
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	64 44       	mov.b	@r4,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	68 44       	mov.b	@r4,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	6c 44       	mov.b	@r4,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	70 44       	br	@r4+		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	74 44       	mov.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	78 44       	mov.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	7c 44       	mov.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	80 44 00 00 	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	84 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8c 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	90 44 00 00 	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	94 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	9c 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a0 44 00 00 	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a4 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	ac 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b0 44 00 00 	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b4 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b8 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c0 44 00 00 	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c4 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c8 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	cc 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 44 00 00 	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d4 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d8 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	dc 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e0 44 00 00 	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	32 cc       	bic	@r12+,	r2	;

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	c6 cb       	bic.b	r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e4 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	e8 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	5a cb       	bic.b,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	f0 44 00 00 	mov.b	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	fe ca       	bic.b	@r10+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	d8 cf       	interrupt service routine at 0xcfd8

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f4 44       	interrupt service routine at 0x44f4

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	9e cc       	interrupt service routine at 0xcc9e

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	ca ce       	interrupt service routine at 0xceca

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	f8 44       	interrupt service routine at 0x44f8

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	fc 44       	interrupt service routine at 0x44fc

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	00 45       	interrupt service routine at 0x4500

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	30 cd       	interrupt service routine at 0xcd30

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	04 45       	interrupt service routine at 0x4504

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	08 45       	interrupt service routine at 0x4508

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	dc ca       	interrupt service routine at 0xcadc

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	0c 45       	interrupt service routine at 0x450c

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	10 45       	interrupt service routine at 0x4510

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	14 45       	interrupt service routine at 0x4514

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	81 00 98 a1 	mova	#41368,	r1	;0x0a198

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
    440c:	8c 00 1c c8 	mova	#51228,	r12	;0x0c81c

00004410 <.Loc.74.1>:
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
    4412:	3e 40 c0 02 	mov	#704,	r14	;#0x02c0

00004416 <.Loc.77.1>:
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
    4418:	b0 13 28 a0 	calla	#41000		;0x0a028

0000441c <__crt0_init_highbss>:
    441c:	8c 01 04 07 	mova	#67332,	r12	;0x10704

00004420 <.Loc.94.1>:
    4420:	0d 43       	clr	r13		;

00004422 <.Loc.95.1>:
    4422:	8e 01 fc 0a 	mova	#68348,	r14	;0x10afc

00004426 <.Loc.98.1>:
    4426:	0e 93       	cmp	#0,	r14	;r3 As==00

00004428 <.Loc.99.1>:
    4428:	02 24       	jz	$+6      	;abs 0x442e

0000442a <.Loc.100.1>:
    442a:	b0 13 28 a0 	calla	#41000		;0x0a028

0000442e <__crt0_move_highdata>:
    442e:	3e 40 1c 00 	mov	#28,	r14	;#0x001c

00004432 <.Loc.146.1>:
    4432:	0e 93       	cmp	#0,	r14	;r3 As==00

00004434 <.Loc.147.1>:
    4434:	14 24       	jz	$+42     	;abs 0x445e

00004436 <.Loc.150.1>:
    4436:	41 18 82 93 	cmpx.w	#0,	&0x106e6;r3 As==00
    443a:	e6 06 

0000443c <.Loc.151.1>:
    443c:	05 24       	jz	$+12     	;abs 0x4448

0000443e <.Loc.153.1>:
    443e:	8c 01 e8 06 	mova	#67304,	r12	;0x106e8

00004442 <.Loc.154.1>:
    4442:	8d 01 e8 06 	mova	#67304,	r13	;0x106e8

00004446 <.Loc.155.1>:
    4446:	07 3c       	jmp	$+16     	;abs 0x4456

00004448 <.L11>:
    4448:	41 18 92 43 	movx.w	#1,	&0x106e6;r3 As==01
    444c:	e6 06 

0000444e <.Loc.159.1>:
    444e:	8c 01 e8 06 	mova	#67304,	r12	;0x106e8

00004452 <.Loc.160.1>:
    4452:	8d 01 e8 06 	mova	#67304,	r13	;0x106e8

00004456 <.L21>:
    4456:	3e 40 1c 00 	mov	#28,	r14	;#0x001c

0000445a <.Loc.165.1>:
    445a:	b0 13 42 a0 	calla	#41026		;0x0a042

0000445e <__crt0_call_just_main>:
    445e:	0c 43       	clr	r12		;

00004460 <.Loc.181.1>:
    4460:	b0 13 08 9e 	calla	#40456		;0x09e08

00004464 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4464:	80 00 64 44 	mova	#17508,	r0	;0x04464

00004468 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    4468:	80 00 68 44 	mova	#17512,	r0	;0x04468

0000446c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    446c:	80 00 6c 44 	mova	#17516,	r0	;0x0446c

00004470 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4470:	80 00 70 44 	mova	#17520,	r0	;0x04470

00004474 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4474:	80 00 74 44 	mova	#17524,	r0	;0x04474

00004478 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    4478:	80 00 78 44 	mova	#17528,	r0	;0x04478

0000447c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    447c:	80 00 7c 44 	mova	#17532,	r0	;0x0447c

00004480 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4480:	80 00 80 44 	mova	#17536,	r0	;0x04480

00004484 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4484:	80 00 84 44 	mova	#17540,	r0	;0x04484

00004488 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    4488:	80 00 88 44 	mova	#17544,	r0	;0x04488

0000448c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    448c:	80 00 8c 44 	mova	#17548,	r0	;0x0448c

00004490 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4490:	80 00 90 44 	mova	#17552,	r0	;0x04490

00004494 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4494:	80 00 94 44 	mova	#17556,	r0	;0x04494

00004498 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    4498:	80 00 98 44 	mova	#17560,	r0	;0x04498

0000449c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    449c:	80 00 9c 44 	mova	#17564,	r0	;0x0449c

000044a0 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    44a0:	80 00 a0 44 	mova	#17568,	r0	;0x044a0

000044a4 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    44a4:	80 00 a4 44 	mova	#17572,	r0	;0x044a4

000044a8 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    44a8:	80 00 a8 44 	mova	#17576,	r0	;0x044a8

000044ac <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    44ac:	80 00 ac 44 	mova	#17580,	r0	;0x044ac

000044b0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    44b0:	80 00 b0 44 	mova	#17584,	r0	;0x044b0

000044b4 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    44b4:	80 00 b4 44 	mova	#17588,	r0	;0x044b4

000044b8 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    44b8:	80 00 b8 44 	mova	#17592,	r0	;0x044b8

000044bc <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    44bc:	80 00 bc 44 	mova	#17596,	r0	;0x044bc

000044c0 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    44c0:	80 00 c0 44 	mova	#17600,	r0	;0x044c0

000044c4 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    44c4:	80 00 c4 44 	mova	#17604,	r0	;0x044c4

000044c8 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    44c8:	80 00 c8 44 	mova	#17608,	r0	;0x044c8

000044cc <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    44cc:	80 00 cc 44 	mova	#17612,	r0	;0x044cc

000044d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44d0:	80 00 d0 44 	mova	#17616,	r0	;0x044d0

000044d4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44d4:	80 00 d4 44 	mova	#17620,	r0	;0x044d4

000044d8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44d8:	80 00 d8 44 	mova	#17624,	r0	;0x044d8

000044dc <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44dc:	80 00 dc 44 	mova	#17628,	r0	;0x044dc

000044e0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44e0:	80 00 e0 44 	mova	#17632,	r0	;0x044e0

000044e4 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44e4:	80 00 e4 44 	mova	#17636,	r0	;0x044e4

000044e8 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44e8:	80 00 e8 44 	mova	#17640,	r0	;0x044e8

000044ec <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44ec:	80 00 ec 44 	mova	#17644,	r0	;0x044ec

000044f0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44f0:	80 00 f0 44 	mova	#17648,	r0	;0x044f0

000044f4 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44f4:	80 00 f4 44 	mova	#17652,	r0	;0x044f4

000044f8 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    44f8:	80 00 f8 44 	mova	#17656,	r0	;0x044f8

000044fc <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44fc:	80 00 fc 44 	mova	#17660,	r0	;0x044fc

00004500 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    4500:	80 00 00 45 	mova	#17664,	r0	;0x04500

00004504 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    4504:	80 00 04 45 	mova	#17668,	r0	;0x04504

00004508 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    4508:	80 00 08 45 	mova	#17672,	r0	;0x04508

0000450c <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    450c:	80 00 0c 45 	mova	#17676,	r0	;0x0450c

00004510 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    4510:	80 00 10 45 	mova	#17680,	r0	;0x04510

00004514 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    4514:	80 00 14 45 	mova	#17684,	r0	;0x04514

00004518 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    4518:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    451c:	4e 07 

0000451e <.Loc.305.1>:
}
    451e:	10 01       	reta			;

00004520 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    4520:	03 43       	nop			

00004522 <.Loc.356.1>:
  _enable_interrupts();
    4522:	03 43       	nop			
    4524:	32 d2       	eint			
    4526:	03 43       	nop			

00004528 <.Loc.357.1>:
}
    4528:	10 01       	reta			;

0000452a <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    452a:	32 c2       	dint			
    452c:	03 43       	nop			

0000452e <.Loc.390.1>:
  asm volatile("nop");
    452e:	03 43       	nop			

00004530 <.Loc.391.1>:
}
    4530:	10 01       	reta			;

00004532 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    4532:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004536 <.LCFI0>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    4536:	80 18 f1 40 	movx.a	#67346,	16(r1)	;0x10712, 0x00010
    453a:	12 07 10 00 

0000453e <.Loc.234.2>:
  tcp = nil_thd_configs;
    453e:	80 18 f1 40 	movx.a	#67242,	12(r1)	;0x106aa, 0x0000c
    4542:	aa 06 0c 00 

00004546 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4546:	80 00 12 46 	mova	#17938,	r0	;0x04612

0000454a <.L6>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    454a:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    454e:	0d 0c       	mova	@r12,	r13	;
    4550:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4554:	7c 0d 10 00 	mova	r13,	16(r12)	; 0x00010

00004558 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4558:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    455c:	3c 0c 04 00 	mova	4(r12),	r12	;
    4560:	cd 0c       	mova	r12,	r13	;
    4562:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    4566:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    456a:	7c 0d 00 00 	mova	r13,	0(r12)	;
    456e:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4572:	0c 0c       	mova	@r12,	r12	;
    4574:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    4578:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    457c:	71 0d 08 00 	mova	r13,	8(r1)	;
    4580:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    4584:	00 00 
    4586:	3e 01 08 00 	mova	8(r1),	r14	;
    458a:	0e 14       	pushm.a	#1,	r14	;20-bit words
    458c:	0d 17       	popm	#1,	r13	;16-bit words
    458e:	0d 17       	popm	#1,	r13	;16-bit words
    4590:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4594:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    4598:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    459c:	4d de       	bis.b	r14,	r13	;
    459e:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    45a2:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    45a6:	0c 0c       	mova	@r12,	r12	;
    45a8:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    45ac:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    45b0:	71 0d 04 00 	mova	r13,	4(r1)	;
    45b4:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    45b8:	04 00 
    45ba:	3e 01 04 00 	mova	4(r1),	r14	;
    45be:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45c0:	0d 17       	popm	#1,	r13	;16-bit words
    45c2:	0d 17       	popm	#1,	r13	;16-bit words
    45c4:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45c8:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    45cc:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45d0:	4d de       	bis.b	r14,	r13	;
    45d2:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    45d6:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    45da:	0c 0c       	mova	@r12,	r12	;
    45dc:	00 18 f1 40 	movx.a	#19664,	0(r1)	;0x04cd0
    45e0:	d0 4c 00 00 
    45e4:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    45e8:	0e 01       	mova	@r1,	r14	;
    45ea:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45ec:	0d 17       	popm	#1,	r13	;16-bit words
    45ee:	0d 17       	popm	#1,	r13	;16-bit words
    45f0:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45f4:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    45f8:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45fc:	4d de       	bis.b	r14,	r13	;
    45fe:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

00004602 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    4602:	00 18 f1 50 	addx.a	#20,	16(r1)	;0x00014, 0x00010
    4606:	14 00 10 00 

0000460a <.Loc.247.2>:
    tcp++;
    460a:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    460e:	14 00 0c 00 

00004612 <.L5>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4612:	80 18 f1 90 	cmpx.a	#67386,	16(r1)	;0x1073a, 0x00010
    4616:	3a 07 10 00 
    461a:	97 2b       	jnc	$-208    	;abs 0x454a

0000461c <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    461c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4620:	00 18 fc 40 	movx.a	#41368,	16(r12)	;0x0a198, 0x00010
    4624:	98 a1 10 00 

00004628 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    4628:	b0 13 2a 45 	calla	#17706		;0x0452a

0000462c <.LVL4>:
  nil.lock_cnt = (cnt_t)1;
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    462c:	b0 13 14 4c 	calla	#19476		;0x04c14

00004630 <.LVL5>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    4630:	b0 13 18 45 	calla	#17688		;0x04518

00004634 <.LVL6>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4634:	81 18 f2 40 	movx.a	#67346,	&0x10708;0x10712
    4638:	12 07 08 07 
    463c:	2c 01 08 07 	mova	&67336,	r12	;0x10708
    4640:	61 0c 04 07 	mova	r12,	&67332	; 0x10704

00004644 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4644:	2c 01 04 07 	mova	&67332,	r12	;0x10704
    4648:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    464c:	b0 13 c4 4c 	calla	#19652		;0x04cc4

00004650 <.LVL7>:
  chSysUnlock();
    4650:	b0 13 20 45 	calla	#17696		;0x04520

00004654 <.LVL8>:
}
    4654:	03 43       	nop			
    4656:	a1 00 14 00 	adda	#20,	r1	;0x00014
    465a:	10 01       	reta			;

0000465c <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    465c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000465e <.LCFI1>:
    465e:	ca 0c       	mova	r12,	r10	;

00004660 <.Loc.293.2>:

  port_disable();
    4660:	b0 13 2a 45 	calla	#17706		;0x0452a

00004664 <.LVL10>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4664:	61 0a 0e 07 	mova	r10,	&67342	; 0x1070e

00004668 <.L8>:
    4668:	80 00 68 46 	mova	#18024,	r0	;0x04668

0000466c <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    466c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000466e <.LCFI2>:
    466e:	08 14       	pushm.a	#1,	r8	;20-bit words

00004670 <.LCFI3>:
    4670:	06 14       	pushm.a	#1,	r6	;20-bit words

00004672 <.LCFI4>:

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    4672:	88 01 04 07 	mova	#67332,	r8	;0x10704
    4676:	98 53 08 00 	inc	8(r8)		;
    467a:	a8 00 14 00 	adda	#20,	r8	;0x00014

0000467e <.Loc.341.2>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    467e:	8a 00 2c 47 	mova	#18220,	r10	;0x0472c
    4682:	86 0f ff ff 	mova	#-1,	r6	;0xffffffff

00004686 <.L17>:
    4686:	cc 08       	mova	r8,	r12	;
    4688:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

0000468c <.LVL13>:
    if (tp->timeout > (systime_t)0) {
    468c:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    4690:	0d 93       	cmp	#0,	r13	;r3 As==00
    4692:	1e 24       	jz	$+62     	;abs 0x46d0

00004694 <.Loc.327.2>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    4694:	5d 48 fe ff 	mov.b	-2(r8),	r13	;
    4698:	0d 93       	cmp	#0,	r13	;r3 As==00
    469a:	0b 20       	jnz	$+24     	;abs 0x46b2

0000469c <.LBB72>:
  port_disable();
    469c:	b0 13 2a 45 	calla	#17706		;0x0452a

000046a0 <.LVL15>:
  nil.dbg_panic_msg = reason;
    46a0:	81 18 f2 40 	movx.a	#65536,	&0x1070e;0x10000
    46a4:	00 00 0e 07 

000046a8 <.L13>:
    46a8:	80 00 a8 46 	mova	#18088,	r0	;0x046a8

000046ac <.L18>:
    46ac:	c8 0c       	mova	r12,	r8	;

000046ae <.LVL17>:
    46ae:	80 00 86 46 	mova	#18054,	r0	;0x04686

000046b2 <.L12>:
      if (--tp->timeout == (systime_t)0) {
    46b2:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    46b6:	3e 53       	add	#-1,	r14	;r3 As==11
    46b8:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a
    46bc:	0e 93       	cmp	#0,	r14	;r3 As==00
    46be:	08 20       	jnz	$+18     	;abs 0x46d0

000046c0 <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    46c0:	7d 90 03 00 	cmp.b	#3,	r13	;
    46c4:	11 20       	jnz	$+36     	;abs 0x46e8

000046c6 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    46c6:	0e 08       	mova	@r8,	r14	;
    46c8:	9e 53 00 00 	inc	0(r14)		;

000046cc <.L16>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    46cc:	cd 06       	mova	r6,	r13	;
    46ce:	4a 13       	calla	r10		;

000046d0 <.L11>:
    46d0:	cc 08       	mova	r8,	r12	;
    46d2:	ac 00 14 00 	adda	#20,	r12	;0x00014

000046d6 <.Loc.349.2>:
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    tp++;
    chSysLockFromISR();
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    46d6:	a8 00 0e 00 	adda	#14,	r8	;0x0000e

000046da <.LVL20>:
    46da:	98 01 3a 07 	cmpa	#67386,	r8	;0x1073a
    46de:	e6 2b       	jnc	$-50     	;abs 0x46ac

000046e0 <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    46e0:	06 16       	popm.a	#1,	r6	;20-bit words
    46e2:	08 16       	popm.a	#1,	r8	;20-bit words
    46e4:	0a 16       	popm.a	#1,	r10	;20-bit words
    46e6:	10 01       	reta			;

000046e8 <.L15>:
        else if (NIL_THD_IS_SUSP(tp)) {
    46e8:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    46ea:	f0 23       	jnz	$-30     	;abs 0x46cc

000046ec <.Loc.338.2>:
          *tp->u1.trp = NULL;
    46ec:	0e 08       	mova	@r8,	r14	;
    46ee:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    46f2:	00 00 
    46f4:	80 00 cc 46 	mova	#18124,	r0	;0x046cc

000046f8 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    46f8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000046fa <.LBB78>:
  return __get_SR_register();
    46fa:	0a 42       	mov	r2,	r10	;

000046fc <.LBE78>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    46fc:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    4700:	06 24       	jz	$+14     	;abs 0x470e

00004702 <.Loc.450.2>:
    if (port_is_isr_context()) {
    4702:	41 18 c2 93 	cmpx.b	#0,	&0x1074e;r3 As==00
    4706:	4e 07 
    4708:	02 20       	jnz	$+6      	;abs 0x470e

0000470a <.Loc.454.2>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    470a:	b0 13 2a 45 	calla	#17706		;0x0452a

0000470e <.L27>:
    }
  }
  return sts;
}
    470e:	0c 4a       	mov	r10,	r12	;
    4710:	0a 16       	popm.a	#1,	r10	;20-bit words
    4712:	10 01       	reta			;

00004714 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    4714:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    4718:	08 24       	jz	$+18     	;abs 0x472a

0000471a <.Loc.472.2>:
    if (port_is_isr_context()) {
    471a:	41 18 c2 93 	cmpx.b	#0,	&0x1074e;r3 As==00
    471e:	4e 07 
    4720:	04 20       	jnz	$+10     	;abs 0x472a

00004722 <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    4722:	b0 13 e2 47 	calla	#18402		;0x047e2

00004726 <.LVL26>:
      chSysUnlock();
    4726:	b0 13 20 45 	calla	#17696		;0x04520

0000472a <.L31>:
    }
  }
}
    472a:	10 01       	reta			;

0000472c <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    472c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000472e <.LCFI6>:
    472e:	b1 00 04 00 	suba	#4,	r1	;

00004732 <.LCFI7>:
    4732:	71 0d 00 00 	mova	r13,	0(r1)	;

00004736 <.Loc.537.2>:

  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    4736:	9c 01 12 07 	cmpa	#67346,	r12	;0x10712
    473a:	03 28       	jnc	$+8      	;abs 0x4742

0000473c <.Loc.537.2>:
    473c:	9c 01 3a 07 	cmpa	#67386,	r12	;0x1073a
    4740:	08 28       	jnc	$+18     	;abs 0x4752

00004742 <.L37>:
  port_disable();
    4742:	b0 13 2a 45 	calla	#17706		;0x0452a

00004746 <.LVL30>:
  nil.dbg_panic_msg = reason;
    4746:	81 18 f2 40 	movx.a	#65555,	&0x1070e;0x10013
    474a:	13 00 0e 07 

0000474e <.L39>:
    474e:	80 00 4e 47 	mova	#18254,	r0	;0x0474e

00004752 <.L38>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    4752:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4756:	08 20       	jnz	$+18     	;abs 0x4768

00004758 <.LBB82>:
  port_disable();
    4758:	b0 13 2a 45 	calla	#17706		;0x0452a

0000475c <.LVL33>:
  nil.dbg_panic_msg = reason;
    475c:	81 18 f2 40 	movx.a	#65555,	&0x1070e;0x10013
    4760:	13 00 0e 07 

00004764 <.L41>:
    4764:	80 00 64 47 	mova	#18276,	r0	;0x04764

00004768 <.L40>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    4768:	8e 01 04 07 	mova	#67332,	r14	;0x10704
    476c:	3a 0e 04 00 	mova	4(r14),	r10	;
    4770:	01 18 c2 9a 	cmpx.a	r10,	&0x10704;
    4774:	04 07 
    4776:	08 2c       	jc	$+18     	;abs 0x4788

00004778 <.LBB84>:
  port_disable();
    4778:	b0 13 2a 45 	calla	#17706		;0x0452a

0000477c <.LVL36>:
  nil.dbg_panic_msg = reason;
    477c:	81 18 f2 40 	movx.a	#65555,	&0x1070e;0x10013
    4780:	13 00 0e 07 

00004784 <.L43>:
    4784:	80 00 84 47 	mova	#18308,	r0	;0x04784

00004788 <.L42>:

  tp->u1.msg = msg;
    4788:	ac 41 06 00 	mov	@r1,	6(r12)	;
    478c:	0f 01       	mova	@r1,	r15	;
    478e:	0f 14       	pushm.a	#1,	r15	;20-bit words
    4790:	0d 17       	popm	#1,	r13	;16-bit words
    4792:	0d 17       	popm	#1,	r13	;16-bit words

00004794 <.LVL38>:
    4794:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4798:	5f 4c 08 00 	mov.b	8(r12),	r15	;
    479c:	7f f0 f0 ff 	and.b	#-16,	r15	;#0xfff0
    47a0:	4f dd       	bis.b	r13,	r15	;
    47a2:	cc 4f 08 00 	mov.b	r15,	8(r12)	;

000047a6 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    47a6:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

000047aa <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    47aa:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000047ae <.Loc.544.2>:
  if (tp < nil.next) {
    47ae:	dc 0a       	cmpa	r10,	r12	;
    47b0:	02 2c       	jc	$+6      	;abs 0x47b6

000047b2 <.Loc.545.2>:
    nil.next = tp;
    47b2:	7e 0c 04 00 	mova	r12,	4(r14)	;

000047b6 <.L44>:
  }
  return tp;
}
    47b6:	a1 00 04 00 	adda	#4,	r1	;

000047ba <.LVL39>:
    47ba:	0a 16       	popm.a	#1,	r10	;20-bit words
    47bc:	10 01       	reta			;

000047be <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    47be:	5c 43       	mov.b	#1,	r12	;r3 As==01
    47c0:	81 18 d2 92 	cmpx.a	&0x10708,&0x10704;
    47c4:	08 07 04 07 
    47c8:	01 20       	jnz	$+4      	;abs 0x47cc
    47ca:	4c 43       	clr.b	r12		;

000047cc <.L46>:
}
    47cc:	10 01       	reta			;

000047ce <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    47ce:	8e 01 04 07 	mova	#67332,	r14	;0x10704
    47d2:	0d 0e       	mova	@r14,	r13	;

000047d4 <.LVL40>:

  nil.current = nil.next;
    47d4:	3c 0e 04 00 	mova	4(r14),	r12	;
    47d8:	7e 0c 00 00 	mova	r12,	0(r14)	;

000047dc <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    47dc:	b0 13 c4 4c 	calla	#19652		;0x04cc4

000047e0 <.LVL41>:
}
    47e0:	10 01       	reta			;

000047e2 <chSchRescheduleS>:
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    47e2:	81 18 d2 92 	cmpx.a	&0x10708,&0x10704;
    47e6:	08 07 04 07 
    47ea:	02 24       	jz	$+6      	;abs 0x47f0

000047ec <.Loc.595.2>:
    chSchDoReschedule();
    47ec:	b0 13 ce 47 	calla	#18382		;0x047ce

000047f0 <.L48>:
  }
}
    47f0:	10 01       	reta			;

000047f2 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    47f2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047f4 <.LCFI8>:
    47f4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000047f8 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    47f8:	8a 01 04 07 	mova	#67332,	r10	;0x10704
    47fc:	0e 0a       	mova	@r10,	r14	;

000047fe <.LVL44>:

  chDbgCheckClassS();

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    47fe:	9e 01 3a 07 	cmpa	#67386,	r14	;0x1073a
    4802:	08 20       	jnz	$+18     	;abs 0x4814

00004804 <.LBB86>:
  port_disable();
    4804:	b0 13 2a 45 	calla	#17706		;0x0452a

00004808 <.LVL46>:
  nil.dbg_panic_msg = reason;
    4808:	81 18 f2 40 	movx.a	#65567,	&0x1070e;0x1001f
    480c:	1f 00 0e 07 

00004810 <.L52>:
    4810:	80 00 10 48 	mova	#18448,	r0	;0x04810

00004814 <.L51>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    4814:	ce 4c 04 00 	mov.b	r12,	4(r14)	;

00004818 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    4818:	8e 4d 0a 00 	mov	r13,	10(r14)	; 0x000a

0000481c <.LVL48>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    481c:	cc 0a       	mova	r10,	r12	;
    481e:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00004822 <.L54>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    4822:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4826:	0c 20       	jnz	$+26     	;abs 0x4840

00004828 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    4828:	7a 0c 04 00 	mova	r12,	4(r10)	;
    482c:	7a 0c 00 00 	mova	r12,	0(r10)	;

00004830 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    4830:	cd 0e       	mova	r14,	r13	;
    4832:	b0 13 c4 4c 	calla	#19652		;0x04cc4

00004836 <.LVL50>:
      return nil.current->u1.msg;
    4836:	0c 0a       	mova	@r10,	r12	;
    4838:	3c 0c 06 00 	mova	6(r12),	r12	;

0000483c <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    483c:	0a 16       	popm.a	#1,	r10	;20-bit words
    483e:	10 01       	reta			;

00004840 <.L53>:
    ntp++;
    4840:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004844 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    4844:	8d 01 3a 07 	mova	#67386,	r13	;0x1073a
    4848:	dd 0c       	cmpa	r12,	r13	;
    484a:	eb 2f       	jc	$-40     	;abs 0x4822

0000484c <.LBB88>:
  port_disable();
    484c:	b0 13 2a 45 	calla	#17706		;0x0452a

00004850 <.LVL54>:
  nil.dbg_panic_msg = reason;
    4850:	81 18 f2 40 	movx.a	#65567,	&0x1070e;0x1001f
    4854:	1f 00 0e 07 

00004858 <.L55>:
    4858:	80 00 58 48 	mova	#18520,	r0	;0x04858

0000485c <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    485c:	ce 0c       	mova	r12,	r14	;

0000485e <.Loc.718.2>:

  if (*trp != NULL) {
    485e:	0c 0c       	mova	@r12,	r12	;

00004860 <.LVL62>:
    4860:	9c 00 00 00 	cmpa	#0,	r12	;
    4864:	10 24       	jz	$+34     	;abs 0x4886

00004866 <.LBB92>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4866:	ec 93 04 00 	cmp.b	#2,	4(r12)	;r3 As==10
    486a:	08 24       	jz	$+18     	;abs 0x487c

0000486c <.LBB93>:
  port_disable();
    486c:	b0 13 2a 45 	calla	#17706		;0x0452a

00004870 <.LVL65>:
  nil.dbg_panic_msg = reason;
    4870:	81 18 f2 40 	movx.a	#65609,	&0x1070e;0x10049
    4874:	49 00 0e 07 

00004878 <.L64>:
    4878:	80 00 78 48 	mova	#18552,	r0	;0x04878

0000487c <.L63>:

    *trp = NULL;
    487c:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    4880:	00 00 

00004882 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    4882:	b0 13 2c 47 	calla	#18220		;0x0472c

00004886 <.L61>:
  }
}
    4886:	10 01       	reta			;

00004888 <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    4888:	b1 00 08 00 	suba	#8,	r1	;

0000488c <.LCFI11>:
  msg_t msg;

  chSysLock();
    488c:	71 0c 00 00 	mova	r12,	0(r1)	;
    4890:	71 0d 04 00 	mova	r13,	4(r1)	;
    4894:	b0 13 2a 45 	calla	#17706		;0x0452a

00004898 <.LVL78>:
  msg = chSemWaitTimeoutS(sp, timeout);
    4898:	3d 01 04 00 	mova	4(r1),	r13	;
    489c:	0c 01       	mova	@r1,	r12	;
    489e:	b0 13 b2 48 	calla	#18610		;0x048b2

000048a2 <.LVL79>:
  chSysUnlock();
    48a2:	71 0c 00 00 	mova	r12,	0(r1)	;
    48a6:	b0 13 20 45 	calla	#17696		;0x04520

000048aa <.LVL80>:

  return msg;
}
    48aa:	0c 01       	mova	@r1,	r12	;
    48ac:	a1 00 08 00 	adda	#8,	r1	;
    48b0:	10 01       	reta			;

000048b2 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    48b2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000048b4 <.LCFI12>:

  chDbgCheckClassS();
  chDbgCheck(sp != NULL);
    48b4:	9c 00 00 00 	cmpa	#0,	r12	;
    48b8:	08 20       	jnz	$+18     	;abs 0x48ca

000048ba <.LBB95>:
  port_disable();
    48ba:	b0 13 2a 45 	calla	#17706		;0x0452a

000048be <.LVL83>:
  nil.dbg_panic_msg = reason;
    48be:	81 18 f2 40 	movx.a	#65622,	&0x1070e;0x10056
    48c2:	56 00 0e 07 

000048c6 <.L73>:
    48c6:	80 00 c6 48 	mova	#18630,	r0	;0x048c6

000048ca <.L72>:

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    48ca:	2e 4c       	mov	@r12,	r14	;

000048cc <.LVL85>:
  if (cnt <= (cnt_t)0) {
    48cc:	4a 43       	clr.b	r10		;
    48ce:	0a 9e       	cmp	r14,	r10	;
    48d0:	0f 38       	jl	$+32     	;abs 0x48f0

000048d2 <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    48d2:	3d 93       	cmp	#-1,	r13	;r3 As==11
    48d4:	13 24       	jz	$+40     	;abs 0x48fc

000048d6 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    48d6:	3e 53       	add	#-1,	r14	;r3 As==11

000048d8 <.LVL86>:
    48d8:	8c 4e 00 00 	mov	r14,	0(r12)	;

000048dc <.Loc.819.2>:
    nil.current->u1.semp = sp;
    48dc:	2e 01 04 07 	mova	&67332,	r14	;0x10704

000048e0 <.LVL87>:
    48e0:	7e 0c 06 00 	mova	r12,	6(r14)	;

000048e4 <.LVL88>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    48e4:	7c 40 03 00 	mov.b	#3,	r12	;

000048e8 <.LVL89>:
    48e8:	b0 13 f2 47 	calla	#18418		;0x047f2

000048ec <.L71>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    48ec:	0a 16       	popm.a	#1,	r10	;20-bit words
    48ee:	10 01       	reta			;

000048f0 <.L74>:
  sp->cnt = cnt - (cnt_t)1;
    48f0:	3e 53       	add	#-1,	r14	;r3 As==11

000048f2 <.LVL92>:
    48f2:	8c 4e 00 00 	mov	r14,	0(r12)	;

000048f6 <.Loc.823.2>:
  return MSG_OK;
    48f6:	4c 43       	clr.b	r12		;

000048f8 <.LVL93>:
    48f8:	80 00 ec 48 	mova	#18668,	r0	;0x048ec

000048fc <.L76>:
      return MSG_TIMEOUT;
    48fc:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004900 <.LVL95>:
    4900:	80 00 ec 48 	mova	#18668,	r0	;0x048ec

00004904 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    4904:	ce 0c       	mova	r12,	r14	;

00004906 <.Loc.855.2>:

  chDbgCheckClassI();
  chDbgCheck(sp != NULL);
    4906:	9c 00 00 00 	cmpa	#0,	r12	;
    490a:	08 20       	jnz	$+18     	;abs 0x491c

0000490c <.LBB109>:
  port_disable();
    490c:	b0 13 2a 45 	calla	#17706		;0x0452a

00004910 <.LVL103>:
  nil.dbg_panic_msg = reason;
    4910:	81 18 f2 40 	movx.a	#65640,	&0x1070e;0x10068
    4914:	68 00 0e 07 

00004918 <.L80>:
    4918:	80 00 18 49 	mova	#18712,	r0	;0x04918

0000491c <.L79>:

  if (++sp->cnt <= (cnt_t)0) {
    491c:	2c 4c       	mov	@r12,	r12	;

0000491e <.LVL105>:
    491e:	1c 53       	inc	r12		;
    4920:	8e 4c 00 00 	mov	r12,	0(r14)	;
    4924:	4d 43       	clr.b	r13		;
    4926:	0d 9c       	cmp	r12,	r13	;
    4928:	15 38       	jl	$+44     	;abs 0x4954
    492a:	8c 01 12 07 	mova	#67346,	r12	;0x10712

0000492e <.L85>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    492e:	00 18 5e 9c 	cmpx.a	6(r12),	r14	;
    4932:	06 00 
    4934:	10 20       	jnz	$+34     	;abs 0x4956

00004936 <.Loc.863.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4936:	fc 90 03 00 	cmp.b	#3,	4(r12)	;
    493a:	04 00 
    493c:	08 24       	jz	$+18     	;abs 0x494e

0000493e <.LBB114>:
  port_disable();
    493e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004942 <.LVL108>:
  nil.dbg_panic_msg = reason;
    4942:	81 18 f2 40 	movx.a	#65640,	&0x1070e;0x10068
    4946:	68 00 0e 07 

0000494a <.L84>:
    494a:	80 00 4a 49 	mova	#18762,	r0	;0x0494a

0000494e <.L83>:

        (void) chSchReadyI(tr, MSG_OK);
    494e:	4d 43       	clr.b	r13		;
    4950:	b0 13 2c 47 	calla	#18220		;0x0472c

00004954 <.L78>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4954:	10 01       	reta			;

00004956 <.L82>:
      tr++;
    4956:	ac 00 14 00 	adda	#20,	r12	;0x00014

0000495a <.Loc.870.2>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    495a:	9c 01 3a 07 	cmpa	#67386,	r12	;0x1073a
    495e:	e7 2b       	jnc	$-48     	;abs 0x492e

00004960 <.LBB116>:
  port_disable();
    4960:	b0 13 2a 45 	calla	#17706		;0x0452a

00004964 <.LVL114>:
  nil.dbg_panic_msg = reason;
    4964:	81 18 f2 40 	movx.a	#65640,	&0x1070e;0x10068
    4968:	68 00 0e 07 

0000496c <.L86>:
    496c:	80 00 6c 49 	mova	#18796,	r0	;0x0496c

00004970 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    4970:	19 14       	pushm.a	#2,	r9	;20-bit words

00004972 <.LCFI17>:
    4972:	b1 00 04 00 	suba	#4,	r1	;

00004976 <.LCFI18>:
    4976:	08 4d       	mov	r13,	r8	;
    4978:	09 4e       	mov	r14,	r9	;

0000497a <.Loc.951.2>:

  chSysLock();
    497a:	71 0c 00 00 	mova	r12,	0(r1)	;
    497e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004982 <.LVL138>:
  chEvtSignalI(tp, mask);
    4982:	0d 48       	mov	r8,	r13	;
    4984:	0e 49       	mov	r9,	r14	;
    4986:	0c 01       	mova	@r1,	r12	;
    4988:	b0 13 9c 49 	calla	#18844		;0x0499c

0000498c <.LVL139>:
  chSchRescheduleS();
    498c:	b0 13 e2 47 	calla	#18402		;0x047e2

00004990 <.LVL140>:
  chSysUnlock();
    4990:	b0 13 20 45 	calla	#17696		;0x04520

00004994 <.LVL141>:
}
    4994:	a1 00 04 00 	adda	#4,	r1	;
    4998:	18 16       	popm.a	#2,	r9	;20-bit words
    499a:	10 01       	reta			;

0000499c <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    499c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000499e <.LCFI19>:
    499e:	ca 0c       	mova	r12,	r10	;

000049a0 <.Loc.972.2>:

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    49a0:	9c 00 00 00 	cmpa	#0,	r12	;
    49a4:	08 20       	jnz	$+18     	;abs 0x49b6

000049a6 <.LBB127>:
  port_disable();
    49a6:	b0 13 2a 45 	calla	#17706		;0x0452a

000049aa <.LVL144>:
  nil.dbg_panic_msg = reason;
    49aa:	81 18 f2 40 	movx.a	#65665,	&0x1070e;0x10081
    49ae:	81 00 0e 07 

000049b2 <.L106>:
    49b2:	80 00 b2 49 	mova	#18866,	r0	;0x049b2

000049b6 <.L105>:

  tp->epmask |= mask;
    49b6:	1d dc 0c 00 	bis	12(r12),r13	;0x0000c

000049ba <.LVL146>:
    49ba:	1e dc 0e 00 	bis	14(r12),r14	;0x0000e
    49be:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
    49c2:	8c 4e 0e 00 	mov	r14,	14(r12)	; 0x000e

000049c6 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49c6:	ec 92 04 00 	cmp.b	#4,	4(r12)	;r2 As==10
    49ca:	0a 20       	jnz	$+22     	;abs 0x49e0

000049cc <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    49cc:	1d fc 06 00 	and	6(r12),	r13	;
    49d0:	1e fc 08 00 	and	8(r12),	r14	;

000049d4 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49d4:	0d de       	bis	r14,	r13	;
    49d6:	0d 93       	cmp	#0,	r13	;r3 As==00
    49d8:	03 24       	jz	$+8      	;abs 0x49e0

000049da <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    49da:	4d 43       	clr.b	r13		;
    49dc:	b0 13 2c 47 	calla	#18220		;0x0472c

000049e0 <.L104>:
  }
}
    49e0:	0a 16       	popm.a	#1,	r10	;20-bit words
    49e2:	10 01       	reta			;

000049e4 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    49e4:	6a 14       	pushm.a	#7,	r10	;20-bit words

000049e6 <.LCFI20>:
    49e6:	06 4c       	mov	r12,	r6	;
    49e8:	07 4d       	mov	r13,	r7	;
    49ea:	05 4e       	mov	r14,	r5	;

000049ec <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    49ec:	2a 01 04 07 	mova	&67332,	r10	;0x10704

000049f0 <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    49f0:	b0 13 2a 45 	calla	#17706		;0x0452a

000049f4 <.LVL150>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    49f4:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    49f8:	08 f6       	and	r6,	r8	;
    49fa:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    49fe:	09 f7       	and	r7,	r9	;

00004a00 <.LVL151>:
    4a00:	0c 48       	mov	r8,	r12	;
    4a02:	0c d9       	bis	r9,	r12	;
    4a04:	84 00 20 45 	mova	#17696,	r4	;0x04520
    4a08:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a0a:	18 20       	jnz	$+50     	;abs 0x4a3c

00004a0c <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4a0c:	35 93       	cmp	#-1,	r5	;r3 As==11
    4a0e:	05 20       	jnz	$+12     	;abs 0x4a1a

00004a10 <.L117>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    4a10:	44 13       	calla	r4		;

00004a12 <.LVL153>:

  return m;
}
    4a12:	0c 48       	mov	r8,	r12	;
    4a14:	0d 49       	mov	r9,	r13	;
    4a16:	64 16       	popm.a	#7,	r10	;20-bit words
    4a18:	10 01       	reta			;

00004a1a <.L114>:
    ctp->u1.ewmask = mask;
    4a1a:	8a 46 06 00 	mov	r6,	6(r10)	;
    4a1e:	8a 47 08 00 	mov	r7,	8(r10)	;

00004a22 <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4a22:	0d 45       	mov	r5,	r13	;
    4a24:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4a26:	b0 13 f2 47 	calla	#18418		;0x047f2

00004a2a <.LVL155>:
    4a2a:	9c 00 00 00 	cmpa	#0,	r12	;
    4a2e:	f0 3b       	jl	$-30     	;abs 0x4a10

00004a30 <.Loc.1016.2>:
    m = ctp->epmask & mask;
    4a30:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

00004a34 <.LVL156>:
    4a34:	08 f6       	and	r6,	r8	;
    4a36:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4a3a:	09 f7       	and	r7,	r9	;

00004a3c <.L113>:
  ctp->epmask &= ~m;
    4a3c:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    4a40:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e
    4a44:	80 00 10 4a 	mova	#18960,	r0	;0x04a10

00004a48 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4a48:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a4a <.LCFI4>:
    4a4a:	08 14       	pushm.a	#1,	r8	;20-bit words

00004a4c <.LCFI5>:
    4a4c:	06 14       	pushm.a	#1,	r6	;20-bit words

00004a4e <.LCFI6>:
    4a4e:	ca 0c       	mova	r12,	r10	;
    4a50:	c6 0d       	mova	r13,	r6	;
    4a52:	08 4e       	mov	r14,	r8	;

00004a54 <.Loc.188.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);
    4a54:	9c 00 00 00 	cmpa	#0,	r12	;
    4a58:	04 20       	jnz	$+10     	;abs 0x4a62

00004a5a <.Loc.188.1>:
    4a5a:	8c 01 cc 00 	mova	#65740,	r12	;0x100cc

00004a5e <.LVL13>:
    4a5e:	b0 13 5c 46 	calla	#18012		;0x0465c

00004a62 <.L13>:

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4a62:	0d 48       	mov	r8,	r13	;
    4a64:	cc 0a       	mova	r10,	r12	;
    4a66:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4a6a:	b0 13 b2 48 	calla	#18610		;0x048b2

00004a6e <.LVL15>:
    4a6e:	c8 0c       	mova	r12,	r8	;

00004a70 <.LVL16>:
  if (rdymsg == MSG_OK) {
    4a70:	9c 00 00 00 	cmpa	#0,	r12	;
    4a74:	17 20       	jnz	$+48     	;abs 0x4aa4

00004a76 <.LBB12>:
    *mbp->wrptr++ = msg;
    4a76:	3e 0a 08 00 	mova	8(r10),	r14	;
    4a7a:	cc 0e       	mova	r14,	r12	;
    4a7c:	ac 00 04 00 	adda	#4,	r12	;
    4a80:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4a84:	7e 06 00 00 	mova	r6,	0(r14)	;

00004a88 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4a88:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4a8c:	04 00 
    4a8e:	03 28       	jnc	$+8      	;abs 0x4a96

00004a90 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4a90:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4a94:	08 00 

00004a96 <.L15>:
    }
    chSemSignalI(&mbp->fullsem);
    4a96:	cc 0a       	mova	r10,	r12	;
    4a98:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4a9c:	b0 13 04 49 	calla	#18692		;0x04904

00004aa0 <.LVL18>:
    chSchRescheduleS();
    4aa0:	b0 13 e2 47 	calla	#18402		;0x047e2

00004aa4 <.L12>:
  }

  return rdymsg;
}
    4aa4:	cc 08       	mova	r8,	r12	;
    4aa6:	06 16       	popm.a	#1,	r6	;20-bit words
    4aa8:	08 16       	popm.a	#1,	r8	;20-bit words
    4aaa:	0a 16       	popm.a	#1,	r10	;20-bit words
    4aac:	10 01       	reta			;

00004aae <chMBPost>:
  _disable_interrupts();
    4aae:	32 c2       	dint			
    4ab0:	03 43       	nop			

00004ab2 <.Loc.348.2>:
  asm volatile("nop");
    4ab2:	03 43       	nop			

00004ab4 <.LBE18>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4ab4:	b0 13 48 4a 	calla	#19016		;0x04a48

00004ab8 <.LBB20>:
  asm volatile("nop");
    4ab8:	03 43       	nop			

00004aba <.Loc.356.2>:
  _enable_interrupts();
    4aba:	03 43       	nop			
    4abc:	32 d2       	eint			
    4abe:	03 43       	nop			

00004ac0 <.LBE20>:
}
    4ac0:	10 01       	reta			;

00004ac2 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4ac2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ac4 <.LCFI7>:
    4ac4:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ac6 <.LCFI8>:
    4ac6:	ca 0c       	mova	r12,	r10	;
    4ac8:	c8 0d       	mova	r13,	r8	;

00004aca <.Loc.220.1>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);
    4aca:	9c 00 00 00 	cmpa	#0,	r12	;
    4ace:	04 20       	jnz	$+10     	;abs 0x4ad8

00004ad0 <.Loc.220.1>:
    4ad0:	8c 01 c2 00 	mova	#65730,	r12	;0x100c2

00004ad4 <.LVL23>:
    4ad4:	b0 13 5c 46 	calla	#18012		;0x0465c

00004ad8 <.L18>:

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    4ad8:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    4adc:	4d 43       	clr.b	r13		;
    4ade:	0d 9c       	cmp	r12,	r13	;
    4ae0:	1b 34       	jge	$+56     	;abs 0x4b18

00004ae2 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4ae2:	ba 53 12 00 	add	#-1,	18(r10)	;r3 As==11, 0x0012

00004ae6 <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4ae6:	3e 0a 08 00 	mova	8(r10),	r14	;
    4aea:	cc 0e       	mova	r14,	r12	;
    4aec:	ac 00 04 00 	adda	#4,	r12	;
    4af0:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4af4:	7e 08 00 00 	mova	r8,	0(r14)	;

00004af8 <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4af8:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4afc:	04 00 
    4afe:	03 28       	jnc	$+8      	;abs 0x4b06

00004b00 <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4b00:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4b04:	08 00 

00004b06 <.L20>:
  }
  chSemSignalI(&mbp->fullsem);
    4b06:	cc 0a       	mova	r10,	r12	;
    4b08:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b0c:	b0 13 04 49 	calla	#18692		;0x04904

00004b10 <.LVL25>:

  return MSG_OK;
    4b10:	4c 43       	clr.b	r12		;

00004b12 <.L17>:
}
    4b12:	08 16       	popm.a	#1,	r8	;20-bit words
    4b14:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b16:	10 01       	reta			;

00004b18 <.L21>:
    return MSG_TIMEOUT;
    4b18:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    4b1c:	80 00 12 4b 	mova	#19218,	r0	;0x04b12

00004b20 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4b20:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b22 <.LCFI14>:
    4b22:	08 14       	pushm.a	#1,	r8	;20-bit words

00004b24 <.LCFI15>:
    4b24:	06 14       	pushm.a	#1,	r6	;20-bit words

00004b26 <.LCFI16>:
    4b26:	ca 0c       	mova	r12,	r10	;
    4b28:	c8 0d       	mova	r13,	r8	;
    4b2a:	06 4e       	mov	r14,	r6	;

00004b2c <.Loc.387.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4b2c:	9c 00 00 00 	cmpa	#0,	r12	;
    4b30:	03 24       	jz	$+8      	;abs 0x4b38

00004b32 <.Loc.387.1>:
    4b32:	9d 00 00 00 	cmpa	#0,	r13	;
    4b36:	04 20       	jnz	$+10     	;abs 0x4b40

00004b38 <.L33>:
    4b38:	8c 01 99 00 	mova	#65689,	r12	;0x10099

00004b3c <.LVL41>:
    4b3c:	b0 13 5c 46 	calla	#18012		;0x0465c

00004b40 <.L34>:

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4b40:	0d 46       	mov	r6,	r13	;
    4b42:	cc 0a       	mova	r10,	r12	;
    4b44:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b48:	b0 13 b2 48 	calla	#18610		;0x048b2

00004b4c <.LVL43>:
    4b4c:	c6 0c       	mova	r12,	r6	;

00004b4e <.LVL44>:
  if (rdymsg == MSG_OK) {
    4b4e:	9c 00 00 00 	cmpa	#0,	r12	;
    4b52:	18 20       	jnz	$+50     	;abs 0x4b84

00004b54 <.LBB36>:
    *msgp = *mbp->rdptr++;
    4b54:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4b58:	ce 0c       	mova	r12,	r14	;
    4b5a:	ae 00 04 00 	adda	#4,	r14	;
    4b5e:	7a 0e 0c 00 	mova	r14,	12(r10)	; 0x0000c
    4b62:	00 18 e8 4c 	movx.a	@r12,	0(r8)	;
    4b66:	00 00 

00004b68 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4b68:	00 18 5e 9a 	cmpx.a	4(r10),	r14	;
    4b6c:	04 00 
    4b6e:	03 28       	jnc	$+8      	;abs 0x4b76

00004b70 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4b70:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4b74:	0c 00 

00004b76 <.L36>:
    }
    chSemSignalI(&mbp->emptysem);
    4b76:	cc 0a       	mova	r10,	r12	;
    4b78:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4b7c:	b0 13 04 49 	calla	#18692		;0x04904

00004b80 <.LVL46>:
    chSchRescheduleS();
    4b80:	b0 13 e2 47 	calla	#18402		;0x047e2

00004b84 <.L32>:
  }

  return rdymsg;
}
    4b84:	cc 06       	mova	r6,	r12	;
    4b86:	06 16       	popm.a	#1,	r6	;20-bit words
    4b88:	08 16       	popm.a	#1,	r8	;20-bit words
    4b8a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b8c:	10 01       	reta			;

00004b8e <chMBFetch>:
  _disable_interrupts();
    4b8e:	32 c2       	dint			
    4b90:	03 43       	nop			

00004b92 <.Loc.348.2>:
  asm volatile("nop");
    4b92:	03 43       	nop			

00004b94 <.LBE42>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4b94:	b0 13 20 4b 	calla	#19232		;0x04b20

00004b98 <.LBB44>:
  asm volatile("nop");
    4b98:	03 43       	nop			

00004b9a <.Loc.356.2>:
  _enable_interrupts();
    4b9a:	03 43       	nop			
    4b9c:	32 d2       	eint			
    4b9e:	03 43       	nop			

00004ba0 <.LBE44>:
}
    4ba0:	10 01       	reta			;

00004ba2 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    4ba2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ba4 <.LCFI0>:
    4ba4:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ba6 <.LCFI1>:
    4ba6:	ca 0c       	mova	r12,	r10	;
    4ba8:	40 18 08 4d 	movx.w	r13,	r8	;

00004bac <.Loc.112.1>:
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    4bac:	0d 93       	cmp	#0,	r13	;r3 As==00
    4bae:	06 24       	jz	$+14     	;abs 0x4bbc

00004bb0 <.Loc.112.1>:
    4bb0:	cc 08       	mova	r8,	r12	;

00004bb2 <.LVL1>:
    4bb2:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4bb6:	00 18 4c b8 	bitx.a	r8,	r12	;
    4bba:	04 24       	jz	$+10     	;abs 0x4bc4

00004bbc <.L3>:
    4bbc:	8c 01 f0 00 	mova	#65776,	r12	;0x100f0
    4bc0:	b0 13 5c 46 	calla	#18012		;0x0465c

00004bc4 <.L4>:

  size = MEM_ALIGN_NEXT(size, align);
    4bc4:	ce 0a       	mova	r10,	r14	;
    4bc6:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    4bca:	ee 08       	adda	r8,	r14	;
    4bcc:	00 18 4a 43 	clrx.a	r10		;
    4bd0:	fa 08       	suba	r8,	r10	;

00004bd2 <.LVL3>:
    4bd2:	00 18 4e fa 	andx.a	r10,	r14	;

00004bd6 <.LVL4>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    4bd6:	2c 00 20 c8 	mova	&51232,	r12	;0x0c820
    4bda:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4bde:	ec 08       	adda	r8,	r12	;
    4be0:	00 18 4c fa 	andx.a	r10,	r12	;

00004be4 <.LVL5>:

  if (((size_t)endmem - (size_t)p) < size) {
    4be4:	2a 00 1c c8 	mova	&51228,	r10	;0x0c81c
    4be8:	fa 0c       	suba	r12,	r10	;
    4bea:	da 0e       	cmpa	r14,	r10	;
    4bec:	06 28       	jnc	$+14     	;abs 0x4bfa

00004bee <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    4bee:	ee 0c       	adda	r12,	r14	;

00004bf0 <.LVL6>:
    4bf0:	60 0e 20 c8 	mova	r14,	&51232	; 0x0c820

00004bf4 <.L2>:

  return p;
}
    4bf4:	08 16       	popm.a	#1,	r8	;20-bit words
    4bf6:	0a 16       	popm.a	#1,	r10	;20-bit words
    4bf8:	10 01       	reta			;

00004bfa <.L6>:
    return NULL;
    4bfa:	4c 43       	clr.b	r12		;

00004bfc <.LVL9>:
    4bfc:	80 00 f4 4b 	mova	#19444,	r0	;0x04bf4

00004c00 <chCoreAllocAligned>:
  _disable_interrupts();
    4c00:	32 c2       	dint			
    4c02:	03 43       	nop			

00004c04 <.Loc.348.2>:
  asm volatile("nop");
    4c04:	03 43       	nop			

00004c06 <.LBE6>:
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  void *p;

  chSysLock();
  p = chCoreAllocAlignedI(size, align);
    4c06:	b0 13 a2 4b 	calla	#19362		;0x04ba2

00004c0a <.LBB8>:
  asm volatile("nop");
    4c0a:	03 43       	nop			

00004c0c <.Loc.356.2>:
  _enable_interrupts();
    4c0c:	03 43       	nop			
    4c0e:	32 d2       	eint			
    4c10:	03 43       	nop			

00004c12 <.LBE8>:
  chSysUnlock();

  return p;
}
    4c12:	10 01       	reta			;

00004c14 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    4c14:	8c 00 24 c8 	mova	#51236,	r12	;0x0c824
    4c18:	00 18 fc 40 	movx.a	#19456,	0(r12)	;0x04c00
    4c1c:	00 4c 00 00 

00004c20 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    4c20:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4c24:	04 00 

00004c26 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    4c26:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    4c2a:	fc f0 f0 ff 	and.b	#-16,	10(r12)	;#0xfff0, 0x000a
    4c2e:	0a 00 

00004c30 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    4c30:	9c 43 0c 00 	mov	#1,	12(r12)	;r3 As==01, 0x000c

00004c34 <.Loc.117.1>:
#endif
}
    4c34:	10 01       	reta			;

00004c36 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4c36:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c38 <.LCFI3>:
    4c38:	ca 0c       	mova	r12,	r10	;

00004c3a <.Loc.125.1>:
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);
    4c3a:	9c 00 00 00 	cmpa	#0,	r12	;
    4c3e:	04 20       	jnz	$+10     	;abs 0x4c48

00004c40 <.Loc.125.1>:
    4c40:	8c 01 27 01 	mova	#65831,	r12	;0x10127

00004c44 <.LVL5>:
    4c44:	b0 13 5c 46 	calla	#18012		;0x0465c

00004c48 <.L8>:

  objp = mp->next;
    4c48:	0c 0a       	mova	@r10,	r12	;

00004c4a <.LVL7>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4c4a:	9c 00 00 00 	cmpa	#0,	r12	;
    4c4e:	05 24       	jz	$+12     	;abs 0x4c5a

00004c50 <.Loc.130.1>:
    mp->next = mp->next->next;
    4c50:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4c54:	00 00 

00004c56 <.L7>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4c56:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c58:	10 01       	reta			;

00004c5a <.L9>:
  else if (mp->provider != NULL) {
    4c5a:	3e 0a 08 00 	mova	8(r10),	r14	;
    4c5e:	9e 00 00 00 	cmpa	#0,	r14	;
    4c62:	f9 27       	jz	$-12     	;abs 0x4c56

00004c64 <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4c64:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4c66:	3c 0a 04 00 	mova	4(r10),	r12	;

00004c6a <.LVL8>:
    4c6a:	4e 13       	calla	r14		;

00004c6c <.LVL9>:
  return objp;
    4c6c:	80 00 56 4c 	mova	#19542,	r0	;0x04c56

00004c70 <chPoolAlloc>:
  _disable_interrupts();
    4c70:	32 c2       	dint			
    4c72:	03 43       	nop			

00004c74 <.Loc.348.2>:
  asm volatile("nop");
    4c74:	03 43       	nop			

00004c76 <.LBE10>:
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
    4c76:	b0 13 36 4c 	calla	#19510		;0x04c36

00004c7a <.LBB12>:
  asm volatile("nop");
    4c7a:	03 43       	nop			

00004c7c <.Loc.356.2>:
  _enable_interrupts();
    4c7c:	03 43       	nop			
    4c7e:	32 d2       	eint			
    4c80:	03 43       	nop			

00004c82 <.LBE12>:
  chSysUnlock();

  return objp;
}
    4c82:	10 01       	reta			;

00004c84 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4c84:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c86 <.LCFI4>:
    4c86:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c88 <.LCFI5>:
    4c88:	ca 0c       	mova	r12,	r10	;
    4c8a:	c8 0d       	mova	r13,	r8	;

00004c8c <.LVL13>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
    4c8c:	9c 00 00 00 	cmpa	#0,	r12	;
    4c90:	03 24       	jz	$+8      	;abs 0x4c98

00004c92 <.Loc.176.1>:
    4c92:	9d 00 00 00 	cmpa	#0,	r13	;
    4c96:	04 20       	jnz	$+10     	;abs 0x4ca0

00004c98 <.L15>:
    4c98:	8c 01 1b 01 	mova	#65819,	r12	;0x1011b

00004c9c <.LVL14>:
    4c9c:	b0 13 5c 46 	calla	#18012		;0x0465c

00004ca0 <.L16>:

  php->next = mp->next;
    4ca0:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4ca4:	00 00 

00004ca6 <.Loc.179.1>:
  mp->next = php;
    4ca6:	7a 08 00 00 	mova	r8,	0(r10)	;

00004caa <.Loc.180.1>:
}
    4caa:	08 16       	popm.a	#1,	r8	;20-bit words
    4cac:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cae:	10 01       	reta			;

00004cb0 <chPoolFree>:
  _disable_interrupts();
    4cb0:	32 c2       	dint			
    4cb2:	03 43       	nop			

00004cb4 <.Loc.348.2>:
  asm volatile("nop");
    4cb4:	03 43       	nop			

00004cb6 <.LBE18>:
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
    4cb6:	b0 13 84 4c 	calla	#19588		;0x04c84

00004cba <.LBB20>:
  asm volatile("nop");
    4cba:	03 43       	nop			

00004cbc <.Loc.356.2>:
  _enable_interrupts();
    4cbc:	03 43       	nop			
    4cbe:	32 d2       	eint			
    4cc0:	03 43       	nop			

00004cc2 <.LBE20>:
  chSysUnlock();
}
    4cc2:	10 01       	reta			;

00004cc4 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4cc4:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004cc6 <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4cc6:	7d 01 00 00 	mova	r1,	0(r13)	;

00004cca <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4cca:	01 0c       	mova	@r12,	r1	;

00004ccc <.Loc.76.1>:
  asm volatile ("popm.a #7, R10");
    4ccc:	64 16       	popm.a	#7,	r10	;20-bit words

00004cce <.Loc.77.1>:
  asm volatile ("reta");
    4cce:	10 01       	reta			;

00004cd0 <_port_thread_start>:
  asm volatile("nop");
    4cd0:	03 43       	nop			

00004cd2 <.Loc.356.2>:
  _enable_interrupts();
    4cd2:	03 43       	nop			
    4cd4:	32 d2       	eint			
    4cd6:	03 43       	nop			

00004cd8 <.LBE4>:
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4cd8:	cc 05       	mova	r5,	r12	;

00004cda <.Loc.98.1>:
  asm volatile ("calla R4");
    4cda:	44 13       	calla	r4		;

00004cdc <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4cdc:	4c 43       	clr.b	r12		;
    4cde:	b0 13 5c 46 	calla	#18012		;0x0465c

00004ce2 <.LVL1>:
#endif
}
    4ce2:	10 01       	reta			;

00004ce4 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4ce4:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004ce6 <.LCFI0>:
    4ce6:	06 14       	pushm.a	#1,	r6	;20-bit words

00004ce8 <.LCFI1>:
    4ce8:	04 14       	pushm.a	#1,	r4	;20-bit words

00004cea <.LCFI2>:
    4cea:	c6 0c       	mova	r12,	r6	;
    4cec:	c4 0d       	mova	r13,	r4	;

00004cee <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4cee:	2c 4c       	mov	@r12,	r12	;

00004cf0 <.LVL2>:
    4cf0:	0c 93       	cmp	#0,	r12	;r3 As==00
    4cf2:	18 34       	jge	$+50     	;abs 0x4d24
    4cf4:	8a 01 12 07 	mova	#67346,	r10	;0x10712

00004cf8 <.LBB2>:
        (void) chSchReadyI(tp, msg);
        return;
      }
      tp++;

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4cf8:	88 00 5c 46 	mova	#18012,	r8	;0x0465c
    4cfc:	89 01 6b 01 	mova	#65899,	r9	;0x1016b

00004d00 <.L3>:
      if (tp->u1.semp == sp) {
    4d00:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    4d04:	06 00 
    4d06:	12 20       	jnz	$+38     	;abs 0x4d2c

00004d08 <.Loc.67.1>:
        sp->cnt++;
    4d08:	96 53 00 00 	inc	0(r6)		;

00004d0c <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4d0c:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    4d10:	04 00 
    4d12:	04 24       	jz	$+10     	;abs 0x4d1c

00004d14 <.Loc.69.1>:
    4d14:	8c 01 6b 01 	mova	#65899,	r12	;0x1016b
    4d18:	b0 13 5c 46 	calla	#18012		;0x0465c

00004d1c <.L5>:
        (void) chSchReadyI(tp, msg);
    4d1c:	cd 04       	mova	r4,	r13	;
    4d1e:	cc 0a       	mova	r10,	r12	;
    4d20:	b0 13 2c 47 	calla	#18220		;0x0472c

00004d24 <.L1>:
                  "pointer out of range");
    }
  }
}
    4d24:	04 16       	popm.a	#1,	r4	;20-bit words
    4d26:	06 16       	popm.a	#1,	r6	;20-bit words
    4d28:	28 16       	popm.a	#3,	r10	;20-bit words
    4d2a:	10 01       	reta			;

00004d2c <.L4>:
      tp++;
    4d2c:	aa 00 14 00 	adda	#20,	r10	;0x00014

00004d30 <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4d30:	9a 01 3a 07 	cmpa	#67386,	r10	;0x1073a
    4d34:	e5 2b       	jnc	$-52     	;abs 0x4d00

00004d36 <.Loc.76.1>:
    4d36:	cc 09       	mova	r9,	r12	;
    4d38:	48 13       	calla	r8		;

00004d3a <.LVL8>:
    4d3a:	80 00 00 4d 	mova	#19712,	r0	;0x04d00

00004d3e <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4d3e:	b0 13 32 50 	calla	#20530		;0x05032

00004d42 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4d42:	8c 01 8a 04 	mova	#66698,	r12	;0x1048a
    4d46:	b0 13 a2 50 	calla	#20642		;0x050a2

00004d4a <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4d4a:	b0 13 7c 4d 	calla	#19836		;0x04d7c

00004d4e <.LVL2>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    4d4e:	b0 13 52 4e 	calla	#20050		;0x04e52

00004d52 <.LVL3>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4d52:	b0 13 bc 4e 	calla	#20156		;0x04ebc

00004d56 <.LVL4>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    4d56:	b0 13 d4 4e 	calla	#20180		;0x04ed4

00004d5a <.LVL5>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4d5a:	b0 13 0a 60 	calla	#24586		;0x0600a

00004d5e <.LVL6>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4d5e:	b0 13 64 4d 	calla	#19812		;0x04d64

00004d62 <.LVL7>:
#endif
}
    4d62:	10 01       	reta			;

00004d64 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4d64:	b0 13 82 50 	calla	#20610		;0x05082

00004d68 <.LVL0>:
}
    4d68:	10 01       	reta			;

00004d6a <port_lock>:
  _disable_interrupts();
    4d6a:	32 c2       	dint			
    4d6c:	03 43       	nop			

00004d6e <.Loc.348.1>:
  asm volatile("nop");
    4d6e:	03 43       	nop			

00004d70 <.Loc.349.1>:
}
    4d70:	10 01       	reta			;

00004d72 <port_unlock>:
  asm volatile("nop");
    4d72:	03 43       	nop			

00004d74 <.Loc.356.1>:
  _enable_interrupts();
    4d74:	03 43       	nop			
    4d76:	32 d2       	eint			
    4d78:	03 43       	nop			

00004d7a <.Loc.357.1>:
}
    4d7a:	10 01       	reta			;

00004d7c <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    4d7c:	b0 13 02 5f 	calla	#24322		;0x05f02

00004d80 <.LVL0>:
}
    4d80:	10 01       	reta			;

00004d82 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    4d82:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004d86 <.Loc.71.2>:
  gptp->config = NULL;
    4d86:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4d8a:	02 00 

00004d8c <.Loc.72.2>:
}
    4d8c:	10 01       	reta			;

00004d8e <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    4d8e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d90 <.LCFI0>:
    4d90:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d92 <.LCFI1>:
    4d92:	ca 0c       	mova	r12,	r10	;
    4d94:	c8 0d       	mova	r13,	r8	;

00004d96 <.Loc.84.2>:

  osalDbgCheck((gptp != NULL) && (config != NULL));
    4d96:	9c 00 00 00 	cmpa	#0,	r12	;
    4d9a:	03 24       	jz	$+8      	;abs 0x4da2

00004d9c <.Loc.84.2>:
    4d9c:	9d 00 00 00 	cmpa	#0,	r13	;
    4da0:	04 20       	jnz	$+10     	;abs 0x4daa

00004da2 <.L6>:
    4da2:	8c 01 de 01 	mova	#66014,	r12	;0x101de

00004da6 <.LVL3>:
    4da6:	b0 13 5c 46 	calla	#18012		;0x0465c

00004daa <.L7>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    4daa:	b0 13 6a 4d 	calla	#19818		;0x04d6a

00004dae <.LBE26>:

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    4dae:	6c 4a       	mov.b	@r10,	r12	;
    4db0:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4db2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4db4:	4d 9c       	cmp.b	r12,	r13	;
    4db6:	04 2c       	jc	$+10     	;abs 0x4dc0

00004db8 <.Loc.87.2>:
    4db8:	8c 01 de 01 	mova	#66014,	r12	;0x101de
    4dbc:	b0 13 5c 46 	calla	#18012		;0x0465c

00004dc0 <.L8>:
              "invalid state");
  gptp->config = config;
    4dc0:	7a 08 02 00 	mova	r8,	2(r10)	;

00004dc4 <.Loc.90.2>:
  gpt_lld_start(gptp);
    4dc4:	cc 0a       	mova	r10,	r12	;
    4dc6:	b0 13 14 5f 	calla	#24340		;0x05f14

00004dca <.LVL7>:
  gptp->state = GPT_READY;
    4dca:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004dce <.LBB28>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    4dce:	b0 13 72 4d 	calla	#19826		;0x04d72

00004dd2 <.LBE28>:
  osalSysUnlock();
}
    4dd2:	08 16       	popm.a	#1,	r8	;20-bit words
    4dd4:	0a 16       	popm.a	#1,	r10	;20-bit words
    4dd6:	10 01       	reta			;

00004dd8 <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    4dd8:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004dda <.LCFI6>:
    4dda:	ca 0c       	mova	r12,	r10	;
    4ddc:	09 4d       	mov	r13,	r9	;

00004dde <.Loc.200.2>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4dde:	9c 00 00 00 	cmpa	#0,	r12	;
    4de2:	04 20       	jnz	$+10     	;abs 0x4dec

00004de4 <.Loc.200.2>:
    4de4:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f

00004de8 <.LVL32>:
    4de8:	b0 13 5c 46 	calla	#18012		;0x0465c

00004dec <.L23>:
  osalDbgCheck(gptp->config->callback != NULL);
    4dec:	3c 0a 02 00 	mova	2(r10),	r12	;
    4df0:	00 18 cc 93 	cmpx.a	#0,	4(r12)	;r3 As==00
    4df4:	04 00 
    4df6:	04 20       	jnz	$+10     	;abs 0x4e00

00004df8 <.Loc.201.2>:
    4df8:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f
    4dfc:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e00 <.L24>:
  osalDbgAssert(gptp->state == GPT_READY,
    4e00:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4e04:	04 24       	jz	$+10     	;abs 0x4e0e

00004e06 <.Loc.202.2>:
    4e06:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f
    4e0a:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e0e <.L25>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    4e0e:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00004e12 <.Loc.206.2>:
  gpt_lld_start_timer(gptp, interval);
    4e12:	0d 49       	mov	r9,	r13	;
    4e14:	cc 0a       	mova	r10,	r12	;
    4e16:	b0 13 da 5f 	calla	#24538		;0x05fda

00004e1a <.LVL36>:
}
    4e1a:	19 16       	popm.a	#2,	r10	;20-bit words
    4e1c:	10 01       	reta			;

00004e1e <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    4e1e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e20 <.LCFI8>:
    4e20:	ca 0c       	mova	r12,	r10	;

00004e22 <.Loc.233.2>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4e22:	9c 00 00 00 	cmpa	#0,	r12	;
    4e26:	04 20       	jnz	$+10     	;abs 0x4e30

00004e28 <.Loc.233.2>:
    4e28:	8c 01 91 01 	mova	#65937,	r12	;0x10191

00004e2c <.LVL42>:
    4e2c:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e30 <.L28>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4e30:	6c 4a       	mov.b	@r10,	r12	;
    4e32:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    4e36:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4e38:	4d 9c       	cmp.b	r12,	r13	;
    4e3a:	04 2c       	jc	$+10     	;abs 0x4e44

00004e3c <.Loc.234.2>:
    4e3c:	8c 01 91 01 	mova	#65937,	r12	;0x10191
    4e40:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e44 <.L29>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    4e44:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004e48 <.Loc.239.2>:
  gpt_lld_stop_timer(gptp);
    4e48:	cc 0a       	mova	r10,	r12	;
    4e4a:	b0 13 fe 5f 	calla	#24574		;0x05ffe

00004e4e <.LVL45>:
}
    4e4e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e50:	10 01       	reta			;

00004e52 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    4e52:	b0 13 36 53 	calla	#21302		;0x05336

00004e56 <.LVL0>:
}
    4e56:	10 01       	reta			;

00004e58 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    4e58:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004e5c <.Loc.74.1>:
  i2cp->config = NULL;
    4e5c:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4e60:	02 00 

00004e62 <.Loc.83.1>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    4e62:	10 01       	reta			;

00004e64 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    4e64:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e66 <.LCFI0>:
    4e66:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e68 <.LCFI1>:
    4e68:	ca 0c       	mova	r12,	r10	;
    4e6a:	c8 0d       	mova	r13,	r8	;

00004e6c <.Loc.95.1>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    4e6c:	9c 00 00 00 	cmpa	#0,	r12	;
    4e70:	03 24       	jz	$+8      	;abs 0x4e78

00004e72 <.Loc.95.1>:
    4e72:	9d 00 00 00 	cmpa	#0,	r13	;
    4e76:	04 20       	jnz	$+10     	;abs 0x4e80

00004e78 <.L4>:
    4e78:	8c 01 2d 02 	mova	#66093,	r12	;0x1022d

00004e7c <.LVL3>:
    4e7c:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e80 <.L5>:
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    4e80:	6c 4a       	mov.b	@r10,	r12	;
    4e82:	4d 4c       	mov.b	r12,	r13	;
    4e84:	7d 53       	add.b	#-1,	r13	;r3 As==11
    4e86:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4e88:	4e 9d       	cmp.b	r13,	r14	;
    4e8a:	07 2c       	jc	$+16     	;abs 0x4e9a

00004e8c <.Loc.96.1>:
    4e8c:	3c 90 05 00 	cmp	#5,	r12	;
    4e90:	04 24       	jz	$+10     	;abs 0x4e9a

00004e92 <.Loc.96.1>:
    4e92:	8c 01 2d 02 	mova	#66093,	r12	;0x1022d
    4e96:	b0 13 5c 46 	calla	#18012		;0x0465c

00004e9a <.L6>:
  _disable_interrupts();
    4e9a:	32 c2       	dint			
    4e9c:	03 43       	nop			

00004e9e <.Loc.348.2>:
  asm volatile("nop");
    4e9e:	03 43       	nop			

00004ea0 <.LBE26>:
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    4ea0:	7a 08 02 00 	mova	r8,	2(r10)	;

00004ea4 <.Loc.101.1>:
  i2c_lld_start(i2cp);
    4ea4:	cc 0a       	mova	r10,	r12	;
    4ea6:	b0 13 6e 53 	calla	#21358		;0x0536e

00004eaa <.LVL6>:
  i2cp->state = I2C_READY;
    4eaa:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004eae <.LBB29>:
  asm volatile("nop");
    4eae:	03 43       	nop			

00004eb0 <.Loc.356.2>:
  _enable_interrupts();
    4eb0:	03 43       	nop			
    4eb2:	32 d2       	eint			
    4eb4:	03 43       	nop			

00004eb6 <.LBE29>:
  osalSysUnlock();
}
    4eb6:	08 16       	popm.a	#1,	r8	;20-bit words
    4eb8:	0a 16       	popm.a	#1,	r10	;20-bit words
    4eba:	10 01       	reta			;

00004ebc <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    4ebc:	b0 13 2a 53 	calla	#21290		;0x0532a

00004ec0 <.LVL2>:
}
    4ec0:	10 01       	reta			;

00004ec2 <port_lock>:
  _disable_interrupts();
    4ec2:	32 c2       	dint			
    4ec4:	03 43       	nop			

00004ec6 <.Loc.348.1>:
  asm volatile("nop");
    4ec6:	03 43       	nop			

00004ec8 <.Loc.349.1>:
}
    4ec8:	10 01       	reta			;

00004eca <port_unlock>:
  asm volatile("nop");
    4eca:	03 43       	nop			

00004ecc <.Loc.356.1>:
  _enable_interrupts();
    4ecc:	03 43       	nop			
    4ece:	32 d2       	eint			
    4ed0:	03 43       	nop			

00004ed2 <.Loc.357.1>:
}
    4ed2:	10 01       	reta			;

00004ed4 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    4ed4:	b0 13 a6 5b 	calla	#23462		;0x05ba6

00004ed8 <.LVL0>:
}
    4ed8:	10 01       	reta			;

00004eda <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    4eda:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004ede <.Loc.71.2>:
  uartp->txstate    = UART_TX_IDLE;
    4ede:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00004ee2 <.Loc.72.2>:
  uartp->rxstate    = UART_RX_IDLE;
    4ee2:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00004ee6 <.Loc.73.2>:
  uartp->config     = NULL;
    4ee6:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4eea:	04 00 

00004eec <.Loc.75.2>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    4eec:	cc 43 08 00 	mov.b	#0,	8(r12)	;r3 As==00

00004ef0 <.Loc.76.2>:
  uartp->threadrx   = NULL;
    4ef0:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    4ef4:	0a 00 

00004ef6 <.Loc.77.2>:
  uartp->threadtx   = NULL;
    4ef6:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    4efa:	0e 00 

00004efc <.Loc.87.2>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    4efc:	10 01       	reta			;

00004efe <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    4efe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f00 <.LCFI0>:
    4f00:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f02 <.LCFI1>:
    4f02:	ca 0c       	mova	r12,	r10	;
    4f04:	c8 0d       	mova	r13,	r8	;

00004f06 <.Loc.99.2>:

  osalDbgCheck((uartp != NULL) && (config != NULL));
    4f06:	9c 00 00 00 	cmpa	#0,	r12	;
    4f0a:	03 24       	jz	$+8      	;abs 0x4f12

00004f0c <.Loc.99.2>:
    4f0c:	9d 00 00 00 	cmpa	#0,	r13	;
    4f10:	04 20       	jnz	$+10     	;abs 0x4f1a

00004f12 <.L6>:
    4f12:	8c 01 f2 02 	mova	#66290,	r12	;0x102f2

00004f16 <.LVL3>:
    4f16:	b0 13 5c 46 	calla	#18012		;0x0465c

00004f1a <.L7>:
  chSysLock();
    4f1a:	b0 13 c2 4e 	calla	#20162		;0x04ec2

00004f1e <.LBE46>:

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    4f1e:	6c 4a       	mov.b	@r10,	r12	;
    4f20:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4f22:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4f24:	4d 9c       	cmp.b	r12,	r13	;
    4f26:	04 2c       	jc	$+10     	;abs 0x4f30

00004f28 <.Loc.102.2>:
    4f28:	8c 01 f2 02 	mova	#66290,	r12	;0x102f2
    4f2c:	b0 13 5c 46 	calla	#18012		;0x0465c

00004f30 <.L8>:
                "invalid state");

  uartp->config = config;
    4f30:	7a 08 04 00 	mova	r8,	4(r10)	;

00004f34 <.Loc.106.2>:
  uart_lld_start(uartp);
    4f34:	cc 0a       	mova	r10,	r12	;
    4f36:	b0 13 06 5c 	calla	#23558		;0x05c06

00004f3a <.LVL7>:
  uartp->state = UART_READY;
    4f3a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004f3e <.LBB48>:
  chSysUnlock();
    4f3e:	b0 13 ca 4e 	calla	#20170		;0x04eca

00004f42 <.LBE48>:
  osalSysUnlock();
}
    4f42:	08 16       	popm.a	#1,	r8	;20-bit words
    4f44:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f46:	10 01       	reta			;

00004f48 <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    4f48:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f4a <.LCFI6>:
    4f4a:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f4c <.LCFI7>:
    4f4c:	06 14       	pushm.a	#1,	r6	;20-bit words

00004f4e <.LCFI8>:
    4f4e:	ca 0c       	mova	r12,	r10	;
    4f50:	c6 0d       	mova	r13,	r6	;
    4f52:	c8 0e       	mova	r14,	r8	;

00004f54 <.Loc.175.2>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
    4f54:	9c 00 00 00 	cmpa	#0,	r12	;
    4f58:	06 24       	jz	$+14     	;abs 0x4f66

00004f5a <.Loc.175.2>:
    4f5a:	9d 00 00 00 	cmpa	#0,	r13	;
    4f5e:	03 24       	jz	$+8      	;abs 0x4f66

00004f60 <.Loc.175.2>:
    4f60:	9e 00 00 00 	cmpa	#0,	r14	;
    4f64:	04 20       	jnz	$+10     	;abs 0x4f6e

00004f66 <.L26>:
    4f66:	8c 01 cc 02 	mova	#66252,	r12	;0x102cc

00004f6a <.LVL25>:
    4f6a:	b0 13 5c 46 	calla	#18012		;0x0465c

00004f6e <.L27>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4f6e:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4f72:	04 24       	jz	$+10     	;abs 0x4f7c

00004f74 <.Loc.176.2>:
    4f74:	8c 01 cc 02 	mova	#66252,	r12	;0x102cc
    4f78:	b0 13 5c 46 	calla	#18012		;0x0465c

00004f7c <.L28>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    4f7c:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    4f80:	04 20       	jnz	$+10     	;abs 0x4f8a

00004f82 <.Loc.177.2>:
    4f82:	8c 01 cc 02 	mova	#66252,	r12	;0x102cc
    4f86:	b0 13 5c 46 	calla	#18012		;0x0465c

00004f8a <.L29>:

  uart_lld_start_send(uartp, n, txbuf);
    4f8a:	ce 08       	mova	r8,	r14	;
    4f8c:	cd 06       	mova	r6,	r13	;
    4f8e:	cc 0a       	mova	r10,	r12	;
    4f90:	b0 13 0a 5e 	calla	#24074		;0x05e0a

00004f94 <.LVL29>:
  uartp->txstate = UART_TX_ACTIVE;
    4f94:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00004f98 <.Loc.181.2>:
}
    4f98:	06 16       	popm.a	#1,	r6	;20-bit words
    4f9a:	08 16       	popm.a	#1,	r8	;20-bit words
    4f9c:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f9e:	10 01       	reta			;

00004fa0 <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    4fa0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004fa2 <.LCFI15>:
    4fa2:	08 14       	pushm.a	#1,	r8	;20-bit words

00004fa4 <.LCFI16>:
    4fa4:	06 14       	pushm.a	#1,	r6	;20-bit words

00004fa6 <.LCFI17>:
    4fa6:	ca 0c       	mova	r12,	r10	;
    4fa8:	c6 0d       	mova	r13,	r6	;
    4faa:	c8 0e       	mova	r14,	r8	;

00004fac <.Loc.281.2>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
    4fac:	9c 00 00 00 	cmpa	#0,	r12	;
    4fb0:	06 24       	jz	$+14     	;abs 0x4fbe

00004fb2 <.Loc.281.2>:
    4fb2:	9d 00 00 00 	cmpa	#0,	r13	;
    4fb6:	03 24       	jz	$+8      	;abs 0x4fbe

00004fb8 <.Loc.281.2>:
    4fb8:	9e 00 00 00 	cmpa	#0,	r14	;
    4fbc:	04 20       	jnz	$+10     	;abs 0x4fc6

00004fbe <.L56>:
    4fbe:	8c 01 8e 02 	mova	#66190,	r12	;0x1028e

00004fc2 <.LVL54>:
    4fc2:	b0 13 5c 46 	calla	#18012		;0x0465c

00004fc6 <.L57>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4fc6:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4fca:	04 24       	jz	$+10     	;abs 0x4fd4

00004fcc <.Loc.282.2>:
    4fcc:	8c 01 8e 02 	mova	#66190,	r12	;0x1028e
    4fd0:	b0 13 5c 46 	calla	#18012		;0x0465c

00004fd4 <.L58>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    4fd4:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4fd8:	04 20       	jnz	$+10     	;abs 0x4fe2

00004fda <.Loc.283.2>:
    4fda:	8c 01 8e 02 	mova	#66190,	r12	;0x1028e
    4fde:	b0 13 5c 46 	calla	#18012		;0x0465c

00004fe2 <.L59>:

  uart_lld_start_receive(uartp, n, rxbuf);
    4fe2:	ce 08       	mova	r8,	r14	;
    4fe4:	cd 06       	mova	r6,	r13	;
    4fe6:	cc 0a       	mova	r10,	r12	;
    4fe8:	b0 13 5e 5e 	calla	#24158		;0x05e5e

00004fec <.LVL58>:
  uartp->rxstate = UART_RX_ACTIVE;
    4fec:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

00004ff0 <.Loc.287.2>:
}
    4ff0:	06 16       	popm.a	#1,	r6	;20-bit words
    4ff2:	08 16       	popm.a	#1,	r8	;20-bit words
    4ff4:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ff6:	10 01       	reta			;

00004ff8 <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    4ff8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ffa <.LCFI20>:
    4ffa:	ca 0c       	mova	r12,	r10	;

00004ffc <.Loc.337.2>:

  osalDbgCheckClassI();
  osalDbgCheck(uartp != NULL);
    4ffc:	9c 00 00 00 	cmpa	#0,	r12	;
    5000:	04 20       	jnz	$+10     	;abs 0x500a

00005002 <.Loc.337.2>:
    5002:	8c 01 6d 02 	mova	#66157,	r12	;0x1026d

00005006 <.LVL68>:
    5006:	b0 13 5c 46 	calla	#18012		;0x0465c

0000500a <.L71>:
  osalDbgAssert(uartp->state == UART_READY, "not active");
    500a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    500e:	04 24       	jz	$+10     	;abs 0x5018

00005010 <.Loc.338.2>:
    5010:	8c 01 6d 02 	mova	#66157,	r12	;0x1026d
    5014:	b0 13 5c 46 	calla	#18012		;0x0465c

00005018 <.L72>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    5018:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    501c:	07 20       	jnz	$+16     	;abs 0x502c

0000501e <.LBB79>:
    size_t n = uart_lld_stop_receive(uartp);
    501e:	cc 0a       	mova	r10,	r12	;
    5020:	b0 13 b6 5e 	calla	#24246		;0x05eb6

00005024 <.LVL72>:
    uartp->rxstate = UART_RX_IDLE;
    5024:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00005028 <.L70>:
    return n;
  }
  return 0;
}
    5028:	0a 16       	popm.a	#1,	r10	;20-bit words
    502a:	10 01       	reta			;

0000502c <.L74>:
  return 0;
    502c:	4c 43       	clr.b	r12		;
    502e:	80 00 28 50 	mova	#20520,	r0	;0x05028

00005032 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    5032:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    5036:	80 5a 5c 01 

0000503a <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    503a:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    503e:	10 a5 40 01 

00005042 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    5042:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    5046:	41 01 

00005048 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    5048:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    504c:	00 a5 60 01 

00005050 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    5050:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    5054:	48 00 62 01 

00005058 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    5058:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    505c:	33 01 64 01 

00005060 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    5060:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    5064:	66 01 

00005066 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    5066:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    506a:	c9 c1 68 01 

0000506e <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    506e:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    5072:	0f 00 6c 01 

00005076 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    5076:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    507a:	61 01 

0000507c <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    507c:	b0 13 5c 51 	calla	#20828		;0x0515c

00005080 <.LVL0>:
#endif
}
    5080:	10 01       	reta			;

00005082 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    5082:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    5086:	7f 3e d2 03 

0000508a <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    508a:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    508e:	10 00 c2 03 

00005092 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    5092:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    5096:	e0 03 

00005098 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    5098:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    509c:	14 02 c0 03 

000050a0 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    50a0:	10 01       	reta			;

000050a2 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    50a2:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    50a6:	02 02 

000050a8 <.Loc.310.1>:
  PADIR = config->porta.dir;
    50a8:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    50ac:	02 00 04 02 

000050b0 <.Loc.311.1>:
  PAREN = config->porta.ren;
    50b0:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    50b4:	04 00 06 02 

000050b8 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    50b8:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    50bc:	06 00 0a 02 

000050c0 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    50c0:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    50c4:	08 00 0c 02 

000050c8 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    50c8:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    50cc:	0a 00 22 02 

000050d0 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    50d0:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    50d4:	0c 00 24 02 

000050d8 <.Loc.317.1>:
  PBREN = config->portb.ren;
    50d8:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    50dc:	0e 00 26 02 

000050e0 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    50e0:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    50e4:	10 00 2a 02 

000050e8 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    50e8:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    50ec:	12 00 2c 02 

000050f0 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    50f0:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    50f4:	14 00 22 03 

000050f8 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    50f8:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    50fc:	16 00 24 03 

00005100 <.Loc.351.1>:
  PJREN = config->portj.ren;
    5100:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    5104:	18 00 26 03 

00005108 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    5108:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    510c:	1a 00 2a 03 

00005110 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    5110:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    5114:	1c 00 2c 03 

00005118 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    5118:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    511c:	30 01 

0000511e <.Loc.356.1>:
}
    511e:	10 01       	reta			;

00005120 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    5120:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005122 <.LCFI0>:
    5122:	49 4c       	mov.b	r12,	r9	;
    5124:	48 4d       	mov.b	r13,	r8	;

00005126 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5126:	0a 49       	mov	r9,	r10	;
    5128:	12 c3       	clrc			
    512a:	0a 10       	rrc	r10		;
    512c:	40 18 0a 4a 	movx.w	r10,	r10	;
    5130:	ea 0a       	adda	r10,	r10	;
    5132:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005136 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5136:	59 f3       	and.b	#1,	r9	;r3 As==01
    5138:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    513c:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00005140 <.LVL2>:
    5140:	0d 49       	mov	r9,	r13	;

00005142 <.LVL3>:
    5142:	b0 13 78 9f 	calla	#40824		;0x09f78
    5146:	07 4c       	mov	r12,	r7	;
    5148:	27 fa       	and	@r10,	r7	;

0000514a <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    514a:	0c 48       	mov	r8,	r12	;
    514c:	0d 49       	mov	r9,	r13	;
    514e:	b0 13 e4 9e 	calla	#40676		;0x09ee4
    5152:	07 dc       	bis	r12,	r7	;
    5154:	8a 47 00 00 	mov	r7,	0(r10)	;

00005158 <.Loc.65.1>:
}
    5158:	37 16       	popm.a	#4,	r10	;20-bit words
    515a:	10 01       	reta			;

0000515c <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    515c:	40 18 82 43 	movx.w	#0,	&0xfc832;r3 As==00
    5160:	32 c8 

00005162 <.LBE15>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    5162:	10 01       	reta			;

00005164 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5164:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005166 <.LCFI2>:
    5166:	ca 0c       	mova	r12,	r10	;

00005168 <.LVL19>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    5168:	40 18 19 42 	movx.w	&0x00510,r9	;
    516c:	10 05 
    516e:	79 f0 10 00 	and.b	#16,	r9	;#0x0010
    5172:	09 93       	cmp	#0,	r9	;r3 As==00
    5174:	11 24       	jz	$+36     	;abs 0x5198

00005176 <.LVL20>:
    5176:	8c 00 20 05 	mova	#1312,	r12	;0x00520

0000517a <.LVL21>:
    517a:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    517e:	10 00 00 00 
    5182:	09 24       	jz	$+20     	;abs 0x5196

00005184 <.LVL22>:
    5184:	40 18 bc b0 	bitx.w	#16,	16(r12)	;0x00010, 0x00010
    5188:	10 00 10 00 
    518c:	1f 24       	jz	$+64     	;abs 0x51cc

0000518e <.Loc.198.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    518e:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00005192 <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    5192:	28 16       	popm.a	#3,	r10	;20-bit words
    5194:	10 01       	reta			;

00005196 <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    5196:	59 43       	mov.b	#1,	r9	;r3 As==01

00005198 <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    5198:	48 49       	mov.b	r9,	r8	;
    519a:	4d 43       	clr.b	r13		;
    519c:	4c 48       	mov.b	r8,	r12	;
    519e:	b0 13 20 51 	calla	#20768		;0x05120

000051a2 <.LVL26>:
  dma_regs[i].sz  = 0;
    51a2:	0c 49       	mov	r9,	r12	;
    51a4:	0d 43       	clr	r13		;
    51a6:	b0 13 16 9f 	calla	#40726		;0x09f16
    51aa:	0d 12       	push	r13		;
    51ac:	0c 12       	push	r12		;
    51ae:	0c 16       	popm.a	#1,	r12	;20-bit words
    51b0:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    51b4:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000051b8 <.Loc.204.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    51b8:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    51bc:	00 00 

000051be <.Loc.206.1>:
  channel->registers = dma_regs + i;
    51be:	7a 0c 00 00 	mova	r12,	0(r10)	;

000051c2 <.Loc.207.1>:
  channel->index     = i;
    51c2:	ca 48 04 00 	mov.b	r8,	4(r10)	;

000051c6 <.Loc.209.1>:
  return MSG_OK;
    51c6:	4c 43       	clr.b	r12		;
    51c8:	80 00 92 51 	mova	#20882,	r0	;0x05192

000051cc <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    51cc:	69 43       	mov.b	#2,	r9	;r3 As==10
    51ce:	80 00 98 51 	mova	#20888,	r0	;0x05198

000051d2 <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    51d2:	3a 14       	pushm.a	#4,	r10	;20-bit words

000051d4 <.LCFI4>:
    51d4:	c8 0c       	mova	r12,	r8	;
    51d6:	49 4d       	mov.b	r13,	r9	;

000051d8 <.Loc.229.1>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    51d8:	6c 43       	mov.b	#2,	r12	;r3 As==10

000051da <.LVL37>:
    51da:	4c 99       	cmp.b	r9,	r12	;
    51dc:	04 2c       	jc	$+10     	;abs 0x51e6

000051de <.Loc.229.1>:
    51de:	8c 01 13 03 	mova	#66323,	r12	;0x10313
    51e2:	b0 13 5c 46 	calla	#18012		;0x0465c

000051e6 <.L27>:
  if (dma_regs[index].ctl & DMAEN) {
    51e6:	0c 49       	mov	r9,	r12	;
    51e8:	0d 43       	clr	r13		;
    51ea:	b0 13 16 9f 	calla	#40726		;0x09f16
    51ee:	0d 12       	push	r13		;
    51f0:	0c 12       	push	r12		;
    51f2:	0a 16       	popm.a	#1,	r10	;20-bit words
    51f4:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    51f8:	27 4a       	mov	@r10,	r7	;
    51fa:	77 f0 10 00 	and.b	#16,	r7	;#0x0010
    51fe:	07 93       	cmp	#0,	r7	;r3 As==00
    5200:	10 20       	jnz	$+34     	;abs 0x5222

00005202 <.Loc.235.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5202:	4d 47       	mov.b	r7,	r13	;
    5204:	4c 49       	mov.b	r9,	r12	;
    5206:	b0 13 20 51 	calla	#20768		;0x05120

0000520a <.LVL40>:
  dma_regs[index].sz  = 0;
    520a:	8a 47 0a 00 	mov	r7,	10(r10)	; 0x000a

0000520e <.Loc.237.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    520e:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    5212:	00 00 

00005214 <.Loc.239.1>:

  channel->registers = dma_regs + index;
    5214:	78 0a 00 00 	mova	r10,	0(r8)	;

00005218 <.Loc.240.1>:
  channel->index     = index;
    5218:	c8 49 04 00 	mov.b	r9,	4(r8)	;

0000521c <.Loc.242.1>:
  
  return MSG_OK;
    521c:	4c 43       	clr.b	r12		;

0000521e <.L26>:
}
    521e:	37 16       	popm.a	#4,	r10	;20-bit words
    5220:	10 01       	reta			;

00005222 <.L29>:
    return MSG_TIMEOUT;
    5222:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5226:	80 00 1e 52 	mova	#21022,	r0	;0x0521e

0000522a <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    522a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000522c <.LCFI5>:
    522c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000522e <.LCFI6>:
    522e:	c8 0c       	mova	r12,	r8	;
    5230:	ca 0d       	mova	r13,	r10	;

00005232 <.Loc.273.1>:


  channel->registers->ctl &= (~DMAEN);
    5232:	0c 0c       	mova	@r12,	r12	;

00005234 <.LVL42>:
    5234:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5238:	00 00 

0000523a <.Loc.274.1>:
  dma_trigger_set(channel->index, request->trigger);
    523a:	5d 4d 10 00 	mov.b	16(r13),r13	;0x00010

0000523e <.LVL43>:
    523e:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5242:	b0 13 20 51 	calla	#20768		;0x05120

00005246 <.LVL44>:
  callbacks[channel->index] = request->callback;
    5246:	5c 48 04 00 	mov.b	4(r8),	r12	;
    524a:	0d 43       	clr	r13		;
    524c:	b0 13 1a 9f 	calla	#40730		;0x09f1a
    5250:	0d 12       	push	r13		;
    5252:	0c 12       	push	r12		;
    5254:	0c 16       	popm.a	#1,	r12	;20-bit words
    5256:	ac 00 34 c8 	adda	#51252,	r12	;0x0c834
    525a:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    525e:	00 00 
    5260:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    5264:	02 00 
    5266:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    526a:	04 00 
    526c:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    5270:	06 00 

00005272 <.Loc.278.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    5272:	0c 08       	mova	@r8,	r12	;
    5274:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    5278:	02 00 

0000527a <.Loc.279.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    527a:	0c 08       	mova	@r8,	r12	;
    527c:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    5280:	04 00 06 00 

00005284 <.Loc.284.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    5284:	0e 08       	mova	@r8,	r14	;
    5286:	9e 4a 08 00 	mov	8(r10),	10(r14)	; 0x000a
    528a:	0a 00 

0000528c <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    528c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    5290:	1c da 0a 00 	bis	10(r10),r12	;0x0000a

00005294 <.Loc.286.1>:
                            request->transfer_mode | DMAEN |
    5294:	3c d0 15 00 	bis	#21,	r12	;#0x0015

00005298 <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5298:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    529c:	8e 4c 00 00 	mov	r12,	0(r14)	;

000052a0 <.Loc.288.1>:
                            DMAREQ;
}
    52a0:	08 16       	popm.a	#1,	r8	;20-bit words
    52a2:	0a 16       	popm.a	#1,	r10	;20-bit words
    52a4:	10 01       	reta			;

000052a6 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    52a6:	1a 14       	pushm.a	#2,	r10	;20-bit words

000052a8 <.LCFI7>:
    52a8:	ca 0c       	mova	r12,	r10	;

000052aa <.LBB33>:
  return chSysGetStatusAndLockX();
    52aa:	b0 13 f8 46 	calla	#18168		;0x046f8

000052ae <.LVL49>:
    52ae:	09 4c       	mov	r12,	r9	;

000052b0 <.LBE33>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
    52b0:	9a 00 00 00 	cmpa	#0,	r10	;
    52b4:	09 20       	jnz	$+20     	;abs 0x52c8

000052b6 <.Loc.303.1>:
    52b6:	8c 01 07 03 	mova	#66311,	r12	;0x10307
    52ba:	b0 13 5c 46 	calla	#18012		;0x0465c

000052be <.L34>:
  chSysRestoreStatusX(sts);
    52be:	0c 49       	mov	r9,	r12	;
    52c0:	b0 13 14 47 	calla	#18196		;0x04714

000052c4 <.LBE35>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    52c4:	19 16       	popm.a	#2,	r10	;20-bit words
    52c6:	10 01       	reta			;

000052c8 <.L33>:
  if (dmaIsClaimed(channel)) {
    52c8:	0c 0a       	mova	@r10,	r12	;
    52ca:	9c 00 00 00 	cmpa	#0,	r12	;
    52ce:	f7 27       	jz	$-16     	;abs 0x52be

000052d0 <.Loc.305.1>:
    52d0:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    52d4:	10 00 00 00 
    52d8:	f2 27       	jz	$-26     	;abs 0x52be

000052da <.Loc.308.1>:
    channel->registers->ctl = DMAABORT;
    52da:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

000052de <.Loc.311.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    52de:	4d 43       	clr.b	r13		;
    52e0:	8c 00 32 c8 	mova	#51250,	r12	;0x0c832
    52e4:	b0 13 e4 4c 	calla	#19684		;0x04ce4

000052e8 <.LVL52>:
    52e8:	80 00 be 52 	mova	#21182,	r0	;0x052be

000052ec <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    52ec:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052ee <.LCFI8>:
    52ee:	ca 0c       	mova	r12,	r10	;

000052f0 <.Loc.327.1>:
  
  osalDbgCheck(channel != NULL);
    52f0:	9c 00 00 00 	cmpa	#0,	r12	;
    52f4:	04 20       	jnz	$+10     	;abs 0x52fe

000052f6 <.Loc.327.1>:
    52f6:	8c 01 fc 02 	mova	#66300,	r12	;0x102fc

000052fa <.LVL54>:
    52fa:	b0 13 5c 46 	calla	#18012		;0x0465c

000052fe <.L41>:
  
  if (!(channel->registers->ctl & DMAEN)) {
    52fe:	0c 0a       	mova	@r10,	r12	;
    5300:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5304:	10 00 00 00 
    5308:	0e 24       	jz	$+30     	;abs 0x5326

0000530a <.Loc.334.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    530a:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    530e:	00 00 

00005310 <.Loc.336.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    5310:	4d 43       	clr.b	r13		;
    5312:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5316:	b0 13 20 51 	calla	#20768		;0x05120

0000531a <.LVL56>:
  channel->registers->sz  = 0;
    531a:	0c 0a       	mova	@r10,	r12	;
    531c:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005320 <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    5320:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5324:	00 00 

00005326 <.L40>:
}
    5326:	0a 16       	popm.a	#1,	r10	;20-bit words
    5328:	10 01       	reta			;

0000532a <spi_lld_init>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    532a:	10 01       	reta			;

0000532c <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    532c:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005330 <.LVL2>:
    5330:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

00005334 <.Loc.82.1>:
}
    5334:	10 01       	reta			;

00005336 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    5336:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005338 <.LCFI0>:

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5338:	8a 01 d0 07 	mova	#67536,	r10	;0x107d0
    533c:	cc 0a       	mova	r10,	r12	;
    533e:	b0 13 58 4e 	calla	#20056		;0x04e58

00005342 <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    5342:	00 18 fa 40 	movx.a	#1600,	16(r10)	;0x00640, 0x00010
    5346:	40 06 10 00 

0000534a <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    534a:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    534e:	20 00 

00005350 <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    5350:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

00005354 <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    5354:	fa 40 13 00 	mov.b	#19,	50(r10)	;#0x0013, 0x0032
    5358:	32 00 

0000535a <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    535a:	fa 40 12 00 	mov.b	#18,	51(r10)	;#0x0012, 0x0033
    535e:	33 00 

00005360 <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    5360:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    5364:	26 00 

00005366 <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    5366:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

0000536a <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    536a:	0a 16       	popm.a	#1,	r10	;20-bit words
    536c:	10 01       	reta			;

0000536e <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    536e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005370 <.LCFI1>:
    5370:	ca 0c       	mova	r12,	r10	;

00005372 <.Loc.479.1>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    5372:	9c 01 d0 07 	cmpa	#67536,	r12	;0x107d0
    5376:	52 20       	jnz	$+166    	;abs 0x541c

00005378 <.Loc.481.1>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    5378:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    537c:	40 06 

0000537e <.Loc.483.1>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    537e:	3c 0c 02 00 	mova	2(r12),	r12	;

00005382 <.LVL8>:
    5382:	2e 4c       	mov	@r12,	r14	;
    5384:	1f 4c 02 00 	mov	2(r12),	r15	;
    5388:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    538c:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5390:	b0 13 ae 9e 	calla	#40622		;0x09eae
    5394:	40 18 82 4c 	movx.w	r12,	&0x00646;
    5398:	46 06 

0000539a <.Loc.485.1>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    539a:	40 18 b2 40 	movx.w	#192,	&0x00642;0x000c0
    539e:	c0 00 42 06 

000053a2 <.Loc.490.1>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
        | MSP430X_I2CB0_UCSSEL;
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    53a2:	40 18 b2 40 	movx.w	#3968,	&0x00640;0x00f80
    53a6:	80 0f 40 06 

000053aa <.Loc.492.1>:
  #endif
      if (I2CDB0.regs->statw & BIT4) {
    53aa:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    53ae:	40 18 bc b0 	bitx.w	#16,	8(r12)	;0x00010
    53b2:	10 00 08 00 
    53b6:	2b 24       	jz	$+88     	;abs 0x540e

000053b8 <.Loc.494.1>:
        /* Disable again */
        UCB0CTLW0 |= 0x01;
    53b8:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    53bc:	40 06 

000053be <.Loc.496.1>:
        /* Set the SCL pin as an output */
        P1SEL1 &= ~0x80;
    53be:	40 18 f2 f0 	andx.b	#127,	&0x0020c;0x0007f
    53c2:	7f 00 0c 02 

000053c6 <.Loc.497.1>:
        P1DIR |= 0x80;
    53c6:	c0 1f f2 d0 	bisx.b	#-128,	&0x00204;0xfff80
    53ca:	80 ff 04 02 

000053ce <.Loc.498.1>:
        P1REN &= ~0x80;
    53ce:	40 18 f2 f0 	andx.b	#127,	&0x00206;0x0007f
    53d2:	7f 00 06 02 

000053d6 <.LVL10>:
    53d6:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a

000053da <.L7>:
        /* Toggle it 10 times */
        for (int i = 0 ; i < 10; i++) {
          P1OUT &= ~0x80;
    53da:	40 18 f2 f0 	andx.b	#127,	&0x00202;0x0007f
    53de:	7f 00 02 02 

000053e2 <.Loc.502.1>:
          P1OUT |= 0x80;
    53e2:	c0 1f f2 d0 	bisx.b	#-128,	&0x00202;0xfff80
    53e6:	80 ff 02 02 

000053ea <.LVL12>:
    53ea:	3c 53       	add	#-1,	r12	;r3 As==11

000053ec <.LVL13>:
        for (int i = 0 ; i < 10; i++) {
    53ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    53ee:	f5 23       	jnz	$-20     	;abs 0x53da

000053f0 <.LBE53>:
        }
        /* Reset it to I2C mode */
        P1DIR &= ~0x80;
    53f0:	40 18 f2 f0 	andx.b	#127,	&0x00204;0x0007f
    53f4:	7f 00 04 02 

000053f8 <.Loc.506.1>:
        P1SEL1 |= 0x80;
    53f8:	c0 1f f2 d0 	bisx.b	#-128,	&0x0020c;0xfff80
    53fc:	80 ff 0c 02 

00005400 <.Loc.507.1>:
        P1REN |= 0x80;
    5400:	c0 1f f2 d0 	bisx.b	#-128,	&0x00206;0xfff80
    5404:	80 ff 06 02 

00005408 <.Loc.509.1>:
        /* Re-enable the peripheral */
        UCB0CTLW0 &= ~0x01;
    5408:	40 18 92 c3 	bicx.w	#1,	&0x00640;r3 As==01
    540c:	40 06 

0000540e <.L6>:
      }
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    540e:	40 18 b2 40 	movx.w	#184,	&0x0066a;0x000b8
    5412:	b8 00 6a 06 

00005416 <.Loc.512.1>:
      UCB0IFG = 0;
    5416:	40 18 82 43 	movx.w	#0,	&0x0066c;r3 As==00
    541a:	6c 06 

0000541c <.L4>:
      }
  #endif
    }
#endif

}
    541c:	0a 16       	popm.a	#1,	r10	;20-bit words
    541e:	10 01       	reta			;

00005420 <i2cMSP430XStartReceiveToRegI>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    5420:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005422 <.LCFI3>:
    5422:	06 14       	pushm.a	#1,	r6	;20-bit words

00005424 <.LCFI4>:
    5424:	04 14       	pushm.a	#1,	r4	;20-bit words

00005426 <.LCFI5>:
    5426:	ca 0c       	mova	r12,	r10	;
    5428:	49 4d       	mov.b	r13,	r9	;
    542a:	c6 0e       	mova	r14,	r6	;
    542c:	c8 0f       	mova	r15,	r8	;
    542e:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005432 <.Loc.680.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5432:	9e 00 00 00 	cmpa	#0,	r14	;
    5436:	04 20       	jnz	$+10     	;abs 0x5440

00005438 <.Loc.680.1>:
    5438:	8c 01 1d 04 	mova	#66589,	r12	;0x1041d

0000543c <.LVL20>:
    543c:	b0 13 5c 46 	calla	#18012		;0x0465c

00005440 <.L16>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5440:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5442:	04 34       	jge	$+10     	;abs 0x544c

00005444 <.Loc.684.1>:
    5444:	8c 01 1d 04 	mova	#66589,	r12	;0x1041d
    5448:	b0 13 5c 46 	calla	#18012		;0x0465c

0000544c <.L17>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    544c:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005450 <.Loc.690.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5450:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005454 <.Loc.692.1>:
  
  i2cp->buffer = regp;
    5454:	7a 08 08 00 	mova	r8,	8(r10)	;

00005458 <.Loc.695.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5458:	96 00 01 00 	cmpa	#1,	r6	;
    545c:	1b 20       	jnz	$+56     	;abs 0x5494

0000545e <.Loc.697.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = regp;
    545e:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005462 <.Loc.698.1>:
    i2cp->req.size = 0;
    5462:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005466 <.Loc.700.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5466:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    546a:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    546e:	00 00 

00005470 <.Loc.702.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5470:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005474 <.L19>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5474:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5478:	fd 23       	jnz	$-4      	;abs 0x5474

0000547a <.Loc.705.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    547a:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

0000547e <.Loc.707.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
    547e:	94 00 00 00 	cmpa	#0,	r4	;
    5482:	04 24       	jz	$+10     	;abs 0x548c

00005484 <.Loc.708.1>:
      callback(i2cp, regp, 1);
    5484:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5486:	cd 08       	mova	r8,	r13	;
    5488:	cc 0a       	mova	r10,	r12	;
    548a:	44 13       	calla	r4		;

0000548c <.L15>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    548c:	04 16       	popm.a	#1,	r4	;20-bit words
    548e:	06 16       	popm.a	#1,	r6	;20-bit words
    5490:	28 16       	popm.a	#3,	r10	;20-bit words
    5492:	10 01       	reta			;

00005494 <.L18>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5494:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5498:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    549c:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

000054a0 <.Loc.713.1>:
    i2cp->req.dest_addr = regp;
    54a0:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

000054a4 <.Loc.714.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    54a4:	40 18 06 46 	movx.w	r6,	r6	;

000054a8 <.LVL25>:
    54a8:	36 53       	add	#-1,	r6	;r3 As==11
    54aa:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

000054ae <.Loc.715.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    54ae:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

000054b2 <.Loc.716.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    54b2:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    54b6:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

000054ba <.Loc.718.1>:
    i2cp->callback = callback;
    54ba:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

000054be <.Loc.720.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    54be:	00 18 fa 40 	movx.a	#22662,	38(r10)	;0x05886, 0x00026
    54c2:	86 58 26 00 

000054c6 <.Loc.721.1>:
    i2cp->req.callback.args = i2cp;
    54c6:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

000054ca <.Loc.723.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    54ca:	c8 0a       	mova	r10,	r8	;

000054cc <.LVL26>:
    54cc:	a8 00 34 00 	adda	#52,	r8	;0x00034
    54d0:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    54d4:	9c 00 00 00 	cmpa	#0,	r12	;
    54d8:	04 24       	jz	$+10     	;abs 0x54e2

000054da <.Loc.723.1>:
    54da:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    54de:	00 00 
    54e0:	03 20       	jnz	$+8      	;abs 0x54e8

000054e2 <.L21>:
      dmaAcquireI(&(i2cp->dma));
    54e2:	cc 08       	mova	r8,	r12	;
    54e4:	b0 13 64 51 	calla	#20836		;0x05164

000054e8 <.L22>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    54e8:	cd 0a       	mova	r10,	r13	;
    54ea:	ad 00 14 00 	adda	#20,	r13	;0x00014
    54ee:	cc 08       	mova	r8,	r12	;
    54f0:	b0 13 2a 52 	calla	#21034		;0x0522a

000054f4 <.LVL28>:
    i2cp->regs->i2csa = addr;
    54f4:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    54f8:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

000054fc <.Loc.730.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    54fc:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5500:	00 00 

00005502 <.Loc.731.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5502:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005506 <.Loc.733.1>:
}
    5506:	80 00 8c 54 	mova	#21644,	r0	;0x0548c

0000550a <i2cMSP430XStartReceiveI>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    550a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000550c <.LCFI6>:
    550c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000550e <.LCFI7>:
    550e:	04 14       	pushm.a	#1,	r4	;20-bit words

00005510 <.LCFI8>:
    5510:	ca 0c       	mova	r12,	r10	;
    5512:	49 4d       	mov.b	r13,	r9	;
    5514:	c6 0e       	mova	r14,	r6	;
    5516:	c8 0f       	mova	r15,	r8	;
    5518:	34 01 18 00 	mova	24(r1),	r4	;0x00018

0000551c <.Loc.740.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    551c:	9e 00 00 00 	cmpa	#0,	r14	;
    5520:	04 20       	jnz	$+10     	;abs 0x552a

00005522 <.Loc.740.1>:
    5522:	8c 01 05 04 	mova	#66565,	r12	;0x10405

00005526 <.LVL30>:
    5526:	b0 13 5c 46 	calla	#18012		;0x0465c

0000552a <.L31>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    552a:	49 93       	cmp.b	#0,	r9	;r3 As==00
    552c:	04 34       	jge	$+10     	;abs 0x5536

0000552e <.Loc.744.1>:
    552e:	8c 01 05 04 	mova	#66565,	r12	;0x10405
    5532:	b0 13 5c 46 	calla	#18012		;0x0465c

00005536 <.L32>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5536:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

0000553a <.Loc.750.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    553a:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

0000553e <.Loc.752.1>:
  
  i2cp->buffer = rxbuf;
    553e:	7a 08 08 00 	mova	r8,	8(r10)	;

00005542 <.Loc.755.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5542:	96 00 01 00 	cmpa	#1,	r6	;
    5546:	18 20       	jnz	$+50     	;abs 0x5578

00005548 <.Loc.757.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    5548:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

0000554c <.Loc.758.1>:
    i2cp->req.size = 0;
    554c:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005550 <.Loc.760.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5550:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5554:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5558:	00 00 

0000555a <.Loc.762.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    555a:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

0000555e <.L34>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    555e:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5562:	fd 23       	jnz	$-4      	;abs 0x555e

00005564 <.Loc.765.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    5564:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005568 <.Loc.769.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
      chSysUnlockFromISR();
      callback(i2cp, rxbuf, 1);
    5568:	5e 43       	mov.b	#1,	r14	;r3 As==01
    556a:	cd 08       	mova	r8,	r13	;
    556c:	cc 0a       	mova	r10,	r12	;
    556e:	44 13       	calla	r4		;

00005570 <.L30>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5570:	04 16       	popm.a	#1,	r4	;20-bit words
    5572:	06 16       	popm.a	#1,	r6	;20-bit words
    5574:	28 16       	popm.a	#3,	r10	;20-bit words
    5576:	10 01       	reta			;

00005578 <.L33>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5578:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    557c:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5580:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

00005584 <.Loc.775.1>:
    i2cp->req.dest_addr = rxbuf;
    5584:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005588 <.Loc.776.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5588:	40 18 06 46 	movx.w	r6,	r6	;

0000558c <.LVL35>:
    558c:	36 53       	add	#-1,	r6	;r3 As==11
    558e:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

00005592 <.Loc.777.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    5592:	ba 40 00 0c 	mov	#3072,	30(r10)	;#0x0c00, 0x001e
    5596:	1e 00 

00005598 <.Loc.778.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5598:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    559c:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

000055a0 <.Loc.780.1>:
    i2cp->callback = callback;
    55a0:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

000055a4 <.Loc.782.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    55a4:	00 18 fa 40 	movx.a	#22662,	38(r10)	;0x05886, 0x00026
    55a8:	86 58 26 00 

000055ac <.Loc.783.1>:
    i2cp->req.callback.args = i2cp;
    55ac:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

000055b0 <.Loc.785.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    55b0:	c8 0a       	mova	r10,	r8	;

000055b2 <.LVL36>:
    55b2:	a8 00 34 00 	adda	#52,	r8	;0x00034
    55b6:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    55ba:	9c 00 00 00 	cmpa	#0,	r12	;
    55be:	04 24       	jz	$+10     	;abs 0x55c8

000055c0 <.Loc.785.1>:
    55c0:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    55c4:	00 00 
    55c6:	03 20       	jnz	$+8      	;abs 0x55ce

000055c8 <.L36>:
      dmaAcquireI(&(i2cp->dma));
    55c8:	cc 08       	mova	r8,	r12	;
    55ca:	b0 13 64 51 	calla	#20836		;0x05164

000055ce <.L37>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    55ce:	cd 0a       	mova	r10,	r13	;
    55d0:	ad 00 14 00 	adda	#20,	r13	;0x00014
    55d4:	cc 08       	mova	r8,	r12	;
    55d6:	b0 13 2a 52 	calla	#21034		;0x0522a

000055da <.LVL38>:
    i2cp->regs->i2csa = addr;
    55da:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    55de:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

000055e2 <.Loc.792.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    55e2:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    55e6:	00 00 

000055e8 <.Loc.793.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    55e8:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000055ec <.Loc.795.1>:
}
    55ec:	80 00 70 55 	mova	#21872,	r0	;0x05570

000055f0 <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    55f0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000055f2 <.LCFI9>:
    55f2:	06 14       	pushm.a	#1,	r6	;20-bit words

000055f4 <.LCFI10>:
    55f4:	c6 0c       	mova	r12,	r6	;
    55f6:	49 4d       	mov.b	r13,	r9	;
    55f8:	ca 0e       	mova	r14,	r10	;
    55fa:	c8 0f       	mova	r15,	r8	;

000055fc <.Loc.802.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    55fc:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    5600:	04 24       	jz	$+10     	;abs 0x560a

00005602 <.Loc.802.1>:
    5602:	8c 01 e9 03 	mova	#66537,	r12	;0x103e9

00005606 <.LVL40>:
    5606:	b0 13 5c 46 	calla	#18012		;0x0465c

0000560a <.L43>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    560a:	9a 00 00 00 	cmpa	#0,	r10	;
    560e:	04 20       	jnz	$+10     	;abs 0x5618

00005610 <.Loc.804.1>:
    5610:	8c 01 e9 03 	mova	#66537,	r12	;0x103e9
    5614:	b0 13 5c 46 	calla	#18012		;0x0465c

00005618 <.L44>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5618:	49 93       	cmp.b	#0,	r9	;r3 As==00
    561a:	04 34       	jge	$+10     	;abs 0x5624

0000561c <.Loc.809.1>:
    561c:	8c 01 e9 03 	mova	#66537,	r12	;0x103e9
    5620:	b0 13 5c 46 	calla	#18012		;0x0465c

00005624 <.L45>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5624:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005628 <.Loc.815.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    5628:	f6 40 03 00 	mov.b	#3,	0(r6)	;
    562c:	00 00 

0000562e <.Loc.817.1>:
  
  i2cp->buffer = txbuf;
    562e:	76 08 08 00 	mova	r8,	8(r6)	;

00005632 <.Loc.820.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    5632:	cc 0a       	mova	r10,	r12	;
    5634:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    5638:	e8 0c       	adda	r12,	r8	;

0000563a <.LVL44>:
    563a:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

0000563e <.Loc.821.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    563e:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5642:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5646:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

0000564a <.Loc.822.1>:
  i2cp->req.size = n;
    564a:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    564e:	1c 00 

00005650 <.Loc.823.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    5650:	b6 40 00 02 	mov	#512,	30(r6)	;#0x0200, 0x001e
    5654:	1e 00 

00005656 <.Loc.824.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5656:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    565a:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

0000565e <.Loc.826.1>:
  /* Custom callback */
  i2cp->callback = callback;
    565e:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5662:	14 00 0c 00 

00005666 <.Loc.828.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5666:	00 18 f6 40 	movx.a	#21292,	38(r6)	;0x0532c, 0x00026
    566a:	2c 53 26 00 

0000566e <.Loc.830.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    566e:	ca 06       	mova	r6,	r10	;

00005670 <.LVL45>:
    5670:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5674:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5678:	9c 00 00 00 	cmpa	#0,	r12	;
    567c:	04 24       	jz	$+10     	;abs 0x5686

0000567e <.Loc.830.1>:
    567e:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5682:	00 00 
    5684:	03 20       	jnz	$+8      	;abs 0x568c

00005686 <.L46>:
    dmaAcquireI(&(i2cp->dma));
    5686:	cc 0a       	mova	r10,	r12	;
    5688:	b0 13 64 51 	calla	#20836		;0x05164

0000568c <.L47>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    568c:	cd 06       	mova	r6,	r13	;
    568e:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5692:	cc 0a       	mova	r10,	r12	;
    5694:	b0 13 2a 52 	calla	#21034		;0x0522a

00005698 <.LVL47>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    5698:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    569c:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

000056a0 <.Loc.837.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    56a0:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    56a4:	00 00 

000056a6 <.Loc.840.1>:
  /* IFG is set automatically after START */
  
}
    56a6:	06 16       	popm.a	#1,	r6	;20-bit words
    56a8:	28 16       	popm.a	#3,	r10	;20-bit words
    56aa:	10 01       	reta			;

000056ac <i2cMSP430XContinueTransmitMemsetI>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    56ac:	2a 14       	pushm.a	#3,	r10	;20-bit words

000056ae <.LCFI15>:
    56ae:	06 14       	pushm.a	#1,	r6	;20-bit words

000056b0 <.LCFI16>:
    56b0:	c6 0c       	mova	r12,	r6	;
    56b2:	49 4d       	mov.b	r13,	r9	;
    56b4:	ca 0e       	mova	r14,	r10	;
    56b6:	c8 0f       	mova	r15,	r8	;

000056b8 <.Loc.928.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    56b8:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    56bc:	00 00 
    56be:	04 24       	jz	$+10     	;abs 0x56c8

000056c0 <.Loc.928.1>:
    56c0:	8c 01 8f 03 	mova	#66447,	r12	;0x1038f

000056c4 <.LVL66>:
    56c4:	b0 13 5c 46 	calla	#18012		;0x0465c

000056c8 <.L76>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    56c8:	9a 00 00 00 	cmpa	#0,	r10	;
    56cc:	04 20       	jnz	$+10     	;abs 0x56d6

000056ce <.Loc.930.1>:
    56ce:	8c 01 8f 03 	mova	#66447,	r12	;0x1038f
    56d2:	b0 13 5c 46 	calla	#18012		;0x0465c

000056d6 <.L77>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    56d6:	49 93       	cmp.b	#0,	r9	;r3 As==00
    56d8:	04 34       	jge	$+10     	;abs 0x56e2

000056da <.Loc.935.1>:
    56da:	8c 01 8f 03 	mova	#66447,	r12	;0x1038f
    56de:	b0 13 5c 46 	calla	#18012		;0x0465c

000056e2 <.L78>:
#endif
  
  i2cp->buffer = value;
    56e2:	76 08 08 00 	mova	r8,	8(r6)	;

000056e6 <.Loc.941.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    56e6:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

000056ea <.Loc.942.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    56ea:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    56ee:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    56f2:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

000056f6 <.Loc.943.1>:
  i2cp->req.size = n;
    56f6:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    56fa:	1c 00 

000056fc <.Loc.944.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    56fc:	86 43 1e 00 	mov	#0,	30(r6)	;r3 As==00, 0x001e

00005700 <.Loc.945.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5700:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5704:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005708 <.Loc.947.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5708:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    570c:	14 00 0c 00 

00005710 <.Loc.949.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5710:	00 18 f6 40 	movx.a	#21292,	38(r6)	;0x0532c, 0x00026
    5714:	2c 53 26 00 

00005718 <.Loc.951.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5718:	ca 06       	mova	r6,	r10	;

0000571a <.LVL70>:
    571a:	aa 00 34 00 	adda	#52,	r10	;0x00034
    571e:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5722:	9c 00 00 00 	cmpa	#0,	r12	;
    5726:	04 24       	jz	$+10     	;abs 0x5730

00005728 <.Loc.951.1>:
    5728:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    572c:	00 00 
    572e:	04 20       	jnz	$+10     	;abs 0x5738

00005730 <.L79>:
    5730:	8c 01 8f 03 	mova	#66447,	r12	;0x1038f
    5734:	b0 13 5c 46 	calla	#18012		;0x0465c

00005738 <.L80>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5738:	cd 06       	mova	r6,	r13	;
    573a:	ad 00 14 00 	adda	#20,	r13	;0x00014
    573e:	cc 0a       	mova	r10,	r12	;
    5740:	b0 13 2a 52 	calla	#21034		;0x0522a

00005744 <.LVL72>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5744:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5748:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

0000574c <.Loc.957.1>:
  
}
    574c:	06 16       	popm.a	#1,	r6	;20-bit words
    574e:	28 16       	popm.a	#3,	r10	;20-bit words
    5750:	10 01       	reta			;

00005752 <i2cMSP430XContinueTransmitI>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5752:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005754 <.LCFI17>:
    5754:	06 14       	pushm.a	#1,	r6	;20-bit words

00005756 <.LCFI18>:
    5756:	c6 0c       	mova	r12,	r6	;
    5758:	49 4d       	mov.b	r13,	r9	;
    575a:	ca 0e       	mova	r14,	r10	;
    575c:	c8 0f       	mova	r15,	r8	;

0000575e <.Loc.964.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    575e:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    5762:	00 00 
    5764:	04 24       	jz	$+10     	;abs 0x576e

00005766 <.Loc.964.1>:
    5766:	8c 01 73 03 	mova	#66419,	r12	;0x10373

0000576a <.LVL74>:
    576a:	b0 13 5c 46 	calla	#18012		;0x0465c

0000576e <.L85>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    576e:	9a 00 00 00 	cmpa	#0,	r10	;
    5772:	04 20       	jnz	$+10     	;abs 0x577c

00005774 <.Loc.966.1>:
    5774:	8c 01 73 03 	mova	#66419,	r12	;0x10373
    5778:	b0 13 5c 46 	calla	#18012		;0x0465c

0000577c <.L86>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    577c:	49 93       	cmp.b	#0,	r9	;r3 As==00
    577e:	04 34       	jge	$+10     	;abs 0x5788

00005780 <.Loc.971.1>:
    5780:	8c 01 73 03 	mova	#66419,	r12	;0x10373
    5784:	b0 13 5c 46 	calla	#18012		;0x0465c

00005788 <.L87>:
#endif
  
  i2cp->buffer = txbuf;
    5788:	76 08 08 00 	mova	r8,	8(r6)	;

0000578c <.Loc.977.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    578c:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005790 <.Loc.978.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5790:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5794:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5798:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

0000579c <.Loc.979.1>:
  i2cp->req.size = n;
    579c:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    57a0:	1c 00 

000057a2 <.Loc.980.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    57a2:	b6 40 00 03 	mov	#768,	30(r6)	;#0x0300, 0x001e
    57a6:	1e 00 

000057a8 <.Loc.981.1>:
  i2cp->req.trigger = i2cp->txtrig;
    57a8:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    57ac:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

000057b0 <.Loc.983.1>:
  /* Custom callback */
  i2cp->callback = callback;
    57b0:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    57b4:	14 00 0c 00 

000057b8 <.Loc.985.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    57b8:	00 18 f6 40 	movx.a	#21292,	38(r6)	;0x0532c, 0x00026
    57bc:	2c 53 26 00 

000057c0 <.Loc.987.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    57c0:	ca 06       	mova	r6,	r10	;

000057c2 <.LVL78>:
    57c2:	aa 00 34 00 	adda	#52,	r10	;0x00034
    57c6:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    57ca:	9c 00 00 00 	cmpa	#0,	r12	;
    57ce:	04 24       	jz	$+10     	;abs 0x57d8

000057d0 <.Loc.987.1>:
    57d0:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    57d4:	00 00 
    57d6:	04 20       	jnz	$+10     	;abs 0x57e0

000057d8 <.L88>:
    57d8:	8c 01 73 03 	mova	#66419,	r12	;0x10373
    57dc:	b0 13 5c 46 	calla	#18012		;0x0465c

000057e0 <.L89>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    57e0:	cd 06       	mova	r6,	r13	;
    57e2:	ad 00 14 00 	adda	#20,	r13	;0x00014
    57e6:	cc 0a       	mova	r10,	r12	;
    57e8:	b0 13 2a 52 	calla	#21034		;0x0522a

000057ec <.LVL80>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    57ec:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    57f0:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

000057f4 <.Loc.993.1>:
  
}
    57f4:	06 16       	popm.a	#1,	r6	;20-bit words
    57f6:	28 16       	popm.a	#3,	r10	;20-bit words
    57f8:	10 01       	reta			;

000057fa <i2cMSP430XEndTransferI>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    57fa:	0a 14       	pushm.a	#1,	r10	;20-bit words

000057fc <.LCFI19>:
    57fc:	b1 00 02 00 	suba	#2,	r1	;

00005800 <.LCFI20>:
    5800:	ca 0c       	mova	r12,	r10	;

00005802 <.Loc.999.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
    5802:	6c 4c       	mov.b	@r12,	r12	;

00005804 <.LVL82>:
    5804:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    5808:	5d 43       	mov.b	#1,	r13	;r3 As==01
    580a:	4d 9c       	cmp.b	r12,	r13	;
    580c:	04 2c       	jc	$+10     	;abs 0x5816

0000580e <.Loc.999.1>:
    580e:	8c 01 5c 03 	mova	#66396,	r12	;0x1035c
    5812:	b0 13 5c 46 	calla	#18012		;0x0465c

00005816 <.L94>:
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    5816:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    581a:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

0000581e <.Loc.1005.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    581e:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    5822:	2c 20       	jnz	$+90     	;abs 0x587c

00005824 <.L107>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
    
    /* Wait for last RX byte */
    while (!(i2cp->regs->ifg & UCRXIFG0));
    5824:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    5828:	2c 00 
    582a:	fc 27       	jz	$-6      	;abs 0x5824
    582c:	3e 0a 18 00 	mova	24(r10),r14	;0x00018

00005830 <.Loc.1015.1>:
    
    if (i2cp->req.addr_mode) {
    5830:	8a 93 1e 00 	cmp	#0,	30(r10)	;r3 As==00, 0x001e
    5834:	1d 24       	jz	$+60     	;abs 0x5870

00005836 <.Loc.1016.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    5836:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    583a:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    583e:	1c 00 
    5840:	ec 0e       	adda	r14,	r12	;
    5842:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00005846 <.L98>:
    }
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
    
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    5846:	3c 0a 10 00 	mova	16(r10),r12	;0x00010

0000584a <.L99>:
    584a:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    584e:	fd 23       	jnz	$-4      	;abs 0x584a

00005850 <.Loc.1024.1>:
      
    if (i2cp->regs->ifg & UCRXIFG0) {
    5850:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    5854:	2c 00 
    5856:	06 24       	jz	$+14     	;abs 0x5864

00005858 <.LBB68>:
      /* Need to read the buffer to reset the state */
      volatile uint8_t throwaway;
      throwaway = i2cp->regs->rxbuf;
    5858:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    585c:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00005860 <.Loc.1028.1>:
      (void)(throwaway);
    5860:	5c 41 01 00 	mov.b	1(r1),	r12	;

00005864 <.L101>:
  }
  else {
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
  }
  
  i2cp->state = I2C_READY;
    5864:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005868 <.Loc.1036.1>:
}
    5868:	a1 00 02 00 	adda	#2,	r1	;
    586c:	0a 16       	popm.a	#1,	r10	;20-bit words
    586e:	10 01       	reta			;

00005870 <.L97>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    5870:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    5874:	ce 4c 00 00 	mov.b	r12,	0(r14)	;
    5878:	80 00 46 58 	mova	#22598,	r0	;0x05846

0000587c <.L104>:
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    587c:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    5880:	fd 23       	jnz	$-4      	;abs 0x587c
    5882:	80 00 64 58 	mova	#22628,	r0	;0x05864

00005886 <rx_async_callback>:
void rx_async_callback(void * args) {
    5886:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005888 <.LCFI21>:
    5888:	08 14       	pushm.a	#1,	r8	;20-bit words

0000588a <.LCFI22>:
    588a:	ca 0c       	mova	r12,	r10	;

0000588c <.LVL85>:
  if (NULL != i2cp->callback) {
    588c:	38 0c 0c 00 	mova	12(r12),r8	;0x0000c
    5890:	98 00 00 00 	cmpa	#0,	r8	;
    5894:	08 24       	jz	$+18     	;abs 0x58a6

00005896 <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    5896:	1e 4c 1c 00 	mov	28(r12),r14	;0x0001c
    589a:	3d 0c 08 00 	mova	8(r12),	r13	;
    589e:	48 13       	calla	r8		;

000058a0 <.L109>:
}
    58a0:	08 16       	popm.a	#1,	r8	;20-bit words
    58a2:	0a 16       	popm.a	#1,	r10	;20-bit words
    58a4:	10 01       	reta			;

000058a6 <.L110>:
    i2cMSP430XEndTransferI(i2cp);
    58a6:	b0 13 fa 57 	calla	#22522		;0x057fa

000058aa <.LVL87>:
}
    58aa:	80 00 a0 58 	mova	#22688,	r0	;0x058a0

000058ae <UCBRS>:
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
  /* TODO there must be a better way */
  if (frac < 529)
    58ae:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    58b2:	0d 9c       	cmp	r12,	r13	;
    58b4:	8b 2c       	jc	$+280    	;abs 0x59cc

000058b6 <.Loc.84.1>:
    return 0x00;
  else if (frac < 715)
    58b6:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    58ba:	0d 9c       	cmp	r12,	r13	;
    58bc:	8a 2c       	jc	$+278    	;abs 0x59d2

000058be <.Loc.86.1>:
    return 0x01;
  else if (frac < 835)
    58be:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    58c2:	0d 9c       	cmp	r12,	r13	;
    58c4:	89 2c       	jc	$+276    	;abs 0x59d8

000058c6 <.Loc.88.1>:
    return 0x02;
  else if (frac < 1001)
    58c6:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    58ca:	0d 9c       	cmp	r12,	r13	;
    58cc:	88 2c       	jc	$+274    	;abs 0x59de

000058ce <.Loc.90.1>:
    return 0x04;
  else if (frac < 1252)
    58ce:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    58d2:	0d 9c       	cmp	r12,	r13	;
    58d4:	87 2c       	jc	$+272    	;abs 0x59e4

000058d6 <.Loc.92.1>:
    return 0x08;
  else if (frac < 1430)
    58d6:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    58da:	0d 9c       	cmp	r12,	r13	;
    58dc:	86 2c       	jc	$+270    	;abs 0x59ea

000058de <.Loc.94.1>:
    return 0x10;
  else if (frac < 1670)
    58de:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    58e2:	0d 9c       	cmp	r12,	r13	;
    58e4:	86 2c       	jc	$+270    	;abs 0x59f2

000058e6 <.Loc.96.1>:
    return 0x20;
  else if (frac < 2147)
    58e6:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    58ea:	0d 9c       	cmp	r12,	r13	;
    58ec:	86 2c       	jc	$+270    	;abs 0x59fa

000058ee <.Loc.98.1>:
    return 0x11;
  else if (frac < 2224)
    58ee:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    58f2:	0d 9c       	cmp	r12,	r13	;
    58f4:	86 2c       	jc	$+270    	;abs 0x5a02

000058f6 <.Loc.100.1>:
    return 0x21;
  else if (frac < 2503)
    58f6:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    58fa:	0d 9c       	cmp	r12,	r13	;
    58fc:	86 2c       	jc	$+270    	;abs 0x5a0a

000058fe <.Loc.102.1>:
    return 0x22;
  else if (frac < 3000)
    58fe:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    5902:	0d 9c       	cmp	r12,	r13	;
    5904:	86 2c       	jc	$+270    	;abs 0x5a12

00005906 <.LBB41>:
    return 0x44;
  else if (frac < 3335)
    5906:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    590a:	0d 9c       	cmp	r12,	r13	;
    590c:	86 2c       	jc	$+270    	;abs 0x5a1a

0000590e <.Loc.106.1>:
    return 0x25;
  else if (frac < 3575)
    590e:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    5912:	0d 9c       	cmp	r12,	r13	;
    5914:	86 2c       	jc	$+270    	;abs 0x5a22

00005916 <.Loc.108.1>:
    return 0x49;
  else if (frac < 3753)
    5916:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    591a:	0d 9c       	cmp	r12,	r13	;
    591c:	86 2c       	jc	$+270    	;abs 0x5a2a

0000591e <.Loc.110.1>:
    return 0x4A;
  else if (frac < 4003)
    591e:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    5922:	0d 9c       	cmp	r12,	r13	;
    5924:	86 2c       	jc	$+270    	;abs 0x5a32

00005926 <.Loc.112.1>:
    return 0x52;
  else if (frac < 4286)
    5926:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    592a:	0d 9c       	cmp	r12,	r13	;
    592c:	86 2c       	jc	$+270    	;abs 0x5a3a

0000592e <.Loc.114.1>:
    return 0x92;
  else if (frac < 4378)
    592e:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    5932:	0d 9c       	cmp	r12,	r13	;
    5934:	86 2c       	jc	$+270    	;abs 0x5a42

00005936 <.Loc.116.1>:
    return 0x53;
  else if (frac < 5002)
    5936:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    593a:	0d 9c       	cmp	r12,	r13	;
    593c:	86 2c       	jc	$+270    	;abs 0x5a4a

0000593e <.Loc.118.1>:
    return 0x55;
  else if (frac < 5715)
    593e:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    5942:	0d 9c       	cmp	r12,	r13	;
    5944:	86 2c       	jc	$+270    	;abs 0x5a52

00005946 <.Loc.120.1>:
    return 0xAA;
  else if (frac < 6003)
    5946:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    594a:	0d 9c       	cmp	r12,	r13	;
    594c:	86 2c       	jc	$+270    	;abs 0x5a5a

0000594e <.Loc.122.1>:
    return 0x6B;
  else if (frac < 6254)
    594e:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    5952:	0d 9c       	cmp	r12,	r13	;
    5954:	86 2c       	jc	$+270    	;abs 0x5a62

00005956 <.Loc.124.1>:
    return 0xAD;
  else if (frac < 6432)
    5956:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    595a:	0d 9c       	cmp	r12,	r13	;
    595c:	86 2c       	jc	$+270    	;abs 0x5a6a

0000595e <.Loc.126.1>:
    return 0xB5;
  else if (frac < 6667)
    595e:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    5962:	0d 9c       	cmp	r12,	r13	;
    5964:	86 2c       	jc	$+270    	;abs 0x5a72

00005966 <.Loc.128.1>:
    return 0xB6;
  else if (frac < 7001)
    5966:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    596a:	0d 9c       	cmp	r12,	r13	;
    596c:	86 2c       	jc	$+270    	;abs 0x5a7a

0000596e <.Loc.130.1>:
    return 0xD6;
  else if (frac < 7147)
    596e:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    5972:	0d 9c       	cmp	r12,	r13	;
    5974:	86 2c       	jc	$+270    	;abs 0x5a82

00005976 <.Loc.132.1>:
    return 0xB7;
  else if (frac < 7503)
    5976:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    597a:	0d 9c       	cmp	r12,	r13	;
    597c:	86 2c       	jc	$+270    	;abs 0x5a8a

0000597e <.Loc.134.1>:
    return 0xBB;
  else if (frac < 7861)
    597e:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    5982:	0d 9c       	cmp	r12,	r13	;
    5984:	86 2c       	jc	$+270    	;abs 0x5a92

00005986 <.Loc.136.1>:
    return 0xDD;
  else if (frac < 8004)
    5986:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    598a:	0d 9c       	cmp	r12,	r13	;
    598c:	86 2c       	jc	$+270    	;abs 0x5a9a

0000598e <.Loc.138.1>:
    return 0xED;
  else if (frac < 8333)
    598e:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    5992:	0d 9c       	cmp	r12,	r13	;
    5994:	86 2c       	jc	$+270    	;abs 0x5aa2

00005996 <.Loc.140.1>:
    return 0xEE;
  else if (frac < 8464)
    5996:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    599a:	0d 9c       	cmp	r12,	r13	;
    599c:	86 2c       	jc	$+270    	;abs 0x5aaa

0000599e <.Loc.142.1>:
    return 0xBF;
  else if (frac < 8572)
    599e:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    59a2:	0d 9c       	cmp	r12,	r13	;
    59a4:	86 2c       	jc	$+270    	;abs 0x5ab2

000059a6 <.Loc.144.1>:
    return 0xDF;
  else if (frac < 8751)
    59a6:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    59aa:	0d 9c       	cmp	r12,	r13	;
    59ac:	86 2c       	jc	$+270    	;abs 0x5aba

000059ae <.Loc.146.1>:
    return 0xEF;
  else if (frac < 9004)
    59ae:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    59b2:	0d 9c       	cmp	r12,	r13	;
    59b4:	86 2c       	jc	$+270    	;abs 0x5ac2

000059b6 <.Loc.148.1>:
    return 0xF7;
  else if (frac < 9170)
    59b6:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    59ba:	0d 9c       	cmp	r12,	r13	;
    59bc:	86 2c       	jc	$+270    	;abs 0x5aca

000059be <.Loc.150.1>:
    return 0xFB;
  else if (frac < 9288)
    59be:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    59c2:	0d 9c       	cmp	r12,	r13	;
    59c4:	86 2c       	jc	$+270    	;abs 0x5ad2

000059c6 <.Loc.153.1>:
    return 0xFD;
  else
    return 0xFE;
    59c6:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000059ca <.L2>:
}
    59ca:	10 01       	reta			;

000059cc <.L3>:
    return 0x00;
    59cc:	4c 43       	clr.b	r12		;

000059ce <.LVL4>:
    59ce:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059d2 <.L4>:
    return 0x01;
    59d2:	5c 43       	mov.b	#1,	r12	;r3 As==01

000059d4 <.LVL6>:
    59d4:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059d8 <.L5>:
    return 0x02;
    59d8:	6c 43       	mov.b	#2,	r12	;r3 As==10

000059da <.LVL8>:
    59da:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059de <.L6>:
    return 0x04;
    59de:	6c 42       	mov.b	#4,	r12	;r2 As==10

000059e0 <.LVL10>:
    59e0:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059e4 <.L7>:
    return 0x08;
    59e4:	7c 42       	mov.b	#8,	r12	;r2 As==11

000059e6 <.LVL12>:
    59e6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059ea <.L8>:
    return 0x10;
    59ea:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000059ee <.LVL14>:
    59ee:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059f2 <.L9>:
    return 0x20;
    59f2:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000059f6 <.LVL16>:
    59f6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

000059fa <.L10>:
    return 0x11;
    59fa:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000059fe <.LVL18>:
    59fe:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a02 <.L11>:
    return 0x21;
    5a02:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

00005a06 <.LVL20>:
    5a06:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a0a <.L12>:
    return 0x22;
    5a0a:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00005a0e <.LVL22>:
    5a0e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a12 <.L13>:
    return 0x44;
    5a12:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00005a16 <.LVL24>:
    5a16:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a1a <.L14>:
    return 0x25;
    5a1a:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00005a1e <.LVL26>:
    5a1e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a22 <.L15>:
    return 0x49;
    5a22:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00005a26 <.LVL28>:
    5a26:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a2a <.L16>:
    return 0x4A;
    5a2a:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

00005a2e <.LVL30>:
    5a2e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a32 <.L17>:
    return 0x52;
    5a32:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00005a36 <.LVL32>:
    5a36:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a3a <.L18>:
    return 0x92;
    5a3a:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00005a3e <.LVL34>:
    5a3e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a42 <.L19>:
    return 0x53;
    5a42:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00005a46 <.LVL36>:
    5a46:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a4a <.L20>:
    return 0x55;
    5a4a:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00005a4e <.LVL38>:
    5a4e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a52 <.L21>:
    return 0xAA;
    5a52:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00005a56 <.LVL40>:
    5a56:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a5a <.L22>:
    return 0x6B;
    5a5a:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00005a5e <.LVL42>:
    5a5e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a62 <.L23>:
    return 0xAD;
    5a62:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00005a66 <.LVL44>:
    5a66:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a6a <.L24>:
    return 0xB5;
    5a6a:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

00005a6e <.LVL46>:
    5a6e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a72 <.L25>:
    return 0xB6;
    5a72:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00005a76 <.LVL48>:
    5a76:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a7a <.L26>:
    return 0xD6;
    5a7a:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00005a7e <.LVL50>:
    5a7e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a82 <.L27>:
    return 0xB7;
    5a82:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00005a86 <.LVL52>:
    5a86:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a8a <.L28>:
    return 0xBB;
    5a8a:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

00005a8e <.LVL54>:
    5a8e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a92 <.L29>:
    return 0xDD;
    5a92:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00005a96 <.LVL56>:
    5a96:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005a9a <.L30>:
    return 0xED;
    5a9a:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00005a9e <.LVL58>:
    5a9e:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005aa2 <.L31>:
    return 0xEE;
    5aa2:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00005aa6 <.LVL60>:
    5aa6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005aaa <.L32>:
    return 0xBF;
    5aaa:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

00005aae <.LVL62>:
    5aae:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005ab2 <.L33>:
    return 0xDF;
    5ab2:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

00005ab6 <.LVL64>:
    5ab6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005aba <.L34>:
    return 0xEF;
    5aba:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

00005abe <.LVL66>:
    5abe:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005ac2 <.L35>:
    return 0xF7;
    5ac2:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00005ac6 <.LVL68>:
    5ac6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005aca <.L36>:
    return 0xFB;
    5aca:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

00005ace <.LVL70>:
    5ace:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005ad2 <.L37>:
    return 0xFD;
    5ad2:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

00005ad6 <.LVL72>:
    5ad6:	80 00 ca 59 	mova	#22986,	r0	;0x059ca

00005ada <rx_cb>:
static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
}

static void rx_cb(void * arg){
    5ada:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005adc <.LCFI0>:
    5adc:	ca 0c       	mova	r12,	r10	;

00005ade <.LVL74>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5ade:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    5ae2:	3e 0c 04 00 	mova	4(r12),	r14	;
    5ae6:	3e 0e 08 00 	mova	8(r14),	r14	;
    5aea:	9e 00 00 00 	cmpa	#0,	r14	;
    5aee:	01 24       	jz	$+4      	;abs 0x5af2

00005af0 <.Loc.213.1>:
    5af0:	4e 13       	calla	r14		;

00005af2 <.L39>:
    5af2:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    5af6:	06 20       	jnz	$+14     	;abs 0x5b04

00005af8 <.Loc.213.1>:
    5af8:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    5afc:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00005b00 <.LBB55>:
  uartp->regs->ie |= UCRXIE;
    5b00:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005b04 <.L40>:
  chThdResumeI(trp, msg);
    5b04:	4d 43       	clr.b	r13		;
    5b06:	cc 0a       	mova	r10,	r12	;
    5b08:	ac 00 0a 00 	adda	#10,	r12	;0x0000a

00005b0c <.LVL78>:
    5b0c:	b0 13 5c 48 	calla	#18524		;0x0485c

00005b10 <.LBE57>:
  if (uartp->rxstate == UART_RX_IDLE) {
    5b10:	ca 93 02 00 	cmp.b	#0,	2(r10)	;r3 As==00
    5b14:	0e 20       	jnz	$+30     	;abs 0x5b32

00005b16 <.LBB59>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
    if (uartp->config->dmarx_index >= MSP430X_DMA_CHANNELS) {
    5b16:	3c 0a 04 00 	mova	4(r10),	r12	;
    5b1a:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f
    5b1e:	5d 9c 19 00 	cmp.b	25(r12),r13	;0x00019
    5b22:	07 2c       	jc	$+16     	;abs 0x5b32

00005b24 <.Loc.217.1>:
      dmaReleaseX(&(uartp->dma_rx));
    5b24:	cc 0a       	mova	r10,	r12	;
    5b26:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5b2a:	b0 13 a6 52 	calla	#21158		;0x052a6

00005b2e <.LVL81>:
      uartp->dma_acquired_rx = false;
    5b2e:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063

00005b32 <.L38>:
#else
    dmaReleaseX(&(uartp->dmta_rx));
    uartp->dma_acquired_rx = false;
#endif
  }
}
    5b32:	0a 16       	popm.a	#1,	r10	;20-bit words
    5b34:	10 01       	reta			;

00005b36 <tx_cb>:
static void tx_cb(void * arg) {
    5b36:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005b38 <.LCFI1>:
    5b38:	ca 0c       	mova	r12,	r10	;

00005b3a <.LVL84>:
  _uart_tx1_isr_code(uartp);
    5b3a:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    5b3e:	3e 0c 04 00 	mova	4(r12),	r14	;
    5b42:	0e 0e       	mova	@r14,	r14	;
    5b44:	9e 00 00 00 	cmpa	#0,	r14	;
    5b48:	01 24       	jz	$+4      	;abs 0x5b4c

00005b4a <.Loc.183.1>:
    5b4a:	4e 13       	calla	r14		;

00005b4c <.L46>:
    5b4c:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    5b50:	02 20       	jnz	$+6      	;abs 0x5b56

00005b52 <.Loc.183.1>:
    5b52:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00

00005b56 <.L47>:
    5b56:	ca 93 08 00 	cmp.b	#0,	8(r10)	;r3 As==00
    5b5a:	06 24       	jz	$+14     	;abs 0x5b68

00005b5c <.LBB67>:
    5b5c:	4d 43       	clr.b	r13		;
    5b5e:	cc 0a       	mova	r10,	r12	;
    5b60:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00005b64 <.LVL87>:
    5b64:	b0 13 5c 48 	calla	#18524		;0x0485c

00005b68 <.L48>:
  if (uartp->txstate == UART_TX_IDLE) {
    5b68:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    5b6c:	1a 20       	jnz	$+54     	;abs 0x5ba2

00005b6e <.LBB69>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    5b6e:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00005b72 <.L51>:
    5b72:	40 18 bc b2 	bitx.w	#8,	28(r12)	;r2 As==11, 0x0001c
    5b76:	1c 00 
    5b78:	fc 27       	jz	$-6      	;abs 0x5b72

00005b7a <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    5b7a:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

00005b7e <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    5b7e:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

00005b82 <.Loc.193.1>:
    if (uartp->config->dmatx_index >= MSP430X_DMA_CHANNELS) {
    5b82:	3c 0a 04 00 	mova	4(r10),	r12	;
    5b86:	5c 4c 19 00 	mov.b	25(r12),r12	;0x00019
    5b8a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    5b8e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5b90:	0d 9c       	cmp	r12,	r13	;
    5b92:	07 34       	jge	$+16     	;abs 0x5ba2

00005b94 <.Loc.194.1>:
      dmaReleaseX(&(uartp->dma_tx));
    5b94:	cc 0a       	mova	r10,	r12	;
    5b96:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5b9a:	b0 13 a6 52 	calla	#21158		;0x052a6

00005b9e <.LVL89>:
      uartp->dma_acquired_tx = false;
    5b9e:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062

00005ba2 <.L45>:
}
    5ba2:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ba4:	10 01       	reta			;

00005ba6 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
    5ba6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005ba8 <.LCFI3>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
#endif
  
#if MSP430X_UART_USE_UARTA1 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA1);
    5ba8:	8a 01 0e 08 	mova	#67598,	r10	;0x1080e
    5bac:	cc 0a       	mova	r10,	r12	;
    5bae:	b0 13 da 4e 	calla	#20186		;0x04eda

00005bb2 <.LVL108>:
  UARTDA1.regs = (msp430x_uart_reg_t  *)(&UCA1CTLW0);
    5bb2:	00 18 fa 40 	movx.a	#1504,	22(r10)	;0x005e0, 0x00016
    5bb6:	e0 05 16 00 

00005bba <.Loc.483.1>:
  UARTDA1.freq = MSP430X_UARTA1_CLK_FREQ;
    5bba:	ba 40 00 24 	mov	#9216,	18(r10)	;#0x2400, 0x0012
    5bbe:	12 00 
    5bc0:	ba 40 f4 00 	mov	#244,	20(r10)	;#0x00f4, 0x0014
    5bc4:	14 00 

00005bc6 <.Loc.484.1>:
  UARTDA1.dmareq_tx.dest_addr = (void*)(&UCA1TXBUF);
    5bc6:	00 18 fa 40 	movx.a	#1518,	30(r10)	;0x005ee, 0x0001e
    5bca:	ee 05 1e 00 

00005bce <.Loc.485.1>:
  UARTDA1.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    5bce:	ba 40 00 03 	mov	#768,	36(r10)	;#0x0300, 0x0024
    5bd2:	24 00 

00005bd4 <.Loc.486.1>:
  UARTDA1.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5bd4:	ba 40 c0 00 	mov	#192,	38(r10)	;#0x00c0, 0x0026
    5bd8:	26 00 

00005bda <.Loc.487.1>:
  UARTDA1.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    5bda:	8a 43 28 00 	mov	#0,	40(r10)	;r3 As==00, 0x0028

00005bde <.Loc.488.1>:
  UARTDA1.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA1TXIFG);
    5bde:	ba 40 11 00 	mov	#17,	42(r10)	;#0x0011, 0x002a
    5be2:	2a 00 

00005be4 <.Loc.489.1>:
  UARTDA1.dmareq_rx.source_addr = (void*)(&UCA1RXBUF);
    5be4:	00 18 fa 40 	movx.a	#1516,	52(r10)	;0x005ec, 0x00034
    5be8:	ec 05 34 00 

00005bec <.Loc.490.1>:
  UARTDA1.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    5bec:	ba 40 00 0c 	mov	#3072,	62(r10)	;#0x0c00, 0x003e
    5bf0:	3e 00 

00005bf2 <.Loc.491.1>:
  UARTDA1.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5bf2:	ba 40 c0 00 	mov	#192,	64(r10)	;#0x00c0, 0x0040
    5bf6:	40 00 

00005bf8 <.Loc.492.1>:
  UARTDA1.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    5bf8:	8a 43 42 00 	mov	#0,	66(r10)	;r3 As==00, 0x0042

00005bfc <.Loc.493.1>:
  UARTDA1.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA1RXIFG);
    5bfc:	ba 40 10 00 	mov	#16,	68(r10)	;#0x0010, 0x0044
    5c00:	44 00 

00005c02 <.Loc.532.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    5c02:	0a 16       	popm.a	#1,	r10	;20-bit words
    5c04:	10 01       	reta			;

00005c06 <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    5c06:	6a 14       	pushm.a	#7,	r10	;20-bit words

00005c08 <.LCFI4>:
    5c08:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00005c0c <.LCFI5>:
    5c0c:	ca 0c       	mova	r12,	r10	;

00005c0e <.Loc.543.1>:

  if (uartp->state != UART_STOP) {
    5c0e:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    5c12:	16 24       	jz	$+46     	;abs 0x5c40

00005c14 <.Loc.545.1>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    5c14:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00005c18 <.L106>:
    5c18:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    5c1c:	1c 00 
    5c1e:	fc 27       	jz	$-6      	;abs 0x5c18

00005c20 <.Loc.548.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    5c20:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    5c24:	05 24       	jz	$+12     	;abs 0x5c30

00005c26 <.Loc.549.1>:
      dmaReleaseX(&(uartp->dma_tx));
    5c26:	cc 0a       	mova	r10,	r12	;
    5c28:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5c2c:	b0 13 a6 52 	calla	#21158		;0x052a6

00005c30 <.L107>:
    }
    if (uartp->dma_acquired_rx) {
    5c30:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    5c34:	05 24       	jz	$+12     	;abs 0x5c40

00005c36 <.Loc.552.1>:
      dmaReleaseX(&(uartp->dma_rx));
    5c36:	cc 0a       	mova	r10,	r12	;
    5c38:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5c3c:	b0 13 a6 52 	calla	#21158		;0x052a6

00005c40 <.L105>:
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    5c40:	34 0a 16 00 	mova	22(r10),r4	;0x00016
    5c44:	94 d3 00 00 	bis	#1,	0(r4)	;r3 As==01

00005c48 <.LBB79>:
  uint16_t n = uartp->freq / uartp->config->baud;
    5c48:	91 4a 12 00 	mov	18(r10),10(r1)	;0x00012, 0x000a
    5c4c:	0a 00 
    5c4e:	91 4a 14 00 	mov	20(r10),12(r1)	;0x00014, 0x000c
    5c52:	0c 00 
    5c54:	35 0a 04 00 	mova	4(r10),	r5	;
    5c58:	91 45 14 00 	mov	20(r5),	6(r1)	;0x00014
    5c5c:	06 00 
    5c5e:	91 45 16 00 	mov	22(r5),	8(r1)	;0x00016
    5c62:	08 00 
    5c64:	8b 00 ae 9e 	mova	#40622,	r11	;0x09eae
    5c68:	1e 41 06 00 	mov	6(r1),	r14	;
    5c6c:	1f 41 08 00 	mov	8(r1),	r15	;
    5c70:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    5c74:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    5c78:	71 0b 00 00 	mova	r11,	0(r1)	;
    5c7c:	4b 13       	calla	r11		;

00005c7e <.LVL114>:
    5c7e:	07 4c       	mov	r12,	r7	;
    5c80:	81 4c 04 00 	mov	r12,	4(r1)	;

00005c84 <.Loc.158.1>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    5c84:	86 00 e8 9f 	mova	#40936,	r6	;0x09fe8
    5c88:	1e 41 06 00 	mov	6(r1),	r14	;
    5c8c:	1f 41 08 00 	mov	8(r1),	r15	;
    5c90:	4d 43       	clr.b	r13		;
    5c92:	46 13       	calla	r6		;

00005c94 <.LVL116>:
    5c94:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    5c98:	4f 43       	clr.b	r15		;
    5c9a:	18 41 0a 00 	mov	10(r1),	r8	;0x0000a
    5c9e:	19 41 0c 00 	mov	12(r1),	r9	;0x0000c
    5ca2:	40 18 08 8c 	subx.w	r12,	r8	;
    5ca6:	40 18 09 7d 	subcx.w	r13,	r9	;
    5caa:	0c 48       	mov	r8,	r12	;
    5cac:	0d 49       	mov	r9,	r13	;
    5cae:	46 13       	calla	r6		;

00005cb0 <.LVL117>:
    5cb0:	1e 41 06 00 	mov	6(r1),	r14	;
    5cb4:	1f 41 08 00 	mov	8(r1),	r15	;
    5cb8:	0b 01       	mova	@r1,	r11	;
    5cba:	4b 13       	calla	r11		;

00005cbc <.LVL118>:
    5cbc:	8e 00 ae 58 	mova	#22702,	r14	;0x058ae

00005cc0 <.Loc.159.1>:
  if (n > 16) {
    5cc0:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    5cc4:	09 97       	cmp	r7,	r9	;
    5cc6:	90 2c       	jc	$+290    	;abs 0x5de8

00005cc8 <.Loc.160.1>:
    uartp->regs->brw = (n >> 4);
    5cc8:	0d 47       	mov	r7,	r13	;
    5cca:	5d 0f       	rrum	#4,	r13	;
    5ccc:	84 4d 06 00 	mov	r13,	6(r4)	;

00005cd0 <.Loc.162.1>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    5cd0:	4e 13       	calla	r14		;

00005cd2 <.LVL119>:
    5cd2:	09 47       	mov	r7,	r9	;
    5cd4:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    5cd8:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    5cdc:	19 d3       	bis	#1,	r9	;r3 As==01
    5cde:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5ce2:	09 dc       	bis	r12,	r9	;
    5ce4:	84 49 08 00 	mov	r9,	8(r4)	;

00005ce8 <.L110>:
  set_baud(uartp);
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    5ce8:	5c 45 18 00 	mov.b	24(r5),	r12	;0x00018
    5cec:	5c 0f       	rrum	#4,	r12	;
    5cee:	5c 03       	rrum	#1,	r12	;
    5cf0:	5c f3       	and.b	#1,	r12	;r3 As==01
    5cf2:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    5cf6:	84 4c 10 00 	mov	r12,	16(r4)	; 0x0010

00005cfa <.Loc.563.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    5cfa:	5d 45 19 00 	mov.b	25(r5),	r13	;0x00019
    5cfe:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    5d02:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5d04:	0c 9d       	cmp	r13,	r12	;
    5d06:	79 38       	jl	$+244    	;abs 0x5dfa

00005d08 <.Loc.564.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    5d08:	cc 0a       	mova	r10,	r12	;
    5d0a:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5d0e:	b0 13 d2 51 	calla	#20946		;0x051d2

00005d12 <.LVL121>:
    5d12:	c8 0c       	mova	r12,	r8	;

00005d14 <.LVL122>:
    osalDbgAssert(!b, "stream already allocated");
    5d14:	9c 00 00 00 	cmpa	#0,	r12	;
    5d18:	04 24       	jz	$+10     	;abs 0x5d22

00005d1a <.Loc.565.1>:
    5d1a:	8c 01 5a 04 	mova	#66650,	r12	;0x1045a
    5d1e:	b0 13 5c 46 	calla	#18012		;0x0465c

00005d22 <.L112>:
    uartp->dma_acquired_tx = !b;
    5d22:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5d24:	98 00 00 00 	cmpa	#0,	r8	;
    5d28:	01 24       	jz	$+4      	;abs 0x5d2c
    5d2a:	4c 43       	clr.b	r12		;

00005d2c <.L113>:
    5d2c:	ca 4c 62 00 	mov.b	r12,	98(r10)	; 0x0062

00005d30 <.L114>:
  }
  else {
    uartp->dma_acquired_tx = false;
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    5d30:	3c 0a 04 00 	mova	4(r10),	r12	;
    5d34:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    5d38:	5d 0f       	rrum	#4,	r13	;
    5d3a:	68 43       	mov.b	#2,	r8	;r3 As==10
    5d3c:	08 9d       	cmp	r13,	r8	;
    5d3e:	61 38       	jl	$+196    	;abs 0x5e02

00005d40 <.Loc.572.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    5d40:	cc 0a       	mova	r10,	r12	;
    5d42:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5d46:	b0 13 d2 51 	calla	#20946		;0x051d2

00005d4a <.LVL125>:
    5d4a:	c8 0c       	mova	r12,	r8	;

00005d4c <.LVL126>:
    osalDbgAssert(!b, "stream already allocated");
    5d4c:	9c 00 00 00 	cmpa	#0,	r12	;
    5d50:	04 24       	jz	$+10     	;abs 0x5d5a

00005d52 <.Loc.573.1>:
    5d52:	8c 01 5a 04 	mova	#66650,	r12	;0x1045a
    5d56:	b0 13 5c 46 	calla	#18012		;0x0465c

00005d5a <.L116>:
    uartp->dma_acquired_rx = !b;
    5d5a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5d5c:	98 00 00 00 	cmpa	#0,	r8	;
    5d60:	01 24       	jz	$+4      	;abs 0x5d64
    5d62:	4c 43       	clr.b	r12		;

00005d64 <.L117>:
    5d64:	ca 4c 63 00 	mov.b	r12,	99(r10)	; 0x0063

00005d68 <.L118>:
  else {
    uartp->dma_acquired_rx = false;
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    5d68:	00 18 fa 40 	movx.a	#23350,	44(r10)	;0x05b36, 0x0002c
    5d6c:	36 5b 2c 00 

00005d70 <.Loc.582.1>:
  uartp->dmareq_tx.callback.args = uartp;
    5d70:	7a 0a 30 00 	mova	r10,	48(r10)	; 0x00030

00005d74 <.Loc.583.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    5d74:	00 18 fa 40 	movx.a	#23258,	70(r10)	;0x05ada, 0x00046
    5d78:	da 5a 46 00 

00005d7c <.Loc.584.1>:
  uartp->dmareq_rx.callback.args = uartp;
    5d7c:	7a 0a 4a 00 	mova	r10,	74(r10)	; 0x0004a

00005d80 <.Loc.598.1>:
        (UCRXEIE) | (UCBRKIE));

  }
#endif
#if MSP430X_UART_USE_UARTA1 == TRUE
  if (&UARTDA1 == uartp) {
    5d80:	9a 01 0e 08 	cmpa	#67598,	r10	;0x1080e
    5d84:	29 20       	jnz	$+84     	;abs 0x5dd8

00005d86 <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5d86:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5d8a:	38 0a 04 00 	mova	4(r10),	r8	;

00005d8e <.Loc.603.1>:
        (uartp->config->order << 13) | 
        (uartp->config->char_size << 12) | 
        (uartp->config->stop_bits << 11) |
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5d8e:	5e 48 18 00 	mov.b	24(r8),	r14	;0x00018
    5d92:	0f 4e       	mov	r14,	r15	;
    5d94:	5f 0f       	rrum	#4,	r15	;
    5d96:	5f 03       	rrum	#1,	r15	;
    5d98:	5f f3       	and.b	#1,	r15	;r3 As==01

00005d9a <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5d9a:	0d 4e       	mov	r14,	r13	;
    5d9c:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;

00005da0 <.Loc.600.1>:
        (uartp->config->order << 13) | 
    5da0:	09 4e       	mov	r14,	r9	;
    5da2:	4a 18 09 59 	rpt #11 { rlax.w	r9		;
    5da6:	39 f0 00 20 	and	#8192,	r9	;#0x2000

00005daa <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5daa:	0d d9       	bis	r9,	r13	;

00005dac <.Loc.605.1>:
        (MSP430X_UARTA1_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));
    5dac:	3d d0 b0 00 	bis	#176,	r13	;#0x00b0

00005db0 <.Loc.601.1>:
        (uartp->config->char_size << 12) | 
    5db0:	09 4e       	mov	r14,	r9	;
    5db2:	48 18 09 59 	rpt #9 { rlax.w	r9		;
    5db6:	39 f0 00 10 	and	#4096,	r9	;#0x1000

00005dba <.Loc.605.1>:
        (UCRXEIE) | (UCBRKIE));
    5dba:	0d d9       	bis	r9,	r13	;

00005dbc <.Loc.602.1>:
        (uartp->config->stop_bits << 11) |
    5dbc:	46 18 0e 5e 	rpt #7 { rlax.w	r14		;
    5dc0:	3e f0 00 08 	and	#2048,	r14	;#0x0800

00005dc4 <.Loc.605.1>:
        (UCRXEIE) | (UCBRKIE));
    5dc4:	0d de       	bis	r14,	r13	;

00005dc6 <.Loc.603.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5dc6:	0e 4f       	mov	r15,	r14	;
    5dc8:	49 18 0e 5e 	rpt #10 { rlax.w	r14		;

00005dcc <.Loc.605.1>:
        (UCRXEIE) | (UCBRKIE));
    5dcc:	0d de       	bis	r14,	r13	;

00005dce <.Loc.603.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5dce:	48 18 0f 5f 	rpt #9 { rlax.w	r15		;

00005dd2 <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5dd2:	0d df       	bis	r15,	r13	;
    5dd4:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005dd8 <.L119>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    5dd8:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5ddc:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005de0 <.Loc.634.1>:
}
    5de0:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    5de4:	64 16       	popm.a	#7,	r10	;20-bit words
    5de6:	10 01       	reta			;

00005de8 <.L109>:
    uartp->regs->brw = n;
    5de8:	84 47 06 00 	mov	r7,	6(r4)	;

00005dec <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    5dec:	4e 13       	calla	r14		;

00005dee <.LVL130>:
    5dee:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5df2:	84 4c 08 00 	mov	r12,	8(r4)	;
    5df6:	80 00 e8 5c 	mova	#23784,	r0	;0x05ce8

00005dfa <.L111>:
    uartp->dma_acquired_tx = false;
    5dfa:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062
    5dfe:	80 00 30 5d 	mova	#23856,	r0	;0x05d30

00005e02 <.L115>:
    uartp->dma_acquired_rx = false;
    5e02:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063
    5e06:	80 00 68 5d 	mova	#23912,	r0	;0x05d68

00005e0a <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    5e0a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005e0c <.LCFI8>:
    5e0c:	08 14       	pushm.a	#1,	r8	;20-bit words

00005e0e <.LCFI9>:
    5e0e:	06 14       	pushm.a	#1,	r6	;20-bit words

00005e10 <.LCFI10>:
    5e10:	ca 0c       	mova	r12,	r10	;

00005e12 <.Loc.667.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    5e12:	7c 0e 1a 00 	mova	r14,	26(r12)	; 0x0001a

00005e16 <.Loc.668.1>:
  uartp->dmareq_tx.size = n;
    5e16:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

00005e1a <.Loc.670.1>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    5e1a:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00005e1e <.L137>:
    5e1e:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    5e22:	1c 00 
    5e24:	fc 27       	jz	$-6      	;abs 0x5e1e

00005e26 <.Loc.671.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    5e26:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

00005e2a <.Loc.673.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    5e2a:	c8 0a       	mova	r10,	r8	;
    5e2c:	a8 00 4e 00 	adda	#78,	r8	;0x0004e
    5e30:	c6 0a       	mova	r10,	r6	;
    5e32:	a6 00 1a 00 	adda	#26,	r6	;0x0001a

00005e36 <.LBB85>:
  if (!(*acquired)) {
    5e36:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    5e3a:	05 20       	jnz	$+12     	;abs 0x5e46

00005e3c <.Loc.173.1>:
    dmaAcquireI(dma);
    5e3c:	cc 08       	mova	r8,	r12	;
    5e3e:	b0 13 64 51 	calla	#20836		;0x05164

00005e42 <.LVL139>:
    (*acquired) = true;
    5e42:	da 43 62 00 	mov.b	#1,	98(r10)	;r3 As==01, 0x0062

00005e46 <.L138>:
  dmaTransferI(dma, req);
    5e46:	cd 06       	mova	r6,	r13	;
    5e48:	cc 08       	mova	r8,	r12	;
    5e4a:	b0 13 2a 52 	calla	#21034		;0x0522a

00005e4e <.LBE85>:
  
  uartp->regs->ifg |= UCTXIFG;
    5e4e:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5e52:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00005e56 <.Loc.676.1>:
}
    5e56:	06 16       	popm.a	#1,	r6	;20-bit words
    5e58:	08 16       	popm.a	#1,	r8	;20-bit words
    5e5a:	0a 16       	popm.a	#1,	r10	;20-bit words
    5e5c:	10 01       	reta			;

00005e5e <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    5e5e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005e60 <.LCFI13>:
    5e60:	08 14       	pushm.a	#1,	r8	;20-bit words

00005e62 <.LCFI14>:
    5e62:	06 14       	pushm.a	#1,	r6	;20-bit words

00005e64 <.LCFI15>:
    5e64:	ca 0c       	mova	r12,	r10	;

00005e66 <.Loc.720.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    5e66:	7c 0e 38 00 	mova	r14,	56(r12)	; 0x00038

00005e6a <.Loc.721.1>:
  uartp->dmareq_rx.size = n;
    5e6a:	8c 4d 3c 00 	mov	r13,	60(r12)	; 0x003c

00005e6e <.Loc.724.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    5e6e:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00005e72 <.LVL146>:
    5e72:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00005e76 <.Loc.726.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    5e76:	c8 0a       	mova	r10,	r8	;
    5e78:	a8 00 58 00 	adda	#88,	r8	;0x00058
    5e7c:	c6 0a       	mova	r10,	r6	;
    5e7e:	a6 00 34 00 	adda	#52,	r6	;0x00034

00005e82 <.LBB89>:
  if (!(*acquired)) {
    5e82:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    5e86:	05 20       	jnz	$+12     	;abs 0x5e92

00005e88 <.Loc.173.1>:
    dmaAcquireI(dma);
    5e88:	cc 08       	mova	r8,	r12	;
    5e8a:	b0 13 64 51 	calla	#20836		;0x05164

00005e8e <.LVL148>:
    (*acquired) = true;
    5e8e:	da 43 63 00 	mov.b	#1,	99(r10)	;r3 As==01, 0x0063

00005e92 <.L144>:
  dmaTransferI(dma, req);
    5e92:	cd 06       	mova	r6,	r13	;
    5e94:	cc 08       	mova	r8,	r12	;
    5e96:	b0 13 2a 52 	calla	#21034		;0x0522a

00005e9a <.LBE89>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    5e9a:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5e9e:	40 18 9c b3 	bitx.w	#1,	28(r12)	;r3 As==01, 0x0001c
    5ea2:	1c 00 
    5ea4:	04 24       	jz	$+10     	;abs 0x5eae

00005ea6 <.Loc.730.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    5ea6:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005eaa <.Loc.731.1>:
    uartp->regs->ifg |= UCRXIFG;
    5eaa:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00005eae <.L143>:
  }
}
    5eae:	06 16       	popm.a	#1,	r6	;20-bit words
    5eb0:	08 16       	popm.a	#1,	r8	;20-bit words
    5eb2:	0a 16       	popm.a	#1,	r10	;20-bit words
    5eb4:	10 01       	reta			;

00005eb6 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    5eb6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005eb8 <.LCFI16>:
    5eb8:	08 14       	pushm.a	#1,	r8	;20-bit words

00005eba <.LCFI17>:
    5eba:	06 14       	pushm.a	#1,	r6	;20-bit words

00005ebc <.LCFI18>:
    5ebc:	c6 0c       	mova	r12,	r6	;

00005ebe <.Loc.748.1>:

  size_t result = uartp->dma_rx.registers->sz;
    5ebe:	3c 0c 58 00 	mova	88(r12),r12	;0x00058

00005ec2 <.LVL151>:
    5ec2:	40 18 1a 4c 	movx.w	10(r12),r10	;0x0000a
    5ec6:	0a 00 

00005ec8 <.Loc.749.1>:
  dmaCancelI(&(uartp->dma_rx));
    5ec8:	c8 06       	mova	r6,	r8	;
    5eca:	a8 00 58 00 	adda	#88,	r8	;0x00058
    5ece:	cc 08       	mova	r8,	r12	;
    5ed0:	b0 13 ec 52 	calla	#21228		;0x052ec

00005ed4 <.LVL153>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  if (uartp->config->dmarx_index >= MSP430X_DMA_CHANNELS) {
    5ed4:	3c 06 04 00 	mova	4(r6),	r12	;
    5ed8:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f
    5edc:	5d 9c 19 00 	cmp.b	25(r12),r13	;0x00019
    5ee0:	05 2c       	jc	$+12     	;abs 0x5eec

00005ee2 <.Loc.752.1>:
    dmaReleaseX(&(uartp->dma_rx));
    5ee2:	cc 08       	mova	r8,	r12	;
    5ee4:	b0 13 a6 52 	calla	#21158		;0x052a6

00005ee8 <.LVL154>:
    uartp->dma_acquired_rx = false;
    5ee8:	c6 43 63 00 	mov.b	#0,	99(r6)	;r3 As==00, 0x0063

00005eec <.L150>:
#else
  dmaReleaseX(&(uartp->dma_rx));
  uartp->dma_acquired_rx = false;
#endif
  
  uartp->regs->ifg &= ~UCRXIFG;
    5eec:	3c 06 16 00 	mova	22(r6),	r12	;0x00016
    5ef0:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005ef4 <.Loc.761.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    5ef4:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005ef8 <.Loc.764.1>:

  return result;
}
    5ef8:	cc 0a       	mova	r10,	r12	;
    5efa:	06 16       	popm.a	#1,	r6	;20-bit words
    5efc:	08 16       	popm.a	#1,	r8	;20-bit words
    5efe:	0a 16       	popm.a	#1,	r10	;20-bit words
    5f00:	10 01       	reta			;

00005f02 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    5f02:	8c 01 72 08 	mova	#67698,	r12	;0x10872
    5f06:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    5f0a:	80 03 06 00 

00005f0e <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    5f0e:	b0 13 82 4d 	calla	#19842		;0x04d82

00005f12 <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    5f12:	10 01       	reta			;

00005f14 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    5f14:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005f16 <.LCFI0>:
    5f16:	ca 0c       	mova	r12,	r10	;

00005f18 <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    5f18:	9c 01 72 08 	cmpa	#67698,	r12	;0x10872
    5f1c:	32 20       	jnz	$+102    	;abs 0x5f82

00005f1e <.Loc.301.1>:
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    5f1e:	3c 0c 06 00 	mova	6(r12),	r12	;

00005f22 <.LVL3>:
    5f22:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    5f26:	00 00 

00005f28 <.Loc.304.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    5f28:	3c 0a 02 00 	mova	2(r10),	r12	;
    5f2c:	2e 4c       	mov	@r12,	r14	;
    5f2e:	1f 4c 02 00 	mov	2(r12),	r15	;
    5f32:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    5f36:	4d 43       	clr.b	r13		;
    5f38:	b0 13 ae 9e 	calla	#40622		;0x09eae
    5f3c:	08 4c       	mov	r12,	r8	;
    5f3e:	09 4d       	mov	r13,	r9	;

00005f40 <.LVL5>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5f40:	0d 93       	cmp	#0,	r13	;r3 As==00
    5f42:	04 20       	jnz	$+10     	;abs 0x5f4c
    5f44:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    5f48:	0c 98       	cmp	r8,	r12	;
    5f4a:	04 2c       	jc	$+10     	;abs 0x5f54

00005f4c <.L11>:
    5f4c:	8c 01 7c 04 	mova	#66684,	r12	;0x1047c
    5f50:	b0 13 5c 46 	calla	#18012		;0x0465c

00005f54 <.L3>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    5f54:	0c 48       	mov	r8,	r12	;
    5f56:	7c f0 07 00 	and.b	#7,	r12	;
    5f5a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f5c:	14 24       	jz	$+42     	;abs 0x5f86

00005f5e <.Loc.348.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    divider /= 8;
  }
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    5f5e:	0c 48       	mov	r8,	r12	;
    5f60:	7c f0 03 00 	and.b	#3,	r12	;
    5f64:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f66:	2b 20       	jnz	$+88     	;abs 0x5fbe

00005f68 <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    5f68:	3c 0a 06 00 	mova	6(r10),	r12	;
    5f6c:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    5f70:	00 00 

00005f72 <.Loc.350.1>:
    divider /= 4;
    5f72:	40 19 09 10 	rrux.w	r9		;
    5f76:	08 10       	rrc	r8		;
    5f78:	40 19 09 10 	rrux.w	r9		;
    5f7c:	08 10       	rrc	r8		;
    5f7e:	80 00 9c 5f 	mova	#24476,	r0	;0x05f9c

00005f82 <.L10>:
  uint32_t divider = 0;
    5f82:	48 43       	clr.b	r8		;
    5f84:	49 43       	clr.b	r9		;

00005f86 <.L13>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    5f86:	3c 0a 06 00 	mova	6(r10),	r12	;
    5f8a:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    5f8e:	00 00 

00005f90 <.Loc.346.1>:
    divider /= 8;
    5f90:	0c 48       	mov	r8,	r12	;
    5f92:	0d 49       	mov	r9,	r13	;
    5f94:	b0 13 c6 9f 	calla	#40902		;0x09fc6
    5f98:	08 4c       	mov	r12,	r8	;
    5f9a:	09 4d       	mov	r13,	r9	;

00005f9c <.L6>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    5f9c:	09 93       	cmp	#0,	r9	;r3 As==00
    5f9e:	03 20       	jnz	$+8      	;abs 0x5fa6
    5fa0:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5fa2:	0d 98       	cmp	r8,	r13	;
    5fa4:	04 2c       	jc	$+10     	;abs 0x5fae

00005fa6 <.L12>:
    5fa6:	8c 01 7c 04 	mova	#66684,	r12	;0x1047c
    5faa:	b0 13 5c 46 	calla	#18012		;0x0465c

00005fae <.L8>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    5fae:	3c 0a 06 00 	mova	6(r10),	r12	;
    5fb2:	0d 48       	mov	r8,	r13	;
    5fb4:	3d 53       	add	#-1,	r13	;r3 As==11
    5fb6:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

00005fba <.Loc.359.1>:

}
    5fba:	28 16       	popm.a	#3,	r10	;20-bit words
    5fbc:	10 01       	reta			;

00005fbe <.L7>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    5fbe:	0c 48       	mov	r8,	r12	;
    5fc0:	5c f3       	and.b	#1,	r12	;r3 As==01
    5fc2:	0c 93       	cmp	#0,	r12	;r3 As==00
    5fc4:	eb 23       	jnz	$-40     	;abs 0x5f9c

00005fc6 <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    5fc6:	3c 0a 06 00 	mova	6(r10),	r12	;
    5fca:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    5fce:	00 00 

00005fd0 <.Loc.354.1>:
    divider /= 2;
    5fd0:	12 c3       	clrc			
    5fd2:	09 10       	rrc	r9		;
    5fd4:	08 10       	rrc	r8		;
    5fd6:	80 00 9c 5f 	mova	#24476,	r0	;0x05f9c

00005fda <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    5fda:	3e 0c 02 00 	mova	2(r12),	r14	;
    5fde:	3c 0c 06 00 	mova	6(r12),	r12	;

00005fe2 <.LVL17>:
    5fe2:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    5fe6:	04 00 
    5fe8:	02 24       	jz	$+6      	;abs 0x5fee

00005fea <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    5fea:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005fee <.L17>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    5fee:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00005ff2 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    5ff2:	2d 4c       	mov	@r12,	r13	;

00005ff4 <.LVL18>:
    5ff4:	3d d0 14 00 	bis	#20,	r13	;#0x0014
    5ff8:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005ffc <.Loc.398.1>:
}
    5ffc:	10 01       	reta			;

00005ffe <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    5ffe:	3c 0c 06 00 	mova	6(r12),	r12	;

00006002 <.LVL20>:
    6002:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    6006:	00 00 

00006008 <.Loc.412.1>:

}
    6008:	10 01       	reta			;

0000600a <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    600a:	32 c2       	dint			
    600c:	03 43       	nop			

0000600e <.Loc.46.1>:

}
    600e:	10 01       	reta			;

00006010 <send_complete_cb>:

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    6010:	00 18 c2 43 	movx.a	#0,	&0xfa216;r3 As==00
    6014:	16 a2 

00006016 <.Loc.57.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    6016:	40 18 f2 d0 	bisx.b	#3,	&0xfc854;
    601a:	03 00 54 c8 

0000601e <.LBB10>:
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->fullsem);
    601e:	40 18 1c 42 	movx.w	&0x0a22a,r12	;
    6022:	2a a2 

00006024 <.LBE10>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    6024:	4d 43       	clr.b	r13		;
    6026:	0d 9c       	cmp	r12,	r13	;
    6028:	06 34       	jge	$+14     	;abs 0x6036

0000602a <.Loc.60.1>:
    events |= UARTBufferPosted;
    602a:	40 18 a2 d3 	bisx.w	#2,	&0xfc850;r3 As==10
    602e:	50 c8 
    6030:	40 18 82 dd 	bisx.w	r13,	&0xfc852;
    6034:	52 c8 

00006036 <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    6036:	2c 00 4c c8 	mova	&51276,	r12	;0x0c84c
    603a:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    603e:	04 24       	jz	$+10     	;abs 0x6048

00006040 <.Loc.64.1>:
    chSchReadyI(uart_thd, MSG_RESET);
    6040:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    6044:	b0 13 2c 47 	calla	#18220		;0x0472c

00006048 <.L1>:
  }
  chSysUnlockFromISR();
}
    6048:	10 01       	reta			;

0000604a <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    604a:	01 18 d2 92 	cmpx.a	&0x0c84c,&0x10704;
    604e:	4c c8 04 07 
    6052:	04 20       	jnz	$+10     	;abs 0x605c

00006054 <.Loc.19.1>:
    6054:	8c 01 b5 04 	mova	#66741,	r12	;0x104b5
    6058:	b0 13 5c 46 	calla	#18012		;0x0465c

0000605c <.L7>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    605c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    605e:	4e 43       	clr.b	r14		;
    6060:	2c 00 4c c8 	mova	&51276,	r12	;0x0c84c
    6064:	b0 13 70 49 	calla	#18800		;0x04970

00006068 <.LVL7>:
}
    6068:	10 01       	reta			;

0000606a <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    606a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000606c <.LCFI0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    606c:	cd 0c       	mova	r12,	r13	;
    606e:	8c 00 1a a2 	mova	#41498,	r12	;0x0a21a

00006072 <.LVL9>:
    6072:	b0 13 c2 4a 	calla	#19138		;0x04ac2

00006076 <.LVL10>:
    6076:	ca 0c       	mova	r12,	r10	;

00006078 <.Loc.26.1>:
  if (MSG_OK == msg) {
    6078:	9c 00 00 00 	cmpa	#0,	r12	;
    607c:	09 20       	jnz	$+20     	;abs 0x6090

0000607e <.Loc.27.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    607e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6080:	4e 43       	clr.b	r14		;
    6082:	2c 00 4c c8 	mova	&51276,	r12	;0x0c84c
    6086:	b0 13 9c 49 	calla	#18844		;0x0499c

0000608a <.L8>:
}
    608a:	cc 0a       	mova	r10,	r12	;
    608c:	0a 16       	popm.a	#1,	r10	;20-bit words
    608e:	10 01       	reta			;

00006090 <.L9>:
    chDbgAssert(false, "an error");
    6090:	8c 01 a8 04 	mova	#66728,	r12	;0x104a8
    6094:	b0 13 5c 46 	calla	#18012		;0x0465c

00006098 <.LVL13>:
  return msg;
    6098:	80 00 8a 60 	mova	#24714,	r0	;0x0608a

0000609c <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    609c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000609e <.LBB16>:
  _disable_interrupts();
    609e:	32 c2       	dint			
    60a0:	03 43       	nop			

000060a2 <.Loc.348.3>:
  asm volatile("nop");
    60a2:	03 43       	nop			

000060a4 <.LBE16>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    60a4:	0e 4d       	mov	r13,	r14	;
    60a6:	cd 0c       	mova	r12,	r13	;

000060a8 <.LVL15>:
    60a8:	8c 00 1a a2 	mova	#41498,	r12	;0x0a21a

000060ac <.LVL16>:
    60ac:	b0 13 48 4a 	calla	#19016		;0x04a48

000060b0 <.LVL17>:
    60b0:	ca 0c       	mova	r12,	r10	;

000060b2 <.Loc.42.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    60b2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    60b4:	4e 43       	clr.b	r14		;
    60b6:	2c 00 4c c8 	mova	&51276,	r12	;0x0c84c
    60ba:	b0 13 9c 49 	calla	#18844		;0x0499c

000060be <.LBB18>:
  asm volatile("nop");
    60be:	03 43       	nop			

000060c0 <.Loc.356.3>:
  _enable_interrupts();
    60c0:	03 43       	nop			
    60c2:	32 d2       	eint			
    60c4:	03 43       	nop			

000060c6 <.LBE18>:
}
    60c6:	cc 0a       	mova	r10,	r12	;
    60c8:	0a 16       	popm.a	#1,	r10	;20-bit words
    60ca:	10 01       	reta			;

000060cc <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 256);
THD_FUNCTION(UARTThd, arg) {
    60cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000060ce <.LCFI2>:
    60ce:	08 14       	pushm.a	#1,	r8	;20-bit words

000060d0 <.LCFI3>:
    60d0:	06 14       	pushm.a	#1,	r6	;20-bit words

000060d2 <.LCFI4>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    60d2:	80 18 d2 42 	movx.a	&0x10704,&0xfc84c;
    60d6:	04 07 4c c8 

000060da <.Loc.99.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    60da:	40 18 f2 40 	movx.b	#7,	&0xfc854;
    60de:	07 00 54 c8 

000060e2 <.LBB36>:
  _disable_interrupts();
    60e2:	32 c2       	dint			
    60e4:	03 43       	nop			

000060e6 <.Loc.348.3>:
  asm volatile("nop");
    60e6:	03 43       	nop			

000060e8 <.LBE36>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    60e8:	00 18 c2 93 	cmpx.a	#0,	&0xfa216;r3 As==00
    60ec:	16 a2 
    60ee:	06 20       	jnz	$+14     	;abs 0x60fc

000060f0 <.LBB38>:
    60f0:	40 18 1c 42 	movx.w	&0x0a22a,r12	;
    60f4:	2a a2 

000060f6 <.LBE38>:
    60f6:	4d 43       	clr.b	r13		;
    60f8:	0d 9c       	cmp	r12,	r13	;
    60fa:	06 34       	jge	$+14     	;abs 0x6108

000060fc <.L14>:
    events |= UARTBufferPosted;
    60fc:	40 18 a2 d3 	bisx.w	#2,	&0xfc850;r3 As==10
    6100:	50 c8 
    6102:	40 18 82 d3 	bisx.w	#0,	&0xfc852;r3 As==00
    6106:	52 c8 

00006108 <.L15>:
  asm volatile("nop");
    6108:	03 43       	nop			

0000610a <.Loc.356.3>:
  _enable_interrupts();
    610a:	03 43       	nop			
    610c:	32 d2       	eint			
    610e:	03 43       	nop			

00006110 <.LBE40>:
  }
  chSysUnlock();
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    6110:	40 18 92 d3 	bisx.w	#1,	&0xfc850;r3 As==01
    6114:	50 c8 
    6116:	40 18 82 d3 	bisx.w	#0,	&0xfc852;r3 As==00
    611a:	52 c8 

0000611c <.Loc.112.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    611c:	8d 01 de 04 	mova	#66782,	r13	;0x104de
    6120:	8c 01 72 08 	mova	#67698,	r12	;0x10872
    6124:	b0 13 8e 4d 	calla	#19854		;0x04d8e

00006128 <.LVL24>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    6128:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    612c:	b0 13 52 93 	calla	#37714		;0x09352

00006130 <.LVL25>:
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    6130:	2a 01 ca 05 	mova	&67018,	r10	;0x105ca
    6134:	86 00 14 a2 	mova	#41492,	r6	;0x0a214

00006138 <.Loc.129.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    6138:	88 00 fc a1 	mova	#41468,	r8	;0x0a1fc

0000613c <.L16>:
    if (events & UARTConfigUpdated) {
    613c:	40 18 d2 b3 	bitx.b	#1,	&0xfc850;r3 As==01
    6140:	50 c8 
    6142:	3d 24       	jz	$+124    	;abs 0x61be

00006144 <.LBB42>:
  _disable_interrupts();
    6144:	32 c2       	dint			
    6146:	03 43       	nop			

00006148 <.Loc.348.3>:
  asm volatile("nop");
    6148:	03 43       	nop			

0000614a <.LBE42>:
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    614a:	5c 4a 26 00 	mov.b	38(r10),r12	;0x00026
    614e:	4f 4c       	mov.b	r12,	r15	;
    6150:	7f f0 03 00 	and.b	#3,	r15	;
    6154:	6d 46       	mov.b	@r6,	r13	;
    6156:	7d f0 ec ff 	and.b	#-20,	r13	;#0xffec

0000615a <.Loc.125.1>:
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    615a:	0e 4c       	mov	r12,	r14	;
    615c:	5e 07       	rrum	#2,	r14	;
    615e:	5e f3       	and.b	#1,	r14	;r3 As==01
    6160:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    6164:	4d df       	bis.b	r15,	r13	;
    6166:	4d de       	bis.b	r14,	r13	;

00006168 <.Loc.127.1>:
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    6168:	5c 0b       	rrum	#3,	r12	;
    616a:	5c f3       	and.b	#1,	r12	;r3 As==01
    616c:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    6170:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    6174:	4d dc       	bis.b	r12,	r13	;
    6176:	c6 4d 00 00 	mov.b	r13,	0(r6)	;

0000617a <.Loc.131.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    617a:	5d 4a 23 00 	mov.b	35(r10),r13	;0x00023
    617e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6182:	5c 4a 25 00 	mov.b	37(r10),r12	;0x00025
    6186:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    618a:	5e 4a 24 00 	mov.b	36(r10),r14	;0x00024
    618e:	0c de       	bis	r14,	r12	;

00006190 <.Loc.129.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    6190:	5e 4a 22 00 	mov.b	34(r10),r14	;0x00022
    6194:	0e dd       	bis	r13,	r14	;
    6196:	88 4e 14 00 	mov	r14,	20(r8)	; 0x0014
    619a:	88 4c 16 00 	mov	r12,	22(r8)	; 0x0016

0000619e <.LBB44>:
  asm volatile("nop");
    619e:	03 43       	nop			

000061a0 <.Loc.356.3>:
  _enable_interrupts();
    61a0:	03 43       	nop			
    61a2:	32 d2       	eint			
    61a4:	03 43       	nop			

000061a6 <.LBE44>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
      
      chSysUnlock();
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    61a6:	8d 00 fc a1 	mova	#41468,	r13	;0x0a1fc
    61aa:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    61ae:	b0 13 fe 4e 	calla	#20222		;0x04efe

000061b2 <.LVL26>:
      events &= ~UARTConfigUpdated;
    61b2:	40 18 92 c3 	bicx.w	#1,	&0xfc850;r3 As==01
    61b6:	50 c8 
    61b8:	40 18 82 c3 	bicx.w	#0,	&0xfc852;r3 As==00
    61bc:	52 c8 

000061be <.L17>:
    }
    if (events & UARTBufferPosted) {
    61be:	40 18 e2 b3 	bitx.b	#2,	&0xfc850;r3 As==10
    61c2:	50 c8 
    61c4:	31 24       	jz	$+100    	;abs 0x6228

000061c6 <.Loc.140.1>:
      if (NULL == tx_active_buffer) {
    61c6:	00 18 c2 93 	cmpx.a	#0,	&0xfa216;r3 As==00
    61ca:	16 a2 
    61cc:	1d 20       	jnz	$+60     	;abs 0x6208

000061ce <.LBB46>:
  _disable_interrupts();
    61ce:	32 c2       	dint			
    61d0:	03 43       	nop			

000061d2 <.Loc.348.3>:
  asm volatile("nop");
    61d2:	03 43       	nop			

000061d4 <.LBE46>:
        /* Get the buffer */
        chSysLock();
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    61d4:	3e 43       	mov	#-1,	r14	;r3 As==11
    61d6:	8d 00 16 a2 	mova	#41494,	r13	;0x0a216
    61da:	8c 00 1a a2 	mova	#41498,	r12	;0x0a21a
    61de:	b0 13 20 4b 	calla	#19232		;0x04b20

000061e2 <.LVL27>:
        if (result != MSG_OK) {
    61e2:	9c 00 00 00 	cmpa	#0,	r12	;
    61e6:	0c 24       	jz	$+26     	;abs 0x6200

000061e8 <.Loc.145.1>:
          events &= ~UARTBufferPosted;
    61e8:	40 18 a2 c3 	bicx.w	#2,	&0xfc850;r3 As==10
    61ec:	50 c8 
    61ee:	40 18 82 c3 	bicx.w	#0,	&0xfc852;r3 As==00
    61f2:	52 c8 

000061f4 <.LBB48>:
  asm volatile("nop");
    61f4:	03 43       	nop			

000061f6 <.Loc.356.3>:
  _enable_interrupts();
    61f6:	03 43       	nop			
    61f8:	32 d2       	eint			
    61fa:	03 43       	nop			

000061fc <.LBE48>:
          chSysUnlock();
          /* Skip to the next loop */
          continue;
    61fc:	80 00 3c 61 	mova	#24892,	r0	;0x0613c

00006200 <.L22>:
  asm volatile("nop");
    6200:	03 43       	nop			

00006202 <.Loc.356.3>:
  _enable_interrupts();
    6202:	03 43       	nop			
    6204:	32 d2       	eint			
    6206:	03 43       	nop			

00006208 <.L21>:
        }
        chSysUnlock();
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    6208:	2d 00 16 a2 	mova	&41494,	r13	;0x0a216
    620c:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    6210:	b0 13 ac 92 	calla	#37548		;0x092ac

00006214 <.LVL29>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    6214:	c0 1f f2 f0 	andx.b	#-4,	&0xfc854;0xffffc
    6218:	fc ff 54 c8 

0000621c <.Loc.159.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    621c:	40 18 a2 c3 	bicx.w	#2,	&0xfc850;r3 As==10
    6220:	50 c8 
    6222:	40 18 82 c3 	bicx.w	#0,	&0xfc852;r3 As==00
    6226:	52 c8 

00006228 <.L19>:
    }
    if (events & UARTRxBufferReady) {
    6228:	40 18 e2 b2 	bitx.b	#4,	&0xfc850;r2 As==10
    622c:	50 c8 
    622e:	08 24       	jz	$+18     	;abs 0x6240

00006230 <.Loc.163.1>:
      
      elyUARTDLLRxHandleBuffer();
    6230:	b0 13 5c 93 	calla	#37724		;0x0935c

00006234 <.LVL30>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    6234:	40 18 a2 c2 	bicx.w	#4,	&0xfc850;r2 As==10
    6238:	50 c8 
    623a:	40 18 82 c3 	bicx.w	#0,	&0xfc852;r3 As==00
    623e:	52 c8 

00006240 <.L24>:
    }
    /* Get next events */
    events |= chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    6240:	4e 43       	clr.b	r14		;
    6242:	5c 42 54 c8 	mov.b	&0xc854,r12	;0xc854
    6246:	0d 43       	clr	r13		;
    6248:	b0 13 e4 49 	calla	#18916		;0x049e4

0000624c <.LVL31>:
    624c:	40 18 82 dc 	bisx.w	r12,	&0xfc850;
    6250:	50 c8 
    6252:	40 18 82 dd 	bisx.w	r13,	&0xfc852;
    6256:	52 c8 
    6258:	80 00 3c 61 	mova	#24892,	r0	;0x0613c

0000625c <fw_allocator>:

#include "main.h"

static uint8_t PERSIST fw_storage[elyFWTotalBuffer];

void * fw_allocator(size_t size, unsigned align) {
    625c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000625e <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyFWTotalBuffer) {
    625e:	2e 00 6a a2 	mova	&41578,	r14	;0x0a26a
    6262:	ca 0e       	mova	r14,	r10	;
    6264:	ea 0c       	adda	r12,	r10	;
    6266:	3c 40 24 04 	mov	#1060,	r12	;#0x0424

0000626a <.LVL1>:
    626a:	dc 0a       	cmpa	r10,	r12	;
    626c:	07 28       	jnc	$+16     	;abs 0x627c

0000626e <.Loc.15.1>:
    return NULL;
  }

  void * result = fw_storage + curr_index;
    626e:	cc 0e       	mova	r14,	r12	;
    6270:	ac 00 6e a2 	adda	#41582,	r12	;0x0a26e

00006274 <.LVL2>:
  
  curr_index += size;
    6274:	60 0a 6a a2 	mova	r10,	&41578	; 0x0a26a

00006278 <.L1>:
  return result;
}
    6278:	0a 16       	popm.a	#1,	r10	;20-bit words
    627a:	10 01       	reta			;

0000627c <.L3>:
    return NULL;
    627c:	4c 43       	clr.b	r12		;
    627e:	80 00 78 62 	mova	#25208,	r0	;0x06278

00006282 <elyFWGetBufferI>:

static PERSIST MEMORYPOOL_DECL(fw_mpool, elyFWBufferMaxSize, fw_allocator);
static SEMAPHORE_DECL(fw_sem, (cnt_t)(elyFWMaxSlots));

uint8_t * elyFWGetBufferI() {
  uint8_t * result =  chPoolAllocI(&fw_mpool);
    6282:	8c 00 5e a2 	mova	#41566,	r12	;0x0a25e
    6286:	b0 13 36 4c 	calla	#19510		;0x04c36

0000628a <.LVL4>:
    628a:	ce 0c       	mova	r12,	r14	;

0000628c <.LVL5>:
  
  if (result == NULL) {
    628c:	9c 00 00 00 	cmpa	#0,	r12	;
    6290:	06 24       	jz	$+14     	;abs 0x629e

00006292 <.Loc.32.1>:
    return NULL;
  }
  
  /* semaphore must be >0 if we got a non-null result */
  chSemFastWaitI(&fw_sem);
    6292:	41 18 b2 53 	addx.w	#-1,	&0x106e8;r3 As==11
    6296:	e8 06 

00006298 <.Loc.33.1>:
  return elyNLToFW(result);
    6298:	b0 13 ee 9d 	calla	#40430		;0x09dee

0000629c <.LVL6>:
    629c:	ce 0c       	mova	r12,	r14	;

0000629e <.L4>:
}
    629e:	cc 0e       	mova	r14,	r12	;
    62a0:	10 01       	reta			;

000062a2 <elyFWGetBuffer>:
  _disable_interrupts();
    62a2:	32 c2       	dint			
    62a4:	03 43       	nop			

000062a6 <.Loc.348.2>:
  asm volatile("nop");
    62a6:	03 43       	nop			

000062a8 <.LBE6>:

uint8_t * elyFWGetBuffer() {
  chSysLock();
  uint8_t * result = elyFWGetBufferI();
    62a8:	b0 13 82 62 	calla	#25218		;0x06282

000062ac <.LBB8>:
  asm volatile("nop");
    62ac:	03 43       	nop			

000062ae <.Loc.356.2>:
  _enable_interrupts();
    62ae:	03 43       	nop			
    62b0:	32 d2       	eint			
    62b2:	03 43       	nop			

000062b4 <.LBE8>:
  chSysUnlock();
  
  return result;
}
    62b4:	10 01       	reta			;

000062b6 <elyFWFreeBufferI>:
  chDbgAssert(NULL != result, "Guarded pool failure");
  return elyNLToFW(result);
}

void elyFWFreeBufferI(uint8_t * buffer) {
  chPoolFreeI(&fw_mpool, buffer);
    62b6:	cd 0c       	mova	r12,	r13	;
    62b8:	8c 00 5e a2 	mova	#41566,	r12	;0x0a25e

000062bc <.LVL19>:
    62bc:	b0 13 84 4c 	calla	#19588		;0x04c84

000062c0 <.LVL20>:
  chSemSignalI(&fw_sem);
    62c0:	8c 01 e8 06 	mova	#67304,	r12	;0x106e8
    62c4:	b0 13 04 49 	calla	#18692		;0x04904

000062c8 <.LVL21>:
}
    62c8:	10 01       	reta			;

000062ca <elyFWFreeBuffer>:
  _disable_interrupts();
    62ca:	32 c2       	dint			
    62cc:	03 43       	nop			

000062ce <.Loc.348.2>:
  asm volatile("nop");
    62ce:	03 43       	nop			

000062d0 <.LBE14>:

void elyFWFreeBuffer(uint8_t * buffer) {
  chSysLock();
  elyFWFreeBufferI(buffer);
    62d0:	b0 13 b6 62 	calla	#25270		;0x062b6

000062d4 <.LVL23>:
  chSchRescheduleS();
    62d4:	b0 13 e2 47 	calla	#18402		;0x047e2

000062d8 <.LBB16>:
  asm volatile("nop");
    62d8:	03 43       	nop			

000062da <.Loc.356.2>:
  _enable_interrupts();
    62da:	03 43       	nop			
    62dc:	32 d2       	eint			
    62de:	03 43       	nop			

000062e0 <.LBE16>:
  chSysUnlock();
}
    62e0:	10 01       	reta			;

000062e2 <port_lock>:
  _disable_interrupts();
    62e2:	32 c2       	dint			
    62e4:	03 43       	nop			

000062e6 <.Loc.348.1>:
  asm volatile("nop");
    62e6:	03 43       	nop			

000062e8 <.Loc.349.1>:
}
    62e8:	10 01       	reta			;

000062ea <port_unlock>:
  asm volatile("nop");
    62ea:	03 43       	nop			

000062ec <.Loc.356.1>:
  _enable_interrupts();
    62ec:	03 43       	nop			
    62ee:	32 d2       	eint			
    62f0:	03 43       	nop			

000062f2 <.Loc.357.1>:
}
    62f2:	10 01       	reta			;

000062f4 <reset>:
  
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLFromFW(buffer));
    62f4:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000062f8 <.LVL1>:
    62f8:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000062fc <.LVL2>:
  active_buffer = NULL; /* have to null before reset */
    62fc:	00 18 c2 43 	movx.a	#0,	&0xfc868;r3 As==00
    6300:	68 c8 

00006302 <.Loc.168.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6302:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    6306:	48 a5 20 01 

0000630a <.Loc.169.2>:
}
    630a:	10 01       	reta			;

0000630c <write_failure>:
static void write_failure(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    630c:	2d 4d       	mov	@r13,	r13	;

0000630e <.LVL4>:
    630e:	0e 4d       	mov	r13,	r14	;
    6310:	5e 07       	rrum	#2,	r14	;
    6312:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f

00006316 <.Loc.61.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    6316:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

0000631a <.Loc.62.2>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    631a:	5d f3       	and.b	#1,	r13	;r3 As==01
    631c:	0d 93       	cmp	#0,	r13	;r3 As==00
    631e:	12 20       	jnz	$+38     	;abs 0x6344
    6320:	0e 4d       	mov	r13,	r14	;

00006322 <.L5>:
    6322:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00006326 <.Loc.63.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    6326:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    632a:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    632e:	02 00 

00006330 <.Loc.64.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    6330:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    6334:	03 00 

00006336 <.Loc.65.2>:
  if (hdr.crc) {
    6336:	0d 93       	cmp	#0,	r13	;r3 As==00
    6338:	04 24       	jz	$+10     	;abs 0x6342

0000633a <.Loc.66.2>:
    crcGenX25(reply_buff, 6);
    633a:	7d 40 06 00 	mov.b	#6,	r13	;
    633e:	b0 13 d4 95 	calla	#38356		;0x095d4

00006342 <.L4>:
}
    6342:	10 01       	reta			;

00006344 <.L7>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    6344:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6346:	80 00 22 63 	mova	#25378,	r0	;0x06322

0000634a <store_telem>:
  elyFWFreeBufferI(elyNLFromFW(buff));
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    634a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000634c <.LCFI0>:
    634c:	b1 00 06 00 	suba	#6,	r1	;

00006350 <.LCFI1>:
    6350:	c8 0c       	mova	r12,	r8	;
    6352:	2a 4d       	mov	@r13,	r10	;

00006354 <.LVL11>:
    6354:	91 4d 02 00 	mov	2(r13),	4(r1)	;
    6358:	04 00 
    635a:	09 4a       	mov	r10,	r9	;
    635c:	59 0f       	rrum	#4,	r9	;
    635e:	59 0f       	rrum	#4,	r9	;

00006360 <.Loc.1468.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6360:	4c 4a       	mov.b	r10,	r12	;

00006362 <.LVL13>:
    6362:	4f 4c       	mov.b	r12,	r15	;
    6364:	6f f3       	and.b	#2,	r15	;r3 As==10
    6366:	47 4f       	mov.b	r15,	r7	;
    6368:	07 93       	cmp	#0,	r7	;r3 As==00
    636a:	1f 20       	jnz	$+64     	;abs 0x63aa
    636c:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000636e <.L12>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    636e:	1c b3       	bit	#1,	r12	;r3 As==01
    6370:	1f 20       	jnz	$+64     	;abs 0x63b0

00006372 <.Loc.1469.2>:
    6372:	4c 43       	clr.b	r12		;

00006374 <.L13>:
    6374:	40 18 4e 49 	movx.b	r9,	r14	;
    6378:	40 18 4e 8f 	subx.b	r15,	r14	;
    637c:	40 18 46 4e 	movx.b	r14,	r6	;
    6380:	40 18 46 8c 	subx.b	r12,	r6	;
    6384:	45 46       	mov.b	r6,	r5	;

00006386 <.LVL15>:
  
  uint8_t * reply_buff = elyFWGetBuffer();
    6386:	71 0d 00 00 	mova	r13,	0(r1)	;
    638a:	b0 13 a2 62 	calla	#25250		;0x062a2

0000638e <.LVL16>:
    638e:	c4 0c       	mova	r12,	r4	;

00006390 <.LVL17>:
  if (reply_buff == NULL) {
    6390:	0d 01       	mova	@r1,	r13	;
    6392:	9c 00 00 00 	cmpa	#0,	r12	;
    6396:	0f 20       	jnz	$+32     	;abs 0x63b6

00006398 <.Loc.1474.2>:
    /* TODO signal a buffer overflow here */
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6398:	cc 08       	mova	r8,	r12	;
    639a:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000639e <.LVL18>:
    639e:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000063a2 <.L11>:
  elyTelemPostBufferS(reply_buff, 
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
  
  /* Reply is posted from callback if needed */
}
    63a2:	a1 00 06 00 	adda	#6,	r1	;
    63a6:	64 16       	popm.a	#7,	r10	;20-bit words
    63a8:	10 01       	reta			;

000063aa <.L17>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    63aa:	6d 42       	mov.b	#4,	r13	;r2 As==10
    63ac:	80 00 6e 63 	mova	#25454,	r0	;0x0636e

000063b0 <.L18>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    63b0:	6c 43       	mov.b	#2,	r12	;r3 As==10
    63b2:	80 00 74 63 	mova	#25460,	r0	;0x06374

000063b6 <.L14>:
  memcpy(reply_buff + 5, buffer + hdr_ext, payload_len);
    63b6:	40 18 06 46 	movx.w	r6,	r6	;

000063ba <.LVL23>:
    63ba:	40 18 0d 4d 	movx.w	r13,	r13	;
    63be:	ce 06       	mova	r6,	r14	;
    63c0:	ed 08       	adda	r8,	r13	;
    63c2:	ac 00 05 00 	adda	#5,	r12	;
    63c6:	b0 13 0a a0 	calla	#40970		;0x0a00a

000063ca <.LVL24>:
  memset(reply_buff + 5 + payload_len, 0, 251 - payload_len);
    63ca:	40 18 3e 40 	movx.w	#251,	r14	;0x000fb
    63ce:	fb 00 
    63d0:	40 18 0e 85 	subx.w	r5,	r14	;
    63d4:	4e 0e       	rlam.a	#4,	r14	;
    63d6:	4e 0d       	rram.a	#4,	r14	;
    63d8:	cc 06       	mova	r6,	r12	;
    63da:	ac 00 05 00 	adda	#5,	r12	;
    63de:	4d 43       	clr.b	r13		;
    63e0:	ec 04       	adda	r4,	r12	;
    63e2:	b0 13 28 a0 	calla	#41000		;0x0a028

000063e6 <.LVL25>:
  telem_stored_hdr = hdr;
    63e6:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    63ea:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000063ee <.LVL27>:
    63ee:	0a d9       	bis	r9,	r10	;
    63f0:	40 18 82 4a 	movx.w	r10,	&0xfc85c;
    63f4:	5c c8 
    63f6:	40 18 92 41 	movx.w	4(r1),	&0xfc85e;
    63fa:	04 00 5e c8 

000063fe <.Loc.1482.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    63fe:	cc 08       	mova	r8,	r12	;
    6400:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006404 <.LVL28>:
    6404:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006408 <.LVL29>:
  chSysLock();
    6408:	b0 13 e2 62 	calla	#25314		;0x062e2

0000640c <.LVL30>:
  elyTelemPostBufferS(reply_buff, 
    640c:	07 93       	cmp	#0,	r7	;r3 As==00
    640e:	09 20       	jnz	$+20     	;abs 0x6422
    6410:	8d 00 2a 64 	mova	#25642,	r13	;0x0642a

00006414 <.L16>:
    6414:	cc 04       	mova	r4,	r12	;
    6416:	b0 13 4c 91 	calla	#37196		;0x0914c

0000641a <.LVL31>:
  chSysUnlock();
    641a:	b0 13 ea 62 	calla	#25322		;0x062ea

0000641e <.LVL32>:
    641e:	80 00 a2 63 	mova	#25506,	r0	;0x063a2

00006422 <.L19>:
  elyTelemPostBufferS(reply_buff, 
    6422:	8d 00 d0 68 	mova	#26832,	r13	;0x068d0
    6426:	80 00 14 64 	mova	#25620,	r0	;0x06414

0000642a <store_telem_noreply_cb>:
  elyFWFreeBufferI(elyNLFromFW(buff));
    642a:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000642e <.LVL34>:
    642e:	b0 13 b6 62 	calla	#25270		;0x062b6

00006432 <.LVL35>:
}
    6432:	10 01       	reta			;

00006434 <upload_fw_noreply_cb>:
    6434:	b0 13 2a 64 	calla	#25642		;0x0642a
    6438:	10 01       	reta			;

0000643a <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    643a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000643c <.LCFI2>:
    643c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000643e <.LCFI3>:
    643e:	b1 00 04 00 	suba	#4,	r1	;

00006442 <.LCFI4>:
    6442:	c6 0c       	mova	r12,	r6	;
    6444:	29 4d       	mov	@r13,	r9	;

00006446 <.LVL37>:
    6446:	1a 4d 02 00 	mov	2(r13),	r10	;

0000644a <.LVL38>:
    644a:	8e 00 fa 9d 	mova	#40442,	r14	;0x09dfa
    644e:	88 00 3e 9b 	mova	#39742,	r8	;0x09b3e

00006452 <.Loc.1303.2>:
  if (hdr.reply) {
    6452:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    6456:	47 24       	jz	$+144    	;abs 0x64e6

00006458 <.LBB26>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    6458:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    645c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6460:	56 4c 05 00 	mov.b	5(r12),	r6	;
    6464:	06 dd       	bis	r13,	r6	;
    6466:	40 18 82 46 	movx.w	r6,	&0xfc85a;
    646a:	5a c8 

0000646c <.Loc.1307.2>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    646c:	4e 13       	calla	r14		;

0000646e <.LVL40>:
    646e:	48 13       	calla	r8		;

00006470 <.LVL41>:
    volatile uint8_t * crc_addr = crcStart();
    6470:	b0 13 b2 96 	calla	#38578		;0x096b2

00006474 <.LVL42>:
    6474:	c8 0c       	mova	r12,	r8	;

00006476 <.LVL43>:
    verify_stored_hdr = hdr;
    6476:	40 18 82 49 	movx.w	r9,	&0xfc860;
    647a:	60 c8 
    647c:	40 18 82 4a 	movx.w	r10,	&0xfc862;
    6480:	62 c8 

00006482 <.Loc.1317.2>:
    chSysLock();
    6482:	8a 00 e2 62 	mova	#25314,	r10	;0x062e2

00006486 <.LVL45>:
    6486:	4a 13       	calla	r10		;

00006488 <.LVL46>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6488:	4d 43       	clr.b	r13		;
    648a:	cc 01       	mova	r1,	r12	;
    648c:	b0 13 6c 99 	calla	#39276		;0x0996c

00006490 <.LVL47>:
    chSysUnlock();
    6490:	86 00 ea 62 	mova	#25322,	r6	;0x062ea
    6494:	46 13       	calla	r6		;

00006496 <.LVL48>:
    req->address = FRAM_FW_BASE; 
    6496:	0c 01       	mova	@r1,	r12	;
    6498:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    649c:	00 00 
    649e:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

000064a2 <.Loc.1324.2>:
    req->special = 1; /* read to a constant register address */
    64a2:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    64a6:	04 00 

000064a8 <.Loc.1325.2>:
    req->size = FRAM_FW_SIZE;
    64a8:	1d 4c 04 00 	mov	4(r12),	r13	;
    64ac:	7d f0 03 00 	and.b	#3,	r13	;
    64b0:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    64b4:	8c 4d 04 00 	mov	r13,	4(r12)	;
    64b8:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    64bc:	7d d0 03 00 	bis.b	#3,	r13	;
    64c0:	6d c2       	bic.b	#4,	r13	;r2 As==10
    64c2:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

000064c6 <.Loc.1326.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    64c6:	7c 08 08 00 	mova	r8,	8(r12)	;

000064ca <.Loc.1327.2>:
    req->callback = verify_fw_cb;
    64ca:	00 18 fc 40 	movx.a	#26864,	12(r12)	;0x068f0, 0x0000c
    64ce:	f0 68 0c 00 

000064d2 <.Loc.1330.2>:
    chSysLock();
    64d2:	4a 13       	calla	r10		;

000064d4 <.LVL49>:
    elyFramPostRequestS(req);
    64d4:	0c 01       	mova	@r1,	r12	;
    64d6:	b0 13 48 99 	calla	#39240		;0x09948

000064da <.LVL50>:
    chSysUnlock();
    64da:	46 13       	calla	r6		;

000064dc <.L22>:
}
    64dc:	a1 00 04 00 	adda	#4,	r1	;
    64e0:	06 16       	popm.a	#1,	r6	;20-bit words
    64e2:	28 16       	popm.a	#3,	r10	;20-bit words
    64e4:	10 01       	reta			;

000064e6 <.L23>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    64e6:	4e 13       	calla	r14		;

000064e8 <.LVL53>:
    64e8:	48 13       	calla	r8		;

000064ea <.LVL54>:
}
    64ea:	80 00 dc 64 	mova	#25820,	r0	;0x064dc

000064ee <write_success>:
static void write_success(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    64ee:	0a 14       	pushm.a	#1,	r10	;20-bit words

000064f0 <.LCFI5>:
    64f0:	2f 4d       	mov	@r13,	r15	;

000064f2 <.LVL56>:
    64f2:	0d 4f       	mov	r15,	r13	;
    64f4:	5d 07       	rrum	#2,	r13	;
    64f6:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

000064fa <.Loc.35.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    64fa:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000064fe <.Loc.36.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    64fe:	2a 01 ca 05 	mova	&67018,	r10	;0x105ca
    6502:	dc 4a 51 00 	mov.b	81(r10),2(r12)	;0x00051
    6506:	02 00 

00006508 <.Loc.37.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    6508:	dc 4a 50 00 	mov.b	80(r10),3(r12)	;0x00050
    650c:	03 00 

0000650e <.Loc.38.2>:
  reply_buff[4] = 1;
    650e:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00006512 <.Loc.39.2>:
  if (hdr.crc) {
    6512:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    6516:	09 24       	jz	$+20     	;abs 0x652a

00006518 <.LBB29>:
    reply_buff[1] = 3;
    6518:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    651c:	01 00 

0000651e <.Loc.41.2>:
    crcGenX25(reply_buff, 7);
    651e:	7d 40 07 00 	mov.b	#7,	r13	;
    6522:	b0 13 d4 95 	calla	#38356		;0x095d4

00006526 <.L25>:
}
    6526:	0a 16       	popm.a	#1,	r10	;20-bit words
    6528:	10 01       	reta			;

0000652a <.L26>:
    reply_buff[1] = 1;
    652a:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01

0000652e <.Loc.46.2>:
}
    652e:	80 00 26 65 	mova	#25894,	r0	;0x06526

00006532 <cancel_fw_eeprom_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    6532:	40 18 1c 42 	movx.w	&0x0c858,r12	;
    6536:	58 c8 

00006538 <.LVL64>:
    6538:	4d 43       	clr.b	r13		;
    653a:	0d 9c       	cmp	r12,	r13	;
    653c:	04 38       	jl	$+10     	;abs 0x6546

0000653e <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    653e:	8c 00 58 c8 	mova	#51288,	r12	;0x0c858
    6542:	b0 13 04 49 	calla	#18692		;0x04904

00006546 <.L28>:
}
    6546:	10 01       	reta			;

00006548 <elyMainMBPost>:
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    6548:	0e 4d       	mov	r13,	r14	;
    654a:	cd 0c       	mova	r12,	r13	;

0000654c <.LVL67>:
    654c:	8c 01 ea 06 	mova	#67306,	r12	;0x106ea

00006550 <.LVL68>:
    6550:	b0 13 ae 4a 	calla	#19118		;0x04aae

00006554 <.LVL69>:
}
    6554:	10 01       	reta			;

00006556 <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * fw_buffer) {
    6556:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006558 <.LCFI6>:
    6558:	ca 0d       	mova	r13,	r10	;

0000655a <.Loc.1590.2>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (fw_buffer[0] >> 7);
    655a:	6d 4d       	mov.b	@r13,	r13	;

0000655c <.LVL78>:
    655c:	09 4d       	mov	r13,	r9	;
    655e:	59 0f       	rrum	#4,	r9	;
    6560:	59 0b       	rrum	#3,	r9	;

00006562 <.LVL79>:
  hdr.reply = ((fw_buffer[0] >> 6) & 0x01);
    6562:	0e 4d       	mov	r13,	r14	;
    6564:	5e 0f       	rrum	#4,	r14	;
    6566:	5e 07       	rrum	#2,	r14	;
    6568:	5e f3       	and.b	#1,	r14	;r3 As==01

0000656a <.LVL80>:
  hdr.opcode = (fw_buffer[0] & 0x3F);
    656a:	08 4d       	mov	r13,	r8	;
    656c:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f

00006570 <.LVL81>:
  hdr.length = fw_buffer[1];
    6570:	5b 4a 01 00 	mov.b	1(r10),	r11	;

00006574 <.LVL82>:
  if (hdr.reply) {
    6574:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    6576:	07 24       	jz	$+16     	;abs 0x6586

00006578 <.Loc.1595.2>:
    hdr.reply_addr = (((uint16_t)(fw_buffer[2]) << 8) | (fw_buffer[3]));
    6578:	5f 4a 02 00 	mov.b	2(r10),	r15	;
    657c:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    6580:	5a 4a 03 00 	mov.b	3(r10),	r10	;

00006584 <.LVL83>:
    6584:	0f da       	bis	r10,	r15	;

00006586 <.L34>:
  }
  return hdr;
    6586:	4d 4e       	mov.b	r14,	r13	;

00006588 <.LVL85>:
    6588:	5d f3       	and.b	#1,	r13	;r3 As==01
    658a:	4d 5d       	rla.b	r13		;
    658c:	7d f0 03 00 	and.b	#3,	r13	;
    6590:	0e 48       	mov	r8,	r14	;

00006592 <.LVL86>:
    6592:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    6596:	4d d9       	bis.b	r9,	r13	;
    6598:	4d de       	bis.b	r14,	r13	;
    659a:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    659e:	cc 4b 01 00 	mov.b	r11,	1(r12)	;
    65a2:	8c 4f 02 00 	mov	r15,	2(r12)	;

000065a6 <.LVL87>:
}
    65a6:	28 16       	popm.a	#3,	r10	;20-bit words
    65a8:	10 01       	reta			;

000065aa <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    65aa:	2a 14       	pushm.a	#3,	r10	;20-bit words

000065ac <.LCFI7>:
    65ac:	2e 4c       	mov	@r12,	r14	;

000065ae <.LVL89>:
    65ae:	ca 0d       	mova	r13,	r10	;
    65b0:	0c 4e       	mov	r14,	r12	;
    65b2:	5c 07       	rrum	#2,	r12	;
    65b4:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    65b8:	49 4c       	mov.b	r12,	r9	;
    65ba:	08 4e       	mov	r14,	r8	;
    65bc:	58 0f       	rrum	#4,	r8	;
    65be:	58 0f       	rrum	#4,	r8	;

000065c0 <.Loc.1603.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    65c0:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f

000065c4 <.LVL91>:
    65c4:	0d 99       	cmp	r9,	r13	;
    65c6:	07 34       	jge	$+16     	;abs 0x65d6

000065c8 <.Loc.1604.2>:
    elyErrorSignal(ErrInvalidOpcode);
    65c8:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

000065cc <.L182>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    65cc:	b0 13 2a 91 	calla	#37162		;0x0912a

000065d0 <.L70>:
      return false;
    65d0:	4a 43       	clr.b	r10		;

000065d2 <.LVL94>:
    65d2:	80 00 48 66 	mova	#26184,	r0	;0x06648

000065d6 <.L39>:
  if (hdr.reply) {
    65d6:	0d 49       	mov	r9,	r13	;
    65d8:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    65dc:	09 4e       	mov	r14,	r9	;
    65de:	79 f0 03 00 	and.b	#3,	r9	;
    65e2:	09 dd       	bis	r13,	r9	;
    65e4:	4f 49       	mov.b	r9,	r15	;
    65e6:	6f f3       	and.b	#2,	r15	;r3 As==10
    65e8:	4f 93       	cmp.b	#0,	r15	;r3 As==00
    65ea:	0a 24       	jz	$+22     	;abs 0x6600

000065ec <.Loc.1610.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    65ec:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    65f0:	da 9e 51 00 	cmp.b	81(r14),2(r10)	;0x00051
    65f4:	02 00 
    65f6:	04 20       	jnz	$+10     	;abs 0x6600

000065f8 <.Loc.1610.2>:
    65f8:	da 9e 50 00 	cmp.b	80(r14),3(r10)	;0x00050
    65fc:	03 00 
    65fe:	e8 27       	jz	$-46     	;abs 0x65d0

00006600 <.L41>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6600:	59 f3       	and.b	#1,	r9	;r3 As==01
    6602:	09 93       	cmp	#0,	r9	;r3 As==00
    6604:	24 24       	jz	$+74     	;abs 0x664e
    6606:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006608 <.L42>:
    6608:	40 18 4e 48 	movx.b	r8,	r14	;
    660c:	40 18 4e 8f 	subx.b	r15,	r14	;
    6610:	4e 8d       	sub.b	r13,	r14	;
    6612:	4d 4e       	mov.b	r14,	r13	;

00006614 <.LVL96>:
  switch(hdr.opcode) {
    6614:	7c 90 16 00 	cmp.b	#22,	r12	;#0x0016
    6618:	4d 24       	jz	$+156    	;abs 0x66b4
    661a:	7f 40 16 00 	mov.b	#22,	r15	;#0x0016
    661e:	4f 9c       	cmp.b	r12,	r15	;
    6620:	6e 28       	jnc	$+222    	;abs 0x66fe
    6622:	7c 90 0a 00 	cmp.b	#10,	r12	;#0x000a
    6626:	46 24       	jz	$+142    	;abs 0x66b4
    6628:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    662c:	4f 9c       	cmp.b	r12,	r15	;
    662e:	2e 28       	jnc	$+94     	;abs 0x668c
    6630:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    6632:	cd 24       	jz	$+412    	;abs 0x67ce
    6634:	6f 42       	mov.b	#4,	r15	;r2 As==10
    6636:	4f 9c       	cmp.b	r12,	r15	;
    6638:	0d 28       	jnc	$+28     	;abs 0x6654
    663a:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    663c:	3b 20       	jnz	$+120    	;abs 0x66b4

0000663e <.L49>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    663e:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    6640:	3b 20       	jnz	$+120    	;abs 0x66b8

00006642 <.L66>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    6642:	09 93       	cmp	#0,	r9	;r3 As==00
    6644:	dc 20       	jnz	$+442    	;abs 0x67fe

00006646 <.L69>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    6646:	5a 43       	mov.b	#1,	r10	;r3 As==01

00006648 <.L40>:
  
}
    6648:	4c 4a       	mov.b	r10,	r12	;
    664a:	28 16       	popm.a	#3,	r10	;20-bit words
    664c:	10 01       	reta			;

0000664e <.L71>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    664e:	0d 49       	mov	r9,	r13	;
    6650:	80 00 08 66 	mova	#26120,	r0	;0x06608

00006654 <.L48>:
  switch(hdr.opcode) {
    6654:	7c 90 07 00 	cmp.b	#7,	r12	;
    6658:	ca 24       	jz	$+406    	;abs 0x67ee
    665a:	7f 40 07 00 	mov.b	#7,	r15	;
    665e:	4f 9c       	cmp.b	r12,	r15	;
    6660:	0c 28       	jnc	$+26     	;abs 0x667a
    6662:	7c 90 05 00 	cmp.b	#5,	r12	;
    6666:	b9 24       	jz	$+372    	;abs 0x67da
    6668:	7c 90 06 00 	cmp.b	#6,	r12	;
    666c:	ab 24       	jz	$+344    	;abs 0x67c4

0000666e <.L43>:
      chDbgAssert(false, "invalid opcode in length check");
    666e:	8c 01 f7 04 	mova	#66807,	r12	;0x104f7
    6672:	b0 13 5c 46 	calla	#18012		;0x0465c

00006676 <.LVL102>:
    6676:	80 00 42 66 	mova	#26178,	r0	;0x06642

0000667a <.L51>:
  switch(hdr.opcode) {
    667a:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    667c:	1b 24       	jz	$+56     	;abs 0x66b4
    667e:	7c 90 09 00 	cmp.b	#9,	r12	;
    6682:	f5 23       	jnz	$-20     	;abs 0x666e

00006684 <.L179>:
      if (payload_len != 2 && payload_len != 4 && 
    6684:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    6686:	18 20       	jnz	$+50     	;abs 0x66b8
    6688:	80 00 42 66 	mova	#26178,	r0	;0x06642

0000668c <.L46>:
  switch(hdr.opcode) {
    668c:	7c 90 10 00 	cmp.b	#16,	r12	;#0x0010
    6690:	11 24       	jz	$+36     	;abs 0x66b4
    6692:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    6696:	4f 9c       	cmp.b	r12,	r15	;
    6698:	1b 28       	jnc	$+56     	;abs 0x66d0
    669a:	7c 90 0d 00 	cmp.b	#13,	r12	;#0x000d
    669e:	f2 27       	jz	$-26     	;abs 0x6684
    66a0:	7f 40 0d 00 	mov.b	#13,	r15	;#0x000d
    66a4:	4f 9c       	cmp.b	r12,	r15	;
    66a6:	0c 28       	jnc	$+26     	;abs 0x66c0
    66a8:	7c 90 0b 00 	cmp.b	#11,	r12	;#0x000b
    66ac:	eb 27       	jz	$-40     	;abs 0x6684
    66ae:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    66b2:	dd 23       	jnz	$-68     	;abs 0x666e

000066b4 <.L44>:
      if (payload_len != 0) {
    66b4:	0d 93       	cmp	#0,	r13	;r3 As==00
    66b6:	c5 27       	jz	$-116    	;abs 0x6642

000066b8 <.L67>:
        elyErrorSignal(ErrInvalidLength);
    66b8:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    66bc:	80 00 cc 65 	mova	#26060,	r0	;0x065cc

000066c0 <.L56>:
  switch(hdr.opcode) {
    66c0:	7c 90 0e 00 	cmp.b	#14,	r12	;#0x000e
    66c4:	f7 27       	jz	$-16     	;abs 0x66b4
    66c6:	7c 90 0f 00 	cmp.b	#15,	r12	;#0x000f
    66ca:	dc 27       	jz	$-70     	;abs 0x6684
    66cc:	80 00 6e 66 	mova	#26222,	r0	;0x0666e

000066d0 <.L55>:
    66d0:	7c 90 13 00 	cmp.b	#19,	r12	;#0x0013
    66d4:	d7 27       	jz	$-80     	;abs 0x6684
    66d6:	7f 40 13 00 	mov.b	#19,	r15	;#0x0013
    66da:	4f 9c       	cmp.b	r12,	r15	;
    66dc:	08 28       	jnc	$+18     	;abs 0x66ee
    66de:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    66e2:	d0 27       	jz	$-94     	;abs 0x6684
    66e4:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    66e8:	e5 27       	jz	$-52     	;abs 0x66b4
    66ea:	80 00 6e 66 	mova	#26222,	r0	;0x0666e

000066ee <.L57>:
    66ee:	7c 90 14 00 	cmp.b	#20,	r12	;#0x0014
    66f2:	e0 27       	jz	$-62     	;abs 0x66b4
    66f4:	7c 90 15 00 	cmp.b	#21,	r12	;#0x0015
    66f8:	a2 27       	jz	$-186    	;abs 0x663e
    66fa:	80 00 6e 66 	mova	#26222,	r0	;0x0666e

000066fe <.L45>:
    66fe:	7c 90 24 00 	cmp.b	#36,	r12	;#0x0024
    6702:	c0 27       	jz	$-126    	;abs 0x6684
    6704:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    6708:	4f 9c       	cmp.b	r12,	r15	;
    670a:	31 28       	jnc	$+100    	;abs 0x676e
    670c:	7c 90 1c 00 	cmp.b	#28,	r12	;#0x001c
    6710:	5e 24       	jz	$+190    	;abs 0x67ce
    6712:	7f 40 1c 00 	mov.b	#28,	r15	;#0x001c
    6716:	4f 9c       	cmp.b	r12,	r15	;
    6718:	1b 28       	jnc	$+56     	;abs 0x6750
    671a:	7c 90 19 00 	cmp.b	#25,	r12	;#0x0019
    671e:	12 24       	jz	$+38     	;abs 0x6744
    6720:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    6724:	4d 9c       	cmp.b	r12,	r13	;
    6726:	08 28       	jnc	$+18     	;abs 0x6738
    6728:	7c 90 17 00 	cmp.b	#23,	r12	;#0x0017
    672c:	ab 27       	jz	$-168    	;abs 0x6684
    672e:	7c 90 18 00 	cmp.b	#24,	r12	;#0x0018
    6732:	85 27       	jz	$-244    	;abs 0x663e
    6734:	80 00 6e 66 	mova	#26222,	r0	;0x0666e

00006738 <.L61>:
    6738:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    673c:	48 24       	jz	$+146    	;abs 0x67ce
    673e:	7c 90 1b 00 	cmp.b	#27,	r12	;#0x001b
    6742:	95 23       	jnz	$-212    	;abs 0x666e

00006744 <.L60>:
      if (payload_len < 4 || payload_len > 251) {
    6744:	7e 50 fc ff 	add.b	#-4,	r14	;#0xfffc

00006748 <.LVL108>:
    6748:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    674c:	80 00 d2 67 	mova	#26578,	r0	;0x067d2

00006750 <.L59>:
  switch(hdr.opcode) {
    6750:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    6754:	4f 9c       	cmp.b	r12,	r15	;
    6756:	ae 2b       	jnc	$-162    	;abs 0x66b4
    6758:	7c 90 1f 00 	cmp.b	#31,	r12	;#0x001f
    675c:	38 2c       	jc	$+114    	;abs 0x67ce
    675e:	7c 90 1d 00 	cmp.b	#29,	r12	;#0x001d
    6762:	6d 27       	jz	$-292    	;abs 0x663e
    6764:	7c 90 1e 00 	cmp.b	#30,	r12	;#0x001e
    6768:	82 23       	jnz	$-250    	;abs 0x666e
    676a:	80 00 b4 66 	mova	#26292,	r0	;0x066b4

0000676e <.L58>:
    676e:	7c 90 2a 00 	cmp.b	#42,	r12	;#0x002a
    6772:	e8 27       	jz	$-46     	;abs 0x6744
    6774:	7f 40 2a 00 	mov.b	#42,	r15	;#0x002a
    6778:	4f 9c       	cmp.b	r12,	r15	;
    677a:	0e 28       	jnc	$+30     	;abs 0x6798
    677c:	7c 90 27 00 	cmp.b	#39,	r12	;#0x0027
    6780:	5e 27       	jz	$-322    	;abs 0x663e
    6782:	7c 90 27 00 	cmp.b	#39,	r12	;#0x0027
    6786:	96 2b       	jnc	$-210    	;abs 0x66b4
    6788:	7c 90 28 00 	cmp.b	#40,	r12	;#0x0028
    678c:	93 27       	jz	$-216    	;abs 0x66b4
    678e:	7c 90 29 00 	cmp.b	#41,	r12	;#0x0029
    6792:	55 27       	jz	$-340    	;abs 0x663e
    6794:	80 00 6e 66 	mova	#26222,	r0	;0x0666e

00006798 <.L62>:
    6798:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    679c:	4f 9c       	cmp.b	r12,	r15	;
    679e:	07 28       	jnc	$+16     	;abs 0x67ae
    67a0:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    67a4:	87 2f       	jc	$-240    	;abs 0x66b4

000067a6 <.Loc.1656.2>:
      if (payload_len != 2) {
    67a6:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    67a8:	4c 27       	jz	$-358    	;abs 0x6642
    67aa:	80 00 b8 66 	mova	#26296,	r0	;0x066b8

000067ae <.L63>:
  switch(hdr.opcode) {
    67ae:	7c 90 2e 00 	cmp.b	#46,	r12	;#0x002e
    67b2:	0d 24       	jz	$+28     	;abs 0x67ce
    67b4:	7c 90 2f 00 	cmp.b	#47,	r12	;#0x002f
    67b8:	5a 23       	jnz	$-330    	;abs 0x666e

000067ba <.Loc.1684.2>:
      if (payload_len != 2 && payload_len != 4 && 
    67ba:	7e c2       	bic.b	#8,	r14	;r2 As==11

000067bc <.LVL111>:
    67bc:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    67be:	62 23       	jnz	$-314    	;abs 0x6684
    67c0:	80 00 42 66 	mova	#26178,	r0	;0x06642

000067c4 <.L53>:
      if (payload_len != 3) {
    67c4:	7e 90 03 00 	cmp.b	#3,	r14	;
    67c8:	3c 27       	jz	$-390    	;abs 0x6642
    67ca:	80 00 b8 66 	mova	#26296,	r0	;0x066b8

000067ce <.L47>:
      if (payload_len > 251) {
    67ce:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb

000067d2 <.L181>:
      if (payload_len < 4 || payload_len > 251) {
    67d2:	4c 9e       	cmp.b	r14,	r12	;
    67d4:	36 2f       	jc	$-402    	;abs 0x6642
    67d6:	80 00 b8 66 	mova	#26296,	r0	;0x066b8

000067da <.L52>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    67da:	4c 4e       	mov.b	r14,	r12	;
    67dc:	7c 53       	add.b	#-1,	r12	;r3 As==11
    67de:	7d 40 fa ff 	mov.b	#-6,	r13	;#0xfffa
    67e2:	4d 9c       	cmp.b	r12,	r13	;
    67e4:	69 2b       	jnc	$-300    	;abs 0x66b8

000067e6 <.Loc.1706.2>:
    67e6:	1e b3       	bit	#1,	r14	;r3 As==01
    67e8:	2c 23       	jnz	$-422    	;abs 0x6642
    67ea:	80 00 b8 66 	mova	#26296,	r0	;0x066b8

000067ee <.L50>:
      if (payload_len < 2 || payload_len > 251) {
    67ee:	7e 50 fe ff 	add.b	#-2,	r14	;#0xfffe

000067f2 <.LVL117>:
    67f2:	7f 40 f9 ff 	mov.b	#-7,	r15	;#0xfff9
    67f6:	4f 9e       	cmp.b	r14,	r15	;
    67f8:	24 2f       	jc	$-438    	;abs 0x6642
    67fa:	80 00 b8 66 	mova	#26296,	r0	;0x066b8

000067fe <.L68>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    67fe:	0d 48       	mov	r8,	r13	;
    6800:	2d 53       	incd	r13		;
    6802:	4d 0e       	rlam.a	#4,	r13	;
    6804:	4d 0d       	rram.a	#4,	r13	;
    6806:	cc 0a       	mova	r10,	r12	;
    6808:	b0 13 48 96 	calla	#38472		;0x09648

0000680c <.LVL119>:
    680c:	4a 4c       	mov.b	r12,	r10	;

0000680e <.LVL120>:
    680e:	0a 93       	cmp	#0,	r10	;r3 As==00
    6810:	1a 23       	jnz	$-458    	;abs 0x6646

00006812 <.Loc.1736.2>:
      elyErrorSignal(ErrFCSError);
    6812:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    6816:	b0 13 2a 91 	calla	#37162		;0x0912a

0000681a <.LVL121>:
      return false;
    681a:	80 00 48 66 	mova	#26184,	r0	;0x06648

0000681e <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    681e:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006820 <.LCFI8>:
    6820:	b1 00 08 00 	suba	#8,	r1	;

00006824 <.LCFI9>:
    6824:	2f 4c       	mov	@r12,	r15	;

00006826 <.LVL123>:
    6826:	91 4c 02 00 	mov	2(r12),	6(r1)	;
    682a:	06 00 
    682c:	cc 0d       	mova	r13,	r12	;
    682e:	0d 4f       	mov	r15,	r13	;

00006830 <.LVL124>:
    6830:	5d 07       	rrum	#2,	r13	;
    6832:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

00006836 <.Loc.1747.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    6836:	0a 4d       	mov	r13,	r10	;
    6838:	0b 43       	clr	r11		;
    683a:	08 4a       	mov	r10,	r8	;
    683c:	09 4b       	mov	r11,	r9	;
    683e:	08 58       	rla	r8		;
    6840:	09 69       	rlc	r9		;
    6842:	08 58       	rla	r8		;
    6844:	09 69       	rlc	r9		;
    6846:	81 48 00 00 	mov	r8,	0(r1)	;
    684a:	81 49 02 00 	mov	r9,	2(r1)	;
    684e:	09 01       	mova	@r1,	r9	;
    6850:	80 18 5e 49 	movx.a	66822(r9),r14	;0x10506
    6854:	06 05 
    6856:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    685a:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

0000685e <.LVL126>:
    685e:	0f dd       	bis	r13,	r15	;
    6860:	81 4f 04 00 	mov	r15,	4(r1)	;
    6864:	cd 01       	mova	r1,	r13	;
    6866:	ad 00 04 00 	adda	#4,	r13	;
    686a:	4e 13       	calla	r14		;

0000686c <.LVL127>:
}
    686c:	a1 00 08 00 	adda	#8,	r1	;
    6870:	28 16       	popm.a	#3,	r10	;20-bit words
    6872:	10 01       	reta			;

00006874 <elyCmdSendReplyI>:
  chSysLock();
  elyCmdSendReplyI(buff, dest_addr);
  chSysUnlock();
}

void elyCmdSendReplyI(uint8_t * buff, uint16_t dest_addr) {
    6874:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006876 <.LCFI10>:
    6876:	09 4d       	mov	r13,	r9	;

00006878 <.Loc.1757.2>:
  uint8_t length = buff[1];
    6878:	58 4c 01 00 	mov.b	1(r12),	r8	;

0000687c <.LVL129>:
  uint8_t * buffer = elyNLFromFW(buff);
    687c:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006880 <.LVL130>:
    6880:	ca 0c       	mova	r12,	r10	;

00006882 <.Loc.1760.2>:
  
  elyNLSetHeader(buffer, length+4, dest_addr);
    6882:	0e 49       	mov	r9,	r14	;
    6884:	0d 48       	mov	r8,	r13	;
    6886:	2d 52       	add	#4,	r13	;r2 As==10
    6888:	b0 13 f6 9b 	calla	#39926		;0x09bf6

0000688c <.LVL132>:
  switch (elyNLGetDest(buffer, dest_addr)) {
    688c:	0d 49       	mov	r9,	r13	;
    688e:	cc 0a       	mova	r10,	r12	;
    6890:	b0 13 56 9b 	calla	#39766		;0x09b56

00006894 <.LVL133>:
    6894:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6896:	11 24       	jz	$+36     	;abs 0x68ba
    6898:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    689a:	14 20       	jnz	$+42     	;abs 0x68c4

0000689c <.Loc.1763.2>:
    case ELY_DEST_RF:
      if (MSG_OK != elyRFPostI(buffer)) {
    689c:	cc 0a       	mova	r10,	r12	;
    689e:	b0 13 68 91 	calla	#37224		;0x09168

000068a2 <.L197>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
      }
      break;
    case ELY_DEST_UART:
      if (MSG_OK != elyUARTPostI(buffer)) {
    68a2:	9c 00 00 00 	cmpa	#0,	r12	;
    68a6:	07 24       	jz	$+16     	;abs 0x68b6

000068a8 <.Loc.1773.2>:
        /* We should never hit this because everyone allocates the same amount */
        chDbgAssert(false, "internal buffer overflows should be impossible");
    68a8:	8c 01 e6 04 	mova	#66790,	r12	;0x104e6
    68ac:	b0 13 5c 46 	calla	#18012		;0x0465c

000068b0 <.LVL135>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
    68b0:	cc 0a       	mova	r10,	r12	;
    68b2:	b0 13 ca 62 	calla	#25290		;0x062ca

000068b6 <.L184>:
      break;
    default:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
}
    68b6:	28 16       	popm.a	#3,	r10	;20-bit words
    68b8:	10 01       	reta			;

000068ba <.L186>:
      if (MSG_OK != elyUARTPostI(buffer)) {
    68ba:	cc 0a       	mova	r10,	r12	;
    68bc:	b0 13 6a 60 	calla	#24682		;0x0606a

000068c0 <.LVL137>:
    68c0:	80 00 a2 68 	mova	#26786,	r0	;0x068a2

000068c4 <.L194>:
      chDbgAssert(false, "shouldn't happen");
    68c4:	8c 01 e6 04 	mova	#66790,	r12	;0x104e6
    68c8:	b0 13 5c 46 	calla	#18012		;0x0465c

000068cc <.LVL138>:
}
    68cc:	80 00 b6 68 	mova	#26806,	r0	;0x068b6

000068d0 <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buff) {
    68d0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000068d2 <.LCFI11>:
    68d2:	08 14       	pushm.a	#1,	r8	;20-bit words

000068d4 <.LCFI12>:
    68d4:	c8 0c       	mova	r12,	r8	;

000068d6 <.Loc.1452.2>:
  write_success(buff, telem_stored_hdr); /* crc */
    68d6:	8a 00 5c c8 	mova	#51292,	r10	;0x0c85c
    68da:	cd 0a       	mova	r10,	r13	;
    68dc:	b0 13 ee 64 	calla	#25838		;0x064ee

000068e0 <.LVL140>:
  elyCmdSendReplyI(buff, telem_stored_hdr.reply_addr);
    68e0:	1d 4a 02 00 	mov	2(r10),	r13	;
    68e4:	cc 08       	mova	r8,	r12	;
    68e6:	b0 13 74 68 	calla	#26740		;0x06874

000068ea <.LVL141>:
}
    68ea:	08 16       	popm.a	#1,	r8	;20-bit words
    68ec:	0a 16       	popm.a	#1,	r10	;20-bit words
    68ee:	10 01       	reta			;

000068f0 <verify_fw_cb>:
static void verify_fw_cb(uint8_t * buffer) {
    68f0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000068f2 <.LCFI13>:
    68f2:	06 14       	pushm.a	#1,	r6	;20-bit words

000068f4 <.LCFI14>:
  uint16_t result = crcStop();
    68f4:	b0 13 d4 96 	calla	#38612		;0x096d4

000068f8 <.LVL143>:
    68f8:	09 4c       	mov	r12,	r9	;

000068fa <.Loc.1284.2>:
  uint8_t * reply_buff = elyFWGetBufferI();
    68fa:	b0 13 82 62 	calla	#25218		;0x06282

000068fe <.LVL145>:
    68fe:	c6 0c       	mova	r12,	r6	;

00006900 <.Loc.1285.2>:
  if (reply_buff == NULL) {
    6900:	9c 00 00 00 	cmpa	#0,	r12	;
    6904:	10 24       	jz	$+34     	;abs 0x6926
    6906:	88 00 64 c8 	mova	#51300,	r8	;0x0c864
    690a:	8a 00 74 68 	mova	#26740,	r10	;0x06874

0000690e <.Loc.1291.2>:
    write_success(reply_buff, verify_stored_hdr);
    690e:	8d 00 60 c8 	mova	#51296,	r13	;0x0c860

00006912 <.Loc.1290.2>:
  if (result == verify_crc) {
    6912:	40 18 19 92 	cmpx.w	&0x0c85a,r9	;
    6916:	5a c8 
    6918:	09 20       	jnz	$+20     	;abs 0x692c

0000691a <.Loc.1291.2>:
    write_success(reply_buff, verify_stored_hdr);
    691a:	b0 13 ee 64 	calla	#25838		;0x064ee

0000691e <.L205>:
    elyCmdSendReplyI(reply_buff, stored_hdr.reply_addr);
    691e:	1d 48 02 00 	mov	2(r8),	r13	;
    6922:	cc 06       	mova	r6,	r12	;
    6924:	4a 13       	calla	r10		;

00006926 <.L199>:
}
    6926:	06 16       	popm.a	#1,	r6	;20-bit words
    6928:	28 16       	popm.a	#3,	r10	;20-bit words
    692a:	10 01       	reta			;

0000692c <.L201>:
    write_failure(reply_buff, verify_stored_hdr);
    692c:	b0 13 0c 63 	calla	#25356		;0x0630c

00006930 <.LVL149>:
    6930:	80 00 1e 69 	mova	#26910,	r0	;0x0691e

00006934 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buff) {
    6934:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006936 <.LCFI15>:
    6936:	08 14       	pushm.a	#1,	r8	;20-bit words

00006938 <.LCFI16>:
    6938:	c8 0c       	mova	r12,	r8	;

0000693a <.Loc.1213.2>:
    write_success(buff, stored_hdr);
    693a:	8a 00 64 c8 	mova	#51300,	r10	;0x0c864
    693e:	cd 0a       	mova	r10,	r13	;
    6940:	b0 13 ee 64 	calla	#25838		;0x064ee

00006944 <.LVL151>:
    elyCmdSendReplyI(buff, stored_hdr.reply_addr);
    6944:	1d 4a 02 00 	mov	2(r10),	r13	;
    6948:	cc 08       	mova	r8,	r12	;
    694a:	b0 13 74 68 	calla	#26740		;0x06874

0000694e <.LVL152>:
}
    694e:	08 16       	popm.a	#1,	r8	;20-bit words
    6950:	0a 16       	popm.a	#1,	r10	;20-bit words
    6952:	10 01       	reta			;

00006954 <elyCmdSendReply>:
void elyCmdSendReply(uint8_t * buff, uint16_t dest_addr) {
    6954:	b1 00 08 00 	suba	#8,	r1	;

00006958 <.LCFI17>:
  chSysLock();
    6958:	71 0c 04 00 	mova	r12,	4(r1)	;
    695c:	71 0d 00 00 	mova	r13,	0(r1)	;
    6960:	b0 13 e2 62 	calla	#25314		;0x062e2

00006964 <.LVL154>:
  elyCmdSendReplyI(buff, dest_addr);
    6964:	0d 01       	mova	@r1,	r13	;
    6966:	3c 01 04 00 	mova	4(r1),	r12	;
    696a:	b0 13 74 68 	calla	#26740		;0x06874

0000696e <.LVL155>:
  chSysUnlock();
    696e:	b0 13 ea 62 	calla	#25322		;0x062ea

00006972 <.LVL156>:
}
    6972:	a1 00 08 00 	adda	#8,	r1	;
    6976:	10 01       	reta			;

00006978 <gen_success>:
static void gen_success(elysium_cmd_hdr_t hdr) {
    6978:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000697a <.LCFI18>:
    697a:	b1 00 04 00 	suba	#4,	r1	;

0000697e <.LCFI19>:
    697e:	28 4c       	mov	@r12,	r8	;

00006980 <.LVL158>:
    6980:	19 4c 02 00 	mov	2(r12),	r9	;

00006984 <.LVL159>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6984:	b0 13 a2 62 	calla	#25250		;0x062a2

00006988 <.LVL160>:
    6988:	ca 0c       	mova	r12,	r10	;

0000698a <.Loc.50.2>:
  if (reply_buff == NULL) {
    698a:	9c 00 00 00 	cmpa	#0,	r12	;
    698e:	0b 24       	jz	$+24     	;abs 0x69a6

00006990 <.Loc.54.2>:
  write_success(reply_buff, hdr);
    6990:	81 48 00 00 	mov	r8,	0(r1)	;
    6994:	81 49 02 00 	mov	r9,	2(r1)	;
    6998:	cd 01       	mova	r1,	r13	;
    699a:	b0 13 ee 64 	calla	#25838		;0x064ee

0000699e <.LVL163>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    699e:	0d 49       	mov	r9,	r13	;
    69a0:	cc 0a       	mova	r10,	r12	;
    69a2:	b0 13 54 69 	calla	#26964		;0x06954

000069a6 <.L208>:
}
    69a6:	a1 00 04 00 	adda	#4,	r1	;
    69aa:	28 16       	popm.a	#3,	r10	;20-bit words
    69ac:	10 01       	reta			;

000069ae <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    69ae:	6a 14       	pushm.a	#7,	r10	;20-bit words

000069b0 <.LCFI20>:
    69b0:	b1 00 1c 00 	suba	#28,	r1	;0x0001c

000069b4 <.LCFI21>:
    69b4:	c8 0c       	mova	r12,	r8	;
    69b6:	2a 4d       	mov	@r13,	r10	;

000069b8 <.LVL167>:
    69b8:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    69bc:	0a 00 
    69be:	0c 4a       	mov	r10,	r12	;

000069c0 <.LVL168>:
    69c0:	5c 0f       	rrum	#4,	r12	;
    69c2:	5c 0f       	rrum	#4,	r12	;
    69c4:	81 4c 08 00 	mov	r12,	8(r1)	;

000069c8 <.Loc.1493.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    69c8:	4c 4a       	mov.b	r10,	r12	;
    69ca:	4e 4c       	mov.b	r12,	r14	;
    69cc:	6e f3       	and.b	#2,	r14	;r3 As==10
    69ce:	4d 4e       	mov.b	r14,	r13	;
    69d0:	81 4d 06 00 	mov	r13,	6(r1)	;
    69d4:	0d 93       	cmp	#0,	r13	;r3 As==00
    69d6:	49 20       	jnz	$+148    	;abs 0x6a6a
    69d8:	6f 43       	mov.b	#2,	r15	;r3 As==10

000069da <.L214>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    69da:	1c b3       	bit	#1,	r12	;r3 As==01
    69dc:	49 20       	jnz	$+148    	;abs 0x6a70

000069de <.Loc.1494.2>:
    69de:	4c 43       	clr.b	r12		;

000069e0 <.L215>:
    69e0:	1d 41 08 00 	mov	8(r1),	r13	;
    69e4:	4d 8e       	sub.b	r14,	r13	;
    69e6:	4d 8c       	sub.b	r12,	r13	;

000069e8 <.LVL171>:
  if (payload_len == 4 || payload_len == 12) {
    69e8:	4c 4d       	mov.b	r13,	r12	;
    69ea:	7c c2       	bic.b	#8,	r12	;r2 As==11
    69ec:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    69ee:	74 20       	jnz	$+234    	;abs 0x6ad8

000069f0 <.LVL172>:
    config.index_start = buffer[hdr_ext+2];
    69f0:	40 18 0c 4f 	movx.w	r15,	r12	;
    69f4:	ce 08       	mova	r8,	r14	;
    69f6:	ee 0c       	adda	r12,	r14	;
    69f8:	d1 4e 02 00 	mov.b	2(r14),	24(r1)	; 0x0018
    69fc:	18 00 

000069fe <.Loc.1502.2>:
    config.index_end = buffer[hdr_ext+3];
    69fe:	d1 4e 03 00 	mov.b	3(r14),	25(r1)	; 0x0019
    6a02:	19 00 

00006a04 <.Loc.1508.2>:
  if (payload_len > 4) {
    6a04:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    6a06:	37 20       	jnz	$+112    	;abs 0x6a76

00006a08 <.L230>:
    config.use_index = true;
    6a08:	54 43       	mov.b	#1,	r4	;r3 As==01

00006a0a <.L218>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6a0a:	cc 08       	mova	r8,	r12	;
    6a0c:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006a10 <.LVL175>:
    6a10:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006a14 <.LVL176>:
  chSysLock();
    6a14:	b0 13 e2 62 	calla	#25314		;0x062e2

00006a18 <.LVL177>:
  elyTelemUpdateConfigS(config);
    6a18:	81 49 10 00 	mov	r9,	16(r1)	; 0x0010
    6a1c:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    6a20:	81 46 14 00 	mov	r6,	20(r1)	; 0x0014
    6a24:	81 45 16 00 	mov	r5,	22(r1)	; 0x0016
    6a28:	c1 44 1a 00 	mov.b	r4,	26(r1)	; 0x001a
    6a2c:	cc 01       	mova	r1,	r12	;
    6a2e:	ac 00 10 00 	adda	#16,	r12	;0x00010
    6a32:	b0 13 4a 91 	calla	#37194		;0x0914a

00006a36 <.LVL178>:
  chSysUnlock();
    6a36:	b0 13 ea 62 	calla	#25322		;0x062ea

00006a3a <.LVL179>:
  if (hdr.reply) {
    6a3a:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6a3e:	11 24       	jz	$+36     	;abs 0x6a62

00006a40 <.Loc.1532.2>:
    gen_success(hdr);
    6a40:	19 41 08 00 	mov	8(r1),	r9	;

00006a44 <.LVL180>:
    6a44:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    6a48:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00006a4c <.LVL181>:
    6a4c:	0a d9       	bis	r9,	r10	;
    6a4e:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    6a52:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    6a56:	0e 00 
    6a58:	cc 01       	mova	r1,	r12	;
    6a5a:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    6a5e:	b0 13 78 69 	calla	#27000		;0x06978

00006a62 <.L213>:
}
    6a62:	a1 00 1c 00 	adda	#28,	r1	;0x0001c
    6a66:	64 16       	popm.a	#7,	r10	;20-bit words
    6a68:	10 01       	reta			;

00006a6a <.L223>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6a6a:	6f 42       	mov.b	#4,	r15	;r2 As==10
    6a6c:	80 00 da 69 	mova	#27098,	r0	;0x069da

00006a70 <.L224>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6a70:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6a72:	80 00 e0 69 	mova	#27104,	r0	;0x069e0

00006a76 <.L217>:
    config.use_timestamp = true;
    6a76:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00006a7a <.LBB35>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    6a7a:	0e 4f       	mov	r15,	r14	;
    6a7c:	3e 50 0b 00 	add	#11,	r14	;#0x000b
    6a80:	4e 0e       	rlam.a	#4,	r14	;
    6a82:	4e 0d       	rram.a	#4,	r14	;
    6a84:	ee 08       	adda	r8,	r14	;
    6a86:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    6a8a:	81 4e 04 00 	mov	r14,	4(r1)	;
    6a8e:	ac 00 07 00 	adda	#7,	r12	;
    6a92:	ce 08       	mova	r8,	r14	;
    6a94:	ee 0c       	adda	r12,	r14	;
    6a96:	44 43       	clr.b	r4		;

00006a98 <.L219>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    6a98:	6c 4e       	mov.b	@r14,	r12	;
    6a9a:	0d 44       	mov	r4,	r13	;
    6a9c:	71 0e 00 00 	mova	r14,	0(r1)	;
    6aa0:	b0 13 e4 9e 	calla	#40676		;0x09ee4
    6aa4:	0d 4c       	mov	r12,	r13	;
    6aa6:	0b 4c       	mov	r12,	r11	;
    6aa8:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6aac:	09 dd       	bis	r13,	r9	;

00006aae <.LVL187>:
    6aae:	07 dc       	bis	r12,	r7	;

00006ab0 <.Loc.1513.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    6ab0:	1c 41 04 00 	mov	4(r1),	r12	;
    6ab4:	0d 44       	mov	r4,	r13	;
    6ab6:	b0 13 e4 9e 	calla	#40676		;0x09ee4
    6aba:	0d 4c       	mov	r12,	r13	;
    6abc:	0b 4c       	mov	r12,	r11	;
    6abe:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6ac2:	06 dd       	bis	r13,	r6	;

00006ac4 <.LVL189>:
    6ac4:	05 dc       	bis	r12,	r5	;
    6ac6:	0e 01       	mova	@r1,	r14	;
    6ac8:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    6acc:	34 52       	add	#8,	r4	;r2 As==11

00006ace <.Loc.1511.2>:
      for (int i = 0; i < 4; i++) {
    6ace:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    6ad2:	e2 23       	jnz	$-58     	;abs 0x6a98
    6ad4:	80 00 08 6a 	mova	#27144,	r0	;0x06a08

00006ad8 <.L216>:
  if (payload_len > 4) {
    6ad8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6ada:	4c 9d       	cmp.b	r13,	r12	;
    6adc:	30 2c       	jc	$+98     	;abs 0x6b3e

00006ade <.Loc.1509.2>:
    config.use_timestamp = true;
    6ade:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00006ae2 <.LBB36>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6ae2:	0c 4f       	mov	r15,	r12	;
    6ae4:	3c 50 09 00 	add	#9,	r12	;
    6ae8:	4c 0e       	rlam.a	#4,	r12	;
    6aea:	4c 0d       	rram.a	#4,	r12	;
    6aec:	ec 08       	adda	r8,	r12	;
    6aee:	5c 4c ff ff 	mov.b	-1(r12),r12	;
    6af2:	81 4c 04 00 	mov	r12,	4(r1)	;
    6af6:	40 18 0e 4f 	movx.w	r15,	r14	;
    6afa:	ae 00 05 00 	adda	#5,	r14	;
    6afe:	ee 08       	adda	r8,	r14	;
    6b00:	44 43       	clr.b	r4		;

00006b02 <.L220>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    6b02:	6c 4e       	mov.b	@r14,	r12	;
    6b04:	0d 44       	mov	r4,	r13	;
    6b06:	71 0e 00 00 	mova	r14,	0(r1)	;
    6b0a:	b0 13 e4 9e 	calla	#40676		;0x09ee4
    6b0e:	0d 4c       	mov	r12,	r13	;
    6b10:	0b 4c       	mov	r12,	r11	;
    6b12:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6b16:	09 dd       	bis	r13,	r9	;

00006b18 <.LVL194>:
    6b18:	07 dc       	bis	r12,	r7	;

00006b1a <.Loc.1519.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6b1a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b1e:	0d 44       	mov	r4,	r13	;
    6b20:	b0 13 e4 9e 	calla	#40676		;0x09ee4
    6b24:	0d 4c       	mov	r12,	r13	;
    6b26:	0b 4c       	mov	r12,	r11	;
    6b28:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6b2c:	06 dd       	bis	r13,	r6	;

00006b2e <.LVL196>:
    6b2e:	05 dc       	bis	r12,	r5	;
    6b30:	0e 01       	mova	@r1,	r14	;
    6b32:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    6b36:	34 52       	add	#8,	r4	;r2 As==11

00006b38 <.Loc.1517.2>:
      for (int i = 0; i < 4; i++) {
    6b38:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    6b3c:	e2 23       	jnz	$-58     	;abs 0x6b02

00006b3e <.L231>:
    config.use_index = false;
    6b3e:	44 43       	clr.b	r4		;
    6b40:	80 00 0a 6a 	mova	#27146,	r0	;0x06a0a

00006b44 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6b44:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006b46 <.LCFI22>:
    6b46:	04 14       	pushm.a	#1,	r4	;20-bit words

00006b48 <.LCFI23>:
    6b48:	b1 00 04 00 	suba	#4,	r1	;

00006b4c <.LCFI24>:
    6b4c:	c6 0c       	mova	r12,	r6	;
    6b4e:	27 4d       	mov	@r13,	r7	;

00006b50 <.LVL199>:
    6b50:	1a 4d 02 00 	mov	2(r13),	r10	;

00006b54 <.LVL200>:
    6b54:	09 47       	mov	r7,	r9	;

00006b56 <.Loc.1434.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6b56:	84 00 fa 9d 	mova	#40442,	r4	;0x09dfa
    6b5a:	44 13       	calla	r4		;

00006b5c <.LVL202>:
    6b5c:	88 00 3e 9b 	mova	#39742,	r8	;0x09b3e
    6b60:	48 13       	calla	r8		;

00006b62 <.LVL203>:
  if (hdr.reply) {
    6b62:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    6b66:	13 24       	jz	$+40     	;abs 0x6b8e

00006b68 <.Loc.1438.2>:
    gen_success(hdr);
    6b68:	81 47 00 00 	mov	r7,	0(r1)	;
    6b6c:	81 4a 02 00 	mov	r10,	2(r1)	;
    6b70:	cc 01       	mova	r1,	r12	;
    6b72:	b0 13 78 69 	calla	#27000		;0x06978

00006b76 <.L234>:
  bootloader = 1;
    6b76:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    6b7a:	fc 19 

00006b7c <.Loc.1446.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6b7c:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    6b80:	48 a5 20 01 

00006b84 <.Loc.1448.2>:
}
    6b84:	a1 00 04 00 	adda	#4,	r1	;
    6b88:	04 16       	popm.a	#1,	r4	;20-bit words
    6b8a:	46 16       	popm.a	#5,	r10	;20-bit words
    6b8c:	10 01       	reta			;

00006b8e <.L233>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6b8e:	cc 06       	mova	r6,	r12	;
    6b90:	44 13       	calla	r4		;

00006b92 <.LVL207>:
    6b92:	48 13       	calla	r8		;

00006b94 <.LVL208>:
    6b94:	80 00 76 6b 	mova	#27510,	r0	;0x06b76

00006b98 <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6b98:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006b9a <.LCFI25>:
    6b9a:	b1 00 08 00 	suba	#8,	r1	;

00006b9e <.LCFI26>:
    6b9e:	2a 4d       	mov	@r13,	r10	;

00006ba0 <.LVL210>:
    6ba0:	17 4d 02 00 	mov	2(r13),	r7	;

00006ba4 <.LVL211>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6ba4:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006ba8 <.LVL212>:
    6ba8:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006bac <.LVL213>:
    6bac:	38 40 00 04 	mov	#1024,	r8	;#0x0400
    6bb0:	59 43       	mov.b	#1,	r9	;r3 As==01

00006bb2 <.LBB40>:
    chSysLock();
    6bb2:	84 00 e2 62 	mova	#25314,	r4	;0x062e2

00006bb6 <.Loc.1400.2>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6bb6:	85 00 6c 99 	mova	#39276,	r5	;0x0996c

00006bba <.L240>:
    chSysLock();
    6bba:	44 13       	calla	r4		;

00006bbc <.LVL215>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6bbc:	4d 43       	clr.b	r13		;
    6bbe:	cc 01       	mova	r1,	r12	;
    6bc0:	ac 00 04 00 	adda	#4,	r12	;
    6bc4:	45 13       	calla	r5		;

00006bc6 <.LVL216>:
    chSysUnlock();
    6bc6:	86 00 ea 62 	mova	#25322,	r6	;0x062ea
    6bca:	46 13       	calla	r6		;

00006bcc <.LVL217>:
    req->address = FRAM_FW_BASE + (i * 128); 
    6bcc:	3c 01 04 00 	mova	4(r1),	r12	;
    6bd0:	8c 48 00 00 	mov	r8,	0(r12)	;
    6bd4:	8c 49 02 00 	mov	r9,	2(r12)	;

00006bd8 <.Loc.1405.2>:
    req->read = 0;
    6bd8:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    6bdc:	6d c3       	bic.b	#2,	r13	;r3 As==10

00006bde <.Loc.1406.2>:
    req->special = 1; /* write a constant value */
    6bde:	5d d3       	bis.b	#1,	r13	;r3 As==01
    6be0:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00006be4 <.Loc.1407.2>:
    req->size = 128;
    6be4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6be8:	7d f0 03 00 	and.b	#3,	r13	;
    6bec:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    6bf0:	8c 4d 04 00 	mov	r13,	4(r12)	;
    6bf4:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    6bf8:	06 00 

00006bfa <.Loc.1408.2>:
    req->buffer = &fill_value; 
    6bfa:	00 18 fc 40 	movx.a	#51286,	8(r12)	;0x0c856
    6bfe:	56 c8 08 00 

00006c02 <.Loc.1409.2>:
    req->callback = cancel_fw_eeprom_cb;
    6c02:	00 18 fc 40 	movx.a	#25906,	12(r12)	;0x06532, 0x0000c
    6c06:	32 65 0c 00 

00006c0a <.Loc.1413.2>:
    chSysLock();
    6c0a:	44 13       	calla	r4		;

00006c0c <.LVL218>:
    elyFramPostRequestS(req);
    6c0c:	3c 01 04 00 	mova	4(r1),	r12	;
    6c10:	b0 13 48 99 	calla	#39240		;0x09948

00006c14 <.LVL219>:
    chSysUnlock();
    6c14:	46 13       	calla	r6		;

00006c16 <.LBB41>:
  return chSemWaitTimeout(&bsp->sem, time);
    6c16:	4d 43       	clr.b	r13		;
    6c18:	8c 00 58 c8 	mova	#51288,	r12	;0x0c858
    6c1c:	b0 13 88 48 	calla	#18568		;0x04888

00006c20 <.LVL221>:
    6c20:	38 50 80 00 	add	#128,	r8	;#0x0080
    6c24:	09 63       	adc	r9		;

00006c26 <.LBE41>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    6c26:	08 93       	cmp	#0,	r8	;r3 As==00
    6c28:	c8 23       	jnz	$-110    	;abs 0x6bba
    6c2a:	29 93       	cmp	#2,	r9	;r3 As==10
    6c2c:	c6 23       	jnz	$-114    	;abs 0x6bba

00006c2e <.LBE40>:
  if (hdr.reply) {
    6c2e:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    6c32:	07 24       	jz	$+16     	;abs 0x6c42

00006c34 <.Loc.1423.2>:
    gen_success(hdr);
    6c34:	81 4a 00 00 	mov	r10,	0(r1)	;
    6c38:	81 47 02 00 	mov	r7,	2(r1)	;
    6c3c:	cc 01       	mova	r1,	r12	;
    6c3e:	b0 13 78 69 	calla	#27000		;0x06978

00006c42 <.L235>:
}
    6c42:	a1 00 08 00 	adda	#8,	r1	;
    6c46:	64 16       	popm.a	#7,	r10	;20-bit words
    6c48:	10 01       	reta			;

00006c4a <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6c4a:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006c4c <.LCFI27>:
    6c4c:	b1 00 04 00 	suba	#4,	r1	;

00006c50 <.LCFI28>:
    6c50:	c8 0c       	mova	r12,	r8	;
    6c52:	29 4d       	mov	@r13,	r9	;

00006c54 <.LVL226>:
    6c54:	1a 4d 02 00 	mov	2(r13),	r10	;

00006c58 <.LVL227>:
    6c58:	07 49       	mov	r9,	r7	;

00006c5a <.Loc.1024.2>:
  elyEventReset();
    6c5a:	b0 13 3a 91 	calla	#37178		;0x0913a

00006c5e <.LVL229>:
  if (hdr.reply) {
    6c5e:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    6c62:	07 24       	jz	$+16     	;abs 0x6c72

00006c64 <.Loc.1028.2>:
    gen_success(hdr);
    6c64:	81 49 00 00 	mov	r9,	0(r1)	;
    6c68:	81 4a 02 00 	mov	r10,	2(r1)	;
    6c6c:	cc 01       	mova	r1,	r12	;
    6c6e:	b0 13 78 69 	calla	#27000		;0x06978

00006c72 <.L243>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6c72:	cc 08       	mova	r8,	r12	;
    6c74:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006c78 <.LVL232>:
    6c78:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006c7c <.LVL233>:
}
    6c7c:	a1 00 04 00 	adda	#4,	r1	;
    6c80:	37 16       	popm.a	#4,	r10	;20-bit words
    6c82:	10 01       	reta			;

00006c84 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6c84:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006c86 <.LCFI29>:
    6c86:	b1 00 04 00 	suba	#4,	r1	;

00006c8a <.LCFI30>:
    6c8a:	c8 0c       	mova	r12,	r8	;
    6c8c:	29 4d       	mov	@r13,	r9	;

00006c8e <.LVL235>:
    6c8e:	1a 4d 02 00 	mov	2(r13),	r10	;

00006c92 <.LVL236>:
    6c92:	07 49       	mov	r9,	r7	;

00006c94 <.Loc.871.2>:
  elyChanReset();
    6c94:	b0 13 48 91 	calla	#37192		;0x09148

00006c98 <.LVL238>:
  if (hdr.reply) {
    6c98:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    6c9c:	07 24       	jz	$+16     	;abs 0x6cac

00006c9e <.Loc.875.2>:
    gen_success(hdr);
    6c9e:	81 49 00 00 	mov	r9,	0(r1)	;
    6ca2:	81 4a 02 00 	mov	r10,	2(r1)	;
    6ca6:	cc 01       	mova	r1,	r12	;
    6ca8:	b0 13 78 69 	calla	#27000		;0x06978

00006cac <.L248>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6cac:	cc 08       	mova	r8,	r12	;
    6cae:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006cb2 <.LVL241>:
    6cb2:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006cb6 <.LVL242>:
}
    6cb6:	a1 00 04 00 	adda	#4,	r1	;
    6cba:	37 16       	popm.a	#4,	r10	;20-bit words
    6cbc:	10 01       	reta			;

00006cbe <gen_failure>:
static void gen_failure(elysium_cmd_hdr_t hdr) {
    6cbe:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006cc0 <.LCFI31>:
    6cc0:	b1 00 04 00 	suba	#4,	r1	;

00006cc4 <.LCFI32>:
    6cc4:	28 4c       	mov	@r12,	r8	;

00006cc6 <.LVL244>:
    6cc6:	19 4c 02 00 	mov	2(r12),	r9	;

00006cca <.LVL245>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6cca:	b0 13 a2 62 	calla	#25250		;0x062a2

00006cce <.LVL246>:
    6cce:	ca 0c       	mova	r12,	r10	;

00006cd0 <.Loc.72.2>:
  if (reply_buff == NULL) {
    6cd0:	9c 00 00 00 	cmpa	#0,	r12	;
    6cd4:	0b 24       	jz	$+24     	;abs 0x6cec

00006cd6 <.Loc.77.2>:
  write_failure(reply_buff, hdr);
    6cd6:	81 48 00 00 	mov	r8,	0(r1)	;
    6cda:	81 49 02 00 	mov	r9,	2(r1)	;
    6cde:	cd 01       	mova	r1,	r13	;
    6ce0:	b0 13 0c 63 	calla	#25356		;0x0630c

00006ce4 <.LVL249>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    6ce4:	0d 49       	mov	r9,	r13	;
    6ce6:	cc 0a       	mova	r10,	r12	;
    6ce8:	b0 13 54 69 	calla	#26964		;0x06954

00006cec <.L252>:
}
    6cec:	a1 00 04 00 	adda	#4,	r1	;
    6cf0:	28 16       	popm.a	#3,	r10	;20-bit words
    6cf2:	10 01       	reta			;

00006cf4 <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6cf4:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006cf6 <.LCFI33>:
    6cf6:	b1 00 14 00 	suba	#20,	r1	;0x00014

00006cfa <.LCFI34>:
    6cfa:	c6 0c       	mova	r12,	r6	;
    6cfc:	2a 4d       	mov	@r13,	r10	;

00006cfe <.LVL253>:
    6cfe:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    6d02:	0a 00 
    6d04:	09 4a       	mov	r10,	r9	;
    6d06:	59 0f       	rrum	#4,	r9	;
    6d08:	59 0f       	rrum	#4,	r9	;
    6d0a:	81 49 04 00 	mov	r9,	4(r1)	;

00006d0e <.Loc.1225.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6d0e:	49 4a       	mov.b	r10,	r9	;
    6d10:	81 49 00 00 	mov	r9,	0(r1)	;
    6d14:	0c 49       	mov	r9,	r12	;

00006d16 <.LVL255>:
    6d16:	6c f3       	and.b	#2,	r12	;r3 As==10
    6d18:	47 4c       	mov.b	r12,	r7	;
    6d1a:	07 93       	cmp	#0,	r7	;r3 As==00
    6d1c:	42 20       	jnz	$+134    	;abs 0x6da2
    6d1e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006d20 <.L258>:
    6d20:	00 18 c1 4d 	movx.a	r13,	6(r1)	;
    6d24:	06 00 
    6d26:	38 01 06 00 	mova	6(r1),	r8	;
    6d2a:	e8 06       	adda	r6,	r8	;

00006d2c <.Loc.1225.2>:
    6d2c:	79 40 18 00 	mov.b	#24,	r9	;#0x0018

00006d30 <.Loc.1226.2>:
  uint32_t address = 0;
    6d30:	44 43       	clr.b	r4		;
    6d32:	05 44       	mov	r4,	r5	;

00006d34 <.L259>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    6d34:	6c 48       	mov.b	@r8,	r12	;
    6d36:	0d 43       	clr	r13		;
    6d38:	0e 49       	mov	r9,	r14	;
    6d3a:	0f 43       	clr	r15		;
    6d3c:	b0 13 2e 9f 	calla	#40750		;0x09f2e
    6d40:	0c d4       	bis	r4,	r12	;
    6d42:	0d d5       	bis	r5,	r13	;
    6d44:	04 4c       	mov	r12,	r4	;

00006d46 <.LVL259>:
    6d46:	05 4d       	mov	r13,	r5	;

00006d48 <.LVL260>:
    6d48:	a8 00 01 00 	adda	#1,	r8	;
    6d4c:	39 50 f8 ff 	add	#-8,	r9	;#0xfff8

00006d50 <.Loc.1229.2>:
  for (int i = 0; i < 4; i++) {
    6d50:	39 90 f8 ff 	cmp	#-8,	r9	;#0xfff8
    6d54:	ef 23       	jnz	$-32     	;abs 0x6d34

00006d56 <.LBE43>:
  if (address < 0x4400 || address > 0x13FFF) {
    6d56:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    6d5a:	09 4d       	mov	r13,	r9	;
    6d5c:	39 63       	addc	#-1,	r9	;r3 As==11
    6d5e:	09 93       	cmp	#0,	r9	;r3 As==00
    6d60:	04 20       	jnz	$+10     	;abs 0x6d6a
    6d62:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    6d66:	0d 9c       	cmp	r12,	r13	;
    6d68:	25 2c       	jc	$+76     	;abs 0x6db4

00006d6a <.L272>:
    if (hdr.reply) {
    6d6a:	07 93       	cmp	#0,	r7	;r3 As==00
    6d6c:	1d 24       	jz	$+60     	;abs 0x6da8

00006d6e <.Loc.1236.2>:
      gen_failure(hdr);
    6d6e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d72:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6d76:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00006d7a <.LVL261>:
    6d7a:	0a dc       	bis	r12,	r10	;
    6d7c:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    6d80:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    6d84:	0e 00 
    6d86:	cc 01       	mova	r1,	r12	;
    6d88:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    6d8c:	b0 13 be 6c 	calla	#27838		;0x06cbe

00006d90 <.L275>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6d90:	cc 06       	mova	r6,	r12	;
    6d92:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006d96 <.LVL263>:
    6d96:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006d9a <.L257>:
}
    6d9a:	a1 00 14 00 	adda	#20,	r1	;0x00014
    6d9e:	64 16       	popm.a	#7,	r10	;20-bit words
    6da0:	10 01       	reta			;

00006da2 <.L269>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6da2:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6da4:	80 00 20 6d 	mova	#27936,	r0	;0x06d20

00006da8 <.L262>:
      elyErrorSignal(ErrCmdFailure);
    6da8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6dac:	b0 13 2a 91 	calla	#37162		;0x0912a

00006db0 <.LVL267>:
    6db0:	80 00 90 6d 	mova	#28048,	r0	;0x06d90

00006db4 <.L274>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6db4:	b0 13 a2 62 	calla	#25250		;0x062a2

00006db8 <.LVL268>:
    6db8:	c8 0c       	mova	r12,	r8	;

00006dba <.Loc.1246.2>:
  if (reply_buff == NULL) {
    6dba:	9c 00 00 00 	cmpa	#0,	r12	;
    6dbe:	e8 27       	jz	$-46     	;abs 0x6d90

00006dc0 <.Loc.1255.2>:
  chSysLock();
    6dc0:	b0 13 e2 62 	calla	#25314		;0x062e2

00006dc4 <.LVL270>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6dc4:	0d 49       	mov	r9,	r13	;
    6dc6:	cc 01       	mova	r1,	r12	;
    6dc8:	ac 00 10 00 	adda	#16,	r12	;0x00010
    6dcc:	b0 13 6c 99 	calla	#39276		;0x0996c

00006dd0 <.LVL271>:
  chSysUnlock();
    6dd0:	b0 13 ea 62 	calla	#25322		;0x062ea

00006dd4 <.LVL272>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    6dd4:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    6dd8:	1d 41 04 00 	mov	4(r1),	r13	;
    6ddc:	0d 87       	sub	r7,	r13	;
    6dde:	40 18 91 b3 	bitx.w	#1,	0(r1)	;r3 As==01
    6de2:	00 00 
    6de4:	01 24       	jz	$+4      	;abs 0x6de8
    6de6:	69 43       	mov.b	#2,	r9	;r3 As==10

00006de8 <.L266>:
    6de8:	0d 89       	sub	r9,	r13	;
    6dea:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc
    6dee:	0e 4d       	mov	r13,	r14	;
    6df0:	4e 0e       	rlam.a	#4,	r14	;
    6df2:	4e 0d       	rram.a	#4,	r14	;
    6df4:	80 18 7e f0 	andx.a	#131071,r14	;0x1ffff
    6df8:	ff ff 
    6dfa:	71 0e 00 00 	mova	r14,	0(r1)	;
    6dfe:	0d 4e       	mov	r14,	r13	;
    6e00:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    6e04:	1e 4c 04 00 	mov	4(r12),	r14	;
    6e08:	7e f0 03 00 	and.b	#3,	r14	;
    6e0c:	0e dd       	bis	r13,	r14	;
    6e0e:	8c 4e 04 00 	mov	r14,	4(r12)	;
    6e12:	2e 41       	mov	@r1,	r14	;
    6e14:	0f 4e       	mov	r14,	r15	;
    6e16:	5f 03       	rrum	#1,	r15	;
    6e18:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    6e1c:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    6e20:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    6e24:	09 01       	mova	@r1,	r9	;
    6e26:	09 14       	pushm.a	#1,	r9	;20-bit words
    6e28:	0d 17       	popm	#1,	r13	;16-bit words
    6e2a:	0d 17       	popm	#1,	r13	;16-bit words
    6e2c:	5d f3       	and.b	#1,	r13	;r3 As==01
    6e2e:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    6e32:	4e df       	bis.b	r15,	r14	;
    6e34:	4e dd       	bis.b	r13,	r14	;
    6e36:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00006e3a <.Loc.1260.2>:
  memcpy(reply_buff, buffer + hdr_ext + 4, req->size);
    6e3a:	3d 01 06 00 	mova	6(r1),	r13	;
    6e3e:	ad 00 04 00 	adda	#4,	r13	;
    6e42:	ce 09       	mova	r9,	r14	;
    6e44:	ed 06       	adda	r6,	r13	;
    6e46:	cc 08       	mova	r8,	r12	;
    6e48:	b0 13 0a a0 	calla	#40970		;0x0a00a

00006e4c <.LVL274>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6e4c:	cc 06       	mova	r6,	r12	;
    6e4e:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006e52 <.LVL275>:
    6e52:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006e56 <.LVL276>:
  stored_hdr = hdr;
    6e56:	1c 41 04 00 	mov	4(r1),	r12	;
    6e5a:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6e5e:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00006e62 <.LVL277>:
    6e62:	0a dc       	bis	r12,	r10	;
    6e64:	40 18 82 4a 	movx.w	r10,	&0xfc864;
    6e68:	64 c8 
    6e6a:	40 18 92 41 	movx.w	10(r1),	&0xfc866;0x0000a
    6e6e:	0a 00 66 c8 

00006e72 <.Loc.1267.2>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    6e72:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    6e76:	34 50 00 c0 	add	#-16384,r4	;#0xc000

00006e7a <.LVL278>:
    6e7a:	8c 44 00 00 	mov	r4,	0(r12)	;
    6e7e:	05 63       	adc	r5		;
    6e80:	8c 45 02 00 	mov	r5,	2(r12)	;

00006e84 <.Loc.1268.2>:
  req->read = 0;
    6e84:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

00006e88 <.Loc.1269.2>:
  req->buffer = reply_buff;
    6e88:	7c 08 08 00 	mova	r8,	8(r12)	;

00006e8c <.Loc.1270.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6e8c:	07 93       	cmp	#0,	r7	;r3 As==00
    6e8e:	0e 20       	jnz	$+30     	;abs 0x6eac

00006e90 <.Loc.1270.2>:
    6e90:	8e 00 34 64 	mova	#25652,	r14	;0x06434

00006e94 <.L267>:
    6e94:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

00006e98 <.Loc.1273.2>:
  chSysLock();
    6e98:	b0 13 e2 62 	calla	#25314		;0x062e2

00006e9c <.LVL280>:
  elyFramPostRequestS(req);
    6e9c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    6ea0:	b0 13 48 99 	calla	#39240		;0x09948

00006ea4 <.LVL281>:
  chSysUnlock();
    6ea4:	b0 13 ea 62 	calla	#25322		;0x062ea

00006ea8 <.LVL282>:
    6ea8:	80 00 9a 6d 	mova	#28058,	r0	;0x06d9a

00006eac <.L271>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6eac:	8e 00 34 69 	mova	#26932,	r14	;0x06934
    6eb0:	80 00 94 6e 	mova	#28308,	r0	;0x06e94

00006eb4 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6eb4:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006eb6 <.LCFI35>:
    6eb6:	b1 00 04 00 	suba	#4,	r1	;

00006eba <.LCFI36>:
    6eba:	2a 4d       	mov	@r13,	r10	;

00006ebc <.LVL284>:
    6ebc:	18 4d 02 00 	mov	2(r13),	r8	;

00006ec0 <.LVL285>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ec0:	49 4a       	mov.b	r10,	r9	;
    6ec2:	69 f3       	and.b	#2,	r9	;r3 As==10
    6ec4:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    6ec8:	09 93       	cmp	#0,	r9	;r3 As==00
    6eca:	1a 20       	jnz	$+54     	;abs 0x6f00
    6ecc:	6e 43       	mov.b	#2,	r14	;r3 As==10

00006ece <.L277>:
  uint8_t err = buffer[hdr_ext];
    6ece:	40 18 0e 4e 	movx.w	r14,	r14	;
    6ed2:	ee 0c       	adda	r12,	r14	;

00006ed4 <.LVL287>:
    6ed4:	67 4e       	mov.b	@r14,	r7	;

00006ed6 <.LVL288>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6ed6:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006eda <.LVL289>:
    6eda:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006ede <.LVL290>:
  if (err > ELY_ALL_ERRORS) {
    6ede:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    6ee2:	4c 97       	cmp.b	r7,	r12	;
    6ee4:	16 2c       	jc	$+46     	;abs 0x6f12

00006ee6 <.Loc.1187.2>:
    if (hdr.reply) {
    6ee6:	09 93       	cmp	#0,	r9	;r3 As==00
    6ee8:	0e 24       	jz	$+30     	;abs 0x6f06

00006eea <.Loc.1189.2>:
      gen_failure(hdr);
    6eea:	81 4a 00 00 	mov	r10,	0(r1)	;
    6eee:	81 48 02 00 	mov	r8,	2(r1)	;
    6ef2:	cc 01       	mova	r1,	r12	;
    6ef4:	b0 13 be 6c 	calla	#27838		;0x06cbe

00006ef8 <.L276>:
}
    6ef8:	a1 00 04 00 	adda	#4,	r1	;
    6efc:	37 16       	popm.a	#4,	r10	;20-bit words
    6efe:	10 01       	reta			;

00006f00 <.L281>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f00:	6e 42       	mov.b	#4,	r14	;r2 As==10
    6f02:	80 00 ce 6e 	mova	#28366,	r0	;0x06ece

00006f06 <.L279>:
      elyErrorSignal(ErrCmdFailure);
    6f06:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6f0a:	b0 13 2a 91 	calla	#37162		;0x0912a

00006f0e <.LVL296>:
    6f0e:	80 00 f8 6e 	mova	#28408,	r0	;0x06ef8

00006f12 <.L278>:
  bank0w[RegErrLogLvl] = err;
    6f12:	2c 01 c6 05 	mova	&67014,	r12	;0x105c6
    6f16:	cc 47 4d 00 	mov.b	r7,	77(r12)	; 0x004d

00006f1a <.Loc.1199.2>:
  chSysLock();
    6f1a:	b0 13 e2 62 	calla	#25314		;0x062e2

00006f1e <.LVL297>:
  elyErrorSetLogLvlS(err);
    6f1e:	4c 47       	mov.b	r7,	r12	;
    6f20:	b0 13 2e 91 	calla	#37166		;0x0912e

00006f24 <.LVL298>:
  chSysUnlock();
    6f24:	b0 13 ea 62 	calla	#25322		;0x062ea

00006f28 <.LVL299>:
  if (hdr.reply) {
    6f28:	09 93       	cmp	#0,	r9	;r3 As==00
    6f2a:	e6 27       	jz	$-50     	;abs 0x6ef8

00006f2c <.Loc.1205.2>:
    gen_success(hdr);
    6f2c:	81 4a 00 00 	mov	r10,	0(r1)	;
    6f30:	81 48 02 00 	mov	r8,	2(r1)	;
    6f34:	cc 01       	mova	r1,	r12	;
    6f36:	b0 13 78 69 	calla	#27000		;0x06978

00006f3a <.LVL301>:
    6f3a:	80 00 f8 6e 	mova	#28408,	r0	;0x06ef8

00006f3e <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6f3e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006f40 <.LCFI37>:
    6f40:	b1 00 04 00 	suba	#4,	r1	;

00006f44 <.LCFI38>:
    6f44:	2a 4d       	mov	@r13,	r10	;

00006f46 <.LVL303>:
    6f46:	18 4d 02 00 	mov	2(r13),	r8	;

00006f4a <.LVL304>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f4a:	49 4a       	mov.b	r10,	r9	;
    6f4c:	69 f3       	and.b	#2,	r9	;r3 As==10
    6f4e:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    6f52:	09 93       	cmp	#0,	r9	;r3 As==00
    6f54:	1a 20       	jnz	$+54     	;abs 0x6f8a
    6f56:	6e 43       	mov.b	#2,	r14	;r3 As==10

00006f58 <.L286>:
  uint8_t err = buffer[hdr_ext];
    6f58:	40 18 0e 4e 	movx.w	r14,	r14	;
    6f5c:	ee 0c       	adda	r12,	r14	;

00006f5e <.LVL306>:
    6f5e:	67 4e       	mov.b	@r14,	r7	;

00006f60 <.LVL307>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6f60:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00006f64 <.LVL308>:
    6f64:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00006f68 <.LVL309>:
  if (err > ELY_ALL_ERRORS) {
    6f68:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    6f6c:	4c 97       	cmp.b	r7,	r12	;
    6f6e:	16 2c       	jc	$+46     	;abs 0x6f9c

00006f70 <.Loc.1128.2>:
    if (hdr.reply) {
    6f70:	09 93       	cmp	#0,	r9	;r3 As==00
    6f72:	0e 24       	jz	$+30     	;abs 0x6f90

00006f74 <.Loc.1130.2>:
      gen_failure(hdr);
    6f74:	81 4a 00 00 	mov	r10,	0(r1)	;
    6f78:	81 48 02 00 	mov	r8,	2(r1)	;
    6f7c:	cc 01       	mova	r1,	r12	;
    6f7e:	b0 13 be 6c 	calla	#27838		;0x06cbe

00006f82 <.L285>:
}
    6f82:	a1 00 04 00 	adda	#4,	r1	;
    6f86:	37 16       	popm.a	#4,	r10	;20-bit words
    6f88:	10 01       	reta			;

00006f8a <.L290>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f8a:	6e 42       	mov.b	#4,	r14	;r2 As==10
    6f8c:	80 00 58 6f 	mova	#28504,	r0	;0x06f58

00006f90 <.L288>:
      elyErrorSignal(ErrCmdFailure);
    6f90:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6f94:	b0 13 2a 91 	calla	#37162		;0x0912a

00006f98 <.LVL315>:
    6f98:	80 00 82 6f 	mova	#28546,	r0	;0x06f82

00006f9c <.L287>:
  bank0w[RegErrRptLvl] = err;
    6f9c:	2c 01 c6 05 	mova	&67014,	r12	;0x105c6
    6fa0:	cc 47 4c 00 	mov.b	r7,	76(r12)	; 0x004c

00006fa4 <.Loc.1140.2>:
  chSysLock();
    6fa4:	b0 13 e2 62 	calla	#25314		;0x062e2

00006fa8 <.LVL316>:
  elyErrorSetRptLvlS(err);
    6fa8:	4c 47       	mov.b	r7,	r12	;
    6faa:	b0 13 2c 91 	calla	#37164		;0x0912c

00006fae <.LVL317>:
  chSysUnlock();
    6fae:	b0 13 ea 62 	calla	#25322		;0x062ea

00006fb2 <.LVL318>:
  if (hdr.reply) {
    6fb2:	09 93       	cmp	#0,	r9	;r3 As==00
    6fb4:	e6 27       	jz	$-50     	;abs 0x6f82

00006fb6 <.Loc.1146.2>:
    gen_success(hdr);
    6fb6:	81 4a 00 00 	mov	r10,	0(r1)	;
    6fba:	81 48 02 00 	mov	r8,	2(r1)	;
    6fbe:	cc 01       	mova	r1,	r12	;
    6fc0:	b0 13 78 69 	calla	#27000		;0x06978

00006fc4 <.LVL320>:
    6fc4:	80 00 82 6f 	mova	#28546,	r0	;0x06f82

00006fc8 <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6fc8:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006fca <.LCFI39>:
    6fca:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00006fce <.LCFI40>:
    6fce:	c8 0c       	mova	r12,	r8	;
    6fd0:	29 4d       	mov	@r13,	r9	;

00006fd2 <.LVL322>:
    6fd2:	14 4d 02 00 	mov	2(r13),	r4	;

00006fd6 <.LVL323>:
    6fd6:	07 49       	mov	r9,	r7	;
    6fd8:	57 0f       	rrum	#4,	r7	;
    6fda:	57 0f       	rrum	#4,	r7	;

00006fdc <.Loc.991.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6fdc:	4c 49       	mov.b	r9,	r12	;

00006fde <.LVL325>:
    6fde:	1c b3       	bit	#1,	r12	;r3 As==01
    6fe0:	2b 20       	jnz	$+88     	;abs 0x7038
    6fe2:	4e 43       	clr.b	r14		;

00006fe4 <.L295>:
    6fe4:	6c f3       	and.b	#2,	r12	;r3 As==10
    6fe6:	45 4c       	mov.b	r12,	r5	;
    6fe8:	40 18 4d 47 	movx.b	r7,	r13	;
    6fec:	40 18 4d 8c 	subx.b	r12,	r13	;
    6ff0:	4d 8e       	sub.b	r14,	r13	;
    6ff2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006ff6 <.LVL326>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ff6:	05 93       	cmp	#0,	r5	;r3 As==00
    6ff8:	22 20       	jnz	$+70     	;abs 0x703e

00006ffa <.Loc.992.2>:
    6ffa:	6a 43       	mov.b	#2,	r10	;r3 As==10

00006ffc <.L296>:
    6ffc:	40 18 0e 4a 	movx.w	r10,	r14	;
    7000:	ee 08       	adda	r8,	r14	;

00007002 <.LBB44>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7002:	c6 0e       	mova	r14,	r6	;
    7004:	0c 4a       	mov	r10,	r12	;
    7006:	0d 5a       	add	r10,	r13	;

00007008 <.L297>:
    7008:	0c 9d       	cmp	r13,	r12	;
    700a:	1c 38       	jl	$+58     	;abs 0x7044

0000700c <.LBB45>:
    elyEventUnlog(buffer[i]);
    700c:	86 00 38 91 	mova	#37176,	r6	;0x09138

00007010 <.L303>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7010:	0a 9d       	cmp	r13,	r10	;
    7012:	41 38       	jl	$+132    	;abs 0x7096

00007014 <.LBE45>:
  if (hdr.reply) {
    7014:	05 93       	cmp	#0,	r5	;r3 As==00
    7016:	2d 24       	jz	$+92     	;abs 0x7072

00007018 <.Loc.1015.2>:
    gen_success(hdr);
    7018:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    701c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007020 <.LVL331>:
    7020:	09 d7       	bis	r7,	r9	;
    7022:	81 49 08 00 	mov	r9,	8(r1)	;
    7026:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    702a:	cc 01       	mova	r1,	r12	;
    702c:	ac 00 08 00 	adda	#8,	r12	;
    7030:	b0 13 78 69 	calla	#27000		;0x06978

00007034 <.LVL332>:
    7034:	80 00 72 70 	mova	#28786,	r0	;0x07072

00007038 <.L306>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7038:	6e 43       	mov.b	#2,	r14	;r3 As==10
    703a:	80 00 e4 6f 	mova	#28644,	r0	;0x06fe4

0000703e <.L307>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    703e:	6a 42       	mov.b	#4,	r10	;r2 As==10
    7040:	80 00 fc 6f 	mova	#28668,	r0	;0x06ffc

00007044 <.L302>:
    7044:	a6 00 01 00 	adda	#1,	r6	;

00007048 <.LBB46>:
    if (buffer[i] < 0xC0) {
    7048:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    704c:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    7050:	1f 28       	jnc	$+64     	;abs 0x7090

00007052 <.Loc.997.2>:
      if (hdr.reply) {
    7052:	05 93       	cmp	#0,	r5	;r3 As==00
    7054:	17 24       	jz	$+48     	;abs 0x7084

00007056 <.Loc.999.2>:
        gen_failure(hdr);
    7056:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    705a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000705e <.LVL337>:
    705e:	09 d7       	bis	r7,	r9	;
    7060:	81 49 08 00 	mov	r9,	8(r1)	;
    7064:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    7068:	cc 01       	mova	r1,	r12	;

0000706a <.LVL338>:
    706a:	ac 00 08 00 	adda	#8,	r12	;
    706e:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007072 <.L305>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7072:	cc 08       	mova	r8,	r12	;
    7074:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007078 <.LVL340>:
    7078:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000707c <.LVL341>:
}
    707c:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    7080:	64 16       	popm.a	#7,	r10	;20-bit words
    7082:	10 01       	reta			;

00007084 <.L299>:
        elyErrorSignal(ErrCmdFailure);
    7084:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007088 <.LVL343>:
    7088:	b0 13 2a 91 	calla	#37162		;0x0912a

0000708c <.LVL344>:
    708c:	80 00 72 70 	mova	#28786,	r0	;0x07072

00007090 <.L298>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7090:	1c 53       	inc	r12		;
    7092:	80 00 08 70 	mova	#28680,	r0	;0x07008

00007096 <.L304>:
    elyEventUnlog(buffer[i]);
    7096:	6c 4e       	mov.b	@r14,	r12	;
    7098:	71 0d 00 00 	mova	r13,	0(r1)	;
    709c:	71 0e 04 00 	mova	r14,	4(r1)	;
    70a0:	46 13       	calla	r6		;

000070a2 <.LVL348>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    70a2:	1a 53       	inc	r10		;
    70a4:	3e 01 04 00 	mova	4(r1),	r14	;
    70a8:	ae 00 01 00 	adda	#1,	r14	;
    70ac:	0d 01       	mova	@r1,	r13	;
    70ae:	80 00 10 70 	mova	#28688,	r0	;0x07010

000070b2 <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    70b2:	6a 14       	pushm.a	#7,	r10	;20-bit words

000070b4 <.LCFI41>:
    70b4:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000070b8 <.LCFI42>:
    70b8:	c8 0c       	mova	r12,	r8	;
    70ba:	29 4d       	mov	@r13,	r9	;

000070bc <.LVL351>:
    70bc:	1b 4d 02 00 	mov	2(r13),	r11	;

000070c0 <.LVL352>:
    70c0:	07 49       	mov	r9,	r7	;
    70c2:	57 0f       	rrum	#4,	r7	;
    70c4:	57 0f       	rrum	#4,	r7	;

000070c6 <.Loc.957.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    70c6:	4c 49       	mov.b	r9,	r12	;

000070c8 <.LVL354>:
    70c8:	1c b3       	bit	#1,	r12	;r3 As==01
    70ca:	2b 20       	jnz	$+88     	;abs 0x7122
    70cc:	4e 43       	clr.b	r14		;

000070ce <.L312>:
    70ce:	6c f3       	and.b	#2,	r12	;r3 As==10
    70d0:	45 4c       	mov.b	r12,	r5	;
    70d2:	40 18 4d 47 	movx.b	r7,	r13	;
    70d6:	40 18 4d 8c 	subx.b	r12,	r13	;
    70da:	4d 8e       	sub.b	r14,	r13	;
    70dc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000070e0 <.LVL355>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    70e0:	05 93       	cmp	#0,	r5	;r3 As==00
    70e2:	22 20       	jnz	$+70     	;abs 0x7128

000070e4 <.Loc.958.2>:
    70e4:	6a 43       	mov.b	#2,	r10	;r3 As==10

000070e6 <.L313>:
    70e6:	40 18 04 4a 	movx.w	r10,	r4	;
    70ea:	e4 08       	adda	r8,	r4	;

000070ec <.LBB49>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    70ec:	c6 04       	mova	r4,	r6	;
    70ee:	0e 4a       	mov	r10,	r14	;
    70f0:	0d 5a       	add	r10,	r13	;

000070f2 <.L314>:
    70f2:	0e 9d       	cmp	r13,	r14	;
    70f4:	1c 38       	jl	$+58     	;abs 0x712e

000070f6 <.LBB50>:
    elyEventLog(buffer[i]);
    70f6:	86 00 36 91 	mova	#37174,	r6	;0x09136

000070fa <.L321>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    70fa:	0a 9d       	cmp	r13,	r10	;
    70fc:	55 38       	jl	$+172    	;abs 0x71a8

000070fe <.LBE50>:
  if (hdr.reply) {
    70fe:	05 93       	cmp	#0,	r5	;r3 As==00
    7100:	41 24       	jz	$+132    	;abs 0x7184

00007102 <.Loc.983.2>:
    gen_success(hdr);
    7102:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    7106:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000710a <.LVL360>:
    710a:	09 d7       	bis	r7,	r9	;
    710c:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7110:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    7114:	cc 01       	mova	r1,	r12	;
    7116:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    711a:	b0 13 78 69 	calla	#27000		;0x06978

0000711e <.LVL361>:
    711e:	80 00 84 71 	mova	#29060,	r0	;0x07184

00007122 <.L324>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7122:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7124:	80 00 ce 70 	mova	#28878,	r0	;0x070ce

00007128 <.L325>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7128:	6a 42       	mov.b	#4,	r10	;r2 As==10
    712a:	80 00 e6 70 	mova	#28902,	r0	;0x070e6

0000712e <.L320>:
    if ((buffer[i] < 0xC0) || 
    712e:	6c 46       	mov.b	@r6,	r12	;
    7130:	4f 4c       	mov.b	r12,	r15	;
    7132:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    7136:	c1 4f 01 00 	mov.b	r15,	1(r1)	;
    713a:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    713e:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    7142:	10 28       	jnc	$+34     	;abs 0x7164

00007144 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7144:	4f 4c       	mov.b	r12,	r15	;
    7146:	7f 50 2d 00 	add.b	#45,	r15	;#0x002d
    714a:	c1 4f 01 00 	mov.b	r15,	1(r1)	;

0000714e <.Loc.961.2>:
    if ((buffer[i] < 0xC0) || 
    714e:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    7152:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    7156:	06 2c       	jc	$+14     	;abs 0x7164
    7158:	a6 00 01 00 	adda	#1,	r6	;

0000715c <.Loc.963.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    715c:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

00007160 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7160:	4f 9c       	cmp.b	r12,	r15	;
    7162:	1f 28       	jnc	$+64     	;abs 0x71a2

00007164 <.L315>:
      if (hdr.reply) {
    7164:	05 93       	cmp	#0,	r5	;r3 As==00
    7166:	17 24       	jz	$+48     	;abs 0x7196

00007168 <.Loc.967.2>:
        gen_failure(hdr);
    7168:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    716c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007170 <.LVL366>:
    7170:	09 d7       	bis	r7,	r9	;
    7172:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7176:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    717a:	cc 01       	mova	r1,	r12	;
    717c:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    7180:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007184 <.L323>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7184:	cc 08       	mova	r8,	r12	;
    7186:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000718a <.LVL368>:
    718a:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000718e <.LVL369>:
}
    718e:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    7192:	64 16       	popm.a	#7,	r10	;20-bit words
    7194:	10 01       	reta			;

00007196 <.L317>:
        elyErrorSignal(ErrCmdFailure);
    7196:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    719a:	b0 13 2a 91 	calla	#37162		;0x0912a

0000719e <.LVL371>:
    719e:	80 00 84 71 	mova	#29060,	r0	;0x07184

000071a2 <.L316>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    71a2:	1e 53       	inc	r14		;
    71a4:	80 00 f2 70 	mova	#28914,	r0	;0x070f2

000071a8 <.L322>:
    elyEventLog(buffer[i]);
    71a8:	6c 44       	mov.b	@r4,	r12	;
    71aa:	71 0b 02 00 	mova	r11,	2(r1)	;
    71ae:	71 0d 06 00 	mova	r13,	6(r1)	;
    71b2:	46 13       	calla	r6		;

000071b4 <.LVL375>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    71b4:	1a 53       	inc	r10		;
    71b6:	a4 00 01 00 	adda	#1,	r4	;
    71ba:	3d 01 06 00 	mova	6(r1),	r13	;
    71be:	3b 01 02 00 	mova	2(r1),	r11	;
    71c2:	80 00 fa 70 	mova	#28922,	r0	;0x070fa

000071c6 <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    71c6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000071c8 <.LCFI43>:
    71c8:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

000071cc <.LCFI44>:
    71cc:	c8 0c       	mova	r12,	r8	;
    71ce:	29 4d       	mov	@r13,	r9	;

000071d0 <.LVL378>:
    71d0:	14 4d 02 00 	mov	2(r13),	r4	;

000071d4 <.LVL379>:
    71d4:	07 49       	mov	r9,	r7	;
    71d6:	57 0f       	rrum	#4,	r7	;
    71d8:	57 0f       	rrum	#4,	r7	;

000071da <.Loc.926.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    71da:	4c 49       	mov.b	r9,	r12	;

000071dc <.LVL381>:
    71dc:	1c b3       	bit	#1,	r12	;r3 As==01
    71de:	2b 20       	jnz	$+88     	;abs 0x7236
    71e0:	4e 43       	clr.b	r14		;

000071e2 <.L330>:
    71e2:	6c f3       	and.b	#2,	r12	;r3 As==10
    71e4:	45 4c       	mov.b	r12,	r5	;
    71e6:	40 18 4d 47 	movx.b	r7,	r13	;
    71ea:	40 18 4d 8c 	subx.b	r12,	r13	;
    71ee:	4d 8e       	sub.b	r14,	r13	;
    71f0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000071f4 <.LVL382>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    71f4:	05 93       	cmp	#0,	r5	;r3 As==00
    71f6:	22 20       	jnz	$+70     	;abs 0x723c

000071f8 <.Loc.927.2>:
    71f8:	6a 43       	mov.b	#2,	r10	;r3 As==10

000071fa <.L331>:
    71fa:	40 18 0e 4a 	movx.w	r10,	r14	;
    71fe:	ee 08       	adda	r8,	r14	;

00007200 <.LBB54>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7200:	c6 0e       	mova	r14,	r6	;
    7202:	0c 4a       	mov	r10,	r12	;
    7204:	0d 5a       	add	r10,	r13	;

00007206 <.L332>:
    7206:	0c 9d       	cmp	r13,	r12	;
    7208:	1c 38       	jl	$+58     	;abs 0x7242

0000720a <.LBB55>:
    elyEventUnsubscribe(buffer[i]);
    720a:	86 00 34 91 	mova	#37172,	r6	;0x09134

0000720e <.L338>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    720e:	0a 9d       	cmp	r13,	r10	;
    7210:	41 38       	jl	$+132    	;abs 0x7294

00007212 <.LBE55>:
  if (hdr.reply) {
    7212:	05 93       	cmp	#0,	r5	;r3 As==00
    7214:	2d 24       	jz	$+92     	;abs 0x7270

00007216 <.Loc.949.2>:
    gen_success(hdr);
    7216:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    721a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000721e <.LVL387>:
    721e:	09 d7       	bis	r7,	r9	;
    7220:	81 49 08 00 	mov	r9,	8(r1)	;
    7224:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    7228:	cc 01       	mova	r1,	r12	;
    722a:	ac 00 08 00 	adda	#8,	r12	;
    722e:	b0 13 78 69 	calla	#27000		;0x06978

00007232 <.LVL388>:
    7232:	80 00 70 72 	mova	#29296,	r0	;0x07270

00007236 <.L341>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7236:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7238:	80 00 e2 71 	mova	#29154,	r0	;0x071e2

0000723c <.L342>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    723c:	6a 42       	mov.b	#4,	r10	;r2 As==10
    723e:	80 00 fa 71 	mova	#29178,	r0	;0x071fa

00007242 <.L337>:
    7242:	a6 00 01 00 	adda	#1,	r6	;

00007246 <.LBB56>:
    if (buffer[i] < 0xC0) {
    7246:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    724a:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    724e:	1f 28       	jnc	$+64     	;abs 0x728e

00007250 <.Loc.931.2>:
      if (hdr.reply) {
    7250:	05 93       	cmp	#0,	r5	;r3 As==00
    7252:	17 24       	jz	$+48     	;abs 0x7282

00007254 <.Loc.933.2>:
        gen_failure(hdr);
    7254:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    7258:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000725c <.LVL393>:
    725c:	09 d7       	bis	r7,	r9	;
    725e:	81 49 08 00 	mov	r9,	8(r1)	;
    7262:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    7266:	cc 01       	mova	r1,	r12	;

00007268 <.LVL394>:
    7268:	ac 00 08 00 	adda	#8,	r12	;
    726c:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007270 <.L340>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7270:	cc 08       	mova	r8,	r12	;
    7272:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007276 <.LVL396>:
    7276:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000727a <.LVL397>:
}
    727a:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    727e:	64 16       	popm.a	#7,	r10	;20-bit words
    7280:	10 01       	reta			;

00007282 <.L334>:
        elyErrorSignal(ErrCmdFailure);
    7282:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007286 <.LVL399>:
    7286:	b0 13 2a 91 	calla	#37162		;0x0912a

0000728a <.LVL400>:
    728a:	80 00 70 72 	mova	#29296,	r0	;0x07270

0000728e <.L333>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    728e:	1c 53       	inc	r12		;
    7290:	80 00 06 72 	mova	#29190,	r0	;0x07206

00007294 <.L339>:
    elyEventUnsubscribe(buffer[i]);
    7294:	6c 4e       	mov.b	@r14,	r12	;
    7296:	71 0d 00 00 	mova	r13,	0(r1)	;
    729a:	71 0e 04 00 	mova	r14,	4(r1)	;
    729e:	46 13       	calla	r6		;

000072a0 <.LVL404>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    72a0:	1a 53       	inc	r10		;
    72a2:	3e 01 04 00 	mova	4(r1),	r14	;
    72a6:	ae 00 01 00 	adda	#1,	r14	;
    72aa:	0d 01       	mova	@r1,	r13	;
    72ac:	80 00 0e 72 	mova	#29198,	r0	;0x0720e

000072b0 <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    72b0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000072b2 <.LCFI45>:
    72b2:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000072b6 <.LCFI46>:
    72b6:	c4 0c       	mova	r12,	r4	;
    72b8:	29 4d       	mov	@r13,	r9	;

000072ba <.LVL407>:
    72ba:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    72be:	08 00 
    72c0:	06 49       	mov	r9,	r6	;
    72c2:	56 0f       	rrum	#4,	r6	;
    72c4:	56 0f       	rrum	#4,	r6	;

000072c6 <.Loc.883.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    72c6:	4c 49       	mov.b	r9,	r12	;

000072c8 <.LVL409>:
    72c8:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    72cc:	36 24       	jz	$+110    	;abs 0x733a
    72ce:	6d 43       	mov.b	#2,	r13	;r3 As==10

000072d0 <.L347>:
    72d0:	6c f3       	and.b	#2,	r12	;r3 As==10
    72d2:	4e 4c       	mov.b	r12,	r14	;
    72d4:	40 18 47 46 	movx.b	r6,	r7	;
    72d8:	40 18 47 8c 	subx.b	r12,	r7	;
    72dc:	47 8d       	sub.b	r13,	r7	;
    72de:	37 f0 ff 00 	and	#255,	r7	;#0x00ff

000072e2 <.LVL410>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    72e2:	0e 93       	cmp	#0,	r14	;r3 As==00
    72e4:	2d 24       	jz	$+92     	;abs 0x7340

000072e6 <.Loc.884.2>:
    72e6:	6a 42       	mov.b	#4,	r10	;r2 As==10

000072e8 <.L348>:
    72e8:	40 18 0c 4a 	movx.w	r10,	r12	;
    72ec:	cb 04       	mova	r4,	r11	;
    72ee:	eb 0c       	adda	r12,	r11	;

000072f0 <.LBB59>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    72f0:	c8 0b       	mova	r11,	r8	;
    72f2:	0d 4a       	mov	r10,	r13	;
    72f4:	07 5a       	add	r10,	r7	;

000072f6 <.L349>:
    72f6:	0d 97       	cmp	r7,	r13	;
    72f8:	26 38       	jl	$+78     	;abs 0x7346

000072fa <.LBE59>:
  if (hdr.reply) {
    72fa:	0e 93       	cmp	#0,	r14	;r3 As==00
    72fc:	5b 24       	jz	$+184    	;abs 0x73b4

000072fe <.Loc.905.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    72fe:	55 44 02 00 	mov.b	2(r4),	r5	;
    7302:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    7306:	5c 44 03 00 	mov.b	3(r4),	r12	;

0000730a <.L366>:
    730a:	05 dc       	bis	r12,	r5	;

0000730c <.LBB60>:
      elyEventSubscribe(buffer[i], addr);
    730c:	88 00 32 91 	mova	#37170,	r8	;0x09132

00007310 <.L358>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7310:	0a 97       	cmp	r7,	r10	;
    7312:	5a 38       	jl	$+182    	;abs 0x73c8

00007314 <.LBE60>:
  if (hdr.reply) {
    7314:	0e 93       	cmp	#0,	r14	;r3 As==00
    7316:	3c 24       	jz	$+122    	;abs 0x7390

00007318 <.Loc.918.2>:
    gen_success(hdr);
    7318:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    731c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007320 <.LVL416>:
    7320:	09 d6       	bis	r6,	r9	;
    7322:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7326:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    732a:	0c 00 
    732c:	cc 01       	mova	r1,	r12	;
    732e:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    7332:	b0 13 78 69 	calla	#27000		;0x06978

00007336 <.LVL417>:
    7336:	80 00 90 73 	mova	#29584,	r0	;0x07390

0000733a <.L361>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    733a:	4d 43       	clr.b	r13		;
    733c:	80 00 d0 72 	mova	#29392,	r0	;0x072d0

00007340 <.L362>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7340:	6a 43       	mov.b	#2,	r10	;r3 As==10
    7342:	80 00 e8 72 	mova	#29416,	r0	;0x072e8

00007346 <.L355>:
    if ((buffer[i] < 0xC0) || 
    7346:	6c 48       	mov.b	@r8,	r12	;
    7348:	4f 4c       	mov.b	r12,	r15	;
    734a:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    734e:	75 40 32 00 	mov.b	#50,	r5	;#0x0032
    7352:	45 9f       	cmp.b	r15,	r5	;
    7354:	0c 28       	jnc	$+26     	;abs 0x736e

00007356 <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7356:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

0000735a <.Loc.887.2>:
    if ((buffer[i] < 0xC0) || 
    735a:	75 40 0c 00 	mov.b	#12,	r5	;#0x000c
    735e:	45 9f       	cmp.b	r15,	r5	;
    7360:	06 2c       	jc	$+14     	;abs 0x736e
    7362:	a8 00 01 00 	adda	#1,	r8	;

00007366 <.Loc.889.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7366:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

0000736a <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    736a:	45 9c       	cmp.b	r12,	r5	;
    736c:	20 28       	jnc	$+66     	;abs 0x73ae

0000736e <.L350>:
      if (hdr.reply) {
    736e:	0e 93       	cmp	#0,	r14	;r3 As==00
    7370:	18 24       	jz	$+50     	;abs 0x73a2

00007372 <.Loc.893.2>:
        gen_failure(hdr);
    7372:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    7376:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000737a <.LVL422>:
    737a:	09 d6       	bis	r6,	r9	;
    737c:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7380:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    7384:	0c 00 
    7386:	cc 01       	mova	r1,	r12	;
    7388:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    738c:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007390 <.L360>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7390:	cc 04       	mova	r4,	r12	;
    7392:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007396 <.LVL424>:
    7396:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000739a <.LVL425>:
}
    739a:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    739e:	64 16       	popm.a	#7,	r10	;20-bit words
    73a0:	10 01       	reta			;

000073a2 <.L352>:
        elyErrorSignal(ErrCmdFailure);
    73a2:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    73a6:	b0 13 2a 91 	calla	#37162		;0x0912a

000073aa <.LVL427>:
    73aa:	80 00 90 73 	mova	#29584,	r0	;0x07390

000073ae <.L351>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73ae:	1d 53       	inc	r13		;
    73b0:	80 00 f6 72 	mova	#29430,	r0	;0x072f6

000073b4 <.L356>:
    73b4:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    73b8:	55 4c 55 00 	mov.b	85(r12),r5	;0x00055
    73bc:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    73c0:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    73c4:	80 00 0a 73 	mova	#29450,	r0	;0x0730a

000073c8 <.L359>:
      elyEventSubscribe(buffer[i], addr);
    73c8:	0d 45       	mov	r5,	r13	;
    73ca:	6c 4b       	mov.b	@r11,	r12	;
    73cc:	71 0b 00 00 	mova	r11,	0(r1)	;
    73d0:	71 0e 04 00 	mova	r14,	4(r1)	;
    73d4:	48 13       	calla	r8		;

000073d6 <.LVL431>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73d6:	1a 53       	inc	r10		;
    73d8:	0b 01       	mova	@r1,	r11	;
    73da:	ab 00 01 00 	adda	#1,	r11	;
    73de:	3e 01 04 00 	mova	4(r1),	r14	;
    73e2:	80 00 10 73 	mova	#29456,	r0	;0x07310

000073e6 <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    73e6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000073e8 <.LCFI47>:
    73e8:	b1 00 06 00 	suba	#6,	r1	;

000073ec <.LCFI48>:
    73ec:	c6 0c       	mova	r12,	r6	;
    73ee:	29 4d       	mov	@r13,	r9	;

000073f0 <.LVL434>:
    73f0:	17 4d 02 00 	mov	2(r13),	r7	;

000073f4 <.LVL435>:
    73f4:	0a 49       	mov	r9,	r10	;
    73f6:	5a 0f       	rrum	#4,	r10	;
    73f8:	5a 0f       	rrum	#4,	r10	;

000073fa <.Loc.796.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    73fa:	4e 49       	mov.b	r9,	r14	;
    73fc:	04 4e       	mov	r14,	r4	;
    73fe:	54 f3       	and.b	#1,	r4	;r3 As==01
    7400:	04 93       	cmp	#0,	r4	;r3 As==00
    7402:	30 20       	jnz	$+98     	;abs 0x7464
    7404:	0d 44       	mov	r4,	r13	;

00007406 <.L368>:
    7406:	6e f3       	and.b	#2,	r14	;r3 As==10
    7408:	48 4e       	mov.b	r14,	r8	;

0000740a <.LVL437>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    740a:	08 93       	cmp	#0,	r8	;r3 As==00
    740c:	2e 20       	jnz	$+94     	;abs 0x746a

0000740e <.Loc.797.2>:
    740e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007410 <.L369>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7410:	0f 4c       	mov	r12,	r15	;

00007412 <.LVL439>:
    7412:	05 4a       	mov	r10,	r5	;
    7414:	05 5c       	add	r12,	r5	;
    7416:	04 93       	cmp	#0,	r4	;r3 As==00
    7418:	01 24       	jz	$+4      	;abs 0x741c
    741a:	64 43       	mov.b	#2,	r4	;r3 As==10

0000741c <.L371>:
    741c:	05 84       	sub	r4,	r5	;
    741e:	81 45 00 00 	mov	r5,	0(r1)	;
    7422:	40 18 04 4c 	movx.w	r12,	r4	;
    7426:	e4 06       	adda	r6,	r4	;
    7428:	cc 04       	mova	r4,	r12	;

0000742a <.L372>:
    742a:	2f 91       	cmp	@r1,	r15	;
    742c:	21 38       	jl	$+68     	;abs 0x7470

0000742e <.LBE64>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    742e:	40 18 4c 4a 	movx.b	r10,	r12	;
    7432:	40 18 4c 8e 	subx.b	r14,	r12	;

00007436 <.Loc.813.2>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    7436:	4c 8d       	sub.b	r13,	r12	;
    7438:	4d 4c       	mov.b	r12,	r13	;

0000743a <.LVL441>:
    743a:	cc 04       	mova	r4,	r12	;
    743c:	b0 13 42 91 	calla	#37186		;0x09142

00007440 <.LVL442>:
  if (hdr.reply) {
    7440:	08 93       	cmp	#0,	r8	;r3 As==00
    7442:	2f 24       	jz	$+96     	;abs 0x74a2

00007444 <.Loc.817.2>:
    gen_success(hdr);
    7444:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;
    7448:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000744c <.LVL444>:
    744c:	09 da       	bis	r10,	r9	;
    744e:	81 49 02 00 	mov	r9,	2(r1)	;
    7452:	81 47 04 00 	mov	r7,	4(r1)	;
    7456:	cc 01       	mova	r1,	r12	;
    7458:	ac 00 02 00 	adda	#2,	r12	;
    745c:	b0 13 78 69 	calla	#27000		;0x06978

00007460 <.LVL445>:
    7460:	80 00 a2 74 	mova	#29858,	r0	;0x074a2

00007464 <.L379>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7464:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7466:	80 00 06 74 	mova	#29702,	r0	;0x07406

0000746a <.L380>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    746a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    746c:	80 00 10 74 	mova	#29712,	r0	;0x07410

00007470 <.L377>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7470:	6b 4c       	mov.b	@r12,	r11	;
    7472:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    7476:	ac 00 01 00 	adda	#1,	r12	;
    747a:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    747e:	45 9b       	cmp.b	r11,	r5	;
    7480:	1f 2c       	jc	$+64     	;abs 0x74c0

00007482 <.Loc.801.2>:
      if (hdr.reply) {
    7482:	08 93       	cmp	#0,	r8	;r3 As==00
    7484:	17 24       	jz	$+48     	;abs 0x74b4

00007486 <.Loc.803.2>:
        gen_failure(hdr);
    7486:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;

0000748a <.LVL449>:
    748a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000748e <.LVL450>:
    748e:	09 da       	bis	r10,	r9	;
    7490:	81 49 02 00 	mov	r9,	2(r1)	;
    7494:	81 47 04 00 	mov	r7,	4(r1)	;
    7498:	cc 01       	mova	r1,	r12	;
    749a:	ac 00 02 00 	adda	#2,	r12	;
    749e:	b0 13 be 6c 	calla	#27838		;0x06cbe

000074a2 <.L378>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    74a2:	cc 06       	mova	r6,	r12	;
    74a4:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000074a8 <.LVL452>:
    74a8:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000074ac <.LVL453>:
}
    74ac:	a1 00 06 00 	adda	#6,	r1	;
    74b0:	64 16       	popm.a	#7,	r10	;20-bit words
    74b2:	10 01       	reta			;

000074b4 <.L374>:
        elyErrorSignal(ErrCmdFailure);
    74b4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    74b8:	b0 13 2a 91 	calla	#37162		;0x0912a

000074bc <.LVL455>:
    74bc:	80 00 a2 74 	mova	#29858,	r0	;0x074a2

000074c0 <.L373>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    74c0:	1f 53       	inc	r15		;
    74c2:	80 00 2a 74 	mova	#29738,	r0	;0x0742a

000074c6 <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    74c6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000074c8 <.LCFI49>:
    74c8:	b1 00 14 00 	suba	#20,	r1	;0x00014

000074cc <.LCFI50>:
    74cc:	c8 0c       	mova	r12,	r8	;
    74ce:	27 4d       	mov	@r13,	r7	;

000074d0 <.LVL459>:
    74d0:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    74d4:	08 00 
    74d6:	09 47       	mov	r7,	r9	;
    74d8:	59 0f       	rrum	#4,	r9	;
    74da:	59 0f       	rrum	#4,	r9	;

000074dc <.Loc.755.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    74dc:	4c 47       	mov.b	r7,	r12	;

000074de <.LVL461>:
    74de:	1c b3       	bit	#1,	r12	;r3 As==01
    74e0:	66 20       	jnz	$+206    	;abs 0x75ae
    74e2:	4d 43       	clr.b	r13		;

000074e4 <.L385>:
    74e4:	6c f3       	and.b	#2,	r12	;r3 As==10
    74e6:	45 4c       	mov.b	r12,	r5	;
    74e8:	81 45 04 00 	mov	r5,	4(r1)	;
    74ec:	40 18 4e 49 	movx.b	r9,	r14	;
    74f0:	40 18 4e 8c 	subx.b	r12,	r14	;
    74f4:	4e 8d       	sub.b	r13,	r14	;
    74f6:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    74fa:	4f 4e       	mov.b	r14,	r15	;

000074fc <.LVL462>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    74fc:	05 93       	cmp	#0,	r5	;r3 As==00
    74fe:	5a 20       	jnz	$+182    	;abs 0x75b4

00007500 <.Loc.756.2>:
    7500:	6a 43       	mov.b	#2,	r10	;r3 As==10

00007502 <.L386>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7502:	0e 4a       	mov	r10,	r14	;

00007504 <.LVL464>:
    7504:	2e 52       	add	#4,	r14	;r2 As==10

00007506 <.LVL465>:
    7506:	06 4e       	mov	r14,	r6	;
    7508:	46 0e       	rlam.a	#4,	r6	;
    750a:	46 0d       	rram.a	#4,	r6	;
    750c:	cc 06       	mova	r6,	r12	;
    750e:	ec 08       	adda	r8,	r12	;
    7510:	0f 5a       	add	r10,	r15	;

00007512 <.L387>:
    7512:	0e 9f       	cmp	r15,	r14	;
    7514:	52 38       	jl	$+166    	;abs 0x75ba
    7516:	04 4a       	mov	r10,	r4	;
    7518:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    751c:	04 8a       	sub	r10,	r4	;
    751e:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00007522 <.Loc.759.2>:
    7522:	65 42       	mov.b	#4,	r5	;r2 As==10
    7524:	46 43       	clr.b	r6		;
    7526:	04 46       	mov	r6,	r4	;

00007528 <.LBB68>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7528:	40 18 0c 4a 	movx.w	r10,	r12	;
    752c:	ec 08       	adda	r8,	r12	;
    752e:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

00007532 <.L394>:
    7532:	35 53       	add	#-1,	r5	;r3 As==11

00007534 <.LVL467>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7534:	35 93       	cmp	#-1,	r5	;r3 As==11
    7536:	7b 20       	jnz	$+248    	;abs 0x762e

00007538 <.LBE68>:
  interval = (interval / 100) * 100;
    7538:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    753c:	4f 43       	clr.b	r15		;
    753e:	0c 46       	mov	r6,	r12	;
    7540:	0d 44       	mov	r4,	r13	;
    7542:	b0 13 ae 9e 	calla	#40622		;0x09eae
    7546:	05 4c       	mov	r12,	r5	;

00007548 <.LVL469>:
    7548:	06 4d       	mov	r13,	r6	;

0000754a <.LVL470>:
    754a:	0c 5c       	rla	r12		;
    754c:	0d 6d       	rlc	r13		;
    754e:	0e 4c       	mov	r12,	r14	;
    7550:	0e 55       	add	r5,	r14	;
    7552:	04 4d       	mov	r13,	r4	;
    7554:	04 66       	addc	r6,	r4	;
    7556:	0c 4e       	mov	r14,	r12	;
    7558:	0d 44       	mov	r4,	r13	;
    755a:	71 0e 00 00 	mova	r14,	0(r1)	;
    755e:	b0 13 12 9f 	calla	#40722		;0x09f12
    7562:	0e 01       	mova	@r1,	r14	;
    7564:	0e 5c       	add	r12,	r14	;
    7566:	0d 64       	addc	r4,	r13	;

00007568 <.Loc.783.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    7568:	40 18 0a 4a 	movx.w	r10,	r10	;
    756c:	aa 00 04 00 	adda	#4,	r10	;

00007570 <.LVL472>:
    7570:	0e 55       	add	r5,	r14	;
    7572:	0f 4d       	mov	r13,	r15	;
    7574:	0f 66       	addc	r6,	r15	;
    7576:	5d 41 07 00 	mov.b	7(r1),	r13	;
    757a:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    757e:	cc 08       	mova	r8,	r12	;
    7580:	ec 0a       	adda	r10,	r12	;
    7582:	b0 13 40 91 	calla	#37184		;0x09140

00007586 <.LVL473>:
  if (hdr.reply) {
    7586:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    758a:	3f 24       	jz	$+128    	;abs 0x760a

0000758c <.Loc.787.2>:
    gen_success(hdr);
    758c:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    7590:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00007594 <.LVL475>:
    7594:	07 d9       	bis	r9,	r7	;
    7596:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    759a:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    759e:	12 00 
    75a0:	cc 01       	mova	r1,	r12	;
    75a2:	ac 00 10 00 	adda	#16,	r12	;0x00010
    75a6:	b0 13 78 69 	calla	#27000		;0x06978

000075aa <.LVL476>:
    75aa:	80 00 0a 76 	mova	#30218,	r0	;0x0760a

000075ae <.L397>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    75ae:	6d 43       	mov.b	#2,	r13	;r3 As==10
    75b0:	80 00 e4 74 	mova	#29924,	r0	;0x074e4

000075b4 <.L398>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    75b4:	6a 42       	mov.b	#4,	r10	;r2 As==10
    75b6:	80 00 02 75 	mova	#29954,	r0	;0x07502

000075ba <.L393>:
    if ((buffer[i] < 0x40) || 
    75ba:	6d 4c       	mov.b	@r12,	r13	;
    75bc:	46 4d       	mov.b	r13,	r6	;
    75be:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    75c2:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    75c6:	45 96       	cmp.b	r6,	r5	;
    75c8:	0e 28       	jnc	$+30     	;abs 0x75e6

000075ca <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    75ca:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

000075ce <.Loc.760.2>:
    if ((buffer[i] < 0x40) || 
    75ce:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    75d2:	45 96       	cmp.b	r6,	r5	;
    75d4:	08 2c       	jc	$+18     	;abs 0x75e6
    75d6:	ac 00 01 00 	adda	#1,	r12	;

000075da <.Loc.762.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    75da:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

000075de <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    75de:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    75e2:	46 9d       	cmp.b	r13,	r6	;
    75e4:	21 28       	jnc	$+68     	;abs 0x7628

000075e6 <.L388>:
      if (hdr.reply) {
    75e6:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    75ea:	18 24       	jz	$+50     	;abs 0x761c

000075ec <.Loc.766.2>:
        gen_failure(hdr);
    75ec:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    75f0:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

000075f4 <.LVL481>:
    75f4:	07 d9       	bis	r9,	r7	;
    75f6:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    75fa:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    75fe:	12 00 
    7600:	cc 01       	mova	r1,	r12	;
    7602:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7606:	b0 13 be 6c 	calla	#27838		;0x06cbe

0000760a <.L396>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    760a:	cc 08       	mova	r8,	r12	;
    760c:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007610 <.LVL483>:
    7610:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007614 <.LVL484>:
}
    7614:	a1 00 14 00 	adda	#20,	r1	;0x00014
    7618:	64 16       	popm.a	#7,	r10	;20-bit words
    761a:	10 01       	reta			;

0000761c <.L390>:
        elyErrorSignal(ErrCmdFailure);
    761c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7620:	b0 13 2a 91 	calla	#37162		;0x0912a

00007624 <.LVL486>:
    7624:	80 00 0a 76 	mova	#30218,	r0	;0x0760a

00007628 <.L389>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7628:	1e 53       	inc	r14		;
    762a:	80 00 12 75 	mova	#29970,	r0	;0x07512

0000762e <.L395>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    762e:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7632:	0e 55       	add	r5,	r14	;
    7634:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7638:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    763c:	6c 4f       	mov.b	@r15,	r12	;
    763e:	0d 43       	clr	r13		;
    7640:	0f 43       	clr	r15		;
    7642:	b0 13 2e 9f 	calla	#40750		;0x09f2e
    7646:	06 dc       	bis	r12,	r6	;

00007648 <.LVL491>:
    7648:	04 dd       	bis	r13,	r4	;

0000764a <.LVL492>:
    764a:	80 00 32 75 	mova	#30002,	r0	;0x07532

0000764e <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    764e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007650 <.LCFI51>:
    7650:	b1 00 04 00 	suba	#4,	r1	;

00007654 <.LCFI52>:
    7654:	c8 0c       	mova	r12,	r8	;
    7656:	2a 4d       	mov	@r13,	r10	;

00007658 <.LVL494>:
    7658:	16 4d 02 00 	mov	2(r13),	r6	;

0000765c <.LVL495>:
    765c:	09 4a       	mov	r10,	r9	;
    765e:	59 0f       	rrum	#4,	r9	;
    7660:	59 0f       	rrum	#4,	r9	;

00007662 <.Loc.727.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7662:	4c 4a       	mov.b	r10,	r12	;

00007664 <.LVL497>:
    7664:	1c b3       	bit	#1,	r12	;r3 As==01
    7666:	26 20       	jnz	$+78     	;abs 0x76b4
    7668:	4e 43       	clr.b	r14		;

0000766a <.L403>:
    766a:	6c f3       	and.b	#2,	r12	;r3 As==10
    766c:	47 4c       	mov.b	r12,	r7	;
    766e:	40 18 4d 49 	movx.b	r9,	r13	;
    7672:	40 18 4d 8c 	subx.b	r12,	r13	;
    7676:	4d 8e       	sub.b	r14,	r13	;
    7678:	4f 4d       	mov.b	r13,	r15	;

0000767a <.LVL498>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    767a:	07 93       	cmp	#0,	r7	;r3 As==00
    767c:	1e 20       	jnz	$+62     	;abs 0x76ba

0000767e <.Loc.728.2>:
    767e:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007680 <.L404>:
    7680:	40 18 04 4e 	movx.w	r14,	r4	;
    7684:	e4 08       	adda	r8,	r4	;
    7686:	cc 04       	mova	r4,	r12	;

00007688 <.LBB72>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7688:	0f 5e       	add	r14,	r15	;

0000768a <.L405>:
    768a:	0e 9f       	cmp	r15,	r14	;
    768c:	19 38       	jl	$+52     	;abs 0x76c0

0000768e <.LBE72>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    768e:	cc 04       	mova	r4,	r12	;
    7690:	b0 13 3e 91 	calla	#37182		;0x0913e

00007694 <.LVL501>:
  if (hdr.reply) {
    7694:	07 93       	cmp	#0,	r7	;r3 As==00
    7696:	2b 24       	jz	$+88     	;abs 0x76ee

00007698 <.Loc.748.2>:
    gen_success(hdr);
    7698:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    769c:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000076a0 <.LVL503>:
    76a0:	0a d9       	bis	r9,	r10	;
    76a2:	81 4a 00 00 	mov	r10,	0(r1)	;
    76a6:	81 46 02 00 	mov	r6,	2(r1)	;
    76aa:	cc 01       	mova	r1,	r12	;
    76ac:	b0 13 78 69 	calla	#27000		;0x06978

000076b0 <.LVL504>:
    76b0:	80 00 ee 76 	mova	#30446,	r0	;0x076ee

000076b4 <.L412>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    76b4:	6e 43       	mov.b	#2,	r14	;r3 As==10
    76b6:	80 00 6a 76 	mova	#30314,	r0	;0x0766a

000076ba <.L413>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    76ba:	6e 42       	mov.b	#4,	r14	;r2 As==10
    76bc:	80 00 80 76 	mova	#30336,	r0	;0x07680

000076c0 <.L410>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    76c0:	6b 4c       	mov.b	@r12,	r11	;
    76c2:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    76c6:	ac 00 01 00 	adda	#1,	r12	;
    76ca:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    76ce:	45 9b       	cmp.b	r11,	r5	;
    76d0:	1d 2c       	jc	$+60     	;abs 0x770c

000076d2 <.Loc.732.2>:
      if (hdr.reply) {
    76d2:	07 93       	cmp	#0,	r7	;r3 As==00
    76d4:	15 24       	jz	$+44     	;abs 0x7700

000076d6 <.Loc.734.2>:
        gen_failure(hdr);
    76d6:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    76da:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000076de <.LVL509>:
    76de:	0a d9       	bis	r9,	r10	;
    76e0:	81 4a 00 00 	mov	r10,	0(r1)	;
    76e4:	81 46 02 00 	mov	r6,	2(r1)	;
    76e8:	cc 01       	mova	r1,	r12	;
    76ea:	b0 13 be 6c 	calla	#27838		;0x06cbe

000076ee <.L411>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    76ee:	cc 08       	mova	r8,	r12	;
    76f0:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000076f4 <.LVL511>:
    76f4:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000076f8 <.LVL512>:
}
    76f8:	a1 00 04 00 	adda	#4,	r1	;
    76fc:	64 16       	popm.a	#7,	r10	;20-bit words
    76fe:	10 01       	reta			;

00007700 <.L407>:
        elyErrorSignal(ErrCmdFailure);
    7700:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7704:	b0 13 2a 91 	calla	#37162		;0x0912a

00007708 <.LVL514>:
    7708:	80 00 ee 76 	mova	#30446,	r0	;0x076ee

0000770c <.L406>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    770c:	1e 53       	inc	r14		;
    770e:	80 00 8a 76 	mova	#30346,	r0	;0x0768a

00007712 <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7712:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007714 <.LCFI53>:
    7714:	b1 00 14 00 	suba	#20,	r1	;0x00014

00007718 <.LCFI54>:
    7718:	c8 0c       	mova	r12,	r8	;
    771a:	27 4d       	mov	@r13,	r7	;

0000771c <.LVL518>:
    771c:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7720:	08 00 
    7722:	09 47       	mov	r7,	r9	;
    7724:	59 0f       	rrum	#4,	r9	;
    7726:	59 0f       	rrum	#4,	r9	;

00007728 <.Loc.686.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7728:	4c 47       	mov.b	r7,	r12	;

0000772a <.LVL520>:
    772a:	1c b3       	bit	#1,	r12	;r3 As==01
    772c:	66 20       	jnz	$+206    	;abs 0x77fa
    772e:	4d 43       	clr.b	r13		;

00007730 <.L418>:
    7730:	6c f3       	and.b	#2,	r12	;r3 As==10
    7732:	45 4c       	mov.b	r12,	r5	;
    7734:	81 45 04 00 	mov	r5,	4(r1)	;
    7738:	40 18 4e 49 	movx.b	r9,	r14	;
    773c:	40 18 4e 8c 	subx.b	r12,	r14	;
    7740:	4e 8d       	sub.b	r13,	r14	;
    7742:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    7746:	4f 4e       	mov.b	r14,	r15	;

00007748 <.LVL521>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7748:	05 93       	cmp	#0,	r5	;r3 As==00
    774a:	5a 20       	jnz	$+182    	;abs 0x7800

0000774c <.Loc.687.2>:
    774c:	6a 43       	mov.b	#2,	r10	;r3 As==10

0000774e <.L419>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    774e:	0e 4a       	mov	r10,	r14	;

00007750 <.LVL523>:
    7750:	2e 52       	add	#4,	r14	;r2 As==10

00007752 <.LVL524>:
    7752:	06 4e       	mov	r14,	r6	;
    7754:	46 0e       	rlam.a	#4,	r6	;
    7756:	46 0d       	rram.a	#4,	r6	;
    7758:	cc 06       	mova	r6,	r12	;
    775a:	ec 08       	adda	r8,	r12	;
    775c:	0f 5a       	add	r10,	r15	;

0000775e <.L420>:
    775e:	0e 9f       	cmp	r15,	r14	;
    7760:	52 38       	jl	$+166    	;abs 0x7806
    7762:	04 4a       	mov	r10,	r4	;
    7764:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    7768:	04 8a       	sub	r10,	r4	;
    776a:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

0000776e <.Loc.690.2>:
    776e:	65 42       	mov.b	#4,	r5	;r2 As==10
    7770:	46 43       	clr.b	r6		;
    7772:	04 46       	mov	r6,	r4	;

00007774 <.LBB76>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7774:	40 18 0c 4a 	movx.w	r10,	r12	;
    7778:	ec 08       	adda	r8,	r12	;
    777a:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

0000777e <.L427>:
    777e:	35 53       	add	#-1,	r5	;r3 As==11

00007780 <.LVL526>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7780:	35 93       	cmp	#-1,	r5	;r3 As==11
    7782:	7b 20       	jnz	$+248    	;abs 0x787a

00007784 <.LBE76>:
  interval = (interval / 100) * 100;
    7784:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7788:	4f 43       	clr.b	r15		;
    778a:	0c 46       	mov	r6,	r12	;
    778c:	0d 44       	mov	r4,	r13	;
    778e:	b0 13 ae 9e 	calla	#40622		;0x09eae
    7792:	05 4c       	mov	r12,	r5	;

00007794 <.LVL528>:
    7794:	06 4d       	mov	r13,	r6	;

00007796 <.LVL529>:
    7796:	0c 5c       	rla	r12		;
    7798:	0d 6d       	rlc	r13		;
    779a:	0e 4c       	mov	r12,	r14	;
    779c:	0e 55       	add	r5,	r14	;
    779e:	04 4d       	mov	r13,	r4	;
    77a0:	04 66       	addc	r6,	r4	;
    77a2:	0c 4e       	mov	r14,	r12	;
    77a4:	0d 44       	mov	r4,	r13	;
    77a6:	71 0e 00 00 	mova	r14,	0(r1)	;
    77aa:	b0 13 12 9f 	calla	#40722		;0x09f12
    77ae:	0e 01       	mova	@r1,	r14	;
    77b0:	0e 5c       	add	r12,	r14	;
    77b2:	0d 64       	addc	r4,	r13	;

000077b4 <.Loc.715.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    77b4:	40 18 0a 4a 	movx.w	r10,	r10	;
    77b8:	aa 00 04 00 	adda	#4,	r10	;

000077bc <.LVL531>:
    77bc:	0e 55       	add	r5,	r14	;
    77be:	0f 4d       	mov	r13,	r15	;
    77c0:	0f 66       	addc	r6,	r15	;
    77c2:	5d 41 07 00 	mov.b	7(r1),	r13	;
    77c6:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    77ca:	cc 08       	mova	r8,	r12	;
    77cc:	ec 0a       	adda	r10,	r12	;
    77ce:	b0 13 3c 91 	calla	#37180		;0x0913c

000077d2 <.LVL532>:
  if (hdr.reply) {
    77d2:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    77d6:	3f 24       	jz	$+128    	;abs 0x7856

000077d8 <.Loc.719.2>:
    gen_success(hdr);
    77d8:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    77dc:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

000077e0 <.LVL534>:
    77e0:	07 d9       	bis	r9,	r7	;
    77e2:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    77e6:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    77ea:	12 00 
    77ec:	cc 01       	mova	r1,	r12	;
    77ee:	ac 00 10 00 	adda	#16,	r12	;0x00010
    77f2:	b0 13 78 69 	calla	#27000		;0x06978

000077f6 <.LVL535>:
    77f6:	80 00 56 78 	mova	#30806,	r0	;0x07856

000077fa <.L430>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    77fa:	6d 43       	mov.b	#2,	r13	;r3 As==10
    77fc:	80 00 30 77 	mova	#30512,	r0	;0x07730

00007800 <.L431>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7800:	6a 42       	mov.b	#4,	r10	;r2 As==10
    7802:	80 00 4e 77 	mova	#30542,	r0	;0x0774e

00007806 <.L426>:
    if ((buffer[i] < 0x40) || 
    7806:	6d 4c       	mov.b	@r12,	r13	;
    7808:	46 4d       	mov.b	r13,	r6	;
    780a:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    780e:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    7812:	45 96       	cmp.b	r6,	r5	;
    7814:	0e 28       	jnc	$+30     	;abs 0x7832

00007816 <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7816:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

0000781a <.Loc.691.2>:
    if ((buffer[i] < 0x40) || 
    781a:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    781e:	45 96       	cmp.b	r6,	r5	;
    7820:	08 2c       	jc	$+18     	;abs 0x7832
    7822:	ac 00 01 00 	adda	#1,	r12	;

00007826 <.Loc.693.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7826:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

0000782a <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    782a:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    782e:	46 9d       	cmp.b	r13,	r6	;
    7830:	21 28       	jnc	$+68     	;abs 0x7874

00007832 <.L421>:
      if (hdr.reply) {
    7832:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    7836:	18 24       	jz	$+50     	;abs 0x7868

00007838 <.Loc.697.2>:
        gen_failure(hdr);
    7838:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    783c:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00007840 <.LVL540>:
    7840:	07 d9       	bis	r9,	r7	;
    7842:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    7846:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    784a:	12 00 
    784c:	cc 01       	mova	r1,	r12	;
    784e:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7852:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007856 <.L429>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7856:	cc 08       	mova	r8,	r12	;
    7858:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000785c <.LVL542>:
    785c:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007860 <.LVL543>:
}
    7860:	a1 00 14 00 	adda	#20,	r1	;0x00014
    7864:	64 16       	popm.a	#7,	r10	;20-bit words
    7866:	10 01       	reta			;

00007868 <.L423>:
        elyErrorSignal(ErrCmdFailure);
    7868:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    786c:	b0 13 2a 91 	calla	#37162		;0x0912a

00007870 <.LVL545>:
    7870:	80 00 56 78 	mova	#30806,	r0	;0x07856

00007874 <.L422>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7874:	1e 53       	inc	r14		;
    7876:	80 00 5e 77 	mova	#30558,	r0	;0x0775e

0000787a <.L428>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    787a:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    787e:	0e 55       	add	r5,	r14	;
    7880:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7884:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    7888:	6c 4f       	mov.b	@r15,	r12	;
    788a:	0d 43       	clr	r13		;
    788c:	0f 43       	clr	r15		;
    788e:	b0 13 2e 9f 	calla	#40750		;0x09f2e
    7892:	06 dc       	bis	r12,	r6	;

00007894 <.LVL550>:
    7894:	04 dd       	bis	r13,	r4	;

00007896 <.LVL551>:
    7896:	80 00 7e 77 	mova	#30590,	r0	;0x0777e

0000789a <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    789a:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000789c <.LCFI55>:
    789c:	b1 00 04 00 	suba	#4,	r1	;

000078a0 <.LCFI56>:
    78a0:	28 4d       	mov	@r13,	r8	;

000078a2 <.LVL553>:
    78a2:	1a 4d 02 00 	mov	2(r13),	r10	;

000078a6 <.LVL554>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    78a6:	47 48       	mov.b	r8,	r7	;
    78a8:	67 f3       	and.b	#2,	r7	;r3 As==10
    78aa:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    78ae:	07 93       	cmp	#0,	r7	;r3 As==00
    78b0:	1c 20       	jnz	$+58     	;abs 0x78ea
    78b2:	6e 43       	mov.b	#2,	r14	;r3 As==10

000078b4 <.L436>:
  uint8_t bank = buffer[hdr_ext];
    78b4:	40 18 0e 4e 	movx.w	r14,	r14	;
    78b8:	ee 0c       	adda	r12,	r14	;

000078ba <.LVL556>:
    78ba:	69 4e       	mov.b	@r14,	r9	;

000078bc <.LVL557>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    78bc:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000078c0 <.LVL558>:
    78c0:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000078c4 <.LVL559>:
  if (bank == 0 || bank > 4) {
    78c4:	4c 49       	mov.b	r9,	r12	;
    78c6:	7c 53       	add.b	#-1,	r12	;r3 As==11
    78c8:	7d 40 03 00 	mov.b	#3,	r13	;
    78cc:	4d 9c       	cmp.b	r12,	r13	;
    78ce:	16 2c       	jc	$+46     	;abs 0x78fc

000078d0 <.Loc.660.2>:
    if (hdr.reply) {
    78d0:	07 93       	cmp	#0,	r7	;r3 As==00
    78d2:	0e 24       	jz	$+30     	;abs 0x78f0

000078d4 <.Loc.662.2>:
      gen_failure(hdr);
    78d4:	81 48 00 00 	mov	r8,	0(r1)	;
    78d8:	81 4a 02 00 	mov	r10,	2(r1)	;
    78dc:	cc 01       	mova	r1,	r12	;
    78de:	b0 13 be 6c 	calla	#27838		;0x06cbe

000078e2 <.L435>:
}
    78e2:	a1 00 04 00 	adda	#4,	r1	;
    78e6:	37 16       	popm.a	#4,	r10	;20-bit words
    78e8:	10 01       	reta			;

000078ea <.L440>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    78ea:	6e 42       	mov.b	#4,	r14	;r2 As==10
    78ec:	80 00 b4 78 	mova	#30900,	r0	;0x078b4

000078f0 <.L438>:
      elyErrorSignal(ErrCmdFailure);
    78f0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    78f4:	b0 13 2a 91 	calla	#37162		;0x0912a

000078f8 <.LVL565>:
    78f8:	80 00 e2 78 	mova	#30946,	r0	;0x078e2

000078fc <.L437>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    78fc:	2a 01 c6 05 	mova	&67014,	r10	;0x105c6

00007900 <.LVL566>:
    7900:	88 00 92 90 	mova	#37010,	r8	;0x09092
    7904:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    7908:	4e 43       	clr.b	r14		;
    790a:	cd 0a       	mova	r10,	r13	;
    790c:	4c 49       	mov.b	r9,	r12	;
    790e:	48 13       	calla	r8		;

00007910 <.LVL567>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    7910:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    7914:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    7918:	cd 0a       	mova	r10,	r13	;
    791a:	ad 00 80 00 	adda	#128,	r13	;0x00080
    791e:	4c 49       	mov.b	r9,	r12	;
    7920:	48 13       	calla	r8		;

00007922 <.LVL568>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    7922:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    7926:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    792a:	cd 0a       	mova	r10,	r13	;
    792c:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    7930:	4c 49       	mov.b	r9,	r12	;
    7932:	48 13       	calla	r8		;

00007934 <.LVL569>:
  bank0w[RegActiveBank] = bank;
    7934:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

00007938 <.Loc.678.2>:
  active_buffer = NULL; /* have to null before reset */
    7938:	00 18 c2 43 	movx.a	#0,	&0xfc868;r3 As==00
    793c:	68 c8 

0000793e <.Loc.682.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    793e:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    7942:	48 a5 20 01 
    7946:	80 00 e2 78 	mova	#30946,	r0	;0x078e2

0000794a <set_u32>:
    const uint32_t max, const uint32_t min) {
    794a:	b1 00 02 00 	suba	#2,	r1	;
    794e:	00 18 d1 41 	movx.a	2(r1),	0(r1)	;
    7952:	02 00 00 00 

00007956 <.LCFI57>:
    7956:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007958 <.LCFI58>:
    7958:	b1 00 14 00 	suba	#20,	r1	;0x00014

0000795c <.LCFI59>:
    795c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7960:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    7964:	2a 4e       	mov	@r14,	r10	;

00007966 <.LVL571>:
    7966:	1c 4e 02 00 	mov	2(r14),	r12	;

0000796a <.LVL572>:
    796a:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034
    796e:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c
    7972:	1b 41 36 00 	mov	54(r1),	r11	;0x00036
    7976:	91 41 38 00 	mov	56(r1),	14(r1)	;0x00038, 0x000e
    797a:	0e 00 
    797c:	15 41 3a 00 	mov	58(r1),	r5	;0x0003a

00007980 <.Loc.130.2>:
static void set_u32(const uint8_t addr, const uint8_t * buffer, elysium_cmd_hdr_t hdr,
    7980:	81 4c 08 00 	mov	r12,	8(r1)	;

00007984 <.Loc.132.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7984:	49 4a       	mov.b	r10,	r9	;
    7986:	69 f3       	and.b	#2,	r9	;r3 As==10
    7988:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    798c:	09 93       	cmp	#0,	r9	;r3 As==00
    798e:	44 20       	jnz	$+138    	;abs 0x7a18
    7990:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007992 <.L442>:
    7992:	40 18 04 4c 	movx.w	r12,	r4	;
    7996:	e4 0d       	adda	r13,	r4	;
    7998:	71 04 04 00 	mova	r4,	4(r1)	;

0000799c <.Loc.132.2>:
    799c:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

000079a0 <.Loc.133.2>:
  uint32_t val = 0;
    79a0:	48 43       	clr.b	r8		;
    79a2:	07 48       	mov	r8,	r7	;

000079a4 <.L443>:
    val |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    79a4:	3e 01 04 00 	mova	4(r1),	r14	;
    79a8:	6c 4e       	mov.b	@r14,	r12	;
    79aa:	0d 43       	clr	r13		;
    79ac:	0e 46       	mov	r6,	r14	;
    79ae:	0f 43       	clr	r15		;
    79b0:	71 0b 00 00 	mova	r11,	0(r1)	;
    79b4:	b0 13 2e 9f 	calla	#40750		;0x09f2e
    79b8:	0c d8       	bis	r8,	r12	;
    79ba:	0d d7       	bis	r7,	r13	;
    79bc:	08 4c       	mov	r12,	r8	;

000079be <.LVL576>:
    79be:	07 4d       	mov	r13,	r7	;

000079c0 <.LVL577>:
    79c0:	00 18 d1 53 	incx.a	4(r1)		;
    79c4:	04 00 
    79c6:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

000079ca <.Loc.136.2>:
  for (int i = 0; i < 4; i++) {
    79ca:	0b 01       	mova	@r1,	r11	;
    79cc:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    79d0:	e9 23       	jnz	$-44     	;abs 0x79a4

000079d2 <.LBE80>:
  if (val > max || 
    79d2:	0b 9d       	cmp	r13,	r11	;
    79d4:	0c 28       	jnc	$+26     	;abs 0x79ee
    79d6:	0d 9b       	cmp	r11,	r13	;
    79d8:	03 20       	jnz	$+8      	;abs 0x79e0
    79da:	81 9c 0c 00 	cmp	r12,	12(r1)	; 0x000c
    79de:	07 28       	jnc	$+16     	;abs 0x79ee

000079e0 <.L451>:
    79e0:	0d 95       	cmp	r5,	r13	;
    79e2:	05 28       	jnc	$+12     	;abs 0x79ee
    79e4:	05 9d       	cmp	r13,	r5	;
    79e6:	21 20       	jnz	$+68     	;abs 0x7a2a
    79e8:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    79ec:	1e 2c       	jc	$+62     	;abs 0x7a2a

000079ee <.L444>:
    if (hdr.reply) {
    79ee:	09 93       	cmp	#0,	r9	;r3 As==00
    79f0:	16 24       	jz	$+46     	;abs 0x7a1e

000079f2 <.Loc.144.2>:
      gen_failure(hdr);
    79f2:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    79f6:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    79fa:	12 00 
    79fc:	cc 01       	mova	r1,	r12	;
    79fe:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7a02:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007a06 <.L441>:
}
    7a06:	a1 00 14 00 	adda	#20,	r1	;0x00014
    7a0a:	64 16       	popm.a	#7,	r10	;20-bit words
    7a0c:	00 18 e1 41 	movx.a	@r1,	2(r1)	;
    7a10:	02 00 
    7a12:	a1 00 02 00 	adda	#2,	r1	;
    7a16:	10 01       	reta			;

00007a18 <.L450>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7a18:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007a1a <.LVL581>:
    7a1a:	80 00 92 79 	mova	#31122,	r0	;0x07992

00007a1e <.L448>:
      elyErrorSignal(ErrCmdFailure);
    7a1e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7a22:	b0 13 2a 91 	calla	#37162		;0x0912a

00007a26 <.LVL583>:
    7a26:	80 00 06 7a 	mova	#31238,	r0	;0x07a06

00007a2a <.L446>:
  bank0w[addr+3] = buffer[hdr_ext];
    7a2a:	40 18 1c 41 	movx.w	10(r1),	r12	;0x0000a
    7a2e:	0a 00 
    7a30:	80 18 5c 52 	addx.a	&0x105c6,r12	;
    7a34:	c6 05 
    7a36:	ec 44 03 00 	mov.b	@r4,	3(r12)	;

00007a3a <.Loc.153.2>:
  bank0w[addr+2] = buffer[hdr_ext+1];
    7a3a:	dc 44 01 00 	mov.b	1(r4),	2(r12)	;
    7a3e:	02 00 

00007a40 <.Loc.154.2>:
  bank0w[addr+1] = buffer[hdr_ext+2];
    7a40:	dc 44 02 00 	mov.b	2(r4),	1(r12)	;
    7a44:	01 00 

00007a46 <.Loc.155.2>:
  bank0w[addr] = buffer[hdr_ext+3];
    7a46:	dc 44 03 00 	mov.b	3(r4),	0(r12)	;
    7a4a:	00 00 

00007a4c <.Loc.157.2>:
  if (hdr.reply) {
    7a4c:	09 93       	cmp	#0,	r9	;r3 As==00
    7a4e:	db 27       	jz	$-72     	;abs 0x7a06

00007a50 <.Loc.159.2>:
    gen_success(hdr);
    7a50:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    7a54:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7a58:	12 00 
    7a5a:	cc 01       	mova	r1,	r12	;
    7a5c:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7a60:	b0 13 78 69 	calla	#27000		;0x06978

00007a64 <.LVL584>:
    7a64:	80 00 06 7a 	mova	#31238,	r0	;0x07a06

00007a68 <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a68:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007a6a <.LCFI60>:
    7a6a:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007a6e <.LCFI61>:
    7a6e:	ca 0c       	mova	r12,	r10	;

00007a70 <.Loc.643.2>:
  set_u32(RegUARTBaudLsb, buffer, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    7a70:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7a74:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7a78:	08 00 
    7a7a:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    7a7e:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7a82:	b1 40 0f 00 	mov	#15,	0(r1)	;#0x000f
    7a86:	00 00 
    7a88:	3f 40 40 42 	mov	#16960,	r15	;#0x4240
    7a8c:	ce 01       	mova	r1,	r14	;
    7a8e:	ae 00 06 00 	adda	#6,	r14	;
    7a92:	cd 0c       	mova	r12,	r13	;
    7a94:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00007a98 <.LVL586>:
    7a98:	b0 13 4a 79 	calla	#31050		;0x0794a

00007a9c <.LVL587>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7a9c:	cc 0a       	mova	r10,	r12	;
    7a9e:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007aa2 <.LVL588>:
    7aa2:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007aa6 <.LVL589>:
  elyUARTCfgMarkDirty();
    7aa6:	b0 13 4a 60 	calla	#24650		;0x0604a

00007aaa <.LVL590>:
}
    7aaa:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7aae:	0a 16       	popm.a	#1,	r10	;20-bit words
    7ab0:	10 01       	reta			;

00007ab2 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7ab2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007ab4 <.LCFI62>:
    7ab4:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007ab8 <.LCFI63>:
    7ab8:	ca 0c       	mova	r12,	r10	;

00007aba <.Loc.565.2>:
  set_u32(RegRXDevLsb, buffer, hdr, RX_DEV_MAX, RX_DEV_MIN);
    7aba:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7abe:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7ac2:	08 00 
    7ac4:	b1 40 e8 80 	mov	#-32536,2(r1)	;#0x80e8
    7ac8:	02 00 
    7aca:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7ace:	b1 40 03 00 	mov	#3,	0(r1)	;
    7ad2:	00 00 
    7ad4:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7ad8:	ce 01       	mova	r1,	r14	;
    7ada:	ae 00 06 00 	adda	#6,	r14	;
    7ade:	cd 0c       	mova	r12,	r13	;
    7ae0:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c

00007ae4 <.LVL592>:
    7ae4:	b0 13 4a 79 	calla	#31050		;0x0794a

00007ae8 <.LVL593>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7ae8:	cc 0a       	mova	r10,	r12	;
    7aea:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007aee <.LVL594>:
    7aee:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007af2 <.LVL595>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    7af2:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    7af6:	4d 43       	clr.b	r13		;
    7af8:	b0 13 74 91 	calla	#37236		;0x09174

00007afc <.LVL596>:
  elyEventSignal(EvtRXDevChange);
    7afc:	7c 40 ca ff 	mov.b	#-54,	r12	;#0xffca
    7b00:	b0 13 30 91 	calla	#37168		;0x09130

00007b04 <.LVL597>:
}
    7b04:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7b08:	0a 16       	popm.a	#1,	r10	;20-bit words
    7b0a:	10 01       	reta			;

00007b0c <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7b0c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007b0e <.LCFI64>:
    7b0e:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007b12 <.LCFI65>:
    7b12:	ca 0c       	mova	r12,	r10	;

00007b14 <.Loc.543.2>:
  set_u32(RegTXDevLsb, buffer, hdr, TX_DEV_MAX, TX_DEV_MIN);
    7b14:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7b18:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7b1c:	08 00 
    7b1e:	b1 40 58 02 	mov	#600,	2(r1)	;#0x0258
    7b22:	02 00 
    7b24:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7b28:	b1 40 03 00 	mov	#3,	0(r1)	;
    7b2c:	00 00 
    7b2e:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7b32:	ce 01       	mova	r1,	r14	;
    7b34:	ae 00 06 00 	adda	#6,	r14	;
    7b38:	cd 0c       	mova	r12,	r13	;
    7b3a:	7c 42       	mov.b	#8,	r12	;r2 As==11

00007b3c <.LVL599>:
    7b3c:	b0 13 4a 79 	calla	#31050		;0x0794a

00007b40 <.LVL600>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7b40:	cc 0a       	mova	r10,	r12	;
    7b42:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007b46 <.LVL601>:
    7b46:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007b4a <.LVL602>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    7b4a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7b4e:	4d 43       	clr.b	r13		;
    7b50:	b0 13 74 91 	calla	#37236		;0x09174

00007b54 <.LVL603>:
  elyEventSignal(EvtTXDevChange);
    7b54:	7c 40 c9 ff 	mov.b	#-55,	r12	;#0xffc9
    7b58:	b0 13 30 91 	calla	#37168		;0x09130

00007b5c <.LVL604>:
}
    7b5c:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7b60:	0a 16       	popm.a	#1,	r10	;20-bit words
    7b62:	10 01       	reta			;

00007b64 <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7b64:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007b66 <.LCFI66>:
    7b66:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007b6a <.LCFI67>:
    7b6a:	ca 0c       	mova	r12,	r10	;

00007b6c <.Loc.521.2>:
  set_u32(RegRXBRLsb, buffer, hdr, RX_BR_MAX, RX_BR_MIN);
    7b6c:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7b70:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7b74:	08 00 
    7b76:	b1 40 0c 03 	mov	#780,	2(r1)	;#0x030c
    7b7a:	02 00 
    7b7c:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7b80:	a1 43 00 00 	mov	#2,	0(r1)	;r3 As==10
    7b84:	3f 40 f0 49 	mov	#18928,	r15	;#0x49f0
    7b88:	ce 01       	mova	r1,	r14	;
    7b8a:	ae 00 06 00 	adda	#6,	r14	;
    7b8e:	cd 0c       	mova	r12,	r13	;
    7b90:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c

00007b94 <.LVL606>:
    7b94:	b0 13 4a 79 	calla	#31050		;0x0794a

00007b98 <.LVL607>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7b98:	cc 0a       	mova	r10,	r12	;
    7b9a:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007b9e <.LVL608>:
    7b9e:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007ba2 <.LVL609>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    7ba2:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7ba4:	4d 43       	clr.b	r13		;
    7ba6:	b0 13 74 91 	calla	#37236		;0x09174

00007baa <.LVL610>:
  elyEventSignal(EvtRXBRChange);
    7baa:	7c 40 c8 ff 	mov.b	#-56,	r12	;#0xffc8
    7bae:	b0 13 30 91 	calla	#37168		;0x09130

00007bb2 <.LVL611>:
}
    7bb2:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7bb6:	0a 16       	popm.a	#1,	r10	;20-bit words
    7bb8:	10 01       	reta			;

00007bba <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7bba:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007bbc <.LCFI68>:
    7bbc:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007bc0 <.LCFI69>:
    7bc0:	ca 0c       	mova	r12,	r10	;

00007bc2 <.Loc.499.2>:
  set_u32(RegTXBRLsb, buffer, hdr, TX_BR_MAX, TX_BR_MIN);
    7bc2:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7bc6:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7bca:	08 00 
    7bcc:	b1 40 b0 04 	mov	#1200,	2(r1)	;#0x04b0
    7bd0:	02 00 
    7bd2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7bd6:	a1 42 00 00 	mov	#4,	0(r1)	;r2 As==10
    7bda:	3f 40 e0 93 	mov	#-27680,r15	;#0x93e0
    7bde:	ce 01       	mova	r1,	r14	;
    7be0:	ae 00 06 00 	adda	#6,	r14	;
    7be4:	cd 0c       	mova	r12,	r13	;
    7be6:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018

00007bea <.LVL613>:
    7bea:	b0 13 4a 79 	calla	#31050		;0x0794a

00007bee <.LVL614>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7bee:	cc 0a       	mova	r10,	r12	;
    7bf0:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007bf4 <.LVL615>:
    7bf4:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007bf8 <.LVL616>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    7bf8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7bfa:	4d 43       	clr.b	r13		;
    7bfc:	b0 13 74 91 	calla	#37236		;0x09174

00007c00 <.LVL617>:
  elyEventSignal(EvtTXBRChange);
    7c00:	7c 40 c7 ff 	mov.b	#-57,	r12	;#0xffc7
    7c04:	b0 13 30 91 	calla	#37168		;0x09130

00007c08 <.LVL618>:
}
    7c08:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7c0c:	0a 16       	popm.a	#1,	r10	;20-bit words
    7c0e:	10 01       	reta			;

00007c10 <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7c10:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007c12 <.LCFI70>:
    7c12:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007c16 <.LCFI71>:
    7c16:	ca 0c       	mova	r12,	r10	;

00007c18 <.Loc.477.2>:
  set_u32(RegRXFreqLsb, buffer, hdr, RX_BAND_MAX, RX_BAND_MIN);
    7c18:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7c1c:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7c20:	08 00 
    7c22:	b1 40 40 44 	mov	#17472,	2(r1)	;#0x4440
    7c26:	02 00 
    7c28:	b1 40 3d 1b 	mov	#6973,	4(r1)	;#0x1b3d
    7c2c:	04 00 
    7c2e:	b1 40 12 1c 	mov	#7186,	0(r1)	;#0x1c12
    7c32:	00 00 
    7c34:	3f 40 c0 e3 	mov	#-7232,	r15	;#0xe3c0
    7c38:	ce 01       	mova	r1,	r14	;
    7c3a:	ae 00 06 00 	adda	#6,	r14	;
    7c3e:	cd 0c       	mova	r12,	r13	;
    7c40:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007c42 <.LVL620>:
    7c42:	b0 13 4a 79 	calla	#31050		;0x0794a

00007c46 <.LVL621>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7c46:	cc 0a       	mova	r10,	r12	;
    7c48:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007c4c <.LVL622>:
    7c4c:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007c50 <.LVL623>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    7c50:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7c52:	4d 43       	clr.b	r13		;
    7c54:	b0 13 74 91 	calla	#37236		;0x09174

00007c58 <.LVL624>:
  elyEventSignal(EvtRXFreqChange);
    7c58:	7c 40 c6 ff 	mov.b	#-58,	r12	;#0xffc6
    7c5c:	b0 13 30 91 	calla	#37168		;0x09130

00007c60 <.LVL625>:
}
    7c60:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7c64:	0a 16       	popm.a	#1,	r10	;20-bit words
    7c66:	10 01       	reta			;

00007c68 <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7c68:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007c6a <.LCFI72>:
    7c6a:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007c6e <.LCFI73>:
    7c6e:	ca 0c       	mova	r12,	r10	;

00007c70 <.Loc.455.2>:
  set_u32(RegTXFreqLsb, buffer, hdr, TX_BAND_MAX, TX_BAND_MIN);
    7c70:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7c74:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7c78:	08 00 
    7c7a:	b1 40 40 da 	mov	#-9664,	2(r1)	;#0xda40
    7c7e:	02 00 
    7c80:	b1 40 8e 33 	mov	#13198,	4(r1)	;#0x338e
    7c84:	04 00 
    7c86:	b1 40 ec 38 	mov	#14572,	0(r1)	;#0x38ec
    7c8a:	00 00 
    7c8c:	3f 40 c0 24 	mov	#9408,	r15	;#0x24c0
    7c90:	ce 01       	mova	r1,	r14	;
    7c92:	ae 00 06 00 	adda	#6,	r14	;
    7c96:	cd 0c       	mova	r12,	r13	;
    7c98:	4c 43       	clr.b	r12		;

00007c9a <.LVL627>:
    7c9a:	b0 13 4a 79 	calla	#31050		;0x0794a

00007c9e <.LVL628>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7c9e:	cc 0a       	mova	r10,	r12	;
    7ca0:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007ca4 <.LVL629>:
    7ca4:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007ca8 <.LVL630>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    7ca8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7caa:	4d 43       	clr.b	r13		;
    7cac:	b0 13 74 91 	calla	#37236		;0x09174

00007cb0 <.LVL631>:
  elyEventSignal(EvtTXFreqChange);
    7cb0:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    7cb4:	b0 13 30 91 	calla	#37168		;0x09130

00007cb8 <.LVL632>:
}
    7cb8:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7cbc:	0a 16       	popm.a	#1,	r10	;20-bit words
    7cbe:	10 01       	reta			;

00007cc0 <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7cc0:	5a 14       	pushm.a	#6,	r10	;20-bit words

00007cc2 <.LCFI74>:
    7cc2:	b1 00 04 00 	suba	#4,	r1	;

00007cc6 <.LCFI75>:
    7cc6:	ca 0c       	mova	r12,	r10	;
    7cc8:	29 4d       	mov	@r13,	r9	;

00007cca <.LVL634>:
    7cca:	15 4d 02 00 	mov	2(r13),	r5	;

00007cce <.LVL635>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7cce:	47 49       	mov.b	r9,	r7	;
    7cd0:	67 f3       	and.b	#2,	r7	;r3 As==10
    7cd2:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    7cd6:	07 93       	cmp	#0,	r7	;r3 As==00
    7cd8:	1d 20       	jnz	$+60     	;abs 0x7d14
    7cda:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007cdc <.L464>:
  if (buffer[hdr_ext] > TX_POW_MAX) {
    7cdc:	40 18 0c 4c 	movx.w	r12,	r12	;
    7ce0:	ec 0a       	adda	r10,	r12	;

00007ce2 <.LVL637>:
    7ce2:	6d 4c       	mov.b	@r12,	r13	;
    7ce4:	88 00 fa 9d 	mova	#40442,	r8	;0x09dfa
    7ce8:	86 00 3e 9b 	mova	#39742,	r6	;0x09b3e
    7cec:	7c 40 82 ff 	mov.b	#-126,	r12	;#0xff82
    7cf0:	4c 9d       	cmp.b	r13,	r12	;
    7cf2:	19 2c       	jc	$+52     	;abs 0x7d26

00007cf4 <.Loc.608.2>:
    if (hdr.reply) {
    7cf4:	07 93       	cmp	#0,	r7	;r3 As==00
    7cf6:	11 24       	jz	$+36     	;abs 0x7d1a

00007cf8 <.Loc.610.2>:
      gen_failure(hdr);
    7cf8:	81 49 00 00 	mov	r9,	0(r1)	;
    7cfc:	81 45 02 00 	mov	r5,	2(r1)	;
    7d00:	cc 01       	mova	r1,	r12	;
    7d02:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007d06 <.L469>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7d06:	cc 0a       	mova	r10,	r12	;
    7d08:	48 13       	calla	r8		;

00007d0a <.LVL641>:
    7d0a:	46 13       	calla	r6		;

00007d0c <.LBE83>:
}
    7d0c:	a1 00 04 00 	adda	#4,	r1	;
    7d10:	55 16       	popm.a	#6,	r10	;20-bit words
    7d12:	10 01       	reta			;

00007d14 <.L470>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7d14:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7d16:	80 00 dc 7c 	mova	#31964,	r0	;0x07cdc

00007d1a <.L466>:
      elyErrorSignal(ErrCmdFailure);
    7d1a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7d1e:	b0 13 2a 91 	calla	#37162		;0x0912a

00007d22 <.LVL644>:
    7d22:	80 00 06 7d 	mova	#32006,	r0	;0x07d06

00007d26 <.L465>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    7d26:	2c 01 c6 05 	mova	&67014,	r12	;0x105c6
    7d2a:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

00007d2e <.Loc.622.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    7d2e:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    7d32:	4d 43       	clr.b	r13		;
    7d34:	b0 13 74 91 	calla	#37236		;0x09174

00007d38 <.LVL645>:
  if (hdr.reply) {
    7d38:	07 93       	cmp	#0,	r7	;r3 As==00
    7d3a:	e5 27       	jz	$-52     	;abs 0x7d06

00007d3c <.Loc.626.2>:
    gen_success(hdr);
    7d3c:	81 49 00 00 	mov	r9,	0(r1)	;
    7d40:	81 45 02 00 	mov	r5,	2(r1)	;
    7d44:	cc 01       	mova	r1,	r12	;
    7d46:	b0 13 78 69 	calla	#27000		;0x06978

00007d4a <.LVL647>:
    7d4a:	80 00 06 7d 	mova	#32006,	r0	;0x07d06

00007d4e <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7d4e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007d50 <.LCFI76>:
    7d50:	b1 00 04 00 	suba	#4,	r1	;

00007d54 <.LCFI77>:
    7d54:	2a 4d       	mov	@r13,	r10	;

00007d56 <.LVL649>:
    7d56:	18 4d 02 00 	mov	2(r13),	r8	;

00007d5a <.LVL650>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    7d5a:	49 4a       	mov.b	r10,	r9	;
    7d5c:	69 f3       	and.b	#2,	r9	;r3 As==10
    7d5e:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7d62:	09 93       	cmp	#0,	r9	;r3 As==00
    7d64:	17 20       	jnz	$+48     	;abs 0x7d94
    7d66:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007d68 <.L475>:
    7d68:	ee 0c       	adda	r12,	r14	;
    7d6a:	67 4e       	mov.b	@r14,	r7	;

00007d6c <.LVL651>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7d6c:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007d70 <.LVL652>:
    7d70:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007d74 <.LVL653>:
  if (arg > 1) {
    7d74:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d76:	4c 97       	cmp.b	r7,	r12	;
    7d78:	16 2c       	jc	$+46     	;abs 0x7da6

00007d7a <.Loc.201.2>:
    if (hdr.reply) {
    7d7a:	09 93       	cmp	#0,	r9	;r3 As==00
    7d7c:	0e 24       	jz	$+30     	;abs 0x7d9a

00007d7e <.Loc.203.2>:
      gen_failure(hdr);
    7d7e:	81 4a 00 00 	mov	r10,	0(r1)	;
    7d82:	81 48 02 00 	mov	r8,	2(r1)	;
    7d86:	cc 01       	mova	r1,	r12	;
    7d88:	b0 13 be 6c 	calla	#27838		;0x06cbe

00007d8c <.L474>:
}
    7d8c:	a1 00 04 00 	adda	#4,	r1	;
    7d90:	37 16       	popm.a	#4,	r10	;20-bit words
    7d92:	10 01       	reta			;

00007d94 <.L480>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    7d94:	6e 42       	mov.b	#4,	r14	;r2 As==10
    7d96:	80 00 68 7d 	mova	#32104,	r0	;0x07d68

00007d9a <.L477>:
      elyErrorSignal(ErrCmdFailure);
    7d9a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7d9e:	b0 13 2a 91 	calla	#37162		;0x0912a

00007da2 <.LVL659>:
    7da2:	80 00 8c 7d 	mova	#32140,	r0	;0x07d8c

00007da6 <.L476>:
  if (bank0p[RegGPOState] != arg) {
    7da6:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    7daa:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    7dae:	16 24       	jz	$+46     	;abs 0x7ddc

00007db0 <.Loc.214.2>:
    palWriteLine(LINE_GPO, arg);
    7db0:	0c 47       	mov	r7,	r12	;
    7db2:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    7db6:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    7dba:	40 18 1d 42 	movx.w	&0x00222,r13	;
    7dbe:	22 02 
    7dc0:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    7dc4:	0c dd       	bis	r13,	r12	;
    7dc6:	40 18 82 4c 	movx.w	r12,	&0x00222;
    7dca:	22 02 

00007dcc <.Loc.216.2>:
    elyEventSignal(EvtGPOChange);
    7dcc:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    7dd0:	b0 13 30 91 	calla	#37168		;0x09130

00007dd4 <.LVL660>:
    bank0w[RegGPOState] = arg;
    7dd4:	2c 01 c6 05 	mova	&67014,	r12	;0x105c6
    7dd8:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

00007ddc <.L479>:
  if (hdr.reply) {
    7ddc:	09 93       	cmp	#0,	r9	;r3 As==00
    7dde:	d6 27       	jz	$-82     	;abs 0x7d8c

00007de0 <.Loc.222.2>:
    gen_success(hdr);
    7de0:	81 4a 00 00 	mov	r10,	0(r1)	;
    7de4:	81 48 02 00 	mov	r8,	2(r1)	;
    7de8:	cc 01       	mova	r1,	r12	;
    7dea:	b0 13 78 69 	calla	#27000		;0x06978

00007dee <.LVL662>:
    7dee:	80 00 8c 7d 	mova	#32140,	r0	;0x07d8c

00007df2 <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7df2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007df4 <.LCFI78>:
    7df4:	c8 0c       	mova	r12,	r8	;
    7df6:	24 4d       	mov	@r13,	r4	;

00007df8 <.LVL664>:
    7df8:	19 4d 02 00 	mov	2(r13),	r9	;

00007dfc <.LVL665>:
    7dfc:	07 44       	mov	r4,	r7	;
    7dfe:	57 07       	rrum	#2,	r7	;
    7e00:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    7e04:	45 47       	mov.b	r7,	r5	;

00007e06 <.Loc.1153.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7e06:	8a 00 fa 9d 	mova	#40442,	r10	;0x09dfa
    7e0a:	4a 13       	calla	r10		;

00007e0c <.LVL667>:
    7e0c:	86 00 3e 9b 	mova	#39742,	r6	;0x09b3e
    7e10:	46 13       	calla	r6		;

00007e12 <.LVL668>:
  if (hdr.reply) {
    7e12:	41 18 05 55 	rpt #2 { rlax.w	r5		;
    7e16:	74 f0 03 00 	and.b	#3,	r4	;

00007e1a <.LVL669>:
    7e1a:	05 d4       	bis	r4,	r5	;
    7e1c:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    7e20:	09 24       	jz	$+20     	;abs 0x7e34

00007e22 <.LBB85>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7e22:	b0 13 a2 62 	calla	#25250		;0x062a2

00007e26 <.LVL670>:
    7e26:	c4 0c       	mova	r12,	r4	;

00007e28 <.LVL671>:
    if (reply_buff == NULL) {
    7e28:	9c 00 00 00 	cmpa	#0,	r12	;
    7e2c:	05 20       	jnz	$+12     	;abs 0x7e38

00007e2e <.Loc.1159.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7e2e:	cc 08       	mova	r8,	r12	;
    7e30:	4a 13       	calla	r10		;

00007e32 <.LVL672>:
    7e32:	46 13       	calla	r6		;

00007e34 <.L484>:
}
    7e34:	64 16       	popm.a	#7,	r10	;20-bit words
    7e36:	10 01       	reta			;

00007e38 <.L486>:
    reply_buff[0] = hdr.opcode;
    7e38:	cc 47 00 00 	mov.b	r7,	0(r12)	;

00007e3c <.Loc.1164.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7e3c:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    7e40:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7e44:	02 00 

00007e46 <.Loc.1165.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7e46:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7e4a:	03 00 

00007e4c <.Loc.1166.2>:
    reply_buff[4] = bank0p[RegErrLogLvl];
    7e4c:	dc 4e 4d 00 	mov.b	77(r14),4(r12)	;0x0004d
    7e50:	04 00 

00007e52 <.Loc.1167.2>:
    if (hdr.crc) {
    7e52:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    7e56:	0d 24       	jz	$+28     	;abs 0x7e72

00007e58 <.Loc.1168.2>:
      reply_buff[1] = 3;
    7e58:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    7e5c:	01 00 

00007e5e <.Loc.1169.2>:
      crcGenX25(reply_buff, 7);
    7e5e:	7d 40 07 00 	mov.b	#7,	r13	;
    7e62:	b0 13 d4 95 	calla	#38356		;0x095d4

00007e66 <.L488>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7e66:	0d 49       	mov	r9,	r13	;
    7e68:	cc 04       	mova	r4,	r12	;
    7e6a:	b0 13 54 69 	calla	#26964		;0x06954

00007e6e <.LVL676>:
    7e6e:	80 00 34 7e 	mova	#32308,	r0	;0x07e34

00007e72 <.L487>:
      reply_buff[1] = 1;
    7e72:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    7e76:	80 00 66 7e 	mova	#32358,	r0	;0x07e66

00007e7a <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e7a:	5a 14       	pushm.a	#6,	r10	;20-bit words

00007e7c <.LCFI79>:
    7e7c:	c8 0c       	mova	r12,	r8	;
    7e7e:	2c 4d       	mov	@r13,	r12	;

00007e80 <.LVL678>:
    7e80:	19 4d 02 00 	mov	2(r13),	r9	;

00007e84 <.LVL679>:
    7e84:	05 4c       	mov	r12,	r5	;
    7e86:	55 07       	rrum	#2,	r5	;
    7e88:	75 f0 3f 00 	and.b	#63,	r5	;#0x003f

00007e8c <.Loc.1094.2>:
  if (hdr.reply) {
    7e8c:	07 45       	mov	r5,	r7	;
    7e8e:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    7e92:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    7e96:	7c f0 03 00 	and.b	#3,	r12	;

00007e9a <.LVL681>:
    7e9a:	07 dc       	bis	r12,	r7	;
    7e9c:	8a 00 fa 9d 	mova	#40442,	r10	;0x09dfa
    7ea0:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    7ea4:	06 24       	jz	$+14     	;abs 0x7eb2

00007ea6 <.LBB87>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7ea6:	b0 13 a2 62 	calla	#25250		;0x062a2

00007eaa <.LVL682>:
    7eaa:	c6 0c       	mova	r12,	r6	;

00007eac <.LVL683>:
    if (reply_buff == NULL) {
    7eac:	9c 00 00 00 	cmpa	#0,	r12	;
    7eb0:	06 20       	jnz	$+14     	;abs 0x7ebe

00007eb2 <.L493>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7eb2:	cc 08       	mova	r8,	r12	;
    7eb4:	4a 13       	calla	r10		;

00007eb6 <.LVL685>:
    7eb6:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007eba <.LVL686>:
}
    7eba:	55 16       	popm.a	#6,	r10	;20-bit words
    7ebc:	10 01       	reta			;

00007ebe <.L494>:
    reply_buff[0] = hdr.opcode;
    7ebe:	cc 45 00 00 	mov.b	r5,	0(r12)	;

00007ec2 <.Loc.1103.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7ec2:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    7ec6:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7eca:	02 00 

00007ecc <.Loc.1104.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7ecc:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7ed0:	03 00 

00007ed2 <.Loc.1105.2>:
    reply_buff[4] = bank0p[RegErrRptLvl];
    7ed2:	dc 4e 4c 00 	mov.b	76(r14),4(r12)	;0x0004c
    7ed6:	04 00 

00007ed8 <.Loc.1106.2>:
    if (hdr.crc) {
    7ed8:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    7edc:	0d 24       	jz	$+28     	;abs 0x7ef8

00007ede <.Loc.1107.2>:
      reply_buff[1] = 3;
    7ede:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    7ee2:	01 00 

00007ee4 <.Loc.1108.2>:
      crcGenX25(reply_buff, 7);
    7ee4:	7d 40 07 00 	mov.b	#7,	r13	;
    7ee8:	b0 13 d4 95 	calla	#38356		;0x095d4

00007eec <.L497>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7eec:	0d 49       	mov	r9,	r13	;
    7eee:	cc 06       	mova	r6,	r12	;
    7ef0:	b0 13 54 69 	calla	#26964		;0x06954

00007ef4 <.LVL689>:
    7ef4:	80 00 b2 7e 	mova	#32434,	r0	;0x07eb2

00007ef8 <.L496>:
      reply_buff[1] = 1;
    7ef8:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    7efc:	80 00 ec 7e 	mova	#32492,	r0	;0x07eec

00007f00 <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f00:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007f02 <.LCFI80>:
    7f02:	2a 4d       	mov	@r13,	r10	;

00007f04 <.LVL691>:
    7f04:	19 4d 02 00 	mov	2(r13),	r9	;

00007f08 <.LVL692>:
    7f08:	08 4a       	mov	r10,	r8	;
    7f0a:	58 07       	rrum	#2,	r8	;
    7f0c:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    7f10:	47 48       	mov.b	r8,	r7	;
    7f12:	06 4a       	mov	r10,	r6	;
    7f14:	56 0f       	rrum	#4,	r6	;
    7f16:	56 0f       	rrum	#4,	r6	;

00007f18 <.Loc.1067.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7f18:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007f1c <.LVL694>:
    7f1c:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007f20 <.LVL695>:
  if (hdr.reply) {
    7f20:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    7f24:	7a f0 03 00 	and.b	#3,	r10	;

00007f28 <.LVL696>:
    7f28:	07 da       	bis	r10,	r7	;
    7f2a:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    7f2e:	32 24       	jz	$+102    	;abs 0x7f94

00007f30 <.LBB89>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7f30:	b0 13 a2 62 	calla	#25250		;0x062a2

00007f34 <.LVL697>:
    7f34:	ca 0c       	mova	r12,	r10	;

00007f36 <.LVL698>:
    if (reply_buff == NULL) {
    7f36:	9c 00 00 00 	cmpa	#0,	r12	;
    7f3a:	2c 24       	jz	$+90     	;abs 0x7f94

00007f3c <.Loc.1076.2>:
    reply_buff[0] = hdr.opcode;
    7f3c:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00007f40 <.Loc.1077.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7f40:	28 01 ca 05 	mova	&67018,	r8	;0x105ca
    7f44:	dc 48 51 00 	mov.b	81(r8),	2(r12)	;0x00051
    7f48:	02 00 

00007f4a <.Loc.1078.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7f4a:	dc 48 50 00 	mov.b	80(r8),	3(r12)	;0x00050
    7f4e:	03 00 

00007f50 <.Loc.1079.2>:
    reply_buff[1] = hdr.length + 2;
    7f50:	66 53       	incd.b	r6		;
    7f52:	cc 46 01 00 	mov.b	r6,	1(r12)	;

00007f56 <.LVL701>:
    7f56:	cc 08       	mova	r8,	r12	;
    7f58:	ac 00 76 00 	adda	#118,	r12	;0x00076
    7f5c:	ce 0a       	mova	r10,	r14	;
    7f5e:	ae 00 04 00 	adda	#4,	r14	;
    7f62:	a8 00 72 00 	adda	#114,	r8	;0x00072

00007f66 <.L505>:
      reply_buff[i + 4] = bank0p[RegMissionTimeMsb - i];
    7f66:	ee 4c 00 00 	mov.b	@r12,	0(r14)	;

00007f6a <.LVL703>:
    7f6a:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    7f6e:	ae 00 01 00 	adda	#1,	r14	;

00007f72 <.LVL704>:
    for (int i = 0; i < 4; i++) {
    7f72:	dc 08       	cmpa	r8,	r12	;
    7f74:	f8 23       	jnz	$-14     	;abs 0x7f66

00007f76 <.LBE90>:
    if (hdr.crc) {
    7f76:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    7f7a:	08 24       	jz	$+18     	;abs 0x7f8c

00007f7c <.Loc.1085.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    7f7c:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    7f80:	2d 52       	add	#4,	r13	;r2 As==10
    7f82:	40 18 0d 4d 	movx.w	r13,	r13	;
    7f86:	cc 0a       	mova	r10,	r12	;
    7f88:	b0 13 d4 95 	calla	#38356		;0x095d4

00007f8c <.L506>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7f8c:	0d 49       	mov	r9,	r13	;
    7f8e:	cc 0a       	mova	r10,	r12	;
    7f90:	b0 13 54 69 	calla	#26964		;0x06954

00007f94 <.L501>:
}
    7f94:	46 16       	popm.a	#5,	r10	;20-bit words
    7f96:	10 01       	reta			;

00007f98 <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f98:	5a 14       	pushm.a	#6,	r10	;20-bit words

00007f9a <.LCFI81>:
    7f9a:	2e 4d       	mov	@r13,	r14	;

00007f9c <.LVL708>:
    7f9c:	19 4d 02 00 	mov	2(r13),	r9	;

00007fa0 <.LVL709>:
    7fa0:	0a 4e       	mov	r14,	r10	;
    7fa2:	5a 07       	rrum	#2,	r10	;
    7fa4:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    7fa8:	05 4e       	mov	r14,	r5	;
    7faa:	55 0f       	rrum	#4,	r5	;
    7fac:	55 0f       	rrum	#4,	r5	;

00007fae <.Loc.1035.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7fae:	07 4a       	mov	r10,	r7	;
    7fb0:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    7fb4:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    7fb8:	7e f0 03 00 	and.b	#3,	r14	;

00007fbc <.LVL711>:
    7fbc:	07 de       	bis	r14,	r7	;
    7fbe:	46 47       	mov.b	r7,	r6	;
    7fc0:	66 f3       	and.b	#2,	r6	;r3 As==10
    7fc2:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    7fc6:	06 93       	cmp	#0,	r6	;r3 As==00
    7fc8:	3a 20       	jnz	$+118    	;abs 0x803e
    7fca:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007fcc <.L515>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    7fcc:	28 01 c6 05 	mova	&67014,	r8	;0x105c6
    7fd0:	40 18 0e 4e 	movx.w	r14,	r14	;
    7fd4:	ee 0c       	adda	r12,	r14	;

00007fd6 <.LVL713>:
    7fd6:	e8 4e 76 00 	mov.b	@r14,	118(r8)	; 0x0076

00007fda <.Loc.1039.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    7fda:	d8 4e 01 00 	mov.b	1(r14),	117(r8)	; 0x0075
    7fde:	75 00 

00007fe0 <.Loc.1040.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    7fe0:	d8 4e 02 00 	mov.b	2(r14),	116(r8)	; 0x0074
    7fe4:	74 00 

00007fe6 <.Loc.1041.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    7fe6:	d8 4e 03 00 	mov.b	3(r14),	115(r8)	; 0x0073
    7fea:	73 00 

00007fec <.Loc.1043.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7fec:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00007ff0 <.LVL714>:
    7ff0:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00007ff4 <.LVL715>:
  if (hdr.reply) {
    7ff4:	06 93       	cmp	#0,	r6	;r3 As==00
    7ff6:	21 24       	jz	$+68     	;abs 0x803a

00007ff8 <.LBB91>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7ff8:	b0 13 a2 62 	calla	#25250		;0x062a2

00007ffc <.LVL716>:
    7ffc:	c8 0c       	mova	r12,	r8	;

00007ffe <.LVL717>:
    if (reply_buff == NULL) {
    7ffe:	9c 00 00 00 	cmpa	#0,	r12	;
    8002:	1b 24       	jz	$+56     	;abs 0x803a

00008004 <.Loc.1052.2>:
    reply_buff[0] = hdr.opcode;
    8004:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00008008 <.Loc.1053.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8008:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    800c:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8010:	02 00 

00008012 <.Loc.1054.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8012:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8016:	03 00 

00008018 <.Loc.1055.2>:
    reply_buff[1] = hdr.length - 2;
    8018:	75 50 fe ff 	add.b	#-2,	r5	;#0xfffe
    801c:	4d 45       	mov.b	r5,	r13	;
    801e:	cc 45 01 00 	mov.b	r5,	1(r12)	;

00008022 <.Loc.1056.2>:
    if (hdr.crc) {
    8022:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    8026:	05 24       	jz	$+12     	;abs 0x8032

00008028 <.Loc.1057.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    8028:	2d 52       	add	#4,	r13	;r2 As==10
    802a:	4d 0e       	rlam.a	#4,	r13	;
    802c:	4d 0d       	rram.a	#4,	r13	;
    802e:	b0 13 d4 95 	calla	#38356		;0x095d4

00008032 <.L519>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8032:	0d 49       	mov	r9,	r13	;
    8034:	cc 08       	mova	r8,	r12	;
    8036:	b0 13 54 69 	calla	#26964		;0x06954

0000803a <.L514>:
}
    803a:	55 16       	popm.a	#6,	r10	;20-bit words
    803c:	10 01       	reta			;

0000803e <.L520>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    803e:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8040:	80 00 cc 7f 	mova	#32716,	r0	;0x07fcc

00008044 <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8044:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008046 <.LCFI82>:
    8046:	b1 00 04 00 	suba	#4,	r1	;

0000804a <.LCFI83>:
    804a:	ca 0c       	mova	r12,	r10	;
    804c:	2e 4d       	mov	@r13,	r14	;

0000804e <.LVL723>:
    804e:	17 4d 02 00 	mov	2(r13),	r7	;

00008052 <.LVL724>:
    8052:	09 4e       	mov	r14,	r9	;
    8054:	59 07       	rrum	#2,	r9	;
    8056:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

0000805a <.Loc.826.2>:
  if (hdr.reply) {
    805a:	0d 49       	mov	r9,	r13	;
    805c:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    8060:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8064:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

00008068 <.LVL727>:
    8068:	0d de       	bis	r14,	r13	;
    806a:	45 4d       	mov.b	r13,	r5	;
    806c:	88 00 fa 9d 	mova	#40442,	r8	;0x09dfa
    8070:	86 00 3e 9b 	mova	#39742,	r6	;0x09b3e
    8074:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    8078:	1d 24       	jz	$+60     	;abs 0x80b4

0000807a <.LBB92>:
    if ((buffer[4] < 0x40) || 
    807a:	5c 4c 04 00 	mov.b	4(r12),	r12	;

0000807e <.LVL728>:
    807e:	4e 4c       	mov.b	r12,	r14	;
    8080:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    8084:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    8088:	4f 9e       	cmp.b	r14,	r15	;
    808a:	0c 28       	jnc	$+26     	;abs 0x80a4

0000808c <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    808c:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

00008090 <.Loc.827.2>:
    if ((buffer[4] < 0x40) || 
    8090:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    8094:	4f 9e       	cmp.b	r14,	r15	;
    8096:	06 2c       	jc	$+14     	;abs 0x80a4

00008098 <.Loc.829.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    8098:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

0000809c <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    809c:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    80a0:	4e 9c       	cmp.b	r12,	r14	;
    80a2:	0c 28       	jnc	$+26     	;abs 0x80bc

000080a4 <.L529>:
        gen_failure(hdr);
    80a4:	81 4d 00 00 	mov	r13,	0(r1)	;
    80a8:	81 47 02 00 	mov	r7,	2(r1)	;
    80ac:	cc 01       	mova	r1,	r12	;
    80ae:	b0 13 be 6c 	calla	#27838		;0x06cbe

000080b2 <.L535>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    80b2:	cc 0a       	mova	r10,	r12	;

000080b4 <.L528>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    80b4:	48 13       	calla	r8		;

000080b6 <.LVL731>:
    80b6:	46 13       	calla	r6		;

000080b8 <.LVL732>:
    80b8:	80 00 1e 81 	mova	#33054,	r0	;0x0811e

000080bc <.L530>:
    uint8_t * reply_buff = elyFWGetBuffer();
    80bc:	b0 13 a2 62 	calla	#25250		;0x062a2

000080c0 <.LVL733>:
    80c0:	c4 0c       	mova	r12,	r4	;

000080c2 <.LVL734>:
    if (reply_buff == NULL) {
    80c2:	9c 00 00 00 	cmpa	#0,	r12	;
    80c6:	f5 27       	jz	$-20     	;abs 0x80b2

000080c8 <.Loc.844.2>:
    reply_buff[0] = hdr.opcode;
    80c8:	cc 49 00 00 	mov.b	r9,	0(r12)	;

000080cc <.Loc.845.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    80cc:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    80d0:	d4 4c 51 00 	mov.b	81(r12),2(r4)	;0x00051
    80d4:	02 00 

000080d6 <.Loc.846.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    80d6:	d4 4c 50 00 	mov.b	80(r12),3(r4)	;0x00050
    80da:	03 00 

000080dc <.Loc.849.2>:
    size_t n = elyChanGetValue(&reply_buff[4], buffer[4]);
    80dc:	5d 4a 04 00 	mov.b	4(r10),	r13	;
    80e0:	cc 04       	mova	r4,	r12	;
    80e2:	ac 00 04 00 	adda	#4,	r12	;
    80e6:	b0 13 44 91 	calla	#37188		;0x09144

000080ea <.LVL735>:
    80ea:	c9 0c       	mova	r12,	r9	;

000080ec <.LVL736>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    80ec:	cc 0a       	mova	r10,	r12	;
    80ee:	48 13       	calla	r8		;

000080f0 <.LVL737>:
    80f0:	46 13       	calla	r6		;

000080f2 <.LVL738>:
    80f2:	09 14       	pushm.a	#1,	r9	;20-bit words
    80f4:	40 18 3c 41 	popx.w	r12		;
    80f8:	40 18 3d 41 	popx.w	r13		;

000080fc <.Loc.853.2>:
    if (hdr.crc) {
    80fc:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    8100:	12 24       	jz	$+38     	;abs 0x8126

00008102 <.Loc.854.2>:
      reply_buff[1] = n + 3;
    8102:	7c 50 03 00 	add.b	#3,	r12	;
    8106:	c4 4c 01 00 	mov.b	r12,	1(r4)	;

0000810a <.Loc.855.2>:
      crcGenX25(reply_buff, 7+n);
    810a:	cd 09       	mova	r9,	r13	;
    810c:	ad 00 07 00 	adda	#7,	r13	;
    8110:	cc 04       	mova	r4,	r12	;
    8112:	b0 13 d4 95 	calla	#38356		;0x095d4

00008116 <.L534>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8116:	0d 47       	mov	r7,	r13	;
    8118:	cc 04       	mova	r4,	r12	;
    811a:	b0 13 54 69 	calla	#26964		;0x06954

0000811e <.L527>:
}
    811e:	a1 00 04 00 	adda	#4,	r1	;
    8122:	64 16       	popm.a	#7,	r10	;20-bit words
    8124:	10 01       	reta			;

00008126 <.L533>:
      reply_buff[1] = n + 1;
    8126:	5c 53       	inc.b	r12		;
    8128:	c4 4c 01 00 	mov.b	r12,	1(r4)	;
    812c:	80 00 16 81 	mova	#33046,	r0	;0x08116

00008130 <get_u32>:
    const uint32_t max, const uint32_t min) {
    8130:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008132 <.LCFI84>:
    8132:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00008136 <.LCFI85>:
    8136:	46 4c       	mov.b	r12,	r6	;
    8138:	2c 4d       	mov	@r13,	r12	;

0000813a <.LVL743>:
    813a:	91 4d 02 00 	mov	2(r13),	12(r1)	; 0x000c
    813e:	0c 00 
    8140:	07 4e       	mov	r14,	r7	;
    8142:	08 4f       	mov	r15,	r8	;
    8144:	91 41 2e 00 	mov	46(r1),	8(r1)	;0x0002e
    8148:	08 00 
    814a:	15 41 30 00 	mov	48(r1),	r5	;0x00030
    814e:	09 4c       	mov	r12,	r9	;
    8150:	59 07       	rrum	#2,	r9	;
    8152:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

00008156 <.Loc.85.2>:
  if (hdr.reply) {
    8156:	0d 49       	mov	r9,	r13	;
    8158:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    815c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8160:	7c f0 03 00 	and.b	#3,	r12	;

00008164 <.LVL746>:
    8164:	0c dd       	bis	r13,	r12	;
    8166:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    816a:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    816e:	71 24       	jz	$+228    	;abs 0x8252

00008170 <.LBB95>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8170:	b0 13 a2 62 	calla	#25250		;0x062a2

00008174 <.LVL747>:
    8174:	ca 0c       	mova	r12,	r10	;

00008176 <.LVL748>:
    if (reply_buff == NULL) {
    8176:	9c 00 00 00 	cmpa	#0,	r12	;
    817a:	6b 24       	jz	$+216    	;abs 0x8252

0000817c <.Loc.92.2>:
    reply_buff[0] = hdr.opcode;
    817c:	cc 49 00 00 	mov.b	r9,	0(r12)	;

00008180 <.Loc.93.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8180:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    8184:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8188:	02 00 

0000818a <.Loc.94.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    818a:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    818e:	03 00 

00008190 <.LVL749>:
    8190:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    8194:	04 00 
    8196:	3b 01 04 00 	mova	4(r1),	r11	;
    819a:	eb 0c       	adda	r12,	r11	;
    819c:	44 43       	clr.b	r4		;

0000819e <.Loc.96.2>:
    uint32_t val = 0;
    819e:	09 44       	mov	r4,	r9	;
    81a0:	06 44       	mov	r4,	r6	;

000081a2 <.L540>:
      val |= ((uint32_t)(bank0p[addr + i]) << (8 * i));
    81a2:	6c 4b       	mov.b	@r11,	r12	;
    81a4:	0d 43       	clr	r13		;
    81a6:	0e 44       	mov	r4,	r14	;
    81a8:	0f 43       	clr	r15		;
    81aa:	71 0b 00 00 	mova	r11,	0(r1)	;
    81ae:	b0 13 2e 9f 	calla	#40750		;0x09f2e
    81b2:	0c d9       	bis	r9,	r12	;
    81b4:	0d d6       	bis	r6,	r13	;
    81b6:	09 4c       	mov	r12,	r9	;

000081b8 <.LVL753>:
    81b8:	06 4d       	mov	r13,	r6	;

000081ba <.LVL754>:
    81ba:	0b 01       	mova	@r1,	r11	;
    81bc:	ab 00 01 00 	adda	#1,	r11	;
    81c0:	34 52       	add	#8,	r4	;r2 As==11

000081c2 <.Loc.97.2>:
    for (int i = 0; i < 4; i++) {
    81c2:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    81c6:	ed 23       	jnz	$-36     	;abs 0x81a2

000081c8 <.LBE96>:
    if (val > max) {
    81c8:	08 9d       	cmp	r13,	r8	;
    81ca:	04 28       	jnc	$+10     	;abs 0x81d4
    81cc:	0d 98       	cmp	r8,	r13	;
    81ce:	45 20       	jnz	$+140    	;abs 0x825a
    81d0:	07 9c       	cmp	r12,	r7	;
    81d2:	43 2c       	jc	$+136    	;abs 0x825a

000081d4 <.L549>:
    81d4:	36 01 04 00 	mova	4(r1),	r6	;

000081d8 <.LVL755>:
    81d8:	80 18 56 52 	addx.a	&0x105c6,r6	;
    81dc:	c6 05 

000081de <.LBB97>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    81de:	49 43       	clr.b	r9		;

000081e0 <.L543>:
    81e0:	0c 47       	mov	r7,	r12	;
    81e2:	0d 48       	mov	r8,	r13	;
    81e4:	0e 49       	mov	r9,	r14	;
    81e6:	0f 43       	clr	r15		;
    81e8:	b0 13 e2 9f 	calla	#40930		;0x09fe2
    81ec:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    81f0:	39 52       	add	#8,	r9	;r2 As==11
    81f2:	a6 00 01 00 	adda	#1,	r6	;

000081f6 <.Loc.103.2>:
      for (int i = 0; i < 4; i++) {
    81f6:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    81fa:	f2 23       	jnz	$-26     	;abs 0x81e0
    81fc:	09 47       	mov	r7,	r9	;
    81fe:	06 48       	mov	r8,	r6	;

00008200 <.L544>:
      reply_buff[i + 4] = ((val >> (8 * (3 - i))) & 0xFF);
    8200:	0c 49       	mov	r9,	r12	;
    8202:	0d 46       	mov	r6,	r13	;
    8204:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    8208:	b0 13 e2 9f 	calla	#40930		;0x09fe2
    820c:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

00008210 <.LVL762>:
    8210:	0c 49       	mov	r9,	r12	;
    8212:	0d 46       	mov	r6,	r13	;
    8214:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8218:	b0 13 e2 9f 	calla	#40930		;0x09fe2
    821c:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

00008220 <.LVL764>:
    8220:	0c 49       	mov	r9,	r12	;
    8222:	0d 46       	mov	r6,	r13	;
    8224:	b0 13 a8 9f 	calla	#40872		;0x09fa8
    8228:	ca 4c 06 00 	mov.b	r12,	6(r10)	;

0000822c <.LVL766>:
    822c:	ca 49 07 00 	mov.b	r9,	7(r10)	;

00008230 <.LBE98>:
    if (hdr.crc) {
    8230:	40 18 91 b3 	bitx.w	#1,	10(r1)	;r3 As==01, 0x0000a
    8234:	0a 00 
    8236:	32 24       	jz	$+102    	;abs 0x829c

00008238 <.Loc.119.2>:
      reply_buff[1] = 6;
    8238:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    823c:	01 00 

0000823e <.Loc.120.2>:
      crcGenX25(reply_buff, 10);
    823e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8242:	cc 0a       	mova	r10,	r12	;
    8244:	b0 13 d4 95 	calla	#38356		;0x095d4

00008248 <.L548>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8248:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    824c:	cc 0a       	mova	r10,	r12	;
    824e:	b0 13 54 69 	calla	#26964		;0x06954

00008252 <.L536>:
}
    8252:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    8256:	64 16       	popm.a	#7,	r10	;20-bit words
    8258:	10 01       	reta			;

0000825a <.L541>:
    else if (val < min) {
    825a:	0d 95       	cmp	r5,	r13	;
    825c:	05 28       	jnc	$+12     	;abs 0x8268
    825e:	05 9d       	cmp	r13,	r5	;
    8260:	cf 23       	jnz	$-96     	;abs 0x8200
    8262:	1c 91 08 00 	cmp	8(r1),	r12	;
    8266:	cc 2f       	jc	$-102    	;abs 0x8200

00008268 <.L550>:
    8268:	36 01 04 00 	mova	4(r1),	r6	;

0000826c <.LVL771>:
    826c:	80 18 56 52 	addx.a	&0x105c6,r6	;
    8270:	c6 05 

00008272 <.LBB99>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    8272:	49 43       	clr.b	r9		;

00008274 <.L546>:
    8274:	1c 41 08 00 	mov	8(r1),	r12	;
    8278:	0d 45       	mov	r5,	r13	;
    827a:	0e 49       	mov	r9,	r14	;
    827c:	0f 43       	clr	r15		;
    827e:	b0 13 e2 9f 	calla	#40930		;0x09fe2
    8282:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    8286:	39 52       	add	#8,	r9	;r2 As==11
    8288:	a6 00 01 00 	adda	#1,	r6	;

0000828c <.Loc.109.2>:
      for (int i = 0; i < 4; i++) {
    828c:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    8290:	f1 23       	jnz	$-28     	;abs 0x8274
    8292:	19 41 08 00 	mov	8(r1),	r9	;
    8296:	06 45       	mov	r5,	r6	;
    8298:	80 00 00 82 	mova	#33280,	r0	;0x08200

0000829c <.L547>:
      reply_buff[1] = 4;
    829c:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    82a0:	80 00 48 82 	mova	#33352,	r0	;0x08248

000082a4 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    82a4:	19 14       	pushm.a	#2,	r9	;20-bit words

000082a6 <.LCFI86>:
    82a6:	b1 00 08 00 	suba	#8,	r1	;

000082aa <.LCFI87>:
    82aa:	28 4d       	mov	@r13,	r8	;

000082ac <.LVL779>:
    82ac:	19 4d 02 00 	mov	2(r13),	r9	;

000082b0 <.LVL780>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    82b0:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000082b4 <.LVL781>:
    82b4:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000082b8 <.LVL782>:
  get_u32(RegUARTBaudLsb, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    82b8:	81 48 04 00 	mov	r8,	4(r1)	;
    82bc:	81 49 06 00 	mov	r9,	6(r1)	;
    82c0:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    82c4:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    82c8:	3e 40 40 42 	mov	#16960,	r14	;#0x4240
    82cc:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    82d0:	cd 01       	mova	r1,	r13	;
    82d2:	ad 00 04 00 	adda	#4,	r13	;
    82d6:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    82da:	b0 13 30 81 	calla	#33072		;0x08130

000082de <.LVL783>:
}
    82de:	a1 00 08 00 	adda	#8,	r1	;
    82e2:	18 16       	popm.a	#2,	r9	;20-bit words
    82e4:	10 01       	reta			;

000082e6 <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    82e6:	19 14       	pushm.a	#2,	r9	;20-bit words

000082e8 <.LCFI88>:
    82e8:	b1 00 08 00 	suba	#8,	r1	;

000082ec <.LCFI89>:
    82ec:	28 4d       	mov	@r13,	r8	;

000082ee <.LVL785>:
    82ee:	19 4d 02 00 	mov	2(r13),	r9	;

000082f2 <.LVL786>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    82f2:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000082f6 <.LVL787>:
    82f6:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000082fa <.LVL788>:
  get_u32(RegRXDevLsb, hdr, RX_DEV_MAX, RX_DEV_MIN);
    82fa:	81 48 04 00 	mov	r8,	4(r1)	;
    82fe:	81 49 06 00 	mov	r9,	6(r1)	;
    8302:	b1 40 e8 80 	mov	#-32536,0(r1)	;#0x80e8
    8306:	00 00 
    8308:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    830c:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    8310:	7f 40 03 00 	mov.b	#3,	r15	;
    8314:	cd 01       	mova	r1,	r13	;
    8316:	ad 00 04 00 	adda	#4,	r13	;
    831a:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c
    831e:	b0 13 30 81 	calla	#33072		;0x08130

00008322 <.LVL789>:
}
    8322:	a1 00 08 00 	adda	#8,	r1	;
    8326:	18 16       	popm.a	#2,	r9	;20-bit words
    8328:	10 01       	reta			;

0000832a <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    832a:	19 14       	pushm.a	#2,	r9	;20-bit words

0000832c <.LCFI90>:
    832c:	b1 00 08 00 	suba	#8,	r1	;

00008330 <.LCFI91>:
    8330:	28 4d       	mov	@r13,	r8	;

00008332 <.LVL791>:
    8332:	19 4d 02 00 	mov	2(r13),	r9	;

00008336 <.LVL792>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8336:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000833a <.LVL793>:
    833a:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000833e <.LVL794>:
  get_u32(RegTXDevLsb, hdr, TX_DEV_MAX, TX_DEV_MIN);
    833e:	81 48 04 00 	mov	r8,	4(r1)	;
    8342:	81 49 06 00 	mov	r9,	6(r1)	;
    8346:	b1 40 58 02 	mov	#600,	0(r1)	;#0x0258
    834a:	00 00 
    834c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8350:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    8354:	7f 40 03 00 	mov.b	#3,	r15	;
    8358:	cd 01       	mova	r1,	r13	;
    835a:	ad 00 04 00 	adda	#4,	r13	;
    835e:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8360:	b0 13 30 81 	calla	#33072		;0x08130

00008364 <.LVL795>:
}
    8364:	a1 00 08 00 	adda	#8,	r1	;
    8368:	18 16       	popm.a	#2,	r9	;20-bit words
    836a:	10 01       	reta			;

0000836c <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    836c:	19 14       	pushm.a	#2,	r9	;20-bit words

0000836e <.LCFI92>:
    836e:	b1 00 08 00 	suba	#8,	r1	;

00008372 <.LCFI93>:
    8372:	28 4d       	mov	@r13,	r8	;

00008374 <.LVL797>:
    8374:	19 4d 02 00 	mov	2(r13),	r9	;

00008378 <.LVL798>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8378:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000837c <.LVL799>:
    837c:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008380 <.LVL800>:
  get_u32(RegRXBRLsb, hdr, RX_BR_MAX, RX_BR_MIN);
    8380:	81 48 04 00 	mov	r8,	4(r1)	;
    8384:	81 49 06 00 	mov	r9,	6(r1)	;
    8388:	b1 40 0c 03 	mov	#780,	0(r1)	;#0x030c
    838c:	00 00 
    838e:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8392:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    8396:	6f 43       	mov.b	#2,	r15	;r3 As==10
    8398:	cd 01       	mova	r1,	r13	;
    839a:	ad 00 04 00 	adda	#4,	r13	;
    839e:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c
    83a2:	b0 13 30 81 	calla	#33072		;0x08130

000083a6 <.LVL801>:
}
    83a6:	a1 00 08 00 	adda	#8,	r1	;
    83aa:	18 16       	popm.a	#2,	r9	;20-bit words
    83ac:	10 01       	reta			;

000083ae <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83ae:	19 14       	pushm.a	#2,	r9	;20-bit words

000083b0 <.LCFI94>:
    83b0:	b1 00 08 00 	suba	#8,	r1	;

000083b4 <.LCFI95>:
    83b4:	28 4d       	mov	@r13,	r8	;

000083b6 <.LVL803>:
    83b6:	19 4d 02 00 	mov	2(r13),	r9	;

000083ba <.LVL804>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    83ba:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000083be <.LVL805>:
    83be:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000083c2 <.LVL806>:
  get_u32(RegTXBRLsb, hdr, TX_BR_MAX, TX_BR_MIN);
    83c2:	81 48 04 00 	mov	r8,	4(r1)	;
    83c6:	81 49 06 00 	mov	r9,	6(r1)	;
    83ca:	b1 40 b0 04 	mov	#1200,	0(r1)	;#0x04b0
    83ce:	00 00 
    83d0:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    83d4:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    83d8:	6f 42       	mov.b	#4,	r15	;r2 As==10
    83da:	cd 01       	mova	r1,	r13	;
    83dc:	ad 00 04 00 	adda	#4,	r13	;
    83e0:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    83e4:	b0 13 30 81 	calla	#33072		;0x08130

000083e8 <.LVL807>:
}
    83e8:	a1 00 08 00 	adda	#8,	r1	;
    83ec:	18 16       	popm.a	#2,	r9	;20-bit words
    83ee:	10 01       	reta			;

000083f0 <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83f0:	19 14       	pushm.a	#2,	r9	;20-bit words

000083f2 <.LCFI96>:
    83f2:	b1 00 08 00 	suba	#8,	r1	;

000083f6 <.LCFI97>:
    83f6:	28 4d       	mov	@r13,	r8	;

000083f8 <.LVL809>:
    83f8:	19 4d 02 00 	mov	2(r13),	r9	;

000083fc <.LVL810>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    83fc:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00008400 <.LVL811>:
    8400:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008404 <.LVL812>:
  get_u32(RegRXFreqLsb, hdr, RX_BAND_MAX, RX_BAND_MIN);
    8404:	81 48 04 00 	mov	r8,	4(r1)	;
    8408:	81 49 06 00 	mov	r9,	6(r1)	;
    840c:	b1 40 40 44 	mov	#17472,	0(r1)	;#0x4440
    8410:	00 00 
    8412:	b1 40 3d 1b 	mov	#6973,	2(r1)	;#0x1b3d
    8416:	02 00 
    8418:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    841c:	3f 40 12 1c 	mov	#7186,	r15	;#0x1c12
    8420:	cd 01       	mova	r1,	r13	;
    8422:	ad 00 04 00 	adda	#4,	r13	;
    8426:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8428:	b0 13 30 81 	calla	#33072		;0x08130

0000842c <.LVL813>:
}
    842c:	a1 00 08 00 	adda	#8,	r1	;
    8430:	18 16       	popm.a	#2,	r9	;20-bit words
    8432:	10 01       	reta			;

00008434 <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8434:	19 14       	pushm.a	#2,	r9	;20-bit words

00008436 <.LCFI98>:
    8436:	b1 00 08 00 	suba	#8,	r1	;

0000843a <.LCFI99>:
    843a:	28 4d       	mov	@r13,	r8	;

0000843c <.LVL815>:
    843c:	19 4d 02 00 	mov	2(r13),	r9	;

00008440 <.LVL816>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8440:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00008444 <.LVL817>:
    8444:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008448 <.LVL818>:
  get_u32(RegTXFreqLsb, hdr, TX_BAND_MAX, TX_BAND_MIN);
    8448:	81 48 04 00 	mov	r8,	4(r1)	;
    844c:	81 49 06 00 	mov	r9,	6(r1)	;
    8450:	b1 40 40 da 	mov	#-9664,	0(r1)	;#0xda40
    8454:	00 00 
    8456:	b1 40 8e 33 	mov	#13198,	2(r1)	;#0x338e
    845a:	02 00 
    845c:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    8460:	3f 40 ec 38 	mov	#14572,	r15	;#0x38ec
    8464:	cd 01       	mova	r1,	r13	;
    8466:	ad 00 04 00 	adda	#4,	r13	;
    846a:	4c 43       	clr.b	r12		;
    846c:	b0 13 30 81 	calla	#33072		;0x08130

00008470 <.LVL819>:
}
    8470:	a1 00 08 00 	adda	#8,	r1	;
    8474:	18 16       	popm.a	#2,	r9	;20-bit words
    8476:	10 01       	reta			;

00008478 <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8478:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000847a <.LCFI100>:
    847a:	c8 0c       	mova	r12,	r8	;
    847c:	2a 4d       	mov	@r13,	r10	;

0000847e <.LVL821>:
    847e:	16 4d 02 00 	mov	2(r13),	r6	;

00008482 <.LVL822>:
    8482:	07 4a       	mov	r10,	r7	;
    8484:	57 07       	rrum	#2,	r7	;
    8486:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    848a:	49 47       	mov.b	r7,	r9	;

0000848c <.Loc.579.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    848c:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00008490 <.LVL824>:
    8490:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008494 <.LVL825>:
  if (hdr.reply) {
    8494:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    8498:	7a f0 03 00 	and.b	#3,	r10	;

0000849c <.LVL826>:
    849c:	09 da       	bis	r10,	r9	;
    849e:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    84a2:	22 24       	jz	$+70     	;abs 0x84e8

000084a4 <.LBB101>:
    uint8_t * reply_buff = elyFWGetBuffer();
    84a4:	b0 13 a2 62 	calla	#25250		;0x062a2

000084a8 <.LVL827>:
    84a8:	ca 0c       	mova	r12,	r10	;

000084aa <.LVL828>:
    if (reply_buff == NULL) {
    84aa:	9c 00 00 00 	cmpa	#0,	r12	;
    84ae:	1c 24       	jz	$+58     	;abs 0x84e8

000084b0 <.Loc.588.2>:
    reply_buff[0] = hdr.opcode;
    84b0:	cc 47 00 00 	mov.b	r7,	0(r12)	;

000084b4 <.Loc.589.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    84b4:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    84b8:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    84bc:	02 00 

000084be <.Loc.590.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    84be:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    84c2:	03 00 

000084c4 <.Loc.591.2>:
    reply_buff[4] = bank0p[RegOutputPower];
    84c4:	da 4c 21 00 	mov.b	33(r12),4(r10)	;0x00021
    84c8:	04 00 

000084ca <.Loc.592.2>:
    if (hdr.crc) {
    84ca:	40 18 19 b3 	bitx.w	#1,	r9	;r3 As==01
    84ce:	0e 24       	jz	$+30     	;abs 0x84ec

000084d0 <.Loc.593.2>:
      reply_buff[1] = 3;
    84d0:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    84d4:	01 00 

000084d6 <.Loc.594.2>:
      crcGenX25(buffer, 7);
    84d6:	7d 40 07 00 	mov.b	#7,	r13	;
    84da:	cc 08       	mova	r8,	r12	;
    84dc:	b0 13 d4 95 	calla	#38356		;0x095d4

000084e0 <.L569>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    84e0:	0d 46       	mov	r6,	r13	;
    84e2:	cc 0a       	mova	r10,	r12	;
    84e4:	b0 13 54 69 	calla	#26964		;0x06954

000084e8 <.L564>:
}
    84e8:	46 16       	popm.a	#5,	r10	;20-bit words
    84ea:	10 01       	reta			;

000084ec <.L568>:
      reply_buff[1] = 1;
    84ec:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01
    84f0:	80 00 e0 84 	mova	#34016,	r0	;0x084e0

000084f4 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    84f4:	6a 14       	pushm.a	#7,	r10	;20-bit words

000084f6 <.LCFI101>:
    84f6:	b1 00 16 00 	suba	#22,	r1	;0x00016

000084fa <.LCFI102>:
    84fa:	71 0c 08 00 	mova	r12,	8(r1)	;
    84fe:	2a 4d       	mov	@r13,	r10	;

00008500 <.LVL833>:
    8500:	15 4d 02 00 	mov	2(r13),	r5	;

00008504 <.LVL834>:
    8504:	09 4a       	mov	r10,	r9	;
    8506:	59 0f       	rrum	#4,	r9	;
    8508:	59 0f       	rrum	#4,	r9	;

0000850a <.Loc.405.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    850a:	4f 4a       	mov.b	r10,	r15	;
    850c:	4b 4f       	mov.b	r15,	r11	;
    850e:	6b f3       	and.b	#2,	r11	;r3 As==10
    8510:	47 4b       	mov.b	r11,	r7	;
    8512:	07 93       	cmp	#0,	r7	;r3 As==00
    8514:	26 20       	jnz	$+78     	;abs 0x8562
    8516:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008518 <.L574>:
  uint8_t bank = buffer[hdr_ext];
    8518:	40 18 06 4d 	movx.w	r13,	r6	;
    851c:	3c 01 08 00 	mova	8(r1),	r12	;

00008520 <.LVL837>:
    8520:	ec 06       	adda	r6,	r12	;
    8522:	64 4c       	mov.b	@r12,	r4	;
    8524:	81 44 10 00 	mov	r4,	16(r1)	; 0x0010

00008528 <.LVL838>:
  uint8_t addr = buffer[hdr_ext+1];
    8528:	54 4c 01 00 	mov.b	1(r12),	r4	;

0000852c <.LVL839>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    852c:	1f b3       	bit	#1,	r15	;r3 As==01
    852e:	1c 20       	jnz	$+58     	;abs 0x8568

00008530 <.Loc.408.2>:
    8530:	4d 43       	clr.b	r13		;

00008532 <.L575>:
  uint8_t * reply_buff = elyFWGetBuffer();
    8532:	71 0b 00 00 	mova	r11,	0(r1)	;

00008536 <.LVL841>:
    8536:	71 0d 04 00 	mova	r13,	4(r1)	;
    853a:	b0 13 a2 62 	calla	#25250		;0x062a2

0000853e <.LVL842>:
    853e:	c8 0c       	mova	r12,	r8	;

00008540 <.LVL843>:
    8540:	8e 00 fa 9d 	mova	#40442,	r14	;0x09dfa

00008544 <.Loc.410.2>:
  if (reply_buff == NULL) {
    8544:	0b 01       	mova	@r1,	r11	;
    8546:	3d 01 04 00 	mova	4(r1),	r13	;
    854a:	9c 00 00 00 	cmpa	#0,	r12	;
    854e:	0f 20       	jnz	$+32     	;abs 0x856e

00008550 <.L582>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8550:	3c 01 08 00 	mova	8(r1),	r12	;
    8554:	4e 13       	calla	r14		;

00008556 <.LVL845>:
    8556:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000855a <.L573>:
}
    855a:	a1 00 16 00 	adda	#22,	r1	;0x00016
    855e:	64 16       	popm.a	#7,	r10	;20-bit words
    8560:	10 01       	reta			;

00008562 <.L584>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8562:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8564:	80 00 18 85 	mova	#34072,	r0	;0x08518

00008568 <.L585>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8568:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000856a <.LVL850>:
    856a:	80 00 32 85 	mova	#34098,	r0	;0x08532

0000856e <.L576>:
  if (bank == 0 || bank > 4 || 
    856e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8572:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8574:	7f 40 03 00 	mov.b	#3,	r15	;
    8578:	4f 9c       	cmp.b	r12,	r15	;
    857a:	21 28       	jnc	$+68     	;abs 0x85be

0000857c <.Loc.408.2>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    857c:	4f 49       	mov.b	r9,	r15	;
    857e:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe
    8582:	4f 8b       	sub.b	r11,	r15	;
    8584:	4f 8d       	sub.b	r13,	r15	;
    8586:	4c 4f       	mov.b	r15,	r12	;

00008588 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    8588:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    858c:	57 00 
    858e:	40 18 0d 8c 	subx.w	r12,	r13	;

00008592 <.Loc.417.2>:
  if (bank == 0 || bank > 4 || 
    8592:	04 9d       	cmp	r13,	r4	;
    8594:	02 38       	jl	$+6      	;abs 0x859a

00008596 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    8596:	44 93       	cmp.b	#0,	r4	;r3 As==00
    8598:	12 34       	jge	$+38     	;abs 0x85be

0000859a <.L579>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    859a:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    859e:	8b 00 
    85a0:	40 18 0d 8c 	subx.w	r12,	r13	;

000085a4 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    85a4:	04 9d       	cmp	r13,	r4	;
    85a6:	04 38       	jl	$+10     	;abs 0x85b0

000085a8 <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    85a8:	7b 40 bf ff 	mov.b	#-65,	r11	;#0xffbf
    85ac:	4b 94       	cmp.b	r4,	r11	;
    85ae:	07 2c       	jc	$+16     	;abs 0x85be

000085b0 <.L580>:
      (addr >= RegDLLMAX - count + 1)) {
    85b0:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    85b4:	d6 00 
    85b6:	40 18 0d 8c 	subx.w	r12,	r13	;

000085ba <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    85ba:	04 9d       	cmp	r13,	r4	;
    85bc:	1b 38       	jl	$+56     	;abs 0x85f4

000085be <.L578>:
    if (hdr.reply) {
    85be:	07 93       	cmp	#0,	r7	;r3 As==00
    85c0:	c7 27       	jz	$-112    	;abs 0x8550

000085c2 <.Loc.422.2>:
      write_failure(reply_buff, hdr);
    85c2:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    85c6:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000085ca <.LVL854>:
    85ca:	0a d9       	bis	r9,	r10	;
    85cc:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    85d0:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    85d4:	cd 01       	mova	r1,	r13	;
    85d6:	ad 00 12 00 	adda	#18,	r13	;0x00012
    85da:	cc 08       	mova	r8,	r12	;
    85dc:	71 0e 04 00 	mova	r14,	4(r1)	;
    85e0:	b0 13 0c 63 	calla	#25356		;0x0630c

000085e4 <.LVL855>:
      elyCmdSendReply(reply_buff, hdr.reply_addr);
    85e4:	0d 45       	mov	r5,	r13	;
    85e6:	cc 08       	mova	r8,	r12	;
    85e8:	b0 13 54 69 	calla	#26964		;0x06954

000085ec <.LVL856>:
    85ec:	3e 01 04 00 	mova	4(r1),	r14	;
    85f0:	80 00 50 85 	mova	#34128,	r0	;0x08550

000085f4 <.L581>:
  memcpy(reply_buff + 4, buffer + hdr_ext + 2, count);
    85f4:	cd 06       	mova	r6,	r13	;
    85f6:	ad 00 02 00 	adda	#2,	r13	;
    85fa:	40 18 0e 4f 	movx.w	r15,	r14	;
    85fe:	00 18 5d 51 	addx.a	8(r1),	r13	;
    8602:	08 00 
    8604:	cb 08       	mova	r8,	r11	;
    8606:	ab 00 04 00 	adda	#4,	r11	;
    860a:	71 0b 0c 00 	mova	r11,	12(r1)	; 0x0000c
    860e:	cc 0b       	mova	r11,	r12	;
    8610:	71 0f 04 00 	mova	r15,	4(r1)	;
    8614:	b0 13 0a a0 	calla	#40970		;0x0a00a

00008618 <.LVL858>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8618:	86 00 fa 9d 	mova	#40442,	r6	;0x09dfa

0000861c <.LVL859>:
    861c:	3c 01 08 00 	mova	8(r1),	r12	;
    8620:	46 13       	calla	r6		;

00008622 <.LVL860>:
    8622:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008626 <.LVL861>:
  elyRegSetBlock(bank, reply_buff + 4, addr, count);
    8626:	3f 01 04 00 	mova	4(r1),	r15	;
    862a:	4e 44       	mov.b	r4,	r14	;
    862c:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    8630:	14 41 10 00 	mov	16(r1),	r4	;0x00010

00008634 <.LVL862>:
    8634:	4c 44       	mov.b	r4,	r12	;
    8636:	b0 13 d8 90 	calla	#37080		;0x090d8

0000863a <.LVL863>:
  if (hdr.reply) {
    863a:	07 93       	cmp	#0,	r7	;r3 As==00
    863c:	15 24       	jz	$+44     	;abs 0x8668

0000863e <.Loc.437.2>:
    write_success(reply_buff, hdr);
    863e:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8642:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00008646 <.LVL866>:
    8646:	0a d9       	bis	r9,	r10	;
    8648:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    864c:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    8650:	cd 01       	mova	r1,	r13	;
    8652:	ad 00 12 00 	adda	#18,	r13	;0x00012
    8656:	cc 08       	mova	r8,	r12	;
    8658:	b0 13 ee 64 	calla	#25838		;0x064ee

0000865c <.LVL867>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    865c:	0d 45       	mov	r5,	r13	;
    865e:	cc 08       	mova	r8,	r12	;
    8660:	b0 13 54 69 	calla	#26964		;0x06954

00008664 <.LVL868>:
    8664:	80 00 5a 85 	mova	#34138,	r0	;0x0855a

00008668 <.L583>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    8668:	cc 08       	mova	r8,	r12	;
    866a:	46 13       	calla	r6		;

0000866c <.LVL870>:
    866c:	b0 13 ca 62 	calla	#25290		;0x062ca

00008670 <.LVL871>:
    8670:	80 00 5a 85 	mova	#34138,	r0	;0x0855a

00008674 <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8674:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008676 <.LCFI103>:
    8676:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

0000867a <.LCFI104>:
    867a:	2f 4d       	mov	@r13,	r15	;

0000867c <.LVL873>:
    867c:	16 4d 02 00 	mov	2(r13),	r6	;

00008680 <.LVL874>:
    8680:	07 4f       	mov	r15,	r7	;
    8682:	57 07       	rrum	#2,	r7	;
    8684:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f

00008688 <.Loc.358.2>:
  if (hdr.reply) { /* reply requested */
    8688:	08 47       	mov	r7,	r8	;
    868a:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    868e:	41 18 08 58 	rpt #2 { rlax.w	r8		;
    8692:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

00008696 <.LVL876>:
    8696:	08 df       	bis	r15,	r8	;
    8698:	45 48       	mov.b	r8,	r5	;
    869a:	8f 00 fa 9d 	mova	#40442,	r15	;0x09dfa
    869e:	84 00 3e 9b 	mova	#39742,	r4	;0x09b3e
    86a2:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    86a6:	0e 24       	jz	$+30     	;abs 0x86c4

000086a8 <.LBB103>:
    uint8_t * reply_buff = elyFWGetBuffer();
    86a8:	71 0c 04 00 	mova	r12,	4(r1)	;
    86ac:	71 0f 00 00 	mova	r15,	0(r1)	;
    86b0:	b0 13 a2 62 	calla	#25250		;0x062a2

000086b4 <.LVL878>:
    86b4:	ca 0c       	mova	r12,	r10	;

000086b6 <.LVL879>:
    if (reply_buff == NULL) {
    86b6:	3e 01 04 00 	mova	4(r1),	r14	;
    86ba:	0f 01       	mova	@r1,	r15	;
    86bc:	9c 00 00 00 	cmpa	#0,	r12	;
    86c0:	05 20       	jnz	$+12     	;abs 0x86cc

000086c2 <.Loc.362.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    86c2:	cc 0e       	mova	r14,	r12	;

000086c4 <.L590>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    86c4:	4f 13       	calla	r15		;

000086c6 <.LVL881>:
    86c6:	44 13       	calla	r4		;

000086c8 <.LVL882>:
    86c8:	80 00 54 87 	mova	#34644,	r0	;0x08754

000086cc <.L591>:
    uint8_t bank = buffer[4];
    86cc:	5b 4e 04 00 	mov.b	4(r14),	r11	;

000086d0 <.LVL884>:
    uint8_t addr = buffer[5];
    86d0:	5d 4e 05 00 	mov.b	5(r14),	r13	;

000086d4 <.LVL885>:
    uint8_t count = buffer[6];
    86d4:	59 4e 06 00 	mov.b	6(r14),	r9	;

000086d8 <.LVL886>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    86d8:	cc 0e       	mova	r14,	r12	;
    86da:	71 0b 04 00 	mova	r11,	4(r1)	;

000086de <.LVL887>:
    86de:	71 0d 00 00 	mova	r13,	0(r1)	;
    86e2:	4f 13       	calla	r15		;

000086e4 <.LVL888>:
    86e4:	44 13       	calla	r4		;

000086e6 <.LVL889>:
    if (bank > 4 || 
    86e6:	3b 01 04 00 	mova	4(r1),	r11	;
    86ea:	0d 01       	mova	@r1,	r13	;
    86ec:	6c 42       	mov.b	#4,	r12	;r2 As==10
    86ee:	4c 9b       	cmp.b	r11,	r12	;
    86f0:	23 28       	jnc	$+72     	;abs 0x8738

000086f2 <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    86f2:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    86f6:	57 00 
    86f8:	40 18 0c 89 	subx.w	r9,	r12	;

000086fc <.Loc.373.2>:
    if (bank > 4 || 
    86fc:	0d 9c       	cmp	r12,	r13	;
    86fe:	04 38       	jl	$+10     	;abs 0x8708

00008700 <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    8700:	7e 40 5f 00 	mov.b	#95,	r14	;#0x005f
    8704:	4e 9d       	cmp.b	r13,	r14	;
    8706:	18 2c       	jc	$+50     	;abs 0x8738

00008708 <.L594>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    8708:	4c 4d       	mov.b	r13,	r12	;
    870a:	7c 50 89 ff 	add.b	#-119,	r12	;#0xff89

0000870e <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    870e:	7e 42       	mov.b	#8,	r14	;r2 As==11
    8710:	4e 9c       	cmp.b	r12,	r14	;
    8712:	12 2c       	jc	$+38     	;abs 0x8738

00008714 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8714:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    8718:	8b 00 
    871a:	40 18 0c 89 	subx.w	r9,	r12	;

0000871e <.Loc.375.2>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    871e:	0d 9c       	cmp	r12,	r13	;
    8720:	04 38       	jl	$+10     	;abs 0x872a

00008722 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8722:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    8726:	4c 9d       	cmp.b	r13,	r12	;
    8728:	07 2c       	jc	$+16     	;abs 0x8738

0000872a <.L595>:
        (addr >= RegDLLMAX - count + 1)) {
    872a:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    872e:	d6 00 
    8730:	40 18 0c 89 	subx.w	r9,	r12	;

00008734 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8734:	0d 9c       	cmp	r12,	r13	;
    8736:	12 38       	jl	$+38     	;abs 0x875c

00008738 <.L593>:
      write_failure(reply_buff, hdr);
    8738:	81 48 08 00 	mov	r8,	8(r1)	;
    873c:	81 46 0a 00 	mov	r6,	10(r1)	; 0x000a
    8740:	cd 01       	mova	r1,	r13	;
    8742:	ad 00 08 00 	adda	#8,	r13	;
    8746:	cc 0a       	mova	r10,	r12	;
    8748:	b0 13 0c 63 	calla	#25356		;0x0630c

0000874c <.L598>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    874c:	0d 46       	mov	r6,	r13	;
    874e:	cc 0a       	mova	r10,	r12	;
    8750:	b0 13 54 69 	calla	#26964		;0x06954

00008754 <.L589>:
}
    8754:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    8758:	64 16       	popm.a	#7,	r10	;20-bit words
    875a:	10 01       	reta			;

0000875c <.L596>:
    elyRegGetBlock(bank, reply_buff + 4, addr, count);
    875c:	4f 49       	mov.b	r9,	r15	;
    875e:	4e 4d       	mov.b	r13,	r14	;
    8760:	cd 0a       	mova	r10,	r13	;
    8762:	ad 00 04 00 	adda	#4,	r13	;
    8766:	4c 4b       	mov.b	r11,	r12	;
    8768:	b0 13 92 90 	calla	#37010		;0x09092

0000876c <.LVL894>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    876c:	ca 47 00 00 	mov.b	r7,	0(r10)	;

00008770 <.Loc.386.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8770:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    8774:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8778:	02 00 

0000877a <.Loc.387.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    877a:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    877e:	03 00 

00008780 <.Loc.389.2>:
    if (hdr.crc) {
    8780:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    8784:	0e 24       	jz	$+30     	;abs 0x87a2

00008786 <.Loc.390.2>:
      reply_buff[1] = count + 2; 
    8786:	4e 49       	mov.b	r9,	r14	;
    8788:	6e 53       	incd.b	r14		;
    878a:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

0000878e <.Loc.391.2>:
      crcGenX25(reply_buff, count + 6);
    878e:	0d 49       	mov	r9,	r13	;
    8790:	3d 50 06 00 	add	#6,	r13	;
    8794:	4d 0e       	rlam.a	#4,	r13	;
    8796:	4d 0d       	rram.a	#4,	r13	;
    8798:	cc 0a       	mova	r10,	r12	;
    879a:	b0 13 d4 95 	calla	#38356		;0x095d4

0000879e <.LVL895>:
    879e:	80 00 4c 87 	mova	#34636,	r0	;0x0874c

000087a2 <.L597>:
      reply_buff[1] = count; 
    87a2:	ca 49 01 00 	mov.b	r9,	1(r10)	;
    87a6:	80 00 4c 87 	mova	#34636,	r0	;0x0874c

000087aa <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    87aa:	6a 14       	pushm.a	#7,	r10	;20-bit words

000087ac <.LCFI105>:
    87ac:	b1 00 10 00 	suba	#16,	r1	;0x00010

000087b0 <.LCFI106>:
    87b0:	c8 0c       	mova	r12,	r8	;
    87b2:	25 4d       	mov	@r13,	r5	;

000087b4 <.LVL897>:
    87b4:	91 4d 02 00 	mov	2(r13),	2(r1)	;
    87b8:	02 00 
    87ba:	09 45       	mov	r5,	r9	;
    87bc:	59 0f       	rrum	#4,	r9	;
    87be:	59 0f       	rrum	#4,	r9	;

000087c0 <.Loc.309.2>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    87c0:	4c 45       	mov.b	r5,	r12	;

000087c2 <.LVL899>:
    87c2:	44 4c       	mov.b	r12,	r4	;
    87c4:	64 f3       	and.b	#2,	r4	;r3 As==10
    87c6:	34 f0 ff 00 	and	#255,	r4	;#0x00ff
    87ca:	04 93       	cmp	#0,	r4	;r3 As==00
    87cc:	5b 24       	jz	$+184    	;abs 0x8884

000087ce <.Loc.309.2>:
    87ce:	57 48 04 00 	mov.b	4(r8),	r7	;

000087d2 <.LVL900>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    87d2:	76 40 05 00 	mov.b	#5,	r6	;

000087d6 <.L601>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    87d6:	1c b3       	bit	#1,	r12	;r3 As==01
    87d8:	5b 20       	jnz	$+184    	;abs 0x8890

000087da <.Loc.311.2>:
    87da:	4d 43       	clr.b	r13		;

000087dc <.L602>:
    87dc:	40 18 0c 49 	movx.w	r9,	r12	;
    87e0:	40 18 0c 8d 	subx.w	r13,	r12	;
    87e4:	0c 84       	sub	r4,	r12	;
    87e6:	0d 4c       	mov	r12,	r13	;
    87e8:	5d 03       	rrum	#1,	r13	;
    87ea:	4d 18 0d 11 	rpt #14 { rrax.w	r13		;
    87ee:	0c 5d       	add	r13,	r12	;
    87f0:	0c 11       	rra	r12		;
    87f2:	81 4c 08 00 	mov	r12,	8(r1)	;

000087f6 <.LVL903>:
  uint8_t * reply_buff = elyFWGetBuffer();
    87f6:	b0 13 a2 62 	calla	#25250		;0x062a2

000087fa <.LVL904>:
    87fa:	ca 0c       	mova	r12,	r10	;

000087fc <.LVL905>:
  if (reply_buff == NULL) {
    87fc:	9c 00 00 00 	cmpa	#0,	r12	;
    8800:	7a 24       	jz	$+246    	;abs 0x88f6

00008802 <.LBB106>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    8802:	1b 41 08 00 	mov	8(r1),	r11	;
    8806:	7b f0 ff 00 	and.b	#255,	r11	;#0x00ff
    880a:	0b 5b       	rla	r11		;
    880c:	81 4b 00 00 	mov	r11,	0(r1)	;
    8810:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    8814:	04 00 
    8816:	36 01 04 00 	mova	4(r1),	r6	;

0000881a <.LVL906>:
    881a:	e6 0c       	adda	r12,	r6	;
    881c:	3e 01 04 00 	mova	4(r1),	r14	;
    8820:	ee 08       	adda	r8,	r14	;
    8822:	4d 43       	clr.b	r13		;

00008824 <.LBB107>:
    if ((bank == 0) || (bank > 4) ||
    8824:	4b 47       	mov.b	r7,	r11	;
    8826:	7b 53       	add.b	#-1,	r11	;r3 As==11
    8828:	c1 4b 0b 00 	mov.b	r11,	11(r1)	; 0x000b

0000882c <.L604>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    882c:	2d 91       	cmp	@r1,	r13	;
    882e:	33 38       	jl	$+104    	;abs 0x8896

00008830 <.LBE106>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8830:	86 00 fa 9d 	mova	#40442,	r6	;0x09dfa
    8834:	cc 08       	mova	r8,	r12	;
    8836:	46 13       	calla	r6		;

00008838 <.LVL908>:
    8838:	b0 13 3e 9b 	calla	#39742		;0x09b3e

0000883c <.LVL909>:
  elyRegSet(bank, reply_buff + regs_offset-1, num_regs);
    883c:	3d 01 04 00 	mova	4(r1),	r13	;
    8840:	ad 0f ff ff 	adda	#1048575,r13	;0xfffff
    8844:	1b 41 08 00 	mov	8(r1),	r11	;
    8848:	4e 4b       	mov.b	r11,	r14	;
    884a:	ed 0a       	adda	r10,	r13	;
    884c:	4c 47       	mov.b	r7,	r12	;
    884e:	b0 13 26 90 	calla	#36902		;0x09026

00008852 <.LVL910>:
  if (hdr.reply) {
    8852:	04 93       	cmp	#0,	r4	;r3 As==00
    8854:	63 24       	jz	$+200    	;abs 0x891c

00008856 <.Loc.347.2>:
    write_success(reply_buff, hdr);
    8856:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    885a:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

0000885e <.LVL912>:
    885e:	05 d9       	bis	r9,	r5	;
    8860:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    8864:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    8868:	0e 00 
    886a:	cd 01       	mova	r1,	r13	;
    886c:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    8870:	cc 0a       	mova	r10,	r12	;
    8872:	b0 13 ee 64 	calla	#25838		;0x064ee

00008876 <.LVL913>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8876:	1d 41 02 00 	mov	2(r1),	r13	;
    887a:	cc 0a       	mova	r10,	r12	;
    887c:	b0 13 54 69 	calla	#26964		;0x06954

00008880 <.LVL914>:
    8880:	80 00 00 89 	mova	#35072,	r0	;0x08900

00008884 <.L600>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8884:	57 48 02 00 	mov.b	2(r8),	r7	;

00008888 <.LVL916>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8888:	76 40 03 00 	mov.b	#3,	r6	;
    888c:	80 00 d6 87 	mova	#34774,	r0	;0x087d6

00008890 <.L611>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8890:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8892:	80 00 dc 87 	mova	#34780,	r0	;0x087dc

00008896 <.L609>:
    uint8_t addr = buffer[i + regs_offset];
    8896:	6c 4e       	mov.b	@r14,	r12	;

00008898 <.LVL920>:
    if ((bank == 0) || (bank > 4) ||
    8898:	7f 40 03 00 	mov.b	#3,	r15	;
    889c:	5f 91 0b 00 	cmp.b	11(r1),	r15	;0x0000b
    88a0:	13 28       	jnc	$+40     	;abs 0x88c8

000088a2 <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    88a2:	4f 4c       	mov.b	r12,	r15	;
    88a4:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

000088a8 <.Loc.323.2>:
    if ((bank == 0) || (bank > 4) ||
    88a8:	7b 40 29 00 	mov.b	#41,	r11	;#0x0029
    88ac:	4b 9f       	cmp.b	r15,	r11	;
    88ae:	0c 2c       	jc	$+26     	;abs 0x88c8

000088b0 <.Loc.325.2>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    88b0:	7f 50 cc ff 	add.b	#-52,	r15	;#0xffcc

000088b4 <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    88b4:	7b 40 35 00 	mov.b	#53,	r11	;#0x0035
    88b8:	4b 9f       	cmp.b	r15,	r11	;
    88ba:	06 2c       	jc	$+14     	;abs 0x88c8
    88bc:	ae 00 02 00 	adda	#2,	r14	;

000088c0 <.LVL921>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    88c0:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    88c4:	4f 9c       	cmp.b	r12,	r15	;
    88c6:	20 2c       	jc	$+66     	;abs 0x8908

000088c8 <.L606>:
      if (hdr.reply) {
    88c8:	04 93       	cmp	#0,	r4	;r3 As==00
    88ca:	15 24       	jz	$+44     	;abs 0x88f6

000088cc <.Loc.328.2>:
        write_failure(reply_buff, hdr);
    88cc:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    88d0:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

000088d4 <.LVL924>:
    88d4:	05 d9       	bis	r9,	r5	;
    88d6:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    88da:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    88de:	0e 00 
    88e0:	cd 01       	mova	r1,	r13	;

000088e2 <.LVL925>:
    88e2:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    88e6:	cc 0a       	mova	r10,	r12	;

000088e8 <.LVL926>:
    88e8:	b0 13 0c 63 	calla	#25356		;0x0630c

000088ec <.LVL927>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    88ec:	1d 41 02 00 	mov	2(r1),	r13	;
    88f0:	cc 0a       	mova	r10,	r12	;
    88f2:	b0 13 54 69 	calla	#26964		;0x06954

000088f6 <.L608>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    88f6:	cc 08       	mova	r8,	r12	;
    88f8:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000088fc <.LVL929>:
    88fc:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008900 <.L599>:
}
    8900:	a1 00 10 00 	adda	#16,	r1	;0x00010
    8904:	64 16       	popm.a	#7,	r10	;20-bit words
    8906:	10 01       	reta			;

00008908 <.L607>:
    reply_buff[i+regs_offset-1] = addr;
    8908:	c6 4c ff ff 	mov.b	r12,	-1(r6)	; 0xffff

0000890c <.LVL932>:
    reply_buff[i+regs_offset] = buffer[i+regs_offset+1];
    890c:	d6 4e ff ff 	mov.b	-1(r14),0(r6)	;
    8910:	00 00 

00008912 <.LBE109>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    8912:	2d 53       	incd	r13		;
    8914:	a6 00 02 00 	adda	#2,	r6	;
    8918:	80 00 2c 88 	mova	#34860,	r0	;0x0882c

0000891c <.L610>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    891c:	cc 0a       	mova	r10,	r12	;
    891e:	46 13       	calla	r6		;

00008920 <.LVL935>:
    8920:	b0 13 ca 62 	calla	#25290		;0x062ca

00008924 <.LVL936>:
    8924:	80 00 00 89 	mova	#35072,	r0	;0x08900

00008928 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8928:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000892a <.LCFI107>:
    892a:	b1 00 12 00 	suba	#18,	r1	;0x00012

0000892e <.LCFI108>:
    892e:	c8 0c       	mova	r12,	r8	;
    8930:	2e 4d       	mov	@r13,	r14	;

00008932 <.LVL938>:
    8932:	16 4d 02 00 	mov	2(r13),	r6	;

00008936 <.LVL939>:
    8936:	0d 4e       	mov	r14,	r13	;
    8938:	5d 07       	rrum	#2,	r13	;
    893a:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    893e:	c1 4d 0a 00 	mov.b	r13,	10(r1)	; 0x000a
    8942:	09 4e       	mov	r14,	r9	;
    8944:	59 0f       	rrum	#4,	r9	;
    8946:	59 0f       	rrum	#4,	r9	;
    8948:	81 49 08 00 	mov	r9,	8(r1)	;

0000894c <.Loc.252.2>:
  if (hdr.reply) {
    894c:	49 4d       	mov.b	r13,	r9	;
    894e:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
    8952:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    8956:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

0000895a <.LVL941>:
    895a:	09 de       	bis	r14,	r9	;
    895c:	81 49 00 00 	mov	r9,	0(r1)	;
    8960:	07 49       	mov	r9,	r7	;
    8962:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    8966:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    896a:	07 24       	jz	$+16     	;abs 0x897a

0000896c <.LBB112>:
    uint8_t * reply_buff = elyFWGetBuffer();
    896c:	b0 13 a2 62 	calla	#25250		;0x062a2

00008970 <.LVL942>:
    8970:	ca 0c       	mova	r12,	r10	;

00008972 <.LVL943>:
    if (reply_buff == NULL) {
    8972:	9c 00 00 00 	cmpa	#0,	r12	;
    8976:	07 20       	jnz	$+16     	;abs 0x8986

00008978 <.L627>:
        elyNLFreeBuffer(elyNLFromFW(buffer));
    8978:	cc 08       	mova	r8,	r12	;

0000897a <.L616>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    897a:	b0 13 fa 9d 	calla	#40442		;0x09dfa

0000897e <.LVL945>:
    897e:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008982 <.LVL946>:
    8982:	80 00 14 8a 	mova	#35348,	r0	;0x08a14

00008986 <.L617>:
    uint8_t bank = buffer[4];
    8986:	54 48 04 00 	mov.b	4(r8),	r4	;

0000898a <.LVL948>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    898a:	57 f3       	and.b	#1,	r7	;r3 As==01
    898c:	07 93       	cmp	#0,	r7	;r3 As==00
    898e:	46 20       	jnz	$+142    	;abs 0x8a1c
    8990:	0c 47       	mov	r7,	r12	;

00008992 <.L619>:
    8992:	1f 41 08 00 	mov	8(r1),	r15	;
    8996:	4f 8c       	sub.b	r12,	r15	;
    8998:	c1 4f 0d 00 	mov.b	r15,	13(r1)	; 0x000d
    899c:	45 4f       	mov.b	r15,	r5	;
    899e:	75 50 fd ff 	add.b	#-3,	r5	;#0xfffd
    89a2:	49 45       	mov.b	r5,	r9	;
    89a4:	81 49 02 00 	mov	r9,	2(r1)	;

000089a8 <.LVL949>:
    89a8:	cd 0a       	mova	r10,	r13	;
    89aa:	ad 00 04 00 	adda	#4,	r13	;
    89ae:	71 0d 04 00 	mova	r13,	4(r1)	;
    89b2:	cb 08       	mova	r8,	r11	;
    89b4:	ab 00 05 00 	adda	#5,	r11	;

000089b8 <.LBB116>:
    for (int i = 0; i < num_regs; i++) {
    89b8:	4e 43       	clr.b	r14		;

000089ba <.L620>:
    89ba:	1e 91 02 00 	cmp	2(r1),	r14	;
    89be:	31 38       	jl	$+100    	;abs 0x8a22

000089c0 <.LBE116>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    89c0:	cc 08       	mova	r8,	r12	;
    89c2:	b0 13 fa 9d 	calla	#40442		;0x09dfa

000089c6 <.LVL951>:
    89c6:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000089ca <.LVL952>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    89ca:	da 41 0a 00 	mov.b	10(r1),	0(r10)	;0x0000a
    89ce:	00 00 

000089d0 <.Loc.287.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    89d0:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    89d4:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    89d8:	02 00 

000089da <.Loc.288.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    89da:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    89de:	03 00 

000089e0 <.Loc.291.2>:
    elyRegGet(bank, reply_buff + 4, num_regs);
    89e0:	4e 45       	mov.b	r5,	r14	;
    89e2:	3d 01 04 00 	mova	4(r1),	r13	;
    89e6:	4c 44       	mov.b	r4,	r12	;
    89e8:	b0 13 ca 8f 	calla	#36810		;0x08fca

000089ec <.LVL953>:
    if (hdr.crc) {
    89ec:	07 93       	cmp	#0,	r7	;r3 As==00
    89ee:	54 24       	jz	$+170    	;abs 0x8a98

000089f0 <.Loc.294.2>:
      reply_buff[1] = num_regs + 2;
    89f0:	59 41 0d 00 	mov.b	13(r1),	r9	;0x0000d
    89f4:	79 53       	add.b	#-1,	r9	;r3 As==11
    89f6:	ca 49 01 00 	mov.b	r9,	1(r10)	;

000089fa <.Loc.295.2>:
      crcGenX25(reply_buff, num_regs + 6);
    89fa:	1d 41 02 00 	mov	2(r1),	r13	;
    89fe:	3d 50 06 00 	add	#6,	r13	;
    8a02:	4d 0e       	rlam.a	#4,	r13	;
    8a04:	4d 0d       	rram.a	#4,	r13	;
    8a06:	cc 0a       	mova	r10,	r12	;
    8a08:	b0 13 d4 95 	calla	#38356		;0x095d4

00008a0c <.L625>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8a0c:	0d 46       	mov	r6,	r13	;
    8a0e:	cc 0a       	mova	r10,	r12	;
    8a10:	b0 13 54 69 	calla	#26964		;0x06954

00008a14 <.L615>:
}
    8a14:	a1 00 12 00 	adda	#18,	r1	;0x00012
    8a18:	64 16       	popm.a	#7,	r10	;20-bit words
    8a1a:	10 01       	reta			;

00008a1c <.L626>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8a1c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8a1e:	80 00 92 89 	mova	#35218,	r0	;0x08992

00008a22 <.L623>:
      uint8_t addr = buffer[i + regs_offset];
    8a22:	6c 4b       	mov.b	@r11,	r12	;

00008a24 <.LVL958>:
      if ((bank > 4) ||
    8a24:	69 42       	mov.b	#4,	r9	;r2 As==10
    8a26:	49 94       	cmp.b	r4,	r9	;
    8a28:	18 28       	jnc	$+50     	;abs 0x8a5a

00008a2a <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    8a2a:	4f 4c       	mov.b	r12,	r15	;
    8a2c:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00008a30 <.Loc.269.2>:
      if ((bank > 4) ||
    8a30:	79 40 09 00 	mov.b	#9,	r9	;
    8a34:	49 9f       	cmp.b	r15,	r9	;
    8a36:	11 2c       	jc	$+36     	;abs 0x8a5a

00008a38 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8a38:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

00008a3c <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    8a3c:	79 42       	mov.b	#8,	r9	;r2 As==11
    8a3e:	49 9f       	cmp.b	r15,	r9	;
    8a40:	0c 2c       	jc	$+26     	;abs 0x8a5a

00008a42 <.Loc.272.2>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    8a42:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00008a46 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8a46:	79 40 35 00 	mov.b	#53,	r9	;#0x0035
    8a4a:	49 9f       	cmp.b	r15,	r9	;
    8a4c:	06 2c       	jc	$+14     	;abs 0x8a5a
    8a4e:	ab 00 01 00 	adda	#1,	r11	;

00008a52 <.LVL959>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    8a52:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    8a56:	4f 9c       	cmp.b	r12,	r15	;
    8a58:	18 2c       	jc	$+50     	;abs 0x8a8a

00008a5a <.L621>:
        write_failure(reply_buff, hdr);
    8a5a:	1d 41 08 00 	mov	8(r1),	r13	;
    8a5e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    8a62:	29 41       	mov	@r1,	r9	;
    8a64:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    8a68:	09 dd       	bis	r13,	r9	;
    8a6a:	81 49 0e 00 	mov	r9,	14(r1)	; 0x000e
    8a6e:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    8a72:	cd 01       	mova	r1,	r13	;
    8a74:	ad 00 0e 00 	adda	#14,	r13	;0x0000e
    8a78:	cc 0a       	mova	r10,	r12	;

00008a7a <.LVL961>:
    8a7a:	b0 13 0c 63 	calla	#25356		;0x0630c

00008a7e <.LVL962>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    8a7e:	0d 46       	mov	r6,	r13	;
    8a80:	cc 0a       	mova	r10,	r12	;
    8a82:	b0 13 54 69 	calla	#26964		;0x06954

00008a86 <.LVL963>:
    8a86:	80 00 78 89 	mova	#35192,	r0	;0x08978

00008a8a <.L622>:
      reply_buff[i+4] = addr;
    8a8a:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

00008a8e <.LBE115>:
    for (int i = 0; i < num_regs; i++) {
    8a8e:	1e 53       	inc	r14		;
    8a90:	ad 00 01 00 	adda	#1,	r13	;
    8a94:	80 00 ba 89 	mova	#35258,	r0	;0x089ba

00008a98 <.L624>:
      reply_buff[1] = num_regs;
    8a98:	ca 45 01 00 	mov.b	r5,	1(r10)	;
    8a9c:	80 00 0c 8a 	mova	#35340,	r0	;0x08a0c

00008aa0 <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8aa0:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008aa2 <.LCFI109>:
    8aa2:	2a 4d       	mov	@r13,	r10	;

00008aa4 <.LVL969>:
    8aa4:	17 4d 02 00 	mov	2(r13),	r7	;

00008aa8 <.LVL970>:
    8aa8:	49 4a       	mov.b	r10,	r9	;
    8aaa:	59 f3       	and.b	#1,	r9	;r3 As==01
    8aac:	45 49       	mov.b	r9,	r5	;
    8aae:	08 4a       	mov	r10,	r8	;
    8ab0:	58 07       	rrum	#2,	r8	;
    8ab2:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    8ab6:	46 48       	mov.b	r8,	r6	;

00008ab8 <.Loc.229.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8ab8:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00008abc <.LVL972>:
    8abc:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008ac0 <.LVL973>:
  if (hdr.reply) { /* reply requested */
    8ac0:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

00008ac4 <.LVL974>:
    8ac4:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    8ac8:	0a d5       	bis	r5,	r10	;
    8aca:	0a d6       	bis	r6,	r10	;
    8acc:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8ad0:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    8ad4:	22 24       	jz	$+70     	;abs 0x8b1a

00008ad6 <.LBB120>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8ad6:	b0 13 a2 62 	calla	#25250		;0x062a2

00008ada <.LVL975>:
    8ada:	c6 0c       	mova	r12,	r6	;

00008adc <.LVL976>:
    if (reply_buff == NULL) {
    8adc:	9c 00 00 00 	cmpa	#0,	r12	;
    8ae0:	1c 24       	jz	$+58     	;abs 0x8b1a

00008ae2 <.Loc.238.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8ae2:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00008ae6 <.Loc.239.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8ae6:	49 59       	rla.b	r9		;
    8ae8:	59 53       	inc.b	r9		;
    8aea:	cc 49 01 00 	mov.b	r9,	1(r12)	;

00008aee <.Loc.240.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8aee:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    8af2:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8af6:	02 00 

00008af8 <.Loc.241.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8af8:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8afc:	03 00 

00008afe <.Loc.242.2>:
    reply_buff[4] = bank0p[RegActiveBank];
    8afe:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    8b02:	04 00 

00008b04 <.Loc.243.2>:
    if (hdr.crc) {
    8b04:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    8b08:	04 24       	jz	$+10     	;abs 0x8b12

00008b0a <.Loc.244.2>:
      crcGenX25(reply_buff, 7);
    8b0a:	7d 40 07 00 	mov.b	#7,	r13	;
    8b0e:	b0 13 d4 95 	calla	#38356		;0x095d4

00008b12 <.L632>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8b12:	0d 47       	mov	r7,	r13	;
    8b14:	cc 06       	mova	r6,	r12	;
    8b16:	b0 13 54 69 	calla	#26964		;0x06954

00008b1a <.L628>:
}
    8b1a:	55 16       	popm.a	#6,	r10	;20-bit words
    8b1c:	10 01       	reta			;

00008b1e <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8b1e:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008b20 <.LCFI110>:
    8b20:	2a 4d       	mov	@r13,	r10	;

00008b22 <.LVL981>:
    8b22:	17 4d 02 00 	mov	2(r13),	r7	;

00008b26 <.LVL982>:
    8b26:	49 4a       	mov.b	r10,	r9	;
    8b28:	59 f3       	and.b	#1,	r9	;r3 As==01
    8b2a:	45 49       	mov.b	r9,	r5	;
    8b2c:	08 4a       	mov	r10,	r8	;
    8b2e:	58 07       	rrum	#2,	r8	;
    8b30:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    8b34:	46 48       	mov.b	r8,	r6	;

00008b36 <.Loc.173.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8b36:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00008b3a <.LVL984>:
    8b3a:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008b3e <.LVL985>:
  if (hdr.reply) { /* reply requested */
    8b3e:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

00008b42 <.LVL986>:
    8b42:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    8b46:	0a d5       	bis	r5,	r10	;
    8b48:	0a d6       	bis	r6,	r10	;
    8b4a:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8b4e:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    8b52:	22 24       	jz	$+70     	;abs 0x8b98

00008b54 <.LBB121>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8b54:	b0 13 a2 62 	calla	#25250		;0x062a2

00008b58 <.LVL987>:
    8b58:	c6 0c       	mova	r12,	r6	;

00008b5a <.LVL988>:
    if (reply_buff == NULL) {
    8b5a:	9c 00 00 00 	cmpa	#0,	r12	;
    8b5e:	1c 24       	jz	$+58     	;abs 0x8b98

00008b60 <.Loc.182.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8b60:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00008b64 <.Loc.183.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8b64:	49 59       	rla.b	r9		;
    8b66:	59 53       	inc.b	r9		;
    8b68:	cc 49 01 00 	mov.b	r9,	1(r12)	;

00008b6c <.Loc.184.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8b6c:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca
    8b70:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8b74:	02 00 

00008b76 <.Loc.185.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8b76:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8b7a:	03 00 

00008b7c <.Loc.186.2>:
    reply_buff[4] = bank0p[RegGPOState];
    8b7c:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    8b80:	04 00 

00008b82 <.Loc.187.2>:
    if (hdr.crc) {
    8b82:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    8b86:	04 24       	jz	$+10     	;abs 0x8b90

00008b88 <.Loc.188.2>:
      crcGenX25(reply_buff, 7);
    8b88:	7d 40 07 00 	mov.b	#7,	r13	;
    8b8c:	b0 13 d4 95 	calla	#38356		;0x095d4

00008b90 <.L643>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8b90:	0d 47       	mov	r7,	r13	;
    8b92:	cc 06       	mova	r6,	r12	;
    8b94:	b0 13 54 69 	calla	#26964		;0x06954

00008b98 <.L639>:
}
    8b98:	55 16       	popm.a	#6,	r10	;20-bit words
    8b9a:	10 01       	reta			;

00008b9c <CmdThd>:

THD_WORKING_AREA(waCmdThd, 256);
THD_FUNCTION(CmdThd, arg) {
    8b9c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008b9e <.LCFI111>:
    8b9e:	08 14       	pushm.a	#1,	r8	;20-bit words

00008ba0 <.LCFI112>:
    8ba0:	26 14       	pushm.a	#3,	r6	;20-bit words

00008ba2 <.LCFI113>:
    8ba2:	b1 00 04 00 	suba	#4,	r1	;

00008ba6 <.LBB122>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    8ba6:	88 00 8e 4b 	mova	#19342,	r8	;0x04b8e

00008baa <.Loc.1793.2>:
    }
    
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    8baa:	8a 00 ee 9d 	mova	#40430,	r10	;0x09dee

00008bae <.L654>:
    if (NULL == active_buffer) {
    8bae:	00 18 c2 93 	cmpx.a	#0,	&0xfc868;r3 As==00
    8bb2:	68 c8 
    8bb4:	06 20       	jnz	$+14     	;abs 0x8bc2

00008bb6 <.Loc.1790.2>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    8bb6:	4e 43       	clr.b	r14		;
    8bb8:	8d 00 68 c8 	mova	#51304,	r13	;0x0c868
    8bbc:	8c 01 ea 06 	mova	#67306,	r12	;0x106ea
    8bc0:	48 13       	calla	r8		;

00008bc2 <.L651>:
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    8bc2:	2c 00 68 c8 	mova	&51304,	r12	;0x0c868
    8bc6:	4a 13       	calla	r10		;

00008bc8 <.LVL995>:
    8bc8:	c6 0c       	mova	r12,	r6	;

00008bca <.Loc.1796.2>:
    elysium_cmd_hdr_t hdr;
    
    hdr = elyCmdParse(cmd_buffer);
    8bca:	cd 0c       	mova	r12,	r13	;
    8bcc:	cc 01       	mova	r1,	r12	;
    8bce:	b0 13 56 65 	calla	#25942		;0x06556

00008bd2 <.LVL997>:
    8bd2:	24 41       	mov	@r1,	r4	;

00008bd4 <.LVL998>:
    8bd4:	15 41 02 00 	mov	2(r1),	r5	;

00008bd8 <.Loc.1797.2>:
    if (elyCmdValidate(hdr, cmd_buffer)) {
    8bd8:	cd 06       	mova	r6,	r13	;
    8bda:	cc 01       	mova	r1,	r12	;
    8bdc:	b0 13 aa 65 	calla	#26026		;0x065aa

00008be0 <.LVL999>:
    8be0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8be2:	0d 24       	jz	$+28     	;abs 0x8bfe

00008be4 <.Loc.1798.2>:
      elyCmdDispatch(hdr, cmd_buffer);
    8be4:	81 44 00 00 	mov	r4,	0(r1)	;

00008be8 <.LVL1000>:
    8be8:	81 45 02 00 	mov	r5,	2(r1)	;
    8bec:	cd 06       	mova	r6,	r13	;
    8bee:	cc 01       	mova	r1,	r12	;
    8bf0:	b0 13 1e 68 	calla	#26654		;0x0681e

00008bf4 <.L653>:
      /* Invalid command - free the buffer (guaranteed to be NL) */
      elyNLFreeBuffer(active_buffer);
    }
    
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    8bf4:	00 18 c2 43 	movx.a	#0,	&0xfc868;r3 As==00
    8bf8:	68 c8 

00008bfa <.LBE122>:
  while (true) {
    8bfa:	80 00 ae 8b 	mova	#35758,	r0	;0x08bae

00008bfe <.L652>:
      elyNLFreeBuffer(active_buffer);
    8bfe:	2c 00 68 c8 	mova	&51304,	r12	;0x0c868
    8c02:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00008c06 <.LVL1003>:
    8c06:	80 00 f4 8b 	mova	#35828,	r0	;0x08bf4

00008c0a <clamp>:

/* TODO persistent, really? */
static BSEMAPHORE_DECL(regs_sem, 1); /* 1 is taken which is cnt == 0 */
static uint8_t regs_in_progress = 0;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    8c0a:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008c0c <.LCFI0>:
    8c0c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c10:	49 4d       	mov.b	r13,	r9	;
    8c12:	4a 4e       	mov.b	r14,	r10	;

00008c14 <.Loc.153.1>:
  if (value < min) {
    8c14:	4c 99       	cmp.b	r9,	r12	;
    8c16:	07 2c       	jc	$+16     	;abs 0x8c26

00008c18 <.LVL1>:
    value = min;
    elyErrorSignal(ErrRegClip);
    8c18:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c1c:	b0 13 2a 91 	calla	#37162		;0x0912a

00008c20 <.LVL2>:
    8c20:	0c 49       	mov	r9,	r12	;

00008c22 <.L3>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    8c22:	19 16       	popm.a	#2,	r10	;20-bit words
    8c24:	10 01       	reta			;

00008c26 <.L2>:
  else if (value > max) {
    8c26:	4a 9c       	cmp.b	r12,	r10	;
    8c28:	fc 2f       	jc	$-6      	;abs 0x8c22

00008c2a <.LVL5>:
    elyErrorSignal(ErrRegClip);
    8c2a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c2e:	b0 13 2a 91 	calla	#37162		;0x0912a

00008c32 <.LVL6>:
    8c32:	0c 4a       	mov	r10,	r12	;
    8c34:	80 00 22 8c 	mova	#35874,	r0	;0x08c22

00008c38 <fram_reg_cb>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    8c38:	40 18 5c 42 	movx.b	&0x0c89c,r12	;
    8c3c:	9c c8 

00008c3e <.LVL8>:
    8c3e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8c40:	40 18 c2 4c 	movx.b	r12,	&0xfc89c;
    8c44:	9c c8 

00008c46 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    8c46:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8c48:	0a 20       	jnz	$+22     	;abs 0x8c5e

00008c4a <.LBB12>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8c4a:	40 18 1c 42 	movx.w	&0x0c89e,r12	;
    8c4e:	9e c8 
    8c50:	4d 43       	clr.b	r13		;
    8c52:	0d 9c       	cmp	r12,	r13	;
    8c54:	04 38       	jl	$+10     	;abs 0x8c5e

00008c56 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8c56:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    8c5a:	b0 13 04 49 	calla	#18692		;0x04904

00008c5e <.L4>:
    chSysLockFromISR();
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
  }
}
    8c5e:	10 01       	reta			;

00008c60 <fram_block_cb>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8c60:	40 18 1c 42 	movx.w	&0x0c89e,r12	;
    8c64:	9e c8 

00008c66 <.LVL13>:
    8c66:	4d 43       	clr.b	r13		;
    8c68:	0d 9c       	cmp	r12,	r13	;
    8c6a:	04 38       	jl	$+10     	;abs 0x8c74

00008c6c <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8c6c:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    8c70:	b0 13 04 49 	calla	#18692		;0x04904

00008c74 <.L6>:
void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
}
    8c74:	10 01       	reta			;

00008c76 <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    8c76:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008c78 <.LCFI1>:
    8c78:	06 14       	pushm.a	#1,	r6	;20-bit words

00008c7a <.LCFI2>:
    8c7a:	b1 00 04 00 	suba	#4,	r1	;

00008c7e <.LCFI3>:
    8c7e:	4a 4c       	mov.b	r12,	r10	;
    8c80:	49 4d       	mov.b	r13,	r9	;
    8c82:	48 4e       	mov.b	r14,	r8	;
    8c84:	c6 0f       	mova	r15,	r6	;

00008c86 <.LBB26>:
  _disable_interrupts();
    8c86:	32 c2       	dint			
    8c88:	03 43       	nop			

00008c8a <.Loc.348.3>:
  asm volatile("nop");
    8c8a:	03 43       	nop			

00008c8c <.LBE26>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8c8c:	4d 43       	clr.b	r13		;

00008c8e <.LVL16>:
    8c8e:	cc 01       	mova	r1,	r12	;

00008c90 <.LVL17>:
    8c90:	b0 13 6c 99 	calla	#39276		;0x0996c

00008c94 <.LBB28>:
  asm volatile("nop");
    8c94:	03 43       	nop			

00008c96 <.Loc.356.3>:
  _enable_interrupts();
    8c96:	03 43       	nop			
    8c98:	32 d2       	eint			
    8c9a:	03 43       	nop			

00008c9c <.LBE28>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    8c9c:	0c 01       	mova	@r1,	r12	;
    8c9e:	39 53       	add	#-1,	r9	;r3 As==11

00008ca0 <.LVL19>:
    8ca0:	47 18 09 59 	rpt #8 { rlax.w	r9		;

00008ca4 <.LVL20>:
    8ca4:	0e 49       	mov	r9,	r14	;
    8ca6:	0f 49       	mov	r9,	r15	;
    8ca8:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8cac:	48 48       	mov.b	r8,	r8	;
    8cae:	09 43       	clr	r9		;

00008cb0 <.LVL21>:
    8cb0:	0d 48       	mov	r8,	r13	;
    8cb2:	0d 53       	add	#0,	r13	;r3 As==00
    8cb4:	19 63       	addc	#1,	r9	;r3 As==01
    8cb6:	0d 5e       	add	r14,	r13	;
    8cb8:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8cbc:	09 6f       	addc	r15,	r9	;
    8cbe:	8c 49 02 00 	mov	r9,	2(r12)	;

00008cc2 <.Loc.225.1>:
  req->read = read;
    8cc2:	5a f3       	and.b	#1,	r10	;r3 As==01

00008cc4 <.LVL22>:
    8cc4:	4a 5a       	rla.b	r10		;
    8cc6:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8cca:	6d c3       	bic.b	#2,	r13	;r3 As==10
    8ccc:	4d da       	bis.b	r10,	r13	;
    8cce:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008cd2 <.Loc.226.1>:
  req->size = 1;
    8cd2:	1d 4c 04 00 	mov	4(r12),	r13	;
    8cd6:	7d f0 03 00 	and.b	#3,	r13	;
    8cda:	2d d2       	bis	#4,	r13	;r2 As==10
    8cdc:	8c 4d 04 00 	mov	r13,	4(r12)	;
    8ce0:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    8ce4:	06 00 

00008ce6 <.Loc.227.1>:
  req->buffer = valuep;
    8ce6:	7c 06 08 00 	mova	r6,	8(r12)	;

00008cea <.Loc.228.1>:
  req->callback = fram_reg_cb;
    8cea:	00 18 fc 40 	movx.a	#35896,	12(r12)	;0x08c38, 0x0000c
    8cee:	38 8c 0c 00 

00008cf2 <.LBB30>:
  _disable_interrupts();
    8cf2:	32 c2       	dint			
    8cf4:	03 43       	nop			

00008cf6 <.Loc.348.3>:
  asm volatile("nop");
    8cf6:	03 43       	nop			

00008cf8 <.LBE30>:
  elyFramPostRequestS(req);
    8cf8:	b0 13 48 99 	calla	#39240		;0x09948

00008cfc <.LBB32>:
  asm volatile("nop");
    8cfc:	03 43       	nop			

00008cfe <.Loc.356.3>:
  _enable_interrupts();
    8cfe:	03 43       	nop			
    8d00:	32 d2       	eint			
    8d02:	03 43       	nop			

00008d04 <.LBE32>:
}
    8d04:	a1 00 04 00 	adda	#4,	r1	;
    8d08:	06 16       	popm.a	#1,	r6	;20-bit words
    8d0a:	28 16       	popm.a	#3,	r10	;20-bit words
    8d0c:	10 01       	reta			;

00008d0e <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    8d0e:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008d10 <.LCFI4>:
    8d10:	06 14       	pushm.a	#1,	r6	;20-bit words

00008d12 <.LCFI5>:
    8d12:	b1 00 08 00 	suba	#8,	r1	;

00008d16 <.LCFI6>:
    8d16:	4a 4c       	mov.b	r12,	r10	;
    8d18:	49 4d       	mov.b	r13,	r9	;
    8d1a:	48 4e       	mov.b	r14,	r8	;
    8d1c:	c6 0f       	mova	r15,	r6	;

00008d1e <.LBB42>:
  _disable_interrupts();
    8d1e:	32 c2       	dint			
    8d20:	03 43       	nop			

00008d22 <.Loc.348.3>:
  asm volatile("nop");
    8d22:	03 43       	nop			

00008d24 <.LBE42>:
  fram_req_t * req;
  
  chSysLock();
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8d24:	4d 43       	clr.b	r13		;

00008d26 <.LVL25>:
    8d26:	cc 01       	mova	r1,	r12	;

00008d28 <.LVL26>:
    8d28:	ac 00 04 00 	adda	#4,	r12	;
    8d2c:	b0 13 6c 99 	calla	#39276		;0x0996c

00008d30 <.LBB44>:
  asm volatile("nop");
    8d30:	03 43       	nop			

00008d32 <.Loc.356.3>:
  _enable_interrupts();
    8d32:	03 43       	nop			
    8d34:	32 d2       	eint			
    8d36:	03 43       	nop			

00008d38 <.LBE44>:
  chSysUnlock();
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    8d38:	3c 01 04 00 	mova	4(r1),	r12	;
    8d3c:	39 53       	add	#-1,	r9	;r3 As==11

00008d3e <.LVL28>:
    8d3e:	47 18 09 59 	rpt #8 { rlax.w	r9		;

00008d42 <.LVL29>:
    8d42:	0e 49       	mov	r9,	r14	;
    8d44:	0f 49       	mov	r9,	r15	;
    8d46:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8d4a:	48 48       	mov.b	r8,	r8	;
    8d4c:	09 43       	clr	r9		;

00008d4e <.LVL30>:
    8d4e:	0d 48       	mov	r8,	r13	;
    8d50:	0d 53       	add	#0,	r13	;r3 As==00
    8d52:	19 63       	addc	#1,	r9	;r3 As==01
    8d54:	0d 5e       	add	r14,	r13	;
    8d56:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8d5a:	09 6f       	addc	r15,	r9	;
    8d5c:	8c 49 02 00 	mov	r9,	2(r12)	;

00008d60 <.Loc.253.1>:
  req->read = read;
    8d60:	5a f3       	and.b	#1,	r10	;r3 As==01

00008d62 <.LVL31>:
    8d62:	4a 5a       	rla.b	r10		;
    8d64:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8d68:	6d c3       	bic.b	#2,	r13	;r3 As==10
    8d6a:	4d da       	bis.b	r10,	r13	;
    8d6c:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008d70 <.Loc.254.1>:
  req->size = n;
    8d70:	5d 41 1c 00 	mov.b	28(r1),	r13	;0x0001c
    8d74:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    8d78:	00 00 
    8d7a:	2d 41       	mov	@r1,	r13	;
    8d7c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8d80:	1e 4c 04 00 	mov	4(r12),	r14	;
    8d84:	7e f0 03 00 	and.b	#3,	r14	;
    8d88:	0e dd       	bis	r13,	r14	;
    8d8a:	8c 4e 04 00 	mov	r14,	4(r12)	;

00008d8e <.LVL32>:
    8d8e:	2e 41       	mov	@r1,	r14	;
    8d90:	0f 4e       	mov	r14,	r15	;
    8d92:	5f 03       	rrum	#1,	r15	;
    8d94:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    8d98:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    8d9c:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    8da0:	0a 01       	mova	@r1,	r10	;
    8da2:	0a 14       	pushm.a	#1,	r10	;20-bit words
    8da4:	0d 17       	popm	#1,	r13	;16-bit words
    8da6:	0d 17       	popm	#1,	r13	;16-bit words
    8da8:	5d f3       	and.b	#1,	r13	;r3 As==01
    8daa:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8dae:	4e df       	bis.b	r15,	r14	;
    8db0:	4e dd       	bis.b	r13,	r14	;
    8db2:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00008db6 <.Loc.255.1>:
  req->buffer = buffer;
    8db6:	7c 06 08 00 	mova	r6,	8(r12)	;

00008dba <.Loc.256.1>:
  req->callback = fram_block_cb;
    8dba:	00 18 fc 40 	movx.a	#35936,	12(r12)	;0x08c60, 0x0000c
    8dbe:	60 8c 0c 00 

00008dc2 <.LBB46>:
  _disable_interrupts();
    8dc2:	32 c2       	dint			
    8dc4:	03 43       	nop			

00008dc6 <.Loc.348.3>:
  asm volatile("nop");
    8dc6:	03 43       	nop			

00008dc8 <.LBE46>:
  
  /* TODO handle failure */
  chSysLock();
  elyFramPostRequestS(req);
    8dc8:	b0 13 48 99 	calla	#39240		;0x09948

00008dcc <.LBB48>:
  asm volatile("nop");
    8dcc:	03 43       	nop			

00008dce <.Loc.356.3>:
  _enable_interrupts();
    8dce:	03 43       	nop			
    8dd0:	32 d2       	eint			
    8dd2:	03 43       	nop			

00008dd4 <.LBE48>:
  chSysUnlock();
}
    8dd4:	a1 00 08 00 	adda	#8,	r1	;
    8dd8:	06 16       	popm.a	#1,	r6	;20-bit words
    8dda:	28 16       	popm.a	#3,	r10	;20-bit words
    8ddc:	10 01       	reta			;

00008dde <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    8dde:	4e 4c       	mov.b	r12,	r14	;
    8de0:	4c 4d       	mov.b	r13,	r12	;

00008de2 <.LVL35>:
  switch(addr) {
    8de2:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    8de6:	8d 24       	jz	$+284    	;abs 0x8f02
    8de8:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    8dec:	4f 9e       	cmp.b	r14,	r15	;
    8dee:	3b 28       	jnc	$+120    	;abs 0x8e66
    8df0:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    8df4:	78 24       	jz	$+242    	;abs 0x8ee6
    8df6:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    8dfa:	4f 9e       	cmp.b	r14,	r15	;
    8dfc:	13 28       	jnc	$+40     	;abs 0x8e24
    8dfe:	7e 90 07 00 	cmp.b	#7,	r14	;
    8e02:	6b 24       	jz	$+216    	;abs 0x8eda
    8e04:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    8e08:	6e 24       	jz	$+222    	;abs 0x8ee6
    8e0a:	7e 90 03 00 	cmp.b	#3,	r14	;
    8e0e:	14 20       	jnz	$+42     	;abs 0x8e38

00008e10 <.Loc.267.1>:
    case RegTXFreqMsb:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    8e10:	7e 40 38 00 	mov.b	#56,	r14	;#0x0038

00008e14 <.LVL36>:
    8e14:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033

00008e18 <.L92>:
      break;
    case RegOutputPower:
      value = clamp(value, TX_POW_MIN, TX_POW_MAX);
    case RegUARTBaudLsb:
    case RegSCCommBaudLsb:
      value = clamp(value, 1, 0xFF);
    8e18:	b0 13 0a 8c 	calla	#35850		;0x08c0a

00008e1c <.L91>:
    case RegPATempERR:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
      break;
    default:
      if (addr > 0x80 && addr < 0xBF) {
        value = elyNLClampReg(addr, value);
    8e1c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008e20 <.LVL39>:
    8e20:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008e24 <.L15>:
  switch(addr) {
    8e24:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    8e28:	5e 24       	jz	$+190    	;abs 0x8ee6
    8e2a:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    8e2e:	4f 9e       	cmp.b	r14,	r15	;
    8e30:	10 28       	jnc	$+34     	;abs 0x8e52
    8e32:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    8e36:	57 24       	jz	$+176    	;abs 0x8ee6

00008e38 <.L11>:
      if (addr > 0x80 && addr < 0xBF) {
    8e38:	4d 4e       	mov.b	r14,	r13	;
    8e3a:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    8e3e:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    8e42:	4f 9d       	cmp.b	r13,	r15	;
    8e44:	b8 28       	jnc	$+370    	;abs 0x8fb6

00008e46 <.Loc.322.1>:
        value = elyNLClampReg(addr, value);
    8e46:	4d 4c       	mov.b	r12,	r13	;
    8e48:	4c 4e       	mov.b	r14,	r12	;

00008e4a <.LVL42>:
    8e4a:	b0 13 24 9a 	calla	#39460		;0x09a24

00008e4e <.LVL43>:
    8e4e:	80 00 1c 8e 	mova	#36380,	r0	;0x08e1c

00008e52 <.L20>:
  switch(addr) {
    8e52:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    8e56:	4b 24       	jz	$+152    	;abs 0x8eee
    8e58:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    8e5c:	ed 23       	jnz	$-36     	;abs 0x8e38

00008e5e <.L23>:
      value = clamp(value, 1, 0xFF);
    8e5e:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    8e60:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8e62:	80 00 18 8e 	mova	#36376,	r0	;0x08e18

00008e66 <.L13>:
  switch(addr) {
    8e66:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    8e6a:	4b 24       	jz	$+152    	;abs 0x8f02
    8e6c:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    8e70:	4f 9e       	cmp.b	r14,	r15	;
    8e72:	12 28       	jnc	$+38     	;abs 0x8e98
    8e74:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    8e78:	4f 9e       	cmp.b	r14,	r15	;
    8e7a:	09 28       	jnc	$+20     	;abs 0x8e8e
    8e7c:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    8e80:	44 2c       	jc	$+138    	;abs 0x8f0a
    8e82:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    8e86:	d8 23       	jnz	$-78     	;abs 0x8e38

00008e88 <.L38>:
      return 0; /* this is purely efficiency */
    8e88:	4c 43       	clr.b	r12		;
    8e8a:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008e8e <.L25>:
  switch(addr) {
    8e8e:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    8e92:	e5 27       	jz	$-52     	;abs 0x8e5e
    8e94:	80 00 38 8e 	mova	#36408,	r0	;0x08e38

00008e98 <.L24>:
    8e98:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    8e9c:	7d 24       	jz	$+252    	;abs 0x8f98
    8e9e:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    8ea2:	4f 9e       	cmp.b	r14,	r15	;
    8ea4:	05 28       	jnc	$+12     	;abs 0x8eb0
    8ea6:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    8eaa:	ee 27       	jz	$-34     	;abs 0x8e88
    8eac:	80 00 38 8e 	mova	#36408,	r0	;0x08e38

00008eb0 <.L29>:
    8eb0:	4d 4e       	mov.b	r14,	r13	;

00008eb2 <.LVL49>:
    8eb2:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    8eb6:	7f 40 05 00 	mov.b	#5,	r15	;
    8eba:	4f 9d       	cmp.b	r13,	r15	;
    8ebc:	bd 2b       	jnc	$-132    	;abs 0x8e38

00008ebe <.LBB54>:
  if ((int8_t)(value) < min) {
    8ebe:	4d 4c       	mov.b	r12,	r13	;
    8ec0:	40 18 8d 11 	sxtx.w	r13		;
    8ec4:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    8ec8:	6a 34       	jge	$+214    	;abs 0x8f9e

00008eca <.Loc.195.1>:
    elyErrorSignal(ErrRegClip);
    8eca:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008ece <.LVL51>:
    8ece:	b0 13 2a 91 	calla	#37162		;0x0912a

00008ed2 <.LVL52>:
    value = (uint8_t)(min);
    8ed2:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    8ed6:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008eda <.L16>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    8eda:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    8ede:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b

00008ee2 <.LVL54>:
    8ee2:	80 00 18 8e 	mova	#36376,	r0	;0x08e18

00008ee6 <.L19>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    8ee6:	4e 43       	clr.b	r14		;

00008ee8 <.L93>:
      value = clamp(value, 0, 4);
    8ee8:	4d 43       	clr.b	r13		;

00008eea <.LVL56>:
    8eea:	80 00 18 8e 	mova	#36376,	r0	;0x08e18

00008eee <.L22>:
      value = clamp(value, TX_POW_MIN, TX_POW_MAX);
    8eee:	7e 40 82 ff 	mov.b	#-126,	r14	;#0xff82
    8ef2:	7d 40 3b 00 	mov.b	#59,	r13	;#0x003b

00008ef6 <.LVL58>:
    8ef6:	b0 13 0a 8c 	calla	#35850		;0x08c0a

00008efa <.LVL59>:
    8efa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008efe <.LVL60>:
    8efe:	80 00 5e 8e 	mova	#36446,	r0	;0x08e5e

00008f02 <.L12>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    8f02:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    8f06:	80 00 e8 8e 	mova	#36584,	r0	;0x08ee8

00008f0a <.L26>:
  if ((value & 0x10) && value != 0x10) {
    8f0a:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    8f0e:	10 00 
    8f10:	0a 24       	jz	$+22     	;abs 0x8f26
    8f12:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    8f16:	07 24       	jz	$+16     	;abs 0x8f26

00008f18 <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    8f18:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f1c <.LVL63>:
    8f1c:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f20 <.LVL64>:
    return 0x10;
    8f20:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

00008f24 <.L27>:
        value = elyRFDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    8f24:	10 01       	reta			;

00008f26 <.L31>:
  if ((value & 0x08) && value != 0x08) {
    8f26:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    8f2a:	09 24       	jz	$+20     	;abs 0x8f3e
    8f2c:	3c 92       	cmp	#8,	r12	;r2 As==11
    8f2e:	07 24       	jz	$+16     	;abs 0x8f3e

00008f30 <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    8f30:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f34 <.LVL67>:
    8f34:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f38 <.LVL68>:
    return 0x08;
    8f38:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8f3a:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008f3e <.L32>:
  if ((value & 0x04) && value != 0x04) {
    8f3e:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    8f42:	09 24       	jz	$+20     	;abs 0x8f56
    8f44:	2c 92       	cmp	#4,	r12	;r2 As==10
    8f46:	07 24       	jz	$+16     	;abs 0x8f56

00008f48 <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    8f48:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f4c <.LVL70>:
    8f4c:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f50 <.LVL71>:
    return 0x04;
    8f50:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8f52:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008f56 <.L33>:
  if ((value & 0x02) && value != 0x02) {
    8f56:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    8f5a:	09 24       	jz	$+20     	;abs 0x8f6e
    8f5c:	2c 93       	cmp	#2,	r12	;r3 As==10
    8f5e:	07 24       	jz	$+16     	;abs 0x8f6e

00008f60 <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    8f60:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f64 <.LVL73>:
    8f64:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f68 <.LVL74>:
    return 0x02;
    8f68:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8f6a:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008f6e <.L34>:
  if ((value & 0x01) && value != 0x01) {
    8f6e:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8f72:	09 24       	jz	$+20     	;abs 0x8f86
    8f74:	1c 93       	cmp	#1,	r12	;r3 As==01
    8f76:	07 24       	jz	$+16     	;abs 0x8f86

00008f78 <.Loc.182.1>:
    elyErrorSignal(ErrRegClip);
    8f78:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f7c <.LVL76>:
    8f7c:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f80 <.LVL77>:
    return 0x01;
    8f80:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8f82:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008f86 <.L35>:
  if (value & 0xD0) {
    8f86:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    8f8a:	cc 27       	jz	$-102    	;abs 0x8f24

00008f8c <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    8f8c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008f90 <.LVL79>:
    8f90:	b0 13 2a 91 	calla	#37162		;0x0912a

00008f94 <.LVL80>:
    8f94:	80 00 88 8e 	mova	#36488,	r0	;0x08e88

00008f98 <.L28>:
      value = clamp(value, 0, 4);
    8f98:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8f9a:	80 00 e8 8e 	mova	#36584,	r0	;0x08ee8

00008f9e <.L36>:
  else if ((int8_t)(value) > max) {
    8f9e:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    8fa2:	4e 9d       	cmp.b	r13,	r14	;
    8fa4:	bf 37       	jge	$-128    	;abs 0x8f24

00008fa6 <.Loc.199.1>:
    elyErrorSignal(ErrRegClip);
    8fa6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008faa <.LVL83>:
    8faa:	b0 13 2a 91 	calla	#37162		;0x0912a

00008fae <.LVL84>:
    value = (uint8_t)(max);
    8fae:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    8fb2:	80 00 24 8f 	mova	#36644,	r0	;0x08f24

00008fb6 <.L37>:
      else if (addr > 0xC0) {
    8fb6:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    8fba:	4d 9e       	cmp.b	r14,	r13	;
    8fbc:	b3 2f       	jc	$-152    	;abs 0x8f24

00008fbe <.Loc.325.1>:
        value = elyRFDLLClampReg(addr, value);
    8fbe:	4d 4c       	mov.b	r12,	r13	;
    8fc0:	4c 4e       	mov.b	r14,	r12	;
    8fc2:	b0 13 76 91 	calla	#37238		;0x09176

00008fc6 <.LVL86>:
    8fc6:	80 00 1c 8e 	mova	#36380,	r0	;0x08e1c

00008fca <elyRegGet>:

void elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    8fca:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008fcc <.LCFI7>:
    8fcc:	49 4c       	mov.b	r12,	r9	;
    8fce:	ca 0d       	mova	r13,	r10	;
    8fd0:	47 4e       	mov.b	r14,	r7	;

00008fd2 <.Loc.333.1>:
  regs_in_progress = n;
    8fd2:	40 18 c2 47 	movx.b	r7,	&0xfc89c;
    8fd6:	9c c8 

00008fd8 <.Loc.335.1>:
  
  if (bank == 0) {
    8fd8:	09 93       	cmp	#0,	r9	;r3 As==00
    8fda:	17 24       	jz	$+48     	;abs 0x900a
    8fdc:	45 43       	clr.b	r5		;

00008fde <.LBB68>:
  else {
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
  
      /* Get the register */
      fram_reg(1, bank, addr, (buffer+i));
    8fde:	88 00 76 8c 	mova	#35958,	r8	;0x08c76
    8fe2:	56 43       	mov.b	#1,	r6	;r3 As==01

00008fe4 <.L96>:
    for (int i = 0; i < n; i++) {
    8fe4:	05 97       	cmp	r7,	r5	;
    8fe6:	15 38       	jl	$+44     	;abs 0x9012

00008fe8 <.LBB71>:
  return chSemWaitTimeout(&bsp->sem, time);
    8fe8:	4d 43       	clr.b	r13		;
    8fea:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    8fee:	b0 13 88 48 	calla	#18568		;0x04888

00008ff2 <.LBE71>:
    }
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
}
    8ff2:	80 00 0e 90 	mova	#36878,	r0	;0x0900e

00008ff6 <.L98>:
      *(buffer+i) = bank0p[addr];
    8ff6:	6d 4a       	mov.b	@r10,	r13	;
    8ff8:	40 18 0c 4d 	movx.w	r13,	r12	;
    8ffc:	40 18 da 4c 	movx.b	42642(r12),0(r10)	;0x0a692
    9000:	92 a6 00 00 

00009004 <.LBE74>:
    for (int i = 0; i < n; i++) {
    9004:	19 53       	inc	r9		;
    9006:	aa 00 01 00 	adda	#1,	r10	;

0000900a <.L97>:
    900a:	09 97       	cmp	r7,	r9	;
    900c:	f4 3b       	jl	$-22     	;abs 0x8ff6

0000900e <.L94>:
}
    900e:	55 16       	popm.a	#6,	r10	;20-bit words
    9010:	10 01       	reta			;

00009012 <.L100>:
      fram_reg(1, bank, addr, (buffer+i));
    9012:	cf 0a       	mova	r10,	r15	;
    9014:	6e 4a       	mov.b	@r10,	r14	;
    9016:	4d 49       	mov.b	r9,	r13	;
    9018:	4c 46       	mov.b	r6,	r12	;
    901a:	48 13       	calla	r8		;

0000901c <.LBE70>:
    for (int i = 0; i < n; i++) {
    901c:	15 53       	inc	r5		;
    901e:	aa 00 01 00 	adda	#1,	r10	;
    9022:	80 00 e4 8f 	mova	#36836,	r0	;0x08fe4

00009026 <elyRegSet>:

void elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    9026:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009028 <.LCFI8>:
    9028:	b1 00 06 00 	suba	#6,	r1	;

0000902c <.LCFI9>:
    902c:	47 4c       	mov.b	r12,	r7	;
    902e:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00009032 <.Loc.355.1>:
  regs_in_progress = n;
    9032:	40 18 c2 4e 	movx.b	r14,	&0xfc89c;
    9036:	9c c8 

00009038 <.LBB80>:
  
  for (int i = 0; i < n * 2; i += 2) {
    9038:	0e 5e       	rla	r14		;

0000903a <.LVL101>:
    903a:	81 4e 04 00 	mov	r14,	4(r1)	;
    903e:	c6 0d       	mova	r13,	r6	;
    9040:	ca 0d       	mova	r13,	r10	;
    9042:	aa 00 01 00 	adda	#1,	r10	;
    9046:	49 43       	clr.b	r9		;

00009048 <.LBB81>:
    uint8_t addr = buffer[i];
    uint8_t *valuep = &buffer[i+1];
    (*valuep) = elyClampReg(addr, (*valuep));
    9048:	84 00 de 8d 	mova	#36318,	r4	;0x08dde

0000904c <.Loc.363.1>:
  
    /* Write the register */
    fram_reg(0, bank, addr, valuep);
    904c:	88 00 76 8c 	mova	#35958,	r8	;0x08c76
    9050:	45 49       	mov.b	r9,	r5	;

00009052 <.L102>:
  for (int i = 0; i < n * 2; i += 2) {
    9052:	19 91 04 00 	cmp	4(r1),	r9	;
    9056:	09 38       	jl	$+20     	;abs 0x906a

00009058 <.LBB83>:
    9058:	4d 43       	clr.b	r13		;
    905a:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    905e:	b0 13 88 48 	calla	#18568		;0x04888

00009062 <.LBE83>:
  }
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
}
    9062:	a1 00 06 00 	adda	#6,	r1	;
    9066:	64 16       	popm.a	#7,	r10	;20-bit words
    9068:	10 01       	reta			;

0000906a <.L103>:
    uint8_t addr = buffer[i];
    906a:	6e 46       	mov.b	@r6,	r14	;

0000906c <.LVL105>:
    (*valuep) = elyClampReg(addr, (*valuep));
    906c:	6d 4a       	mov.b	@r10,	r13	;
    906e:	4c 4e       	mov.b	r14,	r12	;
    9070:	71 0e 00 00 	mova	r14,	0(r1)	;

00009074 <.LVL106>:
    9074:	44 13       	calla	r4		;

00009076 <.LVL107>:
    9076:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

0000907a <.Loc.363.1>:
    fram_reg(0, bank, addr, valuep);
    907a:	cf 0a       	mova	r10,	r15	;
    907c:	0e 01       	mova	@r1,	r14	;
    907e:	4d 47       	mov.b	r7,	r13	;
    9080:	4c 45       	mov.b	r5,	r12	;
    9082:	48 13       	calla	r8		;

00009084 <.LBE82>:
  for (int i = 0; i < n * 2; i += 2) {
    9084:	29 53       	incd	r9		;
    9086:	a6 00 02 00 	adda	#2,	r6	;
    908a:	aa 00 02 00 	adda	#2,	r10	;

0000908e <.LVL110>:
    908e:	80 00 52 90 	mova	#36946,	r0	;0x09052

00009092 <elyRegGetBlock>:

void elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9092:	b1 00 02 00 	suba	#2,	r1	;

00009096 <.LCFI10>:
    9096:	4b 4c       	mov.b	r12,	r11	;
    9098:	cc 0d       	mova	r13,	r12	;

0000909a <.LVL112>:
    909a:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    909e:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

000090a2 <.Loc.373.1>:
  
  if (bank == 0) {
    90a2:	0b 93       	cmp	#0,	r11	;r3 As==00
    90a4:	0b 20       	jnz	$+24     	;abs 0x90bc

000090a6 <.Loc.374.1>:
    memcpy(buffer, bank0p + addr, n);
    90a6:	40 18 0d 4e 	movx.w	r14,	r13	;

000090aa <.LVL113>:
    90aa:	40 18 0e 4f 	movx.w	r15,	r14	;

000090ae <.LVL114>:
    90ae:	ad 00 92 a6 	adda	#42642,	r13	;0x0a692

000090b2 <.LVL115>:
    90b2:	b0 13 0a a0 	calla	#40970		;0x0a00a

000090b6 <.L104>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
}
    90b6:	a1 00 02 00 	adda	#2,	r1	;
    90ba:	10 01       	reta			;

000090bc <.L105>:
    fram_block(1, bank, addr, buffer, n);
    90bc:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    90c0:	cf 0d       	mova	r13,	r15	;
    90c2:	4d 4b       	mov.b	r11,	r13	;
    90c4:	5c 43       	mov.b	#1,	r12	;r3 As==01

000090c6 <.LVL118>:
    90c6:	b0 13 0e 8d 	calla	#36110		;0x08d0e

000090ca <.LBB88>:
    90ca:	4d 43       	clr.b	r13		;
    90cc:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    90d0:	b0 13 88 48 	calla	#18568		;0x04888

000090d4 <.LBE88>:
}
    90d4:	80 00 b6 90 	mova	#37046,	r0	;0x090b6

000090d8 <elyRegSetBlock>:

void elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    90d8:	6a 14       	pushm.a	#7,	r10	;20-bit words

000090da <.LCFI11>:
    90da:	b1 00 02 00 	suba	#2,	r1	;

000090de <.LCFI12>:
    90de:	49 4c       	mov.b	r12,	r9	;
    90e0:	ca 0d       	mova	r13,	r10	;
    90e2:	45 4e       	mov.b	r14,	r5	;
    90e4:	44 4f       	mov.b	r15,	r4	;

000090e6 <.LVL122>:
    90e6:	c6 0d       	mova	r13,	r6	;

000090e8 <.LBB93>:
  
  for (int i = 0; i < n; i++) {
    90e8:	47 43       	clr.b	r7		;

000090ea <.Loc.389.1>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    90ea:	88 00 de 8d 	mova	#36318,	r8	;0x08dde

000090ee <.L108>:
  for (int i = 0; i < n; i++) {
    90ee:	07 94       	cmp	r4,	r7	;
    90f0:	11 38       	jl	$+36     	;abs 0x9114

000090f2 <.LBE93>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    90f2:	c1 44 00 00 	mov.b	r4,	0(r1)	;
    90f6:	cf 0a       	mova	r10,	r15	;
    90f8:	4e 45       	mov.b	r5,	r14	;
    90fa:	4d 49       	mov.b	r9,	r13	;
    90fc:	4c 43       	clr.b	r12		;
    90fe:	b0 13 0e 8d 	calla	#36110		;0x08d0e

00009102 <.LBB94>:
    9102:	4d 43       	clr.b	r13		;
    9104:	8c 00 9e c8 	mova	#51358,	r12	;0x0c89e
    9108:	b0 13 88 48 	calla	#18568		;0x04888

0000910c <.LBE94>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
}
    910c:	a1 00 02 00 	adda	#2,	r1	;
    9110:	64 16       	popm.a	#7,	r10	;20-bit words
    9112:	10 01       	reta			;

00009114 <.L109>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    9114:	6d 46       	mov.b	@r6,	r13	;
    9116:	4c 47       	mov.b	r7,	r12	;
    9118:	4c 55       	add.b	r5,	r12	;
    911a:	48 13       	calla	r8		;

0000911c <.LVL126>:
    911c:	c6 4c 00 00 	mov.b	r12,	0(r6)	;

00009120 <.Loc.388.1>:
  for (int i = 0; i < n; i++) {
    9120:	17 53       	inc	r7		;
    9122:	a6 00 01 00 	adda	#1,	r6	;
    9126:	80 00 ee 90 	mova	#37102,	r0	;0x090ee

0000912a <elyErrorSignal>:
    912a:	10 01       	reta			;

0000912c <elyErrorSetRptLvlS>:
    912c:	10 01       	reta			;

0000912e <elyErrorSetLogLvlS>:
  (void)(lvl);
}

void elyErrorSetLogLvlS(uint8_t lvl) {
  (void)(lvl);
}
    912e:	10 01       	reta			;

00009130 <elyEventSignal>:
    9130:	10 01       	reta			;

00009132 <elyEventSubscribe>:
}

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(event);
  (void)(addr);
}
    9132:	10 01       	reta			;

00009134 <elyEventUnsubscribe>:
    9134:	10 01       	reta			;

00009136 <elyEventLog>:
    9136:	10 01       	reta			;

00009138 <elyEventUnlog>:
  (void)(event);
}

void elyEventUnlog(uint8_t event) {
  (void)(event);
}
    9138:	10 01       	reta			;

0000913a <elyEventReset>:

void elyEventReset() {
}
    913a:	10 01       	reta			;

0000913c <elyChanSubscribe>:
    913c:	10 01       	reta			;

0000913e <elyChanUnsubscribe>:
    913e:	10 01       	reta			;

00009140 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
  (void)(buffer);
  (void)(length);
  (void)(interval);
}
    9140:	10 01       	reta			;

00009142 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
  (void)(buffer);
  (void)(length);
}
    9142:	10 01       	reta			;

00009144 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer, uint8_t id) {
  (void)(buffer);
  (void)(id);
  return 4;
}
    9144:	6c 42       	mov.b	#4,	r12	;r2 As==10

00009146 <.LVL3>:
    9146:	10 01       	reta			;

00009148 <elyChanReset>:

void elyChanReset() {
}
    9148:	10 01       	reta			;

0000914a <elyTelemUpdateConfigS>:

#include "telem.h"

void elyTelemUpdateConfigS(telem_cfg_t config) {
  (void)(config);
}
    914a:	10 01       	reta			;

0000914c <elyTelemPostBufferS>:

void elyTelemPostBufferS(uint8_t * buffer, telemcallback_t cb) {
  /* WARNING this is an abominable hack! */
  OSAL_IRQ_PROLOGUE();
    914c:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    9150:	4e 07 

00009152 <.Loc.12.1>:
  chSysLockFromISR();
  cb(buffer);
    9152:	4d 13       	calla	r13		;

00009154 <.LVL1>:
  chSysUnlockFromISR();
  OSAL_IRQ_EPILOGUE();
    9154:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    9158:	4e 07 
    915a:	b0 13 be 47 	calla	#18366		;0x047be

0000915e <.LVL2>:
    915e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9160:	02 24       	jz	$+6      	;abs 0x9166

00009162 <.Loc.14.1>:
    9162:	b0 13 ce 47 	calla	#18382		;0x047ce

00009166 <.L2>:
}
    9166:	10 01       	reta			;

00009168 <elyRFPostI>:

#include "rf.h"

msg_t elyRFPostI(uint8_t * buffer) {
  return elyUARTPostI(buffer);
    9168:	b0 13 6a 60 	calla	#24682		;0x0606a

0000916c <.LVL1>:
}
    916c:	10 01       	reta			;

0000916e <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
  return elyUARTPost(buffer, timeout);
    916e:	b0 13 9c 60 	calla	#24732		;0x0609c

00009172 <.LVL3>:
}
    9172:	10 01       	reta			;

00009174 <elyRFCfgMarkDirty>:
  (void)(event);
}

void elyRFCfgMarkDirty(rf_events_t event) {
  (void)(event);
}
    9174:	10 01       	reta			;

00009176 <elyRFDLLClampReg>:
#include "core.h"

uint8_t elyRFDLLClampReg(uint8_t addr, uint8_t value) {
  (void)(addr);
  return value;
}
    9176:	4c 4d       	mov.b	r13,	r12	;

00009178 <.LVL1>:
    9178:	10 01       	reta			;

0000917a <calc_next_buff>:
static const uint8_t * next_tx_ptr;
static slip_uart_states_t tx_state = ELY_SLIP_NOT_ESCAPED;

static thread_t * uart_thd;
    
void calc_next_buff(void) {
    917a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000917c <.LCFI0>:
    917c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000917e <.LCFI1>:
  
  switch (tx_state) {
    917e:	c0 18 5c 42 	movx.b	&0x106fe,r12	;
    9182:	fe 06 
    9184:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9186:	2f 24       	jz	$+96     	;abs 0x91e6
    9188:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    918a:	59 20       	jnz	$+180    	;abs 0x923e

0000918c <.Loc.48.1>:
    case ELY_SLIP_NOT_ESCAPED:
      next_tx_ptr = tx_read_ptr;
    918c:	2c 00 b4 c8 	mova	&51380,	r12	;0x0c8b4
    9190:	60 0c ac c8 	mova	r12,	&51372	; 0x0c8ac

00009194 <.Loc.49.1>:
      next_cnt = 0;
    9194:	00 18 c2 43 	movx.a	#0,	&0xfc8b0;r3 As==00
    9198:	b0 c8 

0000919a <.Loc.50.1>:
      while (next_cnt != tx_n && 
    919a:	28 00 b8 c8 	mova	&51384,	r8	;0x0c8b8
    919e:	4e 43       	clr.b	r14		;
    91a0:	4d 43       	clr.b	r13		;
    91a2:	5b 43       	mov.b	#1,	r11	;r3 As==01

000091a4 <.L5>:
    91a4:	d8 0e       	cmpa	r14,	r8	;
    91a6:	0f 20       	jnz	$+32     	;abs 0x91c6

000091a8 <.L33>:
    91a8:	0d 93       	cmp	#0,	r13	;r3 As==00
    91aa:	04 24       	jz	$+10     	;abs 0x91b4
    91ac:	60 0e b0 c8 	mova	r14,	&51376	; 0x0c8b0
    91b0:	60 0c b4 c8 	mova	r12,	&51380	; 0x0c8b4

000091b4 <.L11>:
          *tx_read_ptr != SLIP_END && 
          *tx_read_ptr != SLIP_ESC) {
        next_cnt++;
        tx_read_ptr++;
      }
      tx_state = ELY_SLIP_ESCAPED;
    91b4:	41 18 d2 43 	movx.b	#1,	&0x106fe;r3 As==01
    91b8:	fe 06 

000091ba <.Loc.57.1>:
      if (next_cnt > 0) {
    91ba:	9e 00 00 00 	cmpa	#0,	r14	;
    91be:	13 24       	jz	$+40     	;abs 0x91e6

000091c0 <.L1>:
      chDbgAssert(false, "State machine error");
      /* ACTUALLY can't happen */
      break;
  }
            
}
    91c0:	08 16       	popm.a	#1,	r8	;20-bit words
    91c2:	0a 16       	popm.a	#1,	r10	;20-bit words
    91c4:	10 01       	reta			;

000091c6 <.L6>:
      while (next_cnt != tx_n && 
    91c6:	6f 4c       	mov.b	@r12,	r15	;
    91c8:	7f 90 c0 ff 	cmp.b	#-64,	r15	;#0xffc0
    91cc:	ed 27       	jz	$-36     	;abs 0x91a8
    91ce:	ca 0e       	mova	r14,	r10	;
    91d0:	aa 00 01 00 	adda	#1,	r10	;

000091d4 <.Loc.51.1>:
          *tx_read_ptr != SLIP_END && 
    91d4:	7f 90 db ff 	cmp.b	#-37,	r15	;#0xffdb
    91d8:	e7 27       	jz	$-48     	;abs 0x91a8

000091da <.Loc.54.1>:
        tx_read_ptr++;
    91da:	ac 00 01 00 	adda	#1,	r12	;
    91de:	0d 4b       	mov	r11,	r13	;
    91e0:	ce 0a       	mova	r10,	r14	;
    91e2:	80 00 a4 91 	mova	#37284,	r0	;0x091a4

000091e6 <.L3>:
        switch(*tx_read_ptr++) {
    91e6:	2c 00 b4 c8 	mova	&51380,	r12	;0x0c8b4
    91ea:	cd 0c       	mova	r12,	r13	;
    91ec:	ad 00 01 00 	adda	#1,	r13	;
    91f0:	60 0d b4 c8 	mova	r13,	&51380	; 0x0c8b4
    91f4:	6c 4c       	mov.b	@r12,	r12	;
    91f6:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    91fa:	12 24       	jz	$+38     	;abs 0x9220
    91fc:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    9200:	15 20       	jnz	$+44     	;abs 0x922c

00009202 <.Loc.64.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    9202:	80 18 f2 40 	movx.a	#67092,	&0xfc8ac;0x10614
    9206:	14 06 ac c8 

0000920a <.L17>:
        next_cnt = 2;
    920a:	00 18 e2 43 	movx.a	#2,	&0xfc8b0;r3 As==10
    920e:	b0 c8 

00009210 <.Loc.78.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    9210:	00 18 d2 53 	incx.a	&0xc8b8		;
    9214:	b8 c8 

00009216 <.Loc.79.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    9216:	41 18 e2 43 	movx.b	#2,	&0x106fe;r3 As==10
    921a:	fe 06 
    921c:	80 00 c0 91 	mova	#37312,	r0	;0x091c0

00009220 <.L15>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    9220:	80 18 f2 40 	movx.a	#67090,	&0xfc8ac;0x10612
    9224:	12 06 ac c8 
    9228:	80 00 0a 92 	mova	#37386,	r0	;0x0920a

0000922c <.L31>:
            chDbgAssert(false, "state machine error");
    922c:	8c 01 03 06 	mova	#67075,	r12	;0x10603
    9230:	b0 13 5c 46 	calla	#18012		;0x0465c

00009234 <.LVL0>:
            tx_n--;
    9234:	00 18 f2 53 	addx.a	#-1,	&0xfc8b8;r3 As==11
    9238:	b8 c8 
    923a:	80 00 0a 92 	mova	#37386,	r0	;0x0920a

0000923e <.L30>:
      chDbgAssert(false, "State machine error");
    923e:	8c 01 03 06 	mova	#67075,	r12	;0x10603
    9242:	b0 13 5c 46 	calla	#18012		;0x0465c

00009246 <.LVL1>:
}
    9246:	80 00 c0 91 	mova	#37312,	r0	;0x091c0

0000924a <elyUARTDLLTxCB>:

void elyUARTDLLTxCB(UARTDriver * uartp) {
  static bool done = false;
  static const uint8_t END = SLIP_END;
  
  if (done) {
    924a:	40 18 c2 93 	cmpx.b	#0,	&0xfc8a6;r3 As==00
    924e:	a6 c8 
    9250:	04 24       	jz	$+10     	;abs 0x925a

00009252 <.Loc.95.1>:
    done = false;
    9252:	40 18 c2 43 	movx.b	#0,	&0xfc8a6;r3 As==00
    9256:	a6 c8 

00009258 <.L34>:
    next_cnt = 1;
    return;
  }
  
  calc_next_buff();
}
    9258:	10 01       	reta			;

0000925a <.L35>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    925a:	2e 00 ac c8 	mova	&51372,	r14	;0x0c8ac
    925e:	2d 00 b0 c8 	mova	&51376,	r13	;0x0c8b0
    9262:	b0 13 48 4f 	calla	#20296		;0x04f48

00009266 <.LVL5>:
  if (tx_n == 0) {
    9266:	2c 00 b8 c8 	mova	&51384,	r12	;0x0c8b8
    926a:	9c 00 00 00 	cmpa	#0,	r12	;
    926e:	05 20       	jnz	$+12     	;abs 0x927a

00009270 <.Loc.104.1>:
    done = true;
    9270:	40 18 d2 43 	movx.b	#1,	&0xfc8a6;r3 As==01
    9274:	a6 c8 

00009276 <.Loc.105.1>:
    return;
    9276:	80 00 58 92 	mova	#37464,	r0	;0x09258

0000927a <.L37>:
  tx_n -= next_cnt;
    927a:	00 18 5c 82 	subx.a	&0x0c8b0,r12	;
    927e:	b0 c8 
    9280:	60 0c b8 c8 	mova	r12,	&51384	; 0x0c8b8

00009284 <.Loc.110.1>:
  if (tx_n == 0) {
    9284:	9c 00 00 00 	cmpa	#0,	r12	;
    9288:	0d 20       	jnz	$+28     	;abs 0x92a4

0000928a <.Loc.112.1>:
    elyNLFreeBufferCheckedI(tx_active_buffer);
    928a:	2c 00 bc c8 	mova	&51388,	r12	;0x0c8bc
    928e:	b0 13 ce 9b 	calla	#39886		;0x09bce

00009292 <.LVL6>:
    next_tx_ptr = &END;
    9292:	80 18 f2 40 	movx.a	#67074,	&0xfc8ac;0x10602
    9296:	02 06 ac c8 

0000929a <.Loc.115.1>:
    next_cnt = 1;
    929a:	00 18 d2 43 	movx.a	#1,	&0xfc8b0;r3 As==01
    929e:	b0 c8 

000092a0 <.Loc.116.1>:
    return;
    92a0:	80 00 58 92 	mova	#37464,	r0	;0x09258

000092a4 <.L38>:
  calc_next_buff();
    92a4:	b0 13 7a 91 	calla	#37242		;0x0917a

000092a8 <.LVL7>:
    92a8:	80 00 58 92 	mova	#37464,	r0	;0x09258

000092ac <elyUARTDLLStartTx>:

void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    92ac:	0a 14       	pushm.a	#1,	r10	;20-bit words

000092ae <.LCFI2>:
    92ae:	08 14       	pushm.a	#1,	r8	;20-bit words

000092b0 <.LCFI3>:
    92b0:	c8 0c       	mova	r12,	r8	;
    92b2:	ca 0d       	mova	r13,	r10	;

000092b4 <.Loc.125.1>:
  static const uint8_t END = SLIP_END;
  /* Calculate the length of the packet - store it in n */
  tx_n = elyNLGetLength(buffer);
    92b4:	cc 0d       	mova	r13,	r12	;

000092b6 <.LVL9>:
    92b6:	b0 13 e4 9c 	calla	#40164		;0x09ce4

000092ba <.LVL10>:
    92ba:	60 0c b8 c8 	mova	r12,	&51384	; 0x0c8b8

000092be <.Loc.126.1>:
  chDbgAssert(tx_n != 0 && tx_n <= elyNLMaxLen, "invalid packet length");
    92be:	9c 00 00 00 	cmpa	#0,	r12	;
    92c2:	04 24       	jz	$+10     	;abs 0x92cc

000092c4 <.Loc.126.1>:
    92c4:	00 18 c2 9c 	cmpx.a	r12,	&0xfc818;
    92c8:	18 c8 
    92ca:	04 2c       	jc	$+10     	;abs 0x92d4

000092cc <.L40>:
    92cc:	8c 01 f0 05 	mova	#67056,	r12	;0x105f0
    92d0:	b0 13 5c 46 	calla	#18012		;0x0465c

000092d4 <.L41>:
  /* The below should be impossible and should be deleted if Assert is Abort */
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    92d4:	2c 00 b8 c8 	mova	&51384,	r12	;0x0c8b8
    92d8:	9c 00 00 00 	cmpa	#0,	r12	;
    92dc:	04 24       	jz	$+10     	;abs 0x92e6

000092de <.Loc.128.1>:
    92de:	00 18 c2 9c 	cmpx.a	r12,	&0xfc818;
    92e2:	18 c8 
    92e4:	03 2c       	jc	$+8      	;abs 0x92ec

000092e6 <.L42>:
    /* TODO signal an error here */
    elyNLFreeBufferChecked(buffer);
    92e6:	cc 0a       	mova	r10,	r12	;
    92e8:	b0 13 ae 9b 	calla	#39854		;0x09bae

000092ec <.L43>:
  }
  tx_read_ptr = buffer;
    92ec:	60 0a b4 c8 	mova	r10,	&51380	; 0x0c8b4

000092f0 <.Loc.133.1>:
  tx_active_buffer = buffer;
    92f0:	60 0a bc c8 	mova	r10,	&51388	; 0x0c8bc

000092f4 <.Loc.134.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    92f4:	41 18 e2 43 	movx.b	#2,	&0x106fe;r3 As==10
    92f8:	fe 06 

000092fa <.Loc.136.1>:
  
  calc_next_buff();
    92fa:	8a 00 7a 91 	mova	#37242,	r10	;0x0917a

000092fe <.LVL13>:
    92fe:	4a 13       	calla	r10		;

00009300 <.LBB40>:
  _disable_interrupts();
    9300:	32 c2       	dint			
    9302:	03 43       	nop			

00009304 <.Loc.348.2>:
  asm volatile("nop");
    9304:	03 43       	nop			

00009306 <.LBE40>:
  
  chSysLock();
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    9306:	2e 00 ac c8 	mova	&51372,	r14	;0x0c8ac
    930a:	2d 00 b0 c8 	mova	&51376,	r13	;0x0c8b0
    930e:	cc 08       	mova	r8,	r12	;
    9310:	b0 13 48 4f 	calla	#20296		;0x04f48

00009314 <.LVL15>:
  
  tx_n -= next_cnt;
    9314:	2c 00 b8 c8 	mova	&51384,	r12	;0x0c8b8
    9318:	00 18 5c 82 	subx.a	&0x0c8b0,r12	;
    931c:	b0 c8 
    931e:	60 0c b8 c8 	mova	r12,	&51384	; 0x0c8b8

00009322 <.Loc.143.1>:
  
  if (tx_n == 0) {
    9322:	9c 00 00 00 	cmpa	#0,	r12	;
    9326:	12 20       	jnz	$+38     	;abs 0x934c

00009328 <.Loc.144.1>:
    elyNLFreeBufferCheckedI(tx_active_buffer);
    9328:	2c 00 bc c8 	mova	&51388,	r12	;0x0c8bc
    932c:	b0 13 ce 9b 	calla	#39886		;0x09bce

00009330 <.LVL16>:
    next_tx_ptr = &END;
    9330:	80 18 f2 40 	movx.a	#67055,	&0xfc8ac;0x105ef
    9334:	ef 05 ac c8 

00009338 <.Loc.146.1>:
    next_cnt = 1;
    9338:	00 18 d2 43 	movx.a	#1,	&0xfc8b0;r3 As==01
    933c:	b0 c8 

0000933e <.L52>:
  asm volatile("nop");
    933e:	03 43       	nop			

00009340 <.Loc.356.2>:
  _enable_interrupts();
    9340:	03 43       	nop			
    9342:	32 d2       	eint			
    9344:	03 43       	nop			

00009346 <.LBE42>:
  }
  
  calc_next_buff();
  chSysUnlock();
  
}
    9346:	08 16       	popm.a	#1,	r8	;20-bit words
    9348:	0a 16       	popm.a	#1,	r10	;20-bit words
    934a:	10 01       	reta			;

0000934c <.L44>:
  calc_next_buff();
    934c:	4a 13       	calla	r10		;

0000934e <.LVL17>:
    934e:	80 00 3e 93 	mova	#37694,	r0	;0x0933e

00009352 <elyUARTDLLRxInit>:

void elyUARTDLLRxInit(UARTDriver * uartp) {
  (void)(uartp);
  
  uart_thd = chThdGetSelfX();
    9352:	80 18 d2 42 	movx.a	&0x10704,&0xfc8a8;
    9356:	04 07 a8 c8 

0000935a <.Loc.160.1>:
}
    935a:	10 01       	reta			;

0000935c <elyUARTDLLRxHandleBuffer>:
    rx_state = ELY_SLIP_RESET;
  }

}

void elyUARTDLLRxHandleBuffer() {
    935c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000935e <.LCFI4>:
  handle_buffer(bytes_available, dbuf_get_read(&rx_buf));
    935e:	28 00 c0 c8 	mova	&51392,	r8	;0x0c8c0

00009362 <.LBB49>:
  return rb->buf[rb->read_idx++ & 1];
    9362:	8e 00 ca c8 	mova	#51402,	r14	;0x0c8ca
    9366:	1c 4e 02 02 	mov	514(r14),r12	;0x00202
    936a:	0d 4c       	mov	r12,	r13	;
    936c:	1d 53       	inc	r13		;
    936e:	8e 4d 02 02 	mov	r13,	514(r14); 0x0202
    9372:	5c f3       	and.b	#1,	r12	;r3 As==01
    9374:	0d 43       	clr	r13		;
    9376:	b0 13 06 9f 	calla	#40710		;0x09f06
    937a:	0d 12       	push	r13		;
    937c:	0c 12       	push	r12		;
    937e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9380:	aa 00 ca c8 	adda	#51402,	r10	;0x0c8ca

00009384 <.LBB51>:
  const uint8_t * end = buffer + bytes_available;
    9384:	c5 0a       	mova	r10,	r5	;
    9386:	e5 08       	adda	r8,	r5	;

00009388 <.LBB53>:
        rx_active_buffer = elyNLGetBuffer();
    9388:	87 00 34 9b 	mova	#39732,	r7	;0x09b34

0000938c <.Loc.250.1>:
      if (elyNLValidate(rx_active_buffer)) {
    938c:	84 00 fc 9c 	mova	#40188,	r4	;0x09cfc

00009390 <.Loc.251.1>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    9390:	86 00 e4 9c 	mova	#40164,	r6	;0x09ce4

00009394 <.L55>:
  while (cp < end) {
    9394:	da 05       	cmpa	r5,	r10	;
    9396:	13 28       	jnc	$+40     	;abs 0x93be

00009398 <.Loc.261.1>:
  if (bytes_available < SLIP_RX_BUF_LEN) {
    9398:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    939c:	dc 08       	cmpa	r8,	r12	;
    939e:	0d 28       	jnc	$+28     	;abs 0x93ba

000093a0 <.Loc.262.1>:
    if (NULL != rx_active_buffer) {
    93a0:	2c 00 92 a7 	mova	&42898,	r12	;0x0a792
    93a4:	9c 00 00 00 	cmpa	#0,	r12	;
    93a8:	05 24       	jz	$+12     	;abs 0x93b4

000093aa <.Loc.263.1>:
      elyNLFreeBuffer(rx_active_buffer);
    93aa:	b0 13 3e 9b 	calla	#39742		;0x09b3e

000093ae <.LVL24>:
      rx_active_buffer = NULL;
    93ae:	00 18 c2 43 	movx.a	#0,	&0xfa792;r3 As==00
    93b2:	92 a7 

000093b4 <.L78>:
    rx_state = ELY_SLIP_RESET;
    93b4:	40 18 c2 43 	movx.b	#0,	&0xfc8c8;r3 As==00
    93b8:	c8 c8 

000093ba <.L54>:
}
    93ba:	64 16       	popm.a	#7,	r10	;20-bit words
    93bc:	10 01       	reta			;

000093be <.L76>:
    uint8_t c = *cp;
    93be:	69 4a       	mov.b	@r10,	r9	;

000093c0 <.LVL27>:
    if (rx_state == ELY_SLIP_RESET) {
    93c0:	40 18 c2 93 	cmpx.b	#0,	&0xfc8c8;r3 As==00
    93c4:	c8 c8 
    93c6:	18 20       	jnz	$+50     	;abs 0x93f8

000093c8 <.Loc.176.1>:
      if (NULL == rx_active_buffer) {
    93c8:	00 18 c2 93 	cmpx.a	#0,	&0xfa792;r3 As==00
    93cc:	92 a7 
    93ce:	03 20       	jnz	$+8      	;abs 0x93d6

000093d0 <.Loc.177.1>:
        rx_active_buffer = elyNLGetBuffer();
    93d0:	47 13       	calla	r7		;

000093d2 <.LVL28>:
    93d2:	60 0c 92 a7 	mova	r12,	&42898	; 0x0a792

000093d6 <.L57>:
      if (NULL == rx_active_buffer) {
    93d6:	2c 00 92 a7 	mova	&42898,	r12	;0x0a792
    93da:	9c 00 00 00 	cmpa	#0,	r12	;
    93de:	ed 27       	jz	$-36     	;abs 0x93ba

000093e0 <.Loc.184.1>:
      rx_write_ptr = rx_active_buffer;
    93e0:	60 0c c4 c8 	mova	r12,	&51396	; 0x0c8c4

000093e4 <.Loc.185.1>:
      rx_n = elyNLHeaderLen;
    93e4:	00 18 f2 40 	movx.a	#6,	&0xfc8a2;
    93e8:	06 00 a2 c8 

000093ec <.Loc.186.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    93ec:	40 18 e2 43 	movx.b	#2,	&0xfc8c8;r3 As==10
    93f0:	c8 c8 

000093f2 <.Loc.187.1>:
      header = true;
    93f2:	40 18 d2 43 	movx.b	#1,	&0xfc8a0;r3 As==01
    93f6:	a0 c8 

000093f8 <.L56>:
    switch (rx_state) {
    93f8:	40 18 5c 42 	movx.b	&0x0c8c8,r12	;
    93fc:	c8 c8 
    93fe:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9400:	08 24       	jz	$+18     	;abs 0x9412
    9402:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9404:	48 24       	jz	$+146    	;abs 0x9496

00009406 <.Loc.244.1>:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    9406:	8c 01 e1 05 	mova	#67041,	r12	;0x105e1
    940a:	b0 13 5c 46 	calla	#18012		;0x0465c

0000940e <.LVL29>:
    940e:	80 00 4c 94 	mova	#37964,	r0	;0x0944c

00009412 <.L61>:
          switch(c) {
    9412:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    9416:	08 24       	jz	$+18     	;abs 0x9428
    9418:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    941c:	30 24       	jz	$+98     	;abs 0x947e

0000941e <.L86>:
                rx_state = ELY_SLIP_RESET;
    941e:	40 18 c2 43 	movx.b	#0,	&0xfc8c8;r3 As==00
    9422:	c8 c8 
    9424:	80 00 94 93 	mova	#37780,	r0	;0x09394

00009428 <.L64>:
              *rx_write_ptr++ = SLIP_END;
    9428:	2c 00 c4 c8 	mova	&51396,	r12	;0x0c8c4
    942c:	cd 0c       	mova	r12,	r13	;
    942e:	ad 00 01 00 	adda	#1,	r13	;
    9432:	60 0d c4 c8 	mova	r13,	&51396	; 0x0c8c4
    9436:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    943a:	00 00 

0000943c <.L66>:
          rx_n--;
    943c:	00 18 f2 53 	addx.a	#-1,	&0xfc8a2;r3 As==11
    9440:	a2 c8 

00009442 <.Loc.205.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    9442:	40 18 e2 43 	movx.b	#2,	&0xfc8c8;r3 As==10
    9446:	c8 c8 

00009448 <.L85>:
                cp++;
    9448:	aa 00 01 00 	adda	#1,	r10	;

0000944c <.L68>:
    if (rx_n == 0 && header) { /* and we haven't reset */
    944c:	00 18 c2 93 	cmpx.a	#0,	&0xfc8a2;r3 As==00
    9450:	a2 c8 
    9452:	a0 23       	jnz	$-190    	;abs 0x9394
    9454:	40 18 c2 93 	cmpx.b	#0,	&0xfc8a0;r3 As==00
    9458:	a0 c8 
    945a:	9c 27       	jz	$-198    	;abs 0x9394

0000945c <.Loc.250.1>:
      if (elyNLValidate(rx_active_buffer)) {
    945c:	2c 00 92 a7 	mova	&42898,	r12	;0x0a792
    9460:	44 13       	calla	r4		;

00009462 <.LVL31>:
    9462:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9464:	4d 24       	jz	$+156    	;abs 0x9500

00009466 <.Loc.251.1>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    9466:	2c 00 92 a7 	mova	&42898,	r12	;0x0a792
    946a:	46 13       	calla	r6		;

0000946c <.LVL32>:
    946c:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    9470:	60 0c a2 c8 	mova	r12,	&51362	; 0x0c8a2

00009474 <.Loc.252.1>:
        header = false;
    9474:	40 18 c2 43 	movx.b	#0,	&0xfc8a0;r3 As==00
    9478:	a0 c8 
    947a:	80 00 94 93 	mova	#37780,	r0	;0x09394

0000947e <.L65>:
              *rx_write_ptr++ = SLIP_ESC;
    947e:	2c 00 c4 c8 	mova	&51396,	r12	;0x0c8c4
    9482:	cd 0c       	mova	r12,	r13	;
    9484:	ad 00 01 00 	adda	#1,	r13	;
    9488:	60 0d c4 c8 	mova	r13,	&51396	; 0x0c8c4
    948c:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    9490:	00 00 
    9492:	80 00 3c 94 	mova	#37948,	r0	;0x0943c

00009496 <.L62>:
          switch(c) {
    9496:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    949a:	0c 24       	jz	$+26     	;abs 0x94b4
    949c:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    94a0:	1b 20       	jnz	$+56     	;abs 0x94d8

000094a2 <.Loc.213.1>:
              if (rx_n == 0) {
    94a2:	00 18 c2 93 	cmpx.a	#0,	&0xfc8a2;r3 As==00
    94a6:	a2 c8 
    94a8:	ba 27       	jz	$-138    	;abs 0x941e

000094aa <.Loc.218.1>:
                rx_state = ELY_SLIP_ESCAPED;
    94aa:	40 18 d2 43 	movx.b	#1,	&0xfc8c8;r3 As==01
    94ae:	c8 c8 
    94b0:	80 00 48 94 	mova	#37960,	r0	;0x09448

000094b4 <.L70>:
              if (rx_n == 0) {
    94b4:	00 18 c2 93 	cmpx.a	#0,	&0xfc8a2;r3 As==00
    94b8:	a2 c8 
    94ba:	07 20       	jnz	$+16     	;abs 0x94ca

000094bc <.Loc.224.1>:
                elyNLRouteUART(rx_active_buffer);
    94bc:	2c 00 92 a7 	mova	&42898,	r12	;0x0a792
    94c0:	b0 13 dc 9d 	calla	#40412		;0x09ddc

000094c4 <.LVL33>:
                rx_active_buffer = NULL;
    94c4:	00 18 c2 43 	movx.a	#0,	&0xfa792;r3 As==00
    94c8:	92 a7 

000094ca <.L73>:
              rx_state = ELY_SLIP_RESET;
    94ca:	40 18 c2 43 	movx.b	#0,	&0xfc8c8;r3 As==00
    94ce:	c8 c8 

000094d0 <.Loc.228.1>:
              cp++;
    94d0:	aa 00 01 00 	adda	#1,	r10	;
    94d4:	80 00 94 93 	mova	#37780,	r0	;0x09394

000094d8 <.L84>:
              if (rx_n == 0) {
    94d8:	2c 00 a2 c8 	mova	&51362,	r12	;0x0c8a2
    94dc:	9c 00 00 00 	cmpa	#0,	r12	;
    94e0:	9e 27       	jz	$-194    	;abs 0x941e

000094e2 <.Loc.236.1>:
                *rx_write_ptr++ = c;
    94e2:	2e 00 c4 c8 	mova	&51396,	r14	;0x0c8c4
    94e6:	cd 0e       	mova	r14,	r13	;
    94e8:	ad 00 01 00 	adda	#1,	r13	;
    94ec:	60 0d c4 c8 	mova	r13,	&51396	; 0x0c8c4
    94f0:	ce 49 00 00 	mov.b	r9,	0(r14)	;

000094f4 <.Loc.237.1>:
                rx_n--;
    94f4:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    94f8:	60 0c a2 c8 	mova	r12,	&51362	; 0x0c8a2
    94fc:	80 00 48 94 	mova	#37960,	r0	;0x09448

00009500 <.L75>:
        rx_state = ELY_SLIP_RESET;
    9500:	40 18 c2 4c 	movx.b	r12,	&0xfc8c8;
    9504:	c8 c8 
    9506:	80 00 94 93 	mova	#37780,	r0	;0x09394

0000950a <elyUARTDLLTimeoutCB>:
/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    950a:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e

0000950e <.LVL36>:
    950e:	b0 13 f8 4f 	calla	#20472		;0x04ff8

00009512 <.LVL37>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    9512:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9516:	fd 0c       	suba	r12,	r13	;
    9518:	60 0d c0 c8 	mova	r13,	&51392	; 0x0c8c0

0000951c <.Loc.285.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    951c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    951e:	4e 43       	clr.b	r14		;
    9520:	2c 00 a8 c8 	mova	&51368,	r12	;0x0c8a8

00009524 <.LVL38>:
    9524:	b0 13 9c 49 	calla	#18844		;0x0499c

00009528 <.LVL39>:
  chSysUnlockFromISR();

}
    9528:	10 01       	reta			;

0000952a <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    952a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000952c <.LCFI5>:
    952c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000952e <.LCFI6>:
    952e:	c8 0c       	mova	r12,	r8	;
    9530:	0a 4d       	mov	r13,	r10	;

00009532 <.Loc.291.1>:
  chDbgAssert(c < 0x100, "invalid char");
    9532:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

00009536 <.LVL41>:
    9536:	0c 9d       	cmp	r13,	r12	;
    9538:	04 2c       	jc	$+10     	;abs 0x9542

0000953a <.Loc.291.1>:
    953a:	8c 01 ce 05 	mova	#67022,	r12	;0x105ce
    953e:	b0 13 5c 46 	calla	#18012		;0x0465c

00009542 <.L89>:
  rb->read_idx = 0;
    9542:	8e 00 ca c8 	mova	#51402,	r14	;0x0c8ca
    9546:	40 18 82 43 	movx.w	#0,	&0xfcacc;r3 As==00
    954a:	cc ca 

0000954c <.LBB59>:
  return rb->buf[rb->write_idx++ & 1];
    954c:	40 18 92 43 	movx.w	#1,	&0xfcaca;r3 As==01
    9550:	ca ca 

00009552 <.LBE59>:
  dbuf_init(&rx_buf);
  
  uint8_t * buf = dbuf_get_write(&rx_buf);
  buf[0] = (uint8_t)(c);
    9552:	ce 4a 00 00 	mov.b	r10,	0(r14)	;

00009556 <.Loc.297.1>:
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, buf+1);
    9556:	ae 00 01 00 	adda	#1,	r14	;
    955a:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    955e:	cc 08       	mova	r8,	r12	;
    9560:	b0 13 a0 4f 	calla	#20384		;0x04fa0

00009564 <.LVL45>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    9564:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9568:	8c 01 72 08 	mova	#67698,	r12	;0x10872
    956c:	b0 13 d8 4d 	calla	#19928		;0x04dd8

00009570 <.LVL46>:
  
  
  chSysUnlockFromISR();
}
    9570:	08 16       	popm.a	#1,	r8	;20-bit words
    9572:	0a 16       	popm.a	#1,	r10	;20-bit words
    9574:	10 01       	reta			;

00009576 <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    9576:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009578 <.LCFI7>:
    9578:	08 14       	pushm.a	#1,	r8	;20-bit words

0000957a <.LCFI8>:
    957a:	ca 0c       	mova	r12,	r10	;

0000957c <.LBB61>:
  return rb->buf[rb->write_idx++ & 1];
    957c:	8e 00 ca c8 	mova	#51402,	r14	;0x0c8ca
    9580:	1c 4e 00 02 	mov	512(r14),r12	;0x00200

00009584 <.LVL49>:
    9584:	0d 4c       	mov	r12,	r13	;
    9586:	1d 53       	inc	r13		;
    9588:	8e 4d 00 02 	mov	r13,	512(r14); 0x0200

0000958c <.LVL50>:
    958c:	5c f3       	and.b	#1,	r12	;r3 As==01
    958e:	0d 43       	clr	r13		;
    9590:	b0 13 06 9f 	calla	#40710		;0x09f06
    9594:	0d 12       	push	r13		;
    9596:	0c 12       	push	r12		;
    9598:	0e 16       	popm.a	#1,	r14	;20-bit words

0000959a <.LBE61>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, dbuf_get_write(&rx_buf)); 
    959a:	38 40 00 01 	mov	#256,	r8	;#0x0100
    959e:	ae 00 ca c8 	adda	#51402,	r14	;0x0c8ca
    95a2:	cd 08       	mova	r8,	r13	;
    95a4:	cc 0a       	mova	r10,	r12	;
    95a6:	b0 13 a0 4f 	calla	#20384		;0x04fa0

000095aa <.LVL52>:
  gptStopTimerI(&uart_gpt);
    95aa:	8a 01 72 08 	mova	#67698,	r10	;0x10872

000095ae <.LVL53>:
    95ae:	cc 0a       	mova	r10,	r12	;
    95b0:	b0 13 1e 4e 	calla	#19998		;0x04e1e

000095b4 <.LVL54>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    95b4:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    95b8:	cc 0a       	mova	r10,	r12	;
    95ba:	b0 13 d8 4d 	calla	#19928		;0x04dd8

000095be <.LVL55>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    95be:	60 08 c0 c8 	mova	r8,	&51392	; 0x0c8c0

000095c2 <.Loc.313.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    95c2:	6d 42       	mov.b	#4,	r13	;r2 As==10
    95c4:	4e 43       	clr.b	r14		;
    95c6:	2c 00 a8 c8 	mova	&51368,	r12	;0x0c8a8
    95ca:	b0 13 9c 49 	calla	#18844		;0x0499c

000095ce <.LVL56>:
  
  chSysUnlockFromISR();
}
    95ce:	08 16       	popm.a	#1,	r8	;20-bit words
    95d0:	0a 16       	popm.a	#1,	r10	;20-bit words
    95d2:	10 01       	reta			;

000095d4 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    95d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000095d6 <.LCFI0>:
    95d6:	08 14       	pushm.a	#1,	r8	;20-bit words

000095d8 <.LCFI1>:
    95d8:	06 14       	pushm.a	#1,	r6	;20-bit words

000095da <.LCFI2>:
    95da:	ca 0c       	mova	r12,	r10	;
    95dc:	c8 0d       	mova	r13,	r8	;

000095de <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    95de:	40 18 c2 93 	cmpx.b	#0,	&0xfcace;r3 As==00
    95e2:	ce ca 
    95e4:	04 24       	jz	$+10     	;abs 0x95ee

000095e6 <.Loc.34.1>:
    95e6:	8c 01 33 06 	mova	#67123,	r12	;0x10633

000095ea <.LVL1>:
    95ea:	b0 13 5c 46 	calla	#18012		;0x0465c

000095ee <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    95ee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    95f0:	dc 08       	cmpa	r8,	r12	;
    95f2:	04 28       	jnc	$+10     	;abs 0x95fc

000095f4 <.Loc.38.1>:
    95f4:	8c 01 33 06 	mova	#67123,	r12	;0x10633
    95f8:	b0 13 5c 46 	calla	#18012		;0x0465c

000095fc <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    95fc:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    9600:	54 01 

00009602 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9602:	ce 0a       	mova	r10,	r14	;
    9604:	cc 08       	mova	r8,	r12	;
    9606:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000960a <.L4>:
    960a:	00 18 46 4e 	movx.a	r14,	r6	;
    960e:	00 18 46 8a 	subx.a	r10,	r6	;

00009612 <.LVL6>:
    9612:	d6 0c       	cmpa	r12,	r6	;
    9614:	12 28       	jnc	$+38     	;abs 0x963a

00009616 <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    9616:	ec 0a       	adda	r10,	r12	;
    9618:	40 18 5d 42 	movx.b	&0x00157,r13	;
    961c:	57 01 
    961e:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    9620:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00009624 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    9624:	ea 08       	adda	r8,	r10	;

00009626 <.LVL7>:
    9626:	40 18 5c 42 	movx.b	&0x00156,r12	;
    962a:	56 01 
    962c:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    962e:	ca 4c ff ff 	mov.b	r12,	-1(r10)	; 0xffff

00009632 <.Loc.63.1>:
}
    9632:	06 16       	popm.a	#1,	r6	;20-bit words
    9634:	08 16       	popm.a	#1,	r8	;20-bit words
    9636:	0a 16       	popm.a	#1,	r10	;20-bit words
    9638:	10 01       	reta			;

0000963a <.L5>:
      CRCDI_L = message[i];
    963a:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    963e:	50 01 

00009640 <.LVL9>:
    9640:	ae 00 01 00 	adda	#1,	r14	;

00009644 <.LVL10>:
    9644:	80 00 0a 96 	mova	#38410,	r0	;0x0960a

00009648 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    9648:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000964a <.LCFI3>:
    964a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000964c <.LCFI4>:
    964c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000964e <.LCFI5>:
    964e:	ca 0c       	mova	r12,	r10	;
    9650:	c8 0d       	mova	r13,	r8	;

00009652 <.Loc.72.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9652:	40 18 c2 93 	cmpx.b	#0,	&0xfcace;r3 As==00
    9656:	ce ca 
    9658:	04 24       	jz	$+10     	;abs 0x9662

0000965a <.Loc.72.1>:
    965a:	8c 01 27 06 	mova	#67111,	r12	;0x10627

0000965e <.LVL12>:
    965e:	b0 13 5c 46 	calla	#18012		;0x0465c

00009662 <.L7>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9662:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    9666:	54 01 

00009668 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9668:	ce 0a       	mova	r10,	r14	;
    966a:	cc 08       	mova	r8,	r12	;
    966c:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

00009670 <.L8>:
    9670:	00 18 46 4e 	movx.a	r14,	r6	;
    9674:	00 18 46 8a 	subx.a	r10,	r6	;

00009678 <.LVL16>:
    9678:	d6 0c       	cmpa	r12,	r6	;
    967a:	14 28       	jnc	$+42     	;abs 0x96a4

0000967c <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    967c:	ec 0a       	adda	r10,	r12	;
    967e:	6d 4c       	mov.b	@r12,	r13	;
    9680:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9684:	ea 08       	adda	r8,	r10	;

00009686 <.LVL17>:
    9686:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    968a:	0d da       	bis	r10,	r13	;
    968c:	40 18 1e 42 	movx.w	&0x00156,r14	;
    9690:	56 01 
    9692:	3e e3       	inv	r14		;
    9694:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9696:	0d 9e       	cmp	r14,	r13	;
    9698:	01 24       	jz	$+4      	;abs 0x969c
    969a:	4c 43       	clr.b	r12		;

0000969c <.L10>:
}
    969c:	06 16       	popm.a	#1,	r6	;20-bit words
    969e:	08 16       	popm.a	#1,	r8	;20-bit words
    96a0:	0a 16       	popm.a	#1,	r10	;20-bit words
    96a2:	10 01       	reta			;

000096a4 <.L9>:
      CRCDI_L = message[i];
    96a4:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    96a8:	50 01 

000096aa <.LVL19>:
    96aa:	ae 00 01 00 	adda	#1,	r14	;

000096ae <.LVL20>:
    96ae:	80 00 70 96 	mova	#38512,	r0	;0x09670

000096b2 <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    96b2:	40 18 c2 93 	cmpx.b	#0,	&0xfcace;r3 As==00
    96b6:	ce ca 
    96b8:	04 24       	jz	$+10     	;abs 0x96c2

000096ba <.Loc.103.1>:
    96ba:	8c 01 1e 06 	mova	#67102,	r12	;0x1061e
    96be:	b0 13 5c 46 	calla	#18012		;0x0465c

000096c2 <.L12>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    96c2:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    96c6:	54 01 

000096c8 <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    96c8:	40 18 d2 43 	movx.b	#1,	&0xfcace;r3 As==01
    96cc:	ce ca 

000096ce <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    96ce:	8c 00 50 01 	mova	#336,	r12	;0x00150
    96d2:	10 01       	reta			;

000096d4 <crcStop>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    96d4:	40 18 d2 93 	cmpx.b	#1,	&0xfcace;r3 As==01
    96d8:	ce ca 
    96da:	04 24       	jz	$+10     	;abs 0x96e4

000096dc <.Loc.119.1>:
    96dc:	8c 01 16 06 	mova	#67094,	r12	;0x10616
    96e0:	b0 13 5c 46 	calla	#18012		;0x0465c

000096e4 <.L14>:
  /* Change state */
  crc_state = CRC_STOPPED;
    96e4:	40 18 c2 43 	movx.b	#0,	&0xfcace;r3 As==00
    96e8:	ce ca 

000096ea <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    96ea:	40 18 1c 42 	movx.w	&0x00156,r12	;
    96ee:	56 01 
    96f0:	3c e3       	inv	r12		;
    96f2:	10 01       	reta			;

000096f4 <fram_mpool_alloc>:
static const uint8_t slave_id = 0x50;
static const uint8_t device_select = 0x00;

static PERSIST uint8_t fram_storage[FRAM_REQ_STORAGE];

void * fram_mpool_alloc(size_t size, unsigned align) {
    96f4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000096f6 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > FRAM_REQ_STORAGE) {
    96f6:	2e 00 b6 a7 	mova	&42934,	r14	;0x0a7b6
    96fa:	ca 0e       	mova	r14,	r10	;
    96fc:	ea 0c       	adda	r12,	r10	;
    96fe:	7c 40 48 00 	mov.b	#72,	r12	;#0x0048

00009702 <.LVL1>:
    9702:	dc 0a       	cmpa	r10,	r12	;
    9704:	07 28       	jnc	$+16     	;abs 0x9714

00009706 <.Loc.18.1>:
    return NULL;
  }

  void * result = fram_storage + curr_index;
    9706:	cc 0e       	mova	r14,	r12	;
    9708:	ac 00 ba a7 	adda	#42938,	r12	;0x0a7ba

0000970c <.LVL2>:
  
  curr_index += size;
    970c:	60 0a b6 a7 	mova	r10,	&42934	; 0x0a7b6

00009710 <.L1>:
  return result;
}
    9710:	0a 16       	popm.a	#1,	r10	;20-bit words
    9712:	10 01       	reta			;

00009714 <.L3>:
    return NULL;
    9714:	4c 43       	clr.b	r12		;
    9716:	80 00 10 97 	mova	#38672,	r0	;0x09710

0000971a <addr_cb>:
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
  }
  counter++;
}

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    971a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000971c <.LCFI1>:
    971c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000971e <.LCFI2>:
    971e:	b1 00 08 00 	suba	#8,	r1	;

00009722 <.LCFI3>:
    9722:	c8 0c       	mova	r12,	r8	;

00009724 <.Loc.66.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    9724:	2c 00 d4 ca 	mova	&51924,	r12	;0x0cad4

00009728 <.LVL5>:
  
  chSysLockFromISR();
  /* TODO put in an assert in here for the Rev A crossing bank boundaries */
  if (req->read) {
    9728:	5e 4c 04 00 	mov.b	4(r12),	r14	;

0000972c <.LVL6>:
    972c:	4d 4e       	mov.b	r14,	r13	;

0000972e <.LVL7>:
    972e:	5d f3       	and.b	#1,	r13	;r3 As==01
    9730:	36 0c 08 00 	mova	8(r12),	r6	;
    9734:	5a 4c 06 00 	mov.b	6(r12),	r10	;
    9738:	59 4c 10 00 	mov.b	16(r12),r9	;0x00010

0000973c <.Loc.73.1>:
    if (req->special) {
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    973c:	1c 4c 04 00 	mov	4(r12),	r12	;

00009740 <.LVL8>:
  if (req->read) {
    9740:	40 18 2e b3 	bitx.w	#2,	r14	;r3 As==10
    9744:	37 24       	jz	$+112    	;abs 0x97b4

00009746 <.Loc.71.1>:
    if (req->special) {
    9746:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    9748:	1c 24       	jz	$+58     	;abs 0x9782

0000974a <.Loc.73.1>:
          req->size, req->buffer, end_cb);
    974a:	b0 13 68 9f 	calla	#40808		;0x09f68

0000974e <.LVL9>:
    974e:	0d 4a       	mov	r10,	r13	;
    9750:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    9754:	0d dc       	bis	r12,	r13	;
    9756:	81 4d 04 00 	mov	r13,	4(r1)	;
    975a:	5a 07       	rrum	#2,	r10	;
    975c:	5a f3       	and.b	#1,	r10	;r3 As==01
    975e:	81 4a 06 00 	mov	r10,	6(r1)	;

00009762 <.Loc.72.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    9762:	00 18 f1 40 	movx.a	#39026,	0(r1)	;0x09872
    9766:	72 98 00 00 
    976a:	cf 06       	mova	r6,	r15	;
    976c:	3e 01 04 00 	mova	4(r1),	r14	;
    9770:	4d 49       	mov.b	r9,	r13	;
    9772:	cc 08       	mova	r8,	r12	;
    9774:	b0 13 20 54 	calla	#21536		;0x05420

00009778 <.L4>:
          req->buffer, end_cb);
    }
  }
  current_callback = req->callback;
  chSysUnlockFromISR();
}
    9778:	a1 00 08 00 	adda	#8,	r1	;
    977c:	06 16       	popm.a	#1,	r6	;20-bit words
    977e:	28 16       	popm.a	#3,	r10	;20-bit words
    9780:	10 01       	reta			;

00009782 <.L6>:
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    9782:	b0 13 68 9f 	calla	#40808		;0x09f68

00009786 <.LVL12>:
    9786:	0d 4a       	mov	r10,	r13	;
    9788:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    978c:	0d dc       	bis	r12,	r13	;
    978e:	81 4d 04 00 	mov	r13,	4(r1)	;
    9792:	5a 07       	rrum	#2,	r10	;
    9794:	5a f3       	and.b	#1,	r10	;r3 As==01
    9796:	81 4a 06 00 	mov	r10,	6(r1)	;
    979a:	00 18 f1 40 	movx.a	#39026,	0(r1)	;0x09872
    979e:	72 98 00 00 
    97a2:	cf 06       	mova	r6,	r15	;
    97a4:	3e 01 04 00 	mova	4(r1),	r14	;
    97a8:	4d 49       	mov.b	r9,	r13	;
    97aa:	cc 08       	mova	r8,	r12	;
    97ac:	b0 13 0a 55 	calla	#21770		;0x0550a

000097b0 <.LVL13>:
    97b0:	80 00 78 97 	mova	#38776,	r0	;0x09778

000097b4 <.L5>:
    if (req->special) {
    97b4:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    97b6:	19 24       	jz	$+52     	;abs 0x97ea

000097b8 <.Loc.86.1>:
          req->size, req->buffer, end_cb);
    97b8:	b0 13 68 9f 	calla	#40808		;0x09f68

000097bc <.LVL15>:
    97bc:	0d 4a       	mov	r10,	r13	;
    97be:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    97c2:	0d dc       	bis	r12,	r13	;
    97c4:	81 4d 04 00 	mov	r13,	4(r1)	;
    97c8:	5a 07       	rrum	#2,	r10	;
    97ca:	5a f3       	and.b	#1,	r10	;r3 As==01
    97cc:	81 4a 06 00 	mov	r10,	6(r1)	;

000097d0 <.Loc.85.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    97d0:	00 18 f1 40 	movx.a	#39026,	0(r1)	;0x09872
    97d4:	72 98 00 00 
    97d8:	cf 06       	mova	r6,	r15	;
    97da:	3e 01 04 00 	mova	4(r1),	r14	;
    97de:	4d 49       	mov.b	r9,	r13	;
    97e0:	cc 08       	mova	r8,	r12	;
    97e2:	b0 13 ac 56 	calla	#22188		;0x056ac

000097e6 <.LVL16>:
    97e6:	80 00 78 97 	mova	#38776,	r0	;0x09778

000097ea <.L8>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    97ea:	b0 13 68 9f 	calla	#40808		;0x09f68

000097ee <.LVL18>:
    97ee:	0d 4a       	mov	r10,	r13	;
    97f0:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    97f4:	0d dc       	bis	r12,	r13	;
    97f6:	81 4d 04 00 	mov	r13,	4(r1)	;
    97fa:	5a 07       	rrum	#2,	r10	;
    97fc:	5a f3       	and.b	#1,	r10	;r3 As==01
    97fe:	81 4a 06 00 	mov	r10,	6(r1)	;
    9802:	00 18 f1 40 	movx.a	#39026,	0(r1)	;0x09872
    9806:	72 98 00 00 
    980a:	cf 06       	mova	r6,	r15	;
    980c:	3e 01 04 00 	mova	4(r1),	r14	;
    9810:	4d 49       	mov.b	r9,	r13	;
    9812:	cc 08       	mova	r8,	r12	;
    9814:	b0 13 52 57 	calla	#22354		;0x05752

00009818 <.LVL19>:
}
    9818:	80 00 78 97 	mova	#38776,	r0	;0x09778

0000981c <fram_handle_request>:

/* called from i-class */
void fram_handle_request(fram_req_t * req) {
    981c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000981e <.LCFI4>:
    981e:	b1 00 04 00 	suba	#4,	r1	;

00009822 <.LCFI5>:
    9822:	ca 0c       	mova	r12,	r10	;

00009824 <.Loc.100.1>:
  static volatile unsigned counter = 0;
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    9824:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009826 <.LVL21>:
    9826:	1c 9a 02 00 	cmp	2(r10),	r12	;
    982a:	04 2c       	jc	$+10     	;abs 0x9834

0000982c <.Loc.100.1>:
    982c:	8c 01 7e 06 	mova	#67198,	r12	;0x1067e
    9830:	b0 13 5c 46 	calla	#18012		;0x0465c

00009834 <.L10>:
  
  active_req = req;
    9834:	60 0a d4 ca 	mova	r10,	&51924	; 0x0cad4

00009838 <.Loc.105.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    9838:	2c 4a       	mov	@r10,	r12	;
    983a:	1d 4a 02 00 	mov	2(r10),	r13	;
    983e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9842:	b0 13 e2 9f 	calla	#40930		;0x09fe2

00009846 <.Loc.104.1>:
  req->device_id = (slave_id | device_select | 
    9846:	4d 4c       	mov.b	r12,	r13	;
    9848:	7d d0 50 00 	bis.b	#80,	r13	;#0x0050
    984c:	ca 4d 10 00 	mov.b	r13,	16(r10)	; 0x0010

00009850 <.Loc.108.1>:
  
  /* Issue a write to set the address */
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    9850:	00 18 f1 40 	movx.a	#38682,	0(r1)	;0x0971a
    9854:	1a 97 00 00 
    9858:	cf 0a       	mova	r10,	r15	;
    985a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    985c:	8c 01 d0 07 	mova	#67536,	r12	;0x107d0
    9860:	b0 13 f0 55 	calla	#22000		;0x055f0

00009864 <.LVL24>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
  counter++;
    9864:	40 18 92 53 	incx.w	&0xcad0		;
    9868:	d0 ca 

0000986a <.Loc.112.1>:
}
    986a:	a1 00 04 00 	adda	#4,	r1	;
    986e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9870:	10 01       	reta			;

00009872 <end_cb>:
void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    9872:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009874 <.LCFI6>:
    9874:	b1 00 04 00 	suba	#4,	r1	;

00009878 <.LCFI7>:
    9878:	ca 0d       	mova	r13,	r10	;

0000987a <.Loc.44.1>:
  i2cMSP430XEndTransferI(i2cp);
    987a:	b0 13 fa 57 	calla	#22522		;0x057fa

0000987e <.LVL26>:
  fram_read_idx++;
    987e:	40 18 d2 53 	incx.b	&0xa7a4		;
    9882:	a4 a7 

00009884 <.Loc.48.1>:
  chPoolFreeI(&fram_mpool, active_req);
    9884:	2d 00 d4 ca 	mova	&51924,	r13	;0x0cad4
    9888:	8c 00 98 a7 	mova	#42904,	r12	;0x0a798
    988c:	b0 13 84 4c 	calla	#19588		;0x04c84

00009890 <.LVL27>:
  chSemSignalI(&fram_pool_sem);
    9890:	8c 00 96 a7 	mova	#42902,	r12	;0x0a796
    9894:	b0 13 04 49 	calla	#18692		;0x04904

00009898 <.LVL28>:
  if (active_req->callback) {
    9898:	2c 00 d4 ca 	mova	&51924,	r12	;0x0cad4
    989c:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    98a0:	9e 00 00 00 	cmpa	#0,	r14	;
    98a4:	02 24       	jz	$+6      	;abs 0x98aa

000098a6 <.Loc.53.1>:
    active_req->callback(buffer);
    98a6:	cc 0a       	mova	r10,	r12	;
    98a8:	4e 13       	calla	r14		;

000098aa <.L14>:
  if (!QUEUE_EMPTY()) {
    98aa:	40 18 5c 42 	movx.b	&0x0a7a4,r12	;
    98ae:	a4 a7 
    98b0:	40 18 c2 9c 	cmpx.b	r12,	&0xfa7a5;
    98b4:	a5 a7 
    98b6:	13 24       	jz	$+40     	;abs 0x98de

000098b8 <.Loc.58.1>:
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
    98b8:	7c f0 03 00 	and.b	#3,	r12	;
    98bc:	0d 43       	clr	r13		;
    98be:	0e 4c       	mov	r12,	r14	;
    98c0:	0f 4d       	mov	r13,	r15	;
    98c2:	0e 5e       	rla	r14		;
    98c4:	0f 6f       	rlc	r15		;
    98c6:	0e 5e       	rla	r14		;
    98c8:	0f 6f       	rlc	r15		;
    98ca:	81 4e 00 00 	mov	r14,	0(r1)	;
    98ce:	81 4f 02 00 	mov	r15,	2(r1)	;
    98d2:	0d 01       	mova	@r1,	r13	;
    98d4:	00 18 5c 4d 	movx.a	42918(r13),r12	;0x0a7a6
    98d8:	a6 a7 
    98da:	b0 13 1c 98 	calla	#38940		;0x0981c

000098de <.L15>:
  counter++;
    98de:	40 18 92 53 	incx.w	&0xcad2		;
    98e2:	d2 ca 

000098e4 <.Loc.61.1>:
}
    98e4:	a1 00 04 00 	adda	#4,	r1	;
    98e8:	0a 16       	popm.a	#1,	r10	;20-bit words
    98ea:	10 01       	reta			;

000098ec <elyFramPostRequestI>:

void elyFramPostRequestI(fram_req_t * req) {
    98ec:	0a 14       	pushm.a	#1,	r10	;20-bit words

000098ee <.LCFI8>:
    98ee:	b1 00 04 00 	suba	#4,	r1	;

000098f2 <.LCFI9>:
    98f2:	ca 0c       	mova	r12,	r10	;

000098f4 <.Loc.118.1>:
  chDbgCheckClassI();
  
  /* We should never hit this if we've managed to get a request in the first place */
  chDbgAssert(!QUEUE_FULL(), "internal buffer overflows should be impossible");
    98f4:	40 18 5c 42 	movx.b	&0x0a7a5,r12	;
    98f8:	a5 a7 

000098fa <.LVL32>:
    98fa:	40 18 5d 42 	movx.b	&0x0a7a4,r13	;
    98fe:	a4 a7 
    9900:	0c 8d       	sub	r13,	r12	;
    9902:	2c 92       	cmp	#4,	r12	;r2 As==10
    9904:	04 20       	jnz	$+10     	;abs 0x990e

00009906 <.Loc.118.1>:
    9906:	8c 01 6a 06 	mova	#67178,	r12	;0x1066a
    990a:	b0 13 5c 46 	calla	#18012		;0x0465c

0000990e <.L20>:
  
  fram_mbox_buffer[QUEUE_MASK(fram_write_idx++)] = req;
    990e:	40 18 5c 42 	movx.b	&0x0a7a5,r12	;
    9912:	a5 a7 
    9914:	4e 4c       	mov.b	r12,	r14	;
    9916:	5e 53       	inc.b	r14		;
    9918:	40 18 c2 4e 	movx.b	r14,	&0xfa7a5;
    991c:	a5 a7 
    991e:	7c f0 03 00 	and.b	#3,	r12	;
    9922:	0d 43       	clr	r13		;
    9924:	0e 4c       	mov	r12,	r14	;
    9926:	0f 4d       	mov	r13,	r15	;
    9928:	0e 5e       	rla	r14		;
    992a:	0f 6f       	rlc	r15		;
    992c:	0e 5e       	rla	r14		;
    992e:	0f 6f       	rlc	r15		;
    9930:	81 4e 00 00 	mov	r14,	0(r1)	;
    9934:	81 4f 02 00 	mov	r15,	2(r1)	;
    9938:	0c 01       	mova	@r1,	r12	;
    993a:	00 18 cc 4a 	movx.a	r10,	-22618(r12); 0xfa7a6
    993e:	a6 a7 

00009940 <.Loc.121.1>:
}
    9940:	a1 00 04 00 	adda	#4,	r1	;
    9944:	0a 16       	popm.a	#1,	r10	;20-bit words
    9946:	10 01       	reta			;

00009948 <elyFramPostRequestS>:

void elyFramPostRequestS(fram_req_t * req) {
    9948:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000994a <.LCFI10>:
    994a:	ca 0c       	mova	r12,	r10	;
    994c:	8e 00 ec 98 	mova	#39148,	r14	;0x098ec

00009950 <.Loc.126.1>:
  chDbgCheckClassS();
  
  if (QUEUE_EMPTY()) {
    9950:	40 18 d2 92 	cmpx.b	&0x0a7a4,&0xfa7a5;
    9954:	a4 a7 a5 a7 
    9958:	06 20       	jnz	$+14     	;abs 0x9966

0000995a <.Loc.127.1>:
    elyFramPostRequestI(req);
    995a:	4e 13       	calla	r14		;

0000995c <.LVL35>:
    fram_handle_request(req);
    995c:	cc 0a       	mova	r10,	r12	;
    995e:	b0 13 1c 98 	calla	#38940		;0x0981c

00009962 <.L21>:
  }
  else {
    elyFramPostRequestI(req);
  }
}
    9962:	0a 16       	popm.a	#1,	r10	;20-bit words
    9964:	10 01       	reta			;

00009966 <.L22>:
    elyFramPostRequestI(req);
    9966:	4e 13       	calla	r14		;

00009968 <.LVL37>:
}
    9968:	80 00 62 99 	mova	#39266,	r0	;0x09962

0000996c <elyFramGetRequestTimeoutS>:
  (*reqp)->special = 0;
  
  return MSG_OK;
}

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    996c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000996e <.LCFI12>:
    996e:	08 14       	pushm.a	#1,	r8	;20-bit words

00009970 <.LCFI13>:
    9970:	c8 0c       	mova	r12,	r8	;

00009972 <.Loc.156.1>:
  chDbgCheckClassS();
  
  msg_t r = chSemWaitTimeoutS(&fram_pool_sem, timeout);
    9972:	8c 00 96 a7 	mova	#42902,	r12	;0x0a796

00009976 <.LVL46>:
    9976:	b0 13 b2 48 	calla	#18610		;0x048b2

0000997a <.LVL47>:
    997a:	ca 0c       	mova	r12,	r10	;

0000997c <.Loc.157.1>:
  if (MSG_OK != r) {
    997c:	9c 00 00 00 	cmpa	#0,	r12	;
    9980:	10 20       	jnz	$+34     	;abs 0x99a2

00009982 <.Loc.161.1>:
    return r;
  }
  
  (*reqp) = (fram_req_t *)(chPoolAllocI(&fram_mpool));
    9982:	8c 00 98 a7 	mova	#42904,	r12	;0x0a798
    9986:	b0 13 36 4c 	calla	#19510		;0x04c36

0000998a <.LVL49>:
    998a:	78 0c 00 00 	mova	r12,	0(r8)	;

0000998e <.Loc.162.1>:
  chDbgAssert( (*reqp) != NULL, "internal pool overflow should be impossible");
    998e:	9c 00 00 00 	cmpa	#0,	r12	;
    9992:	04 20       	jnz	$+10     	;abs 0x999c

00009994 <.Loc.162.1>:
    9994:	8c 01 3d 06 	mova	#67133,	r12	;0x1063d
    9998:	b0 13 5c 46 	calla	#18012		;0x0465c

0000999c <.L30>:
  (*reqp)->special = 0;
    999c:	0c 08       	mova	@r8,	r12	;
    999e:	dc c3 04 00 	bic.b	#1,	4(r12)	;r3 As==01

000099a2 <.L28>:
  return r;
}
    99a2:	cc 0a       	mova	r10,	r12	;
    99a4:	08 16       	popm.a	#1,	r8	;20-bit words
    99a6:	0a 16       	popm.a	#1,	r10	;20-bit words
    99a8:	10 01       	reta			;

000099aa <elyFramInit>:

  
void elyFramInit() {
  chDbgAssert((FRAM_QUEUE_LEN & (FRAM_QUEUE_LEN -1)) == 0, 
      "queue length must be power of 2");
  i2cStart(&I2CDB0, &cfg);
    99aa:	8d 01 00 07 	mova	#67328,	r13	;0x10700
    99ae:	8c 01 d0 07 	mova	#67536,	r12	;0x107d0
    99b2:	b0 13 64 4e 	calla	#20068		;0x04e64

000099b6 <.LVL51>:
}
    99b6:	10 01       	reta			;

000099b8 <nl_allocator>:
uint8_t PERSIST packets_received;
uint16_t PERSIST packets_sent = 1;
uint8_t PERSIST packets_relayed;
static size_t sh_len;

void * nl_allocator(size_t size, unsigned align) {
    99b8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000099ba <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    99ba:	2e 00 0e a8 	mova	&43022,	r14	;0x0a80e
    99be:	ca 0e       	mova	r14,	r10	;
    99c0:	ea 0c       	adda	r12,	r10	;
    99c2:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

000099c6 <.LVL1>:
    99c6:	dc 0a       	cmpa	r10,	r12	;
    99c8:	07 28       	jnc	$+16     	;abs 0x99d8

000099ca <.Loc.26.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    99ca:	cc 0e       	mova	r14,	r12	;
    99cc:	ac 00 17 a8 	adda	#43031,	r12	;0x0a817

000099d0 <.LVL2>:
  
  curr_index += size;
    99d0:	60 0a 0e a8 	mova	r10,	&43022	; 0x0a80e

000099d4 <.L1>:
  return result;
}
    99d4:	0a 16       	popm.a	#1,	r10	;20-bit words
    99d6:	10 01       	reta			;

000099d8 <.L3>:
    return NULL;
    99d8:	4c 43       	clr.b	r12		;
    99da:	80 00 d4 99 	mova	#39380,	r0	;0x099d4

000099de <clamp>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    99de:	1a 14       	pushm.a	#2,	r10	;20-bit words

000099e0 <.LCFI1>:
    99e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    99e4:	49 4d       	mov.b	r13,	r9	;
    99e6:	4a 4e       	mov.b	r14,	r10	;

000099e8 <.Loc.35.1>:
  if (value < min) {
    99e8:	4c 99       	cmp.b	r9,	r12	;
    99ea:	07 2c       	jc	$+16     	;abs 0x99fa

000099ec <.LVL5>:
    value = min;
    elyErrorSignal(ErrRegClip);
    99ec:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    99f0:	b0 13 2a 91 	calla	#37162		;0x0912a

000099f4 <.LVL6>:
    99f4:	0c 49       	mov	r9,	r12	;

000099f6 <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    99f6:	19 16       	popm.a	#2,	r10	;20-bit words
    99f8:	10 01       	reta			;

000099fa <.L5>:
  else if (value > max) {
    99fa:	4a 9c       	cmp.b	r12,	r10	;
    99fc:	fc 2f       	jc	$-6      	;abs 0x99f6

000099fe <.LVL9>:
    elyErrorSignal(ErrRegClip);
    99fe:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9a02:	b0 13 2a 91 	calla	#37162		;0x0912a

00009a06 <.LVL10>:
    9a06:	0c 4a       	mov	r10,	r12	;
    9a08:	80 00 f6 99 	mova	#39414,	r0	;0x099f6

00009a0c <uart_pass>:
  
  return;
}

static inline msg_t uart_pass(uint8_t * buffer) {
  return elyUARTPost(buffer, TIME_INFINITE);
    9a0c:	4d 43       	clr.b	r13		;
    9a0e:	b0 13 9c 60 	calla	#24732		;0x0609c

00009a12 <.LVL12>:
}
    9a12:	10 01       	reta			;

00009a14 <fw>:
static inline msg_t uart_pass_i(uint8_t * buffer) {
  return elyUARTPostI(buffer);
}

static inline msg_t fw(uint8_t * buffer) {
  return elyMainMBPost(buffer, TIME_INFINITE);
    9a14:	4d 43       	clr.b	r13		;
    9a16:	b0 13 48 65 	calla	#25928		;0x06548

00009a1a <.LVL14>:
}
    9a1a:	10 01       	reta			;

00009a1c <rf_pass>:
  return elyRFPost(buffer, TIME_INFINITE);
    9a1c:	4d 43       	clr.b	r13		;
    9a1e:	b0 13 6e 91 	calla	#37230		;0x0916e

00009a22 <.LVL16>:
}
    9a22:	10 01       	reta			;

00009a24 <elyNLClampReg>:
uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    9a24:	1a 14       	pushm.a	#2,	r10	;20-bit words

00009a26 <.LCFI2>:
    9a26:	49 4c       	mov.b	r12,	r9	;
    9a28:	4a 4d       	mov.b	r13,	r10	;

00009a2a <.Loc.75.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    9a2a:	4c 49       	mov.b	r9,	r12	;

00009a2c <.LVL24>:
    9a2c:	7c 50 80 ff 	add.b	#-128,	r12	;#0xff80
    9a30:	7d 40 09 00 	mov.b	#9,	r13	;

00009a34 <.LVL25>:
    9a34:	4d 9c       	cmp.b	r12,	r13	;
    9a36:	04 2c       	jc	$+10     	;abs 0x9a40

00009a38 <.Loc.75.1>:
    9a38:	8c 01 9b 06 	mova	#67227,	r12	;0x1069b
    9a3c:	b0 13 5c 46 	calla	#18012		;0x0465c

00009a40 <.L14>:
  switch(addr) {
    9a40:	79 90 83 ff 	cmp.b	#-125,	r9	;#0xff83
    9a44:	35 24       	jz	$+108    	;abs 0x9ab0
    9a46:	7d 40 83 ff 	mov.b	#-125,	r13	;#0xff83
    9a4a:	4d 99       	cmp.b	r9,	r13	;
    9a4c:	09 28       	jnc	$+20     	;abs 0x9a60
    9a4e:	79 90 80 ff 	cmp.b	#-128,	r9	;#0xff80
    9a52:	20 24       	jz	$+66     	;abs 0x9a94
    9a54:	79 90 81 ff 	cmp.b	#-127,	r9	;#0xff81
    9a58:	26 24       	jz	$+78     	;abs 0x9aa6

00009a5a <.L15>:
}
    9a5a:	4c 4a       	mov.b	r10,	r12	;
    9a5c:	19 16       	popm.a	#2,	r10	;20-bit words
    9a5e:	10 01       	reta			;

00009a60 <.L17>:
  switch(addr) {
    9a60:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    9a64:	29 24       	jz	$+84     	;abs 0x9ab8
    9a66:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    9a6a:	f7 2b       	jnc	$-16     	;abs 0x9a5a
    9a6c:	79 50 79 00 	add.b	#121,	r9	;#0x0079
    9a70:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9a72:	4c 99       	cmp.b	r9,	r12	;
    9a74:	f2 2b       	jnc	$-26     	;abs 0x9a5a

00009a76 <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    9a76:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    9a7a:	10 00 
    9a7c:	21 24       	jz	$+68     	;abs 0x9ac0
    9a7e:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    9a82:	1e 24       	jz	$+62     	;abs 0x9ac0

00009a84 <.Loc.48.1>:
    elyErrorSignal(ErrRegClip);
    9a84:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9a88:	b0 13 2a 91 	calla	#37162		;0x0912a

00009a8c <.LVL29>:
    return 0x10;
    9a8c:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

00009a90 <.LVL30>:
    9a90:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009a94 <.L18>:
      value = clamp(value, 7, 0xFF);
    9a94:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9a96:	7d 40 07 00 	mov.b	#7,	r13	;

00009a9a <.L61>:
      value = clamp(value, 0, 0x10);
    9a9a:	4c 4a       	mov.b	r10,	r12	;
    9a9c:	b0 13 de 99 	calla	#39390		;0x099de

00009aa0 <.LVL32>:
    9aa0:	4a 4c       	mov.b	r12,	r10	;

00009aa2 <.LVL33>:
      break;
    9aa2:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009aa6 <.L19>:
      value = clamp(value, 0, 0x10);
    9aa6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

00009aaa <.L62>:
    9aaa:	4d 43       	clr.b	r13		;
    9aac:	80 00 9a 9a 	mova	#39578,	r0	;0x09a9a

00009ab0 <.L16>:
      value = clamp(value, 0, 0x07);
    9ab0:	7e 40 07 00 	mov.b	#7,	r14	;
    9ab4:	80 00 aa 9a 	mova	#39594,	r0	;0x09aaa

00009ab8 <.L20>:
      value = clamp(value, 0, 0x3F);
    9ab8:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    9abc:	80 00 aa 9a 	mova	#39594,	r0	;0x09aaa

00009ac0 <.L22>:
  if ((value & 0x08) && value != 0x08) {
    9ac0:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    9ac4:	09 24       	jz	$+20     	;abs 0x9ad8
    9ac6:	3a 92       	cmp	#8,	r10	;r2 As==11
    9ac8:	07 24       	jz	$+16     	;abs 0x9ad8

00009aca <.Loc.52.1>:
    elyErrorSignal(ErrRegClip);
    9aca:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9ace:	b0 13 2a 91 	calla	#37162		;0x0912a

00009ad2 <.LVL36>:
    return 0x08;
    9ad2:	7a 42       	mov.b	#8,	r10	;r2 As==11

00009ad4 <.LVL37>:
    9ad4:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009ad8 <.L23>:
  if ((value & 0x04) && value != 0x04) {
    9ad8:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    9adc:	09 24       	jz	$+20     	;abs 0x9af0
    9ade:	2a 92       	cmp	#4,	r10	;r2 As==10
    9ae0:	07 24       	jz	$+16     	;abs 0x9af0

00009ae2 <.Loc.56.1>:
    elyErrorSignal(ErrRegClip);
    9ae2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9ae6:	b0 13 2a 91 	calla	#37162		;0x0912a

00009aea <.LVL39>:
    return 0x04;
    9aea:	6a 42       	mov.b	#4,	r10	;r2 As==10

00009aec <.LVL40>:
    9aec:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009af0 <.L24>:
  if ((value & 0x02) && value != 0x02) {
    9af0:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    9af4:	09 24       	jz	$+20     	;abs 0x9b08
    9af6:	2a 93       	cmp	#2,	r10	;r3 As==10
    9af8:	07 24       	jz	$+16     	;abs 0x9b08

00009afa <.Loc.60.1>:
    elyErrorSignal(ErrRegClip);
    9afa:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9afe:	b0 13 2a 91 	calla	#37162		;0x0912a

00009b02 <.LVL42>:
    return 0x02;
    9b02:	6a 43       	mov.b	#2,	r10	;r3 As==10

00009b04 <.LVL43>:
    9b04:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009b08 <.L25>:
  if ((value & 0x01) && value != 0x01) {
    9b08:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    9b0c:	09 24       	jz	$+20     	;abs 0x9b20
    9b0e:	1a 93       	cmp	#1,	r10	;r3 As==01
    9b10:	07 24       	jz	$+16     	;abs 0x9b20

00009b12 <.Loc.64.1>:
    elyErrorSignal(ErrRegClip);
    9b12:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9b16:	b0 13 2a 91 	calla	#37162		;0x0912a

00009b1a <.LVL45>:
    return 0x01;
    9b1a:	5a 43       	mov.b	#1,	r10	;r3 As==01

00009b1c <.LVL46>:
    9b1c:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009b20 <.L26>:
  if (value & 0xD0) {
    9b20:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    9b24:	9a 27       	jz	$-202    	;abs 0x9a5a

00009b26 <.Loc.68.1>:
    elyErrorSignal(ErrRegClip);
    9b26:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9b2a:	b0 13 2a 91 	calla	#37162		;0x0912a

00009b2e <.LVL48>:
    return 0x00;
    9b2e:	4a 43       	clr.b	r10		;

00009b30 <.LVL49>:
    9b30:	80 00 5a 9a 	mova	#39514,	r0	;0x09a5a

00009b34 <elyNLGetBuffer>:
  return chPoolAlloc(&main_mpool);
    9b34:	8c 00 02 a8 	mova	#43010,	r12	;0x0a802
    9b38:	b0 13 70 4c 	calla	#19568		;0x04c70

00009b3c <.LVL57>:
}
    9b3c:	10 01       	reta			;

00009b3e <elyNLFreeBuffer>:
  chPoolFree(&main_mpool, buffer);
    9b3e:	cd 0c       	mova	r12,	r13	;
    9b40:	8c 00 02 a8 	mova	#43010,	r12	;0x0a802

00009b44 <.LVL59>:
    9b44:	b0 13 b0 4c 	calla	#19632		;0x04cb0

00009b48 <.LVL60>:
}
    9b48:	10 01       	reta			;

00009b4a <elyNLFreeBufferI>:
  chPoolFreeI(&main_mpool, buffer);
    9b4a:	cd 0c       	mova	r12,	r13	;
    9b4c:	8c 00 02 a8 	mova	#43010,	r12	;0x0a802

00009b50 <.LVL63>:
    9b50:	b0 13 84 4c 	calla	#19588		;0x04c84

00009b54 <.LVL64>:
}
    9b54:	10 01       	reta			;

00009b56 <elyNLGetDest>:
  (void)(buffer);
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (dest_addr == ground_apid) {
    9b56:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca

00009b5a <.LVL67>:
    9b5a:	5e 4c 83 00 	mov.b	131(r12),r14	;0x00083
    9b5e:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9b62:	5c 4c 82 00 	mov.b	130(r12),r12	;0x00082
    9b66:	0e dc       	bis	r12,	r14	;
    9b68:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9b6a:	0e 9d       	cmp	r13,	r14	;
    9b6c:	01 24       	jz	$+4      	;abs 0x9b70
    9b6e:	4c 43       	clr.b	r12		;

00009b70 <.L73>:
    return ELY_DEST_RF;
  }
  
  return ELY_DEST_UART;
}
    9b70:	10 01       	reta			;

00009b72 <is_fw_buf>:

bool is_fw_buf(uint8_t * buffer) {
    9b72:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009b74 <.LCFI7>:
   * If (TM AND APID == Elysium) FW Reply
   * If (TC AND APID == Elysium) Coding error
   * Else NL packet */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    9b74:	6d 4c       	mov.b	@r12,	r13	;

00009b76 <.LVL69>:
    9b76:	0e 4d       	mov	r13,	r14	;
    9b78:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9b7c:	3e f0 00 07 	and	#1792,	r14	;#0x0700
    9b80:	5c 4c 01 00 	mov.b	1(r12),	r12	;

00009b84 <.LVL70>:
    9b84:	0c de       	bis	r14,	r12	;

00009b86 <.LVL71>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9b86:	2a 01 ca 05 	mova	&67018,	r10	;0x105ca
    9b8a:	5e 4a 51 00 	mov.b	81(r10),r14	;0x00051
    9b8e:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9b92:	5a 4a 50 00 	mov.b	80(r10),r10	;0x00050
    9b96:	0e da       	bis	r10,	r14	;

00009b98 <.Loc.277.1>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (apid == elysium_apid) {
    9b98:	0c 9e       	cmp	r14,	r12	;
    9b9a:	06 20       	jnz	$+14     	;abs 0x9ba8

00009b9c <.Loc.278.1>:
    if (!tc) {
    9b9c:	0c 4d       	mov	r13,	r12	;
    9b9e:	5c 0f       	rrum	#4,	r12	;
    9ba0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9ba2:	5c f3       	and.b	#1,	r12	;r3 As==01

00009ba4 <.L75>:
      /* Fall through to NL to allow loopback */
    }
  }
  
  return false;
}
    9ba4:	0a 16       	popm.a	#1,	r10	;20-bit words
    9ba6:	10 01       	reta			;

00009ba8 <.L76>:
  return false;
    9ba8:	4c 43       	clr.b	r12		;
    9baa:	80 00 a4 9b 	mova	#39844,	r0	;0x09ba4

00009bae <elyNLFreeBufferChecked>:
  
void elyNLFreeBufferChecked(uint8_t * buffer) {
    9bae:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009bb0 <.LCFI8>:
    9bb0:	ca 0c       	mova	r12,	r10	;

00009bb2 <.Loc.290.1>:
  if (is_fw_buf(buffer)) {
    9bb2:	b0 13 72 9b 	calla	#39794		;0x09b72

00009bb6 <.LVL73>:
    9bb6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9bb8:	05 24       	jz	$+12     	;abs 0x9bc4

00009bba <.Loc.291.1>:
      elyFWFreeBuffer(buffer);
    9bba:	cc 0a       	mova	r10,	r12	;
    9bbc:	b0 13 ca 62 	calla	#25290		;0x062ca

00009bc0 <.L77>:
  }
  else {
    elyNLFreeBuffer(buffer);
  }
}
    9bc0:	0a 16       	popm.a	#1,	r10	;20-bit words
    9bc2:	10 01       	reta			;

00009bc4 <.L78>:
    elyNLFreeBuffer(buffer);
    9bc4:	cc 0a       	mova	r10,	r12	;
    9bc6:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00009bca <.LVL75>:
}
    9bca:	80 00 c0 9b 	mova	#39872,	r0	;0x09bc0

00009bce <elyNLFreeBufferCheckedI>:

void elyNLFreeBufferCheckedI(uint8_t * buffer) {
    9bce:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009bd0 <.LCFI9>:
    9bd0:	ca 0c       	mova	r12,	r10	;

00009bd2 <.Loc.299.1>:
  if (is_fw_buf(buffer)) {
    9bd2:	b0 13 72 9b 	calla	#39794		;0x09b72

00009bd6 <.LVL77>:
    9bd6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9bd8:	05 24       	jz	$+12     	;abs 0x9be4

00009bda <.Loc.300.1>:
      elyFWFreeBufferI(buffer);
    9bda:	cc 0a       	mova	r10,	r12	;
    9bdc:	b0 13 b6 62 	calla	#25270		;0x062b6

00009be0 <.L80>:
  }
  else {
    elyNLFreeBufferI(buffer);
  }
}
    9be0:	0a 16       	popm.a	#1,	r10	;20-bit words
    9be2:	10 01       	reta			;

00009be4 <.L81>:
    elyNLFreeBufferI(buffer);
    9be4:	cc 0a       	mova	r10,	r12	;
    9be6:	b0 13 4a 9b 	calla	#39754		;0x09b4a

00009bea <.LVL79>:
}
    9bea:	80 00 e0 9b 	mova	#39904,	r0	;0x09be0

00009bee <elyNLInit>:
      /* 4-byte Secondary Header + 6-byte Primary Header */
      sh_len = 4;
    }
  }
  
  sh_len = 0;
    9bee:	00 18 c2 43 	movx.a	#0,	&0xfcad8;r3 As==00
    9bf2:	d8 ca 

00009bf4 <.Loc.321.1>:
}
    9bf4:	10 01       	reta			;

00009bf6 <elyNLSetHeader>:

void elyNLSetHeader(uint8_t * buffer, uint16_t length, uint16_t dest_addr) {
    9bf6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009bf8 <.LCFI10>:
  /* dest_addr not used for SPP */
  (void)(dest_addr);
  
  /* Set APID */
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9bf8:	2e 01 ca 05 	mova	&67018,	r14	;0x105ca

00009bfc <.LVL83>:
    9bfc:	5f 4e 51 00 	mov.b	81(r14),r15	;0x00051
    9c00:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    9c04:	5a 4e 50 00 	mov.b	80(r14),r10	;0x00050
    9c08:	0f da       	bis	r10,	r15	;

00009c0a <.LVL84>:
        (bank0p[RegSrcAddrLsb])) );
  buffer[0] = (elysium_apid >> 8);
    9c0a:	0b 4f       	mov	r15,	r11	;
    9c0c:	5b 0f       	rrum	#4,	r11	;
    9c0e:	5b 0f       	rrum	#4,	r11	;
    9c10:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

00009c14 <.Loc.331.1>:
  buffer[1] = (elysium_apid & 0xFF);
    9c14:	cc 4f 01 00 	mov.b	r15,	1(r12)	;

00009c18 <.Loc.333.1>:
  
  length = (length + sh_len - 1);
    9c18:	40 18 1f 42 	movx.w	&0x0cad8,r15	;
    9c1c:	d8 ca 

00009c1e <.LVL85>:
    9c1e:	3f 53       	add	#-1,	r15	;r3 As==11
    9c20:	0d 5f       	add	r15,	r13	;

00009c22 <.LVL86>:
  buffer[4] = (length >> 8);
    9c22:	0f 4d       	mov	r13,	r15	;
    9c24:	5f 0f       	rrum	#4,	r15	;
    9c26:	5f 0f       	rrum	#4,	r15	;
    9c28:	cc 4f 04 00 	mov.b	r15,	4(r12)	;

00009c2c <.Loc.335.1>:
  buffer[5] = (length & 0xFF);
    9c2c:	cc 4d 05 00 	mov.b	r13,	5(r12)	;

00009c30 <.Loc.337.1>:
  
  uint8_t options = bank0p[RegNLOptions];
    9c30:	5d 4e 86 00 	mov.b	134(r14),r13	;0x00086

00009c34 <.LVL87>:
  
  if (options & 0x04) {
    9c34:	40 18 2d b2 	bitx.w	#4,	r13	;r2 As==10
    9c38:	36 24       	jz	$+110    	;abs 0x9ca6

00009c3a <.LBB21>:
  _disable_interrupts();
    9c3a:	32 c2       	dint			
    9c3c:	03 43       	nop			

00009c3e <.Loc.348.2>:
  asm volatile("nop");
    9c3e:	03 43       	nop			

00009c40 <.LBE21>:
    chSysLock();
    buffer[2] = bank0p[RegNLPktNameMsb];
    9c40:	dc 4e 85 00 	mov.b	133(r14),2(r12)	;0x00085
    9c44:	02 00 

00009c46 <.LVL88>:
    buffer[3] = bank0p[RegNLPktNameLsb];
    9c46:	dc 4e 84 00 	mov.b	132(r14),3(r12)	;0x00084
    9c4a:	03 00 

00009c4c <.LBB23>:
  asm volatile("nop");
    9c4c:	03 43       	nop			

00009c4e <.Loc.356.2>:
  _enable_interrupts();
    9c4e:	03 43       	nop			
    9c50:	32 d2       	eint			
    9c52:	03 43       	nop			

00009c54 <.L86>:
  else {
    buffer[2] = (packets_sent >> 8) | 0xC0;
    buffer[3] = (packets_sent & 0xFF);
  }
  
  packets_sent = (packets_sent + 1) & 0x3FFF;
    9c54:	40 18 1f 42 	movx.w	&0x0a814,r15	;
    9c58:	14 a8 
    9c5a:	1f 53       	inc	r15		;
    9c5c:	3f f0 ff 3f 	and	#16383,	r15	;#0x3fff
    9c60:	40 18 82 4f 	movx.w	r15,	&0xfa814;
    9c64:	14 a8 

00009c66 <.Loc.353.1>:
  
  /* insert timestamps here too if required */
  if (options & 0x02) { /* Timestamp */
    9c66:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9c6a:	1b 24       	jz	$+56     	;abs 0x9ca2

00009c6c <.Loc.354.1>:
    buffer[0] |= 0x08; /* Sec Hdr Flag */
    9c6c:	fc d2 00 00 	bis.b	#8,	0(r12)	;r2 As==11

00009c70 <.Loc.355.1>:
    if (options & 0x01) { /* P-field */
    9c70:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9c74:	26 24       	jz	$+78     	;abs 0x9cc2

00009c76 <.Loc.356.1>:
      buffer[6] = SPP_PFIELD;
    9c76:	fc 40 2c 00 	mov.b	#44,	6(r12)	;#0x002c
    9c7a:	06 00 

00009c7c <.LBB25>:
  _disable_interrupts();
    9c7c:	32 c2       	dint			
    9c7e:	03 43       	nop			

00009c80 <.Loc.348.2>:
  asm volatile("nop");
    9c80:	03 43       	nop			

00009c82 <.LBE25>:
      chSysLock();
      buffer[7] = bank0p[RegMissionTimeMsb];
    9c82:	dc 4e 76 00 	mov.b	118(r14),7(r12)	;0x00076
    9c86:	07 00 

00009c88 <.Loc.359.1>:
      buffer[8] = bank0p[RegMissionTimeHmb];
    9c88:	dc 4e 75 00 	mov.b	117(r14),8(r12)	;0x00075
    9c8c:	08 00 

00009c8e <.Loc.360.1>:
      buffer[9] = bank0p[RegMissionTimeLmb];
    9c8e:	dc 4e 74 00 	mov.b	116(r14),9(r12)	;0x00074
    9c92:	09 00 

00009c94 <.Loc.361.1>:
      buffer[10] = bank0p[RegMissionTimeLsb];
    9c94:	dc 4e 73 00 	mov.b	115(r14),10(r12)	;0x00073, 0x000a
    9c98:	0a 00 

00009c9a <.L92>:
  asm volatile("nop");
    9c9a:	03 43       	nop			

00009c9c <.Loc.356.2>:
  _enable_interrupts();
    9c9c:	03 43       	nop			
    9c9e:	32 d2       	eint			
    9ca0:	03 43       	nop			

00009ca2 <.L84>:
      chSysUnlock();
    }
  }
  
  return;
}
    9ca2:	0a 16       	popm.a	#1,	r10	;20-bit words
    9ca4:	10 01       	reta			;

00009ca6 <.L85>:
    buffer[2] = (packets_sent >> 8) | 0xC0;
    9ca6:	40 18 1f 42 	movx.w	&0x0a814,r15	;
    9caa:	14 a8 
    9cac:	0b 4f       	mov	r15,	r11	;
    9cae:	5b 0f       	rrum	#4,	r11	;
    9cb0:	5b 0f       	rrum	#4,	r11	;
    9cb2:	7b d0 c0 ff 	bis.b	#-64,	r11	;#0xffc0
    9cb6:	cc 4b 02 00 	mov.b	r11,	2(r12)	;

00009cba <.LVL90>:
    buffer[3] = (packets_sent & 0xFF);
    9cba:	cc 4f 03 00 	mov.b	r15,	3(r12)	;
    9cbe:	80 00 54 9c 	mova	#40020,	r0	;0x09c54

00009cc2 <.L88>:
  _disable_interrupts();
    9cc2:	32 c2       	dint			
    9cc4:	03 43       	nop			

00009cc6 <.Loc.348.2>:
  asm volatile("nop");
    9cc6:	03 43       	nop			

00009cc8 <.LBE29>:
      buffer[6] = bank0p[RegMissionTimeMsb];
    9cc8:	dc 4e 76 00 	mov.b	118(r14),6(r12)	;0x00076
    9ccc:	06 00 

00009cce <.Loc.369.1>:
      buffer[7] = bank0p[RegMissionTimeHmb];
    9cce:	dc 4e 75 00 	mov.b	117(r14),7(r12)	;0x00075
    9cd2:	07 00 

00009cd4 <.Loc.370.1>:
      buffer[8] = bank0p[RegMissionTimeLmb];
    9cd4:	dc 4e 74 00 	mov.b	116(r14),8(r12)	;0x00074
    9cd8:	08 00 

00009cda <.Loc.371.1>:
      buffer[9] = bank0p[RegMissionTimeLsb];
    9cda:	dc 4e 73 00 	mov.b	115(r14),9(r12)	;0x00073
    9cde:	09 00 
    9ce0:	80 00 9a 9c 	mova	#40090,	r0	;0x09c9a

00009ce4 <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    9ce4:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    9ce8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9cec:	5c 4c 05 00 	mov.b	5(r12),	r12	;

00009cf0 <.LVL92>:
    9cf0:	0c dd       	bis	r13,	r12	;
    9cf2:	3c 50 07 00 	add	#7,	r12	;
    9cf6:	4c 0e       	rlam.a	#4,	r12	;
    9cf8:	4c 0d       	rram.a	#4,	r12	;

00009cfa <.Loc.381.1>:
}
    9cfa:	10 01       	reta			;

00009cfc <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    9cfc:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009cfe <.LCFI11>:
  if (buffer[0] & 0xE0) {
    9cfe:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    9d02:	00 00 
    9d04:	07 24       	jz	$+16     	;abs 0x9d14

00009d06 <.Loc.139.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    9d06:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

00009d0a <.L98>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    9d0a:	b0 13 2a 91 	calla	#37162		;0x0912a

00009d0e <.LVL95>:
    9d0e:	4c 43       	clr.b	r12		;

00009d10 <.L96>:
}
    9d10:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d12:	10 01       	reta			;

00009d14 <.L95>:
  _disable_interrupts();
    9d14:	32 c2       	dint			
    9d16:	03 43       	nop			

00009d18 <.Loc.348.2>:
  asm volatile("nop");
    9d18:	03 43       	nop			

00009d1a <.LBE44>:
  if ( elyNLGetLength(buffer) > 
    9d1a:	b0 13 e4 9c 	calla	#40164		;0x09ce4

00009d1e <.LVL97>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    9d1e:	2a 01 ca 05 	mova	&67018,	r10	;0x105ca
    9d22:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    9d26:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9d2a:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    9d2e:	0e da       	bis	r10,	r14	;
    9d30:	40 18 0e 4e 	movx.w	r14,	r14	;

00009d34 <.Loc.145.1>:
  if ( elyNLGetLength(buffer) > 
    9d34:	de 0c       	cmpa	r12,	r14	;
    9d36:	08 2c       	jc	$+18     	;abs 0x9d48

00009d38 <.LBB41>:
  asm volatile("nop");
    9d38:	03 43       	nop			

00009d3a <.Loc.356.2>:
  _enable_interrupts();
    9d3a:	03 43       	nop			
    9d3c:	32 d2       	eint			
    9d3e:	03 43       	nop			

00009d40 <.LBE41>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    9d40:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    9d44:	80 00 0a 9d 	mova	#40202,	r0	;0x09d0a

00009d48 <.L97>:
  asm volatile("nop");
    9d48:	03 43       	nop			

00009d4a <.Loc.356.2>:
  _enable_interrupts();
    9d4a:	03 43       	nop			
    9d4c:	32 d2       	eint			
    9d4e:	03 43       	nop			

00009d50 <.LBE47>:
  return true;
    9d50:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9d52:	80 00 10 9d 	mova	#40208,	r0	;0x09d10

00009d56 <nl_route>:
    msg_t (*loop_func)(uint8_t *)) {
    9d56:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009d58 <.LCFI12>:
    9d58:	08 14       	pushm.a	#1,	r8	;20-bit words

00009d5a <.LCFI13>:
    9d5a:	06 14       	pushm.a	#1,	r6	;20-bit words

00009d5c <.LCFI14>:
    9d5c:	04 14       	pushm.a	#1,	r4	;20-bit words

00009d5e <.LCFI15>:
    9d5e:	ca 0c       	mova	r12,	r10	;
    9d60:	c4 0d       	mova	r13,	r4	;
    9d62:	c6 0e       	mova	r14,	r6	;
    9d64:	c8 0f       	mova	r15,	r8	;

00009d66 <.Loc.166.1>:
  if (!elyNLValidate(buffer)) {
    9d66:	b0 13 fc 9c 	calla	#40188		;0x09cfc

00009d6a <.LVL101>:
    9d6a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9d6c:	08 20       	jnz	$+18     	;abs 0x9d7e

00009d6e <.L108>:
        elyNLFreeBuffer(buffer);
    9d6e:	cc 0a       	mova	r10,	r12	;
    9d70:	b0 13 3e 9b 	calla	#39742		;0x09b3e

00009d74 <.L99>:
}
    9d74:	04 16       	popm.a	#1,	r4	;20-bit words
    9d76:	06 16       	popm.a	#1,	r6	;20-bit words
    9d78:	08 16       	popm.a	#1,	r8	;20-bit words
    9d7a:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d7c:	10 01       	reta			;

00009d7e <.L100>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    9d7e:	6e 4a       	mov.b	@r10,	r14	;

00009d80 <.LVL103>:
    9d80:	0d 4e       	mov	r14,	r13	;
    9d82:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9d86:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    9d8a:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    9d8e:	0d dc       	bis	r12,	r13	;

00009d90 <.Loc.173.1>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9d90:	2c 01 ca 05 	mova	&67018,	r12	;0x105ca
    9d94:	5f 4c 51 00 	mov.b	81(r12),r15	;0x00051
    9d98:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    9d9c:	5c 4c 50 00 	mov.b	80(r12),r12	;0x00050
    9da0:	0f dc       	bis	r12,	r15	;

00009da2 <.Loc.177.1>:
  if (apid == elysium_apid) {
    9da2:	0d 9f       	cmp	r15,	r13	;
    9da4:	17 20       	jnz	$+48     	;abs 0x9dd4

00009da6 <.Loc.178.1>:
    if (tc) {
    9da6:	40 18 3e b0 	bitx.w	#16,	r14	;0x00010
    9daa:	10 00 
    9dac:	0b 24       	jz	$+24     	;abs 0x9dc4

00009dae <.Loc.179.1>:
      if (MSG_OK != fw_func(buffer)) {
    9dae:	cc 0a       	mova	r10,	r12	;
    9db0:	46 13       	calla	r6		;

00009db2 <.L106>:
    9db2:	9c 00 00 00 	cmpa	#0,	r12	;
    9db6:	de 27       	jz	$-66     	;abs 0x9d74

00009db8 <.Loc.181.1>:
        chDbgAssert(false, "internal buffer overflows should be impossible");
    9db8:	8c 01 92 06 	mova	#67218,	r12	;0x10692
    9dbc:	b0 13 5c 46 	calla	#18012		;0x0465c

00009dc0 <.LVL105>:
    9dc0:	80 00 6e 9d 	mova	#40302,	r0	;0x09d6e

00009dc4 <.L103>:
      buffer[0] |= 0x10; /* set apid to free properly */
    9dc4:	7e d0 10 00 	bis.b	#16,	r14	;#0x0010

00009dc8 <.LVL107>:
    9dc8:	ca 4e 00 00 	mov.b	r14,	0(r10)	;

00009dcc <.LVL108>:
      if (MSG_OK != loop_func(buffer)) {
    9dcc:	cc 0a       	mova	r10,	r12	;
    9dce:	48 13       	calla	r8		;

00009dd0 <.LVL109>:
    9dd0:	80 00 b2 9d 	mova	#40370,	r0	;0x09db2

00009dd4 <.L102>:
  if (MSG_OK != pass_func(buffer)) {
    9dd4:	cc 0a       	mova	r10,	r12	;
    9dd6:	44 13       	calla	r4		;

00009dd8 <.LVL111>:
    9dd8:	80 00 b2 9d 	mova	#40370,	r0	;0x09db2

00009ddc <elyNLRouteUART>:
  nl_route(buffer, rf_pass, fw, uart_pass);
    9ddc:	8f 00 0c 9a 	mova	#39436,	r15	;0x09a0c
    9de0:	8e 00 14 9a 	mova	#39444,	r14	;0x09a14
    9de4:	8d 00 1c 9a 	mova	#39452,	r13	;0x09a1c
    9de8:	b0 13 56 9d 	calla	#40278		;0x09d56

00009dec <.LVL113>:
}
    9dec:	10 01       	reta			;

00009dee <elyNLToFW>:
size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - sh_len + 1;
}

uint8_t * elyNLToFW(uint8_t * buffer) {
  return buffer + sh_len + 6;
    9dee:	2e 00 d8 ca 	mova	&51928,	r14	;0x0cad8
    9df2:	ae 00 06 00 	adda	#6,	r14	;

00009df6 <.Loc.389.1>:
}
    9df6:	ec 0e       	adda	r14,	r12	;

00009df8 <.LVL121>:
    9df8:	10 01       	reta			;

00009dfa <elyNLFromFW>:

uint8_t * elyNLFromFW(uint8_t * buffer) {
  return buffer - sh_len - 6;
    9dfa:	8e 0f fa ff 	mova	#-6,	r14	;0xfffffffa
    9dfe:	00 18 5e 82 	subx.a	&0x0cad8,r14	;
    9e02:	d8 ca 

00009e04 <.Loc.393.1>:
}
    9e04:	ec 0e       	adda	r14,	r12	;

00009e06 <.LVL123>:
    9e06:	10 01       	reta			;

00009e08 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    9e08:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    9e0c:	80 5a 5c 01 

00009e10 <.Loc.51.1>:

  halInit();
    9e10:	b0 13 3e 4d 	calla	#19774		;0x04d3e

00009e14 <.LVL0>:
  elyNLInit();
    9e14:	b0 13 ee 9b 	calla	#39918		;0x09bee

00009e18 <.LVL1>:
  elyFramInit();
    9e18:	b0 13 aa 99 	calla	#39338		;0x099aa

00009e1c <.LVL2>:
  chSysInit();
    9e1c:	b0 13 32 45 	calla	#17714		;0x04532

00009e20 <.L3>:
    9e20:	80 00 20 9e 	mova	#40480,	r0	;0x09e20

00009e24 <udivmodsi4>:
    9e24:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009e26 <.LCFI0>:
    9e26:	0a 4c       	mov	r12,	r10	;
    9e28:	0b 4d       	mov	r13,	r11	;

00009e2a <.LVL1>:
    9e2a:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00009e2e <.Loc.35.1>:
    9e2e:	58 43       	mov.b	#1,	r8	;r3 As==01
    9e30:	49 43       	clr.b	r9		;

00009e32 <.Loc.38.1>:
    9e32:	07 4b       	mov	r11,	r7	;

00009e34 <.L2>:
    9e34:	0f 9b       	cmp	r11,	r15	;
    9e36:	11 28       	jnc	$+36     	;abs 0x9e5a
    9e38:	07 9f       	cmp	r15,	r7	;
    9e3a:	02 20       	jnz	$+6      	;abs 0x9e40
    9e3c:	0e 9a       	cmp	r10,	r14	;
    9e3e:	0d 28       	jnc	$+28     	;abs 0x9e5a

00009e40 <.L20>:
    9e40:	4c 43       	clr.b	r12		;

00009e42 <.LVL3>:
    9e42:	0d 4c       	mov	r12,	r13	;

00009e44 <.L5>:
    9e44:	07 48       	mov	r8,	r7	;
    9e46:	07 d9       	bis	r9,	r7	;
    9e48:	07 93       	cmp	#0,	r7	;r3 As==00
    9e4a:	1a 20       	jnz	$+54     	;abs 0x9e80

00009e4c <.L6>:
    9e4c:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    9e50:	02 24       	jz	$+6      	;abs 0x9e56
    9e52:	0c 4a       	mov	r10,	r12	;
    9e54:	0d 4b       	mov	r11,	r13	;

00009e56 <.L1>:
    9e56:	55 16       	popm.a	#6,	r10	;20-bit words
    9e58:	10 01       	reta			;

00009e5a <.L3>:
    9e5a:	3d 53       	add	#-1,	r13	;r3 As==11

00009e5c <.Loc.38.1>:
    9e5c:	0d 93       	cmp	#0,	r13	;r3 As==00
    9e5e:	24 24       	jz	$+74     	;abs 0x9ea8

00009e60 <.Loc.38.1>:
    9e60:	0f 93       	cmp	#0,	r15	;r3 As==00
    9e62:	ee 3b       	jl	$-34     	;abs 0x9e40

00009e64 <.Loc.40.1>:
    9e64:	05 4e       	mov	r14,	r5	;
    9e66:	06 4f       	mov	r15,	r6	;
    9e68:	05 5e       	add	r14,	r5	;
    9e6a:	06 6f       	addc	r15,	r6	;
    9e6c:	0e 45       	mov	r5,	r14	;

00009e6e <.LVL7>:
    9e6e:	0f 46       	mov	r6,	r15	;

00009e70 <.LVL8>:
    9e70:	05 48       	mov	r8,	r5	;
    9e72:	06 49       	mov	r9,	r6	;
    9e74:	05 58       	add	r8,	r5	;
    9e76:	06 69       	addc	r9,	r6	;
    9e78:	08 45       	mov	r5,	r8	;

00009e7a <.LVL9>:
    9e7a:	09 46       	mov	r6,	r9	;

00009e7c <.LVL10>:
    9e7c:	80 00 34 9e 	mova	#40500,	r0	;0x09e34

00009e80 <.L12>:
    9e80:	0b 9f       	cmp	r15,	r11	;
    9e82:	0a 28       	jnc	$+22     	;abs 0x9e98
    9e84:	0f 9b       	cmp	r11,	r15	;
    9e86:	02 20       	jnz	$+6      	;abs 0x9e8c
    9e88:	0a 9e       	cmp	r14,	r10	;
    9e8a:	06 28       	jnc	$+14     	;abs 0x9e98

00009e8c <.L16>:
    9e8c:	40 18 0a 8e 	subx.w	r14,	r10	;
    9e90:	40 18 0b 7f 	subcx.w	r15,	r11	;

00009e94 <.Loc.48.1>:
    9e94:	0c d8       	bis	r8,	r12	;

00009e96 <.LVL13>:
    9e96:	0d d9       	bis	r9,	r13	;

00009e98 <.L10>:
    9e98:	12 c3       	clrc			
    9e9a:	09 10       	rrc	r9		;
    9e9c:	08 10       	rrc	r8		;

00009e9e <.Loc.51.1>:
    9e9e:	12 c3       	clrc			
    9ea0:	0f 10       	rrc	r15		;
    9ea2:	0e 10       	rrc	r14		;
    9ea4:	80 00 44 9e 	mova	#40516,	r0	;0x09e44

00009ea8 <.L14>:
    9ea8:	0c 4d       	mov	r13,	r12	;

00009eaa <.LVL18>:
    9eaa:	80 00 4c 9e 	mova	#40524,	r0	;0x09e4c

00009eae <__mspabi_divlu>:
    9eae:	b1 00 02 00 	suba	#2,	r1	;

00009eb2 <.LCFI5>:
    9eb2:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9eb6:	b0 13 24 9e 	calla	#40484		;0x09e24

00009eba <.LVL46>:
    9eba:	a1 00 02 00 	adda	#2,	r1	;
    9ebe:	10 01       	reta			;

00009ec0 <__mspabi_slli_15>:
    9ec0:	0c 5c       	rla	r12		;

00009ec2 <__mspabi_slli_14>:
    9ec2:	0c 5c       	rla	r12		;

00009ec4 <__mspabi_slli_13>:
    9ec4:	0c 5c       	rla	r12		;

00009ec6 <__mspabi_slli_12>:
    9ec6:	0c 5c       	rla	r12		;

00009ec8 <__mspabi_slli_11>:
    9ec8:	0c 5c       	rla	r12		;

00009eca <__mspabi_slli_10>:
    9eca:	0c 5c       	rla	r12		;

00009ecc <__mspabi_slli_9>:
    9ecc:	0c 5c       	rla	r12		;

00009ece <__mspabi_slli_8>:
    9ece:	0c 5c       	rla	r12		;

00009ed0 <__mspabi_slli_7>:
    9ed0:	0c 5c       	rla	r12		;

00009ed2 <__mspabi_slli_6>:
    9ed2:	0c 5c       	rla	r12		;

00009ed4 <__mspabi_slli_5>:
    9ed4:	0c 5c       	rla	r12		;

00009ed6 <__mspabi_slli_4>:
    9ed6:	0c 5c       	rla	r12		;

00009ed8 <__mspabi_slli_3>:
    9ed8:	0c 5c       	rla	r12		;

00009eda <__mspabi_slli_2>:
    9eda:	0c 5c       	rla	r12		;

00009edc <__mspabi_slli_1>:
    9edc:	0c 5c       	rla	r12		;
    9ede:	10 01       	reta			;

00009ee0 <.L11>:
    9ee0:	3d 53       	add	#-1,	r13	;r3 As==11
    9ee2:	0c 5c       	rla	r12		;

00009ee4 <__mspabi_slli>:
    9ee4:	0d 93       	cmp	#0,	r13	;r3 As==00
    9ee6:	fc 23       	jnz	$-6      	;abs 0x9ee0
    9ee8:	10 01       	reta			;

00009eea <__mspabi_slll_15>:
    9eea:	0c 5c       	rla	r12		;
    9eec:	0d 6d       	rlc	r13		;

00009eee <__mspabi_slll_14>:
    9eee:	0c 5c       	rla	r12		;
    9ef0:	0d 6d       	rlc	r13		;

00009ef2 <__mspabi_slll_13>:
    9ef2:	0c 5c       	rla	r12		;
    9ef4:	0d 6d       	rlc	r13		;

00009ef6 <__mspabi_slll_12>:
    9ef6:	0c 5c       	rla	r12		;
    9ef8:	0d 6d       	rlc	r13		;

00009efa <__mspabi_slll_11>:
    9efa:	0c 5c       	rla	r12		;
    9efc:	0d 6d       	rlc	r13		;

00009efe <__mspabi_slll_10>:
    9efe:	0c 5c       	rla	r12		;
    9f00:	0d 6d       	rlc	r13		;

00009f02 <__mspabi_slll_9>:
    9f02:	0c 5c       	rla	r12		;
    9f04:	0d 6d       	rlc	r13		;

00009f06 <__mspabi_slll_8>:
    9f06:	0c 5c       	rla	r12		;
    9f08:	0d 6d       	rlc	r13		;

00009f0a <__mspabi_slll_7>:
    9f0a:	0c 5c       	rla	r12		;
    9f0c:	0d 6d       	rlc	r13		;

00009f0e <__mspabi_slll_6>:
    9f0e:	0c 5c       	rla	r12		;
    9f10:	0d 6d       	rlc	r13		;

00009f12 <__mspabi_slll_5>:
    9f12:	0c 5c       	rla	r12		;
    9f14:	0d 6d       	rlc	r13		;

00009f16 <__mspabi_slll_4>:
    9f16:	0c 5c       	rla	r12		;
    9f18:	0d 6d       	rlc	r13		;

00009f1a <__mspabi_slll_3>:
    9f1a:	0c 5c       	rla	r12		;
    9f1c:	0d 6d       	rlc	r13		;

00009f1e <__mspabi_slll_2>:
    9f1e:	0c 5c       	rla	r12		;
    9f20:	0d 6d       	rlc	r13		;

00009f22 <__mspabi_slll_1>:
    9f22:	0c 5c       	rla	r12		;
    9f24:	0d 6d       	rlc	r13		;
    9f26:	10 01       	reta			;

00009f28 <.L12>:
    9f28:	3e 53       	add	#-1,	r14	;r3 As==11
    9f2a:	0c 5c       	rla	r12		;
    9f2c:	0d 6d       	rlc	r13		;

00009f2e <__mspabi_slll>:
    9f2e:	0e 93       	cmp	#0,	r14	;r3 As==00
    9f30:	fb 23       	jnz	$-8      	;abs 0x9f28
    9f32:	10 01       	reta			;

00009f34 <__mspabi_srli_15>:
    9f34:	12 c3       	clrc			
    9f36:	0c 10       	rrc	r12		;

00009f38 <__mspabi_srli_14>:
    9f38:	12 c3       	clrc			
    9f3a:	0c 10       	rrc	r12		;

00009f3c <__mspabi_srli_13>:
    9f3c:	12 c3       	clrc			
    9f3e:	0c 10       	rrc	r12		;

00009f40 <__mspabi_srli_12>:
    9f40:	12 c3       	clrc			
    9f42:	0c 10       	rrc	r12		;

00009f44 <__mspabi_srli_11>:
    9f44:	12 c3       	clrc			
    9f46:	0c 10       	rrc	r12		;

00009f48 <__mspabi_srli_10>:
    9f48:	12 c3       	clrc			
    9f4a:	0c 10       	rrc	r12		;

00009f4c <__mspabi_srli_9>:
    9f4c:	12 c3       	clrc			
    9f4e:	0c 10       	rrc	r12		;

00009f50 <__mspabi_srli_8>:
    9f50:	12 c3       	clrc			
    9f52:	0c 10       	rrc	r12		;

00009f54 <__mspabi_srli_7>:
    9f54:	12 c3       	clrc			
    9f56:	0c 10       	rrc	r12		;

00009f58 <__mspabi_srli_6>:
    9f58:	12 c3       	clrc			
    9f5a:	0c 10       	rrc	r12		;

00009f5c <__mspabi_srli_5>:
    9f5c:	12 c3       	clrc			
    9f5e:	0c 10       	rrc	r12		;

00009f60 <__mspabi_srli_4>:
    9f60:	12 c3       	clrc			
    9f62:	0c 10       	rrc	r12		;

00009f64 <__mspabi_srli_3>:
    9f64:	12 c3       	clrc			
    9f66:	0c 10       	rrc	r12		;

00009f68 <__mspabi_srli_2>:
    9f68:	12 c3       	clrc			
    9f6a:	0c 10       	rrc	r12		;

00009f6c <__mspabi_srli_1>:
    9f6c:	12 c3       	clrc			
    9f6e:	0c 10       	rrc	r12		;
    9f70:	10 01       	reta			;

00009f72 <.L11>:
    9f72:	3d 53       	add	#-1,	r13	;r3 As==11
    9f74:	12 c3       	clrc			
    9f76:	0c 10       	rrc	r12		;

00009f78 <__mspabi_srli>:
    9f78:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f7a:	fb 23       	jnz	$-8      	;abs 0x9f72
    9f7c:	10 01       	reta			;

00009f7e <__mspabi_srll_15>:
    9f7e:	12 c3       	clrc			
    9f80:	0d 10       	rrc	r13		;
    9f82:	0c 10       	rrc	r12		;

00009f84 <__mspabi_srll_14>:
    9f84:	12 c3       	clrc			
    9f86:	0d 10       	rrc	r13		;
    9f88:	0c 10       	rrc	r12		;

00009f8a <__mspabi_srll_13>:
    9f8a:	12 c3       	clrc			
    9f8c:	0d 10       	rrc	r13		;
    9f8e:	0c 10       	rrc	r12		;

00009f90 <__mspabi_srll_12>:
    9f90:	12 c3       	clrc			
    9f92:	0d 10       	rrc	r13		;
    9f94:	0c 10       	rrc	r12		;

00009f96 <__mspabi_srll_11>:
    9f96:	12 c3       	clrc			
    9f98:	0d 10       	rrc	r13		;
    9f9a:	0c 10       	rrc	r12		;

00009f9c <__mspabi_srll_10>:
    9f9c:	12 c3       	clrc			
    9f9e:	0d 10       	rrc	r13		;
    9fa0:	0c 10       	rrc	r12		;

00009fa2 <__mspabi_srll_9>:
    9fa2:	12 c3       	clrc			
    9fa4:	0d 10       	rrc	r13		;
    9fa6:	0c 10       	rrc	r12		;

00009fa8 <__mspabi_srll_8>:
    9fa8:	12 c3       	clrc			
    9faa:	0d 10       	rrc	r13		;
    9fac:	0c 10       	rrc	r12		;

00009fae <__mspabi_srll_7>:
    9fae:	12 c3       	clrc			
    9fb0:	0d 10       	rrc	r13		;
    9fb2:	0c 10       	rrc	r12		;

00009fb4 <__mspabi_srll_6>:
    9fb4:	12 c3       	clrc			
    9fb6:	0d 10       	rrc	r13		;
    9fb8:	0c 10       	rrc	r12		;

00009fba <__mspabi_srll_5>:
    9fba:	12 c3       	clrc			
    9fbc:	0d 10       	rrc	r13		;
    9fbe:	0c 10       	rrc	r12		;

00009fc0 <__mspabi_srll_4>:
    9fc0:	12 c3       	clrc			
    9fc2:	0d 10       	rrc	r13		;
    9fc4:	0c 10       	rrc	r12		;

00009fc6 <__mspabi_srll_3>:
    9fc6:	12 c3       	clrc			
    9fc8:	0d 10       	rrc	r13		;
    9fca:	0c 10       	rrc	r12		;

00009fcc <__mspabi_srll_2>:
    9fcc:	12 c3       	clrc			
    9fce:	0d 10       	rrc	r13		;
    9fd0:	0c 10       	rrc	r12		;

00009fd2 <__mspabi_srll_1>:
    9fd2:	12 c3       	clrc			
    9fd4:	0d 10       	rrc	r13		;
    9fd6:	0c 10       	rrc	r12		;
    9fd8:	10 01       	reta			;

00009fda <.L12>:
    9fda:	3e 53       	add	#-1,	r14	;r3 As==11
    9fdc:	12 c3       	clrc			
    9fde:	0d 10       	rrc	r13		;
    9fe0:	0c 10       	rrc	r12		;

00009fe2 <__mspabi_srll>:
    9fe2:	0e 93       	cmp	#0,	r14	;r3 As==00
    9fe4:	fa 23       	jnz	$-10     	;abs 0x9fda
    9fe6:	10 01       	reta			;

00009fe8 <__mspabi_mpyl>:
    9fe8:	02 12       	push	r2		;
    9fea:	32 c2       	dint			
    9fec:	03 43       	nop			
    9fee:	82 4c d0 04 	mov	r12,	&0x04d0	;
    9ff2:	82 4d d2 04 	mov	r13,	&0x04d2	;
    9ff6:	82 4e e0 04 	mov	r14,	&0x04e0	;
    9ffa:	82 4f e2 04 	mov	r15,	&0x04e2	;
    9ffe:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    a002:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    a006:	32 41       	pop	r2		;
    a008:	10 01       	reta			;

0000a00a <memcpy>:
    a00a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a00c <.LCFI0>:
    a00c:	ca 0c       	mova	r12,	r10	;
    a00e:	ee 0c       	adda	r12,	r14	;

0000a010 <.L2>:
    a010:	da 0e       	cmpa	r14,	r10	;
    a012:	08 24       	jz	$+18     	;abs 0xa024

0000a014 <.LVL3>:
    a014:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    a018:	aa 00 01 00 	adda	#1,	r10	;

0000a01c <.LVL4>:
    a01c:	ad 00 01 00 	adda	#1,	r13	;
    a020:	80 00 10 a0 	mova	#40976,	r0	;0x0a010

0000a024 <.L5>:
    a024:	0a 16       	popm.a	#1,	r10	;20-bit words
    a026:	10 01       	reta			;

0000a028 <memset>:
    a028:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a02a <.LCFI0>:
    a02a:	ca 0c       	mova	r12,	r10	;
    a02c:	ee 0c       	adda	r12,	r14	;

0000a02e <.L2>:
    a02e:	da 0e       	cmpa	r14,	r10	;
    a030:	06 24       	jz	$+14     	;abs 0xa03e

0000a032 <.LVL3>:
    a032:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    a036:	aa 00 01 00 	adda	#1,	r10	;

0000a03a <.LVL4>:
    a03a:	80 00 2e a0 	mova	#41006,	r0	;0x0a02e

0000a03e <.L5>:
    a03e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a040:	10 01       	reta			;

0000a042 <memmove>:
    a042:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a044 <.LCFI0>:
    a044:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a046 <.LCFI1>:
    a046:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a048 <.LCFI2>:
    a048:	c8 0c       	mova	r12,	r8	;
    a04a:	e8 0e       	adda	r14,	r8	;

0000a04c <.Loc.69.1>:
    a04c:	dd 0c       	cmpa	r12,	r13	;
    a04e:	04 28       	jnc	$+10     	;abs 0xa058

0000a050 <.L4>:
    a050:	ce 0c       	mova	r12,	r14	;

0000a052 <.LVL2>:
    a052:	ca 0d       	mova	r13,	r10	;
    a054:	80 00 7c a0 	mova	#41084,	r0	;0x0a07c

0000a058 <.L2>:
    a058:	ca 0d       	mova	r13,	r10	;
    a05a:	ea 0e       	adda	r14,	r10	;
    a05c:	dc 0a       	cmpa	r10,	r12	;
    a05e:	f8 2f       	jc	$-14     	;abs 0xa050

0000a060 <.LVL4>:
    a060:	fe 0a       	suba	r10,	r14	;

0000a062 <.L5>:
    a062:	c6 0a       	mova	r10,	r6	;
    a064:	e6 0e       	adda	r14,	r6	;

0000a066 <.Loc.74.1>:
    a066:	96 00 00 00 	cmpa	#0,	r6	;
    a06a:	12 24       	jz	$+38     	;abs 0xa090

0000a06c <.Loc.76.1>:
    a06c:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    a070:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000a074 <.LVL7>:
    a074:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    a078:	80 00 62 a0 	mova	#41058,	r0	;0x0a062

0000a07c <.L3>:
    a07c:	d8 0e       	cmpa	r14,	r8	;
    a07e:	08 24       	jz	$+18     	;abs 0xa090

0000a080 <.LVL9>:
    a080:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    a084:	ae 00 01 00 	adda	#1,	r14	;

0000a088 <.LVL10>:
    a088:	aa 00 01 00 	adda	#1,	r10	;
    a08c:	80 00 7c a0 	mova	#41084,	r0	;0x0a07c

0000a090 <.L9>:
    a090:	06 16       	popm.a	#1,	r6	;20-bit words
    a092:	08 16       	popm.a	#1,	r8	;20-bit words
    a094:	0a 16       	popm.a	#1,	r10	;20-bit words
    a096:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000cadc <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    cadc:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cade <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    cade:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cae2:	4e 07 

0000cae4 <.LBB12>:
  chSysTimerHandlerI();
    cae4:	b0 13 6c 46 	calla	#18028		;0x0466c

0000cae8 <.LBE12>:
  OSAL_IRQ_EPILOGUE();
    cae8:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    caec:	4e 07 
    caee:	b0 13 be 47 	calla	#18366		;0x047be

0000caf2 <.LVL1>:
    caf2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    caf4:	02 24       	jz	$+6      	;abs 0xcafa

0000caf6 <.Loc.174.1>:
    caf6:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cafa <.L1>:
}
    cafa:	b4 16       	popm.a	#12,	r15	;20-bit words
    cafc:	00 13       	reti			

0000cafe <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    cafe:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cb00 <.LCFI0>:
    cb00:	b1 00 04 00 	suba	#4,	r1	;

0000cb04 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    cb04:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cb08:	4e 07 

0000cb0a <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    cb0a:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    cb0e:	0e 02 

0000cb10 <.LVL0>:
    cb10:	12 c3       	clrc			
    cb12:	0c 10       	rrc	r12		;

0000cb14 <.LVL1>:
    cb14:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cb16 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    cb16:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cb1a:	0d 43       	clr	r13		;
    cb1c:	0e 4c       	mov	r12,	r14	;
    cb1e:	0f 4d       	mov	r13,	r15	;
    cb20:	0e 5e       	rla	r14		;
    cb22:	0f 6f       	rlc	r15		;
    cb24:	0e 5e       	rla	r14		;
    cb26:	0f 6f       	rlc	r15		;
    cb28:	81 4e 00 00 	mov	r14,	0(r1)	;
    cb2c:	81 4f 02 00 	mov	r15,	2(r1)	;
    cb30:	0d 01       	mova	@r1,	r13	;
    cb32:	80 18 5c 4d 	movx.a	67408(r13),r12	;0x10750
    cb36:	50 07 

0000cb38 <.LVL2>:
  if (cb != NULL) {
    cb38:	9c 00 00 00 	cmpa	#0,	r12	;
    cb3c:	01 24       	jz	$+4      	;abs 0xcb40

0000cb3e <.Loc.81.1>:
    (*cb)();
    cb3e:	4c 13       	calla	r12		;

0000cb40 <.L2>:
  OSAL_IRQ_EPILOGUE();
    cb40:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cb44:	4e 07 
    cb46:	b0 13 be 47 	calla	#18366		;0x047be

0000cb4a <.LVL4>:
    cb4a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cb4c:	02 24       	jz	$+6      	;abs 0xcb52

0000cb4e <.Loc.84.1>:
    cb4e:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cb52 <.L1>:
}
    cb52:	a1 00 04 00 	adda	#4,	r1	;
    cb56:	b4 16       	popm.a	#12,	r15	;20-bit words
    cb58:	00 13       	reti			

0000cb5a <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    cb5a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cb5c <.LCFI2>:
    cb5c:	b1 00 04 00 	suba	#4,	r1	;

0000cb60 <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    cb60:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cb64:	4e 07 

0000cb66 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    cb66:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    cb6a:	1e 02 

0000cb6c <.LVL6>:
    cb6c:	12 c3       	clrc			
    cb6e:	0c 10       	rrc	r12		;

0000cb70 <.LVL7>:
    cb70:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cb72 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    cb72:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cb76:	4c 0e       	rlam.a	#4,	r12	;
    cb78:	4c 0d       	rram.a	#4,	r12	;
    cb7a:	ac 00 08 00 	adda	#8,	r12	;
    cb7e:	0c 14       	pushm.a	#1,	r12	;20-bit words
    cb80:	40 18 3c 41 	popx.w	r12		;
    cb84:	40 18 3d 41 	popx.w	r13		;
    cb88:	0e 4c       	mov	r12,	r14	;
    cb8a:	0f 4d       	mov	r13,	r15	;
    cb8c:	0e 5e       	rla	r14		;
    cb8e:	0f 6f       	rlc	r15		;
    cb90:	0e 5e       	rla	r14		;
    cb92:	0f 6f       	rlc	r15		;
    cb94:	81 4e 00 00 	mov	r14,	0(r1)	;
    cb98:	81 4f 02 00 	mov	r15,	2(r1)	;
    cb9c:	0d 01       	mova	@r1,	r13	;
    cb9e:	80 18 5c 4d 	movx.a	67408(r13),r12	;0x10750
    cba2:	50 07 

0000cba4 <.LVL8>:
  if (cb != NULL) {
    cba4:	9c 00 00 00 	cmpa	#0,	r12	;
    cba8:	01 24       	jz	$+4      	;abs 0xcbac

0000cbaa <.Loc.99.1>:
    (*cb)();
    cbaa:	4c 13       	calla	r12		;

0000cbac <.L11>:
  OSAL_IRQ_EPILOGUE();
    cbac:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cbb0:	4e 07 
    cbb2:	b0 13 be 47 	calla	#18366		;0x047be

0000cbb6 <.LVL10>:
    cbb6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cbb8:	02 24       	jz	$+6      	;abs 0xcbbe

0000cbba <.Loc.102.1>:
    cbba:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cbbe <.L10>:
}
    cbbe:	a1 00 04 00 	adda	#4,	r1	;
    cbc2:	b4 16       	popm.a	#12,	r15	;20-bit words
    cbc4:	00 13       	reti			

0000cbc6 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    cbc6:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cbc8 <.LCFI4>:
    cbc8:	b1 00 04 00 	suba	#4,	r1	;

0000cbcc <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    cbcc:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cbd0:	4e 07 

0000cbd2 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    cbd2:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    cbd6:	2e 02 

0000cbd8 <.LVL12>:
    cbd8:	12 c3       	clrc			
    cbda:	0c 10       	rrc	r12		;

0000cbdc <.LVL13>:
    cbdc:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cbde <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    cbde:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cbe2:	4c 0e       	rlam.a	#4,	r12	;
    cbe4:	4c 0d       	rram.a	#4,	r12	;
    cbe6:	ac 00 10 00 	adda	#16,	r12	;0x00010
    cbea:	0c 14       	pushm.a	#1,	r12	;20-bit words
    cbec:	40 18 3c 41 	popx.w	r12		;
    cbf0:	40 18 3d 41 	popx.w	r13		;
    cbf4:	0e 4c       	mov	r12,	r14	;
    cbf6:	0f 4d       	mov	r13,	r15	;
    cbf8:	0e 5e       	rla	r14		;
    cbfa:	0f 6f       	rlc	r15		;
    cbfc:	0e 5e       	rla	r14		;
    cbfe:	0f 6f       	rlc	r15		;
    cc00:	81 4e 00 00 	mov	r14,	0(r1)	;
    cc04:	81 4f 02 00 	mov	r15,	2(r1)	;
    cc08:	0d 01       	mova	@r1,	r13	;
    cc0a:	80 18 5c 4d 	movx.a	67408(r13),r12	;0x10750
    cc0e:	50 07 

0000cc10 <.LVL14>:
  if (cb != NULL) {
    cc10:	9c 00 00 00 	cmpa	#0,	r12	;
    cc14:	01 24       	jz	$+4      	;abs 0xcc18

0000cc16 <.Loc.118.1>:
    (*cb)();
    cc16:	4c 13       	calla	r12		;

0000cc18 <.L20>:
  OSAL_IRQ_EPILOGUE();
    cc18:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cc1c:	4e 07 
    cc1e:	b0 13 be 47 	calla	#18366		;0x047be

0000cc22 <.LVL16>:
    cc22:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cc24:	02 24       	jz	$+6      	;abs 0xcc2a

0000cc26 <.Loc.121.1>:
    cc26:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cc2a <.L19>:
}
    cc2a:	a1 00 04 00 	adda	#4,	r1	;
    cc2e:	b4 16       	popm.a	#12,	r15	;20-bit words
    cc30:	00 13       	reti			

0000cc32 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    cc32:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cc34 <.LCFI6>:
    cc34:	b1 00 04 00 	suba	#4,	r1	;

0000cc38 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    cc38:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cc3c:	4e 07 

0000cc3e <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    cc3e:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    cc42:	3e 02 

0000cc44 <.LVL18>:
    cc44:	12 c3       	clrc			
    cc46:	0c 10       	rrc	r12		;

0000cc48 <.LVL19>:
    cc48:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cc4a <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    cc4a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cc4e:	4c 0e       	rlam.a	#4,	r12	;
    cc50:	4c 0d       	rram.a	#4,	r12	;
    cc52:	ac 00 18 00 	adda	#24,	r12	;0x00018
    cc56:	0c 14       	pushm.a	#1,	r12	;20-bit words
    cc58:	40 18 3c 41 	popx.w	r12		;
    cc5c:	40 18 3d 41 	popx.w	r13		;
    cc60:	0e 4c       	mov	r12,	r14	;
    cc62:	0f 4d       	mov	r13,	r15	;
    cc64:	0e 5e       	rla	r14		;
    cc66:	0f 6f       	rlc	r15		;
    cc68:	0e 5e       	rla	r14		;
    cc6a:	0f 6f       	rlc	r15		;
    cc6c:	81 4e 00 00 	mov	r14,	0(r1)	;
    cc70:	81 4f 02 00 	mov	r15,	2(r1)	;
    cc74:	0d 01       	mova	@r1,	r13	;
    cc76:	80 18 5c 4d 	movx.a	67408(r13),r12	;0x10750
    cc7a:	50 07 

0000cc7c <.LVL20>:
  if (cb != NULL) {
    cc7c:	9c 00 00 00 	cmpa	#0,	r12	;
    cc80:	01 24       	jz	$+4      	;abs 0xcc84

0000cc82 <.Loc.136.1>:
    (*cb)();
    cc82:	4c 13       	calla	r12		;

0000cc84 <.L29>:
  OSAL_IRQ_EPILOGUE();
    cc84:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cc88:	4e 07 
    cc8a:	b0 13 be 47 	calla	#18366		;0x047be

0000cc8e <.LVL22>:
    cc8e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cc90:	02 24       	jz	$+6      	;abs 0xcc96

0000cc92 <.Loc.139.1>:
    cc92:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cc96 <.L28>:
}
    cc96:	a1 00 04 00 	adda	#4,	r1	;
    cc9a:	b4 16       	popm.a	#12,	r15	;20-bit words
    cc9c:	00 13       	reti			

0000cc9e <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    cc9e:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cca0 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    cca0:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cca4:	4e 07 

0000cca6 <.Loc.75.1>:
  index = (DMAIV >> 1) - 1;
    cca6:	40 18 18 42 	movx.w	&0x0050e,r8	;
    ccaa:	0e 05 
    ccac:	12 c3       	clrc			
    ccae:	08 10       	rrc	r8		;
    ccb0:	78 53       	add.b	#-1,	r8	;r3 As==11
    ccb2:	49 48       	mov.b	r8,	r9	;

0000ccb4 <.LVL6>:
  if (index < MSP430X_DMA_CHANNELS) {
    ccb4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    ccb6:	4c 98       	cmp.b	r8,	r12	;
    ccb8:	30 28       	jnc	$+98     	;abs 0xcd1a

0000ccba <.LBB14>:
    dma_regs[index].ctl &= ~DMAEN;
    ccba:	4c 48       	mov.b	r8,	r12	;
    ccbc:	0d 43       	clr	r13		;
    ccbe:	b0 13 16 9f 	calla	#40726		;0x09f16
    ccc2:	0d 12       	push	r13		;
    ccc4:	0c 12       	push	r12		;
    ccc6:	0a 16       	popm.a	#1,	r10	;20-bit words
    ccc8:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    cccc:	ba f0 ef ff 	and	#-17,	0(r10)	;#0xffef
    ccd0:	00 00 

0000ccd2 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    ccd2:	4d 43       	clr.b	r13		;
    ccd4:	4c 48       	mov.b	r8,	r12	;
    ccd6:	b0 13 20 51 	calla	#20768		;0x05120

0000ccda <.LVL8>:
    dma_regs[index].sz  = 0;
    ccda:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000ccde <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    ccde:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    cce2:	00 00 

0000cce4 <.Loc.87.1>:
    if (cb->callback != NULL) {
    cce4:	8a 00 34 c8 	mova	#51252,	r10	;0x0c834
    cce8:	08 49       	mov	r9,	r8	;
    ccea:	09 43       	clr	r9		;

0000ccec <.LVL10>:
    ccec:	0c 48       	mov	r8,	r12	;
    ccee:	0d 49       	mov	r9,	r13	;
    ccf0:	b0 13 1a 9f 	calla	#40730		;0x09f1a
    ccf4:	0d 12       	push	r13		;
    ccf6:	0c 12       	push	r12		;
    ccf8:	0c 16       	popm.a	#1,	r12	;20-bit words
    ccfa:	ec 0a       	adda	r10,	r12	;
    ccfc:	06 0c       	mova	@r12,	r6	;
    ccfe:	96 00 00 00 	cmpa	#0,	r6	;
    cd02:	0b 24       	jz	$+24     	;abs 0xcd1a

0000cd04 <.Loc.88.1>:
      cb->callback(cb->args);
    cd04:	0c 48       	mov	r8,	r12	;
    cd06:	0d 49       	mov	r9,	r13	;
    cd08:	b0 13 1a 9f 	calla	#40730		;0x09f1a
    cd0c:	0d 12       	push	r13		;
    cd0e:	0c 12       	push	r12		;
    cd10:	0c 16       	popm.a	#1,	r12	;20-bit words
    cd12:	ea 0c       	adda	r12,	r10	;
    cd14:	3c 0a 04 00 	mova	4(r10),	r12	;
    cd18:	46 13       	calla	r6		;

0000cd1a <.L4>:
  OSAL_IRQ_EPILOGUE();
    cd1a:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cd1e:	4e 07 
    cd20:	b0 13 be 47 	calla	#18366		;0x047be

0000cd24 <.LVL14>:
    cd24:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cd26:	02 24       	jz	$+6      	;abs 0xcd2c

0000cd28 <.Loc.92.1>:
    cd28:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cd2c <.L2>:
}
    cd2c:	b4 16       	popm.a	#12,	r15	;20-bit words
    cd2e:	00 13       	reti			

0000cd30 <ISR_USCI_B0_VECTOR>:
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    cd30:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cd32 <.LCFI23>:
  OSAL_IRQ_PROLOGUE();
    cd32:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cd36:	4e 07 

0000cd38 <.Loc.110.1>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    cd38:	40 18 1c 42 	movx.w	&0x0066e,r12	;
    cd3c:	6e 06 
    cd3e:	8a 01 d0 07 	mova	#67536,	r10	;0x107d0
    cd42:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    cd46:	74 24       	jz	$+234    	;abs 0xce30
    cd48:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    cd4c:	0d 9c       	cmp	r12,	r13	;
    cd4e:	60 28       	jnc	$+194    	;abs 0xce10
    cd50:	3c 90 06 00 	cmp	#6,	r12	;
    cd54:	6d 24       	jz	$+220    	;abs 0xce30
    cd56:	7d 40 06 00 	mov.b	#6,	r13	;
    cd5a:	0d 9c       	cmp	r12,	r13	;
    cd5c:	3e 28       	jnc	$+126    	;abs 0xcdda
    cd5e:	2c 93       	cmp	#2,	r12	;r3 As==10
    cd60:	8a 24       	jz	$+278    	;abs 0xce76
    cd62:	2c 92       	cmp	#4,	r12	;r2 As==10
    cd64:	8c 24       	jz	$+282    	;abs 0xce7e

0000cd66 <.L113>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    cd66:	41 18 82 93 	cmpx.w	#0,	&0x107d6;r3 As==00
    cd6a:	d6 07 
    cd6c:	2b 24       	jz	$+88     	;abs 0xcdc4

0000cd6e <.LBB69>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    cd6e:	17 4a 1c 00 	mov	28(r10),r7	;0x0001c
    cd72:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    cd76:	19 4c 0a 00 	mov	10(r12),r9	;0x0000a

0000cd7a <.LVL88>:
    dmaCancelI(&I2CDB0.dma);
    cd7a:	8c 01 04 08 	mova	#67588,	r12	;0x10804
    cd7e:	b0 13 ec 52 	calla	#21228		;0x052ec

0000cd82 <.LVL89>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    cd82:	40 18 fa b0 	bitx.b	#32,	6(r10)	;0x00020
    cd86:	20 00 06 00 
    cd8a:	04 24       	jz	$+10     	;abs 0xcd94

0000cd8c <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    cd8c:	41 18 f2 40 	movx.b	#5,	&0x107d0;
    cd90:	05 00 d0 07 

0000cd94 <.L131>:
    if (NULL != I2CDB0.callback) {
    cd94:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    cd98:	98 00 00 00 	cmpa	#0,	r8	;
    cd9c:	09 24       	jz	$+20     	;abs 0xcdb0

0000cd9e <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    cd9e:	40 18 0e 47 	movx.w	r7,	r14	;
    cda2:	40 18 0e 89 	subx.w	r9,	r14	;
    cda6:	3d 0a 08 00 	mova	8(r10),	r13	;
    cdaa:	8c 01 d0 07 	mova	#67536,	r12	;0x107d0
    cdae:	48 13       	calla	r8		;

0000cdb0 <.L132>:
    if (I2CDB0.thread != NULL) {
    cdb0:	01 18 c2 93 	cmpx.a	#0,	&0x107fe;r3 As==00
    cdb4:	fe 07 
    cdb6:	06 24       	jz	$+14     	;abs 0xcdc4

0000cdb8 <.LBB70>:
  chThdResumeI(trp, msg);
    cdb8:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    cdbc:	8c 01 fe 07 	mova	#67582,	r12	;0x107fe

0000cdc0 <.LVL92>:
    cdc0:	b0 13 5c 48 	calla	#18524		;0x0485c

0000cdc4 <.L130>:
  OSAL_IRQ_EPILOGUE();
    cdc4:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    cdc8:	4e 07 
    cdca:	b0 13 be 47 	calla	#18366		;0x047be

0000cdce <.LVL94>:
    cdce:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cdd0:	02 24       	jz	$+6      	;abs 0xcdd6

0000cdd2 <.Loc.211.1>:
    cdd2:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cdd6 <.L112>:
}
    cdd6:	b4 16       	popm.a	#12,	r15	;20-bit words
    cdd8:	00 13       	reti			

0000cdda <.L117>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    cdda:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    cdde:	28 24       	jz	$+82     	;abs 0xce30
    cde0:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    cde4:	25 24       	jz	$+76     	;abs 0xce30
    cde6:	3c 92       	cmp	#8,	r12	;r2 As==11
    cde8:	be 23       	jnz	$-130    	;abs 0xcd66

0000cdea <.Loc.126.1>:
      I2CDB0.state = I2C_READY;
    cdea:	41 18 e2 43 	movx.b	#2,	&0x107d0;r3 As==10
    cdee:	d0 07 

0000cdf0 <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    cdf0:	01 18 c2 93 	cmpx.a	#0,	&0x107fe;r3 As==00
    cdf4:	fe 07 
    cdf6:	06 24       	jz	$+14     	;abs 0xce04

0000cdf8 <.LBB72>:
    cdf8:	4d 43       	clr.b	r13		;
    cdfa:	cc 0a       	mova	r10,	r12	;
    cdfc:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    ce00:	b0 13 5c 48 	calla	#18524		;0x0485c

0000ce04 <.L126>:
        dmaReleaseX(&(I2CDB0.dma));
    ce04:	8c 01 04 08 	mova	#67588,	r12	;0x10804
    ce08:	b0 13 a6 52 	calla	#21158		;0x052a6

0000ce0c <.LVL98>:
      break;
    ce0c:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ce10 <.L115>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    ce10:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    ce14:	38 24       	jz	$+114    	;abs 0xce86
    ce16:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    ce1a:	0d 9c       	cmp	r12,	r13	;
    ce1c:	0f 28       	jnc	$+32     	;abs 0xce3c
    ce1e:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    ce22:	06 24       	jz	$+14     	;abs 0xce30
    ce24:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    ce28:	03 24       	jz	$+8      	;abs 0xce30
    ce2a:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    ce2e:	9b 23       	jnz	$-200    	;abs 0xcd66

0000ce30 <.L123>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    ce30:	8c 01 47 04 	mova	#66631,	r12	;0x10447
    ce34:	b0 13 5c 46 	calla	#18012		;0x0465c

0000ce38 <.LVL99>:
      break;
    ce38:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ce3c <.L122>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    ce3c:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    ce40:	f7 27       	jz	$-16     	;abs 0xce30
    ce42:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    ce46:	3c 24       	jz	$+122    	;abs 0xcec0
    ce48:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    ce4c:	8c 23       	jnz	$-230    	;abs 0xcd66

0000ce4e <.Loc.158.1>:
      UCB0IE &= ~(UCTXIE);
    ce4e:	40 18 a2 c3 	bicx.w	#2,	&0x0066a;r3 As==10
    ce52:	6a 06 

0000ce54 <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    ce54:	01 18 c2 93 	cmpx.a	#0,	&0x107fe;r3 As==00
    ce58:	fe 07 
    ce5a:	2a 20       	jnz	$+86     	;abs 0xceb0

0000ce5c <.Loc.162.1>:
        if (NULL != I2CDB0.callback) {
    ce5c:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    ce60:	98 00 00 00 	cmpa	#0,	r8	;
    ce64:	20 24       	jz	$+66     	;abs 0xcea6

0000ce66 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    ce66:	1e 4a 1c 00 	mov	28(r10),r14	;0x0001c
    ce6a:	3d 0a 08 00 	mova	8(r10),	r13	;
    ce6e:	cc 0a       	mova	r10,	r12	;
    ce70:	48 13       	calla	r8		;

0000ce72 <.LVL100>:
    ce72:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ce76 <.L118>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    ce76:	aa d3 06 00 	bis	#2,	6(r10)	;r3 As==10

0000ce7a <.Loc.116.1>:
      break;
    ce7a:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ce7e <.L119>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    ce7e:	aa d2 06 00 	bis	#4,	6(r10)	;r2 As==10

0000ce82 <.Loc.120.1>:
      break;
    ce82:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ce86 <.L121>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    ce86:	40 18 1d 42 	movx.w	&0x0064c,r13	;
    ce8a:	4c 06 
    ce8c:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    ce90:	1c 00 
    ce92:	00 18 5c 5a 	addx.a	24(r10),r12	;0x00018
    ce96:	18 00 
    ce98:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000ce9c <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    ce9c:	40 18 92 c3 	bicx.w	#1,	&0x0066a;r3 As==01
    cea0:	6a 06 

0000cea2 <.Loc.155.1>:
      break;
    cea2:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000cea6 <.L128>:
          i2cMSP430XEndTransferI(&I2CDB0);
    cea6:	cc 0a       	mova	r10,	r12	;
    cea8:	b0 13 fa 57 	calla	#22522		;0x057fa

0000ceac <.LVL101>:
    ceac:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ceb0 <.L127>:
    ceb0:	4d 43       	clr.b	r13		;
    ceb2:	cc 0a       	mova	r10,	r12	;
    ceb4:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    ceb8:	b0 13 5c 48 	calla	#18524		;0x0485c

0000cebc <.LVL103>:
    cebc:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000cec0 <.L124>:
      I2CDB0.errors |= I2C_TIMEOUT;
    cec0:	ba d0 20 00 	bis	#32,	6(r10)	;#0x0020
    cec4:	06 00 

0000cec6 <.Loc.185.1>:
      break;
    cec6:	80 00 66 cd 	mova	#52582,	r0	;0x0cd66

0000ceca <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    ceca:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cecc <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    cecc:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    ced0:	4e 07 

0000ced2 <.Loc.287.1>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    ced2:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    ced6:	fe 05 
    ced8:	2c 92       	cmp	#4,	r12	;r2 As==10
    ceda:	78 24       	jz	$+242    	;abs 0xcfcc
    cedc:	6d 42       	mov.b	#4,	r13	;r2 As==10
    cede:	0d 9c       	cmp	r12,	r13	;
    cee0:	0d 28       	jnc	$+28     	;abs 0xcefc
    cee2:	2c 93       	cmp	#2,	r12	;r3 As==10
    cee4:	2b 24       	jz	$+88     	;abs 0xcf3c

0000cee6 <.L59>:
  OSAL_IRQ_EPILOGUE();
    cee6:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    ceea:	4e 07 
    ceec:	b0 13 be 47 	calla	#18366		;0x047be

0000cef0 <.LVL90>:
    cef0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cef2:	02 24       	jz	$+6      	;abs 0xcef8

0000cef4 <.Loc.331.1>:
    cef4:	b0 13 ce 47 	calla	#18382		;0x047ce

0000cef8 <.L58>:
}
    cef8:	b4 16       	popm.a	#12,	r15	;20-bit words
    cefa:	00 13       	reti			

0000cefc <.L61>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    cefc:	3c 90 06 00 	cmp	#6,	r12	;
    cf00:	65 24       	jz	$+204    	;abs 0xcfcc
    cf02:	3c 92       	cmp	#8,	r12	;r2 As==11
    cf04:	f0 23       	jnz	$-30     	;abs 0xcee6

0000cf06 <.Loc.323.1>:
      _uart_tx2_isr_code(&UARTDA1);
    cf06:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    cf0a:	3e 0c 04 00 	mova	4(r12),	r14	;
    cf0e:	3e 0e 04 00 	mova	4(r14),	r14	;
    cf12:	9e 00 00 00 	cmpa	#0,	r14	;
    cf16:	01 24       	jz	$+4      	;abs 0xcf1a

0000cf18 <.Loc.323.1>:
    cf18:	4e 13       	calla	r14		;

0000cf1a <.L71>:
    cf1a:	41 18 c2 93 	cmpx.b	#0,	&0x10816;r3 As==00
    cf1e:	16 08 
    cf20:	05 20       	jnz	$+12     	;abs 0xcf2c

0000cf22 <.LBB71>:
    cf22:	4d 43       	clr.b	r13		;
    cf24:	8c 01 1c 08 	mova	#67612,	r12	;0x1081c

0000cf28 <.LVL94>:
    cf28:	b0 13 5c 48 	calla	#18524		;0x0485c

0000cf2c <.L72>:
      UCA1IE &= ~UCTXCPTIE;
    cf2c:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    cf30:	fa 05 

0000cf32 <.Loc.327.1>:
      UCA1IFG &= ~UCTXCPTIFG;
    cf32:	40 18 b2 c2 	bicx.w	#8,	&0x005fc;r2 As==11
    cf36:	fc 05 

0000cf38 <.Loc.328.1>:
      break;
    cf38:	80 00 e6 ce 	mova	#52966,	r0	;0x0cee6

0000cf3c <.L62>:
    cf3c:	8a 01 0e 08 	mova	#67598,	r10	;0x1080e

0000cf40 <.Loc.292.1>:
      if (UCA1STATW & UCRXERR) {
    cf40:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    cf44:	ea 05 
    cf46:	2a 24       	jz	$+86     	;abs 0xcf9c

0000cf48 <.LBB73>:
        if (UCA1STATW & UCBRK)
    cf48:	40 18 f2 b2 	bitx.b	#8,	&0x005ea;r2 As==11
    cf4c:	ea 05 
    cf4e:	35 24       	jz	$+108    	;abs 0xcfba

0000cf50 <.Loc.297.1>:
          sts |= UART_BREAK_DETECTED;
    cf50:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    cf54:	4e 43       	clr.b	r14		;

0000cf56 <.L65>:
        if (UCA1STATW & UCOE)
    cf56:	40 18 f2 b0 	bitx.b	#32,	&0x005ea;0x00020
    cf5a:	20 00 ea 05 
    cf5e:	02 24       	jz	$+6      	;abs 0xcf64

0000cf60 <.Loc.299.1>:
          sts |= UART_OVERRUN_ERROR;
    cf60:	3d d0 10 00 	bis	#16,	r13	;#0x0010

0000cf64 <.L66>:
        if (UCA1STATW & UCFE)
    cf64:	40 18 f2 b0 	bitx.b	#64,	&0x005ea;0x00040
    cf68:	40 00 ea 05 
    cf6c:	01 24       	jz	$+4      	;abs 0xcf70

0000cf6e <.Loc.301.1>:
          sts |= UART_FRAMING_ERROR;
    cf6e:	3d d2       	bis	#8,	r13	;r2 As==11

0000cf70 <.L67>:
        if (UCA1STATW & UCPE)
    cf70:	40 18 f2 b0 	bitx.b	#16,	&0x005ea;0x00010
    cf74:	10 00 ea 05 
    cf78:	01 24       	jz	$+4      	;abs 0xcf7c

0000cf7a <.Loc.303.1>:
          sts |= UART_PARITY_ERROR;
    cf7a:	2d d2       	bis	#4,	r13	;r2 As==10

0000cf7c <.L68>:
        _uart_rx_error_isr_code(&UARTDA1, sts);
    cf7c:	3c 0a 04 00 	mova	4(r10),	r12	;
    cf80:	38 0c 10 00 	mova	16(r12),r8	;0x00010
    cf84:	98 00 00 00 	cmpa	#0,	r8	;
    cf88:	03 24       	jz	$+8      	;abs 0xcf90

0000cf8a <.Loc.305.1>:
    cf8a:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    cf8e:	48 13       	calla	r8		;

0000cf90 <.L69>:
    cf90:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    cf94:	8c 01 18 08 	mova	#67608,	r12	;0x10818

0000cf98 <.LVL102>:
    cf98:	b0 13 5c 48 	calla	#18524		;0x0485c

0000cf9c <.L64>:
      if (UARTDA1.config->rxchar_cb != NULL) {
    cf9c:	3c 0a 04 00 	mova	4(r10),	r12	;
    cfa0:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    cfa4:	9e 00 00 00 	cmpa	#0,	r14	;
    cfa8:	0c 24       	jz	$+26     	;abs 0xcfc2

0000cfaa <.Loc.310.1>:
        UARTDA1.config->rxchar_cb(&UARTDA1, UCA1RXBUF);
    cfaa:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    cfae:	ec 05 
    cfb0:	8c 01 0e 08 	mova	#67598,	r12	;0x1080e
    cfb4:	4e 13       	calla	r14		;

0000cfb6 <.LVL104>:
    cfb6:	80 00 e6 ce 	mova	#52966,	r0	;0x0cee6

0000cfba <.L74>:
        uartflags_t sts = 0;
    cfba:	4d 43       	clr.b	r13		;
    cfbc:	0e 4d       	mov	r13,	r14	;
    cfbe:	80 00 56 cf 	mova	#53078,	r0	;0x0cf56

0000cfc2 <.L70>:
        UCA1IFG &= ~UCRXIFG;
    cfc2:	40 18 92 c3 	bicx.w	#1,	&0x005fc;r3 As==01
    cfc6:	fc 05 
    cfc8:	80 00 e6 ce 	mova	#52966,	r0	;0x0cee6

0000cfcc <.L60>:
      osalDbgAssert(false, "Spurious interrupt in USCI A1 UART");
    cfcc:	8c 01 69 04 	mova	#66665,	r12	;0x10469
    cfd0:	b0 13 5c 46 	calla	#18012		;0x0465c

0000cfd4 <.LVL107>:
      break;
    cfd4:	80 00 e6 ce 	mova	#52966,	r0	;0x0cee6

0000cfd8 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    cfd8:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cfda <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    cfda:	41 18 d2 43 	movx.b	#1,	&0x1074e;r3 As==01
    cfde:	4e 07 

0000cfe0 <.Loc.119.1>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    cfe0:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    cfe4:	ae 03 
    cfe6:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    cfea:	1b 20       	jnz	$+56     	;abs 0xd022

0000cfec <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    cfec:	8c 01 72 08 	mova	#67698,	r12	;0x10872
    cff0:	6d 4c       	mov.b	@r12,	r13	;
    cff2:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    cff6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cff8:	4e 9d       	cmp.b	r13,	r14	;
    cffa:	08 28       	jnc	$+18     	;abs 0xd00c

0000cffc <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    cffc:	3e 0c 02 00 	mova	2(r12),	r14	;
    d000:	3e 0e 04 00 	mova	4(r14),	r14	;

0000d004 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    d004:	9e 00 00 00 	cmpa	#0,	r14	;
    d008:	01 24       	jz	$+4      	;abs 0xd00c

0000d00a <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    d00a:	4e 13       	calla	r14		;

0000d00c <.L22>:
      if (GPTDA1.state == GPT_ONESHOT) {
    d00c:	41 18 e2 92 	cmpx.b	#4,	&0x10872;r2 As==10
    d010:	72 08 
    d012:	07 20       	jnz	$+16     	;abs 0xd022

0000d014 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    d014:	41 18 e2 43 	movx.b	#2,	&0x10872;r3 As==10
    d018:	72 08 

0000d01a <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    d01a:	8c 01 72 08 	mova	#67698,	r12	;0x10872
    d01e:	b0 13 fe 5f 	calla	#24574		;0x05ffe

0000d022 <.L20>:
  OSAL_IRQ_EPILOGUE();
    d022:	41 18 c2 43 	movx.b	#0,	&0x1074e;r3 As==00
    d026:	4e 07 
    d028:	b0 13 be 47 	calla	#18366		;0x047be

0000d02c <.LVL23>:
    d02c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d02e:	02 24       	jz	$+6      	;abs 0xd034

0000d030 <.Loc.135.1>:
    d030:	b0 13 ce 47 	calla	#18382		;0x047ce

0000d034 <.L19>:
}
    d034:	b4 16       	popm.a	#12,	r15	;20-bit words
    d036:	00 13       	reti			
