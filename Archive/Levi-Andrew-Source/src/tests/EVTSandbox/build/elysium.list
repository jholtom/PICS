
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	9a a8       	dadd			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	9c a8       	dadd			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	9e a8       	dadd			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	a0 a8 00 00 	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	a2 a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	a4 a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	a6 a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	a8 a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	aa a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	ac a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	ae a8       	dadd	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	b0 a8 00 00 	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	b2 a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	b4 a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	b6 a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	b8 a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	ba a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	bc a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	be a8       	dadd	@r8+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	c0 a8 00 00 	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	c2 a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	c4 a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	c6 a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c8 a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	ca a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	cc a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	ce a8       	dadd.b	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 a8 00 00 	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d2 a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d4 a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	d6 a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	d8 a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	98 4e       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	5e 4e       	mov.b,		r14	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	da a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	dc a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	26 4e       	mov	@r14,	r6	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	de a8       	dadd.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	e0 a8 00 00 	dadd.b	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	f0 4d 00 00 	mov.b	@r13+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	a8 5f       	interrupt service routine at 0x5fa8

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	e2 a8       	interrupt service routine at 0xa8e2

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	66 4f       	interrupt service routine at 0x4f66

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	e4 a8       	interrupt service routine at 0xa8e4

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	e6 a8       	interrupt service routine at 0xa8e6

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	e8 a8       	interrupt service routine at 0xa8e8

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	40 56       	interrupt service routine at 0x5640

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	26 5b       	interrupt service routine at 0x5b26

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	ea a8       	interrupt service routine at 0xa8ea

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	ec a8       	interrupt service routine at 0xa8ec

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	b8 4d       	interrupt service routine at 0x4db8

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	ee a8       	interrupt service routine at 0xa8ee

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	f0 a8       	interrupt service routine at 0xa8f0

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	f2 a8       	interrupt service routine at 0xa8f2

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	31 40 52 ae 	mov	#-20910,r1	;#0xae52

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    4408:	5c 01 

0000440a <__crt0_init_bss>:
    440a:	3c 40 8a b4 	mov	#-19318,r12	;#0xb48a

0000440e <.Loc.74.1>:
    440e:	0d 43       	clr	r13		;

00004410 <.Loc.75.1>:
    4410:	3e 40 b2 2b 	mov	#11186,	r14	;#0x2bb2

00004414 <.Loc.79.1>:
    4414:	b0 12 c0 ad 	call	#-21056	;#0xadc0

00004418 <__crt0_movedata>:
    4418:	3c 40 fa b2 	mov	#-19718,r12	;#0xb2fa

0000441c <.Loc.116.1>:
    441c:	3d 40 fa b2 	mov	#-19718,r13	;#0xb2fa

00004420 <.Loc.119.1>:
    4420:	0d 9c       	cmp	r12,	r13	;

00004422 <.Loc.120.1>:
    4422:	04 24       	jz	$+10     	;abs 0x442c

00004424 <.Loc.122.1>:
    4424:	3e 40 90 01 	mov	#400,	r14	;#0x0190

00004428 <.Loc.124.1>:
    4428:	b0 12 86 ad 	call	#-21114	;#0xad86

0000442c <__crt0_call_just_main>:
    442c:	0c 43       	clr	r12		;

0000442e <.Loc.181.1>:
    442e:	b0 12 8c ab 	call	#-21620	;#0xab8c

00004432 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    4432:	0a 15       	pushm	#1,	r10	;16-bit words

00004434 <.LCFI0>:
  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
    4434:	3c 40 84 b2 	mov	#-19836,r12	;#0xb284

00004438 <.Loc.233.1>:
  tp = &nil.threads[0];
    4438:	3a 40 92 b4 	mov	#-19310,r10	;#0xb492

0000443c <.LVL1>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    443c:	17 3c       	jmp	$+48     	;abs 0x446c

0000443e <.L3>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    443e:	aa 4c 0e 00 	mov	@r12,	14(r10)	; 0x000e

00004442 <.Loc.241.1>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4442:	1d 4c 02 00 	mov	2(r12),	r13	;
    4446:	3d 50 f0 ff 	add	#-16,	r13	;#0xfff0
    444a:	8a 4d 00 00 	mov	r13,	0(r10)	;
    444e:	9d 4c 06 00 	mov	6(r12),	0(r13)	;
    4452:	00 00 
    4454:	2d 4a       	mov	@r10,	r13	;
    4456:	9d 4c 08 00 	mov	8(r12),	2(r13)	;
    445a:	02 00 
    445c:	2d 4a       	mov	@r10,	r13	;
    445e:	bd 40 80 4a 	mov	#19072,	14(r13)	;#0x4a80, 0x000e
    4462:	0e 00 

00004464 <.Loc.246.1>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    4464:	3a 50 10 00 	add	#16,	r10	;#0x0010

00004468 <.Loc.247.1>:
    tcp++;
    4468:	3c 50 0a 00 	add	#10,	r12	;#0x000a

0000446c <.L2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    446c:	3a 90 d2 b4 	cmp	#-19246,r10	;#0xb4d2
    4470:	e6 2b       	jnc	$-50     	;abs 0x443e

00004472 <.Loc.253.1>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    4472:	ba 40 52 ae 	mov	#-20910,14(r10)	;#0xae52, 0x000e
    4476:	0e 00 

00004478 <.LBB79>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    4478:	32 c2       	dint			

0000447a <.Loc.390.2>:
  asm volatile("nop");
    447a:	03 43       	nop			

0000447c <.LBE79>:
  nil.lock_cnt = (cnt_t)1;
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    447c:	b0 12 32 49 	call	#18738		;#0x4932

00004480 <.LBB81>:
  __msp430x_in_isr = false;
    4480:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00

00004484 <.LBE81>:
     initializations performed before.*/
  port_init();

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4484:	3c 40 8a b4 	mov	#-19318,r12	;#0xb48a
    4488:	0d 4c       	mov	r12,	r13	;
    448a:	3d 52       	add	#8,	r13	;r2 As==11
    448c:	8c 4d 02 00 	mov	r13,	2(r12)	;
    4490:	8c 4d 00 00 	mov	r13,	0(r12)	;

00004494 <.Loc.275.1>:
  port_switch(nil.current, tp);
    4494:	0d 4a       	mov	r10,	r13	;
    4496:	2c 4c       	mov	@r12,	r12	;
    4498:	b0 12 74 4a 	call	#19060		;#0x4a74

0000449c <.LBB83>:
  asm volatile("nop");
    449c:	03 43       	nop			

0000449e <.Loc.356.2>:
  _enable_interrupts();
    449e:	32 d2       	eint			
    44a0:	03 43       	nop			

000044a2 <.LBE83>:
  chSysUnlock();
}
    44a2:	0a 17       	popm	#1,	r10	;16-bit words
    44a4:	30 41       	ret			

000044a6 <chSysHalt>:
  _disable_interrupts();
    44a6:	32 c2       	dint			

000044a8 <L0>:
  asm volatile("nop");
    44a8:	03 43       	nop			

000044aa <.LBE85>:
void chSysHalt(const char *reason) {

  port_disable();

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    44aa:	82 4c 90 b4 	mov	r12,	&0xb490	;

000044ae <.L5>:
    44ae:	ff 3f       	jmp	$+0      	;abs 0x44ae

000044b0 <chSysGetStatusAndLockX>:
    44b0:	0c 42       	mov	r2,	r12	;

000044b2 <L0>:
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    44b2:	3c b2       	bit	#8,	r12	;r2 As==11
    44b4:	05 24       	jz	$+12     	;abs 0x44c0

000044b6 <.Loc.450.1>:
    if (port_is_isr_context()) {
    44b6:	c2 93 ee b4 	cmp.b	#0,	&0xb4ee	;r3 As==00
    44ba:	02 20       	jnz	$+6      	;abs 0x44c0

000044bc <.LBB97>:
  _disable_interrupts();
    44bc:	32 c2       	dint			

000044be <.Loc.348.2>:
  asm volatile("nop");
    44be:	03 43       	nop			

000044c0 <.L11>:
    else {
      chSysLock();
    }
  }
  return sts;
}
    44c0:	30 41       	ret			

000044c2 <chSchReadyI>:
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    44c2:	3c 90 92 b4 	cmp	#-19310,r12	;#0xb492
    44c6:	1a 28       	jnc	$+54     	;abs 0x44fc

000044c8 <.Loc.537.1>:
    44c8:	3c 90 d2 b4 	cmp	#-19246,r12	;#0xb4d2
    44cc:	17 2c       	jc	$+48     	;abs 0x44fc

000044ce <.Loc.538.1>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    44ce:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    44d2:	18 24       	jz	$+50     	;abs 0x4504

000044d4 <.Loc.539.1>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    44d4:	3e 40 8a b4 	mov	#-19318,r14	;#0xb48a
    44d8:	9e 9e 02 00 	cmp	2(r14),	0(r14)	;
    44dc:	00 00 
    44de:	16 28       	jnc	$+46     	;abs 0x450c

000044e0 <.Loc.541.1>:

  tp->u1.msg = msg;
    44e0:	8c 4d 04 00 	mov	r13,	4(r12)	;

000044e4 <.Loc.542.1>:
  tp->state = NIL_STATE_READY;
    44e4:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000044e8 <.Loc.543.1>:
  tp->timeout = (systime_t)0;
    44e8:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

000044ec <.Loc.544.1>:
  if (tp < nil.next) {
    44ec:	3d 40 8a b4 	mov	#-19318,r13	;#0xb48a

000044f0 <.LVL9>:
    44f0:	1c 9d 02 00 	cmp	2(r13),	r12	;
    44f4:	02 2c       	jc	$+6      	;abs 0x44fa

000044f6 <.Loc.545.1>:
    nil.next = tp;
    44f6:	82 4c 8c b4 	mov	r12,	&0xb48c	;

000044fa <.L17>:
  }
  return tp;
}
    44fa:	30 41       	ret			

000044fc <.L13>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    44fc:	3c 40 a0 ae 	mov	#-20832,r12	;#0xaea0

00004500 <.LVL11>:
    4500:	b0 12 a6 44 	call	#17574		;#0x44a6

00004504 <.L18>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    4504:	3c 40 a0 ae 	mov	#-20832,r12	;#0xaea0

00004508 <.LVL13>:
    4508:	b0 12 a6 44 	call	#17574		;#0x44a6

0000450c <.L19>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    450c:	3c 40 a0 ae 	mov	#-20832,r12	;#0xaea0

00004510 <.LVL15>:
    4510:	b0 12 a6 44 	call	#17574		;#0x44a6

00004514 <chSysTimerHandlerI>:
void chSysTimerHandlerI(void) {
    4514:	0a 15       	pushm	#1,	r10	;16-bit words

00004516 <.LCFI1>:
  nil.systime++;
    4516:	3a 40 8a b4 	mov	#-19318,r10	;#0xb48a
    451a:	9a 53 04 00 	inc	4(r10)		;

0000451e <.Loc.321.1>:
  thread_t *tp = &nil.threads[0];
    451e:	3a 52       	add	#8,	r10	;r2 As==11
    4520:	11 3c       	jmp	$+36     	;abs 0x4544

00004522 <.L27>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    4522:	3c 40 ac ae 	mov	#-20820,r12	;#0xaeac
    4526:	b0 12 a6 44 	call	#17574		;#0x44a6

0000452a <.L28>:
          tp->u1.semp->cnt++;
    452a:	1c 4a 04 00 	mov	4(r10),	r12	;
    452e:	9c 53 00 00 	inc	0(r12)		;

00004532 <.L24>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4532:	3d 43       	mov	#-1,	r13	;r3 As==11
    4534:	0c 4a       	mov	r10,	r12	;
    4536:	b0 12 c2 44 	call	#17602		;#0x44c2

0000453a <.L21>:
    tp++;
    453a:	3a 50 10 00 	add	#16,	r10	;#0x0010

0000453e <.Loc.349.1>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    453e:	3a 90 d2 b4 	cmp	#-19246,r10	;#0xb4d2
    4542:	19 2c       	jc	$+52     	;abs 0x4576

00004544 <.L25>:
    if (tp->timeout > (systime_t)0) {
    4544:	1c 4a 08 00 	mov	8(r10),	r12	;
    4548:	0c 93       	cmp	#0,	r12	;r3 As==00
    454a:	f7 27       	jz	$-16     	;abs 0x453a

0000454c <.Loc.327.1>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    454c:	5d 4a 02 00 	mov.b	2(r10),	r13	;
    4550:	0d 93       	cmp	#0,	r13	;r3 As==00
    4552:	e7 27       	jz	$-48     	;abs 0x4522

00004554 <.Loc.330.1>:
      if (--tp->timeout == (systime_t)0) {
    4554:	1c 4a 08 00 	mov	8(r10),	r12	;
    4558:	3c 53       	add	#-1,	r12	;r3 As==11
    455a:	8a 4c 08 00 	mov	r12,	8(r10)	;
    455e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4560:	ec 23       	jnz	$-38     	;abs 0x453a

00004562 <.Loc.334.1>:
        if (NIL_THD_IS_WTSEM(tp)) {
    4562:	3d 90 03 00 	cmp	#3,	r13	;
    4566:	e1 27       	jz	$-60     	;abs 0x452a

00004568 <.Loc.337.1>:
        else if (NIL_THD_IS_SUSP(tp)) {
    4568:	2d 93       	cmp	#2,	r13	;r3 As==10
    456a:	e3 23       	jnz	$-56     	;abs 0x4532

0000456c <.Loc.338.1>:
          *tp->u1.trp = NULL;
    456c:	1c 4a 04 00 	mov	4(r10),	r12	;
    4570:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    4574:	de 3f       	jmp	$-66     	;abs 0x4532

00004576 <.L26>:
}
    4576:	0a 17       	popm	#1,	r10	;16-bit words
    4578:	30 41       	ret			

0000457a <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    457a:	3c 40 8a b4 	mov	#-19318,r12	;#0xb48a

0000457e <L0>:
    457e:	2d 4c       	mov	@r12,	r13	;
    4580:	1d ec 02 00 	xor	2(r12),	r13	;
    4584:	0c 43       	clr	r12		;
    4586:	0c 8d       	sub	r13,	r12	;
    4588:	0c dd       	bis	r13,	r12	;

0000458a <.Loc.566.1>:
}
    458a:	5c 03       	rrum	#1,	r12	;
    458c:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    4590:	30 41       	ret			

00004592 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    4592:	3e 40 8a b4 	mov	#-19318,r14	;#0xb48a
    4596:	2d 4e       	mov	@r14,	r13	;

00004598 <.LVL23>:

  nil.current = nil.next;
    4598:	1c 4e 02 00 	mov	2(r14),	r12	;
    459c:	8e 4c 00 00 	mov	r12,	0(r14)	;

000045a0 <.Loc.582.1>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    45a0:	b0 12 74 4a 	call	#19060		;#0x4a74

000045a4 <.LVL24>:
}
    45a4:	30 41       	ret			

000045a6 <chSchRescheduleS>:
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    45a6:	3c 40 8a b4 	mov	#-19318,r12	;#0xb48a
    45aa:	9c 9c 02 00 	cmp	2(r12),	0(r12)	;
    45ae:	00 00 
    45b0:	02 24       	jz	$+6      	;abs 0x45b6

000045b2 <.Loc.595.1>:
    chSchDoReschedule();
    45b2:	b0 12 92 45 	call	#17810		;#0x4592

000045b6 <.L31>:
  }
}
    45b6:	30 41       	ret			

000045b8 <chSysRestoreStatusX>:
  if (port_irq_enabled(sts)) {
    45b8:	3c b2       	bit	#8,	r12	;r2 As==11
    45ba:	03 24       	jz	$+8      	;abs 0x45c2

000045bc <.Loc.472.1>:
    if (port_is_isr_context()) {
    45bc:	c2 93 ee b4 	cmp.b	#0,	&0xb4ee	;r3 As==00
    45c0:	01 24       	jz	$+4      	;abs 0x45c4

000045c2 <.L33>:
}
    45c2:	30 41       	ret			

000045c4 <.L35>:
      chSchRescheduleS();
    45c4:	b0 12 a6 45 	call	#17830		;#0x45a6

000045c8 <.LBB99>:
  asm volatile("nop");
    45c8:	03 43       	nop			

000045ca <.Loc.356.2>:
  _enable_interrupts();
    45ca:	32 d2       	eint			
    45cc:	03 43       	nop			

000045ce <.LBE99>:
}
    45ce:	f9 3f       	jmp	$-12     	;abs 0x45c2

000045d0 <chSchGoSleepTimeoutS>:
    45d0:	0a 15       	pushm	#1,	r10	;16-bit words

000045d2 <L0>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    45d2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000045d6 <.Loc.617.1>:
  thread_t *ntp, *otp = nil.current;
    45d6:	1e 42 8a b4 	mov	&0xb48a,r14	;0xb48a

000045da <.LVL31>:

  chDbgCheckClassS();

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    45da:	3e 90 d2 b4 	cmp	#-19246,r14	;#0xb4d2
    45de:	13 24       	jz	$+40     	;abs 0x4606

000045e0 <.Loc.625.1>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    45e0:	ce 4c 02 00 	mov.b	r12,	2(r14)	;

000045e4 <.Loc.660.1>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    45e4:	8e 4d 08 00 	mov	r13,	8(r14)	;

000045e8 <.Loc.664.1>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    45e8:	3c 40 92 b4 	mov	#-19310,r12	;#0xb492

000045ec <.L39>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    45ec:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    45f0:	0e 24       	jz	$+30     	;abs 0x460e

000045f2 <.Loc.677.1>:
      port_switch(ntp, otp);
      return nil.current->u1.msg;
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    45f2:	3c 50 10 00 	add	#16,	r12	;#0x0010

000045f6 <.Loc.678.1>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    45f6:	3d 40 d2 b4 	mov	#-19246,r13	;#0xb4d2
    45fa:	0d 9c       	cmp	r12,	r13	;
    45fc:	f7 2f       	jc	$-16     	;abs 0x45ec

000045fe <.Loc.678.1>:
    45fe:	3c 40 8b ae 	mov	#-20853,r12	;#0xae8b

00004602 <.LVL35>:
    4602:	b0 12 a6 44 	call	#17574		;#0x44a6

00004606 <.L41>:
  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    4606:	3c 40 8b ae 	mov	#-20853,r12	;#0xae8b
    460a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000460e <.L42>:
      nil.current = nil.next = ntp;
    460e:	3a 40 8a b4 	mov	#-19318,r10	;#0xb48a
    4612:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4616:	8a 4c 00 00 	mov	r12,	0(r10)	;

0000461a <.Loc.672.1>:
      port_switch(ntp, otp);
    461a:	0d 4e       	mov	r14,	r13	;
    461c:	b0 12 74 4a 	call	#19060		;#0x4a74

00004620 <.LVL38>:
      return nil.current->u1.msg;
    4620:	2c 4a       	mov	@r10,	r12	;
    4622:	1c 4c 04 00 	mov	4(r12),	r12	;

00004626 <.Loc.681.1>:
                "pointer out of range");
  }
}
    4626:	0a 17       	popm	#1,	r10	;16-bit words
    4628:	30 41       	ret			

0000462a <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    462a:	2e 4c       	mov	@r12,	r14	;
    462c:	0e 93       	cmp	#0,	r14	;r3 As==00
    462e:	08 24       	jz	$+18     	;abs 0x4640

00004630 <.LBB101>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4630:	ee 93 02 00 	cmp.b	#2,	2(r14)	;r3 As==10
    4634:	06 20       	jnz	$+14     	;abs 0x4642

00004636 <.Loc.723.1>:

    *trp = NULL;
    4636:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

0000463a <.Loc.724.1>:
    (void) chSchReadyI(tr, msg);
    463a:	0c 4e       	mov	r14,	r12	;

0000463c <.LVL47>:
    463c:	b0 12 c2 44 	call	#17602		;#0x44c2

00004640 <.L46>:
  }
}
    4640:	30 41       	ret			

00004642 <.L49>:
    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4642:	3c 40 7e ae 	mov	#-20866,r12	;#0xae7e

00004646 <.LVL50>:
    4646:	b0 12 a6 44 	call	#17574		;#0x44a6

0000464a <chThdSleep>:
  _disable_interrupts();
    464a:	32 c2       	dint			

0000464c <.Loc.348.2>:
  asm volatile("nop");
    464c:	03 43       	nop			

0000464e <.LBE103>:
 * @api
 */
void chThdSleep(systime_t timeout) {

  chSysLock();
  chThdSleepS(timeout);
    464e:	0d 4c       	mov	r12,	r13	;
    4650:	5c 43       	mov.b	#1,	r12	;r3 As==01

00004652 <.LVL53>:
    4652:	b0 12 d0 45 	call	#17872		;#0x45d0

00004656 <.LBB105>:
  asm volatile("nop");
    4656:	03 43       	nop			

00004658 <.Loc.356.2>:
  _enable_interrupts();
    4658:	32 d2       	eint			
    465a:	03 43       	nop			

0000465c <.LBE105>:
  chSysUnlock();
}
    465c:	30 41       	ret			

0000465e <chSemWaitTimeoutS>:
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {

  chDbgCheckClassS();
  chDbgCheck(sp != NULL);
    465e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4660:	09 24       	jz	$+20     	;abs 0x4674

00004662 <.Loc.813.1>:

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    4662:	2e 4c       	mov	@r12,	r14	;

00004664 <.LVL59>:
  if (cnt <= (cnt_t)0) {
    4664:	4f 43       	clr.b	r15		;
    4666:	0f 9e       	cmp	r14,	r15	;
    4668:	09 34       	jge	$+20     	;abs 0x467c

0000466a <.Loc.822.1>:
    }
    sp->cnt = cnt - (cnt_t)1;
    nil.current->u1.semp = sp;
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
  }
  sp->cnt = cnt - (cnt_t)1;
    466a:	3e 53       	add	#-1,	r14	;r3 As==11

0000466c <.LVL60>:
    466c:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004670 <.Loc.823.1>:
  return MSG_OK;
    4670:	4c 43       	clr.b	r12		;

00004672 <.L52>:
}
    4672:	30 41       	ret			

00004674 <.L57>:
  chDbgCheck(sp != NULL);
    4674:	3c 40 6c ae 	mov	#-20884,r12	;#0xae6c

00004678 <.LVL63>:
    4678:	b0 12 a6 44 	call	#17574		;#0x44a6

0000467c <.L58>:
    if (TIME_IMMEDIATE == timeout) {
    467c:	3d 93       	cmp	#-1,	r13	;r3 As==11
    467e:	0c 24       	jz	$+26     	;abs 0x4698

00004680 <.Loc.818.1>:
    sp->cnt = cnt - (cnt_t)1;
    4680:	3e 53       	add	#-1,	r14	;r3 As==11

00004682 <.LVL65>:
    4682:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004686 <.Loc.819.1>:
    nil.current->u1.semp = sp;
    4686:	1e 42 8a b4 	mov	&0xb48a,r14	;0xb48a

0000468a <.LVL66>:
    468a:	8e 4c 04 00 	mov	r12,	4(r14)	;

0000468e <.LVL67>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    468e:	7c 40 03 00 	mov.b	#3,	r12	;

00004692 <.LVL68>:
    4692:	b0 12 d0 45 	call	#17872		;#0x45d0

00004696 <.LVL69>:
    4696:	ed 3f       	jmp	$-36     	;abs 0x4672

00004698 <.L56>:
      return MSG_TIMEOUT;
    4698:	3c 43       	mov	#-1,	r12	;r3 As==11

0000469a <.LVL71>:
    469a:	eb 3f       	jmp	$-40     	;abs 0x4672

0000469c <chSemWaitTimeout>:
    469c:	32 c2       	dint			

0000469e <.Loc.348.2>:
  asm volatile("nop");
    469e:	03 43       	nop			

000046a0 <L0>:
  msg = chSemWaitTimeoutS(sp, timeout);
    46a0:	b0 12 5e 46 	call	#18014		;#0x465e

000046a4 <.LBB113>:
  asm volatile("nop");
    46a4:	03 43       	nop			

000046a6 <.Loc.356.2>:
  _enable_interrupts();
    46a6:	32 d2       	eint			
    46a8:	03 43       	nop			

000046aa <.LBE113>:
}
    46aa:	30 41       	ret			

000046ac <chSemSignalI>:
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
  chDbgCheck(sp != NULL);
    46ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    46ae:	08 24       	jz	$+18     	;abs 0x46c0

000046b0 <.Loc.857.1>:

  if (++sp->cnt <= (cnt_t)0) {
    46b0:	2d 4c       	mov	@r12,	r13	;
    46b2:	1d 53       	inc	r13		;
    46b4:	8c 4d 00 00 	mov	r13,	0(r12)	;
    46b8:	4e 43       	clr.b	r14		;
    46ba:	0e 9d       	cmp	r13,	r14	;
    46bc:	05 34       	jge	$+12     	;abs 0x46c8

000046be <.L60>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    46be:	30 41       	ret			

000046c0 <.L66>:
  chDbgCheck(sp != NULL);
    46c0:	3c 40 5f ae 	mov	#-20897,r12	;#0xae5f

000046c4 <.LVL77>:
    46c4:	b0 12 a6 44 	call	#17574		;#0x44a6

000046c8 <.L67>:
    46c8:	3e 40 92 b4 	mov	#-19310,r14	;#0xb492

000046cc <.L65>:
      if (tr->u1.semp == sp) {
    46cc:	1c 9e 04 00 	cmp	4(r14),	r12	;
    46d0:	09 24       	jz	$+20     	;abs 0x46e4

000046d2 <.Loc.868.1>:
      tr++;
    46d2:	3e 50 10 00 	add	#16,	r14	;#0x0010

000046d6 <.Loc.870.1>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    46d6:	3e 90 d2 b4 	cmp	#-19246,r14	;#0xb4d2
    46da:	f8 2b       	jnc	$-14     	;abs 0x46cc

000046dc <.Loc.870.1>:
    46dc:	3c 40 5f ae 	mov	#-20897,r12	;#0xae5f

000046e0 <.LVL81>:
    46e0:	b0 12 a6 44 	call	#17574		;#0x44a6

000046e4 <.L68>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    46e4:	fe 90 03 00 	cmp.b	#3,	2(r14)	;
    46e8:	02 00 
    46ea:	05 20       	jnz	$+12     	;abs 0x46f6

000046ec <.Loc.865.1>:
        (void) chSchReadyI(tr, MSG_OK);
    46ec:	4d 43       	clr.b	r13		;
    46ee:	0c 4e       	mov	r14,	r12	;

000046f0 <.LVL83>:
    46f0:	b0 12 c2 44 	call	#17602		;#0x44c2

000046f4 <.LVL84>:
        return;
    46f4:	e4 3f       	jmp	$-54     	;abs 0x46be

000046f6 <.L69>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    46f6:	3c 40 5f ae 	mov	#-20897,r12	;#0xae5f

000046fa <.LVL86>:
    46fa:	b0 12 a6 44 	call	#17574		;#0x44a6

000046fe <chEvtSignalI>:
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    46fe:	0c 93       	cmp	#0,	r12	;r3 As==00

00004700 <L0>:
    4700:	0c 24       	jz	$+26     	;abs 0x471a

00004702 <.Loc.974.1>:

  tp->epmask |= mask;
    4702:	1d dc 0a 00 	bis	10(r12),r13	;0x0000a

00004706 <.LVL107>:
    4706:	1e dc 0c 00 	bis	12(r12),r14	;0x0000c
    470a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a
    470e:	8c 4e 0c 00 	mov	r14,	12(r12)	; 0x000c

00004712 <.Loc.975.1>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4712:	ec 92 02 00 	cmp.b	#4,	2(r12)	;r2 As==10
    4716:	05 24       	jz	$+12     	;abs 0x4722

00004718 <.L83>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    (void) chSchReadyI(tp, MSG_OK);
  }
}
    4718:	30 41       	ret			

0000471a <.L87>:
  chDbgCheck(tp != NULL);
    471a:	3c 40 52 ae 	mov	#-20910,r12	;#0xae52

0000471e <.LVL110>:
    471e:	b0 12 a6 44 	call	#17574		;#0x44a6

00004722 <.L88>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4722:	1d fc 04 00 	and	4(r12),	r13	;
    4726:	1e fc 06 00 	and	6(r12),	r14	;

0000472a <.Loc.975.1>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    472a:	0f 4d       	mov	r13,	r15	;
    472c:	0f de       	bis	r14,	r15	;
    472e:	0f 93       	cmp	#0,	r15	;r3 As==00
    4730:	f3 27       	jz	$-24     	;abs 0x4718

00004732 <.Loc.977.1>:
    (void) chSchReadyI(tp, MSG_OK);
    4732:	4d 43       	clr.b	r13		;
    4734:	b0 12 c2 44 	call	#17602		;#0x44c2

00004738 <.LVL112>:
}
    4738:	ef 3f       	jmp	$-32     	;abs 0x4718

0000473a <chEvtSignal>:
    473a:	32 c2       	dint			

0000473c <L0>:
  asm volatile("nop");
    473c:	03 43       	nop			

0000473e <.LBE124>:
  chEvtSignalI(tp, mask);
    473e:	b0 12 fe 46 	call	#18174		;#0x46fe

00004742 <.LVL114>:
  chSchRescheduleS();
    4742:	b0 12 a6 45 	call	#17830		;#0x45a6

00004746 <.LBB126>:
  asm volatile("nop");
    4746:	03 43       	nop			

00004748 <.Loc.356.2>:
  _enable_interrupts();
    4748:	32 d2       	eint			
    474a:	03 43       	nop			

0000474c <.LBE126>:
}
    474c:	30 41       	ret			

0000474e <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    474e:	4a 15       	pushm	#5,	r10	;16-bit words

00004750 <.LCFI4>:
    4750:	06 4c       	mov	r12,	r6	;
    4752:	07 4d       	mov	r13,	r7	;

00004754 <.Loc.1000.1>:
  thread_t *ctp = nil.current;
    4754:	1a 42 8a b4 	mov	&0xb48a,r10	;0xb48a

00004758 <.LBB128>:
  _disable_interrupts();
    4758:	32 c2       	dint			

0000475a <.Loc.348.2>:
  asm volatile("nop");
    475a:	03 43       	nop			

0000475c <.LBE128>:
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    475c:	19 4a 0a 00 	mov	10(r10),r9	;0x0000a
    4760:	09 fc       	and	r12,	r9	;
    4762:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    4766:	08 fd       	and	r13,	r8	;

00004768 <.LVL118>:
    4768:	0c 49       	mov	r9,	r12	;

0000476a <.LVL119>:
    476a:	0c d8       	bis	r8,	r12	;
    476c:	0c 93       	cmp	#0,	r12	;r3 As==00
    476e:	12 20       	jnz	$+38     	;abs 0x4794

00004770 <.Loc.1005.1>:
    if (TIME_IMMEDIATE == timeout) {
    4770:	3e 93       	cmp	#-1,	r14	;r3 As==11
    4772:	1b 24       	jz	$+56     	;abs 0x47aa

00004774 <.Loc.1010.1>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    4774:	8a 46 04 00 	mov	r6,	4(r10)	;
    4778:	8a 4d 06 00 	mov	r13,	6(r10)	;

0000477c <.Loc.1011.1>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    477c:	0d 4e       	mov	r14,	r13	;
    477e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4780:	b0 12 d0 45 	call	#17872		;#0x45d0

00004784 <.LVL120>:
    4784:	0c 93       	cmp	#0,	r12	;r3 As==00
    4786:	15 38       	jl	$+44     	;abs 0x47b2

00004788 <.Loc.1016.1>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    4788:	09 46       	mov	r6,	r9	;

0000478a <.LVL121>:
    478a:	19 fa 0a 00 	and	10(r10),r9	;0x0000a
    478e:	08 47       	mov	r7,	r8	;
    4790:	18 fa 0c 00 	and	12(r10),r8	;0x0000c

00004794 <.L91>:
  }
  ctp->epmask &= ~m;
    4794:	8a c9 0a 00 	bic	r9,	10(r10)	; 0x000a
    4798:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c

0000479c <.LBB130>:
  asm volatile("nop");
    479c:	03 43       	nop			

0000479e <.Loc.356.2>:
  _enable_interrupts();
    479e:	32 d2       	eint			
    47a0:	03 43       	nop			

000047a2 <.L90>:
  chSysUnlock();

  return m;
}
    47a2:	0c 49       	mov	r9,	r12	;
    47a4:	0d 48       	mov	r8,	r13	;
    47a6:	46 17       	popm	#5,	r10	;16-bit words
    47a8:	30 41       	ret			

000047aa <.L95>:
  asm volatile("nop");
    47aa:	03 43       	nop			

000047ac <.Loc.356.2>:
  _enable_interrupts();
    47ac:	32 d2       	eint			
    47ae:	03 43       	nop			

000047b0 <.LBE132>:
      return (eventmask_t)0;
    47b0:	f8 3f       	jmp	$-14     	;abs 0x47a2

000047b2 <.L96>:
  asm volatile("nop");
    47b2:	03 43       	nop			

000047b4 <.Loc.356.2>:
  _enable_interrupts();
    47b4:	32 d2       	eint			
    47b6:	03 43       	nop			

000047b8 <.LBE134>:
      return (eventmask_t)0;
    47b8:	f4 3f       	jmp	$-22     	;abs 0x47a2

000047ba <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    47ba:	2a 15       	pushm	#3,	r10	;16-bit words

000047bc <.LCFI2>:
    47bc:	0a 4c       	mov	r12,	r10	;

000047be <L0>:
    47be:	08 4d       	mov	r13,	r8	;
    47c0:	09 4e       	mov	r14,	r9	;

000047c2 <.Loc.188.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);
    47c2:	0c 93       	cmp	#0,	r12	;r3 As==00
    47c4:	20 24       	jz	$+66     	;abs 0x4806

000047c6 <.L9>:

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    47c6:	0d 49       	mov	r9,	r13	;
    47c8:	0c 4a       	mov	r10,	r12	;
    47ca:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    47ce:	b0 12 5e 46 	call	#18014		;#0x465e

000047d2 <.LVL16>:
    47d2:	09 4c       	mov	r12,	r9	;

000047d4 <.LVL17>:
  if (rdymsg == MSG_OK) {
    47d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    47d6:	14 20       	jnz	$+42     	;abs 0x4800

000047d8 <.Loc.192.1>:
    *mbp->wrptr++ = msg;
    47d8:	1c 4a 04 00 	mov	4(r10),	r12	;
    47dc:	0d 4c       	mov	r12,	r13	;
    47de:	2d 53       	incd	r13		;
    47e0:	8a 4d 04 00 	mov	r13,	4(r10)	;
    47e4:	8c 48 00 00 	mov	r8,	0(r12)	;

000047e8 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    47e8:	9a 9a 02 00 	cmp	2(r10),	4(r10)	;
    47ec:	04 00 
    47ee:	02 28       	jnc	$+6      	;abs 0x47f4

000047f0 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    47f0:	aa 4a 04 00 	mov	@r10,	4(r10)	;

000047f4 <.L11>:
    }
    chSemSignalI(&mbp->fullsem);
    47f4:	0c 4a       	mov	r10,	r12	;
    47f6:	3c 52       	add	#8,	r12	;r2 As==11
    47f8:	b0 12 ac 46 	call	#18092		;#0x46ac

000047fc <.LVL18>:
    chSchRescheduleS();
    47fc:	b0 12 a6 45 	call	#17830		;#0x45a6

00004800 <.L8>:
  }

  return rdymsg;
}
    4800:	0c 49       	mov	r9,	r12	;
    4802:	28 17       	popm	#3,	r10	;16-bit words
    4804:	30 41       	ret			

00004806 <.L12>:
  chDbgCheck(mbp != NULL);
    4806:	3c 40 d4 ae 	mov	#-20780,r12	;#0xaed4
    480a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000480e <.LVL21>:
    480e:	db 3f       	jmp	$-72     	;abs 0x47c6

00004810 <chMBPost>:
    4810:	32 c2       	dint			

00004812 <L0>:
  asm volatile("nop");
    4812:	03 43       	nop			

00004814 <.LBE22>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4814:	b0 12 ba 47 	call	#18362		;#0x47ba

00004818 <.LBB24>:
  asm volatile("nop");
    4818:	03 43       	nop			

0000481a <.Loc.356.2>:
  _enable_interrupts();
    481a:	32 d2       	eint			
    481c:	03 43       	nop			

0000481e <.LBE24>:
}
    481e:	30 41       	ret			

00004820 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4820:	1a 15       	pushm	#2,	r10	;16-bit words

00004822 <.LCFI3>:
    4822:	0a 4c       	mov	r12,	r10	;
    4824:	09 4d       	mov	r13,	r9	;

00004826 <.Loc.220.1>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);
    4826:	0c 93       	cmp	#0,	r12	;r3 As==00
    4828:	1c 24       	jz	$+58     	;abs 0x4862

0000482a <.L15>:

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    482a:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    482e:	4d 43       	clr.b	r13		;
    4830:	0d 9c       	cmp	r12,	r13	;
    4832:	1c 34       	jge	$+58     	;abs 0x486c

00004834 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4834:	ba 53 0a 00 	add	#-1,	10(r10)	;r3 As==11, 0x000a

00004838 <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4838:	1c 4a 04 00 	mov	4(r10),	r12	;
    483c:	0d 4c       	mov	r12,	r13	;
    483e:	2d 53       	incd	r13		;
    4840:	8a 4d 04 00 	mov	r13,	4(r10)	;
    4844:	8c 49 00 00 	mov	r9,	0(r12)	;

00004848 <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4848:	9a 9a 02 00 	cmp	2(r10),	4(r10)	;
    484c:	04 00 
    484e:	02 28       	jnc	$+6      	;abs 0x4854

00004850 <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4850:	aa 4a 04 00 	mov	@r10,	4(r10)	;

00004854 <.L17>:
  }
  chSemSignalI(&mbp->fullsem);
    4854:	0c 4a       	mov	r10,	r12	;
    4856:	3c 52       	add	#8,	r12	;r2 As==11
    4858:	b0 12 ac 46 	call	#18092		;#0x46ac

0000485c <.LVL26>:

  return MSG_OK;
    485c:	4c 43       	clr.b	r12		;

0000485e <.L14>:
}
    485e:	19 17       	popm	#2,	r10	;16-bit words
    4860:	30 41       	ret			

00004862 <.L19>:
  chDbgCheck(mbp != NULL);
    4862:	3c 40 ca ae 	mov	#-20790,r12	;#0xaeca
    4866:	b0 12 a6 44 	call	#17574		;#0x44a6

0000486a <.LVL27>:
    486a:	df 3f       	jmp	$-64     	;abs 0x482a

0000486c <.L18>:
    return MSG_TIMEOUT;
    486c:	3c 43       	mov	#-1,	r12	;r3 As==11
    486e:	f7 3f       	jmp	$-16     	;abs 0x485e

00004870 <chMBFetchS>:
    4870:	2a 15       	pushm	#3,	r10	;16-bit words

00004872 <.LCFI6>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4872:	0a 4c       	mov	r12,	r10	;

00004874 <L0>:
    4874:	08 4d       	mov	r13,	r8	;
    4876:	09 4e       	mov	r14,	r9	;

00004878 <.Loc.387.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4878:	0c 93       	cmp	#0,	r12	;r3 As==00
    487a:	22 24       	jz	$+70     	;abs 0x48c0

0000487c <.Loc.387.1>:
    487c:	0d 93       	cmp	#0,	r13	;r3 As==00
    487e:	20 24       	jz	$+66     	;abs 0x48c0

00004880 <.L34>:

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4880:	0d 49       	mov	r9,	r13	;
    4882:	0c 4a       	mov	r10,	r12	;
    4884:	3c 52       	add	#8,	r12	;r2 As==11
    4886:	b0 12 5e 46 	call	#18014		;#0x465e

0000488a <.LVL44>:
    488a:	09 4c       	mov	r12,	r9	;

0000488c <.LVL45>:
  if (rdymsg == MSG_OK) {
    488c:	0c 93       	cmp	#0,	r12	;r3 As==00
    488e:	15 20       	jnz	$+44     	;abs 0x48ba

00004890 <.Loc.391.1>:
    *msgp = *mbp->rdptr++;
    4890:	1c 4a 06 00 	mov	6(r10),	r12	;
    4894:	0d 4c       	mov	r12,	r13	;
    4896:	2d 53       	incd	r13		;
    4898:	8a 4d 06 00 	mov	r13,	6(r10)	;
    489c:	a8 4c 00 00 	mov	@r12,	0(r8)	;

000048a0 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    48a0:	9a 9a 02 00 	cmp	2(r10),	6(r10)	;
    48a4:	06 00 
    48a6:	02 28       	jnc	$+6      	;abs 0x48ac

000048a8 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    48a8:	aa 4a 06 00 	mov	@r10,	6(r10)	;

000048ac <.L36>:
    }
    chSemSignalI(&mbp->emptysem);
    48ac:	0c 4a       	mov	r10,	r12	;
    48ae:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    48b2:	b0 12 ac 46 	call	#18092		;#0x46ac

000048b6 <.LVL46>:
    chSchRescheduleS();
    48b6:	b0 12 a6 45 	call	#17830		;#0x45a6

000048ba <.L32>:
  }

  return rdymsg;
}
    48ba:	0c 49       	mov	r9,	r12	;
    48bc:	28 17       	popm	#3,	r10	;16-bit words
    48be:	30 41       	ret			

000048c0 <.L33>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    48c0:	3c 40 bf ae 	mov	#-20801,r12	;#0xaebf
    48c4:	b0 12 a6 44 	call	#17574		;#0x44a6

000048c8 <.LVL49>:
    48c8:	db 3f       	jmp	$-72     	;abs 0x4880

000048ca <chMBFetch>:
    48ca:	32 c2       	dint			

000048cc <L0>:
  asm volatile("nop");
    48cc:	03 43       	nop			

000048ce <.LBE30>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    48ce:	b0 12 70 48 	call	#18544		;#0x4870

000048d2 <.LBB32>:
  asm volatile("nop");
    48d2:	03 43       	nop			

000048d4 <.Loc.356.2>:
  _enable_interrupts();
    48d4:	32 d2       	eint			
    48d6:	03 43       	nop			

000048d8 <.LBE32>:
}
    48d8:	30 41       	ret			

000048da <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    48da:	1a 15       	pushm	#2,	r10	;16-bit words

000048dc <.LCFI0>:
    48dc:	09 4c       	mov	r12,	r9	;
    48de:	0a 4d       	mov	r13,	r10	;

000048e0 <.Loc.112.1>:
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    48e0:	0d 93       	cmp	#0,	r13	;r3 As==00
    48e2:	04 24       	jz	$+10     	;abs 0x48ec

000048e4 <.Loc.112.1>:
    48e4:	0c 4d       	mov	r13,	r12	;

000048e6 <.LVL1>:
    48e6:	3c 53       	add	#-1,	r12	;r3 As==11
    48e8:	0d bc       	bit	r12,	r13	;
    48ea:	04 24       	jz	$+10     	;abs 0x48f4

000048ec <.L3>:
    48ec:	3c 40 de ae 	mov	#-20770,r12	;#0xaede
    48f0:	b0 12 a6 44 	call	#17574		;#0x44a6

000048f4 <.L4>:

  size = MEM_ALIGN_NEXT(size, align);
    48f4:	0d 4a       	mov	r10,	r13	;
    48f6:	0d 59       	add	r9,	r13	;
    48f8:	3d 53       	add	#-1,	r13	;r3 As==11
    48fa:	0c 43       	clr	r12		;
    48fc:	0c 8a       	sub	r10,	r12	;
    48fe:	0d fc       	and	r12,	r13	;

00004900 <.LVL3>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    4900:	1a 52 e4 b4 	add	&0xb4e4,r10	;0xb4e4

00004904 <.LVL4>:
    4904:	3a 53       	add	#-1,	r10	;r3 As==11
    4906:	0a fc       	and	r12,	r10	;

00004908 <.Loc.117.1>:

  if (((size_t)endmem - (size_t)p) < size) {
    4908:	1c 42 e2 b4 	mov	&0xb4e2,r12	;0xb4e2
    490c:	0c 8a       	sub	r10,	r12	;
    490e:	0c 9d       	cmp	r13,	r12	;
    4910:	06 28       	jnc	$+14     	;abs 0x491e

00004912 <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    4912:	0d 5a       	add	r10,	r13	;

00004914 <.LVL6>:
    4914:	82 4d e4 b4 	mov	r13,	&0xb4e4	;

00004918 <.Loc.122.1>:

  return p;
    4918:	0c 4a       	mov	r10,	r12	;

0000491a <.L2>:
}
    491a:	19 17       	popm	#2,	r10	;16-bit words
    491c:	30 41       	ret			

0000491e <.L6>:
    return NULL;
    491e:	4c 43       	clr.b	r12		;
    4920:	fc 3f       	jmp	$-6      	;abs 0x491a

00004922 <chCoreAllocAligned>:
    4922:	32 c2       	dint			

00004924 <L0>:
  asm volatile("nop");
    4924:	03 43       	nop			

00004926 <.LBE6>:
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  void *p;

  chSysLock();
  p = chCoreAllocAlignedI(size, align);
    4926:	b0 12 da 48 	call	#18650		;#0x48da

0000492a <.LBB8>:
  asm volatile("nop");
    492a:	03 43       	nop			

0000492c <.Loc.356.2>:
  _enable_interrupts();
    492c:	32 d2       	eint			
    492e:	03 43       	nop			

00004930 <.LBE8>:
  chSysUnlock();

  return p;
}
    4930:	30 41       	ret			

00004932 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    4932:	3c 40 e6 b4 	mov	#-19226,r12	;#0xb4e6
    4936:	bc 40 22 49 	mov	#18722,	0(r12)	;#0x4922
    493a:	00 00 

0000493c <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    493c:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00004940 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    4940:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00004944 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    4944:	9c 43 06 00 	mov	#1,	6(r12)	;r3 As==01

00004948 <.Loc.117.1>:
#endif
}
    4948:	30 41       	ret			

0000494a <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    494a:	2a 15       	pushm	#3,	r10	;16-bit words

0000494c <.LCFI0>:
    494c:	0a 4c       	mov	r12,	r10	;
    494e:	09 4d       	mov	r13,	r9	;
    4950:	08 4e       	mov	r14,	r8	;

00004952 <.Loc.78.1>:

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    4952:	0c 93       	cmp	#0,	r12	;r3 As==00
    4954:	0b 24       	jz	$+24     	;abs 0x496c

00004956 <.Loc.78.1>:
    4956:	5c 43       	mov.b	#1,	r12	;r3 As==01

00004958 <.LVL1>:
    4958:	0c 9d       	cmp	r13,	r12	;
    495a:	08 2c       	jc	$+18     	;abs 0x496c

0000495c <.L3>:

  mp->next = NULL;
    495c:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00

00004960 <.Loc.81.1>:
  mp->object_size = size;
    4960:	8a 49 02 00 	mov	r9,	2(r10)	;

00004964 <.Loc.82.1>:
  mp->provider = provider;
    4964:	8a 48 04 00 	mov	r8,	4(r10)	;

00004968 <.Loc.83.1>:
}
    4968:	28 17       	popm	#3,	r10	;16-bit words
    496a:	30 41       	ret			

0000496c <.L2>:
  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    496c:	3c 40 22 af 	mov	#-20702,r12	;#0xaf22
    4970:	b0 12 a6 44 	call	#17574		;#0x44a6

00004974 <.LVL3>:
    4974:	f3 3f       	jmp	$-24     	;abs 0x495c

00004976 <chPoolAllocI>:
    4976:	0a 15       	pushm	#1,	r10	;16-bit words

00004978 <L0>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4978:	0a 4c       	mov	r12,	r10	;

0000497a <.Loc.125.1>:
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);
    497a:	0c 93       	cmp	#0,	r12	;r3 As==00
    497c:	07 24       	jz	$+16     	;abs 0x498c

0000497e <.L5>:

  objp = mp->next;
    497e:	2c 4a       	mov	@r10,	r12	;

00004980 <.LVL6>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4980:	0c 93       	cmp	#0,	r12	;r3 As==00
    4982:	09 24       	jz	$+20     	;abs 0x4996

00004984 <.Loc.130.1>:
    mp->next = mp->next->next;
    4984:	aa 4c 00 00 	mov	@r12,	0(r10)	;

00004988 <.L4>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4988:	0a 17       	popm	#1,	r10	;16-bit words
    498a:	30 41       	ret			

0000498c <.L8>:
  chDbgCheck(mp != NULL);
    498c:	3c 40 15 af 	mov	#-20715,r12	;#0xaf15
    4990:	b0 12 a6 44 	call	#17574		;#0x44a6

00004994 <.LVL8>:
    4994:	f4 3f       	jmp	$-22     	;abs 0x497e

00004996 <.L6>:
  else if (mp->provider != NULL) {
    4996:	1e 4a 04 00 	mov	4(r10),	r14	;
    499a:	0e 93       	cmp	#0,	r14	;r3 As==00
    499c:	f5 27       	jz	$-20     	;abs 0x4988

0000499e <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    499e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    49a0:	1c 4a 02 00 	mov	2(r10),	r12	;

000049a4 <.LVL10>:
    49a4:	8e 12       	call	r14		;

000049a6 <.LVL11>:
  return objp;
    49a6:	f0 3f       	jmp	$-30     	;abs 0x4988

000049a8 <chPoolAlloc>:
    49a8:	32 c2       	dint			

000049aa <.Loc.348.2>:
  asm volatile("nop");
    49aa:	03 43       	nop			

000049ac <L0>:
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
    49ac:	b0 12 76 49 	call	#18806		;#0x4976

000049b0 <.LBB24>:
  asm volatile("nop");
    49b0:	03 43       	nop			

000049b2 <.Loc.356.2>:
  _enable_interrupts();
    49b2:	32 d2       	eint			
    49b4:	03 43       	nop			

000049b6 <.LBE24>:
  chSysUnlock();

  return objp;
}
    49b6:	30 41       	ret			

000049b8 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    49b8:	1a 15       	pushm	#2,	r10	;16-bit words

000049ba <.LCFI2>:
    49ba:	0a 4c       	mov	r12,	r10	;
    49bc:	09 4d       	mov	r13,	r9	;

000049be <.LVL15>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
    49be:	0c 93       	cmp	#0,	r12	;r3 As==00
    49c0:	08 24       	jz	$+18     	;abs 0x49d2

000049c2 <.Loc.176.1>:
    49c2:	0d 93       	cmp	#0,	r13	;r3 As==00
    49c4:	06 24       	jz	$+14     	;abs 0x49d2

000049c6 <.L12>:

  php->next = mp->next;
    49c6:	a9 4a 00 00 	mov	@r10,	0(r9)	;

000049ca <.Loc.179.1>:
  mp->next = php;
    49ca:	8a 49 00 00 	mov	r9,	0(r10)	;

000049ce <.Loc.180.1>:
}
    49ce:	19 17       	popm	#2,	r10	;16-bit words
    49d0:	30 41       	ret			

000049d2 <.L11>:
  chDbgCheck((mp != NULL) && (objp != NULL));
    49d2:	3c 40 09 af 	mov	#-20727,r12	;#0xaf09
    49d6:	b0 12 a6 44 	call	#17574		;#0x44a6

000049da <.LVL17>:
    49da:	f5 3f       	jmp	$-20     	;abs 0x49c6

000049dc <chPoolFree>:
    49dc:	32 c2       	dint			

000049de <L0>:
  asm volatile("nop");
    49de:	03 43       	nop			

000049e0 <.LBE26>:
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
    49e0:	b0 12 b8 49 	call	#18872		;#0x49b8

000049e4 <.LBB28>:
  asm volatile("nop");
    49e4:	03 43       	nop			

000049e6 <.Loc.356.2>:
  _enable_interrupts();
    49e6:	32 d2       	eint			
    49e8:	03 43       	nop			

000049ea <.LBE28>:
  chSysUnlock();
}
    49ea:	30 41       	ret			

000049ec <chGuardedPoolObjectInit>:
 *                      memory pool, the minimum accepted size is the size
 *                      of a pointer to void.
 *
 * @init
 */
void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp, size_t size) {
    49ec:	0a 15       	pushm	#1,	r10	;16-bit words

000049ee <.LCFI4>:
    49ee:	0a 4c       	mov	r12,	r10	;

000049f0 <.Loc.214.1>:

  chPoolObjectInit(&gmp->pool, size, NULL);
    49f0:	4e 43       	clr.b	r14		;
    49f2:	2c 53       	incd	r12		;

000049f4 <.LVL28>:
    49f4:	b0 12 4a 49 	call	#18762		;#0x494a

000049f8 <.LVL29>:
  chSemObjectInit(&gmp->sem, (cnt_t)0);
    49f8:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00

000049fc <.Loc.216.1>:
}
    49fc:	0a 17       	popm	#1,	r10	;16-bit words
    49fe:	30 41       	ret			

00004a00 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
    4a00:	0a 15       	pushm	#1,	r10	;16-bit words

00004a02 <.LCFI5>:
    4a02:	0a 4c       	mov	r12,	r10	;

00004a04 <.Loc.263.1>:
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
    4a04:	b0 12 5e 46 	call	#18014		;#0x465e

00004a08 <.LVL31>:
  if (msg != MSG_OK) {
    4a08:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a0a:	06 20       	jnz	$+14     	;abs 0x4a18

00004a0c <.Loc.268.1>:
    return NULL;
  }

  return chPoolAllocI(&gmp->pool);
    4a0c:	0c 4a       	mov	r10,	r12	;

00004a0e <.LVL32>:
    4a0e:	2c 53       	incd	r12		;
    4a10:	b0 12 76 49 	call	#18806		;#0x4976

00004a14 <.L20>:
}
    4a14:	0a 17       	popm	#1,	r10	;16-bit words
    4a16:	30 41       	ret			

00004a18 <.L22>:
    return NULL;
    4a18:	4c 43       	clr.b	r12		;

00004a1a <.LVL35>:
    4a1a:	fc 3f       	jmp	$-6      	;abs 0x4a14

00004a1c <chGuardedPoolFreeI>:
    4a1c:	0a 15       	pushm	#1,	r10	;16-bit words

00004a1e <L0>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
    4a1e:	0a 4c       	mov	r12,	r10	;

00004a20 <.Loc.311.1>:

  chPoolFreeI(&gmp->pool, objp);
    4a20:	2c 53       	incd	r12		;

00004a22 <.LVL39>:
    4a22:	b0 12 b8 49 	call	#18872		;#0x49b8

00004a26 <.LVL40>:
  chSemSignalI(&gmp->sem);
    4a26:	0c 4a       	mov	r10,	r12	;
    4a28:	b0 12 ac 46 	call	#18092		;#0x46ac

00004a2c <.LVL41>:
}
    4a2c:	0a 17       	popm	#1,	r10	;16-bit words
    4a2e:	30 41       	ret			

00004a30 <chGuardedPoolFree>:
  _disable_interrupts();
    4a30:	32 c2       	dint			

00004a32 <.Loc.348.2>:
  asm volatile("nop");
    4a32:	03 43       	nop			

00004a34 <.LBE36>:
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
    4a34:	b0 12 1c 4a 	call	#18972		;#0x4a1c

00004a38 <.LVL43>:
  chSchRescheduleS();
    4a38:	b0 12 a6 45 	call	#17830		;#0x45a6

00004a3c <.LBB38>:
  asm volatile("nop");
    4a3c:	03 43       	nop			

00004a3e <.Loc.356.2>:
  _enable_interrupts();
    4a3e:	32 d2       	eint			
    4a40:	03 43       	nop			

00004a42 <.LBE38>:
  chSysUnlock();
}
    4a42:	30 41       	ret			

00004a44 <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
    4a44:	2a 15       	pushm	#3,	r10	;16-bit words

00004a46 <.LCFI7>:
    4a46:	08 4c       	mov	r12,	r8	;
    4a48:	09 4d       	mov	r13,	r9	;
    4a4a:	0a 4e       	mov	r14,	r10	;

00004a4c <.Loc.233.1>:
  chDbgCheck((gmp != NULL) && (n != 0U));
    4a4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a4e:	02 24       	jz	$+6      	;abs 0x4a54

00004a50 <.Loc.233.1>:
    4a50:	0e 93       	cmp	#0,	r14	;r3 As==00
    4a52:	0c 20       	jnz	$+26     	;abs 0x4a6c

00004a54 <.L27>:
    4a54:	3c 40 f2 ae 	mov	#-20750,r12	;#0xaef2

00004a58 <.LVL46>:
    4a58:	b0 12 a6 44 	call	#17574		;#0x44a6

00004a5c <.LVL47>:
    4a5c:	07 3c       	jmp	$+16     	;abs 0x4a6c

00004a5e <.L30>:
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
    4a5e:	0d 49       	mov	r9,	r13	;
    4a60:	0c 48       	mov	r8,	r12	;
    4a62:	b0 12 30 4a 	call	#18992		;#0x4a30

00004a66 <.LBE40>:
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
    4a66:	19 58 04 00 	add	4(r8),	r9	;

00004a6a <.Loc.240.1>:
    n--;
    4a6a:	3a 53       	add	#-1,	r10	;r3 As==11

00004a6c <.L29>:
  while (n != 0U) {
    4a6c:	0a 93       	cmp	#0,	r10	;r3 As==00
    4a6e:	f7 23       	jnz	$-16     	;abs 0x4a5e

00004a70 <.Loc.242.1>:
}
    4a70:	28 17       	popm	#3,	r10	;16-bit words
    4a72:	30 41       	ret			

00004a74 <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    4a74:	6a 15       	pushm	#7,	r10	;16-bit words

00004a76 <L0>:
  asm volatile ("mov r1, @R13");
    4a76:	8d 41 00 00 	mov	r1,	0(r13)	;

00004a7a <.Loc.81.1>:
  asm volatile ("mov @R12, r1");
    4a7a:	21 4c       	mov	@r12,	r1	;

00004a7c <.Loc.82.1>:
  asm volatile ("popm.w #7, R10");
    4a7c:	64 17       	popm	#7,	r10	;16-bit words

00004a7e <.Loc.83.1>:
  asm volatile ("ret");
    4a7e:	30 41       	ret			

00004a80 <_port_thread_start>:
  asm volatile("nop");
    4a80:	03 43       	nop			

00004a82 <.Loc.356.2>:
  _enable_interrupts();
    4a82:	32 d2       	eint			
    4a84:	03 43       	nop			

00004a86 <.LBE4>:
  chSysUnlock();
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    4a86:	0c 45       	mov	r5,	r12	;

00004a88 <.Loc.101.1>:
  asm volatile ("call R4");
    4a88:	84 12       	call	r4		;

00004a8a <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4a8a:	4c 43       	clr.b	r12		;
    4a8c:	b0 12 a6 44 	call	#17574		;#0x44a6

00004a90 <.LVL1>:
#endif
}
    4a90:	30 41       	ret			

00004a92 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4a92:	3a 15       	pushm	#4,	r10	;16-bit words

00004a94 <.LCFI0>:
    4a94:	08 4c       	mov	r12,	r8	;
    4a96:	07 4d       	mov	r13,	r7	;

00004a98 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    4a98:	09 4c       	mov	r12,	r9	;

00004a9a <.LVL1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4a9a:	2c 4c       	mov	@r12,	r12	;

00004a9c <.LVL2>:
    4a9c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a9e:	02 38       	jl	$+6      	;abs 0x4aa4

00004aa0 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4aa0:	37 17       	popm	#4,	r10	;16-bit words
    4aa2:	30 41       	ret			

00004aa4 <.L8>:
    4aa4:	3a 40 92 b4 	mov	#-19310,r10	;#0xb492

00004aa8 <.L2>:
      if (tp->u1.semp == sp) {
    4aa8:	19 9a 04 00 	cmp	4(r10),	r9	;
    4aac:	0a 24       	jz	$+22     	;abs 0x4ac2

00004aae <.Loc.74.1>:
      tp++;
    4aae:	3a 50 10 00 	add	#16,	r10	;#0x0010

00004ab2 <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4ab2:	3a 90 d2 b4 	cmp	#-19246,r10	;#0xb4d2
    4ab6:	f8 2b       	jnc	$-14     	;abs 0x4aa8

00004ab8 <.Loc.76.1>:
    4ab8:	3c 40 33 af 	mov	#-20685,r12	;#0xaf33
    4abc:	b0 12 a6 44 	call	#17574		;#0x44a6

00004ac0 <.LVL6>:
    4ac0:	f3 3f       	jmp	$-24     	;abs 0x4aa8

00004ac2 <.L9>:
        sp->cnt++;
    4ac2:	98 53 00 00 	inc	0(r8)		;

00004ac6 <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4ac6:	fa 90 03 00 	cmp.b	#3,	2(r10)	;
    4aca:	02 00 
    4acc:	04 24       	jz	$+10     	;abs 0x4ad6

00004ace <.Loc.69.1>:
    4ace:	3c 40 33 af 	mov	#-20685,r12	;#0xaf33
    4ad2:	b0 12 a6 44 	call	#17574		;#0x44a6

00004ad6 <.L5>:
        (void) chSchReadyI(tp, msg);
    4ad6:	0d 47       	mov	r7,	r13	;
    4ad8:	0c 4a       	mov	r10,	r12	;
    4ada:	b0 12 c2 44 	call	#17602		;#0x44c2

00004ade <.LVL8>:
        return;
    4ade:	e0 3f       	jmp	$-62     	;abs 0x4aa0

00004ae0 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4ae0:	b0 12 7c 4d 	call	#19836		;#0x4d7c

00004ae4 <L0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4ae4:	3c 40 c2 b0 	mov	#-20286,r12	;#0xb0c2
    4ae8:	b0 12 d2 4e 	call	#20178		;#0x4ed2

00004aec <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4aec:	b0 12 0c 4b 	call	#19212		;#0x4b0c

00004af0 <.LVL2>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    4af0:	b0 12 de 4b 	call	#19422		;#0x4bde

00004af4 <.LVL3>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4af4:	b0 12 3c 4c 	call	#19516		;#0x4c3c

00004af8 <.LVL4>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    4af8:	b0 12 42 4c 	call	#19522		;#0x4c42

00004afc <.LVL5>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4afc:	b0 12 04 60 	call	#24580		;#0x6004

00004b00 <.LVL6>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4b00:	b0 12 06 4b 	call	#19206		;#0x4b06

00004b04 <.LVL7>:
#endif
}
    4b04:	30 41       	ret			

00004b06 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4b06:	b0 12 d8 4d 	call	#19928		;#0x4dd8

00004b0a <.LVL0>:
}
    4b0a:	30 41       	ret			

00004b0c <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    4b0c:	b0 12 90 5e 	call	#24208		;#0x5e90

00004b10 <.LVL0>:
}
    4b10:	30 41       	ret			

00004b12 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    4b12:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004b16 <.Loc.71.1>:
  gptp->config = NULL;
    4b16:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00004b1a <.Loc.72.1>:
}
    4b1a:	30 41       	ret			

00004b1c <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    4b1c:	1a 15       	pushm	#2,	r10	;16-bit words

00004b1e <.LCFI0>:
    4b1e:	0a 4c       	mov	r12,	r10	;
    4b20:	09 4d       	mov	r13,	r9	;

00004b22 <.Loc.84.1>:

  osalDbgCheck((gptp != NULL) && (config != NULL));
    4b22:	0c 93       	cmp	#0,	r12	;r3 As==00
    4b24:	19 24       	jz	$+52     	;abs 0x4b58

00004b26 <.Loc.84.1>:
    4b26:	0d 93       	cmp	#0,	r13	;r3 As==00
    4b28:	17 24       	jz	$+48     	;abs 0x4b58

00004b2a <.L5>:
  _disable_interrupts();
    4b2a:	32 c2       	dint			

00004b2c <.Loc.348.2>:
  asm volatile("nop");
    4b2c:	03 43       	nop			

00004b2e <.LBE54>:

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    4b2e:	6c 4a       	mov.b	@r10,	r12	;
    4b30:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4b32:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4b34:	4d 9c       	cmp.b	r12,	r13	;
    4b36:	04 2c       	jc	$+10     	;abs 0x4b40

00004b38 <.Loc.87.1>:
    4b38:	3c 40 69 af 	mov	#-20631,r12	;#0xaf69
    4b3c:	b0 12 a6 44 	call	#17574		;#0x44a6

00004b40 <.L6>:
              "invalid state");
  gptp->config = config;
    4b40:	8a 49 02 00 	mov	r9,	2(r10)	;

00004b44 <.Loc.90.1>:
  gpt_lld_start(gptp);
    4b44:	0c 4a       	mov	r10,	r12	;
    4b46:	b0 12 a0 5e 	call	#24224		;#0x5ea0

00004b4a <.LVL5>:
  gptp->state = GPT_READY;
    4b4a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004b4e <.LBB57>:
  asm volatile("nop");
    4b4e:	03 43       	nop			

00004b50 <.Loc.356.2>:
  _enable_interrupts();
    4b50:	32 d2       	eint			
    4b52:	03 43       	nop			

00004b54 <.LBE57>:
  osalSysUnlock();
}
    4b54:	19 17       	popm	#2,	r10	;16-bit words
    4b56:	30 41       	ret			

00004b58 <.L4>:
  osalDbgCheck((gptp != NULL) && (config != NULL));
    4b58:	3c 40 69 af 	mov	#-20631,r12	;#0xaf69
    4b5c:	b0 12 a6 44 	call	#17574		;#0x44a6

00004b60 <.LVL6>:
    4b60:	e4 3f       	jmp	$-54     	;abs 0x4b2a

00004b62 <gptStartOneShotI>:
    4b62:	1a 15       	pushm	#2,	r10	;16-bit words

00004b64 <L0>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    4b64:	0a 4c       	mov	r12,	r10	;
    4b66:	09 4d       	mov	r13,	r9	;

00004b68 <.Loc.200.1>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4b68:	0c 93       	cmp	#0,	r12	;r3 As==00
    4b6a:	14 24       	jz	$+42     	;abs 0x4b94

00004b6c <.L21>:
  osalDbgCheck(gptp->config->callback != NULL);
    4b6c:	1c 4a 02 00 	mov	2(r10),	r12	;
    4b70:	8c 93 04 00 	cmp	#0,	4(r12)	;r3 As==00
    4b74:	14 24       	jz	$+42     	;abs 0x4b9e

00004b76 <.L22>:
  osalDbgAssert(gptp->state == GPT_READY,
    4b76:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4b7a:	04 24       	jz	$+10     	;abs 0x4b84

00004b7c <.Loc.202.1>:
    4b7c:	3c 40 58 af 	mov	#-20648,r12	;#0xaf58
    4b80:	b0 12 a6 44 	call	#17574		;#0x44a6

00004b84 <.L23>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    4b84:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00004b88 <.Loc.206.1>:
  gpt_lld_start_timer(gptp, interval);
    4b88:	0d 49       	mov	r9,	r13	;
    4b8a:	0c 4a       	mov	r10,	r12	;
    4b8c:	b0 12 6e 5f 	call	#24430		;#0x5f6e

00004b90 <.LVL27>:
}
    4b90:	19 17       	popm	#2,	r10	;16-bit words
    4b92:	30 41       	ret			

00004b94 <.L24>:
  osalDbgCheck(gptp != NULL);
    4b94:	3c 40 58 af 	mov	#-20648,r12	;#0xaf58
    4b98:	b0 12 a6 44 	call	#17574		;#0x44a6

00004b9c <.LVL28>:
    4b9c:	e7 3f       	jmp	$-48     	;abs 0x4b6c

00004b9e <.L25>:
  osalDbgCheck(gptp->config->callback != NULL);
    4b9e:	3c 40 58 af 	mov	#-20648,r12	;#0xaf58
    4ba2:	b0 12 a6 44 	call	#17574		;#0x44a6

00004ba6 <.LVL29>:
    4ba6:	e7 3f       	jmp	$-48     	;abs 0x4b76

00004ba8 <gptStopTimerI>:
    4ba8:	0a 15       	pushm	#1,	r10	;16-bit words

00004baa <.LCFI5>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    4baa:	0a 4c       	mov	r12,	r10	;

00004bac <L0>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4bac:	0c 93       	cmp	#0,	r12	;r3 As==00
    4bae:	0d 24       	jz	$+28     	;abs 0x4bca

00004bb0 <.L28>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4bb0:	6c 4a       	mov.b	@r10,	r12	;
    4bb2:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    4bb6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4bb8:	4d 9c       	cmp.b	r12,	r13	;
    4bba:	0c 28       	jnc	$+26     	;abs 0x4bd4

00004bbc <.L29>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    4bbc:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004bc0 <.Loc.239.1>:
  gpt_lld_stop_timer(gptp);
    4bc0:	0c 4a       	mov	r10,	r12	;
    4bc2:	b0 12 9c 5f 	call	#24476		;#0x5f9c

00004bc6 <.LVL34>:
}
    4bc6:	0a 17       	popm	#1,	r10	;16-bit words
    4bc8:	30 41       	ret			

00004bca <.L30>:
  osalDbgCheck(gptp != NULL);
    4bca:	3c 40 4a af 	mov	#-20662,r12	;#0xaf4a
    4bce:	b0 12 a6 44 	call	#17574		;#0x44a6

00004bd2 <.LVL35>:
    4bd2:	ee 3f       	jmp	$-34     	;abs 0x4bb0

00004bd4 <.L31>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4bd4:	3c 40 4a af 	mov	#-20662,r12	;#0xaf4a
    4bd8:	b0 12 a6 44 	call	#17574		;#0x44a6

00004bdc <.LVL36>:
    4bdc:	ef 3f       	jmp	$-32     	;abs 0x4bbc

00004bde <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    4bde:	b0 12 76 51 	call	#20854		;#0x5176

00004be2 <L0>:
}
    4be2:	30 41       	ret			

00004be4 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    4be4:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004be8 <.Loc.74.1>:
  i2cp->config = NULL;
    4be8:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00004bec <.Loc.83.1>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    4bec:	30 41       	ret			

00004bee <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    4bee:	1a 15       	pushm	#2,	r10	;16-bit words

00004bf0 <.LCFI0>:
    4bf0:	0a 4c       	mov	r12,	r10	;
    4bf2:	09 4d       	mov	r13,	r9	;

00004bf4 <.Loc.95.1>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    4bf4:	0c 93       	cmp	#0,	r12	;r3 As==00
    4bf6:	1d 24       	jz	$+60     	;abs 0x4c32

00004bf8 <.Loc.95.1>:
    4bf8:	0d 93       	cmp	#0,	r13	;r3 As==00
    4bfa:	1b 24       	jz	$+56     	;abs 0x4c32

00004bfc <.L5>:
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    4bfc:	6c 4a       	mov.b	@r10,	r12	;
    4bfe:	4d 4c       	mov.b	r12,	r13	;
    4c00:	7d 53       	add.b	#-1,	r13	;r3 As==11
    4c02:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4c04:	4e 9d       	cmp.b	r13,	r14	;
    4c06:	07 2c       	jc	$+16     	;abs 0x4c16

00004c08 <.Loc.96.1>:
    4c08:	3c 90 05 00 	cmp	#5,	r12	;
    4c0c:	04 24       	jz	$+10     	;abs 0x4c16

00004c0e <.Loc.96.1>:
    4c0e:	3c 40 72 af 	mov	#-20622,r12	;#0xaf72
    4c12:	b0 12 a6 44 	call	#17574		;#0x44a6

00004c16 <.L6>:
  _disable_interrupts();
    4c16:	32 c2       	dint			

00004c18 <.Loc.348.2>:
  asm volatile("nop");
    4c18:	03 43       	nop			

00004c1a <.LBE38>:
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    4c1a:	8a 49 02 00 	mov	r9,	2(r10)	;

00004c1e <.Loc.101.1>:
  i2c_lld_start(i2cp);
    4c1e:	0c 4a       	mov	r10,	r12	;
    4c20:	b0 12 a8 51 	call	#20904		;#0x51a8

00004c24 <.LVL5>:
  i2cp->state = I2C_READY;
    4c24:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004c28 <.LBB41>:
  asm volatile("nop");
    4c28:	03 43       	nop			

00004c2a <.Loc.356.2>:
  _enable_interrupts();
    4c2a:	32 d2       	eint			
    4c2c:	03 43       	nop			

00004c2e <.LBE41>:
  osalSysUnlock();
}
    4c2e:	19 17       	popm	#2,	r10	;16-bit words
    4c30:	30 41       	ret			

00004c32 <.L4>:
  osalDbgCheck((i2cp != NULL) && (config != NULL));
    4c32:	3c 40 72 af 	mov	#-20622,r12	;#0xaf72
    4c36:	b0 12 a6 44 	call	#17574		;#0x44a6

00004c3a <.LVL6>:
    4c3a:	e0 3f       	jmp	$-62     	;abs 0x4bfc

00004c3c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    4c3c:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00004c3e <L0>:
    4c3e:	6a 51       	add.b	@r1,	r10	;

00004c40 <.LVL0>:
}
    4c40:	30 41       	ret			

00004c42 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    4c42:	b0 12 20 5c 	call	#23584		;#0x5c20

00004c46 <.LVL0>:
}
    4c46:	30 41       	ret			

00004c48 <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    4c48:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004c4c <.Loc.71.1>:
  uartp->txstate    = UART_TX_IDLE;
    4c4c:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00004c50 <.Loc.72.1>:
  uartp->rxstate    = UART_RX_IDLE;
    4c50:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00004c54 <.Loc.73.1>:
  uartp->config     = NULL;
    4c54:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00004c58 <.Loc.75.1>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    4c58:	cc 43 06 00 	mov.b	#0,	6(r12)	;r3 As==00

00004c5c <.Loc.76.1>:
  uartp->threadrx   = NULL;
    4c5c:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00004c60 <.Loc.77.1>:
  uartp->threadtx   = NULL;
    4c60:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00004c64 <.Loc.87.1>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    4c64:	30 41       	ret			

00004c66 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    4c66:	1a 15       	pushm	#2,	r10	;16-bit words

00004c68 <.LCFI0>:
    4c68:	0a 4c       	mov	r12,	r10	;
    4c6a:	09 4d       	mov	r13,	r9	;

00004c6c <.Loc.99.1>:

  osalDbgCheck((uartp != NULL) && (config != NULL));
    4c6c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4c6e:	19 24       	jz	$+52     	;abs 0x4ca2

00004c70 <.Loc.99.1>:
    4c70:	0d 93       	cmp	#0,	r13	;r3 As==00
    4c72:	17 24       	jz	$+48     	;abs 0x4ca2

00004c74 <.L5>:
  _disable_interrupts();
    4c74:	32 c2       	dint			

00004c76 <.Loc.348.2>:
  asm volatile("nop");
    4c76:	03 43       	nop			

00004c78 <.LBE84>:

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    4c78:	6c 4a       	mov.b	@r10,	r12	;
    4c7a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4c7c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4c7e:	4d 9c       	cmp.b	r12,	r13	;
    4c80:	04 2c       	jc	$+10     	;abs 0x4c8a

00004c82 <.Loc.102.1>:
    4c82:	3c 40 ad af 	mov	#-20563,r12	;#0xafad
    4c86:	b0 12 a6 44 	call	#17574		;#0x44a6

00004c8a <.L6>:
                "invalid state");

  uartp->config = config;
    4c8a:	8a 49 04 00 	mov	r9,	4(r10)	;

00004c8e <.Loc.106.1>:
  uart_lld_start(uartp);
    4c8e:	0c 4a       	mov	r10,	r12	;
    4c90:	b0 12 7c 5c 	call	#23676		;#0x5c7c

00004c94 <.LVL5>:
  uartp->state = UART_READY;
    4c94:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004c98 <.LBB87>:
  asm volatile("nop");
    4c98:	03 43       	nop			

00004c9a <.Loc.356.2>:
  _enable_interrupts();
    4c9a:	32 d2       	eint			
    4c9c:	03 43       	nop			

00004c9e <.LBE87>:
  osalSysUnlock();
}
    4c9e:	19 17       	popm	#2,	r10	;16-bit words
    4ca0:	30 41       	ret			

00004ca2 <.L4>:
  osalDbgCheck((uartp != NULL) && (config != NULL));
    4ca2:	3c 40 ad af 	mov	#-20563,r12	;#0xafad
    4ca6:	b0 12 a6 44 	call	#17574		;#0x44a6

00004caa <.LVL6>:
    4caa:	e4 3f       	jmp	$-54     	;abs 0x4c74

00004cac <uartStartSendI>:
    4cac:	2a 15       	pushm	#3,	r10	;16-bit words

00004cae <L0>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    4cae:	0a 4c       	mov	r12,	r10	;
    4cb0:	09 4d       	mov	r13,	r9	;
    4cb2:	08 4e       	mov	r14,	r8	;

00004cb4 <.Loc.175.1>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
    4cb4:	0c 93       	cmp	#0,	r12	;r3 As==00
    4cb6:	04 24       	jz	$+10     	;abs 0x4cc0

00004cb8 <.Loc.175.1>:
    4cb8:	0d 93       	cmp	#0,	r13	;r3 As==00
    4cba:	02 24       	jz	$+6      	;abs 0x4cc0

00004cbc <.Loc.175.1>:
    4cbc:	0e 93       	cmp	#0,	r14	;r3 As==00
    4cbe:	04 20       	jnz	$+10     	;abs 0x4cc8

00004cc0 <.L18>:
    4cc0:	3c 40 9e af 	mov	#-20578,r12	;#0xaf9e

00004cc4 <.LVL19>:
    4cc4:	b0 12 a6 44 	call	#17574		;#0x44a6

00004cc8 <.L19>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4cc8:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4ccc:	04 24       	jz	$+10     	;abs 0x4cd6

00004cce <.Loc.176.1>:
    4cce:	3c 40 9e af 	mov	#-20578,r12	;#0xaf9e
    4cd2:	b0 12 a6 44 	call	#17574		;#0x44a6

00004cd6 <.L20>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    4cd6:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    4cda:	09 24       	jz	$+20     	;abs 0x4cee

00004cdc <.L21>:

  uart_lld_start_send(uartp, n, txbuf);
    4cdc:	0e 48       	mov	r8,	r14	;
    4cde:	0d 49       	mov	r9,	r13	;
    4ce0:	0c 4a       	mov	r10,	r12	;
    4ce2:	b0 12 d4 5d 	call	#24020		;#0x5dd4

00004ce6 <.LVL22>:
  uartp->txstate = UART_TX_ACTIVE;
    4ce6:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00004cea <.Loc.181.1>:
}
    4cea:	28 17       	popm	#3,	r10	;16-bit words
    4cec:	30 41       	ret			

00004cee <.L22>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    4cee:	3c 40 9e af 	mov	#-20578,r12	;#0xaf9e
    4cf2:	b0 12 a6 44 	call	#17574		;#0x44a6

00004cf6 <.LVL23>:
    4cf6:	f2 3f       	jmp	$-26     	;abs 0x4cdc

00004cf8 <uartStartReceiveI>:
    4cf8:	2a 15       	pushm	#3,	r10	;16-bit words

00004cfa <L0>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    4cfa:	0a 4c       	mov	r12,	r10	;
    4cfc:	09 4d       	mov	r13,	r9	;
    4cfe:	08 4e       	mov	r14,	r8	;

00004d00 <.Loc.281.1>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
    4d00:	0c 93       	cmp	#0,	r12	;r3 As==00
    4d02:	04 24       	jz	$+10     	;abs 0x4d0c

00004d04 <.Loc.281.1>:
    4d04:	0d 93       	cmp	#0,	r13	;r3 As==00
    4d06:	02 24       	jz	$+6      	;abs 0x4d0c

00004d08 <.Loc.281.1>:
    4d08:	0e 93       	cmp	#0,	r14	;r3 As==00
    4d0a:	04 20       	jnz	$+10     	;abs 0x4d14

00004d0c <.L44>:
    4d0c:	3c 40 8c af 	mov	#-20596,r12	;#0xaf8c

00004d10 <.LVL43>:
    4d10:	b0 12 a6 44 	call	#17574		;#0x44a6

00004d14 <.L45>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4d14:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4d18:	04 24       	jz	$+10     	;abs 0x4d22

00004d1a <.Loc.282.1>:
    4d1a:	3c 40 8c af 	mov	#-20596,r12	;#0xaf8c
    4d1e:	b0 12 a6 44 	call	#17574		;#0x44a6

00004d22 <.L46>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    4d22:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4d26:	09 24       	jz	$+20     	;abs 0x4d3a

00004d28 <.L47>:

  uart_lld_start_receive(uartp, n, rxbuf);
    4d28:	0e 48       	mov	r8,	r14	;
    4d2a:	0d 49       	mov	r9,	r13	;
    4d2c:	0c 4a       	mov	r10,	r12	;
    4d2e:	b0 12 10 5e 	call	#24080		;#0x5e10

00004d32 <.LVL46>:
  uartp->rxstate = UART_RX_ACTIVE;
    4d32:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

00004d36 <.Loc.287.1>:
}
    4d36:	28 17       	popm	#3,	r10	;16-bit words
    4d38:	30 41       	ret			

00004d3a <.L48>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    4d3a:	3c 40 8c af 	mov	#-20596,r12	;#0xaf8c
    4d3e:	b0 12 a6 44 	call	#17574		;#0x44a6

00004d42 <.LVL47>:
    4d42:	f2 3f       	jmp	$-26     	;abs 0x4d28

00004d44 <uartStopReceiveI>:
    4d44:	0a 15       	pushm	#1,	r10	;16-bit words

00004d46 <L0>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    4d46:	0a 4c       	mov	r12,	r10	;

00004d48 <.Loc.337.1>:

  osalDbgCheckClassI();
  osalDbgCheck(uartp != NULL);
    4d48:	0c 93       	cmp	#0,	r12	;r3 As==00
    4d4a:	0d 24       	jz	$+28     	;abs 0x4d66

00004d4c <.L57>:
  osalDbgAssert(uartp->state == UART_READY, "not active");
    4d4c:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4d50:	04 24       	jz	$+10     	;abs 0x4d5a

00004d52 <.Loc.338.1>:
    4d52:	3c 40 7b af 	mov	#-20613,r12	;#0xaf7b
    4d56:	b0 12 a6 44 	call	#17574		;#0x44a6

00004d5a <.L58>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    4d5a:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4d5e:	08 24       	jz	$+18     	;abs 0x4d70

00004d60 <.Loc.345.1>:
    size_t n = uart_lld_stop_receive(uartp);
    uartp->rxstate = UART_RX_IDLE;
    return n;
  }
  return 0;
    4d60:	4c 43       	clr.b	r12		;

00004d62 <.L56>:
}
    4d62:	0a 17       	popm	#1,	r10	;16-bit words
    4d64:	30 41       	ret			

00004d66 <.L61>:
  osalDbgCheck(uartp != NULL);
    4d66:	3c 40 7b af 	mov	#-20613,r12	;#0xaf7b
    4d6a:	b0 12 a6 44 	call	#17574		;#0x44a6

00004d6e <.LVL58>:
    4d6e:	ee 3f       	jmp	$-34     	;abs 0x4d4c

00004d70 <.L62>:
    size_t n = uart_lld_stop_receive(uartp);
    4d70:	0c 4a       	mov	r10,	r12	;
    4d72:	b0 12 54 5e 	call	#24148		;#0x5e54

00004d76 <.LVL59>:
    uartp->rxstate = UART_RX_IDLE;
    4d76:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00004d7a <.Loc.343.1>:
    return n;
    4d7a:	f3 3f       	jmp	$-24     	;abs 0x4d62

00004d7c <hal_lld_init>:
    4d7c:	b2 40 80 5a 	mov	#23168		;#0x5a80, Warning: disassembly unreliable - not enough bytes available

00004d80 <L0>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    4d80:	5c 01       	rram	#1,	r12	;

00004d82 <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    4d82:	b2 40 10 a5 	mov	#-23280,&0x0140	;#0xa510
    4d86:	40 01 

00004d88 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    4d88:	f2 43 41 01 	mov.b	#-1,	&0x0141	;r3 As==11

00004d8c <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    4d8c:	b2 40 00 a5 	mov	#-23296,&0x0160	;#0xa500
    4d90:	60 01 

00004d92 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    4d92:	b2 40 48 00 	mov	#72,	&0x0162	;#0x0048
    4d96:	62 01 

00004d98 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    4d98:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    4d9c:	64 01 

00004d9e <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    4d9e:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00004da2 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    4da2:	b2 40 c9 c1 	mov	#-15927,&0x0168	;#0xc1c9
    4da6:	68 01 

00004da8 <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    4da8:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    4dac:	6c 01 

00004dae <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    4dae:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00004db2 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    4db2:	b0 12 d0 4f 	call	#20432		;#0x4fd0

00004db6 <.LVL0>:
#endif
}
    4db6:	30 41       	ret			

00004db8 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    4db8:	bf 15       	pushm	#12,	r15	;16-bit words

00004dba <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    4dba:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004dbe <.LBB12>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    4dbe:	b0 12 14 45 	call	#17684		;#0x4514

00004dc2 <.LBE12>:
  
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();
  
  OSAL_IRQ_EPILOGUE();
    4dc2:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4dc6:	b0 12 7a 45 	call	#17786		;#0x457a

00004dca <.LVL1>:
    4dca:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4dcc:	02 20       	jnz	$+6      	;abs 0x4dd2

00004dce <.L1>:
}
    4dce:	b4 17       	popm	#12,	r15	;16-bit words
    4dd0:	00 13       	reti			

00004dd2 <.L3>:
  OSAL_IRQ_EPILOGUE();
    4dd2:	b0 12 92 45 	call	#17810		;#0x4592

00004dd6 <.LVL2>:
}
    4dd6:	fb 3f       	jmp	$-8      	;abs 0x4dce

00004dd8 <st_lld_init>:
    4dd8:	b2 40       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00004dda <L0>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    4dda:	7f 3e       	jmp	$-768    	;abs 0x4ada
    4ddc:	d2 03       	cmpa	r3,	r2	;

00004dde <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    4dde:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    4de2:	c2 03 

00004de4 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    4de4:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00004de8 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    4de8:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    4dec:	c0 03 

00004dee <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    4dee:	30 41       	ret			

00004df0 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    4df0:	bf 15       	pushm	#12,	r15	;16-bit words

00004df2 <.LCFI0>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4df2:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004df6 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    4df6:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    4dfa:	12 c3       	clrc			
    4dfc:	0c 10       	rrc	r12		;
    4dfe:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4e00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00004e04 <.LVL0>:
  cb = port_callback_map[0][pad];
    4e04:	0c 5c       	rla	r12		;

00004e06 <.LVL1>:
    4e06:	1c 4c f0 b4 	mov	-19216(r12),r12	;0xffffb4f0

00004e0a <.LVL2>:
  if (cb != NULL) {
    4e0a:	0c 93       	cmp	#0,	r12	;r3 As==00
    4e0c:	01 24       	jz	$+4      	;abs 0x4e10

00004e0e <.Loc.81.1>:
    (*cb)();
    4e0e:	8c 12       	call	r12		;

00004e10 <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4e10:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4e14:	b0 12 7a 45 	call	#17786		;#0x457a

00004e18 <.LVL4>:
    4e18:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4e1a:	02 20       	jnz	$+6      	;abs 0x4e20

00004e1c <.L1>:
}
    4e1c:	b4 17       	popm	#12,	r15	;16-bit words
    4e1e:	00 13       	reti			

00004e20 <.L4>:
  OSAL_IRQ_EPILOGUE();
    4e20:	b0 12 92 45 	call	#17810		;#0x4592

00004e24 <.LVL5>:
}
    4e24:	fb 3f       	jmp	$-8      	;abs 0x4e1c

00004e26 <ISR_PORT2_VECTOR>:
    4e26:	bf 15       	pushm	#12,	r15	;16-bit words

00004e28 <L0>:
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e28:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004e2c <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    4e2c:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    4e30:	12 c3       	clrc			
    4e32:	0c 10       	rrc	r12		;
    4e34:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4e36:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00004e3a <.LVL6>:
  cb = port_callback_map[1][pad];
    4e3a:	3c 52       	add	#8,	r12	;r2 As==11

00004e3c <.LVL7>:
    4e3c:	0c 5c       	rla	r12		;

00004e3e <.LVL8>:
    4e3e:	1c 4c f0 b4 	mov	-19216(r12),r12	;0xffffb4f0

00004e42 <.LVL9>:
  if (cb != NULL) {
    4e42:	0c 93       	cmp	#0,	r12	;r3 As==00
    4e44:	01 24       	jz	$+4      	;abs 0x4e48

00004e46 <.Loc.99.1>:
    (*cb)();
    4e46:	8c 12       	call	r12		;

00004e48 <.L6>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4e48:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4e4c:	b0 12 7a 45 	call	#17786		;#0x457a

00004e50 <.LVL11>:
    4e50:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4e52:	02 20       	jnz	$+6      	;abs 0x4e58

00004e54 <.L5>:
}
    4e54:	b4 17       	popm	#12,	r15	;16-bit words
    4e56:	00 13       	reti			

00004e58 <.L8>:
  OSAL_IRQ_EPILOGUE();
    4e58:	b0 12 92 45 	call	#17810		;#0x4592

00004e5c <.LVL12>:
}
    4e5c:	fb 3f       	jmp	$-8      	;abs 0x4e54

00004e5e <ISR_PORT3_VECTOR>:
    4e5e:	bf 15       	pushm	#12,	r15	;16-bit words

00004e60 <L0>:
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e60:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004e64 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    4e64:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    4e68:	12 c3       	clrc			
    4e6a:	0c 10       	rrc	r12		;
    4e6c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4e6e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00004e72 <.LVL13>:
  cb = port_callback_map[2][pad];
    4e72:	3c 50 10 00 	add	#16,	r12	;#0x0010

00004e76 <.LVL14>:
    4e76:	0c 5c       	rla	r12		;

00004e78 <.LVL15>:
    4e78:	1c 4c f0 b4 	mov	-19216(r12),r12	;0xffffb4f0

00004e7c <.LVL16>:
  if (cb != NULL) {
    4e7c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4e7e:	01 24       	jz	$+4      	;abs 0x4e82

00004e80 <.Loc.118.1>:
    (*cb)();
    4e80:	8c 12       	call	r12		;

00004e82 <.L10>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4e82:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4e86:	b0 12 7a 45 	call	#17786		;#0x457a

00004e8a <.LVL18>:
    4e8a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4e8c:	02 20       	jnz	$+6      	;abs 0x4e92

00004e8e <.L9>:
}
    4e8e:	b4 17       	popm	#12,	r15	;16-bit words
    4e90:	00 13       	reti			

00004e92 <.L12>:
  OSAL_IRQ_EPILOGUE();
    4e92:	b0 12 92 45 	call	#17810		;#0x4592

00004e96 <.LVL19>:
}
    4e96:	fb 3f       	jmp	$-8      	;abs 0x4e8e

00004e98 <ISR_PORT4_VECTOR>:
    4e98:	bf 15       	pushm	#12,	r15	;16-bit words

00004e9a <L0>:
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e9a:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004e9e <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    4e9e:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    4ea2:	12 c3       	clrc			
    4ea4:	0c 10       	rrc	r12		;
    4ea6:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4ea8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00004eac <.LVL20>:
  cb = port_callback_map[3][pad];
    4eac:	3c 50 18 00 	add	#24,	r12	;#0x0018

00004eb0 <.LVL21>:
    4eb0:	0c 5c       	rla	r12		;

00004eb2 <.LVL22>:
    4eb2:	1c 4c f0 b4 	mov	-19216(r12),r12	;0xffffb4f0

00004eb6 <.LVL23>:
  if (cb != NULL) {
    4eb6:	0c 93       	cmp	#0,	r12	;r3 As==00
    4eb8:	01 24       	jz	$+4      	;abs 0x4ebc

00004eba <.Loc.136.1>:
    (*cb)();
    4eba:	8c 12       	call	r12		;

00004ebc <.L14>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4ebc:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4ec0:	b0 12 7a 45 	call	#17786		;#0x457a

00004ec4 <.LVL25>:
    4ec4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4ec6:	02 20       	jnz	$+6      	;abs 0x4ecc

00004ec8 <.L13>:
}
    4ec8:	b4 17       	popm	#12,	r15	;16-bit words
    4eca:	00 13       	reti			

00004ecc <.L16>:
  OSAL_IRQ_EPILOGUE();
    4ecc:	b0 12 92 45 	call	#17810		;#0x4592

00004ed0 <.LVL26>:
}
    4ed0:	fb 3f       	jmp	$-8      	;abs 0x4ec8

00004ed2 <_pal_lld_init>:
    4ed2:	a2 4c       	mov	@r12		; Warning: disassembly unreliable - not enough bytes available

00004ed4 <L0>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    4ed4:	02 02       	mova	@r2,	r2	;

00004ed6 <.Loc.310.1>:
  PADIR = config->porta.dir;
    4ed6:	92 4c 02 00 	mov	2(r12),	&0x0204	;
    4eda:	04 02 

00004edc <.Loc.311.1>:
  PAREN = config->porta.ren;
    4edc:	92 4c 04 00 	mov	4(r12),	&0x0206	;
    4ee0:	06 02 

00004ee2 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    4ee2:	92 4c 06 00 	mov	6(r12),	&0x020a	;
    4ee6:	0a 02 

00004ee8 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    4ee8:	92 4c 08 00 	mov	8(r12),	&0x020c	;
    4eec:	0c 02 

00004eee <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    4eee:	92 4c 0a 00 	mov	10(r12),&0x0222	;0x0000a
    4ef2:	22 02 

00004ef4 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    4ef4:	92 4c 0c 00 	mov	12(r12),&0x0224	;0x0000c
    4ef8:	24 02 

00004efa <.Loc.317.1>:
  PBREN = config->portb.ren;
    4efa:	92 4c 0e 00 	mov	14(r12),&0x0226	;0x0000e
    4efe:	26 02 

00004f00 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    4f00:	92 4c 10 00 	mov	16(r12),&0x022a	;0x00010
    4f04:	2a 02 

00004f06 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    4f06:	92 4c 12 00 	mov	18(r12),&0x022c	;0x00012
    4f0a:	2c 02 

00004f0c <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    4f0c:	92 4c 14 00 	mov	20(r12),&0x0322	;0x00014
    4f10:	22 03 

00004f12 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    4f12:	92 4c 16 00 	mov	22(r12),&0x0324	;0x00016
    4f16:	24 03 

00004f18 <.Loc.351.1>:
  PJREN = config->portj.ren;
    4f18:	92 4c 18 00 	mov	24(r12),&0x0326	;0x00018
    4f1c:	26 03 

00004f1e <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    4f1e:	92 4c 1a 00 	mov	26(r12),&0x032a	;0x0001a
    4f22:	2a 03 

00004f24 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    4f24:	92 4c 1c 00 	mov	28(r12),&0x032c	;0x0001c
    4f28:	2c 03 

00004f2a <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    4f2a:	92 c3 30 01 	bic	#1,	&0x0130	;r3 As==01

00004f2e <.Loc.356.1>:
}
    4f2e:	30 41       	ret			

00004f30 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    4f30:	3a 15       	pushm	#4,	r10	;16-bit words

00004f32 <.LCFI0>:
    4f32:	4a 4c       	mov.b	r12,	r10	;
    4f34:	47 4d       	mov.b	r13,	r7	;

00004f36 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    4f36:	09 4a       	mov	r10,	r9	;
    4f38:	79 f0 fe 00 	and.b	#254,	r9	;#0x00fe
    4f3c:	39 50 00 05 	add	#1280,	r9	;#0x0500

00004f40 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    4f40:	5a f3       	and.b	#1,	r10	;r3 As==01
    4f42:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    4f46:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00004f4a <.LVL2>:
    4f4a:	0d 4a       	mov	r10,	r13	;

00004f4c <.LVL3>:
    4f4c:	b0 12 e2 ac 	call	#-21278	;#0xace2
    4f50:	08 4c       	mov	r12,	r8	;
    4f52:	28 f9       	and	@r9,	r8	;

00004f54 <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    4f54:	0c 47       	mov	r7,	r12	;
    4f56:	0d 4a       	mov	r10,	r13	;
    4f58:	b0 12 4e ac 	call	#-21426	;#0xac4e
    4f5c:	08 dc       	bis	r12,	r8	;
    4f5e:	89 48 00 00 	mov	r8,	0(r9)	;

00004f62 <.Loc.65.1>:
}
    4f62:	37 17       	popm	#4,	r10	;16-bit words
    4f64:	30 41       	ret			

00004f66 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    4f66:	bf 15       	pushm	#12,	r15	;16-bit words

00004f68 <.LCFI1>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    4f68:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00004f6c <.Loc.75.1>:

  index = (DMAIV >> 1) - 1;
    4f6c:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    4f70:	12 c3       	clrc			
    4f72:	0c 10       	rrc	r12		;
    4f74:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4f76:	4a 4c       	mov.b	r12,	r10	;

00004f78 <.LVL6>:

  if (index < MSP430X_DMA_CHANNELS) {
    4f78:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4f7a:	4d 9c       	cmp.b	r12,	r13	;
    4f7c:	08 2c       	jc	$+18     	;abs 0x4f8e

00004f7e <.L3>:
    if (cb->callback != NULL) {
      cb->callback(cb->args);
    }
  }

  OSAL_IRQ_EPILOGUE();
    4f7e:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    4f82:	b0 12 7a 45 	call	#17786		;#0x457a

00004f86 <.LVL8>:
    4f86:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4f88:	20 20       	jnz	$+66     	;abs 0x4fca

00004f8a <.L2>:
}
    4f8a:	b4 17       	popm	#12,	r15	;16-bit words
    4f8c:	00 13       	reti			

00004f8e <.L5>:
    dma_regs[index].ctl &= ~DMAEN;
    4f8e:	09 4a       	mov	r10,	r9	;
    4f90:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    4f94:	39 50 10 05 	add	#1296,	r9	;#0x0510
    4f98:	b9 f0 ef ff 	and	#-17,	0(r9)	;#0xffef
    4f9c:	00 00 

00004f9e <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    4f9e:	4d 43       	clr.b	r13		;
    4fa0:	b0 12 30 4f 	call	#20272		;#0x4f30

00004fa4 <.LVL10>:
    dma_regs[index].sz  = 0;
    4fa4:	89 43 0a 00 	mov	#0,	10(r9)	;r3 As==00, 0x000a

00004fa8 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    4fa8:	b9 40 12 00 	mov	#18,	0(r9)	;#0x0012
    4fac:	00 00 

00004fae <.LVL11>:
    if (cb->callback != NULL) {
    4fae:	0c 4a       	mov	r10,	r12	;
    4fb0:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    4fb4:	1d 4c 32 b5 	mov	-19150(r12),r13	;0xffffb532
    4fb8:	0d 93       	cmp	#0,	r13	;r3 As==00
    4fba:	e1 27       	jz	$-60     	;abs 0x4f7e

00004fbc <.Loc.88.1>:
      cb->callback(cb->args);
    4fbc:	0a 4c       	mov	r12,	r10	;

00004fbe <.LVL12>:
    4fbe:	3a 50 32 b5 	add	#-19150,r10	;#0xb532

00004fc2 <.LVL13>:
    4fc2:	1c 4a 02 00 	mov	2(r10),	r12	;
    4fc6:	8d 12       	call	r13		;
    4fc8:	da 3f       	jmp	$-74     	;abs 0x4f7e

00004fca <.L6>:
  OSAL_IRQ_EPILOGUE();
    4fca:	b0 12 92 45 	call	#17810		;#0x4592

00004fce <.LVL16>:
}
    4fce:	dd 3f       	jmp	$-68     	;abs 0x4f8a

00004fd0 <dmaInit>:
    4fd0:	82 43 30 b5 	mov	#0,	&0xb530	;r3 As==00

00004fd4 <L0>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    4fd4:	30 41       	ret			

00004fd6 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    4fd6:	2a 15       	pushm	#3,	r10	;16-bit words

00004fd8 <.LCFI2>:
    4fd8:	09 4c       	mov	r12,	r9	;

00004fda <.LVL20>:
  
  osalDbgCheckClassI();

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    4fda:	4a 43       	clr.b	r10		;

00004fdc <.L9>:
    4fdc:	6c 43       	mov.b	#2,	r12	;r3 As==10
    4fde:	0c 9a       	cmp	r10,	r12	;
    4fe0:	09 38       	jl	$+20     	;abs 0x4ff4

00004fe2 <.Loc.193.1>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    4fe2:	0c 4a       	mov	r10,	r12	;
    4fe4:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    4fe8:	bc b0 10 00 	bit	#16,	1296(r12);#0x0010, 0x0510
    4fec:	10 05 
    4fee:	02 24       	jz	$+6      	;abs 0x4ff4

00004ff0 <.Loc.192.1>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    4ff0:	1a 53       	inc	r10		;
    4ff2:	f4 3f       	jmp	$-22     	;abs 0x4fdc

00004ff4 <.L10>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    4ff4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    4ff6:	0c 9a       	cmp	r10,	r12	;
    4ff8:	15 38       	jl	$+44     	;abs 0x5024

00004ffa <.Loc.203.1>:
    return MSG_TIMEOUT;
  }
  
  /* Acquire the channel in an idle mode */
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    4ffa:	48 4a       	mov.b	r10,	r8	;
    4ffc:	4d 43       	clr.b	r13		;
    4ffe:	4c 48       	mov.b	r8,	r12	;
    5000:	b0 12 30 4f 	call	#20272		;#0x4f30

00005004 <.LVL23>:
  dma_regs[i].sz  = 0;
    5004:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;

00005008 <.LVL24>:
    5008:	3a 50 10 05 	add	#1296,	r10	;#0x0510
    500c:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

00005010 <.Loc.205.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    5010:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    5014:	00 00 

00005016 <.Loc.207.1>:

  channel->registers = dma_regs + i;
    5016:	89 4a 00 00 	mov	r10,	0(r9)	;

0000501a <.Loc.208.1>:
  channel->index     = i;
    501a:	c9 48 02 00 	mov.b	r8,	2(r9)	;

0000501e <.Loc.210.1>:
  
  return MSG_OK;
    501e:	4c 43       	clr.b	r12		;

00005020 <.L8>:
}
    5020:	28 17       	popm	#3,	r10	;16-bit words
    5022:	30 41       	ret			

00005024 <.L13>:
    return MSG_TIMEOUT;
    5024:	3c 43       	mov	#-1,	r12	;r3 As==11
    5026:	fc 3f       	jmp	$-6      	;abs 0x5020

00005028 <dmaClaimI>:
    5028:	2a 15       	pushm	#3,	r10	;16-bit words

0000502a <.LCFI4>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    502a:	08 4c       	mov	r12,	r8	;

0000502c <L0>:
    502c:	49 4d       	mov.b	r13,	r9	;

0000502e <.Loc.232.1>:
  
  osalDbgCheckClassI();

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    502e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005030 <.LVL34>:
    5030:	4c 99       	cmp.b	r9,	r12	;
    5032:	19 28       	jnc	$+52     	;abs 0x5066

00005034 <.L18>:
  if (dma_regs[index].ctl & DMAEN) {
    5034:	0a 49       	mov	r9,	r10	;
    5036:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    503a:	3a 50 10 05 	add	#1296,	r10	;#0x0510
    503e:	ba b0 10 00 	bit	#16,	0(r10)	;#0x0010
    5042:	00 00 
    5044:	15 20       	jnz	$+44     	;abs 0x5070

00005046 <.Loc.238.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5046:	4d 43       	clr.b	r13		;
    5048:	4c 49       	mov.b	r9,	r12	;
    504a:	b0 12 30 4f 	call	#20272		;#0x4f30

0000504e <.LVL36>:
  dma_regs[index].sz  = 0;
    504e:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

00005052 <.Loc.240.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    5052:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    5056:	00 00 

00005058 <.Loc.242.1>:

  channel->registers = dma_regs + index;
    5058:	88 4a 00 00 	mov	r10,	0(r8)	;

0000505c <.Loc.243.1>:
  channel->index     = index;
    505c:	c8 49 02 00 	mov.b	r9,	2(r8)	;

00005060 <.Loc.245.1>:
  
  return MSG_OK;
    5060:	4c 43       	clr.b	r12		;

00005062 <.L17>:
}
    5062:	28 17       	popm	#3,	r10	;16-bit words
    5064:	30 41       	ret			

00005066 <.L21>:
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    5066:	3c 40 ce af 	mov	#-20530,r12	;#0xafce
    506a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000506e <.LVL38>:
    506e:	e2 3f       	jmp	$-58     	;abs 0x5034

00005070 <.L20>:
    return MSG_TIMEOUT;
    5070:	3c 43       	mov	#-1,	r12	;r3 As==11
    5072:	f7 3f       	jmp	$-16     	;abs 0x5062

00005074 <dmaTransferI>:
    5074:	1a 15       	pushm	#2,	r10	;16-bit words

00005076 <.LCFI5>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5076:	09 4c       	mov	r12,	r9	;

00005078 <L0>:
    5078:	0a 4d       	mov	r13,	r10	;

0000507a <.Loc.277.1>:

  osalDbgCheckClassI();

  channel->registers->ctl &= (~DMAEN);
    507a:	2c 4c       	mov	@r12,	r12	;

0000507c <.LVL40>:
    507c:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5080:	00 00 

00005082 <.Loc.278.1>:
  dma_trigger_set(channel->index, request->trigger);
    5082:	5d 4d 0c 00 	mov.b	12(r13),r13	;0x0000c

00005086 <.LVL41>:
    5086:	5c 49 02 00 	mov.b	2(r9),	r12	;
    508a:	b0 12 30 4f 	call	#20272		;#0x4f30

0000508e <.LVL42>:
  callbacks[channel->index] = request->callback;
    508e:	5c 49 02 00 	mov.b	2(r9),	r12	;
    5092:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    5096:	9c 4a 0e 00 	mov	14(r10),-19150(r12);0x0000e, 0xb532
    509a:	32 b5 
    509c:	9c 4a 10 00 	mov	16(r10),-19148(r12);0x00010, 0xb534
    50a0:	34 b5 

000050a2 <.Loc.281.1>:

  channel->registers->sa  = (uintptr_t)request->source_addr;
    50a2:	2c 49       	mov	@r9,	r12	;
    50a4:	2d 4a       	mov	@r10,	r13	;
    50a6:	0e 4d       	mov	r13,	r14	;
    50a8:	0f 43       	clr	r15		;
    50aa:	8c 4e 02 00 	mov	r14,	2(r12)	;
    50ae:	8c 4f 04 00 	mov	r15,	4(r12)	;

000050b2 <.Loc.282.1>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    50b2:	2c 49       	mov	@r9,	r12	;
    50b4:	1d 4a 02 00 	mov	2(r10),	r13	;
    50b8:	0e 4d       	mov	r13,	r14	;
    50ba:	0f 43       	clr	r15		;
    50bc:	8c 4e 06 00 	mov	r14,	6(r12)	;
    50c0:	8c 4f 08 00 	mov	r15,	8(r12)	;

000050c4 <.Loc.283.1>:
  channel->registers->sz  = request->size;
    50c4:	2c 49       	mov	@r9,	r12	;
    50c6:	9c 4a 04 00 	mov	4(r10),	10(r12)	; 0x000a
    50ca:	0a 00 

000050cc <.Loc.284.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    50cc:	2d 49       	mov	@r9,	r13	;
    50ce:	1c 4a 08 00 	mov	8(r10),	r12	;
    50d2:	1c da 06 00 	bis	6(r10),	r12	;
    50d6:	1c da 0a 00 	bis	10(r10),r12	;0x0000a
    50da:	3c d0 15 00 	bis	#21,	r12	;#0x0015
    50de:	8d 4c 00 00 	mov	r12,	0(r13)	;

000050e2 <.Loc.287.1>:
                            request->transfer_mode | DMAEN |
                            DMAREQ;
}
    50e2:	19 17       	popm	#2,	r10	;16-bit words
    50e4:	30 41       	ret			

000050e6 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    50e6:	1a 15       	pushm	#2,	r10	;16-bit words

000050e8 <.LCFI6>:
    50e8:	0a 4c       	mov	r12,	r10	;

000050ea <.LBB33>:
  return chSysGetStatusAndLockX();
    50ea:	b0 12 b0 44 	call	#17584		;#0x44b0

000050ee <.LVL46>:
    50ee:	09 4c       	mov	r12,	r9	;

000050f0 <.LBE33>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
    50f0:	0a 93       	cmp	#0,	r10	;r3 As==00
    50f2:	0e 24       	jz	$+30     	;abs 0x5110

000050f4 <.L25>:
  
  if (dmaIsClaimed(channel)) {
    50f4:	0a 93       	cmp	#0,	r10	;r3 As==00
    50f6:	07 24       	jz	$+16     	;abs 0x5106

000050f8 <.Loc.304.1>:
    50f8:	2c 4a       	mov	@r10,	r12	;
    50fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    50fc:	04 24       	jz	$+10     	;abs 0x5106

000050fe <.Loc.304.1>:
    50fe:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5102:	00 00 
    5104:	0a 20       	jnz	$+22     	;abs 0x511a

00005106 <.L26>:
  chSysRestoreStatusX(sts);
    5106:	0c 49       	mov	r9,	r12	;
    5108:	b0 12 b8 45 	call	#17848		;#0x45b8

0000510c <.LBE35>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    510c:	19 17       	popm	#2,	r10	;16-bit words
    510e:	30 41       	ret			

00005110 <.L27>:
  osalDbgCheck(channel != NULL);
    5110:	3c 40 c2 af 	mov	#-20542,r12	;#0xafc2
    5114:	b0 12 a6 44 	call	#17574		;#0x44a6

00005118 <.LVL49>:
    5118:	ed 3f       	jmp	$-36     	;abs 0x50f4

0000511a <.L28>:
    channel->registers->ctl = DMAABORT;
    511a:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

0000511e <.Loc.310.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    511e:	4d 43       	clr.b	r13		;
    5120:	3c 40 30 b5 	mov	#-19152,r12	;#0xb530
    5124:	b0 12 92 4a 	call	#19090		;#0x4a92

00005128 <.LVL50>:
    5128:	ee 3f       	jmp	$-34     	;abs 0x5106

0000512a <dmaCancelI>:
    512a:	0a 15       	pushm	#1,	r10	;16-bit words

0000512c <.LCFI7>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    512c:	0a 4c       	mov	r12,	r10	;

0000512e <L0>:
  
  osalDbgCheckClassI();
  osalDbgCheck(channel != NULL);
    512e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5130:	07 24       	jz	$+16     	;abs 0x5140

00005132 <.L30>:
  
  if (!(channel->registers->ctl & DMAEN)) {
    5132:	2c 4a       	mov	@r10,	r12	;
    5134:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5138:	00 00 
    513a:	07 20       	jnz	$+16     	;abs 0x514a

0000513c <.L29>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
  channel->registers->sz  = 0;
  channel->registers->ctl = DMAEN | DMAABORT;
}
    513c:	0a 17       	popm	#1,	r10	;16-bit words
    513e:	30 41       	ret			

00005140 <.L32>:
  osalDbgCheck(channel != NULL);
    5140:	3c 40 b7 af 	mov	#-20553,r12	;#0xafb7
    5144:	b0 12 a6 44 	call	#17574		;#0x44a6

00005148 <.LVL53>:
    5148:	f4 3f       	jmp	$-22     	;abs 0x5132

0000514a <.L33>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    514a:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    514e:	00 00 

00005150 <.Loc.336.1>:
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    5150:	4d 43       	clr.b	r13		;
    5152:	5c 4a 02 00 	mov.b	2(r10),	r12	;
    5156:	b0 12 30 4f 	call	#20272		;#0x4f30

0000515a <.LVL54>:
  channel->registers->sz  = 0;
    515a:	2c 4a       	mov	@r10,	r12	;
    515c:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005160 <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    5160:	2c 4a       	mov	@r10,	r12	;
    5162:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5166:	00 00 
    5168:	e9 3f       	jmp	$-44     	;abs 0x513c

0000516a <spi_lld_init>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    516a:	30 41       	ret			

0000516c <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    516c:	1c 4c       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

0000516e <L0>:
    516e:	0a 00       	mova	@r0,	r10	;

00005170 <.LVL2>:
    5170:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

00005174 <.Loc.82.1>:
}
    5174:	30 41       	ret			

00005176 <i2c_lld_init>:
 * @notapi
 */
void i2c_lld_init(void) {

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5176:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    517a:	b0 12 e4 4b 	call	#19428		;#0x4be4

0000517e <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    517e:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5182:	bc 40 40 06 	mov	#1600,	10(r12)	;#0x0640, 0x000a
    5186:	0a 00 

00005188 <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5188:	bc 40 c0 00 	mov	#192,	20(r12)	;#0x00c0, 0x0014
    518c:	14 00 

0000518e <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    518e:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016

00005192 <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    5192:	fc 40 13 00 	mov.b	#19,	32(r12)	;#0x0013, 0x0020
    5196:	20 00 

00005198 <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    5198:	fc 40 12 00 	mov.b	#18,	33(r12)	;#0x0012, 0x0021
    519c:	21 00 

0000519e <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    519e:	8c 43 1a 00 	mov	#0,	26(r12)	;r3 As==00, 0x001a

000051a2 <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    51a2:	8c 4c 1c 00 	mov	r12,	28(r12)	; 0x001c

000051a6 <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    51a6:	30 41       	ret			

000051a8 <i2c_lld_start>:
 */
void i2c_lld_start(I2CDriver *i2cp) {

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    51a8:	3c 90 3e b5 	cmp	#-19138,r12	;#0xb53e
    51ac:	01 24       	jz	$+4      	;abs 0x51b0

000051ae <.L4>:
      }
  #endif
    }
#endif

}
    51ae:	30 41       	ret			

000051b0 <.L6>:
      UCB0CTLW0 |= 0x01;
    51b0:	92 d3 40 06 	bis	#1,	&0x0640	;r3 As==01

000051b4 <.Loc.483.1>:
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    51b4:	1c 42 40 b5 	mov	&0xb540,r12	;0xb540

000051b8 <.LVL10>:
    51b8:	2e 4c       	mov	@r12,	r14	;
    51ba:	1f 4c 02 00 	mov	2(r12),	r15	;
    51be:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    51c2:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    51c6:	b0 12 1c ac 	call	#-21476	;#0xac1c
    51ca:	82 4c 46 06 	mov	r12,	&0x0646	;

000051ce <.Loc.485.1>:
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    51ce:	b2 40 c0 00 	mov	#192,	&0x0642	;#0x00c0
    51d2:	42 06 

000051d4 <.Loc.490.1>:
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    51d4:	b2 40 80 0f 	mov	#3968,	&0x0640	;#0x0f80
    51d8:	40 06 

000051da <.Loc.492.1>:
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    51da:	b2 40 b8 00 	mov	#184,	&0x066a	;#0x00b8
    51de:	6a 06 

000051e0 <.Loc.493.1>:
      UCB0IFG = 0;
    51e0:	82 43 6c 06 	mov	#0,	&0x066c	;r3 As==00

000051e4 <.Loc.582.1>:
}
    51e4:	e4 3f       	jmp	$-54     	;abs 0x51ae

000051e6 <i2cMSP430XStartReceiveToRegI>:
    51e6:	3a 15       	pushm	#4,	r10	;16-bit words

000051e8 <L0>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    51e8:	0a 4c       	mov	r12,	r10	;
    51ea:	47 4d       	mov.b	r13,	r7	;
    51ec:	09 4e       	mov	r14,	r9	;
    51ee:	08 4f       	mov	r15,	r8	;

000051f0 <.Loc.661.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    51f0:	0e 93       	cmp	#0,	r14	;r3 As==00
    51f2:	48 24       	jz	$+146    	;abs 0x5284

000051f4 <.L13>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    51f4:	47 93       	cmp.b	#0,	r7	;r3 As==00
    51f6:	4b 38       	jl	$+152    	;abs 0x528e

000051f8 <.L14>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    51f8:	8a 43 04 00 	mov	#0,	4(r10)	;r3 As==00

000051fc <.Loc.671.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    51fc:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005200 <.Loc.673.1>:
  
  i2cp->buffer = regp;
    5200:	8a 48 06 00 	mov	r8,	6(r10)	;

00005204 <.Loc.676.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5204:	19 93       	cmp	#1,	r9	;r3 As==01
    5206:	48 24       	jz	$+146    	;abs 0x5298

00005208 <.Loc.693.1>:
    if (callback != NULL)
      callback(i2cp, regp, 1);
  }
  else {
    /* Set up DMA */
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5208:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    520c:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    5210:	8a 4c 0c 00 	mov	r12,	12(r10)	; 0x000c

00005214 <.Loc.694.1>:
    i2cp->req.dest_addr = regp;
    5214:	8a 48 0e 00 	mov	r8,	14(r10)	; 0x000e

00005218 <.Loc.695.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5218:	39 53       	add	#-1,	r9	;r3 As==11

0000521a <.LVL18>:
    521a:	8a 49 10 00 	mov	r9,	16(r10)	; 0x0010

0000521e <.Loc.696.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    521e:	8a 43 12 00 	mov	#0,	18(r10)	;r3 As==00, 0x0012

00005222 <.Loc.697.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5222:	5f 4a 21 00 	mov.b	33(r10),r15	;0x00021
    5226:	8a 4f 18 00 	mov	r15,	24(r10)	; 0x0018

0000522a <.Loc.699.1>:
    /* Custom callback */
    i2cp->callback = callback;
    522a:	9a 41 0a 00 	mov	10(r1),	8(r10)	;0x0000a
    522e:	08 00 

00005230 <.Loc.701.1>:
    /* DMA callback handler */
    i2cp->req.callback.callback = &rx_async_callback;
    5230:	ba 40 26 56 	mov	#22054,	26(r10)	;#0x5626, 0x001a
    5234:	1a 00 

00005236 <.Loc.702.1>:
    i2cp->req.callback.args = i2cp;
    5236:	8a 4a 1c 00 	mov	r10,	28(r10)	; 0x001c

0000523a <.Loc.704.1>:
    
    if (!dmaIsClaimed(&(i2cp->dma))) {
    523a:	09 4a       	mov	r10,	r9	;

0000523c <.LVL19>:
    523c:	39 50 22 00 	add	#34,	r9	;#0x0022

00005240 <.LVL20>:
    5240:	09 93       	cmp	#0,	r9	;r3 As==00
    5242:	08 24       	jz	$+18     	;abs 0x5254

00005244 <.Loc.704.1>:
    5244:	1c 4a 22 00 	mov	34(r10),r12	;0x00022
    5248:	0c 93       	cmp	#0,	r12	;r3 As==00
    524a:	04 24       	jz	$+10     	;abs 0x5254

0000524c <.Loc.704.1>:
    524c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5250:	00 00 
    5252:	03 20       	jnz	$+8      	;abs 0x525a

00005254 <.L18>:
      dmaAcquireI(&(i2cp->dma));
    5254:	0c 49       	mov	r9,	r12	;
    5256:	b0 12 d6 4f 	call	#20438		;#0x4fd6

0000525a <.L19>:
    }
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    525a:	0d 4a       	mov	r10,	r13	;
    525c:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    5260:	0c 49       	mov	r9,	r12	;
    5262:	b0 12 74 50 	call	#20596		;#0x5074

00005266 <.LVL22>:
    
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    5266:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    526a:	8c 47 20 00 	mov	r7,	32(r12)	; 0x0020

0000526e <.Loc.711.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    526e:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5272:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5276:	00 00 

00005278 <.Loc.712.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5278:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    527c:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005280 <.L12>:
  }
}
    5280:	37 17       	popm	#4,	r10	;16-bit words
    5282:	30 41       	ret			

00005284 <.L20>:
  osalDbgAssert(n > 0, "can't receive no bytes");
    5284:	3c 40 61 b0 	mov	#-20383,r12	;#0xb061
    5288:	b0 12 a6 44 	call	#17574		;#0x44a6

0000528c <.LVL24>:
    528c:	b3 3f       	jmp	$-152    	;abs 0x51f4

0000528e <.L21>:
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    528e:	3c 40 61 b0 	mov	#-20383,r12	;#0xb061
    5292:	b0 12 a6 44 	call	#17574		;#0x44a6

00005296 <.LVL25>:
    5296:	b0 3f       	jmp	$-158    	;abs 0x51f8

00005298 <.L22>:
    i2cp->req.dest_addr = regp;
    5298:	8a 48 0e 00 	mov	r8,	14(r10)	; 0x000e

0000529c <.Loc.679.1>:
    i2cp->req.size = 0;
    529c:	8a 43 10 00 	mov	#0,	16(r10)	;r3 As==00, 0x0010

000052a0 <.Loc.681.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    52a0:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    52a4:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    52a8:	00 00 

000052aa <.Loc.683.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    52aa:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    52ae:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000052b2 <.L16>:
    while (i2cp->regs->ctlw0 & UCTXSTT);
    52b2:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    52b6:	2d 4c       	mov	@r12,	r13	;
    52b8:	2d b3       	bit	#2,	r13	;r3 As==10
    52ba:	fb 23       	jnz	$-8      	;abs 0x52b2

000052bc <.Loc.686.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    52bc:	2d d2       	bis	#4,	r13	;r2 As==10
    52be:	8c 4d 00 00 	mov	r13,	0(r12)	;

000052c2 <.Loc.688.1>:
    if (callback != NULL)
    52c2:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    52c6:	dc 27       	jz	$-70     	;abs 0x5280

000052c8 <.Loc.689.1>:
      callback(i2cp, regp, 1);
    52c8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    52ca:	0d 48       	mov	r8,	r13	;
    52cc:	0c 4a       	mov	r10,	r12	;
    52ce:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    52d2:	8f 12       	call	r15		;

000052d4 <.LVL26>:
    52d4:	d5 3f       	jmp	$-84     	;abs 0x5280

000052d6 <i2cMSP430XStartReceiveI>:
    52d6:	3a 15       	pushm	#4,	r10	;16-bit words

000052d8 <.LCFI2>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    52d8:	0a 4c       	mov	r12,	r10	;
    52da:	47 4d       	mov.b	r13,	r7	;

000052dc <L0>:
    52dc:	09 4e       	mov	r14,	r9	;
    52de:	08 4f       	mov	r15,	r8	;

000052e0 <.Loc.721.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    52e0:	0e 93       	cmp	#0,	r14	;r3 As==00
    52e2:	49 24       	jz	$+148    	;abs 0x5376

000052e4 <.L24>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    52e4:	47 93       	cmp.b	#0,	r7	;r3 As==00
    52e6:	4c 38       	jl	$+154    	;abs 0x5380

000052e8 <.L25>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    52e8:	8a 43 04 00 	mov	#0,	4(r10)	;r3 As==00

000052ec <.Loc.731.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    52ec:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

000052f0 <.Loc.733.1>:
  
  i2cp->buffer = rxbuf;
    52f0:	8a 48 06 00 	mov	r8,	6(r10)	;

000052f4 <.Loc.736.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    52f4:	19 93       	cmp	#1,	r9	;r3 As==01
    52f6:	49 24       	jz	$+148    	;abs 0x538a

000052f8 <.Loc.753.1>:
    if (callback != NULL)
      callback(i2cp, rxbuf, 1);
  }
  else {
    /* Set up DMA */
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    52f8:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    52fc:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    5300:	8a 4c 0c 00 	mov	r12,	12(r10)	; 0x000c

00005304 <.Loc.754.1>:
    i2cp->req.dest_addr = rxbuf;
    5304:	8a 48 0e 00 	mov	r8,	14(r10)	; 0x000e

00005308 <.Loc.755.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5308:	39 53       	add	#-1,	r9	;r3 As==11

0000530a <.LVL29>:
    530a:	8a 49 10 00 	mov	r9,	16(r10)	; 0x0010

0000530e <.Loc.756.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    530e:	ba 40 00 0c 	mov	#3072,	18(r10)	;#0x0c00, 0x0012
    5312:	12 00 

00005314 <.Loc.757.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5314:	5f 4a 21 00 	mov.b	33(r10),r15	;0x00021
    5318:	8a 4f 18 00 	mov	r15,	24(r10)	; 0x0018

0000531c <.Loc.759.1>:
    /* Custom callback */
    i2cp->callback = callback;
    531c:	9a 41 0a 00 	mov	10(r1),	8(r10)	;0x0000a
    5320:	08 00 

00005322 <.Loc.761.1>:
    /* DMA callback handler */
    i2cp->req.callback.callback = &rx_async_callback;
    5322:	ba 40 26 56 	mov	#22054,	26(r10)	;#0x5626, 0x001a
    5326:	1a 00 

00005328 <.Loc.762.1>:
    i2cp->req.callback.args = i2cp;
    5328:	8a 4a 1c 00 	mov	r10,	28(r10)	; 0x001c

0000532c <.Loc.764.1>:
    
    if (!dmaIsClaimed(&(i2cp->dma))) {
    532c:	09 4a       	mov	r10,	r9	;

0000532e <.LVL30>:
    532e:	39 50 22 00 	add	#34,	r9	;#0x0022

00005332 <.LVL31>:
    5332:	09 93       	cmp	#0,	r9	;r3 As==00
    5334:	08 24       	jz	$+18     	;abs 0x5346

00005336 <.Loc.764.1>:
    5336:	1c 4a 22 00 	mov	34(r10),r12	;0x00022
    533a:	0c 93       	cmp	#0,	r12	;r3 As==00
    533c:	04 24       	jz	$+10     	;abs 0x5346

0000533e <.Loc.764.1>:
    533e:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5342:	00 00 
    5344:	03 20       	jnz	$+8      	;abs 0x534c

00005346 <.L29>:
      dmaAcquireI(&(i2cp->dma));
    5346:	0c 49       	mov	r9,	r12	;
    5348:	b0 12 d6 4f 	call	#20438		;#0x4fd6

0000534c <.L30>:
    }
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    534c:	0d 4a       	mov	r10,	r13	;
    534e:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    5352:	0c 49       	mov	r9,	r12	;
    5354:	b0 12 74 50 	call	#20596		;#0x5074

00005358 <.LVL33>:
    
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    5358:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    535c:	8c 47 20 00 	mov	r7,	32(r12)	; 0x0020

00005360 <.Loc.771.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5360:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5364:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5368:	00 00 

0000536a <.Loc.772.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    536a:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    536e:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005372 <.L23>:
  }
}
    5372:	37 17       	popm	#4,	r10	;16-bit words
    5374:	30 41       	ret			

00005376 <.L31>:
  osalDbgAssert(n > 0, "can't receive no bytes");
    5376:	3c 40 49 b0 	mov	#-20407,r12	;#0xb049
    537a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000537e <.LVL35>:
    537e:	b2 3f       	jmp	$-154    	;abs 0x52e4

00005380 <.L32>:
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5380:	3c 40 49 b0 	mov	#-20407,r12	;#0xb049
    5384:	b0 12 a6 44 	call	#17574		;#0x44a6

00005388 <.LVL36>:
    5388:	af 3f       	jmp	$-160    	;abs 0x52e8

0000538a <.L33>:
    i2cp->req.dest_addr = rxbuf;
    538a:	8a 48 0e 00 	mov	r8,	14(r10)	; 0x000e

0000538e <.Loc.739.1>:
    i2cp->req.size = 0;
    538e:	8a 43 10 00 	mov	#0,	16(r10)	;r3 As==00, 0x0010

00005392 <.Loc.741.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5392:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5396:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    539a:	00 00 

0000539c <.Loc.743.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    539c:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    53a0:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000053a4 <.L27>:
    while (i2cp->regs->ctlw0 & UCTXSTT);
    53a4:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    53a8:	2d 4c       	mov	@r12,	r13	;
    53aa:	2d b3       	bit	#2,	r13	;r3 As==10
    53ac:	fb 23       	jnz	$-8      	;abs 0x53a4

000053ae <.Loc.746.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    53ae:	2d d2       	bis	#4,	r13	;r2 As==10
    53b0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000053b4 <.Loc.748.1>:
    if (callback != NULL)
    53b4:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    53b8:	dc 27       	jz	$-70     	;abs 0x5372

000053ba <.Loc.749.1>:
      callback(i2cp, rxbuf, 1);
    53ba:	5e 43       	mov.b	#1,	r14	;r3 As==01
    53bc:	0d 48       	mov	r8,	r13	;
    53be:	0c 4a       	mov	r10,	r12	;
    53c0:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    53c4:	8f 12       	call	r15		;

000053c6 <.LVL37>:
    53c6:	d5 3f       	jmp	$-84     	;abs 0x5372

000053c8 <i2cMSP430XStartTransmitMSBI>:
    53c8:	3a 15       	pushm	#4,	r10	;16-bit words

000053ca <.LCFI3>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    53ca:	0a 4c       	mov	r12,	r10	;
    53cc:	48 4d       	mov.b	r13,	r8	;

000053ce <L0>:
    53ce:	09 4e       	mov	r14,	r9	;
    53d0:	07 4f       	mov	r15,	r7	;

000053d2 <.Loc.781.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    53d2:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    53d6:	04 24       	jz	$+10     	;abs 0x53e0

000053d8 <.Loc.781.1>:
    53d8:	3c 40 2d b0 	mov	#-20435,r12	;#0xb02d

000053dc <.LVL39>:
    53dc:	b0 12 a6 44 	call	#17574		;#0x44a6

000053e0 <.L35>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    53e0:	09 93       	cmp	#0,	r9	;r3 As==00
    53e2:	44 24       	jz	$+138    	;abs 0x546c

000053e4 <.L36>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    53e4:	48 93       	cmp.b	#0,	r8	;r3 As==00
    53e6:	47 38       	jl	$+144    	;abs 0x5476

000053e8 <.L37>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    53e8:	8a 43 04 00 	mov	#0,	4(r10)	;r3 As==00

000053ec <.Loc.794.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    53ec:	fa 40 03 00 	mov.b	#3,	0(r10)	;
    53f0:	00 00 

000053f2 <.Loc.796.1>:
  
  i2cp->buffer = txbuf;
    53f2:	8a 47 06 00 	mov	r7,	6(r10)	;

000053f6 <.Loc.799.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    53f6:	0c 49       	mov	r9,	r12	;
    53f8:	3c 53       	add	#-1,	r12	;r3 As==11
    53fa:	07 5c       	add	r12,	r7	;

000053fc <.LVL41>:
    53fc:	8a 47 0c 00 	mov	r7,	12(r10)	; 0x000c

00005400 <.Loc.800.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5400:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5404:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    5408:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000540c <.Loc.801.1>:
  i2cp->req.size = n;
    540c:	8a 49 10 00 	mov	r9,	16(r10)	; 0x0010

00005410 <.Loc.802.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    5410:	ba 40 00 02 	mov	#512,	18(r10)	;#0x0200, 0x0012
    5414:	12 00 

00005416 <.Loc.803.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5416:	5c 4a 20 00 	mov.b	32(r10),r12	;0x00020
    541a:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018

0000541e <.Loc.805.1>:
  /* Custom callback */
  i2cp->callback = callback;
    541e:	9a 41 0a 00 	mov	10(r1),	8(r10)	;0x0000a
    5422:	08 00 

00005424 <.Loc.807.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5424:	ba 40 6c 51 	mov	#20844,	26(r10)	;#0x516c, 0x001a
    5428:	1a 00 

0000542a <.Loc.809.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    542a:	09 4a       	mov	r10,	r9	;

0000542c <.LVL42>:
    542c:	39 50 22 00 	add	#34,	r9	;#0x0022
    5430:	09 93       	cmp	#0,	r9	;r3 As==00
    5432:	08 24       	jz	$+18     	;abs 0x5444

00005434 <.Loc.809.1>:
    5434:	1c 4a 22 00 	mov	34(r10),r12	;0x00022
    5438:	0c 93       	cmp	#0,	r12	;r3 As==00
    543a:	04 24       	jz	$+10     	;abs 0x5444

0000543c <.Loc.809.1>:
    543c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5440:	00 00 
    5442:	03 20       	jnz	$+8      	;abs 0x544a

00005444 <.L38>:
    dmaAcquireI(&(i2cp->dma));
    5444:	0c 49       	mov	r9,	r12	;
    5446:	b0 12 d6 4f 	call	#20438		;#0x4fd6

0000544a <.L39>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    544a:	0d 4a       	mov	r10,	r13	;
    544c:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    5450:	0c 49       	mov	r9,	r12	;
    5452:	b0 12 74 50 	call	#20596		;#0x5074

00005456 <.LVL44>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    5456:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    545a:	8c 48 20 00 	mov	r8,	32(r12)	; 0x0020

0000545e <.Loc.816.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    545e:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5462:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    5466:	00 00 

00005468 <.Loc.819.1>:
  /* IFG is set automatically after START */
  
}
    5468:	37 17       	popm	#4,	r10	;16-bit words
    546a:	30 41       	ret			

0000546c <.L40>:
  osalDbgAssert(n > 0, "can't transmit no bytes");
    546c:	3c 40 2d b0 	mov	#-20435,r12	;#0xb02d
    5470:	b0 12 a6 44 	call	#17574		;#0x44a6

00005474 <.LVL46>:
    5474:	b7 3f       	jmp	$-144    	;abs 0x53e4

00005476 <.L41>:
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5476:	3c 40 2d b0 	mov	#-20435,r12	;#0xb02d
    547a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000547e <.LVL47>:
    547e:	b4 3f       	jmp	$-150    	;abs 0x53e8

00005480 <i2cMSP430XContinueTransmitMemsetI>:
    5480:	3a 15       	pushm	#4,	r10	;16-bit words

00005482 <.LCFI6>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    5482:	0a 4c       	mov	r12,	r10	;

00005484 <L0>:
    5484:	47 4d       	mov.b	r13,	r7	;
    5486:	09 4e       	mov	r14,	r9	;
    5488:	08 4f       	mov	r15,	r8	;

0000548a <.Loc.907.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    548a:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    548e:	00 00 
    5490:	04 24       	jz	$+10     	;abs 0x549a

00005492 <.Loc.907.1>:
    5492:	3c 40 0b b0 	mov	#-20469,r12	;#0xb00b

00005496 <.LVL69>:
    5496:	b0 12 a6 44 	call	#17574		;#0x44a6

0000549a <.L59>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    549a:	09 93       	cmp	#0,	r9	;r3 As==00
    549c:	37 24       	jz	$+112    	;abs 0x550c

0000549e <.L60>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    549e:	47 93       	cmp.b	#0,	r7	;r3 As==00
    54a0:	3a 38       	jl	$+118    	;abs 0x5516

000054a2 <.L61>:
#endif
  
  i2cp->buffer = value;
    54a2:	8a 48 06 00 	mov	r8,	6(r10)	;

000054a6 <.Loc.920.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    54a6:	8a 48 0c 00 	mov	r8,	12(r10)	; 0x000c

000054aa <.Loc.921.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    54aa:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    54ae:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    54b2:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

000054b6 <.Loc.922.1>:
  i2cp->req.size = n;
    54b6:	8a 49 10 00 	mov	r9,	16(r10)	; 0x0010

000054ba <.Loc.923.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    54ba:	8a 43 12 00 	mov	#0,	18(r10)	;r3 As==00, 0x0012

000054be <.Loc.924.1>:
  i2cp->req.trigger = i2cp->txtrig;
    54be:	5c 4a 20 00 	mov.b	32(r10),r12	;0x00020
    54c2:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018

000054c6 <.Loc.926.1>:
  /* Custom callback */
  i2cp->callback = callback;
    54c6:	9a 41 0a 00 	mov	10(r1),	8(r10)	;0x0000a
    54ca:	08 00 

000054cc <.Loc.928.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    54cc:	ba 40 6c 51 	mov	#20844,	26(r10)	;#0x516c, 0x001a
    54d0:	1a 00 

000054d2 <.Loc.930.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    54d2:	09 4a       	mov	r10,	r9	;

000054d4 <.LVL71>:
    54d4:	39 50 22 00 	add	#34,	r9	;#0x0022

000054d8 <.LVL72>:
    54d8:	09 93       	cmp	#0,	r9	;r3 As==00
    54da:	08 24       	jz	$+18     	;abs 0x54ec

000054dc <.Loc.930.1>:
    54dc:	1c 4a 22 00 	mov	34(r10),r12	;0x00022
    54e0:	0c 93       	cmp	#0,	r12	;r3 As==00
    54e2:	04 24       	jz	$+10     	;abs 0x54ec

000054e4 <.Loc.930.1>:
    54e4:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    54e8:	00 00 
    54ea:	04 20       	jnz	$+10     	;abs 0x54f4

000054ec <.L62>:
    54ec:	3c 40 0b b0 	mov	#-20469,r12	;#0xb00b
    54f0:	b0 12 a6 44 	call	#17574		;#0x44a6

000054f4 <.L63>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    54f4:	0d 4a       	mov	r10,	r13	;
    54f6:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    54fa:	0c 49       	mov	r9,	r12	;
    54fc:	b0 12 74 50 	call	#20596		;#0x5074

00005500 <.LVL74>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5500:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    5504:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005508 <.Loc.936.1>:
  
}
    5508:	37 17       	popm	#4,	r10	;16-bit words
    550a:	30 41       	ret			

0000550c <.L64>:
  osalDbgAssert(n > 0, "can't transmit no bytes");
    550c:	3c 40 0b b0 	mov	#-20469,r12	;#0xb00b
    5510:	b0 12 a6 44 	call	#17574		;#0x44a6

00005514 <.LVL76>:
    5514:	c4 3f       	jmp	$-118    	;abs 0x549e

00005516 <.L65>:
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5516:	3c 40 0b b0 	mov	#-20469,r12	;#0xb00b
    551a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000551e <.LVL77>:
    551e:	c1 3f       	jmp	$-124    	;abs 0x54a2

00005520 <i2cMSP430XContinueTransmitI>:
    5520:	3a 15       	pushm	#4,	r10	;16-bit words

00005522 <.LCFI7>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5522:	0a 4c       	mov	r12,	r10	;

00005524 <L0>:
    5524:	47 4d       	mov.b	r13,	r7	;
    5526:	09 4e       	mov	r14,	r9	;
    5528:	08 4f       	mov	r15,	r8	;

0000552a <.Loc.943.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    552a:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    552e:	00 00 
    5530:	04 24       	jz	$+10     	;abs 0x553a

00005532 <.Loc.943.1>:
    5532:	3c 40 ef af 	mov	#-20497,r12	;#0xafef

00005536 <.LVL79>:
    5536:	b0 12 a6 44 	call	#17574		;#0x44a6

0000553a <.L67>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    553a:	09 93       	cmp	#0,	r9	;r3 As==00
    553c:	38 24       	jz	$+114    	;abs 0x55ae

0000553e <.L68>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    553e:	47 93       	cmp.b	#0,	r7	;r3 As==00
    5540:	3b 38       	jl	$+120    	;abs 0x55b8

00005542 <.L69>:
#endif
  
  i2cp->buffer = txbuf;
    5542:	8a 48 06 00 	mov	r8,	6(r10)	;

00005546 <.Loc.956.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    5546:	8a 48 0c 00 	mov	r8,	12(r10)	; 0x000c

0000554a <.Loc.957.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    554a:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    554e:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    5552:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

00005556 <.Loc.958.1>:
  i2cp->req.size = n;
    5556:	8a 49 10 00 	mov	r9,	16(r10)	; 0x0010

0000555a <.Loc.959.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    555a:	ba 40 00 03 	mov	#768,	18(r10)	;#0x0300, 0x0012
    555e:	12 00 

00005560 <.Loc.960.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5560:	5c 4a 20 00 	mov.b	32(r10),r12	;0x00020
    5564:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018

00005568 <.Loc.962.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5568:	9a 41 0a 00 	mov	10(r1),	8(r10)	;0x0000a
    556c:	08 00 

0000556e <.Loc.964.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    556e:	ba 40 6c 51 	mov	#20844,	26(r10)	;#0x516c, 0x001a
    5572:	1a 00 

00005574 <.Loc.966.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5574:	09 4a       	mov	r10,	r9	;

00005576 <.LVL81>:
    5576:	39 50 22 00 	add	#34,	r9	;#0x0022

0000557a <.LVL82>:
    557a:	09 93       	cmp	#0,	r9	;r3 As==00
    557c:	08 24       	jz	$+18     	;abs 0x558e

0000557e <.Loc.966.1>:
    557e:	1c 4a 22 00 	mov	34(r10),r12	;0x00022
    5582:	0c 93       	cmp	#0,	r12	;r3 As==00
    5584:	04 24       	jz	$+10     	;abs 0x558e

00005586 <.Loc.966.1>:
    5586:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    558a:	00 00 
    558c:	04 20       	jnz	$+10     	;abs 0x5596

0000558e <.L70>:
    558e:	3c 40 ef af 	mov	#-20497,r12	;#0xafef
    5592:	b0 12 a6 44 	call	#17574		;#0x44a6

00005596 <.L71>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5596:	0d 4a       	mov	r10,	r13	;
    5598:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    559c:	0c 49       	mov	r9,	r12	;
    559e:	b0 12 74 50 	call	#20596		;#0x5074

000055a2 <.LVL84>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    55a2:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    55a6:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

000055aa <.Loc.972.1>:
  
}
    55aa:	37 17       	popm	#4,	r10	;16-bit words
    55ac:	30 41       	ret			

000055ae <.L72>:
  osalDbgAssert(n > 0, "can't transmit no bytes");
    55ae:	3c 40 ef af 	mov	#-20497,r12	;#0xafef
    55b2:	b0 12 a6 44 	call	#17574		;#0x44a6

000055b6 <.LVL86>:
    55b6:	c3 3f       	jmp	$-120    	;abs 0x553e

000055b8 <.L73>:
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    55b8:	3c 40 ef af 	mov	#-20497,r12	;#0xafef
    55bc:	b0 12 a6 44 	call	#17574		;#0x44a6

000055c0 <.LVL87>:
    55c0:	c0 3f       	jmp	$-126    	;abs 0x5542

000055c2 <i2cMSP430XEndTransferI>:
    55c2:	0a 15       	pushm	#1,	r10	;16-bit words

000055c4 <.LCFI8>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    55c4:	0a 4c       	mov	r12,	r10	;

000055c6 <L0>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
    55c6:	6c 4c       	mov.b	@r12,	r12	;

000055c8 <.LVL89>:
    55c8:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    55cc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    55ce:	4d 9c       	cmp.b	r12,	r13	;
    55d0:	04 2c       	jc	$+10     	;abs 0x55da

000055d2 <.Loc.978.1>:
    55d2:	3c 40 d8 af 	mov	#-20520,r12	;#0xafd8
    55d6:	b0 12 a6 44 	call	#17574		;#0x44a6

000055da <.L75>:
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    55da:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    55de:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

000055e2 <.Loc.984.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    55e2:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    55e6:	09 24       	jz	$+20     	;abs 0x55fa

000055e8 <.L79>:
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
  }
  
  while (i2cp->regs->ctlw0 & UCTXSTP) ;
    55e8:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    55ec:	ec b2 00 00 	bit.b	#4,	0(r12)	;r2 As==10
    55f0:	fb 23       	jnz	$-8      	;abs 0x55e8

000055f2 <.Loc.1004.1>:
  
  i2cp->state = I2C_READY;
    55f2:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000055f6 <.Loc.1005.1>:
}
    55f6:	0a 17       	popm	#1,	r10	;16-bit words
    55f8:	30 41       	ret			

000055fa <.L77>:
    while (!(i2cp->regs->ifg & UCRXIFG0));
    55fa:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    55fe:	dc b3 2c 00 	bit.b	#1,	44(r12)	;r3 As==01, 0x002c
    5602:	fb 27       	jz	$-8      	;abs 0x55fa

00005604 <.Loc.994.1>:
    if (i2cp->req.addr_mode) {
    5604:	8a 93 12 00 	cmp	#0,	18(r10)	;r3 As==00, 0x0012
    5608:	08 24       	jz	$+18     	;abs 0x561a

0000560a <.Loc.995.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    560a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    560e:	1d 5a 10 00 	add	16(r10),r13	;0x00010
    5612:	dd 4c 0c 00 	mov.b	12(r12),0(r13)	;0x0000c
    5616:	00 00 
    5618:	e7 3f       	jmp	$-48     	;abs 0x55e8

0000561a <.L78>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    561a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    561e:	dd 4c 0c 00 	mov.b	12(r12),0(r13)	;0x0000c
    5622:	00 00 
    5624:	e1 3f       	jmp	$-60     	;abs 0x55e8

00005626 <rx_async_callback>:
    5626:	1f 4c 08 00 	mov	8(r12),	r15	;

0000562a <L0>:
  if (NULL != i2cp->callback) {
    562a:	0f 93       	cmp	#0,	r15	;r3 As==00
    562c:	06 24       	jz	$+14     	;abs 0x563a

0000562e <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    562e:	1e 4c 10 00 	mov	16(r12),r14	;0x00010
    5632:	1d 4c 06 00 	mov	6(r12),	r13	;
    5636:	8f 12       	call	r15		;

00005638 <.L80>:
}
    5638:	30 41       	ret			

0000563a <.L81>:
    i2cMSP430XEndTransferI(i2cp);
    563a:	b0 12 c2 55 	call	#21954		;#0x55c2

0000563e <.LVL95>:
}
    563e:	fc 3f       	jmp	$-6      	;abs 0x5638

00005640 <ISR_USCI_B0_VECTOR>:
    5640:	bf 15       	pushm	#12,	r15	;16-bit words

00005642 <L0>:
  OSAL_IRQ_PROLOGUE();
    5642:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00005646 <.Loc.110.1>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    5646:	1c 42 6e 06 	mov	&0x066e,r12	;0x066e
    564a:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    564e:	53 24       	jz	$+168    	;abs 0x56f6
    5650:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    5654:	0d 9c       	cmp	r12,	r13	;
    5656:	1d 2c       	jc	$+60     	;abs 0x5692
    5658:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    565c:	67 24       	jz	$+208    	;abs 0x572c
    565e:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    5662:	0d 9c       	cmp	r12,	r13	;
    5664:	3f 2c       	jc	$+128    	;abs 0x56e4
    5666:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    566a:	7d 24       	jz	$+252    	;abs 0x5766
    566c:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    5670:	7f 24       	jz	$+256    	;abs 0x5770
    5672:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    5676:	48 20       	jnz	$+146    	;abs 0x5708

00005678 <.Loc.158.1>:
      UCB0IE &= ~(UCTXIE);
    5678:	a2 c3 6a 06 	bic	#2,	&0x066a	;r3 As==10

0000567c <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    567c:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5680:	8c 93 1e 00 	cmp	#0,	30(r12)	;r3 As==00, 0x001e
    5684:	61 24       	jz	$+196    	;abs 0x5748

00005686 <.LBB63>:
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
    5686:	4d 43       	clr.b	r13		;
    5688:	3c 40 5c b5 	mov	#-19108,r12	;#0xb55c

0000568c <.LVL97>:
    568c:	b0 12 2a 46 	call	#17962		;#0x462a

00005690 <.LVL98>:
    5690:	3b 3c       	jmp	$+120    	;abs 0x5708

00005692 <.L104>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    5692:	3c 90 06 00 	cmp	#6,	r12	;
    5696:	45 24       	jz	$+140    	;abs 0x5722
    5698:	7d 40 06 00 	mov.b	#6,	r13	;
    569c:	0d 9c       	cmp	r12,	r13	;
    569e:	09 28       	jnc	$+20     	;abs 0x56b2
    56a0:	2c 93       	cmp	#2,	r12	;r3 As==10
    56a2:	2e 24       	jz	$+94     	;abs 0x5700
    56a4:	2c 92       	cmp	#4,	r12	;r2 As==10
    56a6:	30 20       	jnz	$+98     	;abs 0x5708

000056a8 <.Loc.119.1>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    56a8:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    56ac:	ac d2 04 00 	bis	#4,	4(r12)	;r2 As==10

000056b0 <.Loc.120.1>:
      break;
    56b0:	2b 3c       	jmp	$+88     	;abs 0x5708

000056b2 <.L88>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    56b2:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    56b6:	1f 24       	jz	$+64     	;abs 0x56f6
    56b8:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    56bc:	1c 24       	jz	$+58     	;abs 0x56f6
    56be:	3c 92       	cmp	#8,	r12	;r2 As==11
    56c0:	23 20       	jnz	$+72     	;abs 0x5708

000056c2 <.Loc.126.1>:
      I2CDB0.state = I2C_READY;
    56c2:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    56c6:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

000056ca <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    56ca:	8c 93 1e 00 	cmp	#0,	30(r12)	;r3 As==00, 0x001e
    56ce:	05 24       	jz	$+12     	;abs 0x56da

000056d0 <.LBB65>:
    56d0:	4d 43       	clr.b	r13		;
    56d2:	3c 50 1e 00 	add	#30,	r12	;#0x001e
    56d6:	b0 12 2a 46 	call	#17962		;#0x462a

000056da <.L97>:
        dmaReleaseX(&(I2CDB0.dma));
    56da:	3c 40 60 b5 	mov	#-19104,r12	;#0xb560
    56de:	b0 12 e6 50 	call	#20710		;#0x50e6

000056e2 <.LVL102>:
      break;
    56e2:	12 3c       	jmp	$+38     	;abs 0x5708

000056e4 <.L105>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    56e4:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    56e8:	06 24       	jz	$+14     	;abs 0x56f6
    56ea:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    56ee:	03 24       	jz	$+8      	;abs 0x56f6
    56f0:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    56f4:	09 20       	jnz	$+20     	;abs 0x5708

000056f6 <.L85>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    56f6:	3c 40 7e b0 	mov	#-20354,r12	;#0xb07e
    56fa:	b0 12 a6 44 	call	#17574		;#0x44a6

000056fe <.LVL103>:
      break;
    56fe:	04 3c       	jmp	$+10     	;abs 0x5708

00005700 <.L89>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    5700:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5704:	ac d3 04 00 	bis	#2,	4(r12)	;r3 As==10

00005708 <.L84>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    5708:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    570c:	8c 93 04 00 	cmp	#0,	4(r12)	;r3 As==00
    5710:	35 20       	jnz	$+108    	;abs 0x577c

00005712 <.L100>:
  OSAL_IRQ_EPILOGUE();
    5712:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    5716:	b0 12 7a 45 	call	#17786		;#0x457a

0000571a <.LVL104>:
    571a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    571c:	59 20       	jnz	$+180    	;abs 0x57d0

0000571e <.L83>:
}
    571e:	b4 17       	popm	#12,	r15	;16-bit words
    5720:	00 13       	reti			

00005722 <.L87>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    5722:	3c 40 7e b0 	mov	#-20354,r12	;#0xb07e
    5726:	b0 12 a6 44 	call	#17574		;#0x44a6

0000572a <.LVL105>:
      break;
    572a:	ee 3f       	jmp	$-34     	;abs 0x5708

0000572c <.L92>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    572c:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5730:	1d 4c 0e 00 	mov	14(r12),r13	;0x0000e
    5734:	1d 5c 10 00 	add	16(r12),r13	;0x00010
    5738:	0c 4d       	mov	r13,	r12	;
    573a:	1d 42 4c 06 	mov	&0x064c,r13	;0x064c
    573e:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00005742 <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    5742:	92 c3 6a 06 	bic	#1,	&0x066a	;r3 As==01

00005746 <.Loc.155.1>:
      break;
    5746:	e0 3f       	jmp	$-62     	;abs 0x5708

00005748 <.L106>:
        if (NULL != I2CDB0.callback) {
    5748:	1f 42 46 b5 	mov	&0xb546,r15	;0xb546
    574c:	0f 93       	cmp	#0,	r15	;r3 As==00
    574e:	06 24       	jz	$+14     	;abs 0x575c

00005750 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    5750:	1e 4c 10 00 	mov	16(r12),r14	;0x00010
    5754:	1d 4c 06 00 	mov	6(r12),	r13	;
    5758:	8f 12       	call	r15		;
    575a:	d6 3f       	jmp	$-82     	;abs 0x5708

0000575c <.L99>:
          i2cMSP430XEndTransferI(&I2CDB0);
    575c:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5760:	b0 12 c2 55 	call	#21954		;#0x55c2

00005764 <.LVL107>:
    5764:	d1 3f       	jmp	$-92     	;abs 0x5708

00005766 <.L94>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    5766:	3c 40 7e b0 	mov	#-20354,r12	;#0xb07e
    576a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000576e <.LVL108>:
      break;
    576e:	cc 3f       	jmp	$-102    	;abs 0x5708

00005770 <.L95>:
      I2CDB0.errors |= I2C_TIMEOUT;
    5770:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    5774:	bc d0 20 00 	bis	#32,	4(r12)	;#0x0020
    5778:	04 00 

0000577a <.Loc.185.1>:
      break;
    577a:	c6 3f       	jmp	$-114    	;abs 0x5708

0000577c <.L107>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    577c:	0a 4c       	mov	r12,	r10	;
    577e:	1c 4c 22 00 	mov	34(r12),r12	;0x00022
    5782:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    5786:	19 4a 10 00 	mov	16(r10),r9	;0x00010
    578a:	09 8c       	sub	r12,	r9	;

0000578c <.LVL109>:
    dmaCancelI(&I2CDB0.dma);
    578c:	0c 4a       	mov	r10,	r12	;
    578e:	3c 50 22 00 	add	#34,	r12	;#0x0022
    5792:	b0 12 2a 51 	call	#20778		;#0x512a

00005796 <.LVL110>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    5796:	fa b0 20 00 	bit.b	#32,	4(r10)	;#0x0020
    579a:	04 00 
    579c:	03 24       	jz	$+8      	;abs 0x57a4

0000579e <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    579e:	f2 40 05 00 	mov.b	#5,	&0xb53e	;
    57a2:	3e b5 

000057a4 <.L101>:
    if (NULL != I2CDB0.callback) {
    57a4:	1f 42 46 b5 	mov	&0xb546,r15	;0xb546
    57a8:	0f 93       	cmp	#0,	r15	;r3 As==00
    57aa:	06 24       	jz	$+14     	;abs 0x57b8

000057ac <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    57ac:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    57b0:	0e 49       	mov	r9,	r14	;
    57b2:	1d 4c 06 00 	mov	6(r12),	r13	;
    57b6:	8f 12       	call	r15		;

000057b8 <.L102>:
    if (I2CDB0.thread != NULL) {
    57b8:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    57bc:	8c 93 1e 00 	cmp	#0,	30(r12)	;r3 As==00, 0x001e
    57c0:	a8 27       	jz	$-174    	;abs 0x5712

000057c2 <.LBB68>:
    57c2:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    57c6:	3c 50 1e 00 	add	#30,	r12	;#0x001e
    57ca:	b0 12 2a 46 	call	#17962		;#0x462a

000057ce <.LVL113>:
    57ce:	a1 3f       	jmp	$-188    	;abs 0x5712

000057d0 <.L108>:
  OSAL_IRQ_EPILOGUE();
    57d0:	b0 12 92 45 	call	#17810		;#0x4592

000057d4 <.LVL115>:
}
    57d4:	a4 3f       	jmp	$-182    	;abs 0x571e

000057d6 <UCBRS>:
    57d6:	3d 40 10 02 	mov	#528,	r13	;#0x0210
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
  /* TODO there must be a better way */
  if (frac < 529)
    57da:	0d 9c       	cmp	r12,	r13	;
    57dc:	a0 2c       	jc	$+322    	;abs 0x591e

000057de <.Loc.84.1>:
    return 0x00;
  else if (frac < 715)
    57de:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    57e2:	0d 9c       	cmp	r12,	r13	;
    57e4:	9e 2c       	jc	$+318    	;abs 0x5922

000057e6 <.Loc.86.1>:
    return 0x01;
  else if (frac < 835)
    57e6:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    57ea:	0d 9c       	cmp	r12,	r13	;
    57ec:	02 28       	jnc	$+6      	;abs 0x57f2

000057ee <L0>:
    return 0x02;
    57ee:	6c 43       	mov.b	#2,	r12	;r3 As==10

000057f0 <.LVL1>:
    57f0:	97 3c       	jmp	$+304    	;abs 0x5920

000057f2 <.L38>:
  else if (frac < 1001)
    57f2:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    57f6:	0d 9c       	cmp	r12,	r13	;
    57f8:	02 28       	jnc	$+6      	;abs 0x57fe

000057fa <.Loc.89.1>:
    return 0x04;
    57fa:	6c 42       	mov.b	#4,	r12	;r2 As==10

000057fc <.LVL3>:
    57fc:	91 3c       	jmp	$+292    	;abs 0x5920

000057fe <.L39>:
  else if (frac < 1252)
    57fe:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    5802:	0d 9c       	cmp	r12,	r13	;
    5804:	02 28       	jnc	$+6      	;abs 0x580a

00005806 <.Loc.91.1>:
    return 0x08;
    5806:	7c 42       	mov.b	#8,	r12	;r2 As==11

00005808 <.LVL5>:
    5808:	8b 3c       	jmp	$+280    	;abs 0x5920

0000580a <.L40>:
  else if (frac < 1430)
    580a:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    580e:	0d 9c       	cmp	r12,	r13	;
    5810:	03 28       	jnc	$+8      	;abs 0x5818

00005812 <.Loc.93.1>:
    return 0x10;
    5812:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

00005816 <.LVL7>:
    5816:	84 3c       	jmp	$+266    	;abs 0x5920

00005818 <.L41>:
  else if (frac < 1670)
    5818:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    581c:	0d 9c       	cmp	r12,	r13	;
    581e:	03 28       	jnc	$+8      	;abs 0x5826

00005820 <.Loc.95.1>:
    return 0x20;
    5820:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

00005824 <.LVL9>:
    5824:	7d 3c       	jmp	$+252    	;abs 0x5920

00005826 <.L42>:
  else if (frac < 2147)
    5826:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    582a:	0d 9c       	cmp	r12,	r13	;
    582c:	03 28       	jnc	$+8      	;abs 0x5834

0000582e <.Loc.97.1>:
    return 0x11;
    582e:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

00005832 <.LVL11>:
    5832:	76 3c       	jmp	$+238    	;abs 0x5920

00005834 <.L43>:
  else if (frac < 2224)
    5834:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    5838:	0d 9c       	cmp	r12,	r13	;
    583a:	03 28       	jnc	$+8      	;abs 0x5842

0000583c <.Loc.99.1>:
    return 0x21;
    583c:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

00005840 <.LVL13>:
    5840:	6f 3c       	jmp	$+224    	;abs 0x5920

00005842 <.L44>:
  else if (frac < 2503)
    5842:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    5846:	0d 9c       	cmp	r12,	r13	;
    5848:	6e 2c       	jc	$+222    	;abs 0x5926

0000584a <.Loc.102.1>:
    return 0x22;
  else if (frac < 3000)
    584a:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    584e:	0d 9c       	cmp	r12,	r13	;
    5850:	03 28       	jnc	$+8      	;abs 0x5858

00005852 <.Loc.103.1>:
    return 0x44;
    5852:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00005856 <.LVL15>:
    5856:	64 3c       	jmp	$+202    	;abs 0x5920

00005858 <.L45>:
  else if (frac < 3335)
    5858:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    585c:	0d 9c       	cmp	r12,	r13	;
    585e:	66 2c       	jc	$+206    	;abs 0x592c

00005860 <.Loc.106.1>:
    return 0x25;
  else if (frac < 3575)
    5860:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    5864:	0d 9c       	cmp	r12,	r13	;
    5866:	65 2c       	jc	$+204    	;abs 0x5932

00005868 <.Loc.108.1>:
    return 0x49;
  else if (frac < 3753)
    5868:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    586c:	0d 9c       	cmp	r12,	r13	;
    586e:	64 2c       	jc	$+202    	;abs 0x5938

00005870 <.Loc.110.1>:
    return 0x4A;
  else if (frac < 4003)
    5870:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    5874:	0d 9c       	cmp	r12,	r13	;
    5876:	63 2c       	jc	$+200    	;abs 0x593e

00005878 <.Loc.112.1>:
    return 0x52;
  else if (frac < 4286)
    5878:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    587c:	0d 9c       	cmp	r12,	r13	;
    587e:	62 2c       	jc	$+198    	;abs 0x5944

00005880 <.Loc.114.1>:
    return 0x92;
  else if (frac < 4378)
    5880:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    5884:	0d 9c       	cmp	r12,	r13	;
    5886:	61 2c       	jc	$+196    	;abs 0x594a

00005888 <.Loc.116.1>:
    return 0x53;
  else if (frac < 5002)
    5888:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    588c:	0d 9c       	cmp	r12,	r13	;
    588e:	60 2c       	jc	$+194    	;abs 0x5950

00005890 <.Loc.118.1>:
    return 0x55;
  else if (frac < 5715)
    5890:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    5894:	0d 9c       	cmp	r12,	r13	;
    5896:	5f 2c       	jc	$+192    	;abs 0x5956

00005898 <.Loc.120.1>:
    return 0xAA;
  else if (frac < 6003)
    5898:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    589c:	0d 9c       	cmp	r12,	r13	;
    589e:	5e 2c       	jc	$+190    	;abs 0x595c

000058a0 <.Loc.122.1>:
    return 0x6B;
  else if (frac < 6254)
    58a0:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    58a4:	0d 9c       	cmp	r12,	r13	;
    58a6:	5d 2c       	jc	$+188    	;abs 0x5962

000058a8 <.Loc.124.1>:
    return 0xAD;
  else if (frac < 6432)
    58a8:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    58ac:	0d 9c       	cmp	r12,	r13	;
    58ae:	5c 2c       	jc	$+186    	;abs 0x5968

000058b0 <.Loc.126.1>:
    return 0xB5;
  else if (frac < 6667)
    58b0:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    58b4:	0d 9c       	cmp	r12,	r13	;
    58b6:	5b 2c       	jc	$+184    	;abs 0x596e

000058b8 <.Loc.128.1>:
    return 0xB6;
  else if (frac < 7001)
    58b8:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    58bc:	0d 9c       	cmp	r12,	r13	;
    58be:	5a 2c       	jc	$+182    	;abs 0x5974

000058c0 <.Loc.130.1>:
    return 0xD6;
  else if (frac < 7147)
    58c0:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    58c4:	0d 9c       	cmp	r12,	r13	;
    58c6:	59 2c       	jc	$+180    	;abs 0x597a

000058c8 <.Loc.132.1>:
    return 0xB7;
  else if (frac < 7503)
    58c8:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    58cc:	0d 9c       	cmp	r12,	r13	;
    58ce:	58 2c       	jc	$+178    	;abs 0x5980

000058d0 <.Loc.134.1>:
    return 0xBB;
  else if (frac < 7861)
    58d0:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    58d4:	0d 9c       	cmp	r12,	r13	;
    58d6:	57 2c       	jc	$+176    	;abs 0x5986

000058d8 <.Loc.136.1>:
    return 0xDD;
  else if (frac < 8004)
    58d8:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    58dc:	0d 9c       	cmp	r12,	r13	;
    58de:	56 2c       	jc	$+174    	;abs 0x598c

000058e0 <.Loc.138.1>:
    return 0xED;
  else if (frac < 8333)
    58e0:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    58e4:	0d 9c       	cmp	r12,	r13	;
    58e6:	55 2c       	jc	$+172    	;abs 0x5992

000058e8 <.Loc.140.1>:
    return 0xEE;
  else if (frac < 8464)
    58e8:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    58ec:	0d 9c       	cmp	r12,	r13	;
    58ee:	54 2c       	jc	$+170    	;abs 0x5998

000058f0 <.Loc.142.1>:
    return 0xBF;
  else if (frac < 8572)
    58f0:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    58f4:	0d 9c       	cmp	r12,	r13	;
    58f6:	53 2c       	jc	$+168    	;abs 0x599e

000058f8 <.Loc.144.1>:
    return 0xDF;
  else if (frac < 8751)
    58f8:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    58fc:	0d 9c       	cmp	r12,	r13	;
    58fe:	52 2c       	jc	$+166    	;abs 0x59a4

00005900 <.Loc.146.1>:
    return 0xEF;
  else if (frac < 9004)
    5900:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    5904:	0d 9c       	cmp	r12,	r13	;
    5906:	51 2c       	jc	$+164    	;abs 0x59aa

00005908 <.Loc.148.1>:
    return 0xF7;
  else if (frac < 9170)
    5908:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    590c:	0d 9c       	cmp	r12,	r13	;
    590e:	50 2c       	jc	$+162    	;abs 0x59b0

00005910 <.Loc.150.1>:
    return 0xFB;
  else if (frac < 9288)
    5910:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    5914:	0d 9c       	cmp	r12,	r13	;
    5916:	4f 28       	jnc	$+160    	;abs 0x59b6

00005918 <.Loc.151.1>:
    return 0xFD;
    5918:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

0000591c <.LVL17>:
    591c:	01 3c       	jmp	$+4      	;abs 0x5920

0000591e <.L3>:
    return 0x00;
    591e:	4c 43       	clr.b	r12		;

00005920 <.L2>:
  else
    return 0xFE;
}
    5920:	30 41       	ret			

00005922 <.L4>:
    return 0x01;
    5922:	5c 43       	mov.b	#1,	r12	;r3 As==01

00005924 <.LVL21>:
    5924:	fd 3f       	jmp	$-4      	;abs 0x5920

00005926 <.L12>:
    return 0x22;
    5926:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

0000592a <.LVL23>:
    592a:	fa 3f       	jmp	$-10     	;abs 0x5920

0000592c <.L14>:
    return 0x25;
    592c:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00005930 <.LVL25>:
    5930:	f7 3f       	jmp	$-16     	;abs 0x5920

00005932 <.L15>:
    return 0x49;
    5932:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00005936 <.LVL27>:
    5936:	f4 3f       	jmp	$-22     	;abs 0x5920

00005938 <.L16>:
    return 0x4A;
    5938:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

0000593c <.LVL29>:
    593c:	f1 3f       	jmp	$-28     	;abs 0x5920

0000593e <.L17>:
    return 0x52;
    593e:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00005942 <.LVL31>:
    5942:	ee 3f       	jmp	$-34     	;abs 0x5920

00005944 <.L18>:
    return 0x92;
    5944:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00005948 <.LVL33>:
    5948:	eb 3f       	jmp	$-40     	;abs 0x5920

0000594a <.L19>:
    return 0x53;
    594a:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

0000594e <.LVL35>:
    594e:	e8 3f       	jmp	$-46     	;abs 0x5920

00005950 <.L20>:
    return 0x55;
    5950:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00005954 <.LVL37>:
    5954:	e5 3f       	jmp	$-52     	;abs 0x5920

00005956 <.L21>:
    return 0xAA;
    5956:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

0000595a <.LVL39>:
    595a:	e2 3f       	jmp	$-58     	;abs 0x5920

0000595c <.L22>:
    return 0x6B;
    595c:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00005960 <.LVL41>:
    5960:	df 3f       	jmp	$-64     	;abs 0x5920

00005962 <.L23>:
    return 0xAD;
    5962:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00005966 <.LVL43>:
    5966:	dc 3f       	jmp	$-70     	;abs 0x5920

00005968 <.L24>:
    return 0xB5;
    5968:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

0000596c <.LVL45>:
    596c:	d9 3f       	jmp	$-76     	;abs 0x5920

0000596e <.L25>:
    return 0xB6;
    596e:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00005972 <.LVL47>:
    5972:	d6 3f       	jmp	$-82     	;abs 0x5920

00005974 <.L26>:
    return 0xD6;
    5974:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00005978 <.LVL49>:
    5978:	d3 3f       	jmp	$-88     	;abs 0x5920

0000597a <.L27>:
    return 0xB7;
    597a:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

0000597e <.LVL51>:
    597e:	d0 3f       	jmp	$-94     	;abs 0x5920

00005980 <.L28>:
    return 0xBB;
    5980:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

00005984 <.LVL53>:
    5984:	cd 3f       	jmp	$-100    	;abs 0x5920

00005986 <.L29>:
    return 0xDD;
    5986:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

0000598a <.LVL55>:
    598a:	ca 3f       	jmp	$-106    	;abs 0x5920

0000598c <.L30>:
    return 0xED;
    598c:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00005990 <.LVL57>:
    5990:	c7 3f       	jmp	$-112    	;abs 0x5920

00005992 <.L31>:
    return 0xEE;
    5992:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00005996 <.LVL59>:
    5996:	c4 3f       	jmp	$-118    	;abs 0x5920

00005998 <.L32>:
    return 0xBF;
    5998:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

0000599c <.LVL61>:
    599c:	c1 3f       	jmp	$-124    	;abs 0x5920

0000599e <.L33>:
    return 0xDF;
    599e:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

000059a2 <.LVL63>:
    59a2:	be 3f       	jmp	$-130    	;abs 0x5920

000059a4 <.L34>:
    return 0xEF;
    59a4:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

000059a8 <.LVL65>:
    59a8:	bb 3f       	jmp	$-136    	;abs 0x5920

000059aa <.L35>:
    return 0xF7;
    59aa:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

000059ae <.LVL67>:
    59ae:	b8 3f       	jmp	$-142    	;abs 0x5920

000059b0 <.L36>:
    return 0xFB;
    59b0:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

000059b4 <.LVL69>:
    59b4:	b5 3f       	jmp	$-148    	;abs 0x5920

000059b6 <.L37>:
    return 0xFE;
    59b6:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000059ba <.LVL71>:
    59ba:	b2 3f       	jmp	$-154    	;abs 0x5920

000059bc <set_baud>:
    59bc:	6a 15       	pushm	#7,	r10	;16-bit words

000059be <.LCFI0>:

static void set_baud(UARTDriver * uartp) {
    59be:	31 80 06 00 	sub	#6,	r1	;

000059c2 <.LCFI1>:
    59c2:	0a 4c       	mov	r12,	r10	;

000059c4 <.Loc.157.1>:
  uint16_t n = uartp->freq / uartp->config->baud;
    59c4:	91 4c 0c 00 	mov	12(r12),2(r1)	;0x0000c
    59c8:	02 00 
    59ca:	91 4c 0e 00 	mov	14(r12),4(r1)	;0x0000e
    59ce:	04 00 
    59d0:	1c 4c 04 00 	mov	4(r12),	r12	;

000059d4 <.LVL73>:
    59d4:	18 4c 0a 00 	mov	10(r12),r8	;0x0000a
    59d8:	19 4c 0c 00 	mov	12(r12),r9	;0x0000c
    59dc:	35 40 1c ac 	mov	#-21476,r5	;#0xac1c
    59e0:	0e 48       	mov	r8,	r14	;
    59e2:	0f 49       	mov	r9,	r15	;
    59e4:	1c 41 02 00 	mov	2(r1),	r12	;
    59e8:	1d 41 04 00 	mov	4(r1),	r13	;
    59ec:	85 12       	call	r5		;

000059ee <.LVL74>:
    59ee:	81 4c 00 00 	mov	r12,	0(r1)	;

000059f2 <.LVL75>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    59f2:	34 40 52 ad 	mov	#-21166,r4	;#0xad52
    59f6:	0e 48       	mov	r8,	r14	;
    59f8:	0f 49       	mov	r9,	r15	;
    59fa:	4d 43       	clr.b	r13		;
    59fc:	84 12       	call	r4		;

000059fe <.LVL76>:
    59fe:	3e 40 10 27 	mov	#10000,	r14	;#0x2710

00005a02 <L0>:
    5a02:	4f 43       	clr.b	r15		;
    5a04:	16 41 02 00 	mov	2(r1),	r6	;
    5a08:	17 41 04 00 	mov	4(r1),	r7	;
    5a0c:	06 8c       	sub	r12,	r6	;
    5a0e:	07 7d       	subc	r13,	r7	;
    5a10:	0c 46       	mov	r6,	r12	;
    5a12:	0d 47       	mov	r7,	r13	;
    5a14:	84 12       	call	r4		;

00005a16 <.LVL77>:
    5a16:	0e 48       	mov	r8,	r14	;
    5a18:	0f 49       	mov	r9,	r15	;
    5a1a:	85 12       	call	r5		;

00005a1c <.LVL78>:
  if (n > 16) {
    5a1c:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    5a20:	27 91       	cmp	@r1,	r7	;
    5a22:	10 28       	jnc	$+34     	;abs 0x5a44

00005a24 <.Loc.165.1>:
    uartp->regs->brw = (n >> 4);
    n = (n & 0x0F);
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
  }
  else {
    uartp->regs->brw = n;
    5a24:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    5a28:	ad 41 06 00 	mov	@r1,	6(r13)	;

00005a2c <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    5a2c:	1a 4a 10 00 	mov	16(r10),r10	;0x00010

00005a30 <.LVL79>:
    5a30:	b0 12 d6 57 	call	#22486		;#0x57d6

00005a34 <.LVL80>:
    5a34:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5a38:	8a 4c 08 00 	mov	r12,	8(r10)	;

00005a3c <.L46>:
  }
}
    5a3c:	31 50 06 00 	add	#6,	r1	;
    5a40:	64 17       	popm	#7,	r10	;16-bit words
    5a42:	30 41       	ret			

00005a44 <.L49>:
    uartp->regs->brw = (n >> 4);
    5a44:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    5a48:	2e 41       	mov	@r1,	r14	;
    5a4a:	5e 0f       	rrum	#4,	r14	;
    5a4c:	8d 4e 06 00 	mov	r14,	6(r13)	;

00005a50 <.LVL83>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    5a50:	1a 4a 10 00 	mov	16(r10),r10	;0x00010

00005a54 <.LVL84>:
    5a54:	b0 12 d6 57 	call	#22486		;#0x57d6

00005a58 <.LVL85>:
    5a58:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5a5c:	2d 41       	mov	@r1,	r13	;
    5a5e:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    5a62:	7d f0 ff 00 	and.b	#255,	r13	;#0x00ff
    5a66:	0c dd       	bis	r13,	r12	;
    5a68:	1c d3       	bis	#1,	r12	;r3 As==01
    5a6a:	8a 4c 08 00 	mov	r12,	8(r10)	;
    5a6e:	e6 3f       	jmp	$-50     	;abs 0x5a3c

00005a70 <uart_enter_rx_idle_loop>:
    5a70:	1c 4c       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00005a72 <L0>:
  }
}

static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
    5a72:	10 00       	bra	@r0+		;

00005a74 <.LVL87>:
    5a74:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005a78 <.Loc.197.1>:
}
    5a78:	30 41       	ret			

00005a7a <rx_cb>:

static void rx_cb(void * arg){
    5a7a:	0a 15       	pushm	#1,	r10	;16-bit words

00005a7c <.LCFI2>:
    5a7c:	0a 4c       	mov	r12,	r10	;

00005a7e <.LVL89>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5a7e:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    5a82:	1c 4c 04 00 	mov	4(r12),	r12	;

00005a86 <.LVL90>:
    5a86:	1d 4c 04 00 	mov	4(r12),	r13	;
    5a8a:	0d 93       	cmp	#0,	r13	;r3 As==00
    5a8c:	02 24       	jz	$+6      	;abs 0x5a92

00005a8e <.Loc.203.1>:
    5a8e:	0c 4a       	mov	r10,	r12	;
    5a90:	8d 12       	call	r13		;

00005a92 <.L52>:
    5a92:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    5a96:	07 24       	jz	$+16     	;abs 0x5aa6

00005a98 <.L53>:
    5a98:	4d 43       	clr.b	r13		;
    5a9a:	0c 4a       	mov	r10,	r12	;
    5a9c:	3c 52       	add	#8,	r12	;r2 As==11

00005a9e <.LVL93>:
    5a9e:	b0 12 2a 46 	call	#17962		;#0x462a

00005aa2 <.LBE31>:
}
    5aa2:	0a 17       	popm	#1,	r10	;16-bit words
    5aa4:	30 41       	ret			

00005aa6 <.L54>:
  _uart_rx_complete_isr_code(uartp);
    5aa6:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    5aaa:	0c 4a       	mov	r10,	r12	;
    5aac:	b0 12 70 5a 	call	#23152		;#0x5a70

00005ab0 <.LVL95>:
    5ab0:	f3 3f       	jmp	$-24     	;abs 0x5a98

00005ab2 <tx_cb>:
    5ab2:	0a 15       	pushm	#1,	r10	;16-bit words

00005ab4 <L0>:
static void tx_cb(void * arg) {
    5ab4:	0a 4c       	mov	r12,	r10	;

00005ab6 <.LVL97>:
  _uart_tx1_isr_code(uartp);
    5ab6:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    5aba:	1c 4c 04 00 	mov	4(r12),	r12	;

00005abe <.LVL98>:
    5abe:	2d 4c       	mov	@r12,	r13	;
    5ac0:	0d 93       	cmp	#0,	r13	;r3 As==00
    5ac2:	02 24       	jz	$+6      	;abs 0x5ac8

00005ac4 <.Loc.183.1>:
    5ac4:	0c 4a       	mov	r10,	r12	;
    5ac6:	8d 12       	call	r13		;

00005ac8 <.L56>:
    5ac8:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    5acc:	10 24       	jz	$+34     	;abs 0x5aee

00005ace <.L57>:
    5ace:	ca 93 06 00 	cmp.b	#0,	6(r10)	;r3 As==00
    5ad2:	10 20       	jnz	$+34     	;abs 0x5af4

00005ad4 <.L58>:
  if (uartp->txstate == UART_TX_IDLE) {
    5ad4:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    5ad8:	08 20       	jnz	$+18     	;abs 0x5aea

00005ada <.Loc.187.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    5ada:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5ade:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

00005ae2 <.Loc.190.1>:
    uartp->regs->ie |= UCTXCPTIE;
    5ae2:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5ae6:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

00005aea <.L55>:
}
    5aea:	0a 17       	popm	#1,	r10	;16-bit words
    5aec:	30 41       	ret			

00005aee <.L60>:
  _uart_tx1_isr_code(uartp);
    5aee:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00
    5af2:	ed 3f       	jmp	$-36     	;abs 0x5ace

00005af4 <.L61>:
    5af4:	4d 43       	clr.b	r13		;
    5af6:	0c 4a       	mov	r10,	r12	;
    5af8:	3c 50 0a 00 	add	#10,	r12	;#0x000a

00005afc <.LVL101>:
    5afc:	b0 12 2a 46 	call	#17962		;#0x462a

00005b00 <.LVL102>:
    5b00:	e9 3f       	jmp	$-44     	;abs 0x5ad4

00005b02 <init_transfer>:
    5b02:	2a 15       	pushm	#3,	r10	;16-bit words

00005b04 <.LCFI4>:
static void init_transfer(msp430x_dma_ch_t * dma, msp430x_dma_req_t * req, bool *acquired) {
    5b04:	0a 4c       	mov	r12,	r10	;

00005b06 <L0>:
    5b06:	08 4d       	mov	r13,	r8	;
    5b08:	09 4e       	mov	r14,	r9	;

00005b0a <.Loc.171.1>:
  if (!(*acquired)) {
    5b0a:	ce 93 00 00 	cmp.b	#0,	0(r14)	;r3 As==00
    5b0e:	06 24       	jz	$+14     	;abs 0x5b1c

00005b10 <.L63>:
  dmaTransferI(dma, req);
    5b10:	0d 48       	mov	r8,	r13	;
    5b12:	0c 4a       	mov	r10,	r12	;
    5b14:	b0 12 74 50 	call	#20596		;#0x5074

00005b18 <.LVL105>:
}
    5b18:	28 17       	popm	#3,	r10	;16-bit words
    5b1a:	30 41       	ret			

00005b1c <.L64>:
    dmaAcquireI(dma);
    5b1c:	b0 12 d6 4f 	call	#20438		;#0x4fd6

00005b20 <.LVL106>:
    (*acquired) = true;
    5b20:	d9 43 00 00 	mov.b	#1,	0(r9)	;r3 As==01
    5b24:	f5 3f       	jmp	$-20     	;abs 0x5b10

00005b26 <ISR_USCI_A0_VECTOR>:
    5b26:	bf 15       	pushm	#12,	r15	;16-bit words

00005b28 <L0>:
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

#if MSP430X_UART_USE_UARTA0 == TRUE
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
  OSAL_IRQ_PROLOGUE();
    5b28:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00005b2c <.Loc.214.1>:

  switch(__even_in_range(UCA0IV, UCTXCPTIFG)) {
    5b2c:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    5b30:	2c 92       	cmp	#4,	r12	;r2 As==10
    5b32:	4c 24       	jz	$+154    	;abs 0x5bcc
    5b34:	6d 42       	mov.b	#4,	r13	;r2 As==10
    5b36:	0d 9c       	cmp	r12,	r13	;
    5b38:	0d 2c       	jc	$+28     	;abs 0x5b54
    5b3a:	3c 90 06 00 	cmp	#6,	r12	;
    5b3e:	46 24       	jz	$+142    	;abs 0x5bcc
    5b40:	3c 92       	cmp	#8,	r12	;r2 As==11
    5b42:	48 20       	jnz	$+146    	;abs 0x5bd4

00005b44 <.Loc.249.1>:
    case USCI_UART_UCTXIFG:
    case USCI_UART_UCSTTIFG:
      osalDbgAssert(false, "Spurious interrupt in USCI A0 UART");
      break;
    case USCI_UART_UCTXCPTIFG:
      if (UARTDA0.txcpt_first) {
    5b44:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5b48:	cc 93 42 00 	cmp.b	#0,	66(r12)	;r3 As==00, 0x0042
    5b4c:	4b 24       	jz	$+152    	;abs 0x5be4

00005b4e <.Loc.250.1>:
        UARTDA0.txcpt_first = false;
    5b4e:	c2 43 a8 b5 	mov.b	#0,	&0xb5a8	;r3 As==00
    5b52:	40 3c       	jmp	$+130    	;abs 0x5bd4

00005b54 <.L83>:
  switch(__even_in_range(UCA0IV, UCTXCPTIFG)) {
    5b54:	2c 93       	cmp	#2,	r12	;r3 As==10
    5b56:	3e 20       	jnz	$+126    	;abs 0x5bd4

00005b58 <.Loc.219.1>:
      if (UCA0STATW & UCRXERR) {
    5b58:	e2 b2 ca 05 	bit.b	#4,	&0x05ca	;r2 As==10
    5b5c:	24 24       	jz	$+74     	;abs 0x5ba6

00005b5e <.LBB35>:
        if (UCA0STATW & UCBRK)
    5b5e:	f2 b2 ca 05 	bit.b	#8,	&0x05ca	;r2 As==11
    5b62:	2d 20       	jnz	$+92     	;abs 0x5bbe

00005b64 <.Loc.221.1>:
        uartflags_t sts = 0;
    5b64:	4d 43       	clr.b	r13		;
    5b66:	0e 4d       	mov	r13,	r14	;

00005b68 <.L72>:
        if (UCA0STATW & UCOE)
    5b68:	f2 b0 20 00 	bit.b	#32,	&0x05ca	;#0x0020
    5b6c:	ca 05 
    5b6e:	02 24       	jz	$+6      	;abs 0x5b74

00005b70 <.Loc.226.1>:
          sts |= UART_OVERRUN_ERROR;
    5b70:	3d d0 10 00 	bis	#16,	r13	;#0x0010

00005b74 <.L73>:
        if (UCA0STATW & UCFE)
    5b74:	f2 b0 40 00 	bit.b	#64,	&0x05ca	;#0x0040
    5b78:	ca 05 
    5b7a:	01 24       	jz	$+4      	;abs 0x5b7e

00005b7c <.Loc.228.1>:
          sts |= UART_FRAMING_ERROR;
    5b7c:	3d d2       	bis	#8,	r13	;r2 As==11

00005b7e <.L74>:
        if (UCA0STATW & UCPE)
    5b7e:	f2 b0 10 00 	bit.b	#16,	&0x05ca	;#0x0010
    5b82:	ca 05 
    5b84:	01 24       	jz	$+4      	;abs 0x5b88

00005b86 <.Loc.230.1>:
          sts |= UART_PARITY_ERROR;
    5b86:	2d d2       	bis	#4,	r13	;r2 As==10

00005b88 <.L75>:
        _uart_rx_error_isr_code(&UARTDA0, sts);
    5b88:	1c 42 6a b5 	mov	&0xb56a,r12	;0xb56a
    5b8c:	1f 4c 08 00 	mov	8(r12),	r15	;
    5b90:	0f 93       	cmp	#0,	r15	;r3 As==00
    5b92:	03 24       	jz	$+8      	;abs 0x5b9a

00005b94 <.Loc.232.1>:
    5b94:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5b98:	8f 12       	call	r15		;

00005b9a <.L76>:
    5b9a:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    5b9e:	3c 40 6e b5 	mov	#-19090,r12	;#0xb56e

00005ba2 <.LVL113>:
    5ba2:	b0 12 2a 46 	call	#17962		;#0x462a

00005ba6 <.L71>:
      if (UARTDA0.config->rxchar_cb != NULL) {
    5ba6:	1c 42 6a b5 	mov	&0xb56a,r12	;0xb56a
    5baa:	1e 4c 06 00 	mov	6(r12),	r14	;
    5bae:	0e 93       	cmp	#0,	r14	;r3 As==00
    5bb0:	0a 24       	jz	$+22     	;abs 0x5bc6

00005bb2 <.Loc.237.1>:
        UARTDA0.config->rxchar_cb(&UARTDA0, UCA0RXBUF);
    5bb2:	1d 42 cc 05 	mov	&0x05cc,r13	;0x05cc
    5bb6:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5bba:	8e 12       	call	r14		;

00005bbc <.LVL115>:
    5bbc:	0b 3c       	jmp	$+24     	;abs 0x5bd4

00005bbe <.L82>:
          sts |= UART_BREAK_DETECTED;
    5bbe:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    5bc2:	4e 43       	clr.b	r14		;
    5bc4:	d1 3f       	jmp	$-92     	;abs 0x5b68

00005bc6 <.L77>:
        UCA0IFG &= ~UCRXIFG;
    5bc6:	92 c3 dc 05 	bic	#1,	&0x05dc	;r3 As==01
    5bca:	04 3c       	jmp	$+10     	;abs 0x5bd4

00005bcc <.L67>:
      osalDbgAssert(false, "Spurious interrupt in USCI A0 UART");
    5bcc:	3c 40 a0 b0 	mov	#-20320,r12	;#0xb0a0
    5bd0:	b0 12 a6 44 	call	#17574		;#0x44a6

00005bd4 <.L66>:
        UARTDA0.txcpt_first = true;
      }
      break;
  }
  
  OSAL_IRQ_EPILOGUE();
    5bd4:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    5bd8:	b0 12 7a 45 	call	#17786		;#0x457a

00005bdc <.LVL119>:
    5bdc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5bde:	1d 20       	jnz	$+60     	;abs 0x5c1a

00005be0 <.L65>:
}
    5be0:	b4 17       	popm	#12,	r15	;16-bit words
    5be2:	00 13       	reti			

00005be4 <.L78>:
        _uart_tx2_isr_code(&UARTDA0);
    5be4:	1c 42 6a b5 	mov	&0xb56a,r12	;0xb56a
    5be8:	1d 4c 02 00 	mov	2(r12),	r13	;
    5bec:	0d 93       	cmp	#0,	r13	;r3 As==00
    5bee:	03 24       	jz	$+8      	;abs 0x5bf6

00005bf0 <.Loc.254.1>:
    5bf0:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5bf4:	8d 12       	call	r13		;

00005bf6 <.L79>:
    5bf6:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5bfa:	cc 93 06 00 	cmp.b	#0,	6(r12)	;r3 As==00
    5bfe:	07 24       	jz	$+16     	;abs 0x5c0e

00005c00 <.L80>:
        UCA0IE &= ~UCTXCPTIE;
    5c00:	b2 c2 da 05 	bic	#8,	&0x05da	;r2 As==11

00005c04 <.Loc.258.1>:
        UCA0IFG &= ~UCTXCPTIFG;
    5c04:	b2 c2 dc 05 	bic	#8,	&0x05dc	;r2 As==11

00005c08 <.Loc.259.1>:
        UARTDA0.txcpt_first = true;
    5c08:	d2 43 a8 b5 	mov.b	#1,	&0xb5a8	;r3 As==01
    5c0c:	e3 3f       	jmp	$-56     	;abs 0x5bd4

00005c0e <.L85>:
    5c0e:	4d 43       	clr.b	r13		;
    5c10:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    5c14:	b0 12 2a 46 	call	#17962		;#0x462a

00005c18 <.LVL122>:
    5c18:	f3 3f       	jmp	$-24     	;abs 0x5c00

00005c1a <.L84>:
  OSAL_IRQ_EPILOGUE();
    5c1a:	b0 12 92 45 	call	#17810		;#0x4592

00005c1e <.LVL124>:
}
    5c1e:	e0 3f       	jmp	$-62     	;abs 0x5be0

00005c20 <uart_lld_init>:
    5c20:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
 */
void uart_lld_init(void) {

#if MSP430X_UART_USE_UARTA0 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA0);
    5c24:	b0 12 48 4c 	call	#19528		;#0x4c48

00005c28 <.LVL125>:
  UARTDA0.regs = (msp430x_uart_reg_t  *)(&UCA0CTLW0);
    5c28:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    5c2c:	bc 40       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00005c2e <L0>:
    5c2e:	c0 05       	mova	r5,	r0	;
    5c30:	10 00       	bra	@r0+		;

00005c32 <.Loc.457.1>:
  UARTDA0.freq = MSP430X_UARTA0_CLK_FREQ;
    5c32:	bc 40 00 24 	mov	#9216,	12(r12)	;#0x2400, 0x000c
    5c36:	0c 00 
    5c38:	bc 40 f4 00 	mov	#244,	14(r12)	;#0x00f4, 0x000e
    5c3c:	0e 00 

00005c3e <.Loc.458.1>:
  UARTDA0.dmareq_tx.dest_addr = (void*)(&UCA0TXBUF);
    5c3e:	bc 40 ce 05 	mov	#1486,	20(r12)	;#0x05ce, 0x0014
    5c42:	14 00 

00005c44 <.Loc.459.1>:
  UARTDA0.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    5c44:	bc 40 00 03 	mov	#768,	24(r12)	;#0x0300, 0x0018
    5c48:	18 00 

00005c4a <.Loc.460.1>:
  UARTDA0.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5c4a:	bc 40 c0 00 	mov	#192,	26(r12)	;#0x00c0, 0x001a
    5c4e:	1a 00 

00005c50 <.Loc.461.1>:
  UARTDA0.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    5c50:	8c 43 1c 00 	mov	#0,	28(r12)	;r3 As==00, 0x001c

00005c54 <.Loc.462.1>:
  UARTDA0.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA0TXIFG);
    5c54:	bc 40 0f 00 	mov	#15,	30(r12)	;#0x000f, 0x001e
    5c58:	1e 00 

00005c5a <.Loc.463.1>:
  UARTDA0.dmareq_rx.source_addr = (void*)(&UCA0RXBUF);
    5c5a:	bc 40 cc 05 	mov	#1484,	36(r12)	;#0x05cc, 0x0024
    5c5e:	24 00 

00005c60 <.Loc.464.1>:
  UARTDA0.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    5c60:	bc 40 00 0c 	mov	#3072,	42(r12)	;#0x0c00, 0x002a
    5c64:	2a 00 

00005c66 <.Loc.465.1>:
  UARTDA0.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5c66:	bc 40 c0 00 	mov	#192,	44(r12)	;#0x00c0, 0x002c
    5c6a:	2c 00 

00005c6c <.Loc.466.1>:
  UARTDA0.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    5c6c:	8c 43 2e 00 	mov	#0,	46(r12)	;r3 As==00, 0x002e

00005c70 <.Loc.467.1>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
    5c70:	bc 40 0e 00 	mov	#14,	48(r12)	;#0x000e, 0x0030
    5c74:	30 00 

00005c76 <.Loc.468.1>:
  UARTDA0.txcpt_first = true;
    5c76:	dc 43 42 00 	mov.b	#1,	66(r12)	;r3 As==01, 0x0042

00005c7a <.Loc.525.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    5c7a:	30 41       	ret			

00005c7c <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    5c7c:	1a 15       	pushm	#2,	r10	;16-bit words

00005c7e <.LCFI6>:
    5c7e:	0a 4c       	mov	r12,	r10	;

00005c80 <.Loc.536.1>:

  if (uartp->state != UART_STOP) {
    5c80:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    5c84:	0b 24       	jz	$+24     	;abs 0x5c9c

00005c86 <.L89>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    5c86:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5c8a:	ac b3 1c 00 	bit	#2,	28(r12)	;r3 As==10, 0x001c
    5c8e:	fb 27       	jz	$-8      	;abs 0x5c86

00005c90 <.Loc.541.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    5c90:	ca 93 43 00 	cmp.b	#0,	67(r10)	;r3 As==00, 0x0043
    5c94:	40 20       	jnz	$+130    	;abs 0x5d16

00005c96 <.L90>:
      dmaReleaseX(&(uartp->dma_tx));
    }
    if (uartp->dma_acquired_rx) {
    5c96:	ca 93 44 00 	cmp.b	#0,	68(r10)	;r3 As==00, 0x0044
    5c9a:	43 20       	jnz	$+136    	;abs 0x5d22

00005c9c <.L88>:
      dmaReleaseX(&(uartp->dma_rx));
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    5c9c:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5ca0:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

00005ca4 <.Loc.551.1>:
  set_baud(uartp);
    5ca4:	0c 4a       	mov	r10,	r12	;
    5ca6:	b0 12 bc 59 	call	#22972		;#0x59bc

00005caa <.LVL128>:
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    5caa:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    5cae:	1c 4a 04 00 	mov	4(r10),	r12	;
    5cb2:	5c 4c 0e 00 	mov.b	14(r12),r12	;0x0000e
    5cb6:	5c 0f       	rrum	#4,	r12	;
    5cb8:	5c 03       	rrum	#1,	r12	;
    5cba:	5c f3       	and.b	#1,	r12	;r3 As==01
    5cbc:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    5cc0:	8d 4c 10 00 	mov	r12,	16(r13)	; 0x0010

00005cc4 <.Loc.556.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    5cc4:	1c 4a 04 00 	mov	4(r10),	r12	;
    5cc8:	5d 4c 0f 00 	mov.b	15(r12),r13	;0x0000f
    5ccc:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    5cd0:	4c 4d       	mov.b	r13,	r12	;
    5cd2:	6e 43       	mov.b	#2,	r14	;r3 As==10
    5cd4:	0e 9c       	cmp	r12,	r14	;
    5cd6:	2b 34       	jge	$+88     	;abs 0x5d2e

00005cd8 <.Loc.562.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_tx = !b;
  }
  else {
    uartp->dma_acquired_tx = false;
    5cd8:	ca 43 43 00 	mov.b	#0,	67(r10)	;r3 As==00, 0x0043

00005cdc <.L94>:
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    5cdc:	1c 4a 04 00 	mov	4(r10),	r12	;
    5ce0:	5d 4c 0f 00 	mov.b	15(r12),r13	;0x0000f
    5ce4:	5d 0f       	rrum	#4,	r13	;
    5ce6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5ce8:	0c 9d       	cmp	r13,	r12	;
    5cea:	35 34       	jge	$+108    	;abs 0x5d56

00005cec <.Loc.570.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_rx = !b;
  }
  else {
    uartp->dma_acquired_rx = false;
    5cec:	ca 43 44 00 	mov.b	#0,	68(r10)	;r3 As==00, 0x0044

00005cf0 <.L98>:
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    5cf0:	ba 40 b2 5a 	mov	#23218,	32(r10)	;#0x5ab2, 0x0020
    5cf4:	20 00 

00005cf6 <.Loc.575.1>:
  uartp->dmareq_tx.callback.args = uartp;
    5cf6:	8a 4a 22 00 	mov	r10,	34(r10)	; 0x0022

00005cfa <.Loc.576.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    5cfa:	ba 40 7a 5a 	mov	#23162,	50(r10)	;#0x5a7a, 0x0032
    5cfe:	32 00 

00005d00 <.Loc.577.1>:
  uartp->dmareq_rx.callback.args = uartp;
    5d00:	8a 4a 34 00 	mov	r10,	52(r10)	; 0x0034

00005d04 <.Loc.579.1>:
#if MSP430X_UART_USE_UARTA0 == TRUE
  if (&UARTDA0 == uartp) {
    5d04:	3a 90 66 b5 	cmp	#-19098,r10	;#0xb566
    5d08:	3a 24       	jz	$+118    	;abs 0x5d7e

00005d0a <.L99>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    5d0a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5d0e:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005d12 <.Loc.627.1>:
}
    5d12:	19 17       	popm	#2,	r10	;16-bit words
    5d14:	30 41       	ret			

00005d16 <.L100>:
      dmaReleaseX(&(uartp->dma_tx));
    5d16:	0c 4a       	mov	r10,	r12	;
    5d18:	3c 50 36 00 	add	#54,	r12	;#0x0036
    5d1c:	b0 12 e6 50 	call	#20710		;#0x50e6

00005d20 <.LVL129>:
    5d20:	ba 3f       	jmp	$-138    	;abs 0x5c96

00005d22 <.L101>:
      dmaReleaseX(&(uartp->dma_rx));
    5d22:	0c 4a       	mov	r10,	r12	;
    5d24:	3c 50 3c 00 	add	#60,	r12	;#0x003c
    5d28:	b0 12 e6 50 	call	#20710		;#0x50e6

00005d2c <.LVL130>:
    5d2c:	b7 3f       	jmp	$-144    	;abs 0x5c9c

00005d2e <.L102>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    5d2e:	0c 4a       	mov	r10,	r12	;
    5d30:	3c 50 36 00 	add	#54,	r12	;#0x0036
    5d34:	b0 12 28 50 	call	#20520		;#0x5028

00005d38 <.LVL131>:
    5d38:	09 4c       	mov	r12,	r9	;

00005d3a <.LVL132>:
    osalDbgAssert(!b, "stream already allocated");
    5d3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d3c:	07 20       	jnz	$+16     	;abs 0x5d4c

00005d3e <.L92>:
    uartp->dma_acquired_tx = !b;
    5d3e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5d40:	09 93       	cmp	#0,	r9	;r3 As==00
    5d42:	01 24       	jz	$+4      	;abs 0x5d46
    5d44:	4c 43       	clr.b	r12		;

00005d46 <.L93>:
    5d46:	ca 4c 43 00 	mov.b	r12,	67(r10)	; 0x0043
    5d4a:	c8 3f       	jmp	$-110    	;abs 0x5cdc

00005d4c <.L105>:
    osalDbgAssert(!b, "stream already allocated");
    5d4c:	3c 40 91 b0 	mov	#-20335,r12	;#0xb091
    5d50:	b0 12 a6 44 	call	#17574		;#0x44a6

00005d54 <.LVL133>:
    5d54:	f4 3f       	jmp	$-22     	;abs 0x5d3e

00005d56 <.L103>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    5d56:	0c 4a       	mov	r10,	r12	;
    5d58:	3c 50 3c 00 	add	#60,	r12	;#0x003c
    5d5c:	b0 12 28 50 	call	#20520		;#0x5028

00005d60 <.LVL135>:
    5d60:	09 4c       	mov	r12,	r9	;

00005d62 <.LVL136>:
    osalDbgAssert(!b, "stream already allocated");
    5d62:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d64:	07 20       	jnz	$+16     	;abs 0x5d74

00005d66 <.L96>:
    uartp->dma_acquired_rx = !b;
    5d66:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5d68:	09 93       	cmp	#0,	r9	;r3 As==00
    5d6a:	01 24       	jz	$+4      	;abs 0x5d6e
    5d6c:	4c 43       	clr.b	r12		;

00005d6e <.L97>:
    5d6e:	ca 4c 44 00 	mov.b	r12,	68(r10)	; 0x0044
    5d72:	be 3f       	jmp	$-130    	;abs 0x5cf0

00005d74 <.L106>:
    osalDbgAssert(!b, "stream already allocated");
    5d74:	3c 40 91 b0 	mov	#-20335,r12	;#0xb091
    5d78:	b0 12 a6 44 	call	#17574		;#0x44a6

00005d7c <.LVL137>:
    5d7c:	f4 3f       	jmp	$-22     	;abs 0x5d66

00005d7e <.L104>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5d7e:	1e 4a 10 00 	mov	16(r10),r14	;0x00010
    5d82:	1d 4a 04 00 	mov	4(r10),	r13	;
    5d86:	5c 4d 0e 00 	mov.b	14(r13),r12	;0x0000e
    5d8a:	4d 18 0c 5c 	rpt #14 { rlax.w	r12		;

00005d8e <.Loc.581.1>:
        (uartp->config->order << 13) | 
    5d8e:	5d 4d 0e 00 	mov.b	14(r13),r13	;0x0000e
    5d92:	0f 4d       	mov	r13,	r15	;
    5d94:	5f 07       	rrum	#2,	r15	;
    5d96:	5f f3       	and.b	#1,	r15	;r3 As==01
    5d98:	4c 18 0f 5f 	rpt #13 { rlax.w	r15		;

00005d9c <.Loc.580.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5d9c:	0c df       	bis	r15,	r12	;

00005d9e <.Loc.582.1>:
        (uartp->config->char_size << 12) | 
    5d9e:	0f 4d       	mov	r13,	r15	;
    5da0:	5f 0b       	rrum	#3,	r15	;
    5da2:	5f f3       	and.b	#1,	r15	;r3 As==01
    5da4:	4b 18 0f 5f 	rpt #12 { rlax.w	r15		;

00005da8 <.Loc.581.1>:
        (uartp->config->order << 13) | 
    5da8:	0c df       	bis	r15,	r12	;

00005daa <.Loc.583.1>:
        (uartp->config->stop_bits << 11) |
    5daa:	0f 4d       	mov	r13,	r15	;
    5dac:	5f 0f       	rrum	#4,	r15	;
    5dae:	5f f3       	and.b	#1,	r15	;r3 As==01
    5db0:	4a 18 0f 5f 	rpt #11 { rlax.w	r15		;

00005db4 <.Loc.582.1>:
        (uartp->config->char_size << 12) | 
    5db4:	0c df       	bis	r15,	r12	;

00005db6 <.Loc.584.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5db6:	5d 0f       	rrum	#4,	r13	;
    5db8:	5d 03       	rrum	#1,	r13	;
    5dba:	5d f3       	and.b	#1,	r13	;r3 As==01
    5dbc:	0f 4d       	mov	r13,	r15	;
    5dbe:	49 18 0f 5f 	rpt #10 { rlax.w	r15		;

00005dc2 <.Loc.583.1>:
        (uartp->config->stop_bits << 11) |
    5dc2:	0c df       	bis	r15,	r12	;

00005dc4 <.Loc.584.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5dc4:	48 18 0d 5d 	rpt #9 { rlax.w	r13		;
    5dc8:	0c dd       	bis	r13,	r12	;

00005dca <.Loc.580.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5dca:	3c d0 b0 00 	bis	#176,	r12	;#0x00b0
    5dce:	8e 4c 00 00 	mov	r12,	0(r14)	;
    5dd2:	9b 3f       	jmp	$-200    	;abs 0x5d0a

00005dd4 <uart_lld_start_send>:
    5dd4:	0a 15       	pushm	#1,	r10	;16-bit words

00005dd6 <.LCFI8>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    5dd6:	0a 4c       	mov	r12,	r10	;

00005dd8 <.Loc.660.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    5dd8:	8c 4e 12 00 	mov	r14,	18(r12)	; 0x0012

00005ddc <.Loc.661.1>:
  uartp->dmareq_tx.size = n;
    5ddc:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016

00005de0 <.L111>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    5de0:	1c 4a       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00005de2 <L0>:
    5de2:	10 00       	bra	@r0+		;
    5de4:	ac b3 1c 00 	bit	#2,	28(r12)	;r3 As==10, 0x001c
    5de8:	fb 27       	jz	$-8      	;abs 0x5de0

00005dea <.Loc.664.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    5dea:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

00005dee <.Loc.666.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    5dee:	0e 4a       	mov	r10,	r14	;

00005df0 <.LVL145>:
    5df0:	3e 50 43 00 	add	#67,	r14	;#0x0043
    5df4:	0d 4a       	mov	r10,	r13	;

00005df6 <.LVL146>:
    5df6:	3d 50 12 00 	add	#18,	r13	;#0x0012
    5dfa:	0c 4a       	mov	r10,	r12	;
    5dfc:	3c 50 36 00 	add	#54,	r12	;#0x0036
    5e00:	b0 12 02 5b 	call	#23298		;#0x5b02

00005e04 <.LVL147>:
  
  uartp->regs->ifg |= UCTXIFG;
    5e04:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5e08:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00005e0c <.Loc.669.1>:
}
    5e0c:	0a 17       	popm	#1,	r10	;16-bit words
    5e0e:	30 41       	ret			

00005e10 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    5e10:	0a 15       	pushm	#1,	r10	;16-bit words

00005e12 <.LCFI10>:
    5e12:	0a 4c       	mov	r12,	r10	;

00005e14 <.Loc.707.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    5e14:	8c 4e 26 00 	mov	r14,	38(r12)	; 0x0026

00005e18 <.Loc.708.1>:
  uartp->dmareq_rx.size = n;
    5e18:	8c 4d 28 00 	mov	r13,	40(r12)	; 0x0028

00005e1c <.Loc.711.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    5e1c:	1c 4c 10 00 	mov	16(r12),r12	;0x00010

00005e20 <.LVL155>:
    5e20:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00005e24 <.Loc.713.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    5e24:	0e 4a       	mov	r10,	r14	;

00005e26 <.LVL156>:
    5e26:	3e 50 44 00 	add	#68,	r14	;#0x0044
    5e2a:	0d 4a       	mov	r10,	r13	;

00005e2c <.LVL157>:
    5e2c:	3d 50 24 00 	add	#36,	r13	;#0x0024
    5e30:	0c 4a       	mov	r10,	r12	;
    5e32:	3c 50 3c 00 	add	#60,	r12	;#0x003c
    5e36:	b0 12 02 5b 	call	#23298		;#0x5b02

00005e3a <.LVL158>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    5e3a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5e3e:	9c b3 1c 00 	bit	#1,	28(r12)	;r3 As==01, 0x001c
    5e42:	06 24       	jz	$+14     	;abs 0x5e50

00005e44 <.Loc.717.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    5e44:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005e48 <.Loc.718.1>:
    uartp->regs->ifg |= UCRXIFG;
    5e48:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5e4c:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00005e50 <.L115>:
  }
}
    5e50:	0a 17       	popm	#1,	r10	;16-bit words
    5e52:	30 41       	ret			

00005e54 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    5e54:	2a 15       	pushm	#3,	r10	;16-bit words

00005e56 <.LCFI11>:
    5e56:	0a 4c       	mov	r12,	r10	;

00005e58 <.Loc.735.1>:

  size_t result = uartp->dma_rx.registers->sz;
    5e58:	1c 4c 3c 00 	mov	60(r12),r12	;0x0003c

00005e5c <.LVL160>:
    5e5c:	18 4c 0a 00 	mov	10(r12),r8	;0x0000a

00005e60 <.Loc.736.1>:
  dmaCancelI(&(uartp->dma_rx));
    5e60:	09 4a       	mov	r10,	r9	;
    5e62:	39 50 3c 00 	add	#60,	r9	;#0x003c
    5e66:	0c 49       	mov	r9,	r12	;
    5e68:	b0 12 2a 51 	call	#20778		;#0x512a

00005e6c <.LVL162>:
  if (uartp->dma_acquired_rx) {
    5e6c:	ca 93 44 00 	cmp.b	#0,	68(r10)	;r3 As==00, 0x0044
    5e70:	0b 20       	jnz	$+24     	;abs 0x5e88

00005e72 <.L118>:
    dmaReleaseX(&(uartp->dma_rx));
  }
  
  uartp->regs->ifg &= ~UCRXIFG;
    5e72:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5e76:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005e7a <.Loc.742.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    5e7a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5e7e:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005e82 <.Loc.745.1>:

  return result;
}
    5e82:	0c 48       	mov	r8,	r12	;
    5e84:	28 17       	popm	#3,	r10	;16-bit words
    5e86:	30 41       	ret			

00005e88 <.L119>:
    dmaReleaseX(&(uartp->dma_rx));
    5e88:	0c 49       	mov	r9,	r12	;
    5e8a:	b0 12 e6 50 	call	#20710		;#0x50e6

00005e8e <.LVL163>:
    5e8e:	f1 3f       	jmp	$-28     	;abs 0x5e72

00005e90 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    5e90:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00005e92 <L0>:
    5e92:	ac b5 bc 40 	bit	@r5,	16572(r12); 0x40bc
    5e96:	80 03 04 00 	mova	#196612,r0	;0x30004

00005e9a <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    5e9a:	b0 12 12 4b 	call	#19218		;#0x4b12

00005e9e <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    5e9e:	30 41       	ret			

00005ea0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    5ea0:	2a 15       	pushm	#3,	r10	;16-bit words

00005ea2 <.LCFI0>:
    5ea2:	0a 4c       	mov	r12,	r10	;

00005ea4 <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    5ea4:	3c 90 ac b5 	cmp	#-19028,r12	;#0xb5ac
    5ea8:	29 24       	jz	$+84     	;abs 0x5efc

00005eaa <.Loc.286.1>:
  uint32_t divider = 0;
    5eaa:	48 43       	clr.b	r8		;
    5eac:	49 43       	clr.b	r9		;

00005eae <.L3>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5eae:	09 93       	cmp	#0,	r9	;r3 As==00
    5eb0:	3b 20       	jnz	$+120    	;abs 0x5f28
    5eb2:	09 93       	cmp	#0,	r9	;r3 As==00
    5eb4:	35 24       	jz	$+108    	;abs 0x5f20

00005eb6 <.L4>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    5eb6:	0c 48       	mov	r8,	r12	;
    5eb8:	7c f0 07 00 	and.b	#7,	r12	;
    5ebc:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ebe:	39 20       	jnz	$+116    	;abs 0x5f32

00005ec0 <.Loc.345.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    5ec0:	1c 4a 04 00 	mov	4(r10),	r12	;
    5ec4:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    5ec8:	00 00 

00005eca <.Loc.346.1>:
    divider /= 8;
    5eca:	0c 48       	mov	r8,	r12	;
    5ecc:	0d 49       	mov	r9,	r13	;
    5ece:	b0 12 30 ad 	call	#-21200	;#0xad30
    5ed2:	08 4c       	mov	r12,	r8	;

00005ed4 <.LVL5>:
    5ed4:	09 4d       	mov	r13,	r9	;

00005ed6 <.L7>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    5ed6:	09 93       	cmp	#0,	r9	;r3 As==00
    5ed8:	05 20       	jnz	$+12     	;abs 0x5ee4
    5eda:	09 93       	cmp	#0,	r9	;r3 As==00
    5edc:	07 20       	jnz	$+16     	;abs 0x5eec
    5ede:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5ee0:	0d 98       	cmp	r8,	r13	;
    5ee2:	04 2c       	jc	$+10     	;abs 0x5eec

00005ee4 <.L13>:
    5ee4:	3c 40 b3 b0 	mov	#-20301,r12	;#0xb0b3
    5ee8:	b0 12 a6 44 	call	#17574		;#0x44a6

00005eec <.L9>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    5eec:	1c 4a 04 00 	mov	4(r10),	r12	;
    5ef0:	0d 48       	mov	r8,	r13	;
    5ef2:	3d 53       	add	#-1,	r13	;r3 As==11
    5ef4:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

00005ef8 <.Loc.359.1>:

}
    5ef8:	28 17       	popm	#3,	r10	;16-bit words
    5efa:	30 41       	ret			

00005efc <.L14>:
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    5efc:	1c 4c 04 00 	mov	4(r12),	r12	;
    5f00:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    5f04:	00 00 

00005f06 <.Loc.304.1>:
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    5f06:	1c 4a 02 00 	mov	2(r10),	r12	;
    5f0a:	2e 4c       	mov	@r12,	r14	;
    5f0c:	1f 4c 02 00 	mov	2(r12),	r15	;
    5f10:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    5f14:	4d 43       	clr.b	r13		;
    5f16:	b0 12 1c ac 	call	#-21476	;#0xac1c
    5f1a:	08 4c       	mov	r12,	r8	;
    5f1c:	09 4d       	mov	r13,	r9	;

00005f1e <.LVL10>:
    5f1e:	c7 3f       	jmp	$-112    	;abs 0x5eae

00005f20 <.L15>:
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5f20:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    5f24:	0c 98       	cmp	r8,	r12	;
    5f26:	c7 2f       	jc	$-112    	;abs 0x5eb6

00005f28 <.L12>:
    5f28:	3c 40 b3 b0 	mov	#-20301,r12	;#0xb0b3
    5f2c:	b0 12 a6 44 	call	#17574		;#0x44a6

00005f30 <.LVL11>:
    5f30:	c2 3f       	jmp	$-122    	;abs 0x5eb6

00005f32 <.L6>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    5f32:	0c 48       	mov	r8,	r12	;
    5f34:	7c f0 03 00 	and.b	#3,	r12	;
    5f38:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f3a:	0c 20       	jnz	$+26     	;abs 0x5f54

00005f3c <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    5f3c:	1c 4a 04 00 	mov	4(r10),	r12	;
    5f40:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    5f44:	00 00 

00005f46 <.Loc.350.1>:
    divider /= 4;
    5f46:	40 19 09 10 	rrux.w	r9		;
    5f4a:	08 10       	rrc	r8		;
    5f4c:	40 19 09 10 	rrux.w	r9		;
    5f50:	08 10       	rrc	r8		;
    5f52:	c1 3f       	jmp	$-124    	;abs 0x5ed6

00005f54 <.L8>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    5f54:	0c 48       	mov	r8,	r12	;
    5f56:	5c f3       	and.b	#1,	r12	;r3 As==01
    5f58:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f5a:	bd 23       	jnz	$-132    	;abs 0x5ed6

00005f5c <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    5f5c:	1c 4a 04 00 	mov	4(r10),	r12	;
    5f60:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    5f64:	00 00 

00005f66 <.Loc.354.1>:
    divider /= 2;
    5f66:	12 c3       	clrc			
    5f68:	09 10       	rrc	r9		;
    5f6a:	08 10       	rrc	r8		;
    5f6c:	b4 3f       	jmp	$-150    	;abs 0x5ed6

00005f6e <gpt_lld_start_timer>:
    5f6e:	1e 4c 02 00 	mov	2(r12),	r14	;
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    5f72:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00

00005f76 <L0>:
    5f76:	04 24       	jz	$+10     	;abs 0x5f80

00005f78 <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    5f78:	1e 4c 04 00 	mov	4(r12),	r14	;
    5f7c:	ae d3 00 00 	bis	#2,	0(r14)	;r3 As==10

00005f80 <.L20>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
    5f80:	1e 4c 04 00 	mov	4(r12),	r14	;
    5f84:	ae d2 00 00 	bis	#4,	0(r14)	;r2 As==10

00005f88 <.Loc.395.1>:
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    5f88:	1e 4c 04 00 	mov	4(r12),	r14	;
    5f8c:	8e 4d 12 00 	mov	r13,	18(r14)	; 0x0012

00005f90 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    5f90:	1c 4c 04 00 	mov	4(r12),	r12	;

00005f94 <.LVL19>:
    5f94:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    5f98:	00 00 

00005f9a <.Loc.398.1>:
}
    5f9a:	30 41       	ret			

00005f9c <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    5f9c:	1c 4c 04 00 	mov	4(r12),	r12	;

00005fa0 <.LVL21>:
    5fa0:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    5fa4:	00 00 

00005fa6 <.Loc.412.1>:

}
    5fa6:	30 41       	ret			

00005fa8 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    5fa8:	bf 15       	pushm	#12,	r15	;16-bit words

00005faa <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    5faa:	d2 43 ee b4 	mov.b	#1,	&0xb4ee	;r3 As==01

00005fae <.Loc.119.1>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    5fae:	1c 42 ae 03 	mov	&0x03ae,r12	;0x03ae
    5fb2:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    5fb6:	0a 20       	jnz	$+22     	;abs 0x5fcc

00005fb8 <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    5fb8:	5c 42 ac b5 	mov.b	&0xb5ac,r12	;0xb5ac
    5fbc:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    5fc0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5fc2:	4d 9c       	cmp.b	r12,	r13	;
    5fc4:	0b 2c       	jc	$+24     	;abs 0x5fdc

00005fc6 <.L25>:
      if (GPTDA1.state == GPT_ONESHOT) {
    5fc6:	e2 92 ac b5 	cmp.b	#4,	&0xb5ac	;r2 As==10
    5fca:	12 24       	jz	$+38     	;abs 0x5ff0

00005fcc <.L23>:
  OSAL_IRQ_EPILOGUE();
    5fcc:	c2 43 ee b4 	mov.b	#0,	&0xb4ee	;r3 As==00
    5fd0:	b0 12 7a 45 	call	#17786		;#0x457a

00005fd4 <.LVL22>:
    5fd4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5fd6:	13 20       	jnz	$+40     	;abs 0x5ffe

00005fd8 <.L22>:
}
    5fd8:	b4 17       	popm	#12,	r15	;16-bit words
    5fda:	00 13       	reti			

00005fdc <.L27>:
          NULL != GPTDA1.config->callback) {
    5fdc:	1c 42 ae b5 	mov	&0xb5ae,r12	;0xb5ae
    5fe0:	1d 4c 04 00 	mov	4(r12),	r13	;

00005fe4 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    5fe4:	0d 93       	cmp	#0,	r13	;r3 As==00
    5fe6:	ef 27       	jz	$-32     	;abs 0x5fc6

00005fe8 <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    5fe8:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    5fec:	8d 12       	call	r13		;

00005fee <.LVL23>:
    5fee:	eb 3f       	jmp	$-40     	;abs 0x5fc6

00005ff0 <.L28>:
        GPTDA1.state = GPT_READY;
    5ff0:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    5ff4:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00005ff8 <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    5ff8:	b0 12 9c 5f 	call	#24476		;#0x5f9c

00005ffc <.LVL24>:
    5ffc:	e7 3f       	jmp	$-48     	;abs 0x5fcc

00005ffe <.L29>:
  OSAL_IRQ_EPILOGUE();
    5ffe:	b0 12 92 45 	call	#17810		;#0x4592

00006002 <.LVL25>:
}
    6002:	ea 3f       	jmp	$-42     	;abs 0x5fd8

00006004 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    6004:	32 c2       	dint			

00006006 <.Loc.46.1>:

}
    6006:	30 41       	ret			

00006008 <send_complete_cb>:
}

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  /* Allow us to handle config events again */
  UARTEvtMask |= UARTConfigUpdated;
    6008:	d2 d3       	bis.b	#1		;r3 As==01, Warning: disassembly unreliable - not enough bytes available

0000600a <L0>:
    600a:	0a b3       	bit	#0,	r10	;r3 As==00

0000600c <.Loc.50.1>:
}
    600c:	30 41       	ret			

0000600e <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    600e:	92 92 62 b6 	cmp	&0xb662,&0xb48a	;0xb662
    6012:	8a b4 
    6014:	07 24       	jz	$+16     	;abs 0x6024

00006016 <.L6>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    6016:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6018:	4e 43       	clr.b	r14		;
    601a:	1c 42 62 b6 	mov	&0xb662,r12	;0xb662
    601e:	b0 12 3a 47 	call	#18234		;#0x473a

00006022 <.LVL3>:
}
    6022:	30 41       	ret			

00006024 <.L7>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    6024:	3c 40 e0 b0 	mov	#-20256,r12	;#0xb0e0
    6028:	b0 12 a6 44 	call	#17574		;#0x44a6

0000602c <.LVL4>:
    602c:	f4 3f       	jmp	$-22     	;abs 0x6016

0000602e <elyUARTPostI>:
    602e:	0a 15       	pushm	#1,	r10	;16-bit words

00006030 <L0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    6030:	0d 4c       	mov	r12,	r13	;
    6032:	3c 40 0c b3 	mov	#-19700,r12	;#0xb30c

00006036 <.LVL6>:
    6036:	b0 12 20 48 	call	#18464		;#0x4820

0000603a <.LVL7>:
    603a:	0a 4c       	mov	r12,	r10	;

0000603c <.Loc.28.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    603c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    603e:	4e 43       	clr.b	r14		;
    6040:	1c 42 62 b6 	mov	&0xb662,r12	;0xb662
    6044:	b0 12 fe 46 	call	#18174		;#0x46fe

00006048 <.LVL9>:
}
    6048:	0c 4a       	mov	r10,	r12	;
    604a:	0a 17       	popm	#1,	r10	;16-bit words
    604c:	30 41       	ret			

0000604e <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer) {
    604e:	0a 15       	pushm	#1,	r10	;16-bit words

00006050 <.LBB17>:
  _disable_interrupts();
    6050:	32 c2       	dint			

00006052 <.Loc.348.2>:
  asm volatile("nop");
    6052:	03 43       	nop			

00006054 <.LBE17>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), TIME_INFINITE);
    6054:	4e 43       	clr.b	r14		;
    6056:	0d 4c       	mov	r12,	r13	;
    6058:	3c 40 0c b3 	mov	#-19700,r12	;#0xb30c

0000605c <.LVL11>:
    605c:	b0 12 ba 47 	call	#18362		;#0x47ba

00006060 <.LVL12>:
    6060:	0a 4c       	mov	r12,	r10	;

00006062 <.Loc.37.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    6062:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6064:	4e 43       	clr.b	r14		;
    6066:	1c 42 62 b6 	mov	&0xb662,r12	;0xb662
    606a:	b0 12 fe 46 	call	#18174		;#0x46fe

0000606e <.LBB19>:
  asm volatile("nop");
    606e:	03 43       	nop			

00006070 <.Loc.356.2>:
  _enable_interrupts();
    6070:	32 d2       	eint			
    6072:	03 43       	nop			

00006074 <.LBE19>:
}
    6074:	0c 4a       	mov	r10,	r12	;
    6076:	0a 17       	popm	#1,	r10	;16-bit words
    6078:	30 41       	ret			

0000607a <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 128);
THD_FUNCTION(UARTThd, arg) {
    607a:	1a 15       	pushm	#2,	r10	;16-bit words

0000607c <.LCFI2>:
    607c:	17 15       	pushm	#2,	r7	;16-bit words

0000607e <.LCFI3>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    607e:	92 42 8a b4 	mov	&0xb48a,&0xb662	;0xb48a
    6082:	62 b6 

00006084 <.Loc.82.1>:
  
  /* Start the UART driver */
  uartStart(&ELY_UART, &A1_cfg);
    6084:	3d 40 fa b2 	mov	#-19718,r13	;#0xb2fa
    6088:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566

0000608c <.LVL17>:
    608c:	b0 12 66 4c 	call	#19558		;#0x4c66

00006090 <.LVL18>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    6090:	3d 40 f4 b0 	mov	#-20236,r13	;#0xb0f4
    6094:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    6098:	b0 12 1c 4b 	call	#19228		;#0x4b1c

0000609c <.LVL19>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    609c:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    60a0:	b0 12 42 9e 	call	#-25022	;#0x9e42

000060a4 <.LVL20>:
    60a4:	5a 3c       	jmp	$+182    	;abs 0x615a

000060a6 <.L20>:
  _disable_interrupts();
    60a6:	32 c2       	dint			

000060a8 <.Loc.348.2>:
  asm volatile("nop");
    60a8:	03 43       	nop			

000060aa <.LBE22>:
    eventmask_t events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    60aa:	19 42 84 b1 	mov	&0xb184,r9	;0xb184
    60ae:	5c 49 26 00 	mov.b	38(r9),	r12	;0x00026
    60b2:	3e 40 08 b3 	mov	#-19704,r14	;#0xb308
    60b6:	4f 4c       	mov.b	r12,	r15	;
    60b8:	7f f0 03 00 	and.b	#3,	r15	;
    60bc:	6d 4e       	mov.b	@r14,	r13	;

000060be <.LVL22>:
    60be:	7d f0 fc ff 	and.b	#-4,	r13	;#0xfffc
    60c2:	4d df       	bis.b	r15,	r13	;

000060c4 <.Loc.99.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    60c4:	0f 4c       	mov	r12,	r15	;
    60c6:	5f 07       	rrum	#2,	r15	;
    60c8:	5f f3       	and.b	#1,	r15	;r3 As==01
    60ca:	43 18 0f 5f 	rpt #4 { rlax.w	r15		;
    60ce:	7d f0 ef ff 	and.b	#-17,	r13	;#0xffef
    60d2:	4d df       	bis.b	r15,	r13	;

000060d4 <.Loc.101.1>:
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    60d4:	5c 0b       	rrum	#3,	r12	;
    60d6:	5c f3       	and.b	#1,	r12	;r3 As==01
    60d8:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    60dc:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    60e0:	4d dc       	bis.b	r12,	r13	;
    60e2:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

000060e6 <.Loc.103.1>:
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    60e6:	56 49 22 00 	mov.b	34(r9),	r6	;0x00022
    60ea:	07 43       	clr	r7		;

000060ec <.Loc.104.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    60ec:	5c 49 23 00 	mov.b	35(r9),	r12	;0x00023
    60f0:	0d 43       	clr	r13		;
    60f2:	b0 12 70 ac 	call	#-21392	;#0xac70
    60f6:	07 4d       	mov	r13,	r7	;

000060f8 <.Loc.103.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    60f8:	06 dc       	bis	r12,	r6	;

000060fa <.Loc.105.1>:
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    60fa:	5c 49 24 00 	mov.b	36(r9),	r12	;0x00024
    60fe:	0d 43       	clr	r13		;
    6100:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6104:	b0 12 98 ac 	call	#-21352	;#0xac98

00006108 <.Loc.104.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    6108:	06 dc       	bis	r12,	r6	;
    610a:	07 dd       	bis	r13,	r7	;

0000610c <.Loc.106.1>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
    610c:	5c 49 25 00 	mov.b	37(r9),	r12	;0x00025
    6110:	0d 43       	clr	r13		;
    6112:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    6116:	b0 12 98 ac 	call	#-21352	;#0xac98

0000611a <.Loc.103.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    611a:	3e 40 fa b2 	mov	#-19718,r14	;#0xb2fa
    611e:	06 dc       	bis	r12,	r6	;
    6120:	8e 46 0a 00 	mov	r6,	10(r14)	; 0x000a
    6124:	07 dd       	bis	r13,	r7	;
    6126:	8e 47 0c 00 	mov	r7,	12(r14)	; 0x000c

0000612a <.LBB24>:
  asm volatile("nop");
    612a:	03 43       	nop			

0000612c <.Loc.356.2>:
  _enable_interrupts();
    612c:	32 d2       	eint			
    612e:	03 43       	nop			

00006130 <.LBE24>:
      
      chSysUnlock();
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    6130:	0d 4e       	mov	r14,	r13	;
    6132:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566
    6136:	b0 12 66 4c 	call	#19558		;#0x4c66

0000613a <.LVL26>:
      events &= ~UARTConfigUpdated;
    613a:	1a c3       	bic	#1,	r10	;r3 As==01
    613c:	17 3c       	jmp	$+48     	;abs 0x616c

0000613e <.L21>:
  _disable_interrupts();
    613e:	32 c2       	dint			

00006140 <.Loc.348.2>:
  asm volatile("nop");
    6140:	03 43       	nop			

00006142 <.LBE26>:
    }
    if (events & UARTBufferPosted) {
        /* Get the buffer */
        chSysLock();
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    6142:	3e 43       	mov	#-1,	r14	;r3 As==11
    6144:	3d 40 64 b6 	mov	#-18844,r13	;#0xb664
    6148:	3c 40 0c b3 	mov	#-19700,r12	;#0xb30c
    614c:	b0 12 70 48 	call	#18544		;#0x4870

00006150 <.LVL27>:
        if (result != MSG_OK) {
    6150:	0c 93       	cmp	#0,	r12	;r3 As==00
    6152:	13 24       	jz	$+40     	;abs 0x617a

00006154 <.LBB28>:
  asm volatile("nop");
    6154:	03 43       	nop			

00006156 <.Loc.356.2>:
  _enable_interrupts();
    6156:	32 d2       	eint			
    6158:	03 43       	nop			

0000615a <.L12>:
    eventmask_t events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    615a:	4e 43       	clr.b	r14		;
    615c:	5c 42 0a b3 	mov.b	&0xb30a,r12	;0xb30a
    6160:	0d 43       	clr	r13		;
    6162:	b0 12 4e 47 	call	#18254		;#0x474e

00006166 <.LVL29>:
    6166:	0a 4c       	mov	r12,	r10	;

00006168 <.LVL30>:
    if (events & UARTConfigUpdated) {
    6168:	1c b3       	bit	#1,	r12	;r3 As==01
    616a:	9d 23       	jnz	$-196    	;abs 0x60a6

0000616c <.L13>:
    if (events & UARTBufferPosted) {
    616c:	2a b3       	bit	#2,	r10	;r3 As==10
    616e:	e7 23       	jnz	$-48     	;abs 0x613e

00006170 <.L15>:
        /* Don't handle config events until transmission ends */
        UARTEvtMask &= ~UARTConfigUpdated;
      
        events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    }
    if (events & UARTRxBufferReady) {
    6170:	2a b2       	bit	#4,	r10	;r2 As==10
    6172:	f3 27       	jz	$-24     	;abs 0x615a

00006174 <.Loc.135.1>:
      
      elyUARTDLLRxHandleBuffer();
    6174:	b0 12 52 9e 	call	#-25006	;#0x9e52

00006178 <.LVL32>:
    6178:	f0 3f       	jmp	$-30     	;abs 0x615a

0000617a <.L17>:
  asm volatile("nop");
    617a:	03 43       	nop			

0000617c <.Loc.356.2>:
  _enable_interrupts();
    617c:	32 d2       	eint			
    617e:	03 43       	nop			

00006180 <.LBE30>:
        elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    6180:	1d 42 64 b6 	mov	&0xb664,r13	;0xb664
    6184:	3c 40 66 b5 	mov	#-19098,r12	;#0xb566

00006188 <.LVL34>:
    6188:	b0 12 c6 9d 	call	#-25146	;#0x9dc6

0000618c <.LVL35>:
        UARTEvtMask &= ~UARTConfigUpdated;
    618c:	d2 c3 0a b3 	bic.b	#1,	&0xb30a	;r3 As==01

00006190 <.Loc.131.1>:
        events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    6190:	2a c3       	bic	#2,	r10	;r3 As==10
    6192:	ee 3f       	jmp	$-34     	;abs 0x6170

00006194 <elyMainMBPost>:
static PERSIST MAILBOX_DECL(main_mbox, main_buffer, MAIN_BUF_LEN);
/* TODO persist? */
static PERSIST uint8_t * active_buffer;

msg_t elyMainMBPost(uint8_t * buffer, systime_t timeout) {
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    6194:	0e 4d       	mov	r13,	r14	;
    6196:	0d 4c       	mov	r12,	r13	;

00006198 <.LVL1>:
    6198:	3c 40 18 b3 	mov	#-19688,r12	;#0xb318

0000619c <L0>:
    619c:	b0 12 10 48 	call	#18448		;#0x4810

000061a0 <.LVL3>:
}
    61a0:	30 41       	ret			

000061a2 <MainThd>:
msg_t elyMainMBPostI(uint8_t * buffer) {
  return chMBPostI(&main_mbox, (msg_t)(buffer));
}

THD_WORKING_AREA(waMainThd, 128);
THD_FUNCTION(MainThd, arg) {
    61a2:	0a 15       	pushm	#1,	r10	;16-bit words

000061a4 <.LCFI0>:
    61a4:	21 83       	decd	r1		;

000061a6 <.LCFI1>:
    61a6:	04 3c       	jmp	$+10     	;abs 0x61b0

000061a8 <.L8>:
    
    /* Route packet according to Network Layer rules */
    switch(elyNLGetDest(active_buffer)) {
      case ELY_DEST_UART:
        /* TODO handle failure */
        elyUARTPost(active_buffer);
    61a8:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    61ac:	b0 12 4e 60 	call	#24654		;#0x604e

000061b0 <.L5>:
    chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    61b0:	4e 43       	clr.b	r14		;
    61b2:	3d 40 26 b7 	mov	#-18650,r13	;#0xb726
    61b6:	3c 40 18 b3 	mov	#-19688,r12	;#0xb318
    61ba:	b0 12 ca 48 	call	#18634		;#0x48ca

000061be <.LVL14>:
    elyNLValidate(active_buffer);
    61be:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    61c2:	b0 12 36 a7 	call	#-22730	;#0xa736

000061c6 <.LVL15>:
    switch(elyNLGetDest(active_buffer)) {
    61c6:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    61ca:	b0 12 7e a7 	call	#-22658	;#0xa77e

000061ce <.LVL16>:
    61ce:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    61d0:	09 24       	jz	$+20     	;abs 0x61e4
    61d2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    61d4:	e9 27       	jz	$-44     	;abs 0x61a8
    61d6:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    61d8:	0a 24       	jz	$+22     	;abs 0x61ee

000061da <.Loc.66.1>:
            elyNLFreeBuffer(active_buffer);
          }
        }
        break;
      default:
        chDbgAssert(false, "shouldn't happen");
    61da:	3c 40 fa b0 	mov	#-20230,r12	;#0xb0fa
    61de:	b0 12 a6 44 	call	#17574		;#0x44a6

000061e2 <.LVL17>:
    61e2:	e6 3f       	jmp	$-50     	;abs 0x61b0

000061e4 <.L7>:
        elyRFPost(active_buffer);
    61e4:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    61e8:	b0 12 c0 aa 	call	#-21824	;#0xaac0

000061ec <.LVL18>:
        break;
    61ec:	e1 3f       	jmp	$-60     	;abs 0x61b0

000061ee <.L9>:
          uint8_t * cmd_buffer = elyNLExtract(active_buffer);
    61ee:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    61f2:	b0 12 3a a8 	call	#-22470	;#0xa83a

000061f6 <.LVL19>:
    61f6:	0a 4c       	mov	r12,	r10	;

000061f8 <.Loc.49.1>:
          hdr = elyCmdParse(cmd_buffer);
    61f8:	0d 4c       	mov	r12,	r13	;
    61fa:	0c 41       	mov	r1,	r12	;
    61fc:	b0 12 58 63 	call	#25432		;#0x6358

00006200 <.LVL21>:
          if (elyCmdValidate(hdr, cmd_buffer)) {
    6200:	0d 4a       	mov	r10,	r13	;
    6202:	0c 41       	mov	r1,	r12	;
    6204:	b0 12 90 63 	call	#25488		;#0x6390

00006208 <.LVL22>:
    6208:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    620a:	0e 24       	jz	$+30     	;abs 0x6228

0000620c <.Loc.51.1>:
            if (hdr.reply) {
    620c:	6c 41       	mov.b	@r1,	r12	;
    620e:	6c f3       	and.b	#2,	r12	;r3 As==10
    6210:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6212:	05 20       	jnz	$+12     	;abs 0x621e

00006214 <.L12>:
            elyCmdDispatch(hdr, cmd_buffer);
    6214:	0d 4a       	mov	r10,	r13	;
    6216:	0c 41       	mov	r1,	r12	;
    6218:	b0 12 48 66 	call	#26184		;#0x6648

0000621c <.LVL23>:
    621c:	c9 3f       	jmp	$-108    	;abs 0x61b0

0000621e <.L15>:
              elyNLSetDest(active_buffer);
    621e:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    6222:	b0 12 d6 a7 	call	#-22570	;#0xa7d6

00006226 <.LVL24>:
    6226:	f6 3f       	jmp	$-18     	;abs 0x6214

00006228 <.L11>:
            elyNLFreeBuffer(active_buffer);
    6228:	1c 42 26 b7 	mov	&0xb726,r12	;0xb726
    622c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006230 <.LBE2>:
        break;
    6230:	bf 3f       	jmp	$-128    	;abs 0x61b0

00006232 <reset>:
  }
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLPack(buffer));
    6232:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006236 <.LVL1>:
    6236:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000623a <.LVL2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    623a:	b2 40 48 a5 	mov	#-23224	;#0xa548, Warning: disassembly unreliable - not enough bytes available

0000623e <L0>:
    623e:	20 01 30 41 	bra			;Warning: disassembly unreliable - not enough bytes available

00006240 <.Loc.44.1>:
}
    6240:	30 41       	ret			

00006242 <store_telem>:
  elyNLFreeBufferI(buffer);
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6242:	0a 15       	pushm	#1,	r10	;16-bit words

00006244 <.LCFI0>:
    6244:	21 83       	decd	r1		;

00006246 <.LCFI1>:
    6246:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    624a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    624e:	01 00 

00006250 <.Loc.1628.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6250:	6e 41       	mov.b	@r1,	r14	;
    6252:	4b 4e       	mov.b	r14,	r11	;
    6254:	6b f3       	and.b	#2,	r11	;r3 As==10
    6256:	4f 4b       	mov.b	r11,	r15	;
    6258:	0f 93       	cmp	#0,	r15	;r3 As==00
    625a:	19 24       	jz	$+52     	;abs 0x628e
    625c:	6a 42       	mov.b	#4,	r10	;r2 As==10

0000625e <.L3>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    625e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6262:	1e b3       	bit	#1,	r14	;r3 As==01
    6264:	16 24       	jz	$+46     	;abs 0x6292

00006266 <.Loc.1629.1>:
    6266:	6e 43       	mov.b	#2,	r14	;r3 As==10

00006268 <.L4>:
    6268:	4e 5b       	add.b	r11,	r14	;
    626a:	4d 8e       	sub.b	r14,	r13	;
    626c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006270 <.LBB57>:
  _disable_interrupts();
    6270:	32 c2       	dint			

00006272 <.Loc.348.2>:
  asm volatile("nop");
    6272:	03 43       	nop			

00006274 <.LBE57>:
  
  chSysLock();
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    6274:	0c 5a       	add	r10,	r12	;

00006276 <.LVL6>:
    6276:	0f 93       	cmp	#0,	r15	;r3 As==00
    6278:	0e 20       	jnz	$+30     	;abs 0x6296

0000627a <.Loc.1632.1>:
    627a:	3e 40 9c 62 	mov	#25244,	r14	;#0x629c

0000627e <.L5>:
    627e:	b0 12 96 aa 	call	#-21866	;#0xaa96

00006282 <.LBB59>:
  asm volatile("nop");
    6282:	03 43       	nop			

00006284 <.Loc.356.2>:
  _enable_interrupts();
    6284:	32 d2       	eint			
    6286:	03 43       	nop			

00006288 <.LBE59>:
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
  
  /* Reply is posted from callback if needed */
}
    6288:	21 53       	incd	r1		;
    628a:	0a 17       	popm	#1,	r10	;16-bit words
    628c:	30 41       	ret			

0000628e <.L6>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    628e:	6a 43       	mov.b	#2,	r10	;r3 As==10
    6290:	e6 3f       	jmp	$-50     	;abs 0x625e

00006292 <.L7>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6292:	4e 43       	clr.b	r14		;
    6294:	e9 3f       	jmp	$-44     	;abs 0x6268

00006296 <.L9>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    6296:	3e 40 a0 66 	mov	#26272,	r14	;#0x66a0
    629a:	f1 3f       	jmp	$-28     	;abs 0x627e

0000629c <store_telem_noreply_cb>:
    629c:	3c 50 fe ff 	add	#-2,	r12	;#0xfffe

000062a0 <.LVL13>:
  elyNLFreeBufferI(buffer);
    62a0:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

000062a2 <L0>:
    62a2:	2a a7       	dadd	@r7,	r10	;

000062a4 <.LVL14>:
}
    62a4:	30 41       	ret			

000062a6 <upload_fw_noreply_cb>:
  elyNLFreeBufferI(elyNLPack(buffer));
    62a6:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa

000062aa <.LVL17>:
    62aa:	b0 12 4c a8 	call	#-22452	;#0xa84c

000062ae <.LVL18>:
    62ae:	b0 12 2a a7 	call	#-22742	;#0xa72a

000062b2 <.LVL19>:
}
    62b2:	30 41       	ret			

000062b4 <cancel_fw_eeprom_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    62b4:	1c 42 3e b7 	mov	&0xb73e,r12	;0xb73e

000062b8 <.LVL22>:
    62b8:	4d 43       	clr.b	r13		;
    62ba:	0d 9c       	cmp	r12,	r13	;
    62bc:	03 34       	jge	$+8      	;abs 0x62c4

000062be <.L13>:
  pages_acked++;
    62be:	92 53 3a b7 	inc	&0xb73a		;

000062c2 <.Loc.1500.1>:
}
    62c2:	30 41       	ret			

000062c4 <.L14>:
    chSemSignalI(&bsp->sem);
    62c4:	3c 40 3e b7 	mov	#-18626,r12	;#0xb73e
    62c8:	b0 12 ac 46 	call	#18092		;#0x46ac

000062cc <.LVL25>:
    62cc:	f8 3f       	jmp	$-14     	;abs 0x62be

000062ce <verify_fw>:
    62ce:	0a 15       	pushm	#1,	r10	;16-bit words

000062d0 <L0>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    62d0:	21 82       	sub	#4,	r1	;r2 As==10

000062d2 <.LCFI3>:
    62d2:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    62d6:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    62da:	03 00 

000062dc <.Loc.1460.1>:
  if (hdr.reply) {
    62dc:	5d 41 02 00 	mov.b	2(r1),	r13	;
    62e0:	6d f3       	and.b	#2,	r13	;r3 As==10
    62e2:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    62e4:	07 20       	jnz	$+16     	;abs 0x62f4

000062e6 <.Loc.1490.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    62e6:	b0 12 4c a8 	call	#-22452	;#0xa84c

000062ea <.LVL27>:
    62ea:	b0 12 1e a7 	call	#-22754	;#0xa71e

000062ee <.L15>:
}
    62ee:	21 52       	add	#4,	r1	;r2 As==10
    62f0:	0a 17       	popm	#1,	r10	;16-bit words
    62f2:	30 41       	ret			

000062f4 <.L18>:
    stored_buff = buffer; /* store for freeing */
    62f4:	82 4c 40 b7 	mov	r12,	&0xb740	;

000062f8 <.Loc.1463.1>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    62f8:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    62fc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6300:	5c 4c 05 00 	mov.b	5(r12),	r12	;

00006304 <.LVL30>:
    6304:	0c dd       	bis	r13,	r12	;
    6306:	82 4c 42 b7 	mov	r12,	&0xb742	;

0000630a <.Loc.1466.1>:
    volatile uint8_t * crc_addr = crcStart();
    630a:	b0 12 de 9f 	call	#-24610	;#0x9fde

0000630e <.LVL31>:
    630e:	0a 4c       	mov	r12,	r10	;

00006310 <.Loc.1471.1>:
    elyFramGetRequest(&req);
    6310:	0c 41       	mov	r1,	r12	;
    6312:	b0 12 20 a2 	call	#-24032	;#0xa220

00006316 <.LVL33>:
    req->address = FRAM_FW_BASE; 
    6316:	2c 41       	mov	@r1,	r12	;
    6318:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    631c:	00 00 
    631e:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

00006322 <.Loc.1476.1>:
    req->read = 1;
    6322:	2c 41       	mov	@r1,	r12	;

00006324 <.Loc.1477.1>:
    req->special = 1; /* read to a constant register address */
    6324:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    6328:	04 00 

0000632a <.Loc.1478.1>:
    req->size = FRAM_FW_SIZE;
    632a:	1d 4c 04 00 	mov	4(r12),	r13	;
    632e:	7d f0 03 00 	and.b	#3,	r13	;
    6332:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    6336:	8c 4d 04 00 	mov	r13,	4(r12)	;
    633a:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    633e:	7d d0 03 00 	bis.b	#3,	r13	;
    6342:	6d c2       	bic.b	#4,	r13	;r2 As==10
    6344:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

00006348 <.Loc.1480.1>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    6348:	8c 4a 08 00 	mov	r10,	8(r12)	;

0000634c <.Loc.1481.1>:
    req->callback = verify_fw_cb;
    634c:	bc 40 66 68 	mov	#26726,	10(r12)	;#0x6866, 0x000a
    6350:	0a 00 

00006352 <.Loc.1487.1>:
    elyFramPostRequest(req);
    6352:	b0 12 3a a2 	call	#-24006	;#0xa23a

00006356 <.LBE65>:
    6356:	cb 3f       	jmp	$-104    	;abs 0x62ee

00006358 <elyCmdParse>:
    6358:	0a 15       	pushm	#1,	r10	;16-bit words

0000635a <L0>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * buffer) {
    635a:	0a 4c       	mov	r12,	r10	;

0000635c <.Loc.1740.1>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (buffer[0] >> 7);
    635c:	6b 4d       	mov.b	@r13,	r11	;
    635e:	0f 4b       	mov	r11,	r15	;
    6360:	5f 0f       	rrum	#4,	r15	;
    6362:	5f 0b       	rrum	#3,	r15	;
    6364:	6e 4c       	mov.b	@r12,	r14	;
    6366:	5e c3       	bic.b	#1,	r14	;r3 As==01
    6368:	4e df       	bis.b	r15,	r14	;

0000636a <.Loc.1741.1>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
    636a:	0f 4b       	mov	r11,	r15	;
    636c:	5f 0f       	rrum	#4,	r15	;
    636e:	5f 07       	rrum	#2,	r15	;
    6370:	5f f3       	and.b	#1,	r15	;r3 As==01
    6372:	4f 5f       	rla.b	r15		;
    6374:	6e c3       	bic.b	#2,	r14	;r3 As==10
    6376:	4e df       	bis.b	r15,	r14	;

00006378 <.Loc.1742.1>:
  hdr.opcode = (buffer[0] & 0x3F);
    6378:	41 18 0b 5b 	rpt #2 { rlax.w	r11		;
    637c:	7e f0 03 00 	and.b	#3,	r14	;
    6380:	4e db       	bis.b	r11,	r14	;
    6382:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00006386 <.Loc.1743.1>:
  hdr.length = buffer[1];
    6386:	dc 4d 01 00 	mov.b	1(r13),	1(r12)	;
    638a:	01 00 

0000638c <.Loc.1745.1>:
  return hdr;
}
    638c:	0a 17       	popm	#1,	r10	;16-bit words
    638e:	30 41       	ret			

00006390 <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    6390:	2a 15       	pushm	#3,	r10	;16-bit words

00006392 <.LCFI5>:
    6392:	21 83       	decd	r1		;

00006394 <.LCFI6>:
    6394:	09 4d       	mov	r13,	r9	;

00006396 <.Loc.1747.1>:
    6396:	e1 4c 00 00 	mov.b	@r12,	0(r1)	;
    639a:	d1 4c 01 00 	mov.b	1(r12),	1(r1)	;
    639e:	01 00 

000063a0 <.Loc.1750.1>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    63a0:	6c 41       	mov.b	@r1,	r12	;
    63a2:	5c 07       	rrum	#2,	r12	;
    63a4:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f

000063a8 <.LVL37>:
    63a8:	0d 9c       	cmp	r12,	r13	;
    63aa:	44 38       	jl	$+138    	;abs 0x6434

000063ac <.Loc.1756.1>:
    elyErrorSignal(ErrInvalidOpcode);
    return false;
  }
  
  /* Check return address */
  if (hdr.reply) {
    63ac:	6a 41       	mov.b	@r1,	r10	;
    63ae:	4e 4a       	mov.b	r10,	r14	;
    63b0:	6e f3       	and.b	#2,	r14	;r3 As==10
    63b2:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    63b4:	06 24       	jz	$+14     	;abs 0x63c2

000063b6 <.Loc.1757.1>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    63b6:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    63ba:	d9 9d 51 00 	cmp.b	81(r13),2(r9)	;0x00051
    63be:	02 00 
    63c0:	3f 24       	jz	$+128    	;abs 0x6440

000063c2 <.L23>:
      return false;
    }
  }
  
  /* Check length */
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    63c2:	58 41 01 00 	mov.b	1(r1),	r8	;
    63c6:	5a f3       	and.b	#1,	r10	;r3 As==01
    63c8:	0a 93       	cmp	#0,	r10	;r3 As==00
    63ca:	40 24       	jz	$+130    	;abs 0x644c
    63cc:	6d 43       	mov.b	#2,	r13	;r3 As==10

000063ce <.L24>:
    63ce:	4d 5e       	add.b	r14,	r13	;
    63d0:	4e 48       	mov.b	r8,	r14	;
    63d2:	4e 8d       	sub.b	r13,	r14	;
    63d4:	4d 4e       	mov.b	r14,	r13	;

000063d6 <.LVL38>:
  switch(hdr.opcode) {
    63d6:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    63da:	5e 24       	jz	$+190    	;abs 0x6498
    63dc:	7f 40 16 00 	mov.b	#22,	r15	;#0x0016
    63e0:	4f 9c       	cmp.b	r12,	r15	;
    63e2:	36 2c       	jc	$+110    	;abs 0x6450
    63e4:	3c 90 24 00 	cmp	#36,	r12	;#0x0024
    63e8:	64 24       	jz	$+202    	;abs 0x64b2
    63ea:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    63ee:	4f 9c       	cmp.b	r12,	r15	;
    63f0:	a0 2c       	jc	$+322    	;abs 0x6532
    63f2:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    63f6:	b1 24       	jz	$+356    	;abs 0x655a
    63f8:	7f 40 2a 00 	mov.b	#42,	r15	;#0x002a
    63fc:	4f 9c       	cmp.b	r12,	r15	;
    63fe:	d9 2c       	jc	$+436    	;abs 0x65b2
    6400:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    6404:	4f 9c       	cmp.b	r12,	r15	;
    6406:	e3 2c       	jc	$+456    	;abs 0x65ce
    6408:	3c 90 2e 00 	cmp	#46,	r12	;#0x002e
    640c:	ec 24       	jz	$+474    	;abs 0x65e6
    640e:	3c 90 2f 00 	cmp	#47,	r12	;#0x002f
    6412:	c4 20       	jnz	$+394    	;abs 0x659c

00006414 <.Loc.1831.1>:
        return false;
      }
      break;
      
    case CmdGetTelem: /* 2 + 2 + 8 */
      if (payload_len != 2 && payload_len != 4 && 
    6414:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    6416:	c6 24       	jz	$+398    	;abs 0x65a4

00006418 <.Loc.1831.1>:
    6418:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    641a:	c4 24       	jz	$+394    	;abs 0x65a4

0000641c <.Loc.1831.1>:
    641c:	7e 90 0a 00 	cmp.b	#10,	r14	;#0x000a
    6420:	c1 24       	jz	$+388    	;abs 0x65a4

00006422 <.Loc.1832.1>:
          payload_len != 10 && payload_len != 12) {
    6422:	7e 90 0c 00 	cmp.b	#12,	r14	;#0x000c
    6426:	be 24       	jz	$+382    	;abs 0x65a4

00006428 <.Loc.1833.1>:
        elyErrorSignal(ErrInvalidLength);
    6428:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    642c:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006430 <.LVL39>:
        return false;
    6430:	4a 43       	clr.b	r10		;
    6432:	bb 3c       	jmp	$+376    	;abs 0x65aa

00006434 <.L54>:
    elyErrorSignal(ErrInvalidOpcode);
    6434:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89
    6438:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000643c <.LVL40>:
    return false;
    643c:	4a 43       	clr.b	r10		;
    643e:	b5 3c       	jmp	$+364    	;abs 0x65aa

00006440 <.L55>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    6440:	d9 9d 50 00 	cmp.b	80(r13),3(r9)	;0x00050
    6444:	03 00 
    6446:	bd 23       	jnz	$-132    	;abs 0x63c2

00006448 <.Loc.1759.1>:
      return false;
    6448:	4a 43       	clr.b	r10		;
    644a:	af 3c       	jmp	$+352    	;abs 0x65aa

0000644c <.L51>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    644c:	4d 43       	clr.b	r13		;
    644e:	bf 3f       	jmp	$-128    	;abs 0x63ce

00006450 <.L56>:
  switch(hdr.opcode) {
    6450:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    6454:	21 24       	jz	$+68     	;abs 0x6498
    6456:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    645a:	4f 9c       	cmp.b	r12,	r15	;
    645c:	32 28       	jnc	$+102    	;abs 0x64c2
    645e:	2c 92       	cmp	#4,	r12	;r2 As==10
    6460:	c2 24       	jz	$+390    	;abs 0x65e6
    6462:	6f 42       	mov.b	#4,	r15	;r2 As==10
    6464:	4f 9c       	cmp.b	r12,	r15	;
    6466:	16 2c       	jc	$+46     	;abs 0x6494
    6468:	3c 90 07 00 	cmp	#7,	r12	;
    646c:	d4 24       	jz	$+426    	;abs 0x6616
    646e:	7f 40 07 00 	mov.b	#7,	r15	;
    6472:	4f 9c       	cmp.b	r12,	r15	;
    6474:	19 28       	jnc	$+52     	;abs 0x64a8
    6476:	3c 90 05 00 	cmp	#5,	r12	;
    647a:	bf 24       	jz	$+384    	;abs 0x65fa
    647c:	3c 90 06 00 	cmp	#6,	r12	;
    6480:	8d 20       	jnz	$+284    	;abs 0x659c

00006482 <.Loc.1810.1>:
      if (payload_len != 3) {
    6482:	7e 90 03 00 	cmp.b	#3,	r14	;
    6486:	8e 24       	jz	$+286    	;abs 0x65a4

00006488 <.Loc.1811.1>:
        elyErrorSignal(ErrInvalidLength);
    6488:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    648c:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006490 <.LVL42>:
        return false;
    6490:	4a 43       	clr.b	r10		;
    6492:	8b 3c       	jmp	$+280    	;abs 0x65aa

00006494 <.L60>:
  switch(hdr.opcode) {
    6494:	2c 93       	cmp	#2,	r12	;r3 As==10
    6496:	29 24       	jz	$+84     	;abs 0x64ea

00006498 <.L26>:
      if (payload_len != 0) {
    6498:	0d 93       	cmp	#0,	r13	;r3 As==00
    649a:	84 24       	jz	$+266    	;abs 0x65a4

0000649c <.Loc.1785.1>:
        elyErrorSignal(ErrInvalidLength);
    649c:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    64a0:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000064a4 <.LVL44>:
        return false;
    64a4:	4a 43       	clr.b	r10		;
    64a6:	81 3c       	jmp	$+260    	;abs 0x65aa

000064a8 <.L33>:
  switch(hdr.opcode) {
    64a8:	3c 92       	cmp	#8,	r12	;r2 As==11
    64aa:	f6 27       	jz	$-18     	;abs 0x6498
    64ac:	3c 90 09 00 	cmp	#9,	r12	;
    64b0:	75 20       	jnz	$+236    	;abs 0x659c

000064b2 <.L36>:
      if (payload_len != 4) {
    64b2:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    64b4:	77 24       	jz	$+240    	;abs 0x65a4

000064b6 <.Loc.1825.1>:
        elyErrorSignal(ErrInvalidLength);
    64b6:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    64ba:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000064be <.LVL46>:
        return false;
    64be:	4a 43       	clr.b	r10		;
    64c0:	74 3c       	jmp	$+234    	;abs 0x65aa

000064c2 <.L28>:
  switch(hdr.opcode) {
    64c2:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    64c6:	e8 27       	jz	$-46     	;abs 0x6498
    64c8:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    64cc:	4f 9c       	cmp.b	r12,	r15	;
    64ce:	15 2c       	jc	$+44     	;abs 0x64fa
    64d0:	3c 90 13 00 	cmp	#19,	r12	;#0x0013
    64d4:	ee 27       	jz	$-34     	;abs 0x64b2
    64d6:	7f 40 13 00 	mov.b	#19,	r15	;#0x0013
    64da:	4f 9c       	cmp.b	r12,	r15	;
    64dc:	23 2c       	jc	$+72     	;abs 0x6524
    64de:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    64e2:	da 27       	jz	$-74     	;abs 0x6498
    64e4:	3c 90 15 00 	cmp	#21,	r12	;#0x0015
    64e8:	59 20       	jnz	$+180    	;abs 0x659c

000064ea <.L31>:
      if (payload_len != 1) {
    64ea:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    64ec:	5b 24       	jz	$+184    	;abs 0x65a4

000064ee <.Loc.1797.1>:
        elyErrorSignal(ErrInvalidLength);
    64ee:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    64f2:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000064f6 <.LVL48>:
        return false;
    64f6:	4a 43       	clr.b	r10		;
    64f8:	58 3c       	jmp	$+178    	;abs 0x65aa

000064fa <.L61>:
  switch(hdr.opcode) {
    64fa:	3c 90 0d 00 	cmp	#13,	r12	;#0x000d
    64fe:	d9 27       	jz	$-76     	;abs 0x64b2
    6500:	7f 40 0d 00 	mov.b	#13,	r15	;#0x000d
    6504:	4f 9c       	cmp.b	r12,	r15	;
    6506:	07 28       	jnc	$+16     	;abs 0x6516
    6508:	3c 90 0b 00 	cmp	#11,	r12	;#0x000b
    650c:	d2 27       	jz	$-90     	;abs 0x64b2
    650e:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    6512:	c2 27       	jz	$-122    	;abs 0x6498
    6514:	43 3c       	jmp	$+136    	;abs 0x659c

00006516 <.L38>:
    6516:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    651a:	be 27       	jz	$-130    	;abs 0x6498
    651c:	3c 90 0f 00 	cmp	#15,	r12	;#0x000f
    6520:	c8 27       	jz	$-110    	;abs 0x64b2
    6522:	3c 3c       	jmp	$+122    	;abs 0x659c

00006524 <.L62>:
    6524:	3c 90 11 00 	cmp	#17,	r12	;#0x0011
    6528:	c4 27       	jz	$-118    	;abs 0x64b2
    652a:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    652e:	b4 27       	jz	$-150    	;abs 0x6498
    6530:	35 3c       	jmp	$+108    	;abs 0x659c

00006532 <.L57>:
    6532:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    6536:	57 24       	jz	$+176    	;abs 0x65e6
    6538:	7f 40 1c 00 	mov.b	#28,	r15	;#0x001c
    653c:	4f 9c       	cmp.b	r12,	r15	;
    653e:	20 28       	jnc	$+66     	;abs 0x6580
    6540:	3c 90 19 00 	cmp	#25,	r12	;#0x0019
    6544:	0a 24       	jz	$+22     	;abs 0x655a
    6546:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    654a:	4d 9c       	cmp.b	r12,	r13	;
    654c:	12 2c       	jc	$+38     	;abs 0x6572
    654e:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    6552:	49 24       	jz	$+148    	;abs 0x65e6
    6554:	3c 90 1b 00 	cmp	#27,	r12	;#0x001b
    6558:	21 20       	jnz	$+68     	;abs 0x659c

0000655a <.L42>:
      break;
      
    case CmdChannelSub: /* 4 + 8-bit aligned */
    case CmdLogChan: /* 4 + 8-bit aligned */
    case CmdUploadFW: /* 4 + 8-bit aligned */
      if (payload_len < 4 || payload_len > 251) {
    655a:	7e 50 fc ff 	add.b	#-4,	r14	;#0xfffc

0000655e <.LVL50>:
    655e:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    6562:	4c 9e       	cmp.b	r14,	r12	;
    6564:	1f 2c       	jc	$+64     	;abs 0x65a4

00006566 <.Loc.1870.1>:
        elyErrorSignal(ErrInvalidLength);
    6566:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    656a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000656e <.LVL51>:
        return false;
    656e:	4a 43       	clr.b	r10		;
    6570:	1c 3c       	jmp	$+58     	;abs 0x65aa

00006572 <.L63>:
  switch(hdr.opcode) {
    6572:	3c 90 17 00 	cmp	#23,	r12	;#0x0017
    6576:	9d 27       	jz	$-196    	;abs 0x64b2
    6578:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    657c:	b6 27       	jz	$-146    	;abs 0x64ea
    657e:	0e 3c       	jmp	$+30     	;abs 0x659c

00006580 <.L41>:
    6580:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    6584:	4f 9c       	cmp.b	r12,	r15	;
    6586:	88 2b       	jnc	$-238    	;abs 0x6498
    6588:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    658c:	4f 9c       	cmp.b	r12,	r15	;
    658e:	2b 28       	jnc	$+88     	;abs 0x65e6
    6590:	3c 90 1d 00 	cmp	#29,	r12	;#0x001d
    6594:	aa 27       	jz	$-170    	;abs 0x64ea
    6596:	3c 90 1e 00 	cmp	#30,	r12	;#0x001e
    659a:	7e 27       	jz	$-258    	;abs 0x6498

0000659c <.L25>:
      }
      break;
      
    default:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
    659c:	3c 40 13 b1 	mov	#-20205,r12	;#0xb113
    65a0:	b0 12 a6 44 	call	#17574		;#0x44a6

000065a4 <.L48>:
  }
  
  /* Check CRC */
  if (hdr.crc) {
    65a4:	0a 93       	cmp	#0,	r10	;r3 As==00
    65a6:	43 20       	jnz	$+136    	;abs 0x662e

000065a8 <.Loc.1888.1>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    65a8:	5a 43       	mov.b	#1,	r10	;r3 As==01

000065aa <.L22>:
  
}
    65aa:	4c 4a       	mov.b	r10,	r12	;
    65ac:	21 53       	incd	r1		;
    65ae:	28 17       	popm	#3,	r10	;16-bit words
    65b0:	30 41       	ret			

000065b2 <.L58>:
  switch(hdr.opcode) {
    65b2:	3c 90 27 00 	cmp	#39,	r12	;#0x0027
    65b6:	99 27       	jz	$-204    	;abs 0x64ea
    65b8:	7f 40 26 00 	mov.b	#38,	r15	;#0x0026
    65bc:	4f 9c       	cmp.b	r12,	r15	;
    65be:	6c 2f       	jc	$-294    	;abs 0x6498
    65c0:	3c 90 28 00 	cmp	#40,	r12	;#0x0028
    65c4:	69 27       	jz	$-300    	;abs 0x6498
    65c6:	3c 90 29 00 	cmp	#41,	r12	;#0x0029
    65ca:	8f 27       	jz	$-224    	;abs 0x64ea
    65cc:	e7 3f       	jmp	$-48     	;abs 0x659c

000065ce <.L59>:
    65ce:	7f 40 2b 00 	mov.b	#43,	r15	;#0x002b
    65d2:	4f 9c       	cmp.b	r12,	r15	;
    65d4:	61 2b       	jnc	$-316    	;abs 0x6498

000065d6 <.Loc.1803.1>:
      if (payload_len != 2) {
    65d6:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    65d8:	e5 27       	jz	$-52     	;abs 0x65a4

000065da <.Loc.1804.1>:
        elyErrorSignal(ErrInvalidLength);
    65da:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    65de:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000065e2 <.LVL55>:
        return false;
    65e2:	4a 43       	clr.b	r10		;
    65e4:	e2 3f       	jmp	$-58     	;abs 0x65aa

000065e6 <.L29>:
      if (payload_len > 251) {
    65e6:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb
    65ea:	4c 9e       	cmp.b	r14,	r12	;
    65ec:	db 2f       	jc	$-72     	;abs 0x65a4

000065ee <.Loc.1847.1>:
        elyErrorSignal(ErrInvalidLength);
    65ee:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    65f2:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000065f6 <.LVL57>:
        return false;
    65f6:	4a 43       	clr.b	r10		;
    65f8:	d8 3f       	jmp	$-78     	;abs 0x65aa

000065fa <.L34>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    65fa:	0d 93       	cmp	#0,	r13	;r3 As==00
    65fc:	06 24       	jz	$+14     	;abs 0x660a

000065fe <.Loc.1853.1>:
    65fe:	1e b3       	bit	#1,	r14	;r3 As==01
    6600:	04 24       	jz	$+10     	;abs 0x660a

00006602 <.Loc.1853.1>:
    6602:	7d 40 fb ff 	mov.b	#-5,	r13	;#0xfffb
    6606:	4d 9e       	cmp.b	r14,	r13	;
    6608:	cd 2f       	jc	$-100    	;abs 0x65a4

0000660a <.L49>:
        elyErrorSignal(ErrInvalidLength);
    660a:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    660e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006612 <.LVL59>:
        return false;
    6612:	4a 43       	clr.b	r10		;
    6614:	ca 3f       	jmp	$-106    	;abs 0x65aa

00006616 <.L32>:
      if (payload_len < 2 || payload_len > 251) {
    6616:	7e 50 fe ff 	add.b	#-2,	r14	;#0xfffe

0000661a <.LVL61>:
    661a:	7f 40 f9 ff 	mov.b	#-7,	r15	;#0xfff9
    661e:	4f 9e       	cmp.b	r14,	r15	;
    6620:	c1 2f       	jc	$-124    	;abs 0x65a4

00006622 <.Loc.1861.1>:
        elyErrorSignal(ErrInvalidLength);
    6622:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    6626:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000662a <.LVL62>:
        return false;
    662a:	4a 43       	clr.b	r10		;
    662c:	be 3f       	jmp	$-130    	;abs 0x65aa

0000662e <.L64>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    662e:	0d 48       	mov	r8,	r13	;
    6630:	2d 53       	incd	r13		;
    6632:	0c 49       	mov	r9,	r12	;
    6634:	b0 12 8a 9f 	call	#-24694	;#0x9f8a

00006638 <.LVL63>:
    6638:	4a 4c       	mov.b	r12,	r10	;
    663a:	0a 93       	cmp	#0,	r10	;r3 As==00
    663c:	b6 23       	jnz	$-146    	;abs 0x65aa

0000663e <.Loc.1883.1>:
      elyErrorSignal(ErrFCSError);
    663e:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    6642:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006646 <.LVL64>:
      return false;
    6646:	b1 3f       	jmp	$-156    	;abs 0x65aa

00006648 <elyCmdDispatch>:
    6648:	21 83       	decd	r1		;

0000664a <.LCFI7>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    664a:	0f 4d       	mov	r13,	r15	;

0000664c <.Loc.1892.1>:
    664c:	e1 4c 00 00 	mov.b	@r12,	0(r1)	;
    6650:	d1 4c 01 00 	mov.b	1(r12),	1(r1)	;
    6654:	01 00 

00006656 <.Loc.1894.1>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    6656:	6d 41       	mov.b	@r1,	r13	;

00006658 <.LVL66>:
    6658:	5d 07       	rrum	#2,	r13	;
    665a:	0e 4d       	mov	r13,	r14	;
    665c:	0e 5d       	add	r13,	r14	;
    665e:	0d 41       	mov	r1,	r13	;
    6660:	0c 4f       	mov	r15,	r12	;
    6662:	1e 4e 22 b1 	mov	-20190(r14),r14	;0xffffb122
    6666:	8e 12       	call	r14		;

00006668 <.LVL67>:
}
    6668:	21 53       	incd	r1		;
    666a:	30 41       	ret			

0000666c <elyCmdSendReplyI>:
  msg = elyCmdSendReplyI(buff);
  chSysUnlock();
  return msg;
}

msg_t elyCmdSendReplyI(uint8_t * buff) {
    666c:	0a 15       	pushm	#1,	r10	;16-bit words

0000666e <L0>:
  uint8_t * buffer = elyNLPack(buff);
    666e:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006672 <.LVL69>:
    6672:	0a 4c       	mov	r12,	r10	;

00006674 <.Loc.1907.1>:
  switch (elyNLGetDest(buffer)) {
    6674:	b0 12 7e a7 	call	#-22658	;#0xa77e

00006678 <.LVL71>:
    6678:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    667a:	07 24       	jz	$+16     	;abs 0x668a
    667c:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    667e:	09 20       	jnz	$+20     	;abs 0x6692

00006680 <.Loc.1909.1>:
    case ELY_DEST_RF:
      return elyRFPostI(buffer);
    6680:	0c 4a       	mov	r10,	r12	;
    6682:	b0 12 ba aa 	call	#-21830	;#0xaaba

00006686 <.L66>:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
  /* also shouldn't happen */
  return MSG_RESET;
}
    6686:	0a 17       	popm	#1,	r10	;16-bit words
    6688:	30 41       	ret			

0000668a <.L68>:
      return elyUARTPostI(buffer);
    668a:	0c 4a       	mov	r10,	r12	;
    668c:	b0 12 2e 60 	call	#24622		;#0x602e

00006690 <.LVL73>:
    6690:	fa 3f       	jmp	$-10     	;abs 0x6686

00006692 <.L71>:
      chDbgAssert(false, "shouldn't happen");
    6692:	3c 40 02 b1 	mov	#-20222,r12	;#0xb102
    6696:	b0 12 a6 44 	call	#17574		;#0x44a6

0000669a <.LVL74>:
  return MSG_RESET;
    669a:	3c 40 fe ff 	mov	#-2,	r12	;#0xfffe
    669e:	f3 3f       	jmp	$-24     	;abs 0x6686

000066a0 <store_telem_reply_cb>:
    66a0:	0a 15       	pushm	#1,	r10	;16-bit words

000066a2 <.LCFI9>:
  buffer = buffer - 4;
    66a2:	0a 4c       	mov	r12,	r10	;

000066a4 <L0>:
    66a4:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc

000066a8 <.LVL76>:
  gen_success(buffer, buffer[0] & 0x80); /* crc */
    66a8:	5d 4c fc ff 	mov.b	-4(r12),r13	;
    66ac:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    66b0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000066b4 <.LBB68>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    66b4:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    66b8:	00 00 

000066ba <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    66ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    66bc:	15 24       	jz	$+44     	;abs 0x66e8
    66be:	7e 40 03 00 	mov.b	#3,	r14	;

000066c2 <.L73>:
    66c2:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

000066c6 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    66c6:	1e 42 84 b1 	mov	&0xb184,r14	;0xb184
    66ca:	da 4e 51 00 	mov.b	81(r14),2(r10)	;0x00051
    66ce:	02 00 

000066d0 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    66d0:	da 4e 50 00 	mov.b	80(r14),3(r10)	;0x00050
    66d4:	03 00 

000066d6 <.Loc.24.1>:
  buffer[4] = 1;
    66d6:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000066da <.Loc.25.1>:
  if (crc) {
    66da:	0d 93       	cmp	#0,	r13	;r3 As==00
    66dc:	07 20       	jnz	$+16     	;abs 0x66ec

000066de <.L74>:
  elyCmdSendReplyI(buffer);
    66de:	0c 4a       	mov	r10,	r12	;
    66e0:	b0 12 6c 66 	call	#26220		;#0x666c

000066e4 <.LVL79>:
}
    66e4:	0a 17       	popm	#1,	r10	;16-bit words
    66e6:	30 41       	ret			

000066e8 <.L75>:
  buffer[1] = (crc ? 3 : 1);
    66e8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    66ea:	eb 3f       	jmp	$-40     	;abs 0x66c2

000066ec <.L76>:
    crcGenX25(buffer, 7);
    66ec:	7d 40 07 00 	mov.b	#7,	r13	;

000066f0 <.LVL81>:
    66f0:	0c 4a       	mov	r10,	r12	;
    66f2:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000066f6 <.LVL82>:
    66f6:	f3 3f       	jmp	$-24     	;abs 0x66de

000066f8 <install_fw>:
    66f8:	0a 15       	pushm	#1,	r10	;16-bit words

000066fa <.LCFI10>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    66fa:	21 83       	decd	r1		;

000066fc <L0>:
    66fc:	0a 4c       	mov	r12,	r10	;

000066fe <.Loc.1587.1>:
    66fe:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6702:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6706:	01 00 

00006708 <.Loc.1592.1>:
  if (hdr.reply) {
    6708:	6c 41       	mov.b	@r1,	r12	;

0000670a <.LVL84>:
    670a:	6c f3       	and.b	#2,	r12	;r3 As==10
    670c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    670e:	0d 20       	jnz	$+28     	;abs 0x672a

00006710 <.Loc.1597.1>:
    elyNLFreeBufferI(elyNLPack(buffer));
    6710:	0c 4a       	mov	r10,	r12	;
    6712:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006716 <.LVL85>:
    6716:	b0 12 2a a7 	call	#-22742	;#0xa72a

0000671a <.L81>:
  bootloader = 1;
    671a:	d2 43 fc 19 	mov.b	#1,	&0x19fc	;r3 As==01

0000671e <.Loc.1602.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    671e:	b2 40 48 a5 	mov	#-23224,&0x0120	;#0xa548
    6722:	20 01 

00006724 <.Loc.1604.1>:
}
    6724:	21 53       	incd	r1		;
    6726:	0a 17       	popm	#1,	r10	;16-bit words
    6728:	30 41       	ret			

0000672a <.L83>:
    gen_success(buffer, hdr.crc);
    672a:	6c 41       	mov.b	@r1,	r12	;
    672c:	5c f3       	and.b	#1,	r12	;r3 As==01

0000672e <.LBB74>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    672e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6732:	00 00 

00006734 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    6734:	0c 93       	cmp	#0,	r12	;r3 As==00
    6736:	14 24       	jz	$+42     	;abs 0x6760
    6738:	7d 40 03 00 	mov.b	#3,	r13	;

0000673c <.L79>:
    673c:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006740 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6740:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6744:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6748:	02 00 

0000674a <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    674a:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    674e:	03 00 

00006750 <.Loc.24.1>:
  buffer[4] = 1;
    6750:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006754 <.Loc.25.1>:
  if (crc) {
    6754:	0c 93       	cmp	#0,	r12	;r3 As==00
    6756:	06 20       	jnz	$+14     	;abs 0x6764

00006758 <.L80>:
    elyCmdSendReplyI(buffer);
    6758:	0c 4a       	mov	r10,	r12	;
    675a:	b0 12 6c 66 	call	#26220		;#0x666c

0000675e <.LVL89>:
    675e:	dd 3f       	jmp	$-68     	;abs 0x671a

00006760 <.L82>:
  buffer[1] = (crc ? 3 : 1);
    6760:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6762:	ec 3f       	jmp	$-38     	;abs 0x673c

00006764 <.L84>:
    crcGenX25(buffer, 7);
    6764:	7d 40 07 00 	mov.b	#7,	r13	;
    6768:	0c 4a       	mov	r10,	r12	;
    676a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000676e <.LVL91>:
    676e:	f4 3f       	jmp	$-22     	;abs 0x6758

00006770 <cancel_fw>:
    6770:	1a 15       	pushm	#2,	r10	;16-bit words

00006772 <.LCFI12>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6772:	21 82       	sub	#4,	r1	;r2 As==10

00006774 <.LCFI13>:
    6774:	09 4c       	mov	r12,	r9	;

00006776 <L0>:
    6776:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    677a:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    677e:	03 00 

00006780 <.Loc.1521.1>:
  stored_buff = buffer; /* store for freeing */
    6780:	82 4c 40 b7 	mov	r12,	&0xb740	;

00006784 <.LBB87>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    6784:	4a 43       	clr.b	r10		;
    6786:	39 3c       	jmp	$+116    	;abs 0x67fa

00006788 <.L87>:
  _disable_interrupts();
    6788:	32 c2       	dint			

0000678a <.Loc.348.2>:
  asm volatile("nop");
    678a:	03 43       	nop			

0000678c <.LBE88>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    678c:	4d 43       	clr.b	r13		;
    678e:	0c 41       	mov	r1,	r12	;
    6790:	b0 12 52 a2 	call	#-23982	;#0xa252

00006794 <.LBB90>:
  asm volatile("nop");
    6794:	03 43       	nop			

00006796 <.Loc.356.2>:
  _enable_interrupts();
    6796:	32 d2       	eint			
    6798:	03 43       	nop			

0000679a <.LBE90>:
    pages_sent++;
    679a:	92 53 3c b7 	inc	&0xb73c		;

0000679e <.Loc.1559.1>:
    req->address = FRAM_FW_BASE + (i * 128); 
    679e:	2e 41       	mov	@r1,	r14	;
    67a0:	0c 4a       	mov	r10,	r12	;
    67a2:	46 18 0c 5c 	rpt #7 { rlax.w	r12		;
    67a6:	0d 43       	clr	r13		;
    67a8:	0f 4c       	mov	r12,	r15	;
    67aa:	3f 50 00 04 	add	#1024,	r15	;#0x0400
    67ae:	8e 4f 00 00 	mov	r15,	0(r14)	;
    67b2:	0f 4d       	mov	r13,	r15	;
    67b4:	1f 63       	addc	#1,	r15	;r3 As==01
    67b6:	8e 4f 02 00 	mov	r15,	2(r14)	;

000067ba <.Loc.1560.1>:
    req->read = 0;
    67ba:	2c 41       	mov	@r1,	r12	;
    67bc:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    67c0:	6d c3       	bic.b	#2,	r13	;r3 As==10

000067c2 <.Loc.1561.1>:
    req->special = 1; /* write a constant value */
    67c2:	5d d3       	bis.b	#1,	r13	;r3 As==01
    67c4:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

000067c8 <.Loc.1562.1>:
    req->size = 128;
    67c8:	1d 4c 04 00 	mov	4(r12),	r13	;
    67cc:	7d f0 03 00 	and.b	#3,	r13	;
    67d0:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    67d4:	8c 4d 04 00 	mov	r13,	4(r12)	;
    67d8:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    67dc:	06 00 

000067de <.Loc.1563.1>:
    req->buffer = &fill_value; 
    67de:	bc 40 38 b7 	mov	#-18632,8(r12)	;#0xb738
    67e2:	08 00 

000067e4 <.Loc.1564.1>:
    req->callback = cancel_fw_eeprom_cb;
    67e4:	bc 40 b4 62 	mov	#25268,	10(r12)	;#0x62b4, 0x000a
    67e8:	0a 00 

000067ea <.Loc.1568.1>:
    elyFramPostRequest(req);
    67ea:	b0 12 3a a2 	call	#-24006	;#0xa23a

000067ee <.LBB92>:
  return chSemWaitTimeout(&bsp->sem, time);
    67ee:	4d 43       	clr.b	r13		;
    67f0:	3c 40 3e b7 	mov	#-18626,r12	;#0xb73e
    67f4:	b0 12 9c 46 	call	#18076		;#0x469c

000067f8 <.LBE92>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    67f8:	1a 53       	inc	r10		;

000067fa <.L86>:
    67fa:	3c 40 f7 01 	mov	#503,	r12	;#0x01f7
    67fe:	0c 9a       	cmp	r10,	r12	;
    6800:	c3 2f       	jc	$-120    	;abs 0x6788

00006802 <.LBE87>:
  if (hdr.reply) {
    6802:	5c 41 02 00 	mov.b	2(r1),	r12	;
    6806:	6c f3       	and.b	#2,	r12	;r3 As==10
    6808:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    680a:	09 20       	jnz	$+20     	;abs 0x681e

0000680c <.Loc.1580.1>:
    elyNLFreeBufferI(elyNLPack(stored_buff));
    680c:	1c 42 40 b7 	mov	&0xb740,r12	;0xb740
    6810:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006814 <.LVL99>:
    6814:	b0 12 2a a7 	call	#-22742	;#0xa72a

00006818 <.L85>:
}
    6818:	21 52       	add	#4,	r1	;r2 As==10
    681a:	19 17       	popm	#2,	r10	;16-bit words
    681c:	30 41       	ret			

0000681e <.L93>:
    gen_success(buffer, hdr.crc);
    681e:	5c 41 02 00 	mov.b	2(r1),	r12	;
    6822:	5c f3       	and.b	#1,	r12	;r3 As==01

00006824 <.LBB94>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6824:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    6828:	00 00 

0000682a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    682a:	0c 93       	cmp	#0,	r12	;r3 As==00
    682c:	14 24       	jz	$+42     	;abs 0x6856
    682e:	7d 40 03 00 	mov.b	#3,	r13	;

00006832 <.L89>:
    6832:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00006836 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6836:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    683a:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    683e:	02 00 

00006840 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6840:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    6844:	03 00 

00006846 <.Loc.24.1>:
  buffer[4] = 1;
    6846:	d9 43 04 00 	mov.b	#1,	4(r9)	;r3 As==01

0000684a <.Loc.25.1>:
  if (crc) {
    684a:	0c 93       	cmp	#0,	r12	;r3 As==00
    684c:	06 20       	jnz	$+14     	;abs 0x685a

0000684e <.L90>:
    elyCmdSendReplyI(buffer);
    684e:	0c 49       	mov	r9,	r12	;
    6850:	b0 12 6c 66 	call	#26220		;#0x666c

00006854 <.LVL103>:
    6854:	e1 3f       	jmp	$-60     	;abs 0x6818

00006856 <.L92>:
  buffer[1] = (crc ? 3 : 1);
    6856:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6858:	ec 3f       	jmp	$-38     	;abs 0x6832

0000685a <.L94>:
    crcGenX25(buffer, 7);
    685a:	7d 40 07 00 	mov.b	#7,	r13	;
    685e:	0c 49       	mov	r9,	r12	;
    6860:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006864 <.LVL105>:
    6864:	f4 3f       	jmp	$-22     	;abs 0x684e

00006866 <verify_fw_cb>:
    6866:	b0 12 fc 9f 	call	#-24580	;#0x9ffc

0000686a <.LVL107>:
  if (result == verify_crc) {
    686a:	1c 92 42 b7 	cmp	&0xb742,r12	;0xb742

0000686e <L0>:
    686e:	1e 24       	jz	$+62     	;abs 0x68ac

00006870 <.Loc.1452.1>:
    gen_failure(stored_buff, stored_buff[0] & 0x80); /* crc */
    6870:	1c 42 40 b7 	mov	&0xb740,r12	;0xb740

00006874 <.LVL108>:
    6874:	6d 4c       	mov.b	@r12,	r13	;
    6876:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    687a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000687e <.LBB102>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    687e:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    6882:	00 00 

00006884 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    6884:	0d 93       	cmp	#0,	r13	;r3 As==00
    6886:	35 24       	jz	$+108    	;abs 0x68f2
    6888:	6e 43       	mov.b	#2,	r14	;r3 As==10

0000688a <.L99>:
    688a:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000688e <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    688e:	1e 42 84 b1 	mov	&0xb184,r14	;0xb184
    6892:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    6896:	02 00 

00006898 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6898:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    689c:	03 00 

0000689e <.Loc.35.1>:
  if (crc) {
    689e:	0d 93       	cmp	#0,	r13	;r3 As==00
    68a0:	2a 20       	jnz	$+86     	;abs 0x68f6

000068a2 <.L98>:
  elyCmdSendReplyI(stored_buff);
    68a2:	1c 42 40 b7 	mov	&0xb740,r12	;0xb740
    68a6:	b0 12 6c 66 	call	#26220		;#0x666c

000068aa <.LVL111>:
}
    68aa:	30 41       	ret			

000068ac <.L102>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    68ac:	1c 42 40 b7 	mov	&0xb740,r12	;0xb740

000068b0 <.LVL113>:
    68b0:	6d 4c       	mov.b	@r12,	r13	;
    68b2:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    68b6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000068ba <.LBB105>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    68ba:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    68be:	00 00 

000068c0 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    68c0:	0d 93       	cmp	#0,	r13	;r3 As==00
    68c2:	15 24       	jz	$+44     	;abs 0x68ee
    68c4:	7e 40 03 00 	mov.b	#3,	r14	;

000068c8 <.L97>:
    68c8:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

000068cc <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    68cc:	1e 42 84 b1 	mov	&0xb184,r14	;0xb184
    68d0:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    68d4:	02 00 

000068d6 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    68d6:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    68da:	03 00 

000068dc <.Loc.24.1>:
  buffer[4] = 1;
    68dc:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

000068e0 <.Loc.25.1>:
  if (crc) {
    68e0:	0d 93       	cmp	#0,	r13	;r3 As==00
    68e2:	df 27       	jz	$-64     	;abs 0x68a2

000068e4 <.Loc.26.1>:
    crcGenX25(buffer, 7);
    68e4:	7d 40 07 00 	mov.b	#7,	r13	;

000068e8 <.LVL115>:
    68e8:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000068ec <.LVL116>:
    68ec:	da 3f       	jmp	$-74     	;abs 0x68a2

000068ee <.L100>:
  buffer[1] = (crc ? 3 : 1);
    68ee:	5e 43       	mov.b	#1,	r14	;r3 As==01
    68f0:	eb 3f       	jmp	$-40     	;abs 0x68c8

000068f2 <.L101>:
  buffer[1] = (crc ? 2 : 0);
    68f2:	0e 4d       	mov	r13,	r14	;
    68f4:	ca 3f       	jmp	$-106    	;abs 0x688a

000068f6 <.L103>:
    crcGenX25(buffer, 6);
    68f6:	7d 40 06 00 	mov.b	#6,	r13	;

000068fa <.LVL119>:
    68fa:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000068fe <.LVL120>:
    68fe:	d1 3f       	jmp	$-92     	;abs 0x68a2

00006900 <upload_fw_reply_cb>:
    6900:	0a 15       	pushm	#1,	r10	;16-bit words

00006902 <.LCFI14>:
  buffer = buffer - 8;
    6902:	0a 4c       	mov	r12,	r10	;
    6904:	3a 50 f8 ff 	add	#-8,	r10	;#0xfff8

00006908 <L0>:
    gen_success(buffer, buffer[0] & 0x80); /* crc */
    6908:	5c 4c f8 ff 	mov.b	-8(r12),r12	;
    690c:	7c f0 80 ff 	and.b	#-128,	r12	;#0xff80
    6910:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006914 <.LBB110>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6914:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6918:	00 00 

0000691a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    691a:	0c 93       	cmp	#0,	r12	;r3 As==00
    691c:	15 24       	jz	$+44     	;abs 0x6948
    691e:	7d 40 03 00 	mov.b	#3,	r13	;

00006922 <.L105>:
    6922:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006926 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6926:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    692a:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    692e:	02 00 

00006930 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6930:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6934:	03 00 

00006936 <.Loc.24.1>:
  buffer[4] = 1;
    6936:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

0000693a <.Loc.25.1>:
  if (crc) {
    693a:	0c 93       	cmp	#0,	r12	;r3 As==00
    693c:	07 20       	jnz	$+16     	;abs 0x694c

0000693e <.L106>:
    elyCmdSendReplyI(buffer);
    693e:	0c 4a       	mov	r10,	r12	;
    6940:	b0 12 6c 66 	call	#26220		;#0x666c

00006944 <.LVL125>:
}
    6944:	0a 17       	popm	#1,	r10	;16-bit words
    6946:	30 41       	ret			

00006948 <.L107>:
  buffer[1] = (crc ? 3 : 1);
    6948:	5d 43       	mov.b	#1,	r13	;r3 As==01
    694a:	eb 3f       	jmp	$-40     	;abs 0x6922

0000694c <.L108>:
    crcGenX25(buffer, 7);
    694c:	7d 40 07 00 	mov.b	#7,	r13	;
    6950:	0c 4a       	mov	r10,	r12	;

00006952 <.LVL127>:
    6952:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006956 <.LVL128>:
    6956:	f3 3f       	jmp	$-24     	;abs 0x693e

00006958 <elyCmdSendReply>:
    6958:	32 c2       	dint			

0000695a <.Loc.348.2>:
  asm volatile("nop");
    695a:	03 43       	nop			

0000695c <L0>:
  msg = elyCmdSendReplyI(buff);
    695c:	b0 12 6c 66 	call	#26220		;#0x666c

00006960 <.LBB116>:
  asm volatile("nop");
    6960:	03 43       	nop			

00006962 <.Loc.356.2>:
  _enable_interrupts();
    6962:	32 d2       	eint			
    6964:	03 43       	nop			

00006966 <.LBE116>:
}
    6966:	30 41       	ret			

00006968 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6968:	4a 15       	pushm	#5,	r10	;16-bit words

0000696a <.LCFI15>:
    696a:	31 80 10 00 	sub	#16,	r1	;#0x0010

0000696e <.LCFI16>:
    696e:	0a 4c       	mov	r12,	r10	;

00006970 <.Loc.1639.1>:
    6970:	e1 4d 0e 00 	mov.b	@r13,	14(r1)	; 0x000e
    6974:	d1 4d 01 00 	mov.b	1(r13),	15(r1)	; 0x000f
    6978:	0f 00 

0000697a <.Loc.1640.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    697a:	5d 41 0e 00 	mov.b	14(r1),	r13	;0x0000e
    697e:	4e 4d       	mov.b	r13,	r14	;
    6980:	6e f3       	and.b	#2,	r14	;r3 As==10
    6982:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    6984:	24 24       	jz	$+74     	;abs 0x69ce
    6986:	69 42       	mov.b	#4,	r9	;r2 As==10

00006988 <.L111>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6988:	5c 41 0f 00 	mov.b	15(r1),	r12	;0x0000f

0000698c <.LVL133>:
    698c:	1d b3       	bit	#1,	r13	;r3 As==01
    698e:	21 24       	jz	$+68     	;abs 0x69d2

00006990 <.Loc.1641.1>:
    6990:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006992 <.L112>:
    6992:	4d 5e       	add.b	r14,	r13	;
    6994:	4c 8d       	sub.b	r13,	r12	;

00006996 <.LVL134>:
  config.duration = ((buffer[hdr_ext] << 8) | buffer[hdr_ext+1]);
    6996:	08 49       	mov	r9,	r8	;
    6998:	0d 4a       	mov	r10,	r13	;
    699a:	0d 59       	add	r9,	r13	;
    699c:	6e 4d       	mov.b	@r13,	r14	;
    699e:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    69a2:	5d 4d 01 00 	mov.b	1(r13),	r13	;
    69a6:	0d de       	bis	r14,	r13	;
    69a8:	81 4d 08 00 	mov	r13,	8(r1)	;

000069ac <.Loc.1646.1>:
  if (payload_len == 4 || payload_len == 12) {
    69ac:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    69ae:	13 24       	jz	$+40     	;abs 0x69d6

000069b0 <.LVL135>:
    69b0:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    69b4:	10 24       	jz	$+34     	;abs 0x69d6

000069b6 <.Loc.1652.1>:
    config.use_index = false;
    69b6:	c1 43 0c 00 	mov.b	#0,	12(r1)	;r3 As==00, 0x000c

000069ba <.L115>:
  if (payload_len > 4) {
    69ba:	6d 42       	mov.b	#4,	r13	;r2 As==10
    69bc:	4d 9c       	cmp.b	r12,	r13	;
    69be:	3e 2c       	jc	$+126    	;abs 0x6a3c

000069c0 <.Loc.1656.1>:
    config.use_timestamp = true;
    69c0:	d1 43 0d 00 	mov.b	#1,	13(r1)	;r3 As==01, 0x000d

000069c4 <.Loc.1657.1>:
    if (config.use_index) {
    69c4:	c1 93 0c 00 	cmp.b	#0,	12(r1)	;r3 As==00, 0x000c
    69c8:	4f 20       	jnz	$+160    	;abs 0x6a68
    69ca:	47 43       	clr.b	r7		;
    69cc:	73 3c       	jmp	$+232    	;abs 0x6ab4

000069ce <.L125>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    69ce:	69 43       	mov.b	#2,	r9	;r3 As==10
    69d0:	db 3f       	jmp	$-72     	;abs 0x6988

000069d2 <.L126>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    69d2:	4d 43       	clr.b	r13		;
    69d4:	de 3f       	jmp	$-66     	;abs 0x6992

000069d6 <.L113>:
    config.use_index = true;
    69d6:	d1 43 0c 00 	mov.b	#1,	12(r1)	;r3 As==01, 0x000c

000069da <.Loc.1648.1>:
    config.index_start = buffer[hdr_ext+2];
    69da:	0d 4a       	mov	r10,	r13	;
    69dc:	0d 58       	add	r8,	r13	;
    69de:	d1 4d 02 00 	mov.b	2(r13),	10(r1)	; 0x000a
    69e2:	0a 00 

000069e4 <.Loc.1649.1>:
    config.index_end = buffer[hdr_ext+3];
    69e4:	d1 4d 03 00 	mov.b	3(r13),	11(r1)	; 0x000b
    69e8:	0b 00 
    69ea:	e7 3f       	jmp	$-48     	;abs 0x69ba

000069ec <.L119>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    69ec:	0c 49       	mov	r9,	r12	;
    69ee:	3c 50 07 00 	add	#7,	r12	;
    69f2:	0c 87       	sub	r7,	r12	;
    69f4:	0c 5a       	add	r10,	r12	;
    69f6:	06 47       	mov	r7,	r6	;
    69f8:	42 18 06 56 	rpt #3 { rlax.w	r6		;
    69fc:	6c 4c       	mov.b	@r12,	r12	;
    69fe:	0d 46       	mov	r6,	r13	;
    6a00:	b0 12 4e ac 	call	#-21426	;#0xac4e
    6a04:	0e 4c       	mov	r12,	r14	;
    6a06:	0f 4c       	mov	r12,	r15	;
    6a08:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6a0c:	81 dc 00 00 	bis	r12,	0(r1)	;
    6a10:	81 df 02 00 	bis	r15,	2(r1)	;

00006a14 <.Loc.1660.1>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    6a14:	0c 4a       	mov	r10,	r12	;
    6a16:	0c 58       	add	r8,	r12	;
    6a18:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    6a1c:	0d 46       	mov	r6,	r13	;
    6a1e:	b0 12 4e ac 	call	#-21426	;#0xac4e
    6a22:	0e 4c       	mov	r12,	r14	;
    6a24:	0f 4c       	mov	r12,	r15	;
    6a26:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6a2a:	81 dc 04 00 	bis	r12,	4(r1)	;
    6a2e:	81 df 06 00 	bis	r15,	6(r1)	;

00006a32 <.Loc.1658.1>:
      for (int i = 0; i < 4; i++) {
    6a32:	17 53       	inc	r7		;

00006a34 <.L117>:
    6a34:	7c 40 03 00 	mov.b	#3,	r12	;
    6a38:	0c 97       	cmp	r7,	r12	;
    6a3a:	d8 37       	jge	$-78     	;abs 0x69ec

00006a3c <.L116>:
  _disable_interrupts();
    6a3c:	32 c2       	dint			

00006a3e <.Loc.348.2>:
  asm volatile("nop");
    6a3e:	03 43       	nop			

00006a40 <.LBE127>:
  elyTelemUpdateConfigS(config);
    6a40:	0c 41       	mov	r1,	r12	;
    6a42:	b0 12 9a aa 	call	#-21862	;#0xaa9a

00006a46 <.LBB129>:
  asm volatile("nop");
    6a46:	03 43       	nop			

00006a48 <.Loc.356.2>:
  _enable_interrupts();
    6a48:	32 d2       	eint			
    6a4a:	03 43       	nop			

00006a4c <.LBE129>:
  if (hdr.reply) {
    6a4c:	5c 41 0e 00 	mov.b	14(r1),	r12	;0x0000e
    6a50:	6c f3       	and.b	#2,	r12	;r3 As==10
    6a52:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6a54:	34 20       	jnz	$+106    	;abs 0x6abe

00006a56 <.Loc.1682.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6a56:	0c 4a       	mov	r10,	r12	;
    6a58:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006a5c <.LVL145>:
    6a5c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006a60 <.L110>:
}
    6a60:	31 50 10 00 	add	#16,	r1	;#0x0010
    6a64:	46 17       	popm	#5,	r10	;16-bit words
    6a66:	30 41       	ret			

00006a68 <.L127>:
    6a68:	47 43       	clr.b	r7		;
    6a6a:	e4 3f       	jmp	$-54     	;abs 0x6a34

00006a6c <.L120>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    6a6c:	0c 49       	mov	r9,	r12	;
    6a6e:	3c 50 05 00 	add	#5,	r12	;
    6a72:	0c 87       	sub	r7,	r12	;
    6a74:	0c 5a       	add	r10,	r12	;
    6a76:	06 47       	mov	r7,	r6	;
    6a78:	42 18 06 56 	rpt #3 { rlax.w	r6		;
    6a7c:	6c 4c       	mov.b	@r12,	r12	;
    6a7e:	0d 46       	mov	r6,	r13	;
    6a80:	b0 12 4e ac 	call	#-21426	;#0xac4e
    6a84:	0e 4c       	mov	r12,	r14	;
    6a86:	0f 4c       	mov	r12,	r15	;
    6a88:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6a8c:	81 dc 00 00 	bis	r12,	0(r1)	;
    6a90:	81 df 02 00 	bis	r15,	2(r1)	;

00006a94 <.Loc.1666.1>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6a94:	0c 4a       	mov	r10,	r12	;
    6a96:	0c 58       	add	r8,	r12	;
    6a98:	5c 4c 08 00 	mov.b	8(r12),	r12	;
    6a9c:	0d 46       	mov	r6,	r13	;
    6a9e:	b0 12 4e ac 	call	#-21426	;#0xac4e
    6aa2:	0e 4c       	mov	r12,	r14	;
    6aa4:	0f 4c       	mov	r12,	r15	;
    6aa6:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6aaa:	81 dc 04 00 	bis	r12,	4(r1)	;
    6aae:	81 df 06 00 	bis	r15,	6(r1)	;

00006ab2 <.Loc.1664.1>:
      for (int i = 0; i < 4; i++) {
    6ab2:	17 53       	inc	r7		;

00006ab4 <.L118>:
    6ab4:	7d 40 03 00 	mov.b	#3,	r13	;
    6ab8:	0d 97       	cmp	r7,	r13	;
    6aba:	d8 37       	jge	$-78     	;abs 0x6a6c
    6abc:	bf 3f       	jmp	$-128    	;abs 0x6a3c

00006abe <.L129>:
    gen_success(buffer, hdr.crc);
    6abe:	5c 41 0e 00 	mov.b	14(r1),	r12	;0x0000e
    6ac2:	5c f3       	and.b	#1,	r12	;r3 As==01

00006ac4 <.LBB132>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6ac4:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6ac8:	00 00 

00006aca <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    6aca:	0c 93       	cmp	#0,	r12	;r3 As==00
    6acc:	14 24       	jz	$+42     	;abs 0x6af6
    6ace:	7d 40 03 00 	mov.b	#3,	r13	;

00006ad2 <.L122>:
    6ad2:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006ad6 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6ad6:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6ada:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6ade:	02 00 

00006ae0 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6ae0:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6ae4:	03 00 

00006ae6 <.Loc.24.1>:
  buffer[4] = 1;
    6ae6:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006aea <.Loc.25.1>:
  if (crc) {
    6aea:	0c 93       	cmp	#0,	r12	;r3 As==00
    6aec:	06 20       	jnz	$+14     	;abs 0x6afa

00006aee <.L123>:
    elyCmdSendReply(buffer);
    6aee:	0c 4a       	mov	r10,	r12	;
    6af0:	b0 12 58 69 	call	#26968		;#0x6958

00006af4 <.LVL155>:
    6af4:	b5 3f       	jmp	$-148    	;abs 0x6a60

00006af6 <.L128>:
  buffer[1] = (crc ? 3 : 1);
    6af6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6af8:	ec 3f       	jmp	$-38     	;abs 0x6ad2

00006afa <.L130>:
    crcGenX25(buffer, 7);
    6afa:	7d 40 07 00 	mov.b	#7,	r13	;
    6afe:	0c 4a       	mov	r10,	r12	;
    6b00:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006b04 <.LVL157>:
    6b04:	f4 3f       	jmp	$-22     	;abs 0x6aee

00006b06 <upload_fw>:
    6b06:	6a 15       	pushm	#7,	r10	;16-bit words

00006b08 <.LCFI17>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6b08:	31 82       	sub	#8,	r1	;r2 As==11

00006b0a <.LCFI18>:
    6b0a:	07 4c       	mov	r12,	r7	;

00006b0c <.Loc.1402.1>:
    6b0c:	e1 4d 06 00 	mov.b	@r13,	6(r1)	;
    6b10:	d1 4d 01 00 	mov.b	1(r13),	7(r1)	;
    6b14:	07 00 

00006b16 <.Loc.1403.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6b16:	54 41       	mov.b,		r4	;Warning: disassembly unreliable - not enough bytes available

00006b18 <L0>:
    6b18:	06 00       	mova	@r0,	r6	;
    6b1a:	45 44       	mov.b	r4,	r5	;
    6b1c:	65 f3       	and.b	#2,	r5	;r3 As==10
    6b1e:	35 f0 ff 00 	and	#255,	r5	;#0x00ff
    6b22:	05 93       	cmp	#0,	r5	;r3 As==00
    6b24:	05 24       	jz	$+12     	;abs 0x6b30
    6b26:	66 42       	mov.b	#4,	r6	;r2 As==10

00006b28 <.L132>:
  for (int i = 0; i < 4; i++) {
    6b28:	4a 43       	clr.b	r10		;

00006b2a <.LBE139>:
  uint32_t address = 0;
    6b2a:	09 4a       	mov	r10,	r9	;
    6b2c:	08 4a       	mov	r10,	r8	;

00006b2e <.LBB140>:
  for (int i = 0; i < 4; i++) {
    6b2e:	14 3c       	jmp	$+42     	;abs 0x6b58

00006b30 <.L144>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6b30:	66 43       	mov.b	#2,	r6	;r3 As==10
    6b32:	fa 3f       	jmp	$-10     	;abs 0x6b28

00006b34 <.L134>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    6b34:	0c 46       	mov	r6,	r12	;
    6b36:	0c 5a       	add	r10,	r12	;
    6b38:	0c 57       	add	r7,	r12	;
    6b3a:	3e 40 03 00 	mov	#3,	r14	;
    6b3e:	0e 8a       	sub	r10,	r14	;
    6b40:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    6b44:	6c 4c       	mov.b	@r12,	r12	;
    6b46:	0d 43       	clr	r13		;
    6b48:	0f 43       	clr	r15		;
    6b4a:	b0 12 98 ac 	call	#-21352	;#0xac98
    6b4e:	0c d9       	bis	r9,	r12	;
    6b50:	0d d8       	bis	r8,	r13	;
    6b52:	09 4c       	mov	r12,	r9	;

00006b54 <.LVL163>:
    6b54:	08 4d       	mov	r13,	r8	;

00006b56 <.LVL164>:
  for (int i = 0; i < 4; i++) {
    6b56:	1a 53       	inc	r10		;

00006b58 <.L133>:
    6b58:	7c 40 03 00 	mov.b	#3,	r12	;
    6b5c:	0c 9a       	cmp	r10,	r12	;
    6b5e:	ea 37       	jge	$-42     	;abs 0x6b34

00006b60 <.LBE141>:
  if (address < 0x4400 || address > 0x13FFF) {
    6b60:	0e 49       	mov	r9,	r14	;
    6b62:	3e 50 00 bc 	add	#-17408,r14	;#0xbc00
    6b66:	0c 48       	mov	r8,	r12	;
    6b68:	3c 63       	addc	#-1,	r12	;r3 As==11
    6b6a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b6c:	1d 24       	jz	$+60     	;abs 0x6ba8

00006b6e <.L148>:
    if (hdr.reply) {
    6b6e:	05 93       	cmp	#0,	r5	;r3 As==00
    6b70:	77 24       	jz	$+240    	;abs 0x6c60

00006b72 <.Loc.1414.1>:
      gen_failure(buffer, hdr.crc);
    6b72:	5c 41 06 00 	mov.b	6(r1),	r12	;
    6b76:	5c f3       	and.b	#1,	r12	;r3 As==01

00006b78 <.LBB142>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6b78:	f7 f0 3f 00 	and.b	#63,	0(r7)	;#0x003f
    6b7c:	00 00 

00006b7e <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    6b7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b80:	67 24       	jz	$+208    	;abs 0x6c50
    6b82:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006b84 <.L138>:
    6b84:	c7 4d 01 00 	mov.b	r13,	1(r7)	;

00006b88 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6b88:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6b8c:	d7 4d 51 00 	mov.b	81(r13),2(r7)	;0x00051
    6b90:	02 00 

00006b92 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6b92:	d7 4d 50 00 	mov.b	80(r13),3(r7)	;0x00050
    6b96:	03 00 

00006b98 <.Loc.35.1>:
  if (crc) {
    6b98:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b9a:	5c 20       	jnz	$+186    	;abs 0x6c54

00006b9c <.L139>:
      elyCmdSendReply(buffer);
    6b9c:	0c 47       	mov	r7,	r12	;
    6b9e:	b0 12 58 69 	call	#26968		;#0x6958

00006ba2 <.L131>:
}
    6ba2:	31 52       	add	#8,	r1	;r2 As==11
    6ba4:	64 17       	popm	#7,	r10	;16-bit words
    6ba6:	30 41       	ret			

00006ba8 <.L149>:
  if (address < 0x4400 || address > 0x13FFF) {
    6ba8:	0c 93       	cmp	#0,	r12	;r3 As==00
    6baa:	04 20       	jnz	$+10     	;abs 0x6bb4
    6bac:	3f 40 ff fb 	mov	#-1025,	r15	;#0xfbff
    6bb0:	0f 9e       	cmp	r14,	r15	;
    6bb2:	dd 2b       	jnc	$-68     	;abs 0x6b6e

00006bb4 <.L135>:
  elyFramGetRequest(&req);
    6bb4:	0c 41       	mov	r1,	r12	;
    6bb6:	2c 52       	add	#4,	r12	;r2 As==10
    6bb8:	b0 12 20 a2 	call	#-24032	;#0xa220

00006bbc <.LVL170>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    6bbc:	1c 41 04 00 	mov	4(r1),	r12	;
    6bc0:	39 50 00 c0 	add	#-16384,r9	;#0xc000

00006bc4 <.LVL171>:
    6bc4:	8c 49 00 00 	mov	r9,	0(r12)	;
    6bc8:	08 63       	adc	r8		;
    6bca:	8c 48 02 00 	mov	r8,	2(r12)	;

00006bce <.Loc.1432.1>:
  req->read = 0;
    6bce:	1c 41 04 00 	mov	4(r1),	r12	;
    6bd2:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

00006bd6 <.Loc.1433.1>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    6bd6:	5d 41 07 00 	mov.b	7(r1),	r13	;
    6bda:	0d 85       	sub	r5,	r13	;
    6bdc:	14 b3       	bit	#1,	r4	;r3 As==01
    6bde:	4a 24       	jz	$+150    	;abs 0x6c74
    6be0:	6e 43       	mov.b	#2,	r14	;r3 As==10

00006be2 <.L141>:
    6be2:	0d 8e       	sub	r14,	r13	;
    6be4:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc
    6be8:	0e 4d       	mov	r13,	r14	;
    6bea:	4e 0e       	rlam.a	#4,	r14	;
    6bec:	4e 0d       	rram.a	#4,	r14	;
    6bee:	80 18 7e f0 	andx.a	#131071,r14	;0x1ffff
    6bf2:	ff ff 
    6bf4:	71 0e 00 00 	mova	r14,	0(r1)	;
    6bf8:	0d 4e       	mov	r14,	r13	;
    6bfa:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    6bfe:	1e 4c 04 00 	mov	4(r12),	r14	;
    6c02:	7e f0 03 00 	and.b	#3,	r14	;
    6c06:	0e dd       	bis	r13,	r14	;
    6c08:	8c 4e 04 00 	mov	r14,	4(r12)	;
    6c0c:	2e 41       	mov	@r1,	r14	;
    6c0e:	0d 4e       	mov	r14,	r13	;
    6c10:	5d 03       	rrum	#1,	r13	;
    6c12:	4c 18 0d 11 	rpt #13 { rrax.w	r13		;
    6c16:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    6c1a:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
    6c1e:	4e dd       	bis.b	r13,	r14	;
    6c20:	0f 01       	mova	@r1,	r15	;
    6c22:	0f 14       	pushm.a	#1,	r15	;20-bit words
    6c24:	0d 17       	popm	#1,	r13	;16-bit words
    6c26:	0d 17       	popm	#1,	r13	;16-bit words
    6c28:	5d f3       	and.b	#1,	r13	;r3 As==01
    6c2a:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    6c2e:	6e c2       	bic.b	#4,	r14	;r2 As==10
    6c30:	4e dd       	bis.b	r13,	r14	;
    6c32:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00006c36 <.Loc.1434.1>:
  lookbehind = hdr_ext+4;
    6c36:	26 52       	add	#4,	r6	;r2 As==10

00006c38 <.LVL173>:
  req->buffer = &buffer[lookbehind];
    6c38:	07 56       	add	r6,	r7	;

00006c3a <.LVL174>:
    6c3a:	8c 47 08 00 	mov	r7,	8(r12)	;

00006c3e <.Loc.1436.1>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6c3e:	05 93       	cmp	#0,	r5	;r3 As==00
    6c40:	1b 20       	jnz	$+56     	;abs 0x6c78

00006c42 <.Loc.1436.1>:
    6c42:	3d 40 a6 62 	mov	#25254,	r13	;#0x62a6

00006c46 <.L142>:
    6c46:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006c4a <.Loc.1440.1>:
  elyFramPostRequest(req);
    6c4a:	b0 12 3a a2 	call	#-24006	;#0xa23a

00006c4e <.LVL175>:
    6c4e:	a9 3f       	jmp	$-172    	;abs 0x6ba2

00006c50 <.L145>:
  buffer[1] = (crc ? 2 : 0);
    6c50:	0d 4c       	mov	r12,	r13	;
    6c52:	98 3f       	jmp	$-206    	;abs 0x6b84

00006c54 <.L150>:
    crcGenX25(buffer, 6);
    6c54:	7d 40 06 00 	mov.b	#6,	r13	;
    6c58:	0c 47       	mov	r7,	r12	;
    6c5a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006c5e <.LVL177>:
    6c5e:	9e 3f       	jmp	$-194    	;abs 0x6b9c

00006c60 <.L137>:
      elyErrorSignal(ErrCmdFailure);
    6c60:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6c64:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006c68 <.LVL179>:
      elyNLFreeBuffer(elyNLPack(buffer));
    6c68:	0c 47       	mov	r7,	r12	;
    6c6a:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006c6e <.LVL180>:
    6c6e:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006c72 <.LVL181>:
    6c72:	97 3f       	jmp	$-208    	;abs 0x6ba2

00006c74 <.L146>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    6c74:	4e 43       	clr.b	r14		;
    6c76:	b5 3f       	jmp	$-148    	;abs 0x6be2

00006c78 <.L151>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6c78:	3d 40 00 69 	mov	#26880,	r13	;#0x6900
    6c7c:	e4 3f       	jmp	$-54     	;abs 0x6c46

00006c7e <set_log>:
    6c7e:	1a 15       	pushm	#2,	r10	;16-bit words

00006c80 <.LCFI19>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6c80:	21 83       	decd	r1		;

00006c82 <.LCFI20>:
    6c82:	0a 4c       	mov	r12,	r10	;

00006c84 <.Loc.1351.1>:
    6c84:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6c88:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6c8c:	01 00 

00006c8e <L0>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6c8e:	69 41       	mov.b	@r1,	r9	;
    6c90:	69 f3       	and.b	#2,	r9	;r3 As==10
    6c92:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    6c96:	09 93       	cmp	#0,	r9	;r3 As==00
    6c98:	23 24       	jz	$+72     	;abs 0x6ce0
    6c9a:	6c 42       	mov.b	#4,	r12	;r2 As==10

00006c9c <.L153>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    6c9c:	0c 5a       	add	r10,	r12	;

00006c9e <.LVL186>:
    6c9e:	6d 4c       	mov.b	@r12,	r13	;
    6ca0:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    6ca4:	4e 9d       	cmp.b	r13,	r14	;
    6ca6:	30 2c       	jc	$+98     	;abs 0x6d08

00006ca8 <.Loc.1355.1>:
    if (hdr.reply) {
    6ca8:	09 93       	cmp	#0,	r9	;r3 As==00
    6caa:	24 24       	jz	$+74     	;abs 0x6cf4

00006cac <.Loc.1357.1>:
      gen_failure(buffer, hdr.crc);
    6cac:	6c 41       	mov.b	@r1,	r12	;
    6cae:	5c f3       	and.b	#1,	r12	;r3 As==01

00006cb0 <.LBB154>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6cb0:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6cb4:	00 00 

00006cb6 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    6cb6:	0c 93       	cmp	#0,	r12	;r3 As==00
    6cb8:	15 24       	jz	$+44     	;abs 0x6ce4
    6cba:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006cbc <.L156>:
    6cbc:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006cc0 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6cc0:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6cc4:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6cc8:	02 00 

00006cca <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6cca:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6cce:	03 00 

00006cd0 <.Loc.35.1>:
  if (crc) {
    6cd0:	0c 93       	cmp	#0,	r12	;r3 As==00
    6cd2:	0a 20       	jnz	$+22     	;abs 0x6ce8

00006cd4 <.L157>:
      elyCmdSendReply(buffer);
    6cd4:	0c 4a       	mov	r10,	r12	;
    6cd6:	b0 12 58 69 	call	#26968		;#0x6958

00006cda <.L152>:
}
    6cda:	21 53       	incd	r1		;
    6cdc:	19 17       	popm	#2,	r10	;16-bit words
    6cde:	30 41       	ret			

00006ce0 <.L162>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ce0:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6ce2:	dc 3f       	jmp	$-70     	;abs 0x6c9c

00006ce4 <.L163>:
  buffer[1] = (crc ? 2 : 0);
    6ce4:	0d 4c       	mov	r12,	r13	;
    6ce6:	ea 3f       	jmp	$-42     	;abs 0x6cbc

00006ce8 <.L165>:
    crcGenX25(buffer, 6);
    6ce8:	7d 40 06 00 	mov.b	#6,	r13	;
    6cec:	0c 4a       	mov	r10,	r12	;
    6cee:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006cf2 <.LVL191>:
    6cf2:	f0 3f       	jmp	$-30     	;abs 0x6cd4

00006cf4 <.L155>:
      elyErrorSignal(ErrCmdFailure);
    6cf4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6cf8:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006cfc <.LVL193>:
      elyNLFreeBuffer(elyNLPack(buffer));
    6cfc:	0c 4a       	mov	r10,	r12	;
    6cfe:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006d02 <.LVL194>:
    6d02:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006d06 <.LVL195>:
    6d06:	e9 3f       	jmp	$-44     	;abs 0x6cda

00006d08 <.L154>:
  bank0w[RegErrLogLvl] = buffer[hdr_ext];
    6d08:	1e 42 82 b1 	mov	&0xb182,r14	;0xb182
    6d0c:	ce 4d 4d 00 	mov.b	r13,	77(r14)	; 0x004d

00006d10 <.LBB158>:
  _disable_interrupts();
    6d10:	32 c2       	dint			

00006d12 <.Loc.348.2>:
  asm volatile("nop");
    6d12:	03 43       	nop			

00006d14 <.LBE158>:
  elyErrorSetLogLvlS(buffer[hdr_ext]);
    6d14:	6c 4c       	mov.b	@r12,	r12	;
    6d16:	b0 12 b4 a9 	call	#-22092	;#0xa9b4

00006d1a <.LBB160>:
  asm volatile("nop");
    6d1a:	03 43       	nop			

00006d1c <.Loc.356.2>:
  _enable_interrupts();
    6d1c:	32 d2       	eint			
    6d1e:	03 43       	nop			

00006d20 <.LBE160>:
  if (hdr.reply) {
    6d20:	09 93       	cmp	#0,	r9	;r3 As==00
    6d22:	06 20       	jnz	$+14     	;abs 0x6d30

00006d24 <.Loc.1381.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6d24:	0c 4a       	mov	r10,	r12	;
    6d26:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006d2a <.LVL197>:
    6d2a:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006d2e <.LVL198>:
    6d2e:	d5 3f       	jmp	$-84     	;abs 0x6cda

00006d30 <.L166>:
    gen_success(buffer, hdr.crc);
    6d30:	6c 41       	mov.b	@r1,	r12	;
    6d32:	5c f3       	and.b	#1,	r12	;r3 As==01

00006d34 <.LBB162>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6d34:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6d38:	00 00 

00006d3a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    6d3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d3c:	14 24       	jz	$+42     	;abs 0x6d66
    6d3e:	7d 40 03 00 	mov.b	#3,	r13	;

00006d42 <.L160>:
    6d42:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006d46 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6d46:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6d4a:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6d4e:	02 00 

00006d50 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6d50:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6d54:	03 00 

00006d56 <.Loc.24.1>:
  buffer[4] = 1;
    6d56:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006d5a <.Loc.25.1>:
  if (crc) {
    6d5a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d5c:	06 20       	jnz	$+14     	;abs 0x6d6a

00006d5e <.L161>:
    elyCmdSendReply(buffer);
    6d5e:	0c 4a       	mov	r10,	r12	;
    6d60:	b0 12 58 69 	call	#26968		;#0x6958

00006d64 <.LVL201>:
    6d64:	ba 3f       	jmp	$-138    	;abs 0x6cda

00006d66 <.L164>:
  buffer[1] = (crc ? 3 : 1);
    6d66:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6d68:	ec 3f       	jmp	$-38     	;abs 0x6d42

00006d6a <.L167>:
    crcGenX25(buffer, 7);
    6d6a:	7d 40 07 00 	mov.b	#7,	r13	;
    6d6e:	0c 4a       	mov	r10,	r12	;
    6d70:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006d74 <.LVL203>:
    6d74:	f4 3f       	jmp	$-22     	;abs 0x6d5e

00006d76 <get_log>:
    6d76:	0a 15       	pushm	#1,	r10	;16-bit words

00006d78 <.LCFI21>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6d78:	21 83       	decd	r1		;

00006d7a <.LCFI22>:
    6d7a:	0a 4c       	mov	r12,	r10	;

00006d7c <.Loc.1328.1>:
    6d7c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6d80:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6d84:	01 00 

00006d86 <L0>:
  if (hdr.reply) {
    6d86:	6d 41       	mov.b	@r1,	r13	;
    6d88:	4c 4d       	mov.b	r13,	r12	;

00006d8a <.LVL205>:
    6d8a:	6c f3       	and.b	#2,	r12	;r3 As==10
    6d8c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6d8e:	21 24       	jz	$+68     	;abs 0x6dd2

00006d90 <.Loc.1331.1>:
    buffer[0] = buffer[0] & 0x3F;
    6d90:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6d94:	00 00 

00006d96 <.Loc.1332.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    6d96:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    6d9a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    6d9e:	02 00 

00006da0 <.Loc.1333.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    6da0:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    6da4:	03 00 

00006da6 <.Loc.1334.1>:
    buffer[4] = bank0p[RegErrLogLvl];
    6da6:	da 4c 4d 00 	mov.b	77(r12),4(r10)	;0x0004d
    6daa:	04 00 

00006dac <.Loc.1335.1>:
    if (hdr.crc) {
    6dac:	1d b3       	bit	#1,	r13	;r3 As==01
    6dae:	08 20       	jnz	$+18     	;abs 0x6dc0

00006db0 <.Loc.1340.1>:
      buffer[1] = 1;
    6db0:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00006db4 <.L171>:
    elyCmdSendReply(buffer);
    6db4:	0c 4a       	mov	r10,	r12	;
    6db6:	b0 12 58 69 	call	#26968		;#0x6958

00006dba <.L168>:
}
    6dba:	21 53       	incd	r1		;
    6dbc:	0a 17       	popm	#1,	r10	;16-bit words
    6dbe:	30 41       	ret			

00006dc0 <.L173>:
      buffer[1] = 3;
    6dc0:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    6dc4:	01 00 

00006dc6 <.Loc.1337.1>:
      crcGenX25(buffer, 7);
    6dc6:	7d 40 07 00 	mov.b	#7,	r13	;
    6dca:	0c 4a       	mov	r10,	r12	;
    6dcc:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006dd0 <.LVL207>:
    6dd0:	f1 3f       	jmp	$-28     	;abs 0x6db4

00006dd2 <.L169>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6dd2:	0c 4a       	mov	r10,	r12	;
    6dd4:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006dd8 <.LVL208>:
    6dd8:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006ddc <.LVL209>:
}
    6ddc:	ee 3f       	jmp	$-34     	;abs 0x6dba

00006dde <set_err>:
    6dde:	1a 15       	pushm	#2,	r10	;16-bit words

00006de0 <.LCFI23>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6de0:	21 83       	decd	r1		;

00006de2 <L0>:
    6de2:	0a 4c       	mov	r12,	r10	;

00006de4 <.Loc.1293.1>:
    6de4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6de8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6dec:	01 00 

00006dee <.Loc.1294.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6dee:	69 41       	mov.b	@r1,	r9	;
    6df0:	69 f3       	and.b	#2,	r9	;r3 As==10
    6df2:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    6df6:	09 93       	cmp	#0,	r9	;r3 As==00
    6df8:	23 24       	jz	$+72     	;abs 0x6e40
    6dfa:	6c 42       	mov.b	#4,	r12	;r2 As==10

00006dfc <.L175>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    6dfc:	0c 5a       	add	r10,	r12	;

00006dfe <.LVL212>:
    6dfe:	6d 4c       	mov.b	@r12,	r13	;
    6e00:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    6e04:	4e 9d       	cmp.b	r13,	r14	;
    6e06:	30 2c       	jc	$+98     	;abs 0x6e68

00006e08 <.Loc.1297.1>:
    if (hdr.reply) {
    6e08:	09 93       	cmp	#0,	r9	;r3 As==00
    6e0a:	24 24       	jz	$+74     	;abs 0x6e54

00006e0c <.Loc.1299.1>:
      gen_failure(buffer, hdr.crc);
    6e0c:	6c 41       	mov.b	@r1,	r12	;
    6e0e:	5c f3       	and.b	#1,	r12	;r3 As==01

00006e10 <.LBB174>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6e10:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6e14:	00 00 

00006e16 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    6e16:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e18:	15 24       	jz	$+44     	;abs 0x6e44
    6e1a:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006e1c <.L178>:
    6e1c:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006e20 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6e20:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6e24:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6e28:	02 00 

00006e2a <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6e2a:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6e2e:	03 00 

00006e30 <.Loc.35.1>:
  if (crc) {
    6e30:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e32:	0a 20       	jnz	$+22     	;abs 0x6e48

00006e34 <.L179>:
      elyCmdSendReply(buffer);
    6e34:	0c 4a       	mov	r10,	r12	;
    6e36:	b0 12 58 69 	call	#26968		;#0x6958

00006e3a <.L174>:
}
    6e3a:	21 53       	incd	r1		;
    6e3c:	19 17       	popm	#2,	r10	;16-bit words
    6e3e:	30 41       	ret			

00006e40 <.L184>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6e40:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6e42:	dc 3f       	jmp	$-70     	;abs 0x6dfc

00006e44 <.L185>:
  buffer[1] = (crc ? 2 : 0);
    6e44:	0d 4c       	mov	r12,	r13	;
    6e46:	ea 3f       	jmp	$-42     	;abs 0x6e1c

00006e48 <.L187>:
    crcGenX25(buffer, 6);
    6e48:	7d 40 06 00 	mov.b	#6,	r13	;
    6e4c:	0c 4a       	mov	r10,	r12	;
    6e4e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006e52 <.LVL217>:
    6e52:	f0 3f       	jmp	$-30     	;abs 0x6e34

00006e54 <.L177>:
      elyErrorSignal(ErrCmdFailure);
    6e54:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6e58:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00006e5c <.LVL219>:
      elyNLFreeBuffer(elyNLPack(buffer));
    6e5c:	0c 4a       	mov	r10,	r12	;
    6e5e:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006e62 <.LVL220>:
    6e62:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006e66 <.LVL221>:
    6e66:	e9 3f       	jmp	$-44     	;abs 0x6e3a

00006e68 <.L176>:
  bank0w[RegErrRptLvl] = buffer[hdr_ext];
    6e68:	1e 42 82 b1 	mov	&0xb182,r14	;0xb182
    6e6c:	ce 4d 4c 00 	mov.b	r13,	76(r14)	; 0x004c

00006e70 <.LBB178>:
  _disable_interrupts();
    6e70:	32 c2       	dint			

00006e72 <.Loc.348.2>:
  asm volatile("nop");
    6e72:	03 43       	nop			

00006e74 <.LBE178>:
  elyErrorSetRptLvlS(buffer[hdr_ext]);
    6e74:	6c 4c       	mov.b	@r12,	r12	;
    6e76:	b0 12 b6 a9 	call	#-22090	;#0xa9b6

00006e7a <.LBB180>:
  asm volatile("nop");
    6e7a:	03 43       	nop			

00006e7c <.Loc.356.2>:
  _enable_interrupts();
    6e7c:	32 d2       	eint			
    6e7e:	03 43       	nop			

00006e80 <.LBE180>:
  if (hdr.reply) {
    6e80:	09 93       	cmp	#0,	r9	;r3 As==00
    6e82:	06 20       	jnz	$+14     	;abs 0x6e90

00006e84 <.Loc.1323.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6e84:	0c 4a       	mov	r10,	r12	;
    6e86:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006e8a <.LVL223>:
    6e8a:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006e8e <.LVL224>:
    6e8e:	d5 3f       	jmp	$-84     	;abs 0x6e3a

00006e90 <.L188>:
    gen_success(buffer, hdr.crc);
    6e90:	6c 41       	mov.b	@r1,	r12	;
    6e92:	5c f3       	and.b	#1,	r12	;r3 As==01

00006e94 <.LBB182>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6e94:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6e98:	00 00 

00006e9a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    6e9a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e9c:	14 24       	jz	$+42     	;abs 0x6ec6
    6e9e:	7d 40 03 00 	mov.b	#3,	r13	;

00006ea2 <.L182>:
    6ea2:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00006ea6 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6ea6:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    6eaa:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    6eae:	02 00 

00006eb0 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6eb0:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    6eb4:	03 00 

00006eb6 <.Loc.24.1>:
  buffer[4] = 1;
    6eb6:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006eba <.Loc.25.1>:
  if (crc) {
    6eba:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ebc:	06 20       	jnz	$+14     	;abs 0x6eca

00006ebe <.L183>:
    elyCmdSendReply(buffer);
    6ebe:	0c 4a       	mov	r10,	r12	;
    6ec0:	b0 12 58 69 	call	#26968		;#0x6958

00006ec4 <.LVL227>:
    6ec4:	ba 3f       	jmp	$-138    	;abs 0x6e3a

00006ec6 <.L186>:
  buffer[1] = (crc ? 3 : 1);
    6ec6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6ec8:	ec 3f       	jmp	$-38     	;abs 0x6ea2

00006eca <.L189>:
    crcGenX25(buffer, 7);
    6eca:	7d 40 07 00 	mov.b	#7,	r13	;
    6ece:	0c 4a       	mov	r10,	r12	;
    6ed0:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006ed4 <.LVL229>:
    6ed4:	f4 3f       	jmp	$-22     	;abs 0x6ebe

00006ed6 <get_err>:
    6ed6:	0a 15       	pushm	#1,	r10	;16-bit words

00006ed8 <.LCFI25>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6ed8:	21 83       	decd	r1		;

00006eda <.LCFI26>:
    6eda:	0a 4c       	mov	r12,	r10	;

00006edc <.Loc.1270.1>:
    6edc:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6ee0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6ee4:	01 00 

00006ee6 <L0>:
  if (hdr.reply) {
    6ee6:	6d 41       	mov.b	@r1,	r13	;
    6ee8:	4c 4d       	mov.b	r13,	r12	;

00006eea <.LVL231>:
    6eea:	6c f3       	and.b	#2,	r12	;r3 As==10
    6eec:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6eee:	21 24       	jz	$+68     	;abs 0x6f32

00006ef0 <.Loc.1273.1>:
    buffer[0] = buffer[0] & 0x3F;
    6ef0:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6ef4:	00 00 

00006ef6 <.Loc.1274.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    6ef6:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    6efa:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    6efe:	02 00 

00006f00 <.Loc.1275.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    6f00:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    6f04:	03 00 

00006f06 <.Loc.1276.1>:
    buffer[4] = bank0p[RegErrRptLvl];
    6f06:	da 4c 4c 00 	mov.b	76(r12),4(r10)	;0x0004c
    6f0a:	04 00 

00006f0c <.Loc.1277.1>:
    if (hdr.crc) {
    6f0c:	1d b3       	bit	#1,	r13	;r3 As==01
    6f0e:	08 20       	jnz	$+18     	;abs 0x6f20

00006f10 <.Loc.1282.1>:
      buffer[1] = 1;
    6f10:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00006f14 <.L193>:
    elyCmdSendReply(buffer);
    6f14:	0c 4a       	mov	r10,	r12	;
    6f16:	b0 12 58 69 	call	#26968		;#0x6958

00006f1a <.L190>:
}
    6f1a:	21 53       	incd	r1		;
    6f1c:	0a 17       	popm	#1,	r10	;16-bit words
    6f1e:	30 41       	ret			

00006f20 <.L195>:
      buffer[1] = 3;
    6f20:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    6f24:	01 00 

00006f26 <.Loc.1279.1>:
      crcGenX25(buffer, 7);
    6f26:	7d 40 07 00 	mov.b	#7,	r13	;
    6f2a:	0c 4a       	mov	r10,	r12	;
    6f2c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006f30 <.LVL233>:
    6f30:	f1 3f       	jmp	$-28     	;abs 0x6f14

00006f32 <.L191>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6f32:	0c 4a       	mov	r10,	r12	;
    6f34:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006f38 <.LVL234>:
    6f38:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006f3c <.LVL235>:
}
    6f3c:	ee 3f       	jmp	$-34     	;abs 0x6f1a

00006f3e <get_time>:
    6f3e:	0a 15       	pushm	#1,	r10	;16-bit words

00006f40 <.LCFI27>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6f40:	21 83       	decd	r1		;

00006f42 <L0>:
    6f42:	0a 4c       	mov	r12,	r10	;

00006f44 <.Loc.1247.1>:
    6f44:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6f48:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6f4c:	01 00 

00006f4e <.Loc.1249.1>:
  if (hdr.reply) {
    6f4e:	6b 41       	mov.b	@r1,	r11	;
    6f50:	4c 4b       	mov.b	r11,	r12	;

00006f52 <.LVL237>:
    6f52:	6c f3       	and.b	#2,	r12	;r3 As==10
    6f54:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6f56:	2c 24       	jz	$+90     	;abs 0x6fb0

00006f58 <.Loc.1250.1>:
    buffer[0] = buffer[0] & 0x3F;
    6f58:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    6f5c:	00 00 

00006f5e <.Loc.1251.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    6f5e:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    6f62:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    6f66:	02 00 

00006f68 <.Loc.1252.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    6f68:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    6f6c:	03 00 

00006f6e <.Loc.1253.1>:
    buffer[1] += 2;
    6f6e:	ea 53 01 00 	incd.b	1(r10)		;

00006f72 <.LBB186>:
    for (int i = 0; i < 4; i++) {
    6f72:	4c 43       	clr.b	r12		;
    6f74:	0a 3c       	jmp	$+22     	;abs 0x6f8a

00006f76 <.L199>:
      buffer[i + 4] = bank0p[RegMissionTimeMsb - i];
    6f76:	0d 4c       	mov	r12,	r13	;
    6f78:	2d 52       	add	#4,	r13	;r2 As==10
    6f7a:	0d 5a       	add	r10,	r13	;
    6f7c:	3e 40 76 00 	mov	#118,	r14	;#0x0076
    6f80:	0e 8c       	sub	r12,	r14	;
    6f82:	0e 5f       	add	r15,	r14	;
    6f84:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00006f88 <.Loc.1255.1>:
    for (int i = 0; i < 4; i++) {
    6f88:	1c 53       	inc	r12		;

00006f8a <.L198>:
    6f8a:	7d 40 03 00 	mov.b	#3,	r13	;
    6f8e:	0d 9c       	cmp	r12,	r13	;
    6f90:	f2 37       	jge	$-26     	;abs 0x6f76

00006f92 <.LBE186>:
    if (hdr.crc) {
    6f92:	1b b3       	bit	#1,	r11	;r3 As==01
    6f94:	06 20       	jnz	$+14     	;abs 0x6fa2

00006f96 <.L200>:
    elyCmdSendReply(buffer);
    6f96:	0c 4a       	mov	r10,	r12	;
    6f98:	b0 12 58 69 	call	#26968		;#0x6958

00006f9c <.L196>:
}
    6f9c:	21 53       	incd	r1		;
    6f9e:	0a 17       	popm	#1,	r10	;16-bit words
    6fa0:	30 41       	ret			

00006fa2 <.L202>:
      crcGenX25(buffer, buffer[1]+4);
    6fa2:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    6fa6:	2d 52       	add	#4,	r13	;r2 As==10
    6fa8:	0c 4a       	mov	r10,	r12	;

00006faa <.LVL244>:
    6faa:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00006fae <.LVL245>:
    6fae:	f3 3f       	jmp	$-24     	;abs 0x6f96

00006fb0 <.L197>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6fb0:	0c 4a       	mov	r10,	r12	;
    6fb2:	b0 12 4c a8 	call	#-22452	;#0xa84c

00006fb6 <.LVL246>:
    6fb6:	b0 12 1e a7 	call	#-22754	;#0xa71e

00006fba <.LVL247>:
}
    6fba:	f0 3f       	jmp	$-30     	;abs 0x6f9c

00006fbc <set_time>:
    6fbc:	0a 15       	pushm	#1,	r10	;16-bit words

00006fbe <.LCFI29>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6fbe:	21 83       	decd	r1		;

00006fc0 <.LCFI30>:
    6fc0:	0a 4c       	mov	r12,	r10	;

00006fc2 <L0>:
    6fc2:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    6fc6:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    6fca:	01 00 

00006fcc <.Loc.1222.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6fcc:	6f 41       	mov.b	@r1,	r15	;
    6fce:	4d 4f       	mov.b	r15,	r13	;
    6fd0:	6d f3       	and.b	#2,	r13	;r3 As==10
    6fd2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    6fd6:	0d 93       	cmp	#0,	r13	;r3 As==00
    6fd8:	2b 24       	jz	$+88     	;abs 0x7030
    6fda:	6c 42       	mov.b	#4,	r12	;r2 As==10

00006fdc <.L204>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    6fdc:	1e 42 82 b1 	mov	&0xb182,r14	;0xb182
    6fe0:	0c 5a       	add	r10,	r12	;

00006fe2 <.LVL250>:
    6fe2:	ee 4c 76 00 	mov.b	@r12,	118(r14); 0x0076

00006fe6 <.Loc.1226.1>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    6fe6:	de 4c 01 00 	mov.b	1(r12),	117(r14); 0x0075
    6fea:	75 00 

00006fec <.Loc.1227.1>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    6fec:	de 4c 02 00 	mov.b	2(r12),	116(r14); 0x0074
    6ff0:	74 00 

00006ff2 <.Loc.1228.1>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    6ff2:	de 4c 03 00 	mov.b	3(r12),	115(r14); 0x0073
    6ff6:	73 00 

00006ff8 <.Loc.1230.1>:
  if (hdr.reply) {
    6ff8:	0d 93       	cmp	#0,	r13	;r3 As==00
    6ffa:	21 24       	jz	$+68     	;abs 0x703e

00006ffc <.Loc.1231.1>:
    buffer[0] = buffer[0] & 0x3F;
    6ffc:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7000:	00 00 

00007002 <.Loc.1232.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7002:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    7006:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    700a:	02 00 

0000700c <.Loc.1233.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    700c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7010:	03 00 

00007012 <.Loc.1234.1>:
    buffer[1] -= 2;
    7012:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    7016:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    701a:	4d 4c       	mov.b	r12,	r13	;
    701c:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00007020 <.Loc.1235.1>:
    if (hdr.crc) {
    7020:	1f b3       	bit	#1,	r15	;r3 As==01
    7022:	08 20       	jnz	$+18     	;abs 0x7034

00007024 <.L206>:
    elyCmdSendReply(buffer);
    7024:	0c 4a       	mov	r10,	r12	;
    7026:	b0 12 58 69 	call	#26968		;#0x6958

0000702a <.L203>:
}
    702a:	21 53       	incd	r1		;
    702c:	0a 17       	popm	#1,	r10	;16-bit words
    702e:	30 41       	ret			

00007030 <.L208>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7030:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7032:	d4 3f       	jmp	$-86     	;abs 0x6fdc

00007034 <.L209>:
      crcGenX25(buffer, buffer[1]+4);
    7034:	2d 52       	add	#4,	r13	;r2 As==10
    7036:	0c 4a       	mov	r10,	r12	;
    7038:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000703c <.LVL252>:
    703c:	f3 3f       	jmp	$-24     	;abs 0x7024

0000703e <.L205>:
    elyNLFreeBuffer(elyNLPack(buffer));
    703e:	0c 4a       	mov	r10,	r12	;
    7040:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007044 <.LVL253>:
    7044:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007048 <.LVL254>:
}
    7048:	f0 3f       	jmp	$-30     	;abs 0x702a

0000704a <reset_event>:
    704a:	0a 15       	pushm	#1,	r10	;16-bit words

0000704c <.LCFI31>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    704c:	21 83       	decd	r1		;

0000704e <.LCFI32>:
    704e:	0a 4c       	mov	r12,	r10	;

00007050 <L0>:
    7050:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7054:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7058:	01 00 

0000705a <.Loc.1208.1>:
  elyEventReset();
    705a:	b0 12 2c a4 	call	#-23508	;#0xa42c

0000705e <.LVL256>:
  if (hdr.reply) {
    705e:	6c 41       	mov.b	@r1,	r12	;
    7060:	6c f3       	and.b	#2,	r12	;r3 As==10
    7062:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7064:	08 20       	jnz	$+18     	;abs 0x7076

00007066 <.Loc.1217.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7066:	0c 4a       	mov	r10,	r12	;
    7068:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000706c <.LVL257>:
    706c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007070 <.L210>:
}
    7070:	21 53       	incd	r1		;
    7072:	0a 17       	popm	#1,	r10	;16-bit words
    7074:	30 41       	ret			

00007076 <.L216>:
    gen_success(buffer, hdr.crc);
    7076:	6c 41       	mov.b	@r1,	r12	;
    7078:	5c f3       	and.b	#1,	r12	;r3 As==01

0000707a <.LBB189>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    707a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    707e:	00 00 

00007080 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7080:	0c 93       	cmp	#0,	r12	;r3 As==00
    7082:	14 24       	jz	$+42     	;abs 0x70ac
    7084:	7d 40 03 00 	mov.b	#3,	r13	;

00007088 <.L212>:
    7088:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

0000708c <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    708c:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7090:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7094:	02 00 

00007096 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7096:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    709a:	03 00 

0000709c <.Loc.24.1>:
  buffer[4] = 1;
    709c:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

000070a0 <.Loc.25.1>:
  if (crc) {
    70a0:	0c 93       	cmp	#0,	r12	;r3 As==00
    70a2:	06 20       	jnz	$+14     	;abs 0x70b0

000070a4 <.L213>:
    elyCmdSendReply(buffer);
    70a4:	0c 4a       	mov	r10,	r12	;
    70a6:	b0 12 58 69 	call	#26968		;#0x6958

000070aa <.LVL261>:
    70aa:	e2 3f       	jmp	$-58     	;abs 0x7070

000070ac <.L215>:
  buffer[1] = (crc ? 3 : 1);
    70ac:	5d 43       	mov.b	#1,	r13	;r3 As==01
    70ae:	ec 3f       	jmp	$-38     	;abs 0x7088

000070b0 <.L217>:
    crcGenX25(buffer, 7);
    70b0:	7d 40 07 00 	mov.b	#7,	r13	;
    70b4:	0c 4a       	mov	r10,	r12	;
    70b6:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000070ba <.LVL263>:
    70ba:	f4 3f       	jmp	$-22     	;abs 0x70a4

000070bc <unlog_event>:
    70bc:	3a 15       	pushm	#4,	r10	;16-bit words

000070be <.LCFI33>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    70be:	21 83       	decd	r1		;

000070c0 <.LCFI34>:
    70c0:	08 4c       	mov	r12,	r8	;

000070c2 <L0>:
    70c2:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    70c6:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    70ca:	01 00 

000070cc <.Loc.1170.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    70cc:	5e 41 01 00 	mov.b	1(r1),	r14	;
    70d0:	6c 41       	mov.b	@r1,	r12	;

000070d2 <.LVL265>:
    70d2:	1c b3       	bit	#1,	r12	;r3 As==01
    70d4:	17 24       	jz	$+48     	;abs 0x7104
    70d6:	6d 43       	mov.b	#2,	r13	;r3 As==10

000070d8 <.L219>:
    70d8:	6c f3       	and.b	#2,	r12	;r3 As==10
    70da:	47 4c       	mov.b	r12,	r7	;
    70dc:	4c 5d       	add.b	r13,	r12	;
    70de:	4e 8c       	sub.b	r12,	r14	;
    70e0:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

000070e4 <.LVL266>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    70e4:	07 93       	cmp	#0,	r7	;r3 As==00
    70e6:	10 24       	jz	$+34     	;abs 0x7108

000070e8 <.Loc.1171.1>:
    70e8:	6c 42       	mov.b	#4,	r12	;r2 As==10

000070ea <.L220>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    70ea:	0a 4c       	mov	r12,	r10	;

000070ec <.L221>:
    70ec:	09 4e       	mov	r14,	r9	;
    70ee:	09 5a       	add	r10,	r9	;
    70f0:	0c 99       	cmp	r9,	r12	;
    70f2:	3e 34       	jge	$+126    	;abs 0x7170

000070f4 <.Loc.1175.1>:
    if (buffer[i] < 0xC0) {
    70f4:	0d 48       	mov	r8,	r13	;
    70f6:	0d 5c       	add	r12,	r13	;
    70f8:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    70fc:	6f 9d       	cmp.b	@r13,	r15	;
    70fe:	06 2c       	jc	$+14     	;abs 0x710c

00007100 <.Loc.1173.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7100:	1c 53       	inc	r12		;
    7102:	f4 3f       	jmp	$-22     	;abs 0x70ec

00007104 <.L233>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7104:	4d 43       	clr.b	r13		;
    7106:	e8 3f       	jmp	$-46     	;abs 0x70d8

00007108 <.L234>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7108:	6c 43       	mov.b	#2,	r12	;r3 As==10
    710a:	ef 3f       	jmp	$-32     	;abs 0x70ea

0000710c <.L237>:
      if (hdr.reply) {
    710c:	07 93       	cmp	#0,	r7	;r3 As==00
    710e:	20 24       	jz	$+66     	;abs 0x7150

00007110 <.Loc.1178.1>:
        gen_failure(buffer, hdr.crc);
    7110:	6c 41       	mov.b	@r1,	r12	;

00007112 <.LVL273>:
    7112:	5c f3       	and.b	#1,	r12	;r3 As==01

00007114 <.LBB200>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7114:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    7118:	00 00 

0000711a <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    711a:	0c 93       	cmp	#0,	r12	;r3 As==00
    711c:	11 24       	jz	$+36     	;abs 0x7140
    711e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007120 <.L224>:
    7120:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00007124 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7124:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7128:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    712c:	02 00 

0000712e <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    712e:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    7132:	03 00 

00007134 <.Loc.35.1>:
  if (crc) {
    7134:	0c 93       	cmp	#0,	r12	;r3 As==00
    7136:	06 20       	jnz	$+14     	;abs 0x7144

00007138 <.L225>:
        elyCmdSendReply(buffer);
    7138:	0c 48       	mov	r8,	r12	;
    713a:	b0 12 58 69 	call	#26968		;#0x6958

0000713e <.LVL276>:
    713e:	21 3c       	jmp	$+68     	;abs 0x7182

00007140 <.L235>:
  buffer[1] = (crc ? 2 : 0);
    7140:	0d 4c       	mov	r12,	r13	;
    7142:	ee 3f       	jmp	$-34     	;abs 0x7120

00007144 <.L238>:
    crcGenX25(buffer, 6);
    7144:	7d 40 06 00 	mov.b	#6,	r13	;
    7148:	0c 48       	mov	r8,	r12	;
    714a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000714e <.LVL278>:
    714e:	f4 3f       	jmp	$-22     	;abs 0x7138

00007150 <.L223>:
        elyErrorSignal(ErrCmdFailure);
    7150:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007154 <.LVL280>:
    7154:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007158 <.LVL281>:
        elyNLFreeBuffer(elyNLPack(buffer));
    7158:	0c 48       	mov	r8,	r12	;
    715a:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000715e <.LVL282>:
    715e:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007162 <.LVL283>:
    7162:	0f 3c       	jmp	$+32     	;abs 0x7182

00007164 <.L229>:
    elyEventUnlog(buffer[i]);
    7164:	0c 48       	mov	r8,	r12	;
    7166:	0c 5a       	add	r10,	r12	;
    7168:	6c 4c       	mov.b	@r12,	r12	;
    716a:	b0 12 fc a3 	call	#-23556	;#0xa3fc

0000716e <.LVL285>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    716e:	1a 53       	inc	r10		;

00007170 <.L228>:
    7170:	0a 99       	cmp	r9,	r10	;
    7172:	f8 3b       	jl	$-14     	;abs 0x7164

00007174 <.LBE205>:
  if (hdr.reply) {
    7174:	07 93       	cmp	#0,	r7	;r3 As==00
    7176:	08 20       	jnz	$+18     	;abs 0x7188

00007178 <.Loc.1201.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7178:	0c 48       	mov	r8,	r12	;
    717a:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000717e <.LVL287>:
    717e:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007182 <.L218>:
}
    7182:	21 53       	incd	r1		;
    7184:	37 17       	popm	#4,	r10	;16-bit words
    7186:	30 41       	ret			

00007188 <.L239>:
    gen_success(buffer, hdr.crc);
    7188:	6c 41       	mov.b	@r1,	r12	;
    718a:	5c f3       	and.b	#1,	r12	;r3 As==01

0000718c <.LBB206>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    718c:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    7190:	00 00 

00007192 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7192:	0c 93       	cmp	#0,	r12	;r3 As==00
    7194:	14 24       	jz	$+42     	;abs 0x71be
    7196:	7d 40 03 00 	mov.b	#3,	r13	;

0000719a <.L231>:
    719a:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

0000719e <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    719e:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    71a2:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    71a6:	02 00 

000071a8 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    71a8:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    71ac:	03 00 

000071ae <.Loc.24.1>:
  buffer[4] = 1;
    71ae:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

000071b2 <.Loc.25.1>:
  if (crc) {
    71b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    71b4:	06 20       	jnz	$+14     	;abs 0x71c2

000071b6 <.L232>:
    elyCmdSendReply(buffer);
    71b6:	0c 48       	mov	r8,	r12	;
    71b8:	b0 12 58 69 	call	#26968		;#0x6958

000071bc <.LVL292>:
    71bc:	e2 3f       	jmp	$-58     	;abs 0x7182

000071be <.L236>:
  buffer[1] = (crc ? 3 : 1);
    71be:	5d 43       	mov.b	#1,	r13	;r3 As==01
    71c0:	ec 3f       	jmp	$-38     	;abs 0x719a

000071c2 <.L240>:
    crcGenX25(buffer, 7);
    71c2:	7d 40 07 00 	mov.b	#7,	r13	;
    71c6:	0c 48       	mov	r8,	r12	;
    71c8:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000071cc <.LVL294>:
    71cc:	f4 3f       	jmp	$-22     	;abs 0x71b6

000071ce <log_event>:
    71ce:	3a 15       	pushm	#4,	r10	;16-bit words

000071d0 <.LCFI35>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    71d0:	21 83       	decd	r1		;

000071d2 <.LCFI36>:
    71d2:	08 4c       	mov	r12,	r8	;

000071d4 <.Loc.1130.1>:
    71d4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    71d8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    71dc:	01 00 

000071de <.Loc.1131.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    71de:	5f 41 01 00 	mov.b	1(r1),	r15	;

000071e2 <L0>:
    71e2:	6c 41       	mov.b	@r1,	r12	;

000071e4 <.LVL296>:
    71e4:	1c b3       	bit	#1,	r12	;r3 As==01
    71e6:	27 24       	jz	$+80     	;abs 0x7236
    71e8:	6d 43       	mov.b	#2,	r13	;r3 As==10

000071ea <.L242>:
    71ea:	6c f3       	and.b	#2,	r12	;r3 As==10
    71ec:	47 4c       	mov.b	r12,	r7	;
    71ee:	4c 5d       	add.b	r13,	r12	;
    71f0:	4f 8c       	sub.b	r12,	r15	;
    71f2:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

000071f6 <.LVL297>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    71f6:	07 93       	cmp	#0,	r7	;r3 As==00
    71f8:	20 24       	jz	$+66     	;abs 0x723a

000071fa <.Loc.1132.1>:
    71fa:	6d 42       	mov.b	#4,	r13	;r2 As==10

000071fc <.L243>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    71fc:	09 4d       	mov	r13,	r9	;

000071fe <.L244>:
    71fe:	0a 4f       	mov	r15,	r10	;
    7200:	0a 59       	add	r9,	r10	;
    7202:	0d 9a       	cmp	r10,	r13	;
    7204:	50 34       	jge	$+162    	;abs 0x72a6

00007206 <.Loc.1135.1>:
    if ((buffer[i] < 0xC0) || 
    7206:	0c 48       	mov	r8,	r12	;
    7208:	0c 5d       	add	r13,	r12	;
    720a:	6c 4c       	mov.b	@r12,	r12	;
    720c:	7a 40 bf ff 	mov.b	#-65,	r10	;#0xffbf
    7210:	4a 9c       	cmp.b	r12,	r10	;
    7212:	15 2c       	jc	$+44     	;abs 0x723e

00007214 <.Loc.1136.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7214:	4e 4c       	mov.b	r12,	r14	;
    7216:	7e 50 2d 00 	add.b	#45,	r14	;#0x002d

0000721a <.Loc.1135.1>:
    if ((buffer[i] < 0xC0) || 
    721a:	7a 40 0c 00 	mov.b	#12,	r10	;#0x000c
    721e:	4a 9e       	cmp.b	r14,	r10	;
    7220:	0e 2c       	jc	$+30     	;abs 0x723e

00007222 <.Loc.1137.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7222:	7e 50 f0 ff 	add.b	#-16,	r14	;#0xfff0

00007226 <.Loc.1136.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7226:	4a 9e       	cmp.b	r14,	r10	;
    7228:	0a 2c       	jc	$+22     	;abs 0x723e

0000722a <.Loc.1137.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    722a:	7e 40 f2 ff 	mov.b	#-14,	r14	;#0xfff2
    722e:	4e 9c       	cmp.b	r12,	r14	;
    7230:	06 28       	jnc	$+14     	;abs 0x723e

00007232 <.Loc.1134.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7232:	1d 53       	inc	r13		;
    7234:	e4 3f       	jmp	$-54     	;abs 0x71fe

00007236 <.L257>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7236:	4d 43       	clr.b	r13		;
    7238:	d8 3f       	jmp	$-78     	;abs 0x71ea

0000723a <.L258>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    723a:	6d 43       	mov.b	#2,	r13	;r3 As==10
    723c:	df 3f       	jmp	$-64     	;abs 0x71fc

0000723e <.L245>:
      if (hdr.reply) {
    723e:	07 93       	cmp	#0,	r7	;r3 As==00
    7240:	22 24       	jz	$+70     	;abs 0x7286

00007242 <.Loc.1141.1>:
        gen_failure(buffer, hdr.crc);
    7242:	6c 41       	mov.b	@r1,	r12	;
    7244:	5c f3       	and.b	#1,	r12	;r3 As==01

00007246 <.LBB217>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7246:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    724a:	00 00 

0000724c <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    724c:	0c 93       	cmp	#0,	r12	;r3 As==00
    724e:	13 24       	jz	$+40     	;abs 0x7276
    7250:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007252 <.L248>:
    7252:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00007256 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7256:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    725a:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    725e:	02 00 

00007260 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7260:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    7264:	03 00 

00007266 <.Loc.35.1>:
  if (crc) {
    7266:	0c 93       	cmp	#0,	r12	;r3 As==00
    7268:	08 20       	jnz	$+18     	;abs 0x727a

0000726a <.L249>:
        elyCmdSendReply(buffer);
    726a:	0c 48       	mov	r8,	r12	;
    726c:	b0 12 58 69 	call	#26968		;#0x6958

00007270 <.L241>:
}
    7270:	21 53       	incd	r1		;
    7272:	37 17       	popm	#4,	r10	;16-bit words
    7274:	30 41       	ret			

00007276 <.L259>:
  buffer[1] = (crc ? 2 : 0);
    7276:	0d 4c       	mov	r12,	r13	;

00007278 <.LVL309>:
    7278:	ec 3f       	jmp	$-38     	;abs 0x7252

0000727a <.L261>:
    crcGenX25(buffer, 6);
    727a:	7d 40 06 00 	mov.b	#6,	r13	;
    727e:	0c 48       	mov	r8,	r12	;
    7280:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007284 <.LVL310>:
    7284:	f2 3f       	jmp	$-26     	;abs 0x726a

00007286 <.L247>:
        elyErrorSignal(ErrCmdFailure);
    7286:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    728a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000728e <.LVL312>:
        elyNLFreeBuffer(elyNLPack(buffer));
    728e:	0c 48       	mov	r8,	r12	;
    7290:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007294 <.LVL313>:
    7294:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007298 <.LVL314>:
    7298:	eb 3f       	jmp	$-40     	;abs 0x7270

0000729a <.L253>:
    elyEventLog(buffer[i]);
    729a:	0c 48       	mov	r8,	r12	;
    729c:	0c 59       	add	r9,	r12	;
    729e:	6c 4c       	mov.b	@r12,	r12	;
    72a0:	b0 12 cc a3 	call	#-23604	;#0xa3cc

000072a4 <.LVL316>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    72a4:	19 53       	inc	r9		;

000072a6 <.L252>:
    72a6:	09 9a       	cmp	r10,	r9	;
    72a8:	f8 3b       	jl	$-14     	;abs 0x729a

000072aa <.LBE223>:
  if (hdr.reply) {
    72aa:	07 93       	cmp	#0,	r7	;r3 As==00
    72ac:	06 20       	jnz	$+14     	;abs 0x72ba

000072ae <.Loc.1164.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    72ae:	0c 48       	mov	r8,	r12	;
    72b0:	b0 12 4c a8 	call	#-22452	;#0xa84c

000072b4 <.LVL318>:
    72b4:	b0 12 1e a7 	call	#-22754	;#0xa71e

000072b8 <.LVL319>:
    72b8:	db 3f       	jmp	$-72     	;abs 0x7270

000072ba <.L262>:
    gen_success(buffer, hdr.crc);
    72ba:	6c 41       	mov.b	@r1,	r12	;
    72bc:	5c f3       	and.b	#1,	r12	;r3 As==01

000072be <.LBB224>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    72be:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    72c2:	00 00 

000072c4 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    72c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    72c6:	14 24       	jz	$+42     	;abs 0x72f0
    72c8:	7d 40 03 00 	mov.b	#3,	r13	;

000072cc <.L255>:
    72cc:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000072d0 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    72d0:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    72d4:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    72d8:	02 00 

000072da <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    72da:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    72de:	03 00 

000072e0 <.Loc.24.1>:
  buffer[4] = 1;
    72e0:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

000072e4 <.Loc.25.1>:
  if (crc) {
    72e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    72e6:	06 20       	jnz	$+14     	;abs 0x72f4

000072e8 <.L256>:
    elyCmdSendReply(buffer);
    72e8:	0c 48       	mov	r8,	r12	;
    72ea:	b0 12 58 69 	call	#26968		;#0x6958

000072ee <.LVL322>:
    72ee:	c0 3f       	jmp	$-126    	;abs 0x7270

000072f0 <.L260>:
  buffer[1] = (crc ? 3 : 1);
    72f0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    72f2:	ec 3f       	jmp	$-38     	;abs 0x72cc

000072f4 <.L263>:
    crcGenX25(buffer, 7);
    72f4:	7d 40 07 00 	mov.b	#7,	r13	;
    72f8:	0c 48       	mov	r8,	r12	;
    72fa:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000072fe <.LVL324>:
    72fe:	f4 3f       	jmp	$-22     	;abs 0x72e8

00007300 <event_unsub>:
    7300:	3a 15       	pushm	#4,	r10	;16-bit words

00007302 <.LCFI37>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7302:	21 83       	decd	r1		;

00007304 <.LCFI38>:
    7304:	08 4c       	mov	r12,	r8	;

00007306 <.Loc.1094.1>:
    7306:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    730a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    730e:	01 00 

00007310 <.Loc.1095.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7310:	5e 41 01 00 	mov.b	1(r1),	r14	;

00007314 <L0>:
    7314:	6c 41       	mov.b	@r1,	r12	;

00007316 <.LVL326>:
    7316:	1c b3       	bit	#1,	r12	;r3 As==01
    7318:	17 24       	jz	$+48     	;abs 0x7348
    731a:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000731c <.L265>:
    731c:	6c f3       	and.b	#2,	r12	;r3 As==10
    731e:	47 4c       	mov.b	r12,	r7	;
    7320:	4c 5d       	add.b	r13,	r12	;
    7322:	4e 8c       	sub.b	r12,	r14	;
    7324:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00007328 <.LVL327>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7328:	07 93       	cmp	#0,	r7	;r3 As==00
    732a:	10 24       	jz	$+34     	;abs 0x734c

0000732c <.Loc.1096.1>:
    732c:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000732e <.L266>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    732e:	0a 4c       	mov	r12,	r10	;

00007330 <.L267>:
    7330:	09 4e       	mov	r14,	r9	;
    7332:	09 5a       	add	r10,	r9	;
    7334:	0c 99       	cmp	r9,	r12	;
    7336:	3e 34       	jge	$+126    	;abs 0x73b4

00007338 <.Loc.1099.1>:
    if (buffer[i] < 0xC0) {
    7338:	0d 48       	mov	r8,	r13	;
    733a:	0d 5c       	add	r12,	r13	;
    733c:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    7340:	6f 9d       	cmp.b	@r13,	r15	;
    7342:	06 2c       	jc	$+14     	;abs 0x7350

00007344 <.Loc.1098.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7344:	1c 53       	inc	r12		;
    7346:	f4 3f       	jmp	$-22     	;abs 0x7330

00007348 <.L279>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7348:	4d 43       	clr.b	r13		;
    734a:	e8 3f       	jmp	$-46     	;abs 0x731c

0000734c <.L280>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    734c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    734e:	ef 3f       	jmp	$-32     	;abs 0x732e

00007350 <.L283>:
      if (hdr.reply) {
    7350:	07 93       	cmp	#0,	r7	;r3 As==00
    7352:	20 24       	jz	$+66     	;abs 0x7394

00007354 <.Loc.1102.1>:
        gen_failure(buffer, hdr.crc);
    7354:	6c 41       	mov.b	@r1,	r12	;

00007356 <.LVL334>:
    7356:	5c f3       	and.b	#1,	r12	;r3 As==01

00007358 <.LBB235>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7358:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    735c:	00 00 

0000735e <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    735e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7360:	11 24       	jz	$+36     	;abs 0x7384
    7362:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007364 <.L270>:
    7364:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00007368 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7368:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    736c:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    7370:	02 00 

00007372 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7372:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    7376:	03 00 

00007378 <.Loc.35.1>:
  if (crc) {
    7378:	0c 93       	cmp	#0,	r12	;r3 As==00
    737a:	06 20       	jnz	$+14     	;abs 0x7388

0000737c <.L271>:
        elyCmdSendReply(buffer);
    737c:	0c 48       	mov	r8,	r12	;
    737e:	b0 12 58 69 	call	#26968		;#0x6958

00007382 <.LVL337>:
    7382:	21 3c       	jmp	$+68     	;abs 0x73c6

00007384 <.L281>:
  buffer[1] = (crc ? 2 : 0);
    7384:	0d 4c       	mov	r12,	r13	;
    7386:	ee 3f       	jmp	$-34     	;abs 0x7364

00007388 <.L284>:
    crcGenX25(buffer, 6);
    7388:	7d 40 06 00 	mov.b	#6,	r13	;
    738c:	0c 48       	mov	r8,	r12	;
    738e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007392 <.LVL339>:
    7392:	f4 3f       	jmp	$-22     	;abs 0x737c

00007394 <.L269>:
        elyErrorSignal(ErrCmdFailure);
    7394:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007398 <.LVL341>:
    7398:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000739c <.LVL342>:
        elyNLFreeBuffer(elyNLPack(buffer));
    739c:	0c 48       	mov	r8,	r12	;
    739e:	b0 12 4c a8 	call	#-22452	;#0xa84c

000073a2 <.LVL343>:
    73a2:	b0 12 1e a7 	call	#-22754	;#0xa71e

000073a6 <.LVL344>:
    73a6:	0f 3c       	jmp	$+32     	;abs 0x73c6

000073a8 <.L275>:
    elyEventUnsubscribe(buffer[i]);
    73a8:	0c 48       	mov	r8,	r12	;
    73aa:	0c 5a       	add	r10,	r12	;
    73ac:	6c 4c       	mov.b	@r12,	r12	;
    73ae:	b0 12 9c a3 	call	#-23652	;#0xa39c

000073b2 <.LVL346>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73b2:	1a 53       	inc	r10		;

000073b4 <.L274>:
    73b4:	0a 99       	cmp	r9,	r10	;
    73b6:	f8 3b       	jl	$-14     	;abs 0x73a8

000073b8 <.LBE240>:
  if (hdr.reply) {
    73b8:	07 93       	cmp	#0,	r7	;r3 As==00
    73ba:	08 20       	jnz	$+18     	;abs 0x73cc

000073bc <.Loc.1125.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    73bc:	0c 48       	mov	r8,	r12	;
    73be:	b0 12 4c a8 	call	#-22452	;#0xa84c

000073c2 <.LVL348>:
    73c2:	b0 12 1e a7 	call	#-22754	;#0xa71e

000073c6 <.L264>:
}
    73c6:	21 53       	incd	r1		;
    73c8:	37 17       	popm	#4,	r10	;16-bit words
    73ca:	30 41       	ret			

000073cc <.L285>:
    gen_success(buffer, hdr.crc);
    73cc:	6c 41       	mov.b	@r1,	r12	;
    73ce:	5c f3       	and.b	#1,	r12	;r3 As==01

000073d0 <.LBB241>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    73d0:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    73d4:	00 00 

000073d6 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    73d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    73d8:	14 24       	jz	$+42     	;abs 0x7402
    73da:	7d 40 03 00 	mov.b	#3,	r13	;

000073de <.L277>:
    73de:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000073e2 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    73e2:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    73e6:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    73ea:	02 00 

000073ec <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    73ec:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    73f0:	03 00 

000073f2 <.Loc.24.1>:
  buffer[4] = 1;
    73f2:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

000073f6 <.Loc.25.1>:
  if (crc) {
    73f6:	0c 93       	cmp	#0,	r12	;r3 As==00
    73f8:	06 20       	jnz	$+14     	;abs 0x7406

000073fa <.L278>:
    elyCmdSendReply(buffer);
    73fa:	0c 48       	mov	r8,	r12	;
    73fc:	b0 12 58 69 	call	#26968		;#0x6958

00007400 <.LVL353>:
    7400:	e2 3f       	jmp	$-58     	;abs 0x73c6

00007402 <.L282>:
  buffer[1] = (crc ? 3 : 1);
    7402:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7404:	ec 3f       	jmp	$-38     	;abs 0x73de

00007406 <.L286>:
    crcGenX25(buffer, 7);
    7406:	7d 40 07 00 	mov.b	#7,	r13	;
    740a:	0c 48       	mov	r8,	r12	;
    740c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007410 <.LVL355>:
    7410:	f4 3f       	jmp	$-22     	;abs 0x73fa

00007412 <event_sub>:
    7412:	4a 15       	pushm	#5,	r10	;16-bit words

00007414 <.LCFI39>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7414:	21 83       	decd	r1		;

00007416 <.LCFI40>:
    7416:	08 4c       	mov	r12,	r8	;

00007418 <.Loc.1046.1>:
    7418:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    741c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7420:	01 00 

00007422 <.Loc.1047.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7422:	5f 41 01 00 	mov.b	1(r1),	r15	;

00007426 <L0>:
    7426:	6c 41       	mov.b	@r1,	r12	;

00007428 <.LVL357>:
    7428:	1c b3       	bit	#1,	r12	;r3 As==01
    742a:	27 24       	jz	$+80     	;abs 0x747a
    742c:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000742e <.L288>:
    742e:	6c f3       	and.b	#2,	r12	;r3 As==10
    7430:	47 4c       	mov.b	r12,	r7	;
    7432:	4c 5d       	add.b	r13,	r12	;
    7434:	4f 8c       	sub.b	r12,	r15	;
    7436:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

0000743a <.LVL358>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    743a:	07 93       	cmp	#0,	r7	;r3 As==00
    743c:	20 24       	jz	$+66     	;abs 0x747e

0000743e <.Loc.1048.1>:
    743e:	6d 42       	mov.b	#4,	r13	;r2 As==10

00007440 <.L289>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7440:	09 4d       	mov	r13,	r9	;

00007442 <.L290>:
    7442:	0a 4f       	mov	r15,	r10	;
    7444:	0a 59       	add	r9,	r10	;
    7446:	0d 9a       	cmp	r10,	r13	;
    7448:	4a 34       	jge	$+150    	;abs 0x74de

0000744a <.Loc.1051.1>:
    if ((buffer[i] < 0xC0) || 
    744a:	0c 48       	mov	r8,	r12	;
    744c:	0c 5d       	add	r13,	r12	;
    744e:	6c 4c       	mov.b	@r12,	r12	;
    7450:	7a 40 bf ff 	mov.b	#-65,	r10	;#0xffbf
    7454:	4a 9c       	cmp.b	r12,	r10	;
    7456:	15 2c       	jc	$+44     	;abs 0x7482

00007458 <.Loc.1052.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7458:	4e 4c       	mov.b	r12,	r14	;
    745a:	7e 50 2d 00 	add.b	#45,	r14	;#0x002d

0000745e <.Loc.1051.1>:
    if ((buffer[i] < 0xC0) || 
    745e:	7a 40 0c 00 	mov.b	#12,	r10	;#0x000c
    7462:	4a 9e       	cmp.b	r14,	r10	;
    7464:	0e 2c       	jc	$+30     	;abs 0x7482

00007466 <.Loc.1053.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7466:	7e 50 f0 ff 	add.b	#-16,	r14	;#0xfff0

0000746a <.Loc.1052.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    746a:	4a 9e       	cmp.b	r14,	r10	;
    746c:	0a 2c       	jc	$+22     	;abs 0x7482

0000746e <.Loc.1053.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    746e:	7e 40 f2 ff 	mov.b	#-14,	r14	;#0xfff2
    7472:	4e 9c       	cmp.b	r12,	r14	;
    7474:	06 28       	jnc	$+14     	;abs 0x7482

00007476 <.Loc.1050.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7476:	1d 53       	inc	r13		;
    7478:	e4 3f       	jmp	$-54     	;abs 0x7442

0000747a <.L305>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    747a:	4d 43       	clr.b	r13		;
    747c:	d8 3f       	jmp	$-78     	;abs 0x742e

0000747e <.L306>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    747e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7480:	df 3f       	jmp	$-64     	;abs 0x7440

00007482 <.L291>:
      if (hdr.reply) {
    7482:	07 93       	cmp	#0,	r7	;r3 As==00
    7484:	22 24       	jz	$+70     	;abs 0x74ca

00007486 <.Loc.1057.1>:
        gen_failure(buffer, hdr.crc);
    7486:	6c 41       	mov.b	@r1,	r12	;
    7488:	5c f3       	and.b	#1,	r12	;r3 As==01

0000748a <.LBB252>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    748a:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    748e:	00 00 

00007490 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7490:	0c 93       	cmp	#0,	r12	;r3 As==00
    7492:	13 24       	jz	$+40     	;abs 0x74ba
    7494:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007496 <.L294>:
    7496:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

0000749a <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    749a:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    749e:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    74a2:	02 00 

000074a4 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    74a4:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    74a8:	03 00 

000074aa <.Loc.35.1>:
  if (crc) {
    74aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    74ac:	08 20       	jnz	$+18     	;abs 0x74be

000074ae <.L295>:
        elyCmdSendReply(buffer);
    74ae:	0c 48       	mov	r8,	r12	;
    74b0:	b0 12 58 69 	call	#26968		;#0x6958

000074b4 <.L287>:
}
    74b4:	21 53       	incd	r1		;
    74b6:	46 17       	popm	#5,	r10	;16-bit words
    74b8:	30 41       	ret			

000074ba <.L307>:
  buffer[1] = (crc ? 2 : 0);
    74ba:	0d 4c       	mov	r12,	r13	;

000074bc <.LVL370>:
    74bc:	ec 3f       	jmp	$-38     	;abs 0x7496

000074be <.L310>:
    crcGenX25(buffer, 6);
    74be:	7d 40 06 00 	mov.b	#6,	r13	;
    74c2:	0c 48       	mov	r8,	r12	;
    74c4:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000074c8 <.LVL371>:
    74c8:	f2 3f       	jmp	$-26     	;abs 0x74ae

000074ca <.L293>:
        elyErrorSignal(ErrCmdFailure);
    74ca:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    74ce:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000074d2 <.LVL373>:
        elyNLFreeBuffer(elyNLPack(buffer));
    74d2:	0c 48       	mov	r8,	r12	;
    74d4:	b0 12 4c a8 	call	#-22452	;#0xa84c

000074d8 <.LVL374>:
    74d8:	b0 12 1e a7 	call	#-22754	;#0xa71e

000074dc <.LVL375>:
    74dc:	eb 3f       	jmp	$-40     	;abs 0x74b4

000074de <.L309>:
  if (hdr.reply) {
    74de:	07 93       	cmp	#0,	r7	;r3 As==00
    74e0:	08 24       	jz	$+18     	;abs 0x74f2

000074e2 <.Loc.1071.1>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    74e2:	56 48 02 00 	mov.b	2(r8),	r6	;
    74e6:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    74ea:	5c 48 03 00 	mov.b	3(r8),	r12	;
    74ee:	06 dc       	bis	r12,	r6	;

000074f0 <.LVL377>:
    74f0:	11 3c       	jmp	$+36     	;abs 0x7514

000074f2 <.L298>:
    addr = ((bank0p[RegEventDefaultAddrMsb] << 8) | (bank0p[RegEventDefaultAddrLsb]));
    74f2:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    74f6:	56 4c 55 00 	mov.b	85(r12),r6	;0x00055
    74fa:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    74fe:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    7502:	06 dc       	bis	r12,	r6	;

00007504 <.LBB258>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7504:	07 3c       	jmp	$+16     	;abs 0x7514

00007506 <.L301>:
      elyEventSubscribe(buffer[i], addr);
    7506:	0c 48       	mov	r8,	r12	;
    7508:	0c 59       	add	r9,	r12	;
    750a:	0d 46       	mov	r6,	r13	;
    750c:	6c 4c       	mov.b	@r12,	r12	;
    750e:	b0 12 54 a3 	call	#-23724	;#0xa354

00007512 <.LVL381>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7512:	19 53       	inc	r9		;

00007514 <.L300>:
    7514:	09 9a       	cmp	r10,	r9	;
    7516:	f7 3b       	jl	$-16     	;abs 0x7506

00007518 <.LBE258>:
  if (hdr.reply) {
    7518:	07 93       	cmp	#0,	r7	;r3 As==00
    751a:	06 20       	jnz	$+14     	;abs 0x7528

0000751c <.Loc.1089.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    751c:	0c 48       	mov	r8,	r12	;
    751e:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007522 <.LVL383>:
    7522:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007526 <.LVL384>:
    7526:	c6 3f       	jmp	$-114    	;abs 0x74b4

00007528 <.L311>:
    gen_success(buffer, hdr.crc);
    7528:	6c 41       	mov.b	@r1,	r12	;
    752a:	5c f3       	and.b	#1,	r12	;r3 As==01

0000752c <.LBB259>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    752c:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    7530:	00 00 

00007532 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7532:	0c 93       	cmp	#0,	r12	;r3 As==00
    7534:	14 24       	jz	$+42     	;abs 0x755e
    7536:	7d 40 03 00 	mov.b	#3,	r13	;

0000753a <.L303>:
    753a:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

0000753e <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    753e:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7542:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    7546:	02 00 

00007548 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7548:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    754c:	03 00 

0000754e <.Loc.24.1>:
  buffer[4] = 1;
    754e:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

00007552 <.Loc.25.1>:
  if (crc) {
    7552:	0c 93       	cmp	#0,	r12	;r3 As==00
    7554:	06 20       	jnz	$+14     	;abs 0x7562

00007556 <.L304>:
    elyCmdSendReply(buffer);
    7556:	0c 48       	mov	r8,	r12	;
    7558:	b0 12 58 69 	call	#26968		;#0x6958

0000755c <.LVL387>:
    755c:	ab 3f       	jmp	$-168    	;abs 0x74b4

0000755e <.L308>:
  buffer[1] = (crc ? 3 : 1);
    755e:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7560:	ec 3f       	jmp	$-38     	;abs 0x753a

00007562 <.L312>:
    crcGenX25(buffer, 7);
    7562:	7d 40 07 00 	mov.b	#7,	r13	;
    7566:	0c 48       	mov	r8,	r12	;
    7568:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000756c <.LVL389>:
    756c:	f4 3f       	jmp	$-22     	;abs 0x7556

0000756e <reset_chan>:
    756e:	0a 15       	pushm	#1,	r10	;16-bit words

00007570 <.LCFI41>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7570:	21 83       	decd	r1		;

00007572 <.LCFI42>:
    7572:	0a 4c       	mov	r12,	r10	;

00007574 <.Loc.1031.1>:
    7574:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7578:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    757c:	01 00 

0000757e <.Loc.1033.1>:
  elyChanReset();
    757e:	b0 12 80 aa 	call	#-21888	;#0xaa80

00007582 <.LVL391>:
  if (hdr.reply) {
    7582:	6c 41       	mov.b	@r1,	r12	;
    7584:	6c f3       	and.b	#2,	r12	;r3 As==10

00007586 <L0>:
    7586:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7588:	08 20       	jnz	$+18     	;abs 0x759a

0000758a <.Loc.1042.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    758a:	0c 4a       	mov	r10,	r12	;
    758c:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007590 <.LVL392>:
    7590:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007594 <.L313>:
}
    7594:	21 53       	incd	r1		;
    7596:	0a 17       	popm	#1,	r10	;16-bit words
    7598:	30 41       	ret			

0000759a <.L319>:
    gen_success(buffer, hdr.crc);
    759a:	6c 41       	mov.b	@r1,	r12	;
    759c:	5c f3       	and.b	#1,	r12	;r3 As==01

0000759e <.LBB265>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    759e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    75a2:	00 00 

000075a4 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    75a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    75a6:	14 24       	jz	$+42     	;abs 0x75d0
    75a8:	7d 40 03 00 	mov.b	#3,	r13	;

000075ac <.L315>:
    75ac:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

000075b0 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    75b0:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    75b4:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    75b8:	02 00 

000075ba <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    75ba:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    75be:	03 00 

000075c0 <.Loc.24.1>:
  buffer[4] = 1;
    75c0:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

000075c4 <.Loc.25.1>:
  if (crc) {
    75c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    75c6:	06 20       	jnz	$+14     	;abs 0x75d4

000075c8 <.L316>:
    elyCmdSendReply(buffer);
    75c8:	0c 4a       	mov	r10,	r12	;
    75ca:	b0 12 58 69 	call	#26968		;#0x6958

000075ce <.LVL396>:
    75ce:	e2 3f       	jmp	$-58     	;abs 0x7594

000075d0 <.L318>:
  buffer[1] = (crc ? 3 : 1);
    75d0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    75d2:	ec 3f       	jmp	$-38     	;abs 0x75ac

000075d4 <.L320>:
    crcGenX25(buffer, 7);
    75d4:	7d 40 07 00 	mov.b	#7,	r13	;
    75d8:	0c 4a       	mov	r10,	r12	;
    75da:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000075de <.LVL398>:
    75de:	f4 3f       	jmp	$-22     	;abs 0x75c8

000075e0 <get_chan>:
    75e0:	1a 15       	pushm	#2,	r10	;16-bit words

000075e2 <.LCFI43>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    75e2:	21 83       	decd	r1		;

000075e4 <.LCFI44>:
    75e4:	0a 4c       	mov	r12,	r10	;

000075e6 <L0>:
    75e6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    75ea:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    75ee:	01 00 

000075f0 <.Loc.997.1>:
  if (hdr.reply) {
    75f0:	69 41       	mov.b	@r1,	r9	;
    75f2:	4c 49       	mov.b	r9,	r12	;

000075f4 <.LVL400>:
    75f4:	6c f3       	and.b	#2,	r12	;r3 As==10
    75f6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    75f8:	5d 24       	jz	$+188    	;abs 0x76b4

000075fa <.LBB272>:
    if ((buffer[4] < 0x40) || 
    75fa:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    75fe:	7d 40 3f 00 	mov.b	#63,	r13	;#0x003f
    7602:	4d 9c       	cmp.b	r12,	r13	;
    7604:	11 2c       	jc	$+36     	;abs 0x7628

00007606 <.Loc.999.1>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    7606:	4d 4c       	mov.b	r12,	r13	;
    7608:	7d 50 af ff 	add.b	#-81,	r13	;#0xffaf

0000760c <.Loc.998.1>:
    if ((buffer[4] < 0x40) || 
    760c:	7e 40 0e 00 	mov.b	#14,	r14	;#0x000e
    7610:	4e 9d       	cmp.b	r13,	r14	;
    7612:	0a 2c       	jc	$+22     	;abs 0x7628

00007614 <.Loc.1000.1>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    7614:	7d 50 ee ff 	add.b	#-18,	r13	;#0xffee

00007618 <.Loc.999.1>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    7618:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    761c:	4e 9d       	cmp.b	r13,	r14	;
    761e:	04 2c       	jc	$+10     	;abs 0x7628

00007620 <.Loc.1000.1>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    7620:	7d 40 76 00 	mov.b	#118,	r13	;#0x0076
    7624:	4d 9c       	cmp.b	r12,	r13	;
    7626:	22 2c       	jc	$+70     	;abs 0x766c

00007628 <.L323>:
        gen_failure(buffer, hdr.crc);
    7628:	6c 41       	mov.b	@r1,	r12	;
    762a:	5c f3       	and.b	#1,	r12	;r3 As==01

0000762c <.LBB273>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    762c:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7630:	00 00 

00007632 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7632:	0c 93       	cmp	#0,	r12	;r3 As==00
    7634:	13 24       	jz	$+40     	;abs 0x765c
    7636:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007638 <.L325>:
    7638:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

0000763c <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    763c:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7640:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7644:	02 00 

00007646 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7646:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    764a:	03 00 

0000764c <.Loc.35.1>:
  if (crc) {
    764c:	0c 93       	cmp	#0,	r12	;r3 As==00
    764e:	08 20       	jnz	$+18     	;abs 0x7660

00007650 <.L326>:
        elyCmdSendReply(buffer);
    7650:	0c 4a       	mov	r10,	r12	;
    7652:	b0 12 58 69 	call	#26968		;#0x6958

00007656 <.L321>:
}
    7656:	21 53       	incd	r1		;
    7658:	19 17       	popm	#2,	r10	;16-bit words
    765a:	30 41       	ret			

0000765c <.L330>:
  buffer[1] = (crc ? 2 : 0);
    765c:	0d 4c       	mov	r12,	r13	;
    765e:	ec 3f       	jmp	$-38     	;abs 0x7638

00007660 <.L331>:
    crcGenX25(buffer, 6);
    7660:	7d 40 06 00 	mov.b	#6,	r13	;
    7664:	0c 4a       	mov	r10,	r12	;
    7666:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000766a <.LVL405>:
    766a:	f2 3f       	jmp	$-26     	;abs 0x7650

0000766c <.L324>:
    buffer[0] = buffer[0] & 0x3F;
    766c:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7670:	00 00 

00007672 <.Loc.1009.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7672:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    7676:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    767a:	02 00 

0000767c <.Loc.1010.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    767c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7680:	03 00 

00007682 <.Loc.1013.1>:
    size_t n = elyChanGetValue(&buffer[4]);
    7682:	0c 4a       	mov	r10,	r12	;
    7684:	2c 52       	add	#4,	r12	;r2 As==10
    7686:	b0 12 78 aa 	call	#-21896	;#0xaa78

0000768a <.LVL407>:
    if (hdr.crc) {
    768a:	19 b3       	bit	#1,	r9	;r3 As==01
    768c:	07 20       	jnz	$+16     	;abs 0x769c

0000768e <.Loc.1020.1>:
      buffer[1] = n + 1;
    768e:	5c 53       	inc.b	r12		;

00007690 <.LVL408>:
    7690:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00007694 <.L329>:
    elyCmdSendReply(buffer);
    7694:	0c 4a       	mov	r10,	r12	;
    7696:	b0 12 58 69 	call	#26968		;#0x6958

0000769a <.LBE277>:
    769a:	dd 3f       	jmp	$-68     	;abs 0x7656

0000769c <.L332>:
      buffer[1] = n + 3;
    769c:	4e 4c       	mov.b	r12,	r14	;
    769e:	7e 50 03 00 	add.b	#3,	r14	;
    76a2:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

000076a6 <.Loc.1017.1>:
      crcGenX25(buffer, 7+n);
    76a6:	0d 4c       	mov	r12,	r13	;
    76a8:	3d 50 07 00 	add	#7,	r13	;
    76ac:	0c 4a       	mov	r10,	r12	;

000076ae <.LVL411>:
    76ae:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000076b2 <.LVL412>:
    76b2:	f0 3f       	jmp	$-30     	;abs 0x7694

000076b4 <.L322>:
    elyNLFreeBuffer(elyNLPack(buffer));
    76b4:	0c 4a       	mov	r10,	r12	;
    76b6:	b0 12 4c a8 	call	#-22452	;#0xa84c

000076ba <.LVL413>:
    76ba:	b0 12 1e a7 	call	#-22754	;#0xa71e

000076be <.LVL414>:
    76be:	cb 3f       	jmp	$-104    	;abs 0x7656

000076c0 <unlog_chan>:
    76c0:	5a 15       	pushm	#6,	r10	;16-bit words

000076c2 <.LCFI45>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    76c2:	21 83       	decd	r1		;

000076c4 <.LCFI46>:
    76c4:	0a 4c       	mov	r12,	r10	;

000076c6 <.Loc.960.1>:
    76c6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

000076ca <L0>:
    76ca:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    76ce:	01 00 

000076d0 <.Loc.962.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    76d0:	58 41 01 00 	mov.b	1(r1),	r8	;
    76d4:	6c 41       	mov.b	@r1,	r12	;

000076d6 <.LVL416>:
    76d6:	07 4c       	mov	r12,	r7	;
    76d8:	57 f3       	and.b	#1,	r7	;r3 As==01
    76da:	07 93       	cmp	#0,	r7	;r3 As==00
    76dc:	0c 24       	jz	$+26     	;abs 0x76f6
    76de:	6d 43       	mov.b	#2,	r13	;r3 As==10

000076e0 <.L334>:
    76e0:	6c f3       	and.b	#2,	r12	;r3 As==10
    76e2:	49 4c       	mov.b	r12,	r9	;
    76e4:	4c 5d       	add.b	r13,	r12	;
    76e6:	4d 48       	mov.b	r8,	r13	;
    76e8:	4d 8c       	sub.b	r12,	r13	;

000076ea <.LVL417>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    76ea:	09 93       	cmp	#0,	r9	;r3 As==00
    76ec:	06 24       	jz	$+14     	;abs 0x76fa

000076ee <.Loc.963.1>:
    76ee:	6c 42       	mov.b	#4,	r12	;r2 As==10

000076f0 <.L335>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    76f0:	06 4c       	mov	r12,	r6	;

000076f2 <.LVL419>:
    76f2:	0f 4c       	mov	r12,	r15	;
    76f4:	3d 3c       	jmp	$+124    	;abs 0x7770

000076f6 <.L347>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    76f6:	4d 43       	clr.b	r13		;
    76f8:	f3 3f       	jmp	$-24     	;abs 0x76e0

000076fa <.L348>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    76fa:	6c 43       	mov.b	#2,	r12	;r3 As==10
    76fc:	f9 3f       	jmp	$-12     	;abs 0x76f0

000076fe <.L354>:
      if (hdr.reply) {
    76fe:	09 93       	cmp	#0,	r9	;r3 As==00
    7700:	1f 24       	jz	$+64     	;abs 0x7740

00007702 <.Loc.969.1>:
        gen_failure(buffer, hdr.crc);
    7702:	6c 41       	mov.b	@r1,	r12	;
    7704:	5c f3       	and.b	#1,	r12	;r3 As==01

00007706 <.LBB285>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7706:	ca f5 00 00 	and.b	r5,	0(r10)	;

0000770a <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    770a:	0c 93       	cmp	#0,	r12	;r3 As==00
    770c:	11 24       	jz	$+36     	;abs 0x7730
    770e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007710 <.L339>:
    7710:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00007714 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7714:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7718:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    771c:	02 00 

0000771e <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    771e:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    7722:	03 00 

00007724 <.Loc.35.1>:
  if (crc) {
    7724:	0c 93       	cmp	#0,	r12	;r3 As==00
    7726:	06 20       	jnz	$+14     	;abs 0x7734

00007728 <.L340>:
        elyCmdSendReply(buffer);
    7728:	0c 4a       	mov	r10,	r12	;
    772a:	b0 12 58 69 	call	#26968		;#0x6958

0000772e <.LVL426>:
    772e:	30 3c       	jmp	$+98     	;abs 0x7790

00007730 <.L349>:
  buffer[1] = (crc ? 2 : 0);
    7730:	0d 4c       	mov	r12,	r13	;

00007732 <.LVL428>:
    7732:	ee 3f       	jmp	$-34     	;abs 0x7710

00007734 <.L352>:
    crcGenX25(buffer, 6);
    7734:	7d 40 06 00 	mov.b	#6,	r13	;
    7738:	0c 4a       	mov	r10,	r12	;
    773a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000773e <.LVL429>:
    773e:	f4 3f       	jmp	$-22     	;abs 0x7728

00007740 <.L338>:
        elyErrorSignal(ErrCmdFailure);
    7740:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7744:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007748 <.LVL431>:
        elyNLFreeBuffer(elyNLPack(buffer));
    7748:	0c 4a       	mov	r10,	r12	;
    774a:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000774e <.LVL432>:
    774e:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007752 <.LVL433>:
    7752:	1e 3c       	jmp	$+62     	;abs 0x7790

00007754 <.L350>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7754:	4b 43       	clr.b	r11		;

00007756 <.L342>:
    7756:	0e 8b       	sub	r11,	r14	;
    7758:	0f 9e       	cmp	r14,	r15	;
    775a:	10 34       	jge	$+34     	;abs 0x777c

0000775c <.Loc.966.1>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    775c:	0e 4a       	mov	r10,	r14	;
    775e:	0e 5f       	add	r15,	r14	;
    7760:	6e 4e       	mov.b	@r14,	r14	;
    7762:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    7766:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    776a:	45 9e       	cmp.b	r14,	r5	;
    776c:	c8 2b       	jnc	$-110    	;abs 0x76fe

0000776e <.Loc.965.1>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    776e:	1f 53       	inc	r15		;

00007770 <.L336>:
    7770:	0e 46       	mov	r6,	r14	;
    7772:	0e 58       	add	r8,	r14	;
    7774:	07 93       	cmp	#0,	r7	;r3 As==00
    7776:	ee 27       	jz	$-34     	;abs 0x7754

00007778 <.Loc.965.1>:
    7778:	6b 43       	mov.b	#2,	r11	;r3 As==10
    777a:	ed 3f       	jmp	$-36     	;abs 0x7756

0000777c <.L353>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    777c:	0c 5a       	add	r10,	r12	;
    777e:	b0 12 48 aa 	call	#-21944	;#0xaa48

00007782 <.LVL436>:
  if (hdr.reply) {
    7782:	09 93       	cmp	#0,	r9	;r3 As==00
    7784:	08 20       	jnz	$+18     	;abs 0x7796

00007786 <.Loc.990.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7786:	0c 4a       	mov	r10,	r12	;
    7788:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000778c <.LVL437>:
    778c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007790 <.L333>:
}
    7790:	21 53       	incd	r1		;
    7792:	55 17       	popm	#6,	r10	;16-bit words
    7794:	30 41       	ret			

00007796 <.L355>:
    gen_success(buffer, hdr.crc);
    7796:	6c 41       	mov.b	@r1,	r12	;
    7798:	5c f3       	and.b	#1,	r12	;r3 As==01

0000779a <.LBB290>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    779a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    779e:	00 00 

000077a0 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    77a0:	0c 93       	cmp	#0,	r12	;r3 As==00
    77a2:	14 24       	jz	$+42     	;abs 0x77cc
    77a4:	7d 40 03 00 	mov.b	#3,	r13	;

000077a8 <.L345>:
    77a8:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

000077ac <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    77ac:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    77b0:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    77b4:	02 00 

000077b6 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    77b6:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    77ba:	03 00 

000077bc <.Loc.24.1>:
  buffer[4] = 1;
    77bc:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

000077c0 <.Loc.25.1>:
  if (crc) {
    77c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    77c2:	06 20       	jnz	$+14     	;abs 0x77d0

000077c4 <.L346>:
    elyCmdSendReply(buffer);
    77c4:	0c 4a       	mov	r10,	r12	;
    77c6:	b0 12 58 69 	call	#26968		;#0x6958

000077ca <.LVL441>:
    77ca:	e2 3f       	jmp	$-58     	;abs 0x7790

000077cc <.L351>:
  buffer[1] = (crc ? 3 : 1);
    77cc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    77ce:	ec 3f       	jmp	$-38     	;abs 0x77a8

000077d0 <.L356>:
    crcGenX25(buffer, 7);
    77d0:	7d 40 07 00 	mov.b	#7,	r13	;
    77d4:	0c 4a       	mov	r10,	r12	;
    77d6:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000077da <.LVL443>:
    77da:	f4 3f       	jmp	$-22     	;abs 0x77c4

000077dc <log_chan>:
    77dc:	6a 15       	pushm	#7,	r10	;16-bit words

000077de <.LCFI47>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    77de:	21 82       	sub	#4,	r1	;r2 As==10

000077e0 <.LCFI48>:
    77e0:	09 4c       	mov	r12,	r9	;

000077e2 <.Loc.915.1>:
    77e2:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    77e6:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    77ea:	03 00 

000077ec <.Loc.916.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    77ec:	5e 41 03 00 	mov.b	3(r1),	r14	;
    77f0:	5c 41       	mov.b,		r12	;Warning: disassembly unreliable - not enough bytes available

000077f2 <L0>:
    77f2:	02 00       	mova	@r0,	r2	;

000077f4 <.LVL445>:
    77f4:	1c b3       	bit	#1,	r12	;r3 As==01
    77f6:	2d 24       	jz	$+92     	;abs 0x7852
    77f8:	6d 43       	mov.b	#2,	r13	;r3 As==10

000077fa <.L358>:
    77fa:	6c f3       	and.b	#2,	r12	;r3 As==10
    77fc:	44 4c       	mov.b	r12,	r4	;
    77fe:	4c 5d       	add.b	r13,	r12	;
    7800:	4e 8c       	sub.b	r12,	r14	;
    7802:	c1 4e 01 00 	mov.b	r14,	1(r1)	;
    7806:	4f 4e       	mov.b	r14,	r15	;

00007808 <.LVL446>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7808:	04 93       	cmp	#0,	r4	;r3 As==00
    780a:	25 24       	jz	$+76     	;abs 0x7856

0000780c <.Loc.917.1>:
    780c:	68 42       	mov.b	#4,	r8	;r2 As==10

0000780e <.L359>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    780e:	0a 48       	mov	r8,	r10	;
    7810:	05 48       	mov	r8,	r5	;
    7812:	25 52       	add	#4,	r5	;r2 As==10

00007814 <.LVL448>:
    7814:	0d 45       	mov	r5,	r13	;

00007816 <.L360>:
    7816:	0c 4f       	mov	r15,	r12	;
    7818:	0c 5a       	add	r10,	r12	;
    781a:	0d 9c       	cmp	r12,	r13	;
    781c:	4d 34       	jge	$+156    	;abs 0x78b8

0000781e <.Loc.921.1>:
    if ((buffer[i] < 0x40) || 
    781e:	0c 49       	mov	r9,	r12	;
    7820:	0c 5d       	add	r13,	r12	;
    7822:	6c 4c       	mov.b	@r12,	r12	;
    7824:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    7828:	47 9c       	cmp.b	r12,	r7	;
    782a:	17 2c       	jc	$+48     	;abs 0x785a

0000782c <.Loc.922.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    782c:	4e 4c       	mov.b	r12,	r14	;
    782e:	7e 50 af ff 	add.b	#-81,	r14	;#0xffaf

00007832 <.Loc.921.1>:
    if ((buffer[i] < 0x40) || 
    7832:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    7836:	47 9e       	cmp.b	r14,	r7	;
    7838:	10 2c       	jc	$+34     	;abs 0x785a

0000783a <.Loc.923.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    783a:	7e 50 ee ff 	add.b	#-18,	r14	;#0xffee

0000783e <.Loc.922.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    783e:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    7842:	47 9e       	cmp.b	r14,	r7	;
    7844:	0a 2c       	jc	$+22     	;abs 0x785a

00007846 <.Loc.923.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7846:	7e 40 76 00 	mov.b	#118,	r14	;#0x0076
    784a:	4e 9c       	cmp.b	r12,	r14	;
    784c:	06 28       	jnc	$+14     	;abs 0x785a

0000784e <.Loc.920.1>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    784e:	1d 53       	inc	r13		;
    7850:	e2 3f       	jmp	$-58     	;abs 0x7816

00007852 <.L373>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7852:	4d 43       	clr.b	r13		;
    7854:	d2 3f       	jmp	$-90     	;abs 0x77fa

00007856 <.L374>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7856:	68 43       	mov.b	#2,	r8	;r3 As==10
    7858:	da 3f       	jmp	$-74     	;abs 0x780e

0000785a <.L361>:
      if (hdr.reply) {
    785a:	04 93       	cmp	#0,	r4	;r3 As==00
    785c:	23 24       	jz	$+72     	;abs 0x78a4

0000785e <.Loc.927.1>:
        gen_failure(buffer, hdr.crc);
    785e:	5c 41 02 00 	mov.b	2(r1),	r12	;
    7862:	5c f3       	and.b	#1,	r12	;r3 As==01

00007864 <.LBB301>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7864:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    7868:	00 00 

0000786a <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    786a:	0c 93       	cmp	#0,	r12	;r3 As==00
    786c:	13 24       	jz	$+40     	;abs 0x7894
    786e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007870 <.L364>:
    7870:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00007874 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7874:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7878:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    787c:	02 00 

0000787e <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    787e:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    7882:	03 00 

00007884 <.Loc.35.1>:
  if (crc) {
    7884:	0c 93       	cmp	#0,	r12	;r3 As==00
    7886:	08 20       	jnz	$+18     	;abs 0x7898

00007888 <.L365>:
        elyCmdSendReply(buffer);
    7888:	0c 49       	mov	r9,	r12	;
    788a:	b0 12 58 69 	call	#26968		;#0x6958

0000788e <.L357>:
}
    788e:	21 52       	add	#4,	r1	;r2 As==10
    7890:	64 17       	popm	#7,	r10	;16-bit words
    7892:	30 41       	ret			

00007894 <.L375>:
  buffer[1] = (crc ? 2 : 0);
    7894:	0d 4c       	mov	r12,	r13	;

00007896 <.LVL459>:
    7896:	ec 3f       	jmp	$-38     	;abs 0x7870

00007898 <.L378>:
    crcGenX25(buffer, 6);
    7898:	7d 40 06 00 	mov.b	#6,	r13	;
    789c:	0c 49       	mov	r9,	r12	;
    789e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000078a2 <.LVL460>:
    78a2:	f2 3f       	jmp	$-26     	;abs 0x7888

000078a4 <.L363>:
        elyErrorSignal(ErrCmdFailure);
    78a4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    78a8:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000078ac <.LVL462>:
        elyNLFreeBuffer(elyNLPack(buffer));
    78ac:	0c 49       	mov	r9,	r12	;
    78ae:	b0 12 4c a8 	call	#-22452	;#0xa84c

000078b2 <.LVL463>:
    78b2:	b0 12 1e a7 	call	#-22754	;#0xa71e

000078b6 <.LVL464>:
    78b6:	eb 3f       	jmp	$-40     	;abs 0x788e

000078b8 <.L377>:
    78b8:	47 43       	clr.b	r7		;
    78ba:	06 47       	mov	r7,	r6	;
    78bc:	0f 3c       	jmp	$+32     	;abs 0x78dc

000078be <.L369>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    78be:	3e 40 03 00 	mov	#3,	r14	;
    78c2:	0e 8a       	sub	r10,	r14	;
    78c4:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    78c8:	0c 49       	mov	r9,	r12	;
    78ca:	0c 58       	add	r8,	r12	;
    78cc:	6c 4c       	mov.b	@r12,	r12	;
    78ce:	0d 43       	clr	r13		;
    78d0:	0f 43       	clr	r15		;
    78d2:	b0 12 98 ac 	call	#-21352	;#0xac98
    78d6:	07 dc       	bis	r12,	r7	;

000078d8 <.LVL468>:
    78d8:	06 dd       	bis	r13,	r6	;

000078da <.LVL469>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    78da:	1a 53       	inc	r10		;

000078dc <.L368>:
    78dc:	0a 95       	cmp	r5,	r10	;
    78de:	ef 3b       	jl	$-32     	;abs 0x78be

000078e0 <.LBE307>:
  interval = (interval / 100) * 100;
    78e0:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    78e4:	4f 43       	clr.b	r15		;
    78e6:	0c 47       	mov	r7,	r12	;
    78e8:	0d 46       	mov	r6,	r13	;
    78ea:	b0 12 1c ac 	call	#-21476	;#0xac1c
    78ee:	07 4c       	mov	r12,	r7	;

000078f0 <.LVL472>:
    78f0:	06 4d       	mov	r13,	r6	;
    78f2:	0a 4c       	mov	r12,	r10	;

000078f4 <.LVL473>:
    78f4:	0a 5c       	add	r12,	r10	;
    78f6:	05 4d       	mov	r13,	r5	;
    78f8:	05 6d       	addc	r13,	r5	;
    78fa:	0a 5c       	add	r12,	r10	;
    78fc:	05 6d       	addc	r13,	r5	;
    78fe:	0c 4a       	mov	r10,	r12	;
    7900:	0d 45       	mov	r5,	r13	;
    7902:	b0 12 7c ac 	call	#-21380	;#0xac7c
    7906:	0c 5a       	add	r10,	r12	;
    7908:	0d 65       	addc	r5,	r13	;

0000790a <.Loc.946.1>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    790a:	28 52       	add	#4,	r8	;r2 As==10

0000790c <.LVL476>:
    790c:	0e 4c       	mov	r12,	r14	;
    790e:	0e 57       	add	r7,	r14	;
    7910:	0f 4d       	mov	r13,	r15	;
    7912:	0f 66       	addc	r6,	r15	;
    7914:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7918:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    791c:	0c 49       	mov	r9,	r12	;
    791e:	0c 58       	add	r8,	r12	;
    7920:	b0 12 18 aa 	call	#-21992	;#0xaa18

00007924 <.LVL478>:
  if (hdr.reply) {
    7924:	04 93       	cmp	#0,	r4	;r3 As==00
    7926:	06 20       	jnz	$+14     	;abs 0x7934

00007928 <.Loc.955.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7928:	0c 49       	mov	r9,	r12	;
    792a:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000792e <.LVL479>:
    792e:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007932 <.LVL480>:
    7932:	ad 3f       	jmp	$-164    	;abs 0x788e

00007934 <.L379>:
    gen_success(buffer, hdr.crc);
    7934:	5c 41 02 00 	mov.b	2(r1),	r12	;
    7938:	5c f3       	and.b	#1,	r12	;r3 As==01

0000793a <.LBB308>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    793a:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    793e:	00 00 

00007940 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7940:	0c 93       	cmp	#0,	r12	;r3 As==00
    7942:	14 24       	jz	$+42     	;abs 0x796c
    7944:	7d 40 03 00 	mov.b	#3,	r13	;

00007948 <.L371>:
    7948:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

0000794c <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    794c:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7950:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    7954:	02 00 

00007956 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7956:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    795a:	03 00 

0000795c <.Loc.24.1>:
  buffer[4] = 1;
    795c:	d9 43 04 00 	mov.b	#1,	4(r9)	;r3 As==01

00007960 <.Loc.25.1>:
  if (crc) {
    7960:	0c 93       	cmp	#0,	r12	;r3 As==00
    7962:	06 20       	jnz	$+14     	;abs 0x7970

00007964 <.L372>:
    elyCmdSendReply(buffer);
    7964:	0c 49       	mov	r9,	r12	;
    7966:	b0 12 58 69 	call	#26968		;#0x6958

0000796a <.LVL483>:
    796a:	91 3f       	jmp	$-220    	;abs 0x788e

0000796c <.L376>:
  buffer[1] = (crc ? 3 : 1);
    796c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    796e:	ec 3f       	jmp	$-38     	;abs 0x7948

00007970 <.L380>:
    crcGenX25(buffer, 7);
    7970:	7d 40 07 00 	mov.b	#7,	r13	;
    7974:	0c 49       	mov	r9,	r12	;
    7976:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000797a <.LVL485>:
    797a:	f4 3f       	jmp	$-22     	;abs 0x7964

0000797c <channel_unsub>:
    797c:	3a 15       	pushm	#4,	r10	;16-bit words

0000797e <.LCFI49>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    797e:	21 83       	decd	r1		;

00007980 <.LCFI50>:
    7980:	0a 4c       	mov	r12,	r10	;

00007982 <.Loc.881.1>:
    7982:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7986:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    798a:	01 00 

0000798c <.Loc.882.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    798c:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7990:	6c 41       	mov.b	@r1,	r12	;

00007992 <L0>:
    7992:	1c b3       	bit	#1,	r12	;r3 As==01
    7994:	1a 24       	jz	$+54     	;abs 0x79ca
    7996:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007998 <.L382>:
    7998:	6c f3       	and.b	#2,	r12	;r3 As==10
    799a:	49 4c       	mov.b	r12,	r9	;
    799c:	4c 5e       	add.b	r14,	r12	;
    799e:	4d 8c       	sub.b	r12,	r13	;
    79a0:	48 4d       	mov.b	r13,	r8	;

000079a2 <.LVL488>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    79a2:	09 93       	cmp	#0,	r9	;r3 As==00
    79a4:	14 24       	jz	$+42     	;abs 0x79ce

000079a6 <.Loc.883.1>:
    79a6:	6c 42       	mov.b	#4,	r12	;r2 As==10

000079a8 <.L383>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    79a8:	0b 4c       	mov	r12,	r11	;

000079aa <.LVL490>:
    79aa:	0e 4c       	mov	r12,	r14	;

000079ac <.L384>:
    79ac:	0f 48       	mov	r8,	r15	;
    79ae:	0f 5b       	add	r11,	r15	;
    79b0:	0e 9f       	cmp	r15,	r14	;
    79b2:	3a 34       	jge	$+118    	;abs 0x7a28

000079b4 <.Loc.886.1>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    79b4:	0f 4a       	mov	r10,	r15	;
    79b6:	0f 5e       	add	r14,	r15	;
    79b8:	6f 4f       	mov.b	@r15,	r15	;
    79ba:	7f 50 c0 ff 	add.b	#-64,	r15	;#0xffc0
    79be:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    79c2:	47 9f       	cmp.b	r15,	r7	;
    79c4:	06 28       	jnc	$+14     	;abs 0x79d2

000079c6 <.Loc.885.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    79c6:	1e 53       	inc	r14		;
    79c8:	f1 3f       	jmp	$-28     	;abs 0x79ac

000079ca <.L394>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    79ca:	4e 43       	clr.b	r14		;
    79cc:	e5 3f       	jmp	$-52     	;abs 0x7998

000079ce <.L395>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    79ce:	6c 43       	mov.b	#2,	r12	;r3 As==10
    79d0:	eb 3f       	jmp	$-40     	;abs 0x79a8

000079d2 <.L399>:
      if (hdr.reply) {
    79d2:	09 93       	cmp	#0,	r9	;r3 As==00
    79d4:	1f 24       	jz	$+64     	;abs 0x7a14

000079d6 <.Loc.889.1>:
        gen_failure(buffer, hdr.crc);
    79d6:	6c 41       	mov.b	@r1,	r12	;
    79d8:	5c f3       	and.b	#1,	r12	;r3 As==01

000079da <.LBB318>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    79da:	ca f7 00 00 	and.b	r7,	0(r10)	;

000079de <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    79de:	0c 93       	cmp	#0,	r12	;r3 As==00
    79e0:	11 24       	jz	$+36     	;abs 0x7a04
    79e2:	6d 43       	mov.b	#2,	r13	;r3 As==10

000079e4 <.L387>:
    79e4:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

000079e8 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    79e8:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    79ec:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    79f0:	02 00 

000079f2 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    79f2:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    79f6:	03 00 

000079f8 <.Loc.35.1>:
  if (crc) {
    79f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    79fa:	06 20       	jnz	$+14     	;abs 0x7a08

000079fc <.L388>:
        elyCmdSendReply(buffer);
    79fc:	0c 4a       	mov	r10,	r12	;
    79fe:	b0 12 58 69 	call	#26968		;#0x6958

00007a02 <.LVL499>:
    7a02:	1c 3c       	jmp	$+58     	;abs 0x7a3c

00007a04 <.L396>:
  buffer[1] = (crc ? 2 : 0);
    7a04:	0d 4c       	mov	r12,	r13	;

00007a06 <.LVL501>:
    7a06:	ee 3f       	jmp	$-34     	;abs 0x79e4

00007a08 <.L400>:
    crcGenX25(buffer, 6);
    7a08:	7d 40 06 00 	mov.b	#6,	r13	;
    7a0c:	0c 4a       	mov	r10,	r12	;
    7a0e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007a12 <.LVL502>:
    7a12:	f4 3f       	jmp	$-22     	;abs 0x79fc

00007a14 <.L386>:
        elyErrorSignal(ErrCmdFailure);
    7a14:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7a18:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007a1c <.LVL504>:
        elyNLFreeBuffer(elyNLPack(buffer));
    7a1c:	0c 4a       	mov	r10,	r12	;
    7a1e:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007a22 <.LVL505>:
    7a22:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007a26 <.LVL506>:
    7a26:	0a 3c       	jmp	$+22     	;abs 0x7a3c

00007a28 <.L398>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    7a28:	0c 5a       	add	r10,	r12	;
    7a2a:	b0 12 e8 a9 	call	#-22040	;#0xa9e8

00007a2e <.LVL508>:
  if (hdr.reply) {
    7a2e:	09 93       	cmp	#0,	r9	;r3 As==00
    7a30:	08 20       	jnz	$+18     	;abs 0x7a42

00007a32 <.Loc.910.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7a32:	0c 4a       	mov	r10,	r12	;
    7a34:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007a38 <.LVL509>:
    7a38:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007a3c <.L381>:
}
    7a3c:	21 53       	incd	r1		;
    7a3e:	37 17       	popm	#4,	r10	;16-bit words
    7a40:	30 41       	ret			

00007a42 <.L401>:
    gen_success(buffer, hdr.crc);
    7a42:	6c 41       	mov.b	@r1,	r12	;
    7a44:	5c f3       	and.b	#1,	r12	;r3 As==01

00007a46 <.LBB323>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7a46:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7a4a:	00 00 

00007a4c <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7a4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a4e:	14 24       	jz	$+42     	;abs 0x7a78
    7a50:	7d 40 03 00 	mov.b	#3,	r13	;

00007a54 <.L392>:
    7a54:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00007a58 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7a58:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7a5c:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7a60:	02 00 

00007a62 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7a62:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    7a66:	03 00 

00007a68 <.Loc.24.1>:
  buffer[4] = 1;
    7a68:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00007a6c <.Loc.25.1>:
  if (crc) {
    7a6c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a6e:	06 20       	jnz	$+14     	;abs 0x7a7c

00007a70 <.L393>:
    elyCmdSendReply(buffer);
    7a70:	0c 4a       	mov	r10,	r12	;
    7a72:	b0 12 58 69 	call	#26968		;#0x6958

00007a76 <.LVL513>:
    7a76:	e2 3f       	jmp	$-58     	;abs 0x7a3c

00007a78 <.L397>:
  buffer[1] = (crc ? 3 : 1);
    7a78:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7a7a:	ec 3f       	jmp	$-38     	;abs 0x7a54

00007a7c <.L402>:
    crcGenX25(buffer, 7);
    7a7c:	7d 40 07 00 	mov.b	#7,	r13	;
    7a80:	0c 4a       	mov	r10,	r12	;
    7a82:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007a86 <.LVL515>:
    7a86:	f4 3f       	jmp	$-22     	;abs 0x7a70

00007a88 <channel_sub>:
    7a88:	6a 15       	pushm	#7,	r10	;16-bit words

00007a8a <.LCFI51>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a8a:	21 82       	sub	#4,	r1	;r2 As==10

00007a8c <.LCFI52>:
    7a8c:	09 4c       	mov	r12,	r9	;

00007a8e <.Loc.835.1>:
    7a8e:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    7a92:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    7a96:	03 00 

00007a98 <.Loc.836.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7a98:	5e 41 03 00 	mov.b	3(r1),	r14	;

00007a9c <L0>:
    7a9c:	5c 41 02 00 	mov.b	2(r1),	r12	;

00007aa0 <.LVL517>:
    7aa0:	1c b3       	bit	#1,	r12	;r3 As==01
    7aa2:	2d 24       	jz	$+92     	;abs 0x7afe
    7aa4:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007aa6 <.L404>:
    7aa6:	6c f3       	and.b	#2,	r12	;r3 As==10
    7aa8:	44 4c       	mov.b	r12,	r4	;
    7aaa:	4c 5d       	add.b	r13,	r12	;
    7aac:	4e 8c       	sub.b	r12,	r14	;
    7aae:	c1 4e 01 00 	mov.b	r14,	1(r1)	;
    7ab2:	4f 4e       	mov.b	r14,	r15	;

00007ab4 <.LVL518>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7ab4:	04 93       	cmp	#0,	r4	;r3 As==00
    7ab6:	25 24       	jz	$+76     	;abs 0x7b02

00007ab8 <.Loc.837.1>:
    7ab8:	68 42       	mov.b	#4,	r8	;r2 As==10

00007aba <.L405>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7aba:	0a 48       	mov	r8,	r10	;
    7abc:	05 48       	mov	r8,	r5	;
    7abe:	25 52       	add	#4,	r5	;r2 As==10

00007ac0 <.LVL520>:
    7ac0:	0d 45       	mov	r5,	r13	;

00007ac2 <.L406>:
    7ac2:	0c 4f       	mov	r15,	r12	;
    7ac4:	0c 5a       	add	r10,	r12	;
    7ac6:	0d 9c       	cmp	r12,	r13	;
    7ac8:	4d 34       	jge	$+156    	;abs 0x7b64

00007aca <.Loc.841.1>:
    if ((buffer[i] < 0x40) || 
    7aca:	0c 49       	mov	r9,	r12	;
    7acc:	0c 5d       	add	r13,	r12	;
    7ace:	6c 4c       	mov.b	@r12,	r12	;
    7ad0:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    7ad4:	47 9c       	cmp.b	r12,	r7	;
    7ad6:	17 2c       	jc	$+48     	;abs 0x7b06

00007ad8 <.Loc.842.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7ad8:	4e 4c       	mov.b	r12,	r14	;
    7ada:	7e 50 af ff 	add.b	#-81,	r14	;#0xffaf

00007ade <.Loc.841.1>:
    if ((buffer[i] < 0x40) || 
    7ade:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    7ae2:	47 9e       	cmp.b	r14,	r7	;
    7ae4:	10 2c       	jc	$+34     	;abs 0x7b06

00007ae6 <.Loc.843.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7ae6:	7e 50 ee ff 	add.b	#-18,	r14	;#0xffee

00007aea <.Loc.842.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7aea:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    7aee:	47 9e       	cmp.b	r14,	r7	;
    7af0:	0a 2c       	jc	$+22     	;abs 0x7b06

00007af2 <.Loc.843.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7af2:	7e 40 76 00 	mov.b	#118,	r14	;#0x0076
    7af6:	4e 9c       	cmp.b	r12,	r14	;
    7af8:	06 28       	jnc	$+14     	;abs 0x7b06

00007afa <.Loc.840.1>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7afa:	1d 53       	inc	r13		;
    7afc:	e2 3f       	jmp	$-58     	;abs 0x7ac2

00007afe <.L419>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7afe:	4d 43       	clr.b	r13		;
    7b00:	d2 3f       	jmp	$-90     	;abs 0x7aa6

00007b02 <.L420>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7b02:	68 43       	mov.b	#2,	r8	;r3 As==10
    7b04:	da 3f       	jmp	$-74     	;abs 0x7aba

00007b06 <.L407>:
      if (hdr.reply) {
    7b06:	04 93       	cmp	#0,	r4	;r3 As==00
    7b08:	23 24       	jz	$+72     	;abs 0x7b50

00007b0a <.Loc.847.1>:
        gen_failure(buffer, hdr.crc);
    7b0a:	5c 41 02 00 	mov.b	2(r1),	r12	;
    7b0e:	5c f3       	and.b	#1,	r12	;r3 As==01

00007b10 <.LBB334>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7b10:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    7b14:	00 00 

00007b16 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7b16:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b18:	13 24       	jz	$+40     	;abs 0x7b40
    7b1a:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007b1c <.L410>:
    7b1c:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00007b20 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7b20:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7b24:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    7b28:	02 00 

00007b2a <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7b2a:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    7b2e:	03 00 

00007b30 <.Loc.35.1>:
  if (crc) {
    7b30:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b32:	08 20       	jnz	$+18     	;abs 0x7b44

00007b34 <.L411>:
        elyCmdSendReply(buffer);
    7b34:	0c 49       	mov	r9,	r12	;
    7b36:	b0 12 58 69 	call	#26968		;#0x6958

00007b3a <.L403>:
}
    7b3a:	21 52       	add	#4,	r1	;r2 As==10
    7b3c:	64 17       	popm	#7,	r10	;16-bit words
    7b3e:	30 41       	ret			

00007b40 <.L421>:
  buffer[1] = (crc ? 2 : 0);
    7b40:	0d 4c       	mov	r12,	r13	;

00007b42 <.LVL531>:
    7b42:	ec 3f       	jmp	$-38     	;abs 0x7b1c

00007b44 <.L424>:
    crcGenX25(buffer, 6);
    7b44:	7d 40 06 00 	mov.b	#6,	r13	;
    7b48:	0c 49       	mov	r9,	r12	;
    7b4a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007b4e <.LVL532>:
    7b4e:	f2 3f       	jmp	$-26     	;abs 0x7b34

00007b50 <.L409>:
        elyNLFreeBuffer(elyNLPack(buffer));
    7b50:	0c 49       	mov	r9,	r12	;
    7b52:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007b56 <.LVL534>:
    7b56:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007b5a <.LVL535>:
        elyErrorSignal(ErrCmdFailure);
    7b5a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7b5e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007b62 <.LVL536>:
    7b62:	eb 3f       	jmp	$-40     	;abs 0x7b3a

00007b64 <.L423>:
    7b64:	47 43       	clr.b	r7		;
    7b66:	06 47       	mov	r7,	r6	;
    7b68:	0f 3c       	jmp	$+32     	;abs 0x7b88

00007b6a <.L415>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7b6a:	3e 40 03 00 	mov	#3,	r14	;
    7b6e:	0e 8a       	sub	r10,	r14	;
    7b70:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7b74:	0c 49       	mov	r9,	r12	;
    7b76:	0c 58       	add	r8,	r12	;
    7b78:	6c 4c       	mov.b	@r12,	r12	;
    7b7a:	0d 43       	clr	r13		;
    7b7c:	0f 43       	clr	r15		;
    7b7e:	b0 12 98 ac 	call	#-21352	;#0xac98
    7b82:	07 dc       	bis	r12,	r7	;

00007b84 <.LVL540>:
    7b84:	06 dd       	bis	r13,	r6	;

00007b86 <.LVL541>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7b86:	1a 53       	inc	r10		;

00007b88 <.L414>:
    7b88:	0a 95       	cmp	r5,	r10	;
    7b8a:	ef 3b       	jl	$-32     	;abs 0x7b6a

00007b8c <.LBE340>:
  interval = (interval / 100) * 100;
    7b8c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7b90:	4f 43       	clr.b	r15		;
    7b92:	0c 47       	mov	r7,	r12	;
    7b94:	0d 46       	mov	r6,	r13	;
    7b96:	b0 12 1c ac 	call	#-21476	;#0xac1c
    7b9a:	07 4c       	mov	r12,	r7	;

00007b9c <.LVL544>:
    7b9c:	06 4d       	mov	r13,	r6	;
    7b9e:	0a 4c       	mov	r12,	r10	;

00007ba0 <.LVL545>:
    7ba0:	0a 5c       	add	r12,	r10	;
    7ba2:	05 4d       	mov	r13,	r5	;
    7ba4:	05 6d       	addc	r13,	r5	;
    7ba6:	0a 5c       	add	r12,	r10	;
    7ba8:	05 6d       	addc	r13,	r5	;
    7baa:	0c 4a       	mov	r10,	r12	;
    7bac:	0d 45       	mov	r5,	r13	;
    7bae:	b0 12 7c ac 	call	#-21380	;#0xac7c
    7bb2:	0c 5a       	add	r10,	r12	;
    7bb4:	0d 65       	addc	r5,	r13	;

00007bb6 <.Loc.867.1>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    7bb6:	28 52       	add	#4,	r8	;r2 As==10

00007bb8 <.LVL548>:
    7bb8:	0e 4c       	mov	r12,	r14	;
    7bba:	0e 57       	add	r7,	r14	;
    7bbc:	0f 4d       	mov	r13,	r15	;
    7bbe:	0f 66       	addc	r6,	r15	;
    7bc0:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7bc4:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    7bc8:	0c 49       	mov	r9,	r12	;
    7bca:	0c 58       	add	r8,	r12	;
    7bcc:	b0 12 b8 a9 	call	#-22088	;#0xa9b8

00007bd0 <.LVL550>:
  if (hdr.reply) {
    7bd0:	04 93       	cmp	#0,	r4	;r3 As==00
    7bd2:	06 20       	jnz	$+14     	;abs 0x7be0

00007bd4 <.Loc.876.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7bd4:	0c 49       	mov	r9,	r12	;
    7bd6:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007bda <.LVL551>:
    7bda:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007bde <.LVL552>:
    7bde:	ad 3f       	jmp	$-164    	;abs 0x7b3a

00007be0 <.L425>:
    gen_success(buffer, hdr.crc);
    7be0:	5c 41 02 00 	mov.b	2(r1),	r12	;
    7be4:	5c f3       	and.b	#1,	r12	;r3 As==01

00007be6 <.LBB341>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7be6:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    7bea:	00 00 

00007bec <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7bec:	0c 93       	cmp	#0,	r12	;r3 As==00
    7bee:	14 24       	jz	$+42     	;abs 0x7c18
    7bf0:	7d 40 03 00 	mov.b	#3,	r13	;

00007bf4 <.L417>:
    7bf4:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00007bf8 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7bf8:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7bfc:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    7c00:	02 00 

00007c02 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7c02:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    7c06:	03 00 

00007c08 <.Loc.24.1>:
  buffer[4] = 1;
    7c08:	d9 43 04 00 	mov.b	#1,	4(r9)	;r3 As==01

00007c0c <.Loc.25.1>:
  if (crc) {
    7c0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c0e:	06 20       	jnz	$+14     	;abs 0x7c1c

00007c10 <.L418>:
    elyCmdSendReply(buffer);
    7c10:	0c 49       	mov	r9,	r12	;
    7c12:	b0 12 58 69 	call	#26968		;#0x6958

00007c16 <.LVL555>:
    7c16:	91 3f       	jmp	$-220    	;abs 0x7b3a

00007c18 <.L422>:
  buffer[1] = (crc ? 3 : 1);
    7c18:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7c1a:	ec 3f       	jmp	$-38     	;abs 0x7bf4

00007c1c <.L426>:
    crcGenX25(buffer, 7);
    7c1c:	7d 40 07 00 	mov.b	#7,	r13	;
    7c20:	0c 49       	mov	r9,	r12	;
    7c22:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007c26 <.LVL557>:
    7c26:	f4 3f       	jmp	$-22     	;abs 0x7c10

00007c28 <reload_config>:
    7c28:	3a 15       	pushm	#4,	r10	;16-bit words

00007c2a <.LCFI53>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7c2a:	21 83       	decd	r1		;

00007c2c <.LCFI54>:
    7c2c:	0a 4c       	mov	r12,	r10	;

00007c2e <.Loc.801.1>:
    7c2e:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7c32:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7c36:	01 00 

00007c38 <.Loc.802.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c38:	6c 41       	mov.b	@r1,	r12	;

00007c3a <.LVL559>:
    7c3a:	6c f3       	and.b	#2,	r12	;r3 As==10
    7c3c:	3c f0       	and,		r12	;Warning: disassembly unreliable - not enough bytes available

00007c3e <L0>:
    7c3e:	ff 00       	suba	r0,	r15	;
    7c40:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c42:	25 24       	jz	$+76     	;abs 0x7c8e
    7c44:	6d 42       	mov.b	#4,	r13	;r2 As==10

00007c46 <.L428>:
  uint8_t bank = buffer[hdr_ext];
    7c46:	0d 5a       	add	r10,	r13	;

00007c48 <.LVL561>:
    7c48:	69 4d       	mov.b	@r13,	r9	;

00007c4a <.LVL562>:
  if (bank == 0 || bank > 4) {
    7c4a:	4d 49       	mov.b	r9,	r13	;

00007c4c <.LVL563>:
    7c4c:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7c4e:	7e 40 03 00 	mov.b	#3,	r14	;
    7c52:	4e 9d       	cmp.b	r13,	r14	;
    7c54:	30 2c       	jc	$+98     	;abs 0x7cb6

00007c56 <.Loc.807.1>:
    if (hdr.reply) {
    7c56:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c58:	24 24       	jz	$+74     	;abs 0x7ca2

00007c5a <.Loc.809.1>:
      gen_failure(buffer, hdr.crc);
    7c5a:	6c 41       	mov.b	@r1,	r12	;
    7c5c:	5c f3       	and.b	#1,	r12	;r3 As==01

00007c5e <.LBB347>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7c5e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7c62:	00 00 

00007c64 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7c64:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c66:	15 24       	jz	$+44     	;abs 0x7c92
    7c68:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007c6a <.L431>:
    7c6a:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00007c6e <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7c6e:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7c72:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7c76:	02 00 

00007c78 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7c78:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    7c7c:	03 00 

00007c7e <.Loc.35.1>:
  if (crc) {
    7c7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c80:	0a 20       	jnz	$+22     	;abs 0x7c96

00007c82 <.L432>:
      elyCmdSendReply(buffer);
    7c82:	0c 4a       	mov	r10,	r12	;
    7c84:	b0 12 58 69 	call	#26968		;#0x6958

00007c88 <.L427>:
}
    7c88:	21 53       	incd	r1		;
    7c8a:	37 17       	popm	#4,	r10	;16-bit words
    7c8c:	30 41       	ret			

00007c8e <.L434>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c8e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7c90:	da 3f       	jmp	$-74     	;abs 0x7c46

00007c92 <.L435>:
  buffer[1] = (crc ? 2 : 0);
    7c92:	0d 4c       	mov	r12,	r13	;
    7c94:	ea 3f       	jmp	$-42     	;abs 0x7c6a

00007c96 <.L436>:
    crcGenX25(buffer, 6);
    7c96:	7d 40 06 00 	mov.b	#6,	r13	;
    7c9a:	0c 4a       	mov	r10,	r12	;
    7c9c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007ca0 <.LVL569>:
    7ca0:	f0 3f       	jmp	$-30     	;abs 0x7c82

00007ca2 <.L430>:
      elyErrorSignal(ErrCmdFailure);
    7ca2:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7ca6:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007caa <.LVL571>:
      elyNLFreeBuffer(elyNLPack(buffer));
    7caa:	0c 4a       	mov	r10,	r12	;
    7cac:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007cb0 <.LVL572>:
    7cb0:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007cb4 <.LVL573>:
    7cb4:	e9 3f       	jmp	$-44     	;abs 0x7c88

00007cb6 <.L429>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    7cb6:	18 42 82 b1 	mov	&0xb182,r8	;0xb182
    7cba:	37 40 86 9a 	mov	#-25978,r7	;#0x9a86
    7cbe:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    7cc2:	4e 43       	clr.b	r14		;
    7cc4:	0d 48       	mov	r8,	r13	;
    7cc6:	4c 49       	mov.b	r9,	r12	;
    7cc8:	87 12       	call	r7		;

00007cca <.LVL574>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    7cca:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    7cce:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    7cd2:	0d 48       	mov	r8,	r13	;
    7cd4:	3d 50 80 00 	add	#128,	r13	;#0x0080
    7cd8:	4c 49       	mov.b	r9,	r12	;
    7cda:	87 12       	call	r7		;

00007cdc <.LVL575>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    7cdc:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    7ce0:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    7ce4:	0d 48       	mov	r8,	r13	;
    7ce6:	3d 50 c0 00 	add	#192,	r13	;#0x00c0
    7cea:	4c 49       	mov.b	r9,	r12	;
    7cec:	87 12       	call	r7		;

00007cee <.LVL576>:
  elyNLFreeBuffer(elyNLPack(buffer));
    7cee:	0c 4a       	mov	r10,	r12	;
    7cf0:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007cf4 <.LVL577>:
    7cf4:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007cf8 <.LVL578>:
  bank0w[RegActiveBank] = bank;
    7cf8:	c8 49 69 00 	mov.b	r9,	105(r8)	; 0x0069

00007cfc <.Loc.832.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7cfc:	b2 40 48 a5 	mov	#-23224,&0x0120	;#0xa548
    7d00:	20 01 
    7d02:	c2 3f       	jmp	$-122    	;abs 0x7c88

00007d04 <set_baud>:
    7d04:	5a 15       	pushm	#6,	r10	;16-bit words

00007d06 <.LCFI55>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7d06:	21 83       	decd	r1		;

00007d08 <.LCFI56>:
    7d08:	08 4c       	mov	r12,	r8	;

00007d0a <.Loc.757.1>:
    7d0a:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00007d0e <L0>:
    7d0e:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7d12:	01 00 

00007d14 <.Loc.758.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7d14:	66 41       	mov.b	@r1,	r6	;
    7d16:	66 f3       	and.b	#2,	r6	;r3 As==10
    7d18:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    7d1c:	06 93       	cmp	#0,	r6	;r3 As==00
    7d1e:	05 24       	jz	$+12     	;abs 0x7d2a
    7d20:	67 42       	mov.b	#4,	r7	;r2 As==10

00007d22 <.L438>:
  for (int i = 0; i < 4; i++) {
    7d22:	4a 43       	clr.b	r10		;

00007d24 <.LBE356>:
  uint32_t baud = 0;
    7d24:	05 4a       	mov	r10,	r5	;
    7d26:	09 4a       	mov	r10,	r9	;

00007d28 <.LBB357>:
  for (int i = 0; i < 4; i++) {
    7d28:	14 3c       	jmp	$+42     	;abs 0x7d52

00007d2a <.L450>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7d2a:	67 43       	mov.b	#2,	r7	;r3 As==10
    7d2c:	fa 3f       	jmp	$-10     	;abs 0x7d22

00007d2e <.L440>:
    baud |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    7d2e:	0c 47       	mov	r7,	r12	;
    7d30:	0c 5a       	add	r10,	r12	;
    7d32:	0c 58       	add	r8,	r12	;
    7d34:	3e 40 03 00 	mov	#3,	r14	;
    7d38:	0e 8a       	sub	r10,	r14	;
    7d3a:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7d3e:	6c 4c       	mov.b	@r12,	r12	;
    7d40:	0d 43       	clr	r13		;
    7d42:	0f 43       	clr	r15		;
    7d44:	b0 12 98 ac 	call	#-21352	;#0xac98
    7d48:	0c d5       	bis	r5,	r12	;
    7d4a:	0d d9       	bis	r9,	r13	;
    7d4c:	05 4c       	mov	r12,	r5	;

00007d4e <.LVL584>:
    7d4e:	09 4d       	mov	r13,	r9	;

00007d50 <.LVL585>:
  for (int i = 0; i < 4; i++) {
    7d50:	1a 53       	inc	r10		;

00007d52 <.L439>:
    7d52:	7c 40 03 00 	mov.b	#3,	r12	;
    7d56:	0c 9a       	cmp	r10,	r12	;
    7d58:	ea 37       	jge	$-42     	;abs 0x7d2e

00007d5a <.LBE358>:
  if (baud > UART_BAUD_MAX || 
    7d5a:	35 53       	add	#-1,	r5	;r3 As==11

00007d5c <.LVL587>:
    7d5c:	39 63       	addc	#-1,	r9	;r3 As==11
    7d5e:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f
    7d62:	0c 99       	cmp	r9,	r12	;
    7d64:	1c 2c       	jc	$+58     	;abs 0x7d9e

00007d66 <.L453>:
    if (hdr.reply) {
    7d66:	06 93       	cmp	#0,	r6	;r3 As==00
    7d68:	40 24       	jz	$+130    	;abs 0x7dea

00007d6a <.Loc.770.1>:
      gen_failure(buffer, hdr.crc);
    7d6a:	6c 41       	mov.b	@r1,	r12	;
    7d6c:	5c f3       	and.b	#1,	r12	;r3 As==01

00007d6e <.LBB359>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7d6e:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    7d72:	00 00 

00007d74 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7d74:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d76:	31 24       	jz	$+100    	;abs 0x7dda
    7d78:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007d7a <.L444>:
    7d7a:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00007d7e <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7d7e:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7d82:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    7d86:	02 00 

00007d88 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7d88:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    7d8c:	03 00 

00007d8e <.Loc.35.1>:
  if (crc) {
    7d8e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d90:	26 20       	jnz	$+78     	;abs 0x7dde

00007d92 <.L445>:
      elyCmdSendReply(buffer);
    7d92:	0c 48       	mov	r8,	r12	;
    7d94:	b0 12 58 69 	call	#26968		;#0x6958

00007d98 <.L437>:
}
    7d98:	21 53       	incd	r1		;
    7d9a:	55 17       	popm	#6,	r10	;16-bit words
    7d9c:	30 41       	ret			

00007d9e <.L454>:
  if (baud > UART_BAUD_MAX || 
    7d9e:	09 9c       	cmp	r12,	r9	;
    7da0:	04 20       	jnz	$+10     	;abs 0x7daa
    7da2:	3c 40 3f 42 	mov	#16959,	r12	;#0x423f
    7da6:	0c 95       	cmp	r5,	r12	;
    7da8:	de 2b       	jnc	$-66     	;abs 0x7d66

00007daa <.L441>:
  bank0w[RegUARTBaudMsb] = buffer[hdr_ext];
    7daa:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    7dae:	07 58       	add	r8,	r7	;

00007db0 <.LVL593>:
    7db0:	ec 47 25 00 	mov.b	@r7,	37(r12)	; 0x0025

00007db4 <.Loc.782.1>:
  bank0w[RegUARTBaudHmb] = buffer[hdr_ext+1];
    7db4:	dc 47 01 00 	mov.b	1(r7),	36(r12)	; 0x0024
    7db8:	24 00 

00007dba <.Loc.783.1>:
  bank0w[RegUARTBaudLmb] = buffer[hdr_ext+2];
    7dba:	dc 47 02 00 	mov.b	2(r7),	35(r12)	; 0x0023
    7dbe:	23 00 

00007dc0 <.Loc.784.1>:
  bank0w[RegUARTBaudLsb] = buffer[hdr_ext+3];
    7dc0:	dc 47 03 00 	mov.b	3(r7),	34(r12)	; 0x0022
    7dc4:	22 00 

00007dc6 <.Loc.787.1>:
  elyUARTCfgMarkDirty();
    7dc6:	b0 12 0e 60 	call	#24590		;#0x600e

00007dca <.LVL594>:
  if (hdr.reply) {
    7dca:	06 93       	cmp	#0,	r6	;r3 As==00
    7dcc:	18 20       	jnz	$+50     	;abs 0x7dfe

00007dce <.Loc.796.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7dce:	0c 48       	mov	r8,	r12	;
    7dd0:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007dd4 <.LVL595>:
    7dd4:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007dd8 <.LVL596>:
    7dd8:	df 3f       	jmp	$-64     	;abs 0x7d98

00007dda <.L451>:
  buffer[1] = (crc ? 2 : 0);
    7dda:	0d 4c       	mov	r12,	r13	;
    7ddc:	ce 3f       	jmp	$-98     	;abs 0x7d7a

00007dde <.L455>:
    crcGenX25(buffer, 6);
    7dde:	7d 40 06 00 	mov.b	#6,	r13	;
    7de2:	0c 48       	mov	r8,	r12	;
    7de4:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007de8 <.LVL598>:
    7de8:	d4 3f       	jmp	$-86     	;abs 0x7d92

00007dea <.L443>:
      elyErrorSignal(ErrCmdFailure);
    7dea:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7dee:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007df2 <.LVL600>:
      elyNLFreeBuffer(elyNLPack(buffer));
    7df2:	0c 48       	mov	r8,	r12	;
    7df4:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007df8 <.LVL601>:
    7df8:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007dfc <.LVL602>:
    7dfc:	cd 3f       	jmp	$-100    	;abs 0x7d98

00007dfe <.L456>:
    gen_success(buffer, hdr.crc);
    7dfe:	6c 41       	mov.b	@r1,	r12	;
    7e00:	5c f3       	and.b	#1,	r12	;r3 As==01

00007e02 <.LBB363>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7e02:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    7e06:	00 00 

00007e08 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7e08:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e0a:	14 24       	jz	$+42     	;abs 0x7e34
    7e0c:	7d 40 03 00 	mov.b	#3,	r13	;

00007e10 <.L448>:
    7e10:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00007e14 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7e14:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7e18:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    7e1c:	02 00 

00007e1e <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7e1e:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    7e22:	03 00 

00007e24 <.Loc.24.1>:
  buffer[4] = 1;
    7e24:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

00007e28 <.Loc.25.1>:
  if (crc) {
    7e28:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e2a:	06 20       	jnz	$+14     	;abs 0x7e38

00007e2c <.L449>:
    elyCmdSendReply(buffer);
    7e2c:	0c 48       	mov	r8,	r12	;
    7e2e:	b0 12 58 69 	call	#26968		;#0x6958

00007e32 <.LVL606>:
    7e32:	b2 3f       	jmp	$-154    	;abs 0x7d98

00007e34 <.L452>:
  buffer[1] = (crc ? 3 : 1);
    7e34:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7e36:	ec 3f       	jmp	$-38     	;abs 0x7e10

00007e38 <.L457>:
    crcGenX25(buffer, 7);
    7e38:	7d 40 07 00 	mov.b	#7,	r13	;
    7e3c:	0c 48       	mov	r8,	r12	;
    7e3e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007e42 <.LVL608>:
    7e42:	f4 3f       	jmp	$-22     	;abs 0x7e2c

00007e44 <get_baud>:
    7e44:	0a 15       	pushm	#1,	r10	;16-bit words

00007e46 <.LCFI57>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e46:	21 83       	decd	r1		;

00007e48 <.LCFI58>:
    7e48:	0a 4c       	mov	r12,	r10	;

00007e4a <.Loc.731.1>:
    7e4a:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7e4e:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7e52:	01 00 

00007e54 <.Loc.733.1>:
  if (hdr.reply) {
    7e54:	6b 41       	mov.b	@r1,	r11	;

00007e56 <L0>:
    7e56:	4c 4b       	mov.b	r11,	r12	;

00007e58 <.LVL610>:
    7e58:	6c f3       	and.b	#2,	r12	;r3 As==10
    7e5a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7e5c:	2e 24       	jz	$+94     	;abs 0x7eba

00007e5e <.Loc.734.1>:
    buffer[0] = buffer[0] & 0x3F;
    7e5e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7e62:	00 00 

00007e64 <.Loc.735.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7e64:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    7e68:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    7e6c:	02 00 

00007e6e <.Loc.736.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    7e6e:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    7e72:	03 00 

00007e74 <.LBB367>:
    for (int i = 0; i < 4; i++) {
    7e74:	4c 43       	clr.b	r12		;
    7e76:	0a 3c       	jmp	$+22     	;abs 0x7e8c

00007e78 <.L461>:
      buffer[i + 4] = bank0p[RegUARTBaudMsb - i];
    7e78:	0d 4c       	mov	r12,	r13	;
    7e7a:	2d 52       	add	#4,	r13	;r2 As==10
    7e7c:	0d 5a       	add	r10,	r13	;
    7e7e:	3e 40 25 00 	mov	#37,	r14	;#0x0025
    7e82:	0e 8c       	sub	r12,	r14	;
    7e84:	0e 5f       	add	r15,	r14	;
    7e86:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00007e8a <.Loc.738.1>:
    for (int i = 0; i < 4; i++) {
    7e8a:	1c 53       	inc	r12		;

00007e8c <.L460>:
    7e8c:	7d 40 03 00 	mov.b	#3,	r13	;
    7e90:	0d 9c       	cmp	r12,	r13	;
    7e92:	f2 37       	jge	$-26     	;abs 0x7e78

00007e94 <.LBE367>:
    if (hdr.crc) {
    7e94:	1b b3       	bit	#1,	r11	;r3 As==01
    7e96:	08 20       	jnz	$+18     	;abs 0x7ea8

00007e98 <.Loc.746.1>:
      buffer[1] = 4;
    7e98:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

00007e9c <.L463>:
    elyCmdSendReply(buffer);
    7e9c:	0c 4a       	mov	r10,	r12	;
    7e9e:	b0 12 58 69 	call	#26968		;#0x6958

00007ea2 <.L458>:
}
    7ea2:	21 53       	incd	r1		;
    7ea4:	0a 17       	popm	#1,	r10	;16-bit words
    7ea6:	30 41       	ret			

00007ea8 <.L465>:
      buffer[1] = 6;
    7ea8:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    7eac:	01 00 

00007eae <.Loc.743.1>:
      crcGenX25(buffer, 10);
    7eae:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    7eb2:	0c 4a       	mov	r10,	r12	;

00007eb4 <.LVL617>:
    7eb4:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007eb8 <.LVL618>:
    7eb8:	f1 3f       	jmp	$-28     	;abs 0x7e9c

00007eba <.L459>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7eba:	0c 4a       	mov	r10,	r12	;
    7ebc:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007ec0 <.LVL619>:
    7ec0:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007ec4 <.LVL620>:
}
    7ec4:	ee 3f       	jmp	$-34     	;abs 0x7ea2

00007ec6 <set_tx_pow>:
    7ec6:	1a 15       	pushm	#2,	r10	;16-bit words

00007ec8 <.LCFI59>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7ec8:	21 83       	decd	r1		;

00007eca <.LCFI60>:
    7eca:	0a 4c       	mov	r12,	r10	;

00007ecc <L0>:
    7ecc:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7ed0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7ed4:	01 00 

00007ed6 <.Loc.698.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7ed6:	69 41       	mov.b	@r1,	r9	;
    7ed8:	69 f3       	and.b	#2,	r9	;r3 As==10
    7eda:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7ede:	09 93       	cmp	#0,	r9	;r3 As==00
    7ee0:	22 24       	jz	$+70     	;abs 0x7f26
    7ee2:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007ee4 <.L467>:
  if ((int8_t)(buffer[hdr_ext]) > TX_POW_MAX) {
    7ee4:	0c 5a       	add	r10,	r12	;

00007ee6 <.LVL623>:
    7ee6:	6c 4c       	mov.b	@r12,	r12	;
    7ee8:	4d 43       	clr.b	r13		;
    7eea:	4d 9c       	cmp.b	r12,	r13	;
    7eec:	30 34       	jge	$+98     	;abs 0x7f4e

00007eee <.Loc.701.1>:
    if (hdr.reply) {
    7eee:	09 93       	cmp	#0,	r9	;r3 As==00
    7ef0:	24 24       	jz	$+74     	;abs 0x7f3a

00007ef2 <.Loc.703.1>:
      gen_failure(buffer, hdr.crc);
    7ef2:	6c 41       	mov.b	@r1,	r12	;
    7ef4:	5c f3       	and.b	#1,	r12	;r3 As==01

00007ef6 <.LBB372>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7ef6:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7efa:	00 00 

00007efc <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    7efc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7efe:	15 24       	jz	$+44     	;abs 0x7f2a
    7f00:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007f02 <.L470>:
    7f02:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00007f06 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7f06:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7f0a:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7f0e:	02 00 

00007f10 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7f10:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    7f14:	03 00 

00007f16 <.Loc.35.1>:
  if (crc) {
    7f16:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f18:	0a 20       	jnz	$+22     	;abs 0x7f2e

00007f1a <.L471>:
      elyCmdSendReply(buffer);
    7f1a:	0c 4a       	mov	r10,	r12	;
    7f1c:	b0 12 58 69 	call	#26968		;#0x6958

00007f20 <.L466>:
}
    7f20:	21 53       	incd	r1		;
    7f22:	19 17       	popm	#2,	r10	;16-bit words
    7f24:	30 41       	ret			

00007f26 <.L476>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7f26:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7f28:	dd 3f       	jmp	$-68     	;abs 0x7ee4

00007f2a <.L477>:
  buffer[1] = (crc ? 2 : 0);
    7f2a:	0d 4c       	mov	r12,	r13	;
    7f2c:	ea 3f       	jmp	$-42     	;abs 0x7f02

00007f2e <.L479>:
    crcGenX25(buffer, 6);
    7f2e:	7d 40 06 00 	mov.b	#6,	r13	;
    7f32:	0c 4a       	mov	r10,	r12	;
    7f34:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007f38 <.LVL628>:
    7f38:	f0 3f       	jmp	$-30     	;abs 0x7f1a

00007f3a <.L469>:
      elyErrorSignal(ErrCmdFailure);
    7f3a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7f3e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00007f42 <.LVL630>:
      elyNLFreeBuffer(elyNLPack(buffer));
    7f42:	0c 4a       	mov	r10,	r12	;
    7f44:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007f48 <.LVL631>:
    7f48:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007f4c <.LVL632>:
    7f4c:	e9 3f       	jmp	$-44     	;abs 0x7f20

00007f4e <.L468>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    7f4e:	1d 42 82 b1 	mov	&0xb182,r13	;0xb182
    7f52:	cd 4c 21 00 	mov.b	r12,	33(r13)	; 0x0021

00007f56 <.Loc.717.1>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    7f56:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    7f5a:	4d 43       	clr.b	r13		;
    7f5c:	b0 12 9c aa 	call	#-21860	;#0xaa9c

00007f60 <.LVL633>:
  if (hdr.reply) {
    7f60:	09 93       	cmp	#0,	r9	;r3 As==00
    7f62:	06 20       	jnz	$+14     	;abs 0x7f70

00007f64 <.Loc.726.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7f64:	0c 4a       	mov	r10,	r12	;
    7f66:	b0 12 4c a8 	call	#-22452	;#0xa84c

00007f6a <.LVL634>:
    7f6a:	b0 12 1e a7 	call	#-22754	;#0xa71e

00007f6e <.LVL635>:
    7f6e:	d8 3f       	jmp	$-78     	;abs 0x7f20

00007f70 <.L480>:
    gen_success(buffer, hdr.crc);
    7f70:	6c 41       	mov.b	@r1,	r12	;
    7f72:	5c f3       	and.b	#1,	r12	;r3 As==01

00007f74 <.LBB376>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7f74:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7f78:	00 00 

00007f7a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    7f7a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f7c:	14 24       	jz	$+42     	;abs 0x7fa6
    7f7e:	7d 40 03 00 	mov.b	#3,	r13	;

00007f82 <.L474>:
    7f82:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00007f86 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7f86:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    7f8a:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    7f8e:	02 00 

00007f90 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7f90:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    7f94:	03 00 

00007f96 <.Loc.24.1>:
  buffer[4] = 1;
    7f96:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00007f9a <.Loc.25.1>:
  if (crc) {
    7f9a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f9c:	06 20       	jnz	$+14     	;abs 0x7faa

00007f9e <.L475>:
    elyCmdSendReply(buffer);
    7f9e:	0c 4a       	mov	r10,	r12	;
    7fa0:	b0 12 58 69 	call	#26968		;#0x6958

00007fa4 <.LVL638>:
    7fa4:	bd 3f       	jmp	$-132    	;abs 0x7f20

00007fa6 <.L478>:
  buffer[1] = (crc ? 3 : 1);
    7fa6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7fa8:	ec 3f       	jmp	$-38     	;abs 0x7f82

00007faa <.L481>:
    crcGenX25(buffer, 7);
    7faa:	7d 40 07 00 	mov.b	#7,	r13	;
    7fae:	0c 4a       	mov	r10,	r12	;
    7fb0:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00007fb4 <.LVL640>:
    7fb4:	f4 3f       	jmp	$-22     	;abs 0x7f9e

00007fb6 <get_tx_pow>:
    7fb6:	0a 15       	pushm	#1,	r10	;16-bit words

00007fb8 <.LCFI61>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7fb8:	21 83       	decd	r1		;

00007fba <.LCFI62>:
    7fba:	0a 4c       	mov	r12,	r10	;

00007fbc <.Loc.674.1>:
    7fbc:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7fc0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7fc4:	01 00 

00007fc6 <L0>:
  if (hdr.reply) {
    7fc6:	6d 41       	mov.b	@r1,	r13	;
    7fc8:	4c 4d       	mov.b	r13,	r12	;

00007fca <.LVL642>:
    7fca:	6c f3       	and.b	#2,	r12	;r3 As==10
    7fcc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7fce:	21 24       	jz	$+68     	;abs 0x8012

00007fd0 <.Loc.677.1>:
    buffer[0] = buffer[0] & 0x3F;
    7fd0:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7fd4:	00 00 

00007fd6 <.Loc.678.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7fd6:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    7fda:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    7fde:	02 00 

00007fe0 <.Loc.679.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    7fe0:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7fe4:	03 00 

00007fe6 <.Loc.680.1>:
    buffer[4] = bank0p[RegOutputPower];
    7fe6:	da 4c 21 00 	mov.b	33(r12),4(r10)	;0x00021
    7fea:	04 00 

00007fec <.Loc.681.1>:
    if (hdr.crc) {
    7fec:	1d b3       	bit	#1,	r13	;r3 As==01
    7fee:	08 20       	jnz	$+18     	;abs 0x8000

00007ff0 <.Loc.686.1>:
      buffer[1] = 1;
    7ff0:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00007ff4 <.L485>:
    elyCmdSendReply(buffer);
    7ff4:	0c 4a       	mov	r10,	r12	;
    7ff6:	b0 12 58 69 	call	#26968		;#0x6958

00007ffa <.L482>:
}
    7ffa:	21 53       	incd	r1		;
    7ffc:	0a 17       	popm	#1,	r10	;16-bit words
    7ffe:	30 41       	ret			

00008000 <.L487>:
      buffer[1] = 3;
    8000:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    8004:	01 00 

00008006 <.Loc.683.1>:
      crcGenX25(buffer, 7);
    8006:	7d 40 07 00 	mov.b	#7,	r13	;
    800a:	0c 4a       	mov	r10,	r12	;
    800c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008010 <.LVL644>:
    8010:	f1 3f       	jmp	$-28     	;abs 0x7ff4

00008012 <.L483>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8012:	0c 4a       	mov	r10,	r12	;
    8014:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008018 <.LVL645>:
    8018:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000801c <.LVL646>:
}
    801c:	ee 3f       	jmp	$-34     	;abs 0x7ffa

0000801e <set_rx_dev>:
    801e:	5a 15       	pushm	#6,	r10	;16-bit words

00008020 <.LCFI63>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8020:	21 83       	decd	r1		;

00008022 <L0>:
    8022:	08 4c       	mov	r12,	r8	;

00008024 <.Loc.630.1>:
    8024:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8028:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    802c:	01 00 

0000802e <.Loc.631.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    802e:	66 41       	mov.b	@r1,	r6	;
    8030:	66 f3       	and.b	#2,	r6	;r3 As==10
    8032:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    8036:	06 93       	cmp	#0,	r6	;r3 As==00
    8038:	05 24       	jz	$+12     	;abs 0x8044
    803a:	67 42       	mov.b	#4,	r7	;r2 As==10

0000803c <.L489>:
  for (int i = 0; i < 4; i++) {
    803c:	4a 43       	clr.b	r10		;

0000803e <.LBE385>:
  uint32_t dev = 0;
    803e:	05 4a       	mov	r10,	r5	;
    8040:	09 4a       	mov	r10,	r9	;

00008042 <.LBB386>:
  for (int i = 0; i < 4; i++) {
    8042:	14 3c       	jmp	$+42     	;abs 0x806c

00008044 <.L501>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8044:	67 43       	mov.b	#2,	r7	;r3 As==10
    8046:	fa 3f       	jmp	$-10     	;abs 0x803c

00008048 <.L491>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8048:	0c 47       	mov	r7,	r12	;
    804a:	0c 5a       	add	r10,	r12	;
    804c:	0c 58       	add	r8,	r12	;
    804e:	3e 40 03 00 	mov	#3,	r14	;
    8052:	0e 8a       	sub	r10,	r14	;
    8054:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8058:	6c 4c       	mov.b	@r12,	r12	;
    805a:	0d 43       	clr	r13		;
    805c:	0f 43       	clr	r15		;
    805e:	b0 12 98 ac 	call	#-21352	;#0xac98
    8062:	0c d5       	bis	r5,	r12	;
    8064:	0d d9       	bis	r9,	r13	;
    8066:	05 4c       	mov	r12,	r5	;

00008068 <.LVL652>:
    8068:	09 4d       	mov	r13,	r9	;

0000806a <.LVL653>:
  for (int i = 0; i < 4; i++) {
    806a:	1a 53       	inc	r10		;

0000806c <.L490>:
    806c:	7c 40 03 00 	mov.b	#3,	r12	;
    8070:	0c 9a       	cmp	r10,	r12	;
    8072:	ea 37       	jge	$-42     	;abs 0x8048

00008074 <.LBE387>:
  if (dev > RX_DEV_MAX || 
    8074:	35 50 18 7f 	add	#32536,	r5	;#0x7f18

00008078 <.LVL655>:
    8078:	39 63       	addc	#-1,	r9	;r3 As==11
    807a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    807c:	0c 99       	cmp	r9,	r12	;
    807e:	1c 2c       	jc	$+58     	;abs 0x80b8

00008080 <.L504>:
    if (hdr.reply) {
    8080:	06 93       	cmp	#0,	r6	;r3 As==00
    8082:	43 24       	jz	$+136    	;abs 0x810a

00008084 <.Loc.643.1>:
      gen_failure(buffer, hdr.crc);
    8084:	6c 41       	mov.b	@r1,	r12	;
    8086:	5c f3       	and.b	#1,	r12	;r3 As==01

00008088 <.LBB388>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8088:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    808c:	00 00 

0000808e <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    808e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8090:	34 24       	jz	$+106    	;abs 0x80fa
    8092:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008094 <.L495>:
    8094:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008098 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8098:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    809c:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    80a0:	02 00 

000080a2 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    80a2:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    80a6:	03 00 

000080a8 <.Loc.35.1>:
  if (crc) {
    80a8:	0c 93       	cmp	#0,	r12	;r3 As==00
    80aa:	29 20       	jnz	$+84     	;abs 0x80fe

000080ac <.L496>:
      elyCmdSendReply(buffer);
    80ac:	0c 48       	mov	r8,	r12	;
    80ae:	b0 12 58 69 	call	#26968		;#0x6958

000080b2 <.L488>:
}
    80b2:	21 53       	incd	r1		;
    80b4:	55 17       	popm	#6,	r10	;16-bit words
    80b6:	30 41       	ret			

000080b8 <.L505>:
  if (dev > RX_DEV_MAX || 
    80b8:	09 9c       	cmp	r12,	r9	;
    80ba:	04 20       	jnz	$+10     	;abs 0x80c4
    80bc:	3c 40 58 8c 	mov	#-29608,r12	;#0x8c58
    80c0:	0c 95       	cmp	r5,	r12	;
    80c2:	de 2b       	jnc	$-66     	;abs 0x8080

000080c4 <.L492>:
  bank0w[RegRXDevMsb] = buffer[hdr_ext];
    80c4:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    80c8:	07 58       	add	r8,	r7	;

000080ca <.LVL661>:
    80ca:	ec 47 0f 00 	mov.b	@r7,	15(r12)	; 0x000f

000080ce <.Loc.655.1>:
  bank0w[RegRXDevHmb] = buffer[hdr_ext+1];
    80ce:	dc 47 01 00 	mov.b	1(r7),	14(r12)	; 0x000e
    80d2:	0e 00 

000080d4 <.Loc.656.1>:
  bank0w[RegRXDevLmb] = buffer[hdr_ext+2];
    80d4:	dc 47 02 00 	mov.b	2(r7),	13(r12)	; 0x000d
    80d8:	0d 00 

000080da <.Loc.657.1>:
  bank0w[RegRXDevLsb] = buffer[hdr_ext+3];
    80da:	dc 47 03 00 	mov.b	3(r7),	12(r12)	; 0x000c
    80de:	0c 00 

000080e0 <.Loc.660.1>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    80e0:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    80e4:	4d 43       	clr.b	r13		;
    80e6:	b0 12 9c aa 	call	#-21860	;#0xaa9c

000080ea <.LVL662>:
  if (hdr.reply) {
    80ea:	06 93       	cmp	#0,	r6	;r3 As==00
    80ec:	18 20       	jnz	$+50     	;abs 0x811e

000080ee <.Loc.669.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    80ee:	0c 48       	mov	r8,	r12	;
    80f0:	b0 12 4c a8 	call	#-22452	;#0xa84c

000080f4 <.LVL663>:
    80f4:	b0 12 1e a7 	call	#-22754	;#0xa71e

000080f8 <.LVL664>:
    80f8:	dc 3f       	jmp	$-70     	;abs 0x80b2

000080fa <.L502>:
  buffer[1] = (crc ? 2 : 0);
    80fa:	0d 4c       	mov	r12,	r13	;
    80fc:	cb 3f       	jmp	$-104    	;abs 0x8094

000080fe <.L506>:
    crcGenX25(buffer, 6);
    80fe:	7d 40 06 00 	mov.b	#6,	r13	;
    8102:	0c 48       	mov	r8,	r12	;
    8104:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008108 <.LVL666>:
    8108:	d1 3f       	jmp	$-92     	;abs 0x80ac

0000810a <.L494>:
      elyErrorSignal(ErrCmdFailure);
    810a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    810e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008112 <.LVL668>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8112:	0c 48       	mov	r8,	r12	;
    8114:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008118 <.LVL669>:
    8118:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000811c <.LVL670>:
    811c:	ca 3f       	jmp	$-106    	;abs 0x80b2

0000811e <.L507>:
    gen_success(buffer, hdr.crc);
    811e:	6c 41       	mov.b	@r1,	r12	;
    8120:	5c f3       	and.b	#1,	r12	;r3 As==01

00008122 <.LBB392>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8122:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8126:	00 00 

00008128 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8128:	0c 93       	cmp	#0,	r12	;r3 As==00
    812a:	14 24       	jz	$+42     	;abs 0x8154
    812c:	7d 40 03 00 	mov.b	#3,	r13	;

00008130 <.L499>:
    8130:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008134 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8134:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8138:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    813c:	02 00 

0000813e <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    813e:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    8142:	03 00 

00008144 <.Loc.24.1>:
  buffer[4] = 1;
    8144:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

00008148 <.Loc.25.1>:
  if (crc) {
    8148:	0c 93       	cmp	#0,	r12	;r3 As==00
    814a:	06 20       	jnz	$+14     	;abs 0x8158

0000814c <.L500>:
    elyCmdSendReply(buffer);
    814c:	0c 48       	mov	r8,	r12	;
    814e:	b0 12 58 69 	call	#26968		;#0x6958

00008152 <.LVL674>:
    8152:	af 3f       	jmp	$-160    	;abs 0x80b2

00008154 <.L503>:
  buffer[1] = (crc ? 3 : 1);
    8154:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8156:	ec 3f       	jmp	$-38     	;abs 0x8130

00008158 <.L508>:
    crcGenX25(buffer, 7);
    8158:	7d 40 07 00 	mov.b	#7,	r13	;
    815c:	0c 48       	mov	r8,	r12	;
    815e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008162 <.LVL676>:
    8162:	f4 3f       	jmp	$-22     	;abs 0x814c

00008164 <get_rx_dev>:
    8164:	0a 15       	pushm	#1,	r10	;16-bit words

00008166 <.LCFI65>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8166:	21 83       	decd	r1		;

00008168 <.LCFI66>:
    8168:	0a 4c       	mov	r12,	r10	;

0000816a <.Loc.604.1>:
    816a:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    816e:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8172:	01 00 

00008174 <.Loc.606.1>:
  if (hdr.reply) {
    8174:	6b 41       	mov.b	@r1,	r11	;

00008176 <L0>:
    8176:	4c 4b       	mov.b	r11,	r12	;

00008178 <.LVL678>:
    8178:	6c f3       	and.b	#2,	r12	;r3 As==10
    817a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    817c:	2e 24       	jz	$+94     	;abs 0x81da

0000817e <.Loc.607.1>:
    buffer[0] = buffer[0] & 0x3F;
    817e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8182:	00 00 

00008184 <.Loc.608.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8184:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    8188:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    818c:	02 00 

0000818e <.Loc.609.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    818e:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    8192:	03 00 

00008194 <.LBB396>:
    for (int i = 0; i < 4; i++) {
    8194:	4c 43       	clr.b	r12		;
    8196:	0a 3c       	jmp	$+22     	;abs 0x81ac

00008198 <.L512>:
      buffer[i + 4] = bank0p[RegRXDevMsb - i];
    8198:	0d 4c       	mov	r12,	r13	;
    819a:	2d 52       	add	#4,	r13	;r2 As==10
    819c:	0d 5a       	add	r10,	r13	;
    819e:	3e 40 0f 00 	mov	#15,	r14	;#0x000f
    81a2:	0e 8c       	sub	r12,	r14	;
    81a4:	0e 5f       	add	r15,	r14	;
    81a6:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

000081aa <.Loc.611.1>:
    for (int i = 0; i < 4; i++) {
    81aa:	1c 53       	inc	r12		;

000081ac <.L511>:
    81ac:	7d 40 03 00 	mov.b	#3,	r13	;
    81b0:	0d 9c       	cmp	r12,	r13	;
    81b2:	f2 37       	jge	$-26     	;abs 0x8198

000081b4 <.LBE396>:
    if (hdr.crc) {
    81b4:	1b b3       	bit	#1,	r11	;r3 As==01
    81b6:	08 20       	jnz	$+18     	;abs 0x81c8

000081b8 <.Loc.619.1>:
      buffer[1] = 4;
    81b8:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

000081bc <.L514>:
    elyCmdSendReply(buffer);
    81bc:	0c 4a       	mov	r10,	r12	;
    81be:	b0 12 58 69 	call	#26968		;#0x6958

000081c2 <.L509>:
}
    81c2:	21 53       	incd	r1		;
    81c4:	0a 17       	popm	#1,	r10	;16-bit words
    81c6:	30 41       	ret			

000081c8 <.L516>:
      buffer[1] = 6;
    81c8:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    81cc:	01 00 

000081ce <.Loc.616.1>:
      crcGenX25(buffer, 10);
    81ce:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    81d2:	0c 4a       	mov	r10,	r12	;

000081d4 <.LVL685>:
    81d4:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000081d8 <.LVL686>:
    81d8:	f1 3f       	jmp	$-28     	;abs 0x81bc

000081da <.L510>:
    elyNLFreeBuffer(elyNLPack(buffer));
    81da:	0c 4a       	mov	r10,	r12	;
    81dc:	b0 12 4c a8 	call	#-22452	;#0xa84c

000081e0 <.LVL687>:
    81e0:	b0 12 1e a7 	call	#-22754	;#0xa71e

000081e4 <.LVL688>:
}
    81e4:	ee 3f       	jmp	$-34     	;abs 0x81c2

000081e6 <set_tx_dev>:
    81e6:	5a 15       	pushm	#6,	r10	;16-bit words

000081e8 <.LCFI67>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    81e8:	21 83       	decd	r1		;

000081ea <.LCFI68>:
    81ea:	08 4c       	mov	r12,	r8	;

000081ec <L0>:
    81ec:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    81f0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    81f4:	01 00 

000081f6 <.Loc.561.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    81f6:	66 41       	mov.b	@r1,	r6	;
    81f8:	66 f3       	and.b	#2,	r6	;r3 As==10
    81fa:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    81fe:	06 93       	cmp	#0,	r6	;r3 As==00
    8200:	05 24       	jz	$+12     	;abs 0x820c
    8202:	67 42       	mov.b	#4,	r7	;r2 As==10

00008204 <.L518>:
  for (int i = 0; i < 4; i++) {
    8204:	4a 43       	clr.b	r10		;

00008206 <.LBE402>:
  uint32_t dev = 0;
    8206:	05 4a       	mov	r10,	r5	;
    8208:	09 4a       	mov	r10,	r9	;

0000820a <.LBB403>:
  for (int i = 0; i < 4; i++) {
    820a:	14 3c       	jmp	$+42     	;abs 0x8234

0000820c <.L530>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    820c:	67 43       	mov.b	#2,	r7	;r3 As==10
    820e:	fa 3f       	jmp	$-10     	;abs 0x8204

00008210 <.L520>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8210:	0c 47       	mov	r7,	r12	;
    8212:	0c 5a       	add	r10,	r12	;
    8214:	0c 58       	add	r8,	r12	;
    8216:	3e 40 03 00 	mov	#3,	r14	;
    821a:	0e 8a       	sub	r10,	r14	;
    821c:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8220:	6c 4c       	mov.b	@r12,	r12	;
    8222:	0d 43       	clr	r13		;
    8224:	0f 43       	clr	r15		;
    8226:	b0 12 98 ac 	call	#-21352	;#0xac98
    822a:	0c d5       	bis	r5,	r12	;
    822c:	0d d9       	bis	r9,	r13	;
    822e:	05 4c       	mov	r12,	r5	;

00008230 <.LVL694>:
    8230:	09 4d       	mov	r13,	r9	;

00008232 <.LVL695>:
  for (int i = 0; i < 4; i++) {
    8232:	1a 53       	inc	r10		;

00008234 <.L519>:
    8234:	7c 40 03 00 	mov.b	#3,	r12	;
    8238:	0c 9a       	cmp	r10,	r12	;
    823a:	ea 37       	jge	$-42     	;abs 0x8210

0000823c <.LBE404>:
  if (dev > TX_DEV_MAX || 
    823c:	35 50 a8 fd 	add	#-600,	r5	;#0xfda8

00008240 <.LVL697>:
    8240:	39 63       	addc	#-1,	r9	;r3 As==11
    8242:	0c 99       	cmp	r9,	r12	;
    8244:	1c 2c       	jc	$+58     	;abs 0x827e

00008246 <.L533>:
    if (hdr.reply) {
    8246:	06 93       	cmp	#0,	r6	;r3 As==00
    8248:	43 24       	jz	$+136    	;abs 0x82d0

0000824a <.Loc.573.1>:
      gen_failure(buffer, hdr.crc);
    824a:	6c 41       	mov.b	@r1,	r12	;
    824c:	5c f3       	and.b	#1,	r12	;r3 As==01

0000824e <.LBB405>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    824e:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8252:	00 00 

00008254 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8254:	0c 93       	cmp	#0,	r12	;r3 As==00
    8256:	34 24       	jz	$+106    	;abs 0x82c0
    8258:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000825a <.L524>:
    825a:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

0000825e <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    825e:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8262:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    8266:	02 00 

00008268 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8268:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    826c:	03 00 

0000826e <.Loc.35.1>:
  if (crc) {
    826e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8270:	29 20       	jnz	$+84     	;abs 0x82c4

00008272 <.L525>:
      elyCmdSendReply(buffer);
    8272:	0c 48       	mov	r8,	r12	;
    8274:	b0 12 58 69 	call	#26968		;#0x6958

00008278 <.L517>:
}
    8278:	21 53       	incd	r1		;
    827a:	55 17       	popm	#6,	r10	;16-bit words
    827c:	30 41       	ret			

0000827e <.L534>:
  if (dev > TX_DEV_MAX || 
    827e:	09 9c       	cmp	r12,	r9	;
    8280:	04 20       	jnz	$+10     	;abs 0x828a
    8282:	3c 40 e8 0a 	mov	#2792,	r12	;#0x0ae8
    8286:	0c 95       	cmp	r5,	r12	;
    8288:	de 2b       	jnc	$-66     	;abs 0x8246

0000828a <.L521>:
  bank0w[RegTXDevMsb] = buffer[hdr_ext];
    828a:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    828e:	07 58       	add	r8,	r7	;

00008290 <.LVL703>:
    8290:	ec 47 0b 00 	mov.b	@r7,	11(r12)	; 0x000b

00008294 <.Loc.585.1>:
  bank0w[RegTXDevHmb] = buffer[hdr_ext+1];
    8294:	dc 47 01 00 	mov.b	1(r7),	10(r12)	; 0x000a
    8298:	0a 00 

0000829a <.Loc.586.1>:
  bank0w[RegTXDevLmb] = buffer[hdr_ext+2];
    829a:	dc 47 02 00 	mov.b	2(r7),	9(r12)	;
    829e:	09 00 

000082a0 <.Loc.587.1>:
  bank0w[RegTXDevLsb] = buffer[hdr_ext+3];
    82a0:	dc 47 03 00 	mov.b	3(r7),	8(r12)	;
    82a4:	08 00 

000082a6 <.Loc.590.1>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    82a6:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    82aa:	4d 43       	clr.b	r13		;
    82ac:	b0 12 9c aa 	call	#-21860	;#0xaa9c

000082b0 <.LVL704>:
  if (hdr.reply) {
    82b0:	06 93       	cmp	#0,	r6	;r3 As==00
    82b2:	18 20       	jnz	$+50     	;abs 0x82e4

000082b4 <.Loc.599.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    82b4:	0c 48       	mov	r8,	r12	;
    82b6:	b0 12 4c a8 	call	#-22452	;#0xa84c

000082ba <.LVL705>:
    82ba:	b0 12 1e a7 	call	#-22754	;#0xa71e

000082be <.LVL706>:
    82be:	dc 3f       	jmp	$-70     	;abs 0x8278

000082c0 <.L531>:
  buffer[1] = (crc ? 2 : 0);
    82c0:	0d 4c       	mov	r12,	r13	;
    82c2:	cb 3f       	jmp	$-104    	;abs 0x825a

000082c4 <.L535>:
    crcGenX25(buffer, 6);
    82c4:	7d 40 06 00 	mov.b	#6,	r13	;
    82c8:	0c 48       	mov	r8,	r12	;
    82ca:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000082ce <.LVL708>:
    82ce:	d1 3f       	jmp	$-92     	;abs 0x8272

000082d0 <.L523>:
      elyErrorSignal(ErrCmdFailure);
    82d0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    82d4:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000082d8 <.LVL710>:
      elyNLFreeBuffer(elyNLPack(buffer));
    82d8:	0c 48       	mov	r8,	r12	;
    82da:	b0 12 4c a8 	call	#-22452	;#0xa84c

000082de <.LVL711>:
    82de:	b0 12 1e a7 	call	#-22754	;#0xa71e

000082e2 <.LVL712>:
    82e2:	ca 3f       	jmp	$-106    	;abs 0x8278

000082e4 <.L536>:
    gen_success(buffer, hdr.crc);
    82e4:	6c 41       	mov.b	@r1,	r12	;
    82e6:	5c f3       	and.b	#1,	r12	;r3 As==01

000082e8 <.LBB409>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    82e8:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    82ec:	00 00 

000082ee <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    82ee:	0c 93       	cmp	#0,	r12	;r3 As==00
    82f0:	14 24       	jz	$+42     	;abs 0x831a
    82f2:	7d 40 03 00 	mov.b	#3,	r13	;

000082f6 <.L528>:
    82f6:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000082fa <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    82fa:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    82fe:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    8302:	02 00 

00008304 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8304:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    8308:	03 00 

0000830a <.Loc.24.1>:
  buffer[4] = 1;
    830a:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

0000830e <.Loc.25.1>:
  if (crc) {
    830e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8310:	06 20       	jnz	$+14     	;abs 0x831e

00008312 <.L529>:
    elyCmdSendReply(buffer);
    8312:	0c 48       	mov	r8,	r12	;
    8314:	b0 12 58 69 	call	#26968		;#0x6958

00008318 <.LVL716>:
    8318:	af 3f       	jmp	$-160    	;abs 0x8278

0000831a <.L532>:
  buffer[1] = (crc ? 3 : 1);
    831a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    831c:	ec 3f       	jmp	$-38     	;abs 0x82f6

0000831e <.L537>:
    crcGenX25(buffer, 7);
    831e:	7d 40 07 00 	mov.b	#7,	r13	;
    8322:	0c 48       	mov	r8,	r12	;
    8324:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008328 <.LVL718>:
    8328:	f4 3f       	jmp	$-22     	;abs 0x8312

0000832a <get_tx_dev>:
    832a:	0a 15       	pushm	#1,	r10	;16-bit words

0000832c <.LCFI69>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    832c:	21 83       	decd	r1		;

0000832e <.LCFI70>:
    832e:	0a 4c       	mov	r12,	r10	;

00008330 <.Loc.534.1>:
    8330:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8334:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8338:	01 00 

0000833a <.Loc.536.1>:
  if (hdr.reply) {
    833a:	6b 41       	mov.b	@r1,	r11	;

0000833c <L0>:
    833c:	4c 4b       	mov.b	r11,	r12	;

0000833e <.LVL720>:
    833e:	6c f3       	and.b	#2,	r12	;r3 As==10
    8340:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8342:	2e 24       	jz	$+94     	;abs 0x83a0

00008344 <.Loc.537.1>:
    buffer[0] = buffer[0] & 0x3F;
    8344:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8348:	00 00 

0000834a <.Loc.538.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    834a:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    834e:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    8352:	02 00 

00008354 <.Loc.539.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8354:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    8358:	03 00 

0000835a <.LBB413>:
    for (int i = 0; i < 4; i++) {
    835a:	4c 43       	clr.b	r12		;
    835c:	0a 3c       	jmp	$+22     	;abs 0x8372

0000835e <.L541>:
      buffer[i + 4] = bank0p[RegTXDevMsb - i];
    835e:	0d 4c       	mov	r12,	r13	;
    8360:	2d 52       	add	#4,	r13	;r2 As==10
    8362:	0d 5a       	add	r10,	r13	;
    8364:	3e 40 0b 00 	mov	#11,	r14	;#0x000b
    8368:	0e 8c       	sub	r12,	r14	;
    836a:	0e 5f       	add	r15,	r14	;
    836c:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008370 <.Loc.541.1>:
    for (int i = 0; i < 4; i++) {
    8370:	1c 53       	inc	r12		;

00008372 <.L540>:
    8372:	7d 40 03 00 	mov.b	#3,	r13	;
    8376:	0d 9c       	cmp	r12,	r13	;
    8378:	f2 37       	jge	$-26     	;abs 0x835e

0000837a <.LBE413>:
    if (hdr.crc) {
    837a:	1b b3       	bit	#1,	r11	;r3 As==01
    837c:	08 20       	jnz	$+18     	;abs 0x838e

0000837e <.Loc.549.1>:
      buffer[1] = 4;
    837e:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

00008382 <.L543>:
    elyCmdSendReply(buffer);
    8382:	0c 4a       	mov	r10,	r12	;
    8384:	b0 12 58 69 	call	#26968		;#0x6958

00008388 <.L538>:
}
    8388:	21 53       	incd	r1		;
    838a:	0a 17       	popm	#1,	r10	;16-bit words
    838c:	30 41       	ret			

0000838e <.L545>:
      buffer[1] = 6;
    838e:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8392:	01 00 

00008394 <.Loc.546.1>:
      crcGenX25(buffer, 10);
    8394:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8398:	0c 4a       	mov	r10,	r12	;

0000839a <.LVL727>:
    839a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000839e <.LVL728>:
    839e:	f1 3f       	jmp	$-28     	;abs 0x8382

000083a0 <.L539>:
    elyNLFreeBuffer(elyNLPack(buffer));
    83a0:	0c 4a       	mov	r10,	r12	;
    83a2:	b0 12 4c a8 	call	#-22452	;#0xa84c

000083a6 <.LVL729>:
    83a6:	b0 12 1e a7 	call	#-22754	;#0xa71e

000083aa <.LVL730>:
}
    83aa:	ee 3f       	jmp	$-34     	;abs 0x8388

000083ac <set_rx_br>:
    83ac:	5a 15       	pushm	#6,	r10	;16-bit words

000083ae <.LCFI71>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83ae:	21 83       	decd	r1		;

000083b0 <.LCFI72>:
    83b0:	08 4c       	mov	r12,	r8	;

000083b2 <L0>:
    83b2:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    83b6:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    83ba:	01 00 

000083bc <.Loc.491.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    83bc:	66 41       	mov.b	@r1,	r6	;
    83be:	66 f3       	and.b	#2,	r6	;r3 As==10
    83c0:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    83c4:	06 93       	cmp	#0,	r6	;r3 As==00
    83c6:	05 24       	jz	$+12     	;abs 0x83d2
    83c8:	67 42       	mov.b	#4,	r7	;r2 As==10

000083ca <.L547>:
  for (int i = 0; i < 4; i++) {
    83ca:	4a 43       	clr.b	r10		;

000083cc <.LBE419>:
  uint32_t br = 0;
    83cc:	05 4a       	mov	r10,	r5	;
    83ce:	09 4a       	mov	r10,	r9	;

000083d0 <.LBB420>:
  for (int i = 0; i < 4; i++) {
    83d0:	14 3c       	jmp	$+42     	;abs 0x83fa

000083d2 <.L559>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    83d2:	67 43       	mov.b	#2,	r7	;r3 As==10
    83d4:	fa 3f       	jmp	$-10     	;abs 0x83ca

000083d6 <.L549>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    83d6:	0c 47       	mov	r7,	r12	;
    83d8:	0c 5a       	add	r10,	r12	;
    83da:	0c 58       	add	r8,	r12	;
    83dc:	3e 40 03 00 	mov	#3,	r14	;
    83e0:	0e 8a       	sub	r10,	r14	;
    83e2:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    83e6:	6c 4c       	mov.b	@r12,	r12	;
    83e8:	0d 43       	clr	r13		;
    83ea:	0f 43       	clr	r15		;
    83ec:	b0 12 98 ac 	call	#-21352	;#0xac98
    83f0:	0c d5       	bis	r5,	r12	;
    83f2:	0d d9       	bis	r9,	r13	;
    83f4:	05 4c       	mov	r12,	r5	;

000083f6 <.LVL736>:
    83f6:	09 4d       	mov	r13,	r9	;

000083f8 <.LVL737>:
  for (int i = 0; i < 4; i++) {
    83f8:	1a 53       	inc	r10		;

000083fa <.L548>:
    83fa:	7c 40 03 00 	mov.b	#3,	r12	;
    83fe:	0c 9a       	cmp	r10,	r12	;
    8400:	ea 37       	jge	$-42     	;abs 0x83d6

00008402 <.LBE421>:
  if (br > RX_BR_MAX || 
    8402:	35 50 f4 fc 	add	#-780,	r5	;#0xfcf4

00008406 <.LVL739>:
    8406:	39 63       	addc	#-1,	r9	;r3 As==11
    8408:	6c 43       	mov.b	#2,	r12	;r3 As==10
    840a:	0c 99       	cmp	r9,	r12	;
    840c:	1c 2c       	jc	$+58     	;abs 0x8446

0000840e <.L562>:
    if (hdr.reply) {
    840e:	06 93       	cmp	#0,	r6	;r3 As==00
    8410:	42 24       	jz	$+134    	;abs 0x8496

00008412 <.Loc.503.1>:
      gen_failure(buffer, hdr.crc);
    8412:	6c 41       	mov.b	@r1,	r12	;
    8414:	5c f3       	and.b	#1,	r12	;r3 As==01

00008416 <.LBB422>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8416:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    841a:	00 00 

0000841c <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    841c:	0c 93       	cmp	#0,	r12	;r3 As==00
    841e:	33 24       	jz	$+104    	;abs 0x8486
    8420:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008422 <.L553>:
    8422:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008426 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8426:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    842a:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    842e:	02 00 

00008430 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8430:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    8434:	03 00 

00008436 <.Loc.35.1>:
  if (crc) {
    8436:	0c 93       	cmp	#0,	r12	;r3 As==00
    8438:	28 20       	jnz	$+82     	;abs 0x848a

0000843a <.L554>:
      elyCmdSendReply(buffer);
    843a:	0c 48       	mov	r8,	r12	;
    843c:	b0 12 58 69 	call	#26968		;#0x6958

00008440 <.L546>:
}
    8440:	21 53       	incd	r1		;
    8442:	55 17       	popm	#6,	r10	;16-bit words
    8444:	30 41       	ret			

00008446 <.L563>:
  if (br > RX_BR_MAX || 
    8446:	09 9c       	cmp	r12,	r9	;
    8448:	04 20       	jnz	$+10     	;abs 0x8452
    844a:	3c 40 e4 46 	mov	#18148,	r12	;#0x46e4
    844e:	0c 95       	cmp	r5,	r12	;
    8450:	de 2b       	jnc	$-66     	;abs 0x840e

00008452 <.L550>:
  bank0w[RegRXBRMsb] = buffer[hdr_ext];
    8452:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    8456:	07 58       	add	r8,	r7	;

00008458 <.LVL745>:
    8458:	ec 47 1f 00 	mov.b	@r7,	31(r12)	; 0x001f

0000845c <.Loc.515.1>:
  bank0w[RegRXBRHmb] = buffer[hdr_ext+1];
    845c:	dc 47 01 00 	mov.b	1(r7),	30(r12)	; 0x001e
    8460:	1e 00 

00008462 <.Loc.516.1>:
  bank0w[RegRXBRLmb] = buffer[hdr_ext+2];
    8462:	dc 47 02 00 	mov.b	2(r7),	29(r12)	; 0x001d
    8466:	1d 00 

00008468 <.Loc.517.1>:
  bank0w[RegRXBRLsb] = buffer[hdr_ext+3];
    8468:	dc 47 03 00 	mov.b	3(r7),	28(r12)	; 0x001c
    846c:	1c 00 

0000846e <.Loc.520.1>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    846e:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8470:	4d 43       	clr.b	r13		;
    8472:	b0 12 9c aa 	call	#-21860	;#0xaa9c

00008476 <.LVL746>:
  if (hdr.reply) {
    8476:	06 93       	cmp	#0,	r6	;r3 As==00
    8478:	18 20       	jnz	$+50     	;abs 0x84aa

0000847a <.Loc.529.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    847a:	0c 48       	mov	r8,	r12	;
    847c:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008480 <.LVL747>:
    8480:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008484 <.LVL748>:
    8484:	dd 3f       	jmp	$-68     	;abs 0x8440

00008486 <.L560>:
  buffer[1] = (crc ? 2 : 0);
    8486:	0d 4c       	mov	r12,	r13	;
    8488:	cc 3f       	jmp	$-102    	;abs 0x8422

0000848a <.L564>:
    crcGenX25(buffer, 6);
    848a:	7d 40 06 00 	mov.b	#6,	r13	;
    848e:	0c 48       	mov	r8,	r12	;
    8490:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008494 <.LVL750>:
    8494:	d2 3f       	jmp	$-90     	;abs 0x843a

00008496 <.L552>:
      elyErrorSignal(ErrCmdFailure);
    8496:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    849a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000849e <.LVL752>:
      elyNLFreeBuffer(elyNLPack(buffer));
    849e:	0c 48       	mov	r8,	r12	;
    84a0:	b0 12 4c a8 	call	#-22452	;#0xa84c

000084a4 <.LVL753>:
    84a4:	b0 12 1e a7 	call	#-22754	;#0xa71e

000084a8 <.LVL754>:
    84a8:	cb 3f       	jmp	$-104    	;abs 0x8440

000084aa <.L565>:
    gen_success(buffer, hdr.crc);
    84aa:	6c 41       	mov.b	@r1,	r12	;
    84ac:	5c f3       	and.b	#1,	r12	;r3 As==01

000084ae <.LBB426>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    84ae:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    84b2:	00 00 

000084b4 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    84b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    84b6:	14 24       	jz	$+42     	;abs 0x84e0
    84b8:	7d 40 03 00 	mov.b	#3,	r13	;

000084bc <.L557>:
    84bc:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000084c0 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    84c0:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    84c4:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    84c8:	02 00 

000084ca <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    84ca:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    84ce:	03 00 

000084d0 <.Loc.24.1>:
  buffer[4] = 1;
    84d0:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

000084d4 <.Loc.25.1>:
  if (crc) {
    84d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    84d6:	06 20       	jnz	$+14     	;abs 0x84e4

000084d8 <.L558>:
    elyCmdSendReply(buffer);
    84d8:	0c 48       	mov	r8,	r12	;
    84da:	b0 12 58 69 	call	#26968		;#0x6958

000084de <.LVL758>:
    84de:	b0 3f       	jmp	$-158    	;abs 0x8440

000084e0 <.L561>:
  buffer[1] = (crc ? 3 : 1);
    84e0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    84e2:	ec 3f       	jmp	$-38     	;abs 0x84bc

000084e4 <.L566>:
    crcGenX25(buffer, 7);
    84e4:	7d 40 07 00 	mov.b	#7,	r13	;
    84e8:	0c 48       	mov	r8,	r12	;
    84ea:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000084ee <.LVL760>:
    84ee:	f4 3f       	jmp	$-22     	;abs 0x84d8

000084f0 <get_rx_br>:
    84f0:	0a 15       	pushm	#1,	r10	;16-bit words

000084f2 <.LCFI73>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    84f2:	21 83       	decd	r1		;

000084f4 <.LCFI74>:
    84f4:	0a 4c       	mov	r12,	r10	;

000084f6 <.Loc.464.1>:
    84f6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    84fa:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    84fe:	01 00 

00008500 <.Loc.466.1>:
  if (hdr.reply) {
    8500:	6b 41       	mov.b	@r1,	r11	;

00008502 <L0>:
    8502:	4c 4b       	mov.b	r11,	r12	;

00008504 <.LVL762>:
    8504:	6c f3       	and.b	#2,	r12	;r3 As==10
    8506:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8508:	2e 24       	jz	$+94     	;abs 0x8566

0000850a <.Loc.467.1>:
    buffer[0] = buffer[0] & 0x3F;
    850a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    850e:	00 00 

00008510 <.Loc.468.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8510:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    8514:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    8518:	02 00 

0000851a <.Loc.469.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    851a:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    851e:	03 00 

00008520 <.LBB430>:
    for (int i = 0; i < 4; i++) {
    8520:	4c 43       	clr.b	r12		;
    8522:	0a 3c       	jmp	$+22     	;abs 0x8538

00008524 <.L570>:
      buffer[i + 4] = bank0p[RegRXBRMsb - i];
    8524:	0d 4c       	mov	r12,	r13	;
    8526:	2d 52       	add	#4,	r13	;r2 As==10
    8528:	0d 5a       	add	r10,	r13	;
    852a:	3e 40 1f 00 	mov	#31,	r14	;#0x001f
    852e:	0e 8c       	sub	r12,	r14	;
    8530:	0e 5f       	add	r15,	r14	;
    8532:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008536 <.Loc.471.1>:
    for (int i = 0; i < 4; i++) {
    8536:	1c 53       	inc	r12		;

00008538 <.L569>:
    8538:	7d 40 03 00 	mov.b	#3,	r13	;
    853c:	0d 9c       	cmp	r12,	r13	;
    853e:	f2 37       	jge	$-26     	;abs 0x8524

00008540 <.LBE430>:
    if (hdr.crc) {
    8540:	1b b3       	bit	#1,	r11	;r3 As==01
    8542:	08 20       	jnz	$+18     	;abs 0x8554

00008544 <.Loc.479.1>:
      buffer[1] = 4;
    8544:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

00008548 <.L572>:
    elyCmdSendReply(buffer);
    8548:	0c 4a       	mov	r10,	r12	;
    854a:	b0 12 58 69 	call	#26968		;#0x6958

0000854e <.L567>:
}
    854e:	21 53       	incd	r1		;
    8550:	0a 17       	popm	#1,	r10	;16-bit words
    8552:	30 41       	ret			

00008554 <.L574>:
      buffer[1] = 6;
    8554:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8558:	01 00 

0000855a <.Loc.476.1>:
      crcGenX25(buffer, 10);
    855a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    855e:	0c 4a       	mov	r10,	r12	;

00008560 <.LVL769>:
    8560:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008564 <.LVL770>:
    8564:	f1 3f       	jmp	$-28     	;abs 0x8548

00008566 <.L568>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8566:	0c 4a       	mov	r10,	r12	;
    8568:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000856c <.LVL771>:
    856c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008570 <.LVL772>:
}
    8570:	ee 3f       	jmp	$-34     	;abs 0x854e

00008572 <set_tx_br>:
    8572:	5a 15       	pushm	#6,	r10	;16-bit words

00008574 <.LCFI75>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8574:	21 83       	decd	r1		;

00008576 <.LCFI76>:
    8576:	08 4c       	mov	r12,	r8	;

00008578 <L0>:
    8578:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    857c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8580:	01 00 

00008582 <.Loc.421.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8582:	66 41       	mov.b	@r1,	r6	;
    8584:	66 f3       	and.b	#2,	r6	;r3 As==10
    8586:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    858a:	06 93       	cmp	#0,	r6	;r3 As==00
    858c:	05 24       	jz	$+12     	;abs 0x8598
    858e:	67 42       	mov.b	#4,	r7	;r2 As==10

00008590 <.L576>:
  for (int i = 0; i < 4; i++) {
    8590:	4a 43       	clr.b	r10		;

00008592 <.LBE436>:
  uint32_t br = 0;
    8592:	05 4a       	mov	r10,	r5	;
    8594:	09 4a       	mov	r10,	r9	;

00008596 <.LBB437>:
  for (int i = 0; i < 4; i++) {
    8596:	14 3c       	jmp	$+42     	;abs 0x85c0

00008598 <.L588>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8598:	67 43       	mov.b	#2,	r7	;r3 As==10
    859a:	fa 3f       	jmp	$-10     	;abs 0x8590

0000859c <.L578>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    859c:	0c 47       	mov	r7,	r12	;
    859e:	0c 5a       	add	r10,	r12	;
    85a0:	0c 58       	add	r8,	r12	;
    85a2:	3e 40 03 00 	mov	#3,	r14	;
    85a6:	0e 8a       	sub	r10,	r14	;
    85a8:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    85ac:	6c 4c       	mov.b	@r12,	r12	;
    85ae:	0d 43       	clr	r13		;
    85b0:	0f 43       	clr	r15		;
    85b2:	b0 12 98 ac 	call	#-21352	;#0xac98
    85b6:	0c d5       	bis	r5,	r12	;
    85b8:	0d d9       	bis	r9,	r13	;
    85ba:	05 4c       	mov	r12,	r5	;

000085bc <.LVL778>:
    85bc:	09 4d       	mov	r13,	r9	;

000085be <.LVL779>:
  for (int i = 0; i < 4; i++) {
    85be:	1a 53       	inc	r10		;

000085c0 <.L577>:
    85c0:	7c 40 03 00 	mov.b	#3,	r12	;
    85c4:	0c 9a       	cmp	r10,	r12	;
    85c6:	ea 37       	jge	$-42     	;abs 0x859c

000085c8 <.LBE438>:
  if (br > TX_BR_MAX || 
    85c8:	35 50 50 fb 	add	#-1200,	r5	;#0xfb50

000085cc <.LVL781>:
    85cc:	39 63       	addc	#-1,	r9	;r3 As==11
    85ce:	6c 42       	mov.b	#4,	r12	;r2 As==10
    85d0:	0c 99       	cmp	r9,	r12	;
    85d2:	1c 2c       	jc	$+58     	;abs 0x860c

000085d4 <.L591>:
    if (hdr.reply) {
    85d4:	06 93       	cmp	#0,	r6	;r3 As==00
    85d6:	42 24       	jz	$+134    	;abs 0x865c

000085d8 <.Loc.433.1>:
      gen_failure(buffer, hdr.crc);
    85d8:	6c 41       	mov.b	@r1,	r12	;
    85da:	5c f3       	and.b	#1,	r12	;r3 As==01

000085dc <.LBB439>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    85dc:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    85e0:	00 00 

000085e2 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    85e2:	0c 93       	cmp	#0,	r12	;r3 As==00
    85e4:	33 24       	jz	$+104    	;abs 0x864c
    85e6:	6d 43       	mov.b	#2,	r13	;r3 As==10

000085e8 <.L582>:
    85e8:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000085ec <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    85ec:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    85f0:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    85f4:	02 00 

000085f6 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    85f6:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    85fa:	03 00 

000085fc <.Loc.35.1>:
  if (crc) {
    85fc:	0c 93       	cmp	#0,	r12	;r3 As==00
    85fe:	28 20       	jnz	$+82     	;abs 0x8650

00008600 <.L583>:
      elyCmdSendReply(buffer);
    8600:	0c 48       	mov	r8,	r12	;
    8602:	b0 12 58 69 	call	#26968		;#0x6958

00008606 <.L575>:
}
    8606:	21 53       	incd	r1		;
    8608:	55 17       	popm	#6,	r10	;16-bit words
    860a:	30 41       	ret			

0000860c <.L592>:
  if (br > TX_BR_MAX || 
    860c:	09 9c       	cmp	r12,	r9	;
    860e:	04 20       	jnz	$+10     	;abs 0x8618
    8610:	3c 40 30 8f 	mov	#-28880,r12	;#0x8f30
    8614:	0c 95       	cmp	r5,	r12	;
    8616:	de 2b       	jnc	$-66     	;abs 0x85d4

00008618 <.L579>:
  bank0w[RegTXBRMsb] = buffer[hdr_ext];
    8618:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    861c:	07 58       	add	r8,	r7	;

0000861e <.LVL787>:
    861e:	ec 47 1b 00 	mov.b	@r7,	27(r12)	; 0x001b

00008622 <.Loc.445.1>:
  bank0w[RegTXBRHmb] = buffer[hdr_ext+1];
    8622:	dc 47 01 00 	mov.b	1(r7),	26(r12)	; 0x001a
    8626:	1a 00 

00008628 <.Loc.446.1>:
  bank0w[RegTXBRLmb] = buffer[hdr_ext+2];
    8628:	dc 47 02 00 	mov.b	2(r7),	25(r12)	; 0x0019
    862c:	19 00 

0000862e <.Loc.447.1>:
  bank0w[RegTXBRLsb] = buffer[hdr_ext+3];
    862e:	dc 47 03 00 	mov.b	3(r7),	24(r12)	; 0x0018
    8632:	18 00 

00008634 <.Loc.450.1>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    8634:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8636:	4d 43       	clr.b	r13		;
    8638:	b0 12 9c aa 	call	#-21860	;#0xaa9c

0000863c <.LVL788>:
  if (hdr.reply) {
    863c:	06 93       	cmp	#0,	r6	;r3 As==00
    863e:	18 20       	jnz	$+50     	;abs 0x8670

00008640 <.Loc.459.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8640:	0c 48       	mov	r8,	r12	;
    8642:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008646 <.LVL789>:
    8646:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000864a <.LVL790>:
    864a:	dd 3f       	jmp	$-68     	;abs 0x8606

0000864c <.L589>:
  buffer[1] = (crc ? 2 : 0);
    864c:	0d 4c       	mov	r12,	r13	;
    864e:	cc 3f       	jmp	$-102    	;abs 0x85e8

00008650 <.L593>:
    crcGenX25(buffer, 6);
    8650:	7d 40 06 00 	mov.b	#6,	r13	;
    8654:	0c 48       	mov	r8,	r12	;
    8656:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000865a <.LVL792>:
    865a:	d2 3f       	jmp	$-90     	;abs 0x8600

0000865c <.L581>:
      elyErrorSignal(ErrCmdFailure);
    865c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8660:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008664 <.LVL794>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8664:	0c 48       	mov	r8,	r12	;
    8666:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000866a <.LVL795>:
    866a:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000866e <.LVL796>:
    866e:	cb 3f       	jmp	$-104    	;abs 0x8606

00008670 <.L594>:
    gen_success(buffer, hdr.crc);
    8670:	6c 41       	mov.b	@r1,	r12	;
    8672:	5c f3       	and.b	#1,	r12	;r3 As==01

00008674 <.LBB443>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8674:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8678:	00 00 

0000867a <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    867a:	0c 93       	cmp	#0,	r12	;r3 As==00
    867c:	14 24       	jz	$+42     	;abs 0x86a6
    867e:	7d 40 03 00 	mov.b	#3,	r13	;

00008682 <.L586>:
    8682:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008686 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8686:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    868a:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    868e:	02 00 

00008690 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8690:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    8694:	03 00 

00008696 <.Loc.24.1>:
  buffer[4] = 1;
    8696:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

0000869a <.Loc.25.1>:
  if (crc) {
    869a:	0c 93       	cmp	#0,	r12	;r3 As==00
    869c:	06 20       	jnz	$+14     	;abs 0x86aa

0000869e <.L587>:
    elyCmdSendReply(buffer);
    869e:	0c 48       	mov	r8,	r12	;
    86a0:	b0 12 58 69 	call	#26968		;#0x6958

000086a4 <.LVL800>:
    86a4:	b0 3f       	jmp	$-158    	;abs 0x8606

000086a6 <.L590>:
  buffer[1] = (crc ? 3 : 1);
    86a6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    86a8:	ec 3f       	jmp	$-38     	;abs 0x8682

000086aa <.L595>:
    crcGenX25(buffer, 7);
    86aa:	7d 40 07 00 	mov.b	#7,	r13	;
    86ae:	0c 48       	mov	r8,	r12	;
    86b0:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000086b4 <.LVL802>:
    86b4:	f4 3f       	jmp	$-22     	;abs 0x869e

000086b6 <get_tx_br>:
    86b6:	0a 15       	pushm	#1,	r10	;16-bit words

000086b8 <.LCFI77>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    86b8:	21 83       	decd	r1		;

000086ba <.LCFI78>:
    86ba:	0a 4c       	mov	r12,	r10	;

000086bc <.Loc.394.1>:
    86bc:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    86c0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    86c4:	01 00 

000086c6 <.Loc.396.1>:
  if (hdr.reply) {
    86c6:	6b 41       	mov.b	@r1,	r11	;

000086c8 <L0>:
    86c8:	4c 4b       	mov.b	r11,	r12	;

000086ca <.LVL804>:
    86ca:	6c f3       	and.b	#2,	r12	;r3 As==10
    86cc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    86ce:	2e 24       	jz	$+94     	;abs 0x872c

000086d0 <.Loc.397.1>:
    buffer[0] = buffer[0] & 0x3F;
    86d0:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    86d4:	00 00 

000086d6 <.Loc.398.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    86d6:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    86da:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    86de:	02 00 

000086e0 <.Loc.399.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    86e0:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    86e4:	03 00 

000086e6 <.LBB447>:
    for (int i = 0; i < 4; i++) {
    86e6:	4c 43       	clr.b	r12		;
    86e8:	0a 3c       	jmp	$+22     	;abs 0x86fe

000086ea <.L599>:
      buffer[i + 4] = bank0p[RegTXBRMsb - i];
    86ea:	0d 4c       	mov	r12,	r13	;
    86ec:	2d 52       	add	#4,	r13	;r2 As==10
    86ee:	0d 5a       	add	r10,	r13	;
    86f0:	3e 40 1b 00 	mov	#27,	r14	;#0x001b
    86f4:	0e 8c       	sub	r12,	r14	;
    86f6:	0e 5f       	add	r15,	r14	;
    86f8:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

000086fc <.Loc.401.1>:
    for (int i = 0; i < 4; i++) {
    86fc:	1c 53       	inc	r12		;

000086fe <.L598>:
    86fe:	7d 40 03 00 	mov.b	#3,	r13	;
    8702:	0d 9c       	cmp	r12,	r13	;
    8704:	f2 37       	jge	$-26     	;abs 0x86ea

00008706 <.LBE447>:
    if (hdr.crc) {
    8706:	1b b3       	bit	#1,	r11	;r3 As==01
    8708:	08 20       	jnz	$+18     	;abs 0x871a

0000870a <.Loc.409.1>:
      buffer[1] = 4;
    870a:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

0000870e <.L601>:
    elyCmdSendReply(buffer);
    870e:	0c 4a       	mov	r10,	r12	;
    8710:	b0 12 58 69 	call	#26968		;#0x6958

00008714 <.L596>:
}
    8714:	21 53       	incd	r1		;
    8716:	0a 17       	popm	#1,	r10	;16-bit words
    8718:	30 41       	ret			

0000871a <.L603>:
      buffer[1] = 6;
    871a:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    871e:	01 00 

00008720 <.Loc.406.1>:
      crcGenX25(buffer, 10);
    8720:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8724:	0c 4a       	mov	r10,	r12	;

00008726 <.LVL811>:
    8726:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000872a <.LVL812>:
    872a:	f1 3f       	jmp	$-28     	;abs 0x870e

0000872c <.L597>:
    elyNLFreeBuffer(elyNLPack(buffer));
    872c:	0c 4a       	mov	r10,	r12	;
    872e:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008732 <.LVL813>:
    8732:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008736 <.LVL814>:
}
    8736:	ee 3f       	jmp	$-34     	;abs 0x8714

00008738 <set_rx_freq>:
    8738:	5a 15       	pushm	#6,	r10	;16-bit words

0000873a <.LCFI79>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    873a:	21 83       	decd	r1		;

0000873c <.LCFI80>:
    873c:	08 4c       	mov	r12,	r8	;

0000873e <L0>:
    873e:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8742:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8746:	01 00 

00008748 <.Loc.351.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8748:	66 41       	mov.b	@r1,	r6	;
    874a:	66 f3       	and.b	#2,	r6	;r3 As==10
    874c:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    8750:	06 93       	cmp	#0,	r6	;r3 As==00
    8752:	05 24       	jz	$+12     	;abs 0x875e
    8754:	67 42       	mov.b	#4,	r7	;r2 As==10

00008756 <.L605>:
  for (int i = 0; i < 4; i++) {
    8756:	4a 43       	clr.b	r10		;

00008758 <.LBE453>:
  uint32_t freq = 0;
    8758:	05 4a       	mov	r10,	r5	;
    875a:	09 4a       	mov	r10,	r9	;

0000875c <.LBB454>:
  for (int i = 0; i < 4; i++) {
    875c:	14 3c       	jmp	$+42     	;abs 0x8786

0000875e <.L617>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    875e:	67 43       	mov.b	#2,	r7	;r3 As==10
    8760:	fa 3f       	jmp	$-10     	;abs 0x8756

00008762 <.L607>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8762:	0c 47       	mov	r7,	r12	;
    8764:	0c 5a       	add	r10,	r12	;
    8766:	0c 58       	add	r8,	r12	;
    8768:	3e 40 03 00 	mov	#3,	r14	;
    876c:	0e 8a       	sub	r10,	r14	;
    876e:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8772:	6c 4c       	mov.b	@r12,	r12	;
    8774:	0d 43       	clr	r13		;
    8776:	0f 43       	clr	r15		;
    8778:	b0 12 98 ac 	call	#-21352	;#0xac98
    877c:	0c d5       	bis	r5,	r12	;
    877e:	0d d9       	bis	r9,	r13	;
    8780:	05 4c       	mov	r12,	r5	;

00008782 <.LVL820>:
    8782:	09 4d       	mov	r13,	r9	;

00008784 <.LVL821>:
  for (int i = 0; i < 4; i++) {
    8784:	1a 53       	inc	r10		;

00008786 <.L606>:
    8786:	7c 40 03 00 	mov.b	#3,	r12	;
    878a:	0c 9a       	cmp	r10,	r12	;
    878c:	ea 37       	jge	$-42     	;abs 0x8762

0000878e <.LBE455>:
  if (freq > RX_BAND_MAX || 
    878e:	35 50 20 d5 	add	#-10976,r5	;#0xd520

00008792 <.LVL823>:
    8792:	39 60 47 e6 	addc	#-6585,	r9	;#0xe647
    8796:	7c 40 4c 00 	mov.b	#76,	r12	;#0x004c
    879a:	0c 99       	cmp	r9,	r12	;
    879c:	1c 2c       	jc	$+58     	;abs 0x87d6

0000879e <.L620>:
    if (hdr.reply) {
    879e:	06 93       	cmp	#0,	r6	;r3 As==00
    87a0:	42 24       	jz	$+134    	;abs 0x8826

000087a2 <.Loc.363.1>:
      gen_failure(buffer, hdr.crc);
    87a2:	6c 41       	mov.b	@r1,	r12	;
    87a4:	5c f3       	and.b	#1,	r12	;r3 As==01

000087a6 <.LBB456>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    87a6:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    87aa:	00 00 

000087ac <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    87ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    87ae:	33 24       	jz	$+104    	;abs 0x8816
    87b0:	6d 43       	mov.b	#2,	r13	;r3 As==10

000087b2 <.L611>:
    87b2:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

000087b6 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    87b6:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    87ba:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    87be:	02 00 

000087c0 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    87c0:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    87c4:	03 00 

000087c6 <.Loc.35.1>:
  if (crc) {
    87c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    87c8:	28 20       	jnz	$+82     	;abs 0x881a

000087ca <.L612>:
      elyCmdSendReply(buffer);
    87ca:	0c 48       	mov	r8,	r12	;
    87cc:	b0 12 58 69 	call	#26968		;#0x6958

000087d0 <.L604>:
}
    87d0:	21 53       	incd	r1		;
    87d2:	55 17       	popm	#6,	r10	;16-bit words
    87d4:	30 41       	ret			

000087d6 <.L621>:
  if (freq > RX_BAND_MAX || 
    87d6:	09 9c       	cmp	r12,	r9	;
    87d8:	04 20       	jnz	$+10     	;abs 0x87e2
    87da:	3c 40 40 4b 	mov	#19264,	r12	;#0x4b40
    87de:	0c 95       	cmp	r5,	r12	;
    87e0:	de 2b       	jnc	$-66     	;abs 0x879e

000087e2 <.L608>:
  bank0w[RegRXFreqMsb] = buffer[hdr_ext];
    87e2:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    87e6:	07 58       	add	r8,	r7	;

000087e8 <.LVL829>:
    87e8:	ec 47 07 00 	mov.b	@r7,	7(r12)	;

000087ec <.Loc.375.1>:
  bank0w[RegRXFreqHmb] = buffer[hdr_ext+1];
    87ec:	dc 47 01 00 	mov.b	1(r7),	6(r12)	;
    87f0:	06 00 

000087f2 <.Loc.376.1>:
  bank0w[RegRXFreqLmb] = buffer[hdr_ext+2];
    87f2:	dc 47 02 00 	mov.b	2(r7),	5(r12)	;
    87f6:	05 00 

000087f8 <.Loc.377.1>:
  bank0w[RegRXFreqLsb] = buffer[hdr_ext+3];
    87f8:	dc 47 03 00 	mov.b	3(r7),	4(r12)	;
    87fc:	04 00 

000087fe <.Loc.380.1>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    87fe:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8800:	4d 43       	clr.b	r13		;
    8802:	b0 12 9c aa 	call	#-21860	;#0xaa9c

00008806 <.LVL830>:
  if (hdr.reply) {
    8806:	06 93       	cmp	#0,	r6	;r3 As==00
    8808:	18 20       	jnz	$+50     	;abs 0x883a

0000880a <.Loc.389.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    880a:	0c 48       	mov	r8,	r12	;
    880c:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008810 <.LVL831>:
    8810:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008814 <.LVL832>:
    8814:	dd 3f       	jmp	$-68     	;abs 0x87d0

00008816 <.L618>:
  buffer[1] = (crc ? 2 : 0);
    8816:	0d 4c       	mov	r12,	r13	;
    8818:	cc 3f       	jmp	$-102    	;abs 0x87b2

0000881a <.L622>:
    crcGenX25(buffer, 6);
    881a:	7d 40 06 00 	mov.b	#6,	r13	;
    881e:	0c 48       	mov	r8,	r12	;
    8820:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008824 <.LVL834>:
    8824:	d2 3f       	jmp	$-90     	;abs 0x87ca

00008826 <.L610>:
      elyErrorSignal(ErrCmdFailure);
    8826:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    882a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000882e <.LVL836>:
      elyNLFreeBuffer(elyNLPack(buffer));
    882e:	0c 48       	mov	r8,	r12	;
    8830:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008834 <.LVL837>:
    8834:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008838 <.LVL838>:
    8838:	cb 3f       	jmp	$-104    	;abs 0x87d0

0000883a <.L623>:
    gen_success(buffer, hdr.crc);
    883a:	6c 41       	mov.b	@r1,	r12	;
    883c:	5c f3       	and.b	#1,	r12	;r3 As==01

0000883e <.LBB460>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    883e:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8842:	00 00 

00008844 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8844:	0c 93       	cmp	#0,	r12	;r3 As==00
    8846:	14 24       	jz	$+42     	;abs 0x8870
    8848:	7d 40 03 00 	mov.b	#3,	r13	;

0000884c <.L615>:
    884c:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008850 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8850:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8854:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    8858:	02 00 

0000885a <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    885a:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    885e:	03 00 

00008860 <.Loc.24.1>:
  buffer[4] = 1;
    8860:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

00008864 <.Loc.25.1>:
  if (crc) {
    8864:	0c 93       	cmp	#0,	r12	;r3 As==00
    8866:	06 20       	jnz	$+14     	;abs 0x8874

00008868 <.L616>:
    elyCmdSendReply(buffer);
    8868:	0c 48       	mov	r8,	r12	;
    886a:	b0 12 58 69 	call	#26968		;#0x6958

0000886e <.LVL842>:
    886e:	b0 3f       	jmp	$-158    	;abs 0x87d0

00008870 <.L619>:
  buffer[1] = (crc ? 3 : 1);
    8870:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8872:	ec 3f       	jmp	$-38     	;abs 0x884c

00008874 <.L624>:
    crcGenX25(buffer, 7);
    8874:	7d 40 07 00 	mov.b	#7,	r13	;
    8878:	0c 48       	mov	r8,	r12	;
    887a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000887e <.LVL844>:
    887e:	f4 3f       	jmp	$-22     	;abs 0x8868

00008880 <get_rx_freq>:
    8880:	0a 15       	pushm	#1,	r10	;16-bit words

00008882 <.LCFI81>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8882:	21 83       	decd	r1		;

00008884 <.LCFI82>:
    8884:	0a 4c       	mov	r12,	r10	;

00008886 <.Loc.324.1>:
    8886:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    888a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    888e:	01 00 

00008890 <.Loc.326.1>:
  if (hdr.reply) {
    8890:	6b 41       	mov.b	@r1,	r11	;

00008892 <L0>:
    8892:	4c 4b       	mov.b	r11,	r12	;

00008894 <.LVL846>:
    8894:	6c f3       	and.b	#2,	r12	;r3 As==10
    8896:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8898:	2e 24       	jz	$+94     	;abs 0x88f6

0000889a <.Loc.327.1>:
    buffer[0] = buffer[0] & 0x3F;
    889a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    889e:	00 00 

000088a0 <.Loc.328.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    88a0:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    88a4:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    88a8:	02 00 

000088aa <.Loc.329.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    88aa:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    88ae:	03 00 

000088b0 <.LBB464>:
    for (int i = 0; i < 4; i++) {
    88b0:	4c 43       	clr.b	r12		;
    88b2:	0a 3c       	jmp	$+22     	;abs 0x88c8

000088b4 <.L628>:
      buffer[i + 4] = bank0p[RegRXFreqMsb - i];
    88b4:	0d 4c       	mov	r12,	r13	;
    88b6:	2d 52       	add	#4,	r13	;r2 As==10
    88b8:	0d 5a       	add	r10,	r13	;
    88ba:	3e 40 07 00 	mov	#7,	r14	;
    88be:	0e 8c       	sub	r12,	r14	;
    88c0:	0e 5f       	add	r15,	r14	;
    88c2:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

000088c6 <.Loc.331.1>:
    for (int i = 0; i < 4; i++) {
    88c6:	1c 53       	inc	r12		;

000088c8 <.L627>:
    88c8:	7d 40 03 00 	mov.b	#3,	r13	;
    88cc:	0d 9c       	cmp	r12,	r13	;
    88ce:	f2 37       	jge	$-26     	;abs 0x88b4

000088d0 <.LBE464>:
    if (hdr.crc) {
    88d0:	1b b3       	bit	#1,	r11	;r3 As==01
    88d2:	08 20       	jnz	$+18     	;abs 0x88e4

000088d4 <.Loc.339.1>:
      buffer[1] = 4;
    88d4:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

000088d8 <.L630>:
    elyCmdSendReply(buffer);
    88d8:	0c 4a       	mov	r10,	r12	;
    88da:	b0 12 58 69 	call	#26968		;#0x6958

000088de <.L625>:
}
    88de:	21 53       	incd	r1		;
    88e0:	0a 17       	popm	#1,	r10	;16-bit words
    88e2:	30 41       	ret			

000088e4 <.L632>:
      buffer[1] = 6;
    88e4:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    88e8:	01 00 

000088ea <.Loc.336.1>:
      crcGenX25(buffer, 10);
    88ea:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    88ee:	0c 4a       	mov	r10,	r12	;

000088f0 <.LVL853>:
    88f0:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000088f4 <.LVL854>:
    88f4:	f1 3f       	jmp	$-28     	;abs 0x88d8

000088f6 <.L626>:
    elyNLFreeBuffer(elyNLPack(buffer));
    88f6:	0c 4a       	mov	r10,	r12	;
    88f8:	b0 12 4c a8 	call	#-22452	;#0xa84c

000088fc <.LVL855>:
    88fc:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008900 <.LVL856>:
}
    8900:	ee 3f       	jmp	$-34     	;abs 0x88de

00008902 <set_tx_freq>:
    8902:	5a 15       	pushm	#6,	r10	;16-bit words

00008904 <.LCFI83>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8904:	21 83       	decd	r1		;

00008906 <.LCFI84>:
    8906:	08 4c       	mov	r12,	r8	;

00008908 <L0>:
    8908:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    890c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8910:	01 00 

00008912 <.Loc.278.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8912:	66 41       	mov.b	@r1,	r6	;
    8914:	66 f3       	and.b	#2,	r6	;r3 As==10
    8916:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    891a:	06 93       	cmp	#0,	r6	;r3 As==00
    891c:	05 24       	jz	$+12     	;abs 0x8928
    891e:	67 42       	mov.b	#4,	r7	;r2 As==10

00008920 <.L634>:
  for (int i = 0; i < 4; i++) {
    8920:	4a 43       	clr.b	r10		;

00008922 <.LBE470>:
  uint32_t freq = 0;
    8922:	05 4a       	mov	r10,	r5	;
    8924:	09 4a       	mov	r10,	r9	;

00008926 <.LBB471>:
  for (int i = 0; i < 4; i++) {
    8926:	14 3c       	jmp	$+42     	;abs 0x8950

00008928 <.L646>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8928:	67 43       	mov.b	#2,	r7	;r3 As==10
    892a:	fa 3f       	jmp	$-10     	;abs 0x8920

0000892c <.L636>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    892c:	0c 47       	mov	r7,	r12	;
    892e:	0c 5a       	add	r10,	r12	;
    8930:	0c 58       	add	r8,	r12	;
    8932:	3e 40 03 00 	mov	#3,	r14	;
    8936:	0e 8a       	sub	r10,	r14	;
    8938:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    893c:	6c 4c       	mov.b	@r12,	r12	;
    893e:	0d 43       	clr	r13		;
    8940:	0f 43       	clr	r15		;
    8942:	b0 12 98 ac 	call	#-21352	;#0xac98
    8946:	0c d5       	bis	r5,	r12	;
    8948:	0d d9       	bis	r9,	r13	;
    894a:	05 4c       	mov	r12,	r5	;

0000894c <.LVL862>:
    894c:	09 4d       	mov	r13,	r9	;

0000894e <.LVL863>:
  for (int i = 0; i < 4; i++) {
    894e:	1a 53       	inc	r10		;

00008950 <.L635>:
    8950:	7c 40 03 00 	mov.b	#3,	r12	;
    8954:	0c 9a       	cmp	r10,	r12	;
    8956:	ea 37       	jge	$-42     	;abs 0x892c

00008958 <.LBE472>:
  if (freq > TX_BAND_MAX || 
    8958:	35 50 c0 f1 	add	#-3648,	r5	;#0xf1c0

0000895c <.LVL865>:
    895c:	39 60 30 e6 	addc	#-6608,	r9	;#0xe630
    8960:	3c 40 34 02 	mov	#564,	r12	;#0x0234
    8964:	0c 99       	cmp	r9,	r12	;
    8966:	1c 2c       	jc	$+58     	;abs 0x89a0

00008968 <.L649>:
    if (hdr.reply) {
    8968:	06 93       	cmp	#0,	r6	;r3 As==00
    896a:	46 24       	jz	$+142    	;abs 0x89f8

0000896c <.Loc.290.1>:
      gen_failure(buffer, hdr.crc);
    896c:	6c 41       	mov.b	@r1,	r12	;
    896e:	5c f3       	and.b	#1,	r12	;r3 As==01

00008970 <.LBB473>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8970:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8974:	00 00 

00008976 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8976:	0c 93       	cmp	#0,	r12	;r3 As==00
    8978:	37 24       	jz	$+112    	;abs 0x89e8
    897a:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000897c <.L640>:
    897c:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008980 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8980:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8984:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    8988:	02 00 

0000898a <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    898a:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    898e:	03 00 

00008990 <.Loc.35.1>:
  if (crc) {
    8990:	0c 93       	cmp	#0,	r12	;r3 As==00
    8992:	2c 20       	jnz	$+90     	;abs 0x89ec

00008994 <.L641>:
      elyCmdSendReply(buffer);
    8994:	0c 48       	mov	r8,	r12	;
    8996:	b0 12 58 69 	call	#26968		;#0x6958

0000899a <.L633>:
}
    899a:	21 53       	incd	r1		;
    899c:	55 17       	popm	#6,	r10	;16-bit words
    899e:	30 41       	ret			

000089a0 <.L650>:
  if (freq > TX_BAND_MAX || 
    89a0:	09 9c       	cmp	r12,	r9	;
    89a2:	04 20       	jnz	$+10     	;abs 0x89ac
    89a4:	3c 40 40 93 	mov	#-27840,r12	;#0x9340
    89a8:	0c 95       	cmp	r5,	r12	;
    89aa:	de 2b       	jnc	$-66     	;abs 0x8968

000089ac <.L637>:
  bank0w[RegTXFreqMsb] = buffer[hdr_ext];
    89ac:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    89b0:	07 58       	add	r8,	r7	;

000089b2 <.LVL871>:
    89b2:	ec 47 03 00 	mov.b	@r7,	3(r12)	;

000089b6 <.Loc.302.1>:
  bank0w[RegTXFreqHmb] = buffer[hdr_ext+1];
    89b6:	dc 47 01 00 	mov.b	1(r7),	2(r12)	;
    89ba:	02 00 

000089bc <.Loc.303.1>:
  bank0w[RegTXFreqLmb] = buffer[hdr_ext+2];
    89bc:	dc 47 02 00 	mov.b	2(r7),	1(r12)	;
    89c0:	01 00 

000089c2 <.Loc.304.1>:
  bank0w[RegTXFreqLsb] = buffer[hdr_ext+3];
    89c2:	dc 47 03 00 	mov.b	3(r7),	0(r12)	;
    89c6:	00 00 

000089c8 <.Loc.307.1>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    89c8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    89ca:	4d 43       	clr.b	r13		;
    89cc:	b0 12 9c aa 	call	#-21860	;#0xaa9c

000089d0 <.LVL872>:
  elyEventSignal(EvtTXFreqChange);
    89d0:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    89d4:	b0 12 3a a3 	call	#-23750	;#0xa33a

000089d8 <.LVL873>:
  if (hdr.reply) {
    89d8:	06 93       	cmp	#0,	r6	;r3 As==00
    89da:	18 20       	jnz	$+50     	;abs 0x8a0c

000089dc <.Loc.319.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    89dc:	0c 48       	mov	r8,	r12	;
    89de:	b0 12 4c a8 	call	#-22452	;#0xa84c

000089e2 <.LVL874>:
    89e2:	b0 12 1e a7 	call	#-22754	;#0xa71e

000089e6 <.LVL875>:
    89e6:	d9 3f       	jmp	$-76     	;abs 0x899a

000089e8 <.L647>:
  buffer[1] = (crc ? 2 : 0);
    89e8:	0d 4c       	mov	r12,	r13	;
    89ea:	c8 3f       	jmp	$-110    	;abs 0x897c

000089ec <.L651>:
    crcGenX25(buffer, 6);
    89ec:	7d 40 06 00 	mov.b	#6,	r13	;
    89f0:	0c 48       	mov	r8,	r12	;
    89f2:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

000089f6 <.LVL877>:
    89f6:	ce 3f       	jmp	$-98     	;abs 0x8994

000089f8 <.L639>:
      elyNLFreeBuffer(elyNLPack(buffer));
    89f8:	0c 48       	mov	r8,	r12	;
    89fa:	b0 12 4c a8 	call	#-22452	;#0xa84c

000089fe <.LVL879>:
    89fe:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008a02 <.LVL880>:
      elyErrorSignal(ErrCmdFailure);
    8a02:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8a06:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008a0a <.LVL881>:
    8a0a:	c7 3f       	jmp	$-112    	;abs 0x899a

00008a0c <.L652>:
    gen_success(buffer, hdr.crc);
    8a0c:	6c 41       	mov.b	@r1,	r12	;
    8a0e:	5c f3       	and.b	#1,	r12	;r3 As==01

00008a10 <.LBB477>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8a10:	f8 f0 3f 00 	and.b	#63,	0(r8)	;#0x003f
    8a14:	00 00 

00008a16 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8a16:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a18:	14 24       	jz	$+42     	;abs 0x8a42
    8a1a:	7d 40 03 00 	mov.b	#3,	r13	;

00008a1e <.L644>:
    8a1e:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

00008a22 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8a22:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8a26:	d8 4d 51 00 	mov.b	81(r13),2(r8)	;0x00051
    8a2a:	02 00 

00008a2c <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8a2c:	d8 4d 50 00 	mov.b	80(r13),3(r8)	;0x00050
    8a30:	03 00 

00008a32 <.Loc.24.1>:
  buffer[4] = 1;
    8a32:	d8 43 04 00 	mov.b	#1,	4(r8)	;r3 As==01

00008a36 <.Loc.25.1>:
  if (crc) {
    8a36:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a38:	06 20       	jnz	$+14     	;abs 0x8a46

00008a3a <.L645>:
    elyCmdSendReply(buffer);
    8a3a:	0c 48       	mov	r8,	r12	;
    8a3c:	b0 12 58 69 	call	#26968		;#0x6958

00008a40 <.LVL885>:
    8a40:	ac 3f       	jmp	$-166    	;abs 0x899a

00008a42 <.L648>:
  buffer[1] = (crc ? 3 : 1);
    8a42:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8a44:	ec 3f       	jmp	$-38     	;abs 0x8a1e

00008a46 <.L653>:
    crcGenX25(buffer, 7);
    8a46:	7d 40 07 00 	mov.b	#7,	r13	;
    8a4a:	0c 48       	mov	r8,	r12	;
    8a4c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008a50 <.LVL887>:
    8a50:	f4 3f       	jmp	$-22     	;abs 0x8a3a

00008a52 <get_tx_freq>:
    8a52:	0a 15       	pushm	#1,	r10	;16-bit words

00008a54 <.LCFI85>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a54:	21 83       	decd	r1		;

00008a56 <.LCFI86>:
    8a56:	0a 4c       	mov	r12,	r10	;

00008a58 <.Loc.251.1>:
    8a58:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8a5c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8a60:	01 00 

00008a62 <.Loc.253.1>:
  if (hdr.reply) {
    8a62:	6b 41       	mov.b	@r1,	r11	;

00008a64 <L0>:
    8a64:	4c 4b       	mov.b	r11,	r12	;

00008a66 <.LVL889>:
    8a66:	6c f3       	and.b	#2,	r12	;r3 As==10
    8a68:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8a6a:	2e 24       	jz	$+94     	;abs 0x8ac8

00008a6c <.Loc.254.1>:
    buffer[0] = buffer[0] & 0x3F;
    8a6c:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8a70:	00 00 

00008a72 <.Loc.255.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8a72:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    8a76:	da 4f 51 00 	mov.b	81(r15),2(r10)	;0x00051
    8a7a:	02 00 

00008a7c <.Loc.256.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8a7c:	da 4f 50 00 	mov.b	80(r15),3(r10)	;0x00050
    8a80:	03 00 

00008a82 <.LBB481>:
    for (int i = 0; i < 4; i++) {
    8a82:	4c 43       	clr.b	r12		;
    8a84:	0a 3c       	jmp	$+22     	;abs 0x8a9a

00008a86 <.L657>:
      buffer[i + 4] = bank0p[RegTXFreqMsb - i];
    8a86:	0d 4c       	mov	r12,	r13	;
    8a88:	2d 52       	add	#4,	r13	;r2 As==10
    8a8a:	0d 5a       	add	r10,	r13	;
    8a8c:	3e 40 03 00 	mov	#3,	r14	;
    8a90:	0e 8c       	sub	r12,	r14	;
    8a92:	0e 5f       	add	r15,	r14	;
    8a94:	ed 4e 00 00 	mov.b	@r14,	0(r13)	;

00008a98 <.Loc.258.1>:
    for (int i = 0; i < 4; i++) {
    8a98:	1c 53       	inc	r12		;

00008a9a <.L656>:
    8a9a:	7d 40 03 00 	mov.b	#3,	r13	;
    8a9e:	0d 9c       	cmp	r12,	r13	;
    8aa0:	f2 37       	jge	$-26     	;abs 0x8a86

00008aa2 <.LBE481>:
    if (hdr.crc) {
    8aa2:	1b b3       	bit	#1,	r11	;r3 As==01
    8aa4:	08 20       	jnz	$+18     	;abs 0x8ab6

00008aa6 <.Loc.266.1>:
      buffer[1] = 4;
    8aa6:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10

00008aaa <.L659>:
    elyCmdSendReply(buffer);
    8aaa:	0c 4a       	mov	r10,	r12	;
    8aac:	b0 12 58 69 	call	#26968		;#0x6958

00008ab0 <.L654>:
}
    8ab0:	21 53       	incd	r1		;
    8ab2:	0a 17       	popm	#1,	r10	;16-bit words
    8ab4:	30 41       	ret			

00008ab6 <.L661>:
      buffer[1] = 6;
    8ab6:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8aba:	01 00 

00008abc <.Loc.263.1>:
      crcGenX25(buffer, 10);
    8abc:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8ac0:	0c 4a       	mov	r10,	r12	;

00008ac2 <.LVL896>:
    8ac2:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008ac6 <.LVL897>:
    8ac6:	f1 3f       	jmp	$-28     	;abs 0x8aaa

00008ac8 <.L655>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8ac8:	0c 4a       	mov	r10,	r12	;
    8aca:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008ace <.LVL898>:
    8ace:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008ad2 <.LVL899>:
}
    8ad2:	ee 3f       	jmp	$-34     	;abs 0x8ab0

00008ad4 <set_block>:
    8ad4:	2a 15       	pushm	#3,	r10	;16-bit words

00008ad6 <.LCFI87>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ad6:	21 83       	decd	r1		;

00008ad8 <.LCFI88>:
    8ad8:	0a 4c       	mov	r12,	r10	;

00008ada <L0>:
    8ada:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8ade:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8ae2:	01 00 

00008ae4 <.Loc.220.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8ae4:	6b 41       	mov.b	@r1,	r11	;
    8ae6:	48 4b       	mov.b	r11,	r8	;
    8ae8:	68 f3       	and.b	#2,	r8	;r3 As==10
    8aea:	49 48       	mov.b	r8,	r9	;
    8aec:	09 93       	cmp	#0,	r9	;r3 As==00
    8aee:	31 24       	jz	$+100    	;abs 0x8b52
    8af0:	6e 42       	mov.b	#4,	r14	;r2 As==10

00008af2 <.L663>:
  uint8_t bank = buffer[hdr_ext];
    8af2:	0d 4e       	mov	r14,	r13	;
    8af4:	0c 4a       	mov	r10,	r12	;

00008af6 <.LVL902>:
    8af6:	0c 5e       	add	r14,	r12	;
    8af8:	6c 4c       	mov.b	@r12,	r12	;

00008afa <.LVL903>:
  uint8_t addr = buffer[hdr_ext+1];
    8afa:	1e 53       	inc	r14		;

00008afc <.LVL904>:
    8afc:	0e 5a       	add	r10,	r14	;
    8afe:	6e 4e       	mov.b	@r14,	r14	;

00008b00 <.LVL905>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8b00:	5f 41 01 00 	mov.b	1(r1),	r15	;
    8b04:	4f 88       	sub.b	r8,	r15	;
    8b06:	1b b3       	bit	#1,	r11	;r3 As==01
    8b08:	26 24       	jz	$+78     	;abs 0x8b56

00008b0a <.Loc.223.1>:
    8b0a:	68 43       	mov.b	#2,	r8	;r3 As==10

00008b0c <.L664>:
    8b0c:	4f 88       	sub.b	r8,	r15	;

00008b0e <.LVL906>:
  if (!elyRegSetBlock(bank, buffer + hdr_ext + 2, addr, count)) {
    8b0e:	2d 53       	incd	r13		;

00008b10 <.LVL907>:
    8b10:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

00008b14 <.LVL908>:
    8b14:	0d 5a       	add	r10,	r13	;

00008b16 <.LVL909>:
    8b16:	b0 12 22 9b 	call	#-25822	;#0x9b22

00008b1a <.LVL910>:
    8b1a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8b1c:	30 20       	jnz	$+98     	;abs 0x8b7e

00008b1e <.Loc.226.1>:
    if (hdr.reply) {
    8b1e:	09 93       	cmp	#0,	r9	;r3 As==00
    8b20:	24 24       	jz	$+74     	;abs 0x8b6a

00008b22 <.Loc.228.1>:
      gen_failure(buffer, hdr.crc);
    8b22:	6c 41       	mov.b	@r1,	r12	;
    8b24:	5c f3       	and.b	#1,	r12	;r3 As==01

00008b26 <.LBB486>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8b26:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8b2a:	00 00 

00008b2c <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8b2c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b2e:	15 24       	jz	$+44     	;abs 0x8b5a
    8b30:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008b32 <.L667>:
    8b32:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008b36 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8b36:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8b3a:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8b3e:	02 00 

00008b40 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8b40:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8b44:	03 00 

00008b46 <.Loc.35.1>:
  if (crc) {
    8b46:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b48:	0a 20       	jnz	$+22     	;abs 0x8b5e

00008b4a <.L668>:
      elyCmdSendReply(buffer);
    8b4a:	0c 4a       	mov	r10,	r12	;
    8b4c:	b0 12 58 69 	call	#26968		;#0x6958

00008b50 <.LVL913>:
    8b50:	1d 3c       	jmp	$+60     	;abs 0x8b8c

00008b52 <.L673>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8b52:	6e 43       	mov.b	#2,	r14	;r3 As==10
    8b54:	ce 3f       	jmp	$-98     	;abs 0x8af2

00008b56 <.L674>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8b56:	48 43       	clr.b	r8		;
    8b58:	d9 3f       	jmp	$-76     	;abs 0x8b0c

00008b5a <.L675>:
  buffer[1] = (crc ? 2 : 0);
    8b5a:	0d 4c       	mov	r12,	r13	;
    8b5c:	ea 3f       	jmp	$-42     	;abs 0x8b32

00008b5e <.L677>:
    crcGenX25(buffer, 6);
    8b5e:	7d 40 06 00 	mov.b	#6,	r13	;
    8b62:	0c 4a       	mov	r10,	r12	;
    8b64:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008b68 <.LVL917>:
    8b68:	f0 3f       	jmp	$-30     	;abs 0x8b4a

00008b6a <.L666>:
      elyErrorSignal(ErrCmdFailure);
    8b6a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8b6e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008b72 <.LVL919>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8b72:	0c 4a       	mov	r10,	r12	;
    8b74:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008b78 <.LVL920>:
    8b78:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008b7c <.LVL921>:
    8b7c:	07 3c       	jmp	$+16     	;abs 0x8b8c

00008b7e <.L665>:
  if (hdr.reply) {
    8b7e:	09 93       	cmp	#0,	r9	;r3 As==00
    8b80:	08 20       	jnz	$+18     	;abs 0x8b92

00008b82 <.Loc.247.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8b82:	0c 4a       	mov	r10,	r12	;
    8b84:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008b88 <.LVL922>:
    8b88:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008b8c <.L662>:
}
    8b8c:	21 53       	incd	r1		;
    8b8e:	28 17       	popm	#3,	r10	;16-bit words
    8b90:	30 41       	ret			

00008b92 <.L678>:
    gen_success(buffer, hdr.crc);
    8b92:	6c 41       	mov.b	@r1,	r12	;
    8b94:	5c f3       	and.b	#1,	r12	;r3 As==01

00008b96 <.LBB490>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8b96:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8b9a:	00 00 

00008b9c <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8b9c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b9e:	14 24       	jz	$+42     	;abs 0x8bc8
    8ba0:	7d 40 03 00 	mov.b	#3,	r13	;

00008ba4 <.L671>:
    8ba4:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008ba8 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8ba8:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8bac:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8bb0:	02 00 

00008bb2 <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8bb2:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8bb6:	03 00 

00008bb8 <.Loc.24.1>:
  buffer[4] = 1;
    8bb8:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00008bbc <.Loc.25.1>:
  if (crc) {
    8bbc:	0c 93       	cmp	#0,	r12	;r3 As==00
    8bbe:	06 20       	jnz	$+14     	;abs 0x8bcc

00008bc0 <.L672>:
    elyCmdSendReply(buffer);
    8bc0:	0c 4a       	mov	r10,	r12	;
    8bc2:	b0 12 58 69 	call	#26968		;#0x6958

00008bc6 <.LVL926>:
    8bc6:	e2 3f       	jmp	$-58     	;abs 0x8b8c

00008bc8 <.L676>:
  buffer[1] = (crc ? 3 : 1);
    8bc8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8bca:	ec 3f       	jmp	$-38     	;abs 0x8ba4

00008bcc <.L679>:
    crcGenX25(buffer, 7);
    8bcc:	7d 40 07 00 	mov.b	#7,	r13	;
    8bd0:	0c 4a       	mov	r10,	r12	;
    8bd2:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008bd6 <.LVL928>:
    8bd6:	f4 3f       	jmp	$-22     	;abs 0x8bc0

00008bd8 <get_block>:
    8bd8:	2a 15       	pushm	#3,	r10	;16-bit words

00008bda <.LCFI89>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8bda:	21 83       	decd	r1		;

00008bdc <.LCFI90>:
    8bdc:	0a 4c       	mov	r12,	r10	;

00008bde <.Loc.187.1>:
    8bde:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8be2:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8be6:	01 00 

00008be8 <.Loc.189.1>:
  if (hdr.reply) { /* reply requested */
    8be8:	69 41       	mov.b	@r1,	r9	;

00008bea <L0>:
    8bea:	4c 49       	mov.b	r9,	r12	;

00008bec <.LVL930>:
    8bec:	6c f3       	and.b	#2,	r12	;r3 As==10
    8bee:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8bf0:	4e 24       	jz	$+158    	;abs 0x8c8e

00008bf2 <.LBB497>:
    uint8_t count = buffer[6];
    8bf2:	58 4a 06 00 	mov.b	6(r10),	r8	;

00008bf6 <.LVL932>:
    if (!elyRegGetBlock(bank, buffer + 4, addr, count)) {
    8bf6:	4f 48       	mov.b	r8,	r15	;
    8bf8:	5e 4a 05 00 	mov.b	5(r10),	r14	;
    8bfc:	0d 4a       	mov	r10,	r13	;
    8bfe:	2d 52       	add	#4,	r13	;r2 As==10

00008c00 <.LVL933>:
    8c00:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    8c04:	b0 12 86 9a 	call	#-25978	;#0x9a86

00008c08 <.LVL934>:
    8c08:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8c0a:	18 24       	jz	$+50     	;abs 0x8c3c

00008c0c <.Loc.202.1>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8c0c:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8c10:	00 00 

00008c12 <.Loc.203.1>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    8c12:	59 f3       	and.b	#1,	r9	;r3 As==01
    8c14:	09 93       	cmp	#0,	r9	;r3 As==00
    8c16:	32 24       	jz	$+102    	;abs 0x8c7c
    8c18:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008c1a <.L686>:
    8c1a:	4c 58       	add.b	r8,	r12	;
    8c1c:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00008c20 <.Loc.204.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8c20:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    8c24:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8c28:	02 00 

00008c2a <.Loc.205.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8c2a:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8c2e:	03 00 

00008c30 <.Loc.207.1>:
    if (hdr.crc) {
    8c30:	09 93       	cmp	#0,	r9	;r3 As==00
    8c32:	26 20       	jnz	$+78     	;abs 0x8c80

00008c34 <.L687>:
    elyCmdSendReply(buffer);
    8c34:	0c 4a       	mov	r10,	r12	;
    8c36:	b0 12 58 69 	call	#26968		;#0x6958

00008c3a <.LBE497>:
    8c3a:	2e 3c       	jmp	$+94     	;abs 0x8c98

00008c3c <.L690>:
      gen_failure(buffer, hdr.crc);
    8c3c:	6c 41       	mov.b	@r1,	r12	;
    8c3e:	5c f3       	and.b	#1,	r12	;r3 As==01

00008c40 <.LBB498>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8c40:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8c44:	00 00 

00008c46 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8c46:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c48:	11 24       	jz	$+36     	;abs 0x8c6c
    8c4a:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008c4c <.L683>:
    8c4c:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008c50 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8c50:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8c54:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8c58:	02 00 

00008c5a <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8c5a:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8c5e:	03 00 

00008c60 <.Loc.35.1>:
  if (crc) {
    8c60:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c62:	06 20       	jnz	$+14     	;abs 0x8c70

00008c64 <.L684>:
      elyCmdSendReply(buffer);
    8c64:	0c 4a       	mov	r10,	r12	;
    8c66:	b0 12 58 69 	call	#26968		;#0x6958

00008c6a <.LVL938>:
      return;
    8c6a:	16 3c       	jmp	$+46     	;abs 0x8c98

00008c6c <.L688>:
  buffer[1] = (crc ? 2 : 0);
    8c6c:	0d 4c       	mov	r12,	r13	;
    8c6e:	ee 3f       	jmp	$-34     	;abs 0x8c4c

00008c70 <.L692>:
    crcGenX25(buffer, 6);
    8c70:	7d 40 06 00 	mov.b	#6,	r13	;
    8c74:	0c 4a       	mov	r10,	r12	;
    8c76:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008c7a <.LVL940>:
    8c7a:	f4 3f       	jmp	$-22     	;abs 0x8c64

00008c7c <.L689>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    8c7c:	4c 43       	clr.b	r12		;
    8c7e:	cd 3f       	jmp	$-100    	;abs 0x8c1a

00008c80 <.L691>:
      crcGenX25(buffer, count + 6);
    8c80:	0d 48       	mov	r8,	r13	;
    8c82:	3d 50 06 00 	add	#6,	r13	;
    8c86:	0c 4a       	mov	r10,	r12	;
    8c88:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008c8c <.LVL942>:
    8c8c:	d3 3f       	jmp	$-88     	;abs 0x8c34

00008c8e <.L681>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8c8e:	0c 4a       	mov	r10,	r12	;
    8c90:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008c94 <.LVL944>:
    8c94:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008c98 <.L680>:
}
    8c98:	21 53       	incd	r1		;
    8c9a:	28 17       	popm	#3,	r10	;16-bit words
    8c9c:	30 41       	ret			

00008c9e <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8c9e:	1a 15       	pushm	#2,	r10	;16-bit words

00008ca0 <.LCFI91>:
    8ca0:	21 83       	decd	r1		;

00008ca2 <.LCFI92>:
    8ca2:	09 4c       	mov	r12,	r9	;

00008ca4 <.Loc.155.1>:
    8ca4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8ca8:	d1 4d       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00008caa <L0>:
    8caa:	01 00       	mova	@r0,	r1	;
    8cac:	01 00       	mova	@r0,	r1	;

00008cae <.Loc.156.1>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8cae:	6f 41       	mov.b	@r1,	r15	;
    8cb0:	4a 4f       	mov.b	r15,	r10	;
    8cb2:	6a f3       	and.b	#2,	r10	;r3 As==10
    8cb4:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8cb8:	0a 93       	cmp	#0,	r10	;r3 As==00
    8cba:	33 24       	jz	$+104    	;abs 0x8d22

00008cbc <.Loc.156.1>:
    8cbc:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008cc0 <.L695>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8cc0:	0a 93       	cmp	#0,	r10	;r3 As==00
    8cc2:	32 24       	jz	$+102    	;abs 0x8d28

00008cc4 <.Loc.157.1>:
    8cc4:	7d 40 05 00 	mov.b	#5,	r13	;

00008cc8 <.L696>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8cc8:	5e 41 01 00 	mov.b	1(r1),	r14	;
    8ccc:	1f b3       	bit	#1,	r15	;r3 As==01
    8cce:	2f 24       	jz	$+96     	;abs 0x8d2e

00008cd0 <.Loc.158.1>:
    8cd0:	6f 43       	mov.b	#2,	r15	;r3 As==10

00008cd2 <.L697>:
    8cd2:	0e 8f       	sub	r15,	r14	;
    8cd4:	0e 8a       	sub	r10,	r14	;
    8cd6:	0f 4e       	mov	r14,	r15	;
    8cd8:	5f 03       	rrum	#1,	r15	;
    8cda:	4d 18 0f 11 	rpt #14 { rrax.w	r15		;
    8cde:	0e 5f       	add	r15,	r14	;

00008ce0 <.LVL949>:
  if (!elyRegSet(bank, buffer + regs_offset, num_regs)) {
    8ce0:	12 c3       	clrc			
    8ce2:	0e 10       	rrc	r14		;

00008ce4 <.LVL950>:
    8ce4:	0d 59       	add	r9,	r13	;

00008ce6 <.LVL951>:
    8ce6:	b0 12 ec 99 	call	#-26132	;#0x99ec

00008cea <.LVL952>:
    8cea:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8cec:	34 20       	jnz	$+106    	;abs 0x8d56

00008cee <.Loc.161.1>:
    if (hdr.reply) {
    8cee:	0a 93       	cmp	#0,	r10	;r3 As==00
    8cf0:	28 24       	jz	$+82     	;abs 0x8d42

00008cf2 <.Loc.163.1>:
      gen_failure(buffer, hdr.crc);
    8cf2:	6c 41       	mov.b	@r1,	r12	;
    8cf4:	5c f3       	and.b	#1,	r12	;r3 As==01

00008cf6 <.LBB507>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8cf6:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    8cfa:	00 00 

00008cfc <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8cfc:	0c 93       	cmp	#0,	r12	;r3 As==00
    8cfe:	19 24       	jz	$+52     	;abs 0x8d32
    8d00:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008d02 <.L700>:
    8d02:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00008d06 <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8d06:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8d0a:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    8d0e:	02 00 

00008d10 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8d10:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    8d14:	03 00 

00008d16 <.Loc.35.1>:
  if (crc) {
    8d16:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d18:	0e 20       	jnz	$+30     	;abs 0x8d36

00008d1a <.L701>:
      elyCmdSendReply(buffer);
    8d1a:	0c 49       	mov	r9,	r12	;
    8d1c:	b0 12 58 69 	call	#26968		;#0x6958

00008d20 <.LVL955>:
    8d20:	21 3c       	jmp	$+68     	;abs 0x8d64

00008d22 <.L694>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8d22:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8d26:	cc 3f       	jmp	$-102    	;abs 0x8cc0

00008d28 <.L706>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8d28:	7d 40 03 00 	mov.b	#3,	r13	;
    8d2c:	cd 3f       	jmp	$-100    	;abs 0x8cc8

00008d2e <.L707>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8d2e:	4f 43       	clr.b	r15		;
    8d30:	d0 3f       	jmp	$-94     	;abs 0x8cd2

00008d32 <.L708>:
  buffer[1] = (crc ? 2 : 0);
    8d32:	0d 4c       	mov	r12,	r13	;
    8d34:	e6 3f       	jmp	$-50     	;abs 0x8d02

00008d36 <.L710>:
    crcGenX25(buffer, 6);
    8d36:	7d 40 06 00 	mov.b	#6,	r13	;
    8d3a:	0c 49       	mov	r9,	r12	;
    8d3c:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008d40 <.LVL959>:
    8d40:	ec 3f       	jmp	$-38     	;abs 0x8d1a

00008d42 <.L699>:
      elyErrorSignal(ErrCmdFailure);
    8d42:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8d46:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008d4a <.LVL961>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8d4a:	0c 49       	mov	r9,	r12	;
    8d4c:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008d50 <.LVL962>:
    8d50:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008d54 <.LVL963>:
    8d54:	07 3c       	jmp	$+16     	;abs 0x8d64

00008d56 <.L698>:
  if (hdr.reply) {
    8d56:	0a 93       	cmp	#0,	r10	;r3 As==00
    8d58:	08 20       	jnz	$+18     	;abs 0x8d6a

00008d5a <.Loc.182.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8d5a:	0c 49       	mov	r9,	r12	;
    8d5c:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008d60 <.LVL964>:
    8d60:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008d64 <.L693>:
}
    8d64:	21 53       	incd	r1		;
    8d66:	19 17       	popm	#2,	r10	;16-bit words
    8d68:	30 41       	ret			

00008d6a <.L711>:
    gen_success(buffer, hdr.crc);
    8d6a:	6c 41       	mov.b	@r1,	r12	;
    8d6c:	5c f3       	and.b	#1,	r12	;r3 As==01

00008d6e <.LBB511>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8d6e:	f9 f0 3f 00 	and.b	#63,	0(r9)	;#0x003f
    8d72:	00 00 

00008d74 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8d74:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d76:	14 24       	jz	$+42     	;abs 0x8da0
    8d78:	7d 40 03 00 	mov.b	#3,	r13	;

00008d7c <.L704>:
    8d7c:	c9 4d 01 00 	mov.b	r13,	1(r9)	;

00008d80 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8d80:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8d84:	d9 4d 51 00 	mov.b	81(r13),2(r9)	;0x00051
    8d88:	02 00 

00008d8a <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8d8a:	d9 4d 50 00 	mov.b	80(r13),3(r9)	;0x00050
    8d8e:	03 00 

00008d90 <.Loc.24.1>:
  buffer[4] = 1;
    8d90:	d9 43 04 00 	mov.b	#1,	4(r9)	;r3 As==01

00008d94 <.Loc.25.1>:
  if (crc) {
    8d94:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d96:	06 20       	jnz	$+14     	;abs 0x8da4

00008d98 <.L705>:
    elyCmdSendReply(buffer);
    8d98:	0c 49       	mov	r9,	r12	;
    8d9a:	b0 12 58 69 	call	#26968		;#0x6958

00008d9e <.LVL968>:
    8d9e:	e2 3f       	jmp	$-58     	;abs 0x8d64

00008da0 <.L709>:
  buffer[1] = (crc ? 3 : 1);
    8da0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8da2:	ec 3f       	jmp	$-38     	;abs 0x8d7c

00008da4 <.L712>:
    crcGenX25(buffer, 7);
    8da4:	7d 40 07 00 	mov.b	#7,	r13	;
    8da8:	0c 49       	mov	r9,	r12	;
    8daa:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008dae <.LVL970>:
    8dae:	f4 3f       	jmp	$-22     	;abs 0x8d98

00008db0 <get_regs>:
    8db0:	3a 15       	pushm	#4,	r10	;16-bit words

00008db2 <.LCFI93>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8db2:	21 83       	decd	r1		;

00008db4 <.LCFI94>:
    8db4:	0a 4c       	mov	r12,	r10	;

00008db6 <.Loc.125.1>:
    8db6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8dba:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8dbe:	01 00 

00008dc0 <.Loc.126.1>:
  if (hdr.reply) {
    8dc0:	6d 41       	mov.b	@r1,	r13	;
    8dc2:	4c 4d       	mov.b	r13,	r12	;

00008dc4 <L0>:
    8dc4:	6c f3       	and.b	#2,	r12	;r3 As==10
    8dc6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8dc8:	55 24       	jz	$+172    	;abs 0x8e74

00008dca <.LBB518>:
    uint8_t bank = buffer[4];
    8dca:	5c 4a 04 00 	mov.b	4(r10),	r12	;

00008dce <.LVL973>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8dce:	58 41 01 00 	mov.b	1(r1),	r8	;
    8dd2:	09 4d       	mov	r13,	r9	;
    8dd4:	59 f3       	and.b	#1,	r9	;r3 As==01
    8dd6:	09 93       	cmp	#0,	r9	;r3 As==00
    8dd8:	24 24       	jz	$+74     	;abs 0x8e22
    8dda:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008ddc <.L715>:
    8ddc:	4e 48       	mov.b	r8,	r14	;
    8dde:	4e 8d       	sub.b	r13,	r14	;
    8de0:	7e 50 fd ff 	add.b	#-3,	r14	;#0xfffd
    8de4:	47 4e       	mov.b	r14,	r7	;

00008de6 <.LVL974>:
    if (!elyRegGet(bank, buffer + regs_offset, num_regs)) {
    8de6:	0d 4a       	mov	r10,	r13	;
    8de8:	3d 50 05 00 	add	#5,	r13	;
    8dec:	b0 12 34 99 	call	#-26316	;#0x9934

00008df0 <.LVL975>:
    8df0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8df2:	19 24       	jz	$+52     	;abs 0x8e26

00008df4 <.Loc.139.1>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8df4:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8df8:	00 00 

00008dfa <.Loc.140.1>:
    buffer[1] = hdr.length - 3; /* no Reply Address, no Bank Index */
    8dfa:	78 50 fd ff 	add.b	#-3,	r8	;#0xfffd
    8dfe:	ca 48 01 00 	mov.b	r8,	1(r10)	;

00008e02 <.Loc.141.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8e02:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    8e06:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8e0a:	02 00 

00008e0c <.Loc.142.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8e0c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8e10:	03 00 

00008e12 <.Loc.144.1>:
    if (hdr.crc) {
    8e12:	09 93       	cmp	#0,	r9	;r3 As==00
    8e14:	28 20       	jnz	$+82     	;abs 0x8e66

00008e16 <.L720>:
    elyCmdSendReply(buffer);
    8e16:	0c 4a       	mov	r10,	r12	;
    8e18:	b0 12 58 69 	call	#26968		;#0x6958

00008e1c <.L713>:
}
    8e1c:	21 53       	incd	r1		;
    8e1e:	37 17       	popm	#4,	r10	;16-bit words
    8e20:	30 41       	ret			

00008e22 <.L721>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8e22:	4d 43       	clr.b	r13		;
    8e24:	db 3f       	jmp	$-72     	;abs 0x8ddc

00008e26 <.L723>:
      gen_failure(buffer, hdr.crc);
    8e26:	6c 41       	mov.b	@r1,	r12	;
    8e28:	5c f3       	and.b	#1,	r12	;r3 As==01

00008e2a <.LBB519>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8e2a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8e2e:	00 00 

00008e30 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8e30:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e32:	11 24       	jz	$+36     	;abs 0x8e56
    8e34:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008e36 <.L717>:
    8e36:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008e3a <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8e3a:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8e3e:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8e42:	02 00 

00008e44 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8e44:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8e48:	03 00 

00008e4a <.Loc.35.1>:
  if (crc) {
    8e4a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e4c:	06 20       	jnz	$+14     	;abs 0x8e5a

00008e4e <.L718>:
      elyCmdSendReply(buffer);
    8e4e:	0c 4a       	mov	r10,	r12	;
    8e50:	b0 12 58 69 	call	#26968		;#0x6958

00008e54 <.LVL981>:
      return;
    8e54:	e3 3f       	jmp	$-56     	;abs 0x8e1c

00008e56 <.L722>:
  buffer[1] = (crc ? 2 : 0);
    8e56:	0d 4c       	mov	r12,	r13	;
    8e58:	ee 3f       	jmp	$-34     	;abs 0x8e36

00008e5a <.L725>:
    crcGenX25(buffer, 6);
    8e5a:	7d 40 06 00 	mov.b	#6,	r13	;
    8e5e:	0c 4a       	mov	r10,	r12	;
    8e60:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008e64 <.LVL983>:
    8e64:	f4 3f       	jmp	$-22     	;abs 0x8e4e

00008e66 <.L724>:
      crcGenX25(buffer, num_regs + 6);
    8e66:	0d 47       	mov	r7,	r13	;
    8e68:	3d 50 06 00 	add	#6,	r13	;
    8e6c:	0c 4a       	mov	r10,	r12	;
    8e6e:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008e72 <.LVL985>:
    8e72:	d1 3f       	jmp	$-92     	;abs 0x8e16

00008e74 <.L714>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8e74:	0c 4a       	mov	r10,	r12	;
    8e76:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008e7a <.LVL987>:
    8e7a:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008e7e <.LVL988>:
    8e7e:	ce 3f       	jmp	$-98     	;abs 0x8e1c

00008e80 <get_active_bank>:
    8e80:	0a 15       	pushm	#1,	r10	;16-bit words

00008e82 <.LCFI95>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8e82:	21 83       	decd	r1		;

00008e84 <.LCFI96>:
    8e84:	0a 4c       	mov	r12,	r10	;

00008e86 <.Loc.105.1>:
    8e86:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8e8a:	d1 4d       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00008e8c <L0>:
    8e8c:	01 00       	mova	@r0,	r1	;
    8e8e:	01 00       	mova	@r0,	r1	;

00008e90 <.Loc.107.1>:
  if (hdr.reply) { /* reply requested */
    8e90:	6d 41       	mov.b	@r1,	r13	;
    8e92:	4c 4d       	mov.b	r13,	r12	;

00008e94 <.LVL990>:
    8e94:	6c f3       	and.b	#2,	r12	;r3 As==10
    8e96:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8e98:	22 24       	jz	$+70     	;abs 0x8ede

00008e9a <.Loc.108.1>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8e9a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8e9e:	00 00 

00008ea0 <.Loc.109.1>:
    buffer[1] = 1 + (hdr.crc << 1);
    8ea0:	6c 41       	mov.b	@r1,	r12	;
    8ea2:	5c f3       	and.b	#1,	r12	;r3 As==01
    8ea4:	4c 5c       	rla.b	r12		;
    8ea6:	5c 53       	inc.b	r12		;
    8ea8:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00008eac <.Loc.110.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8eac:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    8eb0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8eb4:	02 00 

00008eb6 <.Loc.111.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8eb6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8eba:	03 00 

00008ebc <.Loc.112.1>:
    buffer[4] = bank0p[RegActiveBank];
    8ebc:	da 4c 69 00 	mov.b	105(r12),4(r10)	;0x00069
    8ec0:	04 00 

00008ec2 <.Loc.113.1>:
    if (hdr.crc) {
    8ec2:	1d b3       	bit	#1,	r13	;r3 As==01
    8ec4:	06 20       	jnz	$+14     	;abs 0x8ed2

00008ec6 <.L728>:
    elyCmdSendReply(buffer);
    8ec6:	0c 4a       	mov	r10,	r12	;
    8ec8:	b0 12 58 69 	call	#26968		;#0x6958

00008ecc <.L726>:
}
    8ecc:	21 53       	incd	r1		;
    8ece:	0a 17       	popm	#1,	r10	;16-bit words
    8ed0:	30 41       	ret			

00008ed2 <.L730>:
      crcGenX25(buffer, 7);
    8ed2:	7d 40 07 00 	mov.b	#7,	r13	;
    8ed6:	0c 4a       	mov	r10,	r12	;
    8ed8:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008edc <.LVL992>:
    8edc:	f4 3f       	jmp	$-22     	;abs 0x8ec6

00008ede <.L727>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8ede:	0c 4a       	mov	r10,	r12	;
    8ee0:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008ee4 <.LVL993>:
    8ee4:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008ee8 <.LVL994>:
}
    8ee8:	f1 3f       	jmp	$-28     	;abs 0x8ecc

00008eea <set_gpo>:
    8eea:	2a 15       	pushm	#3,	r10	;16-bit words

00008eec <.LCFI97>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8eec:	21 83       	decd	r1		;

00008eee <L0>:
    8eee:	0a 4c       	mov	r12,	r10	;

00008ef0 <.Loc.66.1>:
    8ef0:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8ef4:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8ef8:	01 00 

00008efa <.Loc.67.1>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    8efa:	69 41       	mov.b	@r1,	r9	;
    8efc:	69 f3       	and.b	#2,	r9	;r3 As==10
    8efe:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8f02:	09 93       	cmp	#0,	r9	;r3 As==00
    8f04:	22 24       	jz	$+70     	;abs 0x8f4a
    8f06:	6c 42       	mov.b	#4,	r12	;r2 As==10

00008f08 <.L732>:
    8f08:	0c 5a       	add	r10,	r12	;
    8f0a:	68 4c       	mov.b	@r12,	r8	;

00008f0c <.LVL997>:
  if (arg > 1) {
    8f0c:	5c 43       	mov.b	#1,	r12	;r3 As==01

00008f0e <.LVL998>:
    8f0e:	4c 98       	cmp.b	r8,	r12	;
    8f10:	30 2c       	jc	$+98     	;abs 0x8f72

00008f12 <.Loc.70.1>:
    if (hdr.reply) {
    8f12:	09 93       	cmp	#0,	r9	;r3 As==00
    8f14:	24 24       	jz	$+74     	;abs 0x8f5e

00008f16 <.Loc.72.1>:
      gen_failure(buffer, hdr.crc);
    8f16:	6c 41       	mov.b	@r1,	r12	;
    8f18:	5c f3       	and.b	#1,	r12	;r3 As==01

00008f1a <.LBB528>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8f1a:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8f1e:	00 00 

00008f20 <.Loc.32.1>:
  buffer[1] = (crc ? 2 : 0);
    8f20:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f22:	15 24       	jz	$+44     	;abs 0x8f4e
    8f24:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008f26 <.L735>:
    8f26:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008f2a <.Loc.33.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8f2a:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8f2e:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8f32:	02 00 

00008f34 <.Loc.34.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8f34:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8f38:	03 00 

00008f3a <.Loc.35.1>:
  if (crc) {
    8f3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f3c:	0a 20       	jnz	$+22     	;abs 0x8f52

00008f3e <.L736>:
      elyCmdSendReply(buffer);
    8f3e:	0c 4a       	mov	r10,	r12	;
    8f40:	b0 12 58 69 	call	#26968		;#0x6958

00008f44 <.L731>:
}
    8f44:	21 53       	incd	r1		;
    8f46:	28 17       	popm	#3,	r10	;16-bit words
    8f48:	30 41       	ret			

00008f4a <.L742>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    8f4a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8f4c:	dd 3f       	jmp	$-68     	;abs 0x8f08

00008f4e <.L743>:
  buffer[1] = (crc ? 2 : 0);
    8f4e:	0d 4c       	mov	r12,	r13	;
    8f50:	ea 3f       	jmp	$-42     	;abs 0x8f26

00008f52 <.L745>:
    crcGenX25(buffer, 6);
    8f52:	7d 40 06 00 	mov.b	#6,	r13	;
    8f56:	0c 4a       	mov	r10,	r12	;
    8f58:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008f5c <.LVL1004>:
    8f5c:	f0 3f       	jmp	$-30     	;abs 0x8f3e

00008f5e <.L734>:
      elyErrorSignal(ErrCmdFailure);
    8f5e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8f62:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00008f66 <.LVL1006>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8f66:	0c 4a       	mov	r10,	r12	;
    8f68:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008f6c <.LVL1007>:
    8f6c:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008f70 <.LVL1008>:
    return;
    8f70:	e9 3f       	jmp	$-44     	;abs 0x8f44

00008f72 <.L733>:
  if (bank0p[RegGPOState] != arg) {
    8f72:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    8f76:	cc 98 61 00 	cmp.b	r8,	97(r12)	; 0x0061
    8f7a:	08 24       	jz	$+18     	;abs 0x8f8c

00008f7c <.Loc.89.1>:
    elyEventSignal(EvtGPOChange);
    8f7c:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    8f80:	b0 12 3a a3 	call	#-23750	;#0xa33a

00008f84 <.LVL1009>:
    bank0w[RegGPOState] = arg;
    8f84:	1c 42 82 b1 	mov	&0xb182,r12	;0xb182
    8f88:	cc 48 61 00 	mov.b	r8,	97(r12)	; 0x0061

00008f8c <.L738>:
  if (hdr.reply) {
    8f8c:	09 93       	cmp	#0,	r9	;r3 As==00
    8f8e:	06 20       	jnz	$+14     	;abs 0x8f9c

00008f90 <.Loc.100.1>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8f90:	0c 4a       	mov	r10,	r12	;
    8f92:	b0 12 4c a8 	call	#-22452	;#0xa84c

00008f96 <.LVL1010>:
    8f96:	b0 12 1e a7 	call	#-22754	;#0xa71e

00008f9a <.LVL1011>:
    8f9a:	d4 3f       	jmp	$-86     	;abs 0x8f44

00008f9c <.L746>:
    gen_success(buffer, hdr.crc);
    8f9c:	6c 41       	mov.b	@r1,	r12	;
    8f9e:	5c f3       	and.b	#1,	r12	;r3 As==01

00008fa0 <.LBB532>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8fa0:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8fa4:	00 00 

00008fa6 <.Loc.21.1>:
  buffer[1] = (crc ? 3 : 1);
    8fa6:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fa8:	14 24       	jz	$+42     	;abs 0x8fd2
    8faa:	7d 40 03 00 	mov.b	#3,	r13	;

00008fae <.L740>:
    8fae:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008fb2 <.Loc.22.1>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    8fb2:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    8fb6:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8fba:	02 00 

00008fbc <.Loc.23.1>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    8fbc:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8fc0:	03 00 

00008fc2 <.Loc.24.1>:
  buffer[4] = 1;
    8fc2:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00008fc6 <.Loc.25.1>:
  if (crc) {
    8fc6:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fc8:	06 20       	jnz	$+14     	;abs 0x8fd6

00008fca <.L741>:
    elyCmdSendReply(buffer);
    8fca:	0c 4a       	mov	r10,	r12	;
    8fcc:	b0 12 58 69 	call	#26968		;#0x6958

00008fd0 <.LVL1014>:
    8fd0:	b9 3f       	jmp	$-140    	;abs 0x8f44

00008fd2 <.L744>:
  buffer[1] = (crc ? 3 : 1);
    8fd2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8fd4:	ec 3f       	jmp	$-38     	;abs 0x8fae

00008fd6 <.L747>:
    crcGenX25(buffer, 7);
    8fd6:	7d 40 07 00 	mov.b	#7,	r13	;
    8fda:	0c 4a       	mov	r10,	r12	;
    8fdc:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

00008fe0 <.LVL1016>:
    8fe0:	f4 3f       	jmp	$-22     	;abs 0x8fca

00008fe2 <get_gpo>:
    8fe2:	0a 15       	pushm	#1,	r10	;16-bit words

00008fe4 <.LCFI99>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8fe4:	21 83       	decd	r1		;

00008fe6 <.LCFI100>:
    8fe6:	0a 4c       	mov	r12,	r10	;

00008fe8 <.Loc.46.1>:
    8fe8:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8fec:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8ff0:	01 00 

00008ff2 <L0>:
  if (hdr.reply) { /* reply requested */
    8ff2:	6d 41       	mov.b	@r1,	r13	;
    8ff4:	4c 4d       	mov.b	r13,	r12	;

00008ff6 <.LVL1018>:
    8ff6:	6c f3       	and.b	#2,	r12	;r3 As==10
    8ff8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8ffa:	22 24       	jz	$+70     	;abs 0x9040

00008ffc <.Loc.49.1>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8ffc:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    9000:	00 00 

00009002 <.Loc.50.1>:
    buffer[1] = 1 + (hdr.crc << 1);
    9002:	6c 41       	mov.b	@r1,	r12	;
    9004:	5c f3       	and.b	#1,	r12	;r3 As==01
    9006:	4c 5c       	rla.b	r12		;
    9008:	5c 53       	inc.b	r12		;
    900a:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

0000900e <.Loc.51.1>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    900e:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184
    9012:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9016:	02 00 

00009018 <.Loc.52.1>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9018:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    901c:	03 00 

0000901e <.Loc.53.1>:
    buffer[4] = bank0p[RegGPOState];
    901e:	da 4c 61 00 	mov.b	97(r12),4(r10)	;0x00061
    9022:	04 00 

00009024 <.Loc.54.1>:
    if (hdr.crc) {
    9024:	1d b3       	bit	#1,	r13	;r3 As==01
    9026:	06 20       	jnz	$+14     	;abs 0x9034

00009028 <.L750>:
    elyCmdSendReply(buffer);
    9028:	0c 4a       	mov	r10,	r12	;
    902a:	b0 12 58 69 	call	#26968		;#0x6958

0000902e <.L748>:
}
    902e:	21 53       	incd	r1		;
    9030:	0a 17       	popm	#1,	r10	;16-bit words
    9032:	30 41       	ret			

00009034 <.L752>:
      crcGenX25(buffer, 7);
    9034:	7d 40 07 00 	mov.b	#7,	r13	;
    9038:	0c 4a       	mov	r10,	r12	;
    903a:	b0 12 2a 9f 	call	#-24790	;#0x9f2a

0000903e <.LVL1020>:
    903e:	f4 3f       	jmp	$-22     	;abs 0x9028

00009040 <.L749>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9040:	0c 4a       	mov	r10,	r12	;
    9042:	b0 12 4c a8 	call	#-22452	;#0xa84c

00009046 <.LVL1021>:
    9046:	b0 12 1e a7 	call	#-22754	;#0xa71e

0000904a <.LVL1022>:
}
    904a:	f1 3f       	jmp	$-28     	;abs 0x902e

0000904c <fram_reg_cb>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    904c:	5c 42 44 b7 	mov.b	&0xb744,r12	;0xb744

00009050 <L0>:
    9050:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9052:	c2 4c 44 b7 	mov.b	r12,	&0xb744	;

00009056 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    9056:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9058:	05 20       	jnz	$+12     	;abs 0x9064

0000905a <.LBB41>:
  if (bsp->sem.cnt < (cnt_t)1) {
    905a:	1c 42 46 b7 	mov	&0xb746,r12	;0xb746
    905e:	4d 43       	clr.b	r13		;
    9060:	0d 9c       	cmp	r12,	r13	;
    9062:	01 34       	jge	$+4      	;abs 0x9066

00009064 <.L1>:
    chSysLockFromISR();
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
  }
}
    9064:	30 41       	ret			

00009066 <.L3>:
    chSemSignalI(&bsp->sem);
    9066:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    906a:	b0 12 ac 46 	call	#18092		;#0x46ac

0000906e <.LBE44>:
    906e:	fa 3f       	jmp	$-10     	;abs 0x9064

00009070 <fram_block_cb>:
    9070:	1c 42       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00009072 <L0>:
  if (bsp->sem.cnt < (cnt_t)1) {
    9072:	46 b7       	bit.b	r7,	r6	;

00009074 <.LVL8>:
    9074:	4d 43       	clr.b	r13		;
    9076:	0d 9c       	cmp	r12,	r13	;
    9078:	01 34       	jge	$+4      	;abs 0x907c

0000907a <.L4>:
void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
}
    907a:	30 41       	ret			

0000907c <.L6>:
    chSemSignalI(&bsp->sem);
    907c:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    9080:	b0 12 ac 46 	call	#18092		;#0x46ac

00009084 <.LBE48>:
    9084:	fa 3f       	jmp	$-10     	;abs 0x907a

00009086 <clamp_err>:
    9086:	3c f0       	and,		r12	;Warning: disassembly unreliable - not enough bytes available

00009088 <L0>:
static uint8_t clamp_err(uint8_t value) {
    9088:	ff 00       	suba	r0,	r15	;

0000908a <.Loc.165.1>:
  if ((value & 0x10) && value != 0x10) {
    908a:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    908e:	0a 24       	jz	$+22     	;abs 0x90a4

00009090 <.Loc.165.1>:
    9090:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    9094:	07 24       	jz	$+16     	;abs 0x90a4

00009096 <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    9096:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000909a <.LVL13>:
    909a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000909e <.LVL14>:
    return 0x10;
    909e:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000090a2 <.L9>:
}
    90a2:	30 41       	ret			

000090a4 <.L8>:
  if ((value & 0x08) && value != 0x08) {
    90a4:	3c b2       	bit	#8,	r12	;r2 As==11
    90a6:	08 24       	jz	$+18     	;abs 0x90b8

000090a8 <.Loc.169.1>:
    90a8:	3c 92       	cmp	#8,	r12	;r2 As==11
    90aa:	06 24       	jz	$+14     	;abs 0x90b8

000090ac <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    90ac:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    90b0:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000090b4 <.LVL15>:
    return 0x08;
    90b4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    90b6:	f5 3f       	jmp	$-20     	;abs 0x90a2

000090b8 <.L10>:
  if ((value & 0x04) && value != 0x04) {
    90b8:	2c b2       	bit	#4,	r12	;r2 As==10
    90ba:	08 24       	jz	$+18     	;abs 0x90cc

000090bc <.Loc.173.1>:
    90bc:	2c 92       	cmp	#4,	r12	;r2 As==10
    90be:	06 24       	jz	$+14     	;abs 0x90cc

000090c0 <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    90c0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    90c4:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000090c8 <.LVL16>:
    return 0x04;
    90c8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    90ca:	eb 3f       	jmp	$-40     	;abs 0x90a2

000090cc <.L11>:
  if ((value & 0x02) && value != 0x02) {
    90cc:	2c b3       	bit	#2,	r12	;r3 As==10
    90ce:	08 24       	jz	$+18     	;abs 0x90e0

000090d0 <.Loc.177.1>:
    90d0:	2c 93       	cmp	#2,	r12	;r3 As==10
    90d2:	06 24       	jz	$+14     	;abs 0x90e0

000090d4 <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    90d4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    90d8:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000090dc <.LVL17>:
    return 0x02;
    90dc:	6c 43       	mov.b	#2,	r12	;r3 As==10
    90de:	e1 3f       	jmp	$-60     	;abs 0x90a2

000090e0 <.L12>:
  if ((value & 0x01) && value != 0x01) {
    90e0:	1c b3       	bit	#1,	r12	;r3 As==01
    90e2:	02 24       	jz	$+6      	;abs 0x90e8

000090e4 <.Loc.181.1>:
    90e4:	1c 93       	cmp	#1,	r12	;r3 As==01
    90e6:	09 20       	jnz	$+20     	;abs 0x90fa

000090e8 <.L13>:
  if (value & 0xD0) {
    90e8:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    90ec:	da 27       	jz	$-74     	;abs 0x90a2

000090ee <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    90ee:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    90f2:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

000090f6 <.LVL18>:
    return 0x00;
    90f6:	4c 43       	clr.b	r12		;
    90f8:	d4 3f       	jmp	$-86     	;abs 0x90a2

000090fa <.L14>:
    elyErrorSignal(ErrRegClip);
    90fa:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    90fe:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00009102 <.LVL19>:
    return 0x01;
    9102:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9104:	ce 3f       	jmp	$-98     	;abs 0x90a2

00009106 <clamp>:
    9106:	1a 15       	pushm	#2,	r10	;16-bit words

00009108 <.LCFI0>:
static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    9108:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    910c:	4a 4d       	mov.b	r13,	r10	;
    910e:	49 4e       	mov.b	r14,	r9	;

00009110 <L0>:
  if (value < min) {
    9110:	4c 9a       	cmp.b	r10,	r12	;
    9112:	04 28       	jnc	$+10     	;abs 0x911c

00009114 <.Loc.157.1>:
  else if (value > max) {
    9114:	49 9c       	cmp.b	r12,	r9	;
    9116:	08 28       	jnc	$+18     	;abs 0x9128

00009118 <.L17>:
}
    9118:	19 17       	popm	#2,	r10	;16-bit words
    911a:	30 41       	ret			

0000911c <.L18>:
    elyErrorSignal(ErrRegClip);
    911c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9120:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00009124 <.LVL23>:
    value = min;
    9124:	0c 4a       	mov	r10,	r12	;
    9126:	f8 3f       	jmp	$-14     	;abs 0x9118

00009128 <.L19>:
    elyErrorSignal(ErrRegClip);
    9128:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    912c:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00009130 <.LVL25>:
    value = max;
    9130:	0c 49       	mov	r9,	r12	;
    9132:	f2 3f       	jmp	$-26     	;abs 0x9118

00009134 <clamps>:
    9134:	1a 15       	pushm	#2,	r10	;16-bit words

00009136 <.LCFI1>:
static uint8_t clamps(uint8_t value, int8_t min, int8_t max) {
    9136:	3c f0       	and,		r12	;Warning: disassembly unreliable - not enough bytes available

00009138 <L0>:
    9138:	ff 00       	suba	r0,	r15	;
    913a:	4a 4d       	mov.b	r13,	r10	;
    913c:	8a 11       	sxt	r10		;
    913e:	49 4e       	mov.b	r14,	r9	;
    9140:	89 11       	sxt	r9		;

00009142 <.Loc.194.1>:
  if ((int8_t)(value) < min) {
    9142:	4d 4c       	mov.b	r12,	r13	;

00009144 <.LVL27>:
    9144:	8d 11       	sxt	r13		;
    9146:	4d 9a       	cmp.b	r10,	r13	;
    9148:	04 38       	jl	$+10     	;abs 0x9152

0000914a <.Loc.198.1>:
  else if ((int8_t)(value) > max) {
    914a:	49 9d       	cmp.b	r13,	r9	;
    914c:	08 38       	jl	$+18     	;abs 0x915e

0000914e <.L22>:
}
    914e:	19 17       	popm	#2,	r10	;16-bit words
    9150:	30 41       	ret			

00009152 <.L23>:
    elyErrorSignal(ErrRegClip);
    9152:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009156 <.LVL30>:
    9156:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000915a <.LVL31>:
    value = (uint8_t)(min);
    915a:	4c 4a       	mov.b	r10,	r12	;

0000915c <.LVL32>:
    915c:	f8 3f       	jmp	$-14     	;abs 0x914e

0000915e <.L24>:
    elyErrorSignal(ErrRegClip);
    915e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9162:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

00009166 <.LVL34>:
    value = (uint8_t)(max);
    9166:	4c 49       	mov.b	r9,	r12	;

00009168 <.LVL35>:
    9168:	f2 3f       	jmp	$-26     	;abs 0x914e

0000916a <fram_reg>:
    916a:	3a 15       	pushm	#4,	r10	;16-bit words

0000916c <.LCFI2>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    916c:	21 83       	decd	r1		;

0000916e <L0>:
    916e:	4a 4c       	mov.b	r12,	r10	;
    9170:	48 4d       	mov.b	r13,	r8	;
    9172:	47 4e       	mov.b	r14,	r7	;
    9174:	09 4f       	mov	r15,	r9	;

00009176 <.LBB49>:
  _disable_interrupts();
    9176:	32 c2       	dint			

00009178 <.Loc.348.3>:
  asm volatile("nop");
    9178:	03 43       	nop			

0000917a <.LBE49>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    917a:	4d 43       	clr.b	r13		;

0000917c <.LVL37>:
    917c:	0c 41       	mov	r1,	r12	;

0000917e <.LVL38>:
    917e:	b0 12 52 a2 	call	#-23982	;#0xa252

00009182 <.LBB51>:
  asm volatile("nop");
    9182:	03 43       	nop			

00009184 <.Loc.356.3>:
  _enable_interrupts();
    9184:	32 d2       	eint			
    9186:	03 43       	nop			

00009188 <.LBE51>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    9188:	2b 41       	mov	@r1,	r11	;
    918a:	38 53       	add	#-1,	r8	;r3 As==11

0000918c <.LVL40>:
    918c:	47 18 08 58 	rpt #8 { rlax.w	r8		;

00009190 <.LVL41>:
    9190:	0c 48       	mov	r8,	r12	;
    9192:	0d 48       	mov	r8,	r13	;
    9194:	4e 18 0d 11 	rpt #15 { rrax.w	r13		;
    9198:	4e 47       	mov.b	r7,	r14	;
    919a:	0f 43       	clr	r15		;
    919c:	0c 5e       	add	r14,	r12	;
    919e:	0d 6f       	addc	r15,	r13	;
    91a0:	0c 53       	add	#0,	r12	;r3 As==00
    91a2:	8b 4c 00 00 	mov	r12,	0(r11)	;
    91a6:	1d 63       	addc	#1,	r13	;r3 As==01
    91a8:	8b 4d 02 00 	mov	r13,	2(r11)	;

000091ac <.Loc.225.1>:
  req->read = read;
    91ac:	2c 41       	mov	@r1,	r12	;
    91ae:	4d 4a       	mov.b	r10,	r13	;
    91b0:	5d f3       	and.b	#1,	r13	;r3 As==01
    91b2:	4d 5d       	rla.b	r13		;
    91b4:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    91b8:	6e c3       	bic.b	#2,	r14	;r3 As==10
    91ba:	4e dd       	bis.b	r13,	r14	;
    91bc:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

000091c0 <.Loc.226.1>:
  req->size = 1;
    91c0:	1d 4c 04 00 	mov	4(r12),	r13	;
    91c4:	7d f0 03 00 	and.b	#3,	r13	;
    91c8:	2d d2       	bis	#4,	r13	;r2 As==10
    91ca:	8c 4d 04 00 	mov	r13,	4(r12)	;
    91ce:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    91d2:	06 00 

000091d4 <.Loc.227.1>:
  req->buffer = valuep;
    91d4:	8c 49 08 00 	mov	r9,	8(r12)	;

000091d8 <.Loc.228.1>:
  req->callback = fram_reg_cb;
    91d8:	bc 40 4c 90 	mov	#-28596,10(r12)	;#0x904c, 0x000a
    91dc:	0a 00 

000091de <.Loc.231.1>:
  elyFramPostRequest(req);
    91de:	b0 12 3a a2 	call	#-24006	;#0xa23a

000091e2 <.LVL42>:
}
    91e2:	21 53       	incd	r1		;
    91e4:	37 17       	popm	#4,	r10	;16-bit words
    91e6:	30 41       	ret			

000091e8 <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    91e8:	3a 15       	pushm	#4,	r10	;16-bit words

000091ea <.LCFI4>:
    91ea:	31 80 06 00 	sub	#6,	r1	;

000091ee <.LCFI5>:
    91ee:	4a 4c       	mov.b	r12,	r10	;
    91f0:	48 4d       	mov.b	r13,	r8	;
    91f2:	47 4e       	mov.b	r14,	r7	;
    91f4:	09 4f       	mov	r15,	r9	;

000091f6 <.LBB53>:
  _disable_interrupts();
    91f6:	32 c2       	dint			

000091f8 <.Loc.348.3>:
  asm volatile("nop");
    91f8:	03 43       	nop			

000091fa <.LBE53>:
  fram_req_t * req;
  
  chSysLock();
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    91fa:	4d 43       	clr.b	r13		;

000091fc <.LVL44>:
    91fc:	0c 41       	mov	r1,	r12	;

000091fe <.LVL45>:
    91fe:	2c 52       	add	#4,	r12	;r2 As==10
    9200:	b0 12 52 a2 	call	#-23982	;#0xa252

00009204 <.LBB55>:
  asm volatile("nop");
    9204:	03 43       	nop			

00009206 <.Loc.356.3>:
  _enable_interrupts();
    9206:	32 d2       	eint			
    9208:	03 43       	nop			

0000920a <.LBE55>:
  chSysUnlock();
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    920a:	1b 41 04 00 	mov	4(r1),	r11	;
    920e:	38 53       	add	#-1,	r8	;r3 As==11

00009210 <.LVL47>:
    9210:	47 18 08 58 	rpt #8 { rlax.w	r8		;

00009214 <.LVL48>:
    9214:	0c 48       	mov	r8,	r12	;
    9216:	0d 48       	mov	r8,	r13	;
    9218:	4e 18 0d 11 	rpt #15 { rrax.w	r13		;
    921c:	4e 47       	mov.b	r7,	r14	;
    921e:	0f 43       	clr	r15		;
    9220:	0c 5e       	add	r14,	r12	;
    9222:	0d 6f       	addc	r15,	r13	;
    9224:	0c 53       	add	#0,	r12	;r3 As==00
    9226:	8b 4c 00 00 	mov	r12,	0(r11)	;
    922a:	1d 63       	addc	#1,	r13	;r3 As==01
    922c:	8b 4d 02 00 	mov	r13,	2(r11)	;

00009230 <.Loc.251.1>:
  req->read = read;
    9230:	1c 41 04 00 	mov	4(r1),	r12	;
    9234:	4d 4a       	mov.b	r10,	r13	;
    9236:	5d f3       	and.b	#1,	r13	;r3 As==01
    9238:	4d 5d       	rla.b	r13		;
    923a:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    923e:	6e c3       	bic.b	#2,	r14	;r3 As==10
    9240:	4e dd       	bis.b	r13,	r14	;
    9242:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

00009246 <.Loc.252.1>:
  req->size = n;
    9246:	5d 41 10 00 	mov.b	16(r1),	r13	;0x00010
    924a:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    924e:	00 00 
    9250:	2d 41       	mov	@r1,	r13	;
    9252:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    9256:	1e 4c 04 00 	mov	4(r12),	r14	;
    925a:	7e f0 03 00 	and.b	#3,	r14	;
    925e:	0e dd       	bis	r13,	r14	;
    9260:	8c 4e 04 00 	mov	r14,	4(r12)	;

00009264 <.LVL49>:
    9264:	2e 41       	mov	@r1,	r14	;
    9266:	0d 4e       	mov	r14,	r13	;
    9268:	5d 03       	rrum	#1,	r13	;
    926a:	4c 18 0d 11 	rpt #13 { rrax.w	r13		;
    926e:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    9272:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
    9276:	4e dd       	bis.b	r13,	r14	;
    9278:	0f 01       	mova	@r1,	r15	;
    927a:	0f 14       	pushm.a	#1,	r15	;20-bit words
    927c:	0d 17       	popm	#1,	r13	;16-bit words
    927e:	0d 17       	popm	#1,	r13	;16-bit words
    9280:	5d f3       	and.b	#1,	r13	;r3 As==01
    9282:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    9286:	6e c2       	bic.b	#4,	r14	;r2 As==10
    9288:	4e dd       	bis.b	r13,	r14	;
    928a:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000928e <.Loc.253.1>:
  req->buffer = buffer;
    928e:	8c 49 08 00 	mov	r9,	8(r12)	;

00009292 <.Loc.254.1>:
  req->callback = fram_block_cb;
    9292:	bc 40 70 90 	mov	#-28560,10(r12)	;#0x9070, 0x000a
    9296:	0a 00 

00009298 <.Loc.257.1>:
  
  /* TODO handle failure */
  elyFramPostRequest(req);
    9298:	b0 12 3a a2 	call	#-24006	;#0xa23a

0000929c <.LVL50>:
}
    929c:	31 50 06 00 	add	#6,	r1	;
    92a0:	37 17       	popm	#4,	r10	;16-bit words
    92a2:	30 41       	ret			

000092a4 <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    92a4:	4e 4c       	mov.b	r12,	r14	;
    92a6:	4c 4d       	mov.b	r13,	r12	;

000092a8 <.LVL52>:
  switch(addr) {
    92a8:	3e 90 19 00 	cmp	#25,	r14	;#0x0019
    92ac:	02 20       	jnz	$+6      	;abs 0x92b2
    92ae:	80 00 d6 97 	mova	#38870,	r0	;0x097d6
    92b2:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019

000092b6 <.LVL53>:
    92b6:	4d 9e       	cmp.b	r14,	r13	;
    92b8:	96 28       	jnc	$+302    	;abs 0x93e6
    92ba:	3e 92       	cmp	#8,	r14	;r2 As==11
    92bc:	e1 25       	jz	$+964    	;abs 0x9680
    92be:	7f 42       	mov.b	#8,	r15	;r2 As==11
    92c0:	4f 9e       	cmp.b	r14,	r15	;
    92c2:	3b 28       	jnc	$+120    	;abs 0x933a
    92c4:	3e 90 03 00 	cmp	#3,	r14	;
    92c8:	6d 25       	jz	$+732    	;abs 0x95a4
    92ca:	7d 40 03 00 	mov.b	#3,	r13	;
    92ce:	4d 9e       	cmp.b	r14,	r13	;
    92d0:	15 2c       	jc	$+44     	;abs 0x92fc
    92d2:	3e 90 05 00 	cmp	#5,	r14	;
    92d6:	9a 25       	jz	$+822    	;abs 0x960c
    92d8:	6d 42       	mov.b	#4,	r13	;r2 As==10
    92da:	4d 9e       	cmp.b	r14,	r13	;
    92dc:	6c 2d       	jc	$+730    	;abs 0x95b6
    92de:	3e 90 06 00 	cmp	#6,	r14	;
    92e2:	b7 25       	jz	$+880    	;abs 0x9652
    92e4:	3e 90 07 00 	cmp	#7,	r14	;
    92e8:	c2 20       	jnz	$+390    	;abs 0x946e

000092ea <.Loc.326.1>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB) {
        value = clamp(value, RX_BAND_MIN_HMB, 0xFF);
      }
      break;
    case RegRXFreqMsb:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    92ea:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a

000092ee <.LVL54>:
    92ee:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    92f2:	b0 12 06 91 	call	#-28410	;#0x9106

000092f6 <.LVL55>:
    92f6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000092fa <.LVL56>:
      break;
    92fa:	a2 3c       	jmp	$+326    	;abs 0x9440

000092fc <.L89>:
  switch(addr) {
    92fc:	1e 93       	cmp	#1,	r14	;r3 As==01
    92fe:	16 25       	jz	$+558    	;abs 0x952c
    9300:	5f 43       	mov.b	#1,	r15	;r3 As==01
    9302:	4f 9e       	cmp.b	r14,	r15	;
    9304:	37 29       	jnc	$+624    	;abs 0x9574

00009306 <.Loc.263.1>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    9306:	5d 42 27 b3 	mov.b	&0xb327,r13	;0xb327
    930a:	3d 90 1c 00 	cmp	#28,	r13	;#0x001c
    930e:	fc 24       	jz	$+506    	;abs 0x9508

00009310 <.L69>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    9310:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    9314:	95 20       	jnz	$+300    	;abs 0x9440

00009316 <.Loc.269.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MIN_HMB &&
    9316:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

0000931a <.Loc.268.1>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    931a:	fd 90 cf ff 	cmp.b	#-49,	2(r13)	;#0xffcf
    931e:	02 00 
    9320:	8f 20       	jnz	$+288    	;abs 0x9440

00009322 <.Loc.269.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MIN_HMB &&
    9322:	fd 90 0e 00 	cmp.b	#14,	1(r13)	;#0x000e
    9326:	01 00 
    9328:	8b 20       	jnz	$+280    	;abs 0x9440

0000932a <.Loc.271.1>:
        value = clamp(value, TX_BAND_MIN_LSB, 0xFF);
    932a:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    932c:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    9330:	b0 12 06 91 	call	#-28410	;#0x9106

00009334 <.LVL58>:
    9334:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009338 <.LVL59>:
    9338:	83 3c       	jmp	$+264    	;abs 0x9440

0000933a <.L32>:
  switch(addr) {
    933a:	3e 90 0c 00 	cmp	#12,	r14	;#0x000c
    933e:	e2 25       	jz	$+966    	;abs 0x9704
    9340:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    9344:	4f 9e       	cmp.b	r14,	r15	;
    9346:	30 2c       	jc	$+98     	;abs 0x93a8
    9348:	3e 90 0e 00 	cmp	#14,	r14	;#0x000e
    934c:	02 20       	jnz	$+6      	;abs 0x9352
    934e:	80 00 94 97 	mova	#38804,	r0	;0x09794
    9352:	7f 40 0d 00 	mov.b	#13,	r15	;#0x000d
    9356:	4f 9e       	cmp.b	r14,	r15	;
    9358:	02 28       	jnc	$+6      	;abs 0x935e
    935a:	80 00 54 97 	mova	#38740,	r0	;0x09754
    935e:	3e 90 0f 00 	cmp	#15,	r14	;#0x000f
    9362:	02 20       	jnz	$+6      	;abs 0x9368
    9364:	80 00 ae 97 	mova	#38830,	r0	;0x097ae
    9368:	3e 90 18 00 	cmp	#24,	r14	;#0x0018
    936c:	80 20       	jnz	$+258    	;abs 0x946e

0000936e <.Loc.395.1>:
      break;
    case RegRXDevMsb:
      value = clamp(value, RX_DEV_MIN_MSB, RX_DEV_MAX_MSB);
      break;
    case RegTXBRLsb:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    936e:	5d 42 3f b3 	mov.b	&0xb33f,r13	;0xb33f
    9372:	0d 93       	cmp	#0,	r13	;r3 As==00
    9374:	07 20       	jnz	$+16     	;abs 0x9384

00009376 <.Loc.396.1>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB &&
    9376:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000937a <.Loc.395.1>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    937a:	ee 92 1a 00 	cmp.b	#4,	26(r14)	;r2 As==10, 0x001a
    937e:	02 20       	jnz	$+6      	;abs 0x9384
    9380:	80 00 bc 97 	mova	#38844,	r0	;0x097bc

00009384 <.L79>:
          bank0p[RegTXBRLmb] == TX_BR_MAX_LMB) {
        value = clamp(value, 0, TX_BR_MAX_LSB);
      }
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    9384:	0d 93       	cmp	#0,	r13	;r3 As==00
    9386:	5c 20       	jnz	$+186    	;abs 0x9440

00009388 <.Loc.401.1>:
          bank0p[RegTXBRHmb] == TX_BR_MIN_HMB &&
    9388:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

0000938c <.Loc.400.1>:
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    938c:	cd 93 1a 00 	cmp.b	#0,	26(r13)	;r3 As==00, 0x001a
    9390:	57 20       	jnz	$+176    	;abs 0x9440

00009392 <.Loc.401.1>:
          bank0p[RegTXBRHmb] == TX_BR_MIN_HMB &&
    9392:	ed 92 19 00 	cmp.b	#4,	25(r13)	;r2 As==10, 0x0019
    9396:	54 20       	jnz	$+170    	;abs 0x9440

00009398 <.Loc.403.1>:
          bank0p[RegTXBRLmb] == TX_BR_MIN_LMB) {
        value = clamp(value, TX_BR_MIN_LSB, 0xFF);
    9398:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    939a:	7d 40 b0 ff 	mov.b	#-80,	r13	;#0xffb0
    939e:	b0 12 06 91 	call	#-28410	;#0x9106

000093a2 <.LVL61>:
    93a2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000093a6 <.LVL62>:
    93a6:	4c 3c       	jmp	$+154    	;abs 0x9440

000093a8 <.L92>:
  switch(addr) {
    93a8:	3e 90 0a 00 	cmp	#10,	r14	;#0x000a
    93ac:	97 25       	jz	$+816    	;abs 0x96dc
    93ae:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    93b2:	4d 9e       	cmp.b	r14,	r13	;
    93b4:	a0 29       	jnc	$+834    	;abs 0x96f6

000093b6 <.Loc.341.1>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    93b6:	5d 42 2f b3 	mov.b	&0xb32f,r13	;0xb32f
    93ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    93bc:	06 20       	jnz	$+14     	;abs 0x93ca

000093be <.Loc.342.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB) {
    93be:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

000093c2 <.Loc.341.1>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    93c2:	fe 90 03 00 	cmp.b	#3,	10(r14)	; 0x000a
    93c6:	0a 00 
    93c8:	82 25       	jz	$+774    	;abs 0x96ce

000093ca <.L76>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    93ca:	0d 93       	cmp	#0,	r13	;r3 As==00
    93cc:	39 20       	jnz	$+116    	;abs 0x9440

000093ce <.Loc.346.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MIN_HMB) {
    93ce:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

000093d2 <.Loc.345.1>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    93d2:	cd 93 0a 00 	cmp.b	#0,	10(r13)	;r3 As==00, 0x000a
    93d6:	34 20       	jnz	$+106    	;abs 0x9440

000093d8 <.Loc.347.1>:
        value = clamp(value, TX_DEV_MIN_LMB, 0xFF);
    93d8:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    93da:	6d 43       	mov.b	#2,	r13	;r3 As==10
    93dc:	b0 12 06 91 	call	#-28410	;#0x9106

000093e0 <.LVL64>:
    93e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000093e4 <.LVL65>:
    93e4:	2d 3c       	jmp	$+92     	;abs 0x9440

000093e6 <.L30>:
  switch(addr) {
    93e6:	3e 90 24 00 	cmp	#36,	r14	;#0x0024
    93ea:	02 20       	jnz	$+6      	;abs 0x93f0
    93ec:	80 00 f6 98 	mova	#39158,	r0	;0x098f6
    93f0:	7d 40 24 00 	mov.b	#36,	r13	;#0x0024
    93f4:	4d 9e       	cmp.b	r14,	r13	;
    93f6:	4f 28       	jnc	$+160    	;abs 0x9496
    93f8:	3e 90 1d 00 	cmp	#29,	r14	;#0x001d
    93fc:	02 20       	jnz	$+6      	;abs 0x9402
    93fe:	80 00 7e 98 	mova	#39038,	r0	;0x0987e
    9402:	7f 40 1d 00 	mov.b	#29,	r15	;#0x001d
    9406:	4f 9e       	cmp.b	r14,	r15	;
    9408:	1c 2c       	jc	$+58     	;abs 0x9442
    940a:	3e 90 1f 00 	cmp	#31,	r14	;#0x001f
    940e:	02 20       	jnz	$+6      	;abs 0x9414
    9410:	80 00 e6 98 	mova	#39142,	r0	;0x098e6
    9414:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    9418:	4f 9e       	cmp.b	r14,	r15	;
    941a:	02 28       	jnc	$+6      	;abs 0x9420
    941c:	80 00 c8 98 	mova	#39112,	r0	;0x098c8
    9420:	3e 90 21 00 	cmp	#33,	r14	;#0x0021
    9424:	21 20       	jnz	$+68     	;abs 0x9468

00009426 <.Loc.461.1>:
      break;
    case RegRXBRMsb:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
      break;
    case RegOutputPower:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    9426:	4e 43       	clr.b	r14		;
    9428:	7d 40 4f 00 	mov.b	#79,	r13	;#0x004f
    942c:	b0 12 06 91 	call	#-28410	;#0x9106

00009430 <.LVL67>:
    9430:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009434 <.L61>:
    case RegUARTBaudLsb:
    case RegSCCommBaudLsb:
      value = clamp(value, 1, 0xFF);
    9434:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9436:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9438:	b0 12 06 91 	call	#-28410	;#0x9106

0000943c <.LVL69>:
    943c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009440 <.L65>:
        value = elyDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    9440:	30 41       	ret			

00009442 <.L96>:
  switch(addr) {
    9442:	3e 90 1b 00 	cmp	#27,	r14	;#0x001b
    9446:	e5 25       	jz	$+972    	;abs 0x9812
    9448:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b
    944c:	4d 9e       	cmp.b	r14,	r13	;
    944e:	e8 29       	jnc	$+978    	;abs 0x9820

00009450 <.Loc.417.1>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB) {
    9450:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324
    9454:	cd 93 1b 00 	cmp.b	#0,	27(r13)	;r3 As==00, 0x001b
    9458:	f3 23       	jnz	$-24     	;abs 0x9440

0000945a <.Loc.418.1>:
        value = clamp(value, 0, TX_BR_MAX_HMB);
    945a:	6e 42       	mov.b	#4,	r14	;r2 As==10
    945c:	4d 43       	clr.b	r13		;
    945e:	b0 12 06 91 	call	#-28410	;#0x9106

00009462 <.LVL72>:
    9462:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009466 <.LVL73>:
    9466:	ec 3f       	jmp	$-38     	;abs 0x9440

00009468 <.L97>:
  switch(addr) {
    9468:	3e 90 22 00 	cmp	#34,	r14	;#0x0022
    946c:	e3 27       	jz	$-56     	;abs 0x9434

0000946e <.L28>:
      if (addr > 0x80 && addr < 0xBF) {
    946e:	4d 4e       	mov.b	r14,	r13	;
    9470:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    9474:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    9478:	4f 9d       	cmp.b	r13,	r15	;
    947a:	02 28       	jnc	$+6      	;abs 0x9480
    947c:	80 00 24 99 	mova	#39204,	r0	;0x09924

00009480 <.Loc.500.1>:
      else if (addr > 0xC0) {
    9480:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    9484:	4d 9e       	cmp.b	r14,	r13	;
    9486:	dc 2f       	jc	$-70     	;abs 0x9440

00009488 <.Loc.501.1>:
        value = elyDLLClampReg(addr, value);
    9488:	4d 4c       	mov.b	r12,	r13	;
    948a:	4c 4e       	mov.b	r14,	r12	;
    948c:	b0 12 c6 aa 	call	#-21818	;#0xaac6

00009490 <.LVL75>:
    9490:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009494 <.LVL76>:
    9494:	d5 3f       	jmp	$-84     	;abs 0x9440

00009496 <.L52>:
  switch(addr) {
    9496:	3e 90 3a 00 	cmp	#58,	r14	;#0x003a
    949a:	02 20       	jnz	$+6      	;abs 0x94a0
    949c:	80 00 f6 98 	mova	#39158,	r0	;0x098f6
    94a0:	7d 40 3a 00 	mov.b	#58,	r13	;#0x003a
    94a4:	4d 9e       	cmp.b	r14,	r13	;
    94a6:	19 2c       	jc	$+52     	;abs 0x94da
    94a8:	3e 90 40 00 	cmp	#64,	r14	;#0x0040
    94ac:	02 20       	jnz	$+6      	;abs 0x94b2
    94ae:	80 00 14 99 	mova	#39188,	r0	;0x09914
    94b2:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    94b6:	4f 9e       	cmp.b	r14,	r15	;
    94b8:	23 2c       	jc	$+72     	;abs 0x9500
    94ba:	4d 4e       	mov.b	r14,	r13	;
    94bc:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    94c0:	7f 40 05 00 	mov.b	#5,	r15	;
    94c4:	4f 9d       	cmp.b	r13,	r15	;
    94c6:	d3 2b       	jnc	$-88     	;abs 0x946e

000094c8 <.Loc.494.1>:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
    94c8:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    94cc:	7d 40 b0 ff 	mov.b	#-80,	r13	;#0xffb0
    94d0:	b0 12 34 91 	call	#-28364	;#0x9134

000094d4 <.LVL78>:
    94d4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000094d8 <.LVL79>:
      break;
    94d8:	b3 3f       	jmp	$-152    	;abs 0x9440

000094da <.L100>:
  switch(addr) {
    94da:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    94de:	4f 9e       	cmp.b	r14,	r15	;
    94e0:	0b 28       	jnc	$+24     	;abs 0x94f8
    94e2:	7d 40 29 00 	mov.b	#41,	r13	;#0x0029
    94e6:	4d 9e       	cmp.b	r14,	r13	;
    94e8:	02 2c       	jc	$+6      	;abs 0x94ee
    94ea:	80 00 08 99 	mova	#39176,	r0	;0x09908
    94ee:	3e 90 25 00 	cmp	#37,	r14	;#0x0025
    94f2:	bd 23       	jnz	$-132    	;abs 0x946e

000094f4 <.L84>:
      return 0; /* this is purely efficiency */
    94f4:	4c 43       	clr.b	r12		;
    94f6:	a4 3f       	jmp	$-182    	;abs 0x9440

000094f8 <.L63>:
  switch(addr) {
    94f8:	3e 90 38 00 	cmp	#56,	r14	;#0x0038
    94fc:	9b 27       	jz	$-200    	;abs 0x9434
    94fe:	b7 3f       	jmp	$-144    	;abs 0x946e

00009500 <.L101>:
    9500:	3e 90 3b 00 	cmp	#59,	r14	;#0x003b
    9504:	f7 27       	jz	$-16     	;abs 0x94f4
    9506:	b3 3f       	jmp	$-152    	;abs 0x946e

00009508 <.L91>:
          bank0p[RegTXFreqHmb] == TX_BAND_MAX_HMB &&
    9508:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000950c <.Loc.263.1>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    950c:	fe 90 03 00 	cmp.b	#3,	2(r14)	;
    9510:	02 00 
    9512:	fe 22       	jnz	$-514    	;abs 0x9310

00009514 <.Loc.264.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MAX_HMB &&
    9514:	fe 90 a1 ff 	cmp.b	#-95,	1(r14)	;#0xffa1
    9518:	01 00 
    951a:	fa 22       	jnz	$-522    	;abs 0x9310

0000951c <.Loc.266.1>:
        value = clamp(value, 0, TX_BAND_MAX_LSB);
    951c:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    9520:	4d 43       	clr.b	r13		;
    9522:	b0 12 06 91 	call	#-28410	;#0x9106

00009526 <.LVL81>:
    9526:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000952a <.LVL82>:
    952a:	8a 3f       	jmp	$-234    	;abs 0x9440

0000952c <.L35>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    952c:	5d 42 27 b3 	mov.b	&0xb327,r13	;0xb327
    9530:	3d 90 1c 00 	cmp	#28,	r13	;#0x001c
    9534:	11 24       	jz	$+36     	;abs 0x9558

00009536 <.L70>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    9536:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    953a:	82 23       	jnz	$-250    	;abs 0x9440

0000953c <.Loc.280.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MIN_HMB) {
    953c:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

00009540 <.Loc.279.1>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    9540:	fd 90 cf ff 	cmp.b	#-49,	2(r13)	;#0xffcf
    9544:	02 00 
    9546:	7c 23       	jnz	$-262    	;abs 0x9440

00009548 <.Loc.281.1>:
        value = clamp(value, TX_BAND_MIN_LMB, 0xFF);
    9548:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    954a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    954e:	b0 12 06 91 	call	#-28410	;#0x9106

00009552 <.LVL84>:
    9552:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009556 <.LVL85>:
    9556:	74 3f       	jmp	$-278    	;abs 0x9440

00009558 <.L102>:
          bank0p[RegTXFreqHmb] == TX_BAND_MAX_HMB) {
    9558:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000955c <.Loc.275.1>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    955c:	fe 90 03 00 	cmp.b	#3,	2(r14)	;
    9560:	02 00 
    9562:	e9 23       	jnz	$-44     	;abs 0x9536

00009564 <.Loc.277.1>:
        value = clamp(value, 0, TX_BAND_MAX_LMB);
    9564:	7e 40 a1 ff 	mov.b	#-95,	r14	;#0xffa1
    9568:	4d 43       	clr.b	r13		;
    956a:	b0 12 06 91 	call	#-28410	;#0x9106

0000956e <.LVL87>:
    956e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009572 <.LVL88>:
    9572:	66 3f       	jmp	$-306    	;abs 0x9440

00009574 <.L90>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB) {
    9574:	5d 42 27 b3 	mov.b	&0xb327,r13	;0xb327
    9578:	3d 90 1c 00 	cmp	#28,	r13	;#0x001c
    957c:	0b 24       	jz	$+24     	;abs 0x9594

0000957e <.Loc.288.1>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB) {
    957e:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    9582:	5e 23       	jnz	$-322    	;abs 0x9440

00009584 <.Loc.289.1>:
        value = clamp(value, TX_BAND_MIN_HMB, 0xFF);
    9584:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9586:	7d 40 cf ff 	mov.b	#-49,	r13	;#0xffcf
    958a:	b0 12 06 91 	call	#-28410	;#0x9106

0000958e <.LVL90>:
    958e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009592 <.LVL91>:
    9592:	56 3f       	jmp	$-338    	;abs 0x9440

00009594 <.L103>:
        value = clamp(value, 0, TX_BAND_MAX_HMB);
    9594:	7e 40 03 00 	mov.b	#3,	r14	;
    9598:	4d 43       	clr.b	r13		;
    959a:	b0 12 06 91 	call	#-28410	;#0x9106

0000959e <.LVL93>:
    959e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000095a2 <.LVL94>:
    95a2:	4e 3f       	jmp	$-354    	;abs 0x9440

000095a4 <.L33>:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    95a4:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    95a8:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    95ac:	b0 12 06 91 	call	#-28410	;#0x9106

000095b0 <.LVL96>:
    95b0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000095b4 <.LVL97>:
      break;
    95b4:	45 3f       	jmp	$-372    	;abs 0x9440

000095b6 <.L39>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    95b6:	5d 42 2b b3 	mov.b	&0xb32b,r13	;0xb32b
    95ba:	3d 90 1a 00 	cmp	#26,	r13	;#0x001a
    95be:	15 24       	jz	$+44     	;abs 0x95ea

000095c0 <.L72>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    95c0:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    95c4:	3d 23       	jnz	$-388    	;abs 0x9440

000095c6 <.Loc.302.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MIN_HMB &&
    95c6:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

000095ca <.Loc.301.1>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    95ca:	fd 90 b8 ff 	cmp.b	#-72,	6(r13)	;#0xffb8
    95ce:	06 00 
    95d0:	37 23       	jnz	$-400    	;abs 0x9440

000095d2 <.Loc.302.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MIN_HMB &&
    95d2:	fd 90 2a 00 	cmp.b	#42,	5(r13)	;#0x002a
    95d6:	05 00 
    95d8:	33 23       	jnz	$-408    	;abs 0x9440

000095da <.Loc.304.1>:
        value = clamp(value, RX_BAND_MIN_LSB, 0xFF);
    95da:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    95dc:	7d 40 e0 ff 	mov.b	#-32,	r13	;#0xffe0
    95e0:	b0 12 06 91 	call	#-28410	;#0x9106

000095e4 <.LVL99>:
    95e4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000095e8 <.LVL100>:
    95e8:	2b 3f       	jmp	$-424    	;abs 0x9440

000095ea <.L104>:
          bank0p[RegRXFreqHmb] == RX_BAND_MAX_HMB &&
    95ea:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

000095ee <.Loc.296.1>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    95ee:	ee 92 06 00 	cmp.b	#4,	6(r14)	;r2 As==10
    95f2:	e6 23       	jnz	$-50     	;abs 0x95c0

000095f4 <.Loc.297.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MAX_HMB &&
    95f4:	fe 90 76 00 	cmp.b	#118,	5(r14)	;#0x0076
    95f8:	05 00 
    95fa:	e2 23       	jnz	$-58     	;abs 0x95c0

000095fc <.Loc.299.1>:
        value = clamp(value, 0, RX_BAND_MAX_LSB);
    95fc:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    9600:	4d 43       	clr.b	r13		;
    9602:	b0 12 06 91 	call	#-28410	;#0x9106

00009606 <.LVL102>:
    9606:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000960a <.LVL103>:
    960a:	1a 3f       	jmp	$-458    	;abs 0x9440

0000960c <.L38>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    960c:	5d 42 2b b3 	mov.b	&0xb32b,r13	;0xb32b
    9610:	3d 90 1a 00 	cmp	#26,	r13	;#0x001a
    9614:	11 24       	jz	$+36     	;abs 0x9638

00009616 <.L73>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    9616:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    961a:	12 23       	jnz	$-474    	;abs 0x9440

0000961c <.Loc.313.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MIN_HMB) {
    961c:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

00009620 <.Loc.312.1>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    9620:	fd 90 b8 ff 	cmp.b	#-72,	6(r13)	;#0xffb8
    9624:	06 00 
    9626:	0c 23       	jnz	$-486    	;abs 0x9440

00009628 <.Loc.314.1>:
        value = clamp(value, RX_BAND_MIN_LMB, 0xFF);
    9628:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    962a:	7d 40 2a 00 	mov.b	#42,	r13	;#0x002a
    962e:	b0 12 06 91 	call	#-28410	;#0x9106

00009632 <.LVL105>:
    9632:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009636 <.LVL106>:
    9636:	04 3f       	jmp	$-502    	;abs 0x9440

00009638 <.L105>:
          bank0p[RegRXFreqHmb] == RX_BAND_MAX_HMB) {
    9638:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000963c <.Loc.308.1>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    963c:	ee 92 06 00 	cmp.b	#4,	6(r14)	;r2 As==10
    9640:	ea 23       	jnz	$-42     	;abs 0x9616

00009642 <.Loc.310.1>:
        value = clamp(value, 0, RX_BAND_MAX_LMB);
    9642:	7e 40 76 00 	mov.b	#118,	r14	;#0x0076
    9646:	4d 43       	clr.b	r13		;
    9648:	b0 12 06 91 	call	#-28410	;#0x9106

0000964c <.LVL108>:
    964c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009650 <.LVL109>:
    9650:	f7 3e       	jmp	$-528    	;abs 0x9440

00009652 <.L40>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB) {
    9652:	5d 42 2b b3 	mov.b	&0xb32b,r13	;0xb32b
    9656:	3d 90 1a 00 	cmp	#26,	r13	;#0x001a
    965a:	0b 24       	jz	$+24     	;abs 0x9672

0000965c <.Loc.321.1>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB) {
    965c:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    9660:	ef 22       	jnz	$-544    	;abs 0x9440

00009662 <.Loc.322.1>:
        value = clamp(value, RX_BAND_MIN_HMB, 0xFF);
    9662:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9664:	7d 40 b8 ff 	mov.b	#-72,	r13	;#0xffb8
    9668:	b0 12 06 91 	call	#-28410	;#0x9106

0000966c <.LVL111>:
    966c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009670 <.LVL112>:
    9670:	e7 3e       	jmp	$-560    	;abs 0x9440

00009672 <.L106>:
        value = clamp(value, 0, RX_BAND_MAX_HMB);
    9672:	6e 42       	mov.b	#4,	r14	;r2 As==10
    9674:	4d 43       	clr.b	r13		;
    9676:	b0 12 06 91 	call	#-28410	;#0x9106

0000967a <.LVL114>:
    967a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000967e <.LVL115>:
    967e:	e0 3e       	jmp	$-574    	;abs 0x9440

00009680 <.L31>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    9680:	5d 42 2f b3 	mov.b	&0xb32f,r13	;0xb32f
    9684:	0d 93       	cmp	#0,	r13	;r3 As==00
    9686:	06 20       	jnz	$+14     	;abs 0x9694

00009688 <.Loc.330.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB &&
    9688:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000968c <.Loc.329.1>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    968c:	fe 90 03 00 	cmp.b	#3,	10(r14)	; 0x000a
    9690:	0a 00 
    9692:	12 24       	jz	$+38     	;abs 0x96b8

00009694 <.L75>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    9694:	0d 93       	cmp	#0,	r13	;r3 As==00
    9696:	d4 22       	jnz	$-598    	;abs 0x9440

00009698 <.Loc.335.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MIN_HMB &&
    9698:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

0000969c <.Loc.334.1>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    969c:	cd 93 0a 00 	cmp.b	#0,	10(r13)	;r3 As==00, 0x000a
    96a0:	cf 22       	jnz	$-608    	;abs 0x9440

000096a2 <.Loc.335.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MIN_HMB &&
    96a2:	ed 93 09 00 	cmp.b	#2,	9(r13)	;r3 As==10
    96a6:	cc 22       	jnz	$-614    	;abs 0x9440

000096a8 <.Loc.337.1>:
        value = clamp(value, TX_DEV_MIN_LSB, 0xFF);
    96a8:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    96aa:	7d 40 58 00 	mov.b	#88,	r13	;#0x0058
    96ae:	b0 12 06 91 	call	#-28410	;#0x9106

000096b2 <.LVL117>:
    96b2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000096b6 <.LVL118>:
    96b6:	c4 3e       	jmp	$-630    	;abs 0x9440

000096b8 <.L107>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB &&
    96b8:	fe 90 0d 00 	cmp.b	#13,	9(r14)	;#0x000d
    96bc:	09 00 
    96be:	ea 23       	jnz	$-42     	;abs 0x9694

000096c0 <.Loc.332.1>:
        value = clamp(value, 0, TX_DEV_MAX_LSB);
    96c0:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    96c4:	b0 12 06 91 	call	#-28410	;#0x9106

000096c8 <.LVL120>:
    96c8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000096cc <.LVL121>:
    96cc:	b9 3e       	jmp	$-652    	;abs 0x9440

000096ce <.L95>:
        value = clamp(value, 0, TX_DEV_MAX_LMB);
    96ce:	7e 40 0d 00 	mov.b	#13,	r14	;#0x000d
    96d2:	b0 12 06 91 	call	#-28410	;#0x9106

000096d6 <.LVL123>:
    96d6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000096da <.LVL124>:
    96da:	b2 3e       	jmp	$-666    	;abs 0x9440

000096dc <.L44>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB) {
    96dc:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324
    96e0:	cd 93 0b 00 	cmp.b	#0,	11(r13)	;r3 As==00, 0x000b
    96e4:	ad 22       	jnz	$-676    	;abs 0x9440

000096e6 <.Loc.352.1>:
        value = clamp(value, 0, TX_DEV_MAX_HMB);
    96e6:	7e 40 03 00 	mov.b	#3,	r14	;
    96ea:	4d 43       	clr.b	r13		;
    96ec:	b0 12 06 91 	call	#-28410	;#0x9106

000096f0 <.LVL126>:
    96f0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000096f4 <.LVL127>:
    96f4:	a5 3e       	jmp	$-692    	;abs 0x9440

000096f6 <.L94>:
      value = clamp(value, TX_DEV_MIN_MSB, TX_DEV_MAX_MSB);
    96f6:	4e 43       	clr.b	r14		;
    96f8:	4d 4e       	mov.b	r14,	r13	;
    96fa:	b0 12 06 91 	call	#-28410	;#0x9106

000096fe <.LVL129>:
    96fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009702 <.LVL130>:
      break;
    9702:	9e 3e       	jmp	$-706    	;abs 0x9440

00009704 <.L42>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    9704:	5d 42 33 b3 	mov.b	&0xb333,r13	;0xb333
    9708:	0d 93       	cmp	#0,	r13	;r3 As==00
    970a:	06 20       	jnz	$+14     	;abs 0x9718

0000970c <.Loc.363.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB &&
    970c:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

00009710 <.Loc.362.1>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    9710:	fe 90 03 00 	cmp.b	#3,	14(r14)	; 0x000e
    9714:	0e 00 
    9716:	13 24       	jz	$+40     	;abs 0x973e

00009718 <.L77>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    9718:	0d 93       	cmp	#0,	r13	;r3 As==00
    971a:	92 22       	jnz	$-730    	;abs 0x9440

0000971c <.Loc.368.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MIN_HMB &&
    971c:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

00009720 <.Loc.367.1>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    9720:	cd 93 0e 00 	cmp.b	#0,	14(r13)	;r3 As==00, 0x000e
    9724:	8d 22       	jnz	$-740    	;abs 0x9440

00009726 <.Loc.368.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MIN_HMB &&
    9726:	fd 90 80 ff 	cmp.b	#-128,	13(r13)	;#0xff80, 0x000d
    972a:	0d 00 
    972c:	89 22       	jnz	$-748    	;abs 0x9440

0000972e <.Loc.370.1>:
        value = clamp(value, RX_DEV_MIN_LSB, 0xFF);
    972e:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9730:	7d 40 e8 ff 	mov.b	#-24,	r13	;#0xffe8
    9734:	b0 12 06 91 	call	#-28410	;#0x9106

00009738 <.LVL132>:
    9738:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000973c <.LVL133>:
    973c:	81 3e       	jmp	$-764    	;abs 0x9440

0000973e <.L108>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB &&
    973e:	fe 90 0d 00 	cmp.b	#13,	13(r14)	;#0x000d, 0x000d
    9742:	0d 00 
    9744:	e9 23       	jnz	$-44     	;abs 0x9718

00009746 <.Loc.365.1>:
        value = clamp(value, 0, RX_DEV_MAX_LSB);
    9746:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    974a:	b0 12 06 91 	call	#-28410	;#0x9106

0000974e <.LVL135>:
    974e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009752 <.LVL136>:
    9752:	76 3e       	jmp	$-786    	;abs 0x9440

00009754 <.L48>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    9754:	5d 42 33 b3 	mov.b	&0xb333,r13	;0xb333
    9758:	0d 93       	cmp	#0,	r13	;r3 As==00
    975a:	06 20       	jnz	$+14     	;abs 0x9768

0000975c <.Loc.375.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB) {
    975c:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

00009760 <.Loc.374.1>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    9760:	fe 90 03 00 	cmp.b	#3,	14(r14)	; 0x000e
    9764:	0e 00 
    9766:	0f 24       	jz	$+32     	;abs 0x9786

00009768 <.L78>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    9768:	0d 93       	cmp	#0,	r13	;r3 As==00
    976a:	6a 22       	jnz	$-810    	;abs 0x9440

0000976c <.Loc.379.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MIN_HMB) {
    976c:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

00009770 <.Loc.378.1>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    9770:	cd 93 0e 00 	cmp.b	#0,	14(r13)	;r3 As==00, 0x000e
    9774:	65 22       	jnz	$-820    	;abs 0x9440

00009776 <.Loc.380.1>:
        value = clamp(value, RX_DEV_MIN_LMB, 0xFF);
    9776:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9778:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    977c:	b0 12 06 91 	call	#-28410	;#0x9106

00009780 <.LVL138>:
    9780:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009784 <.LVL139>:
    9784:	5d 3e       	jmp	$-836    	;abs 0x9440

00009786 <.L109>:
        value = clamp(value, 0, RX_DEV_MAX_LMB);
    9786:	7e 40 0d 00 	mov.b	#13,	r14	;#0x000d
    978a:	b0 12 06 91 	call	#-28410	;#0x9106

0000978e <.LVL141>:
    978e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009792 <.LVL142>:
    9792:	56 3e       	jmp	$-850    	;abs 0x9440

00009794 <.L47>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB) {
    9794:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324
    9798:	cd 93 0f 00 	cmp.b	#0,	15(r13)	;r3 As==00, 0x000f
    979c:	51 22       	jnz	$-860    	;abs 0x9440

0000979e <.Loc.385.1>:
        value = clamp(value, 0, RX_DEV_MAX_HMB);
    979e:	7e 40 03 00 	mov.b	#3,	r14	;
    97a2:	4d 43       	clr.b	r13		;
    97a4:	b0 12 06 91 	call	#-28410	;#0x9106

000097a8 <.LVL144>:
    97a8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000097ac <.LVL145>:
    97ac:	49 3e       	jmp	$-876    	;abs 0x9440

000097ae <.L49>:
      value = clamp(value, RX_DEV_MIN_MSB, RX_DEV_MAX_MSB);
    97ae:	4e 43       	clr.b	r14		;
    97b0:	4d 4e       	mov.b	r14,	r13	;
    97b2:	b0 12 06 91 	call	#-28410	;#0x9106

000097b6 <.LVL147>:
    97b6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000097ba <.LVL148>:
      break;
    97ba:	42 3e       	jmp	$-890    	;abs 0x9440

000097bc <.L93>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB &&
    97bc:	fe 90 93 ff 	cmp.b	#-109,	25(r14)	;#0xff93, 0x0019
    97c0:	19 00 
    97c2:	02 24       	jz	$+6      	;abs 0x97c8
    97c4:	80 00 84 93 	mova	#37764,	r0	;0x09384

000097c8 <.Loc.398.1>:
        value = clamp(value, 0, TX_BR_MAX_LSB);
    97c8:	7e 40 e0 ff 	mov.b	#-32,	r14	;#0xffe0
    97cc:	b0 12 06 91 	call	#-28410	;#0x9106

000097d0 <.LVL150>:
    97d0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000097d4 <.LVL151>:
    97d4:	35 3e       	jmp	$-916    	;abs 0x9440

000097d6 <.L29>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    97d6:	5d 42 3f b3 	mov.b	&0xb33f,r13	;0xb33f

000097da <.LVL153>:
    97da:	0d 93       	cmp	#0,	r13	;r3 As==00
    97dc:	05 20       	jnz	$+12     	;abs 0x97e8

000097de <.Loc.408.1>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB) {
    97de:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

000097e2 <.Loc.407.1>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    97e2:	ee 92 1a 00 	cmp.b	#4,	26(r14)	;r2 As==10, 0x001a
    97e6:	0e 24       	jz	$+30     	;abs 0x9804

000097e8 <.L80>:
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    97e8:	0d 93       	cmp	#0,	r13	;r3 As==00
    97ea:	2a 22       	jnz	$-938    	;abs 0x9440

000097ec <.Loc.412.1>:
          bank0p[RegTXBRHmb] == TX_BR_MIN_HMB) {
    97ec:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

000097f0 <.Loc.411.1>:
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    97f0:	cd 93 1a 00 	cmp.b	#0,	26(r13)	;r3 As==00, 0x001a
    97f4:	25 22       	jnz	$-948    	;abs 0x9440

000097f6 <.Loc.413.1>:
        value = clamp(value, TX_BR_MIN_LMB, 0xFF);
    97f6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    97f8:	6d 42       	mov.b	#4,	r13	;r2 As==10
    97fa:	b0 12 06 91 	call	#-28410	;#0x9106

000097fe <.LVL154>:
    97fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009802 <.LVL155>:
    9802:	1e 3e       	jmp	$-962    	;abs 0x9440

00009804 <.L110>:
        value = clamp(value, 0, TX_BR_MAX_LMB);
    9804:	7e 40 93 ff 	mov.b	#-109,	r14	;#0xff93
    9808:	b0 12 06 91 	call	#-28410	;#0x9106

0000980c <.LVL157>:
    980c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009810 <.LVL158>:
    9810:	17 3e       	jmp	$-976    	;abs 0x9440

00009812 <.L55>:
      value = clamp(value, TX_BR_MIN_MSB, TX_BR_MAX_MSB);
    9812:	4e 43       	clr.b	r14		;
    9814:	4d 4e       	mov.b	r14,	r13	;
    9816:	b0 12 06 91 	call	#-28410	;#0x9106

0000981a <.LVL160>:
    981a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000981e <.LVL161>:
      break;
    981e:	10 3e       	jmp	$-990    	;abs 0x9440

00009820 <.L98>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    9820:	5d 42 43 b3 	mov.b	&0xb343,r13	;0xb343
    9824:	0d 93       	cmp	#0,	r13	;r3 As==00
    9826:	05 20       	jnz	$+12     	;abs 0x9832

00009828 <.Loc.429.1>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB &&
    9828:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000982c <.Loc.428.1>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    982c:	ee 93 1e 00 	cmp.b	#2,	30(r14)	;r3 As==10, 0x001e
    9830:	1a 24       	jz	$+54     	;abs 0x9866

00009832 <.L81>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    9832:	0d 93       	cmp	#0,	r13	;r3 As==00
    9834:	02 24       	jz	$+6      	;abs 0x983a
    9836:	80 00 40 94 	mova	#37952,	r0	;0x09440

0000983a <.Loc.434.1>:
          bank0p[RegRXBRHmb] == RX_BR_MIN_HMB &&
    983a:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

0000983e <.Loc.433.1>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    983e:	cd 93 1e 00 	cmp.b	#0,	30(r13)	;r3 As==00, 0x001e
    9842:	02 24       	jz	$+6      	;abs 0x9848
    9844:	80 00 40 94 	mova	#37952,	r0	;0x09440

00009848 <.Loc.434.1>:
          bank0p[RegRXBRHmb] == RX_BR_MIN_HMB &&
    9848:	fd 90 03 00 	cmp.b	#3,	29(r13)	; 0x001d
    984c:	1d 00 
    984e:	02 24       	jz	$+6      	;abs 0x9854
    9850:	80 00 40 94 	mova	#37952,	r0	;0x09440

00009854 <.Loc.436.1>:
        value = clamp(value, RX_BR_MIN_LSB, 0xFF);
    9854:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9856:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    985a:	b0 12 06 91 	call	#-28410	;#0x9106

0000985e <.LVL163>:
    985e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009862 <.LVL164>:
    9862:	30 40 40 94 	br	#0x9440		;

00009866 <.L111>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB &&
    9866:	fe 90 49 00 	cmp.b	#73,	29(r14)	;#0x0049, 0x001d
    986a:	1d 00 
    986c:	e2 23       	jnz	$-58     	;abs 0x9832

0000986e <.Loc.431.1>:
        value = clamp(value, 0, RX_BR_MAX_LSB);
    986e:	7e 40 f0 ff 	mov.b	#-16,	r14	;#0xfff0
    9872:	b0 12 06 91 	call	#-28410	;#0x9106

00009876 <.LVL166>:
    9876:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000987a <.LVL167>:
    987a:	30 40 40 94 	br	#0x9440		;

0000987e <.L53>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    987e:	5d 42 43 b3 	mov.b	&0xb343,r13	;0xb343
    9882:	0d 93       	cmp	#0,	r13	;r3 As==00
    9884:	05 20       	jnz	$+12     	;abs 0x9890

00009886 <.Loc.441.1>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB) {
    9886:	3e 40 24 b3 	mov	#-19676,r14	;#0xb324

0000988a <.Loc.440.1>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    988a:	ee 93 1e 00 	cmp.b	#2,	30(r14)	;r3 As==10, 0x001e
    988e:	14 24       	jz	$+42     	;abs 0x98b8

00009890 <.L82>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    9890:	0d 93       	cmp	#0,	r13	;r3 As==00
    9892:	02 24       	jz	$+6      	;abs 0x9898
    9894:	80 00 40 94 	mova	#37952,	r0	;0x09440

00009898 <.Loc.445.1>:
          bank0p[RegRXBRHmb] == RX_BR_MIN_HMB) {
    9898:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324

0000989c <.Loc.444.1>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    989c:	cd 93 1e 00 	cmp.b	#0,	30(r13)	;r3 As==00, 0x001e
    98a0:	02 24       	jz	$+6      	;abs 0x98a6
    98a2:	80 00 40 94 	mova	#37952,	r0	;0x09440

000098a6 <.Loc.446.1>:
        value = clamp(value, RX_BR_MIN_LMB, 0xFF);
    98a6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    98a8:	7d 40 03 00 	mov.b	#3,	r13	;
    98ac:	b0 12 06 91 	call	#-28410	;#0x9106

000098b0 <.LVL169>:
    98b0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000098b4 <.LVL170>:
    98b4:	30 40 40 94 	br	#0x9440		;

000098b8 <.L112>:
        value = clamp(value, 0, RX_BR_MAX_LMB);
    98b8:	7e 40 49 00 	mov.b	#73,	r14	;#0x0049
    98bc:	b0 12 06 91 	call	#-28410	;#0x9106

000098c0 <.LVL172>:
    98c0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000098c4 <.LVL173>:
    98c4:	30 40 40 94 	br	#0x9440		;

000098c8 <.L59>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB) {
    98c8:	3d 40 24 b3 	mov	#-19676,r13	;#0xb324
    98cc:	cd 93 1f 00 	cmp.b	#0,	31(r13)	;r3 As==00, 0x001f
    98d0:	02 24       	jz	$+6      	;abs 0x98d6
    98d2:	80 00 40 94 	mova	#37952,	r0	;0x09440

000098d6 <.Loc.451.1>:
        value = clamp(value, 0, RX_BR_MAX_HMB);
    98d6:	6e 43       	mov.b	#2,	r14	;r3 As==10
    98d8:	4d 43       	clr.b	r13		;
    98da:	b0 12 06 91 	call	#-28410	;#0x9106

000098de <.LVL175>:
    98de:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000098e2 <.LVL176>:
    98e2:	30 40 40 94 	br	#0x9440		;

000098e6 <.L58>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    98e6:	4e 43       	clr.b	r14		;
    98e8:	4d 4e       	mov.b	r14,	r13	;
    98ea:	b0 12 06 91 	call	#-28410	;#0x9106

000098ee <.LVL178>:
    98ee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000098f2 <.LVL179>:
      break;
    98f2:	30 40 40 94 	br	#0x9440		;

000098f6 <.L51>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    98f6:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    98fa:	4d 43       	clr.b	r13		;
    98fc:	b0 12 06 91 	call	#-28410	;#0x9106

00009900 <.LVL181>:
    9900:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009904 <.LVL182>:
      break;
    9904:	30 40 40 94 	br	#0x9440		;

00009908 <.L64>:
      value = clamp_err(value);
    9908:	b0 12 86 90 	call	#-28538	;#0x9086

0000990c <.LVL184>:
    990c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009910 <.LVL185>:
      break;
    9910:	30 40 40 94 	br	#0x9440		;

00009914 <.L66>:
      value = clamp(value, 0, 4);
    9914:	6e 42       	mov.b	#4,	r14	;r2 As==10
    9916:	4d 43       	clr.b	r13		;
    9918:	b0 12 06 91 	call	#-28410	;#0x9106

0000991c <.LVL187>:
    991c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009920 <.LVL188>:
      break;
    9920:	30 40 40 94 	br	#0x9440		;

00009924 <.L99>:
        value = elyNLClampReg(addr, value);
    9924:	4d 4c       	mov.b	r12,	r13	;
    9926:	4c 4e       	mov.b	r14,	r12	;
    9928:	b0 12 78 a6 	call	#-22920	;#0xa678

0000992c <.LVL190>:
    992c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009930 <L0>:
    9930:	30 40 40 94 	br	#0x9440		;

00009934 <elyRegGet>:

bool elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    9934:	3a 15       	pushm	#4,	r10	;16-bit words

00009936 <.LCFI6>:
    9936:	49 4c       	mov.b	r12,	r9	;
    9938:	0a 4d       	mov	r13,	r10	;
    993a:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

0000993e <.Loc.509.1>:
  regs_in_progress = n;
    993e:	c2 4e 44 b7 	mov.b	r14,	&0xb744	;

00009942 <.LBB57>:
  
  for (int i = 0; i < n; i++) {
    9942:	4d 43       	clr.b	r13		;

00009944 <.L114>:
    9944:	08 4e       	mov	r14,	r8	;
    9946:	0d 9e       	cmp	r14,	r13	;
    9948:	1e 34       	jge	$+62     	;abs 0x9986

0000994a <.LBB58>:
    uint8_t addr = buffer[i];
    994a:	0c 4a       	mov	r10,	r12	;
    994c:	0c 5d       	add	r13,	r12	;
    994e:	6c 4c       	mov.b	@r12,	r12	;

00009950 <.LVL196>:
    
    if ((bank > 4) ||
    9950:	68 42       	mov.b	#4,	r8	;r2 As==10

00009952 <.LVL197>:
    9952:	48 99       	cmp.b	r9,	r8	;
    9954:	40 28       	jnc	$+130    	;abs 0x99d6

00009956 <.Loc.515.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    9956:	4f 4c       	mov.b	r12,	r15	;
    9958:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

0000995c <.Loc.514.1>:
    if ((bank > 4) ||
    995c:	78 40 09 00 	mov.b	#9,	r8	;
    9960:	48 9f       	cmp.b	r15,	r8	;
    9962:	3c 2c       	jc	$+122    	;abs 0x99dc

00009964 <.Loc.516.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9964:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

00009968 <.Loc.515.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    9968:	78 42       	mov.b	#8,	r8	;r2 As==11
    996a:	48 9f       	cmp.b	r15,	r8	;
    996c:	39 2c       	jc	$+116    	;abs 0x99e0

0000996e <.Loc.517.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    996e:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00009972 <.Loc.516.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9972:	78 40 35 00 	mov.b	#53,	r8	;#0x0035
    9976:	48 9f       	cmp.b	r15,	r8	;
    9978:	35 2c       	jc	$+108    	;abs 0x99e4

0000997a <.Loc.517.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    997a:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    997e:	4f 9c       	cmp.b	r12,	r15	;
    9980:	33 28       	jnc	$+104    	;abs 0x99e8

00009982 <.LBE58>:
  for (int i = 0; i < n; i++) {
    9982:	1d 53       	inc	r13		;

00009984 <.LVL198>:
    9984:	df 3f       	jmp	$-64     	;abs 0x9944

00009986 <.L127>:
        (addr >= RegDLLMAX)) {
      return false; /* other bits handled outside */
    }
  }
  
  if (bank == 0) {
    9986:	09 93       	cmp	#0,	r9	;r3 As==00
    9988:	10 24       	jz	$+34     	;abs 0x99aa
    998a:	47 43       	clr.b	r7		;
    998c:	1b 3c       	jmp	$+56     	;abs 0x99c4

0000998e <.L119>:
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
    998e:	0d 4a       	mov	r10,	r13	;
    9990:	0d 5c       	add	r12,	r13	;
    9992:	6e 4d       	mov.b	@r13,	r14	;

00009994 <.LVL201>:
      *(buffer+i-1) = bank0p[addr];
    9994:	0d 4c       	mov	r12,	r13	;

00009996 <.LVL202>:
    9996:	3d 53       	add	#-1,	r13	;r3 As==11

00009998 <.LVL203>:
    9998:	0d 5a       	add	r10,	r13	;
    999a:	dd 4e 24 b3 	mov.b	-19676(r14),0(r13)	;0xffffb324
    999e:	00 00 

000099a0 <.LBE62>:
    for (int i = 0; i < n; i++) {
    99a0:	1c 53       	inc	r12		;

000099a2 <.L117>:
    99a2:	0c 98       	cmp	r8,	r12	;
    99a4:	f4 3b       	jl	$-22     	;abs 0x998e

000099a6 <.LBE61>:
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    99a6:	5c 43       	mov.b	#1,	r12	;r3 As==01

000099a8 <.LVL205>:
    99a8:	17 3c       	jmp	$+48     	;abs 0x99d8

000099aa <.L126>:
    99aa:	4c 43       	clr.b	r12		;
    99ac:	fa 3f       	jmp	$-10     	;abs 0x99a2

000099ae <.L120>:
      uint8_t addr = buffer[i];
    99ae:	0c 4a       	mov	r10,	r12	;
    99b0:	0c 57       	add	r7,	r12	;

000099b2 <.LVL208>:
      fram_reg(1, bank, addr, (buffer+i-1));
    99b2:	0f 47       	mov	r7,	r15	;
    99b4:	3f 53       	add	#-1,	r15	;r3 As==11
    99b6:	0f 5a       	add	r10,	r15	;
    99b8:	6e 4c       	mov.b	@r12,	r14	;
    99ba:	4d 49       	mov.b	r9,	r13	;
    99bc:	5c 43       	mov.b	#1,	r12	;r3 As==01

000099be <.LVL209>:
    99be:	b0 12 6a 91 	call	#-28310	;#0x916a

000099c2 <.LBE64>:
    for (int i = 0; i < n; i++) {
    99c2:	17 53       	inc	r7		;

000099c4 <.L118>:
    99c4:	07 98       	cmp	r8,	r7	;
    99c6:	f3 3b       	jl	$-24     	;abs 0x99ae

000099c8 <.LBB65>:
  return chSemWaitTimeout(&bsp->sem, time);
    99c8:	4d 43       	clr.b	r13		;
    99ca:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    99ce:	b0 12 9c 46 	call	#18076		;#0x469c

000099d2 <.LBE65>:
  return true;
    99d2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    99d4:	01 3c       	jmp	$+4      	;abs 0x99d8

000099d6 <.L121>:
      return false; /* other bits handled outside */
    99d6:	4c 43       	clr.b	r12		;

000099d8 <.L115>:
}
    99d8:	37 17       	popm	#4,	r10	;16-bit words
    99da:	30 41       	ret			

000099dc <.L122>:
      return false; /* other bits handled outside */
    99dc:	4c 43       	clr.b	r12		;
    99de:	fc 3f       	jmp	$-6      	;abs 0x99d8

000099e0 <.L123>:
    99e0:	4c 43       	clr.b	r12		;
    99e2:	fa 3f       	jmp	$-10     	;abs 0x99d8

000099e4 <.L124>:
    99e4:	4c 43       	clr.b	r12		;
    99e6:	f8 3f       	jmp	$-14     	;abs 0x99d8

000099e8 <.L125>:
    99e8:	4c 43       	clr.b	r12		;
    99ea:	f6 3f       	jmp	$-18     	;abs 0x99d8

000099ec <elyRegSet>:
    99ec:	5a 15       	pushm	#6,	r10	;16-bit words

000099ee <.LCFI7>:
    99ee:	48 4c       	mov.b	r12,	r8	;
    99f0:	09 4d       	mov	r13,	r9	;
    99f2:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

000099f6 <.Loc.545.1>:

bool elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
  regs_in_progress = n;
    99f6:	c2 4e 44 b7 	mov.b	r14,	&0xb744	;

000099fa <.LBB69>:
  
  for (int i = 0; i < n * 2; i += 2) {
    99fa:	4c 43       	clr.b	r12		;

000099fc <.L129>:
    99fc:	0a 4e       	mov	r14,	r10	;

000099fe <L0>:
    99fe:	0a 5e       	add	r14,	r10	;
    9a00:	0c 9a       	cmp	r10,	r12	;
    9a02:	1c 34       	jge	$+58     	;abs 0x9a3c

00009a04 <.LBB70>:
    uint8_t addr = buffer[i];
    9a04:	0d 49       	mov	r9,	r13	;
    9a06:	0d 5c       	add	r12,	r13	;
    9a08:	6d 4d       	mov.b	@r13,	r13	;

00009a0a <.LVL220>:
    
    if ((bank == 0) || (bank > 4) ||
    9a0a:	4f 48       	mov.b	r8,	r15	;
    9a0c:	7f 53       	add.b	#-1,	r15	;r3 As==11
    9a0e:	7a 40 03 00 	mov.b	#3,	r10	;
    9a12:	4a 9f       	cmp.b	r15,	r10	;
    9a14:	30 28       	jnc	$+98     	;abs 0x9a76

00009a16 <.Loc.551.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    9a16:	4f 4d       	mov.b	r13,	r15	;
    9a18:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00009a1c <.Loc.550.1>:
    if ((bank == 0) || (bank > 4) ||
    9a1c:	7a 40 29 00 	mov.b	#41,	r10	;#0x0029
    9a20:	4a 9f       	cmp.b	r15,	r10	;
    9a22:	2b 2c       	jc	$+88     	;abs 0x9a7a

00009a24 <.Loc.552.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    9a24:	7f 50 cc ff 	add.b	#-52,	r15	;#0xffcc

00009a28 <.Loc.551.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    9a28:	7a 40 35 00 	mov.b	#53,	r10	;#0x0035
    9a2c:	4a 9f       	cmp.b	r15,	r10	;
    9a2e:	27 2c       	jc	$+80     	;abs 0x9a7e

00009a30 <.Loc.552.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    9a30:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    9a34:	4f 9d       	cmp.b	r13,	r15	;
    9a36:	25 28       	jnc	$+76     	;abs 0x9a82

00009a38 <.LBE70>:
  for (int i = 0; i < n * 2; i += 2) {
    9a38:	2c 53       	incd	r12		;

00009a3a <.LVL221>:
    9a3a:	e0 3f       	jmp	$-62     	;abs 0x99fc

00009a3c <.L138>:
    9a3c:	47 43       	clr.b	r7		;
    9a3e:	11 3c       	jmp	$+36     	;abs 0x9a62

00009a40 <.L133>:
      return false; /* other bits handled outside */
    }
  }

  for (int i = 0; i < n * 2; i += 2) {
    uint8_t addr = buffer[i];
    9a40:	0c 49       	mov	r9,	r12	;
    9a42:	0c 57       	add	r7,	r12	;
    9a44:	65 4c       	mov.b	@r12,	r5	;

00009a46 <.LVL224>:
    uint8_t value = buffer[i+1];
    9a46:	06 47       	mov	r7,	r6	;
    9a48:	16 53       	inc	r6		;
    9a4a:	06 59       	add	r9,	r6	;

00009a4c <.LVL225>:
    value = elyClampReg(addr, value);
    9a4c:	6d 46       	mov.b	@r6,	r13	;
    9a4e:	4c 45       	mov.b	r5,	r12	;

00009a50 <.LVL226>:
    9a50:	b0 12 a4 92 	call	#-27996	;#0x92a4

00009a54 <.LVL227>:
  
    /* Write the register */
    fram_reg(0, bank, addr, &buffer[i+1]);
    9a54:	0f 46       	mov	r6,	r15	;
    9a56:	4e 45       	mov.b	r5,	r14	;
    9a58:	4d 48       	mov.b	r8,	r13	;
    9a5a:	4c 43       	clr.b	r12		;
    9a5c:	b0 12 6a 91 	call	#-28310	;#0x916a

00009a60 <.LBE73>:
  for (int i = 0; i < n * 2; i += 2) {
    9a60:	27 53       	incd	r7		;

00009a62 <.L132>:
    9a62:	07 9a       	cmp	r10,	r7	;
    9a64:	ed 3b       	jl	$-36     	;abs 0x9a40

00009a66 <.LBB74>:
    9a66:	4d 43       	clr.b	r13		;
    9a68:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    9a6c:	b0 12 9c 46 	call	#18076		;#0x469c

00009a70 <.LBE74>:
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    9a70:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009a72 <.L130>:
}
    9a72:	55 17       	popm	#6,	r10	;16-bit words
    9a74:	30 41       	ret			

00009a76 <.L134>:
      return false; /* other bits handled outside */
    9a76:	4c 43       	clr.b	r12		;

00009a78 <.LVL234>:
    9a78:	fc 3f       	jmp	$-6      	;abs 0x9a72

00009a7a <.L135>:
    9a7a:	4c 43       	clr.b	r12		;

00009a7c <.LVL236>:
    9a7c:	fa 3f       	jmp	$-10     	;abs 0x9a72

00009a7e <.L136>:
    9a7e:	4c 43       	clr.b	r12		;

00009a80 <.LVL238>:
    9a80:	f8 3f       	jmp	$-14     	;abs 0x9a72

00009a82 <.L137>:
    9a82:	4c 43       	clr.b	r12		;

00009a84 <.LVL240>:
    9a84:	f6 3f       	jmp	$-18     	;abs 0x9a72

00009a86 <elyRegGetBlock>:
    9a86:	1a 15       	pushm	#2,	r10	;16-bit words

00009a88 <.LCFI8>:
    9a88:	21 83       	decd	r1		;

00009a8a <.LCFI9>:
    9a8a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

bool elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9a8e:	0a 4d       	mov	r13,	r10	;
    9a90:	4d 4e       	mov.b	r14,	r13	;

00009a92 <L0>:
    9a92:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

00009a96 <.Loc.576.1>:
  
  if (bank > 4 || 
    9a96:	69 42       	mov.b	#4,	r9	;r2 As==10
    9a98:	49 9c       	cmp.b	r12,	r9	;
    9a9a:	37 28       	jnc	$+112    	;abs 0x9b0a

00009a9c <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    9a9c:	0b 4d       	mov	r13,	r11	;
    9a9e:	3e 40 57 00 	mov	#87,	r14	;#0x0057
    9aa2:	0e 8f       	sub	r15,	r14	;

00009aa4 <.LVL243>:
  if (bank > 4 || 
    9aa4:	0d 9e       	cmp	r14,	r13	;
    9aa6:	04 38       	jl	$+10     	;abs 0x9ab0

00009aa8 <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    9aa8:	7e 40 5f 00 	mov.b	#95,	r14	;#0x005f
    9aac:	4e 9d       	cmp.b	r13,	r14	;
    9aae:	31 2c       	jc	$+100    	;abs 0x9b12

00009ab0 <.L141>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    9ab0:	4e 4d       	mov.b	r13,	r14	;
    9ab2:	7e 50 89 ff 	add.b	#-119,	r14	;#0xff89

00009ab6 <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    9ab6:	79 42       	mov.b	#8,	r9	;r2 As==11
    9ab8:	49 9e       	cmp.b	r14,	r9	;
    9aba:	2d 2c       	jc	$+92     	;abs 0x9b16

00009abc <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9abc:	3e 40 8b 00 	mov	#139,	r14	;#0x008b
    9ac0:	0e 8f       	sub	r15,	r14	;

00009ac2 <.Loc.578.1>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    9ac2:	0b 9e       	cmp	r14,	r11	;
    9ac4:	04 38       	jl	$+10     	;abs 0x9ace

00009ac6 <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9ac6:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    9aca:	4e 9d       	cmp.b	r13,	r14	;
    9acc:	26 2c       	jc	$+78     	;abs 0x9b1a

00009ace <.L142>:
      (addr >= RegDLLMAX - n + 1)) {
    9ace:	3e 40 d6 00 	mov	#214,	r14	;#0x00d6
    9ad2:	0e 8f       	sub	r15,	r14	;

00009ad4 <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9ad4:	0b 9e       	cmp	r14,	r11	;
    9ad6:	23 34       	jge	$+72     	;abs 0x9b1e

00009ad8 <.Loc.584.1>:
    return false; /* Other bits handled outside */
  }
  
  if (bank == 0) {
    9ad8:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ada:	0f 24       	jz	$+32     	;abs 0x9afa

00009adc <.Loc.589.1>:
    memcpy(buffer, bank0p + addr, n);
  }
  else {
    /* Read the block */
    fram_block(1, bank, addr, buffer, n);
    9adc:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    9ae0:	0f 4a       	mov	r10,	r15	;

00009ae2 <.LVL244>:
    9ae2:	4e 4d       	mov.b	r13,	r14	;
    9ae4:	4d 4c       	mov.b	r12,	r13	;
    9ae6:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009ae8 <.LVL245>:
    9ae8:	b0 12 e8 91 	call	#-28184	;#0x91e8

00009aec <.LBB77>:
    9aec:	4d 43       	clr.b	r13		;
    9aee:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    9af2:	b0 12 9c 46 	call	#18076		;#0x469c

00009af6 <.LBE77>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    9af6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9af8:	09 3c       	jmp	$+20     	;abs 0x9b0c

00009afa <.L149>:
    memcpy(buffer, bank0p + addr, n);
    9afa:	0e 4f       	mov	r15,	r14	;
    9afc:	3d 50 24 b3 	add	#-19676,r13	;#0xb324
    9b00:	0c 4a       	mov	r10,	r12	;
    9b02:	b0 12 72 ad 	call	#-21134	;#0xad72

00009b06 <.LVL249>:
  return true;
    9b06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9b08:	01 3c       	jmp	$+4      	;abs 0x9b0c

00009b0a <.L144>:
    return false; /* Other bits handled outside */
    9b0a:	4c 43       	clr.b	r12		;

00009b0c <.L140>:
}
    9b0c:	21 53       	incd	r1		;
    9b0e:	19 17       	popm	#2,	r10	;16-bit words
    9b10:	30 41       	ret			

00009b12 <.L145>:
    return false; /* Other bits handled outside */
    9b12:	4c 43       	clr.b	r12		;
    9b14:	fb 3f       	jmp	$-8      	;abs 0x9b0c

00009b16 <.L146>:
    9b16:	4c 43       	clr.b	r12		;
    9b18:	f9 3f       	jmp	$-12     	;abs 0x9b0c

00009b1a <.L147>:
    9b1a:	4c 43       	clr.b	r12		;
    9b1c:	f7 3f       	jmp	$-16     	;abs 0x9b0c

00009b1e <.L148>:
    9b1e:	4c 43       	clr.b	r12		;
    9b20:	f5 3f       	jmp	$-20     	;abs 0x9b0c

00009b22 <elyRegSetBlock>:
    9b22:	6a 15       	pushm	#7,	r10	;16-bit words

00009b24 <.LCFI10>:
    9b24:	21 83       	decd	r1		;

00009b26 <.LCFI11>:
    9b26:	44 4c       	mov.b	r12,	r4	;
    9b28:	07 4d       	mov	r13,	r7	;

bool elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9b2a:	48 4e       	mov.b	r14,	r8	;
    9b2c:	46 4f       	mov.b	r15,	r6	;

00009b2e <L0>:
  
  if (bank == 0 || bank > 4 || 
    9b2e:	4c 44       	mov.b	r4,	r12	;

00009b30 <.LVL253>:
    9b30:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9b32:	7d 40 03 00 	mov.b	#3,	r13	;

00009b36 <.LVL254>:
    9b36:	4d 9c       	cmp.b	r12,	r13	;
    9b38:	36 28       	jnc	$+110    	;abs 0x9ba6

00009b3a <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    9b3a:	0c 48       	mov	r8,	r12	;
    9b3c:	05 46       	mov	r6,	r5	;
    9b3e:	3d 40 57 00 	mov	#87,	r13	;#0x0057
    9b42:	0d 86       	sub	r6,	r13	;

00009b44 <.Loc.600.1>:
  if (bank == 0 || bank > 4 || 
    9b44:	08 9d       	cmp	r13,	r8	;
    9b46:	04 38       	jl	$+10     	;abs 0x9b50

00009b48 <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    9b48:	48 93       	cmp.b	#0,	r8	;r3 As==00
    9b4a:	02 38       	jl	$+6      	;abs 0x9b50

00009b4c <.Loc.604.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
      (addr >= RegDLLMAX - n + 1)) {
    return false; /* Other bits handled outside */
    9b4c:	4c 43       	clr.b	r12		;
    9b4e:	2c 3c       	jmp	$+90     	;abs 0x9ba8

00009b50 <.L152>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9b50:	3d 40 8b 00 	mov	#139,	r13	;#0x008b
    9b54:	0d 86       	sub	r6,	r13	;

00009b56 <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    9b56:	0c 9d       	cmp	r13,	r12	;
    9b58:	04 38       	jl	$+10     	;abs 0x9b62

00009b5a <.Loc.602.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9b5a:	7d 40 bf ff 	mov.b	#-65,	r13	;#0xffbf
    9b5e:	4d 98       	cmp.b	r8,	r13	;
    9b60:	26 2c       	jc	$+78     	;abs 0x9bae

00009b62 <.L153>:
      (addr >= RegDLLMAX - n + 1)) {
    9b62:	3d 40 d6 00 	mov	#214,	r13	;#0x00d6
    9b66:	0d 86       	sub	r6,	r13	;

00009b68 <.Loc.602.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9b68:	0c 9d       	cmp	r13,	r12	;
    9b6a:	23 34       	jge	$+72     	;abs 0x9bb2
    9b6c:	4a 43       	clr.b	r10		;
    9b6e:	0a 3c       	jmp	$+22     	;abs 0x9b84

00009b70 <.L155>:
  }
  
  for (int i = 0; i < n; i++) {
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    9b70:	09 47       	mov	r7,	r9	;
    9b72:	09 5a       	add	r10,	r9	;
    9b74:	6d 49       	mov.b	@r9,	r13	;
    9b76:	4c 4a       	mov.b	r10,	r12	;
    9b78:	4c 58       	add.b	r8,	r12	;
    9b7a:	b0 12 a4 92 	call	#-27996	;#0x92a4

00009b7e <.LVL256>:
    9b7e:	c9 4c 00 00 	mov.b	r12,	0(r9)	;

00009b82 <.Loc.607.1>:
  for (int i = 0; i < n; i++) {
    9b82:	1a 53       	inc	r10		;

00009b84 <.L154>:
    9b84:	0a 95       	cmp	r5,	r10	;
    9b86:	f4 3b       	jl	$-22     	;abs 0x9b70

00009b88 <.LBE79>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    9b88:	c1 46 00 00 	mov.b	r6,	0(r1)	;
    9b8c:	0f 47       	mov	r7,	r15	;
    9b8e:	4e 48       	mov.b	r8,	r14	;
    9b90:	4d 44       	mov.b	r4,	r13	;
    9b92:	4c 43       	clr.b	r12		;
    9b94:	b0 12 e8 91 	call	#-28184	;#0x91e8

00009b98 <.LBB80>:
    9b98:	4d 43       	clr.b	r13		;
    9b9a:	3c 40 46 b7 	mov	#-18618,r12	;#0xb746
    9b9e:	b0 12 9c 46 	call	#18076		;#0x469c

00009ba2 <.LBE80>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    9ba2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9ba4:	01 3c       	jmp	$+4      	;abs 0x9ba8

00009ba6 <.L156>:
    return false; /* Other bits handled outside */
    9ba6:	4c 43       	clr.b	r12		;

00009ba8 <.L151>:
}
    9ba8:	21 53       	incd	r1		;
    9baa:	64 17       	popm	#7,	r10	;16-bit words
    9bac:	30 41       	ret			

00009bae <.L158>:
    return false; /* Other bits handled outside */
    9bae:	4c 43       	clr.b	r12		;
    9bb0:	fb 3f       	jmp	$-8      	;abs 0x9ba8

00009bb2 <.L159>:
    9bb2:	4c 43       	clr.b	r12		;
    9bb4:	f9 3f       	jmp	$-12     	;abs 0x9ba8

00009bb6 <reset_state>:
  uart_thd = chThdGetSelfX();
}

static slip_uart_states_t reset_state(void) {
  return ELY_SLIP_RESET;
}
    9bb6:	4c 43       	clr.b	r12		;
    9bb8:	30 41       	ret			

00009bba <handle_buffer>:

static void handle_buffer(size_t bytes_available, const uint8_t * buffer) {
    9bba:	2a 15       	pushm	#3,	r10	;16-bit words

00009bbc <.LCFI0>:
    9bbc:	08 4c       	mov	r12,	r8	;
    9bbe:	0a 4d       	mov	r13,	r10	;

00009bc0 <L0>:
  static size_t rx_n = elyNLHeaderLen;
  static bool header = true;
  /* We have now received 256 bytes of data somewhere in rx_buf */
  
  const uint8_t * end = buffer + bytes_available;
    9bc0:	09 4d       	mov	r13,	r9	;
    9bc2:	09 5c       	add	r12,	r9	;

00009bc4 <.LVL1>:
  const uint8_t * cp = buffer;
  
  while (cp < end) {
    9bc4:	0a 3c       	jmp	$+22     	;abs 0x9bda

00009bc6 <.L6>:
    }
    
    switch (rx_state) {
      case ELY_SLIP_ESCAPED:
        {
          switch(c) {
    9bc6:	7d 90 dc ff 	cmp.b	#-36,	r13	;#0xffdc
    9bca:	32 24       	jz	$+102    	;abs 0x9c30
    9bcc:	7d 90 dd ff 	cmp.b	#-35,	r13	;#0xffdd
    9bd0:	3e 24       	jz	$+126    	;abs 0x9c4e

00009bd2 <.Loc.166.1>:
              break;
            case SLIP_ESC_ESC:
              *rx_write_ptr++ = SLIP_ESC;
              break;
            default:
              rx_state = reset_state();
    9bd2:	b0 12 b6 9b 	call	#-25674	;#0x9bb6

00009bd6 <.LVL3>:
    9bd6:	c2 4c 5c b7 	mov.b	r12,	&0xb75c	;

00009bda <.L3>:
  while (cp < end) {
    9bda:	0a 99       	cmp	r9,	r10	;
    9bdc:	7d 2c       	jc	$+252    	;abs 0x9cd8

00009bde <.LBB29>:
    uint8_t c = *cp;
    9bde:	6d 4a       	mov.b	@r10,	r13	;

00009be0 <.LVL4>:
    if (rx_state == ELY_SLIP_RESET) {
    9be0:	c2 93 5c b7 	cmp.b	#0,	&0xb75c	;r3 As==00
    9be4:	0a 20       	jnz	$+22     	;abs 0x9bfa

00009be6 <.Loc.149.1>:
      rx_write_ptr = rx_active_buffer;
    9be6:	92 42 5a b7 	mov	&0xb75a,&0xb758	;0xb75a
    9bea:	58 b7 

00009bec <.Loc.150.1>:
      rx_n = elyNLHeaderLen;
    9bec:	b2 40 06 00 	mov	#6,	&0xb426	;
    9bf0:	26 b4 

00009bf2 <.Loc.151.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    9bf2:	e2 43 5c b7 	mov.b	#2,	&0xb75c	;r3 As==10

00009bf6 <.Loc.152.1>:
      header = true;
    9bf6:	d2 43 24 b4 	mov.b	#1,	&0xb424	;r3 As==01

00009bfa <.L4>:
    switch (rx_state) {
    9bfa:	5c 42 5c b7 	mov.b	&0xb75c,r12	;0xb75c
    9bfe:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9c00:	e2 27       	jz	$-58     	;abs 0x9bc6
    9c02:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9c04:	2e 24       	jz	$+94     	;abs 0x9c62

00009c06 <.Loc.213.1>:
              }
          }
        }
        break;
      default:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    9c06:	3c 40 99 b1 	mov	#-20071,r12	;#0xb199
    9c0a:	b0 12 a6 44 	call	#17574		;#0x44a6

00009c0e <.L13>:
        break;
    }
    
    if (rx_n == 0 && header) { /* and we haven't reset */
    9c0e:	82 93 26 b4 	cmp	#0,	&0xb426	;r3 As==00
    9c12:	e3 23       	jnz	$-56     	;abs 0x9bda

00009c14 <.Loc.217.1>:
    9c14:	c2 93 24 b4 	cmp.b	#0,	&0xb424	;r3 As==00
    9c18:	e0 27       	jz	$-62     	;abs 0x9bda

00009c1a <.Loc.218.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    9c1a:	1c 42 5a b7 	mov	&0xb75a,r12	;0xb75a
    9c1e:	b0 12 26 a8 	call	#-22490	;#0xa826

00009c22 <.LVL6>:
    9c22:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa
    9c26:	82 4c 26 b4 	mov	r12,	&0xb426	;

00009c2a <.Loc.219.1>:
      header = false;
    9c2a:	c2 43 24 b4 	mov.b	#0,	&0xb424	;r3 As==00
    9c2e:	d5 3f       	jmp	$-84     	;abs 0x9bda

00009c30 <.L9>:
              *rx_write_ptr++ = SLIP_END;
    9c30:	1c 42 58 b7 	mov	&0xb758,r12	;0xb758
    9c34:	0d 4c       	mov	r12,	r13	;
    9c36:	1d 53       	inc	r13		;
    9c38:	82 4d 58 b7 	mov	r13,	&0xb758	;
    9c3c:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    9c40:	00 00 

00009c42 <.L11>:
          rx_n--;
    9c42:	b2 53 26 b4 	add	#-1,	&0xb426	;r3 As==11

00009c46 <.Loc.170.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    9c46:	e2 43 5c b7 	mov.b	#2,	&0xb75c	;r3 As==10

00009c4a <.Loc.171.1>:
          cp++;
    9c4a:	1a 53       	inc	r10		;

00009c4c <.Loc.173.1>:
        break;
    9c4c:	e0 3f       	jmp	$-62     	;abs 0x9c0e

00009c4e <.L10>:
              *rx_write_ptr++ = SLIP_ESC;
    9c4e:	1c 42 58 b7 	mov	&0xb758,r12	;0xb758
    9c52:	0f 4c       	mov	r12,	r15	;
    9c54:	1f 53       	inc	r15		;
    9c56:	82 4f 58 b7 	mov	r15,	&0xb758	;
    9c5a:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    9c5e:	00 00 

00009c60 <.LVL11>:
              break;
    9c60:	f0 3f       	jmp	$-30     	;abs 0x9c42

00009c62 <.L7>:
          switch(c) {
    9c62:	7d 90 c0 ff 	cmp.b	#-64,	r13	;#0xffc0
    9c66:	0f 24       	jz	$+32     	;abs 0x9c86
    9c68:	7d 90 db ff 	cmp.b	#-37,	r13	;#0xffdb
    9c6c:	1f 20       	jnz	$+64     	;abs 0x9cac

00009c6e <.Loc.178.1>:
              if (rx_n == 0) {
    9c6e:	82 93 26 b4 	cmp	#0,	&0xb426	;r3 As==00
    9c72:	05 20       	jnz	$+12     	;abs 0x9c7e

00009c74 <.Loc.179.1>:
                rx_state = reset_state();
    9c74:	b0 12 b6 9b 	call	#-25674	;#0x9bb6

00009c78 <.LVL13>:
    9c78:	c2 4c 5c b7 	mov.b	r12,	&0xb75c	;

00009c7c <.Loc.180.1>:
                continue;
    9c7c:	ae 3f       	jmp	$-162    	;abs 0x9bda

00009c7e <.L17>:
                rx_state = ELY_SLIP_ESCAPED;
    9c7e:	d2 43 5c b7 	mov.b	#1,	&0xb75c	;r3 As==01

00009c82 <.Loc.184.1>:
                cp++;
    9c82:	1a 53       	inc	r10		;

00009c84 <.LVL15>:
              break;
    9c84:	c4 3f       	jmp	$-118    	;abs 0x9c0e

00009c86 <.L15>:
              if (rx_n == 0) {
    9c86:	82 93 26 b4 	cmp	#0,	&0xb426	;r3 As==00
    9c8a:	04 24       	jz	$+10     	;abs 0x9c94

00009c8c <.L18>:
              cp++;
    9c8c:	1a 53       	inc	r10		;

00009c8e <.Loc.197.1>:
              rx_state = ELY_SLIP_RESET;
    9c8e:	c2 43 5c b7 	mov.b	#0,	&0xb75c	;r3 As==00

00009c92 <.Loc.198.1>:
              continue;
    9c92:	a3 3f       	jmp	$-184    	;abs 0x9bda

00009c94 <.L27>:
                elyMainMBPost(rx_active_buffer, TIME_INFINITE);
    9c94:	4d 43       	clr.b	r13		;
    9c96:	1c 42 5a b7 	mov	&0xb75a,r12	;0xb75a
    9c9a:	b0 12 94 61 	call	#24980		;#0x6194

00009c9e <.LVL20>:
                rx_active_buffer = elyNLGetBuffer();
    9c9e:	b0 12 14 a7 	call	#-22764	;#0xa714

00009ca2 <.LVL21>:
    9ca2:	82 4c 5a b7 	mov	r12,	&0xb75a	;

00009ca6 <.Loc.192.1>:
                if (rx_active_buffer == NULL) {
    9ca6:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ca8:	f1 23       	jnz	$-28     	;abs 0x9c8c

00009caa <.L19>:
    9caa:	ff 3f       	jmp	$+0      	;abs 0x9caa

00009cac <.L25>:
              if (rx_n == 0) {
    9cac:	1c 42 26 b4 	mov	&0xb426,r12	;0xb426
    9cb0:	0c 93       	cmp	#0,	r12	;r3 As==00
    9cb2:	05 20       	jnz	$+12     	;abs 0x9cbe

00009cb4 <.Loc.201.1>:
                rx_state = reset_state();
    9cb4:	b0 12 b6 9b 	call	#-25674	;#0x9bb6

00009cb8 <.LVL23>:
    9cb8:	c2 4c 5c b7 	mov.b	r12,	&0xb75c	;

00009cbc <.Loc.202.1>:
                continue;
    9cbc:	8e 3f       	jmp	$-226    	;abs 0x9bda

00009cbe <.L20>:
                *rx_write_ptr++ = c;
    9cbe:	1e 42 58 b7 	mov	&0xb758,r14	;0xb758
    9cc2:	0f 4e       	mov	r14,	r15	;
    9cc4:	1f 53       	inc	r15		;
    9cc6:	82 4f 58 b7 	mov	r15,	&0xb758	;
    9cca:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00009cce <.LVL25>:
                rx_n--;
    9cce:	3c 53       	add	#-1,	r12	;r3 As==11
    9cd0:	82 4c 26 b4 	mov	r12,	&0xb426	;

00009cd4 <.Loc.207.1>:
                cp++;
    9cd4:	1a 53       	inc	r10		;
    9cd6:	9b 3f       	jmp	$-200    	;abs 0x9c0e

00009cd8 <.L26>:
    }
  }
  
  if (bytes_available < SLIP_RX_BUF_LEN) {
    9cd8:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    9cdc:	0c 98       	cmp	r8,	r12	;
    9cde:	02 28       	jnc	$+6      	;abs 0x9ce4

00009ce0 <.Loc.224.1>:
    rx_state = ELY_SLIP_RESET;
    9ce0:	c2 43 5c b7 	mov.b	#0,	&0xb75c	;r3 As==00

00009ce4 <.L2>:
  }

}
    9ce4:	28 17       	popm	#3,	r10	;16-bit words
    9ce6:	30 41       	ret			

00009ce8 <calc_next_buff>:
  switch (tx_state) {
    9ce8:	5c 42 28 b4 	mov.b	&0xb428,r12	;0xb428
    9cec:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9cee:	20 24       	jz	$+66     	;abs 0x9d30
    9cf0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9cf2:	3e 20       	jnz	$+126    	;abs 0x9d70

00009cf4 <.Loc.28.1>:
      next_tx_ptr = tx_read_ptr;
    9cf4:	92 42 50 b7 	mov	&0xb750,&0xb74c	;0xb750
    9cf8:	4c b7 

00009cfa <.Loc.29.1>:
      next_cnt = 0;
    9cfa:	82 43       	mov	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00009cfc <L0>:
    9cfc:	4e b7       	bit.b	r7,	r14	;

00009cfe <.Loc.30.1>:
      while (next_cnt != tx_n && 
    9cfe:	06 3c       	jmp	$+14     	;abs 0x9d0c

00009d00 <.L34>:
        next_cnt++;
    9d00:	1c 53       	inc	r12		;
    9d02:	82 4c 4e b7 	mov	r12,	&0xb74e	;

00009d06 <.Loc.34.1>:
        tx_read_ptr++;
    9d06:	1e 53       	inc	r14		;
    9d08:	82 4e 50 b7 	mov	r14,	&0xb750	;

00009d0c <.L32>:
      while (next_cnt != tx_n && 
    9d0c:	1c 42 4e b7 	mov	&0xb74e,r12	;0xb74e
    9d10:	1c 92 52 b7 	cmp	&0xb752,r12	;0xb752
    9d14:	09 24       	jz	$+20     	;abs 0x9d28

00009d16 <.Loc.31.1>:
          *tx_read_ptr != SLIP_END && 
    9d16:	1e 42 50 b7 	mov	&0xb750,r14	;0xb750
    9d1a:	6d 4e       	mov.b	@r14,	r13	;

00009d1c <.Loc.30.1>:
      while (next_cnt != tx_n && 
    9d1c:	7d 90 c0 ff 	cmp.b	#-64,	r13	;#0xffc0
    9d20:	03 24       	jz	$+8      	;abs 0x9d28

00009d22 <.Loc.31.1>:
          *tx_read_ptr != SLIP_END && 
    9d22:	7d 90 db ff 	cmp.b	#-37,	r13	;#0xffdb
    9d26:	ec 23       	jnz	$-38     	;abs 0x9d00

00009d28 <.L33>:
      tx_state = ELY_SLIP_ESCAPED;
    9d28:	d2 43 28 b4 	mov.b	#1,	&0xb428	;r3 As==01

00009d2c <.Loc.37.1>:
      if (next_cnt > 0) {
    9d2c:	0c 93       	cmp	#0,	r12	;r3 As==00
    9d2e:	16 20       	jnz	$+46     	;abs 0x9d5c

00009d30 <.L30>:
        switch(*tx_read_ptr++) {
    9d30:	1c 42 50 b7 	mov	&0xb750,r12	;0xb750
    9d34:	0d 4c       	mov	r12,	r13	;
    9d36:	1d 53       	inc	r13		;
    9d38:	82 4d 50 b7 	mov	r13,	&0xb750	;
    9d3c:	6c 4c       	mov.b	@r12,	r12	;
    9d3e:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    9d42:	0d 24       	jz	$+28     	;abs 0x9d5e
    9d44:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    9d48:	0e 20       	jnz	$+30     	;abs 0x9d66

00009d4a <.Loc.44.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    9d4a:	b2 40 cc b1 	mov	#-20020,&0xb74c	;#0xb1cc
    9d4e:	4c b7 

00009d50 <.L39>:
        next_cnt = 2;
    9d50:	a2 43 4e b7 	mov	#2,	&0xb74e	;r3 As==10

00009d54 <.Loc.54.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    9d54:	92 53 52 b7 	inc	&0xb752		;

00009d58 <.Loc.55.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    9d58:	e2 43 28 b4 	mov.b	#2,	&0xb428	;r3 As==10

00009d5c <.L28>:
}
    9d5c:	30 41       	ret			

00009d5e <.L37>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    9d5e:	b2 40 ca b1 	mov	#-20022,&0xb74c	;#0xb1ca
    9d62:	4c b7 

00009d64 <.Loc.48.1>:
            break;
    9d64:	f5 3f       	jmp	$-20     	;abs 0x9d50

00009d66 <.L41>:
            chDbgAssert(false, "state machine error");
    9d66:	3c 40 bb b1 	mov	#-20037,r12	;#0xb1bb
    9d6a:	b0 12 a6 44 	call	#17574		;#0x44a6

00009d6e <.LVL28>:
            break;
    9d6e:	f0 3f       	jmp	$-30     	;abs 0x9d50

00009d70 <.L40>:
      chDbgAssert(false, "State machine error");
    9d70:	3c 40 bb b1 	mov	#-20037,r12	;#0xb1bb
    9d74:	b0 12 a6 44 	call	#17574		;#0x44a6

00009d78 <.LVL29>:
}
    9d78:	f1 3f       	jmp	$-28     	;abs 0x9d5c

00009d7a <elyUARTDLLTxCB>:
    9d7a:	c2 93 48 b7 	cmp.b	#0,	&0xb748	;r3 As==00
  if (done) {
    9d7e:	03 24       	jz	$+8      	;abs 0x9d86

00009d80 <.Loc.70.1>:
    done = false;
    9d80:	c2 43       	mov.b	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00009d82 <L0>:
    9d82:	48 b7       	bit.b	r7,	r8	;

00009d84 <.L42>:
}
    9d84:	30 41       	ret			

00009d86 <.L43>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    9d86:	1e 42 4c b7 	mov	&0xb74c,r14	;0xb74c
    9d8a:	1d 42 4e b7 	mov	&0xb74e,r13	;0xb74e
    9d8e:	b0 12 ac 4c 	call	#19628		;#0x4cac

00009d92 <.LVL33>:
  if (tx_n == 0) {
    9d92:	1c 42 52 b7 	mov	&0xb752,r12	;0xb752
    9d96:	0c 93       	cmp	#0,	r12	;r3 As==00
    9d98:	09 24       	jz	$+20     	;abs 0x9dac

00009d9a <.Loc.83.1>:
  tx_n -= next_cnt;
    9d9a:	1c 82 4e b7 	sub	&0xb74e,r12	;0xb74e
    9d9e:	82 4c 52 b7 	mov	r12,	&0xb752	;

00009da2 <.Loc.85.1>:
  if (tx_n == 0) {
    9da2:	0c 93       	cmp	#0,	r12	;r3 As==00
    9da4:	06 24       	jz	$+14     	;abs 0x9db2

00009da6 <.Loc.94.1>:
  calc_next_buff();
    9da6:	b0 12 e8 9c 	call	#-25368	;#0x9ce8

00009daa <.LVL34>:
    9daa:	ec 3f       	jmp	$-38     	;abs 0x9d84

00009dac <.L47>:
    done = true;
    9dac:	d2 43 48 b7 	mov.b	#1,	&0xb748	;r3 As==01

00009db0 <.Loc.80.1>:
    return;
    9db0:	e9 3f       	jmp	$-44     	;abs 0x9d84

00009db2 <.L48>:
    elyNLFreeBufferI(tx_active_buffer);
    9db2:	1c 42 54 b7 	mov	&0xb754,r12	;0xb754
    9db6:	b0 12 2a a7 	call	#-22742	;#0xa72a

00009dba <.LVL35>:
    next_tx_ptr = &END;
    9dba:	b2 40 ba b1 	mov	#-20038,&0xb74c	;#0xb1ba
    9dbe:	4c b7 

00009dc0 <.Loc.90.1>:
    next_cnt = 1;
    9dc0:	92 43 4e b7 	mov	#1,	&0xb74e	;r3 As==01

00009dc4 <.Loc.91.1>:
    return;
    9dc4:	df 3f       	jmp	$-64     	;abs 0x9d84

00009dc6 <elyUARTDLLStartTx>:
    9dc6:	1a 15       	pushm	#2,	r10	;16-bit words

00009dc8 <.LCFI1>:
void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    9dc8:	09 4c       	mov	r12,	r9	;
    9dca:	0a 4d       	mov	r13,	r10	;

00009dcc <L0>:
  tx_n = elyNLGetLength(buffer);
    9dcc:	0c 4d       	mov	r13,	r12	;

00009dce <.LVL37>:
    9dce:	b0 12 26 a8 	call	#-22490	;#0xa826

00009dd2 <.LVL38>:
    9dd2:	82 4c 52 b7 	mov	r12,	&0xb752	;

00009dd6 <.Loc.101.1>:
  chDbgAssert(tx_n != 0 && tx_n < elyNLMaxLen, "invalid packet length");
    9dd6:	0c 93       	cmp	#0,	r12	;r3 As==00
    9dd8:	03 24       	jz	$+8      	;abs 0x9de0

00009dda <.Loc.101.1>:
    9dda:	1c 92 88 b4 	cmp	&0xb488,r12	;0xb488
    9dde:	04 28       	jnc	$+10     	;abs 0x9de8

00009de0 <.L50>:
    9de0:	3c 40 a8 b1 	mov	#-20056,r12	;#0xb1a8
    9de4:	b0 12 a6 44 	call	#17574		;#0x44a6

00009de8 <.L51>:
  tx_read_ptr = buffer;
    9de8:	82 4a 50 b7 	mov	r10,	&0xb750	;

00009dec <.Loc.103.1>:
  tx_active_buffer = buffer;
    9dec:	82 4a 54 b7 	mov	r10,	&0xb754	;

00009df0 <.Loc.104.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    9df0:	e2 43 28 b4 	mov.b	#2,	&0xb428	;r3 As==10

00009df4 <.Loc.106.1>:
  calc_next_buff();
    9df4:	b0 12 e8 9c 	call	#-25368	;#0x9ce8

00009df8 <.LBB30>:
  _disable_interrupts();
    9df8:	32 c2       	dint			

00009dfa <.Loc.348.2>:
  asm volatile("nop");
    9dfa:	03 43       	nop			

00009dfc <.LBE30>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    9dfc:	1e 42 4c b7 	mov	&0xb74c,r14	;0xb74c
    9e00:	1d 42 4e b7 	mov	&0xb74e,r13	;0xb74e
    9e04:	0c 49       	mov	r9,	r12	;
    9e06:	b0 12 ac 4c 	call	#19628		;#0x4cac

00009e0a <.LVL41>:
  tx_n -= next_cnt;
    9e0a:	1c 42 52 b7 	mov	&0xb752,r12	;0xb752
    9e0e:	1c 82 4e b7 	sub	&0xb74e,r12	;0xb74e
    9e12:	82 4c 52 b7 	mov	r12,	&0xb752	;

00009e16 <.Loc.113.1>:
  if (tx_n == 0) {
    9e16:	0c 93       	cmp	#0,	r12	;r3 As==00
    9e18:	07 24       	jz	$+16     	;abs 0x9e28

00009e1a <.Loc.121.1>:
  calc_next_buff();
    9e1a:	b0 12 e8 9c 	call	#-25368	;#0x9ce8

00009e1e <.LBB32>:
  asm volatile("nop");
    9e1e:	03 43       	nop			

00009e20 <.Loc.356.2>:
  _enable_interrupts();
    9e20:	32 d2       	eint			
    9e22:	03 43       	nop			

00009e24 <.L49>:
}
    9e24:	19 17       	popm	#2,	r10	;16-bit words
    9e26:	30 41       	ret			

00009e28 <.L54>:
    elyNLFreeBufferI(tx_active_buffer);
    9e28:	1c 42 54 b7 	mov	&0xb754,r12	;0xb754
    9e2c:	b0 12 2a a7 	call	#-22742	;#0xa72a

00009e30 <.LVL43>:
    next_tx_ptr = &END;
    9e30:	b2 40 a7 b1 	mov	#-20057,&0xb74c	;#0xb1a7
    9e34:	4c b7 

00009e36 <.Loc.116.1>:
    next_cnt = 1;
    9e36:	92 43 4e b7 	mov	#1,	&0xb74e	;r3 As==01

00009e3a <.LBB34>:
  asm volatile("nop");
    9e3a:	03 43       	nop			

00009e3c <.Loc.356.2>:
  _enable_interrupts();
    9e3c:	32 d2       	eint			
    9e3e:	03 43       	nop			
    9e40:	f1 3f       	jmp	$-28     	;abs 0x9e24

00009e42 <elyUARTDLLRxInit>:
    9e42:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00009e44 <L0>:
  rx_active_buffer = elyNLGetBuffer();
    9e44:	14 a7       	dadd,		r4	;Warning: disassembly unreliable - not enough bytes available

00009e46 <.LVL45>:
    9e46:	82 4c 5a b7 	mov	r12,	&0xb75a	;

00009e4a <.Loc.130.1>:
  uart_thd = chThdGetSelfX();
    9e4a:	92 42 8a b4 	mov	&0xb48a,&0xb74a	;0xb48a
    9e4e:	4a b7 

00009e50 <.Loc.131.1>:
}
    9e50:	30 41       	ret			

00009e52 <elyUARTDLLRxHandleBuffer>:

void elyUARTDLLRxHandleBuffer() {
  handle_buffer(bytes_available, curr_rx_buf);
    9e52:	1d 42 2c b4 	mov	&0xb42c,r13	;0xb42c
    9e56:	1c 42 56 b7 	mov	&0xb756,r12	;0xb756
    9e5a:	b0 12 ba 9b 	call	#-25670	;#0x9bba

00009e5e <.LVL46>:
  
  if (curr_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    9e5e:	b2 90 5d b8 	cmp	#-18339,&0xb42c	;#0xb85d
    9e62:	2c b4 
    9e64:	04 24       	jz	$+10     	;abs 0x9e6e

00009e66 <.Loc.236.1>:
    curr_rx_buf = rx_buf;
  }
  else {
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9e66:	b2 40 5d b8 	mov	#-18339,&0xb42c	;#0xb85d
    9e6a:	2c b4 

00009e6c <.L56>:
  }
}
    9e6c:	30 41       	ret			

00009e6e <.L59>:
    curr_rx_buf = rx_buf;
    9e6e:	b2 40 5d b7 	mov	#-18595,&0xb42c	;#0xb75d
    9e72:	2c b4 
    9e74:	fb 3f       	jmp	$-8      	;abs 0x9e6c

00009e76 <elyUARTDLLTimeoutCB>:
    9e76:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00009e78 <L0>:
/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    9e78:	66 b5       	bit.b	@r5,	r6	;

00009e7a <.LVL48>:
    9e7a:	b0 12 44 4d 	call	#19780		;#0x4d44

00009e7e <.LVL49>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    9e7e:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9e82:	0d 8c       	sub	r12,	r13	;
    9e84:	82 4d 56 b7 	mov	r13,	&0xb756	;

00009e88 <.Loc.250.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    9e88:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9e8a:	4e 43       	clr.b	r14		;
    9e8c:	1c 42 4a b7 	mov	&0xb74a,r12	;0xb74a

00009e90 <.LVL50>:
    9e90:	b0 12 fe 46 	call	#18174		;#0x46fe

00009e94 <.LVL51>:
  chSysUnlockFromISR();

}
    9e94:	30 41       	ret			

00009e96 <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    9e96:	2a 15       	pushm	#3,	r10	;16-bit words

00009e98 <.LCFI2>:
    9e98:	08 4c       	mov	r12,	r8	;
    9e9a:	09 4d       	mov	r13,	r9	;

00009e9c <.Loc.256.1>:
  chDbgAssert(c < 0x100, "invalid char");
    9e9c:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

00009ea0 <.LVL53>:
    9ea0:	0c 9d       	cmp	r13,	r12	;
    9ea2:	19 28       	jnc	$+52     	;abs 0x9ed6

00009ea4 <.L62>:
  rx_buf[0] = (uint8_t)(c);
    9ea4:	3a 40 5d b7 	mov	#-18595,r10	;#0xb75d
    9ea8:	ca 49 00 00 	mov.b	r9,	0(r10)	;

00009eac <.Loc.259.1>:
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, rx_buf+1);
    9eac:	0e 4a       	mov	r10,	r14	;
    9eae:	1e 53       	inc	r14		;
    9eb0:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    9eb4:	0c 48       	mov	r8,	r12	;
    9eb6:	b0 12 f8 4c 	call	#19704		;#0x4cf8

00009eba <.LVL55>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    9eba:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9ebe:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    9ec2:	b0 12 62 4b 	call	#19298		;#0x4b62

00009ec6 <.LVL56>:
  
  curr_rx_buf = rx_buf;
    9ec6:	82 4a 2c b4 	mov	r10,	&0xb42c	;

00009eca <.Loc.263.1>:
  next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9eca:	3a 50 00 01 	add	#256,	r10	;#0x0100
    9ece:	82 4a 2a b4 	mov	r10,	&0xb42a	;

00009ed2 <.Loc.266.1>:
  
  chSysUnlockFromISR();
}
    9ed2:	28 17       	popm	#3,	r10	;16-bit words
    9ed4:	30 41       	ret			

00009ed6 <.L63>:
  chDbgAssert(c < 0x100, "invalid char");
    9ed6:	3c 40 86 b1 	mov	#-20090,r12	;#0xb186
    9eda:	b0 12 a6 44 	call	#17574		;#0x44a6

00009ede <.LVL57>:
    9ede:	e2 3f       	jmp	$-58     	;abs 0x9ea4

00009ee0 <elyUARTDLLRxCB>:
    9ee0:	1e 42       	mov,		r14	;Warning: disassembly unreliable - not enough bytes available

00009ee2 <L0>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, next_rx_buf); 
    9ee2:	2a b4       	bit	@r4,	r10	;
    9ee4:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9ee8:	b0 12 f8 4c 	call	#19704		;#0x4cf8

00009eec <.LVL59>:
  gptStopTimerI(&uart_gpt);
    9eec:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    9ef0:	b0 12 a8 4b 	call	#19368		;#0x4ba8

00009ef4 <.LVL60>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    9ef4:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9ef8:	3c 40 ac b5 	mov	#-19028,r12	;#0xb5ac
    9efc:	b0 12 62 4b 	call	#19298		;#0x4b62

00009f00 <.LVL61>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    9f00:	b2 40 00 01 	mov	#256,	&0xb756	;#0x0100
    9f04:	56 b7 

00009f06 <.Loc.277.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    9f06:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9f08:	4e 43       	clr.b	r14		;
    9f0a:	1c 42 4a b7 	mov	&0xb74a,r12	;0xb74a
    9f0e:	b0 12 fe 46 	call	#18174		;#0x46fe

00009f12 <.LVL62>:
  
  if (next_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    9f12:	b2 90 5d b8 	cmp	#-18339,&0xb42a	;#0xb85d
    9f16:	2a b4 
    9f18:	04 24       	jz	$+10     	;abs 0x9f22

00009f1a <.Loc.283.1>:
    next_rx_buf = rx_buf;
  }
  else {
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9f1a:	b2 40 5d b8 	mov	#-18339,&0xb42a	;#0xb85d
    9f1e:	2a b4 

00009f20 <.L64>:
  }
  
  chSysUnlockFromISR();
}
    9f20:	30 41       	ret			

00009f22 <.L67>:
    next_rx_buf = rx_buf;
    9f22:	b2 40 5d b7 	mov	#-18595,&0xb42a	;#0xb75d
    9f26:	2a b4 
    9f28:	fb 3f       	jmp	$-8      	;abs 0x9f20

00009f2a <crcGenX25>:
    9f2a:	1a 15       	pushm	#2,	r10	;16-bit words

00009f2c <L0>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    9f2c:	09 4c       	mov	r12,	r9	;
    9f2e:	0a 4d       	mov	r13,	r10	;

00009f30 <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9f30:	c2 93 5d b9 	cmp.b	#0,	&0xb95d	;r3 As==00
    9f34:	07 20       	jnz	$+16     	;abs 0x9f44

00009f36 <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    9f36:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9f38:	0c 9a       	cmp	r10,	r12	;
    9f3a:	09 2c       	jc	$+20     	;abs 0x9f4e

00009f3c <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9f3c:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00009f40 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9f40:	4c 43       	clr.b	r12		;
    9f42:	0f 3c       	jmp	$+32     	;abs 0x9f62

00009f44 <.L6>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9f44:	3c 40 eb b1 	mov	#-19989,r12	;#0xb1eb
    9f48:	b0 12 a6 44 	call	#17574		;#0x44a6

00009f4c <.LVL4>:
    9f4c:	f4 3f       	jmp	$-22     	;abs 0x9f36

00009f4e <.L7>:
  chDbgAssert(n >= 2, "message too small to CRC");
    9f4e:	3c 40 eb b1 	mov	#-19989,r12	;#0xb1eb
    9f52:	b0 12 a6 44 	call	#17574		;#0x44a6

00009f56 <.LVL5>:
    9f56:	f2 3f       	jmp	$-26     	;abs 0x9f3c

00009f58 <.L5>:
      CRCDI_L = message[i];
    9f58:	0d 49       	mov	r9,	r13	;
    9f5a:	0d 5c       	add	r12,	r13	;
    9f5c:	e2 4d 50 01 	mov.b	@r13,	&0x0150	;

00009f60 <.Loc.51.1>:
    for (size_t i = 0; i < n-2; i++) {
    9f60:	1c 53       	inc	r12		;

00009f62 <.L4>:
    9f62:	0d 4a       	mov	r10,	r13	;
    9f64:	3d 50 fe ff 	add	#-2,	r13	;#0xfffe
    9f68:	0c 9d       	cmp	r13,	r12	;
    9f6a:	f6 2b       	jnc	$-18     	;abs 0x9f58

00009f6c <.LBE3>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    9f6c:	0d 59       	add	r9,	r13	;
    9f6e:	5c 42 57 01 	mov.b	&0x0157,r12	;0x0157

00009f72 <.LVL8>:
    9f72:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    9f74:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

00009f78 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    9f78:	3a 53       	add	#-1,	r10	;r3 As==11

00009f7a <.LVL9>:
    9f7a:	0a 59       	add	r9,	r10	;

00009f7c <.LVL10>:
    9f7c:	5c 42 56 01 	mov.b	&0x0156,r12	;0x0156
    9f80:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    9f82:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00009f86 <.Loc.63.1>:
}
    9f86:	19 17       	popm	#2,	r10	;16-bit words
    9f88:	30 41       	ret			

00009f8a <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    9f8a:	1a 15       	pushm	#2,	r10	;16-bit words

00009f8c <.LCFI1>:
    9f8c:	0a 4c       	mov	r12,	r10	;
    9f8e:	09 4d       	mov	r13,	r9	;

00009f90 <L0>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9f90:	c2 93 5d b9 	cmp.b	#0,	&0xb95d	;r3 As==00
    9f94:	04 20       	jnz	$+10     	;abs 0x9f9e

00009f96 <.L9>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9f96:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00009f9a <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9f9a:	4d 43       	clr.b	r13		;
    9f9c:	0a 3c       	jmp	$+22     	;abs 0x9fb2

00009f9e <.L13>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9f9e:	3c 40 df b1 	mov	#-20001,r12	;#0xb1df
    9fa2:	b0 12 a6 44 	call	#17574		;#0x44a6

00009fa6 <.LVL15>:
    9fa6:	f7 3f       	jmp	$-16     	;abs 0x9f96

00009fa8 <.L11>:
      CRCDI_L = message[i];
    9fa8:	0e 4a       	mov	r10,	r14	;
    9faa:	0e 5d       	add	r13,	r14	;
    9fac:	e2 4e 50 01 	mov.b	@r14,	&0x0150	;

00009fb0 <.Loc.85.1>:
    for (size_t i = 0; i < n-2; i++) {
    9fb0:	1d 53       	inc	r13		;

00009fb2 <.L10>:
    9fb2:	0e 49       	mov	r9,	r14	;
    9fb4:	3e 50 fe ff 	add	#-2,	r14	;#0xfffe
    9fb8:	0d 9e       	cmp	r14,	r13	;
    9fba:	f6 2b       	jnc	$-18     	;abs 0x9fa8

00009fbc <.LBE5>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    9fbc:	1f 42 56 01 	mov	&0x0156,r15	;0x0156
    9fc0:	3f e3       	inv	r15		;
    9fc2:	0e 5a       	add	r10,	r14	;
    9fc4:	6d 4e       	mov.b	@r14,	r13	;

00009fc6 <.LVL18>:
    9fc6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9fca:	0a 59       	add	r9,	r10	;

00009fcc <.LVL19>:
    9fcc:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    9fd0:	0d da       	bis	r10,	r13	;
    9fd2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9fd4:	0f 9d       	cmp	r13,	r15	;
    9fd6:	01 24       	jz	$+4      	;abs 0x9fda
    9fd8:	4c 43       	clr.b	r12		;

00009fda <.L12>:
}
    9fda:	19 17       	popm	#2,	r10	;16-bit words
    9fdc:	30 41       	ret			

00009fde <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9fde:	c2 93 5d b9 	cmp.b	#0,	&0xb95d	;r3 As==00

00009fe2 <L0>:
    9fe2:	07 20       	jnz	$+16     	;abs 0x9ff2

00009fe4 <.L15>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9fe4:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00009fe8 <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    9fe8:	d2 43 5d b9 	mov.b	#1,	&0xb95d	;r3 As==01

00009fec <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    9fec:	3c 40 50 01 	mov	#336,	r12	;#0x0150
    9ff0:	30 41       	ret			

00009ff2 <.L16>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9ff2:	3c 40 d6 b1 	mov	#-20010,r12	;#0xb1d6
    9ff6:	b0 12 a6 44 	call	#17574		;#0x44a6

00009ffa <.LVL20>:
    9ffa:	f4 3f       	jmp	$-22     	;abs 0x9fe4

00009ffc <crcStop>:
    9ffc:	d2 93       	cmp.b	#1		;r3 As==01, Warning: disassembly unreliable - not enough bytes available

00009ffe <L0>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    9ffe:	5d b9 04 24 	bit.b	9220(r9),r13	;0x02404

0000a002 <.Loc.119.1>:
    a002:	3c 40 ce b1 	mov	#-20018,r12	;#0xb1ce
    a006:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a00a <.L18>:
  /* Change state */
  crc_state = CRC_STOPPED;
    a00a:	c2 43 5d b9 	mov.b	#0,	&0xb95d	;r3 As==00

0000a00e <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    a00e:	1c 42 56 01 	mov	&0x0156,r12	;0x0156
    a012:	3c e3       	inv	r12		;
    a014:	30 41       	ret			

0000a016 <end_cb>:
  {{1, 1, 1, 1, NULL, NULL, 1}, };
static fram_req_t * active_req;

static BSEMAPHORE_DECL(fram_sem, 0); /* not taken */

void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    a016:	0a 15       	pushm	#1,	r10	;16-bit words

0000a018 <.LCFI0>:
    a018:	0a 4d       	mov	r13,	r10	;

0000a01a <.Loc.22.1>:
  (void)(n);
  /* End the transfer */
  chSysLockFromISR();
  i2cMSP430XEndTransferI(i2cp);
    a01a:	b0 12 c2 55 	call	#21954		;#0x55c2

0000a01e <.LVL1>:
  chSysUnlockFromISR();
  /* Call the FRAM callback */
  current_callback(buffer);
    a01e:	0c 4a       	mov	r10,	r12	;
    a020:	1d 42 10 ba 	mov	&0xba10,r13	;0xba10
    a024:	8d 12       	call	r13		;

0000a026 <.LVL2>:
  /* Signal that I2C is available */
  chSysLockFromISR();
  elyQueueFreeBufferI(&fram_queue, (uint8_t *)(active_req));
    a026:	1d 42 0e ba 	mov	&0xba0e,r13	;0xba0e
    a02a:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c
    a02e:	b0 12 6a a5 	call	#-23190	;#0xa56a

0000a032 <.LBB26>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a032:	1c 42 32 b4 	mov	&0xb432,r12	;0xb432
    a036:	4d 43       	clr.b	r13		;
    a038:	0d 9c       	cmp	r12,	r13	;
    a03a:	02 34       	jge	$+6      	;abs 0xa040

0000a03c <.L1>:
  chBSemSignalI(&fram_sem);
  chSysUnlockFromISR();
}
    a03c:	0a 17       	popm	#1,	r10	;16-bit words
    a03e:	30 41       	ret			

0000a040 <.L3>:
    chSemSignalI(&bsp->sem);
    a040:	3c 40 32 b4 	mov	#-19406,r12	;#0xb432
    a044:	b0 12 ac 46 	call	#18092		;#0x46ac

0000a048 <.LBE29>:
    a048:	f9 3f       	jmp	$-12     	;abs 0xa03c

0000a04a <addr_cb>:
    a04a:	1a 15       	pushm	#2,	r10	;16-bit words

0000a04c <L0>:

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    a04c:	17 15       	pushm	#2,	r7	;16-bit words

0000a04e <.LCFI2>:
    a04e:	31 80 06 00 	sub	#6,	r1	;

0000a052 <.LCFI3>:
    a052:	09 4c       	mov	r12,	r9	;

0000a054 <.Loc.36.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    a054:	1a 42 0e ba 	mov	&0xba0e,r10	;0xba0e

0000a058 <.Loc.40.1>:
  
  chSysLockFromISR();
  /* TODO put in an assert in here for the Rev A crossing page boundaries */
  if (req->read) {
    a058:	5c 4a 04 00 	mov.b	4(r10),	r12	;

0000a05c <.LVL9>:
    a05c:	4d 4c       	mov.b	r12,	r13	;

0000a05e <.LVL10>:
    a05e:	6d f3       	and.b	#2,	r13	;r3 As==10
    a060:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    a062:	40 24       	jz	$+130    	;abs 0xa0e4

0000a064 <.Loc.41.1>:
    if (req->special) {
    a064:	1c b3       	bit	#1,	r12	;r3 As==01
    a066:	1f 24       	jz	$+64     	;abs 0xa0a6

0000a068 <.Loc.43.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    a068:	1c 4a 04 00 	mov	4(r10),	r12	;
    a06c:	b0 12 d2 ac 	call	#-21294	;#0xacd2

0000a070 <.LVL11>:
    a070:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    a074:	0e 4d       	mov	r13,	r14	;
    a076:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    a07a:	0e dc       	bis	r12,	r14	;
    a07c:	81 4e 02 00 	mov	r14,	2(r1)	;
    a080:	5d 07       	rrum	#2,	r13	;
    a082:	5d f3       	and.b	#1,	r13	;r3 As==01
    a084:	81 4d 04 00 	mov	r13,	4(r1)	;

0000a088 <.Loc.42.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    a088:	1f 4a 08 00 	mov	8(r10),	r15	;
    a08c:	3c 01 02 00 	mova	2(r1),	r12	;
    a090:	40 18 0e 4c 	movx.w	r12,	r14	;
    a094:	5d 4a 0c 00 	mov.b	12(r10),r13	;0x0000c
    a098:	b1 40 16 a0 	mov	#-24554,0(r1)	;#0xa016
    a09c:	00 00 
    a09e:	0c 49       	mov	r9,	r12	;
    a0a0:	b0 12 e6 51 	call	#20966		;#0x51e6

0000a0a4 <.LVL12>:
    a0a4:	64 3c       	jmp	$+202    	;abs 0xa16e

0000a0a6 <.L6>:
    }
    else {
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    a0a6:	1c 4a 04 00 	mov	4(r10),	r12	;
    a0aa:	b0 12 d2 ac 	call	#-21294	;#0xacd2

0000a0ae <.LVL14>:
    a0ae:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    a0b2:	0e 4d       	mov	r13,	r14	;
    a0b4:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    a0b8:	0e dc       	bis	r12,	r14	;
    a0ba:	81 4e 02 00 	mov	r14,	2(r1)	;
    a0be:	5d 07       	rrum	#2,	r13	;
    a0c0:	5d f3       	and.b	#1,	r13	;r3 As==01
    a0c2:	81 4d 04 00 	mov	r13,	4(r1)	;
    a0c6:	1f 4a 08 00 	mov	8(r10),	r15	;
    a0ca:	3c 01 02 00 	mova	2(r1),	r12	;
    a0ce:	40 18 0e 4c 	movx.w	r12,	r14	;
    a0d2:	5d 4a 0c 00 	mov.b	12(r10),r13	;0x0000c
    a0d6:	b1 40 16 a0 	mov	#-24554,0(r1)	;#0xa016
    a0da:	00 00 
    a0dc:	0c 49       	mov	r9,	r12	;
    a0de:	b0 12 d6 52 	call	#21206		;#0x52d6

0000a0e2 <.LVL15>:
    a0e2:	45 3c       	jmp	$+140    	;abs 0xa16e

0000a0e4 <.L5>:
          req->buffer, end_cb);
    }
  }
  else {
#if ELY_REVISION == A
    chDbgAssert(req->size <= 128 - (req->address & 0x7F), "crosses page boundaries");
    a0e4:	1c 4a 04 00 	mov	4(r10),	r12	;
    a0e8:	b0 12 d2 ac 	call	#-21294	;#0xacd2

0000a0ec <.LVL17>:
    a0ec:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    a0f0:	0e 4d       	mov	r13,	r14	;
    a0f2:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    a0f6:	0e dc       	bis	r12,	r14	;
    a0f8:	81 4e 02 00 	mov	r14,	2(r1)	;
    a0fc:	5d 07       	rrum	#2,	r13	;
    a0fe:	5d f3       	and.b	#1,	r13	;r3 As==01
    a100:	81 4d 04 00 	mov	r13,	4(r1)	;
    a104:	3c 01 02 00 	mova	2(r1),	r12	;
    a108:	0c 14       	pushm.a	#1,	r12	;20-bit words
    a10a:	40 18 36 41 	popx.w	r6		;
    a10e:	40 18 37 41 	popx.w	r7		;
    a112:	2e 4a       	mov	@r10,	r14	;
    a114:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    a118:	4f 43       	clr.b	r15		;
    a11a:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    a11e:	4d 43       	clr.b	r13		;
    a120:	0c 8e       	sub	r14,	r12	;
    a122:	0d 7f       	subc	r15,	r13	;
    a124:	0d 97       	cmp	r7,	r13	;
    a126:	2d 28       	jnc	$+92     	;abs 0xa182
    a128:	07 9d       	cmp	r13,	r7	;
    a12a:	29 24       	jz	$+84     	;abs 0xa17e

0000a12c <.L8>:
#endif
    if (req->special) {
    a12c:	da b3 04 00 	bit.b	#1,	4(r10)	;r3 As==01
    a130:	2d 20       	jnz	$+92     	;abs 0xa18c

0000a132 <.Loc.59.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    }
    else {
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    a132:	1c 4a 04 00 	mov	4(r10),	r12	;
    a136:	b0 12 d2 ac 	call	#-21294	;#0xacd2
    a13a:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    a13e:	0e 4d       	mov	r13,	r14	;
    a140:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    a144:	0e dc       	bis	r12,	r14	;
    a146:	81 4e 02 00 	mov	r14,	2(r1)	;
    a14a:	5d 07       	rrum	#2,	r13	;
    a14c:	5d f3       	and.b	#1,	r13	;r3 As==01
    a14e:	81 4d 04 00 	mov	r13,	4(r1)	;
    a152:	1f 4a 08 00 	mov	8(r10),	r15	;
    a156:	3c 01 02 00 	mova	2(r1),	r12	;
    a15a:	40 18 0e 4c 	movx.w	r12,	r14	;
    a15e:	5d 4a 0c 00 	mov.b	12(r10),r13	;0x0000c
    a162:	b1 40 16 a0 	mov	#-24554,0(r1)	;#0xa016
    a166:	00 00 
    a168:	0c 49       	mov	r9,	r12	;
    a16a:	b0 12 20 55 	call	#21792		;#0x5520

0000a16e <.L7>:
          req->buffer, end_cb);
    }
  }
  /* Either way save the callback and we're done with the request object */
  current_callback = req->callback;
    a16e:	92 4a 0a 00 	mov	10(r10),&0xba10	;0x0000a
    a172:	10 ba 

0000a174 <.Loc.66.1>:
  chSysUnlockFromISR();
}
    a174:	31 50 06 00 	add	#6,	r1	;
    a178:	16 17       	popm	#2,	r7	;16-bit words
    a17a:	19 17       	popm	#2,	r10	;16-bit words
    a17c:	30 41       	ret			

0000a17e <.L12>:
    chDbgAssert(req->size <= 128 - (req->address & 0x7F), "crosses page boundaries");
    a17e:	0c 96       	cmp	r6,	r12	;
    a180:	d5 2f       	jc	$-84     	;abs 0xa12c

0000a182 <.L11>:
    a182:	3c 40 09 b2 	mov	#-19959,r12	;#0xb209
    a186:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a18a <.LVL20>:
    a18a:	d0 3f       	jmp	$-94     	;abs 0xa12c

0000a18c <.L13>:
          req->size, req->buffer, end_cb);
    a18c:	1c 4a 04 00 	mov	4(r10),	r12	;
    a190:	b0 12 d2 ac 	call	#-21294	;#0xacd2
    a194:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    a198:	0e 4d       	mov	r13,	r14	;
    a19a:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    a19e:	0e dc       	bis	r12,	r14	;
    a1a0:	81 4e 02 00 	mov	r14,	2(r1)	;
    a1a4:	5d 07       	rrum	#2,	r13	;
    a1a6:	5d f3       	and.b	#1,	r13	;r3 As==01
    a1a8:	81 4d 04 00 	mov	r13,	4(r1)	;

0000a1ac <.Loc.55.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    a1ac:	1f 4a 08 00 	mov	8(r10),	r15	;
    a1b0:	3c 01 02 00 	mova	2(r1),	r12	;
    a1b4:	40 18 0e 4c 	movx.w	r12,	r14	;
    a1b8:	5d 4a 0c 00 	mov.b	12(r10),r13	;0x0000c
    a1bc:	b1 40 16 a0 	mov	#-24554,0(r1)	;#0xa016
    a1c0:	00 00 
    a1c2:	0c 49       	mov	r9,	r12	;
    a1c4:	b0 12 80 54 	call	#21632		;#0x5480

0000a1c8 <.LVL22>:
    a1c8:	d2 3f       	jmp	$-90     	;abs 0xa16e

0000a1ca <fram_handle_request>:
    a1ca:	0a 15       	pushm	#1,	r10	;16-bit words

0000a1cc <.LCFI4>:

void fram_handle_request(fram_req_t * req) {
    a1cc:	21 83       	decd	r1		;

0000a1ce <.LCFI5>:
    a1ce:	0a 4c       	mov	r12,	r10	;

0000a1d0 <.Loc.69.1>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    a1d0:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a1d2 <L0>:
    a1d2:	1c 9a 02 00 	cmp	2(r10),	r12	;
    a1d6:	1f 28       	jnc	$+64     	;abs 0xa216

0000a1d8 <.L15>:
  
  active_req = req;
    a1d8:	82 4a 0e ba 	mov	r10,	&0xba0e	;

0000a1dc <.Loc.74.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    a1dc:	2c 4a       	mov	@r10,	r12	;
    a1de:	1d 4a 02 00 	mov	2(r10),	r13	;
    a1e2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    a1e6:	b0 12 4c ad 	call	#-21172	;#0xad4c

0000a1ea <.Loc.73.1>:
  req->device_id = (slave_id | device_select | 
    a1ea:	4d 4c       	mov.b	r12,	r13	;
    a1ec:	7d d0 50 00 	bis.b	#80,	r13	;#0x0050
    a1f0:	ca 4d 0c 00 	mov.b	r13,	12(r10)	; 0x000c

0000a1f4 <.LBB30>:
  _disable_interrupts();
    a1f4:	32 c2       	dint			

0000a1f6 <.Loc.348.3>:
  asm volatile("nop");
    a1f6:	03 43       	nop			

0000a1f8 <.LBE30>:
  
  /* Issue a write to set the address */
  chSysLock();
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    a1f8:	b1 40 4a a0 	mov	#-24502,0(r1)	;#0xa04a
    a1fc:	00 00 
    a1fe:	0f 4a       	mov	r10,	r15	;
    a200:	6e 43       	mov.b	#2,	r14	;r3 As==10
    a202:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e
    a206:	b0 12 c8 53 	call	#21448		;#0x53c8

0000a20a <.LBB32>:
  asm volatile("nop");
    a20a:	03 43       	nop			

0000a20c <.Loc.356.3>:
  _enable_interrupts();
    a20c:	32 d2       	eint			
    a20e:	03 43       	nop			

0000a210 <.LBE32>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
  chSysUnlock();
}
    a210:	21 53       	incd	r1		;
    a212:	0a 17       	popm	#1,	r10	;16-bit words
    a214:	30 41       	ret			

0000a216 <.L18>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    a216:	3c 40 f5 b1 	mov	#-19979,r12	;#0xb1f5
    a21a:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a21e <.LVL27>:
    a21e:	dc 3f       	jmp	$-70     	;abs 0xa1d8

0000a220 <elyFramGetRequest>:
    a220:	0a 15       	pushm	#1,	r10	;16-bit words

0000a222 <L0>:

msg_t elyFramGetRequest(fram_req_t ** reqp) {
    a222:	0a 4c       	mov	r12,	r10	;

0000a224 <.Loc.85.1>:
  msg_t r = elyQueueGetEmptyBufferTimeout(&fram_queue, (uint8_t **)reqp, TIME_IMMEDIATE);
    a224:	3e 43       	mov	#-1,	r14	;r3 As==11
    a226:	0d 4c       	mov	r12,	r13	;
    a228:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c

0000a22c <.LVL29>:
    a22c:	b0 12 5a a5 	call	#-23206	;#0xa55a

0000a230 <.LVL30>:
  /* ENH remove this hack - should be at PointOfCall */
  (*reqp)->special = 0;
    a230:	2d 4a       	mov	@r10,	r13	;
    a232:	dd c3 04 00 	bic.b	#1,	4(r13)	;r3 As==01

0000a236 <.Loc.89.1>:
  return r;
}
    a236:	0a 17       	popm	#1,	r10	;16-bit words
    a238:	30 41       	ret			

0000a23a <elyFramPostRequest>:
  _disable_interrupts();
    a23a:	32 c2       	dint			

0000a23c <.Loc.348.3>:
  asm volatile("nop");
    a23c:	03 43       	nop			

0000a23e <.LBE34>:

msg_t elyFramPostRequest(fram_req_t * req) {
  msg_t result;
  chSysLock();
  result = elyQueuePostFullBufferS(&fram_queue, (uint8_t *)(req), TIME_IMMEDIATE);
    a23e:	3e 43       	mov	#-1,	r14	;r3 As==11
    a240:	0d 4c       	mov	r12,	r13	;
    a242:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c

0000a246 <.LVL32>:
    a246:	b0 12 14 a5 	call	#-23276	;#0xa514

0000a24a <.LBB36>:
  asm volatile("nop");
    a24a:	03 43       	nop			

0000a24c <.Loc.356.3>:
  _enable_interrupts();
    a24c:	32 d2       	eint			
    a24e:	03 43       	nop			

0000a250 <.LBE36>:
  chSysUnlock();
  return result;
}
    a250:	30 41       	ret			

0000a252 <elyFramGetRequestTimeoutS>:

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    a252:	0a 15       	pushm	#1,	r10	;16-bit words

0000a254 <.LCFI7>:
    a254:	0a 4c       	mov	r12,	r10	;

0000a256 <.Loc.100.1>:
  msg_t r = elyQueueGetEmptyBufferTimeoutS(&fram_queue, (uint8_t **)reqp, timeout);
    a256:	0e 4d       	mov	r13,	r14	;
    a258:	0d 4c       	mov	r12,	r13	;

0000a25a <.LVL35>:
    a25a:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c

0000a25e <.LVL36>:
    a25e:	b0 12 3a a5 	call	#-23238	;#0xa53a

0000a262 <.LVL37>:
  (*reqp)->special = 0;
    a262:	2d 4a       	mov	@r10,	r13	;
    a264:	dd c3 04 00 	bic.b	#1,	4(r13)	;r3 As==01

0000a268 <.Loc.103.1>:
  return r;
}
    a268:	0a 17       	popm	#1,	r10	;16-bit words
    a26a:	30 41       	ret			

0000a26c <FramThd>:
static I2CConfig cfg = {
  400000, /* max bitrate supported by USCI */
};

THD_WORKING_AREA(waFramThd, 128);
THD_FUNCTION(FramThd, arg) {
    a26c:	21 83       	decd	r1		;

0000a26e <.LCFI8>:
  (void)arg;
  fram_req_t * req;
  
  i2cStart(&I2CDB0, &cfg);
    a26e:	3d 40 2e b4 	mov	#-19410,r13	;#0xb42e
    a272:	3c 40 3e b5 	mov	#-19138,r12	;#0xb53e

0000a276 <.LVL39>:
    a276:	b0 12 ee 4b 	call	#19438		;#0x4bee

0000a27a <.LVL40>:
  
  if (!elyIsQueueInitialized(&fram_queue)) {
    a27a:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c
    a27e:	b0 12 e2 a4 	call	#-23326	;#0xa4e2

0000a282 <.LVL41>:
    a282:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a284:	15 20       	jnz	$+44     	;abs 0xa2b0

0000a286 <.Loc.117.1>:
    elyQueueObjectInit(&fram_queue, sizeof(fram_req_t), (uint8_t *)(fram_queue_storage));
    a286:	3e 40 34 b4 	mov	#-19404,r14	;#0xb434
    a28a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    a28e:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c
    a292:	b0 12 f4 a4 	call	#-23308	;#0xa4f4

0000a296 <.LVL42>:
    a296:	0c 3c       	jmp	$+26     	;abs 0xa2b0

0000a298 <.L25>:
  return chSemWaitTimeout(&bsp->sem, time);
    a298:	4d 43       	clr.b	r13		;
    a29a:	3c 40 32 b4 	mov	#-19406,r12	;#0xb432
    a29e:	b0 12 9c 46 	call	#18076		;#0x469c

0000a2a2 <.LBE38>:
  }
  
  while (MSG_OK == elyQueuePend(&fram_queue, (uint8_t**)(&req), TIME_INFINITE)) {
    /* TODO timeout for safety */
    chBSemWaitTimeout(&fram_sem, TIME_INFINITE);
    fram_handle_request(req);
    a2a2:	2c 41       	mov	@r1,	r12	;
    a2a4:	b0 12 ca a1 	call	#-24118	;#0xa1ca

0000a2a8 <.LVL45>:
#if ELY_REVISION == A
    chThdSleepMilliseconds(10);
    a2a8:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a
    a2ac:	b0 12 4a 46 	call	#17994		;#0x464a

0000a2b0 <.L24>:
  while (MSG_OK == elyQueuePend(&fram_queue, (uint8_t**)(&req), TIME_INFINITE)) {
    a2b0:	4e 43       	clr.b	r14		;
    a2b2:	0d 41       	mov	r1,	r13	;
    a2b4:	3c 40 6c b4 	mov	#-19348,r12	;#0xb46c
    a2b8:	b0 12 9a a5 	call	#-23142	;#0xa59a

0000a2bc <.LVL47>:
    a2bc:	0c 93       	cmp	#0,	r12	;r3 As==00
    a2be:	ec 27       	jz	$-38     	;abs 0xa298

0000a2c0 <.Loc.129.1>:
#endif
  }
  
}
    a2c0:	21 53       	incd	r1		;
    a2c2:	30 41       	ret			

0000a2c4 <evt_idx>:
void elyEventSignalI(uint8_t event) {
  chDbgCheckClassI();
  chEvtSignalI(event_thd, mask_from_event(event));
}

static uint8_t evt_idx(uint8_t event) {
    a2c4:	3c f0       	and,		r12	;Warning: disassembly unreliable - not enough bytes available

0000a2c6 <L0>:
    a2c6:	ff 00       	suba	r0,	r15	;

0000a2c8 <.Loc.34.1>:
  if (event > 0xF0) {
    a2c8:	7d 40 f0 ff 	mov.b	#-16,	r13	;#0xfff0
    a2cc:	4d 9c       	cmp.b	r12,	r13	;
    a2ce:	09 28       	jnc	$+20     	;abs 0xa2e2

0000a2d0 <.Loc.37.1>:
    return (event-0xF0)+(EvtCoreMAX-0xC0)+(EvtNLMAX-0xE0);
  }
  else if (event > 0xE0) {
    a2d0:	7d 40 e0 ff 	mov.b	#-32,	r13	;#0xffe0
    a2d4:	4d 9c       	cmp.b	r12,	r13	;
    a2d6:	0a 28       	jnc	$+22     	;abs 0xa2ec

0000a2d8 <.Loc.40.1>:
    return (event-0xE0)+(EvtCoreMAX-0xC0);
  }
  return event - 0xC0;
    a2d8:	7c 50 40 00 	add.b	#64,	r12	;#0x0040

0000a2dc <.LVL1>:
    a2dc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a2e0:	04 3c       	jmp	$+10     	;abs 0xa2ea

0000a2e2 <.L5>:
    return (event-0xF0)+(EvtCoreMAX-0xC0)+(EvtNLMAX-0xE0);
    a2e2:	7c 50 26 00 	add.b	#38,	r12	;#0x0026
    a2e6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a2ea <.L3>:
}
    a2ea:	30 41       	ret			

0000a2ec <.L6>:
    return (event-0xE0)+(EvtCoreMAX-0xC0);
    a2ec:	7c 50 33 00 	add.b	#51,	r12	;#0x0033
    a2f0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a2f4:	fa 3f       	jmp	$-10     	;abs 0xa2ea

0000a2f6 <get_next_event>:
    a2f6:	0a 15       	pushm	#1,	r10	;16-bit words

0000a2f8 <.LCFI0>:
  }
  chSysUnlock();
}

/* TODO make sure this is right, port it to Errors */
static eventmask_t get_next_event(eventmask_t mask) {
    a2f8:	0a 4c       	mov	r12,	r10	;

0000a2fa <L0>:
    a2fa:	0b 4d       	mov	r13,	r11	;

0000a2fc <.Loc.92.1>:
  mask ^= mask & (mask - (eventmask_t)1);
    a2fc:	4e 43       	clr.b	r14		;
    a2fe:	4f 43       	clr.b	r15		;
    a300:	0e 8a       	sub	r10,	r14	;
    a302:	0f 7b       	subc	r11,	r15	;

0000a304 <.LVL3>:
  return mask;
}
    a304:	0c fe       	and	r14,	r12	;
    a306:	0d ff       	and	r15,	r13	;
    a308:	0a 17       	popm	#1,	r10	;16-bit words
    a30a:	30 41       	ret			

0000a30c <make_evt_buffer>:

static void make_evt_buffer(uint8_t * buffer, uint8_t event) {
    a30c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a30e <.LCFI1>:
    a30e:	0a 4c       	mov	r12,	r10	;
    a310:	4c 4d       	mov.b	r13,	r12	;

0000a312 <.LVL5>:
  buffer[0] = event;
    a312:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

0000a316 <.Loc.98.1>:
  buffer[1] = 0;
    a316:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00

0000a31a <.Loc.99.1>:
  buffer[2] = report_addrs[evt_idx(event)] >> 8;
    a31a:	b0 12 c4 a2 	call	#-23868	;#0xa2c4

0000a31e <.LVL6>:
    a31e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a322:	0c 5c       	rla	r12		;
    a324:	3c 50 cc ba 	add	#-17716,r12	;#0xbacc
    a328:	2d 4c       	mov	@r12,	r13	;
    a32a:	5d 0f       	rrum	#4,	r13	;
    a32c:	5d 0f       	rrum	#4,	r13	;
    a32e:	ca 4d 02 00 	mov.b	r13,	2(r10)	;

0000a332 <.Loc.100.1>:
  buffer[3] = report_addrs[evt_idx(event)] & 0xFF;
    a332:	ea 4c 03 00 	mov.b	@r12,	3(r10)	;

0000a336 <.Loc.101.1>:
}
    a336:	0a 17       	popm	#1,	r10	;16-bit words
    a338:	30 41       	ret			

0000a33a <elyEventSignal>:
  return (1U << (event & 0x3F));
    a33a:	0d 4c       	mov	r12,	r13	;
    a33c:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a340:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a342 <.LVL9>:
    a342:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a346 <.LBE37>:
  chEvtSignal(event_thd, mask_from_event(event));
    a346:	0d 4c       	mov	r12,	r13	;
    a348:	0e 43       	clr	r14		;
    a34a:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a34e:	b0 12 3a 47 	call	#18234		;#0x473a

0000a352 <.LVL11>:
}
    a352:	30 41       	ret			

0000a354 <elyEventSubscribe>:
void elyEventSubscribe(uint8_t event, uint16_t addr) {
    a354:	1a 15       	pushm	#2,	r10	;16-bit words

0000a356 <.LCFI2>:
    a356:	4a 4c       	mov.b	r12,	r10	;
    a358:	09 4d       	mov	r13,	r9	;

0000a35a <.LBB41>:
  return (1U << (event & 0x3F));
    a35a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a35c <.LVL19>:
    a35c:	0d 4a       	mov	r10,	r13	;

0000a35e <.LVL20>:
    a35e:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a362:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a366 <.LBE41>:
  reported_events |= mask_from_event(event);
    a366:	82 dc 1e c0 	bis	r12,	&0xc01e	;

0000a36a <.Loc.45.1>:
  report_addrs[evt_idx(event)] = addr;
    a36a:	4c 4a       	mov.b	r10,	r12	;
    a36c:	b0 12 c4 a2 	call	#-23868	;#0xa2c4

0000a370 <.LVL22>:
    a370:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a374:	0c 5c       	rla	r12		;
    a376:	8c 49 cc ba 	mov	r9,	-17716(r12); 0xbacc

0000a37a <.LBB43>:
  _disable_interrupts();
    a37a:	32 c2       	dint			

0000a37c <.Loc.348.2>:
  asm volatile("nop");
    a37c:	03 43       	nop			

0000a37e <.LBE43>:
  if (!NIL_THD_IS_READY(event_thd)) {
    a37e:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a382:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    a386:	05 20       	jnz	$+12     	;abs 0xa392

0000a388 <.L12>:
  asm volatile("nop");
    a388:	03 43       	nop			

0000a38a <.Loc.356.2>:
  _enable_interrupts();
    a38a:	32 d2       	eint			
    a38c:	03 43       	nop			

0000a38e <.LBE45>:
}
    a38e:	19 17       	popm	#2,	r10	;16-bit words
    a390:	30 41       	ret			

0000a392 <.L13>:
    chSchReadyI(event_thd, MSG_RESET);
    a392:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    a396:	b0 12 c2 44 	call	#17602		;#0x44c2

0000a39a <.LVL23>:
    a39a:	f6 3f       	jmp	$-18     	;abs 0xa388

0000a39c <elyEventUnsubscribe>:
    a39c:	0d 4c       	mov	r12,	r13	;

0000a39e <L0>:
  return (1U << (event & 0x3F));
    a39e:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a3a2:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a3a4 <.LVL26>:
    a3a4:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a3a8 <.LBE47>:
  reported_events &= ~(mask_from_event(event));
    a3a8:	82 cc 1e c0 	bic	r12,	&0xc01e	;

0000a3ac <.LBB49>:
  _disable_interrupts();
    a3ac:	32 c2       	dint			

0000a3ae <.Loc.348.2>:
  asm volatile("nop");
    a3ae:	03 43       	nop			

0000a3b0 <.LBE49>:
  if (!NIL_THD_IS_READY(event_thd)) {
    a3b0:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a3b4:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    a3b8:	04 20       	jnz	$+10     	;abs 0xa3c2

0000a3ba <.L15>:
  asm volatile("nop");
    a3ba:	03 43       	nop			

0000a3bc <.Loc.356.2>:
  _enable_interrupts();
    a3bc:	32 d2       	eint			
    a3be:	03 43       	nop			

0000a3c0 <.LBE51>:
}
    a3c0:	30 41       	ret			

0000a3c2 <.L16>:
    chSchReadyI(event_thd, MSG_RESET);
    a3c2:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    a3c6:	b0 12 c2 44 	call	#17602		;#0x44c2

0000a3ca <.LVL28>:
    a3ca:	f7 3f       	jmp	$-16     	;abs 0xa3ba

0000a3cc <elyEventLog>:
    a3cc:	0d 4c       	mov	r12,	r13	;

0000a3ce <L0>:
  return (1U << (event & 0x3F));
    a3ce:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a3d2:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a3d4 <.LVL31>:
    a3d4:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a3d8 <.LBE53>:
  logged_events |= mask_from_event(event);
    a3d8:	82 dc 22 c0 	bis	r12,	&0xc022	;

0000a3dc <.LBB55>:
  _disable_interrupts();
    a3dc:	32 c2       	dint			

0000a3de <.Loc.348.2>:
  asm volatile("nop");
    a3de:	03 43       	nop			

0000a3e0 <.LBE55>:
  if (!NIL_THD_IS_READY(event_thd)) {
    a3e0:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a3e4:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    a3e8:	04 20       	jnz	$+10     	;abs 0xa3f2

0000a3ea <.L18>:
  asm volatile("nop");
    a3ea:	03 43       	nop			

0000a3ec <.Loc.356.2>:
  _enable_interrupts();
    a3ec:	32 d2       	eint			
    a3ee:	03 43       	nop			

0000a3f0 <.LBE57>:
}
    a3f0:	30 41       	ret			

0000a3f2 <.L19>:
    chSchReadyI(event_thd, MSG_RESET);
    a3f2:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    a3f6:	b0 12 c2 44 	call	#17602		;#0x44c2

0000a3fa <.LVL33>:
    a3fa:	f7 3f       	jmp	$-16     	;abs 0xa3ea

0000a3fc <elyEventUnlog>:
    a3fc:	0d 4c       	mov	r12,	r13	;

0000a3fe <L0>:
  return (1U << (event & 0x3F));
    a3fe:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a402:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a404 <.LVL36>:
    a404:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a408 <.LBE59>:
  logged_events &= ~(mask_from_event(event));
    a408:	82 cc 22 c0 	bic	r12,	&0xc022	;

0000a40c <.LBB61>:
  _disable_interrupts();
    a40c:	32 c2       	dint			

0000a40e <.Loc.348.2>:
  asm volatile("nop");
    a40e:	03 43       	nop			

0000a410 <.LBE61>:
  if (!NIL_THD_IS_READY(event_thd)) {
    a410:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a414:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    a418:	04 20       	jnz	$+10     	;abs 0xa422

0000a41a <.L21>:
  asm volatile("nop");
    a41a:	03 43       	nop			

0000a41c <.Loc.356.2>:
  _enable_interrupts();
    a41c:	32 d2       	eint			
    a41e:	03 43       	nop			

0000a420 <.LBE63>:
}
    a420:	30 41       	ret			

0000a422 <.L22>:
    chSchReadyI(event_thd, MSG_RESET);
    a422:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    a426:	b0 12 c2 44 	call	#17602		;#0x44c2

0000a42a <.LVL38>:
    a42a:	f7 3f       	jmp	$-16     	;abs 0xa41a

0000a42c <elyEventReset>:
    a42c:	82 43       	mov	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

0000a42e <L0>:
  logged_events = 0;
    a42e:	22 c0       	bic	@r0,	r2	;
    a430:	82 43 24 c0 	mov	#0,	&0xc024	;r3 As==00

0000a434 <.Loc.82.1>:
  reported_events = 0;
    a434:	82 43 1e c0 	mov	#0,	&0xc01e	;r3 As==00
    a438:	82 43 20 c0 	mov	#0,	&0xc020	;r3 As==00

0000a43c <.LBB65>:
  _disable_interrupts();
    a43c:	32 c2       	dint			

0000a43e <.Loc.348.2>:
  asm volatile("nop");
    a43e:	03 43       	nop			

0000a440 <.LBE65>:
  if (!NIL_THD_IS_READY(event_thd)) {
    a440:	1c 42 ca ba 	mov	&0xbaca,r12	;0xbaca
    a444:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    a448:	04 20       	jnz	$+10     	;abs 0xa452

0000a44a <.L24>:
  asm volatile("nop");
    a44a:	03 43       	nop			

0000a44c <.Loc.356.2>:
  _enable_interrupts();
    a44c:	32 d2       	eint			
    a44e:	03 43       	nop			

0000a450 <.LBE67>:
}
    a450:	30 41       	ret			

0000a452 <.L25>:
    chSchReadyI(event_thd, MSG_RESET);
    a452:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    a456:	b0 12 c2 44 	call	#17602		;#0x44c2

0000a45a <.LVL39>:
    a45a:	f7 3f       	jmp	$-16     	;abs 0xa44a

0000a45c <EvtThd>:
    a45c:	4a 15       	pushm	#5,	r10	;16-bit words

0000a45e <L0>:
THD_FUNCTION(EvtThd, arg) {
  (void)arg;
  eventmask_t result;
  eventmask_t evt;
  
  event_thd = chThdGetSelfX();
    a45e:	92 42 8a b4 	mov	&0xb48a,&0xbaca	;0xb48a
    a462:	ca ba 

0000a464 <.L34>:
  
  while (true) {
    result = chEvtWaitAnyTimeout(logged_events | reported_events, TIME_INFINITE);
    a464:	4e 43       	clr.b	r14		;
    a466:	1c 42 22 c0 	mov	&0xc022,r12	;0xc022
    a46a:	1c d2 1e c0 	bis	&0xc01e,r12	;0xc01e
    a46e:	1d 42 24 c0 	mov	&0xc024,r13	;0xc024
    a472:	1d d2 20 c0 	bis	&0xc020,r13	;0xc020
    a476:	b0 12 4e 47 	call	#18254		;#0x474e

0000a47a <.LVL42>:
    a47a:	0a 4c       	mov	r12,	r10	;
    a47c:	09 4d       	mov	r13,	r9	;

0000a47e <.LVL43>:
    while (result > 0) {
    a47e:	14 3c       	jmp	$+42     	;abs 0xa4a8

0000a480 <.L31>:
    event >>= 1;
    a480:	12 c3       	clrc			
    a482:	0f 10       	rrc	r15		;
    a484:	0e 10       	rrc	r14		;

0000a486 <.Loc.19.1>:
    i++;
    a486:	1d 53       	inc	r13		;

0000a488 <.L30>:
  while (!(event & 1)) {
    a488:	0b 4e       	mov	r14,	r11	;
    a48a:	5b f3       	and.b	#1,	r11	;r3 As==01
    a48c:	0b 93       	cmp	#0,	r11	;r3 As==00
    a48e:	f8 27       	jz	$-14     	;abs 0xa480

0000a490 <.LBE70>:
        /* TODO log event */
      }
      
      if (reported_events & evt) {
        uint8_t * buffer = elyNLGetBuffer();
        make_evt_buffer(elyNLExtract(buffer), event_from_mask(evt));
    a490:	7d 50 c0 ff 	add.b	#-64,	r13	;#0xffc0
    a494:	b0 12 0c a3 	call	#-23796	;#0xa30c

0000a498 <.LVL48>:
        /* TODO timeout for safety */
        elyMainMBPost(elyNLPack(buffer), TIME_INFINITE);
    a498:	0c 46       	mov	r6,	r12	;
    a49a:	b0 12 4c a8 	call	#-22452	;#0xa84c

0000a49e <.LVL49>:
    a49e:	4d 43       	clr.b	r13		;
    a4a0:	b0 12 94 61 	call	#24980		;#0x6194

0000a4a4 <.L28>:
      }
      
      /* Remove the event from the mask */
      result &= ~evt;
    a4a4:	0a c7       	bic	r7,	r10	;

0000a4a6 <.LVL51>:
    a4a6:	09 c8       	bic	r8,	r9	;

0000a4a8 <.L27>:
    while (result > 0) {
    a4a8:	0c 4a       	mov	r10,	r12	;
    a4aa:	0c d9       	bis	r9,	r12	;
    a4ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    a4ae:	da 27       	jz	$-74     	;abs 0xa464

0000a4b0 <.Loc.115.1>:
      evt = get_next_event(result);
    a4b0:	0c 4a       	mov	r10,	r12	;
    a4b2:	0d 49       	mov	r9,	r13	;
    a4b4:	b0 12 f6 a2 	call	#-23818	;#0xa2f6

0000a4b8 <.LVL53>:
    a4b8:	07 4c       	mov	r12,	r7	;
    a4ba:	08 4d       	mov	r13,	r8	;

0000a4bc <.LVL54>:
      if (reported_events & evt) {
    a4bc:	1d 42 1e c0 	mov	&0xc01e,r13	;0xc01e
    a4c0:	0d f7       	and	r7,	r13	;
    a4c2:	1e 42 20 c0 	mov	&0xc020,r14	;0xc020
    a4c6:	0e f8       	and	r8,	r14	;
    a4c8:	0c 4d       	mov	r13,	r12	;
    a4ca:	0c de       	bis	r14,	r12	;
    a4cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    a4ce:	ea 27       	jz	$-42     	;abs 0xa4a4

0000a4d0 <.LBB74>:
        uint8_t * buffer = elyNLGetBuffer();
    a4d0:	b0 12 14 a7 	call	#-22764	;#0xa714

0000a4d4 <.LVL55>:
    a4d4:	06 4c       	mov	r12,	r6	;

0000a4d6 <.LVL56>:
        make_evt_buffer(elyNLExtract(buffer), event_from_mask(evt));
    a4d6:	b0 12 3a a8 	call	#-22470	;#0xa83a

0000a4da <.LVL57>:
    a4da:	0e 47       	mov	r7,	r14	;
    a4dc:	0f 48       	mov	r8,	r15	;

0000a4de <.LBB73>:
  size_t i = 0;
    a4de:	4d 43       	clr.b	r13		;
    a4e0:	d3 3f       	jmp	$-88     	;abs 0xa488

0000a4e2 <elyIsQueueInitialized>:
#include "queues.h"

bool elyIsQueueInitialized( queue_t * queue ) {
  return (queue->mpool.pool.object_size != 0);
    a4e2:	1d 4c 12 00 	mov	18(r12),r13	;0x00012

0000a4e6 <L0>:
    a4e6:	0c 43       	clr	r12		;
    a4e8:	0c 8d       	sub	r13,	r12	;

0000a4ea <.LVL1>:
    a4ea:	0c dd       	bis	r13,	r12	;

0000a4ec <.Loc.5.1>:
}
    a4ec:	5c 03       	rrum	#1,	r12	;
    a4ee:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    a4f2:	30 41       	ret			

0000a4f4 <elyQueueObjectInit>:

void elyQueueObjectInit( queue_t * queue, size_t buf_size, uint8_t * mpool_storage ) {
    a4f4:	2a 15       	pushm	#3,	r10	;16-bit words

0000a4f6 <.LCFI0>:
    a4f6:	09 4c       	mov	r12,	r9	;
    a4f8:	08 4e       	mov	r14,	r8	;

0000a4fa <.Loc.8.1>:
  chGuardedPoolObjectInit(&(queue->mpool), buf_size);
    a4fa:	0a 4c       	mov	r12,	r10	;
    a4fc:	3a 50 0e 00 	add	#14,	r10	;#0x000e
    a500:	0c 4a       	mov	r10,	r12	;

0000a502 <.LVL3>:
    a502:	b0 12 ec 49 	call	#18924		;#0x49ec

0000a506 <.LVL4>:
  chGuardedPoolLoadArray(&(queue->mpool), mpool_storage, queue->queue_len);
    a506:	2e 49       	mov	@r9,	r14	;
    a508:	0d 48       	mov	r8,	r13	;
    a50a:	0c 4a       	mov	r10,	r12	;
    a50c:	b0 12 44 4a 	call	#19012		;#0x4a44

0000a510 <.LVL5>:
}
    a510:	28 17       	popm	#3,	r10	;16-bit words
    a512:	30 41       	ret			

0000a514 <elyQueuePostFullBufferS>:

msg_t elyQueuePostFullBufferS(queue_t * queue, uint8_t * buffer, systime_t timeout) {
    a514:	2a 15       	pushm	#3,	r10	;16-bit words

0000a516 <.LCFI1>:
    a516:	0a 4c       	mov	r12,	r10	;
    a518:	09 4d       	mov	r13,	r9	;
    a51a:	08 4e       	mov	r14,	r8	;

0000a51c <.Loc.14.1>:
  chDbgCheckClassS();
  chDbgCheck(queue != NULL);
    a51c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a51e:	08 24       	jz	$+18     	;abs 0xa530

0000a520 <.L4>:
  
  return chMBPostS(&(queue->mbox), (msg_t)(buffer), timeout);
    a520:	0e 48       	mov	r8,	r14	;
    a522:	0d 49       	mov	r9,	r13	;
    a524:	0c 4a       	mov	r10,	r12	;
    a526:	2c 53       	incd	r12		;
    a528:	b0 12 ba 47 	call	#18362		;#0x47ba

0000a52c <.LVL8>:
}
    a52c:	28 17       	popm	#3,	r10	;16-bit words
    a52e:	30 41       	ret			

0000a530 <.L5>:
  chDbgCheck(queue != NULL);
    a530:	3c 40 1f b2 	mov	#-19937,r12	;#0xb21f
    a534:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a538 <.LVL9>:
    a538:	f3 3f       	jmp	$-24     	;abs 0xa520

0000a53a <elyQueueGetEmptyBufferTimeoutS>:
    a53a:	0a 15       	pushm	#1,	r10	;16-bit words

0000a53c <L0>:
  chDbgCheck(queue != NULL);
  
  return chMBPostAheadI(&(queue->mbox), (msg_t)(buffer));
}

msg_t elyQueueGetEmptyBufferTimeoutS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    a53c:	0a 4d       	mov	r13,	r10	;

0000a53e <.Loc.41.1>:
  void * result = chGuardedPoolAllocTimeoutS(&(queue->mpool), timeout);
    a53e:	0d 4e       	mov	r14,	r13	;

0000a540 <.LVL23>:
    a540:	3c 50 0e 00 	add	#14,	r12	;#0x000e

0000a544 <.LVL24>:
    a544:	b0 12 00 4a 	call	#18944		;#0x4a00

0000a548 <.LVL25>:
  if (result == NULL) {
    a548:	0c 93       	cmp	#0,	r12	;r3 As==00
    a54a:	05 24       	jz	$+12     	;abs 0xa556

0000a54c <.Loc.46.1>:
    return MSG_TIMEOUT;
  }
  
  (*bufferp) = result;
    a54c:	8a 4c 00 00 	mov	r12,	0(r10)	;

0000a550 <.Loc.47.1>:
  return MSG_OK;
    a550:	4c 43       	clr.b	r12		;

0000a552 <.L15>:
}
    a552:	0a 17       	popm	#1,	r10	;16-bit words
    a554:	30 41       	ret			

0000a556 <.L17>:
    return MSG_TIMEOUT;
    a556:	3c 43       	mov	#-1,	r12	;r3 As==11

0000a558 <.LVL28>:
    a558:	fc 3f       	jmp	$-6      	;abs 0xa552

0000a55a <elyQueueGetEmptyBufferTimeout>:
    a55a:	32 c2       	dint			

0000a55c <L0>:
  asm volatile("nop");
    a55c:	03 43       	nop			

0000a55e <.LBE16>:

msg_t elyQueueGetEmptyBufferTimeout(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
  msg_t result;
  chSysLock();
  result = elyQueueGetEmptyBufferTimeoutS(queue, bufferp, timeout);
    a55e:	b0 12 3a a5 	call	#-23238	;#0xa53a

0000a562 <.LBB18>:
  asm volatile("nop");
    a562:	03 43       	nop			

0000a564 <.Loc.356.2>:
  _enable_interrupts();
    a564:	32 d2       	eint			
    a566:	03 43       	nop			

0000a568 <.LBE18>:
  chSysUnlock();
  return result;
}
    a568:	30 41       	ret			

0000a56a <elyQueueFreeBufferI>:

void elyQueueFreeBufferI(queue_t * queue, uint8_t * buffer) {
  chGuardedPoolFreeI(&(queue->mpool), buffer);
    a56a:	3c 50 0e 00 	add	#14,	r12	;#0x000e

0000a56e <.LVL32>:
    a56e:	b0 12 1c 4a 	call	#18972		;#0x4a1c

0000a572 <.LVL33>:
}
    a572:	30 41       	ret			

0000a574 <elyQueuePendS>:

/* TODO add timeout variant using guarded pools */

msg_t elyQueuePendS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    a574:	2a 15       	pushm	#3,	r10	;16-bit words

0000a576 <.LCFI6>:
    a576:	0a 4c       	mov	r12,	r10	;
    a578:	09 4d       	mov	r13,	r9	;
    a57a:	08 4e       	mov	r14,	r8	;

0000a57c <.Loc.66.1>:
  chDbgCheckClassS();
  chDbgCheck(queue != NULL);
    a57c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a57e:	08 24       	jz	$+18     	;abs 0xa590

0000a580 <.L21>:
  
  return chMBFetchS(&(queue->mbox), (msg_t *)(bufferp), timeout);
    a580:	0e 48       	mov	r8,	r14	;
    a582:	0d 49       	mov	r9,	r13	;
    a584:	0c 4a       	mov	r10,	r12	;
    a586:	2c 53       	incd	r12		;
    a588:	b0 12 70 48 	call	#18544		;#0x4870

0000a58c <.LVL36>:
}
    a58c:	28 17       	popm	#3,	r10	;16-bit words
    a58e:	30 41       	ret			

0000a590 <.L22>:
  chDbgCheck(queue != NULL);
    a590:	3c 40 11 b2 	mov	#-19951,r12	;#0xb211
    a594:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a598 <.LVL37>:
    a598:	f3 3f       	jmp	$-24     	;abs 0xa580

0000a59a <elyQueuePend>:
    a59a:	32 c2       	dint			

0000a59c <L0>:
  asm volatile("nop");
    a59c:	03 43       	nop			

0000a59e <.LBE20>:

msg_t elyQueuePend(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
  msg_t result;
  chSysLock();
  result = elyQueuePendS(queue, bufferp, timeout);
    a59e:	b0 12 74 a5 	call	#-23180	;#0xa574

0000a5a2 <.LBB22>:
  asm volatile("nop");
    a5a2:	03 43       	nop			

0000a5a4 <.Loc.356.2>:
  _enable_interrupts();
    a5a4:	32 d2       	eint			
    a5a6:	03 43       	nop			

0000a5a8 <.LBE22>:
  chSysUnlock();
  return result;
}
    a5a8:	30 41       	ret			

0000a5aa <nl_allocator>:
  (void)(align);
  /* Provides memory blocks for the pool */
  /* TODO does this persistence work like you think? */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    a5aa:	1d 42 26 c0 	mov	&0xc026,r13	;0xc026

0000a5ae <.LVL1>:
    a5ae:	0e 4d       	mov	r13,	r14	;
    a5b0:	0e 5c       	add	r12,	r14	;
    a5b2:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

0000a5b6 <.LVL2>:
    a5b6:	0c 9e       	cmp	r14,	r12	;
    a5b8:	06 28       	jnc	$+14     	;abs 0xa5c6

0000a5ba <.Loc.23.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    a5ba:	0c 4d       	mov	r13,	r12	;
    a5bc:	3c 50 2a c0 	add	#-16342,r12	;#0xc02a

0000a5c0 <.LVL3>:
  
  curr_index += size;
    a5c0:	82 4e 26 c0 	mov	r14,	&0xc026	;

0000a5c4 <.L1>:
  return result;
}
    a5c4:	30 41       	ret			

0000a5c6 <.L3>:
    return NULL;
    a5c6:	4c 43       	clr.b	r12		;
    a5c8:	fd 3f       	jmp	$-4      	;abs 0xa5c4

0000a5ca <clamp>:
    a5ca:	1a 15       	pushm	#2,	r10	;16-bit words

0000a5cc <L0>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a5cc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a5d0:	4a 4d       	mov.b	r13,	r10	;
    a5d2:	49 4e       	mov.b	r14,	r9	;

0000a5d4 <.Loc.32.1>:
  if (value < min) {
    a5d4:	4c 9a       	cmp.b	r10,	r12	;
    a5d6:	04 28       	jnc	$+10     	;abs 0xa5e0

0000a5d8 <.Loc.36.1>:
    value = min;
    elyErrorSignal(ErrRegClip);
  }
  else if (value > max) {
    a5d8:	49 9c       	cmp.b	r12,	r9	;
    a5da:	08 28       	jnc	$+18     	;abs 0xa5ec

0000a5dc <.L6>:
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    a5dc:	19 17       	popm	#2,	r10	;16-bit words
    a5de:	30 41       	ret			

0000a5e0 <.L7>:
    elyErrorSignal(ErrRegClip);
    a5e0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a5e4:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a5e8 <.LVL8>:
    value = min;
    a5e8:	0c 4a       	mov	r10,	r12	;
    a5ea:	f8 3f       	jmp	$-14     	;abs 0xa5dc

0000a5ec <.L8>:
    elyErrorSignal(ErrRegClip);
    a5ec:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a5f0:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a5f4 <.LVL10>:
    value = max;
    a5f4:	0c 49       	mov	r9,	r12	;
    a5f6:	f2 3f       	jmp	$-26     	;abs 0xa5dc

0000a5f8 <clamp_err>:
    a5f8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a5fc <L0>:

static uint8_t clamp_err(uint8_t value) {
  if ((value & 0x10) && value != 0x10) {
    a5fc:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    a600:	0a 24       	jz	$+22     	;abs 0xa616

0000a602 <.Loc.44.1>:
    a602:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a606:	07 24       	jz	$+16     	;abs 0xa616

0000a608 <.Loc.45.1>:
    elyErrorSignal(ErrRegClip);
    a608:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a60c <.LVL12>:
    a60c:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a610 <.LVL13>:
    return 0x10;
    a610:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000a614 <.L11>:
  if (value & 0xD0) {
    elyErrorSignal(ErrRegClip);
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}
    a614:	30 41       	ret			

0000a616 <.L10>:
  if ((value & 0x08) && value != 0x08) {
    a616:	3c b2       	bit	#8,	r12	;r2 As==11
    a618:	08 24       	jz	$+18     	;abs 0xa62a

0000a61a <.Loc.48.1>:
    a61a:	3c 92       	cmp	#8,	r12	;r2 As==11
    a61c:	06 24       	jz	$+14     	;abs 0xa62a

0000a61e <.Loc.49.1>:
    elyErrorSignal(ErrRegClip);
    a61e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a622:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a626 <.LVL14>:
    return 0x08;
    a626:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a628:	f5 3f       	jmp	$-20     	;abs 0xa614

0000a62a <.L12>:
  if ((value & 0x04) && value != 0x04) {
    a62a:	2c b2       	bit	#4,	r12	;r2 As==10
    a62c:	08 24       	jz	$+18     	;abs 0xa63e

0000a62e <.Loc.52.1>:
    a62e:	2c 92       	cmp	#4,	r12	;r2 As==10
    a630:	06 24       	jz	$+14     	;abs 0xa63e

0000a632 <.Loc.53.1>:
    elyErrorSignal(ErrRegClip);
    a632:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a636:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a63a <.LVL15>:
    return 0x04;
    a63a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a63c:	eb 3f       	jmp	$-40     	;abs 0xa614

0000a63e <.L13>:
  if ((value & 0x02) && value != 0x02) {
    a63e:	2c b3       	bit	#2,	r12	;r3 As==10
    a640:	08 24       	jz	$+18     	;abs 0xa652

0000a642 <.Loc.56.1>:
    a642:	2c 93       	cmp	#2,	r12	;r3 As==10
    a644:	06 24       	jz	$+14     	;abs 0xa652

0000a646 <.Loc.57.1>:
    elyErrorSignal(ErrRegClip);
    a646:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a64a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a64e <.LVL16>:
    return 0x02;
    a64e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a650:	e1 3f       	jmp	$-60     	;abs 0xa614

0000a652 <.L14>:
  if ((value & 0x01) && value != 0x01) {
    a652:	1c b3       	bit	#1,	r12	;r3 As==01
    a654:	02 24       	jz	$+6      	;abs 0xa65a

0000a656 <.Loc.60.1>:
    a656:	1c 93       	cmp	#1,	r12	;r3 As==01
    a658:	09 20       	jnz	$+20     	;abs 0xa66c

0000a65a <.L15>:
  if (value & 0xD0) {
    a65a:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a65e:	da 27       	jz	$-74     	;abs 0xa614

0000a660 <.Loc.65.1>:
    elyErrorSignal(ErrRegClip);
    a660:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a664:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a668 <.LVL17>:
    return 0x00;
    a668:	4c 43       	clr.b	r12		;
    a66a:	d4 3f       	jmp	$-86     	;abs 0xa614

0000a66c <.L16>:
    elyErrorSignal(ErrRegClip);
    a66c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a670:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a674 <.LVL18>:
    return 0x01;
    a674:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a676:	ce 3f       	jmp	$-98     	;abs 0xa614

0000a678 <elyNLClampReg>:
    a678:	1a 15       	pushm	#2,	r10	;16-bit words

0000a67a <.LCFI1>:

uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    a67a:	4a 4c       	mov.b	r12,	r10	;
    a67c:	49 4d       	mov.b	r13,	r9	;

0000a67e <.Loc.72.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    a67e:	4c 4a       	mov.b	r10,	r12	;

0000a680 <.LVL20>:
    a680:	7c 50       	add.b,		r12	;Warning: disassembly unreliable - not enough bytes available

0000a682 <L0>:
    a682:	80 ff 7d 40 	and	r15,	0x407d	; PC rel. 0xe701
    a686:	09 00       	mova	@r0,	r9	;

0000a688 <.LVL21>:
    a688:	4d 9c       	cmp.b	r12,	r13	;
    a68a:	15 28       	jnc	$+44     	;abs 0xa6b6

0000a68c <.L18>:
  switch(addr) {
    a68c:	7a 90 83 ff 	cmp.b	#-125,	r10	;#0xff83
    a690:	31 24       	jz	$+100    	;abs 0xa6f4
    a692:	7c 40 83 ff 	mov.b	#-125,	r12	;#0xff83
    a696:	4c 9a       	cmp.b	r10,	r12	;
    a698:	13 28       	jnc	$+40     	;abs 0xa6c0
    a69a:	7a 90 80 ff 	cmp.b	#-128,	r10	;#0xff80
    a69e:	20 24       	jz	$+66     	;abs 0xa6e0
    a6a0:	7a 90 81 ff 	cmp.b	#-127,	r10	;#0xff81
    a6a4:	24 20       	jnz	$+74     	;abs 0xa6ee

0000a6a6 <.Loc.78.1>:
    case RegNLMaxPktLengthLsb:
      value = clamp(value, 7, 0xFF);
      break;
    case RegNLMaxPktLengthMsb:
      value = clamp(value, 0, 0x10);
    a6a6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    a6aa:	4d 43       	clr.b	r13		;
    a6ac:	4c 49       	mov.b	r9,	r12	;
    a6ae:	b0 12 ca a5 	call	#-23094	;#0xa5ca

0000a6b2 <.LVL22>:
    a6b2:	49 4c       	mov.b	r12,	r9	;

0000a6b4 <.LVL23>:
      break;
    a6b4:	1c 3c       	jmp	$+58     	;abs 0xa6ee

0000a6b6 <.L27>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    a6b6:	3c 40 37 b2 	mov	#-19913,r12	;#0xb237
    a6ba:	b0 12 a6 44 	call	#17574		;#0x44a6

0000a6be <.LVL25>:
    a6be:	e6 3f       	jmp	$-50     	;abs 0xa68c

0000a6c0 <.L21>:
  switch(addr) {
    a6c0:	7a 90 85 ff 	cmp.b	#-123,	r10	;#0xff85
    a6c4:	1f 24       	jz	$+64     	;abs 0xa704
    a6c6:	7a 90 85 ff 	cmp.b	#-123,	r10	;#0xff85
    a6ca:	11 28       	jnc	$+36     	;abs 0xa6ee
    a6cc:	7a 50 79 00 	add.b	#121,	r10	;#0x0079

0000a6d0 <.LVL26>:
    a6d0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a6d2:	4d 9a       	cmp.b	r10,	r13	;
    a6d4:	0c 28       	jnc	$+26     	;abs 0xa6ee

0000a6d6 <.Loc.88.1>:
    case RegNLPktNameMsb:
      value = clamp(value, 0, 0x3F);
      break;
    case RegNLPVNErrLvl:
    case RegNLPktLenghtLvl:
      value = clamp_err(value);
    a6d6:	4c 49       	mov.b	r9,	r12	;
    a6d8:	b0 12 f8 a5 	call	#-23048	;#0xa5f8

0000a6dc <.LVL27>:
    a6dc:	49 4c       	mov.b	r12,	r9	;

0000a6de <.LVL28>:
      break;
    a6de:	07 3c       	jmp	$+16     	;abs 0xa6ee

0000a6e0 <.L22>:
      value = clamp(value, 7, 0xFF);
    a6e0:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    a6e2:	7d 40 07 00 	mov.b	#7,	r13	;
    a6e6:	4c 49       	mov.b	r9,	r12	;
    a6e8:	b0 12 ca a5 	call	#-23094	;#0xa5ca

0000a6ec <.LVL30>:
    a6ec:	49 4c       	mov.b	r12,	r9	;

0000a6ee <.L19>:
    default:
      /* All other registers have ranges equal to their data type's */
      break;
  }
  return value;
}
    a6ee:	4c 49       	mov.b	r9,	r12	;
    a6f0:	19 17       	popm	#2,	r10	;16-bit words
    a6f2:	30 41       	ret			

0000a6f4 <.L20>:
      value = clamp(value, 0, 0x07);
    a6f4:	7e 40 07 00 	mov.b	#7,	r14	;
    a6f8:	4d 43       	clr.b	r13		;
    a6fa:	4c 49       	mov.b	r9,	r12	;
    a6fc:	b0 12 ca a5 	call	#-23094	;#0xa5ca

0000a700 <.LVL33>:
    a700:	49 4c       	mov.b	r12,	r9	;

0000a702 <.LVL34>:
      break;
    a702:	f5 3f       	jmp	$-20     	;abs 0xa6ee

0000a704 <.L24>:
      value = clamp(value, 0, 0x3F);
    a704:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    a708:	4d 43       	clr.b	r13		;
    a70a:	4c 49       	mov.b	r9,	r12	;
    a70c:	b0 12 ca a5 	call	#-23094	;#0xa5ca

0000a710 <.LVL36>:
    a710:	49 4c       	mov.b	r12,	r9	;

0000a712 <.LVL37>:
      break;
    a712:	ed 3f       	jmp	$-36     	;abs 0xa6ee

0000a714 <elyNLGetBuffer>:
    a714:	3c 40 82 b4 	mov	#-19326,r12	;#0xb482
  /* TODO remove dead code */
  /*elyUARTChangeMaxLengthS(len);*/
}

uint8_t * elyNLGetBuffer() {
  return chPoolAlloc(&main_mpool);
    a718:	b0 12 a8 49 	call	#18856		;#0x49a8

0000a71c <.LVL44>:
}
    a71c:	30 41       	ret			

0000a71e <elyNLFreeBuffer>:

void elyNLFreeBuffer(uint8_t * buffer) {
  chPoolFree(&main_mpool, buffer);
    a71e:	0d 4c       	mov	r12,	r13	;
    a720:	3c 40 82 b4 	mov	#-19326,r12	;#0xb482

0000a724 <.LVL46>:
    a724:	b0 12 dc 49 	call	#18908		;#0x49dc

0000a728 <.LVL47>:
}
    a728:	30 41       	ret			

0000a72a <elyNLFreeBufferI>:
  return chPoolAllocI(&main_mpool);
}

void elyNLFreeBufferI(uint8_t * buffer) {
  chDbgCheckClassI();
  chPoolFreeI(&main_mpool, buffer);
    a72a:	0d 4c       	mov	r12,	r13	;
    a72c:	3c 40 82 b4 	mov	#-19326,r12	;#0xb482

0000a730 <.LVL50>:
    a730:	b0 12 b8 49 	call	#18872		;#0x49b8

0000a734 <.LVL51>:
}
    a734:	30 41       	ret			

0000a736 <elyNLValidate>:
  /* Validation for Space Packet Protocol means checking the following:
   * Packet Version Number - 000
   * Packet Length - <= MaxPktLength */
  /* TODO - we need to check to make sure we've actually received the P-field
   * and timestamp if they're configured */
  if (buffer[0] & 0xE0) {
    a736:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    a73a:	00 00 
    a73c:	14 20       	jnz	$+42     	;abs 0xa766

0000a73e <.Loc.150.1>:
  
  /* TODO we should really lock around stuff like this, that accesses multiple
   * registers and expects them to be a coherent value */
  /* TODO this comparison is wrong, we need the *total* packet length */
  /* ENH nasty pointer math makes this faster/better/more atomic */
  if ( ((buffer[4] << 8) | (buffer[5])) > 
    a73e:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a742:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a746:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000a74a <.LVL53>:
    a74a:	0d dc       	bis	r12,	r13	;

0000a74c <.Loc.151.1>:
      ((bank0p[RegNLMaxPktLengthMsb] << 8) | (bank0p[RegNLMaxPktLengthLsb])) ) {
    a74c:	1e 42 84 b1 	mov	&0xb184,r14	;0xb184
    a750:	5c 4e 81 00 	mov.b	129(r14),r12	;0x00081
    a754:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a758:	5e 4e 80 00 	mov.b	128(r14),r14	;0x00080
    a75c:	0c de       	bis	r14,	r12	;

0000a75e <.Loc.150.1>:
  if ( ((buffer[4] << 8) | (buffer[5])) > 
    a75e:	0c 9d       	cmp	r13,	r12	;
    a760:	08 38       	jl	$+18     	;abs 0xa772

0000a762 <.Loc.156.1>:
    /* Raise Packet Length Mismatch error */
    elyErrorSignal(ErrNLPacketLengthMismatch);
    return false;
  }
  return true;
    a762:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a764 <.L38>:
}
    a764:	30 41       	ret			

0000a766 <.L40>:
    elyErrorSignal(ErrNLPVNMismatch);
    a766:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000a76a <.LVL55>:
    a76a:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a76e <.LVL56>:
    return false;
    a76e:	4c 43       	clr.b	r12		;
    a770:	f9 3f       	jmp	$-12     	;abs 0xa764

0000a772 <.L41>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    a772:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    a776:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a77a <.LVL57>:
    return false;
    a77a:	4c 43       	clr.b	r12		;
    a77c:	f3 3f       	jmp	$-24     	;abs 0xa764

0000a77e <elyNLGetDest>:
    a77e:	6e 4c       	mov.b	@r12,	r14	;
   * Else If (TC) UART
   * Else (TM) If (Source == Elysium AND APID != GroundAPID) UART
   * Else RF */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    a780:	0d 4e       	mov	r14,	r13	;

0000a782 <L0>:
    a782:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a786:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    a78a:	5c 4c 01 00 	mov.b	1(r12),	r12	;

0000a78e <.LVL59>:
    a78e:	0d dc       	bis	r12,	r13	;

0000a790 <.Loc.168.1>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    a790:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    a794:	5c 4f 51 00 	mov.b	81(r15),r12	;0x00051
    a798:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a79c:	5f 4f 50 00 	mov.b	80(r15),r15	;0x00050
    a7a0:	0c df       	bis	r15,	r12	;

0000a7a2 <.LVL61>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (tc) {
    a7a2:	3e b0 10 00 	bit	#16,	r14	;#0x0010
    a7a6:	06 24       	jz	$+14     	;abs 0xa7b4

0000a7a8 <.Loc.173.1>:
    if (apid == elysium_apid)
    a7a8:	0d 9c       	cmp	r12,	r13	;
    a7aa:	02 24       	jz	$+6      	;abs 0xa7b0

0000a7ac <.Loc.176.1>:
      return ELY_DEST_FW;
    else
      return ELY_DEST_UART;
    a7ac:	4c 43       	clr.b	r12		;

0000a7ae <.LVL62>:
    a7ae:	03 3c       	jmp	$+8      	;abs 0xa7b6

0000a7b0 <.L46>:
      return ELY_DEST_FW;
    a7b0:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000a7b2 <.LVL64>:
    a7b2:	01 3c       	jmp	$+4      	;abs 0xa7b6

0000a7b4 <.L44>:
  }
  else {
    /* We can't tell if this is coming from the Elysium without more context,
     * however because of where this is called in the main loop that's OK */
    return ELY_DEST_RF;
    a7b4:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a7b6 <.L43>:
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    a7b6:	30 41       	ret			

0000a7b8 <get_sh_len>:

/* TODO again, we really ought to lock this stuff */
size_t get_sh_len(void) {
  uint8_t options = bank0p[RegNLOptions];
    a7b8:	1c 42 84 b1 	mov	&0xb184,r12	;0xb184

0000a7bc <L0>:
    a7bc:	5c 4c 86 00 	mov.b	134(r12),r12	;0x00086

0000a7c0 <.Loc.191.1>:
  if (options & 0x02) { /* Timestamp */
    a7c0:	2c b3       	bit	#2,	r12	;r3 As==10
    a7c2:	05 24       	jz	$+12     	;abs 0xa7ce

0000a7c4 <.Loc.192.1>:
    if (options & 0x01) { /* P-field */
    a7c4:	1c b3       	bit	#1,	r12	;r3 As==01
    a7c6:	05 24       	jz	$+12     	;abs 0xa7d2

0000a7c8 <.Loc.194.1>:
      /* 5-byte Secondary Header + 6-byte Primary Header */
      return 5;
    a7c8:	7c 40 05 00 	mov.b	#5,	r12	;
    a7cc:	01 3c       	jmp	$+4      	;abs 0xa7d0

0000a7ce <.L49>:
      /* 4-byte Secondary Header + 6-byte Primary Header */
      return 4;
    }
  }
  
  return 0;
    a7ce:	4c 43       	clr.b	r12		;

0000a7d0 <.L47>:
}
    a7d0:	30 41       	ret			

0000a7d2 <.L50>:
      return 4;
    a7d2:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a7d4:	fd 3f       	jmp	$-4      	;abs 0xa7d0

0000a7d6 <elyNLSetDest>:
    a7d6:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11

0000a7da <L0>:

elysium_destinations_t elyNLSetDest(uint8_t * buffer) {
  uint16_t apid;
  if (buffer[0] & 0x08) { /* Secondary Header flag - Timestamp */
    a7da:	0b 24       	jz	$+24     	;abs 0xa7f2

0000a7dc <.Loc.208.1>:
    if (bank0p[RegNLOptions] & 0x01) { /* P-field - SH 5 bytes */
    a7dc:	1d 42 84 b1 	mov	&0xb184,r13	;0xb184
    a7e0:	dd b3 86 00 	bit.b	#1,	134(r13);r3 As==01, 0x0086
    a7e4:	03 24       	jz	$+8      	;abs 0xa7ec

0000a7e6 <.Loc.210.1>:
      /* PH 6 bytes, SH 5 bytes, EH 2 bytes */
      apid = ( ((buffer[13] << 8) & 0x07) | (buffer[14]) );
    a7e6:	5e 4c 0e 00 	mov.b	14(r12),r14	;0x0000e

0000a7ea <.LVL69>:
    a7ea:	05 3c       	jmp	$+12     	;abs 0xa7f6

0000a7ec <.L53>:
    }
    else { /* No P-field - SH 4 bytes */
      apid = ( ((buffer[12] << 8) & 0x07) | (buffer[13]) );
    a7ec:	5e 4c 0d 00 	mov.b	13(r12),r14	;0x0000d

0000a7f0 <.LVL71>:
    a7f0:	02 3c       	jmp	$+6      	;abs 0xa7f6

0000a7f2 <.L52>:
    }
  }
  else { /* No timestamp */
    /* PH 6 bytes, EH 2 bytes */
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
    a7f2:	5e 4c 09 00 	mov.b	9(r12),	r14	;

0000a7f6 <.L54>:
  }
  
  /* Set APID */
  buffer[0] = (apid >> 8);
    a7f6:	4b 43       	clr.b	r11		;
    a7f8:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

0000a7fc <.Loc.223.1>:
  buffer[1] = (apid & 0xFF);
    a7fc:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000a800 <.Loc.225.1>:
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
    a800:	1f 42 84 b1 	mov	&0xb184,r15	;0xb184
    a804:	5d 4f 83 00 	mov.b	131(r15),r13	;0x00083
    a808:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a80c:	5f 4f 82 00 	mov.b	130(r15),r15	;0x00082
    a810:	0d df       	bis	r15,	r13	;

0000a812 <.Loc.228.1>:
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (apid == ground_apid) {
    a812:	0e 9d       	cmp	r13,	r14	;
    a814:	06 24       	jz	$+14     	;abs 0xa822

0000a816 <.Loc.233.1>:
    return ELY_DEST_RF;
  }
  else {
    /* Remember to set it to TC mode */
    buffer[0] |= 0x10;
    a816:	7b d0 10 00 	bis.b	#16,	r11	;#0x0010
    a81a:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

0000a81e <.Loc.234.1>:
    return ELY_DEST_UART;
    a81e:	4c 43       	clr.b	r12		;

0000a820 <.L55>:
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    a820:	30 41       	ret			

0000a822 <.L56>:
    return ELY_DEST_RF;
    a822:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a824 <.LVL77>:
    a824:	fd 3f       	jmp	$-4      	;abs 0xa820

0000a826 <elyNLGetLength>:
    a826:	5d 4c 04 00 	mov.b	4(r12),	r13	;

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    a82a:	47 18 0d 5d 	.word	0x1847, 0xffff;	????

0000a82c <L0>:
    a82c:	0d 5d       	rla	r13		;
    a82e:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000a832 <.LVL79>:
    a832:	0c dd       	bis	r13,	r12	;

0000a834 <.Loc.243.1>:
}
    a834:	3c 50 07 00 	add	#7,	r12	;
    a838:	30 41       	ret			

0000a83a <elyNLExtract>:

size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - get_sh_len() + 1;
}

uint8_t * elyNLExtract(uint8_t * buffer) {
    a83a:	0a 15       	pushm	#1,	r10	;16-bit words

0000a83c <.LCFI4>:
    a83c:	0a 4c       	mov	r12,	r10	;

0000a83e <.Loc.252.1>:
  /* TODO better constants */
  /* 6-byte Primary Header */
  return buffer + get_sh_len() + 6;
    a83e:	b0 12 b8 a7 	call	#-22600	;#0xa7b8

0000a842 <.LVL84>:
    a842:	3c 50 06 00 	add	#6,	r12	;

0000a846 <.Loc.253.1>:
}
    a846:	0c 5a       	add	r10,	r12	;
    a848:	0a 17       	popm	#1,	r10	;16-bit words
    a84a:	30 41       	ret			

0000a84c <elyNLPack>:

uint8_t * elyNLPack(uint8_t * buffer) {
    a84c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a84e <.LCFI5>:
    a84e:	0a 4c       	mov	r12,	r10	;

0000a850 <.Loc.257.1>:
  /* 6-byte Primary Header */
  uint8_t * result = buffer - get_sh_len() - 6;
    a850:	b0 12 b8 a7 	call	#-22600	;#0xa7b8

0000a854 <.LVL86>:
    a854:	3d 40 fa ff 	mov	#-6,	r13	;#0xfffa
    a858:	0d 8c       	sub	r12,	r13	;
    a85a:	0d 5a       	add	r10,	r13	;

0000a85c <.Loc.258.1>:
  uint16_t length = (buffer[1] + 4 + get_sh_len() - 1);
    a85c:	5a 4a 01 00 	mov.b	1(r10),	r10	;

0000a860 <.LVL88>:
    a860:	0c 5a       	add	r10,	r12	;
    a862:	3c 50 03 00 	add	#3,	r12	;

0000a866 <.LVL89>:
  result[4] = (length >> 8);
    a866:	0e 4c       	mov	r12,	r14	;
    a868:	5e 0f       	rrum	#4,	r14	;
    a86a:	5e 0f       	rrum	#4,	r14	;
    a86c:	cd 4e 04 00 	mov.b	r14,	4(r13)	;

0000a870 <.Loc.260.1>:
  result[5] = (length & 0xFF);
    a870:	cd 4c 05 00 	mov.b	r12,	5(r13)	;

0000a874 <.Loc.262.1>:
  
  result[2] = (packets_sent >> 8) | 0xC0;
    a874:	1c 42 28 c0 	mov	&0xc028,r12	;0xc028

0000a878 <.LVL90>:
    a878:	0e 4c       	mov	r12,	r14	;
    a87a:	5e 0f       	rrum	#4,	r14	;
    a87c:	5e 0f       	rrum	#4,	r14	;
    a87e:	7e d0 c0 ff 	bis.b	#-64,	r14	;#0xffc0
    a882:	cd 4e 02 00 	mov.b	r14,	2(r13)	;

0000a886 <.Loc.263.1>:
  result[3] = (packets_sent & 0xFF);
    a886:	cd 4c 03 00 	mov.b	r12,	3(r13)	;

0000a88a <.Loc.264.1>:
  packets_sent = (packets_sent + 1) & 0x3FFF;
    a88a:	1c 53       	inc	r12		;
    a88c:	3c f0 ff 3f 	and	#16383,	r12	;#0x3fff
    a890:	82 4c 28 c0 	mov	r12,	&0xc028	;

0000a894 <.Loc.268.1>:
  /* TODO insert timestamps here too if required */
  
  return result;
}
    a894:	0c 4d       	mov	r13,	r12	;
    a896:	0a 17       	popm	#1,	r10	;16-bit words
    a898:	30 41       	ret			

0000a89a <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    a89a:	ff 3f       	jmp	$+0      	;abs 0xa89a

0000a89c <Vector2>:
    a89c:	ff 3f       	jmp	$+0      	;abs 0xa89c

0000a89e <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    a89e:	ff 3f       	jmp	$+0      	;abs 0xa89e

0000a8a0 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    a8a0:	ff 3f       	jmp	$+0      	;abs 0xa8a0

0000a8a2 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    a8a2:	ff 3f       	jmp	$+0      	;abs 0xa8a2

0000a8a4 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    a8a4:	ff 3f       	jmp	$+0      	;abs 0xa8a4

0000a8a6 <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    a8a6:	ff 3f       	jmp	$+0      	;abs 0xa8a6

0000a8a8 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    a8a8:	ff 3f       	jmp	$+0      	;abs 0xa8a8

0000a8aa <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    a8aa:	ff 3f       	jmp	$+0      	;abs 0xa8aa

0000a8ac <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    a8ac:	ff 3f       	jmp	$+0      	;abs 0xa8ac

0000a8ae <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    a8ae:	ff 3f       	jmp	$+0      	;abs 0xa8ae

0000a8b0 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    a8b0:	ff 3f       	jmp	$+0      	;abs 0xa8b0

0000a8b2 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    a8b2:	ff 3f       	jmp	$+0      	;abs 0xa8b2

0000a8b4 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    a8b4:	ff 3f       	jmp	$+0      	;abs 0xa8b4

0000a8b6 <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    a8b6:	ff 3f       	jmp	$+0      	;abs 0xa8b6

0000a8b8 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    a8b8:	ff 3f       	jmp	$+0      	;abs 0xa8b8

0000a8ba <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    a8ba:	ff 3f       	jmp	$+0      	;abs 0xa8ba

0000a8bc <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    a8bc:	ff 3f       	jmp	$+0      	;abs 0xa8bc

0000a8be <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    a8be:	ff 3f       	jmp	$+0      	;abs 0xa8be

0000a8c0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    a8c0:	ff 3f       	jmp	$+0      	;abs 0xa8c0

0000a8c2 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    a8c2:	ff 3f       	jmp	$+0      	;abs 0xa8c2

0000a8c4 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    a8c4:	ff 3f       	jmp	$+0      	;abs 0xa8c4

0000a8c6 <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    a8c6:	ff 3f       	jmp	$+0      	;abs 0xa8c6

0000a8c8 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    a8c8:	ff 3f       	jmp	$+0      	;abs 0xa8c8

0000a8ca <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    a8ca:	ff 3f       	jmp	$+0      	;abs 0xa8ca

0000a8cc <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    a8cc:	ff 3f       	jmp	$+0      	;abs 0xa8cc

0000a8ce <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    a8ce:	ff 3f       	jmp	$+0      	;abs 0xa8ce

0000a8d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    a8d0:	ff 3f       	jmp	$+0      	;abs 0xa8d0

0000a8d2 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    a8d2:	ff 3f       	jmp	$+0      	;abs 0xa8d2

0000a8d4 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    a8d4:	ff 3f       	jmp	$+0      	;abs 0xa8d4

0000a8d6 <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    a8d6:	ff 3f       	jmp	$+0      	;abs 0xa8d6

0000a8d8 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    a8d8:	ff 3f       	jmp	$+0      	;abs 0xa8d8

0000a8da <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    a8da:	ff 3f       	jmp	$+0      	;abs 0xa8da

0000a8dc <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    a8dc:	ff 3f       	jmp	$+0      	;abs 0xa8dc

0000a8de <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    a8de:	ff 3f       	jmp	$+0      	;abs 0xa8de

0000a8e0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    a8e0:	ff 3f       	jmp	$+0      	;abs 0xa8e0

0000a8e2 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    a8e2:	ff 3f       	jmp	$+0      	;abs 0xa8e2

0000a8e4 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    a8e4:	ff 3f       	jmp	$+0      	;abs 0xa8e4

0000a8e6 <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    a8e6:	ff 3f       	jmp	$+0      	;abs 0xa8e6

0000a8e8 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    a8e8:	ff 3f       	jmp	$+0      	;abs 0xa8e8

0000a8ea <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    a8ea:	ff 3f       	jmp	$+0      	;abs 0xa8ea

0000a8ec <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    a8ec:	ff 3f       	jmp	$+0      	;abs 0xa8ec

0000a8ee <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    a8ee:	ff 3f       	jmp	$+0      	;abs 0xa8ee

0000a8f0 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    a8f0:	ff 3f       	jmp	$+0      	;abs 0xa8f0

0000a8f2 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    a8f2:	ff 3f       	jmp	$+0      	;abs 0xa8f2

0000a8f4 <elyErrorSignal>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    a8f4:	0d 4c       	mov	r12,	r13	;

0000a8f6 <L0>:
/* Errors */
static uint16_t PERSIST err_log_lvl;
static uint16_t PERSIST err_rpt_lvl;
static uint16_t PERSIST signalled_errors;
static inline eventmask_t mask_from_error(uint8_t error) {
  return (1 << (error & 0x3F));
    a8f6:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    a8fa:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a8fc <.LVL2>:
    a8fc:	b0 12 4e ac 	call	#-21426	;#0xac4e

0000a900 <.LBE18>:
}

void elyErrorSignal(uint8_t error) {
  signalled_errors |= mask_from_error(error);
    a900:	82 dc 38 e0 	bis	r12,	&0xe038	;

0000a904 <.Loc.40.1>:
}
    a904:	30 41       	ret			

0000a906 <clamp>:
msg_t elyRFPost(uint8_t * buffer) {
  return elyUARTPost(buffer);
}

/* DLL */
static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a906:	1a 15       	pushm	#2,	r10	;16-bit words

0000a908 <.LCFI0>:
    a908:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a90c:	4a 4d       	mov.b	r13,	r10	;
    a90e:	49 4e       	mov.b	r14,	r9	;

0000a910 <.Loc.131.1>:
  if (value < min) {
    a910:	4c 9a       	cmp.b	r10,	r12	;
    a912:	04 28       	jnc	$+10     	;abs 0xa91c

0000a914 <.Loc.135.1>:
    value = min;
    elyErrorSignal(ErrRegClip);
  }
  else if (value > max) {
    a914:	49 9c       	cmp.b	r12,	r9	;
    a916:	08 28       	jnc	$+18     	;abs 0xa928

0000a918 <.L5>:
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    a918:	19 17       	popm	#2,	r10	;16-bit words
    a91a:	30 41       	ret			

0000a91c <.L6>:
    elyErrorSignal(ErrRegClip);
    a91c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a920:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a924 <.LVL7>:
    value = min;
    a924:	0c 4a       	mov	r10,	r12	;
    a926:	f8 3f       	jmp	$-14     	;abs 0xa918

0000a928 <.L7>:
    elyErrorSignal(ErrRegClip);
    a928:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a92c:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a930 <.LVL9>:
    value = max;
    a930:	0c 49       	mov	r9,	r12	;
    a932:	f2 3f       	jmp	$-26     	;abs 0xa918

0000a934 <clamp_err>:
    a934:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a938 <L0>:

static uint8_t clamp_err(uint8_t value) {
  if ((value & 0x10) && value != 0x10) {
    a938:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    a93c:	0a 24       	jz	$+22     	;abs 0xa952

0000a93e <.Loc.143.1>:
    a93e:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a942:	07 24       	jz	$+16     	;abs 0xa952

0000a944 <.Loc.144.1>:
    elyErrorSignal(ErrRegClip);
    a944:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a948 <.LVL11>:
    a948:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a94c <.LVL12>:
    return 0x10;
    a94c:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000a950 <.L10>:
  if (value & 0xD0) {
    elyErrorSignal(ErrRegClip);
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}
    a950:	30 41       	ret			

0000a952 <.L9>:
  if ((value & 0x08) && value != 0x08) {
    a952:	3c b2       	bit	#8,	r12	;r2 As==11
    a954:	08 24       	jz	$+18     	;abs 0xa966

0000a956 <.Loc.147.1>:
    a956:	3c 92       	cmp	#8,	r12	;r2 As==11
    a958:	06 24       	jz	$+14     	;abs 0xa966

0000a95a <.Loc.148.1>:
    elyErrorSignal(ErrRegClip);
    a95a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a95e:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a962 <.LVL13>:
    return 0x08;
    a962:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a964:	f5 3f       	jmp	$-20     	;abs 0xa950

0000a966 <.L11>:
  if ((value & 0x04) && value != 0x04) {
    a966:	2c b2       	bit	#4,	r12	;r2 As==10
    a968:	08 24       	jz	$+18     	;abs 0xa97a

0000a96a <.Loc.151.1>:
    a96a:	2c 92       	cmp	#4,	r12	;r2 As==10
    a96c:	06 24       	jz	$+14     	;abs 0xa97a

0000a96e <.Loc.152.1>:
    elyErrorSignal(ErrRegClip);
    a96e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a972:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a976 <.LVL14>:
    return 0x04;
    a976:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a978:	eb 3f       	jmp	$-40     	;abs 0xa950

0000a97a <.L12>:
  if ((value & 0x02) && value != 0x02) {
    a97a:	2c b3       	bit	#2,	r12	;r3 As==10
    a97c:	08 24       	jz	$+18     	;abs 0xa98e

0000a97e <.Loc.155.1>:
    a97e:	2c 93       	cmp	#2,	r12	;r3 As==10
    a980:	06 24       	jz	$+14     	;abs 0xa98e

0000a982 <.Loc.156.1>:
    elyErrorSignal(ErrRegClip);
    a982:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a986:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a98a <.LVL15>:
    return 0x02;
    a98a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a98c:	e1 3f       	jmp	$-60     	;abs 0xa950

0000a98e <.L13>:
  if ((value & 0x01) && value != 0x01) {
    a98e:	1c b3       	bit	#1,	r12	;r3 As==01
    a990:	02 24       	jz	$+6      	;abs 0xa996

0000a992 <.Loc.159.1>:
    a992:	1c 93       	cmp	#1,	r12	;r3 As==01
    a994:	09 20       	jnz	$+20     	;abs 0xa9a8

0000a996 <.L14>:
  if (value & 0xD0) {
    a996:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a99a:	da 27       	jz	$-74     	;abs 0xa950

0000a99c <.Loc.164.1>:
    elyErrorSignal(ErrRegClip);
    a99c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a9a0:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a9a4 <.LVL16>:
    return 0x00;
    a9a4:	4c 43       	clr.b	r12		;
    a9a6:	d4 3f       	jmp	$-86     	;abs 0xa950

0000a9a8 <.L15>:
    elyErrorSignal(ErrRegClip);
    a9a8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a9ac:	b0 12 f4 a8 	call	#-22284	;#0xa8f4

0000a9b0 <.LVL17>:
    return 0x01;
    a9b0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a9b2:	ce 3f       	jmp	$-98     	;abs 0xa950

0000a9b4 <elyErrorSetLogLvlS>:
    a9b4:	30 41       	ret			

0000a9b6 <elyErrorSetRptLvlS>:
}
    a9b6:	30 41       	ret			

0000a9b8 <elyChanSubscribe>:
void elyChanSubscribe(uint8_t * buffer, uint8_t length, uint32_t interval) {
    a9b8:	2a 15       	pushm	#3,	r10	;16-bit words

0000a9ba <.LCFI1>:
    a9ba:	08 4c       	mov	r12,	r8	;
    a9bc:	49 4d       	mov.b	r13,	r9	;

0000a9be <L0>:
  for (int i = 0; i < length; i++) {
    a9be:	4a 43       	clr.b	r10		;
    a9c0:	0f 3c       	jmp	$+32     	;abs 0xa9e0

0000a9c2 <.L20>:
    subscribed_channels |= mask_from_chan(buffer[i]);
    a9c2:	0c 48       	mov	r8,	r12	;
    a9c4:	0c 5a       	add	r10,	r12	;

0000a9c6 <.LBB21>:
  return (1UL << (chan & 0x3F));
    a9c6:	6e 4c       	mov.b	@r12,	r14	;
    a9c8:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    a9cc:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a9ce <.LVL24>:
    a9ce:	4d 43       	clr.b	r13		;
    a9d0:	0f 43       	clr	r15		;
    a9d2:	b0 12 98 ac 	call	#-21352	;#0xac98

0000a9d6 <.LBE21>:
    subscribed_channels |= mask_from_chan(buffer[i]);
    a9d6:	82 dc 34 e0 	bis	r12,	&0xe034	;
    a9da:	82 dd 36 e0 	bis	r13,	&0xe036	;

0000a9de <.Loc.65.1>:
  for (int i = 0; i < length; i++) {
    a9de:	1a 53       	inc	r10		;

0000a9e0 <.L19>:
    a9e0:	0a 99       	cmp	r9,	r10	;
    a9e2:	ef 3b       	jl	$-32     	;abs 0xa9c2

0000a9e4 <.LBE20>:
}
    a9e4:	28 17       	popm	#3,	r10	;16-bit words
    a9e6:	30 41       	ret			

0000a9e8 <elyChanUnsubscribe>:
void elyChanUnsubscribe(uint8_t * buffer, uint8_t length) {
    a9e8:	2a 15       	pushm	#3,	r10	;16-bit words

0000a9ea <L0>:
    a9ea:	08 4c       	mov	r12,	r8	;
    a9ec:	49 4d       	mov.b	r13,	r9	;

0000a9ee <.LBB23>:
  for (int i = 0; i < length; i++) {
    a9ee:	4a 43       	clr.b	r10		;
    a9f0:	0f 3c       	jmp	$+32     	;abs 0xaa10

0000a9f2 <.L23>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
    a9f2:	0c 48       	mov	r8,	r12	;
    a9f4:	0c 5a       	add	r10,	r12	;

0000a9f6 <.LBB24>:
  return (1UL << (chan & 0x3F));
    a9f6:	6e 4c       	mov.b	@r12,	r14	;
    a9f8:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    a9fc:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a9fe <.LVL31>:
    a9fe:	4d 43       	clr.b	r13		;
    aa00:	0f 43       	clr	r15		;
    aa02:	b0 12 98 ac 	call	#-21352	;#0xac98

0000aa06 <.LBE24>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
    aa06:	82 cc 34 e0 	bic	r12,	&0xe034	;
    aa0a:	82 cd 36 e0 	bic	r13,	&0xe036	;

0000aa0e <.Loc.71.1>:
  for (int i = 0; i < length; i++) {
    aa0e:	1a 53       	inc	r10		;

0000aa10 <.L22>:
    aa10:	0a 99       	cmp	r9,	r10	;
    aa12:	ef 3b       	jl	$-32     	;abs 0xa9f2

0000aa14 <.LBE23>:
}
    aa14:	28 17       	popm	#3,	r10	;16-bit words
    aa16:	30 41       	ret			

0000aa18 <elyChanLog>:
void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
    aa18:	2a 15       	pushm	#3,	r10	;16-bit words

0000aa1a <L0>:
    aa1a:	08 4c       	mov	r12,	r8	;
    aa1c:	49 4d       	mov.b	r13,	r9	;

0000aa1e <.LBB26>:
  for (int i = 0; i < length; i++) {
    aa1e:	4a 43       	clr.b	r10		;
    aa20:	0f 3c       	jmp	$+32     	;abs 0xaa40

0000aa22 <.L26>:
    logged_channels |= mask_from_chan(buffer[i]);
    aa22:	0c 48       	mov	r8,	r12	;
    aa24:	0c 5a       	add	r10,	r12	;

0000aa26 <.LBB27>:
  return (1UL << (chan & 0x3F));
    aa26:	6e 4c       	mov.b	@r12,	r14	;
    aa28:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    aa2c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000aa2e <.LVL38>:
    aa2e:	4d 43       	clr.b	r13		;
    aa30:	0f 43       	clr	r15		;
    aa32:	b0 12 98 ac 	call	#-21352	;#0xac98

0000aa36 <.LBE27>:
    logged_channels |= mask_from_chan(buffer[i]);
    aa36:	82 dc 30 e0 	bis	r12,	&0xe030	;
    aa3a:	82 dd 32 e0 	bis	r13,	&0xe032	;

0000aa3e <.Loc.78.1>:
  for (int i = 0; i < length; i++) {
    aa3e:	1a 53       	inc	r10		;

0000aa40 <.L25>:
    aa40:	0a 99       	cmp	r9,	r10	;
    aa42:	ef 3b       	jl	$-32     	;abs 0xaa22

0000aa44 <.LBE26>:
}
    aa44:	28 17       	popm	#3,	r10	;16-bit words
    aa46:	30 41       	ret			

0000aa48 <elyChanUnlog>:
void elyChanUnlog(uint8_t * buffer, uint8_t length) {
    aa48:	2a 15       	pushm	#3,	r10	;16-bit words

0000aa4a <L0>:
    aa4a:	08 4c       	mov	r12,	r8	;
    aa4c:	49 4d       	mov.b	r13,	r9	;

0000aa4e <.LBB29>:
  for (int i = 0; i < length; i++) {
    aa4e:	4a 43       	clr.b	r10		;
    aa50:	0f 3c       	jmp	$+32     	;abs 0xaa70

0000aa52 <.L29>:
    logged_channels &= ~mask_from_chan(buffer[i]);
    aa52:	0c 48       	mov	r8,	r12	;
    aa54:	0c 5a       	add	r10,	r12	;

0000aa56 <.LBB30>:
  return (1UL << (chan & 0x3F));
    aa56:	6e 4c       	mov.b	@r12,	r14	;
    aa58:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    aa5c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000aa5e <.LVL45>:
    aa5e:	4d 43       	clr.b	r13		;
    aa60:	0f 43       	clr	r15		;
    aa62:	b0 12 98 ac 	call	#-21352	;#0xac98

0000aa66 <.LBE30>:
    logged_channels &= ~mask_from_chan(buffer[i]);
    aa66:	82 cc 30 e0 	bic	r12,	&0xe030	;
    aa6a:	82 cd 32 e0 	bic	r13,	&0xe032	;

0000aa6e <.Loc.84.1>:
  for (int i = 0; i < length; i++) {
    aa6e:	1a 53       	inc	r10		;

0000aa70 <.L28>:
    aa70:	0a 99       	cmp	r9,	r10	;
    aa72:	ef 3b       	jl	$-32     	;abs 0xaa52

0000aa74 <.LBE29>:
}
    aa74:	28 17       	popm	#3,	r10	;16-bit words
    aa76:	30 41       	ret			

0000aa78 <elyChanGetValue>:
  buffer[1] = 0;
    aa78:	cc 43       	mov.b	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

0000aa7a <L0>:
    aa7a:	01 00       	mova	@r0,	r1	;

0000aa7c <.Loc.92.1>:
}
    aa7c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000aa7e <.LVL49>:
    aa7e:	30 41       	ret			

0000aa80 <elyChanReset>:
  logged_channels = 0;
    aa80:	82 43 30 e0 	mov	#0,	&0xe030	;r3 As==00
    aa84:	82 43 32 e0 	mov	#0,	&0xe032	;r3 As==00

0000aa88 <.Loc.96.1>:
  subscribed_channels = 0;
    aa88:	82 43 34 e0 	mov	#0,	&0xe034	;r3 As==00
    aa8c:	82 43 36 e0 	mov	#0,	&0xe036	;r3 As==00

0000aa90 <.Loc.97.1>:
  chan_resets++;
    aa90:	92 53 2e e0 	inc	&0xe02e		;

0000aa94 <.Loc.98.1>:
}
    aa94:	30 41       	ret			

0000aa96 <elyTelemPostBufferS>:
  cb(buffer);
    aa96:	8e 12       	call	r14		;

0000aa98 <.LVL51>:
}
    aa98:	30 41       	ret			

0000aa9a <elyTelemUpdateConfigS>:
}
    aa9a:	30 41       	ret			

0000aa9c <elyRFCfgMarkDirty>:
  return (1 << (event & 0x3F));
    aa9c:	0d 4c       	mov	r12,	r13	;
    aa9e:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    aaa2:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000aaa4 <.LVL54>:
    aaa4:	b0 12 4e ac 	call	#-21426	;#0xac4e
    aaa8:	0e 4c       	mov	r12,	r14	;
    aaaa:	0f 4c       	mov	r12,	r15	;
    aaac:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000aab0 <.LBE32>:
  cfg_dirt |= mask_from_event(event);
    aab0:	82 dc 2a e0 	bis	r12,	&0xe02a	;
    aab4:	82 df 2c e0 	bis	r15,	&0xe02c	;

0000aab8 <.Loc.119.1>:
}
    aab8:	30 41       	ret			

0000aaba <elyRFPostI>:
  return elyUARTPostI(buffer);
    aaba:	b0 12 2e 60 	call	#24622		;#0x602e

0000aabe <.LVL57>:
}
    aabe:	30 41       	ret			

0000aac0 <elyRFPost>:
  return elyUARTPost(buffer);
    aac0:	b0 12 4e 60 	call	#24654		;#0x604e

0000aac4 <.LVL59>:
}
    aac4:	30 41       	ret			

0000aac6 <elyDLLClampReg>:

uint8_t elyDLLClampReg(uint8_t addr, uint8_t value) {
    aac6:	1a 15       	pushm	#2,	r10	;16-bit words

0000aac8 <.LCFI5>:
    aac8:	4a 4c       	mov.b	r12,	r10	;
    aaca:	49 4d       	mov.b	r13,	r9	;

0000aacc <.Loc.171.1>:
  chDbgAssert(addr >= 0xC0 && addr < RegDLLMAX, "invalid address");
    aacc:	4c 4a       	mov.b	r10,	r12	;

0000aace <.LVL61>:
    aace:	7c 50 40 00 	add.b	#64,	r12	;#0x0040
    aad2:	7d 40 14 00 	mov.b	#20,	r13	;#0x0014

0000aad6 <.LVL62>:
    aad6:	4d 9c       	cmp.b	r12,	r13	;
    aad8:	1b 28       	jnc	$+56     	;abs 0xab10

0000aada <.L38>:
  switch (addr) {
    aada:	7a 90 c3 ff 	cmp.b	#-61,	r10	;#0xffc3
    aade:	4a 24       	jz	$+150    	;abs 0xab74
    aae0:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    aae4:	4c 9a       	cmp.b	r10,	r12	;
    aae6:	19 28       	jnc	$+52     	;abs 0xab1a
    aae8:	7a 90 c1 ff 	cmp.b	#-63,	r10	;#0xffc1
    aaec:	26 24       	jz	$+78     	;abs 0xab3a
    aaee:	7d 40 c1 ff 	mov.b	#-63,	r13	;#0xffc1
    aaf2:	4d 9a       	cmp.b	r10,	r13	;
    aaf4:	2a 28       	jnc	$+86     	;abs 0xab4a
    aaf6:	7a 90 c0 ff 	cmp.b	#-64,	r10	;#0xffc0
    aafa:	07 20       	jnz	$+16     	;abs 0xab0a

0000aafc <.Loc.174.1>:
    case RegDLLTFLengthLSB:
      value = clamp(value, 7, 0xFF);
    aafc:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    aafe:	7d 40 07 00 	mov.b	#7,	r13	;
    ab02:	4c 49       	mov.b	r9,	r12	;
    ab04:	b0 12 06 a9 	call	#-22266	;#0xa906

0000ab08 <.LVL63>:
    ab08:	49 4c       	mov.b	r12,	r9	;

0000ab0a <.L39>:
    default:
      /* All other registers have ranges equal to their data types */
      break;
  }
  return value;
}
    ab0a:	4c 49       	mov.b	r9,	r12	;
    ab0c:	19 17       	popm	#2,	r10	;16-bit words
    ab0e:	30 41       	ret			

0000ab10 <.L49>:
  chDbgAssert(addr >= 0xC0 && addr < RegDLLMAX, "invalid address");
    ab10:	3c 40 45 b2 	mov	#-19899,r12	;#0xb245
    ab14:	b0 12 a6 44 	call	#17574		;#0x44a6

0000ab18 <.LVL66>:
    ab18:	e0 3f       	jmp	$-62     	;abs 0xaada

0000ab1a <.L41>:
  switch (addr) {
    ab1a:	7a 90 c7 ff 	cmp.b	#-57,	r10	;#0xffc7
    ab1e:	33 24       	jz	$+104    	;abs 0xab86
    ab20:	7a 90 c7 ff 	cmp.b	#-57,	r10	;#0xffc7
    ab24:	f2 2b       	jnc	$-26     	;abs 0xab0a
    ab26:	7a 50 35 00 	add.b	#53,	r10	;#0x0035
    ab2a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    ab2c:	4c 9a       	cmp.b	r10,	r12	;
    ab2e:	ed 2b       	jnc	$-36     	;abs 0xab0a

0000ab30 <.Loc.205.1>:
      value = clamp_err(value);
    ab30:	4c 49       	mov.b	r9,	r12	;
    ab32:	b0 12 34 a9 	call	#-22220	;#0xa934

0000ab36 <.LVL67>:
    ab36:	49 4c       	mov.b	r12,	r9	;

0000ab38 <.LVL68>:
      break;
    ab38:	e8 3f       	jmp	$-46     	;abs 0xab0a

0000ab3a <.L42>:
      value = clamp(value, 0, 0x40);
    ab3a:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    ab3e:	4d 43       	clr.b	r13		;
    ab40:	4c 49       	mov.b	r9,	r12	;
    ab42:	b0 12 06 a9 	call	#-22266	;#0xa906

0000ab46 <.LVL70>:
    ab46:	49 4c       	mov.b	r12,	r9	;

0000ab48 <.LVL71>:
      break;
    ab48:	e0 3f       	jmp	$-62     	;abs 0xab0a

0000ab4a <.L43>:
      if ((value & 0x38) == 0x38) {
    ab4a:	4c 49       	mov.b	r9,	r12	;
    ab4c:	7c f0 38 00 	and.b	#56,	r12	;#0x0038
    ab50:	7c 90 38 00 	cmp.b	#56,	r12	;#0x0038
    ab54:	0c 24       	jz	$+26     	;abs 0xab6e

0000ab56 <.L47>:
      if ((value & 0x07) > 5) {
    ab56:	0c 49       	mov	r9,	r12	;
    ab58:	7c f0 07 00 	and.b	#7,	r12	;
    ab5c:	7d 40 05 00 	mov.b	#5,	r13	;
    ab60:	0d 9c       	cmp	r12,	r13	;
    ab62:	d3 37       	jge	$-88     	;abs 0xab0a

0000ab64 <.Loc.184.1>:
        value &= ~BIT1;
    ab64:	69 c3       	bic.b	#2,	r9	;r3 As==10

0000ab66 <.Loc.185.1>:
        value |= BIT0;
    ab66:	59 d3       	bis.b	#1,	r9	;r3 As==01

0000ab68 <.LVL75>:
    ab68:	39 f0 ff 00 	and	#255,	r9	;#0x00ff

0000ab6c <.LVL76>:
    ab6c:	ce 3f       	jmp	$-98     	;abs 0xab0a

0000ab6e <.L50>:
        value &= ~BIT3;
    ab6e:	79 f0 f7 00 	and.b	#247,	r9	;#0x00f7

0000ab72 <.LVL78>:
    ab72:	f1 3f       	jmp	$-28     	;abs 0xab56

0000ab74 <.L40>:
      if ((value & 0x03) == 0x03) {
    ab74:	4c 49       	mov.b	r9,	r12	;
    ab76:	7c f0 03 00 	and.b	#3,	r12	;
    ab7a:	7c 90 03 00 	cmp.b	#3,	r12	;
    ab7e:	c5 23       	jnz	$-116    	;abs 0xab0a

0000ab80 <.Loc.190.1>:
        value &= ~BIT0;
    ab80:	79 f0 fe 00 	and.b	#254,	r9	;#0x00fe

0000ab84 <.LVL80>:
    ab84:	c2 3f       	jmp	$-122    	;abs 0xab0a

0000ab86 <.L45>:
      value &= ~BIT0;
    ab86:	79 f0 fe 00 	and.b	#254,	r9	;#0x00fe

0000ab8a <.LVL82>:
      break;
    ab8a:	bf 3f       	jmp	$-128    	;abs 0xab0a

0000ab8c <main>:
    ab8c:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    ab90:	5c 01 

0000ab92 <.Loc.239.1>:
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;

  halInit();
    ab92:	b0 12 e0 4a 	call	#19168		;#0x4ae0

0000ab96 <.LVL83>:
  chSysInit();
    ab96:	b0 12 32 44 	call	#17458		;#0x4432

0000ab9a <L0>:
    ab9a:	ff 3f       	jmp	$+0      	;abs 0xab9a

0000ab9c <udivmodsi4>:
    ab9c:	5a 15       	pushm	#6,	r10	;16-bit words

0000ab9e <L0>:
    ab9e:	0a 4c       	mov	r12,	r10	;
    aba0:	0b 4d       	mov	r13,	r11	;

0000aba2 <.LVL1>:
    aba2:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000aba6 <.Loc.35.1>:
    aba6:	58 43       	mov.b	#1,	r8	;r3 As==01
    aba8:	49 43       	clr.b	r9		;

0000abaa <.Loc.38.1>:
    abaa:	07 4b       	mov	r11,	r7	;

0000abac <.L2>:
    abac:	0f 9b       	cmp	r11,	r15	;
    abae:	11 28       	jnc	$+36     	;abs 0xabd2
    abb0:	07 9f       	cmp	r15,	r7	;
    abb2:	02 20       	jnz	$+6      	;abs 0xabb8
    abb4:	0e 9a       	cmp	r10,	r14	;
    abb6:	0d 28       	jnc	$+28     	;abs 0xabd2

0000abb8 <.L20>:
    abb8:	4c 43       	clr.b	r12		;

0000abba <.LVL3>:
    abba:	0d 4c       	mov	r12,	r13	;

0000abbc <.L5>:
    abbc:	07 48       	mov	r8,	r7	;
    abbe:	07 d9       	bis	r9,	r7	;
    abc0:	07 93       	cmp	#0,	r7	;r3 As==00
    abc2:	19 20       	jnz	$+52     	;abs 0xabf6

0000abc4 <.L6>:
    abc4:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    abc8:	02 24       	jz	$+6      	;abs 0xabce
    abca:	0c 4a       	mov	r10,	r12	;
    abcc:	0d 4b       	mov	r11,	r13	;

0000abce <.L1>:
    abce:	55 17       	popm	#6,	r10	;16-bit words
    abd0:	30 41       	ret			

0000abd2 <.L3>:
    abd2:	3d 53       	add	#-1,	r13	;r3 As==11

0000abd4 <.Loc.38.1>:
    abd4:	0d 93       	cmp	#0,	r13	;r3 As==00
    abd6:	20 24       	jz	$+66     	;abs 0xac18

0000abd8 <.Loc.38.1>:
    abd8:	0f 93       	cmp	#0,	r15	;r3 As==00
    abda:	ee 3b       	jl	$-34     	;abs 0xabb8

0000abdc <.Loc.40.1>:
    abdc:	05 4e       	mov	r14,	r5	;
    abde:	06 4f       	mov	r15,	r6	;
    abe0:	05 5e       	add	r14,	r5	;
    abe2:	06 6f       	addc	r15,	r6	;
    abe4:	0e 45       	mov	r5,	r14	;

0000abe6 <.LVL7>:
    abe6:	0f 46       	mov	r6,	r15	;

0000abe8 <.LVL8>:
    abe8:	05 48       	mov	r8,	r5	;
    abea:	06 49       	mov	r9,	r6	;
    abec:	05 58       	add	r8,	r5	;
    abee:	06 69       	addc	r9,	r6	;
    abf0:	08 45       	mov	r5,	r8	;

0000abf2 <.LVL9>:
    abf2:	09 46       	mov	r6,	r9	;

0000abf4 <.LVL10>:
    abf4:	db 3f       	jmp	$-72     	;abs 0xabac

0000abf6 <.L12>:
    abf6:	0b 9f       	cmp	r15,	r11	;
    abf8:	08 28       	jnc	$+18     	;abs 0xac0a
    abfa:	0f 9b       	cmp	r11,	r15	;
    abfc:	02 20       	jnz	$+6      	;abs 0xac02
    abfe:	0a 9e       	cmp	r14,	r10	;
    ac00:	04 28       	jnc	$+10     	;abs 0xac0a

0000ac02 <.L16>:
    ac02:	0a 8e       	sub	r14,	r10	;
    ac04:	0b 7f       	subc	r15,	r11	;

0000ac06 <.Loc.48.1>:
    ac06:	0c d8       	bis	r8,	r12	;

0000ac08 <.LVL13>:
    ac08:	0d d9       	bis	r9,	r13	;

0000ac0a <.L10>:
    ac0a:	12 c3       	clrc			
    ac0c:	09 10       	rrc	r9		;
    ac0e:	08 10       	rrc	r8		;

0000ac10 <.Loc.51.1>:
    ac10:	12 c3       	clrc			
    ac12:	0f 10       	rrc	r15		;
    ac14:	0e 10       	rrc	r14		;
    ac16:	d2 3f       	jmp	$-90     	;abs 0xabbc

0000ac18 <.L14>:
    ac18:	0c 4d       	mov	r13,	r12	;

0000ac1a <.LVL18>:
    ac1a:	d4 3f       	jmp	$-86     	;abs 0xabc4

0000ac1c <__mspabi_divlu>:
    ac1c:	21 83       	decd	r1		;

0000ac1e <.LCFI5>:
    ac1e:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000ac22 <L0>:
    ac22:	b0 12 9c ab 	call	#-21604	;#0xab9c

0000ac26 <.LVL46>:
    ac26:	21 53       	incd	r1		;
    ac28:	30 41       	ret			

0000ac2a <__mspabi_slli_15>:
    ac2a:	0c 5c       	rla	r12		;

0000ac2c <__mspabi_slli_14>:
    ac2c:	0c 5c       	rla	r12		;

0000ac2e <__mspabi_slli_13>:
    ac2e:	0c 5c       	rla	r12		;

0000ac30 <__mspabi_slli_12>:
    ac30:	0c 5c       	rla	r12		;

0000ac32 <__mspabi_slli_11>:
    ac32:	0c 5c       	rla	r12		;

0000ac34 <__mspabi_slli_10>:
    ac34:	0c 5c       	rla	r12		;

0000ac36 <__mspabi_slli_9>:
    ac36:	0c 5c       	rla	r12		;

0000ac38 <__mspabi_slli_8>:
    ac38:	0c 5c       	rla	r12		;

0000ac3a <__mspabi_slli_7>:
    ac3a:	0c 5c       	rla	r12		;

0000ac3c <__mspabi_slli_6>:
    ac3c:	0c 5c       	rla	r12		;

0000ac3e <__mspabi_slli_5>:
    ac3e:	0c 5c       	rla	r12		;

0000ac40 <__mspabi_slli_4>:
    ac40:	0c 5c       	rla	r12		;

0000ac42 <__mspabi_slli_3>:
    ac42:	0c 5c       	rla	r12		;

0000ac44 <__mspabi_slli_2>:
    ac44:	0c 5c       	rla	r12		;

0000ac46 <__mspabi_slli_1>:
    ac46:	0c 5c       	rla	r12		;
    ac48:	30 41       	ret			

0000ac4a <.L11>:
    ac4a:	3d 53       	add	#-1,	r13	;r3 As==11
    ac4c:	0c 5c       	rla	r12		;

0000ac4e <__mspabi_slli>:
    ac4e:	0d 93       	cmp	#0,	r13	;r3 As==00
    ac50:	fc 23       	jnz	$-6      	;abs 0xac4a
    ac52:	30 41       	ret			

0000ac54 <__mspabi_slll_15>:
    ac54:	0c 5c       	rla	r12		;
    ac56:	0d 6d       	rlc	r13		;

0000ac58 <__mspabi_slll_14>:
    ac58:	0c 5c       	rla	r12		;
    ac5a:	0d 6d       	rlc	r13		;

0000ac5c <__mspabi_slll_13>:
    ac5c:	0c 5c       	rla	r12		;
    ac5e:	0d 6d       	rlc	r13		;

0000ac60 <__mspabi_slll_12>:
    ac60:	0c 5c       	rla	r12		;
    ac62:	0d 6d       	rlc	r13		;

0000ac64 <__mspabi_slll_11>:
    ac64:	0c 5c       	rla	r12		;
    ac66:	0d 6d       	rlc	r13		;

0000ac68 <__mspabi_slll_10>:
    ac68:	0c 5c       	rla	r12		;
    ac6a:	0d 6d       	rlc	r13		;

0000ac6c <__mspabi_slll_9>:
    ac6c:	0c 5c       	rla	r12		;
    ac6e:	0d 6d       	rlc	r13		;

0000ac70 <__mspabi_slll_8>:
    ac70:	0c 5c       	rla	r12		;
    ac72:	0d 6d       	rlc	r13		;

0000ac74 <__mspabi_slll_7>:
    ac74:	0c 5c       	rla	r12		;
    ac76:	0d 6d       	rlc	r13		;

0000ac78 <__mspabi_slll_6>:
    ac78:	0c 5c       	rla	r12		;
    ac7a:	0d 6d       	rlc	r13		;

0000ac7c <__mspabi_slll_5>:
    ac7c:	0c 5c       	rla	r12		;
    ac7e:	0d 6d       	rlc	r13		;

0000ac80 <__mspabi_slll_4>:
    ac80:	0c 5c       	rla	r12		;
    ac82:	0d 6d       	rlc	r13		;

0000ac84 <__mspabi_slll_3>:
    ac84:	0c 5c       	rla	r12		;
    ac86:	0d 6d       	rlc	r13		;

0000ac88 <__mspabi_slll_2>:
    ac88:	0c 5c       	rla	r12		;
    ac8a:	0d 6d       	rlc	r13		;

0000ac8c <__mspabi_slll_1>:
    ac8c:	0c 5c       	rla	r12		;
    ac8e:	0d 6d       	rlc	r13		;
    ac90:	30 41       	ret			

0000ac92 <.L12>:
    ac92:	3e 53       	add	#-1,	r14	;r3 As==11
    ac94:	0c 5c       	rla	r12		;
    ac96:	0d 6d       	rlc	r13		;

0000ac98 <__mspabi_slll>:
    ac98:	0e 93       	cmp	#0,	r14	;r3 As==00
    ac9a:	fb 23       	jnz	$-8      	;abs 0xac92
    ac9c:	30 41       	ret			

0000ac9e <__mspabi_srli_15>:
    ac9e:	12 c3       	clrc			
    aca0:	0c 10       	rrc	r12		;

0000aca2 <__mspabi_srli_14>:
    aca2:	12 c3       	clrc			
    aca4:	0c 10       	rrc	r12		;

0000aca6 <__mspabi_srli_13>:
    aca6:	12 c3       	clrc			
    aca8:	0c 10       	rrc	r12		;

0000acaa <__mspabi_srli_12>:
    acaa:	12 c3       	clrc			
    acac:	0c 10       	rrc	r12		;

0000acae <__mspabi_srli_11>:
    acae:	12 c3       	clrc			
    acb0:	0c 10       	rrc	r12		;

0000acb2 <__mspabi_srli_10>:
    acb2:	12 c3       	clrc			
    acb4:	0c 10       	rrc	r12		;

0000acb6 <__mspabi_srli_9>:
    acb6:	12 c3       	clrc			
    acb8:	0c 10       	rrc	r12		;

0000acba <__mspabi_srli_8>:
    acba:	12 c3       	clrc			
    acbc:	0c 10       	rrc	r12		;

0000acbe <__mspabi_srli_7>:
    acbe:	12 c3       	clrc			
    acc0:	0c 10       	rrc	r12		;

0000acc2 <__mspabi_srli_6>:
    acc2:	12 c3       	clrc			
    acc4:	0c 10       	rrc	r12		;

0000acc6 <__mspabi_srli_5>:
    acc6:	12 c3       	clrc			
    acc8:	0c 10       	rrc	r12		;

0000acca <__mspabi_srli_4>:
    acca:	12 c3       	clrc			
    accc:	0c 10       	rrc	r12		;

0000acce <__mspabi_srli_3>:
    acce:	12 c3       	clrc			
    acd0:	0c 10       	rrc	r12		;

0000acd2 <__mspabi_srli_2>:
    acd2:	12 c3       	clrc			
    acd4:	0c 10       	rrc	r12		;

0000acd6 <__mspabi_srli_1>:
    acd6:	12 c3       	clrc			
    acd8:	0c 10       	rrc	r12		;
    acda:	30 41       	ret			

0000acdc <.L11>:
    acdc:	3d 53       	add	#-1,	r13	;r3 As==11
    acde:	12 c3       	clrc			
    ace0:	0c 10       	rrc	r12		;

0000ace2 <__mspabi_srli>:
    ace2:	0d 93       	cmp	#0,	r13	;r3 As==00
    ace4:	fb 23       	jnz	$-8      	;abs 0xacdc
    ace6:	30 41       	ret			

0000ace8 <__mspabi_srll_15>:
    ace8:	12 c3       	clrc			
    acea:	0d 10       	rrc	r13		;
    acec:	0c 10       	rrc	r12		;

0000acee <__mspabi_srll_14>:
    acee:	12 c3       	clrc			
    acf0:	0d 10       	rrc	r13		;
    acf2:	0c 10       	rrc	r12		;

0000acf4 <__mspabi_srll_13>:
    acf4:	12 c3       	clrc			
    acf6:	0d 10       	rrc	r13		;
    acf8:	0c 10       	rrc	r12		;

0000acfa <__mspabi_srll_12>:
    acfa:	12 c3       	clrc			
    acfc:	0d 10       	rrc	r13		;
    acfe:	0c 10       	rrc	r12		;

0000ad00 <__mspabi_srll_11>:
    ad00:	12 c3       	clrc			
    ad02:	0d 10       	rrc	r13		;
    ad04:	0c 10       	rrc	r12		;

0000ad06 <__mspabi_srll_10>:
    ad06:	12 c3       	clrc			
    ad08:	0d 10       	rrc	r13		;
    ad0a:	0c 10       	rrc	r12		;

0000ad0c <__mspabi_srll_9>:
    ad0c:	12 c3       	clrc			
    ad0e:	0d 10       	rrc	r13		;
    ad10:	0c 10       	rrc	r12		;

0000ad12 <__mspabi_srll_8>:
    ad12:	12 c3       	clrc			
    ad14:	0d 10       	rrc	r13		;
    ad16:	0c 10       	rrc	r12		;

0000ad18 <__mspabi_srll_7>:
    ad18:	12 c3       	clrc			
    ad1a:	0d 10       	rrc	r13		;
    ad1c:	0c 10       	rrc	r12		;

0000ad1e <__mspabi_srll_6>:
    ad1e:	12 c3       	clrc			
    ad20:	0d 10       	rrc	r13		;
    ad22:	0c 10       	rrc	r12		;

0000ad24 <__mspabi_srll_5>:
    ad24:	12 c3       	clrc			
    ad26:	0d 10       	rrc	r13		;
    ad28:	0c 10       	rrc	r12		;

0000ad2a <__mspabi_srll_4>:
    ad2a:	12 c3       	clrc			
    ad2c:	0d 10       	rrc	r13		;
    ad2e:	0c 10       	rrc	r12		;

0000ad30 <__mspabi_srll_3>:
    ad30:	12 c3       	clrc			
    ad32:	0d 10       	rrc	r13		;
    ad34:	0c 10       	rrc	r12		;

0000ad36 <__mspabi_srll_2>:
    ad36:	12 c3       	clrc			
    ad38:	0d 10       	rrc	r13		;
    ad3a:	0c 10       	rrc	r12		;

0000ad3c <__mspabi_srll_1>:
    ad3c:	12 c3       	clrc			
    ad3e:	0d 10       	rrc	r13		;
    ad40:	0c 10       	rrc	r12		;
    ad42:	30 41       	ret			

0000ad44 <.L12>:
    ad44:	3e 53       	add	#-1,	r14	;r3 As==11
    ad46:	12 c3       	clrc			
    ad48:	0d 10       	rrc	r13		;
    ad4a:	0c 10       	rrc	r12		;

0000ad4c <__mspabi_srll>:
    ad4c:	0e 93       	cmp	#0,	r14	;r3 As==00
    ad4e:	fa 23       	jnz	$-10     	;abs 0xad44
    ad50:	30 41       	ret			

0000ad52 <__mspabi_mpyl>:
    ad52:	02 12       	push	r2		;
    ad54:	32 c2       	dint			
    ad56:	03 43       	nop			
    ad58:	82 4c d0 04 	mov	r12,	&0x04d0	;
    ad5c:	82 4d d2 04 	mov	r13,	&0x04d2	;
    ad60:	82 4e e0 04 	mov	r14,	&0x04e0	;
    ad64:	82 4f e2 04 	mov	r15,	&0x04e2	;
    ad68:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    ad6c:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    ad70:	00 13       	reti			

0000ad72 <memcpy>:
    ad72:	0f 4c       	mov	r12,	r15	;
    ad74:	0e 5c       	add	r12,	r14	;

0000ad76 <.L2>:
    ad76:	0f 9e       	cmp	r14,	r15	;
    ad78:	05 24       	jz	$+12     	;abs 0xad84

0000ad7a <.LVL3>:
    ad7a:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    ad7e:	1f 53       	inc	r15		;

0000ad80 <.LVL4>:
    ad80:	1d 53       	inc	r13		;
    ad82:	f9 3f       	jmp	$-12     	;abs 0xad76

0000ad84 <.L5>:
    ad84:	30 41       	ret			

0000ad86 <memmove>:
    ad86:	0b 4c       	mov	r12,	r11	;

0000ad88 <L0>:
    ad88:	0b 5e       	add	r14,	r11	;

0000ad8a <.Loc.69.1>:
    ad8a:	0d 9c       	cmp	r12,	r13	;
    ad8c:	02 28       	jnc	$+6      	;abs 0xad92

0000ad8e <.L4>:
    ad8e:	0e 4c       	mov	r12,	r14	;

0000ad90 <.LVL2>:
    ad90:	0f 3c       	jmp	$+32     	;abs 0xadb0

0000ad92 <.L2>:
    ad92:	0f 4d       	mov	r13,	r15	;
    ad94:	0f 5e       	add	r14,	r15	;
    ad96:	0c 9f       	cmp	r15,	r12	;
    ad98:	fa 2f       	jc	$-10     	;abs 0xad8e

0000ad9a <.LVL4>:
    ad9a:	0d 4f       	mov	r15,	r13	;

0000ad9c <.LVL5>:
    ad9c:	0e 8f       	sub	r15,	r14	;

0000ad9e <.L5>:
    ad9e:	0f 4d       	mov	r13,	r15	;
    ada0:	0f 5e       	add	r14,	r15	;
    ada2:	0f 93       	cmp	#0,	r15	;r3 As==00
    ada4:	0c 24       	jz	$+26     	;abs 0xadbe

0000ada6 <.Loc.76.1>:
    ada6:	3b 53       	add	#-1,	r11	;r3 As==11
    ada8:	3d 53       	add	#-1,	r13	;r3 As==11

0000adaa <.LVL8>:
    adaa:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    adae:	f7 3f       	jmp	$-16     	;abs 0xad9e

0000adb0 <.L3>:
    adb0:	0b 9e       	cmp	r14,	r11	;
    adb2:	05 24       	jz	$+12     	;abs 0xadbe

0000adb4 <.LVL10>:
    adb4:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    adb8:	1e 53       	inc	r14		;

0000adba <.LVL11>:
    adba:	1d 53       	inc	r13		;
    adbc:	f9 3f       	jmp	$-12     	;abs 0xadb0

0000adbe <.L9>:
    adbe:	30 41       	ret			

0000adc0 <memset>:
    adc0:	0f 4c       	mov	r12,	r15	;
    adc2:	0e 5c       	add	r12,	r14	;

0000adc4 <.L2>:
    adc4:	0f 9e       	cmp	r14,	r15	;

0000adc6 <L0>:
    adc6:	04 24       	jz	$+10     	;abs 0xadd0

0000adc8 <.LVL3>:
    adc8:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    adcc:	1f 53       	inc	r15		;

0000adce <.LVL4>:
    adce:	fa 3f       	jmp	$-10     	;abs 0xadc4

0000add0 <.L5>:
    add0:	30 41       	ret			
