
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	64 44       	mov.b	@r4,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	68 44       	mov.b	@r4,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	6c 44       	mov.b	@r4,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	70 44       	br	@r4+		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	74 44       	mov.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	78 44       	mov.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	7c 44       	mov.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	80 44 00 00 	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	84 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8c 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	90 44 00 00 	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	94 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	9c 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a0 44 00 00 	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a4 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	ac 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b0 44 00 00 	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b4 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b8 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c0 44 00 00 	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c4 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c8 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	cc 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 44 00 00 	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d4 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d8 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	dc 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e0 44 00 00 	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	c0 f5 00 00 	and.b	r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	44 f5       	and.b	r5,	r4	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e4 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	e8 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	c8 f4       	and.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	f0 44 00 00 	mov.b	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	5c f4       	and.b,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	d2 f9       	interrupt service routine at 0xf9d2

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f4 44       	interrupt service routine at 0x44f4

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	3c f6       	interrupt service routine at 0xf63c

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	a4 f8       	interrupt service routine at 0xf8a4

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	f8 44       	interrupt service routine at 0x44f8

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	fc 44       	interrupt service routine at 0x44fc

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	00 45       	interrupt service routine at 0x4500

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	de f6       	interrupt service routine at 0xf6de

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	04 45       	interrupt service routine at 0x4504

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	08 45       	interrupt service routine at 0x4508

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	22 f4       	interrupt service routine at 0xf422

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	0c 45       	interrupt service routine at 0x450c

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	10 45       	interrupt service routine at 0x4510

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	14 45       	interrupt service routine at 0x4514

Disassembly of section .text:

00004400 <__crt0_start>:
#ifdef MINRT
	.refsym	__crt0_call_just_main
#else
	.refsym	__crt0_call_init_then_main
#endif
	mov_	#__stack, R1
    4400:	81 00 64 d0 	mova	#53348,	r1	;0x0d064

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
;; application if it is needed.  It is responsible for initializing
;; the contents of the .bss section.

START_CRT_FUNC 0100 init_bss

	mov_	#__bssstart, R12
    440c:	8c 00 18 d1 	mova	#53528,	r12	;0x0d118

00004410 <.Loc.74.1>:
	clr.w	R13
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
	mov.w	#__bsssize, R14
    4412:	3e 40 0a 23 	mov	#8970,	r14	;#0x230a

00004416 <.Loc.77.1>:
#ifdef __MSP430X_LARGE__
	clr.w	R15		; We assume that __bsssize is never > 64M
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
#endif
	call_	#memset
    4418:	b0 13 4a cf 	calla	#53066		;0x0cf4a

0000441c <__crt0_init_highbss>:
;; application if it is needed.  It is responsible for initializing
;; the contents of the .upper.bss section.

START_CRT_FUNC 0200 init_highbss
	
	mov_	#__high_bssstart, R12
    441c:	8c 01 20 13 	mova	#70432,	r12	;0x11320

00004420 <.Loc.94.1>:
	mov.w	#0, R13
    4420:	0d 43       	clr	r13		;

00004422 <.Loc.95.1>:
	mov_	#__high_bsssize, R14
    4422:	8e 01 6a 1a 	mova	#72298,	r14	;0x11a6a

00004426 <.Loc.98.1>:
	;; If __high_bsssize is zero then skip the call to memset.
	;; This can happen if all of the bss data was placed into .either.bss.
	cmp.w	#0, R14
    4426:	0e 93       	cmp	#0,	r14	;r3 As==00

00004428 <.Loc.99.1>:
	jeq	1f
    4428:	02 24       	jz	$+6      	;abs 0x442e

0000442a <.Loc.100.1>:
	call_	#memset
    442a:	b0 13 4a cf 	calla	#53066		;0x0cf4a

0000442e <__crt0_move_highdata>:
START_CRT_FUNC 0400 move_highdata
	;;  __rom_highdatacopysize may be zero.  Test this first because
	;; its value may come from the weak definitions above and we do
	;; not want to access the memory at address 0 pointed to by the
	;; weak definition of __upper_data_init.
	mov.w	#__rom_highdatacopysize, R14
    442e:	3e 40 72 0a 	mov	#2674,	r14	;#0x0a72

00004432 <.Loc.146.1>:
	cmp.w	#0, R14
    4432:	0e 93       	cmp	#0,	r14	;r3 As==00

00004434 <.Loc.147.1>:
	jeq	3f
    4434:	14 24       	jz	$+42     	;abs 0x445e

00004436 <.Loc.150.1>:

	/* Test our status word.  */
	cmpx.w  #0, &__upper_data_init
    4436:	41 18 82 93 	cmpx.w	#0,	&0x108ac;r3 As==00
    443a:	ac 08 

0000443c <.Loc.151.1>:
	jeq	1f
    443c:	05 24       	jz	$+12     	;abs 0x4448

0000443e <.Loc.153.1>:
	/* Status word is non-zero - copy from shadow into upper.  */
	mov_	#__high_datastart, R12
    443e:	8c 01 ae 08 	mova	#67758,	r12	;0x108ae

00004442 <.Loc.154.1>:
	mov_	#__rom_highdatastart, R13
    4442:	8d 01 ae 08 	mova	#67758,	r13	;0x108ae

00004446 <.Loc.155.1>:
	jmp	2f
    4446:	07 3c       	jmp	$+16     	;abs 0x4456

00004448 <.L11>:

1:	/* Status word is zero.  Copy from upper to shadow and change status word.  */
	movx.w  #1, &__upper_data_init
    4448:	41 18 92 43 	movx.w	#1,	&0x108ac;r3 As==01
    444c:	ac 08 

0000444e <.Loc.159.1>:
	mov_	#__rom_highdatastart, R12
    444e:	8c 01 ae 08 	mova	#67758,	r12	;0x108ae

00004452 <.Loc.160.1>:
	mov_	#__high_datastart, R13
    4452:	8d 01 ae 08 	mova	#67758,	r13	;0x108ae

00004456 <.L21>:

2:	;; __rom_highdatacopysize may be zero.  memmove should cope.
	mov.w	#__rom_highdatacopysize, R14
    4456:	3e 40 72 0a 	mov	#2674,	r14	;#0x0a72

0000445a <.Loc.165.1>:

	call_	#memmove
    445a:	b0 13 f4 ce 	calla	#52980		;0x0cef4

0000445e <__crt0_call_just_main>:
;; main.  No initialization code is called first, and main is not
;; expected to return.

START_CRT_FUNC 0600 call_just_main

	clr.w	R12		; Set argc == 0
    445e:	0c 43       	clr	r12		;

00004460 <.Loc.181.1>:
	call_	#main
    4460:	b0 13 f8 c5 	calla	#50680		;0x0c5f8

00004464 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4464:	80 00 64 44 	mova	#17508,	r0	;0x04464

00004468 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    4468:	80 00 68 44 	mova	#17512,	r0	;0x04468

0000446c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    446c:	80 00 6c 44 	mova	#17516,	r0	;0x0446c

00004470 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4470:	80 00 70 44 	mova	#17520,	r0	;0x04470

00004474 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4474:	80 00 74 44 	mova	#17524,	r0	;0x04474

00004478 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    4478:	80 00 78 44 	mova	#17528,	r0	;0x04478

0000447c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    447c:	80 00 7c 44 	mova	#17532,	r0	;0x0447c

00004480 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4480:	80 00 80 44 	mova	#17536,	r0	;0x04480

00004484 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4484:	80 00 84 44 	mova	#17540,	r0	;0x04484

00004488 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    4488:	80 00 88 44 	mova	#17544,	r0	;0x04488

0000448c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    448c:	80 00 8c 44 	mova	#17548,	r0	;0x0448c

00004490 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4490:	80 00 90 44 	mova	#17552,	r0	;0x04490

00004494 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4494:	80 00 94 44 	mova	#17556,	r0	;0x04494

00004498 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    4498:	80 00 98 44 	mova	#17560,	r0	;0x04498

0000449c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    449c:	80 00 9c 44 	mova	#17564,	r0	;0x0449c

000044a0 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    44a0:	80 00 a0 44 	mova	#17568,	r0	;0x044a0

000044a4 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    44a4:	80 00 a4 44 	mova	#17572,	r0	;0x044a4

000044a8 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    44a8:	80 00 a8 44 	mova	#17576,	r0	;0x044a8

000044ac <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    44ac:	80 00 ac 44 	mova	#17580,	r0	;0x044ac

000044b0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    44b0:	80 00 b0 44 	mova	#17584,	r0	;0x044b0

000044b4 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    44b4:	80 00 b4 44 	mova	#17588,	r0	;0x044b4

000044b8 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    44b8:	80 00 b8 44 	mova	#17592,	r0	;0x044b8

000044bc <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    44bc:	80 00 bc 44 	mova	#17596,	r0	;0x044bc

000044c0 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    44c0:	80 00 c0 44 	mova	#17600,	r0	;0x044c0

000044c4 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    44c4:	80 00 c4 44 	mova	#17604,	r0	;0x044c4

000044c8 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    44c8:	80 00 c8 44 	mova	#17608,	r0	;0x044c8

000044cc <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    44cc:	80 00 cc 44 	mova	#17612,	r0	;0x044cc

000044d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44d0:	80 00 d0 44 	mova	#17616,	r0	;0x044d0

000044d4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44d4:	80 00 d4 44 	mova	#17620,	r0	;0x044d4

000044d8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44d8:	80 00 d8 44 	mova	#17624,	r0	;0x044d8

000044dc <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44dc:	80 00 dc 44 	mova	#17628,	r0	;0x044dc

000044e0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44e0:	80 00 e0 44 	mova	#17632,	r0	;0x044e0

000044e4 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44e4:	80 00 e4 44 	mova	#17636,	r0	;0x044e4

000044e8 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44e8:	80 00 e8 44 	mova	#17640,	r0	;0x044e8

000044ec <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44ec:	80 00 ec 44 	mova	#17644,	r0	;0x044ec

000044f0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44f0:	80 00 f0 44 	mova	#17648,	r0	;0x044f0

000044f4 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44f4:	80 00 f4 44 	mova	#17652,	r0	;0x044f4

000044f8 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    44f8:	80 00 f8 44 	mova	#17656,	r0	;0x044f8

000044fc <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44fc:	80 00 fc 44 	mova	#17660,	r0	;0x044fc

00004500 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    4500:	80 00 00 45 	mova	#17664,	r0	;0x04500

00004504 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    4504:	80 00 04 45 	mova	#17668,	r0	;0x04504

00004508 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    4508:	80 00 08 45 	mova	#17672,	r0	;0x04508

0000450c <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    450c:	80 00 0c 45 	mova	#17676,	r0	;0x0450c

00004510 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    4510:	80 00 10 45 	mova	#17680,	r0	;0x04510

00004514 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    4514:	80 00 14 45 	mova	#17684,	r0	;0x04514

00004518 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    4518:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    451c:	96 13 

0000451e <.Loc.305.1>:
}
    451e:	10 01       	reta			;

00004520 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    4520:	03 43       	nop			

00004522 <.Loc.356.1>:
  _enable_interrupts();
    4522:	03 43       	nop			
    4524:	32 d2       	eint			
    4526:	03 43       	nop			

00004528 <.Loc.357.1>:
}
    4528:	10 01       	reta			;

0000452a <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    452a:	32 c2       	dint			
    452c:	03 43       	nop			

0000452e <.Loc.390.1>:
  asm volatile("nop");
    452e:	03 43       	nop			

00004530 <.Loc.391.1>:
}
    4530:	10 01       	reta			;

00004532 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4532:	41 18 82 93 	cmpx.w	#0,	&0x1132a;r3 As==00
    4536:	2a 13 
    4538:	04 20       	jnz	$+10     	;abs 0x4542

0000453a <.Loc.79.2>:
    453a:	41 18 82 93 	cmpx.w	#0,	&0x1132c;r3 As==00
    453e:	2c 13 
    4540:	08 24       	jz	$+18     	;abs 0x4552

00004542 <.L9>:
 *
 * @special
 */
void chSysHalt(const char *reason) {

  port_disable();
    4542:	b0 13 2a 45 	calla	#17706		;0x0452a

00004546 <.LVL4>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4546:	01 18 f2 40 	movx.a	#53353,	&0x1132e;0x0d069
    454a:	69 d0 2e 13 

0000454e <.L11>:
    454e:	80 00 4e 45 	mova	#17742,	r0	;0x0454e

00004552 <.L8>:
}
    4552:	10 01       	reta			;

00004554 <_dbg_check_lock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4554:	41 18 82 93 	cmpx.w	#0,	&0x1132a;r3 As==00
    4558:	2a 13 
    455a:	04 20       	jnz	$+10     	;abs 0x4564

0000455c <.Loc.103.2>:
    455c:	41 18 82 93 	cmpx.w	#0,	&0x1132c;r3 As==00
    4560:	2c 13 
    4562:	08 24       	jz	$+18     	;abs 0x4574

00004564 <.L17>:
  port_disable();
    4564:	b0 13 2a 45 	calla	#17706		;0x0452a

00004568 <.LVL10>:
  nil.dbg_panic_msg = reason;
    4568:	01 18 f2 40 	movx.a	#53363,	&0x1132e;0x0d073
    456c:	73 d0 2e 13 

00004570 <.L19>:
    4570:	80 00 70 45 	mova	#17776,	r0	;0x04570

00004574 <.L18>:
  _dbg_enter_lock();
    4574:	41 18 92 43 	movx.w	#1,	&0x1132c;r3 As==01
    4578:	2c 13 

0000457a <.Loc.107.2>:
}
    457a:	10 01       	reta			;

0000457c <_dbg_check_unlock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    457c:	41 18 82 93 	cmpx.w	#0,	&0x1132a;r3 As==00
    4580:	2a 13 
    4582:	05 20       	jnz	$+12     	;abs 0x458e

00004584 <.Loc.116.2>:
    4584:	4c 43       	clr.b	r12		;
    4586:	c0 18 1c 92 	cmpx.w	&0x1132c,r12	;
    458a:	2c 13 
    458c:	08 38       	jl	$+18     	;abs 0x459e

0000458e <.L21>:
  port_disable();
    458e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004592 <.LVL13>:
  nil.dbg_panic_msg = reason;
    4592:	01 18 f2 40 	movx.a	#53368,	&0x1132e;0x0d078
    4596:	78 d0 2e 13 

0000459a <.L23>:
    459a:	80 00 9a 45 	mova	#17818,	r0	;0x0459a

0000459e <.L22>:
  _dbg_leave_lock();
    459e:	41 18 82 43 	movx.w	#0,	&0x1132c;r3 As==00
    45a2:	2c 13 

000045a4 <.Loc.120.2>:
}
    45a4:	10 01       	reta			;

000045a6 <_dbg_check_lock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45a6:	4c 43       	clr.b	r12		;
    45a8:	c0 18 1c 92 	cmpx.w	&0x1132a,r12	;
    45ac:	2a 13 
    45ae:	04 34       	jge	$+10     	;abs 0x45b8

000045b0 <.Loc.129.2>:
    45b0:	41 18 82 9c 	cmpx.w	r12,	&0x1132c;
    45b4:	2c 13 
    45b6:	08 24       	jz	$+18     	;abs 0x45c8

000045b8 <.L25>:
  port_disable();
    45b8:	b0 13 2a 45 	calla	#17706		;0x0452a

000045bc <.LVL16>:
  nil.dbg_panic_msg = reason;
    45bc:	01 18 f2 40 	movx.a	#53373,	&0x1132e;0x0d07d
    45c0:	7d d0 2e 13 

000045c4 <.L27>:
    45c4:	80 00 c4 45 	mova	#17860,	r0	;0x045c4

000045c8 <.L26>:
  _dbg_enter_lock();
    45c8:	41 18 92 43 	movx.w	#1,	&0x1132c;r3 As==01
    45cc:	2c 13 

000045ce <.Loc.133.2>:
}
    45ce:	10 01       	reta			;

000045d0 <_dbg_check_unlock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    45d0:	4c 43       	clr.b	r12		;
    45d2:	c0 18 1c 92 	cmpx.w	&0x1132a,r12	;
    45d6:	2a 13 
    45d8:	04 34       	jge	$+10     	;abs 0x45e2

000045da <.Loc.142.2>:
    45da:	c0 18 1c 92 	cmpx.w	&0x1132c,r12	;
    45de:	2c 13 
    45e0:	08 38       	jl	$+18     	;abs 0x45f2

000045e2 <.L29>:
  port_disable();
    45e2:	b0 13 2a 45 	calla	#17706		;0x0452a

000045e6 <.LVL19>:
  nil.dbg_panic_msg = reason;
    45e6:	01 18 f2 40 	movx.a	#53378,	&0x1132e;0x0d082
    45ea:	82 d0 2e 13 

000045ee <.L31>:
    45ee:	80 00 ee 45 	mova	#17902,	r0	;0x045ee

000045f2 <.L30>:
  _dbg_leave_lock();
    45f2:	41 18 82 43 	movx.w	#0,	&0x1132c;r3 As==00
    45f6:	2c 13 

000045f8 <.Loc.146.2>:
}
    45f8:	10 01       	reta			;

000045fa <_dbg_check_enter_isr>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45fa:	8c 01 20 13 	mova	#70432,	r12	;0x11320
    45fe:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    4602:	0d 93       	cmp	#0,	r13	;r3 As==00
    4604:	04 38       	jl	$+10     	;abs 0x460e

00004606 <.Loc.156.2>:
    4606:	41 18 82 93 	cmpx.w	#0,	&0x1132c;r3 As==00
    460a:	2c 13 
    460c:	08 24       	jz	$+18     	;abs 0x461e

0000460e <.L33>:
  port_disable();
    460e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004612 <.LVL22>:
  nil.dbg_panic_msg = reason;
    4612:	01 18 f2 40 	movx.a	#53383,	&0x1132e;0x0d087
    4616:	87 d0 2e 13 

0000461a <.L35>:
    461a:	80 00 1a 46 	mova	#17946,	r0	;0x0461a

0000461e <.L34>:
  nil.isr_cnt++;
    461e:	1d 53       	inc	r13		;
    4620:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00004624 <.Loc.161.2>:
}
    4624:	10 01       	reta			;

00004626 <_dbg_check_leave_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4626:	8c 01 20 13 	mova	#70432,	r12	;0x11320
    462a:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    462e:	4e 43       	clr.b	r14		;
    4630:	0e 9d       	cmp	r13,	r14	;
    4632:	04 34       	jge	$+10     	;abs 0x463c

00004634 <.Loc.171.2>:
    4634:	41 18 82 9e 	cmpx.w	r14,	&0x1132c;
    4638:	2c 13 
    463a:	08 24       	jz	$+18     	;abs 0x464c

0000463c <.L37>:
  port_disable();
    463c:	b0 13 2a 45 	calla	#17706		;0x0452a

00004640 <.LVL25>:
  nil.dbg_panic_msg = reason;
    4640:	01 18 f2 40 	movx.a	#53388,	&0x1132e;0x0d08c
    4644:	8c d0 2e 13 

00004648 <.L39>:
    4648:	80 00 48 46 	mova	#17992,	r0	;0x04648

0000464c <.L38>:
  nil.isr_cnt--;
    464c:	3d 53       	add	#-1,	r13	;r3 As==11
    464e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00004652 <.Loc.176.2>:
}
    4652:	10 01       	reta			;

00004654 <chDbgCheckClassI>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4654:	41 18 82 93 	cmpx.w	#0,	&0x1132a;r3 As==00
    4658:	2a 13 
    465a:	05 38       	jl	$+12     	;abs 0x4666

0000465c <.Loc.188.2>:
    465c:	4c 43       	clr.b	r12		;
    465e:	c0 18 1c 92 	cmpx.w	&0x1132c,r12	;
    4662:	2c 13 
    4664:	08 38       	jl	$+18     	;abs 0x4676

00004666 <.L41>:
  port_disable();
    4666:	b0 13 2a 45 	calla	#17706		;0x0452a

0000466a <.LVL28>:
  nil.dbg_panic_msg = reason;
    466a:	01 18 f2 40 	movx.a	#53393,	&0x1132e;0x0d091
    466e:	91 d0 2e 13 

00004672 <.L43>:
    4672:	80 00 72 46 	mova	#18034,	r0	;0x04672

00004676 <.L40>:
}
    4676:	10 01       	reta			;

00004678 <chDbgCheckClassS>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4678:	41 18 82 93 	cmpx.w	#0,	&0x1132a;r3 As==00
    467c:	2a 13 
    467e:	05 20       	jnz	$+12     	;abs 0x468a

00004680 <.Loc.203.2>:
    4680:	4c 43       	clr.b	r12		;
    4682:	c0 18 1c 92 	cmpx.w	&0x1132c,r12	;
    4686:	2c 13 
    4688:	08 38       	jl	$+18     	;abs 0x469a

0000468a <.L45>:
  port_disable();
    468a:	b0 13 2a 45 	calla	#17706		;0x0452a

0000468e <.LVL31>:
  nil.dbg_panic_msg = reason;
    468e:	01 18 f2 40 	movx.a	#53399,	&0x1132e;0x0d097
    4692:	97 d0 2e 13 

00004696 <.L47>:
    4696:	80 00 96 46 	mova	#18070,	r0	;0x04696

0000469a <.L44>:
}
    469a:	10 01       	reta			;

0000469c <chSysInit>:
__attribute__((optimize(0))) void chSysInit(void) {
    469c:	b1 00 14 00 	suba	#20,	r1	;0x00014

000046a0 <.LCFI0>:
  nil.isr_cnt  = (cnt_t)0;
    46a0:	41 18 82 43 	movx.w	#0,	&0x1132a;r3 As==00
    46a4:	2a 13 

000046a6 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    46a6:	41 18 82 43 	movx.w	#0,	&0x1132c;r3 As==00
    46aa:	2c 13 

000046ac <.Loc.233.2>:
  tp = &nil.threads[0];
    46ac:	80 18 f1 40 	movx.a	#70450,	16(r1)	;0x11332, 0x00010
    46b0:	32 13 10 00 

000046b4 <.Loc.234.2>:
  tcp = nil_thd_configs;
    46b4:	80 18 f1 40 	movx.a	#67606,	12(r1)	;0x10816, 0x0000c
    46b8:	16 08 0c 00 

000046bc <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    46bc:	80 00 88 47 	mova	#18312,	r0	;0x04788

000046c0 <.L50>:
    tp->wabase  = (stkalign_t *)tcp->wbase;
    46c0:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    46c4:	0d 0c       	mova	@r12,	r13	;
    46c6:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46ca:	7c 0d 10 00 	mova	r13,	16(r12)	; 0x00010

000046ce <.Loc.241.2>:
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    46ce:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    46d2:	3c 0c 04 00 	mova	4(r12),	r12	;
    46d6:	cd 0c       	mova	r12,	r13	;
    46d8:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    46dc:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46e0:	7c 0d 00 00 	mova	r13,	0(r12)	;
    46e4:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46e8:	0c 0c       	mova	@r12,	r12	;
    46ea:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    46ee:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    46f2:	71 0d 08 00 	mova	r13,	8(r1)	;
    46f6:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    46fa:	00 00 
    46fc:	3e 01 08 00 	mova	8(r1),	r14	;
    4700:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4702:	0d 17       	popm	#1,	r13	;16-bit words
    4704:	0d 17       	popm	#1,	r13	;16-bit words
    4706:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    470a:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    470e:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4712:	4d de       	bis.b	r14,	r13	;
    4714:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    4718:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    471c:	0c 0c       	mova	@r12,	r12	;
    471e:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    4722:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    4726:	71 0d 04 00 	mova	r13,	4(r1)	;
    472a:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    472e:	04 00 
    4730:	3e 01 04 00 	mova	4(r1),	r14	;
    4734:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4736:	0d 17       	popm	#1,	r13	;16-bit words
    4738:	0d 17       	popm	#1,	r13	;16-bit words
    473a:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    473e:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    4742:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4746:	4d de       	bis.b	r14,	r13	;
    4748:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    474c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4750:	0c 0c       	mova	@r12,	r12	;
    4752:	00 18 f1 40 	movx.a	#20366,	0(r1)	;0x04f8e
    4756:	8e 4f 00 00 
    475a:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    475e:	0e 01       	mova	@r1,	r14	;
    4760:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4762:	0d 17       	popm	#1,	r13	;16-bit words
    4764:	0d 17       	popm	#1,	r13	;16-bit words
    4766:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    476a:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    476e:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4772:	4d de       	bis.b	r14,	r13	;
    4774:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

00004778 <.Loc.246.2>:
    tp++;
    4778:	00 18 f1 50 	addx.a	#20,	16(r1)	;0x00014, 0x00010
    477c:	14 00 10 00 

00004780 <.Loc.247.2>:
    tcp++;
    4780:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    4784:	14 00 0c 00 

00004788 <.L49>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4788:	80 18 f1 90 	cmpx.a	#70530,	16(r1)	;0x11382, 0x00010
    478c:	82 13 10 00 
    4790:	97 2b       	jnc	$-208    	;abs 0x46c0

00004792 <.Loc.253.2>:
  tp->wabase  = THD_IDLE_BASE;
    4792:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4796:	00 18 fc 40 	movx.a	#53348,	16(r12)	;0x0d064, 0x00010
    479a:	64 d0 10 00 

0000479e <.Loc.258.2>:
  chSysSuspend();
    479e:	b0 13 2a 45 	calla	#17706		;0x0452a

000047a2 <.LVL37>:
    47a2:	b0 13 32 45 	calla	#17714		;0x04532

000047a6 <.LVL38>:
  nil.lock_cnt = (cnt_t)1;
    47a6:	41 18 92 43 	movx.w	#1,	&0x1132c;r3 As==01
    47aa:	2c 13 

000047ac <.Loc.270.2>:
  port_init();
    47ac:	b0 13 18 45 	calla	#17688		;0x04518

000047b0 <.LVL39>:
  nil.current = nil.next = nil.threads;
    47b0:	81 18 f2 40 	movx.a	#70450,	&0x11324;0x11332
    47b4:	32 13 24 13 
    47b8:	2c 01 24 13 	mova	&70436,	r12	;0x11324
    47bc:	61 0c 20 13 	mova	r12,	&70432	; 0x11320

000047c0 <.Loc.275.2>:
  port_switch(nil.current, tp);
    47c0:	2c 01 20 13 	mova	&70432,	r12	;0x11320
    47c4:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    47c8:	b0 13 82 4f 	calla	#20354		;0x04f82

000047cc <.LVL40>:
  chSysUnlock();
    47cc:	b0 13 7c 45 	calla	#17788		;0x0457c

000047d0 <.LVL41>:
    47d0:	b0 13 20 45 	calla	#17696		;0x04520

000047d4 <.LVL42>:
}
    47d4:	03 43       	nop			
    47d6:	a1 00 14 00 	adda	#20,	r1	;0x00014
    47da:	10 01       	reta			;

000047dc <chSysHalt>:
void chSysHalt(const char *reason) {
    47dc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047de <.LCFI1>:
    47de:	ca 0c       	mova	r12,	r10	;

000047e0 <.Loc.293.2>:
  port_disable();
    47e0:	b0 13 2a 45 	calla	#17706		;0x0452a

000047e4 <.LVL44>:
  nil.dbg_panic_msg = reason;
    47e4:	61 0a 2e 13 	mova	r10,	&70446	; 0x1132e

000047e8 <.L52>:
    47e8:	80 00 e8 47 	mova	#18408,	r0	;0x047e8

000047ec <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    47ec:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047ee <.LCFI2>:
    47ee:	08 14       	pushm.a	#1,	r8	;20-bit words

000047f0 <.LCFI3>:
    47f0:	06 14       	pushm.a	#1,	r6	;20-bit words

000047f2 <.LCFI4>:
    47f2:	04 14       	pushm.a	#1,	r4	;20-bit words

000047f4 <.LCFI5>:

  chDbgCheckClassI();
    47f4:	b0 13 54 46 	calla	#18004		;0x04654

000047f8 <.LVL45>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    47f8:	88 01 20 13 	mova	#70432,	r8	;0x11320
    47fc:	98 53 08 00 	inc	8(r8)		;
    4800:	a8 00 18 00 	adda	#24,	r8	;0x00018

00004804 <.Loc.341.2>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4804:	8a 00 d6 48 	mova	#18646,	r10	;0x048d6

00004808 <.Loc.346.2>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    4808:	86 00 d0 45 	mova	#17872,	r6	;0x045d0

0000480c <.Loc.348.2>:
    tp++;
    chSysLockFromISR();
    480c:	84 00 a6 45 	mova	#17830,	r4	;0x045a6

00004810 <.L61>:
    4810:	cc 08       	mova	r8,	r12	;
    4812:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

00004816 <.LVL47>:
    if (tp->timeout > (systime_t)0) {
    4816:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    481a:	0d 93       	cmp	#0,	r13	;r3 As==00
    481c:	1f 24       	jz	$+64     	;abs 0x485c

0000481e <.Loc.327.2>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    481e:	5d 48 fe ff 	mov.b	-2(r8),	r13	;
    4822:	0d 93       	cmp	#0,	r13	;r3 As==00
    4824:	0b 20       	jnz	$+24     	;abs 0x483c

00004826 <.LBB112>:
  port_disable();
    4826:	b0 13 2a 45 	calla	#17706		;0x0452a

0000482a <.LVL49>:
  nil.dbg_panic_msg = reason;
    482a:	81 18 f2 40 	movx.a	#65536,	&0x1132e;0x10000
    482e:	00 00 2e 13 

00004832 <.L57>:
    4832:	80 00 32 48 	mova	#18482,	r0	;0x04832

00004836 <.L62>:
    4836:	c8 0c       	mova	r12,	r8	;

00004838 <.LVL51>:
    4838:	80 00 10 48 	mova	#18448,	r0	;0x04810

0000483c <.L56>:
      if (--tp->timeout == (systime_t)0) {
    483c:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    4840:	3e 53       	add	#-1,	r14	;r3 As==11
    4842:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a
    4846:	0e 93       	cmp	#0,	r14	;r3 As==00
    4848:	09 20       	jnz	$+20     	;abs 0x485c

0000484a <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    484a:	7d 90 03 00 	cmp.b	#3,	r13	;
    484e:	15 20       	jnz	$+44     	;abs 0x487a

00004850 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    4850:	0e 08       	mova	@r8,	r14	;
    4852:	9e 53 00 00 	inc	0(r14)		;

00004856 <.L60>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4856:	8d 0f ff ff 	mova	#-1,	r13	;0xffffffff
    485a:	4a 13       	calla	r10		;

0000485c <.L55>:
    chSysUnlockFromISR();
    485c:	46 13       	calla	r6		;

0000485e <.LVL54>:
    chSysLockFromISR();
    485e:	44 13       	calla	r4		;

00004860 <.LVL55>:
    4860:	cc 08       	mova	r8,	r12	;
    4862:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004866 <.Loc.349.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    4866:	a8 00 0e 00 	adda	#14,	r8	;0x0000e

0000486a <.LVL56>:
    486a:	98 01 82 13 	cmpa	#70530,	r8	;0x11382
    486e:	e3 2b       	jnc	$-56     	;abs 0x4836

00004870 <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    4870:	04 16       	popm.a	#1,	r4	;20-bit words
    4872:	06 16       	popm.a	#1,	r6	;20-bit words
    4874:	08 16       	popm.a	#1,	r8	;20-bit words
    4876:	0a 16       	popm.a	#1,	r10	;20-bit words
    4878:	10 01       	reta			;

0000487a <.L59>:
        else if (NIL_THD_IS_SUSP(tp)) {
    487a:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    487c:	ec 23       	jnz	$-38     	;abs 0x4856

0000487e <.Loc.338.2>:
          *tp->u1.trp = NULL;
    487e:	0e 08       	mova	@r8,	r14	;
    4880:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    4884:	00 00 
    4886:	80 00 56 48 	mova	#18518,	r0	;0x04856

0000488a <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    488a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000488c <.LBB118>:
  return __get_SR_register();
    488c:	0a 42       	mov	r2,	r10	;

0000488e <.LBE118>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    488e:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    4892:	06 24       	jz	$+14     	;abs 0x48a0

00004894 <.Loc.450.2>:
    if (port_is_isr_context()) {
    4894:	41 18 c2 93 	cmpx.b	#0,	&0x11396;r3 As==00
    4898:	96 13 
    489a:	05 24       	jz	$+12     	;abs 0x48a6

0000489c <.Loc.451.2>:
      chSysLockFromISR();
    489c:	b0 13 a6 45 	calla	#17830		;0x045a6

000048a0 <.L71>:
    else {
      chSysLock();
    }
  }
  return sts;
}
    48a0:	0c 4a       	mov	r10,	r12	;
    48a2:	0a 16       	popm.a	#1,	r10	;20-bit words
    48a4:	10 01       	reta			;

000048a6 <.L72>:
      chSysLock();
    48a6:	b0 13 2a 45 	calla	#17706		;0x0452a

000048aa <.LVL63>:
    48aa:	b0 13 54 45 	calla	#17748		;0x04554

000048ae <.LVL64>:
    48ae:	80 00 a0 48 	mova	#18592,	r0	;0x048a0

000048b2 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    48b2:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    48b6:	06 24       	jz	$+14     	;abs 0x48c4

000048b8 <.Loc.472.2>:
    if (port_is_isr_context()) {
    48b8:	41 18 c2 93 	cmpx.b	#0,	&0x11396;r3 As==00
    48bc:	96 13 
    48be:	03 24       	jz	$+8      	;abs 0x48c6

000048c0 <.Loc.473.2>:
      chSysUnlockFromISR();
    48c0:	b0 13 d0 45 	calla	#17872		;0x045d0

000048c4 <.L76>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    48c4:	10 01       	reta			;

000048c6 <.L78>:
      chSchRescheduleS();
    48c6:	b0 13 7e 49 	calla	#18814		;0x0497e

000048ca <.LVL68>:
      chSysUnlock();
    48ca:	b0 13 7c 45 	calla	#17788		;0x0457c

000048ce <.LVL69>:
    48ce:	b0 13 20 45 	calla	#17696		;0x04520

000048d2 <.LVL70>:
}
    48d2:	80 00 c4 48 	mova	#18628,	r0	;0x048c4

000048d6 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    48d6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000048d8 <.LCFI7>:
    48d8:	b1 00 08 00 	suba	#8,	r1	;

000048dc <.LCFI8>:
    48dc:	71 0d 04 00 	mova	r13,	4(r1)	;

000048e0 <.Loc.536.2>:

  chDbgCheckClassI();
    48e0:	71 0c 00 00 	mova	r12,	0(r1)	;
    48e4:	b0 13 54 46 	calla	#18004		;0x04654

000048e8 <.LVL72>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    48e8:	0c 01       	mova	@r1,	r12	;
    48ea:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    48ee:	08 20       	jnz	$+18     	;abs 0x4900

000048f0 <.LBB120>:
  port_disable();
    48f0:	b0 13 2a 45 	calla	#17706		;0x0452a

000048f4 <.LVL74>:
  nil.dbg_panic_msg = reason;
    48f4:	81 18 f2 40 	movx.a	#65555,	&0x1132e;0x10013
    48f8:	13 00 2e 13 

000048fc <.L84>:
    48fc:	80 00 fc 48 	mova	#18684,	r0	;0x048fc

00004900 <.L83>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    4900:	8e 01 20 13 	mova	#70432,	r14	;0x11320
    4904:	3a 0e 04 00 	mova	4(r14),	r10	;
    4908:	01 18 c2 9a 	cmpx.a	r10,	&0x11320;
    490c:	20 13 
    490e:	08 2c       	jc	$+18     	;abs 0x4920

00004910 <.LBB122>:
  port_disable();
    4910:	b0 13 2a 45 	calla	#17706		;0x0452a

00004914 <.LVL77>:
  nil.dbg_panic_msg = reason;
    4914:	81 18 f2 40 	movx.a	#65555,	&0x1132e;0x10013
    4918:	13 00 2e 13 

0000491c <.L86>:
    491c:	80 00 1c 49 	mova	#18716,	r0	;0x0491c

00004920 <.L85>:

  tp->u1.msg = msg;
    4920:	9c 41 04 00 	mov	4(r1),	6(r12)	;
    4924:	06 00 
    4926:	3f 01 04 00 	mova	4(r1),	r15	;
    492a:	0f 14       	pushm.a	#1,	r15	;20-bit words
    492c:	0d 17       	popm	#1,	r13	;16-bit words
    492e:	0d 17       	popm	#1,	r13	;16-bit words
    4930:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4934:	5f 4c 08 00 	mov.b	8(r12),	r15	;
    4938:	7f f0 f0 ff 	and.b	#-16,	r15	;#0xfff0
    493c:	4f dd       	bis.b	r13,	r15	;
    493e:	cc 4f 08 00 	mov.b	r15,	8(r12)	;

00004942 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    4942:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

00004946 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    4946:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000494a <.Loc.544.2>:
  if (tp < nil.next) {
    494a:	dc 0a       	cmpa	r10,	r12	;
    494c:	02 2c       	jc	$+6      	;abs 0x4952

0000494e <.Loc.545.2>:
    nil.next = tp;
    494e:	7e 0c 04 00 	mova	r12,	4(r14)	;

00004952 <.L87>:
  }
  return tp;
}
    4952:	a1 00 08 00 	adda	#8,	r1	;
    4956:	0a 16       	popm.a	#1,	r10	;20-bit words
    4958:	10 01       	reta			;

0000495a <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    495a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    495c:	81 18 d2 92 	cmpx.a	&0x11324,&0x11320;
    4960:	24 13 20 13 
    4964:	01 20       	jnz	$+4      	;abs 0x4968
    4966:	4c 43       	clr.b	r12		;

00004968 <.L89>:
}
    4968:	10 01       	reta			;

0000496a <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    496a:	8e 01 20 13 	mova	#70432,	r14	;0x11320
    496e:	0d 0e       	mova	@r14,	r13	;

00004970 <.LVL79>:

  nil.current = nil.next;
    4970:	3c 0e 04 00 	mova	4(r14),	r12	;
    4974:	7e 0c 00 00 	mova	r12,	0(r14)	;

00004978 <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    4978:	b0 13 82 4f 	calla	#20354		;0x04f82

0000497c <.LVL80>:
}
    497c:	10 01       	reta			;

0000497e <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    497e:	b0 13 78 46 	calla	#18040		;0x04678

00004982 <.LVL81>:

  if (chSchIsRescRequiredI()) {
    4982:	81 18 d2 92 	cmpx.a	&0x11324,&0x11320;
    4986:	24 13 20 13 
    498a:	02 24       	jz	$+6      	;abs 0x4990

0000498c <.Loc.595.2>:
    chSchDoReschedule();
    498c:	b0 13 6a 49 	calla	#18794		;0x0496a

00004990 <.L91>:
  }
}
    4990:	10 01       	reta			;

00004992 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    4992:	3a 14       	pushm.a	#4,	r10	;20-bit words

00004994 <.LCFI9>:
    4994:	49 4c       	mov.b	r12,	r9	;
    4996:	07 4d       	mov	r13,	r7	;

00004998 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    4998:	8a 01 20 13 	mova	#70432,	r10	;0x11320
    499c:	08 0a       	mova	@r10,	r8	;

0000499e <.Loc.619.2>:

  chDbgCheckClassS();
    499e:	b0 13 78 46 	calla	#18040		;0x04678

000049a2 <.LVL85>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    49a2:	98 01 82 13 	cmpa	#70530,	r8	;0x11382
    49a6:	08 20       	jnz	$+18     	;abs 0x49b8

000049a8 <.LBB124>:
  port_disable();
    49a8:	b0 13 2a 45 	calla	#17706		;0x0452a

000049ac <.LVL87>:
  nil.dbg_panic_msg = reason;
    49ac:	81 18 f2 40 	movx.a	#65567,	&0x1132e;0x1001f
    49b0:	1f 00 2e 13 

000049b4 <.L95>:
    49b4:	80 00 b4 49 	mova	#18868,	r0	;0x049b4

000049b8 <.L94>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    49b8:	c8 49 04 00 	mov.b	r9,	4(r8)	;

000049bc <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    49bc:	88 47 0a 00 	mov	r7,	10(r8)	; 0x000a

000049c0 <.LVL89>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    49c0:	cc 0a       	mova	r10,	r12	;
    49c2:	ac 00 12 00 	adda	#18,	r12	;0x00012

000049c6 <.L97>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    49c6:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    49ca:	0c 20       	jnz	$+26     	;abs 0x49e4

000049cc <.Loc.668.2>:
      nil.current = nil.next = ntp;
    49cc:	7a 0c 04 00 	mova	r12,	4(r10)	;
    49d0:	7a 0c 00 00 	mova	r12,	0(r10)	;

000049d4 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    49d4:	cd 08       	mova	r8,	r13	;
    49d6:	b0 13 82 4f 	calla	#20354		;0x04f82

000049da <.LVL91>:
      return nil.current->u1.msg;
    49da:	0c 0a       	mova	@r10,	r12	;
    49dc:	3c 0c 06 00 	mova	6(r12),	r12	;

000049e0 <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    49e0:	37 16       	popm.a	#4,	r10	;20-bit words
    49e2:	10 01       	reta			;

000049e4 <.L96>:
    ntp++;
    49e4:	ac 00 14 00 	adda	#20,	r12	;0x00014

000049e8 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    49e8:	8d 01 82 13 	mova	#70530,	r13	;0x11382
    49ec:	dd 0c       	cmpa	r12,	r13	;
    49ee:	eb 2f       	jc	$-40     	;abs 0x49c6

000049f0 <.LBB126>:
  port_disable();
    49f0:	b0 13 2a 45 	calla	#17706		;0x0452a

000049f4 <.LVL95>:
  nil.dbg_panic_msg = reason;
    49f4:	81 18 f2 40 	movx.a	#65567,	&0x1132e;0x1001f
    49f8:	1f 00 2e 13 

000049fc <.L98>:
    49fc:	80 00 fc 49 	mova	#18940,	r0	;0x049fc

00004a00 <chThdSuspendTimeoutS>:
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {

  chDbgAssert(*trp == NULL, "not NULL");
    4a00:	00 18 cc 93 	cmpx.a	#0,	0(r12)	;r3 As==00
    4a04:	00 00 
    4a06:	08 24       	jz	$+18     	;abs 0x4a18

00004a08 <.LBB128>:
  port_disable();
    4a08:	b0 13 2a 45 	calla	#17706		;0x0452a

00004a0c <.LVL98>:
  nil.dbg_panic_msg = reason;
    4a0c:	81 18 f2 40 	movx.a	#65588,	&0x1132e;0x10034
    4a10:	34 00 2e 13 

00004a14 <.L103>:
    4a14:	80 00 14 4a 	mova	#18964,	r0	;0x04a14

00004a18 <.L102>:

  *trp = nil.current;
    4a18:	8e 01 20 13 	mova	#70432,	r14	;0x11320
    4a1c:	00 18 ec 4e 	movx.a	@r14,	0(r12)	;
    4a20:	00 00 

00004a22 <.Loc.702.2>:
  nil.current->u1.trp = trp;
    4a22:	0e 0e       	mova	@r14,	r14	;
    4a24:	7e 0c 06 00 	mova	r12,	6(r14)	;

00004a28 <.Loc.703.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    4a28:	6c 43       	mov.b	#2,	r12	;r3 As==10

00004a2a <.LVL100>:
    4a2a:	b0 13 92 49 	calla	#18834		;0x04992

00004a2e <.LVL101>:
}
    4a2e:	10 01       	reta			;

00004a30 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    4a30:	ce 0c       	mova	r12,	r14	;

00004a32 <.Loc.718.2>:

  if (*trp != NULL) {
    4a32:	0c 0c       	mova	@r12,	r12	;

00004a34 <.LVL103>:
    4a34:	9c 00 00 00 	cmpa	#0,	r12	;
    4a38:	10 24       	jz	$+34     	;abs 0x4a5a

00004a3a <.LBB130>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4a3a:	ec 93 04 00 	cmp.b	#2,	4(r12)	;r3 As==10
    4a3e:	08 24       	jz	$+18     	;abs 0x4a50

00004a40 <.LBB131>:
  port_disable();
    4a40:	b0 13 2a 45 	calla	#17706		;0x0452a

00004a44 <.LVL106>:
  nil.dbg_panic_msg = reason;
    4a44:	81 18 f2 40 	movx.a	#65609,	&0x1132e;0x10049
    4a48:	49 00 2e 13 

00004a4c <.L107>:
    4a4c:	80 00 4c 4a 	mova	#19020,	r0	;0x04a4c

00004a50 <.L106>:

    *trp = NULL;
    4a50:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    4a54:	00 00 

00004a56 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    4a56:	b0 13 d6 48 	calla	#18646		;0x048d6

00004a5a <.L104>:
  }
}
    4a5a:	10 01       	reta			;

00004a5c <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    4a5c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a5e <.LCFI10>:
    4a5e:	0a 4c       	mov	r12,	r10	;

00004a60 <.Loc.737.2>:

  chSysLock();
    4a60:	b0 13 2a 45 	calla	#17706		;0x0452a

00004a64 <.LVL110>:
    4a64:	b0 13 54 45 	calla	#17748		;0x04554

00004a68 <.LVL111>:
  chThdSleepS(timeout);
    4a68:	0d 4a       	mov	r10,	r13	;
    4a6a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    4a6c:	b0 13 92 49 	calla	#18834		;0x04992

00004a70 <.LVL112>:
  chSysUnlock();
    4a70:	b0 13 7c 45 	calla	#17788		;0x0457c

00004a74 <.LVL113>:
    4a74:	b0 13 20 45 	calla	#17696		;0x04520

00004a78 <.LVL114>:
}
    4a78:	0a 16       	popm.a	#1,	r10	;20-bit words
    4a7a:	10 01       	reta			;

00004a7c <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    4a7c:	b1 00 08 00 	suba	#8,	r1	;

00004a80 <.LCFI12>:
  msg_t msg;

  chSysLock();
    4a80:	71 0c 00 00 	mova	r12,	0(r1)	;
    4a84:	71 0d 04 00 	mova	r13,	4(r1)	;
    4a88:	b0 13 2a 45 	calla	#17706		;0x0452a

00004a8c <.LVL123>:
    4a8c:	b0 13 54 45 	calla	#17748		;0x04554

00004a90 <.LVL124>:
  msg = chSemWaitTimeoutS(sp, timeout);
    4a90:	3d 01 04 00 	mova	4(r1),	r13	;
    4a94:	0c 01       	mova	@r1,	r12	;
    4a96:	b0 13 ae 4a 	calla	#19118		;0x04aae

00004a9a <.LVL125>:
  chSysUnlock();
    4a9a:	71 0c 00 00 	mova	r12,	0(r1)	;
    4a9e:	b0 13 7c 45 	calla	#17788		;0x0457c

00004aa2 <.LVL126>:
    4aa2:	b0 13 20 45 	calla	#17696		;0x04520

00004aa6 <.LVL127>:

  return msg;
}
    4aa6:	0c 01       	mova	@r1,	r12	;
    4aa8:	a1 00 08 00 	adda	#8,	r1	;
    4aac:	10 01       	reta			;

00004aae <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    4aae:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ab0 <.LCFI13>:
    4ab0:	b1 00 04 00 	suba	#4,	r1	;

00004ab4 <.LCFI14>:
    4ab4:	ca 0c       	mova	r12,	r10	;

00004ab6 <.Loc.808.2>:

  chDbgCheckClassS();
    4ab6:	71 0d 00 00 	mova	r13,	0(r1)	;
    4aba:	b0 13 78 46 	calla	#18040		;0x04678

00004abe <.LVL129>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    4abe:	2c 4a       	mov	@r10,	r12	;

00004ac0 <.LVL130>:
  if (cnt <= (cnt_t)0) {
    4ac0:	0d 01       	mova	@r1,	r13	;
    4ac2:	4e 43       	clr.b	r14		;
    4ac4:	0e 9c       	cmp	r12,	r14	;
    4ac6:	11 38       	jl	$+36     	;abs 0x4aea

00004ac8 <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    4ac8:	3d 93       	cmp	#-1,	r13	;r3 As==11
    4aca:	15 24       	jz	$+44     	;abs 0x4af6

00004acc <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    4acc:	3c 53       	add	#-1,	r12	;r3 As==11

00004ace <.LVL131>:
    4ace:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004ad2 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    4ad2:	2c 01 20 13 	mova	&70432,	r12	;0x11320

00004ad6 <.LVL132>:
    4ad6:	7c 0a 06 00 	mova	r10,	6(r12)	;

00004ada <.LVL133>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    4ada:	7c 40 03 00 	mov.b	#3,	r12	;
    4ade:	b0 13 92 49 	calla	#18834		;0x04992

00004ae2 <.L114>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    4ae2:	a1 00 04 00 	adda	#4,	r1	;
    4ae6:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ae8:	10 01       	reta			;

00004aea <.L115>:
  sp->cnt = cnt - (cnt_t)1;
    4aea:	3c 53       	add	#-1,	r12	;r3 As==11

00004aec <.LVL136>:
    4aec:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004af0 <.Loc.823.2>:
  return MSG_OK;
    4af0:	4c 43       	clr.b	r12		;

00004af2 <.LVL137>:
    4af2:	80 00 e2 4a 	mova	#19170,	r0	;0x04ae2

00004af6 <.L117>:
      return MSG_TIMEOUT;
    4af6:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004afa <.LVL139>:
    4afa:	80 00 e2 4a 	mova	#19170,	r0	;0x04ae2

00004afe <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    4afe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b00 <.LCFI16>:
    4b00:	ca 0c       	mova	r12,	r10	;

00004b02 <.Loc.854.2>:

  chDbgCheckClassI();
    4b02:	b0 13 54 46 	calla	#18004		;0x04654

00004b06 <.LVL148>:
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    4b06:	2c 4a       	mov	@r10,	r12	;
    4b08:	1c 53       	inc	r12		;
    4b0a:	8a 4c 00 00 	mov	r12,	0(r10)	;
    4b0e:	4d 43       	clr.b	r13		;
    4b10:	0d 9c       	cmp	r12,	r13	;
    4b12:	15 38       	jl	$+44     	;abs 0x4b3e
    4b14:	8c 01 32 13 	mova	#70450,	r12	;0x11332

00004b18 <.L124>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    4b18:	00 18 5a 9c 	cmpx.a	6(r12),	r10	;
    4b1c:	06 00 
    4b1e:	11 20       	jnz	$+36     	;abs 0x4b42

00004b20 <.Loc.863.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4b20:	fc 90 03 00 	cmp.b	#3,	4(r12)	;
    4b24:	04 00 
    4b26:	08 24       	jz	$+18     	;abs 0x4b38

00004b28 <.LBB144>:
  port_disable();
    4b28:	b0 13 2a 45 	calla	#17706		;0x0452a

00004b2c <.LVL151>:
  nil.dbg_panic_msg = reason;
    4b2c:	81 18 f2 40 	movx.a	#65622,	&0x1132e;0x10056
    4b30:	56 00 2e 13 

00004b34 <.L123>:
    4b34:	80 00 34 4b 	mova	#19252,	r0	;0x04b34

00004b38 <.L122>:

        (void) chSchReadyI(tr, MSG_OK);
    4b38:	4d 43       	clr.b	r13		;
    4b3a:	b0 13 d6 48 	calla	#18646		;0x048d6

00004b3e <.L119>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4b3e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b40:	10 01       	reta			;

00004b42 <.L121>:
      tr++;
    4b42:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004b46 <.Loc.870.2>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    4b46:	9c 01 82 13 	cmpa	#70530,	r12	;0x11382
    4b4a:	e6 2b       	jnc	$-50     	;abs 0x4b18

00004b4c <.LBB146>:
  port_disable();
    4b4c:	b0 13 2a 45 	calla	#17706		;0x0452a

00004b50 <.LVL157>:
  nil.dbg_panic_msg = reason;
    4b50:	81 18 f2 40 	movx.a	#65622,	&0x1132e;0x10056
    4b54:	56 00 2e 13 

00004b58 <.L125>:
    4b58:	80 00 58 4b 	mova	#19288,	r0	;0x04b58

00004b5c <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    4b5c:	19 14       	pushm.a	#2,	r9	;20-bit words

00004b5e <.LCFI20>:
    4b5e:	b1 00 04 00 	suba	#4,	r1	;

00004b62 <.LCFI21>:
    4b62:	08 4d       	mov	r13,	r8	;
    4b64:	09 4e       	mov	r14,	r9	;

00004b66 <.Loc.951.2>:

  chSysLock();
    4b66:	71 0c 00 00 	mova	r12,	0(r1)	;
    4b6a:	b0 13 2a 45 	calla	#17706		;0x0452a

00004b6e <.LVL182>:
    4b6e:	b0 13 54 45 	calla	#17748		;0x04554

00004b72 <.LVL183>:
  chEvtSignalI(tp, mask);
    4b72:	0d 48       	mov	r8,	r13	;
    4b74:	0e 49       	mov	r9,	r14	;
    4b76:	0c 01       	mova	@r1,	r12	;
    4b78:	b0 13 90 4b 	calla	#19344		;0x04b90

00004b7c <.LVL184>:
  chSchRescheduleS();
    4b7c:	b0 13 7e 49 	calla	#18814		;0x0497e

00004b80 <.LVL185>:
  chSysUnlock();
    4b80:	b0 13 7c 45 	calla	#17788		;0x0457c

00004b84 <.LVL186>:
    4b84:	b0 13 20 45 	calla	#17696		;0x04520

00004b88 <.LVL187>:
}
    4b88:	a1 00 04 00 	adda	#4,	r1	;
    4b8c:	18 16       	popm.a	#2,	r9	;20-bit words
    4b8e:	10 01       	reta			;

00004b90 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    4b90:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004b92 <.LCFI22>:
    4b92:	b1 00 04 00 	suba	#4,	r1	;

00004b96 <.LCFI23>:
    4b96:	0a 4d       	mov	r13,	r10	;
    4b98:	09 4e       	mov	r14,	r9	;

00004b9a <.Loc.971.2>:

  chDbgCheckClassI();
    4b9a:	71 0c 00 00 	mova	r12,	0(r1)	;
    4b9e:	b0 13 54 46 	calla	#18004		;0x04654

00004ba2 <.LVL189>:
  chDbgCheck(tp != NULL);

  tp->epmask |= mask;
    4ba2:	0c 01       	mova	@r1,	r12	;
    4ba4:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    4ba8:	0d da       	bis	r10,	r13	;
    4baa:	1e 4c 0e 00 	mov	14(r12),r14	;0x0000e
    4bae:	0e d9       	bis	r9,	r14	;
    4bb0:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
    4bb4:	8c 4e 0e 00 	mov	r14,	14(r12)	; 0x000e

00004bb8 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4bb8:	ec 92 04 00 	cmp.b	#4,	4(r12)	;r2 As==10
    4bbc:	0a 20       	jnz	$+22     	;abs 0x4bd2

00004bbe <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4bbe:	1d fc 06 00 	and	6(r12),	r13	;
    4bc2:	1e fc 08 00 	and	8(r12),	r14	;

00004bc6 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4bc6:	0d de       	bis	r14,	r13	;
    4bc8:	0d 93       	cmp	#0,	r13	;r3 As==00
    4bca:	03 24       	jz	$+8      	;abs 0x4bd2

00004bcc <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    4bcc:	4d 43       	clr.b	r13		;
    4bce:	b0 13 d6 48 	calla	#18646		;0x048d6

00004bd2 <.L137>:
  }
}
    4bd2:	a1 00 04 00 	adda	#4,	r1	;
    4bd6:	19 16       	popm.a	#2,	r10	;20-bit words
    4bd8:	10 01       	reta			;

00004bda <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    4bda:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004bdc <.LCFI24>:
    4bdc:	b1 00 04 00 	suba	#4,	r1	;

00004be0 <.LCFI25>:
    4be0:	06 4c       	mov	r12,	r6	;
    4be2:	07 4d       	mov	r13,	r7	;
    4be4:	0d 4e       	mov	r14,	r13	;

00004be6 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    4be6:	2a 01 20 13 	mova	&70432,	r10	;0x11320

00004bea <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    4bea:	71 0d 00 00 	mova	r13,	0(r1)	;
    4bee:	b0 13 2a 45 	calla	#17706		;0x0452a

00004bf2 <.LVL193>:
    4bf2:	b0 13 54 45 	calla	#17748		;0x04554

00004bf6 <.LVL194>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    4bf6:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    4bfa:	08 f6       	and	r6,	r8	;
    4bfc:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4c00:	09 f7       	and	r7,	r9	;

00004c02 <.LVL195>:
    4c02:	0c 48       	mov	r8,	r12	;
    4c04:	0c d9       	bis	r9,	r12	;
    4c06:	84 00 7c 45 	mova	#17788,	r4	;0x0457c
    4c0a:	85 00 20 45 	mova	#17696,	r5	;0x04520
    4c0e:	0d 01       	mova	@r1,	r13	;
    4c10:	0c 93       	cmp	#0,	r12	;r3 As==00
    4c12:	1a 20       	jnz	$+54     	;abs 0x4c48

00004c14 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4c14:	3d 93       	cmp	#-1,	r13	;r3 As==11
    4c16:	08 20       	jnz	$+18     	;abs 0x4c28

00004c18 <.L148>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    4c18:	44 13       	calla	r4		;

00004c1a <.LVL197>:
    4c1a:	45 13       	calla	r5		;

00004c1c <.LVL198>:

  return m;
}
    4c1c:	0c 48       	mov	r8,	r12	;
    4c1e:	0d 49       	mov	r9,	r13	;
    4c20:	a1 00 04 00 	adda	#4,	r1	;
    4c24:	64 16       	popm.a	#7,	r10	;20-bit words
    4c26:	10 01       	reta			;

00004c28 <.L145>:
    ctp->u1.ewmask = mask;
    4c28:	8a 46 06 00 	mov	r6,	6(r10)	;
    4c2c:	8a 47 08 00 	mov	r7,	8(r10)	;

00004c30 <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4c30:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4c32:	b0 13 92 49 	calla	#18834		;0x04992

00004c36 <.LVL200>:
    4c36:	9c 00 00 00 	cmpa	#0,	r12	;
    4c3a:	ee 3b       	jl	$-34     	;abs 0x4c18

00004c3c <.Loc.1016.2>:
    m = ctp->epmask & mask;
    4c3c:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

00004c40 <.LVL201>:
    4c40:	08 f6       	and	r6,	r8	;
    4c42:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4c46:	09 f7       	and	r7,	r9	;

00004c48 <.L144>:
  ctp->epmask &= ~m;
    4c48:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    4c4c:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e
    4c50:	80 00 18 4c 	mova	#19480,	r0	;0x04c18

00004c54 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4c54:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c56 <.LCFI5>:
    4c56:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c58 <.LCFI6>:
    4c58:	06 14       	pushm.a	#1,	r6	;20-bit words

00004c5a <.LCFI7>:
    4c5a:	ca 0c       	mova	r12,	r10	;
    4c5c:	c6 0d       	mova	r13,	r6	;
    4c5e:	08 4e       	mov	r14,	r8	;

00004c60 <.Loc.187.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4c60:	b0 13 78 46 	calla	#18040		;0x04678

00004c64 <.LVL11>:
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4c64:	0d 48       	mov	r8,	r13	;
    4c66:	cc 0a       	mova	r10,	r12	;
    4c68:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4c6c:	b0 13 ae 4a 	calla	#19118		;0x04aae

00004c70 <.LVL12>:
    4c70:	c8 0c       	mova	r12,	r8	;

00004c72 <.LVL13>:
  if (rdymsg == MSG_OK) {
    4c72:	9c 00 00 00 	cmpa	#0,	r12	;
    4c76:	17 20       	jnz	$+48     	;abs 0x4ca6

00004c78 <.LBB12>:
    *mbp->wrptr++ = msg;
    4c78:	3e 0a 08 00 	mova	8(r10),	r14	;
    4c7c:	cc 0e       	mova	r14,	r12	;
    4c7e:	ac 00 04 00 	adda	#4,	r12	;
    4c82:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4c86:	7e 06 00 00 	mova	r6,	0(r14)	;

00004c8a <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4c8a:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4c8e:	04 00 
    4c90:	03 28       	jnc	$+8      	;abs 0x4c98

00004c92 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4c92:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4c96:	08 00 

00004c98 <.L6>:
    }
    chSemSignalI(&mbp->fullsem);
    4c98:	cc 0a       	mova	r10,	r12	;
    4c9a:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4c9e:	b0 13 fe 4a 	calla	#19198		;0x04afe

00004ca2 <.LVL15>:
    chSchRescheduleS();
    4ca2:	b0 13 7e 49 	calla	#18814		;0x0497e

00004ca6 <.L4>:
  }

  return rdymsg;
}
    4ca6:	cc 08       	mova	r8,	r12	;
    4ca8:	06 16       	popm.a	#1,	r6	;20-bit words
    4caa:	08 16       	popm.a	#1,	r8	;20-bit words
    4cac:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cae:	10 01       	reta			;

00004cb0 <chMBPost>:
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4cb0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cb2 <.LCFI8>:
    4cb2:	b1 00 08 00 	suba	#8,	r1	;

00004cb6 <.LCFI9>:
    4cb6:	ca 0d       	mova	r13,	r10	;

00004cb8 <.LBB18>:
  _disable_interrupts();
    4cb8:	32 c2       	dint			
    4cba:	03 43       	nop			

00004cbc <.Loc.348.2>:
  asm volatile("nop");
    4cbc:	03 43       	nop			

00004cbe <.LBE18>:
  chSysLock();
    4cbe:	71 0c 00 00 	mova	r12,	0(r1)	;
    4cc2:	71 0e 04 00 	mova	r14,	4(r1)	;
    4cc6:	b0 13 54 45 	calla	#17748		;0x04554

00004cca <.LVL18>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4cca:	3e 01 04 00 	mova	4(r1),	r14	;
    4cce:	cd 0a       	mova	r10,	r13	;
    4cd0:	0c 01       	mova	@r1,	r12	;
    4cd2:	b0 13 54 4c 	calla	#19540		;0x04c54

00004cd6 <.LVL19>:
  chSysUnlock();
    4cd6:	71 0c 00 00 	mova	r12,	0(r1)	;
    4cda:	b0 13 7c 45 	calla	#17788		;0x0457c

00004cde <.LBB20>:
  asm volatile("nop");
    4cde:	03 43       	nop			

00004ce0 <.Loc.356.2>:
  _enable_interrupts();
    4ce0:	03 43       	nop			
    4ce2:	32 d2       	eint			
    4ce4:	03 43       	nop			

00004ce6 <.LBE20>:
}
    4ce6:	0c 01       	mova	@r1,	r12	;
    4ce8:	a1 00 08 00 	adda	#8,	r1	;
    4cec:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cee:	10 01       	reta			;

00004cf0 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4cf0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cf2 <.LCFI10>:
    4cf2:	08 14       	pushm.a	#1,	r8	;20-bit words

00004cf4 <.LCFI11>:
    4cf4:	ca 0c       	mova	r12,	r10	;
    4cf6:	c8 0d       	mova	r13,	r8	;

00004cf8 <.Loc.219.1>:

  chDbgCheckClassI();
    4cf8:	b0 13 54 46 	calla	#18004		;0x04654

00004cfc <.LVL22>:
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    4cfc:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    4d00:	4d 43       	clr.b	r13		;
    4d02:	0d 9c       	cmp	r12,	r13	;
    4d04:	1b 34       	jge	$+56     	;abs 0x4d3c

00004d06 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4d06:	ba 53 12 00 	add	#-1,	18(r10)	;r3 As==11, 0x0012

00004d0a <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4d0a:	3e 0a 08 00 	mova	8(r10),	r14	;
    4d0e:	cc 0e       	mova	r14,	r12	;
    4d10:	ac 00 04 00 	adda	#4,	r12	;
    4d14:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4d18:	7e 08 00 00 	mova	r8,	0(r14)	;

00004d1c <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4d1c:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4d20:	04 00 
    4d22:	03 28       	jnc	$+8      	;abs 0x4d2a

00004d24 <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4d24:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4d28:	08 00 

00004d2a <.L10>:
  }
  chSemSignalI(&mbp->fullsem);
    4d2a:	cc 0a       	mova	r10,	r12	;
    4d2c:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4d30:	b0 13 fe 4a 	calla	#19198		;0x04afe

00004d34 <.LVL23>:

  return MSG_OK;
    4d34:	4c 43       	clr.b	r12		;

00004d36 <.L8>:
}
    4d36:	08 16       	popm.a	#1,	r8	;20-bit words
    4d38:	0a 16       	popm.a	#1,	r10	;20-bit words
    4d3a:	10 01       	reta			;

00004d3c <.L11>:
    return MSG_TIMEOUT;
    4d3c:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    4d40:	80 00 36 4d 	mova	#19766,	r0	;0x04d36

00004d44 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4d44:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d46 <.LCFI19>:
    4d46:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d48 <.LCFI20>:
    4d48:	06 14       	pushm.a	#1,	r6	;20-bit words

00004d4a <.LCFI21>:
    4d4a:	ca 0c       	mova	r12,	r10	;
    4d4c:	c8 0d       	mova	r13,	r8	;
    4d4e:	06 4e       	mov	r14,	r6	;

00004d50 <.Loc.386.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4d50:	b0 13 78 46 	calla	#18040		;0x04678

00004d54 <.LVL39>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4d54:	0d 46       	mov	r6,	r13	;
    4d56:	cc 0a       	mova	r10,	r12	;
    4d58:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4d5c:	b0 13 ae 4a 	calla	#19118		;0x04aae

00004d60 <.LVL40>:
    4d60:	c6 0c       	mova	r12,	r6	;

00004d62 <.LVL41>:
  if (rdymsg == MSG_OK) {
    4d62:	9c 00 00 00 	cmpa	#0,	r12	;
    4d66:	18 20       	jnz	$+50     	;abs 0x4d98

00004d68 <.LBB36>:
    *msgp = *mbp->rdptr++;
    4d68:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4d6c:	ce 0c       	mova	r12,	r14	;
    4d6e:	ae 00 04 00 	adda	#4,	r14	;
    4d72:	7a 0e 0c 00 	mova	r14,	12(r10)	; 0x0000c
    4d76:	00 18 e8 4c 	movx.a	@r12,	0(r8)	;
    4d7a:	00 00 

00004d7c <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4d7c:	00 18 5e 9a 	cmpx.a	4(r10),	r14	;
    4d80:	04 00 
    4d82:	03 28       	jnc	$+8      	;abs 0x4d8a

00004d84 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4d84:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4d88:	0c 00 

00004d8a <.L22>:
    }
    chSemSignalI(&mbp->emptysem);
    4d8a:	cc 0a       	mova	r10,	r12	;
    4d8c:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4d90:	b0 13 fe 4a 	calla	#19198		;0x04afe

00004d94 <.LVL43>:
    chSchRescheduleS();
    4d94:	b0 13 7e 49 	calla	#18814		;0x0497e

00004d98 <.L20>:
  }

  return rdymsg;
}
    4d98:	cc 06       	mova	r6,	r12	;
    4d9a:	06 16       	popm.a	#1,	r6	;20-bit words
    4d9c:	08 16       	popm.a	#1,	r8	;20-bit words
    4d9e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4da0:	10 01       	reta			;

00004da2 <chMBFetch>:
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4da2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004da4 <.LCFI22>:
    4da4:	b1 00 08 00 	suba	#8,	r1	;

00004da8 <.LCFI23>:
    4da8:	ca 0d       	mova	r13,	r10	;

00004daa <.LBB42>:
  _disable_interrupts();
    4daa:	32 c2       	dint			
    4dac:	03 43       	nop			

00004dae <.Loc.348.2>:
  asm volatile("nop");
    4dae:	03 43       	nop			

00004db0 <.LBE42>:
  chSysLock();
    4db0:	71 0c 00 00 	mova	r12,	0(r1)	;
    4db4:	71 0e 04 00 	mova	r14,	4(r1)	;
    4db8:	b0 13 54 45 	calla	#17748		;0x04554

00004dbc <.LVL46>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4dbc:	3e 01 04 00 	mova	4(r1),	r14	;
    4dc0:	cd 0a       	mova	r10,	r13	;
    4dc2:	0c 01       	mova	@r1,	r12	;
    4dc4:	b0 13 44 4d 	calla	#19780		;0x04d44

00004dc8 <.LVL47>:
  chSysUnlock();
    4dc8:	71 0c 00 00 	mova	r12,	0(r1)	;
    4dcc:	b0 13 7c 45 	calla	#17788		;0x0457c

00004dd0 <.LBB44>:
  asm volatile("nop");
    4dd0:	03 43       	nop			

00004dd2 <.Loc.356.2>:
  _enable_interrupts();
    4dd2:	03 43       	nop			
    4dd4:	32 d2       	eint			
    4dd6:	03 43       	nop			

00004dd8 <.LBE44>:
}
    4dd8:	0c 01       	mova	@r1,	r12	;
    4dda:	a1 00 08 00 	adda	#8,	r1	;
    4dde:	0a 16       	popm.a	#1,	r10	;20-bit words
    4de0:	10 01       	reta			;

00004de2 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4de2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004de4 <.LCFI1>:
    4de4:	ca 0c       	mova	r12,	r10	;

00004de6 <.Loc.124.1>:
  void *objp;

  chDbgCheckClassI();
    4de6:	b0 13 54 46 	calla	#18004		;0x04654

00004dea <.LVL4>:
  chDbgCheck(mp != NULL);

  objp = mp->next;
    4dea:	0c 0a       	mova	@r10,	r12	;

00004dec <.LVL5>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4dec:	9c 00 00 00 	cmpa	#0,	r12	;
    4df0:	05 24       	jz	$+12     	;abs 0x4dfc

00004df2 <.Loc.130.1>:
    mp->next = mp->next->next;
    4df2:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4df6:	00 00 

00004df8 <.L2>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4df8:	0a 16       	popm.a	#1,	r10	;20-bit words
    4dfa:	10 01       	reta			;

00004dfc <.L3>:
  else if (mp->provider != NULL) {
    4dfc:	3e 0a 08 00 	mova	8(r10),	r14	;
    4e00:	9e 00 00 00 	cmpa	#0,	r14	;
    4e04:	f9 27       	jz	$-12     	;abs 0x4df8

00004e06 <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4e06:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4e08:	3c 0a 04 00 	mova	4(r10),	r12	;

00004e0c <.LVL6>:
    4e0c:	4e 13       	calla	r14		;

00004e0e <.LVL7>:
  return objp;
    4e0e:	80 00 f8 4d 	mova	#19960,	r0	;0x04df8

00004e12 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
    4e12:	b1 00 04 00 	suba	#4,	r1	;

00004e16 <.LBB16>:
  _disable_interrupts();
    4e16:	32 c2       	dint			
    4e18:	03 43       	nop			

00004e1a <.Loc.348.2>:
  asm volatile("nop");
    4e1a:	03 43       	nop			

00004e1c <.LBE16>:
  void *objp;

  chSysLock();
    4e1c:	71 0c 00 00 	mova	r12,	0(r1)	;
    4e20:	b0 13 54 45 	calla	#17748		;0x04554

00004e24 <.LVL9>:
  objp = chPoolAllocI(mp);
    4e24:	0c 01       	mova	@r1,	r12	;
    4e26:	b0 13 e2 4d 	calla	#19938		;0x04de2

00004e2a <.LVL10>:
  chSysUnlock();
    4e2a:	71 0c 00 00 	mova	r12,	0(r1)	;
    4e2e:	b0 13 7c 45 	calla	#17788		;0x0457c

00004e32 <.LBB18>:
  asm volatile("nop");
    4e32:	03 43       	nop			

00004e34 <.Loc.356.2>:
  _enable_interrupts();
    4e34:	03 43       	nop			
    4e36:	32 d2       	eint			
    4e38:	03 43       	nop			

00004e3a <.LBE18>:

  return objp;
}
    4e3a:	0c 01       	mova	@r1,	r12	;
    4e3c:	a1 00 04 00 	adda	#4,	r1	;
    4e40:	10 01       	reta			;

00004e42 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4e42:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e44 <.LCFI3>:
    4e44:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e46 <.LCFI4>:
    4e46:	ca 0c       	mova	r12,	r10	;
    4e48:	c8 0d       	mova	r13,	r8	;

00004e4a <.LVL13>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
    4e4a:	b0 13 54 46 	calla	#18004		;0x04654

00004e4e <.LVL14>:
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
    4e4e:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4e52:	00 00 

00004e54 <.Loc.179.1>:
  mp->next = php;
    4e54:	7a 08 00 00 	mova	r8,	0(r10)	;

00004e58 <.Loc.180.1>:
}
    4e58:	08 16       	popm.a	#1,	r8	;20-bit words
    4e5a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e5c:	10 01       	reta			;

00004e5e <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    4e5e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e60 <.LCFI5>:
    4e60:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e62 <.LCFI6>:
    4e62:	ca 0c       	mova	r12,	r10	;
    4e64:	c8 0d       	mova	r13,	r8	;

00004e66 <.LBB26>:
  _disable_interrupts();
    4e66:	32 c2       	dint			
    4e68:	03 43       	nop			

00004e6a <.Loc.348.2>:
  asm volatile("nop");
    4e6a:	03 43       	nop			

00004e6c <.LBE26>:

  chSysLock();
    4e6c:	b0 13 54 45 	calla	#17748		;0x04554

00004e70 <.LBB28>:
  chDbgCheckClassI();
    4e70:	b0 13 54 46 	calla	#18004		;0x04654

00004e74 <.LVL17>:
  php->next = mp->next;
    4e74:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4e78:	00 00 

00004e7a <.Loc.179.1>:
  mp->next = php;
    4e7a:	7a 08 00 00 	mova	r8,	0(r10)	;

00004e7e <.LBE28>:
  chPoolFreeI(mp, objp);
  chSysUnlock();
    4e7e:	b0 13 7c 45 	calla	#17788		;0x0457c

00004e82 <.LBB30>:
  asm volatile("nop");
    4e82:	03 43       	nop			

00004e84 <.Loc.356.2>:
  _enable_interrupts();
    4e84:	03 43       	nop			
    4e86:	32 d2       	eint			
    4e88:	03 43       	nop			

00004e8a <.LBE30>:
}
    4e8a:	08 16       	popm.a	#1,	r8	;20-bit words
    4e8c:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e8e:	10 01       	reta			;

00004e90 <chGuardedPoolObjectInit>:
 *                      memory pool, the minimum accepted size is the size
 *                      of a pointer to void.
 *
 * @init
 */
void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp, size_t size) {
    4e90:	b1 00 04 00 	suba	#4,	r1	;

00004e94 <.LCFI11>:
    4e94:	71 0d 00 00 	mova	r13,	0(r1)	;

00004e98 <.LBB36>:
  mp->next = NULL;
    4e98:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4e9c:	02 00 

00004e9e <.Loc.81.1>:
  mp->object_size = size;
    4e9e:	ac 41 06 00 	mov	@r1,	6(r12)	;
    4ea2:	0d 14       	pushm.a	#1,	r13	;20-bit words
    4ea4:	0d 17       	popm	#1,	r13	;16-bit words
    4ea6:	0d 17       	popm	#1,	r13	;16-bit words

00004ea8 <.LVL28>:
    4ea8:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4eac:	5e 4c 08 00 	mov.b	8(r12),	r14	;
    4eb0:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4eb4:	4e dd       	bis.b	r13,	r14	;
    4eb6:	cc 4e 08 00 	mov.b	r14,	8(r12)	;

00004eba <.Loc.82.1>:
  mp->provider = provider;
    4eba:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    4ebe:	0a 00 

00004ec0 <.LBE36>:

  chPoolObjectInit(&gmp->pool, size, NULL);
  chSemObjectInit(&gmp->sem, (cnt_t)0);
    4ec0:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00004ec4 <.Loc.216.1>:
}
    4ec4:	a1 00 04 00 	adda	#4,	r1	;

00004ec8 <.LVL30>:
    4ec8:	10 01       	reta			;

00004eca <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
    4eca:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ecc <.LCFI12>:
    4ecc:	ca 0c       	mova	r12,	r10	;

00004ece <.Loc.263.1>:
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
    4ece:	b0 13 ae 4a 	calla	#19118		;0x04aae

00004ed2 <.LVL32>:
  if (msg != MSG_OK) {
    4ed2:	9c 00 00 00 	cmpa	#0,	r12	;
    4ed6:	07 20       	jnz	$+16     	;abs 0x4ee6

00004ed8 <.Loc.268.1>:
    return NULL;
  }

  return chPoolAllocI(&gmp->pool);
    4ed8:	cc 0a       	mova	r10,	r12	;

00004eda <.LVL33>:
    4eda:	ac 00 02 00 	adda	#2,	r12	;
    4ede:	b0 13 e2 4d 	calla	#19938		;0x04de2

00004ee2 <.L14>:
}
    4ee2:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ee4:	10 01       	reta			;

00004ee6 <.L16>:
    return NULL;
    4ee6:	4c 43       	clr.b	r12		;

00004ee8 <.LVL36>:
    4ee8:	80 00 e2 4e 	mova	#20194,	r0	;0x04ee2

00004eec <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
    4eec:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004eee <.LCFI14>:
    4eee:	b1 00 04 00 	suba	#4,	r1	;

00004ef2 <.LCFI15>:
    4ef2:	ca 0d       	mova	r13,	r10	;

00004ef4 <.LBB46>:
  chDbgCheckClassI();
    4ef4:	71 0c 00 00 	mova	r12,	0(r1)	;
    4ef8:	b0 13 54 46 	calla	#18004		;0x04654

00004efc <.LVL43>:
  php->next = mp->next;
    4efc:	0c 01       	mova	@r1,	r12	;
    4efe:	00 18 da 4c 	movx.a	2(r12),	0(r10)	;
    4f02:	02 00 00 00 

00004f06 <.Loc.179.1>:
  mp->next = php;
    4f06:	7c 0a 02 00 	mova	r10,	2(r12)	;

00004f0a <.LBE46>:

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
    4f0a:	b0 13 fe 4a 	calla	#19198		;0x04afe

00004f0e <.LVL45>:
}
    4f0e:	a1 00 04 00 	adda	#4,	r1	;
    4f12:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f14:	10 01       	reta			;

00004f16 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
    4f16:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f18 <.LCFI16>:
    4f18:	b1 00 04 00 	suba	#4,	r1	;

00004f1c <.LCFI17>:
    4f1c:	ca 0d       	mova	r13,	r10	;

00004f1e <.LBB52>:
  _disable_interrupts();
    4f1e:	32 c2       	dint			
    4f20:	03 43       	nop			

00004f22 <.Loc.348.2>:
  asm volatile("nop");
    4f22:	03 43       	nop			

00004f24 <.LBE52>:

  chSysLock();
    4f24:	71 0c 00 00 	mova	r12,	0(r1)	;
    4f28:	b0 13 54 45 	calla	#17748		;0x04554

00004f2c <.LVL47>:
  chGuardedPoolFreeI(gmp, objp);
    4f2c:	cd 0a       	mova	r10,	r13	;
    4f2e:	0c 01       	mova	@r1,	r12	;
    4f30:	b0 13 ec 4e 	calla	#20204		;0x04eec

00004f34 <.LVL48>:
  chSchRescheduleS();
    4f34:	b0 13 7e 49 	calla	#18814		;0x0497e

00004f38 <.LVL49>:
  chSysUnlock();
    4f38:	b0 13 7c 45 	calla	#17788		;0x0457c

00004f3c <.LBB54>:
  asm volatile("nop");
    4f3c:	03 43       	nop			

00004f3e <.Loc.356.2>:
  _enable_interrupts();
    4f3e:	03 43       	nop			
    4f40:	32 d2       	eint			
    4f42:	03 43       	nop			

00004f44 <.LBE54>:
}
    4f44:	a1 00 04 00 	adda	#4,	r1	;
    4f48:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f4a:	10 01       	reta			;

00004f4c <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
    4f4c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f4e <.LCFI18>:
    4f4e:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f50 <.LCFI19>:
    4f50:	06 14       	pushm.a	#1,	r6	;20-bit words

00004f52 <.LCFI20>:
    4f52:	04 14       	pushm.a	#1,	r4	;20-bit words

00004f54 <.LCFI21>:
    4f54:	ca 0c       	mova	r12,	r10	;
    4f56:	c6 0d       	mova	r13,	r6	;
    4f58:	c4 0e       	mova	r14,	r4	;

00004f5a <.LBB56>:
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
    4f5a:	88 00 16 4f 	mova	#20246,	r8	;0x04f16

00004f5e <.L21>:
  while (n != 0U) {
    4f5e:	94 00 00 00 	cmpa	#0,	r4	;
    4f62:	05 20       	jnz	$+12     	;abs 0x4f6e

00004f64 <.Loc.242.1>:
}
    4f64:	04 16       	popm.a	#1,	r4	;20-bit words
    4f66:	06 16       	popm.a	#1,	r6	;20-bit words
    4f68:	08 16       	popm.a	#1,	r8	;20-bit words
    4f6a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f6c:	10 01       	reta			;

00004f6e <.L22>:
    4f6e:	cd 06       	mova	r6,	r13	;
    4f70:	cc 0a       	mova	r10,	r12	;
    4f72:	48 13       	calla	r8		;

00004f74 <.LBE59>:
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
    4f74:	00 18 56 5a 	addx.a	6(r10),	r6	;
    4f78:	06 00 

00004f7a <.Loc.240.1>:
    n--;
    4f7a:	a4 0f ff ff 	adda	#1048575,r4	;0xfffff
    4f7e:	80 00 5e 4f 	mova	#20318,	r0	;0x04f5e

00004f82 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4f82:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004f84 <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4f84:	7d 01 00 00 	mova	r1,	0(r13)	;

00004f88 <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4f88:	01 0c       	mova	@r12,	r1	;

00004f8a <.Loc.76.1>:
  asm volatile ("popm.a #7, R10");
    4f8a:	64 16       	popm.a	#7,	r10	;20-bit words

00004f8c <.Loc.77.1>:
  asm volatile ("reta");
    4f8c:	10 01       	reta			;

00004f8e <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    4f8e:	b0 13 7c 45 	calla	#17788		;0x0457c

00004f92 <.LBB4>:
  asm volatile("nop");
    4f92:	03 43       	nop			

00004f94 <.Loc.356.2>:
  _enable_interrupts();
    4f94:	03 43       	nop			
    4f96:	32 d2       	eint			
    4f98:	03 43       	nop			

00004f9a <.LBE4>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4f9a:	cc 05       	mova	r5,	r12	;

00004f9c <.Loc.98.1>:
  asm volatile ("calla R4");
    4f9c:	44 13       	calla	r4		;

00004f9e <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4f9e:	4c 43       	clr.b	r12		;
    4fa0:	b0 13 dc 47 	calla	#18396		;0x047dc

00004fa4 <.LVL2>:
#endif
}
    4fa4:	10 01       	reta			;

00004fa6 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4fa6:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004fa8 <.LCFI0>:
    4fa8:	06 14       	pushm.a	#1,	r6	;20-bit words

00004faa <.LCFI1>:
    4faa:	04 14       	pushm.a	#1,	r4	;20-bit words

00004fac <.LCFI2>:
    4fac:	c6 0c       	mova	r12,	r6	;
    4fae:	c4 0d       	mova	r13,	r4	;

00004fb0 <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4fb0:	2c 4c       	mov	@r12,	r12	;

00004fb2 <.LVL2>:
    4fb2:	0c 93       	cmp	#0,	r12	;r3 As==00
    4fb4:	18 34       	jge	$+50     	;abs 0x4fe6
    4fb6:	8a 01 32 13 	mova	#70450,	r10	;0x11332

00004fba <.LBB2>:
        (void) chSchReadyI(tp, msg);
        return;
      }
      tp++;

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4fba:	88 00 dc 47 	mova	#18396,	r8	;0x047dc
    4fbe:	89 01 85 00 	mova	#65669,	r9	;0x10085

00004fc2 <.L3>:
      if (tp->u1.semp == sp) {
    4fc2:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    4fc6:	06 00 
    4fc8:	12 20       	jnz	$+38     	;abs 0x4fee

00004fca <.Loc.67.1>:
        sp->cnt++;
    4fca:	96 53 00 00 	inc	0(r6)		;

00004fce <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4fce:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    4fd2:	04 00 
    4fd4:	04 24       	jz	$+10     	;abs 0x4fde

00004fd6 <.Loc.69.1>:
    4fd6:	8c 01 85 00 	mova	#65669,	r12	;0x10085
    4fda:	b0 13 dc 47 	calla	#18396		;0x047dc

00004fde <.L5>:
        (void) chSchReadyI(tp, msg);
    4fde:	cd 04       	mova	r4,	r13	;
    4fe0:	cc 0a       	mova	r10,	r12	;
    4fe2:	b0 13 d6 48 	calla	#18646		;0x048d6

00004fe6 <.L1>:
                  "pointer out of range");
    }
  }
}
    4fe6:	04 16       	popm.a	#1,	r4	;20-bit words
    4fe8:	06 16       	popm.a	#1,	r6	;20-bit words
    4fea:	28 16       	popm.a	#3,	r10	;20-bit words
    4fec:	10 01       	reta			;

00004fee <.L4>:
      tp++;
    4fee:	aa 00 14 00 	adda	#20,	r10	;0x00014

00004ff2 <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4ff2:	9a 01 82 13 	cmpa	#70530,	r10	;0x11382
    4ff6:	e5 2b       	jnc	$-52     	;abs 0x4fc2

00004ff8 <.Loc.76.1>:
    4ff8:	cc 09       	mova	r9,	r12	;
    4ffa:	48 13       	calla	r8		;

00004ffc <.LVL8>:
    4ffc:	80 00 c2 4f 	mova	#20418,	r0	;0x04fc2

00005000 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    5000:	b0 13 1a 53 	calla	#21274		;0x0531a

00005004 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    5004:	8c 01 28 04 	mova	#66600,	r12	;0x10428
    5008:	b0 13 8a 53 	calla	#21386		;0x0538a

0000500c <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    500c:	b0 13 46 50 	calla	#20550		;0x05046

00005010 <.LVL2>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    5010:	b0 13 fa 50 	calla	#20730		;0x050fa

00005014 <.LVL3>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    5014:	b0 13 64 51 	calla	#20836		;0x05164

00005018 <.LVL4>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    5018:	b0 13 06 52 	calla	#20998		;0x05206

0000501c <.LVL5>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    501c:	b0 13 7c 67 	calla	#26492		;0x0677c

00005020 <.LVL6>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    5020:	b0 13 26 50 	calla	#20518		;0x05026

00005024 <.LVL7>:
#endif
}
    5024:	10 01       	reta			;

00005026 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    5026:	b0 13 6a 53 	calla	#21354		;0x0536a

0000502a <.LVL0>:
}
    502a:	10 01       	reta			;

0000502c <osalSysLock>:
  _disable_interrupts();
    502c:	32 c2       	dint			
    502e:	03 43       	nop			

00005030 <.Loc.348.2>:
  asm volatile("nop");
    5030:	03 43       	nop			

00005032 <.LBE4>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    5032:	b0 13 54 45 	calla	#17748		;0x04554

00005036 <.LVL0>:
}
    5036:	10 01       	reta			;

00005038 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    5038:	b0 13 7c 45 	calla	#17788		;0x0457c

0000503c <.LBB8>:
  asm volatile("nop");
    503c:	03 43       	nop			

0000503e <.Loc.356.2>:
  _enable_interrupts();
    503e:	03 43       	nop			
    5040:	32 d2       	eint			
    5042:	03 43       	nop			

00005044 <.LBE8>:
}
    5044:	10 01       	reta			;

00005046 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    5046:	b0 13 74 66 	calla	#26228		;0x06674

0000504a <.LVL2>:
}
    504a:	10 01       	reta			;

0000504c <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    504c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00005050 <.Loc.71.3>:
  gptp->config = NULL;
    5050:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    5054:	02 00 

00005056 <.Loc.72.3>:
}
    5056:	10 01       	reta			;

00005058 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    5058:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000505a <.LCFI0>:
    505a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000505c <.LCFI1>:
    505c:	ca 0c       	mova	r12,	r10	;
    505e:	c8 0d       	mova	r13,	r8	;

00005060 <.Loc.86.3>:

  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
    5060:	b0 13 2c 50 	calla	#20524		;0x0502c

00005064 <.LVL5>:
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    5064:	6c 4a       	mov.b	@r10,	r12	;
    5066:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5068:	5d 43       	mov.b	#1,	r13	;r3 As==01
    506a:	4d 9c       	cmp.b	r12,	r13	;
    506c:	04 2c       	jc	$+10     	;abs 0x5076

0000506e <.Loc.87.3>:
    506e:	8c 01 f8 00 	mova	#65784,	r12	;0x100f8
    5072:	b0 13 dc 47 	calla	#18396		;0x047dc

00005076 <.L6>:
              "invalid state");
  gptp->config = config;
    5076:	7a 08 02 00 	mova	r8,	2(r10)	;

0000507a <.Loc.90.3>:
  gpt_lld_start(gptp);
    507a:	cc 0a       	mova	r10,	r12	;
    507c:	b0 13 86 66 	calla	#26246		;0x06686

00005080 <.LVL7>:
  gptp->state = GPT_READY;
    5080:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005084 <.Loc.92.3>:
  osalSysUnlock();
    5084:	b0 13 38 50 	calla	#20536		;0x05038

00005088 <.LVL8>:
}
    5088:	08 16       	popm.a	#1,	r8	;20-bit words
    508a:	0a 16       	popm.a	#1,	r10	;20-bit words
    508c:	10 01       	reta			;

0000508e <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    508e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005090 <.LCFI6>:
    5090:	ca 0c       	mova	r12,	r10	;
    5092:	09 4d       	mov	r13,	r9	;

00005094 <.Loc.199.3>:

  osalDbgCheckClassI();
    5094:	b0 13 54 46 	calla	#18004		;0x04654

00005098 <.LVL27>:
  osalDbgCheck(gptp != NULL);
  osalDbgCheck(gptp->config->callback != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
    5098:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    509c:	04 24       	jz	$+10     	;abs 0x50a6

0000509e <.Loc.202.3>:
    509e:	8c 01 b9 00 	mova	#65721,	r12	;0x100b9
    50a2:	b0 13 dc 47 	calla	#18396		;0x047dc

000050a6 <.L15>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    50a6:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

000050aa <.Loc.206.3>:
  gpt_lld_start_timer(gptp, interval);
    50aa:	0d 49       	mov	r9,	r13	;
    50ac:	cc 0a       	mova	r10,	r12	;
    50ae:	b0 13 4c 67 	calla	#26444		;0x0674c

000050b2 <.LVL29>:
}
    50b2:	19 16       	popm.a	#2,	r10	;20-bit words
    50b4:	10 01       	reta			;

000050b6 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    50b6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000050b8 <.LCFI8>:
    50b8:	ca 0c       	mova	r12,	r10	;

000050ba <.Loc.232.3>:

  osalDbgCheckClassI();
    50ba:	b0 13 54 46 	calla	#18004		;0x04654

000050be <.LVL35>:
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    50be:	6c 4a       	mov.b	@r10,	r12	;
    50c0:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    50c4:	6d 43       	mov.b	#2,	r13	;r3 As==10
    50c6:	4d 9c       	cmp.b	r12,	r13	;
    50c8:	04 2c       	jc	$+10     	;abs 0x50d2

000050ca <.Loc.234.3>:
    50ca:	8c 01 ab 00 	mova	#65707,	r12	;0x100ab
    50ce:	b0 13 dc 47 	calla	#18396		;0x047dc

000050d2 <.L18>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    50d2:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000050d6 <.Loc.239.3>:
  gpt_lld_stop_timer(gptp);
    50d6:	cc 0a       	mova	r10,	r12	;
    50d8:	b0 13 70 67 	calla	#26480		;0x06770

000050dc <.LVL37>:
}
    50dc:	0a 16       	popm.a	#1,	r10	;20-bit words
    50de:	10 01       	reta			;

000050e0 <osalSysLock>:
  _disable_interrupts();
    50e0:	32 c2       	dint			
    50e2:	03 43       	nop			

000050e4 <.Loc.348.2>:
  asm volatile("nop");
    50e4:	03 43       	nop			

000050e6 <.LBE4>:
  chSysLock();
    50e6:	b0 13 54 45 	calla	#17748		;0x04554

000050ea <.LVL0>:
}
    50ea:	10 01       	reta			;

000050ec <osalSysUnlock>:
  chSysUnlock();
    50ec:	b0 13 7c 45 	calla	#17788		;0x0457c

000050f0 <.LBB8>:
  asm volatile("nop");
    50f0:	03 43       	nop			

000050f2 <.Loc.356.2>:
  _enable_interrupts();
    50f2:	03 43       	nop			
    50f4:	32 d2       	eint			
    50f6:	03 43       	nop			

000050f8 <.LBE8>:
}
    50f8:	10 01       	reta			;

000050fa <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    50fa:	b0 13 c4 5a 	calla	#23236		;0x05ac4

000050fe <.LVL2>:
}
    50fe:	10 01       	reta			;

00005100 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    5100:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00005104 <.Loc.74.3>:
  i2cp->config = NULL;
    5104:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    5108:	02 00 

0000510a <.Loc.83.3>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    510a:	10 01       	reta			;

0000510c <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    510c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000510e <.LCFI0>:
    510e:	08 14       	pushm.a	#1,	r8	;20-bit words

00005110 <.LCFI1>:
    5110:	ca 0c       	mova	r12,	r10	;
    5112:	c8 0d       	mova	r13,	r8	;

00005114 <.Loc.96.3>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    5114:	6c 4c       	mov.b	@r12,	r12	;

00005116 <.LVL5>:
    5116:	4d 4c       	mov.b	r12,	r13	;

00005118 <.LVL6>:
    5118:	7d 53       	add.b	#-1,	r13	;r3 As==11
    511a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    511c:	4e 9d       	cmp.b	r13,	r14	;
    511e:	07 2c       	jc	$+16     	;abs 0x512e

00005120 <.Loc.96.3>:
    5120:	3c 90 05 00 	cmp	#5,	r12	;
    5124:	04 24       	jz	$+10     	;abs 0x512e

00005126 <.Loc.96.3>:
    5126:	8c 01 3a 01 	mova	#65850,	r12	;0x1013a
    512a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000512e <.L6>:
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
    512e:	b0 13 e0 50 	calla	#20704		;0x050e0

00005132 <.LVL8>:
  i2cp->config = config;
    5132:	7a 08 02 00 	mova	r8,	2(r10)	;

00005136 <.Loc.101.3>:
  i2c_lld_start(i2cp);
    5136:	cc 0a       	mova	r10,	r12	;
    5138:	b0 13 fc 5a 	calla	#23292		;0x05afc

0000513c <.LVL9>:
  i2cp->state = I2C_READY;
    513c:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005140 <.Loc.103.3>:
  osalSysUnlock();
    5140:	b0 13 ec 50 	calla	#20716		;0x050ec

00005144 <.LVL10>:
}
    5144:	08 16       	popm.a	#1,	r8	;20-bit words
    5146:	0a 16       	popm.a	#1,	r10	;20-bit words
    5148:	10 01       	reta			;

0000514a <osalSysLock>:
  _disable_interrupts();
    514a:	32 c2       	dint			
    514c:	03 43       	nop			

0000514e <.Loc.348.2>:
  asm volatile("nop");
    514e:	03 43       	nop			

00005150 <.LBE4>:
  chSysLock();
    5150:	b0 13 54 45 	calla	#17748		;0x04554

00005154 <.LVL0>:
}
    5154:	10 01       	reta			;

00005156 <osalSysUnlock>:
  chSysUnlock();
    5156:	b0 13 7c 45 	calla	#17788		;0x0457c

0000515a <.LBB8>:
  asm volatile("nop");
    515a:	03 43       	nop			

0000515c <.Loc.356.2>:
  _enable_interrupts();
    515c:	03 43       	nop			
    515e:	32 d2       	eint			
    5160:	03 43       	nop			

00005162 <.LBE8>:
}
    5162:	10 01       	reta			;

00005164 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    5164:	b0 13 dc 58 	calla	#22748		;0x058dc

00005168 <.LVL4>:
}
    5168:	10 01       	reta			;

0000516a <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    516a:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000516e <.Loc.71.3>:
  spip->config = NULL;
    516e:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    5172:	02 00 

00005174 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    5174:	00 18 cc 43 	movx.a	#0,	6(r12)	;r3 As==00
    5178:	06 00 

0000517a <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    517a:	10 01       	reta			;

0000517c <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    517c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000517e <.LCFI0>:
    517e:	08 14       	pushm.a	#1,	r8	;20-bit words

00005180 <.LCFI1>:
    5180:	ca 0c       	mova	r12,	r10	;
    5182:	c8 0d       	mova	r13,	r8	;

00005184 <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    5184:	b0 13 4a 51 	calla	#20810		;0x0514a

00005188 <.LVL7>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    5188:	6c 4a       	mov.b	@r10,	r12	;
    518a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    518c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    518e:	4d 9c       	cmp.b	r12,	r13	;
    5190:	04 2c       	jc	$+10     	;abs 0x519a

00005192 <.Loc.96.3>:
    5192:	8c 01 c7 01 	mova	#65991,	r12	;0x101c7
    5196:	b0 13 dc 47 	calla	#18396		;0x047dc

0000519a <.L7>:
                "invalid state");
  spip->config = config;
    519a:	7a 08 02 00 	mova	r8,	2(r10)	;

0000519e <.Loc.99.3>:
  spi_lld_start(spip);
    519e:	cc 0a       	mova	r10,	r12	;
    51a0:	b0 13 cc 59 	calla	#22988		;0x059cc

000051a4 <.LVL9>:
  spip->state = SPI_READY;
    51a4:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000051a8 <.Loc.101.3>:
  osalSysUnlock();
    51a8:	b0 13 56 51 	calla	#20822		;0x05156

000051ac <.LVL10>:
}
    51ac:	08 16       	popm.a	#1,	r8	;20-bit words
    51ae:	0a 16       	popm.a	#1,	r10	;20-bit words
    51b0:	10 01       	reta			;

000051b2 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
    51b2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000051b4 <.LCFI11>:
    51b4:	08 14       	pushm.a	#1,	r8	;20-bit words

000051b6 <.LCFI12>:
    51b6:	06 14       	pushm.a	#1,	r6	;20-bit words

000051b8 <.LCFI13>:
    51b8:	ca 0c       	mova	r12,	r10	;
    51ba:	c6 0d       	mova	r13,	r6	;
    51bc:	c8 0e       	mova	r14,	r8	;

000051be <.Loc.235.3>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
    51be:	b0 13 4a 51 	calla	#20810		;0x0514a

000051c2 <.LVL37>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
    51c2:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    51c6:	04 24       	jz	$+10     	;abs 0x51d0

000051c8 <.Loc.236.3>:
    51c8:	8c 01 7c 01 	mova	#65916,	r12	;0x1017c
    51cc:	b0 13 dc 47 	calla	#18396		;0x047dc

000051d0 <.L19>:
  spiStartSendI(spip, n, txbuf);
    51d0:	fa 40 03 00 	mov.b	#3,	0(r10)	;
    51d4:	00 00 
    51d6:	ce 08       	mova	r8,	r14	;
    51d8:	cd 06       	mova	r6,	r13	;
    51da:	cc 0a       	mova	r10,	r12	;
    51dc:	b0 13 5a 5a 	calla	#23130		;0x05a5a

000051e0 <.LVL39>:
  osalSysUnlock();
    51e0:	b0 13 56 51 	calla	#20822		;0x05156

000051e4 <.LVL40>:
}
    51e4:	06 16       	popm.a	#1,	r6	;20-bit words
    51e6:	08 16       	popm.a	#1,	r8	;20-bit words
    51e8:	0a 16       	popm.a	#1,	r10	;20-bit words
    51ea:	10 01       	reta			;

000051ec <osalSysLock>:
  _disable_interrupts();
    51ec:	32 c2       	dint			
    51ee:	03 43       	nop			

000051f0 <.Loc.348.2>:
  asm volatile("nop");
    51f0:	03 43       	nop			

000051f2 <.LBE12>:
  chSysLock();
    51f2:	b0 13 54 45 	calla	#17748		;0x04554

000051f6 <.LVL0>:
}
    51f6:	10 01       	reta			;

000051f8 <osalSysUnlock>:
  chSysUnlock();
    51f8:	b0 13 7c 45 	calla	#17788		;0x0457c

000051fc <.LBB16>:
  asm volatile("nop");
    51fc:	03 43       	nop			

000051fe <.Loc.356.2>:
  _enable_interrupts();
    51fe:	03 43       	nop			
    5200:	32 d2       	eint			
    5202:	03 43       	nop			

00005204 <.LBE16>:
}
    5204:	10 01       	reta			;

00005206 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    5206:	b0 13 24 63 	calla	#25380		;0x06324

0000520a <.LVL2>:
}
    520a:	10 01       	reta			;

0000520c <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    520c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00005210 <.Loc.71.3>:
  uartp->txstate    = UART_TX_IDLE;
    5210:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00005214 <.Loc.72.3>:
  uartp->rxstate    = UART_RX_IDLE;
    5214:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00005218 <.Loc.73.3>:
  uartp->config     = NULL;
    5218:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    521c:	04 00 

0000521e <.Loc.75.3>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    521e:	cc 43 08 00 	mov.b	#0,	8(r12)	;r3 As==00

00005222 <.Loc.76.3>:
  uartp->threadrx   = NULL;
    5222:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    5226:	0a 00 

00005228 <.Loc.77.3>:
  uartp->threadtx   = NULL;
    5228:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    522c:	0e 00 

0000522e <.Loc.87.3>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    522e:	10 01       	reta			;

00005230 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    5230:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005232 <.LCFI0>:
    5232:	08 14       	pushm.a	#1,	r8	;20-bit words

00005234 <.LCFI1>:
    5234:	ca 0c       	mova	r12,	r10	;
    5236:	c8 0d       	mova	r13,	r8	;

00005238 <.Loc.101.3>:

  osalDbgCheck((uartp != NULL) && (config != NULL));

  osalSysLock();
    5238:	b0 13 ec 51 	calla	#20972		;0x051ec

0000523c <.LVL5>:
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    523c:	6c 4a       	mov.b	@r10,	r12	;
    523e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5240:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5242:	4d 9c       	cmp.b	r12,	r13	;
    5244:	04 2c       	jc	$+10     	;abs 0x524e

00005246 <.Loc.102.3>:
    5246:	8c 01 8c 02 	mova	#66188,	r12	;0x1028c
    524a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000524e <.L6>:
                "invalid state");

  uartp->config = config;
    524e:	7a 08 04 00 	mova	r8,	4(r10)	;

00005252 <.Loc.106.3>:
  uart_lld_start(uartp);
    5252:	cc 0a       	mova	r10,	r12	;
    5254:	b0 13 84 63 	calla	#25476		;0x06384

00005258 <.LVL7>:
  uartp->state = UART_READY;
    5258:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000525c <.Loc.108.3>:
  osalSysUnlock();
    525c:	b0 13 f8 51 	calla	#20984		;0x051f8

00005260 <.LVL8>:
}
    5260:	08 16       	popm.a	#1,	r8	;20-bit words
    5262:	0a 16       	popm.a	#1,	r10	;20-bit words
    5264:	10 01       	reta			;

00005266 <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    5266:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005268 <.LCFI6>:
    5268:	08 14       	pushm.a	#1,	r8	;20-bit words

0000526a <.LCFI7>:
    526a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000526c <.LCFI8>:
    526c:	ca 0c       	mova	r12,	r10	;
    526e:	c6 0d       	mova	r13,	r6	;
    5270:	c8 0e       	mova	r14,	r8	;

00005272 <.Loc.174.3>:

  osalDbgCheckClassI();
    5272:	b0 13 54 46 	calla	#18004		;0x04654

00005276 <.LVL21>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
    5276:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    527a:	04 24       	jz	$+10     	;abs 0x5284

0000527c <.Loc.176.3>:
    527c:	8c 01 66 02 	mova	#66150,	r12	;0x10266
    5280:	b0 13 dc 47 	calla	#18396		;0x047dc

00005284 <.L13>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    5284:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    5288:	04 20       	jnz	$+10     	;abs 0x5292

0000528a <.Loc.177.3>:
    528a:	8c 01 66 02 	mova	#66150,	r12	;0x10266
    528e:	b0 13 dc 47 	calla	#18396		;0x047dc

00005292 <.L14>:

  uart_lld_start_send(uartp, n, txbuf);
    5292:	ce 08       	mova	r8,	r14	;
    5294:	cd 06       	mova	r6,	r13	;
    5296:	cc 0a       	mova	r10,	r12	;
    5298:	b0 13 88 65 	calla	#25992		;0x06588

0000529c <.LVL24>:
  uartp->txstate = UART_TX_ACTIVE;
    529c:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

000052a0 <.Loc.181.3>:
}
    52a0:	06 16       	popm.a	#1,	r6	;20-bit words
    52a2:	08 16       	popm.a	#1,	r8	;20-bit words
    52a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    52a6:	10 01       	reta			;

000052a8 <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    52a8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052aa <.LCFI15>:
    52aa:	08 14       	pushm.a	#1,	r8	;20-bit words

000052ac <.LCFI16>:
    52ac:	06 14       	pushm.a	#1,	r6	;20-bit words

000052ae <.LCFI17>:
    52ae:	ca 0c       	mova	r12,	r10	;
    52b0:	c6 0d       	mova	r13,	r6	;
    52b2:	c8 0e       	mova	r14,	r8	;

000052b4 <.Loc.280.3>:

  osalDbgCheckClassI();
    52b4:	b0 13 54 46 	calla	#18004		;0x04654

000052b8 <.LVL44>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
    52b8:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    52bc:	04 24       	jz	$+10     	;abs 0x52c6

000052be <.Loc.282.3>:
    52be:	8c 01 28 02 	mova	#66088,	r12	;0x10228
    52c2:	b0 13 dc 47 	calla	#18396		;0x047dc

000052c6 <.L27>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    52c6:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    52ca:	04 20       	jnz	$+10     	;abs 0x52d4

000052cc <.Loc.283.3>:
    52cc:	8c 01 28 02 	mova	#66088,	r12	;0x10228
    52d0:	b0 13 dc 47 	calla	#18396		;0x047dc

000052d4 <.L28>:

  uart_lld_start_receive(uartp, n, rxbuf);
    52d4:	ce 08       	mova	r8,	r14	;
    52d6:	cd 06       	mova	r6,	r13	;
    52d8:	cc 0a       	mova	r10,	r12	;
    52da:	b0 13 dc 65 	calla	#26076		;0x065dc

000052de <.LVL47>:
  uartp->rxstate = UART_RX_ACTIVE;
    52de:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

000052e2 <.Loc.287.3>:
}
    52e2:	06 16       	popm.a	#1,	r6	;20-bit words
    52e4:	08 16       	popm.a	#1,	r8	;20-bit words
    52e6:	0a 16       	popm.a	#1,	r10	;20-bit words
    52e8:	10 01       	reta			;

000052ea <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    52ea:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052ec <.LCFI20>:
    52ec:	ca 0c       	mova	r12,	r10	;

000052ee <.Loc.336.3>:

  osalDbgCheckClassI();
    52ee:	b0 13 54 46 	calla	#18004		;0x04654

000052f2 <.LVL55>:
  osalDbgCheck(uartp != NULL);
  osalDbgAssert(uartp->state == UART_READY, "not active");
    52f2:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    52f6:	04 24       	jz	$+10     	;abs 0x5300

000052f8 <.Loc.338.3>:
    52f8:	8c 01 07 02 	mova	#66055,	r12	;0x10207
    52fc:	b0 13 dc 47 	calla	#18396		;0x047dc

00005300 <.L34>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    5300:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    5304:	07 20       	jnz	$+16     	;abs 0x5314

00005306 <.LBB27>:
    size_t n = uart_lld_stop_receive(uartp);
    5306:	cc 0a       	mova	r10,	r12	;
    5308:	b0 13 34 66 	calla	#26164		;0x06634

0000530c <.LVL58>:
    uartp->rxstate = UART_RX_IDLE;
    530c:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00005310 <.L33>:
    return n;
  }
  return 0;
}
    5310:	0a 16       	popm.a	#1,	r10	;20-bit words
    5312:	10 01       	reta			;

00005314 <.L36>:
  return 0;
    5314:	4c 43       	clr.b	r12		;
    5316:	80 00 10 53 	mova	#21264,	r0	;0x05310

0000531a <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    531a:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    531e:	80 5a 5c 01 

00005322 <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    5322:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    5326:	10 a5 40 01 

0000532a <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    532a:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    532e:	41 01 

00005330 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    5330:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    5334:	00 a5 60 01 

00005338 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    5338:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    533c:	48 00 62 01 

00005340 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    5340:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    5344:	33 01 64 01 

00005348 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    5348:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    534c:	66 01 

0000534e <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    534e:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    5352:	c9 c1 68 01 

00005356 <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    5356:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    535a:	0f 00 6c 01 

0000535e <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    535e:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    5362:	61 01 

00005364 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    5364:	b0 13 3e 56 	calla	#22078		;0x0563e

00005368 <.LVL0>:
#endif
}
    5368:	10 01       	reta			;

0000536a <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    536a:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    536e:	7f 3e d2 03 

00005372 <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    5372:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    5376:	10 00 c2 03 

0000537a <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    537a:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    537e:	e0 03 

00005380 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    5380:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    5384:	14 02 c0 03 

00005388 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    5388:	10 01       	reta			;

0000538a <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    538a:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    538e:	02 02 

00005390 <.Loc.310.1>:
  PADIR = config->porta.dir;
    5390:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    5394:	02 00 04 02 

00005398 <.Loc.311.1>:
  PAREN = config->porta.ren;
    5398:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    539c:	04 00 06 02 

000053a0 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    53a0:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    53a4:	06 00 0a 02 

000053a8 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    53a8:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    53ac:	08 00 0c 02 

000053b0 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    53b0:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    53b4:	0a 00 22 02 

000053b8 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    53b8:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    53bc:	0c 00 24 02 

000053c0 <.Loc.317.1>:
  PBREN = config->portb.ren;
    53c0:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    53c4:	0e 00 26 02 

000053c8 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    53c8:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    53cc:	10 00 2a 02 

000053d0 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    53d0:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    53d4:	12 00 2c 02 

000053d8 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    53d8:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    53dc:	14 00 22 03 

000053e0 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    53e0:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    53e4:	16 00 24 03 

000053e8 <.Loc.351.1>:
  PJREN = config->portj.ren;
    53e8:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    53ec:	18 00 26 03 

000053f0 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    53f0:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    53f4:	1a 00 2a 03 

000053f8 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    53f8:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    53fc:	1c 00 2c 03 

00005400 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    5400:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    5404:	30 01 

00005406 <.Loc.356.1>:
}
    5406:	10 01       	reta			;

00005408 <_pal_lld_setgroupmode>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    5408:	2e 92       	cmp	#4,	r14	;r2 As==10
    540a:	4e 24       	jz	$+158    	;abs 0x54a8
    540c:	6f 42       	mov.b	#4,	r15	;r2 As==10
    540e:	0f 9e       	cmp	r14,	r15	;
    5410:	0a 28       	jnc	$+22     	;abs 0x5426
    5412:	1e 93       	cmp	#1,	r14	;r3 As==01
    5414:	3f 24       	jz	$+128    	;abs 0x5494
    5416:	0e 93       	cmp	#0,	r14	;r3 As==00
    5418:	2d 24       	jz	$+92     	;abs 0x5474
    541a:	2e 93       	cmp	#2,	r14	;r3 As==10
    541c:	2b 24       	jz	$+88     	;abs 0x5474
    541e:	3e 90 03 00 	cmp	#3,	r14	;
    5422:	38 24       	jz	$+114    	;abs 0x5494

00005424 <.L38>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    5424:	10 01       	reta			;

00005426 <.L41>:
  switch (mode) {
    5426:	3e 92       	cmp	#8,	r14	;r2 As==11
    5428:	4f 24       	jz	$+160    	;abs 0x54c8
    542a:	7f 42       	mov.b	#8,	r15	;r2 As==11
    542c:	0f 9e       	cmp	r14,	r15	;
    542e:	12 28       	jnc	$+38     	;abs 0x5454
    5430:	3e 90 06 00 	cmp	#6,	r14	;
    5434:	f7 23       	jnz	$-16     	;abs 0x5424

00005436 <.Loc.410.1>:
      port->dir |= mask;
    5436:	8c dd 04 00 	bis	r13,	4(r12)	;

0000543a <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    543a:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    543e:	03 24       	jz	$+8      	;abs 0x5446

00005440 <.Loc.411.1>:
    5440:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5444:	23 20       	jnz	$+72     	;abs 0x548c

00005446 <.L52>:
        port->sel0 &= ~mask;
    5446:	3d e3       	inv	r13		;

00005448 <.LVL44>:
    5448:	8c fd 0a 00 	and	r13,	10(r12)	; 0x000a

0000544c <.Loc.415.1>:
        port->sel1 &= ~mask;
    544c:	8c fd 0c 00 	and	r13,	12(r12)	; 0x000c
    5450:	80 00 24 54 	mova	#21540,	r0	;0x05424

00005454 <.L45>:
  switch (mode) {
    5454:	3e 90 09 00 	cmp	#9,	r14	;
    5458:	43 24       	jz	$+136    	;abs 0x54e0
    545a:	3e 90 0a 00 	cmp	#10,	r14	;#0x000a
    545e:	e2 23       	jnz	$-58     	;abs 0x5424

00005460 <.Loc.435.1>:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    5460:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    5464:	03 20       	jnz	$+8      	;abs 0x546c

00005466 <.Loc.435.1>:
    5466:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    546a:	10 24       	jz	$+34     	;abs 0x548c

0000546c <.L55>:
        port->sel0 |= mask;
    546c:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a
    5470:	80 00 f0 54 	mova	#21744,	r0	;0x054f0

00005474 <.L43>:
      port->dir &= ~mask;
    5474:	0e 4d       	mov	r13,	r14	;

00005476 <.LVL46>:
    5476:	3e e3       	inv	r14		;
    5478:	8c fe 04 00 	and	r14,	4(r12)	;

0000547c <.Loc.378.1>:
      port->ren &= ~mask;
    547c:	8c fe 08 00 	and	r14,	8(r12)	;

00005480 <.L105>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    5480:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    5484:	1b 24       	jz	$+56     	;abs 0x54bc

00005486 <.Loc.402.1>:
    5486:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    548a:	18 24       	jz	$+50     	;abs 0x54bc

0000548c <.L99>:
        port->selc = mask;
    548c:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016
    5490:	80 00 24 54 	mova	#21540,	r0	;0x05424

00005494 <.L42>:
      port->dir &= ~mask;
    5494:	0e 4d       	mov	r13,	r14	;

00005496 <.LVL48>:
    5496:	3e e3       	inv	r14		;
    5498:	8c fe 04 00 	and	r14,	4(r12)	;

0000549c <.Loc.389.1>:
      port->ren |= mask;
    549c:	8c dd 08 00 	bis	r13,	8(r12)	;

000054a0 <.Loc.390.1>:
      port->out |= mask;
    54a0:	8c dd 02 00 	bis	r13,	2(r12)	;
    54a4:	80 00 80 54 	mova	#21632,	r0	;0x05480

000054a8 <.L40>:
      port->dir &= ~mask;
    54a8:	0e 4d       	mov	r13,	r14	;

000054aa <.LVL50>:
    54aa:	3e e3       	inv	r14		;
    54ac:	8c fe 04 00 	and	r14,	4(r12)	;

000054b0 <.Loc.400.1>:
      port->ren |= mask;
    54b0:	8c dd 08 00 	bis	r13,	8(r12)	;

000054b4 <.Loc.401.1>:
      port->out &= ~mask;
    54b4:	8c fe 02 00 	and	r14,	2(r12)	;
    54b8:	80 00 80 54 	mova	#21632,	r0	;0x05480

000054bc <.L51>:
        port->sel0 &= ~mask;
    54bc:	8c fe 0a 00 	and	r14,	10(r12)	; 0x000a

000054c0 <.Loc.406.1>:
        port->sel1 &= ~mask;
    54c0:	8c fe 0c 00 	and	r14,	12(r12)	; 0x000c
    54c4:	80 00 24 54 	mova	#21540,	r0	;0x05424

000054c8 <.L44>:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    54c8:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    54cc:	03 20       	jnz	$+8      	;abs 0x54d4

000054ce <.Loc.419.1>:
    54ce:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    54d2:	dc 23       	jnz	$-70     	;abs 0x548c

000054d4 <.L53>:
        port->sel0 |= mask;
    54d4:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a

000054d8 <.Loc.423.1>:
        port->sel1 &= ~mask;
    54d8:	8c cd 0c 00 	bic	r13,	12(r12)	; 0x000c
    54dc:	80 00 24 54 	mova	#21540,	r0	;0x05424

000054e0 <.L47>:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    54e0:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    54e4:	03 24       	jz	$+8      	;abs 0x54ec

000054e6 <.Loc.427.1>:
    54e6:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    54ea:	d0 27       	jz	$-94     	;abs 0x548c

000054ec <.L54>:
        port->sel0 &= ~mask;
    54ec:	8c cd 0a 00 	bic	r13,	10(r12)	; 0x000a

000054f0 <.L98>:
        port->sel1 |= mask;
    54f0:	8c dd 0c 00 	bis	r13,	12(r12)	; 0x000c

000054f4 <.Loc.443.1>:
}
    54f4:	80 00 24 54 	mova	#21540,	r0	;0x05424

000054f8 <_pal_lld_enablepadevent>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    54f8:	4a 14       	pushm.a	#5,	r10	;20-bit words

000054fa <.LCFI8>:
    54fa:	b1 00 04 00 	suba	#4,	r1	;

000054fe <.LCFI9>:
    54fe:	ca 0c       	mova	r12,	r10	;
    5500:	49 4d       	mov.b	r13,	r9	;
    5502:	47 4e       	mov.b	r14,	r7	;
    5504:	c6 0f       	mova	r15,	r6	;

00005506 <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5506:	00 18 4d 4c 	movx.a	r12,	r13	;
    550a:	0c 4c       	mov	r12,	r12	;
    550c:	0f 18 4d 11 	rpt #16 { rrax.a	r13		;

00005510 <.LVL53>:
    5510:	b0 13 a4 cd 	calla	#52644		;0x0cda4

00005514 <.LVL54>:
    5514:	0d 12       	push	r13		;
    5516:	0c 12       	push	r12		;
    5518:	0c 16       	popm.a	#1,	r12	;20-bit words
    551a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    551e:	7d 40 07 00 	mov.b	#7,	r13	;
    5522:	4d 99       	cmp.b	r9,	r13	;
    5524:	41 28       	jnc	$+132    	;abs 0x55a8
    5526:	5d 43       	mov.b	#1,	r13	;r3 As==01

00005528 <.L108>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    5528:	08 49       	mov	r9,	r8	;
    552a:	78 f0 07 00 	and.b	#7,	r8	;
    552e:	48 0e       	rlam.a	#4,	r8	;
    5530:	48 0d       	rram.a	#4,	r8	;

00005532 <.Loc.448.1>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5532:	4d 5c       	add.b	r12,	r13	;

00005534 <.LVL56>:
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    5534:	4c 4d       	mov.b	r13,	r12	;
    5536:	3c 53       	add	#-1,	r12	;r3 As==11
    5538:	4c 0e       	rlam.a	#4,	r12	;
    553a:	4c 0d       	rram.a	#4,	r12	;
    553c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    553e:	40 18 3c 41 	popx.w	r12		;
    5542:	40 18 3d 41 	popx.w	r13		;
    5546:	b0 13 34 cd 	calla	#52532		;0x0cd34
    554a:	0d 12       	push	r13		;
    554c:	0c 12       	push	r12		;
    554e:	0c 16       	popm.a	#1,	r12	;20-bit words
    5550:	e8 0c       	adda	r12,	r8	;
    5552:	08 14       	pushm.a	#1,	r8	;20-bit words
    5554:	40 18 3c 41 	popx.w	r12		;
    5558:	40 18 3d 41 	popx.w	r13		;
    555c:	0e 4c       	mov	r12,	r14	;
    555e:	0f 4d       	mov	r13,	r15	;
    5560:	0e 5e       	rla	r14		;
    5562:	0f 6f       	rlc	r15		;
    5564:	0e 5e       	rla	r14		;
    5566:	0f 6f       	rlc	r15		;
    5568:	81 4e 00 00 	mov	r14,	0(r1)	;
    556c:	81 4f 02 00 	mov	r15,	2(r1)	;
    5570:	0c 01       	mova	@r1,	r12	;
    5572:	01 18 cc 46 	movx.a	r6,	70552(r12); 0x11398
    5576:	98 13 

00005578 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    5578:	57 93       	cmp.b	#1,	r7	;r3 As==01
    557a:	19 20       	jnz	$+52     	;abs 0x55ae

0000557c <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    557c:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    5580:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5582:	0d 49       	mov	r9,	r13	;
    5584:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    5588:	08 cc       	bic	r12,	r8	;
    558a:	8a 48 18 00 	mov	r8,	24(r10)	; 0x0018

0000558e <.L110>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    558e:	18 4a 1c 00 	mov	28(r10),r8	;0x0001c
    5592:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5594:	0d 49       	mov	r9,	r13	;
    5596:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    559a:	08 cc       	bic	r12,	r8	;
    559c:	8a 48 1c 00 	mov	r8,	28(r10)	; 0x001c

000055a0 <.Loc.464.1>:
    port->ie |= (1 << pad);
    55a0:	8a dc 1a 00 	bis	r12,	26(r10)	; 0x001a

000055a4 <.Loc.466.1>:
  }
}
    55a4:	80 00 de 55 	mova	#21982,	r0	;0x055de

000055a8 <.L113>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    55a8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    55aa:	80 00 28 55 	mova	#21800,	r0	;0x05528

000055ae <.L109>:
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    55ae:	67 93       	cmp.b	#2,	r7	;r3 As==10
    55b0:	0b 20       	jnz	$+24     	;abs 0x55c8

000055b2 <.Loc.456.1>:
    port->ies |= (1 << pad);
    55b2:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    55b6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    55b8:	0d 49       	mov	r9,	r13	;
    55ba:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    55be:	0c d8       	bis	r8,	r12	;
    55c0:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018
    55c4:	80 00 8e 55 	mova	#21902,	r0	;0x0558e

000055c8 <.L111>:
  if (mode == PAL_EVENT_MODE_DISABLED) {
    55c8:	07 93       	cmp	#0,	r7	;r3 As==00
    55ca:	e1 23       	jnz	$-60     	;abs 0x558e

000055cc <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    55cc:	18 4a 1a 00 	mov	26(r10),r8	;0x0001a
    55d0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    55d2:	0d 49       	mov	r9,	r13	;
    55d4:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    55d8:	08 cc       	bic	r12,	r8	;
    55da:	8a 48 1a 00 	mov	r8,	26(r10)	; 0x001a

000055de <.L107>:
}
    55de:	a1 00 04 00 	adda	#4,	r1	;
    55e2:	46 16       	popm.a	#5,	r10	;20-bit words
    55e4:	10 01       	reta			;

000055e6 <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    55e6:	1a 14       	pushm.a	#2,	r10	;20-bit words

000055e8 <.LCFI10>:
    55e8:	ca 0c       	mova	r12,	r10	;

000055ea <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    55ea:	19 4c 1a 00 	mov	26(r12),r9	;0x0001a
    55ee:	5c 43       	mov.b	#1,	r12	;r3 As==01

000055f0 <.LVL63>:
    55f0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    55f4:	b0 13 fe cc 	calla	#52478		;0x0ccfe

000055f8 <.LVL64>:
    55f8:	09 cc       	bic	r12,	r9	;
    55fa:	8a 49 1a 00 	mov	r9,	26(r10)	; 0x001a

000055fe <.Loc.471.1>:
}
    55fe:	19 16       	popm.a	#2,	r10	;20-bit words
    5600:	10 01       	reta			;

00005602 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    5602:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005604 <.LCFI0>:
    5604:	49 4c       	mov.b	r12,	r9	;
    5606:	48 4d       	mov.b	r13,	r8	;

00005608 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5608:	0a 49       	mov	r9,	r10	;
    560a:	12 c3       	clrc			
    560c:	0a 10       	rrc	r10		;
    560e:	40 18 0a 4a 	movx.w	r10,	r10	;
    5612:	ea 0a       	adda	r10,	r10	;
    5614:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005618 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5618:	59 f3       	and.b	#1,	r9	;r3 As==01
    561a:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    561e:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00005622 <.LVL2>:
    5622:	0d 49       	mov	r9,	r13	;

00005624 <.LVL3>:
    5624:	b0 13 06 ce 	calla	#52742		;0x0ce06
    5628:	07 4c       	mov	r12,	r7	;
    562a:	27 fa       	and	@r10,	r7	;

0000562c <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    562c:	0c 48       	mov	r8,	r12	;
    562e:	0d 49       	mov	r9,	r13	;
    5630:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    5634:	07 dc       	bis	r12,	r7	;
    5636:	8a 47 00 00 	mov	r7,	0(r10)	;

0000563a <.Loc.65.1>:
}
    563a:	37 16       	popm.a	#4,	r10	;20-bit words
    563c:	10 01       	reta			;

0000563e <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    563e:	40 18 82 43 	movx.w	#0,	&0xfd118;r3 As==00
    5642:	18 d1 

00005644 <.LBE11>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    5644:	10 01       	reta			;

00005646 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5646:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005648 <.LCFI2>:
    5648:	ca 0c       	mova	r12,	r10	;

0000564a <.Loc.188.1>:
  
  osalDbgCheckClassI();
    564a:	b0 13 54 46 	calla	#18004		;0x04654

0000564e <.LVL23>:

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    564e:	40 18 19 42 	movx.w	&0x00510,r9	;
    5652:	10 05 
    5654:	79 f0 10 00 	and.b	#16,	r9	;#0x0010
    5658:	09 93       	cmp	#0,	r9	;r3 As==00
    565a:	11 24       	jz	$+36     	;abs 0x567e

0000565c <.LVL24>:
    565c:	8c 00 20 05 	mova	#1312,	r12	;0x00520
    5660:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5664:	10 00 00 00 
    5668:	09 24       	jz	$+20     	;abs 0x567c

0000566a <.LVL25>:
    566a:	40 18 bc b0 	bitx.w	#16,	16(r12)	;0x00010, 0x00010
    566e:	10 00 10 00 
    5672:	1f 24       	jz	$+64     	;abs 0x56b2

00005674 <.Loc.199.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    5674:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00005678 <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    5678:	28 16       	popm.a	#3,	r10	;20-bit words
    567a:	10 01       	reta			;

0000567c <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    567c:	59 43       	mov.b	#1,	r9	;r3 As==01

0000567e <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    567e:	48 49       	mov.b	r9,	r8	;
    5680:	4d 43       	clr.b	r13		;
    5682:	4c 48       	mov.b	r8,	r12	;
    5684:	b0 13 02 56 	calla	#22018		;0x05602

00005688 <.LVL29>:
  dma_regs[i].sz  = 0;
    5688:	0c 49       	mov	r9,	r12	;
    568a:	0d 43       	clr	r13		;
    568c:	b0 13 30 cd 	calla	#52528		;0x0cd30
    5690:	0d 12       	push	r13		;
    5692:	0c 12       	push	r12		;
    5694:	0c 16       	popm.a	#1,	r12	;20-bit words
    5696:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    569a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000569e <.Loc.205.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    569e:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    56a2:	00 00 

000056a4 <.Loc.207.1>:
  channel->registers = dma_regs + i;
    56a4:	7a 0c 00 00 	mova	r12,	0(r10)	;

000056a8 <.Loc.208.1>:
  channel->index     = i;
    56a8:	ca 48 04 00 	mov.b	r8,	4(r10)	;

000056ac <.Loc.210.1>:
  return MSG_OK;
    56ac:	4c 43       	clr.b	r12		;
    56ae:	80 00 78 56 	mova	#22136,	r0	;0x05678

000056b2 <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    56b2:	69 43       	mov.b	#2,	r9	;r3 As==10
    56b4:	80 00 7e 56 	mova	#22142,	r0	;0x0567e

000056b8 <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    56b8:	3a 14       	pushm.a	#4,	r10	;20-bit words

000056ba <.LCFI4>:
    56ba:	c8 0c       	mova	r12,	r8	;
    56bc:	49 4d       	mov.b	r13,	r9	;

000056be <.Loc.229.1>:
  
  osalDbgCheckClassI();
    56be:	b0 13 54 46 	calla	#18004		;0x04654

000056c2 <.LVL41>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    56c2:	6c 43       	mov.b	#2,	r12	;r3 As==10
    56c4:	4c 99       	cmp.b	r9,	r12	;
    56c6:	04 2c       	jc	$+10     	;abs 0x56d0

000056c8 <.Loc.232.1>:
    56c8:	8c 01 96 02 	mova	#66198,	r12	;0x10296
    56cc:	b0 13 dc 47 	calla	#18396		;0x047dc

000056d0 <.L27>:
  if (dma_regs[index].ctl & DMAEN) {
    56d0:	0c 49       	mov	r9,	r12	;
    56d2:	0d 43       	clr	r13		;
    56d4:	b0 13 30 cd 	calla	#52528		;0x0cd30
    56d8:	0d 12       	push	r13		;
    56da:	0c 12       	push	r12		;
    56dc:	0a 16       	popm.a	#1,	r10	;20-bit words
    56de:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    56e2:	27 4a       	mov	@r10,	r7	;
    56e4:	77 f0 10 00 	and.b	#16,	r7	;#0x0010
    56e8:	07 93       	cmp	#0,	r7	;r3 As==00
    56ea:	10 20       	jnz	$+34     	;abs 0x570c

000056ec <.Loc.238.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    56ec:	4d 47       	mov.b	r7,	r13	;
    56ee:	4c 49       	mov.b	r9,	r12	;
    56f0:	b0 13 02 56 	calla	#22018		;0x05602

000056f4 <.LVL44>:
  dma_regs[index].sz  = 0;
    56f4:	8a 47 0a 00 	mov	r7,	10(r10)	; 0x000a

000056f8 <.Loc.240.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    56f8:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    56fc:	00 00 

000056fe <.Loc.242.1>:

  channel->registers = dma_regs + index;
    56fe:	78 0a 00 00 	mova	r10,	0(r8)	;

00005702 <.Loc.243.1>:
  channel->index     = index;
    5702:	c8 49 04 00 	mov.b	r9,	4(r8)	;

00005706 <.Loc.245.1>:
  
  return MSG_OK;
    5706:	4c 43       	clr.b	r12		;

00005708 <.L26>:
}
    5708:	37 16       	popm.a	#4,	r10	;20-bit words
    570a:	10 01       	reta			;

0000570c <.L29>:
    return MSG_TIMEOUT;
    570c:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5710:	80 00 08 57 	mova	#22280,	r0	;0x05708

00005714 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5714:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005716 <.LCFI5>:
    5716:	08 14       	pushm.a	#1,	r8	;20-bit words

00005718 <.LCFI6>:
    5718:	c8 0c       	mova	r12,	r8	;
    571a:	ca 0d       	mova	r13,	r10	;

0000571c <.Loc.275.1>:

  osalDbgCheckClassI();
    571c:	b0 13 54 46 	calla	#18004		;0x04654

00005720 <.LVL46>:

  channel->registers->ctl &= (~DMAEN);
    5720:	0c 08       	mova	@r8,	r12	;
    5722:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5726:	00 00 

00005728 <.Loc.278.1>:
  dma_trigger_set(channel->index, request->trigger);
    5728:	5d 4a 10 00 	mov.b	16(r10),r13	;0x00010
    572c:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5730:	b0 13 02 56 	calla	#22018		;0x05602

00005734 <.LVL47>:
  callbacks[channel->index] = request->callback;
    5734:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5738:	0d 43       	clr	r13		;
    573a:	b0 13 34 cd 	calla	#52532		;0x0cd34
    573e:	0d 12       	push	r13		;
    5740:	0c 12       	push	r12		;
    5742:	0c 16       	popm.a	#1,	r12	;20-bit words
    5744:	ac 00 1a d1 	adda	#53530,	r12	;0x0d11a
    5748:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    574c:	00 00 
    574e:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    5752:	02 00 
    5754:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    5758:	04 00 
    575a:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    575e:	06 00 

00005760 <.Loc.282.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    5760:	0c 08       	mova	@r8,	r12	;
    5762:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    5766:	02 00 

00005768 <.Loc.283.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    5768:	0c 08       	mova	@r8,	r12	;
    576a:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    576e:	04 00 06 00 

00005772 <.Loc.288.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    5772:	0e 08       	mova	@r8,	r14	;
    5774:	9e 4a 08 00 	mov	8(r10),	10(r14)	; 0x000a
    5778:	0a 00 

0000577a <.Loc.289.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    577a:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    577e:	1c da 0a 00 	bis	10(r10),r12	;0x0000a

00005782 <.Loc.290.1>:
                            request->transfer_mode | DMAEN |
    5782:	3c d0 15 00 	bis	#21,	r12	;#0x0015

00005786 <.Loc.289.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5786:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    578a:	8e 4c 00 00 	mov	r12,	0(r14)	;

0000578e <.Loc.292.1>:
                            DMAREQ;
}
    578e:	08 16       	popm.a	#1,	r8	;20-bit words
    5790:	0a 16       	popm.a	#1,	r10	;20-bit words
    5792:	10 01       	reta			;

00005794 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5794:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005796 <.LCFI9>:
    5796:	ca 0c       	mova	r12,	r10	;

00005798 <.LBB31>:
  return chSysGetStatusAndLockX();
    5798:	b0 13 8a 48 	calla	#18570		;0x0488a

0000579c <.LVL54>:
    579c:	09 4c       	mov	r12,	r9	;

0000579e <.LBE31>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    579e:	9a 00 00 00 	cmpa	#0,	r10	;
    57a2:	10 24       	jz	$+34     	;abs 0x57c4

000057a4 <.Loc.309.1>:
    57a4:	0c 0a       	mova	@r10,	r12	;
    57a6:	9c 00 00 00 	cmpa	#0,	r12	;
    57aa:	0c 24       	jz	$+26     	;abs 0x57c4

000057ac <.Loc.309.1>:
    57ac:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    57b0:	10 00 00 00 
    57b4:	07 24       	jz	$+16     	;abs 0x57c4

000057b6 <.Loc.312.1>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    57b6:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

000057ba <.Loc.315.1>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    57ba:	4d 43       	clr.b	r13		;
    57bc:	8c 00 18 d1 	mova	#53528,	r12	;0x0d118
    57c0:	b0 13 a6 4f 	calla	#20390		;0x04fa6

000057c4 <.L33>:
  chSysRestoreStatusX(sts);
    57c4:	0c 49       	mov	r9,	r12	;
    57c6:	b0 13 b2 48 	calla	#18610		;0x048b2

000057ca <.LBE33>:
  }
  osalSysRestoreStatusX(sts);
}
    57ca:	19 16       	popm.a	#2,	r10	;20-bit words
    57cc:	10 01       	reta			;

000057ce <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    57ce:	0a 14       	pushm.a	#1,	r10	;20-bit words

000057d0 <.LCFI10>:
    57d0:	ca 0c       	mova	r12,	r10	;

000057d2 <.Loc.331.1>:
  
  osalDbgCheckClassI();
    57d2:	b0 13 54 46 	calla	#18004		;0x04654

000057d6 <.LVL58>:
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    57d6:	0c 0a       	mova	@r10,	r12	;
    57d8:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    57dc:	10 00 00 00 
    57e0:	0e 24       	jz	$+30     	;abs 0x57fe

000057e2 <.Loc.339.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    57e2:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    57e6:	00 00 

000057e8 <.Loc.341.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    57e8:	4d 43       	clr.b	r13		;
    57ea:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    57ee:	b0 13 02 56 	calla	#22018		;0x05602

000057f2 <.LVL59>:
  channel->registers->sz  = 0;
    57f2:	0c 0a       	mova	@r10,	r12	;
    57f4:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000057f8 <.Loc.343.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    57f8:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    57fc:	00 00 

000057fe <.L42>:
}
    57fe:	0a 16       	popm.a	#1,	r10	;20-bit words
    5800:	10 01       	reta			;

00005802 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    5802:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005804 <.LCFI0>:
    5804:	08 14       	pushm.a	#1,	r8	;20-bit words

00005806 <.LCFI1>:
    5806:	06 14       	pushm.a	#1,	r6	;20-bit words

00005808 <.LCFI2>:
    5808:	04 14       	pushm.a	#1,	r4	;20-bit words

0000580a <.LCFI3>:
    580a:	ca 0c       	mova	r12,	r10	;

0000580c <.Loc.106.1>:

  if (!dmaIsClaimed(&(spip->dmarx))) {
    580c:	c8 0c       	mova	r12,	r8	;
    580e:	a8 00 50 00 	adda	#80,	r8	;0x00050
    5812:	98 00 00 00 	cmpa	#0,	r8	;
    5816:	09 24       	jz	$+20     	;abs 0x582a

00005818 <.Loc.106.1>:
    5818:	3c 0c 50 00 	mova	80(r12),r12	;0x00050

0000581c <.LVL1>:
    581c:	9c 00 00 00 	cmpa	#0,	r12	;
    5820:	04 24       	jz	$+10     	;abs 0x582a

00005822 <.Loc.106.1>:
    5822:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5826:	00 00 
    5828:	03 20       	jnz	$+8      	;abs 0x5830

0000582a <.L2>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmarx));
    582a:	cc 08       	mova	r8,	r12	;
    582c:	b0 13 46 56 	calla	#22086		;0x05646

00005830 <.L3>:
  }
  
  if (!dmaIsClaimed(&(spip->dmatx))) {
    5830:	c6 0a       	mova	r10,	r6	;
    5832:	a6 00 46 00 	adda	#70,	r6	;0x00046
    5836:	96 00 00 00 	cmpa	#0,	r6	;
    583a:	09 24       	jz	$+20     	;abs 0x584e

0000583c <.Loc.111.1>:
    583c:	3c 0a 46 00 	mova	70(r10),r12	;0x00046
    5840:	9c 00 00 00 	cmpa	#0,	r12	;
    5844:	04 24       	jz	$+10     	;abs 0x584e

00005846 <.Loc.111.1>:
    5846:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    584a:	00 00 
    584c:	03 20       	jnz	$+8      	;abs 0x5854

0000584e <.L4>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmatx));
    584e:	cc 06       	mova	r6,	r12	;
    5850:	b0 13 46 56 	calla	#22086		;0x05646

00005854 <.L5>:
  }
  
  dmaTransferI(&(spip->dmarx), &(spip->rx_req));
    5854:	84 00 14 57 	mova	#22292,	r4	;0x05714
    5858:	cd 0a       	mova	r10,	r13	;
    585a:	ad 00 2c 00 	adda	#44,	r13	;0x0002c
    585e:	cc 08       	mova	r8,	r12	;
    5860:	44 13       	calla	r4		;

00005862 <.LVL4>:
  dmaTransferI(&(spip->dmatx), &(spip->tx_req));
    5862:	cd 0a       	mova	r10,	r13	;
    5864:	ad 00 12 00 	adda	#18,	r13	;0x00012
    5868:	cc 06       	mova	r6,	r12	;
    586a:	44 13       	calla	r4		;

0000586c <.LVL5>:

  *(spip->ifg) |= UCTXIFG;
    586c:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    5870:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005874 <.Loc.120.1>:
}
    5874:	04 16       	popm.a	#1,	r4	;20-bit words
    5876:	06 16       	popm.a	#1,	r6	;20-bit words
    5878:	08 16       	popm.a	#1,	r8	;20-bit words
    587a:	0a 16       	popm.a	#1,	r10	;20-bit words
    587c:	10 01       	reta			;

0000587e <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    587e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005880 <.LCFI4>:
    5880:	08 14       	pushm.a	#1,	r8	;20-bit words

00005882 <.LCFI5>:
    5882:	ca 0c       	mova	r12,	r10	;

00005884 <.LVL7>:
  SPIDriver * spip = (SPIDriver *)(arg);

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    5884:	3e 0c 0e 00 	mova	14(r12),r14	;0x0000e
    5888:	ae c3 00 00 	bic	#2,	0(r14)	;r3 As==10

0000588c <.Loc.136.1>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    588c:	3e 0c 02 00 	mova	2(r12),	r14	;
    5890:	0e 0e       	mova	@r14,	r14	;
    5892:	9e 00 00 00 	cmpa	#0,	r14	;
    5896:	06 24       	jz	$+14     	;abs 0x58a4

00005898 <.Loc.136.1>:
    5898:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    589c:	4e 13       	calla	r14		;

0000589e <.LVL8>:
    589e:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    58a2:	02 20       	jnz	$+6      	;abs 0x58a8

000058a4 <.L17>:
    58a4:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000058a8 <.L18>:
  chSysLockFromISR();
    58a8:	b0 13 a6 45 	calla	#17830		;0x045a6

000058ac <.LBB34>:
  chThdResumeI(trp, msg);
    58ac:	4d 43       	clr.b	r13		;
    58ae:	cc 0a       	mova	r10,	r12	;
    58b0:	ac 00 06 00 	adda	#6,	r12	;

000058b4 <.LVL10>:
    58b4:	b0 13 30 4a 	calla	#18992		;0x04a30

000058b8 <.LBB36>:
  chSysUnlockFromISR();
    58b8:	b0 13 d0 45 	calla	#17872		;0x045d0

000058bc <.LBE36>:
  
  if (spip->state == SPI_READY) {
    58bc:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    58c0:	0a 20       	jnz	$+22     	;abs 0x58d6

000058c2 <.LBB38>:
    dmaReleaseX(&(spip->dmarx));
    58c2:	88 00 94 57 	mova	#22420,	r8	;0x05794
    58c6:	cc 0a       	mova	r10,	r12	;
    58c8:	ac 00 50 00 	adda	#80,	r12	;0x00050
    58cc:	48 13       	calla	r8		;

000058ce <.LVL14>:
    dmaReleaseX(&(spip->dmatx));
    58ce:	cc 0a       	mova	r10,	r12	;
    58d0:	ac 00 46 00 	adda	#70,	r12	;0x00046
    58d4:	48 13       	calla	r8		;

000058d6 <.L16>:
  }
}
    58d6:	08 16       	popm.a	#1,	r8	;20-bit words
    58d8:	0a 16       	popm.a	#1,	r10	;20-bit words
    58da:	10 01       	reta			;

000058dc <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
    58dc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000058de <.LCFI6>:

#if MSP430X_SPI_USE_SPIA0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA0);
    58de:	8a 01 18 14 	mova	#70680,	r10	;0x11418
    58e2:	cc 0a       	mova	r10,	r12	;
    58e4:	b0 13 6a 51 	calla	#20842		;0x0516a

000058e8 <.LVL16>:
  SPIDA0.regs                     = (msp430x_spi_reg_t *)(&UCA0CTLW0);
    58e8:	00 18 fa 40 	movx.a	#1472,	10(r10)	;0x005c0, 0x0000a
    58ec:	c0 05 0a 00 

000058f0 <.Loc.162.1>:
  SPIDA0.ifg                      = (volatile uint16_t *)&UCA0IFG;
    58f0:	00 18 fa 40 	movx.a	#1500,	14(r10)	;0x005dc, 0x0000e
    58f4:	dc 05 0e 00 

000058f8 <.Loc.163.1>:
  SPIDA0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA0TXIFG);
    58f8:	ba 40 0f 00 	mov	#15,	34(r10)	;#0x000f, 0x0022
    58fc:	22 00 

000058fe <.Loc.164.1>:
  SPIDA0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA0RXIFG);
    58fe:	ba 40 0e 00 	mov	#14,	60(r10)	;#0x000e, 0x003c
    5902:	3c 00 

00005904 <.Loc.165.1>:
  SPIDA0.tx_req.dest_addr         = &(SPIDA0.regs->txbuf);
    5904:	00 18 fa 40 	movx.a	#1486,	22(r10)	;0x005ce, 0x00016
    5908:	ce 05 16 00 

0000590c <.Loc.166.1>:
  SPIDA0.rx_req.source_addr       = &(SPIDA0.regs->rxbuf);
    590c:	00 18 fa 40 	movx.a	#1484,	44(r10)	;0x005cc, 0x0002c
    5910:	cc 05 2c 00 

00005914 <.Loc.167.1>:
  SPIDA0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5914:	ba 40 c0 00 	mov	#192,	30(r10)	;#0x00c0, 0x001e
    5918:	1e 00 

0000591a <.Loc.168.1>:
  SPIDA0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    591a:	ba 40 c0 00 	mov	#192,	56(r10)	;#0x00c0, 0x0038
    591e:	38 00 

00005920 <.Loc.169.1>:
  SPIDA0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    5920:	8a 43 20 00 	mov	#0,	32(r10)	;r3 As==00, 0x0020

00005924 <.Loc.170.1>:
  SPIDA0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    5924:	8a 43 3a 00 	mov	#0,	58(r10)	;r3 As==00, 0x003a

00005928 <.Loc.171.1>:
  SPIDA0.tx_req.callback.callback = NULL;
    5928:	00 18 ca 43 	movx.a	#0,	36(r10)	;r3 As==00, 0x00024
    592c:	24 00 

0000592e <.Loc.172.1>:
  SPIDA0.tx_req.callback.args     = NULL;
    592e:	00 18 ca 43 	movx.a	#0,	40(r10)	;r3 As==00, 0x00028
    5932:	28 00 

00005934 <.Loc.173.1>:
  SPIDA0.rx_req.callback.callback = spi_lld_end_of_transfer;
    5934:	00 18 fa 40 	movx.a	#22654,	62(r10)	;0x0587e, 0x0003e
    5938:	7e 58 3e 00 

0000593c <.Loc.174.1>:
  SPIDA0.rx_req.callback.args     = &SPIDA0;
    593c:	7a 0a 42 00 	mova	r10,	66(r10)	; 0x00042

00005940 <.Loc.312.1>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    5940:	0a 16       	popm.a	#1,	r10	;20-bit words
    5942:	10 01       	reta			;

00005944 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    5944:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005946 <.LCFI7>:

  if (spip->config->ss_line) {
    5946:	3c 0c 02 00 	mova	2(r12),	r12	;

0000594a <.LVL20>:
    594a:	3c 0c 04 00 	mova	4(r12),	r12	;
    594e:	9c 00 00 00 	cmpa	#0,	r12	;
    5952:	18 24       	jz	$+50     	;abs 0x5984

00005954 <.Loc.432.1>:
    palClearLine(spip->config->ss_line);
    5954:	ca 0c       	mova	r12,	r10	;
    5956:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    595a:	ff 0f 
    595c:	19 4a 02 00 	mov	2(r10),	r9	;
    5960:	0c 14       	pushm.a	#1,	r12	;20-bit words
    5962:	40 18 3c 41 	popx.w	r12		;
    5966:	40 18 3d 41 	popx.w	r13		;
    596a:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    596e:	0d 12       	push	r13		;
    5970:	0c 12       	push	r12		;
    5972:	0c 16       	popm.a	#1,	r12	;20-bit words
    5974:	40 18 0d 4c 	movx.w	r12,	r13	;
    5978:	5c 43       	mov.b	#1,	r12	;r3 As==01
    597a:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    597e:	09 cc       	bic	r12,	r9	;
    5980:	8a 49 02 00 	mov	r9,	2(r10)	;

00005984 <.L26>:
  }
}
    5984:	19 16       	popm.a	#2,	r10	;20-bit words
    5986:	10 01       	reta			;

00005988 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    5988:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000598a <.LCFI8>:

  if (spip->config->ss_line) {
    598a:	3c 0c 02 00 	mova	2(r12),	r12	;

0000598e <.LVL24>:
    598e:	3c 0c 04 00 	mova	4(r12),	r12	;
    5992:	9c 00 00 00 	cmpa	#0,	r12	;
    5996:	18 24       	jz	$+50     	;abs 0x59c8

00005998 <.Loc.447.1>:
    palSetLine(spip->config->ss_line);
    5998:	ca 0c       	mova	r12,	r10	;
    599a:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    599e:	ff 0f 
    59a0:	19 4a 02 00 	mov	2(r10),	r9	;
    59a4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    59a6:	40 18 3c 41 	popx.w	r12		;
    59aa:	40 18 3d 41 	popx.w	r13		;
    59ae:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    59b2:	0d 12       	push	r13		;
    59b4:	0c 12       	push	r12		;
    59b6:	0c 16       	popm.a	#1,	r12	;20-bit words
    59b8:	40 18 0d 4c 	movx.w	r12,	r13	;
    59bc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    59be:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    59c2:	0c d9       	bis	r9,	r12	;
    59c4:	8a 4c 02 00 	mov	r12,	2(r10)	;

000059c8 <.L31>:
  }
}
    59c8:	19 16       	popm.a	#2,	r10	;20-bit words
    59ca:	10 01       	reta			;

000059cc <spi_lld_start>:
void spi_lld_start(SPIDriver * spip) {
    59cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000059ce <.LCFI9>:
    59ce:	08 14       	pushm.a	#1,	r8	;20-bit words

000059d0 <.LCFI10>:
    59d0:	ca 0c       	mova	r12,	r10	;

000059d2 <.LVL28>:
  if (spip == &SPIDA0) {
    59d2:	9c 01 18 14 	cmpa	#70680,	r12	;0x11418
    59d6:	3a 20       	jnz	$+118    	;abs 0x5a4c

000059d8 <.Loc.342.1>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    59d8:	3c 0c 02 00 	mova	2(r12),	r12	;

000059dc <.LVL29>:
    59dc:	1e 4c 08 00 	mov	8(r12),	r14	;
    59e0:	1f 4c 0a 00 	mov	10(r12),r15	;0x0000a
    59e4:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    59e8:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    59ec:	b0 13 c8 cc 	calla	#52424		;0x0ccc8

000059f0 <.LVL30>:
    ssel = MSP430X_SPIA0_UCSSEL;
    59f0:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080

000059f4 <.L37>:
  spip->regs->ctlw0 = UCSWRST;
    59f4:	3e 0a 0a 00 	mova	10(r10),r14	;0x0000a

000059f8 <.Loc.390.1>:
  spip->regs->brw   = brw;
    59f8:	8e 4c 06 00 	mov	r12,	6(r14)	;

000059fc <.Loc.392.1>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    59fc:	38 0a 02 00 	mova	2(r10),	r8	;
    5a00:	5c 48 0e 00 	mov.b	14(r8),	r12	;0x0000e

00005a04 <.LVL32>:
    5a04:	6c e3       	xor.b	#2,	r12	;r3 As==10
    5a06:	0f 4c       	mov	r12,	r15	;
    5a08:	4d 18 0f 5f 	rpt #14 { rlax.w	r15		;
    5a0c:	5c 48 0c 00 	mov.b	12(r8),	r12	;0x0000c
    5a10:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;

00005a14 <.Loc.393.1>:
      (spip->config->data_size << 12) | (UCMST) |
    5a14:	5b 48 0d 00 	mov.b	13(r8),	r11	;0x0000d
    5a18:	4b 18 0b 5b 	rpt #12 { rlax.w	r11		;
    5a1c:	0c db       	bis	r11,	r12	;

00005a1e <.Loc.394.1>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    5a1e:	00 18 c8 93 	cmpx.a	#0,	4(r8)	;r3 As==00
    5a22:	04 00 
    5a24:	17 20       	jnz	$+48     	;abs 0x5a54
    5a26:	38 40 00 04 	mov	#1024,	r8	;#0x0400

00005a2a <.L38>:
    5a2a:	3c d0 02 09 	bis	#2306,	r12	;#0x0902
    5a2e:	0c df       	bis	r15,	r12	;
    5a30:	0c dd       	bis	r13,	r12	;
    5a32:	0c d8       	bis	r8,	r12	;
    5a34:	8e 4c 00 00 	mov	r12,	0(r14)	;

00005a38 <.Loc.395.1>:
  *(spip->ifg) = 0;
    5a38:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    5a3c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005a40 <.LVL33>:
  spi_lld_unselect(spip);
    5a40:	cc 0a       	mova	r10,	r12	;
    5a42:	b0 13 88 59 	calla	#22920		;0x05988

00005a46 <.LVL34>:
}
    5a46:	08 16       	popm.a	#1,	r8	;20-bit words
    5a48:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a4a:	10 01       	reta			;

00005a4c <.L39>:
  uint8_t ssel = 0;
    5a4c:	4d 43       	clr.b	r13		;

00005a4e <.Loc.338.1>:
  uint16_t brw = 0;
    5a4e:	0c 4d       	mov	r13,	r12	;
    5a50:	80 00 f4 59 	mova	#23028,	r0	;0x059f4

00005a54 <.L40>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    5a54:	48 43       	clr.b	r8		;
    5a56:	80 00 2a 5a 	mova	#23082,	r0	;0x05a2a

00005a5a <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {
    5a5a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005a5c <.LCFI12>:
    5a5c:	ca 0c       	mova	r12,	r10	;

00005a5e <.Loc.521.1>:

  spip->tx_req.source_addr = txbuf;
    5a5e:	7c 0e 12 00 	mova	r14,	18(r12)	; 0x00012

00005a62 <.Loc.522.1>:
  spip->tx_req.size        = n;
    5a62:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00005a66 <.Loc.523.1>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    5a66:	bc 40 00 03 	mov	#768,	28(r12)	;#0x0300, 0x001c
    5a6a:	1c 00 

00005a6c <.Loc.525.1>:

  spip->rx_req.dest_addr = &dummyrx;
    5a6c:	00 18 fc 40 	movx.a	#53554,	48(r12)	;0x0d132, 0x00030
    5a70:	32 d1 30 00 

00005a74 <.Loc.526.1>:
  spip->rx_req.size      = n;
    5a74:	8c 4d 34 00 	mov	r13,	52(r12)	; 0x0034

00005a78 <.Loc.527.1>:
  spip->rx_req.addr_mode = 0;
    5a78:	8c 43 36 00 	mov	#0,	54(r12)	;r3 As==00, 0x0036

00005a7c <.Loc.529.1>:

  init_transfer(spip);
    5a7c:	b0 13 02 58 	calla	#22530		;0x05802

00005a80 <.LVL42>:
}
    5a80:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a82:	10 01       	reta			;

00005a84 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {
    5a84:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005a86 <.LCFI14>:
    5a86:	ca 0c       	mova	r12,	r10	;
    5a88:	49 4d       	mov.b	r13,	r9	;

00005a8a <.Loc.572.1>:

  osalDbgAssert(spip->state == SPI_READY, "not ready");
    5a8a:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    5a8e:	04 24       	jz	$+10     	;abs 0x5a98

00005a90 <.Loc.572.1>:
    5a90:	8c 01 a0 02 	mova	#66208,	r12	;0x102a0

00005a94 <.LVL46>:
    5a94:	b0 13 dc 47 	calla	#18396		;0x047dc

00005a98 <.L46>:
  spip->regs->txbuf = frame;
    5a98:	3e 0a 0a 00 	mova	10(r10),r14	;0x0000a
    5a9c:	8e 49 0e 00 	mov	r9,	14(r14)	; 0x000e

00005aa0 <.Loc.574.1>:
  while (!(*(spip->ifg) & UCRXIFG))
    5aa0:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e

00005aa4 <.L47>:
    5aa4:	40 18 9c b3 	bitx.w	#1,	0(r12)	;r3 As==01
    5aa8:	00 00 
    5aaa:	fc 27       	jz	$-6      	;abs 0x5aa4

00005aac <.Loc.576.1>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    5aac:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    5ab0:	00 00 

00005ab2 <.Loc.578.1>:
  return spip->regs->rxbuf;
}
    5ab2:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    5ab6:	19 16       	popm.a	#2,	r10	;20-bit words
    5ab8:	10 01       	reta			;

00005aba <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    5aba:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005abe <.LVL2>:
    5abe:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

00005ac2 <.Loc.82.1>:
}
    5ac2:	10 01       	reta			;

00005ac4 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    5ac4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005ac6 <.LCFI0>:

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5ac6:	8a 01 72 14 	mova	#70770,	r10	;0x11472
    5aca:	cc 0a       	mova	r10,	r12	;
    5acc:	b0 13 00 51 	calla	#20736		;0x05100

00005ad0 <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    5ad0:	00 18 fa 40 	movx.a	#1600,	16(r10)	;0x00640, 0x00010
    5ad4:	40 06 10 00 

00005ad8 <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5ad8:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    5adc:	20 00 

00005ade <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    5ade:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

00005ae2 <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    5ae2:	fa 40 13 00 	mov.b	#19,	50(r10)	;#0x0013, 0x0032
    5ae6:	32 00 

00005ae8 <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    5ae8:	fa 40 12 00 	mov.b	#18,	51(r10)	;#0x0012, 0x0033
    5aec:	33 00 

00005aee <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    5aee:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    5af2:	26 00 

00005af4 <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    5af4:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005af8 <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    5af8:	0a 16       	popm.a	#1,	r10	;20-bit words
    5afa:	10 01       	reta			;

00005afc <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    5afc:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005afe <.LCFI1>:
    5afe:	ca 0c       	mova	r12,	r10	;

00005b00 <.Loc.479.1>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    5b00:	9c 01 72 14 	cmpa	#70770,	r12	;0x11472
    5b04:	52 20       	jnz	$+166    	;abs 0x5baa

00005b06 <.Loc.481.1>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    5b06:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5b0a:	40 06 

00005b0c <.Loc.483.1>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    5b0c:	3c 0c 02 00 	mova	2(r12),	r12	;

00005b10 <.LVL8>:
    5b10:	2e 4c       	mov	@r12,	r14	;
    5b12:	1f 4c 02 00 	mov	2(r12),	r15	;
    5b16:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5b1a:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5b1e:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    5b22:	40 18 82 4c 	movx.w	r12,	&0x00646;
    5b26:	46 06 

00005b28 <.Loc.485.1>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    5b28:	40 18 b2 40 	movx.w	#192,	&0x00642;0x000c0
    5b2c:	c0 00 42 06 

00005b30 <.Loc.490.1>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
        | MSP430X_I2CB0_UCSSEL;
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    5b30:	40 18 b2 40 	movx.w	#3968,	&0x00640;0x00f80
    5b34:	80 0f 40 06 

00005b38 <.Loc.492.1>:
  #endif
      if (I2CDB0.regs->statw & BIT4) {
    5b38:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5b3c:	40 18 bc b0 	bitx.w	#16,	8(r12)	;0x00010
    5b40:	10 00 08 00 
    5b44:	2b 24       	jz	$+88     	;abs 0x5b9c

00005b46 <.Loc.494.1>:
        /* Disable again */
        UCB0CTLW0 |= 0x01;
    5b46:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5b4a:	40 06 

00005b4c <.Loc.496.1>:
        /* Set the SCL pin as an output */
        P1SEL1 &= ~0x80;
    5b4c:	40 18 f2 f0 	andx.b	#127,	&0x0020c;0x0007f
    5b50:	7f 00 0c 02 

00005b54 <.Loc.497.1>:
        P1DIR |= 0x80;
    5b54:	c0 1f f2 d0 	bisx.b	#-128,	&0x00204;0xfff80
    5b58:	80 ff 04 02 

00005b5c <.Loc.498.1>:
        P1REN &= ~0x80;
    5b5c:	40 18 f2 f0 	andx.b	#127,	&0x00206;0x0007f
    5b60:	7f 00 06 02 

00005b64 <.LVL10>:
    5b64:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a

00005b68 <.L7>:
        /* Toggle it 10 times */
        for (int i = 0 ; i < 10; i++) {
          P1OUT &= ~0x80;
    5b68:	40 18 f2 f0 	andx.b	#127,	&0x00202;0x0007f
    5b6c:	7f 00 02 02 

00005b70 <.Loc.502.1>:
          P1OUT |= 0x80;
    5b70:	c0 1f f2 d0 	bisx.b	#-128,	&0x00202;0xfff80
    5b74:	80 ff 02 02 

00005b78 <.LVL12>:
    5b78:	3c 53       	add	#-1,	r12	;r3 As==11

00005b7a <.LVL13>:
        for (int i = 0 ; i < 10; i++) {
    5b7a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b7c:	f5 23       	jnz	$-20     	;abs 0x5b68

00005b7e <.LBE49>:
        }
        /* Reset it to I2C mode */
        P1DIR &= ~0x80;
    5b7e:	40 18 f2 f0 	andx.b	#127,	&0x00204;0x0007f
    5b82:	7f 00 04 02 

00005b86 <.Loc.506.1>:
        P1SEL1 |= 0x80;
    5b86:	c0 1f f2 d0 	bisx.b	#-128,	&0x0020c;0xfff80
    5b8a:	80 ff 0c 02 

00005b8e <.Loc.507.1>:
        P1REN |= 0x80;
    5b8e:	c0 1f f2 d0 	bisx.b	#-128,	&0x00206;0xfff80
    5b92:	80 ff 06 02 

00005b96 <.Loc.509.1>:
        /* Re-enable the peripheral */
        UCB0CTLW0 &= ~0x01;
    5b96:	40 18 92 c3 	bicx.w	#1,	&0x00640;r3 As==01
    5b9a:	40 06 

00005b9c <.L6>:
      }
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    5b9c:	40 18 b2 40 	movx.w	#184,	&0x0066a;0x000b8
    5ba0:	b8 00 6a 06 

00005ba4 <.Loc.512.1>:
      UCB0IFG = 0;
    5ba4:	40 18 82 43 	movx.w	#0,	&0x0066c;r3 As==00
    5ba8:	6c 06 

00005baa <.L4>:
      }
  #endif
    }
#endif

}
    5baa:	0a 16       	popm.a	#1,	r10	;20-bit words
    5bac:	10 01       	reta			;

00005bae <i2cMSP430XStartReceiveToRegI>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    5bae:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005bb0 <.LCFI3>:
    5bb0:	06 14       	pushm.a	#1,	r6	;20-bit words

00005bb2 <.LCFI4>:
    5bb2:	04 14       	pushm.a	#1,	r4	;20-bit words

00005bb4 <.LCFI5>:
    5bb4:	c6 0c       	mova	r12,	r6	;
    5bb6:	49 4d       	mov.b	r13,	r9	;
    5bb8:	ca 0e       	mova	r14,	r10	;
    5bba:	c8 0f       	mova	r15,	r8	;
    5bbc:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005bc0 <.Loc.678.1>:
  
  osalDbgCheckClassI();
    5bc0:	b0 13 54 46 	calla	#18004		;0x04654

00005bc4 <.LVL22>:
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5bc4:	9a 00 00 00 	cmpa	#0,	r10	;
    5bc8:	04 20       	jnz	$+10     	;abs 0x5bd2

00005bca <.Loc.680.1>:
    5bca:	8c 01 ba 03 	mova	#66490,	r12	;0x103ba
    5bce:	b0 13 dc 47 	calla	#18396		;0x047dc

00005bd2 <.L16>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5bd2:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5bd4:	04 34       	jge	$+10     	;abs 0x5bde

00005bd6 <.Loc.684.1>:
    5bd6:	8c 01 ba 03 	mova	#66490,	r12	;0x103ba
    5bda:	b0 13 dc 47 	calla	#18396		;0x047dc

00005bde <.L17>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5bde:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005be2 <.Loc.690.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5be2:	e6 42 00 00 	mov.b	#4,	0(r6)	;r2 As==10

00005be6 <.Loc.692.1>:
  
  i2cp->buffer = regp;
    5be6:	76 08 08 00 	mova	r8,	8(r6)	;

00005bea <.Loc.695.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5bea:	9a 00 01 00 	cmpa	#1,	r10	;
    5bee:	1b 20       	jnz	$+56     	;abs 0x5c26

00005bf0 <.Loc.697.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = regp;
    5bf0:	76 08 18 00 	mova	r8,	24(r6)	; 0x00018

00005bf4 <.Loc.698.1>:
    i2cp->req.size = 0;
    5bf4:	86 43 1c 00 	mov	#0,	28(r6)	;r3 As==00, 0x001c

00005bf8 <.Loc.700.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5bf8:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5bfc:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5c00:	00 00 

00005c02 <.Loc.702.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5c02:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005c06 <.L19>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5c06:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5c0a:	fd 23       	jnz	$-4      	;abs 0x5c06

00005c0c <.Loc.705.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    5c0c:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005c10 <.Loc.707.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
    5c10:	94 00 00 00 	cmpa	#0,	r4	;
    5c14:	04 24       	jz	$+10     	;abs 0x5c1e

00005c16 <.Loc.708.1>:
      callback(i2cp, regp, 1);
    5c16:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5c18:	cd 08       	mova	r8,	r13	;
    5c1a:	cc 06       	mova	r6,	r12	;
    5c1c:	44 13       	calla	r4		;

00005c1e <.L15>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5c1e:	04 16       	popm.a	#1,	r4	;20-bit words
    5c20:	06 16       	popm.a	#1,	r6	;20-bit words
    5c22:	28 16       	popm.a	#3,	r10	;20-bit words
    5c24:	10 01       	reta			;

00005c26 <.L18>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5c26:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5c2a:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5c2e:	76 0c 14 00 	mova	r12,	20(r6)	; 0x00014

00005c32 <.Loc.713.1>:
    i2cp->req.dest_addr = regp;
    5c32:	76 08 18 00 	mova	r8,	24(r6)	; 0x00018

00005c36 <.Loc.714.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5c36:	40 18 0a 4a 	movx.w	r10,	r10	;

00005c3a <.LVL27>:
    5c3a:	3a 53       	add	#-1,	r10	;r3 As==11
    5c3c:	86 4a 1c 00 	mov	r10,	28(r6)	; 0x001c

00005c40 <.Loc.715.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5c40:	86 43 1e 00 	mov	#0,	30(r6)	;r3 As==00, 0x001e

00005c44 <.Loc.716.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5c44:	5c 46 33 00 	mov.b	51(r6),	r12	;0x00033
    5c48:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005c4c <.Loc.718.1>:
    i2cp->callback = callback;
    5c4c:	76 04 0c 00 	mova	r4,	12(r6)	; 0x0000c

00005c50 <.Loc.720.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5c50:	00 18 f6 40 	movx.a	#24630,	38(r6)	;0x06036, 0x00026
    5c54:	36 60 26 00 

00005c58 <.Loc.721.1>:
    i2cp->req.callback.args = i2cp;
    5c58:	76 06 2a 00 	mova	r6,	42(r6)	; 0x0002a

00005c5c <.Loc.723.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5c5c:	ca 06       	mova	r6,	r10	;
    5c5e:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5c62:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5c66:	9c 00 00 00 	cmpa	#0,	r12	;
    5c6a:	04 24       	jz	$+10     	;abs 0x5c74

00005c6c <.Loc.723.1>:
    5c6c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5c70:	00 00 
    5c72:	03 20       	jnz	$+8      	;abs 0x5c7a

00005c74 <.L21>:
      dmaAcquireI(&(i2cp->dma));
    5c74:	cc 0a       	mova	r10,	r12	;
    5c76:	b0 13 46 56 	calla	#22086		;0x05646

00005c7a <.L22>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5c7a:	cd 06       	mova	r6,	r13	;
    5c7c:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5c80:	cc 0a       	mova	r10,	r12	;
    5c82:	b0 13 14 57 	calla	#22292		;0x05714

00005c86 <.LVL29>:
    i2cp->regs->i2csa = addr;
    5c86:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5c8a:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005c8e <.Loc.730.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5c8e:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5c92:	00 00 

00005c94 <.Loc.731.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5c94:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005c98 <.Loc.733.1>:
}
    5c98:	80 00 1e 5c 	mova	#23582,	r0	;0x05c1e

00005c9c <i2cMSP430XStartReceiveI>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    5c9c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005c9e <.LCFI6>:
    5c9e:	06 14       	pushm.a	#1,	r6	;20-bit words

00005ca0 <.LCFI7>:
    5ca0:	04 14       	pushm.a	#1,	r4	;20-bit words

00005ca2 <.LCFI8>:
    5ca2:	c6 0c       	mova	r12,	r6	;
    5ca4:	49 4d       	mov.b	r13,	r9	;
    5ca6:	ca 0e       	mova	r14,	r10	;
    5ca8:	c8 0f       	mova	r15,	r8	;
    5caa:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005cae <.Loc.738.1>:
  
  osalDbgCheckClassI();
    5cae:	b0 13 54 46 	calla	#18004		;0x04654

00005cb2 <.LVL31>:
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5cb2:	9a 00 00 00 	cmpa	#0,	r10	;
    5cb6:	04 20       	jnz	$+10     	;abs 0x5cc0

00005cb8 <.Loc.740.1>:
    5cb8:	8c 01 a2 03 	mova	#66466,	r12	;0x103a2
    5cbc:	b0 13 dc 47 	calla	#18396		;0x047dc

00005cc0 <.L31>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5cc0:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5cc2:	04 34       	jge	$+10     	;abs 0x5ccc

00005cc4 <.Loc.744.1>:
    5cc4:	8c 01 a2 03 	mova	#66466,	r12	;0x103a2
    5cc8:	b0 13 dc 47 	calla	#18396		;0x047dc

00005ccc <.L32>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5ccc:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005cd0 <.Loc.750.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5cd0:	e6 42 00 00 	mov.b	#4,	0(r6)	;r2 As==10

00005cd4 <.Loc.752.1>:
  
  i2cp->buffer = rxbuf;
    5cd4:	76 08 08 00 	mova	r8,	8(r6)	;

00005cd8 <.Loc.755.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5cd8:	9a 00 01 00 	cmpa	#1,	r10	;
    5cdc:	1f 20       	jnz	$+64     	;abs 0x5d1c

00005cde <.Loc.757.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    5cde:	76 08 18 00 	mova	r8,	24(r6)	; 0x00018

00005ce2 <.Loc.758.1>:
    i2cp->req.size = 0;
    5ce2:	86 43 1c 00 	mov	#0,	28(r6)	;r3 As==00, 0x001c

00005ce6 <.Loc.760.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5ce6:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5cea:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5cee:	00 00 

00005cf0 <.Loc.762.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5cf0:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005cf4 <.L34>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5cf4:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5cf8:	fd 23       	jnz	$-4      	;abs 0x5cf4

00005cfa <.Loc.765.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    5cfa:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005cfe <.Loc.767.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
    5cfe:	94 00 00 00 	cmpa	#0,	r4	;
    5d02:	02 24       	jz	$+6      	;abs 0x5d08

00005d04 <.Loc.768.1>:
      chSysUnlockFromISR();
    5d04:	b0 13 d0 45 	calla	#17872		;0x045d0

00005d08 <.L35>:
      callback(i2cp, rxbuf, 1);
    5d08:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5d0a:	cd 08       	mova	r8,	r13	;
    5d0c:	cc 06       	mova	r6,	r12	;
    5d0e:	44 13       	calla	r4		;

00005d10 <.LVL35>:
      chSysLockFromISR();
    5d10:	b0 13 a6 45 	calla	#17830		;0x045a6

00005d14 <.L30>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5d14:	04 16       	popm.a	#1,	r4	;20-bit words
    5d16:	06 16       	popm.a	#1,	r6	;20-bit words
    5d18:	28 16       	popm.a	#3,	r10	;20-bit words
    5d1a:	10 01       	reta			;

00005d1c <.L33>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5d1c:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5d20:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5d24:	76 0c 14 00 	mova	r12,	20(r6)	; 0x00014

00005d28 <.Loc.775.1>:
    i2cp->req.dest_addr = rxbuf;
    5d28:	76 08 18 00 	mova	r8,	24(r6)	; 0x00018

00005d2c <.Loc.776.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5d2c:	40 18 0a 4a 	movx.w	r10,	r10	;

00005d30 <.LVL38>:
    5d30:	3a 53       	add	#-1,	r10	;r3 As==11
    5d32:	86 4a 1c 00 	mov	r10,	28(r6)	; 0x001c

00005d36 <.Loc.777.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    5d36:	b6 40 00 0c 	mov	#3072,	30(r6)	;#0x0c00, 0x001e
    5d3a:	1e 00 

00005d3c <.Loc.778.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5d3c:	5c 46 33 00 	mov.b	51(r6),	r12	;0x00033
    5d40:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005d44 <.Loc.780.1>:
    i2cp->callback = callback;
    5d44:	76 04 0c 00 	mova	r4,	12(r6)	; 0x0000c

00005d48 <.Loc.782.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5d48:	00 18 f6 40 	movx.a	#24630,	38(r6)	;0x06036, 0x00026
    5d4c:	36 60 26 00 

00005d50 <.Loc.783.1>:
    i2cp->req.callback.args = i2cp;
    5d50:	76 06 2a 00 	mova	r6,	42(r6)	; 0x0002a

00005d54 <.Loc.785.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5d54:	ca 06       	mova	r6,	r10	;
    5d56:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5d5a:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5d5e:	9c 00 00 00 	cmpa	#0,	r12	;
    5d62:	04 24       	jz	$+10     	;abs 0x5d6c

00005d64 <.Loc.785.1>:
    5d64:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5d68:	00 00 
    5d6a:	03 20       	jnz	$+8      	;abs 0x5d72

00005d6c <.L37>:
      dmaAcquireI(&(i2cp->dma));
    5d6c:	cc 0a       	mova	r10,	r12	;
    5d6e:	b0 13 46 56 	calla	#22086		;0x05646

00005d72 <.L38>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5d72:	cd 06       	mova	r6,	r13	;
    5d74:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5d78:	cc 0a       	mova	r10,	r12	;
    5d7a:	b0 13 14 57 	calla	#22292		;0x05714

00005d7e <.LVL40>:
    i2cp->regs->i2csa = addr;
    5d7e:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5d82:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005d86 <.Loc.792.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5d86:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5d8a:	00 00 

00005d8c <.Loc.793.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5d8c:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005d90 <.Loc.795.1>:
}
    5d90:	80 00 14 5d 	mova	#23828,	r0	;0x05d14

00005d94 <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5d94:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005d96 <.LCFI9>:
    5d96:	06 14       	pushm.a	#1,	r6	;20-bit words

00005d98 <.LCFI10>:
    5d98:	c6 0c       	mova	r12,	r6	;
    5d9a:	49 4d       	mov.b	r13,	r9	;
    5d9c:	ca 0e       	mova	r14,	r10	;
    5d9e:	c8 0f       	mova	r15,	r8	;

00005da0 <.Loc.800.1>:
  
  osalDbgCheckClassI();
    5da0:	b0 13 54 46 	calla	#18004		;0x04654

00005da4 <.LVL42>:
  
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    5da4:	e6 93 00 00 	cmp.b	#2,	0(r6)	;r3 As==10
    5da8:	04 24       	jz	$+10     	;abs 0x5db2

00005daa <.Loc.802.1>:
    5daa:	8c 01 86 03 	mova	#66438,	r12	;0x10386
    5dae:	b0 13 dc 47 	calla	#18396		;0x047dc

00005db2 <.L47>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5db2:	9a 00 00 00 	cmpa	#0,	r10	;
    5db6:	04 20       	jnz	$+10     	;abs 0x5dc0

00005db8 <.Loc.804.1>:
    5db8:	8c 01 86 03 	mova	#66438,	r12	;0x10386
    5dbc:	b0 13 dc 47 	calla	#18396		;0x047dc

00005dc0 <.L48>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5dc0:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5dc2:	04 34       	jge	$+10     	;abs 0x5dcc

00005dc4 <.Loc.809.1>:
    5dc4:	8c 01 86 03 	mova	#66438,	r12	;0x10386
    5dc8:	b0 13 dc 47 	calla	#18396		;0x047dc

00005dcc <.L49>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5dcc:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005dd0 <.Loc.815.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    5dd0:	f6 40 03 00 	mov.b	#3,	0(r6)	;
    5dd4:	00 00 

00005dd6 <.Loc.817.1>:
  
  i2cp->buffer = txbuf;
    5dd6:	76 08 08 00 	mova	r8,	8(r6)	;

00005dda <.Loc.820.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    5dda:	cc 0a       	mova	r10,	r12	;
    5ddc:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    5de0:	e8 0c       	adda	r12,	r8	;

00005de2 <.LVL46>:
    5de2:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005de6 <.Loc.821.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5de6:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5dea:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5dee:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005df2 <.Loc.822.1>:
  i2cp->req.size = n;
    5df2:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5df6:	1c 00 

00005df8 <.Loc.823.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    5df8:	b6 40 00 02 	mov	#512,	30(r6)	;#0x0200, 0x001e
    5dfc:	1e 00 

00005dfe <.Loc.824.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5dfe:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5e02:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005e06 <.Loc.826.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5e06:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5e0a:	14 00 0c 00 

00005e0e <.Loc.828.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5e0e:	00 18 f6 40 	movx.a	#23226,	38(r6)	;0x05aba, 0x00026
    5e12:	ba 5a 26 00 

00005e16 <.Loc.830.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    5e16:	ca 06       	mova	r6,	r10	;

00005e18 <.LVL47>:
    5e18:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5e1c:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5e20:	9c 00 00 00 	cmpa	#0,	r12	;
    5e24:	04 24       	jz	$+10     	;abs 0x5e2e

00005e26 <.Loc.830.1>:
    5e26:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5e2a:	00 00 
    5e2c:	03 20       	jnz	$+8      	;abs 0x5e34

00005e2e <.L50>:
    dmaAcquireI(&(i2cp->dma));
    5e2e:	cc 0a       	mova	r10,	r12	;
    5e30:	b0 13 46 56 	calla	#22086		;0x05646

00005e34 <.L51>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5e34:	cd 06       	mova	r6,	r13	;
    5e36:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5e3a:	cc 0a       	mova	r10,	r12	;
    5e3c:	b0 13 14 57 	calla	#22292		;0x05714

00005e40 <.LVL49>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    5e40:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5e44:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005e48 <.Loc.837.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    5e48:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    5e4c:	00 00 

00005e4e <.Loc.840.1>:
  /* IFG is set automatically after START */
  
}
    5e4e:	06 16       	popm.a	#1,	r6	;20-bit words
    5e50:	28 16       	popm.a	#3,	r10	;20-bit words
    5e52:	10 01       	reta			;

00005e54 <i2cMSP430XContinueTransmitMemsetI>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    5e54:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005e56 <.LCFI15>:
    5e56:	06 14       	pushm.a	#1,	r6	;20-bit words

00005e58 <.LCFI16>:
    5e58:	ca 0c       	mova	r12,	r10	;
    5e5a:	49 4d       	mov.b	r13,	r9	;
    5e5c:	c8 0e       	mova	r14,	r8	;
    5e5e:	c6 0f       	mova	r15,	r6	;

00005e60 <.Loc.926.1>:
  
  osalDbgCheckClassI();
    5e60:	b0 13 54 46 	calla	#18004		;0x04654

00005e64 <.LVL68>:
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5e64:	fa 90 03 00 	cmp.b	#3,	0(r10)	;
    5e68:	00 00 
    5e6a:	04 24       	jz	$+10     	;abs 0x5e74

00005e6c <.Loc.928.1>:
    5e6c:	8c 01 2c 03 	mova	#66348,	r12	;0x1032c
    5e70:	b0 13 dc 47 	calla	#18396		;0x047dc

00005e74 <.L80>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5e74:	98 00 00 00 	cmpa	#0,	r8	;
    5e78:	04 20       	jnz	$+10     	;abs 0x5e82

00005e7a <.Loc.930.1>:
    5e7a:	8c 01 2c 03 	mova	#66348,	r12	;0x1032c
    5e7e:	b0 13 dc 47 	calla	#18396		;0x047dc

00005e82 <.L81>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5e82:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5e84:	04 34       	jge	$+10     	;abs 0x5e8e

00005e86 <.Loc.935.1>:
    5e86:	8c 01 2c 03 	mova	#66348,	r12	;0x1032c
    5e8a:	b0 13 dc 47 	calla	#18396		;0x047dc

00005e8e <.L82>:
#endif
  
  i2cp->buffer = value;
    5e8e:	7a 06 08 00 	mova	r6,	8(r10)	;

00005e92 <.Loc.941.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    5e92:	7a 06 14 00 	mova	r6,	20(r10)	; 0x00014

00005e96 <.Loc.942.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5e96:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5e9a:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5e9e:	7a 0c 18 00 	mova	r12,	24(r10)	; 0x00018

00005ea2 <.Loc.943.1>:
  i2cp->req.size = n;
    5ea2:	40 18 8a 48 	movx.w	r8,	28(r10)	; 0x0001c
    5ea6:	1c 00 

00005ea8 <.Loc.944.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5ea8:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

00005eac <.Loc.945.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5eac:	5c 4a 32 00 	mov.b	50(r10),r12	;0x00032
    5eb0:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005eb4 <.Loc.947.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5eb4:	00 18 da 41 	movx.a	20(r1),	12(r10)	;0x00014, 0x0000c
    5eb8:	14 00 0c 00 

00005ebc <.Loc.949.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5ebc:	00 18 fa 40 	movx.a	#23226,	38(r10)	;0x05aba, 0x00026
    5ec0:	ba 5a 26 00 

00005ec4 <.Loc.951.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5ec4:	c8 0a       	mova	r10,	r8	;

00005ec6 <.LVL72>:
    5ec6:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5eca:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5ece:	9c 00 00 00 	cmpa	#0,	r12	;
    5ed2:	04 24       	jz	$+10     	;abs 0x5edc

00005ed4 <.Loc.951.1>:
    5ed4:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5ed8:	00 00 
    5eda:	04 20       	jnz	$+10     	;abs 0x5ee4

00005edc <.L83>:
    5edc:	8c 01 2c 03 	mova	#66348,	r12	;0x1032c
    5ee0:	b0 13 dc 47 	calla	#18396		;0x047dc

00005ee4 <.L84>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5ee4:	cd 0a       	mova	r10,	r13	;
    5ee6:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5eea:	cc 08       	mova	r8,	r12	;
    5eec:	b0 13 14 57 	calla	#22292		;0x05714

00005ef0 <.LVL74>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5ef0:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5ef4:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005ef8 <.Loc.957.1>:
  
}
    5ef8:	06 16       	popm.a	#1,	r6	;20-bit words
    5efa:	28 16       	popm.a	#3,	r10	;20-bit words
    5efc:	10 01       	reta			;

00005efe <i2cMSP430XContinueTransmitI>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5efe:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005f00 <.LCFI17>:
    5f00:	06 14       	pushm.a	#1,	r6	;20-bit words

00005f02 <.LCFI18>:
    5f02:	ca 0c       	mova	r12,	r10	;
    5f04:	49 4d       	mov.b	r13,	r9	;
    5f06:	c8 0e       	mova	r14,	r8	;
    5f08:	c6 0f       	mova	r15,	r6	;

00005f0a <.Loc.962.1>:
  
  osalDbgCheckClassI();
    5f0a:	b0 13 54 46 	calla	#18004		;0x04654

00005f0e <.LVL76>:
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5f0e:	fa 90 03 00 	cmp.b	#3,	0(r10)	;
    5f12:	00 00 
    5f14:	04 24       	jz	$+10     	;abs 0x5f1e

00005f16 <.Loc.964.1>:
    5f16:	8c 01 10 03 	mova	#66320,	r12	;0x10310
    5f1a:	b0 13 dc 47 	calla	#18396		;0x047dc

00005f1e <.L89>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5f1e:	98 00 00 00 	cmpa	#0,	r8	;
    5f22:	04 20       	jnz	$+10     	;abs 0x5f2c

00005f24 <.Loc.966.1>:
    5f24:	8c 01 10 03 	mova	#66320,	r12	;0x10310
    5f28:	b0 13 dc 47 	calla	#18396		;0x047dc

00005f2c <.L90>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5f2c:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5f2e:	04 34       	jge	$+10     	;abs 0x5f38

00005f30 <.Loc.971.1>:
    5f30:	8c 01 10 03 	mova	#66320,	r12	;0x10310
    5f34:	b0 13 dc 47 	calla	#18396		;0x047dc

00005f38 <.L91>:
#endif
  
  i2cp->buffer = txbuf;
    5f38:	7a 06 08 00 	mova	r6,	8(r10)	;

00005f3c <.Loc.977.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    5f3c:	7a 06 14 00 	mova	r6,	20(r10)	; 0x00014

00005f40 <.Loc.978.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5f40:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5f44:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5f48:	7a 0c 18 00 	mova	r12,	24(r10)	; 0x00018

00005f4c <.Loc.979.1>:
  i2cp->req.size = n;
    5f4c:	40 18 8a 48 	movx.w	r8,	28(r10)	; 0x0001c
    5f50:	1c 00 

00005f52 <.Loc.980.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    5f52:	ba 40 00 03 	mov	#768,	30(r10)	;#0x0300, 0x001e
    5f56:	1e 00 

00005f58 <.Loc.981.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5f58:	5c 4a 32 00 	mov.b	50(r10),r12	;0x00032
    5f5c:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005f60 <.Loc.983.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5f60:	00 18 da 41 	movx.a	20(r1),	12(r10)	;0x00014, 0x0000c
    5f64:	14 00 0c 00 

00005f68 <.Loc.985.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5f68:	00 18 fa 40 	movx.a	#23226,	38(r10)	;0x05aba, 0x00026
    5f6c:	ba 5a 26 00 

00005f70 <.Loc.987.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5f70:	c8 0a       	mova	r10,	r8	;

00005f72 <.LVL80>:
    5f72:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5f76:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5f7a:	9c 00 00 00 	cmpa	#0,	r12	;
    5f7e:	04 24       	jz	$+10     	;abs 0x5f88

00005f80 <.Loc.987.1>:
    5f80:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5f84:	00 00 
    5f86:	04 20       	jnz	$+10     	;abs 0x5f90

00005f88 <.L92>:
    5f88:	8c 01 10 03 	mova	#66320,	r12	;0x10310
    5f8c:	b0 13 dc 47 	calla	#18396		;0x047dc

00005f90 <.L93>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5f90:	cd 0a       	mova	r10,	r13	;
    5f92:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5f96:	cc 08       	mova	r8,	r12	;
    5f98:	b0 13 14 57 	calla	#22292		;0x05714

00005f9c <.LVL82>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5f9c:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5fa0:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005fa4 <.Loc.993.1>:
  
}
    5fa4:	06 16       	popm.a	#1,	r6	;20-bit words
    5fa6:	28 16       	popm.a	#3,	r10	;20-bit words
    5fa8:	10 01       	reta			;

00005faa <i2cMSP430XEndTransferI>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    5faa:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005fac <.LCFI19>:
    5fac:	b1 00 02 00 	suba	#2,	r1	;

00005fb0 <.LCFI20>:
    5fb0:	ca 0c       	mova	r12,	r10	;

00005fb2 <.Loc.997.1>:
  
  osalDbgCheckClassI();
    5fb2:	b0 13 54 46 	calla	#18004		;0x04654

00005fb6 <.LVL84>:
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
    5fb6:	6c 4a       	mov.b	@r10,	r12	;
    5fb8:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    5fbc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5fbe:	4d 9c       	cmp.b	r12,	r13	;
    5fc0:	04 2c       	jc	$+10     	;abs 0x5fca

00005fc2 <.Loc.999.1>:
    5fc2:	8c 01 f9 02 	mova	#66297,	r12	;0x102f9
    5fc6:	b0 13 dc 47 	calla	#18396		;0x047dc

00005fca <.L98>:
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    5fca:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5fce:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005fd2 <.Loc.1005.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    5fd2:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    5fd6:	2a 20       	jnz	$+86     	;abs 0x602c

00005fd8 <.L111>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
    
    /* Wait for last RX byte */
    while (!(i2cp->regs->ifg & UCRXIFG0));
    5fd8:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    5fdc:	2c 00 
    5fde:	fc 27       	jz	$-6      	;abs 0x5fd8
    5fe0:	3e 0a 18 00 	mova	24(r10),r14	;0x00018

00005fe4 <.Loc.1015.1>:
    
    if (i2cp->req.addr_mode) {
    5fe4:	8a 93 1e 00 	cmp	#0,	30(r10)	;r3 As==00, 0x001e
    5fe8:	1b 24       	jz	$+56     	;abs 0x6020

00005fea <.Loc.1016.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    5fea:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    5fee:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    5ff2:	1c 00 
    5ff4:	ec 0e       	adda	r14,	r12	;
    5ff6:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00005ffa <.L102>:
    }
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
    
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    5ffa:	3c 0a 10 00 	mova	16(r10),r12	;0x00010

00005ffe <.L103>:
    5ffe:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    6002:	fd 23       	jnz	$-4      	;abs 0x5ffe

00006004 <.Loc.1024.1>:
      
    if (i2cp->regs->ifg & UCRXIFG0) {
    6004:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    6008:	2c 00 
    600a:	04 24       	jz	$+10     	;abs 0x6014

0000600c <.LBB66>:
      volatile uint8_t throwaway;
      throwaway = i2cp->regs->rxbuf;
    600c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6010:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00006014 <.L105>:
  }
  else {
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
  }
  
  i2cp->state = I2C_READY;
    6014:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00006018 <.Loc.1034.1>:
}
    6018:	a1 00 02 00 	adda	#2,	r1	;
    601c:	0a 16       	popm.a	#1,	r10	;20-bit words
    601e:	10 01       	reta			;

00006020 <.L101>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    6020:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6024:	ce 4c 00 00 	mov.b	r12,	0(r14)	;
    6028:	80 00 fa 5f 	mova	#24570,	r0	;0x05ffa

0000602c <.L108>:
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    602c:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    6030:	fd 23       	jnz	$-4      	;abs 0x602c
    6032:	80 00 14 60 	mova	#24596,	r0	;0x06014

00006036 <rx_async_callback>:
void rx_async_callback(void * args) {
    6036:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006038 <.LCFI21>:
    6038:	08 14       	pushm.a	#1,	r8	;20-bit words

0000603a <.LCFI22>:
    603a:	ca 0c       	mova	r12,	r10	;

0000603c <.LVL87>:
  if (NULL != i2cp->callback) {
    603c:	38 0c 0c 00 	mova	12(r12),r8	;0x0000c
    6040:	98 00 00 00 	cmpa	#0,	r8	;
    6044:	08 24       	jz	$+18     	;abs 0x6056

00006046 <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    6046:	1e 4c 1c 00 	mov	28(r12),r14	;0x0001c
    604a:	3d 0c 08 00 	mova	8(r12),	r13	;
    604e:	48 13       	calla	r8		;

00006050 <.L113>:
}
    6050:	08 16       	popm.a	#1,	r8	;20-bit words
    6052:	0a 16       	popm.a	#1,	r10	;20-bit words
    6054:	10 01       	reta			;

00006056 <.L114>:
    i2cMSP430XEndTransferI(i2cp);
    6056:	b0 13 aa 5f 	calla	#24490		;0x05faa

0000605a <.LVL89>:
}
    605a:	80 00 50 60 	mova	#24656,	r0	;0x06050

0000605e <rx_cb>:
static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
}

static void rx_cb(void * arg){
    605e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006060 <.LCFI0>:
    6060:	ca 0c       	mova	r12,	r10	;

00006062 <.LVL1>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    6062:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    6066:	3e 0c 04 00 	mova	4(r12),	r14	;
    606a:	3e 0e 08 00 	mova	8(r14),	r14	;
    606e:	9e 00 00 00 	cmpa	#0,	r14	;
    6072:	01 24       	jz	$+4      	;abs 0x6076

00006074 <.Loc.204.1>:
    6074:	4e 13       	calla	r14		;

00006076 <.L2>:
    6076:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    607a:	06 20       	jnz	$+14     	;abs 0x6088

0000607c <.Loc.204.1>:
    607c:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    6080:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00006084 <.LBB39>:
  uartp->regs->ie |= UCRXIE;
    6084:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00006088 <.L3>:
  chSysLockFromISR();
    6088:	b0 13 a6 45 	calla	#17830		;0x045a6

0000608c <.LBB43>:
  chThdResumeI(trp, msg);
    608c:	4d 43       	clr.b	r13		;
    608e:	cc 0a       	mova	r10,	r12	;
    6090:	ac 00 0a 00 	adda	#10,	r12	;0x0000a

00006094 <.LVL6>:
    6094:	b0 13 30 4a 	calla	#18992		;0x04a30

00006098 <.LBB45>:
  chSysUnlockFromISR();
    6098:	b0 13 d0 45 	calla	#17872		;0x045d0

0000609c <.LBE45>:
}
    609c:	0a 16       	popm.a	#1,	r10	;20-bit words
    609e:	10 01       	reta			;

000060a0 <UCBRS>:
  if (frac < 529)
    60a0:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    60a4:	0d 9c       	cmp	r12,	r13	;
    60a6:	8b 2c       	jc	$+280    	;abs 0x61be

000060a8 <.Loc.84.1>:
  else if (frac < 715)
    60a8:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    60ac:	0d 9c       	cmp	r12,	r13	;
    60ae:	8a 2c       	jc	$+278    	;abs 0x61c4

000060b0 <.Loc.86.1>:
  else if (frac < 835)
    60b0:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    60b4:	0d 9c       	cmp	r12,	r13	;
    60b6:	89 2c       	jc	$+276    	;abs 0x61ca

000060b8 <.Loc.88.1>:
  else if (frac < 1001)
    60b8:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    60bc:	0d 9c       	cmp	r12,	r13	;
    60be:	88 2c       	jc	$+274    	;abs 0x61d0

000060c0 <.Loc.90.1>:
  else if (frac < 1252)
    60c0:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    60c4:	0d 9c       	cmp	r12,	r13	;
    60c6:	87 2c       	jc	$+272    	;abs 0x61d6

000060c8 <.Loc.92.1>:
  else if (frac < 1430)
    60c8:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    60cc:	0d 9c       	cmp	r12,	r13	;
    60ce:	86 2c       	jc	$+270    	;abs 0x61dc

000060d0 <.Loc.94.1>:
  else if (frac < 1670)
    60d0:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    60d4:	0d 9c       	cmp	r12,	r13	;
    60d6:	86 2c       	jc	$+270    	;abs 0x61e4

000060d8 <.Loc.96.1>:
  else if (frac < 2147)
    60d8:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    60dc:	0d 9c       	cmp	r12,	r13	;
    60de:	86 2c       	jc	$+270    	;abs 0x61ec

000060e0 <.Loc.98.1>:
  else if (frac < 2224)
    60e0:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    60e4:	0d 9c       	cmp	r12,	r13	;
    60e6:	86 2c       	jc	$+270    	;abs 0x61f4

000060e8 <.Loc.100.1>:
  else if (frac < 2503)
    60e8:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    60ec:	0d 9c       	cmp	r12,	r13	;
    60ee:	86 2c       	jc	$+270    	;abs 0x61fc

000060f0 <.Loc.102.1>:
  else if (frac < 3000)
    60f0:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    60f4:	0d 9c       	cmp	r12,	r13	;
    60f6:	86 2c       	jc	$+270    	;abs 0x6204

000060f8 <.LBB49>:
  else if (frac < 3335)
    60f8:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    60fc:	0d 9c       	cmp	r12,	r13	;
    60fe:	86 2c       	jc	$+270    	;abs 0x620c

00006100 <.Loc.106.1>:
  else if (frac < 3575)
    6100:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    6104:	0d 9c       	cmp	r12,	r13	;
    6106:	86 2c       	jc	$+270    	;abs 0x6214

00006108 <.Loc.108.1>:
  else if (frac < 3753)
    6108:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    610c:	0d 9c       	cmp	r12,	r13	;
    610e:	86 2c       	jc	$+270    	;abs 0x621c

00006110 <.Loc.110.1>:
  else if (frac < 4003)
    6110:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    6114:	0d 9c       	cmp	r12,	r13	;
    6116:	86 2c       	jc	$+270    	;abs 0x6224

00006118 <.Loc.112.1>:
  else if (frac < 4286)
    6118:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    611c:	0d 9c       	cmp	r12,	r13	;
    611e:	86 2c       	jc	$+270    	;abs 0x622c

00006120 <.Loc.114.1>:
  else if (frac < 4378)
    6120:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    6124:	0d 9c       	cmp	r12,	r13	;
    6126:	86 2c       	jc	$+270    	;abs 0x6234

00006128 <.Loc.116.1>:
  else if (frac < 5002)
    6128:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    612c:	0d 9c       	cmp	r12,	r13	;
    612e:	86 2c       	jc	$+270    	;abs 0x623c

00006130 <.Loc.118.1>:
  else if (frac < 5715)
    6130:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    6134:	0d 9c       	cmp	r12,	r13	;
    6136:	86 2c       	jc	$+270    	;abs 0x6244

00006138 <.Loc.120.1>:
  else if (frac < 6003)
    6138:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    613c:	0d 9c       	cmp	r12,	r13	;
    613e:	86 2c       	jc	$+270    	;abs 0x624c

00006140 <.Loc.122.1>:
  else if (frac < 6254)
    6140:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    6144:	0d 9c       	cmp	r12,	r13	;
    6146:	86 2c       	jc	$+270    	;abs 0x6254

00006148 <.Loc.124.1>:
  else if (frac < 6432)
    6148:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    614c:	0d 9c       	cmp	r12,	r13	;
    614e:	86 2c       	jc	$+270    	;abs 0x625c

00006150 <.Loc.126.1>:
  else if (frac < 6667)
    6150:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    6154:	0d 9c       	cmp	r12,	r13	;
    6156:	86 2c       	jc	$+270    	;abs 0x6264

00006158 <.Loc.128.1>:
  else if (frac < 7001)
    6158:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    615c:	0d 9c       	cmp	r12,	r13	;
    615e:	86 2c       	jc	$+270    	;abs 0x626c

00006160 <.Loc.130.1>:
  else if (frac < 7147)
    6160:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    6164:	0d 9c       	cmp	r12,	r13	;
    6166:	86 2c       	jc	$+270    	;abs 0x6274

00006168 <.Loc.132.1>:
  else if (frac < 7503)
    6168:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    616c:	0d 9c       	cmp	r12,	r13	;
    616e:	86 2c       	jc	$+270    	;abs 0x627c

00006170 <.Loc.134.1>:
  else if (frac < 7861)
    6170:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    6174:	0d 9c       	cmp	r12,	r13	;
    6176:	86 2c       	jc	$+270    	;abs 0x6284

00006178 <.Loc.136.1>:
  else if (frac < 8004)
    6178:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    617c:	0d 9c       	cmp	r12,	r13	;
    617e:	86 2c       	jc	$+270    	;abs 0x628c

00006180 <.Loc.138.1>:
  else if (frac < 8333)
    6180:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    6184:	0d 9c       	cmp	r12,	r13	;
    6186:	86 2c       	jc	$+270    	;abs 0x6294

00006188 <.Loc.140.1>:
  else if (frac < 8464)
    6188:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    618c:	0d 9c       	cmp	r12,	r13	;
    618e:	86 2c       	jc	$+270    	;abs 0x629c

00006190 <.Loc.142.1>:
  else if (frac < 8572)
    6190:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    6194:	0d 9c       	cmp	r12,	r13	;
    6196:	86 2c       	jc	$+270    	;abs 0x62a4

00006198 <.Loc.144.1>:
  else if (frac < 8751)
    6198:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    619c:	0d 9c       	cmp	r12,	r13	;
    619e:	86 2c       	jc	$+270    	;abs 0x62ac

000061a0 <.Loc.146.1>:
  else if (frac < 9004)
    61a0:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    61a4:	0d 9c       	cmp	r12,	r13	;
    61a6:	86 2c       	jc	$+270    	;abs 0x62b4

000061a8 <.Loc.148.1>:
  else if (frac < 9170)
    61a8:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    61ac:	0d 9c       	cmp	r12,	r13	;
    61ae:	86 2c       	jc	$+270    	;abs 0x62bc

000061b0 <.Loc.150.1>:
  else if (frac < 9288)
    61b0:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    61b4:	0d 9c       	cmp	r12,	r13	;
    61b6:	86 2c       	jc	$+270    	;abs 0x62c4

000061b8 <.Loc.153.1>:
    return 0xFE;
    61b8:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000061bc <.L8>:
}
    61bc:	10 01       	reta			;

000061be <.L9>:
    return 0x00;
    61be:	4c 43       	clr.b	r12		;

000061c0 <.LVL13>:
    61c0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061c4 <.L10>:
    return 0x01;
    61c4:	5c 43       	mov.b	#1,	r12	;r3 As==01

000061c6 <.LVL15>:
    61c6:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061ca <.L11>:
    return 0x02;
    61ca:	6c 43       	mov.b	#2,	r12	;r3 As==10

000061cc <.LVL17>:
    61cc:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061d0 <.L12>:
    return 0x04;
    61d0:	6c 42       	mov.b	#4,	r12	;r2 As==10

000061d2 <.LVL19>:
    61d2:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061d6 <.L13>:
    return 0x08;
    61d6:	7c 42       	mov.b	#8,	r12	;r2 As==11

000061d8 <.LVL21>:
    61d8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061dc <.L14>:
    return 0x10;
    61dc:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000061e0 <.LVL23>:
    61e0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061e4 <.L15>:
    return 0x20;
    61e4:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000061e8 <.LVL25>:
    61e8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061ec <.L16>:
    return 0x11;
    61ec:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000061f0 <.LVL27>:
    61f0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061f4 <.L17>:
    return 0x21;
    61f4:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

000061f8 <.LVL29>:
    61f8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000061fc <.L18>:
    return 0x22;
    61fc:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00006200 <.LVL31>:
    6200:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006204 <.L19>:
    return 0x44;
    6204:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00006208 <.LVL33>:
    6208:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000620c <.L20>:
    return 0x25;
    620c:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00006210 <.LVL35>:
    6210:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006214 <.L21>:
    return 0x49;
    6214:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00006218 <.LVL37>:
    6218:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000621c <.L22>:
    return 0x4A;
    621c:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

00006220 <.LVL39>:
    6220:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006224 <.L23>:
    return 0x52;
    6224:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00006228 <.LVL41>:
    6228:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000622c <.L24>:
    return 0x92;
    622c:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00006230 <.LVL43>:
    6230:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006234 <.L25>:
    return 0x53;
    6234:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00006238 <.LVL45>:
    6238:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000623c <.L26>:
    return 0x55;
    623c:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00006240 <.LVL47>:
    6240:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006244 <.L27>:
    return 0xAA;
    6244:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00006248 <.LVL49>:
    6248:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000624c <.L28>:
    return 0x6B;
    624c:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00006250 <.LVL51>:
    6250:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006254 <.L29>:
    return 0xAD;
    6254:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00006258 <.LVL53>:
    6258:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000625c <.L30>:
    return 0xB5;
    625c:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

00006260 <.LVL55>:
    6260:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006264 <.L31>:
    return 0xB6;
    6264:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00006268 <.LVL57>:
    6268:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000626c <.L32>:
    return 0xD6;
    626c:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00006270 <.LVL59>:
    6270:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006274 <.L33>:
    return 0xB7;
    6274:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00006278 <.LVL61>:
    6278:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000627c <.L34>:
    return 0xBB;
    627c:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

00006280 <.LVL63>:
    6280:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006284 <.L35>:
    return 0xDD;
    6284:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00006288 <.LVL65>:
    6288:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000628c <.L36>:
    return 0xED;
    628c:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00006290 <.LVL67>:
    6290:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

00006294 <.L37>:
    return 0xEE;
    6294:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00006298 <.LVL69>:
    6298:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

0000629c <.L38>:
    return 0xBF;
    629c:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

000062a0 <.LVL71>:
    62a0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062a4 <.L39>:
    return 0xDF;
    62a4:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

000062a8 <.LVL73>:
    62a8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062ac <.L40>:
    return 0xEF;
    62ac:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

000062b0 <.LVL75>:
    62b0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062b4 <.L41>:
    return 0xF7;
    62b4:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

000062b8 <.LVL77>:
    62b8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062bc <.L42>:
    return 0xFB;
    62bc:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

000062c0 <.LVL79>:
    62c0:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062c4 <.L43>:
    return 0xFD;
    62c4:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

000062c8 <.LVL81>:
    62c8:	80 00 bc 61 	mova	#25020,	r0	;0x061bc

000062cc <tx_cb>:
static void tx_cb(void * arg) {
    62cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000062ce <.LCFI1>:
    62ce:	ca 0c       	mova	r12,	r10	;

000062d0 <.LVL83>:
  _uart_tx1_isr_code(uartp);
    62d0:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    62d4:	3e 0c 04 00 	mova	4(r12),	r14	;
    62d8:	0e 0e       	mova	@r14,	r14	;
    62da:	9e 00 00 00 	cmpa	#0,	r14	;
    62de:	01 24       	jz	$+4      	;abs 0x62e2

000062e0 <.Loc.183.1>:
    62e0:	4e 13       	calla	r14		;

000062e2 <.L45>:
    62e2:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    62e6:	02 20       	jnz	$+6      	;abs 0x62ec

000062e8 <.Loc.183.1>:
    62e8:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00

000062ec <.L46>:
    62ec:	ca 93 08 00 	cmp.b	#0,	8(r10)	;r3 As==00
    62f0:	0a 24       	jz	$+22     	;abs 0x6306

000062f2 <.LBB67>:
  chSysLockFromISR();
    62f2:	b0 13 a6 45 	calla	#17830		;0x045a6

000062f6 <.LBB69>:
  chThdResumeI(trp, msg);
    62f6:	4d 43       	clr.b	r13		;
    62f8:	cc 0a       	mova	r10,	r12	;
    62fa:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

000062fe <.LVL86>:
    62fe:	b0 13 30 4a 	calla	#18992		;0x04a30

00006302 <.LBB71>:
  chSysUnlockFromISR();
    6302:	b0 13 d0 45 	calla	#17872		;0x045d0

00006306 <.L47>:
  if (uartp->txstate == UART_TX_IDLE) {
    6306:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    630a:	0a 20       	jnz	$+22     	;abs 0x6320

0000630c <.LBB73>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    630c:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00006310 <.L49>:
    6310:	40 18 bc b2 	bitx.w	#8,	28(r12)	;r2 As==11, 0x0001c
    6314:	1c 00 
    6316:	fc 27       	jz	$-6      	;abs 0x6310

00006318 <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    6318:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

0000631c <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    631c:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

00006320 <.L44>:
}
    6320:	0a 16       	popm.a	#1,	r10	;20-bit words
    6322:	10 01       	reta			;

00006324 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
    6324:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006326 <.LCFI3>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
#endif
  
#if MSP430X_UART_USE_UARTA1 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA1);
    6326:	8a 01 b0 14 	mova	#70832,	r10	;0x114b0
    632a:	cc 0a       	mova	r10,	r12	;
    632c:	b0 13 0c 52 	calla	#21004		;0x0520c

00006330 <.LVL114>:
  UARTDA1.regs = (msp430x_uart_reg_t  *)(&UCA1CTLW0);
    6330:	00 18 fa 40 	movx.a	#1504,	22(r10)	;0x005e0, 0x00016
    6334:	e0 05 16 00 

00006338 <.Loc.463.1>:
  UARTDA1.freq = MSP430X_UARTA1_CLK_FREQ;
    6338:	ba 40 00 24 	mov	#9216,	18(r10)	;#0x2400, 0x0012
    633c:	12 00 
    633e:	ba 40 f4 00 	mov	#244,	20(r10)	;#0x00f4, 0x0014
    6342:	14 00 

00006344 <.Loc.464.1>:
  UARTDA1.dmareq_tx.dest_addr = (void*)(&UCA1TXBUF);
    6344:	00 18 fa 40 	movx.a	#1518,	30(r10)	;0x005ee, 0x0001e
    6348:	ee 05 1e 00 

0000634c <.Loc.465.1>:
  UARTDA1.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    634c:	ba 40 00 03 	mov	#768,	36(r10)	;#0x0300, 0x0024
    6350:	24 00 

00006352 <.Loc.466.1>:
  UARTDA1.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    6352:	ba 40 c0 00 	mov	#192,	38(r10)	;#0x00c0, 0x0026
    6356:	26 00 

00006358 <.Loc.467.1>:
  UARTDA1.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    6358:	8a 43 28 00 	mov	#0,	40(r10)	;r3 As==00, 0x0028

0000635c <.Loc.468.1>:
  UARTDA1.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA1TXIFG);
    635c:	ba 40 11 00 	mov	#17,	42(r10)	;#0x0011, 0x002a
    6360:	2a 00 

00006362 <.Loc.469.1>:
  UARTDA1.dmareq_rx.source_addr = (void*)(&UCA1RXBUF);
    6362:	00 18 fa 40 	movx.a	#1516,	52(r10)	;0x005ec, 0x00034
    6366:	ec 05 34 00 

0000636a <.Loc.470.1>:
  UARTDA1.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    636a:	ba 40 00 0c 	mov	#3072,	62(r10)	;#0x0c00, 0x003e
    636e:	3e 00 

00006370 <.Loc.471.1>:
  UARTDA1.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    6370:	ba 40 c0 00 	mov	#192,	64(r10)	;#0x00c0, 0x0040
    6374:	40 00 

00006376 <.Loc.472.1>:
  UARTDA1.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    6376:	8a 43 42 00 	mov	#0,	66(r10)	;r3 As==00, 0x0042

0000637a <.Loc.473.1>:
  UARTDA1.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA1RXIFG);
    637a:	ba 40 10 00 	mov	#16,	68(r10)	;#0x0010, 0x0044
    637e:	44 00 

00006380 <.Loc.512.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    6380:	0a 16       	popm.a	#1,	r10	;20-bit words
    6382:	10 01       	reta			;

00006384 <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    6384:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006386 <.LCFI4>:
    6386:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

0000638a <.LCFI5>:
    638a:	ca 0c       	mova	r12,	r10	;

0000638c <.Loc.523.1>:

  if (uartp->state != UART_STOP) {
    638c:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    6390:	16 24       	jz	$+46     	;abs 0x63be

00006392 <.Loc.525.1>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    6392:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00006396 <.L103>:
    6396:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    639a:	1c 00 
    639c:	fc 27       	jz	$-6      	;abs 0x6396

0000639e <.Loc.528.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    639e:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    63a2:	05 24       	jz	$+12     	;abs 0x63ae

000063a4 <.Loc.529.1>:
      dmaReleaseX(&(uartp->dma_tx));
    63a4:	cc 0a       	mova	r10,	r12	;
    63a6:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    63aa:	b0 13 94 57 	calla	#22420		;0x05794

000063ae <.L104>:
    }
    if (uartp->dma_acquired_rx) {
    63ae:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    63b2:	05 24       	jz	$+12     	;abs 0x63be

000063b4 <.Loc.532.1>:
      dmaReleaseX(&(uartp->dma_rx));
    63b4:	cc 0a       	mova	r10,	r12	;
    63b6:	ac 00 58 00 	adda	#88,	r12	;0x00058
    63ba:	b0 13 94 57 	calla	#22420		;0x05794

000063be <.L102>:
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    63be:	34 0a 16 00 	mova	22(r10),r4	;0x00016
    63c2:	94 d3 00 00 	bis	#1,	0(r4)	;r3 As==01

000063c6 <.LBB91>:
  uint16_t n = uartp->freq / uartp->config->baud;
    63c6:	91 4a 12 00 	mov	18(r10),10(r1)	;0x00012, 0x000a
    63ca:	0a 00 
    63cc:	91 4a 14 00 	mov	20(r10),12(r1)	;0x00014, 0x000c
    63d0:	0c 00 
    63d2:	35 0a 04 00 	mova	4(r10),	r5	;
    63d6:	91 45 14 00 	mov	20(r5),	6(r1)	;0x00014
    63da:	06 00 
    63dc:	91 45 16 00 	mov	22(r5),	8(r1)	;0x00016
    63e0:	08 00 
    63e2:	8b 00 c8 cc 	mova	#52424,	r11	;0x0ccc8
    63e6:	1e 41 06 00 	mov	6(r1),	r14	;
    63ea:	1f 41 08 00 	mov	8(r1),	r15	;
    63ee:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    63f2:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    63f6:	71 0b 00 00 	mova	r11,	0(r1)	;
    63fa:	4b 13       	calla	r11		;

000063fc <.LVL120>:
    63fc:	07 4c       	mov	r12,	r7	;
    63fe:	81 4c 04 00 	mov	r12,	4(r1)	;

00006402 <.Loc.158.1>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    6402:	86 00 b4 ce 	mova	#52916,	r6	;0x0ceb4
    6406:	1e 41 06 00 	mov	6(r1),	r14	;
    640a:	1f 41 08 00 	mov	8(r1),	r15	;
    640e:	4d 43       	clr.b	r13		;
    6410:	46 13       	calla	r6		;

00006412 <.LVL122>:
    6412:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    6416:	4f 43       	clr.b	r15		;
    6418:	18 41 0a 00 	mov	10(r1),	r8	;0x0000a
    641c:	19 41 0c 00 	mov	12(r1),	r9	;0x0000c
    6420:	40 18 08 8c 	subx.w	r12,	r8	;
    6424:	40 18 09 7d 	subcx.w	r13,	r9	;
    6428:	0c 48       	mov	r8,	r12	;
    642a:	0d 49       	mov	r9,	r13	;
    642c:	46 13       	calla	r6		;

0000642e <.LVL123>:
    642e:	1e 41 06 00 	mov	6(r1),	r14	;
    6432:	1f 41 08 00 	mov	8(r1),	r15	;
    6436:	0b 01       	mova	@r1,	r11	;
    6438:	4b 13       	calla	r11		;

0000643a <.LVL124>:
    643a:	8e 00 a0 60 	mova	#24736,	r14	;0x060a0

0000643e <.Loc.159.1>:
  if (n > 16) {
    643e:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    6442:	09 97       	cmp	r7,	r9	;
    6444:	90 2c       	jc	$+290    	;abs 0x6566

00006446 <.Loc.160.1>:
    uartp->regs->brw = (n >> 4);
    6446:	0d 47       	mov	r7,	r13	;
    6448:	5d 0f       	rrum	#4,	r13	;
    644a:	84 4d 06 00 	mov	r13,	6(r4)	;

0000644e <.Loc.162.1>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    644e:	4e 13       	calla	r14		;

00006450 <.LVL125>:
    6450:	09 47       	mov	r7,	r9	;
    6452:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    6456:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    645a:	19 d3       	bis	#1,	r9	;r3 As==01
    645c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6460:	09 dc       	bis	r12,	r9	;
    6462:	84 49 08 00 	mov	r9,	8(r4)	;

00006466 <.L107>:
  set_baud(uartp);
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    6466:	5c 45 18 00 	mov.b	24(r5),	r12	;0x00018
    646a:	5c 0f       	rrum	#4,	r12	;
    646c:	5c 03       	rrum	#1,	r12	;
    646e:	5c f3       	and.b	#1,	r12	;r3 As==01
    6470:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    6474:	84 4c 10 00 	mov	r12,	16(r4)	; 0x0010

00006478 <.Loc.543.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    6478:	5d 45 19 00 	mov.b	25(r5),	r13	;0x00019
    647c:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    6480:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6482:	0c 9d       	cmp	r13,	r12	;
    6484:	79 38       	jl	$+244    	;abs 0x6578

00006486 <.Loc.544.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    6486:	cc 0a       	mova	r10,	r12	;
    6488:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    648c:	b0 13 b8 56 	calla	#22200		;0x056b8

00006490 <.LVL127>:
    6490:	c8 0c       	mova	r12,	r8	;

00006492 <.LVL128>:
    osalDbgAssert(!b, "stream already allocated");
    6492:	9c 00 00 00 	cmpa	#0,	r12	;
    6496:	04 24       	jz	$+10     	;abs 0x64a0

00006498 <.Loc.545.1>:
    6498:	8c 01 f7 03 	mova	#66551,	r12	;0x103f7
    649c:	b0 13 dc 47 	calla	#18396		;0x047dc

000064a0 <.L109>:
    uartp->dma_acquired_tx = !b;
    64a0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    64a2:	98 00 00 00 	cmpa	#0,	r8	;
    64a6:	01 24       	jz	$+4      	;abs 0x64aa
    64a8:	4c 43       	clr.b	r12		;

000064aa <.L110>:
    64aa:	ca 4c 62 00 	mov.b	r12,	98(r10)	; 0x0062

000064ae <.L111>:
  }
  else {
    uartp->dma_acquired_tx = false;
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    64ae:	3c 0a 04 00 	mova	4(r10),	r12	;
    64b2:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    64b6:	5d 0f       	rrum	#4,	r13	;
    64b8:	68 43       	mov.b	#2,	r8	;r3 As==10
    64ba:	08 9d       	cmp	r13,	r8	;
    64bc:	61 38       	jl	$+196    	;abs 0x6580

000064be <.Loc.552.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    64be:	cc 0a       	mova	r10,	r12	;
    64c0:	ac 00 58 00 	adda	#88,	r12	;0x00058
    64c4:	b0 13 b8 56 	calla	#22200		;0x056b8

000064c8 <.LVL131>:
    64c8:	c8 0c       	mova	r12,	r8	;

000064ca <.LVL132>:
    osalDbgAssert(!b, "stream already allocated");
    64ca:	9c 00 00 00 	cmpa	#0,	r12	;
    64ce:	04 24       	jz	$+10     	;abs 0x64d8

000064d0 <.Loc.553.1>:
    64d0:	8c 01 f7 03 	mova	#66551,	r12	;0x103f7
    64d4:	b0 13 dc 47 	calla	#18396		;0x047dc

000064d8 <.L113>:
    uartp->dma_acquired_rx = !b;
    64d8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    64da:	98 00 00 00 	cmpa	#0,	r8	;
    64de:	01 24       	jz	$+4      	;abs 0x64e2
    64e0:	4c 43       	clr.b	r12		;

000064e2 <.L114>:
    64e2:	ca 4c 63 00 	mov.b	r12,	99(r10)	; 0x0063

000064e6 <.L115>:
  else {
    uartp->dma_acquired_rx = false;
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    64e6:	00 18 fa 40 	movx.a	#25292,	44(r10)	;0x062cc, 0x0002c
    64ea:	cc 62 2c 00 

000064ee <.Loc.562.1>:
  uartp->dmareq_tx.callback.args = uartp;
    64ee:	7a 0a 30 00 	mova	r10,	48(r10)	; 0x00030

000064f2 <.Loc.563.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    64f2:	00 18 fa 40 	movx.a	#24670,	70(r10)	;0x0605e, 0x00046
    64f6:	5e 60 46 00 

000064fa <.Loc.564.1>:
  uartp->dmareq_rx.callback.args = uartp;
    64fa:	7a 0a 4a 00 	mova	r10,	74(r10)	; 0x0004a

000064fe <.Loc.578.1>:
        (UCRXEIE) | (UCBRKIE));

  }
#endif
#if MSP430X_UART_USE_UARTA1 == TRUE
  if (&UARTDA1 == uartp) {
    64fe:	9a 01 b0 14 	cmpa	#70832,	r10	;0x114b0
    6502:	29 20       	jnz	$+84     	;abs 0x6556

00006504 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6504:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    6508:	38 0a 04 00 	mova	4(r10),	r8	;

0000650c <.Loc.583.1>:
        (uartp->config->order << 13) | 
        (uartp->config->char_size << 12) | 
        (uartp->config->stop_bits << 11) |
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    650c:	5e 48 18 00 	mov.b	24(r8),	r14	;0x00018
    6510:	0f 4e       	mov	r14,	r15	;
    6512:	5f 0f       	rrum	#4,	r15	;
    6514:	5f 03       	rrum	#1,	r15	;
    6516:	5f f3       	and.b	#1,	r15	;r3 As==01

00006518 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6518:	0d 4e       	mov	r14,	r13	;
    651a:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;

0000651e <.Loc.580.1>:
        (uartp->config->order << 13) | 
    651e:	09 4e       	mov	r14,	r9	;
    6520:	4a 18 09 59 	rpt #11 { rlax.w	r9		;
    6524:	39 f0 00 20 	and	#8192,	r9	;#0x2000

00006528 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6528:	0d d9       	bis	r9,	r13	;

0000652a <.Loc.585.1>:
        (MSP430X_UARTA1_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));
    652a:	3d d0 b0 00 	bis	#176,	r13	;#0x00b0

0000652e <.Loc.581.1>:
        (uartp->config->char_size << 12) | 
    652e:	09 4e       	mov	r14,	r9	;
    6530:	48 18 09 59 	rpt #9 { rlax.w	r9		;
    6534:	39 f0 00 10 	and	#4096,	r9	;#0x1000

00006538 <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    6538:	0d d9       	bis	r9,	r13	;

0000653a <.Loc.582.1>:
        (uartp->config->stop_bits << 11) |
    653a:	46 18 0e 5e 	rpt #7 { rlax.w	r14		;
    653e:	3e f0 00 08 	and	#2048,	r14	;#0x0800

00006542 <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    6542:	0d de       	bis	r14,	r13	;

00006544 <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    6544:	0e 4f       	mov	r15,	r14	;
    6546:	49 18 0e 5e 	rpt #10 { rlax.w	r14		;

0000654a <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    654a:	0d de       	bis	r14,	r13	;

0000654c <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    654c:	48 18 0f 5f 	rpt #9 { rlax.w	r15		;

00006550 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6550:	0d df       	bis	r15,	r13	;
    6552:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006556 <.L116>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    6556:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    655a:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

0000655e <.Loc.614.1>:
}
    655e:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    6562:	64 16       	popm.a	#7,	r10	;20-bit words
    6564:	10 01       	reta			;

00006566 <.L106>:
    uartp->regs->brw = n;
    6566:	84 47 06 00 	mov	r7,	6(r4)	;

0000656a <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    656a:	4e 13       	calla	r14		;

0000656c <.LVL136>:
    656c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6570:	84 4c 08 00 	mov	r12,	8(r4)	;
    6574:	80 00 66 64 	mova	#25702,	r0	;0x06466

00006578 <.L108>:
    uartp->dma_acquired_tx = false;
    6578:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062
    657c:	80 00 ae 64 	mova	#25774,	r0	;0x064ae

00006580 <.L112>:
    uartp->dma_acquired_rx = false;
    6580:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063
    6584:	80 00 e6 64 	mova	#25830,	r0	;0x064e6

00006588 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    6588:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000658a <.LCFI8>:
    658a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000658c <.LCFI9>:
    658c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000658e <.LCFI10>:
    658e:	ca 0c       	mova	r12,	r10	;

00006590 <.Loc.647.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    6590:	7c 0e 1a 00 	mova	r14,	26(r12)	; 0x0001a

00006594 <.Loc.648.1>:
  uartp->dmareq_tx.size = n;
    6594:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

00006598 <.Loc.650.1>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    6598:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

0000659c <.L134>:
    659c:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    65a0:	1c 00 
    65a2:	fc 27       	jz	$-6      	;abs 0x659c

000065a4 <.Loc.651.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    65a4:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

000065a8 <.Loc.653.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    65a8:	c8 0a       	mova	r10,	r8	;
    65aa:	a8 00 4e 00 	adda	#78,	r8	;0x0004e
    65ae:	c6 0a       	mova	r10,	r6	;
    65b0:	a6 00 1a 00 	adda	#26,	r6	;0x0001a

000065b4 <.LBB97>:
  if (!(*acquired)) {
    65b4:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    65b8:	05 20       	jnz	$+12     	;abs 0x65c4

000065ba <.Loc.173.1>:
    dmaAcquireI(dma);
    65ba:	cc 08       	mova	r8,	r12	;
    65bc:	b0 13 46 56 	calla	#22086		;0x05646

000065c0 <.LVL145>:
    (*acquired) = true;
    65c0:	da 43 62 00 	mov.b	#1,	98(r10)	;r3 As==01, 0x0062

000065c4 <.L135>:
  dmaTransferI(dma, req);
    65c4:	cd 06       	mova	r6,	r13	;
    65c6:	cc 08       	mova	r8,	r12	;
    65c8:	b0 13 14 57 	calla	#22292		;0x05714

000065cc <.LBE97>:
  
  uartp->regs->ifg |= UCTXIFG;
    65cc:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    65d0:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

000065d4 <.Loc.656.1>:
}
    65d4:	06 16       	popm.a	#1,	r6	;20-bit words
    65d6:	08 16       	popm.a	#1,	r8	;20-bit words
    65d8:	0a 16       	popm.a	#1,	r10	;20-bit words
    65da:	10 01       	reta			;

000065dc <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    65dc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000065de <.LCFI13>:
    65de:	08 14       	pushm.a	#1,	r8	;20-bit words

000065e0 <.LCFI14>:
    65e0:	06 14       	pushm.a	#1,	r6	;20-bit words

000065e2 <.LCFI15>:
    65e2:	ca 0c       	mova	r12,	r10	;

000065e4 <.Loc.694.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    65e4:	7c 0e 38 00 	mova	r14,	56(r12)	; 0x00038

000065e8 <.Loc.695.1>:
  uartp->dmareq_rx.size = n;
    65e8:	8c 4d 3c 00 	mov	r13,	60(r12)	; 0x003c

000065ec <.Loc.698.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    65ec:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

000065f0 <.LVL152>:
    65f0:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

000065f4 <.Loc.700.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    65f4:	c8 0a       	mova	r10,	r8	;
    65f6:	a8 00 58 00 	adda	#88,	r8	;0x00058
    65fa:	c6 0a       	mova	r10,	r6	;
    65fc:	a6 00 34 00 	adda	#52,	r6	;0x00034

00006600 <.LBB101>:
  if (!(*acquired)) {
    6600:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    6604:	05 20       	jnz	$+12     	;abs 0x6610

00006606 <.Loc.173.1>:
    dmaAcquireI(dma);
    6606:	cc 08       	mova	r8,	r12	;
    6608:	b0 13 46 56 	calla	#22086		;0x05646

0000660c <.LVL154>:
    (*acquired) = true;
    660c:	da 43 63 00 	mov.b	#1,	99(r10)	;r3 As==01, 0x0063

00006610 <.L141>:
  dmaTransferI(dma, req);
    6610:	cd 06       	mova	r6,	r13	;
    6612:	cc 08       	mova	r8,	r12	;
    6614:	b0 13 14 57 	calla	#22292		;0x05714

00006618 <.LBE101>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    6618:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    661c:	40 18 9c b3 	bitx.w	#1,	28(r12)	;r3 As==01, 0x0001c
    6620:	1c 00 
    6622:	04 24       	jz	$+10     	;abs 0x662c

00006624 <.Loc.704.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    6624:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00006628 <.Loc.705.1>:
    uartp->regs->ifg |= UCRXIFG;
    6628:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

0000662c <.L140>:
  }
}
    662c:	06 16       	popm.a	#1,	r6	;20-bit words
    662e:	08 16       	popm.a	#1,	r8	;20-bit words
    6630:	0a 16       	popm.a	#1,	r10	;20-bit words
    6632:	10 01       	reta			;

00006634 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    6634:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006636 <.LCFI16>:
    6636:	08 14       	pushm.a	#1,	r8	;20-bit words

00006638 <.LCFI17>:
    6638:	06 14       	pushm.a	#1,	r6	;20-bit words

0000663a <.LCFI18>:
    663a:	c8 0c       	mova	r12,	r8	;

0000663c <.Loc.722.1>:

  size_t result = uartp->dma_rx.registers->sz;
    663c:	3c 0c 58 00 	mova	88(r12),r12	;0x00058

00006640 <.LVL157>:
    6640:	40 18 1a 4c 	movx.w	10(r12),r10	;0x0000a
    6644:	0a 00 

00006646 <.Loc.723.1>:
  dmaCancelI(&(uartp->dma_rx));
    6646:	c6 08       	mova	r8,	r6	;
    6648:	a6 00 58 00 	adda	#88,	r6	;0x00058
    664c:	cc 06       	mova	r6,	r12	;
    664e:	b0 13 ce 57 	calla	#22478		;0x057ce

00006652 <.LVL159>:
  if (uartp->dma_acquired_rx) {
    6652:	c8 93 63 00 	cmp.b	#0,	99(r8)	;r3 As==00, 0x0063
    6656:	03 24       	jz	$+8      	;abs 0x665e

00006658 <.Loc.725.1>:
    dmaReleaseX(&(uartp->dma_rx));
    6658:	cc 06       	mova	r6,	r12	;
    665a:	b0 13 94 57 	calla	#22420		;0x05794

0000665e <.L147>:
  }
  
  uartp->regs->ifg &= ~UCRXIFG;
    665e:	3c 08 16 00 	mova	22(r8),	r12	;0x00016
    6662:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00006666 <.Loc.729.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    6666:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

0000666a <.Loc.732.1>:

  return result;
}
    666a:	cc 0a       	mova	r10,	r12	;
    666c:	06 16       	popm.a	#1,	r6	;20-bit words
    666e:	08 16       	popm.a	#1,	r8	;20-bit words
    6670:	0a 16       	popm.a	#1,	r10	;20-bit words
    6672:	10 01       	reta			;

00006674 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    6674:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    6678:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    667c:	80 03 06 00 

00006680 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    6680:	b0 13 4c 50 	calla	#20556		;0x0504c

00006684 <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    6684:	10 01       	reta			;

00006686 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    6686:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006688 <.LCFI0>:
    6688:	ca 0c       	mova	r12,	r10	;

0000668a <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    668a:	9c 01 14 15 	cmpa	#70932,	r12	;0x11514
    668e:	32 20       	jnz	$+102    	;abs 0x66f4

00006690 <.Loc.301.1>:
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    6690:	3c 0c 06 00 	mova	6(r12),	r12	;

00006694 <.LVL3>:
    6694:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    6698:	00 00 

0000669a <.Loc.304.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    669a:	3c 0a 02 00 	mova	2(r10),	r12	;
    669e:	2e 4c       	mov	@r12,	r14	;
    66a0:	1f 4c 02 00 	mov	2(r12),	r15	;
    66a4:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    66a8:	4d 43       	clr.b	r13		;
    66aa:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    66ae:	08 4c       	mov	r12,	r8	;
    66b0:	09 4d       	mov	r13,	r9	;

000066b2 <.LVL5>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    66b2:	0d 93       	cmp	#0,	r13	;r3 As==00
    66b4:	04 20       	jnz	$+10     	;abs 0x66be
    66b6:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    66ba:	0c 98       	cmp	r8,	r12	;
    66bc:	04 2c       	jc	$+10     	;abs 0x66c6

000066be <.L11>:
    66be:	8c 01 19 04 	mova	#66585,	r12	;0x10419
    66c2:	b0 13 dc 47 	calla	#18396		;0x047dc

000066c6 <.L3>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    66c6:	0c 48       	mov	r8,	r12	;
    66c8:	7c f0 07 00 	and.b	#7,	r12	;
    66cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    66ce:	14 24       	jz	$+42     	;abs 0x66f8

000066d0 <.Loc.348.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    divider /= 8;
  }
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    66d0:	0c 48       	mov	r8,	r12	;
    66d2:	7c f0 03 00 	and.b	#3,	r12	;
    66d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    66d8:	2b 20       	jnz	$+88     	;abs 0x6730

000066da <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    66da:	3c 0a 06 00 	mova	6(r10),	r12	;
    66de:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    66e2:	00 00 

000066e4 <.Loc.350.1>:
    divider /= 4;
    66e4:	40 19 09 10 	rrux.w	r9		;
    66e8:	08 10       	rrc	r8		;
    66ea:	40 19 09 10 	rrux.w	r9		;
    66ee:	08 10       	rrc	r8		;
    66f0:	80 00 0e 67 	mova	#26382,	r0	;0x0670e

000066f4 <.L10>:
  uint32_t divider = 0;
    66f4:	48 43       	clr.b	r8		;
    66f6:	49 43       	clr.b	r9		;

000066f8 <.L13>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    66f8:	3c 0a 06 00 	mova	6(r10),	r12	;
    66fc:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    6700:	00 00 

00006702 <.Loc.346.1>:
    divider /= 8;
    6702:	0c 48       	mov	r8,	r12	;
    6704:	0d 49       	mov	r9,	r13	;
    6706:	b0 13 54 ce 	calla	#52820		;0x0ce54
    670a:	08 4c       	mov	r12,	r8	;
    670c:	09 4d       	mov	r13,	r9	;

0000670e <.L6>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    670e:	09 93       	cmp	#0,	r9	;r3 As==00
    6710:	03 20       	jnz	$+8      	;abs 0x6718
    6712:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6714:	0d 98       	cmp	r8,	r13	;
    6716:	04 2c       	jc	$+10     	;abs 0x6720

00006718 <.L12>:
    6718:	8c 01 19 04 	mova	#66585,	r12	;0x10419
    671c:	b0 13 dc 47 	calla	#18396		;0x047dc

00006720 <.L8>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    6720:	3c 0a 06 00 	mova	6(r10),	r12	;
    6724:	0d 48       	mov	r8,	r13	;
    6726:	3d 53       	add	#-1,	r13	;r3 As==11
    6728:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

0000672c <.Loc.359.1>:

}
    672c:	28 16       	popm.a	#3,	r10	;20-bit words
    672e:	10 01       	reta			;

00006730 <.L7>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    6730:	0c 48       	mov	r8,	r12	;
    6732:	5c f3       	and.b	#1,	r12	;r3 As==01
    6734:	0c 93       	cmp	#0,	r12	;r3 As==00
    6736:	eb 23       	jnz	$-40     	;abs 0x670e

00006738 <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    6738:	3c 0a 06 00 	mova	6(r10),	r12	;
    673c:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    6740:	00 00 

00006742 <.Loc.354.1>:
    divider /= 2;
    6742:	12 c3       	clrc			
    6744:	09 10       	rrc	r9		;
    6746:	08 10       	rrc	r8		;
    6748:	80 00 0e 67 	mova	#26382,	r0	;0x0670e

0000674c <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    674c:	3e 0c 02 00 	mova	2(r12),	r14	;
    6750:	3c 0c 06 00 	mova	6(r12),	r12	;

00006754 <.LVL17>:
    6754:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    6758:	04 00 
    675a:	02 24       	jz	$+6      	;abs 0x6760

0000675c <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    675c:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00006760 <.L17>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    6760:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00006764 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    6764:	2d 4c       	mov	@r12,	r13	;

00006766 <.LVL18>:
    6766:	3d d0 14 00 	bis	#20,	r13	;#0x0014
    676a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000676e <.Loc.398.1>:
}
    676e:	10 01       	reta			;

00006770 <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    6770:	3c 0c 06 00 	mova	6(r12),	r12	;

00006774 <.LVL20>:
    6774:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    6778:	00 00 

0000677a <.Loc.412.1>:

}
    677a:	10 01       	reta			;

0000677c <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    677c:	32 c2       	dint			
    677e:	03 43       	nop			

00006780 <.Loc.46.1>:

}
    6780:	10 01       	reta			;

00006782 <sx1278SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
uint8_t sx1278SetRegister(SX1278Driver *devp, uint8_t reg, 
    uint8_t value) {
    6782:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006784 <.LCFI0>:
    6784:	ca 0c       	mova	r12,	r10	;
    6786:	49 4d       	mov.b	r13,	r9	;
    6788:	47 4e       	mov.b	r14,	r7	;

0000678a <.Loc.105.1>:
  
  osalDbgAssert(reg & 0x7FU, "register address out of bounds");
    678a:	39 b0 7f 00 	bit	#127,	r9	;#0x007f
    678e:	04 20       	jnz	$+10     	;abs 0x6798

00006790 <.Loc.105.1>:
    6790:	8c 01 48 04 	mova	#66632,	r12	;0x10448

00006794 <.LVL4>:
    6794:	b0 13 dc 47 	calla	#18396		;0x047dc

00006798 <.L3>:
  
  osalDbgAssert(reg != 0x11U && reg != 0x3CU && reg != 0x42U, 
    6798:	79 90 11 00 	cmp.b	#17,	r9	;#0x0011
    679c:	06 24       	jz	$+14     	;abs 0x67aa

0000679e <.Loc.107.1>:
    679e:	79 90 3c 00 	cmp.b	#60,	r9	;#0x003c
    67a2:	03 24       	jz	$+8      	;abs 0x67aa

000067a4 <.Loc.107.1>:
    67a4:	79 90 42 00 	cmp.b	#66,	r9	;#0x0042
    67a8:	04 20       	jnz	$+10     	;abs 0x67b2

000067aa <.L4>:
    67aa:	8c 01 48 04 	mova	#66632,	r12	;0x10448
    67ae:	b0 13 dc 47 	calla	#18396		;0x047dc

000067b2 <.L5>:
      "setting read-only registers");
  
  palClearLine(devp->config->ss_line);
    67b2:	06 0a       	mova	@r10,	r6	;
    67b4:	3c 06 22 00 	mova	34(r6),	r12	;0x00022
    67b8:	c8 0c       	mova	r12,	r8	;
    67ba:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    67be:	ff 0f 
    67c0:	15 48 02 00 	mov	2(r8),	r5	;
    67c4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    67c6:	40 18 3c 41 	popx.w	r12		;
    67ca:	40 18 3d 41 	popx.w	r13		;
    67ce:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    67d2:	0d 12       	push	r13		;
    67d4:	0c 12       	push	r12		;
    67d6:	0c 16       	popm.a	#1,	r12	;20-bit words
    67d8:	40 18 0d 4c 	movx.w	r12,	r13	;
    67dc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    67de:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    67e2:	05 cc       	bic	r12,	r5	;
    67e4:	88 45 02 00 	mov	r5,	2(r8)	;

000067e8 <.Loc.111.1>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    67e8:	88 00 84 5a 	mova	#23172,	r8	;0x05a84
    67ec:	4d 49       	mov.b	r9,	r13	;
    67ee:	7d d0 80 ff 	bis.b	#-128,	r13	;#0xff80
    67f2:	0c 06       	mova	@r6,	r12	;
    67f4:	48 13       	calla	r8		;

000067f6 <.LVL9>:
  reg = spiPolledExchange(devp->config->spip, value);
    67f6:	0c 0a       	mova	@r10,	r12	;
    67f8:	4d 47       	mov.b	r7,	r13	;
    67fa:	0c 0c       	mova	@r12,	r12	;
    67fc:	48 13       	calla	r8		;

000067fe <.LVL10>:
    67fe:	49 4c       	mov.b	r12,	r9	;

00006800 <.Loc.113.1>:
  palSetLine(devp->config->ss_line);
    6800:	0c 0a       	mova	@r10,	r12	;
    6802:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6806:	ca 0c       	mova	r12,	r10	;

00006808 <.LVL12>:
    6808:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    680c:	ff 0f 
    680e:	18 4a 02 00 	mov	2(r10),	r8	;
    6812:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6814:	40 18 3c 41 	popx.w	r12		;
    6818:	40 18 3d 41 	popx.w	r13		;
    681c:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6820:	0d 12       	push	r13		;
    6822:	0c 12       	push	r12		;
    6824:	0c 16       	popm.a	#1,	r12	;20-bit words
    6826:	40 18 0d 4c 	movx.w	r12,	r13	;
    682a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    682c:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6830:	0c d8       	bis	r8,	r12	;
    6832:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006836 <.Loc.116.1>:
  
  return reg;
}
    6836:	4c 49       	mov.b	r9,	r12	;
    6838:	55 16       	popm.a	#6,	r10	;20-bit words
    683a:	10 01       	reta			;

0000683c <sx1278SetBitrate>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] rate bit rate in bits per second to be used
*/
void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    683c:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000683e <.LCFI1>:
    683e:	c8 0c       	mova	r12,	r8	;
    6840:	06 4d       	mov	r13,	r6	;
    6842:	0a 4e       	mov	r14,	r10	;

00006844 <.Loc.166.1>:
  uint32_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    6844:	0e 4d       	mov	r13,	r14	;
    6846:	0f 4a       	mov	r10,	r15	;
    6848:	3c 40 00 80 	mov	#-32768,r12	;#0x8000

0000684c <.LVL16>:
    684c:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84

00006850 <.LVL17>:
    6850:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    6854:	09 4c       	mov	r12,	r9	;

00006856 <.LVL19>:
  uint16_t regs = tmp >> 4;
    6856:	b0 13 4e ce 	calla	#52814		;0x0ce4e

0000685a <.LVL20>:
    685a:	07 4c       	mov	r12,	r7	;

0000685c <.Loc.168.1>:
  uint8_t frac = tmp & 0x000F;
    685c:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

00006860 <.Loc.170.1>:
  
  osalDbgAssert(rate < 300000, "bit rate too high");
    6860:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6862:	0c 9a       	cmp	r10,	r12	;
    6864:	06 28       	jnc	$+14     	;abs 0x6872
    6866:	0a 9c       	cmp	r12,	r10	;
    6868:	08 20       	jnz	$+18     	;abs 0x687a
    686a:	3c 40 df 93 	mov	#-27681,r12	;#0x93df
    686e:	0c 96       	cmp	r6,	r12	;
    6870:	04 2c       	jc	$+10     	;abs 0x687a

00006872 <.L15>:
    6872:	8c 01 5a 04 	mova	#66650,	r12	;0x1045a
    6876:	b0 13 dc 47 	calla	#18396		;0x047dc

0000687a <.L13>:
  
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    687a:	8a 00 82 67 	mova	#26498,	r10	;0x06782
    687e:	0e 47       	mov	r7,	r14	;
    6880:	5e 0f       	rrum	#4,	r14	;
    6882:	5e 0f       	rrum	#4,	r14	;
    6884:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6886:	cc 08       	mova	r8,	r12	;
    6888:	4a 13       	calla	r10		;

0000688a <.LVL24>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    688a:	4e 47       	mov.b	r7,	r14	;
    688c:	7d 40 03 00 	mov.b	#3,	r13	;
    6890:	cc 08       	mova	r8,	r12	;
    6892:	4a 13       	calla	r10		;

00006894 <.LVL25>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    6894:	4e 49       	mov.b	r9,	r14	;
    6896:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    689a:	cc 08       	mova	r8,	r12	;
    689c:	4a 13       	calla	r10		;

0000689e <.LVL26>:
}
    689e:	46 16       	popm.a	#5,	r10	;20-bit words
    68a0:	10 01       	reta			;

000068a2 <sx1278SetDeviation>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    68a2:	4a 14       	pushm.a	#5,	r10	;20-bit words

000068a4 <.LCFI2>:
    68a4:	c8 0c       	mova	r12,	r8	;
    68a6:	06 4d       	mov	r13,	r6	;
    68a8:	09 4e       	mov	r14,	r9	;

000068aa <.Loc.186.1>:
  /* Fancy math for freq / FSTEP to correct for roundings */
  uint16_t regs = ((fdev << 11) + (SX1278_CLK_FREQ >> 9)) / 
    68aa:	0c 4d       	mov	r13,	r12	;

000068ac <.LVL28>:
    68ac:	0d 4e       	mov	r14,	r13	;

000068ae <.LVL29>:
    68ae:	b0 13 14 cd 	calla	#52500		;0x0cd14
    68b2:	3e 40 48 e8 	mov	#-6072,	r14	;#0xe848
    68b6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    68b8:	3c 50 24 f4 	add	#-3036,	r12	;#0xf424
    68bc:	0d 63       	adc	r13		;
    68be:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    68c2:	07 4c       	mov	r12,	r7	;
    68c4:	0a 4c       	mov	r12,	r10	;

000068c6 <.Loc.189.1>:
    (SX1278_CLK_FREQ >> 8);
  
  osalDbgAssert(fdev < 200000, "deviation too high");
    68c6:	7c 40 03 00 	mov.b	#3,	r12	;
    68ca:	0c 99       	cmp	r9,	r12	;
    68cc:	06 28       	jnc	$+14     	;abs 0x68da
    68ce:	09 9c       	cmp	r12,	r9	;
    68d0:	08 20       	jnz	$+18     	;abs 0x68e2
    68d2:	3c 40 3f 0d 	mov	#3391,	r12	;#0x0d3f
    68d6:	0c 96       	cmp	r6,	r12	;
    68d8:	04 2c       	jc	$+10     	;abs 0x68e2

000068da <.L19>:
    68da:	8c 01 6b 04 	mova	#66667,	r12	;0x1046b
    68de:	b0 13 dc 47 	calla	#18396		;0x047dc

000068e2 <.L17>:
  
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    68e2:	86 00 82 67 	mova	#26498,	r6	;0x06782
    68e6:	0e 4a       	mov	r10,	r14	;
    68e8:	5e 0f       	rrum	#4,	r14	;
    68ea:	5e 0f       	rrum	#4,	r14	;
    68ec:	6d 42       	mov.b	#4,	r13	;r2 As==10
    68ee:	cc 08       	mova	r8,	r12	;
    68f0:	46 13       	calla	r6		;

000068f2 <.LVL34>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    68f2:	4e 47       	mov.b	r7,	r14	;
    68f4:	7d 40 05 00 	mov.b	#5,	r13	;
    68f8:	cc 08       	mova	r8,	r12	;
    68fa:	46 13       	calla	r6		;

000068fc <.LVL35>:
}
    68fc:	46 16       	popm.a	#5,	r10	;20-bit words
    68fe:	10 01       	reta			;

00006900 <sx1278SetFrequency>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    6900:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006902 <.LCFI3>:
    6902:	ca 0c       	mova	r12,	r10	;
    6904:	08 4d       	mov	r13,	r8	;
    6906:	05 4e       	mov	r14,	r5	;

00006908 <.Loc.204.1>:
  /* Fancy math for freq / FSTEP to keep everything from rounding */
  uint32_t regs = (((freq + (SX1278_CLK_FREQ >> 12)) / 
    6908:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    690c:	4f 43       	clr.b	r15		;
    690e:	0c 4d       	mov	r13,	r12	;

00006910 <.LVL37>:
    6910:	3c 50 84 1e 	add	#7812,	r12	;#0x1e84
    6914:	0d 45       	mov	r5,	r13	;

00006916 <.LVL38>:
    6916:	0d 63       	adc	r13		;
    6918:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    691c:	07 4c       	mov	r12,	r7	;
    691e:	b0 13 20 cd 	calla	#52512		;0x0cd20
    6922:	06 4c       	mov	r12,	r6	;
    6924:	09 4d       	mov	r13,	r9	;

00006926 <.Loc.207.1>:
        (SX1278_CLK_FREQ >> 11)) << 8);
  
  if ((freq >= 137000000 && freq <= 175000000) || 
    6926:	0d 48       	mov	r8,	r13	;
    6928:	3d 50 c0 8b 	add	#-29760,r13	;#0x8bc0
    692c:	0c 45       	mov	r5,	r12	;
    692e:	3c 60 d5 f7 	addc	#-2091,	r12	;#0xf7d5
    6932:	3e 40 43 02 	mov	#579,	r14	;#0x0243
    6936:	0e 9c       	cmp	r12,	r14	;
    6938:	06 28       	jnc	$+14     	;abs 0x6946
    693a:	0c 9e       	cmp	r14,	r12	;
    693c:	14 20       	jnz	$+42     	;abs 0x6966
    693e:	3c 40 80 d5 	mov	#-10880,r12	;#0xd580
    6942:	0c 9d       	cmp	r13,	r12	;
    6944:	10 2c       	jc	$+34     	;abs 0x6966

00006946 <.L30>:
      (freq >= 410000000 && freq <= 525000000)) {
    6946:	0d 48       	mov	r8,	r13	;
    6948:	3d 50 80 e5 	add	#-6784,	r13	;#0xe580
    694c:	0c 45       	mov	r5,	r12	;
    694e:	3c 60 8f e7 	addc	#-6257,	r12	;#0xe78f

00006952 <.Loc.207.1>:
  if ((freq >= 137000000 && freq <= 175000000) || 
    6952:	3e 40 da 06 	mov	#1754,	r14	;#0x06da
    6956:	0e 9c       	cmp	r12,	r14	;
    6958:	2c 28       	jnc	$+90     	;abs 0x69b2
    695a:	0c 9e       	cmp	r14,	r12	;
    695c:	04 20       	jnz	$+10     	;abs 0x6966
    695e:	3c 40 c0 c2 	mov	#-15680,r12	;#0xc2c0
    6962:	0c 9d       	cmp	r13,	r12	;
    6964:	26 28       	jnc	$+78     	;abs 0x69b2

00006966 <.L21>:
    /* Bands 2 + 3 */
    devp->regs.opmode |= (1 << 3);
    6966:	fa d2 05 00 	bis.b	#8,	5(r10)	;r2 As==11

0000696a <.L25>:
  }
  else {
    osalDbgAssert(false, "frequency out of range");
  }
  
  osalDbgAssert(!(regs & 0xFF000000), "incorrect register value calculated");
    696a:	39 b0 00 ff 	bit	#-256,	r9	;#0xff00
    696e:	04 24       	jz	$+10     	;abs 0x6978
    6970:	8c 01 7e 04 	mova	#66686,	r12	;0x1047e
    6974:	b0 13 dc 47 	calla	#18396		;0x047dc

00006978 <.L28>:
  
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    6978:	88 00 82 67 	mova	#26498,	r8	;0x06782
    697c:	5e 4a 05 00 	mov.b	5(r10),	r14	;
    6980:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6982:	cc 0a       	mova	r10,	r12	;
    6984:	48 13       	calla	r8		;

00006986 <.LVL43>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    6986:	0c 46       	mov	r6,	r12	;
    6988:	0d 49       	mov	r9,	r13	;
    698a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    698e:	b0 13 70 ce 	calla	#52848		;0x0ce70
    6992:	4e 4c       	mov.b	r12,	r14	;
    6994:	7d 40 06 00 	mov.b	#6,	r13	;
    6998:	cc 0a       	mova	r10,	r12	;
    699a:	48 13       	calla	r8		;

0000699c <.LVL45>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    699c:	4e 47       	mov.b	r7,	r14	;
    699e:	7d 40 07 00 	mov.b	#7,	r13	;
    69a2:	cc 0a       	mova	r10,	r12	;
    69a4:	48 13       	calla	r8		;

000069a6 <.LVL46>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    69a6:	4e 43       	clr.b	r14		;
    69a8:	7d 42       	mov.b	#8,	r13	;r2 As==11
    69aa:	cc 0a       	mova	r10,	r12	;
    69ac:	48 13       	calla	r8		;

000069ae <.LVL47>:
}
    69ae:	55 16       	popm.a	#6,	r10	;20-bit words
    69b0:	10 01       	reta			;

000069b2 <.L23>:
  else if (freq >= 862000000 && freq <= 1020000000) {
    69b2:	38 50 80 ec 	add	#-4992,	r8	;#0xec80
    69b6:	35 60 9e cc 	addc	#-13154,r5	;#0xcc9e
    69ba:	3e 40 6a 09 	mov	#2410,	r14	;#0x096a
    69be:	0e 95       	cmp	r5,	r14	;
    69c0:	0a 28       	jnc	$+22     	;abs 0x69d6
    69c2:	05 9e       	cmp	r14,	r5	;
    69c4:	04 20       	jnz	$+10     	;abs 0x69ce
    69c6:	3c 40 80 e3 	mov	#-7296,	r12	;#0xe380
    69ca:	0c 98       	cmp	r8,	r12	;
    69cc:	04 28       	jnc	$+10     	;abs 0x69d6

000069ce <.L31>:
    devp->regs.opmode &= ~(1 << 3);
    69ce:	fa c2 05 00 	bic.b	#8,	5(r10)	;r2 As==11
    69d2:	80 00 6a 69 	mova	#26986,	r0	;0x0696a

000069d6 <.L26>:
    osalDbgAssert(false, "frequency out of range");
    69d6:	8c 01 7e 04 	mova	#66686,	r12	;0x1047e
    69da:	b0 13 dc 47 	calla	#18396		;0x047dc

000069de <.LVL48>:
    69de:	80 00 6a 69 	mova	#26986,	r0	;0x0696a

000069e2 <sx1278SetPower>:
 * @param[in] pow  output power will be programmed as [10+(.2 * pow)], in dBm
*/
void sx1278SetPower(SX1278Driver * devp, uint8_t pow) {
  (void)(pow);
  /* TODO figure out how to set power properly. also add closed loop. */
  sx1278SetRegister(devp, RegPaConfig, 0x03);
    69e2:	7e 40 03 00 	mov.b	#3,	r14	;
    69e6:	7d 40 09 00 	mov.b	#9,	r13	;

000069ea <.LVL50>:
    69ea:	b0 13 82 67 	calla	#26498		;0x06782

000069ee <.LVL51>:
  return;
}
    69ee:	10 01       	reta			;

000069f0 <sx1278SetSync>:
 * 
 * @param[in] devp  pointer to the SX1278 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    69f0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000069f2 <.LCFI6>:
    69f2:	c4 0c       	mova	r12,	r4	;
    69f4:	09 4d       	mov	r13,	r9	;
    69f6:	07 4e       	mov	r14,	r7	;

000069f8 <.LVL57>:
  
  osalDbgAssert(sizeof(sync) <= 8, "requested sync length too large");

  reg |= devp->config->packet_config->preamble_polarity << 5;
  
  if (sync == 0) {
    69f8:	0d de       	bis	r14,	r13	;

000069fa <.LVL58>:
    69fa:	0d 93       	cmp	#0,	r13	;r3 As==00
    69fc:	2c 24       	jz	$+90     	;abs 0x6a56

000069fe <.Loc.281.1>:
  reg |= devp->config->packet_config->preamble_polarity << 5;
    69fe:	0e 0c       	mova	@r12,	r14	;
    6a00:	3e 0e 26 00 	mova	38(r14),r14	;0x00026
    6a04:	6e 4e       	mov.b	@r14,	r14	;
    6a06:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00006a0a <.LVL59>:
  }
  else {
    reg |= 0x90 | (sizeof(sync) - 1);
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
    6a0a:	88 00 82 67 	mova	#26498,	r8	;0x06782
    6a0e:	7e d0 93 ff 	bis.b	#-109,	r14	;#0xff93

00006a12 <.LVL60>:
    6a12:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027
    6a16:	48 13       	calla	r8		;

00006a18 <.LVL61>:
    6a18:	7a 40 28 00 	mov.b	#40,	r10	;#0x0028
    6a1c:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00006a20 <.LBB39>:
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
    6a20:	88 00 dc 47 	mova	#18396,	r8	;0x047dc

00006a24 <.L41>:
    6a24:	0c 49       	mov	r9,	r12	;
    6a26:	0d 47       	mov	r7,	r13	;
    6a28:	0e 46       	mov	r6,	r14	;
    6a2a:	0f 43       	clr	r15		;
    6a2c:	b0 13 70 ce 	calla	#52848		;0x0ce70
    6a30:	05 4c       	mov	r12,	r5	;
    6a32:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6a34:	03 20       	jnz	$+8      	;abs 0x6a3c
    6a36:	8c 01 a7 04 	mova	#66727,	r12	;0x104a7
    6a3a:	48 13       	calla	r8		;

00006a3c <.L40>:
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    6a3c:	4e 45       	mov.b	r5,	r14	;
    6a3e:	4d 4a       	mov.b	r10,	r13	;
    6a40:	cc 04       	mova	r4,	r12	;
    6a42:	b0 13 82 67 	calla	#26498		;0x06782

00006a46 <.LVL65>:
    6a46:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8
    6a4a:	4c 4a       	mov.b	r10,	r12	;
    6a4c:	5c 53       	inc.b	r12		;
    6a4e:	4a 4c       	mov.b	r12,	r10	;

00006a50 <.Loc.293.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    6a50:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    6a54:	e7 23       	jnz	$-48     	;abs 0x6a24

00006a56 <.L38>:
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
  }
}
    6a56:	64 16       	popm.a	#7,	r10	;20-bit words
    6a58:	10 01       	reta			;

00006a5a <sx1278ObjectInit>:
 * @init
 */
void sx1278ObjectInit(SX1278Driver *devp) {
  
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    6a5a:	fc 40 09 00 	mov.b	#9,	5(r12)	;
    6a5e:	05 00 

00006a60 <.Loc.511.1>:
  devp->regs.seq_config = 0x00;
    6a60:	cc 43 06 00 	mov.b	#0,	6(r12)	;r3 As==00

00006a64 <.Loc.513.1>:
  
  devp->state = SX1278_STOP;
    6a64:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00006a68 <.Loc.514.1>:
}
    6a68:	10 01       	reta			;

00006a6a <spi_callback>:

void spi_callback(SPIDriver *spip) {
    6a6a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006a6c <.LCFI9>:
    6a6c:	06 14       	pushm.a	#1,	r6	;20-bit words

00006a6e <.LCFI10>:
    6a6e:	ca 0c       	mova	r12,	r10	;

00006a70 <.Loc.517.1>:
  palSetLine(SX1278D1.config->ss_line);
    6a70:	88 01 1e 15 	mova	#70942,	r8	;0x1151e
    6a74:	0c 08       	mova	@r8,	r12	;

00006a76 <.LVL105>:
    6a76:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6a7a:	c6 0c       	mova	r12,	r6	;
    6a7c:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    6a80:	ff 0f 
    6a82:	19 46 02 00 	mov	2(r6),	r9	;
    6a86:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6a88:	40 18 3c 41 	popx.w	r12		;
    6a8c:	40 18 3d 41 	popx.w	r13		;
    6a90:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6a94:	0d 12       	push	r13		;
    6a96:	0c 12       	push	r12		;
    6a98:	0c 16       	popm.a	#1,	r12	;20-bit words
    6a9a:	40 18 0d 4c 	movx.w	r12,	r13	;
    6a9e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6aa0:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6aa4:	0c d9       	bis	r9,	r12	;
    6aa6:	86 4c 02 00 	mov	r12,	2(r6)	;

00006aaa <.Loc.518.1>:
  if (SX1278D1.callback != NULL) {
    6aaa:	3e 08 08 00 	mova	8(r8),	r14	;
    6aae:	9e 00 00 00 	cmpa	#0,	r14	;
    6ab2:	02 24       	jz	$+6      	;abs 0x6ab8

00006ab4 <.Loc.519.1>:
    SX1278D1.callback(spip);
    6ab4:	cc 0a       	mova	r10,	r12	;
    6ab6:	4e 13       	calla	r14		;

00006ab8 <.L61>:
  }
}
    6ab8:	06 16       	popm.a	#1,	r6	;20-bit words
    6aba:	28 16       	popm.a	#3,	r10	;20-bit words
    6abc:	10 01       	reta			;

00006abe <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    6abe:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006ac0 <.LCFI11>:
    6ac0:	06 14       	pushm.a	#1,	r6	;20-bit words

00006ac2 <.LCFI12>:
    6ac2:	ca 0c       	mova	r12,	r10	;
    6ac4:	c8 0d       	mova	r13,	r8	;

00006ac6 <.Loc.533.1>:
  
  devp->config = config;
    6ac6:	7a 0d 00 00 	mova	r13,	0(r10)	;

00006aca <.Loc.535.1>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    6aca:	b0 13 b2 6e 	calla	#28338		;0x06eb2

00006ace <.LVL110>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Add the SPI callback to the SPI config */
  config->spicfgp->end_cb = spi_callback;
    6ace:	3d 08 04 00 	mova	4(r8),	r13	;
    6ad2:	00 18 fd 40 	movx.a	#27242,	0(r13)	;0x06a6a
    6ad6:	6a 6a 00 00 

00006ada <.Loc.542.1>:
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    6ada:	0c 08       	mova	@r8,	r12	;
    6adc:	b0 13 7c 51 	calla	#20860		;0x0517c

00006ae0 <.LVL111>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, SX1278Sleep);
    6ae0:	cc 0a       	mova	r10,	r12	;
    6ae2:	b0 13 8c 6f 	calla	#28556		;0x06f8c

00006ae6 <.LVL112>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    6ae6:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    6aea:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    6aee:	cc 0a       	mova	r10,	r12	;
    6af0:	b0 13 00 69 	calla	#26880		;0x06900

00006af4 <.LVL113>:
  sx1278SetDeviation(devp, config->fdev);
    6af4:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    6af8:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    6afc:	cc 0a       	mova	r10,	r12	;
    6afe:	b0 13 a2 68 	calla	#26786		;0x068a2

00006b02 <.LVL114>:
  sx1278SetBitrate(devp, config->bitrate);
    6b02:	1d 48 08 00 	mov	8(r8),	r13	;
    6b06:	1e 48 0a 00 	mov	10(r8),	r14	;0x0000a
    6b0a:	cc 0a       	mova	r10,	r12	;
    6b0c:	b0 13 3c 68 	calla	#26684		;0x0683c

00006b10 <.LVL115>:
  sx1278SetPower(devp, config->pow);
    6b10:	5d 48 15 00 	mov.b	21(r8),	r13	;0x00015
    6b14:	cc 0a       	mova	r10,	r12	;
    6b16:	b0 13 e2 69 	calla	#27106		;0x069e2

00006b1a <.LVL116>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    6b1a:	19 48 16 00 	mov	22(r8),	r9	;0x00016

00006b1e <.LBB90>:
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    6b1e:	86 00 82 67 	mova	#26498,	r6	;0x06782
    6b22:	0e 49       	mov	r9,	r14	;
    6b24:	5e 0f       	rrum	#4,	r14	;
    6b26:	5e 0f       	rrum	#4,	r14	;
    6b28:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    6b2c:	cc 0a       	mova	r10,	r12	;
    6b2e:	46 13       	calla	r6		;

00006b30 <.LVL118>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    6b30:	4e 49       	mov.b	r9,	r14	;
    6b32:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    6b36:	cc 0a       	mova	r10,	r12	;
    6b38:	46 13       	calla	r6		;

00006b3a <.LBE90>:
  sx1278SetSync(devp, config->sync_word);
    6b3a:	1d 48 18 00 	mov	24(r8),	r13	;0x00018
    6b3e:	1e 48 1a 00 	mov	26(r8),	r14	;0x0001a
    6b42:	cc 0a       	mova	r10,	r12	;
    6b44:	b0 13 f0 69 	calla	#27120		;0x069f0

00006b48 <.LVL120>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 
  Don't set SequencerStart, SequencerStop, FromTransmit, and LowPowerSelection
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x18;
    6b48:	fa 40 18 00 	mov.b	#24,	6(r10)	;#0x0018
    6b4c:	06 00 

00006b4e <.Loc.559.1>:
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    6b4e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    6b52:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6b56:	cc 0a       	mova	r10,	r12	;
    6b58:	46 13       	calla	r6		;

00006b5a <.LVL121>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    6b5a:	0c 0a       	mova	@r10,	r12	;
    6b5c:	38 0c 26 00 	mova	38(r12),r8	;0x00026

00006b60 <.LBB92>:
  if (packet_config->format == SX1278Variable) {
    6b60:	6c 48       	mov.b	@r8,	r12	;
    6b62:	4d 4c       	mov.b	r12,	r13	;
    6b64:	7d f0 03 00 	and.b	#3,	r13	;
    6b68:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    6b6a:	5f 24       	jz	$+192    	;abs 0x6c2a

00006b6c <.Loc.381.1>:
  uint8_t reg = 0x00;
    6b6c:	49 43       	clr.b	r9		;

00006b6e <.L67>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
    6b6e:	7c f0 0c 00 	and.b	#12,	r12	;#0x000c
    6b72:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    6b76:	04 20       	jnz	$+10     	;abs 0x6b80
    6b78:	8c 01 cf 04 	mova	#66767,	r12	;0x104cf
    6b7c:	b0 13 dc 47 	calla	#18396		;0x047dc

00006b80 <.L68>:
  reg |= packet_config->whitening << 6;
    6b80:	6d 48       	mov.b	@r8,	r13	;
    6b82:	0c 4d       	mov	r13,	r12	;
    6b84:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    6b88:	7c f0 40 00 	and.b	#64,	r12	;#0x0040

00006b8c <.Loc.394.1>:
  reg |= packet_config->manchester << 5;
    6b8c:	0e 4d       	mov	r13,	r14	;
    6b8e:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    6b92:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00006b96 <.Loc.396.1>:
  reg |= packet_config->crc << 4;
    6b96:	4c de       	bis.b	r14,	r12	;
    6b98:	0e 4d       	mov	r13,	r14	;
    6b9a:	7e f0 10 00 	and.b	#16,	r14	;#0x0010
    6b9e:	4e dc       	bis.b	r12,	r14	;

00006ba0 <.LVL125>:
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    6ba0:	4e d9       	bis.b	r9,	r14	;

00006ba2 <.LVL126>:
    6ba2:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

00006ba6 <.LVL127>:
    6ba6:	cc 0a       	mova	r10,	r12	;

00006ba8 <.LVL128>:
    6ba8:	46 13       	calla	r6		;

00006baa <.LVL129>:
  if (packet_config->format == SX1278Fixed) {
    6baa:	6c 48       	mov.b	@r8,	r12	;
    6bac:	7c f0 03 00 	and.b	#3,	r12	;
    6bb0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6bb2:	3f 20       	jnz	$+128    	;abs 0x6c32

00006bb4 <.Loc.402.1>:
        0x40 | (devp->config->length >> 8));
    6bb4:	0c 0a       	mova	@r10,	r12	;
    6bb6:	1c 4c 2c 00 	mov	44(r12),r12	;0x0002c
    6bba:	b0 13 de cd 	calla	#52702		;0x0cdde

00006bbe <.Loc.401.1>:
    sx1278SetRegister(devp, RegPacketConfig2, 
    6bbe:	4e 4c       	mov.b	r12,	r14	;
    6bc0:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6bc4:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6bc8:	cc 0a       	mova	r10,	r12	;
    6bca:	46 13       	calla	r6		;

00006bcc <.LVL131>:
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    6bcc:	0c 0a       	mova	@r10,	r12	;
    6bce:	5e 4c 2c 00 	mov.b	44(r12),r14	;0x0002c
    6bd2:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    6bd6:	cc 0a       	mova	r10,	r12	;
    6bd8:	46 13       	calla	r6		;

00006bda <.L70>:
  
  sx1278MapIRQs(devp, devp->config->irq_map);
    6bda:	08 0a       	mova	@r10,	r8	;

00006bdc <.LBB95>:
    if (irq_map[i] > 5) continue;
    6bdc:	5c 48 1c 00 	mov.b	28(r8),	r12	;0x0001c
    6be0:	7d 40 05 00 	mov.b	#5,	r13	;
    6be4:	4d 9c       	cmp.b	r12,	r13	;
    6be6:	06 28       	jnc	$+14     	;abs 0x6bf4

00006be8 <.Loc.352.1>:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
    6be8:	0c 93       	cmp	#0,	r12	;r3 As==00
    6bea:	04 24       	jz	$+10     	;abs 0x6bf4
    6bec:	8c 01 e6 04 	mova	#66790,	r12	;0x104e6
    6bf0:	b0 13 dc 47 	calla	#18396		;0x047dc

00006bf4 <.L71>:
    if (irq_map[i] > 5) continue;
    6bf4:	5c 48 1d 00 	mov.b	29(r8),	r12	;0x0001d
    6bf8:	7d 40 05 00 	mov.b	#5,	r13	;
    6bfc:	4d 9c       	cmp.b	r12,	r13	;
    6bfe:	06 28       	jnc	$+14     	;abs 0x6c0c

00006c00 <.Loc.357.1>:
        osalDbgAssert(irq_map[i] == 1, "IRQ mapping invalid");
    6c00:	1c 93       	cmp	#1,	r12	;r3 As==01
    6c02:	04 24       	jz	$+10     	;abs 0x6c0c

00006c04 <.Loc.352.1>:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
    6c04:	8c 01 e6 04 	mova	#66790,	r12	;0x104e6
    6c08:	b0 13 dc 47 	calla	#18396		;0x047dc

00006c0c <.L74>:
  sx1278SetRegister(devp, RegDioMapping1, ((uint8_t *)(&dio_reg))[0]);
    6c0c:	4e 43       	clr.b	r14		;
    6c0e:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    6c12:	cc 0a       	mova	r10,	r12	;
    6c14:	46 13       	calla	r6		;

00006c16 <.LVL136>:
  sx1278SetRegister(devp, RegDioMapping2, ((uint8_t *)(&dio_reg))[1]);
    6c16:	4e 43       	clr.b	r14		;
    6c18:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    6c1c:	cc 0a       	mova	r10,	r12	;
    6c1e:	46 13       	calla	r6		;

00006c20 <.LBE95>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    6c20:	ea 43 04 00 	mov.b	#2,	4(r10)	;r3 As==10

00006c24 <.Loc.570.1>:
}
    6c24:	06 16       	popm.a	#1,	r6	;20-bit words
    6c26:	28 16       	popm.a	#3,	r10	;20-bit words
    6c28:	10 01       	reta			;

00006c2a <.L77>:
    reg |= 1 << 7;
    6c2a:	79 40 80 00 	mov.b	#128,	r9	;#0x0080
    6c2e:	80 00 6e 6b 	mova	#27502,	r0	;0x06b6e

00006c32 <.L69>:
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    6c32:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    6c36:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6c3a:	cc 0a       	mova	r10,	r12	;
    6c3c:	46 13       	calla	r6		;

00006c3e <.LVL140>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    6c3e:	4e 43       	clr.b	r14		;
    6c40:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    6c44:	cc 0a       	mova	r10,	r12	;
    6c46:	46 13       	calla	r6		;

00006c48 <.LVL141>:
    6c48:	80 00 da 6b 	mova	#27610,	r0	;0x06bda

00006c4c <sx1278FifoWriteAsync>:
  
  devp->state = SX1278_SLEEP;
}

__attribute__((optimize(0))) void sx1278FifoWriteAsync(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6c4c:	1a 14       	pushm.a	#2,	r10	;20-bit words

00006c4e <.LCFI15>:
    6c4e:	b1 00 10 00 	suba	#16,	r1	;0x00010

00006c52 <.LCFI16>:
    6c52:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c
    6c56:	71 0d 08 00 	mova	r13,	8(r1)	;
    6c5a:	71 0e 04 00 	mova	r14,	4(r1)	;
    6c5e:	71 0f 00 00 	mova	r15,	0(r1)	;

00006c62 <.Loc.624.1>:
  devp->callback = cb;
    6c62:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6c66:	00 18 ec 41 	movx.a	@r1,	8(r12)	;
    6c6a:	08 00 

00006c6c <.Loc.625.1>:
  palClearLine(devp->config->ss_line);
    6c6c:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6c70:	0c 0c       	mova	@r12,	r12	;

00006c72 <.LVL150>:
    6c72:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6c76:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6c7a:	ff 0f 
    6c7c:	ca 0c       	mova	r12,	r10	;
    6c7e:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6c82:	0c 0c       	mova	@r12,	r12	;
    6c84:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6c88:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6c8c:	ff 0f 
    6c8e:	19 4c 02 00 	mov	2(r12),	r9	;
    6c92:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6c96:	0c 0c       	mova	@r12,	r12	;
    6c98:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6c9c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6c9e:	40 18 3c 41 	popx.w	r12		;
    6ca2:	40 18 3d 41 	popx.w	r13		;
    6ca6:	b0 13 1e ce 	calla	#52766		;0x0ce1e

00006caa <.LVL151>:
    6caa:	0d 12       	push	r13		;
    6cac:	0c 12       	push	r12		;
    6cae:	0c 16       	popm.a	#1,	r12	;20-bit words
    6cb0:	40 18 0d 4c 	movx.w	r12,	r13	;
    6cb4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6cb6:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6cba:	3c e3       	inv	r12		;
    6cbc:	0c f9       	and	r9,	r12	;
    6cbe:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006cc2 <.Loc.626.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    6cc2:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6cc6:	0c 0c       	mova	@r12,	r12	;
    6cc8:	0c 0c       	mova	@r12,	r12	;
    6cca:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6cce:	b0 13 84 5a 	calla	#23172		;0x05a84

00006cd2 <.LVL153>:
  devp->config->spicfgp->end_cb = spi_callback;
    6cd2:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6cd6:	0c 0c       	mova	@r12,	r12	;
    6cd8:	3c 0c 04 00 	mova	4(r12),	r12	;
    6cdc:	00 18 fc 40 	movx.a	#27242,	0(r12)	;0x06a6a
    6ce0:	6a 6a 00 00 

00006ce4 <.Loc.628.1>:
  spiStartSend(devp->config->spip, n, buffer);
    6ce4:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6ce8:	0c 0c       	mova	@r12,	r12	;
    6cea:	0c 0c       	mova	@r12,	r12	;
    6cec:	3e 01 04 00 	mova	4(r1),	r14	;
    6cf0:	3d 01 08 00 	mova	8(r1),	r13	;
    6cf4:	b0 13 b2 51 	calla	#20914		;0x051b2

00006cf8 <.LVL154>:
}
    6cf8:	03 43       	nop			
    6cfa:	a1 00 10 00 	adda	#16,	r1	;0x00010

00006cfe <.LVL155>:
    6cfe:	19 16       	popm.a	#2,	r10	;20-bit words
    6d00:	10 01       	reta			;

00006d02 <sx1278FifoWriteAsyncS>:

__attribute__((optimize(0))) void sx1278FifoWriteAsyncS(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6d02:	1a 14       	pushm.a	#2,	r10	;20-bit words

00006d04 <.LCFI17>:
    6d04:	b1 00 10 00 	suba	#16,	r1	;0x00010

00006d08 <.LCFI18>:
    6d08:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c
    6d0c:	71 0d 08 00 	mova	r13,	8(r1)	;
    6d10:	71 0e 04 00 	mova	r14,	4(r1)	;
    6d14:	71 0f 00 00 	mova	r15,	0(r1)	;

00006d18 <.Loc.633.1>:
  devp->callback = cb;
    6d18:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d1c:	00 18 ec 41 	movx.a	@r1,	8(r12)	;
    6d20:	08 00 

00006d22 <.Loc.634.1>:
  palClearLine(devp->config->ss_line);
    6d22:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d26:	0c 0c       	mova	@r12,	r12	;

00006d28 <.LVL157>:
    6d28:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6d2c:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6d30:	ff 0f 
    6d32:	ca 0c       	mova	r12,	r10	;
    6d34:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d38:	0c 0c       	mova	@r12,	r12	;
    6d3a:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6d3e:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6d42:	ff 0f 
    6d44:	19 4c 02 00 	mov	2(r12),	r9	;
    6d48:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d4c:	0c 0c       	mova	@r12,	r12	;
    6d4e:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6d52:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6d54:	40 18 3c 41 	popx.w	r12		;
    6d58:	40 18 3d 41 	popx.w	r13		;
    6d5c:	b0 13 1e ce 	calla	#52766		;0x0ce1e

00006d60 <.LVL158>:
    6d60:	0d 12       	push	r13		;
    6d62:	0c 12       	push	r12		;
    6d64:	0c 16       	popm.a	#1,	r12	;20-bit words
    6d66:	40 18 0d 4c 	movx.w	r12,	r13	;
    6d6a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d6c:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6d70:	3c e3       	inv	r12		;
    6d72:	0c f9       	and	r9,	r12	;
    6d74:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006d78 <.Loc.635.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    6d78:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d7c:	0c 0c       	mova	@r12,	r12	;
    6d7e:	0c 0c       	mova	@r12,	r12	;
    6d80:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6d84:	b0 13 84 5a 	calla	#23172		;0x05a84

00006d88 <.LVL160>:
  devp->config->spicfgp->end_cb = spi_callback;
    6d88:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d8c:	0c 0c       	mova	@r12,	r12	;
    6d8e:	3c 0c 04 00 	mova	4(r12),	r12	;
    6d92:	00 18 fc 40 	movx.a	#27242,	0(r12)	;0x06a6a
    6d96:	6a 6a 00 00 

00006d9a <.Loc.637.1>:
  spiStartSendI(devp->config->spip, n, buffer);
    6d9a:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6d9e:	0c 0c       	mova	@r12,	r12	;
    6da0:	0c 0c       	mova	@r12,	r12	;
    6da2:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6da6:	00 00 
    6da8:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6dac:	0c 0c       	mova	@r12,	r12	;
    6dae:	0c 0c       	mova	@r12,	r12	;
    6db0:	3e 01 04 00 	mova	4(r1),	r14	;
    6db4:	3d 01 08 00 	mova	8(r1),	r13	;
    6db8:	b0 13 5a 5a 	calla	#23130		;0x05a5a

00006dbc <.LVL161>:
}
    6dbc:	03 43       	nop			
    6dbe:	a1 00 10 00 	adda	#16,	r1	;0x00010

00006dc2 <.LVL162>:
    6dc2:	19 16       	popm.a	#2,	r10	;20-bit words
    6dc4:	10 01       	reta			;

00006dc6 <sx1278StartTransmit>:

size_t sx1278StartTransmit(SX1278Driver * devp, size_t n, uint8_t * buffer, 
    palcallback_t pal_cb, spicallback_t spi_cb) {
    6dc6:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006dc8 <.LCFI19>:
    6dc8:	06 14       	pushm.a	#1,	r6	;20-bit words

00006dca <.LCFI20>:
    6dca:	04 14       	pushm.a	#1,	r4	;20-bit words

00006dcc <.LCFI21>:
    6dcc:	b1 00 08 00 	suba	#8,	r1	;

00006dd0 <.LCFI22>:
    6dd0:	ca 0c       	mova	r12,	r10	;
    6dd2:	c4 0d       	mova	r13,	r4	;
    6dd4:	c6 0e       	mova	r14,	r6	;

00006dd6 <.Loc.645.1>:
  
  /* We're in Sleep or Standby, TLS isn't started yet */
  /* Set FifoThreshold to 25% or packet size, whichever's smaller */
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6dd6:	78 40 18 00 	mov.b	#24,	r8	;#0x0018
    6dda:	d8 0d       	cmpa	r13,	r8	;
    6ddc:	66 28       	jnc	$+206    	;abs 0x6eaa

00006dde <.Loc.645.1>:
    6dde:	4e 4d       	mov.b	r13,	r14	;

00006de0 <.LVL164>:
    6de0:	7e 53       	add.b	#-1,	r14	;r3 As==11
    6de2:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00006de6 <.L85>:
    6de6:	88 00 82 67 	mova	#26498,	r8	;0x06782
    6dea:	7d 40 35 00 	mov.b	#53,	r13	;#0x0035

00006dee <.LVL165>:
    6dee:	cc 0a       	mova	r10,	r12	;

00006df0 <.LVL166>:
    6df0:	71 0f 00 00 	mova	r15,	0(r1)	;
    6df4:	48 13       	calla	r8		;

00006df6 <.LVL167>:
  /* Stop TLS */
  devp->regs.seq_config &= ~(0x80);
    6df6:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6dfa:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    6dfe:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006e02 <.Loc.648.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config | 0x40);
    6e02:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6e06:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6e0a:	cc 0a       	mova	r10,	r12	;
    6e0c:	48 13       	calla	r8		;

00006e0e <.LVL168>:
  /* Start TLS */
  devp->regs.seq_config |= 0x80;
    6e0e:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6e12:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    6e16:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006e1a <.Loc.651.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    6e1a:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6e1e:	cc 0a       	mova	r10,	r12	;
    6e20:	48 13       	calla	r8		;

00006e22 <.LBB103>:
  _disable_interrupts();
    6e22:	32 c2       	dint			
    6e24:	03 43       	nop			

00006e26 <.Loc.348.3>:
  asm volatile("nop");
    6e26:	03 43       	nop			

00006e28 <.LBE103>:
  
  /* Configure FifoLevel interrupt */
  chSysLock();
    6e28:	b0 13 54 45 	calla	#17748		;0x04554

00006e2c <.LVL170>:
  palLineEnableEventI(devp->config->dio_map[devp->config->irq_map[SX1278FifoLevel]],
    6e2c:	0e 0a       	mova	@r10,	r14	;
    6e2e:	5c 4e 1d 00 	mov.b	29(r14),r12	;0x0001d
    6e32:	0d 43       	clr	r13		;
    6e34:	08 4c       	mov	r12,	r8	;
    6e36:	09 4d       	mov	r13,	r9	;
    6e38:	08 58       	rla	r8		;
    6e3a:	09 69       	rlc	r9		;
    6e3c:	08 58       	rla	r8		;
    6e3e:	09 69       	rlc	r9		;
    6e40:	81 48 04 00 	mov	r8,	4(r1)	;
    6e44:	81 49 06 00 	mov	r9,	6(r1)	;
    6e48:	00 18 5e 51 	addx.a	4(r1),	r14	;
    6e4c:	04 00 
    6e4e:	38 0e 2e 00 	mova	46(r14),r8	;0x0002e
    6e52:	08 14       	pushm.a	#1,	r8	;20-bit words
    6e54:	40 18 3c 41 	popx.w	r12		;
    6e58:	40 18 3d 41 	popx.w	r13		;
    6e5c:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6e60:	0d 12       	push	r13		;
    6e62:	0c 12       	push	r12		;
    6e64:	0c 16       	popm.a	#1,	r12	;20-bit words
    6e66:	0f 01       	mova	@r1,	r15	;
    6e68:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6e6a:	4d 4c       	mov.b	r12,	r13	;
    6e6c:	cc 08       	mova	r8,	r12	;
    6e6e:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6e72:	ff 0f 
    6e74:	b0 13 f8 54 	calla	#21752		;0x054f8

00006e78 <.LVL172>:
      PAL_EVENT_MODE_FALLING_EDGE, pal_cb);
  chSysUnlock();
    6e78:	b0 13 7c 45 	calla	#17788		;0x0457c

00006e7c <.LBB105>:
  asm volatile("nop");
    6e7c:	03 43       	nop			

00006e7e <.Loc.356.3>:
  _enable_interrupts();
    6e7e:	03 43       	nop			
    6e80:	32 d2       	eint			
    6e82:	03 43       	nop			

00006e84 <.LBE105>:
  /* Fill the FIFO */
  uint8_t to_write = (n > 47 ? 47 : n);
    6e84:	79 40 2f 00 	mov.b	#47,	r9	;#0x002f
    6e88:	d9 04       	cmpa	r4,	r9	;
    6e8a:	01 2c       	jc	$+4      	;abs 0x6e8e
    6e8c:	c4 09       	mova	r9,	r4	;

00006e8e <.L86>:
  sx1278FifoWriteAsync(devp, to_write, buffer, spi_cb);
    6e8e:	3f 01 20 00 	mova	32(r1),	r15	;0x00020
    6e92:	ce 06       	mova	r6,	r14	;
    6e94:	cd 04       	mova	r4,	r13	;
    6e96:	cc 0a       	mova	r10,	r12	;
    6e98:	b0 13 4c 6c 	calla	#27724		;0x06c4c

00006e9c <.LVL175>:
  return to_write;
}
    6e9c:	cc 04       	mova	r4,	r12	;
    6e9e:	a1 00 08 00 	adda	#8,	r1	;
    6ea2:	04 16       	popm.a	#1,	r4	;20-bit words
    6ea4:	06 16       	popm.a	#1,	r6	;20-bit words
    6ea6:	28 16       	popm.a	#3,	r10	;20-bit words
    6ea8:	10 01       	reta			;

00006eaa <.L87>:
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6eaa:	7e 40 17 00 	mov.b	#23,	r14	;#0x0017
    6eae:	80 00 e6 6d 	mova	#28134,	r0	;0x06de6

00006eb2 <sx1278Reset.isra.1>:
static void sx1278Reset(SX1278Driver *devp) {
    6eb2:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006eb4 <.LCFI25>:
    6eb4:	06 14       	pushm.a	#1,	r6	;20-bit words

00006eb6 <.LCFI26>:
    6eb6:	ca 0c       	mova	r12,	r10	;

00006eb8 <.Loc.308.1>:
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
    6eb8:	0c 0c       	mova	@r12,	r12	;
    6eba:	00 18 cc 93 	cmpx.a	#0,	30(r12)	;r3 As==00, 0x0001e
    6ebe:	1e 00 
    6ec0:	04 20       	jnz	$+10     	;abs 0x6eca
    6ec2:	8c 01 b5 04 	mova	#66741,	r12	;0x104b5
    6ec6:	b0 13 dc 47 	calla	#18396		;0x047dc

00006eca <.L128>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    6eca:	0c 0a       	mova	@r10,	r12	;
    6ecc:	38 0c 1e 00 	mova	30(r12),r8	;0x0001e
    6ed0:	08 14       	pushm.a	#1,	r8	;20-bit words
    6ed2:	40 18 3c 41 	popx.w	r12		;
    6ed6:	40 18 3d 41 	popx.w	r13		;
    6eda:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6ede:	0d 12       	push	r13		;
    6ee0:	0c 12       	push	r12		;
    6ee2:	0c 16       	popm.a	#1,	r12	;20-bit words
    6ee4:	40 18 0d 4c 	movx.w	r12,	r13	;
    6ee8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6eea:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6eee:	86 00 08 54 	mova	#21512,	r6	;0x05408
    6ef2:	7e 40 06 00 	mov.b	#6,	r14	;
    6ef6:	0d 4c       	mov	r12,	r13	;
    6ef8:	cc 08       	mova	r8,	r12	;
    6efa:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6efe:	ff 0f 
    6f00:	46 13       	calla	r6		;

00006f02 <.LVL210>:
  palClearLine(devp->config->reset_line);
    6f02:	0c 0a       	mova	@r10,	r12	;
    6f04:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    6f08:	c8 0c       	mova	r12,	r8	;
    6f0a:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6f0e:	ff 0f 
    6f10:	19 48 02 00 	mov	2(r8),	r9	;
    6f14:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6f16:	40 18 3c 41 	popx.w	r12		;
    6f1a:	40 18 3d 41 	popx.w	r13		;
    6f1e:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6f22:	0d 12       	push	r13		;
    6f24:	0c 12       	push	r12		;
    6f26:	0c 16       	popm.a	#1,	r12	;20-bit words
    6f28:	40 18 0d 4c 	movx.w	r12,	r13	;
    6f2c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f2e:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6f32:	09 cc       	bic	r12,	r9	;
    6f34:	88 49 02 00 	mov	r9,	2(r8)	;

00006f38 <.LBB119>:
  chThdSleep(time);
    6f38:	88 00 5c 4a 	mova	#19036,	r8	;0x04a5c
    6f3c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f3e:	48 13       	calla	r8		;

00006f40 <.LBE119>:
  palSetLine(devp->config->reset_line);
    6f40:	0c 0a       	mova	@r10,	r12	;
    6f42:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    6f46:	ca 0c       	mova	r12,	r10	;
    6f48:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6f4c:	ff 0f 
    6f4e:	19 4a 02 00 	mov	2(r10),	r9	;
    6f52:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6f54:	40 18 3c 41 	popx.w	r12		;
    6f58:	40 18 3d 41 	popx.w	r13		;
    6f5c:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    6f60:	0d 12       	push	r13		;
    6f62:	0c 12       	push	r12		;
    6f64:	0c 16       	popm.a	#1,	r12	;20-bit words
    6f66:	40 18 0d 4c 	movx.w	r12,	r13	;
    6f6a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f6c:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    6f70:	09 dc       	bis	r12,	r9	;
    6f72:	8a 49 02 00 	mov	r9,	2(r10)	;

00006f76 <.Loc.314.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLUP);
    6f76:	7e 40 03 00 	mov.b	#3,	r14	;
    6f7a:	0d 4c       	mov	r12,	r13	;
    6f7c:	cc 0a       	mova	r10,	r12	;
    6f7e:	46 13       	calla	r6		;

00006f80 <.LBB121>:
    6f80:	7c 40 05 00 	mov.b	#5,	r12	;
    6f84:	48 13       	calla	r8		;

00006f86 <.LBE121>:
}
    6f86:	06 16       	popm.a	#1,	r6	;20-bit words
    6f88:	28 16       	popm.a	#3,	r10	;20-bit words
    6f8a:	10 01       	reta			;

00006f8c <sx1278SetMode.constprop.4>:
static void sx1278SetMode(SX1278Driver *devp, SX1278ModeConstants mode) {
    6f8c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006f8e <.LCFI27>:
    6f8e:	ca 0c       	mova	r12,	r10	;

00006f90 <.Loc.329.1>:
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    6f90:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    6f94:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    6f98:	cc 4e 05 00 	mov.b	r14,	5(r12)	;

00006f9c <.Loc.330.1>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    6f9c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6f9e:	b0 13 82 67 	calla	#26498		;0x06782

00006fa2 <.LVL221>:
}
    6fa2:	0a 16       	popm.a	#1,	r10	;20-bit words
    6fa4:	10 01       	reta			;

00006fa6 <blockuntil_callback>:
  chSysLockFromISR();
    6fa6:	b0 13 a6 45 	calla	#17830		;0x045a6

00006faa <.LBB31>:
  chThdResumeI(trp, msg);
    6faa:	4d 43       	clr.b	r13		;
    6fac:	8c 01 2c 15 	mova	#70956,	r12	;0x1152c
    6fb0:	b0 13 30 4a 	calla	#18992		;0x04a30

00006fb4 <.LBB33>:
  chSysUnlockFromISR();
    6fb4:	b0 13 d0 45 	calla	#17872		;0x045d0

00006fb8 <.LBE33>:

static void blockuntil_callback(void) {
  osalSysLockFromISR();
  osalThreadResumeI(&tr, MSG_OK);
  osalSysUnlockFromISR();
}
    6fb8:	10 01       	reta			;

00006fba <sx1212SetRegister.isra.0>:
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1212SetRegister(SX1212Driver *devp, uint8_t reg, 
    6fba:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006fbc <.LCFI1>:
    6fbc:	ca 0c       	mova	r12,	r10	;
    6fbe:	49 4d       	mov.b	r13,	r9	;
    6fc0:	47 4e       	mov.b	r14,	r7	;

00006fc2 <.Loc.173.1>:
    uint8_t value) {
  
  osalDbgAssert(reg <= 30, "register address out of bounds");
    6fc2:	7c 40 1e 00 	mov.b	#30,	r12	;#0x001e
    6fc6:	4c 99       	cmp.b	r9,	r12	;
    6fc8:	1b 2c       	jc	$+56     	;abs 0x7000

00006fca <.L6>:
    6fca:	8c 01 09 06 	mova	#67081,	r12	;0x10609
    6fce:	b0 13 dc 47 	calla	#18396		;0x047dc

00006fd2 <.L5>:
  osalDbgAssert(reg != 20, "setting read-only registers");
  
  /* 00xxxxx0 */
  reg = (reg << 1);
  
  spiSelectI(devp->config->spip);
    6fd2:	0c 0a       	mova	@r10,	r12	;
    6fd4:	0c 0c       	mova	@r12,	r12	;
    6fd6:	b0 13 44 59 	calla	#22852		;0x05944

00006fda <.LVL9>:
  spiPolledExchange(devp->config->spip, reg);
    6fda:	0c 0a       	mova	@r10,	r12	;
    6fdc:	88 00 84 5a 	mova	#23172,	r8	;0x05a84
    6fe0:	0d 49       	mov	r9,	r13	;
    6fe2:	0d 5d       	rla	r13		;
    6fe4:	0c 0c       	mova	@r12,	r12	;
    6fe6:	48 13       	calla	r8		;

00006fe8 <.LVL10>:
  reg = spiPolledExchange(devp->config->spip, value);
    6fe8:	0c 0a       	mova	@r10,	r12	;
    6fea:	4d 47       	mov.b	r7,	r13	;
    6fec:	0c 0c       	mova	@r12,	r12	;
    6fee:	48 13       	calla	r8		;

00006ff0 <.LVL11>:
    6ff0:	49 4c       	mov.b	r12,	r9	;

00006ff2 <.LVL12>:
  spiUnselectI(devp->config->spip);
    6ff2:	0c 0a       	mova	@r10,	r12	;
    6ff4:	0c 0c       	mova	@r12,	r12	;
    6ff6:	b0 13 88 59 	calla	#22920		;0x05988

00006ffa <.LVL13>:
  
  return reg;
}
    6ffa:	4c 49       	mov.b	r9,	r12	;
    6ffc:	37 16       	popm.a	#4,	r10	;20-bit words
    6ffe:	10 01       	reta			;

00007000 <.L4>:
  osalDbgAssert(reg != 20, "setting read-only registers");
    7000:	39 90 14 00 	cmp	#20,	r9	;#0x0014
    7004:	e6 23       	jnz	$-50     	;abs 0x6fd2
    7006:	80 00 ca 6f 	mova	#28618,	r0	;0x06fca

0000700a <sx1212SetMode>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1212SetMode(SX1212Driver *devp, SX1212ModeConstants mode) {
    700a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000700c <.LCFI2>:
    700c:	ca 0c       	mova	r12,	r10	;

0000700e <.Loc.607.1>:
  
  devp->regs.MCParam0 = (devp->regs.MCParam0 & 0x1F) | mode;
    700e:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    7012:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    7016:	4e dd       	bis.b	r13,	r14	;
    7018:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

0000701c <.Loc.608.1>:
  sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    701c:	4d 43       	clr.b	r13		;

0000701e <.LVL16>:
    701e:	b0 13 ba 6f 	calla	#28602		;0x06fba

00007022 <.LVL17>:
}
    7022:	0a 16       	popm.a	#1,	r10	;20-bit words
    7024:	10 01       	reta			;

00007026 <sx1212SetFifoThreshold>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] thresh  the threshold to set
 */
static void sx1212SetFifoThreshold(SX1212Driver *devp, uint8_t thresh) {
    7026:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007028 <.LCFI3>:
    7028:	08 14       	pushm.a	#1,	r8	;20-bit words

0000702a <.LCFI4>:
    702a:	c8 0c       	mova	r12,	r8	;
    702c:	4a 4d       	mov.b	r13,	r10	;

0000702e <.Loc.706.1>:
  
  osalDbgAssert(thresh < 64, "threshold too high");
    702e:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f

00007032 <.LVL19>:
    7032:	4c 9a       	cmp.b	r10,	r12	;
    7034:	04 2c       	jc	$+10     	;abs 0x703e

00007036 <.Loc.706.1>:
    7036:	8c 01 6c 05 	mova	#66924,	r12	;0x1056c
    703a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000703e <.L12>:
  
  sx1212SetRegister(devp, IRQParam0, (0xC0 | thresh));
    703e:	7a d0 c0 ff 	bis.b	#-64,	r10	;#0xffc0

00007042 <.LVL21>:
    7042:	4e 4a       	mov.b	r10,	r14	;
    7044:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    7048:	cc 08       	mova	r8,	r12	;
    704a:	b0 13 ba 6f 	calla	#28602		;0x06fba

0000704e <.LVL22>:
  devp->regs.IRQParam0 = (0xC0 | thresh);
    704e:	c8 4a 05 00 	mov.b	r10,	5(r8)	;

00007052 <.Loc.710.1>:
}
    7052:	08 16       	popm.a	#1,	r8	;20-bit words
    7054:	0a 16       	popm.a	#1,	r10	;20-bit words
    7056:	10 01       	reta			;

00007058 <sx1212Reset.isra.2>:
static void sx1212Reset(SX1212Driver *devp) {
    7058:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000705a <.LCFI5>:
    705a:	ca 0c       	mova	r12,	r10	;

0000705c <.Loc.586.1>:
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
    705c:	0c 0c       	mova	@r12,	r12	;
    705e:	00 18 cc 93 	cmpx.a	#0,	34(r12)	;r3 As==00, 0x00022
    7062:	22 00 
    7064:	04 20       	jnz	$+10     	;abs 0x706e
    7066:	8c 01 a9 05 	mova	#66985,	r12	;0x105a9
    706a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000706e <.L14>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    706e:	0c 0a       	mova	@r10,	r12	;
    7070:	38 0c 22 00 	mova	34(r12),r8	;0x00022
    7074:	08 14       	pushm.a	#1,	r8	;20-bit words
    7076:	40 18 3c 41 	popx.w	r12		;
    707a:	40 18 3d 41 	popx.w	r13		;
    707e:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    7082:	0d 12       	push	r13		;
    7084:	0c 12       	push	r12		;
    7086:	0c 16       	popm.a	#1,	r12	;20-bit words
    7088:	40 18 0d 4c 	movx.w	r12,	r13	;
    708c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    708e:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    7092:	86 00 08 54 	mova	#21512,	r6	;0x05408
    7096:	7e 40 06 00 	mov.b	#6,	r14	;
    709a:	0d 4c       	mov	r12,	r13	;
    709c:	cc 08       	mova	r8,	r12	;
    709e:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    70a2:	ff 0f 
    70a4:	46 13       	calla	r6		;

000070a6 <.LVL26>:
  palSetLine(devp->config->reset_line);
    70a6:	0c 0a       	mova	@r10,	r12	;
    70a8:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    70ac:	c8 0c       	mova	r12,	r8	;
    70ae:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    70b2:	ff 0f 
    70b4:	19 48 02 00 	mov	2(r8),	r9	;
    70b8:	0c 14       	pushm.a	#1,	r12	;20-bit words
    70ba:	40 18 3c 41 	popx.w	r12		;
    70be:	40 18 3d 41 	popx.w	r13		;
    70c2:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    70c6:	0d 12       	push	r13		;
    70c8:	0c 12       	push	r12		;
    70ca:	0c 16       	popm.a	#1,	r12	;20-bit words
    70cc:	40 18 0d 4c 	movx.w	r12,	r13	;
    70d0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    70d2:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    70d6:	0c d9       	bis	r9,	r12	;
    70d8:	88 4c 02 00 	mov	r12,	2(r8)	;

000070dc <.LBB35>:
  chThdSleep(time);
    70dc:	88 00 5c 4a 	mova	#19036,	r8	;0x04a5c
    70e0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    70e2:	48 13       	calla	r8		;

000070e4 <.LBE35>:
  palClearLine(devp->config->reset_line);
    70e4:	0c 0a       	mova	@r10,	r12	;
    70e6:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    70ea:	ca 0c       	mova	r12,	r10	;
    70ec:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    70f0:	ff 0f 
    70f2:	19 4a 02 00 	mov	2(r10),	r9	;
    70f6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    70f8:	40 18 3c 41 	popx.w	r12		;
    70fc:	40 18 3d 41 	popx.w	r13		;
    7100:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    7104:	0d 12       	push	r13		;
    7106:	0c 12       	push	r12		;
    7108:	0c 16       	popm.a	#1,	r12	;20-bit words
    710a:	40 18 07 4c 	movx.w	r12,	r7	;
    710e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7110:	0d 47       	mov	r7,	r13	;
    7112:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    7116:	09 cc       	bic	r12,	r9	;
    7118:	8a 49 02 00 	mov	r9,	2(r10)	;

0000711c <.Loc.592.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLDOWN);
    711c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    711e:	0d 47       	mov	r7,	r13	;
    7120:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    7124:	6e 42       	mov.b	#4,	r14	;r2 As==10
    7126:	0d 4c       	mov	r12,	r13	;
    7128:	cc 0a       	mova	r10,	r12	;
    712a:	46 13       	calla	r6		;

0000712c <.LBB37>:
    712c:	7c 40 05 00 	mov.b	#5,	r12	;
    7130:	48 13       	calla	r8		;

00007132 <.LBE37>:
}
    7132:	46 16       	popm.a	#5,	r10	;20-bit words
    7134:	10 01       	reta			;

00007136 <irq_block_with_timeout.isra.3>:
static msg_t irq_block_with_timeout(SX1212Driver *devp, ioline_t irq, 
    7136:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007138 <.LCFI6>:
    7138:	ca 0c       	mova	r12,	r10	;
    713a:	07 4d       	mov	r13,	r7	;

0000713c <.LBB49>:
  _disable_interrupts();
    713c:	32 c2       	dint			
    713e:	03 43       	nop			

00007140 <.Loc.348.3>:
  asm volatile("nop");
    7140:	03 43       	nop			

00007142 <.LBE51>:
  chSysLock();
    7142:	b0 13 54 45 	calla	#17748		;0x04554

00007146 <.LBE49>:
  palLineEnableEventI(irq, PAL_EVENT_MODE_RISING_EDGE, blockuntil_callback); 
    7146:	c8 0a       	mova	r10,	r8	;
    7148:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    714c:	ff 0f 
    714e:	0a 14       	pushm.a	#1,	r10	;20-bit words
    7150:	40 18 3c 41 	popx.w	r12		;
    7154:	40 18 3d 41 	popx.w	r13		;
    7158:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    715c:	0d 12       	push	r13		;
    715e:	0c 12       	push	r12		;
    7160:	0a 16       	popm.a	#1,	r10	;20-bit words

00007162 <.LVL40>:
    7162:	0a 14       	pushm.a	#1,	r10	;20-bit words
    7164:	40 18 3c 41 	popx.w	r12		;
    7168:	40 18 3d 41 	popx.w	r13		;
    716c:	49 4c       	mov.b	r12,	r9	;
    716e:	8f 00 a6 6f 	mova	#28582,	r15	;0x06fa6
    7172:	5e 43       	mov.b	#1,	r14	;r3 As==01
    7174:	4d 4c       	mov.b	r12,	r13	;
    7176:	cc 08       	mova	r8,	r12	;
    7178:	b0 13 f8 54 	calla	#21752		;0x054f8

0000717c <.LVL41>:
  if (palReadLine(irq)) {
    717c:	40 18 0d 4a 	movx.w	r10,	r13	;
    7180:	2c 48       	mov	@r8,	r12	;
    7182:	b0 13 06 ce 	calla	#52742		;0x0ce06
    7186:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    718a:	11 24       	jz	$+36     	;abs 0x71ae

0000718c <.Loc.243.1>:
    suspend_result = MSG_OK;
    718c:	00 18 c2 43 	movx.a	#0,	&0xfd138;r3 As==00
    7190:	38 d1 

00007192 <.L17>:
  palLineDisableEventI(irq);
    7192:	4d 49       	mov.b	r9,	r13	;
    7194:	cc 08       	mova	r8,	r12	;
    7196:	b0 13 e6 55 	calla	#21990		;0x055e6

0000719a <.LBB53>:
  chSysUnlock();
    719a:	b0 13 7c 45 	calla	#17788		;0x0457c

0000719e <.LBB55>:
  asm volatile("nop");
    719e:	03 43       	nop			

000071a0 <.Loc.356.3>:
  _enable_interrupts();
    71a0:	03 43       	nop			
    71a2:	32 d2       	eint			
    71a4:	03 43       	nop			

000071a6 <.LBE53>:
}
    71a6:	2c 00 38 d1 	mova	&53560,	r12	;0x0d138
    71aa:	37 16       	popm.a	#4,	r10	;20-bit words
    71ac:	10 01       	reta			;

000071ae <.L16>:
  return chThdSuspendTimeoutS(trp, timeout);
    71ae:	0d 47       	mov	r7,	r13	;
    71b0:	8c 01 2c 15 	mova	#70956,	r12	;0x1152c
    71b4:	b0 13 00 4a 	calla	#18944		;0x04a00

000071b8 <.LBE57>:
    suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    71b8:	60 0c 38 d1 	mova	r12,	&53560	; 0x0d138
    71bc:	80 00 92 71 	mova	#29074,	r0	;0x07192

000071c0 <spi_mode_config>:
  devp->config->spicfgp->end_cb = NULL;
    71c0:	0c 0c       	mova	@r12,	r12	;

000071c2 <.LVL48>:
    71c2:	3e 0c 04 00 	mova	4(r12),	r14	;
    71c6:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    71ca:	00 00 

000071cc <.Loc.66.1>:
  devp->config->spip->regs->ctlw0 &= ~UCMODE1;
    71cc:	0c 0c       	mova	@r12,	r12	;
    71ce:	3c 0c 0a 00 	mova	10(r12),r12	;0x0000a
    71d2:	bc f0 ff fb 	and	#-1025,	0(r12)	;#0xfbff
    71d6:	00 00 

000071d8 <.Loc.67.1>:
}
    71d8:	10 01       	reta			;

000071da <sx1212SetBitrate>:
void sx1212SetBitrate(SX1212Driver *devp, uint32_t rate) {
    71da:	6a 14       	pushm.a	#7,	r10	;20-bit words

000071dc <.LCFI8>:
    71dc:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

000071e0 <.LCFI9>:
    71e0:	c6 0c       	mova	r12,	r6	;
    71e2:	09 4d       	mov	r13,	r9	;
    71e4:	0a 4e       	mov	r14,	r10	;

000071e6 <.Loc.419.1>:
  osalDbgAssert(rate < 150000, "bit rate too high");
    71e6:	6c 43       	mov.b	#2,	r12	;r3 As==10

000071e8 <.LVL58>:
    71e8:	0c 9e       	cmp	r14,	r12	;
    71ea:	06 28       	jnc	$+14     	;abs 0x71f8
    71ec:	0e 9c       	cmp	r12,	r14	;
    71ee:	08 20       	jnz	$+18     	;abs 0x7200
    71f0:	3d 40 ef 49 	mov	#18927,	r13	;#0x49ef

000071f4 <.LVL59>:
    71f4:	0d 99       	cmp	r9,	r13	;
    71f6:	04 2c       	jc	$+10     	;abs 0x7200

000071f8 <.L34>:
    71f8:	8c 01 1b 06 	mova	#67099,	r12	;0x1061b
    71fc:	b0 13 dc 47 	calla	#18396		;0x047dc

00007200 <.L24>:
  rate = (SX1212_CLK_FREQ >> 1)/rate;
    7200:	88 00 c8 cc 	mova	#52424,	r8	;0x0ccc8
    7204:	0e 49       	mov	r9,	r14	;
    7206:	0f 4a       	mov	r10,	r15	;
    7208:	3c 40 00 a8 	mov	#-22528,r12	;#0xa800
    720c:	7d 40 61 00 	mov.b	#97,	r13	;#0x0061
    7210:	48 13       	calla	r8		;

00007212 <.LVL61>:
    7212:	0a 4c       	mov	r12,	r10	;
    7214:	09 4d       	mov	r13,	r9	;

00007216 <.LVL62>:
  if (rate - 1 <= 255) {
    7216:	3c 53       	add	#-1,	r12	;r3 As==11
    7218:	07 4d       	mov	r13,	r7	;
    721a:	37 63       	addc	#-1,	r7	;r3 As==11
    721c:	07 93       	cmp	#0,	r7	;r3 As==00
    721e:	13 20       	jnz	$+40     	;abs 0x7246
    7220:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    7224:	0d 9c       	cmp	r12,	r13	;
    7226:	0f 28       	jnc	$+32     	;abs 0x7246

00007228 <.Loc.425.1>:
    sx1212SetRegister(devp, MCParam3, (rate & 0x00FF));
    7228:	88 00 ba 6f 	mova	#28602,	r8	;0x06fba
    722c:	4e 4a       	mov.b	r10,	r14	;
    722e:	7d 40 03 00 	mov.b	#3,	r13	;
    7232:	cc 06       	mova	r6,	r12	;
    7234:	48 13       	calla	r8		;

00007236 <.LVL63>:
    sx1212SetRegister(devp, MCParam4, 0);
    7236:	4e 47       	mov.b	r7,	r14	;
    7238:	6d 42       	mov.b	#4,	r13	;r2 As==10
    723a:	cc 06       	mova	r6,	r12	;
    723c:	48 13       	calla	r8		;

0000723e <.L23>:
}
    723e:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7242:	64 16       	popm.a	#7,	r10	;20-bit words
    7244:	10 01       	reta			;

00007246 <.L26>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    7246:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    724a:	4f 43       	clr.b	r15		;
    724c:	0c 4a       	mov	r10,	r12	;
    724e:	0d 49       	mov	r9,	r13	;
    7250:	48 13       	calla	r8		;
    7252:	05 4c       	mov	r12,	r5	;
    7254:	15 53       	inc	r5		;

00007256 <.LBE62>:
    uint8_t bestd = 0;
    7256:	48 43       	clr.b	r8		;

00007258 <.Loc.429.1>:
    uint8_t bestc = 0;
    7258:	07 48       	mov	r8,	r7	;

0000725a <.LBB63>:
      err = rate - (tmp * i);
    725a:	84 00 9e ce 	mova	#52894,	r4	;0x0ce9e

0000725e <.Loc.442.1>:
      if (err == 0 || i*i > rate) break;
    725e:	81 4a 08 00 	mov	r10,	8(r1)	;

00007262 <.L29>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    7262:	7c 40 5c 00 	mov.b	#92,	r12	;#0x005c
    7266:	0c 95       	cmp	r5,	r12	;
    7268:	0d 2c       	jc	$+28     	;abs 0x7284

0000726a <.L31>:
    sx1212SetRegister(devp, MCParam3, bestc);
    726a:	8a 00 ba 6f 	mova	#28602,	r10	;0x06fba

0000726e <.LVL70>:
    726e:	4e 47       	mov.b	r7,	r14	;
    7270:	7d 40 03 00 	mov.b	#3,	r13	;
    7274:	cc 06       	mova	r6,	r12	;
    7276:	4a 13       	calla	r10		;

00007278 <.LVL71>:
    sx1212SetRegister(devp, MCParam4, bestd);
    7278:	4e 48       	mov.b	r8,	r14	;
    727a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    727c:	cc 06       	mova	r6,	r12	;
    727e:	4a 13       	calla	r10		;

00007280 <.LBE61>:
}
    7280:	80 00 3e 72 	mova	#29246,	r0	;0x0723e

00007284 <.L33>:
      tmp = rate / i;
    7284:	0e 45       	mov	r5,	r14	;
    7286:	0f 43       	clr	r15		;
    7288:	0c 4a       	mov	r10,	r12	;
    728a:	0d 49       	mov	r9,	r13	;
    728c:	b0 13 c8 cc 	calla	#52424		;0x0ccc8

00007290 <.Loc.437.1>:
      err = rate - (tmp * i);
    7290:	4e 4c       	mov.b	r12,	r14	;
    7292:	4f 45       	mov.b	r5,	r15	;
    7294:	0d 4f       	mov	r15,	r13	;
    7296:	0c 4e       	mov	r14,	r12	;
    7298:	71 0e 04 00 	mova	r14,	4(r1)	;
    729c:	71 0f 00 00 	mova	r15,	0(r1)	;
    72a0:	44 13       	calla	r4		;
    72a2:	4d 4a       	mov.b	r10,	r13	;
    72a4:	4d 8c       	sub.b	r12,	r13	;
    72a6:	4c 4d       	mov.b	r13,	r12	;
    72a8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000072ac <.LVL76>:
      if (err < besterr) {
    72ac:	3e 01 04 00 	mova	4(r1),	r14	;
    72b0:	0f 01       	mova	@r1,	r15	;
    72b2:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    72b4:	06 24       	jz	$+14     	;abs 0x72c2
    72b6:	7f 53       	add.b	#-1,	r15	;r3 As==11
    72b8:	47 4f       	mov.b	r15,	r7	;

000072ba <.LVL77>:
        bestd = tmp - 1;
    72ba:	7e 53       	add.b	#-1,	r14	;r3 As==11
    72bc:	48 4e       	mov.b	r14,	r8	;

000072be <.LVL78>:
      if (err == 0 || i*i > rate) break;
    72be:	0d 93       	cmp	#0,	r13	;r3 As==00
    72c0:	d4 27       	jz	$-86     	;abs 0x726a

000072c2 <.L30>:
    72c2:	0d 45       	mov	r5,	r13	;
    72c4:	0c 45       	mov	r5,	r12	;

000072c6 <.LVL80>:
    72c6:	44 13       	calla	r4		;
    72c8:	4d 43       	clr.b	r13		;
    72ca:	0d 99       	cmp	r9,	r13	;
    72cc:	03 20       	jnz	$+8      	;abs 0x72d4
    72ce:	81 9c 08 00 	cmp	r12,	8(r1)	;
    72d2:	cb 2b       	jnc	$-104    	;abs 0x726a

000072d4 <.L36>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    72d4:	15 53       	inc	r5		;
    72d6:	80 00 62 72 	mova	#29282,	r0	;0x07262

000072da <sx1212SetDeviation>:
void sx1212SetDeviation(SX1212Driver *devp, uint32_t fdev) {
    72da:	4a 14       	pushm.a	#5,	r10	;20-bit words

000072dc <.LCFI10>:
    72dc:	ca 0c       	mova	r12,	r10	;
    72de:	08 4d       	mov	r13,	r8	;
    72e0:	09 4e       	mov	r14,	r9	;

000072e2 <.Loc.459.1>:
  uint16_t regs = ((SX1212_CLK_FREQ >> 5) + (fdev >> 1))/ fdev;
    72e2:	06 4d       	mov	r13,	r6	;
    72e4:	07 4e       	mov	r14,	r7	;
    72e6:	12 c3       	clrc			
    72e8:	07 10       	rrc	r7		;
    72ea:	06 10       	rrc	r6		;
    72ec:	0e 4d       	mov	r13,	r14	;
    72ee:	0f 49       	mov	r9,	r15	;
    72f0:	0c 46       	mov	r6,	r12	;

000072f2 <.LVL84>:
    72f2:	3c 50 80 1a 	add	#6784,	r12	;#0x1a80
    72f6:	0d 47       	mov	r7,	r13	;

000072f8 <.LVL85>:
    72f8:	3d 60 06 00 	addc	#6,	r13	;
    72fc:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    7300:	07 4c       	mov	r12,	r7	;

00007302 <.Loc.461.1>:
  osalDbgAssert(fdev < 200000, "deviation too high");
    7302:	7c 40 03 00 	mov.b	#3,	r12	;
    7306:	0c 99       	cmp	r9,	r12	;
    7308:	07 28       	jnc	$+16     	;abs 0x7318
    730a:	39 90 03 00 	cmp	#3,	r9	;
    730e:	08 20       	jnz	$+18     	;abs 0x7320
    7310:	3c 40 3f 0d 	mov	#3391,	r12	;#0x0d3f
    7314:	0c 98       	cmp	r8,	r12	;
    7316:	04 2c       	jc	$+10     	;abs 0x7320

00007318 <.L46>:
    7318:	8c 01 f6 05 	mova	#67062,	r12	;0x105f6
    731c:	b0 13 dc 47 	calla	#18396		;0x047dc

00007320 <.L44>:
  sx1212SetRegister(devp, MCParam2, regs - 1);
    7320:	4e 47       	mov.b	r7,	r14	;
    7322:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7324:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7326:	cc 0a       	mova	r10,	r12	;
    7328:	b0 13 ba 6f 	calla	#28602		;0x06fba

0000732c <.LVL89>:
}
    732c:	46 16       	popm.a	#5,	r10	;20-bit words
    732e:	10 01       	reta			;

00007330 <sx1212SetFrequency>:
void sx1212SetFrequency(SX1212Driver *devp, uint32_t freq) {
    7330:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007332 <.LCFI11>:
    7332:	b1 00 16 00 	suba	#22,	r1	;0x00016

00007336 <.LCFI12>:
    7336:	c4 0c       	mova	r12,	r4	;
    7338:	0a 4d       	mov	r13,	r10	;
    733a:	05 4e       	mov	r14,	r5	;

0000733c <.Loc.479.1>:
  osalDbgAssert(freq >= 300000000 && freq <= 510000000, 
    733c:	0c 4d       	mov	r13,	r12	;

0000733e <.LVL91>:
    733e:	3c 50 00 5d 	add	#23808,	r12	;#0x5d00
    7342:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    7346:	0d 4e       	mov	r14,	r13	;

00007348 <.LVL92>:
    7348:	3d 60 1e ee 	addc	#-4578,	r13	;#0xee1e
    734c:	81 4d 04 00 	mov	r13,	4(r1)	;
    7350:	3e 40 84 0c 	mov	#3204,	r14	;#0x0c84
    7354:	0e 9d       	cmp	r13,	r14	;
    7356:	07 28       	jnc	$+16     	;abs 0x7366
    7358:	0d 9e       	cmp	r14,	r13	;
    735a:	09 20       	jnz	$+20     	;abs 0x736e
    735c:	3c 40 80 58 	mov	#22656,	r12	;#0x5880
    7360:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7364:	04 2c       	jc	$+10     	;abs 0x736e

00007366 <.L82>:
    7366:	8c 01 e3 05 	mova	#67043,	r12	;0x105e3
    736a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000736e <.L48>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    736e:	0c 4a       	mov	r10,	r12	;
    7370:	0d 45       	mov	r5,	r13	;
    7372:	b0 13 34 cd 	calla	#52532		;0x0cd34
    7376:	81 4c 06 00 	mov	r12,	6(r1)	;
    737a:	81 4d 08 00 	mov	r13,	8(r1)	;

0000737e <.LBB69>:
  osalDbgAssert(u != 0 && v != 0, "doesn't support 0s");
    737e:	0c dd       	bis	r13,	r12	;

00007380 <.LVL96>:
    7380:	0c 93       	cmp	#0,	r12	;r3 As==00
    7382:	04 20       	jnz	$+10     	;abs 0x738c
    7384:	8c 01 df 05 	mova	#67039,	r12	;0x105df
    7388:	b0 13 dc 47 	calla	#18396		;0x047dc

0000738c <.L50>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    738c:	18 41 06 00 	mov	6(r1),	r8	;
    7390:	19 41 08 00 	mov	8(r1),	r9	;
    7394:	4e 43       	clr.b	r14		;
    7396:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    739a:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd

0000739e <.L51>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    739e:	0f 48       	mov	r8,	r15	;
    73a0:	0f dc       	bis	r12,	r15	;
    73a2:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    73a6:	b9 24       	jz	$+372    	;abs 0x751a

000073a8 <.L54>:
  while((u & 1) == 0)
    73a8:	0f 48       	mov	r8,	r15	;
    73aa:	5f f3       	and.b	#1,	r15	;r3 As==01
    73ac:	0f 93       	cmp	#0,	r15	;r3 As==00
    73ae:	be 24       	jz	$+382    	;abs 0x752c

000073b0 <.L57>:
    while ((v & 1) == 0)
    73b0:	0f 4c       	mov	r12,	r15	;
    73b2:	5f f3       	and.b	#1,	r15	;r3 As==01
    73b4:	0f 93       	cmp	#0,	r15	;r3 As==00
    73b6:	bf 24       	jz	$+384    	;abs 0x7536

000073b8 <.Loc.395.1>:
    if (u > v) {
    73b8:	0d 99       	cmp	r9,	r13	;
    73ba:	0a 28       	jnc	$+22     	;abs 0x73d0
    73bc:	09 9d       	cmp	r13,	r9	;
    73be:	02 20       	jnz	$+6      	;abs 0x73c4
    73c0:	0c 98       	cmp	r8,	r12	;
    73c2:	06 28       	jnc	$+14     	;abs 0x73d0

000073c4 <.L83>:
    73c4:	06 4c       	mov	r12,	r6	;
    73c6:	07 4d       	mov	r13,	r7	;
    73c8:	0c 48       	mov	r8,	r12	;

000073ca <.LVL100>:
    73ca:	0d 49       	mov	r9,	r13	;
    73cc:	08 46       	mov	r6,	r8	;

000073ce <.LVL101>:
    73ce:	09 47       	mov	r7,	r9	;

000073d0 <.L60>:
    v = v - u;
    73d0:	06 48       	mov	r8,	r6	;
    73d2:	07 49       	mov	r9,	r7	;
    73d4:	40 18 06 8c 	subx.w	r12,	r6	;
    73d8:	40 18 07 7d 	subcx.w	r13,	r7	;

000073dc <.LVL103>:
  } while (v != 0);
    73dc:	0f 46       	mov	r6,	r15	;
    73de:	0f d7       	bis	r7,	r15	;
    73e0:	0f 93       	cmp	#0,	r15	;r3 As==00
    73e2:	b0 20       	jnz	$+354    	;abs 0x7544

000073e4 <.Loc.403.1>:
  return u << shift;
    73e4:	0f 43       	clr	r15		;
    73e6:	b0 13 48 cd 	calla	#52552		;0x0cd48

000073ea <.LVL104>:
    73ea:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    73ee:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

000073f2 <.LBE73>:
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
    73f2:	0e 4c       	mov	r12,	r14	;
    73f4:	0f 4d       	mov	r13,	r15	;
    73f6:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    73fa:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    73fe:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    7402:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    7406:	81 4d 0e 00 	mov	r13,	14(r1)	; 0x000e

0000740a <.LVL107>:
  while (r_mult - (75 * i) > 169) {
    740a:	08 4c       	mov	r12,	r8	;
    740c:	09 4d       	mov	r13,	r9	;

0000740e <.L63>:
    740e:	09 93       	cmp	#0,	r9	;r3 As==00
    7410:	9f 20       	jnz	$+320    	;abs 0x7550
    7412:	7d 40 a9 00 	mov.b	#169,	r13	;#0x00a9
    7416:	0d 98       	cmp	r8,	r13	;
    7418:	9b 28       	jnc	$+312    	;abs 0x7550

0000741a <.LVL109>:
  r = r_mult - 1;
    741a:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    741e:	46 48       	mov.b	r8,	r6	;
    7420:	76 53       	add.b	#-1,	r6	;r3 As==11

00007422 <.L91>:
    r += r_mult;
    7422:	36 f0 ff 00 	and	#255,	r6	;#0x00ff

00007426 <.LVL111>:
  while (r < 64 || r > 169) {
    7426:	4c 46       	mov.b	r6,	r12	;
    7428:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0
    742c:	7e 40 69 00 	mov.b	#105,	r14	;#0x0069
    7430:	4e 9c       	cmp.b	r12,	r14	;
    7432:	93 28       	jnc	$+296    	;abs 0x755a

00007434 <.Loc.511.1>:
  r -= r_mult;
    7434:	46 88       	sub.b	r8,	r6	;

00007436 <.LVL112>:
    7436:	49 46       	mov.b	r6,	r9	;

00007438 <.LVL113>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    7438:	86 00 c8 cc 	mova	#52424,	r6	;0x0ccc8

0000743c <.L68>:
    r += r_mult;
    743c:	4c 49       	mov.b	r9,	r12	;
    743e:	4c 58       	add.b	r8,	r12	;
    7440:	49 4c       	mov.b	r12,	r9	;

00007442 <.LVL115>:
  } while (r < 64 || r > 169 || s > p);
    7442:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0

00007446 <.LVL116>:
    7446:	7d 40 69 00 	mov.b	#105,	r13	;#0x0069
    744a:	4d 9c       	cmp.b	r12,	r13	;
    744c:	f7 2b       	jnc	$-16     	;abs 0x743c

0000744e <.Loc.514.1>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    744e:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    7452:	1f 41 14 00 	mov	20(r1),	r15	;0x00014
    7456:	1c 41 06 00 	mov	6(r1),	r12	;

0000745a <.LVL117>:
    745a:	1d 41 08 00 	mov	8(r1),	r13	;
    745e:	46 13       	calla	r6		;
    7460:	0e 49       	mov	r9,	r14	;
    7462:	1e 53       	inc	r14		;
    7464:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    7468:	0f 7f       	subc	r15,	r15	;
    746a:	3f e3       	inv	r15		;
    746c:	b0 13 b4 ce 	calla	#52916		;0x0ceb4
    7470:	1e 41 0c 00 	mov	12(r1),	r14	;0x0000c
    7474:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    7478:	46 13       	calla	r6		;
    747a:	07 4c       	mov	r12,	r7	;

0000747c <.Loc.515.1>:
    p = (temp / 75) - 1;
    747c:	7e 40 4b 00 	mov.b	#75,	r14	;#0x004b
    7480:	4f 43       	clr.b	r15		;
    7482:	46 13       	calla	r6		;
    7484:	4e 4c       	mov.b	r12,	r14	;
    7486:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7488:	4c 4e       	mov.b	r14,	r12	;
    748a:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010

0000748e <.Loc.516.1>:
    s = temp - ((p+1)*75);
    748e:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    7492:	1c 53       	inc	r12		;
    7494:	71 0e 00 00 	mova	r14,	0(r1)	;
    7498:	b0 13 9e ce 	calla	#52894		;0x0ce9e
    749c:	47 8c       	sub.b	r12,	r7	;
    749e:	4c 47       	mov.b	r7,	r12	;
    74a0:	37 f0 ff 00 	and	#255,	r7	;#0x00ff

000074a4 <.Loc.517.1>:
  } while (r < 64 || r > 169 || s > p);
    74a4:	0e 01       	mova	@r1,	r14	;
    74a6:	4e 9c       	cmp.b	r12,	r14	;
    74a8:	c9 2b       	jnc	$-108    	;abs 0x743c

000074aa <.Loc.519.1>:
  sx1212SetRegister(devp, MCParam6, r);
    74aa:	88 00 ba 6f 	mova	#28602,	r8	;0x06fba
    74ae:	4e 49       	mov.b	r9,	r14	;
    74b0:	7d 40 06 00 	mov.b	#6,	r13	;
    74b4:	cc 04       	mova	r4,	r12	;
    74b6:	48 13       	calla	r8		;

000074b8 <.LVL123>:
  sx1212SetRegister(devp, MCParam7, p);
    74b8:	1d 41 10 00 	mov	16(r1),	r13	;0x00010
    74bc:	4e 4d       	mov.b	r13,	r14	;
    74be:	7d 40 07 00 	mov.b	#7,	r13	;
    74c2:	cc 04       	mova	r4,	r12	;
    74c4:	48 13       	calla	r8		;

000074c6 <.LVL124>:
  sx1212SetRegister(devp, MCParam8, s);
    74c6:	4e 47       	mov.b	r7,	r14	;
    74c8:	7d 42       	mov.b	#8,	r13	;r2 As==11
    74ca:	cc 04       	mova	r4,	r12	;
    74cc:	48 13       	calla	r8		;

000074ce <.LVL125>:
  if (freq >= 300000000 && freq <= 330000000) {
    74ce:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    74d2:	1e 91 04 00 	cmp	4(r1),	r14	;
    74d6:	44 28       	jnc	$+138    	;abs 0x7560
    74d8:	1c 41 04 00 	mov	4(r1),	r12	;
    74dc:	0c 9e       	cmp	r14,	r12	;
    74de:	05 20       	jnz	$+12     	;abs 0x74ea
    74e0:	3c 40 80 c3 	mov	#-15488,r12	;#0xc380
    74e4:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    74e8:	3b 28       	jnc	$+120    	;abs 0x7560

000074ea <.L85>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    74ea:	5a 44 04 00 	mov.b	4(r4),	r10	;
    74ee:	7a f0 e0 ff 	and.b	#-32,	r10	;#0xffe0

000074f2 <.Loc.526.1>:
      0x00 << 2 | ((freq - 300000000) / 7500000);
    74f2:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    74f6:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    74fa:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    74fe:	1d 41 04 00 	mov	4(r1),	r13	;

00007502 <.L93>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    7502:	46 13       	calla	r6		;
    7504:	4e 4a       	mov.b	r10,	r14	;

00007506 <.L92>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    7506:	4e dc       	bis.b	r12,	r14	;

00007508 <.Loc.550.1>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    7508:	c4 4e 04 00 	mov.b	r14,	4(r4)	;

0000750c <.Loc.552.1>:
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    750c:	4d 43       	clr.b	r13		;
    750e:	cc 04       	mova	r4,	r12	;
    7510:	48 13       	calla	r8		;

00007512 <.L47>:
}
    7512:	a1 00 16 00 	adda	#22,	r1	;0x00016
    7516:	64 16       	popm.a	#7,	r10	;20-bit words
    7518:	10 01       	reta			;

0000751a <.L52>:
    u >>= 1;
    751a:	12 c3       	clrc			
    751c:	09 10       	rrc	r9		;
    751e:	08 10       	rrc	r8		;

00007520 <.Loc.385.1>:
    v >>= 1;
    7520:	12 c3       	clrc			
    7522:	0d 10       	rrc	r13		;
    7524:	0c 10       	rrc	r12		;

00007526 <.Loc.383.1>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    7526:	1e 53       	inc	r14		;
    7528:	80 00 9e 73 	mova	#29598,	r0	;0x0739e

0000752c <.L55>:
    u >>= 1;
    752c:	12 c3       	clrc			
    752e:	09 10       	rrc	r9		;
    7530:	08 10       	rrc	r8		;
    7532:	80 00 a8 73 	mova	#29608,	r0	;0x073a8

00007536 <.L58>:
      v >>= 1;
    7536:	06 4c       	mov	r12,	r6	;
    7538:	07 4d       	mov	r13,	r7	;
    753a:	12 c3       	clrc			
    753c:	07 10       	rrc	r7		;
    753e:	06 10       	rrc	r6		;

00007540 <.LVL134>:
    7540:	0c 48       	mov	r8,	r12	;
    7542:	0d 49       	mov	r9,	r13	;

00007544 <.L62>:
    7544:	08 4c       	mov	r12,	r8	;
    7546:	09 4d       	mov	r13,	r9	;
    7548:	0c 46       	mov	r6,	r12	;
    754a:	0d 47       	mov	r7,	r13	;
    754c:	80 00 b0 73 	mova	#29616,	r0	;0x073b0

00007550 <.L64>:
    7550:	38 50 b5 ff 	add	#-75,	r8	;#0xffb5
    7554:	39 63       	addc	#-1,	r9	;r3 As==11
    7556:	80 00 0e 74 	mova	#29710,	r0	;0x0740e

0000755a <.L67>:
    r += r_mult;
    755a:	46 58       	add.b	r8,	r6	;

0000755c <.LVL138>:
    755c:	80 00 22 74 	mova	#29730,	r0	;0x07422

00007560 <.L70>:
  else if (freq >= 320000000 && freq <= 350000000) {
    7560:	0c 4a       	mov	r10,	r12	;
    7562:	3c 50 00 30 	add	#12288,	r12	;#0x3000
    7566:	0d 45       	mov	r5,	r13	;
    7568:	3d 60 ed ec 	addc	#-4883,	r13	;#0xeced
    756c:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    7570:	0e 9d       	cmp	r13,	r14	;
    7572:	13 28       	jnc	$+40     	;abs 0x759a
    7574:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    7578:	04 20       	jnz	$+10     	;abs 0x7582
    757a:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    757e:	0e 9c       	cmp	r12,	r14	;
    7580:	0c 28       	jnc	$+26     	;abs 0x759a

00007582 <.L86>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    7582:	5e 44 04 00 	mov.b	4(r4),	r14	;
    7586:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    758a:	4a 4e       	mov.b	r14,	r10	;
    758c:	6a d2       	bis.b	#4,	r10	;r2 As==10
    758e:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    7592:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    7596:	80 00 02 75 	mova	#29954,	r0	;0x07502

0000759a <.L73>:
  else if (freq >= 350000000 && freq <= 390000000) {
    759a:	0c 4a       	mov	r10,	r12	;
    759c:	3c 50 80 6c 	add	#27776,	r12	;#0x6c80
    75a0:	0d 45       	mov	r5,	r13	;
    75a2:	3d 60 23 eb 	addc	#-5341,	r13	;#0xeb23
    75a6:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    75aa:	0e 9d       	cmp	r13,	r14	;
    75ac:	13 28       	jnc	$+40     	;abs 0x75d4
    75ae:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    75b2:	04 20       	jnz	$+10     	;abs 0x75bc
    75b4:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    75b8:	0e 9c       	cmp	r12,	r14	;
    75ba:	0c 28       	jnc	$+26     	;abs 0x75d4

000075bc <.L87>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    75bc:	5e 44 04 00 	mov.b	4(r4),	r14	;
    75c0:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    75c4:	4a 4e       	mov.b	r14,	r10	;
    75c6:	7a d2       	bis.b	#8,	r10	;r2 As==11

000075c8 <.L94>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    75c8:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    75cc:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    75d0:	80 00 02 75 	mova	#29954,	r0	;0x07502

000075d4 <.L75>:
  else if (freq >= 390000000 && freq <= 430000000) {
    75d4:	0c 4a       	mov	r10,	r12	;
    75d6:	3c 50 80 12 	add	#4736,	r12	;#0x1280
    75da:	0d 45       	mov	r5,	r13	;
    75dc:	3d 60 c1 e8 	addc	#-5951,	r13	;#0xe8c1
    75e0:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    75e4:	0e 9d       	cmp	r13,	r14	;
    75e6:	10 28       	jnc	$+34     	;abs 0x7608
    75e8:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    75ec:	04 20       	jnz	$+10     	;abs 0x75f6
    75ee:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    75f2:	0e 9c       	cmp	r12,	r14	;
    75f4:	09 28       	jnc	$+20     	;abs 0x7608

000075f6 <.L88>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    75f6:	5e 44 04 00 	mov.b	4(r4),	r14	;
    75fa:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    75fe:	4a 4e       	mov.b	r14,	r10	;
    7600:	7a d0 0c 00 	bis.b	#12,	r10	;#0x000c
    7604:	80 00 c8 75 	mova	#30152,	r0	;0x075c8

00007608 <.L77>:
  else if (freq >= 430000000 && freq <= 470000000) {
    7608:	0c 4a       	mov	r10,	r12	;
    760a:	3c 50 80 b8 	add	#-18304,r12	;#0xb880
    760e:	0d 45       	mov	r5,	r13	;
    7610:	3d 60 5e e6 	addc	#-6562,	r13	;#0xe65e
    7614:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    7618:	0e 9d       	cmp	r13,	r14	;
    761a:	10 28       	jnc	$+34     	;abs 0x763c
    761c:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    7620:	04 20       	jnz	$+10     	;abs 0x762a
    7622:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7626:	0e 9c       	cmp	r12,	r14	;
    7628:	09 28       	jnc	$+20     	;abs 0x763c

0000762a <.L89>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    762a:	5e 44 04 00 	mov.b	4(r4),	r14	;
    762e:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7632:	4a 4e       	mov.b	r14,	r10	;
    7634:	7a d0 10 00 	bis.b	#16,	r10	;#0x0010
    7638:	80 00 c8 75 	mova	#30152,	r0	;0x075c8

0000763c <.L79>:
  else if (freq >= 470000000 && freq <= 510000000) {
    763c:	0c 4a       	mov	r10,	r12	;
    763e:	3c 50 80 5e 	add	#24192,	r12	;#0x5e80
    7642:	0d 45       	mov	r5,	r13	;
    7644:	3d 60 fc e3 	addc	#-7172,	r13	;#0xe3fc
    7648:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    764c:	0e 9d       	cmp	r13,	r14	;
    764e:	61 2b       	jnc	$-316    	;abs 0x7512
    7650:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    7654:	04 20       	jnz	$+10     	;abs 0x765e
    7656:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    765a:	0e 9c       	cmp	r12,	r14	;
    765c:	5a 2b       	jnc	$-330    	;abs 0x7512

0000765e <.L90>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    765e:	5e 44 04 00 	mov.b	4(r4),	r14	;
    7662:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7666:	49 4e       	mov.b	r14,	r9	;

00007668 <.LVL140>:
    7668:	79 d0 14 00 	bis.b	#20,	r9	;#0x0014
    766c:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    7670:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    7674:	46 13       	calla	r6		;
    7676:	4e 49       	mov.b	r9,	r14	;
    7678:	80 00 06 75 	mova	#29958,	r0	;0x07506

0000767c <sx1212SetSync>:
void sx1212SetSync(SX1212Driver *devp, SX1212_SYNC_TYPE sync) {
    767c:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000767e <.LCFI13>:
    767e:	ca 0c       	mova	r12,	r10	;
    7680:	08 4d       	mov	r13,	r8	;
    7682:	09 4e       	mov	r14,	r9	;

00007684 <.LVL143>:
    7684:	77 40 16 00 	mov.b	#22,	r7	;#0x0016
    7688:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

0000768c <.LBB75>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    768c:	86 00 ba 6f 	mova	#28602,	r6	;0x06fba

00007690 <.L96>:
        sync >> (8 * (sizeof(sync) - 1 - i)));
    7690:	0c 48       	mov	r8,	r12	;
    7692:	0d 49       	mov	r9,	r13	;
    7694:	0e 45       	mov	r5,	r14	;
    7696:	0f 43       	clr	r15		;
    7698:	b0 13 70 ce 	calla	#52848		;0x0ce70

0000769c <.Loc.574.1>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    769c:	4e 4c       	mov.b	r12,	r14	;
    769e:	4d 47       	mov.b	r7,	r13	;
    76a0:	cc 0a       	mova	r10,	r12	;
    76a2:	46 13       	calla	r6		;

000076a4 <.LVL146>:
    76a4:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8
    76a8:	4c 47       	mov.b	r7,	r12	;
    76aa:	5c 53       	inc.b	r12		;
    76ac:	47 4c       	mov.b	r12,	r7	;

000076ae <.Loc.573.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    76ae:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    76b2:	ee 23       	jnz	$-34     	;abs 0x7690

000076b4 <.LBE75>:
}
    76b4:	55 16       	popm.a	#6,	r10	;20-bit words
    76b6:	10 01       	reta			;

000076b8 <sx1212SetRxBw>:
 * @param[in] bandwidth the receiver bandwidth to use minus one, in steps of 25 kHz
 * 
 * @note The bandwidth specifiedd here is for the active filter. Passive
 *       filter bandwidth is set automatically according to datasheet
 */
void sx1212SetRxBw(SX1212Driver *devp, uint8_t bandwidth) {
    76b8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000076ba <.LCFI14>:
    76ba:	08 14       	pushm.a	#1,	r8	;20-bit words

000076bc <.LCFI15>:
    76bc:	c8 0c       	mova	r12,	r8	;
    76be:	4a 4d       	mov.b	r13,	r10	;

000076c0 <.Loc.729.1>:
  static const uint8_t passive[16] = {
    1, 4, 7, 9, 10, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15
  };
  
  osalDbgAssert(bandwidth < 16, "requested bandwidth is too wide");
    76c0:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

000076c4 <.LVL148>:
    76c4:	4c 9a       	cmp.b	r10,	r12	;
    76c6:	04 2c       	jc	$+10     	;abs 0x76d0

000076c8 <.Loc.729.1>:
    76c8:	8c 01 d1 05 	mova	#67025,	r12	;0x105d1
    76cc:	b0 13 dc 47 	calla	#18396		;0x047dc

000076d0 <.L99>:
  
  /* Passive filter bandwidth to be between 3 and 4 times active filter 
   * bandwidth, per datasheet. This is precalculated because there's no obvious
   * mapping. */
  sx1212SetRegister(devp, RXParam0, (passive[bandwidth] << 4) | bandwidth);
    76d0:	0d 4a       	mov	r10,	r13	;
    76d2:	4d 0e       	rlam.a	#4,	r13	;
    76d4:	4d 0d       	rram.a	#4,	r13	;
    76d6:	c0 18 5e 4d 	movx.b	67009(r13),r14	;0x105c1
    76da:	c1 05 
    76dc:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    76e0:	4e da       	bis.b	r10,	r14	;
    76e2:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    76e6:	cc 08       	mova	r8,	r12	;
    76e8:	b0 13 ba 6f 	calla	#28602		;0x06fba

000076ec <.LVL150>:
}
    76ec:	08 16       	popm.a	#1,	r8	;20-bit words
    76ee:	0a 16       	popm.a	#1,	r10	;20-bit words
    76f0:	10 01       	reta			;

000076f2 <sx1212Start>:
 * @param[in] devp      pointer to the @p SX1212Driver object
 * @param[in] config    pointer to the @p SX1212Config object
 *
 * @api
 */
void sx1212Start(SX1212Driver *devp, const SX1212Config *config) {
    76f2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000076f4 <.LCFI16>:
    76f4:	08 14       	pushm.a	#1,	r8	;20-bit words

000076f6 <.LCFI17>:
    76f6:	06 14       	pushm.a	#1,	r6	;20-bit words

000076f8 <.LCFI18>:
    76f8:	04 14       	pushm.a	#1,	r4	;20-bit words

000076fa <.LCFI19>:
    76fa:	ca 0c       	mova	r12,	r10	;
    76fc:	c8 0d       	mova	r13,	r8	;

000076fe <.Loc.957.1>:
  
  devp->config = config;
    76fe:	7a 0d 00 00 	mova	r13,	0(r10)	;

00007702 <.Loc.959.1>:
  /* Reset the device to get it into a known state */
  sx1212Reset(devp);
    7702:	b0 13 58 70 	calla	#28760		;0x07058

00007706 <.LVL152>:
  /* Set all the stored registers to their reset states */
  devp->regs.MCParam0 = 0x30;
    7706:	fa 40 30 00 	mov.b	#48,	4(r10)	;#0x0030
    770a:	04 00 

0000770c <.Loc.962.1>:
  devp->regs.IRQParam0 = 0x0F;
    770c:	fa 40 0f 00 	mov.b	#15,	5(r10)	;#0x000f
    7710:	05 00 

00007712 <.Loc.965.1>:
  
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    7712:	3d 08 04 00 	mova	4(r8),	r13	;
    7716:	0c 08       	mova	@r8,	r12	;
    7718:	b0 13 7c 51 	calla	#20860		;0x0517c

0000771c <.LVL153>:
  /* Put the SPI interface into Config mode */
  spi_mode_config(devp);
    771c:	cc 0a       	mova	r10,	r12	;
    771e:	b0 13 c0 71 	calla	#29120		;0x071c0

00007722 <.LVL154>:
  
  /* Put the device into sleep mode */
  sx1212SetMode(devp, SX1212Sleep);
    7722:	4d 43       	clr.b	r13		;
    7724:	cc 0a       	mova	r10,	r12	;
    7726:	b0 13 0a 70 	calla	#28682		;0x0700a

0000772a <.LVL155>:
  /* Set device configuration */
  sx1212SetFrequency(devp, config->freq);
    772a:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    772e:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    7732:	cc 0a       	mova	r10,	r12	;
    7734:	b0 13 30 73 	calla	#29488		;0x07330

00007738 <.LVL156>:
  sx1212SetDeviation(devp, config->fdev);
    7738:	1d 48 14 00 	mov	20(r8),	r13	;0x00014
    773c:	1e 48 16 00 	mov	22(r8),	r14	;0x00016
    7740:	cc 0a       	mova	r10,	r12	;
    7742:	b0 13 da 72 	calla	#29402		;0x072da

00007746 <.LVL157>:
  sx1212SetBitrate(devp, config->bitrate);
    7746:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    774a:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    774e:	cc 0a       	mova	r10,	r12	;
    7750:	b0 13 da 71 	calla	#29146		;0x071da

00007754 <.LVL158>:
  sx1212SetRxBw(devp, config->rx_bw);
    7754:	5d 48 18 00 	mov.b	24(r8),	r13	;0x00018
    7758:	cc 0a       	mova	r10,	r12	;
    775a:	b0 13 b8 76 	calla	#30392		;0x076b8

0000775e <.LVL159>:
  sx1212SetSync(devp, config->sync_word);
    775e:	1d 48 1c 00 	mov	28(r8),	r13	;0x0001c
    7762:	1e 48 1e 00 	mov	30(r8),	r14	;0x0001e
    7766:	cc 0a       	mova	r10,	r12	;
    7768:	b0 13 7c 76 	calla	#30332		;0x0767c

0000776c <.LVL160>:
    776c:	86 00 ba 6f 	mova	#28602,	r6	;0x06fba

00007770 <.Loc.977.1>:
  if (config->packet_config != NULL) {
    7770:	00 18 c8 93 	cmpx.a	#0,	38(r8)	;r3 As==00, 0x00026
    7774:	26 00 
    7776:	8a 24       	jz	$+278    	;abs 0x788c

00007778 <.Loc.978.1>:
    sx1212ConfigurePackets(devp, devp->config->packet_config);
    7778:	0c 0a       	mova	@r10,	r12	;
    777a:	34 0c 26 00 	mova	38(r12),r4	;0x00026

0000777e <.LBB78>:
  sx1212SetRegister(devp, MCParam1, 0xA4);
    777e:	7e 40 a4 ff 	mov.b	#-92,	r14	;#0xffa4
    7782:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7784:	cc 0a       	mova	r10,	r12	;
    7786:	46 13       	calla	r6		;

00007788 <.LVL162>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
    7788:	6c 44       	mov.b	@r4,	r12	;
    778a:	7c f0 06 00 	and.b	#6,	r12	;
    778e:	7c 90 06 00 	cmp.b	#6,	r12	;
    7792:	04 20       	jnz	$+10     	;abs 0x779c
    7794:	8c 01 92 05 	mova	#66962,	r12	;0x10592
    7798:	b0 13 dc 47 	calla	#18396		;0x047dc

0000779c <.L102>:
  osalDbgAssert(devp->config->length < 128, "requested packet size too long");
    779c:	0c 0a       	mova	@r10,	r12	;
    779e:	cc 93 2b 00 	cmp.b	#0,	43(r12)	;r3 As==00, 0x002b
    77a2:	04 34       	jge	$+10     	;abs 0x77ac
    77a4:	8c 01 92 05 	mova	#66962,	r12	;0x10592
    77a8:	b0 13 dc 47 	calla	#18396		;0x047dc

000077ac <.L103>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    77ac:	6e 44       	mov.b	@r4,	r14	;
    77ae:	44 18 0e 5e 	rpt #5 { rlax.w	r14		;
    77b2:	7e f0 80 00 	and.b	#128,	r14	;#0x0080

000077b6 <.Loc.763.1>:
     devp->config->length);
    77b6:	0c 0a       	mova	@r10,	r12	;

000077b8 <.Loc.762.1>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    77b8:	5e dc 2b 00 	bis.b	43(r12),r14	;0x0002b
    77bc:	7d 40 1c 00 	mov.b	#28,	r13	;#0x001c
    77c0:	cc 0a       	mova	r10,	r12	;
    77c2:	46 13       	calla	r6		;

000077c4 <.LVL165>:
  if (!packet_config->broadcast) {
    77c4:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    77c8:	00 00 
    77ca:	0b 20       	jnz	$+24     	;abs 0x77e2

000077cc <.Loc.767.1>:
    packet_config->broadcast = packet_config->addressing;
    77cc:	6d 44       	mov.b	@r4,	r13	;
    77ce:	0c 4d       	mov	r13,	r12	;
    77d0:	5c 0f       	rrum	#4,	r12	;
    77d2:	5c f3       	and.b	#1,	r12	;r3 As==01
    77d4:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    77d8:	7d f0 9f ff 	and.b	#-97,	r13	;#0xff9f
    77dc:	4d dc       	bis.b	r12,	r13	;
    77de:	c4 4d 00 00 	mov.b	r13,	0(r4)	;

000077e2 <.L104>:
  if (packet_config->broadcast) {
    77e2:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    77e6:	00 00 
    77e8:	07 24       	jz	$+16     	;abs 0x77f8

000077ea <.Loc.772.1>:
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
    77ea:	0c 0a       	mova	@r10,	r12	;
    77ec:	5e 4c 2a 00 	mov.b	42(r12),r14	;0x0002a
    77f0:	7d 40 1d 00 	mov.b	#29,	r13	;#0x001d
    77f4:	cc 0a       	mova	r10,	r12	;
    77f6:	46 13       	calla	r6		;

000077f8 <.L105>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    77f8:	d4 b3 00 00 	bit.b	#1,	0(r4)	;r3 As==01
    77fc:	43 20       	jnz	$+136    	;abs 0x7884
    77fe:	4d 43       	clr.b	r13		;

00007800 <.L106>:
      (packet_config->whitening << 4) |
    7800:	6f 44       	mov.b	@r4,	r15	;
    7802:	0c 4f       	mov	r15,	r12	;
    7804:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    7808:	7c f0 10 00 	and.b	#16,	r12	;#0x0010

0000780c <.Loc.779.1>:
      (packet_config->crc << 3) |
    780c:	0e 4f       	mov	r15,	r14	;
    780e:	7e f2       	and.b	#8,	r14	;r2 As==11
    7810:	4c de       	bis.b	r14,	r12	;

00007812 <.Loc.780.1>:
      (packet_config->broadcast << 1));
    7812:	0e 4f       	mov	r15,	r14	;
    7814:	5e 0f       	rrum	#4,	r14	;
    7816:	7e f0 06 00 	and.b	#6,	r14	;

0000781a <.Loc.779.1>:
      (packet_config->crc << 3) |
    781a:	4e dc       	bis.b	r12,	r14	;

0000781c <.Loc.775.1>:
  sx1212SetRegister(devp, PKTParam2, 
    781c:	4e dd       	bis.b	r13,	r14	;
    781e:	7d 40 1e 00 	mov.b	#30,	r13	;#0x001e
    7822:	cc 0a       	mova	r10,	r12	;
    7824:	46 13       	calla	r6		;

00007826 <.LVL167>:
  sx1212SetRegister(devp, PKTParam3, ((!packet_config->crc_autoclear) << 7));
    7826:	6e 44       	mov.b	@r4,	r14	;
    7828:	3e e0 80 00 	xor	#128,	r14	;#0x0080
    782c:	7e f0 80 ff 	and.b	#-128,	r14	;#0xff80
    7830:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

00007834 <.L115>:
  }
  else {
    /* Buffered mode */
    sx1212SetRegister(devp, MCParam1, 0x64);
    7834:	cc 0a       	mova	r10,	r12	;
    7836:	46 13       	calla	r6		;

00007838 <.LVL169>:
  }
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
    7838:	7c 40 03 00 	mov.b	#3,	r12	;
    783c:	5c 98 20 00 	cmp.b	32(r8),	r12	;0x00020
    7840:	04 2c       	jc	$+10     	;abs 0x784a

00007842 <.Loc.986.1>:
    7842:	8c 01 b5 05 	mova	#66997,	r12	;0x105b5
    7846:	b0 13 dc 47 	calla	#18396		;0x047dc

0000784a <.L109>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
    784a:	5e 48 20 00 	mov.b	32(r8),	r14	;0x00020
    784e:	0e 5e       	rla	r14		;

00007850 <.Loc.987.1>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
    7850:	7e d0 38 00 	bis.b	#56,	r14	;#0x0038
    7854:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    7858:	cc 0a       	mova	r10,	r12	;
    785a:	46 13       	calla	r6		;

0000785c <.LVL171>:
  
  /* IRQParam2 - enable PLL lock */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    785c:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7860:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7864:	cc 0a       	mova	r10,	r12	;
    7866:	46 13       	calla	r6		;

00007868 <.LVL172>:
  
  /* Set Fifo size to 64 */
  sx1212SetRegister(devp, IRQParam0, 0xC0);
    7868:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    786c:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    7870:	cc 0a       	mova	r10,	r12	;
    7872:	46 13       	calla	r6		;

00007874 <.LVL173>:
  devp->regs.IRQParam0 = 0xC0;
    7874:	fa 40 c0 ff 	mov.b	#-64,	5(r10)	;#0xffc0
    7878:	05 00 

0000787a <.Loc.1002.1>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(config->spip);
#endif

}
    787a:	04 16       	popm.a	#1,	r4	;20-bit words
    787c:	06 16       	popm.a	#1,	r6	;20-bit words
    787e:	08 16       	popm.a	#1,	r8	;20-bit words
    7880:	0a 16       	popm.a	#1,	r10	;20-bit words
    7882:	10 01       	reta			;

00007884 <.L110>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    7884:	3d 40 80 ff 	mov	#-128,	r13	;#0xff80
    7888:	80 00 00 78 	mova	#30720,	r0	;0x07800

0000788c <.L101>:
    sx1212SetRegister(devp, MCParam1, 0x64);
    788c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7890:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7892:	80 00 34 78 	mova	#30772,	r0	;0x07834

00007896 <sx1212ReceiveI>:
      );
  
  return MSG_OK;
}

void sx1212ReceiveI(SX1212Driver * devp, size_t n, palcallback_t callback) {
    7896:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007898 <.LCFI21>:
    7898:	08 14       	pushm.a	#1,	r8	;20-bit words

0000789a <.LCFI22>:
    789a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000789c <.LCFI23>:
    789c:	c8 0c       	mova	r12,	r8	;
    789e:	ca 0d       	mova	r13,	r10	;
    78a0:	c6 0e       	mova	r14,	r6	;

000078a2 <.Loc.1066.1>:
  static volatile size_t fft;
  fft = n - 1;
    78a2:	cc 0d       	mova	r13,	r12	;

000078a4 <.LVL182>:
    78a4:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    78a8:	60 0c 34 d1 	mova	r12,	&53556	; 0x0d134

000078ac <.Loc.1067.1>:
  osalDbgCheckClassI();
    78ac:	b0 13 54 46 	calla	#18004		;0x04654

000078b0 <.LVL183>:
  /* TODO state machine */
  
  osalDbgAssert(n < 64, "invalid threshold");
    78b0:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    78b4:	dc 0a       	cmpa	r10,	r12	;
    78b6:	04 2c       	jc	$+10     	;abs 0x78c0

000078b8 <.Loc.1070.1>:
    78b8:	8c 01 83 05 	mova	#66947,	r12	;0x10583
    78bc:	b0 13 dc 47 	calla	#18396		;0x047dc

000078c0 <.L118>:
  /* IRQs are Fifoempty_B and Fifo_threshold */
  
  /* Configure the Fifo_threshold callback appropriately */
  palLineEnableEventI(SX1212_IRQ_1, PAL_EVENT_MODE_RISING_EDGE, callback);
    78c0:	cf 06       	mova	r6,	r15	;
    78c2:	5e 43       	mov.b	#1,	r14	;r3 As==01
    78c4:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    78c8:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    78cc:	b0 13 f8 54 	calla	#21752		;0x054f8

000078d0 <.LVL185>:
  
  /* Set Fifo threshold */
  sx1212SetFifoThreshold(devp, n);
    78d0:	4d 4a       	mov.b	r10,	r13	;
    78d2:	cc 08       	mova	r8,	r12	;
    78d4:	b0 13 26 70 	calla	#28710		;0x07026

000078d8 <.LVL186>:
}
    78d8:	06 16       	popm.a	#1,	r6	;20-bit words
    78da:	08 16       	popm.a	#1,	r8	;20-bit words
    78dc:	0a 16       	popm.a	#1,	r10	;20-bit words
    78de:	10 01       	reta			;

000078e0 <sx1212StartReceive>:
msg_t sx1212StartReceive(SX1212Driver *devp, size_t n, palcallback_t callback) {
    78e0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000078e2 <.LCFI24>:
    78e2:	08 14       	pushm.a	#1,	r8	;20-bit words

000078e4 <.LCFI25>:
    78e4:	06 14       	pushm.a	#1,	r6	;20-bit words

000078e6 <.LCFI26>:
    78e6:	04 14       	pushm.a	#1,	r4	;20-bit words

000078e8 <.LCFI27>:
    78e8:	ca 0c       	mova	r12,	r10	;
    78ea:	c6 0d       	mova	r13,	r6	;
    78ec:	c8 0e       	mova	r14,	r8	;

000078ee <.LBB92>:
  devp->irq_mappings[0] = irq0;
    78ee:	fc 40 80 ff 	mov.b	#-128,	6(r12)	;#0xff80
    78f2:	06 00 

000078f4 <.Loc.625.1>:
  devp->irq_mappings[1] = irq1;
    78f4:	fc 40 30 00 	mov.b	#48,	7(r12)	;#0x0030
    78f8:	07 00 

000078fa <.Loc.627.1>:
  sx1212SetRegister(devp, IRQParam1, irq0 | irq1);
    78fa:	84 00 ba 6f 	mova	#28602,	r4	;0x06fba
    78fe:	7e 40 b0 ff 	mov.b	#-80,	r14	;#0xffb0

00007902 <.LVL189>:
    7902:	7d 40 0d 00 	mov.b	#13,	r13	;#0x000d

00007906 <.LVL190>:
    7906:	44 13       	calla	r4		;

00007908 <.LBB94>:
  _disable_interrupts();
    7908:	32 c2       	dint			
    790a:	03 43       	nop			

0000790c <.Loc.348.3>:
  asm volatile("nop");
    790c:	03 43       	nop			

0000790e <.LBE94>:
  chSysLock();
    790e:	b0 13 54 45 	calla	#17748		;0x04554

00007912 <.LVL192>:
  sx1212ReceiveI(devp, n, callback);
    7912:	ce 08       	mova	r8,	r14	;
    7914:	cd 06       	mova	r6,	r13	;
    7916:	cc 0a       	mova	r10,	r12	;
    7918:	b0 13 96 78 	calla	#30870		;0x07896

0000791c <.LVL193>:
  chSysUnlock();
    791c:	b0 13 7c 45 	calla	#17788		;0x0457c

00007920 <.LBB96>:
  asm volatile("nop");
    7920:	03 43       	nop			

00007922 <.Loc.356.3>:
  _enable_interrupts();
    7922:	03 43       	nop			
    7924:	32 d2       	eint			
    7926:	03 43       	nop			

00007928 <.LBB98>:
  sx1212SetMode(devp, SX1212Stdby);
    7928:	88 00 0a 70 	mova	#28682,	r8	;0x0700a

0000792c <.LVL196>:
    792c:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    7930:	cc 0a       	mova	r10,	r12	;
    7932:	48 13       	calla	r8		;

00007934 <.LBB100>:
  chThdSleep(time);
    7934:	7c 40 05 00 	mov.b	#5,	r12	;
    7938:	b0 13 5c 4a 	calla	#19036		;0x04a5c

0000793c <.LBE100>:
  sx1212SetMode(devp, SX1212FS);
    793c:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    7940:	cc 0a       	mova	r10,	r12	;
    7942:	48 13       	calla	r8		;

00007944 <.LVL199>:
  suspend_result = irq_block_with_timeout(devp, SX1212_PLL_LOCK, timeout);
    7944:	4d 43       	clr.b	r13		;
    7946:	3c 40 20 b2 	mov	#-19936,r12	;#0xb220
    794a:	b0 13 36 71 	calla	#28982		;0x07136

0000794e <.LVL200>:
    794e:	c6 0c       	mova	r12,	r6	;

00007950 <.LVL201>:
    7950:	60 0c 38 d1 	mova	r12,	&53560	; 0x0d138

00007954 <.Loc.677.1>:
  if (suspend_result != MSG_OK) {
    7954:	9c 00 00 00 	cmpa	#0,	r12	;
    7958:	0a 20       	jnz	$+22     	;abs 0x796e

0000795a <.Loc.682.1>:
  sx1212SetMode(devp, SX1212Rx);
    795a:	7d 40 60 00 	mov.b	#96,	r13	;#0x0060
    795e:	cc 0a       	mova	r10,	r12	;
    7960:	48 13       	calla	r8		;

00007962 <.LVL202>:
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7962:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7966:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    796a:	cc 0a       	mova	r10,	r12	;
    796c:	44 13       	calla	r4		;

0000796e <.L120>:
  BLOCK_RETURN_ERROR(
    796e:	60 06 38 d1 	mova	r6,	&53560	; 0x0d138

00007972 <.Loc.1062.1>:
}
    7972:	cc 06       	mova	r6,	r12	;
    7974:	04 16       	popm.a	#1,	r4	;20-bit words
    7976:	06 16       	popm.a	#1,	r6	;20-bit words
    7978:	08 16       	popm.a	#1,	r8	;20-bit words
    797a:	0a 16       	popm.a	#1,	r10	;20-bit words
    797c:	10 01       	reta			;

0000797e <sx1212FifoRead>:
  
  devp->rx_callback = callback;
  spiStartReceive(devp->config->spip, n, buffer);
}

void sx1212FifoRead(SX1212Driver * devp, size_t n, uint8_t * buffer) {
    797e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007980 <.LCFI32>:
    7980:	b1 00 04 00 	suba	#4,	r1	;

00007984 <.LCFI33>:
    7984:	c4 0c       	mova	r12,	r4	;
    7986:	c5 0e       	mova	r14,	r5	;

00007988 <.LVL210>:
    7988:	ed 0e       	adda	r14,	r13	;

0000798a <.LVL211>:
    798a:	71 0d 00 00 	mova	r13,	0(r1)	;

0000798e <.LBB102>:
  
  for (size_t i = 0; i < n; i++) {
    palClearLine(devp->config->data_ss_b);
    798e:	5a 43       	mov.b	#1,	r10	;r3 As==01

00007990 <.Loc.1093.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    7990:	79 43       	mov.b	#-1,	r9	;r3 As==11

00007992 <.L124>:
  for (size_t i = 0; i < n; i++) {
    7992:	00 18 c1 95 	cmpx.a	r5,	0(r1)	;
    7996:	00 00 
    7998:	04 20       	jnz	$+10     	;abs 0x79a2

0000799a <.LBE102>:
    palSetLine(devp->config->data_ss_b);
  }
  
}
    799a:	a1 00 04 00 	adda	#4,	r1	;
    799e:	64 16       	popm.a	#7,	r10	;20-bit words
    79a0:	10 01       	reta			;

000079a2 <.L125>:
    palClearLine(devp->config->data_ss_b);
    79a2:	08 04       	mova	@r4,	r8	;
    79a4:	3c 08 08 00 	mova	8(r8),	r12	;
    79a8:	c6 0c       	mova	r12,	r6	;
    79aa:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    79ae:	ff 0f 
    79b0:	17 46 02 00 	mov	2(r6),	r7	;
    79b4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    79b6:	40 18 3c 41 	popx.w	r12		;
    79ba:	40 18 3d 41 	popx.w	r13		;
    79be:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    79c2:	0d 12       	push	r13		;
    79c4:	0c 12       	push	r12		;
    79c6:	0c 16       	popm.a	#1,	r12	;20-bit words
    79c8:	40 18 0d 4c 	movx.w	r12,	r13	;
    79cc:	0c 4a       	mov	r10,	r12	;
    79ce:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    79d2:	07 cc       	bic	r12,	r7	;
    79d4:	86 47 02 00 	mov	r7,	2(r6)	;

000079d8 <.Loc.1093.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    79d8:	4d 49       	mov.b	r9,	r13	;
    79da:	0c 08       	mova	@r8,	r12	;
    79dc:	b0 13 84 5a 	calla	#23172		;0x05a84

000079e0 <.LVL215>:
    79e0:	c5 4c 00 00 	mov.b	r12,	0(r5)	;

000079e4 <.Loc.1094.1>:
    palSetLine(devp->config->data_ss_b);
    79e4:	0c 04       	mova	@r4,	r12	;
    79e6:	3c 0c 08 00 	mova	8(r12),	r12	;
    79ea:	c6 0c       	mova	r12,	r6	;
    79ec:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    79f0:	ff 0f 
    79f2:	18 46 02 00 	mov	2(r6),	r8	;
    79f6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    79f8:	40 18 3c 41 	popx.w	r12		;
    79fc:	40 18 3d 41 	popx.w	r13		;
    7a00:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    7a04:	0d 12       	push	r13		;
    7a06:	0c 12       	push	r12		;
    7a08:	0c 16       	popm.a	#1,	r12	;20-bit words
    7a0a:	40 18 0d 4c 	movx.w	r12,	r13	;
    7a0e:	0c 4a       	mov	r10,	r12	;
    7a10:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    7a14:	0c d8       	bis	r8,	r12	;
    7a16:	86 4c 02 00 	mov	r12,	2(r6)	;

00007a1a <.LVL218>:
    7a1a:	a5 00 01 00 	adda	#1,	r5	;

00007a1e <.LVL219>:
    7a1e:	80 00 92 79 	mova	#31122,	r0	;0x07992

00007a22 <sx1212StopReceive>:
 * @post    NSS_CONFIG and NSS_DATA busses are both released (if enabled).
 *          SX1212 is in Sleep mode.
 *          
 * @param[in] devp    pointer to the SX1212 driver
 */
void sx1212StopReceive(SX1212Driver *devp) {
    7a22:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007a24 <.LCFI34>:
    7a24:	ca 0c       	mova	r12,	r10	;

00007a26 <.Loc.1147.1>:
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* Reset for next packet reception */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7a26:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7a2a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7a2e:	b0 13 ba 6f 	calla	#28602		;0x06fba

00007a32 <.LVL221>:
  /* Go to Sleep */
  sx1212SetMode(devp, SX1212Sleep);
    7a32:	4d 43       	clr.b	r13		;
    7a34:	cc 0a       	mova	r10,	r12	;
    7a36:	b0 13 0a 70 	calla	#28682		;0x0700a

00007a3a <.LVL222>:
  
  /* Release SPI bus */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
}
    7a3a:	0a 16       	popm.a	#1,	r10	;20-bit words
    7a3c:	10 01       	reta			;

00007a3e <send_complete_cb>:
  chEvtSignalI(uart_thd, UARTRxBufferReady);
}

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
    7a3e:	b0 13 a6 45 	calla	#17830		;0x045a6

00007a42 <.LVL1>:
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    7a42:	00 18 c2 43 	movx.a	#0,	&0xfd146;r3 As==00
    7a46:	46 d1 

00007a48 <.Loc.56.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    7a48:	40 18 f2 d0 	bisx.b	#3,	&0xfd144;
    7a4c:	03 00 44 d1 

00007a50 <.LBB10>:
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
    7a50:	b0 13 54 46 	calla	#18004		;0x04654

00007a54 <.LVL3>:

  return chSemGetCounterI(&mbp->fullsem);
    7a54:	c0 18 1c 42 	movx.w	&0x108d8,r12	;
    7a58:	d8 08 

00007a5a <.LBE10>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    7a5a:	4d 43       	clr.b	r13		;
    7a5c:	0d 9c       	cmp	r12,	r13	;
    7a5e:	06 34       	jge	$+14     	;abs 0x7a6c

00007a60 <.Loc.59.1>:
    events |= UARTBufferPosted;
    7a60:	40 18 a2 d3 	bisx.w	#2,	&0xfd140;r3 As==10
    7a64:	40 d1 
    7a66:	40 18 82 dd 	bisx.w	r13,	&0xfd142;
    7a6a:	42 d1 

00007a6c <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    7a6c:	2c 00 3c d1 	mova	&53564,	r12	;0x0d13c
    7a70:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    7a74:	04 24       	jz	$+10     	;abs 0x7a7e

00007a76 <.Loc.63.1>:
    chSchReadyI(uart_thd, MSG_RESET);
    7a76:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    7a7a:	b0 13 d6 48 	calla	#18646		;0x048d6

00007a7e <.L3>:
  }
  chSysUnlockFromISR();
    7a7e:	b0 13 d0 45 	calla	#17872		;0x045d0

00007a82 <.LVL6>:
}
    7a82:	10 01       	reta			;

00007a84 <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    7a84:	01 18 d2 92 	cmpx.a	&0x0d13c,&0x11320;
    7a88:	3c d1 20 13 
    7a8c:	04 20       	jnz	$+10     	;abs 0x7a96

00007a8e <.Loc.19.1>:
    7a8e:	8c 01 2c 06 	mova	#67116,	r12	;0x1062c
    7a92:	b0 13 dc 47 	calla	#18396		;0x047dc

00007a96 <.L7>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    7a96:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7a98:	4e 43       	clr.b	r14		;
    7a9a:	2c 00 3c d1 	mova	&53564,	r12	;0x0d13c
    7a9e:	b0 13 5c 4b 	calla	#19292		;0x04b5c

00007aa2 <.LVL10>:
}
    7aa2:	10 01       	reta			;

00007aa4 <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    7aa4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007aa6 <.LCFI0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    7aa6:	cd 0c       	mova	r12,	r13	;
    7aa8:	8c 01 c8 08 	mova	#67784,	r12	;0x108c8

00007aac <.LVL12>:
    7aac:	b0 13 f0 4c 	calla	#19696		;0x04cf0

00007ab0 <.LVL13>:
    7ab0:	ca 0c       	mova	r12,	r10	;

00007ab2 <.Loc.26.1>:
  if (MSG_OK == msg) {
    7ab2:	9c 00 00 00 	cmpa	#0,	r12	;
    7ab6:	06 20       	jnz	$+14     	;abs 0x7ac4

00007ab8 <.Loc.27.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    7ab8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7aba:	4e 43       	clr.b	r14		;
    7abc:	2c 00 3c d1 	mova	&53564,	r12	;0x0d13c
    7ac0:	b0 13 90 4b 	calla	#19344		;0x04b90

00007ac4 <.L8>:
}
    7ac4:	cc 0a       	mova	r10,	r12	;
    7ac6:	0a 16       	popm.a	#1,	r10	;20-bit words
    7ac8:	10 01       	reta			;

00007aca <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    7aca:	1a 14       	pushm.a	#2,	r10	;20-bit words

00007acc <.LCFI1>:
    7acc:	ca 0c       	mova	r12,	r10	;
    7ace:	09 4d       	mov	r13,	r9	;

00007ad0 <.LBB16>:
  _disable_interrupts();
    7ad0:	32 c2       	dint			
    7ad2:	03 43       	nop			

00007ad4 <.Loc.348.3>:
  asm volatile("nop");
    7ad4:	03 43       	nop			

00007ad6 <.LBE16>:
  chSysLock();
    7ad6:	b0 13 54 45 	calla	#17748		;0x04554

00007ada <.LVL17>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    7ada:	0e 49       	mov	r9,	r14	;
    7adc:	cd 0a       	mova	r10,	r13	;
    7ade:	8c 01 c8 08 	mova	#67784,	r12	;0x108c8
    7ae2:	b0 13 54 4c 	calla	#19540		;0x04c54

00007ae6 <.LVL18>:
    7ae6:	ca 0c       	mova	r12,	r10	;

00007ae8 <.LVL19>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    7ae8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7aea:	4e 43       	clr.b	r14		;
    7aec:	2c 00 3c d1 	mova	&53564,	r12	;0x0d13c
    7af0:	b0 13 90 4b 	calla	#19344		;0x04b90

00007af4 <.LVL20>:
  chSysUnlock();
    7af4:	b0 13 7c 45 	calla	#17788		;0x0457c

00007af8 <.LBB18>:
  asm volatile("nop");
    7af8:	03 43       	nop			

00007afa <.Loc.356.3>:
  _enable_interrupts();
    7afa:	03 43       	nop			
    7afc:	32 d2       	eint			
    7afe:	03 43       	nop			

00007b00 <.LBE18>:
}
    7b00:	cc 0a       	mova	r10,	r12	;
    7b02:	19 16       	popm.a	#2,	r10	;20-bit words
    7b04:	10 01       	reta			;

00007b06 <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 256);
THD_FUNCTION(UARTThd, arg) {
    7b06:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007b08 <.LCFI2>:
    7b08:	06 14       	pushm.a	#1,	r6	;20-bit words

00007b0a <.LCFI3>:
    7b0a:	04 14       	pushm.a	#1,	r4	;20-bit words

00007b0c <.LCFI4>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    7b0c:	80 18 d2 42 	movx.a	&0x11320,&0xfd13c;
    7b10:	20 13 3c d1 

00007b14 <.Loc.98.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    7b14:	40 18 f2 40 	movx.b	#7,	&0xfd144;
    7b18:	07 00 44 d1 

00007b1c <.LBB36>:
  _disable_interrupts();
    7b1c:	32 c2       	dint			
    7b1e:	03 43       	nop			

00007b20 <.Loc.348.3>:
  asm volatile("nop");
    7b20:	03 43       	nop			

00007b22 <.LBE36>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    7b22:	8a 00 54 45 	mova	#17748,	r10	;0x04554
    7b26:	4a 13       	calla	r10		;

00007b28 <.LVL24>:
    7b28:	c9 0a       	mova	r10,	r9	;

00007b2a <.Loc.102.1>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    7b2a:	00 18 c2 93 	cmpx.a	#0,	&0xfd146;r3 As==00
    7b2e:	46 d1 
    7b30:	89 24       	jz	$+276    	;abs 0x7c44

00007b32 <.L15>:
    events |= UARTBufferPosted;
    7b32:	40 18 a2 d3 	bisx.w	#2,	&0xfd140;r3 As==10
    7b36:	40 d1 
    7b38:	40 18 82 d3 	bisx.w	#0,	&0xfd142;r3 As==00
    7b3c:	42 d1 

00007b3e <.L14>:
  }
  chSysUnlock();
    7b3e:	8a 00 7c 45 	mova	#17788,	r10	;0x0457c
    7b42:	4a 13       	calla	r10		;

00007b44 <.LBB38>:
  asm volatile("nop");
    7b44:	03 43       	nop			

00007b46 <.Loc.356.3>:
  _enable_interrupts();
    7b46:	03 43       	nop			
    7b48:	32 d2       	eint			
    7b4a:	03 43       	nop			

00007b4c <.LBE38>:
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    7b4c:	40 18 92 d3 	bisx.w	#1,	&0xfd140;r3 As==01
    7b50:	40 d1 
    7b52:	40 18 82 d3 	bisx.w	#0,	&0xfd142;r3 As==00
    7b56:	42 d1 

00007b58 <.Loc.111.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    7b58:	8d 01 56 06 	mova	#67158,	r13	;0x10656
    7b5c:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    7b60:	b0 13 58 50 	calla	#20568		;0x05058

00007b64 <.LVL26>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    7b64:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    7b68:	b0 13 cc ab 	calla	#43980		;0x0abcc

00007b6c <.LVL27>:
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    7b6c:	28 01 4a 07 	mova	&67402,	r8	;0x1074a
    7b70:	84 01 c6 08 	mova	#67782,	r4	;0x108c6

00007b74 <.Loc.128.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    7b74:	86 01 ae 08 	mova	#67758,	r6	;0x108ae

00007b78 <.L16>:
    if (events & UARTConfigUpdated) {
    7b78:	40 18 d2 b3 	bitx.b	#1,	&0xfd140;r3 As==01
    7b7c:	40 d1 
    7b7e:	3f 24       	jz	$+128    	;abs 0x7bfe

00007b80 <.LBB40>:
  _disable_interrupts();
    7b80:	32 c2       	dint			
    7b82:	03 43       	nop			

00007b84 <.Loc.348.3>:
  asm volatile("nop");
    7b84:	03 43       	nop			

00007b86 <.LBE40>:
      chSysLock();
    7b86:	49 13       	calla	r9		;

00007b88 <.LVL28>:
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    7b88:	5c 48 26 00 	mov.b	38(r8),	r12	;0x00026
    7b8c:	4f 4c       	mov.b	r12,	r15	;
    7b8e:	7f f0 03 00 	and.b	#3,	r15	;
    7b92:	6d 44       	mov.b	@r4,	r13	;
    7b94:	7d f0 ec ff 	and.b	#-20,	r13	;#0xffec

00007b98 <.Loc.124.1>:
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    7b98:	0e 4c       	mov	r12,	r14	;
    7b9a:	5e 07       	rrum	#2,	r14	;
    7b9c:	5e f3       	and.b	#1,	r14	;r3 As==01
    7b9e:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    7ba2:	4d df       	bis.b	r15,	r13	;
    7ba4:	4d de       	bis.b	r14,	r13	;

00007ba6 <.Loc.126.1>:
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    7ba6:	5c 0b       	rrum	#3,	r12	;
    7ba8:	5c f3       	and.b	#1,	r12	;r3 As==01
    7baa:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    7bae:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    7bb2:	4d dc       	bis.b	r12,	r13	;
    7bb4:	c4 4d 00 00 	mov.b	r13,	0(r4)	;

00007bb8 <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    7bb8:	5d 48 23 00 	mov.b	35(r8),	r13	;0x00023
    7bbc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    7bc0:	5c 48 25 00 	mov.b	37(r8),	r12	;0x00025
    7bc4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7bc8:	5e 48 24 00 	mov.b	36(r8),	r14	;0x00024
    7bcc:	0c de       	bis	r14,	r12	;

00007bce <.Loc.128.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    7bce:	5e 48 22 00 	mov.b	34(r8),	r14	;0x00022
    7bd2:	0e dd       	bis	r13,	r14	;
    7bd4:	86 4e 14 00 	mov	r14,	20(r6)	; 0x0014
    7bd8:	86 4c 16 00 	mov	r12,	22(r6)	; 0x0016

00007bdc <.Loc.133.1>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
      
      chSysUnlock();
    7bdc:	4a 13       	calla	r10		;

00007bde <.LBB42>:
  asm volatile("nop");
    7bde:	03 43       	nop			

00007be0 <.Loc.356.3>:
  _enable_interrupts();
    7be0:	03 43       	nop			
    7be2:	32 d2       	eint			
    7be4:	03 43       	nop			

00007be6 <.LBE42>:
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    7be6:	8d 01 ae 08 	mova	#67758,	r13	;0x108ae
    7bea:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    7bee:	b0 13 30 52 	calla	#21040		;0x05230

00007bf2 <.LVL30>:
      events &= ~UARTConfigUpdated;
    7bf2:	40 18 92 c3 	bicx.w	#1,	&0xfd140;r3 As==01
    7bf6:	40 d1 
    7bf8:	40 18 82 c3 	bicx.w	#0,	&0xfd142;r3 As==00
    7bfc:	42 d1 

00007bfe <.L17>:
    }
    if (events & UARTBufferPosted) {
    7bfe:	40 18 e2 b3 	bitx.b	#2,	&0xfd140;r3 As==10
    7c02:	40 d1 
    7c04:	3e 24       	jz	$+126    	;abs 0x7c82

00007c06 <.Loc.139.1>:
      if (NULL == tx_active_buffer) {
    7c06:	00 18 c2 93 	cmpx.a	#0,	&0xfd146;r3 As==00
    7c0a:	46 d1 
    7c0c:	2a 20       	jnz	$+86     	;abs 0x7c62

00007c0e <.LBB44>:
  _disable_interrupts();
    7c0e:	32 c2       	dint			
    7c10:	03 43       	nop			

00007c12 <.Loc.348.3>:
  asm volatile("nop");
    7c12:	03 43       	nop			

00007c14 <.LBE44>:
        /* Get the buffer */
        chSysLock();
    7c14:	49 13       	calla	r9		;

00007c16 <.LVL31>:
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    7c16:	3e 43       	mov	#-1,	r14	;r3 As==11
    7c18:	8d 00 46 d1 	mova	#53574,	r13	;0x0d146
    7c1c:	8c 01 c8 08 	mova	#67784,	r12	;0x108c8
    7c20:	b0 13 44 4d 	calla	#19780		;0x04d44

00007c24 <.LVL32>:
        if (result != MSG_OK) {
    7c24:	9c 00 00 00 	cmpa	#0,	r12	;
    7c28:	17 24       	jz	$+48     	;abs 0x7c58

00007c2a <.Loc.144.1>:
          events &= ~UARTBufferPosted;
    7c2a:	40 18 a2 c3 	bicx.w	#2,	&0xfd140;r3 As==10
    7c2e:	40 d1 
    7c30:	40 18 82 c3 	bicx.w	#0,	&0xfd142;r3 As==00
    7c34:	42 d1 

00007c36 <.Loc.145.1>:
          chSysUnlock();
    7c36:	4a 13       	calla	r10		;

00007c38 <.LBB46>:
  asm volatile("nop");
    7c38:	03 43       	nop			

00007c3a <.Loc.356.3>:
  _enable_interrupts();
    7c3a:	03 43       	nop			
    7c3c:	32 d2       	eint			
    7c3e:	03 43       	nop			

00007c40 <.LBE46>:
          /* Skip to the next loop */
          continue;
    7c40:	80 00 78 7b 	mova	#31608,	r0	;0x07b78

00007c44 <.L13>:
  chDbgCheckClassI();
    7c44:	b0 13 54 46 	calla	#18004		;0x04654

00007c48 <.LVL35>:
  return chSemGetCounterI(&mbp->fullsem);
    7c48:	c0 18 1c 42 	movx.w	&0x108d8,r12	;
    7c4c:	d8 08 

00007c4e <.LBE48>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    7c4e:	4d 43       	clr.b	r13		;
    7c50:	0d 9c       	cmp	r12,	r13	;
    7c52:	6f 3b       	jl	$-288    	;abs 0x7b32
    7c54:	80 00 3e 7b 	mova	#31550,	r0	;0x07b3e

00007c58 <.L22>:
        }
        chSysUnlock();
    7c58:	4a 13       	calla	r10		;

00007c5a <.LBB50>:
  asm volatile("nop");
    7c5a:	03 43       	nop			

00007c5c <.Loc.356.3>:
  _enable_interrupts();
    7c5c:	03 43       	nop			
    7c5e:	32 d2       	eint			
    7c60:	03 43       	nop			

00007c62 <.L21>:
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    7c62:	2d 00 46 d1 	mova	&53574,	r13	;0x0d146
    7c66:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    7c6a:	b0 13 18 ab 	calla	#43800		;0x0ab18

00007c6e <.LVL39>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    7c6e:	c0 1f f2 f0 	andx.b	#-4,	&0xfd144;0xffffc
    7c72:	fc ff 44 d1 

00007c76 <.Loc.158.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    7c76:	40 18 a2 c3 	bicx.w	#2,	&0xfd140;r3 As==10
    7c7a:	40 d1 
    7c7c:	40 18 82 c3 	bicx.w	#0,	&0xfd142;r3 As==00
    7c80:	42 d1 

00007c82 <.L19>:
    }
    if (events & UARTRxBufferReady) {
    7c82:	40 18 e2 b2 	bitx.b	#4,	&0xfd140;r2 As==10
    7c86:	40 d1 
    7c88:	08 24       	jz	$+18     	;abs 0x7c9a

00007c8a <.Loc.162.1>:
      
      elyUARTDLLRxHandleBuffer();
    7c8a:	b0 13 d6 ab 	calla	#43990		;0x0abd6

00007c8e <.LVL40>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    7c8e:	40 18 a2 c2 	bicx.w	#4,	&0xfd140;r2 As==10
    7c92:	40 d1 
    7c94:	40 18 82 c3 	bicx.w	#0,	&0xfd142;r3 As==00
    7c98:	42 d1 

00007c9a <.L24>:
    }
    /* Get next events */
    events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    7c9a:	4e 43       	clr.b	r14		;
    7c9c:	5c 42 44 d1 	mov.b	&0xd144,r12	;0xd144
    7ca0:	0d 43       	clr	r13		;
    7ca2:	b0 13 da 4b 	calla	#19418		;0x04bda

00007ca6 <.LVL41>:
    7ca6:	40 18 82 4c 	movx.w	r12,	&0xfd140;
    7caa:	40 d1 
    7cac:	40 18 82 4d 	movx.w	r13,	&0xfd142;
    7cb0:	42 d1 
    7cb2:	80 00 78 7b 	mova	#31608,	r0	;0x07b78

00007cb6 <elyMainMBPost>:
static PERSIST msg_t main_buffer[elyNLMaxSlots];
static PERSIST MAILBOX_DECL(main_mbox, main_buffer, elyNLMaxSlots);
static PERSIST uint8_t * active_buffer = NULL;

msg_t elyMainMBPost(uint8_t * buffer, systime_t timeout) {
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    7cb6:	0e 4d       	mov	r13,	r14	;
    7cb8:	cd 0c       	mova	r12,	r13	;

00007cba <.LVL1>:
    7cba:	8c 01 dc 08 	mova	#67804,	r12	;0x108dc

00007cbe <.LVL2>:
    7cbe:	b0 13 b0 4c 	calla	#19632		;0x04cb0

00007cc2 <.LVL3>:
}
    7cc2:	10 01       	reta			;

00007cc4 <MainThd>:
msg_t elyMainMBPostI(uint8_t * buffer) {
  return chMBPostI(&main_mbox, (msg_t)(buffer));
}

THD_WORKING_AREA(waMainThd, 256);
THD_FUNCTION(MainThd, arg) {
    7cc4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007cc6 <.LCFI1>:
    7cc6:	08 14       	pushm.a	#1,	r8	;20-bit words

00007cc8 <.LCFI2>:
    7cc8:	06 14       	pushm.a	#1,	r6	;20-bit words

00007cca <.LCFI3>:
    7cca:	b1 00 02 00 	suba	#2,	r1	;

00007cce <.LCFI4>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    7cce:	88 00 a2 4d 	mova	#19874,	r8	;0x04da2

00007cd2 <.Loc.32.1>:
    }
    
    /* Run Network Layer validation checks */
    /* TODO figure out a better way to deal with this problem, here and below */
    if (!elyNLValidate(active_buffer)) {
    7cd2:	86 00 42 c2 	mova	#49730,	r6	;0x0c242

00007cd6 <.L5>:
    if (NULL == active_buffer) {
    7cd6:	00 18 c2 93 	cmpx.a	#0,	&0xfd16a;r3 As==00
    7cda:	6a d1 
    7cdc:	06 20       	jnz	$+14     	;abs 0x7cea

00007cde <.Loc.27.1>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    7cde:	4e 43       	clr.b	r14		;
    7ce0:	8d 00 6a d1 	mova	#53610,	r13	;0x0d16a
    7ce4:	8c 01 dc 08 	mova	#67804,	r12	;0x108dc
    7ce8:	48 13       	calla	r8		;

00007cea <.L6>:
    if (!elyNLValidate(active_buffer)) {
    7cea:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7cee:	46 13       	calla	r6		;

00007cf0 <.LVL13>:
    7cf0:	2e 00 6a d1 	mova	&53610,	r14	;0x0d16a
    7cf4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7cf6:	05 20       	jnz	$+12     	;abs 0x7d02

00007cf8 <.Loc.33.1>:
      elyNLFreeBuffer(active_buffer);
    7cf8:	cc 0e       	mova	r14,	r12	;

00007cfa <.L26>:
            }
            elyCmdDispatch(hdr, cmd_buffer);
          }
          else {
            /* Invalid command - free the buffer */
            elyNLFreeBuffer(active_buffer);
    7cfa:	b0 13 42 c1 	calla	#49474		;0x0c142

00007cfe <.LBE2>:
          }
        }
        break;
    7cfe:	80 00 8a 7d 	mova	#32138,	r0	;0x07d8a

00007d02 <.L7>:
    switch(elyNLGetDest(active_buffer)) {
    7d02:	cc 0e       	mova	r14,	r12	;
    7d04:	b0 13 72 c1 	calla	#49522		;0x0c172

00007d08 <.LVL15>:
    7d08:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7d0a:	18 24       	jz	$+50     	;abs 0x7d3c
    7d0c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7d0e:	08 24       	jz	$+18     	;abs 0x7d20
    7d10:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    7d12:	20 24       	jz	$+66     	;abs 0x7d54

00007d14 <.Loc.78.1>:
      default:
        chDbgAssert(false, "shouldn't happen");
    7d14:	8c 01 5e 06 	mova	#67166,	r12	;0x1065e
    7d18:	b0 13 dc 47 	calla	#18396		;0x047dc

00007d1c <.LVL16>:
        /* ACTUALLY can't happen */
        break;
    7d1c:	80 00 8a 7d 	mova	#32138,	r0	;0x07d8a

00007d20 <.L11>:
        if (MSG_OK != elyUARTPost(active_buffer, TIME_IMMEDIATE)) {
    7d20:	3d 43       	mov	#-1,	r13	;r3 As==11
    7d22:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d26:	b0 13 ca 7a 	calla	#31434		;0x07aca

00007d2a <.LVL17>:
    7d2a:	9c 00 00 00 	cmpa	#0,	r12	;
    7d2e:	2d 24       	jz	$+92     	;abs 0x7d8a

00007d30 <.Loc.44.1>:
          elyNLFreeBuffer(active_buffer);
    7d30:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d34:	b0 13 42 c1 	calla	#49474		;0x0c142

00007d38 <.LVL18>:
          continue;
    7d38:	80 00 d6 7c 	mova	#31958,	r0	;0x07cd6

00007d3c <.L10>:
        if (MSG_OK != elyRFPost(active_buffer, TIME_IMMEDIATE)) {
    7d3c:	3d 43       	mov	#-1,	r13	;r3 As==11
    7d3e:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d42:	b0 13 1a b0 	calla	#45082		;0x0b01a

00007d46 <.LVL19>:
    7d46:	9c 00 00 00 	cmpa	#0,	r12	;
    7d4a:	1f 24       	jz	$+64     	;abs 0x7d8a

00007d4c <.L16>:
            elyNLFreeBuffer(active_buffer);
    7d4c:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d50:	80 00 fa 7c 	mova	#31994,	r0	;0x07cfa

00007d54 <.L12>:
          uint8_t * cmd_buffer = elyNLExtract(active_buffer);
    7d54:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d58:	b0 13 b6 c2 	calla	#49846		;0x0c2b6

00007d5c <.LVL20>:
    7d5c:	ca 0c       	mova	r12,	r10	;

00007d5e <.LVL21>:
          hdr = elyCmdParse(cmd_buffer);
    7d5e:	cd 0c       	mova	r12,	r13	;
    7d60:	cc 01       	mova	r1,	r12	;
    7d62:	b0 13 9a 7f 	calla	#32666		;0x07f9a

00007d66 <.LVL22>:
          if (elyCmdValidate(hdr, cmd_buffer)) {
    7d66:	cd 0a       	mova	r10,	r13	;
    7d68:	cc 01       	mova	r1,	r12	;
    7d6a:	b0 13 c6 7f 	calla	#32710		;0x07fc6

00007d6e <.LVL23>:
    7d6e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7d70:	ed 27       	jz	$-36     	;abs 0x7d4c

00007d72 <.Loc.63.1>:
            if (hdr.reply) {
    7d72:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    7d76:	00 00 
    7d78:	04 24       	jz	$+10     	;abs 0x7d82

00007d7a <.Loc.67.1>:
              elyNLSetDest(active_buffer);
    7d7a:	2c 00 6a d1 	mova	&53610,	r12	;0x0d16a
    7d7e:	b0 13 d4 c1 	calla	#49620		;0x0c1d4

00007d82 <.L17>:
            elyCmdDispatch(hdr, cmd_buffer);
    7d82:	cd 0a       	mova	r10,	r13	;
    7d84:	cc 01       	mova	r1,	r12	;
    7d86:	b0 13 44 82 	calla	#33348		;0x08244

00007d8a <.L14>:
    }
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    7d8a:	00 18 c2 43 	movx.a	#0,	&0xfd16a;r3 As==00
    7d8e:	6a d1 
    7d90:	80 00 d6 7c 	mova	#31958,	r0	;0x07cd6

00007d94 <port_lock>:
  _disable_interrupts();
    7d94:	32 c2       	dint			
    7d96:	03 43       	nop			

00007d98 <.Loc.348.1>:
  asm volatile("nop");
    7d98:	03 43       	nop			

00007d9a <.Loc.349.1>:
}
    7d9a:	10 01       	reta			;

00007d9c <port_unlock>:
  asm volatile("nop");
    7d9c:	03 43       	nop			

00007d9e <.Loc.356.1>:
  _enable_interrupts();
    7d9e:	03 43       	nop			
    7da0:	32 d2       	eint			
    7da2:	03 43       	nop			

00007da4 <.Loc.357.1>:
}
    7da4:	10 01       	reta			;

00007da6 <reset>:
  }
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLPack(buffer));
    7da6:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00007daa <.LVL1>:
    7daa:	b0 13 42 c1 	calla	#49474		;0x0c142

00007dae <.LVL2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7dae:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    7db2:	48 a5 20 01 

00007db6 <.Loc.42.2>:
}
    7db6:	10 01       	reta			;

00007db8 <gen_success>:
static inline void gen_success(uint8_t *buffer, uint8_t crc) {
    7db8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007dbc <.Loc.18.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7dbc:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    7dc0:	00 00 

00007dc2 <.Loc.19.2>:
  buffer[1] = (crc ? 3 : 1);
    7dc2:	0d 93       	cmp	#0,	r13	;r3 As==00
    7dc4:	14 20       	jnz	$+42     	;abs 0x7dee
    7dc6:	5e 43       	mov.b	#1,	r14	;r3 As==01

00007dc8 <.L5>:
    7dc8:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00007dcc <.Loc.20.2>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7dcc:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    7dd0:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7dd4:	02 00 

00007dd6 <.Loc.21.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7dd6:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7dda:	03 00 

00007ddc <.Loc.22.2>:
  buffer[4] = 1;
    7ddc:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00007de0 <.Loc.23.2>:
  if (crc) {
    7de0:	0d 93       	cmp	#0,	r13	;r3 As==00
    7de2:	04 24       	jz	$+10     	;abs 0x7dec

00007de4 <.Loc.24.2>:
    crcGenX25(buffer, 7);
    7de4:	7d 40 07 00 	mov.b	#7,	r13	;

00007de8 <.LVL4>:
    7de8:	b0 13 64 ae 	calla	#44644		;0x0ae64

00007dec <.L4>:
}
    7dec:	10 01       	reta			;

00007dee <.L7>:
  buffer[1] = (crc ? 3 : 1);
    7dee:	7e 40 03 00 	mov.b	#3,	r14	;
    7df2:	80 00 c8 7d 	mova	#32200,	r0	;0x07dc8

00007df6 <gen_failure>:
static inline void gen_failure(uint8_t *buffer, uint8_t crc) {
    7df6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007dfa <.Loc.29.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7dfa:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    7dfe:	00 00 

00007e00 <.Loc.30.2>:
  buffer[1] = (crc ? 2 : 0);
    7e00:	0d 93       	cmp	#0,	r13	;r3 As==00
    7e02:	12 20       	jnz	$+38     	;abs 0x7e28
    7e04:	0e 4d       	mov	r13,	r14	;

00007e06 <.L12>:
    7e06:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00007e0a <.Loc.31.2>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7e0a:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    7e0e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7e12:	02 00 

00007e14 <.Loc.32.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7e14:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7e18:	03 00 

00007e1a <.Loc.33.2>:
  if (crc) {
    7e1a:	0d 93       	cmp	#0,	r13	;r3 As==00
    7e1c:	04 24       	jz	$+10     	;abs 0x7e26

00007e1e <.Loc.34.2>:
    crcGenX25(buffer, 6);
    7e1e:	7d 40 06 00 	mov.b	#6,	r13	;

00007e22 <.LVL8>:
    7e22:	b0 13 64 ae 	calla	#44644		;0x0ae64

00007e26 <.L11>:
}
    7e26:	10 01       	reta			;

00007e28 <.L14>:
  buffer[1] = (crc ? 2 : 0);
    7e28:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7e2a:	80 00 06 7e 	mova	#32262,	r0	;0x07e06

00007e2e <store_telem>:
  elyNLFreeBufferI(buffer);
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e2e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007e30 <.LCFI0>:
    7e30:	b1 00 02 00 	suba	#2,	r1	;

00007e34 <.LCFI1>:
    7e34:	c8 0c       	mova	r12,	r8	;
    7e36:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00007e3a <.LVL12>:
    7e3a:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00007e3e <.Loc.1645.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7e3e:	6c 41       	mov.b	@r1,	r12	;

00007e40 <.LVL14>:
    7e40:	4d 4c       	mov.b	r12,	r13	;

00007e42 <.LVL15>:
    7e42:	6d f3       	and.b	#2,	r13	;r3 As==10
    7e44:	47 4d       	mov.b	r13,	r7	;
    7e46:	07 93       	cmp	#0,	r7	;r3 As==00
    7e48:	1d 20       	jnz	$+60     	;abs 0x7e84
    7e4a:	69 43       	mov.b	#2,	r9	;r3 As==10

00007e4c <.L19>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7e4c:	1c b3       	bit	#1,	r12	;r3 As==01
    7e4e:	1d 20       	jnz	$+60     	;abs 0x7e8a

00007e50 <.Loc.1646.2>:
    7e50:	4c 43       	clr.b	r12		;

00007e52 <.L20>:
    7e52:	4a 8d       	sub.b	r13,	r10	;

00007e54 <.LVL17>:
    7e54:	4a 8c       	sub.b	r12,	r10	;

00007e56 <.LVL18>:
  
  chSysLock();
    7e56:	b0 13 94 7d 	calla	#32148		;0x07d94

00007e5a <.LVL19>:
    7e5a:	b0 13 54 45 	calla	#17748		;0x04554

00007e5e <.LVL20>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    7e5e:	40 18 0c 49 	movx.w	r9,	r12	;
    7e62:	ec 08       	adda	r8,	r12	;
    7e64:	40 18 0d 4a 	movx.w	r10,	r13	;
    7e68:	07 93       	cmp	#0,	r7	;r3 As==00
    7e6a:	12 20       	jnz	$+38     	;abs 0x7e90

00007e6c <.Loc.1649.2>:
    7e6c:	8e 00 98 7e 	mova	#32408,	r14	;0x07e98

00007e70 <.L21>:
    7e70:	b0 13 ee c5 	calla	#50670		;0x0c5ee

00007e74 <.LVL21>:
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
    7e74:	b0 13 7c 45 	calla	#17788		;0x0457c

00007e78 <.LVL22>:
    7e78:	b0 13 9c 7d 	calla	#32156		;0x07d9c

00007e7c <.LVL23>:
  
  /* Reply is posted from callback if needed */
}
    7e7c:	a1 00 02 00 	adda	#2,	r1	;
    7e80:	37 16       	popm.a	#4,	r10	;20-bit words
    7e82:	10 01       	reta			;

00007e84 <.L22>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7e84:	69 42       	mov.b	#4,	r9	;r2 As==10
    7e86:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007e8a <.L23>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7e8a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7e8c:	80 00 52 7e 	mova	#32338,	r0	;0x07e52

00007e90 <.L24>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    7e90:	8e 00 d0 82 	mova	#33488,	r14	;0x082d0
    7e94:	80 00 70 7e 	mova	#32368,	r0	;0x07e70

00007e98 <store_telem_noreply_cb>:
static void store_telem_noreply_cb(uint8_t * buffer) {
    7e98:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007e9a <.LCFI2>:
    7e9a:	ca 0c       	mova	r12,	r10	;

00007e9c <.LVL28>:
  chSysLockFromISR();
    7e9c:	b0 13 a6 45 	calla	#17830		;0x045a6

00007ea0 <.LVL29>:
  elyNLFreeBufferI(buffer);
    7ea0:	cc 0a       	mova	r10,	r12	;
    7ea2:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

00007ea6 <.LVL30>:
    7ea6:	b0 13 5c c1 	calla	#49500		;0x0c15c

00007eaa <.LVL31>:
  chSysUnlockFromISR();
    7eaa:	b0 13 d0 45 	calla	#17872		;0x045d0

00007eae <.LVL32>:
}
    7eae:	0a 16       	popm.a	#1,	r10	;20-bit words
    7eb0:	10 01       	reta			;

00007eb2 <upload_fw_noreply_cb>:
static void upload_fw_noreply_cb(uint8_t * buffer) {
    7eb2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007eb4 <.LCFI3>:
    7eb4:	ca 0c       	mova	r12,	r10	;

00007eb6 <.LVL34>:
  chSysLockFromISR();
    7eb6:	b0 13 a6 45 	calla	#17830		;0x045a6

00007eba <.LVL35>:
  elyNLFreeBufferI(elyNLPack(buffer));
    7eba:	cc 0a       	mova	r10,	r12	;
    7ebc:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

00007ec0 <.LVL36>:
    7ec0:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00007ec4 <.LVL37>:
    7ec4:	b0 13 5c c1 	calla	#49500		;0x0c15c

00007ec8 <.LVL38>:
  chSysUnlockFromISR();
    7ec8:	b0 13 d0 45 	calla	#17872		;0x045d0

00007ecc <.LVL39>:
}
    7ecc:	0a 16       	popm.a	#1,	r10	;20-bit words
    7ece:	10 01       	reta			;

00007ed0 <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7ed0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007ed2 <.LCFI4>:
    7ed2:	b1 00 06 00 	suba	#6,	r1	;

00007ed6 <.LCFI5>:
    7ed6:	ce 0c       	mova	r12,	r14	;

00007ed8 <.Loc.1476.2>:
    7ed8:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7edc:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7ee0:	01 00 

00007ee2 <.Loc.1477.2>:
  if (hdr.reply) {
    7ee2:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    7ee6:	00 00 
    7ee8:	39 24       	jz	$+116    	;abs 0x7f5c

00007eea <.LBB36>:
    stored_buff = buffer; /* store for freeing */
    7eea:	60 0c 96 d1 	mova	r12,	&53654	; 0x0d196

00007eee <.Loc.1480.2>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    7eee:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00007ef2 <.LVL42>:
    7ef2:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7ef6:	5e 4e 05 00 	mov.b	5(r14),	r14	;

00007efa <.LVL43>:
    7efa:	0e dc       	bis	r12,	r14	;
    7efc:	40 18 82 4e 	movx.w	r14,	&0xfd19a;
    7f00:	9a d1 

00007f02 <.Loc.1483.2>:
    volatile uint8_t * crc_addr = crcStart();
    7f02:	b0 13 42 af 	calla	#44866		;0x0af42

00007f06 <.LVL44>:
    7f06:	ca 0c       	mova	r12,	r10	;

00007f08 <.LVL45>:
    elyFramGetRequest(&req);
    7f08:	cc 01       	mova	r1,	r12	;
    7f0a:	ac 00 02 00 	adda	#2,	r12	;
    7f0e:	b0 13 be bd 	calla	#48574		;0x0bdbe

00007f12 <.LVL46>:
    req->address = FRAM_FW_BASE; 
    7f12:	3c 01 02 00 	mova	2(r1),	r12	;
    7f16:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    7f1a:	00 00 
    7f1c:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

00007f20 <.Loc.1494.2>:
    req->special = 1; /* read to a constant register address */
    7f20:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    7f24:	04 00 

00007f26 <.Loc.1495.2>:
    req->size = FRAM_FW_SIZE;
    7f26:	1d 4c 04 00 	mov	4(r12),	r13	;
    7f2a:	7d f0 03 00 	and.b	#3,	r13	;
    7f2e:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    7f32:	8c 4d 04 00 	mov	r13,	4(r12)	;
    7f36:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    7f3a:	7d d0 03 00 	bis.b	#3,	r13	;
    7f3e:	6d c2       	bic.b	#4,	r13	;r2 As==10
    7f40:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

00007f44 <.Loc.1497.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    7f44:	7c 0a 08 00 	mova	r10,	8(r12)	;

00007f48 <.Loc.1498.2>:
    req->callback = verify_fw_cb;
    7f48:	00 18 fc 40 	movx.a	#33528,	12(r12)	;0x082f8, 0x0000c
    7f4c:	f8 82 0c 00 

00007f50 <.Loc.1504.2>:
    elyFramPostRequest(req);
    7f50:	b0 13 d8 bd 	calla	#48600		;0x0bdd8

00007f54 <.L27>:
}
    7f54:	a1 00 06 00 	adda	#6,	r1	;
    7f58:	0a 16       	popm.a	#1,	r10	;20-bit words
    7f5a:	10 01       	reta			;

00007f5c <.L28>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7f5c:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00007f60 <.LVL49>:
    7f60:	b0 13 42 c1 	calla	#49474		;0x0c142

00007f64 <.LVL50>:
}
    7f64:	80 00 54 7f 	mova	#32596,	r0	;0x07f54

00007f68 <get_active_bank.part.12>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7f68:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00007f6c <.LVL52>:
    7f6c:	b0 13 42 c1 	calla	#49474		;0x0c142

00007f70 <.LVL53>:
}
    7f70:	10 01       	reta			;

00007f72 <cancel_fw_eeprom_cb>:
  chSysLockFromISR();
    7f72:	b0 13 a6 45 	calla	#17830		;0x045a6

00007f76 <.LBB40>:
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
    7f76:	b0 13 54 46 	calla	#18004		;0x04654

00007f7a <.LVL56>:

  if (bsp->sem.cnt < (cnt_t)1) {
    7f7a:	40 18 1c 42 	movx.w	&0x0d194,r12	;
    7f7e:	94 d1 
    7f80:	4d 43       	clr.b	r13		;
    7f82:	0d 9c       	cmp	r12,	r13	;
    7f84:	04 38       	jl	$+10     	;abs 0x7f8e

00007f86 <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    7f86:	8c 00 94 d1 	mova	#53652,	r12	;0x0d194
    7f8a:	b0 13 fe 4a 	calla	#19198		;0x04afe

00007f8e <.L32>:
  pages_acked++;
    7f8e:	40 18 92 53 	incx.w	&0xd190		;
    7f92:	90 d1 

00007f94 <.Loc.1516.2>:
  chSysUnlockFromISR();
    7f94:	b0 13 d0 45 	calla	#17872		;0x045d0

00007f98 <.LVL58>:
}
    7f98:	10 01       	reta			;

00007f9a <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * buffer) {
    7f9a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007f9c <.LCFI6>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (buffer[0] >> 7);
    7f9c:	6f 4d       	mov.b	@r13,	r15	;

00007f9e <.LVL60>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
  hdr.opcode = (buffer[0] & 0x3F);
  hdr.length = buffer[1];
    7f9e:	5b 4d 01 00 	mov.b	1(r13),	r11	;

00007fa2 <.LVL61>:
  return hdr;
    7fa2:	0a 4f       	mov	r15,	r10	;
    7fa4:	5a 0f       	rrum	#4,	r10	;
    7fa6:	5a 0b       	rrum	#3,	r10	;

00007fa8 <.Loc.1758.2>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
    7fa8:	0d 4f       	mov	r15,	r13	;

00007faa <.LVL62>:
    7faa:	5d 0f       	rrum	#4,	r13	;
    7fac:	5d 07       	rrum	#2,	r13	;

00007fae <.Loc.1761.2>:
  return hdr;
    7fae:	0d 5d       	rla	r13		;
    7fb0:	6d f3       	and.b	#2,	r13	;r3 As==10
    7fb2:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;

00007fb6 <.LVL63>:
    7fb6:	4d da       	bis.b	r10,	r13	;
    7fb8:	4d df       	bis.b	r15,	r13	;
    7fba:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    7fbe:	cc 4b 01 00 	mov.b	r11,	1(r12)	;

00007fc2 <.LVL64>:
}
    7fc2:	0a 16       	popm.a	#1,	r10	;20-bit words
    7fc4:	10 01       	reta			;

00007fc6 <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7fc6:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007fc8 <.LCFI7>:
    7fc8:	b1 00 02 00 	suba	#2,	r1	;

00007fcc <.LCFI8>:
    7fcc:	ca 0d       	mova	r13,	r10	;
    7fce:	69 4c       	mov.b	@r12,	r9	;
    7fd0:	0f 49       	mov	r9,	r15	;
    7fd2:	5f 07       	rrum	#2,	r15	;

00007fd4 <.LVL66>:
    7fd4:	58 4c 01 00 	mov.b	1(r12),	r8	;

00007fd8 <.LVL67>:
    7fd8:	c1 48 01 00 	mov.b	r8,	1(r1)	;

00007fdc <.Loc.1767.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    7fdc:	77 40 2f 00 	mov.b	#47,	r7	;#0x002f
    7fe0:	07 9f       	cmp	r15,	r7	;
    7fe2:	07 34       	jge	$+16     	;abs 0x7ff2

00007fe4 <.Loc.1768.2>:
    elyErrorSignal(ErrInvalidOpcode);
    7fe4:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

00007fe8 <.L178>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    7fe8:	b0 13 98 c3 	calla	#50072		;0x0c398

00007fec <.L66>:
      return false;
    7fec:	4a 43       	clr.b	r10		;

00007fee <.LVL71>:
    7fee:	80 00 6a 80 	mova	#32874,	r0	;0x0806a

00007ff2 <.L35>:
  if (hdr.reply) {
    7ff2:	79 f0 03 00 	and.b	#3,	r9	;
    7ff6:	0c 4f       	mov	r15,	r12	;
    7ff8:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7ffc:	49 dc       	bis.b	r12,	r9	;
    7ffe:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    8002:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8006:	4d 49       	mov.b	r9,	r13	;
    8008:	6d f3       	and.b	#2,	r13	;r3 As==10
    800a:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    800c:	0a 24       	jz	$+22     	;abs 0x8022

0000800e <.Loc.1774.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    800e:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    8012:	da 9c 51 00 	cmp.b	81(r12),2(r10)	;0x00051
    8016:	02 00 
    8018:	04 20       	jnz	$+10     	;abs 0x8022

0000801a <.Loc.1774.2>:
    801a:	da 9c 50 00 	cmp.b	80(r12),3(r10)	;0x00050
    801e:	03 00 
    8020:	e5 27       	jz	$-52     	;abs 0x7fec

00008022 <.L37>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8022:	59 f3       	and.b	#1,	r9	;r3 As==01
    8024:	09 93       	cmp	#0,	r9	;r3 As==00
    8026:	26 24       	jz	$+78     	;abs 0x8074
    8028:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000802a <.L38>:
    802a:	40 18 4e 48 	movx.b	r8,	r14	;
    802e:	40 18 4e 8d 	subx.b	r13,	r14	;
    8032:	4e 8c       	sub.b	r12,	r14	;
    8034:	4d 4e       	mov.b	r14,	r13	;

00008036 <.LVL73>:
  switch(hdr.opcode) {
    8036:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    803a:	4f 24       	jz	$+160    	;abs 0x80da
    803c:	77 40 16 00 	mov.b	#22,	r7	;#0x0016
    8040:	47 9f       	cmp.b	r15,	r7	;
    8042:	70 28       	jnc	$+226    	;abs 0x8124
    8044:	7f 90 0a 00 	cmp.b	#10,	r15	;#0x000a
    8048:	48 24       	jz	$+146    	;abs 0x80da
    804a:	77 40 0a 00 	mov.b	#10,	r7	;#0x000a
    804e:	47 9f       	cmp.b	r15,	r7	;
    8050:	30 28       	jnc	$+98     	;abs 0x80b2
    8052:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    8054:	cf 24       	jz	$+416    	;abs 0x81f4
    8056:	67 42       	mov.b	#4,	r7	;r2 As==10
    8058:	47 9f       	cmp.b	r15,	r7	;
    805a:	0f 28       	jnc	$+32     	;abs 0x807a
    805c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    805e:	3d 20       	jnz	$+124    	;abs 0x80da

00008060 <.L45>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    8060:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    8062:	3d 20       	jnz	$+124    	;abs 0x80de

00008064 <.L62>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    8064:	09 93       	cmp	#0,	r9	;r3 As==00
    8066:	de 20       	jnz	$+446    	;abs 0x8224

00008068 <.L65>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    8068:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000806a <.L36>:
  
}
    806a:	4c 4a       	mov.b	r10,	r12	;
    806c:	a1 00 02 00 	adda	#2,	r1	;
    8070:	37 16       	popm.a	#4,	r10	;20-bit words
    8072:	10 01       	reta			;

00008074 <.L67>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8074:	0c 49       	mov	r9,	r12	;
    8076:	80 00 2a 80 	mova	#32810,	r0	;0x0802a

0000807a <.L44>:
  switch(hdr.opcode) {
    807a:	7f 90 07 00 	cmp.b	#7,	r15	;
    807e:	ca 24       	jz	$+406    	;abs 0x8214
    8080:	77 40 07 00 	mov.b	#7,	r7	;
    8084:	47 9f       	cmp.b	r15,	r7	;
    8086:	0c 28       	jnc	$+26     	;abs 0x80a0
    8088:	7f 90 05 00 	cmp.b	#5,	r15	;
    808c:	b9 24       	jz	$+372    	;abs 0x8200
    808e:	7f 90 06 00 	cmp.b	#6,	r15	;
    8092:	ab 24       	jz	$+344    	;abs 0x81ea

00008094 <.L39>:
      chDbgAssert(false, "invalid opcode in length check");
    8094:	8c 01 77 06 	mova	#67191,	r12	;0x10677
    8098:	b0 13 dc 47 	calla	#18396		;0x047dc

0000809c <.LVL78>:
    809c:	80 00 64 80 	mova	#32868,	r0	;0x08064

000080a0 <.L47>:
  switch(hdr.opcode) {
    80a0:	7f 92       	cmp.b	#8,	r15	;r2 As==11
    80a2:	1b 24       	jz	$+56     	;abs 0x80da
    80a4:	7f 90 09 00 	cmp.b	#9,	r15	;
    80a8:	f5 23       	jnz	$-20     	;abs 0x8094

000080aa <.L175>:
      if (payload_len != 2 && payload_len != 4 && 
    80aa:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    80ac:	18 20       	jnz	$+50     	;abs 0x80de
    80ae:	80 00 64 80 	mova	#32868,	r0	;0x08064

000080b2 <.L42>:
  switch(hdr.opcode) {
    80b2:	7f 90 10 00 	cmp.b	#16,	r15	;#0x0010
    80b6:	11 24       	jz	$+36     	;abs 0x80da
    80b8:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    80bc:	47 9f       	cmp.b	r15,	r7	;
    80be:	1b 28       	jnc	$+56     	;abs 0x80f6
    80c0:	7f 90 0d 00 	cmp.b	#13,	r15	;#0x000d
    80c4:	f2 27       	jz	$-26     	;abs 0x80aa
    80c6:	77 40 0d 00 	mov.b	#13,	r7	;#0x000d
    80ca:	47 9f       	cmp.b	r15,	r7	;
    80cc:	0c 28       	jnc	$+26     	;abs 0x80e6
    80ce:	7f 90 0b 00 	cmp.b	#11,	r15	;#0x000b
    80d2:	eb 27       	jz	$-40     	;abs 0x80aa
    80d4:	7f 90 0c 00 	cmp.b	#12,	r15	;#0x000c
    80d8:	dd 23       	jnz	$-68     	;abs 0x8094

000080da <.L40>:
      if (payload_len != 0) {
    80da:	0d 93       	cmp	#0,	r13	;r3 As==00
    80dc:	c3 27       	jz	$-120    	;abs 0x8064

000080de <.L63>:
        elyErrorSignal(ErrInvalidLength);
    80de:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    80e2:	80 00 e8 7f 	mova	#32744,	r0	;0x07fe8

000080e6 <.L52>:
  switch(hdr.opcode) {
    80e6:	7f 90 0e 00 	cmp.b	#14,	r15	;#0x000e
    80ea:	f7 27       	jz	$-16     	;abs 0x80da
    80ec:	7f 90 0f 00 	cmp.b	#15,	r15	;#0x000f
    80f0:	dc 27       	jz	$-70     	;abs 0x80aa
    80f2:	80 00 94 80 	mova	#32916,	r0	;0x08094

000080f6 <.L51>:
    80f6:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    80fa:	d7 27       	jz	$-80     	;abs 0x80aa
    80fc:	77 40 13 00 	mov.b	#19,	r7	;#0x0013
    8100:	47 9f       	cmp.b	r15,	r7	;
    8102:	08 28       	jnc	$+18     	;abs 0x8114
    8104:	7f 90 11 00 	cmp.b	#17,	r15	;#0x0011
    8108:	d0 27       	jz	$-94     	;abs 0x80aa
    810a:	7f 90 12 00 	cmp.b	#18,	r15	;#0x0012
    810e:	e5 27       	jz	$-52     	;abs 0x80da
    8110:	80 00 94 80 	mova	#32916,	r0	;0x08094

00008114 <.L53>:
    8114:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    8118:	e0 27       	jz	$-62     	;abs 0x80da
    811a:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    811e:	a0 27       	jz	$-190    	;abs 0x8060
    8120:	80 00 94 80 	mova	#32916,	r0	;0x08094

00008124 <.L41>:
    8124:	7f 90 24 00 	cmp.b	#36,	r15	;#0x0024
    8128:	c0 27       	jz	$-126    	;abs 0x80aa
    812a:	77 40 24 00 	mov.b	#36,	r7	;#0x0024
    812e:	47 9f       	cmp.b	r15,	r7	;
    8130:	31 28       	jnc	$+100    	;abs 0x8194
    8132:	7f 90 1c 00 	cmp.b	#28,	r15	;#0x001c
    8136:	5e 24       	jz	$+190    	;abs 0x81f4
    8138:	77 40 1c 00 	mov.b	#28,	r7	;#0x001c
    813c:	47 9f       	cmp.b	r15,	r7	;
    813e:	1b 28       	jnc	$+56     	;abs 0x8176
    8140:	7f 90 19 00 	cmp.b	#25,	r15	;#0x0019
    8144:	12 24       	jz	$+38     	;abs 0x816a
    8146:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    814a:	4d 9f       	cmp.b	r15,	r13	;
    814c:	08 28       	jnc	$+18     	;abs 0x815e
    814e:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    8152:	ab 27       	jz	$-168    	;abs 0x80aa
    8154:	7f 90 18 00 	cmp.b	#24,	r15	;#0x0018
    8158:	83 27       	jz	$-248    	;abs 0x8060
    815a:	80 00 94 80 	mova	#32916,	r0	;0x08094

0000815e <.L57>:
    815e:	7f 90 1a 00 	cmp.b	#26,	r15	;#0x001a
    8162:	48 24       	jz	$+146    	;abs 0x81f4
    8164:	7f 90 1b 00 	cmp.b	#27,	r15	;#0x001b
    8168:	95 23       	jnz	$-212    	;abs 0x8094

0000816a <.L56>:
      if (payload_len < 4 || payload_len > 251) {
    816a:	7e 50 fc ff 	add.b	#-4,	r14	;#0xfffc

0000816e <.LVL84>:
    816e:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    8172:	80 00 f8 81 	mova	#33272,	r0	;0x081f8

00008176 <.L55>:
  switch(hdr.opcode) {
    8176:	77 40 22 00 	mov.b	#34,	r7	;#0x0022
    817a:	47 9f       	cmp.b	r15,	r7	;
    817c:	ae 2b       	jnc	$-162    	;abs 0x80da
    817e:	7f 90 1f 00 	cmp.b	#31,	r15	;#0x001f
    8182:	38 2c       	jc	$+114    	;abs 0x81f4
    8184:	7f 90 1d 00 	cmp.b	#29,	r15	;#0x001d
    8188:	6b 27       	jz	$-296    	;abs 0x8060
    818a:	7f 90 1e 00 	cmp.b	#30,	r15	;#0x001e
    818e:	82 23       	jnz	$-250    	;abs 0x8094
    8190:	80 00 da 80 	mova	#32986,	r0	;0x080da

00008194 <.L54>:
    8194:	7f 90 2a 00 	cmp.b	#42,	r15	;#0x002a
    8198:	e8 27       	jz	$-46     	;abs 0x816a
    819a:	77 40 2a 00 	mov.b	#42,	r7	;#0x002a
    819e:	47 9f       	cmp.b	r15,	r7	;
    81a0:	0e 28       	jnc	$+30     	;abs 0x81be
    81a2:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    81a6:	5c 27       	jz	$-326    	;abs 0x8060
    81a8:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    81ac:	96 2b       	jnc	$-210    	;abs 0x80da
    81ae:	7f 90 28 00 	cmp.b	#40,	r15	;#0x0028
    81b2:	93 27       	jz	$-216    	;abs 0x80da
    81b4:	7f 90 29 00 	cmp.b	#41,	r15	;#0x0029
    81b8:	53 27       	jz	$-344    	;abs 0x8060
    81ba:	80 00 94 80 	mova	#32916,	r0	;0x08094

000081be <.L58>:
    81be:	77 40 2d 00 	mov.b	#45,	r7	;#0x002d
    81c2:	47 9f       	cmp.b	r15,	r7	;
    81c4:	07 28       	jnc	$+16     	;abs 0x81d4
    81c6:	7f 90 2c 00 	cmp.b	#44,	r15	;#0x002c
    81ca:	87 2f       	jc	$-240    	;abs 0x80da

000081cc <.Loc.1820.2>:
      if (payload_len != 2) {
    81cc:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    81ce:	4a 27       	jz	$-362    	;abs 0x8064
    81d0:	80 00 de 80 	mova	#32990,	r0	;0x080de

000081d4 <.L59>:
  switch(hdr.opcode) {
    81d4:	7f 90 2e 00 	cmp.b	#46,	r15	;#0x002e
    81d8:	0d 24       	jz	$+28     	;abs 0x81f4
    81da:	7f 90 2f 00 	cmp.b	#47,	r15	;#0x002f
    81de:	5a 23       	jnz	$-330    	;abs 0x8094

000081e0 <.Loc.1848.2>:
      if (payload_len != 2 && payload_len != 4 && 
    81e0:	7e c2       	bic.b	#8,	r14	;r2 As==11

000081e2 <.LVL86>:
    81e2:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    81e4:	62 23       	jnz	$-314    	;abs 0x80aa
    81e6:	80 00 64 80 	mova	#32868,	r0	;0x08064

000081ea <.L49>:
      if (payload_len != 3) {
    81ea:	7e 90 03 00 	cmp.b	#3,	r14	;
    81ee:	3a 27       	jz	$-394    	;abs 0x8064
    81f0:	80 00 de 80 	mova	#32990,	r0	;0x080de

000081f4 <.L43>:
      if (payload_len > 251) {
    81f4:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb

000081f8 <.L177>:
      if (payload_len < 4 || payload_len > 251) {
    81f8:	4c 9e       	cmp.b	r14,	r12	;
    81fa:	34 2f       	jc	$-406    	;abs 0x8064
    81fc:	80 00 de 80 	mova	#32990,	r0	;0x080de

00008200 <.L48>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    8200:	4c 4e       	mov.b	r14,	r12	;
    8202:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8204:	7d 40 fa ff 	mov.b	#-6,	r13	;#0xfffa
    8208:	4d 9c       	cmp.b	r12,	r13	;
    820a:	69 2b       	jnc	$-300    	;abs 0x80de

0000820c <.Loc.1870.2>:
    820c:	1e b3       	bit	#1,	r14	;r3 As==01
    820e:	2a 23       	jnz	$-426    	;abs 0x8064
    8210:	80 00 de 80 	mova	#32990,	r0	;0x080de

00008214 <.L46>:
      if (payload_len < 2 || payload_len > 251) {
    8214:	7e 50 fe ff 	add.b	#-2,	r14	;#0xfffe

00008218 <.LVL90>:
    8218:	77 40 f9 ff 	mov.b	#-7,	r7	;#0xfff9
    821c:	47 9e       	cmp.b	r14,	r7	;
    821e:	22 2f       	jc	$-442    	;abs 0x8064
    8220:	80 00 de 80 	mova	#32990,	r0	;0x080de

00008224 <.L64>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    8224:	0d 48       	mov	r8,	r13	;
    8226:	2d 53       	incd	r13		;
    8228:	4d 0e       	rlam.a	#4,	r13	;
    822a:	4d 0d       	rram.a	#4,	r13	;
    822c:	cc 0a       	mova	r10,	r12	;
    822e:	b0 13 d8 ae 	calla	#44760		;0x0aed8

00008232 <.LVL92>:
    8232:	4a 4c       	mov.b	r12,	r10	;

00008234 <.LVL93>:
    8234:	0a 93       	cmp	#0,	r10	;r3 As==00
    8236:	18 23       	jnz	$-462    	;abs 0x8068

00008238 <.Loc.1900.2>:
      elyErrorSignal(ErrFCSError);
    8238:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    823c:	b0 13 98 c3 	calla	#50072		;0x0c398

00008240 <.LVL94>:
      return false;
    8240:	80 00 6a 80 	mova	#32874,	r0	;0x0806a

00008244 <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    8244:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008246 <.LCFI9>:
    8246:	b1 00 06 00 	suba	#6,	r1	;

0000824a <.LCFI10>:
    824a:	ca 0c       	mova	r12,	r10	;
    824c:	cc 0d       	mova	r13,	r12	;
    824e:	6e 4a       	mov.b	@r10,	r14	;
    8250:	0d 4e       	mov	r14,	r13	;

00008252 <.LVL96>:
    8252:	5d 07       	rrum	#2,	r13	;

00008254 <.LVL97>:
    8254:	d1 4a 01 00 	mov.b	1(r10),	5(r1)	;
    8258:	05 00 

0000825a <.Loc.1911.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    825a:	0a 4d       	mov	r13,	r10	;
    825c:	0b 43       	clr	r11		;
    825e:	08 4a       	mov	r10,	r8	;
    8260:	09 4b       	mov	r11,	r9	;
    8262:	08 58       	rla	r8		;
    8264:	09 69       	rlc	r9		;
    8266:	08 58       	rla	r8		;
    8268:	09 69       	rlc	r9		;
    826a:	81 48 00 00 	mov	r8,	0(r1)	;
    826e:	81 49 02 00 	mov	r9,	2(r1)	;
    8272:	08 01       	mova	@r1,	r8	;
    8274:	80 18 5a 48 	movx.a	67206(r8),r10	;0x10686
    8278:	86 06 
    827a:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;

0000827e <.LVL99>:
    827e:	7e f0 03 00 	and.b	#3,	r14	;

00008282 <.LVL100>:
    8282:	4e dd       	bis.b	r13,	r14	;
    8284:	c1 4e 04 00 	mov.b	r14,	4(r1)	;
    8288:	cd 01       	mova	r1,	r13	;
    828a:	ad 00 04 00 	adda	#4,	r13	;
    828e:	4a 13       	calla	r10		;

00008290 <.LVL101>:
}
    8290:	a1 00 06 00 	adda	#6,	r1	;
    8294:	28 16       	popm.a	#3,	r10	;20-bit words
    8296:	10 01       	reta			;

00008298 <elyCmdSendReplyI>:
  msg = elyCmdSendReplyI(buff);
  chSysUnlock();
  return msg;
}

msg_t elyCmdSendReplyI(uint8_t * buff) {
    8298:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000829a <.LCFI11>:
  uint8_t * buffer = elyNLPack(buff);
    829a:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000829e <.LVL103>:
    829e:	ca 0c       	mova	r12,	r10	;

000082a0 <.Loc.1924.2>:
  switch (elyNLGetDest(buffer)) {
    82a0:	b0 13 72 c1 	calla	#49522		;0x0c172

000082a4 <.LVL105>:
    82a4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    82a6:	07 24       	jz	$+16     	;abs 0x82b6
    82a8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    82aa:	0a 20       	jnz	$+22     	;abs 0x82c0

000082ac <.Loc.1926.2>:
    case ELY_DEST_RF:
      return elyRFPostI(buffer);
    82ac:	cc 0a       	mova	r10,	r12	;
    82ae:	b0 13 f2 af 	calla	#45042		;0x0aff2

000082b2 <.L180>:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
  /* also shouldn't happen */
  return MSG_RESET;
}
    82b2:	0a 16       	popm.a	#1,	r10	;20-bit words
    82b4:	10 01       	reta			;

000082b6 <.L182>:
      return elyUARTPostI(buffer);
    82b6:	cc 0a       	mova	r10,	r12	;
    82b8:	b0 13 a4 7a 	calla	#31396		;0x07aa4

000082bc <.LVL107>:
    82bc:	80 00 b2 82 	mova	#33458,	r0	;0x082b2

000082c0 <.L185>:
      chDbgAssert(false, "shouldn't happen");
    82c0:	8c 01 66 06 	mova	#67174,	r12	;0x10666
    82c4:	b0 13 dc 47 	calla	#18396		;0x047dc

000082c8 <.LVL108>:
  return MSG_RESET;
    82c8:	8c 0f fe ff 	mova	#-2,	r12	;0xfffffffe
    82cc:	80 00 b2 82 	mova	#33458,	r0	;0x082b2

000082d0 <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buffer) {
    82d0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000082d2 <.LCFI12>:
  buffer = buffer - 4;
    82d2:	ca 0c       	mova	r12,	r10	;
    82d4:	aa 0f fc ff 	adda	#1048572,r10	;0xffffc

000082d8 <.LVL110>:
  gen_success(buffer, buffer[0] & 0x80); /* crc */
    82d8:	5d 4c fc ff 	mov.b	-4(r12),r13	;
    82dc:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    82e0:	cc 0a       	mova	r10,	r12	;
    82e2:	b0 13 b8 7d 	calla	#32184		;0x07db8

000082e6 <.LVL111>:
  chSysLockFromISR();
    82e6:	b0 13 a6 45 	calla	#17830		;0x045a6

000082ea <.LVL112>:
  elyCmdSendReplyI(buffer);
    82ea:	cc 0a       	mova	r10,	r12	;
    82ec:	b0 13 98 82 	calla	#33432		;0x08298

000082f0 <.LVL113>:
  chSysUnlockFromISR();
    82f0:	b0 13 d0 45 	calla	#17872		;0x045d0

000082f4 <.LVL114>:
}
    82f4:	0a 16       	popm.a	#1,	r10	;20-bit words
    82f6:	10 01       	reta			;

000082f8 <verify_fw_cb>:
  uint16_t result = crcStop();
    82f8:	b0 13 64 af 	calla	#44900		;0x0af64

000082fc <.LVL116>:
    82fc:	2e 00 96 d1 	mova	&53654,	r14	;0x0d196

00008300 <.Loc.1466.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    8300:	6d 4e       	mov.b	@r14,	r13	;
    8302:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80

00008306 <.Loc.1465.2>:
  if (result == verify_crc) {
    8306:	40 18 1c 92 	cmpx.w	&0x0d19a,r12	;
    830a:	9a d1 
    830c:	0c 20       	jnz	$+26     	;abs 0x8326

0000830e <.Loc.1466.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    830e:	cc 0e       	mova	r14,	r12	;

00008310 <.LVL117>:
    8310:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008314 <.L189>:
  chSysLockFromISR();
    8314:	b0 13 a6 45 	calla	#17830		;0x045a6

00008318 <.LVL119>:
  elyCmdSendReplyI(stored_buff);
    8318:	2c 00 96 d1 	mova	&53654,	r12	;0x0d196
    831c:	b0 13 98 82 	calla	#33432		;0x08298

00008320 <.LVL120>:
  chSysUnlockFromISR();
    8320:	b0 13 d0 45 	calla	#17872		;0x045d0

00008324 <.LVL121>:
}
    8324:	10 01       	reta			;

00008326 <.L188>:
    gen_failure(stored_buff, stored_buff[0] & 0x80); /* crc */
    8326:	cc 0e       	mova	r14,	r12	;

00008328 <.LVL123>:
    8328:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000832c <.LVL124>:
    832c:	80 00 14 83 	mova	#33556,	r0	;0x08314

00008330 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buffer) {
    8330:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008332 <.LCFI13>:
    8332:	08 14       	pushm.a	#1,	r8	;20-bit words

00008334 <.LCFI14>:
    8334:	c8 0c       	mova	r12,	r8	;

00008336 <.Loc.1404.2>:
  buffer = buffer - 8;
    8336:	ca 0c       	mova	r12,	r10	;
    8338:	aa 0f f8 ff 	adda	#1048568,r10	;0xffff8

0000833c <.LVL126>:
  chSysLockFromISR();
    833c:	b0 13 a6 45 	calla	#17830		;0x045a6

00008340 <.LVL127>:
    gen_success(buffer, buffer[0] & 0x80); /* crc */
    8340:	5d 48 f8 ff 	mov.b	-8(r8),	r13	;
    8344:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    8348:	cc 0a       	mova	r10,	r12	;
    834a:	b0 13 b8 7d 	calla	#32184		;0x07db8

0000834e <.LVL128>:
    elyCmdSendReplyI(buffer);
    834e:	cc 0a       	mova	r10,	r12	;
    8350:	b0 13 98 82 	calla	#33432		;0x08298

00008354 <.LVL129>:
  chSysUnlockFromISR();
    8354:	b0 13 d0 45 	calla	#17872		;0x045d0

00008358 <.LVL130>:
}
    8358:	08 16       	popm.a	#1,	r8	;20-bit words
    835a:	0a 16       	popm.a	#1,	r10	;20-bit words
    835c:	10 01       	reta			;

0000835e <elyCmdSendReply>:
msg_t elyCmdSendReply(uint8_t * buff) {
    835e:	b1 00 04 00 	suba	#4,	r1	;

00008362 <.LCFI15>:
  chSysLock();
    8362:	71 0c 00 00 	mova	r12,	0(r1)	;
    8366:	b0 13 94 7d 	calla	#32148		;0x07d94

0000836a <.LVL132>:
    836a:	b0 13 54 45 	calla	#17748		;0x04554

0000836e <.LVL133>:
  msg = elyCmdSendReplyI(buff);
    836e:	0c 01       	mova	@r1,	r12	;
    8370:	b0 13 98 82 	calla	#33432		;0x08298

00008374 <.LVL134>:
  chSysUnlock();
    8374:	71 0c 00 00 	mova	r12,	0(r1)	;
    8378:	b0 13 7c 45 	calla	#17788		;0x0457c

0000837c <.LVL135>:
    837c:	b0 13 9c 7d 	calla	#32156		;0x07d9c

00008380 <.LVL136>:
}
    8380:	0c 01       	mova	@r1,	r12	;
    8382:	a1 00 04 00 	adda	#4,	r1	;
    8386:	10 01       	reta			;

00008388 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8388:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000838a <.LCFI16>:
    838a:	b1 00 18 00 	suba	#24,	r1	;0x00018

0000838e <.LCFI17>:
    838e:	c4 0c       	mova	r12,	r4	;
    8390:	cc 0d       	mova	r13,	r12	;

00008392 <.LVL138>:
    8392:	6d 4d       	mov.b	@r13,	r13	;
    8394:	5d f3       	and.b	#1,	r13	;r3 As==01
    8396:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

0000839a <.LVL139>:
    839a:	5f 4c 01 00 	mov.b	1(r12),	r15	;

0000839e <.LVL140>:
    839e:	c1 4f 09 00 	mov.b	r15,	9(r1)	;

000083a2 <.Loc.1657.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    83a2:	6c 4c       	mov.b	@r12,	r12	;

000083a4 <.LVL142>:
    83a4:	5c c3       	bic.b	#1,	r12	;r3 As==01
    83a6:	4c dd       	bis.b	r13,	r12	;
    83a8:	c1 4c 08 00 	mov.b	r12,	8(r1)	;
    83ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    83b0:	4e 4c       	mov.b	r12,	r14	;
    83b2:	6e f3       	and.b	#2,	r14	;r3 As==10
    83b4:	46 4e       	mov.b	r14,	r6	;
    83b6:	06 93       	cmp	#0,	r6	;r3 As==00
    83b8:	44 20       	jnz	$+138    	;abs 0x8442
    83ba:	6d 43       	mov.b	#2,	r13	;r3 As==10

000083bc <.L193>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    83bc:	1c b3       	bit	#1,	r12	;r3 As==01
    83be:	44 20       	jnz	$+138    	;abs 0x8448

000083c0 <.Loc.1658.2>:
    83c0:	4c 43       	clr.b	r12		;

000083c2 <.L194>:
    83c2:	4f 8e       	sub.b	r14,	r15	;

000083c4 <.LVL144>:
    83c4:	4f 8c       	sub.b	r12,	r15	;

000083c6 <.LVL145>:
  config.duration = ((buffer[hdr_ext] << 8) | buffer[hdr_ext+1]);
    83c6:	40 18 0c 4d 	movx.w	r13,	r12	;
    83ca:	ce 04       	mova	r4,	r14	;
    83cc:	ee 0c       	adda	r12,	r14	;
    83ce:	65 4e       	mov.b	@r14,	r5	;
    83d0:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    83d4:	5b 4e 01 00 	mov.b	1(r14),	r11	;
    83d8:	0b d5       	bis	r5,	r11	;
    83da:	81 4b 12 00 	mov	r11,	18(r1)	; 0x0012

000083de <.Loc.1663.2>:
  if (payload_len == 4 || payload_len == 12) {
    83de:	45 4f       	mov.b	r15,	r5	;
    83e0:	75 c2       	bic.b	#8,	r5	;r2 As==11
    83e2:	65 92       	cmp.b	#4,	r5	;r2 As==10
    83e4:	6c 20       	jnz	$+218    	;abs 0x84be

000083e6 <.LVL146>:
    config.index_start = buffer[hdr_ext+2];
    83e6:	d1 4e 02 00 	mov.b	2(r14),	20(r1)	; 0x0014
    83ea:	14 00 

000083ec <.Loc.1666.2>:
    config.index_end = buffer[hdr_ext+3];
    83ec:	d1 4e 03 00 	mov.b	3(r14),	21(r1)	; 0x0015
    83f0:	15 00 

000083f2 <.Loc.1672.2>:
  if (payload_len > 4) {
    83f2:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    83f4:	33 20       	jnz	$+104    	;abs 0x845c

000083f6 <.L207>:
    config.use_index = true;
    83f6:	55 43       	mov.b	#1,	r5	;r3 As==01

000083f8 <.L197>:
  chSysLock();
    83f8:	b0 13 94 7d 	calla	#32148		;0x07d94

000083fc <.LVL149>:
    83fc:	b0 13 54 45 	calla	#17748		;0x04554

00008400 <.LVL150>:
  elyTelemUpdateConfigS(config);
    8400:	81 4a 0a 00 	mov	r10,	10(r1)	; 0x000a
    8404:	81 49 0c 00 	mov	r9,	12(r1)	; 0x000c
    8408:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    840c:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    8410:	c1 45 16 00 	mov.b	r5,	22(r1)	; 0x0016
    8414:	cc 01       	mova	r1,	r12	;
    8416:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    841a:	b0 13 f2 c5 	calla	#50674		;0x0c5f2

0000841e <.LVL151>:
  chSysUnlock();
    841e:	b0 13 7c 45 	calla	#17788		;0x0457c

00008422 <.LVL152>:
    8422:	b0 13 9c 7d 	calla	#32156		;0x07d9c

00008426 <.LVL153>:
  if (hdr.reply) {
    8426:	06 93       	cmp	#0,	r6	;r3 As==00
    8428:	12 24       	jz	$+38     	;abs 0x844e

0000842a <.Loc.1694.2>:
    gen_success(buffer, hdr.crc);
    842a:	5d 41 07 00 	mov.b	7(r1),	r13	;
    842e:	cc 04       	mova	r4,	r12	;
    8430:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008434 <.LVL154>:
    elyCmdSendReply(buffer);
    8434:	cc 04       	mova	r4,	r12	;
    8436:	b0 13 5e 83 	calla	#33630		;0x0835e

0000843a <.L192>:
}
    843a:	a1 00 18 00 	adda	#24,	r1	;0x00018
    843e:	64 16       	popm.a	#7,	r10	;20-bit words
    8440:	10 01       	reta			;

00008442 <.L203>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8442:	6d 42       	mov.b	#4,	r13	;r2 As==10

00008444 <.LVL157>:
    8444:	80 00 bc 83 	mova	#33724,	r0	;0x083bc

00008448 <.L204>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8448:	6c 43       	mov.b	#2,	r12	;r3 As==10
    844a:	80 00 c2 83 	mova	#33730,	r0	;0x083c2

0000844e <.L200>:
    elyNLFreeBuffer(elyNLPack(buffer));
    844e:	cc 04       	mova	r4,	r12	;
    8450:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008454 <.LVL160>:
    8454:	b0 13 42 c1 	calla	#49474		;0x0c142

00008458 <.LVL161>:
}
    8458:	80 00 3a 84 	mova	#33850,	r0	;0x0843a

0000845c <.L196>:
    config.use_timestamp = true;
    845c:	d1 43 17 00 	mov.b	#1,	23(r1)	;r3 As==01, 0x0017

00008460 <.LBB42>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    8460:	0e 4d       	mov	r13,	r14	;
    8462:	3e 50 0b 00 	add	#11,	r14	;#0x000b
    8466:	4e 0e       	rlam.a	#4,	r14	;
    8468:	4e 0d       	rram.a	#4,	r14	;
    846a:	ee 04       	adda	r4,	r14	;
    846c:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    8470:	81 4e 04 00 	mov	r14,	4(r1)	;
    8474:	ac 00 07 00 	adda	#7,	r12	;
    8478:	ce 04       	mova	r4,	r14	;
    847a:	ee 0c       	adda	r12,	r14	;
    847c:	45 43       	clr.b	r5		;

0000847e <.L198>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    847e:	6c 4e       	mov.b	@r14,	r12	;
    8480:	0d 45       	mov	r5,	r13	;
    8482:	71 0e 00 00 	mova	r14,	0(r1)	;
    8486:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    848a:	0d 4c       	mov	r12,	r13	;
    848c:	0b 4c       	mov	r12,	r11	;
    848e:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8492:	0a dd       	bis	r13,	r10	;

00008494 <.LVL165>:
    8494:	09 dc       	bis	r12,	r9	;

00008496 <.Loc.1677.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    8496:	1c 41 04 00 	mov	4(r1),	r12	;
    849a:	0d 45       	mov	r5,	r13	;
    849c:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    84a0:	0d 4c       	mov	r12,	r13	;
    84a2:	0b 4c       	mov	r12,	r11	;
    84a4:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    84a8:	08 dd       	bis	r13,	r8	;

000084aa <.LVL167>:
    84aa:	07 dc       	bis	r12,	r7	;
    84ac:	0e 01       	mova	@r1,	r14	;
    84ae:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    84b2:	35 52       	add	#8,	r5	;r2 As==11

000084b4 <.Loc.1675.2>:
      for (int i = 0; i < 4; i++) {
    84b4:	35 90 20 00 	cmp	#32,	r5	;#0x0020
    84b8:	e2 23       	jnz	$-58     	;abs 0x847e
    84ba:	80 00 f6 83 	mova	#33782,	r0	;0x083f6

000084be <.L195>:
  if (payload_len > 4) {
    84be:	6e 42       	mov.b	#4,	r14	;r2 As==10
    84c0:	4e 9f       	cmp.b	r15,	r14	;
    84c2:	2f 2c       	jc	$+96     	;abs 0x8522

000084c4 <.Loc.1673.2>:
    config.use_timestamp = true;
    84c4:	d1 43 17 00 	mov.b	#1,	23(r1)	;r3 As==01, 0x0017

000084c8 <.LBB43>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    84c8:	0e 4d       	mov	r13,	r14	;
    84ca:	3e 50 09 00 	add	#9,	r14	;
    84ce:	4e 0e       	rlam.a	#4,	r14	;
    84d0:	4e 0d       	rram.a	#4,	r14	;
    84d2:	ee 04       	adda	r4,	r14	;
    84d4:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    84d8:	81 4e 04 00 	mov	r14,	4(r1)	;
    84dc:	ac 00 05 00 	adda	#5,	r12	;
    84e0:	ce 04       	mova	r4,	r14	;
    84e2:	ee 0c       	adda	r12,	r14	;
    84e4:	45 43       	clr.b	r5		;

000084e6 <.L199>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    84e6:	6c 4e       	mov.b	@r14,	r12	;
    84e8:	0d 45       	mov	r5,	r13	;
    84ea:	71 0e 00 00 	mova	r14,	0(r1)	;
    84ee:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    84f2:	0d 4c       	mov	r12,	r13	;
    84f4:	0b 4c       	mov	r12,	r11	;
    84f6:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    84fa:	0a dd       	bis	r13,	r10	;

000084fc <.LVL172>:
    84fc:	09 dc       	bis	r12,	r9	;

000084fe <.Loc.1683.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    84fe:	1c 41 04 00 	mov	4(r1),	r12	;
    8502:	0d 45       	mov	r5,	r13	;
    8504:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    8508:	0d 4c       	mov	r12,	r13	;
    850a:	0b 4c       	mov	r12,	r11	;
    850c:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8510:	08 dd       	bis	r13,	r8	;

00008512 <.LVL174>:
    8512:	07 dc       	bis	r12,	r7	;
    8514:	0e 01       	mova	@r1,	r14	;
    8516:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    851a:	35 52       	add	#8,	r5	;r2 As==11

0000851c <.Loc.1681.2>:
      for (int i = 0; i < 4; i++) {
    851c:	35 90 20 00 	cmp	#32,	r5	;#0x0020
    8520:	e2 23       	jnz	$-58     	;abs 0x84e6

00008522 <.L208>:
    config.use_index = false;
    8522:	45 43       	clr.b	r5		;
    8524:	80 00 f8 83 	mova	#33784,	r0	;0x083f8

00008528 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    8528:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000852a <.LCFI18>:
    852a:	b1 00 02 00 	suba	#2,	r1	;

0000852e <.LCFI19>:
    852e:	ca 0c       	mova	r12,	r10	;
    8530:	ce 0d       	mova	r13,	r14	;

00008532 <.LVL177>:
  if (hdr.reply) {
    8532:	6d 4d       	mov.b	@r13,	r13	;

00008534 <.LVL178>:
    8534:	5d f3       	and.b	#1,	r13	;r3 As==01
    8536:	40 18 ee b3 	bitx.b	#2,	0(r14)	;r3 As==10
    853a:	00 00 
    853c:	10 24       	jz	$+34     	;abs 0x855e

0000853e <.Loc.1610.2>:
    gen_success(buffer, hdr.crc);
    853e:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008542 <.LVL179>:
    elyCmdSendReply(buffer);
    8542:	cc 0a       	mova	r10,	r12	;
    8544:	b0 13 5e 83 	calla	#33630		;0x0835e

00008548 <.L211>:
  bootloader = 1;
    8548:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    854c:	fc 19 

0000854e <.Loc.1619.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    854e:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    8552:	48 a5 20 01 

00008556 <.Loc.1621.2>:
}
    8556:	a1 00 02 00 	adda	#2,	r1	;
    855a:	0a 16       	popm.a	#1,	r10	;20-bit words
    855c:	10 01       	reta			;

0000855e <.L210>:
    elyNLFreeBuffer(elyNLPack(buffer));
    855e:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008562 <.LVL182>:
    8562:	b0 13 42 c1 	calla	#49474		;0x0c142

00008566 <.LVL183>:
    8566:	80 00 48 85 	mova	#34120,	r0	;0x08548

0000856a <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    856a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000856c <.LCFI20>:
    856c:	26 14       	pushm.a	#3,	r6	;20-bit words

0000856e <.LCFI21>:
    856e:	b1 00 06 00 	suba	#6,	r1	;

00008572 <.LCFI22>:
    8572:	ca 0c       	mova	r12,	r10	;
    8574:	69 4d       	mov.b	@r13,	r9	;
    8576:	59 f3       	and.b	#1,	r9	;r3 As==01

00008578 <.Loc.1537.2>:
    8578:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    857c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8580:	01 00 

00008582 <.Loc.1538.2>:
  stored_buff = buffer; /* store for freeing */
    8582:	60 0a 96 d1 	mova	r10,	&53654	; 0x0d196

00008586 <.LVL187>:
    8586:	34 40 00 04 	mov	#1024,	r4	;#0x0400
    858a:	55 43       	mov.b	#1,	r5	;r3 As==01

0000858c <.LBB47>:
    chSysLock();
    858c:	86 00 94 7d 	mova	#32148,	r6	;0x07d94
    8590:	88 00 54 45 	mova	#17748,	r8	;0x04554

00008594 <.L216>:
    8594:	46 13       	calla	r6		;

00008596 <.LVL189>:
    8596:	48 13       	calla	r8		;

00008598 <.LVL190>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8598:	4d 43       	clr.b	r13		;
    859a:	cc 01       	mova	r1,	r12	;
    859c:	ac 00 02 00 	adda	#2,	r12	;
    85a0:	b0 13 10 be 	calla	#48656		;0x0be10

000085a4 <.LVL191>:
    chSysUnlock();
    85a4:	b0 13 7c 45 	calla	#17788		;0x0457c

000085a8 <.LVL192>:
    85a8:	b0 13 9c 7d 	calla	#32156		;0x07d9c

000085ac <.LVL193>:
    pages_sent++;
    85ac:	40 18 92 53 	incx.w	&0xd192		;
    85b0:	92 d1 

000085b2 <.Loc.1576.2>:
    req->address = FRAM_FW_BASE + (i * 128); 
    85b2:	3c 01 02 00 	mova	2(r1),	r12	;
    85b6:	8c 44 00 00 	mov	r4,	0(r12)	;
    85ba:	8c 45 02 00 	mov	r5,	2(r12)	;

000085be <.Loc.1577.2>:
    req->read = 0;
    85be:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    85c2:	6d c3       	bic.b	#2,	r13	;r3 As==10

000085c4 <.Loc.1578.2>:
    req->special = 1; /* write a constant value */
    85c4:	5d d3       	bis.b	#1,	r13	;r3 As==01
    85c6:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

000085ca <.Loc.1579.2>:
    req->size = 128;
    85ca:	1d 4c 04 00 	mov	4(r12),	r13	;
    85ce:	7d f0 03 00 	and.b	#3,	r13	;
    85d2:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    85d6:	8c 4d 04 00 	mov	r13,	4(r12)	;
    85da:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    85de:	06 00 

000085e0 <.Loc.1580.2>:
    req->buffer = &fill_value; 
    85e0:	00 18 fc 40 	movx.a	#53646,	8(r12)	;0x0d18e
    85e4:	8e d1 08 00 

000085e8 <.Loc.1581.2>:
    req->callback = cancel_fw_eeprom_cb;
    85e8:	00 18 fc 40 	movx.a	#32626,	12(r12)	;0x07f72, 0x0000c
    85ec:	72 7f 0c 00 

000085f0 <.Loc.1585.2>:
    elyFramPostRequest(req);
    85f0:	b0 13 d8 bd 	calla	#48600		;0x0bdd8

000085f4 <.LBB48>:
  return chSemWaitTimeout(&bsp->sem, time);
    85f4:	4d 43       	clr.b	r13		;
    85f6:	8c 00 94 d1 	mova	#53652,	r12	;0x0d194
    85fa:	b0 13 7c 4a 	calla	#19068		;0x04a7c

000085fe <.LVL195>:
    85fe:	34 50 80 00 	add	#128,	r4	;#0x0080
    8602:	05 63       	adc	r5		;

00008604 <.LBE48>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    8604:	04 93       	cmp	#0,	r4	;r3 As==00
    8606:	c6 23       	jnz	$-114    	;abs 0x8594
    8608:	25 93       	cmp	#2,	r5	;r3 As==10
    860a:	c4 23       	jnz	$-118    	;abs 0x8594

0000860c <.LBE47>:
  if (hdr.reply) {
    860c:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8610:	00 00 
    8612:	0c 24       	jz	$+26     	;abs 0x862c

00008614 <.Loc.1593.2>:
    gen_success(buffer, hdr.crc);
    8614:	4d 49       	mov.b	r9,	r13	;
    8616:	cc 0a       	mova	r10,	r12	;
    8618:	b0 13 b8 7d 	calla	#32184		;0x07db8

0000861c <.LVL196>:
    elyCmdSendReply(buffer);
    861c:	cc 0a       	mova	r10,	r12	;
    861e:	b0 13 5e 83 	calla	#33630		;0x0835e

00008622 <.L212>:
}
    8622:	a1 00 06 00 	adda	#6,	r1	;
    8626:	24 16       	popm.a	#3,	r6	;20-bit words
    8628:	28 16       	popm.a	#3,	r10	;20-bit words
    862a:	10 01       	reta			;

0000862c <.L214>:
    elyNLFreeBuffer(elyNLPack(stored_buff));
    862c:	2c 00 96 d1 	mova	&53654,	r12	;0x0d196
    8630:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008634 <.LVL198>:
    8634:	b0 13 42 c1 	calla	#49474		;0x0c142

00008638 <.LVL199>:
}
    8638:	80 00 22 86 	mova	#34338,	r0	;0x08622

0000863c <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    863c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000863e <.LCFI23>:
    863e:	b1 00 12 00 	suba	#18,	r1	;0x00012

00008642 <.LCFI24>:
    8642:	71 0c 08 00 	mova	r12,	8(r1)	;
    8646:	6b 4d       	mov.b	@r13,	r11	;
    8648:	5b f3       	and.b	#1,	r11	;r3 As==01

0000864a <.LVL201>:
    864a:	5a 4d 01 00 	mov.b	1(r13),	r10	;
    864e:	81 4a 04 00 	mov	r10,	4(r1)	;

00008652 <.LVL202>:
    8652:	c1 4a 0d 00 	mov.b	r10,	13(r1)	; 0x000d

00008656 <.Loc.1420.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8656:	68 4d       	mov.b	@r13,	r8	;
    8658:	58 c3       	bic.b	#1,	r8	;r3 As==01
    865a:	48 db       	bis.b	r11,	r8	;
    865c:	c1 48 0c 00 	mov.b	r8,	12(r1)	; 0x000c
    8660:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    8664:	46 48       	mov.b	r8,	r6	;
    8666:	66 f3       	and.b	#2,	r6	;r3 As==10
    8668:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    866c:	06 93       	cmp	#0,	r6	;r3 As==00
    866e:	37 20       	jnz	$+112    	;abs 0x86de
    8670:	69 43       	mov.b	#2,	r9	;r3 As==10

00008672 <.L218>:
    8672:	40 18 0a 49 	movx.w	r9,	r10	;
    8676:	00 18 5a 51 	addx.a	8(r1),	r10	;
    867a:	08 00 

0000867c <.Loc.1420.2>:
    867c:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

00008680 <.Loc.1421.2>:
  uint32_t address = 0;
    8680:	47 43       	clr.b	r7		;
    8682:	05 47       	mov	r7,	r5	;

00008684 <.L219>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    8684:	6c 4a       	mov.b	@r10,	r12	;
    8686:	0d 43       	clr	r13		;
    8688:	0e 44       	mov	r4,	r14	;
    868a:	0f 43       	clr	r15		;
    868c:	71 0b 00 00 	mova	r11,	0(r1)	;
    8690:	b0 13 48 cd 	calla	#52552		;0x0cd48
    8694:	0c d7       	bis	r7,	r12	;
    8696:	0d d5       	bis	r5,	r13	;
    8698:	07 4c       	mov	r12,	r7	;

0000869a <.LVL207>:
    869a:	05 4d       	mov	r13,	r5	;

0000869c <.LVL208>:
    869c:	aa 00 01 00 	adda	#1,	r10	;

000086a0 <.LVL209>:
    86a0:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

000086a4 <.Loc.1424.2>:
  for (int i = 0; i < 4; i++) {
    86a4:	0b 01       	mova	@r1,	r11	;
    86a6:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    86aa:	ec 23       	jnz	$-38     	;abs 0x8684

000086ac <.LBE50>:
  if (address < 0x4400 || address > 0x13FFF) {
    86ac:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    86b0:	04 4d       	mov	r13,	r4	;
    86b2:	34 63       	addc	#-1,	r4	;r3 As==11
    86b4:	04 93       	cmp	#0,	r4	;r3 As==00
    86b6:	04 20       	jnz	$+10     	;abs 0x86c0
    86b8:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    86bc:	0d 9c       	cmp	r12,	r13	;
    86be:	1e 2c       	jc	$+62     	;abs 0x86fc

000086c0 <.L230>:
    if (hdr.reply) {
    86c0:	06 93       	cmp	#0,	r6	;r3 As==00
    86c2:	10 24       	jz	$+34     	;abs 0x86e4

000086c4 <.Loc.1431.2>:
      gen_failure(buffer, hdr.crc);
    86c4:	4d 4b       	mov.b	r11,	r13	;
    86c6:	3c 01 08 00 	mova	8(r1),	r12	;
    86ca:	b0 13 f6 7d 	calla	#32246		;0x07df6

000086ce <.LVL210>:
      elyCmdSendReply(buffer);
    86ce:	3c 01 08 00 	mova	8(r1),	r12	;
    86d2:	b0 13 5e 83 	calla	#33630		;0x0835e

000086d6 <.L217>:
}
    86d6:	a1 00 12 00 	adda	#18,	r1	;0x00012
    86da:	64 16       	popm.a	#7,	r10	;20-bit words
    86dc:	10 01       	reta			;

000086de <.L227>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    86de:	69 42       	mov.b	#4,	r9	;r2 As==10
    86e0:	80 00 72 86 	mova	#34418,	r0	;0x08672

000086e4 <.L222>:
      elyErrorSignal(ErrCmdFailure);
    86e4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    86e8:	b0 13 98 c3 	calla	#50072		;0x0c398

000086ec <.LVL214>:
      elyNLFreeBuffer(elyNLPack(buffer));
    86ec:	3c 01 08 00 	mova	8(r1),	r12	;
    86f0:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000086f4 <.LVL215>:
    86f4:	b0 13 42 c1 	calla	#49474		;0x0c142

000086f8 <.LVL216>:
    86f8:	80 00 d6 86 	mova	#34518,	r0	;0x086d6

000086fc <.L232>:
  elyFramGetRequest(&req);
    86fc:	cc 01       	mova	r1,	r12	;
    86fe:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    8702:	b0 13 be bd 	calla	#48574		;0x0bdbe

00008706 <.LVL217>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    8706:	3c 01 0e 00 	mova	14(r1),	r12	;0x0000e
    870a:	37 50 00 c0 	add	#-16384,r7	;#0xc000

0000870e <.LVL218>:
    870e:	8c 47 00 00 	mov	r7,	0(r12)	;
    8712:	05 63       	adc	r5		;
    8714:	8c 45 02 00 	mov	r5,	2(r12)	;

00008718 <.Loc.1449.2>:
  req->read = 0;
    8718:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

0000871c <.Loc.1450.2>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    871c:	1a 41 04 00 	mov	4(r1),	r10	;

00008720 <.LVL220>:
    8720:	0a 86       	sub	r6,	r10	;
    8722:	40 18 18 b3 	bitx.w	#1,	r8	;r3 As==01
    8726:	01 24       	jz	$+4      	;abs 0x872a
    8728:	64 43       	mov.b	#2,	r4	;r3 As==10

0000872a <.L224>:
    872a:	0a 84       	sub	r4,	r10	;
    872c:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc
    8730:	4a 0e       	rlam.a	#4,	r10	;
    8732:	4a 0d       	rram.a	#4,	r10	;
    8734:	80 18 7a f0 	andx.a	#131071,r10	;0x1ffff
    8738:	ff ff 
    873a:	71 0a 04 00 	mova	r10,	4(r1)	;

0000873e <.LVL221>:
    873e:	0d 4a       	mov	r10,	r13	;
    8740:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8744:	1e 4c 04 00 	mov	4(r12),	r14	;
    8748:	7e f0 03 00 	and.b	#3,	r14	;
    874c:	0e dd       	bis	r13,	r14	;
    874e:	8c 4e 04 00 	mov	r14,	4(r12)	;

00008752 <.LVL222>:
    8752:	0f 4a       	mov	r10,	r15	;
    8754:	5f 03       	rrum	#1,	r15	;
    8756:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    875a:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    875e:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    8762:	3a 01 04 00 	mova	4(r1),	r10	;
    8766:	0a 14       	pushm.a	#1,	r10	;20-bit words
    8768:	0d 17       	popm	#1,	r13	;16-bit words
    876a:	0d 17       	popm	#1,	r13	;16-bit words
    876c:	5d f3       	and.b	#1,	r13	;r3 As==01
    876e:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8772:	4e df       	bis.b	r15,	r14	;
    8774:	4e dd       	bis.b	r13,	r14	;
    8776:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000877a <.Loc.1451.2>:
  lookbehind = hdr_ext+4;
    877a:	69 52       	add.b	#4,	r9	;r2 As==10

0000877c <.LVL223>:
  req->buffer = &buffer[lookbehind];
    877c:	40 18 0e 49 	movx.w	r9,	r14	;
    8780:	00 18 5e 51 	addx.a	8(r1),	r14	;
    8784:	08 00 
    8786:	7c 0e 08 00 	mova	r14,	8(r12)	;

0000878a <.Loc.1453.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    878a:	06 93       	cmp	#0,	r6	;r3 As==00
    878c:	08 20       	jnz	$+18     	;abs 0x879e

0000878e <.Loc.1453.2>:
    878e:	8e 00 b2 7e 	mova	#32434,	r14	;0x07eb2

00008792 <.L225>:
    8792:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

00008796 <.Loc.1457.2>:
  elyFramPostRequest(req);
    8796:	b0 13 d8 bd 	calla	#48600		;0x0bdd8

0000879a <.LVL224>:
    879a:	80 00 d6 86 	mova	#34518,	r0	;0x086d6

0000879e <.L229>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    879e:	8e 00 30 83 	mova	#33584,	r14	;0x08330
    87a2:	80 00 92 87 	mova	#34706,	r0	;0x08792

000087a6 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    87a6:	3a 14       	pushm.a	#4,	r10	;20-bit words

000087a8 <.LCFI25>:
    87a8:	b1 00 02 00 	suba	#2,	r1	;

000087ac <.LCFI26>:
    87ac:	ca 0c       	mova	r12,	r10	;

000087ae <.LVL226>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    87ae:	67 4d       	mov.b	@r13,	r7	;
    87b0:	57 f3       	and.b	#1,	r7	;r3 As==01
    87b2:	69 4d       	mov.b	@r13,	r9	;
    87b4:	69 f3       	and.b	#2,	r9	;r3 As==10
    87b6:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    87ba:	09 93       	cmp	#0,	r9	;r3 As==00
    87bc:	16 20       	jnz	$+46     	;abs 0x87ea
    87be:	68 43       	mov.b	#2,	r8	;r3 As==10

000087c0 <.L234>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    87c0:	40 18 08 48 	movx.w	r8,	r8	;
    87c4:	e8 0a       	adda	r10,	r8	;

000087c6 <.LVL228>:
    87c6:	6d 48       	mov.b	@r8,	r13	;

000087c8 <.LVL229>:
    87c8:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

000087cc <.LVL230>:
    87cc:	4c 9d       	cmp.b	r13,	r12	;
    87ce:	1b 2c       	jc	$+56     	;abs 0x8806

000087d0 <.Loc.1372.2>:
    if (hdr.reply) {
    87d0:	09 93       	cmp	#0,	r9	;r3 As==00
    87d2:	0e 24       	jz	$+30     	;abs 0x87f0

000087d4 <.Loc.1374.2>:
      gen_failure(buffer, hdr.crc);
    87d4:	4d 47       	mov.b	r7,	r13	;
    87d6:	cc 0a       	mova	r10,	r12	;
    87d8:	b0 13 f6 7d 	calla	#32246		;0x07df6

000087dc <.L240>:
    elyCmdSendReply(buffer);
    87dc:	cc 0a       	mova	r10,	r12	;
    87de:	b0 13 5e 83 	calla	#33630		;0x0835e

000087e2 <.L233>:
}
    87e2:	a1 00 02 00 	adda	#2,	r1	;
    87e6:	37 16       	popm.a	#4,	r10	;20-bit words
    87e8:	10 01       	reta			;

000087ea <.L239>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    87ea:	68 42       	mov.b	#4,	r8	;r2 As==10
    87ec:	80 00 c0 87 	mova	#34752,	r0	;0x087c0

000087f0 <.L236>:
      elyErrorSignal(ErrCmdFailure);
    87f0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    87f4:	b0 13 98 c3 	calla	#50072		;0x0c398

000087f8 <.L238>:
    elyNLFreeBuffer(elyNLPack(buffer));
    87f8:	cc 0a       	mova	r10,	r12	;
    87fa:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000087fe <.LVL236>:
    87fe:	b0 13 42 c1 	calla	#49474		;0x0c142

00008802 <.LVL237>:
    8802:	80 00 e2 87 	mova	#34786,	r0	;0x087e2

00008806 <.L235>:
  bank0w[RegErrLogLvl] = buffer[hdr_ext];
    8806:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    880a:	cc 4d 4d 00 	mov.b	r13,	77(r12)	; 0x004d

0000880e <.Loc.1387.2>:
  chSysLock();
    880e:	b0 13 94 7d 	calla	#32148		;0x07d94

00008812 <.LVL238>:
    8812:	b0 13 54 45 	calla	#17748		;0x04554

00008816 <.LVL239>:
  elyErrorSetLogLvlS(buffer[hdr_ext]);
    8816:	6c 48       	mov.b	@r8,	r12	;
    8818:	b0 13 ac c3 	calla	#50092		;0x0c3ac

0000881c <.LVL240>:
  chSysUnlock();
    881c:	b0 13 7c 45 	calla	#17788		;0x0457c

00008820 <.LVL241>:
    8820:	b0 13 9c 7d 	calla	#32156		;0x07d9c

00008824 <.LVL242>:
  if (hdr.reply) {
    8824:	09 93       	cmp	#0,	r9	;r3 As==00
    8826:	e8 27       	jz	$-46     	;abs 0x87f8

00008828 <.Loc.1393.2>:
    gen_success(buffer, hdr.crc);
    8828:	4d 47       	mov.b	r7,	r13	;
    882a:	cc 0a       	mova	r10,	r12	;
    882c:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008830 <.LVL243>:
    8830:	80 00 dc 87 	mova	#34780,	r0	;0x087dc

00008834 <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8834:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008836 <.LCFI27>:
    8836:	b1 00 02 00 	suba	#2,	r1	;

0000883a <.LCFI28>:
    883a:	ca 0c       	mova	r12,	r10	;

0000883c <.Loc.1345.2>:
    883c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8840:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8844:	01 00 

00008846 <.Loc.1347.2>:
  if (hdr.reply) {
    8846:	6d 41       	mov.b	@r1,	r13	;
    8848:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    884c:	23 24       	jz	$+72     	;abs 0x8894

0000884e <.Loc.1348.2>:
    buffer[0] = buffer[0] & 0x3F;
    884e:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8852:	00 00 

00008854 <.Loc.1349.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8854:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    8858:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    885c:	02 00 

0000885e <.Loc.1350.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    885e:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8862:	03 00 

00008864 <.Loc.1351.2>:
    buffer[4] = bank0p[RegErrLogLvl];
    8864:	dc 4e 4d 00 	mov.b	77(r14),4(r12)	;0x0004d
    8868:	04 00 

0000886a <.Loc.1352.2>:
    if (hdr.crc) {
    886a:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    886e:	0e 24       	jz	$+30     	;abs 0x888c

00008870 <.Loc.1353.2>:
      buffer[1] = 3;
    8870:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    8874:	01 00 

00008876 <.Loc.1354.2>:
      crcGenX25(buffer, 7);
    8876:	7d 40 07 00 	mov.b	#7,	r13	;
    887a:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000887e <.L244>:
    elyCmdSendReply(buffer);
    887e:	cc 0a       	mova	r10,	r12	;
    8880:	b0 13 5e 83 	calla	#33630		;0x0835e

00008884 <.L241>:
}
    8884:	a1 00 02 00 	adda	#2,	r1	;
    8888:	0a 16       	popm.a	#1,	r10	;20-bit words
    888a:	10 01       	reta			;

0000888c <.L243>:
      buffer[1] = 1;
    888c:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    8890:	80 00 7e 88 	mova	#34942,	r0	;0x0887e

00008894 <.L242>:
    8894:	b0 13 68 7f 	calla	#32616		;0x07f68

00008898 <.LVL247>:
}
    8898:	80 00 84 88 	mova	#34948,	r0	;0x08884

0000889c <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    889c:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000889e <.LCFI29>:
    889e:	b1 00 02 00 	suba	#2,	r1	;

000088a2 <.LCFI30>:
    88a2:	ca 0c       	mova	r12,	r10	;

000088a4 <.LVL249>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    88a4:	67 4d       	mov.b	@r13,	r7	;
    88a6:	57 f3       	and.b	#1,	r7	;r3 As==01
    88a8:	69 4d       	mov.b	@r13,	r9	;
    88aa:	69 f3       	and.b	#2,	r9	;r3 As==10
    88ac:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    88b0:	09 93       	cmp	#0,	r9	;r3 As==00
    88b2:	16 20       	jnz	$+46     	;abs 0x88e0
    88b4:	68 43       	mov.b	#2,	r8	;r3 As==10

000088b6 <.L247>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    88b6:	40 18 08 48 	movx.w	r8,	r8	;
    88ba:	e8 0a       	adda	r10,	r8	;

000088bc <.LVL251>:
    88bc:	6d 48       	mov.b	@r8,	r13	;

000088be <.LVL252>:
    88be:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

000088c2 <.LVL253>:
    88c2:	4c 9d       	cmp.b	r13,	r12	;
    88c4:	1b 2c       	jc	$+56     	;abs 0x88fc

000088c6 <.Loc.1314.2>:
    if (hdr.reply) {
    88c6:	09 93       	cmp	#0,	r9	;r3 As==00
    88c8:	0e 24       	jz	$+30     	;abs 0x88e6

000088ca <.Loc.1316.2>:
      gen_failure(buffer, hdr.crc);
    88ca:	4d 47       	mov.b	r7,	r13	;
    88cc:	cc 0a       	mova	r10,	r12	;
    88ce:	b0 13 f6 7d 	calla	#32246		;0x07df6

000088d2 <.L253>:
    elyCmdSendReply(buffer);
    88d2:	cc 0a       	mova	r10,	r12	;
    88d4:	b0 13 5e 83 	calla	#33630		;0x0835e

000088d8 <.L246>:
}
    88d8:	a1 00 02 00 	adda	#2,	r1	;
    88dc:	37 16       	popm.a	#4,	r10	;20-bit words
    88de:	10 01       	reta			;

000088e0 <.L252>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    88e0:	68 42       	mov.b	#4,	r8	;r2 As==10
    88e2:	80 00 b6 88 	mova	#34998,	r0	;0x088b6

000088e6 <.L249>:
      elyErrorSignal(ErrCmdFailure);
    88e6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    88ea:	b0 13 98 c3 	calla	#50072		;0x0c398

000088ee <.L251>:
    elyNLFreeBuffer(elyNLPack(buffer));
    88ee:	cc 0a       	mova	r10,	r12	;
    88f0:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000088f4 <.LVL259>:
    88f4:	b0 13 42 c1 	calla	#49474		;0x0c142

000088f8 <.LVL260>:
    88f8:	80 00 d8 88 	mova	#35032,	r0	;0x088d8

000088fc <.L248>:
  bank0w[RegErrRptLvl] = buffer[hdr_ext];
    88fc:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    8900:	cc 4d 4c 00 	mov.b	r13,	76(r12)	; 0x004c

00008904 <.Loc.1329.2>:
  chSysLock();
    8904:	b0 13 94 7d 	calla	#32148		;0x07d94

00008908 <.LVL261>:
    8908:	b0 13 54 45 	calla	#17748		;0x04554

0000890c <.LVL262>:
  elyErrorSetRptLvlS(buffer[hdr_ext]);
    890c:	6c 48       	mov.b	@r8,	r12	;
    890e:	b0 13 ae c3 	calla	#50094		;0x0c3ae

00008912 <.LVL263>:
  chSysUnlock();
    8912:	b0 13 7c 45 	calla	#17788		;0x0457c

00008916 <.LVL264>:
    8916:	b0 13 9c 7d 	calla	#32156		;0x07d9c

0000891a <.LVL265>:
  if (hdr.reply) {
    891a:	09 93       	cmp	#0,	r9	;r3 As==00
    891c:	e8 27       	jz	$-46     	;abs 0x88ee

0000891e <.Loc.1335.2>:
    gen_success(buffer, hdr.crc);
    891e:	4d 47       	mov.b	r7,	r13	;
    8920:	cc 0a       	mova	r10,	r12	;
    8922:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008926 <.LVL266>:
    8926:	80 00 d2 88 	mova	#35026,	r0	;0x088d2

0000892a <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    892a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000892c <.LCFI31>:
    892c:	b1 00 02 00 	suba	#2,	r1	;

00008930 <.LCFI32>:
    8930:	ca 0c       	mova	r12,	r10	;

00008932 <.Loc.1287.2>:
    8932:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8936:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    893a:	01 00 

0000893c <.Loc.1289.2>:
  if (hdr.reply) {
    893c:	6d 41       	mov.b	@r1,	r13	;
    893e:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    8942:	23 24       	jz	$+72     	;abs 0x898a

00008944 <.Loc.1290.2>:
    buffer[0] = buffer[0] & 0x3F;
    8944:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8948:	00 00 

0000894a <.Loc.1291.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    894a:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    894e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8952:	02 00 

00008954 <.Loc.1292.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8954:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8958:	03 00 

0000895a <.Loc.1293.2>:
    buffer[4] = bank0p[RegErrRptLvl];
    895a:	dc 4e 4c 00 	mov.b	76(r14),4(r12)	;0x0004c
    895e:	04 00 

00008960 <.Loc.1294.2>:
    if (hdr.crc) {
    8960:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    8964:	0e 24       	jz	$+30     	;abs 0x8982

00008966 <.Loc.1295.2>:
      buffer[1] = 3;
    8966:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    896a:	01 00 

0000896c <.Loc.1296.2>:
      crcGenX25(buffer, 7);
    896c:	7d 40 07 00 	mov.b	#7,	r13	;
    8970:	b0 13 64 ae 	calla	#44644		;0x0ae64

00008974 <.L257>:
    elyCmdSendReply(buffer);
    8974:	cc 0a       	mova	r10,	r12	;
    8976:	b0 13 5e 83 	calla	#33630		;0x0835e

0000897a <.L254>:
}
    897a:	a1 00 02 00 	adda	#2,	r1	;
    897e:	0a 16       	popm.a	#1,	r10	;20-bit words
    8980:	10 01       	reta			;

00008982 <.L256>:
      buffer[1] = 1;
    8982:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    8986:	80 00 74 89 	mova	#35188,	r0	;0x08974

0000898a <.L255>:
    898a:	b0 13 68 7f 	calla	#32616		;0x07f68

0000898e <.LVL270>:
}
    898e:	80 00 7a 89 	mova	#35194,	r0	;0x0897a

00008992 <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8992:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008994 <.LCFI33>:
    8994:	08 14       	pushm.a	#1,	r8	;20-bit words

00008996 <.LCFI34>:
    8996:	b1 00 02 00 	suba	#2,	r1	;

0000899a <.LCFI35>:
    899a:	ca 0c       	mova	r12,	r10	;

0000899c <.Loc.1264.2>:
    899c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    89a0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    89a4:	01 00 

000089a6 <.Loc.1266.2>:
  if (hdr.reply) {
    89a6:	6d 41       	mov.b	@r1,	r13	;
    89a8:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    89ac:	30 24       	jz	$+98     	;abs 0x8a0e

000089ae <.Loc.1267.2>:
    buffer[0] = buffer[0] & 0x3F;
    89ae:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    89b2:	00 00 

000089b4 <.Loc.1268.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    89b4:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

000089b8 <.LVL272>:
    89b8:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    89bc:	02 00 

000089be <.Loc.1269.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    89be:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    89c2:	03 00 

000089c4 <.Loc.1270.2>:
    buffer[1] += 2;
    89c4:	ea 53 01 00 	incd.b	1(r10)		;

000089c8 <.LVL273>:
    89c8:	ce 0c       	mova	r12,	r14	;
    89ca:	ae 00 76 00 	adda	#118,	r14	;0x00076
    89ce:	c8 0a       	mova	r10,	r8	;
    89d0:	a8 00 04 00 	adda	#4,	r8	;
    89d4:	ac 00 72 00 	adda	#114,	r12	;0x00072

000089d8 <.L261>:
      buffer[i + 4] = bank0p[RegMissionTimeMsb - i];
    89d8:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

000089dc <.LVL275>:
    89dc:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    89e0:	a8 00 01 00 	adda	#1,	r8	;

000089e4 <.LVL276>:
    for (int i = 0; i < 4; i++) {
    89e4:	de 0c       	cmpa	r12,	r14	;
    89e6:	f8 23       	jnz	$-14     	;abs 0x89d8

000089e8 <.LBE51>:
    if (hdr.crc) {
    89e8:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    89ec:	08 24       	jz	$+18     	;abs 0x89fe

000089ee <.Loc.1276.2>:
      crcGenX25(buffer, buffer[1]+4);
    89ee:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    89f2:	2d 52       	add	#4,	r13	;r2 As==10
    89f4:	40 18 0d 4d 	movx.w	r13,	r13	;
    89f8:	cc 0a       	mova	r10,	r12	;
    89fa:	b0 13 64 ae 	calla	#44644		;0x0ae64

000089fe <.L262>:
    elyCmdSendReply(buffer);
    89fe:	cc 0a       	mova	r10,	r12	;
    8a00:	b0 13 5e 83 	calla	#33630		;0x0835e

00008a04 <.L259>:
}
    8a04:	a1 00 02 00 	adda	#2,	r1	;
    8a08:	08 16       	popm.a	#1,	r8	;20-bit words
    8a0a:	0a 16       	popm.a	#1,	r10	;20-bit words
    8a0c:	10 01       	reta			;

00008a0e <.L260>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8a0e:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008a12 <.LVL279>:
    8a12:	b0 13 42 c1 	calla	#49474		;0x0c142

00008a16 <.LVL280>:
}
    8a16:	80 00 04 8a 	mova	#35332,	r0	;0x08a04

00008a1a <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a1a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008a1c <.LCFI36>:
    8a1c:	b1 00 02 00 	suba	#2,	r1	;

00008a20 <.LCFI37>:
    8a20:	ca 0c       	mova	r12,	r10	;

00008a22 <.Loc.1238.2>:
    8a22:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8a26:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8a2a:	01 00 

00008a2c <.Loc.1239.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a2c:	6f 41       	mov.b	@r1,	r15	;
    8a2e:	4d 4f       	mov.b	r15,	r13	;
    8a30:	6d f3       	and.b	#2,	r13	;r3 As==10
    8a32:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8a36:	0d 93       	cmp	#0,	r13	;r3 As==00
    8a38:	35 20       	jnz	$+108    	;abs 0x8aa4
    8a3a:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008a3c <.L269>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    8a3c:	2e 01 46 07 	mova	&67398,	r14	;0x10746
    8a40:	40 18 0c 4c 	movx.w	r12,	r12	;
    8a44:	ec 0a       	adda	r10,	r12	;

00008a46 <.LVL283>:
    8a46:	ee 4c 76 00 	mov.b	@r12,	118(r14); 0x0076

00008a4a <.Loc.1243.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    8a4a:	de 4c 01 00 	mov.b	1(r12),	117(r14); 0x0075
    8a4e:	75 00 

00008a50 <.Loc.1244.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    8a50:	de 4c 02 00 	mov.b	2(r12),	116(r14); 0x0074
    8a54:	74 00 

00008a56 <.Loc.1245.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    8a56:	de 4c 03 00 	mov.b	3(r12),	115(r14); 0x0073
    8a5a:	73 00 

00008a5c <.Loc.1247.2>:
  if (hdr.reply) {
    8a5c:	0d 93       	cmp	#0,	r13	;r3 As==00
    8a5e:	25 24       	jz	$+76     	;abs 0x8aaa

00008a60 <.Loc.1248.2>:
    buffer[0] = buffer[0] & 0x3F;
    8a60:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8a64:	00 00 

00008a66 <.Loc.1249.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8a66:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    8a6a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8a6e:	02 00 

00008a70 <.Loc.1250.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8a70:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8a74:	03 00 

00008a76 <.Loc.1251.2>:
    buffer[1] -= 2;
    8a76:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    8a7a:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    8a7e:	4d 4c       	mov.b	r12,	r13	;
    8a80:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00008a84 <.Loc.1252.2>:
    if (hdr.crc) {
    8a84:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    8a88:	06 24       	jz	$+14     	;abs 0x8a96

00008a8a <.Loc.1253.2>:
      crcGenX25(buffer, buffer[1]+4);
    8a8a:	2d 52       	add	#4,	r13	;r2 As==10
    8a8c:	4d 0e       	rlam.a	#4,	r13	;
    8a8e:	4d 0d       	rram.a	#4,	r13	;
    8a90:	cc 0a       	mova	r10,	r12	;
    8a92:	b0 13 64 ae 	calla	#44644		;0x0ae64

00008a96 <.L271>:
    elyCmdSendReply(buffer);
    8a96:	cc 0a       	mova	r10,	r12	;
    8a98:	b0 13 5e 83 	calla	#33630		;0x0835e

00008a9c <.L268>:
}
    8a9c:	a1 00 02 00 	adda	#2,	r1	;
    8aa0:	0a 16       	popm.a	#1,	r10	;20-bit words
    8aa2:	10 01       	reta			;

00008aa4 <.L273>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8aa4:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8aa6:	80 00 3c 8a 	mova	#35388,	r0	;0x08a3c

00008aaa <.L270>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8aaa:	cc 0a       	mova	r10,	r12	;
    8aac:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008ab0 <.LVL286>:
    8ab0:	b0 13 42 c1 	calla	#49474		;0x0c142

00008ab4 <.LVL287>:
}
    8ab4:	80 00 9c 8a 	mova	#35484,	r0	;0x08a9c

00008ab8 <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ab8:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008aba <.LCFI38>:
    8aba:	b1 00 02 00 	suba	#2,	r1	;

00008abe <.LCFI39>:
    8abe:	ca 0c       	mova	r12,	r10	;
    8ac0:	69 4d       	mov.b	@r13,	r9	;
    8ac2:	59 f3       	and.b	#1,	r9	;r3 As==01

00008ac4 <.Loc.1223.2>:
    8ac4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00008ac8 <.Loc.1225.2>:
  elyEventReset();
    8ac8:	b0 13 5a c4 	calla	#50266		;0x0c45a

00008acc <.LVL291>:
  if (hdr.reply) {
    8acc:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8ad0:	00 00 
    8ad2:	0b 24       	jz	$+24     	;abs 0x8aea

00008ad4 <.Loc.1229.2>:
    gen_success(buffer, hdr.crc);
    8ad4:	4d 49       	mov.b	r9,	r13	;
    8ad6:	cc 0a       	mova	r10,	r12	;
    8ad8:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008adc <.LVL292>:
    elyCmdSendReply(buffer);
    8adc:	cc 0a       	mova	r10,	r12	;
    8ade:	b0 13 5e 83 	calla	#33630		;0x0835e

00008ae2 <.L277>:
}
    8ae2:	a1 00 02 00 	adda	#2,	r1	;
    8ae6:	19 16       	popm.a	#2,	r10	;20-bit words
    8ae8:	10 01       	reta			;

00008aea <.L278>:
    8aea:	cc 0a       	mova	r10,	r12	;
    8aec:	b0 13 68 7f 	calla	#32616		;0x07f68

00008af0 <.LVL294>:
    8af0:	80 00 e2 8a 	mova	#35554,	r0	;0x08ae2

00008af4 <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8af4:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008af6 <.LCFI40>:
    8af6:	b1 00 02 00 	suba	#2,	r1	;

00008afa <.LCFI41>:
    8afa:	c8 0c       	mova	r12,	r8	;
    8afc:	69 4d       	mov.b	@r13,	r9	;
    8afe:	59 f3       	and.b	#1,	r9	;r3 As==01

00008b00 <.LVL296>:
    8b00:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008b04 <.LVL297>:
    8b04:	c1 45 01 00 	mov.b	r5,	1(r1)	;

00008b08 <.Loc.1187.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8b08:	6c 4d       	mov.b	@r13,	r12	;

00008b0a <.LVL299>:
    8b0a:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8b0c:	4c d9       	bis.b	r9,	r12	;
    8b0e:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8b12:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8b16:	1c b3       	bit	#1,	r12	;r3 As==01
    8b18:	1e 20       	jnz	$+62     	;abs 0x8b56
    8b1a:	4d 43       	clr.b	r13		;

00008b1c <.L281>:
    8b1c:	6c f3       	and.b	#2,	r12	;r3 As==10
    8b1e:	47 4c       	mov.b	r12,	r7	;
    8b20:	45 8c       	sub.b	r12,	r5	;

00008b22 <.LVL301>:
    8b22:	45 8d       	sub.b	r13,	r5	;
    8b24:	35 f0 ff 00 	and	#255,	r5	;#0x00ff

00008b28 <.LVL302>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8b28:	07 93       	cmp	#0,	r7	;r3 As==00
    8b2a:	18 20       	jnz	$+50     	;abs 0x8b5c

00008b2c <.Loc.1188.2>:
    8b2c:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008b2e <.L282>:
    8b2e:	40 18 04 4a 	movx.w	r10,	r4	;
    8b32:	e4 08       	adda	r8,	r4	;

00008b34 <.LBB52>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8b34:	cc 04       	mova	r4,	r12	;
    8b36:	0d 4a       	mov	r10,	r13	;
    8b38:	05 5a       	add	r10,	r5	;

00008b3a <.L283>:
    8b3a:	0d 95       	cmp	r5,	r13	;
    8b3c:	12 38       	jl	$+38     	;abs 0x8b62

00008b3e <.LBB53>:
    elyEventUnlog(buffer[i]);
    8b3e:	86 00 38 c4 	mova	#50232,	r6	;0x0c438

00008b42 <.L288>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8b42:	0a 95       	cmp	r5,	r10	;
    8b44:	30 38       	jl	$+98     	;abs 0x8ba6

00008b46 <.LBE53>:
  if (hdr.reply) {
    8b46:	07 93       	cmp	#0,	r7	;r3 As==00
    8b48:	24 24       	jz	$+74     	;abs 0x8b92

00008b4a <.Loc.1213.2>:
    gen_success(buffer, hdr.crc);
    8b4a:	4d 49       	mov.b	r9,	r13	;
    8b4c:	cc 08       	mova	r8,	r12	;
    8b4e:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008b52 <.LVL306>:
    8b52:	80 00 7c 8b 	mova	#35708,	r0	;0x08b7c

00008b56 <.L291>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8b56:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008b58 <.LVL308>:
    8b58:	80 00 1c 8b 	mova	#35612,	r0	;0x08b1c

00008b5c <.L292>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8b5c:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8b5e:	80 00 2e 8b 	mova	#35630,	r0	;0x08b2e

00008b62 <.L287>:
    8b62:	ac 00 01 00 	adda	#1,	r12	;

00008b66 <.LBB54>:
    if (buffer[i] < 0xC0) {
    8b66:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    8b6a:	5e 9c ff ff 	cmp.b	-1(r12),r14	;
    8b6e:	18 28       	jnc	$+50     	;abs 0x8ba0

00008b70 <.Loc.1193.2>:
      if (hdr.reply) {
    8b70:	07 93       	cmp	#0,	r7	;r3 As==00
    8b72:	0b 24       	jz	$+24     	;abs 0x8b8a

00008b74 <.Loc.1195.2>:
        gen_failure(buffer, hdr.crc);
    8b74:	4d 49       	mov.b	r9,	r13	;

00008b76 <.LVL311>:
    8b76:	cc 08       	mova	r8,	r12	;
    8b78:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008b7c <.L293>:
    elyCmdSendReply(buffer);
    8b7c:	cc 08       	mova	r8,	r12	;
    8b7e:	b0 13 5e 83 	calla	#33630		;0x0835e

00008b82 <.L280>:
}
    8b82:	a1 00 02 00 	adda	#2,	r1	;
    8b86:	64 16       	popm.a	#7,	r10	;20-bit words
    8b88:	10 01       	reta			;

00008b8a <.L285>:
        elyErrorSignal(ErrCmdFailure);
    8b8a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8b8e:	b0 13 98 c3 	calla	#50072		;0x0c398

00008b92 <.L290>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8b92:	cc 08       	mova	r8,	r12	;
    8b94:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008b98 <.LVL316>:
    8b98:	b0 13 42 c1 	calla	#49474		;0x0c142

00008b9c <.LVL317>:
    8b9c:	80 00 82 8b 	mova	#35714,	r0	;0x08b82

00008ba0 <.L284>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8ba0:	1d 53       	inc	r13		;
    8ba2:	80 00 3a 8b 	mova	#35642,	r0	;0x08b3a

00008ba6 <.L289>:
    elyEventUnlog(buffer[i]);
    8ba6:	6c 44       	mov.b	@r4,	r12	;
    8ba8:	46 13       	calla	r6		;

00008baa <.LVL321>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8baa:	1a 53       	inc	r10		;
    8bac:	a4 00 01 00 	adda	#1,	r4	;
    8bb0:	80 00 42 8b 	mova	#35650,	r0	;0x08b42

00008bb4 <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8bb4:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008bb6 <.LCFI42>:
    8bb6:	b1 00 02 00 	suba	#2,	r1	;

00008bba <.LCFI43>:
    8bba:	c8 0c       	mova	r12,	r8	;

00008bbc <.LVL324>:
    8bbc:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00008bc0 <.LVL325>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8bc0:	65 4d       	mov.b	@r13,	r5	;
    8bc2:	55 f3       	and.b	#1,	r5	;r3 As==01
    8bc4:	6c 4d       	mov.b	@r13,	r12	;

00008bc6 <.LVL326>:
    8bc6:	1c b3       	bit	#1,	r12	;r3 As==01
    8bc8:	1e 20       	jnz	$+62     	;abs 0x8c06
    8bca:	4d 43       	clr.b	r13		;

00008bcc <.L295>:
    8bcc:	6c f3       	and.b	#2,	r12	;r3 As==10

00008bce <.LVL328>:
    8bce:	47 4c       	mov.b	r12,	r7	;
    8bd0:	4a 8c       	sub.b	r12,	r10	;

00008bd2 <.LVL329>:
    8bd2:	4a 8d       	sub.b	r13,	r10	;
    8bd4:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00008bd8 <.LVL330>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8bd8:	07 93       	cmp	#0,	r7	;r3 As==00
    8bda:	18 20       	jnz	$+50     	;abs 0x8c0c

00008bdc <.Loc.1149.2>:
    8bdc:	69 43       	mov.b	#2,	r9	;r3 As==10

00008bde <.L296>:
    8bde:	40 18 04 49 	movx.w	r9,	r4	;
    8be2:	e4 08       	adda	r8,	r4	;

00008be4 <.LBB58>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8be4:	c6 04       	mova	r4,	r6	;
    8be6:	0d 49       	mov	r9,	r13	;
    8be8:	0a 59       	add	r9,	r10	;

00008bea <.L297>:
    8bea:	0d 9a       	cmp	r10,	r13	;
    8bec:	12 38       	jl	$+38     	;abs 0x8c12

00008bee <.LBB59>:
    elyEventLog(buffer[i]);
    8bee:	86 00 16 c4 	mova	#50198,	r6	;0x0c416

00008bf2 <.L303>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8bf2:	09 9a       	cmp	r10,	r9	;
    8bf4:	3d 38       	jl	$+124    	;abs 0x8c70

00008bf6 <.LBE59>:
  if (hdr.reply) {
    8bf6:	07 93       	cmp	#0,	r7	;r3 As==00
    8bf8:	31 24       	jz	$+100    	;abs 0x8c5c

00008bfa <.Loc.1176.2>:
    gen_success(buffer, hdr.crc);
    8bfa:	4d 45       	mov.b	r5,	r13	;
    8bfc:	cc 08       	mova	r8,	r12	;
    8bfe:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008c02 <.LVL334>:
    8c02:	80 00 46 8c 	mova	#35910,	r0	;0x08c46

00008c06 <.L306>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8c06:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008c08 <.LVL336>:
    8c08:	80 00 cc 8b 	mova	#35788,	r0	;0x08bcc

00008c0c <.L307>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8c0c:	69 42       	mov.b	#4,	r9	;r2 As==10
    8c0e:	80 00 de 8b 	mova	#35806,	r0	;0x08bde

00008c12 <.L302>:
    if ((buffer[i] < 0xC0) || 
    8c12:	6c 46       	mov.b	@r6,	r12	;
    8c14:	4e 4c       	mov.b	r12,	r14	;
    8c16:	7e 50 40 00 	add.b	#64,	r14	;#0x0040
    8c1a:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    8c1e:	4f 9e       	cmp.b	r14,	r15	;
    8c20:	0c 28       	jnc	$+26     	;abs 0x8c3a

00008c22 <.Loc.1153.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8c22:	7e 50 ed ff 	add.b	#-19,	r14	;#0xffed

00008c26 <.Loc.1152.2>:
    if ((buffer[i] < 0xC0) || 
    8c26:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    8c2a:	4f 9e       	cmp.b	r14,	r15	;
    8c2c:	06 2c       	jc	$+14     	;abs 0x8c3a
    8c2e:	a6 00 01 00 	adda	#1,	r6	;

00008c32 <.Loc.1154.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    8c32:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

00008c36 <.Loc.1153.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8c36:	4f 9c       	cmp.b	r12,	r15	;
    8c38:	18 28       	jnc	$+50     	;abs 0x8c6a

00008c3a <.L298>:
      if (hdr.reply) {
    8c3a:	07 93       	cmp	#0,	r7	;r3 As==00
    8c3c:	0b 24       	jz	$+24     	;abs 0x8c54

00008c3e <.Loc.1158.2>:
        gen_failure(buffer, hdr.crc);
    8c3e:	4d 45       	mov.b	r5,	r13	;

00008c40 <.LVL339>:
    8c40:	cc 08       	mova	r8,	r12	;
    8c42:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008c46 <.L308>:
    elyCmdSendReply(buffer);
    8c46:	cc 08       	mova	r8,	r12	;
    8c48:	b0 13 5e 83 	calla	#33630		;0x0835e

00008c4c <.L294>:
}
    8c4c:	a1 00 02 00 	adda	#2,	r1	;
    8c50:	64 16       	popm.a	#7,	r10	;20-bit words
    8c52:	10 01       	reta			;

00008c54 <.L300>:
        elyErrorSignal(ErrCmdFailure);
    8c54:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8c58:	b0 13 98 c3 	calla	#50072		;0x0c398

00008c5c <.L305>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8c5c:	cc 08       	mova	r8,	r12	;
    8c5e:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008c62 <.LVL344>:
    8c62:	b0 13 42 c1 	calla	#49474		;0x0c142

00008c66 <.LVL345>:
    8c66:	80 00 4c 8c 	mova	#35916,	r0	;0x08c4c

00008c6a <.L299>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8c6a:	1d 53       	inc	r13		;
    8c6c:	80 00 ea 8b 	mova	#35818,	r0	;0x08bea

00008c70 <.L304>:
    elyEventLog(buffer[i]);
    8c70:	6c 44       	mov.b	@r4,	r12	;
    8c72:	46 13       	calla	r6		;

00008c74 <.LVL349>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8c74:	19 53       	inc	r9		;
    8c76:	a4 00 01 00 	adda	#1,	r4	;
    8c7a:	80 00 f2 8b 	mova	#35826,	r0	;0x08bf2

00008c7e <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8c7e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008c80 <.LCFI44>:
    8c80:	b1 00 02 00 	suba	#2,	r1	;

00008c84 <.LCFI45>:
    8c84:	c8 0c       	mova	r12,	r8	;
    8c86:	69 4d       	mov.b	@r13,	r9	;
    8c88:	59 f3       	and.b	#1,	r9	;r3 As==01

00008c8a <.LVL352>:
    8c8a:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008c8e <.LVL353>:
    8c8e:	c1 45 01 00 	mov.b	r5,	1(r1)	;

00008c92 <.Loc.1112.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8c92:	6c 4d       	mov.b	@r13,	r12	;

00008c94 <.LVL355>:
    8c94:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8c96:	4c d9       	bis.b	r9,	r12	;
    8c98:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8c9c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ca0:	1c b3       	bit	#1,	r12	;r3 As==01
    8ca2:	1e 20       	jnz	$+62     	;abs 0x8ce0
    8ca4:	4d 43       	clr.b	r13		;

00008ca6 <.L310>:
    8ca6:	6c f3       	and.b	#2,	r12	;r3 As==10
    8ca8:	47 4c       	mov.b	r12,	r7	;
    8caa:	45 8c       	sub.b	r12,	r5	;

00008cac <.LVL357>:
    8cac:	45 8d       	sub.b	r13,	r5	;
    8cae:	35 f0 ff 00 	and	#255,	r5	;#0x00ff

00008cb2 <.LVL358>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8cb2:	07 93       	cmp	#0,	r7	;r3 As==00
    8cb4:	18 20       	jnz	$+50     	;abs 0x8ce6

00008cb6 <.Loc.1113.2>:
    8cb6:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008cb8 <.L311>:
    8cb8:	40 18 04 4a 	movx.w	r10,	r4	;
    8cbc:	e4 08       	adda	r8,	r4	;

00008cbe <.LBB64>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8cbe:	cc 04       	mova	r4,	r12	;
    8cc0:	0d 4a       	mov	r10,	r13	;
    8cc2:	05 5a       	add	r10,	r5	;

00008cc4 <.L312>:
    8cc4:	0d 95       	cmp	r5,	r13	;
    8cc6:	12 38       	jl	$+38     	;abs 0x8cec

00008cc8 <.LBB65>:
    elyEventUnsubscribe(buffer[i]);
    8cc8:	86 00 f4 c3 	mova	#50164,	r6	;0x0c3f4

00008ccc <.L317>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8ccc:	0a 95       	cmp	r5,	r10	;
    8cce:	30 38       	jl	$+98     	;abs 0x8d30

00008cd0 <.LBE65>:
  if (hdr.reply) {
    8cd0:	07 93       	cmp	#0,	r7	;r3 As==00
    8cd2:	24 24       	jz	$+74     	;abs 0x8d1c

00008cd4 <.Loc.1137.2>:
    gen_success(buffer, hdr.crc);
    8cd4:	4d 49       	mov.b	r9,	r13	;
    8cd6:	cc 08       	mova	r8,	r12	;
    8cd8:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008cdc <.LVL362>:
    8cdc:	80 00 06 8d 	mova	#36102,	r0	;0x08d06

00008ce0 <.L320>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8ce0:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008ce2 <.LVL364>:
    8ce2:	80 00 a6 8c 	mova	#36006,	r0	;0x08ca6

00008ce6 <.L321>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8ce6:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8ce8:	80 00 b8 8c 	mova	#36024,	r0	;0x08cb8

00008cec <.L316>:
    8cec:	ac 00 01 00 	adda	#1,	r12	;

00008cf0 <.LBB66>:
    if (buffer[i] < 0xC0) {
    8cf0:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    8cf4:	5e 9c ff ff 	cmp.b	-1(r12),r14	;
    8cf8:	18 28       	jnc	$+50     	;abs 0x8d2a

00008cfa <.Loc.1117.2>:
      if (hdr.reply) {
    8cfa:	07 93       	cmp	#0,	r7	;r3 As==00
    8cfc:	0b 24       	jz	$+24     	;abs 0x8d14

00008cfe <.Loc.1119.2>:
        gen_failure(buffer, hdr.crc);
    8cfe:	4d 49       	mov.b	r9,	r13	;

00008d00 <.LVL367>:
    8d00:	cc 08       	mova	r8,	r12	;
    8d02:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008d06 <.L322>:
    elyCmdSendReply(buffer);
    8d06:	cc 08       	mova	r8,	r12	;
    8d08:	b0 13 5e 83 	calla	#33630		;0x0835e

00008d0c <.L309>:
}
    8d0c:	a1 00 02 00 	adda	#2,	r1	;
    8d10:	64 16       	popm.a	#7,	r10	;20-bit words
    8d12:	10 01       	reta			;

00008d14 <.L314>:
        elyErrorSignal(ErrCmdFailure);
    8d14:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8d18:	b0 13 98 c3 	calla	#50072		;0x0c398

00008d1c <.L319>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8d1c:	cc 08       	mova	r8,	r12	;
    8d1e:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008d22 <.LVL372>:
    8d22:	b0 13 42 c1 	calla	#49474		;0x0c142

00008d26 <.LVL373>:
    8d26:	80 00 0c 8d 	mova	#36108,	r0	;0x08d0c

00008d2a <.L313>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8d2a:	1d 53       	inc	r13		;
    8d2c:	80 00 c4 8c 	mova	#36036,	r0	;0x08cc4

00008d30 <.L318>:
    elyEventUnsubscribe(buffer[i]);
    8d30:	6c 44       	mov.b	@r4,	r12	;
    8d32:	46 13       	calla	r6		;

00008d34 <.LVL377>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8d34:	1a 53       	inc	r10		;
    8d36:	a4 00 01 00 	adda	#1,	r4	;
    8d3a:	80 00 cc 8c 	mova	#36044,	r0	;0x08ccc

00008d3e <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8d3e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008d40 <.LCFI46>:
    8d40:	b1 00 02 00 	suba	#2,	r1	;

00008d44 <.LCFI47>:
    8d44:	c8 0c       	mova	r12,	r8	;
    8d46:	65 4d       	mov.b	@r13,	r5	;
    8d48:	55 f3       	and.b	#1,	r5	;r3 As==01

00008d4a <.LVL380>:
    8d4a:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00008d4e <.LVL381>:
    8d4e:	c1 4a 01 00 	mov.b	r10,	1(r1)	;

00008d52 <.Loc.1064.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8d52:	6c 4d       	mov.b	@r13,	r12	;

00008d54 <.LVL383>:
    8d54:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8d56:	4c d5       	bis.b	r5,	r12	;
    8d58:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8d5c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d60:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8d64:	25 24       	jz	$+76     	;abs 0x8db0
    8d66:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008d68 <.L324>:
    8d68:	6c f3       	and.b	#2,	r12	;r3 As==10
    8d6a:	47 4c       	mov.b	r12,	r7	;
    8d6c:	4a 8c       	sub.b	r12,	r10	;

00008d6e <.LVL385>:
    8d6e:	4a 8d       	sub.b	r13,	r10	;
    8d70:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00008d74 <.LVL386>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8d74:	07 93       	cmp	#0,	r7	;r3 As==00
    8d76:	1f 24       	jz	$+64     	;abs 0x8db6

00008d78 <.Loc.1065.2>:
    8d78:	69 42       	mov.b	#4,	r9	;r2 As==10

00008d7a <.L325>:
    8d7a:	40 18 06 49 	movx.w	r9,	r6	;
    8d7e:	e6 08       	adda	r8,	r6	;

00008d80 <.LBB70>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8d80:	cc 06       	mova	r6,	r12	;
    8d82:	0e 49       	mov	r9,	r14	;
    8d84:	0a 59       	add	r9,	r10	;

00008d86 <.L326>:
    8d86:	0e 9a       	cmp	r10,	r14	;
    8d88:	19 38       	jl	$+52     	;abs 0x8dbc

00008d8a <.LBE70>:
  if (hdr.reply) {
    8d8a:	07 93       	cmp	#0,	r7	;r3 As==00
    8d8c:	46 24       	jz	$+142    	;abs 0x8e1a

00008d8e <.Loc.1088.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    8d8e:	54 48 02 00 	mov.b	2(r8),	r4	;
    8d92:	47 18 04 54 	rpt #8 { rlax.w	r4		;
    8d96:	5c 48 03 00 	mov.b	3(r8),	r12	;

00008d9a <.L339>:
    8d9a:	04 dc       	bis	r12,	r4	;

00008d9c <.L334>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8d9c:	09 9a       	cmp	r10,	r9	;
    8d9e:	47 38       	jl	$+144    	;abs 0x8e2e

00008da0 <.LBE71>:
  if (hdr.reply) {
    8da0:	07 93       	cmp	#0,	r7	;r3 As==00
    8da2:	31 24       	jz	$+100    	;abs 0x8e06

00008da4 <.Loc.1101.2>:
    gen_success(buffer, hdr.crc);
    8da4:	4d 45       	mov.b	r5,	r13	;
    8da6:	cc 08       	mova	r8,	r12	;
    8da8:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008dac <.LVL390>:
    8dac:	80 00 f0 8d 	mova	#36336,	r0	;0x08df0

00008db0 <.L337>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8db0:	4d 43       	clr.b	r13		;

00008db2 <.LVL392>:
    8db2:	80 00 68 8d 	mova	#36200,	r0	;0x08d68

00008db6 <.L338>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8db6:	69 43       	mov.b	#2,	r9	;r3 As==10
    8db8:	80 00 7a 8d 	mova	#36218,	r0	;0x08d7a

00008dbc <.L331>:
    if ((buffer[i] < 0xC0) || 
    8dbc:	6d 4c       	mov.b	@r12,	r13	;
    8dbe:	4f 4d       	mov.b	r13,	r15	;
    8dc0:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    8dc4:	74 40 32 00 	mov.b	#50,	r4	;#0x0032
    8dc8:	44 9f       	cmp.b	r15,	r4	;
    8dca:	0c 28       	jnc	$+26     	;abs 0x8de4

00008dcc <.Loc.1069.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8dcc:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00008dd0 <.Loc.1068.2>:
    if ((buffer[i] < 0xC0) || 
    8dd0:	74 40 0c 00 	mov.b	#12,	r4	;#0x000c
    8dd4:	44 9f       	cmp.b	r15,	r4	;
    8dd6:	06 2c       	jc	$+14     	;abs 0x8de4
    8dd8:	ac 00 01 00 	adda	#1,	r12	;

00008ddc <.Loc.1070.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    8ddc:	7d 50 1d 00 	add.b	#29,	r13	;#0x001d

00008de0 <.Loc.1069.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8de0:	44 9d       	cmp.b	r13,	r4	;
    8de2:	18 28       	jnc	$+50     	;abs 0x8e14

00008de4 <.L327>:
      if (hdr.reply) {
    8de4:	07 93       	cmp	#0,	r7	;r3 As==00
    8de6:	0b 24       	jz	$+24     	;abs 0x8dfe

00008de8 <.Loc.1074.2>:
        gen_failure(buffer, hdr.crc);
    8de8:	4d 45       	mov.b	r5,	r13	;
    8dea:	cc 08       	mova	r8,	r12	;
    8dec:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008df0 <.L340>:
    elyCmdSendReply(buffer);
    8df0:	cc 08       	mova	r8,	r12	;
    8df2:	b0 13 5e 83 	calla	#33630		;0x0835e

00008df6 <.L323>:
}
    8df6:	a1 00 02 00 	adda	#2,	r1	;
    8dfa:	64 16       	popm.a	#7,	r10	;20-bit words
    8dfc:	10 01       	reta			;

00008dfe <.L329>:
        elyErrorSignal(ErrCmdFailure);
    8dfe:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8e02:	b0 13 98 c3 	calla	#50072		;0x0c398

00008e06 <.L336>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8e06:	cc 08       	mova	r8,	r12	;
    8e08:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008e0c <.LVL399>:
    8e0c:	b0 13 42 c1 	calla	#49474		;0x0c142

00008e10 <.LVL400>:
    8e10:	80 00 f6 8d 	mova	#36342,	r0	;0x08df6

00008e14 <.L328>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8e14:	1e 53       	inc	r14		;
    8e16:	80 00 86 8d 	mova	#36230,	r0	;0x08d86

00008e1a <.L332>:
    8e1a:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    8e1e:	54 4c 55 00 	mov.b	85(r12),r4	;0x00055
    8e22:	47 18 04 54 	rpt #8 { rlax.w	r4		;
    8e26:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    8e2a:	80 00 9a 8d 	mova	#36250,	r0	;0x08d9a

00008e2e <.L335>:
      elyEventSubscribe(buffer[i], addr);
    8e2e:	0d 44       	mov	r4,	r13	;
    8e30:	6c 46       	mov.b	@r6,	r12	;
    8e32:	b0 13 d2 c3 	calla	#50130		;0x0c3d2

00008e36 <.LVL404>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8e36:	19 53       	inc	r9		;
    8e38:	a6 00 01 00 	adda	#1,	r6	;
    8e3c:	80 00 9c 8d 	mova	#36252,	r0	;0x08d9c

00008e40 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8e40:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008e42 <.LCFI48>:
    8e42:	b1 00 02 00 	suba	#2,	r1	;

00008e46 <.LCFI49>:
    8e46:	ca 0c       	mova	r12,	r10	;
    8e48:	69 4d       	mov.b	@r13,	r9	;
    8e4a:	59 f3       	and.b	#1,	r9	;r3 As==01

00008e4c <.Loc.1048.2>:
    8e4c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00008e50 <.Loc.1050.2>:
  elyChanReset();
    8e50:	b0 13 ce c5 	calla	#50638		;0x0c5ce

00008e54 <.LVL409>:
  if (hdr.reply) {
    8e54:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8e58:	00 00 
    8e5a:	0b 24       	jz	$+24     	;abs 0x8e72

00008e5c <.Loc.1054.2>:
    gen_success(buffer, hdr.crc);
    8e5c:	4d 49       	mov.b	r9,	r13	;
    8e5e:	cc 0a       	mova	r10,	r12	;
    8e60:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008e64 <.LVL410>:
    elyCmdSendReply(buffer);
    8e64:	cc 0a       	mova	r10,	r12	;
    8e66:	b0 13 5e 83 	calla	#33630		;0x0835e

00008e6a <.L341>:
}
    8e6a:	a1 00 02 00 	adda	#2,	r1	;
    8e6e:	19 16       	popm.a	#2,	r10	;20-bit words
    8e70:	10 01       	reta			;

00008e72 <.L342>:
    8e72:	cc 0a       	mova	r10,	r12	;
    8e74:	b0 13 68 7f 	calla	#32616		;0x07f68

00008e78 <.LVL412>:
    8e78:	80 00 6a 8e 	mova	#36458,	r0	;0x08e6a

00008e7c <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8e7c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008e7e <.LCFI50>:
    8e7e:	b1 00 02 00 	suba	#2,	r1	;

00008e82 <.LCFI51>:
    8e82:	ca 0c       	mova	r12,	r10	;
    8e84:	ce 0d       	mova	r13,	r14	;
    8e86:	6d 4d       	mov.b	@r13,	r13	;
    8e88:	5d f3       	and.b	#1,	r13	;r3 As==01

00008e8a <.LVL414>:
    8e8a:	d1 4e 01 00 	mov.b	1(r14),	1(r1)	;
    8e8e:	01 00 

00008e90 <.Loc.1014.2>:
  if (hdr.reply) {
    8e90:	69 4e       	mov.b	@r14,	r9	;
    8e92:	59 c3       	bic.b	#1,	r9	;r3 As==01
    8e94:	49 dd       	bis.b	r13,	r9	;
    8e96:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    8e9a:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8e9e:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    8ea2:	49 24       	jz	$+148    	;abs 0x8f36

00008ea4 <.LBB76>:
    if ((buffer[4] < 0x40) || 
    8ea4:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008ea8 <.LVL416>:
    8ea8:	4e 4c       	mov.b	r12,	r14	;
    8eaa:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    8eae:	88 00 5e 83 	mova	#33630,	r8	;0x0835e
    8eb2:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    8eb6:	4f 9e       	cmp.b	r14,	r15	;
    8eb8:	0c 28       	jnc	$+26     	;abs 0x8ed2

00008eba <.Loc.1016.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8eba:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

00008ebe <.Loc.1015.2>:
    if ((buffer[4] < 0x40) || 
    8ebe:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    8ec2:	4f 9e       	cmp.b	r14,	r15	;
    8ec4:	06 2c       	jc	$+14     	;abs 0x8ed2

00008ec6 <.Loc.1017.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    8ec6:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

00008eca <.Loc.1016.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8eca:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    8ece:	4e 9c       	cmp.b	r12,	r14	;
    8ed0:	09 28       	jnc	$+20     	;abs 0x8ee4

00008ed2 <.L346>:
        gen_failure(buffer, hdr.crc);
    8ed2:	cc 0a       	mova	r10,	r12	;
    8ed4:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008ed8 <.L350>:
    elyCmdSendReply(buffer);
    8ed8:	cc 0a       	mova	r10,	r12	;
    8eda:	48 13       	calla	r8		;

00008edc <.L344>:
}
    8edc:	a1 00 02 00 	adda	#2,	r1	;
    8ee0:	28 16       	popm.a	#3,	r10	;20-bit words
    8ee2:	10 01       	reta			;

00008ee4 <.L347>:
    buffer[0] = buffer[0] & 0x3F;
    8ee4:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8ee8:	00 00 

00008eea <.Loc.1026.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8eea:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    8eee:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8ef2:	02 00 

00008ef4 <.Loc.1027.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8ef4:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8ef8:	03 00 

00008efa <.Loc.1030.2>:
    size_t n = elyChanGetValue(&buffer[4]);
    8efa:	cc 0a       	mova	r10,	r12	;
    8efc:	ac 00 04 00 	adda	#4,	r12	;
    8f00:	b0 13 c6 c5 	calla	#50630		;0x0c5c6

00008f04 <.LVL420>:
    8f04:	0c 14       	pushm.a	#1,	r12	;20-bit words
    8f06:	40 18 3e 41 	popx.w	r14		;
    8f0a:	40 18 3f 41 	popx.w	r15		;

00008f0e <.Loc.1032.2>:
    if (hdr.crc) {
    8f0e:	40 18 19 b3 	bitx.w	#1,	r9	;r3 As==01
    8f12:	0c 24       	jz	$+26     	;abs 0x8f2c

00008f14 <.Loc.1033.2>:
      buffer[1] = n + 3;
    8f14:	7e 50 03 00 	add.b	#3,	r14	;
    8f18:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

00008f1c <.Loc.1034.2>:
      crcGenX25(buffer, 7+n);
    8f1c:	cd 0c       	mova	r12,	r13	;
    8f1e:	ad 00 07 00 	adda	#7,	r13	;
    8f22:	cc 0a       	mova	r10,	r12	;

00008f24 <.LVL421>:
    8f24:	b0 13 64 ae 	calla	#44644		;0x0ae64

00008f28 <.LVL422>:
    8f28:	80 00 d8 8e 	mova	#36568,	r0	;0x08ed8

00008f2c <.L349>:
      buffer[1] = n + 1;
    8f2c:	5e 53       	inc.b	r14		;
    8f2e:	ca 4e 01 00 	mov.b	r14,	1(r10)	;
    8f32:	80 00 d8 8e 	mova	#36568,	r0	;0x08ed8

00008f36 <.L345>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8f36:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008f3a <.LVL425>:
    8f3a:	b0 13 42 c1 	calla	#49474		;0x0c142

00008f3e <.LVL426>:
    8f3e:	80 00 dc 8e 	mova	#36572,	r0	;0x08edc

00008f42 <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8f42:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008f44 <.LCFI52>:
    8f44:	b1 00 02 00 	suba	#2,	r1	;

00008f48 <.LCFI53>:
    8f48:	ca 0c       	mova	r12,	r10	;

00008f4a <.LVL428>:
    8f4a:	5f 4d 01 00 	mov.b	1(r13),	r15	;

00008f4e <.LVL429>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8f4e:	68 4d       	mov.b	@r13,	r8	;
    8f50:	58 f3       	and.b	#1,	r8	;r3 As==01
    8f52:	6e 4d       	mov.b	@r13,	r14	;
    8f54:	06 4e       	mov	r14,	r6	;
    8f56:	56 f3       	and.b	#1,	r6	;r3 As==01
    8f58:	06 93       	cmp	#0,	r6	;r3 As==00
    8f5a:	23 20       	jnz	$+72     	;abs 0x8fa2
    8f5c:	07 46       	mov	r6,	r7	;

00008f5e <.L352>:
    8f5e:	6e f3       	and.b	#2,	r14	;r3 As==10
    8f60:	49 4e       	mov.b	r14,	r9	;

00008f62 <.LVL430>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8f62:	09 93       	cmp	#0,	r9	;r3 As==00
    8f64:	21 20       	jnz	$+68     	;abs 0x8fa8

00008f66 <.Loc.980.2>:
    8f66:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008f68 <.L353>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8f68:	0b 4c       	mov	r12,	r11	;

00008f6a <.LVL432>:
    8f6a:	0d 4f       	mov	r15,	r13	;

00008f6c <.LVL433>:
    8f6c:	0d 5c       	add	r12,	r13	;
    8f6e:	06 93       	cmp	#0,	r6	;r3 As==00
    8f70:	01 24       	jz	$+4      	;abs 0x8f74
    8f72:	66 43       	mov.b	#2,	r6	;r3 As==10

00008f74 <.L355>:
    8f74:	0d 86       	sub	r6,	r13	;
    8f76:	40 18 04 4c 	movx.w	r12,	r4	;
    8f7a:	e4 0a       	adda	r10,	r4	;
    8f7c:	cc 04       	mova	r4,	r12	;

00008f7e <.L356>:
    8f7e:	0b 9d       	cmp	r13,	r11	;
    8f80:	16 38       	jl	$+46     	;abs 0x8fae

00008f82 <.LBE78>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8f82:	40 18 4d 4f 	movx.b	r15,	r13	;
    8f86:	40 18 4d 8e 	subx.b	r14,	r13	;

00008f8a <.Loc.998.2>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    8f8a:	4d 87       	sub.b	r7,	r13	;
    8f8c:	cc 04       	mova	r4,	r12	;
    8f8e:	b0 13 76 c5 	calla	#50550		;0x0c576

00008f92 <.LVL435>:
  if (hdr.reply) {
    8f92:	09 93       	cmp	#0,	r9	;r3 As==00
    8f94:	26 24       	jz	$+78     	;abs 0x8fe2

00008f96 <.Loc.1002.2>:
    gen_success(buffer, hdr.crc);
    8f96:	4d 48       	mov.b	r8,	r13	;
    8f98:	cc 0a       	mova	r10,	r12	;
    8f9a:	b0 13 b8 7d 	calla	#32184		;0x07db8

00008f9e <.LVL436>:
    8f9e:	80 00 cc 8f 	mova	#36812,	r0	;0x08fcc

00008fa2 <.L362>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8fa2:	67 43       	mov.b	#2,	r7	;r3 As==10
    8fa4:	80 00 5e 8f 	mova	#36702,	r0	;0x08f5e

00008fa8 <.L363>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8fa8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8faa:	80 00 68 8f 	mova	#36712,	r0	;0x08f68

00008fae <.L360>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    8fae:	66 4c       	mov.b	@r12,	r6	;
    8fb0:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    8fb4:	ac 00 01 00 	adda	#1,	r12	;
    8fb8:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    8fbc:	45 96       	cmp.b	r6,	r5	;
    8fbe:	18 2c       	jc	$+50     	;abs 0x8ff0

00008fc0 <.Loc.984.2>:
      if (hdr.reply) {
    8fc0:	09 93       	cmp	#0,	r9	;r3 As==00
    8fc2:	0b 24       	jz	$+24     	;abs 0x8fda

00008fc4 <.Loc.986.2>:
        gen_failure(buffer, hdr.crc);
    8fc4:	4d 48       	mov.b	r8,	r13	;
    8fc6:	cc 0a       	mova	r10,	r12	;
    8fc8:	b0 13 f6 7d 	calla	#32246		;0x07df6

00008fcc <.L364>:
    elyCmdSendReply(buffer);
    8fcc:	cc 0a       	mova	r10,	r12	;
    8fce:	b0 13 5e 83 	calla	#33630		;0x0835e

00008fd2 <.L351>:
}
    8fd2:	a1 00 02 00 	adda	#2,	r1	;
    8fd6:	64 16       	popm.a	#7,	r10	;20-bit words
    8fd8:	10 01       	reta			;

00008fda <.L358>:
        elyErrorSignal(ErrCmdFailure);
    8fda:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8fde:	b0 13 98 c3 	calla	#50072		;0x0c398

00008fe2 <.L361>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8fe2:	cc 0a       	mova	r10,	r12	;
    8fe4:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00008fe8 <.LVL444>:
    8fe8:	b0 13 42 c1 	calla	#49474		;0x0c142

00008fec <.LVL445>:
    8fec:	80 00 d2 8f 	mova	#36818,	r0	;0x08fd2

00008ff0 <.L357>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8ff0:	1b 53       	inc	r11		;
    8ff2:	80 00 7e 8f 	mova	#36734,	r0	;0x08f7e

00008ff6 <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ff6:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008ff8 <.LCFI54>:
    8ff8:	b1 00 10 00 	suba	#16,	r1	;0x00010

00008ffc <.LCFI55>:
    8ffc:	ca 0c       	mova	r12,	r10	;

00008ffe <.LVL449>:
    8ffe:	55 4d 01 00 	mov.b	1(r13),	r5	;

00009002 <.LVL450>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    9002:	68 4d       	mov.b	@r13,	r8	;
    9004:	58 f3       	and.b	#1,	r8	;r3 As==01
    9006:	6c 4d       	mov.b	@r13,	r12	;

00009008 <.LVL451>:
    9008:	1c b3       	bit	#1,	r12	;r3 As==01
    900a:	5f 20       	jnz	$+192    	;abs 0x90ca
    900c:	4d 43       	clr.b	r13		;

0000900e <.L366>:
    900e:	6c f3       	and.b	#2,	r12	;r3 As==10

00009010 <.LVL453>:
    9010:	46 4c       	mov.b	r12,	r6	;
    9012:	45 8c       	sub.b	r12,	r5	;

00009014 <.LVL454>:
    9014:	45 8d       	sub.b	r13,	r5	;
    9016:	49 45       	mov.b	r5,	r9	;

00009018 <.LVL455>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9018:	06 93       	cmp	#0,	r6	;r3 As==00
    901a:	5a 20       	jnz	$+182    	;abs 0x90d0

0000901c <.Loc.934.2>:
    901c:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000901e <.L367>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    901e:	0f 4c       	mov	r12,	r15	;
    9020:	2f 52       	add	#4,	r15	;r2 As==10

00009022 <.LVL457>:
    9022:	04 4f       	mov	r15,	r4	;
    9024:	44 0e       	rlam.a	#4,	r4	;
    9026:	44 0d       	rram.a	#4,	r4	;
    9028:	ce 04       	mova	r4,	r14	;
    902a:	ee 0a       	adda	r10,	r14	;
    902c:	09 5c       	add	r12,	r9	;

0000902e <.L368>:
    902e:	0f 99       	cmp	r9,	r15	;
    9030:	52 38       	jl	$+166    	;abs 0x90d6
    9032:	0d 4c       	mov	r12,	r13	;
    9034:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    9038:	0d 8c       	sub	r12,	r13	;
    903a:	81 4d 08 00 	mov	r13,	8(r1)	;

0000903e <.Loc.937.2>:
    903e:	67 42       	mov.b	#4,	r7	;r2 As==10
    9040:	49 43       	clr.b	r9		;
    9042:	04 49       	mov	r9,	r4	;
    9044:	4d 4c       	mov.b	r12,	r13	;
    9046:	0e 43       	clr	r14		;
    9048:	81 4d 04 00 	mov	r13,	4(r1)	;
    904c:	81 4e 06 00 	mov	r14,	6(r1)	;

00009050 <.LBB83>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    9050:	0e 12       	push	r14		;
    9052:	0d 12       	push	r13		;
    9054:	0c 16       	popm.a	#1,	r12	;20-bit words
    9056:	ec 0a       	adda	r10,	r12	;
    9058:	71 0c 0a 00 	mova	r12,	10(r1)	; 0x0000a

0000905c <.L374>:
    905c:	37 53       	add	#-1,	r7	;r3 As==11

0000905e <.Loc.956.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    905e:	37 93       	cmp	#-1,	r7	;r3 As==11
    9060:	6b 20       	jnz	$+216    	;abs 0x9138

00009062 <.LBE83>:
  interval = (interval / 100) * 100;
    9062:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    9066:	4f 43       	clr.b	r15		;
    9068:	0c 49       	mov	r9,	r12	;
    906a:	0d 44       	mov	r4,	r13	;
    906c:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    9070:	07 4c       	mov	r12,	r7	;
    9072:	09 4d       	mov	r13,	r9	;

00009074 <.LVL460>:
    9074:	0e 4c       	mov	r12,	r14	;
    9076:	0e 5c       	add	r12,	r14	;
    9078:	0d 6d       	rlc	r13		;
    907a:	04 4e       	mov	r14,	r4	;
    907c:	04 57       	add	r7,	r4	;
    907e:	0f 4d       	mov	r13,	r15	;
    9080:	0f 69       	addc	r9,	r15	;
    9082:	0c 44       	mov	r4,	r12	;
    9084:	0d 4f       	mov	r15,	r13	;
    9086:	71 0f 00 00 	mova	r15,	0(r1)	;
    908a:	b0 13 2c cd 	calla	#52524		;0x0cd2c
    908e:	0e 44       	mov	r4,	r14	;
    9090:	0e 5c       	add	r12,	r14	;
    9092:	0f 01       	mova	@r1,	r15	;
    9094:	0f 6d       	addc	r13,	r15	;

00009096 <.Loc.963.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    9096:	1c 41 04 00 	mov	4(r1),	r12	;
    909a:	1d 41 06 00 	mov	6(r1),	r13	;
    909e:	0d 12       	push	r13		;
    90a0:	0c 12       	push	r12		;
    90a2:	04 16       	popm.a	#1,	r4	;20-bit words
    90a4:	cc 04       	mova	r4,	r12	;
    90a6:	ac 00 04 00 	adda	#4,	r12	;
    90aa:	0e 57       	add	r7,	r14	;
    90ac:	0f 69       	addc	r9,	r15	;
    90ae:	4d 45       	mov.b	r5,	r13	;
    90b0:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    90b4:	ec 0a       	adda	r10,	r12	;
    90b6:	b0 13 26 c5 	calla	#50470		;0x0c526

000090ba <.LVL462>:
  if (hdr.reply) {
    90ba:	06 93       	cmp	#0,	r6	;r3 As==00
    90bc:	33 24       	jz	$+104    	;abs 0x9124

000090be <.Loc.967.2>:
    gen_success(buffer, hdr.crc);
    90be:	4d 48       	mov.b	r8,	r13	;
    90c0:	cc 0a       	mova	r10,	r12	;
    90c2:	b0 13 b8 7d 	calla	#32184		;0x07db8

000090c6 <.LVL463>:
    90c6:	80 00 0e 91 	mova	#37134,	r0	;0x0910e

000090ca <.L377>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    90ca:	6d 43       	mov.b	#2,	r13	;r3 As==10

000090cc <.LVL465>:
    90cc:	80 00 0e 90 	mova	#36878,	r0	;0x0900e

000090d0 <.L378>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    90d0:	6c 42       	mov.b	#4,	r12	;r2 As==10
    90d2:	80 00 1e 90 	mova	#36894,	r0	;0x0901e

000090d6 <.L373>:
    if ((buffer[i] < 0x40) || 
    90d6:	6d 4e       	mov.b	@r14,	r13	;
    90d8:	47 4d       	mov.b	r13,	r7	;
    90da:	77 50 c0 ff 	add.b	#-64,	r7	;#0xffc0
    90de:	74 40 36 00 	mov.b	#54,	r4	;#0x0036
    90e2:	44 97       	cmp.b	r7,	r4	;
    90e4:	0e 28       	jnc	$+30     	;abs 0x9102

000090e6 <.Loc.939.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    90e6:	77 50 ef ff 	add.b	#-17,	r7	;#0xffef

000090ea <.Loc.938.2>:
    if ((buffer[i] < 0x40) || 
    90ea:	74 40 0e 00 	mov.b	#14,	r4	;#0x000e
    90ee:	44 97       	cmp.b	r7,	r4	;
    90f0:	08 2c       	jc	$+18     	;abs 0x9102
    90f2:	ae 00 01 00 	adda	#1,	r14	;

000090f6 <.Loc.940.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    90f6:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

000090fa <.Loc.939.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    90fa:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    90fe:	47 9d       	cmp.b	r13,	r7	;
    9100:	18 28       	jnc	$+50     	;abs 0x9132

00009102 <.L369>:
      if (hdr.reply) {
    9102:	06 93       	cmp	#0,	r6	;r3 As==00
    9104:	0b 24       	jz	$+24     	;abs 0x911c

00009106 <.Loc.944.2>:
        gen_failure(buffer, hdr.crc);
    9106:	4d 48       	mov.b	r8,	r13	;
    9108:	cc 0a       	mova	r10,	r12	;
    910a:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000910e <.L379>:
    elyCmdSendReply(buffer);
    910e:	cc 0a       	mova	r10,	r12	;
    9110:	b0 13 5e 83 	calla	#33630		;0x0835e

00009114 <.L365>:
}
    9114:	a1 00 10 00 	adda	#16,	r1	;0x00010
    9118:	64 16       	popm.a	#7,	r10	;20-bit words
    911a:	10 01       	reta			;

0000911c <.L371>:
        elyErrorSignal(ErrCmdFailure);
    911c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9120:	b0 13 98 c3 	calla	#50072		;0x0c398

00009124 <.L376>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9124:	cc 0a       	mova	r10,	r12	;
    9126:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000912a <.LVL472>:
    912a:	b0 13 42 c1 	calla	#49474		;0x0c142

0000912e <.LVL473>:
    912e:	80 00 14 91 	mova	#37140,	r0	;0x09114

00009132 <.L370>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    9132:	1f 53       	inc	r15		;
    9134:	80 00 2e 90 	mova	#36910,	r0	;0x0902e

00009138 <.L375>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    9138:	1e 41 08 00 	mov	8(r1),	r14	;
    913c:	0e 57       	add	r7,	r14	;
    913e:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    9142:	3f 01 0a 00 	mova	10(r1),	r15	;0x0000a
    9146:	6c 4f       	mov.b	@r15,	r12	;
    9148:	0d 43       	clr	r13		;
    914a:	0f 43       	clr	r15		;
    914c:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9150:	09 dc       	bis	r12,	r9	;

00009152 <.LVL478>:
    9152:	04 dd       	bis	r13,	r4	;

00009154 <.LVL479>:
    9154:	80 00 5c 90 	mova	#36956,	r0	;0x0905c

00009158 <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9158:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000915a <.LCFI56>:
    915a:	b1 00 02 00 	suba	#2,	r1	;

0000915e <.LCFI57>:
    915e:	ca 0c       	mova	r12,	r10	;

00009160 <.LVL481>:
    9160:	5e 4d 01 00 	mov.b	1(r13),	r14	;

00009164 <.LVL482>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    9164:	67 4d       	mov.b	@r13,	r7	;
    9166:	57 f3       	and.b	#1,	r7	;r3 As==01
    9168:	6c 4d       	mov.b	@r13,	r12	;

0000916a <.LVL483>:
    916a:	1c b3       	bit	#1,	r12	;r3 As==01
    916c:	1d 20       	jnz	$+60     	;abs 0x91a8
    916e:	4f 43       	clr.b	r15		;

00009170 <.L381>:
    9170:	6c f3       	and.b	#2,	r12	;r3 As==10
    9172:	49 4c       	mov.b	r12,	r9	;
    9174:	40 18 4d 4e 	movx.b	r14,	r13	;
    9178:	40 18 4d 8c 	subx.b	r12,	r13	;

0000917c <.LVL484>:
    917c:	4d 8f       	sub.b	r15,	r13	;
    917e:	4f 4d       	mov.b	r13,	r15	;

00009180 <.LVL485>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9180:	09 93       	cmp	#0,	r9	;r3 As==00
    9182:	15 20       	jnz	$+44     	;abs 0x91ae

00009184 <.Loc.900.2>:
    9184:	6e 43       	mov.b	#2,	r14	;r3 As==10

00009186 <.L382>:
    9186:	40 18 0c 4e 	movx.w	r14,	r12	;
    918a:	ec 0a       	adda	r10,	r12	;
    918c:	c8 0c       	mova	r12,	r8	;

0000918e <.LBB88>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    918e:	0f 5e       	add	r14,	r15	;

00009190 <.L383>:
    9190:	0e 9f       	cmp	r15,	r14	;
    9192:	10 38       	jl	$+34     	;abs 0x91b4

00009194 <.LBE88>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    9194:	b0 13 d6 c4 	calla	#50390		;0x0c4d6

00009198 <.LVL488>:
  if (hdr.reply) {
    9198:	09 93       	cmp	#0,	r9	;r3 As==00
    919a:	26 24       	jz	$+78     	;abs 0x91e8

0000919c <.Loc.922.2>:
    gen_success(buffer, hdr.crc);
    919c:	4d 47       	mov.b	r7,	r13	;
    919e:	cc 0a       	mova	r10,	r12	;
    91a0:	b0 13 b8 7d 	calla	#32184		;0x07db8

000091a4 <.LVL489>:
    91a4:	80 00 d2 91 	mova	#37330,	r0	;0x091d2

000091a8 <.L389>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    91a8:	6f 43       	mov.b	#2,	r15	;r3 As==10
    91aa:	80 00 70 91 	mova	#37232,	r0	;0x09170

000091ae <.L390>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    91ae:	6e 42       	mov.b	#4,	r14	;r2 As==10

000091b0 <.LVL492>:
    91b0:	80 00 86 91 	mova	#37254,	r0	;0x09186

000091b4 <.L387>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    91b4:	6b 48       	mov.b	@r8,	r11	;
    91b6:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    91ba:	a8 00 01 00 	adda	#1,	r8	;
    91be:	76 40 3f 00 	mov.b	#63,	r6	;#0x003f
    91c2:	46 9b       	cmp.b	r11,	r6	;
    91c4:	18 2c       	jc	$+50     	;abs 0x91f6

000091c6 <.Loc.904.2>:
      if (hdr.reply) {
    91c6:	09 93       	cmp	#0,	r9	;r3 As==00
    91c8:	0b 24       	jz	$+24     	;abs 0x91e0

000091ca <.Loc.906.2>:
        gen_failure(buffer, hdr.crc);
    91ca:	4d 47       	mov.b	r7,	r13	;

000091cc <.LVL494>:
    91cc:	cc 0a       	mova	r10,	r12	;
    91ce:	b0 13 f6 7d 	calla	#32246		;0x07df6

000091d2 <.L391>:
    elyCmdSendReply(buffer);
    91d2:	cc 0a       	mova	r10,	r12	;
    91d4:	b0 13 5e 83 	calla	#33630		;0x0835e

000091d8 <.L380>:
}
    91d8:	a1 00 02 00 	adda	#2,	r1	;
    91dc:	46 16       	popm.a	#5,	r10	;20-bit words
    91de:	10 01       	reta			;

000091e0 <.L385>:
        elyErrorSignal(ErrCmdFailure);
    91e0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    91e4:	b0 13 98 c3 	calla	#50072		;0x0c398

000091e8 <.L388>:
    elyNLFreeBuffer(elyNLPack(buffer));
    91e8:	cc 0a       	mova	r10,	r12	;
    91ea:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000091ee <.LVL499>:
    91ee:	b0 13 42 c1 	calla	#49474		;0x0c142

000091f2 <.LVL500>:
    91f2:	80 00 d8 91 	mova	#37336,	r0	;0x091d8

000091f6 <.L384>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    91f6:	1e 53       	inc	r14		;
    91f8:	80 00 90 91 	mova	#37264,	r0	;0x09190

000091fc <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    91fc:	6a 14       	pushm.a	#7,	r10	;20-bit words

000091fe <.LCFI58>:
    91fe:	b1 00 10 00 	suba	#16,	r1	;0x00010

00009202 <.LCFI59>:
    9202:	ca 0c       	mova	r12,	r10	;

00009204 <.LVL504>:
    9204:	55 4d 01 00 	mov.b	1(r13),	r5	;

00009208 <.LVL505>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    9208:	68 4d       	mov.b	@r13,	r8	;
    920a:	58 f3       	and.b	#1,	r8	;r3 As==01
    920c:	6c 4d       	mov.b	@r13,	r12	;

0000920e <.LVL506>:
    920e:	1c b3       	bit	#1,	r12	;r3 As==01
    9210:	5f 20       	jnz	$+192    	;abs 0x92d0
    9212:	4d 43       	clr.b	r13		;

00009214 <.L393>:
    9214:	6c f3       	and.b	#2,	r12	;r3 As==10

00009216 <.LVL508>:
    9216:	46 4c       	mov.b	r12,	r6	;
    9218:	45 8c       	sub.b	r12,	r5	;

0000921a <.LVL509>:
    921a:	45 8d       	sub.b	r13,	r5	;
    921c:	49 45       	mov.b	r5,	r9	;

0000921e <.LVL510>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    921e:	06 93       	cmp	#0,	r6	;r3 As==00
    9220:	5a 20       	jnz	$+182    	;abs 0x92d6

00009222 <.Loc.854.2>:
    9222:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009224 <.L394>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    9224:	0f 4c       	mov	r12,	r15	;
    9226:	2f 52       	add	#4,	r15	;r2 As==10

00009228 <.LVL512>:
    9228:	04 4f       	mov	r15,	r4	;
    922a:	44 0e       	rlam.a	#4,	r4	;
    922c:	44 0d       	rram.a	#4,	r4	;
    922e:	ce 04       	mova	r4,	r14	;
    9230:	ee 0a       	adda	r10,	r14	;
    9232:	09 5c       	add	r12,	r9	;

00009234 <.L395>:
    9234:	0f 99       	cmp	r9,	r15	;
    9236:	52 38       	jl	$+166    	;abs 0x92dc
    9238:	0d 4c       	mov	r12,	r13	;
    923a:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    923e:	0d 8c       	sub	r12,	r13	;
    9240:	81 4d 08 00 	mov	r13,	8(r1)	;

00009244 <.Loc.857.2>:
    9244:	67 42       	mov.b	#4,	r7	;r2 As==10
    9246:	49 43       	clr.b	r9		;
    9248:	04 49       	mov	r9,	r4	;
    924a:	4d 4c       	mov.b	r12,	r13	;
    924c:	0e 43       	clr	r14		;
    924e:	81 4d 04 00 	mov	r13,	4(r1)	;
    9252:	81 4e 06 00 	mov	r14,	6(r1)	;

00009256 <.LBB93>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    9256:	0e 12       	push	r14		;
    9258:	0d 12       	push	r13		;
    925a:	0c 16       	popm.a	#1,	r12	;20-bit words
    925c:	ec 0a       	adda	r10,	r12	;
    925e:	71 0c 0a 00 	mova	r12,	10(r1)	; 0x0000a

00009262 <.L401>:
    9262:	37 53       	add	#-1,	r7	;r3 As==11

00009264 <.Loc.876.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    9264:	37 93       	cmp	#-1,	r7	;r3 As==11
    9266:	6b 20       	jnz	$+216    	;abs 0x933e

00009268 <.LBE93>:
  interval = (interval / 100) * 100;
    9268:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    926c:	4f 43       	clr.b	r15		;
    926e:	0c 49       	mov	r9,	r12	;
    9270:	0d 44       	mov	r4,	r13	;
    9272:	b0 13 c8 cc 	calla	#52424		;0x0ccc8
    9276:	07 4c       	mov	r12,	r7	;
    9278:	09 4d       	mov	r13,	r9	;

0000927a <.LVL515>:
    927a:	0e 4c       	mov	r12,	r14	;
    927c:	0e 5c       	add	r12,	r14	;
    927e:	0d 6d       	rlc	r13		;
    9280:	04 4e       	mov	r14,	r4	;
    9282:	04 57       	add	r7,	r4	;
    9284:	0f 4d       	mov	r13,	r15	;
    9286:	0f 69       	addc	r9,	r15	;
    9288:	0c 44       	mov	r4,	r12	;
    928a:	0d 4f       	mov	r15,	r13	;
    928c:	71 0f 00 00 	mova	r15,	0(r1)	;
    9290:	b0 13 2c cd 	calla	#52524		;0x0cd2c
    9294:	0e 44       	mov	r4,	r14	;
    9296:	0e 5c       	add	r12,	r14	;
    9298:	0f 01       	mova	@r1,	r15	;
    929a:	0f 6d       	addc	r13,	r15	;

0000929c <.Loc.884.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    929c:	1c 41 04 00 	mov	4(r1),	r12	;
    92a0:	1d 41 06 00 	mov	6(r1),	r13	;
    92a4:	0d 12       	push	r13		;
    92a6:	0c 12       	push	r12		;
    92a8:	04 16       	popm.a	#1,	r4	;20-bit words
    92aa:	cc 04       	mova	r4,	r12	;
    92ac:	ac 00 04 00 	adda	#4,	r12	;
    92b0:	0e 57       	add	r7,	r14	;
    92b2:	0f 69       	addc	r9,	r15	;
    92b4:	4d 45       	mov.b	r5,	r13	;
    92b6:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    92ba:	ec 0a       	adda	r10,	r12	;
    92bc:	b0 13 86 c4 	calla	#50310		;0x0c486

000092c0 <.LVL517>:
  if (hdr.reply) {
    92c0:	06 93       	cmp	#0,	r6	;r3 As==00
    92c2:	4d 24       	jz	$+156    	;abs 0x935e

000092c4 <.Loc.888.2>:
    gen_success(buffer, hdr.crc);
    92c4:	4d 48       	mov.b	r8,	r13	;
    92c6:	cc 0a       	mova	r10,	r12	;
    92c8:	b0 13 b8 7d 	calla	#32184		;0x07db8

000092cc <.LVL518>:
    92cc:	80 00 14 93 	mova	#37652,	r0	;0x09314

000092d0 <.L404>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    92d0:	6d 43       	mov.b	#2,	r13	;r3 As==10

000092d2 <.LVL520>:
    92d2:	80 00 14 92 	mova	#37396,	r0	;0x09214

000092d6 <.L405>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    92d6:	6c 42       	mov.b	#4,	r12	;r2 As==10
    92d8:	80 00 24 92 	mova	#37412,	r0	;0x09224

000092dc <.L400>:
    if ((buffer[i] < 0x40) || 
    92dc:	6d 4e       	mov.b	@r14,	r13	;
    92de:	47 4d       	mov.b	r13,	r7	;
    92e0:	77 50 c0 ff 	add.b	#-64,	r7	;#0xffc0
    92e4:	74 40 36 00 	mov.b	#54,	r4	;#0x0036
    92e8:	44 97       	cmp.b	r7,	r4	;
    92ea:	0e 28       	jnc	$+30     	;abs 0x9308

000092ec <.Loc.859.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    92ec:	77 50 ef ff 	add.b	#-17,	r7	;#0xffef

000092f0 <.Loc.858.2>:
    if ((buffer[i] < 0x40) || 
    92f0:	74 40 0e 00 	mov.b	#14,	r4	;#0x000e
    92f4:	44 97       	cmp.b	r7,	r4	;
    92f6:	08 2c       	jc	$+18     	;abs 0x9308
    92f8:	ae 00 01 00 	adda	#1,	r14	;

000092fc <.Loc.860.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    92fc:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00009300 <.Loc.859.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    9300:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    9304:	47 9d       	cmp.b	r13,	r7	;
    9306:	18 28       	jnc	$+50     	;abs 0x9338

00009308 <.L396>:
      if (hdr.reply) {
    9308:	06 93       	cmp	#0,	r6	;r3 As==00
    930a:	09 24       	jz	$+20     	;abs 0x931e

0000930c <.Loc.864.2>:
        gen_failure(buffer, hdr.crc);
    930c:	4d 48       	mov.b	r8,	r13	;
    930e:	cc 0a       	mova	r10,	r12	;
    9310:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009314 <.L406>:
    elyCmdSendReply(buffer);
    9314:	cc 0a       	mova	r10,	r12	;
    9316:	b0 13 5e 83 	calla	#33630		;0x0835e

0000931a <.LVL524>:
    931a:	80 00 30 93 	mova	#37680,	r0	;0x09330

0000931e <.L398>:
        elyNLFreeBuffer(elyNLPack(buffer));
    931e:	cc 0a       	mova	r10,	r12	;
    9320:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009324 <.LVL526>:
    9324:	b0 13 42 c1 	calla	#49474		;0x0c142

00009328 <.LVL527>:
        elyErrorSignal(ErrCmdFailure);
    9328:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    932c:	b0 13 98 c3 	calla	#50072		;0x0c398

00009330 <.L392>:
}
    9330:	a1 00 10 00 	adda	#16,	r1	;0x00010
    9334:	64 16       	popm.a	#7,	r10	;20-bit words
    9336:	10 01       	reta			;

00009338 <.L397>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    9338:	1f 53       	inc	r15		;
    933a:	80 00 34 92 	mova	#37428,	r0	;0x09234

0000933e <.L402>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    933e:	1e 41 08 00 	mov	8(r1),	r14	;
    9342:	0e 57       	add	r7,	r14	;
    9344:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    9348:	3f 01 0a 00 	mova	10(r1),	r15	;0x0000a
    934c:	6c 4f       	mov.b	@r15,	r12	;
    934e:	0d 43       	clr	r13		;
    9350:	0f 43       	clr	r15		;
    9352:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9356:	09 dc       	bis	r12,	r9	;

00009358 <.LVL533>:
    9358:	04 dd       	bis	r13,	r4	;

0000935a <.LVL534>:
    935a:	80 00 62 92 	mova	#37474,	r0	;0x09262

0000935e <.L403>:
    elyNLFreeBuffer(elyNLPack(buffer));
    935e:	cc 0a       	mova	r10,	r12	;
    9360:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009364 <.LVL536>:
    9364:	b0 13 42 c1 	calla	#49474		;0x0c142

00009368 <.LVL537>:
    9368:	80 00 30 93 	mova	#37680,	r0	;0x09330

0000936c <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    936c:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000936e <.LCFI60>:
    936e:	06 14       	pushm.a	#1,	r6	;20-bit words

00009370 <.LCFI61>:
    9370:	b1 00 02 00 	suba	#2,	r1	;

00009374 <.LCFI62>:
    9374:	c6 0c       	mova	r12,	r6	;
    9376:	cc 0d       	mova	r13,	r12	;

00009378 <.LVL539>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9378:	6d 4d       	mov.b	@r13,	r13	;
    937a:	5d f3       	and.b	#1,	r13	;r3 As==01
    937c:	6e 4c       	mov.b	@r12,	r14	;
    937e:	6e f3       	and.b	#2,	r14	;r3 As==10
    9380:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    9384:	0e 93       	cmp	#0,	r14	;r3 As==00
    9386:	18 20       	jnz	$+50     	;abs 0x93b8
    9388:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000938a <.L408>:
  uint8_t bank = buffer[hdr_ext];
    938a:	40 18 0c 4c 	movx.w	r12,	r12	;
    938e:	ec 06       	adda	r6,	r12	;

00009390 <.LVL541>:
    9390:	69 4c       	mov.b	@r12,	r9	;

00009392 <.LVL542>:
  if (bank == 0 || bank > 4) {
    9392:	4c 49       	mov.b	r9,	r12	;

00009394 <.LVL543>:
    9394:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9396:	7f 40 03 00 	mov.b	#3,	r15	;
    939a:	4f 9c       	cmp.b	r12,	r15	;
    939c:	1b 2c       	jc	$+56     	;abs 0x93d4

0000939e <.Loc.824.2>:
    if (hdr.reply) {
    939e:	0e 93       	cmp	#0,	r14	;r3 As==00
    93a0:	0e 24       	jz	$+30     	;abs 0x93be

000093a2 <.Loc.826.2>:
      gen_failure(buffer, hdr.crc);
    93a2:	cc 06       	mova	r6,	r12	;
    93a4:	b0 13 f6 7d 	calla	#32246		;0x07df6

000093a8 <.LVL544>:
      elyCmdSendReply(buffer);
    93a8:	cc 06       	mova	r6,	r12	;
    93aa:	b0 13 5e 83 	calla	#33630		;0x0835e

000093ae <.L407>:
}
    93ae:	a1 00 02 00 	adda	#2,	r1	;
    93b2:	06 16       	popm.a	#1,	r6	;20-bit words
    93b4:	28 16       	popm.a	#3,	r10	;20-bit words
    93b6:	10 01       	reta			;

000093b8 <.L412>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    93b8:	6c 42       	mov.b	#4,	r12	;r2 As==10

000093ba <.LVL547>:
    93ba:	80 00 8a 93 	mova	#37770,	r0	;0x0938a

000093be <.L410>:
      elyErrorSignal(ErrCmdFailure);
    93be:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    93c2:	b0 13 98 c3 	calla	#50072		;0x0c398

000093c6 <.LVL549>:
      elyNLFreeBuffer(elyNLPack(buffer));
    93c6:	cc 06       	mova	r6,	r12	;
    93c8:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000093cc <.LVL550>:
    93cc:	b0 13 42 c1 	calla	#49474		;0x0c142

000093d0 <.LVL551>:
    93d0:	80 00 ae 93 	mova	#37806,	r0	;0x093ae

000093d4 <.L409>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    93d4:	2a 01 46 07 	mova	&67398,	r10	;0x10746
    93d8:	88 00 86 a8 	mova	#43142,	r8	;0x0a886
    93dc:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    93e0:	4e 43       	clr.b	r14		;
    93e2:	cd 0a       	mova	r10,	r13	;
    93e4:	4c 49       	mov.b	r9,	r12	;
    93e6:	48 13       	calla	r8		;

000093e8 <.LVL552>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    93e8:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    93ec:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    93f0:	cd 0a       	mova	r10,	r13	;
    93f2:	ad 00 80 00 	adda	#128,	r13	;0x00080
    93f6:	4c 49       	mov.b	r9,	r12	;
    93f8:	48 13       	calla	r8		;

000093fa <.LVL553>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    93fa:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    93fe:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    9402:	cd 0a       	mova	r10,	r13	;
    9404:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    9408:	4c 49       	mov.b	r9,	r12	;
    940a:	48 13       	calla	r8		;

0000940c <.LVL554>:
  elyNLFreeBuffer(elyNLPack(buffer));
    940c:	cc 06       	mova	r6,	r12	;
    940e:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009412 <.LVL555>:
    9412:	b0 13 42 c1 	calla	#49474		;0x0c142

00009416 <.LVL556>:
  bank0w[RegActiveBank] = bank;
    9416:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

0000941a <.Loc.849.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    941a:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    941e:	48 a5 20 01 
    9422:	80 00 ae 93 	mova	#37806,	r0	;0x093ae

00009426 <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9426:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009428 <.LCFI63>:
    9428:	b1 00 06 00 	suba	#6,	r1	;

0000942c <.LCFI64>:
    942c:	c8 0c       	mova	r12,	r8	;

0000942e <.LVL558>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    942e:	65 4d       	mov.b	@r13,	r5	;
    9430:	55 f3       	and.b	#1,	r5	;r3 As==01
    9432:	67 4d       	mov.b	@r13,	r7	;
    9434:	67 f3       	and.b	#2,	r7	;r3 As==10
    9436:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    943a:	07 93       	cmp	#0,	r7	;r3 As==00
    943c:	36 20       	jnz	$+110    	;abs 0x94aa
    943e:	64 43       	mov.b	#2,	r4	;r3 As==10

00009440 <.L414>:
    9440:	40 18 04 44 	movx.w	r4,	r4	;
    9444:	e4 08       	adda	r8,	r4	;
    9446:	cb 04       	mova	r4,	r11	;

00009448 <.Loc.775.2>:
    9448:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

0000944c <.Loc.776.2>:
  uint32_t baud = 0;
    944c:	49 43       	clr.b	r9		;
    944e:	0a 49       	mov	r9,	r10	;

00009450 <.L415>:
    baud |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9450:	6c 4b       	mov.b	@r11,	r12	;
    9452:	0d 43       	clr	r13		;
    9454:	0e 46       	mov	r6,	r14	;
    9456:	0f 43       	clr	r15		;
    9458:	71 0b 00 00 	mova	r11,	0(r1)	;
    945c:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9460:	0c d9       	bis	r9,	r12	;
    9462:	0d da       	bis	r10,	r13	;
    9464:	09 4c       	mov	r12,	r9	;

00009466 <.LVL562>:
    9466:	0a 4d       	mov	r13,	r10	;

00009468 <.LVL563>:
    9468:	0b 01       	mova	@r1,	r11	;
    946a:	ab 00 01 00 	adda	#1,	r11	;
    946e:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009472 <.Loc.779.2>:
  for (int i = 0; i < 4; i++) {
    9472:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9476:	ec 23       	jnz	$-38     	;abs 0x9450

00009478 <.LBE98>:
  if (baud > UART_BAUD_MAX || 
    9478:	39 53       	add	#-1,	r9	;r3 As==11

0000947a <.LVL564>:
    947a:	3a 63       	addc	#-1,	r10	;r3 As==11

0000947c <.LVL565>:
    947c:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

00009480 <.LVL566>:
    9480:	0c 9a       	cmp	r10,	r12	;
    9482:	06 28       	jnc	$+14     	;abs 0x9490
    9484:	0a 9c       	cmp	r12,	r10	;
    9486:	1f 20       	jnz	$+64     	;abs 0x94c6
    9488:	3c 40 3f 42 	mov	#16959,	r12	;#0x423f
    948c:	0c 99       	cmp	r9,	r12	;
    948e:	1b 2c       	jc	$+56     	;abs 0x94c6

00009490 <.L422>:
    if (hdr.reply) {
    9490:	07 93       	cmp	#0,	r7	;r3 As==00
    9492:	0e 24       	jz	$+30     	;abs 0x94b0

00009494 <.Loc.787.2>:
      gen_failure(buffer, hdr.crc);
    9494:	4d 45       	mov.b	r5,	r13	;
    9496:	cc 08       	mova	r8,	r12	;
    9498:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000949c <.L424>:
    elyCmdSendReply(buffer);
    949c:	cc 08       	mova	r8,	r12	;
    949e:	b0 13 5e 83 	calla	#33630		;0x0835e

000094a2 <.L413>:
}
    94a2:	a1 00 06 00 	adda	#6,	r1	;
    94a6:	64 16       	popm.a	#7,	r10	;20-bit words
    94a8:	10 01       	reta			;

000094aa <.L421>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    94aa:	64 42       	mov.b	#4,	r4	;r2 As==10
    94ac:	80 00 40 94 	mova	#37952,	r0	;0x09440

000094b0 <.L418>:
      elyErrorSignal(ErrCmdFailure);
    94b0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    94b4:	b0 13 98 c3 	calla	#50072		;0x0c398

000094b8 <.L420>:
    elyNLFreeBuffer(elyNLPack(buffer));
    94b8:	cc 08       	mova	r8,	r12	;
    94ba:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000094be <.LVL573>:
    94be:	b0 13 42 c1 	calla	#49474		;0x0c142

000094c2 <.LVL574>:
    94c2:	80 00 a2 94 	mova	#38050,	r0	;0x094a2

000094c6 <.L416>:
  bank0w[RegUARTBaudMsb] = buffer[hdr_ext];
    94c6:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    94ca:	ec 44 25 00 	mov.b	@r4,	37(r12)	; 0x0025

000094ce <.Loc.799.2>:
  bank0w[RegUARTBaudHmb] = buffer[hdr_ext+1];
    94ce:	dc 44 01 00 	mov.b	1(r4),	36(r12)	; 0x0024
    94d2:	24 00 

000094d4 <.Loc.800.2>:
  bank0w[RegUARTBaudLmb] = buffer[hdr_ext+2];
    94d4:	dc 44 02 00 	mov.b	2(r4),	35(r12)	; 0x0023
    94d8:	23 00 

000094da <.Loc.801.2>:
  bank0w[RegUARTBaudLsb] = buffer[hdr_ext+3];
    94da:	dc 44 03 00 	mov.b	3(r4),	34(r12)	; 0x0022
    94de:	22 00 

000094e0 <.Loc.804.2>:
  elyUARTCfgMarkDirty();
    94e0:	b0 13 84 7a 	calla	#31364		;0x07a84

000094e4 <.LVL576>:
  if (hdr.reply) {
    94e4:	07 93       	cmp	#0,	r7	;r3 As==00
    94e6:	e8 27       	jz	$-46     	;abs 0x94b8

000094e8 <.Loc.808.2>:
    gen_success(buffer, hdr.crc);
    94e8:	4d 45       	mov.b	r5,	r13	;
    94ea:	cc 08       	mova	r8,	r12	;
    94ec:	b0 13 b8 7d 	calla	#32184		;0x07db8

000094f0 <.LVL577>:
    94f0:	80 00 9c 94 	mova	#38044,	r0	;0x0949c

000094f4 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    94f4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000094f6 <.LCFI65>:
    94f6:	08 14       	pushm.a	#1,	r8	;20-bit words

000094f8 <.LCFI66>:
    94f8:	b1 00 02 00 	suba	#2,	r1	;

000094fc <.LCFI67>:
    94fc:	ca 0c       	mova	r12,	r10	;

000094fe <.Loc.748.2>:
    94fe:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9502:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9506:	01 00 

00009508 <.Loc.750.2>:
  if (hdr.reply) {
    9508:	6d 41       	mov.b	@r1,	r13	;
    950a:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    950e:	32 24       	jz	$+102    	;abs 0x9574

00009510 <.Loc.751.2>:
    buffer[0] = buffer[0] & 0x3F;
    9510:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9514:	00 00 

00009516 <.Loc.752.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9516:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

0000951a <.LVL579>:
    951a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    951e:	02 00 

00009520 <.Loc.753.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9520:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9524:	03 00 

00009526 <.LVL580>:
    9526:	ce 0c       	mova	r12,	r14	;
    9528:	ae 00 25 00 	adda	#37,	r14	;0x00025
    952c:	c8 0a       	mova	r10,	r8	;
    952e:	a8 00 04 00 	adda	#4,	r8	;
    9532:	ac 00 21 00 	adda	#33,	r12	;0x00021

00009536 <.L427>:
      buffer[i + 4] = bank0p[RegUARTBaudMsb - i];
    9536:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

0000953a <.LVL582>:
    953a:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    953e:	a8 00 01 00 	adda	#1,	r8	;

00009542 <.LVL583>:
    for (int i = 0; i < 4; i++) {
    9542:	de 0c       	cmpa	r12,	r14	;
    9544:	f8 23       	jnz	$-14     	;abs 0x9536

00009546 <.LBE99>:
    if (hdr.crc) {
    9546:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    954a:	10 24       	jz	$+34     	;abs 0x956c

0000954c <.Loc.759.2>:
      buffer[1] = 6;
    954c:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9550:	01 00 

00009552 <.Loc.760.2>:
      crcGenX25(buffer, 10);
    9552:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9556:	cc 0a       	mova	r10,	r12	;
    9558:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000955c <.L429>:
    elyCmdSendReply(buffer);
    955c:	cc 0a       	mova	r10,	r12	;
    955e:	b0 13 5e 83 	calla	#33630		;0x0835e

00009562 <.L425>:
}
    9562:	a1 00 02 00 	adda	#2,	r1	;
    9566:	08 16       	popm.a	#1,	r8	;20-bit words
    9568:	0a 16       	popm.a	#1,	r10	;20-bit words
    956a:	10 01       	reta			;

0000956c <.L428>:
      buffer[1] = 4;
    956c:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9570:	80 00 5c 95 	mova	#38236,	r0	;0x0955c

00009574 <.L426>:
    9574:	b0 13 68 7f 	calla	#32616		;0x07f68

00009578 <.LVL588>:
}
    9578:	80 00 62 95 	mova	#38242,	r0	;0x09562

0000957c <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    957c:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000957e <.LCFI68>:
    957e:	b1 00 02 00 	suba	#2,	r1	;

00009582 <.LCFI69>:
    9582:	ca 0c       	mova	r12,	r10	;

00009584 <.LVL590>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9584:	68 4d       	mov.b	@r13,	r8	;
    9586:	58 f3       	and.b	#1,	r8	;r3 As==01
    9588:	69 4d       	mov.b	@r13,	r9	;
    958a:	69 f3       	and.b	#2,	r9	;r3 As==10
    958c:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9590:	09 93       	cmp	#0,	r9	;r3 As==00
    9592:	15 20       	jnz	$+44     	;abs 0x95be
    9594:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009596 <.L433>:
  if ((int8_t)(buffer[hdr_ext]) > TX_POW_MAX) {
    9596:	40 18 0c 4c 	movx.w	r12,	r12	;
    959a:	ec 0a       	adda	r10,	r12	;

0000959c <.LVL592>:
    959c:	6d 4c       	mov.b	@r12,	r13	;

0000959e <.LVL593>:
    959e:	4c 43       	clr.b	r12		;
    95a0:	4c 9d       	cmp.b	r13,	r12	;
    95a2:	1b 34       	jge	$+56     	;abs 0x95da

000095a4 <.Loc.718.2>:
    if (hdr.reply) {
    95a4:	09 93       	cmp	#0,	r9	;r3 As==00
    95a6:	0e 24       	jz	$+30     	;abs 0x95c4

000095a8 <.Loc.720.2>:
      gen_failure(buffer, hdr.crc);
    95a8:	4d 48       	mov.b	r8,	r13	;
    95aa:	cc 0a       	mova	r10,	r12	;
    95ac:	b0 13 f6 7d 	calla	#32246		;0x07df6

000095b0 <.L439>:
    elyCmdSendReply(buffer);
    95b0:	cc 0a       	mova	r10,	r12	;
    95b2:	b0 13 5e 83 	calla	#33630		;0x0835e

000095b6 <.L432>:
}
    95b6:	a1 00 02 00 	adda	#2,	r1	;
    95ba:	28 16       	popm.a	#3,	r10	;20-bit words
    95bc:	10 01       	reta			;

000095be <.L438>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    95be:	6c 42       	mov.b	#4,	r12	;r2 As==10
    95c0:	80 00 96 95 	mova	#38294,	r0	;0x09596

000095c4 <.L435>:
      elyErrorSignal(ErrCmdFailure);
    95c4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    95c8:	b0 13 98 c3 	calla	#50072		;0x0c398

000095cc <.L437>:
    elyNLFreeBuffer(elyNLPack(buffer));
    95cc:	cc 0a       	mova	r10,	r12	;
    95ce:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000095d2 <.LVL599>:
    95d2:	b0 13 42 c1 	calla	#49474		;0x0c142

000095d6 <.LVL600>:
    95d6:	80 00 b6 95 	mova	#38326,	r0	;0x095b6

000095da <.L434>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    95da:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    95de:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

000095e2 <.Loc.734.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    95e2:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    95e6:	4d 43       	clr.b	r13		;
    95e8:	b0 13 58 b0 	calla	#45144		;0x0b058

000095ec <.LVL601>:
  if (hdr.reply) {
    95ec:	09 93       	cmp	#0,	r9	;r3 As==00
    95ee:	ee 27       	jz	$-34     	;abs 0x95cc

000095f0 <.Loc.738.2>:
    gen_success(buffer, hdr.crc);
    95f0:	4d 48       	mov.b	r8,	r13	;
    95f2:	cc 0a       	mova	r10,	r12	;
    95f4:	b0 13 b8 7d 	calla	#32184		;0x07db8

000095f8 <.LVL602>:
    95f8:	80 00 b0 95 	mova	#38320,	r0	;0x095b0

000095fc <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    95fc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000095fe <.LCFI70>:
    95fe:	b1 00 02 00 	suba	#2,	r1	;

00009602 <.LCFI71>:
    9602:	ca 0c       	mova	r12,	r10	;

00009604 <.Loc.691.2>:
    9604:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9608:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    960c:	01 00 

0000960e <.Loc.693.2>:
  if (hdr.reply) {
    960e:	6d 41       	mov.b	@r1,	r13	;
    9610:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9614:	23 24       	jz	$+72     	;abs 0x965c

00009616 <.Loc.694.2>:
    buffer[0] = buffer[0] & 0x3F;
    9616:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    961a:	00 00 

0000961c <.Loc.695.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    961c:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    9620:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    9624:	02 00 

00009626 <.Loc.696.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9626:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    962a:	03 00 

0000962c <.Loc.697.2>:
    buffer[4] = bank0p[RegOutputPower];
    962c:	dc 4e 21 00 	mov.b	33(r14),4(r12)	;0x00021
    9630:	04 00 

00009632 <.Loc.698.2>:
    if (hdr.crc) {
    9632:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9636:	0e 24       	jz	$+30     	;abs 0x9654

00009638 <.Loc.699.2>:
      buffer[1] = 3;
    9638:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    963c:	01 00 

0000963e <.Loc.700.2>:
      crcGenX25(buffer, 7);
    963e:	7d 40 07 00 	mov.b	#7,	r13	;
    9642:	b0 13 64 ae 	calla	#44644		;0x0ae64

00009646 <.L443>:
    elyCmdSendReply(buffer);
    9646:	cc 0a       	mova	r10,	r12	;
    9648:	b0 13 5e 83 	calla	#33630		;0x0835e

0000964c <.L440>:
}
    964c:	a1 00 02 00 	adda	#2,	r1	;
    9650:	0a 16       	popm.a	#1,	r10	;20-bit words
    9652:	10 01       	reta			;

00009654 <.L442>:
      buffer[1] = 1;
    9654:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    9658:	80 00 46 96 	mova	#38470,	r0	;0x09646

0000965c <.L441>:
    965c:	b0 13 68 7f 	calla	#32616		;0x07f68

00009660 <.LVL606>:
}
    9660:	80 00 4c 96 	mova	#38476,	r0	;0x0964c

00009664 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9664:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009666 <.LCFI72>:
    9666:	b1 00 06 00 	suba	#6,	r1	;

0000966a <.LCFI73>:
    966a:	c8 0c       	mova	r12,	r8	;

0000966c <.LVL608>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    966c:	65 4d       	mov.b	@r13,	r5	;
    966e:	55 f3       	and.b	#1,	r5	;r3 As==01
    9670:	67 4d       	mov.b	@r13,	r7	;
    9672:	67 f3       	and.b	#2,	r7	;r3 As==10
    9674:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9678:	07 93       	cmp	#0,	r7	;r3 As==00
    967a:	36 20       	jnz	$+110    	;abs 0x96e8
    967c:	64 43       	mov.b	#2,	r4	;r3 As==10

0000967e <.L446>:
    967e:	40 18 04 44 	movx.w	r4,	r4	;
    9682:	e4 08       	adda	r8,	r4	;
    9684:	cb 04       	mova	r4,	r11	;

00009686 <.Loc.648.2>:
    9686:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

0000968a <.Loc.649.2>:
  uint32_t dev = 0;
    968a:	49 43       	clr.b	r9		;
    968c:	0a 49       	mov	r9,	r10	;

0000968e <.L447>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    968e:	6c 4b       	mov.b	@r11,	r12	;
    9690:	0d 43       	clr	r13		;
    9692:	0e 46       	mov	r6,	r14	;
    9694:	0f 43       	clr	r15		;
    9696:	71 0b 00 00 	mova	r11,	0(r1)	;
    969a:	b0 13 48 cd 	calla	#52552		;0x0cd48
    969e:	0c d9       	bis	r9,	r12	;
    96a0:	0d da       	bis	r10,	r13	;
    96a2:	09 4c       	mov	r12,	r9	;

000096a4 <.LVL612>:
    96a4:	0a 4d       	mov	r13,	r10	;

000096a6 <.LVL613>:
    96a6:	0b 01       	mova	@r1,	r11	;
    96a8:	ab 00 01 00 	adda	#1,	r11	;
    96ac:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

000096b0 <.Loc.652.2>:
  for (int i = 0; i < 4; i++) {
    96b0:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    96b4:	ec 23       	jnz	$-38     	;abs 0x968e

000096b6 <.LBE100>:
  if (dev > RX_DEV_MAX || 
    96b6:	39 50 18 7f 	add	#32536,	r9	;#0x7f18

000096ba <.LVL614>:
    96ba:	3a 63       	addc	#-1,	r10	;r3 As==11

000096bc <.LVL615>:
    96bc:	6c 43       	mov.b	#2,	r12	;r3 As==10

000096be <.LVL616>:
    96be:	0c 9a       	cmp	r10,	r12	;
    96c0:	06 28       	jnc	$+14     	;abs 0x96ce
    96c2:	0a 9c       	cmp	r12,	r10	;
    96c4:	1f 20       	jnz	$+64     	;abs 0x9704
    96c6:	3c 40 58 8c 	mov	#-29608,r12	;#0x8c58
    96ca:	0c 99       	cmp	r9,	r12	;
    96cc:	1b 2c       	jc	$+56     	;abs 0x9704

000096ce <.L454>:
    if (hdr.reply) {
    96ce:	07 93       	cmp	#0,	r7	;r3 As==00
    96d0:	0e 24       	jz	$+30     	;abs 0x96ee

000096d2 <.Loc.660.2>:
      gen_failure(buffer, hdr.crc);
    96d2:	4d 45       	mov.b	r5,	r13	;
    96d4:	cc 08       	mova	r8,	r12	;
    96d6:	b0 13 f6 7d 	calla	#32246		;0x07df6

000096da <.L456>:
    elyCmdSendReply(buffer);
    96da:	cc 08       	mova	r8,	r12	;
    96dc:	b0 13 5e 83 	calla	#33630		;0x0835e

000096e0 <.L445>:
}
    96e0:	a1 00 06 00 	adda	#6,	r1	;
    96e4:	64 16       	popm.a	#7,	r10	;20-bit words
    96e6:	10 01       	reta			;

000096e8 <.L453>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    96e8:	64 42       	mov.b	#4,	r4	;r2 As==10
    96ea:	80 00 7e 96 	mova	#38526,	r0	;0x0967e

000096ee <.L450>:
      elyErrorSignal(ErrCmdFailure);
    96ee:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    96f2:	b0 13 98 c3 	calla	#50072		;0x0c398

000096f6 <.L452>:
    elyNLFreeBuffer(elyNLPack(buffer));
    96f6:	cc 08       	mova	r8,	r12	;
    96f8:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000096fc <.LVL623>:
    96fc:	b0 13 42 c1 	calla	#49474		;0x0c142

00009700 <.LVL624>:
    9700:	80 00 e0 96 	mova	#38624,	r0	;0x096e0

00009704 <.L448>:
  bank0w[RegRXDevMsb] = buffer[hdr_ext];
    9704:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9708:	ec 44 0f 00 	mov.b	@r4,	15(r12)	; 0x000f

0000970c <.Loc.672.2>:
  bank0w[RegRXDevHmb] = buffer[hdr_ext+1];
    970c:	dc 44 01 00 	mov.b	1(r4),	14(r12)	; 0x000e
    9710:	0e 00 

00009712 <.Loc.673.2>:
  bank0w[RegRXDevLmb] = buffer[hdr_ext+2];
    9712:	dc 44 02 00 	mov.b	2(r4),	13(r12)	; 0x000d
    9716:	0d 00 

00009718 <.Loc.674.2>:
  bank0w[RegRXDevLsb] = buffer[hdr_ext+3];
    9718:	dc 44 03 00 	mov.b	3(r4),	12(r12)	; 0x000c
    971c:	0c 00 

0000971e <.Loc.677.2>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    971e:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    9722:	4d 43       	clr.b	r13		;
    9724:	b0 13 58 b0 	calla	#45144		;0x0b058

00009728 <.LVL627>:
  if (hdr.reply) {
    9728:	07 93       	cmp	#0,	r7	;r3 As==00
    972a:	e5 27       	jz	$-52     	;abs 0x96f6

0000972c <.Loc.681.2>:
    gen_success(buffer, hdr.crc);
    972c:	4d 45       	mov.b	r5,	r13	;
    972e:	cc 08       	mova	r8,	r12	;
    9730:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009734 <.LVL628>:
    9734:	80 00 da 96 	mova	#38618,	r0	;0x096da

00009738 <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9738:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000973a <.LCFI74>:
    973a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000973c <.LCFI75>:
    973c:	b1 00 02 00 	suba	#2,	r1	;

00009740 <.LCFI76>:
    9740:	ca 0c       	mova	r12,	r10	;

00009742 <.Loc.621.2>:
    9742:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9746:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    974a:	01 00 

0000974c <.Loc.623.2>:
  if (hdr.reply) {
    974c:	6d 41       	mov.b	@r1,	r13	;
    974e:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9752:	32 24       	jz	$+102    	;abs 0x97b8

00009754 <.Loc.624.2>:
    buffer[0] = buffer[0] & 0x3F;
    9754:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9758:	00 00 

0000975a <.Loc.625.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    975a:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

0000975e <.LVL630>:
    975e:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9762:	02 00 

00009764 <.Loc.626.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9764:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9768:	03 00 

0000976a <.LVL631>:
    976a:	ce 0c       	mova	r12,	r14	;
    976c:	ae 00 0f 00 	adda	#15,	r14	;0x0000f
    9770:	c8 0a       	mova	r10,	r8	;
    9772:	a8 00 04 00 	adda	#4,	r8	;
    9776:	ac 00 0b 00 	adda	#11,	r12	;0x0000b

0000977a <.L459>:
      buffer[i + 4] = bank0p[RegRXDevMsb - i];
    977a:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

0000977e <.LVL633>:
    977e:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9782:	a8 00 01 00 	adda	#1,	r8	;

00009786 <.LVL634>:
    for (int i = 0; i < 4; i++) {
    9786:	de 0c       	cmpa	r12,	r14	;
    9788:	f8 23       	jnz	$-14     	;abs 0x977a

0000978a <.LBE101>:
    if (hdr.crc) {
    978a:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    978e:	10 24       	jz	$+34     	;abs 0x97b0

00009790 <.Loc.632.2>:
      buffer[1] = 6;
    9790:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9794:	01 00 

00009796 <.Loc.633.2>:
      crcGenX25(buffer, 10);
    9796:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    979a:	cc 0a       	mova	r10,	r12	;
    979c:	b0 13 64 ae 	calla	#44644		;0x0ae64

000097a0 <.L461>:
    elyCmdSendReply(buffer);
    97a0:	cc 0a       	mova	r10,	r12	;
    97a2:	b0 13 5e 83 	calla	#33630		;0x0835e

000097a6 <.L457>:
}
    97a6:	a1 00 02 00 	adda	#2,	r1	;
    97aa:	08 16       	popm.a	#1,	r8	;20-bit words
    97ac:	0a 16       	popm.a	#1,	r10	;20-bit words
    97ae:	10 01       	reta			;

000097b0 <.L460>:
      buffer[1] = 4;
    97b0:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    97b4:	80 00 a0 97 	mova	#38816,	r0	;0x097a0

000097b8 <.L458>:
    97b8:	b0 13 68 7f 	calla	#32616		;0x07f68

000097bc <.LVL639>:
}
    97bc:	80 00 a6 97 	mova	#38822,	r0	;0x097a6

000097c0 <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    97c0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000097c2 <.LCFI77>:
    97c2:	b1 00 06 00 	suba	#6,	r1	;

000097c6 <.LCFI78>:
    97c6:	c8 0c       	mova	r12,	r8	;

000097c8 <.LVL641>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    97c8:	65 4d       	mov.b	@r13,	r5	;
    97ca:	55 f3       	and.b	#1,	r5	;r3 As==01
    97cc:	67 4d       	mov.b	@r13,	r7	;
    97ce:	67 f3       	and.b	#2,	r7	;r3 As==10
    97d0:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    97d4:	07 93       	cmp	#0,	r7	;r3 As==00
    97d6:	37 20       	jnz	$+112    	;abs 0x9846
    97d8:	64 43       	mov.b	#2,	r4	;r3 As==10

000097da <.L465>:
    97da:	40 18 04 44 	movx.w	r4,	r4	;
    97de:	e4 08       	adda	r8,	r4	;
    97e0:	cb 04       	mova	r4,	r11	;

000097e2 <.Loc.578.2>:
    97e2:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

000097e6 <.Loc.579.2>:
  uint32_t dev = 0;
    97e6:	49 43       	clr.b	r9		;
    97e8:	0a 49       	mov	r9,	r10	;

000097ea <.L466>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    97ea:	6c 4b       	mov.b	@r11,	r12	;
    97ec:	0d 43       	clr	r13		;
    97ee:	0e 46       	mov	r6,	r14	;
    97f0:	0f 43       	clr	r15		;
    97f2:	71 0b 00 00 	mova	r11,	0(r1)	;
    97f6:	b0 13 48 cd 	calla	#52552		;0x0cd48
    97fa:	0c d9       	bis	r9,	r12	;
    97fc:	0d da       	bis	r10,	r13	;
    97fe:	09 4c       	mov	r12,	r9	;

00009800 <.LVL645>:
    9800:	0a 4d       	mov	r13,	r10	;

00009802 <.LVL646>:
    9802:	0b 01       	mova	@r1,	r11	;
    9804:	ab 00 01 00 	adda	#1,	r11	;
    9808:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

0000980c <.Loc.582.2>:
  for (int i = 0; i < 4; i++) {
    980c:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9810:	ec 23       	jnz	$-38     	;abs 0x97ea

00009812 <.LBE102>:
  if (dev > TX_DEV_MAX || 
    9812:	39 50 a8 fd 	add	#-600,	r9	;#0xfda8

00009816 <.LVL647>:
    9816:	3a 63       	addc	#-1,	r10	;r3 As==11

00009818 <.LVL648>:
    9818:	7c 40 03 00 	mov.b	#3,	r12	;

0000981c <.LVL649>:
    981c:	0c 9a       	cmp	r10,	r12	;
    981e:	06 28       	jnc	$+14     	;abs 0x982c
    9820:	0a 9c       	cmp	r12,	r10	;
    9822:	1f 20       	jnz	$+64     	;abs 0x9862
    9824:	3c 40 e8 0a 	mov	#2792,	r12	;#0x0ae8
    9828:	0c 99       	cmp	r9,	r12	;
    982a:	1b 2c       	jc	$+56     	;abs 0x9862

0000982c <.L473>:
    if (hdr.reply) {
    982c:	07 93       	cmp	#0,	r7	;r3 As==00
    982e:	0e 24       	jz	$+30     	;abs 0x984c

00009830 <.Loc.590.2>:
      gen_failure(buffer, hdr.crc);
    9830:	4d 45       	mov.b	r5,	r13	;
    9832:	cc 08       	mova	r8,	r12	;
    9834:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009838 <.L475>:
    elyCmdSendReply(buffer);
    9838:	cc 08       	mova	r8,	r12	;
    983a:	b0 13 5e 83 	calla	#33630		;0x0835e

0000983e <.L464>:
}
    983e:	a1 00 06 00 	adda	#6,	r1	;
    9842:	64 16       	popm.a	#7,	r10	;20-bit words
    9844:	10 01       	reta			;

00009846 <.L472>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9846:	64 42       	mov.b	#4,	r4	;r2 As==10
    9848:	80 00 da 97 	mova	#38874,	r0	;0x097da

0000984c <.L469>:
      elyErrorSignal(ErrCmdFailure);
    984c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9850:	b0 13 98 c3 	calla	#50072		;0x0c398

00009854 <.L471>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9854:	cc 08       	mova	r8,	r12	;
    9856:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000985a <.LVL656>:
    985a:	b0 13 42 c1 	calla	#49474		;0x0c142

0000985e <.LVL657>:
    985e:	80 00 3e 98 	mova	#38974,	r0	;0x0983e

00009862 <.L467>:
  bank0w[RegTXDevMsb] = buffer[hdr_ext];
    9862:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9866:	ec 44 0b 00 	mov.b	@r4,	11(r12)	; 0x000b

0000986a <.Loc.602.2>:
  bank0w[RegTXDevHmb] = buffer[hdr_ext+1];
    986a:	dc 44 01 00 	mov.b	1(r4),	10(r12)	; 0x000a
    986e:	0a 00 

00009870 <.Loc.603.2>:
  bank0w[RegTXDevLmb] = buffer[hdr_ext+2];
    9870:	dc 44 02 00 	mov.b	2(r4),	9(r12)	;
    9874:	09 00 

00009876 <.Loc.604.2>:
  bank0w[RegTXDevLsb] = buffer[hdr_ext+3];
    9876:	dc 44 03 00 	mov.b	3(r4),	8(r12)	;
    987a:	08 00 

0000987c <.Loc.607.2>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    987c:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    9880:	4d 43       	clr.b	r13		;
    9882:	b0 13 58 b0 	calla	#45144		;0x0b058

00009886 <.LVL660>:
  if (hdr.reply) {
    9886:	07 93       	cmp	#0,	r7	;r3 As==00
    9888:	e5 27       	jz	$-52     	;abs 0x9854

0000988a <.Loc.611.2>:
    gen_success(buffer, hdr.crc);
    988a:	4d 45       	mov.b	r5,	r13	;
    988c:	cc 08       	mova	r8,	r12	;
    988e:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009892 <.LVL661>:
    9892:	80 00 38 98 	mova	#38968,	r0	;0x09838

00009896 <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9896:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009898 <.LCFI79>:
    9898:	08 14       	pushm.a	#1,	r8	;20-bit words

0000989a <.LCFI80>:
    989a:	b1 00 02 00 	suba	#2,	r1	;

0000989e <.LCFI81>:
    989e:	ca 0c       	mova	r12,	r10	;

000098a0 <.Loc.551.2>:
    98a0:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    98a4:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    98a8:	01 00 

000098aa <.Loc.553.2>:
  if (hdr.reply) {
    98aa:	6d 41       	mov.b	@r1,	r13	;
    98ac:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    98b0:	32 24       	jz	$+102    	;abs 0x9916

000098b2 <.Loc.554.2>:
    buffer[0] = buffer[0] & 0x3F;
    98b2:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    98b6:	00 00 

000098b8 <.Loc.555.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    98b8:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

000098bc <.LVL663>:
    98bc:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    98c0:	02 00 

000098c2 <.Loc.556.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    98c2:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    98c6:	03 00 

000098c8 <.LVL664>:
    98c8:	ce 0c       	mova	r12,	r14	;
    98ca:	ae 00 0b 00 	adda	#11,	r14	;0x0000b
    98ce:	c8 0a       	mova	r10,	r8	;
    98d0:	a8 00 04 00 	adda	#4,	r8	;
    98d4:	ac 00 07 00 	adda	#7,	r12	;

000098d8 <.L478>:
      buffer[i + 4] = bank0p[RegTXDevMsb - i];
    98d8:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

000098dc <.LVL666>:
    98dc:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    98e0:	a8 00 01 00 	adda	#1,	r8	;

000098e4 <.LVL667>:
    for (int i = 0; i < 4; i++) {
    98e4:	de 0c       	cmpa	r12,	r14	;
    98e6:	f8 23       	jnz	$-14     	;abs 0x98d8

000098e8 <.LBE103>:
    if (hdr.crc) {
    98e8:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    98ec:	10 24       	jz	$+34     	;abs 0x990e

000098ee <.Loc.562.2>:
      buffer[1] = 6;
    98ee:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    98f2:	01 00 

000098f4 <.Loc.563.2>:
      crcGenX25(buffer, 10);
    98f4:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    98f8:	cc 0a       	mova	r10,	r12	;
    98fa:	b0 13 64 ae 	calla	#44644		;0x0ae64

000098fe <.L480>:
    elyCmdSendReply(buffer);
    98fe:	cc 0a       	mova	r10,	r12	;
    9900:	b0 13 5e 83 	calla	#33630		;0x0835e

00009904 <.L476>:
}
    9904:	a1 00 02 00 	adda	#2,	r1	;
    9908:	08 16       	popm.a	#1,	r8	;20-bit words
    990a:	0a 16       	popm.a	#1,	r10	;20-bit words
    990c:	10 01       	reta			;

0000990e <.L479>:
      buffer[1] = 4;
    990e:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9912:	80 00 fe 98 	mova	#39166,	r0	;0x098fe

00009916 <.L477>:
    9916:	b0 13 68 7f 	calla	#32616		;0x07f68

0000991a <.LVL672>:
}
    991a:	80 00 04 99 	mova	#39172,	r0	;0x09904

0000991e <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    991e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009920 <.LCFI82>:
    9920:	b1 00 06 00 	suba	#6,	r1	;

00009924 <.LCFI83>:
    9924:	c8 0c       	mova	r12,	r8	;

00009926 <.LVL674>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9926:	65 4d       	mov.b	@r13,	r5	;
    9928:	55 f3       	and.b	#1,	r5	;r3 As==01
    992a:	67 4d       	mov.b	@r13,	r7	;
    992c:	67 f3       	and.b	#2,	r7	;r3 As==10
    992e:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9932:	07 93       	cmp	#0,	r7	;r3 As==00
    9934:	36 20       	jnz	$+110    	;abs 0x99a2
    9936:	64 43       	mov.b	#2,	r4	;r3 As==10

00009938 <.L484>:
    9938:	40 18 04 44 	movx.w	r4,	r4	;
    993c:	e4 08       	adda	r8,	r4	;
    993e:	cb 04       	mova	r4,	r11	;

00009940 <.Loc.508.2>:
    9940:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009944 <.Loc.509.2>:
  uint32_t br = 0;
    9944:	49 43       	clr.b	r9		;
    9946:	0a 49       	mov	r9,	r10	;

00009948 <.L485>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9948:	6c 4b       	mov.b	@r11,	r12	;
    994a:	0d 43       	clr	r13		;
    994c:	0e 46       	mov	r6,	r14	;
    994e:	0f 43       	clr	r15		;
    9950:	71 0b 00 00 	mova	r11,	0(r1)	;
    9954:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9958:	0c d9       	bis	r9,	r12	;
    995a:	0d da       	bis	r10,	r13	;
    995c:	09 4c       	mov	r12,	r9	;

0000995e <.LVL678>:
    995e:	0a 4d       	mov	r13,	r10	;

00009960 <.LVL679>:
    9960:	0b 01       	mova	@r1,	r11	;
    9962:	ab 00 01 00 	adda	#1,	r11	;
    9966:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

0000996a <.Loc.512.2>:
  for (int i = 0; i < 4; i++) {
    996a:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    996e:	ec 23       	jnz	$-38     	;abs 0x9948

00009970 <.LBE104>:
  if (br > RX_BR_MAX || 
    9970:	39 50 f4 fc 	add	#-780,	r9	;#0xfcf4

00009974 <.LVL680>:
    9974:	3a 63       	addc	#-1,	r10	;r3 As==11

00009976 <.LVL681>:
    9976:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009978 <.LVL682>:
    9978:	0c 9a       	cmp	r10,	r12	;
    997a:	06 28       	jnc	$+14     	;abs 0x9988
    997c:	0a 9c       	cmp	r12,	r10	;
    997e:	1f 20       	jnz	$+64     	;abs 0x99be
    9980:	3c 40 e4 46 	mov	#18148,	r12	;#0x46e4
    9984:	0c 99       	cmp	r9,	r12	;
    9986:	1b 2c       	jc	$+56     	;abs 0x99be

00009988 <.L492>:
    if (hdr.reply) {
    9988:	07 93       	cmp	#0,	r7	;r3 As==00
    998a:	0e 24       	jz	$+30     	;abs 0x99a8

0000998c <.Loc.520.2>:
      gen_failure(buffer, hdr.crc);
    998c:	4d 45       	mov.b	r5,	r13	;
    998e:	cc 08       	mova	r8,	r12	;
    9990:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009994 <.L494>:
    elyCmdSendReply(buffer);
    9994:	cc 08       	mova	r8,	r12	;
    9996:	b0 13 5e 83 	calla	#33630		;0x0835e

0000999a <.L483>:
}
    999a:	a1 00 06 00 	adda	#6,	r1	;
    999e:	64 16       	popm.a	#7,	r10	;20-bit words
    99a0:	10 01       	reta			;

000099a2 <.L491>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    99a2:	64 42       	mov.b	#4,	r4	;r2 As==10
    99a4:	80 00 38 99 	mova	#39224,	r0	;0x09938

000099a8 <.L488>:
      elyErrorSignal(ErrCmdFailure);
    99a8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    99ac:	b0 13 98 c3 	calla	#50072		;0x0c398

000099b0 <.L490>:
    elyNLFreeBuffer(elyNLPack(buffer));
    99b0:	cc 08       	mova	r8,	r12	;
    99b2:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

000099b6 <.LVL689>:
    99b6:	b0 13 42 c1 	calla	#49474		;0x0c142

000099ba <.LVL690>:
    99ba:	80 00 9a 99 	mova	#39322,	r0	;0x0999a

000099be <.L486>:
  bank0w[RegRXBRMsb] = buffer[hdr_ext];
    99be:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    99c2:	ec 44 1f 00 	mov.b	@r4,	31(r12)	; 0x001f

000099c6 <.Loc.532.2>:
  bank0w[RegRXBRHmb] = buffer[hdr_ext+1];
    99c6:	dc 44 01 00 	mov.b	1(r4),	30(r12)	; 0x001e
    99ca:	1e 00 

000099cc <.Loc.533.2>:
  bank0w[RegRXBRLmb] = buffer[hdr_ext+2];
    99cc:	dc 44 02 00 	mov.b	2(r4),	29(r12)	; 0x001d
    99d0:	1d 00 

000099d2 <.Loc.534.2>:
  bank0w[RegRXBRLsb] = buffer[hdr_ext+3];
    99d2:	dc 44 03 00 	mov.b	3(r4),	28(r12)	; 0x001c
    99d6:	1c 00 

000099d8 <.Loc.537.2>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    99d8:	7c 42       	mov.b	#8,	r12	;r2 As==11
    99da:	4d 43       	clr.b	r13		;
    99dc:	b0 13 58 b0 	calla	#45144		;0x0b058

000099e0 <.LVL693>:
  if (hdr.reply) {
    99e0:	07 93       	cmp	#0,	r7	;r3 As==00
    99e2:	e6 27       	jz	$-50     	;abs 0x99b0

000099e4 <.Loc.541.2>:
    gen_success(buffer, hdr.crc);
    99e4:	4d 45       	mov.b	r5,	r13	;
    99e6:	cc 08       	mova	r8,	r12	;
    99e8:	b0 13 b8 7d 	calla	#32184		;0x07db8

000099ec <.LVL694>:
    99ec:	80 00 94 99 	mova	#39316,	r0	;0x09994

000099f0 <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    99f0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000099f2 <.LCFI84>:
    99f2:	08 14       	pushm.a	#1,	r8	;20-bit words

000099f4 <.LCFI85>:
    99f4:	b1 00 02 00 	suba	#2,	r1	;

000099f8 <.LCFI86>:
    99f8:	ca 0c       	mova	r12,	r10	;

000099fa <.Loc.481.2>:
    99fa:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    99fe:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9a02:	01 00 

00009a04 <.Loc.483.2>:
  if (hdr.reply) {
    9a04:	6d 41       	mov.b	@r1,	r13	;
    9a06:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9a0a:	32 24       	jz	$+102    	;abs 0x9a70

00009a0c <.Loc.484.2>:
    buffer[0] = buffer[0] & 0x3F;
    9a0c:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9a10:	00 00 

00009a12 <.Loc.485.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9a12:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

00009a16 <.LVL696>:
    9a16:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9a1a:	02 00 

00009a1c <.Loc.486.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9a1c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9a20:	03 00 

00009a22 <.LVL697>:
    9a22:	ce 0c       	mova	r12,	r14	;
    9a24:	ae 00 1f 00 	adda	#31,	r14	;0x0001f
    9a28:	c8 0a       	mova	r10,	r8	;
    9a2a:	a8 00 04 00 	adda	#4,	r8	;
    9a2e:	ac 00 1b 00 	adda	#27,	r12	;0x0001b

00009a32 <.L497>:
      buffer[i + 4] = bank0p[RegRXBRMsb - i];
    9a32:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

00009a36 <.LVL699>:
    9a36:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9a3a:	a8 00 01 00 	adda	#1,	r8	;

00009a3e <.LVL700>:
    for (int i = 0; i < 4; i++) {
    9a3e:	de 0c       	cmpa	r12,	r14	;
    9a40:	f8 23       	jnz	$-14     	;abs 0x9a32

00009a42 <.LBE105>:
    if (hdr.crc) {
    9a42:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9a46:	10 24       	jz	$+34     	;abs 0x9a68

00009a48 <.Loc.492.2>:
      buffer[1] = 6;
    9a48:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9a4c:	01 00 

00009a4e <.Loc.493.2>:
      crcGenX25(buffer, 10);
    9a4e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9a52:	cc 0a       	mova	r10,	r12	;
    9a54:	b0 13 64 ae 	calla	#44644		;0x0ae64

00009a58 <.L499>:
    elyCmdSendReply(buffer);
    9a58:	cc 0a       	mova	r10,	r12	;
    9a5a:	b0 13 5e 83 	calla	#33630		;0x0835e

00009a5e <.L495>:
}
    9a5e:	a1 00 02 00 	adda	#2,	r1	;
    9a62:	08 16       	popm.a	#1,	r8	;20-bit words
    9a64:	0a 16       	popm.a	#1,	r10	;20-bit words
    9a66:	10 01       	reta			;

00009a68 <.L498>:
      buffer[1] = 4;
    9a68:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9a6c:	80 00 58 9a 	mova	#39512,	r0	;0x09a58

00009a70 <.L496>:
    9a70:	b0 13 68 7f 	calla	#32616		;0x07f68

00009a74 <.LVL705>:
}
    9a74:	80 00 5e 9a 	mova	#39518,	r0	;0x09a5e

00009a78 <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9a78:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009a7a <.LCFI87>:
    9a7a:	b1 00 06 00 	suba	#6,	r1	;

00009a7e <.LCFI88>:
    9a7e:	c8 0c       	mova	r12,	r8	;

00009a80 <.LVL707>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9a80:	65 4d       	mov.b	@r13,	r5	;
    9a82:	55 f3       	and.b	#1,	r5	;r3 As==01
    9a84:	67 4d       	mov.b	@r13,	r7	;
    9a86:	67 f3       	and.b	#2,	r7	;r3 As==10
    9a88:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9a8c:	07 93       	cmp	#0,	r7	;r3 As==00
    9a8e:	36 20       	jnz	$+110    	;abs 0x9afc
    9a90:	64 43       	mov.b	#2,	r4	;r3 As==10

00009a92 <.L503>:
    9a92:	40 18 04 44 	movx.w	r4,	r4	;
    9a96:	e4 08       	adda	r8,	r4	;
    9a98:	cb 04       	mova	r4,	r11	;

00009a9a <.Loc.438.2>:
    9a9a:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009a9e <.Loc.439.2>:
  uint32_t br = 0;
    9a9e:	49 43       	clr.b	r9		;
    9aa0:	0a 49       	mov	r9,	r10	;

00009aa2 <.L504>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9aa2:	6c 4b       	mov.b	@r11,	r12	;
    9aa4:	0d 43       	clr	r13		;
    9aa6:	0e 46       	mov	r6,	r14	;
    9aa8:	0f 43       	clr	r15		;
    9aaa:	71 0b 00 00 	mova	r11,	0(r1)	;
    9aae:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9ab2:	0c d9       	bis	r9,	r12	;
    9ab4:	0d da       	bis	r10,	r13	;
    9ab6:	09 4c       	mov	r12,	r9	;

00009ab8 <.LVL711>:
    9ab8:	0a 4d       	mov	r13,	r10	;

00009aba <.LVL712>:
    9aba:	0b 01       	mova	@r1,	r11	;
    9abc:	ab 00 01 00 	adda	#1,	r11	;
    9ac0:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009ac4 <.Loc.442.2>:
  for (int i = 0; i < 4; i++) {
    9ac4:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9ac8:	ec 23       	jnz	$-38     	;abs 0x9aa2

00009aca <.LBE106>:
  if (br > TX_BR_MAX || 
    9aca:	39 50 50 fb 	add	#-1200,	r9	;#0xfb50

00009ace <.LVL713>:
    9ace:	3a 63       	addc	#-1,	r10	;r3 As==11

00009ad0 <.LVL714>:
    9ad0:	6c 42       	mov.b	#4,	r12	;r2 As==10

00009ad2 <.LVL715>:
    9ad2:	0c 9a       	cmp	r10,	r12	;
    9ad4:	06 28       	jnc	$+14     	;abs 0x9ae2
    9ad6:	0a 9c       	cmp	r12,	r10	;
    9ad8:	1f 20       	jnz	$+64     	;abs 0x9b18
    9ada:	3c 40 30 8f 	mov	#-28880,r12	;#0x8f30
    9ade:	0c 99       	cmp	r9,	r12	;
    9ae0:	1b 2c       	jc	$+56     	;abs 0x9b18

00009ae2 <.L511>:
    if (hdr.reply) {
    9ae2:	07 93       	cmp	#0,	r7	;r3 As==00
    9ae4:	0e 24       	jz	$+30     	;abs 0x9b02

00009ae6 <.Loc.450.2>:
      gen_failure(buffer, hdr.crc);
    9ae6:	4d 45       	mov.b	r5,	r13	;
    9ae8:	cc 08       	mova	r8,	r12	;
    9aea:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009aee <.L513>:
    elyCmdSendReply(buffer);
    9aee:	cc 08       	mova	r8,	r12	;
    9af0:	b0 13 5e 83 	calla	#33630		;0x0835e

00009af4 <.L502>:
}
    9af4:	a1 00 06 00 	adda	#6,	r1	;
    9af8:	64 16       	popm.a	#7,	r10	;20-bit words
    9afa:	10 01       	reta			;

00009afc <.L510>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9afc:	64 42       	mov.b	#4,	r4	;r2 As==10
    9afe:	80 00 92 9a 	mova	#39570,	r0	;0x09a92

00009b02 <.L507>:
      elyErrorSignal(ErrCmdFailure);
    9b02:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9b06:	b0 13 98 c3 	calla	#50072		;0x0c398

00009b0a <.L509>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9b0a:	cc 08       	mova	r8,	r12	;
    9b0c:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009b10 <.LVL722>:
    9b10:	b0 13 42 c1 	calla	#49474		;0x0c142

00009b14 <.LVL723>:
    9b14:	80 00 f4 9a 	mova	#39668,	r0	;0x09af4

00009b18 <.L505>:
  bank0w[RegTXBRMsb] = buffer[hdr_ext];
    9b18:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9b1c:	ec 44 1b 00 	mov.b	@r4,	27(r12)	; 0x001b

00009b20 <.Loc.462.2>:
  bank0w[RegTXBRHmb] = buffer[hdr_ext+1];
    9b20:	dc 44 01 00 	mov.b	1(r4),	26(r12)	; 0x001a
    9b24:	1a 00 

00009b26 <.Loc.463.2>:
  bank0w[RegTXBRLmb] = buffer[hdr_ext+2];
    9b26:	dc 44 02 00 	mov.b	2(r4),	25(r12)	; 0x0019
    9b2a:	19 00 

00009b2c <.Loc.464.2>:
  bank0w[RegTXBRLsb] = buffer[hdr_ext+3];
    9b2c:	dc 44 03 00 	mov.b	3(r4),	24(r12)	; 0x0018
    9b30:	18 00 

00009b32 <.Loc.467.2>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    9b32:	6c 42       	mov.b	#4,	r12	;r2 As==10
    9b34:	4d 43       	clr.b	r13		;
    9b36:	b0 13 58 b0 	calla	#45144		;0x0b058

00009b3a <.LVL726>:
  if (hdr.reply) {
    9b3a:	07 93       	cmp	#0,	r7	;r3 As==00
    9b3c:	e6 27       	jz	$-50     	;abs 0x9b0a

00009b3e <.Loc.471.2>:
    gen_success(buffer, hdr.crc);
    9b3e:	4d 45       	mov.b	r5,	r13	;
    9b40:	cc 08       	mova	r8,	r12	;
    9b42:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009b46 <.LVL727>:
    9b46:	80 00 ee 9a 	mova	#39662,	r0	;0x09aee

00009b4a <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9b4a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009b4c <.LCFI89>:
    9b4c:	08 14       	pushm.a	#1,	r8	;20-bit words

00009b4e <.LCFI90>:
    9b4e:	b1 00 02 00 	suba	#2,	r1	;

00009b52 <.LCFI91>:
    9b52:	ca 0c       	mova	r12,	r10	;

00009b54 <.Loc.411.2>:
    9b54:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9b58:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9b5c:	01 00 

00009b5e <.Loc.413.2>:
  if (hdr.reply) {
    9b5e:	6d 41       	mov.b	@r1,	r13	;
    9b60:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9b64:	32 24       	jz	$+102    	;abs 0x9bca

00009b66 <.Loc.414.2>:
    buffer[0] = buffer[0] & 0x3F;
    9b66:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9b6a:	00 00 

00009b6c <.Loc.415.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9b6c:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

00009b70 <.LVL729>:
    9b70:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9b74:	02 00 

00009b76 <.Loc.416.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9b76:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9b7a:	03 00 

00009b7c <.LVL730>:
    9b7c:	ce 0c       	mova	r12,	r14	;
    9b7e:	ae 00 1b 00 	adda	#27,	r14	;0x0001b
    9b82:	c8 0a       	mova	r10,	r8	;
    9b84:	a8 00 04 00 	adda	#4,	r8	;
    9b88:	ac 00 17 00 	adda	#23,	r12	;0x00017

00009b8c <.L516>:
      buffer[i + 4] = bank0p[RegTXBRMsb - i];
    9b8c:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

00009b90 <.LVL732>:
    9b90:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9b94:	a8 00 01 00 	adda	#1,	r8	;

00009b98 <.LVL733>:
    for (int i = 0; i < 4; i++) {
    9b98:	de 0c       	cmpa	r12,	r14	;
    9b9a:	f8 23       	jnz	$-14     	;abs 0x9b8c

00009b9c <.LBE107>:
    if (hdr.crc) {
    9b9c:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9ba0:	10 24       	jz	$+34     	;abs 0x9bc2

00009ba2 <.Loc.422.2>:
      buffer[1] = 6;
    9ba2:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9ba6:	01 00 

00009ba8 <.Loc.423.2>:
      crcGenX25(buffer, 10);
    9ba8:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9bac:	cc 0a       	mova	r10,	r12	;
    9bae:	b0 13 64 ae 	calla	#44644		;0x0ae64

00009bb2 <.L518>:
    elyCmdSendReply(buffer);
    9bb2:	cc 0a       	mova	r10,	r12	;
    9bb4:	b0 13 5e 83 	calla	#33630		;0x0835e

00009bb8 <.L514>:
}
    9bb8:	a1 00 02 00 	adda	#2,	r1	;
    9bbc:	08 16       	popm.a	#1,	r8	;20-bit words
    9bbe:	0a 16       	popm.a	#1,	r10	;20-bit words
    9bc0:	10 01       	reta			;

00009bc2 <.L517>:
      buffer[1] = 4;
    9bc2:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9bc6:	80 00 b2 9b 	mova	#39858,	r0	;0x09bb2

00009bca <.L515>:
    9bca:	b0 13 68 7f 	calla	#32616		;0x07f68

00009bce <.LVL738>:
}
    9bce:	80 00 b8 9b 	mova	#39864,	r0	;0x09bb8

00009bd2 <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9bd2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009bd4 <.LCFI92>:
    9bd4:	b1 00 06 00 	suba	#6,	r1	;

00009bd8 <.LCFI93>:
    9bd8:	c8 0c       	mova	r12,	r8	;

00009bda <.LVL740>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9bda:	65 4d       	mov.b	@r13,	r5	;
    9bdc:	55 f3       	and.b	#1,	r5	;r3 As==01
    9bde:	67 4d       	mov.b	@r13,	r7	;
    9be0:	67 f3       	and.b	#2,	r7	;r3 As==10
    9be2:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9be6:	07 93       	cmp	#0,	r7	;r3 As==00
    9be8:	38 20       	jnz	$+114    	;abs 0x9c5a
    9bea:	64 43       	mov.b	#2,	r4	;r3 As==10

00009bec <.L522>:
    9bec:	40 18 04 44 	movx.w	r4,	r4	;
    9bf0:	e4 08       	adda	r8,	r4	;
    9bf2:	cb 04       	mova	r4,	r11	;

00009bf4 <.Loc.368.2>:
    9bf4:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009bf8 <.Loc.369.2>:
  uint32_t freq = 0;
    9bf8:	49 43       	clr.b	r9		;
    9bfa:	0a 49       	mov	r9,	r10	;

00009bfc <.L523>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9bfc:	6c 4b       	mov.b	@r11,	r12	;
    9bfe:	0d 43       	clr	r13		;
    9c00:	0e 46       	mov	r6,	r14	;
    9c02:	0f 43       	clr	r15		;
    9c04:	71 0b 00 00 	mova	r11,	0(r1)	;
    9c08:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9c0c:	0c d9       	bis	r9,	r12	;
    9c0e:	0d da       	bis	r10,	r13	;
    9c10:	09 4c       	mov	r12,	r9	;

00009c12 <.LVL744>:
    9c12:	0a 4d       	mov	r13,	r10	;

00009c14 <.LVL745>:
    9c14:	0b 01       	mova	@r1,	r11	;
    9c16:	ab 00 01 00 	adda	#1,	r11	;
    9c1a:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009c1e <.Loc.372.2>:
  for (int i = 0; i < 4; i++) {
    9c1e:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9c22:	ec 23       	jnz	$-38     	;abs 0x9bfc

00009c24 <.LBE108>:
  if (freq > RX_BAND_MAX || 
    9c24:	39 50 c0 bb 	add	#-17472,r9	;#0xbbc0

00009c28 <.LVL746>:
    9c28:	3a 60 c2 e4 	addc	#-6974,	r10	;#0xe4c2

00009c2c <.LVL747>:
    9c2c:	7c 40 d5 00 	mov.b	#213,	r12	;#0x00d5

00009c30 <.LVL748>:
    9c30:	0c 9a       	cmp	r10,	r12	;
    9c32:	06 28       	jnc	$+14     	;abs 0x9c40
    9c34:	0a 9c       	cmp	r12,	r10	;
    9c36:	1f 20       	jnz	$+64     	;abs 0x9c76
    9c38:	3c 40 80 9f 	mov	#-24704,r12	;#0x9f80
    9c3c:	0c 99       	cmp	r9,	r12	;
    9c3e:	1b 2c       	jc	$+56     	;abs 0x9c76

00009c40 <.L530>:
    if (hdr.reply) {
    9c40:	07 93       	cmp	#0,	r7	;r3 As==00
    9c42:	0e 24       	jz	$+30     	;abs 0x9c60

00009c44 <.Loc.380.2>:
      gen_failure(buffer, hdr.crc);
    9c44:	4d 45       	mov.b	r5,	r13	;
    9c46:	cc 08       	mova	r8,	r12	;
    9c48:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009c4c <.L532>:
    elyCmdSendReply(buffer);
    9c4c:	cc 08       	mova	r8,	r12	;
    9c4e:	b0 13 5e 83 	calla	#33630		;0x0835e

00009c52 <.L521>:
}
    9c52:	a1 00 06 00 	adda	#6,	r1	;
    9c56:	64 16       	popm.a	#7,	r10	;20-bit words
    9c58:	10 01       	reta			;

00009c5a <.L529>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9c5a:	64 42       	mov.b	#4,	r4	;r2 As==10
    9c5c:	80 00 ec 9b 	mova	#39916,	r0	;0x09bec

00009c60 <.L526>:
      elyErrorSignal(ErrCmdFailure);
    9c60:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9c64:	b0 13 98 c3 	calla	#50072		;0x0c398

00009c68 <.L528>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9c68:	cc 08       	mova	r8,	r12	;
    9c6a:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009c6e <.LVL755>:
    9c6e:	b0 13 42 c1 	calla	#49474		;0x0c142

00009c72 <.LVL756>:
    9c72:	80 00 52 9c 	mova	#40018,	r0	;0x09c52

00009c76 <.L524>:
  bank0w[RegRXFreqMsb] = buffer[hdr_ext];
    9c76:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9c7a:	ec 44 07 00 	mov.b	@r4,	7(r12)	;

00009c7e <.Loc.392.2>:
  bank0w[RegRXFreqHmb] = buffer[hdr_ext+1];
    9c7e:	dc 44 01 00 	mov.b	1(r4),	6(r12)	;
    9c82:	06 00 

00009c84 <.Loc.393.2>:
  bank0w[RegRXFreqLmb] = buffer[hdr_ext+2];
    9c84:	dc 44 02 00 	mov.b	2(r4),	5(r12)	;
    9c88:	05 00 

00009c8a <.Loc.394.2>:
  bank0w[RegRXFreqLsb] = buffer[hdr_ext+3];
    9c8a:	dc 44 03 00 	mov.b	3(r4),	4(r12)	;
    9c8e:	04 00 

00009c90 <.Loc.397.2>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    9c90:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9c92:	4d 43       	clr.b	r13		;
    9c94:	b0 13 58 b0 	calla	#45144		;0x0b058

00009c98 <.LVL759>:
  if (hdr.reply) {
    9c98:	07 93       	cmp	#0,	r7	;r3 As==00
    9c9a:	e6 27       	jz	$-50     	;abs 0x9c68

00009c9c <.Loc.401.2>:
    gen_success(buffer, hdr.crc);
    9c9c:	4d 45       	mov.b	r5,	r13	;
    9c9e:	cc 08       	mova	r8,	r12	;
    9ca0:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009ca4 <.LVL760>:
    9ca4:	80 00 4c 9c 	mova	#40012,	r0	;0x09c4c

00009ca8 <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9ca8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009caa <.LCFI94>:
    9caa:	08 14       	pushm.a	#1,	r8	;20-bit words

00009cac <.LCFI95>:
    9cac:	b1 00 02 00 	suba	#2,	r1	;

00009cb0 <.LCFI96>:
    9cb0:	ca 0c       	mova	r12,	r10	;

00009cb2 <.Loc.341.2>:
    9cb2:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9cb6:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9cba:	01 00 

00009cbc <.Loc.343.2>:
  if (hdr.reply) {
    9cbc:	6d 41       	mov.b	@r1,	r13	;
    9cbe:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9cc2:	32 24       	jz	$+102    	;abs 0x9d28

00009cc4 <.Loc.344.2>:
    buffer[0] = buffer[0] & 0x3F;
    9cc4:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9cc8:	00 00 

00009cca <.Loc.345.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9cca:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a

00009cce <.LVL762>:
    9cce:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9cd2:	02 00 

00009cd4 <.Loc.346.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9cd4:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9cd8:	03 00 

00009cda <.LVL763>:
    9cda:	ce 0c       	mova	r12,	r14	;
    9cdc:	ae 00 07 00 	adda	#7,	r14	;
    9ce0:	c8 0a       	mova	r10,	r8	;
    9ce2:	a8 00 04 00 	adda	#4,	r8	;
    9ce6:	ac 00 03 00 	adda	#3,	r12	;

00009cea <.L535>:
      buffer[i + 4] = bank0p[RegRXFreqMsb - i];
    9cea:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

00009cee <.LVL765>:
    9cee:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9cf2:	a8 00 01 00 	adda	#1,	r8	;

00009cf6 <.LVL766>:
    for (int i = 0; i < 4; i++) {
    9cf6:	de 0c       	cmpa	r12,	r14	;
    9cf8:	f8 23       	jnz	$-14     	;abs 0x9cea

00009cfa <.LBE109>:
    if (hdr.crc) {
    9cfa:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9cfe:	10 24       	jz	$+34     	;abs 0x9d20

00009d00 <.Loc.352.2>:
      buffer[1] = 6;
    9d00:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9d04:	01 00 

00009d06 <.Loc.353.2>:
      crcGenX25(buffer, 10);
    9d06:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9d0a:	cc 0a       	mova	r10,	r12	;
    9d0c:	b0 13 64 ae 	calla	#44644		;0x0ae64

00009d10 <.L537>:
    elyCmdSendReply(buffer);
    9d10:	cc 0a       	mova	r10,	r12	;
    9d12:	b0 13 5e 83 	calla	#33630		;0x0835e

00009d16 <.L533>:
}
    9d16:	a1 00 02 00 	adda	#2,	r1	;
    9d1a:	08 16       	popm.a	#1,	r8	;20-bit words
    9d1c:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d1e:	10 01       	reta			;

00009d20 <.L536>:
      buffer[1] = 4;
    9d20:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9d24:	80 00 10 9d 	mova	#40208,	r0	;0x09d10

00009d28 <.L534>:
    9d28:	b0 13 68 7f 	calla	#32616		;0x07f68

00009d2c <.LVL771>:
}
    9d2c:	80 00 16 9d 	mova	#40214,	r0	;0x09d16

00009d30 <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9d30:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009d32 <.LCFI97>:
    9d32:	b1 00 06 00 	suba	#6,	r1	;

00009d36 <.LCFI98>:
    9d36:	c8 0c       	mova	r12,	r8	;

00009d38 <.LVL773>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9d38:	65 4d       	mov.b	@r13,	r5	;
    9d3a:	55 f3       	and.b	#1,	r5	;r3 As==01
    9d3c:	67 4d       	mov.b	@r13,	r7	;
    9d3e:	67 f3       	and.b	#2,	r7	;r3 As==10
    9d40:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9d44:	07 93       	cmp	#0,	r7	;r3 As==00
    9d46:	36 20       	jnz	$+110    	;abs 0x9db4
    9d48:	64 43       	mov.b	#2,	r4	;r3 As==10

00009d4a <.L541>:
    9d4a:	40 18 04 44 	movx.w	r4,	r4	;
    9d4e:	e4 08       	adda	r8,	r4	;
    9d50:	cb 04       	mova	r4,	r11	;

00009d52 <.Loc.295.2>:
    9d52:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009d56 <.Loc.296.2>:
  uint32_t freq = 0;
    9d56:	49 43       	clr.b	r9		;
    9d58:	0a 49       	mov	r9,	r10	;

00009d5a <.L542>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9d5a:	6c 4b       	mov.b	@r11,	r12	;
    9d5c:	0d 43       	clr	r13		;
    9d5e:	0e 46       	mov	r6,	r14	;
    9d60:	0f 43       	clr	r15		;
    9d62:	71 0b 00 00 	mova	r11,	0(r1)	;
    9d66:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9d6a:	0c d9       	bis	r9,	r12	;
    9d6c:	0d da       	bis	r10,	r13	;
    9d6e:	09 4c       	mov	r12,	r9	;

00009d70 <.LVL777>:
    9d70:	0a 4d       	mov	r13,	r10	;

00009d72 <.LVL778>:
    9d72:	0b 01       	mova	@r1,	r11	;
    9d74:	ab 00 01 00 	adda	#1,	r11	;
    9d78:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009d7c <.Loc.299.2>:
  for (int i = 0; i < 4; i++) {
    9d7c:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9d80:	ec 23       	jnz	$-38     	;abs 0x9d5a

00009d82 <.LBE110>:
  if (freq > TX_BAND_MAX || 
    9d82:	39 50 c0 25 	add	#9664,	r9	;#0x25c0

00009d86 <.LVL779>:
    9d86:	3a 60 71 cc 	addc	#-13199,r10	;#0xcc71

00009d8a <.LVL780>:
    9d8a:	3c 40 5d 05 	mov	#1373,	r12	;#0x055d

00009d8e <.LVL781>:
    9d8e:	0c 9a       	cmp	r10,	r12	;
    9d90:	06 28       	jnc	$+14     	;abs 0x9d9e
    9d92:	0a 9c       	cmp	r12,	r10	;
    9d94:	1f 20       	jnz	$+64     	;abs 0x9dd4
    9d96:	3c 40 80 4a 	mov	#19072,	r12	;#0x4a80
    9d9a:	0c 99       	cmp	r9,	r12	;
    9d9c:	1b 2c       	jc	$+56     	;abs 0x9dd4

00009d9e <.L549>:
    if (hdr.reply) {
    9d9e:	07 93       	cmp	#0,	r7	;r3 As==00
    9da0:	0c 24       	jz	$+26     	;abs 0x9dba

00009da2 <.Loc.307.2>:
      gen_failure(buffer, hdr.crc);
    9da2:	4d 45       	mov.b	r5,	r13	;
    9da4:	cc 08       	mova	r8,	r12	;
    9da6:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009daa <.L551>:
    elyCmdSendReply(buffer);
    9daa:	cc 08       	mova	r8,	r12	;
    9dac:	b0 13 5e 83 	calla	#33630		;0x0835e

00009db0 <.LVL784>:
    9db0:	80 00 cc 9d 	mova	#40396,	r0	;0x09dcc

00009db4 <.L548>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9db4:	64 42       	mov.b	#4,	r4	;r2 As==10
    9db6:	80 00 4a 9d 	mova	#40266,	r0	;0x09d4a

00009dba <.L545>:
      elyNLFreeBuffer(elyNLPack(buffer));
    9dba:	cc 08       	mova	r8,	r12	;
    9dbc:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009dc0 <.LVL787>:
    9dc0:	b0 13 42 c1 	calla	#49474		;0x0c142

00009dc4 <.LVL788>:
      elyErrorSignal(ErrCmdFailure);
    9dc4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9dc8:	b0 13 98 c3 	calla	#50072		;0x0c398

00009dcc <.L540>:
}
    9dcc:	a1 00 06 00 	adda	#6,	r1	;
    9dd0:	64 16       	popm.a	#7,	r10	;20-bit words
    9dd2:	10 01       	reta			;

00009dd4 <.L543>:
  bank0w[RegTXFreqMsb] = buffer[hdr_ext];
    9dd4:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9dd8:	ec 44 03 00 	mov.b	@r4,	3(r12)	;

00009ddc <.Loc.319.2>:
  bank0w[RegTXFreqHmb] = buffer[hdr_ext+1];
    9ddc:	dc 44 01 00 	mov.b	1(r4),	2(r12)	;
    9de0:	02 00 

00009de2 <.Loc.320.2>:
  bank0w[RegTXFreqLmb] = buffer[hdr_ext+2];
    9de2:	dc 44 02 00 	mov.b	2(r4),	1(r12)	;
    9de6:	01 00 

00009de8 <.Loc.321.2>:
  bank0w[RegTXFreqLsb] = buffer[hdr_ext+3];
    9de8:	dc 44 03 00 	mov.b	3(r4),	0(r12)	;
    9dec:	00 00 

00009dee <.Loc.324.2>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    9dee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9df0:	4d 43       	clr.b	r13		;
    9df2:	b0 13 58 b0 	calla	#45144		;0x0b058

00009df6 <.LVL792>:
  elyEventSignal(EvtTXFreqChange);
    9df6:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    9dfa:	b0 13 b0 c3 	calla	#50096		;0x0c3b0

00009dfe <.LVL793>:
  if (hdr.reply) {
    9dfe:	07 93       	cmp	#0,	r7	;r3 As==00
    9e00:	06 24       	jz	$+14     	;abs 0x9e0e

00009e02 <.Loc.331.2>:
    gen_success(buffer, hdr.crc);
    9e02:	4d 45       	mov.b	r5,	r13	;
    9e04:	cc 08       	mova	r8,	r12	;
    9e06:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009e0a <.LVL794>:
    9e0a:	80 00 aa 9d 	mova	#40362,	r0	;0x09daa

00009e0e <.L547>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9e0e:	cc 08       	mova	r8,	r12	;
    9e10:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009e14 <.LVL795>:
    9e14:	b0 13 42 c1 	calla	#49474		;0x0c142

00009e18 <.LVL796>:
    9e18:	80 00 cc 9d 	mova	#40396,	r0	;0x09dcc

00009e1c <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9e1c:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009e1e <.LCFI99>:
    9e1e:	b1 00 02 00 	suba	#2,	r1	;

00009e22 <.LCFI100>:
    9e22:	ca 0c       	mova	r12,	r10	;

00009e24 <.Loc.249.2>:
    9e24:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9e28:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9e2c:	01 00 

00009e2e <.Loc.251.2>:
  if (hdr.reply) {
    9e2e:	66 41       	mov.b	@r1,	r6	;
    9e30:	40 18 26 b3 	bitx.w	#2,	r6	;r3 As==10
    9e34:	88 24       	jz	$+274    	;abs 0x9f46

00009e36 <.LBB111>:
    buffer[0] = buffer[0] & 0x3F;
    9e36:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9e3a:	00 00 

00009e3c <.Loc.253.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9e3c:	28 01 4a 07 	mova	&67402,	r8	;0x1074a
    9e40:	dc 48 51 00 	mov.b	81(r8),	2(r12)	;0x00051
    9e44:	02 00 

00009e46 <.Loc.254.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9e46:	dc 48 50 00 	mov.b	80(r8),	3(r12)	;0x00050
    9e4a:	03 00 

00009e4c <.LVL798>:
    9e4c:	a8 00 03 00 	adda	#3,	r8	;
    9e50:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

00009e54 <.Loc.256.2>:
    uint32_t freq = 0;
    9e54:	49 43       	clr.b	r9		;
    9e56:	07 49       	mov	r9,	r7	;

00009e58 <.L554>:
      freq |= ((uint32_t)(bank0p[RegTXFreqMsb - i]) << (8 * (3-i)));
    9e58:	6c 48       	mov.b	@r8,	r12	;
    9e5a:	0d 43       	clr	r13		;
    9e5c:	0e 45       	mov	r5,	r14	;
    9e5e:	0f 43       	clr	r15		;
    9e60:	b0 13 48 cd 	calla	#52552		;0x0cd48
    9e64:	09 dc       	bis	r12,	r9	;

00009e66 <.LVL801>:
    9e66:	07 dd       	bis	r13,	r7	;

00009e68 <.LVL802>:
    9e68:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    9e6c:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8

00009e70 <.Loc.257.2>:
    for (int i = 0; i < 4; i++) {
    9e70:	35 90 f8 ff 	cmp	#-8,	r5	;#0xfff8
    9e74:	f1 23       	jnz	$-28     	;abs 0x9e58

00009e76 <.LBE112>:
    if (freq > TX_BAND_MAX) {
    9e76:	3c 40 ec 38 	mov	#14572,	r12	;#0x38ec
    9e7a:	0c 97       	cmp	r7,	r12	;
    9e7c:	06 28       	jnc	$+14     	;abs 0x9e8a
    9e7e:	07 9c       	cmp	r12,	r7	;
    9e80:	40 20       	jnz	$+130    	;abs 0x9f02
    9e82:	3c 40 c0 24 	mov	#9408,	r12	;#0x24c0
    9e86:	0c 99       	cmp	r9,	r12	;
    9e88:	12 2c       	jc	$+38     	;abs 0x9eae

00009e8a <.L562>:
        bank0w[RegTXFreqMsb - i] = ((freq >> (8 * (3 - i))) & 0xFF);
    9e8a:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9e8e:	fc 40 38 00 	mov.b	#56,	3(r12)	;#0x0038
    9e92:	03 00 

00009e94 <.LVL804>:
    9e94:	fc 40 ec ff 	mov.b	#-20,	2(r12)	;#0xffec
    9e98:	02 00 

00009e9a <.LVL805>:
    9e9a:	fc 40 24 00 	mov.b	#36,	1(r12)	;#0x0024
    9e9e:	01 00 

00009ea0 <.LVL806>:
    9ea0:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    9ea4:	00 00 

00009ea6 <.LBE113>:
      freq = TX_BAND_MAX;
    9ea6:	39 40 c0 24 	mov	#9408,	r9	;#0x24c0

00009eaa <.LVL808>:
    9eaa:	37 40 ec 38 	mov	#14572,	r7	;#0x38ec

00009eae <.L557>:
      buffer[i + 4] = ((freq >> (8 * (3 - i))) & 0xFF);
    9eae:	0c 49       	mov	r9,	r12	;
    9eb0:	0d 47       	mov	r7,	r13	;
    9eb2:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    9eb6:	b0 13 70 ce 	calla	#52848		;0x0ce70
    9eba:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

00009ebe <.LVL811>:
    9ebe:	0c 49       	mov	r9,	r12	;
    9ec0:	0d 47       	mov	r7,	r13	;
    9ec2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9ec6:	b0 13 70 ce 	calla	#52848		;0x0ce70
    9eca:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

00009ece <.LVL813>:
    9ece:	0c 49       	mov	r9,	r12	;
    9ed0:	0d 47       	mov	r7,	r13	;
    9ed2:	b0 13 36 ce 	calla	#52790		;0x0ce36
    9ed6:	ca 4c 06 00 	mov.b	r12,	6(r10)	;

00009eda <.LVL815>:
    9eda:	ca 49 07 00 	mov.b	r9,	7(r10)	;

00009ede <.LBE114>:
    if (hdr.crc) {
    9ede:	40 18 16 b3 	bitx.w	#1,	r6	;r3 As==01
    9ee2:	2d 24       	jz	$+92     	;abs 0x9f3e

00009ee4 <.Loc.279.2>:
      buffer[1] = 6;
    9ee4:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9ee8:	01 00 

00009eea <.Loc.280.2>:
      crcGenX25(buffer, 10);
    9eea:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9eee:	cc 0a       	mova	r10,	r12	;
    9ef0:	b0 13 64 ae 	calla	#44644		;0x0ae64

00009ef4 <.L560>:
    elyCmdSendReply(buffer);
    9ef4:	cc 0a       	mova	r10,	r12	;
    9ef6:	b0 13 5e 83 	calla	#33630		;0x0835e

00009efa <.L552>:
}
    9efa:	a1 00 02 00 	adda	#2,	r1	;
    9efe:	55 16       	popm.a	#6,	r10	;20-bit words
    9f00:	10 01       	reta			;

00009f02 <.L555>:
    else if (freq < TX_BAND_MIN) {
    9f02:	3c 40 8e 33 	mov	#13198,	r12	;#0x338e
    9f06:	0c 97       	cmp	r7,	r12	;
    9f08:	d2 2b       	jnc	$-90     	;abs 0x9eae
    9f0a:	07 9c       	cmp	r12,	r7	;
    9f0c:	04 20       	jnz	$+10     	;abs 0x9f16
    9f0e:	3c 40 3f da 	mov	#-9665,	r12	;#0xda3f
    9f12:	0c 99       	cmp	r9,	r12	;
    9f14:	cc 2b       	jnc	$-102    	;abs 0x9eae

00009f16 <.L563>:
        bank0w[RegTXFreqMsb - i] = ((freq >> (8 * (3 - i))) & 0xFF);
    9f16:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    9f1a:	fc 40 33 00 	mov.b	#51,	3(r12)	;#0x0033
    9f1e:	03 00 

00009f20 <.LVL821>:
    9f20:	fc 40 8e ff 	mov.b	#-114,	2(r12)	;#0xff8e
    9f24:	02 00 

00009f26 <.LVL822>:
    9f26:	fc 40 da ff 	mov.b	#-38,	1(r12)	;#0xffda
    9f2a:	01 00 

00009f2c <.LVL823>:
    9f2c:	fc 40 40 00 	mov.b	#64,	0(r12)	;#0x0040
    9f30:	00 00 

00009f32 <.LBE115>:
      freq = TX_BAND_MIN;
    9f32:	39 40 40 da 	mov	#-9664,	r9	;#0xda40

00009f36 <.LVL825>:
    9f36:	37 40 8e 33 	mov	#13198,	r7	;#0x338e

00009f3a <.LBB116>:
    9f3a:	80 00 ae 9e 	mova	#40622,	r0	;0x09eae

00009f3e <.L559>:
      buffer[1] = 4;
    9f3e:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9f42:	80 00 f4 9e 	mova	#40692,	r0	;0x09ef4

00009f46 <.L553>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9f46:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009f4a <.LVL828>:
    9f4a:	b0 13 42 c1 	calla	#49474		;0x0c142

00009f4e <.LVL829>:
}
    9f4e:	80 00 fa 9e 	mova	#40698,	r0	;0x09efa

00009f52 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9f52:	4a 14       	pushm.a	#5,	r10	;20-bit words

00009f54 <.LCFI101>:
    9f54:	b1 00 02 00 	suba	#2,	r1	;

00009f58 <.LCFI102>:
    9f58:	ca 0c       	mova	r12,	r10	;

00009f5a <.LVL831>:
    9f5a:	5f 4d 01 00 	mov.b	1(r13),	r15	;

00009f5e <.LVL832>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9f5e:	67 4d       	mov.b	@r13,	r7	;
    9f60:	57 f3       	and.b	#1,	r7	;r3 As==01
    9f62:	66 4d       	mov.b	@r13,	r6	;
    9f64:	4b 46       	mov.b	r6,	r11	;
    9f66:	6b f3       	and.b	#2,	r11	;r3 As==10
    9f68:	49 4b       	mov.b	r11,	r9	;
    9f6a:	09 93       	cmp	#0,	r9	;r3 As==00
    9f6c:	24 20       	jnz	$+74     	;abs 0x9fb6
    9f6e:	68 43       	mov.b	#2,	r8	;r3 As==10

00009f70 <.L566>:
  uint8_t bank = buffer[hdr_ext];
    9f70:	40 18 08 48 	movx.w	r8,	r8	;
    9f74:	ce 0a       	mova	r10,	r14	;
    9f76:	ee 08       	adda	r8,	r14	;
    9f78:	6c 4e       	mov.b	@r14,	r12	;

00009f7a <.LVL834>:
  uint8_t addr = buffer[hdr_ext+1];
    9f7a:	5e 4e 01 00 	mov.b	1(r14),	r14	;

00009f7e <.LVL835>:
    9f7e:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

00009f82 <.Loc.221.2>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9f82:	16 b3       	bit	#1,	r6	;r3 As==01
    9f84:	1b 20       	jnz	$+56     	;abs 0x9fbc

00009f86 <.Loc.221.2>:
    9f86:	4d 43       	clr.b	r13		;

00009f88 <.L567>:
    9f88:	4f 8b       	sub.b	r11,	r15	;

00009f8a <.LVL837>:
  if (!elyRegSetBlock(bank, buffer + hdr_ext + 2, addr, count)) {
    9f8a:	a8 00 02 00 	adda	#2,	r8	;

00009f8e <.LVL838>:
    9f8e:	4f 8d       	sub.b	r13,	r15	;
    9f90:	cd 0a       	mova	r10,	r13	;
    9f92:	ed 08       	adda	r8,	r13	;
    9f94:	b0 13 24 a9 	calla	#43300		;0x0a924

00009f98 <.LVL839>:
    9f98:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9f9a:	1e 20       	jnz	$+62     	;abs 0x9fd8

00009f9c <.Loc.224.2>:
    if (hdr.reply) {
    9f9c:	09 93       	cmp	#0,	r9	;r3 As==00
    9f9e:	11 24       	jz	$+36     	;abs 0x9fc2

00009fa0 <.Loc.226.2>:
      gen_failure(buffer, hdr.crc);
    9fa0:	4d 47       	mov.b	r7,	r13	;
    9fa2:	cc 0a       	mova	r10,	r12	;
    9fa4:	b0 13 f6 7d 	calla	#32246		;0x07df6

00009fa8 <.L574>:
    elyCmdSendReply(buffer);
    9fa8:	cc 0a       	mova	r10,	r12	;
    9faa:	b0 13 5e 83 	calla	#33630		;0x0835e

00009fae <.L565>:
}
    9fae:	a1 00 02 00 	adda	#2,	r1	;
    9fb2:	46 16       	popm.a	#5,	r10	;20-bit words
    9fb4:	10 01       	reta			;

00009fb6 <.L572>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9fb6:	68 42       	mov.b	#4,	r8	;r2 As==10
    9fb8:	80 00 70 9f 	mova	#40816,	r0	;0x09f70

00009fbc <.L573>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9fbc:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009fbe <.LVL844>:
    9fbe:	80 00 88 9f 	mova	#40840,	r0	;0x09f88

00009fc2 <.L569>:
      elyErrorSignal(ErrCmdFailure);
    9fc2:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9fc6:	b0 13 98 c3 	calla	#50072		;0x0c398

00009fca <.L571>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9fca:	cc 0a       	mova	r10,	r12	;
    9fcc:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

00009fd0 <.LVL847>:
    9fd0:	b0 13 42 c1 	calla	#49474		;0x0c142

00009fd4 <.LVL848>:
    9fd4:	80 00 ae 9f 	mova	#40878,	r0	;0x09fae

00009fd8 <.L568>:
  if (hdr.reply) {
    9fd8:	09 93       	cmp	#0,	r9	;r3 As==00
    9fda:	f7 27       	jz	$-16     	;abs 0x9fca

00009fdc <.Loc.240.2>:
    gen_success(buffer, hdr.crc);
    9fdc:	4d 47       	mov.b	r7,	r13	;
    9fde:	cc 0a       	mova	r10,	r12	;
    9fe0:	b0 13 b8 7d 	calla	#32184		;0x07db8

00009fe4 <.LVL849>:
    9fe4:	80 00 a8 9f 	mova	#40872,	r0	;0x09fa8

00009fe8 <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9fe8:	4a 14       	pushm.a	#5,	r10	;20-bit words

00009fea <.LCFI103>:
    9fea:	b1 00 02 00 	suba	#2,	r1	;

00009fee <.LCFI104>:
    9fee:	ca 0c       	mova	r12,	r10	;
    9ff0:	67 4d       	mov.b	@r13,	r7	;
    9ff2:	57 f3       	and.b	#1,	r7	;r3 As==01

00009ff4 <.Loc.185.2>:
    9ff4:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9ff8:	01 00 

00009ffa <.Loc.187.2>:
  if (hdr.reply) { /* reply requested */
    9ffa:	69 4d       	mov.b	@r13,	r9	;
    9ffc:	59 c3       	bic.b	#1,	r9	;r3 As==01
    9ffe:	49 d7       	bis.b	r7,	r9	;
    a000:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    a004:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    a008:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    a00c:	3c 24       	jz	$+122    	;abs 0xa086

0000a00e <.LBB118>:
    uint8_t count = buffer[6];
    a00e:	56 4c 06 00 	mov.b	6(r12),	r6	;

0000a012 <.LVL854>:
    if (!elyRegGetBlock(bank, buffer + 4, addr, count)) {
    a012:	4f 46       	mov.b	r6,	r15	;
    a014:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    a018:	cd 0c       	mova	r12,	r13	;
    a01a:	ad 00 04 00 	adda	#4,	r13	;

0000a01e <.LVL855>:
    a01e:	5c 4c 04 00 	mov.b	4(r12),	r12	;

0000a022 <.LVL856>:
    a022:	b0 13 86 a8 	calla	#43142		;0x0a886

0000a026 <.LVL857>:
    a026:	88 00 5e 83 	mova	#33630,	r8	;0x0835e
    a02a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a02c:	0a 20       	jnz	$+22     	;abs 0xa042

0000a02e <.Loc.194.2>:
      gen_failure(buffer, hdr.crc);
    a02e:	4d 47       	mov.b	r7,	r13	;
    a030:	cc 0a       	mova	r10,	r12	;
    a032:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000a036 <.L580>:
    elyCmdSendReply(buffer);
    a036:	cc 0a       	mova	r10,	r12	;
    a038:	48 13       	calla	r8		;

0000a03a <.L575>:
}
    a03a:	a1 00 02 00 	adda	#2,	r1	;
    a03e:	46 16       	popm.a	#5,	r10	;20-bit words
    a040:	10 01       	reta			;

0000a042 <.L577>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    a042:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    a046:	00 00 

0000a048 <.Loc.201.2>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    a048:	0c 49       	mov	r9,	r12	;
    a04a:	5c f3       	and.b	#1,	r12	;r3 As==01
    a04c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a04e:	18 20       	jnz	$+50     	;abs 0xa080
    a050:	0d 4c       	mov	r12,	r13	;

0000a052 <.L579>:
    a052:	4d 56       	add.b	r6,	r13	;
    a054:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

0000a058 <.Loc.202.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    a058:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    a05c:	da 4e 51 00 	mov.b	81(r14),2(r10)	;0x00051
    a060:	02 00 

0000a062 <.Loc.203.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    a062:	da 4e 50 00 	mov.b	80(r14),3(r10)	;0x00050
    a066:	03 00 

0000a068 <.Loc.205.2>:
    if (hdr.crc) {
    a068:	0c 93       	cmp	#0,	r12	;r3 As==00
    a06a:	e5 27       	jz	$-52     	;abs 0xa036

0000a06c <.Loc.206.2>:
      crcGenX25(buffer, count + 6);
    a06c:	0d 46       	mov	r6,	r13	;
    a06e:	3d 50 06 00 	add	#6,	r13	;
    a072:	4d 0e       	rlam.a	#4,	r13	;
    a074:	4d 0d       	rram.a	#4,	r13	;
    a076:	cc 0a       	mova	r10,	r12	;
    a078:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000a07c <.LVL861>:
    a07c:	80 00 36 a0 	mova	#41014,	r0	;0x0a036

0000a080 <.L581>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    a080:	6d 43       	mov.b	#2,	r13	;r3 As==10
    a082:	80 00 52 a0 	mova	#41042,	r0	;0x0a052

0000a086 <.L576>:
    elyNLFreeBuffer(elyNLPack(buffer));
    a086:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000a08a <.LVL863>:
    a08a:	b0 13 42 c1 	calla	#49474		;0x0c142

0000a08e <.LVL864>:
    a08e:	80 00 3a a0 	mova	#41018,	r0	;0x0a03a

0000a092 <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a092:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a094 <.LCFI105>:
    a094:	b1 00 02 00 	suba	#2,	r1	;

0000a098 <.LCFI106>:
    a098:	ca 0c       	mova	r12,	r10	;

0000a09a <.LVL866>:
    a09a:	5e 4d 01 00 	mov.b	1(r13),	r14	;

0000a09e <.LVL867>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    a09e:	68 4d       	mov.b	@r13,	r8	;
    a0a0:	58 f3       	and.b	#1,	r8	;r3 As==01
    a0a2:	6f 4d       	mov.b	@r13,	r15	;
    a0a4:	49 4f       	mov.b	r15,	r9	;
    a0a6:	69 f3       	and.b	#2,	r9	;r3 As==10
    a0a8:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    a0ac:	09 93       	cmp	#0,	r9	;r3 As==00
    a0ae:	24 24       	jz	$+74     	;abs 0xa0f8

0000a0b0 <.Loc.154.2>:
    a0b0:	5c 4a 04 00 	mov.b	4(r10),	r12	;

0000a0b4 <.LVL868>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    a0b4:	7d 40 05 00 	mov.b	#5,	r13	;

0000a0b8 <.L587>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    a0b8:	1f b3       	bit	#1,	r15	;r3 As==01
    a0ba:	24 20       	jnz	$+74     	;abs 0xa104

0000a0bc <.Loc.156.2>:
    a0bc:	4f 43       	clr.b	r15		;

0000a0be <.L588>:
    a0be:	0e 8f       	sub	r15,	r14	;

0000a0c0 <.LVL871>:
    a0c0:	0e 89       	sub	r9,	r14	;
    a0c2:	0f 4e       	mov	r14,	r15	;
    a0c4:	5f 03       	rrum	#1,	r15	;
    a0c6:	4d 18 0f 11 	rpt #14 { rrax.w	r15		;
    a0ca:	0e 5f       	add	r15,	r14	;

0000a0cc <.Loc.158.2>:
  if (!elyRegSet(bank, buffer + regs_offset, num_regs)) {
    a0cc:	40 18 0d 4d 	movx.w	r13,	r13	;
    a0d0:	12 c3       	clrc			
    a0d2:	0e 10       	rrc	r14		;
    a0d4:	ed 0a       	adda	r10,	r13	;

0000a0d6 <.LVL872>:
    a0d6:	b0 13 de a7 	calla	#42974		;0x0a7de

0000a0da <.LVL873>:
    a0da:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a0dc:	21 20       	jnz	$+68     	;abs 0xa120

0000a0de <.Loc.159.2>:
    if (hdr.reply) {
    a0de:	09 93       	cmp	#0,	r9	;r3 As==00
    a0e0:	14 24       	jz	$+42     	;abs 0xa10a

0000a0e2 <.Loc.161.2>:
      gen_failure(buffer, hdr.crc);
    a0e2:	4d 48       	mov.b	r8,	r13	;
    a0e4:	cc 0a       	mova	r10,	r12	;
    a0e6:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000a0ea <.L594>:
    elyCmdSendReply(buffer);
    a0ea:	cc 0a       	mova	r10,	r12	;
    a0ec:	b0 13 5e 83 	calla	#33630		;0x0835e

0000a0f0 <.L585>:
}
    a0f0:	a1 00 02 00 	adda	#2,	r1	;
    a0f4:	28 16       	popm.a	#3,	r10	;20-bit words
    a0f6:	10 01       	reta			;

0000a0f8 <.L586>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    a0f8:	5c 4a 02 00 	mov.b	2(r10),	r12	;

0000a0fc <.LVL877>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    a0fc:	7d 40 03 00 	mov.b	#3,	r13	;

0000a100 <.LVL878>:
    a100:	80 00 b8 a0 	mova	#41144,	r0	;0x0a0b8

0000a104 <.L593>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    a104:	6f 43       	mov.b	#2,	r15	;r3 As==10

0000a106 <.LVL880>:
    a106:	80 00 be a0 	mova	#41150,	r0	;0x0a0be

0000a10a <.L590>:
      elyErrorSignal(ErrCmdFailure);
    a10a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    a10e:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a112 <.L592>:
    elyNLFreeBuffer(elyNLPack(buffer));
    a112:	cc 0a       	mova	r10,	r12	;
    a114:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000a118 <.LVL883>:
    a118:	b0 13 42 c1 	calla	#49474		;0x0c142

0000a11c <.LVL884>:
    a11c:	80 00 f0 a0 	mova	#41200,	r0	;0x0a0f0

0000a120 <.L589>:
  if (hdr.reply) {
    a120:	09 93       	cmp	#0,	r9	;r3 As==00
    a122:	f7 27       	jz	$-16     	;abs 0xa112

0000a124 <.Loc.175.2>:
    gen_success(buffer, hdr.crc);
    a124:	4d 48       	mov.b	r8,	r13	;
    a126:	cc 0a       	mova	r10,	r12	;
    a128:	b0 13 b8 7d 	calla	#32184		;0x07db8

0000a12c <.LVL885>:
    a12c:	80 00 ea a0 	mova	#41194,	r0	;0x0a0ea

0000a130 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a130:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a132 <.LCFI107>:
    a132:	b1 00 02 00 	suba	#2,	r1	;

0000a136 <.LCFI108>:
    a136:	ca 0c       	mova	r12,	r10	;
    a138:	67 4d       	mov.b	@r13,	r7	;
    a13a:	57 f3       	and.b	#1,	r7	;r3 As==01

0000a13c <.LVL887>:
    a13c:	55 4d 01 00 	mov.b	1(r13),	r5	;

0000a140 <.LVL888>:
    a140:	c1 45 01 00 	mov.b	r5,	1(r1)	;

0000a144 <.Loc.124.2>:
  if (hdr.reply) {
    a144:	69 4d       	mov.b	@r13,	r9	;
    a146:	59 c3       	bic.b	#1,	r9	;r3 As==01
    a148:	49 d7       	bis.b	r7,	r9	;
    a14a:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    a14e:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    a152:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    a156:	3c 24       	jz	$+122    	;abs 0xa1d0

0000a158 <.LBB120>:
    uint8_t bank = buffer[4];
    a158:	5c 4c 04 00 	mov.b	4(r12),	r12	;

0000a15c <.LVL890>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    a15c:	59 f3       	and.b	#1,	r9	;r3 As==01
    a15e:	09 93       	cmp	#0,	r9	;r3 As==00
    a160:	1b 24       	jz	$+56     	;abs 0xa198
    a162:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000a164 <.L597>:
    a164:	75 50 fd ff 	add.b	#-3,	r5	;#0xfffd

0000a168 <.LVL892>:
    a168:	40 18 4e 45 	movx.b	r5,	r14	;
    a16c:	40 18 4e 8d 	subx.b	r13,	r14	;
    a170:	46 4e       	mov.b	r14,	r6	;

0000a172 <.LVL893>:
    if (!elyRegGet(bank, buffer + regs_offset, num_regs)) {
    a172:	cd 0a       	mova	r10,	r13	;
    a174:	ad 00 05 00 	adda	#5,	r13	;
    a178:	b0 13 30 a7 	calla	#42800		;0x0a730

0000a17c <.LVL894>:
    a17c:	88 00 5e 83 	mova	#33630,	r8	;0x0835e
    a180:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a182:	0d 20       	jnz	$+28     	;abs 0xa19e

0000a184 <.Loc.131.2>:
      gen_failure(buffer, hdr.crc);
    a184:	4d 47       	mov.b	r7,	r13	;
    a186:	cc 0a       	mova	r10,	r12	;
    a188:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000a18c <.L600>:
    elyCmdSendReply(buffer);
    a18c:	cc 0a       	mova	r10,	r12	;
    a18e:	48 13       	calla	r8		;

0000a190 <.L595>:
}
    a190:	a1 00 02 00 	adda	#2,	r1	;
    a194:	55 16       	popm.a	#6,	r10	;20-bit words
    a196:	10 01       	reta			;

0000a198 <.L601>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    a198:	0d 49       	mov	r9,	r13	;

0000a19a <.LVL898>:
    a19a:	80 00 64 a1 	mova	#41316,	r0	;0x0a164

0000a19e <.L598>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    a19e:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    a1a2:	00 00 

0000a1a4 <.Loc.138.2>:
    buffer[1] = hdr.length - 3; /* no Reply Address, no Bank Index */
    a1a4:	ca 45 01 00 	mov.b	r5,	1(r10)	;

0000a1a8 <.Loc.139.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    a1a8:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    a1ac:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    a1b0:	02 00 

0000a1b2 <.Loc.140.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    a1b2:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    a1b6:	03 00 

0000a1b8 <.Loc.142.2>:
    if (hdr.crc) {
    a1b8:	09 93       	cmp	#0,	r9	;r3 As==00
    a1ba:	e8 27       	jz	$-46     	;abs 0xa18c

0000a1bc <.Loc.143.2>:
      crcGenX25(buffer, num_regs + 6);
    a1bc:	0d 46       	mov	r6,	r13	;
    a1be:	3d 50 06 00 	add	#6,	r13	;
    a1c2:	4d 0e       	rlam.a	#4,	r13	;
    a1c4:	4d 0d       	rram.a	#4,	r13	;
    a1c6:	cc 0a       	mova	r10,	r12	;
    a1c8:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000a1cc <.LVL900>:
    a1cc:	80 00 8c a1 	mova	#41356,	r0	;0x0a18c

0000a1d0 <.L596>:
    elyNLFreeBuffer(elyNLPack(buffer));
    a1d0:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000a1d4 <.LVL902>:
    a1d4:	b0 13 42 c1 	calla	#49474		;0x0c142

0000a1d8 <.LVL903>:
    a1d8:	80 00 90 a1 	mova	#41360,	r0	;0x0a190

0000a1dc <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a1dc:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a1de <.LCFI109>:
    a1de:	b1 00 02 00 	suba	#2,	r1	;

0000a1e2 <.LCFI110>:
    a1e2:	ca 0c       	mova	r12,	r10	;
    a1e4:	6e 4d       	mov.b	@r13,	r14	;
    a1e6:	5e f3       	and.b	#1,	r14	;r3 As==01

0000a1e8 <.LVL905>:
    a1e8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    a1ec:	01 00 

0000a1ee <.Loc.105.2>:
  if (hdr.reply) { /* reply requested */
    a1ee:	6d 4d       	mov.b	@r13,	r13	;
    a1f0:	5d c3       	bic.b	#1,	r13	;r3 As==01
    a1f2:	4d de       	bis.b	r14,	r13	;
    a1f4:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    a1f8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a1fc:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    a200:	20 24       	jz	$+66     	;abs 0xa242

0000a202 <.Loc.106.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    a202:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    a206:	00 00 

0000a208 <.Loc.107.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    a208:	4e 5e       	rla.b	r14		;

0000a20a <.LVL907>:
    a20a:	5e 53       	inc.b	r14		;
    a20c:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000a210 <.Loc.108.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    a210:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    a214:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    a218:	02 00 

0000a21a <.Loc.109.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    a21a:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    a21e:	03 00 

0000a220 <.Loc.110.2>:
    buffer[4] = bank0p[RegActiveBank];
    a220:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    a224:	04 00 

0000a226 <.Loc.111.2>:
    if (hdr.crc) {
    a226:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    a22a:	04 24       	jz	$+10     	;abs 0xa234

0000a22c <.Loc.112.2>:
      crcGenX25(buffer, 7);
    a22c:	7d 40 07 00 	mov.b	#7,	r13	;
    a230:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000a234 <.L607>:
    elyCmdSendReply(buffer);
    a234:	cc 0a       	mova	r10,	r12	;
    a236:	b0 13 5e 83 	calla	#33630		;0x0835e

0000a23a <.L605>:
}
    a23a:	a1 00 02 00 	adda	#2,	r1	;
    a23e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a240:	10 01       	reta			;

0000a242 <.L606>:
    a242:	b0 13 68 7f 	calla	#32616		;0x07f68

0000a246 <.LVL911>:
    a246:	80 00 3a a2 	mova	#41530,	r0	;0x0a23a

0000a24a <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a24a:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000a24c <.LCFI111>:
    a24c:	b1 00 02 00 	suba	#2,	r1	;

0000a250 <.LCFI112>:
    a250:	ca 0c       	mova	r12,	r10	;
    a252:	68 4d       	mov.b	@r13,	r8	;
    a254:	58 f3       	and.b	#1,	r8	;r3 As==01

0000a256 <.Loc.64.2>:
    a256:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    a25a:	01 00 

0000a25c <.Loc.65.2>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    a25c:	69 4d       	mov.b	@r13,	r9	;
    a25e:	59 c3       	bic.b	#1,	r9	;r3 As==01
    a260:	49 d8       	bis.b	r8,	r9	;
    a262:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    a266:	69 f3       	and.b	#2,	r9	;r3 As==10
    a268:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    a26c:	09 93       	cmp	#0,	r9	;r3 As==00
    a26e:	13 20       	jnz	$+40     	;abs 0xa296
    a270:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000a272 <.L613>:
    a272:	ec 0a       	adda	r10,	r12	;
    a274:	67 4c       	mov.b	@r12,	r7	;

0000a276 <.LVL916>:
  if (arg > 1) {
    a276:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a278 <.LVL917>:
    a278:	4c 97       	cmp.b	r7,	r12	;
    a27a:	1b 2c       	jc	$+56     	;abs 0xa2b2

0000a27c <.Loc.68.2>:
    if (hdr.reply) {
    a27c:	09 93       	cmp	#0,	r9	;r3 As==00
    a27e:	0e 24       	jz	$+30     	;abs 0xa29c

0000a280 <.Loc.70.2>:
      gen_failure(buffer, hdr.crc);
    a280:	4d 48       	mov.b	r8,	r13	;
    a282:	cc 0a       	mova	r10,	r12	;
    a284:	b0 13 f6 7d 	calla	#32246		;0x07df6

0000a288 <.L620>:
    elyCmdSendReply(buffer);
    a288:	cc 0a       	mova	r10,	r12	;
    a28a:	b0 13 5e 83 	calla	#33630		;0x0835e

0000a28e <.L612>:
}
    a28e:	a1 00 02 00 	adda	#2,	r1	;
    a292:	37 16       	popm.a	#4,	r10	;20-bit words
    a294:	10 01       	reta			;

0000a296 <.L619>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    a296:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a298:	80 00 72 a2 	mova	#41586,	r0	;0x0a272

0000a29c <.L615>:
      elyErrorSignal(ErrCmdFailure);
    a29c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    a2a0:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a2a4 <.L618>:
    elyNLFreeBuffer(elyNLPack(buffer));
    a2a4:	cc 0a       	mova	r10,	r12	;
    a2a6:	b0 13 c8 c2 	calla	#49864		;0x0c2c8

0000a2aa <.LVL923>:
    a2aa:	b0 13 42 c1 	calla	#49474		;0x0c142

0000a2ae <.LVL924>:
    a2ae:	80 00 8e a2 	mova	#41614,	r0	;0x0a28e

0000a2b2 <.L614>:
  if (bank0p[RegGPOState] != arg) {
    a2b2:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    a2b6:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    a2ba:	16 24       	jz	$+46     	;abs 0xa2e8

0000a2bc <.Loc.85.2>:
    palWriteLine(LINE_GPO, arg);
    a2bc:	0c 47       	mov	r7,	r12	;
    a2be:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    a2c2:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    a2c6:	40 18 1d 42 	movx.w	&0x00222,r13	;
    a2ca:	22 02 
    a2cc:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    a2d0:	0c dd       	bis	r13,	r12	;
    a2d2:	40 18 82 4c 	movx.w	r12,	&0x00222;
    a2d6:	22 02 

0000a2d8 <.Loc.87.2>:
    elyEventSignal(EvtGPOChange);
    a2d8:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    a2dc:	b0 13 b0 c3 	calla	#50096		;0x0c3b0

0000a2e0 <.LVL925>:
    bank0w[RegGPOState] = arg;
    a2e0:	2c 01 46 07 	mova	&67398,	r12	;0x10746
    a2e4:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

0000a2e8 <.L617>:
  if (hdr.reply) {
    a2e8:	09 93       	cmp	#0,	r9	;r3 As==00
    a2ea:	dc 27       	jz	$-70     	;abs 0xa2a4

0000a2ec <.Loc.93.2>:
    gen_success(buffer, hdr.crc);
    a2ec:	4d 48       	mov.b	r8,	r13	;
    a2ee:	cc 0a       	mova	r10,	r12	;
    a2f0:	b0 13 b8 7d 	calla	#32184		;0x07db8

0000a2f4 <.LVL926>:
    a2f4:	80 00 88 a2 	mova	#41608,	r0	;0x0a288

0000a2f8 <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a2f8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a2fa <.LCFI113>:
    a2fa:	b1 00 02 00 	suba	#2,	r1	;

0000a2fe <.LCFI114>:
    a2fe:	ca 0c       	mova	r12,	r10	;
    a300:	6e 4d       	mov.b	@r13,	r14	;
    a302:	5e f3       	and.b	#1,	r14	;r3 As==01

0000a304 <.LVL928>:
    a304:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    a308:	01 00 

0000a30a <.Loc.46.2>:
  if (hdr.reply) { /* reply requested */
    a30a:	6d 4d       	mov.b	@r13,	r13	;
    a30c:	5d c3       	bic.b	#1,	r13	;r3 As==01
    a30e:	4d de       	bis.b	r14,	r13	;
    a310:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    a314:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a318:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    a31c:	20 24       	jz	$+66     	;abs 0xa35e

0000a31e <.Loc.47.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    a31e:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    a322:	00 00 

0000a324 <.Loc.48.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    a324:	4e 5e       	rla.b	r14		;

0000a326 <.LVL930>:
    a326:	5e 53       	inc.b	r14		;
    a328:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000a32c <.Loc.49.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    a32c:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    a330:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    a334:	02 00 

0000a336 <.Loc.50.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    a336:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    a33a:	03 00 

0000a33c <.Loc.51.2>:
    buffer[4] = bank0p[RegGPOState];
    a33c:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    a340:	04 00 

0000a342 <.Loc.52.2>:
    if (hdr.crc) {
    a342:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    a346:	04 24       	jz	$+10     	;abs 0xa350

0000a348 <.Loc.53.2>:
      crcGenX25(buffer, 7);
    a348:	7d 40 07 00 	mov.b	#7,	r13	;
    a34c:	b0 13 64 ae 	calla	#44644		;0x0ae64

0000a350 <.L623>:
    elyCmdSendReply(buffer);
    a350:	cc 0a       	mova	r10,	r12	;
    a352:	b0 13 5e 83 	calla	#33630		;0x0835e

0000a356 <.L621>:
}
    a356:	a1 00 02 00 	adda	#2,	r1	;
    a35a:	0a 16       	popm.a	#1,	r10	;20-bit words
    a35c:	10 01       	reta			;

0000a35e <.L622>:
    a35e:	b0 13 68 7f 	calla	#32616		;0x07f68

0000a362 <.LVL934>:
    a362:	80 00 56 a3 	mova	#41814,	r0	;0x0a356

0000a366 <clamp>:

/* TODO persistent, really? */
static BSEMAPHORE_DECL(regs_sem, 1); /* 1 is taken which is cnt == 0 */
static uint8_t regs_in_progress = 0;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a366:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000a368 <.LCFI0>:
    a368:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a36c:	49 4d       	mov.b	r13,	r9	;
    a36e:	4a 4e       	mov.b	r14,	r10	;

0000a370 <.Loc.153.1>:
  if (value < min) {
    a370:	4c 99       	cmp.b	r9,	r12	;
    a372:	07 2c       	jc	$+16     	;abs 0xa382

0000a374 <.LVL1>:
    value = min;
    elyErrorSignal(ErrRegClip);
    a374:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a378:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a37c <.LVL2>:
    a37c:	0c 49       	mov	r9,	r12	;

0000a37e <.L3>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    a37e:	19 16       	popm.a	#2,	r10	;20-bit words
    a380:	10 01       	reta			;

0000a382 <.L2>:
  else if (value > max) {
    a382:	4a 9c       	cmp.b	r12,	r10	;
    a384:	fc 2f       	jc	$-6      	;abs 0xa37e

0000a386 <.LVL5>:
    elyErrorSignal(ErrRegClip);
    a386:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a38a:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a38e <.LVL6>:
    a38e:	0c 4a       	mov	r10,	r12	;
    a390:	80 00 7e a3 	mova	#41854,	r0	;0x0a37e

0000a394 <fram_reg_cb>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    a394:	40 18 5c 42 	movx.b	&0x0d19c,r12	;
    a398:	9c d1 

0000a39a <.LVL8>:
    a39a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a39c:	40 18 c2 4c 	movx.b	r12,	&0xfd19c;
    a3a0:	9c d1 

0000a3a2 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    a3a2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a3a4:	10 20       	jnz	$+34     	;abs 0xa3c6

0000a3a6 <.LBB14>:
    chSysLockFromISR();
    a3a6:	b0 13 a6 45 	calla	#17830		;0x045a6

0000a3aa <.LBB16>:
  chDbgCheckClassI();
    a3aa:	b0 13 54 46 	calla	#18004		;0x04654

0000a3ae <.LVL11>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a3ae:	40 18 1c 42 	movx.w	&0x0d19e,r12	;
    a3b2:	9e d1 
    a3b4:	4d 43       	clr.b	r13		;
    a3b6:	0d 9c       	cmp	r12,	r13	;
    a3b8:	04 38       	jl	$+10     	;abs 0xa3c2

0000a3ba <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a3ba:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a3be:	b0 13 fe 4a 	calla	#19198		;0x04afe

0000a3c2 <.L6>:
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
    a3c2:	b0 13 d0 45 	calla	#17872		;0x045d0

0000a3c6 <.L4>:
  }
}
    a3c6:	10 01       	reta			;

0000a3c8 <fram_block_cb>:
  elyFramPostRequest(req);
}

void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
    a3c8:	b0 13 a6 45 	calla	#17830		;0x045a6

0000a3cc <.LBB20>:
  chDbgCheckClassI();
    a3cc:	b0 13 54 46 	calla	#18004		;0x04654

0000a3d0 <.LVL16>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a3d0:	40 18 1c 42 	movx.w	&0x0d19e,r12	;
    a3d4:	9e d1 
    a3d6:	4d 43       	clr.b	r13		;
    a3d8:	0d 9c       	cmp	r12,	r13	;
    a3da:	04 38       	jl	$+10     	;abs 0xa3e4

0000a3dc <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a3dc:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a3e0:	b0 13 fe 4a 	calla	#19198		;0x04afe

0000a3e4 <.L8>:
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
    a3e4:	b0 13 d0 45 	calla	#17872		;0x045d0

0000a3e8 <.LVL18>:
}
    a3e8:	10 01       	reta			;

0000a3ea <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    a3ea:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a3ec <.LCFI1>:
    a3ec:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a3ee <.LCFI2>:
    a3ee:	b1 00 04 00 	suba	#4,	r1	;

0000a3f2 <.LCFI3>:
    a3f2:	4a 4c       	mov.b	r12,	r10	;
    a3f4:	49 4d       	mov.b	r13,	r9	;
    a3f6:	48 4e       	mov.b	r14,	r8	;
    a3f8:	c6 0f       	mova	r15,	r6	;

0000a3fa <.LBB26>:
  _disable_interrupts();
    a3fa:	32 c2       	dint			
    a3fc:	03 43       	nop			

0000a3fe <.Loc.348.3>:
  asm volatile("nop");
    a3fe:	03 43       	nop			

0000a400 <.LBE26>:
  chSysLock();
    a400:	b0 13 54 45 	calla	#17748		;0x04554

0000a404 <.LVL20>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a404:	4d 43       	clr.b	r13		;
    a406:	cc 01       	mova	r1,	r12	;
    a408:	b0 13 10 be 	calla	#48656		;0x0be10

0000a40c <.LVL21>:
  chSysUnlock();
    a40c:	b0 13 7c 45 	calla	#17788		;0x0457c

0000a410 <.LBB28>:
  asm volatile("nop");
    a410:	03 43       	nop			

0000a412 <.Loc.356.3>:
  _enable_interrupts();
    a412:	03 43       	nop			
    a414:	32 d2       	eint			
    a416:	03 43       	nop			

0000a418 <.LBE28>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a418:	0c 01       	mova	@r1,	r12	;
    a41a:	39 53       	add	#-1,	r9	;r3 As==11

0000a41c <.LVL23>:
    a41c:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a420 <.LVL24>:
    a420:	0e 49       	mov	r9,	r14	;
    a422:	0f 49       	mov	r9,	r15	;
    a424:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a428:	48 48       	mov.b	r8,	r8	;
    a42a:	09 43       	clr	r9		;

0000a42c <.LVL25>:
    a42c:	0d 48       	mov	r8,	r13	;
    a42e:	0d 53       	add	#0,	r13	;r3 As==00
    a430:	19 63       	addc	#1,	r9	;r3 As==01
    a432:	0d 5e       	add	r14,	r13	;
    a434:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a438:	09 6f       	addc	r15,	r9	;
    a43a:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a43e <.Loc.225.1>:
  req->read = read;
    a43e:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a440 <.LVL26>:
    a440:	4a 5a       	rla.b	r10		;
    a442:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a446:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a448:	4d da       	bis.b	r10,	r13	;
    a44a:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a44e <.Loc.226.1>:
  req->size = 1;
    a44e:	1d 4c 04 00 	mov	4(r12),	r13	;
    a452:	7d f0 03 00 	and.b	#3,	r13	;
    a456:	2d d2       	bis	#4,	r13	;r2 As==10
    a458:	8c 4d 04 00 	mov	r13,	4(r12)	;
    a45c:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    a460:	06 00 

0000a462 <.Loc.227.1>:
  req->buffer = valuep;
    a462:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a466 <.Loc.228.1>:
  req->callback = fram_reg_cb;
    a466:	00 18 fc 40 	movx.a	#41876,	12(r12)	;0x0a394, 0x0000c
    a46a:	94 a3 0c 00 

0000a46e <.Loc.231.1>:
  elyFramPostRequest(req);
    a46e:	b0 13 d8 bd 	calla	#48600		;0x0bdd8

0000a472 <.LVL27>:
}
    a472:	a1 00 04 00 	adda	#4,	r1	;
    a476:	06 16       	popm.a	#1,	r6	;20-bit words
    a478:	28 16       	popm.a	#3,	r10	;20-bit words
    a47a:	10 01       	reta			;

0000a47c <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    a47c:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a47e <.LCFI4>:
    a47e:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a480 <.LCFI5>:
    a480:	b1 00 08 00 	suba	#8,	r1	;

0000a484 <.LCFI6>:
    a484:	4a 4c       	mov.b	r12,	r10	;
    a486:	49 4d       	mov.b	r13,	r9	;
    a488:	48 4e       	mov.b	r14,	r8	;
    a48a:	c6 0f       	mova	r15,	r6	;

0000a48c <.LBB34>:
  _disable_interrupts();
    a48c:	32 c2       	dint			
    a48e:	03 43       	nop			

0000a490 <.Loc.348.3>:
  asm volatile("nop");
    a490:	03 43       	nop			

0000a492 <.LBE34>:
  fram_req_t * req;
  
  chSysLock();
    a492:	b0 13 54 45 	calla	#17748		;0x04554

0000a496 <.LVL29>:
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a496:	4d 43       	clr.b	r13		;
    a498:	cc 01       	mova	r1,	r12	;
    a49a:	ac 00 04 00 	adda	#4,	r12	;
    a49e:	b0 13 10 be 	calla	#48656		;0x0be10

0000a4a2 <.LVL30>:
  chSysUnlock();
    a4a2:	b0 13 7c 45 	calla	#17788		;0x0457c

0000a4a6 <.LBB36>:
  asm volatile("nop");
    a4a6:	03 43       	nop			

0000a4a8 <.Loc.356.3>:
  _enable_interrupts();
    a4a8:	03 43       	nop			
    a4aa:	32 d2       	eint			
    a4ac:	03 43       	nop			

0000a4ae <.LBE36>:
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a4ae:	3c 01 04 00 	mova	4(r1),	r12	;
    a4b2:	39 53       	add	#-1,	r9	;r3 As==11

0000a4b4 <.LVL32>:
    a4b4:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a4b8 <.LVL33>:
    a4b8:	0e 49       	mov	r9,	r14	;
    a4ba:	0f 49       	mov	r9,	r15	;
    a4bc:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a4c0:	48 48       	mov.b	r8,	r8	;
    a4c2:	09 43       	clr	r9		;

0000a4c4 <.LVL34>:
    a4c4:	0d 48       	mov	r8,	r13	;
    a4c6:	0d 53       	add	#0,	r13	;r3 As==00
    a4c8:	19 63       	addc	#1,	r9	;r3 As==01
    a4ca:	0d 5e       	add	r14,	r13	;
    a4cc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a4d0:	09 6f       	addc	r15,	r9	;
    a4d2:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a4d6 <.Loc.251.1>:
  req->read = read;
    a4d6:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a4d8 <.LVL35>:
    a4d8:	4a 5a       	rla.b	r10		;
    a4da:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a4de:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a4e0:	4d da       	bis.b	r10,	r13	;
    a4e2:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a4e6 <.Loc.252.1>:
  req->size = n;
    a4e6:	5d 41 1c 00 	mov.b	28(r1),	r13	;0x0001c
    a4ea:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    a4ee:	00 00 
    a4f0:	2d 41       	mov	@r1,	r13	;
    a4f2:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a4f6:	1e 4c 04 00 	mov	4(r12),	r14	;
    a4fa:	7e f0 03 00 	and.b	#3,	r14	;
    a4fe:	0e dd       	bis	r13,	r14	;
    a500:	8c 4e 04 00 	mov	r14,	4(r12)	;

0000a504 <.LVL36>:
    a504:	2e 41       	mov	@r1,	r14	;
    a506:	0f 4e       	mov	r14,	r15	;
    a508:	5f 03       	rrum	#1,	r15	;
    a50a:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    a50e:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    a512:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    a516:	0a 01       	mova	@r1,	r10	;
    a518:	0a 14       	pushm.a	#1,	r10	;20-bit words
    a51a:	0d 17       	popm	#1,	r13	;16-bit words
    a51c:	0d 17       	popm	#1,	r13	;16-bit words
    a51e:	5d f3       	and.b	#1,	r13	;r3 As==01
    a520:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a524:	4e df       	bis.b	r15,	r14	;
    a526:	4e dd       	bis.b	r13,	r14	;
    a528:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000a52c <.Loc.253.1>:
  req->buffer = buffer;
    a52c:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a530 <.Loc.254.1>:
  req->callback = fram_block_cb;
    a530:	00 18 fc 40 	movx.a	#41928,	12(r12)	;0x0a3c8, 0x0000c
    a534:	c8 a3 0c 00 

0000a538 <.Loc.257.1>:
  
  /* TODO handle failure */
  elyFramPostRequest(req);
    a538:	b0 13 d8 bd 	calla	#48600		;0x0bdd8

0000a53c <.LVL37>:
}
    a53c:	a1 00 08 00 	adda	#8,	r1	;
    a540:	06 16       	popm.a	#1,	r6	;20-bit words
    a542:	28 16       	popm.a	#3,	r10	;20-bit words
    a544:	10 01       	reta			;

0000a546 <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    a546:	4e 4c       	mov.b	r12,	r14	;
    a548:	4c 4d       	mov.b	r13,	r12	;

0000a54a <.LVL39>:
  switch(addr) {
    a54a:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    a54e:	8c 24       	jz	$+282    	;abs 0xa668
    a550:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    a554:	4f 9e       	cmp.b	r14,	r15	;
    a556:	3b 28       	jnc	$+120    	;abs 0xa5ce
    a558:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    a55c:	78 24       	jz	$+242    	;abs 0xa64e
    a55e:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    a562:	4f 9e       	cmp.b	r14,	r15	;
    a564:	13 28       	jnc	$+40     	;abs 0xa58c
    a566:	7e 90 07 00 	cmp.b	#7,	r14	;
    a56a:	6b 24       	jz	$+216    	;abs 0xa642
    a56c:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    a570:	6e 24       	jz	$+222    	;abs 0xa64e
    a572:	7e 90 03 00 	cmp.b	#3,	r14	;
    a576:	14 20       	jnz	$+42     	;abs 0xa5a0

0000a578 <.Loc.263.1>:
    case RegTXFreqMsb:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    a578:	7e 40 38 00 	mov.b	#56,	r14	;#0x0038

0000a57c <.LVL40>:
    a57c:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033

0000a580 <.L93>:
      break;
    case RegOutputPower:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    case RegUARTBaudLsb:
    case RegSCCommBaudLsb:
      value = clamp(value, 1, 0xFF);
    a580:	b0 13 66 a3 	calla	#41830		;0x0a366

0000a584 <.L92>:
    case RegPATempERR:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
      break;
    default:
      if (addr > 0x80 && addr < 0xBF) {
        value = elyNLClampReg(addr, value);
    a584:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a588 <.LVL43>:
    a588:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a58c <.L16>:
  switch(addr) {
    a58c:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    a590:	5e 24       	jz	$+190    	;abs 0xa64e
    a592:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    a596:	4f 9e       	cmp.b	r14,	r15	;
    a598:	10 28       	jnc	$+34     	;abs 0xa5ba
    a59a:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    a59e:	57 24       	jz	$+176    	;abs 0xa64e

0000a5a0 <.L12>:
      if (addr > 0x80 && addr < 0xBF) {
    a5a0:	4d 4e       	mov.b	r14,	r13	;
    a5a2:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    a5a6:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    a5aa:	4f 9d       	cmp.b	r13,	r15	;
    a5ac:	b7 28       	jnc	$+368    	;abs 0xa71c

0000a5ae <.Loc.318.1>:
        value = elyNLClampReg(addr, value);
    a5ae:	4d 4c       	mov.b	r12,	r13	;
    a5b0:	4c 4e       	mov.b	r14,	r12	;

0000a5b2 <.LVL46>:
    a5b2:	b0 13 28 c0 	calla	#49192		;0x0c028

0000a5b6 <.LVL47>:
    a5b6:	80 00 84 a5 	mova	#42372,	r0	;0x0a584

0000a5ba <.L21>:
  switch(addr) {
    a5ba:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    a5be:	4b 24       	jz	$+152    	;abs 0xa656
    a5c0:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    a5c4:	ed 23       	jnz	$-36     	;abs 0xa5a0

0000a5c6 <.L24>:
      value = clamp(value, 1, 0xFF);
    a5c6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    a5c8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a5ca:	80 00 80 a5 	mova	#42368,	r0	;0x0a580

0000a5ce <.L14>:
  switch(addr) {
    a5ce:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    a5d2:	4a 24       	jz	$+150    	;abs 0xa668
    a5d4:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    a5d8:	4f 9e       	cmp.b	r14,	r15	;
    a5da:	12 28       	jnc	$+38     	;abs 0xa600
    a5dc:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    a5e0:	4f 9e       	cmp.b	r14,	r15	;
    a5e2:	09 28       	jnc	$+20     	;abs 0xa5f6
    a5e4:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    a5e8:	43 2c       	jc	$+136    	;abs 0xa670
    a5ea:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    a5ee:	d8 23       	jnz	$-78     	;abs 0xa5a0

0000a5f0 <.L39>:
      return 0; /* this is purely efficiency */
    a5f0:	4c 43       	clr.b	r12		;
    a5f2:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a5f6 <.L26>:
  switch(addr) {
    a5f6:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    a5fa:	e5 27       	jz	$-52     	;abs 0xa5c6
    a5fc:	80 00 a0 a5 	mova	#42400,	r0	;0x0a5a0

0000a600 <.L25>:
    a600:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    a604:	7c 24       	jz	$+250    	;abs 0xa6fe
    a606:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    a60a:	4f 9e       	cmp.b	r14,	r15	;
    a60c:	05 28       	jnc	$+12     	;abs 0xa618
    a60e:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    a612:	ee 27       	jz	$-34     	;abs 0xa5f0
    a614:	80 00 a0 a5 	mova	#42400,	r0	;0x0a5a0

0000a618 <.L30>:
    a618:	4d 4e       	mov.b	r14,	r13	;

0000a61a <.LVL53>:
    a61a:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    a61e:	7f 40 05 00 	mov.b	#5,	r15	;
    a622:	4f 9d       	cmp.b	r13,	r15	;
    a624:	bd 2b       	jnc	$-132    	;abs 0xa5a0

0000a626 <.LBB42>:
  if ((int8_t)(value) < min) {
    a626:	4d 4c       	mov.b	r12,	r13	;
    a628:	40 18 8d 11 	sxtx.w	r13		;
    a62c:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    a630:	69 34       	jge	$+212    	;abs 0xa704

0000a632 <.Loc.195.1>:
    elyErrorSignal(ErrRegClip);
    a632:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a636 <.LVL55>:
    a636:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a63a <.LVL56>:
    value = (uint8_t)(min);
    a63a:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    a63e:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a642 <.L17>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    a642:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    a646:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b

0000a64a <.LVL58>:
    a64a:	80 00 80 a5 	mova	#42368,	r0	;0x0a580

0000a64e <.L20>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    a64e:	4e 43       	clr.b	r14		;

0000a650 <.L94>:
      value = clamp(value, 0, 4);
    a650:	4d 43       	clr.b	r13		;

0000a652 <.LVL60>:
    a652:	80 00 80 a5 	mova	#42368,	r0	;0x0a580

0000a656 <.L23>:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    a656:	4e 43       	clr.b	r14		;
    a658:	7d 40 4f 00 	mov.b	#79,	r13	;#0x004f

0000a65c <.LVL62>:
    a65c:	b0 13 66 a3 	calla	#41830		;0x0a366

0000a660 <.LVL63>:
    a660:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a664 <.LVL64>:
    a664:	80 00 c6 a5 	mova	#42438,	r0	;0x0a5c6

0000a668 <.L13>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    a668:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    a66c:	80 00 50 a6 	mova	#42576,	r0	;0x0a650

0000a670 <.L27>:
  if ((value & 0x10) && value != 0x10) {
    a670:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    a674:	10 00 
    a676:	0a 24       	jz	$+22     	;abs 0xa68c
    a678:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a67c:	07 24       	jz	$+16     	;abs 0xa68c

0000a67e <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    a67e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a682 <.LVL67>:
    a682:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a686 <.LVL68>:
    return 0x10;
    a686:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000a68a <.L28>:
        value = elyDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    a68a:	10 01       	reta			;

0000a68c <.L32>:
  if ((value & 0x08) && value != 0x08) {
    a68c:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    a690:	09 24       	jz	$+20     	;abs 0xa6a4
    a692:	3c 92       	cmp	#8,	r12	;r2 As==11
    a694:	07 24       	jz	$+16     	;abs 0xa6a4

0000a696 <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    a696:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a69a <.LVL71>:
    a69a:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a69e <.LVL72>:
    return 0x08;
    a69e:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a6a0:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a6a4 <.L33>:
  if ((value & 0x04) && value != 0x04) {
    a6a4:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    a6a8:	09 24       	jz	$+20     	;abs 0xa6bc
    a6aa:	2c 92       	cmp	#4,	r12	;r2 As==10
    a6ac:	07 24       	jz	$+16     	;abs 0xa6bc

0000a6ae <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    a6ae:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a6b2 <.LVL74>:
    a6b2:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a6b6 <.LVL75>:
    return 0x04;
    a6b6:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a6b8:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a6bc <.L34>:
  if ((value & 0x02) && value != 0x02) {
    a6bc:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    a6c0:	09 24       	jz	$+20     	;abs 0xa6d4
    a6c2:	2c 93       	cmp	#2,	r12	;r3 As==10
    a6c4:	07 24       	jz	$+16     	;abs 0xa6d4

0000a6c6 <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    a6c6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a6ca <.LVL77>:
    a6ca:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a6ce <.LVL78>:
    return 0x02;
    a6ce:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a6d0:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a6d4 <.L35>:
  if ((value & 0x01) && value != 0x01) {
    a6d4:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    a6d8:	09 24       	jz	$+20     	;abs 0xa6ec
    a6da:	1c 93       	cmp	#1,	r12	;r3 As==01
    a6dc:	07 24       	jz	$+16     	;abs 0xa6ec

0000a6de <.Loc.182.1>:
    elyErrorSignal(ErrRegClip);
    a6de:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a6e2 <.LVL80>:
    a6e2:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a6e6 <.LVL81>:
    return 0x01;
    a6e6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a6e8:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a6ec <.L36>:
  if (value & 0xD0) {
    a6ec:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a6f0:	cc 27       	jz	$-102    	;abs 0xa68a

0000a6f2 <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    a6f2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a6f6 <.LVL83>:
    a6f6:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a6fa <.LVL84>:
    a6fa:	80 00 f0 a5 	mova	#42480,	r0	;0x0a5f0

0000a6fe <.L29>:
      value = clamp(value, 0, 4);
    a6fe:	6e 42       	mov.b	#4,	r14	;r2 As==10
    a700:	80 00 50 a6 	mova	#42576,	r0	;0x0a650

0000a704 <.L37>:
  else if ((int8_t)(value) > max) {
    a704:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    a708:	4e 9d       	cmp.b	r13,	r14	;
    a70a:	bf 37       	jge	$-128    	;abs 0xa68a

0000a70c <.Loc.199.1>:
    elyErrorSignal(ErrRegClip);
    a70c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a710 <.LVL87>:
    a710:	b0 13 98 c3 	calla	#50072		;0x0c398

0000a714 <.LVL88>:
    value = (uint8_t)(max);
    a714:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    a718:	80 00 8a a6 	mova	#42634,	r0	;0x0a68a

0000a71c <.L38>:
      else if (addr > 0xC0) {
    a71c:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    a720:	4d 9e       	cmp.b	r14,	r13	;
    a722:	b3 2f       	jc	$-152    	;abs 0xa68a

0000a724 <.Loc.321.1>:
        value = elyDLLClampReg(addr, value);
    a724:	4d 4c       	mov.b	r12,	r13	;
    a726:	4c 4e       	mov.b	r14,	r12	;
    a728:	b0 13 0a c7 	calla	#50954		;0x0c70a

0000a72c <.LVL90>:
    a72c:	80 00 84 a5 	mova	#42372,	r0	;0x0a584

0000a730 <elyRegGet>:

bool elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a730:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a732 <.LCFI7>:
    a732:	49 4c       	mov.b	r12,	r9	;
    a734:	47 4e       	mov.b	r14,	r7	;

0000a736 <.Loc.329.1>:
  regs_in_progress = n;
    a736:	40 18 c2 47 	movx.b	r7,	&0xfd19c;
    a73a:	9c d1 

0000a73c <.LVL92>:
    a73c:	ca 0d       	mova	r13,	r10	;

0000a73e <.LBB58>:
  
  for (int i = 0; i < n; i++) {
    a73e:	ce 0d       	mova	r13,	r14	;

0000a740 <.LVL93>:
    a740:	4d 43       	clr.b	r13		;

0000a742 <.L96>:
    a742:	0d 97       	cmp	r7,	r13	;
    a744:	0f 38       	jl	$+32     	;abs 0xa764

0000a746 <.LBE58>:
        (addr >= RegDLLMAX)) {
      return false; /* other bits handled outside */
    }
  }
  
  if (bank == 0) {
    a746:	09 93       	cmp	#0,	r9	;r3 As==00
    a748:	36 24       	jz	$+110    	;abs 0xa7b6
    a74a:	45 43       	clr.b	r5		;

0000a74c <.LBB61>:
  else {
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
  
      /* Get the register */
      fram_reg(1, bank, addr, (buffer+i-1));
    a74c:	88 00 ea a3 	mova	#41962,	r8	;0x0a3ea
    a750:	56 43       	mov.b	#1,	r6	;r3 As==01

0000a752 <.L100>:
    for (int i = 0; i < n; i++) {
    a752:	05 97       	cmp	r7,	r5	;
    a754:	35 20       	jnz	$+108    	;abs 0xa7c0

0000a756 <.LBB64>:
  return chSemWaitTimeout(&bsp->sem, time);
    a756:	4d 43       	clr.b	r13		;
    a758:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a75c:	b0 13 7c 4a 	calla	#19068		;0x04a7c

0000a760 <.LVL97>:
    a760:	80 00 ba a7 	mova	#42938,	r0	;0x0a7ba

0000a764 <.L98>:
    uint8_t addr = buffer[i];
    a764:	6c 4e       	mov.b	@r14,	r12	;

0000a766 <.LVL99>:
    if ((bank > 4) ||
    a766:	68 42       	mov.b	#4,	r8	;r2 As==10
    a768:	48 99       	cmp.b	r9,	r8	;
    a76a:	36 28       	jnc	$+110    	;abs 0xa7d8

0000a76c <.Loc.335.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    a76c:	4f 4c       	mov.b	r12,	r15	;
    a76e:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

0000a772 <.Loc.334.1>:
    if ((bank > 4) ||
    a772:	78 40 09 00 	mov.b	#9,	r8	;
    a776:	48 9f       	cmp.b	r15,	r8	;
    a778:	2f 2c       	jc	$+96     	;abs 0xa7d8

0000a77a <.Loc.336.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    a77a:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

0000a77e <.Loc.335.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    a77e:	78 42       	mov.b	#8,	r8	;r2 As==11
    a780:	48 9f       	cmp.b	r15,	r8	;
    a782:	2a 2c       	jc	$+86     	;abs 0xa7d8

0000a784 <.Loc.337.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a784:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

0000a788 <.Loc.336.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    a788:	78 40 35 00 	mov.b	#53,	r8	;#0x0035
    a78c:	48 9f       	cmp.b	r15,	r8	;
    a78e:	24 2c       	jc	$+74     	;abs 0xa7d8
    a790:	ae 00 01 00 	adda	#1,	r14	;

0000a794 <.LVL100>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a794:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    a798:	4f 9c       	cmp.b	r12,	r15	;
    a79a:	1e 28       	jnc	$+62     	;abs 0xa7d8

0000a79c <.LBE59>:
  for (int i = 0; i < n; i++) {
    a79c:	1d 53       	inc	r13		;
    a79e:	80 00 42 a7 	mova	#42818,	r0	;0x0a742

0000a7a2 <.L101>:
      *(buffer+i-1) = bank0p[addr];
    a7a2:	68 4a       	mov.b	@r10,	r8	;
    a7a4:	40 18 0c 48 	movx.w	r8,	r12	;
    a7a8:	cf 18 da 4c 	movx.b	67824(r12),-1(r10)	;0x108f0, 0xfffff
    a7ac:	f0 08 ff ff 

0000a7b0 <.LBE68>:
    for (int i = 0; i < n; i++) {
    a7b0:	19 53       	inc	r9		;
    a7b2:	aa 00 01 00 	adda	#1,	r10	;

0000a7b6 <.L99>:
    a7b6:	09 97       	cmp	r7,	r9	;
    a7b8:	f4 23       	jnz	$-22     	;abs 0xa7a2

0000a7ba <.L109>:
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    a7ba:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a7bc <.L97>:
}
    a7bc:	55 16       	popm.a	#6,	r10	;20-bit words
    a7be:	10 01       	reta			;

0000a7c0 <.L102>:
      fram_reg(1, bank, addr, (buffer+i-1));
    a7c0:	cf 0a       	mova	r10,	r15	;
    a7c2:	af 0f ff ff 	adda	#1048575,r15	;0xfffff
    a7c6:	6e 4a       	mov.b	@r10,	r14	;
    a7c8:	4d 49       	mov.b	r9,	r13	;
    a7ca:	4c 46       	mov.b	r6,	r12	;
    a7cc:	48 13       	calla	r8		;

0000a7ce <.LBE63>:
    for (int i = 0; i < n; i++) {
    a7ce:	15 53       	inc	r5		;
    a7d0:	aa 00 01 00 	adda	#1,	r10	;
    a7d4:	80 00 52 a7 	mova	#42834,	r0	;0x0a752

0000a7d8 <.L107>:
      return false; /* other bits handled outside */
    a7d8:	4c 43       	clr.b	r12		;

0000a7da <.LVL110>:
    a7da:	80 00 bc a7 	mova	#42940,	r0	;0x0a7bc

0000a7de <elyRegSet>:

bool elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a7de:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a7e0 <.LCFI8>:
    a7e0:	b1 00 04 00 	suba	#4,	r1	;

0000a7e4 <.LCFI9>:
    a7e4:	49 4c       	mov.b	r12,	r9	;
    a7e6:	ca 0d       	mova	r13,	r10	;
    a7e8:	45 4e       	mov.b	r14,	r5	;

0000a7ea <.Loc.365.1>:
  regs_in_progress = n;
    a7ea:	40 18 c2 45 	movx.b	r5,	&0xfd19c;
    a7ee:	9c d1 

0000a7f0 <.LBB77>:
  
  for (int i = 0; i < n * 2; i += 2) {
    a7f0:	05 55       	rla	r5		;
    a7f2:	c4 0d       	mova	r13,	r4	;
    a7f4:	cc 0d       	mova	r13,	r12	;

0000a7f6 <.LVL113>:
    a7f6:	4d 43       	clr.b	r13		;

0000a7f8 <.LBB78>:
    uint8_t addr = buffer[i];
    
    if ((bank == 0) || (bank > 4) ||
    a7f8:	4f 49       	mov.b	r9,	r15	;
    a7fa:	7f 53       	add.b	#-1,	r15	;r3 As==11

0000a7fc <.L111>:
  for (int i = 0; i < n * 2; i += 2) {
    a7fc:	0d 95       	cmp	r5,	r13	;
    a7fe:	13 38       	jl	$+40     	;abs 0xa826
    a800:	aa 00 01 00 	adda	#1,	r10	;

0000a804 <.Loc.367.1>:
    a804:	47 43       	clr.b	r7		;

0000a806 <.LBB81>:
  }

  for (int i = 0; i < n * 2; i += 2) {
    uint8_t addr = buffer[i];
    uint8_t value = buffer[i+1];
    value = elyClampReg(addr, value);
    a806:	86 00 46 a5 	mova	#42310,	r6	;0x0a546

0000a80a <.Loc.384.1>:
  
    /* Write the register */
    fram_reg(0, bank, addr, &buffer[i+1]);
    a80a:	88 00 ea a3 	mova	#41962,	r8	;0x0a3ea

0000a80e <.L114>:
  for (int i = 0; i < n * 2; i += 2) {
    a80e:	07 95       	cmp	r5,	r7	;
    a810:	25 38       	jl	$+76     	;abs 0xa85c

0000a812 <.LBB84>:
    a812:	4d 43       	clr.b	r13		;
    a814:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a818:	b0 13 7c 4a 	calla	#19068		;0x04a7c

0000a81c <.LBE84>:
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    a81c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a81e <.L112>:
}
    a81e:	a1 00 04 00 	adda	#4,	r1	;
    a822:	64 16       	popm.a	#7,	r10	;20-bit words
    a824:	10 01       	reta			;

0000a826 <.L113>:
    uint8_t addr = buffer[i];
    a826:	6e 4c       	mov.b	@r12,	r14	;

0000a828 <.LVL121>:
    if ((bank == 0) || (bank > 4) ||
    a828:	77 40 03 00 	mov.b	#3,	r7	;
    a82c:	47 9f       	cmp.b	r15,	r7	;
    a82e:	28 28       	jnc	$+82     	;abs 0xa880

0000a830 <.Loc.371.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    a830:	48 4e       	mov.b	r14,	r8	;
    a832:	78 50 aa ff 	add.b	#-86,	r8	;#0xffaa

0000a836 <.Loc.370.1>:
    if ((bank == 0) || (bank > 4) ||
    a836:	77 40 29 00 	mov.b	#41,	r7	;#0x0029
    a83a:	47 98       	cmp.b	r8,	r7	;
    a83c:	21 2c       	jc	$+68     	;abs 0xa880

0000a83e <.Loc.372.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a83e:	78 50 cc ff 	add.b	#-52,	r8	;#0xffcc

0000a842 <.Loc.371.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    a842:	77 40 35 00 	mov.b	#53,	r7	;#0x0035
    a846:	47 98       	cmp.b	r8,	r7	;
    a848:	1b 2c       	jc	$+56     	;abs 0xa880
    a84a:	ac 00 02 00 	adda	#2,	r12	;

0000a84e <.LVL122>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a84e:	78 40 d4 ff 	mov.b	#-44,	r8	;#0xffd4
    a852:	48 9e       	cmp.b	r14,	r8	;
    a854:	15 28       	jnc	$+44     	;abs 0xa880

0000a856 <.LBE79>:
  for (int i = 0; i < n * 2; i += 2) {
    a856:	2d 53       	incd	r13		;
    a858:	80 00 fc a7 	mova	#43004,	r0	;0x0a7fc

0000a85c <.L115>:
    uint8_t addr = buffer[i];
    a85c:	6e 44       	mov.b	@r4,	r14	;

0000a85e <.LVL125>:
    value = elyClampReg(addr, value);
    a85e:	6d 4a       	mov.b	@r10,	r13	;
    a860:	4c 4e       	mov.b	r14,	r12	;
    a862:	71 0e 00 00 	mova	r14,	0(r1)	;

0000a866 <.LVL126>:
    a866:	46 13       	calla	r6		;

0000a868 <.LVL127>:
    fram_reg(0, bank, addr, &buffer[i+1]);
    a868:	cf 0a       	mova	r10,	r15	;
    a86a:	0e 01       	mova	@r1,	r14	;
    a86c:	4d 49       	mov.b	r9,	r13	;
    a86e:	4c 43       	clr.b	r12		;
    a870:	48 13       	calla	r8		;

0000a872 <.LBE83>:
  for (int i = 0; i < n * 2; i += 2) {
    a872:	27 53       	incd	r7		;
    a874:	a4 00 02 00 	adda	#2,	r4	;
    a878:	aa 00 02 00 	adda	#2,	r10	;
    a87c:	80 00 0e a8 	mova	#43022,	r0	;0x0a80e

0000a880 <.L119>:
      return false; /* other bits handled outside */
    a880:	4c 43       	clr.b	r12		;
    a882:	80 00 1e a8 	mova	#43038,	r0	;0x0a81e

0000a886 <elyRegGetBlock>:

bool elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a886:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a888 <.LCFI10>:
    a888:	b1 00 02 00 	suba	#2,	r1	;

0000a88c <.LCFI11>:
    a88c:	4b 4c       	mov.b	r12,	r11	;
    a88e:	cc 0d       	mova	r13,	r12	;

0000a890 <.LVL132>:
    a890:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    a894:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

0000a898 <.Loc.396.1>:
  
  if (bank > 4 || 
    a898:	6a 42       	mov.b	#4,	r10	;r2 As==10
    a89a:	4a 9b       	cmp.b	r11,	r10	;
    a89c:	40 28       	jnc	$+130    	;abs 0xa91e

0000a89e <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a89e:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    a8a2:	57 00 
    a8a4:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a8a8 <.LVL133>:
  if (bank > 4 || 
    a8a8:	0e 9d       	cmp	r13,	r14	;
    a8aa:	04 38       	jl	$+10     	;abs 0xa8b4

0000a8ac <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a8ac:	7d 40 5f 00 	mov.b	#95,	r13	;#0x005f
    a8b0:	4d 9e       	cmp.b	r14,	r13	;
    a8b2:	35 2c       	jc	$+108    	;abs 0xa91e

0000a8b4 <.L122>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    a8b4:	4d 4e       	mov.b	r14,	r13	;
    a8b6:	7d 50 89 ff 	add.b	#-119,	r13	;#0xff89

0000a8ba <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a8ba:	7a 42       	mov.b	#8,	r10	;r2 As==11
    a8bc:	4a 9d       	cmp.b	r13,	r10	;
    a8be:	2f 2c       	jc	$+96     	;abs 0xa91e

0000a8c0 <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a8c0:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    a8c4:	8b 00 
    a8c6:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a8ca <.Loc.398.1>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    a8ca:	0e 9d       	cmp	r13,	r14	;
    a8cc:	04 38       	jl	$+10     	;abs 0xa8d6

0000a8ce <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a8ce:	7d 40 bf ff 	mov.b	#-65,	r13	;#0xffbf
    a8d2:	4d 9e       	cmp.b	r14,	r13	;
    a8d4:	24 2c       	jc	$+74     	;abs 0xa91e

0000a8d6 <.L123>:
      (addr >= RegDLLMAX - n + 1)) {
    a8d6:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    a8da:	d6 00 
    a8dc:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a8e0 <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a8e0:	0e 9d       	cmp	r13,	r14	;
    a8e2:	1d 34       	jge	$+60     	;abs 0xa91e

0000a8e4 <.Loc.404.1>:
    return false; /* Other bits handled outside */
  }
  
  if (bank == 0) {
    a8e4:	0b 93       	cmp	#0,	r11	;r3 As==00
    a8e6:	0d 20       	jnz	$+28     	;abs 0xa902

0000a8e8 <.Loc.405.1>:
    memcpy(buffer, bank0p + addr, n);
    a8e8:	40 18 0d 4e 	movx.w	r14,	r13	;
    a8ec:	40 18 0e 4f 	movx.w	r15,	r14	;

0000a8f0 <.LVL134>:
    a8f0:	ad 01 f0 08 	adda	#67824,	r13	;0x108f0

0000a8f4 <.LVL135>:
    a8f4:	b0 13 d6 ce 	calla	#52950		;0x0ced6

0000a8f8 <.L130>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    a8f8:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a8fa <.L121>:
}
    a8fa:	a1 00 02 00 	adda	#2,	r1	;
    a8fe:	0a 16       	popm.a	#1,	r10	;20-bit words
    a900:	10 01       	reta			;

0000a902 <.L124>:
    fram_block(1, bank, addr, buffer, n);
    a902:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    a906:	cf 0c       	mova	r12,	r15	;
    a908:	4d 4b       	mov.b	r11,	r13	;
    a90a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a90c <.LVL138>:
    a90c:	b0 13 7c a4 	calla	#42108		;0x0a47c

0000a910 <.LBB91>:
    a910:	4d 43       	clr.b	r13		;
    a912:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a916:	b0 13 7c 4a 	calla	#19068		;0x04a7c

0000a91a <.LVL140>:
    a91a:	80 00 f8 a8 	mova	#43256,	r0	;0x0a8f8

0000a91e <.L129>:
    return false; /* Other bits handled outside */
    a91e:	4c 43       	clr.b	r12		;

0000a920 <.LVL142>:
    a920:	80 00 fa a8 	mova	#43258,	r0	;0x0a8fa

0000a924 <elyRegSetBlock>:

bool elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a924:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a926 <.LCFI12>:
    a926:	b1 00 02 00 	suba	#2,	r1	;

0000a92a <.LCFI13>:
    a92a:	49 4c       	mov.b	r12,	r9	;
    a92c:	c8 0d       	mova	r13,	r8	;
    a92e:	4a 4e       	mov.b	r14,	r10	;
    a930:	47 4f       	mov.b	r15,	r7	;

0000a932 <.Loc.420.1>:
  
  if (bank == 0 || bank > 4 || 
    a932:	4c 49       	mov.b	r9,	r12	;

0000a934 <.LVL144>:
    a934:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a936:	7d 40 03 00 	mov.b	#3,	r13	;

0000a93a <.LVL145>:
    a93a:	4d 9c       	cmp.b	r12,	r13	;
    a93c:	3e 28       	jnc	$+126    	;abs 0xa9ba

0000a93e <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a93e:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    a942:	57 00 
    a944:	40 18 0c 87 	subx.w	r7,	r12	;

0000a948 <.Loc.420.1>:
  if (bank == 0 || bank > 4 || 
    a948:	0a 9c       	cmp	r12,	r10	;
    a94a:	02 38       	jl	$+6      	;abs 0xa950

0000a94c <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a94c:	4a 93       	cmp.b	#0,	r10	;r3 As==00
    a94e:	35 34       	jge	$+108    	;abs 0xa9ba

0000a950 <.L133>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a950:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    a954:	8b 00 
    a956:	40 18 0c 87 	subx.w	r7,	r12	;

0000a95a <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a95a:	0a 9c       	cmp	r12,	r10	;
    a95c:	04 38       	jl	$+10     	;abs 0xa966

0000a95e <.Loc.422.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a95e:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    a962:	4c 9a       	cmp.b	r10,	r12	;
    a964:	2a 2c       	jc	$+86     	;abs 0xa9ba

0000a966 <.L134>:
      (addr >= RegDLLMAX - n + 1)) {
    a966:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    a96a:	d6 00 
    a96c:	40 18 0c 87 	subx.w	r7,	r12	;

0000a970 <.Loc.422.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a970:	0a 9c       	cmp	r12,	r10	;
    a972:	23 34       	jge	$+72     	;abs 0xa9ba
    a974:	c4 08       	mova	r8,	r4	;

0000a976 <.Loc.422.1>:
    a976:	45 43       	clr.b	r5		;

0000a978 <.LBB96>:
    return false; /* Other bits handled outside */
  }
  
  for (int i = 0; i < n; i++) {
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a978:	86 00 46 a5 	mova	#42310,	r6	;0x0a546

0000a97c <.L135>:
  for (int i = 0; i < n; i++) {
    a97c:	05 97       	cmp	r7,	r5	;
    a97e:	12 38       	jl	$+38     	;abs 0xa9a4

0000a980 <.LBE96>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    a980:	c1 47 00 00 	mov.b	r7,	0(r1)	;
    a984:	cf 08       	mova	r8,	r15	;
    a986:	4e 4a       	mov.b	r10,	r14	;
    a988:	4d 49       	mov.b	r9,	r13	;
    a98a:	4c 43       	clr.b	r12		;
    a98c:	b0 13 7c a4 	calla	#42108		;0x0a47c

0000a990 <.LBB97>:
    a990:	4d 43       	clr.b	r13		;
    a992:	8c 00 9e d1 	mova	#53662,	r12	;0x0d19e
    a996:	b0 13 7c 4a 	calla	#19068		;0x04a7c

0000a99a <.LBE97>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    a99a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a99c <.L132>:
}
    a99c:	a1 00 02 00 	adda	#2,	r1	;
    a9a0:	64 16       	popm.a	#7,	r10	;20-bit words
    a9a2:	10 01       	reta			;

0000a9a4 <.L136>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a9a4:	6d 44       	mov.b	@r4,	r13	;
    a9a6:	4c 45       	mov.b	r5,	r12	;
    a9a8:	4c 5a       	add.b	r10,	r12	;
    a9aa:	46 13       	calla	r6		;

0000a9ac <.LVL151>:
    a9ac:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000a9b0 <.Loc.427.1>:
  for (int i = 0; i < n; i++) {
    a9b0:	15 53       	inc	r5		;
    a9b2:	a4 00 01 00 	adda	#1,	r4	;
    a9b6:	80 00 7c a9 	mova	#43388,	r0	;0x0a97c

0000a9ba <.L140>:
    return false; /* Other bits handled outside */
    a9ba:	4c 43       	clr.b	r12		;
    a9bc:	80 00 9c a9 	mova	#43420,	r0	;0x0a99c

0000a9c0 <calc_next_buff>:
static const uint8_t * next_tx_ptr;
static slip_uart_states_t tx_state = ELY_SLIP_NOT_ESCAPED;

static thread_t * uart_thd;
    
void calc_next_buff(void) {
    a9c0:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a9c2 <.LCFI0>:
    a9c2:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a9c4 <.LCFI1>:
  
  switch (tx_state) {
    a9c4:	c0 18 5c 42 	movx.b	&0x109f6,r12	;
    a9c8:	f6 09 
    a9ca:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a9cc:	2f 24       	jz	$+96     	;abs 0xaa2c
    a9ce:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a9d0:	59 20       	jnz	$+180    	;abs 0xaa84

0000a9d2 <.Loc.28.1>:
    case ELY_SLIP_NOT_ESCAPED:
      next_tx_ptr = tx_read_ptr;
    a9d2:	2c 00 ae d1 	mova	&53678,	r12	;0x0d1ae
    a9d6:	60 0c a6 d1 	mova	r12,	&53670	; 0x0d1a6

0000a9da <.Loc.29.1>:
      next_cnt = 0;
    a9da:	00 18 c2 43 	movx.a	#0,	&0xfd1aa;r3 As==00
    a9de:	aa d1 

0000a9e0 <.Loc.30.1>:
      while (next_cnt != tx_n && 
    a9e0:	28 00 b2 d1 	mova	&53682,	r8	;0x0d1b2
    a9e4:	4e 43       	clr.b	r14		;
    a9e6:	4d 43       	clr.b	r13		;
    a9e8:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000a9ea <.L5>:
    a9ea:	d8 0e       	cmpa	r14,	r8	;
    a9ec:	0f 20       	jnz	$+32     	;abs 0xaa0c

0000a9ee <.L33>:
    a9ee:	0d 93       	cmp	#0,	r13	;r3 As==00
    a9f0:	04 24       	jz	$+10     	;abs 0xa9fa
    a9f2:	60 0e aa d1 	mova	r14,	&53674	; 0x0d1aa
    a9f6:	60 0c ae d1 	mova	r12,	&53678	; 0x0d1ae

0000a9fa <.L11>:
          *tx_read_ptr != SLIP_END && 
          *tx_read_ptr != SLIP_ESC) {
        next_cnt++;
        tx_read_ptr++;
      }
      tx_state = ELY_SLIP_ESCAPED;
    a9fa:	41 18 d2 43 	movx.b	#1,	&0x109f6;r3 As==01
    a9fe:	f6 09 

0000aa00 <.Loc.37.1>:
      if (next_cnt > 0) {
    aa00:	9e 00 00 00 	cmpa	#0,	r14	;
    aa04:	13 24       	jz	$+40     	;abs 0xaa2c

0000aa06 <.L1>:
      chDbgAssert(false, "State machine error");
      /* ACTUALLY can't happen */
      break;
  }
            
}
    aa06:	08 16       	popm.a	#1,	r8	;20-bit words
    aa08:	0a 16       	popm.a	#1,	r10	;20-bit words
    aa0a:	10 01       	reta			;

0000aa0c <.L6>:
      while (next_cnt != tx_n && 
    aa0c:	6f 4c       	mov.b	@r12,	r15	;
    aa0e:	7f 90 c0 ff 	cmp.b	#-64,	r15	;#0xffc0
    aa12:	ed 27       	jz	$-36     	;abs 0xa9ee
    aa14:	ca 0e       	mova	r14,	r10	;
    aa16:	aa 00 01 00 	adda	#1,	r10	;

0000aa1a <.Loc.31.1>:
          *tx_read_ptr != SLIP_END && 
    aa1a:	7f 90 db ff 	cmp.b	#-37,	r15	;#0xffdb
    aa1e:	e7 27       	jz	$-48     	;abs 0xa9ee

0000aa20 <.Loc.34.1>:
        tx_read_ptr++;
    aa20:	ac 00 01 00 	adda	#1,	r12	;
    aa24:	0d 4b       	mov	r11,	r13	;
    aa26:	ce 0a       	mova	r10,	r14	;
    aa28:	80 00 ea a9 	mova	#43498,	r0	;0x0a9ea

0000aa2c <.L3>:
        switch(*tx_read_ptr++) {
    aa2c:	2c 00 ae d1 	mova	&53678,	r12	;0x0d1ae
    aa30:	cd 0c       	mova	r12,	r13	;
    aa32:	ad 00 01 00 	adda	#1,	r13	;
    aa36:	60 0d ae d1 	mova	r13,	&53678	; 0x0d1ae
    aa3a:	6c 4c       	mov.b	@r12,	r12	;
    aa3c:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    aa40:	12 24       	jz	$+38     	;abs 0xaa66
    aa42:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    aa46:	15 20       	jnz	$+44     	;abs 0xaa72

0000aa48 <.Loc.44.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    aa48:	80 18 f2 40 	movx.a	#67476,	&0xfd1a6;0x10794
    aa4c:	94 07 a6 d1 

0000aa50 <.L17>:
        next_cnt = 2;
    aa50:	00 18 e2 43 	movx.a	#2,	&0xfd1aa;r3 As==10
    aa54:	aa d1 

0000aa56 <.Loc.58.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    aa56:	00 18 d2 53 	incx.a	&0xd1b2		;
    aa5a:	b2 d1 

0000aa5c <.Loc.59.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    aa5c:	41 18 e2 43 	movx.b	#2,	&0x109f6;r3 As==10
    aa60:	f6 09 
    aa62:	80 00 06 aa 	mova	#43526,	r0	;0x0aa06

0000aa66 <.L15>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    aa66:	80 18 f2 40 	movx.a	#67474,	&0xfd1a6;0x10792
    aa6a:	92 07 a6 d1 
    aa6e:	80 00 50 aa 	mova	#43600,	r0	;0x0aa50

0000aa72 <.L31>:
            chDbgAssert(false, "state machine error");
    aa72:	8c 01 83 07 	mova	#67459,	r12	;0x10783
    aa76:	b0 13 dc 47 	calla	#18396		;0x047dc

0000aa7a <.LVL0>:
            tx_n--;
    aa7a:	00 18 f2 53 	addx.a	#-1,	&0xfd1b2;r3 As==11
    aa7e:	b2 d1 
    aa80:	80 00 50 aa 	mova	#43600,	r0	;0x0aa50

0000aa84 <.L30>:
      chDbgAssert(false, "State machine error");
    aa84:	8c 01 83 07 	mova	#67459,	r12	;0x10783
    aa88:	b0 13 dc 47 	calla	#18396		;0x047dc

0000aa8c <.LVL1>:
}
    aa8c:	80 00 06 aa 	mova	#43526,	r0	;0x0aa06

0000aa90 <elyUARTDLLTxCB>:

void elyUARTDLLTxCB(UARTDriver * uartp) {
    aa90:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aa92 <.LCFI2>:
    aa92:	08 14       	pushm.a	#1,	r8	;20-bit words

0000aa94 <.LCFI3>:
    aa94:	b1 00 04 00 	suba	#4,	r1	;

0000aa98 <.LCFI4>:
  static bool done = false;
  static const uint8_t END = SLIP_END;
  
  if (done) {
    aa98:	40 18 c2 93 	cmpx.b	#0,	&0xfd1a0;r3 As==00
    aa9c:	a0 d1 
    aa9e:	08 24       	jz	$+18     	;abs 0xaab0

0000aaa0 <.Loc.75.1>:
    done = false;
    aaa0:	40 18 c2 43 	movx.b	#0,	&0xfd1a0;r3 As==00
    aaa4:	a0 d1 

0000aaa6 <.L34>:
    next_cnt = 1;
    return;
  }
  
  calc_next_buff();
}
    aaa6:	a1 00 04 00 	adda	#4,	r1	;
    aaaa:	08 16       	popm.a	#1,	r8	;20-bit words
    aaac:	0a 16       	popm.a	#1,	r10	;20-bit words
    aaae:	10 01       	reta			;

0000aab0 <.L35>:
  chSysLockFromISR();
    aab0:	88 00 a6 45 	mova	#17830,	r8	;0x045a6
    aab4:	71 0c 00 00 	mova	r12,	0(r1)	;
    aab8:	48 13       	calla	r8		;

0000aaba <.LVL5>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    aaba:	2e 00 a6 d1 	mova	&53670,	r14	;0x0d1a6
    aabe:	2d 00 aa d1 	mova	&53674,	r13	;0x0d1aa
    aac2:	0c 01       	mova	@r1,	r12	;
    aac4:	b0 13 66 52 	calla	#21094		;0x05266

0000aac8 <.LVL6>:
  chSysUnlockFromISR();
    aac8:	8a 00 d0 45 	mova	#17872,	r10	;0x045d0
    aacc:	4a 13       	calla	r10		;

0000aace <.LVL7>:
  if (tx_n == 0) {
    aace:	2c 00 b2 d1 	mova	&53682,	r12	;0x0d1b2
    aad2:	9c 00 00 00 	cmpa	#0,	r12	;
    aad6:	05 20       	jnz	$+12     	;abs 0xaae2

0000aad8 <.Loc.84.1>:
    done = true;
    aad8:	40 18 d2 43 	movx.b	#1,	&0xfd1a0;r3 As==01
    aadc:	a0 d1 

0000aade <.Loc.85.1>:
    return;
    aade:	80 00 a6 aa 	mova	#43686,	r0	;0x0aaa6

0000aae2 <.L37>:
  tx_n -= next_cnt;
    aae2:	00 18 5c 82 	subx.a	&0x0d1aa,r12	;
    aae6:	aa d1 
    aae8:	60 0c b2 d1 	mova	r12,	&53682	; 0x0d1b2

0000aaec <.Loc.90.1>:
  if (tx_n == 0) {
    aaec:	9c 00 00 00 	cmpa	#0,	r12	;
    aaf0:	0f 20       	jnz	$+32     	;abs 0xab10

0000aaf2 <.Loc.91.1>:
    chSysLockFromISR();
    aaf2:	48 13       	calla	r8		;

0000aaf4 <.LVL8>:
    elyNLFreeBufferI(tx_active_buffer);
    aaf4:	2c 00 b6 d1 	mova	&53686,	r12	;0x0d1b6
    aaf8:	b0 13 5c c1 	calla	#49500		;0x0c15c

0000aafc <.LVL9>:
    chSysUnlockFromISR();
    aafc:	4a 13       	calla	r10		;

0000aafe <.LVL10>:
    next_tx_ptr = &END;
    aafe:	80 18 f2 40 	movx.a	#67458,	&0xfd1a6;0x10782
    ab02:	82 07 a6 d1 

0000ab06 <.Loc.95.1>:
    next_cnt = 1;
    ab06:	00 18 d2 43 	movx.a	#1,	&0xfd1aa;r3 As==01
    ab0a:	aa d1 

0000ab0c <.Loc.96.1>:
    return;
    ab0c:	80 00 a6 aa 	mova	#43686,	r0	;0x0aaa6

0000ab10 <.L38>:
  calc_next_buff();
    ab10:	b0 13 c0 a9 	calla	#43456		;0x0a9c0

0000ab14 <.LVL11>:
    ab14:	80 00 a6 aa 	mova	#43686,	r0	;0x0aaa6

0000ab18 <elyUARTDLLStartTx>:

void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    ab18:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ab1a <.LCFI5>:
    ab1a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ab1c <.LCFI6>:
    ab1c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000ab1e <.LCFI7>:
    ab1e:	c8 0c       	mova	r12,	r8	;
    ab20:	ca 0d       	mova	r13,	r10	;

0000ab22 <.Loc.105.1>:
  static const uint8_t END = SLIP_END;
  /* Calculate the length of the packet - store it in n */
  tx_n = elyNLGetLength(buffer);
    ab22:	cc 0d       	mova	r13,	r12	;

0000ab24 <.LVL13>:
    ab24:	b0 13 2a c2 	calla	#49706		;0x0c22a

0000ab28 <.LVL14>:
    ab28:	60 0c b2 d1 	mova	r12,	&53682	; 0x0d1b2

0000ab2c <.Loc.106.1>:
  chDbgAssert(tx_n != 0 && tx_n <= elyNLMaxLen, "invalid packet length");
    ab2c:	9c 00 00 00 	cmpa	#0,	r12	;
    ab30:	04 24       	jz	$+10     	;abs 0xab3a

0000ab32 <.Loc.106.1>:
    ab32:	01 18 c2 9c 	cmpx.a	r12,	&0x10b18;
    ab36:	18 0b 
    ab38:	04 2c       	jc	$+10     	;abs 0xab42

0000ab3a <.L40>:
    ab3a:	8c 01 70 07 	mova	#67440,	r12	;0x10770
    ab3e:	b0 13 dc 47 	calla	#18396		;0x047dc

0000ab42 <.L41>:
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    ab42:	2c 00 b2 d1 	mova	&53682,	r12	;0x0d1b2
    ab46:	9c 00 00 00 	cmpa	#0,	r12	;
    ab4a:	04 24       	jz	$+10     	;abs 0xab54

0000ab4c <.Loc.107.1>:
    ab4c:	01 18 c2 9c 	cmpx.a	r12,	&0x10b18;
    ab50:	18 0b 
    ab52:	03 2c       	jc	$+8      	;abs 0xab5a

0000ab54 <.L42>:
    /* TODO signal an error here */
    elyNLFreeBuffer(buffer);
    ab54:	cc 0a       	mova	r10,	r12	;
    ab56:	b0 13 42 c1 	calla	#49474		;0x0c142

0000ab5a <.L43>:
  }
  tx_read_ptr = buffer;
    ab5a:	60 0a ae d1 	mova	r10,	&53678	; 0x0d1ae

0000ab5e <.Loc.112.1>:
  tx_active_buffer = buffer;
    ab5e:	60 0a b6 d1 	mova	r10,	&53686	; 0x0d1b6

0000ab62 <.Loc.113.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    ab62:	41 18 e2 43 	movx.b	#2,	&0x109f6;r3 As==10
    ab66:	f6 09 

0000ab68 <.Loc.115.1>:
  
  calc_next_buff();
    ab68:	86 00 c0 a9 	mova	#43456,	r6	;0x0a9c0
    ab6c:	46 13       	calla	r6		;

0000ab6e <.LBB32>:
  _disable_interrupts();
    ab6e:	32 c2       	dint			
    ab70:	03 43       	nop			

0000ab72 <.Loc.348.2>:
  asm volatile("nop");
    ab72:	03 43       	nop			

0000ab74 <.LBE32>:
  
  chSysLock();
    ab74:	b0 13 54 45 	calla	#17748		;0x04554

0000ab78 <.LVL18>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    ab78:	2e 00 a6 d1 	mova	&53670,	r14	;0x0d1a6
    ab7c:	2d 00 aa d1 	mova	&53674,	r13	;0x0d1aa
    ab80:	cc 08       	mova	r8,	r12	;
    ab82:	b0 13 66 52 	calla	#21094		;0x05266

0000ab86 <.LVL19>:
  
  tx_n -= next_cnt;
    ab86:	2c 00 b2 d1 	mova	&53682,	r12	;0x0d1b2
    ab8a:	00 18 5c 82 	subx.a	&0x0d1aa,r12	;
    ab8e:	aa d1 
    ab90:	60 0c b2 d1 	mova	r12,	&53682	; 0x0d1b2
    ab94:	8a 00 7c 45 	mova	#17788,	r10	;0x0457c

0000ab98 <.LVL20>:
  
  if (tx_n == 0) {
    ab98:	9c 00 00 00 	cmpa	#0,	r12	;
    ab9c:	14 20       	jnz	$+42     	;abs 0xabc6

0000ab9e <.Loc.123.1>:
    elyNLFreeBufferI(tx_active_buffer);
    ab9e:	2c 00 b6 d1 	mova	&53686,	r12	;0x0d1b6
    aba2:	b0 13 5c c1 	calla	#49500		;0x0c15c

0000aba6 <.LVL21>:
    next_tx_ptr = &END;
    aba6:	80 18 f2 40 	movx.a	#67439,	&0xfd1a6;0x1076f
    abaa:	6f 07 a6 d1 

0000abae <.Loc.125.1>:
    next_cnt = 1;
    abae:	00 18 d2 43 	movx.a	#1,	&0xfd1aa;r3 As==01
    abb2:	aa d1 

0000abb4 <.L52>:
    chSysUnlock();
    return;
  }
  
  calc_next_buff();
  chSysUnlock();
    abb4:	4a 13       	calla	r10		;

0000abb6 <.LBB34>:
  asm volatile("nop");
    abb6:	03 43       	nop			

0000abb8 <.Loc.356.2>:
  _enable_interrupts();
    abb8:	03 43       	nop			
    abba:	32 d2       	eint			
    abbc:	03 43       	nop			

0000abbe <.LBE34>:
  
}
    abbe:	06 16       	popm.a	#1,	r6	;20-bit words
    abc0:	08 16       	popm.a	#1,	r8	;20-bit words
    abc2:	0a 16       	popm.a	#1,	r10	;20-bit words
    abc4:	10 01       	reta			;

0000abc6 <.L44>:
  calc_next_buff();
    abc6:	46 13       	calla	r6		;

0000abc8 <.LVL23>:
    abc8:	80 00 b4 ab 	mova	#43956,	r0	;0x0abb4

0000abcc <elyUARTDLLRxInit>:

void elyUARTDLLRxInit(UARTDriver * uartp) {
  (void)(uartp);
  
  uart_thd = chThdGetSelfX();
    abcc:	80 18 d2 42 	movx.a	&0x11320,&0xfd1a2;
    abd0:	20 13 a2 d1 

0000abd4 <.Loc.139.1>:
}
    abd4:	10 01       	reta			;

0000abd6 <elyUARTDLLRxHandleBuffer>:
    rx_state = ELY_SLIP_RESET;
  }

}

void elyUARTDLLRxHandleBuffer() {
    abd6:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000abd8 <.LCFI8>:
  handle_buffer(bytes_available, curr_rx_buf);
    abd8:	28 00 ba d1 	mova	&53690,	r8	;0x0d1ba
    abdc:	2a 01 fc 09 	mova	&68092,	r10	;0x109fc

0000abe0 <.LBB39>:
  const uint8_t * end = buffer + bytes_available;
    abe0:	c5 0a       	mova	r10,	r5	;
    abe2:	e5 08       	adda	r8,	r5	;

0000abe4 <.LBB41>:
        rx_active_buffer = elyNLGetBuffer();
    abe4:	87 00 38 c1 	mova	#49464,	r7	;0x0c138

0000abe8 <.Loc.228.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    abe8:	84 00 2a c2 	mova	#49706,	r4	;0x0c22a

0000abec <.Loc.222.1>:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    abec:	86 00 dc 47 	mova	#18396,	r6	;0x047dc

0000abf0 <.L55>:
  while (cp < end) {
    abf0:	da 05       	cmpa	r5,	r10	;
    abf2:	1c 28       	jnc	$+58     	;abs 0xac2c

0000abf4 <.Loc.237.1>:
  if (bytes_available < SLIP_RX_BUF_LEN) {
    abf4:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    abf8:	dc 08       	cmpa	r8,	r12	;
    abfa:	0d 28       	jnc	$+28     	;abs 0xac16

0000abfc <.Loc.238.1>:
    if (NULL != rx_active_buffer) {
    abfc:	2c 00 c2 d1 	mova	&53698,	r12	;0x0d1c2
    ac00:	9c 00 00 00 	cmpa	#0,	r12	;
    ac04:	05 24       	jz	$+12     	;abs 0xac10

0000ac06 <.Loc.239.1>:
      elyNLFreeBuffer(rx_active_buffer);
    ac06:	b0 13 42 c1 	calla	#49474		;0x0c142

0000ac0a <.LVL28>:
      rx_active_buffer = NULL;
    ac0a:	00 18 c2 43 	movx.a	#0,	&0xfd1c2;r3 As==00
    ac0e:	c2 d1 

0000ac10 <.L78>:
    rx_state = ELY_SLIP_RESET;
    ac10:	40 18 c2 43 	movx.b	#0,	&0xfd1c6;r3 As==00
    ac14:	c6 d1 

0000ac16 <.L59>:
  
  if (curr_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    ac16:	01 18 f2 90 	cmpx.a	#53959,	&0x109fc;0x0d2c7
    ac1a:	c7 d2 fc 09 
    ac1e:	a9 20       	jnz	$+340    	;abs 0xad72

0000ac20 <.Loc.251.1>:
    curr_rx_buf = rx_buf;
    ac20:	01 18 f2 40 	movx.a	#53703,	&0x109fc;0x0d1c7
    ac24:	c7 d1 fc 09 

0000ac28 <.L54>:
  }
  else {
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
}
    ac28:	64 16       	popm.a	#7,	r10	;20-bit words
    ac2a:	10 01       	reta			;

0000ac2c <.L76>:
    uint8_t c = *cp;
    ac2c:	69 4a       	mov.b	@r10,	r9	;

0000ac2e <.LVL31>:
    if (rx_state == ELY_SLIP_RESET) {
    ac2e:	40 18 c2 93 	cmpx.b	#0,	&0xfd1c6;r3 As==00
    ac32:	c6 d1 
    ac34:	18 20       	jnz	$+50     	;abs 0xac66

0000ac36 <.Loc.154.1>:
      if (NULL == rx_active_buffer) {
    ac36:	00 18 c2 93 	cmpx.a	#0,	&0xfd1c2;r3 As==00
    ac3a:	c2 d1 
    ac3c:	03 20       	jnz	$+8      	;abs 0xac44

0000ac3e <.Loc.155.1>:
        rx_active_buffer = elyNLGetBuffer();
    ac3e:	47 13       	calla	r7		;

0000ac40 <.LVL32>:
    ac40:	60 0c c2 d1 	mova	r12,	&53698	; 0x0d1c2

0000ac44 <.L57>:
      if (NULL == rx_active_buffer) {
    ac44:	2c 00 c2 d1 	mova	&53698,	r12	;0x0d1c2
    ac48:	9c 00 00 00 	cmpa	#0,	r12	;
    ac4c:	e4 27       	jz	$-54     	;abs 0xac16

0000ac4e <.Loc.161.1>:
      rx_write_ptr = rx_active_buffer;
    ac4e:	60 0c be d1 	mova	r12,	&53694	; 0x0d1be

0000ac52 <.Loc.162.1>:
      rx_n = elyNLHeaderLen;
    ac52:	01 18 f2 40 	movx.a	#6,	&0x109f2;
    ac56:	06 00 f2 09 

0000ac5a <.Loc.163.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    ac5a:	40 18 e2 43 	movx.b	#2,	&0xfd1c6;r3 As==10
    ac5e:	c6 d1 

0000ac60 <.Loc.164.1>:
      header = true;
    ac60:	41 18 d2 43 	movx.b	#1,	&0x109f0;r3 As==01
    ac64:	f0 09 

0000ac66 <.L56>:
    switch (rx_state) {
    ac66:	40 18 5c 42 	movx.b	&0x0d1c6,r12	;
    ac6a:	c6 d1 
    ac6c:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    ac6e:	07 24       	jz	$+16     	;abs 0xac7e
    ac70:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    ac72:	49 24       	jz	$+148    	;abs 0xad06

0000ac74 <.Loc.222.1>:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    ac74:	8c 01 61 07 	mova	#67425,	r12	;0x10761
    ac78:	46 13       	calla	r6		;

0000ac7a <.LVL33>:
    ac7a:	80 00 b8 ac 	mova	#44216,	r0	;0x0acb8

0000ac7e <.L61>:
          switch(c) {
    ac7e:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    ac82:	08 24       	jz	$+18     	;abs 0xac94
    ac84:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    ac88:	32 24       	jz	$+102    	;abs 0xacee

0000ac8a <.L75>:
        rx_state = ELY_SLIP_RESET;
    ac8a:	40 18 c2 43 	movx.b	#0,	&0xfd1c6;r3 As==00
    ac8e:	c6 d1 
    ac90:	80 00 f0 ab 	mova	#44016,	r0	;0x0abf0

0000ac94 <.L64>:
              *rx_write_ptr++ = SLIP_END;
    ac94:	2c 00 be d1 	mova	&53694,	r12	;0x0d1be
    ac98:	cd 0c       	mova	r12,	r13	;
    ac9a:	ad 00 01 00 	adda	#1,	r13	;
    ac9e:	60 0d be d1 	mova	r13,	&53694	; 0x0d1be
    aca2:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    aca6:	00 00 

0000aca8 <.L66>:
          rx_n--;
    aca8:	01 18 f2 53 	addx.a	#-1,	&0x109f2;r3 As==11
    acac:	f2 09 

0000acae <.Loc.182.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    acae:	40 18 e2 43 	movx.b	#2,	&0xfd1c6;r3 As==10
    acb2:	c6 d1 

0000acb4 <.L89>:
                cp++;
    acb4:	aa 00 01 00 	adda	#1,	r10	;

0000acb8 <.L68>:
    if (rx_n == 0 && header) { /* and we haven't reset */
    acb8:	01 18 c2 93 	cmpx.a	#0,	&0x109f2;r3 As==00
    acbc:	f2 09 
    acbe:	98 23       	jnz	$-206    	;abs 0xabf0
    acc0:	41 18 c2 93 	cmpx.b	#0,	&0x109f0;r3 As==00
    acc4:	f0 09 
    acc6:	94 27       	jz	$-214    	;abs 0xabf0

0000acc8 <.Loc.228.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    acc8:	2c 00 c2 d1 	mova	&53698,	r12	;0x0d1c2
    accc:	44 13       	calla	r4		;

0000acce <.LVL35>:
    acce:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    acd2:	61 0c f2 09 	mova	r12,	&68082	; 0x109f2

0000acd6 <.Loc.229.1>:
      header = false;
    acd6:	41 18 c2 43 	movx.b	#0,	&0x109f0;r3 As==00
    acda:	f0 09 

0000acdc <.Loc.230.1>:
      if (rx_n == 0 || rx_n > elyNLMaxLen) {
    acdc:	9c 00 00 00 	cmpa	#0,	r12	;
    ace0:	d4 27       	jz	$-86     	;abs 0xac8a
    ace2:	01 18 c2 9c 	cmpx.a	r12,	&0x10b18;
    ace6:	18 0b 
    ace8:	83 2f       	jc	$-248    	;abs 0xabf0
    acea:	80 00 8a ac 	mova	#44170,	r0	;0x0ac8a

0000acee <.L65>:
              *rx_write_ptr++ = SLIP_ESC;
    acee:	2c 00 be d1 	mova	&53694,	r12	;0x0d1be
    acf2:	cd 0c       	mova	r12,	r13	;
    acf4:	ad 00 01 00 	adda	#1,	r13	;
    acf8:	60 0d be d1 	mova	r13,	&53694	; 0x0d1be
    acfc:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    ad00:	00 00 
    ad02:	80 00 a8 ac 	mova	#44200,	r0	;0x0aca8

0000ad06 <.L62>:
          switch(c) {
    ad06:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    ad0a:	0c 24       	jz	$+26     	;abs 0xad24
    ad0c:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    ad10:	1c 20       	jnz	$+58     	;abs 0xad4a

0000ad12 <.Loc.190.1>:
              if (rx_n == 0) {
    ad12:	01 18 c2 93 	cmpx.a	#0,	&0x109f2;r3 As==00
    ad16:	f2 09 
    ad18:	b8 27       	jz	$-142    	;abs 0xac8a

0000ad1a <.Loc.195.1>:
                rx_state = ELY_SLIP_ESCAPED;
    ad1a:	40 18 d2 43 	movx.b	#1,	&0xfd1c6;r3 As==01
    ad1e:	c6 d1 
    ad20:	80 00 b4 ac 	mova	#44212,	r0	;0x0acb4

0000ad24 <.L70>:
              if (rx_n == 0) {
    ad24:	01 18 c2 93 	cmpx.a	#0,	&0x109f2;r3 As==00
    ad28:	f2 09 
    ad2a:	08 20       	jnz	$+18     	;abs 0xad3c

0000ad2c <.Loc.202.1>:
                elyMainMBPost(rx_active_buffer, TIME_INFINITE);
    ad2c:	4d 43       	clr.b	r13		;
    ad2e:	2c 00 c2 d1 	mova	&53698,	r12	;0x0d1c2
    ad32:	b0 13 b6 7c 	calla	#31926		;0x07cb6

0000ad36 <.LVL36>:
                rx_active_buffer = NULL;
    ad36:	00 18 c2 43 	movx.a	#0,	&0xfd1c2;r3 As==00
    ad3a:	c2 d1 

0000ad3c <.L73>:
              rx_state = ELY_SLIP_RESET;
    ad3c:	40 18 c2 43 	movx.b	#0,	&0xfd1c6;r3 As==00
    ad40:	c6 d1 

0000ad42 <.Loc.206.1>:
              cp++;
    ad42:	aa 00 01 00 	adda	#1,	r10	;
    ad46:	80 00 f0 ab 	mova	#44016,	r0	;0x0abf0

0000ad4a <.L88>:
              if (rx_n == 0) {
    ad4a:	2c 01 f2 09 	mova	&68082,	r12	;0x109f2
    ad4e:	9c 00 00 00 	cmpa	#0,	r12	;
    ad52:	9b 27       	jz	$-200    	;abs 0xac8a

0000ad54 <.Loc.214.1>:
                *rx_write_ptr++ = c;
    ad54:	2e 00 be d1 	mova	&53694,	r14	;0x0d1be
    ad58:	cd 0e       	mova	r14,	r13	;
    ad5a:	ad 00 01 00 	adda	#1,	r13	;
    ad5e:	60 0d be d1 	mova	r13,	&53694	; 0x0d1be
    ad62:	ce 49 00 00 	mov.b	r9,	0(r14)	;

0000ad66 <.Loc.215.1>:
                rx_n--;
    ad66:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    ad6a:	61 0c f2 09 	mova	r12,	&68082	; 0x109f2
    ad6e:	80 00 b4 ac 	mova	#44212,	r0	;0x0acb4

0000ad72 <.L79>:
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    ad72:	01 18 f2 40 	movx.a	#53959,	&0x109fc;0x0d2c7
    ad76:	c7 d2 fc 09 

0000ad7a <.Loc.256.1>:
}
    ad7a:	80 00 28 ac 	mova	#44072,	r0	;0x0ac28

0000ad7e <elyUARTDLLTimeoutCB>:

/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
    ad7e:	b0 13 a6 45 	calla	#17830		;0x045a6

0000ad82 <.LVL40>:
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    ad82:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    ad86:	b0 13 ea 52 	calla	#21226		;0x052ea

0000ad8a <.LVL41>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    ad8a:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    ad8e:	fd 0c       	suba	r12,	r13	;
    ad90:	60 0d ba d1 	mova	r13,	&53690	; 0x0d1ba

0000ad94 <.Loc.268.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    ad94:	6d 42       	mov.b	#4,	r13	;r2 As==10
    ad96:	4e 43       	clr.b	r14		;
    ad98:	2c 00 a2 d1 	mova	&53666,	r12	;0x0d1a2

0000ad9c <.LVL42>:
    ad9c:	b0 13 90 4b 	calla	#19344		;0x04b90

0000ada0 <.LVL43>:
  chSysUnlockFromISR();
    ada0:	b0 13 d0 45 	calla	#17872		;0x045d0

0000ada4 <.LVL44>:

}
    ada4:	10 01       	reta			;

0000ada6 <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    ada6:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000ada8 <.LCFI9>:
    ada8:	c8 0c       	mova	r12,	r8	;
    adaa:	09 4d       	mov	r13,	r9	;

0000adac <.Loc.274.1>:
  chDbgAssert(c < 0x100, "invalid char");
    adac:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

0000adb0 <.LVL46>:
    adb0:	0c 9d       	cmp	r13,	r12	;
    adb2:	04 2c       	jc	$+10     	;abs 0xadbc

0000adb4 <.Loc.274.1>:
    adb4:	8c 01 4e 07 	mova	#67406,	r12	;0x1074e
    adb8:	b0 13 dc 47 	calla	#18396		;0x047dc

0000adbc <.L92>:
  rx_buf[0] = (uint8_t)(c);
    adbc:	8a 00 c7 d1 	mova	#53703,	r10	;0x0d1c7
    adc0:	ca 49 00 00 	mov.b	r9,	0(r10)	;

0000adc4 <.Loc.276.1>:
  chSysLockFromISR();
    adc4:	b0 13 a6 45 	calla	#17830		;0x045a6

0000adc8 <.LVL48>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, rx_buf+1);
    adc8:	ce 0a       	mova	r10,	r14	;
    adca:	ae 00 01 00 	adda	#1,	r14	;
    adce:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    add2:	cc 08       	mova	r8,	r12	;
    add4:	b0 13 a8 52 	calla	#21160		;0x052a8

0000add8 <.LVL49>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    add8:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    addc:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    ade0:	b0 13 8e 50 	calla	#20622		;0x0508e

0000ade4 <.LVL50>:
  
  curr_rx_buf = rx_buf;
    ade4:	61 0a fc 09 	mova	r10,	&68092	; 0x109fc

0000ade8 <.Loc.281.1>:
  next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    ade8:	aa 00 00 01 	adda	#256,	r10	;0x00100
    adec:	61 0a f8 09 	mova	r10,	&68088	; 0x109f8

0000adf0 <.Loc.283.1>:
  
  chSysUnlockFromISR();
    adf0:	b0 13 d0 45 	calla	#17872		;0x045d0

0000adf4 <.LVL51>:
}
    adf4:	28 16       	popm.a	#3,	r10	;20-bit words
    adf6:	10 01       	reta			;

0000adf8 <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    adf8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000adfa <.LCFI10>:
    adfa:	b1 00 04 00 	suba	#4,	r1	;

0000adfe <.LCFI11>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
    adfe:	71 0c 00 00 	mova	r12,	0(r1)	;
    ae02:	b0 13 a6 45 	calla	#17830		;0x045a6

0000ae06 <.LVL53>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, next_rx_buf); 
    ae06:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    ae0a:	2e 01 f8 09 	mova	&68088,	r14	;0x109f8
    ae0e:	cd 0a       	mova	r10,	r13	;
    ae10:	0c 01       	mova	@r1,	r12	;
    ae12:	b0 13 a8 52 	calla	#21160		;0x052a8

0000ae16 <.LVL54>:
  gptStopTimerI(&uart_gpt);
    ae16:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    ae1a:	b0 13 b6 50 	calla	#20662		;0x050b6

0000ae1e <.LVL55>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    ae1e:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    ae22:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    ae26:	b0 13 8e 50 	calla	#20622		;0x0508e

0000ae2a <.LVL56>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    ae2a:	60 0a ba d1 	mova	r10,	&53690	; 0x0d1ba

0000ae2e <.Loc.295.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    ae2e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    ae30:	4e 43       	clr.b	r14		;
    ae32:	2c 00 a2 d1 	mova	&53666,	r12	;0x0d1a2
    ae36:	b0 13 90 4b 	calla	#19344		;0x04b90

0000ae3a <.LVL57>:
  
  if (next_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    ae3a:	01 18 f2 90 	cmpx.a	#53959,	&0x109f8;0x0d2c7
    ae3e:	c7 d2 f8 09 
    ae42:	0a 20       	jnz	$+22     	;abs 0xae58

0000ae44 <.Loc.298.1>:
    next_rx_buf = rx_buf;
    ae44:	01 18 f2 40 	movx.a	#53703,	&0x109f8;0x0d1c7
    ae48:	c7 d1 f8 09 

0000ae4c <.L95>:
  }
  else {
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
  
  chSysUnlockFromISR();
    ae4c:	b0 13 d0 45 	calla	#17872		;0x045d0

0000ae50 <.LVL58>:
}
    ae50:	a1 00 04 00 	adda	#4,	r1	;
    ae54:	0a 16       	popm.a	#1,	r10	;20-bit words
    ae56:	10 01       	reta			;

0000ae58 <.L94>:
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    ae58:	01 18 f2 40 	movx.a	#53959,	&0x109f8;0x0d2c7
    ae5c:	c7 d2 f8 09 
    ae60:	80 00 4c ae 	mova	#44620,	r0	;0x0ae4c

0000ae64 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    ae64:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ae66 <.LCFI0>:
    ae66:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ae68 <.LCFI1>:
    ae68:	06 14       	pushm.a	#1,	r6	;20-bit words

0000ae6a <.LCFI2>:
    ae6a:	ca 0c       	mova	r12,	r10	;
    ae6c:	c8 0d       	mova	r13,	r8	;

0000ae6e <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    ae6e:	40 18 c2 93 	cmpx.b	#0,	&0xfd3c8;r3 As==00
    ae72:	c8 d3 
    ae74:	04 24       	jz	$+10     	;abs 0xae7e

0000ae76 <.Loc.34.1>:
    ae76:	8c 01 b3 07 	mova	#67507,	r12	;0x107b3

0000ae7a <.LVL1>:
    ae7a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000ae7e <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    ae7e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ae80:	dc 08       	cmpa	r8,	r12	;
    ae82:	04 28       	jnc	$+10     	;abs 0xae8c

0000ae84 <.Loc.38.1>:
    ae84:	8c 01 b3 07 	mova	#67507,	r12	;0x107b3
    ae88:	b0 13 dc 47 	calla	#18396		;0x047dc

0000ae8c <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    ae8c:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    ae90:	54 01 

0000ae92 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    ae92:	ce 0a       	mova	r10,	r14	;
    ae94:	cc 08       	mova	r8,	r12	;
    ae96:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000ae9a <.L4>:
    ae9a:	00 18 46 4e 	movx.a	r14,	r6	;
    ae9e:	00 18 46 8a 	subx.a	r10,	r6	;

0000aea2 <.LVL6>:
    aea2:	d6 0c       	cmpa	r12,	r6	;
    aea4:	12 28       	jnc	$+38     	;abs 0xaeca

0000aea6 <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    aea6:	ec 0a       	adda	r10,	r12	;
    aea8:	40 18 5d 42 	movx.b	&0x00157,r13	;
    aeac:	57 01 
    aeae:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    aeb0:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000aeb4 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    aeb4:	ea 08       	adda	r8,	r10	;

0000aeb6 <.LVL7>:
    aeb6:	40 18 5c 42 	movx.b	&0x00156,r12	;
    aeba:	56 01 
    aebc:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    aebe:	ca 4c ff ff 	mov.b	r12,	-1(r10)	; 0xffff

0000aec2 <.Loc.63.1>:
}
    aec2:	06 16       	popm.a	#1,	r6	;20-bit words
    aec4:	08 16       	popm.a	#1,	r8	;20-bit words
    aec6:	0a 16       	popm.a	#1,	r10	;20-bit words
    aec8:	10 01       	reta			;

0000aeca <.L5>:
      CRCDI_L = message[i];
    aeca:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    aece:	50 01 

0000aed0 <.LVL9>:
    aed0:	ae 00 01 00 	adda	#1,	r14	;

0000aed4 <.LVL10>:
    aed4:	80 00 9a ae 	mova	#44698,	r0	;0x0ae9a

0000aed8 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    aed8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aeda <.LCFI3>:
    aeda:	08 14       	pushm.a	#1,	r8	;20-bit words

0000aedc <.LCFI4>:
    aedc:	06 14       	pushm.a	#1,	r6	;20-bit words

0000aede <.LCFI5>:
    aede:	ca 0c       	mova	r12,	r10	;
    aee0:	c8 0d       	mova	r13,	r8	;

0000aee2 <.Loc.72.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    aee2:	40 18 c2 93 	cmpx.b	#0,	&0xfd3c8;r3 As==00
    aee6:	c8 d3 
    aee8:	04 24       	jz	$+10     	;abs 0xaef2

0000aeea <.Loc.72.1>:
    aeea:	8c 01 a7 07 	mova	#67495,	r12	;0x107a7

0000aeee <.LVL12>:
    aeee:	b0 13 dc 47 	calla	#18396		;0x047dc

0000aef2 <.L7>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    aef2:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    aef6:	54 01 

0000aef8 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    aef8:	ce 0a       	mova	r10,	r14	;
    aefa:	cc 08       	mova	r8,	r12	;
    aefc:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000af00 <.L8>:
    af00:	00 18 46 4e 	movx.a	r14,	r6	;
    af04:	00 18 46 8a 	subx.a	r10,	r6	;

0000af08 <.LVL16>:
    af08:	d6 0c       	cmpa	r12,	r6	;
    af0a:	14 28       	jnc	$+42     	;abs 0xaf34

0000af0c <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    af0c:	ec 0a       	adda	r10,	r12	;
    af0e:	6d 4c       	mov.b	@r12,	r13	;
    af10:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    af14:	ea 08       	adda	r8,	r10	;

0000af16 <.LVL17>:
    af16:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    af1a:	0d da       	bis	r10,	r13	;
    af1c:	40 18 1e 42 	movx.w	&0x00156,r14	;
    af20:	56 01 
    af22:	3e e3       	inv	r14		;
    af24:	5c 43       	mov.b	#1,	r12	;r3 As==01
    af26:	0d 9e       	cmp	r14,	r13	;
    af28:	01 24       	jz	$+4      	;abs 0xaf2c
    af2a:	4c 43       	clr.b	r12		;

0000af2c <.L10>:
}
    af2c:	06 16       	popm.a	#1,	r6	;20-bit words
    af2e:	08 16       	popm.a	#1,	r8	;20-bit words
    af30:	0a 16       	popm.a	#1,	r10	;20-bit words
    af32:	10 01       	reta			;

0000af34 <.L9>:
      CRCDI_L = message[i];
    af34:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    af38:	50 01 

0000af3a <.LVL19>:
    af3a:	ae 00 01 00 	adda	#1,	r14	;

0000af3e <.LVL20>:
    af3e:	80 00 00 af 	mova	#44800,	r0	;0x0af00

0000af42 <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    af42:	40 18 c2 93 	cmpx.b	#0,	&0xfd3c8;r3 As==00
    af46:	c8 d3 
    af48:	04 24       	jz	$+10     	;abs 0xaf52

0000af4a <.Loc.103.1>:
    af4a:	8c 01 9e 07 	mova	#67486,	r12	;0x1079e
    af4e:	b0 13 dc 47 	calla	#18396		;0x047dc

0000af52 <.L12>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    af52:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    af56:	54 01 

0000af58 <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    af58:	40 18 d2 43 	movx.b	#1,	&0xfd3c8;r3 As==01
    af5c:	c8 d3 

0000af5e <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    af5e:	8c 00 50 01 	mova	#336,	r12	;0x00150
    af62:	10 01       	reta			;

0000af64 <crcStop>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    af64:	40 18 d2 93 	cmpx.b	#1,	&0xfd3c8;r3 As==01
    af68:	c8 d3 
    af6a:	04 24       	jz	$+10     	;abs 0xaf74

0000af6c <.Loc.119.1>:
    af6c:	8c 01 96 07 	mova	#67478,	r12	;0x10796
    af70:	b0 13 dc 47 	calla	#18396		;0x047dc

0000af74 <.L14>:
  /* Change state */
  crc_state = CRC_STOPPED;
    af74:	40 18 c2 43 	movx.b	#0,	&0xfd3c8;r3 As==00
    af78:	c8 d3 

0000af7a <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    af7a:	40 18 1c 42 	movx.w	&0x00156,r12	;
    af7e:	56 01 
    af80:	3c e3       	inv	r12		;
    af82:	10 01       	reta			;

0000af84 <crcGenSDLP>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenSDLP(uint8_t * message, size_t n) {
    af84:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000af86 <.LCFI0>:
    af86:	08 14       	pushm.a	#1,	r8	;20-bit words

0000af88 <.LCFI1>:
    af88:	06 14       	pushm.a	#1,	r6	;20-bit words

0000af8a <.LCFI2>:
    af8a:	ca 0c       	mova	r12,	r10	;
    af8c:	c8 0d       	mova	r13,	r8	;

0000af8e <.Loc.30.1>:
  /* SDLP CRC is MSB first in and out (CRCDIRB+CRCINIRES), with an initial value
   * of 0xFFFF and no inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    af8e:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000af90 <.LVL1>:
    af90:	dc 0d       	cmpa	r13,	r12	;
    af92:	04 28       	jnc	$+10     	;abs 0xaf9c

0000af94 <.Loc.30.1>:
    af94:	8c 01 bd 07 	mova	#67517,	r12	;0x107bd
    af98:	b0 13 dc 47 	calla	#18396		;0x047dc

0000af9c <.L2>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    af9c:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    afa0:	54 01 

0000afa2 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    afa2:	ce 0a       	mova	r10,	r14	;
    afa4:	cc 08       	mova	r8,	r12	;
    afa6:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000afaa <.L3>:
    afaa:	00 18 46 4e 	movx.a	r14,	r6	;
    afae:	00 18 46 8a 	subx.a	r10,	r6	;

0000afb2 <.LVL5>:
    afb2:	d6 0c       	cmpa	r12,	r6	;
    afb4:	0e 28       	jnc	$+30     	;abs 0xafd2

0000afb6 <.LBE2>:
#endif
  
   
  /* Write result to final 2 bytes */
  /* MSB comes first because of how things are transmitted */
  *(message+n-2) = (CRCINIRES_H);
    afb6:	ec 0a       	adda	r10,	r12	;
    afb8:	40 18 dc 42 	movx.b	&0x00155,0(r12)	;
    afbc:	55 01 00 00 

0000afc0 <.Loc.55.1>:
  *(message+n-1) = (CRCINIRES_L);
    afc0:	ea 08       	adda	r8,	r10	;

0000afc2 <.LVL6>:
    afc2:	4f 18 da 42 	movx.b	&0x00154,-1(r10)	; 0xfffff
    afc6:	54 01 ff ff 

0000afca <.Loc.56.1>:
}
    afca:	06 16       	popm.a	#1,	r6	;20-bit words
    afcc:	08 16       	popm.a	#1,	r8	;20-bit words
    afce:	0a 16       	popm.a	#1,	r10	;20-bit words
    afd0:	10 01       	reta			;

0000afd2 <.L4>:
      CRCDIRB_L = message[i];
    afd2:	40 18 e2 4e 	movx.b	@r14,	&0x00152;
    afd6:	52 01 

0000afd8 <.LVL8>:
    afd8:	ae 00 01 00 	adda	#1,	r14	;

0000afdc <.LVL9>:
    afdc:	80 00 aa af 	mova	#44970,	r0	;0x0afaa

0000afe0 <port_lock>:
  _disable_interrupts();
    afe0:	32 c2       	dint			
    afe2:	03 43       	nop			

0000afe4 <.Loc.348.1>:
  asm volatile("nop");
    afe4:	03 43       	nop			

0000afe6 <.Loc.349.1>:
}
    afe6:	10 01       	reta			;

0000afe8 <port_unlock>:
  asm volatile("nop");
    afe8:	03 43       	nop			

0000afea <.Loc.356.1>:
  _enable_interrupts();
    afea:	03 43       	nop			
    afec:	32 d2       	eint			
    afee:	03 43       	nop			

0000aff0 <.Loc.357.1>:
}
    aff0:	10 01       	reta			;

0000aff2 <elyRFPostI>:
static const PERSIST rf_events_t AllRfEvents = 0x1FFFF;
static const PERSIST rf_events_t RFTxCfgMask = 0x155;
static const PERSIST rf_events_t RFRxCfgMask = 0xAA;
static eventmask_t events;

msg_t elyRFPostI(uint8_t * buffer) {
    aff2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aff4 <.LCFI0>:
  msg_t msg;
  msg = chMBPostI(&rf_mbox, (msg_t)(buffer));
    aff4:	cd 0c       	mova	r12,	r13	;
    aff6:	8c 01 82 0a 	mova	#68226,	r12	;0x10a82

0000affa <.LVL1>:
    affa:	b0 13 f0 4c 	calla	#19696		;0x04cf0

0000affe <.LVL2>:
    affe:	ca 0c       	mova	r12,	r10	;

0000b000 <.Loc.19.2>:
  if (MSG_OK == msg) {
    b000:	9c 00 00 00 	cmpa	#0,	r12	;
    b004:	07 20       	jnz	$+16     	;abs 0xb014

0000b006 <.Loc.20.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    b006:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    b00a:	4e 43       	clr.b	r14		;
    b00c:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    b010:	b0 13 90 4b 	calla	#19344		;0x04b90

0000b014 <.L3>:
  }
  return msg;
}
    b014:	cc 0a       	mova	r10,	r12	;
    b016:	0a 16       	popm.a	#1,	r10	;20-bit words
    b018:	10 01       	reta			;

0000b01a <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
    b01a:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000b01c <.LCFI1>:
    b01c:	ca 0c       	mova	r12,	r10	;
    b01e:	09 4d       	mov	r13,	r9	;

0000b020 <.Loc.27.2>:
  msg_t msg;
  chSysLock();
    b020:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b024 <.LVL6>:
    b024:	b0 13 54 45 	calla	#17748		;0x04554

0000b028 <.LVL7>:
  msg = chMBPostS(&rf_mbox, (msg_t)(buffer), timeout);
    b028:	0e 49       	mov	r9,	r14	;
    b02a:	cd 0a       	mova	r10,	r13	;
    b02c:	8c 01 82 0a 	mova	#68226,	r12	;0x10a82
    b030:	b0 13 54 4c 	calla	#19540		;0x04c54

0000b034 <.LVL8>:
    b034:	ca 0c       	mova	r12,	r10	;

0000b036 <.LVL9>:
  if (MSG_OK == msg) {
    b036:	9c 00 00 00 	cmpa	#0,	r12	;
    b03a:	07 20       	jnz	$+16     	;abs 0xb04a

0000b03c <.Loc.30.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    b03c:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    b040:	4e 43       	clr.b	r14		;
    b042:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    b046:	b0 13 90 4b 	calla	#19344		;0x04b90

0000b04a <.L6>:
  }
  chSysUnlock();
    b04a:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b04e <.LVL11>:
    b04e:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b052 <.LVL12>:
  return msg;
}
    b052:	cc 0a       	mova	r10,	r12	;
    b054:	19 16       	popm.a	#2,	r10	;20-bit words
    b056:	10 01       	reta			;

0000b058 <elyRFCfgMarkDirty>:
  chDbgAssert(event & RFCfgMask, "invalid event");
  
  chEvtSignalI(rf_thd, event);
}

void elyRFCfgMarkDirty(rf_events_t event) {
    b058:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000b05a <.LCFI3>:
    b05a:	0a 4c       	mov	r12,	r10	;
    b05c:	09 4d       	mov	r13,	r9	;

0000b05e <.Loc.44.2>:
  chDbgAssert(chThdGetSelfX() != rf_thd, "can't set your own config dirty");
    b05e:	81 18 d2 92 	cmpx.a	&0x1190c,&0x11320;
    b062:	0c 19 20 13 
    b066:	04 20       	jnz	$+10     	;abs 0xb070

0000b068 <.Loc.44.2>:
    b068:	8c 01 ce 07 	mova	#67534,	r12	;0x107ce

0000b06c <.LVL19>:
    b06c:	b0 13 dc 47 	calla	#18396		;0x047dc

0000b070 <.L11>:
  chDbgAssert(event & RFCfgMask, "invalid event");
    b070:	3a b0 ff 03 	bit	#1023,	r10	;#0x03ff
    b074:	04 20       	jnz	$+10     	;abs 0xb07e

0000b076 <.Loc.45.2>:
    b076:	8c 01 ce 07 	mova	#67534,	r12	;0x107ce
    b07a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000b07e <.L12>:
  
  chEvtSignal(rf_thd, event);
    b07e:	0d 4a       	mov	r10,	r13	;
    b080:	0e 49       	mov	r9,	r14	;
    b082:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    b086:	b0 13 5c 4b 	calla	#19292		;0x04b5c

0000b08a <.LVL22>:
}
    b08a:	19 16       	popm.a	#2,	r10	;20-bit words
    b08c:	10 01       	reta			;

0000b08e <elyRFChangeTxFreqS>:
static eventmask_t get_next_event(eventmask_t mask) {
  mask ^= mask & (mask - (eventmask_t)1);
  return mask;
}

void __attribute__((weak)) elyRFChangeTxFreqS(SX1278Config * cfg) {
    b08e:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b090 <.LCFI4>:
    b090:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b092 <.LCFI5>:
    b092:	ca 0c       	mova	r12,	r10	;

0000b094 <.Loc.56.2>:
  chSysLock();
    b094:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b098 <.LVL24>:
    b098:	b0 13 54 45 	calla	#17748		;0x04554

0000b09c <.LVL25>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    b09c:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b0a0:	5d 4e 01 00 	mov.b	1(r14),	r13	;
    b0a4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b0a8:	6c 4e       	mov.b	@r14,	r12	;
    b0aa:	0d dc       	bis	r12,	r13	;
    b0ac:	5c 4e 03 00 	mov.b	3(r14),	r12	;
    b0b0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b0b4:	5e 4e 02 00 	mov.b	2(r14),	r14	;
    b0b8:	0c de       	bis	r14,	r12	;

0000b0ba <.Loc.61.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  if (cfg->freq > TX_BAND_MAX) {
    b0ba:	3e 40 ec 38 	mov	#14572,	r14	;#0x38ec
    b0be:	0e 9c       	cmp	r12,	r14	;
    b0c0:	4d 28       	jnc	$+156    	;abs 0xb15c
    b0c2:	0c 9e       	cmp	r14,	r12	;
    b0c4:	04 20       	jnz	$+10     	;abs 0xb0ce
    b0c6:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    b0ca:	0e 9d       	cmp	r13,	r14	;
    b0cc:	47 28       	jnc	$+144    	;abs 0xb15c

0000b0ce <.L19>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    b0ce:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    b0d2:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000b0d6 <.L16>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < TX_BAND_MIN) {
    b0d6:	3c 40 8e 33 	mov	#13198,	r12	;#0x338e
    b0da:	1c 9a 0e 00 	cmp	14(r10),r12	;0x0000e
    b0de:	2f 28       	jnc	$+96     	;abs 0xb13e
    b0e0:	8a 9c 0e 00 	cmp	r12,	14(r10)	; 0x000e
    b0e4:	05 20       	jnz	$+12     	;abs 0xb0f0
    b0e6:	3e 40 3f da 	mov	#-9665,	r14	;#0xda3f
    b0ea:	1e 9a 0c 00 	cmp	12(r10),r14	;0x0000c
    b0ee:	27 28       	jnc	$+80     	;abs 0xb13e

0000b0f0 <.L20>:
    cfg->freq = TX_BAND_MIN;
    b0f0:	ba 40 40 da 	mov	#-9664,	12(r10)	;#0xda40, 0x000c
    b0f4:	0c 00 
    b0f6:	ba 40 8e 33 	mov	#13198,	14(r10)	;#0x338e, 0x000e
    b0fa:	0e 00 

0000b0fc <.Loc.70.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    b0fc:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b100:	f8 40 40 00 	mov.b	#64,	0(r8)	;#0x0040
    b104:	00 00 

0000b106 <.Loc.71.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b106:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b10a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b10e:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b112:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000b116 <.Loc.72.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b116:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b11a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b11e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b122:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b126:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000b12a <.Loc.73.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    b12a:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b12e:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b132:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b136:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b13a:	c8 4c 03 00 	mov.b	r12,	3(r8)	;

0000b13e <.L17>:
  }
  chSysUnlock();
    b13e:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b142 <.LVL29>:
    b142:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b146 <.LVL30>:
  
  /* This is pretty fast */
  sx1278SetFrequency(&SX1278D1, cfg->freq);
    b146:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    b14a:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    b14e:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b152:	b0 13 00 69 	calla	#26880		;0x06900

0000b156 <.LVL31>:
}
    b156:	08 16       	popm.a	#1,	r8	;20-bit words
    b158:	0a 16       	popm.a	#1,	r10	;20-bit words
    b15a:	10 01       	reta			;

0000b15c <.L14>:
    cfg->freq = TX_BAND_MAX;
    b15c:	ba 40 c0 24 	mov	#9408,	12(r10)	;#0x24c0, 0x000c
    b160:	0c 00 
    b162:	ba 40 ec 38 	mov	#14572,	14(r10)	;#0x38ec, 0x000e
    b166:	0e 00 

0000b168 <.Loc.63.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    b168:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b16c:	f8 40 c0 ff 	mov.b	#-64,	0(r8)	;#0xffc0
    b170:	00 00 

0000b172 <.Loc.64.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b172:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b176:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b17a:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b17e:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000b182 <.Loc.65.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b182:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b186:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b18a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b18e:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b192:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000b196 <.Loc.66.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    b196:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b19a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b19e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b1a2:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b1a6:	c8 4c 03 00 	mov.b	r12,	3(r8)	;
    b1aa:	80 00 d6 b0 	mova	#45270,	r0	;0x0b0d6

0000b1ae <elyRFChangeRxFreqS>:

void __attribute__((weak)) elyRFChangeRxFreqS(SX1212Config * cfg) {
    b1ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b1b0 <.LCFI6>:
    b1b0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b1b2 <.LCFI7>:
    b1b2:	ca 0c       	mova	r12,	r10	;

0000b1b4 <.Loc.82.2>:
  chSysLock();
    b1b4:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b1b8 <.LVL36>:
    b1b8:	b0 13 54 45 	calla	#17748		;0x04554

0000b1bc <.LVL37>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    b1bc:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b1c0:	5d 4e 05 00 	mov.b	5(r14),	r13	;
    b1c4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b1c8:	5c 4e 04 00 	mov.b	4(r14),	r12	;
    b1cc:	0d dc       	bis	r12,	r13	;
    b1ce:	5c 4e 07 00 	mov.b	7(r14),	r12	;
    b1d2:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b1d6:	5e 4e 06 00 	mov.b	6(r14),	r14	;
    b1da:	0c de       	bis	r14,	r12	;

0000b1dc <.Loc.87.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  if (cfg->freq > RX_BAND_MAX) {
    b1dc:	3e 40 12 1c 	mov	#7186,	r14	;#0x1c12
    b1e0:	0e 9c       	cmp	r12,	r14	;
    b1e2:	4d 28       	jnc	$+156    	;abs 0xb27e
    b1e4:	0c 9e       	cmp	r14,	r12	;
    b1e6:	04 20       	jnz	$+10     	;abs 0xb1f0
    b1e8:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    b1ec:	0e 9d       	cmp	r13,	r14	;
    b1ee:	47 28       	jnc	$+144    	;abs 0xb27e

0000b1f0 <.L27>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    b1f0:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    b1f4:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000b1f8 <.L24>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < RX_BAND_MIN) {
    b1f8:	3c 40 3d 1b 	mov	#6973,	r12	;#0x1b3d
    b1fc:	1c 9a 12 00 	cmp	18(r10),r12	;0x00012
    b200:	2f 28       	jnc	$+96     	;abs 0xb260
    b202:	8a 9c 12 00 	cmp	r12,	18(r10)	; 0x0012
    b206:	05 20       	jnz	$+12     	;abs 0xb212
    b208:	3e 40 3f 44 	mov	#17471,	r14	;#0x443f
    b20c:	1e 9a 10 00 	cmp	16(r10),r14	;0x00010
    b210:	27 28       	jnc	$+80     	;abs 0xb260

0000b212 <.L28>:
    cfg->freq = RX_BAND_MIN;
    b212:	ba 40 40 44 	mov	#17472,	16(r10)	;#0x4440, 0x0010
    b216:	10 00 
    b218:	ba 40 3d 1b 	mov	#6973,	18(r10)	;#0x1b3d, 0x0012
    b21c:	12 00 

0000b21e <.Loc.96.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    b21e:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b222:	f8 40 40 00 	mov.b	#64,	4(r8)	;#0x0040
    b226:	04 00 

0000b228 <.Loc.97.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b228:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b22c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b230:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b234:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000b238 <.Loc.98.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b238:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b23c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b240:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b244:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b248:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000b24c <.Loc.99.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    b24c:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b250:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b254:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b258:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b25c:	c8 4c 07 00 	mov.b	r12,	7(r8)	;

0000b260 <.L25>:
  }
  chSysUnlock();
    b260:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b264 <.LVL41>:
    b264:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b268 <.LVL42>:
  
  /* This is INCREDIBLY slow */
  sx1212SetFrequency(&SX1212D1, cfg->freq);
    b268:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    b26c:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    b270:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b274:	b0 13 30 73 	calla	#29488		;0x07330

0000b278 <.LVL43>:
}
    b278:	08 16       	popm.a	#1,	r8	;20-bit words
    b27a:	0a 16       	popm.a	#1,	r10	;20-bit words
    b27c:	10 01       	reta			;

0000b27e <.L22>:
    cfg->freq = RX_BAND_MAX;
    b27e:	ba 40 c0 e3 	mov	#-7232,	16(r10)	;#0xe3c0, 0x0010
    b282:	10 00 
    b284:	ba 40 12 1c 	mov	#7186,	18(r10)	;#0x1c12, 0x0012
    b288:	12 00 

0000b28a <.Loc.89.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    b28a:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b28e:	f8 40 c0 ff 	mov.b	#-64,	4(r8)	;#0xffc0
    b292:	04 00 

0000b294 <.Loc.90.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b294:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b298:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b29c:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b2a0:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000b2a4 <.Loc.91.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b2a4:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b2a8:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b2ac:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b2b0:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b2b4:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000b2b8 <.Loc.92.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    b2b8:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b2bc:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b2c0:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b2c4:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b2c8:	c8 4c 07 00 	mov.b	r12,	7(r8)	;
    b2cc:	80 00 f8 b1 	mova	#45560,	r0	;0x0b1f8

0000b2d0 <elyRFChangeTxBRS>:

void __attribute__((weak)) elyRFChangeTxBRS(SX1278Config * cfg) {
    b2d0:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b2d2 <.LCFI8>:
    b2d2:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b2d4 <.LCFI9>:
    b2d4:	ca 0c       	mova	r12,	r10	;

0000b2d6 <.Loc.108.2>:
  chSysLock();
    b2d6:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b2da <.LVL48>:
    b2da:	b0 13 54 45 	calla	#17748		;0x04554

0000b2de <.LVL49>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    b2de:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b2e2:	5d 4e 19 00 	mov.b	25(r14),r13	;0x00019
    b2e6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b2ea:	5c 4e 18 00 	mov.b	24(r14),r12	;0x00018
    b2ee:	0d dc       	bis	r12,	r13	;
    b2f0:	5c 4e 1b 00 	mov.b	27(r14),r12	;0x0001b
    b2f4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b2f8:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x0001a
    b2fc:	0c de       	bis	r14,	r12	;

0000b2fe <.Loc.113.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  if (cfg->bitrate > TX_BR_MAX) {
    b2fe:	6e 42       	mov.b	#4,	r14	;r2 As==10
    b300:	0e 9c       	cmp	r12,	r14	;
    b302:	47 28       	jnc	$+144    	;abs 0xb392
    b304:	0c 9e       	cmp	r14,	r12	;
    b306:	04 20       	jnz	$+10     	;abs 0xb310
    b308:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    b30c:	0e 9d       	cmp	r13,	r14	;
    b30e:	41 28       	jnc	$+132    	;abs 0xb392

0000b310 <.L35>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b310:	8a 4d 08 00 	mov	r13,	8(r10)	;
    b314:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000b318 <.L32>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < TX_BR_MIN) {
    b318:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    b31c:	2b 20       	jnz	$+88     	;abs 0xb374
    b31e:	3c 40 af 04 	mov	#1199,	r12	;#0x04af
    b322:	1c 9a 08 00 	cmp	8(r10),	r12	;
    b326:	26 28       	jnc	$+78     	;abs 0xb374

0000b328 <.Loc.121.2>:
    cfg->bitrate = TX_BR_MIN;
    b328:	ba 40 b0 04 	mov	#1200,	8(r10)	;#0x04b0
    b32c:	08 00 
    b32e:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000b332 <.Loc.122.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b332:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b336:	f8 40 b0 ff 	mov.b	#-80,	24(r8)	;#0xffb0, 0x0018
    b33a:	18 00 

0000b33c <.Loc.123.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b33c:	1c 4a 08 00 	mov	8(r10),	r12	;
    b340:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b344:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b348:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b34c <.Loc.124.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b34c:	1c 4a 08 00 	mov	8(r10),	r12	;
    b350:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b354:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b358:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b35c:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b360 <.Loc.125.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b360:	1c 4a 08 00 	mov	8(r10),	r12	;
    b364:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b368:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b36c:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b370:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b

0000b374 <.L33>:
  }
  chSysUnlock();
    b374:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b378 <.LVL53>:
    b378:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b37c <.LVL54>:
  
  /* This is fast */
  sx1278SetBitrate(&SX1278D1, cfg->bitrate);
    b37c:	1d 4a 08 00 	mov	8(r10),	r13	;
    b380:	1e 4a 0a 00 	mov	10(r10),r14	;0x0000a
    b384:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b388:	b0 13 3c 68 	calla	#26684		;0x0683c

0000b38c <.LVL55>:
}
    b38c:	08 16       	popm.a	#1,	r8	;20-bit words
    b38e:	0a 16       	popm.a	#1,	r10	;20-bit words
    b390:	10 01       	reta			;

0000b392 <.L30>:
    cfg->bitrate = TX_BR_MAX;
    b392:	ba 40 e0 93 	mov	#-27680,8(r10)	;#0x93e0
    b396:	08 00 
    b398:	aa 42 0a 00 	mov	#4,	10(r10)	;r2 As==10, 0x000a

0000b39c <.Loc.115.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b39c:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b3a0:	f8 40 e0 ff 	mov.b	#-32,	24(r8)	;#0xffe0, 0x0018
    b3a4:	18 00 

0000b3a6 <.Loc.116.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b3a6:	1c 4a 08 00 	mov	8(r10),	r12	;
    b3aa:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b3ae:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b3b2:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b3b6 <.Loc.117.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b3b6:	1c 4a 08 00 	mov	8(r10),	r12	;
    b3ba:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b3be:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b3c2:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b3c6:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b3ca <.Loc.118.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b3ca:	1c 4a 08 00 	mov	8(r10),	r12	;
    b3ce:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b3d2:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b3d6:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b3da:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b
    b3de:	80 00 18 b3 	mova	#45848,	r0	;0x0b318

0000b3e2 <elyRFChangeRxBRS>:

void __attribute__((weak)) elyRFChangeRxBRS(SX1212Config * cfg) {
    b3e2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b3e4 <.LCFI10>:
    b3e4:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b3e6 <.LCFI11>:
    b3e6:	ca 0c       	mova	r12,	r10	;

0000b3e8 <.Loc.134.2>:
  chSysLock();
    b3e8:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b3ec <.LVL60>:
    b3ec:	b0 13 54 45 	calla	#17748		;0x04554

0000b3f0 <.LVL61>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    b3f0:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b3f4:	5d 4e 1d 00 	mov.b	29(r14),r13	;0x0001d
    b3f8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b3fc:	5c 4e 1c 00 	mov.b	28(r14),r12	;0x0001c
    b400:	0d dc       	bis	r12,	r13	;
    b402:	5c 4e 1f 00 	mov.b	31(r14),r12	;0x0001f
    b406:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b40a:	5e 4e 1e 00 	mov.b	30(r14),r14	;0x0001e
    b40e:	0c de       	bis	r14,	r12	;

0000b410 <.Loc.139.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  if (cfg->bitrate > RX_BR_MAX) {
    b410:	6e 43       	mov.b	#2,	r14	;r3 As==10
    b412:	0e 9c       	cmp	r12,	r14	;
    b414:	47 28       	jnc	$+144    	;abs 0xb4a4
    b416:	0c 9e       	cmp	r14,	r12	;
    b418:	04 20       	jnz	$+10     	;abs 0xb422
    b41a:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    b41e:	0e 9d       	cmp	r13,	r14	;
    b420:	41 28       	jnc	$+132    	;abs 0xb4a4

0000b422 <.L43>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
    b422:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    b426:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000b42a <.L40>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < RX_BR_MIN) {
    b42a:	8a 93 0e 00 	cmp	#0,	14(r10)	;r3 As==00, 0x000e
    b42e:	2b 20       	jnz	$+88     	;abs 0xb486
    b430:	3c 40 0b 03 	mov	#779,	r12	;#0x030b
    b434:	1c 9a 0c 00 	cmp	12(r10),r12	;0x0000c
    b438:	26 28       	jnc	$+78     	;abs 0xb486

0000b43a <.Loc.147.2>:
    cfg->bitrate = RX_BR_MIN;
    b43a:	ba 40 0c 03 	mov	#780,	12(r10)	;#0x030c, 0x000c
    b43e:	0c 00 
    b440:	8a 43 0e 00 	mov	#0,	14(r10)	;r3 As==00, 0x000e

0000b444 <.Loc.148.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b444:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b448:	f8 40 0c 00 	mov.b	#12,	28(r8)	;#0x000c, 0x001c
    b44c:	1c 00 

0000b44e <.Loc.149.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b44e:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b452:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b456:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b45a:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b45e <.Loc.150.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b45e:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b462:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b466:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b46a:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b46e:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b472 <.Loc.151.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b472:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b476:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b47a:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b47e:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b482:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f

0000b486 <.L41>:
  }
  chSysUnlock();
    b486:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b48a <.LVL65>:
    b48a:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b48e <.LVL66>:
  
  /* This is only moderately slow */
  sx1212SetBitrate(&SX1212D1, cfg->bitrate);
    b48e:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    b492:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    b496:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b49a:	b0 13 da 71 	calla	#29146		;0x071da

0000b49e <.LVL67>:
}
    b49e:	08 16       	popm.a	#1,	r8	;20-bit words
    b4a0:	0a 16       	popm.a	#1,	r10	;20-bit words
    b4a2:	10 01       	reta			;

0000b4a4 <.L38>:
    cfg->bitrate = RX_BR_MAX;
    b4a4:	ba 40 f0 49 	mov	#18928,	12(r10)	;#0x49f0, 0x000c
    b4a8:	0c 00 
    b4aa:	aa 43 0e 00 	mov	#2,	14(r10)	;r3 As==10, 0x000e

0000b4ae <.Loc.141.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b4ae:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b4b2:	f8 40 f0 ff 	mov.b	#-16,	28(r8)	;#0xfff0, 0x001c
    b4b6:	1c 00 

0000b4b8 <.Loc.142.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b4b8:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b4bc:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b4c0:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b4c4:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b4c8 <.Loc.143.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b4c8:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b4cc:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b4d0:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b4d4:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b4d8:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b4dc <.Loc.144.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b4dc:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b4e0:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b4e4:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b4e8:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b4ec:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f
    b4f0:	80 00 2a b4 	mova	#46122,	r0	;0x0b42a

0000b4f4 <elyRFChangeTxDevS>:

void __attribute__((weak)) elyRFChangeTxDevS(SX1278Config * cfg) {
    b4f4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b4f6 <.LCFI12>:
    b4f6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b4f8 <.LCFI13>:
    b4f8:	ca 0c       	mova	r12,	r10	;

0000b4fa <.Loc.160.2>:
  chSysLock();
    b4fa:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b4fe <.LVL72>:
    b4fe:	b0 13 54 45 	calla	#17748		;0x04554

0000b502 <.LVL73>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    b502:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b506:	5d 4e 09 00 	mov.b	9(r14),	r13	;
    b50a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b50e:	5c 4e 08 00 	mov.b	8(r14),	r12	;
    b512:	0d dc       	bis	r12,	r13	;
    b514:	5c 4e 0b 00 	mov.b	11(r14),r12	;0x0000b
    b518:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b51c:	5e 4e 0a 00 	mov.b	10(r14),r14	;0x0000a
    b520:	0c de       	bis	r14,	r12	;

0000b522 <.Loc.165.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  if (cfg->fdev > TX_DEV_MAX) {
    b522:	7e 40 03 00 	mov.b	#3,	r14	;
    b526:	0e 9c       	cmp	r12,	r14	;
    b528:	47 28       	jnc	$+144    	;abs 0xb5b8
    b52a:	0c 9e       	cmp	r14,	r12	;
    b52c:	04 20       	jnz	$+10     	;abs 0xb536
    b52e:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    b532:	0e 9d       	cmp	r13,	r14	;
    b534:	41 28       	jnc	$+132    	;abs 0xb5b8

0000b536 <.L51>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    b536:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    b53a:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000b53e <.L48>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < TX_DEV_MIN) {
    b53e:	8a 93 12 00 	cmp	#0,	18(r10)	;r3 As==00, 0x0012
    b542:	2b 20       	jnz	$+88     	;abs 0xb59a
    b544:	3c 40 57 02 	mov	#599,	r12	;#0x0257
    b548:	1c 9a 10 00 	cmp	16(r10),r12	;0x00010
    b54c:	26 28       	jnc	$+78     	;abs 0xb59a

0000b54e <.Loc.173.2>:
    cfg->fdev = TX_DEV_MIN;
    b54e:	ba 40 58 02 	mov	#600,	16(r10)	;#0x0258, 0x0010
    b552:	10 00 
    b554:	8a 43 12 00 	mov	#0,	18(r10)	;r3 As==00, 0x0012

0000b558 <.Loc.174.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    b558:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b55c:	f8 40 58 00 	mov.b	#88,	8(r8)	;#0x0058
    b560:	08 00 

0000b562 <.Loc.175.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b562:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b566:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b56a:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b56e:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000b572 <.Loc.176.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b572:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b576:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b57a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b57e:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b582:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000b586 <.Loc.177.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    b586:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b58a:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b58e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b592:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b596:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b

0000b59a <.L49>:
  }
  chSysUnlock();
    b59a:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b59e <.LVL77>:
    b59e:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b5a2 <.LVL78>:
  
  /* This is fast */
  sx1278SetDeviation(&SX1278D1, cfg->fdev);
    b5a2:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    b5a6:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    b5aa:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b5ae:	b0 13 a2 68 	calla	#26786		;0x068a2

0000b5b2 <.LVL79>:
}
    b5b2:	08 16       	popm.a	#1,	r8	;20-bit words
    b5b4:	0a 16       	popm.a	#1,	r10	;20-bit words
    b5b6:	10 01       	reta			;

0000b5b8 <.L46>:
    cfg->fdev = TX_DEV_MAX;
    b5b8:	ba 40 40 0d 	mov	#3392,	16(r10)	;#0x0d40, 0x0010
    b5bc:	10 00 
    b5be:	ba 40 03 00 	mov	#3,	18(r10)	; 0x0012
    b5c2:	12 00 

0000b5c4 <.Loc.167.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    b5c4:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b5c8:	f8 40 40 00 	mov.b	#64,	8(r8)	;#0x0040
    b5cc:	08 00 

0000b5ce <.Loc.168.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b5ce:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b5d2:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b5d6:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b5da:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000b5de <.Loc.169.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b5de:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b5e2:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b5e6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b5ea:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b5ee:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000b5f2 <.Loc.170.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    b5f2:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b5f6:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b5fa:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b5fe:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b602:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b
    b606:	80 00 3e b5 	mova	#46398,	r0	;0x0b53e

0000b60a <elyRFChangeRxDevS>:

void __attribute__((weak)) elyRFChangeRxDevS(SX1212Config * cfg) {
    b60a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b60c <.LCFI14>:
    b60c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b60e <.LCFI15>:
    b60e:	ca 0c       	mova	r12,	r10	;

0000b610 <.Loc.186.2>:
  chSysLock();
    b610:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b614 <.LVL84>:
    b614:	b0 13 54 45 	calla	#17748		;0x04554

0000b618 <.LVL85>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    b618:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b61c:	5d 4e 0d 00 	mov.b	13(r14),r13	;0x0000d
    b620:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b624:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    b628:	0d dc       	bis	r12,	r13	;
    b62a:	5c 4e 0f 00 	mov.b	15(r14),r12	;0x0000f
    b62e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b632:	5e 4e 0e 00 	mov.b	14(r14),r14	;0x0000e
    b636:	0c de       	bis	r14,	r12	;

0000b638 <.Loc.191.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  if (cfg->fdev > RX_DEV_MAX) {
    b638:	7e 40 03 00 	mov.b	#3,	r14	;
    b63c:	0e 9c       	cmp	r12,	r14	;
    b63e:	47 28       	jnc	$+144    	;abs 0xb6ce
    b640:	0c 9e       	cmp	r14,	r12	;
    b642:	04 20       	jnz	$+10     	;abs 0xb64c
    b644:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    b648:	0e 9d       	cmp	r13,	r14	;
    b64a:	41 28       	jnc	$+132    	;abs 0xb6ce

0000b64c <.L59>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    b64c:	8a 4d 14 00 	mov	r13,	20(r10)	; 0x0014
    b650:	8a 4c 16 00 	mov	r12,	22(r10)	; 0x0016

0000b654 <.L56>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < RX_DEV_MIN) {
    b654:	8a 93 16 00 	cmp	#0,	22(r10)	;r3 As==00, 0x0016
    b658:	2b 20       	jnz	$+88     	;abs 0xb6b0
    b65a:	3c 40 e7 80 	mov	#-32537,r12	;#0x80e7
    b65e:	1c 9a 14 00 	cmp	20(r10),r12	;0x00014
    b662:	26 28       	jnc	$+78     	;abs 0xb6b0

0000b664 <.Loc.199.2>:
    cfg->fdev = RX_DEV_MIN;
    b664:	ba 40 e8 80 	mov	#-32536,20(r10)	;#0x80e8, 0x0014
    b668:	14 00 
    b66a:	8a 43 16 00 	mov	#0,	22(r10)	;r3 As==00, 0x0016

0000b66e <.Loc.200.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    b66e:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b672:	f8 40 e8 ff 	mov.b	#-24,	12(r8)	;#0xffe8, 0x000c
    b676:	0c 00 

0000b678 <.Loc.201.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b678:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b67c:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b680:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b684:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000b688 <.Loc.202.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b688:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b68c:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b690:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b694:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b698:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000b69c <.Loc.203.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    b69c:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b6a0:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b6a4:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b6a8:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b6ac:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f

0000b6b0 <.L57>:
  }
  chSysUnlock();
    b6b0:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b6b4 <.LVL89>:
    b6b4:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b6b8 <.LVL90>:
  
  /* This is super fast */
  sx1212SetDeviation(&SX1212D1, cfg->fdev);
    b6b8:	1d 4a 14 00 	mov	20(r10),r13	;0x00014
    b6bc:	1e 4a 16 00 	mov	22(r10),r14	;0x00016
    b6c0:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b6c4:	b0 13 da 72 	calla	#29402		;0x072da

0000b6c8 <.LVL91>:
}
    b6c8:	08 16       	popm.a	#1,	r8	;20-bit words
    b6ca:	0a 16       	popm.a	#1,	r10	;20-bit words
    b6cc:	10 01       	reta			;

0000b6ce <.L54>:
    cfg->fdev = RX_DEV_MAX;
    b6ce:	ba 40 40 0d 	mov	#3392,	20(r10)	;#0x0d40, 0x0014
    b6d2:	14 00 
    b6d4:	ba 40 03 00 	mov	#3,	22(r10)	; 0x0016
    b6d8:	16 00 

0000b6da <.Loc.193.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    b6da:	28 01 46 07 	mova	&67398,	r8	;0x10746
    b6de:	f8 40 40 00 	mov.b	#64,	12(r8)	;#0x0040, 0x000c
    b6e2:	0c 00 

0000b6e4 <.Loc.194.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b6e4:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b6e8:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b6ec:	b0 13 36 ce 	calla	#52790		;0x0ce36
    b6f0:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000b6f4 <.Loc.195.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b6f4:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b6f8:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b6fc:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b700:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b704:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000b708 <.Loc.196.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    b708:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b70c:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b710:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b714:	b0 13 70 ce 	calla	#52848		;0x0ce70
    b718:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f
    b71c:	80 00 54 b6 	mova	#46676,	r0	;0x0b654

0000b720 <elyRFChangeRxSyncS>:
  
  /* This is reasonably fast */
  sx1278SetSync(&SX1278D1, cfg->sync_word);
}

void __attribute__((weak)) elyRFChangeRxSyncS(SX1212Config * cfg) {
    b720:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b722 <.LCFI17>:
    b722:	ca 0c       	mova	r12,	r10	;

0000b724 <.Loc.224.2>:
  chSysLock();
    b724:	b0 13 e0 af 	calla	#45024		;0x0afe0

0000b728 <.LVL102>:
    b728:	b0 13 54 45 	calla	#17748		;0x04554

0000b72c <.LVL103>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    b72c:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b730:	5d 4e 15 00 	mov.b	21(r14),r13	;0x00015
    b734:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b738:	5c 4e 17 00 	mov.b	23(r14),r12	;0x00017
    b73c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b740:	5f 4e 16 00 	mov.b	22(r14),r15	;0x00016
    b744:	0c df       	bis	r15,	r12	;

0000b746 <.Loc.225.2>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    b746:	5e 4e 14 00 	mov.b	20(r14),r14	;0x00014
    b74a:	0e dd       	bis	r13,	r14	;
    b74c:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c
    b750:	8a 4c 1e 00 	mov	r12,	30(r10)	; 0x001e

0000b754 <.Loc.229.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    b754:	b0 13 7c 45 	calla	#17788		;0x0457c

0000b758 <.LVL104>:
    b758:	b0 13 e8 af 	calla	#45032		;0x0afe8

0000b75c <.LVL105>:
  
  /* This is reasonably fast */
  sx1212SetSync(&SX1212D1, cfg->sync_word);
    b75c:	1d 4a 1c 00 	mov	28(r10),r13	;0x0001c
    b760:	1e 4a 1e 00 	mov	30(r10),r14	;0x0001e
    b764:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b768:	b0 13 7c 76 	calla	#30332		;0x0767c

0000b76c <.LVL106>:
}
    b76c:	0a 16       	popm.a	#1,	r10	;20-bit words
    b76e:	10 01       	reta			;

0000b770 <elyRFChangeTxPowerS>:

void __attribute__((weak)) elyRFChangeTxPowerS(SX1278Config * cfg) {
  cfg->pow = bank0p[RegOutputPower];
    b770:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b774:	5d 4e 21 00 	mov.b	33(r14),r13	;0x00021
    b778:	cc 4d 15 00 	mov.b	r13,	21(r12)	; 0x0015

0000b77c <.Loc.239.2>:
  
  /* This is reasonably fast because I made it kind of sloppy */
  sx1278SetPower(&SX1278D1, cfg->pow);
    b77c:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e

0000b780 <.LVL108>:
    b780:	b0 13 e2 69 	calla	#27106		;0x069e2

0000b784 <.LVL109>:
}
    b784:	10 01       	reta			;

0000b786 <elyRFChangeRxFilterParamsS>:
  sx1278SetFilterParams(&SX1278D1, tx_cfg->filter);
}

void __attribute__((weak)) elyRFChangeRxFilterParamsS(SX1212Config * rx_cfg) {
  
  rx_cfg->rx_bw = (bank0p[RegFilterParams] & 0x0F);
    b786:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    b78a:	5d 4e 20 00 	mov.b	32(r14),r13	;0x00020
    b78e:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    b792:	4e 4d       	mov.b	r13,	r14	;
    b794:	0f 43       	clr	r15		;
    b796:	8c 4e 18 00 	mov	r14,	24(r12)	; 0x0018
    b79a:	8c 4f 1a 00 	mov	r15,	26(r12)	; 0x001a

0000b79e <.Loc.253.2>:
  /* This is fast and I made it kind of sloppy anyway */
  sx1212SetRxBw(&SX1212D1, rx_cfg->rx_bw);
    b79e:	8c 01 30 15 	mova	#70960,	r12	;0x11530

0000b7a2 <.LVL114>:
    b7a2:	b0 13 b8 76 	calla	#30392		;0x076b8

0000b7a6 <.LVL115>:
}
    b7a6:	10 01       	reta			;

0000b7a8 <RFThd>:
static bool bits_set(eventmask_t events, eventmask_t bits) {
  return ((events & bits) == bits);
}

THD_WORKING_AREA(waRFThd, 256);
THD_FUNCTION(RFThd, arg) {
    b7a8:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000b7aa <.LCFI18>:
    b7aa:	04 14       	pushm.a	#1,	r4	;20-bit words

0000b7ac <.LCFI19>:
    b7ac:	b1 00 08 00 	suba	#8,	r1	;

0000b7b0 <.LCFI20>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  rf_thd = chThdGetSelfX();
    b7b0:	81 18 d2 42 	movx.a	&0x11320,&0x1190c;
    b7b4:	20 13 0c 19 

0000b7b8 <.Loc.323.2>:
  
  /* Build the TX config out of the registers */
  chSysLock();
    b7b8:	89 00 e0 af 	mova	#45024,	r9	;0x0afe0
    b7bc:	49 13       	calla	r9		;

0000b7be <.LVL117>:
    b7be:	87 00 54 45 	mova	#17748,	r7	;0x04554
    b7c2:	47 13       	calla	r7		;

0000b7c4 <.LVL118>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b7c4:	26 01 4a 07 	mova	&67402,	r6	;0x1074a
    b7c8:	84 01 2c 0a 	mova	#68140,	r4	;0x10a2c

0000b7cc <.Loc.326.2>:
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    b7cc:	5d 46 19 00 	mov.b	25(r6),	r13	;0x00019
    b7d0:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b7d4:	5c 46 1b 00 	mov.b	27(r6),	r12	;0x0001b
    b7d8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b7dc:	5e 46 1a 00 	mov.b	26(r6),	r14	;0x0001a
    b7e0:	0c de       	bis	r14,	r12	;

0000b7e2 <.Loc.324.2>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b7e2:	5e 46 18 00 	mov.b	24(r6),	r14	;0x00018
    b7e6:	0e dd       	bis	r13,	r14	;
    b7e8:	84 4e 08 00 	mov	r14,	8(r4)	;
    b7ec:	84 4c 0a 00 	mov	r12,	10(r4)	; 0x000a

0000b7f0 <.Loc.330.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    b7f0:	5d 46 01 00 	mov.b	1(r6),	r13	;
    b7f4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b7f8:	5c 46 03 00 	mov.b	3(r6),	r12	;
    b7fc:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b800:	5e 46 02 00 	mov.b	2(r6),	r14	;
    b804:	0c de       	bis	r14,	r12	;

0000b806 <.Loc.328.2>:
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    b806:	6e 46       	mov.b	@r6,	r14	;
    b808:	0e dd       	bis	r13,	r14	;
    b80a:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    b80e:	84 4c 0e 00 	mov	r12,	14(r4)	; 0x000e

0000b812 <.Loc.334.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    b812:	5d 46 09 00 	mov.b	9(r6),	r13	;
    b816:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b81a:	5c 46 0b 00 	mov.b	11(r6),	r12	;0x0000b
    b81e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b822:	5e 46 0a 00 	mov.b	10(r6),	r14	;0x0000a
    b826:	0c de       	bis	r14,	r12	;

0000b828 <.Loc.332.2>:
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    b828:	5e 46 08 00 	mov.b	8(r6),	r14	;
    b82c:	0e dd       	bis	r13,	r14	;
    b82e:	84 4e 10 00 	mov	r14,	16(r4)	; 0x0010
    b832:	84 4c 12 00 	mov	r12,	18(r4)	; 0x0012

0000b836 <.Loc.336.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  tx_cfg.filter = ((bank0p[RegFilterParams] >> 4) & 0x03);
    b836:	5c 46 20 00 	mov.b	32(r6),	r12	;0x00020
    b83a:	5c 0f       	rrum	#4,	r12	;
    b83c:	7c f0 03 00 	and.b	#3,	r12	;
    b840:	c4 4c 14 00 	mov.b	r12,	20(r4)	; 0x0014

0000b844 <.Loc.337.2>:
  tx_cfg.pow = bank0p[RegOutputPower];
    b844:	d4 46 21 00 	mov.b	33(r6),	21(r4)	;0x00021, 0x0015
    b848:	15 00 

0000b84a <.Loc.340.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
                ((uint32_t)(bank0p[RegTXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    b84a:	5d 46 11 00 	mov.b	17(r6),	r13	;0x00011
    b84e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b852:	5c 46 13 00 	mov.b	19(r6),	r12	;0x00013
    b856:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b85a:	5e 46 12 00 	mov.b	18(r6),	r14	;0x00012
    b85e:	0c de       	bis	r14,	r12	;

0000b860 <.Loc.338.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
    b860:	5e 46 10 00 	mov.b	16(r6),	r14	;0x00010
    b864:	0e dd       	bis	r13,	r14	;
    b866:	84 4e 18 00 	mov	r14,	24(r4)	; 0x0018
    b86a:	84 4c 1a 00 	mov	r12,	26(r4)	; 0x001a

0000b86e <.Loc.342.2>:
                ((uint32_t)(bank0p[RegTXSyncMsb]) << 24) );
  chSysUnlock();
    b86e:	88 00 7c 45 	mova	#17788,	r8	;0x0457c
    b872:	48 13       	calla	r8		;

0000b874 <.LVL119>:
    b874:	8a 00 e8 af 	mova	#45032,	r10	;0x0afe8
    b878:	4a 13       	calla	r10		;

0000b87a <.LVL120>:
  
  /* Start the transmitter driver and initiate the transmit loop */
  sx1278ObjectInit(&SX1278D1);
    b87a:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b87e:	b0 13 5a 6a 	calla	#27226		;0x06a5a

0000b882 <.LVL121>:
  sx1278Start(&SX1278D1, &tx_cfg);
    b882:	cd 04       	mova	r4,	r13	;
    b884:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b888:	b0 13 be 6a 	calla	#27326		;0x06abe

0000b88c <.LVL122>:
  
  elyRFDLLTxInit(&SX1278D1);
    b88c:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b890:	b0 13 0e cc 	calla	#52238		;0x0cc0e

0000b894 <.LVL123>:
  
  /* Build the RX config out of the registers */
  chSysLock();
    b894:	49 13       	calla	r9		;

0000b896 <.LVL124>:
    b896:	47 13       	calla	r7		;

0000b898 <.LVL125>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    b898:	84 01 00 0a 	mova	#68096,	r4	;0x10a00

0000b89c <.Loc.354.2>:
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    b89c:	5d 46 1d 00 	mov.b	29(r6),	r13	;0x0001d
    b8a0:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b8a4:	5c 46 1f 00 	mov.b	31(r6),	r12	;0x0001f
    b8a8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b8ac:	5e 46 1e 00 	mov.b	30(r6),	r14	;0x0001e
    b8b0:	0c de       	bis	r14,	r12	;

0000b8b2 <.Loc.352.2>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    b8b2:	5e 46 1c 00 	mov.b	28(r6),	r14	;0x0001c
    b8b6:	0e dd       	bis	r13,	r14	;
    b8b8:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    b8bc:	84 4c 0e 00 	mov	r12,	14(r4)	; 0x000e

0000b8c0 <.Loc.358.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    b8c0:	5d 46 05 00 	mov.b	5(r6),	r13	;
    b8c4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b8c8:	5c 46 07 00 	mov.b	7(r6),	r12	;
    b8cc:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b8d0:	5e 46 06 00 	mov.b	6(r6),	r14	;
    b8d4:	0c de       	bis	r14,	r12	;

0000b8d6 <.Loc.356.2>:
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    b8d6:	5e 46 04 00 	mov.b	4(r6),	r14	;
    b8da:	0e dd       	bis	r13,	r14	;
    b8dc:	84 4e 10 00 	mov	r14,	16(r4)	; 0x0010
    b8e0:	84 4c 12 00 	mov	r12,	18(r4)	; 0x0012

0000b8e4 <.Loc.362.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    b8e4:	5d 46 0d 00 	mov.b	13(r6),	r13	;0x0000d
    b8e8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b8ec:	5c 46 0f 00 	mov.b	15(r6),	r12	;0x0000f
    b8f0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b8f4:	5e 46 0e 00 	mov.b	14(r6),	r14	;0x0000e
    b8f8:	0c de       	bis	r14,	r12	;

0000b8fa <.Loc.360.2>:
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    b8fa:	5e 46 0c 00 	mov.b	12(r6),	r14	;0x0000c
    b8fe:	0e dd       	bis	r13,	r14	;
    b900:	84 4e 14 00 	mov	r14,	20(r4)	; 0x0014
    b904:	84 4c 16 00 	mov	r12,	22(r4)	; 0x0016

0000b908 <.Loc.364.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  rx_cfg.rx_bw = (bank0p[RegFilterParams] & 0x0F);
    b908:	5c 46 20 00 	mov.b	32(r6),	r12	;0x00020
    b90c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    b910:	4d 4c       	mov.b	r12,	r13	;
    b912:	0e 43       	clr	r14		;
    b914:	84 4d 18 00 	mov	r13,	24(r4)	; 0x0018
    b918:	84 4e 1a 00 	mov	r14,	26(r4)	; 0x001a

0000b91c <.Loc.367.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    b91c:	5d 46 15 00 	mov.b	21(r6),	r13	;0x00015
    b920:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b924:	5c 46 17 00 	mov.b	23(r6),	r12	;0x00017
    b928:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b92c:	5e 46 16 00 	mov.b	22(r6),	r14	;0x00016
    b930:	0c de       	bis	r14,	r12	;

0000b932 <.Loc.365.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    b932:	56 46 14 00 	mov.b	20(r6),	r6	;0x00014
    b936:	06 dd       	bis	r13,	r6	;
    b938:	84 46 1c 00 	mov	r6,	28(r4)	; 0x001c
    b93c:	84 4c 1e 00 	mov	r12,	30(r4)	; 0x001e

0000b940 <.Loc.369.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    b940:	48 13       	calla	r8		;

0000b942 <.LVL126>:
    b942:	4a 13       	calla	r10		;

0000b944 <.LVL127>:


  /* Start the receiver driver and initiate the receive loop */
  sx1212Start(&SX1212D1, &rx_cfg);
    b944:	cd 04       	mova	r4,	r13	;
    b946:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b94a:	b0 13 f2 76 	calla	#30450		;0x076f2

0000b94e <.LVL128>:
  
  elyRFDLLRxInit(&SX1212D1);
    b94e:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b952:	b0 13 96 c9 	calla	#51606		;0x0c996

0000b956 <.LVL129>:
  
  events = (RFSpiAvailable | RFTxIdle);
    b956:	40 18 b2 40 	movx.w	#8192,	&0xfd3ca;0x02000
    b95a:	00 20 ca d3 
    b95e:	40 18 92 43 	movx.w	#1,	&0xfd3cc;r3 As==01
    b962:	cc d3 

0000b964 <.Loc.380.2>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    b964:	49 13       	calla	r9		;

0000b966 <.LVL130>:
    b966:	47 13       	calla	r7		;

0000b968 <.LBB22>:
  chDbgCheckClassI();
    b968:	b0 13 54 46 	calla	#18004		;0x04654

0000b96c <.LVL132>:
  return chSemGetCounterI(&mbp->fullsem);
    b96c:	c0 18 1c 42 	movx.w	&0x10a92,r12	;
    b970:	92 0a 

0000b972 <.LBE22>:
  if (chMBGetUsedCountI(&rf_mbox) > 0) {
    b972:	4d 43       	clr.b	r13		;
    b974:	0d 9c       	cmp	r12,	r13	;
    b976:	07 34       	jge	$+16     	;abs 0xb986

0000b978 <.Loc.382.2>:
    events |= RFPktAvailable;
    b978:	40 18 b2 d0 	bisx.w	#1024,	&0xfd3ca;0x00400
    b97c:	00 04 ca d3 
    b980:	40 18 82 dd 	bisx.w	r13,	&0xfd3cc;
    b984:	cc d3 

0000b986 <.L67>:
  }
  chSysUnlock();
    b986:	48 13       	calla	r8		;

0000b988 <.LVL134>:
    b988:	4a 13       	calla	r10		;

0000b98a <.LVL135>:
      /* 
       * Read FifoThresh bytes from the Fifo using spiStartReceive
       *  In the callback - signal SpiAvailable, and post buffer and signal RxIdle if applicable
       * Clear RxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleRxFifo(&SX1212D1);
    b98a:	84 00 c4 c9 	mova	#51652,	r4	;0x0c9c4

0000b98e <.LBB24>:
  mask ^= mask & (mask - (eventmask_t)1);
    b98e:	46 43       	clr.b	r6		;
    b990:	47 43       	clr.b	r7		;

0000b992 <.L92>:
  return ((events & bits) == bits);
    b992:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    b996:	ca d3 
    b998:	3c f0 00 30 	and	#12288,	r12	;#0x3000

0000b99c <.LBE29>:
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    b99c:	3c 90 00 30 	cmp	#12288,	r12	;#0x3000
    b9a0:	0a 20       	jnz	$+22     	;abs 0xb9b6

0000b9a2 <.Loc.393.2>:
      elyRFDLLHandleRxFifo(&SX1212D1);
    b9a2:	8c 01 30 15 	mova	#70960,	r12	;0x11530
    b9a6:	44 13       	calla	r4		;

0000b9a8 <.LVL136>:
      events &= ~(RFSpiAvailable | RFRxFifoThresh);
    b9a8:	c0 1f b2 f0 	andx.w	#-12289,&0xfd3ca;0xfcfff
    b9ac:	ff cf ca d3 
    b9b0:	40 18 82 c3 	bicx.w	#0,	&0xfd3cc;r3 As==00
    b9b4:	cc d3 

0000b9b6 <.L68>:
  return ((events & bits) == bits);
    b9b6:	40 18 1d 42 	movx.w	&0x0d3ca,r13	;
    b9ba:	ca d3 
    b9bc:	3d f0 00 28 	and	#10240,	r13	;#0x2800
    b9c0:	40 18 1c 42 	movx.w	&0x0d3cc,r12	;
    b9c4:	cc d3 
    b9c6:	5c f3       	and.b	#1,	r12	;r3 As==01

0000b9c8 <.LBE31>:
    }
    if (bits_set(events, (RFSpiAvailable | RFTxFrameReady | RFTxIdle))) {
    b9c8:	3d 90 00 28 	cmp	#10240,	r13	;#0x2800
    b9cc:	0d 20       	jnz	$+28     	;abs 0xb9e8
    b9ce:	1c 93       	cmp	#1,	r12	;r3 As==01
    b9d0:	0b 20       	jnz	$+24     	;abs 0xb9e8

0000b9d2 <.Loc.397.2>:
      elyRFDLLInitiateTransmit(&SX1278D1);
    b9d2:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b9d6:	b0 13 5c cb 	calla	#52060		;0x0cb5c

0000b9da <.LVL137>:
      events &= ~(RFSpiAvailable | RFTxFrameReady | RFTxIdle);
    b9da:	c0 1f b2 f0 	andx.w	#-10241,&0xfd3ca;0xfd7ff
    b9de:	ff d7 ca d3 
    b9e2:	40 18 92 c3 	bicx.w	#1,	&0xfd3cc;r3 As==01
    b9e6:	cc d3 

0000b9e8 <.L69>:
  return ((events & bits) == bits);
    b9e8:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    b9ec:	ca d3 
    b9ee:	3c f0 00 a0 	and	#-24576,r12	;#0xa000

0000b9f2 <.LBE33>:
    }
    if (bits_set(events, (RFTxFifoLevel | RFSpiAvailable))) {
    b9f2:	3c 90 00 a0 	cmp	#-24576,r12	;#0xa000
    b9f6:	0b 20       	jnz	$+24     	;abs 0xba0e

0000b9f8 <.Loc.407.2>:
       * Write FifoSize or BytesRemaining bytes to the Fifo using spiStartSend
       *  In the callback - signal SpiAvailable, and TxIdle if applicable
       *  TxFifoThresh signaled by PAL callback
       * Clear TxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleTxFifo(&SX1278D1);
    b9f8:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    b9fc:	b0 13 8e cb 	calla	#52110		;0x0cb8e

0000ba00 <.LVL138>:
      events &= ~(RFSpiAvailable | RFTxFifoLevel);
    ba00:	40 18 b2 f0 	andx.w	#24575,	&0xfd3ca;0x05fff
    ba04:	ff 5f ca d3 
    ba08:	40 18 82 c3 	bicx.w	#0,	&0xfd3cc;r3 As==00
    ba0c:	cc d3 

0000ba0e <.L70>:
    }
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    ba0e:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    ba12:	ca d3 

0000ba14 <.LBB35>:
  return ((events & bits) == bits);
    ba14:	40 18 1d 42 	movx.w	&0x0d3cc,r13	;
    ba18:	cc d3 
    ba1a:	5d f3       	and.b	#1,	r13	;r3 As==01

0000ba1c <.LBE35>:
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    ba1c:	40 18 3c b0 	bitx.w	#1024,	r12	;0x00400
    ba20:	00 04 
    ba22:	11 24       	jz	$+36     	;abs 0xba46
    ba24:	1d 93       	cmp	#1,	r13	;r3 As==01
    ba26:	0f 20       	jnz	$+32     	;abs 0xba46

0000ba28 <.Loc.410.2>:
    ba28:	3c b0 00 08 	bit	#2048,	r12	;#0x0800
    ba2c:	0c 20       	jnz	$+26     	;abs 0xba46

0000ba2e <.Loc.416.2>:
      /*
       * Turn the NL packet into a DLL frame. Do it outside a lock zone.
       * Once the frame is ready, signal TxFrameReady to start transmission
       * Clear RFPktAvailable from Events variable
       */
      elyRFDLLBuildFrame();
    ba2e:	b0 13 62 c8 	calla	#51298		;0x0c862

0000ba32 <.LVL139>:
      events &= ~RFPktAvailable;
    ba32:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    ba36:	ca d3 
    ba38:	3c f0 ff fb 	and	#-1025,	r12	;#0xfbff

0000ba3c <.Loc.418.2>:
      events |= (RFTxFrameReady);
    ba3c:	3c d0 00 08 	bis	#2048,	r12	;#0x0800
    ba40:	40 18 82 4c 	movx.w	r12,	&0xfd3ca;
    ba44:	ca d3 

0000ba46 <.L71>:
  return ((events & bits) == bits);
    ba46:	40 18 1d 42 	movx.w	&0x0d3ca,r13	;
    ba4a:	ca d3 
    ba4c:	3d f0 55 21 	and	#8533,	r13	;#0x2155
    ba50:	40 18 1c 42 	movx.w	&0x0d3cc,r12	;
    ba54:	cc d3 
    ba56:	5c f3       	and.b	#1,	r12	;r3 As==01

0000ba58 <.LBE37>:
    }
    if (bits_set(events, (RFTxCfgMask | RFTxIdle | RFSpiAvailable))) {
    ba58:	3d 90 55 21 	cmp	#8533,	r13	;#0x2155
    ba5c:	11 20       	jnz	$+36     	;abs 0xba80
    ba5e:	1c 93       	cmp	#1,	r12	;r3 As==01
    ba60:	0f 20       	jnz	$+32     	;abs 0xba80

0000ba62 <.LBB39>:
      while (events & RFTxCfgMask) {
        eventmask_t evt = get_next_event(events & RFTxCfgMask);
        
        switch (evt) {
    ba62:	8a 00 8e ce 	mova	#52878,	r10	;0x0ce8e

0000ba66 <.Loc.443.2>:
            break;
          case RFFilterParamsUpdated:
            elyRFChangeTxFilterParamsS(&tx_cfg);
            break;
          default:
            chDbgAssert(false, "shouldn't happen");
    ba66:	88 00 dc 47 	mova	#18396,	r8	;0x047dc

0000ba6a <.L72>:
      while (events & RFTxCfgMask) {
    ba6a:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    ba6e:	ca d3 
    ba70:	3c f0 55 01 	and	#341,	r12	;#0x0155
    ba74:	81 4c 04 00 	mov	r12,	4(r1)	;
    ba78:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    ba7c:	0c 93       	cmp	#0,	r12	;r3 As==00
    ba7e:	24 20       	jnz	$+74     	;abs 0xbac8

0000ba80 <.L91>:
  return ((events & bits) == bits);
    ba80:	40 18 1c 42 	movx.w	&0x0d3ca,r12	;
    ba84:	ca d3 
    ba86:	3c f0 aa 60 	and	#24746,	r12	;#0x60aa

0000ba8a <.LBE40>:
        
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    if (bits_set(events, (RFRxCfgMask | RFRxIdle | RFSpiAvailable))) {
    ba8a:	3c 90 aa 60 	cmp	#24746,	r12	;#0x60aa
    ba8e:	0f 20       	jnz	$+32     	;abs 0xbaae

0000ba90 <.LBB42>:
      while (events & RFRxCfgMask) {
        eventmask_t evt = get_next_event(events & RFRxCfgMask);
        
        switch (evt) {
    ba90:	8a 00 8e ce 	mova	#52878,	r10	;0x0ce8e

0000ba94 <.Loc.470.2>:
            elyRFChangeRxSyncS(&rx_cfg);
          case RFFilterParamsUpdated:
            elyRFChangeRxFilterParamsS(&rx_cfg);
            break;
          default:
            chDbgAssert(false, "shouldn't happen");
    ba94:	88 00 dc 47 	mova	#18396,	r8	;0x047dc

0000ba98 <.L74>:
      while (events & RFRxCfgMask) {
    ba98:	40 18 1e 42 	movx.w	&0x0d3ca,r14	;
    ba9c:	ca d3 
    ba9e:	7e f0 aa 00 	and.b	#170,	r14	;#0x00aa
    baa2:	81 4e 00 00 	mov	r14,	0(r1)	;
    baa6:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    baaa:	0e 93       	cmp	#0,	r14	;r3 As==00
    baac:	54 20       	jnz	$+170    	;abs 0xbb56

0000baae <.L76>:
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    
    events |= chEvtWaitAnyTimeout(AllRfEvents, TIME_INFINITE);
    baae:	4e 43       	clr.b	r14		;
    bab0:	3c 43       	mov	#-1,	r12	;r3 As==11
    bab2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bab4:	b0 13 da 4b 	calla	#19418		;0x04bda

0000bab8 <.LVL140>:
    bab8:	40 18 82 dc 	bisx.w	r12,	&0xfd3ca;
    babc:	ca d3 
    babe:	40 18 82 dd 	bisx.w	r13,	&0xfd3cc;
    bac2:	cc d3 

0000bac4 <.Loc.387.2>:
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    bac4:	80 00 92 b9 	mova	#47506,	r0	;0x0b992

0000bac8 <.L90>:
  mask ^= mask & (mask - (eventmask_t)1);
    bac8:	0c 46       	mov	r6,	r12	;
    baca:	0d 47       	mov	r7,	r13	;
    bacc:	40 18 1c 81 	subx.w	4(r1),	r12	;
    bad0:	04 00 
    bad2:	40 18 1d 71 	subcx.w	6(r1),	r13	;
    bad6:	06 00 
    bad8:	09 4c       	mov	r12,	r9	;
    bada:	19 f1 04 00 	and	4(r1),	r9	;

0000bade <.LBE28>:
        switch (evt) {
    bade:	39 90 10 00 	cmp	#16,	r9	;#0x0010
    bae2:	09 20       	jnz	$+20     	;abs 0xbaf6

0000bae4 <.Loc.432.2>:
            elyRFChangeTxDevS(&tx_cfg);
    bae4:	8c 01 2c 0a 	mova	#68140,	r12	;0x10a2c
    bae8:	b0 13 f4 b4 	calla	#46324		;0x0b4f4

0000baec <.L89>:
        events &= ~evt;
    baec:	40 18 82 c9 	bicx.w	r9,	&0xfd3ca;
    baf0:	ca d3 
    baf2:	80 00 6a ba 	mova	#47722,	r0	;0x0ba6a

0000baf6 <.L79>:
        switch (evt) {
    baf6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    bafa:	4f 43       	clr.b	r15		;
    bafc:	0c 49       	mov	r9,	r12	;
    bafe:	4d 43       	clr.b	r13		;
    bb00:	4a 13       	calla	r10		;
    bb02:	5e 43       	mov.b	#1,	r14	;r3 As==01
    bb04:	0e 9c       	cmp	r12,	r14	;
    bb06:	09 28       	jnc	$+20     	;abs 0xbb1a
    bb08:	09 9e       	cmp	r14,	r9	;
    bb0a:	13 24       	jz	$+40     	;abs 0xbb32
    bb0c:	29 92       	cmp	#4,	r9	;r2 As==10
    bb0e:	17 24       	jz	$+48     	;abs 0xbb3e

0000bb10 <.L77>:
            chDbgAssert(false, "shouldn't happen");
    bb10:	8c 01 c8 07 	mova	#67528,	r12	;0x107c8
    bb14:	48 13       	calla	r8		;

0000bb16 <.LVL145>:
    bb16:	80 00 ec ba 	mova	#47852,	r0	;0x0baec

0000bb1a <.L80>:
        switch (evt) {
    bb1a:	39 90 40 00 	cmp	#64,	r9	;#0x0040
    bb1e:	15 24       	jz	$+44     	;abs 0xbb4a
    bb20:	39 90 00 01 	cmp	#256,	r9	;#0x0100
    bb24:	f5 23       	jnz	$-20     	;abs 0xbb10

0000bb26 <.L87>:
            elyRFChangeTxPowerS(&tx_cfg);
    bb26:	8c 01 2c 0a 	mova	#68140,	r12	;0x10a2c
    bb2a:	b0 13 70 b7 	calla	#46960		;0x0b770

0000bb2e <.LVL146>:
            break;
    bb2e:	80 00 ec ba 	mova	#47852,	r0	;0x0baec

0000bb32 <.L105>:
            elyRFChangeTxFreqS(&tx_cfg);
    bb32:	8c 01 2c 0a 	mova	#68140,	r12	;0x10a2c
    bb36:	b0 13 8e b0 	calla	#45198		;0x0b08e

0000bb3a <.LVL147>:
            break;
    bb3a:	80 00 ec ba 	mova	#47852,	r0	;0x0baec

0000bb3e <.L106>:
            elyRFChangeTxBRS(&tx_cfg);
    bb3e:	8c 01 2c 0a 	mova	#68140,	r12	;0x10a2c
    bb42:	b0 13 d0 b2 	calla	#45776		;0x0b2d0

0000bb46 <.LVL148>:
            break;
    bb46:	80 00 ec ba 	mova	#47852,	r0	;0x0baec

0000bb4a <.L107>:
            elyRFChangeTxSyncS(&tx_cfg);
    bb4a:	8c 01 2c 0a 	mova	#68140,	r12	;0x10a2c
    bb4e:	b0 13 c4 c6 	calla	#50884		;0x0c6c4

0000bb52 <.LVL149>:
    bb52:	80 00 26 bb 	mova	#47910,	r0	;0x0bb26

0000bb56 <.L104>:
  mask ^= mask & (mask - (eventmask_t)1);
    bb56:	0c 46       	mov	r6,	r12	;
    bb58:	0d 47       	mov	r7,	r13	;
    bb5a:	40 18 2c 81 	subx.w	@r1,	r12	;
    bb5e:	40 18 1d 71 	subcx.w	2(r1),	r13	;
    bb62:	02 00 
    bb64:	09 4c       	mov	r12,	r9	;
    bb66:	29 f1       	and	@r1,	r9	;

0000bb68 <.LBE43>:
        switch (evt) {
    bb68:	39 92       	cmp	#8,	r9	;r2 As==11
    bb6a:	09 20       	jnz	$+20     	;abs 0xbb7e

0000bb6c <.Loc.459.2>:
            elyRFChangeRxBRS(&rx_cfg);
    bb6c:	8c 01 00 0a 	mova	#68096,	r12	;0x10a00
    bb70:	b0 13 e2 b3 	calla	#46050		;0x0b3e2

0000bb74 <.L103>:
        events &= ~evt;
    bb74:	40 18 82 c9 	bicx.w	r9,	&0xfd3ca;
    bb78:	ca d3 
    bb7a:	80 00 98 ba 	mova	#47768,	r0	;0x0ba98

0000bb7e <.L95>:
        switch (evt) {
    bb7e:	7e 42       	mov.b	#8,	r14	;r2 As==11
    bb80:	4f 43       	clr.b	r15		;
    bb82:	0c 49       	mov	r9,	r12	;
    bb84:	4d 43       	clr.b	r13		;
    bb86:	4a 13       	calla	r10		;
    bb88:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bb8a:	0d 9c       	cmp	r12,	r13	;
    bb8c:	07 28       	jnc	$+16     	;abs 0xbb9c
    bb8e:	29 93       	cmp	#2,	r9	;r3 As==10
    bb90:	15 24       	jz	$+44     	;abs 0xbbbc

0000bb92 <.L93>:
            chDbgAssert(false, "shouldn't happen");
    bb92:	8c 01 c8 07 	mova	#67528,	r12	;0x107c8
    bb96:	48 13       	calla	r8		;

0000bb98 <.LVL154>:
    bb98:	80 00 74 bb 	mova	#47988,	r0	;0x0bb74

0000bb9c <.L96>:
        switch (evt) {
    bb9c:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    bba0:	13 24       	jz	$+40     	;abs 0xbbc8
    bba2:	39 90 80 00 	cmp	#128,	r9	;#0x0080
    bba6:	f5 23       	jnz	$-20     	;abs 0xbb92

0000bba8 <.Loc.465.2>:
            elyRFChangeRxSyncS(&rx_cfg);
    bba8:	8c 01 00 0a 	mova	#68096,	r12	;0x10a00
    bbac:	b0 13 20 b7 	calla	#46880		;0x0b720

0000bbb0 <.LVL155>:
            elyRFChangeRxFilterParamsS(&rx_cfg);
    bbb0:	8c 01 00 0a 	mova	#68096,	r12	;0x10a00
    bbb4:	b0 13 86 b7 	calla	#46982		;0x0b786

0000bbb8 <.LVL156>:
            break;
    bbb8:	80 00 74 bb 	mova	#47988,	r0	;0x0bb74

0000bbbc <.L108>:
            elyRFChangeRxFreqS(&rx_cfg);
    bbbc:	8c 01 00 0a 	mova	#68096,	r12	;0x10a00
    bbc0:	b0 13 ae b1 	calla	#45486		;0x0b1ae

0000bbc4 <.LVL157>:
            break;
    bbc4:	80 00 74 bb 	mova	#47988,	r0	;0x0bb74

0000bbc8 <.L109>:
            elyRFChangeRxDevS(&rx_cfg);
    bbc8:	8c 01 00 0a 	mova	#68096,	r12	;0x10a00
    bbcc:	b0 13 0a b6 	calla	#46602		;0x0b60a

0000bbd0 <.LVL158>:
            break;
    bbd0:	80 00 74 bb 	mova	#47988,	r0	;0x0bb74

0000bbd4 <addr_cb>:
  elyQueueFreeBufferI(&fram_queue, (uint8_t *)(active_req));
  chBSemSignalI(&fram_sem);
  chSysUnlockFromISR();
}

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    bbd4:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000bbd6 <.LCFI0>:
    bbd6:	06 14       	pushm.a	#1,	r6	;20-bit words

0000bbd8 <.LCFI1>:
    bbd8:	04 14       	pushm.a	#1,	r4	;20-bit words

0000bbda <.LCFI2>:
    bbda:	b1 00 08 00 	suba	#8,	r1	;

0000bbde <.LCFI3>:
    bbde:	c8 0c       	mova	r12,	r8	;

0000bbe0 <.Loc.38.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    bbe0:	24 00 ee d3 	mova	&54254,	r4	;0x0d3ee

0000bbe4 <.Loc.40.1>:
  
  chSysLockFromISR();
    bbe4:	b0 13 a6 45 	calla	#17830		;0x045a6

0000bbe8 <.LVL2>:
  /* TODO put in an assert in here for the Rev A crossing page boundaries */
  if (req->read) {
    bbe8:	5d 44 04 00 	mov.b	4(r4),	r13	;
    bbec:	4c 4d       	mov.b	r13,	r12	;
    bbee:	5c f3       	and.b	#1,	r12	;r3 As==01
    bbf0:	36 04 08 00 	mova	8(r4),	r6	;
    bbf4:	5a 44 06 00 	mov.b	6(r4),	r10	;
    bbf8:	59 44 10 00 	mov.b	16(r4),	r9	;0x00010
    bbfc:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    bc00:	3e 24       	jz	$+126    	;abs 0xbc7e

0000bc02 <.Loc.43.1>:
    if (req->special) {
    bc02:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    bc04:	21 24       	jz	$+68     	;abs 0xbc48

0000bc06 <.Loc.45.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    bc06:	1c 44 04 00 	mov	4(r4),	r12	;
    bc0a:	b0 13 f6 cd 	calla	#52726		;0x0cdf6
    bc0e:	0d 4a       	mov	r10,	r13	;
    bc10:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    bc14:	0d dc       	bis	r12,	r13	;
    bc16:	81 4d 04 00 	mov	r13,	4(r1)	;
    bc1a:	5a 07       	rrum	#2,	r10	;
    bc1c:	5a f3       	and.b	#1,	r10	;r3 As==01
    bc1e:	81 4a 06 00 	mov	r10,	6(r1)	;

0000bc22 <.Loc.44.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    bc22:	00 18 f1 40 	movx.a	#48366,	0(r1)	;0x0bcee
    bc26:	ee bc 00 00 
    bc2a:	cf 06       	mova	r6,	r15	;
    bc2c:	3e 01 04 00 	mova	4(r1),	r14	;
    bc30:	4d 49       	mov.b	r9,	r13	;
    bc32:	cc 08       	mova	r8,	r12	;
    bc34:	b0 13 ae 5b 	calla	#23470		;0x05bae

0000bc38 <.L4>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
          req->buffer, end_cb);
    }
  }
  current_callback = req->callback;
  chSysUnlockFromISR();
    bc38:	b0 13 d0 45 	calla	#17872		;0x045d0

0000bc3c <.LVL5>:
}
    bc3c:	a1 00 08 00 	adda	#8,	r1	;
    bc40:	04 16       	popm.a	#1,	r4	;20-bit words
    bc42:	06 16       	popm.a	#1,	r6	;20-bit words
    bc44:	28 16       	popm.a	#3,	r10	;20-bit words
    bc46:	10 01       	reta			;

0000bc48 <.L3>:
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    bc48:	1c 44 04 00 	mov	4(r4),	r12	;
    bc4c:	b0 13 f6 cd 	calla	#52726		;0x0cdf6
    bc50:	0d 4a       	mov	r10,	r13	;
    bc52:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    bc56:	0d dc       	bis	r12,	r13	;
    bc58:	81 4d 04 00 	mov	r13,	4(r1)	;
    bc5c:	5a 07       	rrum	#2,	r10	;
    bc5e:	5a f3       	and.b	#1,	r10	;r3 As==01
    bc60:	81 4a 06 00 	mov	r10,	6(r1)	;
    bc64:	00 18 f1 40 	movx.a	#48366,	0(r1)	;0x0bcee
    bc68:	ee bc 00 00 
    bc6c:	cf 06       	mova	r6,	r15	;
    bc6e:	3e 01 04 00 	mova	4(r1),	r14	;
    bc72:	4d 49       	mov.b	r9,	r13	;
    bc74:	cc 08       	mova	r8,	r12	;
    bc76:	b0 13 9c 5c 	calla	#23708		;0x05c9c

0000bc7a <.LVL7>:
    bc7a:	80 00 38 bc 	mova	#48184,	r0	;0x0bc38

0000bc7e <.L2>:
    if (req->special) {
    bc7e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    bc80:	1b 24       	jz	$+56     	;abs 0xbcb8

0000bc82 <.Loc.58.1>:
          req->size, req->buffer, end_cb);
    bc82:	1c 44 04 00 	mov	4(r4),	r12	;
    bc86:	b0 13 f6 cd 	calla	#52726		;0x0cdf6
    bc8a:	0d 4a       	mov	r10,	r13	;
    bc8c:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    bc90:	0d dc       	bis	r12,	r13	;
    bc92:	81 4d 04 00 	mov	r13,	4(r1)	;
    bc96:	5a 07       	rrum	#2,	r10	;
    bc98:	5a f3       	and.b	#1,	r10	;r3 As==01
    bc9a:	81 4a 06 00 	mov	r10,	6(r1)	;

0000bc9e <.Loc.57.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    bc9e:	00 18 f1 40 	movx.a	#48366,	0(r1)	;0x0bcee
    bca2:	ee bc 00 00 
    bca6:	cf 06       	mova	r6,	r15	;
    bca8:	3e 01 04 00 	mova	4(r1),	r14	;
    bcac:	4d 49       	mov.b	r9,	r13	;
    bcae:	cc 08       	mova	r8,	r12	;
    bcb0:	b0 13 54 5e 	calla	#24148		;0x05e54

0000bcb4 <.LVL9>:
    bcb4:	80 00 38 bc 	mova	#48184,	r0	;0x0bc38

0000bcb8 <.L5>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    bcb8:	1c 44 04 00 	mov	4(r4),	r12	;
    bcbc:	b0 13 f6 cd 	calla	#52726		;0x0cdf6
    bcc0:	0d 4a       	mov	r10,	r13	;
    bcc2:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    bcc6:	0d dc       	bis	r12,	r13	;
    bcc8:	81 4d 04 00 	mov	r13,	4(r1)	;
    bccc:	5a 07       	rrum	#2,	r10	;
    bcce:	5a f3       	and.b	#1,	r10	;r3 As==01
    bcd0:	81 4a 06 00 	mov	r10,	6(r1)	;
    bcd4:	00 18 f1 40 	movx.a	#48366,	0(r1)	;0x0bcee
    bcd8:	ee bc 00 00 
    bcdc:	cf 06       	mova	r6,	r15	;
    bcde:	3e 01 04 00 	mova	4(r1),	r14	;
    bce2:	4d 49       	mov.b	r9,	r13	;
    bce4:	cc 08       	mova	r8,	r12	;
    bce6:	b0 13 fe 5e 	calla	#24318		;0x05efe

0000bcea <.LVL11>:
    bcea:	80 00 38 bc 	mova	#48184,	r0	;0x0bc38

0000bcee <end_cb>:
void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    bcee:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bcf0 <.LCFI4>:
    bcf0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bcf2 <.LCFI5>:
    bcf2:	06 14       	pushm.a	#1,	r6	;20-bit words

0000bcf4 <.LCFI6>:
    bcf4:	b1 00 04 00 	suba	#4,	r1	;

0000bcf8 <.LCFI7>:
    bcf8:	c6 0d       	mova	r13,	r6	;

0000bcfa <.Loc.21.1>:
  chSysLockFromISR();
    bcfa:	88 00 a6 45 	mova	#17830,	r8	;0x045a6
    bcfe:	71 0c 00 00 	mova	r12,	0(r1)	;
    bd02:	48 13       	calla	r8		;

0000bd04 <.LVL13>:
  i2cMSP430XEndTransferI(i2cp);
    bd04:	0c 01       	mova	@r1,	r12	;
    bd06:	b0 13 aa 5f 	calla	#24490		;0x05faa

0000bd0a <.LVL14>:
  chSysUnlockFromISR();
    bd0a:	8a 00 d0 45 	mova	#17872,	r10	;0x045d0
    bd0e:	4a 13       	calla	r10		;

0000bd10 <.LVL15>:
  if (active_req->callback) {
    bd10:	2c 00 ee d3 	mova	&54254,	r12	;0x0d3ee
    bd14:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    bd18:	9e 00 00 00 	cmpa	#0,	r14	;
    bd1c:	02 24       	jz	$+6      	;abs 0xbd22

0000bd1e <.Loc.26.1>:
    active_req->callback(buffer);
    bd1e:	cc 06       	mova	r6,	r12	;
    bd20:	4e 13       	calla	r14		;

0000bd22 <.L7>:
  chSysLockFromISR();
    bd22:	48 13       	calla	r8		;

0000bd24 <.LVL17>:
  elyQueueFreeBufferI(&fram_queue, (uint8_t *)(active_req));
    bd24:	2d 00 ee d3 	mova	&54254,	r13	;0x0d3ee
    bd28:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4
    bd2c:	b0 13 5e bf 	calla	#48990		;0x0bf5e

0000bd30 <.LBB16>:
  chDbgCheckClassI();
    bd30:	b0 13 54 46 	calla	#18004		;0x04654

0000bd34 <.LVL19>:
  if (bsp->sem.cnt < (cnt_t)1) {
    bd34:	c0 18 1c 42 	movx.w	&0x10a9a,r12	;
    bd38:	9a 0a 
    bd3a:	4d 43       	clr.b	r13		;
    bd3c:	0d 9c       	cmp	r12,	r13	;
    bd3e:	04 38       	jl	$+10     	;abs 0xbd48

0000bd40 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    bd40:	8c 01 9a 0a 	mova	#68250,	r12	;0x10a9a
    bd44:	b0 13 fe 4a 	calla	#19198		;0x04afe

0000bd48 <.L8>:
  chSysUnlockFromISR();
    bd48:	4a 13       	calla	r10		;

0000bd4a <.LVL21>:
}
    bd4a:	a1 00 04 00 	adda	#4,	r1	;
    bd4e:	06 16       	popm.a	#1,	r6	;20-bit words
    bd50:	08 16       	popm.a	#1,	r8	;20-bit words
    bd52:	0a 16       	popm.a	#1,	r10	;20-bit words
    bd54:	10 01       	reta			;

0000bd56 <fram_handle_request>:

void fram_handle_request(fram_req_t * req) {
    bd56:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bd58 <.LCFI8>:
    bd58:	b1 00 04 00 	suba	#4,	r1	;

0000bd5c <.LCFI9>:
    bd5c:	ca 0c       	mova	r12,	r10	;

0000bd5e <.Loc.70.1>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    bd5e:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bd60 <.LVL23>:
    bd60:	1c 9a 02 00 	cmp	2(r10),	r12	;
    bd64:	04 2c       	jc	$+10     	;abs 0xbd6e

0000bd66 <.Loc.70.1>:
    bd66:	8c 01 f3 07 	mova	#67571,	r12	;0x107f3
    bd6a:	b0 13 dc 47 	calla	#18396		;0x047dc

0000bd6e <.L13>:
  
  active_req = req;
    bd6e:	60 0a ee d3 	mova	r10,	&54254	; 0x0d3ee

0000bd72 <.Loc.75.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    bd72:	2c 4a       	mov	@r10,	r12	;
    bd74:	1d 4a 02 00 	mov	2(r10),	r13	;
    bd78:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    bd7c:	b0 13 70 ce 	calla	#52848		;0x0ce70

0000bd80 <.Loc.74.1>:
  req->device_id = (slave_id | device_select | 
    bd80:	7c d0 50 00 	bis.b	#80,	r12	;#0x0050
    bd84:	ca 4c 10 00 	mov.b	r12,	16(r10)	; 0x0010

0000bd88 <.LBB22>:
  _disable_interrupts();
    bd88:	32 c2       	dint			
    bd8a:	03 43       	nop			

0000bd8c <.Loc.348.3>:
  asm volatile("nop");
    bd8c:	03 43       	nop			

0000bd8e <.LBE22>:
  
  /* Issue a write to set the address */
  chSysLock();
    bd8e:	b0 13 54 45 	calla	#17748		;0x04554

0000bd92 <.LVL26>:
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    bd92:	5d 4a 10 00 	mov.b	16(r10),r13	;0x00010
    bd96:	00 18 f1 40 	movx.a	#48084,	0(r1)	;0x0bbd4
    bd9a:	d4 bb 00 00 
    bd9e:	cf 0a       	mova	r10,	r15	;
    bda0:	6e 43       	mov.b	#2,	r14	;r3 As==10
    bda2:	8c 01 72 14 	mova	#70770,	r12	;0x11472
    bda6:	b0 13 94 5d 	calla	#23956		;0x05d94

0000bdaa <.LVL27>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
  chSysUnlock();
    bdaa:	b0 13 7c 45 	calla	#17788		;0x0457c

0000bdae <.LBB24>:
  asm volatile("nop");
    bdae:	03 43       	nop			

0000bdb0 <.Loc.356.3>:
  _enable_interrupts();
    bdb0:	03 43       	nop			
    bdb2:	32 d2       	eint			
    bdb4:	03 43       	nop			

0000bdb6 <.LBE24>:
}
    bdb6:	a1 00 04 00 	adda	#4,	r1	;
    bdba:	0a 16       	popm.a	#1,	r10	;20-bit words
    bdbc:	10 01       	reta			;

0000bdbe <elyFramGetRequest>:

msg_t elyFramGetRequest(fram_req_t ** reqp) {
    bdbe:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bdc0 <.LCFI10>:
    bdc0:	ca 0c       	mova	r12,	r10	;

0000bdc2 <.Loc.86.1>:
  msg_t r = elyQueueGetEmptyBufferTimeout(&fram_queue, (uint8_t **)reqp, TIME_IMMEDIATE);
    bdc2:	3e 43       	mov	#-1,	r14	;r3 As==11
    bdc4:	cd 0c       	mova	r12,	r13	;
    bdc6:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4

0000bdca <.LVL30>:
    bdca:	b0 13 1e bf 	calla	#48926		;0x0bf1e

0000bdce <.LVL31>:
  /* ENH remove this hack - should be at PointOfCall */
  (*reqp)->special = 0;
    bdce:	0e 0a       	mova	@r10,	r14	;
    bdd0:	de c3 04 00 	bic.b	#1,	4(r14)	;r3 As==01

0000bdd4 <.Loc.90.1>:
  return r;
}
    bdd4:	0a 16       	popm.a	#1,	r10	;20-bit words
    bdd6:	10 01       	reta			;

0000bdd8 <elyFramPostRequest>:

msg_t elyFramPostRequest(fram_req_t * req) {
    bdd8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bdda <.LCFI11>:
    bdda:	b1 00 04 00 	suba	#4,	r1	;

0000bdde <.LCFI12>:
    bdde:	ca 0c       	mova	r12,	r10	;

0000bde0 <.LBB30>:
  _disable_interrupts();
    bde0:	32 c2       	dint			
    bde2:	03 43       	nop			

0000bde4 <.Loc.348.3>:
  asm volatile("nop");
    bde4:	03 43       	nop			

0000bde6 <.LBE30>:
  msg_t result;
  chSysLock();
    bde6:	b0 13 54 45 	calla	#17748		;0x04554

0000bdea <.LVL33>:
  result = elyQueuePostFullBufferS(&fram_queue, (uint8_t *)(req), TIME_IMMEDIATE);
    bdea:	3e 43       	mov	#-1,	r14	;r3 As==11
    bdec:	cd 0a       	mova	r10,	r13	;
    bdee:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4
    bdf2:	b0 13 cc be 	calla	#48844		;0x0becc

0000bdf6 <.LVL34>:
  chSysUnlock();
    bdf6:	71 0c 00 00 	mova	r12,	0(r1)	;
    bdfa:	b0 13 7c 45 	calla	#17788		;0x0457c

0000bdfe <.LBB32>:
  asm volatile("nop");
    bdfe:	03 43       	nop			

0000be00 <.Loc.356.3>:
  _enable_interrupts();
    be00:	03 43       	nop			
    be02:	32 d2       	eint			
    be04:	03 43       	nop			

0000be06 <.LBE32>:
  return result;
}
    be06:	0c 01       	mova	@r1,	r12	;
    be08:	a1 00 04 00 	adda	#4,	r1	;
    be0c:	0a 16       	popm.a	#1,	r10	;20-bit words
    be0e:	10 01       	reta			;

0000be10 <elyFramGetRequestTimeoutS>:

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    be10:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000be12 <.LCFI13>:
    be12:	ca 0c       	mova	r12,	r10	;

0000be14 <.Loc.101.1>:
  msg_t r = elyQueueGetEmptyBufferTimeoutS(&fram_queue, (uint8_t **)reqp, timeout);
    be14:	0e 4d       	mov	r13,	r14	;
    be16:	cd 0c       	mova	r12,	r13	;

0000be18 <.LVL37>:
    be18:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4

0000be1c <.LVL38>:
    be1c:	b0 13 f8 be 	calla	#48888		;0x0bef8

0000be20 <.LVL39>:
  (*reqp)->special = 0;
    be20:	0e 0a       	mova	@r10,	r14	;
    be22:	de c3 04 00 	bic.b	#1,	4(r14)	;r3 As==01

0000be26 <.Loc.104.1>:
  return r;
}
    be26:	0a 16       	popm.a	#1,	r10	;20-bit words
    be28:	10 01       	reta			;

0000be2a <FramThd>:
static I2CConfig cfg = {
  400000, /* max bitrate supported by USCI */
};

THD_WORKING_AREA(waFramThd, 256);
THD_FUNCTION(FramThd, arg) {
    be2a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000be2c <.LCFI14>:
    be2c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000be2e <.LCFI15>:
    be2e:	b1 00 04 00 	suba	#4,	r1	;

0000be32 <.LCFI16>:
  (void)arg;
  fram_req_t * req;
  
  i2cStart(&I2CDB0, &cfg);
    be32:	8d 01 96 0a 	mova	#68246,	r13	;0x10a96
    be36:	8c 01 72 14 	mova	#70770,	r12	;0x11472

0000be3a <.LVL41>:
    be3a:	b0 13 0c 51 	calla	#20748		;0x0510c

0000be3e <.LVL42>:
  
  if (!elyIsQueueInitialized(&fram_queue)) {
    be3e:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4
    be42:	b0 13 94 be 	calla	#48788		;0x0be94

0000be46 <.LVL43>:
    be46:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    be48:	08 20       	jnz	$+18     	;abs 0xbe5a

0000be4a <.Loc.118.1>:
    elyQueueObjectInit(&fram_queue, sizeof(fram_req_t), (uint8_t *)(fram_queue_storage));
    be4a:	8e 01 9c 0a 	mova	#68252,	r14	;0x10a9c
    be4e:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    be52:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4
    be56:	b0 13 a4 be 	calla	#48804		;0x0bea4

0000be5a <.L20>:
  }
  
  chSemObjectInit(&fram_queue.mbox.fullsem, (cnt_t)0);
    be5a:	41 18 82 43 	movx.w	#0,	&0x10af8;r3 As==00
    be5e:	f8 0a 

0000be60 <.Loc.123.1>:
  
  while (MSG_OK == elyQueuePend(&fram_queue, (uint8_t**)(&req), TIME_INFINITE)) {
    be60:	8a 00 94 bf 	mova	#49044,	r10	;0x0bf94

0000be64 <.LBB36>:
  return chSemWaitTimeout(&bsp->sem, time);
    be64:	88 00 7c 4a 	mova	#19068,	r8	;0x04a7c

0000be68 <.L21>:
    be68:	4e 43       	clr.b	r14		;
    be6a:	cd 01       	mova	r1,	r13	;
    be6c:	8c 01 e4 0a 	mova	#68324,	r12	;0x10ae4
    be70:	4a 13       	calla	r10		;

0000be72 <.LVL45>:
    be72:	9c 00 00 00 	cmpa	#0,	r12	;
    be76:	05 24       	jz	$+12     	;abs 0xbe82

0000be78 <.Loc.132.1>:
#if ELY_REVISION == A
    chThdSleepMilliseconds(10);
#endif
  }
  
}
    be78:	a1 00 04 00 	adda	#4,	r1	;
    be7c:	08 16       	popm.a	#1,	r8	;20-bit words
    be7e:	0a 16       	popm.a	#1,	r10	;20-bit words
    be80:	10 01       	reta			;

0000be82 <.L22>:
    be82:	4d 43       	clr.b	r13		;
    be84:	8c 01 9a 0a 	mova	#68250,	r12	;0x10a9a
    be88:	48 13       	calla	r8		;

0000be8a <.LBE39>:
    fram_handle_request(req);
    be8a:	0c 01       	mova	@r1,	r12	;
    be8c:	b0 13 56 bd 	calla	#48470		;0x0bd56

0000be90 <.LVL48>:
    be90:	80 00 68 be 	mova	#48744,	r0	;0x0be68

0000be94 <elyIsQueueInitialized>:
#include "queues.h"

bool elyIsQueueInitialized( queue_t * queue ) {
  return (queue->mpool.pool.object_size != 0);
    be94:	5d 43       	mov.b	#1,	r13	;r3 As==01
    be96:	00 18 cc 93 	cmpx.a	#0,	30(r12)	;r3 As==00, 0x0001e
    be9a:	1e 00 
    be9c:	01 20       	jnz	$+4      	;abs 0xbea0
    be9e:	4d 43       	clr.b	r13		;

0000bea0 <.L2>:
}
    bea0:	4c 4d       	mov.b	r13,	r12	;

0000bea2 <.LVL1>:
    bea2:	10 01       	reta			;

0000bea4 <elyQueueObjectInit>:

void elyQueueObjectInit( queue_t * queue, size_t buf_size, uint8_t * mpool_storage ) {
    bea4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bea6 <.LCFI0>:
    bea6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bea8 <.LCFI1>:
    bea8:	06 14       	pushm.a	#1,	r6	;20-bit words

0000beaa <.LCFI2>:
    beaa:	c8 0c       	mova	r12,	r8	;
    beac:	c6 0e       	mova	r14,	r6	;

0000beae <.Loc.8.1>:
  chGuardedPoolObjectInit(&(queue->mpool), buf_size);
    beae:	ca 0c       	mova	r12,	r10	;
    beb0:	aa 00 18 00 	adda	#24,	r10	;0x00018
    beb4:	cc 0a       	mova	r10,	r12	;

0000beb6 <.LVL3>:
    beb6:	b0 13 90 4e 	calla	#20112		;0x04e90

0000beba <.LVL4>:
  chGuardedPoolLoadArray(&(queue->mpool), mpool_storage, queue->queue_len);
    beba:	0e 08       	mova	@r8,	r14	;
    bebc:	cd 06       	mova	r6,	r13	;
    bebe:	cc 0a       	mova	r10,	r12	;
    bec0:	b0 13 4c 4f 	calla	#20300		;0x04f4c

0000bec4 <.LVL5>:
}
    bec4:	06 16       	popm.a	#1,	r6	;20-bit words
    bec6:	08 16       	popm.a	#1,	r8	;20-bit words
    bec8:	0a 16       	popm.a	#1,	r10	;20-bit words
    beca:	10 01       	reta			;

0000becc <elyQueuePostFullBufferS>:

msg_t elyQueuePostFullBufferS(queue_t * queue, uint8_t * buffer, systime_t timeout) {
    becc:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bece <.LCFI3>:
    bece:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bed0 <.LCFI4>:
    bed0:	b1 00 04 00 	suba	#4,	r1	;

0000bed4 <.LCFI5>:
    bed4:	ca 0c       	mova	r12,	r10	;
    bed6:	c8 0d       	mova	r13,	r8	;

0000bed8 <.Loc.13.1>:
  chDbgCheckClassS();
    bed8:	71 0e 00 00 	mova	r14,	0(r1)	;
    bedc:	b0 13 78 46 	calla	#18040		;0x04678

0000bee0 <.LVL7>:
  chDbgCheck(queue != NULL);
  
  return chMBPostS(&(queue->mbox), (msg_t)(buffer), timeout);
    bee0:	0e 01       	mova	@r1,	r14	;
    bee2:	cd 08       	mova	r8,	r13	;
    bee4:	cc 0a       	mova	r10,	r12	;
    bee6:	ac 00 04 00 	adda	#4,	r12	;
    beea:	b0 13 54 4c 	calla	#19540		;0x04c54

0000beee <.LVL8>:
}
    beee:	a1 00 04 00 	adda	#4,	r1	;
    bef2:	08 16       	popm.a	#1,	r8	;20-bit words
    bef4:	0a 16       	popm.a	#1,	r10	;20-bit words
    bef6:	10 01       	reta			;

0000bef8 <elyQueueGetEmptyBufferTimeoutS>:
  chDbgCheck(queue != NULL);
  
  return chMBPostAheadI(&(queue->mbox), (msg_t)(buffer));
}

msg_t elyQueueGetEmptyBufferTimeoutS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bef8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000befa <.LCFI13>:
    befa:	ca 0d       	mova	r13,	r10	;

0000befc <.Loc.41.1>:
  void * result = chGuardedPoolAllocTimeoutS(&(queue->mpool), timeout);
    befc:	0d 4e       	mov	r14,	r13	;

0000befe <.LVL19>:
    befe:	ac 00 18 00 	adda	#24,	r12	;0x00018

0000bf02 <.LVL20>:
    bf02:	b0 13 ca 4e 	calla	#20170		;0x04eca

0000bf06 <.LVL21>:
  if (result == NULL) {
    bf06:	9c 00 00 00 	cmpa	#0,	r12	;
    bf0a:	05 24       	jz	$+12     	;abs 0xbf16

0000bf0c <.Loc.46.1>:
    return MSG_TIMEOUT;
  }
  
  (*bufferp) = result;
    bf0c:	7a 0c 00 00 	mova	r12,	0(r10)	;

0000bf10 <.Loc.47.1>:
  return MSG_OK;
    bf10:	4c 43       	clr.b	r12		;

0000bf12 <.L8>:
}
    bf12:	0a 16       	popm.a	#1,	r10	;20-bit words
    bf14:	10 01       	reta			;

0000bf16 <.L10>:
    return MSG_TIMEOUT;
    bf16:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000bf1a <.LVL24>:
    bf1a:	80 00 12 bf 	mova	#48914,	r0	;0x0bf12

0000bf1e <elyQueueGetEmptyBufferTimeout>:

msg_t elyQueueGetEmptyBufferTimeout(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bf1e:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bf20 <.LCFI14>:
    bf20:	b1 00 08 00 	suba	#8,	r1	;

0000bf24 <.LCFI15>:
    bf24:	ca 0d       	mova	r13,	r10	;

0000bf26 <.LBB12>:
  _disable_interrupts();
    bf26:	32 c2       	dint			
    bf28:	03 43       	nop			

0000bf2a <.Loc.348.2>:
  asm volatile("nop");
    bf2a:	03 43       	nop			

0000bf2c <.LBE12>:
  msg_t result;
  chSysLock();
    bf2c:	71 0c 00 00 	mova	r12,	0(r1)	;
    bf30:	71 0e 04 00 	mova	r14,	4(r1)	;
    bf34:	b0 13 54 45 	calla	#17748		;0x04554

0000bf38 <.LVL26>:
  result = elyQueueGetEmptyBufferTimeoutS(queue, bufferp, timeout);
    bf38:	3e 01 04 00 	mova	4(r1),	r14	;
    bf3c:	cd 0a       	mova	r10,	r13	;
    bf3e:	0c 01       	mova	@r1,	r12	;
    bf40:	b0 13 f8 be 	calla	#48888		;0x0bef8

0000bf44 <.LVL27>:
  chSysUnlock();
    bf44:	71 0c 00 00 	mova	r12,	0(r1)	;
    bf48:	b0 13 7c 45 	calla	#17788		;0x0457c

0000bf4c <.LBB14>:
  asm volatile("nop");
    bf4c:	03 43       	nop			

0000bf4e <.Loc.356.2>:
  _enable_interrupts();
    bf4e:	03 43       	nop			
    bf50:	32 d2       	eint			
    bf52:	03 43       	nop			

0000bf54 <.LBE14>:
  return result;
}
    bf54:	0c 01       	mova	@r1,	r12	;
    bf56:	a1 00 08 00 	adda	#8,	r1	;
    bf5a:	0a 16       	popm.a	#1,	r10	;20-bit words
    bf5c:	10 01       	reta			;

0000bf5e <elyQueueFreeBufferI>:

void elyQueueFreeBufferI(queue_t * queue, uint8_t * buffer) {
  chGuardedPoolFreeI(&(queue->mpool), buffer);
    bf5e:	ac 00 18 00 	adda	#24,	r12	;0x00018

0000bf62 <.LVL30>:
    bf62:	b0 13 ec 4e 	calla	#20204		;0x04eec

0000bf66 <.LVL31>:
}
    bf66:	10 01       	reta			;

0000bf68 <elyQueuePendS>:

/* TODO add timeout variant using guarded pools */

msg_t elyQueuePendS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bf68:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bf6a <.LCFI16>:
    bf6a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bf6c <.LCFI17>:
    bf6c:	b1 00 04 00 	suba	#4,	r1	;

0000bf70 <.LCFI18>:
    bf70:	ca 0c       	mova	r12,	r10	;
    bf72:	c8 0d       	mova	r13,	r8	;

0000bf74 <.Loc.65.1>:
  chDbgCheckClassS();
    bf74:	71 0e 00 00 	mova	r14,	0(r1)	;
    bf78:	b0 13 78 46 	calla	#18040		;0x04678

0000bf7c <.LVL33>:
  chDbgCheck(queue != NULL);
  
  return chMBFetchS(&(queue->mbox), (msg_t *)(bufferp), timeout);
    bf7c:	0e 01       	mova	@r1,	r14	;
    bf7e:	cd 08       	mova	r8,	r13	;
    bf80:	cc 0a       	mova	r10,	r12	;
    bf82:	ac 00 04 00 	adda	#4,	r12	;
    bf86:	b0 13 44 4d 	calla	#19780		;0x04d44

0000bf8a <.LVL34>:
}
    bf8a:	a1 00 04 00 	adda	#4,	r1	;
    bf8e:	08 16       	popm.a	#1,	r8	;20-bit words
    bf90:	0a 16       	popm.a	#1,	r10	;20-bit words
    bf92:	10 01       	reta			;

0000bf94 <elyQueuePend>:

msg_t elyQueuePend(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bf94:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bf96 <.LCFI19>:
    bf96:	b1 00 08 00 	suba	#8,	r1	;

0000bf9a <.LCFI20>:
    bf9a:	ca 0d       	mova	r13,	r10	;

0000bf9c <.LBB20>:
  _disable_interrupts();
    bf9c:	32 c2       	dint			
    bf9e:	03 43       	nop			

0000bfa0 <.Loc.348.2>:
  asm volatile("nop");
    bfa0:	03 43       	nop			

0000bfa2 <.LBE20>:
  msg_t result;
  chSysLock();
    bfa2:	71 0c 00 00 	mova	r12,	0(r1)	;
    bfa6:	71 0e 04 00 	mova	r14,	4(r1)	;
    bfaa:	b0 13 54 45 	calla	#17748		;0x04554

0000bfae <.LVL36>:
  result = elyQueuePendS(queue, bufferp, timeout);
    bfae:	3e 01 04 00 	mova	4(r1),	r14	;
    bfb2:	cd 0a       	mova	r10,	r13	;
    bfb4:	0c 01       	mova	@r1,	r12	;
    bfb6:	b0 13 68 bf 	calla	#49000		;0x0bf68

0000bfba <.LVL37>:
  chSysUnlock();
    bfba:	71 0c 00 00 	mova	r12,	0(r1)	;
    bfbe:	b0 13 7c 45 	calla	#17788		;0x0457c

0000bfc2 <.LBB22>:
  asm volatile("nop");
    bfc2:	03 43       	nop			

0000bfc4 <.Loc.356.2>:
  _enable_interrupts();
    bfc4:	03 43       	nop			
    bfc6:	32 d2       	eint			
    bfc8:	03 43       	nop			

0000bfca <.LBE22>:
  return result;
}
    bfca:	0c 01       	mova	@r1,	r12	;
    bfcc:	a1 00 08 00 	adda	#8,	r1	;
    bfd0:	0a 16       	popm.a	#1,	r10	;20-bit words
    bfd2:	10 01       	reta			;

0000bfd4 <nl_allocator>:

static uint8_t PERSIST packets_received;
static uint16_t PERSIST packets_sent = 1;
static uint8_t PERSIST packets_relayed;

void * nl_allocator(size_t size, unsigned align) {
    bfd4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bfd6 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  /* TODO fix this to use PERSIST when GCC fixes bug #78818 */
  static size_t __attribute__((section(".persistent"))) curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    bfd6:	2e 00 14 d1 	mova	&53524,	r14	;0x0d114
    bfda:	ca 0e       	mova	r14,	r10	;
    bfdc:	ea 0c       	adda	r12,	r10	;
    bfde:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

0000bfe2 <.LVL1>:
    bfe2:	dc 0a       	cmpa	r10,	r12	;
    bfe4:	07 28       	jnc	$+16     	;abs 0xbff4

0000bfe6 <.Loc.23.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    bfe6:	cc 0e       	mova	r14,	r12	;
    bfe8:	ac 00 02 d4 	adda	#54274,	r12	;0x0d402

0000bfec <.LVL2>:
  
  curr_index += size;
    bfec:	60 0a 14 d1 	mova	r10,	&53524	; 0x0d114

0000bff0 <.L1>:
  return result;
}
    bff0:	0a 16       	popm.a	#1,	r10	;20-bit words
    bff2:	10 01       	reta			;

0000bff4 <.L3>:
    return NULL;
    bff4:	4c 43       	clr.b	r12		;
    bff6:	80 00 f0 bf 	mova	#49136,	r0	;0x0bff0

0000bffa <clamp>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    bffa:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000bffc <.LCFI1>:
    bffc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    c000:	49 4d       	mov.b	r13,	r9	;
    c002:	4a 4e       	mov.b	r14,	r10	;

0000c004 <.Loc.32.1>:
  if (value < min) {
    c004:	4c 99       	cmp.b	r9,	r12	;
    c006:	07 2c       	jc	$+16     	;abs 0xc016

0000c008 <.LVL5>:
    value = min;
    elyErrorSignal(ErrRegClip);
    c008:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c00c:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c010 <.LVL6>:
    c010:	0c 49       	mov	r9,	r12	;

0000c012 <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    c012:	19 16       	popm.a	#2,	r10	;20-bit words
    c014:	10 01       	reta			;

0000c016 <.L5>:
  else if (value > max) {
    c016:	4a 9c       	cmp.b	r12,	r10	;
    c018:	fc 2f       	jc	$-6      	;abs 0xc012

0000c01a <.LVL9>:
    elyErrorSignal(ErrRegClip);
    c01a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c01e:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c022 <.LVL10>:
    c022:	0c 4a       	mov	r10,	r12	;
    c024:	80 00 12 c0 	mova	#49170,	r0	;0x0c012

0000c028 <elyNLClampReg>:
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}

uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    c028:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c02a <.LCFI2>:
    c02a:	49 4c       	mov.b	r12,	r9	;
    c02c:	4a 4d       	mov.b	r13,	r10	;

0000c02e <.Loc.72.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    c02e:	4c 49       	mov.b	r9,	r12	;

0000c030 <.LVL12>:
    c030:	7c 50 80 ff 	add.b	#-128,	r12	;#0xff80
    c034:	7d 40 09 00 	mov.b	#9,	r13	;

0000c038 <.LVL13>:
    c038:	4d 9c       	cmp.b	r12,	r13	;
    c03a:	04 2c       	jc	$+10     	;abs 0xc044

0000c03c <.Loc.72.1>:
    c03c:	8c 01 07 08 	mova	#67591,	r12	;0x10807
    c040:	b0 13 dc 47 	calla	#18396		;0x047dc

0000c044 <.L8>:
  switch(addr) {
    c044:	79 90 83 ff 	cmp.b	#-125,	r9	;#0xff83
    c048:	35 24       	jz	$+108    	;abs 0xc0b4
    c04a:	7d 40 83 ff 	mov.b	#-125,	r13	;#0xff83
    c04e:	4d 99       	cmp.b	r9,	r13	;
    c050:	09 28       	jnc	$+20     	;abs 0xc064
    c052:	79 90 80 ff 	cmp.b	#-128,	r9	;#0xff80
    c056:	20 24       	jz	$+66     	;abs 0xc098
    c058:	79 90 81 ff 	cmp.b	#-127,	r9	;#0xff81
    c05c:	26 24       	jz	$+78     	;abs 0xc0aa

0000c05e <.L9>:
    default:
      /* All other registers have ranges equal to their data type's */
      break;
  }
  return value;
}
    c05e:	4c 4a       	mov.b	r10,	r12	;
    c060:	19 16       	popm.a	#2,	r10	;20-bit words
    c062:	10 01       	reta			;

0000c064 <.L11>:
  switch(addr) {
    c064:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    c068:	29 24       	jz	$+84     	;abs 0xc0bc
    c06a:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    c06e:	f7 2b       	jnc	$-16     	;abs 0xc05e
    c070:	79 50 79 00 	add.b	#121,	r9	;#0x0079
    c074:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c076:	4c 99       	cmp.b	r9,	r12	;
    c078:	f2 2b       	jnc	$-26     	;abs 0xc05e

0000c07a <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    c07a:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    c07e:	10 00 
    c080:	21 24       	jz	$+68     	;abs 0xc0c4
    c082:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    c086:	1e 24       	jz	$+62     	;abs 0xc0c4

0000c088 <.Loc.45.1>:
    elyErrorSignal(ErrRegClip);
    c088:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c08c:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c090 <.LVL17>:
    return 0x10;
    c090:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

0000c094 <.LVL18>:
    c094:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c098 <.L12>:
      value = clamp(value, 7, 0xFF);
    c098:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    c09a:	7d 40 07 00 	mov.b	#7,	r13	;

0000c09e <.L55>:
      value = clamp(value, 0, 0x10);
    c09e:	4c 4a       	mov.b	r10,	r12	;
    c0a0:	b0 13 fa bf 	calla	#49146		;0x0bffa

0000c0a4 <.LVL20>:
    c0a4:	4a 4c       	mov.b	r12,	r10	;

0000c0a6 <.LVL21>:
      break;
    c0a6:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c0aa <.L13>:
      value = clamp(value, 0, 0x10);
    c0aa:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

0000c0ae <.L56>:
    c0ae:	4d 43       	clr.b	r13		;
    c0b0:	80 00 9e c0 	mova	#49310,	r0	;0x0c09e

0000c0b4 <.L10>:
      value = clamp(value, 0, 0x07);
    c0b4:	7e 40 07 00 	mov.b	#7,	r14	;
    c0b8:	80 00 ae c0 	mova	#49326,	r0	;0x0c0ae

0000c0bc <.L14>:
      value = clamp(value, 0, 0x3F);
    c0bc:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    c0c0:	80 00 ae c0 	mova	#49326,	r0	;0x0c0ae

0000c0c4 <.L16>:
  if ((value & 0x08) && value != 0x08) {
    c0c4:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    c0c8:	09 24       	jz	$+20     	;abs 0xc0dc
    c0ca:	3a 92       	cmp	#8,	r10	;r2 As==11
    c0cc:	07 24       	jz	$+16     	;abs 0xc0dc

0000c0ce <.Loc.49.1>:
    elyErrorSignal(ErrRegClip);
    c0ce:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c0d2:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c0d6 <.LVL24>:
    return 0x08;
    c0d6:	7a 42       	mov.b	#8,	r10	;r2 As==11

0000c0d8 <.LVL25>:
    c0d8:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c0dc <.L17>:
  if ((value & 0x04) && value != 0x04) {
    c0dc:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    c0e0:	09 24       	jz	$+20     	;abs 0xc0f4
    c0e2:	2a 92       	cmp	#4,	r10	;r2 As==10
    c0e4:	07 24       	jz	$+16     	;abs 0xc0f4

0000c0e6 <.Loc.53.1>:
    elyErrorSignal(ErrRegClip);
    c0e6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c0ea:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c0ee <.LVL27>:
    return 0x04;
    c0ee:	6a 42       	mov.b	#4,	r10	;r2 As==10

0000c0f0 <.LVL28>:
    c0f0:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c0f4 <.L18>:
  if ((value & 0x02) && value != 0x02) {
    c0f4:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    c0f8:	09 24       	jz	$+20     	;abs 0xc10c
    c0fa:	2a 93       	cmp	#2,	r10	;r3 As==10
    c0fc:	07 24       	jz	$+16     	;abs 0xc10c

0000c0fe <.Loc.57.1>:
    elyErrorSignal(ErrRegClip);
    c0fe:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c102:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c106 <.LVL30>:
    return 0x02;
    c106:	6a 43       	mov.b	#2,	r10	;r3 As==10

0000c108 <.LVL31>:
    c108:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c10c <.L19>:
  if ((value & 0x01) && value != 0x01) {
    c10c:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    c110:	09 24       	jz	$+20     	;abs 0xc124
    c112:	1a 93       	cmp	#1,	r10	;r3 As==01
    c114:	07 24       	jz	$+16     	;abs 0xc124

0000c116 <.Loc.61.1>:
    elyErrorSignal(ErrRegClip);
    c116:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c11a:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c11e <.LVL33>:
    return 0x01;
    c11e:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000c120 <.LVL34>:
    c120:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c124 <.L20>:
  if (value & 0xD0) {
    c124:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    c128:	9a 27       	jz	$-202    	;abs 0xc05e

0000c12a <.Loc.65.1>:
    elyErrorSignal(ErrRegClip);
    c12a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c12e:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c132 <.LVL36>:
    return 0x00;
    c132:	4a 43       	clr.b	r10		;

0000c134 <.LVL37>:
    c134:	80 00 5e c0 	mova	#49246,	r0	;0x0c05e

0000c138 <elyNLGetBuffer>:
  elyNLMaxLen = len;
  main_mpool.object_size = elyNLMaxLen;
}

uint8_t * elyNLGetBuffer() {
  return chPoolAlloc(&main_mpool);
    c138:	8c 01 0a 0b 	mova	#68362,	r12	;0x10b0a
    c13c:	b0 13 12 4e 	calla	#19986		;0x04e12

0000c140 <.LVL45>:
}
    c140:	10 01       	reta			;

0000c142 <elyNLFreeBuffer>:

void elyNLFreeBuffer(uint8_t * buffer) {
  chPoolFree(&main_mpool, buffer);
    c142:	cd 0c       	mova	r12,	r13	;
    c144:	8c 01 0a 0b 	mova	#68362,	r12	;0x10b0a

0000c148 <.LVL47>:
    c148:	b0 13 5e 4e 	calla	#20062		;0x04e5e

0000c14c <.LVL48>:
}
    c14c:	10 01       	reta			;

0000c14e <elyNLGetBufferI>:

uint8_t * elyNLGetBufferI() {
  chDbgCheckClassI();
    c14e:	b0 13 54 46 	calla	#18004		;0x04654

0000c152 <.LVL49>:
  return chPoolAllocI(&main_mpool);
    c152:	8c 01 0a 0b 	mova	#68362,	r12	;0x10b0a
    c156:	b0 13 e2 4d 	calla	#19938		;0x04de2

0000c15a <.LVL50>:
}
    c15a:	10 01       	reta			;

0000c15c <elyNLFreeBufferI>:

void elyNLFreeBufferI(uint8_t * buffer) {
    c15c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c15e <.LCFI7>:
    c15e:	ca 0c       	mova	r12,	r10	;

0000c160 <.Loc.125.1>:
  chDbgCheckClassI();
    c160:	b0 13 54 46 	calla	#18004		;0x04654

0000c164 <.LVL52>:
  chPoolFreeI(&main_mpool, buffer);
    c164:	cd 0a       	mova	r10,	r13	;
    c166:	8c 01 0a 0b 	mova	#68362,	r12	;0x10b0a
    c16a:	b0 13 42 4e 	calla	#20034		;0x04e42

0000c16e <.LVL53>:
}
    c16e:	0a 16       	popm.a	#1,	r10	;20-bit words
    c170:	10 01       	reta			;

0000c172 <elyNLGetDest>:
   * Else If (TC) UART
   * Else (TM) If (Source == Elysium AND APID != GroundAPID) UART
   * Else RF */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    c172:	6d 4c       	mov.b	@r12,	r13	;
    c174:	5f 4c 01 00 	mov.b	1(r12),	r15	;

0000c178 <.LVL55>:
    c178:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    c17c:	5c 4e 51 00 	mov.b	81(r14),r12	;0x00051

0000c180 <.LVL56>:
    c180:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    c184:	5e 4e 50 00 	mov.b	80(r14),r14	;0x00050
    c188:	0c de       	bis	r14,	r12	;

0000c18a <.LVL57>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (tc) {
    c18a:	40 18 3d b0 	bitx.w	#16,	r13	;0x00010
    c18e:	10 00 
    c190:	09 24       	jz	$+20     	;abs 0xc1a4

0000c192 <.Loc.160.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    c192:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;

0000c196 <.LVL58>:
    c196:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    c19a:	0d df       	bis	r15,	r13	;

0000c19c <.Loc.166.1>:
    if (apid == elysium_apid)
    c19c:	0d 9c       	cmp	r12,	r13	;
    c19e:	05 24       	jz	$+12     	;abs 0xc1aa

0000c1a0 <.Loc.169.1>:
      return ELY_DEST_FW;
    else
      return ELY_DEST_UART;
    c1a0:	4c 43       	clr.b	r12		;

0000c1a2 <.L67>:
    return ELY_DEST_RF;
  }
  
  chDbgAssert(false, "unreachable code path");
  return 0;
}
    c1a2:	10 01       	reta			;

0000c1a4 <.L68>:
    return ELY_DEST_RF;
    c1a4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c1a6:	80 00 a2 c1 	mova	#49570,	r0	;0x0c1a2

0000c1aa <.L69>:
      return ELY_DEST_FW;
    c1aa:	6c 43       	mov.b	#2,	r12	;r3 As==10
    c1ac:	80 00 a2 c1 	mova	#49570,	r0	;0x0c1a2

0000c1b0 <get_sh_len>:

size_t get_sh_len(void) {
  uint8_t options = bank0p[RegNLOptions];
    c1b0:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    c1b4:	5c 4c 86 00 	mov.b	134(r12),r12	;0x00086

0000c1b8 <.Loc.183.1>:
  if (options & 0x02) { /* Timestamp */
    c1b8:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    c1bc:	04 24       	jz	$+10     	;abs 0xc1c6

0000c1be <.Loc.184.1>:
    if (options & 0x01) { /* P-field */
    c1be:	1c b3       	bit	#1,	r12	;r3 As==01
    c1c0:	05 20       	jnz	$+12     	;abs 0xc1cc

0000c1c2 <.Loc.190.1>:
      /* 5-byte Secondary Header + 6-byte Primary Header */
      return 5;
    }
    else { /* No P-field */
      /* 4-byte Secondary Header + 6-byte Primary Header */
      return 4;
    c1c2:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000c1c4 <.L70>:
    }
  }
  
  return 0;
}
    c1c4:	10 01       	reta			;

0000c1c6 <.L72>:
  return 0;
    c1c6:	4c 43       	clr.b	r12		;
    c1c8:	80 00 c4 c1 	mova	#49604,	r0	;0x0c1c4

0000c1cc <.L73>:
      return 5;
    c1cc:	7c 40 05 00 	mov.b	#5,	r12	;
    c1d0:	80 00 c4 c1 	mova	#49604,	r0	;0x0c1c4

0000c1d4 <elyNLSetDest>:

elysium_destinations_t elyNLSetDest(uint8_t * buffer) {
    c1d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c1d6 <.LCFI8>:
    c1d6:	2a 01 4a 07 	mova	&67402,	r10	;0x1074a

0000c1da <.Loc.199.1>:
  uint16_t apid;
  if (buffer[0] & 0x08) { /* Secondary Header flag - Timestamp */
    c1da:	40 18 fc b2 	bitx.b	#8,	0(r12)	;r2 As==11
    c1de:	00 00 
    c1e0:	1d 24       	jz	$+60     	;abs 0xc21c

0000c1e2 <.Loc.200.1>:
    if (bank0p[RegNLOptions] & 0x01) { /* P-field - SH 5 bytes */
    c1e2:	40 18 da b3 	bitx.b	#1,	134(r10);r3 As==01, 0x00086
    c1e6:	86 00 
    c1e8:	15 24       	jz	$+44     	;abs 0xc214

0000c1ea <.Loc.202.1>:
      /* PH 6 bytes, SH 5 bytes, EH 2 bytes */
      apid = ( ((buffer[13] << 8) & 0x07) | (buffer[14]) );
    c1ea:	5d 4c 0e 00 	mov.b	14(r12),r13	;0x0000e

0000c1ee <.L77>:
    /* PH 6 bytes, EH 2 bytes */
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
  }
  
  /* Set APID */
  buffer[0] = (apid >> 8);
    c1ee:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

0000c1f2 <.Loc.215.1>:
  buffer[1] = (apid & 0xFF);
    c1f2:	cc 4d 01 00 	mov.b	r13,	1(r12)	;

0000c1f6 <.Loc.220.1>:
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (apid == ground_apid) {
    c1f6:	5e 4a 83 00 	mov.b	131(r10),r14	;0x00083
    c1fa:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c1fe:	5a 4a 82 00 	mov.b	130(r10),r10	;0x00082
    c202:	0e da       	bis	r10,	r14	;
    c204:	0d 9e       	cmp	r14,	r13	;
    c206:	0e 24       	jz	$+30     	;abs 0xc224

0000c208 <.Loc.225.1>:
    return ELY_DEST_RF;
  }
  else {
    /* Remember to set it to TC mode */
    buffer[0] |= 0x10;
    c208:	fc 40 10 00 	mov.b	#16,	0(r12)	;#0x0010
    c20c:	00 00 

0000c20e <.Loc.226.1>:
    return ELY_DEST_UART;
    c20e:	4c 43       	clr.b	r12		;

0000c210 <.L78>:
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    c210:	0a 16       	popm.a	#1,	r10	;20-bit words
    c212:	10 01       	reta			;

0000c214 <.L76>:
      apid = ( ((buffer[12] << 8) & 0x07) | (buffer[13]) );
    c214:	5d 4c 0d 00 	mov.b	13(r12),r13	;0x0000d

0000c218 <.LVL68>:
    c218:	80 00 ee c1 	mova	#49646,	r0	;0x0c1ee

0000c21c <.L75>:
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
    c21c:	5d 4c 09 00 	mov.b	9(r12),	r13	;

0000c220 <.LVL70>:
    c220:	80 00 ee c1 	mova	#49646,	r0	;0x0c1ee

0000c224 <.L79>:
    return ELY_DEST_RF;
    c224:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c226 <.LVL72>:
    c226:	80 00 10 c2 	mova	#49680,	r0	;0x0c210

0000c22a <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    c22a:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    c22e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c232:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000c236 <.LVL74>:
    c236:	0c dd       	bis	r13,	r12	;
    c238:	3c 50 07 00 	add	#7,	r12	;
    c23c:	4c 0e       	rlam.a	#4,	r12	;
    c23e:	4c 0d       	rram.a	#4,	r12	;

0000c240 <.Loc.235.1>:
}
    c240:	10 01       	reta			;

0000c242 <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    c242:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c244 <.LCFI9>:
    c244:	b1 00 04 00 	suba	#4,	r1	;

0000c248 <.LCFI10>:
  if (buffer[0] & 0xE0) {
    c248:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    c24c:	00 00 
    c24e:	09 24       	jz	$+20     	;abs 0xc262

0000c250 <.Loc.135.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    c250:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000c254 <.L85>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    c254:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c258 <.LVL77>:
    return false;
    c258:	4c 43       	clr.b	r12		;

0000c25a <.L83>:
}
    c25a:	a1 00 04 00 	adda	#4,	r1	;
    c25e:	0a 16       	popm.a	#1,	r10	;20-bit words
    c260:	10 01       	reta			;

0000c262 <.L82>:
  _disable_interrupts();
    c262:	32 c2       	dint			
    c264:	03 43       	nop			

0000c266 <.Loc.348.2>:
  asm volatile("nop");
    c266:	03 43       	nop			

0000c268 <.LBE15>:
  chSysLock();
    c268:	71 0c 00 00 	mova	r12,	0(r1)	;
    c26c:	b0 13 54 45 	calla	#17748		;0x04554

0000c270 <.LVL79>:
  if ( elyNLGetLength(buffer) > 
    c270:	0c 01       	mova	@r1,	r12	;
    c272:	b0 13 2a c2 	calla	#49706		;0x0c22a

0000c276 <.LVL80>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    c276:	2a 01 4a 07 	mova	&67402,	r10	;0x1074a
    c27a:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    c27e:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c282:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    c286:	0e da       	bis	r10,	r14	;
    c288:	40 18 0e 4e 	movx.w	r14,	r14	;
    c28c:	8a 00 7c 45 	mova	#17788,	r10	;0x0457c

0000c290 <.Loc.141.1>:
  if ( elyNLGetLength(buffer) > 
    c290:	de 0c       	cmpa	r12,	r14	;
    c292:	09 2c       	jc	$+20     	;abs 0xc2a6

0000c294 <.Loc.143.1>:
    chSysUnlock();
    c294:	4a 13       	calla	r10		;

0000c296 <.LBB17>:
  asm volatile("nop");
    c296:	03 43       	nop			

0000c298 <.Loc.356.2>:
  _enable_interrupts();
    c298:	03 43       	nop			
    c29a:	32 d2       	eint			
    c29c:	03 43       	nop			

0000c29e <.LBE17>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    c29e:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    c2a2:	80 00 54 c2 	mova	#49748,	r0	;0x0c254

0000c2a6 <.L84>:
  chSysUnlock();
    c2a6:	4a 13       	calla	r10		;

0000c2a8 <.LBB19>:
  asm volatile("nop");
    c2a8:	03 43       	nop			

0000c2aa <.Loc.356.2>:
  _enable_interrupts();
    c2aa:	03 43       	nop			
    c2ac:	32 d2       	eint			
    c2ae:	03 43       	nop			

0000c2b0 <.LBE19>:
  return true;
    c2b0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c2b2:	80 00 5a c2 	mova	#49754,	r0	;0x0c25a

0000c2b6 <elyNLExtract>:

size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - get_sh_len() + 1;
}

uint8_t * elyNLExtract(uint8_t * buffer) {
    c2b6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c2b8 <.LCFI12>:
    c2b8:	ca 0c       	mova	r12,	r10	;

0000c2ba <.Loc.243.1>:
  /* 6-byte Primary Header */
  return buffer + get_sh_len() + 6;
    c2ba:	b0 13 b0 c1 	calla	#49584		;0x0c1b0

0000c2be <.LVL87>:
    c2be:	ac 00 06 00 	adda	#6,	r12	;

0000c2c2 <.Loc.244.1>:
}
    c2c2:	ec 0a       	adda	r10,	r12	;
    c2c4:	0a 16       	popm.a	#1,	r10	;20-bit words
    c2c6:	10 01       	reta			;

0000c2c8 <elyNLPack>:

uint8_t * elyNLPack(uint8_t * buffer) {
    c2c8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c2ca <.LCFI13>:
    c2ca:	08 14       	pushm.a	#1,	r8	;20-bit words

0000c2cc <.LCFI14>:
    c2cc:	06 14       	pushm.a	#1,	r6	;20-bit words

0000c2ce <.LCFI15>:
    c2ce:	c8 0c       	mova	r12,	r8	;

0000c2d0 <.Loc.248.1>:
  /* 6-byte Primary Header */
  uint8_t * result = buffer - get_sh_len() - 6;
    c2d0:	b0 13 b0 c1 	calla	#49584		;0x0c1b0

0000c2d4 <.LVL89>:
    c2d4:	80 1f 7a 40 	movx.a	#-6,	r10	;0xffffa
    c2d8:	fa ff 
    c2da:	fa 0c       	suba	r12,	r10	;
    c2dc:	ea 08       	adda	r8,	r10	;

0000c2de <.Loc.249.1>:
  uint16_t length = (buffer[1] + 4 + get_sh_len() - 1);
    c2de:	5d 48 01 00 	mov.b	1(r8),	r13	;
    c2e2:	3d 50 03 00 	add	#3,	r13	;
    c2e6:	40 18 0c 4c 	movx.w	r12,	r12	;
    c2ea:	0c 5d       	add	r13,	r12	;

0000c2ec <.LVL91>:
  result[4] = (length >> 8);
    c2ec:	0d 4c       	mov	r12,	r13	;
    c2ee:	5d 0f       	rrum	#4,	r13	;
    c2f0:	5d 0f       	rrum	#4,	r13	;
    c2f2:	ca 4d 04 00 	mov.b	r13,	4(r10)	;

0000c2f6 <.Loc.251.1>:
  result[5] = (length & 0xFF);
    c2f6:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

0000c2fa <.Loc.253.1>:
  
  result[2] = (packets_sent >> 8) | 0xC0;
    c2fa:	c0 18 1c 42 	movx.w	&0x10b16,r12	;
    c2fe:	16 0b 

0000c300 <.LVL92>:
    c300:	0d 4c       	mov	r12,	r13	;
    c302:	5d 0f       	rrum	#4,	r13	;
    c304:	5d 0f       	rrum	#4,	r13	;
    c306:	7d d0 c0 ff 	bis.b	#-64,	r13	;#0xffc0
    c30a:	ca 4d 02 00 	mov.b	r13,	2(r10)	;

0000c30e <.Loc.254.1>:
  result[3] = (packets_sent & 0xFF);
    c30e:	ca 4c 03 00 	mov.b	r12,	3(r10)	;

0000c312 <.Loc.255.1>:
  packets_sent = (packets_sent + 1) & 0x3FFF;
    c312:	1c 53       	inc	r12		;
    c314:	3c f0 ff 3f 	and	#16383,	r12	;#0x3fff
    c318:	41 18 82 4c 	movx.w	r12,	&0x10b16;
    c31c:	16 0b 

0000c31e <.Loc.258.1>:
  
  /* insert timestamps here too if required */
  uint8_t options = bank0p[RegNLOptions];
    c31e:	26 01 4a 07 	mova	&67402,	r6	;0x1074a
    c322:	5d 46 86 00 	mov.b	134(r6),r13	;0x00086

0000c326 <.LVL93>:
  if (options & 0x02) { /* Timestamp */
    c326:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    c32a:	1f 24       	jz	$+64     	;abs 0xc36a
    c32c:	8c 00 54 45 	mova	#17748,	r12	;0x04554
    c330:	88 00 7c 45 	mova	#17788,	r8	;0x0457c

0000c334 <.LVL94>:
    if (options & 0x01) { /* P-field */
    c334:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    c338:	1d 24       	jz	$+60     	;abs 0xc374

0000c33a <.Loc.261.1>:
      result[6] = SPP_PFIELD;
    c33a:	fa 40 2c 00 	mov.b	#44,	6(r10)	;#0x002c
    c33e:	06 00 

0000c340 <.LBB29>:
  _disable_interrupts();
    c340:	32 c2       	dint			
    c342:	03 43       	nop			

0000c344 <.Loc.348.2>:
  asm volatile("nop");
    c344:	03 43       	nop			

0000c346 <.LBE29>:
      chSysLock();
    c346:	4c 13       	calla	r12		;

0000c348 <.LVL96>:
      result[7] = bank0p[RegMissionTimeMsb];
    c348:	da 46 76 00 	mov.b	118(r6),7(r10)	;0x00076
    c34c:	07 00 

0000c34e <.Loc.264.1>:
      result[8] = bank0p[RegMissionTimeHmb];
    c34e:	da 46 75 00 	mov.b	117(r6),8(r10)	;0x00075
    c352:	08 00 

0000c354 <.Loc.265.1>:
      result[9] = bank0p[RegMissionTimeLmb];
    c354:	da 46 74 00 	mov.b	116(r6),9(r10)	;0x00074
    c358:	09 00 

0000c35a <.Loc.266.1>:
      result[10] = bank0p[RegMissionTimeLsb];
    c35a:	da 46 73 00 	mov.b	115(r6),10(r10)	;0x00073, 0x000a
    c35e:	0a 00 

0000c360 <.L94>:
      chSysLock();
      result[6] = bank0p[RegMissionTimeMsb];
      result[7] = bank0p[RegMissionTimeHmb];
      result[8] = bank0p[RegMissionTimeLmb];
      result[9] = bank0p[RegMissionTimeLsb];
      chSysUnlock();
    c360:	48 13       	calla	r8		;

0000c362 <.LBB31>:
  asm volatile("nop");
    c362:	03 43       	nop			

0000c364 <.Loc.356.2>:
  _enable_interrupts();
    c364:	03 43       	nop			
    c366:	32 d2       	eint			
    c368:	03 43       	nop			

0000c36a <.L88>:
    }
  }
  
  return result;
}
    c36a:	cc 0a       	mova	r10,	r12	;
    c36c:	06 16       	popm.a	#1,	r6	;20-bit words
    c36e:	08 16       	popm.a	#1,	r8	;20-bit words
    c370:	0a 16       	popm.a	#1,	r10	;20-bit words
    c372:	10 01       	reta			;

0000c374 <.L90>:
  _disable_interrupts();
    c374:	32 c2       	dint			
    c376:	03 43       	nop			

0000c378 <.Loc.348.2>:
  asm volatile("nop");
    c378:	03 43       	nop			

0000c37a <.LBE33>:
      chSysLock();
    c37a:	4c 13       	calla	r12		;

0000c37c <.LVL99>:
      result[6] = bank0p[RegMissionTimeMsb];
    c37c:	da 46 76 00 	mov.b	118(r6),6(r10)	;0x00076
    c380:	06 00 

0000c382 <.Loc.274.1>:
      result[7] = bank0p[RegMissionTimeHmb];
    c382:	da 46 75 00 	mov.b	117(r6),7(r10)	;0x00075
    c386:	07 00 

0000c388 <.Loc.275.1>:
      result[8] = bank0p[RegMissionTimeLmb];
    c388:	da 46 74 00 	mov.b	116(r6),8(r10)	;0x00074
    c38c:	08 00 

0000c38e <.Loc.276.1>:
      result[9] = bank0p[RegMissionTimeLsb];
    c38e:	da 46 73 00 	mov.b	115(r6),9(r10)	;0x00073
    c392:	09 00 
    c394:	80 00 60 c3 	mova	#50016,	r0	;0x0c360

0000c398 <elyErrorSignal>:
/* Errors */
static uint16_t PERSIST err_log_lvl;
static uint16_t PERSIST err_rpt_lvl;
static uint16_t PERSIST signalled_errors;
static inline eventmask_t mask_from_error(uint8_t error) {
  return (1 << (error & 0x3F));
    c398:	0d 4c       	mov	r12,	r13	;
    c39a:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c39e:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c3a0 <.LVL1>:
    c3a0:	b0 13 fe cc 	calla	#52478		;0x0ccfe

0000c3a4 <.LBE26>:
}

void elyErrorSignal(uint8_t error) {
  signalled_errors |= mask_from_error(error);
    c3a4:	40 18 82 dc 	bisx.w	r12,	&0xff412;
    c3a8:	12 f4 

0000c3aa <.Loc.40.1>:
}
    c3aa:	10 01       	reta			;

0000c3ac <elyErrorSetLogLvlS>:

void elyErrorSetLogLvlS(uint8_t lvl) {
  err_log_lvl = lvl;
}
    c3ac:	10 01       	reta			;

0000c3ae <elyErrorSetRptLvlS>:

void elyErrorSetRptLvlS(uint8_t lvl) {
  err_rpt_lvl = lvl;
}
    c3ae:	10 01       	reta			;

0000c3b0 <elyEventSignal>:
eventmask_t PERSIST logged_events;
eventmask_t PERSIST reported_events;
static eventmask_t PERSIST signalled_events;
size_t PERSIST event_resets = 0;
static inline eventmask_t mask_from_event(uint8_t event) {
  return (1 << (event & 0x3F));
    c3b0:	0d 4c       	mov	r12,	r13	;
    c3b2:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c3b6:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c3b8 <.LVL6>:
    c3b8:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c3bc:	0e 4c       	mov	r12,	r14	;
    c3be:	0f 4c       	mov	r12,	r15	;
    c3c0:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000c3c4 <.LBE28>:
}

void elyEventSignal(uint8_t event) {
  signalled_events |= mask_from_event(event);
    c3c4:	40 18 82 dc 	bisx.w	r12,	&0xff40e;
    c3c8:	0e f4 
    c3ca:	40 18 82 df 	bisx.w	r15,	&0xff410;
    c3ce:	10 f4 

0000c3d0 <.Loc.61.1>:
}
    c3d0:	10 01       	reta			;

0000c3d2 <elyEventSubscribe>:
  return (1 << (event & 0x3F));
    c3d2:	0d 4c       	mov	r12,	r13	;

0000c3d4 <.LVL9>:
    c3d4:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c3d8:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c3da <.LVL10>:
    c3da:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c3de:	0e 4c       	mov	r12,	r14	;
    c3e0:	0f 4c       	mov	r12,	r15	;
    c3e2:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000c3e6 <.LBE30>:

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(addr);
  reported_events |= mask_from_event(event);
    c3e6:	41 18 82 dc 	bisx.w	r12,	&0x11a54;
    c3ea:	54 1a 
    c3ec:	41 18 82 df 	bisx.w	r15,	&0x11a56;
    c3f0:	56 1a 

0000c3f2 <.Loc.66.1>:
}
    c3f2:	10 01       	reta			;

0000c3f4 <elyEventUnsubscribe>:
  return (1 << (event & 0x3F));
    c3f4:	0d 4c       	mov	r12,	r13	;
    c3f6:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c3fa:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c3fc <.LVL13>:
    c3fc:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c400:	0e 4c       	mov	r12,	r14	;
    c402:	0f 4c       	mov	r12,	r15	;
    c404:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000c408 <.LBE32>:

void elyEventUnsubscribe(uint8_t event) {
  reported_events &= ~mask_from_event(event);
    c408:	41 18 82 cc 	bicx.w	r12,	&0x11a54;
    c40c:	54 1a 
    c40e:	41 18 82 cf 	bicx.w	r15,	&0x11a56;
    c412:	56 1a 

0000c414 <.Loc.70.1>:
}
    c414:	10 01       	reta			;

0000c416 <elyEventLog>:
  return (1 << (event & 0x3F));
    c416:	0d 4c       	mov	r12,	r13	;
    c418:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c41c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c41e <.LVL16>:
    c41e:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c422:	0e 4c       	mov	r12,	r14	;
    c424:	0f 4c       	mov	r12,	r15	;
    c426:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000c42a <.LBE34>:

void elyEventLog(uint8_t event) {
  logged_events |= mask_from_event(event);
    c42a:	41 18 82 dc 	bisx.w	r12,	&0x11a58;
    c42e:	58 1a 
    c430:	41 18 82 df 	bisx.w	r15,	&0x11a5a;
    c434:	5a 1a 

0000c436 <.Loc.74.1>:
}
    c436:	10 01       	reta			;

0000c438 <elyEventUnlog>:
  return (1 << (event & 0x3F));
    c438:	0d 4c       	mov	r12,	r13	;
    c43a:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    c43e:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c440 <.LVL19>:
    c440:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c444:	0e 4c       	mov	r12,	r14	;
    c446:	0f 4c       	mov	r12,	r15	;
    c448:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000c44c <.LBE36>:

void elyEventUnlog(uint8_t event) {
  logged_events &= ~mask_from_event(event);
    c44c:	41 18 82 cc 	bicx.w	r12,	&0x11a58;
    c450:	58 1a 
    c452:	41 18 82 cf 	bicx.w	r15,	&0x11a5a;
    c456:	5a 1a 

0000c458 <.Loc.78.1>:
}
    c458:	10 01       	reta			;

0000c45a <elyEventReset>:

void elyEventReset() {
  logged_events = 0;
    c45a:	41 18 82 43 	movx.w	#0,	&0x11a58;r3 As==00
    c45e:	58 1a 
    c460:	41 18 82 43 	movx.w	#0,	&0x11a5a;r3 As==00
    c464:	5a 1a 

0000c466 <.Loc.82.1>:
  signalled_events = 0;
    c466:	40 18 82 43 	movx.w	#0,	&0xff40e;r3 As==00
    c46a:	0e f4 
    c46c:	40 18 82 43 	movx.w	#0,	&0xff410;r3 As==00
    c470:	10 f4 

0000c472 <.Loc.83.1>:
  reported_events = 0;
    c472:	41 18 82 43 	movx.w	#0,	&0x11a54;r3 As==00
    c476:	54 1a 
    c478:	41 18 82 43 	movx.w	#0,	&0x11a56;r3 As==00
    c47c:	56 1a 

0000c47e <.Loc.84.1>:
  event_resets++;
    c47e:	01 18 d2 53 	incx.a	&0x11a50		;
    c482:	50 1a 

0000c484 <.Loc.85.1>:
}
    c484:	10 01       	reta			;

0000c486 <elyChanSubscribe>:
static size_t PERSIST chan_resets = 0;
static inline eventmask_t mask_from_chan(uint8_t chan) {
  return (1UL << (chan & 0x3F));
}

void elyChanSubscribe(uint8_t * buffer, uint8_t length, uint32_t interval) {
    c486:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c488 <.LCFI0>:
    c488:	47 4d       	mov.b	r13,	r7	;

0000c48a <.LVL22>:
    c48a:	40 18 19 42 	movx.w	&0x0f40a,r9	;
    c48e:	0a f4 
    c490:	40 18 1a 42 	movx.w	&0x0f40c,r10	;
    c494:	0c f4 
    c496:	c6 0c       	mova	r12,	r6	;

0000c498 <.LBB38>:
  (void)(interval);
  for (int i = 0; i < length; i++) {
    c498:	4c 43       	clr.b	r12		;

0000c49a <.LVL23>:
    c49a:	08 4c       	mov	r12,	r8	;
    c49c:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c49e <.L12>:
    c49e:	08 97       	cmp	r7,	r8	;
    c4a0:	0a 38       	jl	$+22     	;abs 0xc4b6
    c4a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    c4a4:	06 24       	jz	$+14     	;abs 0xc4b2
    c4a6:	40 18 82 49 	movx.w	r9,	&0xff40a;
    c4aa:	0a f4 
    c4ac:	40 18 82 4a 	movx.w	r10,	&0xff40c;
    c4b0:	0c f4 

0000c4b2 <.L11>:
    subscribed_channels |= mask_from_chan(buffer[i]);
  }
}
    c4b2:	55 16       	popm.a	#6,	r10	;20-bit words
    c4b4:	10 01       	reta			;

0000c4b6 <.L13>:
  return (1UL << (chan & 0x3F));
    c4b6:	6e 46       	mov.b	@r6,	r14	;
    c4b8:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c4bc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c4be:	4d 43       	clr.b	r13		;
    c4c0:	0f 43       	clr	r15		;
    c4c2:	b0 13 48 cd 	calla	#52552		;0x0cd48

0000c4c6 <.LBE39>:
    subscribed_channels |= mask_from_chan(buffer[i]);
    c4c6:	09 dc       	bis	r12,	r9	;
    c4c8:	0a dd       	bis	r13,	r10	;

0000c4ca <.Loc.97.1>:
  for (int i = 0; i < length; i++) {
    c4ca:	18 53       	inc	r8		;
    c4cc:	a6 00 01 00 	adda	#1,	r6	;
    c4d0:	0c 45       	mov	r5,	r12	;
    c4d2:	80 00 9e c4 	mova	#50334,	r0	;0x0c49e

0000c4d6 <elyChanUnsubscribe>:

void elyChanUnsubscribe(uint8_t * buffer, uint8_t length) {
    c4d6:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c4d8 <.LCFI1>:
    c4d8:	47 4d       	mov.b	r13,	r7	;

0000c4da <.LVL28>:
    c4da:	40 18 19 42 	movx.w	&0x0f40a,r9	;
    c4de:	0a f4 
    c4e0:	40 18 1a 42 	movx.w	&0x0f40c,r10	;
    c4e4:	0c f4 
    c4e6:	c6 0c       	mova	r12,	r6	;

0000c4e8 <.LBB42>:
  for (int i = 0; i < length; i++) {
    c4e8:	4c 43       	clr.b	r12		;

0000c4ea <.LVL29>:
    c4ea:	08 4c       	mov	r12,	r8	;
    c4ec:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c4ee <.L19>:
    c4ee:	08 97       	cmp	r7,	r8	;
    c4f0:	0a 38       	jl	$+22     	;abs 0xc506
    c4f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    c4f4:	06 24       	jz	$+14     	;abs 0xc502
    c4f6:	40 18 82 49 	movx.w	r9,	&0xff40a;
    c4fa:	0a f4 
    c4fc:	40 18 82 4a 	movx.w	r10,	&0xff40c;
    c500:	0c f4 

0000c502 <.L18>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
  }
}
    c502:	55 16       	popm.a	#6,	r10	;20-bit words
    c504:	10 01       	reta			;

0000c506 <.L20>:
  return (1UL << (chan & 0x3F));
    c506:	6e 46       	mov.b	@r6,	r14	;
    c508:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c50c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c50e:	4d 43       	clr.b	r13		;
    c510:	0f 43       	clr	r15		;
    c512:	b0 13 48 cd 	calla	#52552		;0x0cd48

0000c516 <.LBE43>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
    c516:	09 cc       	bic	r12,	r9	;
    c518:	0a cd       	bic	r13,	r10	;

0000c51a <.Loc.103.1>:
  for (int i = 0; i < length; i++) {
    c51a:	18 53       	inc	r8		;
    c51c:	a6 00 01 00 	adda	#1,	r6	;
    c520:	0c 45       	mov	r5,	r12	;
    c522:	80 00 ee c4 	mova	#50414,	r0	;0x0c4ee

0000c526 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
    c526:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c528 <.LCFI2>:
    c528:	47 4d       	mov.b	r13,	r7	;

0000c52a <.LVL34>:
    c52a:	40 18 19 42 	movx.w	&0x0f406,r9	;
    c52e:	06 f4 
    c530:	40 18 1a 42 	movx.w	&0x0f408,r10	;
    c534:	08 f4 
    c536:	c6 0c       	mova	r12,	r6	;

0000c538 <.LBB46>:
  (void)(interval);
  for (int i = 0; i < length; i++) {
    c538:	4c 43       	clr.b	r12		;

0000c53a <.LVL35>:
    c53a:	08 4c       	mov	r12,	r8	;
    c53c:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c53e <.L26>:
    c53e:	08 97       	cmp	r7,	r8	;
    c540:	0a 38       	jl	$+22     	;abs 0xc556
    c542:	0c 93       	cmp	#0,	r12	;r3 As==00
    c544:	06 24       	jz	$+14     	;abs 0xc552
    c546:	40 18 82 49 	movx.w	r9,	&0xff406;
    c54a:	06 f4 
    c54c:	40 18 82 4a 	movx.w	r10,	&0xff408;
    c550:	08 f4 

0000c552 <.L25>:
    logged_channels |= mask_from_chan(buffer[i]);
  }
}
    c552:	55 16       	popm.a	#6,	r10	;20-bit words
    c554:	10 01       	reta			;

0000c556 <.L27>:
  return (1UL << (chan & 0x3F));
    c556:	6e 46       	mov.b	@r6,	r14	;
    c558:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c55c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c55e:	4d 43       	clr.b	r13		;
    c560:	0f 43       	clr	r15		;
    c562:	b0 13 48 cd 	calla	#52552		;0x0cd48

0000c566 <.LBE47>:
    logged_channels |= mask_from_chan(buffer[i]);
    c566:	09 dc       	bis	r12,	r9	;
    c568:	0a dd       	bis	r13,	r10	;

0000c56a <.Loc.110.1>:
  for (int i = 0; i < length; i++) {
    c56a:	18 53       	inc	r8		;
    c56c:	a6 00 01 00 	adda	#1,	r6	;
    c570:	0c 45       	mov	r5,	r12	;
    c572:	80 00 3e c5 	mova	#50494,	r0	;0x0c53e

0000c576 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
    c576:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c578 <.LCFI3>:
    c578:	47 4d       	mov.b	r13,	r7	;

0000c57a <.LVL40>:
    c57a:	40 18 19 42 	movx.w	&0x0f406,r9	;
    c57e:	06 f4 
    c580:	40 18 1a 42 	movx.w	&0x0f408,r10	;
    c584:	08 f4 
    c586:	c6 0c       	mova	r12,	r6	;

0000c588 <.LBB50>:
  for (int i = 0; i < length; i++) {
    c588:	4c 43       	clr.b	r12		;

0000c58a <.LVL41>:
    c58a:	08 4c       	mov	r12,	r8	;
    c58c:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c58e <.L33>:
    c58e:	08 97       	cmp	r7,	r8	;
    c590:	0a 38       	jl	$+22     	;abs 0xc5a6
    c592:	0c 93       	cmp	#0,	r12	;r3 As==00
    c594:	06 24       	jz	$+14     	;abs 0xc5a2
    c596:	40 18 82 49 	movx.w	r9,	&0xff406;
    c59a:	06 f4 
    c59c:	40 18 82 4a 	movx.w	r10,	&0xff408;
    c5a0:	08 f4 

0000c5a2 <.L32>:
    logged_channels &= ~mask_from_chan(buffer[i]);
  }
}
    c5a2:	55 16       	popm.a	#6,	r10	;20-bit words
    c5a4:	10 01       	reta			;

0000c5a6 <.L34>:
  return (1UL << (chan & 0x3F));
    c5a6:	6e 46       	mov.b	@r6,	r14	;
    c5a8:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c5ac:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c5ae:	4d 43       	clr.b	r13		;
    c5b0:	0f 43       	clr	r15		;
    c5b2:	b0 13 48 cd 	calla	#52552		;0x0cd48

0000c5b6 <.LBE51>:
    logged_channels &= ~mask_from_chan(buffer[i]);
    c5b6:	09 cc       	bic	r12,	r9	;
    c5b8:	0a cd       	bic	r13,	r10	;

0000c5ba <.Loc.116.1>:
  for (int i = 0; i < length; i++) {
    c5ba:	18 53       	inc	r8		;
    c5bc:	a6 00 01 00 	adda	#1,	r6	;
    c5c0:	0c 45       	mov	r5,	r12	;
    c5c2:	80 00 8e c5 	mova	#50574,	r0	;0x0c58e

0000c5c6 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer) {
  buffer[1] = 0;
    c5c6:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

0000c5ca <.Loc.124.1>:
  return 1;
}
    c5ca:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c5cc <.LVL46>:
    c5cc:	10 01       	reta			;

0000c5ce <elyChanReset>:

void elyChanReset() {
  logged_channels = 0;
    c5ce:	40 18 82 43 	movx.w	#0,	&0xff406;r3 As==00
    c5d2:	06 f4 
    c5d4:	40 18 82 43 	movx.w	#0,	&0xff408;r3 As==00
    c5d8:	08 f4 

0000c5da <.Loc.128.1>:
  subscribed_channels = 0;
    c5da:	40 18 82 43 	movx.w	#0,	&0xff40a;r3 As==00
    c5de:	0a f4 
    c5e0:	40 18 82 43 	movx.w	#0,	&0xff40c;r3 As==00
    c5e4:	0c f4 

0000c5e6 <.Loc.129.1>:
  chan_resets++;
    c5e6:	00 18 d2 53 	incx.a	&0xf402		;
    c5ea:	02 f4 

0000c5ec <.Loc.130.1>:
}
    c5ec:	10 01       	reta			;

0000c5ee <elyTelemPostBufferS>:
static PERSIST size_t last_n; 
static PERSIST telem_cfg_t telem_cfg;
void elyTelemPostBufferS(uint8_t * buffer, size_t n, telemcallback_t cb) {
  last_buffer = buffer;
  last_n = n;
  cb(buffer);
    c5ee:	4e 13       	calla	r14		;

0000c5f0 <.LVL48>:
}
    c5f0:	10 01       	reta			;

0000c5f2 <elyTelemUpdateConfigS>:

void elyTelemUpdateConfigS(telem_cfg_t config) {
  chDbgCheckClassS();
    c5f2:	b0 13 78 46 	calla	#18040		;0x04678

0000c5f6 <.LVL49>:
  telem_cfg = config;
}
    c5f6:	10 01       	reta			;

0000c5f8 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    c5f8:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    c5fc:	80 5a 5c 01 

0000c600 <.Loc.172.1>:

  halInit();
    c600:	b0 13 00 50 	calla	#20480		;0x05000

0000c604 <.LVL50>:
  chSysInit();
    c604:	b0 13 9c 46 	calla	#18076		;0x0469c

0000c608 <.L44>:
    c608:	80 00 08 c6 	mova	#50696,	r0	;0x0c608

0000c60c <rxfifothresh_callback>:
  chSysUnlock();
  
}

void rxfifothresh_callback(void) {
  chSysLockFromISR();
    c60c:	b0 13 a6 45 	calla	#17830		;0x045a6

0000c610 <.LVL0>:
  chEvtSignalI(rf_thd, RFRxFifoThresh);
    c610:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    c614:	4e 43       	clr.b	r14		;
    c616:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c61a:	b0 13 90 4b 	calla	#19344		;0x04b90

0000c61e <.LVL1>:
  chSysUnlockFromISR();
    c61e:	b0 13 d0 45 	calla	#17872		;0x045d0

0000c622 <.LVL2>:
}
    c622:	10 01       	reta			;

0000c624 <txlvl_callback>:
  }
  
}

void txlvl_callback(void) {
  chSysLockFromISR();
    c624:	b0 13 a6 45 	calla	#17830		;0x045a6

0000c628 <.LVL3>:
  chEvtSignalI(rf_thd, RFTxFifoLevel);
    c628:	3d 40 00 80 	mov	#-32768,r13	;#0x8000
    c62c:	4e 43       	clr.b	r14		;
    c62e:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c632:	b0 13 90 4b 	calla	#19344		;0x04b90

0000c636 <.LVL4>:
  chSysUnlockFromISR();
    c636:	b0 13 d0 45 	calla	#17872		;0x045d0

0000c63a <.LVL5>:
}
    c63a:	10 01       	reta			;

0000c63c <write_cb>:

void write_cb(SPIDriver * spip) {
    c63c:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c63e <.LCFI0>:
  (void)(spip);
  chSysLockFromISR();
    c63e:	b0 13 a6 45 	calla	#17830		;0x045a6

0000c642 <.LVL7>:
  palSetLine(SX1278D1.config->ss_line);
    c642:	2c 01 1e 15 	mova	&70942,	r12	;0x1151e
    c646:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    c64a:	ca 0c       	mova	r12,	r10	;
    c64c:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    c650:	ff 0f 
    c652:	19 4a 02 00 	mov	2(r10),	r9	;
    c656:	0c 14       	pushm.a	#1,	r12	;20-bit words
    c658:	40 18 3c 41 	popx.w	r12		;
    c65c:	40 18 3d 41 	popx.w	r13		;
    c660:	b0 13 1e ce 	calla	#52766		;0x0ce1e
    c664:	0d 12       	push	r13		;
    c666:	0c 12       	push	r12		;
    c668:	0c 16       	popm.a	#1,	r12	;20-bit words
    c66a:	40 18 0d 4c 	movx.w	r12,	r13	;
    c66e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c670:	b0 13 fe cc 	calla	#52478		;0x0ccfe
    c674:	0c d9       	bis	r9,	r12	;
    c676:	8a 4c 02 00 	mov	r12,	2(r10)	;
    c67a:	8a 00 90 4b 	mova	#19344,	r10	;0x04b90

0000c67e <.Loc.381.1>:
  if (tf_idx == tf_len) {
    c67e:	c0 18 92 92 	cmpx.w	&0x10b1e,&0xff420;
    c682:	1e 0b 20 f4 
    c686:	16 20       	jnz	$+46     	;abs 0xc6b4

0000c688 <.Loc.386.1>:
    /* TODO in this function, check for another available packet or frame and
     * if none exists, go to sleep mode */
    /* Done transmitting. Do the stuff */
#if ELY_DISCRETE_PA_CTL
    palClearLine(LINE_PA_PC_EN);
    c688:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    c68c:	ff ef 22 02 

0000c690 <.Loc.388.1>:
#endif
    palLineDisableEventI(LINE_SX1278_DIO1);
    c690:	6d 43       	mov.b	#2,	r13	;r3 As==10
    c692:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    c696:	b0 13 e6 55 	calla	#21990		;0x055e6

0000c69a <.LVL10>:
    
    chEvtSignalI(rf_thd, RFSpiAvailable | RFTxIdle);
    c69a:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c69e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c6a0:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c6a4:	4a 13       	calla	r10		;

0000c6a6 <.LVL11>:
    tf_idx = 0;
    c6a6:	40 18 82 43 	movx.w	#0,	&0xff420;r3 As==00
    c6aa:	20 f4 

0000c6ac <.L5>:
  }
  else {
    chEvtSignalI(rf_thd, RFSpiAvailable);
  }
  chSysUnlockFromISR();
    c6ac:	b0 13 d0 45 	calla	#17872		;0x045d0

0000c6b0 <.LVL12>:
}
    c6b0:	19 16       	popm.a	#2,	r10	;20-bit words
    c6b2:	10 01       	reta			;

0000c6b4 <.L4>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    c6b4:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c6b8:	4e 43       	clr.b	r14		;
    c6ba:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c6be:	4a 13       	calla	r10		;

0000c6c0 <.LVL13>:
    c6c0:	80 00 ac c6 	mova	#50860,	r0	;0x0c6ac

0000c6c4 <elyRFChangeTxSyncS>:
void elyRFChangeTxSyncS(SX1278Config * cfg) {
    c6c4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c6c6 <.LCFI1>:
    c6c6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000c6c8 <.LCFI2>:
    c6c8:	c8 0c       	mova	r12,	r8	;

0000c6ca <.Loc.68.1>:
  chDbgCheckClassS();
    c6ca:	b0 13 78 46 	calla	#18040		;0x04678

0000c6ce <.LVL15>:
  if (!(bank0p[RegDLLOptions] & BIT2)) { /* Compliant ASM */
    c6ce:	2a 01 4a 07 	mova	&67402,	r10	;0x1074a
    c6d2:	ea b2 c4 00 	bit.b	#4,	196(r10);r2 As==10, 0x00c4
    c6d6:	16 20       	jnz	$+46     	;abs 0xc704

0000c6d8 <.Loc.73.1>:
                  ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    c6d8:	5d 4a 11 00 	mov.b	17(r10),r13	;0x00011
    c6dc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c6e0:	5c 4a 10 00 	mov.b	16(r10),r12	;0x00010
    c6e4:	0d dc       	bis	r12,	r13	;
    c6e6:	5e 4a 13 00 	mov.b	19(r10),r14	;0x00013
    c6ea:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c6ee:	5a 4a 12 00 	mov.b	18(r10),r10	;0x00012
    c6f2:	0e da       	bis	r10,	r14	;

0000c6f4 <.Loc.71.1>:
    cfg->sync_word = ( (bank0p[RegTXSyncLsb]) |
    c6f4:	88 4d 18 00 	mov	r13,	24(r8)	; 0x0018
    c6f8:	88 4e 1a 00 	mov	r14,	26(r8)	; 0x001a

0000c6fc <.Loc.76.1>:
    sx1278SetSync(&SX1278D1, cfg->sync_word);
    c6fc:	8c 01 1e 15 	mova	#70942,	r12	;0x1151e
    c700:	b0 13 f0 69 	calla	#27120		;0x069f0

0000c704 <.L6>:
}
    c704:	08 16       	popm.a	#1,	r8	;20-bit words
    c706:	0a 16       	popm.a	#1,	r10	;20-bit words
    c708:	10 01       	reta			;

0000c70a <elyDLLClampReg>:
uint8_t elyDLLClampReg(uint8_t addr, uint8_t value) {
    c70a:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c70c <.LCFI3>:
    c70c:	49 4c       	mov.b	r12,	r9	;
    c70e:	4a 4d       	mov.b	r13,	r10	;

0000c710 <.Loc.110.1>:
  chDbgAssert(addr >= 0xC0 && addr < RegDLLMAX, "invalid address");
    c710:	4c 49       	mov.b	r9,	r12	;

0000c712 <.LVL18>:
    c712:	7c 50 40 00 	add.b	#64,	r12	;#0x0040
    c716:	7d 40 14 00 	mov.b	#20,	r13	;#0x0014

0000c71a <.LVL19>:
    c71a:	4d 9c       	cmp.b	r12,	r13	;
    c71c:	04 2c       	jc	$+10     	;abs 0xc726

0000c71e <.Loc.110.1>:
    c71e:	8c 01 9d 08 	mova	#67741,	r12	;0x1089d
    c722:	b0 13 dc 47 	calla	#18396		;0x047dc

0000c726 <.L9>:
  switch (addr) {
    c726:	79 90 c3 ff 	cmp.b	#-61,	r9	;#0xffc3
    c72a:	57 24       	jz	$+176    	;abs 0xc7da
    c72c:	7d 40 c3 ff 	mov.b	#-61,	r13	;#0xffc3
    c730:	4d 99       	cmp.b	r9,	r13	;
    c732:	0d 28       	jnc	$+28     	;abs 0xc74e
    c734:	79 90 c1 ff 	cmp.b	#-63,	r9	;#0xffc1
    c738:	30 24       	jz	$+98     	;abs 0xc79a
    c73a:	7d 40 c1 ff 	mov.b	#-63,	r13	;#0xffc1
    c73e:	4d 99       	cmp.b	r9,	r13	;
    c740:	38 28       	jnc	$+114    	;abs 0xc7b2
    c742:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    c746:	1d 24       	jz	$+60     	;abs 0xc782

0000c748 <.L10>:
}
    c748:	4c 4a       	mov.b	r10,	r12	;
    c74a:	19 16       	popm.a	#2,	r10	;20-bit words
    c74c:	10 01       	reta			;

0000c74e <.L12>:
  switch (addr) {
    c74e:	79 90 c7 ff 	cmp.b	#-57,	r9	;#0xffc7
    c752:	49 24       	jz	$+148    	;abs 0xc7e6
    c754:	79 90 c7 ff 	cmp.b	#-57,	r9	;#0xffc7
    c758:	f7 2b       	jnc	$-16     	;abs 0xc748
    c75a:	79 50 35 00 	add.b	#53,	r9	;#0x0035
    c75e:	7c 42       	mov.b	#8,	r12	;r2 As==11
    c760:	4c 99       	cmp.b	r9,	r12	;
    c762:	f2 2b       	jnc	$-26     	;abs 0xc748

0000c764 <.LBB31>:
  if ((value & 0x10) && value != 0x10) {
    c764:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    c768:	10 00 
    c76a:	41 24       	jz	$+132    	;abs 0xc7ee
    c76c:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    c770:	3e 24       	jz	$+126    	;abs 0xc7ee

0000c772 <.Loc.83.1>:
    elyErrorSignal(ErrRegClip);
    c772:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c776:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c77a <.LVL24>:
    return 0x10;
    c77a:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

0000c77e <.LVL25>:
    c77e:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c782 <.L15>:
  if (value < min) {
    c782:	7d 40 06 00 	mov.b	#6,	r13	;
    c786:	4d 9a       	cmp.b	r10,	r13	;
    c788:	df 2b       	jnc	$-64     	;abs 0xc748

0000c78a <.LVL27>:
    elyErrorSignal(ErrRegClip);
    c78a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c78e:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c792 <.LVL28>:
    value = min;
    c792:	7a 40 07 00 	mov.b	#7,	r10	;
    c796:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c79a <.L13>:
  else if (value > max) {
    c79a:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    c79e:	4c 9a       	cmp.b	r10,	r12	;
    c7a0:	d3 2f       	jc	$-88     	;abs 0xc748

0000c7a2 <.LVL30>:
    elyErrorSignal(ErrRegClip);
    c7a2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c7a6:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c7aa <.LVL31>:
    value = max;
    c7aa:	7a 40 40 00 	mov.b	#64,	r10	;#0x0040
    c7ae:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c7b2 <.L14>:
      if ((value & 0x38) == 0x38) {
    c7b2:	4c 4a       	mov.b	r10,	r12	;
    c7b4:	7c f0 38 00 	and.b	#56,	r12	;#0x0038
    c7b8:	7c 90 38 00 	cmp.b	#56,	r12	;#0x0038
    c7bc:	02 20       	jnz	$+6      	;abs 0xc7c2

0000c7be <.Loc.120.1>:
        value &= ~BIT3;
    c7be:	7a f0 f7 00 	and.b	#247,	r10	;#0x00f7

0000c7c2 <.L18>:
      if ((value & 0x07) > 5) {
    c7c2:	4c 4a       	mov.b	r10,	r12	;
    c7c4:	7c f0 07 00 	and.b	#7,	r12	;
    c7c8:	7d 40 05 00 	mov.b	#5,	r13	;
    c7cc:	4d 9c       	cmp.b	r12,	r13	;
    c7ce:	bc 2f       	jc	$-134    	;abs 0xc748

0000c7d0 <.LVL34>:
        value |= BIT0;
    c7d0:	7a f0 fc 00 	and.b	#252,	r10	;#0x00fc

0000c7d4 <.LVL35>:
    c7d4:	1a d3       	bis	#1,	r10	;r3 As==01

0000c7d6 <.LVL36>:
    c7d6:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c7da <.L11>:
      if ((value & 0x03) == 0x03) {
    c7da:	4c 4a       	mov.b	r10,	r12	;
    c7dc:	7c f0 03 00 	and.b	#3,	r12	;
    c7e0:	7c 90 03 00 	cmp.b	#3,	r12	;
    c7e4:	b1 23       	jnz	$-156    	;abs 0xc748

0000c7e6 <.L16>:
      value &= ~BIT0;
    c7e6:	7a f0 fe 00 	and.b	#254,	r10	;#0x00fe

0000c7ea <.LVL38>:
      break;
    c7ea:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c7ee <.L19>:
  if ((value & 0x08) && value != 0x08) {
    c7ee:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    c7f2:	09 24       	jz	$+20     	;abs 0xc806
    c7f4:	3a 92       	cmp	#8,	r10	;r2 As==11
    c7f6:	07 24       	jz	$+16     	;abs 0xc806

0000c7f8 <.Loc.87.1>:
    elyErrorSignal(ErrRegClip);
    c7f8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c7fc:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c800 <.LVL40>:
    return 0x08;
    c800:	7a 42       	mov.b	#8,	r10	;r2 As==11
    c802:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c806 <.L20>:
  if ((value & 0x04) && value != 0x04) {
    c806:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    c80a:	09 24       	jz	$+20     	;abs 0xc81e
    c80c:	2a 92       	cmp	#4,	r10	;r2 As==10
    c80e:	07 24       	jz	$+16     	;abs 0xc81e

0000c810 <.Loc.91.1>:
    elyErrorSignal(ErrRegClip);
    c810:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c814:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c818 <.LVL42>:
    return 0x04;
    c818:	6a 42       	mov.b	#4,	r10	;r2 As==10
    c81a:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c81e <.L21>:
  if ((value & 0x02) && value != 0x02) {
    c81e:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    c822:	09 24       	jz	$+20     	;abs 0xc836
    c824:	2a 93       	cmp	#2,	r10	;r3 As==10
    c826:	07 24       	jz	$+16     	;abs 0xc836

0000c828 <.Loc.95.1>:
    elyErrorSignal(ErrRegClip);
    c828:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c82c:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c830 <.LVL44>:
    return 0x02;
    c830:	6a 43       	mov.b	#2,	r10	;r3 As==10
    c832:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c836 <.L22>:
  if ((value & 0x01) && value != 0x01) {
    c836:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    c83a:	09 24       	jz	$+20     	;abs 0xc84e
    c83c:	1a 93       	cmp	#1,	r10	;r3 As==01
    c83e:	07 24       	jz	$+16     	;abs 0xc84e

0000c840 <.Loc.99.1>:
    elyErrorSignal(ErrRegClip);
    c840:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c844:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c848 <.LVL46>:
    return 0x01;
    c848:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c84a:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c84e <.L23>:
  if (value & 0xD0) {
    c84e:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    c852:	7a 27       	jz	$-266    	;abs 0xc748

0000c854 <.Loc.103.1>:
    elyErrorSignal(ErrRegClip);
    c854:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c858:	b0 13 98 c3 	calla	#50072		;0x0c398

0000c85c <.LVL48>:
    return 0x00;
    c85c:	4a 43       	clr.b	r10		;
    c85e:	80 00 48 c7 	mova	#51016,	r0	;0x0c748

0000c862 <elyRFDLLBuildFrame>:
void elyRFDLLBuildFrame(void) {
    c862:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c864 <.LCFI4>:
    c864:	08 14       	pushm.a	#1,	r8	;20-bit words

0000c866 <.LCFI5>:
    c866:	06 14       	pushm.a	#1,	r6	;20-bit words

0000c868 <.LCFI6>:
    c868:	b1 00 04 00 	suba	#4,	r1	;

0000c86c <.LCFI7>:
  tf_buffer[0] |= (bank0p[RegDLLIDsMSB] & 0x03);
    c86c:	26 01 4a 07 	mova	&67402,	r6	;0x1074a
    c870:	5c 46 ca 00 	mov.b	202(r6),r12	;0x000ca
    c874:	40 18 8c 11 	sxtx.w	r12		;
    c878:	8a 01 20 0b 	mova	#68384,	r10	;0x10b20
    c87c:	4d 4c       	mov.b	r12,	r13	;
    c87e:	7d f0 03 00 	and.b	#3,	r13	;
    c882:	ca dd 00 00 	bis.b	r13,	0(r10)	;

0000c886 <.Loc.162.1>:
  tf_buffer[1] = bank0p[RegDLLIDsLSB];
    c886:	da 46 c9 00 	mov.b	201(r6),1(r10)	;0x000c9
    c88a:	01 00 

0000c88c <.Loc.164.1>:
  tf_buffer[2] |= (bank0p[RegDLLIDsMSB] & 0xFC);
    c88c:	7c f0 fc ff 	and.b	#-4,	r12	;#0xfffc
    c890:	ca dc 02 00 	bis.b	r12,	2(r10)	;

0000c894 <.Loc.166.1>:
  tf_buffer[4] = mcfc;
    c894:	40 18 5c 42 	movx.b	&0x0f41f,r12	;
    c898:	1f f4 
    c89a:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

0000c89e <.Loc.168.1>:
  mcfc++;
    c89e:	5c 53       	inc.b	r12		;
    c8a0:	40 18 c2 4c 	movx.b	r12,	&0xff41f;
    c8a4:	1f f4 

0000c8a6 <.Loc.172.1>:
  if (MSG_OK != chMBFetch(&rf_mbox, (msg_t *)(&active_packet), 
    c8a6:	3e 43       	mov	#-1,	r14	;r3 As==11
    c8a8:	cd 01       	mova	r1,	r13	;
    c8aa:	8c 01 82 0a 	mova	#68226,	r12	;0x10a82
    c8ae:	b0 13 a2 4d 	calla	#19874		;0x04da2

0000c8b2 <.LVL49>:
    c8b2:	9c 00 00 00 	cmpa	#0,	r12	;
    c8b6:	04 24       	jz	$+10     	;abs 0xc8c0

0000c8b8 <.Loc.175.1>:
    chDbgAssert(false, "should have a packet available");
    c8b8:	8c 01 8a 08 	mova	#67722,	r12	;0x1088a
    c8bc:	b0 13 dc 47 	calla	#18396		;0x047dc

0000c8c0 <.L59>:
  pkt_len = elyNLGetLength(active_packet);
    c8c0:	0c 01       	mova	@r1,	r12	;
    c8c2:	b0 13 2a c2 	calla	#49706		;0x0c22a

0000c8c6 <.LVL51>:
    c8c6:	c8 0c       	mova	r12,	r8	;

0000c8c8 <.LVL52>:
  tf_len = pkt_len + SDLP_TC_PH_LEN; 
    c8c8:	40 18 0c 4c 	movx.w	r12,	r12	;
    c8cc:	0d 4c       	mov	r12,	r13	;
    c8ce:	3d 50 05 00 	add	#5,	r13	;
    c8d2:	41 18 82 4d 	movx.w	r13,	&0x10b1e;
    c8d6:	1e 0b 

0000c8d8 <.Loc.180.1>:
  if (bank0p[RegDLLTCFEC] & BIT7) {
    c8d8:	c6 93 c3 00 	cmp.b	#0,	195(r6)	;r3 As==00, 0x00c3
    c8dc:	05 34       	jge	$+12     	;abs 0xc8e8

0000c8de <.Loc.181.1>:
    tf_len += 2;
    c8de:	3c 50 07 00 	add	#7,	r12	;
    c8e2:	41 18 82 4c 	movx.w	r12,	&0x10b1e;
    c8e6:	1e 0b 

0000c8e8 <.L60>:
  chDbgAssert(tf_len <= 1024, "packet too long");
    c8e8:	3c 40 00 04 	mov	#1024,	r12	;#0x0400
    c8ec:	c0 18 1c 92 	cmpx.w	&0x10b1e,r12	;
    c8f0:	1e 0b 
    c8f2:	04 2c       	jc	$+10     	;abs 0xc8fc

0000c8f4 <.Loc.183.1>:
    c8f4:	8c 01 8a 08 	mova	#67722,	r12	;0x1088a
    c8f8:	b0 13 dc 47 	calla	#18396		;0x047dc

0000c8fc <.L61>:
  tf_buffer[2] |= ((tf_len - 1) >> 8);
    c8fc:	c0 18 1d 42 	movx.w	&0x10b1e,r13	;
    c900:	1e 0b 
    c902:	0c 4d       	mov	r13,	r12	;
    c904:	3c 53       	add	#-1,	r12	;r3 As==11
    c906:	5c 0f       	rrum	#4,	r12	;
    c908:	5c 0f       	rrum	#4,	r12	;
    c90a:	ca dc 02 00 	bis.b	r12,	2(r10)	;

0000c90e <.Loc.185.1>:
  tf_buffer[3] = ((tf_len - 1) & 0xFF);
    c90e:	7d 53       	add.b	#-1,	r13	;r3 As==11
    c910:	ca 4d 03 00 	mov.b	r13,	3(r10)	;

0000c914 <.LBB46>:
    tf_buffer[i+SDLP_TC_PH_LEN] = active_packet[i];
    c914:	0c 01       	mova	@r1,	r12	;
    c916:	ce 0c       	mova	r12,	r14	;
    c918:	8a 01 25 0b 	mova	#68389,	r10	;0x10b25
    c91c:	e8 0c       	adda	r12,	r8	;

0000c91e <.L62>:
  for (size_t i = 0; i < pkt_len; i++) {
    c91e:	d8 0e       	cmpa	r14,	r8	;
    c920:	32 20       	jnz	$+102    	;abs 0xc986

0000c922 <.LBE46>:
  elyNLFreeBuffer(active_packet);
    c922:	b0 13 42 c1 	calla	#49474		;0x0c142

0000c926 <.LVL56>:
  if (bank0p[RegDLLTCFEC] & BIT7) {
    c926:	c6 93 c3 00 	cmp.b	#0,	195(r6)	;r3 As==00, 0x00c3
    c92a:	07 34       	jge	$+16     	;abs 0xc93a

0000c92c <.Loc.199.1>:
    crcGenSDLP(tf_buffer, tf_len);
    c92c:	c0 18 1d 42 	movx.w	&0x10b1e,r13	;
    c930:	1e 0b 
    c932:	8c 01 20 0b 	mova	#68384,	r12	;0x10b20
    c936:	b0 13 84 af 	calla	#44932		;0x0af84

0000c93a <.L64>:
  chEvtSignal(rf_thd, RFTxFrameReady);
    c93a:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    c93e:	4e 43       	clr.b	r14		;
    c940:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c944:	b0 13 5c 4b 	calla	#19292		;0x04b5c

0000c948 <.LBB47>:
  _disable_interrupts();
    c948:	32 c2       	dint			
    c94a:	03 43       	nop			

0000c94c <.Loc.348.2>:
  asm volatile("nop");
    c94c:	03 43       	nop			

0000c94e <.LBE47>:
  chSysLock();
    c94e:	b0 13 54 45 	calla	#17748		;0x04554

0000c952 <.LBB49>:
  chDbgCheckClassI();
    c952:	b0 13 54 46 	calla	#18004		;0x04654

0000c956 <.LVL60>:
  return chSemGetCounterI(&mbp->fullsem);
    c956:	c0 18 1c 42 	movx.w	&0x10a92,r12	;
    c95a:	92 0a 

0000c95c <.LBE49>:
  if (chMBGetUsedCountI(&rf_mbox)) {
    c95c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c95e:	07 24       	jz	$+16     	;abs 0xc96e

0000c960 <.Loc.206.1>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    c960:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    c964:	4e 43       	clr.b	r14		;
    c966:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c96a:	b0 13 90 4b 	calla	#19344		;0x04b90

0000c96e <.L65>:
  chSysUnlock();
    c96e:	b0 13 7c 45 	calla	#17788		;0x0457c

0000c972 <.LBB51>:
  asm volatile("nop");
    c972:	03 43       	nop			

0000c974 <.Loc.356.2>:
  _enable_interrupts();
    c974:	03 43       	nop			
    c976:	32 d2       	eint			
    c978:	03 43       	nop			

0000c97a <.LBE51>:
}
    c97a:	a1 00 04 00 	adda	#4,	r1	;
    c97e:	06 16       	popm.a	#1,	r6	;20-bit words
    c980:	08 16       	popm.a	#1,	r8	;20-bit words
    c982:	0a 16       	popm.a	#1,	r10	;20-bit words
    c984:	10 01       	reta			;

0000c986 <.L63>:
    tf_buffer[i+SDLP_TC_PH_LEN] = active_packet[i];
    c986:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;

0000c98a <.LVL65>:
    c98a:	ae 00 01 00 	adda	#1,	r14	;

0000c98e <.LVL66>:
    c98e:	aa 00 01 00 	adda	#1,	r10	;
    c992:	80 00 1e c9 	mova	#51486,	r0	;0x0c91e

0000c996 <elyRFDLLRxInit>:
void elyRFDLLRxInit(SX1212Driver * devp) {
    c996:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c998 <.LCFI12>:
    c998:	ca 0c       	mova	r12,	r10	;

0000c99a <.Loc.271.1>:
  sx1212StopReceive(devp);
    c99a:	b0 13 22 7a 	calla	#31266		;0x07a22

0000c99e <.LVL85>:
  sx1212StartReceive(devp, SDLP_TC_PH_LEN, rxfifothresh_callback);
    c99e:	8e 00 0c c6 	mova	#50700,	r14	;0x0c60c
    c9a2:	7d 40 05 00 	mov.b	#5,	r13	;
    c9a6:	cc 0a       	mova	r10,	r12	;
    c9a8:	b0 13 e0 78 	calla	#30944		;0x078e0

0000c9ac <.LVL86>:
  dll_state = DLL_STATE_HDR;
    c9ac:	40 18 c2 43 	movx.b	#0,	&0xff41e;r3 As==00
    c9b0:	1e f4 

0000c9b2 <.Loc.279.1>:
  chEvtSignal(rf_thd, RFSpiAvailable | RFRxIdle);
    c9b2:	3d 40 00 60 	mov	#24576,	r13	;#0x6000
    c9b6:	4e 43       	clr.b	r14		;
    c9b8:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    c9bc:	b0 13 5c 4b 	calla	#19292		;0x04b5c

0000c9c0 <.LVL87>:
}
    c9c0:	0a 16       	popm.a	#1,	r10	;20-bit words
    c9c2:	10 01       	reta			;

0000c9c4 <elyRFDLLHandleRxFifo>:
void elyRFDLLHandleRxFifo(SX1212Driver * devp) {
    c9c4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c9c6 <.LCFI13>:
    c9c6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000c9c8 <.LCFI14>:
    c9c8:	06 14       	pushm.a	#1,	r6	;20-bit words

0000c9ca <.LCFI15>:
    c9ca:	ca 0c       	mova	r12,	r10	;
    c9cc:	86 00 7e 79 	mova	#31102,	r6	;0x0797e

0000c9d0 <.Loc.284.1>:
  if (dll_state == DLL_STATE_HDR) {
    c9d0:	40 18 c2 93 	cmpx.b	#0,	&0xff41e;r3 As==00
    c9d4:	1e f4 
    c9d6:	64 20       	jnz	$+202    	;abs 0xcaa0

0000c9d8 <.Loc.288.1>:
    sx1212FifoRead(devp, SDLP_TC_PH_LEN, tc_hdr_buff);
    c9d8:	88 01 65 1a 	mova	#72293,	r8	;0x11a65
    c9dc:	ce 08       	mova	r8,	r14	;
    c9de:	7d 40 05 00 	mov.b	#5,	r13	;
    c9e2:	46 13       	calla	r6		;

0000c9e4 <.LVL89>:
    if (tc_hdr_buff[0] & 0xCC) {
    c9e4:	6c 48       	mov.b	@r8,	r12	;
    c9e6:	7c b0 cc ff 	bit.b	#-52,	r12	;#0xffcc
    c9ea:	07 24       	jz	$+16     	;abs 0xc9fa

0000c9ec <.L92>:
      elyRFDLLRxInit(devp);
    c9ec:	cc 0a       	mova	r10,	r12	;
    c9ee:	b0 13 96 c9 	calla	#51606		;0x0c996

0000c9f2 <.L88>:
}
    c9f2:	06 16       	popm.a	#1,	r6	;20-bit words
    c9f4:	08 16       	popm.a	#1,	r8	;20-bit words
    c9f6:	0a 16       	popm.a	#1,	r10	;20-bit words
    c9f8:	10 01       	reta			;

0000c9fa <.L90>:
    if (((tc_hdr_buff[0] & 0x03) != (bank0p[RegDLLIDsMSB] & 0x03)) ||
    c9fa:	2e 01 4a 07 	mova	&67402,	r14	;0x1074a
    c9fe:	5d 4e ca 00 	mov.b	202(r14),r13	;0x000ca
    ca02:	4c ed       	xor.b	r13,	r12	;
    ca04:	3c b0 03 00 	bit	#3,	r12	;
    ca08:	f1 23       	jnz	$-28     	;abs 0xc9ec

0000ca0a <.Loc.298.1>:
    ca0a:	41 18 d2 9e 	cmpx.b	201(r14),&0x11a66;0x000c9
    ca0e:	c9 00 66 1a 
    ca12:	ec 23       	jnz	$-38     	;abs 0xc9ec

0000ca14 <.Loc.305.1>:
    if ((tc_hdr_buff[2] & 0xFC) != (bank0p[RegDLLIDsMSB] & 0xFC)) {
    ca14:	5c 48 02 00 	mov.b	2(r8),	r12	;
    ca18:	4d ec       	xor.b	r12,	r13	;
    ca1a:	7d b0 fc ff 	bit.b	#-4,	r13	;#0xfffc
    ca1e:	e6 23       	jnz	$-50     	;abs 0xc9ec

0000ca20 <.Loc.312.1>:
    rx_pkt_len = (((tc_hdr_buff[2] & 0x03) << 8) | (tc_hdr_buff[3]))+1;
    ca20:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    ca24:	3c f0 00 03 	and	#768,	r12	;#0x0300
    ca28:	58 48 03 00 	mov.b	3(r8),	r8	;
    ca2c:	0c d8       	bis	r8,	r12	;

0000ca2e <.Loc.318.1>:
    rx_pkt_len -= SDLP_TC_PH_LEN;
    ca2e:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc
    ca32:	40 18 82 4c 	movx.w	r12,	&0xff416;
    ca36:	16 f4 

0000ca38 <.LBB62>:
  _disable_interrupts();
    ca38:	32 c2       	dint			
    ca3a:	03 43       	nop			

0000ca3c <.Loc.348.2>:
  asm volatile("nop");
    ca3c:	03 43       	nop			

0000ca3e <.LBE62>:
    chSysLock();
    ca3e:	b0 13 54 45 	calla	#17748		;0x04554

0000ca42 <.LVL91>:
    rx_active_buffer = elyNLGetBufferI();
    ca42:	b0 13 4e c1 	calla	#49486		;0x0c14e

0000ca46 <.LVL92>:
    ca46:	60 0c 1a f4 	mova	r12,	&62490	; 0x0f41a

0000ca4a <.Loc.322.1>:
    if (rx_active_buffer == NULL) {
    ca4a:	9c 00 00 00 	cmpa	#0,	r12	;
    ca4e:	ce 27       	jz	$-98     	;abs 0xc9ec

0000ca50 <.Loc.328.1>:
    curr_threshold = (rx_pkt_len < 64 ? rx_pkt_len : 32);
    ca50:	40 18 1d 42 	movx.w	&0x0f416,r13	;
    ca54:	16 f4 
    ca56:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    ca5a:	0c 9d       	cmp	r13,	r12	;
    ca5c:	02 2c       	jc	$+6      	;abs 0xca62
    ca5e:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020

0000ca62 <.L93>:
    ca62:	40 18 c2 4d 	movx.b	r13,	&0xff415;
    ca66:	15 f4 

0000ca68 <.Loc.329.1>:
    rx_idx = 0;
    ca68:	40 18 82 43 	movx.w	#0,	&0xff418;r3 As==00
    ca6c:	18 f4 

0000ca6e <.Loc.331.1>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    ca6e:	8e 00 0c c6 	mova	#50700,	r14	;0x0c60c
    ca72:	40 18 0d 4d 	movx.w	r13,	r13	;
    ca76:	cc 0a       	mova	r10,	r12	;
    ca78:	b0 13 96 78 	calla	#30870		;0x07896

0000ca7c <.LVL93>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    ca7c:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    ca80:	4e 43       	clr.b	r14		;
    ca82:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    ca86:	b0 13 90 4b 	calla	#19344		;0x04b90

0000ca8a <.LVL94>:
    dll_state = DLL_STATE_PKT;
    ca8a:	40 18 d2 43 	movx.b	#1,	&0xff41e;r3 As==01
    ca8e:	1e f4 

0000ca90 <.L104>:
      chSysUnlock();
    ca90:	b0 13 7c 45 	calla	#17788		;0x0457c

0000ca94 <.LBB64>:
  asm volatile("nop");
    ca94:	03 43       	nop			

0000ca96 <.Loc.356.2>:
  _enable_interrupts();
    ca96:	03 43       	nop			
    ca98:	32 d2       	eint			
    ca9a:	03 43       	nop			
    ca9c:	80 00 f2 c9 	mova	#51698,	r0	;0x0c9f2

0000caa0 <.L89>:
    sx1212FifoRead(devp, curr_threshold, rx_active_buffer + rx_idx);
    caa0:	40 18 1e 42 	movx.w	&0x0f418,r14	;
    caa4:	18 f4 
    caa6:	00 18 5e 52 	addx.a	&0x0f41a,r14	;
    caaa:	1a f4 
    caac:	40 18 5f 42 	movx.b	&0x0f415,r15	;
    cab0:	15 f4 
    cab2:	40 18 0d 4f 	movx.w	r15,	r13	;
    cab6:	46 13       	calla	r6		;

0000cab8 <.LVL96>:
    rx_idx += curr_threshold;
    cab8:	40 18 5c 42 	movx.b	&0x0f415,r12	;
    cabc:	15 f4 
    cabe:	40 18 1c 52 	addx.w	&0x0f418,r12	;
    cac2:	18 f4 
    cac4:	40 18 82 4c 	movx.w	r12,	&0xff418;
    cac8:	18 f4 

0000caca <.Loc.348.1>:
    if (rx_idx < rx_pkt_len) {
    caca:	40 18 1c 92 	cmpx.w	&0x0f416,r12	;
    cace:	16 f4 
    cad0:	2d 2c       	jc	$+92     	;abs 0xcb2c

0000cad2 <.LBB66>:
  _disable_interrupts();
    cad2:	32 c2       	dint			
    cad4:	03 43       	nop			

0000cad6 <.Loc.348.2>:
  asm volatile("nop");
    cad6:	03 43       	nop			

0000cad8 <.LBE66>:
      chSysLock();
    cad8:	b0 13 54 45 	calla	#17748		;0x04554

0000cadc <.LVL97>:
      curr_threshold = (rx_pkt_len-rx_idx < 64 ? rx_pkt_len-rx_idx : 32);
    cadc:	40 18 1d 42 	movx.w	&0x0f416,r13	;
    cae0:	16 f4 
    cae2:	40 18 1c 42 	movx.w	&0x0f418,r12	;
    cae6:	18 f4 
    cae8:	40 18 0e 4d 	movx.w	r13,	r14	;
    caec:	40 18 0e 8c 	subx.w	r12,	r14	;
    caf0:	7f 40 3f 00 	mov.b	#63,	r15	;#0x003f
    caf4:	0f 9e       	cmp	r14,	r15	;
    caf6:	16 28       	jnc	$+46     	;abs 0xcb24

0000caf8 <.Loc.350.1>:
    caf8:	4d 8c       	sub.b	r12,	r13	;
    cafa:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000cafe <.L95>:
    cafe:	40 18 c2 4d 	movx.b	r13,	&0xff415;
    cb02:	15 f4 

0000cb04 <.Loc.352.1>:
      sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    cb04:	8e 00 0c c6 	mova	#50700,	r14	;0x0c60c
    cb08:	40 18 0d 4d 	movx.w	r13,	r13	;
    cb0c:	cc 0a       	mova	r10,	r12	;
    cb0e:	b0 13 96 78 	calla	#30870		;0x07896

0000cb12 <.LVL98>:
      chEvtSignalI(rf_thd, RFSpiAvailable);
    cb12:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    cb16:	4e 43       	clr.b	r14		;
    cb18:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    cb1c:	b0 13 90 4b 	calla	#19344		;0x04b90

0000cb20 <.LVL99>:
    cb20:	80 00 90 ca 	mova	#51856,	r0	;0x0ca90

0000cb24 <.L97>:
      curr_threshold = (rx_pkt_len-rx_idx < 64 ? rx_pkt_len-rx_idx : 32);
    cb24:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    cb28:	80 00 fe ca 	mova	#51966,	r0	;0x0cafe

0000cb2c <.L94>:
      if (MSG_OK != elyUARTPost(rx_active_buffer, TIME_IMMEDIATE)) {
    cb2c:	3d 43       	mov	#-1,	r13	;r3 As==11
    cb2e:	2c 00 1a f4 	mova	&62490,	r12	;0x0f41a
    cb32:	b0 13 ca 7a 	calla	#31434		;0x07aca

0000cb36 <.LVL100>:
    cb36:	9c 00 00 00 	cmpa	#0,	r12	;
    cb3a:	04 24       	jz	$+10     	;abs 0xcb44

0000cb3c <.Loc.359.1>:
        elyNLFreeBuffer(rx_active_buffer);
    cb3c:	2c 00 1a f4 	mova	&62490,	r12	;0x0f41a
    cb40:	b0 13 42 c1 	calla	#49474		;0x0c142

0000cb44 <.L96>:
      elyRFDLLRxInit(devp);
    cb44:	cc 0a       	mova	r10,	r12	;
    cb46:	b0 13 96 c9 	calla	#51606		;0x0c996

0000cb4a <.LVL102>:
      chEvtSignal(rf_thd, RFSpiAvailable);
    cb4a:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    cb4e:	4e 43       	clr.b	r14		;
    cb50:	2c 01 0c 19 	mova	&71948,	r12	;0x1190c
    cb54:	b0 13 5c 4b 	calla	#19292		;0x04b5c

0000cb58 <.LVL103>:
    cb58:	80 00 f2 c9 	mova	#51698,	r0	;0x0c9f2

0000cb5c <elyRFDLLInitiateTransmit>:

void elyRFDLLInitiateTransmit(SX1278Driver * devp) {
    cb5c:	b1 00 04 00 	suba	#4,	r1	;

0000cb60 <.LCFI16>:
#if ELY_DISCRETE_PA_CTL
  palSetLine(LINE_PA_PC_EN);
    cb60:	40 18 b2 d0 	bisx.w	#4096,	&0x00222;0x01000
    cb64:	00 10 22 02 

0000cb68 <.Loc.404.1>:
#endif
  
  tf_idx = sx1278StartTransmit(devp, tf_len, tf_buffer, txlvl_callback, write_cb);
    cb68:	c0 18 1d 42 	movx.w	&0x10b1e,r13	;
    cb6c:	1e 0b 
    cb6e:	00 18 f1 40 	movx.a	#50748,	0(r1)	;0x0c63c
    cb72:	3c c6 00 00 
    cb76:	8f 00 24 c6 	mova	#50724,	r15	;0x0c624
    cb7a:	8e 01 20 0b 	mova	#68384,	r14	;0x10b20
    cb7e:	b0 13 c6 6d 	calla	#28102		;0x06dc6

0000cb82 <.LVL105>:
    cb82:	40 18 82 4c 	movx.w	r12,	&0xff420;
    cb86:	20 f4 

0000cb88 <.Loc.405.1>:
}
    cb88:	a1 00 04 00 	adda	#4,	r1	;
    cb8c:	10 01       	reta			;

0000cb8e <elyRFDLLHandleTxFifo>:

void elyRFDLLHandleTxFifo(SX1278Driver * devp) {
    cb8e:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cb90 <.LCFI17>:
    cb90:	b1 00 04 00 	suba	#4,	r1	;

0000cb94 <.LCFI18>:
  /* FIFO is sufficiently empty */
  static int8_t to_transmit;
  to_transmit = (tf_len - tf_idx <= 31 ? tf_len - tf_idx : 31);
    cb94:	c0 18 1d 42 	movx.w	&0x10b1e,r13	;
    cb98:	1e 0b 
    cb9a:	40 18 1d 82 	subx.w	&0x0f420,r13	;
    cb9e:	20 f4 
    cba0:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    cba4:	0e 9d       	cmp	r13,	r14	;
    cba6:	01 2c       	jc	$+4      	;abs 0xcbaa
    cba8:	0d 4e       	mov	r14,	r13	;

0000cbaa <.L107>:
    cbaa:	40 18 c2 4d 	movx.b	r13,	&0xff414;
    cbae:	14 f4 

0000cbb0 <.LBB72>:
  _disable_interrupts();
    cbb0:	32 c2       	dint			
    cbb2:	03 43       	nop			

0000cbb4 <.Loc.348.2>:
  asm volatile("nop");
    cbb4:	03 43       	nop			

0000cbb6 <.LBE72>:
  chSysLock();
    cbb6:	71 0c 00 00 	mova	r12,	0(r1)	;
    cbba:	b0 13 54 45 	calla	#17748		;0x04554

0000cbbe <.LVL107>:
  sx1278FifoWriteAsyncS(devp, to_transmit, tf_buffer + tf_idx, write_cb);
    cbbe:	40 18 1e 42 	movx.w	&0x0f420,r14	;
    cbc2:	20 f4 
    cbc4:	40 18 5d 42 	movx.b	&0x0f414,r13	;
    cbc8:	14 f4 
    cbca:	40 18 8d 11 	sxtx.w	r13		;
    cbce:	0a 4d       	mov	r13,	r10	;
    cbd0:	0b 4d       	mov	r13,	r11	;
    cbd2:	4e 18 0b 11 	rpt #15 { rrax.w	r11		;
    cbd6:	0b 12       	push	r11		;
    cbd8:	0a 12       	push	r10		;
    cbda:	0d 16       	popm.a	#1,	r13	;20-bit words
    cbdc:	8f 00 3c c6 	mova	#50748,	r15	;0x0c63c
    cbe0:	ae 01 20 0b 	adda	#68384,	r14	;0x10b20
    cbe4:	0c 01       	mova	@r1,	r12	;
    cbe6:	b0 13 02 6d 	calla	#27906		;0x06d02

0000cbea <.LVL108>:
  tf_idx += to_transmit;
    cbea:	40 18 5c 42 	movx.b	&0x0f414,r12	;
    cbee:	14 f4 
    cbf0:	40 18 8c 11 	sxtx.w	r12		;
    cbf4:	40 18 82 5c 	addx.w	r12,	&0xff420;
    cbf8:	20 f4 

0000cbfa <.Loc.414.1>:
  chSysUnlock();
    cbfa:	b0 13 7c 45 	calla	#17788		;0x0457c

0000cbfe <.LBB74>:
  asm volatile("nop");
    cbfe:	03 43       	nop			

0000cc00 <.Loc.356.2>:
  _enable_interrupts();
    cc00:	03 43       	nop			
    cc02:	32 d2       	eint			
    cc04:	03 43       	nop			

0000cc06 <.LBE74>:
}
    cc06:	a1 00 04 00 	adda	#4,	r1	;
    cc0a:	0a 16       	popm.a	#1,	r10	;20-bit words
    cc0c:	10 01       	reta			;

0000cc0e <elyRFDLLTxInit>:
  _disable_interrupts();
    cc0e:	32 c2       	dint			
    cc10:	03 43       	nop			

0000cc12 <.Loc.348.2>:
  asm volatile("nop");
    cc12:	03 43       	nop			

0000cc14 <.LBE80>:




void elyRFDLLTxInit(SX1278Driver * devp) {
  chSysLock();
    cc14:	b0 13 54 45 	calla	#17748		;0x04554

0000cc18 <.LVL111>:
  tf_len = ((uint16_t)(bank0p[RegDLLTFLengthMSB] << 8)) | ((uint16_t)(bank0p[RegDLLTFLengthLSB]));
    cc18:	2c 01 4a 07 	mova	&67402,	r12	;0x1074a
    cc1c:	5d 4c c1 00 	mov.b	193(r12),r13	;0x000c1
    cc20:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    cc24:	5c 4c c0 00 	mov.b	192(r12),r12	;0x000c0
    cc28:	0c dd       	bis	r13,	r12	;
    cc2a:	41 18 82 4c 	movx.w	r12,	&0x10b1e;
    cc2e:	1e 0b 

0000cc30 <.Loc.425.1>:
  /* Compliant ASM code would go here HOWEVER this isn't the real sdlp.c */
  /* TODO data whitening, FARM */
  chSysUnlock();
    cc30:	b0 13 7c 45 	calla	#17788		;0x0457c

0000cc34 <.LBB82>:
  asm volatile("nop");
    cc34:	03 43       	nop			

0000cc36 <.Loc.356.2>:
  _enable_interrupts();
    cc36:	03 43       	nop			
    cc38:	32 d2       	eint			
    cc3a:	03 43       	nop			

0000cc3c <.LBE82>:
}
    cc3c:	10 01       	reta			;

0000cc3e <udivmodsi4>:
UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);
UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);

UINT_TYPE
C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)
{
    cc3e:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000cc40 <.LCFI0>:
    cc40:	0a 4c       	mov	r12,	r10	;
    cc42:	0b 4d       	mov	r13,	r11	;

0000cc44 <.LVL1>:
  UINT_TYPE bit = 1;
  UINT_TYPE res = 0;

  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cc44:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000cc48 <.Loc.35.1>:
  UINT_TYPE bit = 1;
    cc48:	58 43       	mov.b	#1,	r8	;r3 As==01
    cc4a:	49 43       	clr.b	r9		;

0000cc4c <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cc4c:	07 4b       	mov	r11,	r7	;

0000cc4e <.L2>:
    cc4e:	0f 9b       	cmp	r11,	r15	;
    cc50:	11 28       	jnc	$+36     	;abs 0xcc74
    cc52:	07 9f       	cmp	r15,	r7	;
    cc54:	02 20       	jnz	$+6      	;abs 0xcc5a
    cc56:	0e 9a       	cmp	r10,	r14	;
    cc58:	0d 28       	jnc	$+28     	;abs 0xcc74

0000cc5a <.L20>:
    cc5a:	4c 43       	clr.b	r12		;

0000cc5c <.LVL3>:
    cc5c:	0d 4c       	mov	r12,	r13	;

0000cc5e <.L5>:
    {
      den <<= 1;
      bit <<= 1;
    }
  while (bit)
    cc5e:	07 48       	mov	r8,	r7	;
    cc60:	07 d9       	bis	r9,	r7	;
    cc62:	07 93       	cmp	#0,	r7	;r3 As==00
    cc64:	1a 20       	jnz	$+54     	;abs 0xcc9a

0000cc66 <.L6>:
	  res |= bit;
	}
      bit >>= 1;
      den >>= 1;
    }
  if (modwanted)
    cc66:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    cc6a:	02 24       	jz	$+6      	;abs 0xcc70
    cc6c:	0c 4a       	mov	r10,	r12	;
    cc6e:	0d 4b       	mov	r11,	r13	;

0000cc70 <.L1>:
    return num;
  return res;
}
    cc70:	55 16       	popm.a	#6,	r10	;20-bit words
    cc72:	10 01       	reta			;

0000cc74 <.L3>:
    cc74:	3d 53       	add	#-1,	r13	;r3 As==11

0000cc76 <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cc76:	0d 93       	cmp	#0,	r13	;r3 As==00
    cc78:	24 24       	jz	$+74     	;abs 0xccc2

0000cc7a <.Loc.38.1>:
    cc7a:	0f 93       	cmp	#0,	r15	;r3 As==00
    cc7c:	ee 3b       	jl	$-34     	;abs 0xcc5a

0000cc7e <.Loc.40.1>:
      den <<= 1;
    cc7e:	05 4e       	mov	r14,	r5	;
    cc80:	06 4f       	mov	r15,	r6	;
    cc82:	05 5e       	add	r14,	r5	;
    cc84:	06 6f       	addc	r15,	r6	;
    cc86:	0e 45       	mov	r5,	r14	;

0000cc88 <.LVL7>:
    cc88:	0f 46       	mov	r6,	r15	;

0000cc8a <.LVL8>:
      bit <<= 1;
    cc8a:	05 48       	mov	r8,	r5	;
    cc8c:	06 49       	mov	r9,	r6	;
    cc8e:	05 58       	add	r8,	r5	;
    cc90:	06 69       	addc	r9,	r6	;
    cc92:	08 45       	mov	r5,	r8	;

0000cc94 <.LVL9>:
    cc94:	09 46       	mov	r6,	r9	;

0000cc96 <.LVL10>:
    cc96:	80 00 4e cc 	mova	#52302,	r0	;0x0cc4e

0000cc9a <.L12>:
      if (num >= den)
    cc9a:	0b 9f       	cmp	r15,	r11	;
    cc9c:	0a 28       	jnc	$+22     	;abs 0xccb2
    cc9e:	0f 9b       	cmp	r11,	r15	;
    cca0:	02 20       	jnz	$+6      	;abs 0xcca6
    cca2:	0a 9e       	cmp	r14,	r10	;
    cca4:	06 28       	jnc	$+14     	;abs 0xccb2

0000cca6 <.L16>:
	  num -= den;
    cca6:	40 18 0a 8e 	subx.w	r14,	r10	;
    ccaa:	40 18 0b 7f 	subcx.w	r15,	r11	;

0000ccae <.Loc.48.1>:
	  res |= bit;
    ccae:	0c d8       	bis	r8,	r12	;

0000ccb0 <.LVL13>:
    ccb0:	0d d9       	bis	r9,	r13	;

0000ccb2 <.L10>:
      bit >>= 1;
    ccb2:	12 c3       	clrc			
    ccb4:	09 10       	rrc	r9		;
    ccb6:	08 10       	rrc	r8		;

0000ccb8 <.Loc.51.1>:
      den >>= 1;
    ccb8:	12 c3       	clrc			
    ccba:	0f 10       	rrc	r15		;
    ccbc:	0e 10       	rrc	r14		;
    ccbe:	80 00 5e cc 	mova	#52318,	r0	;0x0cc5e

0000ccc2 <.L14>:
    ccc2:	0c 4d       	mov	r13,	r12	;

0000ccc4 <.LVL18>:
    ccc4:	80 00 66 cc 	mova	#52326,	r0	;0x0cc66

0000ccc8 <__mspabi_divlu>:
  return res;
}

UINT_TYPE
C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)
{
    ccc8:	b1 00 02 00 	suba	#2,	r1	;

0000cccc <.LCFI5>:
  return C3(udivmod,NAME_MODE,4) (a, b, 0);
    cccc:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    ccd0:	b0 13 3e cc 	calla	#52286		;0x0cc3e

0000ccd4 <.LVL46>:
}
    ccd4:	a1 00 02 00 	adda	#2,	r1	;
    ccd8:	10 01       	reta			;

0000ccda <__mspabi_slli_15>:
    ccda:	0c 5c       	rla	r12		;

0000ccdc <__mspabi_slli_14>:
    ccdc:	0c 5c       	rla	r12		;

0000ccde <__mspabi_slli_13>:
    ccde:	0c 5c       	rla	r12		;

0000cce0 <__mspabi_slli_12>:
    cce0:	0c 5c       	rla	r12		;

0000cce2 <__mspabi_slli_11>:
    cce2:	0c 5c       	rla	r12		;

0000cce4 <__mspabi_slli_10>:
    cce4:	0c 5c       	rla	r12		;

0000cce6 <__mspabi_slli_9>:
    cce6:	0c 5c       	rla	r12		;

0000cce8 <__mspabi_slli_8>:
    cce8:	0c 5c       	rla	r12		;

0000ccea <__mspabi_slli_7>:
    ccea:	0c 5c       	rla	r12		;

0000ccec <__mspabi_slli_6>:
    ccec:	0c 5c       	rla	r12		;

0000ccee <__mspabi_slli_5>:
    ccee:	0c 5c       	rla	r12		;

0000ccf0 <__mspabi_slli_4>:
    ccf0:	0c 5c       	rla	r12		;

0000ccf2 <__mspabi_slli_3>:
    ccf2:	0c 5c       	rla	r12		;

0000ccf4 <__mspabi_slli_2>:
    ccf4:	0c 5c       	rla	r12		;

0000ccf6 <__mspabi_slli_1>:
    ccf6:	0c 5c       	rla	r12		;
    ccf8:	10 01       	reta			;

0000ccfa <.L11>:
    ccfa:	3d 53       	add	#-1,	r13	;r3 As==11
    ccfc:	0c 5c       	rla	r12		;

0000ccfe <__mspabi_slli>:
    ccfe:	0d 93       	cmp	#0,	r13	;r3 As==00
    cd00:	fc 23       	jnz	$-6      	;abs 0xccfa
    cd02:	10 01       	reta			;

0000cd04 <__mspabi_slll_15>:
    cd04:	0c 5c       	rla	r12		;
    cd06:	0d 6d       	rlc	r13		;

0000cd08 <__mspabi_slll_14>:
    cd08:	0c 5c       	rla	r12		;
    cd0a:	0d 6d       	rlc	r13		;

0000cd0c <__mspabi_slll_13>:
    cd0c:	0c 5c       	rla	r12		;
    cd0e:	0d 6d       	rlc	r13		;

0000cd10 <__mspabi_slll_12>:
    cd10:	0c 5c       	rla	r12		;
    cd12:	0d 6d       	rlc	r13		;

0000cd14 <__mspabi_slll_11>:
    cd14:	0c 5c       	rla	r12		;
    cd16:	0d 6d       	rlc	r13		;

0000cd18 <__mspabi_slll_10>:
    cd18:	0c 5c       	rla	r12		;
    cd1a:	0d 6d       	rlc	r13		;

0000cd1c <__mspabi_slll_9>:
    cd1c:	0c 5c       	rla	r12		;
    cd1e:	0d 6d       	rlc	r13		;

0000cd20 <__mspabi_slll_8>:
    cd20:	0c 5c       	rla	r12		;
    cd22:	0d 6d       	rlc	r13		;

0000cd24 <__mspabi_slll_7>:
    cd24:	0c 5c       	rla	r12		;
    cd26:	0d 6d       	rlc	r13		;

0000cd28 <__mspabi_slll_6>:
    cd28:	0c 5c       	rla	r12		;
    cd2a:	0d 6d       	rlc	r13		;

0000cd2c <__mspabi_slll_5>:
    cd2c:	0c 5c       	rla	r12		;
    cd2e:	0d 6d       	rlc	r13		;

0000cd30 <__mspabi_slll_4>:
    cd30:	0c 5c       	rla	r12		;
    cd32:	0d 6d       	rlc	r13		;

0000cd34 <__mspabi_slll_3>:
    cd34:	0c 5c       	rla	r12		;
    cd36:	0d 6d       	rlc	r13		;

0000cd38 <__mspabi_slll_2>:
    cd38:	0c 5c       	rla	r12		;
    cd3a:	0d 6d       	rlc	r13		;

0000cd3c <__mspabi_slll_1>:
    cd3c:	0c 5c       	rla	r12		;
    cd3e:	0d 6d       	rlc	r13		;
    cd40:	10 01       	reta			;

0000cd42 <.L12>:
    cd42:	3e 53       	add	#-1,	r14	;r3 As==11
    cd44:	0c 5c       	rla	r12		;
    cd46:	0d 6d       	rlc	r13		;

0000cd48 <__mspabi_slll>:
    cd48:	0e 93       	cmp	#0,	r14	;r3 As==00
    cd4a:	fb 23       	jnz	$-8      	;abs 0xcd42
    cd4c:	10 01       	reta			;

0000cd4e <__mspabi_srai_15>:
    cd4e:	0c 11       	rra	r12		;

0000cd50 <__mspabi_srai_14>:
    cd50:	0c 11       	rra	r12		;

0000cd52 <__mspabi_srai_13>:
    cd52:	0c 11       	rra	r12		;

0000cd54 <__mspabi_srai_12>:
    cd54:	0c 11       	rra	r12		;

0000cd56 <__mspabi_srai_11>:
    cd56:	0c 11       	rra	r12		;

0000cd58 <__mspabi_srai_10>:
    cd58:	0c 11       	rra	r12		;

0000cd5a <__mspabi_srai_9>:
    cd5a:	0c 11       	rra	r12		;

0000cd5c <__mspabi_srai_8>:
    cd5c:	0c 11       	rra	r12		;

0000cd5e <__mspabi_srai_7>:
    cd5e:	0c 11       	rra	r12		;

0000cd60 <__mspabi_srai_6>:
    cd60:	0c 11       	rra	r12		;

0000cd62 <__mspabi_srai_5>:
    cd62:	0c 11       	rra	r12		;

0000cd64 <__mspabi_srai_4>:
    cd64:	0c 11       	rra	r12		;

0000cd66 <__mspabi_srai_3>:
    cd66:	0c 11       	rra	r12		;

0000cd68 <__mspabi_srai_2>:
    cd68:	0c 11       	rra	r12		;

0000cd6a <__mspabi_srai_1>:
    cd6a:	0c 11       	rra	r12		;
    cd6c:	10 01       	reta			;

0000cd6e <.L11>:
    cd6e:	3d 53       	add	#-1,	r13	;r3 As==11
    cd70:	0c 11       	rra	r12		;

0000cd72 <__mspabi_srai>:
    cd72:	0d 93       	cmp	#0,	r13	;r3 As==00
    cd74:	fc 23       	jnz	$-6      	;abs 0xcd6e
    cd76:	10 01       	reta			;

0000cd78 <__mspabi_sral_15>:
    cd78:	0d 11       	rra	r13		;
    cd7a:	0c 10       	rrc	r12		;

0000cd7c <__mspabi_sral_14>:
    cd7c:	0d 11       	rra	r13		;
    cd7e:	0c 10       	rrc	r12		;

0000cd80 <__mspabi_sral_13>:
    cd80:	0d 11       	rra	r13		;
    cd82:	0c 10       	rrc	r12		;

0000cd84 <__mspabi_sral_12>:
    cd84:	0d 11       	rra	r13		;
    cd86:	0c 10       	rrc	r12		;

0000cd88 <__mspabi_sral_11>:
    cd88:	0d 11       	rra	r13		;
    cd8a:	0c 10       	rrc	r12		;

0000cd8c <__mspabi_sral_10>:
    cd8c:	0d 11       	rra	r13		;
    cd8e:	0c 10       	rrc	r12		;

0000cd90 <__mspabi_sral_9>:
    cd90:	0d 11       	rra	r13		;
    cd92:	0c 10       	rrc	r12		;

0000cd94 <__mspabi_sral_8>:
    cd94:	0d 11       	rra	r13		;
    cd96:	0c 10       	rrc	r12		;

0000cd98 <__mspabi_sral_7>:
    cd98:	0d 11       	rra	r13		;
    cd9a:	0c 10       	rrc	r12		;

0000cd9c <__mspabi_sral_6>:
    cd9c:	0d 11       	rra	r13		;
    cd9e:	0c 10       	rrc	r12		;

0000cda0 <__mspabi_sral_5>:
    cda0:	0d 11       	rra	r13		;
    cda2:	0c 10       	rrc	r12		;

0000cda4 <__mspabi_sral_4>:
    cda4:	0d 11       	rra	r13		;
    cda6:	0c 10       	rrc	r12		;

0000cda8 <__mspabi_sral_3>:
    cda8:	0d 11       	rra	r13		;
    cdaa:	0c 10       	rrc	r12		;

0000cdac <__mspabi_sral_2>:
    cdac:	0d 11       	rra	r13		;
    cdae:	0c 10       	rrc	r12		;

0000cdb0 <__mspabi_sral_1>:
    cdb0:	0d 11       	rra	r13		;
    cdb2:	0c 10       	rrc	r12		;
    cdb4:	10 01       	reta			;

0000cdb6 <.L12>:
    cdb6:	3e 53       	add	#-1,	r14	;r3 As==11
    cdb8:	0d 11       	rra	r13		;
    cdba:	0c 10       	rrc	r12		;

0000cdbc <__mspabi_sral>:
    cdbc:	0e 93       	cmp	#0,	r14	;r3 As==00
    cdbe:	fb 23       	jnz	$-8      	;abs 0xcdb6
    cdc0:	10 01       	reta			;

0000cdc2 <__mspabi_srli_15>:
    cdc2:	12 c3       	clrc			
    cdc4:	0c 10       	rrc	r12		;

0000cdc6 <__mspabi_srli_14>:
    cdc6:	12 c3       	clrc			
    cdc8:	0c 10       	rrc	r12		;

0000cdca <__mspabi_srli_13>:
    cdca:	12 c3       	clrc			
    cdcc:	0c 10       	rrc	r12		;

0000cdce <__mspabi_srli_12>:
    cdce:	12 c3       	clrc			
    cdd0:	0c 10       	rrc	r12		;

0000cdd2 <__mspabi_srli_11>:
    cdd2:	12 c3       	clrc			
    cdd4:	0c 10       	rrc	r12		;

0000cdd6 <__mspabi_srli_10>:
    cdd6:	12 c3       	clrc			
    cdd8:	0c 10       	rrc	r12		;

0000cdda <__mspabi_srli_9>:
    cdda:	12 c3       	clrc			
    cddc:	0c 10       	rrc	r12		;

0000cdde <__mspabi_srli_8>:
    cdde:	12 c3       	clrc			
    cde0:	0c 10       	rrc	r12		;

0000cde2 <__mspabi_srli_7>:
    cde2:	12 c3       	clrc			
    cde4:	0c 10       	rrc	r12		;

0000cde6 <__mspabi_srli_6>:
    cde6:	12 c3       	clrc			
    cde8:	0c 10       	rrc	r12		;

0000cdea <__mspabi_srli_5>:
    cdea:	12 c3       	clrc			
    cdec:	0c 10       	rrc	r12		;

0000cdee <__mspabi_srli_4>:
    cdee:	12 c3       	clrc			
    cdf0:	0c 10       	rrc	r12		;

0000cdf2 <__mspabi_srli_3>:
    cdf2:	12 c3       	clrc			
    cdf4:	0c 10       	rrc	r12		;

0000cdf6 <__mspabi_srli_2>:
    cdf6:	12 c3       	clrc			
    cdf8:	0c 10       	rrc	r12		;

0000cdfa <__mspabi_srli_1>:
    cdfa:	12 c3       	clrc			
    cdfc:	0c 10       	rrc	r12		;
    cdfe:	10 01       	reta			;

0000ce00 <.L11>:
    ce00:	3d 53       	add	#-1,	r13	;r3 As==11
    ce02:	12 c3       	clrc			
    ce04:	0c 10       	rrc	r12		;

0000ce06 <__mspabi_srli>:
    ce06:	0d 93       	cmp	#0,	r13	;r3 As==00
    ce08:	fb 23       	jnz	$-8      	;abs 0xce00
    ce0a:	10 01       	reta			;

0000ce0c <__mspabi_srll_15>:
    ce0c:	12 c3       	clrc			
    ce0e:	0d 10       	rrc	r13		;
    ce10:	0c 10       	rrc	r12		;

0000ce12 <__mspabi_srll_14>:
    ce12:	12 c3       	clrc			
    ce14:	0d 10       	rrc	r13		;
    ce16:	0c 10       	rrc	r12		;

0000ce18 <__mspabi_srll_13>:
    ce18:	12 c3       	clrc			
    ce1a:	0d 10       	rrc	r13		;
    ce1c:	0c 10       	rrc	r12		;

0000ce1e <__mspabi_srll_12>:
    ce1e:	12 c3       	clrc			
    ce20:	0d 10       	rrc	r13		;
    ce22:	0c 10       	rrc	r12		;

0000ce24 <__mspabi_srll_11>:
    ce24:	12 c3       	clrc			
    ce26:	0d 10       	rrc	r13		;
    ce28:	0c 10       	rrc	r12		;

0000ce2a <__mspabi_srll_10>:
    ce2a:	12 c3       	clrc			
    ce2c:	0d 10       	rrc	r13		;
    ce2e:	0c 10       	rrc	r12		;

0000ce30 <__mspabi_srll_9>:
    ce30:	12 c3       	clrc			
    ce32:	0d 10       	rrc	r13		;
    ce34:	0c 10       	rrc	r12		;

0000ce36 <__mspabi_srll_8>:
    ce36:	12 c3       	clrc			
    ce38:	0d 10       	rrc	r13		;
    ce3a:	0c 10       	rrc	r12		;

0000ce3c <__mspabi_srll_7>:
    ce3c:	12 c3       	clrc			
    ce3e:	0d 10       	rrc	r13		;
    ce40:	0c 10       	rrc	r12		;

0000ce42 <__mspabi_srll_6>:
    ce42:	12 c3       	clrc			
    ce44:	0d 10       	rrc	r13		;
    ce46:	0c 10       	rrc	r12		;

0000ce48 <__mspabi_srll_5>:
    ce48:	12 c3       	clrc			
    ce4a:	0d 10       	rrc	r13		;
    ce4c:	0c 10       	rrc	r12		;

0000ce4e <__mspabi_srll_4>:
    ce4e:	12 c3       	clrc			
    ce50:	0d 10       	rrc	r13		;
    ce52:	0c 10       	rrc	r12		;

0000ce54 <__mspabi_srll_3>:
    ce54:	12 c3       	clrc			
    ce56:	0d 10       	rrc	r13		;
    ce58:	0c 10       	rrc	r12		;

0000ce5a <__mspabi_srll_2>:
    ce5a:	12 c3       	clrc			
    ce5c:	0d 10       	rrc	r13		;
    ce5e:	0c 10       	rrc	r12		;

0000ce60 <__mspabi_srll_1>:
    ce60:	12 c3       	clrc			
    ce62:	0d 10       	rrc	r13		;
    ce64:	0c 10       	rrc	r12		;
    ce66:	10 01       	reta			;

0000ce68 <.L12>:
    ce68:	3e 53       	add	#-1,	r14	;r3 As==11
    ce6a:	12 c3       	clrc			
    ce6c:	0d 10       	rrc	r13		;
    ce6e:	0c 10       	rrc	r12		;

0000ce70 <__mspabi_srll>:
    ce70:	0e 93       	cmp	#0,	r14	;r3 As==00
    ce72:	fa 23       	jnz	$-10     	;abs 0xce68
    ce74:	10 01       	reta			;

0000ce76 <__cmpsi2>:
    ce76:	0f 9d       	cmp	r13,	r15	;
    ce78:	05 24       	jz	$+12     	;abs 0xce84
    ce7a:	02 34       	jge	$+6      	;abs 0xce80

0000ce7c <.L_greater_than>:
    ce7c:	2c 43       	mov	#2,	r12	;r3 As==10
    ce7e:	10 01       	reta			;

0000ce80 <.L_less_than>:
    ce80:	0c 43       	clr	r12		;
    ce82:	10 01       	reta			;

0000ce84 <.L_compare_low>:
    ce84:	0e 9c       	cmp	r12,	r14	;
    ce86:	fa 3b       	jl	$-10     	;abs 0xce7c
    ce88:	fb 23       	jnz	$-8      	;abs 0xce80
    ce8a:	1c 43       	mov	#1,	r12	;r3 As==01
    ce8c:	10 01       	reta			;

0000ce8e <__ucmpsi2>:
    ce8e:	0d 93       	cmp	#0,	r13	;r3 As==00
    ce90:	03 30       	jn	$+8      	;abs 0xce98
    ce92:	0f 93       	cmp	#0,	r15	;r3 As==00
    ce94:	f5 33       	jn	$-20     	;abs 0xce80
    ce96:	ef 2f       	jc	$-32     	;abs 0xce76

0000ce98 <.L_top_bit_set_in_A>:
    ce98:	0f 93       	cmp	#0,	r15	;r3 As==00
    ce9a:	ed 33       	jn	$-36     	;abs 0xce76
    ce9c:	ef 2f       	jc	$-32     	;abs 0xce7c

0000ce9e <__mspabi_mpyi>:
    ce9e:	02 12       	push	r2		;
    cea0:	32 c2       	dint			
    cea2:	03 43       	nop			
    cea4:	82 4c c0 04 	mov	r12,	&0x04c0	;
    cea8:	82 4d c8 04 	mov	r13,	&0x04c8	;
    ceac:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    ceb0:	32 41       	pop	r2		;
    ceb2:	10 01       	reta			;

0000ceb4 <__mspabi_mpyl>:
    ceb4:	02 12       	push	r2		;
    ceb6:	32 c2       	dint			
    ceb8:	03 43       	nop			
    ceba:	82 4c d0 04 	mov	r12,	&0x04d0	;
    cebe:	82 4d d2 04 	mov	r13,	&0x04d2	;
    cec2:	82 4e e0 04 	mov	r14,	&0x04e0	;
    cec6:	82 4f e2 04 	mov	r15,	&0x04e2	;
    ceca:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    cece:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    ced2:	32 41       	pop	r2		;
    ced4:	10 01       	reta			;

0000ced6 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
    ced6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ced8 <.LCFI0>:
    ced8:	ca 0c       	mova	r12,	r10	;
    ceda:	ee 0c       	adda	r12,	r14	;

0000cedc <.L2>:
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  _PTR save = dst0;

  while (len0--)
    cedc:	da 0e       	cmpa	r14,	r10	;
    cede:	08 24       	jz	$+18     	;abs 0xcef0

0000cee0 <.LVL3>:
    {
      *dst++ = *src++;
    cee0:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    cee4:	aa 00 01 00 	adda	#1,	r10	;

0000cee8 <.LVL4>:
    cee8:	ad 00 01 00 	adda	#1,	r13	;
    ceec:	80 00 dc ce 	mova	#52956,	r0	;0x0cedc

0000cef0 <.L5>:
  while (len0--)
    *dst++ = *src++;

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
    cef0:	0a 16       	popm.a	#1,	r10	;20-bit words
    cef2:	10 01       	reta			;

0000cef4 <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
    cef4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cef6 <.LCFI0>:
    cef6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000cef8 <.LCFI1>:
    cef8:	06 14       	pushm.a	#1,	r6	;20-bit words

0000cefa <.LCFI2>:
    cefa:	c8 0c       	mova	r12,	r8	;
    cefc:	e8 0e       	adda	r14,	r8	;

0000cefe <.Loc.69.1>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dst = dst_void;
  _CONST char *src = src_void;

  if (src < dst && dst < src + length)
    cefe:	dd 0c       	cmpa	r12,	r13	;
    cf00:	04 28       	jnc	$+10     	;abs 0xcf0a

0000cf02 <.L4>:
    cf02:	ce 0c       	mova	r12,	r14	;

0000cf04 <.LVL2>:
    cf04:	ca 0d       	mova	r13,	r10	;
    cf06:	80 00 2e cf 	mova	#53038,	r0	;0x0cf2e

0000cf0a <.L2>:
    cf0a:	ca 0d       	mova	r13,	r10	;
    cf0c:	ea 0e       	adda	r14,	r10	;
    cf0e:	dc 0a       	cmpa	r10,	r12	;
    cf10:	f8 2f       	jc	$-14     	;abs 0xcf02

0000cf12 <.LVL4>:
    cf12:	fe 0a       	suba	r10,	r14	;

0000cf14 <.L5>:
    cf14:	c6 0a       	mova	r10,	r6	;
    cf16:	e6 0e       	adda	r14,	r6	;

0000cf18 <.Loc.74.1>:
    {
      /* Have to copy backwards */
      src += length;
      dst += length;
      while (length--)
    cf18:	96 00 00 00 	cmpa	#0,	r6	;
    cf1c:	12 24       	jz	$+38     	;abs 0xcf42

0000cf1e <.Loc.76.1>:
	{
	  *--dst = *--src;
    cf1e:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    cf22:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000cf26 <.LVL7>:
    cf26:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    cf2a:	80 00 14 cf 	mova	#53012,	r0	;0x0cf14

0000cf2e <.L3>:
	}
    }
  else
    {
      while (length--)
    cf2e:	d8 0e       	cmpa	r14,	r8	;
    cf30:	08 24       	jz	$+18     	;abs 0xcf42

0000cf32 <.LVL9>:
	{
	  *dst++ = *src++;
    cf32:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    cf36:	ae 00 01 00 	adda	#1,	r14	;

0000cf3a <.LVL10>:
    cf3a:	aa 00 01 00 	adda	#1,	r10	;
    cf3e:	80 00 2e cf 	mova	#53038,	r0	;0x0cf2e

0000cf42 <.L9>:
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
    cf42:	06 16       	popm.a	#1,	r6	;20-bit words
    cf44:	08 16       	popm.a	#1,	r8	;20-bit words
    cf46:	0a 16       	popm.a	#1,	r10	;20-bit words
    cf48:	10 01       	reta			;

0000cf4a <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
    cf4a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cf4c <.LCFI0>:
    cf4c:	ca 0c       	mova	r12,	r10	;
    cf4e:	ee 0c       	adda	r12,	r14	;

0000cf50 <.L2>:
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
    cf50:	da 0e       	cmpa	r14,	r10	;
    cf52:	06 24       	jz	$+14     	;abs 0xcf60

0000cf54 <.LVL3>:
    *s++ = (char) c;
    cf54:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    cf58:	aa 00 01 00 	adda	#1,	r10	;

0000cf5c <.LVL4>:
    cf5c:	80 00 50 cf 	mova	#53072,	r0	;0x0cf50

0000cf60 <.L5>:

  return m;
}
    cf60:	0a 16       	popm.a	#1,	r10	;20-bit words
    cf62:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000f422 <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    f422:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f424 <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    f424:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f428:	96 13 
    f42a:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f42e <.LBB12>:
  chSysLockFromISR();
    f42e:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f432 <.LBB14>:
  chSysTimerHandlerI();
    f432:	b0 13 ec 47 	calla	#18412		;0x047ec

0000f436 <.LBB16>:
  chSysUnlockFromISR();
    f436:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f43a <.LBE16>:
  OSAL_IRQ_EPILOGUE();
    f43a:	b0 13 26 46 	calla	#17958		;0x04626

0000f43e <.LVL4>:
    f43e:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f442:	96 13 
    f444:	b0 13 54 45 	calla	#17748		;0x04554

0000f448 <.LVL5>:
    f448:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f44c <.LVL6>:
    f44c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f44e:	02 24       	jz	$+6      	;abs 0xf454

0000f450 <.Loc.174.1>:
    f450:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f454 <.L2>:
    f454:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f458 <.LVL8>:
}
    f458:	b4 16       	popm.a	#12,	r15	;20-bit words
    f45a:	00 13       	reti			

0000f45c <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    f45c:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f45e <.LCFI0>:
    f45e:	b1 00 04 00 	suba	#4,	r1	;

0000f462 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f462:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f466:	96 13 
    f468:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f46c <.LVL0>:
  pad = (P1IV >> 1) - 1;
    f46c:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    f470:	0e 02 

0000f472 <.LVL1>:
    f472:	12 c3       	clrc			
    f474:	0c 10       	rrc	r12		;

0000f476 <.LVL2>:
    f476:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f478 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    f478:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f47c:	0d 43       	clr	r13		;
    f47e:	0e 4c       	mov	r12,	r14	;
    f480:	0f 4d       	mov	r13,	r15	;
    f482:	0e 5e       	rla	r14		;
    f484:	0f 6f       	rlc	r15		;
    f486:	0e 5e       	rla	r14		;
    f488:	0f 6f       	rlc	r15		;
    f48a:	81 4e 00 00 	mov	r14,	0(r1)	;
    f48e:	81 4f 02 00 	mov	r15,	2(r1)	;
    f492:	0d 01       	mova	@r1,	r13	;
    f494:	80 18 5c 4d 	movx.a	70552(r13),r12	;0x11398
    f498:	98 13 

0000f49a <.LVL3>:
  if (cb != NULL) {
    f49a:	9c 00 00 00 	cmpa	#0,	r12	;
    f49e:	01 24       	jz	$+4      	;abs 0xf4a2

0000f4a0 <.Loc.81.1>:
    (*cb)();
    f4a0:	4c 13       	calla	r12		;

0000f4a2 <.L2>:
  OSAL_IRQ_EPILOGUE();
    f4a2:	b0 13 26 46 	calla	#17958		;0x04626

0000f4a6 <.LVL5>:
    f4a6:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f4aa:	96 13 
    f4ac:	b0 13 54 45 	calla	#17748		;0x04554

0000f4b0 <.LVL6>:
    f4b0:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f4b4 <.LVL7>:
    f4b4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f4b6:	02 24       	jz	$+6      	;abs 0xf4bc

0000f4b8 <.Loc.84.1>:
    f4b8:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f4bc <.L3>:
    f4bc:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f4c0 <.LVL9>:
}
    f4c0:	a1 00 04 00 	adda	#4,	r1	;
    f4c4:	b4 16       	popm.a	#12,	r15	;20-bit words
    f4c6:	00 13       	reti			

0000f4c8 <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    f4c8:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f4ca <.LCFI2>:
    f4ca:	b1 00 04 00 	suba	#4,	r1	;

0000f4ce <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    f4ce:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f4d2:	96 13 
    f4d4:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f4d8 <.LVL10>:
  pad = (P2IV >> 1) - 1;
    f4d8:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    f4dc:	1e 02 

0000f4de <.LVL11>:
    f4de:	12 c3       	clrc			
    f4e0:	0c 10       	rrc	r12		;

0000f4e2 <.LVL12>:
    f4e2:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f4e4 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    f4e4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f4e8:	4c 0e       	rlam.a	#4,	r12	;
    f4ea:	4c 0d       	rram.a	#4,	r12	;
    f4ec:	ac 00 08 00 	adda	#8,	r12	;
    f4f0:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f4f2:	40 18 3c 41 	popx.w	r12		;
    f4f6:	40 18 3d 41 	popx.w	r13		;
    f4fa:	0e 4c       	mov	r12,	r14	;
    f4fc:	0f 4d       	mov	r13,	r15	;
    f4fe:	0e 5e       	rla	r14		;
    f500:	0f 6f       	rlc	r15		;
    f502:	0e 5e       	rla	r14		;
    f504:	0f 6f       	rlc	r15		;
    f506:	81 4e 00 00 	mov	r14,	0(r1)	;
    f50a:	81 4f 02 00 	mov	r15,	2(r1)	;
    f50e:	0d 01       	mova	@r1,	r13	;
    f510:	80 18 5c 4d 	movx.a	70552(r13),r12	;0x11398
    f514:	98 13 

0000f516 <.LVL13>:
  if (cb != NULL) {
    f516:	9c 00 00 00 	cmpa	#0,	r12	;
    f51a:	01 24       	jz	$+4      	;abs 0xf51e

0000f51c <.Loc.99.1>:
    (*cb)();
    f51c:	4c 13       	calla	r12		;

0000f51e <.L11>:
  OSAL_IRQ_EPILOGUE();
    f51e:	b0 13 26 46 	calla	#17958		;0x04626

0000f522 <.LVL15>:
    f522:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f526:	96 13 
    f528:	b0 13 54 45 	calla	#17748		;0x04554

0000f52c <.LVL16>:
    f52c:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f530 <.LVL17>:
    f530:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f532:	02 24       	jz	$+6      	;abs 0xf538

0000f534 <.Loc.102.1>:
    f534:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f538 <.L12>:
    f538:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f53c <.LVL19>:
}
    f53c:	a1 00 04 00 	adda	#4,	r1	;
    f540:	b4 16       	popm.a	#12,	r15	;20-bit words
    f542:	00 13       	reti			

0000f544 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    f544:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f546 <.LCFI4>:
    f546:	b1 00 04 00 	suba	#4,	r1	;

0000f54a <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    f54a:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f54e:	96 13 
    f550:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f554 <.LVL20>:
  pad = (P3IV >> 1) - 1;
    f554:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    f558:	2e 02 

0000f55a <.LVL21>:
    f55a:	12 c3       	clrc			
    f55c:	0c 10       	rrc	r12		;

0000f55e <.LVL22>:
    f55e:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f560 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    f560:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f564:	4c 0e       	rlam.a	#4,	r12	;
    f566:	4c 0d       	rram.a	#4,	r12	;
    f568:	ac 00 10 00 	adda	#16,	r12	;0x00010
    f56c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f56e:	40 18 3c 41 	popx.w	r12		;
    f572:	40 18 3d 41 	popx.w	r13		;
    f576:	0e 4c       	mov	r12,	r14	;
    f578:	0f 4d       	mov	r13,	r15	;
    f57a:	0e 5e       	rla	r14		;
    f57c:	0f 6f       	rlc	r15		;
    f57e:	0e 5e       	rla	r14		;
    f580:	0f 6f       	rlc	r15		;
    f582:	81 4e 00 00 	mov	r14,	0(r1)	;
    f586:	81 4f 02 00 	mov	r15,	2(r1)	;
    f58a:	0d 01       	mova	@r1,	r13	;
    f58c:	80 18 5c 4d 	movx.a	70552(r13),r12	;0x11398
    f590:	98 13 

0000f592 <.LVL23>:
  if (cb != NULL) {
    f592:	9c 00 00 00 	cmpa	#0,	r12	;
    f596:	01 24       	jz	$+4      	;abs 0xf59a

0000f598 <.Loc.118.1>:
    (*cb)();
    f598:	4c 13       	calla	r12		;

0000f59a <.L20>:
  OSAL_IRQ_EPILOGUE();
    f59a:	b0 13 26 46 	calla	#17958		;0x04626

0000f59e <.LVL25>:
    f59e:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f5a2:	96 13 
    f5a4:	b0 13 54 45 	calla	#17748		;0x04554

0000f5a8 <.LVL26>:
    f5a8:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f5ac <.LVL27>:
    f5ac:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f5ae:	02 24       	jz	$+6      	;abs 0xf5b4

0000f5b0 <.Loc.121.1>:
    f5b0:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f5b4 <.L21>:
    f5b4:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f5b8 <.LVL29>:
}
    f5b8:	a1 00 04 00 	adda	#4,	r1	;
    f5bc:	b4 16       	popm.a	#12,	r15	;20-bit words
    f5be:	00 13       	reti			

0000f5c0 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    f5c0:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f5c2 <.LCFI6>:
    f5c2:	b1 00 04 00 	suba	#4,	r1	;

0000f5c6 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    f5c6:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f5ca:	96 13 
    f5cc:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f5d0 <.LVL30>:
  pad = (P4IV >> 1) - 1;
    f5d0:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    f5d4:	3e 02 

0000f5d6 <.LVL31>:
    f5d6:	12 c3       	clrc			
    f5d8:	0c 10       	rrc	r12		;

0000f5da <.LVL32>:
    f5da:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f5dc <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    f5dc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f5e0:	4c 0e       	rlam.a	#4,	r12	;
    f5e2:	4c 0d       	rram.a	#4,	r12	;
    f5e4:	ac 00 18 00 	adda	#24,	r12	;0x00018
    f5e8:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f5ea:	40 18 3c 41 	popx.w	r12		;
    f5ee:	40 18 3d 41 	popx.w	r13		;
    f5f2:	0e 4c       	mov	r12,	r14	;
    f5f4:	0f 4d       	mov	r13,	r15	;
    f5f6:	0e 5e       	rla	r14		;
    f5f8:	0f 6f       	rlc	r15		;
    f5fa:	0e 5e       	rla	r14		;
    f5fc:	0f 6f       	rlc	r15		;
    f5fe:	81 4e 00 00 	mov	r14,	0(r1)	;
    f602:	81 4f 02 00 	mov	r15,	2(r1)	;
    f606:	0d 01       	mova	@r1,	r13	;
    f608:	80 18 5c 4d 	movx.a	70552(r13),r12	;0x11398
    f60c:	98 13 

0000f60e <.LVL33>:
  if (cb != NULL) {
    f60e:	9c 00 00 00 	cmpa	#0,	r12	;
    f612:	01 24       	jz	$+4      	;abs 0xf616

0000f614 <.Loc.136.1>:
    (*cb)();
    f614:	4c 13       	calla	r12		;

0000f616 <.L29>:
  OSAL_IRQ_EPILOGUE();
    f616:	b0 13 26 46 	calla	#17958		;0x04626

0000f61a <.LVL35>:
    f61a:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f61e:	96 13 
    f620:	b0 13 54 45 	calla	#17748		;0x04554

0000f624 <.LVL36>:
    f624:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f628 <.LVL37>:
    f628:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f62a:	02 24       	jz	$+6      	;abs 0xf630

0000f62c <.Loc.139.1>:
    f62c:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f630 <.L30>:
    f630:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f634 <.LVL39>:
}
    f634:	a1 00 04 00 	adda	#4,	r1	;
    f638:	b4 16       	popm.a	#12,	r15	;20-bit words
    f63a:	00 13       	reti			

0000f63c <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    f63c:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f63e <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f63e:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f642:	96 13 
    f644:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f648 <.LVL6>:
  index = (DMAIV >> 1) - 1;
    f648:	40 18 18 42 	movx.w	&0x0050e,r8	;
    f64c:	0e 05 
    f64e:	12 c3       	clrc			
    f650:	08 10       	rrc	r8		;
    f652:	78 53       	add.b	#-1,	r8	;r3 As==11
    f654:	49 48       	mov.b	r8,	r9	;

0000f656 <.LVL7>:
  if (index < MSP430X_DMA_CHANNELS) {
    f656:	6c 43       	mov.b	#2,	r12	;r3 As==10
    f658:	4c 98       	cmp.b	r8,	r12	;
    f65a:	30 28       	jnc	$+98     	;abs 0xf6bc

0000f65c <.LBB10>:
    dma_regs[index].ctl &= ~DMAEN;
    f65c:	4c 48       	mov.b	r8,	r12	;
    f65e:	0d 43       	clr	r13		;
    f660:	b0 13 30 cd 	calla	#52528		;0x0cd30
    f664:	0d 12       	push	r13		;
    f666:	0c 12       	push	r12		;
    f668:	0a 16       	popm.a	#1,	r10	;20-bit words
    f66a:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    f66e:	ba f0 ef ff 	and	#-17,	0(r10)	;#0xffef
    f672:	00 00 

0000f674 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    f674:	4d 43       	clr.b	r13		;
    f676:	4c 48       	mov.b	r8,	r12	;
    f678:	b0 13 02 56 	calla	#22018		;0x05602

0000f67c <.LVL9>:
    dma_regs[index].sz  = 0;
    f67c:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000f680 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    f680:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    f684:	00 00 

0000f686 <.Loc.87.1>:
    if (cb->callback != NULL) {
    f686:	8a 00 1a d1 	mova	#53530,	r10	;0x0d11a
    f68a:	08 49       	mov	r9,	r8	;
    f68c:	09 43       	clr	r9		;

0000f68e <.LVL11>:
    f68e:	0c 48       	mov	r8,	r12	;
    f690:	0d 49       	mov	r9,	r13	;
    f692:	b0 13 34 cd 	calla	#52532		;0x0cd34
    f696:	0d 12       	push	r13		;
    f698:	0c 12       	push	r12		;
    f69a:	0c 16       	popm.a	#1,	r12	;20-bit words
    f69c:	ec 0a       	adda	r10,	r12	;
    f69e:	06 0c       	mova	@r12,	r6	;
    f6a0:	96 00 00 00 	cmpa	#0,	r6	;
    f6a4:	0b 24       	jz	$+24     	;abs 0xf6bc

0000f6a6 <.Loc.88.1>:
      cb->callback(cb->args);
    f6a6:	0c 48       	mov	r8,	r12	;
    f6a8:	0d 49       	mov	r9,	r13	;
    f6aa:	b0 13 34 cd 	calla	#52532		;0x0cd34
    f6ae:	0d 12       	push	r13		;
    f6b0:	0c 12       	push	r12		;
    f6b2:	0c 16       	popm.a	#1,	r12	;20-bit words
    f6b4:	ea 0c       	adda	r12,	r10	;
    f6b6:	3c 0a 04 00 	mova	4(r10),	r12	;
    f6ba:	46 13       	calla	r6		;

0000f6bc <.L4>:
  OSAL_IRQ_EPILOGUE();
    f6bc:	b0 13 26 46 	calla	#17958		;0x04626

0000f6c0 <.LVL15>:
    f6c0:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f6c4:	96 13 
    f6c6:	b0 13 54 45 	calla	#17748		;0x04554

0000f6ca <.LVL16>:
    f6ca:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f6ce <.LVL17>:
    f6ce:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f6d0:	02 24       	jz	$+6      	;abs 0xf6d6

0000f6d2 <.Loc.92.1>:
    f6d2:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f6d6 <.L6>:
    f6d6:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f6da <.LVL19>:
}
    f6da:	b4 16       	popm.a	#12,	r15	;20-bit words
    f6dc:	00 13       	reti			

0000f6de <ISR_USCI_B0_VECTOR>:
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    f6de:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f6e0 <.LCFI23>:
  OSAL_IRQ_PROLOGUE();
    f6e0:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f6e4:	96 13 
    f6e6:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f6ea <.LVL90>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f6ea:	40 18 1c 42 	movx.w	&0x0066e,r12	;
    f6ee:	6e 06 
    f6f0:	8a 01 72 14 	mova	#70770,	r10	;0x11472
    f6f4:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    f6f8:	82 24       	jz	$+262    	;abs 0xf7fe
    f6fa:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    f6fe:	0d 9c       	cmp	r12,	r13	;
    f700:	6e 28       	jnc	$+222    	;abs 0xf7de
    f702:	3c 90 06 00 	cmp	#6,	r12	;
    f706:	7b 24       	jz	$+248    	;abs 0xf7fe
    f708:	7d 40 06 00 	mov.b	#6,	r13	;
    f70c:	0d 9c       	cmp	r12,	r13	;
    f70e:	48 28       	jnc	$+146    	;abs 0xf7a0
    f710:	2c 93       	cmp	#2,	r12	;r3 As==10
    f712:	98 24       	jz	$+306    	;abs 0xf844
    f714:	2c 92       	cmp	#4,	r12	;r2 As==10
    f716:	9a 24       	jz	$+310    	;abs 0xf84c

0000f718 <.L117>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    f718:	41 18 82 93 	cmpx.w	#0,	&0x11478;r3 As==00
    f71c:	78 14 
    f71e:	2f 24       	jz	$+96     	;abs 0xf77e

0000f720 <.LBB67>:
  chSysLockFromISR();
    f720:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f724 <.LBE68>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    f724:	17 4a 1c 00 	mov	28(r10),r7	;0x0001c
    f728:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    f72c:	19 4c 0a 00 	mov	10(r12),r9	;0x0000a

0000f730 <.LVL92>:
    dmaCancelI(&I2CDB0.dma);
    f730:	8c 01 a6 14 	mova	#70822,	r12	;0x114a6
    f734:	b0 13 ce 57 	calla	#22478		;0x057ce

0000f738 <.LVL93>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    f738:	40 18 fa b0 	bitx.b	#32,	6(r10)	;0x00020
    f73c:	20 00 06 00 
    f740:	04 24       	jz	$+10     	;abs 0xf74a

0000f742 <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    f742:	41 18 f2 40 	movx.b	#5,	&0x11472;
    f746:	05 00 72 14 

0000f74a <.L134>:
    if (NULL != I2CDB0.callback) {
    f74a:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    f74e:	98 00 00 00 	cmpa	#0,	r8	;
    f752:	09 24       	jz	$+20     	;abs 0xf766

0000f754 <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    f754:	40 18 0e 47 	movx.w	r7,	r14	;
    f758:	40 18 0e 89 	subx.w	r9,	r14	;
    f75c:	3d 0a 08 00 	mova	8(r10),	r13	;
    f760:	8c 01 72 14 	mova	#70770,	r12	;0x11472
    f764:	48 13       	calla	r8		;

0000f766 <.L135>:
    if (I2CDB0.thread != NULL) {
    f766:	01 18 c2 93 	cmpx.a	#0,	&0x114a0;r3 As==00
    f76a:	a0 14 
    f76c:	06 24       	jz	$+14     	;abs 0xf77a

0000f76e <.LBB70>:
  chThdResumeI(trp, msg);
    f76e:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    f772:	8c 01 a0 14 	mova	#70816,	r12	;0x114a0

0000f776 <.LVL96>:
    f776:	b0 13 30 4a 	calla	#18992		;0x04a30

0000f77a <.L136>:
  chSysUnlockFromISR();
    f77a:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f77e <.L133>:
  OSAL_IRQ_EPILOGUE();
    f77e:	b0 13 26 46 	calla	#17958		;0x04626

0000f782 <.LVL99>:
    f782:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f786:	96 13 
    f788:	b0 13 54 45 	calla	#17748		;0x04554

0000f78c <.LVL100>:
    f78c:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f790 <.LVL101>:
    f790:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f792:	02 24       	jz	$+6      	;abs 0xf798

0000f794 <.Loc.211.1>:
    f794:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f798 <.L137>:
    f798:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f79c <.LVL103>:
}
    f79c:	b4 16       	popm.a	#12,	r15	;20-bit words
    f79e:	00 13       	reti			

0000f7a0 <.L121>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f7a0:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    f7a4:	2c 24       	jz	$+90     	;abs 0xf7fe
    f7a6:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    f7aa:	29 24       	jz	$+84     	;abs 0xf7fe
    f7ac:	3c 92       	cmp	#8,	r12	;r2 As==11
    f7ae:	b4 23       	jnz	$-150    	;abs 0xf718

0000f7b0 <.Loc.126.1>:
      I2CDB0.state = I2C_READY;
    f7b0:	41 18 e2 43 	movx.b	#2,	&0x11472;r3 As==10
    f7b4:	72 14 

0000f7b6 <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    f7b6:	01 18 c2 93 	cmpx.a	#0,	&0x114a0;r3 As==00
    f7ba:	a0 14 
    f7bc:	0a 24       	jz	$+22     	;abs 0xf7d2

0000f7be <.LBB74>:
  chSysLockFromISR();
    f7be:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f7c2 <.LBB76>:
  chThdResumeI(trp, msg);
    f7c2:	4d 43       	clr.b	r13		;
    f7c4:	cc 0a       	mova	r10,	r12	;
    f7c6:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    f7ca:	b0 13 30 4a 	calla	#18992		;0x04a30

0000f7ce <.LBB78>:
  chSysUnlockFromISR();
    f7ce:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f7d2 <.L130>:
        dmaReleaseX(&(I2CDB0.dma));
    f7d2:	8c 01 a6 14 	mova	#70822,	r12	;0x114a6
    f7d6:	b0 13 94 57 	calla	#22420		;0x05794

0000f7da <.LVL107>:
      break;
    f7da:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f7de <.L119>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f7de:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    f7e2:	38 24       	jz	$+114    	;abs 0xf854
    f7e4:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    f7e8:	0d 9c       	cmp	r12,	r13	;
    f7ea:	0f 28       	jnc	$+32     	;abs 0xf80a
    f7ec:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    f7f0:	06 24       	jz	$+14     	;abs 0xf7fe
    f7f2:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    f7f6:	03 24       	jz	$+8      	;abs 0xf7fe
    f7f8:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    f7fc:	8d 23       	jnz	$-228    	;abs 0xf718

0000f7fe <.L127>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    f7fe:	8c 01 e4 03 	mova	#66532,	r12	;0x103e4
    f802:	b0 13 dc 47 	calla	#18396		;0x047dc

0000f806 <.LVL108>:
      break;
    f806:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f80a <.L126>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f80a:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    f80e:	f7 27       	jz	$-16     	;abs 0xf7fe
    f810:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    f814:	42 24       	jz	$+134    	;abs 0xf89a
    f816:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    f81a:	7e 23       	jnz	$-258    	;abs 0xf718

0000f81c <.Loc.158.1>:
      UCB0IE &= ~(UCTXIE);
    f81c:	40 18 a2 c3 	bicx.w	#2,	&0x0066a;r3 As==10
    f820:	6a 06 

0000f822 <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    f822:	01 18 c2 93 	cmpx.a	#0,	&0x114a0;r3 As==00
    f826:	a0 14 
    f828:	2e 20       	jnz	$+94     	;abs 0xf886

0000f82a <.Loc.162.1>:
        if (NULL != I2CDB0.callback) {
    f82a:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    f82e:	98 00 00 00 	cmpa	#0,	r8	;
    f832:	20 24       	jz	$+66     	;abs 0xf874

0000f834 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    f834:	1e 4a 1c 00 	mov	28(r10),r14	;0x0001c
    f838:	3d 0a 08 00 	mova	8(r10),	r13	;
    f83c:	cc 0a       	mova	r10,	r12	;
    f83e:	48 13       	calla	r8		;

0000f840 <.LVL109>:
    f840:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f844 <.L122>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    f844:	aa d3 06 00 	bis	#2,	6(r10)	;r3 As==10

0000f848 <.Loc.116.1>:
      break;
    f848:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f84c <.L123>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    f84c:	aa d2 06 00 	bis	#4,	6(r10)	;r2 As==10

0000f850 <.Loc.120.1>:
      break;
    f850:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f854 <.L125>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    f854:	40 18 1d 42 	movx.w	&0x0064c,r13	;
    f858:	4c 06 
    f85a:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    f85e:	1c 00 
    f860:	00 18 5c 5a 	addx.a	24(r10),r12	;0x00018
    f864:	18 00 
    f866:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000f86a <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    f86a:	40 18 92 c3 	bicx.w	#1,	&0x0066a;r3 As==01
    f86e:	6a 06 

0000f870 <.Loc.155.1>:
      break;
    f870:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f874 <.L132>:
  chSysLockFromISR();
    f874:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f878 <.LBE80>:
          i2cMSP430XEndTransferI(&I2CDB0);
    f878:	cc 0a       	mova	r10,	r12	;
    f87a:	b0 13 aa 5f 	calla	#24490		;0x05faa

0000f87e <.L165>:
  chSysUnlockFromISR();
    f87e:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f882 <.LVL112>:
    f882:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f886 <.L131>:
  chSysLockFromISR();
    f886:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f88a <.LBB86>:
  chThdResumeI(trp, msg);
    f88a:	4d 43       	clr.b	r13		;
    f88c:	cc 0a       	mova	r10,	r12	;
    f88e:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    f892:	b0 13 30 4a 	calla	#18992		;0x04a30

0000f896 <.LVL114>:
    f896:	80 00 7e f8 	mova	#63614,	r0	;0x0f87e

0000f89a <.L128>:
      I2CDB0.errors |= I2C_TIMEOUT;
    f89a:	ba d0 20 00 	bis	#32,	6(r10)	;#0x0020
    f89e:	06 00 

0000f8a0 <.Loc.185.1>:
      break;
    f8a0:	80 00 18 f7 	mova	#63256,	r0	;0x0f718

0000f8a4 <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    f8a4:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f8a6 <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    f8a6:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f8aa:	96 13 
    f8ac:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f8b0 <.LVL89>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    f8b0:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    f8b4:	fe 05 
    f8b6:	2c 92       	cmp	#4,	r12	;r2 As==10
    f8b8:	86 24       	jz	$+270    	;abs 0xf9c6
    f8ba:	6d 42       	mov.b	#4,	r13	;r2 As==10
    f8bc:	0d 9c       	cmp	r12,	r13	;
    f8be:	13 28       	jnc	$+40     	;abs 0xf8e6
    f8c0:	2c 93       	cmp	#2,	r12	;r3 As==10
    f8c2:	35 24       	jz	$+108    	;abs 0xf92e

0000f8c4 <.L56>:
  OSAL_IRQ_EPILOGUE();
    f8c4:	b0 13 26 46 	calla	#17958		;0x04626

0000f8c8 <.LVL90>:
    f8c8:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    f8cc:	96 13 
    f8ce:	b0 13 54 45 	calla	#17748		;0x04554

0000f8d2 <.LVL91>:
    f8d2:	b0 13 5a 49 	calla	#18778		;0x0495a

0000f8d6 <.LVL92>:
    f8d6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f8d8:	02 24       	jz	$+6      	;abs 0xf8de

0000f8da <.Loc.311.1>:
    f8da:	b0 13 6a 49 	calla	#18794		;0x0496a

0000f8de <.L70>:
    f8de:	b0 13 7c 45 	calla	#17788		;0x0457c

0000f8e2 <.LVL94>:
}
    f8e2:	b4 16       	popm.a	#12,	r15	;20-bit words
    f8e4:	00 13       	reti			

0000f8e6 <.L58>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    f8e6:	3c 90 06 00 	cmp	#6,	r12	;
    f8ea:	6d 24       	jz	$+220    	;abs 0xf9c6
    f8ec:	3c 92       	cmp	#8,	r12	;r2 As==11
    f8ee:	ea 23       	jnz	$-42     	;abs 0xf8c4

0000f8f0 <.Loc.303.1>:
      _uart_tx2_isr_code(&UARTDA1);
    f8f0:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    f8f4:	3e 0c 04 00 	mova	4(r12),	r14	;
    f8f8:	3e 0e 04 00 	mova	4(r14),	r14	;
    f8fc:	9e 00 00 00 	cmpa	#0,	r14	;
    f900:	01 24       	jz	$+4      	;abs 0xf904

0000f902 <.Loc.303.1>:
    f902:	4e 13       	calla	r14		;

0000f904 <.L68>:
    f904:	41 18 c2 93 	cmpx.b	#0,	&0x114b8;r3 As==00
    f908:	b8 14 
    f90a:	09 20       	jnz	$+20     	;abs 0xf91e

0000f90c <.LBB75>:
  chSysLockFromISR();
    f90c:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f910 <.LBB77>:
  chThdResumeI(trp, msg);
    f910:	4d 43       	clr.b	r13		;
    f912:	8c 01 be 14 	mova	#70846,	r12	;0x114be

0000f916 <.LVL97>:
    f916:	b0 13 30 4a 	calla	#18992		;0x04a30

0000f91a <.LBB79>:
  chSysUnlockFromISR();
    f91a:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f91e <.L69>:
      UCA1IE &= ~UCTXCPTIE;
    f91e:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    f922:	fa 05 

0000f924 <.Loc.307.1>:
      UCA1IFG &= ~UCTXCPTIFG;
    f924:	40 18 b2 c2 	bicx.w	#8,	&0x005fc;r2 As==11
    f928:	fc 05 

0000f92a <.Loc.308.1>:
      break;
    f92a:	80 00 c4 f8 	mova	#63684,	r0	;0x0f8c4

0000f92e <.L59>:
    f92e:	8a 01 b0 14 	mova	#70832,	r10	;0x114b0

0000f932 <.Loc.272.1>:
      if (UCA1STATW & UCRXERR) {
    f932:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    f936:	ea 05 
    f938:	2e 24       	jz	$+94     	;abs 0xf996

0000f93a <.LBB81>:
        if (UCA1STATW & UCBRK)
    f93a:	40 18 f2 b2 	bitx.b	#8,	&0x005ea;r2 As==11
    f93e:	ea 05 
    f940:	39 24       	jz	$+116    	;abs 0xf9b4

0000f942 <.Loc.277.1>:
          sts |= UART_BREAK_DETECTED;
    f942:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    f946:	4e 43       	clr.b	r14		;

0000f948 <.L62>:
        if (UCA1STATW & UCOE)
    f948:	40 18 f2 b0 	bitx.b	#32,	&0x005ea;0x00020
    f94c:	20 00 ea 05 
    f950:	02 24       	jz	$+6      	;abs 0xf956

0000f952 <.Loc.279.1>:
          sts |= UART_OVERRUN_ERROR;
    f952:	3d d0 10 00 	bis	#16,	r13	;#0x0010

0000f956 <.L63>:
        if (UCA1STATW & UCFE)
    f956:	40 18 f2 b0 	bitx.b	#64,	&0x005ea;0x00040
    f95a:	40 00 ea 05 
    f95e:	01 24       	jz	$+4      	;abs 0xf962

0000f960 <.Loc.281.1>:
          sts |= UART_FRAMING_ERROR;
    f960:	3d d2       	bis	#8,	r13	;r2 As==11

0000f962 <.L64>:
        if (UCA1STATW & UCPE)
    f962:	40 18 f2 b0 	bitx.b	#16,	&0x005ea;0x00010
    f966:	10 00 ea 05 
    f96a:	01 24       	jz	$+4      	;abs 0xf96e

0000f96c <.Loc.283.1>:
          sts |= UART_PARITY_ERROR;
    f96c:	2d d2       	bis	#4,	r13	;r2 As==10

0000f96e <.L65>:
        _uart_rx_error_isr_code(&UARTDA1, sts);
    f96e:	3c 0a 04 00 	mova	4(r10),	r12	;
    f972:	38 0c 10 00 	mova	16(r12),r8	;0x00010
    f976:	98 00 00 00 	cmpa	#0,	r8	;
    f97a:	03 24       	jz	$+8      	;abs 0xf982

0000f97c <.Loc.285.1>:
    f97c:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    f980:	48 13       	calla	r8		;

0000f982 <.L66>:
  chSysLockFromISR();
    f982:	b0 13 a6 45 	calla	#17830		;0x045a6

0000f986 <.LBB84>:
  chThdResumeI(trp, msg);
    f986:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    f98a:	8c 01 ba 14 	mova	#70842,	r12	;0x114ba

0000f98e <.LVL107>:
    f98e:	b0 13 30 4a 	calla	#18992		;0x04a30

0000f992 <.LBB86>:
  chSysUnlockFromISR();
    f992:	b0 13 d0 45 	calla	#17872		;0x045d0

0000f996 <.L61>:
      if (UARTDA1.config->rxchar_cb != NULL) {
    f996:	3c 0a 04 00 	mova	4(r10),	r12	;
    f99a:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    f99e:	9e 00 00 00 	cmpa	#0,	r14	;
    f9a2:	0c 24       	jz	$+26     	;abs 0xf9bc

0000f9a4 <.Loc.290.1>:
        UARTDA1.config->rxchar_cb(&UARTDA1, UCA1RXBUF);
    f9a4:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    f9a8:	ec 05 
    f9aa:	8c 01 b0 14 	mova	#70832,	r12	;0x114b0
    f9ae:	4e 13       	calla	r14		;

0000f9b0 <.LVL110>:
    f9b0:	80 00 c4 f8 	mova	#63684,	r0	;0x0f8c4

0000f9b4 <.L71>:
        uartflags_t sts = 0;
    f9b4:	4d 43       	clr.b	r13		;
    f9b6:	0e 4d       	mov	r13,	r14	;
    f9b8:	80 00 48 f9 	mova	#63816,	r0	;0x0f948

0000f9bc <.L67>:
        UCA1IFG &= ~UCRXIFG;
    f9bc:	40 18 92 c3 	bicx.w	#1,	&0x005fc;r3 As==01
    f9c0:	fc 05 
    f9c2:	80 00 c4 f8 	mova	#63684,	r0	;0x0f8c4

0000f9c6 <.L57>:
      osalDbgAssert(false, "Spurious interrupt in USCI A1 UART");
    f9c6:	8c 01 06 04 	mova	#66566,	r12	;0x10406
    f9ca:	b0 13 dc 47 	calla	#18396		;0x047dc

0000f9ce <.LVL113>:
      break;
    f9ce:	80 00 c4 f8 	mova	#63684,	r0	;0x0f8c4

0000f9d2 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    f9d2:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f9d4 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f9d4:	41 18 d2 43 	movx.b	#1,	&0x11396;r3 As==01
    f9d8:	96 13 
    f9da:	b0 13 fa 45 	calla	#17914		;0x045fa

0000f9de <.LVL21>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    f9de:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    f9e2:	ae 03 
    f9e4:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    f9e8:	1b 20       	jnz	$+56     	;abs 0xfa20

0000f9ea <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    f9ea:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    f9ee:	6d 4c       	mov.b	@r12,	r13	;
    f9f0:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    f9f4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    f9f6:	4e 9d       	cmp.b	r13,	r14	;
    f9f8:	08 28       	jnc	$+18     	;abs 0xfa0a

0000f9fa <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    f9fa:	3e 0c 02 00 	mova	2(r12),	r14	;
    f9fe:	3e 0e 04 00 	mova	4(r14),	r14	;

0000fa02 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    fa02:	9e 00 00 00 	cmpa	#0,	r14	;
    fa06:	01 24       	jz	$+4      	;abs 0xfa0a

0000fa08 <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    fa08:	4e 13       	calla	r14		;

0000fa0a <.L22>:
      if (GPTDA1.state == GPT_ONESHOT) {
    fa0a:	41 18 e2 92 	cmpx.b	#4,	&0x11514;r2 As==10
    fa0e:	14 15 
    fa10:	07 20       	jnz	$+16     	;abs 0xfa20

0000fa12 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    fa12:	41 18 e2 43 	movx.b	#2,	&0x11514;r3 As==10
    fa16:	14 15 

0000fa18 <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    fa18:	8c 01 14 15 	mova	#70932,	r12	;0x11514
    fa1c:	b0 13 70 67 	calla	#26480		;0x06770

0000fa20 <.L20>:
  OSAL_IRQ_EPILOGUE();
    fa20:	b0 13 26 46 	calla	#17958		;0x04626

0000fa24 <.LVL24>:
    fa24:	41 18 c2 43 	movx.b	#0,	&0x11396;r3 As==00
    fa28:	96 13 
    fa2a:	b0 13 54 45 	calla	#17748		;0x04554

0000fa2e <.LVL25>:
    fa2e:	b0 13 5a 49 	calla	#18778		;0x0495a

0000fa32 <.LVL26>:
    fa32:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    fa34:	02 24       	jz	$+6      	;abs 0xfa3a

0000fa36 <.Loc.135.1>:
    fa36:	b0 13 6a 49 	calla	#18794		;0x0496a

0000fa3a <.L23>:
    fa3a:	b0 13 7c 45 	calla	#17788		;0x0457c

0000fa3e <.LVL28>:
}
    fa3e:	b4 16       	popm.a	#12,	r15	;20-bit words
    fa40:	00 13       	reti			
