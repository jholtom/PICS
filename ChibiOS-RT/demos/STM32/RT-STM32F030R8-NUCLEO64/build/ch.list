
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000100 <Reset_Handler>:
 8000100:	b672      	cpsid	i
 8000102:	4822      	ldr	r0, [pc, #136]	; (800018c <endfiniloop+0x4>)
 8000104:	f380 8809 	msr	PSP, r0
 8000108:	2002      	movs	r0, #2
 800010a:	f380 8814 	msr	CONTROL, r0
 800010e:	f3bf 8f6f 	isb	sy
 8000112:	f003 fdcd 	bl	8003cb0 <__core_init>
 8000116:	f005 fcb3 	bl	8005a80 <__early_init>
 800011a:	481d      	ldr	r0, [pc, #116]	; (8000190 <endfiniloop+0x8>)
 800011c:	491d      	ldr	r1, [pc, #116]	; (8000194 <endfiniloop+0xc>)
 800011e:	4a1e      	ldr	r2, [pc, #120]	; (8000198 <endfiniloop+0x10>)

08000120 <msloop>:
 8000120:	4291      	cmp	r1, r2
 8000122:	da02      	bge.n	800012a <endmsloop>
 8000124:	6008      	str	r0, [r1, #0]
 8000126:	3104      	adds	r1, #4
 8000128:	e7fa      	b.n	8000120 <msloop>

0800012a <endmsloop>:
 800012a:	491c      	ldr	r1, [pc, #112]	; (800019c <endfiniloop+0x14>)
 800012c:	4a17      	ldr	r2, [pc, #92]	; (800018c <endfiniloop+0x4>)

0800012e <psloop>:
 800012e:	4291      	cmp	r1, r2
 8000130:	da02      	bge.n	8000138 <endpsloop>
 8000132:	6008      	str	r0, [r1, #0]
 8000134:	3104      	adds	r1, #4
 8000136:	e7fa      	b.n	800012e <psloop>

08000138 <endpsloop>:
 8000138:	4919      	ldr	r1, [pc, #100]	; (80001a0 <endfiniloop+0x18>)
 800013a:	4a1a      	ldr	r2, [pc, #104]	; (80001a4 <endfiniloop+0x1c>)
 800013c:	4b1a      	ldr	r3, [pc, #104]	; (80001a8 <endfiniloop+0x20>)

0800013e <dloop>:
 800013e:	429a      	cmp	r2, r3
 8000140:	da04      	bge.n	800014c <enddloop>
 8000142:	6808      	ldr	r0, [r1, #0]
 8000144:	6010      	str	r0, [r2, #0]
 8000146:	3104      	adds	r1, #4
 8000148:	3204      	adds	r2, #4
 800014a:	e7f8      	b.n	800013e <dloop>

0800014c <enddloop>:
 800014c:	2000      	movs	r0, #0
 800014e:	4917      	ldr	r1, [pc, #92]	; (80001ac <endfiniloop+0x24>)
 8000150:	4a17      	ldr	r2, [pc, #92]	; (80001b0 <endfiniloop+0x28>)

08000152 <bloop>:
 8000152:	4291      	cmp	r1, r2
 8000154:	da02      	bge.n	800015c <endbloop>
 8000156:	6008      	str	r0, [r1, #0]
 8000158:	3104      	adds	r1, #4
 800015a:	e7fa      	b.n	8000152 <bloop>

0800015c <endbloop>:
 800015c:	f003 fd70 	bl	8003c40 <__init_ram_areas>
 8000160:	f003 fd9e 	bl	8003ca0 <__late_init>
 8000164:	4c13      	ldr	r4, [pc, #76]	; (80001b4 <endfiniloop+0x2c>)
 8000166:	4d14      	ldr	r5, [pc, #80]	; (80001b8 <endfiniloop+0x30>)

08000168 <initloop>:
 8000168:	42ac      	cmp	r4, r5
 800016a:	da03      	bge.n	8000174 <endinitloop>
 800016c:	6821      	ldr	r1, [r4, #0]
 800016e:	4788      	blx	r1
 8000170:	3404      	adds	r4, #4
 8000172:	e7f9      	b.n	8000168 <initloop>

08000174 <endinitloop>:
 8000174:	f005 f98c 	bl	8005490 <main>
 8000178:	4c10      	ldr	r4, [pc, #64]	; (80001bc <endfiniloop+0x34>)
 800017a:	4d11      	ldr	r5, [pc, #68]	; (80001c0 <endfiniloop+0x38>)

0800017c <finiloop>:
 800017c:	42ac      	cmp	r4, r5
 800017e:	da03      	bge.n	8000188 <endfiniloop>
 8000180:	6821      	ldr	r1, [r4, #0]
 8000182:	4788      	blx	r1
 8000184:	3404      	adds	r4, #4
 8000186:	e7f9      	b.n	800017c <finiloop>

08000188 <endfiniloop>:
 8000188:	490e      	ldr	r1, [pc, #56]	; (80001c4 <endfiniloop+0x3c>)
 800018a:	4708      	bx	r1
 800018c:	20000400 	.word	0x20000400
 8000190:	55555555 	.word	0x55555555
 8000194:	20000000 	.word	0x20000000
 8000198:	20000200 	.word	0x20000200
 800019c:	20000200 	.word	0x20000200
 80001a0:	08006eb0 	.word	0x08006eb0
 80001a4:	20000400 	.word	0x20000400
 80001a8:	200004b0 	.word	0x200004b0
 80001ac:	200004b0 	.word	0x200004b0
 80001b0:	20000f50 	.word	0x20000f50
 80001b4:	08000100 	.word	0x08000100
 80001b8:	08000100 	.word	0x08000100
 80001bc:	08000100 	.word	0x08000100
 80001c0:	08000100 	.word	0x08000100
 80001c4:	08003c91 	.word	0x08003c91
	...

080001d0 <_port_switch>:
 80001d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001d2:	4644      	mov	r4, r8
 80001d4:	464d      	mov	r5, r9
 80001d6:	4656      	mov	r6, sl
 80001d8:	465f      	mov	r7, fp
 80001da:	b4f0      	push	{r4, r5, r6, r7}
 80001dc:	466b      	mov	r3, sp
 80001de:	60cb      	str	r3, [r1, #12]
 80001e0:	68c3      	ldr	r3, [r0, #12]
 80001e2:	469d      	mov	sp, r3
 80001e4:	bcf0      	pop	{r4, r5, r6, r7}
 80001e6:	46a0      	mov	r8, r4
 80001e8:	46a9      	mov	r9, r5
 80001ea:	46b2      	mov	sl, r6
 80001ec:	46bb      	mov	fp, r7
 80001ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001f0 <_port_thread_start>:
 80001f0:	b662      	cpsie	i
 80001f2:	1c28      	adds	r0, r5, #0
 80001f4:	47a0      	blx	r4
 80001f6:	2000      	movs	r0, #0
 80001f8:	f003 fcda 	bl	8003bb0 <chThdExit>

080001fc <_port_switch_from_isr>:
 80001fc:	f003 fd00 	bl	8003c00 <chSchDoReschedule>

08000200 <_port_exit_from_isr>:
 8000200:	4a01      	ldr	r2, [pc, #4]	; (8000208 <_port_exit_from_isr+0x8>)
 8000202:	4b02      	ldr	r3, [pc, #8]	; (800020c <_port_exit_from_isr+0xc>)
 8000204:	6013      	str	r3, [r2, #0]
 8000206:	e7fe      	b.n	8000206 <_port_exit_from_isr+0x6>
 8000208:	e000ed04 	.word	0xe000ed04
 800020c:	80000000 	.word	0x80000000

08000210 <__aeabi_uidiv>:
 8000210:	2900      	cmp	r1, #0
 8000212:	d034      	beq.n	800027e <.udivsi3_skip_div0_test+0x6a>

08000214 <.udivsi3_skip_div0_test>:
 8000214:	2301      	movs	r3, #1
 8000216:	2200      	movs	r2, #0
 8000218:	b410      	push	{r4}
 800021a:	4288      	cmp	r0, r1
 800021c:	d32c      	bcc.n	8000278 <.udivsi3_skip_div0_test+0x64>
 800021e:	2401      	movs	r4, #1
 8000220:	0724      	lsls	r4, r4, #28
 8000222:	42a1      	cmp	r1, r4
 8000224:	d204      	bcs.n	8000230 <.udivsi3_skip_div0_test+0x1c>
 8000226:	4281      	cmp	r1, r0
 8000228:	d202      	bcs.n	8000230 <.udivsi3_skip_div0_test+0x1c>
 800022a:	0109      	lsls	r1, r1, #4
 800022c:	011b      	lsls	r3, r3, #4
 800022e:	e7f8      	b.n	8000222 <.udivsi3_skip_div0_test+0xe>
 8000230:	00e4      	lsls	r4, r4, #3
 8000232:	42a1      	cmp	r1, r4
 8000234:	d204      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 8000236:	4281      	cmp	r1, r0
 8000238:	d202      	bcs.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 800023a:	0049      	lsls	r1, r1, #1
 800023c:	005b      	lsls	r3, r3, #1
 800023e:	e7f8      	b.n	8000232 <.udivsi3_skip_div0_test+0x1e>
 8000240:	4288      	cmp	r0, r1
 8000242:	d301      	bcc.n	8000248 <.udivsi3_skip_div0_test+0x34>
 8000244:	1a40      	subs	r0, r0, r1
 8000246:	431a      	orrs	r2, r3
 8000248:	084c      	lsrs	r4, r1, #1
 800024a:	42a0      	cmp	r0, r4
 800024c:	d302      	bcc.n	8000254 <.udivsi3_skip_div0_test+0x40>
 800024e:	1b00      	subs	r0, r0, r4
 8000250:	085c      	lsrs	r4, r3, #1
 8000252:	4322      	orrs	r2, r4
 8000254:	088c      	lsrs	r4, r1, #2
 8000256:	42a0      	cmp	r0, r4
 8000258:	d302      	bcc.n	8000260 <.udivsi3_skip_div0_test+0x4c>
 800025a:	1b00      	subs	r0, r0, r4
 800025c:	089c      	lsrs	r4, r3, #2
 800025e:	4322      	orrs	r2, r4
 8000260:	08cc      	lsrs	r4, r1, #3
 8000262:	42a0      	cmp	r0, r4
 8000264:	d302      	bcc.n	800026c <.udivsi3_skip_div0_test+0x58>
 8000266:	1b00      	subs	r0, r0, r4
 8000268:	08dc      	lsrs	r4, r3, #3
 800026a:	4322      	orrs	r2, r4
 800026c:	2800      	cmp	r0, #0
 800026e:	d003      	beq.n	8000278 <.udivsi3_skip_div0_test+0x64>
 8000270:	091b      	lsrs	r3, r3, #4
 8000272:	d001      	beq.n	8000278 <.udivsi3_skip_div0_test+0x64>
 8000274:	0909      	lsrs	r1, r1, #4
 8000276:	e7e3      	b.n	8000240 <.udivsi3_skip_div0_test+0x2c>
 8000278:	1c10      	adds	r0, r2, #0
 800027a:	bc10      	pop	{r4}
 800027c:	4770      	bx	lr
 800027e:	2800      	cmp	r0, #0
 8000280:	d001      	beq.n	8000286 <.udivsi3_skip_div0_test+0x72>
 8000282:	2000      	movs	r0, #0
 8000284:	43c0      	mvns	r0, r0
 8000286:	b407      	push	{r0, r1, r2}
 8000288:	4802      	ldr	r0, [pc, #8]	; (8000294 <.udivsi3_skip_div0_test+0x80>)
 800028a:	a102      	add	r1, pc, #8	; (adr r1, 8000294 <.udivsi3_skip_div0_test+0x80>)
 800028c:	1840      	adds	r0, r0, r1
 800028e:	9002      	str	r0, [sp, #8]
 8000290:	bd03      	pop	{r0, r1, pc}
 8000292:	46c0      	nop			; (mov r8, r8)
 8000294:	0000001d 	.word	0x0000001d

08000298 <__aeabi_uidivmod>:
 8000298:	2900      	cmp	r1, #0
 800029a:	d0f0      	beq.n	800027e <.udivsi3_skip_div0_test+0x6a>
 800029c:	b503      	push	{r0, r1, lr}
 800029e:	f7ff ffb9 	bl	8000214 <.udivsi3_skip_div0_test>
 80002a2:	bc0e      	pop	{r1, r2, r3}
 80002a4:	4342      	muls	r2, r0
 80002a6:	1a89      	subs	r1, r1, r2
 80002a8:	4718      	bx	r3
 80002aa:	46c0      	nop			; (mov r8, r8)
 80002ac:	0000      	movs	r0, r0
	...

080002b0 <__aeabi_idiv0>:
 80002b0:	4770      	bx	lr
 80002b2:	46c0      	nop			; (mov r8, r8)
	...

080002c0 <test_010_001_setup.10302>:

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80002c0:	4b07      	ldr	r3, [pc, #28]	; (80002e0 <test_010_001_setup.10302+0x20>)
  H_NEXT(&heapp->header) = hp;
 80002c2:	4908      	ldr	r1, [pc, #32]	; (80002e4 <test_010_001_setup.10302+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80002c4:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80002c6:	20cc      	movs	r0, #204	; 0xcc
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 80002c8:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
 80002ca:	600a      	str	r2, [r1, #0]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80002cc:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80002ce:	1c19      	adds	r1, r3, #0
 80002d0:	3110      	adds	r1, #16

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80002d2:	601a      	str	r2, [r3, #0]
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
 80002d4:	60da      	str	r2, [r3, #12]
 80002d6:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 80002d8:	6159      	str	r1, [r3, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 80002da:	619a      	str	r2, [r3, #24]
 * .
 */

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}
 80002dc:	4770      	bx	lr
 80002de:	46c0      	nop			; (mov r8, r8)
 80002e0:	200004b0 	.word	0x200004b0
 80002e4:	20000518 	.word	0x20000518
 80002e8:	46c0      	nop			; (mov r8, r8)
 80002ea:	46c0      	nop			; (mov r8, r8)
 80002ec:	46c0      	nop			; (mov r8, r8)
 80002ee:	46c0      	nop			; (mov r8, r8)

080002f0 <tmo.10591>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 80002f0:	4770      	bx	lr
 80002f2:	46c0      	nop			; (mov r8, r8)
 80002f4:	46c0      	nop			; (mov r8, r8)
 80002f6:	46c0      	nop			; (mov r8, r8)
 80002f8:	46c0      	nop			; (mov r8, r8)
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	46c0      	nop			; (mov r8, r8)
 80002fe:	46c0      	nop			; (mov r8, r8)

08000300 <test_011_002_setup.10431>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8000300:	4b03      	ldr	r3, [pc, #12]	; (8000310 <test_011_002_setup.10431+0x10>)
  mp->object_size = size;
 8000302:	21a4      	movs	r1, #164	; 0xa4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8000304:	2200      	movs	r2, #0
  mp->object_size = size;
 8000306:	0049      	lsls	r1, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8000308:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 800030a:	6059      	str	r1, [r3, #4]
  mp->provider = provider;
 800030c:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 800030e:	4770      	bx	lr
 8000310:	20000bd8 	.word	0x20000bd8
 8000314:	46c0      	nop			; (mov r8, r8)
 8000316:	46c0      	nop			; (mov r8, r8)
 8000318:	46c0      	nop			; (mov r8, r8)
 800031a:	46c0      	nop			; (mov r8, r8)
 800031c:	46c0      	nop			; (mov r8, r8)
 800031e:	46c0      	nop			; (mov r8, r8)

08000320 <null_provider.10158>:

  (void)size;
  (void)align;

  return NULL;
}
 8000320:	2000      	movs	r0, #0
 8000322:	4770      	bx	lr
 8000324:	46c0      	nop			; (mov r8, r8)
 8000326:	46c0      	nop			; (mov r8, r8)
 8000328:	46c0      	nop			; (mov r8, r8)
 800032a:	46c0      	nop			; (mov r8, r8)
 800032c:	46c0      	nop			; (mov r8, r8)
 800032e:	46c0      	nop			; (mov r8, r8)

08000330 <test_004_004_setup.9156>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000330:	4b02      	ldr	r3, [pc, #8]	; (800033c <test_004_004_setup.9156+0xc>)
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8000332:	2200      	movs	r2, #0
 8000334:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000336:	605b      	str	r3, [r3, #4]
 8000338:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_004_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 800033a:	4770      	bx	lr
 800033c:	20000508 	.word	0x20000508

08000340 <test_003_001_setup.8958>:
 *   the state of the reference are tested.
 * .
 */

static void test_003_001_setup(void) {
  tr1 = NULL;
 8000340:	4b01      	ldr	r3, [pc, #4]	; (8000348 <test_003_001_setup.8958+0x8>)
 8000342:	2200      	movs	r2, #0
 8000344:	601a      	str	r2, [r3, #0]
}
 8000346:	4770      	bx	lr
 8000348:	20000b80 	.word	0x20000b80
 800034c:	46c0      	nop			; (mov r8, r8)
 800034e:	46c0      	nop			; (mov r8, r8)

08000350 <test_001_004_execute.8553>:

static void test_001_004_execute(void) {

  /* [1.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8000350:	4b05      	ldr	r3, [pc, #20]	; (8000368 <test_001_004_execute.8553+0x18>)
 8000352:	2201      	movs	r2, #1
 8000354:	601a      	str	r2, [r3, #0]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000356:	4a05      	ldr	r2, [pc, #20]	; (800036c <test_001_004_execute.8553+0x1c>)
 8000358:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800035a:	b289      	uxth	r1, r1
 800035c:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 800035e:	b29b      	uxth	r3, r3
 8000360:	4299      	cmp	r1, r3
 8000362:	d0fb      	beq.n	800035c <test_001_004_execute.8553+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 8000364:	4770      	bx	lr
 8000366:	46c0      	nop			; (mov r8, r8)
 8000368:	20000f44 	.word	0x20000f44
 800036c:	40000400 	.word	0x40000400

08000370 <test_001_003_execute.8551>:

static void test_001_003_execute(void) {

  /* [1.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 8000370:	4b03      	ldr	r3, [pc, #12]	; (8000380 <test_001_003_execute.8551+0x10>)
 8000372:	2201      	movs	r2, #1
 8000374:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000376:	b672      	cpsid	i
 8000378:	b672      	cpsid	i
 800037a:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037c:	b662      	cpsie	i
    chSysSuspend();
    chSysDisable();
    chSysSuspend();
    chSysEnable();
  }
}
 800037e:	4770      	bx	lr
 8000380:	20000f44 	.word	0x20000f44
 8000384:	46c0      	nop			; (mov r8, r8)
 8000386:	46c0      	nop			; (mov r8, r8)
 8000388:	46c0      	nop			; (mov r8, r8)
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <notify2.8147>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8000390:	4b02      	ldr	r3, [pc, #8]	; (800039c <notify2.8147+0xc>)
 8000392:	2280      	movs	r2, #128	; 0x80
 8000394:	6819      	ldr	r1, [r3, #0]
 8000396:	430a      	orrs	r2, r1
 8000398:	601a      	str	r2, [r3, #0]
}
 800039a:	4770      	bx	lr
 800039c:	40004400 	.word	0x40004400

080003a0 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80003a0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80003a4:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80003a6:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003aa:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80003ac:	4770      	bx	lr
 80003ae:	46c0      	nop			; (mov r8, r8)

080003b0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80003b0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003b2:	b672      	cpsid	i
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80003b4:	1e4a      	subs	r2, r1, #1
 80003b6:	1810      	adds	r0, r2, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80003b8:	4a09      	ldr	r2, [pc, #36]	; (80003e0 <chCoreAllocAligned+0x30>)
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80003ba:	424b      	negs	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80003bc:	6814      	ldr	r4, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80003be:	4018      	ands	r0, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80003c0:	3c01      	subs	r4, #1
 80003c2:	1861      	adds	r1, r4, r1
 80003c4:	4019      	ands	r1, r3

  if (((size_t)endmem - (size_t)p) < size) {
 80003c6:	4b07      	ldr	r3, [pc, #28]	; (80003e4 <chCoreAllocAligned+0x34>)
 80003c8:	681b      	ldr	r3, [r3, #0]
 80003ca:	1a5b      	subs	r3, r3, r1
 80003cc:	4298      	cmp	r0, r3
 80003ce:	d804      	bhi.n	80003da <chCoreAllocAligned+0x2a>
    return NULL;
  }
  nextmem = p + size;
 80003d0:	1808      	adds	r0, r1, r0
 80003d2:	6010      	str	r0, [r2, #0]

  return p;
 80003d4:	1c08      	adds	r0, r1, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003d6:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 80003d8:	bd10      	pop	{r4, pc}

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 80003da:	2000      	movs	r0, #0
 80003dc:	e7fb      	b.n	80003d6 <chCoreAllocAligned+0x26>
 80003de:	46c0      	nop			; (mov r8, r8)
 80003e0:	20000f4c 	.word	0x20000f4c
 80003e4:	20000f48 	.word	0x20000f48
 80003e8:	46c0      	nop			; (mov r8, r8)
 80003ea:	46c0      	nop			; (mov r8, r8)
 80003ec:	46c0      	nop			; (mov r8, r8)
 80003ee:	46c0      	nop			; (mov r8, r8)

080003f0 <wakeup.4588>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003f0:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 80003f2:	2320      	movs	r3, #32
 80003f4:	5cc3      	ldrb	r3, [r0, r3]
 80003f6:	2b07      	cmp	r3, #7
 80003f8:	d80c      	bhi.n	8000414 <wakeup.4588+0x24>
 80003fa:	4a12      	ldr	r2, [pc, #72]	; (8000444 <wakeup.4588+0x54>)
 80003fc:	009b      	lsls	r3, r3, #2
 80003fe:	58d3      	ldr	r3, [r2, r3]
 8000400:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8000402:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000404:	689a      	ldr	r2, [r3, #8]
 8000406:	3201      	adds	r2, #1
 8000408:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800040a:	6843      	ldr	r3, [r0, #4]
 800040c:	6801      	ldr	r1, [r0, #0]
 800040e:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000410:	6802      	ldr	r2, [r0, #0]
 8000412:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000414:	2301      	movs	r3, #1
 8000416:	425b      	negs	r3, r3
 8000418:	6243      	str	r3, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800041a:	2200      	movs	r2, #0
 800041c:	2320      	movs	r3, #32
 800041e:	54c2      	strb	r2, [r0, r3]
 8000420:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000422:	4b09      	ldr	r3, [pc, #36]	; (8000448 <wakeup.4588+0x58>)
  do {
    cp = cp->queue.next;
 8000424:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000426:	6899      	ldr	r1, [r3, #8]
 8000428:	4291      	cmp	r1, r2
 800042a:	d2fb      	bcs.n	8000424 <wakeup.4588+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800042c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800042e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000430:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000432:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000434:	6058      	str	r0, [r3, #4]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000436:	b662      	cpsie	i
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000438:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800043a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800043c:	2200      	movs	r2, #0
 800043e:	601a      	str	r2, [r3, #0]
 8000440:	e7e8      	b.n	8000414 <wakeup.4588+0x24>
 8000442:	46c0      	nop			; (mov r8, r8)
 8000444:	08005b40 	.word	0x08005b40
 8000448:	20000ed4 	.word	0x20000ed4
 800044c:	46c0      	nop			; (mov r8, r8)
 800044e:	46c0      	nop			; (mov r8, r8)

08000450 <chSysIntegrityCheckI.4476>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000450:	b530      	push	{r4, r5, lr}
 8000452:	1c05      	adds	r5, r0, #0
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000454:	07c3      	lsls	r3, r0, #31
 8000456:	d512      	bpl.n	800047e <chSysIntegrityCheckI.4476+0x2e>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
 8000458:	4b21      	ldr	r3, [pc, #132]	; (80004e0 <chSysIntegrityCheckI.4476+0x90>)
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800045a:	2200      	movs	r2, #0
    tp = ch.rlist.queue.next;
 800045c:	6819      	ldr	r1, [r3, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800045e:	4299      	cmp	r1, r3
 8000460:	d003      	beq.n	800046a <chSysIntegrityCheckI.4476+0x1a>
      n++;
      tp = tp->queue.next;
 8000462:	6809      	ldr	r1, [r1, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n++;
 8000464:	3201      	adds	r2, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000466:	4299      	cmp	r1, r3
 8000468:	d1fb      	bne.n	8000462 <chSysIntegrityCheckI.4476+0x12>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800046a:	6859      	ldr	r1, [r3, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800046c:	4299      	cmp	r1, r3
 800046e:	d003      	beq.n	8000478 <chSysIntegrityCheckI.4476+0x28>
      n--;
      tp = tp->queue.prev;
 8000470:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n--;
 8000472:	3a01      	subs	r2, #1
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000474:	4299      	cmp	r1, r3
 8000476:	d1fb      	bne.n	8000470 <chSysIntegrityCheckI.4476+0x20>
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 8000478:	2001      	movs	r0, #1
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800047a:	2a00      	cmp	r2, #0
 800047c:	d12d      	bne.n	80004da <chSysIntegrityCheckI.4476+0x8a>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800047e:	07ab      	lsls	r3, r5, #30
 8000480:	d516      	bpl.n	80004b0 <chSysIntegrityCheckI.4476+0x60>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8000482:	4b17      	ldr	r3, [pc, #92]	; (80004e0 <chSysIntegrityCheckI.4476+0x90>)
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8000484:	2200      	movs	r2, #0
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000486:	1c1c      	adds	r4, r3, #0
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8000488:	69d9      	ldr	r1, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800048a:	341c      	adds	r4, #28
 800048c:	42a1      	cmp	r1, r4
 800048e:	d003      	beq.n	8000498 <chSysIntegrityCheckI.4476+0x48>
      n++;
      vtp = vtp->next;
 8000490:	6809      	ldr	r1, [r1, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 8000492:	3201      	adds	r2, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000494:	42a1      	cmp	r1, r4
 8000496:	d1fb      	bne.n	8000490 <chSysIntegrityCheckI.4476+0x40>
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000498:	1c1c      	adds	r4, r3, #0
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 800049a:	6a19      	ldr	r1, [r3, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800049c:	341c      	adds	r4, #28
 800049e:	42a1      	cmp	r1, r4
 80004a0:	d003      	beq.n	80004aa <chSysIntegrityCheckI.4476+0x5a>
      n--;
      vtp = vtp->prev;
 80004a2:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 80004a4:	3a01      	subs	r2, #1
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80004a6:	42a1      	cmp	r1, r4
 80004a8:	d1fb      	bne.n	80004a2 <chSysIntegrityCheckI.4476+0x52>
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80004aa:	2001      	movs	r0, #1
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80004ac:	2a00      	cmp	r2, #0
 80004ae:	d114      	bne.n	80004da <chSysIntegrityCheckI.4476+0x8a>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 80004b0:	2000      	movs	r0, #0
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80004b2:	076b      	lsls	r3, r5, #29
 80004b4:	d511      	bpl.n	80004da <chSysIntegrityCheckI.4476+0x8a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
 80004b6:	4b0a      	ldr	r3, [pc, #40]	; (80004e0 <chSysIntegrityCheckI.4476+0x90>)
 80004b8:	691a      	ldr	r2, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
 80004ba:	429a      	cmp	r2, r3
 80004bc:	d00e      	beq.n	80004dc <chSysIntegrityCheckI.4476+0x8c>
      n++;
      tp = tp->newer;
 80004be:	6912      	ldr	r2, [r2, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 80004c0:	3001      	adds	r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 80004c2:	429a      	cmp	r2, r3
 80004c4:	d1fb      	bne.n	80004be <chSysIntegrityCheckI.4476+0x6e>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 80004c6:	695a      	ldr	r2, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80004c8:	429a      	cmp	r2, r3
 80004ca:	d003      	beq.n	80004d4 <chSysIntegrityCheckI.4476+0x84>
      n--;
      tp = tp->older;
 80004cc:	6952      	ldr	r2, [r2, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 80004ce:	3801      	subs	r0, #1
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 80004d0:	429a      	cmp	r2, r3
 80004d2:	d1fb      	bne.n	80004cc <chSysIntegrityCheckI.4476+0x7c>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80004d4:	1e43      	subs	r3, r0, #1
 80004d6:	4198      	sbcs	r0, r3
 80004d8:	b2c0      	uxtb	r0, r0
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80004da:	bd30      	pop	{r4, r5, pc}
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80004dc:	2000      	movs	r0, #0
 80004de:	e7f2      	b.n	80004c6 <chSysIntegrityCheckI.4476+0x76>
 80004e0:	20000ed4 	.word	0x20000ed4
 80004e4:	46c0      	nop			; (mov r8, r8)
 80004e6:	46c0      	nop			; (mov r8, r8)
 80004e8:	46c0      	nop			; (mov r8, r8)
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	46c0      	nop			; (mov r8, r8)
 80004ee:	46c0      	nop			; (mov r8, r8)

080004f0 <_idle_thread.4283>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80004f0:	e7fe      	b.n	80004f0 <_idle_thread.4283>
 80004f2:	46c0      	nop			; (mov r8, r8)
 80004f4:	46c0      	nop			; (mov r8, r8)
 80004f6:	46c0      	nop			; (mov r8, r8)
 80004f8:	46c0      	nop			; (mov r8, r8)
 80004fa:	46c0      	nop			; (mov r8, r8)
 80004fc:	46c0      	nop			; (mov r8, r8)
 80004fe:	46c0      	nop			; (mov r8, r8)

08000500 <chThdYield.4431>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8000500:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000502:	b672      	cpsid	i
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8000504:	4c0f      	ldr	r4, [pc, #60]	; (8000544 <chThdYield.4431+0x44>)
 8000506:	6820      	ldr	r0, [r4, #0]
 8000508:	69a1      	ldr	r1, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800050a:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 800050c:	688a      	ldr	r2, [r1, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800050e:	4293      	cmp	r3, r2
 8000510:	d201      	bcs.n	8000516 <chThdYield.4431+0x16>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000512:	b662      	cpsie	i

  chSysLock();
  chSchDoYieldS();
  chSysUnlock();
}
 8000514:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000516:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000518:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800051a:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800051c:	6023      	str	r3, [r4, #0]
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800051e:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8000520:	2420      	movs	r4, #32
 8000522:	5505      	strb	r5, [r0, r4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000524:	2500      	movs	r5, #0
 8000526:	550d      	strb	r5, [r1, r4]
 8000528:	e000      	b.n	800052c <chThdYield.4431+0x2c>
 800052a:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 800052c:	689c      	ldr	r4, [r3, #8]
 800052e:	42a2      	cmp	r2, r4
 8000530:	d9fb      	bls.n	800052a <chThdYield.4431+0x2a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000532:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000534:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000536:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000538:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 800053a:	6059      	str	r1, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800053c:	f7ff fe48 	bl	80001d0 <_port_switch>
 8000540:	e7e7      	b.n	8000512 <chThdYield.4431+0x12>
 8000542:	46c0      	nop			; (mov r8, r8)
 8000544:	20000ed4 	.word	0x20000ed4
 8000548:	46c0      	nop			; (mov r8, r8)
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	46c0      	nop			; (mov r8, r8)
 800054e:	46c0      	nop			; (mov r8, r8)

08000550 <bmk_thread8.10594>:
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
}
#endif

static THD_FUNCTION(bmk_thread8, p) {
 8000550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000552:	4f0a      	ldr	r7, [pc, #40]	; (800057c <bmk_thread8.10594+0x2c>)
 8000554:	1c04      	adds	r4, r0, #0
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8000556:	2621      	movs	r6, #33	; 0x21
 8000558:	2504      	movs	r5, #4

  do {
    chThdYield();
 800055a:	f7ff ffd1 	bl	8000500 <chThdYield.4431>
    chThdYield();
 800055e:	f7ff ffcf 	bl	8000500 <chThdYield.4431>
    chThdYield();
 8000562:	f7ff ffcd 	bl	8000500 <chThdYield.4431>
    chThdYield();
 8000566:	f7ff ffcb 	bl	8000500 <chThdYield.4431>
    (*(uint32_t *)p) += 4;
 800056a:	6823      	ldr	r3, [r4, #0]
 800056c:	69ba      	ldr	r2, [r7, #24]
 800056e:	3304      	adds	r3, #4
 8000570:	6023      	str	r3, [r4, #0]
 8000572:	5d93      	ldrb	r3, [r2, r6]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8000574:	421d      	tst	r5, r3
 8000576:	d0f0      	beq.n	800055a <bmk_thread8.10594+0xa>
}
 8000578:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	20000ed4 	.word	0x20000ed4

08000580 <_test_assert_time_window.constprop.2>:
 8000580:	4b09      	ldr	r3, [pc, #36]	; (80005a8 <_test_assert_time_window.constprop.2+0x28>)
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8000582:	1a09      	subs	r1, r1, r0
 8000584:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8000586:	b289      	uxth	r1, r1
 8000588:	1a1b      	subs	r3, r3, r0
 800058a:	b29b      	uxth	r3, r3
    return _test_fail(msg);
  return false;
 800058c:	2000      	movs	r0, #0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 800058e:	428b      	cmp	r3, r1
 8000590:	d308      	bcc.n	80005a4 <_test_assert_time_window.constprop.2+0x24>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8000592:	4a06      	ldr	r2, [pc, #24]	; (80005ac <_test_assert_time_window.constprop.2+0x2c>)
 8000594:	2301      	movs	r3, #1
 8000596:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 8000598:	4a05      	ldr	r2, [pc, #20]	; (80005b0 <_test_assert_time_window.constprop.2+0x30>)
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
 800059a:	2001      	movs	r0, #1
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
 800059c:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 800059e:	4a05      	ldr	r2, [pc, #20]	; (80005b4 <_test_assert_time_window.constprop.2+0x34>)
 80005a0:	4b05      	ldr	r3, [pc, #20]	; (80005b8 <_test_assert_time_window.constprop.2+0x38>)
 80005a2:	601a      	str	r2, [r3, #0]
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 80005a4:	4770      	bx	lr
 80005a6:	46c0      	nop			; (mov r8, r8)
 80005a8:	40000400 	.word	0x40000400
 80005ac:	20000e51 	.word	0x20000e51
 80005b0:	20000e50 	.word	0x20000e50
 80005b4:	08005b60 	.word	0x08005b60
 80005b8:	20000ed0 	.word	0x20000ed0
 80005bc:	46c0      	nop			; (mov r8, r8)
 80005be:	46c0      	nop			; (mov r8, r8)

080005c0 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 80005c0:	4b08      	ldr	r3, [pc, #32]	; (80005e4 <test_terminate_threads+0x24>)
 80005c2:	b530      	push	{r4, r5, lr}
 80005c4:	1c1c      	adds	r4, r3, #0
 80005c6:	3414      	adds	r4, #20
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 80005c8:	2121      	movs	r1, #33	; 0x21
 80005ca:	2504      	movs	r5, #4
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 80005cc:	681a      	ldr	r2, [r3, #0]
 80005ce:	2a00      	cmp	r2, #0
 80005d0:	d004      	beq.n	80005dc <test_terminate_threads+0x1c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005d2:	b672      	cpsid	i
 80005d4:	5c50      	ldrb	r0, [r2, r1]
 80005d6:	4328      	orrs	r0, r5
 80005d8:	5450      	strb	r0, [r2, r1]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005da:	b662      	cpsie	i
 80005dc:	3304      	adds	r3, #4
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 80005de:	42a3      	cmp	r3, r4
 80005e0:	d1f4      	bne.n	80005cc <test_terminate_threads+0xc>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 80005e2:	bd30      	pop	{r4, r5, pc}
 80005e4:	20000b84 	.word	0x20000b84
 80005e8:	46c0      	nop			; (mov r8, r8)
 80005ea:	46c0      	nop			; (mov r8, r8)
 80005ec:	46c0      	nop			; (mov r8, r8)
 80005ee:	46c0      	nop			; (mov r8, r8)

080005f0 <test_emit_token>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005f0:	b672      	cpsid	i
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 80005f2:	4a05      	ldr	r2, [pc, #20]	; (8000608 <test_emit_token+0x18>)
 80005f4:	4905      	ldr	r1, [pc, #20]	; (800060c <test_emit_token+0x1c>)
 80005f6:	6813      	ldr	r3, [r2, #0]
 80005f8:	428b      	cmp	r3, r1
 80005fa:	d202      	bcs.n	8000602 <test_emit_token+0x12>
    *test_tokp++ = token;
 80005fc:	1c59      	adds	r1, r3, #1
 80005fe:	6011      	str	r1, [r2, #0]
 8000600:	7018      	strb	r0, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000602:	b662      	cpsie	i
  osalSysUnlock();
}
 8000604:	4770      	bx	lr
 8000606:	46c0      	nop			; (mov r8, r8)
 8000608:	20000e18 	.word	0x20000e18
 800060c:	20000e2c 	.word	0x20000e2c

08000610 <dyn_thread1.10426>:
#endif
#if CH_CFG_USE_MEMPOOLS
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {
 8000610:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8000612:	7800      	ldrb	r0, [r0, #0]
 8000614:	f7ff ffec 	bl	80005f0 <test_emit_token>
}
 8000618:	bd08      	pop	{r3, pc}
 800061a:	46c0      	nop			; (mov r8, r8)
 800061c:	46c0      	nop			; (mov r8, r8)
 800061e:	46c0      	nop			; (mov r8, r8)

08000620 <h1.9784>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8000620:	b508      	push	{r3, lr}
 8000622:	2041      	movs	r0, #65	; 0x41
 8000624:	f7ff ffe4 	bl	80005f0 <test_emit_token>
 8000628:	bd08      	pop	{r3, pc}
 800062a:	46c0      	nop			; (mov r8, r8)
 800062c:	46c0      	nop			; (mov r8, r8)
 800062e:	46c0      	nop			; (mov r8, r8)

08000630 <h2.9781>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8000630:	b508      	push	{r3, lr}
 8000632:	2042      	movs	r0, #66	; 0x42
 8000634:	f7ff ffdc 	bl	80005f0 <test_emit_token>
 8000638:	bd08      	pop	{r3, pc}
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	46c0      	nop			; (mov r8, r8)
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <h3.9778>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8000640:	b508      	push	{r3, lr}
 8000642:	2043      	movs	r0, #67	; 0x43
 8000644:	f7ff ffd4 	bl	80005f0 <test_emit_token>
 8000648:	bd08      	pop	{r3, pc}
 800064a:	46c0      	nop			; (mov r8, r8)
 800064c:	46c0      	nop			; (mov r8, r8)
 800064e:	46c0      	nop			; (mov r8, r8)

08000650 <thread.8693>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {
 8000650:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8000652:	7800      	ldrb	r0, [r0, #0]
 8000654:	f7ff ffcc 	bl	80005f0 <test_emit_token>
}
 8000658:	bd08      	pop	{r3, pc}
 800065a:	46c0      	nop			; (mov r8, r8)
 800065c:	46c0      	nop			; (mov r8, r8)
 800065e:	46c0      	nop			; (mov r8, r8)

08000660 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8000660:	b538      	push	{r3, r4, r5, lr}
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000662:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8000664:	1c04      	adds	r4, r0, #0
 8000666:	4d09      	ldr	r5, [pc, #36]	; (800068c <test_println+0x2c>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000668:	2900      	cmp	r1, #0
 800066a:	d007      	beq.n	800067c <test_println+0x1c>
    streamPut(test_chp, *msgp++);
 800066c:	6828      	ldr	r0, [r5, #0]
 800066e:	3401      	adds	r4, #1
 8000670:	6803      	ldr	r3, [r0, #0]
 8000672:	689b      	ldr	r3, [r3, #8]
 8000674:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000676:	7821      	ldrb	r1, [r4, #0]
 8000678:	2900      	cmp	r1, #0
 800067a:	d1f7      	bne.n	800066c <test_println+0xc>
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800067c:	6828      	ldr	r0, [r5, #0]
 800067e:	4904      	ldr	r1, [pc, #16]	; (8000690 <test_println+0x30>)
 8000680:	6803      	ldr	r3, [r0, #0]
 8000682:	2202      	movs	r2, #2
 8000684:	681b      	ldr	r3, [r3, #0]
 8000686:	4798      	blx	r3
}
 8000688:	bd38      	pop	{r3, r4, r5, pc}
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	20000e2c 	.word	0x20000e2c
 8000690:	08005b74 	.word	0x08005b74
 8000694:	46c0      	nop			; (mov r8, r8)
 8000696:	46c0      	nop			; (mov r8, r8)
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 80006a0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 80006a2:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 80006a4:	1c04      	adds	r4, r0, #0

  while (*msgp)
 80006a6:	2900      	cmp	r1, #0
 80006a8:	d008      	beq.n	80006bc <test_print+0x1c>
 80006aa:	4d05      	ldr	r5, [pc, #20]	; (80006c0 <test_print+0x20>)
    streamPut(test_chp, *msgp++);
 80006ac:	6828      	ldr	r0, [r5, #0]
 80006ae:	3401      	adds	r4, #1
 80006b0:	6803      	ldr	r3, [r0, #0]
 80006b2:	689b      	ldr	r3, [r3, #8]
 80006b4:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80006b6:	7821      	ldrb	r1, [r4, #0]
 80006b8:	2900      	cmp	r1, #0
 80006ba:	d1f7      	bne.n	80006ac <test_print+0xc>
    streamPut(test_chp, *msgp++);
}
 80006bc:	bd38      	pop	{r3, r4, r5, pc}
 80006be:	46c0      	nop			; (mov r8, r8)
 80006c0:	20000e2c 	.word	0x20000e2c
 80006c4:	46c0      	nop			; (mov r8, r8)
 80006c6:	46c0      	nop			; (mov r8, r8)
 80006c8:	46c0      	nop			; (mov r8, r8)
 80006ca:	46c0      	nop			; (mov r8, r8)
 80006cc:	46c0      	nop			; (mov r8, r8)
 80006ce:	46c0      	nop			; (mov r8, r8)

080006d0 <test_printn>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 80006d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006d2:	4647      	mov	r7, r8
 80006d4:	b480      	push	{r7}
 80006d6:	1c04      	adds	r4, r0, #0
 80006d8:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 80006da:	2800      	cmp	r0, #0
 80006dc:	d028      	beq.n	8000730 <test_printn+0x60>
 80006de:	466f      	mov	r7, sp
 80006e0:	3701      	adds	r7, #1
 80006e2:	1c3d      	adds	r5, r7, #0
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 80006e4:	1c20      	adds	r0, r4, #0
 80006e6:	210a      	movs	r1, #10
 80006e8:	f7ff fdd6 	bl	8000298 <__aeabi_uidivmod>
 80006ec:	1c0e      	adds	r6, r1, #0
 80006ee:	3630      	adds	r6, #48	; 0x30
 80006f0:	1e6b      	subs	r3, r5, #1
 80006f2:	b2f6      	uxtb	r6, r6
 80006f4:	1c20      	adds	r0, r4, #0
 80006f6:	701e      	strb	r6, [r3, #0]
 80006f8:	210a      	movs	r1, #10
 80006fa:	f7ff fd89 	bl	8000210 <__aeabi_uidiv>
 80006fe:	46a8      	mov	r8, r5
 8000700:	1c04      	adds	r4, r0, #0
 8000702:	3501      	adds	r5, #1

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8000704:	2800      	cmp	r0, #0
 8000706:	d1ed      	bne.n	80006e4 <test_printn+0x14>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000708:	466b      	mov	r3, sp
 800070a:	4598      	cmp	r8, r3
 800070c:	d90c      	bls.n	8000728 <test_printn+0x58>
 800070e:	4644      	mov	r4, r8
 8000710:	4d0b      	ldr	r5, [pc, #44]	; (8000740 <test_printn+0x70>)
 8000712:	e002      	b.n	800071a <test_printn+0x4a>
 8000714:	1ea3      	subs	r3, r4, #2
 8000716:	781e      	ldrb	r6, [r3, #0]
 8000718:	3c01      	subs	r4, #1
      streamPut(test_chp, *--p);
 800071a:	6828      	ldr	r0, [r5, #0]
 800071c:	1c31      	adds	r1, r6, #0
 800071e:	6803      	ldr	r3, [r0, #0]
 8000720:	689b      	ldr	r3, [r3, #8]
 8000722:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000724:	42a7      	cmp	r7, r4
 8000726:	d1f5      	bne.n	8000714 <test_printn+0x44>
      streamPut(test_chp, *--p);
  }
}
 8000728:	b004      	add	sp, #16
 800072a:	bc04      	pop	{r2}
 800072c:	4690      	mov	r8, r2
 800072e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
 8000730:	4b03      	ldr	r3, [pc, #12]	; (8000740 <test_printn+0x70>)
 8000732:	2130      	movs	r1, #48	; 0x30
 8000734:	6818      	ldr	r0, [r3, #0]
 8000736:	6803      	ldr	r3, [r0, #0]
 8000738:	689b      	ldr	r3, [r3, #8]
 800073a:	4798      	blx	r3
 800073c:	e7f4      	b.n	8000728 <test_printn+0x58>
 800073e:	46c0      	nop			; (mov r8, r8)
 8000740:	20000e2c 	.word	0x20000e2c
 8000744:	46c0      	nop			; (mov r8, r8)
 8000746:	46c0      	nop			; (mov r8, r8)
 8000748:	46c0      	nop			; (mov r8, r8)
 800074a:	46c0      	nop			; (mov r8, r8)
 800074c:	46c0      	nop			; (mov r8, r8)
 800074e:	46c0      	nop			; (mov r8, r8)

08000750 <test_012_012_execute.10609>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void test_012_012_execute(void) {
 8000750:	b538      	push	{r3, r4, r5, lr}

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8000752:	4d33      	ldr	r5, [pc, #204]	; (8000820 <test_012_012_execute.10609+0xd0>)
 8000754:	2301      	movs	r3, #1
  {
    test_print("--- System: ");
 8000756:	4833      	ldr	r0, [pc, #204]	; (8000824 <test_012_012_execute.10609+0xd4>)
 */

static void test_012_012_execute(void) {

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8000758:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 800075a:	f7ff ffa1 	bl	80006a0 <test_print>
    test_printn(sizeof(ch_system_t));
 800075e:	2070      	movs	r0, #112	; 0x70
 8000760:	f7ff ffb6 	bl	80006d0 <test_printn>
    test_println(" bytes");
 8000764:	4c30      	ldr	r4, [pc, #192]	; (8000828 <test_012_012_execute.10609+0xd8>)
 8000766:	1c20      	adds	r0, r4, #0
 8000768:	f7ff ff7a 	bl	8000660 <test_println>
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 800076c:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 800076e:	482f      	ldr	r0, [pc, #188]	; (800082c <test_012_012_execute.10609+0xdc>)
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8000770:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 8000772:	f7ff ff95 	bl	80006a0 <test_print>
    test_printn(sizeof(thread_t));
 8000776:	2044      	movs	r0, #68	; 0x44
 8000778:	f7ff ffaa 	bl	80006d0 <test_printn>
    test_println(" bytes");
 800077c:	1c20      	adds	r0, r4, #0
 800077e:	f7ff ff6f 	bl	8000660 <test_println>
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8000782:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 8000784:	482a      	ldr	r0, [pc, #168]	; (8000830 <test_012_012_execute.10609+0xe0>)
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8000786:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 8000788:	f7ff ff8a 	bl	80006a0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 800078c:	2014      	movs	r0, #20
 800078e:	f7ff ff9f 	bl	80006d0 <test_printn>
    test_println(" bytes");
 8000792:	1c20      	adds	r0, r4, #0
 8000794:	f7ff ff64 	bl	8000660 <test_println>
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8000798:	2304      	movs	r3, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800079a:	4826      	ldr	r0, [pc, #152]	; (8000834 <test_012_012_execute.10609+0xe4>)
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 800079c:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800079e:	f7ff ff7f 	bl	80006a0 <test_print>
    test_printn(sizeof(semaphore_t));
 80007a2:	200c      	movs	r0, #12
 80007a4:	f7ff ff94 	bl	80006d0 <test_printn>
    test_println(" bytes");
 80007a8:	1c20      	adds	r0, r4, #0
 80007aa:	f7ff ff59 	bl	8000660 <test_println>
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 80007ae:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 80007b0:	4821      	ldr	r0, [pc, #132]	; (8000838 <test_012_012_execute.10609+0xe8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 80007b2:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 80007b4:	f7ff ff74 	bl	80006a0 <test_print>
    test_printn(sizeof(mutex_t));
 80007b8:	2010      	movs	r0, #16
 80007ba:	f7ff ff89 	bl	80006d0 <test_printn>
    test_println(" bytes");
 80007be:	1c20      	adds	r0, r4, #0
 80007c0:	f7ff ff4e 	bl	8000660 <test_println>
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 80007c4:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 80007c6:	481d      	ldr	r0, [pc, #116]	; (800083c <test_012_012_execute.10609+0xec>)
    test_println(" bytes");
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 80007c8:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 80007ca:	f7ff ff69 	bl	80006a0 <test_print>
    test_printn(sizeof(condition_variable_t));
 80007ce:	2008      	movs	r0, #8
 80007d0:	f7ff ff7e 	bl	80006d0 <test_printn>
    test_println(" bytes");
 80007d4:	1c20      	adds	r0, r4, #0
 80007d6:	f7ff ff43 	bl	8000660 <test_println>
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 80007da:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 80007dc:	4818      	ldr	r0, [pc, #96]	; (8000840 <test_012_012_execute.10609+0xf0>)
    test_println(" bytes");
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 80007de:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 80007e0:	f7ff ff5e 	bl	80006a0 <test_print>
    test_printn(sizeof(event_source_t));
 80007e4:	2004      	movs	r0, #4
 80007e6:	f7ff ff73 	bl	80006d0 <test_printn>
    test_println(" bytes");
 80007ea:	1c20      	adds	r0, r4, #0
 80007ec:	f7ff ff38 	bl	8000660 <test_println>
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 80007f0:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 80007f2:	4814      	ldr	r0, [pc, #80]	; (8000844 <test_012_012_execute.10609+0xf4>)
    test_println(" bytes");
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 80007f4:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 80007f6:	f7ff ff53 	bl	80006a0 <test_print>
    test_printn(sizeof(event_listener_t));
 80007fa:	2014      	movs	r0, #20
 80007fc:	f7ff ff68 	bl	80006d0 <test_printn>
    test_println(" bytes");
 8000800:	1c20      	adds	r0, r4, #0
 8000802:	f7ff ff2d 	bl	8000660 <test_println>
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8000806:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8000808:	480f      	ldr	r0, [pc, #60]	; (8000848 <test_012_012_execute.10609+0xf8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 800080a:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 800080c:	f7ff ff48 	bl	80006a0 <test_print>
    test_printn(sizeof(mailbox_t));
 8000810:	2028      	movs	r0, #40	; 0x28
 8000812:	f7ff ff5d 	bl	80006d0 <test_printn>
    test_println(" bytes");
 8000816:	1c20      	adds	r0, r4, #0
 8000818:	f7ff ff22 	bl	8000660 <test_println>
#endif
  }
}
 800081c:	bd38      	pop	{r3, r4, r5, pc}
 800081e:	46c0      	nop			; (mov r8, r8)
 8000820:	20000f44 	.word	0x20000f44
 8000824:	08005b78 	.word	0x08005b78
 8000828:	08005b88 	.word	0x08005b88
 800082c:	08005b90 	.word	0x08005b90
 8000830:	08005ba0 	.word	0x08005ba0
 8000834:	08005bb0 	.word	0x08005bb0
 8000838:	08005bc0 	.word	0x08005bc0
 800083c:	08005bd0 	.word	0x08005bd0
 8000840:	08005be0 	.word	0x08005be0
 8000844:	08005bf0 	.word	0x08005bf0
 8000848:	08005c00 	.word	0x08005c00
 800084c:	46c0      	nop			; (mov r8, r8)
 800084e:	46c0      	nop			; (mov r8, r8)

08000850 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(msg);
  return false;
}

bool _test_assert_sequence(char *expected, const char *msg) {
 8000850:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000852:	468c      	mov	ip, r1
 8000854:	4f0f      	ldr	r7, [pc, #60]	; (8000894 <_test_assert_sequence+0x44>)
 8000856:	4910      	ldr	r1, [pc, #64]	; (8000898 <_test_assert_sequence+0x48>)
 8000858:	683e      	ldr	r6, [r7, #0]
 800085a:	1c0b      	adds	r3, r1, #0
 800085c:	e005      	b.n	800086a <_test_assert_sequence+0x1a>
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
 800085e:	7815      	ldrb	r5, [r2, #0]
 8000860:	7822      	ldrb	r2, [r4, #0]
 8000862:	3001      	adds	r0, #1
 8000864:	3301      	adds	r3, #1
 8000866:	4295      	cmp	r5, r2
 8000868:	d109      	bne.n	800087e <_test_assert_sequence+0x2e>
 800086a:	1c04      	adds	r4, r0, #0
 800086c:	1c1a      	adds	r2, r3, #0
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 800086e:	429e      	cmp	r6, r3
 8000870:	d8f5      	bhi.n	800085e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 8000872:	7803      	ldrb	r3, [r0, #0]
 8000874:	2b00      	cmp	r3, #0
 8000876:	d102      	bne.n	800087e <_test_assert_sequence+0x2e>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8000878:	6039      	str	r1, [r7, #0]
  if (*expected)
    return _test_fail(msg);

  clear_tokens();

  return false;
 800087a:	2000      	movs	r0, #0
 800087c:	e008      	b.n	8000890 <_test_assert_sequence+0x40>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 800087e:	4a07      	ldr	r2, [pc, #28]	; (800089c <_test_assert_sequence+0x4c>)
 8000880:	2301      	movs	r3, #1
 8000882:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 8000884:	4a06      	ldr	r2, [pc, #24]	; (80008a0 <_test_assert_sequence+0x50>)
bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
     return _test_fail(msg);
 8000886:	2001      	movs	r0, #1
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
 8000888:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 800088a:	4b06      	ldr	r3, [pc, #24]	; (80008a4 <_test_assert_sequence+0x54>)
 800088c:	4662      	mov	r2, ip
 800088e:	601a      	str	r2, [r3, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 8000890:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000892:	46c0      	nop			; (mov r8, r8)
 8000894:	20000e18 	.word	0x20000e18
 8000898:	20000e1c 	.word	0x20000e1c
 800089c:	20000e51 	.word	0x20000e51
 80008a0:	20000e50 	.word	0x20000e50
 80008a4:	20000ed0 	.word	0x20000ed0
 80008a8:	46c0      	nop			; (mov r8, r8)
 80008aa:	46c0      	nop			; (mov r8, r8)
 80008ac:	46c0      	nop			; (mov r8, r8)
 80008ae:	46c0      	nop			; (mov r8, r8)

080008b0 <_test_assert>:

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 80008b0:	2300      	movs	r3, #0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 80008b2:	2800      	cmp	r0, #0
 80008b4:	d107      	bne.n	80008c6 <_test_assert+0x16>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80008b6:	4a05      	ldr	r2, [pc, #20]	; (80008cc <_test_assert+0x1c>)
 80008b8:	2301      	movs	r3, #1
 80008ba:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 80008bc:	4a04      	ldr	r2, [pc, #16]	; (80008d0 <_test_assert+0x20>)
 80008be:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 80008c0:	4b04      	ldr	r3, [pc, #16]	; (80008d4 <_test_assert+0x24>)
 80008c2:	6019      	str	r1, [r3, #0]
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
 80008c4:	2301      	movs	r3, #1
  return false;
}
 80008c6:	1c18      	adds	r0, r3, #0
 80008c8:	4770      	bx	lr
 80008ca:	46c0      	nop			; (mov r8, r8)
 80008cc:	20000e51 	.word	0x20000e51
 80008d0:	20000e50 	.word	0x20000e50
 80008d4:	20000ed0 	.word	0x20000ed0
 80008d8:	46c0      	nop			; (mov r8, r8)
 80008da:	46c0      	nop			; (mov r8, r8)
 80008dc:	46c0      	nop			; (mov r8, r8)
 80008de:	46c0      	nop			; (mov r8, r8)

080008e0 <test_001_001_execute.8573>:
 * - [1.1.3] Testing Registry List integrity.
 * - [1.1.4] Testing Port-defined integrity.
 * .
 */

static void test_001_001_execute(void) {
 80008e0:	b538      	push	{r3, r4, r5, lr}
  bool result;

  /* [1.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 80008e2:	4d1d      	ldr	r5, [pc, #116]	; (8000958 <test_001_001_execute.8573+0x78>)
 80008e4:	2301      	movs	r3, #1
 80008e6:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008e8:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80008ea:	2001      	movs	r0, #1
 80008ec:	f7ff fdb0 	bl	8000450 <chSysIntegrityCheckI.4476>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008f0:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
 80008f2:	2401      	movs	r4, #1
 80008f4:	4060      	eors	r0, r4
 80008f6:	b2c0      	uxtb	r0, r0
 80008f8:	4918      	ldr	r1, [pc, #96]	; (800095c <test_001_001_execute.8573+0x7c>)
 80008fa:	f7ff ffd9 	bl	80008b0 <_test_assert>
 80008fe:	2800      	cmp	r0, #0
 8000900:	d000      	beq.n	8000904 <test_001_001_execute.8573+0x24>
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
  }
}
 8000902:	bd38      	pop	{r3, r4, r5, pc}
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
  }

  /* [1.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8000904:	2302      	movs	r3, #2
 8000906:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000908:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 800090a:	2002      	movs	r0, #2
 800090c:	f7ff fda0 	bl	8000450 <chSysIntegrityCheckI.4476>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000910:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "virtual timers list check failed");
 8000912:	4060      	eors	r0, r4
 8000914:	b2c0      	uxtb	r0, r0
 8000916:	4912      	ldr	r1, [pc, #72]	; (8000960 <test_001_001_execute.8573+0x80>)
 8000918:	f7ff ffca 	bl	80008b0 <_test_assert>
 800091c:	2800      	cmp	r0, #0
 800091e:	d1f0      	bne.n	8000902 <test_001_001_execute.8573+0x22>
  }

  /* [1.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 8000920:	2303      	movs	r3, #3
 8000922:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000924:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8000926:	2004      	movs	r0, #4
 8000928:	f7ff fd92 	bl	8000450 <chSysIntegrityCheckI.4476>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800092c:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "registry list check failed");
 800092e:	4060      	eors	r0, r4
 8000930:	b2c0      	uxtb	r0, r0
 8000932:	490c      	ldr	r1, [pc, #48]	; (8000964 <test_001_001_execute.8573+0x84>)
 8000934:	f7ff ffbc 	bl	80008b0 <_test_assert>
 8000938:	2800      	cmp	r0, #0
 800093a:	d1e2      	bne.n	8000902 <test_001_001_execute.8573+0x22>
  }

  /* [1.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 800093c:	2304      	movs	r3, #4
 800093e:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000940:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8000942:	2008      	movs	r0, #8
 8000944:	f7ff fd84 	bl	8000450 <chSysIntegrityCheckI.4476>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000948:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 800094a:	4044      	eors	r4, r0
 800094c:	b2e0      	uxtb	r0, r4
 800094e:	4906      	ldr	r1, [pc, #24]	; (8000968 <test_001_001_execute.8573+0x88>)
 8000950:	f7ff ffae 	bl	80008b0 <_test_assert>
 8000954:	e7d5      	b.n	8000902 <test_001_001_execute.8573+0x22>
 8000956:	46c0      	nop			; (mov r8, r8)
 8000958:	20000f44 	.word	0x20000f44
 800095c:	08005c10 	.word	0x08005c10
 8000960:	08005c28 	.word	0x08005c28
 8000964:	08005c4c 	.word	0x08005c4c
 8000968:	08005c68 	.word	0x08005c68
 800096c:	46c0      	nop			; (mov r8, r8)
 800096e:	46c0      	nop			; (mov r8, r8)

08000970 <print_line.8268>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
 8000970:	b538      	push	{r3, r4, r5, lr}
 8000972:	4d08      	ldr	r5, [pc, #32]	; (8000994 <print_line.8268+0x24>)
 8000974:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
 8000976:	6828      	ldr	r0, [r5, #0]
 8000978:	212d      	movs	r1, #45	; 0x2d
 800097a:	6803      	ldr	r3, [r0, #0]
 800097c:	3c01      	subs	r4, #1
 800097e:	689b      	ldr	r3, [r3, #8]
 8000980:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8000982:	2c00      	cmp	r4, #0
 8000984:	d1f7      	bne.n	8000976 <print_line.8268+0x6>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000986:	6828      	ldr	r0, [r5, #0]
 8000988:	4903      	ldr	r1, [pc, #12]	; (8000998 <print_line.8268+0x28>)
 800098a:	6803      	ldr	r3, [r0, #0]
 800098c:	2202      	movs	r2, #2
 800098e:	681b      	ldr	r3, [r3, #0]
 8000990:	4798      	blx	r3
}
 8000992:	bd38      	pop	{r3, r4, r5, pc}
 8000994:	20000e2c 	.word	0x20000e2c
 8000998:	08005b74 	.word	0x08005b74
 800099c:	46c0      	nop			; (mov r8, r8)
 800099e:	46c0      	nop			; (mov r8, r8)

080009a0 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80009a0:	300f      	adds	r0, #15
 80009a2:	d011      	beq.n	80009c8 <_port_irq_epilogue+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009a4:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80009a6:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80009aa:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80009ac:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80009b0:	2280      	movs	r2, #128	; 0x80
 80009b2:	0452      	lsls	r2, r2, #17
 80009b4:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80009b6:	4a06      	ldr	r2, [pc, #24]	; (80009d0 <_port_irq_epilogue+0x30>)
 80009b8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80009ba:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80009bc:	6889      	ldr	r1, [r1, #8]
 80009be:	6892      	ldr	r2, [r2, #8]
 80009c0:	4291      	cmp	r1, r2
 80009c2:	d802      	bhi.n	80009ca <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80009c4:	4a03      	ldr	r2, [pc, #12]	; (80009d4 <_port_irq_epilogue+0x34>)
 80009c6:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80009c8:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80009ca:	4a03      	ldr	r2, [pc, #12]	; (80009d8 <_port_irq_epilogue+0x38>)
 80009cc:	619a      	str	r2, [r3, #24]
 80009ce:	e7fb      	b.n	80009c8 <_port_irq_epilogue+0x28>
 80009d0:	20000ed4 	.word	0x20000ed4
 80009d4:	08000200 	.word	0x08000200
 80009d8:	080001fd 	.word	0x080001fd
 80009dc:	46c0      	nop			; (mov r8, r8)
 80009de:	46c0      	nop			; (mov r8, r8)

080009e0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80009e0:	b508      	push	{r3, lr}
 80009e2:	1c03      	adds	r3, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009e4:	b672      	cpsid	i
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 80009e6:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80009e8:	2800      	cmp	r0, #0
 80009ea:	d003      	beq.n	80009f4 <chPoolAlloc+0x14>
    mp->next = mp->next->next;
 80009ec:	6802      	ldr	r2, [r0, #0]
 80009ee:	601a      	str	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009f0:	b662      	cpsie	i
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 80009f2:	bd08      	pop	{r3, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 80009f4:	689a      	ldr	r2, [r3, #8]
 80009f6:	2a00      	cmp	r2, #0
 80009f8:	d0fa      	beq.n	80009f0 <chPoolAlloc+0x10>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 80009fa:	6858      	ldr	r0, [r3, #4]
 80009fc:	2104      	movs	r1, #4
 80009fe:	4790      	blx	r2
 8000a00:	e7f6      	b.n	80009f0 <chPoolAlloc+0x10>
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	46c0      	nop			; (mov r8, r8)
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	46c0      	nop			; (mov r8, r8)
 8000a0a:	46c0      	nop			; (mov r8, r8)
 8000a0c:	46c0      	nop			; (mov r8, r8)
 8000a0e:	46c0      	nop			; (mov r8, r8)

08000a10 <chEvtAddEvents>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a10:	b672      	cpsid	i
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->epending |= events;
 8000a12:	4b03      	ldr	r3, [pc, #12]	; (8000a20 <chEvtAddEvents+0x10>)
 8000a14:	699b      	ldr	r3, [r3, #24]
 8000a16:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a18:	4310      	orrs	r0, r2
 8000a1a:	6358      	str	r0, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a1c:	b662      	cpsie	i
  events = currp->epending;
  chSysUnlock();

  return events;
}
 8000a1e:	4770      	bx	lr
 8000a20:	20000ed4 	.word	0x20000ed4
 8000a24:	46c0      	nop			; (mov r8, r8)
 8000a26:	46c0      	nop			; (mov r8, r8)
 8000a28:	46c0      	nop			; (mov r8, r8)
 8000a2a:	46c0      	nop			; (mov r8, r8)
 8000a2c:	46c0      	nop			; (mov r8, r8)
 8000a2e:	46c0      	nop			; (mov r8, r8)

08000a30 <chEvtUnregister>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a30:	b672      	cpsid	i
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8000a32:	1c02      	adds	r2, r0, #0
 8000a34:	e002      	b.n	8000a3c <chEvtUnregister+0xc>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 8000a36:	428b      	cmp	r3, r1
 8000a38:	d005      	beq.n	8000a46 <chEvtUnregister+0x16>
 8000a3a:	1c1a      	adds	r2, r3, #0
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 8000a3c:	6813      	ldr	r3, [r2, #0]
 8000a3e:	4283      	cmp	r3, r0
 8000a40:	d1f9      	bne.n	8000a36 <chEvtUnregister+0x6>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a42:	b662      	cpsie	i
      break;
    }
    p = p->next;
  }
  chSysUnlock();
}
 8000a44:	4770      	bx	lr
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
 8000a46:	6809      	ldr	r1, [r1, #0]
 8000a48:	6011      	str	r1, [r2, #0]
 8000a4a:	e7fa      	b.n	8000a42 <chEvtUnregister+0x12>
 8000a4c:	46c0      	nop			; (mov r8, r8)
 8000a4e:	46c0      	nop			; (mov r8, r8)

08000a50 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000a50:	6882      	ldr	r2, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000a52:	6841      	ldr	r1, [r0, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000a54:	1c13      	adds	r3, r2, #0
 8000a56:	3b48      	subs	r3, #72	; 0x48
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000a58:	b510      	push	{r4, lr}
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000a5a:	6904      	ldr	r4, [r0, #16]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000a5c:	61d9      	str	r1, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000a5e:	1c11      	adds	r1, r2, #0
 8000a60:	396c      	subs	r1, #108	; 0x6c
 8000a62:	60d9      	str	r1, [r3, #12]
 8000a64:	610c      	str	r4, [r1, #16]
 8000a66:	6944      	ldr	r4, [r0, #20]
 8000a68:	614c      	str	r4, [r1, #20]
 8000a6a:	4c10      	ldr	r4, [pc, #64]	; (8000aac <chThdCreateSuspendedI+0x5c>)
 8000a6c:	620c      	str	r4, [r1, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000a6e:	6801      	ldr	r1, [r0, #0]
 8000a70:	68c0      	ldr	r0, [r0, #12]
 8000a72:	6199      	str	r1, [r3, #24]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000a74:	2402      	movs	r4, #2
 8000a76:	2120      	movs	r1, #32
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000a78:	6098      	str	r0, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8000a7a:	545c      	strb	r4, [r3, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000a7c:	2100      	movs	r1, #0
 8000a7e:	2421      	movs	r4, #33	; 0x21
 8000a80:	5519      	strb	r1, [r3, r4]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000a82:	63d8      	str	r0, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8000a84:	6399      	str	r1, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000a86:	6359      	str	r1, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000a88:	2001      	movs	r0, #1
 8000a8a:	2122      	movs	r1, #34	; 0x22
 8000a8c:	5458      	strb	r0, [r3, r1]
  tp->name      = name;
  REG_INSERT(tp);
 8000a8e:	4908      	ldr	r1, [pc, #32]	; (8000ab0 <chThdCreateSuspendedI+0x60>)
 8000a90:	6948      	ldr	r0, [r1, #20]
 8000a92:	6119      	str	r1, [r3, #16]
 8000a94:	6158      	str	r0, [r3, #20]
 8000a96:	6103      	str	r3, [r0, #16]
 8000a98:	614b      	str	r3, [r1, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000a9a:	1c11      	adds	r1, r2, #0
 8000a9c:	3920      	subs	r1, #32
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8000a9e:	3a1c      	subs	r2, #28
 8000aa0:	6009      	str	r1, [r1, #0]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8000aa2:	1c18      	adds	r0, r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000aa4:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8000aa6:	6052      	str	r2, [r2, #4]
 8000aa8:	bd10      	pop	{r4, pc}
 8000aaa:	46c0      	nop			; (mov r8, r8)
 8000aac:	080001f1 	.word	0x080001f1
 8000ab0:	20000ed4 	.word	0x20000ed4
 8000ab4:	46c0      	nop			; (mov r8, r8)
 8000ab6:	46c0      	nop			; (mov r8, r8)
 8000ab8:	46c0      	nop			; (mov r8, r8)
 8000aba:	46c0      	nop			; (mov r8, r8)
 8000abc:	46c0      	nop			; (mov r8, r8)
 8000abe:	46c0      	nop			; (mov r8, r8)

08000ac0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000ac0:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000ac2:	4c0f      	ldr	r4, [pc, #60]	; (8000b00 <chSchRescheduleS+0x40>)
 8000ac4:	6820      	ldr	r0, [r4, #0]
 8000ac6:	69a1      	ldr	r1, [r4, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000ac8:	6883      	ldr	r3, [r0, #8]
 8000aca:	688a      	ldr	r2, [r1, #8]
 8000acc:	4293      	cmp	r3, r2
 8000ace:	d800      	bhi.n	8000ad2 <chSchRescheduleS+0x12>
    chSchDoRescheduleAhead();
  }
}
 8000ad0:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000ad2:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000ad4:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ad6:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000ad8:	6023      	str	r3, [r4, #0]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000ada:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8000adc:	2420      	movs	r4, #32
 8000ade:	5505      	strb	r5, [r0, r4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000ae0:	2500      	movs	r5, #0
 8000ae2:	550d      	strb	r5, [r1, r4]
 8000ae4:	e000      	b.n	8000ae8 <chSchRescheduleS+0x28>
 8000ae6:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8000ae8:	689c      	ldr	r4, [r3, #8]
 8000aea:	42a2      	cmp	r2, r4
 8000aec:	d3fb      	bcc.n	8000ae6 <chSchRescheduleS+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000aee:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000af0:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000af2:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000af4:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8000af6:	6059      	str	r1, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000af8:	f7ff fb6a 	bl	80001d0 <_port_switch>
 8000afc:	e7e8      	b.n	8000ad0 <chSchRescheduleS+0x10>
 8000afe:	46c0      	nop			; (mov r8, r8)
 8000b00:	20000ed4 	.word	0x20000ed4
 8000b04:	46c0      	nop			; (mov r8, r8)
 8000b06:	46c0      	nop			; (mov r8, r8)
 8000b08:	46c0      	nop			; (mov r8, r8)
 8000b0a:	46c0      	nop			; (mov r8, r8)
 8000b0c:	46c0      	nop			; (mov r8, r8)
 8000b0e:	46c0      	nop			; (mov r8, r8)

08000b10 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8000b10:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b12:	b672      	cpsid	i

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8000b14:	4b07      	ldr	r3, [pc, #28]	; (8000b34 <chThdSetPriority+0x24>)
 8000b16:	699b      	ldr	r3, [r3, #24]
 8000b18:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8000b1a:	6899      	ldr	r1, [r3, #8]
 8000b1c:	428c      	cmp	r4, r1
 8000b1e:	d001      	beq.n	8000b24 <chThdSetPriority+0x14>
 8000b20:	4281      	cmp	r1, r0
 8000b22:	d200      	bcs.n	8000b26 <chThdSetPriority+0x16>
    currp->prio = newprio;
 8000b24:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 8000b26:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 8000b28:	f7ff ffca 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b2c:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 8000b2e:	1c20      	adds	r0, r4, #0
 8000b30:	bd10      	pop	{r4, pc}
 8000b32:	46c0      	nop			; (mov r8, r8)
 8000b34:	20000ed4 	.word	0x20000ed4
 8000b38:	46c0      	nop			; (mov r8, r8)
 8000b3a:	46c0      	nop			; (mov r8, r8)
 8000b3c:	46c0      	nop			; (mov r8, r8)
 8000b3e:	46c0      	nop			; (mov r8, r8)

08000b40 <test_002_003_execute.8698>:
 * - [2.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_002_003_execute(void) {
 8000b40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b42:	464e      	mov	r6, r9
 8000b44:	4645      	mov	r5, r8
 8000b46:	4657      	mov	r7, sl
 8000b48:	b4e0      	push	{r5, r6, r7}
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8000b4a:	4a20      	ldr	r2, [pc, #128]	; (8000bcc <test_002_003_execute.8698+0x8c>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000b4c:	4e20      	ldr	r6, [pc, #128]	; (8000bd0 <test_002_003_execute.8698+0x90>)
 8000b4e:	2301      	movs	r3, #1
 8000b50:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8000b52:	69b3      	ldr	r3, [r6, #24]
 8000b54:	4691      	mov	r9, r2
 8000b56:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000b58:	1c65      	adds	r5, r4, #1
 8000b5a:	1c28      	adds	r0, r5, #0
 8000b5c:	f7ff ffd8 	bl	8000b10 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8000b60:	4f1c      	ldr	r7, [pc, #112]	; (8000bd4 <test_002_003_execute.8698+0x94>)
  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000b62:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 8000b64:	1b00      	subs	r0, r0, r4
 8000b66:	4243      	negs	r3, r0
 8000b68:	4158      	adcs	r0, r3
 8000b6a:	b2c0      	uxtb	r0, r0
 8000b6c:	1c39      	adds	r1, r7, #0
 8000b6e:	f7ff fe9f 	bl	80008b0 <_test_assert>
 8000b72:	2800      	cmp	r0, #0
 8000b74:	d004      	beq.n	8000b80 <test_002_003_execute.8698+0x40>
  {
    p1 = chThdSetPriority(p1);
    test_assert(p1 == prio + 1, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
  }
}
 8000b76:	bc1c      	pop	{r2, r3, r4}
 8000b78:	4690      	mov	r8, r2
 8000b7a:	4699      	mov	r9, r3
 8000b7c:	46a2      	mov	sl, r4
 8000b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b80:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
    test_assert(p1 == prio, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8000b82:	6898      	ldr	r0, [r3, #8]
 8000b84:	1a28      	subs	r0, r5, r0
 8000b86:	4243      	negs	r3, r0
 8000b88:	4158      	adcs	r0, r3
 8000b8a:	4b13      	ldr	r3, [pc, #76]	; (8000bd8 <test_002_003_execute.8698+0x98>)
 8000b8c:	b2c0      	uxtb	r0, r0
 8000b8e:	1c19      	adds	r1, r3, #0
 8000b90:	469a      	mov	sl, r3
 8000b92:	f7ff fe8d 	bl	80008b0 <_test_assert>
 8000b96:	2800      	cmp	r0, #0
 8000b98:	d1ed      	bne.n	8000b76 <test_002_003_execute.8698+0x36>
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8000b9a:	2302      	movs	r3, #2
 8000b9c:	464a      	mov	r2, r9
  {
    p1 = chThdSetPriority(p1);
 8000b9e:	4640      	mov	r0, r8
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8000ba0:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(p1);
 8000ba2:	f7ff ffb5 	bl	8000b10 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8000ba6:	1a28      	subs	r0, r5, r0
 8000ba8:	4245      	negs	r5, r0
 8000baa:	4168      	adcs	r0, r5
 8000bac:	b2c0      	uxtb	r0, r0
 8000bae:	1c39      	adds	r1, r7, #0
 8000bb0:	f7ff fe7e 	bl	80008b0 <_test_assert>
 8000bb4:	2800      	cmp	r0, #0
 8000bb6:	d1de      	bne.n	8000b76 <test_002_003_execute.8698+0x36>
 8000bb8:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8000bba:	4651      	mov	r1, sl
 8000bbc:	6898      	ldr	r0, [r3, #8]
 8000bbe:	1a20      	subs	r0, r4, r0
 8000bc0:	4244      	negs	r4, r0
 8000bc2:	4160      	adcs	r0, r4
 8000bc4:	b2c0      	uxtb	r0, r0
 8000bc6:	f7ff fe73 	bl	80008b0 <_test_assert>
 8000bca:	e7d4      	b.n	8000b76 <test_002_003_execute.8698+0x36>
 8000bcc:	20000f44 	.word	0x20000f44
 8000bd0:	20000ed4 	.word	0x20000ed4
 8000bd4:	08005c80 	.word	0x08005c80
 8000bd8:	08005ca4 	.word	0x08005ca4
 8000bdc:	46c0      	nop			; (mov r8, r8)
 8000bde:	46c0      	nop			; (mov r8, r8)

08000be0 <chSysRestoreStatusX.part.2.4295>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8000be0:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8000be2:	f3ef 8305 	mrs	r3, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8000be6:	05db      	lsls	r3, r3, #23

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8000be8:	d101      	bne.n	8000bee <chSysRestoreStatusX.part.2.4295+0xe>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8000bea:	f7ff ff69 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000bee:	b662      	cpsie	i
      chSysUnlock();
    }
  }
}
 8000bf0:	bd08      	pop	{r3, pc}
 8000bf2:	46c0      	nop			; (mov r8, r8)
 8000bf4:	46c0      	nop			; (mov r8, r8)
 8000bf6:	46c0      	nop			; (mov r8, r8)
 8000bf8:	46c0      	nop			; (mov r8, r8)
 8000bfa:	46c0      	nop			; (mov r8, r8)
 8000bfc:	46c0      	nop			; (mov r8, r8)
 8000bfe:	46c0      	nop			; (mov r8, r8)

08000c00 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000c00:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000c02:	4e15      	ldr	r6, [pc, #84]	; (8000c58 <chSchWakeupS+0x58>)

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000c04:	6884      	ldr	r4, [r0, #8]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8000c06:	69b5      	ldr	r5, [r6, #24]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000c08:	6241      	str	r1, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000c0a:	68aa      	ldr	r2, [r5, #8]
 8000c0c:	4294      	cmp	r4, r2
 8000c0e:	d80d      	bhi.n	8000c2c <chSchWakeupS+0x2c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000c10:	2320      	movs	r3, #32
 8000c12:	2200      	movs	r2, #0
 8000c14:	54c2      	strb	r2, [r0, r3]
  cp = (thread_t *)&ch.rlist.queue;
 8000c16:	1c33      	adds	r3, r6, #0
  do {
    cp = cp->queue.next;
 8000c18:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000c1a:	6899      	ldr	r1, [r3, #8]
 8000c1c:	428c      	cmp	r4, r1
 8000c1e:	d9fb      	bls.n	8000c18 <chSchWakeupS+0x18>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000c20:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000c22:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c24:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000c26:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c28:	6058      	str	r0, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8000c2a:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000c2c:	2320      	movs	r3, #32
 8000c2e:	2100      	movs	r1, #0
 8000c30:	54e9      	strb	r1, [r5, r3]
  cp = (thread_t *)&ch.rlist.queue;
 8000c32:	1c33      	adds	r3, r6, #0
  do {
    cp = cp->queue.next;
 8000c34:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000c36:	6899      	ldr	r1, [r3, #8]
 8000c38:	428a      	cmp	r2, r1
 8000c3a:	d9fb      	bls.n	8000c34 <chSchWakeupS+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000c3c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000c3e:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c40:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8000c42:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 8000c44:	605d      	str	r5, [r3, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8000c46:	2201      	movs	r2, #1
 8000c48:	2320      	movs	r3, #32
 8000c4a:	54c2      	strb	r2, [r0, r3]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000c4c:	1c29      	adds	r1, r5, #0
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8000c4e:	61b0      	str	r0, [r6, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000c50:	f7ff fabe 	bl	80001d0 <_port_switch>
 8000c54:	e7e9      	b.n	8000c2a <chSchWakeupS+0x2a>
 8000c56:	46c0      	nop			; (mov r8, r8)
 8000c58:	20000ed4 	.word	0x20000ed4
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46c0      	nop			; (mov r8, r8)

08000c60 <chThdCreateFromMemoryPool.constprop.24>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8000c60:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8000c62:	4d12      	ldr	r5, [pc, #72]	; (8000cac <chThdCreateFromMemoryPool.constprop.24+0x4c>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8000c64:	b087      	sub	sp, #28
 8000c66:	1c07      	adds	r7, r0, #0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8000c68:	1c28      	adds	r0, r5, #0
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8000c6a:	1c0e      	adds	r6, r1, #0
 8000c6c:	1c14      	adds	r4, r2, #0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8000c6e:	f7ff feb7 	bl	80009e0 <chPoolAlloc>
  if (wsp == NULL) {
 8000c72:	2800      	cmp	r0, #0
 8000c74:	d018      	beq.n	8000ca8 <chThdCreateFromMemoryPool.constprop.24+0x48>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8000c76:	686b      	ldr	r3, [r5, #4]
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8000c78:	9001      	str	r0, [sp, #4]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8000c7a:	18c0      	adds	r0, r0, r3
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8000c7c:	4b0c      	ldr	r3, [pc, #48]	; (8000cb0 <chThdCreateFromMemoryPool.constprop.24+0x50>)
 8000c7e:	9700      	str	r7, [sp, #0]
 8000c80:	9002      	str	r0, [sp, #8]
 8000c82:	9603      	str	r6, [sp, #12]
 8000c84:	9304      	str	r3, [sp, #16]
 8000c86:	9405      	str	r4, [sp, #20]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c88:	b672      	cpsid	i
                  CH_DBG_STACK_FILL_VALUE);
#endif


  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8000c8a:	4668      	mov	r0, sp
 8000c8c:	f7ff fee0 	bl	8000a50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8000c90:	2202      	movs	r2, #2
 8000c92:	2321      	movs	r3, #33	; 0x21
 8000c94:	54c2      	strb	r2, [r0, r3]
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8000c96:	2100      	movs	r1, #0


  chSysLock();
  tp = chThdCreateSuspendedI(&td);
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
 8000c98:	6405      	str	r5, [r0, #64]	; 0x40
                  CH_DBG_STACK_FILL_VALUE);
#endif


  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8000c9a:	1c04      	adds	r4, r0, #0
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8000c9c:	f7ff ffb0 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ca0:	b662      	cpsie	i
 8000ca2:	1c20      	adds	r0, r4, #0
  chSysUnlock();

  return tp;
}
 8000ca4:	b007      	add	sp, #28
 8000ca6:	bdf0      	pop	{r4, r5, r6, r7, pc}

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
 8000ca8:	2000      	movs	r0, #0
 8000caa:	e7fb      	b.n	8000ca4 <chThdCreateFromMemoryPool.constprop.24+0x44>
 8000cac:	20000bd8 	.word	0x20000bd8
 8000cb0:	08000611 	.word	0x08000611
 8000cb4:	46c0      	nop			; (mov r8, r8)
 8000cb6:	46c0      	nop			; (mov r8, r8)
 8000cb8:	46c0      	nop			; (mov r8, r8)
 8000cba:	46c0      	nop			; (mov r8, r8)
 8000cbc:	46c0      	nop			; (mov r8, r8)
 8000cbe:	46c0      	nop			; (mov r8, r8)

08000cc0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8000cc0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cc2:	b672      	cpsid	i
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->cnt <= (cnt_t)0) {
 8000cc4:	6883      	ldr	r3, [r0, #8]
 8000cc6:	3301      	adds	r3, #1
 8000cc8:	6083      	str	r3, [r0, #8]
 8000cca:	2b00      	cmp	r3, #0
 8000ccc:	dd01      	ble.n	8000cd2 <chSemSignal+0x12>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cce:	b662      	cpsie	i
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
  }
  chSysUnlock();
}
 8000cd0:	bd08      	pop	{r3, pc}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000cd2:	6803      	ldr	r3, [r0, #0]
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->cnt <= (cnt_t)0) {
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8000cd4:	2100      	movs	r1, #0

  tqp->next             = tp->queue.next;
 8000cd6:	681a      	ldr	r2, [r3, #0]
 8000cd8:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000cda:	6050      	str	r0, [r2, #4]
 8000cdc:	1c18      	adds	r0, r3, #0
 8000cde:	f7ff ff8f 	bl	8000c00 <chSchWakeupS>
 8000ce2:	e7f4      	b.n	8000cce <chSemSignal+0xe>
 8000ce4:	46c0      	nop			; (mov r8, r8)
 8000ce6:	46c0      	nop			; (mov r8, r8)
 8000ce8:	46c0      	nop			; (mov r8, r8)
 8000cea:	46c0      	nop			; (mov r8, r8)
 8000cec:	46c0      	nop			; (mov r8, r8)
 8000cee:	46c0      	nop			; (mov r8, r8)

08000cf0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000cf0:	4b07      	ldr	r3, [pc, #28]	; (8000d10 <chSchGoSleepS+0x20>)

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000cf2:	2220      	movs	r2, #32
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000cf4:	6999      	ldr	r1, [r3, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000cf6:	b510      	push	{r4, lr}
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000cf8:	5488      	strb	r0, [r1, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000cfa:	6818      	ldr	r0, [r3, #0]

  tqp->next             = tp->queue.next;
 8000cfc:	6804      	ldr	r4, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000cfe:	6063      	str	r3, [r4, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000d00:	601c      	str	r4, [r3, #0]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000d02:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8000d04:	2301      	movs	r3, #1
 8000d06:	5483      	strb	r3, [r0, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000d08:	f7ff fa62 	bl	80001d0 <_port_switch>
}
 8000d0c:	bd10      	pop	{r4, pc}
 8000d0e:	46c0      	nop			; (mov r8, r8)
 8000d10:	20000ed4 	.word	0x20000ed4
 8000d14:	46c0      	nop			; (mov r8, r8)
 8000d16:	46c0      	nop			; (mov r8, r8)
 8000d18:	46c0      	nop			; (mov r8, r8)
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	46c0      	nop			; (mov r8, r8)
 8000d1e:	46c0      	nop			; (mov r8, r8)

08000d20 <bmk_thread4.10603>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000d20:	4b05      	ldr	r3, [pc, #20]	; (8000d38 <bmk_thread4.10603+0x18>)
static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
}

static THD_FUNCTION(bmk_thread4, p) {
 8000d22:	b510      	push	{r4, lr}
 8000d24:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d26:	b672      	cpsid	i
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8000d28:	2003      	movs	r0, #3
 8000d2a:	f7ff ffe1 	bl	8000cf0 <chSchGoSleepS>
    msg = self->u.rdymsg;
  } while (msg == MSG_OK);
 8000d2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000d30:	2b00      	cmp	r3, #0
 8000d32:	d0f9      	beq.n	8000d28 <bmk_thread4.10603+0x8>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d34:	b662      	cpsie	i
  chSysUnlock();
}
 8000d36:	bd10      	pop	{r4, pc}
 8000d38:	20000ed4 	.word	0x20000ed4
 8000d3c:	46c0      	nop			; (mov r8, r8)
 8000d3e:	46c0      	nop			; (mov r8, r8)

08000d40 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8000d40:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d42:	b672      	cpsid	i
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8000d44:	4c0b      	ldr	r4, [pc, #44]	; (8000d74 <chMsgWait+0x34>)
 8000d46:	69a3      	ldr	r3, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8000d48:	1c1a      	adds	r2, r3, #0
 8000d4a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8000d4c:	322c      	adds	r2, #44	; 0x2c
 8000d4e:	4290      	cmp	r0, r2
 8000d50:	d007      	beq.n	8000d62 <chMsgWait+0x22>
 8000d52:	6801      	ldr	r1, [r0, #0]
 8000d54:	62d9      	str	r1, [r3, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
 8000d56:	604a      	str	r2, [r1, #4]
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 8000d58:	2320      	movs	r3, #32
 8000d5a:	220d      	movs	r2, #13
 8000d5c:	54c2      	strb	r2, [r0, r3]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d5e:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8000d60:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8000d62:	200e      	movs	r0, #14
 8000d64:	f7ff ffc4 	bl	8000cf0 <chSchGoSleepS>
 8000d68:	69a3      	ldr	r3, [r4, #24]
 8000d6a:	1c1a      	adds	r2, r3, #0
 8000d6c:	322c      	adds	r2, #44	; 0x2c
 8000d6e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8000d70:	e7ef      	b.n	8000d52 <chMsgWait+0x12>
 8000d72:	46c0      	nop			; (mov r8, r8)
 8000d74:	20000ed4 	.word	0x20000ed4
 8000d78:	46c0      	nop			; (mov r8, r8)
 8000d7a:	46c0      	nop			; (mov r8, r8)
 8000d7c:	46c0      	nop			; (mov r8, r8)
 8000d7e:	46c0      	nop			; (mov r8, r8)

08000d80 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8000d80:	b510      	push	{r4, lr}
 8000d82:	1c03      	adds	r3, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d84:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000d86:	6882      	ldr	r2, [r0, #8]
 8000d88:	3a01      	subs	r2, #1
 8000d8a:	6082      	str	r2, [r0, #8]
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->u.rdymsg;
  }

  return MSG_OK;
 8000d8c:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000d8e:	2a00      	cmp	r2, #0
 8000d90:	db01      	blt.n	8000d96 <chSemWait+0x16>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d92:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8000d94:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 8000d96:	4c07      	ldr	r4, [pc, #28]	; (8000db4 <chSemWait+0x34>)
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000d98:	2005      	movs	r0, #5
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 8000d9a:	69a2      	ldr	r2, [r4, #24]
 8000d9c:	6253      	str	r3, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8000d9e:	6859      	ldr	r1, [r3, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8000da0:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = tqp->prev;
 8000da2:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8000da4:	600a      	str	r2, [r1, #0]
  tqp->prev                  = tp;
 8000da6:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000da8:	f7ff ffa2 	bl	8000cf0 <chSchGoSleepS>

    return currp->u.rdymsg;
 8000dac:	69a3      	ldr	r3, [r4, #24]
 8000dae:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000db0:	e7ef      	b.n	8000d92 <chSemWait+0x12>
 8000db2:	46c0      	nop			; (mov r8, r8)
 8000db4:	20000ed4 	.word	0x20000ed4
 8000db8:	46c0      	nop			; (mov r8, r8)
 8000dba:	46c0      	nop			; (mov r8, r8)
 8000dbc:	46c0      	nop			; (mov r8, r8)
 8000dbe:	46c0      	nop			; (mov r8, r8)

08000dc0 <bmk_thread7.10597>:

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 8000dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000dc2:	4c08      	ldr	r4, [pc, #32]	; (8000de4 <bmk_thread7.10597+0x24>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8000dc4:	2321      	movs	r3, #33	; 0x21
 8000dc6:	69a2      	ldr	r2, [r4, #24]
 8000dc8:	5cd3      	ldrb	r3, [r2, r3]

  (void)p;
  while (!chThdShouldTerminateX())
 8000dca:	075a      	lsls	r2, r3, #29
 8000dcc:	d409      	bmi.n	8000de2 <bmk_thread7.10597+0x22>
 8000dce:	4f06      	ldr	r7, [pc, #24]	; (8000de8 <bmk_thread7.10597+0x28>)
 8000dd0:	2621      	movs	r6, #33	; 0x21
 8000dd2:	2504      	movs	r5, #4
    chSemWait(&sem1);
 8000dd4:	1c38      	adds	r0, r7, #0
 8000dd6:	f7ff ffd3 	bl	8000d80 <chSemWait>
 8000dda:	69a2      	ldr	r2, [r4, #24]
 8000ddc:	5d93      	ldrb	r3, [r2, r6]

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8000dde:	421d      	tst	r5, r3
 8000de0:	d0f8      	beq.n	8000dd4 <bmk_thread7.10597+0x14>
    chSemWait(&sem1);
}
 8000de2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000de4:	20000ed4 	.word	0x20000ed4
 8000de8:	20000ba8 	.word	0x20000ba8
 8000dec:	46c0      	nop			; (mov r8, r8)
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <thread1.9145>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 8000df0:	b510      	push	{r4, lr}
 8000df2:	1c04      	adds	r4, r0, #0

  chSemWait(&sem1);
 8000df4:	4803      	ldr	r0, [pc, #12]	; (8000e04 <thread1.9145+0x14>)
 8000df6:	f7ff ffc3 	bl	8000d80 <chSemWait>
  test_emit_token(*(char *)p);
 8000dfa:	7820      	ldrb	r0, [r4, #0]
 8000dfc:	f7ff fbf8 	bl	80005f0 <test_emit_token>
}
 8000e00:	bd10      	pop	{r4, pc}
 8000e02:	46c0      	nop			; (mov r8, r8)
 8000e04:	20000508 	.word	0x20000508
 8000e08:	46c0      	nop			; (mov r8, r8)
 8000e0a:	46c0      	nop			; (mov r8, r8)
 8000e0c:	46c0      	nop			; (mov r8, r8)
 8000e0e:	46c0      	nop			; (mov r8, r8)

08000e10 <thread3.9148>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {
 8000e10:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8000e12:	4c04      	ldr	r4, [pc, #16]	; (8000e24 <thread3.9148+0x14>)
 8000e14:	1c20      	adds	r0, r4, #0
 8000e16:	f7ff ffb3 	bl	8000d80 <chSemWait>
  chSemSignal(&sem1);
 8000e1a:	1c20      	adds	r0, r4, #0
 8000e1c:	f7ff ff50 	bl	8000cc0 <chSemSignal>
}
 8000e20:	bd10      	pop	{r4, pc}
 8000e22:	46c0      	nop			; (mov r8, r8)
 8000e24:	20000508 	.word	0x20000508
 8000e28:	46c0      	nop			; (mov r8, r8)
 8000e2a:	46c0      	nop			; (mov r8, r8)
 8000e2c:	46c0      	nop			; (mov r8, r8)
 8000e2e:	46c0      	nop			; (mov r8, r8)

08000e30 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000e30:	2200      	movs	r2, #0
 8000e32:	2320      	movs	r3, #32
 8000e34:	54c2      	strb	r2, [r0, r3]
 8000e36:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000e38:	4b05      	ldr	r3, [pc, #20]	; (8000e50 <chSchReadyI+0x20>)
  do {
    cp = cp->queue.next;
 8000e3a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000e3c:	6899      	ldr	r1, [r3, #8]
 8000e3e:	4291      	cmp	r1, r2
 8000e40:	d2fb      	bcs.n	8000e3a <chSchReadyI+0xa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000e42:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000e44:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000e46:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000e48:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000e4a:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000e4c:	4770      	bx	lr
 8000e4e:	46c0      	nop			; (mov r8, r8)
 8000e50:	20000ed4 	.word	0x20000ed4
 8000e54:	46c0      	nop			; (mov r8, r8)
 8000e56:	46c0      	nop			; (mov r8, r8)
 8000e58:	46c0      	nop			; (mov r8, r8)
 8000e5a:	46c0      	nop			; (mov r8, r8)
 8000e5c:	46c0      	nop			; (mov r8, r8)
 8000e5e:	46c0      	nop			; (mov r8, r8)

08000e60 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8000e60:	4b0c      	ldr	r3, [pc, #48]	; (8000e94 <chMsgSend+0x34>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8000e62:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8000e64:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e66:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
 8000e68:	1c03      	adds	r3, r0, #0
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
 8000e6a:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
 8000e6c:	332c      	adds	r3, #44	; 0x2c
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8000e6e:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = tqp->prev;
 8000e70:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8000e72:	6063      	str	r3, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8000e74:	601c      	str	r4, [r3, #0]
  tqp->prev                  = tp;
 8000e76:	6304      	str	r4, [r0, #48]	; 0x30
  if (tp->state == CH_STATE_WTMSG) {
 8000e78:	2320      	movs	r3, #32
 8000e7a:	5cc3      	ldrb	r3, [r0, r3]
 8000e7c:	2b0e      	cmp	r3, #14
 8000e7e:	d005      	beq.n	8000e8c <chMsgSend+0x2c>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8000e80:	200c      	movs	r0, #12
 8000e82:	f7ff ff35 	bl	8000cf0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8000e86:	6a60      	ldr	r0, [r4, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e88:	b662      	cpsie	i
  chSysUnlock();

  return msg;
}
 8000e8a:	bd10      	pop	{r4, pc}

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8000e8c:	f7ff ffd0 	bl	8000e30 <chSchReadyI>
 8000e90:	e7f6      	b.n	8000e80 <chMsgSend+0x20>
 8000e92:	46c0      	nop			; (mov r8, r8)
 8000e94:	20000ed4 	.word	0x20000ed4
 8000e98:	46c0      	nop			; (mov r8, r8)
 8000e9a:	46c0      	nop			; (mov r8, r8)
 8000e9c:	46c0      	nop			; (mov r8, r8)
 8000e9e:	46c0      	nop			; (mov r8, r8)

08000ea0 <msg_thread1.9531>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8000ea0:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8000ea2:	2141      	movs	r1, #65	; 0x41

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8000ea4:	1c04      	adds	r4, r0, #0

  chMsgSend(p, 'A');
 8000ea6:	f7ff ffdb 	bl	8000e60 <chMsgSend>
  chMsgSend(p, 'B');
 8000eaa:	1c20      	adds	r0, r4, #0
 8000eac:	2142      	movs	r1, #66	; 0x42
 8000eae:	f7ff ffd7 	bl	8000e60 <chMsgSend>
  chMsgSend(p, 'C');
 8000eb2:	1c20      	adds	r0, r4, #0
 8000eb4:	2143      	movs	r1, #67	; 0x43
 8000eb6:	f7ff ffd3 	bl	8000e60 <chMsgSend>
  chMsgSend(p, 'D');
 8000eba:	1c20      	adds	r0, r4, #0
 8000ebc:	2144      	movs	r1, #68	; 0x44
 8000ebe:	f7ff ffcf 	bl	8000e60 <chMsgSend>
}
 8000ec2:	bd10      	pop	{r4, pc}
 8000ec4:	46c0      	nop			; (mov r8, r8)
 8000ec6:	46c0      	nop			; (mov r8, r8)
 8000ec8:	46c0      	nop			; (mov r8, r8)
 8000eca:	46c0      	nop			; (mov r8, r8)
 8000ecc:	46c0      	nop			; (mov r8, r8)
 8000ece:	46c0      	nop			; (mov r8, r8)

08000ed0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000ed0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000ed2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000ed4:	4319      	orrs	r1, r3
 8000ed6:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ed8:	2320      	movs	r3, #32
 8000eda:	5cc3      	ldrb	r3, [r0, r3]
 8000edc:	2b0a      	cmp	r3, #10
 8000ede:	d00b      	beq.n	8000ef8 <chEvtSignalI+0x28>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000ee0:	2b0b      	cmp	r3, #11
 8000ee2:	d000      	beq.n	8000ee6 <chEvtSignalI+0x16>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000ee4:	bd08      	pop	{r3, pc}
  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000ee6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000ee8:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000eea:	428b      	cmp	r3, r1
 8000eec:	d1fa      	bne.n	8000ee4 <chEvtSignalI+0x14>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000eee:	2300      	movs	r3, #0
 8000ef0:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000ef2:	f7ff ff9d 	bl	8000e30 <chSchReadyI>
 8000ef6:	e7f5      	b.n	8000ee4 <chEvtSignalI+0x14>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ef8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000efa:	420b      	tst	r3, r1
 8000efc:	d0f2      	beq.n	8000ee4 <chEvtSignalI+0x14>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000efe:	2300      	movs	r3, #0
 8000f00:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000f02:	f7ff ff95 	bl	8000e30 <chSchReadyI>
 8000f06:	e7ed      	b.n	8000ee4 <chEvtSignalI+0x14>
 8000f08:	46c0      	nop			; (mov r8, r8)
 8000f0a:	46c0      	nop			; (mov r8, r8)
 8000f0c:	46c0      	nop			; (mov r8, r8)
 8000f0e:	46c0      	nop			; (mov r8, r8)

08000f10 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000f10:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000f12:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000f14:	1c06      	adds	r6, r0, #0
 8000f16:	1c0d      	adds	r5, r1, #0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000f18:	42a0      	cmp	r0, r4
 8000f1a:	d00e      	beq.n	8000f3a <chEvtBroadcastFlagsI+0x2a>
  /*lint -restore*/
    elp->flags |= flags;
 8000f1c:	68e3      	ldr	r3, [r4, #12]
 8000f1e:	432b      	orrs	r3, r5
 8000f20:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000f22:	2d00      	cmp	r5, #0
 8000f24:	d002      	beq.n	8000f2c <chEvtBroadcastFlagsI+0x1c>
 8000f26:	6922      	ldr	r2, [r4, #16]
 8000f28:	421a      	tst	r2, r3
 8000f2a:	d003      	beq.n	8000f34 <chEvtBroadcastFlagsI+0x24>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8000f2c:	6860      	ldr	r0, [r4, #4]
 8000f2e:	68a1      	ldr	r1, [r4, #8]
 8000f30:	f7ff ffce 	bl	8000ed0 <chEvtSignalI>
    }
    elp = elp->next;
 8000f34:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000f36:	42a6      	cmp	r6, r4
 8000f38:	d1f0      	bne.n	8000f1c <chEvtBroadcastFlagsI+0xc>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
 8000f3a:	bd70      	pop	{r4, r5, r6, pc}
 8000f3c:	46c0      	nop			; (mov r8, r8)
 8000f3e:	46c0      	nop			; (mov r8, r8)

08000f40 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8000f40:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000f42:	4b11      	ldr	r3, [pc, #68]	; (8000f88 <chMtxUnlockS+0x48>)
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f44:	6804      	ldr	r4, [r0, #0]
 8000f46:	699d      	ldr	r5, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000f48:	68c3      	ldr	r3, [r0, #12]
 8000f4a:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000f4c:	42a0      	cmp	r0, r4
 8000f4e:	d018      	beq.n	8000f82 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000f50:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000f52:	2b00      	cmp	r3, #0
 8000f54:	d009      	beq.n	8000f6a <chMtxUnlockS+0x2a>
 8000f56:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000f58:	4293      	cmp	r3, r2
 8000f5a:	d003      	beq.n	8000f64 <chMtxUnlockS+0x24>
            (lmp->queue.next->prio > newprio)) {
 8000f5c:	6892      	ldr	r2, [r2, #8]
 8000f5e:	4291      	cmp	r1, r2
 8000f60:	d200      	bcs.n	8000f64 <chMtxUnlockS+0x24>
 8000f62:	1c11      	adds	r1, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000f64:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000f66:	2b00      	cmp	r3, #0
 8000f68:	d1f5      	bne.n	8000f56 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000f6a:	6823      	ldr	r3, [r4, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8000f6c:	60a9      	str	r1, [r5, #8]
 8000f6e:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000f70:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000f72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8000f74:	6084      	str	r4, [r0, #8]
      mp->next = tp->mtxlist;
 8000f76:	60c3      	str	r3, [r0, #12]
      tp->mtxlist = mp;
 8000f78:	63a0      	str	r0, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8000f7a:	1c20      	adds	r0, r4, #0
 8000f7c:	f7ff ff58 	bl	8000e30 <chSchReadyI>
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000f80:	bd38      	pop	{r3, r4, r5, pc}
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    }
    else {
      mp->owner = NULL;
 8000f82:	2300      	movs	r3, #0
 8000f84:	6083      	str	r3, [r0, #8]
 8000f86:	e7fb      	b.n	8000f80 <chMtxUnlockS+0x40>
 8000f88:	20000ed4 	.word	0x20000ed4
 8000f8c:	46c0      	nop			; (mov r8, r8)
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000f90:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000f92:	4b13      	ldr	r3, [pc, #76]	; (8000fe0 <chMtxUnlock+0x50>)
 8000f94:	699d      	ldr	r5, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f96:	b672      	cpsid	i
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000f98:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f9a:	6804      	ldr	r4, [r0, #0]
 8000f9c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000f9e:	42a0      	cmp	r0, r4
 8000fa0:	d01b      	beq.n	8000fda <chMtxUnlock+0x4a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000fa2:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000fa4:	2b00      	cmp	r3, #0
 8000fa6:	d009      	beq.n	8000fbc <chMtxUnlock+0x2c>
 8000fa8:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000faa:	4293      	cmp	r3, r2
 8000fac:	d003      	beq.n	8000fb6 <chMtxUnlock+0x26>
            (lmp->queue.next->prio > newprio)) {
 8000fae:	6892      	ldr	r2, [r2, #8]
 8000fb0:	4291      	cmp	r1, r2
 8000fb2:	d200      	bcs.n	8000fb6 <chMtxUnlock+0x26>
 8000fb4:	1c11      	adds	r1, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000fb6:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000fb8:	2b00      	cmp	r3, #0
 8000fba:	d1f5      	bne.n	8000fa8 <chMtxUnlock+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000fbc:	6823      	ldr	r3, [r4, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8000fbe:	60a9      	str	r1, [r5, #8]
 8000fc0:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000fc2:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000fc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8000fc6:	6084      	str	r4, [r0, #8]
      mp->next = tp->mtxlist;
 8000fc8:	60c3      	str	r3, [r0, #12]
      tp->mtxlist = mp;
 8000fca:	63a0      	str	r0, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000fcc:	1c20      	adds	r0, r4, #0
 8000fce:	f7ff ff2f 	bl	8000e30 <chSchReadyI>
      chSchRescheduleS();
 8000fd2:	f7ff fd75 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fd6:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8000fd8:	bd38      	pop	{r3, r4, r5, pc}
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8000fda:	2300      	movs	r3, #0
 8000fdc:	6083      	str	r3, [r0, #8]
 8000fde:	e7fa      	b.n	8000fd6 <chMtxUnlock+0x46>
 8000fe0:	20000ed4 	.word	0x20000ed4
 8000fe4:	46c0      	nop			; (mov r8, r8)
 8000fe6:	46c0      	nop			; (mov r8, r8)
 8000fe8:	46c0      	nop			; (mov r8, r8)
 8000fea:	46c0      	nop			; (mov r8, r8)
 8000fec:	46c0      	nop			; (mov r8, r8)
 8000fee:	46c0      	nop			; (mov r8, r8)

08000ff0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ff2:	1c05      	adds	r5, r0, #0
  thread_t *ctp = currp;
 8000ff4:	4b2f      	ldr	r3, [pc, #188]	; (80010b4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000ff6:	6880      	ldr	r0, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000ff8:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000ffa:	2800      	cmp	r0, #0
 8000ffc:	d054      	beq.n	80010a8 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000ffe:	68a2      	ldr	r2, [r4, #8]
 8001000:	6881      	ldr	r1, [r0, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001002:	2620      	movs	r6, #32
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8001004:	4291      	cmp	r1, r2
 8001006:	d207      	bcs.n	8001018 <chMtxLockS+0x28>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8001008:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800100a:	5d83      	ldrb	r3, [r0, r6]
 800100c:	2b06      	cmp	r3, #6
 800100e:	d032      	beq.n	8001076 <chMtxLockS+0x86>
 8001010:	2b07      	cmp	r3, #7
 8001012:	d01c      	beq.n	800104e <chMtxLockS+0x5e>
 8001014:	2b00      	cmp	r3, #0
 8001016:	d012      	beq.n	800103e <chMtxLockS+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001018:	1c2b      	adds	r3, r5, #0
 800101a:	e003      	b.n	8001024 <chMtxLockS+0x34>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800101c:	6899      	ldr	r1, [r3, #8]
 800101e:	68a2      	ldr	r2, [r4, #8]
 8001020:	4291      	cmp	r1, r2
 8001022:	d302      	bcc.n	800102a <chMtxLockS+0x3a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001024:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001026:	429d      	cmp	r5, r3
 8001028:	d1f8      	bne.n	800101c <chMtxLockS+0x2c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800102a:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800102c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800102e:	6062      	str	r2, [r4, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001030:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8001032:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001034:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8001036:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8001038:	f7ff fe5a 	bl	8000cf0 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 800103c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800103e:	6843      	ldr	r3, [r0, #4]
 8001040:	6807      	ldr	r7, [r0, #0]
 8001042:	601f      	str	r7, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001044:	6802      	ldr	r2, [r0, #0]
 8001046:	6053      	str	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001048:	f7ff fef2 	bl	8000e30 <chSchReadyI>
 800104c:	e7e4      	b.n	8001018 <chMtxLockS+0x28>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800104e:	6843      	ldr	r3, [r0, #4]
 8001050:	6801      	ldr	r1, [r0, #0]
 8001052:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001054:	6801      	ldr	r1, [r0, #0]
 8001056:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001058:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800105a:	1c0b      	adds	r3, r1, #0
 800105c:	e002      	b.n	8001064 <chMtxLockS+0x74>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800105e:	689e      	ldr	r6, [r3, #8]
 8001060:	4296      	cmp	r6, r2
 8001062:	d302      	bcc.n	800106a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001064:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001066:	4299      	cmp	r1, r3
 8001068:	d1f9      	bne.n	800105e <chMtxLockS+0x6e>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800106a:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800106c:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 800106e:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8001070:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8001072:	6058      	str	r0, [r3, #4]
 8001074:	e7d0      	b.n	8001018 <chMtxLockS+0x28>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001076:	6843      	ldr	r3, [r0, #4]
 8001078:	6807      	ldr	r7, [r0, #0]
 800107a:	601f      	str	r7, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800107c:	6801      	ldr	r1, [r0, #0]
 800107e:	604b      	str	r3, [r1, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001080:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001082:	1c0b      	adds	r3, r1, #0
 8001084:	e002      	b.n	800108c <chMtxLockS+0x9c>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001086:	689f      	ldr	r7, [r3, #8]
 8001088:	4297      	cmp	r7, r2
 800108a:	d302      	bcc.n	8001092 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800108c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800108e:	4299      	cmp	r1, r3
 8001090:	d1f9      	bne.n	8001086 <chMtxLockS+0x96>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001092:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001094:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8001096:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8001098:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800109a:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800109c:	6888      	ldr	r0, [r1, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800109e:	68a2      	ldr	r2, [r4, #8]
 80010a0:	6881      	ldr	r1, [r0, #8]
 80010a2:	4291      	cmp	r1, r2
 80010a4:	d3b0      	bcc.n	8001008 <chMtxLockS+0x18>
 80010a6:	e7b7      	b.n	8001018 <chMtxLockS+0x28>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 80010a8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80010aa:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
 80010ac:	60eb      	str	r3, [r5, #12]
    ctp->mtxlist = mp;
 80010ae:	63a5      	str	r5, [r4, #56]	; 0x38
 80010b0:	e7c4      	b.n	800103c <chMtxLockS+0x4c>
 80010b2:	46c0      	nop			; (mov r8, r8)
 80010b4:	20000ed4 	.word	0x20000ed4
 80010b8:	46c0      	nop			; (mov r8, r8)
 80010ba:	46c0      	nop			; (mov r8, r8)
 80010bc:	46c0      	nop			; (mov r8, r8)
 80010be:	46c0      	nop			; (mov r8, r8)

080010c0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80010c0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80010c2:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 80010c4:	f7ff ff94 	bl	8000ff0 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80010c8:	b662      	cpsie	i
  chSysUnlock();
}
 80010ca:	bd08      	pop	{r3, pc}
 80010cc:	46c0      	nop			; (mov r8, r8)
 80010ce:	46c0      	nop			; (mov r8, r8)

080010d0 <chHeapAllocAligned.constprop.26.4154>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80010d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80010d2:	4656      	mov	r6, sl
 80010d4:	464d      	mov	r5, r9
 80010d6:	465f      	mov	r7, fp
 80010d8:	4644      	mov	r4, r8
 80010da:	b4f0      	push	{r4, r5, r6, r7}
 80010dc:	4682      	mov	sl, r0
 80010de:	b083      	sub	sp, #12
 80010e0:	4689      	mov	r9, r1
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
 80010e2:	2800      	cmp	r0, #0
 80010e4:	d100      	bne.n	80010e8 <chHeapAllocAligned.constprop.26.4154+0x18>
 80010e6:	e071      	b.n	80011cc <chHeapAllocAligned.constprop.26.4154+0xfc>

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80010e8:	2110      	movs	r1, #16
 80010ea:	4688      	mov	r8, r1
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80010ec:	464e      	mov	r6, r9
 80010ee:	3607      	adds	r6, #7

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80010f0:	44d0      	add	r8, sl
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80010f2:	08f6      	lsrs	r6, r6, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80010f4:	4640      	mov	r0, r8
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80010f6:	9601      	str	r6, [sp, #4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80010f8:	f7ff ffe2 	bl	80010c0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 80010fc:	4651      	mov	r1, sl
 80010fe:	3108      	adds	r1, #8
  while (H_NEXT(qp) != NULL) {
 8001100:	680b      	ldr	r3, [r1, #0]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8001102:	2207      	movs	r2, #7
 8001104:	4693      	mov	fp, r2
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8001106:	2b00      	cmp	r3, #0
 8001108:	d01a      	beq.n	8001140 <chHeapAllocAligned.constprop.26.4154+0x70>

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800110a:	1c1a      	adds	r2, r3, #0
 800110c:	320f      	adds	r2, #15

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800110e:	6858      	ldr	r0, [r3, #4]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8001110:	1c16      	adds	r6, r2, #0
 8001112:	465f      	mov	r7, fp
 8001114:	43be      	bics	r6, r7

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8001116:	1c44      	adds	r4, r0, #1

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8001118:	1c32      	adds	r2, r6, #0

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800111a:	00e4      	lsls	r4, r4, #3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800111c:	1c1d      	adds	r5, r3, #0
 800111e:	3a08      	subs	r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8001120:	191f      	adds	r7, r3, r4

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8001122:	3508      	adds	r5, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8001124:	42ba      	cmp	r2, r7
 8001126:	d207      	bcs.n	8001138 <chHeapAllocAligned.constprop.26.4154+0x68>
 8001128:	3c08      	subs	r4, #8
 800112a:	46a4      	mov	ip, r4
 800112c:	9f01      	ldr	r7, [sp, #4]
 800112e:	1a9c      	subs	r4, r3, r2
 8001130:	4464      	add	r4, ip
 8001132:	10e4      	asrs	r4, r4, #3
 8001134:	42a7      	cmp	r7, r4
 8001136:	d91d      	bls.n	8001174 <chHeapAllocAligned.constprop.26.4154+0xa4>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8001138:	1c19      	adds	r1, r3, #0
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800113a:	680b      	ldr	r3, [r1, #0]
 800113c:	2b00      	cmp	r3, #0
 800113e:	d1e4      	bne.n	800110a <chHeapAllocAligned.constprop.26.4154+0x3a>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001140:	4640      	mov	r0, r8
 8001142:	f7ff ff25 	bl	8000f90 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8001146:	4652      	mov	r2, sl
 8001148:	6813      	ldr	r3, [r2, #0]
 800114a:	2b00      	cmp	r3, #0
 800114c:	d045      	beq.n	80011da <chHeapAllocAligned.constprop.26.4154+0x10a>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 800114e:	9e01      	ldr	r6, [sp, #4]
 8001150:	2108      	movs	r1, #8
 8001152:	3601      	adds	r6, #1
 8001154:	00f0      	lsls	r0, r6, #3
 8001156:	4798      	blx	r3
    if (hp != NULL) {
 8001158:	2800      	cmp	r0, #0
 800115a:	d03e      	beq.n	80011da <chHeapAllocAligned.constprop.26.4154+0x10a>
      H_HEAP(hp) = heapp;
 800115c:	4653      	mov	r3, sl
      H_SIZE(hp) = size;
 800115e:	464d      	mov	r5, r9
  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
    if (hp != NULL) {
      H_HEAP(hp) = heapp;
 8001160:	6003      	str	r3, [r0, #0]
      H_SIZE(hp) = size;
 8001162:	6045      	str	r5, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8001164:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8001166:	b003      	add	sp, #12
 8001168:	bc3c      	pop	{r2, r3, r4, r5}
 800116a:	4690      	mov	r8, r2
 800116c:	4699      	mov	r9, r3
 800116e:	46a2      	mov	sl, r4
 8001170:	46ab      	mov	fp, r5
 8001172:	bdf0      	pop	{r4, r5, r6, r7, pc}

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8001174:	429a      	cmp	r2, r3
 8001176:	d817      	bhi.n	80011a8 <chHeapAllocAligned.constprop.26.4154+0xd8>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8001178:	9f01      	ldr	r7, [sp, #4]
 800117a:	4287      	cmp	r7, r0
 800117c:	d029      	beq.n	80011d2 <chHeapAllocAligned.constprop.26.4154+0x102>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 800117e:	9a01      	ldr	r2, [sp, #4]
          H_NEXT(fp) = H_NEXT(hp);
 8001180:	681f      	ldr	r7, [r3, #0]
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 8001182:	3201      	adds	r2, #1
 8001184:	00d2      	lsls	r2, r2, #3
 8001186:	189a      	adds	r2, r3, r2
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8001188:	1a98      	subs	r0, r3, r2
 800118a:	4460      	add	r0, ip
 800118c:	10c0      	asrs	r0, r0, #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 800118e:	6017      	str	r7, [r2, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8001190:	6050      	str	r0, [r2, #4]
          H_NEXT(qp) = fp;
 8001192:	600a      	str	r2, [r1, #0]
 8001194:	1c1a      	adds	r2, r3, #0
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8001196:	4648      	mov	r0, r9
      H_HEAP(hp) = heapp;
 8001198:	4651      	mov	r1, sl
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 800119a:	6050      	str	r0, [r2, #4]
      H_HEAP(hp) = heapp;
 800119c:	6011      	str	r1, [r2, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800119e:	4640      	mov	r0, r8
 80011a0:	f7ff fef6 	bl	8000f90 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 80011a4:	1c28      	adds	r0, r5, #0
 80011a6:	e7de      	b.n	8001166 <chHeapAllocAligned.constprop.26.4154+0x96>
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80011a8:	1b55      	subs	r5, r2, r5
 80011aa:	10ed      	asrs	r5, r5, #3
 80011ac:	605d      	str	r5, [r3, #4]
        if (bpages > pages) {
 80011ae:	42a7      	cmp	r7, r4
 80011b0:	d20a      	bcs.n	80011c8 <chHeapAllocAligned.constprop.26.4154+0xf8>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 80011b2:	9901      	ldr	r1, [sp, #4]
          H_PAGES(fp) = (bpages - pages) - 1U;
 80011b4:	9d01      	ldr	r5, [sp, #4]
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 80011b6:	3101      	adds	r1, #1
          H_PAGES(fp) = (bpages - pages) - 1U;

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 80011b8:	681f      	ldr	r7, [r3, #0]
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 80011ba:	00c9      	lsls	r1, r1, #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 80011bc:	43e8      	mvns	r0, r5
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 80011be:	1851      	adds	r1, r2, r1
          H_PAGES(fp) = (bpages - pages) - 1U;
 80011c0:	1904      	adds	r4, r0, r4
 80011c2:	604c      	str	r4, [r1, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 80011c4:	600f      	str	r7, [r1, #0]
          H_NEXT(hp) = fp;
 80011c6:	6019      	str	r1, [r3, #0]
 80011c8:	1c35      	adds	r5, r6, #0
 80011ca:	e7e4      	b.n	8001196 <chHeapAllocAligned.constprop.26.4154+0xc6>

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 80011cc:	4804      	ldr	r0, [pc, #16]	; (80011e0 <chHeapAllocAligned.constprop.26.4154+0x110>)
 80011ce:	4682      	mov	sl, r0
 80011d0:	e78a      	b.n	80010e8 <chHeapAllocAligned.constprop.26.4154+0x18>
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 80011d2:	6818      	ldr	r0, [r3, #0]
 80011d4:	1c1a      	adds	r2, r3, #0
 80011d6:	6008      	str	r0, [r1, #0]
 80011d8:	e7dd      	b.n	8001196 <chHeapAllocAligned.constprop.26.4154+0xc6>
      return (void *)H_BLOCK(hp);
      /*lint -restore*/
    }
  }

  return NULL;
 80011da:	2000      	movs	r0, #0
 80011dc:	e7c3      	b.n	8001166 <chHeapAllocAligned.constprop.26.4154+0x96>
 80011de:	46c0      	nop			; (mov r8, r8)
 80011e0:	20000e30 	.word	0x20000e30
 80011e4:	46c0      	nop			; (mov r8, r8)
 80011e6:	46c0      	nop			; (mov r8, r8)
 80011e8:	46c0      	nop			; (mov r8, r8)
 80011ea:	46c0      	nop			; (mov r8, r8)
 80011ec:	46c0      	nop			; (mov r8, r8)
 80011ee:	46c0      	nop			; (mov r8, r8)

080011f0 <chThdCreateFromHeap.constprop.25>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80011f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80011f2:	1c04      	adds	r4, r0, #0
 80011f4:	b087      	sub	sp, #28
 80011f6:	1c0f      	adds	r7, r1, #0
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 80011f8:	4810      	ldr	r0, [pc, #64]	; (800123c <chThdCreateFromHeap.constprop.25+0x4c>)
 80011fa:	1c21      	adds	r1, r4, #0
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80011fc:	1c16      	adds	r6, r2, #0
 80011fe:	1c1d      	adds	r5, r3, #0
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8001200:	f7ff ff66 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
  if (wsp == NULL) {
 8001204:	2800      	cmp	r0, #0
 8001206:	d016      	beq.n	8001236 <chThdCreateFromHeap.constprop.25+0x46>
    return NULL;
  }

  thread_descriptor_t td = {
 8001208:	4b0d      	ldr	r3, [pc, #52]	; (8001240 <chThdCreateFromHeap.constprop.25+0x50>)
 800120a:	9001      	str	r0, [sp, #4]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 800120c:	1900      	adds	r0, r0, r4
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 800120e:	9700      	str	r7, [sp, #0]
 8001210:	9002      	str	r0, [sp, #8]
 8001212:	9603      	str	r6, [sp, #12]
 8001214:	9304      	str	r3, [sp, #16]
 8001216:	9505      	str	r5, [sp, #20]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001218:	b672      	cpsid	i
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800121a:	4668      	mov	r0, sp
 800121c:	f7ff fc18 	bl	8000a50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8001220:	2201      	movs	r2, #1
 8001222:	2321      	movs	r3, #33	; 0x21
 8001224:	54c2      	strb	r2, [r0, r3]
  chSchWakeupS(tp, MSG_OK);
 8001226:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8001228:	1c04      	adds	r4, r0, #0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 800122a:	f7ff fce9 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800122e:	b662      	cpsie	i
 8001230:	1c20      	adds	r0, r4, #0
  chSysUnlock();

  return tp;
}
 8001232:	b007      	add	sp, #28
 8001234:	bdf0      	pop	{r4, r5, r6, r7, pc}
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
 8001236:	2000      	movs	r0, #0
 8001238:	e7fb      	b.n	8001232 <chThdCreateFromHeap.constprop.25+0x42>
 800123a:	46c0      	nop			; (mov r8, r8)
 800123c:	20000bb8 	.word	0x20000bb8
 8001240:	08000611 	.word	0x08000611
 8001244:	46c0      	nop			; (mov r8, r8)
 8001246:	46c0      	nop			; (mov r8, r8)
 8001248:	46c0      	nop			; (mov r8, r8)
 800124a:	46c0      	nop			; (mov r8, r8)
 800124c:	46c0      	nop			; (mov r8, r8)
 800124e:	46c0      	nop			; (mov r8, r8)

08001250 <thread1.9395>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8001250:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8001252:	4c06      	ldr	r4, [pc, #24]	; (800126c <thread1.9395+0x1c>)
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8001254:	1c05      	adds	r5, r0, #0

  chMtxLock(&m1);
 8001256:	1c20      	adds	r0, r4, #0
 8001258:	f7ff ff32 	bl	80010c0 <chMtxLock>
  test_emit_token(*(char *)p);
 800125c:	7828      	ldrb	r0, [r5, #0]
 800125e:	f7ff f9c7 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 8001262:	1c20      	adds	r0, r4, #0
 8001264:	f7ff fe94 	bl	8000f90 <chMtxUnlock>
}
 8001268:	bd38      	pop	{r3, r4, r5, pc}
 800126a:	46c0      	nop			; (mov r8, r8)
 800126c:	20000418 	.word	0x20000418

08001270 <thread9.9386>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8001270:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 8001272:	4c06      	ldr	r4, [pc, #24]	; (800128c <thread9.9386+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8001274:	1c05      	adds	r5, r0, #0

  chMtxLock(&m2);
 8001276:	1c20      	adds	r0, r4, #0
 8001278:	f7ff ff22 	bl	80010c0 <chMtxLock>
  test_emit_token(*(char *)p);
 800127c:	7828      	ldrb	r0, [r5, #0]
 800127e:	f7ff f9b7 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m2);
 8001282:	1c20      	adds	r0, r4, #0
 8001284:	f7ff fe84 	bl	8000f90 <chMtxUnlock>
}
 8001288:	bd38      	pop	{r3, r4, r5, pc}
 800128a:	46c0      	nop			; (mov r8, r8)
 800128c:	20000400 	.word	0x20000400

08001290 <chHeapStatus>:
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8001290:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001292:	4657      	mov	r7, sl
 8001294:	464e      	mov	r6, r9
 8001296:	4645      	mov	r5, r8
 8001298:	b4e0      	push	{r5, r6, r7}
 800129a:	1c04      	adds	r4, r0, #0
 800129c:	468a      	mov	sl, r1
 800129e:	4691      	mov	r9, r2
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
 80012a0:	d027      	beq.n	80012f2 <chHeapStatus+0x62>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 80012a2:	2310      	movs	r3, #16
 80012a4:	191b      	adds	r3, r3, r4
 80012a6:	1c18      	adds	r0, r3, #0
 80012a8:	4698      	mov	r8, r3
 80012aa:	f7ff ff09 	bl	80010c0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80012ae:	68a3      	ldr	r3, [r4, #8]
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
 80012b0:	2700      	movs	r7, #0
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
 80012b2:	2600      	movs	r6, #0
  lpages = 0U;
  n = 0U;
 80012b4:	2500      	movs	r5, #0
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80012b6:	2b00      	cmp	r3, #0
 80012b8:	d008      	beq.n	80012cc <chHeapStatus+0x3c>
    size_t pages = H_PAGES(H_NEXT(qp));
 80012ba:	685c      	ldr	r4, [r3, #4]

    /* Updating counters.*/
    n++;
 80012bc:	3501      	adds	r5, #1
    tpages += pages;
 80012be:	1936      	adds	r6, r6, r4
 80012c0:	42a7      	cmp	r7, r4
 80012c2:	d200      	bcs.n	80012c6 <chHeapStatus+0x36>
 80012c4:	1c27      	adds	r7, r4, #0
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80012c6:	681b      	ldr	r3, [r3, #0]
 80012c8:	2b00      	cmp	r3, #0
 80012ca:	d1f6      	bne.n	80012ba <chHeapStatus+0x2a>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80012cc:	4653      	mov	r3, sl
 80012ce:	2b00      	cmp	r3, #0
 80012d0:	d001      	beq.n	80012d6 <chHeapStatus+0x46>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 80012d2:	00f6      	lsls	r6, r6, #3
 80012d4:	601e      	str	r6, [r3, #0]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 80012d6:	464b      	mov	r3, r9
 80012d8:	2b00      	cmp	r3, #0
 80012da:	d001      	beq.n	80012e0 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80012dc:	00ff      	lsls	r7, r7, #3
 80012de:	601f      	str	r7, [r3, #0]
  }
  H_UNLOCK(heapp);
 80012e0:	4640      	mov	r0, r8
 80012e2:	f7ff fe55 	bl	8000f90 <chMtxUnlock>

  return n;
}
 80012e6:	1c28      	adds	r0, r5, #0
 80012e8:	bc1c      	pop	{r2, r3, r4}
 80012ea:	4690      	mov	r8, r2
 80012ec:	4699      	mov	r9, r3
 80012ee:	46a2      	mov	sl, r4
 80012f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 80012f2:	4c01      	ldr	r4, [pc, #4]	; (80012f8 <chHeapStatus+0x68>)
 80012f4:	e7d5      	b.n	80012a2 <chHeapStatus+0x12>
 80012f6:	46c0      	nop			; (mov r8, r8)
 80012f8:	20000e30 	.word	0x20000e30
 80012fc:	46c0      	nop			; (mov r8, r8)
 80012fe:	46c0      	nop			; (mov r8, r8)

08001300 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001300:	b570      	push	{r4, r5, r6, lr}
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8001302:	1c04      	adds	r4, r0, #0
 8001304:	3c08      	subs	r4, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001306:	6863      	ldr	r3, [r4, #4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001308:	6826      	ldr	r6, [r4, #0]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800130a:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800130c:	08db      	lsrs	r3, r3, #3

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800130e:	1c35      	adds	r5, r6, #0
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8001310:	3610      	adds	r6, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001312:	6063      	str	r3, [r4, #4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8001314:	3508      	adds	r5, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8001316:	1c30      	adds	r0, r6, #0
 8001318:	f7ff fed2 	bl	80010c0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800131c:	1c2b      	adds	r3, r5, #0
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 800131e:	42ab      	cmp	r3, r5
 8001320:	d004      	beq.n	800132c <chHeapFree+0x2c>
 8001322:	42a3      	cmp	r3, r4
 8001324:	d302      	bcc.n	800132c <chHeapFree+0x2c>
 8001326:	681b      	ldr	r3, [r3, #0]
 8001328:	42ab      	cmp	r3, r5
 800132a:	d1fa      	bne.n	8001322 <chHeapFree+0x22>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800132c:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 800132e:	2a00      	cmp	r2, #0
 8001330:	d003      	beq.n	800133a <chHeapFree+0x3a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001332:	4294      	cmp	r4, r2
 8001334:	d301      	bcc.n	800133a <chHeapFree+0x3a>
 8001336:	1c13      	adds	r3, r2, #0
 8001338:	e7f1      	b.n	800131e <chHeapFree+0x1e>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800133a:	6861      	ldr	r1, [r4, #4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 800133c:	6022      	str	r2, [r4, #0]
      H_NEXT(qp) = hp;
 800133e:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8001340:	1c4a      	adds	r2, r1, #1
 8001342:	00d2      	lsls	r2, r2, #3
 8001344:	6820      	ldr	r0, [r4, #0]
 8001346:	18a2      	adds	r2, r4, r2
 8001348:	4282      	cmp	r2, r0
 800134a:	d009      	beq.n	8001360 <chHeapFree+0x60>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 800134c:	685a      	ldr	r2, [r3, #4]
 800134e:	1c51      	adds	r1, r2, #1
 8001350:	00c9      	lsls	r1, r1, #3
 8001352:	1859      	adds	r1, r3, r1
 8001354:	428c      	cmp	r4, r1
 8001356:	d00f      	beq.n	8001378 <chHeapFree+0x78>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001358:	1c30      	adds	r0, r6, #0
 800135a:	f7ff fe19 	bl	8000f90 <chMtxUnlock>

  return;
}
 800135e:	bd70      	pop	{r4, r5, r6, pc}
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8001360:	6850      	ldr	r0, [r2, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8001362:	6812      	ldr	r2, [r2, #0]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8001364:	1809      	adds	r1, r1, r0
 8001366:	3101      	adds	r1, #1
 8001368:	6061      	str	r1, [r4, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800136a:	6022      	str	r2, [r4, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 800136c:	685a      	ldr	r2, [r3, #4]
 800136e:	1c51      	adds	r1, r2, #1
 8001370:	00c9      	lsls	r1, r1, #3
 8001372:	1859      	adds	r1, r3, r1
 8001374:	428c      	cmp	r4, r1
 8001376:	d1ef      	bne.n	8001358 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8001378:	6861      	ldr	r1, [r4, #4]
        H_NEXT(qp) = H_NEXT(hp);
 800137a:	6824      	ldr	r4, [r4, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800137c:	1852      	adds	r2, r2, r1
 800137e:	3201      	adds	r2, #1
 8001380:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8001382:	601c      	str	r4, [r3, #0]
 8001384:	e7e8      	b.n	8001358 <chHeapFree+0x58>
 8001386:	46c0      	nop			; (mov r8, r8)
 8001388:	46c0      	nop			; (mov r8, r8)
 800138a:	46c0      	nop			; (mov r8, r8)
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	46c0      	nop			; (mov r8, r8)

08001390 <test_010_001_execute.10300>:

static void test_010_001_execute(void) {
 8001390:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001392:	4656      	mov	r6, sl
 8001394:	464d      	mov	r5, r9
 8001396:	4644      	mov	r4, r8
 8001398:	465f      	mov	r7, fp
 800139a:	b4f0      	push	{r4, r5, r6, r7}

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800139c:	4cbe      	ldr	r4, [pc, #760]	; (8001698 <test_010_001_execute.10300+0x308>)

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_010_001_execute(void) {
 800139e:	b085      	sub	sp, #20
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 80013a0:	4dbe      	ldr	r5, [pc, #760]	; (800169c <test_010_001_execute.10300+0x30c>)
 80013a2:	2301      	movs	r3, #1
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80013a4:	a901      	add	r1, sp, #4
 80013a6:	1c20      	adds	r0, r4, #0
 80013a8:	2200      	movs	r2, #0
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 80013aa:	602b      	str	r3, [r5, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80013ac:	f7ff ff70 	bl	8001290 <chHeapStatus>
 80013b0:	4ebb      	ldr	r6, [pc, #748]	; (80016a0 <test_010_001_execute.10300+0x310>)
 80013b2:	3801      	subs	r0, #1
 80013b4:	4243      	negs	r3, r0
 80013b6:	4158      	adcs	r0, r3
 80013b8:	b2c0      	uxtb	r0, r0
 80013ba:	1c31      	adds	r1, r6, #0
 80013bc:	f7ff fa78 	bl	80008b0 <_test_assert>
 80013c0:	2800      	cmp	r0, #0
 80013c2:	d006      	beq.n	80013d2 <test_010_001_execute.10300+0x42>
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
    test_assert(n == sz, "size changed");
  }
}
 80013c4:	b005      	add	sp, #20
 80013c6:	bc3c      	pop	{r2, r3, r4, r5}
 80013c8:	4690      	mov	r8, r2
 80013ca:	4699      	mov	r9, r3
 80013cc:	46a2      	mov	sl, r4
 80013ce:	46ab      	mov	fp, r5
 80013d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80013d2:	21cd      	movs	r1, #205	; 0xcd
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  }

  /* [10.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 80013d4:	2302      	movs	r3, #2
 80013d6:	0109      	lsls	r1, r1, #4
 80013d8:	1c20      	adds	r0, r4, #0
 80013da:	602b      	str	r3, [r5, #0]
 80013dc:	f7ff fe78 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
    test_assert(p1 == NULL, "allocation not failed");
 80013e0:	4243      	negs	r3, r0
 80013e2:	4158      	adcs	r0, r3
 80013e4:	b2c0      	uxtb	r0, r0
 80013e6:	49af      	ldr	r1, [pc, #700]	; (80016a4 <test_010_001_execute.10300+0x314>)
 80013e8:	f7ff fa62 	bl	80008b0 <_test_assert>
 80013ec:	2800      	cmp	r0, #0
 80013ee:	d1e9      	bne.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.3] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 80013f0:	2303      	movs	r3, #3
 80013f2:	2110      	movs	r1, #16
 80013f4:	1c20      	adds	r0, r4, #0
 80013f6:	602b      	str	r3, [r5, #0]
 80013f8:	f7ff fe6a 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 80013fc:	4aaa      	ldr	r2, [pc, #680]	; (80016a8 <test_010_001_execute.10300+0x318>)
 80013fe:	1c07      	adds	r7, r0, #0
 8001400:	1e43      	subs	r3, r0, #1
 8001402:	4198      	sbcs	r0, r3
 8001404:	b2c0      	uxtb	r0, r0
 8001406:	1c11      	adds	r1, r2, #0
 8001408:	4690      	mov	r8, r2
 800140a:	f7ff fa51 	bl	80008b0 <_test_assert>
 800140e:	2800      	cmp	r0, #0
 8001410:	d1d8      	bne.n	80013c4 <test_010_001_execute.10300+0x34>
    chHeapFree(p1);
 8001412:	1c38      	adds	r0, r7, #0
 8001414:	f7ff ff74 	bl	8001300 <chHeapFree>
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8001418:	2304      	movs	r3, #4
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800141a:	a902      	add	r1, sp, #8
 800141c:	1c20      	adds	r0, r4, #0
 800141e:	aa03      	add	r2, sp, #12
    chHeapFree(p1);
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8001420:	602b      	str	r3, [r5, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8001422:	f7ff ff35 	bl	8001290 <chHeapStatus>
 8001426:	9000      	str	r0, [sp, #0]
    test_assert(n == 1, "missing free block");
 8001428:	3801      	subs	r0, #1
 800142a:	4243      	negs	r3, r0
 800142c:	4158      	adcs	r0, r3
 800142e:	b2c0      	uxtb	r0, r0
 8001430:	499e      	ldr	r1, [pc, #632]	; (80016ac <test_010_001_execute.10300+0x31c>)
 8001432:	f7ff fa3d 	bl	80008b0 <_test_assert>
 8001436:	2800      	cmp	r0, #0
 8001438:	d1c4      	bne.n	80013c4 <test_010_001_execute.10300+0x34>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 800143a:	9b02      	ldr	r3, [sp, #8]
 800143c:	200f      	movs	r0, #15
 800143e:	4f9c      	ldr	r7, [pc, #624]	; (80016b0 <test_010_001_execute.10300+0x320>)
 8001440:	4298      	cmp	r0, r3
 8001442:	4180      	sbcs	r0, r0
 8001444:	4240      	negs	r0, r0
 8001446:	1c39      	adds	r1, r7, #0
 8001448:	f7ff fa32 	bl	80008b0 <_test_assert>
 800144c:	2800      	cmp	r0, #0
 800144e:	d1b9      	bne.n	80013c4 <test_010_001_execute.10300+0x34>
    test_assert(total_size == largest_size, "unexpected heap state");
 8001450:	9b03      	ldr	r3, [sp, #12]
 8001452:	9a02      	ldr	r2, [sp, #8]
 8001454:	1c39      	adds	r1, r7, #0
 8001456:	1ad0      	subs	r0, r2, r3
 8001458:	4243      	negs	r3, r0
 800145a:	4158      	adcs	r0, r3
 800145c:	b2c0      	uxtb	r0, r0
 800145e:	f7ff fa27 	bl	80008b0 <_test_assert>
 8001462:	2800      	cmp	r0, #0
 8001464:	d1ae      	bne.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 8001466:	2305      	movs	r3, #5
 8001468:	2110      	movs	r1, #16
 800146a:	1c20      	adds	r0, r4, #0
 800146c:	602b      	str	r3, [r5, #0]
 800146e:	f7ff fe2f 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 8001472:	2110      	movs	r1, #16
 8001474:	4682      	mov	sl, r0
 8001476:	1c20      	adds	r0, r4, #0
 8001478:	f7ff fe2a 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 800147c:	2110      	movs	r1, #16
 800147e:	4681      	mov	r9, r0
 8001480:	1c20      	adds	r0, r4, #0
 8001482:	f7ff fe25 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 8001486:	1c07      	adds	r7, r0, #0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);                                 /* Does not merge.*/
 8001488:	4650      	mov	r0, sl
 800148a:	f7ff ff39 	bl	8001300 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 800148e:	4648      	mov	r0, r9
 8001490:	f7ff ff36 	bl	8001300 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 8001494:	1c38      	adds	r0, r7, #0
 8001496:	f7ff ff33 	bl	8001300 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800149a:	4669      	mov	r1, sp
 800149c:	2200      	movs	r2, #0
 800149e:	1c20      	adds	r0, r4, #0
 80014a0:	f7ff fef6 	bl	8001290 <chHeapStatus>
 80014a4:	3801      	subs	r0, #1
 80014a6:	4243      	negs	r3, r0
 80014a8:	4158      	adcs	r0, r3
 80014aa:	b2c0      	uxtb	r0, r0
 80014ac:	1c31      	adds	r1, r6, #0
 80014ae:	f7ff f9ff 	bl	80008b0 <_test_assert>
 80014b2:	1e07      	subs	r7, r0, #0
 80014b4:	d000      	beq.n	80014b8 <test_010_001_execute.10300+0x128>
 80014b6:	e785      	b.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 80014b8:	2306      	movs	r3, #6
 80014ba:	2110      	movs	r1, #16
 80014bc:	1c20      	adds	r0, r4, #0
 80014be:	602b      	str	r3, [r5, #0]
 80014c0:	f7ff fe06 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 80014c4:	2110      	movs	r1, #16
 80014c6:	4681      	mov	r9, r0
 80014c8:	1c20      	adds	r0, r4, #0
 80014ca:	f7ff fe01 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 80014ce:	2110      	movs	r1, #16
 80014d0:	4682      	mov	sl, r0
 80014d2:	1c20      	adds	r0, r4, #0
 80014d4:	f7ff fdfc 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p3);                                 /* Merges forward.*/
 80014d8:	f7ff ff12 	bl	8001300 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 80014dc:	4650      	mov	r0, sl
 80014de:	f7ff ff0f 	bl	8001300 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 80014e2:	4648      	mov	r0, r9
 80014e4:	f7ff ff0c 	bl	8001300 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80014e8:	1c3a      	adds	r2, r7, #0
 80014ea:	4669      	mov	r1, sp
 80014ec:	1c20      	adds	r0, r4, #0
 80014ee:	f7ff fecf 	bl	8001290 <chHeapStatus>
 80014f2:	3801      	subs	r0, #1
 80014f4:	4243      	negs	r3, r0
 80014f6:	4158      	adcs	r0, r3
 80014f8:	b2c0      	uxtb	r0, r0
 80014fa:	1c31      	adds	r1, r6, #0
 80014fc:	f7ff f9d8 	bl	80008b0 <_test_assert>
 8001500:	1e07      	subs	r7, r0, #0
 8001502:	d000      	beq.n	8001506 <test_010_001_execute.10300+0x176>
 8001504:	e75e      	b.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 8001506:	2307      	movs	r3, #7
 8001508:	2111      	movs	r1, #17
 800150a:	1c20      	adds	r0, r4, #0
 800150c:	602b      	str	r3, [r5, #0]
 800150e:	f7ff fddf 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 8001512:	2110      	movs	r1, #16
 8001514:	4681      	mov	r9, r0
 8001516:	1c20      	adds	r0, r4, #0
 8001518:	f7ff fdda 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 800151c:	4683      	mov	fp, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 800151e:	4648      	mov	r0, r9
 8001520:	f7ff feee 	bl	8001300 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8001524:	1c3a      	adds	r2, r7, #0
 8001526:	4669      	mov	r1, sp
 8001528:	1c20      	adds	r0, r4, #0
 800152a:	f7ff feb1 	bl	8001290 <chHeapStatus>
 800152e:	4f61      	ldr	r7, [pc, #388]	; (80016b4 <test_010_001_execute.10300+0x324>)
 8001530:	3802      	subs	r0, #2
 8001532:	4243      	negs	r3, r0
 8001534:	4158      	adcs	r0, r3
 8001536:	b2c0      	uxtb	r0, r0
 8001538:	1c39      	adds	r1, r7, #0
 800153a:	f7ff f9b9 	bl	80008b0 <_test_assert>
 800153e:	4681      	mov	r9, r0
 8001540:	2800      	cmp	r0, #0
 8001542:	d000      	beq.n	8001546 <test_010_001_execute.10300+0x1b6>
 8001544:	e73e      	b.n	80013c4 <test_010_001_execute.10300+0x34>
 8001546:	2110      	movs	r1, #16
 8001548:	1c20      	adds	r0, r4, #0
 800154a:	f7ff fdc1 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 800154e:	4669      	mov	r1, sp
 8001550:	4682      	mov	sl, r0
 8001552:	464a      	mov	r2, r9
 8001554:	1c20      	adds	r0, r4, #0
 8001556:	f7ff fe9b 	bl	8001290 <chHeapStatus>
 800155a:	2301      	movs	r3, #1
 800155c:	4298      	cmp	r0, r3
 800155e:	d007      	beq.n	8001570 <test_010_001_execute.10300+0x1e0>
 8001560:	2200      	movs	r2, #0
 8001562:	1c20      	adds	r0, r4, #0
 8001564:	4669      	mov	r1, sp
 8001566:	f7ff fe93 	bl	8001290 <chHeapStatus>
 800156a:	1e83      	subs	r3, r0, #2
 800156c:	425a      	negs	r2, r3
 800156e:	4153      	adcs	r3, r2
 8001570:	1c18      	adds	r0, r3, #0
 8001572:	1c31      	adds	r1, r6, #0
 8001574:	f7ff f99c 	bl	80008b0 <_test_assert>
 8001578:	4681      	mov	r9, r0
 800157a:	2800      	cmp	r0, #0
 800157c:	d000      	beq.n	8001580 <test_010_001_execute.10300+0x1f0>
 800157e:	e721      	b.n	80013c4 <test_010_001_execute.10300+0x34>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 8001580:	4658      	mov	r0, fp
 8001582:	f7ff febd 	bl	8001300 <chHeapFree>
    chHeapFree(p1);
 8001586:	4650      	mov	r0, sl
 8001588:	f7ff feba 	bl	8001300 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800158c:	464a      	mov	r2, r9
 800158e:	4669      	mov	r1, sp
 8001590:	1c20      	adds	r0, r4, #0
 8001592:	f7ff fe7d 	bl	8001290 <chHeapStatus>
 8001596:	3801      	subs	r0, #1
 8001598:	4243      	negs	r3, r0
 800159a:	4158      	adcs	r0, r3
 800159c:	b2c0      	uxtb	r0, r0
 800159e:	1c31      	adds	r1, r6, #0
 80015a0:	f7ff f986 	bl	80008b0 <_test_assert>
 80015a4:	4681      	mov	r9, r0
 80015a6:	2800      	cmp	r0, #0
 80015a8:	d000      	beq.n	80015ac <test_010_001_execute.10300+0x21c>
 80015aa:	e70b      	b.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 80015ac:	2308      	movs	r3, #8
 80015ae:	2110      	movs	r1, #16
 80015b0:	1c20      	adds	r0, r4, #0
 80015b2:	602b      	str	r3, [r5, #0]
 80015b4:	f7ff fd8c 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 80015b8:	2110      	movs	r1, #16
 80015ba:	4683      	mov	fp, r0
 80015bc:	1c20      	adds	r0, r4, #0
 80015be:	f7ff fd87 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 80015c2:	4682      	mov	sl, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 80015c4:	4658      	mov	r0, fp
 80015c6:	f7ff fe9b 	bl	8001300 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 80015ca:	4669      	mov	r1, sp
 80015cc:	464a      	mov	r2, r9
 80015ce:	1c20      	adds	r0, r4, #0
 80015d0:	f7ff fe5e 	bl	8001290 <chHeapStatus>
 80015d4:	3802      	subs	r0, #2
 80015d6:	4243      	negs	r3, r0
 80015d8:	4158      	adcs	r0, r3
 80015da:	1c39      	adds	r1, r7, #0
 80015dc:	b2c0      	uxtb	r0, r0
 80015de:	f7ff f967 	bl	80008b0 <_test_assert>
 80015e2:	1e07      	subs	r7, r0, #0
 80015e4:	d000      	beq.n	80015e8 <test_010_001_execute.10300+0x258>
 80015e6:	e6ed      	b.n	80013c4 <test_010_001_execute.10300+0x34>
 80015e8:	2120      	movs	r1, #32
 80015ea:	1c20      	adds	r0, r4, #0
 80015ec:	f7ff fd70 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
    chHeapFree(p1);
 80015f0:	f7ff fe86 	bl	8001300 <chHeapFree>
    chHeapFree(p2);
 80015f4:	4650      	mov	r0, sl
 80015f6:	f7ff fe83 	bl	8001300 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80015fa:	1c3a      	adds	r2, r7, #0
 80015fc:	4669      	mov	r1, sp
 80015fe:	1c20      	adds	r0, r4, #0
 8001600:	f7ff fe46 	bl	8001290 <chHeapStatus>
 8001604:	3801      	subs	r0, #1
 8001606:	4243      	negs	r3, r0
 8001608:	4158      	adcs	r0, r3
 800160a:	b2c0      	uxtb	r0, r0
 800160c:	1c31      	adds	r1, r6, #0
 800160e:	f7ff f94f 	bl	80008b0 <_test_assert>
 8001612:	1e02      	subs	r2, r0, #0
 8001614:	d000      	beq.n	8001618 <test_010_001_execute.10300+0x288>
 8001616:	e6d5      	b.n	80013c4 <test_010_001_execute.10300+0x34>
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 8001618:	2309      	movs	r3, #9
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 800161a:	4669      	mov	r1, sp
 800161c:	1c20      	adds	r0, r4, #0
    chHeapFree(p2);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 800161e:	602b      	str	r3, [r5, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8001620:	f7ff fe36 	bl	8001290 <chHeapStatus>
 8001624:	9900      	ldr	r1, [sp, #0]
 8001626:	1c20      	adds	r0, r4, #0
 8001628:	f7ff fd52 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 800162c:	4681      	mov	r9, r0
    p1 = chHeapAlloc(&test_heap, n);
    test_assert(p1 != NULL, "allocation failed");
 800162e:	1e43      	subs	r3, r0, #1
 8001630:	4198      	sbcs	r0, r3
 8001632:	b2c0      	uxtb	r0, r0
 8001634:	4641      	mov	r1, r8
 8001636:	f7ff f93b 	bl	80008b0 <_test_assert>
 800163a:	1e02      	subs	r2, r0, #0
 800163c:	d000      	beq.n	8001640 <test_010_001_execute.10300+0x2b0>
 800163e:	e6c1      	b.n	80013c4 <test_010_001_execute.10300+0x34>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8001640:	1c11      	adds	r1, r2, #0
 8001642:	1c20      	adds	r0, r4, #0
 8001644:	f7ff fe24 	bl	8001290 <chHeapStatus>
 8001648:	4243      	negs	r3, r0
 800164a:	4158      	adcs	r0, r3
 800164c:	b2c0      	uxtb	r0, r0
 800164e:	491a      	ldr	r1, [pc, #104]	; (80016b8 <test_010_001_execute.10300+0x328>)
 8001650:	f7ff f92e 	bl	80008b0 <_test_assert>
 8001654:	1e07      	subs	r7, r0, #0
 8001656:	d000      	beq.n	800165a <test_010_001_execute.10300+0x2ca>
 8001658:	e6b4      	b.n	80013c4 <test_010_001_execute.10300+0x34>
    chHeapFree(p1);
 800165a:	4648      	mov	r0, r9
 800165c:	f7ff fe50 	bl	8001300 <chHeapFree>
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8001660:	230a      	movs	r3, #10
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8001662:	4669      	mov	r1, sp
 8001664:	1c20      	adds	r0, r4, #0
 8001666:	1c3a      	adds	r2, r7, #0
    chHeapFree(p1);
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8001668:	602b      	str	r3, [r5, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800166a:	f7ff fe11 	bl	8001290 <chHeapStatus>
 800166e:	3801      	subs	r0, #1
 8001670:	4243      	negs	r3, r0
 8001672:	4158      	adcs	r0, r3
 8001674:	b2c0      	uxtb	r0, r0
 8001676:	1c31      	adds	r1, r6, #0
 8001678:	f7ff f91a 	bl	80008b0 <_test_assert>
 800167c:	2800      	cmp	r0, #0
 800167e:	d000      	beq.n	8001682 <test_010_001_execute.10300+0x2f2>
 8001680:	e6a0      	b.n	80013c4 <test_010_001_execute.10300+0x34>
    test_assert(n == sz, "size changed");
 8001682:	9b01      	ldr	r3, [sp, #4]
 8001684:	9a00      	ldr	r2, [sp, #0]
 8001686:	490d      	ldr	r1, [pc, #52]	; (80016bc <test_010_001_execute.10300+0x32c>)
 8001688:	1ad0      	subs	r0, r2, r3
 800168a:	4243      	negs	r3, r0
 800168c:	4158      	adcs	r0, r3
 800168e:	b2c0      	uxtb	r0, r0
 8001690:	f7ff f90e 	bl	80008b0 <_test_assert>
 8001694:	e696      	b.n	80013c4 <test_010_001_execute.10300+0x34>
 8001696:	46c0      	nop			; (mov r8, r8)
 8001698:	200004b0 	.word	0x200004b0
 800169c:	20000f44 	.word	0x20000f44
 80016a0:	08005cc0 	.word	0x08005cc0
 80016a4:	08005cd0 	.word	0x08005cd0
 80016a8:	08005ce8 	.word	0x08005ce8
 80016ac:	08005cfc 	.word	0x08005cfc
 80016b0:	08005d10 	.word	0x08005d10
 80016b4:	08005d28 	.word	0x08005d28
 80016b8:	08005d38 	.word	0x08005d38
 80016bc:	08005d44 	.word	0x08005d44

080016c0 <test_010_002_execute.10298>:
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 80016c0:	b530      	push	{r4, r5, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 80016c2:	4c14      	ldr	r4, [pc, #80]	; (8001714 <test_010_002_execute.10298+0x54>)
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 80016c4:	b083      	sub	sp, #12
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 80016c6:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 80016c8:	4669      	mov	r1, sp
 80016ca:	aa01      	add	r2, sp, #4
 80016cc:	2000      	movs	r0, #0
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 80016ce:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 80016d0:	f7ff fdde 	bl	8001290 <chHeapStatus>
 80016d4:	2110      	movs	r1, #16
 80016d6:	4810      	ldr	r0, [pc, #64]	; (8001718 <test_010_002_execute.10298+0x58>)
 80016d8:	f7ff fcfa 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
 80016dc:	1c05      	adds	r5, r0, #0
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 80016de:	1e43      	subs	r3, r0, #1
 80016e0:	4198      	sbcs	r0, r3
 80016e2:	b2c0      	uxtb	r0, r0
 80016e4:	490d      	ldr	r1, [pc, #52]	; (800171c <test_010_002_execute.10298+0x5c>)
 80016e6:	f7ff f8e3 	bl	80008b0 <_test_assert>
 80016ea:	2800      	cmp	r0, #0
 80016ec:	d001      	beq.n	80016f2 <test_010_002_execute.10298+0x32>
  test_set_step(2);
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  }
}
 80016ee:	b003      	add	sp, #12
 80016f0:	bd30      	pop	{r4, r5, pc}
  test_set_step(1);
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
    chHeapFree(p1);
 80016f2:	1c28      	adds	r0, r5, #0
 80016f4:	f7ff fe04 	bl	8001300 <chHeapFree>
  }

  /* [10.2.2] Testing allocation failure.*/
  test_set_step(2);
 80016f8:	2302      	movs	r3, #2
 80016fa:	4909      	ldr	r1, [pc, #36]	; (8001720 <test_010_002_execute.10298+0x60>)
 80016fc:	2000      	movs	r0, #0
 80016fe:	6023      	str	r3, [r4, #0]
 8001700:	f7ff fce6 	bl	80010d0 <chHeapAllocAligned.constprop.26.4154>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 8001704:	4243      	negs	r3, r0
 8001706:	4158      	adcs	r0, r3
 8001708:	4906      	ldr	r1, [pc, #24]	; (8001724 <test_010_002_execute.10298+0x64>)
 800170a:	b2c0      	uxtb	r0, r0
 800170c:	f7ff f8d0 	bl	80008b0 <_test_assert>
 8001710:	e7ed      	b.n	80016ee <test_010_002_execute.10298+0x2e>
 8001712:	46c0      	nop			; (mov r8, r8)
 8001714:	20000f44 	.word	0x20000f44
 8001718:	200004b0 	.word	0x200004b0
 800171c:	08005ce8 	.word	0x08005ce8
 8001720:	ffffff00 	.word	0xffffff00
 8001724:	08005cd0 	.word	0x08005cd0
 8001728:	46c0      	nop			; (mov r8, r8)
 800172a:	46c0      	nop			; (mov r8, r8)
 800172c:	46c0      	nop			; (mov r8, r8)
 800172e:	46c0      	nop			; (mov r8, r8)

08001730 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001730:	b508      	push	{r3, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001732:	6883      	ldr	r3, [r0, #8]
 8001734:	3301      	adds	r3, #1
 8001736:	6083      	str	r3, [r0, #8]
 8001738:	2b00      	cmp	r3, #0
 800173a:	dd00      	ble.n	800173e <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 800173c:	bd08      	pop	{r3, pc}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800173e:	6803      	ldr	r3, [r0, #0]

  tqp->next             = tp->queue.next;
 8001740:	681a      	ldr	r2, [r3, #0]
 8001742:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001744:	6050      	str	r0, [r2, #4]

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8001746:	2200      	movs	r2, #0
 8001748:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800174a:	1c18      	adds	r0, r3, #0
 800174c:	f7ff fb70 	bl	8000e30 <chSchReadyI>
 8001750:	e7f4      	b.n	800173c <chSemSignalI+0xc>
 8001752:	46c0      	nop			; (mov r8, r8)
 8001754:	46c0      	nop			; (mov r8, r8)
 8001756:	46c0      	nop			; (mov r8, r8)
 8001758:	46c0      	nop			; (mov r8, r8)
 800175a:	46c0      	nop			; (mov r8, r8)
 800175c:	46c0      	nop			; (mov r8, r8)
 800175e:	46c0      	nop			; (mov r8, r8)

08001760 <chSemResetI.4427>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001760:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8001762:	6885      	ldr	r5, [r0, #8]
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001764:	1c04      	adds	r4, r0, #0
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001766:	3501      	adds	r5, #1
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
 8001768:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 800176a:	2d00      	cmp	r5, #0
 800176c:	dc0b      	bgt.n	8001786 <chSemResetI.4427+0x26>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800176e:	2602      	movs	r6, #2
 8001770:	4276      	negs	r6, r6

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 8001772:	6860      	ldr	r0, [r4, #4]
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001774:	3501      	adds	r5, #1

  tqp->prev             = tp->queue.prev;
 8001776:	6843      	ldr	r3, [r0, #4]
 8001778:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 800177a:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800177c:	f7ff fb58 	bl	8000e30 <chSchReadyI>
 8001780:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001782:	2d01      	cmp	r5, #1
 8001784:	d1f5      	bne.n	8001772 <chSemResetI.4427+0x12>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
  }
}
 8001786:	bd70      	pop	{r4, r5, r6, pc}
 8001788:	46c0      	nop			; (mov r8, r8)
 800178a:	46c0      	nop			; (mov r8, r8)
 800178c:	46c0      	nop			; (mov r8, r8)
 800178e:	46c0      	nop			; (mov r8, r8)

08001790 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8001790:	b510      	push	{r4, lr}
 8001792:	1c04      	adds	r4, r0, #0

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8001794:	6801      	ldr	r1, [r0, #0]
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8001796:	6863      	ldr	r3, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8001798:	6081      	str	r1, [r0, #8]
  mbp->rdptr = mbp->buffer;
 800179a:	60c1      	str	r1, [r0, #12]
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 800179c:	1a59      	subs	r1, r3, r1
 800179e:	301c      	adds	r0, #28
 80017a0:	1089      	asrs	r1, r1, #2
 80017a2:	f7ff ffdd 	bl	8001760 <chSemResetI.4427>
  chSemResetI(&mbp->fullsem, (cnt_t)0);
 80017a6:	1c20      	adds	r0, r4, #0
 80017a8:	3010      	adds	r0, #16
 80017aa:	2100      	movs	r1, #0
 80017ac:	f7ff ffd8 	bl	8001760 <chSemResetI.4427>
}
 80017b0:	bd10      	pop	{r4, pc}
 80017b2:	46c0      	nop			; (mov r8, r8)
 80017b4:	46c0      	nop			; (mov r8, r8)
 80017b6:	46c0      	nop			; (mov r8, r8)
 80017b8:	46c0      	nop			; (mov r8, r8)
 80017ba:	46c0      	nop			; (mov r8, r8)
 80017bc:	46c0      	nop			; (mov r8, r8)
 80017be:	46c0      	nop			; (mov r8, r8)

080017c0 <chMBReset.constprop.22>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 80017c0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80017c2:	b672      	cpsid	i

  chSysLock();
  chMBResetI(mbp);
 80017c4:	4803      	ldr	r0, [pc, #12]	; (80017d4 <chMBReset.constprop.22+0x14>)
 80017c6:	f7ff ffe3 	bl	8001790 <chMBResetI>
  chSchRescheduleS();
 80017ca:	f7ff f979 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80017ce:	b662      	cpsie	i
  chSysUnlock();
}
 80017d0:	bd08      	pop	{r3, pc}
 80017d2:	46c0      	nop			; (mov r8, r8)
 80017d4:	2000042c 	.word	0x2000042c
 80017d8:	46c0      	nop			; (mov r8, r8)
 80017da:	46c0      	nop			; (mov r8, r8)
 80017dc:	46c0      	nop			; (mov r8, r8)
 80017de:	46c0      	nop			; (mov r8, r8)

080017e0 <test_008_001_teardown.10007>:

static void test_008_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_001_teardown(void) {
 80017e0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 80017e2:	f7ff ffed 	bl	80017c0 <chMBReset.constprop.22>
}
 80017e6:	bd08      	pop	{r3, pc}
 80017e8:	46c0      	nop			; (mov r8, r8)
 80017ea:	46c0      	nop			; (mov r8, r8)
 80017ec:	46c0      	nop			; (mov r8, r8)
 80017ee:	46c0      	nop			; (mov r8, r8)

080017f0 <test_008_002_teardown.10005>:

static void test_008_002_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_002_teardown(void) {
 80017f0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 80017f2:	f7ff ffe5 	bl	80017c0 <chMBReset.constprop.22>
}
 80017f6:	bd08      	pop	{r3, pc}
 80017f8:	46c0      	nop			; (mov r8, r8)
 80017fa:	46c0      	nop			; (mov r8, r8)
 80017fc:	46c0      	nop			; (mov r8, r8)
 80017fe:	46c0      	nop			; (mov r8, r8)

08001800 <test_008_003_teardown.10003>:

static void test_008_003_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_003_teardown(void) {
 8001800:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 8001802:	f7ff ffdd 	bl	80017c0 <chMBReset.constprop.22>
}
 8001806:	bd08      	pop	{r3, pc}
 8001808:	46c0      	nop			; (mov r8, r8)
 800180a:	46c0      	nop			; (mov r8, r8)
 800180c:	46c0      	nop			; (mov r8, r8)
 800180e:	46c0      	nop			; (mov r8, r8)

08001810 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001810:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001812:	b672      	cpsid	i

  chSysLock();
  chSemResetI(sp, n);
 8001814:	f7ff ffa4 	bl	8001760 <chSemResetI.4427>
  chSchRescheduleS();
 8001818:	f7ff f952 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800181c:	b662      	cpsie	i
  chSysUnlock();
}
 800181e:	bd08      	pop	{r3, pc}

08001820 <test_004_001_execute.9186>:

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
}

static void test_004_001_execute(void) {
 8001820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     counter and the returned message are tested.*/
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8001822:	4c1f      	ldr	r4, [pc, #124]	; (80018a0 <test_004_001_execute.9186+0x80>)

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8001824:	4e1f      	ldr	r6, [pc, #124]	; (80018a4 <test_004_001_execute.9186+0x84>)
 8001826:	2301      	movs	r3, #1
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8001828:	1c20      	adds	r0, r4, #0

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 800182a:	6033      	str	r3, [r6, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 800182c:	f7ff faa8 	bl	8000d80 <chSemWait>
 8001830:	1c07      	adds	r7, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001832:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8001834:	68a1      	ldr	r1, [r4, #8]
 8001836:	4d1c      	ldr	r5, [pc, #112]	; (80018a8 <test_004_001_execute.9186+0x88>)
 8001838:	424b      	negs	r3, r1
 800183a:	414b      	adcs	r3, r1
 800183c:	b2d8      	uxtb	r0, r3
 800183e:	1c29      	adds	r1, r5, #0
 8001840:	f7ff f836 	bl	80008b0 <_test_assert>
 8001844:	2800      	cmp	r0, #0
 8001846:	d001      	beq.n	800184c <test_004_001_execute.9186+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001848:	b662      	cpsie	i
  test_set_step(3);
  {
    chSemReset(&sem1, 2);
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
  }
}
 800184a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800184c:	b662      	cpsie	i
  {
    msg_t msg;

    msg = chSemWait(&sem1);
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
    test_assert(MSG_OK == msg, "wrong returned message");
 800184e:	4278      	negs	r0, r7
 8001850:	4178      	adcs	r0, r7
 8001852:	b2c0      	uxtb	r0, r0
 8001854:	4915      	ldr	r1, [pc, #84]	; (80018ac <test_004_001_execute.9186+0x8c>)
 8001856:	f7ff f82b 	bl	80008b0 <_test_assert>
 800185a:	2800      	cmp	r0, #0
 800185c:	d1f5      	bne.n	800184a <test_004_001_execute.9186+0x2a>
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 800185e:	2302      	movs	r3, #2
  {
    chSemSignal(&sem1);
 8001860:	1c20      	adds	r0, r4, #0
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8001862:	6033      	str	r3, [r6, #0]
  {
    chSemSignal(&sem1);
 8001864:	f7ff fa2c 	bl	8000cc0 <chSemSignal>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001868:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 800186a:	68a0      	ldr	r0, [r4, #8]
 800186c:	1c29      	adds	r1, r5, #0
 800186e:	3801      	subs	r0, #1
 8001870:	4243      	negs	r3, r0
 8001872:	4158      	adcs	r0, r3
 8001874:	b2c0      	uxtb	r0, r0
 8001876:	f7ff f81b 	bl	80008b0 <_test_assert>
 800187a:	2800      	cmp	r0, #0
 800187c:	d1e4      	bne.n	8001848 <test_004_001_execute.9186+0x28>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800187e:	b662      	cpsie	i
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8001880:	2303      	movs	r3, #3
  {
    chSemReset(&sem1, 2);
 8001882:	1c20      	adds	r0, r4, #0
 8001884:	2102      	movs	r1, #2
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8001886:	6033      	str	r3, [r6, #0]
  {
    chSemReset(&sem1, 2);
 8001888:	f7ff ffc2 	bl	8001810 <chSemReset>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800188c:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 800188e:	68a0      	ldr	r0, [r4, #8]
 8001890:	1c29      	adds	r1, r5, #0
 8001892:	3802      	subs	r0, #2
 8001894:	4243      	negs	r3, r0
 8001896:	4158      	adcs	r0, r3
 8001898:	b2c0      	uxtb	r0, r0
 800189a:	f7ff f809 	bl	80008b0 <_test_assert>
 800189e:	e7d3      	b.n	8001848 <test_004_001_execute.9186+0x28>
 80018a0:	20000508 	.word	0x20000508
 80018a4:	20000f44 	.word	0x20000f44
 80018a8:	08005d54 	.word	0x08005d54
 80018ac:	08005d68 	.word	0x08005d68

080018b0 <test_004_001_teardown.9164>:

static void test_004_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_004_001_teardown(void) {
 80018b0:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
 80018b2:	4802      	ldr	r0, [pc, #8]	; (80018bc <test_004_001_teardown.9164+0xc>)
 80018b4:	2100      	movs	r1, #0
 80018b6:	f7ff ffab 	bl	8001810 <chSemReset>
}
 80018ba:	bd08      	pop	{r3, pc}
 80018bc:	20000508 	.word	0x20000508

080018c0 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80018c0:	f3ef 8010 	mrs	r0, PRIMASK
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 80018c4:	07c3      	lsls	r3, r0, #31
 80018c6:	d402      	bmi.n	80018ce <chSysGetStatusAndLockX+0xe>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80018c8:	f3ef 8305 	mrs	r3, IPSR
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80018cc:	b672      	cpsid	i
    else {
      chSysLock();
    }
  }
  return sts;
}
 80018ce:	4770      	bx	lr

080018d0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80018d0:	e7fe      	b.n	80018d0 <BusFault_Handler>
 80018d2:	46c0      	nop			; (mov r8, r8)
 80018d4:	46c0      	nop			; (mov r8, r8)
 80018d6:	46c0      	nop			; (mov r8, r8)
 80018d8:	46c0      	nop			; (mov r8, r8)
 80018da:	46c0      	nop			; (mov r8, r8)
 80018dc:	46c0      	nop			; (mov r8, r8)
 80018de:	46c0      	nop			; (mov r8, r8)

080018e0 <test_008_003_setup.10011>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 80018e0:	4b09      	ldr	r3, [pc, #36]	; (8001908 <test_008_003_setup.10011+0x28>)
 80018e2:	4a0a      	ldr	r2, [pc, #40]	; (800190c <test_008_003_setup.10011+0x2c>)
 80018e4:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
 80018e6:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 80018e8:	609a      	str	r2, [r3, #8]
  mbp->top = &buf[n];
 80018ea:	3210      	adds	r2, #16
 80018ec:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80018ee:	1c1a      	adds	r2, r3, #0
 80018f0:	321c      	adds	r2, #28
 80018f2:	61da      	str	r2, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 80018f4:	621a      	str	r2, [r3, #32]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 80018f6:	2204      	movs	r2, #4
 80018f8:	625a      	str	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80018fa:	1c1a      	adds	r2, r3, #0
 80018fc:	3210      	adds	r2, #16
 80018fe:	611a      	str	r2, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001900:	615a      	str	r2, [r3, #20]
 8001902:	2200      	movs	r2, #0
 8001904:	619a      	str	r2, [r3, #24]
 * .
 */

static void test_008_003_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8001906:	4770      	bx	lr
 8001908:	2000042c 	.word	0x2000042c
 800190c:	20000b98 	.word	0x20000b98

08001910 <test_008_002_setup.10013>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8001910:	4b09      	ldr	r3, [pc, #36]	; (8001938 <test_008_002_setup.10013+0x28>)
 8001912:	4a0a      	ldr	r2, [pc, #40]	; (800193c <test_008_002_setup.10013+0x2c>)
 8001914:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
 8001916:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8001918:	609a      	str	r2, [r3, #8]
  mbp->top = &buf[n];
 800191a:	3210      	adds	r2, #16
 800191c:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800191e:	1c1a      	adds	r2, r3, #0
 8001920:	321c      	adds	r2, #28
 8001922:	61da      	str	r2, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8001924:	621a      	str	r2, [r3, #32]
 8001926:	2204      	movs	r2, #4
 8001928:	625a      	str	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800192a:	1c1a      	adds	r2, r3, #0
 800192c:	3210      	adds	r2, #16
 800192e:	611a      	str	r2, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001930:	615a      	str	r2, [r3, #20]
 8001932:	2200      	movs	r2, #0
 8001934:	619a      	str	r2, [r3, #24]
 * .
 */

static void test_008_002_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8001936:	4770      	bx	lr
 8001938:	2000042c 	.word	0x2000042c
 800193c:	20000b98 	.word	0x20000b98

08001940 <test_011_001_setup.10435>:

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8001940:	4b07      	ldr	r3, [pc, #28]	; (8001960 <test_011_001_setup.10435+0x20>)
  H_NEXT(&heapp->header) = hp;
 8001942:	4908      	ldr	r1, [pc, #32]	; (8001964 <test_011_001_setup.10435+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8001944:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8001946:	20cc      	movs	r0, #204	; 0xcc
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8001948:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
 800194a:	600a      	str	r2, [r1, #0]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 800194c:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800194e:	1c19      	adds	r1, r3, #0
 8001950:	3110      	adds	r1, #16

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8001952:	601a      	str	r2, [r3, #0]
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
 8001954:	60da      	str	r2, [r3, #12]
 8001956:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001958:	6159      	str	r1, [r3, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 800195a:	619a      	str	r2, [r3, #24]
 * .
 */

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 800195c:	4770      	bx	lr
 800195e:	46c0      	nop			; (mov r8, r8)
 8001960:	20000bb8 	.word	0x20000bb8
 8001964:	20000518 	.word	0x20000518
 8001968:	46c0      	nop			; (mov r8, r8)
 800196a:	46c0      	nop			; (mov r8, r8)
 800196c:	46c0      	nop			; (mov r8, r8)
 800196e:	46c0      	nop			; (mov r8, r8)

08001970 <test_012_011_setup.10613>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001970:	4b02      	ldr	r3, [pc, #8]	; (800197c <test_012_011_setup.10613+0xc>)
 8001972:	2200      	movs	r2, #0
 8001974:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001976:	605b      	str	r3, [r3, #4]
 8001978:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_012_011_setup(void) {
  chMtxObjectInit(&mtx1);
}
 800197a:	4770      	bx	lr
 800197c:	200004d0 	.word	0x200004d0

08001980 <test_005_009_setup.9408>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001980:	4b06      	ldr	r3, [pc, #24]	; (800199c <test_005_009_setup.9408+0x1c>)
 8001982:	2200      	movs	r2, #0
 8001984:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001986:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001988:	4b05      	ldr	r3, [pc, #20]	; (80019a0 <test_005_009_setup.9408+0x20>)
 800198a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800198c:	605b      	str	r3, [r3, #4]
 800198e:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001990:	4b04      	ldr	r3, [pc, #16]	; (80019a4 <test_005_009_setup.9408+0x24>)
 8001992:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001994:	605b      	str	r3, [r3, #4]
 8001996:	609a      	str	r2, [r3, #8]

static void test_005_009_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8001998:	4770      	bx	lr
 800199a:	46c0      	nop			; (mov r8, r8)
 800199c:	20000410 	.word	0x20000410
 80019a0:	20000418 	.word	0x20000418
 80019a4:	20000400 	.word	0x20000400
 80019a8:	46c0      	nop			; (mov r8, r8)
 80019aa:	46c0      	nop			; (mov r8, r8)
 80019ac:	46c0      	nop			; (mov r8, r8)
 80019ae:	46c0      	nop			; (mov r8, r8)

080019b0 <test_005_008_setup.9410>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80019b0:	4b04      	ldr	r3, [pc, #16]	; (80019c4 <test_005_008_setup.9410+0x14>)
 80019b2:	2200      	movs	r2, #0
 80019b4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80019b6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80019b8:	4b03      	ldr	r3, [pc, #12]	; (80019c8 <test_005_008_setup.9410+0x18>)
 80019ba:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80019bc:	605b      	str	r3, [r3, #4]
 80019be:	609a      	str	r2, [r3, #8]
 */

static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 80019c0:	4770      	bx	lr
 80019c2:	46c0      	nop			; (mov r8, r8)
 80019c4:	20000410 	.word	0x20000410
 80019c8:	20000418 	.word	0x20000418
 80019cc:	46c0      	nop			; (mov r8, r8)
 80019ce:	46c0      	nop			; (mov r8, r8)

080019d0 <test_005_007_setup.9412>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80019d0:	4b04      	ldr	r3, [pc, #16]	; (80019e4 <test_005_007_setup.9412+0x14>)
 80019d2:	2200      	movs	r2, #0
 80019d4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80019d6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80019d8:	4b03      	ldr	r3, [pc, #12]	; (80019e8 <test_005_007_setup.9412+0x18>)
 80019da:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80019dc:	605b      	str	r3, [r3, #4]
 80019de:	609a      	str	r2, [r3, #8]
 */

static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 80019e0:	4770      	bx	lr
 80019e2:	46c0      	nop			; (mov r8, r8)
 80019e4:	20000410 	.word	0x20000410
 80019e8:	20000418 	.word	0x20000418
 80019ec:	46c0      	nop			; (mov r8, r8)
 80019ee:	46c0      	nop			; (mov r8, r8)

080019f0 <test_005_005_setup.9414>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80019f0:	4b02      	ldr	r3, [pc, #8]	; (80019fc <test_005_005_setup.9414+0xc>)
 80019f2:	2200      	movs	r2, #0
 80019f4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80019f6:	605b      	str	r3, [r3, #4]
 80019f8:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_005_005_setup(void) {
  chMtxObjectInit(&m1);
}
 80019fa:	4770      	bx	lr
 80019fc:	20000418 	.word	0x20000418

08001a00 <test_005_004_setup.9416>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001a00:	4b04      	ldr	r3, [pc, #16]	; (8001a14 <test_005_004_setup.9416+0x14>)
 8001a02:	2200      	movs	r2, #0
 8001a04:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001a06:	605b      	str	r3, [r3, #4]
 8001a08:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001a0a:	4b03      	ldr	r3, [pc, #12]	; (8001a18 <test_005_004_setup.9416+0x18>)
 8001a0c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001a0e:	605b      	str	r3, [r3, #4]
 8001a10:	609a      	str	r2, [r3, #8]
 */

static void test_005_004_setup(void) {
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8001a12:	4770      	bx	lr
 8001a14:	20000418 	.word	0x20000418
 8001a18:	20000400 	.word	0x20000400
 8001a1c:	46c0      	nop			; (mov r8, r8)
 8001a1e:	46c0      	nop			; (mov r8, r8)

08001a20 <test_005_001_setup.9418>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001a20:	4b02      	ldr	r3, [pc, #8]	; (8001a2c <test_005_001_setup.9418+0xc>)
 8001a22:	2200      	movs	r2, #0
 8001a24:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001a26:	605b      	str	r3, [r3, #4]
 8001a28:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}
 8001a2a:	4770      	bx	lr
 8001a2c:	20000418 	.word	0x20000418

08001a30 <thread8.9392.4134>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8001a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chMtxLock(&m2);
 8001a32:	4d1e      	ldr	r5, [pc, #120]	; (8001aac <thread8.9392.4134+0x7c>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8001a34:	4646      	mov	r6, r8
 8001a36:	464f      	mov	r7, r9
 8001a38:	b4c0      	push	{r6, r7}
 8001a3a:	4680      	mov	r8, r0

  chMtxLock(&m2);
 8001a3c:	1c28      	adds	r0, r5, #0
 8001a3e:	f7ff fb3f 	bl	80010c0 <chMtxLock>
  chMtxLock(&m1);
 8001a42:	4e1b      	ldr	r6, [pc, #108]	; (8001ab0 <thread8.9392.4134+0x80>)
 8001a44:	1c30      	adds	r0, r6, #0
 8001a46:	f7ff fb3b 	bl	80010c0 <chMtxLock>
 8001a4a:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001a4c:	4c19      	ldr	r4, [pc, #100]	; (8001ab4 <thread8.9392.4134+0x84>)
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->mtxlist;
 8001a4e:	69a3      	ldr	r3, [r4, #24]
 8001a50:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8001a52:	4681      	mov	r9, r0
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8001a54:	f7ff fa74 	bl	8000f40 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8001a58:	4917      	ldr	r1, [pc, #92]	; (8001ab8 <thread8.9392.4134+0x88>)
 8001a5a:	69a2      	ldr	r2, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001a5c:	1c0b      	adds	r3, r1, #0
 8001a5e:	6251      	str	r1, [r2, #36]	; 0x24
 8001a60:	e003      	b.n	8001a6a <thread8.9392.4134+0x3a>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001a62:	689f      	ldr	r7, [r3, #8]
 8001a64:	6890      	ldr	r0, [r2, #8]
 8001a66:	4287      	cmp	r7, r0
 8001a68:	d302      	bcc.n	8001a70 <thread8.9392.4134+0x40>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001a6a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001a6c:	428b      	cmp	r3, r1
 8001a6e:	d1f8      	bne.n	8001a62 <thread8.9392.4134+0x32>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001a70:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001a72:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8001a74:	6051      	str	r1, [r2, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001a76:	2007      	movs	r0, #7
  tp->queue.prev->queue.next = tp;
 8001a78:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001a7a:	605a      	str	r2, [r3, #4]
 8001a7c:	f7ff f938 	bl	8000cf0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001a80:	69a3      	ldr	r3, [r4, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 8001a82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001a84:	3301      	adds	r3, #1
 8001a86:	d002      	beq.n	8001a8e <thread8.9392.4134+0x5e>
    chMtxLockS(mp);
 8001a88:	4648      	mov	r0, r9
 8001a8a:	f7ff fab1 	bl	8000ff0 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a8e:	b662      	cpsie	i
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8001a90:	4642      	mov	r2, r8
 8001a92:	7810      	ldrb	r0, [r2, #0]
 8001a94:	f7fe fdac 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 8001a98:	1c30      	adds	r0, r6, #0
 8001a9a:	f7ff fa79 	bl	8000f90 <chMtxUnlock>
  chMtxUnlock(&m2);
 8001a9e:	1c28      	adds	r0, r5, #0
 8001aa0:	f7ff fa76 	bl	8000f90 <chMtxUnlock>
}
 8001aa4:	bc0c      	pop	{r2, r3}
 8001aa6:	4690      	mov	r8, r2
 8001aa8:	4699      	mov	r9, r3
 8001aaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001aac:	20000400 	.word	0x20000400
 8001ab0:	20000418 	.word	0x20000418
 8001ab4:	20000ed4 	.word	0x20000ed4
 8001ab8:	20000410 	.word	0x20000410
 8001abc:	46c0      	nop			; (mov r8, r8)
 8001abe:	46c0      	nop			; (mov r8, r8)

08001ac0 <test_012_009_execute.10621>:
 *   one-second time window.
 * - [12.9.2] The score is printed.
 * .
 */

static void test_012_009_execute(void) {
 8001ac0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [12.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8001ac2:	4a21      	ldr	r2, [pc, #132]	; (8001b48 <test_012_009_execute.10621+0x88>)
 *   one-second time window.
 * - [12.9.2] The score is printed.
 * .
 */

static void test_012_009_execute(void) {
 8001ac4:	465f      	mov	r7, fp
 8001ac6:	4656      	mov	r6, sl
 8001ac8:	464d      	mov	r5, r9
 8001aca:	4644      	mov	r4, r8
 8001acc:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t n;

  /* [12.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8001ace:	2301      	movs	r3, #1
 8001ad0:	6013      	str	r3, [r2, #0]
 8001ad2:	4693      	mov	fp, r2
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8001ad4:	f001 fb24 	bl	8003120 <test_wait_tick>
 8001ad8:	4b1c      	ldr	r3, [pc, #112]	; (8001b4c <test_012_009_execute.10621+0x8c>)
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8001ada:	4a1d      	ldr	r2, [pc, #116]	; (8001b50 <test_012_009_execute.10621+0x90>)
 8001adc:	4f1d      	ldr	r7, [pc, #116]	; (8001b54 <test_012_009_execute.10621+0x94>)
 8001ade:	4e1e      	ldr	r6, [pc, #120]	; (8001b58 <test_012_009_execute.10621+0x98>)
 8001ae0:	4d1e      	ldr	r5, [pc, #120]	; (8001b5c <test_012_009_execute.10621+0x9c>)
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8001ae2:	4682      	mov	sl, r0
     one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8001ae4:	2400      	movs	r4, #0
 8001ae6:	4699      	mov	r9, r3
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8001ae8:	4690      	mov	r8, r2
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001aea:	b672      	cpsid	i
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8001aec:	2101      	movs	r1, #1
 8001aee:	1c38      	adds	r0, r7, #0
 8001af0:	1c32      	adds	r2, r6, #0
 8001af2:	2300      	movs	r3, #0
 8001af4:	f003 fa9c 	bl	8005030 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8001af8:	4919      	ldr	r1, [pc, #100]	; (8001b60 <test_012_009_execute.10621+0xa0>)
 8001afa:	1c32      	adds	r2, r6, #0
 8001afc:	2300      	movs	r3, #0
 8001afe:	1c28      	adds	r0, r5, #0
 8001b00:	f003 fa96 	bl	8005030 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8001b04:	1c38      	adds	r0, r7, #0
 8001b06:	f003 fa53 	bl	8004fb0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8001b0a:	1c28      	adds	r0, r5, #0
 8001b0c:	f003 fa50 	bl	8004fb0 <chVTDoResetI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001b10:	b662      	cpsie	i
 8001b12:	464a      	mov	r2, r9
 8001b14:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8001b16:	4652      	mov	r2, sl
 8001b18:	1a9b      	subs	r3, r3, r2
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8001b1a:	b29b      	uxth	r3, r3
      chVTDoSetI(&vt1, 1, tmo, NULL);
      chVTDoSetI(&vt2, 10000, tmo, NULL);
      chVTDoResetI(&vt1);
      chVTDoResetI(&vt2);
      chSysUnlock();
      n++;
 8001b1c:	3401      	adds	r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8001b1e:	4543      	cmp	r3, r8
 8001b20:	d9e3      	bls.n	8001aea <test_012_009_execute.10621+0x2a>
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 8001b22:	465a      	mov	r2, fp
 8001b24:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8001b26:	480f      	ldr	r0, [pc, #60]	; (8001b64 <test_012_009_execute.10621+0xa4>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 8001b28:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8001b2a:	f7fe fdb9 	bl	80006a0 <test_print>
    test_printn(n * 2);
 8001b2e:	0060      	lsls	r0, r4, #1
 8001b30:	f7fe fdce 	bl	80006d0 <test_printn>
    test_println(" timers/S");
 8001b34:	480c      	ldr	r0, [pc, #48]	; (8001b68 <test_012_009_execute.10621+0xa8>)
 8001b36:	f7fe fd93 	bl	8000660 <test_println>
  }
}
 8001b3a:	bc3c      	pop	{r2, r3, r4, r5}
 8001b3c:	4690      	mov	r8, r2
 8001b3e:	4699      	mov	r9, r3
 8001b40:	46a2      	mov	sl, r4
 8001b42:	46ab      	mov	fp, r5
 8001b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001b46:	46c0      	nop			; (mov r8, r8)
 8001b48:	20000f44 	.word	0x20000f44
 8001b4c:	40000400 	.word	0x40000400
 8001b50:	000003e7 	.word	0x000003e7
 8001b54:	200004f4 	.word	0x200004f4
 8001b58:	080002f1 	.word	0x080002f1
 8001b5c:	200004e0 	.word	0x200004e0
 8001b60:	00002710 	.word	0x00002710
 8001b64:	08005d80 	.word	0x08005d80
 8001b68:	08005d90 	.word	0x08005d90
 8001b6c:	46c0      	nop			; (mov r8, r8)
 8001b6e:	46c0      	nop			; (mov r8, r8)

08001b70 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001b70:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b72:	b672      	cpsid	i

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8001b74:	2322      	movs	r3, #34	; 0x22
 8001b76:	5cc2      	ldrb	r2, [r0, r3]
 8001b78:	3a01      	subs	r2, #1
 8001b7a:	54c2      	strb	r2, [r0, r3]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8001b7c:	6a01      	ldr	r1, [r0, #32]
 8001b7e:	4b10      	ldr	r3, [pc, #64]	; (8001bc0 <chThdRelease+0x50>)
 8001b80:	400b      	ands	r3, r1
 8001b82:	2b0f      	cmp	r3, #15
 8001b84:	d001      	beq.n	8001b8a <chThdRelease+0x1a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001b86:	b662      	cpsie	i
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8001b88:	bd08      	pop	{r3, pc}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8001b8a:	6902      	ldr	r2, [r0, #16]
 8001b8c:	6943      	ldr	r3, [r0, #20]
 8001b8e:	611a      	str	r2, [r3, #16]
 8001b90:	6902      	ldr	r2, [r0, #16]
 8001b92:	6153      	str	r3, [r2, #20]
 8001b94:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001b96:	2321      	movs	r3, #33	; 0x21
 8001b98:	5cc3      	ldrb	r3, [r0, r3]
 8001b9a:	2203      	movs	r2, #3
 8001b9c:	4013      	ands	r3, r2
 8001b9e:	2b01      	cmp	r3, #1
 8001ba0:	d009      	beq.n	8001bb6 <chThdRelease+0x46>
 8001ba2:	2b02      	cmp	r3, #2
 8001ba4:	d1f0      	bne.n	8001b88 <chThdRelease+0x18>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8001ba6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001ba8:	69c2      	ldr	r2, [r0, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001baa:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8001bac:	6819      	ldr	r1, [r3, #0]
 8001bae:	6011      	str	r1, [r2, #0]
  mp->next = php;
 8001bb0:	601a      	str	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bb2:	b662      	cpsie	i
 8001bb4:	e7e8      	b.n	8001b88 <chThdRelease+0x18>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 8001bb6:	69c0      	ldr	r0, [r0, #28]
 8001bb8:	f7ff fba2 	bl	8001300 <chHeapFree>
 8001bbc:	e7e4      	b.n	8001b88 <chThdRelease+0x18>
 8001bbe:	46c0      	nop			; (mov r8, r8)
 8001bc0:	00ff00ff 	.word	0x00ff00ff
 8001bc4:	46c0      	nop			; (mov r8, r8)
 8001bc6:	46c0      	nop			; (mov r8, r8)
 8001bc8:	46c0      	nop			; (mov r8, r8)
 8001bca:	46c0      	nop			; (mov r8, r8)
 8001bcc:	46c0      	nop			; (mov r8, r8)
 8001bce:	46c0      	nop			; (mov r8, r8)

08001bd0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001bd0:	b538      	push	{r3, r4, r5, lr}
 8001bd2:	1c04      	adds	r4, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001bd4:	b672      	cpsid	i
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 8001bd6:	2320      	movs	r3, #32
 8001bd8:	5cc3      	ldrb	r3, [r0, r3]
 8001bda:	2b0f      	cmp	r3, #15
 8001bdc:	d007      	beq.n	8001bee <chThdWait+0x1e>
    list_insert(currp, &tp->waiting);
 8001bde:	4b07      	ldr	r3, [pc, #28]	; (8001bfc <chThdWait+0x2c>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
 8001be0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001be2:	699b      	ldr	r3, [r3, #24]
 8001be4:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 8001be6:	6283      	str	r3, [r0, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001be8:	2009      	movs	r0, #9
 8001bea:	f7ff f881 	bl	8000cf0 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8001bee:	6a65      	ldr	r5, [r4, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bf0:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8001bf2:	1c20      	adds	r0, r4, #0
 8001bf4:	f7ff ffbc 	bl	8001b70 <chThdRelease>
#endif

  return msg;
}
 8001bf8:	1c28      	adds	r0, r5, #0
 8001bfa:	bd38      	pop	{r3, r4, r5, pc}
 8001bfc:	20000ed4 	.word	0x20000ed4

08001c00 <test_wait_threads>:

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8001c00:	b570      	push	{r4, r5, r6, lr}
 8001c02:	4c07      	ldr	r4, [pc, #28]	; (8001c20 <test_wait_threads+0x20>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8001c04:	2600      	movs	r6, #0
 8001c06:	1c25      	adds	r5, r4, #0
 8001c08:	3514      	adds	r5, #20
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001c0a:	6820      	ldr	r0, [r4, #0]
 8001c0c:	2800      	cmp	r0, #0
 8001c0e:	d002      	beq.n	8001c16 <test_wait_threads+0x16>
      chThdWait(threads[i]);
 8001c10:	f7ff ffde 	bl	8001bd0 <chThdWait>
      threads[i] = NULL;
 8001c14:	6026      	str	r6, [r4, #0]
 8001c16:	3404      	adds	r4, #4
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8001c18:	42ac      	cmp	r4, r5
 8001c1a:	d1f6      	bne.n	8001c0a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8001c1c:	bd70      	pop	{r4, r5, r6, pc}
 8001c1e:	46c0      	nop			; (mov r8, r8)
 8001c20:	20000b84 	.word	0x20000b84
 8001c24:	46c0      	nop			; (mov r8, r8)
 8001c26:	46c0      	nop			; (mov r8, r8)
 8001c28:	46c0      	nop			; (mov r8, r8)
 8001c2a:	46c0      	nop			; (mov r8, r8)
 8001c2c:	46c0      	nop			; (mov r8, r8)
 8001c2e:	46c0      	nop			; (mov r8, r8)

08001c30 <test_007_004_execute.9797>:

static void test_007_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_004_execute(void) {
 8001c30:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001c32:	4c29      	ldr	r4, [pc, #164]	; (8001cd8 <test_007_004_execute.9797+0xa8>)
 8001c34:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8001c36:	2005      	movs	r0, #5
static void test_007_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001c38:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8001c3a:	f7fe fee9 	bl	8000a10 <chEvtAddEvents>
  }

  /* [7.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8001c3e:	2302      	movs	r3, #2
 8001c40:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001c42:	f003 fbf5 	bl	8005430 <chEvtWaitAny.constprop.31>
    test_assert(m == 5, "unexpected pending bit");
 8001c46:	3805      	subs	r0, #5
 8001c48:	4243      	negs	r3, r0
 8001c4a:	4158      	adcs	r0, r3
 8001c4c:	b2c0      	uxtb	r0, r0
 8001c4e:	4923      	ldr	r1, [pc, #140]	; (8001cdc <test_007_004_execute.9797+0xac>)
 8001c50:	f7fe fe2e 	bl	80008b0 <_test_assert>
 8001c54:	2800      	cmp	r0, #0
 8001c56:	d000      	beq.n	8001c5a <test_007_004_execute.9797+0x2a>
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 8001c58:	bd70      	pop	{r4, r5, r6, pc}
     returned.*/
  test_set_step(2);
  {
    m = chEvtWaitAny(ALL_EVENTS);
    test_assert(m == 5, "unexpected pending bit");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001c5a:	f003 fb89 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 8001c5e:	4d20      	ldr	r5, [pc, #128]	; (8001ce0 <test_007_004_execute.9797+0xb0>)
 8001c60:	4243      	negs	r3, r0
 8001c62:	4158      	adcs	r0, r3
 8001c64:	b2c0      	uxtb	r0, r0
 8001c66:	1c29      	adds	r1, r5, #0
 8001c68:	f7fe fe22 	bl	80008b0 <_test_assert>
 8001c6c:	2800      	cmp	r0, #0
 8001c6e:	d1f3      	bne.n	8001c58 <test_007_004_execute.9797+0x28>
  }

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8001c70:	2303      	movs	r3, #3
 8001c72:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001c74:	f001 fa54 	bl	8003120 <test_wait_tick>
 8001c78:	4b1a      	ldr	r3, [pc, #104]	; (8001ce4 <test_007_004_execute.9797+0xb4>)
 8001c7a:	1c06      	adds	r6, r0, #0
 8001c7c:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001c7e:	4a1a      	ldr	r2, [pc, #104]	; (8001ce8 <test_007_004_execute.9797+0xb8>)
 8001c80:	6899      	ldr	r1, [r3, #8]
 8001c82:	481a      	ldr	r0, [pc, #104]	; (8001cec <test_007_004_execute.9797+0xbc>)
 8001c84:	3901      	subs	r1, #1
 8001c86:	f003 fabb 	bl	8005200 <chThdCreateStatic.constprop.52>
 8001c8a:	4b19      	ldr	r3, [pc, #100]	; (8001cf0 <test_007_004_execute.9797+0xc0>)
 8001c8c:	6018      	str	r0, [r3, #0]
  }

  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8001c8e:	2304      	movs	r3, #4
 8001c90:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001c92:	f003 fbcd 	bl	8005430 <chEvtWaitAny.constprop.31>

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001c96:	1c33      	adds	r3, r6, #0
 8001c98:	3332      	adds	r3, #50	; 0x32
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001c9a:	3634      	adds	r6, #52	; 0x34
  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001c9c:	1c04      	adds	r4, r0, #0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001c9e:	b2b1      	uxth	r1, r6
 8001ca0:	b298      	uxth	r0, r3
 8001ca2:	f7fe fc6d 	bl	8000580 <_test_assert_time_window.constprop.2>
 8001ca6:	2800      	cmp	r0, #0
 8001ca8:	d1d6      	bne.n	8001c58 <test_007_004_execute.9797+0x28>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8001caa:	1e60      	subs	r0, r4, #1
 8001cac:	4244      	negs	r4, r0
 8001cae:	4160      	adcs	r0, r4
 8001cb0:	b2c0      	uxtb	r0, r0
 8001cb2:	4910      	ldr	r1, [pc, #64]	; (8001cf4 <test_007_004_execute.9797+0xc4>)
 8001cb4:	f7fe fdfc 	bl	80008b0 <_test_assert>
 8001cb8:	2800      	cmp	r0, #0
 8001cba:	d1cd      	bne.n	8001c58 <test_007_004_execute.9797+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001cbc:	f003 fb58 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 8001cc0:	4243      	negs	r3, r0
 8001cc2:	4158      	adcs	r0, r3
 8001cc4:	b2c0      	uxtb	r0, r0
 8001cc6:	1c29      	adds	r1, r5, #0
 8001cc8:	f7fe fdf2 	bl	80008b0 <_test_assert>
 8001ccc:	2800      	cmp	r0, #0
 8001cce:	d1c3      	bne.n	8001c58 <test_007_004_execute.9797+0x28>
    test_wait_threads();
 8001cd0:	f7ff ff96 	bl	8001c00 <test_wait_threads>
 8001cd4:	e7c0      	b.n	8001c58 <test_007_004_execute.9797+0x28>
 8001cd6:	46c0      	nop			; (mov r8, r8)
 8001cd8:	20000f44 	.word	0x20000f44
 8001cdc:	08005d9c 	.word	0x08005d9c
 8001ce0:	08005db4 	.word	0x08005db4
 8001ce4:	20000ed4 	.word	0x20000ed4
 8001ce8:	08002e71 	.word	0x08002e71
 8001cec:	20000518 	.word	0x20000518
 8001cf0:	20000b84 	.word	0x20000b84
 8001cf4:	08005dc0 	.word	0x08005dc0
 8001cf8:	46c0      	nop			; (mov r8, r8)
 8001cfa:	46c0      	nop			; (mov r8, r8)
 8001cfc:	46c0      	nop			; (mov r8, r8)
 8001cfe:	46c0      	nop			; (mov r8, r8)

08001d00 <test_007_003_execute.9801>:

static void test_007_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_003_execute(void) {
 8001d00:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8001d02:	4c35      	ldr	r4, [pc, #212]	; (8001dd8 <test_007_003_execute.9801+0xd8>)
 8001d04:	2301      	movs	r3, #1
  {
    chEvtAddEvents(7);
 8001d06:	2007      	movs	r0, #7
static void test_007_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8001d08:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(7);
 8001d0a:	f7fe fe81 	bl	8000a10 <chEvtAddEvents>
  }

  /* [7.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 8001d0e:	2302      	movs	r3, #2
 8001d10:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001d12:	f003 fb75 	bl	8005400 <chEvtWaitOne.constprop.32>
    test_assert(m == 1, "single event error");
 8001d16:	4d31      	ldr	r5, [pc, #196]	; (8001ddc <test_007_003_execute.9801+0xdc>)
 8001d18:	3801      	subs	r0, #1
 8001d1a:	4243      	negs	r3, r0
 8001d1c:	4158      	adcs	r0, r3
 8001d1e:	b2c0      	uxtb	r0, r0
 8001d20:	1c29      	adds	r1, r5, #0
 8001d22:	f7fe fdc5 	bl	80008b0 <_test_assert>
 8001d26:	2800      	cmp	r0, #0
 8001d28:	d000      	beq.n	8001d2c <test_007_003_execute.9801+0x2c>
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 8001d2a:	bd70      	pop	{r4, r5, r6, pc}
     flag must be returned in order of priority.*/
  test_set_step(2);
  {
    m = chEvtWaitOne(ALL_EVENTS);
    test_assert(m == 1, "single event error");
    m = chEvtWaitOne(ALL_EVENTS);
 8001d2c:	f003 fb68 	bl	8005400 <chEvtWaitOne.constprop.32>
    test_assert(m == 2, "single event error");
 8001d30:	3802      	subs	r0, #2
 8001d32:	4243      	negs	r3, r0
 8001d34:	4158      	adcs	r0, r3
 8001d36:	b2c0      	uxtb	r0, r0
 8001d38:	1c29      	adds	r1, r5, #0
 8001d3a:	f7fe fdb9 	bl	80008b0 <_test_assert>
 8001d3e:	2800      	cmp	r0, #0
 8001d40:	d1f3      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
    m = chEvtWaitOne(ALL_EVENTS);
 8001d42:	f003 fb5d 	bl	8005400 <chEvtWaitOne.constprop.32>
    test_assert(m == 4, "single event error");
 8001d46:	3804      	subs	r0, #4
 8001d48:	4243      	negs	r3, r0
 8001d4a:	4158      	adcs	r0, r3
 8001d4c:	b2c0      	uxtb	r0, r0
 8001d4e:	1c29      	adds	r1, r5, #0
 8001d50:	f7fe fdae 	bl	80008b0 <_test_assert>
 8001d54:	2800      	cmp	r0, #0
 8001d56:	d1e8      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001d58:	f003 fb0a 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 8001d5c:	4d20      	ldr	r5, [pc, #128]	; (8001de0 <test_007_003_execute.9801+0xe0>)
 8001d5e:	4243      	negs	r3, r0
 8001d60:	4158      	adcs	r0, r3
 8001d62:	b2c0      	uxtb	r0, r0
 8001d64:	1c29      	adds	r1, r5, #0
 8001d66:	f7fe fda3 	bl	80008b0 <_test_assert>
 8001d6a:	2800      	cmp	r0, #0
 8001d6c:	d1dd      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
  }

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8001d6e:	2303      	movs	r3, #3
 8001d70:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001d72:	f001 f9d5 	bl	8003120 <test_wait_tick>
 8001d76:	4b1b      	ldr	r3, [pc, #108]	; (8001de4 <test_007_003_execute.9801+0xe4>)
 8001d78:	1c06      	adds	r6, r0, #0
 8001d7a:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001d7c:	4a1a      	ldr	r2, [pc, #104]	; (8001de8 <test_007_003_execute.9801+0xe8>)
 8001d7e:	6899      	ldr	r1, [r3, #8]
 8001d80:	481a      	ldr	r0, [pc, #104]	; (8001dec <test_007_003_execute.9801+0xec>)
 8001d82:	3901      	subs	r1, #1
 8001d84:	f003 fa3c 	bl	8005200 <chThdCreateStatic.constprop.52>
 8001d88:	4b19      	ldr	r3, [pc, #100]	; (8001df0 <test_007_003_execute.9801+0xf0>)
 8001d8a:	6018      	str	r0, [r3, #0]
  }

  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8001d8c:	2304      	movs	r3, #4
 8001d8e:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001d90:	f003 fb36 	bl	8005400 <chEvtWaitOne.constprop.32>

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001d94:	1c33      	adds	r3, r6, #0
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001d96:	1c31      	adds	r1, r6, #0

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001d98:	3332      	adds	r3, #50	; 0x32
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001d9a:	3134      	adds	r1, #52	; 0x34
  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001d9c:	1c04      	adds	r4, r0, #0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001d9e:	b289      	uxth	r1, r1
 8001da0:	b298      	uxth	r0, r3
 8001da2:	f7fe fbed 	bl	8000580 <_test_assert_time_window.constprop.2>
 8001da6:	2800      	cmp	r0, #0
 8001da8:	d1bf      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8001daa:	1e60      	subs	r0, r4, #1
 8001dac:	4244      	negs	r4, r0
 8001dae:	4160      	adcs	r0, r4
 8001db0:	b2c0      	uxtb	r0, r0
 8001db2:	4910      	ldr	r1, [pc, #64]	; (8001df4 <test_007_003_execute.9801+0xf4>)
 8001db4:	f7fe fd7c 	bl	80008b0 <_test_assert>
 8001db8:	2800      	cmp	r0, #0
 8001dba:	d1b6      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001dbc:	f003 fad8 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 8001dc0:	4243      	negs	r3, r0
 8001dc2:	4158      	adcs	r0, r3
 8001dc4:	b2c0      	uxtb	r0, r0
 8001dc6:	1c29      	adds	r1, r5, #0
 8001dc8:	f7fe fd72 	bl	80008b0 <_test_assert>
 8001dcc:	2800      	cmp	r0, #0
 8001dce:	d1ac      	bne.n	8001d2a <test_007_003_execute.9801+0x2a>
    test_wait_threads();
 8001dd0:	f7ff ff16 	bl	8001c00 <test_wait_threads>
 8001dd4:	e7a9      	b.n	8001d2a <test_007_003_execute.9801+0x2a>
 8001dd6:	46c0      	nop			; (mov r8, r8)
 8001dd8:	20000f44 	.word	0x20000f44
 8001ddc:	08005dd4 	.word	0x08005dd4
 8001de0:	08005db4 	.word	0x08005db4
 8001de4:	20000ed4 	.word	0x20000ed4
 8001de8:	08002e71 	.word	0x08002e71
 8001dec:	20000518 	.word	0x20000518
 8001df0:	20000b84 	.word	0x20000b84
 8001df4:	08005dc0 	.word	0x08005dc0
 8001df8:	46c0      	nop			; (mov r8, r8)
 8001dfa:	46c0      	nop			; (mov r8, r8)
 8001dfc:	46c0      	nop			; (mov r8, r8)
 8001dfe:	46c0      	nop			; (mov r8, r8)

08001e00 <test_006_001_execute.9534>:
 * - [6.1.1] Starting the messenger thread.
 * - [6.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_006_001_execute(void) {
 8001e00:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8001e02:	4c12      	ldr	r4, [pc, #72]	; (8001e4c <test_006_001_execute.9534+0x4c>)
 8001e04:	2301      	movs	r3, #1
 8001e06:	6023      	str	r3, [r4, #0]
 8001e08:	4b11      	ldr	r3, [pc, #68]	; (8001e50 <test_006_001_execute.9534+0x50>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8001e0a:	4812      	ldr	r0, [pc, #72]	; (8001e54 <test_006_001_execute.9534+0x54>)
 8001e0c:	699b      	ldr	r3, [r3, #24]
 8001e0e:	4a12      	ldr	r2, [pc, #72]	; (8001e58 <test_006_001_execute.9534+0x58>)
 8001e10:	6899      	ldr	r1, [r3, #8]
 8001e12:	3101      	adds	r1, #1
 8001e14:	f003 f9f4 	bl	8005200 <chThdCreateStatic.constprop.52>
 8001e18:	4b10      	ldr	r3, [pc, #64]	; (8001e5c <test_006_001_execute.9534+0x5c>)
 8001e1a:	6018      	str	r0, [r3, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8001e1c:	2302      	movs	r3, #2
 8001e1e:	6023      	str	r3, [r4, #0]
 8001e20:	2404      	movs	r4, #4
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8001e22:	f7fe ff8d 	bl	8000d40 <chMsgWait>
 * - [6.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_006_001_execute(void) {
  thread_t *tp;
 8001e26:	6a45      	ldr	r5, [r0, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e28:	b672      	cpsid	i
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8001e2a:	1c29      	adds	r1, r5, #0
 8001e2c:	f7fe fee8 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001e30:	b662      	cpsie	i

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 8001e32:	b2e8      	uxtb	r0, r5
 8001e34:	3c01      	subs	r4, #1
 8001e36:	f7fe fbdb 	bl	80005f0 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8001e3a:	2c00      	cmp	r4, #0
 8001e3c:	d1f1      	bne.n	8001e22 <test_006_001_execute.9534+0x22>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 8001e3e:	f7ff fedf 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8001e42:	4907      	ldr	r1, [pc, #28]	; (8001e60 <test_006_001_execute.9534+0x60>)
 8001e44:	4807      	ldr	r0, [pc, #28]	; (8001e64 <test_006_001_execute.9534+0x64>)
 8001e46:	f7fe fd03 	bl	8000850 <_test_assert_sequence>
  }
}
 8001e4a:	bd38      	pop	{r3, r4, r5, pc}
 8001e4c:	20000f44 	.word	0x20000f44
 8001e50:	20000ed4 	.word	0x20000ed4
 8001e54:	20000518 	.word	0x20000518
 8001e58:	08000ea1 	.word	0x08000ea1
 8001e5c:	20000b84 	.word	0x20000b84
 8001e60:	08005df0 	.word	0x08005df0
 8001e64:	08005de8 	.word	0x08005de8
 8001e68:	46c0      	nop			; (mov r8, r8)
 8001e6a:	46c0      	nop			; (mov r8, r8)
 8001e6c:	46c0      	nop			; (mov r8, r8)
 8001e6e:	46c0      	nop			; (mov r8, r8)

08001e70 <test_005_004_teardown.9404>:
static void test_005_004_setup(void) {
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_004_teardown(void) {
 8001e70:	b508      	push	{r3, lr}
  test_wait_threads();
 8001e72:	f7ff fec5 	bl	8001c00 <test_wait_threads>
}
 8001e76:	bd08      	pop	{r3, pc}
 8001e78:	46c0      	nop			; (mov r8, r8)
 8001e7a:	46c0      	nop			; (mov r8, r8)
 8001e7c:	46c0      	nop			; (mov r8, r8)
 8001e7e:	46c0      	nop			; (mov r8, r8)

08001e80 <test_005_009_execute.9406>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_009_execute(void) {
 8001e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e82:	4b1b      	ldr	r3, [pc, #108]	; (8001ef0 <test_005_009_execute.9406+0x70>)
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8001e84:	4c1b      	ldr	r4, [pc, #108]	; (8001ef4 <test_005_009_execute.9406+0x74>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001e86:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8001e88:	4f1b      	ldr	r7, [pc, #108]	; (8001ef8 <test_005_009_execute.9406+0x78>)
 8001e8a:	689e      	ldr	r6, [r3, #8]
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8001e8c:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8001e8e:	1c71      	adds	r1, r6, #1
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8001e90:	6023      	str	r3, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8001e92:	1c38      	adds	r0, r7, #0
 8001e94:	4a19      	ldr	r2, [pc, #100]	; (8001efc <test_005_009_execute.9406+0x7c>)
 8001e96:	4b1a      	ldr	r3, [pc, #104]	; (8001f00 <test_005_009_execute.9406+0x80>)
 8001e98:	f003 f9b2 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8001e9c:	2303      	movs	r3, #3

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8001e9e:	4d19      	ldr	r5, [pc, #100]	; (8001f04 <test_005_009_execute.9406+0x84>)
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8001ea0:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8001ea2:	23a4      	movs	r3, #164	; 0xa4
 8001ea4:	005b      	lsls	r3, r3, #1

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8001ea6:	6028      	str	r0, [r5, #0]

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8001ea8:	1cb1      	adds	r1, r6, #2
 8001eaa:	18f8      	adds	r0, r7, r3
 8001eac:	4a16      	ldr	r2, [pc, #88]	; (8001f08 <test_005_009_execute.9406+0x88>)
 8001eae:	4b17      	ldr	r3, [pc, #92]	; (8001f0c <test_005_009_execute.9406+0x8c>)
 8001eb0:	f003 f9a6 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8001eb4:	2304      	movs	r3, #4
 8001eb6:	6023      	str	r3, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8001eb8:	23a4      	movs	r3, #164	; 0xa4
 8001eba:	009b      	lsls	r3, r3, #2
 8001ebc:	1cf1      	adds	r1, r6, #3
 8001ebe:	4a14      	ldr	r2, [pc, #80]	; (8001f10 <test_005_009_execute.9406+0x90>)

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8001ec0:	6068      	str	r0, [r5, #4]

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8001ec2:	18f8      	adds	r0, r7, r3
 8001ec4:	4b13      	ldr	r3, [pc, #76]	; (8001f14 <test_005_009_execute.9406+0x94>)
 8001ec6:	f003 f99b 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8001eca:	2305      	movs	r3, #5

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8001ecc:	60a8      	str	r0, [r5, #8]
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8001ece:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8001ed0:	f003 fa2e 	bl	8005330 <chCondSignal.constprop.43>
  }

  /* [5.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8001ed4:	2306      	movs	r3, #6
 8001ed6:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8001ed8:	f003 fa2a 	bl	8005330 <chCondSignal.constprop.43>
  }

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
 8001edc:	2307      	movs	r3, #7
 8001ede:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8001ee0:	f7ff fe8e 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8001ee4:	490c      	ldr	r1, [pc, #48]	; (8001f18 <test_005_009_execute.9406+0x98>)
 8001ee6:	480d      	ldr	r0, [pc, #52]	; (8001f1c <test_005_009_execute.9406+0x9c>)
 8001ee8:	f7fe fcb2 	bl	8000850 <_test_assert_sequence>
  }
}
 8001eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001eee:	46c0      	nop			; (mov r8, r8)
 8001ef0:	20000ed4 	.word	0x20000ed4
 8001ef4:	20000f44 	.word	0x20000f44
 8001ef8:	20000518 	.word	0x20000518
 8001efc:	08001a31 	.word	0x08001a31
 8001f00:	08005e04 	.word	0x08005e04
 8001f04:	20000b84 	.word	0x20000b84
 8001f08:	08004ef1 	.word	0x08004ef1
 8001f0c:	08005e08 	.word	0x08005e08
 8001f10:	08001271 	.word	0x08001271
 8001f14:	08005e0c 	.word	0x08005e0c
 8001f18:	08005df0 	.word	0x08005df0
 8001f1c:	08005e10 	.word	0x08005e10

08001f20 <test_005_008_execute.9420>:
static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_008_execute(void) {
 8001f20:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8001f22:	4a2b      	ldr	r2, [pc, #172]	; (8001fd0 <test_005_008_execute.9420+0xb0>)
static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_008_execute(void) {
 8001f24:	4647      	mov	r7, r8

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8001f26:	2301      	movs	r3, #1
static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_008_execute(void) {
 8001f28:	b480      	push	{r7}

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8001f2a:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001f2c:	4b29      	ldr	r3, [pc, #164]	; (8001fd4 <test_005_008_execute.9420+0xb4>)
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8001f2e:	4f2a      	ldr	r7, [pc, #168]	; (8001fd8 <test_005_008_execute.9420+0xb8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001f30:	699b      	ldr	r3, [r3, #24]
 8001f32:	4d2a      	ldr	r5, [pc, #168]	; (8001fdc <test_005_008_execute.9420+0xbc>)
 8001f34:	689e      	ldr	r6, [r3, #8]

static void test_005_008_execute(void) {

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8001f36:	4690      	mov	r8, r2
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8001f38:	1c71      	adds	r1, r6, #1
 8001f3a:	1c2a      	adds	r2, r5, #0
 8001f3c:	1c38      	adds	r0, r7, #0
 8001f3e:	4b28      	ldr	r3, [pc, #160]	; (8001fe0 <test_005_008_execute.9420+0xc0>)
 8001f40:	f003 f95e 	bl	8005200 <chThdCreateStatic.constprop.52>
 8001f44:	4c27      	ldr	r4, [pc, #156]	; (8001fe4 <test_005_008_execute.9420+0xc4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8001f46:	23a4      	movs	r3, #164	; 0xa4
 8001f48:	005b      	lsls	r3, r3, #1
  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8001f4a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8001f4c:	1cb1      	adds	r1, r6, #2
 8001f4e:	18f8      	adds	r0, r7, r3
 8001f50:	1c2a      	adds	r2, r5, #0
 8001f52:	4b25      	ldr	r3, [pc, #148]	; (8001fe8 <test_005_008_execute.9420+0xc8>)
 8001f54:	f003 f954 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8001f58:	22a4      	movs	r2, #164	; 0xa4
 8001f5a:	0092      	lsls	r2, r2, #2
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8001f5c:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8001f5e:	1cf1      	adds	r1, r6, #3
 8001f60:	18b8      	adds	r0, r7, r2
 8001f62:	4b22      	ldr	r3, [pc, #136]	; (8001fec <test_005_008_execute.9420+0xcc>)
 8001f64:	1c2a      	adds	r2, r5, #0
 8001f66:	f003 f94b 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8001f6a:	23f6      	movs	r3, #246	; 0xf6
 8001f6c:	009b      	lsls	r3, r3, #2
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8001f6e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8001f70:	1d31      	adds	r1, r6, #4
 8001f72:	18f8      	adds	r0, r7, r3
 8001f74:	1c2a      	adds	r2, r5, #0
 8001f76:	4b1e      	ldr	r3, [pc, #120]	; (8001ff0 <test_005_008_execute.9420+0xd0>)
 8001f78:	f003 f942 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8001f7c:	22a4      	movs	r2, #164	; 0xa4
 8001f7e:	00d2      	lsls	r2, r2, #3
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8001f80:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8001f82:	1d71      	adds	r1, r6, #5
 8001f84:	18b8      	adds	r0, r7, r2
 8001f86:	4b1b      	ldr	r3, [pc, #108]	; (8001ff4 <test_005_008_execute.9420+0xd4>)
 8001f88:	1c2a      	adds	r2, r5, #0
 8001f8a:	f003 f939 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8001f8e:	2302      	movs	r3, #2
 8001f90:	4642      	mov	r2, r8
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8001f92:	6120      	str	r0, [r4, #16]
  }

  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8001f94:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001f96:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001f98:	4c17      	ldr	r4, [pc, #92]	; (8001ff8 <test_005_008_execute.9420+0xd8>)

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8001f9a:	2502      	movs	r5, #2
 8001f9c:	6820      	ldr	r0, [r4, #0]
 8001f9e:	426d      	negs	r5, r5
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8001fa0:	42a0      	cmp	r0, r4
 8001fa2:	d008      	beq.n	8001fb6 <test_005_008_execute.9420+0x96>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001fa4:	6803      	ldr	r3, [r0, #0]
 8001fa6:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001fa8:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8001faa:	f7fe ff41 	bl	8000e30 <chSchReadyI>
 8001fae:	6245      	str	r5, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001fb0:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8001fb2:	42a0      	cmp	r0, r4
 8001fb4:	d1f6      	bne.n	8001fa4 <test_005_008_execute.9420+0x84>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8001fb6:	f7fe fd83 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001fba:	b662      	cpsie	i
  {
    chCondBroadcast(&c1);
    test_wait_threads();
 8001fbc:	f7ff fe20 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001fc0:	490e      	ldr	r1, [pc, #56]	; (8001ffc <test_005_008_execute.9420+0xdc>)
 8001fc2:	480f      	ldr	r0, [pc, #60]	; (8002000 <test_005_008_execute.9420+0xe0>)
 8001fc4:	f7fe fc44 	bl	8000850 <_test_assert_sequence>
  }
}
 8001fc8:	bc04      	pop	{r2}
 8001fca:	4690      	mov	r8, r2
 8001fcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001fce:	46c0      	nop			; (mov r8, r8)
 8001fd0:	20000f44 	.word	0x20000f44
 8001fd4:	20000ed4 	.word	0x20000ed4
 8001fd8:	20000518 	.word	0x20000518
 8001fdc:	08004ef1 	.word	0x08004ef1
 8001fe0:	08005e1c 	.word	0x08005e1c
 8001fe4:	20000b84 	.word	0x20000b84
 8001fe8:	08005e14 	.word	0x08005e14
 8001fec:	08005e08 	.word	0x08005e08
 8001ff0:	08005e0c 	.word	0x08005e0c
 8001ff4:	08005e04 	.word	0x08005e04
 8001ff8:	20000410 	.word	0x20000410
 8001ffc:	08005df0 	.word	0x08005df0
 8002000:	08005e18 	.word	0x08005e18
 8002004:	46c0      	nop			; (mov r8, r8)
 8002006:	46c0      	nop			; (mov r8, r8)
 8002008:	46c0      	nop			; (mov r8, r8)
 800200a:	46c0      	nop			; (mov r8, r8)
 800200c:	46c0      	nop			; (mov r8, r8)
 800200e:	46c0      	nop			; (mov r8, r8)

08002010 <test_005_007_execute.9422>:
static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_007_execute(void) {
 8002010:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8002012:	4a28      	ldr	r2, [pc, #160]	; (80020b4 <test_005_007_execute.9422+0xa4>)
static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_007_execute(void) {
 8002014:	4647      	mov	r7, r8

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8002016:	2301      	movs	r3, #1
static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_007_execute(void) {
 8002018:	b480      	push	{r7}

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 800201a:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800201c:	4b26      	ldr	r3, [pc, #152]	; (80020b8 <test_005_007_execute.9422+0xa8>)
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800201e:	4f27      	ldr	r7, [pc, #156]	; (80020bc <test_005_007_execute.9422+0xac>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002020:	699b      	ldr	r3, [r3, #24]
 8002022:	4d27      	ldr	r5, [pc, #156]	; (80020c0 <test_005_007_execute.9422+0xb0>)
 8002024:	689e      	ldr	r6, [r3, #8]

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8002026:	4690      	mov	r8, r2
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8002028:	1c71      	adds	r1, r6, #1
 800202a:	1c2a      	adds	r2, r5, #0
 800202c:	1c38      	adds	r0, r7, #0
 800202e:	4b25      	ldr	r3, [pc, #148]	; (80020c4 <test_005_007_execute.9422+0xb4>)
 8002030:	f003 f8e6 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002034:	4c24      	ldr	r4, [pc, #144]	; (80020c8 <test_005_007_execute.9422+0xb8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8002036:	23a4      	movs	r3, #164	; 0xa4
 8002038:	005b      	lsls	r3, r3, #1
  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800203a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800203c:	1cb1      	adds	r1, r6, #2
 800203e:	18f8      	adds	r0, r7, r3
 8002040:	1c2a      	adds	r2, r5, #0
 8002042:	4b22      	ldr	r3, [pc, #136]	; (80020cc <test_005_007_execute.9422+0xbc>)
 8002044:	f003 f8dc 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8002048:	22a4      	movs	r2, #164	; 0xa4
 800204a:	0092      	lsls	r2, r2, #2
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800204c:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800204e:	1cf1      	adds	r1, r6, #3
 8002050:	18b8      	adds	r0, r7, r2
 8002052:	4b1f      	ldr	r3, [pc, #124]	; (80020d0 <test_005_007_execute.9422+0xc0>)
 8002054:	1c2a      	adds	r2, r5, #0
 8002056:	f003 f8d3 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800205a:	23f6      	movs	r3, #246	; 0xf6
 800205c:	009b      	lsls	r3, r3, #2
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800205e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8002060:	1d31      	adds	r1, r6, #4
 8002062:	18f8      	adds	r0, r7, r3
 8002064:	1c2a      	adds	r2, r5, #0
 8002066:	4b1b      	ldr	r3, [pc, #108]	; (80020d4 <test_005_007_execute.9422+0xc4>)
 8002068:	f003 f8ca 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800206c:	22a4      	movs	r2, #164	; 0xa4
 800206e:	00d2      	lsls	r2, r2, #3
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8002070:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8002072:	1d71      	adds	r1, r6, #5
 8002074:	18b8      	adds	r0, r7, r2
 8002076:	4b18      	ldr	r3, [pc, #96]	; (80020d8 <test_005_007_execute.9422+0xc8>)
 8002078:	1c2a      	adds	r2, r5, #0
 800207a:	f003 f8c1 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 800207e:	2302      	movs	r3, #2
 8002080:	4642      	mov	r2, r8
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8002082:	6120      	str	r0, [r4, #16]
  }

  /* [5.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8002084:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002086:	b672      	cpsid	i
  {
    chSysLock();
    chCondSignalI(&c1);
 8002088:	f003 f962 	bl	8005350 <chCondSignalI.constprop.42>
    chCondSignalI(&c1);
 800208c:	f003 f960 	bl	8005350 <chCondSignalI.constprop.42>
    chCondSignalI(&c1);
 8002090:	f003 f95e 	bl	8005350 <chCondSignalI.constprop.42>
    chCondSignalI(&c1);
 8002094:	f003 f95c 	bl	8005350 <chCondSignalI.constprop.42>
    chCondSignalI(&c1);
 8002098:	f003 f95a 	bl	8005350 <chCondSignalI.constprop.42>
    chSchRescheduleS();
 800209c:	f7fe fd10 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80020a0:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 80020a2:	f7ff fdad 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80020a6:	490d      	ldr	r1, [pc, #52]	; (80020dc <test_005_007_execute.9422+0xcc>)
 80020a8:	480d      	ldr	r0, [pc, #52]	; (80020e0 <test_005_007_execute.9422+0xd0>)
 80020aa:	f7fe fbd1 	bl	8000850 <_test_assert_sequence>
  }
}
 80020ae:	bc04      	pop	{r2}
 80020b0:	4690      	mov	r8, r2
 80020b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80020b4:	20000f44 	.word	0x20000f44
 80020b8:	20000ed4 	.word	0x20000ed4
 80020bc:	20000518 	.word	0x20000518
 80020c0:	08004ef1 	.word	0x08004ef1
 80020c4:	08005e1c 	.word	0x08005e1c
 80020c8:	20000b84 	.word	0x20000b84
 80020cc:	08005e14 	.word	0x08005e14
 80020d0:	08005e08 	.word	0x08005e08
 80020d4:	08005e0c 	.word	0x08005e0c
 80020d8:	08005e04 	.word	0x08005e04
 80020dc:	08005df0 	.word	0x08005df0
 80020e0:	08005e18 	.word	0x08005e18
 80020e4:	46c0      	nop			; (mov r8, r8)
 80020e6:	46c0      	nop			; (mov r8, r8)
 80020e8:	46c0      	nop			; (mov r8, r8)
 80020ea:	46c0      	nop			; (mov r8, r8)
 80020ec:	46c0      	nop			; (mov r8, r8)
 80020ee:	46c0      	nop			; (mov r8, r8)

080020f0 <test_005_001_execute.9424>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80020f0:	4a30      	ldr	r2, [pc, #192]	; (80021b4 <test_005_001_execute.9424+0xc4>)

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 80020f2:	b5f0      	push	{r4, r5, r6, r7, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80020f4:	6993      	ldr	r3, [r2, #24]
 80020f6:	4645      	mov	r5, r8
 80020f8:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80020fa:	4b2f      	ldr	r3, [pc, #188]	; (80021b8 <test_005_001_execute.9424+0xc8>)

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 80020fc:	4657      	mov	r7, sl
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80020fe:	4698      	mov	r8, r3

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 8002100:	464e      	mov	r6, r9
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 8002102:	2302      	movs	r3, #2
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002104:	4691      	mov	r9, r2
 8002106:	4642      	mov	r2, r8

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 8002108:	b4e0      	push	{r5, r6, r7}
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 800210a:	6013      	str	r3, [r2, #0]
  {
    chMtxLock(&m1);
 800210c:	4b2b      	ldr	r3, [pc, #172]	; (80021bc <test_005_001_execute.9424+0xcc>)
 800210e:	1c18      	adds	r0, r3, #0
 8002110:	469a      	mov	sl, r3
 8002112:	f7fe ffd5 	bl	80010c0 <chMtxLock>
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8002116:	4f2a      	ldr	r7, [pc, #168]	; (80021c0 <test_005_001_execute.9424+0xd0>)
 8002118:	4e2a      	ldr	r6, [pc, #168]	; (80021c4 <test_005_001_execute.9424+0xd4>)
  }

  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 800211a:	2303      	movs	r3, #3
 800211c:	4642      	mov	r2, r8
 800211e:	6013      	str	r3, [r2, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8002120:	1c61      	adds	r1, r4, #1
 8002122:	1c32      	adds	r2, r6, #0
 8002124:	4b28      	ldr	r3, [pc, #160]	; (80021c8 <test_005_001_execute.9424+0xd8>)
 8002126:	1c38      	adds	r0, r7, #0
 8002128:	f003 f86a 	bl	8005200 <chThdCreateStatic.constprop.52>
 800212c:	4d27      	ldr	r5, [pc, #156]	; (80021cc <test_005_001_execute.9424+0xdc>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800212e:	23a4      	movs	r3, #164	; 0xa4
 8002130:	005b      	lsls	r3, r3, #1
 8002132:	1ca1      	adds	r1, r4, #2
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8002134:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8002136:	1c32      	adds	r2, r6, #0
 8002138:	18f8      	adds	r0, r7, r3
 800213a:	4b25      	ldr	r3, [pc, #148]	; (80021d0 <test_005_001_execute.9424+0xe0>)
 800213c:	f003 f860 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8002140:	22a4      	movs	r2, #164	; 0xa4
 8002142:	0092      	lsls	r2, r2, #2
 8002144:	1ce1      	adds	r1, r4, #3
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8002146:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8002148:	4b22      	ldr	r3, [pc, #136]	; (80021d4 <test_005_001_execute.9424+0xe4>)
 800214a:	18b8      	adds	r0, r7, r2
 800214c:	1c32      	adds	r2, r6, #0
 800214e:	f003 f857 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8002152:	23f6      	movs	r3, #246	; 0xf6
 8002154:	009b      	lsls	r3, r3, #2
 8002156:	1d21      	adds	r1, r4, #4
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8002158:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800215a:	1c32      	adds	r2, r6, #0
 800215c:	18f8      	adds	r0, r7, r3
 800215e:	4b1e      	ldr	r3, [pc, #120]	; (80021d8 <test_005_001_execute.9424+0xe8>)
 8002160:	f003 f84e 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8002164:	22a4      	movs	r2, #164	; 0xa4
 8002166:	00d2      	lsls	r2, r2, #3
 8002168:	1d61      	adds	r1, r4, #5
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800216a:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800216c:	4b1b      	ldr	r3, [pc, #108]	; (80021dc <test_005_001_execute.9424+0xec>)
 800216e:	18b8      	adds	r0, r7, r2
 8002170:	1c32      	adds	r2, r6, #0
 8002172:	f003 f845 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8002176:	2304      	movs	r3, #4
 8002178:	4642      	mov	r2, r8
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800217a:	6128      	str	r0, [r5, #16]

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 800217c:	4650      	mov	r0, sl
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 800217e:	6013      	str	r3, [r2, #0]
  {
    chMtxUnlock(&m1);
 8002180:	f7fe ff06 	bl	8000f90 <chMtxUnlock>
    test_wait_threads();
 8002184:	f7ff fd3c 	bl	8001c00 <test_wait_threads>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002188:	464a      	mov	r2, r9
 800218a:	6993      	ldr	r3, [r2, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 800218c:	4914      	ldr	r1, [pc, #80]	; (80021e0 <test_005_001_execute.9424+0xf0>)
 800218e:	6898      	ldr	r0, [r3, #8]
 8002190:	1a20      	subs	r0, r4, r0
 8002192:	4244      	negs	r4, r0
 8002194:	4160      	adcs	r0, r4
 8002196:	b2c0      	uxtb	r0, r0
 8002198:	f7fe fb8a 	bl	80008b0 <_test_assert>
 800219c:	2800      	cmp	r0, #0
 800219e:	d103      	bne.n	80021a8 <test_005_001_execute.9424+0xb8>
    test_assert_sequence("ABCDE", "invalid sequence");
 80021a0:	4810      	ldr	r0, [pc, #64]	; (80021e4 <test_005_001_execute.9424+0xf4>)
 80021a2:	4911      	ldr	r1, [pc, #68]	; (80021e8 <test_005_001_execute.9424+0xf8>)
 80021a4:	f7fe fb54 	bl	8000850 <_test_assert_sequence>
  }
}
 80021a8:	bc1c      	pop	{r2, r3, r4}
 80021aa:	4690      	mov	r8, r2
 80021ac:	4699      	mov	r9, r3
 80021ae:	46a2      	mov	sl, r4
 80021b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80021b2:	46c0      	nop			; (mov r8, r8)
 80021b4:	20000ed4 	.word	0x20000ed4
 80021b8:	20000f44 	.word	0x20000f44
 80021bc:	20000418 	.word	0x20000418
 80021c0:	20000518 	.word	0x20000518
 80021c4:	08001251 	.word	0x08001251
 80021c8:	08005e1c 	.word	0x08005e1c
 80021cc:	20000b84 	.word	0x20000b84
 80021d0:	08005e14 	.word	0x08005e14
 80021d4:	08005e08 	.word	0x08005e08
 80021d8:	08005e0c 	.word	0x08005e0c
 80021dc:	08005e04 	.word	0x08005e04
 80021e0:	08005e20 	.word	0x08005e20
 80021e4:	08005e18 	.word	0x08005e18
 80021e8:	08005df0 	.word	0x08005df0
 80021ec:	46c0      	nop			; (mov r8, r8)
 80021ee:	46c0      	nop			; (mov r8, r8)

080021f0 <test_004_006_teardown.9174>:
 * - [4.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void test_004_006_teardown(void) {
 80021f0:	b508      	push	{r3, lr}
  test_wait_threads();
 80021f2:	f7ff fd05 	bl	8001c00 <test_wait_threads>
}
 80021f6:	bd08      	pop	{r3, pc}
 80021f8:	46c0      	nop			; (mov r8, r8)
 80021fa:	46c0      	nop			; (mov r8, r8)
 80021fc:	46c0      	nop			; (mov r8, r8)
 80021fe:	46c0      	nop			; (mov r8, r8)

08002200 <test_004_005_teardown.9176>:

static void test_004_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_005_teardown(void) {
 8002200:	b508      	push	{r3, lr}
  test_wait_threads();
 8002202:	f7ff fcfd 	bl	8001c00 <test_wait_threads>
}
 8002206:	bd08      	pop	{r3, pc}
 8002208:	46c0      	nop			; (mov r8, r8)
 800220a:	46c0      	nop			; (mov r8, r8)
 800220c:	46c0      	nop			; (mov r8, r8)
 800220e:	46c0      	nop			; (mov r8, r8)

08002210 <test_004_002_execute.9178>:

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_002_execute(void) {
 8002210:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8002212:	4a2d      	ldr	r2, [pc, #180]	; (80022c8 <test_004_002_execute.9178+0xb8>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002214:	4e2d      	ldr	r6, [pc, #180]	; (80022cc <test_004_002_execute.9178+0xbc>)

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_002_execute(void) {
 8002216:	4647      	mov	r7, r8

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8002218:	2301      	movs	r3, #1

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_002_execute(void) {
 800221a:	b480      	push	{r7}

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 800221c:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800221e:	69b3      	ldr	r3, [r6, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002220:	4f2b      	ldr	r7, [pc, #172]	; (80022d0 <test_004_002_execute.9178+0xc0>)
 8002222:	4d2c      	ldr	r5, [pc, #176]	; (80022d4 <test_004_002_execute.9178+0xc4>)
 8002224:	6899      	ldr	r1, [r3, #8]
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8002226:	4690      	mov	r8, r2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002228:	1c38      	adds	r0, r7, #0
 800222a:	1c2a      	adds	r2, r5, #0
 800222c:	3105      	adds	r1, #5
 800222e:	4b2a      	ldr	r3, [pc, #168]	; (80022d8 <test_004_002_execute.9178+0xc8>)
 8002230:	f002 ffe6 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002234:	4c29      	ldr	r4, [pc, #164]	; (80022dc <test_004_002_execute.9178+0xcc>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002236:	23a4      	movs	r3, #164	; 0xa4
 8002238:	005b      	lsls	r3, r3, #1
  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800223a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800223c:	18f8      	adds	r0, r7, r3
 800223e:	69b3      	ldr	r3, [r6, #24]
 8002240:	1c2a      	adds	r2, r5, #0
 8002242:	6899      	ldr	r1, [r3, #8]
 8002244:	4b26      	ldr	r3, [pc, #152]	; (80022e0 <test_004_002_execute.9178+0xd0>)
 8002246:	3101      	adds	r1, #1
 8002248:	f002 ffda 	bl	8005200 <chThdCreateStatic.constprop.52>
 800224c:	69b3      	ldr	r3, [r6, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800224e:	22a4      	movs	r2, #164	; 0xa4
 8002250:	6899      	ldr	r1, [r3, #8]
 8002252:	0092      	lsls	r2, r2, #2
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002254:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002256:	3103      	adds	r1, #3
 8002258:	18b8      	adds	r0, r7, r2
 800225a:	4b22      	ldr	r3, [pc, #136]	; (80022e4 <test_004_002_execute.9178+0xd4>)
 800225c:	1c2a      	adds	r2, r5, #0
 800225e:	f002 ffcf 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002262:	23f6      	movs	r3, #246	; 0xf6
 8002264:	009b      	lsls	r3, r3, #2
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002266:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002268:	18f8      	adds	r0, r7, r3
 800226a:	69b3      	ldr	r3, [r6, #24]
 800226c:	1c2a      	adds	r2, r5, #0
 800226e:	6899      	ldr	r1, [r3, #8]
 8002270:	4b1d      	ldr	r3, [pc, #116]	; (80022e8 <test_004_002_execute.9178+0xd8>)
 8002272:	3104      	adds	r1, #4
 8002274:	f002 ffc4 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002278:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800227a:	22a4      	movs	r2, #164	; 0xa4
 800227c:	6899      	ldr	r1, [r3, #8]
 800227e:	00d2      	lsls	r2, r2, #3
 8002280:	3102      	adds	r1, #2
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002282:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002284:	4b19      	ldr	r3, [pc, #100]	; (80022ec <test_004_002_execute.9178+0xdc>)
 8002286:	18b8      	adds	r0, r7, r2
 8002288:	1c2a      	adds	r2, r5, #0
 800228a:	f002 ffb9 	bl	8005200 <chThdCreateStatic.constprop.52>
 800228e:	6120      	str	r0, [r4, #16]

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 8002290:	4c17      	ldr	r4, [pc, #92]	; (80022f0 <test_004_002_execute.9178+0xe0>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8002292:	4642      	mov	r2, r8
 8002294:	2302      	movs	r3, #2
  {
    chSemSignal(&sem1);
 8002296:	1c20      	adds	r0, r4, #0
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8002298:	6013      	str	r3, [r2, #0]
  {
    chSemSignal(&sem1);
 800229a:	f7fe fd11 	bl	8000cc0 <chSemSignal>
    chSemSignal(&sem1);
 800229e:	1c20      	adds	r0, r4, #0
 80022a0:	f7fe fd0e 	bl	8000cc0 <chSemSignal>
    chSemSignal(&sem1);
 80022a4:	1c20      	adds	r0, r4, #0
 80022a6:	f7fe fd0b 	bl	8000cc0 <chSemSignal>
    chSemSignal(&sem1);
 80022aa:	1c20      	adds	r0, r4, #0
 80022ac:	f7fe fd08 	bl	8000cc0 <chSemSignal>
    chSemSignal(&sem1);
 80022b0:	1c20      	adds	r0, r4, #0
 80022b2:	f7fe fd05 	bl	8000cc0 <chSemSignal>
    test_wait_threads();
 80022b6:	f7ff fca3 	bl	8001c00 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 80022ba:	490e      	ldr	r1, [pc, #56]	; (80022f4 <test_004_002_execute.9178+0xe4>)
 80022bc:	480e      	ldr	r0, [pc, #56]	; (80022f8 <test_004_002_execute.9178+0xe8>)
 80022be:	f7fe fac7 	bl	8000850 <_test_assert_sequence>
#endif
  }
}
 80022c2:	bc04      	pop	{r2}
 80022c4:	4690      	mov	r8, r2
 80022c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80022c8:	20000f44 	.word	0x20000f44
 80022cc:	20000ed4 	.word	0x20000ed4
 80022d0:	20000518 	.word	0x20000518
 80022d4:	08000df1 	.word	0x08000df1
 80022d8:	08005e04 	.word	0x08005e04
 80022dc:	20000b84 	.word	0x20000b84
 80022e0:	08005e0c 	.word	0x08005e0c
 80022e4:	08005e08 	.word	0x08005e08
 80022e8:	08005e14 	.word	0x08005e14
 80022ec:	08005e1c 	.word	0x08005e1c
 80022f0:	20000508 	.word	0x20000508
 80022f4:	08005df0 	.word	0x08005df0
 80022f8:	08005e18 	.word	0x08005e18
 80022fc:	46c0      	nop			; (mov r8, r8)
 80022fe:	46c0      	nop			; (mov r8, r8)

08002300 <test_004_004_execute.9190>:

static void test_004_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_004_execute(void) {
 8002300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8002302:	4c20      	ldr	r4, [pc, #128]	; (8002384 <test_004_004_execute.9190+0x84>)
 8002304:	2301      	movs	r3, #1
 8002306:	6023      	str	r3, [r4, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002308:	4b1f      	ldr	r3, [pc, #124]	; (8002388 <test_004_004_execute.9190+0x88>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800230a:	4e20      	ldr	r6, [pc, #128]	; (800238c <test_004_004_execute.9190+0x8c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800230c:	699b      	ldr	r3, [r3, #24]
 800230e:	4a20      	ldr	r2, [pc, #128]	; (8002390 <test_004_004_execute.9190+0x90>)
 8002310:	6899      	ldr	r1, [r3, #8]
 8002312:	4820      	ldr	r0, [pc, #128]	; (8002394 <test_004_004_execute.9190+0x94>)
 8002314:	1c33      	adds	r3, r6, #0
 8002316:	3101      	adds	r1, #1
 8002318:	f002 ff72 	bl	8005200 <chThdCreateStatic.constprop.52>
 800231c:	4b1e      	ldr	r3, [pc, #120]	; (8002398 <test_004_004_execute.9190+0x98>)
 800231e:	6018      	str	r0, [r3, #0]
  }

  /* [4.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 8002320:	2302      	movs	r3, #2
 8002322:	6023      	str	r3, [r4, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002324:	b672      	cpsid	i
 8002326:	2402      	movs	r4, #2
 8002328:	4d1c      	ldr	r5, [pc, #112]	; (800239c <test_004_004_execute.9190+0x9c>)
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 800232a:	2700      	movs	r7, #0
 800232c:	e002      	b.n	8002334 <test_004_004_execute.9190+0x34>
 800232e:	3c01      	subs	r4, #1
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002330:	2c00      	cmp	r4, #0
 8002332:	d00e      	beq.n	8002352 <test_004_004_execute.9190+0x52>
    if (++sp->cnt <= (cnt_t)0) {
 8002334:	68aa      	ldr	r2, [r5, #8]
 8002336:	3201      	adds	r2, #1
 8002338:	60aa      	str	r2, [r5, #8]
 800233a:	2a00      	cmp	r2, #0
 800233c:	dcf7      	bgt.n	800232e <test_004_004_execute.9190+0x2e>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800233e:	6828      	ldr	r0, [r5, #0]
 8002340:	3c01      	subs	r4, #1

  tqp->next             = tp->queue.next;
 8002342:	6802      	ldr	r2, [r0, #0]
 8002344:	602a      	str	r2, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002346:	6055      	str	r5, [r2, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8002348:	f7fe fd72 	bl	8000e30 <chSchReadyI>
 800234c:	6247      	str	r7, [r0, #36]	; 0x24
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800234e:	2c00      	cmp	r4, #0
 8002350:	d1f0      	bne.n	8002334 <test_004_004_execute.9190+0x34>
  {
    chSysLock();
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
 8002352:	f7fe fbb5 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002356:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 8002358:	f7ff fc52 	bl	8001c00 <test_wait_threads>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800235c:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800235e:	68a8      	ldr	r0, [r5, #8]
 8002360:	490f      	ldr	r1, [pc, #60]	; (80023a0 <test_004_004_execute.9190+0xa0>)
 8002362:	3801      	subs	r0, #1
 8002364:	4243      	negs	r3, r0
 8002366:	4158      	adcs	r0, r3
 8002368:	b2c0      	uxtb	r0, r0
 800236a:	f7fe faa1 	bl	80008b0 <_test_assert>
 800236e:	2800      	cmp	r0, #0
 8002370:	d001      	beq.n	8002376 <test_004_004_execute.9190+0x76>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002372:	b662      	cpsie	i
    test_assert_sequence("A", "invalid sequence");
  }
}
 8002374:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002376:	b662      	cpsie	i
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
    test_assert_sequence("A", "invalid sequence");
 8002378:	490a      	ldr	r1, [pc, #40]	; (80023a4 <test_004_004_execute.9190+0xa4>)
 800237a:	1c30      	adds	r0, r6, #0
 800237c:	f7fe fa68 	bl	8000850 <_test_assert_sequence>
 8002380:	e7f8      	b.n	8002374 <test_004_004_execute.9190+0x74>
 8002382:	46c0      	nop			; (mov r8, r8)
 8002384:	20000f44 	.word	0x20000f44
 8002388:	20000ed4 	.word	0x20000ed4
 800238c:	08005e04 	.word	0x08005e04
 8002390:	08000df1 	.word	0x08000df1
 8002394:	20000518 	.word	0x20000518
 8002398:	20000b84 	.word	0x20000b84
 800239c:	20000508 	.word	0x20000508
 80023a0:	08005e38 	.word	0x08005e38
 80023a4:	08005df0 	.word	0x08005df0
 80023a8:	46c0      	nop			; (mov r8, r8)
 80023aa:	46c0      	nop			; (mov r8, r8)
 80023ac:	46c0      	nop			; (mov r8, r8)
 80023ae:	46c0      	nop			; (mov r8, r8)

080023b0 <test_002_002_execute.8700>:
 * - [2.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void test_002_002_execute(void) {
 80023b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80023b2:	465f      	mov	r7, fp
 80023b4:	4656      	mov	r6, sl
 80023b6:	464d      	mov	r5, r9
 80023b8:	4644      	mov	r4, r8
 80023ba:	b4f0      	push	{r4, r5, r6, r7}

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80023bc:	4a5c      	ldr	r2, [pc, #368]	; (8002530 <test_002_002_execute.8700+0x180>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80023be:	4e5d      	ldr	r6, [pc, #372]	; (8002534 <test_002_002_execute.8700+0x184>)
 80023c0:	2301      	movs	r3, #1
 80023c2:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80023c4:	69b3      	ldr	r3, [r6, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80023c6:	4d5c      	ldr	r5, [pc, #368]	; (8002538 <test_002_002_execute.8700+0x188>)
 80023c8:	4f5c      	ldr	r7, [pc, #368]	; (800253c <test_002_002_execute.8700+0x18c>)
 80023ca:	6899      	ldr	r1, [r3, #8]

static void test_002_002_execute(void) {

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80023cc:	4693      	mov	fp, r2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80023ce:	3905      	subs	r1, #5
 80023d0:	1c2a      	adds	r2, r5, #0
 80023d2:	4b5b      	ldr	r3, [pc, #364]	; (8002540 <test_002_002_execute.8700+0x190>)
 80023d4:	1c38      	adds	r0, r7, #0
 80023d6:	f002 ff13 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80023da:	23a4      	movs	r3, #164	; 0xa4
 80023dc:	005b      	lsls	r3, r3, #1
 80023de:	19db      	adds	r3, r3, r7
 80023e0:	469a      	mov	sl, r3
 80023e2:	69b3      	ldr	r3, [r6, #24]

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80023e4:	4c57      	ldr	r4, [pc, #348]	; (8002544 <test_002_002_execute.8700+0x194>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80023e6:	6899      	ldr	r1, [r3, #8]

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80023e8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80023ea:	3904      	subs	r1, #4
 80023ec:	1c2a      	adds	r2, r5, #0
 80023ee:	4b56      	ldr	r3, [pc, #344]	; (8002548 <test_002_002_execute.8700+0x198>)
 80023f0:	4650      	mov	r0, sl
 80023f2:	f002 ff05 	bl	8005200 <chThdCreateStatic.constprop.52>
 80023f6:	69b3      	ldr	r3, [r6, #24]
 80023f8:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80023fa:	6899      	ldr	r1, [r3, #8]
 80023fc:	1c2a      	adds	r2, r5, #0
 80023fe:	3903      	subs	r1, #3
 8002400:	4b52      	ldr	r3, [pc, #328]	; (800254c <test_002_002_execute.8700+0x19c>)
 8002402:	4853      	ldr	r0, [pc, #332]	; (8002550 <test_002_002_execute.8700+0x1a0>)
 8002404:	f002 fefc 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002408:	69b3      	ldr	r3, [r6, #24]
 800240a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800240c:	6899      	ldr	r1, [r3, #8]
 800240e:	1c2a      	adds	r2, r5, #0
 8002410:	3902      	subs	r1, #2
 8002412:	4b50      	ldr	r3, [pc, #320]	; (8002554 <test_002_002_execute.8700+0x1a4>)
 8002414:	4850      	ldr	r0, [pc, #320]	; (8002558 <test_002_002_execute.8700+0x1a8>)
 8002416:	f002 fef3 	bl	8005200 <chThdCreateStatic.constprop.52>
 800241a:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800241c:	1c2a      	adds	r2, r5, #0
 800241e:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002420:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002422:	3901      	subs	r1, #1
 8002424:	4b4d      	ldr	r3, [pc, #308]	; (800255c <test_002_002_execute.8700+0x1ac>)
 8002426:	484e      	ldr	r0, [pc, #312]	; (8002560 <test_002_002_execute.8700+0x1b0>)
 8002428:	f002 feea 	bl	8005200 <chThdCreateStatic.constprop.52>
 800242c:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 800242e:	f7ff fbe7 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8002432:	4a4c      	ldr	r2, [pc, #304]	; (8002564 <test_002_002_execute.8700+0x1b4>)
 8002434:	4b4c      	ldr	r3, [pc, #304]	; (8002568 <test_002_002_execute.8700+0x1b8>)
 8002436:	1c10      	adds	r0, r2, #0
 8002438:	1c19      	adds	r1, r3, #0
 800243a:	4691      	mov	r9, r2
 800243c:	4698      	mov	r8, r3
 800243e:	f7fe fa07 	bl	8000850 <_test_assert_sequence>
 8002442:	2800      	cmp	r0, #0
 8002444:	d005      	beq.n	8002452 <test_002_002_execute.8700+0xa2>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
  }
}
 8002446:	bc3c      	pop	{r2, r3, r4, r5}
 8002448:	4690      	mov	r8, r2
 800244a:	4699      	mov	r9, r3
 800244c:	46a2      	mov	sl, r4
 800244e:	46ab      	mov	fp, r5
 8002450:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [2.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8002452:	2302      	movs	r3, #2
 8002454:	465a      	mov	r2, fp
 8002456:	6013      	str	r3, [r2, #0]
 8002458:	69b3      	ldr	r3, [r6, #24]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800245a:	1c2a      	adds	r2, r5, #0
 800245c:	6899      	ldr	r1, [r3, #8]
 800245e:	4840      	ldr	r0, [pc, #256]	; (8002560 <test_002_002_execute.8700+0x1b0>)
 8002460:	3901      	subs	r1, #1
 8002462:	4b3e      	ldr	r3, [pc, #248]	; (800255c <test_002_002_execute.8700+0x1ac>)
 8002464:	f002 fecc 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002468:	69b3      	ldr	r3, [r6, #24]
 800246a:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800246c:	6899      	ldr	r1, [r3, #8]
 800246e:	1c2a      	adds	r2, r5, #0
 8002470:	3902      	subs	r1, #2
 8002472:	4b38      	ldr	r3, [pc, #224]	; (8002554 <test_002_002_execute.8700+0x1a4>)
 8002474:	4838      	ldr	r0, [pc, #224]	; (8002558 <test_002_002_execute.8700+0x1a8>)
 8002476:	f002 fec3 	bl	8005200 <chThdCreateStatic.constprop.52>
 800247a:	69b3      	ldr	r3, [r6, #24]
 800247c:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800247e:	6899      	ldr	r1, [r3, #8]
 8002480:	1c2a      	adds	r2, r5, #0
 8002482:	3903      	subs	r1, #3
 8002484:	4b31      	ldr	r3, [pc, #196]	; (800254c <test_002_002_execute.8700+0x19c>)
 8002486:	4832      	ldr	r0, [pc, #200]	; (8002550 <test_002_002_execute.8700+0x1a0>)
 8002488:	f002 feba 	bl	8005200 <chThdCreateStatic.constprop.52>
 800248c:	69b3      	ldr	r3, [r6, #24]
 800248e:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002490:	6899      	ldr	r1, [r3, #8]
 8002492:	1c2a      	adds	r2, r5, #0
 8002494:	3904      	subs	r1, #4
 8002496:	4b2c      	ldr	r3, [pc, #176]	; (8002548 <test_002_002_execute.8700+0x198>)
 8002498:	4650      	mov	r0, sl
 800249a:	f002 feb1 	bl	8005200 <chThdCreateStatic.constprop.52>
 800249e:	69b3      	ldr	r3, [r6, #24]
 80024a0:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80024a2:	6899      	ldr	r1, [r3, #8]
 80024a4:	1c2a      	adds	r2, r5, #0
 80024a6:	3905      	subs	r1, #5
 80024a8:	4b25      	ldr	r3, [pc, #148]	; (8002540 <test_002_002_execute.8700+0x190>)
 80024aa:	1c38      	adds	r0, r7, #0
 80024ac:	f002 fea8 	bl	8005200 <chThdCreateStatic.constprop.52>
 80024b0:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 80024b2:	f7ff fba5 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80024b6:	4648      	mov	r0, r9
 80024b8:	4641      	mov	r1, r8
 80024ba:	f7fe f9c9 	bl	8000850 <_test_assert_sequence>
 80024be:	2800      	cmp	r0, #0
 80024c0:	d1c1      	bne.n	8002446 <test_002_002_execute.8700+0x96>
  }

  /* [2.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 80024c2:	465a      	mov	r2, fp
 80024c4:	2303      	movs	r3, #3
 80024c6:	6013      	str	r3, [r2, #0]
 80024c8:	69b3      	ldr	r3, [r6, #24]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80024ca:	1c2a      	adds	r2, r5, #0
 80024cc:	6899      	ldr	r1, [r3, #8]
 80024ce:	4650      	mov	r0, sl
 80024d0:	3904      	subs	r1, #4
 80024d2:	4b1d      	ldr	r3, [pc, #116]	; (8002548 <test_002_002_execute.8700+0x198>)
 80024d4:	f002 fe94 	bl	8005200 <chThdCreateStatic.constprop.52>
 80024d8:	69b3      	ldr	r3, [r6, #24]
 80024da:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80024dc:	6899      	ldr	r1, [r3, #8]
 80024de:	1c2a      	adds	r2, r5, #0
 80024e0:	3905      	subs	r1, #5
 80024e2:	1c38      	adds	r0, r7, #0
 80024e4:	4b16      	ldr	r3, [pc, #88]	; (8002540 <test_002_002_execute.8700+0x190>)
 80024e6:	f002 fe8b 	bl	8005200 <chThdCreateStatic.constprop.52>
 80024ea:	69b3      	ldr	r3, [r6, #24]
 80024ec:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80024ee:	6899      	ldr	r1, [r3, #8]
 80024f0:	1c2a      	adds	r2, r5, #0
 80024f2:	3901      	subs	r1, #1
 80024f4:	4b19      	ldr	r3, [pc, #100]	; (800255c <test_002_002_execute.8700+0x1ac>)
 80024f6:	481a      	ldr	r0, [pc, #104]	; (8002560 <test_002_002_execute.8700+0x1b0>)
 80024f8:	f002 fe82 	bl	8005200 <chThdCreateStatic.constprop.52>
 80024fc:	69b3      	ldr	r3, [r6, #24]
 80024fe:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002500:	6899      	ldr	r1, [r3, #8]
 8002502:	1c2a      	adds	r2, r5, #0
 8002504:	3902      	subs	r1, #2
 8002506:	4b13      	ldr	r3, [pc, #76]	; (8002554 <test_002_002_execute.8700+0x1a4>)
 8002508:	4813      	ldr	r0, [pc, #76]	; (8002558 <test_002_002_execute.8700+0x1a8>)
 800250a:	f002 fe79 	bl	8005200 <chThdCreateStatic.constprop.52>
 800250e:	69b3      	ldr	r3, [r6, #24]
 8002510:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8002512:	6899      	ldr	r1, [r3, #8]
 8002514:	1c2a      	adds	r2, r5, #0
 8002516:	3903      	subs	r1, #3
 8002518:	4b0c      	ldr	r3, [pc, #48]	; (800254c <test_002_002_execute.8700+0x19c>)
 800251a:	480d      	ldr	r0, [pc, #52]	; (8002550 <test_002_002_execute.8700+0x1a0>)
 800251c:	f002 fe70 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002520:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 8002522:	f7ff fb6d 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8002526:	4648      	mov	r0, r9
 8002528:	4641      	mov	r1, r8
 800252a:	f7fe f991 	bl	8000850 <_test_assert_sequence>
 800252e:	e78a      	b.n	8002446 <test_002_002_execute.8700+0x96>
 8002530:	20000f44 	.word	0x20000f44
 8002534:	20000ed4 	.word	0x20000ed4
 8002538:	08000651 	.word	0x08000651
 800253c:	20000518 	.word	0x20000518
 8002540:	08005e1c 	.word	0x08005e1c
 8002544:	20000b84 	.word	0x20000b84
 8002548:	08005e14 	.word	0x08005e14
 800254c:	08005e08 	.word	0x08005e08
 8002550:	200007a8 	.word	0x200007a8
 8002554:	08005e0c 	.word	0x08005e0c
 8002558:	200008f0 	.word	0x200008f0
 800255c:	08005e04 	.word	0x08005e04
 8002560:	20000a38 	.word	0x20000a38
 8002564:	08005e18 	.word	0x08005e18
 8002568:	08005df0 	.word	0x08005df0
 800256c:	46c0      	nop			; (mov r8, r8)
 800256e:	46c0      	nop			; (mov r8, r8)

08002570 <iqGetTimeout.4263>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8002570:	b538      	push	{r3, r4, r5, lr}
 8002572:	1c04      	adds	r4, r0, #0
 8002574:	1c0d      	adds	r5, r1, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002576:	b672      	cpsid	i
 8002578:	e005      	b.n	8002586 <iqGetTimeout.4263+0x16>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800257a:	1c20      	adds	r0, r4, #0
 800257c:	1c29      	adds	r1, r5, #0
 800257e:	f002 fdc7 	bl	8005110 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8002582:	2800      	cmp	r0, #0
 8002584:	db16      	blt.n	80025b4 <iqGetTimeout.4263+0x44>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8002586:	68a3      	ldr	r3, [r4, #8]
 8002588:	2b00      	cmp	r3, #0
 800258a:	d0f6      	beq.n	800257a <iqGetTimeout.4263+0xa>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800258c:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800258e:	69a2      	ldr	r2, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8002590:	3b01      	subs	r3, #1
 8002592:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8002594:	1c53      	adds	r3, r2, #1
 8002596:	61a3      	str	r3, [r4, #24]
 8002598:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 800259a:	6922      	ldr	r2, [r4, #16]
 800259c:	4293      	cmp	r3, r2
 800259e:	d301      	bcc.n	80025a4 <iqGetTimeout.4263+0x34>
    iqp->q_rdptr = iqp->q_buffer;
 80025a0:	68e3      	ldr	r3, [r4, #12]
 80025a2:	61a3      	str	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80025a4:	69e3      	ldr	r3, [r4, #28]
 80025a6:	2b00      	cmp	r3, #0
 80025a8:	d001      	beq.n	80025ae <iqGetTimeout.4263+0x3e>
    iqp->q_notify(iqp);
 80025aa:	1c20      	adds	r0, r4, #0
 80025ac:	4798      	blx	r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80025ae:	b662      	cpsie	i
  }

  osalSysUnlock();

  return (msg_t)b;
 80025b0:	1c28      	adds	r0, r5, #0
}
 80025b2:	bd38      	pop	{r3, r4, r5, pc}
 80025b4:	b662      	cpsie	i
 80025b6:	e7fc      	b.n	80025b2 <iqGetTimeout.4263+0x42>
 80025b8:	46c0      	nop			; (mov r8, r8)
 80025ba:	46c0      	nop			; (mov r8, r8)
 80025bc:	46c0      	nop			; (mov r8, r8)
 80025be:	46c0      	nop			; (mov r8, r8)

080025c0 <gett.7636>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 80025c0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80025c2:	300c      	adds	r0, #12
 80025c4:	f7ff ffd4 	bl	8002570 <iqGetTimeout.4263>
}
 80025c8:	bd08      	pop	{r3, pc}
 80025ca:	46c0      	nop			; (mov r8, r8)
 80025cc:	46c0      	nop			; (mov r8, r8)
 80025ce:	46c0      	nop			; (mov r8, r8)

080025d0 <get.7640>:
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 80025d0:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80025d2:	300c      	adds	r0, #12
 80025d4:	4901      	ldr	r1, [pc, #4]	; (80025dc <get.7640+0xc>)
 80025d6:	f7ff ffcb 	bl	8002570 <iqGetTimeout.4263>
}
 80025da:	bd08      	pop	{r3, pc}
 80025dc:	0000ffff 	.word	0x0000ffff

080025e0 <iqReadTimeout.4296>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80025e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025e2:	4656      	mov	r6, sl
 80025e4:	464d      	mov	r5, r9
 80025e6:	4644      	mov	r4, r8
 80025e8:	465f      	mov	r7, fp
 80025ea:	b4f0      	push	{r4, r5, r6, r7}
 80025ec:	1c15      	adds	r5, r2, #0
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80025ee:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80025f0:	b083      	sub	sp, #12
 80025f2:	1c04      	adds	r4, r0, #0
 80025f4:	1c0e      	adds	r6, r1, #0
 80025f6:	469a      	mov	sl, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80025f8:	4691      	mov	r9, r2
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025fa:	b672      	cpsid	i
 80025fc:	4b24      	ldr	r3, [pc, #144]	; (8002690 <iqReadTimeout.4296+0xb0>)
  size_t r = 0;
 80025fe:	2700      	movs	r7, #0
 8002600:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8002602:	4453      	add	r3, sl
 8002604:	b29b      	uxth	r3, r3
 8002606:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8002608:	4653      	mov	r3, sl
 800260a:	3b01      	subs	r3, #1
 800260c:	b29b      	uxth	r3, r3
 800260e:	469b      	mov	fp, r3
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8002610:	68a3      	ldr	r3, [r4, #8]
 8002612:	2b00      	cmp	r3, #0
 8002614:	d01e      	beq.n	8002654 <iqReadTimeout.4296+0x74>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8002616:	68a3      	ldr	r3, [r4, #8]
 8002618:	3b01      	subs	r3, #1
 800261a:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800261c:	1c73      	adds	r3, r6, #1
 800261e:	4698      	mov	r8, r3
 8002620:	69a3      	ldr	r3, [r4, #24]
 8002622:	1c5a      	adds	r2, r3, #1
 8002624:	61a2      	str	r2, [r4, #24]
 8002626:	781b      	ldrb	r3, [r3, #0]
 8002628:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800262a:	69a2      	ldr	r2, [r4, #24]
 800262c:	6923      	ldr	r3, [r4, #16]
 800262e:	429a      	cmp	r2, r3
 8002630:	d301      	bcc.n	8002636 <iqReadTimeout.4296+0x56>
      iqp->q_rdptr = iqp->q_buffer;
 8002632:	68e2      	ldr	r2, [r4, #12]
 8002634:	61a2      	str	r2, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8002636:	464b      	mov	r3, r9
 8002638:	2b00      	cmp	r3, #0
 800263a:	d001      	beq.n	8002640 <iqReadTimeout.4296+0x60>
      nfy(iqp);
 800263c:	1c20      	adds	r0, r4, #0
 800263e:	47c8      	blx	r9
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002640:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 8002642:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8002644:	3701      	adds	r7, #1
    if (--n == 0U) {
 8002646:	2d00      	cmp	r5, #0
 8002648:	d014      	beq.n	8002674 <iqReadTimeout.4296+0x94>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800264a:	b672      	cpsid	i
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800264c:	68a3      	ldr	r3, [r4, #8]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800264e:	4646      	mov	r6, r8
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8002650:	2b00      	cmp	r3, #0
 8002652:	d1e0      	bne.n	8002616 <iqReadTimeout.4296+0x36>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8002654:	4b0f      	ldr	r3, [pc, #60]	; (8002694 <iqReadTimeout.4296+0xb4>)
 8002656:	459b      	cmp	fp, r3
 8002658:	d814      	bhi.n	8002684 <iqReadTimeout.4296+0xa4>
 800265a:	4b0d      	ldr	r3, [pc, #52]	; (8002690 <iqReadTimeout.4296+0xb0>)
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800265c:	9a01      	ldr	r2, [sp, #4]
 800265e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8002660:	1a51      	subs	r1, r2, r1
 8002662:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8002664:	458a      	cmp	sl, r1
 8002666:	d304      	bcc.n	8002672 <iqReadTimeout.4296+0x92>
 8002668:	1c20      	adds	r0, r4, #0
 800266a:	f002 fd51 	bl	8005110 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800266e:	2800      	cmp	r0, #0
 8002670:	d0ce      	beq.n	8002610 <iqReadTimeout.4296+0x30>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002672:	b662      	cpsie	i
      return r;
    }

    osalSysLock();
  }
}
 8002674:	1c38      	adds	r0, r7, #0
 8002676:	b003      	add	sp, #12
 8002678:	bc3c      	pop	{r2, r3, r4, r5}
 800267a:	4690      	mov	r8, r2
 800267c:	4699      	mov	r9, r3
 800267e:	46a2      	mov	sl, r4
 8002680:	46ab      	mov	fp, r5
 8002682:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002684:	1c20      	adds	r0, r4, #0
 8002686:	4651      	mov	r1, sl
 8002688:	f002 fd42 	bl	8005110 <chThdEnqueueTimeoutS>
 800268c:	e7ef      	b.n	800266e <iqReadTimeout.4296+0x8e>
 800268e:	46c0      	nop			; (mov r8, r8)
 8002690:	40000400 	.word	0x40000400
 8002694:	0000fffd 	.word	0x0000fffd
 8002698:	46c0      	nop			; (mov r8, r8)
 800269a:	46c0      	nop			; (mov r8, r8)
 800269c:	46c0      	nop			; (mov r8, r8)
 800269e:	46c0      	nop			; (mov r8, r8)

080026a0 <readt.7611>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 80026a0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80026a2:	300c      	adds	r0, #12
 80026a4:	f7ff ff9c 	bl	80025e0 <iqReadTimeout.4296>
}
 80026a8:	bd08      	pop	{r3, pc}
 80026aa:	46c0      	nop			; (mov r8, r8)
 80026ac:	46c0      	nop			; (mov r8, r8)
 80026ae:	46c0      	nop			; (mov r8, r8)

080026b0 <read.7620>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80026b0:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80026b2:	300c      	adds	r0, #12
 80026b4:	4b01      	ldr	r3, [pc, #4]	; (80026bc <read.7620+0xc>)
 80026b6:	f7ff ff93 	bl	80025e0 <iqReadTimeout.4296>
                       n, TIME_INFINITE);
}
 80026ba:	bd08      	pop	{r3, pc}
 80026bc:	0000ffff 	.word	0x0000ffff

080026c0 <oqPutTimeout.4311>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80026c0:	b570      	push	{r4, r5, r6, lr}
 80026c2:	1c04      	adds	r4, r0, #0
 80026c4:	1c0e      	adds	r6, r1, #0
 80026c6:	1c15      	adds	r5, r2, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80026c8:	b672      	cpsid	i
 80026ca:	e005      	b.n	80026d8 <oqPutTimeout.4311+0x18>
 80026cc:	1c20      	adds	r0, r4, #0
 80026ce:	1c29      	adds	r1, r5, #0
 80026d0:	f002 fd1e 	bl	8005110 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80026d4:	2800      	cmp	r0, #0
 80026d6:	db17      	blt.n	8002708 <oqPutTimeout.4311+0x48>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80026d8:	68a3      	ldr	r3, [r4, #8]
 80026da:	2b00      	cmp	r3, #0
 80026dc:	d0f6      	beq.n	80026cc <oqPutTimeout.4311+0xc>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80026de:	68a3      	ldr	r3, [r4, #8]
 80026e0:	3b01      	subs	r3, #1
 80026e2:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80026e4:	6963      	ldr	r3, [r4, #20]
 80026e6:	1c5a      	adds	r2, r3, #1
 80026e8:	6162      	str	r2, [r4, #20]
 80026ea:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80026ec:	6962      	ldr	r2, [r4, #20]
 80026ee:	6923      	ldr	r3, [r4, #16]
 80026f0:	429a      	cmp	r2, r3
 80026f2:	d301      	bcc.n	80026f8 <oqPutTimeout.4311+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 80026f4:	68e2      	ldr	r2, [r4, #12]
 80026f6:	6162      	str	r2, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80026f8:	69e3      	ldr	r3, [r4, #28]
 80026fa:	2b00      	cmp	r3, #0
 80026fc:	d001      	beq.n	8002702 <oqPutTimeout.4311+0x42>
    oqp->q_notify(oqp);
 80026fe:	1c20      	adds	r0, r4, #0
 8002700:	4798      	blx	r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002702:	b662      	cpsie	i
 8002704:	2000      	movs	r0, #0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8002706:	bd70      	pop	{r4, r5, r6, pc}
 8002708:	b662      	cpsie	i
 800270a:	e7fc      	b.n	8002706 <oqPutTimeout.4311+0x46>
 800270c:	46c0      	nop			; (mov r8, r8)
 800270e:	46c0      	nop			; (mov r8, r8)

08002710 <putt.7643>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8002710:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8002712:	3030      	adds	r0, #48	; 0x30
 8002714:	f7ff ffd4 	bl	80026c0 <oqPutTimeout.4311>
}
 8002718:	bd08      	pop	{r3, pc}
 800271a:	46c0      	nop			; (mov r8, r8)
 800271c:	46c0      	nop			; (mov r8, r8)
 800271e:	46c0      	nop			; (mov r8, r8)

08002720 <put.7648>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8002720:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8002722:	3030      	adds	r0, #48	; 0x30
 8002724:	4a01      	ldr	r2, [pc, #4]	; (800272c <put.7648+0xc>)
 8002726:	f7ff ffcb 	bl	80026c0 <oqPutTimeout.4311>
}
 800272a:	bd08      	pop	{r3, pc}
 800272c:	0000ffff 	.word	0x0000ffff

08002730 <writet.7625>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8002730:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8002732:	3030      	adds	r0, #48	; 0x30
 8002734:	f002 fd04 	bl	8005140 <oqWriteTimeout>
}
 8002738:	bd08      	pop	{r3, pc}
 800273a:	46c0      	nop			; (mov r8, r8)
 800273c:	46c0      	nop			; (mov r8, r8)
 800273e:	46c0      	nop			; (mov r8, r8)

08002740 <write.7631>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8002740:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8002742:	3030      	adds	r0, #48	; 0x30
 8002744:	4b01      	ldr	r3, [pc, #4]	; (800274c <write.7631+0xc>)
 8002746:	f002 fcfb 	bl	8005140 <oqWriteTimeout>
                        n, TIME_INFINITE);
}
 800274a:	bd08      	pop	{r3, pc}
 800274c:	0000ffff 	.word	0x0000ffff

08002750 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8002750:	b510      	push	{r4, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8002752:	6884      	ldr	r4, [r0, #8]
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8002754:	1c03      	adds	r3, r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8002756:	1e62      	subs	r2, r4, #1
 8002758:	6082      	str	r2, [r0, #8]
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 800275a:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 800275c:	2a00      	cmp	r2, #0
 800275e:	db00      	blt.n	8002762 <chSemWaitTimeoutS+0x12>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8002760:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8002762:	2900      	cmp	r1, #0
 8002764:	d00b      	beq.n	800277e <chSemWaitTimeoutS+0x2e>
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8002766:	4a08      	ldr	r2, [pc, #32]	; (8002788 <chSemWaitTimeoutS+0x38>)
 8002768:	6992      	ldr	r2, [r2, #24]
 800276a:	6253      	str	r3, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800276c:	6858      	ldr	r0, [r3, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 800276e:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = tqp->prev;
 8002770:	6050      	str	r0, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8002772:	6002      	str	r2, [r0, #0]
  tqp->prev                  = tp;
 8002774:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8002776:	2005      	movs	r0, #5
 8002778:	f002 fca2 	bl	80050c0 <chSchGoSleepTimeoutS>
 800277c:	e7f0      	b.n	8002760 <chSemWaitTimeoutS+0x10>

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;

      return MSG_TIMEOUT;
 800277e:	2001      	movs	r0, #1
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;
 8002780:	609c      	str	r4, [r3, #8]

      return MSG_TIMEOUT;
 8002782:	4240      	negs	r0, r0
 8002784:	e7ec      	b.n	8002760 <chSemWaitTimeoutS+0x10>
 8002786:	46c0      	nop			; (mov r8, r8)
 8002788:	20000ed4 	.word	0x20000ed4
 800278c:	46c0      	nop			; (mov r8, r8)
 800278e:	46c0      	nop			; (mov r8, r8)

08002790 <chGuardedPoolAllocTimeout.constprop.12>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 8002790:	b510      	push	{r4, lr}
 8002792:	1c01      	adds	r1, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002794:	b672      	cpsid	i
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8002796:	4c0b      	ldr	r4, [pc, #44]	; (80027c4 <chGuardedPoolAllocTimeout.constprop.12+0x34>)
 8002798:	1c20      	adds	r0, r4, #0
 800279a:	f7ff ffd9 	bl	8002750 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 800279e:	2800      	cmp	r0, #0
 80027a0:	d106      	bne.n	80027b0 <chGuardedPoolAllocTimeout.constprop.12+0x20>
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 80027a2:	68e0      	ldr	r0, [r4, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80027a4:	2800      	cmp	r0, #0
 80027a6:	d005      	beq.n	80027b4 <chGuardedPoolAllocTimeout.constprop.12+0x24>
    mp->next = mp->next->next;
 80027a8:	6803      	ldr	r3, [r0, #0]
 80027aa:	60e3      	str	r3, [r4, #12]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80027ac:	b662      	cpsie	i
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 80027ae:	bd10      	pop	{r4, pc}
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
    return NULL;
 80027b0:	2000      	movs	r0, #0
 80027b2:	e7fb      	b.n	80027ac <chGuardedPoolAllocTimeout.constprop.12+0x1c>
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 80027b4:	6963      	ldr	r3, [r4, #20]
 80027b6:	2b00      	cmp	r3, #0
 80027b8:	d0fa      	beq.n	80027b0 <chGuardedPoolAllocTimeout.constprop.12+0x20>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 80027ba:	6920      	ldr	r0, [r4, #16]
 80027bc:	2104      	movs	r1, #4
 80027be:	4798      	blx	r3
 80027c0:	e7f4      	b.n	80027ac <chGuardedPoolAllocTimeout.constprop.12+0x1c>
 80027c2:	46c0      	nop			; (mov r8, r8)
 80027c4:	20000464 	.word	0x20000464
 80027c8:	46c0      	nop			; (mov r8, r8)
 80027ca:	46c0      	nop			; (mov r8, r8)
 80027cc:	46c0      	nop			; (mov r8, r8)
 80027ce:	46c0      	nop			; (mov r8, r8)

080027d0 <test_009_003_execute.10162>:

static void test_009_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_003_execute(void) {
 80027d0:	b508      	push	{r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 80027d2:	4b06      	ldr	r3, [pc, #24]	; (80027ec <test_009_003_execute.10162+0x1c>)
 80027d4:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 80027d6:	2064      	movs	r0, #100	; 0x64

static void test_009_003_execute(void) {

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 80027d8:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 80027da:	f7ff ffd9 	bl	8002790 <chGuardedPoolAllocTimeout.constprop.12>
 80027de:	4243      	negs	r3, r0
 80027e0:	4158      	adcs	r0, r3
 80027e2:	b2c0      	uxtb	r0, r0
 80027e4:	4902      	ldr	r1, [pc, #8]	; (80027f0 <test_009_003_execute.10162+0x20>)
 80027e6:	f7fe f863 	bl	80008b0 <_test_assert>
  }
}
 80027ea:	bd08      	pop	{r3, pc}
 80027ec:	20000f44 	.word	0x20000f44
 80027f0:	08005e48 	.word	0x08005e48
 80027f4:	46c0      	nop			; (mov r8, r8)
 80027f6:	46c0      	nop			; (mov r8, r8)
 80027f8:	46c0      	nop			; (mov r8, r8)
 80027fa:	46c0      	nop			; (mov r8, r8)
 80027fc:	46c0      	nop			; (mov r8, r8)
 80027fe:	46c0      	nop			; (mov r8, r8)

08002800 <chMBPost.constprop.21>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002800:	b570      	push	{r4, r5, r6, lr}
 8002802:	1c06      	adds	r6, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002804:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 8002806:	4d0d      	ldr	r5, [pc, #52]	; (800283c <chMBPost.constprop.21+0x3c>)
 8002808:	1c28      	adds	r0, r5, #0
 800280a:	f7ff ffa1 	bl	8002750 <chSemWaitTimeoutS>
 800280e:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 8002810:	d10d      	bne.n	800282e <chMBPost.constprop.21+0x2e>
    *mbp->wrptr++ = msg;
 8002812:	1c2b      	adds	r3, r5, #0
 8002814:	3b1c      	subs	r3, #28
 8002816:	6899      	ldr	r1, [r3, #8]
 8002818:	1d0a      	adds	r2, r1, #4
 800281a:	609a      	str	r2, [r3, #8]
 800281c:	600e      	str	r6, [r1, #0]
    if (mbp->wrptr >= mbp->top) {
 800281e:	6859      	ldr	r1, [r3, #4]
 8002820:	428a      	cmp	r2, r1
 8002822:	d207      	bcs.n	8002834 <chMBPost.constprop.21+0x34>
      mbp->wrptr = mbp->buffer;
    }
    chSemSignalI(&mbp->fullsem);
 8002824:	4806      	ldr	r0, [pc, #24]	; (8002840 <chMBPost.constprop.21+0x40>)
 8002826:	f7fe ff83 	bl	8001730 <chSemSignalI>
    chSchRescheduleS();
 800282a:	f7fe f949 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800282e:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002830:	1c20      	adds	r0, r4, #0
 8002832:	bd70      	pop	{r4, r5, r6, pc}

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->wrptr++ = msg;
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
 8002834:	681a      	ldr	r2, [r3, #0]
 8002836:	609a      	str	r2, [r3, #8]
 8002838:	e7f4      	b.n	8002824 <chMBPost.constprop.21+0x24>
 800283a:	46c0      	nop			; (mov r8, r8)
 800283c:	20000448 	.word	0x20000448
 8002840:	2000043c 	.word	0x2000043c
 8002844:	46c0      	nop			; (mov r8, r8)
 8002846:	46c0      	nop			; (mov r8, r8)
 8002848:	46c0      	nop			; (mov r8, r8)
 800284a:	46c0      	nop			; (mov r8, r8)
 800284c:	46c0      	nop			; (mov r8, r8)
 800284e:	46c0      	nop			; (mov r8, r8)

08002850 <chMBPostAhead.constprop.19>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002850:	b570      	push	{r4, r5, r6, lr}
 8002852:	1c06      	adds	r6, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002854:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 8002856:	4d0d      	ldr	r5, [pc, #52]	; (800288c <chMBPostAhead.constprop.19+0x3c>)
 8002858:	1c28      	adds	r0, r5, #0
 800285a:	f7ff ff79 	bl	8002750 <chSemWaitTimeoutS>
 800285e:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 8002860:	d10d      	bne.n	800287e <chMBPostAhead.constprop.19+0x2e>
    if (--mbp->rdptr < mbp->buffer) {
 8002862:	1c2a      	adds	r2, r5, #0
 8002864:	3a1c      	subs	r2, #28
 8002866:	68d3      	ldr	r3, [r2, #12]
 8002868:	6811      	ldr	r1, [r2, #0]
 800286a:	3b04      	subs	r3, #4
 800286c:	60d3      	str	r3, [r2, #12]
 800286e:	428b      	cmp	r3, r1
 8002870:	d308      	bcc.n	8002884 <chMBPostAhead.constprop.19+0x34>
      mbp->rdptr = mbp->top - 1;
    }
    *mbp->rdptr = msg;
 8002872:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->fullsem);
 8002874:	4806      	ldr	r0, [pc, #24]	; (8002890 <chMBPostAhead.constprop.19+0x40>)
 8002876:	f7fe ff5b 	bl	8001730 <chSemSignalI>
    chSchRescheduleS();
 800287a:	f7fe f921 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800287e:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002880:	1c20      	adds	r0, r4, #0
 8002882:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->rdptr < mbp->buffer) {
      mbp->rdptr = mbp->top - 1;
 8002884:	6853      	ldr	r3, [r2, #4]
 8002886:	3b04      	subs	r3, #4
 8002888:	60d3      	str	r3, [r2, #12]
 800288a:	e7f2      	b.n	8002872 <chMBPostAhead.constprop.19+0x22>
 800288c:	20000448 	.word	0x20000448
 8002890:	2000043c 	.word	0x2000043c
 8002894:	46c0      	nop			; (mov r8, r8)
 8002896:	46c0      	nop			; (mov r8, r8)
 8002898:	46c0      	nop			; (mov r8, r8)
 800289a:	46c0      	nop			; (mov r8, r8)
 800289c:	46c0      	nop			; (mov r8, r8)
 800289e:	46c0      	nop			; (mov r8, r8)

080028a0 <chMBFetch.constprop.17>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80028a0:	b570      	push	{r4, r5, r6, lr}
 80028a2:	1c06      	adds	r6, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80028a4:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
 80028a6:	4d0d      	ldr	r5, [pc, #52]	; (80028dc <chMBFetch.constprop.17+0x3c>)
 80028a8:	1c28      	adds	r0, r5, #0
 80028aa:	f7ff ff51 	bl	8002750 <chSemWaitTimeoutS>
 80028ae:	1e04      	subs	r4, r0, #0
  if (rdymsg == MSG_OK) {
 80028b0:	d10e      	bne.n	80028d0 <chMBFetch.constprop.17+0x30>
    *msgp = *mbp->rdptr++;
 80028b2:	1c2b      	adds	r3, r5, #0
 80028b4:	3b10      	subs	r3, #16
 80028b6:	68d9      	ldr	r1, [r3, #12]
 80028b8:	1d0a      	adds	r2, r1, #4
 80028ba:	6809      	ldr	r1, [r1, #0]
 80028bc:	60da      	str	r2, [r3, #12]
 80028be:	6031      	str	r1, [r6, #0]
    if (mbp->rdptr >= mbp->top) {
 80028c0:	6859      	ldr	r1, [r3, #4]
 80028c2:	428a      	cmp	r2, r1
 80028c4:	d207      	bcs.n	80028d6 <chMBFetch.constprop.17+0x36>
      mbp->rdptr = mbp->buffer;
    }
    chSemSignalI(&mbp->emptysem);
 80028c6:	4806      	ldr	r0, [pc, #24]	; (80028e0 <chMBFetch.constprop.17+0x40>)
 80028c8:	f7fe ff32 	bl	8001730 <chSemSignalI>
    chSchRescheduleS();
 80028cc:	f7fe f8f8 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80028d0:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 80028d2:	1c20      	adds	r0, r4, #0
 80028d4:	bd70      	pop	{r4, r5, r6, pc}

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
 80028d6:	681a      	ldr	r2, [r3, #0]
 80028d8:	60da      	str	r2, [r3, #12]
 80028da:	e7f4      	b.n	80028c6 <chMBFetch.constprop.17+0x26>
 80028dc:	2000043c 	.word	0x2000043c
 80028e0:	20000448 	.word	0x20000448
 80028e4:	46c0      	nop			; (mov r8, r8)
 80028e6:	46c0      	nop			; (mov r8, r8)
 80028e8:	46c0      	nop			; (mov r8, r8)
 80028ea:	46c0      	nop			; (mov r8, r8)
 80028ec:	46c0      	nop			; (mov r8, r8)
 80028ee:	46c0      	nop			; (mov r8, r8)

080028f0 <test_008_001_execute.10019>:

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 80028f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80028f2:	464d      	mov	r5, r9
 80028f4:	465f      	mov	r7, fp
 80028f6:	4656      	mov	r6, sl
 80028f8:	4644      	mov	r4, r8
 80028fa:	b4f0      	push	{r4, r5, r6, r7}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80028fc:	4d86      	ldr	r5, [pc, #536]	; (8002b18 <test_008_001_execute.10019+0x228>)
 80028fe:	2301      	movs	r3, #1

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 8002900:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 8002902:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002904:	b672      	cpsid	i
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->emptysem);
 8002906:	4c85      	ldr	r4, [pc, #532]	; (8002b1c <test_008_001_execute.10019+0x22c>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8002908:	4985      	ldr	r1, [pc, #532]	; (8002b20 <test_008_001_execute.10019+0x230>)
 800290a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800290c:	3804      	subs	r0, #4
 800290e:	4243      	negs	r3, r0
 8002910:	4158      	adcs	r0, r3
 8002912:	b2c0      	uxtb	r0, r0
 8002914:	f7fd ffcc 	bl	80008b0 <_test_assert>
 8002918:	2800      	cmp	r0, #0
 800291a:	d007      	beq.n	800292c <test_008_001_execute.10019+0x3c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800291c:	b662      	cpsie	i
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 800291e:	b003      	add	sp, #12
 8002920:	bc3c      	pop	{r2, r3, r4, r5}
 8002922:	4690      	mov	r8, r2
 8002924:	4699      	mov	r9, r3
 8002926:	46a2      	mov	sl, r4
 8002928:	46ab      	mov	fp, r5
 800292a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800292c:	b662      	cpsie	i
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 800292e:	2302      	movs	r3, #2
 8002930:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 8002932:	f7fe ff45 	bl	80017c0 <chMBReset.constprop.22>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002936:	b672      	cpsid	i
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8002938:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800293a:	4e7a      	ldr	r6, [pc, #488]	; (8002b24 <test_008_001_execute.10019+0x234>)
 800293c:	3804      	subs	r0, #4
 800293e:	4243      	negs	r3, r0
 8002940:	4158      	adcs	r0, r3
 8002942:	b2c0      	uxtb	r0, r0
 8002944:	1c31      	adds	r1, r6, #0
 8002946:	f7fd ffb3 	bl	80008b0 <_test_assert>
 800294a:	2800      	cmp	r0, #0
 800294c:	d1e6      	bne.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800294e:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002950:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8002952:	69a2      	ldr	r2, [r4, #24]
 8002954:	4f74      	ldr	r7, [pc, #464]	; (8002b28 <test_008_001_execute.10019+0x238>)
 8002956:	4250      	negs	r0, r2
 8002958:	4150      	adcs	r0, r2
 800295a:	b2c0      	uxtb	r0, r0
 800295c:	1c39      	adds	r1, r7, #0
 800295e:	f7fd ffa7 	bl	80008b0 <_test_assert>
 8002962:	2800      	cmp	r0, #0
 8002964:	d1da      	bne.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002966:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002968:	b672      	cpsid	i
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800296a:	6823      	ldr	r3, [r4, #0]
 800296c:	68a2      	ldr	r2, [r4, #8]
 800296e:	1a98      	subs	r0, r3, r2
 8002970:	4243      	negs	r3, r0
 8002972:	4158      	adcs	r0, r3
 8002974:	4b6d      	ldr	r3, [pc, #436]	; (8002b2c <test_008_001_execute.10019+0x23c>)
 8002976:	b2c0      	uxtb	r0, r0
 8002978:	1c19      	adds	r1, r3, #0
 800297a:	4698      	mov	r8, r3
 800297c:	f7fd ff98 	bl	80008b0 <_test_assert>
 8002980:	2800      	cmp	r0, #0
 8002982:	d1cb      	bne.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002984:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002986:	b672      	cpsid	i
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002988:	6822      	ldr	r2, [r4, #0]
 800298a:	68e3      	ldr	r3, [r4, #12]
 800298c:	1ad0      	subs	r0, r2, r3
 800298e:	4a68      	ldr	r2, [pc, #416]	; (8002b30 <test_008_001_execute.10019+0x240>)
 8002990:	4243      	negs	r3, r0
 8002992:	4158      	adcs	r0, r3
 8002994:	b2c0      	uxtb	r0, r0
 8002996:	1c11      	adds	r1, r2, #0
 8002998:	4693      	mov	fp, r2
 800299a:	f7fd ff89 	bl	80008b0 <_test_assert>
 800299e:	2800      	cmp	r0, #0
 80029a0:	d1bc      	bne.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80029a2:	b662      	cpsie	i
  }

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
 80029a4:	2303      	movs	r3, #3
 80029a6:	4a63      	ldr	r2, [pc, #396]	; (8002b34 <test_008_001_execute.10019+0x244>)
 80029a8:	602b      	str	r3, [r5, #0]
 80029aa:	2342      	movs	r3, #66	; 0x42
 80029ac:	4699      	mov	r9, r3
 80029ae:	4692      	mov	sl, r2
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80029b0:	4961      	ldr	r1, [pc, #388]	; (8002b38 <test_008_001_execute.10019+0x248>)
 80029b2:	4648      	mov	r0, r9
 80029b4:	f7ff ff24 	bl	8002800 <chMBPost.constprop.21>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80029b8:	4243      	negs	r3, r0
 80029ba:	4158      	adcs	r0, r3
 80029bc:	b2c0      	uxtb	r0, r0
 80029be:	4651      	mov	r1, sl
 80029c0:	f7fd ff76 	bl	80008b0 <_test_assert>
 80029c4:	2800      	cmp	r0, #0
 80029c6:	d1aa      	bne.n	800291e <test_008_001_execute.10019+0x2e>
 80029c8:	2301      	movs	r3, #1
 80029ca:	4499      	add	r9, r3

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 80029cc:	464a      	mov	r2, r9
 80029ce:	2a45      	cmp	r2, #69	; 0x45
 80029d0:	d1ee      	bne.n	80029b0 <test_008_001_execute.10019+0xc0>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80029d2:	4959      	ldr	r1, [pc, #356]	; (8002b38 <test_008_001_execute.10019+0x248>)
 80029d4:	2041      	movs	r0, #65	; 0x41
 80029d6:	f7ff ff3b 	bl	8002850 <chMBPostAhead.constprop.19>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80029da:	4243      	negs	r3, r0
 80029dc:	4158      	adcs	r0, r3
 80029de:	b2c0      	uxtb	r0, r0
 80029e0:	4651      	mov	r1, sl
 80029e2:	f7fd ff65 	bl	80008b0 <_test_assert>
 80029e6:	2800      	cmp	r0, #0
 80029e8:	d199      	bne.n	800291e <test_008_001_execute.10019+0x2e>
  }

  /* [8.1.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 80029ea:	2304      	movs	r3, #4
 80029ec:	4699      	mov	r9, r3
 80029ee:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80029f0:	b672      	cpsid	i
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80029f2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80029f4:	4951      	ldr	r1, [pc, #324]	; (8002b3c <test_008_001_execute.10019+0x24c>)
 80029f6:	4250      	negs	r0, r2
 80029f8:	4150      	adcs	r0, r2
 80029fa:	b2c0      	uxtb	r0, r0
 80029fc:	f7fd ff58 	bl	80008b0 <_test_assert>
 8002a00:	2800      	cmp	r0, #0
 8002a02:	d000      	beq.n	8002a06 <test_008_001_execute.10019+0x116>
 8002a04:	e78a      	b.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a06:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a08:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8002a0a:	69a0      	ldr	r0, [r4, #24]
 8002a0c:	494c      	ldr	r1, [pc, #304]	; (8002b40 <test_008_001_execute.10019+0x250>)
 8002a0e:	3804      	subs	r0, #4
 8002a10:	4243      	negs	r3, r0
 8002a12:	4158      	adcs	r0, r3
 8002a14:	b2c0      	uxtb	r0, r0
 8002a16:	f7fd ff4b 	bl	80008b0 <_test_assert>
 8002a1a:	2800      	cmp	r0, #0
 8002a1c:	d000      	beq.n	8002a20 <test_008_001_execute.10019+0x130>
 8002a1e:	e77d      	b.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a20:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a22:	b672      	cpsid	i
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8002a24:	68e3      	ldr	r3, [r4, #12]
 8002a26:	68a2      	ldr	r2, [r4, #8]
 8002a28:	4946      	ldr	r1, [pc, #280]	; (8002b44 <test_008_001_execute.10019+0x254>)
 8002a2a:	1a98      	subs	r0, r3, r2
 8002a2c:	4243      	negs	r3, r0
 8002a2e:	4158      	adcs	r0, r3
 8002a30:	b2c0      	uxtb	r0, r0
 8002a32:	f7fd ff3d 	bl	80008b0 <_test_assert>
 8002a36:	2800      	cmp	r0, #0
 8002a38:	d000      	beq.n	8002a3c <test_008_001_execute.10019+0x14c>
 8002a3a:	e76f      	b.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a3c:	b662      	cpsie	i
  }

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
 8002a3e:	2305      	movs	r3, #5
 8002a40:	602b      	str	r3, [r5, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8002a42:	493d      	ldr	r1, [pc, #244]	; (8002b38 <test_008_001_execute.10019+0x248>)
 8002a44:	a801      	add	r0, sp, #4
 8002a46:	f7ff ff2b 	bl	80028a0 <chMBFetch.constprop.17>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002a4a:	4243      	negs	r3, r0
 8002a4c:	4158      	adcs	r0, r3
 8002a4e:	b2c0      	uxtb	r0, r0
 8002a50:	4651      	mov	r1, sl
 8002a52:	f7fd ff2d 	bl	80008b0 <_test_assert>
 8002a56:	2800      	cmp	r0, #0
 8002a58:	d000      	beq.n	8002a5c <test_008_001_execute.10019+0x16c>
 8002a5a:	e760      	b.n	800291e <test_008_001_execute.10019+0x2e>
      test_emit_token(msg2);
 8002a5c:	9b01      	ldr	r3, [sp, #4]
 8002a5e:	b2d8      	uxtb	r0, r3
 8002a60:	f7fd fdc6 	bl	80005f0 <test_emit_token>
 8002a64:	2201      	movs	r2, #1
 8002a66:	4252      	negs	r2, r2
 8002a68:	4491      	add	r9, r2

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8002a6a:	464b      	mov	r3, r9
 8002a6c:	2b00      	cmp	r3, #0
 8002a6e:	d1e8      	bne.n	8002a42 <test_008_001_execute.10019+0x152>
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8002a70:	4835      	ldr	r0, [pc, #212]	; (8002b48 <test_008_001_execute.10019+0x258>)
 8002a72:	4936      	ldr	r1, [pc, #216]	; (8002b4c <test_008_001_execute.10019+0x25c>)
 8002a74:	f7fd feec 	bl	8000850 <_test_assert_sequence>
 8002a78:	2800      	cmp	r0, #0
 8002a7a:	d000      	beq.n	8002a7e <test_008_001_execute.10019+0x18e>
 8002a7c:	e74f      	b.n	800291e <test_008_001_execute.10019+0x2e>
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8002a7e:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8002a80:	492d      	ldr	r1, [pc, #180]	; (8002b38 <test_008_001_execute.10019+0x248>)
 8002a82:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8002a84:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8002a86:	f7ff febb 	bl	8002800 <chMBPost.constprop.21>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002a8a:	4243      	negs	r3, r0
 8002a8c:	4158      	adcs	r0, r3
 8002a8e:	b2c0      	uxtb	r0, r0
 8002a90:	4651      	mov	r1, sl
 8002a92:	f7fd ff0d 	bl	80008b0 <_test_assert>
 8002a96:	2800      	cmp	r0, #0
 8002a98:	d000      	beq.n	8002a9c <test_008_001_execute.10019+0x1ac>
 8002a9a:	e740      	b.n	800291e <test_008_001_execute.10019+0x2e>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8002a9c:	4926      	ldr	r1, [pc, #152]	; (8002b38 <test_008_001_execute.10019+0x248>)
 8002a9e:	a801      	add	r0, sp, #4
 8002aa0:	f7ff fefe 	bl	80028a0 <chMBFetch.constprop.17>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002aa4:	4243      	negs	r3, r0
 8002aa6:	4158      	adcs	r0, r3
 8002aa8:	b2c0      	uxtb	r0, r0
 8002aaa:	4651      	mov	r1, sl
 8002aac:	f7fd ff00 	bl	80008b0 <_test_assert>
 8002ab0:	2800      	cmp	r0, #0
 8002ab2:	d000      	beq.n	8002ab6 <test_008_001_execute.10019+0x1c6>
 8002ab4:	e733      	b.n	800291e <test_008_001_execute.10019+0x2e>
  }

  /* [8.1.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 8002ab6:	2307      	movs	r3, #7
 8002ab8:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002aba:	b672      	cpsid	i
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8002abc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002abe:	1c31      	adds	r1, r6, #0
 8002ac0:	3804      	subs	r0, #4
 8002ac2:	4243      	negs	r3, r0
 8002ac4:	4158      	adcs	r0, r3
 8002ac6:	b2c0      	uxtb	r0, r0
 8002ac8:	f7fd fef2 	bl	80008b0 <_test_assert>
 8002acc:	2800      	cmp	r0, #0
 8002ace:	d000      	beq.n	8002ad2 <test_008_001_execute.10019+0x1e2>
 8002ad0:	e724      	b.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ad2:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ad4:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8002ad6:	69a2      	ldr	r2, [r4, #24]
 8002ad8:	1c39      	adds	r1, r7, #0
 8002ada:	4250      	negs	r0, r2
 8002adc:	4150      	adcs	r0, r2
 8002ade:	b2c0      	uxtb	r0, r0
 8002ae0:	f7fd fee6 	bl	80008b0 <_test_assert>
 8002ae4:	2800      	cmp	r0, #0
 8002ae6:	d000      	beq.n	8002aea <test_008_001_execute.10019+0x1fa>
 8002ae8:	e718      	b.n	800291c <test_008_001_execute.10019+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002aea:	b662      	cpsie	i
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002aec:	6823      	ldr	r3, [r4, #0]
 8002aee:	68a2      	ldr	r2, [r4, #8]
 8002af0:	4641      	mov	r1, r8
 8002af2:	1a98      	subs	r0, r3, r2
 8002af4:	4243      	negs	r3, r0
 8002af6:	4158      	adcs	r0, r3
 8002af8:	b2c0      	uxtb	r0, r0
 8002afa:	f7fd fed9 	bl	80008b0 <_test_assert>
 8002afe:	2800      	cmp	r0, #0
 8002b00:	d000      	beq.n	8002b04 <test_008_001_execute.10019+0x214>
 8002b02:	e70c      	b.n	800291e <test_008_001_execute.10019+0x2e>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002b04:	68e3      	ldr	r3, [r4, #12]
 8002b06:	6820      	ldr	r0, [r4, #0]
 8002b08:	4659      	mov	r1, fp
 8002b0a:	1ac0      	subs	r0, r0, r3
 8002b0c:	4243      	negs	r3, r0
 8002b0e:	4158      	adcs	r0, r3
 8002b10:	b2c0      	uxtb	r0, r0
 8002b12:	f7fd fecd 	bl	80008b0 <_test_assert>
 8002b16:	e702      	b.n	800291e <test_008_001_execute.10019+0x2e>
 8002b18:	20000f44 	.word	0x20000f44
 8002b1c:	2000042c 	.word	0x2000042c
 8002b20:	08005e58 	.word	0x08005e58
 8002b24:	08005d38 	.word	0x08005d38
 8002b28:	08005e64 	.word	0x08005e64
 8002b2c:	08005e70 	.word	0x08005e70
 8002b30:	08005e94 	.word	0x08005e94
 8002b34:	08005eb8 	.word	0x08005eb8
 8002b38:	0000ffff 	.word	0x0000ffff
 8002b3c:	08005ed0 	.word	0x08005ed0
 8002b40:	08005edc 	.word	0x08005edc
 8002b44:	08005ee8 	.word	0x08005ee8
 8002b48:	08005de8 	.word	0x08005de8
 8002b4c:	08005f00 	.word	0x08005f00

08002b50 <test_008_002_execute.10017>:

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8002b50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b52:	464d      	mov	r5, r9
 8002b54:	465f      	mov	r7, fp
 8002b56:	4656      	mov	r6, sl
 8002b58:	4644      	mov	r4, r8
 8002b5a:	b4f0      	push	{r4, r5, r6, r7}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 8002b5c:	4da1      	ldr	r5, [pc, #644]	; (8002de4 <test_008_002_execute.10017+0x294>)
 8002b5e:	2301      	movs	r3, #1

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8002b60:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 8002b62:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b64:	b672      	cpsid	i
 8002b66:	4ca0      	ldr	r4, [pc, #640]	; (8002de8 <test_008_002_execute.10017+0x298>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8002b68:	49a0      	ldr	r1, [pc, #640]	; (8002dec <test_008_002_execute.10017+0x29c>)
 8002b6a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002b6c:	3804      	subs	r0, #4
 8002b6e:	4243      	negs	r3, r0
 8002b70:	4158      	adcs	r0, r3
 8002b72:	b2c0      	uxtb	r0, r0
 8002b74:	f7fd fe9c 	bl	80008b0 <_test_assert>
 8002b78:	2800      	cmp	r0, #0
 8002b7a:	d007      	beq.n	8002b8c <test_008_002_execute.10017+0x3c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b7c:	b662      	cpsie	i
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 8002b7e:	b003      	add	sp, #12
 8002b80:	bc3c      	pop	{r2, r3, r4, r5}
 8002b82:	4690      	mov	r8, r2
 8002b84:	4699      	mov	r9, r3
 8002b86:	46a2      	mov	sl, r4
 8002b88:	46ab      	mov	fp, r5
 8002b8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002b8c:	b662      	cpsie	i
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.2.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 8002b8e:	2302      	movs	r3, #2
 8002b90:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b92:	b672      	cpsid	i
  {
    chSysLock();
    chMBResetI(&mb1);
 8002b94:	1c20      	adds	r0, r4, #0
 8002b96:	f7fe fdfb 	bl	8001790 <chMBResetI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b9a:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b9c:	b672      	cpsid	i
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8002b9e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002ba0:	4e93      	ldr	r6, [pc, #588]	; (8002df0 <test_008_002_execute.10017+0x2a0>)
 8002ba2:	3804      	subs	r0, #4
 8002ba4:	4243      	negs	r3, r0
 8002ba6:	4158      	adcs	r0, r3
 8002ba8:	b2c0      	uxtb	r0, r0
 8002baa:	1c31      	adds	r1, r6, #0
 8002bac:	f7fd fe80 	bl	80008b0 <_test_assert>
 8002bb0:	2800      	cmp	r0, #0
 8002bb2:	d1e3      	bne.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002bb4:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002bb6:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8002bb8:	69a1      	ldr	r1, [r4, #24]
 8002bba:	4f8e      	ldr	r7, [pc, #568]	; (8002df4 <test_008_002_execute.10017+0x2a4>)
 8002bbc:	4248      	negs	r0, r1
 8002bbe:	4148      	adcs	r0, r1
 8002bc0:	b2c0      	uxtb	r0, r0
 8002bc2:	1c39      	adds	r1, r7, #0
 8002bc4:	f7fd fe74 	bl	80008b0 <_test_assert>
 8002bc8:	2800      	cmp	r0, #0
 8002bca:	d1d7      	bne.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002bcc:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002bce:	b672      	cpsid	i
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002bd0:	68a3      	ldr	r3, [r4, #8]
 8002bd2:	6822      	ldr	r2, [r4, #0]
 8002bd4:	4988      	ldr	r1, [pc, #544]	; (8002df8 <test_008_002_execute.10017+0x2a8>)
 8002bd6:	1ad0      	subs	r0, r2, r3
 8002bd8:	4243      	negs	r3, r0
 8002bda:	4158      	adcs	r0, r3
 8002bdc:	b2c0      	uxtb	r0, r0
 8002bde:	4688      	mov	r8, r1
 8002be0:	f7fd fe66 	bl	80008b0 <_test_assert>
 8002be4:	2800      	cmp	r0, #0
 8002be6:	d1c9      	bne.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002be8:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002bea:	b672      	cpsid	i
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002bec:	68e3      	ldr	r3, [r4, #12]
 8002bee:	6822      	ldr	r2, [r4, #0]
 8002bf0:	4982      	ldr	r1, [pc, #520]	; (8002dfc <test_008_002_execute.10017+0x2ac>)
 8002bf2:	1ad0      	subs	r0, r2, r3
 8002bf4:	4243      	negs	r3, r0
 8002bf6:	4158      	adcs	r0, r3
 8002bf8:	b2c0      	uxtb	r0, r0
 8002bfa:	468b      	mov	fp, r1
 8002bfc:	f7fd fe58 	bl	80008b0 <_test_assert>
 8002c00:	2800      	cmp	r0, #0
 8002c02:	d1bb      	bne.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c04:	b662      	cpsie	i
  }

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 8002c06:	2303      	movs	r3, #3
 8002c08:	602b      	str	r3, [r5, #0]
 8002c0a:	4b7d      	ldr	r3, [pc, #500]	; (8002e00 <test_008_002_execute.10017+0x2b0>)
 8002c0c:	2242      	movs	r2, #66	; 0x42
 8002c0e:	4691      	mov	r9, r2
 8002c10:	469a      	mov	sl, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c12:	b672      	cpsid	i
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002c14:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002c16:	2b00      	cmp	r3, #0
 8002c18:	dc00      	bgt.n	8002c1c <test_008_002_execute.10017+0xcc>
 8002c1a:	e08d      	b.n	8002d38 <test_008_002_execute.10017+0x1e8>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8002c1c:	68a2      	ldr	r2, [r4, #8]
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt--;
 8002c1e:	3b01      	subs	r3, #1
 8002c20:	6263      	str	r3, [r4, #36]	; 0x24
 8002c22:	4649      	mov	r1, r9
 8002c24:	1d13      	adds	r3, r2, #4
 8002c26:	60a3      	str	r3, [r4, #8]
 8002c28:	6011      	str	r1, [r2, #0]
  if (mbp->wrptr >= mbp->top) {
 8002c2a:	6862      	ldr	r2, [r4, #4]
 8002c2c:	4293      	cmp	r3, r2
 8002c2e:	d301      	bcc.n	8002c34 <test_008_002_execute.10017+0xe4>
     mbp->wrptr = mbp->buffer;
 8002c30:	6823      	ldr	r3, [r4, #0]
 8002c32:	60a3      	str	r3, [r4, #8]
  }
  chSemSignalI(&mbp->fullsem);
 8002c34:	4873      	ldr	r0, [pc, #460]	; (8002e04 <test_008_002_execute.10017+0x2b4>)
 8002c36:	f7fe fd7b 	bl	8001730 <chSemSignalI>
 8002c3a:	2001      	movs	r0, #1
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c3c:	b662      	cpsie	i
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002c3e:	4651      	mov	r1, sl
 8002c40:	f7fd fe36 	bl	80008b0 <_test_assert>
 8002c44:	2800      	cmp	r0, #0
 8002c46:	d000      	beq.n	8002c4a <test_008_002_execute.10017+0xfa>
 8002c48:	e799      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
 8002c4a:	2101      	movs	r1, #1
 8002c4c:	4489      	add	r9, r1

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8002c4e:	464a      	mov	r2, r9
 8002c50:	2a45      	cmp	r2, #69	; 0x45
 8002c52:	d1de      	bne.n	8002c12 <test_008_002_execute.10017+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c54:	b672      	cpsid	i
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002c56:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002c58:	2b00      	cmp	r3, #0
 8002c5a:	dd10      	ble.n	8002c7e <test_008_002_execute.10017+0x12e>
 8002c5c:	3b01      	subs	r3, #1
 8002c5e:	6263      	str	r3, [r4, #36]	; 0x24
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 8002c60:	68e3      	ldr	r3, [r4, #12]
 8002c62:	6821      	ldr	r1, [r4, #0]
 8002c64:	3b04      	subs	r3, #4
 8002c66:	60e3      	str	r3, [r4, #12]
 8002c68:	428b      	cmp	r3, r1
 8002c6a:	d202      	bcs.n	8002c72 <test_008_002_execute.10017+0x122>
    mbp->rdptr = mbp->top - 1;
 8002c6c:	6863      	ldr	r3, [r4, #4]
 8002c6e:	3b04      	subs	r3, #4
 8002c70:	60e3      	str	r3, [r4, #12]
  }
  *mbp->rdptr = msg;
 8002c72:	2241      	movs	r2, #65	; 0x41
  chSemSignalI(&mbp->fullsem);
 8002c74:	4863      	ldr	r0, [pc, #396]	; (8002e04 <test_008_002_execute.10017+0x2b4>)
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
    mbp->rdptr = mbp->top - 1;
  }
  *mbp->rdptr = msg;
 8002c76:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 8002c78:	f7fe fd5a 	bl	8001730 <chSemSignalI>
 8002c7c:	2001      	movs	r0, #1
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c7e:	b662      	cpsie	i
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'A');
    chSysUnlock();
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002c80:	4651      	mov	r1, sl
 8002c82:	f7fd fe15 	bl	80008b0 <_test_assert>
 8002c86:	2800      	cmp	r0, #0
 8002c88:	d000      	beq.n	8002c8c <test_008_002_execute.10017+0x13c>
 8002c8a:	e778      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
  }

  /* [8.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 8002c8c:	2204      	movs	r2, #4
 8002c8e:	4691      	mov	r9, r2
 8002c90:	602a      	str	r2, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c92:	b672      	cpsid	i
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8002c94:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002c96:	4248      	negs	r0, r1
 8002c98:	4148      	adcs	r0, r1
 8002c9a:	b2c0      	uxtb	r0, r0
 8002c9c:	495a      	ldr	r1, [pc, #360]	; (8002e08 <test_008_002_execute.10017+0x2b8>)
 8002c9e:	f7fd fe07 	bl	80008b0 <_test_assert>
 8002ca2:	2800      	cmp	r0, #0
 8002ca4:	d000      	beq.n	8002ca8 <test_008_002_execute.10017+0x158>
 8002ca6:	e769      	b.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ca8:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002caa:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8002cac:	69a0      	ldr	r0, [r4, #24]
 8002cae:	4957      	ldr	r1, [pc, #348]	; (8002e0c <test_008_002_execute.10017+0x2bc>)
 8002cb0:	3804      	subs	r0, #4
 8002cb2:	4243      	negs	r3, r0
 8002cb4:	4158      	adcs	r0, r3
 8002cb6:	b2c0      	uxtb	r0, r0
 8002cb8:	f7fd fdfa 	bl	80008b0 <_test_assert>
 8002cbc:	2800      	cmp	r0, #0
 8002cbe:	d000      	beq.n	8002cc2 <test_008_002_execute.10017+0x172>
 8002cc0:	e75c      	b.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002cc2:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002cc4:	b672      	cpsid	i
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8002cc6:	68a3      	ldr	r3, [r4, #8]
 8002cc8:	68e2      	ldr	r2, [r4, #12]
 8002cca:	4951      	ldr	r1, [pc, #324]	; (8002e10 <test_008_002_execute.10017+0x2c0>)
 8002ccc:	1ad0      	subs	r0, r2, r3
 8002cce:	4243      	negs	r3, r0
 8002cd0:	4158      	adcs	r0, r3
 8002cd2:	b2c0      	uxtb	r0, r0
 8002cd4:	f7fd fdec 	bl	80008b0 <_test_assert>
 8002cd8:	2800      	cmp	r0, #0
 8002cda:	d000      	beq.n	8002cde <test_008_002_execute.10017+0x18e>
 8002cdc:	e74e      	b.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002cde:	b662      	cpsie	i
  }

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 8002ce0:	2305      	movs	r3, #5
 8002ce2:	602b      	str	r3, [r5, #0]
 8002ce4:	e021      	b.n	8002d2a <test_008_002_execute.10017+0x1da>

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002ce6:	68e2      	ldr	r2, [r4, #12]
 8002ce8:	3b01      	subs	r3, #1
 8002cea:	61a3      	str	r3, [r4, #24]
  if (mbp->rdptr >= mbp->top) {
 8002cec:	6861      	ldr	r1, [r4, #4]

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002cee:	1d13      	adds	r3, r2, #4
 8002cf0:	6812      	ldr	r2, [r2, #0]
 8002cf2:	60e3      	str	r3, [r4, #12]
 8002cf4:	9201      	str	r2, [sp, #4]
  if (mbp->rdptr >= mbp->top) {
 8002cf6:	428b      	cmp	r3, r1
 8002cf8:	d301      	bcc.n	8002cfe <test_008_002_execute.10017+0x1ae>
    mbp->rdptr = mbp->buffer;
 8002cfa:	6822      	ldr	r2, [r4, #0]
 8002cfc:	60e2      	str	r2, [r4, #12]
  }
  chSemSignalI(&mbp->emptysem);
 8002cfe:	4845      	ldr	r0, [pc, #276]	; (8002e14 <test_008_002_execute.10017+0x2c4>)
 8002d00:	f7fe fd16 	bl	8001730 <chSemSignalI>

  return MSG_OK;
 8002d04:	2000      	movs	r0, #0
 8002d06:	b662      	cpsie	i
  {
    for (i = 0; i < MB_SIZE; i++) {
      chSysLock();
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002d08:	3001      	adds	r0, #1
 8002d0a:	4651      	mov	r1, sl
 8002d0c:	f7fd fdd0 	bl	80008b0 <_test_assert>
 8002d10:	2800      	cmp	r0, #0
 8002d12:	d000      	beq.n	8002d16 <test_008_002_execute.10017+0x1c6>
 8002d14:	e733      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
      test_emit_token(msg2);
 8002d16:	9b01      	ldr	r3, [sp, #4]
 8002d18:	b2d8      	uxtb	r0, r3
 8002d1a:	f7fd fc69 	bl	80005f0 <test_emit_token>
 8002d1e:	2101      	movs	r1, #1
 8002d20:	4249      	negs	r1, r1
 8002d22:	4489      	add	r9, r1

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8002d24:	464a      	mov	r2, r9
 8002d26:	2a00      	cmp	r2, #0
 8002d28:	d008      	beq.n	8002d3c <test_008_002_execute.10017+0x1ec>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d2a:	b672      	cpsid	i
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8002d2c:	69a3      	ldr	r3, [r4, #24]
 8002d2e:	2b00      	cmp	r3, #0
 8002d30:	dcd9      	bgt.n	8002ce6 <test_008_002_execute.10017+0x196>
    return MSG_TIMEOUT;
 8002d32:	2001      	movs	r0, #1
 8002d34:	4240      	negs	r0, r0
 8002d36:	e7e6      	b.n	8002d06 <test_008_002_execute.10017+0x1b6>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002d38:	2000      	movs	r0, #0
 8002d3a:	e77f      	b.n	8002c3c <test_008_002_execute.10017+0xec>
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8002d3c:	4836      	ldr	r0, [pc, #216]	; (8002e18 <test_008_002_execute.10017+0x2c8>)
 8002d3e:	4937      	ldr	r1, [pc, #220]	; (8002e1c <test_008_002_execute.10017+0x2cc>)
 8002d40:	f7fd fd86 	bl	8000850 <_test_assert_sequence>
 8002d44:	2800      	cmp	r0, #0
 8002d46:	d000      	beq.n	8002d4a <test_008_002_execute.10017+0x1fa>
 8002d48:	e719      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8002d4a:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8002d4c:	4934      	ldr	r1, [pc, #208]	; (8002e20 <test_008_002_execute.10017+0x2d0>)
 8002d4e:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8002d50:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8002d52:	f7ff fd55 	bl	8002800 <chMBPost.constprop.21>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002d56:	4243      	negs	r3, r0
 8002d58:	4158      	adcs	r0, r3
 8002d5a:	b2c0      	uxtb	r0, r0
 8002d5c:	4651      	mov	r1, sl
 8002d5e:	f7fd fda7 	bl	80008b0 <_test_assert>
 8002d62:	2800      	cmp	r0, #0
 8002d64:	d000      	beq.n	8002d68 <test_008_002_execute.10017+0x218>
 8002d66:	e70a      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8002d68:	492d      	ldr	r1, [pc, #180]	; (8002e20 <test_008_002_execute.10017+0x2d0>)
 8002d6a:	a801      	add	r0, sp, #4
 8002d6c:	f7ff fd98 	bl	80028a0 <chMBFetch.constprop.17>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002d70:	4243      	negs	r3, r0
 8002d72:	4158      	adcs	r0, r3
 8002d74:	b2c0      	uxtb	r0, r0
 8002d76:	4651      	mov	r1, sl
 8002d78:	f7fd fd9a 	bl	80008b0 <_test_assert>
 8002d7c:	2800      	cmp	r0, #0
 8002d7e:	d000      	beq.n	8002d82 <test_008_002_execute.10017+0x232>
 8002d80:	e6fd      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
  }

  /* [8.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 8002d82:	2307      	movs	r3, #7
 8002d84:	602b      	str	r3, [r5, #0]
 8002d86:	b672      	cpsid	i
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8002d88:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002d8a:	1c31      	adds	r1, r6, #0
 8002d8c:	3804      	subs	r0, #4
 8002d8e:	4243      	negs	r3, r0
 8002d90:	4158      	adcs	r0, r3
 8002d92:	b2c0      	uxtb	r0, r0
 8002d94:	f7fd fd8c 	bl	80008b0 <_test_assert>
 8002d98:	2800      	cmp	r0, #0
 8002d9a:	d000      	beq.n	8002d9e <test_008_002_execute.10017+0x24e>
 8002d9c:	e6ee      	b.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d9e:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002da0:	b672      	cpsid	i
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8002da2:	69a1      	ldr	r1, [r4, #24]
 8002da4:	4248      	negs	r0, r1
 8002da6:	4148      	adcs	r0, r1
 8002da8:	b2c0      	uxtb	r0, r0
 8002daa:	1c39      	adds	r1, r7, #0
 8002dac:	f7fd fd80 	bl	80008b0 <_test_assert>
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d000      	beq.n	8002db6 <test_008_002_execute.10017+0x266>
 8002db4:	e6e2      	b.n	8002b7c <test_008_002_execute.10017+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002db6:	b662      	cpsie	i
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002db8:	68a3      	ldr	r3, [r4, #8]
 8002dba:	6822      	ldr	r2, [r4, #0]
 8002dbc:	4641      	mov	r1, r8
 8002dbe:	1ad0      	subs	r0, r2, r3
 8002dc0:	4243      	negs	r3, r0
 8002dc2:	4158      	adcs	r0, r3
 8002dc4:	b2c0      	uxtb	r0, r0
 8002dc6:	f7fd fd73 	bl	80008b0 <_test_assert>
 8002dca:	2800      	cmp	r0, #0
 8002dcc:	d000      	beq.n	8002dd0 <test_008_002_execute.10017+0x280>
 8002dce:	e6d6      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002dd0:	68e3      	ldr	r3, [r4, #12]
 8002dd2:	6820      	ldr	r0, [r4, #0]
 8002dd4:	4659      	mov	r1, fp
 8002dd6:	1ac0      	subs	r0, r0, r3
 8002dd8:	4243      	negs	r3, r0
 8002dda:	4158      	adcs	r0, r3
 8002ddc:	b2c0      	uxtb	r0, r0
 8002dde:	f7fd fd67 	bl	80008b0 <_test_assert>
 8002de2:	e6cc      	b.n	8002b7e <test_008_002_execute.10017+0x2e>
 8002de4:	20000f44 	.word	0x20000f44
 8002de8:	2000042c 	.word	0x2000042c
 8002dec:	08005e58 	.word	0x08005e58
 8002df0:	08005d38 	.word	0x08005d38
 8002df4:	08005e64 	.word	0x08005e64
 8002df8:	08005e70 	.word	0x08005e70
 8002dfc:	08005e94 	.word	0x08005e94
 8002e00:	08005eb8 	.word	0x08005eb8
 8002e04:	2000043c 	.word	0x2000043c
 8002e08:	08005ed0 	.word	0x08005ed0
 8002e0c:	08005edc 	.word	0x08005edc
 8002e10:	08005ee8 	.word	0x08005ee8
 8002e14:	20000448 	.word	0x20000448
 8002e18:	08005de8 	.word	0x08005de8
 8002e1c:	08005f00 	.word	0x08005f00
 8002e20:	0000ffff 	.word	0x0000ffff
 8002e24:	46c0      	nop			; (mov r8, r8)
 8002e26:	46c0      	nop			; (mov r8, r8)
 8002e28:	46c0      	nop			; (mov r8, r8)
 8002e2a:	46c0      	nop			; (mov r8, r8)
 8002e2c:	46c0      	nop			; (mov r8, r8)
 8002e2e:	46c0      	nop			; (mov r8, r8)

08002e30 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8002e30:	b508      	push	{r3, lr}
 8002e32:	1c01      	adds	r1, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e34:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8002e36:	2008      	movs	r0, #8
 8002e38:	f002 f942 	bl	80050c0 <chSchGoSleepTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e3c:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8002e3e:	bd08      	pop	{r3, pc}

08002e40 <Thread1.10922>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8002e40:	4b09      	ldr	r3, [pc, #36]	; (8002e68 <Thread1.10922+0x28>)
 8002e42:	4a0a      	ldr	r2, [pc, #40]	; (8002e6c <Thread1.10922+0x2c>)
 8002e44:	699b      	ldr	r3, [r3, #24]

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002e46:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8002e48:	2490      	movs	r4, #144	; 0x90
 8002e4a:	619a      	str	r2, [r3, #24]
 8002e4c:	05e4      	lsls	r4, r4, #23
 8002e4e:	2620      	movs	r6, #32
 8002e50:	2520      	movs	r5, #32
    chThdSleepMilliseconds(500);
 8002e52:	20fa      	movs	r0, #250	; 0xfa
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 8002e54:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 8002e56:	0040      	lsls	r0, r0, #1
 8002e58:	f7ff ffea 	bl	8002e30 <chThdSleep>
    palSetPad(GPIOA, GPIOA_LED_GREEN);
    chThdSleepMilliseconds(500);
 8002e5c:	20fa      	movs	r0, #250	; 0xfa
  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED_GREEN);
 8002e5e:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 8002e60:	0040      	lsls	r0, r0, #1
 8002e62:	f7ff ffe5 	bl	8002e30 <chThdSleep>
 8002e66:	e7f4      	b.n	8002e52 <Thread1.10922+0x12>
 8002e68:	20000ed4 	.word	0x20000ed4
 8002e6c:	08005f14 	.word	0x08005f14

08002e70 <evt_thread3.9757>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 8002e70:	b510      	push	{r4, lr}
 8002e72:	1c04      	adds	r4, r0, #0

  chThdSleepMilliseconds(50);
 8002e74:	2032      	movs	r0, #50	; 0x32
 8002e76:	f7ff ffdb 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e7a:	b672      	cpsid	i
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8002e7c:	2101      	movs	r1, #1
 8002e7e:	1c20      	adds	r0, r4, #0
 8002e80:	f7fe f826 	bl	8000ed0 <chEvtSignalI>
  chSchRescheduleS();
 8002e84:	f7fd fe1c 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e88:	b662      	cpsie	i
  chEvtSignal((thread_t *)p, 1);
}
 8002e8a:	bd10      	pop	{r4, pc}
 8002e8c:	46c0      	nop			; (mov r8, r8)
 8002e8e:	46c0      	nop			; (mov r8, r8)

08002e90 <test_005_004_execute.9428>:

static void test_005_004_teardown(void) {
  test_wait_threads();
}

static void test_005_004_execute(void) {
 8002e90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002e92:	4656      	mov	r6, sl
 8002e94:	464d      	mov	r5, r9
 8002e96:	4644      	mov	r4, r8
 8002e98:	465f      	mov	r7, fp
 8002e9a:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002e9c:	4d45      	ldr	r5, [pc, #276]	; (8002fb4 <test_005_004_execute.9428+0x124>)
    pa = p + 1;
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8002e9e:	4e46      	ldr	r6, [pc, #280]	; (8002fb8 <test_005_004_execute.9428+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002ea0:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8002ea2:	4a46      	ldr	r2, [pc, #280]	; (8002fbc <test_005_004_execute.9428+0x12c>)
 8002ea4:	689c      	ldr	r4, [r3, #8]
  /* [5.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
 8002ea6:	1c63      	adds	r3, r4, #1
 8002ea8:	4699      	mov	r9, r3
    pb = p + 2;
 8002eaa:	1ca3      	adds	r3, r4, #2
 8002eac:	469a      	mov	sl, r3
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8002eae:	2302      	movs	r3, #2
 8002eb0:	6033      	str	r3, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8002eb2:	4b43      	ldr	r3, [pc, #268]	; (8002fc0 <test_005_004_execute.9428+0x130>)
 8002eb4:	4649      	mov	r1, r9
 8002eb6:	4698      	mov	r8, r3
 8002eb8:	1c18      	adds	r0, r3, #0
 8002eba:	4b42      	ldr	r3, [pc, #264]	; (8002fc4 <test_005_004_execute.9428+0x134>)
 8002ebc:	f002 f9a0 	bl	8005200 <chThdCreateStatic.constprop.52>
 8002ec0:	4f41      	ldr	r7, [pc, #260]	; (8002fc8 <test_005_004_execute.9428+0x138>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8002ec2:	23a4      	movs	r3, #164	; 0xa4
 8002ec4:	005b      	lsls	r3, r3, #1
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8002ec6:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8002ec8:	1c18      	adds	r0, r3, #0
 8002eca:	4651      	mov	r1, sl
 8002ecc:	4440      	add	r0, r8
 8002ece:	4a3f      	ldr	r2, [pc, #252]	; (8002fcc <test_005_004_execute.9428+0x13c>)
 8002ed0:	4b3f      	ldr	r3, [pc, #252]	; (8002fd0 <test_005_004_execute.9428+0x140>)
 8002ed2:	f002 f995 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8002ed6:	2303      	movs	r3, #3
 8002ed8:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 8002eda:	4b3e      	ldr	r3, [pc, #248]	; (8002fd4 <test_005_004_execute.9428+0x144>)

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8002edc:	6078      	str	r0, [r7, #4]
  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
  {
    chMtxLock(&m1);
 8002ede:	1c18      	adds	r0, r3, #0
 8002ee0:	4698      	mov	r8, r3
 8002ee2:	f7fe f8ed 	bl	80010c0 <chMtxLock>
 8002ee6:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8002ee8:	4f3b      	ldr	r7, [pc, #236]	; (8002fd8 <test_005_004_execute.9428+0x148>)
 8002eea:	6898      	ldr	r0, [r3, #8]
 8002eec:	1c39      	adds	r1, r7, #0
 8002eee:	1a20      	subs	r0, r4, r0
 8002ef0:	4243      	negs	r3, r0
 8002ef2:	4158      	adcs	r0, r3
 8002ef4:	b2c0      	uxtb	r0, r0
 8002ef6:	f7fd fcdb 	bl	80008b0 <_test_assert>
 8002efa:	2800      	cmp	r0, #0
 8002efc:	d005      	beq.n	8002f0a <test_005_004_execute.9428+0x7a>
  test_set_step(8);
  {
    chMtxUnlock(&m1);
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  }
}
 8002efe:	bc3c      	pop	{r2, r3, r4, r5}
 8002f00:	4690      	mov	r8, r2
 8002f02:	4699      	mov	r9, r3
 8002f04:	46a2      	mov	sl, r4
 8002f06:	46ab      	mov	fp, r5
 8002f08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8002f0a:	2304      	movs	r3, #4
  {
    chThdSleepMilliseconds(100);
 8002f0c:	2064      	movs	r0, #100	; 0x64
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8002f0e:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 8002f10:	f7ff ff8e 	bl	8002e30 <chThdSleep>
 8002f14:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8002f16:	1c39      	adds	r1, r7, #0
 8002f18:	6898      	ldr	r0, [r3, #8]
 8002f1a:	464b      	mov	r3, r9
 8002f1c:	1a18      	subs	r0, r3, r0
 8002f1e:	4243      	negs	r3, r0
 8002f20:	4158      	adcs	r0, r3
 8002f22:	b2c0      	uxtb	r0, r0
 8002f24:	f7fd fcc4 	bl	80008b0 <_test_assert>
 8002f28:	2800      	cmp	r0, #0
 8002f2a:	d1e8      	bne.n	8002efe <test_005_004_execute.9428+0x6e>
  }

  /* [5.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 8002f2c:	2305      	movs	r3, #5
 8002f2e:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m2);
 8002f30:	4b2a      	ldr	r3, [pc, #168]	; (8002fdc <test_005_004_execute.9428+0x14c>)
 8002f32:	1c18      	adds	r0, r3, #0
 8002f34:	469b      	mov	fp, r3
 8002f36:	f7fe f8c3 	bl	80010c0 <chMtxLock>
 8002f3a:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8002f3c:	1c39      	adds	r1, r7, #0
 8002f3e:	6898      	ldr	r0, [r3, #8]
 8002f40:	464b      	mov	r3, r9
 8002f42:	1a18      	subs	r0, r3, r0
 8002f44:	4243      	negs	r3, r0
 8002f46:	4158      	adcs	r0, r3
 8002f48:	b2c0      	uxtb	r0, r0
 8002f4a:	f7fd fcb1 	bl	80008b0 <_test_assert>
 8002f4e:	2800      	cmp	r0, #0
 8002f50:	d1d5      	bne.n	8002efe <test_005_004_execute.9428+0x6e>
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8002f52:	2306      	movs	r3, #6
  {
    chThdSleepMilliseconds(100);
 8002f54:	2064      	movs	r0, #100	; 0x64
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8002f56:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 8002f58:	f7ff ff6a 	bl	8002e30 <chThdSleep>
 8002f5c:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8002f5e:	1c39      	adds	r1, r7, #0
 8002f60:	6898      	ldr	r0, [r3, #8]
 8002f62:	4653      	mov	r3, sl
 8002f64:	1a18      	subs	r0, r3, r0
 8002f66:	4243      	negs	r3, r0
 8002f68:	4158      	adcs	r0, r3
 8002f6a:	b2c0      	uxtb	r0, r0
 8002f6c:	f7fd fca0 	bl	80008b0 <_test_assert>
 8002f70:	2800      	cmp	r0, #0
 8002f72:	d1c4      	bne.n	8002efe <test_005_004_execute.9428+0x6e>
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8002f74:	2307      	movs	r3, #7
  {
    chMtxUnlock(&m2);
 8002f76:	4658      	mov	r0, fp
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8002f78:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m2);
 8002f7a:	f7fe f809 	bl	8000f90 <chMtxUnlock>
 8002f7e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8002f80:	1c39      	adds	r1, r7, #0
 8002f82:	6898      	ldr	r0, [r3, #8]
 8002f84:	464b      	mov	r3, r9
 8002f86:	1a18      	subs	r0, r3, r0
 8002f88:	4243      	negs	r3, r0
 8002f8a:	4158      	adcs	r0, r3
 8002f8c:	b2c0      	uxtb	r0, r0
 8002f8e:	f7fd fc8f 	bl	80008b0 <_test_assert>
 8002f92:	2800      	cmp	r0, #0
 8002f94:	d1b3      	bne.n	8002efe <test_005_004_execute.9428+0x6e>
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8002f96:	2308      	movs	r3, #8
  {
    chMtxUnlock(&m1);
 8002f98:	4640      	mov	r0, r8
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8002f9a:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 8002f9c:	f7fd fff8 	bl	8000f90 <chMtxUnlock>
 8002fa0:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8002fa2:	1c39      	adds	r1, r7, #0
 8002fa4:	6898      	ldr	r0, [r3, #8]
 8002fa6:	1a20      	subs	r0, r4, r0
 8002fa8:	4244      	negs	r4, r0
 8002faa:	4160      	adcs	r0, r4
 8002fac:	b2c0      	uxtb	r0, r0
 8002fae:	f7fd fc7f 	bl	80008b0 <_test_assert>
 8002fb2:	e7a4      	b.n	8002efe <test_005_004_execute.9428+0x6e>
 8002fb4:	20000ed4 	.word	0x20000ed4
 8002fb8:	20000f44 	.word	0x20000f44
 8002fbc:	08002fe1 	.word	0x08002fe1
 8002fc0:	20000518 	.word	0x20000518
 8002fc4:	08005e04 	.word	0x08005e04
 8002fc8:	20000b84 	.word	0x20000b84
 8002fcc:	08003001 	.word	0x08003001
 8002fd0:	08005e0c 	.word	0x08005e0c
 8002fd4:	20000418 	.word	0x20000418
 8002fd8:	08005e20 	.word	0x08005e20
 8002fdc:	20000400 	.word	0x20000400

08002fe0 <thread4A.9401.4223>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 8002fe0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8002fe2:	2032      	movs	r0, #50	; 0x32
 8002fe4:	f7ff ff24 	bl	8002e30 <chThdSleep>
  chMtxLock(&m1);
 8002fe8:	4c03      	ldr	r4, [pc, #12]	; (8002ff8 <thread4A.9401.4223+0x18>)
 8002fea:	1c20      	adds	r0, r4, #0
 8002fec:	f7fe f868 	bl	80010c0 <chMtxLock>
  chMtxUnlock(&m1);
 8002ff0:	1c20      	adds	r0, r4, #0
 8002ff2:	f7fd ffcd 	bl	8000f90 <chMtxUnlock>
}
 8002ff6:	bd10      	pop	{r4, pc}
 8002ff8:	20000418 	.word	0x20000418
 8002ffc:	46c0      	nop			; (mov r8, r8)
 8002ffe:	46c0      	nop			; (mov r8, r8)

08003000 <thread4B.9398.4226>:

static THD_FUNCTION(thread4B, p) {
 8003000:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 8003002:	2096      	movs	r0, #150	; 0x96
 8003004:	f7ff ff14 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003008:	b672      	cpsid	i
  chSysLock();
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 800300a:	4c05      	ldr	r4, [pc, #20]	; (8003020 <thread4B.9398.4226+0x20>)
 800300c:	1c20      	adds	r0, r4, #0
 800300e:	f7fd ffef 	bl	8000ff0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8003012:	1c20      	adds	r0, r4, #0
 8003014:	f7fd ff94 	bl	8000f40 <chMtxUnlockS>
  chSchRescheduleS();
 8003018:	f7fd fd52 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800301c:	b662      	cpsie	i
  chSysUnlock();
}
 800301e:	bd10      	pop	{r4, pc}
 8003020:	20000400 	.word	0x20000400
 8003024:	46c0      	nop			; (mov r8, r8)
 8003026:	46c0      	nop			; (mov r8, r8)
 8003028:	46c0      	nop			; (mov r8, r8)
 800302a:	46c0      	nop			; (mov r8, r8)
 800302c:	46c0      	nop			; (mov r8, r8)
 800302e:	46c0      	nop			; (mov r8, r8)

08003030 <thread2.9151>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {
 8003030:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8003032:	2032      	movs	r0, #50	; 0x32
 8003034:	f7ff fefc 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003038:	b672      	cpsid	i
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 800303a:	4803      	ldr	r0, [pc, #12]	; (8003048 <thread2.9151+0x18>)
 800303c:	f7fe fb78 	bl	8001730 <chSemSignalI>
  chSchRescheduleS();
 8003040:	f7fd fd3e 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003044:	b662      	cpsie	i
  chSysUnlock();
}
 8003046:	bd08      	pop	{r3, pc}
 8003048:	20000508 	.word	0x20000508
 800304c:	46c0      	nop			; (mov r8, r8)
 800304e:	46c0      	nop			; (mov r8, r8)

08003050 <test_002_001_execute.8704>:
 * - [2.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void test_002_001_execute(void) {
 8003050:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [2.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8003052:	4e2f      	ldr	r6, [pc, #188]	; (8003110 <test_002_001_execute.8704+0xc0>)
 8003054:	2301      	movs	r3, #1
 8003056:	4d2f      	ldr	r5, [pc, #188]	; (8003114 <test_002_001_execute.8704+0xc4>)
 8003058:	6033      	str	r3, [r6, #0]
 800305a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 800305c:	2064      	movs	r0, #100	; 0x64
 800305e:	b2a4      	uxth	r4, r4
 8003060:	f7ff fee6 	bl	8002e30 <chThdSleep>
    test_assert_time_window(time + 100,
 8003064:	1c20      	adds	r0, r4, #0
 8003066:	3064      	adds	r0, #100	; 0x64
 8003068:	3467      	adds	r4, #103	; 0x67
 800306a:	b280      	uxth	r0, r0
 800306c:	b2a1      	uxth	r1, r4
 800306e:	f7fd fa87 	bl	8000580 <_test_assert_time_window.constprop.2>
 8003072:	2800      	cmp	r0, #0
 8003074:	d000      	beq.n	8003078 <test_002_001_execute.8704+0x28>
    chThdSleepUntil(time + 100);
    test_assert_time_window(time + 100,
                            time + 100 + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
  }
}
 8003076:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [2.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8003078:	2302      	movs	r3, #2
 800307a:	6033      	str	r3, [r6, #0]
 800307c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 800307e:	2064      	movs	r0, #100	; 0x64
 8003080:	b2a4      	uxth	r4, r4
 8003082:	f7ff fed5 	bl	8002e30 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 8003086:	1c20      	adds	r0, r4, #0
 8003088:	3064      	adds	r0, #100	; 0x64
 800308a:	3467      	adds	r4, #103	; 0x67
 800308c:	b280      	uxth	r0, r0
 800308e:	b2a1      	uxth	r1, r4
 8003090:	f7fd fa76 	bl	8000580 <_test_assert_time_window.constprop.2>
 8003094:	2800      	cmp	r0, #0
 8003096:	d1ee      	bne.n	8003076 <test_002_001_execute.8704+0x26>
  }

  /* [2.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8003098:	2303      	movs	r3, #3
 800309a:	6033      	str	r3, [r6, #0]
 800309c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 800309e:	2064      	movs	r0, #100	; 0x64
 80030a0:	b2a4      	uxth	r4, r4
 80030a2:	f7ff fec5 	bl	8002e30 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 80030a6:	1c20      	adds	r0, r4, #0
 80030a8:	3064      	adds	r0, #100	; 0x64
 80030aa:	3467      	adds	r4, #103	; 0x67
 80030ac:	b280      	uxth	r0, r0
 80030ae:	b2a1      	uxth	r1, r4
 80030b0:	f7fd fa66 	bl	8000580 <_test_assert_time_window.constprop.2>
 80030b4:	2800      	cmp	r0, #0
 80030b6:	d1de      	bne.n	8003076 <test_002_001_execute.8704+0x26>
                            "out of time window");
  }

  /* [2.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 80030b8:	2304      	movs	r3, #4
 80030ba:	6033      	str	r3, [r6, #0]
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 80030bc:	20fa      	movs	r0, #250	; 0xfa
 80030be:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80030c0:	0080      	lsls	r0, r0, #2
 80030c2:	f7ff feb5 	bl	8002e30 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 80030c6:	23fa      	movs	r3, #250	; 0xfa
 80030c8:	b2a4      	uxth	r4, r4
 80030ca:	009b      	lsls	r3, r3, #2
 80030cc:	18e0      	adds	r0, r4, r3
 80030ce:	4b12      	ldr	r3, [pc, #72]	; (8003118 <test_002_001_execute.8704+0xc8>)
 80030d0:	b280      	uxth	r0, r0
 80030d2:	18e4      	adds	r4, r4, r3
 80030d4:	b2a1      	uxth	r1, r4
 80030d6:	f7fd fa53 	bl	8000580 <_test_assert_time_window.constprop.2>
 80030da:	2800      	cmp	r0, #0
 80030dc:	d1cb      	bne.n	8003076 <test_002_001_execute.8704+0x26>
                            "out of time window");
  }

  /* [2.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 80030de:	2305      	movs	r3, #5
 80030e0:	6033      	str	r3, [r6, #0]
 80030e2:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 80030e4:	b2b6      	uxth	r6, r6
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
 80030e6:	1c34      	adds	r4, r6, #0
 80030e8:	3464      	adds	r4, #100	; 0x64
 80030ea:	b2a4      	uxth	r4, r4
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80030ec:	b672      	cpsid	i
 80030ee:	6a69      	ldr	r1, [r5, #36]	; 0x24
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
 80030f0:	1a61      	subs	r1, r4, r1
 80030f2:	b289      	uxth	r1, r1
  if (time > (systime_t)0) {
 80030f4:	2900      	cmp	r1, #0
 80030f6:	d002      	beq.n	80030fe <test_002_001_execute.8704+0xae>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80030f8:	2008      	movs	r0, #8
 80030fa:	f001 ffe1 	bl	80050c0 <chSchGoSleepTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80030fe:	b662      	cpsie	i
    test_assert_time_window(time + 100,
 8003100:	1c31      	adds	r1, r6, #0
 8003102:	3167      	adds	r1, #103	; 0x67
 8003104:	b289      	uxth	r1, r1
 8003106:	1c20      	adds	r0, r4, #0
 8003108:	f7fd fa3a 	bl	8000580 <_test_assert_time_window.constprop.2>
 800310c:	e7b3      	b.n	8003076 <test_002_001_execute.8704+0x26>
 800310e:	46c0      	nop			; (mov r8, r8)
 8003110:	20000f44 	.word	0x20000f44
 8003114:	40000400 	.word	0x40000400
 8003118:	000003eb 	.word	0x000003eb
 800311c:	46c0      	nop			; (mov r8, r8)
 800311e:	46c0      	nop			; (mov r8, r8)

08003120 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8003120:	b508      	push	{r3, lr}

  chThdSleep(1);
 8003122:	2001      	movs	r0, #1
 8003124:	f7ff fe84 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003128:	b672      	cpsid	i
 800312a:	4b02      	ldr	r3, [pc, #8]	; (8003134 <test_wait_tick+0x14>)
 800312c:	6a58      	ldr	r0, [r3, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800312e:	b662      	cpsie	i
  return chVTGetSystemTime();
 8003130:	b280      	uxth	r0, r0
}
 8003132:	bd08      	pop	{r3, pc}
 8003134:	40000400 	.word	0x40000400
 8003138:	46c0      	nop			; (mov r8, r8)
 800313a:	46c0      	nop			; (mov r8, r8)
 800313c:	46c0      	nop			; (mov r8, r8)
 800313e:	46c0      	nop			; (mov r8, r8)

08003140 <test_012_011_execute.10611>:

static void test_012_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void test_012_011_execute(void) {
 8003140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [12.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8003142:	4a1e      	ldr	r2, [pc, #120]	; (80031bc <test_012_011_execute.10611+0x7c>)

static void test_012_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void test_012_011_execute(void) {
 8003144:	464f      	mov	r7, r9
 8003146:	4646      	mov	r6, r8
 8003148:	b4c0      	push	{r6, r7}
  uint32_t n;

  /* [12.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 800314a:	2301      	movs	r3, #1
 800314c:	4691      	mov	r9, r2
 800314e:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8003150:	f7ff ffe6 	bl	8003120 <test_wait_tick>
 8003154:	4f1a      	ldr	r7, [pc, #104]	; (80031c0 <test_012_011_execute.10611+0x80>)
 8003156:	4c1b      	ldr	r4, [pc, #108]	; (80031c4 <test_012_011_execute.10611+0x84>)
      chMtxUnlock(&mtx1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8003158:	4e1b      	ldr	r6, [pc, #108]	; (80031c8 <test_012_011_execute.10611+0x88>)
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800315a:	4680      	mov	r8, r0
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 800315c:	2500      	movs	r5, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chMtxLock(&mtx1);
 800315e:	1c20      	adds	r0, r4, #0
 8003160:	f7fd ffae 	bl	80010c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003164:	1c20      	adds	r0, r4, #0
 8003166:	f7fd ff13 	bl	8000f90 <chMtxUnlock>
      chMtxLock(&mtx1);
 800316a:	1c20      	adds	r0, r4, #0
 800316c:	f7fd ffa8 	bl	80010c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003170:	1c20      	adds	r0, r4, #0
 8003172:	f7fd ff0d 	bl	8000f90 <chMtxUnlock>
      chMtxLock(&mtx1);
 8003176:	1c20      	adds	r0, r4, #0
 8003178:	f7fd ffa2 	bl	80010c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 800317c:	1c20      	adds	r0, r4, #0
 800317e:	f7fd ff07 	bl	8000f90 <chMtxUnlock>
      chMtxLock(&mtx1);
 8003182:	1c20      	adds	r0, r4, #0
 8003184:	f7fd ff9c 	bl	80010c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003188:	1c20      	adds	r0, r4, #0
 800318a:	f7fd ff01 	bl	8000f90 <chMtxUnlock>
 800318e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003190:	4642      	mov	r2, r8
 8003192:	1a9b      	subs	r3, r3, r2
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8003194:	b29b      	uxth	r3, r3
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      n++;
 8003196:	3501      	adds	r5, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8003198:	42b3      	cmp	r3, r6
 800319a:	d9e0      	bls.n	800315e <test_012_011_execute.10611+0x1e>
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 800319c:	464a      	mov	r2, r9
 800319e:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80031a0:	480a      	ldr	r0, [pc, #40]	; (80031cc <test_012_011_execute.10611+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 80031a2:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 80031a4:	f7fd fa7c 	bl	80006a0 <test_print>
    test_printn(n * 4);
 80031a8:	00a8      	lsls	r0, r5, #2
 80031aa:	f7fd fa91 	bl	80006d0 <test_printn>
    test_println(" lock+unlock/S");
 80031ae:	4808      	ldr	r0, [pc, #32]	; (80031d0 <test_012_011_execute.10611+0x90>)
 80031b0:	f7fd fa56 	bl	8000660 <test_println>
  }
}
 80031b4:	bc0c      	pop	{r2, r3}
 80031b6:	4690      	mov	r8, r2
 80031b8:	4699      	mov	r9, r3
 80031ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80031bc:	20000f44 	.word	0x20000f44
 80031c0:	40000400 	.word	0x40000400
 80031c4:	200004d0 	.word	0x200004d0
 80031c8:	000003e7 	.word	0x000003e7
 80031cc:	08005d80 	.word	0x08005d80
 80031d0:	08005f1c 	.word	0x08005f1c
 80031d4:	46c0      	nop			; (mov r8, r8)
 80031d6:	46c0      	nop			; (mov r8, r8)
 80031d8:	46c0      	nop			; (mov r8, r8)
 80031da:	46c0      	nop			; (mov r8, r8)
 80031dc:	46c0      	nop			; (mov r8, r8)
 80031de:	46c0      	nop			; (mov r8, r8)

080031e0 <test_012_010_execute.10615>:

static void test_012_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_012_010_execute(void) {
 80031e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [12.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80031e2:	4a1e      	ldr	r2, [pc, #120]	; (800325c <test_012_010_execute.10615+0x7c>)

static void test_012_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_012_010_execute(void) {
 80031e4:	464f      	mov	r7, r9
 80031e6:	4646      	mov	r6, r8
 80031e8:	b4c0      	push	{r6, r7}
  uint32_t n;

  /* [12.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80031ea:	2301      	movs	r3, #1
 80031ec:	4691      	mov	r9, r2
 80031ee:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80031f0:	f7ff ff96 	bl	8003120 <test_wait_tick>
 80031f4:	4f1a      	ldr	r7, [pc, #104]	; (8003260 <test_012_010_execute.10615+0x80>)
 80031f6:	4c1b      	ldr	r4, [pc, #108]	; (8003264 <test_012_010_execute.10615+0x84>)
      chSemSignal(&sem1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80031f8:	4e1b      	ldr	r6, [pc, #108]	; (8003268 <test_012_010_execute.10615+0x88>)
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80031fa:	4680      	mov	r8, r0
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 80031fc:	2500      	movs	r5, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemWait(&sem1);
 80031fe:	1c20      	adds	r0, r4, #0
 8003200:	f7fd fdbe 	bl	8000d80 <chSemWait>
      chSemSignal(&sem1);
 8003204:	1c20      	adds	r0, r4, #0
 8003206:	f7fd fd5b 	bl	8000cc0 <chSemSignal>
      chSemWait(&sem1);
 800320a:	1c20      	adds	r0, r4, #0
 800320c:	f7fd fdb8 	bl	8000d80 <chSemWait>
      chSemSignal(&sem1);
 8003210:	1c20      	adds	r0, r4, #0
 8003212:	f7fd fd55 	bl	8000cc0 <chSemSignal>
      chSemWait(&sem1);
 8003216:	1c20      	adds	r0, r4, #0
 8003218:	f7fd fdb2 	bl	8000d80 <chSemWait>
      chSemSignal(&sem1);
 800321c:	1c20      	adds	r0, r4, #0
 800321e:	f7fd fd4f 	bl	8000cc0 <chSemSignal>
      chSemWait(&sem1);
 8003222:	1c20      	adds	r0, r4, #0
 8003224:	f7fd fdac 	bl	8000d80 <chSemWait>
      chSemSignal(&sem1);
 8003228:	1c20      	adds	r0, r4, #0
 800322a:	f7fd fd49 	bl	8000cc0 <chSemSignal>
 800322e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003230:	4642      	mov	r2, r8
 8003232:	1a9b      	subs	r3, r3, r2
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8003234:	b29b      	uxth	r3, r3
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      n++;
 8003236:	3501      	adds	r5, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8003238:	42b3      	cmp	r3, r6
 800323a:	d9e0      	bls.n	80031fe <test_012_010_execute.10615+0x1e>
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 800323c:	464a      	mov	r2, r9
 800323e:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8003240:	480a      	ldr	r0, [pc, #40]	; (800326c <test_012_010_execute.10615+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 8003242:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8003244:	f7fd fa2c 	bl	80006a0 <test_print>
    test_printn(n * 4);
 8003248:	00a8      	lsls	r0, r5, #2
 800324a:	f7fd fa41 	bl	80006d0 <test_printn>
    test_println(" wait+signal/S");
 800324e:	4808      	ldr	r0, [pc, #32]	; (8003270 <test_012_010_execute.10615+0x90>)
 8003250:	f7fd fa06 	bl	8000660 <test_println>
  }
}
 8003254:	bc0c      	pop	{r2, r3}
 8003256:	4690      	mov	r8, r2
 8003258:	4699      	mov	r9, r3
 800325a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800325c:	20000f44 	.word	0x20000f44
 8003260:	40000400 	.word	0x40000400
 8003264:	20000ba8 	.word	0x20000ba8
 8003268:	000003e7 	.word	0x000003e7
 800326c:	08005d80 	.word	0x08005d80
 8003270:	08005f2c 	.word	0x08005f2c
 8003274:	46c0      	nop			; (mov r8, r8)
 8003276:	46c0      	nop			; (mov r8, r8)
 8003278:	46c0      	nop			; (mov r8, r8)
 800327a:	46c0      	nop			; (mov r8, r8)
 800327c:	46c0      	nop			; (mov r8, r8)
 800327e:	46c0      	nop			; (mov r8, r8)

08003280 <msg_loop_test.10633>:
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8003280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003282:	4647      	mov	r7, r8
 8003284:	b480      	push	{r7}
 8003286:	1c05      	adds	r5, r0, #0
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 8003288:	f7ff ff4a 	bl	8003120 <test_wait_tick>
 800328c:	4f0b      	ldr	r7, [pc, #44]	; (80032bc <msg_loop_test.10633+0x3c>)
    (void)chMsgSend(tp, 1);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 800328e:	4e0c      	ldr	r6, [pc, #48]	; (80032c0 <msg_loop_test.10633+0x40>)

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 8003290:	4680      	mov	r8, r0
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
 8003292:	2400      	movs	r4, #0
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
 8003294:	1c28      	adds	r0, r5, #0
 8003296:	2101      	movs	r1, #1
 8003298:	f7fd fde2 	bl	8000e60 <chMsgSend>
 800329c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800329e:	4642      	mov	r2, r8
 80032a0:	1a9b      	subs	r3, r3, r2
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80032a2:	b29b      	uxth	r3, r3
  uint32_t n = 0;
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 80032a4:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80032a6:	42b3      	cmp	r3, r6
 80032a8:	d9f4      	bls.n	8003294 <msg_loop_test.10633+0x14>
  (void)chMsgSend(tp, 0);
 80032aa:	1c28      	adds	r0, r5, #0
 80032ac:	2100      	movs	r1, #0
 80032ae:	f7fd fdd7 	bl	8000e60 <chMsgSend>
  return n;
}
 80032b2:	1c20      	adds	r0, r4, #0
 80032b4:	bc04      	pop	{r2}
 80032b6:	4690      	mov	r8, r2
 80032b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80032ba:	46c0      	nop			; (mov r8, r8)
 80032bc:	40000400 	.word	0x40000400
 80032c0:	000003e7 	.word	0x000003e7
 80032c4:	46c0      	nop			; (mov r8, r8)
 80032c6:	46c0      	nop			; (mov r8, r8)
 80032c8:	46c0      	nop			; (mov r8, r8)
 80032ca:	46c0      	nop			; (mov r8, r8)
 80032cc:	46c0      	nop			; (mov r8, r8)
 80032ce:	46c0      	nop			; (mov r8, r8)

080032d0 <test_007_006_execute.9789>:

static void test_007_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_006_execute(void) {
 80032d0:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;

  /* [7.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 80032d2:	4e4a      	ldr	r6, [pc, #296]	; (80033fc <test_007_006_execute.9789+0x12c>)
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80032d4:	4d4a      	ldr	r5, [pc, #296]	; (8003400 <test_007_006_execute.9789+0x130>)
 80032d6:	2301      	movs	r3, #1
 80032d8:	6033      	str	r3, [r6, #0]
 80032da:	69aa      	ldr	r2, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80032dc:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80032de:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80032e0:	2b00      	cmp	r3, #0
 80032e2:	d108      	bne.n	80032f6 <test_007_006_execute.9789+0x26>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80032e4:	b662      	cpsie	i
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 80032e6:	4c47      	ldr	r4, [pc, #284]	; (8003404 <test_007_006_execute.9789+0x134>)
 80032e8:	2001      	movs	r0, #1
 80032ea:	1c21      	adds	r1, r4, #0
 80032ec:	f7fd fae0 	bl	80008b0 <_test_assert>
 80032f0:	2800      	cmp	r0, #0
 80032f2:	d00e      	beq.n	8003312 <test_007_006_execute.9789+0x42>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
  }
}
 80032f4:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 80032f6:	4258      	negs	r0, r3
 80032f8:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 80032fa:	4383      	bics	r3, r0
 80032fc:	6353      	str	r3, [r2, #52]	; 0x34
 80032fe:	b662      	cpsie	i
  /* [7.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003300:	4c40      	ldr	r4, [pc, #256]	; (8003404 <test_007_006_execute.9789+0x134>)
 8003302:	4243      	negs	r3, r0
 8003304:	4158      	adcs	r0, r3
 8003306:	b2c0      	uxtb	r0, r0
 8003308:	1c21      	adds	r1, r4, #0
 800330a:	f7fd fad1 	bl	80008b0 <_test_assert>
 800330e:	2800      	cmp	r0, #0
 8003310:	d1f0      	bne.n	80032f4 <test_007_006_execute.9789+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003312:	69ab      	ldr	r3, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003314:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 8003316:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003318:	2a00      	cmp	r2, #0
 800331a:	d060      	beq.n	80033de <test_007_006_execute.9789+0x10e>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 800331c:	6358      	str	r0, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800331e:	b662      	cpsie	i
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003320:	1c21      	adds	r1, r4, #0
 8003322:	f7fd fac5 	bl	80008b0 <_test_assert>
 8003326:	2800      	cmp	r0, #0
 8003328:	d1e4      	bne.n	80032f4 <test_007_006_execute.9789+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800332a:	69ab      	ldr	r3, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800332c:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 800332e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003330:	3201      	adds	r2, #1
 8003332:	d057      	beq.n	80033e4 <test_007_006_execute.9789+0x114>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003334:	b662      	cpsie	i
 8003336:	2001      	movs	r0, #1
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003338:	1c21      	adds	r1, r4, #0
 800333a:	f7fd fab9 	bl	80008b0 <_test_assert>
 800333e:	2800      	cmp	r0, #0
 8003340:	d1d8      	bne.n	80032f4 <test_007_006_execute.9789+0x24>
  }

  /* [7.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8003342:	2302      	movs	r3, #2
 8003344:	6033      	str	r3, [r6, #0]
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003346:	69ae      	ldr	r6, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003348:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800334a:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800334c:	2b00      	cmp	r3, #0
 800334e:	d109      	bne.n	8003364 <test_007_006_execute.9789+0x94>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8003350:	2301      	movs	r3, #1
 8003352:	425b      	negs	r3, r3
 8003354:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8003356:	200a      	movs	r0, #10
 8003358:	2132      	movs	r1, #50	; 0x32
 800335a:	f001 feb1 	bl	80050c0 <chSchGoSleepTimeoutS>
 800335e:	2800      	cmp	r0, #0
 8003360:	db43      	blt.n	80033ea <test_007_006_execute.9789+0x11a>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8003362:	6b73      	ldr	r3, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8003364:	4258      	negs	r0, r3
 8003366:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003368:	4383      	bics	r3, r0
 800336a:	6373      	str	r3, [r6, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800336c:	b662      	cpsie	i
 800336e:	4243      	negs	r3, r0
 8003370:	4158      	adcs	r0, r3
 8003372:	b2c0      	uxtb	r0, r0
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8003374:	1c21      	adds	r1, r4, #0
 8003376:	f7fd fa9b 	bl	80008b0 <_test_assert>
 800337a:	2800      	cmp	r0, #0
 800337c:	d1ba      	bne.n	80032f4 <test_007_006_execute.9789+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800337e:	69ae      	ldr	r6, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003380:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003382:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003384:	2b00      	cmp	r3, #0
 8003386:	d109      	bne.n	800339c <test_007_006_execute.9789+0xcc>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8003388:	2301      	movs	r3, #1
 800338a:	425b      	negs	r3, r3
 800338c:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800338e:	200a      	movs	r0, #10
 8003390:	2132      	movs	r1, #50	; 0x32
 8003392:	f001 fe95 	bl	80050c0 <chSchGoSleepTimeoutS>
 8003396:	2800      	cmp	r0, #0
 8003398:	db2a      	blt.n	80033f0 <test_007_006_execute.9789+0x120>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 800339a:	6b73      	ldr	r3, [r6, #52]	; 0x34
  }
  ctp->epending &= ~m;
 800339c:	2200      	movs	r2, #0
 800339e:	6372      	str	r2, [r6, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033a0:	b662      	cpsie	i
 80033a2:	4258      	negs	r0, r3
 80033a4:	4158      	adcs	r0, r3
 80033a6:	b2c0      	uxtb	r0, r0
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80033a8:	1c21      	adds	r1, r4, #0
 80033aa:	f7fd fa81 	bl	80008b0 <_test_assert>
 80033ae:	1e06      	subs	r6, r0, #0
 80033b0:	d1a0      	bne.n	80032f4 <test_007_006_execute.9789+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80033b2:	69ad      	ldr	r5, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033b4:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 80033b6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80033b8:	3301      	adds	r3, #1
 80033ba:	d008      	beq.n	80033ce <test_007_006_execute.9789+0xfe>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 80033bc:	2301      	movs	r3, #1
 80033be:	425b      	negs	r3, r3
 80033c0:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 80033c2:	200b      	movs	r0, #11
 80033c4:	2132      	movs	r1, #50	; 0x32
 80033c6:	f001 fe7b 	bl	80050c0 <chSchGoSleepTimeoutS>
 80033ca:	2800      	cmp	r0, #0
 80033cc:	db13      	blt.n	80033f6 <test_007_006_execute.9789+0x126>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 80033ce:	2300      	movs	r3, #0
 80033d0:	636b      	str	r3, [r5, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033d2:	b662      	cpsie	i
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80033d4:	1c30      	adds	r0, r6, #0
 80033d6:	1c21      	adds	r1, r4, #0
 80033d8:	f7fd fa6a 	bl	80008b0 <_test_assert>
 80033dc:	e78a      	b.n	80032f4 <test_007_006_execute.9789+0x24>
 80033de:	b662      	cpsie	i
 80033e0:	2001      	movs	r0, #1
 80033e2:	e79d      	b.n	8003320 <test_007_006_execute.9789+0x50>
 80033e4:	6358      	str	r0, [r3, #52]	; 0x34
 80033e6:	b662      	cpsie	i
 80033e8:	e7a6      	b.n	8003338 <test_007_006_execute.9789+0x68>
 80033ea:	b662      	cpsie	i
 80033ec:	2001      	movs	r0, #1
 80033ee:	e7c1      	b.n	8003374 <test_007_006_execute.9789+0xa4>
 80033f0:	b662      	cpsie	i
 80033f2:	2001      	movs	r0, #1
 80033f4:	e7d8      	b.n	80033a8 <test_007_006_execute.9789+0xd8>
 80033f6:	b662      	cpsie	i
 80033f8:	2601      	movs	r6, #1
 80033fa:	e7eb      	b.n	80033d4 <test_007_006_execute.9789+0x104>
 80033fc:	20000f44 	.word	0x20000f44
 8003400:	20000ed4 	.word	0x20000ed4
 8003404:	08005f50 	.word	0x08005f50
 8003408:	46c0      	nop			; (mov r8, r8)
 800340a:	46c0      	nop			; (mov r8, r8)
 800340c:	46c0      	nop			; (mov r8, r8)
 800340e:	46c0      	nop			; (mov r8, r8)

08003410 <test_008_003_execute.10009>:

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_003_execute(void) {
 8003410:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 8003412:	4e4f      	ldr	r6, [pc, #316]	; (8003550 <test_008_003_execute.10009+0x140>)
 8003414:	2301      	movs	r3, #1
 8003416:	4d4f      	ldr	r5, [pc, #316]	; (8003554 <test_008_003_execute.10009+0x144>)

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_003_execute(void) {
 8003418:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 800341a:	6033      	str	r3, [r6, #0]
 800341c:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800341e:	494e      	ldr	r1, [pc, #312]	; (8003558 <test_008_003_execute.10009+0x148>)
 8003420:	1c20      	adds	r0, r4, #0
 8003422:	f7ff f9ed 	bl	8002800 <chMBPost.constprop.21>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003426:	4243      	negs	r3, r0
 8003428:	4158      	adcs	r0, r3
 800342a:	b2c0      	uxtb	r0, r0
 800342c:	1c29      	adds	r1, r5, #0
 800342e:	f7fd fa3f 	bl	80008b0 <_test_assert>
 8003432:	2800      	cmp	r0, #0
 8003434:	d111      	bne.n	800345a <test_008_003_execute.10009+0x4a>
 8003436:	3401      	adds	r4, #1
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8003438:	2c46      	cmp	r4, #70	; 0x46
 800343a:	d1f0      	bne.n	800341e <test_008_003_execute.10009+0xe>
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 800343c:	2302      	movs	r3, #2
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 800343e:	2101      	movs	r1, #1
 8003440:	2058      	movs	r0, #88	; 0x58
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8003442:	6033      	str	r3, [r6, #0]
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8003444:	f7ff f9dc 	bl	8002800 <chMBPost.constprop.21>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003448:	3001      	adds	r0, #1
 800344a:	4243      	negs	r3, r0
 800344c:	4158      	adcs	r0, r3
 800344e:	b2c0      	uxtb	r0, r0
 8003450:	1c29      	adds	r1, r5, #0
 8003452:	f7fd fa2d 	bl	80008b0 <_test_assert>
 8003456:	1e07      	subs	r7, r0, #0
 8003458:	d001      	beq.n	800345e <test_008_003_execute.10009+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 800345a:	b003      	add	sp, #12
 800345c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800345e:	b672      	cpsid	i
 8003460:	4c3e      	ldr	r4, [pc, #248]	; (800355c <test_008_003_execute.10009+0x14c>)
 8003462:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003464:	2b00      	cmp	r3, #0
 8003466:	dd6d      	ble.n	8003544 <test_008_003_execute.10009+0x134>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8003468:	68a2      	ldr	r2, [r4, #8]
 800346a:	3b01      	subs	r3, #1
 800346c:	6263      	str	r3, [r4, #36]	; 0x24
 800346e:	2158      	movs	r1, #88	; 0x58
 8003470:	1d13      	adds	r3, r2, #4
 8003472:	60a3      	str	r3, [r4, #8]
 8003474:	6011      	str	r1, [r2, #0]
  if (mbp->wrptr >= mbp->top) {
 8003476:	6862      	ldr	r2, [r4, #4]
 8003478:	4293      	cmp	r3, r2
 800347a:	d260      	bcs.n	800353e <test_008_003_execute.10009+0x12e>
     mbp->wrptr = mbp->buffer;
  }
  chSemSignalI(&mbp->fullsem);
 800347c:	1c20      	adds	r0, r4, #0
 800347e:	3010      	adds	r0, #16
 8003480:	f7fe f956 	bl	8001730 <chSemSignalI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003484:	b662      	cpsie	i
    msg1 = chMBPost(&mb1, 'X', 1);
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
    chSysLock();
    msg1 = chMBPostI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003486:	1c38      	adds	r0, r7, #0
 8003488:	1c29      	adds	r1, r5, #0
 800348a:	f7fd fa11 	bl	80008b0 <_test_assert>
 800348e:	2800      	cmp	r0, #0
 8003490:	d1e3      	bne.n	800345a <test_008_003_execute.10009+0x4a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 8003492:	2101      	movs	r1, #1
 8003494:	2058      	movs	r0, #88	; 0x58
 8003496:	f7ff f9db 	bl	8002850 <chMBPostAhead.constprop.19>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800349a:	3001      	adds	r0, #1
 800349c:	4243      	negs	r3, r0
 800349e:	4158      	adcs	r0, r3
 80034a0:	b2c0      	uxtb	r0, r0
 80034a2:	1c29      	adds	r1, r5, #0
 80034a4:	f7fd fa04 	bl	80008b0 <_test_assert>
 80034a8:	1e07      	subs	r7, r0, #0
 80034aa:	d1d6      	bne.n	800345a <test_008_003_execute.10009+0x4a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80034ac:	b672      	cpsid	i
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 80034ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80034b0:	2b00      	cmp	r3, #0
 80034b2:	dd49      	ble.n	8003548 <test_008_003_execute.10009+0x138>
 80034b4:	3b01      	subs	r3, #1
 80034b6:	6263      	str	r3, [r4, #36]	; 0x24
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 80034b8:	68e3      	ldr	r3, [r4, #12]
 80034ba:	6822      	ldr	r2, [r4, #0]
 80034bc:	3b04      	subs	r3, #4
 80034be:	60e3      	str	r3, [r4, #12]
 80034c0:	4293      	cmp	r3, r2
 80034c2:	d202      	bcs.n	80034ca <test_008_003_execute.10009+0xba>
    mbp->rdptr = mbp->top - 1;
 80034c4:	6863      	ldr	r3, [r4, #4]
 80034c6:	3b04      	subs	r3, #4
 80034c8:	60e3      	str	r3, [r4, #12]
  }
  *mbp->rdptr = msg;
 80034ca:	2258      	movs	r2, #88	; 0x58
  chSemSignalI(&mbp->fullsem);
 80034cc:	1c20      	adds	r0, r4, #0
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
    mbp->rdptr = mbp->top - 1;
  }
  *mbp->rdptr = msg;
 80034ce:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 80034d0:	3010      	adds	r0, #16
 80034d2:	f7fe f92d 	bl	8001730 <chSemSignalI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80034d6:	b662      	cpsie	i
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80034d8:	1c38      	adds	r0, r7, #0
 80034da:	1c29      	adds	r1, r5, #0
 80034dc:	f7fd f9e8 	bl	80008b0 <_test_assert>
 80034e0:	2800      	cmp	r0, #0
 80034e2:	d1ba      	bne.n	800345a <test_008_003_execute.10009+0x4a>
  }

  /* [8.3.3] Resetting the mailbox.*/
  test_set_step(3);
 80034e4:	2303      	movs	r3, #3
 80034e6:	6033      	str	r3, [r6, #0]
  {
    chMBReset(&mb1);
 80034e8:	f7fe f96a 	bl	80017c0 <chMBReset.constprop.22>
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 80034ec:	2304      	movs	r3, #4
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 80034ee:	2101      	movs	r1, #1
 80034f0:	a801      	add	r0, sp, #4
  {
    chMBReset(&mb1);
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 80034f2:	6033      	str	r3, [r6, #0]
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 80034f4:	f7ff f9d4 	bl	80028a0 <chMBFetch.constprop.17>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80034f8:	3001      	adds	r0, #1
 80034fa:	4243      	negs	r3, r0
 80034fc:	4158      	adcs	r0, r3
 80034fe:	b2c0      	uxtb	r0, r0
 8003500:	1c29      	adds	r1, r5, #0
 8003502:	f7fd f9d5 	bl	80008b0 <_test_assert>
 8003506:	1e06      	subs	r6, r0, #0
 8003508:	d1a7      	bne.n	800345a <test_008_003_execute.10009+0x4a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800350a:	b672      	cpsid	i
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 800350c:	69a3      	ldr	r3, [r4, #24]
 800350e:	2b00      	cmp	r3, #0
 8003510:	dd1c      	ble.n	800354c <test_008_003_execute.10009+0x13c>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8003512:	68e2      	ldr	r2, [r4, #12]
 8003514:	3b01      	subs	r3, #1
 8003516:	61a3      	str	r3, [r4, #24]
 8003518:	1d13      	adds	r3, r2, #4
 800351a:	6812      	ldr	r2, [r2, #0]
 800351c:	60e3      	str	r3, [r4, #12]
 800351e:	9201      	str	r2, [sp, #4]
  if (mbp->rdptr >= mbp->top) {
 8003520:	6862      	ldr	r2, [r4, #4]
 8003522:	4293      	cmp	r3, r2
 8003524:	d301      	bcc.n	800352a <test_008_003_execute.10009+0x11a>
    mbp->rdptr = mbp->buffer;
 8003526:	6823      	ldr	r3, [r4, #0]
 8003528:	60e3      	str	r3, [r4, #12]
  }
  chSemSignalI(&mbp->emptysem);
 800352a:	1c20      	adds	r0, r4, #0
 800352c:	301c      	adds	r0, #28
 800352e:	f7fe f8ff 	bl	8001730 <chSemSignalI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003532:	b662      	cpsie	i
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003534:	1c30      	adds	r0, r6, #0
 8003536:	1c29      	adds	r1, r5, #0
 8003538:	f7fd f9ba 	bl	80008b0 <_test_assert>
 800353c:	e78d      	b.n	800345a <test_008_003_execute.10009+0x4a>
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 800353e:	6823      	ldr	r3, [r4, #0]
 8003540:	60a3      	str	r3, [r4, #8]
 8003542:	e79b      	b.n	800347c <test_008_003_execute.10009+0x6c>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8003544:	2701      	movs	r7, #1
 8003546:	e79d      	b.n	8003484 <test_008_003_execute.10009+0x74>
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8003548:	2701      	movs	r7, #1
 800354a:	e7c4      	b.n	80034d6 <test_008_003_execute.10009+0xc6>
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 800354c:	2601      	movs	r6, #1
 800354e:	e7f0      	b.n	8003532 <test_008_003_execute.10009+0x122>
 8003550:	20000f44 	.word	0x20000f44
 8003554:	08005eb8 	.word	0x08005eb8
 8003558:	0000ffff 	.word	0x0000ffff
 800355c:	2000042c 	.word	0x2000042c

08003560 <test_004_006_execute.9172>:

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8003560:	b5f0      	push	{r4, r5, r6, r7, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8003562:	4d4b      	ldr	r5, [pc, #300]	; (8003690 <test_004_006_execute.9172+0x130>)

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8003564:	b085      	sub	sp, #20
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8003566:	2301      	movs	r3, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8003568:	ac01      	add	r4, sp, #4
 800356a:	602b      	str	r3, [r5, #0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 800356c:	2300      	movs	r3, #0
 800356e:	9401      	str	r4, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 8003570:	6064      	str	r4, [r4, #4]
 8003572:	60a3      	str	r3, [r4, #8]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003574:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8003576:	9b03      	ldr	r3, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8003578:	4e46      	ldr	r6, [pc, #280]	; (8003694 <test_004_006_execute.9172+0x134>)
 800357a:	1e58      	subs	r0, r3, #1
 800357c:	4303      	orrs	r3, r0
 800357e:	0fd8      	lsrs	r0, r3, #31
 8003580:	1c31      	adds	r1, r6, #0
 8003582:	f7fd f995 	bl	80008b0 <_test_assert>
 8003586:	2800      	cmp	r0, #0
 8003588:	d002      	beq.n	8003590 <test_004_006_execute.9172+0x30>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800358a:	b662      	cpsie	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 800358c:	b005      	add	sp, #20
 800358e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003590:	b662      	cpsie	i
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 8003592:	2302      	movs	r3, #2
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8003594:	1c20      	adds	r0, r4, #0
 8003596:	2100      	movs	r1, #0
 8003598:	602b      	str	r3, [r5, #0]
 800359a:	f7fe f939 	bl	8001810 <chSemReset>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800359e:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80035a0:	9b03      	ldr	r3, [sp, #12]
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80035a2:	1c31      	adds	r1, r6, #0
 80035a4:	1e58      	subs	r0, r3, #1
 80035a6:	4303      	orrs	r3, r0
 80035a8:	0fd8      	lsrs	r0, r3, #31
 80035aa:	f7fd f981 	bl	80008b0 <_test_assert>
 80035ae:	2800      	cmp	r0, #0
 80035b0:	d1eb      	bne.n	800358a <test_004_006_execute.9172+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035b2:	b662      	cpsie	i
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 80035b4:	2303      	movs	r3, #3
 80035b6:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80035b8:	4b37      	ldr	r3, [pc, #220]	; (8003698 <test_004_006_execute.9172+0x138>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 80035ba:	4a38      	ldr	r2, [pc, #224]	; (800369c <test_004_006_execute.9172+0x13c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80035bc:	699b      	ldr	r3, [r3, #24]
 80035be:	4838      	ldr	r0, [pc, #224]	; (80036a0 <test_004_006_execute.9172+0x140>)
 80035c0:	6899      	ldr	r1, [r3, #8]
 80035c2:	1c23      	adds	r3, r4, #0
 80035c4:	3901      	subs	r1, #1
 80035c6:	f001 fe1b 	bl	8005200 <chThdCreateStatic.constprop.52>
 80035ca:	4b36      	ldr	r3, [pc, #216]	; (80036a4 <test_004_006_execute.9172+0x144>)
 80035cc:	6018      	str	r0, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [4.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 80035ce:	2304      	movs	r3, #4
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->sem);
 80035d0:	1c20      	adds	r0, r4, #0
 80035d2:	602b      	str	r3, [r5, #0]
 80035d4:	f7fd fbd4 	bl	8000d80 <chSemWait>
 80035d8:	1c07      	adds	r7, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80035da:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80035dc:	9b03      	ldr	r3, [sp, #12]
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80035de:	1c31      	adds	r1, r6, #0
 80035e0:	1e5a      	subs	r2, r3, #1
 80035e2:	4313      	orrs	r3, r2
 80035e4:	0fd8      	lsrs	r0, r3, #31
 80035e6:	f7fd f963 	bl	80008b0 <_test_assert>
 80035ea:	2800      	cmp	r0, #0
 80035ec:	d1cd      	bne.n	800358a <test_004_006_execute.9172+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035ee:	b662      	cpsie	i
    test_assert(msg == MSG_OK, "unexpected message");
 80035f0:	4278      	negs	r0, r7
 80035f2:	4178      	adcs	r0, r7
 80035f4:	b2c0      	uxtb	r0, r0
 80035f6:	492c      	ldr	r1, [pc, #176]	; (80036a8 <test_004_006_execute.9172+0x148>)
 80035f8:	f7fd f95a 	bl	80008b0 <_test_assert>
 80035fc:	2800      	cmp	r0, #0
 80035fe:	d1c5      	bne.n	800358c <test_004_006_execute.9172+0x2c>
  }

  /* [4.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 8003600:	2305      	movs	r3, #5
 8003602:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003604:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8003606:	68a3      	ldr	r3, [r4, #8]
 8003608:	2b00      	cmp	r3, #0
 800360a:	dd39      	ble.n	8003680 <test_004_006_execute.9172+0x120>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800360c:	f7fd fa58 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003610:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003612:	b672      	cpsid	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8003614:	9b03      	ldr	r3, [sp, #12]
 8003616:	4925      	ldr	r1, [pc, #148]	; (80036ac <test_004_006_execute.9172+0x14c>)
 8003618:	17d8      	asrs	r0, r3, #31
 800361a:	1ac3      	subs	r3, r0, r3
 800361c:	0fd8      	lsrs	r0, r3, #31
 800361e:	f7fd f947 	bl	80008b0 <_test_assert>
 8003622:	2800      	cmp	r0, #0
 8003624:	d1b1      	bne.n	800358a <test_004_006_execute.9172+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003626:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003628:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 800362a:	9803      	ldr	r0, [sp, #12]
 800362c:	4e20      	ldr	r6, [pc, #128]	; (80036b0 <test_004_006_execute.9172+0x150>)
 800362e:	3801      	subs	r0, #1
 8003630:	4243      	negs	r3, r0
 8003632:	4158      	adcs	r0, r3
 8003634:	b2c0      	uxtb	r0, r0
 8003636:	1c31      	adds	r1, r6, #0
 8003638:	f7fd f93a 	bl	80008b0 <_test_assert>
 800363c:	2800      	cmp	r0, #0
 800363e:	d1a4      	bne.n	800358a <test_004_006_execute.9172+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003640:	b662      	cpsie	i
  }

  /* [4.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8003642:	2306      	movs	r3, #6
 8003644:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003646:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8003648:	68a3      	ldr	r3, [r4, #8]
 800364a:	2b00      	cmp	r3, #0
 800364c:	dd1c      	ble.n	8003688 <test_004_006_execute.9172+0x128>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800364e:	f7fd fa37 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003652:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003654:	b672      	cpsid	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8003656:	9b03      	ldr	r3, [sp, #12]
 8003658:	4916      	ldr	r1, [pc, #88]	; (80036b4 <test_004_006_execute.9172+0x154>)
 800365a:	17d8      	asrs	r0, r3, #31
 800365c:	1ac3      	subs	r3, r0, r3
 800365e:	0fd8      	lsrs	r0, r3, #31
 8003660:	f7fd f926 	bl	80008b0 <_test_assert>
 8003664:	2800      	cmp	r0, #0
 8003666:	d000      	beq.n	800366a <test_004_006_execute.9172+0x10a>
 8003668:	e78f      	b.n	800358a <test_004_006_execute.9172+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800366a:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800366c:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 800366e:	9803      	ldr	r0, [sp, #12]
 8003670:	1c31      	adds	r1, r6, #0
 8003672:	3801      	subs	r0, #1
 8003674:	4243      	negs	r3, r0
 8003676:	4158      	adcs	r0, r3
 8003678:	b2c0      	uxtb	r0, r0
 800367a:	f7fd f919 	bl	80008b0 <_test_assert>
 800367e:	e784      	b.n	800358a <test_004_006_execute.9172+0x2a>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 8003680:	1c20      	adds	r0, r4, #0
 8003682:	f7fe f855 	bl	8001730 <chSemSignalI>
 8003686:	e7c1      	b.n	800360c <test_004_006_execute.9172+0xac>
 8003688:	1c20      	adds	r0, r4, #0
 800368a:	f7fe f851 	bl	8001730 <chSemSignalI>
 800368e:	e7de      	b.n	800364e <test_004_006_execute.9172+0xee>
 8003690:	20000f44 	.word	0x20000f44
 8003694:	08005f60 	.word	0x08005f60
 8003698:	20000ed4 	.word	0x20000ed4
 800369c:	080036c1 	.word	0x080036c1
 80036a0:	20000518 	.word	0x20000518
 80036a4:	20000b84 	.word	0x20000b84
 80036a8:	08005f6c 	.word	0x08005f6c
 80036ac:	08005f80 	.word	0x08005f80
 80036b0:	08005f8c 	.word	0x08005f8c
 80036b4:	08005f64 	.word	0x08005f64
 80036b8:	46c0      	nop			; (mov r8, r8)
 80036ba:	46c0      	nop			; (mov r8, r8)
 80036bc:	46c0      	nop			; (mov r8, r8)
 80036be:	46c0      	nop			; (mov r8, r8)

080036c0 <thread4.9142.4217>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {
 80036c0:	b508      	push	{r3, lr}
 80036c2:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80036c4:	6883      	ldr	r3, [r0, #8]
 80036c6:	2b00      	cmp	r3, #0
 80036c8:	dd03      	ble.n	80036d2 <thread4.9142.4217+0x12>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80036ca:	f7fd f9f9 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036ce:	b662      	cpsie	i

  chBSemSignal((binary_semaphore_t *)p);
}
 80036d0:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 80036d2:	f7fe f82d 	bl	8001730 <chSemSignalI>
 80036d6:	e7f8      	b.n	80036ca <thread4.9142.4217+0xa>
 80036d8:	46c0      	nop			; (mov r8, r8)
 80036da:	46c0      	nop			; (mov r8, r8)
 80036dc:	46c0      	nop			; (mov r8, r8)
 80036de:	46c0      	nop			; (mov r8, r8)

080036e0 <test_001_002_execute.8569>:
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 80036e0:	b530      	push	{r4, r5, lr}
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 80036e2:	4c27      	ldr	r4, [pc, #156]	; (8003780 <test_001_002_execute.8569+0xa0>)
 80036e4:	2501      	movs	r5, #1
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 80036e6:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 80036e8:	6025      	str	r5, [r4, #0]
  {
    sts = chSysGetStatusAndLockX();
 80036ea:	f7fe f8e9 	bl	80018c0 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 80036ee:	4205      	tst	r5, r0
 80036f0:	d101      	bne.n	80036f6 <test_001_002_execute.8569+0x16>
 80036f2:	f7fd fa75 	bl	8000be0 <chSysRestoreStatusX.part.2.4295>
    chSysRestoreStatusX(sts);
  }

  /* [1.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 80036f6:	2302      	movs	r3, #2
 80036f8:	6023      	str	r3, [r4, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80036fa:	b672      	cpsid	i
  {
    chSysLock();
    sts = chSysGetStatusAndLockX();
 80036fc:	f7fe f8e0 	bl	80018c0 <chSysGetStatusAndLockX>
 8003700:	07c2      	lsls	r2, r0, #31
 8003702:	d401      	bmi.n	8003708 <test_001_002_execute.8569+0x28>
 8003704:	f7fd fa6c 	bl	8000be0 <chSysRestoreStatusX.part.2.4295>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003708:	b662      	cpsie	i
    chSysRestoreStatusX(sts);
    chSysUnlock();
  }

  /* [1.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 800370a:	2303      	movs	r3, #3
 800370c:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800370e:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8003712:	07da      	lsls	r2, r3, #31
 8003714:	d400      	bmi.n	8003718 <test_001_002_execute.8569+0x38>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003716:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003718:	f3ef 8310 	mrs	r3, PRIMASK
 800371c:	07da      	lsls	r2, r3, #31
 800371e:	d400      	bmi.n	8003722 <test_001_002_execute.8569+0x42>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003720:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003722:	b662      	cpsie	i
    chSysUnconditionalLock();
    chSysUnlock();
  }

  /* [1.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8003724:	2304      	movs	r3, #4
 8003726:	6023      	str	r3, [r4, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003728:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800372a:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800372e:	07da      	lsls	r2, r3, #31
 8003730:	d500      	bpl.n	8003734 <test_001_002_execute.8569+0x54>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003732:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003734:	f3ef 8310 	mrs	r3, PRIMASK
 8003738:	07da      	lsls	r2, r3, #31
 800373a:	d500      	bpl.n	800373e <test_001_002_execute.8569+0x5e>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800373c:	b662      	cpsie	i
    chSysUnconditionalUnlock();
    chSysUnconditionalUnlock();
  }

  /* [1.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 800373e:	2305      	movs	r3, #5
 8003740:	6023      	str	r3, [r4, #0]
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8003742:	2300      	movs	r3, #0
 8003744:	9304      	str	r3, [sp, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003746:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003748:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 800374a:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800374c:	2b00      	cmp	r3, #0
 800374e:	d002      	beq.n	8003756 <test_001_002_execute.8569+0x76>
    chVTDoResetI(vtp);
 8003750:	1c20      	adds	r0, r4, #0
 8003752:	f001 fc2d 	bl	8004fb0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8003756:	1c20      	adds	r0, r4, #0
 8003758:	2101      	movs	r1, #1
 800375a:	4a0a      	ldr	r2, [pc, #40]	; (8003784 <test_001_002_execute.8569+0xa4>)
 800375c:	2300      	movs	r3, #0
 800375e:	f001 fc67 	bl	8005030 <chVTDoSetI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003762:	b662      	cpsie	i
  {
    chVTObjectInit(&vt);
    chVTSet(&vt, 1, vtcb, NULL);
    chThdSleep(10);
 8003764:	200a      	movs	r0, #10
 8003766:	f7ff fb63 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800376a:	b672      	cpsid	i
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800376c:	9804      	ldr	r0, [sp, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800376e:	b662      	cpsie	i

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8003770:	4243      	negs	r3, r0
 8003772:	4158      	adcs	r0, r3
 8003774:	4904      	ldr	r1, [pc, #16]	; (8003788 <test_001_002_execute.8569+0xa8>)
 8003776:	b2c0      	uxtb	r0, r0
 8003778:	f7fd f89a 	bl	80008b0 <_test_assert>
  }
}
 800377c:	b007      	add	sp, #28
 800377e:	bd30      	pop	{r4, r5, pc}
 8003780:	20000f44 	.word	0x20000f44
 8003784:	08003ea1 	.word	0x08003ea1
 8003788:	08005fa0 	.word	0x08005fa0
 800378c:	46c0      	nop			; (mov r8, r8)
 800378e:	46c0      	nop			; (mov r8, r8)

08003790 <VectorB0.4272>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8003790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8003792:	4c53      	ldr	r4, [pc, #332]	; (80038e0 <VectorB0.4272+0x150>)
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8003794:	4646      	mov	r6, r8
 8003796:	464f      	mov	r7, r9
 8003798:	b4c0      	push	{r6, r7}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 800379a:	6f66      	ldr	r6, [r4, #116]	; 0x74
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800379c:	46f0      	mov	r8, lr
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 800379e:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80037a0:	69f5      	ldr	r5, [r6, #28]
  u->ICR = isr;
 80037a2:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80037a4:	072a      	lsls	r2, r5, #28
 80037a6:	d13d      	bne.n	8003824 <VectorB0.4272+0x94>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80037a8:	06aa      	lsls	r2, r5, #26
 80037aa:	d417      	bmi.n	80037dc <VectorB0.4272+0x4c>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 80037ac:	2380      	movs	r3, #128	; 0x80
 80037ae:	423b      	tst	r3, r7
 80037b0:	d001      	beq.n	80037b6 <VectorB0.4272+0x26>
 80037b2:	422b      	tst	r3, r5
 80037b4:	d14c      	bne.n	8003850 <VectorB0.4272+0xc0>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 80037b6:	066b      	lsls	r3, r5, #25
 80037b8:	d509      	bpl.n	80037ce <VectorB0.4272+0x3e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037ba:	b672      	cpsid	i
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 80037bc:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80037be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80037c0:	429a      	cmp	r2, r3
 80037c2:	d100      	bne.n	80037c6 <VectorB0.4272+0x36>
 80037c4:	e068      	b.n	8003898 <VectorB0.4272+0x108>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80037c6:	2340      	movs	r3, #64	; 0x40
 80037c8:	439f      	bics	r7, r3
 80037ca:	6037      	str	r7, [r6, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80037cc:	b662      	cpsie	i

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 80037ce:	4640      	mov	r0, r8
 80037d0:	f7fd f8e6 	bl	80009a0 <_port_irq_epilogue>
}
 80037d4:	bc0c      	pop	{r2, r3}
 80037d6:	4690      	mov	r8, r2
 80037d8:	4699      	mov	r9, r3
 80037da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037dc:	b672      	cpsid	i
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80037de:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 80037e0:	b2db      	uxtb	r3, r3
 80037e2:	4699      	mov	r9, r3
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80037e4:	6963      	ldr	r3, [r4, #20]
 80037e6:	2b00      	cmp	r3, #0
 80037e8:	d05f      	beq.n	80038aa <VectorB0.4272+0x11a>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 80037ea:	6a23      	ldr	r3, [r4, #32]
 80037ec:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80037ee:	4293      	cmp	r3, r2
 80037f0:	d060      	beq.n	80038b4 <VectorB0.4272+0x124>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 80037f2:	6962      	ldr	r2, [r4, #20]
 80037f4:	3201      	adds	r2, #1
 80037f6:	6162      	str	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
 80037f8:	1c5a      	adds	r2, r3, #1
 80037fa:	6222      	str	r2, [r4, #32]
 80037fc:	464a      	mov	r2, r9
 80037fe:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003800:	6a23      	ldr	r3, [r4, #32]
 8003802:	69e2      	ldr	r2, [r4, #28]
 8003804:	4293      	cmp	r3, r2
 8003806:	d244      	bcs.n	8003892 <VectorB0.4272+0x102>
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8003808:	1c23      	adds	r3, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800380a:	68e0      	ldr	r0, [r4, #12]
 800380c:	330c      	adds	r3, #12
 800380e:	4298      	cmp	r0, r3
 8003810:	d006      	beq.n	8003820 <VectorB0.4272+0x90>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003812:	6802      	ldr	r2, [r0, #0]
 8003814:	60e2      	str	r2, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003816:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003818:	2300      	movs	r3, #0
 800381a:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800381c:	f7fd fb08 	bl	8000e30 <chSchReadyI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003820:	b662      	cpsie	i
 8003822:	e7c3      	b.n	80037ac <VectorB0.4272+0x1c>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8003824:	0729      	lsls	r1, r5, #28
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;
 8003826:	0fc9      	lsrs	r1, r1, #31
 8003828:	01c9      	lsls	r1, r1, #7

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (isr & USART_ISR_PE)
 800382a:	07eb      	lsls	r3, r5, #31
 800382c:	d501      	bpl.n	8003832 <VectorB0.4272+0xa2>
    sts |= SD_PARITY_ERROR;
 800382e:	2320      	movs	r3, #32
 8003830:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 8003832:	07aa      	lsls	r2, r5, #30
 8003834:	d501      	bpl.n	800383a <VectorB0.4272+0xaa>
    sts |= SD_FRAMING_ERROR;
 8003836:	2340      	movs	r3, #64	; 0x40
 8003838:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 800383a:	076b      	lsls	r3, r5, #29
 800383c:	d502      	bpl.n	8003844 <VectorB0.4272+0xb4>
    sts |= SD_NOISE_ERROR;
 800383e:	2380      	movs	r3, #128	; 0x80
 8003840:	005b      	lsls	r3, r3, #1
 8003842:	4319      	orrs	r1, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003844:	b672      	cpsid	i
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8003846:	4827      	ldr	r0, [pc, #156]	; (80038e4 <VectorB0.4272+0x154>)
 8003848:	f7fd fb62 	bl	8000f10 <chEvtBroadcastFlagsI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800384c:	b662      	cpsie	i
 800384e:	e7ab      	b.n	80037a8 <VectorB0.4272+0x18>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003850:	b672      	cpsid	i
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8003852:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003854:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8003856:	429a      	cmp	r2, r3
 8003858:	d034      	beq.n	80038c4 <VectorB0.4272+0x134>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 800385a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800385c:	3201      	adds	r2, #1
 800385e:	63a2      	str	r2, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8003860:	1c5a      	adds	r2, r3, #1
 8003862:	64a2      	str	r2, [r4, #72]	; 0x48
 8003864:	781b      	ldrb	r3, [r3, #0]
 8003866:	4699      	mov	r9, r3
  if (oqp->q_rdptr >= oqp->q_top) {
 8003868:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800386a:	429a      	cmp	r2, r3
 800386c:	d301      	bcc.n	8003872 <VectorB0.4272+0xe2>
    oqp->q_rdptr = oqp->q_buffer;
 800386e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003870:	64a3      	str	r3, [r4, #72]	; 0x48
 8003872:	1c23      	adds	r3, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003874:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003876:	3330      	adds	r3, #48	; 0x30
 8003878:	4298      	cmp	r0, r3
 800387a:	d006      	beq.n	800388a <VectorB0.4272+0xfa>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800387c:	6802      	ldr	r2, [r0, #0]
 800387e:	6322      	str	r2, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 8003880:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003882:	2300      	movs	r3, #0
 8003884:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003886:	f7fd fad3 	bl	8000e30 <chSchReadyI>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 800388a:	464a      	mov	r2, r9
 800388c:	8532      	strh	r2, [r6, #40]	; 0x28
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800388e:	b662      	cpsie	i
 8003890:	e791      	b.n	80037b6 <VectorB0.4272+0x26>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 8003892:	69a3      	ldr	r3, [r4, #24]
 8003894:	6223      	str	r3, [r4, #32]
 8003896:	e7b7      	b.n	8003808 <VectorB0.4272+0x78>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8003898:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800389a:	2b00      	cmp	r3, #0
 800389c:	d100      	bne.n	80038a0 <VectorB0.4272+0x110>
 800389e:	e792      	b.n	80037c6 <VectorB0.4272+0x36>
 80038a0:	1d20      	adds	r0, r4, #4
 80038a2:	2110      	movs	r1, #16
 80038a4:	f7fd fb34 	bl	8000f10 <chEvtBroadcastFlagsI>
 80038a8:	e78d      	b.n	80037c6 <VectorB0.4272+0x36>
 80038aa:	1d20      	adds	r0, r4, #4
 80038ac:	2104      	movs	r1, #4
 80038ae:	f7fd fb2f 	bl	8000f10 <chEvtBroadcastFlagsI>
 80038b2:	e79a      	b.n	80037ea <VectorB0.4272+0x5a>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 80038b4:	6962      	ldr	r2, [r4, #20]
 80038b6:	2a00      	cmp	r2, #0
 80038b8:	d09b      	beq.n	80037f2 <VectorB0.4272+0x62>
 80038ba:	1d20      	adds	r0, r4, #4
 80038bc:	2180      	movs	r1, #128	; 0x80
 80038be:	f7fd fb27 	bl	8000f10 <chEvtBroadcastFlagsI>
 80038c2:	e7ad      	b.n	8003820 <VectorB0.4272+0x90>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80038c4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80038c6:	2a00      	cmp	r2, #0
 80038c8:	d0c7      	beq.n	800385a <VectorB0.4272+0xca>
 80038ca:	1d20      	adds	r0, r4, #4
 80038cc:	2108      	movs	r1, #8
 80038ce:	f7fd fb1f 	bl	8000f10 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80038d2:	23c0      	movs	r3, #192	; 0xc0
 80038d4:	1c3a      	adds	r2, r7, #0
 80038d6:	439a      	bics	r2, r3
 80038d8:	2340      	movs	r3, #64	; 0x40
 80038da:	4313      	orrs	r3, r2
 80038dc:	6033      	str	r3, [r6, #0]
 80038de:	e7d6      	b.n	800388e <VectorB0.4272+0xfe>
 80038e0:	20000e54 	.word	0x20000e54
 80038e4:	20000e58 	.word	0x20000e58
 80038e8:	46c0      	nop			; (mov r8, r8)
 80038ea:	46c0      	nop			; (mov r8, r8)
 80038ec:	46c0      	nop			; (mov r8, r8)
 80038ee:	46c0      	nop			; (mov r8, r8)

080038f0 <evt_thread7.9754>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(evt_thread7, p) {
 80038f0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038f2:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80038f4:	4809      	ldr	r0, [pc, #36]	; (800391c <evt_thread7.9754+0x2c>)
 80038f6:	2100      	movs	r1, #0
 80038f8:	f7fd fb0a 	bl	8000f10 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80038fc:	f7fd f8e0 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003900:	b662      	cpsie	i

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8003902:	2032      	movs	r0, #50	; 0x32
 8003904:	f7ff fa94 	bl	8002e30 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003908:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 800390a:	4805      	ldr	r0, [pc, #20]	; (8003920 <evt_thread7.9754+0x30>)
 800390c:	2100      	movs	r1, #0
 800390e:	f7fd faff 	bl	8000f10 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8003912:	f7fd f8d5 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003916:	b662      	cpsie	i
  chEvtBroadcast(&es2);
}
 8003918:	bd08      	pop	{r3, pc}
 800391a:	46c0      	nop			; (mov r8, r8)
 800391c:	20000454 	.word	0x20000454
 8003920:	20000428 	.word	0x20000428
 8003924:	46c0      	nop			; (mov r8, r8)
 8003926:	46c0      	nop			; (mov r8, r8)
 8003928:	46c0      	nop			; (mov r8, r8)
 800392a:	46c0      	nop			; (mov r8, r8)
 800392c:	46c0      	nop			; (mov r8, r8)
 800392e:	46c0      	nop			; (mov r8, r8)

08003930 <test_003_001_execute.8962>:

static void test_003_001_execute(void) {
 8003930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003932:	4646      	mov	r6, r8
 8003934:	464f      	mov	r7, r9
 8003936:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003938:	4d30      	ldr	r5, [pc, #192]	; (80039fc <test_003_001_execute.8962+0xcc>)
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 800393a:	4e31      	ldr	r6, [pc, #196]	; (8003a00 <test_003_001_execute.8962+0xd0>)
 800393c:	2301      	movs	r3, #1
 800393e:	6033      	str	r3, [r6, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003940:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8003942:	4a30      	ldr	r2, [pc, #192]	; (8003a04 <test_003_001_execute.8962+0xd4>)
 8003944:	6899      	ldr	r1, [r3, #8]
 8003946:	4830      	ldr	r0, [pc, #192]	; (8003a08 <test_003_001_execute.8962+0xd8>)
 8003948:	3901      	subs	r1, #1
 800394a:	4b30      	ldr	r3, [pc, #192]	; (8003a0c <test_003_001_execute.8962+0xdc>)
 800394c:	f001 fc58 	bl	8005200 <chThdCreateStatic.constprop.52>
 8003950:	4b2f      	ldr	r3, [pc, #188]	; (8003a10 <test_003_001_execute.8962+0xe0>)
 8003952:	6018      	str	r0, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003954:	b672      	cpsid	i

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003956:	4c2f      	ldr	r4, [pc, #188]	; (8003a14 <test_003_001_execute.8962+0xe4>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003958:	69ab      	ldr	r3, [r5, #24]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800395a:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 800395c:	625c      	str	r4, [r3, #36]	; 0x24

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800395e:	6023      	str	r3, [r4, #0]
 8003960:	f7fd f9c6 	bl	8000cf0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8003964:	69ab      	ldr	r3, [r5, #24]
 8003966:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003968:	4690      	mov	r8, r2
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800396a:	b662      	cpsie	i
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 800396c:	6822      	ldr	r2, [r4, #0]
 800396e:	4f2a      	ldr	r7, [pc, #168]	; (8003a18 <test_003_001_execute.8962+0xe8>)
 8003970:	4250      	negs	r0, r2
 8003972:	4150      	adcs	r0, r2
 8003974:	b2c0      	uxtb	r0, r0
 8003976:	1c39      	adds	r1, r7, #0
 8003978:	f7fc ff9a 	bl	80008b0 <_test_assert>
 800397c:	2800      	cmp	r0, #0
 800397e:	d003      	beq.n	8003988 <test_003_001_execute.8962+0x58>
                            time + MS2ST(1000) + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
}
 8003980:	bc0c      	pop	{r2, r3}
 8003982:	4690      	mov	r8, r2
 8003984:	4699      	mov	r9, r3
 8003986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_OK == msg,"wrong returned message");
 8003988:	4642      	mov	r2, r8
 800398a:	4250      	negs	r0, r2
 800398c:	4150      	adcs	r0, r2
 800398e:	4b23      	ldr	r3, [pc, #140]	; (8003a1c <test_003_001_execute.8962+0xec>)
 8003990:	b2c0      	uxtb	r0, r0
 8003992:	1c19      	adds	r1, r3, #0
 8003994:	4699      	mov	r9, r3
 8003996:	f7fc ff8b 	bl	80008b0 <_test_assert>
 800399a:	2800      	cmp	r0, #0
 800399c:	d1f0      	bne.n	8003980 <test_003_001_execute.8962+0x50>
    test_wait_threads();
 800399e:	f7fe f92f 	bl	8001c00 <test_wait_threads>
  }

  /* [3.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 80039a2:	2302      	movs	r3, #2
 80039a4:	6033      	str	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80039a6:	b672      	cpsid	i
 80039a8:	4b1d      	ldr	r3, [pc, #116]	; (8003a20 <test_003_001_execute.8962+0xf0>)
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80039aa:	21fa      	movs	r1, #250	; 0xfa
 80039ac:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 80039ae:	69ab      	ldr	r3, [r5, #24]
 80039b0:	0089      	lsls	r1, r1, #2
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 80039b2:	625c      	str	r4, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80039b4:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80039b6:	6023      	str	r3, [r4, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80039b8:	f001 fb82 	bl	80050c0 <chSchGoSleepTimeoutS>
 80039bc:	b2b6      	uxth	r6, r6
 80039be:	1c05      	adds	r5, r0, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80039c0:	b662      	cpsie	i
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
 80039c2:	22fa      	movs	r2, #250	; 0xfa
 80039c4:	4b17      	ldr	r3, [pc, #92]	; (8003a24 <test_003_001_execute.8962+0xf4>)
 80039c6:	0092      	lsls	r2, r2, #2
 80039c8:	18b0      	adds	r0, r6, r2
 80039ca:	18f6      	adds	r6, r6, r3
 80039cc:	b280      	uxth	r0, r0
 80039ce:	b2b1      	uxth	r1, r6
 80039d0:	f7fc fdd6 	bl	8000580 <_test_assert_time_window.constprop.2>
 80039d4:	2800      	cmp	r0, #0
 80039d6:	d1d3      	bne.n	8003980 <test_003_001_execute.8962+0x50>
                            time + MS2ST(1000) + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 80039d8:	6820      	ldr	r0, [r4, #0]
 80039da:	1c39      	adds	r1, r7, #0
 80039dc:	4243      	negs	r3, r0
 80039de:	4158      	adcs	r0, r3
 80039e0:	b2c0      	uxtb	r0, r0
 80039e2:	f7fc ff65 	bl	80008b0 <_test_assert>
 80039e6:	2800      	cmp	r0, #0
 80039e8:	d1ca      	bne.n	8003980 <test_003_001_execute.8962+0x50>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 80039ea:	1c68      	adds	r0, r5, #1
 80039ec:	4245      	negs	r5, r0
 80039ee:	4168      	adcs	r0, r5
 80039f0:	4649      	mov	r1, r9
 80039f2:	b2c0      	uxtb	r0, r0
 80039f4:	f7fc ff5c 	bl	80008b0 <_test_assert>
 80039f8:	e7c2      	b.n	8003980 <test_003_001_execute.8962+0x50>
 80039fa:	46c0      	nop			; (mov r8, r8)
 80039fc:	20000ed4 	.word	0x20000ed4
 8003a00:	20000f44 	.word	0x20000f44
 8003a04:	08004ce1 	.word	0x08004ce1
 8003a08:	20000518 	.word	0x20000518
 8003a0c:	08005e04 	.word	0x08005e04
 8003a10:	20000b84 	.word	0x20000b84
 8003a14:	20000b80 	.word	0x20000b80
 8003a18:	08005fb4 	.word	0x08005fb4
 8003a1c:	08005d68 	.word	0x08005d68
 8003a20:	40000400 	.word	0x40000400
 8003a24:	000003e9 	.word	0x000003e9
 8003a28:	46c0      	nop			; (mov r8, r8)
 8003a2a:	46c0      	nop			; (mov r8, r8)
 8003a2c:	46c0      	nop			; (mov r8, r8)
 8003a2e:	46c0      	nop			; (mov r8, r8)

08003a30 <test_004_003_execute.9194>:

static void test_004_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_003_execute(void) {
 8003a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003a32:	4646      	mov	r6, r8
 8003a34:	464f      	mov	r7, r9
 8003a36:	b4c0      	push	{r6, r7}
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [4.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8003a38:	4e50      	ldr	r6, [pc, #320]	; (8003b7c <test_004_003_execute.9194+0x14c>)
 8003a3a:	2301      	movs	r3, #1
 8003a3c:	6033      	str	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a3e:	b672      	cpsid	i
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 8003a40:	4c4f      	ldr	r4, [pc, #316]	; (8003b80 <test_004_003_execute.9194+0x150>)
 8003a42:	2100      	movs	r1, #0
 8003a44:	1c20      	adds	r0, r4, #0
 8003a46:	f7fe fe83 	bl	8002750 <chSemWaitTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a4a:	b662      	cpsie	i
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8003a4c:	4d4d      	ldr	r5, [pc, #308]	; (8003b84 <test_004_003_execute.9194+0x154>)
 8003a4e:	3001      	adds	r0, #1
 8003a50:	4243      	negs	r3, r0
 8003a52:	4158      	adcs	r0, r3
 8003a54:	b2c0      	uxtb	r0, r0
 8003a56:	1c29      	adds	r1, r5, #0
 8003a58:	f7fc ff2a 	bl	80008b0 <_test_assert>
 8003a5c:	2800      	cmp	r0, #0
 8003a5e:	d003      	beq.n	8003a68 <test_004_003_execute.9194+0x38>
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
  }
}
 8003a60:	bc0c      	pop	{r2, r3}
 8003a62:	4690      	mov	r8, r2
 8003a64:	4699      	mov	r9, r3
 8003a66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8003a68:	6822      	ldr	r2, [r4, #0]
  /* [4.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003a6a:	4f47      	ldr	r7, [pc, #284]	; (8003b88 <test_004_003_execute.9194+0x158>)
 8003a6c:	1b10      	subs	r0, r2, r4
 8003a6e:	4243      	negs	r3, r0
 8003a70:	4158      	adcs	r0, r3
 8003a72:	b2c0      	uxtb	r0, r0
 8003a74:	1c39      	adds	r1, r7, #0
 8003a76:	f7fc ff1b 	bl	80008b0 <_test_assert>
 8003a7a:	2800      	cmp	r0, #0
 8003a7c:	d1f0      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 8003a7e:	68a2      	ldr	r2, [r4, #8]
 8003a80:	4250      	negs	r0, r2
 8003a82:	4150      	adcs	r0, r2
 8003a84:	4b41      	ldr	r3, [pc, #260]	; (8003b8c <test_004_003_execute.9194+0x15c>)
 8003a86:	b2c0      	uxtb	r0, r0
 8003a88:	1c19      	adds	r1, r3, #0
 8003a8a:	4698      	mov	r8, r3
 8003a8c:	f7fc ff10 	bl	80008b0 <_test_assert>
 8003a90:	2800      	cmp	r0, #0
 8003a92:	d1e5      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8003a94:	2302      	movs	r3, #2
 8003a96:	6033      	str	r3, [r6, #0]
 8003a98:	4b3d      	ldr	r3, [pc, #244]	; (8003b90 <test_004_003_execute.9194+0x160>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003a9a:	4a3e      	ldr	r2, [pc, #248]	; (8003b94 <test_004_003_execute.9194+0x164>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003a9c:	699b      	ldr	r3, [r3, #24]
 8003a9e:	483e      	ldr	r0, [pc, #248]	; (8003b98 <test_004_003_execute.9194+0x168>)
 8003aa0:	6899      	ldr	r1, [r3, #8]
 8003aa2:	2300      	movs	r3, #0
 8003aa4:	3901      	subs	r1, #1
 8003aa6:	f001 fbab 	bl	8005200 <chThdCreateStatic.constprop.52>
 8003aaa:	4b3c      	ldr	r3, [pc, #240]	; (8003b9c <test_004_003_execute.9194+0x16c>)
 8003aac:	6018      	str	r0, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003aae:	b672      	cpsid	i
 8003ab0:	21fa      	movs	r1, #250	; 0xfa
 8003ab2:	1c20      	adds	r0, r4, #0
 8003ab4:	0049      	lsls	r1, r1, #1
 8003ab6:	f7fe fe4b 	bl	8002750 <chSemWaitTimeoutS>
 8003aba:	4681      	mov	r9, r0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003abc:	b662      	cpsie	i
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_wait_threads();
 8003abe:	f7fe f89f 	bl	8001c00 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8003ac2:	464a      	mov	r2, r9
 8003ac4:	4250      	negs	r0, r2
 8003ac6:	4150      	adcs	r0, r2
 8003ac8:	b2c0      	uxtb	r0, r0
 8003aca:	1c29      	adds	r1, r5, #0
 8003acc:	f7fc fef0 	bl	80008b0 <_test_assert>
 8003ad0:	2800      	cmp	r0, #0
 8003ad2:	d1c5      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
 8003ad4:	6823      	ldr	r3, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003ad6:	1c39      	adds	r1, r7, #0
 8003ad8:	1b18      	subs	r0, r3, r4
 8003ada:	4243      	negs	r3, r0
 8003adc:	4158      	adcs	r0, r3
 8003ade:	b2c0      	uxtb	r0, r0
 8003ae0:	f7fc fee6 	bl	80008b0 <_test_assert>
 8003ae4:	2800      	cmp	r0, #0
 8003ae6:	d1bb      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 8003ae8:	68a2      	ldr	r2, [r4, #8]
 8003aea:	4641      	mov	r1, r8
 8003aec:	4250      	negs	r0, r2
 8003aee:	4150      	adcs	r0, r2
 8003af0:	b2c0      	uxtb	r0, r0
 8003af2:	f7fc fedd 	bl	80008b0 <_test_assert>
 8003af6:	2800      	cmp	r0, #0
 8003af8:	d1b2      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
  }

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
 8003afa:	2303      	movs	r3, #3
 8003afc:	6033      	str	r3, [r6, #0]
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 8003afe:	f7ff fb0f 	bl	8003120 <test_wait_tick>
 8003b02:	2641      	movs	r6, #65	; 0x41
 8003b04:	4681      	mov	r9, r0
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
 8003b06:	1c30      	adds	r0, r6, #0
 8003b08:	f7fc fd72 	bl	80005f0 <test_emit_token>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b0c:	b672      	cpsid	i
 8003b0e:	2132      	movs	r1, #50	; 0x32
 8003b10:	1c20      	adds	r0, r4, #0
 8003b12:	f7fe fe1d 	bl	8002750 <chSemWaitTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b16:	b662      	cpsie	i
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8003b18:	3001      	adds	r0, #1
 8003b1a:	4243      	negs	r3, r0
 8003b1c:	4158      	adcs	r0, r3
 8003b1e:	b2c0      	uxtb	r0, r0
 8003b20:	1c29      	adds	r1, r5, #0
 8003b22:	f7fc fec5 	bl	80008b0 <_test_assert>
 8003b26:	2800      	cmp	r0, #0
 8003b28:	d19a      	bne.n	8003a60 <test_004_003_execute.9194+0x30>
 8003b2a:	6823      	ldr	r3, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003b2c:	1c39      	adds	r1, r7, #0
 8003b2e:	1b18      	subs	r0, r3, r4
 8003b30:	4243      	negs	r3, r0
 8003b32:	4158      	adcs	r0, r3
 8003b34:	b2c0      	uxtb	r0, r0
 8003b36:	f7fc febb 	bl	80008b0 <_test_assert>
 8003b3a:	2800      	cmp	r0, #0
 8003b3c:	d000      	beq.n	8003b40 <test_004_003_execute.9194+0x110>
 8003b3e:	e78f      	b.n	8003a60 <test_004_003_execute.9194+0x30>
      test_assert(sem1.cnt == 0, "counter not zero");
 8003b40:	68a2      	ldr	r2, [r4, #8]
 8003b42:	4641      	mov	r1, r8
 8003b44:	4250      	negs	r0, r2
 8003b46:	4150      	adcs	r0, r2
 8003b48:	b2c0      	uxtb	r0, r0
 8003b4a:	f7fc feb1 	bl	80008b0 <_test_assert>
 8003b4e:	2800      	cmp	r0, #0
 8003b50:	d000      	beq.n	8003b54 <test_004_003_execute.9194+0x124>
 8003b52:	e785      	b.n	8003a60 <test_004_003_execute.9194+0x30>
 8003b54:	3601      	adds	r6, #1
 8003b56:	b2f6      	uxtb	r6, r6

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
 8003b58:	2e46      	cmp	r6, #70	; 0x46
 8003b5a:	d1d4      	bne.n	8003b06 <test_004_003_execute.9194+0xd6>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8003b5c:	4810      	ldr	r0, [pc, #64]	; (8003ba0 <test_004_003_execute.9194+0x170>)
 8003b5e:	4911      	ldr	r1, [pc, #68]	; (8003ba4 <test_004_003_execute.9194+0x174>)
 8003b60:	f7fc fe76 	bl	8000850 <_test_assert_sequence>
 8003b64:	2800      	cmp	r0, #0
 8003b66:	d000      	beq.n	8003b6a <test_004_003_execute.9194+0x13a>
 8003b68:	e77a      	b.n	8003a60 <test_004_003_execute.9194+0x30>
  }

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 8003b6a:	4648      	mov	r0, r9
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003b6c:	4649      	mov	r1, r9
  }

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 8003b6e:	30fa      	adds	r0, #250	; 0xfa
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003b70:	31fc      	adds	r1, #252	; 0xfc
 8003b72:	b289      	uxth	r1, r1
 8003b74:	b280      	uxth	r0, r0
 8003b76:	f7fc fd03 	bl	8000580 <_test_assert_time_window.constprop.2>
 8003b7a:	e771      	b.n	8003a60 <test_004_003_execute.9194+0x30>
 8003b7c:	20000f44 	.word	0x20000f44
 8003b80:	20000508 	.word	0x20000508
 8003b84:	08005eb8 	.word	0x08005eb8
 8003b88:	08005fc0 	.word	0x08005fc0
 8003b8c:	08005fd0 	.word	0x08005fd0
 8003b90:	20000ed4 	.word	0x20000ed4
 8003b94:	08003031 	.word	0x08003031
 8003b98:	20000518 	.word	0x20000518
 8003b9c:	20000b84 	.word	0x20000b84
 8003ba0:	08005e18 	.word	0x08005e18
 8003ba4:	08005df0 	.word	0x08005df0
 8003ba8:	46c0      	nop			; (mov r8, r8)
 8003baa:	46c0      	nop			; (mov r8, r8)
 8003bac:	46c0      	nop			; (mov r8, r8)
 8003bae:	46c0      	nop			; (mov r8, r8)

08003bb0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003bb0:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003bb2:	b672      	cpsid	i
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8003bb4:	4b0f      	ldr	r3, [pc, #60]	; (8003bf4 <chThdExit+0x44>)
 8003bb6:	699c      	ldr	r4, [r3, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8003bb8:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8003bba:	1c25      	adds	r5, r4, #0
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8003bbc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8003bbe:	3528      	adds	r5, #40	; 0x28
 8003bc0:	42a8      	cmp	r0, r5
 8003bc2:	d006      	beq.n	8003bd2 <chThdExit+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8003bc4:	6802      	ldr	r2, [r0, #0]
 8003bc6:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8003bc8:	f7fd f932 	bl	8000e30 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8003bcc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8003bce:	42a8      	cmp	r0, r5
 8003bd0:	d1f8      	bne.n	8003bc4 <chThdExit+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8003bd2:	2322      	movs	r3, #34	; 0x22
 8003bd4:	5ce3      	ldrb	r3, [r4, r3]
 8003bd6:	2b00      	cmp	r3, #0
 8003bd8:	d108      	bne.n	8003bec <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8003bda:	2321      	movs	r3, #33	; 0x21
 8003bdc:	5ce3      	ldrb	r3, [r4, r3]

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8003bde:	079a      	lsls	r2, r3, #30
 8003be0:	d104      	bne.n	8003bec <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8003be2:	6922      	ldr	r2, [r4, #16]
 8003be4:	6963      	ldr	r3, [r4, #20]
 8003be6:	611a      	str	r2, [r3, #16]
 8003be8:	6922      	ldr	r2, [r4, #16]
 8003bea:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003bec:	200f      	movs	r0, #15
 8003bee:	f7fd f87f 	bl	8000cf0 <chSchGoSleepS>
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8003bf2:	bd38      	pop	{r3, r4, r5, pc}
 8003bf4:	20000ed4 	.word	0x20000ed4
 8003bf8:	46c0      	nop			; (mov r8, r8)
 8003bfa:	46c0      	nop			; (mov r8, r8)
 8003bfc:	46c0      	nop			; (mov r8, r8)
 8003bfe:	46c0      	nop			; (mov r8, r8)

08003c00 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8003c00:	4a0d      	ldr	r2, [pc, #52]	; (8003c38 <chSchDoReschedule+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8003c02:	b510      	push	{r4, lr}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8003c04:	6810      	ldr	r0, [r2, #0]
  thread_t *otp = currp;
 8003c06:	6991      	ldr	r1, [r2, #24]

  tqp->next             = tp->queue.next;
 8003c08:	6803      	ldr	r3, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8003c0a:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8003c0c:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003c0e:	6013      	str	r3, [r2, #0]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003c10:	6190      	str	r0, [r2, #24]
  currp->state = CH_STATE_CURRENT;
 8003c12:	2220      	movs	r2, #32
 8003c14:	5484      	strb	r4, [r0, r2]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003c16:	2400      	movs	r4, #0
 8003c18:	548c      	strb	r4, [r1, r2]
 8003c1a:	688a      	ldr	r2, [r1, #8]
 8003c1c:	e000      	b.n	8003c20 <chSchDoReschedule+0x20>
 8003c1e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8003c20:	689c      	ldr	r4, [r3, #8]
 8003c22:	4294      	cmp	r4, r2
 8003c24:	d8fb      	bhi.n	8003c1e <chSchDoReschedule+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003c26:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003c28:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8003c2a:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8003c2c:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8003c2e:	6059      	str	r1, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003c30:	f7fc face 	bl	80001d0 <_port_switch>
}
 8003c34:	bd10      	pop	{r4, pc}
 8003c36:	46c0      	nop			; (mov r8, r8)
 8003c38:	20000ed4 	.word	0x20000ed4
 8003c3c:	46c0      	nop			; (mov r8, r8)
 8003c3e:	46c0      	nop			; (mov r8, r8)

08003c40 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003c40:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003c42:	4e0f      	ldr	r6, [pc, #60]	; (8003c80 <__init_ram_areas+0x40>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003c44:	2500      	movs	r5, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003c46:	1c37      	adds	r7, r6, #0
 8003c48:	3780      	adds	r7, #128	; 0x80
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;
 8003c4a:	6873      	ldr	r3, [r6, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8003c4c:	68b4      	ldr	r4, [r6, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8003c4e:	6831      	ldr	r1, [r6, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8003c50:	42a3      	cmp	r3, r4
 8003c52:	d20a      	bcs.n	8003c6a <__init_ram_areas+0x2a>
 8003c54:	1c1a      	adds	r2, r3, #0
      *p = *tp;
 8003c56:	c901      	ldmia	r1!, {r0}
 8003c58:	c201      	stmia	r2!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8003c5a:	42a2      	cmp	r2, r4
 8003c5c:	d3fb      	bcc.n	8003c56 <__init_ram_areas+0x16>
 8003c5e:	43da      	mvns	r2, r3
 8003c60:	1912      	adds	r2, r2, r4
 8003c62:	0892      	lsrs	r2, r2, #2
 8003c64:	3201      	adds	r2, #1
 8003c66:	0092      	lsls	r2, r2, #2
 8003c68:	189b      	adds	r3, r3, r2
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8003c6a:	68f2      	ldr	r2, [r6, #12]
 8003c6c:	4293      	cmp	r3, r2
 8003c6e:	d202      	bcs.n	8003c76 <__init_ram_areas+0x36>
      *p = 0;
 8003c70:	c320      	stmia	r3!, {r5}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8003c72:	4293      	cmp	r3, r2
 8003c74:	d3fc      	bcc.n	8003c70 <__init_ram_areas+0x30>
      *p = 0;
      p++;
    }
    rap++;
 8003c76:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003c78:	42be      	cmp	r6, r7
 8003c7a:	d3e6      	bcc.n	8003c4a <__init_ram_areas+0xa>
#endif
}
 8003c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c7e:	46c0      	nop			; (mov r8, r8)
 8003c80:	08005fe4 	.word	0x08005fe4
 8003c84:	46c0      	nop			; (mov r8, r8)
 8003c86:	46c0      	nop			; (mov r8, r8)
 8003c88:	46c0      	nop			; (mov r8, r8)
 8003c8a:	46c0      	nop			; (mov r8, r8)
 8003c8c:	46c0      	nop			; (mov r8, r8)
 8003c8e:	46c0      	nop			; (mov r8, r8)

08003c90 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003c90:	e7fe      	b.n	8003c90 <__default_exit>
 8003c92:	46c0      	nop			; (mov r8, r8)
 8003c94:	46c0      	nop			; (mov r8, r8)
 8003c96:	46c0      	nop			; (mov r8, r8)
 8003c98:	46c0      	nop			; (mov r8, r8)
 8003c9a:	46c0      	nop			; (mov r8, r8)
 8003c9c:	46c0      	nop			; (mov r8, r8)
 8003c9e:	46c0      	nop			; (mov r8, r8)

08003ca0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003ca0:	4770      	bx	lr
 8003ca2:	46c0      	nop			; (mov r8, r8)
 8003ca4:	46c0      	nop			; (mov r8, r8)
 8003ca6:	46c0      	nop			; (mov r8, r8)
 8003ca8:	46c0      	nop			; (mov r8, r8)
 8003caa:	46c0      	nop			; (mov r8, r8)
 8003cac:	46c0      	nop			; (mov r8, r8)
 8003cae:	46c0      	nop			; (mov r8, r8)

08003cb0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003cb0:	4770      	bx	lr
 8003cb2:	46c0      	nop			; (mov r8, r8)
 8003cb4:	46c0      	nop			; (mov r8, r8)
 8003cb6:	46c0      	nop			; (mov r8, r8)
 8003cb8:	46c0      	nop			; (mov r8, r8)
 8003cba:	46c0      	nop			; (mov r8, r8)
 8003cbc:	46c0      	nop			; (mov r8, r8)
 8003cbe:	46c0      	nop			; (mov r8, r8)

08003cc0 <test_007_001_execute.9774>:
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 8003cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8003cc2:	4c29      	ldr	r4, [pc, #164]	; (8003d68 <test_007_001_execute.9774+0xa8>)
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8003cc4:	4e29      	ldr	r6, [pc, #164]	; (8003d6c <test_007_001_execute.9774+0xac>)
 8003cc6:	2102      	movs	r1, #2
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 8003cc8:	b08b      	sub	sp, #44	; 0x2c
 8003cca:	6024      	str	r4, [r4, #0]
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8003ccc:	6031      	str	r1, [r6, #0]
 8003cce:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003cd0:	6820      	ldr	r0, [r4, #0]
  esp->next     = elp;
 8003cd2:	ab00      	add	r3, sp, #0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003cd4:	9000      	str	r0, [sp, #0]
  esp->next     = elp;
  elp->listener = currp;
 8003cd6:	4826      	ldr	r0, [pc, #152]	; (8003d70 <test_007_001_execute.9774+0xb0>)

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8003cd8:	6023      	str	r3, [r4, #0]
  elp->listener = currp;
 8003cda:	6987      	ldr	r7, [r0, #24]
  elp->events   = events;
 8003cdc:	2301      	movs	r3, #1
 8003cde:	9302      	str	r3, [sp, #8]
  elp->flags    = (eventflags_t)0;
 8003ce0:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 8003ce2:	425b      	negs	r3, r3
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8003ce4:	9701      	str	r7, [sp, #4]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8003ce6:	9203      	str	r2, [sp, #12]
  elp->wflags   = wflags;
 8003ce8:	9304      	str	r3, [sp, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003cea:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003cec:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003cee:	6827      	ldr	r7, [r4, #0]
  esp->next     = elp;
  elp->listener = currp;
 8003cf0:	6980      	ldr	r0, [r0, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003cf2:	ad05      	add	r5, sp, #20
 8003cf4:	9705      	str	r7, [sp, #20]
  esp->next     = elp;
 8003cf6:	6025      	str	r5, [r4, #0]
  elp->listener = currp;
 8003cf8:	6068      	str	r0, [r5, #4]
  elp->events   = events;
 8003cfa:	60a9      	str	r1, [r5, #8]
  elp->flags    = (eventflags_t)0;
 8003cfc:	60ea      	str	r2, [r5, #12]
  elp->wflags   = wflags;
 8003cfe:	612b      	str	r3, [r5, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d00:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d02:	b672      	cpsid	i
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8003d04:	6823      	ldr	r3, [r4, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
    chEvtRegisterMask(&es1, &el2, 2);
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8003d06:	4f1b      	ldr	r7, [pc, #108]	; (8003d74 <test_007_001_execute.9774+0xb4>)
 8003d08:	1b18      	subs	r0, r3, r4
 8003d0a:	1e43      	subs	r3, r0, #1
 8003d0c:	4198      	sbcs	r0, r3
 8003d0e:	b2c0      	uxtb	r0, r0
 8003d10:	1c39      	adds	r1, r7, #0
 8003d12:	f7fc fdcd 	bl	80008b0 <_test_assert>
 8003d16:	2800      	cmp	r0, #0
 8003d18:	d002      	beq.n	8003d20 <test_007_001_execute.9774+0x60>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d1a:	b662      	cpsie	i
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 8003d1c:	b00b      	add	sp, #44	; 0x2c
 8003d1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003d20:	b662      	cpsie	i
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8003d22:	2303      	movs	r3, #3
  {
    chEvtUnregister(&es1, &el1);
 8003d24:	1c20      	adds	r0, r4, #0
 8003d26:	4669      	mov	r1, sp
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8003d28:	6033      	str	r3, [r6, #0]
  {
    chEvtUnregister(&es1, &el1);
 8003d2a:	f7fc fe81 	bl	8000a30 <chEvtUnregister>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d2e:	b672      	cpsid	i
 8003d30:	6823      	ldr	r3, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8003d32:	1c39      	adds	r1, r7, #0
 8003d34:	1b18      	subs	r0, r3, r4
 8003d36:	1e43      	subs	r3, r0, #1
 8003d38:	4198      	sbcs	r0, r3
 8003d3a:	b2c0      	uxtb	r0, r0
 8003d3c:	f7fc fdb8 	bl	80008b0 <_test_assert>
 8003d40:	2800      	cmp	r0, #0
 8003d42:	d1ea      	bne.n	8003d1a <test_007_001_execute.9774+0x5a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d44:	b662      	cpsie	i
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8003d46:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el2);
 8003d48:	1c20      	adds	r0, r4, #0
 8003d4a:	1c29      	adds	r1, r5, #0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8003d4c:	6033      	str	r3, [r6, #0]
  {
    chEvtUnregister(&es1, &el2);
 8003d4e:	f7fc fe6f 	bl	8000a30 <chEvtUnregister>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d52:	b672      	cpsid	i
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8003d54:	6827      	ldr	r7, [r4, #0]
 8003d56:	4908      	ldr	r1, [pc, #32]	; (8003d78 <test_007_001_execute.9774+0xb8>)
 8003d58:	1b38      	subs	r0, r7, r4
 8003d5a:	4244      	negs	r4, r0
 8003d5c:	4160      	adcs	r0, r4
 8003d5e:	b2c0      	uxtb	r0, r0
 8003d60:	f7fc fda6 	bl	80008b0 <_test_assert>
 8003d64:	e7d9      	b.n	8003d1a <test_007_001_execute.9774+0x5a>
 8003d66:	46c0      	nop			; (mov r8, r8)
 8003d68:	20000454 	.word	0x20000454
 8003d6c:	20000f44 	.word	0x20000f44
 8003d70:	20000ed4 	.word	0x20000ed4
 8003d74:	08006064 	.word	0x08006064
 8003d78:	08006070 	.word	0x08006070
 8003d7c:	46c0      	nop			; (mov r8, r8)
 8003d7e:	46c0      	nop			; (mov r8, r8)

08003d80 <test_007_007_execute.9772>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 8003d80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003d82:	4645      	mov	r5, r8
 8003d84:	4657      	mov	r7, sl
 8003d86:	464e      	mov	r6, r9
 8003d88:	b4e0      	push	{r5, r6, r7}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8003d8a:	4d38      	ldr	r5, [pc, #224]	; (8003e6c <test_007_007_execute.9772+0xec>)
 8003d8c:	2301      	movs	r3, #1
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 8003d8e:	b08a      	sub	sp, #40	; 0x28
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8003d90:	602b      	str	r3, [r5, #0]
 8003d92:	b672      	cpsid	i
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8003d94:	4e36      	ldr	r6, [pc, #216]	; (8003e70 <test_007_007_execute.9772+0xf0>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003d96:	4f37      	ldr	r7, [pc, #220]	; (8003e74 <test_007_007_execute.9772+0xf4>)
  esp->next     = elp;
  elp->listener = currp;
 8003d98:	69b2      	ldr	r2, [r6, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003d9a:	6838      	ldr	r0, [r7, #0]
  esp->next     = elp;
 8003d9c:	a900      	add	r1, sp, #0
  elp->listener = currp;
 8003d9e:	9201      	str	r2, [sp, #4]
  elp->events   = events;
 8003da0:	9302      	str	r3, [sp, #8]
  elp->flags    = (eventflags_t)0;
 8003da2:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 8003da4:	425b      	negs	r3, r3
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003da6:	9000      	str	r0, [sp, #0]
  esp->next     = elp;
 8003da8:	6039      	str	r1, [r7, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8003daa:	9203      	str	r2, [sp, #12]
  elp->wflags   = wflags;
 8003dac:	9304      	str	r3, [sp, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003dae:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003db0:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8003db2:	4831      	ldr	r0, [pc, #196]	; (8003e78 <test_007_007_execute.9772+0xf8>)
 8003db4:	ac05      	add	r4, sp, #20
 8003db6:	6801      	ldr	r1, [r0, #0]
 8003db8:	4680      	mov	r8, r0
 8003dba:	9105      	str	r1, [sp, #20]
  esp->next     = elp;
  elp->listener = currp;
 8003dbc:	69b1      	ldr	r1, [r6, #24]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8003dbe:	6004      	str	r4, [r0, #0]
  elp->listener = currp;
  elp->events   = events;
 8003dc0:	2004      	movs	r0, #4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8003dc2:	6061      	str	r1, [r4, #4]
  elp->events   = events;
 8003dc4:	4682      	mov	sl, r0
 8003dc6:	60a0      	str	r0, [r4, #8]
  elp->flags    = (eventflags_t)0;
 8003dc8:	60e2      	str	r2, [r4, #12]
  elp->wflags   = wflags;
 8003dca:	6123      	str	r3, [r4, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003dcc:	b662      	cpsie	i
  }

  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8003dce:	2302      	movs	r3, #2
 8003dd0:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8003dd2:	f7ff f9a5 	bl	8003120 <test_wait_tick>
 8003dd6:	69b3      	ldr	r3, [r6, #24]
 8003dd8:	4681      	mov	r9, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003dda:	6899      	ldr	r1, [r3, #8]
 8003ddc:	4a27      	ldr	r2, [pc, #156]	; (8003e7c <test_007_007_execute.9772+0xfc>)
 8003dde:	3901      	subs	r1, #1
 8003de0:	4b27      	ldr	r3, [pc, #156]	; (8003e80 <test_007_007_execute.9772+0x100>)
 8003de2:	4828      	ldr	r0, [pc, #160]	; (8003e84 <test_007_007_execute.9772+0x104>)
 8003de4:	f001 fa0c 	bl	8005200 <chThdCreateStatic.constprop.52>
 8003de8:	4b27      	ldr	r3, [pc, #156]	; (8003e88 <test_007_007_execute.9772+0x108>)
 8003dea:	6018      	str	r0, [r3, #0]
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8003dec:	2303      	movs	r3, #3
 8003dee:	602b      	str	r3, [r5, #0]
  {
    m = chEvtWaitAll(5);
 8003df0:	f001 fb36 	bl	8005460 <chEvtWaitAll.constprop.30>
  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8003df4:	4648      	mov	r0, r9
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003df6:	4649      	mov	r1, r9
  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8003df8:	3032      	adds	r0, #50	; 0x32
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003dfa:	3134      	adds	r1, #52	; 0x34
 8003dfc:	b280      	uxth	r0, r0
 8003dfe:	b289      	uxth	r1, r1
 8003e00:	f7fc fbbe 	bl	8000580 <_test_assert_time_window.constprop.2>
 8003e04:	2800      	cmp	r0, #0
 8003e06:	d005      	beq.n	8003e14 <test_007_007_execute.9772+0x94>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 8003e08:	b00a      	add	sp, #40	; 0x28
 8003e0a:	bc1c      	pop	{r2, r3, r4}
 8003e0c:	4690      	mov	r8, r2
 8003e0e:	4699      	mov	r9, r3
 8003e10:	46a2      	mov	sl, r4
 8003e12:	bdf0      	pop	{r4, r5, r6, r7, pc}
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003e14:	f001 faac 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 8003e18:	4243      	negs	r3, r0
 8003e1a:	4158      	adcs	r0, r3
 8003e1c:	b2c0      	uxtb	r0, r0
 8003e1e:	491b      	ldr	r1, [pc, #108]	; (8003e8c <test_007_007_execute.9772+0x10c>)
 8003e20:	f7fc fd46 	bl	80008b0 <_test_assert>
 8003e24:	2800      	cmp	r0, #0
 8003e26:	d1ef      	bne.n	8003e08 <test_007_007_execute.9772+0x88>
    test_wait_threads();
 8003e28:	f7fd feea 	bl	8001c00 <test_wait_threads>
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 8003e2c:	4652      	mov	r2, sl
  {
    chEvtUnregister(&es1, &el1);
 8003e2e:	1c38      	adds	r0, r7, #0
 8003e30:	4669      	mov	r1, sp
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 8003e32:	602a      	str	r2, [r5, #0]
  {
    chEvtUnregister(&es1, &el1);
 8003e34:	f7fc fdfc 	bl	8000a30 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 8003e38:	1c21      	adds	r1, r4, #0
 8003e3a:	4640      	mov	r0, r8
 8003e3c:	f7fc fdf8 	bl	8000a30 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8003e40:	683b      	ldr	r3, [r7, #0]
 8003e42:	4c13      	ldr	r4, [pc, #76]	; (8003e90 <test_007_007_execute.9772+0x110>)
 8003e44:	1bd8      	subs	r0, r3, r7
 8003e46:	4247      	negs	r7, r0
 8003e48:	4178      	adcs	r0, r7
 8003e4a:	b2c0      	uxtb	r0, r0
 8003e4c:	1c21      	adds	r1, r4, #0
 8003e4e:	f7fc fd2f 	bl	80008b0 <_test_assert>
 8003e52:	2800      	cmp	r0, #0
 8003e54:	d1d8      	bne.n	8003e08 <test_007_007_execute.9772+0x88>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 8003e56:	4641      	mov	r1, r8
 8003e58:	6809      	ldr	r1, [r1, #0]
 8003e5a:	4642      	mov	r2, r8
 8003e5c:	1a88      	subs	r0, r1, r2
 8003e5e:	4243      	negs	r3, r0
 8003e60:	4158      	adcs	r0, r3
 8003e62:	1c21      	adds	r1, r4, #0
 8003e64:	b2c0      	uxtb	r0, r0
 8003e66:	f7fc fd23 	bl	80008b0 <_test_assert>
 8003e6a:	e7cd      	b.n	8003e08 <test_007_007_execute.9772+0x88>
 8003e6c:	20000f44 	.word	0x20000f44
 8003e70:	20000ed4 	.word	0x20000ed4
 8003e74:	20000454 	.word	0x20000454
 8003e78:	20000428 	.word	0x20000428
 8003e7c:	080038f1 	.word	0x080038f1
 8003e80:	08005e04 	.word	0x08005e04
 8003e84:	20000518 	.word	0x20000518
 8003e88:	20000b84 	.word	0x20000b84
 8003e8c:	08005db4 	.word	0x08005db4
 8003e90:	08006070 	.word	0x08006070
 8003e94:	46c0      	nop			; (mov r8, r8)
 8003e96:	46c0      	nop			; (mov r8, r8)
 8003e98:	46c0      	nop			; (mov r8, r8)
 8003e9a:	46c0      	nop			; (mov r8, r8)
 8003e9c:	46c0      	nop			; (mov r8, r8)
 8003e9e:	46c0      	nop			; (mov r8, r8)

08003ea0 <vtcb.8548>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 8003ea0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ea2:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ea4:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ea6:	b672      	cpsid	i
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 8003ea8:	f7fd fd0a 	bl	80018c0 <chSysGetStatusAndLockX>
 8003eac:	07c3      	lsls	r3, r0, #31
 8003eae:	d401      	bmi.n	8003eb4 <vtcb.8548+0x14>
 8003eb0:	f7fc fe96 	bl	8000be0 <chSysRestoreStatusX.part.2.4295>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003eb4:	b662      	cpsie	i
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}
 8003eb6:	bd08      	pop	{r3, pc}
 8003eb8:	46c0      	nop			; (mov r8, r8)
 8003eba:	46c0      	nop			; (mov r8, r8)
 8003ebc:	46c0      	nop			; (mov r8, r8)
 8003ebe:	46c0      	nop			; (mov r8, r8)

08003ec0 <test_009_002_execute.10172>:

static void test_009_002_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_002_execute(void) {
 8003ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ec2:	4646      	mov	r6, r8
 8003ec4:	464f      	mov	r7, r9
 8003ec6:	b4c0      	push	{r6, r7}
  unsigned i;

  /* [9.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 8003ec8:	4f34      	ldr	r7, [pc, #208]	; (8003f9c <test_009_002_execute.10172+0xdc>)
 8003eca:	2301      	movs	r3, #1
 8003ecc:	603b      	str	r3, [r7, #0]
 8003ece:	4b34      	ldr	r3, [pc, #208]	; (8003fa0 <test_009_002_execute.10172+0xe0>)
 8003ed0:	4c34      	ldr	r4, [pc, #208]	; (8003fa4 <test_009_002_execute.10172+0xe4>)
 8003ed2:	2604      	movs	r6, #4
 8003ed4:	4698      	mov	r8, r3
 8003ed6:	1c1d      	adds	r5, r3, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ed8:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003eda:	68e3      	ldr	r3, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003edc:	1c20      	adds	r0, r4, #0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003ede:	602b      	str	r3, [r5, #0]
  mp->next = php;
 8003ee0:	60e5      	str	r5, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003ee2:	f7fd fc25 	bl	8001730 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8003ee6:	f7fc fdeb 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003eea:	b662      	cpsie	i
  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8003eec:	6923      	ldr	r3, [r4, #16]
 8003eee:	3e01      	subs	r6, #1
 8003ef0:	18ed      	adds	r5, r5, r3
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8003ef2:	2e00      	cmp	r6, #0
 8003ef4:	d1f0      	bne.n	8003ed8 <test_009_002_execute.10172+0x18>
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 8003ef6:	2302      	movs	r3, #2
 8003ef8:	603b      	str	r3, [r7, #0]
 8003efa:	4b2b      	ldr	r3, [pc, #172]	; (8003fa8 <test_009_002_execute.10172+0xe8>)
 8003efc:	2604      	movs	r6, #4
 8003efe:	4699      	mov	r9, r3
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8003f00:	2000      	movs	r0, #0
 8003f02:	f7fe fc45 	bl	8002790 <chGuardedPoolAllocTimeout.constprop.12>
 8003f06:	1e43      	subs	r3, r0, #1
 8003f08:	4198      	sbcs	r0, r3
 8003f0a:	b2c0      	uxtb	r0, r0
 8003f0c:	4649      	mov	r1, r9
 8003f0e:	f7fc fccf 	bl	80008b0 <_test_assert>
 8003f12:	2800      	cmp	r0, #0
 8003f14:	d13d      	bne.n	8003f92 <test_009_002_execute.10172+0xd2>
 8003f16:	3e01      	subs	r6, #1
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8003f18:	2e00      	cmp	r6, #0
 8003f1a:	d1f1      	bne.n	8003f00 <test_009_002_execute.10172+0x40>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.3] Now must be empty.*/
  test_set_step(3);
 8003f1c:	2303      	movs	r3, #3
 8003f1e:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8003f20:	f7fe fc36 	bl	8002790 <chGuardedPoolAllocTimeout.constprop.12>
 8003f24:	4e21      	ldr	r6, [pc, #132]	; (8003fac <test_009_002_execute.10172+0xec>)
 8003f26:	4243      	negs	r3, r0
 8003f28:	4158      	adcs	r0, r3
 8003f2a:	b2c0      	uxtb	r0, r0
 8003f2c:	1c31      	adds	r1, r6, #0
 8003f2e:	f7fc fcbf 	bl	80008b0 <_test_assert>
 8003f32:	2800      	cmp	r0, #0
 8003f34:	d12d      	bne.n	8003f92 <test_009_002_execute.10172+0xd2>
  }

  /* [9.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 8003f36:	2304      	movs	r3, #4
 8003f38:	4645      	mov	r5, r8
 8003f3a:	603b      	str	r3, [r7, #0]
 8003f3c:	2310      	movs	r3, #16
 8003f3e:	195b      	adds	r3, r3, r5
 8003f40:	4698      	mov	r8, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f42:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003f44:	68e3      	ldr	r3, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003f46:	1c20      	adds	r0, r4, #0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003f48:	602b      	str	r3, [r5, #0]
  mp->next = php;
 8003f4a:	60e5      	str	r5, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003f4c:	f7fd fbf0 	bl	8001730 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8003f50:	f7fc fdb6 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f54:	b662      	cpsie	i
 8003f56:	3504      	adds	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8003f58:	4545      	cmp	r5, r8
 8003f5a:	d1f2      	bne.n	8003f42 <test_009_002_execute.10172+0x82>
      chGuardedPoolFree(&gmp1, &objects[i]);
  }

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 8003f5c:	2305      	movs	r3, #5
 8003f5e:	603b      	str	r3, [r7, #0]
 8003f60:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8003f62:	2000      	movs	r0, #0
 8003f64:	f7fe fc14 	bl	8002790 <chGuardedPoolAllocTimeout.constprop.12>
 8003f68:	1e43      	subs	r3, r0, #1
 8003f6a:	4198      	sbcs	r0, r3
 8003f6c:	b2c0      	uxtb	r0, r0
 8003f6e:	4649      	mov	r1, r9
 8003f70:	f7fc fc9e 	bl	80008b0 <_test_assert>
 8003f74:	2800      	cmp	r0, #0
 8003f76:	d10c      	bne.n	8003f92 <test_009_002_execute.10172+0xd2>
 8003f78:	3c01      	subs	r4, #1

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8003f7a:	2c00      	cmp	r4, #0
 8003f7c:	d1f1      	bne.n	8003f62 <test_009_002_execute.10172+0xa2>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.6] Now must be empty again.*/
  test_set_step(6);
 8003f7e:	2306      	movs	r3, #6
 8003f80:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8003f82:	f7fe fc05 	bl	8002790 <chGuardedPoolAllocTimeout.constprop.12>
 8003f86:	4243      	negs	r3, r0
 8003f88:	4158      	adcs	r0, r3
 8003f8a:	b2c0      	uxtb	r0, r0
 8003f8c:	1c31      	adds	r1, r6, #0
 8003f8e:	f7fc fc8f 	bl	80008b0 <_test_assert>
  }
}
 8003f92:	bc0c      	pop	{r2, r3}
 8003f94:	4690      	mov	r8, r2
 8003f96:	4699      	mov	r9, r3
 8003f98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003f9a:	46c0      	nop			; (mov r8, r8)
 8003f9c:	20000f44 	.word	0x20000f44
 8003fa0:	20000be4 	.word	0x20000be4
 8003fa4:	20000464 	.word	0x20000464
 8003fa8:	08006080 	.word	0x08006080
 8003fac:	08005e48 	.word	0x08005e48

08003fb0 <bmk_thread1.10606.4180>:
#endif

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 8003fb0:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8003fb2:	f7fc fec5 	bl	8000d40 <chMsgWait>

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
  thread_t *tp;
 8003fb6:	6a44      	ldr	r4, [r0, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003fb8:	b672      	cpsid	i
 8003fba:	1c21      	adds	r1, r4, #0
 8003fbc:	f7fc fe20 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003fc0:	b662      	cpsie	i
  (void)p;
  do {
    tp = chMsgWait();
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 8003fc2:	2c00      	cmp	r4, #0
 8003fc4:	d1f5      	bne.n	8003fb2 <bmk_thread1.10606.4180+0x2>
}
 8003fc6:	bd10      	pop	{r4, pc}
 8003fc8:	46c0      	nop			; (mov r8, r8)
 8003fca:	46c0      	nop			; (mov r8, r8)
 8003fcc:	46c0      	nop			; (mov r8, r8)
 8003fce:	46c0      	nop			; (mov r8, r8)

08003fd0 <test_009_001_execute.10176>:

static void test_009_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}

static void test_009_001_execute(void) {
 8003fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003fd2:	4646      	mov	r6, r8
 8003fd4:	464f      	mov	r7, r9
 8003fd6:	b4c0      	push	{r6, r7}
  unsigned i;

  /* [9.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 8003fd8:	4939      	ldr	r1, [pc, #228]	; (80040c0 <test_009_001_execute.10176+0xf0>)
 8003fda:	4e3a      	ldr	r6, [pc, #232]	; (80040c4 <test_009_001_execute.10176+0xf4>)
 8003fdc:	2301      	movs	r3, #1
 8003fde:	4c3a      	ldr	r4, [pc, #232]	; (80040c8 <test_009_001_execute.10176+0xf8>)
 8003fe0:	6033      	str	r3, [r6, #0]
 8003fe2:	2204      	movs	r2, #4
 8003fe4:	4688      	mov	r8, r1
 8003fe6:	1c0b      	adds	r3, r1, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003fe8:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003fea:	6821      	ldr	r1, [r4, #0]
  mp->next = php;
 8003fec:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003fee:	6019      	str	r1, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ff0:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8003ff2:	6861      	ldr	r1, [r4, #4]
 8003ff4:	3a01      	subs	r2, #1
 8003ff6:	185b      	adds	r3, r3, r1
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003ff8:	2a00      	cmp	r2, #0
 8003ffa:	d1f5      	bne.n	8003fe8 <test_009_001_execute.10176+0x18>
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 8003ffc:	2302      	movs	r3, #2
 8003ffe:	4f33      	ldr	r7, [pc, #204]	; (80040cc <test_009_001_execute.10176+0xfc>)
 8004000:	6033      	str	r3, [r6, #0]
 8004002:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8004004:	1c20      	adds	r0, r4, #0
 8004006:	f7fc fceb 	bl	80009e0 <chPoolAlloc>
 800400a:	1e43      	subs	r3, r0, #1
 800400c:	4198      	sbcs	r0, r3
 800400e:	b2c0      	uxtb	r0, r0
 8004010:	1c39      	adds	r1, r7, #0
 8004012:	f7fc fc4d 	bl	80008b0 <_test_assert>
 8004016:	2800      	cmp	r0, #0
 8004018:	d13c      	bne.n	8004094 <test_009_001_execute.10176+0xc4>
 800401a:	3d01      	subs	r5, #1
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800401c:	2d00      	cmp	r5, #0
 800401e:	d1f1      	bne.n	8004004 <test_009_001_execute.10176+0x34>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 8004020:	2303      	movs	r3, #3
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8004022:	1c20      	adds	r0, r4, #0
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 8004024:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8004026:	f7fc fcdb 	bl	80009e0 <chPoolAlloc>
 800402a:	4243      	negs	r3, r0
 800402c:	4158      	adcs	r0, r3
 800402e:	4b28      	ldr	r3, [pc, #160]	; (80040d0 <test_009_001_execute.10176+0x100>)
 8004030:	b2c0      	uxtb	r0, r0
 8004032:	1c19      	adds	r1, r3, #0
 8004034:	4699      	mov	r9, r3
 8004036:	f7fc fc3b 	bl	80008b0 <_test_assert>
 800403a:	2800      	cmp	r0, #0
 800403c:	d12a      	bne.n	8004094 <test_009_001_execute.10176+0xc4>
  }

  /* [9.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 800403e:	2304      	movs	r3, #4
 8004040:	4642      	mov	r2, r8
 8004042:	6033      	str	r3, [r6, #0]
 8004044:	3210      	adds	r2, #16
 8004046:	4643      	mov	r3, r8
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004048:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800404a:	6821      	ldr	r1, [r4, #0]
  mp->next = php;
 800404c:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800404e:	6019      	str	r1, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004050:	b662      	cpsie	i
 8004052:	3304      	adds	r3, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004054:	4293      	cmp	r3, r2
 8004056:	d1f7      	bne.n	8004048 <test_009_001_execute.10176+0x78>
      chPoolFree(&mp1, &objects[i]);
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 8004058:	2305      	movs	r3, #5
 800405a:	6033      	str	r3, [r6, #0]
 800405c:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800405e:	1c20      	adds	r0, r4, #0
 8004060:	f7fc fcbe 	bl	80009e0 <chPoolAlloc>
 8004064:	1e43      	subs	r3, r0, #1
 8004066:	4198      	sbcs	r0, r3
 8004068:	b2c0      	uxtb	r0, r0
 800406a:	1c39      	adds	r1, r7, #0
 800406c:	f7fc fc20 	bl	80008b0 <_test_assert>
 8004070:	2800      	cmp	r0, #0
 8004072:	d10f      	bne.n	8004094 <test_009_001_execute.10176+0xc4>
 8004074:	3d01      	subs	r5, #1
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004076:	2d00      	cmp	r5, #0
 8004078:	d1f1      	bne.n	800405e <test_009_001_execute.10176+0x8e>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800407a:	2306      	movs	r3, #6
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800407c:	1c20      	adds	r0, r4, #0
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800407e:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8004080:	f7fc fcae 	bl	80009e0 <chPoolAlloc>
 8004084:	4243      	negs	r3, r0
 8004086:	4158      	adcs	r0, r3
 8004088:	b2c0      	uxtb	r0, r0
 800408a:	4649      	mov	r1, r9
 800408c:	f7fc fc10 	bl	80008b0 <_test_assert>
 8004090:	2800      	cmp	r0, #0
 8004092:	d003      	beq.n	800409c <test_009_001_execute.10176+0xcc>
  test_set_step(7);
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
  }
}
 8004094:	bc0c      	pop	{r2, r3}
 8004096:	4690      	mov	r8, r2
 8004098:	4699      	mov	r9, r3
 800409a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  }

  /* [9.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 800409c:	2307      	movs	r3, #7
 800409e:	6033      	str	r3, [r6, #0]
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 80040a0:	2304      	movs	r3, #4
 80040a2:	6063      	str	r3, [r4, #4]
  mp->provider = provider;
 80040a4:	4b0b      	ldr	r3, [pc, #44]	; (80040d4 <test_009_001_execute.10176+0x104>)
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80040a6:	1c20      	adds	r0, r4, #0
 80040a8:	60a3      	str	r3, [r4, #8]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80040aa:	6025      	str	r5, [r4, #0]
 80040ac:	f7fc fc98 	bl	80009e0 <chPoolAlloc>
 80040b0:	4243      	negs	r3, r0
 80040b2:	4158      	adcs	r0, r3
 80040b4:	4908      	ldr	r1, [pc, #32]	; (80040d8 <test_009_001_execute.10176+0x108>)
 80040b6:	b2c0      	uxtb	r0, r0
 80040b8:	f7fc fbfa 	bl	80008b0 <_test_assert>
 80040bc:	e7ea      	b.n	8004094 <test_009_001_execute.10176+0xc4>
 80040be:	46c0      	nop			; (mov r8, r8)
 80040c0:	20000be4 	.word	0x20000be4
 80040c4:	20000f44 	.word	0x20000f44
 80040c8:	20000458 	.word	0x20000458
 80040cc:	08006080 	.word	0x08006080
 80040d0:	08005e48 	.word	0x08005e48
 80040d4:	08000321 	.word	0x08000321
 80040d8:	0800608c 	.word	0x0800608c
 80040dc:	46c0      	nop			; (mov r8, r8)
 80040de:	46c0      	nop			; (mov r8, r8)

080040e0 <test_012_004_execute.10631>:
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 80040e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80040e2:	4a28      	ldr	r2, [pc, #160]	; (8004184 <test_012_004_execute.10631+0xa4>)
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 80040e4:	464f      	mov	r7, r9
 80040e6:	4646      	mov	r6, r8
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80040e8:	2301      	movs	r3, #1
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 80040ea:	b4c0      	push	{r6, r7}
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80040ec:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80040ee:	4b26      	ldr	r3, [pc, #152]	; (8004188 <test_012_004_execute.10631+0xa8>)
 80040f0:	4691      	mov	r9, r2
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80040f2:	699b      	ldr	r3, [r3, #24]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80040f4:	4a25      	ldr	r2, [pc, #148]	; (800418c <test_012_004_execute.10631+0xac>)
 80040f6:	6899      	ldr	r1, [r3, #8]
 80040f8:	4825      	ldr	r0, [pc, #148]	; (8004190 <test_012_004_execute.10631+0xb0>)
 80040fa:	3101      	adds	r1, #1
 80040fc:	2300      	movs	r3, #0
 80040fe:	f001 f87f 	bl	8005200 <chThdCreateStatic.constprop.52>
 8004102:	4b24      	ldr	r3, [pc, #144]	; (8004194 <test_012_004_execute.10631+0xb4>)
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 8004104:	464a      	mov	r2, r9
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8004106:	6018      	str	r0, [r3, #0]
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 8004108:	2302      	movs	r3, #2
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800410a:	1c04      	adds	r4, r0, #0
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 800410c:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800410e:	f7ff f807 	bl	8003120 <test_wait_tick>
 8004112:	4f21      	ldr	r7, [pc, #132]	; (8004198 <test_012_004_execute.10631+0xb8>)
      chSysUnlock();
      n += 4;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004114:	4e21      	ldr	r6, [pc, #132]	; (800419c <test_012_004_execute.10631+0xbc>)
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8004116:	4680      	mov	r8, r0
     time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 8004118:	2500      	movs	r5, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800411a:	b672      	cpsid	i
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 800411c:	2100      	movs	r1, #0
 800411e:	1c20      	adds	r0, r4, #0
 8004120:	f7fc fd6e 	bl	8000c00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8004124:	1c20      	adds	r0, r4, #0
 8004126:	2100      	movs	r1, #0
 8004128:	f7fc fd6a 	bl	8000c00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800412c:	1c20      	adds	r0, r4, #0
 800412e:	2100      	movs	r1, #0
 8004130:	f7fc fd66 	bl	8000c00 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8004134:	1c20      	adds	r0, r4, #0
 8004136:	2100      	movs	r1, #0
 8004138:	f7fc fd62 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800413c:	b662      	cpsie	i
 800413e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8004140:	4642      	mov	r2, r8
 8004142:	1a9b      	subs	r3, r3, r2
      chSysUnlock();
      n += 4;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004144:	b29b      	uxth	r3, r3
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSysUnlock();
      n += 4;
 8004146:	3504      	adds	r5, #4
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004148:	42b3      	cmp	r3, r6
 800414a:	d9e6      	bls.n	800411a <test_012_004_execute.10631+0x3a>
  }

  /* [12.4.3] Stopping the target thread.*/
  test_set_step(3);
 800414c:	2303      	movs	r3, #3
 800414e:	464a      	mov	r2, r9
 8004150:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004152:	b672      	cpsid	i
  {
    chSysLock();
    chSchWakeupS(tp, MSG_TIMEOUT);
 8004154:	2101      	movs	r1, #1
 8004156:	1c20      	adds	r0, r4, #0
 8004158:	4249      	negs	r1, r1
 800415a:	f7fc fd51 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800415e:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 8004160:	f7fd fd4e 	bl	8001c00 <test_wait_threads>
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 8004164:	464a      	mov	r2, r9
 8004166:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8004168:	480d      	ldr	r0, [pc, #52]	; (80041a0 <test_012_004_execute.10631+0xc0>)
    chSysUnlock();
    test_wait_threads();
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 800416a:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 800416c:	f7fc fa98 	bl	80006a0 <test_print>
    test_printn(n * 2);
 8004170:	0068      	lsls	r0, r5, #1
 8004172:	f7fc faad 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 8004176:	480b      	ldr	r0, [pc, #44]	; (80041a4 <test_012_004_execute.10631+0xc4>)
 8004178:	f7fc fa72 	bl	8000660 <test_println>
  }
}
 800417c:	bc0c      	pop	{r2, r3}
 800417e:	4690      	mov	r8, r2
 8004180:	4699      	mov	r9, r3
 8004182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004184:	20000f44 	.word	0x20000f44
 8004188:	20000ed4 	.word	0x20000ed4
 800418c:	08000d21 	.word	0x08000d21
 8004190:	20000518 	.word	0x20000518
 8004194:	20000b84 	.word	0x20000b84
 8004198:	40000400 	.word	0x40000400
 800419c:	000003e7 	.word	0x000003e7
 80041a0:	08005d80 	.word	0x08005d80
 80041a4:	080060a8 	.word	0x080060a8
 80041a8:	46c0      	nop			; (mov r8, r8)
 80041aa:	46c0      	nop			; (mov r8, r8)
 80041ac:	46c0      	nop			; (mov r8, r8)
 80041ae:	46c0      	nop			; (mov r8, r8)

080041b0 <test_012_006_execute.10627>:
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void test_012_006_execute(void) {
 80041b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80041b2:	4b1c      	ldr	r3, [pc, #112]	; (8004224 <test_012_006_execute.10627+0x74>)
 80041b4:	465f      	mov	r7, fp
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80041b6:	699b      	ldr	r3, [r3, #24]
 80041b8:	4656      	mov	r6, sl
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 80041ba:	689b      	ldr	r3, [r3, #8]
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void test_012_006_execute(void) {
 80041bc:	464d      	mov	r5, r9
 80041be:	4644      	mov	r4, r8
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 80041c0:	4a19      	ldr	r2, [pc, #100]	; (8004228 <test_012_006_execute.10627+0x78>)
 * .
 */

static void test_012_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 80041c2:	3301      	adds	r3, #1
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void test_012_006_execute(void) {
 80041c4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 80041c6:	469a      	mov	sl, r3
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 80041c8:	2301      	movs	r3, #1
 80041ca:	6013      	str	r3, [r2, #0]
 80041cc:	4693      	mov	fp, r2
  {
    n = 0;
    start = test_wait_tick();
 80041ce:	f7fe ffa7 	bl	8003120 <test_wait_tick>
 80041d2:	4b16      	ldr	r3, [pc, #88]	; (800422c <test_012_006_execute.10627+0x7c>)
 80041d4:	4f16      	ldr	r7, [pc, #88]	; (8004230 <test_012_006_execute.10627+0x80>)
 80041d6:	4e17      	ldr	r6, [pc, #92]	; (8004234 <test_012_006_execute.10627+0x84>)
#endif
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80041d8:	4d17      	ldr	r5, [pc, #92]	; (8004238 <test_012_006_execute.10627+0x88>)
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  {
    n = 0;
    start = test_wait_tick();
 80041da:	4681      	mov	r9, r0
  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 80041dc:	2400      	movs	r4, #0
 80041de:	4698      	mov	r8, r3
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80041e0:	1c3a      	adds	r2, r7, #0
 80041e2:	2300      	movs	r3, #0
 80041e4:	4651      	mov	r1, sl
 80041e6:	4640      	mov	r0, r8
 80041e8:	f001 f80a 	bl	8005200 <chThdCreateStatic.constprop.52>
 80041ec:	f7fd fcc0 	bl	8001b70 <chThdRelease>
 80041f0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80041f2:	464a      	mov	r2, r9
 80041f4:	1a9b      	subs	r3, r3, r2
#endif
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80041f6:	b29b      	uxth	r3, r3
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 80041f8:	3401      	adds	r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80041fa:	42ab      	cmp	r3, r5
 80041fc:	d9f0      	bls.n	80041e0 <test_012_006_execute.10627+0x30>
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 80041fe:	465a      	mov	r2, fp
 8004200:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8004202:	480e      	ldr	r0, [pc, #56]	; (800423c <test_012_006_execute.10627+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 8004204:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8004206:	f7fc fa4b 	bl	80006a0 <test_print>
    test_printn(n);
 800420a:	1c20      	adds	r0, r4, #0
 800420c:	f7fc fa60 	bl	80006d0 <test_printn>
    test_println(" threads/S");
 8004210:	480b      	ldr	r0, [pc, #44]	; (8004240 <test_012_006_execute.10627+0x90>)
 8004212:	f7fc fa25 	bl	8000660 <test_println>
  }
}
 8004216:	bc3c      	pop	{r2, r3, r4, r5}
 8004218:	4690      	mov	r8, r2
 800421a:	4699      	mov	r9, r3
 800421c:	46a2      	mov	sl, r4
 800421e:	46ab      	mov	fp, r5
 8004220:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004222:	46c0      	nop			; (mov r8, r8)
 8004224:	20000ed4 	.word	0x20000ed4
 8004228:	20000f44 	.word	0x20000f44
 800422c:	20000518 	.word	0x20000518
 8004230:	08005b31 	.word	0x08005b31
 8004234:	40000400 	.word	0x40000400
 8004238:	000003e7 	.word	0x000003e7
 800423c:	08005d80 	.word	0x08005d80
 8004240:	080060b4 	.word	0x080060b4
 8004244:	46c0      	nop			; (mov r8, r8)
 8004246:	46c0      	nop			; (mov r8, r8)
 8004248:	46c0      	nop			; (mov r8, r8)
 800424a:	46c0      	nop			; (mov r8, r8)
 800424c:	46c0      	nop			; (mov r8, r8)
 800424e:	46c0      	nop			; (mov r8, r8)

08004250 <test_012_005_execute.10629>:
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void test_012_005_execute(void) {
 8004250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004252:	4b1c      	ldr	r3, [pc, #112]	; (80042c4 <test_012_005_execute.10629+0x74>)
 8004254:	465f      	mov	r7, fp
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004256:	699b      	ldr	r3, [r3, #24]
 8004258:	4656      	mov	r6, sl
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 800425a:	689b      	ldr	r3, [r3, #8]
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void test_012_005_execute(void) {
 800425c:	464d      	mov	r5, r9
 800425e:	4644      	mov	r4, r8
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8004260:	4a19      	ldr	r2, [pc, #100]	; (80042c8 <test_012_005_execute.10629+0x78>)
 * .
 */

static void test_012_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8004262:	3b01      	subs	r3, #1
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void test_012_005_execute(void) {
 8004264:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8004266:	469a      	mov	sl, r3
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8004268:	2301      	movs	r3, #1
 800426a:	6013      	str	r3, [r2, #0]
 800426c:	4693      	mov	fp, r2
  {
    n = 0;
    start = test_wait_tick();
 800426e:	f7fe ff57 	bl	8003120 <test_wait_tick>
 8004272:	4b16      	ldr	r3, [pc, #88]	; (80042cc <test_012_005_execute.10629+0x7c>)
 8004274:	4f16      	ldr	r7, [pc, #88]	; (80042d0 <test_012_005_execute.10629+0x80>)
 8004276:	4e17      	ldr	r6, [pc, #92]	; (80042d4 <test_012_005_execute.10629+0x84>)
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004278:	4d17      	ldr	r5, [pc, #92]	; (80042d8 <test_012_005_execute.10629+0x88>)
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    n = 0;
    start = test_wait_tick();
 800427a:	4681      	mov	r9, r0
  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 800427c:	2400      	movs	r4, #0
 800427e:	4698      	mov	r8, r3
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8004280:	1c3a      	adds	r2, r7, #0
 8004282:	2300      	movs	r3, #0
 8004284:	4651      	mov	r1, sl
 8004286:	4640      	mov	r0, r8
 8004288:	f000 ffba 	bl	8005200 <chThdCreateStatic.constprop.52>
 800428c:	f7fd fca0 	bl	8001bd0 <chThdWait>
 8004290:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004292:	464a      	mov	r2, r9
 8004294:	1a9b      	subs	r3, r3, r2
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004296:	b29b      	uxth	r3, r3
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
      n++;
 8004298:	3401      	adds	r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800429a:	42ab      	cmp	r3, r5
 800429c:	d9f0      	bls.n	8004280 <test_012_005_execute.10629+0x30>
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 800429e:	465a      	mov	r2, fp
 80042a0:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80042a2:	480e      	ldr	r0, [pc, #56]	; (80042dc <test_012_005_execute.10629+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 80042a4:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 80042a6:	f7fc f9fb 	bl	80006a0 <test_print>
    test_printn(n);
 80042aa:	1c20      	adds	r0, r4, #0
 80042ac:	f7fc fa10 	bl	80006d0 <test_printn>
    test_println(" threads/S");
 80042b0:	480b      	ldr	r0, [pc, #44]	; (80042e0 <test_012_005_execute.10629+0x90>)
 80042b2:	f7fc f9d5 	bl	8000660 <test_println>
  }
}
 80042b6:	bc3c      	pop	{r2, r3, r4, r5}
 80042b8:	4690      	mov	r8, r2
 80042ba:	4699      	mov	r9, r3
 80042bc:	46a2      	mov	sl, r4
 80042be:	46ab      	mov	fp, r5
 80042c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80042c2:	46c0      	nop			; (mov r8, r8)
 80042c4:	20000ed4 	.word	0x20000ed4
 80042c8:	20000f44 	.word	0x20000f44
 80042cc:	20000518 	.word	0x20000518
 80042d0:	08005b31 	.word	0x08005b31
 80042d4:	40000400 	.word	0x40000400
 80042d8:	000003e7 	.word	0x000003e7
 80042dc:	08005d80 	.word	0x08005d80
 80042e0:	080060b4 	.word	0x080060b4
 80042e4:	46c0      	nop			; (mov r8, r8)
 80042e6:	46c0      	nop			; (mov r8, r8)
 80042e8:	46c0      	nop			; (mov r8, r8)
 80042ea:	46c0      	nop			; (mov r8, r8)
 80042ec:	46c0      	nop			; (mov r8, r8)
 80042ee:	46c0      	nop			; (mov r8, r8)

080042f0 <test_012_008_execute.10623>:
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void test_012_008_execute(void) {
 80042f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80042f2:	4647      	mov	r7, r8
 80042f4:	b480      	push	{r7}
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 80042f6:	4a2e      	ldr	r2, [pc, #184]	; (80043b0 <test_012_008_execute.10623+0xc0>)
 80042f8:	2301      	movs	r3, #1
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void test_012_008_execute(void) {
 80042fa:	b082      	sub	sp, #8
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 80042fc:	6013      	str	r3, [r2, #0]
  {
    n = 0;
 80042fe:	2300      	movs	r3, #0
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8004300:	4690      	mov	r8, r2
  {
    n = 0;
 8004302:	9301      	str	r3, [sp, #4]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004304:	f7fe ff0c 	bl	8003120 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004308:	4e2a      	ldr	r6, [pc, #168]	; (80043b4 <test_012_008_execute.10623+0xc4>)
 800430a:	4f2b      	ldr	r7, [pc, #172]	; (80043b8 <test_012_008_execute.10623+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800430c:	69b3      	ldr	r3, [r6, #24]
 800430e:	4d2b      	ldr	r5, [pc, #172]	; (80043bc <test_012_008_execute.10623+0xcc>)
 8004310:	6899      	ldr	r1, [r3, #8]
 8004312:	1c2a      	adds	r2, r5, #0
 8004314:	ab01      	add	r3, sp, #4
 8004316:	3901      	subs	r1, #1
 8004318:	1c38      	adds	r0, r7, #0
 800431a:	f000 ff71 	bl	8005200 <chThdCreateStatic.constprop.52>
 800431e:	4c28      	ldr	r4, [pc, #160]	; (80043c0 <test_012_008_execute.10623+0xd0>)

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004320:	23a4      	movs	r3, #164	; 0xa4
 8004322:	005b      	lsls	r3, r3, #1
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004324:	6020      	str	r0, [r4, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004326:	18f8      	adds	r0, r7, r3
 8004328:	69b3      	ldr	r3, [r6, #24]
 800432a:	1c2a      	adds	r2, r5, #0
 800432c:	6899      	ldr	r1, [r3, #8]
 800432e:	ab01      	add	r3, sp, #4
 8004330:	3901      	subs	r1, #1
 8004332:	f000 ff65 	bl	8005200 <chThdCreateStatic.constprop.52>
 8004336:	69b3      	ldr	r3, [r6, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004338:	22a4      	movs	r2, #164	; 0xa4
 800433a:	6899      	ldr	r1, [r3, #8]
 800433c:	0092      	lsls	r2, r2, #2
  test_set_step(1);
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800433e:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004340:	ab01      	add	r3, sp, #4
 8004342:	18b8      	adds	r0, r7, r2
 8004344:	3901      	subs	r1, #1
 8004346:	1c2a      	adds	r2, r5, #0
 8004348:	f000 ff5a 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800434c:	23f6      	movs	r3, #246	; 0xf6
 800434e:	009b      	lsls	r3, r3, #2
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004350:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004352:	18f8      	adds	r0, r7, r3
 8004354:	69b3      	ldr	r3, [r6, #24]
 8004356:	1c2a      	adds	r2, r5, #0
 8004358:	6899      	ldr	r1, [r3, #8]
 800435a:	ab01      	add	r3, sp, #4
 800435c:	3901      	subs	r1, #1
 800435e:	f000 ff4f 	bl	8005200 <chThdCreateStatic.constprop.52>
 8004362:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8004364:	22a4      	movs	r2, #164	; 0xa4
 8004366:	6899      	ldr	r1, [r3, #8]
 8004368:	00d2      	lsls	r2, r2, #3
 800436a:	3901      	subs	r1, #1
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800436c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800436e:	ab01      	add	r3, sp, #4
 8004370:	18b8      	adds	r0, r7, r2
 8004372:	1c2a      	adds	r2, r5, #0
 8004374:	f000 ff44 	bl	8005200 <chThdCreateStatic.constprop.52>
 8004378:	6120      	str	r0, [r4, #16]
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  {
    chThdSleepSeconds(1);
 800437a:	20fa      	movs	r0, #250	; 0xfa
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 800437c:	4642      	mov	r2, r8
 800437e:	2302      	movs	r3, #2
  {
    chThdSleepSeconds(1);
 8004380:	0080      	lsls	r0, r0, #2
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8004382:	6013      	str	r3, [r2, #0]
  {
    chThdSleepSeconds(1);
 8004384:	f7fe fd54 	bl	8002e30 <chThdSleep>
    test_terminate_threads();
 8004388:	f7fc f91a 	bl	80005c0 <test_terminate_threads>
    test_wait_threads();
 800438c:	f7fd fc38 	bl	8001c00 <test_wait_threads>
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 8004390:	2303      	movs	r3, #3
 8004392:	4642      	mov	r2, r8
  {
    test_print("--- Score : ");
 8004394:	480b      	ldr	r0, [pc, #44]	; (80043c4 <test_012_008_execute.10623+0xd4>)
    test_terminate_threads();
    test_wait_threads();
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 8004396:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8004398:	f7fc f982 	bl	80006a0 <test_print>
    test_printn(n);
 800439c:	9801      	ldr	r0, [sp, #4]
 800439e:	f7fc f997 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 80043a2:	4809      	ldr	r0, [pc, #36]	; (80043c8 <test_012_008_execute.10623+0xd8>)
 80043a4:	f7fc f95c 	bl	8000660 <test_println>
  }
}
 80043a8:	b002      	add	sp, #8
 80043aa:	bc04      	pop	{r2}
 80043ac:	4690      	mov	r8, r2
 80043ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80043b0:	20000f44 	.word	0x20000f44
 80043b4:	20000ed4 	.word	0x20000ed4
 80043b8:	20000518 	.word	0x20000518
 80043bc:	08000551 	.word	0x08000551
 80043c0:	20000b84 	.word	0x20000b84
 80043c4:	08005d80 	.word	0x08005d80
 80043c8:	080060a8 	.word	0x080060a8
 80043cc:	46c0      	nop			; (mov r8, r8)
 80043ce:	46c0      	nop			; (mov r8, r8)

080043d0 <test_012_007_execute.10625>:

static void test_012_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_012_007_execute(void) {
 80043d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80043d2:	464f      	mov	r7, r9
 80043d4:	4646      	mov	r6, r8
 80043d6:	b4c0      	push	{r6, r7}
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 80043d8:	4a3a      	ldr	r2, [pc, #232]	; (80044c4 <test_012_007_execute.10625+0xf4>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80043da:	4e3b      	ldr	r6, [pc, #236]	; (80044c8 <test_012_007_execute.10625+0xf8>)
 80043dc:	2301      	movs	r3, #1
 80043de:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80043e0:	69b3      	ldr	r3, [r6, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80043e2:	4f3a      	ldr	r7, [pc, #232]	; (80044cc <test_012_007_execute.10625+0xfc>)
 80043e4:	4d3a      	ldr	r5, [pc, #232]	; (80044d0 <test_012_007_execute.10625+0x100>)
 80043e6:	6899      	ldr	r1, [r3, #8]
static void test_012_007_execute(void) {
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 80043e8:	4691      	mov	r9, r2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80043ea:	3105      	adds	r1, #5
 80043ec:	1c2a      	adds	r2, r5, #0
 80043ee:	1c38      	adds	r0, r7, #0
 80043f0:	2300      	movs	r3, #0
 80043f2:	f000 ff05 	bl	8005200 <chThdCreateStatic.constprop.52>
 80043f6:	4c37      	ldr	r4, [pc, #220]	; (80044d4 <test_012_007_execute.10625+0x104>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 80043f8:	23a4      	movs	r3, #164	; 0xa4
 80043fa:	005b      	lsls	r3, r3, #1

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80043fc:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 80043fe:	18f8      	adds	r0, r7, r3
 8004400:	69b3      	ldr	r3, [r6, #24]
 8004402:	1c2a      	adds	r2, r5, #0
 8004404:	6899      	ldr	r1, [r3, #8]
 8004406:	2300      	movs	r3, #0
 8004408:	3104      	adds	r1, #4
 800440a:	f000 fef9 	bl	8005200 <chThdCreateStatic.constprop.52>
 800440e:	69b3      	ldr	r3, [r6, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8004410:	22a4      	movs	r2, #164	; 0xa4
 8004412:	6899      	ldr	r1, [r3, #8]
 8004414:	0092      	lsls	r2, r2, #2
  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8004416:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8004418:	3103      	adds	r1, #3
 800441a:	18b8      	adds	r0, r7, r2
 800441c:	2300      	movs	r3, #0
 800441e:	1c2a      	adds	r2, r5, #0
 8004420:	f000 feee 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8004424:	23f6      	movs	r3, #246	; 0xf6
 8004426:	009b      	lsls	r3, r3, #2
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8004428:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800442a:	18f8      	adds	r0, r7, r3
 800442c:	69b3      	ldr	r3, [r6, #24]
 800442e:	1c2a      	adds	r2, r5, #0
 8004430:	6899      	ldr	r1, [r3, #8]
 8004432:	2300      	movs	r3, #0
 8004434:	3102      	adds	r1, #2
 8004436:	f000 fee3 	bl	8005200 <chThdCreateStatic.constprop.52>
 800443a:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800443c:	22a4      	movs	r2, #164	; 0xa4
 800443e:	6899      	ldr	r1, [r3, #8]
 8004440:	00d2      	lsls	r2, r2, #3
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8004442:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8004444:	3101      	adds	r1, #1
 8004446:	18b8      	adds	r0, r7, r2
 8004448:	2300      	movs	r3, #0
 800444a:	1c2a      	adds	r2, r5, #0
 800444c:	f000 fed8 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 8004450:	2302      	movs	r3, #2
 8004452:	464a      	mov	r2, r9
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8004454:	6120      	str	r0, [r4, #16]
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 8004456:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8004458:	f7fe fe62 	bl	8003120 <test_wait_tick>
 800445c:	4f1e      	ldr	r7, [pc, #120]	; (80044d8 <test_012_007_execute.10625+0x108>)
 800445e:	4d1f      	ldr	r5, [pc, #124]	; (80044dc <test_012_007_execute.10625+0x10c>)
      chSemReset(&sem1, 0);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004460:	4e1f      	ldr	r6, [pc, #124]	; (80044e0 <test_012_007_execute.10625+0x110>)
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8004462:	4680      	mov	r8, r0
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 8004464:	2400      	movs	r4, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
 8004466:	1c28      	adds	r0, r5, #0
 8004468:	2100      	movs	r1, #0
 800446a:	f7fd f9d1 	bl	8001810 <chSemReset>
 800446e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004470:	4642      	mov	r2, r8
 8004472:	1a9b      	subs	r3, r3, r2
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004474:	b29b      	uxth	r3, r3
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
      n++;
 8004476:	3401      	adds	r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8004478:	42b3      	cmp	r3, r6
 800447a:	d9f4      	bls.n	8004466 <test_012_007_execute.10625+0x96>
  }

  /* [12.7.3] The five threads are terminated.*/
  test_set_step(3);
 800447c:	464a      	mov	r2, r9
 800447e:	2303      	movs	r3, #3
 8004480:	6013      	str	r3, [r2, #0]
  {
    test_terminate_threads();
 8004482:	f7fc f89d 	bl	80005c0 <test_terminate_threads>
    chSemReset(&sem1, 0);
 8004486:	2100      	movs	r1, #0
 8004488:	1c28      	adds	r0, r5, #0
 800448a:	f7fd f9c1 	bl	8001810 <chSemReset>
    test_wait_threads();
 800448e:	f7fd fbb7 	bl	8001c00 <test_wait_threads>
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8004492:	464a      	mov	r2, r9
 8004494:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8004496:	4813      	ldr	r0, [pc, #76]	; (80044e4 <test_012_007_execute.10625+0x114>)
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8004498:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 800449a:	f7fc f901 	bl	80006a0 <test_print>
    test_printn(n);
 800449e:	1c20      	adds	r0, r4, #0
 80044a0:	f7fc f916 	bl	80006d0 <test_printn>
    test_print(" reschedules/S, ");
 80044a4:	4810      	ldr	r0, [pc, #64]	; (80044e8 <test_012_007_execute.10625+0x118>)
 80044a6:	f7fc f8fb 	bl	80006a0 <test_print>
    test_printn(n * 6);
 80044aa:	0060      	lsls	r0, r4, #1
 80044ac:	1904      	adds	r4, r0, r4
 80044ae:	0060      	lsls	r0, r4, #1
 80044b0:	f7fc f90e 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 80044b4:	480d      	ldr	r0, [pc, #52]	; (80044ec <test_012_007_execute.10625+0x11c>)
 80044b6:	f7fc f8d3 	bl	8000660 <test_println>
  }
}
 80044ba:	bc0c      	pop	{r2, r3}
 80044bc:	4690      	mov	r8, r2
 80044be:	4699      	mov	r9, r3
 80044c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80044c2:	46c0      	nop			; (mov r8, r8)
 80044c4:	20000f44 	.word	0x20000f44
 80044c8:	20000ed4 	.word	0x20000ed4
 80044cc:	20000518 	.word	0x20000518
 80044d0:	08000dc1 	.word	0x08000dc1
 80044d4:	20000b84 	.word	0x20000b84
 80044d8:	40000400 	.word	0x40000400
 80044dc:	20000ba8 	.word	0x20000ba8
 80044e0:	000003e7 	.word	0x000003e7
 80044e4:	08005d80 	.word	0x08005d80
 80044e8:	080060c0 	.word	0x080060c0
 80044ec:	080060a8 	.word	0x080060a8

080044f0 <test_012_003_execute.10636>:
 *   second time window.
 * - [12.3.4] Score is printed.
 * .
 */

static void test_012_003_execute(void) {
 80044f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044f2:	4647      	mov	r7, r8
 80044f4:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80044f6:	4d2d      	ldr	r5, [pc, #180]	; (80045ac <test_012_003_execute.10636+0xbc>)
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80044f8:	4f2d      	ldr	r7, [pc, #180]	; (80045b0 <test_012_003_execute.10636+0xc0>)
 80044fa:	2301      	movs	r3, #1
 80044fc:	603b      	str	r3, [r7, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80044fe:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8004500:	4e2c      	ldr	r6, [pc, #176]	; (80045b4 <test_012_003_execute.10636+0xc4>)
 8004502:	6899      	ldr	r1, [r3, #8]
 8004504:	1c30      	adds	r0, r6, #0
 8004506:	3101      	adds	r1, #1
 8004508:	4a2b      	ldr	r2, [pc, #172]	; (80045b8 <test_012_003_execute.10636+0xc8>)
 800450a:	2300      	movs	r3, #0
 800450c:	f000 fe78 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 8004510:	2302      	movs	r3, #2

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8004512:	4c2a      	ldr	r4, [pc, #168]	; (80045bc <test_012_003_execute.10636+0xcc>)
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 8004514:	603b      	str	r3, [r7, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004516:	23a4      	movs	r3, #164	; 0xa4
 8004518:	005b      	lsls	r3, r3, #1

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800451a:	6020      	str	r0, [r4, #0]

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800451c:	18f0      	adds	r0, r6, r3
 800451e:	69ab      	ldr	r3, [r5, #24]
 8004520:	6899      	ldr	r1, [r3, #8]
 8004522:	4b27      	ldr	r3, [pc, #156]	; (80045c0 <test_012_003_execute.10636+0xd0>)
 8004524:	3902      	subs	r1, #2
 8004526:	4698      	mov	r8, r3
 8004528:	1c1a      	adds	r2, r3, #0
 800452a:	2300      	movs	r3, #0
 800452c:	f000 fe68 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8004530:	23a4      	movs	r3, #164	; 0xa4
 8004532:	009b      	lsls	r3, r3, #2

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004534:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8004536:	18f0      	adds	r0, r6, r3
 8004538:	69ab      	ldr	r3, [r5, #24]
 800453a:	4642      	mov	r2, r8
 800453c:	6899      	ldr	r1, [r3, #8]
 800453e:	2300      	movs	r3, #0
 8004540:	3903      	subs	r1, #3
 8004542:	f000 fe5d 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8004546:	23f6      	movs	r3, #246	; 0xf6
 8004548:	009b      	lsls	r3, r3, #2
  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 800454a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800454c:	18f0      	adds	r0, r6, r3
 800454e:	69ab      	ldr	r3, [r5, #24]
 8004550:	4642      	mov	r2, r8
 8004552:	6899      	ldr	r1, [r3, #8]
 8004554:	2300      	movs	r3, #0
 8004556:	3904      	subs	r1, #4
 8004558:	f000 fe52 	bl	8005200 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 800455c:	23a4      	movs	r3, #164	; 0xa4
 800455e:	00db      	lsls	r3, r3, #3
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8004560:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8004562:	18f0      	adds	r0, r6, r3
 8004564:	69ab      	ldr	r3, [r5, #24]
 8004566:	4642      	mov	r2, r8
 8004568:	6899      	ldr	r1, [r3, #8]
 800456a:	2300      	movs	r3, #0
 800456c:	3905      	subs	r1, #5
 800456e:	f000 fe47 	bl	8005200 <chThdCreateStatic.constprop.52>
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8004572:	2303      	movs	r3, #3
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8004574:	6120      	str	r0, [r4, #16]

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  {
    n = msg_loop_test(threads[0]);
 8004576:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8004578:	603b      	str	r3, [r7, #0]
  {
    n = msg_loop_test(threads[0]);
 800457a:	f7fe fe81 	bl	8003280 <msg_loop_test.10633>
 800457e:	1c04      	adds	r4, r0, #0
    test_wait_threads();
 8004580:	f7fd fb3e 	bl	8001c00 <test_wait_threads>
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8004584:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8004586:	480f      	ldr	r0, [pc, #60]	; (80045c4 <test_012_003_execute.10636+0xd4>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8004588:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 800458a:	f7fc f889 	bl	80006a0 <test_print>
    test_printn(n);
 800458e:	1c20      	adds	r0, r4, #0
 8004590:	f7fc f89e 	bl	80006d0 <test_printn>
    test_print(" msgs/S, ");
 8004594:	480c      	ldr	r0, [pc, #48]	; (80045c8 <test_012_003_execute.10636+0xd8>)
 8004596:	f7fc f883 	bl	80006a0 <test_print>
    test_printn(n << 1);
 800459a:	0060      	lsls	r0, r4, #1
 800459c:	f7fc f898 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 80045a0:	480a      	ldr	r0, [pc, #40]	; (80045cc <test_012_003_execute.10636+0xdc>)
 80045a2:	f7fc f85d 	bl	8000660 <test_println>
  }
}
 80045a6:	bc04      	pop	{r2}
 80045a8:	4690      	mov	r8, r2
 80045aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80045ac:	20000ed4 	.word	0x20000ed4
 80045b0:	20000f44 	.word	0x20000f44
 80045b4:	20000518 	.word	0x20000518
 80045b8:	08003fb1 	.word	0x08003fb1
 80045bc:	20000b84 	.word	0x20000b84
 80045c0:	08005b31 	.word	0x08005b31
 80045c4:	08005d80 	.word	0x08005d80
 80045c8:	080060d4 	.word	0x080060d4
 80045cc:	080060a8 	.word	0x080060a8

080045d0 <test_012_002_execute.10638>:
 *   second time window.
 * - [12.2.3] Score is printed.
 * .
 */

static void test_012_002_execute(void) {
 80045d0:	b538      	push	{r3, r4, r5, lr}
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80045d2:	4c13      	ldr	r4, [pc, #76]	; (8004620 <test_012_002_execute.10638+0x50>)
 80045d4:	2301      	movs	r3, #1
 80045d6:	6023      	str	r3, [r4, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80045d8:	4b12      	ldr	r3, [pc, #72]	; (8004624 <test_012_002_execute.10638+0x54>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80045da:	4a13      	ldr	r2, [pc, #76]	; (8004628 <test_012_002_execute.10638+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80045dc:	699b      	ldr	r3, [r3, #24]
 80045de:	4813      	ldr	r0, [pc, #76]	; (800462c <test_012_002_execute.10638+0x5c>)
 80045e0:	6899      	ldr	r1, [r3, #8]
 80045e2:	2300      	movs	r3, #0
 80045e4:	3101      	adds	r1, #1
 80045e6:	f000 fe0b 	bl	8005200 <chThdCreateStatic.constprop.52>
 80045ea:	4b11      	ldr	r3, [pc, #68]	; (8004630 <test_012_002_execute.10638+0x60>)
 80045ec:	6018      	str	r0, [r3, #0]
  }

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80045ee:	2302      	movs	r3, #2
 80045f0:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 80045f2:	f7fe fe45 	bl	8003280 <msg_loop_test.10633>
 80045f6:	1c05      	adds	r5, r0, #0
    test_wait_threads();
 80045f8:	f7fd fb02 	bl	8001c00 <test_wait_threads>
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 80045fc:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 80045fe:	480d      	ldr	r0, [pc, #52]	; (8004634 <test_012_002_execute.10638+0x64>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 8004600:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8004602:	f7fc f84d 	bl	80006a0 <test_print>
    test_printn(n);
 8004606:	1c28      	adds	r0, r5, #0
 8004608:	f7fc f862 	bl	80006d0 <test_printn>
    test_print(" msgs/S, ");
 800460c:	480a      	ldr	r0, [pc, #40]	; (8004638 <test_012_002_execute.10638+0x68>)
 800460e:	f7fc f847 	bl	80006a0 <test_print>
    test_printn(n << 1);
 8004612:	0068      	lsls	r0, r5, #1
 8004614:	f7fc f85c 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 8004618:	4808      	ldr	r0, [pc, #32]	; (800463c <test_012_002_execute.10638+0x6c>)
 800461a:	f7fc f821 	bl	8000660 <test_println>
  }
}
 800461e:	bd38      	pop	{r3, r4, r5, pc}
 8004620:	20000f44 	.word	0x20000f44
 8004624:	20000ed4 	.word	0x20000ed4
 8004628:	08003fb1 	.word	0x08003fb1
 800462c:	20000518 	.word	0x20000518
 8004630:	20000b84 	.word	0x20000b84
 8004634:	08005d80 	.word	0x08005d80
 8004638:	080060d4 	.word	0x080060d4
 800463c:	080060a8 	.word	0x080060a8

08004640 <test_012_001_execute.10640>:
 *   second time window.
 * - [12.1.3] Score is printed.
 * .
 */

static void test_012_001_execute(void) {
 8004640:	b538      	push	{r3, r4, r5, lr}
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8004642:	4c13      	ldr	r4, [pc, #76]	; (8004690 <test_012_001_execute.10640+0x50>)
 8004644:	2301      	movs	r3, #1
 8004646:	6023      	str	r3, [r4, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004648:	4b12      	ldr	r3, [pc, #72]	; (8004694 <test_012_001_execute.10640+0x54>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 800464a:	4a13      	ldr	r2, [pc, #76]	; (8004698 <test_012_001_execute.10640+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800464c:	699b      	ldr	r3, [r3, #24]
 800464e:	4813      	ldr	r0, [pc, #76]	; (800469c <test_012_001_execute.10640+0x5c>)
 8004650:	6899      	ldr	r1, [r3, #8]
 8004652:	2300      	movs	r3, #0
 8004654:	3901      	subs	r1, #1
 8004656:	f000 fdd3 	bl	8005200 <chThdCreateStatic.constprop.52>
 800465a:	4b11      	ldr	r3, [pc, #68]	; (80046a0 <test_012_001_execute.10640+0x60>)
 800465c:	6018      	str	r0, [r3, #0]
  }

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800465e:	2302      	movs	r3, #2
 8004660:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 8004662:	f7fe fe0d 	bl	8003280 <msg_loop_test.10633>
 8004666:	1c05      	adds	r5, r0, #0
    test_wait_threads();
 8004668:	f7fd faca 	bl	8001c00 <test_wait_threads>
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 800466c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800466e:	480d      	ldr	r0, [pc, #52]	; (80046a4 <test_012_001_execute.10640+0x64>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 8004670:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8004672:	f7fc f815 	bl	80006a0 <test_print>
    test_printn(n);
 8004676:	1c28      	adds	r0, r5, #0
 8004678:	f7fc f82a 	bl	80006d0 <test_printn>
    test_print(" msgs/S, ");
 800467c:	480a      	ldr	r0, [pc, #40]	; (80046a8 <test_012_001_execute.10640+0x68>)
 800467e:	f7fc f80f 	bl	80006a0 <test_print>
    test_printn(n << 1);
 8004682:	0068      	lsls	r0, r5, #1
 8004684:	f7fc f824 	bl	80006d0 <test_printn>
    test_println(" ctxswc/S");
 8004688:	4808      	ldr	r0, [pc, #32]	; (80046ac <test_012_001_execute.10640+0x6c>)
 800468a:	f7fb ffe9 	bl	8000660 <test_println>
  }
}
 800468e:	bd38      	pop	{r3, r4, r5, pc}
 8004690:	20000f44 	.word	0x20000f44
 8004694:	20000ed4 	.word	0x20000ed4
 8004698:	08003fb1 	.word	0x08003fb1
 800469c:	20000518 	.word	0x20000518
 80046a0:	20000b84 	.word	0x20000b84
 80046a4:	08005d80 	.word	0x08005d80
 80046a8:	080060d4 	.word	0x080060d4
 80046ac:	080060a8 	.word	0x080060a8

080046b0 <test_011_002_execute.10429>:

static void test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void test_011_002_execute(void) {
 80046b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 80046b2:	4f3c      	ldr	r7, [pc, #240]	; (80047a4 <test_011_002_execute.10429+0xf4>)
 80046b4:	2301      	movs	r3, #1
 80046b6:	603b      	str	r3, [r7, #0]
 80046b8:	4b3b      	ldr	r3, [pc, #236]	; (80047a8 <test_011_002_execute.10429+0xf8>)
 80046ba:	4d3c      	ldr	r5, [pc, #240]	; (80047ac <test_011_002_execute.10429+0xfc>)
 80046bc:	1c19      	adds	r1, r3, #0
 80046be:	3110      	adds	r1, #16
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 80046c0:	cb04      	ldmia	r3!, {r2}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80046c2:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 80046c4:	6828      	ldr	r0, [r5, #0]
 80046c6:	6010      	str	r0, [r2, #0]
  mp->next = php;
 80046c8:	602a      	str	r2, [r5, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80046ca:	b662      	cpsie	i
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 80046cc:	428b      	cmp	r3, r1
 80046ce:	d1f7      	bne.n	80046c0 <test_011_002_execute.10429+0x10>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80046d0:	4b37      	ldr	r3, [pc, #220]	; (80047b0 <test_011_002_execute.10429+0x100>)
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80046d2:	4a38      	ldr	r2, [pc, #224]	; (80047b4 <test_011_002_execute.10429+0x104>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80046d4:	699b      	ldr	r3, [r3, #24]
 80046d6:	4838      	ldr	r0, [pc, #224]	; (80047b8 <test_011_002_execute.10429+0x108>)
 80046d8:	689e      	ldr	r6, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 80046da:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80046dc:	1e71      	subs	r1, r6, #1
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 80046de:	603b      	str	r3, [r7, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80046e0:	f7fc fabe 	bl	8000c60 <chThdCreateFromMemoryPool.constprop.24>
 80046e4:	4c35      	ldr	r4, [pc, #212]	; (80047bc <test_011_002_execute.10429+0x10c>)
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80046e6:	1eb1      	subs	r1, r6, #2
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80046e8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80046ea:	4a35      	ldr	r2, [pc, #212]	; (80047c0 <test_011_002_execute.10429+0x110>)
 80046ec:	4835      	ldr	r0, [pc, #212]	; (80047c4 <test_011_002_execute.10429+0x114>)
 80046ee:	f7fc fab7 	bl	8000c60 <chThdCreateFromMemoryPool.constprop.24>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 80046f2:	1ef1      	subs	r1, r6, #3

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80046f4:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 80046f6:	4a34      	ldr	r2, [pc, #208]	; (80047c8 <test_011_002_execute.10429+0x118>)
 80046f8:	4834      	ldr	r0, [pc, #208]	; (80047cc <test_011_002_execute.10429+0x11c>)
 80046fa:	f7fc fab1 	bl	8000c60 <chThdCreateFromMemoryPool.constprop.24>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 80046fe:	1f31      	subs	r1, r6, #4
  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8004700:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004702:	4a33      	ldr	r2, [pc, #204]	; (80047d0 <test_011_002_execute.10429+0x120>)
 8004704:	4833      	ldr	r0, [pc, #204]	; (80047d4 <test_011_002_execute.10429+0x124>)
 8004706:	f7fc faab 	bl	8000c60 <chThdCreateFromMemoryPool.constprop.24>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800470a:	1f71      	subs	r1, r6, #5
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800470c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800470e:	4a32      	ldr	r2, [pc, #200]	; (80047d8 <test_011_002_execute.10429+0x128>)
 8004710:	4832      	ldr	r0, [pc, #200]	; (80047dc <test_011_002_execute.10429+0x12c>)
 8004712:	f7fc faa5 	bl	8000c60 <chThdCreateFromMemoryPool.constprop.24>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8004716:	2304      	movs	r3, #4
 8004718:	603b      	str	r3, [r7, #0]
  {
    test_assert((threads[0] != NULL) &&
 800471a:	6823      	ldr	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800471c:	6120      	str	r0, [r4, #16]
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 800471e:	2b00      	cmp	r3, #0
 8004720:	d03e      	beq.n	80047a0 <test_011_002_execute.10429+0xf0>
 8004722:	6860      	ldr	r0, [r4, #4]
 8004724:	2800      	cmp	r0, #0
 8004726:	d03b      	beq.n	80047a0 <test_011_002_execute.10429+0xf0>
 8004728:	68a3      	ldr	r3, [r4, #8]
 800472a:	2b00      	cmp	r3, #0
 800472c:	d038      	beq.n	80047a0 <test_011_002_execute.10429+0xf0>
 800472e:	68e0      	ldr	r0, [r4, #12]
 8004730:	1e43      	subs	r3, r0, #1
 8004732:	4198      	sbcs	r0, r3
 8004734:	b2c0      	uxtb	r0, r0
 8004736:	492a      	ldr	r1, [pc, #168]	; (80047e0 <test_011_002_execute.10429+0x130>)
 8004738:	f7fc f8ba 	bl	80008b0 <_test_assert>
 800473c:	2800      	cmp	r0, #0
 800473e:	d000      	beq.n	8004742 <test_011_002_execute.10429+0x92>
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
}
 8004740:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert((threads[0] != NULL) &&
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8004742:	6920      	ldr	r0, [r4, #16]
 8004744:	4927      	ldr	r1, [pc, #156]	; (80047e4 <test_011_002_execute.10429+0x134>)
 8004746:	4243      	negs	r3, r0
 8004748:	4158      	adcs	r0, r3
 800474a:	b2c0      	uxtb	r0, r0
 800474c:	f7fc f8b0 	bl	80008b0 <_test_assert>
 8004750:	2800      	cmp	r0, #0
 8004752:	d1f5      	bne.n	8004740 <test_011_002_execute.10429+0x90>
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8004754:	2305      	movs	r3, #5
 8004756:	603b      	str	r3, [r7, #0]
  {
    test_wait_threads();
 8004758:	f7fd fa52 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800475c:	4822      	ldr	r0, [pc, #136]	; (80047e8 <test_011_002_execute.10429+0x138>)
 800475e:	4923      	ldr	r1, [pc, #140]	; (80047ec <test_011_002_execute.10429+0x13c>)
 8004760:	f7fc f876 	bl	8000850 <_test_assert_sequence>
 8004764:	2800      	cmp	r0, #0
 8004766:	d1eb      	bne.n	8004740 <test_011_002_execute.10429+0x90>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 8004768:	2306      	movs	r3, #6
 800476a:	4e21      	ldr	r6, [pc, #132]	; (80047f0 <test_011_002_execute.10429+0x140>)
 800476c:	603b      	str	r3, [r7, #0]
 800476e:	2404      	movs	r4, #4
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8004770:	1c28      	adds	r0, r5, #0
 8004772:	f7fc f935 	bl	80009e0 <chPoolAlloc>
 8004776:	1e43      	subs	r3, r0, #1
 8004778:	4198      	sbcs	r0, r3
 800477a:	b2c0      	uxtb	r0, r0
 800477c:	1c31      	adds	r1, r6, #0
 800477e:	f7fc f897 	bl	80008b0 <_test_assert>
 8004782:	2800      	cmp	r0, #0
 8004784:	d1dc      	bne.n	8004740 <test_011_002_execute.10429+0x90>
 8004786:	3c01      	subs	r4, #1
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 8004788:	2c00      	cmp	r4, #0
 800478a:	d1f1      	bne.n	8004770 <test_011_002_execute.10429+0xc0>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800478c:	1c28      	adds	r0, r5, #0
 800478e:	f7fc f927 	bl	80009e0 <chPoolAlloc>
 8004792:	4243      	negs	r3, r0
 8004794:	4158      	adcs	r0, r3
 8004796:	4917      	ldr	r1, [pc, #92]	; (80047f4 <test_011_002_execute.10429+0x144>)
 8004798:	b2c0      	uxtb	r0, r0
 800479a:	f7fc f889 	bl	80008b0 <_test_assert>
 800479e:	e7cf      	b.n	8004740 <test_011_002_execute.10429+0x90>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 80047a0:	2000      	movs	r0, #0
 80047a2:	e7c8      	b.n	8004736 <test_011_002_execute.10429+0x86>
 80047a4:	20000f44 	.word	0x20000f44
 80047a8:	08005f3c 	.word	0x08005f3c
 80047ac:	20000bd8 	.word	0x20000bd8
 80047b0:	20000ed4 	.word	0x20000ed4
 80047b4:	08005e04 	.word	0x08005e04
 80047b8:	080060e0 	.word	0x080060e0
 80047bc:	20000b84 	.word	0x20000b84
 80047c0:	08005e0c 	.word	0x08005e0c
 80047c4:	080060e8 	.word	0x080060e8
 80047c8:	08005e08 	.word	0x08005e08
 80047cc:	080060f0 	.word	0x080060f0
 80047d0:	08005e14 	.word	0x08005e14
 80047d4:	080060f8 	.word	0x080060f8
 80047d8:	08005e1c 	.word	0x08005e1c
 80047dc:	08006100 	.word	0x08006100
 80047e0:	08006108 	.word	0x08006108
 80047e4:	08006120 	.word	0x08006120
 80047e8:	08005de8 	.word	0x08005de8
 80047ec:	08005df0 	.word	0x08005df0
 80047f0:	0800613c 	.word	0x0800613c
 80047f4:	0800614c 	.word	0x0800614c
 80047f8:	46c0      	nop			; (mov r8, r8)
 80047fa:	46c0      	nop			; (mov r8, r8)
 80047fc:	46c0      	nop			; (mov r8, r8)
 80047fe:	46c0      	nop			; (mov r8, r8)

08004800 <test_011_001_execute.10433>:

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 8004800:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004802:	464f      	mov	r7, r9
 8004804:	4646      	mov	r6, r8
 8004806:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004808:	4b42      	ldr	r3, [pc, #264]	; (8004914 <test_011_001_execute.10433+0x114>)
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800480a:	4e43      	ldr	r6, [pc, #268]	; (8004918 <test_011_001_execute.10433+0x118>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800480c:	699b      	ldr	r3, [r3, #24]

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 800480e:	b085      	sub	sp, #20
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8004810:	4c42      	ldr	r4, [pc, #264]	; (800491c <test_011_001_execute.10433+0x11c>)
 8004812:	689f      	ldr	r7, [r3, #8]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004814:	4669      	mov	r1, sp
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8004816:	2302      	movs	r3, #2
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004818:	1c30      	adds	r0, r6, #0
 800481a:	aa01      	add	r2, sp, #4
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 800481c:	6023      	str	r3, [r4, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800481e:	f7fc fd37 	bl	8001290 <chHeapStatus>
 8004822:	1c05      	adds	r5, r0, #0
    test_assert(n1 == 1, "heap fragmented");
 8004824:	3801      	subs	r0, #1
 8004826:	4243      	negs	r3, r0
 8004828:	4158      	adcs	r0, r3
 800482a:	b2c0      	uxtb	r0, r0
 800482c:	493c      	ldr	r1, [pc, #240]	; (8004920 <test_011_001_execute.10433+0x120>)
 800482e:	f7fc f83f 	bl	80008b0 <_test_assert>
 8004832:	2800      	cmp	r0, #0
 8004834:	d004      	beq.n	8004840 <test_011_001_execute.10433+0x40>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 8004836:	b005      	add	sp, #20
 8004838:	bc0c      	pop	{r2, r3}
 800483a:	4690      	mov	r8, r2
 800483c:	4699      	mov	r9, r3
 800483e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8004840:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8004842:	20a4      	movs	r0, #164	; 0xa4
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8004844:	6023      	str	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8004846:	1e7a      	subs	r2, r7, #1
 8004848:	4936      	ldr	r1, [pc, #216]	; (8004924 <test_011_001_execute.10433+0x124>)
 800484a:	4b37      	ldr	r3, [pc, #220]	; (8004928 <test_011_001_execute.10433+0x128>)
 800484c:	0040      	lsls	r0, r0, #1
 800484e:	f7fc fccf 	bl	80011f0 <chThdCreateFromHeap.constprop.25>
 8004852:	4a36      	ldr	r2, [pc, #216]	; (800492c <test_011_001_execute.10433+0x12c>)
 8004854:	6010      	str	r0, [r2, #0]
 8004856:	4690      	mov	r8, r2
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8004858:	4a35      	ldr	r2, [pc, #212]	; (8004930 <test_011_001_execute.10433+0x130>)
 800485a:	1e43      	subs	r3, r0, #1
 800485c:	4198      	sbcs	r0, r3
 800485e:	b2c0      	uxtb	r0, r0
 8004860:	1c11      	adds	r1, r2, #0
 8004862:	4691      	mov	r9, r2
 8004864:	f7fc f824 	bl	80008b0 <_test_assert>
 8004868:	2800      	cmp	r0, #0
 800486a:	d1e4      	bne.n	8004836 <test_011_001_execute.10433+0x36>
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 800486c:	2304      	movs	r3, #4
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 800486e:	20a4      	movs	r0, #164	; 0xa4
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 8004870:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8004872:	4930      	ldr	r1, [pc, #192]	; (8004934 <test_011_001_execute.10433+0x134>)
 8004874:	4b30      	ldr	r3, [pc, #192]	; (8004938 <test_011_001_execute.10433+0x138>)
 8004876:	1eba      	subs	r2, r7, #2
 8004878:	0040      	lsls	r0, r0, #1
 800487a:	f7fc fcb9 	bl	80011f0 <chThdCreateFromHeap.constprop.25>
 800487e:	4643      	mov	r3, r8
 8004880:	6058      	str	r0, [r3, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 8004882:	1e43      	subs	r3, r0, #1
 8004884:	4198      	sbcs	r0, r3
 8004886:	b2c0      	uxtb	r0, r0
 8004888:	4649      	mov	r1, r9
 800488a:	f7fc f811 	bl	80008b0 <_test_assert>
 800488e:	2800      	cmp	r0, #0
 8004890:	d1d1      	bne.n	8004836 <test_011_001_execute.10433+0x36>
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 8004892:	2305      	movs	r3, #5
 8004894:	6023      	str	r3, [r4, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 8004896:	1efa      	subs	r2, r7, #3
 8004898:	4928      	ldr	r1, [pc, #160]	; (800493c <test_011_001_execute.10433+0x13c>)
 800489a:	4b29      	ldr	r3, [pc, #164]	; (8004940 <test_011_001_execute.10433+0x140>)
 800489c:	4829      	ldr	r0, [pc, #164]	; (8004944 <test_011_001_execute.10433+0x144>)
 800489e:	f7fc fca7 	bl	80011f0 <chThdCreateFromHeap.constprop.25>
 80048a2:	4642      	mov	r2, r8
 80048a4:	6090      	str	r0, [r2, #8]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80048a6:	4243      	negs	r3, r0
 80048a8:	4158      	adcs	r0, r3
 80048aa:	b2c0      	uxtb	r0, r0
 80048ac:	4926      	ldr	r1, [pc, #152]	; (8004948 <test_011_001_execute.10433+0x148>)
 80048ae:	f7fb ffff 	bl	80008b0 <_test_assert>
 80048b2:	2800      	cmp	r0, #0
 80048b4:	d1bf      	bne.n	8004836 <test_011_001_execute.10433+0x36>
  }

  /* [11.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 80048b6:	2306      	movs	r3, #6
 80048b8:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 80048ba:	f7fd f9a1 	bl	8001c00 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 80048be:	4823      	ldr	r0, [pc, #140]	; (800494c <test_011_001_execute.10433+0x14c>)
 80048c0:	4923      	ldr	r1, [pc, #140]	; (8004950 <test_011_001_execute.10433+0x150>)
 80048c2:	f7fb ffc5 	bl	8000850 <_test_assert_sequence>
 80048c6:	2800      	cmp	r0, #0
 80048c8:	d1b5      	bne.n	8004836 <test_011_001_execute.10433+0x36>
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 80048ca:	2307      	movs	r3, #7
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 80048cc:	a902      	add	r1, sp, #8
 80048ce:	1c30      	adds	r0, r6, #0
 80048d0:	aa03      	add	r2, sp, #12
    test_wait_threads();
    test_assert_sequence("AB", "invalid sequence");
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 80048d2:	6023      	str	r3, [r4, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 80048d4:	f7fc fcdc 	bl	8001290 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 80048d8:	1a28      	subs	r0, r5, r0
 80048da:	4245      	negs	r5, r0
 80048dc:	4168      	adcs	r0, r5
 80048de:	b2c0      	uxtb	r0, r0
 80048e0:	491c      	ldr	r1, [pc, #112]	; (8004954 <test_011_001_execute.10433+0x154>)
 80048e2:	f7fb ffe5 	bl	80008b0 <_test_assert>
 80048e6:	2800      	cmp	r0, #0
 80048e8:	d1a5      	bne.n	8004836 <test_011_001_execute.10433+0x36>
    test_assert(total1 == total2, "total free space changed");
 80048ea:	9b00      	ldr	r3, [sp, #0]
 80048ec:	9a02      	ldr	r2, [sp, #8]
 80048ee:	491a      	ldr	r1, [pc, #104]	; (8004958 <test_011_001_execute.10433+0x158>)
 80048f0:	1a98      	subs	r0, r3, r2
 80048f2:	4243      	negs	r3, r0
 80048f4:	4158      	adcs	r0, r3
 80048f6:	b2c0      	uxtb	r0, r0
 80048f8:	f7fb ffda 	bl	80008b0 <_test_assert>
 80048fc:	2800      	cmp	r0, #0
 80048fe:	d19a      	bne.n	8004836 <test_011_001_execute.10433+0x36>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8004900:	9b01      	ldr	r3, [sp, #4]
 8004902:	9a03      	ldr	r2, [sp, #12]
 8004904:	4915      	ldr	r1, [pc, #84]	; (800495c <test_011_001_execute.10433+0x15c>)
 8004906:	1a98      	subs	r0, r3, r2
 8004908:	4243      	negs	r3, r0
 800490a:	4158      	adcs	r0, r3
 800490c:	b2c0      	uxtb	r0, r0
 800490e:	f7fb ffcf 	bl	80008b0 <_test_assert>
 8004912:	e790      	b.n	8004836 <test_011_001_execute.10433+0x36>
 8004914:	20000ed4 	.word	0x20000ed4
 8004918:	20000bb8 	.word	0x20000bb8
 800491c:	20000f44 	.word	0x20000f44
 8004920:	08005cc0 	.word	0x08005cc0
 8004924:	080060e0 	.word	0x080060e0
 8004928:	08005e04 	.word	0x08005e04
 800492c:	20000b84 	.word	0x20000b84
 8004930:	08006108 	.word	0x08006108
 8004934:	080060e8 	.word	0x080060e8
 8004938:	08005e0c 	.word	0x08005e0c
 800493c:	080060f0 	.word	0x080060f0
 8004940:	08005e08 	.word	0x08005e08
 8004944:	000200c8 	.word	0x000200c8
 8004948:	08006120 	.word	0x08006120
 800494c:	08006160 	.word	0x08006160
 8004950:	08005df0 	.word	0x08005df0
 8004954:	08006164 	.word	0x08006164
 8004958:	0800617c 	.word	0x0800617c
 800495c:	08006198 	.word	0x08006198

08004960 <test_007_005_execute.9793>:

static void test_007_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_005_execute(void) {
 8004960:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8004962:	4c2b      	ldr	r4, [pc, #172]	; (8004a10 <test_007_005_execute.9793+0xb0>)
 8004964:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8004966:	2005      	movs	r0, #5
static void test_007_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8004968:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 800496a:	f7fc f851 	bl	8000a10 <chEvtAddEvents>
  }

  /* [7.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800496e:	2302      	movs	r3, #2
 8004970:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8004972:	f000 fd75 	bl	8005460 <chEvtWaitAll.constprop.30>
    test_assert(m == 5, "unexpected pending bit");
 8004976:	3805      	subs	r0, #5
 8004978:	4243      	negs	r3, r0
 800497a:	4158      	adcs	r0, r3
 800497c:	b2c0      	uxtb	r0, r0
 800497e:	4925      	ldr	r1, [pc, #148]	; (8004a14 <test_007_005_execute.9793+0xb4>)
 8004980:	f7fb ff96 	bl	80008b0 <_test_assert>
 8004984:	2800      	cmp	r0, #0
 8004986:	d000      	beq.n	800498a <test_007_005_execute.9793+0x2a>
    test_assert(m == 5, "event flags error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 8004988:	bd70      	pop	{r4, r5, r6, pc}
     returned.*/
  test_set_step(2);
  {
    m = chEvtWaitAll(5);
    test_assert(m == 5, "unexpected pending bit");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800498a:	f000 fcf1 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 800498e:	4d22      	ldr	r5, [pc, #136]	; (8004a18 <test_007_005_execute.9793+0xb8>)
 8004990:	4243      	negs	r3, r0
 8004992:	4158      	adcs	r0, r3
 8004994:	b2c0      	uxtb	r0, r0
 8004996:	1c29      	adds	r1, r5, #0
 8004998:	f7fb ff8a 	bl	80008b0 <_test_assert>
 800499c:	2800      	cmp	r0, #0
 800499e:	d1f3      	bne.n	8004988 <test_007_005_execute.9793+0x28>
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 80049a0:	2303      	movs	r3, #3
  {
    chEvtAddEvents(4);
 80049a2:	2004      	movs	r0, #4
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 80049a4:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(4);
 80049a6:	f7fc f833 	bl	8000a10 <chEvtAddEvents>
  }

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 80049aa:	2304      	movs	r3, #4
 80049ac:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 80049ae:	f7fe fbb7 	bl	8003120 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80049b2:	4b1a      	ldr	r3, [pc, #104]	; (8004a1c <test_007_005_execute.9793+0xbc>)
 80049b4:	1c06      	adds	r6, r0, #0
 80049b6:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80049b8:	4a19      	ldr	r2, [pc, #100]	; (8004a20 <test_007_005_execute.9793+0xc0>)
 80049ba:	6899      	ldr	r1, [r3, #8]
 80049bc:	4819      	ldr	r0, [pc, #100]	; (8004a24 <test_007_005_execute.9793+0xc4>)
 80049be:	3901      	subs	r1, #1
 80049c0:	f000 fc1e 	bl	8005200 <chThdCreateStatic.constprop.52>
 80049c4:	4b18      	ldr	r3, [pc, #96]	; (8004a28 <test_007_005_execute.9793+0xc8>)
 80049c6:	6018      	str	r0, [r3, #0]
  }

  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 80049c8:	2305      	movs	r3, #5
 80049ca:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 80049cc:	f000 fd48 	bl	8005460 <chEvtWaitAll.constprop.30>

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
 80049d0:	1c33      	adds	r3, r6, #0
 80049d2:	3332      	adds	r3, #50	; 0x32
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80049d4:	3634      	adds	r6, #52	; 0x34
  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 80049d6:	1c04      	adds	r4, r0, #0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80049d8:	b2b1      	uxth	r1, r6
 80049da:	b298      	uxth	r0, r3
 80049dc:	f7fb fdd0 	bl	8000580 <_test_assert_time_window.constprop.2>
 80049e0:	2800      	cmp	r0, #0
 80049e2:	d1d1      	bne.n	8004988 <test_007_005_execute.9793+0x28>
                            "out of time window");
    test_assert(m == 5, "event flags error");
 80049e4:	1f60      	subs	r0, r4, #5
 80049e6:	4244      	negs	r4, r0
 80049e8:	4160      	adcs	r0, r4
 80049ea:	b2c0      	uxtb	r0, r0
 80049ec:	490f      	ldr	r1, [pc, #60]	; (8004a2c <test_007_005_execute.9793+0xcc>)
 80049ee:	f7fb ff5f 	bl	80008b0 <_test_assert>
 80049f2:	2800      	cmp	r0, #0
 80049f4:	d1c8      	bne.n	8004988 <test_007_005_execute.9793+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80049f6:	f000 fcbb 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
    test_assert(m == 0, "stuck event");
 80049fa:	4243      	negs	r3, r0
 80049fc:	4158      	adcs	r0, r3
 80049fe:	b2c0      	uxtb	r0, r0
 8004a00:	1c29      	adds	r1, r5, #0
 8004a02:	f7fb ff55 	bl	80008b0 <_test_assert>
 8004a06:	2800      	cmp	r0, #0
 8004a08:	d1be      	bne.n	8004988 <test_007_005_execute.9793+0x28>
    test_wait_threads();
 8004a0a:	f7fd f8f9 	bl	8001c00 <test_wait_threads>
 8004a0e:	e7bb      	b.n	8004988 <test_007_005_execute.9793+0x28>
 8004a10:	20000f44 	.word	0x20000f44
 8004a14:	08005d9c 	.word	0x08005d9c
 8004a18:	08005db4 	.word	0x08005db4
 8004a1c:	20000ed4 	.word	0x20000ed4
 8004a20:	08002e71 	.word	0x08002e71
 8004a24:	20000518 	.word	0x20000518
 8004a28:	20000b84 	.word	0x20000b84
 8004a2c:	080061b8 	.word	0x080061b8

08004a30 <test_009_003_setup.10164>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004a30:	4b04      	ldr	r3, [pc, #16]	; (8004a44 <test_009_003_setup.10164+0x14>)
 8004a32:	2200      	movs	r2, #0
  mp->object_size = size;
 8004a34:	2104      	movs	r1, #4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004a36:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
 8004a38:	6119      	str	r1, [r3, #16]
  mp->provider = provider;
 8004a3a:	615a      	str	r2, [r3, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a3c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004a3e:	605b      	str	r3, [r3, #4]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8004a40:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_009_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}
 8004a42:	4770      	bx	lr
 8004a44:	20000464 	.word	0x20000464
 8004a48:	46c0      	nop			; (mov r8, r8)
 8004a4a:	46c0      	nop			; (mov r8, r8)
 8004a4c:	46c0      	nop			; (mov r8, r8)
 8004a4e:	46c0      	nop			; (mov r8, r8)

08004a50 <test_004_003_setup.9158>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a50:	4b02      	ldr	r3, [pc, #8]	; (8004a5c <test_004_003_setup.9158+0xc>)
 8004a52:	2200      	movs	r2, #0
 8004a54:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004a56:	605b      	str	r3, [r3, #4]
 8004a58:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_004_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8004a5a:	4770      	bx	lr
 8004a5c:	20000508 	.word	0x20000508

08004a60 <test_004_002_setup.9160>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a60:	4b02      	ldr	r3, [pc, #8]	; (8004a6c <test_004_002_setup.9160+0xc>)
 8004a62:	2200      	movs	r2, #0
 8004a64:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004a66:	605b      	str	r3, [r3, #4]
 8004a68:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8004a6a:	4770      	bx	lr
 8004a6c:	20000508 	.word	0x20000508

08004a70 <test_004_001_setup.9162>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a70:	4b02      	ldr	r3, [pc, #8]	; (8004a7c <test_004_001_setup.9162+0xc>)
 8004a72:	2201      	movs	r2, #1
 8004a74:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004a76:	605b      	str	r3, [r3, #4]
 8004a78:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_004_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}
 8004a7a:	4770      	bx	lr
 8004a7c:	20000508 	.word	0x20000508

08004a80 <test_008_001_setup.10015>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8004a80:	4b09      	ldr	r3, [pc, #36]	; (8004aa8 <test_008_001_setup.10015+0x28>)
 8004a82:	4a0a      	ldr	r2, [pc, #40]	; (8004aac <test_008_001_setup.10015+0x2c>)
 8004a84:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
 8004a86:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8004a88:	609a      	str	r2, [r3, #8]
  mbp->top = &buf[n];
 8004a8a:	3210      	adds	r2, #16
 8004a8c:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a8e:	1c1a      	adds	r2, r3, #0
 8004a90:	321c      	adds	r2, #28
 8004a92:	61da      	str	r2, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8004a94:	621a      	str	r2, [r3, #32]
 8004a96:	2204      	movs	r2, #4
 8004a98:	625a      	str	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004a9a:	1c1a      	adds	r2, r3, #0
 8004a9c:	3210      	adds	r2, #16
 8004a9e:	611a      	str	r2, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8004aa0:	615a      	str	r2, [r3, #20]
 8004aa2:	2200      	movs	r2, #0
 8004aa4:	619a      	str	r2, [r3, #24]
 * .
 */

static void test_008_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8004aa6:	4770      	bx	lr
 8004aa8:	2000042c 	.word	0x2000042c
 8004aac:	20000b98 	.word	0x20000b98

08004ab0 <test_009_002_setup.10166>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004ab0:	4b04      	ldr	r3, [pc, #16]	; (8004ac4 <test_009_002_setup.10166+0x14>)
 8004ab2:	2200      	movs	r2, #0
  mp->object_size = size;
 8004ab4:	2104      	movs	r1, #4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004ab6:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
 8004ab8:	6119      	str	r1, [r3, #16]
  mp->provider = provider;
 8004aba:	615a      	str	r2, [r3, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004abc:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004abe:	605b      	str	r3, [r3, #4]
 8004ac0:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_009_002_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}
 8004ac2:	4770      	bx	lr
 8004ac4:	20000464 	.word	0x20000464
 8004ac8:	46c0      	nop			; (mov r8, r8)
 8004aca:	46c0      	nop			; (mov r8, r8)
 8004acc:	46c0      	nop			; (mov r8, r8)
 8004ace:	46c0      	nop			; (mov r8, r8)

08004ad0 <test_012_010_setup.10617>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004ad0:	4b02      	ldr	r3, [pc, #8]	; (8004adc <test_012_010_setup.10617+0xc>)
 8004ad2:	2201      	movs	r2, #1
 8004ad4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004ad6:	605b      	str	r3, [r3, #4]
 8004ad8:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_012_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}
 8004ada:	4770      	bx	lr
 8004adc:	20000ba8 	.word	0x20000ba8

08004ae0 <test_012_007_setup.10619>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004ae0:	4b02      	ldr	r3, [pc, #8]	; (8004aec <test_012_007_setup.10619+0xc>)
 8004ae2:	2200      	movs	r2, #0
 8004ae4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004ae6:	605b      	str	r3, [r3, #4]
 8004ae8:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_012_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8004aea:	4770      	bx	lr
 8004aec:	20000ba8 	.word	0x20000ba8

08004af0 <test_004_005_setup.9154>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004af0:	4b02      	ldr	r3, [pc, #8]	; (8004afc <test_004_005_setup.9154+0xc>)
 8004af2:	2200      	movs	r2, #0
 8004af4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004af6:	605b      	str	r3, [r3, #4]
 8004af8:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_004_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8004afa:	4770      	bx	lr
 8004afc:	20000508 	.word	0x20000508

08004b00 <test_009_001_setup.10168>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004b00:	4b03      	ldr	r3, [pc, #12]	; (8004b10 <test_009_001_setup.10168+0x10>)
 8004b02:	2200      	movs	r2, #0
  mp->object_size = size;
 8004b04:	2104      	movs	r1, #4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004b06:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8004b08:	6059      	str	r1, [r3, #4]
  mp->provider = provider;
 8004b0a:	609a      	str	r2, [r3, #8]
 * .
 */

static void test_009_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}
 8004b0c:	4770      	bx	lr
 8004b0e:	46c0      	nop			; (mov r8, r8)
 8004b10:	20000458 	.word	0x20000458
 8004b14:	46c0      	nop			; (mov r8, r8)
 8004b16:	46c0      	nop			; (mov r8, r8)
 8004b18:	46c0      	nop			; (mov r8, r8)
 8004b1a:	46c0      	nop			; (mov r8, r8)
 8004b1c:	46c0      	nop			; (mov r8, r8)
 8004b1e:	46c0      	nop			; (mov r8, r8)

08004b20 <chMtxTryLock.constprop.45.4291>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004b20:	b672      	cpsid	i
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8004b22:	4b07      	ldr	r3, [pc, #28]	; (8004b40 <chMtxTryLock.constprop.45.4291+0x20>)
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 8004b24:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8004b26:	6899      	ldr	r1, [r3, #8]
 8004b28:	2900      	cmp	r1, #0
 8004b2a:	d001      	beq.n	8004b30 <chMtxTryLock.constprop.45.4291+0x10>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004b2c:	b662      	cpsie	i
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8004b2e:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8004b30:	4a04      	ldr	r2, [pc, #16]	; (8004b44 <chMtxTryLock.constprop.45.4291+0x24>)
  mp->next = currp->mtxlist;
  currp->mtxlist = mp;
 8004b32:	2001      	movs	r0, #1

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8004b34:	6992      	ldr	r2, [r2, #24]
  mp->next = currp->mtxlist;
 8004b36:	6b91      	ldr	r1, [r2, #56]	; 0x38

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8004b38:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 8004b3a:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 8004b3c:	6393      	str	r3, [r2, #56]	; 0x38
 8004b3e:	e7f5      	b.n	8004b2c <chMtxTryLock.constprop.45.4291+0xc>
 8004b40:	20000418 	.word	0x20000418
 8004b44:	20000ed4 	.word	0x20000ed4
 8004b48:	46c0      	nop			; (mov r8, r8)
 8004b4a:	46c0      	nop			; (mov r8, r8)
 8004b4c:	46c0      	nop			; (mov r8, r8)
 8004b4e:	46c0      	nop			; (mov r8, r8)

08004b50 <Vector80>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8004b50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004b52:	4646      	mov	r6, r8
 8004b54:	464f      	mov	r7, r9
 8004b56:	b4c0      	push	{r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8004b58:	4e22      	ldr	r6, [pc, #136]	; (8004be4 <Vector80+0x94>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8004b5a:	46f0      	mov	r8, lr

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8004b5c:	6933      	ldr	r3, [r6, #16]
 8004b5e:	0798      	lsls	r0, r3, #30
 8004b60:	d406      	bmi.n	8004b70 <Vector80+0x20>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8004b62:	4640      	mov	r0, r8
 8004b64:	f7fb ff1c 	bl	80009a0 <_port_irq_epilogue>
}
 8004b68:	bc0c      	pop	{r2, r3}
 8004b6a:	4690      	mov	r8, r2
 8004b6c:	4699      	mov	r9, r3
 8004b6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8004b70:	2300      	movs	r3, #0
 8004b72:	6133      	str	r3, [r6, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004b74:	b672      	cpsid	i
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8004b76:	4c1c      	ldr	r4, [pc, #112]	; (8004be8 <Vector80+0x98>)
 8004b78:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8004b7a:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8004b7c:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 8004b7e:	b280      	uxth	r0, r0
 8004b80:	1a45      	subs	r5, r0, r1
 8004b82:	891a      	ldrh	r2, [r3, #8]
 8004b84:	b2ad      	uxth	r5, r5
 8004b86:	4295      	cmp	r5, r2
 8004b88:	d31a      	bcc.n	8004bc0 <Vector80+0x70>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8004b8a:	1c25      	adds	r5, r4, #0
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8004b8c:	2700      	movs	r7, #0
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8004b8e:	351c      	adds	r5, #28
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8004b90:	46b9      	mov	r9, r7
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8004b92:	188a      	adds	r2, r1, r2
 8004b94:	84e2      	strh	r2, [r4, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8004b96:	681a      	ldr	r2, [r3, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8004b98:	4648      	mov	r0, r9
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8004b9a:	6055      	str	r5, [r2, #4]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8004b9c:	68d9      	ldr	r1, [r3, #12]

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
 8004b9e:	61e2      	str	r2, [r4, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8004ba0:	60d8      	str	r0, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8004ba2:	42aa      	cmp	r2, r5
 8004ba4:	d01a      	beq.n	8004bdc <Vector80+0x8c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004ba6:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8004ba8:	6918      	ldr	r0, [r3, #16]
 8004baa:	4788      	blx	r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004bac:	b672      	cpsid	i
 8004bae:	6a70      	ldr	r0, [r6, #36]	; 0x24
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8004bb0:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8004bb2:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 8004bb4:	b280      	uxth	r0, r0
 8004bb6:	1a47      	subs	r7, r0, r1
 8004bb8:	891a      	ldrh	r2, [r3, #8]
 8004bba:	b2bf      	uxth	r7, r7
 8004bbc:	42ba      	cmp	r2, r7
 8004bbe:	d9e8      	bls.n	8004b92 <Vector80+0x42>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8004bc0:	4c0a      	ldr	r4, [pc, #40]	; (8004bec <Vector80+0x9c>)
 8004bc2:	42a3      	cmp	r3, r4
 8004bc4:	d008      	beq.n	8004bd8 <Vector80+0x88>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8004bc6:	188a      	adds	r2, r1, r2
 8004bc8:	1a12      	subs	r2, r2, r0
 8004bca:	b292      	uxth	r2, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004bcc:	2a01      	cmp	r2, #1
 8004bce:	d907      	bls.n	8004be0 <Vector80+0x90>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 8004bd0:	1812      	adds	r2, r2, r0
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004bd2:	4b04      	ldr	r3, [pc, #16]	; (8004be4 <Vector80+0x94>)
 8004bd4:	b292      	uxth	r2, r2
 8004bd6:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004bd8:	b662      	cpsie	i
 8004bda:	e7c2      	b.n	8004b62 <Vector80+0x12>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8004bdc:	60f0      	str	r0, [r6, #12]
 8004bde:	e7e2      	b.n	8004ba6 <Vector80+0x56>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004be0:	2202      	movs	r2, #2
 8004be2:	e7f5      	b.n	8004bd0 <Vector80+0x80>
 8004be4:	40000400 	.word	0x40000400
 8004be8:	20000ed4 	.word	0x20000ed4
 8004bec:	20000ef0 	.word	0x20000ef0

08004bf0 <test_002_004_execute.8696>:
 * - [2.4.3] Raising thread priority above the boosted level.
 * - [2.4.4] Restoring original conditions.
 * .
 */

static void test_002_004_execute(void) {
 8004bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004bf2:	464e      	mov	r6, r9
 8004bf4:	4645      	mov	r5, r8
 8004bf6:	4657      	mov	r7, sl
 8004bf8:	b4e0      	push	{r5, r6, r7}
 8004bfa:	4d33      	ldr	r5, [pc, #204]	; (8004cc8 <test_002_004_execute.8696+0xd8>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8004bfc:	4a33      	ldr	r2, [pc, #204]	; (8004ccc <test_002_004_execute.8696+0xdc>)
 8004bfe:	69ab      	ldr	r3, [r5, #24]
 8004c00:	4690      	mov	r8, r2
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004c02:	689c      	ldr	r4, [r3, #8]

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8004c04:	1ca6      	adds	r6, r4, #2

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8004c06:	1c67      	adds	r7, r4, #1

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8004c08:	609e      	str	r6, [r3, #8]

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8004c0a:	1c38      	adds	r0, r7, #0
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8004c0c:	2302      	movs	r3, #2
 8004c0e:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 8004c10:	f7fb ff7e 	bl	8000b10 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8004c14:	1b00      	subs	r0, r0, r4
 8004c16:	4243      	negs	r3, r0
 8004c18:	4158      	adcs	r0, r3
 8004c1a:	4b2d      	ldr	r3, [pc, #180]	; (8004cd0 <test_002_004_execute.8696+0xe0>)
 8004c1c:	b2c0      	uxtb	r0, r0
 8004c1e:	1c19      	adds	r1, r3, #0
 8004c20:	4699      	mov	r9, r3
 8004c22:	f7fb fe45 	bl	80008b0 <_test_assert>
 8004c26:	2800      	cmp	r0, #0
 8004c28:	d004      	beq.n	8004c34 <test_002_004_execute.8696+0x44>
    chSysLock();
    chThdGetSelfX()->prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
}
 8004c2a:	bc1c      	pop	{r2, r3, r4}
 8004c2c:	4690      	mov	r8, r2
 8004c2e:	4699      	mov	r9, r3
 8004c30:	46a2      	mov	sl, r4
 8004c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
    test_assert(p1 == prio, "unexpected returned priority level");
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8004c34:	69ab      	ldr	r3, [r5, #24]
 8004c36:	6898      	ldr	r0, [r3, #8]
 8004c38:	1a30      	subs	r0, r6, r0
 8004c3a:	4246      	negs	r6, r0
 8004c3c:	4170      	adcs	r0, r6
 8004c3e:	4e25      	ldr	r6, [pc, #148]	; (8004cd4 <test_002_004_execute.8696+0xe4>)
 8004c40:	b2c0      	uxtb	r0, r0
 8004c42:	1c31      	adds	r1, r6, #0
 8004c44:	f7fb fe34 	bl	80008b0 <_test_assert>
 8004c48:	2800      	cmp	r0, #0
 8004c4a:	d1ee      	bne.n	8004c2a <test_002_004_execute.8696+0x3a>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8004c4c:	69ab      	ldr	r3, [r5, #24]
 8004c4e:	4922      	ldr	r1, [pc, #136]	; (8004cd8 <test_002_004_execute.8696+0xe8>)
 8004c50:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8004c52:	1a38      	subs	r0, r7, r0
 8004c54:	4243      	negs	r3, r0
 8004c56:	4158      	adcs	r0, r3
 8004c58:	b2c0      	uxtb	r0, r0
 8004c5a:	f7fb fe29 	bl	80008b0 <_test_assert>
 8004c5e:	2800      	cmp	r0, #0
 8004c60:	d1e3      	bne.n	8004c2a <test_002_004_execute.8696+0x3a>
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8004c62:	2303      	movs	r3, #3
 8004c64:	4642      	mov	r2, r8
 8004c66:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 8004c68:	1ce3      	adds	r3, r4, #3
 8004c6a:	1c18      	adds	r0, r3, #0
 8004c6c:	469a      	mov	sl, r3
 8004c6e:	f7fb ff4f 	bl	8000b10 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8004c72:	1a38      	subs	r0, r7, r0
 8004c74:	4247      	negs	r7, r0
 8004c76:	4178      	adcs	r0, r7
 8004c78:	b2c0      	uxtb	r0, r0
 8004c7a:	4649      	mov	r1, r9
 8004c7c:	f7fb fe18 	bl	80008b0 <_test_assert>
 8004c80:	2800      	cmp	r0, #0
 8004c82:	d1d2      	bne.n	8004c2a <test_002_004_execute.8696+0x3a>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8004c84:	69ab      	ldr	r3, [r5, #24]
 8004c86:	4652      	mov	r2, sl
 8004c88:	6898      	ldr	r0, [r3, #8]
 8004c8a:	1c31      	adds	r1, r6, #0
 8004c8c:	1a10      	subs	r0, r2, r0
 8004c8e:	4243      	negs	r3, r0
 8004c90:	4158      	adcs	r0, r3
 8004c92:	b2c0      	uxtb	r0, r0
 8004c94:	f7fb fe0c 	bl	80008b0 <_test_assert>
 8004c98:	2800      	cmp	r0, #0
 8004c9a:	d1c6      	bne.n	8004c2a <test_002_004_execute.8696+0x3a>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8004c9c:	69ab      	ldr	r3, [r5, #24]
 8004c9e:	490f      	ldr	r1, [pc, #60]	; (8004cdc <test_002_004_execute.8696+0xec>)
 8004ca0:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8004ca2:	4653      	mov	r3, sl
 8004ca4:	1a18      	subs	r0, r3, r0
 8004ca6:	4243      	negs	r3, r0
 8004ca8:	4158      	adcs	r0, r3
 8004caa:	b2c0      	uxtb	r0, r0
 8004cac:	f7fb fe00 	bl	80008b0 <_test_assert>
 8004cb0:	2800      	cmp	r0, #0
 8004cb2:	d1ba      	bne.n	8004c2a <test_002_004_execute.8696+0x3a>
  }

  /* [2.4.4] Restoring original conditions.*/
  test_set_step(4);
 8004cb4:	2304      	movs	r3, #4
 8004cb6:	4642      	mov	r2, r8
 8004cb8:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004cba:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004cbc:	69ab      	ldr	r3, [r5, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8004cbe:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8004cc0:	63dc      	str	r4, [r3, #60]	; 0x3c
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004cc2:	b662      	cpsie	i
 8004cc4:	e7b1      	b.n	8004c2a <test_002_004_execute.8696+0x3a>
 8004cc6:	46c0      	nop			; (mov r8, r8)
 8004cc8:	20000ed4 	.word	0x20000ed4
 8004ccc:	20000f44 	.word	0x20000f44
 8004cd0:	08005c80 	.word	0x08005c80
 8004cd4:	08005ca4 	.word	0x08005ca4
 8004cd8:	080061cc 	.word	0x080061cc
 8004cdc:	080061f4 	.word	0x080061f4

08004ce0 <thread1.8955>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8004ce0:	b510      	push	{r4, lr}
 8004ce2:	1c04      	adds	r4, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ce4:	b672      	cpsid	i
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004ce6:	4a08      	ldr	r2, [pc, #32]	; (8004d08 <thread1.8955+0x28>)
 8004ce8:	6810      	ldr	r0, [r2, #0]
 8004cea:	2800      	cmp	r0, #0
 8004cec:	d004      	beq.n	8004cf8 <thread1.8955+0x18>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004cee:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 8004cf0:	6241      	str	r1, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004cf2:	6011      	str	r1, [r2, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8004cf4:	f7fc f89c 	bl	8000e30 <chSchReadyI>

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
 8004cf8:	f7fb fee2 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004cfc:	b662      	cpsie	i
  chSysUnlock();
  test_emit_token(*(char *)p);
 8004cfe:	7820      	ldrb	r0, [r4, #0]
 8004d00:	f7fb fc76 	bl	80005f0 <test_emit_token>
}
 8004d04:	bd10      	pop	{r4, pc}
 8004d06:	46c0      	nop			; (mov r8, r8)
 8004d08:	20000b80 	.word	0x20000b80
 8004d0c:	46c0      	nop			; (mov r8, r8)
 8004d0e:	46c0      	nop			; (mov r8, r8)

08004d10 <chSemSignalWait.constprop.46.4281>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8004d10:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d12:	b672      	cpsid	i
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
 8004d14:	4c12      	ldr	r4, [pc, #72]	; (8004d60 <chSemSignalWait.constprop.46.4281+0x50>)
 8004d16:	68a3      	ldr	r3, [r4, #8]
 8004d18:	3301      	adds	r3, #1
 8004d1a:	60a3      	str	r3, [r4, #8]
 8004d1c:	2b00      	cmp	r3, #0
 8004d1e:	dd15      	ble.n	8004d4c <chSemSignalWait.constprop.46.4281+0x3c>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8004d20:	3b01      	subs	r3, #1
 8004d22:	60a3      	str	r3, [r4, #8]
 8004d24:	2b00      	cmp	r3, #0
 8004d26:	db04      	blt.n	8004d32 <chSemSignalWait.constprop.46.4281+0x22>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8004d28:	f7fb feca 	bl	8000ac0 <chSchRescheduleS>
    msg = MSG_OK;
 8004d2c:	2000      	movs	r0, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d2e:	b662      	cpsie	i
  }
  chSysUnlock();

  return msg;
}
 8004d30:	bd38      	pop	{r3, r4, r5, pc}
  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8004d32:	4b0c      	ldr	r3, [pc, #48]	; (8004d64 <chSemSignalWait.constprop.46.4281+0x54>)
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8004d34:	2005      	movs	r0, #5
  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8004d36:	699d      	ldr	r5, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8004d38:	6863      	ldr	r3, [r4, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8004d3a:	602c      	str	r4, [r5, #0]
  tp->queue.prev             = tqp->prev;
 8004d3c:	606b      	str	r3, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8004d3e:	601d      	str	r5, [r3, #0]
  tqp->prev                  = tp;
 8004d40:	6065      	str	r5, [r4, #4]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 8004d42:	626c      	str	r4, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 8004d44:	f7fb ffd4 	bl	8000cf0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8004d48:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8004d4a:	e7f0      	b.n	8004d2e <chSemSignalWait.constprop.46.4281+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8004d4c:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 8004d4e:	6803      	ldr	r3, [r0, #0]
 8004d50:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004d52:	605c      	str	r4, [r3, #4]
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8004d54:	f7fc f86c 	bl	8000e30 <chSchReadyI>
 8004d58:	2300      	movs	r3, #0
 8004d5a:	6243      	str	r3, [r0, #36]	; 0x24
 8004d5c:	68a3      	ldr	r3, [r4, #8]
 8004d5e:	e7df      	b.n	8004d20 <chSemSignalWait.constprop.46.4281+0x10>
 8004d60:	20000508 	.word	0x20000508
 8004d64:	20000ed4 	.word	0x20000ed4
 8004d68:	46c0      	nop			; (mov r8, r8)
 8004d6a:	46c0      	nop			; (mov r8, r8)
 8004d6c:	46c0      	nop			; (mov r8, r8)
 8004d6e:	46c0      	nop			; (mov r8, r8)

08004d70 <test_005_005_execute.9426>:

static void test_005_005_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_005_execute(void) {
 8004d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004d72:	465f      	mov	r7, fp
 8004d74:	4656      	mov	r6, sl
 8004d76:	464d      	mov	r5, r9
 8004d78:	4644      	mov	r4, r8
 8004d7a:	b4f0      	push	{r4, r5, r6, r7}
 8004d7c:	4d53      	ldr	r5, [pc, #332]	; (8004ecc <test_005_005_execute.9426+0x15c>)
    prio = chThdGetPriorityX();
  }

  /* [5.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 8004d7e:	4c54      	ldr	r4, [pc, #336]	; (8004ed0 <test_005_005_execute.9426+0x160>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004d80:	69ab      	ldr	r3, [r5, #24]
 8004d82:	689f      	ldr	r7, [r3, #8]
 8004d84:	2302      	movs	r3, #2
 8004d86:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004d88:	f7ff feca 	bl	8004b20 <chMtxTryLock.constprop.45.4291>
    test_assert(b, "already locked");
 8004d8c:	4e51      	ldr	r6, [pc, #324]	; (8004ed4 <test_005_005_execute.9426+0x164>)
 8004d8e:	1c31      	adds	r1, r6, #0
 8004d90:	f7fb fd8e 	bl	80008b0 <_test_assert>
 8004d94:	2800      	cmp	r0, #0
 8004d96:	d005      	beq.n	8004da4 <test_005_005_execute.9426+0x34>
  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  }
}
 8004d98:	bc3c      	pop	{r2, r3, r4, r5}
 8004d9a:	4690      	mov	r8, r2
 8004d9c:	4699      	mov	r9, r3
 8004d9e:	46a2      	mov	sl, r4
 8004da0:	46ab      	mov	fp, r5
 8004da2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(b, "already locked");
  }

  /* [5.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 8004da4:	2303      	movs	r3, #3
 8004da6:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004da8:	f7ff feba 	bl	8004b20 <chMtxTryLock.constprop.45.4291>
    test_assert(!b, "not locked");
 8004dac:	2201      	movs	r2, #1
 8004dae:	4691      	mov	r9, r2
 8004db0:	464b      	mov	r3, r9
 8004db2:	4a49      	ldr	r2, [pc, #292]	; (8004ed8 <test_005_005_execute.9426+0x168>)
 8004db4:	4058      	eors	r0, r3
 8004db6:	b2c0      	uxtb	r0, r0
 8004db8:	1c11      	adds	r1, r2, #0
 8004dba:	4690      	mov	r8, r2
 8004dbc:	f7fb fd78 	bl	80008b0 <_test_assert>
 8004dc0:	2800      	cmp	r0, #0
 8004dc2:	d1e9      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
  }

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8004dc4:	2304      	movs	r3, #4
 8004dc6:	6023      	str	r3, [r4, #0]
  {
    chMtxUnlock(&m1);
 8004dc8:	4b44      	ldr	r3, [pc, #272]	; (8004edc <test_005_005_execute.9426+0x16c>)
 8004dca:	469a      	mov	sl, r3
 8004dcc:	1c18      	adds	r0, r3, #0
 8004dce:	f7fc f8df 	bl	8000f90 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8004dd2:	4652      	mov	r2, sl
 8004dd4:	6892      	ldr	r2, [r2, #8]
 8004dd6:	4250      	negs	r0, r2
 8004dd8:	4150      	adcs	r0, r2
 8004dda:	4b41      	ldr	r3, [pc, #260]	; (8004ee0 <test_005_005_execute.9426+0x170>)
 8004ddc:	b2c0      	uxtb	r0, r0
 8004dde:	1c19      	adds	r1, r3, #0
 8004de0:	469b      	mov	fp, r3
 8004de2:	f7fb fd65 	bl	80008b0 <_test_assert>
 8004de6:	2800      	cmp	r0, #0
 8004de8:	d1d6      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004dea:	4652      	mov	r2, sl
 8004dec:	6812      	ldr	r2, [r2, #0]
 8004dee:	4653      	mov	r3, sl
 8004df0:	1ad0      	subs	r0, r2, r3
 8004df2:	4243      	negs	r3, r0
 8004df4:	4158      	adcs	r0, r3
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004df6:	b2c0      	uxtb	r0, r0
 8004df8:	493a      	ldr	r1, [pc, #232]	; (8004ee4 <test_005_005_execute.9426+0x174>)
 8004dfa:	f7fb fd59 	bl	80008b0 <_test_assert>
 8004dfe:	2800      	cmp	r0, #0
 8004e00:	d1ca      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8004e02:	2305      	movs	r3, #5
 8004e04:	6023      	str	r3, [r4, #0]
 8004e06:	69ab      	ldr	r3, [r5, #24]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004e08:	4937      	ldr	r1, [pc, #220]	; (8004ee8 <test_005_005_execute.9426+0x178>)
 8004e0a:	6898      	ldr	r0, [r3, #8]
 8004e0c:	1a38      	subs	r0, r7, r0
 8004e0e:	4243      	negs	r3, r0
 8004e10:	4158      	adcs	r0, r3
 8004e12:	b2c0      	uxtb	r0, r0
 8004e14:	f7fb fd4c 	bl	80008b0 <_test_assert>
 8004e18:	2800      	cmp	r0, #0
 8004e1a:	d1bd      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
  }

  /* [5.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8004e1c:	2306      	movs	r3, #6
 8004e1e:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004e20:	f7ff fe7e 	bl	8004b20 <chMtxTryLock.constprop.45.4291>
    test_assert(b, "already locked");
 8004e24:	1c31      	adds	r1, r6, #0
 8004e26:	f7fb fd43 	bl	80008b0 <_test_assert>
 8004e2a:	2800      	cmp	r0, #0
 8004e2c:	d1b4      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
    b = chMtxTryLock(&m1);
 8004e2e:	f7ff fe77 	bl	8004b20 <chMtxTryLock.constprop.45.4291>
    test_assert(!b, "not locked");
 8004e32:	464b      	mov	r3, r9
 8004e34:	4058      	eors	r0, r3
 8004e36:	b2c0      	uxtb	r0, r0
 8004e38:	4641      	mov	r1, r8
 8004e3a:	f7fb fd39 	bl	80008b0 <_test_assert>
 8004e3e:	2800      	cmp	r0, #0
 8004e40:	d1aa      	bne.n	8004d98 <test_005_005_execute.9426+0x28>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8004e42:	69ae      	ldr	r6, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004e44:	b672      	cpsid	i

  chSysLock();
  if (ctp->mtxlist != NULL) {
 8004e46:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8004e48:	2b00      	cmp	r3, #0
 8004e4a:	d01a      	beq.n	8004e82 <test_005_005_execute.9426+0x112>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004e4c:	2200      	movs	r2, #0
 8004e4e:	4690      	mov	r8, r2
 8004e50:	e00b      	b.n	8004e6a <test_005_005_execute.9426+0xfa>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004e52:	6802      	ldr	r2, [r0, #0]
 8004e54:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004e56:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 8004e58:	6b82      	ldr	r2, [r0, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 8004e5a:	6098      	str	r0, [r3, #8]
        mp->next = tp->mtxlist;
 8004e5c:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
 8004e5e:	6383      	str	r3, [r0, #56]	; 0x38
        (void) chSchReadyI(tp);
 8004e60:	f7fb ffe6 	bl	8000e30 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 8004e64:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8004e66:	2b00      	cmp	r3, #0
 8004e68:	d007      	beq.n	8004e7a <test_005_005_execute.9426+0x10a>

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 8004e6a:	68da      	ldr	r2, [r3, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004e6c:	6818      	ldr	r0, [r3, #0]
 8004e6e:	63b2      	str	r2, [r6, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8004e70:	4283      	cmp	r3, r0
 8004e72:	d1ee      	bne.n	8004e52 <test_005_005_execute.9426+0xe2>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004e74:	4642      	mov	r2, r8
 8004e76:	609a      	str	r2, [r3, #8]
 8004e78:	e7f4      	b.n	8004e64 <test_005_005_execute.9426+0xf4>
      }
    } while (ctp->mtxlist != NULL);
    ctp->prio = ctp->realprio;
 8004e7a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8004e7c:	60b3      	str	r3, [r6, #8]
    chSchRescheduleS();
 8004e7e:	f7fb fe1f 	bl	8000ac0 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004e82:	b662      	cpsie	i

    chMtxUnlockAll();
    test_assert(m1.owner == NULL, "still owned");
 8004e84:	4652      	mov	r2, sl
 8004e86:	6892      	ldr	r2, [r2, #8]
 8004e88:	4659      	mov	r1, fp
 8004e8a:	4250      	negs	r0, r2
 8004e8c:	4150      	adcs	r0, r2
 8004e8e:	b2c0      	uxtb	r0, r0
 8004e90:	f7fb fd0e 	bl	80008b0 <_test_assert>
 8004e94:	2800      	cmp	r0, #0
 8004e96:	d000      	beq.n	8004e9a <test_005_005_execute.9426+0x12a>
 8004e98:	e77e      	b.n	8004d98 <test_005_005_execute.9426+0x28>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004e9a:	4653      	mov	r3, sl
 8004e9c:	681b      	ldr	r3, [r3, #0]
 8004e9e:	4652      	mov	r2, sl
 8004ea0:	1a98      	subs	r0, r3, r2
 8004ea2:	4243      	negs	r3, r0
 8004ea4:	4158      	adcs	r0, r3
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004ea6:	b2c0      	uxtb	r0, r0
 8004ea8:	490e      	ldr	r1, [pc, #56]	; (8004ee4 <test_005_005_execute.9426+0x174>)
 8004eaa:	f7fb fd01 	bl	80008b0 <_test_assert>
 8004eae:	2800      	cmp	r0, #0
 8004eb0:	d000      	beq.n	8004eb4 <test_005_005_execute.9426+0x144>
 8004eb2:	e771      	b.n	8004d98 <test_005_005_execute.9426+0x28>
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8004eb4:	2307      	movs	r3, #7
 8004eb6:	6023      	str	r3, [r4, #0]
 8004eb8:	69ab      	ldr	r3, [r5, #24]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004eba:	490b      	ldr	r1, [pc, #44]	; (8004ee8 <test_005_005_execute.9426+0x178>)
 8004ebc:	6898      	ldr	r0, [r3, #8]
 8004ebe:	1a38      	subs	r0, r7, r0
 8004ec0:	4247      	negs	r7, r0
 8004ec2:	4178      	adcs	r0, r7
 8004ec4:	b2c0      	uxtb	r0, r0
 8004ec6:	f7fb fcf3 	bl	80008b0 <_test_assert>
 8004eca:	e765      	b.n	8004d98 <test_005_005_execute.9426+0x28>
 8004ecc:	20000ed4 	.word	0x20000ed4
 8004ed0:	20000f44 	.word	0x20000f44
 8004ed4:	08006214 	.word	0x08006214
 8004ed8:	08006224 	.word	0x08006224
 8004edc:	20000418 	.word	0x20000418
 8004ee0:	08006230 	.word	0x08006230
 8004ee4:	08005fc0 	.word	0x08005fc0
 8004ee8:	08005e20 	.word	0x08005e20
 8004eec:	46c0      	nop			; (mov r8, r8)
 8004eee:	46c0      	nop			; (mov r8, r8)

08004ef0 <thread6.9389>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8004ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chMtxLock(&m1);
 8004ef2:	4d15      	ldr	r5, [pc, #84]	; (8004f48 <thread6.9389+0x58>)
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8004ef4:	1c07      	adds	r7, r0, #0

  chMtxLock(&m1);
 8004ef6:	1c28      	adds	r0, r5, #0
 8004ef8:	f7fc f8e2 	bl	80010c0 <chMtxLock>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004efc:	b672      	cpsid	i
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8004efe:	4b13      	ldr	r3, [pc, #76]	; (8004f4c <thread6.9389+0x5c>)
 8004f00:	699c      	ldr	r4, [r3, #24]
 8004f02:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8004f04:	1c30      	adds	r0, r6, #0
 8004f06:	f7fc f81b 	bl	8000f40 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8004f0a:	4a11      	ldr	r2, [pc, #68]	; (8004f50 <thread6.9389+0x60>)
 8004f0c:	6262      	str	r2, [r4, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004f0e:	1c13      	adds	r3, r2, #0
 8004f10:	e003      	b.n	8004f1a <thread6.9389+0x2a>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004f12:	6898      	ldr	r0, [r3, #8]
 8004f14:	68a1      	ldr	r1, [r4, #8]
 8004f16:	4288      	cmp	r0, r1
 8004f18:	d302      	bcc.n	8004f20 <thread6.9389+0x30>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8004f1a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004f1c:	4293      	cmp	r3, r2
 8004f1e:	d1f8      	bne.n	8004f12 <thread6.9389+0x22>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004f20:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8004f22:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8004f24:	6062      	str	r2, [r4, #4]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8004f26:	2007      	movs	r0, #7
  tp->queue.prev->queue.next = tp;
 8004f28:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004f2a:	605c      	str	r4, [r3, #4]
 8004f2c:	f7fb fee0 	bl	8000cf0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 8004f30:	1c30      	adds	r0, r6, #0
 8004f32:	f7fc f85d 	bl	8000ff0 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f36:	b662      	cpsie	i
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8004f38:	7838      	ldrb	r0, [r7, #0]
 8004f3a:	f7fb fb59 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 8004f3e:	1c28      	adds	r0, r5, #0
 8004f40:	f7fc f826 	bl	8000f90 <chMtxUnlock>
}
 8004f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004f46:	46c0      	nop			; (mov r8, r8)
 8004f48:	20000418 	.word	0x20000418
 8004f4c:	20000ed4 	.word	0x20000ed4
 8004f50:	20000410 	.word	0x20000410
 8004f54:	46c0      	nop			; (mov r8, r8)
 8004f56:	46c0      	nop			; (mov r8, r8)
 8004f58:	46c0      	nop			; (mov r8, r8)
 8004f5a:	46c0      	nop			; (mov r8, r8)
 8004f5c:	46c0      	nop			; (mov r8, r8)
 8004f5e:	46c0      	nop			; (mov r8, r8)

08004f60 <test_007_002_execute.9776>:

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_002_execute(void) {
 8004f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8004f62:	4b0f      	ldr	r3, [pc, #60]	; (8004fa0 <test_007_002_execute.9776+0x40>)
 8004f64:	2201      	movs	r2, #1
 8004f66:	601a      	str	r2, [r3, #0]
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8004f68:	2400      	movs	r4, #0
 8004f6a:	2507      	movs	r5, #7
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004f6c:	2601      	movs	r6, #1
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8004f6e:	4f0d      	ldr	r7, [pc, #52]	; (8004fa4 <test_007_002_execute.9776+0x44>)
 8004f70:	e002      	b.n	8004f78 <test_007_002_execute.9776+0x18>
    }
    eid++;
 8004f72:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8004f74:	2d00      	cmp	r5, #0
 8004f76:	d00d      	beq.n	8004f94 <test_007_002_execute.9776+0x34>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004f78:	1c2b      	adds	r3, r5, #0
 8004f7a:	40e3      	lsrs	r3, r4
 8004f7c:	421e      	tst	r6, r3
 8004f7e:	d0f8      	beq.n	8004f72 <test_007_002_execute.9776+0x12>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8004f80:	1c33      	adds	r3, r6, #0
 8004f82:	40a3      	lsls	r3, r4
 8004f84:	439d      	bics	r5, r3
 8004f86:	00a3      	lsls	r3, r4, #2
      handlers[eid](eid);
 8004f88:	1c20      	adds	r0, r4, #0
 8004f8a:	59db      	ldr	r3, [r3, r7]
 8004f8c:	4798      	blx	r3
    }
    eid++;
 8004f8e:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8004f90:	2d00      	cmp	r5, #0
 8004f92:	d1f1      	bne.n	8004f78 <test_007_002_execute.9776+0x18>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8004f94:	4904      	ldr	r1, [pc, #16]	; (8004fa8 <test_007_002_execute.9776+0x48>)
 8004f96:	4805      	ldr	r0, [pc, #20]	; (8004fac <test_007_002_execute.9776+0x4c>)
 8004f98:	f7fb fc5a 	bl	8000850 <_test_assert_sequence>
  }
}
 8004f9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004f9e:	46c0      	nop			; (mov r8, r8)
 8004fa0:	20000f44 	.word	0x20000f44
 8004fa4:	08006244 	.word	0x08006244
 8004fa8:	08005df0 	.word	0x08005df0
 8004fac:	08005e10 	.word	0x08005e10

08004fb0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8004fb0:	4a1b      	ldr	r2, [pc, #108]	; (8005020 <chVTDoResetI+0x70>)
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8004fb2:	b510      	push	{r4, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8004fb4:	69d3      	ldr	r3, [r2, #28]
 8004fb6:	4283      	cmp	r3, r0
 8004fb8:	d00e      	beq.n	8004fd8 <chVTDoResetI+0x28>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8004fba:	6841      	ldr	r1, [r0, #4]
 8004fbc:	6803      	ldr	r3, [r0, #0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004fbe:	321c      	adds	r2, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8004fc0:	600b      	str	r3, [r1, #0]
    vtp->next->prev = vtp->prev;
 8004fc2:	6803      	ldr	r3, [r0, #0]
 8004fc4:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8004fc6:	2100      	movs	r1, #0
 8004fc8:	60c1      	str	r1, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8004fca:	4293      	cmp	r3, r2
 8004fcc:	d003      	beq.n	8004fd6 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 8004fce:	8901      	ldrh	r1, [r0, #8]
 8004fd0:	891a      	ldrh	r2, [r3, #8]
 8004fd2:	188a      	adds	r2, r1, r2
 8004fd4:	811a      	strh	r2, [r3, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004fd6:	bd10      	pop	{r4, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8004fd8:	6819      	ldr	r1, [r3, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8004fda:	1c10      	adds	r0, r2, #0
 8004fdc:	301c      	adds	r0, #28
  vtp->func = NULL;
 8004fde:	2400      	movs	r4, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8004fe0:	61d1      	str	r1, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8004fe2:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8004fe4:	60dc      	str	r4, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004fe6:	4281      	cmp	r1, r0
 8004fe8:	d017      	beq.n	800501a <chVTDoResetI+0x6a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8004fea:	8918      	ldrh	r0, [r3, #8]
 8004fec:	890b      	ldrh	r3, [r1, #8]
 8004fee:	18c3      	adds	r3, r0, r3
 8004ff0:	b29b      	uxth	r3, r3
 8004ff2:	810b      	strh	r3, [r1, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004ff4:	490b      	ldr	r1, [pc, #44]	; (8005024 <chVTDoResetI+0x74>)
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8004ff6:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8004ff8:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8004ffa:	b289      	uxth	r1, r1
 8004ffc:	1a8a      	subs	r2, r1, r2
 8004ffe:	b292      	uxth	r2, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8005000:	4293      	cmp	r3, r2
 8005002:	d9e8      	bls.n	8004fd6 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8005004:	1a9b      	subs	r3, r3, r2
 8005006:	b29b      	uxth	r3, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8005008:	2b01      	cmp	r3, #1
 800500a:	d904      	bls.n	8005016 <chVTDoResetI+0x66>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800500c:	185b      	adds	r3, r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800500e:	4a05      	ldr	r2, [pc, #20]	; (8005024 <chVTDoResetI+0x74>)
 8005010:	b29b      	uxth	r3, r3
 8005012:	6353      	str	r3, [r2, #52]	; 0x34
 8005014:	e7df      	b.n	8004fd6 <chVTDoResetI+0x26>
  delta = ch.vtlist.next->delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005016:	2302      	movs	r3, #2
 8005018:	e7f8      	b.n	800500c <chVTDoResetI+0x5c>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800501a:	4b02      	ldr	r3, [pc, #8]	; (8005024 <chVTDoResetI+0x74>)
 800501c:	60dc      	str	r4, [r3, #12]
 800501e:	e7da      	b.n	8004fd6 <chVTDoResetI+0x26>
 8005020:	20000ed4 	.word	0x20000ed4
 8005024:	40000400 	.word	0x40000400
 8005028:	46c0      	nop			; (mov r8, r8)
 800502a:	46c0      	nop			; (mov r8, r8)
 800502c:	46c0      	nop			; (mov r8, r8)
 800502e:	46c0      	nop			; (mov r8, r8)

08005030 <chVTDoSetI>:
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8005030:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005032:	4b1e      	ldr	r3, [pc, #120]	; (80050ac <chVTDoSetI+0x7c>)
  vtp->func = vtfunc;
 8005034:	60c2      	str	r2, [r0, #12]
 8005036:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8005038:	b570      	push	{r4, r5, r6, lr}
 800503a:	b292      	uxth	r2, r2
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800503c:	2901      	cmp	r1, #1
 800503e:	d924      	bls.n	800508a <chVTDoSetI+0x5a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8005040:	4d1b      	ldr	r5, [pc, #108]	; (80050b0 <chVTDoSetI+0x80>)
 8005042:	1c2c      	adds	r4, r5, #0
 8005044:	69eb      	ldr	r3, [r5, #28]
 8005046:	341c      	adds	r4, #28
 8005048:	42a3      	cmp	r3, r4
 800504a:	d020      	beq.n	800508e <chVTDoSetI+0x5e>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 800504c:	1889      	adds	r1, r1, r2
 800504e:	8cea      	ldrh	r2, [r5, #38]	; 0x26
 8005050:	b289      	uxth	r1, r1
 8005052:	1a8a      	subs	r2, r1, r2
    if (delta < ch.vtlist.next->delta) {
 8005054:	891c      	ldrh	r4, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 8005056:	b292      	uxth	r2, r2
    if (delta < ch.vtlist.next->delta) {
 8005058:	42a2      	cmp	r2, r4
 800505a:	d204      	bcs.n	8005066 <chVTDoSetI+0x36>
 800505c:	e012      	b.n	8005084 <chVTDoSetI+0x54>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
    p = p->next;
 800505e:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
 8005060:	1b12      	subs	r2, r2, r4
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8005062:	891c      	ldrh	r4, [r3, #8]
    delta -= p->delta;
 8005064:	b292      	uxth	r2, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8005066:	4294      	cmp	r4, r2
 8005068:	d3f9      	bcc.n	800505e <chVTDoSetI+0x2e>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800506a:	6859      	ldr	r1, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800506c:	6003      	str	r3, [r0, #0]
  vtp->prev = vtp->next->prev;
 800506e:	6041      	str	r1, [r0, #4]
  vtp->prev->next = vtp;
 8005070:	6008      	str	r0, [r1, #0]
  p->prev = vtp;
 8005072:	6058      	str	r0, [r3, #4]
  vtp->delta = delta
 8005074:	8102      	strh	r2, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8005076:	8919      	ldrh	r1, [r3, #8]
 8005078:	1a8a      	subs	r2, r1, r2
 800507a:	811a      	strh	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800507c:	2301      	movs	r3, #1
 800507e:	425b      	negs	r3, r3
 8005080:	84ab      	strh	r3, [r5, #36]	; 0x24
}
 8005082:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8005084:	4e09      	ldr	r6, [pc, #36]	; (80050ac <chVTDoSetI+0x7c>)
 8005086:	6371      	str	r1, [r6, #52]	; 0x34
 8005088:	e7ed      	b.n	8005066 <chVTDoSetI+0x36>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800508a:	2102      	movs	r1, #2
 800508c:	e7d8      	b.n	8005040 <chVTDoSetI+0x10>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800508e:	84ea      	strh	r2, [r5, #38]	; 0x26
      ch.vtlist.next = vtp;
 8005090:	61e8      	str	r0, [r5, #28]
      ch.vtlist.prev = vtp;
 8005092:	6228      	str	r0, [r5, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8005094:	188a      	adds	r2, r1, r2
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8005096:	6003      	str	r3, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8005098:	6043      	str	r3, [r0, #4]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800509a:	4b04      	ldr	r3, [pc, #16]	; (80050ac <chVTDoSetI+0x7c>)
 800509c:	b292      	uxth	r2, r2
      vtp->delta = delay;
 800509e:	8101      	strh	r1, [r0, #8]
 80050a0:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80050a2:	2200      	movs	r2, #0
 80050a4:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80050a6:	2202      	movs	r2, #2
 80050a8:	60da      	str	r2, [r3, #12]
 80050aa:	e7ea      	b.n	8005082 <chVTDoSetI+0x52>
 80050ac:	40000400 	.word	0x40000400
 80050b0:	20000ed4 	.word	0x20000ed4
 80050b4:	46c0      	nop			; (mov r8, r8)
 80050b6:	46c0      	nop			; (mov r8, r8)
 80050b8:	46c0      	nop			; (mov r8, r8)
 80050ba:	46c0      	nop			; (mov r8, r8)
 80050bc:	46c0      	nop			; (mov r8, r8)
 80050be:	46c0      	nop			; (mov r8, r8)

080050c0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80050c0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80050c2:	4b0e      	ldr	r3, [pc, #56]	; (80050fc <chSchGoSleepTimeoutS+0x3c>)
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80050c4:	b087      	sub	sp, #28
 80050c6:	1c05      	adds	r5, r0, #0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80050c8:	4299      	cmp	r1, r3
 80050ca:	d012      	beq.n	80050f2 <chSchGoSleepTimeoutS+0x32>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80050cc:	4c0c      	ldr	r4, [pc, #48]	; (8005100 <chSchGoSleepTimeoutS+0x40>)
 80050ce:	a801      	add	r0, sp, #4
 80050d0:	69a3      	ldr	r3, [r4, #24]
 80050d2:	4a0c      	ldr	r2, [pc, #48]	; (8005104 <chSchGoSleepTimeoutS+0x44>)
 80050d4:	f7ff ffac 	bl	8005030 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80050d8:	1c28      	adds	r0, r5, #0
 80050da:	f7fb fe09 	bl	8000cf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80050de:	9b04      	ldr	r3, [sp, #16]
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	d002      	beq.n	80050ea <chSchGoSleepTimeoutS+0x2a>
      chVTDoResetI(&vt);
 80050e4:	a801      	add	r0, sp, #4
 80050e6:	f7ff ff63 	bl	8004fb0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 80050ea:	69a3      	ldr	r3, [r4, #24]
 80050ec:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 80050ee:	b007      	add	sp, #28
 80050f0:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80050f2:	f7fb fdfd 	bl	8000cf0 <chSchGoSleepS>
 80050f6:	4c02      	ldr	r4, [pc, #8]	; (8005100 <chSchGoSleepTimeoutS+0x40>)
 80050f8:	e7f7      	b.n	80050ea <chSchGoSleepTimeoutS+0x2a>
 80050fa:	46c0      	nop			; (mov r8, r8)
 80050fc:	0000ffff 	.word	0x0000ffff
 8005100:	20000ed4 	.word	0x20000ed4
 8005104:	080003f1 	.word	0x080003f1
 8005108:	46c0      	nop			; (mov r8, r8)
 800510a:	46c0      	nop			; (mov r8, r8)
 800510c:	46c0      	nop			; (mov r8, r8)
 800510e:	46c0      	nop			; (mov r8, r8)

08005110 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8005110:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8005112:	2900      	cmp	r1, #0
 8005114:	d00a      	beq.n	800512c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8005116:	4b07      	ldr	r3, [pc, #28]	; (8005134 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8005118:	6842      	ldr	r2, [r0, #4]
 800511a:	699b      	ldr	r3, [r3, #24]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 800511c:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800511e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8005120:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8005122:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005124:	2004      	movs	r0, #4
 8005126:	f7ff ffcb 	bl	80050c0 <chSchGoSleepTimeoutS>
}
 800512a:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 800512c:	2001      	movs	r0, #1
 800512e:	4240      	negs	r0, r0
 8005130:	e7fb      	b.n	800512a <chThdEnqueueTimeoutS+0x1a>
 8005132:	46c0      	nop			; (mov r8, r8)
 8005134:	20000ed4 	.word	0x20000ed4
 8005138:	46c0      	nop			; (mov r8, r8)
 800513a:	46c0      	nop			; (mov r8, r8)
 800513c:	46c0      	nop			; (mov r8, r8)
 800513e:	46c0      	nop			; (mov r8, r8)

08005140 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8005140:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005142:	4656      	mov	r6, sl
 8005144:	464d      	mov	r5, r9
 8005146:	4644      	mov	r4, r8
 8005148:	465f      	mov	r7, fp
 800514a:	b4f0      	push	{r4, r5, r6, r7}
 800514c:	1c15      	adds	r5, r2, #0
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800514e:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8005150:	b083      	sub	sp, #12
 8005152:	1c04      	adds	r4, r0, #0
 8005154:	1c0e      	adds	r6, r1, #0
 8005156:	469a      	mov	sl, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8005158:	4691      	mov	r9, r2
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800515a:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800515c:	4b24      	ldr	r3, [pc, #144]	; (80051f0 <oqWriteTimeout+0xb0>)
  size_t w = 0;
 800515e:	2700      	movs	r7, #0
 8005160:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8005162:	4453      	add	r3, sl
 8005164:	b29b      	uxth	r3, r3
 8005166:	9301      	str	r3, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8005168:	4653      	mov	r3, sl
 800516a:	3b01      	subs	r3, #1
 800516c:	b29b      	uxth	r3, r3
 800516e:	469b      	mov	fp, r3
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8005170:	68a3      	ldr	r3, [r4, #8]
 8005172:	2b00      	cmp	r3, #0
 8005174:	d01e      	beq.n	80051b4 <oqWriteTimeout+0x74>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8005176:	68a3      	ldr	r3, [r4, #8]
 8005178:	3b01      	subs	r3, #1
 800517a:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800517c:	6963      	ldr	r3, [r4, #20]
 800517e:	1c5a      	adds	r2, r3, #1
 8005180:	6162      	str	r2, [r4, #20]
 8005182:	1c72      	adds	r2, r6, #1
 8005184:	4690      	mov	r8, r2
 8005186:	7832      	ldrb	r2, [r6, #0]
 8005188:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800518a:	6963      	ldr	r3, [r4, #20]
 800518c:	6922      	ldr	r2, [r4, #16]
 800518e:	4293      	cmp	r3, r2
 8005190:	d301      	bcc.n	8005196 <oqWriteTimeout+0x56>
      oqp->q_wrptr = oqp->q_buffer;
 8005192:	68e3      	ldr	r3, [r4, #12]
 8005194:	6163      	str	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8005196:	464a      	mov	r2, r9
 8005198:	2a00      	cmp	r2, #0
 800519a:	d001      	beq.n	80051a0 <oqWriteTimeout+0x60>
      nfy(oqp);
 800519c:	1c20      	adds	r0, r4, #0
 800519e:	47c8      	blx	r9
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80051a0:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 80051a2:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 80051a4:	3701      	adds	r7, #1
    if (--n == 0U) {
 80051a6:	2d00      	cmp	r5, #0
 80051a8:	d014      	beq.n	80051d4 <oqWriteTimeout+0x94>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80051aa:	b672      	cpsid	i
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 80051ac:	68a3      	ldr	r3, [r4, #8]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80051ae:	4646      	mov	r6, r8
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 80051b0:	2b00      	cmp	r3, #0
 80051b2:	d1e0      	bne.n	8005176 <oqWriteTimeout+0x36>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80051b4:	4b0f      	ldr	r3, [pc, #60]	; (80051f4 <oqWriteTimeout+0xb4>)
 80051b6:	459b      	cmp	fp, r3
 80051b8:	d814      	bhi.n	80051e4 <oqWriteTimeout+0xa4>
 80051ba:	4b0d      	ldr	r3, [pc, #52]	; (80051f0 <oqWriteTimeout+0xb0>)
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80051bc:	9a01      	ldr	r2, [sp, #4]
 80051be:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80051c0:	1a51      	subs	r1, r2, r1
 80051c2:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80051c4:	458a      	cmp	sl, r1
 80051c6:	d304      	bcc.n	80051d2 <oqWriteTimeout+0x92>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 80051c8:	1c20      	adds	r0, r4, #0
 80051ca:	f7ff ffa1 	bl	8005110 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80051ce:	2800      	cmp	r0, #0
 80051d0:	d0ce      	beq.n	8005170 <oqWriteTimeout+0x30>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80051d2:	b662      	cpsie	i
      return w;
    }

    osalSysLock();
  }
}
 80051d4:	1c38      	adds	r0, r7, #0
 80051d6:	b003      	add	sp, #12
 80051d8:	bc3c      	pop	{r2, r3, r4, r5}
 80051da:	4690      	mov	r8, r2
 80051dc:	4699      	mov	r9, r3
 80051de:	46a2      	mov	sl, r4
 80051e0:	46ab      	mov	fp, r5
 80051e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80051e4:	1c20      	adds	r0, r4, #0
 80051e6:	4651      	mov	r1, sl
 80051e8:	f7ff ff92 	bl	8005110 <chThdEnqueueTimeoutS>
 80051ec:	e7ef      	b.n	80051ce <oqWriteTimeout+0x8e>
 80051ee:	46c0      	nop			; (mov r8, r8)
 80051f0:	40000400 	.word	0x40000400
 80051f4:	0000fffd 	.word	0x0000fffd
 80051f8:	46c0      	nop			; (mov r8, r8)
 80051fa:	46c0      	nop			; (mov r8, r8)
 80051fc:	46c0      	nop			; (mov r8, r8)
 80051fe:	46c0      	nop			; (mov r8, r8)

08005200 <chThdCreateStatic.constprop.52>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8005200:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005202:	b672      	cpsid	i
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8005204:	1c44      	adds	r4, r0, #1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005206:	1c05      	adds	r5, r0, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8005208:	34ff      	adds	r4, #255	; 0xff
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800520a:	35dc      	adds	r5, #220	; 0xdc
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 800520c:	61e0      	str	r0, [r4, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800520e:	60e5      	str	r5, [r4, #12]
 8005210:	612a      	str	r2, [r5, #16]
 8005212:	616b      	str	r3, [r5, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005214:	2290      	movs	r2, #144	; 0x90
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005216:	4b18      	ldr	r3, [pc, #96]	; (8005278 <chThdCreateStatic.constprop.52+0x78>)
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005218:	0052      	lsls	r2, r2, #1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800521a:	622b      	str	r3, [r5, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800521c:	1883      	adds	r3, r0, r2
 800521e:	2202      	movs	r2, #2
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8005220:	60a1      	str	r1, [r4, #8]
  tp->state     = CH_STATE_WTSTART;
 8005222:	701a      	strb	r2, [r3, #0]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005224:	2322      	movs	r3, #34	; 0x22
 8005226:	33ff      	adds	r3, #255	; 0xff
 8005228:	18c2      	adds	r2, r0, r3
 800522a:	2300      	movs	r3, #0
 800522c:	7013      	strb	r3, [r2, #0]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800522e:	2291      	movs	r2, #145	; 0x91
 8005230:	0052      	lsls	r2, r2, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005232:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8005234:	6363      	str	r3, [r4, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005236:	1883      	adds	r3, r0, r2
 8005238:	2201      	movs	r2, #1
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800523a:	63e1      	str	r1, [r4, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800523c:	701a      	strb	r2, [r3, #0]
  tp->name      = name;
 800523e:	4b0f      	ldr	r3, [pc, #60]	; (800527c <chThdCreateStatic.constprop.52+0x7c>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005240:	2100      	movs	r1, #0
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8005242:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
 8005244:	4b0e      	ldr	r3, [pc, #56]	; (8005280 <chThdCreateStatic.constprop.52+0x80>)
 8005246:	695a      	ldr	r2, [r3, #20]
 8005248:	6123      	str	r3, [r4, #16]
 800524a:	6162      	str	r2, [r4, #20]
 800524c:	6114      	str	r4, [r2, #16]
 800524e:	615c      	str	r4, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8005250:	2394      	movs	r3, #148	; 0x94
 8005252:	005b      	lsls	r3, r3, #1
 8005254:	18c2      	adds	r2, r0, r3
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005256:	2394      	movs	r3, #148	; 0x94
 8005258:	005b      	lsls	r3, r3, #1
 800525a:	50c2      	str	r2, [r0, r3]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 800525c:	2296      	movs	r2, #150	; 0x96
 800525e:	0052      	lsls	r2, r2, #1
 8005260:	1883      	adds	r3, r0, r2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005262:	2296      	movs	r2, #150	; 0x96
 8005264:	0052      	lsls	r2, r2, #1
 8005266:	5083      	str	r3, [r0, r2]
  tqp->prev = (thread_t *)tqp;
 8005268:	605b      	str	r3, [r3, #4]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800526a:	1c20      	adds	r0, r4, #0
 800526c:	f7fb fcc8 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005270:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8005272:	1c20      	adds	r0, r4, #0
 8005274:	bd38      	pop	{r3, r4, r5, pc}
 8005276:	46c0      	nop			; (mov r8, r8)
 8005278:	080001f1 	.word	0x080001f1
 800527c:	0800623c 	.word	0x0800623c
 8005280:	20000ed4 	.word	0x20000ed4
 8005284:	46c0      	nop			; (mov r8, r8)
 8005286:	46c0      	nop			; (mov r8, r8)
 8005288:	46c0      	nop			; (mov r8, r8)
 800528a:	46c0      	nop			; (mov r8, r8)
 800528c:	46c0      	nop			; (mov r8, r8)
 800528e:	46c0      	nop			; (mov r8, r8)

08005290 <test_004_005_execute.9182>:

static void test_004_005_teardown(void) {
  test_wait_threads();
}

static void test_004_005_execute(void) {
 8005290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 8005292:	4d1f      	ldr	r5, [pc, #124]	; (8005310 <test_004_005_execute.9182+0x80>)
 8005294:	2301      	movs	r3, #1
 8005296:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8005298:	4b1e      	ldr	r3, [pc, #120]	; (8005314 <test_004_005_execute.9182+0x84>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800529a:	4a1f      	ldr	r2, [pc, #124]	; (8005318 <test_004_005_execute.9182+0x88>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800529c:	699b      	ldr	r3, [r3, #24]
 800529e:	481f      	ldr	r0, [pc, #124]	; (800531c <test_004_005_execute.9182+0x8c>)
 80052a0:	6899      	ldr	r1, [r3, #8]
 80052a2:	2300      	movs	r3, #0
 80052a4:	3101      	adds	r1, #1
 80052a6:	f7ff ffab 	bl	8005200 <chThdCreateStatic.constprop.52>
 80052aa:	4b1d      	ldr	r3, [pc, #116]	; (8005320 <test_004_005_execute.9182+0x90>)
 80052ac:	6018      	str	r0, [r3, #0]
  }

  /* [4.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80052ae:	2302      	movs	r3, #2
 80052b0:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80052b2:	f7ff fd2d 	bl	8004d10 <chSemSignalWait.constprop.46.4281>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80052b6:	4c1b      	ldr	r4, [pc, #108]	; (8005324 <test_004_005_execute.9182+0x94>)
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80052b8:	4e1b      	ldr	r6, [pc, #108]	; (8005328 <test_004_005_execute.9182+0x98>)
 80052ba:	6822      	ldr	r2, [r4, #0]
 80052bc:	1c31      	adds	r1, r6, #0
 80052be:	1b10      	subs	r0, r2, r4
 80052c0:	4243      	negs	r3, r0
 80052c2:	4158      	adcs	r0, r3
 80052c4:	b2c0      	uxtb	r0, r0
 80052c6:	f7fb faf3 	bl	80008b0 <_test_assert>
 80052ca:	2800      	cmp	r0, #0
 80052cc:	d000      	beq.n	80052d0 <test_004_005_execute.9182+0x40>
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }
}
 80052ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     value must be one on exit.*/
  test_set_step(2);
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
 80052d0:	68a2      	ldr	r2, [r4, #8]
 80052d2:	4f16      	ldr	r7, [pc, #88]	; (800532c <test_004_005_execute.9182+0x9c>)
 80052d4:	4250      	negs	r0, r2
 80052d6:	4150      	adcs	r0, r2
 80052d8:	b2c0      	uxtb	r0, r0
 80052da:	1c39      	adds	r1, r7, #0
 80052dc:	f7fb fae8 	bl	80008b0 <_test_assert>
 80052e0:	2800      	cmp	r0, #0
 80052e2:	d1f4      	bne.n	80052ce <test_004_005_execute.9182+0x3e>
  }

  /* [4.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 80052e4:	2303      	movs	r3, #3
 80052e6:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80052e8:	f7ff fd12 	bl	8004d10 <chSemSignalWait.constprop.46.4281>
 80052ec:	6823      	ldr	r3, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80052ee:	1c31      	adds	r1, r6, #0
 80052f0:	1b18      	subs	r0, r3, r4
 80052f2:	4243      	negs	r3, r0
 80052f4:	4158      	adcs	r0, r3
 80052f6:	b2c0      	uxtb	r0, r0
 80052f8:	f7fb fada 	bl	80008b0 <_test_assert>
 80052fc:	2800      	cmp	r0, #0
 80052fe:	d1e6      	bne.n	80052ce <test_004_005_execute.9182+0x3e>
    test_assert(sem1.cnt == 0, "counter not zero");
 8005300:	68a0      	ldr	r0, [r4, #8]
 8005302:	1c39      	adds	r1, r7, #0
 8005304:	4243      	negs	r3, r0
 8005306:	4158      	adcs	r0, r3
 8005308:	b2c0      	uxtb	r0, r0
 800530a:	f7fb fad1 	bl	80008b0 <_test_assert>
 800530e:	e7de      	b.n	80052ce <test_004_005_execute.9182+0x3e>
 8005310:	20000f44 	.word	0x20000f44
 8005314:	20000ed4 	.word	0x20000ed4
 8005318:	08000e11 	.word	0x08000e11
 800531c:	20000518 	.word	0x20000518
 8005320:	20000b84 	.word	0x20000b84
 8005324:	20000508 	.word	0x20000508
 8005328:	08005fc0 	.word	0x08005fc0
 800532c:	08005fd0 	.word	0x08005fd0

08005330 <chCondSignal.constprop.43>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8005330:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005332:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005334:	4b05      	ldr	r3, [pc, #20]	; (800534c <chCondSignal.constprop.43+0x1c>)
 8005336:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->queue)) {
 8005338:	4298      	cmp	r0, r3
 800533a:	d005      	beq.n	8005348 <chCondSignal.constprop.43+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800533c:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 800533e:	2100      	movs	r1, #0
 8005340:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005342:	6053      	str	r3, [r2, #4]
 8005344:	f7fb fc5c 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005348:	b662      	cpsie	i
  }
  chSysUnlock();
}
 800534a:	bd08      	pop	{r3, pc}
 800534c:	20000410 	.word	0x20000410

08005350 <chCondSignalI.constprop.42>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8005350:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005352:	4b06      	ldr	r3, [pc, #24]	; (800536c <chCondSignalI.constprop.42+0x1c>)
 8005354:	6818      	ldr	r0, [r3, #0]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8005356:	4298      	cmp	r0, r3
 8005358:	d006      	beq.n	8005368 <chCondSignalI.constprop.42+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800535a:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800535c:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800535e:	601a      	str	r2, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 8005360:	2300      	movs	r3, #0
 8005362:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8005364:	f7fb fd64 	bl	8000e30 <chSchReadyI>
  }
}
 8005368:	bd08      	pop	{r3, pc}
 800536a:	46c0      	nop			; (mov r8, r8)
 800536c:	20000410 	.word	0x20000410

08005370 <chEvtGetAndClearEvents.constprop.36>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005370:	b672      	cpsid	i
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8005372:	4b03      	ldr	r3, [pc, #12]	; (8005380 <chEvtGetAndClearEvents.constprop.36+0x10>)
  currp->epending &= ~events;
 8005374:	2200      	movs	r2, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8005376:	699b      	ldr	r3, [r3, #24]
 8005378:	6b58      	ldr	r0, [r3, #52]	; 0x34
  currp->epending &= ~events;
 800537a:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800537c:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 800537e:	4770      	bx	lr
 8005380:	20000ed4 	.word	0x20000ed4
 8005384:	46c0      	nop			; (mov r8, r8)
 8005386:	46c0      	nop			; (mov r8, r8)
 8005388:	46c0      	nop			; (mov r8, r8)
 800538a:	46c0      	nop			; (mov r8, r8)
 800538c:	46c0      	nop			; (mov r8, r8)
 800538e:	46c0      	nop			; (mov r8, r8)

08005390 <test_007_002_setup.9770>:
 * - [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void test_007_002_setup(void) {
 8005390:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8005392:	f7ff ffed 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
}
 8005396:	bd08      	pop	{r3, pc}
 8005398:	46c0      	nop			; (mov r8, r8)
 800539a:	46c0      	nop			; (mov r8, r8)
 800539c:	46c0      	nop			; (mov r8, r8)
 800539e:	46c0      	nop			; (mov r8, r8)

080053a0 <test_007_003_setup.9768>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void test_007_003_setup(void) {
 80053a0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80053a2:	f7ff ffe5 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
}
 80053a6:	bd08      	pop	{r3, pc}
 80053a8:	46c0      	nop			; (mov r8, r8)
 80053aa:	46c0      	nop			; (mov r8, r8)
 80053ac:	46c0      	nop			; (mov r8, r8)
 80053ae:	46c0      	nop			; (mov r8, r8)

080053b0 <test_007_004_setup.9766>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void test_007_004_setup(void) {
 80053b0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80053b2:	f7ff ffdd 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
}
 80053b6:	bd08      	pop	{r3, pc}
 80053b8:	46c0      	nop			; (mov r8, r8)
 80053ba:	46c0      	nop			; (mov r8, r8)
 80053bc:	46c0      	nop			; (mov r8, r8)
 80053be:	46c0      	nop			; (mov r8, r8)

080053c0 <test_007_005_setup.9764>:
 *   flags have been received after 50mS and that the event flags mask
 *   has been emptied.
 * .
 */

static void test_007_005_setup(void) {
 80053c0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80053c2:	f7ff ffd5 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
}
 80053c6:	bd08      	pop	{r3, pc}
 80053c8:	46c0      	nop			; (mov r8, r8)
 80053ca:	46c0      	nop			; (mov r8, r8)
 80053cc:	46c0      	nop			; (mov r8, r8)
 80053ce:	46c0      	nop			; (mov r8, r8)

080053d0 <test_007_006_setup.9762>:
 * - [7.6.2] The functions are invoked first with a 50mS timeout, the
 *   timeout condition is tested.
 * .
 */

static void test_007_006_setup(void) {
 80053d0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80053d2:	f7ff ffcd 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
}
 80053d6:	bd08      	pop	{r3, pc}
 80053d8:	46c0      	nop			; (mov r8, r8)
 80053da:	46c0      	nop			; (mov r8, r8)
 80053dc:	46c0      	nop			; (mov r8, r8)
 80053de:	46c0      	nop			; (mov r8, r8)

080053e0 <test_007_007_setup.9760>:
 *   has been emptied.
 * - [7.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_007_007_setup(void) {
 80053e0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80053e2:	f7ff ffc5 	bl	8005370 <chEvtGetAndClearEvents.constprop.36>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80053e6:	4b02      	ldr	r3, [pc, #8]	; (80053f0 <test_007_007_setup.9760+0x10>)
 80053e8:	601b      	str	r3, [r3, #0]
 80053ea:	4b02      	ldr	r3, [pc, #8]	; (80053f4 <test_007_007_setup.9760+0x14>)
 80053ec:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
 80053ee:	bd08      	pop	{r3, pc}
 80053f0:	20000454 	.word	0x20000454
 80053f4:	20000428 	.word	0x20000428
 80053f8:	46c0      	nop			; (mov r8, r8)
 80053fa:	46c0      	nop			; (mov r8, r8)
 80053fc:	46c0      	nop			; (mov r8, r8)
 80053fe:	46c0      	nop			; (mov r8, r8)

08005400 <chEvtWaitOne.constprop.32>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 8005400:	4b09      	ldr	r3, [pc, #36]	; (8005428 <chEvtWaitOne.constprop.32+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8005402:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8005404:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005406:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8005408:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800540a:	2b00      	cmp	r3, #0
 800540c:	d106      	bne.n	800541c <chEvtWaitOne.constprop.32+0x1c>
    ctp->u.ewmask = events;
 800540e:	2301      	movs	r3, #1
 8005410:	425b      	negs	r3, r3
 8005412:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005414:	200a      	movs	r0, #10
 8005416:	f7fb fc6b 	bl	8000cf0 <chSchGoSleepS>
    m = ctp->epending & events;
 800541a:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 800541c:	4258      	negs	r0, r3
 800541e:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8005420:	4383      	bics	r3, r0
 8005422:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005424:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8005426:	bd10      	pop	{r4, pc}
 8005428:	20000ed4 	.word	0x20000ed4
 800542c:	46c0      	nop			; (mov r8, r8)
 800542e:	46c0      	nop			; (mov r8, r8)

08005430 <chEvtWaitAny.constprop.31>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8005430:	4b08      	ldr	r3, [pc, #32]	; (8005454 <chEvtWaitAny.constprop.31+0x24>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8005432:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8005434:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005436:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8005438:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800543a:	2800      	cmp	r0, #0
 800543c:	d106      	bne.n	800544c <chEvtWaitAny.constprop.31+0x1c>
    ctp->u.ewmask = events;
 800543e:	2301      	movs	r3, #1
 8005440:	425b      	negs	r3, r3
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005442:	200a      	movs	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
    ctp->u.ewmask = events;
 8005444:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005446:	f7fb fc53 	bl	8000cf0 <chSchGoSleepS>
    m = ctp->epending & events;
 800544a:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 800544c:	2300      	movs	r3, #0
 800544e:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005450:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8005452:	bd10      	pop	{r4, pc}
 8005454:	20000ed4 	.word	0x20000ed4
 8005458:	46c0      	nop			; (mov r8, r8)
 800545a:	46c0      	nop			; (mov r8, r8)
 800545c:	46c0      	nop			; (mov r8, r8)
 800545e:	46c0      	nop			; (mov r8, r8)

08005460 <chEvtWaitAll.constprop.30>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8005460:	4b0a      	ldr	r3, [pc, #40]	; (800548c <chEvtWaitAll.constprop.30+0x2c>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8005462:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8005464:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005466:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 8005468:	2205      	movs	r2, #5
 800546a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800546c:	1c11      	adds	r1, r2, #0
 800546e:	4019      	ands	r1, r3
 8005470:	2905      	cmp	r1, #5
 8005472:	d004      	beq.n	800547e <chEvtWaitAll.constprop.30+0x1e>
    ctp->u.ewmask = events;
 8005474:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8005476:	200b      	movs	r0, #11
 8005478:	f7fb fc3a 	bl	8000cf0 <chSchGoSleepS>
 800547c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 800547e:	2205      	movs	r2, #5
 8005480:	4393      	bics	r3, r2
 8005482:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005484:	b662      	cpsie	i
  chSysUnlock();

  return events;
}
 8005486:	2005      	movs	r0, #5
 8005488:	bd10      	pop	{r4, pc}
 800548a:	46c0      	nop			; (mov r8, r8)
 800548c:	20000ed4 	.word	0x20000ed4

08005490 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8005490:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8005492:	4ba6      	ldr	r3, [pc, #664]	; (800572c <main+0x29c>)
 8005494:	2101      	movs	r1, #1
 8005496:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005498:	4249      	negs	r1, r1
 800549a:	2200      	movs	r2, #0
 800549c:	4644      	mov	r4, r8
 800549e:	465f      	mov	r7, fp
 80054a0:	4656      	mov	r6, sl
 80054a2:	464d      	mov	r5, r9
 80054a4:	b4f0      	push	{r4, r5, r6, r7}
 80054a6:	6299      	str	r1, [r3, #40]	; 0x28
 80054a8:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80054aa:	6918      	ldr	r0, [r3, #16]
 80054ac:	6119      	str	r1, [r3, #16]
 80054ae:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80054b0:	68d9      	ldr	r1, [r3, #12]
 80054b2:	489f      	ldr	r0, [pc, #636]	; (8005730 <main+0x2a0>)
 80054b4:	b083      	sub	sp, #12
 80054b6:	4301      	orrs	r1, r0
 80054b8:	60d9      	str	r1, [r3, #12]
 80054ba:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80054bc:	69d8      	ldr	r0, [r3, #28]
 80054be:	2180      	movs	r1, #128	; 0x80
 80054c0:	0549      	lsls	r1, r1, #21
 80054c2:	4301      	orrs	r1, r0
 80054c4:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80054c6:	499b      	ldr	r1, [pc, #620]	; (8005734 <main+0x2a4>)
 80054c8:	2080      	movs	r0, #128	; 0x80
 80054ca:	680c      	ldr	r4, [r1, #0]
 80054cc:	0040      	lsls	r0, r0, #1
 80054ce:	4320      	orrs	r0, r4
 80054d0:	6008      	str	r0, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80054d2:	6a18      	ldr	r0, [r3, #32]
 80054d4:	21c0      	movs	r1, #192	; 0xc0
 80054d6:	0089      	lsls	r1, r1, #2
 80054d8:	4008      	ands	r0, r1
 80054da:	2180      	movs	r1, #128	; 0x80
 80054dc:	0089      	lsls	r1, r1, #2
 80054de:	4288      	cmp	r0, r1
 80054e0:	d003      	beq.n	80054ea <main+0x5a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80054e2:	2180      	movs	r1, #128	; 0x80
 80054e4:	0249      	lsls	r1, r1, #9
 80054e6:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 80054e8:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80054ea:	4b90      	ldr	r3, [pc, #576]	; (800572c <main+0x29c>)
 80054ec:	2280      	movs	r2, #128	; 0x80
 80054ee:	6a19      	ldr	r1, [r3, #32]
 80054f0:	0212      	lsls	r2, r2, #8
 80054f2:	4211      	tst	r1, r2
 80054f4:	d107      	bne.n	8005506 <main+0x76>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80054f6:	6a18      	ldr	r0, [r3, #32]
 80054f8:	2180      	movs	r1, #128	; 0x80
 80054fa:	0089      	lsls	r1, r1, #2
 80054fc:	4301      	orrs	r1, r0
 80054fe:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8005500:	6a19      	ldr	r1, [r3, #32]
 8005502:	430a      	orrs	r2, r1
 8005504:	621a      	str	r2, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8005506:	4c89      	ldr	r4, [pc, #548]	; (800572c <main+0x29c>)
 8005508:	23bc      	movs	r3, #188	; 0xbc
 800550a:	6962      	ldr	r2, [r4, #20]
 800550c:	03db      	lsls	r3, r3, #15
 800550e:	4313      	orrs	r3, r2
 8005510:	6163      	str	r3, [r4, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005512:	4989      	ldr	r1, [pc, #548]	; (8005738 <main+0x2a8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005514:	2390      	movs	r3, #144	; 0x90
 8005516:	2200      	movs	r2, #0
 8005518:	05db      	lsls	r3, r3, #23
 800551a:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800551c:	6099      	str	r1, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800551e:	4987      	ldr	r1, [pc, #540]	; (800573c <main+0x2ac>)
  gpiop->ODR     = config->odr;
 8005520:	4f87      	ldr	r7, [pc, #540]	; (8005740 <main+0x2b0>)

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005522:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8005524:	4987      	ldr	r1, [pc, #540]	; (8005744 <main+0x2b4>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005526:	2601      	movs	r6, #1
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005528:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800552a:	2188      	movs	r1, #136	; 0x88
 800552c:	0149      	lsls	r1, r1, #5
 800552e:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8005530:	4985      	ldr	r1, [pc, #532]	; (8005748 <main+0x2b8>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8005532:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005534:	6019      	str	r1, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005536:	4b85      	ldr	r3, [pc, #532]	; (800574c <main+0x2bc>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005538:	4985      	ldr	r1, [pc, #532]	; (8005750 <main+0x2c0>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800553a:	4276      	negs	r6, r6
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800553c:	2080      	movs	r0, #128	; 0x80
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800553e:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8005540:	4683      	mov	fp, r0
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005542:	609e      	str	r6, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005544:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8005546:	615f      	str	r7, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005548:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800554a:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800554c:	6018      	str	r0, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800554e:	4b81      	ldr	r3, [pc, #516]	; (8005754 <main+0x2c4>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005550:	4881      	ldr	r0, [pc, #516]	; (8005758 <main+0x2c8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005552:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005554:	609e      	str	r6, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005556:	60d8      	str	r0, [r3, #12]
  gpiop->ODR     = config->odr;
 8005558:	615f      	str	r7, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800555a:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800555c:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800555e:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005560:	4b7e      	ldr	r3, [pc, #504]	; (800575c <main+0x2cc>)
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8005562:	2001      	movs	r0, #1
 8005564:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005566:	609e      	str	r6, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005568:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 800556a:	615f      	str	r7, [r3, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800556c:	497c      	ldr	r1, [pc, #496]	; (8005760 <main+0x2d0>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800556e:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005570:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005572:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005574:	4b7b      	ldr	r3, [pc, #492]	; (8005764 <main+0x2d4>)
 8005576:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005578:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 800557a:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 800557c:	615f      	str	r7, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800557e:	621a      	str	r2, [r3, #32]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8005580:	4979      	ldr	r1, [pc, #484]	; (8005768 <main+0x2d8>)
  gpiop->AFRH    = config->afrh;
 8005582:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005584:	601a      	str	r2, [r3, #0]
 8005586:	4b79      	ldr	r3, [pc, #484]	; (800576c <main+0x2dc>)
 8005588:	4d78      	ldr	r5, [pc, #480]	; (800576c <main+0x2dc>)
 800558a:	c302      	stmia	r3!, {r1}
 800558c:	606b      	str	r3, [r5, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800558e:	1c2b      	adds	r3, r5, #0
 8005590:	330c      	adds	r3, #12
 8005592:	60eb      	str	r3, [r5, #12]
  tqp->prev = (thread_t *)tqp;
 8005594:	612b      	str	r3, [r5, #16]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8005596:	1c2b      	adds	r3, r5, #0
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8005598:	4974      	ldr	r1, [pc, #464]	; (800576c <main+0x2dc>)
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800559a:	3354      	adds	r3, #84	; 0x54
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800559c:	616a      	str	r2, [r5, #20]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800559e:	7228      	strb	r0, [r5, #8]
  iqp->q_buffer  = bp;
 80055a0:	61ab      	str	r3, [r5, #24]
  iqp->q_rdptr   = bp;
 80055a2:	626b      	str	r3, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80055a4:	622b      	str	r3, [r5, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80055a6:	4b71      	ldr	r3, [pc, #452]	; (800576c <main+0x2dc>)
  iqp->q_top     = bp + size;
 80055a8:	3564      	adds	r5, #100	; 0x64
 80055aa:	61cd      	str	r5, [r1, #28]
  iqp->q_notify  = infy;
 80055ac:	628a      	str	r2, [r1, #40]	; 0x28
  iqp->q_link    = link;
 80055ae:	62c9      	str	r1, [r1, #44]	; 0x2c
 80055b0:	3130      	adds	r1, #48	; 0x30
 80055b2:	6319      	str	r1, [r3, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 80055b4:	6359      	str	r1, [r3, #52]	; 0x34
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80055b6:	63dd      	str	r5, [r3, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80055b8:	649d      	str	r5, [r3, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80055ba:	645d      	str	r5, [r3, #68]	; 0x44
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80055bc:	2110      	movs	r1, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80055be:	4d6b      	ldr	r5, [pc, #428]	; (800576c <main+0x2dc>)
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80055c0:	6399      	str	r1, [r3, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80055c2:	3374      	adds	r3, #116	; 0x74
 80055c4:	642b      	str	r3, [r5, #64]	; 0x40
  oqp->q_notify  = onfy;
 80055c6:	4b6a      	ldr	r3, [pc, #424]	; (8005770 <main+0x2e0>)
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80055c8:	21c7      	movs	r1, #199	; 0xc7
 80055ca:	64eb      	str	r3, [r5, #76]	; 0x4c
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 80055cc:	4b69      	ldr	r3, [pc, #420]	; (8005774 <main+0x2e4>)
 80055ce:	0089      	lsls	r1, r1, #2
 80055d0:	676b      	str	r3, [r5, #116]	; 0x74
  SD2.clock = STM32_USART2CLK;
 80055d2:	4b69      	ldr	r3, [pc, #420]	; (8005778 <main+0x2e8>)
  oqp->q_link    = link;
 80055d4:	652d      	str	r5, [r5, #80]	; 0x50
 80055d6:	67ab      	str	r3, [r5, #120]	; 0x78
 80055d8:	4b68      	ldr	r3, [pc, #416]	; (800577c <main+0x2ec>)
 80055da:	468a      	mov	sl, r1
 80055dc:	585d      	ldr	r5, [r3, r1]
 80055de:	21ff      	movs	r1, #255	; 0xff
 80055e0:	438d      	bics	r5, r1
 80055e2:	46a9      	mov	r9, r5
 80055e4:	4688      	mov	r8, r1
 80055e6:	25c0      	movs	r5, #192	; 0xc0
 80055e8:	4649      	mov	r1, r9
 80055ea:	4329      	orrs	r1, r5
 80055ec:	4655      	mov	r5, sl
 80055ee:	5159      	str	r1, [r3, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80055f0:	21c0      	movs	r1, #192	; 0xc0
 80055f2:	0049      	lsls	r1, r1, #1
 80055f4:	468c      	mov	ip, r1
 80055f6:	2180      	movs	r1, #128	; 0x80
 80055f8:	0549      	lsls	r1, r1, #21
 80055fa:	4665      	mov	r5, ip
 80055fc:	5159      	str	r1, [r3, r5]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80055fe:	6019      	str	r1, [r3, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005600:	69e1      	ldr	r1, [r4, #28]
 8005602:	2502      	movs	r5, #2
 8005604:	46a9      	mov	r9, r5
 8005606:	4329      	orrs	r1, r5

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005608:	4d5d      	ldr	r5, [pc, #372]	; (8005780 <main+0x2f0>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800560a:	61e1      	str	r1, [r4, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800560c:	68a9      	ldr	r1, [r5, #8]
 800560e:	464d      	mov	r5, r9
 8005610:	4329      	orrs	r1, r5
 8005612:	4d5b      	ldr	r5, [pc, #364]	; (8005780 <main+0x2f0>)
 8005614:	60a9      	str	r1, [r5, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005616:	495b      	ldr	r1, [pc, #364]	; (8005784 <main+0x2f4>)
 8005618:	4d5b      	ldr	r5, [pc, #364]	; (8005788 <main+0x2f8>)
 800561a:	628d      	str	r5, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800561c:	62cf      	str	r7, [r1, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800561e:	618a      	str	r2, [r1, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8005620:	634a      	str	r2, [r1, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8005622:	60ca      	str	r2, [r1, #12]
  STM32_ST_TIM->CR2    = 0;
 8005624:	604a      	str	r2, [r1, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8005626:	6148      	str	r0, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8005628:	6008      	str	r0, [r1, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800562a:	21c4      	movs	r1, #196	; 0xc4
 800562c:	0089      	lsls	r1, r1, #2
 800562e:	585f      	ldr	r7, [r3, r1]
 8005630:	4645      	mov	r5, r8
 8005632:	43af      	bics	r7, r5
 8005634:	465d      	mov	r5, fp
 8005636:	432f      	orrs	r7, r5
 8005638:	505f      	str	r7, [r3, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800563a:	2180      	movs	r1, #128	; 0x80
 800563c:	0249      	lsls	r1, r1, #9
 800563e:	4665      	mov	r5, ip
 8005640:	5159      	str	r1, [r3, r5]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005642:	6019      	str	r1, [r3, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005644:	4b51      	ldr	r3, [pc, #324]	; (800578c <main+0x2fc>)
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005646:	465d      	mov	r5, fp
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8005648:	1c19      	adds	r1, r3, #0
 800564a:	311c      	adds	r1, #28
 800564c:	61d9      	str	r1, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800564e:	6219      	str	r1, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 8005650:	849e      	strh	r6, [r3, #36]	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8005652:	494f      	ldr	r1, [pc, #316]	; (8005790 <main+0x300>)
 8005654:	4e4f      	ldr	r6, [pc, #316]	; (8005794 <main+0x304>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8005656:	609a      	str	r2, [r3, #8]
 8005658:	600e      	str	r6, [r1, #0]
  endmem  = __heap_end__;
 800565a:	4e4f      	ldr	r6, [pc, #316]	; (8005798 <main+0x308>)
 800565c:	494f      	ldr	r1, [pc, #316]	; (800579c <main+0x30c>)
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800565e:	84da      	strh	r2, [r3, #38]	; 0x26
 8005660:	600e      	str	r6, [r1, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8005662:	494f      	ldr	r1, [pc, #316]	; (80057a0 <main+0x310>)
 8005664:	4e4f      	ldr	r6, [pc, #316]	; (80057a4 <main+0x314>)
 8005666:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8005668:	605b      	str	r3, [r3, #4]
 800566a:	600e      	str	r6, [r1, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800566c:	1c0e      	adds	r6, r1, #0
 800566e:	3610      	adds	r6, #16
  H_NEXT(&default_heap.header) = NULL;
 8005670:	608a      	str	r2, [r1, #8]
  H_PAGES(&default_heap.header) = 0;
 8005672:	60ca      	str	r2, [r1, #12]
 8005674:	610e      	str	r6, [r1, #16]
  tqp->prev = (thread_t *)tqp;
 8005676:	614e      	str	r6, [r1, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8005678:	618a      	str	r2, [r1, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800567a:	4659      	mov	r1, fp
 800567c:	6359      	str	r1, [r3, #52]	; 0x34
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 800567e:	2600      	movs	r6, #0
 8005680:	214d      	movs	r1, #77	; 0x4d
 8005682:	545e      	strb	r6, [r3, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005684:	214e      	movs	r1, #78	; 0x4e
 8005686:	5458      	strb	r0, [r3, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005688:	669d      	str	r5, [r3, #104]	; 0x68
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800568a:	4947      	ldr	r1, [pc, #284]	; (80057a8 <main+0x318>)
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800568c:	1c1d      	adds	r5, r3, #0
 800568e:	3554      	adds	r5, #84	; 0x54
 8005690:	6459      	str	r1, [r3, #68]	; 0x44
 8005692:	655d      	str	r5, [r3, #84]	; 0x54
  REG_INSERT(tp);
 8005694:	1c19      	adds	r1, r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005696:	1c1d      	adds	r5, r3, #0
 8005698:	312c      	adds	r1, #44	; 0x2c
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 800569a:	665a      	str	r2, [r3, #100]	; 0x64
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800569c:	661a      	str	r2, [r3, #96]	; 0x60
 800569e:	3558      	adds	r5, #88	; 0x58
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 80056a0:	649a      	str	r2, [r3, #72]	; 0x48
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80056a2:	224c      	movs	r2, #76	; 0x4c
 80056a4:	5498      	strb	r0, [r3, r2]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80056a6:	6119      	str	r1, [r3, #16]
 80056a8:	6159      	str	r1, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80056aa:	6199      	str	r1, [r3, #24]
 80056ac:	63db      	str	r3, [r3, #60]	; 0x3c
 80056ae:	641b      	str	r3, [r3, #64]	; 0x40
 80056b0:	659d      	str	r5, [r3, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 80056b2:	65dd      	str	r5, [r3, #92]	; 0x5c
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80056b4:	4b3d      	ldr	r3, [pc, #244]	; (80057ac <main+0x31c>)
 80056b6:	4a3e      	ldr	r2, [pc, #248]	; (80057b0 <main+0x320>)
 80056b8:	6a19      	ldr	r1, [r3, #32]
 80056ba:	400a      	ands	r2, r1
 80056bc:	621a      	str	r2, [r3, #32]
 80056be:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80056c0:	b672      	cpsid	i
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 80056c2:	483c      	ldr	r0, [pc, #240]	; (80057b4 <main+0x324>)
 80056c4:	f7fb f9c4 	bl	8000a50 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 80056c8:	2100      	movs	r1, #0
 80056ca:	f7fb fa99 	bl	8000c00 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80056ce:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80056d0:	b672      	cpsid	i
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80056d2:	4d26      	ldr	r5, [pc, #152]	; (800576c <main+0x2dc>)
 80056d4:	7a2b      	ldrb	r3, [r5, #8]
 80056d6:	2b01      	cmp	r3, #1
 80056d8:	d104      	bne.n	80056e4 <main+0x254>
      rccEnableUSART1(FALSE);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 80056da:	69e2      	ldr	r2, [r4, #28]
 80056dc:	2380      	movs	r3, #128	; 0x80
 80056de:	029b      	lsls	r3, r3, #10
 80056e0:	4313      	orrs	r3, r2
 80056e2:	61e3      	str	r3, [r4, #28]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 80056e4:	4d21      	ldr	r5, [pc, #132]	; (800576c <main+0x2dc>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80056e6:	2196      	movs	r1, #150	; 0x96
 80056e8:	6fa8      	ldr	r0, [r5, #120]	; 0x78
 80056ea:	0209      	lsls	r1, r1, #8
 80056ec:	9000      	str	r0, [sp, #0]
 80056ee:	f7fa fd8f 	bl	8000210 <__aeabi_uidiv>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 80056f2:	6f6c      	ldr	r4, [r5, #116]	; 0x74
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80056f4:	2300      	movs	r3, #0
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80056f6:	60e0      	str	r0, [r4, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80056f8:	6063      	str	r3, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80056fa:	2301      	movs	r3, #1
 80056fc:	60a3      	str	r3, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80056fe:	232e      	movs	r3, #46	; 0x2e
 8005700:	33ff      	adds	r3, #255	; 0xff
 8005702:	6023      	str	r3, [r4, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8005704:	2301      	movs	r3, #1
 8005706:	425b      	negs	r3, r3
 8005708:	6223      	str	r3, [r4, #32]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800570a:	2302      	movs	r3, #2
 800570c:	722b      	strb	r3, [r5, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800570e:	b662      	cpsie	i
  sdStart(&SD2, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8005710:	2180      	movs	r1, #128	; 0x80
 8005712:	4a29      	ldr	r2, [pc, #164]	; (80057b8 <main+0x328>)
 8005714:	4829      	ldr	r0, [pc, #164]	; (80057bc <main+0x32c>)
 8005716:	2300      	movs	r3, #0
 8005718:	f7ff fd72 	bl	8005200 <chThdCreateStatic.constprop.52>
 800571c:	4928      	ldr	r1, [pc, #160]	; (80057c0 <main+0x330>)
 800571e:	4a29      	ldr	r2, [pc, #164]	; (80057c4 <main+0x334>)
 8005720:	4c29      	ldr	r4, [pc, #164]	; (80057c8 <main+0x338>)
 8005722:	4e2a      	ldr	r6, [pc, #168]	; (80057cc <main+0x33c>)
 8005724:	468a      	mov	sl, r1
 8005726:	4693      	mov	fp, r2
 8005728:	e056      	b.n	80057d8 <main+0x348>
 800572a:	46c0      	nop			; (mov r8, r8)
 800572c:	40021000 	.word	0x40021000
 8005730:	ffbfffff 	.word	0xffbfffff
 8005734:	40007000 	.word	0x40007000
 8005738:	fffff75f 	.word	0xfffff75f
 800573c:	65555105 	.word	0x65555105
 8005740:	0000ffff 	.word	0x0000ffff
 8005744:	0000ffdf 	.word	0x0000ffdf
 8005748:	280004a0 	.word	0x280004a0
 800574c:	48000400 	.word	0x48000400
 8005750:	55555555 	.word	0x55555555
 8005754:	48000800 	.word	0x48000800
 8005758:	01555555 	.word	0x01555555
 800575c:	48000c00 	.word	0x48000c00
 8005760:	55555550 	.word	0x55555550
 8005764:	48001400 	.word	0x48001400
 8005768:	080065fc 	.word	0x080065fc
 800576c:	20000e54 	.word	0x20000e54
 8005770:	08000391 	.word	0x08000391
 8005774:	40004400 	.word	0x40004400
 8005778:	02dc6c00 	.word	0x02dc6c00
 800577c:	e000e100 	.word	0xe000e100
 8005780:	40015800 	.word	0x40015800
 8005784:	40000400 	.word	0x40000400
 8005788:	0000bb7f 	.word	0x0000bb7f
 800578c:	20000ed4 	.word	0x20000ed4
 8005790:	20000f4c 	.word	0x20000f4c
 8005794:	20000f50 	.word	0x20000f50
 8005798:	20002000 	.word	0x20002000
 800579c:	20000f48 	.word	0x20000f48
 80057a0:	20000e30 	.word	0x20000e30
 80057a4:	080003b1 	.word	0x080003b1
 80057a8:	080062dc 	.word	0x080062dc
 80057ac:	e000ed00 	.word	0xe000ed00
 80057b0:	ff00ffff 	.word	0xff00ffff
 80057b4:	080064cc 	.word	0x080064cc
 80057b8:	08002e41 	.word	0x08002e41
 80057bc:	20000cd0 	.word	0x20000cd0
 80057c0:	20000e1c 	.word	0x20000e1c
 80057c4:	20000f44 	.word	0x20000f44
 80057c8:	20000e2c 	.word	0x20000e2c
 80057cc:	20000e18 	.word	0x20000e18
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadPad(GPIOC, GPIOC_BUTTON))
      test_execute((BaseSequentialStream *)&SD2);
    chThdSleepMilliseconds(500);
 80057d0:	20fa      	movs	r0, #250	; 0xfa
 80057d2:	0040      	lsls	r0, r0, #1
 80057d4:	f7fd fb2c 	bl	8002e30 <chThdSleep>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadPad(GPIOC, GPIOC_BUTTON))
 80057d8:	4d8c      	ldr	r5, [pc, #560]	; (8005a0c <main+0x57c>)
 80057da:	2080      	movs	r0, #128	; 0x80
 80057dc:	692b      	ldr	r3, [r5, #16]
 80057de:	0180      	lsls	r0, r0, #6
 80057e0:	4203      	tst	r3, r0
 80057e2:	d1f5      	bne.n	80057d0 <main+0x340>
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 80057e4:	4d8a      	ldr	r5, [pc, #552]	; (8005a10 <main+0x580>)
  test_println("");
 80057e6:	488b      	ldr	r0, [pc, #556]	; (8005a14 <main+0x584>)
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 80057e8:	6025      	str	r5, [r4, #0]
  test_println("");
 80057ea:	f7fa ff39 	bl	8000660 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 80057ee:	488a      	ldr	r0, [pc, #552]	; (8005a18 <main+0x588>)
 80057f0:	f7fa ff36 	bl	8000660 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 80057f4:	4889      	ldr	r0, [pc, #548]	; (8005a1c <main+0x58c>)
 80057f6:	f7fa ff33 	bl	8000660 <test_println>
 80057fa:	4d89      	ldr	r5, [pc, #548]	; (8005a20 <main+0x590>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80057fc:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 80057fe:	6820      	ldr	r0, [r4, #0]
 8005800:	3501      	adds	r5, #1
 8005802:	6803      	ldr	r3, [r0, #0]
 8005804:	689b      	ldr	r3, [r3, #8]
 8005806:	4798      	blx	r3
 8005808:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 800580a:	7819      	ldrb	r1, [r3, #0]
 800580c:	2900      	cmp	r1, #0
 800580e:	d1f6      	bne.n	80057fe <main+0x36e>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8005810:	4884      	ldr	r0, [pc, #528]	; (8005a24 <main+0x594>)
 8005812:	f7fa ff25 	bl	8000660 <test_println>
 8005816:	4d84      	ldr	r5, [pc, #528]	; (8005a28 <main+0x598>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005818:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 800581a:	6820      	ldr	r0, [r4, #0]
 800581c:	3501      	adds	r5, #1
 800581e:	6803      	ldr	r3, [r0, #0]
 8005820:	689b      	ldr	r3, [r3, #8]
 8005822:	4798      	blx	r3
 8005824:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005826:	7819      	ldrb	r1, [r3, #0]
 8005828:	2900      	cmp	r1, #0
 800582a:	d1f6      	bne.n	800581a <main+0x38a>
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 800582c:	487f      	ldr	r0, [pc, #508]	; (8005a2c <main+0x59c>)
 800582e:	f7fa ff17 	bl	8000660 <test_println>
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005832:	252a      	movs	r5, #42	; 0x2a
 8005834:	4f7e      	ldr	r7, [pc, #504]	; (8005a30 <main+0x5a0>)
 8005836:	1c29      	adds	r1, r5, #0
    streamPut(test_chp, *msgp++);
 8005838:	6820      	ldr	r0, [r4, #0]
 800583a:	3701      	adds	r7, #1
 800583c:	6803      	ldr	r3, [r0, #0]
 800583e:	689b      	ldr	r3, [r3, #8]
 8005840:	4798      	blx	r3
 8005842:	1e7b      	subs	r3, r7, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005844:	7819      	ldrb	r1, [r3, #0]
 8005846:	2900      	cmp	r1, #0
 8005848:	d1f6      	bne.n	8005838 <main+0x3a8>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 800584a:	487a      	ldr	r0, [pc, #488]	; (8005a34 <main+0x5a4>)
 800584c:	1c0d      	adds	r5, r1, #0
 800584e:	f7fa ff07 	bl	8000660 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8005852:	4870      	ldr	r0, [pc, #448]	; (8005a14 <main+0x584>)
 8005854:	f7fa ff04 	bl	8000660 <test_println>

  test_global_fail = false;
 8005858:	4877      	ldr	r0, [pc, #476]	; (8005a38 <main+0x5a8>)
 800585a:	7005      	strb	r5, [r0, #0]
  i = 0;
  while (test_suite[i]) {
 800585c:	4d77      	ldr	r5, [pc, #476]	; (8005a3c <main+0x5ac>)
 800585e:	682b      	ldr	r3, [r5, #0]
 8005860:	2b00      	cmp	r3, #0
 8005862:	d100      	bne.n	8005866 <main+0x3d6>
 8005864:	e0b1      	b.n	80059ca <main+0x53a>
 8005866:	46a9      	mov	r9, r5
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
 8005868:	2500      	movs	r5, #0
 800586a:	9501      	str	r5, [sp, #4]
 800586c:	9d01      	ldr	r5, [sp, #4]
 800586e:	3501      	adds	r5, #1
 8005870:	9501      	str	r5, [sp, #4]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005872:	2500      	movs	r5, #0
 8005874:	46a8      	mov	r8, r5
 8005876:	4640      	mov	r0, r8
 8005878:	0087      	lsls	r7, r0, #2

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 800587a:	59db      	ldr	r3, [r3, r7]
 800587c:	2b00      	cmp	r3, #0
 800587e:	d100      	bne.n	8005882 <main+0x3f2>
 8005880:	e09c      	b.n	80059bc <main+0x52c>
      print_line();
 8005882:	f7fb f875 	bl	8000970 <print_line.8268>
 8005886:	4d6e      	ldr	r5, [pc, #440]	; (8005a40 <main+0x5b0>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005888:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 800588a:	6820      	ldr	r0, [r4, #0]
 800588c:	3501      	adds	r5, #1
 800588e:	6803      	ldr	r3, [r0, #0]
 8005890:	689b      	ldr	r3, [r3, #8]
 8005892:	4798      	blx	r3
 8005894:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005896:	7819      	ldrb	r1, [r3, #0]
 8005898:	2900      	cmp	r1, #0
 800589a:	d1f6      	bne.n	800588a <main+0x3fa>
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 800589c:	9801      	ldr	r0, [sp, #4]
 800589e:	f7fa ff17 	bl	80006d0 <test_printn>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 80058a2:	6820      	ldr	r0, [r4, #0]
 80058a4:	212e      	movs	r1, #46	; 0x2e
 80058a6:	6803      	ldr	r3, [r0, #0]
 80058a8:	689b      	ldr	r3, [r3, #8]
 80058aa:	4798      	blx	r3
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 80058ac:	2001      	movs	r0, #1
 80058ae:	4480      	add	r8, r0
 80058b0:	4640      	mov	r0, r8
 80058b2:	f7fa ff0d 	bl	80006d0 <test_printn>
 80058b6:	4d63      	ldr	r5, [pc, #396]	; (8005a44 <main+0x5b4>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80058b8:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 80058ba:	6820      	ldr	r0, [r4, #0]
 80058bc:	3501      	adds	r5, #1
 80058be:	6803      	ldr	r3, [r0, #0]
 80058c0:	689b      	ldr	r3, [r3, #8]
 80058c2:	4798      	blx	r3
 80058c4:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80058c6:	7819      	ldrb	r1, [r3, #0]
 80058c8:	2900      	cmp	r1, #0
 80058ca:	d1f6      	bne.n	80058ba <main+0x42a>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
 80058cc:	4648      	mov	r0, r9
 80058ce:	6800      	ldr	r0, [r0, #0]
 80058d0:	59c3      	ldr	r3, [r0, r7]
 80058d2:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80058d4:	7829      	ldrb	r1, [r5, #0]
 80058d6:	2900      	cmp	r1, #0
 80058d8:	d007      	beq.n	80058ea <main+0x45a>
    streamPut(test_chp, *msgp++);
 80058da:	6820      	ldr	r0, [r4, #0]
 80058dc:	3501      	adds	r5, #1
 80058de:	6803      	ldr	r3, [r0, #0]
 80058e0:	689b      	ldr	r3, [r3, #8]
 80058e2:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80058e4:	7829      	ldrb	r1, [r5, #0]
 80058e6:	2900      	cmp	r1, #0
 80058e8:	d1f7      	bne.n	80058da <main+0x44a>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
      test_println(")");
 80058ea:	4857      	ldr	r0, [pc, #348]	; (8005a48 <main+0x5b8>)
 80058ec:	f7fa feb8 	bl	8000660 <test_println>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 80058f0:	20c8      	movs	r0, #200	; 0xc8
 80058f2:	f7fd fa9d 	bl	8002e30 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 80058f6:	4649      	mov	r1, r9
 80058f8:	6809      	ldr	r1, [r1, #0]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 80058fa:	4b54      	ldr	r3, [pc, #336]	; (8005a4c <main+0x5bc>)
      test_print(test_suite[i][j]->name);
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 80058fc:	59cd      	ldr	r5, [r1, r7]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 80058fe:	2000      	movs	r0, #0
 8005900:	7018      	strb	r0, [r3, #0]

  if (tcp->setup != NULL)
 8005902:	686b      	ldr	r3, [r5, #4]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8005904:	4652      	mov	r2, sl
 8005906:	6032      	str	r2, [r6, #0]

  /* Initialization */
  clear_tokens();
  test_local_fail = false;

  if (tcp->setup != NULL)
 8005908:	2b00      	cmp	r3, #0
 800590a:	d000      	beq.n	800590e <main+0x47e>
    tcp->setup();
 800590c:	4798      	blx	r3
  tcp->execute();
 800590e:	68e9      	ldr	r1, [r5, #12]
 8005910:	4788      	blx	r1
  if (tcp->teardown != NULL)
 8005912:	68ab      	ldr	r3, [r5, #8]
 8005914:	2b00      	cmp	r3, #0
 8005916:	d000      	beq.n	800591a <main+0x48a>
    tcp->teardown();
 8005918:	4798      	blx	r3
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
 800591a:	4d4c      	ldr	r5, [pc, #304]	; (8005a4c <main+0x5bc>)
 800591c:	782b      	ldrb	r3, [r5, #0]
 800591e:	2b00      	cmp	r3, #0
 8005920:	d06b      	beq.n	80059fa <main+0x56a>
 8005922:	4d4b      	ldr	r5, [pc, #300]	; (8005a50 <main+0x5c0>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005924:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8005926:	6820      	ldr	r0, [r4, #0]
 8005928:	3501      	adds	r5, #1
 800592a:	6803      	ldr	r3, [r0, #0]
 800592c:	689b      	ldr	r3, [r3, #8]
 800592e:	4798      	blx	r3
 8005930:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005932:	7819      	ldrb	r1, [r3, #0]
 8005934:	2900      	cmp	r1, #0
 8005936:	d1f6      	bne.n	8005926 <main+0x496>
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8005938:	4659      	mov	r1, fp
 800593a:	6808      	ldr	r0, [r1, #0]
 800593c:	f7fa fec8 	bl	80006d0 <test_printn>
 8005940:	4d44      	ldr	r5, [pc, #272]	; (8005a54 <main+0x5c4>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005942:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8005944:	6820      	ldr	r0, [r4, #0]
 8005946:	3501      	adds	r5, #1
 8005948:	6803      	ldr	r3, [r0, #0]
 800594a:	689b      	ldr	r3, [r3, #8]
 800594c:	4798      	blx	r3
 800594e:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005950:	7819      	ldrb	r1, [r3, #0]
 8005952:	2900      	cmp	r1, #0
 8005954:	d1f6      	bne.n	8005944 <main+0x4b4>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8005956:	6830      	ldr	r0, [r6, #0]
 8005958:	4655      	mov	r5, sl
 800595a:	3501      	adds	r5, #1
 800595c:	4550      	cmp	r0, sl
 800595e:	d90a      	bls.n	8005976 <main+0x4e6>
    streamPut(test_chp, *cp++);
 8005960:	6820      	ldr	r0, [r4, #0]
 8005962:	1e6a      	subs	r2, r5, #1
 8005964:	6803      	ldr	r3, [r0, #0]
 8005966:	7811      	ldrb	r1, [r2, #0]
 8005968:	689b      	ldr	r3, [r3, #8]
 800596a:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 800596c:	6831      	ldr	r1, [r6, #0]
    streamPut(test_chp, *cp++);
 800596e:	1c2f      	adds	r7, r5, #0
 8005970:	3501      	adds	r5, #1
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8005972:	428f      	cmp	r7, r1
 8005974:	d3f4      	bcc.n	8005960 <main+0x4d0>
 8005976:	4d38      	ldr	r5, [pc, #224]	; (8005a58 <main+0x5c8>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005978:	215d      	movs	r1, #93	; 0x5d
    streamPut(test_chp, *msgp++);
 800597a:	6820      	ldr	r0, [r4, #0]
 800597c:	3501      	adds	r5, #1
 800597e:	6803      	ldr	r3, [r0, #0]
 8005980:	689b      	ldr	r3, [r3, #8]
 8005982:	4798      	blx	r3
 8005984:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005986:	7819      	ldrb	r1, [r3, #0]
 8005988:	2900      	cmp	r1, #0
 800598a:	d1f6      	bne.n	800597a <main+0x4ea>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 800598c:	4a33      	ldr	r2, [pc, #204]	; (8005a5c <main+0x5cc>)
 800598e:	6815      	ldr	r5, [r2, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005990:	7829      	ldrb	r1, [r5, #0]
 8005992:	2900      	cmp	r1, #0
 8005994:	d007      	beq.n	80059a6 <main+0x516>
    streamPut(test_chp, *msgp++);
 8005996:	6820      	ldr	r0, [r4, #0]
 8005998:	3501      	adds	r5, #1
 800599a:	6803      	ldr	r3, [r0, #0]
 800599c:	689b      	ldr	r3, [r3, #8]
 800599e:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80059a0:	7829      	ldrb	r1, [r5, #0]
 80059a2:	2900      	cmp	r1, #0
 80059a4:	d1f7      	bne.n	8005996 <main+0x506>
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
 80059a6:	482e      	ldr	r0, [pc, #184]	; (8005a60 <main+0x5d0>)
 80059a8:	f7fa fe5a 	bl	8000660 <test_println>
 80059ac:	464d      	mov	r5, r9
 80059ae:	682b      	ldr	r3, [r5, #0]
 80059b0:	4640      	mov	r0, r8
 80059b2:	0087      	lsls	r7, r0, #2

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 80059b4:	59db      	ldr	r3, [r3, r7]
 80059b6:	2b00      	cmp	r3, #0
 80059b8:	d000      	beq.n	80059bc <main+0x52c>
 80059ba:	e762      	b.n	8005882 <main+0x3f2>
 80059bc:	2104      	movs	r1, #4
 80059be:	4489      	add	r9, r1
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 80059c0:	464a      	mov	r2, r9
 80059c2:	6813      	ldr	r3, [r2, #0]
 80059c4:	2b00      	cmp	r3, #0
 80059c6:	d000      	beq.n	80059ca <main+0x53a>
 80059c8:	e750      	b.n	800586c <main+0x3dc>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 80059ca:	f7fa ffd1 	bl	8000970 <print_line.8268>
  test_println("");
 80059ce:	4811      	ldr	r0, [pc, #68]	; (8005a14 <main+0x584>)
 80059d0:	f7fa fe46 	bl	8000660 <test_println>
 80059d4:	4d23      	ldr	r5, [pc, #140]	; (8005a64 <main+0x5d4>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80059d6:	2146      	movs	r1, #70	; 0x46
    streamPut(test_chp, *msgp++);
 80059d8:	6820      	ldr	r0, [r4, #0]
 80059da:	3501      	adds	r5, #1
 80059dc:	6803      	ldr	r3, [r0, #0]
 80059de:	689b      	ldr	r3, [r3, #8]
 80059e0:	4798      	blx	r3
 80059e2:	1e6b      	subs	r3, r5, #1
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80059e4:	7819      	ldrb	r1, [r3, #0]
 80059e6:	2900      	cmp	r1, #0
 80059e8:	d1f6      	bne.n	80059d8 <main+0x548>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 80059ea:	4d13      	ldr	r5, [pc, #76]	; (8005a38 <main+0x5a8>)
 80059ec:	782b      	ldrb	r3, [r5, #0]
 80059ee:	2b00      	cmp	r3, #0
 80059f0:	d107      	bne.n	8005a02 <main+0x572>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80059f2:	481d      	ldr	r0, [pc, #116]	; (8005a68 <main+0x5d8>)
 80059f4:	f7fa fe34 	bl	8000660 <test_println>
 80059f8:	e6ea      	b.n	80057d0 <main+0x340>
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else
        test_println("--- Result: SUCCESS");
 80059fa:	481c      	ldr	r0, [pc, #112]	; (8005a6c <main+0x5dc>)
 80059fc:	f7fa fe30 	bl	8000660 <test_println>
 8005a00:	e7d4      	b.n	80059ac <main+0x51c>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8005a02:	481b      	ldr	r0, [pc, #108]	; (8005a70 <main+0x5e0>)
 8005a04:	f7fa fe2c 	bl	8000660 <test_println>
 8005a08:	e6e2      	b.n	80057d0 <main+0x340>
 8005a0a:	46c0      	nop			; (mov r8, r8)
 8005a0c:	48000800 	.word	0x48000800
 8005a10:	20000e54 	.word	0x20000e54
 8005a14:	080060d0 	.word	0x080060d0
 8005a18:	080066ac 	.word	0x080066ac
 8005a1c:	080066c8 	.word	0x080066c8
 8005a20:	080066cd 	.word	0x080066cd
 8005a24:	0800675c 	.word	0x0800675c
 8005a28:	08006775 	.word	0x08006775
 8005a2c:	08006788 	.word	0x08006788
 8005a30:	080067b5 	.word	0x080067b5
 8005a34:	080066e0 	.word	0x080066e0
 8005a38:	20000e50 	.word	0x20000e50
 8005a3c:	2000047c 	.word	0x2000047c
 8005a40:	0800670d 	.word	0x0800670d
 8005a44:	080067c9 	.word	0x080067c9
 8005a48:	0800671c 	.word	0x0800671c
 8005a4c:	20000e51 	.word	0x20000e51
 8005a50:	08006721 	.word	0x08006721
 8005a54:	080067cd 	.word	0x080067cd
 8005a58:	08006739 	.word	0x08006739
 8005a5c:	20000ed0 	.word	0x20000ed0
 8005a60:	0800673c 	.word	0x0800673c
 8005a64:	080067d1 	.word	0x080067d1
 8005a68:	0800674c 	.word	0x0800674c
 8005a6c:	08006740 	.word	0x08006740
 8005a70:	08006754 	.word	0x08006754
 8005a74:	46c0      	nop			; (mov r8, r8)
 8005a76:	46c0      	nop			; (mov r8, r8)
 8005a78:	46c0      	nop			; (mov r8, r8)
 8005a7a:	46c0      	nop			; (mov r8, r8)
 8005a7c:	46c0      	nop			; (mov r8, r8)
 8005a7e:	46c0      	nop			; (mov r8, r8)

08005a80 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005a80:	4827      	ldr	r0, [pc, #156]	; (8005b20 <__early_init+0xa0>)
 8005a82:	2301      	movs	r3, #1
 8005a84:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8005a86:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005a88:	4313      	orrs	r3, r2
 8005a8a:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8005a8c:	6803      	ldr	r3, [r0, #0]
 8005a8e:	4a24      	ldr	r2, [pc, #144]	; (8005b20 <__early_init+0xa0>)
 8005a90:	4219      	tst	r1, r3
 8005a92:	d0fb      	beq.n	8005a8c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8005a94:	6853      	ldr	r3, [r2, #4]
 8005a96:	2103      	movs	r1, #3
 8005a98:	438b      	bics	r3, r1
 8005a9a:	6053      	str	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8005a9c:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8005a9e:	1c10      	adds	r0, r2, #0

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8005aa0:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8005aa2:	210c      	movs	r1, #12
 8005aa4:	6843      	ldr	r3, [r0, #4]
 8005aa6:	4a1e      	ldr	r2, [pc, #120]	; (8005b20 <__early_init+0xa0>)
 8005aa8:	400b      	ands	r3, r1
 8005aaa:	d1fb      	bne.n	8005aa4 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8005aac:	6811      	ldr	r1, [r2, #0]
 8005aae:	20f9      	movs	r0, #249	; 0xf9
 8005ab0:	4001      	ands	r1, r0
 8005ab2:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005ab4:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8005ab6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8005ab8:	2301      	movs	r3, #1
 8005aba:	430b      	orrs	r3, r1
 8005abc:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8005abe:	2002      	movs	r0, #2
 8005ac0:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8005ac2:	4917      	ldr	r1, [pc, #92]	; (8005b20 <__early_init+0xa0>)
 8005ac4:	4218      	tst	r0, r3
 8005ac6:	d0fb      	beq.n	8005ac0 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8005ac8:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8005aca:	2301      	movs	r3, #1
 8005acc:	4313      	orrs	r3, r2
 8005ace:	624b      	str	r3, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8005ad0:	2002      	movs	r0, #2
 8005ad2:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8005ad4:	4a12      	ldr	r2, [pc, #72]	; (8005b20 <__early_init+0xa0>)
 8005ad6:	4218      	tst	r0, r3
 8005ad8:	d0fb      	beq.n	8005ad2 <__early_init+0x52>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8005ada:	23a0      	movs	r3, #160	; 0xa0
 8005adc:	039b      	lsls	r3, r3, #14
 8005ade:	6053      	str	r3, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8005ae0:	2300      	movs	r3, #0
 8005ae2:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8005ae4:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8005ae6:	6811      	ldr	r1, [r2, #0]
 8005ae8:	2380      	movs	r3, #128	; 0x80
 8005aea:	045b      	lsls	r3, r3, #17
 8005aec:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005aee:	2080      	movs	r0, #128	; 0x80
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8005af0:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005af2:	0480      	lsls	r0, r0, #18
 8005af4:	6813      	ldr	r3, [r2, #0]
 8005af6:	490a      	ldr	r1, [pc, #40]	; (8005b20 <__early_init+0xa0>)
 8005af8:	4203      	tst	r3, r0
 8005afa:	d0fb      	beq.n	8005af4 <__early_init+0x74>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8005afc:	4b09      	ldr	r3, [pc, #36]	; (8005b24 <__early_init+0xa4>)
 8005afe:	2211      	movs	r2, #17
 8005b00:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8005b02:	684a      	ldr	r2, [r1, #4]
 8005b04:	2302      	movs	r3, #2
 8005b06:	4313      	orrs	r3, r2
 8005b08:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8005b0a:	200c      	movs	r0, #12
 8005b0c:	684b      	ldr	r3, [r1, #4]
 8005b0e:	4a04      	ldr	r2, [pc, #16]	; (8005b20 <__early_init+0xa0>)
 8005b10:	4003      	ands	r3, r0
 8005b12:	2b08      	cmp	r3, #8
 8005b14:	d1fa      	bne.n	8005b0c <__early_init+0x8c>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8005b16:	6991      	ldr	r1, [r2, #24]
 8005b18:	2301      	movs	r3, #1
 8005b1a:	430b      	orrs	r3, r1
 8005b1c:	6193      	str	r3, [r2, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 8005b1e:	4770      	bx	lr
 8005b20:	40021000 	.word	0x40021000
 8005b24:	40022000 	.word	0x40022000
 8005b28:	46c0      	nop			; (mov r8, r8)
 8005b2a:	46c0      	nop			; (mov r8, r8)
 8005b2c:	46c0      	nop			; (mov r8, r8)
 8005b2e:	46c0      	nop			; (mov r8, r8)

08005b30 <bmk_thread3.10600>:
  (void)chMsgSend(tp, 0);
  return n;
}
#endif

static THD_FUNCTION(bmk_thread3, p) {
 8005b30:	b508      	push	{r3, lr}

  chThdExit((msg_t)p);
 8005b32:	f7fe f83d 	bl	8003bb0 <chThdExit>
}
 8005b36:	bd08      	pop	{r3, pc}
 8005b38:	46c0      	nop			; (mov r8, r8)
 8005b3a:	46c0      	nop			; (mov r8, r8)
 8005b3c:	46c0      	nop			; (mov r8, r8)
 8005b3e:	46c0      	nop			; (mov r8, r8)
