
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	e8 90       	cmp.b	@r0		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	ea 90       	cmp.b	@r0		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	ec 90       	cmp.b	@r0		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	ee 90       	cmp.b	@r0		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	f0 90 00 00 	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	f2 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	f4 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	f6 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	f8 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	fa 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	fc 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	fe 90       	cmp.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	00 91       	cmp	r1,	r0	;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	02 91       	cmp	r1,	r2	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	04 91       	cmp	r1,	r4	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	06 91       	cmp	r1,	r6	;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	08 91       	cmp	r1,	r8	;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	0a 91       	cmp	r1,	r10	;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	0c 91       	cmp	r1,	r12	;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	0e 91       	cmp	r1,	r14	;

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	10 91       	cmp,		r0	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	12 91       	cmp,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	14 91       	cmp,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	16 91       	cmp,		r6	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	18 91       	cmp,		r8	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	1a 91       	cmp,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	1c 91       	cmp,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	1e 91       	cmp,		r14	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	20 91       	cmp	@r1,	r0	;

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	22 91       	cmp	@r1,	r2	;

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	24 91       	cmp	@r1,	r4	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	26 91       	cmp	@r1,	r6	;

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	d0 7e 00 00 	subc.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	6c 7e       	subc.b	@r14,	r12	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	28 91       	cmp	@r1,	r8	;

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	2a 91       	cmp	@r1,	r10	;

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	0a 7e       	subc	r14,	r10	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	2c 91       	cmp	@r1,	r12	;

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	2e 91       	cmp	@r1,	r14	;

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	aa 7d       	subc	@r13		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	30 91       	interrupt service routine at 0x9130

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	32 91       	interrupt service routine at 0x9132

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	7c 80       	interrupt service routine at 0x807c

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	34 91       	interrupt service routine at 0x9134

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	36 91       	interrupt service routine at 0x9136

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	38 91       	interrupt service routine at 0x9138

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	3a 91       	interrupt service routine at 0x913a

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	d8 84       	interrupt service routine at 0x84d8

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	5c 7c       	interrupt service routine at 0x7c5c

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	3c 91       	interrupt service routine at 0x913c

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	3e 91       	interrupt service routine at 0x913e

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	c4 77       	interrupt service routine at 0x77c4

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	40 91       	interrupt service routine at 0x9140

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	42 91       	interrupt service routine at 0x9142

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	44 91       	interrupt service routine at 0x9144

Disassembly of section .text:

000064e2 <__crt0_start>:
    64e2:	31 40 00 50 	mov	#20480,	r1	;#0x5000

000064e6 <disable_watchdog>:
#include "chbsem.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    64e6:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    64ea:	5c 01 

000064ec <.Loc.27.3>:
}
    64ec:	03 43       	nop			

000064ee <__crt0_init_bss>:
    64ee:	3c 40 b0 51 	mov	#20912,	r12	;#0x51b0

000064f2 <.Loc.74.1>:
    64f2:	0d 43       	clr	r13		;

000064f4 <.Loc.75.1>:
    64f4:	3e 40 32 13 	mov	#4914,	r14	;#0x1332

000064f8 <.Loc.79.1>:
    64f8:	b0 12 06 9e 	call	#-25082	;#0x9e06

000064fc <__crt0_movedata>:
    64fc:	3c 40 98 51 	mov	#20888,	r12	;#0x5198

00006500 <.Loc.116.1>:
    6500:	3d 40 98 51 	mov	#20888,	r13	;#0x5198

00006504 <.Loc.119.1>:
    6504:	0d 9c       	cmp	r12,	r13	;

00006506 <.Loc.120.1>:
    6506:	04 24       	jz	$+10     	;abs 0x6510

00006508 <.Loc.122.1>:
    6508:	3e 40 18 00 	mov	#24,	r14	;#0x0018

0000650c <.Loc.124.1>:
    650c:	b0 12 cc 9d 	call	#-25140	;#0x9dcc

00006510 <__crt0_call_just_main>:
    6510:	0c 43       	clr	r12		;

00006512 <.Loc.181.1>:
    6512:	b0 12 d0 9b 	call	#-25648	;#0x9bd0

00006516 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    6516:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00

0000651a <.Loc.305.1>:
}
    651a:	03 43       	nop			
    651c:	30 41       	ret			

0000651e <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
    651e:	21 83       	decd	r1		;

00006520 <.LBB2>:

  return __get_SR_register();
    6520:	0c 42       	mov	r2,	r12	;
    6522:	81 4c 00 00 	mov	r12,	0(r1)	;
    6526:	2c 41       	mov	@r1,	r12	;

00006528 <.LBE2>:
}
    6528:	21 53       	incd	r1		;
    652a:	30 41       	ret			

0000652c <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
    652c:	21 83       	decd	r1		;

0000652e <.LCFI1>:
    652e:	81 4c 00 00 	mov	r12,	0(r1)	;

00006532 <.Loc.328.1>:

  return sts & GIE;
    6532:	2c 41       	mov	@r1,	r12	;
    6534:	7c f2       	and.b	#8,	r12	;r2 As==11
    6536:	0d 43       	clr	r13		;
    6538:	0d 8c       	sub	r12,	r13	;
    653a:	0c dd       	bis	r13,	r12	;
    653c:	5c 03       	rrum	#1,	r12	;
    653e:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    6542:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006546 <.Loc.329.1>:
}
    6546:	21 53       	incd	r1		;
    6548:	30 41       	ret			

0000654a <port_is_isr_context>:
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
  return __msp430x_in_isr;
    654a:	5c 42 e8 51 	mov.b	&0x51e8,r12	;0x51e8

0000654e <.Loc.340.1>:
}
    654e:	30 41       	ret			

00006550 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6550:	32 c2       	dint			

00006552 <.Loc.348.1>:
  asm volatile("nop");
    6552:	03 43       	nop			

00006554 <.Loc.349.1>:
}
    6554:	03 43       	nop			
    6556:	30 41       	ret			

00006558 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6558:	03 43       	nop			

0000655a <.Loc.356.1>:
  _enable_interrupts();
    655a:	32 d2       	eint			
    655c:	03 43       	nop			

0000655e <.Loc.357.1>:
}
    655e:	03 43       	nop			
    6560:	30 41       	ret			

00006562 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6562:	03 43       	nop			
    6564:	30 41       	ret			

00006566 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6566:	03 43       	nop			
    6568:	30 41       	ret			

0000656a <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    656a:	32 c2       	dint			

0000656c <.Loc.381.1>:
  asm volatile("nop");
    656c:	03 43       	nop			

0000656e <.Loc.382.1>:
}
    656e:	03 43       	nop			
    6570:	30 41       	ret			

00006572 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    6572:	32 c2       	dint			

00006574 <.Loc.390.1>:
  asm volatile("nop");
    6574:	03 43       	nop			

00006576 <.Loc.391.1>:
}
    6576:	03 43       	nop			
    6578:	30 41       	ret			

0000657a <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    657a:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    657e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6580:	04 20       	jnz	$+10     	;abs 0x658a

00006582 <.Loc.79.2>:
    6582:	1c 42 b8 51 	mov	&0x51b8,r12	;0x51b8
    6586:	0c 93       	cmp	#0,	r12	;r3 As==00
    6588:	04 24       	jz	$+10     	;abs 0x6592

0000658a <.L19>:
    chSysHalt("SV#2");
    658a:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    658e:	b0 12 78 67 	call	#26488		;#0x6778

00006592 <.L21>:
  }
}
    6592:	03 43       	nop			
    6594:	30 41       	ret			

00006596 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6596:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    659a:	0c 93       	cmp	#0,	r12	;r3 As==00
    659c:	04 20       	jnz	$+10     	;abs 0x65a6

0000659e <.Loc.103.2>:
    659e:	1c 42 b8 51 	mov	&0x51b8,r12	;0x51b8
    65a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    65a4:	04 24       	jz	$+10     	;abs 0x65ae

000065a6 <.L27>:
    chSysHalt("SV#4");
    65a6:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    65aa:	b0 12 78 67 	call	#26488		;#0x6778

000065ae <.L28>:
  }
  _dbg_enter_lock();
    65ae:	92 43 b8 51 	mov	#1,	&0x51b8	;r3 As==01

000065b2 <.Loc.107.2>:
}
    65b2:	03 43       	nop			
    65b4:	30 41       	ret			

000065b6 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    65b6:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    65ba:	0c 93       	cmp	#0,	r12	;r3 As==00
    65bc:	05 20       	jnz	$+12     	;abs 0x65c8

000065be <.Loc.116.2>:
    65be:	1d 42 b8 51 	mov	&0x51b8,r13	;0x51b8
    65c2:	4c 43       	clr.b	r12		;
    65c4:	0c 9d       	cmp	r13,	r12	;
    65c6:	04 38       	jl	$+10     	;abs 0x65d0

000065c8 <.L30>:
    chSysHalt("SV#5");
    65c8:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    65cc:	b0 12 78 67 	call	#26488		;#0x6778

000065d0 <.L31>:
  }
  _dbg_leave_lock();
    65d0:	82 43 b8 51 	mov	#0,	&0x51b8	;r3 As==00

000065d4 <.Loc.120.2>:
}
    65d4:	03 43       	nop			
    65d6:	30 41       	ret			

000065d8 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    65d8:	1d 42 b6 51 	mov	&0x51b6,r13	;0x51b6
    65dc:	4c 43       	clr.b	r12		;
    65de:	0c 9d       	cmp	r13,	r12	;
    65e0:	04 34       	jge	$+10     	;abs 0x65ea

000065e2 <.Loc.129.2>:
    65e2:	1c 42 b8 51 	mov	&0x51b8,r12	;0x51b8
    65e6:	0c 93       	cmp	#0,	r12	;r3 As==00
    65e8:	04 24       	jz	$+10     	;abs 0x65f2

000065ea <.L33>:
    chSysHalt("SV#6");
    65ea:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    65ee:	b0 12 78 67 	call	#26488		;#0x6778

000065f2 <.L34>:
  }
  _dbg_enter_lock();
    65f2:	92 43 b8 51 	mov	#1,	&0x51b8	;r3 As==01

000065f6 <.Loc.133.2>:
}
    65f6:	03 43       	nop			
    65f8:	30 41       	ret			

000065fa <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    65fa:	1d 42 b6 51 	mov	&0x51b6,r13	;0x51b6
    65fe:	4c 43       	clr.b	r12		;
    6600:	0c 9d       	cmp	r13,	r12	;
    6602:	05 34       	jge	$+12     	;abs 0x660e

00006604 <.Loc.142.2>:
    6604:	1d 42 b8 51 	mov	&0x51b8,r13	;0x51b8
    6608:	4c 43       	clr.b	r12		;
    660a:	0c 9d       	cmp	r13,	r12	;
    660c:	04 38       	jl	$+10     	;abs 0x6616

0000660e <.L36>:
    chSysHalt("SV#7");
    660e:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    6612:	b0 12 78 67 	call	#26488		;#0x6778

00006616 <.L37>:
  }
  _dbg_leave_lock();
    6616:	82 43 b8 51 	mov	#0,	&0x51b8	;r3 As==00

0000661a <.Loc.146.2>:
}
    661a:	03 43       	nop			
    661c:	30 41       	ret			

0000661e <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    661e:	b0 12 62 65 	call	#25954		;#0x6562

00006622 <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6622:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    6626:	0c 93       	cmp	#0,	r12	;r3 As==00
    6628:	04 38       	jl	$+10     	;abs 0x6632

0000662a <.Loc.156.2>:
    662a:	1c 42 b8 51 	mov	&0x51b8,r12	;0x51b8
    662e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6630:	04 24       	jz	$+10     	;abs 0x663a

00006632 <.L39>:
    chSysHalt("SV#8");
    6632:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    6636:	b0 12 78 67 	call	#26488		;#0x6778

0000663a <.L40>:
  }
  nil.isr_cnt++;
    663a:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    663e:	1c 53       	inc	r12		;
    6640:	82 4c b6 51 	mov	r12,	&0x51b6	;

00006644 <.Loc.160.2>:
  port_unlock_from_isr();
    6644:	b0 12 66 65 	call	#25958		;#0x6566

00006648 <.Loc.161.2>:
}
    6648:	03 43       	nop			
    664a:	30 41       	ret			

0000664c <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    664c:	b0 12 62 65 	call	#25954		;#0x6562

00006650 <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6650:	1d 42 b6 51 	mov	&0x51b6,r13	;0x51b6
    6654:	4c 43       	clr.b	r12		;
    6656:	0c 9d       	cmp	r13,	r12	;
    6658:	04 34       	jge	$+10     	;abs 0x6662

0000665a <.Loc.171.2>:
    665a:	1c 42 b8 51 	mov	&0x51b8,r12	;0x51b8
    665e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6660:	04 24       	jz	$+10     	;abs 0x666a

00006662 <.L42>:
    chSysHalt("SV#9");
    6662:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    6666:	b0 12 78 67 	call	#26488		;#0x6778

0000666a <.L43>:
  }
  nil.isr_cnt--;
    666a:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    666e:	3c 53       	add	#-1,	r12	;r3 As==11
    6670:	82 4c b6 51 	mov	r12,	&0x51b6	;

00006674 <.Loc.175.2>:
  port_unlock_from_isr();
    6674:	b0 12 66 65 	call	#25958		;#0x6566

00006678 <.Loc.176.2>:
}
    6678:	03 43       	nop			
    667a:	30 41       	ret			

0000667c <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    667c:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    6680:	0c 93       	cmp	#0,	r12	;r3 As==00
    6682:	05 38       	jl	$+12     	;abs 0x668e

00006684 <.Loc.188.2>:
    6684:	1d 42 b8 51 	mov	&0x51b8,r13	;0x51b8
    6688:	4c 43       	clr.b	r12		;
    668a:	0c 9d       	cmp	r13,	r12	;
    668c:	04 38       	jl	$+10     	;abs 0x6696

0000668e <.L45>:
    chSysHalt("SV#10");
    668e:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    6692:	b0 12 78 67 	call	#26488		;#0x6778

00006696 <.L47>:
  }
}
    6696:	03 43       	nop			
    6698:	30 41       	ret			

0000669a <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    669a:	1c 42 b6 51 	mov	&0x51b6,r12	;0x51b6
    669e:	0c 93       	cmp	#0,	r12	;r3 As==00
    66a0:	05 20       	jnz	$+12     	;abs 0x66ac

000066a2 <.Loc.203.2>:
    66a2:	1d 42 b8 51 	mov	&0x51b8,r13	;0x51b8
    66a6:	4c 43       	clr.b	r12		;
    66a8:	0c 9d       	cmp	r13,	r12	;
    66aa:	04 38       	jl	$+10     	;abs 0x66b4

000066ac <.L49>:
    chSysHalt("SV#11");
    66ac:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    66b0:	b0 12 78 67 	call	#26488		;#0x6778

000066b4 <.L51>:
  }
}
    66b4:	03 43       	nop			
    66b6:	30 41       	ret			

000066b8 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    66b8:	21 82       	sub	#4,	r1	;r2 As==10

000066ba <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    66ba:	82 43 b6 51 	mov	#0,	&0x51b6	;r3 As==00

000066be <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    66be:	82 43 b8 51 	mov	#0,	&0x51b8	;r3 As==00

000066c2 <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    66c2:	b1 40 bc 51 	mov	#20924,	2(r1)	;#0x51bc
    66c6:	02 00 

000066c8 <.Loc.234.2>:
  tcp = nil_thd_configs;
    66c8:	b1 40 3c 51 	mov	#20796,	0(r1)	;#0x513c
    66cc:	00 00 

000066ce <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    66ce:	2d 3c       	jmp	$+92     	;abs 0x672a

000066d0 <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    66d0:	2c 41       	mov	@r1,	r12	;
    66d2:	2d 4c       	mov	@r12,	r13	;
    66d4:	1c 41 02 00 	mov	2(r1),	r12	;
    66d8:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

000066dc <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    66dc:	2c 41       	mov	@r1,	r12	;
    66de:	1c 4c 02 00 	mov	2(r12),	r12	;
    66e2:	0d 4c       	mov	r12,	r13	;
    66e4:	3d 50 f0 ff 	add	#-16,	r13	;#0xfff0
    66e8:	1c 41 02 00 	mov	2(r1),	r12	;
    66ec:	8c 4d 00 00 	mov	r13,	0(r12)	;
    66f0:	1c 41 02 00 	mov	2(r1),	r12	;
    66f4:	2c 4c       	mov	@r12,	r12	;
    66f6:	2d 41       	mov	@r1,	r13	;
    66f8:	1d 4d 06 00 	mov	6(r13),	r13	;
    66fc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6700:	1c 41 02 00 	mov	2(r1),	r12	;
    6704:	2c 4c       	mov	@r12,	r12	;
    6706:	2d 41       	mov	@r1,	r13	;
    6708:	1d 4d 08 00 	mov	8(r13),	r13	;
    670c:	8c 4d 02 00 	mov	r13,	2(r12)	;
    6710:	1c 41 02 00 	mov	2(r1),	r12	;
    6714:	2c 4c       	mov	@r12,	r12	;
    6716:	3d 40 ec 6b 	mov	#27628,	r13	;#0x6bec
    671a:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

0000671e <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    671e:	b1 50 10 00 	add	#16,	2(r1)	;#0x0010
    6722:	02 00 

00006724 <.Loc.247.2>:
    tcp++;
    6724:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    6728:	00 00 

0000672a <.L53>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    672a:	b1 90 cc 51 	cmp	#20940,	2(r1)	;#0x51cc
    672e:	02 00 
    6730:	cf 2b       	jnc	$-96     	;abs 0x66d0

00006732 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    6732:	1c 41 02 00 	mov	2(r1),	r12	;
    6736:	bc 40 00 44 	mov	#17408,	14(r12)	;#0x4400, 0x000e
    673a:	0e 00 

0000673c <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    673c:	b0 12 72 65 	call	#25970		;#0x6572
    6740:	b0 12 7a 65 	call	#25978		;#0x657a

00006744 <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    6744:	92 43 b8 51 	mov	#1,	&0x51b8	;r3 As==01

00006748 <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    6748:	b0 12 be 6b 	call	#27582		;#0x6bbe

0000674c <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    674c:	b0 12 16 65 	call	#25878		;#0x6516

00006750 <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    6750:	b2 40 bc 51 	mov	#20924,	&0x51b2	;#0x51bc
    6754:	b2 51 
    6756:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    675a:	82 4c b0 51 	mov	r12,	&0x51b0	;

0000675e <.Loc.275.2>:
  port_switch(nil.current, tp);
    675e:	1c 42 b0 51 	mov	&0x51b0,r12	;0x51b0
    6762:	1d 41 02 00 	mov	2(r1),	r13	;
    6766:	b0 12 de 6b 	call	#27614		;#0x6bde

0000676a <.Loc.276.2>:
  chSysUnlock();
    676a:	b0 12 b6 65 	call	#26038		;#0x65b6
    676e:	b0 12 58 65 	call	#25944		;#0x6558

00006772 <.Loc.277.2>:
}
    6772:	03 43       	nop			
    6774:	21 52       	add	#4,	r1	;r2 As==10
    6776:	30 41       	ret			

00006778 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    6778:	21 83       	decd	r1		;

0000677a <L0>:
    677a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000677e <.Loc.293.2>:

  port_disable();
    677e:	b0 12 6a 65 	call	#25962		;#0x656a

00006782 <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    6782:	a2 41 ba 51 	mov	@r1,	&0x51ba	;

00006786 <.L56>:

  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    6786:	ff 3f       	jmp	$+0      	;abs 0x6786

00006788 <chSysTimerHandlerI>:
    6788:	21 83       	decd	r1		;

0000678a <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    678a:	b0 12 7c 66 	call	#26236		;#0x667c

0000678e <.Loc.321.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    678e:	b1 40 bc 51 	mov	#20924,	0(r1)	;#0x51bc
    6792:	00 00 

00006794 <.Loc.322.2>:
  nil.systime++;
    6794:	1c 42 b4 51 	mov	&0x51b4,r12	;0x51b4
    6798:	1c 53       	inc	r12		;
    679a:	82 4c b4 51 	mov	r12,	&0x51b4	;

0000679e <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    679e:	2c 41       	mov	@r1,	r12	;
    67a0:	1c 4c 08 00 	mov	8(r12),	r12	;
    67a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    67a6:	25 24       	jz	$+76     	;abs 0x67f2

000067a8 <.Loc.330.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    67a8:	2c 41       	mov	@r1,	r12	;
    67aa:	1c 4c 08 00 	mov	8(r12),	r12	;
    67ae:	3c 53       	add	#-1,	r12	;r3 As==11
    67b0:	2d 41       	mov	@r1,	r13	;
    67b2:	8d 4c 08 00 	mov	r12,	8(r13)	;
    67b6:	0c 93       	cmp	#0,	r12	;r3 As==00
    67b8:	1c 20       	jnz	$+58     	;abs 0x67f2

000067ba <.Loc.334.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    67ba:	2c 41       	mov	@r1,	r12	;
    67bc:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    67c0:	7c 90 03 00 	cmp.b	#3,	r12	;
    67c4:	08 20       	jnz	$+18     	;abs 0x67d6

000067c6 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    67c6:	2c 41       	mov	@r1,	r12	;
    67c8:	1c 4c 04 00 	mov	4(r12),	r12	;
    67cc:	2d 4c       	mov	@r12,	r13	;
    67ce:	1d 53       	inc	r13		;
    67d0:	8c 4d 00 00 	mov	r13,	0(r12)	;
    67d4:	0a 3c       	jmp	$+22     	;abs 0x67ea

000067d6 <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    67d6:	2c 41       	mov	@r1,	r12	;
    67d8:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    67dc:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    67de:	05 20       	jnz	$+12     	;abs 0x67ea

000067e0 <.Loc.338.2>:
          *tp->u1.trp = NULL;
    67e0:	2c 41       	mov	@r1,	r12	;
    67e2:	1c 4c 04 00 	mov	4(r12),	r12	;
    67e6:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000067ea <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    67ea:	3d 43       	mov	#-1,	r13	;r3 As==11
    67ec:	2c 41       	mov	@r1,	r12	;
    67ee:	b0 12 8e 68 	call	#26766		;#0x688e

000067f2 <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    67f2:	b0 12 fa 65 	call	#26106		;#0x65fa
    67f6:	b0 12 66 65 	call	#25958		;#0x6566

000067fa <.Loc.347.2>:
    tp++;
    67fa:	b1 50 10 00 	add	#16,	0(r1)	;#0x0010
    67fe:	00 00 

00006800 <.Loc.348.2>:
    chSysLockFromISR();
    6800:	b0 12 62 65 	call	#25954		;#0x6562
    6804:	b0 12 d8 65 	call	#26072		;#0x65d8

00006808 <.Loc.349.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    6808:	b1 90 cc 51 	cmp	#20940,	0(r1)	;#0x51cc
    680c:	00 00 
    680e:	c7 2b       	jnc	$-112    	;abs 0x679e

00006810 <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    6810:	03 43       	nop			
    6812:	21 53       	incd	r1		;
    6814:	30 41       	ret			

00006816 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    6816:	21 83       	decd	r1		;

00006818 <L0>:

  syssts_t sts = port_get_irq_status();
    6818:	b0 12 1e 65 	call	#25886		;#0x651e
    681c:	81 4c 00 00 	mov	r12,	0(r1)	;

00006820 <.Loc.449.2>:
  if (port_irq_enabled(sts)) {
    6820:	2c 41       	mov	@r1,	r12	;
    6822:	b0 12 2c 65 	call	#25900		;#0x652c
    6826:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    682a:	0c 93       	cmp	#0,	r12	;r3 As==00
    682c:	0f 24       	jz	$+32     	;abs 0x684c

0000682e <.Loc.450.2>:
    if (port_is_isr_context()) {
    682e:	b0 12 4a 65 	call	#25930		;#0x654a
    6832:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6836:	0c 93       	cmp	#0,	r12	;r3 As==00
    6838:	05 24       	jz	$+12     	;abs 0x6844

0000683a <.Loc.451.2>:
      chSysLockFromISR();
    683a:	b0 12 62 65 	call	#25954		;#0x6562
    683e:	b0 12 d8 65 	call	#26072		;#0x65d8
    6842:	04 3c       	jmp	$+10     	;abs 0x684c

00006844 <.L70>:
    }
    else {
      chSysLock();
    6844:	b0 12 50 65 	call	#25936		;#0x6550
    6848:	b0 12 96 65 	call	#26006		;#0x6596

0000684c <.L69>:
    }
  }
  return sts;
    684c:	2c 41       	mov	@r1,	r12	;

0000684e <.Loc.458.2>:
}
    684e:	21 53       	incd	r1		;
    6850:	30 41       	ret			

00006852 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
    6852:	21 83       	decd	r1		;

00006854 <L0>:
    6854:	81 4c 00 00 	mov	r12,	0(r1)	;

00006858 <.Loc.471.2>:

  if (port_irq_enabled(sts)) {
    6858:	2c 41       	mov	@r1,	r12	;
    685a:	b0 12 2c 65 	call	#25900		;#0x652c
    685e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6862:	0c 93       	cmp	#0,	r12	;r3 As==00
    6864:	11 24       	jz	$+36     	;abs 0x6888

00006866 <.Loc.472.2>:
    if (port_is_isr_context()) {
    6866:	b0 12 4a 65 	call	#25930		;#0x654a
    686a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    686e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6870:	05 24       	jz	$+12     	;abs 0x687c

00006872 <.Loc.473.2>:
      chSysUnlockFromISR();
    6872:	b0 12 fa 65 	call	#26106		;#0x65fa
    6876:	b0 12 66 65 	call	#25958		;#0x6566

0000687a <.Loc.480.2>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    687a:	06 3c       	jmp	$+14     	;abs 0x6888

0000687c <.L74>:
      chSchRescheduleS();
    687c:	b0 12 08 69 	call	#26888		;#0x6908

00006880 <.Loc.477.2>:
      chSysUnlock();
    6880:	b0 12 b6 65 	call	#26038		;#0x65b6
    6884:	b0 12 58 65 	call	#25944		;#0x6558

00006888 <.L75>:
}
    6888:	03 43       	nop			
    688a:	21 53       	incd	r1		;
    688c:	30 41       	ret			

0000688e <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    688e:	21 82       	sub	#4,	r1	;r2 As==10

00006890 <L0>:
    6890:	81 4c 02 00 	mov	r12,	2(r1)	;
    6894:	81 4d 00 00 	mov	r13,	0(r1)	;

00006898 <.Loc.536.2>:

  chDbgCheckClassI();
    6898:	b0 12 7c 66 	call	#26236		;#0x667c

0000689c <.Loc.541.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    689c:	1c 41 02 00 	mov	2(r1),	r12	;
    68a0:	ac 41 04 00 	mov	@r1,	4(r12)	;

000068a4 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    68a4:	1c 41 02 00 	mov	2(r1),	r12	;
    68a8:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000068ac <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    68ac:	1c 41 02 00 	mov	2(r1),	r12	;
    68b0:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

000068b4 <.Loc.544.2>:
  if (tp < nil.next) {
    68b4:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    68b8:	81 9c 02 00 	cmp	r12,	2(r1)	;
    68bc:	03 2c       	jc	$+8      	;abs 0x68c4

000068be <.Loc.545.2>:
    nil.next = tp;
    68be:	92 41 02 00 	mov	2(r1),	&0x51b2	;
    68c2:	b2 51 

000068c4 <.L77>:
  }
  return tp;
    68c4:	1c 41 02 00 	mov	2(r1),	r12	;

000068c8 <.Loc.548.2>:
}
    68c8:	21 52       	add	#4,	r1	;r2 As==10
    68ca:	30 41       	ret			

000068cc <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    68cc:	1d 42 b0 51 	mov	&0x51b0,r13	;0x51b0
    68d0:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    68d4:	0c ed       	xor	r13,	r12	;
    68d6:	0d 43       	clr	r13		;
    68d8:	0d 8c       	sub	r12,	r13	;
    68da:	0c dd       	bis	r13,	r12	;
    68dc:	5c 03       	rrum	#1,	r12	;
    68de:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    68e2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000068e6 <.Loc.566.2>:
}
    68e6:	30 41       	ret			

000068e8 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    68e8:	21 83       	decd	r1		;

000068ea <.LCFI8>:
  thread_t *otp = nil.current;
    68ea:	91 42 b0 51 	mov	&0x51b0,0(r1)	;0x51b0
    68ee:	00 00 

000068f0 <.Loc.578.2>:

  nil.current = nil.next;
    68f0:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    68f4:	82 4c b0 51 	mov	r12,	&0x51b0	;

000068f8 <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    68f8:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    68fc:	2d 41       	mov	@r1,	r13	;
    68fe:	b0 12 de 6b 	call	#27614		;#0x6bde

00006902 <.Loc.583.2>:
}
    6902:	03 43       	nop			
    6904:	21 53       	incd	r1		;
    6906:	30 41       	ret			

00006908 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    6908:	b0 12 9a 66 	call	#26266		;#0x669a

0000690c <.Loc.594.2>:

  if (chSchIsRescRequiredI()) {
    690c:	1d 42 b0 51 	mov	&0x51b0,r13	;0x51b0
    6910:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    6914:	0d 9c       	cmp	r12,	r13	;
    6916:	02 24       	jz	$+6      	;abs 0x691c

00006918 <.Loc.595.2>:
    chSchDoReschedule();
    6918:	b0 12 e8 68 	call	#26856		;#0x68e8

0000691c <.L84>:
  }
}
    691c:	03 43       	nop			
    691e:	30 41       	ret			

00006920 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    6920:	31 82       	sub	#8,	r1	;r2 As==11

00006922 <.LCFI9>:
    6922:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    6926:	81 4d 00 00 	mov	r13,	0(r1)	;

0000692a <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    692a:	91 42 b0 51 	mov	&0x51b0,4(r1)	;0x51b0
    692e:	04 00 

00006930 <.Loc.619.2>:

  chDbgCheckClassS();
    6930:	b0 12 9a 66 	call	#26266		;#0x669a

00006934 <.Loc.625.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    6934:	1c 41 04 00 	mov	4(r1),	r12	;
    6938:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    693c:	02 00 

0000693e <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    693e:	1c 41 04 00 	mov	4(r1),	r12	;
    6942:	ac 41 08 00 	mov	@r1,	8(r12)	;

00006946 <.Loc.664.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    6946:	b1 40 bc 51 	mov	#20924,	6(r1)	;#0x51bc
    694a:	06 00 

0000694c <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    694c:	1c 41 06 00 	mov	6(r1),	r12	;
    6950:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    6954:	0c 93       	cmp	#0,	r12	;r3 As==00
    6956:	12 20       	jnz	$+38     	;abs 0x697c

00006958 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    6958:	92 41 06 00 	mov	6(r1),	&0x51b2	;
    695c:	b2 51 
    695e:	1c 42 b2 51 	mov	&0x51b2,r12	;0x51b2
    6962:	82 4c b0 51 	mov	r12,	&0x51b0	;

00006966 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    6966:	1d 41 04 00 	mov	4(r1),	r13	;
    696a:	1c 41 06 00 	mov	6(r1),	r12	;
    696e:	b0 12 de 6b 	call	#27614		;#0x6bde

00006972 <.Loc.673.2>:
      return nil.current->u1.msg;
    6972:	1c 42 b0 51 	mov	&0x51b0,r12	;0x51b0
    6976:	1c 4c 04 00 	mov	4(r12),	r12	;
    697a:	04 3c       	jmp	$+10     	;abs 0x6984

0000697c <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    697c:	b1 50 10 00 	add	#16,	6(r1)	;#0x0010
    6980:	06 00 

00006982 <.Loc.667.2>:
    if (NIL_THD_IS_READY(ntp)) {
    6982:	e4 3f       	jmp	$-54     	;abs 0x694c

00006984 <.L89>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    6984:	31 52       	add	#8,	r1	;r2 As==11
    6986:	30 41       	ret			

00006988 <chThdSuspendTimeoutS>:
 *                      .
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    6988:	21 82       	sub	#4,	r1	;r2 As==10

0000698a <.LCFI10>:
    698a:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

0000698c <L0>:
    698c:	02 00       	mova	@r0,	r2	;
    698e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006992 <.Loc.701.2>:

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    6992:	1d 42 b0 51 	mov	&0x51b0,r13	;0x51b0
    6996:	1c 41 02 00 	mov	2(r1),	r12	;
    699a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000699e <.Loc.702.2>:
  nil.current->u1.trp = trp;
    699e:	1c 42 b0 51 	mov	&0x51b0,r12	;0x51b0
    69a2:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    69a6:	04 00 

000069a8 <.Loc.703.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    69a8:	2d 41       	mov	@r1,	r13	;
    69aa:	6c 43       	mov.b	#2,	r12	;r3 As==10
    69ac:	b0 12 20 69 	call	#26912		;#0x6920

000069b0 <.Loc.704.2>:
}
    69b0:	21 52       	add	#4,	r1	;r2 As==10
    69b2:	30 41       	ret			

000069b4 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    69b4:	31 80 06 00 	sub	#6,	r1	;

000069b8 <.LCFI11>:
    69b8:	81 4c 02 00 	mov	r12,	2(r1)	;
    69bc:	81 4d 00 00 	mov	r13,	0(r1)	;

000069c0 <.Loc.718.2>:

  if (*trp != NULL) {
    69c0:	1c 41 02 00 	mov	2(r1),	r12	;
    69c4:	2c 4c       	mov	@r12,	r12	;
    69c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    69c8:	0d 24       	jz	$+28     	;abs 0x69e4

000069ca <.LBB3>:
    thread_reference_t tr = *trp;
    69ca:	1c 41 02 00 	mov	2(r1),	r12	;
    69ce:	a1 4c 04 00 	mov	@r12,	4(r1)	;

000069d2 <.Loc.723.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    69d2:	1c 41 02 00 	mov	2(r1),	r12	;
    69d6:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000069da <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    69da:	2d 41       	mov	@r1,	r13	;
    69dc:	1c 41 04 00 	mov	4(r1),	r12	;
    69e0:	b0 12 8e 68 	call	#26766		;#0x688e

000069e4 <.L94>:
  }
}
    69e4:	03 43       	nop			
    69e6:	31 50 06 00 	add	#6,	r1	;
    69ea:	30 41       	ret			

000069ec <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    69ec:	21 83       	decd	r1		;

000069ee <.LCFI12>:
    69ee:	81 4c 00 00 	mov	r12,	0(r1)	;

000069f2 <.Loc.737.2>:

  chSysLock();
    69f2:	b0 12 50 65 	call	#25936		;#0x6550
    69f6:	b0 12 96 65 	call	#26006		;#0x6596

000069fa <.Loc.738.2>:
  chThdSleepS(timeout);
    69fa:	2d 41       	mov	@r1,	r13	;
    69fc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    69fe:	b0 12 20 69 	call	#26912		;#0x6920

00006a02 <.Loc.739.2>:
  chSysUnlock();
    6a02:	b0 12 b6 65 	call	#26038		;#0x65b6
    6a06:	b0 12 58 65 	call	#25944		;#0x6558

00006a0a <.Loc.740.2>:
}
    6a0a:	03 43       	nop			
    6a0c:	21 53       	incd	r1		;
    6a0e:	30 41       	ret			

00006a10 <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    6a10:	31 80 06 00 	sub	#6,	r1	;

00006a14 <.LCFI14>:
    6a14:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a18:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a1c <.Loc.780.2>:
  msg_t msg;

  chSysLock();
    6a1c:	b0 12 50 65 	call	#25936		;#0x6550
    6a20:	b0 12 96 65 	call	#26006		;#0x6596

00006a24 <.Loc.781.2>:
  msg = chSemWaitTimeoutS(sp, timeout);
    6a24:	2d 41       	mov	@r1,	r13	;
    6a26:	1c 41 02 00 	mov	2(r1),	r12	;
    6a2a:	b0 12 44 6a 	call	#27204		;#0x6a44
    6a2e:	81 4c 04 00 	mov	r12,	4(r1)	;

00006a32 <.Loc.782.2>:
  chSysUnlock();
    6a32:	b0 12 b6 65 	call	#26038		;#0x65b6
    6a36:	b0 12 58 65 	call	#25944		;#0x6558

00006a3a <.Loc.784.2>:

  return msg;
    6a3a:	1c 41 04 00 	mov	4(r1),	r12	;

00006a3e <.Loc.785.2>:
}
    6a3e:	31 50 06 00 	add	#6,	r1	;
    6a42:	30 41       	ret			

00006a44 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    6a44:	31 80 06 00 	sub	#6,	r1	;

00006a48 <.LCFI15>:
    6a48:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a4c:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a50 <.Loc.808.2>:

  chDbgCheckClassS();
    6a50:	b0 12 9a 66 	call	#26266		;#0x669a

00006a54 <.Loc.813.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    6a54:	1c 41 02 00 	mov	2(r1),	r12	;
    6a58:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006a5c <.Loc.814.2>:
  if (cnt <= (cnt_t)0) {
    6a5c:	4c 43       	clr.b	r12		;
    6a5e:	1c 91 04 00 	cmp	4(r1),	r12	;
    6a62:	17 38       	jl	$+48     	;abs 0x6a92

00006a64 <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    6a64:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6a68:	02 20       	jnz	$+6      	;abs 0x6a6e

00006a6a <.Loc.816.2>:
      return MSG_TIMEOUT;
    6a6a:	3c 43       	mov	#-1,	r12	;r3 As==11
    6a6c:	1a 3c       	jmp	$+54     	;abs 0x6aa2

00006a6e <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    6a6e:	1d 41 04 00 	mov	4(r1),	r13	;
    6a72:	3d 53       	add	#-1,	r13	;r3 As==11
    6a74:	1c 41 02 00 	mov	2(r1),	r12	;
    6a78:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006a7c <.Loc.819.2>:
    nil.current->u1.semp = sp;
    6a7c:	1c 42 b0 51 	mov	&0x51b0,r12	;0x51b0
    6a80:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6a84:	04 00 

00006a86 <.Loc.820.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    6a86:	2d 41       	mov	@r1,	r13	;
    6a88:	7c 40 03 00 	mov.b	#3,	r12	;
    6a8c:	b0 12 20 69 	call	#26912		;#0x6920
    6a90:	08 3c       	jmp	$+18     	;abs 0x6aa2

00006a92 <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    6a92:	1d 41 04 00 	mov	4(r1),	r13	;
    6a96:	3d 53       	add	#-1,	r13	;r3 As==11
    6a98:	1c 41 02 00 	mov	2(r1),	r12	;
    6a9c:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006aa0 <.Loc.823.2>:
  return MSG_OK;
    6aa0:	4c 43       	clr.b	r12		;

00006aa2 <.L102>:
}
    6aa2:	31 50 06 00 	add	#6,	r1	;
    6aa6:	30 41       	ret			

00006aa8 <chSemSignal>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
    6aa8:	21 83       	decd	r1		;

00006aaa <.LCFI16>:
    6aaa:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

00006aac <L0>:
	...

00006aae <.Loc.835.2>:

  chSysLock();
    6aae:	b0 12 50 65 	call	#25936		;#0x6550
    6ab2:	b0 12 96 65 	call	#26006		;#0x6596

00006ab6 <.Loc.836.2>:
  chSemSignalI(sp);
    6ab6:	2c 41       	mov	@r1,	r12	;
    6ab8:	b0 12 ce 6a 	call	#27342		;#0x6ace

00006abc <.Loc.837.2>:
  chSchRescheduleS();
    6abc:	b0 12 08 69 	call	#26888		;#0x6908

00006ac0 <.Loc.838.2>:
  chSysUnlock();
    6ac0:	b0 12 b6 65 	call	#26038		;#0x65b6
    6ac4:	b0 12 58 65 	call	#25944		;#0x6558

00006ac8 <.Loc.839.2>:
}
    6ac8:	03 43       	nop			
    6aca:	21 53       	incd	r1		;
    6acc:	30 41       	ret			

00006ace <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    6ace:	21 82       	sub	#4,	r1	;r2 As==10

00006ad0 <.LCFI17>:
    6ad0:	81 4c 00 00 	mov	r12,	0(r1)	;

00006ad4 <.Loc.854.2>:

  chDbgCheckClassI();
    6ad4:	b0 12 7c 66 	call	#26236		;#0x667c

00006ad8 <.Loc.857.2>:
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    6ad8:	2c 41       	mov	@r1,	r12	;
    6ada:	2c 4c       	mov	@r12,	r12	;
    6adc:	1c 53       	inc	r12		;
    6ade:	2d 41       	mov	@r1,	r13	;
    6ae0:	8d 4c 00 00 	mov	r12,	0(r13)	;
    6ae4:	4d 43       	clr.b	r13		;
    6ae6:	0d 9c       	cmp	r12,	r13	;
    6ae8:	13 38       	jl	$+40     	;abs 0x6b10

00006aea <.LBB4>:
    thread_reference_t tr = nil.threads;
    6aea:	b1 40 bc 51 	mov	#20924,	2(r1)	;#0x51bc
    6aee:	02 00 

00006af0 <.L107>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    6af0:	1c 41 02 00 	mov	2(r1),	r12	;
    6af4:	1c 4c 04 00 	mov	4(r12),	r12	;
    6af8:	2c 91       	cmp	@r1,	r12	;
    6afa:	06 20       	jnz	$+14     	;abs 0x6b08

00006afc <.Loc.865.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        (void) chSchReadyI(tr, MSG_OK);
    6afc:	4d 43       	clr.b	r13		;
    6afe:	1c 41 02 00 	mov	2(r1),	r12	;
    6b02:	b0 12 8e 68 	call	#26766		;#0x688e

00006b06 <.Loc.866.2>:
        return;
    6b06:	04 3c       	jmp	$+10     	;abs 0x6b10

00006b08 <.L106>:
      }
      tr++;
    6b08:	b1 50 10 00 	add	#16,	2(r1)	;#0x0010
    6b0c:	02 00 

00006b0e <.Loc.861.2>:
      if (tr->u1.semp == sp) {
    6b0e:	f0 3f       	jmp	$-30     	;abs 0x6af0

00006b10 <.L104>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    6b10:	21 52       	add	#4,	r1	;r2 As==10
    6b12:	30 41       	ret			

00006b14 <port_lock>:
  _disable_interrupts();
    6b14:	32 c2       	dint			

00006b16 <.Loc.348.1>:
  asm volatile("nop");
    6b16:	03 43       	nop			

00006b18 <L0>:
}
    6b18:	03 43       	nop			
    6b1a:	30 41       	ret			

00006b1c <port_unlock>:
  asm volatile("nop");
    6b1c:	03 43       	nop			

00006b1e <.Loc.356.1>:
  _enable_interrupts();
    6b1e:	32 d2       	eint			
    6b20:	03 43       	nop			

00006b22 <.Loc.357.1>:
}
    6b22:	03 43       	nop			
    6b24:	30 41       	ret			

00006b26 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    6b26:	31 80 06 00 	sub	#6,	r1	;

00006b2a <.LCFI0>:
    6b2a:	81 4c 02 00 	mov	r12,	2(r1)	;
    6b2e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006b32 <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    6b32:	b0 12 7c 66 	call	#26236		;#0x667c

00006b36 <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    6b36:	2c 41       	mov	@r1,	r12	;
    6b38:	1c 51 02 00 	add	2(r1),	r12	;
    6b3c:	0d 4c       	mov	r12,	r13	;
    6b3e:	3d 53       	add	#-1,	r13	;r3 As==11
    6b40:	4c 43       	clr.b	r12		;
    6b42:	2c 81       	sub	@r1,	r12	;
    6b44:	0e 4d       	mov	r13,	r14	;
    6b46:	0e fc       	and	r12,	r14	;
    6b48:	81 4e 02 00 	mov	r14,	2(r1)	;

00006b4c <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    6b4c:	1c 42 dc 51 	mov	&0x51dc,r12	;0x51dc
    6b50:	2c 51       	add	@r1,	r12	;
    6b52:	0d 4c       	mov	r12,	r13	;
    6b54:	3d 53       	add	#-1,	r13	;r3 As==11
    6b56:	4c 43       	clr.b	r12		;
    6b58:	2c 81       	sub	@r1,	r12	;
    6b5a:	0c fd       	and	r13,	r12	;
    6b5c:	81 4c 04 00 	mov	r12,	4(r1)	;

00006b60 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    6b60:	1c 42 de 51 	mov	&0x51de,r12	;0x51de
    6b64:	1d 41 04 00 	mov	4(r1),	r13	;
    6b68:	0c 8d       	sub	r13,	r12	;
    6b6a:	1c 91 02 00 	cmp	2(r1),	r12	;
    6b6e:	02 2c       	jc	$+6      	;abs 0x6b74

00006b70 <.Loc.118.2>:
    return NULL;
    6b70:	4c 43       	clr.b	r12		;
    6b72:	08 3c       	jmp	$+18     	;abs 0x6b84

00006b74 <.L5>:
  }
  nextmem = p + size;
    6b74:	1c 41 04 00 	mov	4(r1),	r12	;
    6b78:	1c 51 02 00 	add	2(r1),	r12	;
    6b7c:	82 4c dc 51 	mov	r12,	&0x51dc	;

00006b80 <.Loc.122.2>:

  return p;
    6b80:	1c 41 04 00 	mov	4(r1),	r12	;

00006b84 <.L6>:
}
    6b84:	31 50 06 00 	add	#6,	r1	;
    6b88:	30 41       	ret			

00006b8a <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    6b8a:	31 80       	sub,		r1	;Warning: disassembly unreliable - not enough bytes available

00006b8c <L0>:
    6b8c:	06 00       	mova	@r0,	r6	;

00006b8e <.LCFI1>:
    6b8e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6b92:	81 4d 00 00 	mov	r13,	0(r1)	;

00006b96 <.Loc.140.2>:
  void *p;

  chSysLock();
    6b96:	b0 12 14 6b 	call	#27412		;#0x6b14
    6b9a:	b0 12 96 65 	call	#26006		;#0x6596

00006b9e <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    6b9e:	2d 41       	mov	@r1,	r13	;
    6ba0:	1c 41 02 00 	mov	2(r1),	r12	;
    6ba4:	b0 12 26 6b 	call	#27430		;#0x6b26
    6ba8:	81 4c 04 00 	mov	r12,	4(r1)	;

00006bac <.Loc.142.2>:
  chSysUnlock();
    6bac:	b0 12 b6 65 	call	#26038		;#0x65b6
    6bb0:	b0 12 1c 6b 	call	#27420		;#0x6b1c

00006bb4 <.Loc.144.2>:

  return p;
    6bb4:	1c 41 04 00 	mov	4(r1),	r12	;

00006bb8 <.Loc.145.2>:
}
    6bb8:	31 50 06 00 	add	#6,	r1	;
    6bbc:	30 41       	ret			

00006bbe <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    6bbe:	b2 40 8a 6b 	mov	#27530,	&0x51e0	;#0x6b8a
    6bc2:	e0 51 

00006bc4 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6bc4:	82 43 e2 51 	mov	#0,	&0x51e2	;r3 As==00

00006bc8 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    6bc8:	82 43 e4 51 	mov	#0,	&0x51e4	;r3 As==00

00006bcc <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    6bcc:	92 43 e6 51 	mov	#1,	&0x51e6	;r3 As==01

00006bd0 <.Loc.117.1>:
#endif
}
    6bd0:	03 43       	nop			
    6bd2:	30 41       	ret			

00006bd4 <port_unlock>:
  asm volatile("nop");
    6bd4:	03 43       	nop			

00006bd6 <.Loc.356.1>:
  _enable_interrupts();
    6bd6:	32 d2       	eint			
    6bd8:	03 43       	nop			

00006bda <.Loc.357.1>:
}
    6bda:	03 43       	nop			
    6bdc:	30 41       	ret			

00006bde <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6bde:	6a 15       	pushm	#7,	r10	;16-bit words

00006be0 <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    6be0:	8d 41 00 00 	mov	r1,	0(r13)	;

00006be4 <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    6be4:	21 4c       	mov	@r12,	r1	;

00006be6 <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    6be6:	64 17       	popm	#7,	r10	;16-bit words

00006be8 <.Loc.83.2>:
  asm volatile ("ret");
    6be8:	30 41       	ret			

00006bea <.Loc.85.2>:
#endif
}
    6bea:	03 43       	nop			

00006bec <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    6bec:	b0 12 b6 65 	call	#26038		;#0x65b6
    6bf0:	b0 12 d4 6b 	call	#27604		;#0x6bd4

00006bf4 <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    6bf4:	0c 45       	mov	r5,	r12	;

00006bf6 <.Loc.101.2>:
  asm volatile ("call R4");
    6bf6:	84 12       	call	r4		;

00006bf8 <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    6bf8:	4c 43       	clr.b	r12		;
    6bfa:	b0 12 78 67 	call	#26488		;#0x6778

00006bfe <.Loc.109.2>:
#endif
}
    6bfe:	03 43       	nop			
    6c00:	30 41       	ret			

00006c02 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    6c02:	31 82       	sub	#8,	r1	;r2 As==11

00006c04 <.LCFI0>:
    6c04:	81 4c 02 00 	mov	r12,	2(r1)	;
    6c08:	81 4d 00 00 	mov	r13,	0(r1)	;

00006c0c <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    6c0c:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6c10:	04 00 

00006c12 <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    6c12:	1c 41 02 00 	mov	2(r1),	r12	;
    6c16:	2c 4c       	mov	@r12,	r12	;
    6c18:	0c 93       	cmp	#0,	r12	;r3 As==00
    6c1a:	1d 34       	jge	$+60     	;abs 0x6c56

00006c1c <.LBB2>:
    thread_t *tp = nil.threads;
    6c1c:	b1 40 bc 51 	mov	#20924,	6(r1)	;#0x51bc
    6c20:	06 00 

00006c22 <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6c22:	1c 41 06 00 	mov	6(r1),	r12	;
    6c26:	1c 4c 04 00 	mov	4(r12),	r12	;
    6c2a:	1c 91 04 00 	cmp	4(r1),	r12	;
    6c2e:	0f 20       	jnz	$+32     	;abs 0x6c4e

00006c30 <.Loc.67.1>:
        sp->cnt++;
    6c30:	1c 41 04 00 	mov	4(r1),	r12	;
    6c34:	2c 4c       	mov	@r12,	r12	;
    6c36:	1c 53       	inc	r12		;
    6c38:	0d 4c       	mov	r12,	r13	;
    6c3a:	1c 41 04 00 	mov	4(r1),	r12	;
    6c3e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006c42 <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    6c42:	2d 41       	mov	@r1,	r13	;
    6c44:	1c 41 06 00 	mov	6(r1),	r12	;
    6c48:	b0 12 8e 68 	call	#26766		;#0x688e

00006c4c <.Loc.72.1>:
        return;
    6c4c:	04 3c       	jmp	$+10     	;abs 0x6c56

00006c4e <.L3>:
      }
      tp++;
    6c4e:	b1 50 10 00 	add	#16,	6(r1)	;#0x0010
    6c52:	06 00 

00006c54 <.Loc.66.1>:
      if (tp->u1.semp == sp) {
    6c54:	e6 3f       	jmp	$-50     	;abs 0x6c22

00006c56 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    6c56:	31 52       	add	#8,	r1	;r2 As==11
    6c58:	30 41       	ret			

00006c5a <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    6c5a:	03 43       	nop			
    6c5c:	30 41       	ret			

00006c5e <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    6c5e:	b0 12 5a 6c 	call	#27738		;#0x6c5a

00006c62 <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    6c62:	b0 12 66 77 	call	#30566		;#0x7766

00006c66 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    6c66:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    6c6a:	b0 12 34 7f 	call	#32564		;#0x7f34

00006c6e <.Loc.83.2>:
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    6c6e:	b0 12 04 73 	call	#29444		;#0x7304

00006c72 <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    6c72:	b0 12 3c 76 	call	#30268		;#0x763c

00006c76 <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    6c76:	b0 12 e2 90 	call	#-28446	;#0x90e2

00006c7a <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    6c7a:	b0 12 82 6c 	call	#27778		;#0x6c82

00006c7e <.Loc.145.2>:
#endif
}
    6c7e:	03 43       	nop			
    6c80:	30 41       	ret			

00006c82 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    6c82:	b0 12 00 78 	call	#30720		;#0x7800

00006c86 <.Loc.63.2>:
}
    6c86:	03 43       	nop			
    6c88:	30 41       	ret			

00006c8a <port_lock>:
  _disable_interrupts();
    6c8a:	32 c2       	dint			

00006c8c <.Loc.348.1>:
  asm volatile("nop");
    6c8c:	03 43       	nop			

00006c8e <.Loc.349.1>:
}
    6c8e:	03 43       	nop			
    6c90:	30 41       	ret			

00006c92 <port_unlock>:
  asm volatile("nop");
    6c92:	03 43       	nop			

00006c94 <.Loc.356.1>:
  _enable_interrupts();
    6c94:	32 d2       	eint			
    6c96:	03 43       	nop			

00006c98 <.Loc.357.1>:
}
    6c98:	03 43       	nop			
    6c9a:	30 41       	ret			

00006c9c <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6c9c:	b0 12 8a 6c 	call	#27786		;#0x6c8a
    6ca0:	b0 12 96 65 	call	#26006		;#0x6596

00006ca4 <.Loc.505.2>:
}
    6ca4:	03 43       	nop			
    6ca6:	30 41       	ret			

00006ca8 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6ca8:	b0 12 b6 65 	call	#26038		;#0x65b6
    6cac:	b0 12 92 6c 	call	#27794		;#0x6c92

00006cb0 <.Loc.516.2>:
}
    6cb0:	03 43       	nop			
    6cb2:	30 41       	ret			

00006cb4 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6cb4:	1c 42 b4 51 	mov	&0x51b4,r12	;0x51b4

00006cb8 <.Loc.630.2>:
}
    6cb8:	30 41       	ret			

00006cba <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6cba:	21 83       	decd	r1		;

00006cbc <.LCFI0>:
    6cbc:	81 4c 00 00 	mov	r12,	0(r1)	;

00006cc0 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6cc0:	2c 41       	mov	@r1,	r12	;
    6cc2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006cc6 <.Loc.768.2>:
}
    6cc6:	03 43       	nop			
    6cc8:	21 53       	incd	r1		;
    6cca:	30 41       	ret			

00006ccc <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6ccc:	21 82       	sub	#4,	r1	;r2 As==10

00006cce <.LCFI1>:
    6cce:	81 4c 02 00 	mov	r12,	2(r1)	;
    6cd2:	81 4d 00 00 	mov	r13,	0(r1)	;

00006cd6 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6cd6:	1c 41 02 00 	mov	2(r1),	r12	;
    6cda:	2d 41       	mov	@r1,	r13	;
    6cdc:	b0 12 44 6a 	call	#27204		;#0x6a44

00006ce0 <.Loc.797.2>:
}
    6ce0:	21 52       	add	#4,	r1	;r2 As==10
    6ce2:	30 41       	ret			

00006ce4 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6ce4:	31 82       	sub	#8,	r1	;r2 As==11

00006ce6 <.LCFI2>:
    6ce6:	81 4c 06 00 	mov	r12,	6(r1)	;
    6cea:	81 4d 04 00 	mov	r13,	4(r1)	;
    6cee:	81 4e 02 00 	mov	r14,	2(r1)	;
    6cf2:	81 4f 00 00 	mov	r15,	0(r1)	;

00006cf6 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6cf6:	1c 41 06 00 	mov	6(r1),	r12	;
    6cfa:	b0 12 ba 6c 	call	#27834		;#0x6cba

00006cfe <.Loc.59.3>:
  iqp->q_counter = 0;
    6cfe:	1c 41 06 00 	mov	6(r1),	r12	;
    6d02:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006d06 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6d06:	1c 41 06 00 	mov	6(r1),	r12	;
    6d0a:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6d0e:	04 00 

00006d10 <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    6d10:	1c 41 06 00 	mov	6(r1),	r12	;
    6d14:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6d18:	0a 00 

00006d1a <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6d1a:	1c 41 06 00 	mov	6(r1),	r12	;
    6d1e:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6d22:	08 00 

00006d24 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    6d24:	1d 41 04 00 	mov	4(r1),	r13	;
    6d28:	1d 51 02 00 	add	2(r1),	r13	;
    6d2c:	1c 41 06 00 	mov	6(r1),	r12	;
    6d30:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006d34 <.Loc.64.3>:
  iqp->q_notify  = infy;
    6d34:	1c 41 06 00 	mov	6(r1),	r12	;
    6d38:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006d3c <.Loc.65.3>:
  iqp->q_link    = link;
    6d3c:	1c 41 06 00 	mov	6(r1),	r12	;
    6d40:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6d44:	0e 00 

00006d46 <.Loc.66.3>:
}
    6d46:	03 43       	nop			
    6d48:	31 52       	add	#8,	r1	;r2 As==11
    6d4a:	30 41       	ret			

00006d4c <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    6d4c:	21 82       	sub	#4,	r1	;r2 As==10

00006d4e <.LCFI4>:
    6d4e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6d52:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006d56 <.Loc.104.3>:

  osalDbgCheckClassI();
    6d56:	b0 12 7c 66 	call	#26236		;#0x667c

00006d5a <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    6d5a:	1c 41 02 00 	mov	2(r1),	r12	;
    6d5e:	1d 4c 08 00 	mov	8(r12),	r13	;
    6d62:	1c 41 02 00 	mov	2(r1),	r12	;
    6d66:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6d6a:	0d 9c       	cmp	r12,	r13	;
    6d6c:	08 20       	jnz	$+18     	;abs 0x6d7e

00006d6e <.Loc.106.3>:
    6d6e:	1c 41 02 00 	mov	2(r1),	r12	;
    6d72:	1c 4c 02 00 	mov	2(r12),	r12	;
    6d76:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d78:	02 24       	jz	$+6      	;abs 0x6d7e

00006d7a <.Loc.106.3>:
    6d7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d7c:	01 3c       	jmp	$+4      	;abs 0x6d80

00006d7e <.L13>:
    6d7e:	4c 43       	clr.b	r12		;

00006d80 <.L14>:
    6d80:	5c f3       	and.b	#1,	r12	;r3 As==01
    6d82:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6d86:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d88:	02 24       	jz	$+6      	;abs 0x6d8e

00006d8a <.Loc.107.3>:
    return MSG_TIMEOUT;
    6d8a:	3c 43       	mov	#-1,	r12	;r3 As==11
    6d8c:	2f 3c       	jmp	$+96     	;abs 0x6dec

00006d8e <.L15>:
  }

  iqp->q_counter++;
    6d8e:	1c 41 02 00 	mov	2(r1),	r12	;
    6d92:	1c 4c 02 00 	mov	2(r12),	r12	;
    6d96:	0d 4c       	mov	r12,	r13	;
    6d98:	1d 53       	inc	r13		;
    6d9a:	1c 41 02 00 	mov	2(r1),	r12	;
    6d9e:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006da2 <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    6da2:	1c 41 02 00 	mov	2(r1),	r12	;
    6da6:	1c 4c 08 00 	mov	8(r12),	r12	;
    6daa:	0e 4c       	mov	r12,	r14	;
    6dac:	1e 53       	inc	r14		;
    6dae:	1d 41 02 00 	mov	2(r1),	r13	;
    6db2:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6db6:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6dba:	00 00 

00006dbc <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6dbc:	1c 41 02 00 	mov	2(r1),	r12	;
    6dc0:	1d 4c 08 00 	mov	8(r12),	r13	;
    6dc4:	1c 41 02 00 	mov	2(r1),	r12	;
    6dc8:	1c 4c 06 00 	mov	6(r12),	r12	;
    6dcc:	0d 9c       	cmp	r12,	r13	;
    6dce:	08 28       	jnc	$+18     	;abs 0x6de0

00006dd0 <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    6dd0:	1c 41 02 00 	mov	2(r1),	r12	;
    6dd4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6dd8:	1c 41 02 00 	mov	2(r1),	r12	;
    6ddc:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006de0 <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    6de0:	1c 41 02 00 	mov	2(r1),	r12	;
    6de4:	4d 43       	clr.b	r13		;
    6de6:	b0 12 02 6c 	call	#27650		;#0x6c02

00006dea <.Loc.118.3>:

  return MSG_OK;
    6dea:	4c 43       	clr.b	r12		;

00006dec <.L16>:
}
    6dec:	21 52       	add	#4,	r1	;r2 As==10
    6dee:	30 41       	ret			

00006df0 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    6df0:	31 82       	sub	#8,	r1	;r2 As==11

00006df2 <.LCFI5>:
    6df2:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

00006df4 <L0>:
    6df4:	02 00       	mova	@r0,	r2	;
    6df6:	81 4d 00 00 	mov	r13,	0(r1)	;

00006dfa <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6dfa:	b0 12 9c 6c 	call	#27804		;#0x6c9c

00006dfe <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6dfe:	0f 3c       	jmp	$+32     	;abs 0x6e1e

00006e00 <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6e00:	1c 41 02 00 	mov	2(r1),	r12	;
    6e04:	2d 41       	mov	@r1,	r13	;
    6e06:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    6e0a:	81 4c 06 00 	mov	r12,	6(r1)	;

00006e0e <.Loc.149.3>:
    if (msg < MSG_OK) {
    6e0e:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6e12:	05 34       	jge	$+12     	;abs 0x6e1e

00006e14 <.Loc.150.3>:
      osalSysUnlock();
    6e14:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00006e18 <.Loc.151.3>:
      return msg;
    6e18:	1c 41 06 00 	mov	6(r1),	r12	;
    6e1c:	3f 3c       	jmp	$+128    	;abs 0x6e9c

00006e1e <.L19>:
  while (iqIsEmptyI(iqp)) {
    6e1e:	1c 41 02 00 	mov	2(r1),	r12	;
    6e22:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e26:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e28:	eb 27       	jz	$-40     	;abs 0x6e00

00006e2a <.Loc.156.3>:
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6e2a:	1c 41 02 00 	mov	2(r1),	r12	;
    6e2e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e32:	0d 4c       	mov	r12,	r13	;
    6e34:	3d 53       	add	#-1,	r13	;r3 As==11
    6e36:	1c 41 02 00 	mov	2(r1),	r12	;
    6e3a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006e3e <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6e3e:	1c 41 02 00 	mov	2(r1),	r12	;
    6e42:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6e46:	0e 4c       	mov	r12,	r14	;
    6e48:	1e 53       	inc	r14		;
    6e4a:	1d 41 02 00 	mov	2(r1),	r13	;
    6e4e:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6e52:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

00006e56 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    6e56:	1c 41 02 00 	mov	2(r1),	r12	;
    6e5a:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6e5e:	1c 41 02 00 	mov	2(r1),	r12	;
    6e62:	1c 4c 06 00 	mov	6(r12),	r12	;
    6e66:	0d 9c       	cmp	r12,	r13	;
    6e68:	08 28       	jnc	$+18     	;abs 0x6e7a

00006e6a <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6e6a:	1c 41 02 00 	mov	2(r1),	r12	;
    6e6e:	1d 4c 04 00 	mov	4(r12),	r13	;
    6e72:	1c 41 02 00 	mov	2(r1),	r12	;
    6e76:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006e7a <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6e7a:	1c 41 02 00 	mov	2(r1),	r12	;
    6e7e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6e82:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e84:	07 24       	jz	$+16     	;abs 0x6e94

00006e86 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6e86:	1c 41 02 00 	mov	2(r1),	r12	;
    6e8a:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6e8e:	1c 41 02 00 	mov	2(r1),	r12	;
    6e92:	8d 12       	call	r13		;

00006e94 <.L23>:
  }

  osalSysUnlock();
    6e94:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00006e98 <.Loc.169.3>:

  return (msg_t)b;
    6e98:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006e9c <.L20>:
}
    6e9c:	31 52       	add	#8,	r1	;r2 As==11
    6e9e:	30 41       	ret			

00006ea0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    6ea0:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006ea4 <L0>:
    6ea4:	81 4c 06 00 	mov	r12,	6(r1)	;
    6ea8:	81 4d 04 00 	mov	r13,	4(r1)	;
    6eac:	81 4e 02 00 	mov	r14,	2(r1)	;
    6eb0:	81 4f 00 00 	mov	r15,	0(r1)	;

00006eb4 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6eb4:	1c 41 06 00 	mov	6(r1),	r12	;
    6eb8:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6ebc:	0c 00 

00006ebe <.Loc.200.3>:
  size_t r = 0;
    6ebe:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006ec2 <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6ec2:	b0 12 9c 6c 	call	#27804		;#0x6c9c

00006ec6 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6ec6:	b0 12 b4 6c 	call	#27828		;#0x6cb4
    6eca:	0d 4c       	mov	r12,	r13	;
    6ecc:	2d 51       	add	@r1,	r13	;
    6ece:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006ed2 <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6ed2:	2e 3c       	jmp	$+94     	;abs 0x6f30

00006ed4 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6ed4:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6ed8:	03 24       	jz	$+8      	;abs 0x6ee0

00006eda <.Loc.218.3>:
    6eda:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6ede:	08 20       	jnz	$+18     	;abs 0x6ef0

00006ee0 <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6ee0:	1c 41 06 00 	mov	6(r1),	r12	;
    6ee4:	2d 41       	mov	@r1,	r13	;
    6ee6:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    6eea:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6eee:	18 3c       	jmp	$+50     	;abs 0x6f20

00006ef0 <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6ef0:	b0 12 b4 6c 	call	#27828		;#0x6cb4
    6ef4:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6ef8:	0d 8c       	sub	r12,	r13	;
    6efa:	81 4d 08 00 	mov	r13,	8(r1)	;

00006efe <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6efe:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6f02:	00 00 
    6f04:	05 2c       	jc	$+12     	;abs 0x6f10

00006f06 <.Loc.228.3>:
          osalSysUnlock();
    6f06:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00006f0a <.Loc.229.3>:
          return r;
    6f0a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f0e:	5c 3c       	jmp	$+186    	;abs 0x6fc8

00006f10 <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    6f10:	1c 41 06 00 	mov	6(r1),	r12	;
    6f14:	1d 41 08 00 	mov	8(r1),	r13	;
    6f18:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    6f1c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006f20 <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6f20:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6f24:	05 24       	jz	$+12     	;abs 0x6f30

00006f26 <.Loc.237.3>:
        osalSysUnlock();
    6f26:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00006f2a <.Loc.238.3>:
        return r;
    6f2a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f2e:	4c 3c       	jmp	$+154    	;abs 0x6fc8

00006f30 <.L25>:
    while (iqIsEmptyI(iqp)) {
    6f30:	1c 41 06 00 	mov	6(r1),	r12	;
    6f34:	1c 4c 02 00 	mov	2(r12),	r12	;
    6f38:	0c 93       	cmp	#0,	r12	;r3 As==00
    6f3a:	cc 27       	jz	$-102    	;abs 0x6ed4

00006f3c <.Loc.243.3>:
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    6f3c:	1c 41 06 00 	mov	6(r1),	r12	;
    6f40:	1c 4c 02 00 	mov	2(r12),	r12	;
    6f44:	0d 4c       	mov	r12,	r13	;
    6f46:	3d 53       	add	#-1,	r13	;r3 As==11
    6f48:	1c 41 06 00 	mov	6(r1),	r12	;
    6f4c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006f50 <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    6f50:	1c 41 04 00 	mov	4(r1),	r12	;
    6f54:	0d 4c       	mov	r12,	r13	;
    6f56:	1d 53       	inc	r13		;
    6f58:	81 4d 04 00 	mov	r13,	4(r1)	;
    6f5c:	1d 41 06 00 	mov	6(r1),	r13	;
    6f60:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    6f64:	0f 4d       	mov	r13,	r15	;
    6f66:	1f 53       	inc	r15		;
    6f68:	1e 41 06 00 	mov	6(r1),	r14	;
    6f6c:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    6f70:	6d 4d       	mov.b	@r13,	r13	;
    6f72:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006f76 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    6f76:	1c 41 06 00 	mov	6(r1),	r12	;
    6f7a:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6f7e:	1c 41 06 00 	mov	6(r1),	r12	;
    6f82:	1c 4c 06 00 	mov	6(r12),	r12	;
    6f86:	0d 9c       	cmp	r12,	r13	;
    6f88:	08 28       	jnc	$+18     	;abs 0x6f9a

00006f8a <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6f8a:	1c 41 06 00 	mov	6(r1),	r12	;
    6f8e:	1d 4c 04 00 	mov	4(r12),	r13	;
    6f92:	1c 41 06 00 	mov	6(r1),	r12	;
    6f96:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006f9a <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6f9a:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6f9e:	05 24       	jz	$+12     	;abs 0x6faa

00006fa0 <.Loc.251.3>:
      nfy(iqp);
    6fa0:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6fa4:	1c 41 06 00 	mov	6(r1),	r12	;
    6fa8:	8d 12       	call	r13		;

00006faa <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6faa:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00006fae <.Loc.257.3>:

    r++;
    6fae:	91 53 10 00 	inc	16(r1)		;

00006fb2 <.Loc.258.3>:
    if (--n == 0U) {
    6fb2:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6fb6:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6fba:	03 20       	jnz	$+8      	;abs 0x6fc2

00006fbc <.Loc.259.3>:
      return r;
    6fbc:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6fc0:	03 3c       	jmp	$+8      	;abs 0x6fc8

00006fc2 <.L34>:
    }

    osalSysLock();
    6fc2:	b0 12 9c 6c 	call	#27804		;#0x6c9c

00006fc6 <.Loc.213.3>:
    while (iqIsEmptyI(iqp)) {
    6fc6:	b4 3f       	jmp	$-150    	;abs 0x6f30

00006fc8 <.L30>:
  }
}
    6fc8:	31 50 12 00 	add	#18,	r1	;#0x0012
    6fcc:	30 41       	ret			

00006fce <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    6fce:	31 82       	sub	#8,	r1	;r2 As==11

00006fd0 <.LCFI7>:
    6fd0:	81 4c 06 00 	mov	r12,	6(r1)	;
    6fd4:	81 4d 04 00 	mov	r13,	4(r1)	;
    6fd8:	81 4e       	mov	r14		; Warning: disassembly unreliable - not enough bytes available

00006fda <L0>:
    6fda:	02 00       	mova	@r0,	r2	;
    6fdc:	81 4f 00 00 	mov	r15,	0(r1)	;

00006fe0 <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    6fe0:	1c 41 06 00 	mov	6(r1),	r12	;
    6fe4:	b0 12 ba 6c 	call	#27834		;#0x6cba

00006fe8 <.Loc.285.3>:
  oqp->q_counter = size;
    6fe8:	1c 41 06 00 	mov	6(r1),	r12	;
    6fec:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    6ff0:	02 00 

00006ff2 <.Loc.286.3>:
  oqp->q_buffer  = bp;
    6ff2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ff6:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6ffa:	04 00 

00006ffc <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6ffc:	1c 41 06 00 	mov	6(r1),	r12	;
    7000:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    7004:	0a 00 

00007006 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    7006:	1c 41 06 00 	mov	6(r1),	r12	;
    700a:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    700e:	08 00 

00007010 <.Loc.289.3>:
  oqp->q_top     = bp + size;
    7010:	1d 41 04 00 	mov	4(r1),	r13	;
    7014:	1d 51 02 00 	add	2(r1),	r13	;
    7018:	1c 41 06 00 	mov	6(r1),	r12	;
    701c:	8c 4d 06 00 	mov	r13,	6(r12)	;

00007020 <.Loc.290.3>:
  oqp->q_notify  = onfy;
    7020:	1c 41 06 00 	mov	6(r1),	r12	;
    7024:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00007028 <.Loc.291.3>:
  oqp->q_link    = link;
    7028:	1c 41 06 00 	mov	6(r1),	r12	;
    702c:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    7030:	0e 00 

00007032 <.Loc.292.3>:
}
    7032:	03 43       	nop			
    7034:	31 52       	add	#8,	r1	;r2 As==11
    7036:	30 41       	ret			

00007038 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    7038:	31 82       	sub	#8,	r1	;r2 As==11

0000703a <.LCFI9>:
    703a:	81 4c 04 00 	mov	r12,	4(r1)	;
    703e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    7042:	81 4e 00 00 	mov	r14,	0(r1)	;

00007046 <.Loc.339.3>:

  osalSysLock();
    7046:	b0 12 9c 6c 	call	#27804		;#0x6c9c

0000704a <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    704a:	0f 3c       	jmp	$+32     	;abs 0x706a

0000704c <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    704c:	1c 41 04 00 	mov	4(r1),	r12	;
    7050:	2d 41       	mov	@r1,	r13	;
    7052:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    7056:	81 4c 06 00 	mov	r12,	6(r1)	;

0000705a <.Loc.344.3>:
    if (msg < MSG_OK) {
    705a:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    705e:	05 34       	jge	$+12     	;abs 0x706a

00007060 <.Loc.345.3>:
      osalSysUnlock();
    7060:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00007064 <.Loc.346.3>:
      return msg;
    7064:	1c 41 06 00 	mov	6(r1),	r12	;
    7068:	3f 3c       	jmp	$+128    	;abs 0x70e8

0000706a <.L39>:
  while (oqIsFullI(oqp)) {
    706a:	1c 41 04 00 	mov	4(r1),	r12	;
    706e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7072:	0c 93       	cmp	#0,	r12	;r3 As==00
    7074:	eb 27       	jz	$-40     	;abs 0x704c

00007076 <.Loc.351.3>:
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    7076:	1c 41 04 00 	mov	4(r1),	r12	;
    707a:	1c 4c 02 00 	mov	2(r12),	r12	;
    707e:	0d 4c       	mov	r12,	r13	;
    7080:	3d 53       	add	#-1,	r13	;r3 As==11
    7082:	1c 41 04 00 	mov	4(r1),	r12	;
    7086:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000708a <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    708a:	1c 41 04 00 	mov	4(r1),	r12	;
    708e:	1c 4c 08 00 	mov	8(r12),	r12	;
    7092:	0e 4c       	mov	r12,	r14	;
    7094:	1e 53       	inc	r14		;
    7096:	1d 41 04 00 	mov	4(r1),	r13	;
    709a:	8d 4e 08 00 	mov	r14,	8(r13)	;
    709e:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    70a2:	00 00 

000070a4 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    70a4:	1c 41 04 00 	mov	4(r1),	r12	;
    70a8:	1d 4c 08 00 	mov	8(r12),	r13	;
    70ac:	1c 41 04 00 	mov	4(r1),	r12	;
    70b0:	1c 4c 06 00 	mov	6(r12),	r12	;
    70b4:	0d 9c       	cmp	r12,	r13	;
    70b6:	08 28       	jnc	$+18     	;abs 0x70c8

000070b8 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    70b8:	1c 41 04 00 	mov	4(r1),	r12	;
    70bc:	1d 4c 04 00 	mov	4(r12),	r13	;
    70c0:	1c 41 04 00 	mov	4(r1),	r12	;
    70c4:	8c 4d 08 00 	mov	r13,	8(r12)	;

000070c8 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    70c8:	1c 41 04 00 	mov	4(r1),	r12	;
    70cc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    70d0:	0c 93       	cmp	#0,	r12	;r3 As==00
    70d2:	07 24       	jz	$+16     	;abs 0x70e2

000070d4 <.Loc.359.3>:
    oqp->q_notify(oqp);
    70d4:	1c 41 04 00 	mov	4(r1),	r12	;
    70d8:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    70dc:	1c 41 04 00 	mov	4(r1),	r12	;
    70e0:	8d 12       	call	r13		;

000070e2 <.L43>:
  }

  osalSysUnlock();
    70e2:	b0 12 a8 6c 	call	#27816		;#0x6ca8

000070e6 <.Loc.364.3>:

  return MSG_OK;
    70e6:	4c 43       	clr.b	r12		;

000070e8 <.L40>:
}
    70e8:	31 52       	add	#8,	r1	;r2 As==11
    70ea:	30 41       	ret			

000070ec <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    70ec:	21 82       	sub	#4,	r1	;r2 As==10

000070ee <.LCFI10>:
    70ee:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

000070f0 <L0>:
	...

000070f2 <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    70f2:	b0 12 7c 66 	call	#26236		;#0x667c

000070f6 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    70f6:	2c 41       	mov	@r1,	r12	;
    70f8:	1d 4c 08 00 	mov	8(r12),	r13	;
    70fc:	2c 41       	mov	@r1,	r12	;
    70fe:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7102:	0d 9c       	cmp	r12,	r13	;
    7104:	07 20       	jnz	$+16     	;abs 0x7114

00007106 <.Loc.382.3>:
    7106:	2c 41       	mov	@r1,	r12	;
    7108:	1c 4c 02 00 	mov	2(r12),	r12	;
    710c:	0c 93       	cmp	#0,	r12	;r3 As==00
    710e:	02 24       	jz	$+6      	;abs 0x7114

00007110 <.Loc.382.3>:
    7110:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7112:	01 3c       	jmp	$+4      	;abs 0x7116

00007114 <.L45>:
    7114:	4c 43       	clr.b	r12		;

00007116 <.L46>:
    7116:	5c f3       	and.b	#1,	r12	;r3 As==01
    7118:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    711c:	0c 93       	cmp	#0,	r12	;r3 As==00
    711e:	02 24       	jz	$+6      	;abs 0x7124

00007120 <.Loc.383.3>:
    return MSG_TIMEOUT;
    7120:	3c 43       	mov	#-1,	r12	;r3 As==11
    7122:	26 3c       	jmp	$+78     	;abs 0x7170

00007124 <.L47>:
  }

  oqp->q_counter++;
    7124:	2c 41       	mov	@r1,	r12	;
    7126:	1c 4c 02 00 	mov	2(r12),	r12	;
    712a:	0d 4c       	mov	r12,	r13	;
    712c:	1d 53       	inc	r13		;
    712e:	2c 41       	mov	@r1,	r12	;
    7130:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007134 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    7134:	2c 41       	mov	@r1,	r12	;
    7136:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    713a:	0e 4c       	mov	r12,	r14	;
    713c:	1e 53       	inc	r14		;
    713e:	2d 41       	mov	@r1,	r13	;
    7140:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    7144:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

00007148 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    7148:	2c 41       	mov	@r1,	r12	;
    714a:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    714e:	2c 41       	mov	@r1,	r12	;
    7150:	1c 4c 06 00 	mov	6(r12),	r12	;
    7154:	0d 9c       	cmp	r12,	r13	;
    7156:	06 28       	jnc	$+14     	;abs 0x7164

00007158 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    7158:	2c 41       	mov	@r1,	r12	;
    715a:	1d 4c 04 00 	mov	4(r12),	r13	;
    715e:	2c 41       	mov	@r1,	r12	;
    7160:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007164 <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    7164:	2c 41       	mov	@r1,	r12	;
    7166:	4d 43       	clr.b	r13		;
    7168:	b0 12 02 6c 	call	#27650		;#0x6c02

0000716c <.Loc.394.3>:

  return (msg_t)b;
    716c:	5c 41 03 00 	mov.b	3(r1),	r12	;

00007170 <.L48>:
}
    7170:	21 52       	add	#4,	r1	;r2 As==10
    7172:	30 41       	ret			

00007174 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    7174:	31 80 12 00 	sub	#18,	r1	;#0x0012

00007178 <L0>:
    7178:	81 4c 06 00 	mov	r12,	6(r1)	;
    717c:	81 4d 04 00 	mov	r13,	4(r1)	;
    7180:	81 4e 02 00 	mov	r14,	2(r1)	;
    7184:	81 4f 00 00 	mov	r15,	0(r1)	;

00007188 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    7188:	1c 41 06 00 	mov	6(r1),	r12	;
    718c:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    7190:	0c 00 

00007192 <.Loc.425.3>:
  size_t w = 0;
    7192:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00007196 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    7196:	b0 12 9c 6c 	call	#27804		;#0x6c9c

0000719a <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    719a:	b0 12 b4 6c 	call	#27828		;#0x6cb4
    719e:	0d 4c       	mov	r12,	r13	;
    71a0:	2d 51       	add	@r1,	r13	;
    71a2:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

000071a6 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    71a6:	2e 3c       	jmp	$+94     	;abs 0x7204

000071a8 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    71a8:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    71ac:	03 24       	jz	$+8      	;abs 0x71b4

000071ae <.Loc.442.3>:
    71ae:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    71b2:	08 20       	jnz	$+18     	;abs 0x71c4

000071b4 <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    71b4:	1c 41 06 00 	mov	6(r1),	r12	;
    71b8:	2d 41       	mov	@r1,	r13	;
    71ba:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    71be:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    71c2:	18 3c       	jmp	$+50     	;abs 0x71f4

000071c4 <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    71c4:	b0 12 b4 6c 	call	#27828		;#0x6cb4
    71c8:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    71cc:	0e 8c       	sub	r12,	r14	;
    71ce:	81 4e 08 00 	mov	r14,	8(r1)	;

000071d2 <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    71d2:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    71d6:	00 00 
    71d8:	05 2c       	jc	$+12     	;abs 0x71e4

000071da <.Loc.452.3>:
          osalSysUnlock();
    71da:	b0 12 a8 6c 	call	#27816		;#0x6ca8

000071de <.Loc.453.3>:
          return w;
    71de:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    71e2:	5c 3c       	jmp	$+186    	;abs 0x729c

000071e4 <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    71e4:	1c 41 06 00 	mov	6(r1),	r12	;
    71e8:	1d 41 08 00 	mov	8(r1),	r13	;
    71ec:	b0 12 cc 6c 	call	#27852		;#0x6ccc
    71f0:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

000071f4 <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    71f4:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    71f8:	05 24       	jz	$+12     	;abs 0x7204

000071fa <.Loc.461.3>:
        osalSysUnlock();
    71fa:	b0 12 a8 6c 	call	#27816		;#0x6ca8

000071fe <.Loc.462.3>:
        return w;
    71fe:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7202:	4c 3c       	jmp	$+154    	;abs 0x729c

00007204 <.L51>:
    while (oqIsFullI(oqp)) {
    7204:	1c 41 06 00 	mov	6(r1),	r12	;
    7208:	1c 4c 02 00 	mov	2(r12),	r12	;
    720c:	0c 93       	cmp	#0,	r12	;r3 As==00
    720e:	cc 27       	jz	$-102    	;abs 0x71a8

00007210 <.Loc.467.3>:
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    7210:	1c 41 06 00 	mov	6(r1),	r12	;
    7214:	1c 4c 02 00 	mov	2(r12),	r12	;
    7218:	0d 4c       	mov	r12,	r13	;
    721a:	3d 53       	add	#-1,	r13	;r3 As==11
    721c:	1c 41 06 00 	mov	6(r1),	r12	;
    7220:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007224 <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    7224:	1c 41 06 00 	mov	6(r1),	r12	;
    7228:	1c 4c 08 00 	mov	8(r12),	r12	;
    722c:	0e 4c       	mov	r12,	r14	;
    722e:	1e 53       	inc	r14		;
    7230:	1d 41 06 00 	mov	6(r1),	r13	;
    7234:	8d 4e 08 00 	mov	r14,	8(r13)	;
    7238:	1d 41 04 00 	mov	4(r1),	r13	;
    723c:	0e 4d       	mov	r13,	r14	;
    723e:	1e 53       	inc	r14		;
    7240:	81 4e 04 00 	mov	r14,	4(r1)	;
    7244:	6d 4d       	mov.b	@r13,	r13	;
    7246:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000724a <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    724a:	1c 41 06 00 	mov	6(r1),	r12	;
    724e:	1d 4c 08 00 	mov	8(r12),	r13	;
    7252:	1c 41 06 00 	mov	6(r1),	r12	;
    7256:	1c 4c 06 00 	mov	6(r12),	r12	;
    725a:	0d 9c       	cmp	r12,	r13	;
    725c:	08 28       	jnc	$+18     	;abs 0x726e

0000725e <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    725e:	1c 41 06 00 	mov	6(r1),	r12	;
    7262:	1d 4c 04 00 	mov	4(r12),	r13	;
    7266:	1c 41 06 00 	mov	6(r1),	r12	;
    726a:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000726e <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    726e:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    7272:	05 24       	jz	$+12     	;abs 0x727e

00007274 <.Loc.475.3>:
      nfy(oqp);
    7274:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    7278:	1c 41 06 00 	mov	6(r1),	r12	;
    727c:	8d 12       	call	r13		;

0000727e <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    727e:	b0 12 a8 6c 	call	#27816		;#0x6ca8

00007282 <.Loc.481.3>:

    w++;
    7282:	91 53 10 00 	inc	16(r1)		;

00007286 <.Loc.482.3>:
    if (--n == 0U) {
    7286:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    728a:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    728e:	03 20       	jnz	$+8      	;abs 0x7296

00007290 <.Loc.483.3>:
      return w;
    7290:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7294:	03 3c       	jmp	$+8      	;abs 0x729c

00007296 <.L60>:
    }

    osalSysLock();
    7296:	b0 12 9c 6c 	call	#27804		;#0x6c9c

0000729a <.LBE6>:
  while (true) {
    729a:	85 3f       	jmp	$-244    	;abs 0x71a6

0000729c <.L56>:
  }
}
    729c:	31 50 12 00 	add	#18,	r1	;#0x0012
    72a0:	30 41       	ret			

000072a2 <port_lock>:
  _disable_interrupts();
    72a2:	32 c2       	dint			

000072a4 <.Loc.348.1>:
  asm volatile("nop");
    72a4:	03 43       	nop			

000072a6 <.Loc.349.1>:
}
    72a6:	03 43       	nop			
    72a8:	30 41       	ret			

000072aa <port_unlock>:
  asm volatile("nop");
    72aa:	03 43       	nop			

000072ac <.Loc.356.1>:
  _enable_interrupts();
    72ac:	32 d2       	eint			

000072ae <L0>:
    72ae:	03 43       	nop			

000072b0 <.Loc.357.1>:
}
    72b0:	03 43       	nop			
    72b2:	30 41       	ret			

000072b4 <osalSysLock>:
  chSysLock();
    72b4:	b0 12 a2 72 	call	#29346		;#0x72a2
    72b8:	b0 12 96 65 	call	#26006		;#0x6596

000072bc <.Loc.505.2>:
}
    72bc:	03 43       	nop			
    72be:	30 41       	ret			

000072c0 <osalSysUnlock>:
  chSysUnlock();
    72c0:	b0 12 b6 65 	call	#26038		;#0x65b6
    72c4:	b0 12 aa 72 	call	#29354		;#0x72aa

000072c8 <.Loc.516.2>:
}
    72c8:	03 43       	nop			
    72ca:	30 41       	ret			

000072cc <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    72cc:	21 83       	decd	r1		;

000072ce <.LCFI0>:
    72ce:	81 4c 00 00 	mov	r12,	0(r1)	;

000072d2 <.Loc.885.2>:

  chSemObjectInit((semaphore_t *)mp, (cnt_t)1);
    72d2:	2c 41       	mov	@r1,	r12	;
    72d4:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

000072d8 <.Loc.886.2>:
}
    72d8:	03 43       	nop			
    72da:	21 53       	incd	r1		;
    72dc:	30 41       	ret			

000072de <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
    72de:	21 83       	decd	r1		;

000072e0 <.LCFI1>:
    72e0:	81 4c 00 00 	mov	r12,	0(r1)	;

000072e4 <.Loc.899.2>:

  (void) chSemWait((semaphore_t *)mp);
    72e4:	4d 43       	clr.b	r13		;
    72e6:	2c 41       	mov	@r1,	r12	;
    72e8:	b0 12 10 6a 	call	#27152		;#0x6a10

000072ec <.Loc.900.2>:
}
    72ec:	03 43       	nop			
    72ee:	21 53       	incd	r1		;
    72f0:	30 41       	ret			

000072f2 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
    72f2:	21 83       	decd	r1		;

000072f4 <.LCFI2>:
    72f4:	81 4c 00 00 	mov	r12,	0(r1)	;

000072f8 <.Loc.917.2>:

  chSemSignal((semaphore_t *)mp);
    72f8:	2c 41       	mov	@r1,	r12	;
    72fa:	b0 12 a8 6a 	call	#27304		;#0x6aa8

000072fe <.Loc.918.2>:
}
    72fe:	03 43       	nop			
    7300:	21 53       	incd	r1		;
    7302:	30 41       	ret			

00007304 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    7304:	b0 12 ba 86 	call	#-31046	;#0x86ba

00007308 <.Loc.62.3>:
}
    7308:	03 43       	nop			
    730a:	30 41       	ret			

0000730c <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
    730c:	21 83       	decd	r1		;

0000730e <.LCFI3>:
    730e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007312 <.Loc.73.3>:

  i2cp->state  = I2C_STOP;
    7312:	2c 41       	mov	@r1,	r12	;
    7314:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00007318 <.Loc.74.3>:
  i2cp->config = NULL;
    7318:	2c 41       	mov	@r1,	r12	;
    731a:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000731e <.Loc.77.3>:

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
    731e:	2c 41       	mov	@r1,	r12	;
    7320:	3c 50 06 00 	add	#6,	r12	;
    7324:	b0 12 cc 72 	call	#29388		;#0x72cc

00007328 <.Loc.83.3>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    7328:	03 43       	nop			
    732a:	21 53       	incd	r1		;
    732c:	30 41       	ret			

0000732e <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    732e:	21 82       	sub	#4,	r1	;r2 As==10

00007330 <.LCFI4>:
    7330:	81 4c 02 00 	mov	r12,	2(r1)	;
    7334:	81 4d 00 00 	mov	r13,	0(r1)	;

00007338 <.Loc.99.3>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
    7338:	b0 12 b4 72 	call	#29364		;#0x72b4

0000733c <.Loc.100.3>:
  i2cp->config = config;
    733c:	1c 41 02 00 	mov	2(r1),	r12	;
    7340:	ac 41 02 00 	mov	@r1,	2(r12)	;

00007344 <.Loc.101.3>:
  i2c_lld_start(i2cp);
    7344:	1c 41 02 00 	mov	2(r1),	r12	;
    7348:	b0 12 ec 86 	call	#-30996	;#0x86ec

0000734c <.Loc.102.3>:
  i2cp->state = I2C_READY;
    734c:	1c 41 02 00 	mov	2(r1),	r12	;
    7350:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007354 <.Loc.103.3>:
  osalSysUnlock();
    7354:	b0 12 c0 72 	call	#29376		;#0x72c0

00007358 <.Loc.104.3>:
}
    7358:	03 43       	nop			
    735a:	21 52       	add	#4,	r1	;r2 As==10
    735c:	30 41       	ret			

0000735e <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
    735e:	31 80 10 00 	sub	#16,	r1	;#0x0010

00007362 <.LCFI7>:
    7362:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    7366:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    736a:	81 4e 08 00 	mov	r14,	8(r1)	;
    736e:	81 4f 06 00 	mov	r15,	6(r1)	;

00007372 <.Loc.186.3>:
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
    7372:	b0 12 b4 72 	call	#29364		;#0x72b4

00007376 <.Loc.187.3>:
  i2cp->errors = I2C_NO_ERROR;
    7376:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    737a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

0000737e <.Loc.188.3>:
  i2cp->state = I2C_ACTIVE_TX;
    737e:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    7382:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    7386:	00 00 

00007388 <.Loc.189.3>:
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
    7388:	91 41 16 00 	mov	22(r1),	4(r1)	;0x00016
    738c:	04 00 
    738e:	91 41 14 00 	mov	20(r1),	2(r1)	;0x00014
    7392:	02 00 
    7394:	91 41 12 00 	mov	18(r1),	0(r1)	;0x00012
    7398:	00 00 
    739a:	1f 41 06 00 	mov	6(r1),	r15	;
    739e:	1e 41 08 00 	mov	8(r1),	r14	;
    73a2:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    73a6:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    73aa:	b0 12 34 8e 	call	#-29132	;#0x8e34
    73ae:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

000073b2 <.Loc.191.3>:
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    73b2:	b1 93 0e 00 	cmp	#-1,	14(r1)	;r3 As==11, 0x000e
    73b6:	06 20       	jnz	$+14     	;abs 0x73c4

000073b8 <.Loc.192.3>:
    i2cp->state = I2C_LOCKED;
    73b8:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    73bc:	fc 40 05 00 	mov.b	#5,	0(r12)	;
    73c0:	00 00 
    73c2:	04 3c       	jmp	$+10     	;abs 0x73cc

000073c4 <.L15>:
  }
  else {
    i2cp->state = I2C_READY;
    73c4:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    73c8:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

000073cc <.L16>:
  }
  osalSysUnlock();
    73cc:	b0 12 c0 72 	call	#29376		;#0x72c0

000073d0 <.Loc.198.3>:
  return rdymsg;
    73d0:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e

000073d4 <.Loc.199.3>:
}
    73d4:	31 50 10 00 	add	#16,	r1	;#0x0010
    73d8:	30 41       	ret			

000073da <i2cMasterReceiveTimeout>:
 */
msg_t i2cMasterReceiveTimeout(I2CDriver *i2cp,
                              i2caddr_t addr,
                              uint8_t *rxbuf,
                              size_t rxbytes,
                              systime_t timeout){
    73da:	31 80       	sub,		r1	;Warning: disassembly unreliable - not enough bytes available

000073dc <L0>:
    73dc:	0c 00       	mova	@r0,	r12	;

000073de <.LCFI8>:
    73de:	81 4c 08 00 	mov	r12,	8(r1)	;
    73e2:	81 4d 06 00 	mov	r13,	6(r1)	;
    73e6:	81 4e 04 00 	mov	r14,	4(r1)	;
    73ea:	81 4f 02 00 	mov	r15,	2(r1)	;

000073ee <.Loc.235.3>:
               (rxbytes > 0U) && (rxbuf != NULL) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
    73ee:	b0 12 b4 72 	call	#29364		;#0x72b4

000073f2 <.Loc.236.3>:
  i2cp->errors = I2C_NO_ERROR;
    73f2:	1c 41 08 00 	mov	8(r1),	r12	;
    73f6:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000073fa <.Loc.237.3>:
  i2cp->state = I2C_ACTIVE_RX;
    73fa:	1c 41 08 00 	mov	8(r1),	r12	;
    73fe:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10

00007402 <.Loc.238.3>:
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
    7402:	91 41 0e 00 	mov	14(r1),	0(r1)	;0x0000e
    7406:	00 00 
    7408:	1f 41 02 00 	mov	2(r1),	r15	;
    740c:	1e 41 04 00 	mov	4(r1),	r14	;
    7410:	1d 41 06 00 	mov	6(r1),	r13	;
    7414:	1c 41 08 00 	mov	8(r1),	r12	;
    7418:	b0 12 68 8c 	call	#-29592	;#0x8c68
    741c:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007420 <.Loc.239.3>:
  if (rdymsg == MSG_TIMEOUT) {
    7420:	b1 93 0a 00 	cmp	#-1,	10(r1)	;r3 As==11, 0x000a
    7424:	06 20       	jnz	$+14     	;abs 0x7432

00007426 <.Loc.240.3>:
    i2cp->state = I2C_LOCKED;
    7426:	1c 41 08 00 	mov	8(r1),	r12	;
    742a:	fc 40 05 00 	mov.b	#5,	0(r12)	;
    742e:	00 00 
    7430:	04 3c       	jmp	$+10     	;abs 0x743a

00007432 <.L19>:
  }
  else {
    i2cp->state = I2C_READY;
    7432:	1c 41 08 00 	mov	8(r1),	r12	;
    7436:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000743a <.L20>:
  }
  osalSysUnlock();
    743a:	b0 12 c0 72 	call	#29376		;#0x72c0

0000743e <.Loc.246.3>:
  return rdymsg;
    743e:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a

00007442 <.Loc.247.3>:
}
    7442:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7446:	30 41       	ret			

00007448 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
    7448:	21 83       	decd	r1		;

0000744a <L0>:
    744a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000744e <.Loc.265.3>:

  osalDbgCheck(i2cp != NULL);

  osalMutexLock(&i2cp->mutex);
    744e:	2c 41       	mov	@r1,	r12	;
    7450:	3c 50 06 00 	add	#6,	r12	;
    7454:	b0 12 de 72 	call	#29406		;#0x72de

00007458 <.Loc.266.3>:
}
    7458:	03 43       	nop			
    745a:	21 53       	incd	r1		;
    745c:	30 41       	ret			

0000745e <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
    745e:	21 83       	decd	r1		;

00007460 <.LCFI10>:
    7460:	81 4c 00 00 	mov	r12,	0(r1)	;

00007464 <.Loc.281.3>:

  osalDbgCheck(i2cp != NULL);

  osalMutexUnlock(&i2cp->mutex);
    7464:	2c 41       	mov	@r1,	r12	;
    7466:	3c 50 06 00 	add	#6,	r12	;
    746a:	b0 12 f2 72 	call	#29426		;#0x72f2

0000746e <.Loc.282.3>:
}
    746e:	03 43       	nop			
    7470:	21 53       	incd	r1		;
    7472:	30 41       	ret			

00007474 <port_lock>:
  _disable_interrupts();
    7474:	32 c2       	dint			

00007476 <.Loc.348.1>:
  asm volatile("nop");
    7476:	03 43       	nop			

00007478 <.Loc.349.1>:
}
    7478:	03 43       	nop			
    747a:	30 41       	ret			

0000747c <port_unlock>:
  asm volatile("nop");
    747c:	03 43       	nop			

0000747e <.Loc.356.1>:
  _enable_interrupts();
    747e:	32 d2       	eint			
    7480:	03 43       	nop			

00007482 <.Loc.357.1>:
}
    7482:	03 43       	nop			
    7484:	30 41       	ret			

00007486 <osalSysLock>:
  chSysLock();
    7486:	b0 12 74 74 	call	#29812		;#0x7474
    748a:	b0 12 96 65 	call	#26006		;#0x6596

0000748e <.Loc.505.2>:
}
    748e:	03 43       	nop			
    7490:	30 41       	ret			

00007492 <osalSysUnlock>:
  chSysUnlock();
    7492:	b0 12 b6 65 	call	#26038		;#0x65b6
    7496:	b0 12 7c 74 	call	#29820		;#0x747c

0000749a <.Loc.516.2>:
}
    749a:	03 43       	nop			
    749c:	30 41       	ret			

0000749e <osalEventObjectInit>:
static inline void osalEventObjectInit(event_source_t *esp) {
    749e:	21 83       	decd	r1		;

000074a0 <.LCFI0>:
    74a0:	81 4c 00 00 	mov	r12,	0(r1)	;

000074a4 <.Loc.810.2>:
  esp->flags = 0;
    74a4:	2c 41       	mov	@r1,	r12	;
    74a6:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    74aa:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

000074ae <.Loc.811.2>:
  esp->cb    = NULL;
    74ae:	2c 41       	mov	@r1,	r12	;
    74b0:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000074b4 <.Loc.812.2>:
  esp->param = NULL;
    74b4:	2c 41       	mov	@r1,	r12	;
    74b6:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

000074ba <.Loc.813.2>:
}
    74ba:	03 43       	nop			
    74bc:	21 53       	incd	r1		;
    74be:	30 41       	ret			

000074c0 <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    74c0:	0a 15       	pushm	#1,	r10	;16-bit words

000074c2 <.LCFI1>:
    74c2:	31 80 06 00 	sub	#6,	r1	;

000074c6 <.LCFI2>:
    74c6:	81 4c 04 00 	mov	r12,	4(r1)	;
    74ca:	81 4d 00 00 	mov	r13,	0(r1)	;
    74ce:	81 4e 02 00 	mov	r14,	2(r1)	;

000074d2 <.Loc.828.2>:
  esp->flags |= flags;
    74d2:	1c 41 04 00 	mov	4(r1),	r12	;
    74d6:	1d 4c 02 00 	mov	2(r12),	r13	;
    74da:	2c 4c       	mov	@r12,	r12	;
    74dc:	2a 41       	mov	@r1,	r10	;
    74de:	0a dc       	bis	r12,	r10	;
    74e0:	1b 41 02 00 	mov	2(r1),	r11	;
    74e4:	0b dd       	bis	r13,	r11	;
    74e6:	1c 41 04 00 	mov	4(r1),	r12	;
    74ea:	8c 4a 00 00 	mov	r10,	0(r12)	;
    74ee:	8c 4b 02 00 	mov	r11,	2(r12)	;

000074f2 <.Loc.829.2>:
  if (esp->cb != NULL) {
    74f2:	1c 41 04 00 	mov	4(r1),	r12	;
    74f6:	1c 4c 04 00 	mov	4(r12),	r12	;
    74fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    74fc:	07 24       	jz	$+16     	;abs 0x750c

000074fe <.Loc.830.2>:
    esp->cb(esp);
    74fe:	1c 41 04 00 	mov	4(r1),	r12	;
    7502:	1d 4c 04 00 	mov	4(r12),	r13	;
    7506:	1c 41 04 00 	mov	4(r1),	r12	;
    750a:	8d 12       	call	r13		;

0000750c <.L9>:
}
    750c:	03 43       	nop			
    750e:	31 50 06 00 	add	#6,	r1	;
    7512:	0a 17       	popm	#1,	r10	;16-bit words
    7514:	30 41       	ret			

00007516 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    7516:	31 80 06 00 	sub	#6,	r1	;

0000751a <.LCFI3>:
    751a:	81 4c 04 00 	mov	r12,	4(r1)	;
    751e:	81 4d 02 00 	mov	r13,	2(r1)	;
    7522:	81 4e 00 00 	mov	r14,	0(r1)	;

00007526 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    7526:	1c 41 04 00 	mov	4(r1),	r12	;
    752a:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    752e:	4f 43       	clr.b	r15		;
    7530:	2e 41       	mov	@r1,	r14	;
    7532:	1d 41 02 00 	mov	2(r1),	r13	;
    7536:	b0 12 74 71 	call	#29044		;#0x7174

0000753a <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    753a:	31 50 06 00 	add	#6,	r1	;
    753e:	30 41       	ret			

00007540 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    7540:	31 80 06 00 	sub	#6,	r1	;

00007544 <.LCFI4>:
    7544:	81 4c 04 00 	mov	r12,	4(r1)	;
    7548:	81 4d 02 00 	mov	r13,	2(r1)	;
    754c:	81 4e 00 00 	mov	r14,	0(r1)	;

00007550 <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    7550:	1c 41 04 00 	mov	4(r1),	r12	;
    7554:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7558:	4f 43       	clr.b	r15		;
    755a:	2e 41       	mov	@r1,	r14	;
    755c:	1d 41 02 00 	mov	2(r1),	r13	;
    7560:	b0 12 a0 6e 	call	#28320		;#0x6ea0

00007564 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    7564:	31 50 06 00 	add	#6,	r1	;
    7568:	30 41       	ret			

0000756a <put>:

static msg_t put(void *ip, uint8_t b) {
    756a:	21 82       	sub	#4,	r1	;r2 As==10

0000756c <.LCFI5>:
    756c:	81 4c 02 00 	mov	r12,	2(r1)	;
    7570:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007574 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    7574:	1c 41 02 00 	mov	2(r1),	r12	;
    7578:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    757c:	4e 43       	clr.b	r14		;
    757e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7582:	b0 12 38 70 	call	#28728		;#0x7038

00007586 <.Loc.65.3>:
}
    7586:	21 52       	add	#4,	r1	;r2 As==10
    7588:	30 41       	ret			

0000758a <get>:

static msg_t get(void *ip) {
    758a:	21 83       	decd	r1		;

0000758c <.LCFI6>:
    758c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007590 <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    7590:	2c 41       	mov	@r1,	r12	;
    7592:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7596:	4d 43       	clr.b	r13		;
    7598:	b0 12 f0 6d 	call	#28144		;#0x6df0

0000759c <.Loc.70.3>:
}
    759c:	21 53       	incd	r1		;
    759e:	30 41       	ret			

000075a0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    75a0:	31 80 06 00 	sub	#6,	r1	;

000075a4 <.LCFI7>:
    75a4:	81 4c 04 00 	mov	r12,	4(r1)	;
    75a8:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    75ac:	81 4e 00 00 	mov	r14,	0(r1)	;

000075b0 <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    75b0:	1c 41 04 00 	mov	4(r1),	r12	;
    75b4:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    75b8:	2e 41       	mov	@r1,	r14	;
    75ba:	5d 41 03 00 	mov.b	3(r1),	r13	;
    75be:	b0 12 38 70 	call	#28728		;#0x7038

000075c2 <.Loc.75.3>:
}
    75c2:	31 50 06 00 	add	#6,	r1	;
    75c6:	30 41       	ret			

000075c8 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    75c8:	21 82       	sub	#4,	r1	;r2 As==10

000075ca <.LCFI8>:
    75ca:	81 4c 02 00 	mov	r12,	2(r1)	;
    75ce:	81 4d 00 00 	mov	r13,	0(r1)	;

000075d2 <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    75d2:	1c 41 02 00 	mov	2(r1),	r12	;
    75d6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    75da:	2d 41       	mov	@r1,	r13	;
    75dc:	b0 12 f0 6d 	call	#28144		;#0x6df0

000075e0 <.Loc.80.3>:
}
    75e0:	21 52       	add	#4,	r1	;r2 As==10
    75e2:	30 41       	ret			

000075e4 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    75e4:	31 82       	sub	#8,	r1	;r2 As==11

000075e6 <.LCFI9>:
    75e6:	81 4c 06 00 	mov	r12,	6(r1)	;
    75ea:	81 4d 04 00 	mov	r13,	4(r1)	;
    75ee:	81 4e 02 00 	mov	r14,	2(r1)	;
    75f2:	81 4f 00 00 	mov	r15,	0(r1)	;

000075f6 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    75f6:	1c 41 06 00 	mov	6(r1),	r12	;
    75fa:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    75fe:	2f 41       	mov	@r1,	r15	;
    7600:	1e 41 02 00 	mov	2(r1),	r14	;
    7604:	1d 41 04 00 	mov	4(r1),	r13	;
    7608:	b0 12 74 71 	call	#29044		;#0x7174

0000760c <.Loc.85.3>:
}
    760c:	31 52       	add	#8,	r1	;r2 As==11
    760e:	30 41       	ret			

00007610 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    7610:	31 82       	sub	#8,	r1	;r2 As==11

00007612 <.LCFI10>:
    7612:	81 4c 06 00 	mov	r12,	6(r1)	;
    7616:	81 4d 04 00 	mov	r13,	4(r1)	;
    761a:	81 4e 02 00 	mov	r14,	2(r1)	;
    761e:	81 4f 00 00 	mov	r15,	0(r1)	;

00007622 <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    7622:	1c 41 06 00 	mov	6(r1),	r12	;
    7626:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    762a:	2f 41       	mov	@r1,	r15	;
    762c:	1e 41 02 00 	mov	2(r1),	r14	;
    7630:	1d 41 04 00 	mov	4(r1),	r13	;
    7634:	b0 12 a0 6e 	call	#28320		;#0x6ea0

00007638 <.Loc.90.3>:
}
    7638:	31 52       	add	#8,	r1	;r2 As==11
    763a:	30 41       	ret			

0000763c <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    763c:	b0 12 62 7d 	call	#32098		;#0x7d62

00007640 <.Loc.111.3>:
}
    7640:	03 43       	nop			
    7642:	30 41       	ret			

00007644 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    7644:	31 82       	sub	#8,	r1	;r2 As==11

00007646 <.LCFI11>:
    7646:	81 4c 06 00 	mov	r12,	6(r1)	;
    764a:	81 4d 04 00 	mov	r13,	4(r1)	;
    764e:	81 4e 02 00 	mov	r14,	2(r1)	;

00007652 <.Loc.133.3>:

  sdp->vmt = &vmt;
    7652:	1c 41 06 00 	mov	6(r1),	r12	;
    7656:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    765a:	00 00 

0000765c <.Loc.134.3>:
  osalEventObjectInit(&sdp->event);
    765c:	1c 41 06 00 	mov	6(r1),	r12	;
    7660:	2c 53       	incd	r12		;
    7662:	b0 12 9e 74 	call	#29854		;#0x749e

00007666 <.Loc.135.3>:
  sdp->state = SD_STOP;
    7666:	1c 41 06 00 	mov	6(r1),	r12	;
    766a:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

0000766e <.Loc.136.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    766e:	1c 41 06 00 	mov	6(r1),	r12	;
    7672:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7676:	1d 41 06 00 	mov	6(r1),	r13	;
    767a:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    767e:	91 41 06 00 	mov	6(r1),	0(r1)	;
    7682:	00 00 
    7684:	1f 41 04 00 	mov	4(r1),	r15	;
    7688:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    768c:	b0 12 e4 6c 	call	#27876		;#0x6ce4

00007690 <.Loc.137.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    7690:	1c 41 06 00 	mov	6(r1),	r12	;
    7694:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7698:	1d 41 06 00 	mov	6(r1),	r13	;
    769c:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    76a0:	91 41 06 00 	mov	6(r1),	0(r1)	;
    76a4:	00 00 
    76a6:	1f 41 02 00 	mov	2(r1),	r15	;
    76aa:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    76ae:	b0 12 ce 6f 	call	#28622		;#0x6fce

000076b2 <.Loc.138.3>:
}
    76b2:	03 43       	nop			
    76b4:	31 52       	add	#8,	r1	;r2 As==11
    76b6:	30 41       	ret			

000076b8 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    76b8:	21 82       	sub	#4,	r1	;r2 As==10

000076ba <.LCFI12>:
    76ba:	81 4c 02 00 	mov	r12,	2(r1)	;
    76be:	81 4d 00 00 	mov	r13,	0(r1)	;

000076c2 <.Loc.162.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    76c2:	b0 12 86 74 	call	#29830		;#0x7486

000076c6 <.Loc.165.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    76c6:	2d 41       	mov	@r1,	r13	;
    76c8:	1c 41 02 00 	mov	2(r1),	r12	;
    76cc:	b0 12 74 7d 	call	#32116		;#0x7d74

000076d0 <.Loc.166.3>:
  sdp->state = SD_READY;
    76d0:	1c 41 02 00 	mov	2(r1),	r12	;
    76d4:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

000076d8 <.Loc.167.3>:
  osalSysUnlock();
    76d8:	b0 12 92 74 	call	#29842		;#0x7492

000076dc <.Loc.168.3>:
}
    76dc:	03 43       	nop			
    76de:	21 52       	add	#4,	r1	;r2 As==10
    76e0:	30 41       	ret			

000076e2 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    76e2:	21 82       	sub	#4,	r1	;r2 As==10

000076e4 <.LCFI14>:
    76e4:	81 4c 02 00 	mov	r12,	2(r1)	;
    76e8:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000076ec <.Loc.215.3>:

  osalDbgCheckClassI();
    76ec:	b0 12 7c 66 	call	#26236		;#0x667c

000076f0 <.Loc.218.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    76f0:	1c 41 02 00 	mov	2(r1),	r12	;
    76f4:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    76f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    76fa:	07 20       	jnz	$+16     	;abs 0x770a

000076fc <.Loc.219.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    76fc:	1c 41 02 00 	mov	2(r1),	r12	;
    7700:	2c 53       	incd	r12		;
    7702:	6d 42       	mov.b	#4,	r13	;r2 As==10
    7704:	4e 43       	clr.b	r14		;
    7706:	b0 12 c0 74 	call	#29888		;#0x74c0

0000770a <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    770a:	1c 41 02 00 	mov	2(r1),	r12	;
    770e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7712:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7716:	b0 12 4c 6d 	call	#27980		;#0x6d4c
    771a:	0c 93       	cmp	#0,	r12	;r3 As==00
    771c:	08 34       	jge	$+18     	;abs 0x772e

0000771e <.Loc.221.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    771e:	1c 41 02 00 	mov	2(r1),	r12	;
    7722:	2c 53       	incd	r12		;
    7724:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    7728:	4e 43       	clr.b	r14		;
    772a:	b0 12 c0 74 	call	#29888		;#0x74c0

0000772e <.L33>:
}
    772e:	03 43       	nop			
    7730:	21 52       	add	#4,	r1	;r2 As==10
    7732:	30 41       	ret			

00007734 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    7734:	21 82       	sub	#4,	r1	;r2 As==10

00007736 <.LCFI15>:
    7736:	81 4c 00 00 	mov	r12,	0(r1)	;

0000773a <.Loc.242.3>:
  msg_t  b;

  osalDbgCheckClassI();
    773a:	b0 12 7c 66 	call	#26236		;#0x667c

0000773e <.Loc.245.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    773e:	2c 41       	mov	@r1,	r12	;
    7740:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7744:	b0 12 ec 70 	call	#28908		;#0x70ec
    7748:	81 4c 02 00 	mov	r12,	2(r1)	;

0000774c <.Loc.246.3>:
  if (b < MSG_OK)
    774c:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    7750:	06 34       	jge	$+14     	;abs 0x775e

00007752 <.Loc.247.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    7752:	2c 41       	mov	@r1,	r12	;
    7754:	2c 53       	incd	r12		;
    7756:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7758:	4e 43       	clr.b	r14		;
    775a:	b0 12 c0 74 	call	#29888		;#0x74c0

0000775e <.L35>:
  return b;
    775e:	1c 41 02 00 	mov	2(r1),	r12	;

00007762 <.Loc.249.3>:
}
    7762:	21 52       	add	#4,	r1	;r2 As==10
    7764:	30 41       	ret			

00007766 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    7766:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    776a:	5c 01 

0000776c <.Loc.68.1>:
  FRCTL0 = FRCTLPW | NWAITS_1;
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    776c:	b2 40 00 a5 	mov	#-23296,&0x0160	;#0xa500
    7770:	60 01 

00007772 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    7772:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    7776:	62 01 

00007778 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    7778:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    777c:	64 01 

0000777e <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    777e:	b2 40 50 00 	mov	#80,	&0x0166	;#0x0050
    7782:	66 01 

00007784 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    7784:	b2 40 c9 c1 	mov	#-15927,&0x0168	;#0xc1c9
    7788:	68 01 

0000778a <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    778a:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    778e:	6c 01 

00007790 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    7790:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00007794 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    7794:	b0 12 48 81 	call	#-32440	;#0x8148

00007798 <.Loc.96.1>:
#endif
}
    7798:	03 43       	nop			
    779a:	30 41       	ret			

0000779c <port_lock_from_isr>:
}
    779c:	03 43       	nop			
    779e:	30 41       	ret			

000077a0 <port_unlock_from_isr>:
}
    77a0:	03 43       	nop			
    77a2:	30 41       	ret			

000077a4 <osalSysLockFromISR>:
  chSysLockFromISR();
    77a4:	b0 12 9c 77 	call	#30620		;#0x779c
    77a8:	b0 12 d8 65 	call	#26072		;#0x65d8

000077ac <.Loc.527.2>:
}
    77ac:	03 43       	nop			
    77ae:	30 41       	ret			

000077b0 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    77b0:	b0 12 fa 65 	call	#26106		;#0x65fa
    77b4:	b0 12 a0 77 	call	#30624		;#0x77a0

000077b8 <.Loc.538.2>:
}
    77b8:	03 43       	nop			
    77ba:	30 41       	ret			

000077bc <osalOsTimerHandlerI>:
  chSysTimerHandlerI();
    77bc:	b0 12 88 67 	call	#26504		;#0x6788

000077c0 <.Loc.597.2>:
}
    77c0:	03 43       	nop			
    77c2:	30 41       	ret			

000077c4 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    77c4:	bf 15       	pushm	#12,	r15	;16-bit words

000077c6 <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    77c6:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    77ca:	b0 12 1e 66 	call	#26142		;#0x661e

000077ce <.Loc.170.3>:
  
  osalSysLockFromISR();
    77ce:	b0 12 a4 77 	call	#30628		;#0x77a4

000077d2 <.Loc.171.3>:
  osalOsTimerHandlerI();
    77d2:	b0 12 bc 77 	call	#30652		;#0x77bc

000077d6 <.Loc.172.3>:
  osalSysUnlockFromISR();
    77d6:	b0 12 b0 77 	call	#30640		;#0x77b0

000077da <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    77da:	b0 12 4c 66 	call	#26188		;#0x664c
    77de:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    77e2:	b0 12 96 65 	call	#26006		;#0x6596
    77e6:	b0 12 cc 68 	call	#26828		;#0x68cc
    77ea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    77ee:	0c 93       	cmp	#0,	r12	;r3 As==00
    77f0:	02 24       	jz	$+6      	;abs 0x77f6

000077f2 <.Loc.174.3>:
    77f2:	b0 12 e8 68 	call	#26856		;#0x68e8

000077f6 <.L7>:
    77f6:	b0 12 b6 65 	call	#26038		;#0x65b6

000077fa <.Loc.175.3>:
}
    77fa:	03 43       	nop			
    77fc:	b4 17       	popm	#12,	r15	;16-bit words
    77fe:	00 13       	reti			

00007800 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    7800:	b2 40 f9 00 	mov	#249,	&0x03d2	;#0x00f9
    7804:	d2 03 

00007806 <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    7806:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    780a:	c2 03 

0000780c <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    780c:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00007810 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    7810:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    7814:	c0 03 

00007816 <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    7816:	03 43       	nop			
    7818:	30 41       	ret			

0000781a <port_lock_from_isr>:
}
    781a:	03 43       	nop			
    781c:	30 41       	ret			

0000781e <port_unlock_from_isr>:
}
    781e:	03 43       	nop			
    7820:	30 41       	ret			

00007822 <osalSysLockFromISR>:
  chSysLockFromISR();
    7822:	b0 12 1a 78 	call	#30746		;#0x781a
    7826:	b0 12 d8 65 	call	#26072		;#0x65d8

0000782a <.Loc.527.2>:
}
    782a:	03 43       	nop			
    782c:	30 41       	ret			

0000782e <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    782e:	b0 12 fa 65 	call	#26106		;#0x65fa
    7832:	b0 12 1e 78 	call	#30750		;#0x781e

00007836 <.Loc.538.2>:
}
    7836:	03 43       	nop			
    7838:	30 41       	ret			

0000783a <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    783a:	0a 15       	pushm	#1,	r10	;16-bit words

0000783c <.LCFI0>:
    783c:	31 80 06 00 	sub	#6,	r1	;

00007840 <.LCFI1>:
    7840:	81 4c 04 00 	mov	r12,	4(r1)	;
    7844:	81 4d 00 00 	mov	r13,	0(r1)	;
    7848:	81 4e 02 00 	mov	r14,	2(r1)	;

0000784c <.Loc.828.2>:
  esp->flags |= flags;
    784c:	1c 41 04 00 	mov	4(r1),	r12	;
    7850:	1d 4c 02 00 	mov	2(r12),	r13	;
    7854:	2c 4c       	mov	@r12,	r12	;
    7856:	2a 41       	mov	@r1,	r10	;
    7858:	0a dc       	bis	r12,	r10	;
    785a:	1b 41 02 00 	mov	2(r1),	r11	;
    785e:	0b dd       	bis	r13,	r11	;
    7860:	1c 41 04 00 	mov	4(r1),	r12	;
    7864:	8c 4a 00 00 	mov	r10,	0(r12)	;
    7868:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000786c <.Loc.829.2>:
  if (esp->cb != NULL) {
    786c:	1c 41 04 00 	mov	4(r1),	r12	;
    7870:	1c 4c 04 00 	mov	4(r12),	r12	;
    7874:	0c 93       	cmp	#0,	r12	;r3 As==00
    7876:	07 24       	jz	$+16     	;abs 0x7886

00007878 <.Loc.830.2>:
    esp->cb(esp);
    7878:	1c 41 04 00 	mov	4(r1),	r12	;
    787c:	1d 4c 04 00 	mov	4(r12),	r13	;
    7880:	1c 41 04 00 	mov	4(r1),	r12	;
    7884:	8d 12       	call	r13		;

00007886 <.L7>:
}
    7886:	03 43       	nop			
    7888:	31 50 06 00 	add	#6,	r1	;
    788c:	0a 17       	popm	#1,	r10	;16-bit words
    788e:	30 41       	ret			

00007890 <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    7890:	21 83       	decd	r1		;

00007892 <.LCFI2>:
    7892:	81 4c 00 00 	mov	r12,	0(r1)	;

00007896 <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    7896:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    789a:	2c 91       	cmp	@r1,	r12	;
    789c:	02 28       	jnc	$+6      	;abs 0x78a2

0000789e <.Loc.108.3>:
    return 0x00;
    789e:	4c 43       	clr.b	r12		;
    78a0:	ec 3c       	jmp	$+474    	;abs 0x7a7a

000078a2 <.L9>:
  else if (frac < 715)
    78a2:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    78a6:	2c 91       	cmp	@r1,	r12	;
    78a8:	02 28       	jnc	$+6      	;abs 0x78ae

000078aa <.Loc.110.3>:
    return 0x01;
    78aa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    78ac:	e6 3c       	jmp	$+462    	;abs 0x7a7a

000078ae <.L11>:
  else if (frac < 835)
    78ae:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    78b2:	2c 91       	cmp	@r1,	r12	;
    78b4:	02 28       	jnc	$+6      	;abs 0x78ba

000078b6 <.Loc.112.3>:
    return 0x02;
    78b6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    78b8:	e0 3c       	jmp	$+450    	;abs 0x7a7a

000078ba <.L12>:
  else if (frac < 1001)
    78ba:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    78be:	2c 91       	cmp	@r1,	r12	;
    78c0:	02 28       	jnc	$+6      	;abs 0x78c6

000078c2 <.Loc.114.3>:
    return 0x04;
    78c2:	6c 42       	mov.b	#4,	r12	;r2 As==10
    78c4:	da 3c       	jmp	$+438    	;abs 0x7a7a

000078c6 <.L13>:
  else if (frac < 1252)
    78c6:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    78ca:	2c 91       	cmp	@r1,	r12	;
    78cc:	02 28       	jnc	$+6      	;abs 0x78d2

000078ce <.Loc.116.3>:
    return 0x08;
    78ce:	7c 42       	mov.b	#8,	r12	;r2 As==11
    78d0:	d4 3c       	jmp	$+426    	;abs 0x7a7a

000078d2 <.L14>:
  else if (frac < 1430)
    78d2:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    78d6:	2c 91       	cmp	@r1,	r12	;
    78d8:	03 28       	jnc	$+8      	;abs 0x78e0

000078da <.Loc.118.3>:
    return 0x10;
    78da:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    78de:	cd 3c       	jmp	$+412    	;abs 0x7a7a

000078e0 <.L15>:
  else if (frac < 1670)
    78e0:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    78e4:	2c 91       	cmp	@r1,	r12	;
    78e6:	03 28       	jnc	$+8      	;abs 0x78ee

000078e8 <.Loc.120.3>:
    return 0x20;
    78e8:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    78ec:	c6 3c       	jmp	$+398    	;abs 0x7a7a

000078ee <.L16>:
  else if (frac < 2147)
    78ee:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    78f2:	2c 91       	cmp	@r1,	r12	;
    78f4:	03 28       	jnc	$+8      	;abs 0x78fc

000078f6 <.Loc.122.3>:
    return 0x11;
    78f6:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    78fa:	bf 3c       	jmp	$+384    	;abs 0x7a7a

000078fc <.L17>:
  else if (frac < 2224)
    78fc:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    7900:	2c 91       	cmp	@r1,	r12	;
    7902:	03 28       	jnc	$+8      	;abs 0x790a

00007904 <.Loc.124.3>:
    return 0x21;
    7904:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    7908:	b8 3c       	jmp	$+370    	;abs 0x7a7a

0000790a <.L18>:
  else if (frac < 2503)
    790a:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    790e:	2c 91       	cmp	@r1,	r12	;
    7910:	03 28       	jnc	$+8      	;abs 0x7918

00007912 <.Loc.126.3>:
    return 0x22;
    7912:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    7916:	b1 3c       	jmp	$+356    	;abs 0x7a7a

00007918 <.L19>:
  else if (frac < 3000)
    7918:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    791c:	2c 91       	cmp	@r1,	r12	;
    791e:	03 28       	jnc	$+8      	;abs 0x7926

00007920 <.Loc.128.3>:
    return 0x44;
    7920:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    7924:	aa 3c       	jmp	$+342    	;abs 0x7a7a

00007926 <.L20>:
  else if (frac < 3335)
    7926:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    792a:	2c 91       	cmp	@r1,	r12	;
    792c:	03 28       	jnc	$+8      	;abs 0x7934

0000792e <.Loc.130.3>:
    return 0x25;
    792e:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    7932:	a3 3c       	jmp	$+328    	;abs 0x7a7a

00007934 <.L21>:
  else if (frac < 3575)
    7934:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    7938:	2c 91       	cmp	@r1,	r12	;
    793a:	03 28       	jnc	$+8      	;abs 0x7942

0000793c <.Loc.132.3>:
    return 0x49;
    793c:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    7940:	9c 3c       	jmp	$+314    	;abs 0x7a7a

00007942 <.L22>:
  else if (frac < 3753)
    7942:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    7946:	2c 91       	cmp	@r1,	r12	;
    7948:	03 28       	jnc	$+8      	;abs 0x7950

0000794a <.Loc.134.3>:
    return 0x4A;
    794a:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    794e:	95 3c       	jmp	$+300    	;abs 0x7a7a

00007950 <.L23>:
  else if (frac < 4003)
    7950:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    7954:	2c 91       	cmp	@r1,	r12	;
    7956:	03 28       	jnc	$+8      	;abs 0x795e

00007958 <.Loc.136.3>:
    return 0x52;
    7958:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    795c:	8e 3c       	jmp	$+286    	;abs 0x7a7a

0000795e <.L24>:
  else if (frac < 4286)
    795e:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    7962:	2c 91       	cmp	@r1,	r12	;
    7964:	03 28       	jnc	$+8      	;abs 0x796c

00007966 <.Loc.138.3>:
    return 0x92;
    7966:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    796a:	87 3c       	jmp	$+272    	;abs 0x7a7a

0000796c <.L25>:
  else if (frac < 4378)
    796c:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    7970:	2c 91       	cmp	@r1,	r12	;
    7972:	03 28       	jnc	$+8      	;abs 0x797a

00007974 <.Loc.140.3>:
    return 0x53;
    7974:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    7978:	80 3c       	jmp	$+258    	;abs 0x7a7a

0000797a <.L26>:
  else if (frac < 5002)
    797a:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    797e:	2c 91       	cmp	@r1,	r12	;
    7980:	03 28       	jnc	$+8      	;abs 0x7988

00007982 <.Loc.142.3>:
    return 0x55;
    7982:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    7986:	79 3c       	jmp	$+244    	;abs 0x7a7a

00007988 <.L27>:
  else if (frac < 5715)
    7988:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    798c:	2c 91       	cmp	@r1,	r12	;
    798e:	03 28       	jnc	$+8      	;abs 0x7996

00007990 <.Loc.144.3>:
    return 0xAA;
    7990:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    7994:	72 3c       	jmp	$+230    	;abs 0x7a7a

00007996 <.L28>:
  else if (frac < 6003)
    7996:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    799a:	2c 91       	cmp	@r1,	r12	;
    799c:	03 28       	jnc	$+8      	;abs 0x79a4

0000799e <.Loc.146.3>:
    return 0x6B;
    799e:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    79a2:	6b 3c       	jmp	$+216    	;abs 0x7a7a

000079a4 <.L29>:
  else if (frac < 6254)
    79a4:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    79a8:	2c 91       	cmp	@r1,	r12	;
    79aa:	03 28       	jnc	$+8      	;abs 0x79b2

000079ac <.Loc.148.3>:
    return 0xAD;
    79ac:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    79b0:	64 3c       	jmp	$+202    	;abs 0x7a7a

000079b2 <.L30>:
  else if (frac < 6432)
    79b2:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    79b6:	2c 91       	cmp	@r1,	r12	;
    79b8:	03 28       	jnc	$+8      	;abs 0x79c0

000079ba <.Loc.150.3>:
    return 0xB5;
    79ba:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    79be:	5d 3c       	jmp	$+188    	;abs 0x7a7a

000079c0 <.L31>:
  else if (frac < 6667)
    79c0:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    79c4:	2c 91       	cmp	@r1,	r12	;
    79c6:	03 28       	jnc	$+8      	;abs 0x79ce

000079c8 <.Loc.152.3>:
    return 0xB6;
    79c8:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    79cc:	56 3c       	jmp	$+174    	;abs 0x7a7a

000079ce <.L32>:
  else if (frac < 7001)
    79ce:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    79d2:	2c 91       	cmp	@r1,	r12	;
    79d4:	03 28       	jnc	$+8      	;abs 0x79dc

000079d6 <.Loc.154.3>:
    return 0xD6;
    79d6:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    79da:	4f 3c       	jmp	$+160    	;abs 0x7a7a

000079dc <.L33>:
  else if (frac < 7147)
    79dc:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    79e0:	2c 91       	cmp	@r1,	r12	;
    79e2:	03 28       	jnc	$+8      	;abs 0x79ea

000079e4 <.Loc.156.3>:
    return 0xB7;
    79e4:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    79e8:	48 3c       	jmp	$+146    	;abs 0x7a7a

000079ea <.L34>:
  else if (frac < 7503)
    79ea:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    79ee:	2c 91       	cmp	@r1,	r12	;
    79f0:	03 28       	jnc	$+8      	;abs 0x79f8

000079f2 <.Loc.158.3>:
    return 0xBB;
    79f2:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    79f6:	41 3c       	jmp	$+132    	;abs 0x7a7a

000079f8 <.L35>:
  else if (frac < 7861)
    79f8:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    79fc:	2c 91       	cmp	@r1,	r12	;
    79fe:	03 28       	jnc	$+8      	;abs 0x7a06

00007a00 <.Loc.160.3>:
    return 0xDD;
    7a00:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    7a04:	3a 3c       	jmp	$+118    	;abs 0x7a7a

00007a06 <.L36>:
  else if (frac < 8004)
    7a06:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    7a0a:	2c 91       	cmp	@r1,	r12	;
    7a0c:	03 28       	jnc	$+8      	;abs 0x7a14

00007a0e <.Loc.162.3>:
    return 0xED;
    7a0e:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    7a12:	33 3c       	jmp	$+104    	;abs 0x7a7a

00007a14 <.L37>:
  else if (frac < 8333)
    7a14:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    7a18:	2c 91       	cmp	@r1,	r12	;
    7a1a:	03 28       	jnc	$+8      	;abs 0x7a22

00007a1c <.Loc.164.3>:
    return 0xEE;
    7a1c:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    7a20:	2c 3c       	jmp	$+90     	;abs 0x7a7a

00007a22 <.L38>:
  else if (frac < 8464)
    7a22:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    7a26:	2c 91       	cmp	@r1,	r12	;
    7a28:	03 28       	jnc	$+8      	;abs 0x7a30

00007a2a <.Loc.166.3>:
    return 0xBF;
    7a2a:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    7a2e:	25 3c       	jmp	$+76     	;abs 0x7a7a

00007a30 <.L39>:
  else if (frac < 8572)
    7a30:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    7a34:	2c 91       	cmp	@r1,	r12	;
    7a36:	03 28       	jnc	$+8      	;abs 0x7a3e

00007a38 <.Loc.168.3>:
    return 0xDF;
    7a38:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    7a3c:	1e 3c       	jmp	$+62     	;abs 0x7a7a

00007a3e <.L40>:
  else if (frac < 8751)
    7a3e:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    7a42:	2c 91       	cmp	@r1,	r12	;
    7a44:	03 28       	jnc	$+8      	;abs 0x7a4c

00007a46 <.Loc.170.3>:
    return 0xEF;
    7a46:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    7a4a:	17 3c       	jmp	$+48     	;abs 0x7a7a

00007a4c <.L41>:
  else if (frac < 9004)
    7a4c:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    7a50:	2c 91       	cmp	@r1,	r12	;
    7a52:	03 28       	jnc	$+8      	;abs 0x7a5a

00007a54 <.Loc.172.3>:
    return 0xF7;
    7a54:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    7a58:	10 3c       	jmp	$+34     	;abs 0x7a7a

00007a5a <.L42>:
  else if (frac < 9170)
    7a5a:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    7a5e:	2c 91       	cmp	@r1,	r12	;
    7a60:	03 28       	jnc	$+8      	;abs 0x7a68

00007a62 <.Loc.174.3>:
    return 0xFB;
    7a62:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    7a66:	09 3c       	jmp	$+20     	;abs 0x7a7a

00007a68 <.L43>:
  else if (frac < 9288)
    7a68:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    7a6c:	2c 91       	cmp	@r1,	r12	;
    7a6e:	03 28       	jnc	$+8      	;abs 0x7a76

00007a70 <.Loc.176.3>:
    return 0xFD;
    7a70:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    7a74:	02 3c       	jmp	$+6      	;abs 0x7a7a

00007a76 <.L44>:
  else
    return 0xFE;
    7a76:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00007a7a <.L10>:
}
    7a7a:	21 53       	incd	r1		;
    7a7c:	30 41       	ret			

00007a7e <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    7a7e:	0a 15       	pushm	#1,	r10	;16-bit words

00007a80 <.LCFI3>:
    7a80:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00007a84 <.LCFI4>:
    7a84:	81 4c 04 00 	mov	r12,	4(r1)	;
    7a88:	81 4d 06 00 	mov	r13,	6(r1)	;
    7a8c:	81 4e 00 00 	mov	r14,	0(r1)	;
    7a90:	81 4f 02 00 	mov	r15,	2(r1)	;

00007a94 <.Loc.191.3>:

  uint16_t n = freq / baud;
    7a94:	1e 41 04 00 	mov	4(r1),	r14	;
    7a98:	1f 41 06 00 	mov	6(r1),	r15	;
    7a9c:	2c 41       	mov	@r1,	r12	;
    7a9e:	1d 41 02 00 	mov	2(r1),	r13	;
    7aa2:	b0 12 64 9c 	call	#-25500	;#0x9c64
    7aa6:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007aaa <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    7aaa:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7aae:	0c 4e       	mov	r14,	r12	;
    7ab0:	0d 43       	clr	r13		;
    7ab2:	1e 41 04 00 	mov	4(r1),	r14	;
    7ab6:	1f 41 06 00 	mov	6(r1),	r15	;
    7aba:	b0 12 9a 9d 	call	#-25190	;#0x9d9a
    7abe:	0e 4c       	mov	r12,	r14	;
    7ac0:	0f 4d       	mov	r13,	r15	;
    7ac2:	2c 41       	mov	@r1,	r12	;

00007ac4 <L0>:
    7ac4:	1d 41 02 00 	mov	2(r1),	r13	;
    7ac8:	0c 8e       	sub	r14,	r12	;
    7aca:	0d 7f       	subc	r15,	r13	;
    7acc:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    7ad0:	4f 43       	clr.b	r15		;
    7ad2:	b0 12 9a 9d 	call	#-25190	;#0x9d9a
    7ad6:	1e 41 04 00 	mov	4(r1),	r14	;
    7ada:	1f 41 06 00 	mov	6(r1),	r15	;
    7ade:	b0 12 64 9c 	call	#-25500	;#0x9c64
    7ae2:	81 4c 08 00 	mov	r12,	8(r1)	;

00007ae6 <.Loc.194.3>:
  if (n > 16) {
    7ae6:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7aea:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7aee:	19 2c       	jc	$+52     	;abs 0x7b22

00007af0 <.Loc.195.3>:
    while (n > 16) {
    7af0:	03 3c       	jmp	$+8      	;abs 0x7af8

00007af2 <.L48>:
      n -= 16;
    7af2:	b1 50 f0 ff 	add	#-16,	10(r1)	;#0xfff0, 0x000a
    7af6:	0a 00 

00007af8 <.L47>:
    while (n > 16) {
    7af8:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7afc:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7b00:	f8 2b       	jnc	$-14     	;abs 0x7af2

00007b02 <.Loc.198.3>:
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    7b02:	1c 41 08 00 	mov	8(r1),	r12	;
    7b06:	b0 12 90 78 	call	#30864		;#0x7890
    7b0a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7b0e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7b12:	0a 4c       	mov	r12,	r10	;
    7b14:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7b18:	b0 12 88 9c 	call	#-25464	;#0x9c88
    7b1c:	0c da       	bis	r10,	r12	;
    7b1e:	1c d3       	bis	#1,	r12	;r3 As==01
    7b20:	08 3c       	jmp	$+18     	;abs 0x7b32

00007b22 <.L46>:
  }
  return UCBRS(frac) << 8;
    7b22:	1c 41 08 00 	mov	8(r1),	r12	;
    7b26:	b0 12 90 78 	call	#30864		;#0x7890
    7b2a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7b2e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

00007b32 <.L49>:
}
    7b32:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7b36:	0a 17       	popm	#1,	r10	;16-bit words
    7b38:	30 41       	ret			

00007b3a <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    7b3a:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00007b3e <L0>:
    7b3e:	81 4c 04 00 	mov	r12,	4(r1)	;
    7b42:	81 4d 06 00 	mov	r13,	6(r1)	;
    7b46:	81 4e 00 00 	mov	r14,	0(r1)	;
    7b4a:	81 4f 02 00 	mov	r15,	2(r1)	;

00007b4e <.Loc.212.3>:
  uint16_t n = freq / baud;
    7b4e:	1e 41 04 00 	mov	4(r1),	r14	;
    7b52:	1f 41 06 00 	mov	6(r1),	r15	;
    7b56:	2c 41       	mov	@r1,	r12	;
    7b58:	1d 41 02 00 	mov	2(r1),	r13	;
    7b5c:	b0 12 64 9c 	call	#-25500	;#0x9c64
    7b60:	81 4c 08 00 	mov	r12,	8(r1)	;

00007b64 <.Loc.213.3>:
  if (n > 16) {
    7b64:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7b68:	1c 91 08 00 	cmp	8(r1),	r12	;
    7b6c:	05 2c       	jc	$+12     	;abs 0x7b78

00007b6e <.Loc.214.3>:
    return n >> 4;
    7b6e:	1c 41 08 00 	mov	8(r1),	r12	;
    7b72:	b0 12 12 9d 	call	#-25326	;#0x9d12
    7b76:	02 3c       	jmp	$+6      	;abs 0x7b7c

00007b78 <.L51>:
  }
  return n;
    7b78:	1c 41 08 00 	mov	8(r1),	r12	;

00007b7c <.L52>:
}
    7b7c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    7b80:	30 41       	ret			

00007b82 <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    7b82:	21 83       	decd	r1		;

00007b84 <L0>:
    7b84:	81 4c 00 00 	mov	r12,	0(r1)	;

00007b88 <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7b88:	2c 41       	mov	@r1,	r12	;
    7b8a:	1d 4c 02 00 	mov	2(r12),	r13	;
    7b8e:	2c 4c       	mov	@r12,	r12	;
    7b90:	3e 40 90 d0 	mov	#-12144,r14	;#0xd090
    7b94:	7f 40 03 00 	mov.b	#3,	r15	;
    7b98:	b0 12 3a 7b 	call	#31546		;#0x7b3a
    7b9c:	82 4c c6 05 	mov	r12,	&0x05c6	;

00007ba0 <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7ba0:	2c 41       	mov	@r1,	r12	;
    7ba2:	1d 4c 02 00 	mov	2(r12),	r13	;
    7ba6:	2c 4c       	mov	@r12,	r12	;
    7ba8:	3e 40 90 d0 	mov	#-12144,r14	;#0xd090
    7bac:	7f 40 03 00 	mov.b	#3,	r15	;
    7bb0:	b0 12 7e 7a 	call	#31358		;#0x7a7e
    7bb4:	82 4c c8 05 	mov	r12,	&0x05c8	;

00007bb8 <.Loc.223.3>:
  UCA0STATW = 0;
    7bb8:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

00007bbc <.Loc.224.3>:
  UCA0ABCTL = 0;
    7bbc:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

00007bc0 <.Loc.225.3>:
  UCA0IRCTL = 0;
    7bc0:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

00007bc4 <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    7bc4:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    7bc8:	c0 05 

00007bca <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    7bca:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

00007bce <.Loc.230.3>:
}
    7bce:	03 43       	nop			
    7bd0:	21 53       	incd	r1		;
    7bd2:	30 41       	ret			

00007bd4 <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    7bd4:	21 83       	decd	r1		;

00007bd6 <.LCFI7>:
    7bd6:	81 4c 00 00 	mov	r12,	0(r1)	;

00007bda <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    7bda:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7bde:	2c d3       	bis	#2,	r12	;r3 As==10
    7be0:	82 4c da 05 	mov	r12,	&0x05da	;

00007be4 <.Loc.280.3>:
}
    7be4:	03 43       	nop			
    7be6:	21 53       	incd	r1		;
    7be8:	30 41       	ret			

00007bea <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    7bea:	31 82       	sub	#8,	r1	;r2 As==11

00007bec <.LCFI8>:
    7bec:	81 4c 02 00 	mov	r12,	2(r1)	;
    7bf0:	81 4d 00 00 	mov	r13,	0(r1)	;

00007bf4 <.Loc.314.3>:
  eventflags_t sts = 0;
    7bf4:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7bf8:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00007bfc <.Loc.316.3>:

  if (sra & UCOE)
    7bfc:	1c 41 02 00 	mov	2(r1),	r12	;
    7c00:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    7c04:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c06:	05 24       	jz	$+12     	;abs 0x7c12

00007c08 <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    7c08:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    7c0c:	04 00 
    7c0e:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007c12 <.L56>:
  if (sra & UCPE)
    7c12:	1c 41 02 00 	mov	2(r1),	r12	;
    7c16:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7c1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c1c:	05 24       	jz	$+12     	;abs 0x7c28

00007c1e <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    7c1e:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    7c22:	04 00 
    7c24:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007c28 <.L57>:
  if (sra & UCFE)
    7c28:	1c 41 02 00 	mov	2(r1),	r12	;
    7c2c:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    7c30:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c32:	05 24       	jz	$+12     	;abs 0x7c3e

00007c34 <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    7c34:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    7c38:	04 00 
    7c3a:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007c3e <.L58>:
  osalSysLockFromISR();
    7c3e:	b0 12 22 78 	call	#30754		;#0x7822

00007c42 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    7c42:	2c 41       	mov	@r1,	r12	;
    7c44:	2c 53       	incd	r12		;
    7c46:	1d 41 04 00 	mov	4(r1),	r13	;
    7c4a:	1e 41 06 00 	mov	6(r1),	r14	;
    7c4e:	b0 12 3a 78 	call	#30778		;#0x783a

00007c52 <.Loc.324.3>:
  osalSysUnlockFromISR();
    7c52:	b0 12 2e 78 	call	#30766		;#0x782e

00007c56 <.Loc.325.3>:
}
    7c56:	03 43       	nop			
    7c58:	31 52       	add	#8,	r1	;r2 As==11
    7c5a:	30 41       	ret			

00007c5c <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    7c5c:	bf 15       	pushm	#12,	r15	;16-bit words

00007c5e <.LCFI9>:
    7c5e:	21 83       	decd	r1		;

00007c60 <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    7c60:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    7c64:	b0 12 1e 66 	call	#26142		;#0x661e

00007c68 <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    7c68:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    7c6c:	2c 92       	cmp	#4,	r12	;r2 As==10
    7c6e:	1e 24       	jz	$+62     	;abs 0x7cac
    7c70:	3c 92       	cmp	#8,	r12	;r2 As==11
    7c72:	40 24       	jz	$+130    	;abs 0x7cf4
    7c74:	2c 93       	cmp	#2,	r12	;r3 As==10
    7c76:	01 24       	jz	$+4      	;abs 0x7c7a

00007c78 <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    7c78:	60 3c       	jmp	$+194    	;abs 0x7d3a

00007c7a <.L63>:
    if (UCA0STATW & UCRXERR)
    7c7a:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7c7e:	6c f2       	and.b	#4,	r12	;r2 As==10
    7c80:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c82:	06 24       	jz	$+14     	;abs 0x7c90

00007c84 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    7c84:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7c88:	3d 40 ea 51 	mov	#20970,	r13	;#0x51ea
    7c8c:	b0 12 ea 7b 	call	#31722		;#0x7bea

00007c90 <.L64>:
    osalSysLockFromISR();
    7c90:	b0 12 22 78 	call	#30754		;#0x7822

00007c94 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    7c94:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    7c98:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7c9c:	4d 4c       	mov.b	r12,	r13	;
    7c9e:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    7ca2:	b0 12 e2 76 	call	#30434		;#0x76e2

00007ca6 <.Loc.352.3>:
    osalSysUnlockFromISR();
    7ca6:	b0 12 2e 78 	call	#30766		;#0x782e

00007caa <.Loc.353.3>:
    break;
    7caa:	47 3c       	jmp	$+144    	;abs 0x7d3a

00007cac <.L61>:
    osalSysLockFromISR();
    7cac:	b0 12 22 78 	call	#30754		;#0x7822

00007cb0 <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    7cb0:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    7cb4:	b0 12 34 77 	call	#30516		;#0x7734
    7cb8:	81 4c 00 00 	mov	r12,	0(r1)	;

00007cbc <.Loc.360.3>:
    if (b < Q_OK) {
    7cbc:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7cc0:	13 34       	jge	$+40     	;abs 0x7ce8

00007cc2 <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    7cc2:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7cc4:	4e 43       	clr.b	r14		;
    7cc6:	3c 40 ec 51 	mov	#20972,	r12	;#0x51ec
    7cca:	b0 12 3a 78 	call	#30778		;#0x783a

00007cce <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    7cce:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7cd2:	3c f0 f5 ff 	and	#-11,	r12	;#0xfff5
    7cd6:	3c d2       	bis	#8,	r12	;r2 As==11
    7cd8:	82 4c da 05 	mov	r12,	&0x05da	;

00007cdc <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    7cdc:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    7ce0:	2c d3       	bis	#2,	r12	;r3 As==10
    7ce2:	82 4c dc 05 	mov	r12,	&0x05dc	;
    7ce6:	03 3c       	jmp	$+8      	;abs 0x7cee

00007ce8 <.L66>:
      UCA0TXBUF = b;
    7ce8:	2c 41       	mov	@r1,	r12	;
    7cea:	82 4c ce 05 	mov	r12,	&0x05ce	;

00007cee <.L67>:
    osalSysUnlockFromISR();
    7cee:	b0 12 2e 78 	call	#30766		;#0x782e

00007cf2 <.Loc.368.3>:
    break;
    7cf2:	23 3c       	jmp	$+72     	;abs 0x7d3a

00007cf4 <.L62>:
    osalSysLockFromISR();
    7cf4:	b0 12 22 78 	call	#30754		;#0x7822

00007cf8 <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    7cf8:	1d 42 0e 52 	mov	&0x520e,r13	;0x520e
    7cfc:	1c 42 10 52 	mov	&0x5210,r12	;0x5210
    7d00:	0d 9c       	cmp	r12,	r13	;
    7d02:	06 20       	jnz	$+14     	;abs 0x7d10

00007d04 <.Loc.374.3>:
    7d04:	1c 42 08 52 	mov	&0x5208,r12	;0x5208
    7d08:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d0a:	02 24       	jz	$+6      	;abs 0x7d10

00007d0c <.Loc.374.3>:
    7d0c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d0e:	01 3c       	jmp	$+4      	;abs 0x7d12

00007d10 <.L68>:
    7d10:	4c 43       	clr.b	r12		;

00007d12 <.L69>:
    7d12:	5c f3       	and.b	#1,	r12	;r3 As==01
    7d14:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7d18:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d1a:	07 24       	jz	$+16     	;abs 0x7d2a

00007d1c <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    7d1c:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    7d20:	4e 43       	clr.b	r14		;
    7d22:	3c 40 ec 51 	mov	#20972,	r12	;#0x51ec
    7d26:	b0 12 3a 78 	call	#30778		;#0x783a

00007d2a <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    7d2a:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7d2e:	3c c2       	bic	#8,	r12	;r2 As==11
    7d30:	82 4c da 05 	mov	r12,	&0x05da	;

00007d34 <.Loc.377.3>:
    osalSysUnlockFromISR();
    7d34:	b0 12 2e 78 	call	#30766		;#0x782e

00007d38 <.Loc.378.3>:
    break;
    7d38:	03 43       	nop			

00007d3a <.L65>:
  }

  OSAL_IRQ_EPILOGUE();
    7d3a:	b0 12 4c 66 	call	#26188		;#0x664c
    7d3e:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    7d42:	b0 12 96 65 	call	#26006		;#0x6596
    7d46:	b0 12 cc 68 	call	#26828		;#0x68cc
    7d4a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7d4e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d50:	02 24       	jz	$+6      	;abs 0x7d56

00007d52 <.Loc.385.3>:
    7d52:	b0 12 e8 68 	call	#26856		;#0x68e8

00007d56 <.L71>:
    7d56:	b0 12 b6 65 	call	#26038		;#0x65b6

00007d5a <.Loc.386.3>:
}
    7d5a:	03 43       	nop			
    7d5c:	21 53       	incd	r1		;
    7d5e:	b4 17       	popm	#12,	r15	;16-bit words
    7d60:	00 13       	reti			

00007d62 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    7d62:	3e 40 d4 7b 	mov	#31700,	r14	;#0x7bd4
    7d66:	4d 43       	clr.b	r13		;
    7d68:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea

00007d6c <L0>:
    7d6c:	b0 12 44 76 	call	#30276		;#0x7644

00007d70 <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    7d70:	03 43       	nop			
    7d72:	30 41       	ret			

00007d74 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7d74:	21 82       	sub	#4,	r1	;r2 As==10

00007d76 <.LCFI11>:
    7d76:	81 4c 02 00 	mov	r12,	2(r1)	;
    7d7a:	81 4d 00 00 	mov	r13,	0(r1)	;

00007d7e <.Loc.603.3>:

  if (config == NULL) {
    7d7e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7d82:	03 20       	jnz	$+8      	;abs 0x7d8a

00007d84 <.Loc.604.3>:
    config = &default_config;
    7d84:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7d88:	00 00 

00007d8a <.L74>:
  }

  if (sdp->state == SD_STOP) {
    7d8a:	1c 41 02 00 	mov	2(r1),	r12	;
    7d8e:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7d92:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7d94:	07 20       	jnz	$+16     	;abs 0x7da4

00007d96 <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    7d96:	b1 90 ea 51 	cmp	#20970,	2(r1)	;#0x51ea
    7d9a:	02 00 
    7d9c:	03 20       	jnz	$+8      	;abs 0x7da4

00007d9e <.Loc.610.3>:
      usart0_init(config);
    7d9e:	2c 41       	mov	@r1,	r12	;
    7da0:	b0 12 82 7b 	call	#31618		;#0x7b82

00007da4 <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    7da4:	03 43       	nop			
    7da6:	21 52       	add	#4,	r1	;r2 As==10
    7da8:	30 41       	ret			

00007daa <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    7daa:	bf 15       	pushm	#12,	r15	;16-bit words

00007dac <.LCFI0>:
    7dac:	21 82       	sub	#4,	r1	;r2 As==10

00007dae <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7dae:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    7db2:	b0 12 1e 66 	call	#26142		;#0x661e

00007db6 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    7db6:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    7dba:	12 c3       	clrc			
    7dbc:	0c 10       	rrc	r12		;
    7dbe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7dc2:	4d 4c       	mov.b	r12,	r13	;
    7dc4:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7dc6:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007dca <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    7dca:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7dce:	0c 5c       	rla	r12		;
    7dd0:	3c 50 36 52 	add	#21046,	r12	;#0x5236
    7dd4:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007dd8 <.Loc.80.1>:
  if (cb != NULL) {
    7dd8:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7ddc:	02 24       	jz	$+6      	;abs 0x7de2

00007dde <.Loc.81.1>:
    (*cb)();
    7dde:	2c 41       	mov	@r1,	r12	;
    7de0:	8c 12       	call	r12		;

00007de2 <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7de2:	b0 12 4c 66 	call	#26188		;#0x664c
    7de6:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    7dea:	b0 12 96 65 	call	#26006		;#0x6596
    7dee:	b0 12 cc 68 	call	#26828		;#0x68cc
    7df2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7df6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7df8:	02 24       	jz	$+6      	;abs 0x7dfe

00007dfa <.Loc.84.1>:
    7dfa:	b0 12 e8 68 	call	#26856		;#0x68e8

00007dfe <.L3>:
    7dfe:	b0 12 b6 65 	call	#26038		;#0x65b6

00007e02 <.Loc.85.1>:
}
    7e02:	03 43       	nop			
    7e04:	21 52       	add	#4,	r1	;r2 As==10
    7e06:	b4 17       	popm	#12,	r15	;16-bit words
    7e08:	00 13       	reti			

00007e0a <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    7e0a:	bf 15       	pushm	#12,	r15	;16-bit words

00007e0c <.LCFI2>:
    7e0c:	21 82       	sub	#4,	r1	;r2 As==10

00007e0e <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7e0e:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    7e12:	b0 12 1e 66 	call	#26142		;#0x661e

00007e16 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    7e16:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    7e1a:	12 c3       	clrc			
    7e1c:	0c 10       	rrc	r12		;
    7e1e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e22:	4d 4c       	mov.b	r12,	r13	;
    7e24:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7e26:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007e2a <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    7e2a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7e2e:	3c 52       	add	#8,	r12	;r2 As==11
    7e30:	0c 5c       	rla	r12		;
    7e32:	3c 50 36 52 	add	#21046,	r12	;#0x5236
    7e36:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007e3a <.Loc.98.1>:
  if (cb != NULL) {
    7e3a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7e3e:	02 24       	jz	$+6      	;abs 0x7e44

00007e40 <.Loc.99.1>:
    (*cb)();
    7e40:	2c 41       	mov	@r1,	r12	;
    7e42:	8c 12       	call	r12		;

00007e44 <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7e44:	b0 12 4c 66 	call	#26188		;#0x664c
    7e48:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    7e4c:	b0 12 96 65 	call	#26006		;#0x6596
    7e50:	b0 12 cc 68 	call	#26828		;#0x68cc
    7e54:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e58:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e5a:	02 24       	jz	$+6      	;abs 0x7e60

00007e5c <.Loc.102.1>:
    7e5c:	b0 12 e8 68 	call	#26856		;#0x68e8

00007e60 <.L6>:
    7e60:	b0 12 b6 65 	call	#26038		;#0x65b6

00007e64 <.Loc.103.1>:
}
    7e64:	03 43       	nop			
    7e66:	21 52       	add	#4,	r1	;r2 As==10
    7e68:	b4 17       	popm	#12,	r15	;16-bit words
    7e6a:	00 13       	reti			

00007e6c <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    7e6c:	bf 15       	pushm	#12,	r15	;16-bit words

00007e6e <.LCFI4>:
    7e6e:	21 82       	sub	#4,	r1	;r2 As==10

00007e70 <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7e70:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    7e74:	b0 12 1e 66 	call	#26142		;#0x661e

00007e78 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    7e78:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    7e7c:	12 c3       	clrc			
    7e7e:	0c 10       	rrc	r12		;
    7e80:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e84:	4d 4c       	mov.b	r12,	r13	;
    7e86:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7e88:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007e8c <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    7e8c:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7e90:	3c 50 10 00 	add	#16,	r12	;#0x0010
    7e94:	0c 5c       	rla	r12		;
    7e96:	3c 50 36 52 	add	#21046,	r12	;#0x5236
    7e9a:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007e9e <.Loc.117.1>:
  if (cb != NULL) {
    7e9e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7ea2:	02 24       	jz	$+6      	;abs 0x7ea8

00007ea4 <.Loc.118.1>:
    (*cb)();
    7ea4:	2c 41       	mov	@r1,	r12	;
    7ea6:	8c 12       	call	r12		;

00007ea8 <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7ea8:	b0 12 4c 66 	call	#26188		;#0x664c
    7eac:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    7eb0:	b0 12 96 65 	call	#26006		;#0x6596
    7eb4:	b0 12 cc 68 	call	#26828		;#0x68cc
    7eb8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7ebc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ebe:	02 24       	jz	$+6      	;abs 0x7ec4

00007ec0 <.Loc.121.1>:
    7ec0:	b0 12 e8 68 	call	#26856		;#0x68e8

00007ec4 <.L9>:
    7ec4:	b0 12 b6 65 	call	#26038		;#0x65b6

00007ec8 <.Loc.122.1>:
}
    7ec8:	03 43       	nop			
    7eca:	21 52       	add	#4,	r1	;r2 As==10
    7ecc:	b4 17       	popm	#12,	r15	;16-bit words
    7ece:	00 13       	reti			

00007ed0 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    7ed0:	bf 15       	pushm	#12,	r15	;16-bit words

00007ed2 <.LCFI6>:
    7ed2:	21 82       	sub	#4,	r1	;r2 As==10

00007ed4 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7ed4:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    7ed8:	b0 12 1e 66 	call	#26142		;#0x661e

00007edc <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    7edc:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    7ee0:	12 c3       	clrc			
    7ee2:	0c 10       	rrc	r12		;
    7ee4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7ee8:	4d 4c       	mov.b	r12,	r13	;
    7eea:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7eec:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007ef0 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    7ef0:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7ef4:	3c 50 18 00 	add	#24,	r12	;#0x0018
    7ef8:	0c 5c       	rla	r12		;
    7efa:	3c 50 36 52 	add	#21046,	r12	;#0x5236
    7efe:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007f02 <.Loc.135.1>:
  if (cb != NULL) {
    7f02:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7f06:	02 24       	jz	$+6      	;abs 0x7f0c

00007f08 <.Loc.136.1>:
    (*cb)();
    7f08:	2c 41       	mov	@r1,	r12	;
    7f0a:	8c 12       	call	r12		;

00007f0c <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7f0c:	b0 12 4c 66 	call	#26188		;#0x664c
    7f10:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    7f14:	b0 12 96 65 	call	#26006		;#0x6596
    7f18:	b0 12 cc 68 	call	#26828		;#0x68cc
    7f1c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7f20:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f22:	02 24       	jz	$+6      	;abs 0x7f28

00007f24 <.Loc.139.1>:
    7f24:	b0 12 e8 68 	call	#26856		;#0x68e8

00007f28 <.L12>:
    7f28:	b0 12 b6 65 	call	#26038		;#0x65b6

00007f2c <.Loc.140.1>:
}
    7f2c:	03 43       	nop			
    7f2e:	21 52       	add	#4,	r1	;r2 As==10
    7f30:	b4 17       	popm	#12,	r15	;16-bit words
    7f32:	00 13       	reti			

00007f34 <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    7f34:	21 83       	decd	r1		;

00007f36 <.LCFI8>:
    7f36:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f3a <.Loc.309.1>:

  PAOUT = config->porta.out;
    7f3a:	2c 41       	mov	@r1,	r12	;
    7f3c:	2c 4c       	mov	@r12,	r12	;
    7f3e:	82 4c 02 02 	mov	r12,	&0x0202	;

00007f42 <.Loc.310.1>:
  PADIR = config->porta.dir;
    7f42:	2c 41       	mov	@r1,	r12	;
    7f44:	1c 4c 02 00 	mov	2(r12),	r12	;
    7f48:	82 4c 04 02 	mov	r12,	&0x0204	;

00007f4c <.Loc.311.1>:
  PAREN = config->porta.ren;
    7f4c:	2c 41       	mov	@r1,	r12	;
    7f4e:	1c 4c 04 00 	mov	4(r12),	r12	;
    7f52:	82 4c 06 02 	mov	r12,	&0x0206	;

00007f56 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7f56:	2c 41       	mov	@r1,	r12	;
    7f58:	1c 4c 06 00 	mov	6(r12),	r12	;
    7f5c:	82 4c 0a 02 	mov	r12,	&0x020a	;

00007f60 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    7f60:	2c 41       	mov	@r1,	r12	;
    7f62:	1c 4c 08 00 	mov	8(r12),	r12	;
    7f66:	82 4c 0c 02 	mov	r12,	&0x020c	;

00007f6a <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    7f6a:	2c 41       	mov	@r1,	r12	;
    7f6c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7f70:	82 4c 22 02 	mov	r12,	&0x0222	;

00007f74 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    7f74:	2c 41       	mov	@r1,	r12	;
    7f76:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7f7a:	82 4c 24 02 	mov	r12,	&0x0224	;

00007f7e <.Loc.317.1>:
  PBREN = config->portb.ren;
    7f7e:	2c 41       	mov	@r1,	r12	;
    7f80:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    7f84:	82 4c 26 02 	mov	r12,	&0x0226	;

00007f88 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7f88:	2c 41       	mov	@r1,	r12	;
    7f8a:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    7f8e:	82 4c 2a 02 	mov	r12,	&0x022a	;

00007f92 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    7f92:	2c 41       	mov	@r1,	r12	;
    7f94:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7f98:	82 4c 2c 02 	mov	r12,	&0x022c	;

00007f9c <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    7f9c:	2c 41       	mov	@r1,	r12	;
    7f9e:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    7fa2:	82 4c 22 03 	mov	r12,	&0x0322	;

00007fa6 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    7fa6:	2c 41       	mov	@r1,	r12	;
    7fa8:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    7fac:	82 4c 24 03 	mov	r12,	&0x0324	;

00007fb0 <.Loc.351.1>:
  PJREN = config->portj.ren;
    7fb0:	2c 41       	mov	@r1,	r12	;
    7fb2:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    7fb6:	82 4c 26 03 	mov	r12,	&0x0326	;

00007fba <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    7fba:	2c 41       	mov	@r1,	r12	;
    7fbc:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    7fc0:	82 4c 2a 03 	mov	r12,	&0x032a	;

00007fc4 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    7fc4:	2c 41       	mov	@r1,	r12	;
    7fc6:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    7fca:	82 4c 2c 03 	mov	r12,	&0x032c	;

00007fce <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    7fce:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    7fd2:	1c c3       	bic	#1,	r12	;r3 As==01
    7fd4:	82 4c 30 01 	mov	r12,	&0x0130	;

00007fd8 <.Loc.356.1>:
}
    7fd8:	03 43       	nop			
    7fda:	21 53       	incd	r1		;
    7fdc:	30 41       	ret			

00007fde <osalSysGetStatusAndLockX>:
  return chSysGetStatusAndLockX();
    7fde:	b0 12 16 68 	call	#26646		;#0x6816

00007fe2 <.Loc.556.2>:
}
    7fe2:	30 41       	ret			

00007fe4 <osalSysRestoreStatusX>:
static inline void osalSysRestoreStatusX(syssts_t sts) {
    7fe4:	21 83       	decd	r1		;

00007fe6 <.LCFI0>:
    7fe6:	81 4c 00 00 	mov	r12,	0(r1)	;

00007fea <.Loc.569.2>:
  chSysRestoreStatusX(sts);
    7fea:	2c 41       	mov	@r1,	r12	;
    7fec:	b0 12 52 68 	call	#26706		;#0x6852

00007ff0 <.Loc.570.2>:
}
    7ff0:	03 43       	nop			
    7ff2:	21 53       	incd	r1		;
    7ff4:	30 41       	ret			

00007ff6 <osalThreadQueueObjectInit>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    7ff6:	21 83       	decd	r1		;

00007ff8 <.LCFI1>:
    7ff8:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ffc <.Loc.767.2>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    7ffc:	2c 41       	mov	@r1,	r12	;
    7ffe:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00008002 <.Loc.768.2>:
}
    8002:	03 43       	nop			
    8004:	21 53       	incd	r1		;
    8006:	30 41       	ret			

00008008 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    8008:	0a 15       	pushm	#1,	r10	;16-bit words

0000800a <.LCFI3>:
    800a:	21 82       	sub	#4,	r1	;r2 As==10

0000800c <.LCFI4>:
    800c:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    8010:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

00008014 <.Loc.62.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    8014:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8018:	12 c3       	clrc			
    801a:	0c 10       	rrc	r12		;
    801c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8020:	0c 5c       	rla	r12		;
    8022:	0d 4c       	mov	r12,	r13	;
    8024:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    8028:	81 4d 02 00 	mov	r13,	2(r1)	;

0000802c <.Loc.63.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    802c:	1c 41 02 00 	mov	2(r1),	r12	;
    8030:	2a 4c       	mov	@r12,	r10	;
    8032:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8036:	5c f3       	and.b	#1,	r12	;r3 As==01
    8038:	0d 4c       	mov	r12,	r13	;
    803a:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    803e:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00
    8042:	b0 12 2a 9d 	call	#-25302	;#0x9d2a
    8046:	0d 4a       	mov	r10,	r13	;
    8048:	0d fc       	and	r12,	r13	;
    804a:	1c 41 02 00 	mov	2(r1),	r12	;
    804e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008052 <.Loc.64.3>:
  *ctl |= trigger << (8 * (index % 2));
    8052:	1c 41 02 00 	mov	2(r1),	r12	;
    8056:	2a 4c       	mov	@r12,	r10	;
    8058:	6c 41       	mov.b	@r1,	r12	;
    805a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    805e:	5d f3       	and.b	#1,	r13	;r3 As==01
    8060:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    8064:	b0 12 96 9c 	call	#-25450	;#0x9c96
    8068:	0d 4a       	mov	r10,	r13	;
    806a:	0d dc       	bis	r12,	r13	;
    806c:	1c 41 02 00 	mov	2(r1),	r12	;
    8070:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008074 <.Loc.65.3>:
}
    8074:	03 43       	nop			
    8076:	21 52       	add	#4,	r1	;r2 As==10
    8078:	0a 17       	popm	#1,	r10	;16-bit words
    807a:	30 41       	ret			

0000807c <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    807c:	bf 15       	pushm	#12,	r15	;16-bit words

0000807e <.LCFI5>:
    807e:	21 82       	sub	#4,	r1	;r2 As==10

00008080 <.LCFI6>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    8080:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    8084:	b0 12 1e 66 	call	#26142		;#0x661e

00008088 <.Loc.75.3>:

  index = (DMAIV >> 1) - 1;
    8088:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    808c:	12 c3       	clrc			
    808e:	0c 10       	rrc	r12		;
    8090:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8094:	4d 4c       	mov.b	r12,	r13	;
    8096:	7d 53       	add.b	#-1,	r13	;r3 As==11
    8098:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

0000809c <.Loc.77.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    809c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    809e:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    80a2:	3e 28       	jnc	$+126    	;abs 0x8120

000080a4 <.LBB2>:
    /* Set to idle mode (but still claimed) */
    dma_regs[index].ctl &= ~DMAEN;
    80a4:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    80a8:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80ac:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    80b0:	0d 5c       	add	r12,	r13	;
    80b2:	3e 40 10 05 	mov	#1296,	r14	;#0x0510
    80b6:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80ba:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    80be:	0c 5e       	add	r14,	r12	;
    80c0:	2c 4c       	mov	@r12,	r12	;
    80c2:	3c f0 ef ff 	and	#-17,	r12	;#0xffef
    80c6:	8d 4c 00 00 	mov	r12,	0(r13)	;

000080ca <.Loc.80.3>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    80ca:	4d 43       	clr.b	r13		;
    80cc:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80d0:	b0 12 08 80 	call	#-32760	;#0x8008

000080d4 <.Loc.81.3>:
    dma_regs[index].sz  = 0;
    80d4:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    80d8:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80dc:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    80e0:	0c 5d       	add	r13,	r12	;
    80e2:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000080e6 <.Loc.82.3>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    80e6:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    80ea:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80ee:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    80f2:	0c 5d       	add	r13,	r12	;
    80f4:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    80f8:	00 00 

000080fa <.Loc.84.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    80fa:	5c 41 03 00 	mov.b	3(r1),	r12	;
    80fe:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    8102:	0d 4c       	mov	r12,	r13	;
    8104:	3d 50 76 52 	add	#21110,	r13	;#0x5276
    8108:	81 4d 00 00 	mov	r13,	0(r1)	;

0000810c <.Loc.87.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    810c:	2c 41       	mov	@r1,	r12	;
    810e:	2c 4c       	mov	@r12,	r12	;
    8110:	0c 93       	cmp	#0,	r12	;r3 As==00
    8112:	06 24       	jz	$+14     	;abs 0x8120

00008114 <.Loc.88.3>:
      cb->callback(cb->args);
    8114:	2c 41       	mov	@r1,	r12	;
    8116:	2d 4c       	mov	@r12,	r13	;
    8118:	2c 41       	mov	@r1,	r12	;
    811a:	1c 4c 02 00 	mov	2(r12),	r12	;
    811e:	8d 12       	call	r13		;

00008120 <.L13>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    8120:	b0 12 4c 66 	call	#26188		;#0x664c
    8124:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    8128:	b0 12 96 65 	call	#26006		;#0x6596
    812c:	b0 12 cc 68 	call	#26828		;#0x68cc
    8130:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8134:	0c 93       	cmp	#0,	r12	;r3 As==00
    8136:	02 24       	jz	$+6      	;abs 0x813c

00008138 <.Loc.92.3>:
    8138:	b0 12 e8 68 	call	#26856		;#0x68e8

0000813c <.L14>:
    813c:	b0 12 b6 65 	call	#26038		;#0x65b6

00008140 <.Loc.93.3>:
}
    8140:	03 43       	nop			
    8142:	21 52       	add	#4,	r1	;r2 As==10
    8144:	b4 17       	popm	#12,	r15	;16-bit words
    8146:	00 13       	reti			

00008148 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    8148:	3c 40 82 52 	mov	#21122,	r12	;#0x5282
    814c:	b0 12 f6 7f 	call	#32758		;#0x7ff6

00008150 <.Loc.106.3>:
}
    8150:	03 43       	nop			
    8152:	30 41       	ret			

00008154 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    8154:	21 82       	sub	#4,	r1	;r2 As==10

00008156 <.LCFI8>:
    8156:	81 4c 00 00 	mov	r12,	0(r1)	;

0000815a <.Loc.188.3>:
  
  osalDbgCheckClassI();
    815a:	b0 12 7c 66 	call	#26236		;#0x667c

0000815e <.Loc.191.3>:

  /* Grab the correct DMA channel to use */
  int i = 0;
    815e:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00

00008162 <.Loc.192.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    8162:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8166:	0e 3c       	jmp	$+30     	;abs 0x8184

00008168 <.L24>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    8168:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    816c:	1c 41 02 00 	mov	2(r1),	r12	;
    8170:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8174:	0c 5d       	add	r13,	r12	;
    8176:	2c 4c       	mov	@r12,	r12	;
    8178:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    817c:	0c 93       	cmp	#0,	r12	;r3 As==00
    817e:	07 24       	jz	$+16     	;abs 0x818e

00008180 <.Loc.192.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    8180:	91 53 02 00 	inc	2(r1)		;

00008184 <.L21>:
    8184:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8186:	1c 91 02 00 	cmp	2(r1),	r12	;
    818a:	ee 37       	jge	$-34     	;abs 0x8168
    818c:	01 3c       	jmp	$+4      	;abs 0x8190

0000818e <.L27>:
      break;
    818e:	03 43       	nop			

00008190 <.L23>:
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    8190:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8192:	1c 91 02 00 	cmp	2(r1),	r12	;
    8196:	02 34       	jge	$+6      	;abs 0x819c

00008198 <.Loc.199.3>:
    return MSG_TIMEOUT;
    8198:	3c 43       	mov	#-1,	r12	;r3 As==11
    819a:	2b 3c       	jmp	$+88     	;abs 0x81f2

0000819c <.L25>:
  }
  
  /* Acquire the channel in an idle mode */
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    819c:	1c 41 02 00 	mov	2(r1),	r12	;
    81a0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    81a4:	4d 43       	clr.b	r13		;
    81a6:	b0 12 08 80 	call	#-32760	;#0x8008

000081aa <.Loc.204.3>:
  dma_regs[i].sz  = 0;
    81aa:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    81ae:	1c 41 02 00 	mov	2(r1),	r12	;
    81b2:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    81b6:	0c 5d       	add	r13,	r12	;
    81b8:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000081bc <.Loc.205.3>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    81bc:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    81c0:	1c 41 02 00 	mov	2(r1),	r12	;
    81c4:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    81c8:	0c 5d       	add	r13,	r12	;
    81ca:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    81ce:	00 00 

000081d0 <.Loc.207.3>:

  channel->registers = dma_regs + i;
    81d0:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    81d4:	1c 41 02 00 	mov	2(r1),	r12	;
    81d8:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    81dc:	0d 5c       	add	r12,	r13	;
    81de:	2c 41       	mov	@r1,	r12	;
    81e0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000081e4 <.Loc.208.3>:
  channel->index     = i;
    81e4:	1c 41 02 00 	mov	2(r1),	r12	;
    81e8:	4d 4c       	mov.b	r12,	r13	;
    81ea:	2c 41       	mov	@r1,	r12	;
    81ec:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

000081f0 <.Loc.210.3>:
  
  return MSG_OK;
    81f0:	4c 43       	clr.b	r12		;

000081f2 <.L26>:
}
    81f2:	21 52       	add	#4,	r1	;r2 As==10
    81f4:	30 41       	ret			

000081f6 <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    81f6:	21 82       	sub	#4,	r1	;r2 As==10

000081f8 <.LCFI9>:
    81f8:	81 4c 02 00 	mov	r12,	2(r1)	;

000081fc <L0>:
    81fc:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008200 <.Loc.229.3>:
  
  osalDbgCheckClassI();
    8200:	b0 12 7c 66 	call	#26236		;#0x667c

00008204 <.Loc.233.3>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_regs[index].ctl & DMAEN) {
    8204:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    8208:	5c 41 01 00 	mov.b	1(r1),	r12	;
    820c:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8210:	0c 5d       	add	r13,	r12	;
    8212:	2c 4c       	mov	@r12,	r12	;
    8214:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8218:	0c 93       	cmp	#0,	r12	;r3 As==00
    821a:	02 24       	jz	$+6      	;abs 0x8220

0000821c <.Loc.234.3>:
    return MSG_TIMEOUT;
    821c:	3c 43       	mov	#-1,	r12	;r3 As==11
    821e:	29 3c       	jmp	$+84     	;abs 0x8272

00008220 <.L29>:
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    8220:	4d 43       	clr.b	r13		;
    8222:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8226:	b0 12 08 80 	call	#-32760	;#0x8008

0000822a <.Loc.239.3>:
  dma_regs[index].sz  = 0;
    822a:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    822e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8232:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8236:	0c 5d       	add	r13,	r12	;
    8238:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000823c <.Loc.240.3>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    823c:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    8240:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8244:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8248:	0c 5d       	add	r13,	r12	;
    824a:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    824e:	00 00 

00008250 <.Loc.242.3>:

  channel->registers = dma_regs + index;
    8250:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    8254:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8258:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    825c:	0d 5c       	add	r12,	r13	;
    825e:	1c 41 02 00 	mov	2(r1),	r12	;
    8262:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008266 <.Loc.243.3>:
  channel->index     = index;
    8266:	1c 41 02 00 	mov	2(r1),	r12	;
    826a:	dc 41 01 00 	mov.b	1(r1),	2(r12)	;
    826e:	02 00 

00008270 <.Loc.245.3>:
  
  return MSG_OK;
    8270:	4c 43       	clr.b	r12		;

00008272 <.L30>:
}
    8272:	21 52       	add	#4,	r1	;r2 As==10
    8274:	30 41       	ret			

00008276 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    8276:	21 82       	sub	#4,	r1	;r2 As==10

00008278 <L0>:
    8278:	81 4c 02 00 	mov	r12,	2(r1)	;
    827c:	81 4d 00 00 	mov	r13,	0(r1)	;

00008280 <.Loc.275.3>:

  osalDbgCheckClassI();
    8280:	b0 12 7c 66 	call	#26236		;#0x667c

00008284 <.Loc.277.3>:

  channel->registers->ctl &= (~DMAEN);
    8284:	1c 41 02 00 	mov	2(r1),	r12	;
    8288:	2c 4c       	mov	@r12,	r12	;
    828a:	1d 41 02 00 	mov	2(r1),	r13	;
    828e:	2d 4d       	mov	@r13,	r13	;
    8290:	2d 4d       	mov	@r13,	r13	;
    8292:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8296:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000829a <.Loc.278.3>:
  dma_trigger_set(channel->index, request->trigger);
    829a:	1c 41 02 00 	mov	2(r1),	r12	;
    829e:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    82a2:	2d 41       	mov	@r1,	r13	;
    82a4:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    82a8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    82ac:	b0 12 08 80 	call	#-32760	;#0x8008

000082b0 <.Loc.279.3>:
  callbacks[channel->index] = request->callback;
    82b0:	1c 41 02 00 	mov	2(r1),	r12	;
    82b4:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    82b8:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    82bc:	3c 50 76 52 	add	#21110,	r12	;#0x5276
    82c0:	2d 41       	mov	@r1,	r13	;
    82c2:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    82c6:	00 00 
    82c8:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    82cc:	02 00 

000082ce <.Loc.281.3>:

  channel->registers->sa  = (uintptr_t)request->source_addr;
    82ce:	1c 41 02 00 	mov	2(r1),	r12	;
    82d2:	2e 4c       	mov	@r12,	r14	;
    82d4:	2c 41       	mov	@r1,	r12	;
    82d6:	2c 4c       	mov	@r12,	r12	;
    82d8:	0d 43       	clr	r13		;
    82da:	8e 4c 02 00 	mov	r12,	2(r14)	;
    82de:	8e 4d 04 00 	mov	r13,	4(r14)	;

000082e2 <.Loc.282.3>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    82e2:	1c 41 02 00 	mov	2(r1),	r12	;
    82e6:	2e 4c       	mov	@r12,	r14	;
    82e8:	2c 41       	mov	@r1,	r12	;
    82ea:	1c 4c 02 00 	mov	2(r12),	r12	;
    82ee:	0d 43       	clr	r13		;
    82f0:	8e 4c 06 00 	mov	r12,	6(r14)	;
    82f4:	8e 4d 08 00 	mov	r13,	8(r14)	;

000082f8 <.Loc.283.3>:
  channel->registers->sz  = request->size;
    82f8:	1c 41 02 00 	mov	2(r1),	r12	;
    82fc:	2c 4c       	mov	@r12,	r12	;
    82fe:	2d 41       	mov	@r1,	r13	;
    8300:	1d 4d 04 00 	mov	4(r13),	r13	;
    8304:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00008308 <.Loc.284.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    8308:	1c 41 02 00 	mov	2(r1),	r12	;
    830c:	2c 4c       	mov	@r12,	r12	;
    830e:	2d 41       	mov	@r1,	r13	;
    8310:	1e 4d 08 00 	mov	8(r13),	r14	;
    8314:	2d 41       	mov	@r1,	r13	;
    8316:	1d 4d 06 00 	mov	6(r13),	r13	;
    831a:	0e dd       	bis	r13,	r14	;

0000831c <.Loc.285.3>:
                            request->transfer_mode | DMAEN |
    831c:	2d 41       	mov	@r1,	r13	;
    831e:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a

00008322 <.Loc.284.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    8322:	0d de       	bis	r14,	r13	;

00008324 <.Loc.285.3>:
                            request->transfer_mode | DMAEN |
    8324:	3d d0 15 00 	bis	#21,	r13	;#0x0015

00008328 <.Loc.284.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    8328:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000832c <.Loc.287.3>:
                            DMAREQ;
}
    832c:	03 43       	nop			
    832e:	21 52       	add	#4,	r1	;r2 As==10
    8330:	30 41       	ret			

00008332 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    8332:	21 82       	sub	#4,	r1	;r2 As==10

00008334 <.LCFI12>:
    8334:	81 4c 00 00 	mov	r12,	0(r1)	;

00008338 <.Loc.301.3>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
    8338:	b0 12 de 7f 	call	#32734		;#0x7fde
    833c:	81 4c 02 00 	mov	r12,	2(r1)	;

00008340 <.Loc.304.3>:
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    8340:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    8344:	14 24       	jz	$+42     	;abs 0x836e

00008346 <.Loc.304.3>:
    8346:	2c 41       	mov	@r1,	r12	;
    8348:	2c 4c       	mov	@r12,	r12	;
    834a:	0c 93       	cmp	#0,	r12	;r3 As==00
    834c:	10 24       	jz	$+34     	;abs 0x836e

0000834e <.Loc.304.3>:
    834e:	2c 41       	mov	@r1,	r12	;
    8350:	2c 4c       	mov	@r12,	r12	;
    8352:	2c 4c       	mov	@r12,	r12	;
    8354:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8358:	0c 93       	cmp	#0,	r12	;r3 As==00
    835a:	09 24       	jz	$+20     	;abs 0x836e

0000835c <.Loc.307.3>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    835c:	2c 41       	mov	@r1,	r12	;
    835e:	2c 4c       	mov	@r12,	r12	;
    8360:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00008364 <.Loc.310.3>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    8364:	4d 43       	clr.b	r13		;
    8366:	3c 40 82 52 	mov	#21122,	r12	;#0x5282
    836a:	b0 12 02 6c 	call	#27650		;#0x6c02

0000836e <.L34>:
  }
  osalSysRestoreStatusX(sts);
    836e:	1c 41 02 00 	mov	2(r1),	r12	;
    8372:	b0 12 e4 7f 	call	#32740		;#0x7fe4

00008376 <.Loc.313.3>:
}
    8376:	03 43       	nop			
    8378:	21 52       	add	#4,	r1	;r2 As==10
    837a:	30 41       	ret			

0000837c <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    837c:	21 83       	decd	r1		;

0000837e <.LCFI13>:
    837e:	81 4c 00 00 	mov	r12,	0(r1)	;

00008382 <.Loc.326.3>:
  
  osalDbgCheckClassI();
    8382:	b0 12 7c 66 	call	#26236		;#0x667c

00008386 <.Loc.329.3>:
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    8386:	2c 41       	mov	@r1,	r12	;
    8388:	2c 4c       	mov	@r12,	r12	;
    838a:	2c 4c       	mov	@r12,	r12	;
    838c:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8390:	0c 93       	cmp	#0,	r12	;r3 As==00
    8392:	19 24       	jz	$+52     	;abs 0x83c6

00008394 <.Loc.334.3>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    8394:	2c 41       	mov	@r1,	r12	;
    8396:	2c 4c       	mov	@r12,	r12	;
    8398:	2d 41       	mov	@r1,	r13	;
    839a:	2d 4d       	mov	@r13,	r13	;
    839c:	2d 4d       	mov	@r13,	r13	;
    839e:	3d f0 ee ff 	and	#-18,	r13	;#0xffee
    83a2:	8c 4d 00 00 	mov	r13,	0(r12)	;

000083a6 <.Loc.336.3>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    83a6:	2c 41       	mov	@r1,	r12	;
    83a8:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    83ac:	4d 43       	clr.b	r13		;
    83ae:	b0 12 08 80 	call	#-32760	;#0x8008

000083b2 <.Loc.337.3>:
  channel->registers->sz  = 0;
    83b2:	2c 41       	mov	@r1,	r12	;
    83b4:	2c 4c       	mov	@r12,	r12	;
    83b6:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000083ba <.Loc.338.3>:
  channel->registers->ctl = DMAEN | DMAABORT;
    83ba:	2c 41       	mov	@r1,	r12	;
    83bc:	2c 4c       	mov	@r12,	r12	;
    83be:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    83c2:	00 00 
    83c4:	01 3c       	jmp	$+4      	;abs 0x83c8

000083c6 <.L38>:
    return;
    83c6:	03 43       	nop			

000083c8 <.L35>:
}
    83c8:	21 53       	incd	r1		;
    83ca:	30 41       	ret			

000083cc <port_lock_from_isr>:
}
    83cc:	03 43       	nop			

000083ce <L0>:
    83ce:	30 41       	ret			

000083d0 <port_unlock_from_isr>:
}
    83d0:	03 43       	nop			
    83d2:	30 41       	ret			

000083d4 <osalSysLockFromISR>:
  chSysLockFromISR();
    83d4:	b0 12 cc 83 	call	#-31796	;#0x83cc
    83d8:	b0 12 d8 65 	call	#26072		;#0x65d8

000083dc <.Loc.527.2>:
}
    83dc:	03 43       	nop			
    83de:	30 41       	ret			

000083e0 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    83e0:	b0 12 fa 65 	call	#26106		;#0x65fa
    83e4:	b0 12 d0 83 	call	#-31792	;#0x83d0

000083e8 <.Loc.538.2>:
}
    83e8:	03 43       	nop			
    83ea:	30 41       	ret			

000083ec <osalOsGetSystemTimeX>:
  return chVTGetSystemTimeX();
    83ec:	1c 42 b4 51 	mov	&0x51b4,r12	;0x51b4

000083f0 <.Loc.630.2>:
}
    83f0:	30 41       	ret			

000083f2 <osalThreadSuspendTimeoutS>:
                                              systime_t timeout) {
    83f2:	21 82       	sub	#4,	r1	;r2 As==10

000083f4 <.LCFI0>:
    83f4:	81 4c 02 00 	mov	r12,	2(r1)	;
    83f8:	81 4d 00 00 	mov	r13,	0(r1)	;

000083fc <.Loc.724.2>:
  return chThdSuspendTimeoutS(trp, timeout);
    83fc:	2d 41       	mov	@r1,	r13	;
    83fe:	1c 41 02 00 	mov	2(r1),	r12	;
    8402:	b0 12 88 69 	call	#27016		;#0x6988

00008406 <.Loc.725.2>:
}
    8406:	21 52       	add	#4,	r1	;r2 As==10
    8408:	30 41       	ret			

0000840a <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    840a:	21 82       	sub	#4,	r1	;r2 As==10

0000840c <.LCFI1>:
    840c:	81 4c 02 00 	mov	r12,	2(r1)	;
    8410:	81 4d 00 00 	mov	r13,	0(r1)	;

00008414 <.Loc.739.2>:
  chThdResumeI(trp, msg);
    8414:	2d 41       	mov	@r1,	r13	;
    8416:	1c 41 02 00 	mov	2(r1),	r12	;
    841a:	b0 12 b4 69 	call	#27060		;#0x69b4

0000841e <.Loc.740.2>:
}
    841e:	03 43       	nop			
    8420:	21 52       	add	#4,	r1	;r2 As==10
    8422:	30 41       	ret			

00008424 <tx_complete>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

void tx_complete(void * args) {
    8424:	21 82       	sub	#4,	r1	;r2 As==10

00008426 <.LCFI2>:
    8426:	81 4c 00 00 	mov	r12,	0(r1)	;

0000842a <.Loc.78.3>:
  I2CDriver * i2cp = (I2CDriver *)(args);
    842a:	a1 41 02 00 	mov	@r1,	2(r1)	;

0000842e <.Loc.81.3>:
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    842e:	1c 41 02 00 	mov	2(r1),	r12	;
    8432:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8436:	1d 41 02 00 	mov	2(r1),	r13	;
    843a:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    843e:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    8442:	2d d3       	bis	#2,	r13	;r3 As==10
    8444:	8c 4d 2a 00 	mov	r13,	42(r12)	; 0x002a

00008448 <.Loc.82.3>:
}
    8448:	03 43       	nop			
    844a:	21 52       	add	#4,	r1	;r2 As==10
    844c:	30 41       	ret			

0000844e <rx_complete>:

void rx_complete(void * args) {
    844e:	21 82       	sub	#4,	r1	;r2 As==10

00008450 <.LCFI3>:
    8450:	81 4c 00 00 	mov	r12,	0(r1)	;

00008454 <.Loc.85.3>:
  I2CDriver * i2cp = (I2CDriver *)(args);
    8454:	a1 41 02 00 	mov	@r1,	2(r1)	;

00008458 <.Loc.88.3>:
  
  /* Generate stop condition */
  i2cp->regs->ctlw0 |= UCTXSTP;
    8458:	1c 41 02 00 	mov	2(r1),	r12	;
    845c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8460:	1d 41 02 00 	mov	2(r1),	r13	;
    8464:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8468:	2d 4d       	mov	@r13,	r13	;
    846a:	2d d2       	bis	#4,	r13	;r2 As==10
    846c:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008470 <.Loc.91.3>:
  
  /* Enable RX interrupt to handle the last byte */
  i2cp->regs->ie |= UCRXIE0;
    8470:	1c 41 02 00 	mov	2(r1),	r12	;
    8474:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8478:	1d 41 02 00 	mov	2(r1),	r13	;
    847c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8480:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    8484:	1d d3       	bis	#1,	r13	;r3 As==01
    8486:	8c 4d 2a 00 	mov	r13,	42(r12)	; 0x002a

0000848a <.Loc.92.3>:
}
    848a:	03 43       	nop			
    848c:	21 52       	add	#4,	r1	;r2 As==10
    848e:	30 41       	ret			

00008490 <rx_async_callback>:

void rx_async_callback(void * args) {
    8490:	21 82       	sub	#4,	r1	;r2 As==10

00008492 <.LCFI4>:
    8492:	81 4c 00 00 	mov	r12,	0(r1)	;

00008496 <.Loc.95.3>:
  I2CDriver * i2cp = (I2CDriver *)(args);
    8496:	a1 41 02 00 	mov	@r1,	2(r1)	;

0000849a <.Loc.98.3>:
  
  /* Call the callback with the buffer */
  if (NULL != i2cp->callback) {
    849a:	1c 41 02 00 	mov	2(r1),	r12	;
    849e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    84a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    84a4:	12 24       	jz	$+38     	;abs 0x84ca

000084a6 <.Loc.99.3>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    84a6:	1c 41 02 00 	mov	2(r1),	r12	;
    84aa:	1f 4c 0a 00 	mov	10(r12),r15	;0x0000a
    84ae:	1c 41 02 00 	mov	2(r1),	r12	;
    84b2:	1c 4c 08 00 	mov	8(r12),	r12	;
    84b6:	1d 41 02 00 	mov	2(r1),	r13	;
    84ba:	1d 4d 12 00 	mov	18(r13),r13	;0x00012
    84be:	0e 4d       	mov	r13,	r14	;
    84c0:	0d 4c       	mov	r12,	r13	;
    84c2:	1c 41 02 00 	mov	2(r1),	r12	;
    84c6:	8f 12       	call	r15		;

000084c8 <.Loc.105.3>:
  }
  else {
    /* Default is to stop the transfer */
    i2cMSP430XEndTransferI(i2cp);
  }
}
    84c8:	04 3c       	jmp	$+10     	;abs 0x84d2

000084ca <.L17>:
    i2cMSP430XEndTransferI(i2cp);
    84ca:	1c 41 02 00 	mov	2(r1),	r12	;
    84ce:	b0 12 10 8c 	call	#-29680	;#0x8c10

000084d2 <.L19>:
}
    84d2:	03 43       	nop			
    84d4:	21 52       	add	#4,	r1	;r2 As==10
    84d6:	30 41       	ret			

000084d8 <ISR_USCI_B0_VECTOR>:

#if MSP430X_I2C_USE_I2CB0
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    84d8:	bf 15       	pushm	#12,	r15	;16-bit words

000084da <L0>:
    84da:	21 83       	decd	r1		;

000084dc <.LCFI6>:
  OSAL_IRQ_PROLOGUE();
    84dc:	d2 43 e8 51 	mov.b	#1,	&0x51e8	;r3 As==01
    84e0:	b0 12 1e 66 	call	#26142		;#0x661e

000084e4 <.Loc.110.3>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    84e4:	1c 42 6e 06 	mov	&0x066e,r12	;0x066e
    84e8:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    84ec:	95 24       	jz	$+300    	;abs 0x8618
    84ee:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    84f2:	0d 9c       	cmp	r12,	r13	;
    84f4:	15 28       	jnc	$+44     	;abs 0x8520
    84f6:	3c 90 06 00 	cmp	#6,	r12	;
    84fa:	90 24       	jz	$+290    	;abs 0x861c
    84fc:	7d 40 06 00 	mov.b	#6,	r13	;
    8500:	0d 9c       	cmp	r12,	r13	;
    8502:	05 28       	jnc	$+12     	;abs 0x850e
    8504:	2c 93       	cmp	#2,	r12	;r3 As==10
    8506:	1d 24       	jz	$+60     	;abs 0x8542
    8508:	2c 92       	cmp	#4,	r12	;r2 As==10
    850a:	21 24       	jz	$+68     	;abs 0x854e

0000850c <.Loc.112.3>:
    case USCI_NONE:
      break;
    850c:	8c 3c       	jmp	$+282    	;abs 0x8626

0000850e <.L25>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    850e:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    8512:	82 24       	jz	$+262    	;abs 0x8618
    8514:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    8518:	7f 24       	jz	$+256    	;abs 0x8618
    851a:	3c 92       	cmp	#8,	r12	;r2 As==11
    851c:	1e 24       	jz	$+62     	;abs 0x855a
    851e:	83 3c       	jmp	$+264    	;abs 0x8626

00008520 <.L23>:
    8520:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    8524:	35 24       	jz	$+108    	;abs 0x8590
    8526:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    852a:	0d 9c       	cmp	r12,	r13	;
    852c:	75 2c       	jc	$+236    	;abs 0x8618
    852e:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    8532:	76 24       	jz	$+238    	;abs 0x8620
    8534:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    8538:	68 24       	jz	$+210    	;abs 0x860a
    853a:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    853e:	39 24       	jz	$+116    	;abs 0x85b2
    8540:	72 3c       	jmp	$+230    	;abs 0x8626

00008542 <.L26>:
    case USCI_I2C_UCALIFG:
      /* Arbitration loss error */
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    8542:	1c 42 88 52 	mov	&0x5288,r12	;0x5288
    8546:	2c d3       	bis	#2,	r12	;r3 As==10
    8548:	82 4c 88 52 	mov	r12,	&0x5288	;

0000854c <.Loc.116.3>:
      break;
    854c:	6c 3c       	jmp	$+218    	;abs 0x8626

0000854e <.L27>:
    case USCI_I2C_UCNACKIFG:
      /* NACK received */
      I2CDB0.errors |= I2C_ACK_FAILURE;
    854e:	1c 42 88 52 	mov	&0x5288,r12	;0x5288
    8552:	2c d2       	bis	#4,	r12	;r2 As==10
    8554:	82 4c 88 52 	mov	r12,	&0x5288	;

00008558 <.Loc.120.3>:
      break;
    8558:	66 3c       	jmp	$+206    	;abs 0x8626

0000855a <.L29>:
    case USCI_I2C_UCSTTIFG:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    case USCI_I2C_UCSTPIFG:
      /* We've transmitted STOP - return to ready state */
      I2CDB0.state = I2C_READY;
    855a:	e2 43 84 52 	mov.b	#2,	&0x5284	;r3 As==10

0000855e <.Loc.128.3>:
      /* Resume the thread if we have one */
      if (I2CDB0.thread != NULL) {
    855e:	1c 42 a4 52 	mov	&0x52a4,r12	;0x52a4
    8562:	0c 93       	cmp	#0,	r12	;r3 As==00
    8564:	09 24       	jz	$+20     	;abs 0x8578

00008566 <.Loc.129.3>:
        osalSysLockFromISR();
    8566:	b0 12 d4 83 	call	#-31788	;#0x83d4

0000856a <.Loc.130.3>:
        osalThreadResumeI(&I2CDB0.thread, MSG_OK);
    856a:	4d 43       	clr.b	r13		;
    856c:	3c 40 a4 52 	mov	#21156,	r12	;#0x52a4
    8570:	b0 12 0a 84 	call	#-31734	;#0x840a

00008574 <.Loc.131.3>:
        osalSysUnlockFromISR();
    8574:	b0 12 e0 83 	call	#-31776	;#0x83e0

00008578 <.L35>:
      }
      /* Release the DMA if it's not claimed */
#if MSP430X_I2C_EXCLUSIVE_DMA == TRUE
      if (!(I2CDB0.dma_acquired)) {
    8578:	5c 42 ae 52 	mov.b	&0x52ae,r12	;0x52ae
    857c:	5c e3       	xor.b	#1,	r12	;r3 As==01
    857e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8582:	0c 93       	cmp	#0,	r12	;r3 As==00
    8584:	4f 24       	jz	$+160    	;abs 0x8624

00008586 <.Loc.137.3>:
#endif
        dmaReleaseX(&(I2CDB0.dma));
    8586:	3c 40 a8 52 	mov	#21160,	r12	;#0x52a8
    858a:	b0 12 32 83 	call	#-31950	;#0x8332

0000858e <.Loc.141.3>:
#if MSP430X_I2C_EXCLUSIVE_DMA == TRUE
      }
#endif
      break;
    858e:	4a 3c       	jmp	$+150    	;abs 0x8624

00008590 <.L30>:
    case USCI_I2C_UCTXIFG1:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    case USCI_I2C_UCRXIFG0:
      /* Handle final byte */
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    8590:	1d 42 94 52 	mov	&0x5294,r13	;0x5294
    8594:	1c 42 96 52 	mov	&0x5296,r12	;0x5296
    8598:	0c 5d       	add	r13,	r12	;
    859a:	1d 42 4c 06 	mov	&0x064c,r13	;0x064c
    859e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    85a2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000085a6 <.Loc.154.3>:
      /* Disable interrupt */
      UCB0IE &= ~(UCRXIE);
    85a6:	1c 42 6a 06 	mov	&0x066a,r12	;0x066a
    85aa:	1c c3       	bic	#1,	r12	;r3 As==01
    85ac:	82 4c 6a 06 	mov	r12,	&0x066a	;

000085b0 <.Loc.155.3>:
      break;
    85b0:	3a 3c       	jmp	$+118    	;abs 0x8626

000085b2 <.L34>:
    case USCI_I2C_UCTXIFG0:
      /* Disable interrupt */
      UCB0IE &= ~(UCTXIE);
    85b2:	1c 42 6a 06 	mov	&0x066a,r12	;0x066a
    85b6:	2c c3       	bic	#2,	r12	;r3 As==10
    85b8:	82 4c 6a 06 	mov	r12,	&0x066a	;

000085bc <.Loc.160.3>:
      /* Callback driven? */
      if (I2CDB0.thread == NULL) {
    85bc:	1c 42 a4 52 	mov	&0x52a4,r12	;0x52a4
    85c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    85c2:	19 20       	jnz	$+52     	;abs 0x85f6

000085c4 <.Loc.162.3>:
        /* Call the callback */
        if (NULL != I2CDB0.callback) {
    85c4:	1c 42 8e 52 	mov	&0x528e,r12	;0x528e
    85c8:	0c 93       	cmp	#0,	r12	;r3 As==00
    85ca:	0c 24       	jz	$+26     	;abs 0x85e4

000085cc <.Loc.163.3>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    85cc:	1f 42 8e 52 	mov	&0x528e,r15	;0x528e
    85d0:	1c 42 8c 52 	mov	&0x528c,r12	;0x528c
    85d4:	1d 42 96 52 	mov	&0x5296,r13	;0x5296
    85d8:	0e 4d       	mov	r13,	r14	;
    85da:	0d 4c       	mov	r12,	r13	;
    85dc:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    85e0:	8f 12       	call	r15		;

000085e2 <.Loc.178.3>:
        /* Wake the thread */
        osalSysLockFromISR();
        osalThreadResumeI(&I2CDB0.thread, MSG_OK); 
        osalSysUnlockFromISR();
      }
      break;
    85e2:	21 3c       	jmp	$+68     	;abs 0x8626

000085e4 <.L38>:
          osalSysLockFromISR();
    85e4:	b0 12 d4 83 	call	#-31788	;#0x83d4

000085e8 <.Loc.168.3>:
          i2cMSP430XEndTransferI(&I2CDB0);
    85e8:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    85ec:	b0 12 10 8c 	call	#-29680	;#0x8c10

000085f0 <.Loc.169.3>:
          osalSysUnlockFromISR();
    85f0:	b0 12 e0 83 	call	#-31776	;#0x83e0

000085f4 <.Loc.178.3>:
      break;
    85f4:	18 3c       	jmp	$+50     	;abs 0x8626

000085f6 <.L37>:
        osalSysLockFromISR();
    85f6:	b0 12 d4 83 	call	#-31788	;#0x83d4

000085fa <.Loc.175.3>:
        osalThreadResumeI(&I2CDB0.thread, MSG_OK); 
    85fa:	4d 43       	clr.b	r13		;
    85fc:	3c 40 a4 52 	mov	#21156,	r12	;#0x52a4
    8600:	b0 12 0a 84 	call	#-31734	;#0x840a

00008604 <.Loc.176.3>:
        osalSysUnlockFromISR();
    8604:	b0 12 e0 83 	call	#-31776	;#0x83e0

00008608 <.Loc.178.3>:
      break;
    8608:	0e 3c       	jmp	$+30     	;abs 0x8626

0000860a <.L33>:
    case USCI_I2C_UCBCNTIFG:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    case USCI_I2C_UCCLTOIFG:
      /* Bus low timeout */
      I2CDB0.errors |= I2C_TIMEOUT;
    860a:	1c 42 88 52 	mov	&0x5288,r12	;0x5288
    860e:	3c d0 20 00 	bis	#32,	r12	;#0x0020
    8612:	82 4c 88 52 	mov	r12,	&0x5288	;

00008616 <.Loc.185.3>:
      break;
    8616:	07 3c       	jmp	$+16     	;abs 0x8626

00008618 <.L46>:
      break;
    8618:	03 43       	nop			
    861a:	05 3c       	jmp	$+12     	;abs 0x8626

0000861c <.L47>:
      break;
    861c:	03 43       	nop			
    861e:	03 3c       	jmp	$+8      	;abs 0x8626

00008620 <.L48>:
      break;
    8620:	03 43       	nop			
    8622:	01 3c       	jmp	$+4      	;abs 0x8626

00008624 <.L49>:
      break;
    8624:	03 43       	nop			

00008626 <.L21>:
  }
      
  if (I2CDB0.errors != I2C_NO_ERROR) {
    8626:	1c 42 88 52 	mov	&0x5288,r12	;0x5288
    862a:	0c 93       	cmp	#0,	r12	;r3 As==00
    862c:	32 24       	jz	$+102    	;abs 0x8692

0000862e <.LBB2>:
    osalSysLockFromISR();
    862e:	b0 12 d4 83 	call	#-31788	;#0x83d4

00008632 <.Loc.190.3>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    8632:	1d 42 96 52 	mov	&0x5296,r13	;0x5296
    8636:	1c 42 a8 52 	mov	&0x52a8,r12	;0x52a8
    863a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    863e:	0e 4d       	mov	r13,	r14	;
    8640:	0e 8c       	sub	r12,	r14	;
    8642:	81 4e 00 00 	mov	r14,	0(r1)	;

00008646 <.Loc.192.3>:
    /* Cancel DMA transaction */
    dmaCancelI(&I2CDB0.dma);
    8646:	3c 40 a8 52 	mov	#21160,	r12	;#0x52a8
    864a:	b0 12 7c 83 	call	#-31876	;#0x837c

0000864e <.Loc.194.3>:
  
    if (I2CDB0.errors & I2C_TIMEOUT) {
    864e:	1c 42 88 52 	mov	&0x5288,r12	;0x5288
    8652:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    8656:	0c 93       	cmp	#0,	r12	;r3 As==00
    8658:	03 24       	jz	$+8      	;abs 0x8660

0000865a <.Loc.195.3>:
      I2CDB0.state = I2C_LOCKED;
    865a:	f2 40 05 00 	mov.b	#5,	&0x5284	;
    865e:	84 52 

00008660 <.L42>:
    }
    
    if (NULL != I2CDB0.callback) {
    8660:	1c 42 8e 52 	mov	&0x528e,r12	;0x528e
    8664:	0c 93       	cmp	#0,	r12	;r3 As==00
    8666:	09 24       	jz	$+20     	;abs 0x867a

00008668 <.Loc.199.3>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    8668:	1f 42 8e 52 	mov	&0x528e,r15	;0x528e
    866c:	1c 42 8c 52 	mov	&0x528c,r12	;0x528c
    8670:	2e 41       	mov	@r1,	r14	;
    8672:	0d 4c       	mov	r12,	r13	;
    8674:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    8678:	8f 12       	call	r15		;

0000867a <.L43>:
    }
    
    if (I2CDB0.thread != NULL) {
    867a:	1c 42 a4 52 	mov	&0x52a4,r12	;0x52a4
    867e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8680:	06 24       	jz	$+14     	;abs 0x868e

00008682 <.Loc.203.3>:
      osalThreadResumeI(&I2CDB0.thread, MSG_RESET);
    8682:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    8686:	3c 40 a4 52 	mov	#21156,	r12	;#0x52a4
    868a:	b0 12 0a 84 	call	#-31734	;#0x840a

0000868e <.L44>:
    }
    osalSysUnlockFromISR();
    868e:	b0 12 e0 83 	call	#-31776	;#0x83e0

00008692 <.L41>:
  }
  
    /* Turn off the TX IFG flag so that we'll start DMA correctly next time */
    /*I2CDB0.regs->ifg &= ~(UCTXIFG);*/
  
  OSAL_IRQ_EPILOGUE();
    8692:	b0 12 4c 66 	call	#26188		;#0x664c
    8696:	c2 43 e8 51 	mov.b	#0,	&0x51e8	;r3 As==00
    869a:	b0 12 96 65 	call	#26006		;#0x6596
    869e:	b0 12 cc 68 	call	#26828		;#0x68cc
    86a2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    86a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    86a8:	02 24       	jz	$+6      	;abs 0x86ae

000086aa <.Loc.211.3>:
    86aa:	b0 12 e8 68 	call	#26856		;#0x68e8

000086ae <.L45>:
    86ae:	b0 12 b6 65 	call	#26038		;#0x65b6

000086b2 <.Loc.212.3>:
}
    86b2:	03 43       	nop			
    86b4:	21 53       	incd	r1		;
    86b6:	b4 17       	popm	#12,	r15	;16-bit words
    86b8:	00 13       	reti			

000086ba <i2c_lld_init>:
 * @notapi
 */
void i2c_lld_init(void) {

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    86ba:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    86be:	b0 12 0c 73 	call	#29452		;#0x730c

000086c2 <.Loc.423.3>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    86c2:	b2 40 40 06 	mov	#1600,	&0x5290	;#0x0640
    86c6:	90 52 

000086c8 <.Loc.424.3>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    86c8:	b2 40 c0 00 	mov	#192,	&0x529a	;#0x00c0
    86cc:	9a 52 

000086ce <.Loc.425.3>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    86ce:	82 43 9c 52 	mov	#0,	&0x529c	;r3 As==00

000086d2 <.Loc.426.3>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    86d2:	f2 40 13 00 	mov.b	#19		;#0x0013, Warning: disassembly unreliable - not enough bytes available

000086d6 <L0>:
    86d6:	a6 52       	add	#4		;r2 As==10, Warning: disassembly unreliable - not enough bytes available

000086d8 <.Loc.427.3>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    86d8:	f2 40 12 00 	mov.b	#18,	&0x52a7	;#0x0012
    86dc:	a7 52 

000086de <.Loc.428.3>:
  I2CDB0.req.callback.callback = NULL;
    86de:	82 43 a0 52 	mov	#0,	&0x52a0	;r3 As==00

000086e2 <.Loc.429.3>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    86e2:	b2 40 84 52 	mov	#21124,	&0x52a2	;#0x5284
    86e6:	a2 52 

000086e8 <.Loc.466.3>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    86e8:	03 43       	nop			
    86ea:	30 41       	ret			

000086ec <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    86ec:	21 83       	decd	r1		;

000086ee <.LCFI7>:
    86ee:	81 4c 00 00 	mov	r12,	0(r1)	;

000086f2 <.Loc.479.3>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    86f2:	b1 90 84 52 	cmp	#21124,	0(r1)	;#0x5284
    86f6:	00 00 
    86f8:	53 20       	jnz	$+168    	;abs 0x87a0

000086fa <.Loc.481.3>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    86fa:	1c 42 40 06 	mov	&0x0640,r12	;0x0640
    86fe:	1c d3       	bis	#1,	r12	;r3 As==01
    8700:	82 4c 40 06 	mov	r12,	&0x0640	;

00008704 <.Loc.483.3>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    8704:	1c 42 86 52 	mov	&0x5286,r12	;0x5286
    8708:	1d 4c 02 00 	mov	2(r12),	r13	;
    870c:	2c 4c       	mov	@r12,	r12	;
    870e:	0e 4c       	mov	r12,	r14	;
    8710:	0f 4d       	mov	r13,	r15	;
    8712:	3c 40 90 d0 	mov	#-12144,r12	;#0xd090
    8716:	7d 40 03 00 	mov.b	#3,	r13	;
    871a:	b0 12 64 9c 	call	#-25500	;#0x9c64
    871e:	82 4c 46 06 	mov	r12,	&0x0646	;

00008722 <.Loc.485.3>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    8722:	b2 40 c0 00 	mov	#192,	&0x0642	;#0x00c0
    8726:	42 06 

00008728 <.Loc.487.3>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
    8728:	1c 42 86 52 	mov	&0x5286,r12	;0x5286
    872c:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    8730:	5c f3       	and.b	#1,	r12	;r3 As==01
    8732:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8736:	4d 18 0c 5c 	rpt #14 { rlax.w	r12		;

0000873a <.Loc.488.3>:
        | MSP430X_I2CB0_UCSSEL;
    873a:	3c d0 80 0f 	bis	#3968,	r12	;#0x0f80

0000873e <.Loc.487.3>:
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
    873e:	82 4c 40 06 	mov	r12,	&0x0640	;

00008742 <.Loc.492.3>:
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
  #endif
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    8742:	b2 40 b8 00 	mov	#184,	&0x066a	;#0x00b8
    8746:	6a 06 

00008748 <.Loc.493.3>:
      UCB0IFG = 0;
    8748:	82 43 6c 06 	mov	#0,	&0x066c	;r3 As==00

0000874c <.Loc.495.3>:
  #if MSP430X_I2C_EXCLUSIVE_DMA
      if (i2cp->dma_acquired) {
    874c:	2c 41       	mov	@r1,	r12	;
    874e:	5c 4c 2a 00 	mov.b	42(r12),r12	;0x0002a
    8752:	0c 93       	cmp	#0,	r12	;r3 As==00
    8754:	06 24       	jz	$+14     	;abs 0x8762

00008756 <.Loc.496.3>:
        dmaReleaseX(&I2CDB0.dma);
    8756:	3c 40 a8 52 	mov	#21160,	r12	;#0x52a8
    875a:	b0 12 32 83 	call	#-31950	;#0x8332

0000875e <.Loc.497.3>:
        I2CDB0.dma_acquired = false;
    875e:	c2 43 ae 52 	mov.b	#0,	&0x52ae	;r3 As==00

00008762 <.L53>:
      }
      if (I2CDB0.config->dma_index < MSP430X_DMA_CHANNELS) {
    8762:	1c 42 86 52 	mov	&0x5286,r12	;0x5286
    8766:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    876a:	12 c3       	clrc			
    876c:	0c 10       	rrc	r12		;
    876e:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8772:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8776:	0d 4c       	mov	r12,	r13	;
    8778:	6c 43       	mov.b	#2,	r12	;r3 As==10
    877a:	0c 9d       	cmp	r13,	r12	;
    877c:	11 38       	jl	$+36     	;abs 0x87a0

0000877e <.Loc.500.3>:
        dmaClaimI(&I2CDB0.dma, I2CDB0.config->dma_index);
    877e:	1c 42 86 52 	mov	&0x5286,r12	;0x5286
    8782:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    8786:	12 c3       	clrc			
    8788:	0c 10       	rrc	r12		;
    878a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    878e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8792:	4d 4c       	mov.b	r12,	r13	;
    8794:	3c 40 a8 52 	mov	#21160,	r12	;#0x52a8
    8798:	b0 12 f6 81 	call	#-32266	;#0x81f6

0000879c <.Loc.501.3>:
        I2CDB0.dma_acquired = true;
    879c:	d2 43 ae 52 	mov.b	#1,	&0x52ae	;r3 As==01

000087a0 <.L54>:
      }
  #endif
    }
#endif

}
    87a0:	03 43       	nop			
    87a2:	21 53       	incd	r1		;
    87a4:	30 41       	ret			

000087a6 <i2cMSP430XStartReceiveI>:
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    87a6:	31 82       	sub	#8,	r1	;r2 As==11

000087a8 <.LCFI10>:
    87a8:	81 4c 06 00 	mov	r12,	6(r1)	;
    87ac:	81 4d 04 00 	mov	r13,	4(r1)	;
    87b0:	81 4e 02 00 	mov	r14,	2(r1)	;
    87b4:	81 4f 00 00 	mov	r15,	0(r1)	;

000087b8 <.Loc.719.3>:
  
  osalDbgCheckClassI();
    87b8:	b0 12 7c 66 	call	#26236		;#0x667c

000087bc <.Loc.729.3>:
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    87bc:	1c 41 06 00 	mov	6(r1),	r12	;
    87c0:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000087c4 <.Loc.731.3>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    87c4:	1c 41 06 00 	mov	6(r1),	r12	;
    87c8:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10

000087cc <.Loc.733.3>:
  
  i2cp->buffer = rxbuf;
    87cc:	1c 41 06 00 	mov	6(r1),	r12	;
    87d0:	ac 41 08 00 	mov	@r1,	8(r12)	;

000087d4 <.Loc.736.3>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    87d4:	91 93 02 00 	cmp	#1,	2(r1)	;r3 As==01
    87d8:	41 20       	jnz	$+132    	;abs 0x885c

000087da <.Loc.738.3>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    87da:	1c 41 06 00 	mov	6(r1),	r12	;
    87de:	ac 41 10 00 	mov	@r1,	16(r12)	; 0x0010

000087e2 <.Loc.739.3>:
    i2cp->req.size = 0;
    87e2:	1c 41 06 00 	mov	6(r1),	r12	;
    87e6:	8c 43 12 00 	mov	#0,	18(r12)	;r3 As==00, 0x0012

000087ea <.Loc.741.3>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    87ea:	1c 41 06 00 	mov	6(r1),	r12	;
    87ee:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    87f2:	1d 41 06 00 	mov	6(r1),	r13	;
    87f6:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    87fa:	2d 4d       	mov	@r13,	r13	;
    87fc:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8800:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008804 <.Loc.743.3>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    8804:	1c 41 06 00 	mov	6(r1),	r12	;
    8808:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    880c:	1d 41 06 00 	mov	6(r1),	r13	;
    8810:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8814:	2d 4d       	mov	@r13,	r13	;
    8816:	2d d3       	bis	#2,	r13	;r3 As==10
    8818:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000881c <.Loc.745.3>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    881c:	03 43       	nop			

0000881e <.L68>:
    881e:	1c 41 06 00 	mov	6(r1),	r12	;
    8822:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8826:	2c 4c       	mov	@r12,	r12	;
    8828:	6c f3       	and.b	#2,	r12	;r3 As==10
    882a:	0c 93       	cmp	#0,	r12	;r3 As==00
    882c:	f8 23       	jnz	$-14     	;abs 0x881e

0000882e <.Loc.746.3>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    882e:	1c 41 06 00 	mov	6(r1),	r12	;
    8832:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8836:	1d 41 06 00 	mov	6(r1),	r13	;
    883a:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    883e:	2d 4d       	mov	@r13,	r13	;
    8840:	2d d2       	bis	#4,	r13	;r2 As==10
    8842:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008846 <.Loc.748.3>:
    /* Call the callback immediately as well */
    if (callback != NULL)
    8846:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    884a:	80 24       	jz	$+258    	;abs 0x894c

0000884c <.Loc.749.3>:
      callback(i2cp, rxbuf, 1);
    884c:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    8850:	5e 43       	mov.b	#1,	r14	;r3 As==01
    8852:	2d 41       	mov	@r1,	r13	;
    8854:	1c 41 06 00 	mov	6(r1),	r12	;
    8858:	8f 12       	call	r15		;

0000885a <.Loc.774.3>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    885a:	78 3c       	jmp	$+242    	;abs 0x894c

0000885c <.L67>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    885c:	1c 41 06 00 	mov	6(r1),	r12	;
    8860:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8864:	0d 4c       	mov	r12,	r13	;
    8866:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    886a:	1c 41 06 00 	mov	6(r1),	r12	;
    886e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008872 <.Loc.754.3>:
    i2cp->req.dest_addr = rxbuf;
    8872:	1c 41 06 00 	mov	6(r1),	r12	;
    8876:	ac 41 10 00 	mov	@r1,	16(r12)	; 0x0010

0000887a <.Loc.755.3>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    887a:	1d 41 02 00 	mov	2(r1),	r13	;
    887e:	3d 53       	add	#-1,	r13	;r3 As==11
    8880:	1c 41 06 00 	mov	6(r1),	r12	;
    8884:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00008888 <.Loc.756.3>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    8888:	1c 41 06 00 	mov	6(r1),	r12	;
    888c:	bc 40 00 0c 	mov	#3072,	20(r12)	;#0x0c00, 0x0014
    8890:	14 00 

00008892 <.Loc.757.3>:
    i2cp->req.trigger = i2cp->rxtrig;
    8892:	1c 41 06 00 	mov	6(r1),	r12	;
    8896:	5c 4c 23 00 	mov.b	35(r12),r12	;0x00023
    889a:	0d 4c       	mov	r12,	r13	;
    889c:	1c 41 06 00 	mov	6(r1),	r12	;
    88a0:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

000088a4 <.Loc.759.3>:
    i2cp->callback = callback;
    88a4:	1c 41 06 00 	mov	6(r1),	r12	;
    88a8:	9c 41 0a 00 	mov	10(r1),	10(r12)	;0x0000a, 0x000a
    88ac:	0a 00 

000088ae <.Loc.761.3>:
    i2cp->req.callback.callback = &rx_async_callback;
    88ae:	1c 41 06 00 	mov	6(r1),	r12	;
    88b2:	bc 40 90 84 	mov	#-31600,28(r12)	;#0x8490, 0x001c
    88b6:	1c 00 

000088b8 <.Loc.762.3>:
    i2cp->req.callback.args = i2cp;
    88b8:	1c 41 06 00 	mov	6(r1),	r12	;
    88bc:	9c 41 06 00 	mov	6(r1),	30(r12)	; 0x001e
    88c0:	1e 00 

000088c2 <.Loc.764.3>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    88c2:	1c 41 06 00 	mov	6(r1),	r12	;
    88c6:	3c 50 24 00 	add	#36,	r12	;#0x0024
    88ca:	0c 93       	cmp	#0,	r12	;r3 As==00
    88cc:	0f 24       	jz	$+32     	;abs 0x88ec

000088ce <.Loc.764.3>:
    88ce:	1c 41 06 00 	mov	6(r1),	r12	;
    88d2:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    88d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    88d8:	09 24       	jz	$+20     	;abs 0x88ec

000088da <.Loc.764.3>:
    88da:	1c 41 06 00 	mov	6(r1),	r12	;
    88de:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    88e2:	2c 4c       	mov	@r12,	r12	;
    88e4:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    88e8:	0c 93       	cmp	#0,	r12	;r3 As==00
    88ea:	06 20       	jnz	$+14     	;abs 0x88f8

000088ec <.L71>:
      dmaAcquireI(&(i2cp->dma));
    88ec:	1c 41 06 00 	mov	6(r1),	r12	;
    88f0:	3c 50 24 00 	add	#36,	r12	;#0x0024
    88f4:	b0 12 54 81 	call	#-32428	;#0x8154

000088f8 <.L72>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    88f8:	1c 41 06 00 	mov	6(r1),	r12	;
    88fc:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8900:	1d 41 06 00 	mov	6(r1),	r13	;
    8904:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8908:	b0 12 76 82 	call	#-32138	;#0x8276

0000890c <.Loc.770.3>:
    i2cp->regs->i2csa = addr;
    890c:	1c 41 06 00 	mov	6(r1),	r12	;
    8910:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8914:	9c 41 04 00 	mov	4(r1),	32(r12)	; 0x0020
    8918:	20 00 

0000891a <.Loc.771.3>:
    i2cp->regs->ctlw0 &= ~UCTR;
    891a:	1c 41 06 00 	mov	6(r1),	r12	;
    891e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8922:	1d 41 06 00 	mov	6(r1),	r13	;
    8926:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    892a:	2d 4d       	mov	@r13,	r13	;
    892c:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8930:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008934 <.Loc.772.3>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    8934:	1c 41 06 00 	mov	6(r1),	r12	;
    8938:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    893c:	1d 41 06 00 	mov	6(r1),	r13	;
    8940:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8944:	2d 4d       	mov	@r13,	r13	;
    8946:	2d d3       	bis	#2,	r13	;r3 As==10
    8948:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000894c <.L73>:
}
    894c:	03 43       	nop			
    894e:	31 52       	add	#8,	r1	;r2 As==11
    8950:	30 41       	ret			

00008952 <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    8952:	31 82       	sub	#8,	r1	;r2 As==11

00008954 <L0>:
    8954:	81 4c 06 00 	mov	r12,	6(r1)	;
    8958:	81 4d 04 00 	mov	r13,	4(r1)	;
    895c:	81 4e 02 00 	mov	r14,	2(r1)	;
    8960:	81 4f 00 00 	mov	r15,	0(r1)	;

00008964 <.Loc.779.3>:
  
  osalDbgCheckClassI();
    8964:	b0 12 7c 66 	call	#26236		;#0x667c

00008968 <.Loc.792.3>:
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    8968:	1c 41 06 00 	mov	6(r1),	r12	;
    896c:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00008970 <.Loc.794.3>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    8970:	1c 41 06 00 	mov	6(r1),	r12	;
    8974:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    8978:	00 00 

0000897a <.Loc.796.3>:
  
  i2cp->buffer = txbuf;
    897a:	1c 41 06 00 	mov	6(r1),	r12	;
    897e:	ac 41 08 00 	mov	@r1,	8(r12)	;

00008982 <.Loc.799.3>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    8982:	1c 41 02 00 	mov	2(r1),	r12	;
    8986:	3c 53       	add	#-1,	r12	;r3 As==11
    8988:	2d 41       	mov	@r1,	r13	;
    898a:	0d 5c       	add	r12,	r13	;
    898c:	1c 41 06 00 	mov	6(r1),	r12	;
    8990:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008994 <.Loc.800.3>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    8994:	1c 41 06 00 	mov	6(r1),	r12	;
    8998:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    899c:	0d 4c       	mov	r12,	r13	;
    899e:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    89a2:	1c 41 06 00 	mov	6(r1),	r12	;
    89a6:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

000089aa <.Loc.801.3>:
  i2cp->req.size = n;
    89aa:	1c 41 06 00 	mov	6(r1),	r12	;
    89ae:	9c 41 02 00 	mov	2(r1),	18(r12)	; 0x0012
    89b2:	12 00 

000089b4 <.Loc.802.3>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    89b4:	1c 41 06 00 	mov	6(r1),	r12	;
    89b8:	bc 40 00 02 	mov	#512,	20(r12)	;#0x0200, 0x0014
    89bc:	14 00 

000089be <.Loc.803.3>:
  i2cp->req.trigger = i2cp->txtrig;
    89be:	1c 41 06 00 	mov	6(r1),	r12	;
    89c2:	5c 4c 22 00 	mov.b	34(r12),r12	;0x00022
    89c6:	0d 4c       	mov	r12,	r13	;
    89c8:	1c 41 06 00 	mov	6(r1),	r12	;
    89cc:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

000089d0 <.Loc.805.3>:
  /* Custom callback */
  i2cp->callback = callback;
    89d0:	1c 41 06 00 	mov	6(r1),	r12	;
    89d4:	9c 41 0a 00 	mov	10(r1),	10(r12)	;0x0000a, 0x000a
    89d8:	0a 00 

000089da <.Loc.807.3>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    89da:	1c 41 06 00 	mov	6(r1),	r12	;
    89de:	bc 40 24 84 	mov	#-31708,28(r12)	;#0x8424, 0x001c
    89e2:	1c 00 

000089e4 <.Loc.809.3>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    89e4:	1c 41 06 00 	mov	6(r1),	r12	;
    89e8:	3c 50 24 00 	add	#36,	r12	;#0x0024
    89ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    89ee:	0f 24       	jz	$+32     	;abs 0x8a0e

000089f0 <.Loc.809.3>:
    89f0:	1c 41 06 00 	mov	6(r1),	r12	;
    89f4:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    89f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    89fa:	09 24       	jz	$+20     	;abs 0x8a0e

000089fc <.Loc.809.3>:
    89fc:	1c 41 06 00 	mov	6(r1),	r12	;
    8a00:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8a04:	2c 4c       	mov	@r12,	r12	;
    8a06:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8a0a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a0c:	06 20       	jnz	$+14     	;abs 0x8a1a

00008a0e <.L75>:
    dmaAcquireI(&(i2cp->dma));
    8a0e:	1c 41 06 00 	mov	6(r1),	r12	;
    8a12:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8a16:	b0 12 54 81 	call	#-32428	;#0x8154

00008a1a <.L76>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    8a1a:	1c 41 06 00 	mov	6(r1),	r12	;
    8a1e:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8a22:	1d 41 06 00 	mov	6(r1),	r13	;
    8a26:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8a2a:	b0 12 76 82 	call	#-32138	;#0x8276

00008a2e <.Loc.815.3>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    8a2e:	1c 41 06 00 	mov	6(r1),	r12	;
    8a32:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8a36:	9c 41 04 00 	mov	4(r1),	32(r12)	; 0x0020
    8a3a:	20 00 

00008a3c <.Loc.816.3>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    8a3c:	1c 41 06 00 	mov	6(r1),	r12	;
    8a40:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8a44:	1d 41 06 00 	mov	6(r1),	r13	;
    8a48:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8a4c:	2d 4d       	mov	@r13,	r13	;
    8a4e:	3d d0 12 00 	bis	#18,	r13	;#0x0012
    8a52:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008a56 <.Loc.819.3>:
  /* IFG is set automatically after START */
  
}
    8a56:	03 43       	nop			
    8a58:	31 52       	add	#8,	r1	;r2 As==11
    8a5a:	30 41       	ret			

00008a5c <i2cMSP430XStartTransmitI>:

void i2cMSP430XStartTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    8a5c:	31 82       	sub	#8,	r1	;r2 As==11

00008a5e <.LCFI12>:
    8a5e:	81 4c 06 00 	mov	r12,	6(r1)	;
    8a62:	81 4d 04 00 	mov	r13,	4(r1)	;
    8a66:	81 4e 02 00 	mov	r14,	2(r1)	;
    8a6a:	81 4f 00 00 	mov	r15,	0(r1)	;

00008a6e <.Loc.824.3>:
  
  osalDbgCheckClassI();
    8a6e:	b0 12 7c 66 	call	#26236		;#0x667c

00008a72 <.Loc.837.3>:
#else
  osalDbgAssert(!(addr & 0x7F), "Invalid address");
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    8a72:	1c 41 06 00 	mov	6(r1),	r12	;
    8a76:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00008a7a <.Loc.839.3>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    8a7a:	1c 41 06 00 	mov	6(r1),	r12	;
    8a7e:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    8a82:	00 00 

00008a84 <.Loc.841.3>:
  
  i2cp->buffer = txbuf;
    8a84:	1c 41 06 00 	mov	6(r1),	r12	;
    8a88:	ac 41 08 00 	mov	@r1,	8(r12)	;

00008a8c <.Loc.844.3>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    8a8c:	1c 41 06 00 	mov	6(r1),	r12	;
    8a90:	ac 41 0e 00 	mov	@r1,	14(r12)	; 0x000e

00008a94 <.Loc.845.3>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    8a94:	1c 41 06 00 	mov	6(r1),	r12	;
    8a98:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8a9c:	0d 4c       	mov	r12,	r13	;
    8a9e:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8aa2:	1c 41 06 00 	mov	6(r1),	r12	;
    8aa6:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00008aaa <.Loc.846.3>:
  i2cp->req.size = n;
    8aaa:	1c 41 06 00 	mov	6(r1),	r12	;
    8aae:	9c 41 02 00 	mov	2(r1),	18(r12)	; 0x0012
    8ab2:	12 00 

00008ab4 <.Loc.847.3>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    8ab4:	1c 41 06 00 	mov	6(r1),	r12	;
    8ab8:	bc 40 00 03 	mov	#768,	20(r12)	;#0x0300, 0x0014
    8abc:	14 00 

00008abe <.Loc.848.3>:
  i2cp->req.trigger = i2cp->txtrig;
    8abe:	1c 41 06 00 	mov	6(r1),	r12	;
    8ac2:	5c 4c 22 00 	mov.b	34(r12),r12	;0x00022
    8ac6:	0d 4c       	mov	r12,	r13	;
    8ac8:	1c 41 06 00 	mov	6(r1),	r12	;
    8acc:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008ad0 <.Loc.850.3>:
  /* Custom callback */
  i2cp->callback = callback;
    8ad0:	1c 41 06 00 	mov	6(r1),	r12	;
    8ad4:	9c 41 0a 00 	mov	10(r1),	10(r12)	;0x0000a, 0x000a
    8ad8:	0a 00 

00008ada <.Loc.852.3>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    8ada:	1c 41 06 00 	mov	6(r1),	r12	;
    8ade:	bc 40 24 84 	mov	#-31708,28(r12)	;#0x8424, 0x001c
    8ae2:	1c 00 

00008ae4 <.Loc.854.3>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    8ae4:	1c 41 06 00 	mov	6(r1),	r12	;
    8ae8:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8aec:	0c 93       	cmp	#0,	r12	;r3 As==00
    8aee:	0f 24       	jz	$+32     	;abs 0x8b0e

00008af0 <.Loc.854.3>:
    8af0:	1c 41 06 00 	mov	6(r1),	r12	;
    8af4:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8af8:	0c 93       	cmp	#0,	r12	;r3 As==00
    8afa:	09 24       	jz	$+20     	;abs 0x8b0e

00008afc <.Loc.854.3>:
    8afc:	1c 41 06 00 	mov	6(r1),	r12	;
    8b00:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8b04:	2c 4c       	mov	@r12,	r12	;
    8b06:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8b0a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b0c:	06 20       	jnz	$+14     	;abs 0x8b1a

00008b0e <.L78>:
    dmaAcquireI(&(i2cp->dma));
    8b0e:	1c 41 06 00 	mov	6(r1),	r12	;
    8b12:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8b16:	b0 12 54 81 	call	#-32428	;#0x8154

00008b1a <.L79>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    8b1a:	1c 41 06 00 	mov	6(r1),	r12	;
    8b1e:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8b22:	1d 41 06 00 	mov	6(r1),	r13	;
    8b26:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8b2a:	b0 12 76 82 	call	#-32138	;#0x8276

00008b2e <.Loc.860.3>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    8b2e:	1c 41 06 00 	mov	6(r1),	r12	;
    8b32:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8b36:	9c 41 04 00 	mov	4(r1),	32(r12)	; 0x0020
    8b3a:	20 00 

00008b3c <.Loc.861.3>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    8b3c:	1c 41 06 00 	mov	6(r1),	r12	;
    8b40:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8b44:	1d 41 06 00 	mov	6(r1),	r13	;
    8b48:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8b4c:	2d 4d       	mov	@r13,	r13	;
    8b4e:	3d d0 12 00 	bis	#18,	r13	;#0x0012
    8b52:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008b56 <.Loc.864.3>:
  /* IFG is set automatically after START */
  
}
    8b56:	03 43       	nop			
    8b58:	31 52       	add	#8,	r1	;r2 As==11
    8b5a:	30 41       	ret			

00008b5c <i2cMSP430XContinueTransmitMSBI>:

void i2cMSP430XContinueTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    8b5c:	31 82       	sub	#8,	r1	;r2 As==11

00008b5e <.LCFI13>:
    8b5e:	81 4c 06 00 	mov	r12,	6(r1)	;
    8b62:	81 4d 04 00 	mov	r13,	4(r1)	;
    8b66:	81 4e 02 00 	mov	r14,	2(r1)	;
    8b6a:	81 4f 00 00 	mov	r15,	0(r1)	;

00008b6e <.Loc.869.3>:
  
  osalDbgCheckClassI();
    8b6e:	b0 12 7c 66 	call	#26236		;#0x667c

00008b72 <.Loc.881.3>:
  osalDbgAssert(!(addr & 0x03FF), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x7F), "Invalid address");
#endif
  
  i2cp->buffer = txbuf;
    8b72:	1c 41 06 00 	mov	6(r1),	r12	;
    8b76:	ac 41 08 00 	mov	@r1,	8(r12)	;

00008b7a <.Loc.884.3>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    8b7a:	1c 41 02 00 	mov	2(r1),	r12	;
    8b7e:	3c 53       	add	#-1,	r12	;r3 As==11
    8b80:	2d 41       	mov	@r1,	r13	;
    8b82:	0d 5c       	add	r12,	r13	;
    8b84:	1c 41 06 00 	mov	6(r1),	r12	;
    8b88:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008b8c <.Loc.885.3>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    8b8c:	1c 41 06 00 	mov	6(r1),	r12	;
    8b90:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8b94:	0d 4c       	mov	r12,	r13	;
    8b96:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8b9a:	1c 41 06 00 	mov	6(r1),	r12	;
    8b9e:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00008ba2 <.Loc.886.3>:
  i2cp->req.size = n;
    8ba2:	1c 41 06 00 	mov	6(r1),	r12	;
    8ba6:	9c 41 02 00 	mov	2(r1),	18(r12)	; 0x0012
    8baa:	12 00 

00008bac <.Loc.887.3>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    8bac:	1c 41 06 00 	mov	6(r1),	r12	;
    8bb0:	bc 40 00 02 	mov	#512,	20(r12)	;#0x0200, 0x0014
    8bb4:	14 00 

00008bb6 <.Loc.888.3>:
  i2cp->req.trigger = i2cp->txtrig;
    8bb6:	1c 41 06 00 	mov	6(r1),	r12	;
    8bba:	5c 4c 22 00 	mov.b	34(r12),r12	;0x00022
    8bbe:	0d 4c       	mov	r12,	r13	;
    8bc0:	1c 41 06 00 	mov	6(r1),	r12	;
    8bc4:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008bc8 <.Loc.890.3>:
  /* Custom callback */
  i2cp->callback = callback;
    8bc8:	1c 41 06 00 	mov	6(r1),	r12	;
    8bcc:	9c 41 0a 00 	mov	10(r1),	10(r12)	;0x0000a, 0x000a
    8bd0:	0a 00 

00008bd2 <.Loc.892.3>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    8bd2:	1c 41 06 00 	mov	6(r1),	r12	;
    8bd6:	bc 40 24 84 	mov	#-31708,28(r12)	;#0x8424, 0x001c
    8bda:	1c 00 

00008bdc <.Loc.895.3>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    8bdc:	1c 41 06 00 	mov	6(r1),	r12	;
    8be0:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8be4:	1d 41 06 00 	mov	6(r1),	r13	;
    8be8:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8bec:	b0 12 76 82 	call	#-32138	;#0x8276

00008bf0 <.Loc.898.3>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    8bf0:	1c 41 06 00 	mov	6(r1),	r12	;
    8bf4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8bf8:	1d 41 06 00 	mov	6(r1),	r13	;
    8bfc:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8c00:	1d 4d 2c 00 	mov	44(r13),r13	;0x0002c
    8c04:	2d d3       	bis	#2,	r13	;r3 As==10
    8c06:	8c 4d 2c 00 	mov	r13,	44(r12)	; 0x002c

00008c0a <.Loc.900.3>:
  
}
    8c0a:	03 43       	nop			
    8c0c:	31 52       	add	#8,	r1	;r2 As==11
    8c0e:	30 41       	ret			

00008c10 <i2cMSP430XEndTransferI>:
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    8c10:	21 83       	decd	r1		;

00008c12 <.LCFI16>:
    8c12:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c16 <.Loc.976.3>:
  
  osalDbgCheckClassI();
    8c16:	b0 12 7c 66 	call	#26236		;#0x667c

00008c1a <.Loc.982.3>:
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    8c1a:	2c 41       	mov	@r1,	r12	;
    8c1c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8c20:	2d 41       	mov	@r1,	r13	;
    8c22:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8c26:	2d 4d       	mov	@r13,	r13	;
    8c28:	2d d2       	bis	#4,	r13	;r2 As==10
    8c2a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008c2e <.Loc.984.3>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    8c2e:	2c 41       	mov	@r1,	r12	;
    8c30:	6c 4c       	mov.b	@r12,	r12	;
    8c32:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8c34:	0b 20       	jnz	$+24     	;abs 0x8c4c

00008c36 <.Loc.986.3>:
    /* Enable RX interrupt to handle the last byte */
    i2cp->regs->ie |= UCRXIE0;
    8c36:	2c 41       	mov	@r1,	r12	;
    8c38:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8c3c:	2d 41       	mov	@r1,	r13	;
    8c3e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8c42:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    8c46:	1d d3       	bis	#1,	r13	;r3 As==01
    8c48:	8c 4d 2a 00 	mov	r13,	42(r12)	; 0x002a

00008c4c <.L86>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
  }
  
  while (i2cp->regs->ctlw0 & UCTXSTP) ;
    8c4c:	03 43       	nop			

00008c4e <.L85>:
    8c4e:	2c 41       	mov	@r1,	r12	;
    8c50:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8c54:	2c 4c       	mov	@r12,	r12	;
    8c56:	6c f2       	and.b	#4,	r12	;r2 As==10
    8c58:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c5a:	f9 23       	jnz	$-12     	;abs 0x8c4e

00008c5c <.Loc.994.3>:
  
  i2cp->state = I2C_READY;
    8c5c:	2c 41       	mov	@r1,	r12	;
    8c5e:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00008c62 <.Loc.995.3>:
}
    8c62:	03 43       	nop			
    8c64:	21 53       	incd	r1		;
    8c66:	30 41       	ret			

00008c68 <i2c_lld_master_receive_timeout>:
 *
 * @notapi
 */
msg_t i2c_lld_master_receive_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                     uint8_t *rxbuf, size_t rxbytes,
                                     systime_t timeout) {
    8c68:	0a 15       	pushm	#1,	r10	;16-bit words

00008c6a <.LCFI17>:
    8c6a:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00008c6e <.LCFI18>:
    8c6e:	81 4c 06 00 	mov	r12,	6(r1)	;
    8c72:	81 4d 04 00 	mov	r13,	4(r1)	;
    8c76:	81 4e 02 00 	mov	r14,	2(r1)	;
    8c7a:	81 4f 00 00 	mov	r15,	0(r1)	;

00008c7e <.Loc.1030.3>:
#else
  osalDbgAssert(!(addr & 0x7F), "Invalid address");
#endif
  
  /* So that setup doesn't add to timeout calc */
  start = osalOsGetSystemTimeX();
    8c7e:	b0 12 ec 83 	call	#-31764	;#0x83ec
    8c82:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008c86 <.Loc.1033.3>:
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    8c86:	1c 41 06 00 	mov	6(r1),	r12	;
    8c8a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00008c8e <.Loc.1035.3>:
  
  if (1 == rxbytes) {
    8c8e:	91 93 00 00 	cmp	#1,	0(r1)	;r3 As==01
    8c92:	45 20       	jnz	$+140    	;abs 0x8d1e

00008c94 <.Loc.1037.3>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    8c94:	1c 41 06 00 	mov	6(r1),	r12	;
    8c98:	9c 41 02 00 	mov	2(r1),	16(r12)	; 0x0010
    8c9c:	10 00 

00008c9e <.Loc.1038.3>:
    i2cp->req.size = 0;
    8c9e:	1c 41 06 00 	mov	6(r1),	r12	;
    8ca2:	8c 43 12 00 	mov	#0,	18(r12)	;r3 As==00, 0x0012

00008ca6 <.Loc.1040.3>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    8ca6:	1c 41 06 00 	mov	6(r1),	r12	;
    8caa:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8cae:	1d 41 06 00 	mov	6(r1),	r13	;
    8cb2:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8cb6:	2d 4d       	mov	@r13,	r13	;
    8cb8:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8cbc:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008cc0 <.Loc.1042.3>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    8cc0:	1c 41 06 00 	mov	6(r1),	r12	;
    8cc4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8cc8:	1d 41 06 00 	mov	6(r1),	r13	;
    8ccc:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8cd0:	2d 4d       	mov	@r13,	r13	;
    8cd2:	2d d3       	bis	#2,	r13	;r3 As==10
    8cd4:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008cd8 <.Loc.1044.3>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    8cd8:	03 43       	nop			

00008cda <.L89>:
    8cda:	1c 41 06 00 	mov	6(r1),	r12	;
    8cde:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8ce2:	2c 4c       	mov	@r12,	r12	;
    8ce4:	6c f3       	and.b	#2,	r12	;r3 As==10
    8ce6:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ce8:	f8 23       	jnz	$-14     	;abs 0x8cda

00008cea <.Loc.1045.3>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    8cea:	1c 41 06 00 	mov	6(r1),	r12	;
    8cee:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8cf2:	1d 41 06 00 	mov	6(r1),	r13	;
    8cf6:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8cfa:	2d 4d       	mov	@r13,	r13	;
    8cfc:	2d d2       	bis	#4,	r13	;r2 As==10
    8cfe:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008d02 <.Loc.1047.3>:
    /* Enable RX interrupt to handle the single received byte */
    i2cp->regs->ie |= UCRXIE0;
    8d02:	1c 41 06 00 	mov	6(r1),	r12	;
    8d06:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8d0a:	1d 41 06 00 	mov	6(r1),	r13	;
    8d0e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8d12:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    8d16:	1d d3       	bis	#1,	r13	;r3 As==01
    8d18:	8c 4d 2a 00 	mov	r13,	42(r12)	; 0x002a
    8d1c:	64 3c       	jmp	$+202    	;abs 0x8de6

00008d1e <.L88>:
  }
  else {
    /* Set up DMA */
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    8d1e:	1c 41 06 00 	mov	6(r1),	r12	;
    8d22:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8d26:	0d 4c       	mov	r12,	r13	;
    8d28:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    8d2c:	1c 41 06 00 	mov	6(r1),	r12	;
    8d30:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008d34 <.Loc.1052.3>:
    i2cp->req.dest_addr = rxbuf;
    8d34:	1c 41 06 00 	mov	6(r1),	r12	;
    8d38:	9c 41 02 00 	mov	2(r1),	16(r12)	; 0x0010
    8d3c:	10 00 

00008d3e <.Loc.1053.3>:
    i2cp->req.size = rxbytes - 1; /* have to stop early to generate STOP */
    8d3e:	2d 41       	mov	@r1,	r13	;
    8d40:	3d 53       	add	#-1,	r13	;r3 As==11
    8d42:	1c 41 06 00 	mov	6(r1),	r12	;
    8d46:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00008d4a <.Loc.1054.3>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    8d4a:	1c 41 06 00 	mov	6(r1),	r12	;
    8d4e:	bc 40 00 0c 	mov	#3072,	20(r12)	;#0x0c00, 0x0014
    8d52:	14 00 

00008d54 <.Loc.1055.3>:
    i2cp->req.trigger = i2cp->rxtrig;
    8d54:	1c 41 06 00 	mov	6(r1),	r12	;
    8d58:	5c 4c 23 00 	mov.b	35(r12),r12	;0x00023
    8d5c:	0d 4c       	mov	r12,	r13	;
    8d5e:	1c 41 06 00 	mov	6(r1),	r12	;
    8d62:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008d66 <.Loc.1056.3>:
    i2cp->req.callback.callback = &rx_complete;
    8d66:	1c 41 06 00 	mov	6(r1),	r12	;
    8d6a:	bc 40 4e 84 	mov	#-31666,28(r12)	;#0x844e, 0x001c
    8d6e:	1c 00 

00008d70 <.Loc.1058.3>:
    
  if (!dmaIsClaimed(&(i2cp->dma))) {
    8d70:	1c 41 06 00 	mov	6(r1),	r12	;
    8d74:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8d78:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d7a:	0f 24       	jz	$+32     	;abs 0x8d9a

00008d7c <.Loc.1058.3>:
    8d7c:	1c 41 06 00 	mov	6(r1),	r12	;
    8d80:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8d84:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d86:	09 24       	jz	$+20     	;abs 0x8d9a

00008d88 <.Loc.1058.3>:
    8d88:	1c 41 06 00 	mov	6(r1),	r12	;
    8d8c:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8d90:	2c 4c       	mov	@r12,	r12	;
    8d92:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8d96:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d98:	06 20       	jnz	$+14     	;abs 0x8da6

00008d9a <.L91>:
    dmaAcquireI(&(i2cp->dma));
    8d9a:	1c 41 06 00 	mov	6(r1),	r12	;
    8d9e:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8da2:	b0 12 54 81 	call	#-32428	;#0x8154

00008da6 <.L92>:
    /* TODO fallback */
  }
    
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    8da6:	1c 41 06 00 	mov	6(r1),	r12	;
    8daa:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8dae:	9c 41 04 00 	mov	4(r1),	32(r12)	; 0x0020
    8db2:	20 00 

00008db4 <.Loc.1065.3>:
    i2cp->regs->ctlw0 &= ~UCTR;
    8db4:	1c 41 06 00 	mov	6(r1),	r12	;
    8db8:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8dbc:	1d 41 06 00 	mov	6(r1),	r13	;
    8dc0:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8dc4:	2d 4d       	mov	@r13,	r13	;
    8dc6:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8dca:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008dce <.Loc.1066.3>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    8dce:	1c 41 06 00 	mov	6(r1),	r12	;
    8dd2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8dd6:	1d 41 06 00 	mov	6(r1),	r13	;
    8dda:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8dde:	2d 4d       	mov	@r13,	r13	;
    8de0:	2d d3       	bis	#2,	r13	;r3 As==10
    8de2:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008de6 <.L90>:
  }
  
  /* Wait until timeout, error, or transfer complete */
  msg_t msg;
  msg = osalThreadSuspendTimeoutS(&(i2cp->thread), 
    8de6:	1a 41 06 00 	mov	6(r1),	r10	;
    8dea:	3a 50 20 00 	add	#32,	r10	;#0x0020

00008dee <.Loc.1072.3>:
      timeout - (osalOsGetSystemTimeX() - start));
    8dee:	b0 12 ec 83 	call	#-31764	;#0x83ec
    8df2:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    8df6:	0d 8c       	sub	r12,	r13	;
    8df8:	0c 4d       	mov	r13,	r12	;
    8dfa:	1c 51 10 00 	add	16(r1),	r12	;0x00010

00008dfe <.Loc.1071.3>:
  msg = osalThreadSuspendTimeoutS(&(i2cp->thread), 
    8dfe:	0d 4c       	mov	r12,	r13	;
    8e00:	0c 4a       	mov	r10,	r12	;
    8e02:	b0 12 f2 83 	call	#-31758	;#0x83f2
    8e06:	81 4c 08 00 	mov	r12,	8(r1)	;

00008e0a <.Loc.1075.3>:
  
#if (MSP430X_I2C_EXCLUSIVE_DMA == TRUE)
  if (!(i2cp->dma_acquired)) {
    8e0a:	1c 41 06 00 	mov	6(r1),	r12	;
    8e0e:	5c 4c 2a 00 	mov.b	42(r12),r12	;0x0002a
    8e12:	5c e3       	xor.b	#1,	r12	;r3 As==01
    8e14:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e18:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e1a:	06 24       	jz	$+14     	;abs 0x8e28

00008e1c <.Loc.1076.3>:
    dmaReleaseX(&(i2cp->dma));
    8e1c:	1c 41 06 00 	mov	6(r1),	r12	;
    8e20:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8e24:	b0 12 32 83 	call	#-31950	;#0x8332

00008e28 <.L93>:
  }
#else
  dmaReleaseX(&(i2cp->dma));
#endif
  
  return msg;
    8e28:	1c 41 08 00 	mov	8(r1),	r12	;

00008e2c <.Loc.1083.3>:
}
    8e2c:	31 50 0c 00 	add	#12,	r1	;#0x000c
    8e30:	0a 17       	popm	#1,	r10	;16-bit words
    8e32:	30 41       	ret			

00008e34 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
    8e34:	0a 15       	pushm	#1,	r10	;16-bit words

00008e36 <L0>:
    8e36:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00008e3a <.LCFI20>:
    8e3a:	81 4c 06 00 	mov	r12,	6(r1)	;
    8e3e:	81 4d 04 00 	mov	r13,	4(r1)	;
    8e42:	81 4e 02 00 	mov	r14,	2(r1)	;
    8e46:	81 4f 00 00 	mov	r15,	0(r1)	;

00008e4a <.Loc.1122.3>:
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  /* So that setup doesn't add to timeout calc */
  start = osalOsGetSystemTimeX();
    8e4a:	b0 12 ec 83 	call	#-31764	;#0x83ec
    8e4e:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008e52 <.Loc.1125.3>:
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    8e52:	1c 41 06 00 	mov	6(r1),	r12	;
    8e56:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00008e5a <.Loc.1129.3>:
  
  /* Write first */
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    8e5a:	1c 41 06 00 	mov	6(r1),	r12	;
    8e5e:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    8e62:	0e 00 

00008e64 <.Loc.1130.3>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    8e64:	1c 41 06 00 	mov	6(r1),	r12	;
    8e68:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8e6c:	0d 4c       	mov	r12,	r13	;
    8e6e:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8e72:	1c 41 06 00 	mov	6(r1),	r12	;
    8e76:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00008e7a <.Loc.1131.3>:
  i2cp->req.size = txbytes;
    8e7a:	1c 41 06 00 	mov	6(r1),	r12	;
    8e7e:	ac 41 12 00 	mov	@r1,	18(r12)	; 0x0012

00008e82 <.Loc.1132.3>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    8e82:	1c 41 06 00 	mov	6(r1),	r12	;
    8e86:	bc 40 00 03 	mov	#768,	20(r12)	;#0x0300, 0x0014
    8e8a:	14 00 

00008e8c <.Loc.1133.3>:
  i2cp->req.trigger = i2cp->txtrig;
    8e8c:	1c 41 06 00 	mov	6(r1),	r12	;
    8e90:	5c 4c 22 00 	mov.b	34(r12),r12	;0x00022
    8e94:	0d 4c       	mov	r12,	r13	;
    8e96:	1c 41 06 00 	mov	6(r1),	r12	;
    8e9a:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008e9e <.Loc.1134.3>:
  i2cp->req.callback.callback = &tx_complete;
    8e9e:	1c 41 06 00 	mov	6(r1),	r12	;
    8ea2:	bc 40 24 84 	mov	#-31708,28(r12)	;#0x8424, 0x001c
    8ea6:	1c 00 

00008ea8 <.Loc.1136.3>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    8ea8:	1c 41 06 00 	mov	6(r1),	r12	;
    8eac:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8eb0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8eb2:	0f 24       	jz	$+32     	;abs 0x8ed2

00008eb4 <.Loc.1136.3>:
    8eb4:	1c 41 06 00 	mov	6(r1),	r12	;
    8eb8:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8ebc:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ebe:	09 24       	jz	$+20     	;abs 0x8ed2

00008ec0 <.Loc.1136.3>:
    8ec0:	1c 41 06 00 	mov	6(r1),	r12	;
    8ec4:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    8ec8:	2c 4c       	mov	@r12,	r12	;
    8eca:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    8ece:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ed0:	06 20       	jnz	$+14     	;abs 0x8ede

00008ed2 <.L96>:
    dmaAcquireI(&(i2cp->dma));
    8ed2:	1c 41 06 00 	mov	6(r1),	r12	;
    8ed6:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8eda:	b0 12 54 81 	call	#-32428	;#0x8154

00008ede <.L97>:
    /* TODO fallback */
  }
    
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    8ede:	1c 41 06 00 	mov	6(r1),	r12	;
    8ee2:	3c 50 24 00 	add	#36,	r12	;#0x0024
    8ee6:	1d 41 06 00 	mov	6(r1),	r13	;
    8eea:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8eee:	b0 12 76 82 	call	#-32138	;#0x8276

00008ef2 <.Loc.1144.3>:
  
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    8ef2:	1c 41 06 00 	mov	6(r1),	r12	;
    8ef6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8efa:	9c 41 04 00 	mov	4(r1),	32(r12)	; 0x0020
    8efe:	20 00 

00008f00 <.Loc.1145.3>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    8f00:	1c 41 06 00 	mov	6(r1),	r12	;
    8f04:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8f08:	1d 41 06 00 	mov	6(r1),	r13	;
    8f0c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8f10:	2d 4d       	mov	@r13,	r13	;
    8f12:	3d d0 12 00 	bis	#18,	r13	;#0x0012
    8f16:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008f1a <.Loc.1149.3>:
  /* IFG is set automatically after START */
  
  /* Wait until timeout or until transfer complete */
  result = osalThreadSuspendTimeoutS(&i2cp->thread, 
    8f1a:	1a 41 06 00 	mov	6(r1),	r10	;
    8f1e:	3a 50 20 00 	add	#32,	r10	;#0x0020

00008f22 <.Loc.1150.3>:
      timeout - (osalOsGetSystemTimeX() - start));
    8f22:	b0 12 ec 83 	call	#-31764	;#0x83ec
    8f26:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    8f2a:	0d 8c       	sub	r12,	r13	;
    8f2c:	0c 4d       	mov	r13,	r12	;
    8f2e:	1c 51 14 00 	add	20(r1),	r12	;0x00014

00008f32 <.Loc.1149.3>:
  result = osalThreadSuspendTimeoutS(&i2cp->thread, 
    8f32:	0d 4c       	mov	r12,	r13	;
    8f34:	0c 4a       	mov	r10,	r12	;
    8f36:	b0 12 f2 83 	call	#-31758	;#0x83f2
    8f3a:	81 4c 08 00 	mov	r12,	8(r1)	;

00008f3e <.Loc.1152.3>:
  
  if (MSG_OK != result) {
    8f3e:	81 93 08 00 	cmp	#0,	8(r1)	;r3 As==00
    8f42:	03 24       	jz	$+8      	;abs 0x8f4a

00008f44 <.Loc.1153.3>:
    return result;
    8f44:	1c 41 08 00 	mov	8(r1),	r12	;
    8f48:	c8 3c       	jmp	$+402    	;abs 0x90da

00008f4a <.L98>:
  }
  
  /* Now the read */
  /* If no read, short circuit that logic path */
  if (0 == rxbytes) {
    8f4a:	81 93 12 00 	cmp	#0,	18(r1)	;r3 As==00, 0x0012
    8f4e:	0d 20       	jnz	$+28     	;abs 0x8f6a

00008f50 <.Loc.1160.3>:
    /* Generate stop */
    i2cp->regs->ctlw0 |= UCTXSTP;
    8f50:	1c 41 06 00 	mov	6(r1),	r12	;
    8f54:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8f58:	1d 41 06 00 	mov	6(r1),	r13	;
    8f5c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8f60:	2d 4d       	mov	@r13,	r13	;
    8f62:	2d d2       	bis	#4,	r13	;r2 As==10
    8f64:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8f68:	95 3c       	jmp	$+300    	;abs 0x9094

00008f6a <.L100>:
    /*return MSG_OK;*/
  }
  else if (1 == rxbytes) {
    8f6a:	91 93 12 00 	cmp	#1,	18(r1)	;r3 As==01, 0x0012
    8f6e:	45 20       	jnz	$+140    	;abs 0x8ffa

00008f70 <.Loc.1165.3>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    8f70:	1c 41 06 00 	mov	6(r1),	r12	;
    8f74:	9c 41 10 00 	mov	16(r1),	16(r12)	;0x00010, 0x0010
    8f78:	10 00 

00008f7a <.Loc.1166.3>:
    i2cp->req.size = 0;
    8f7a:	1c 41 06 00 	mov	6(r1),	r12	;
    8f7e:	8c 43 12 00 	mov	#0,	18(r12)	;r3 As==00, 0x0012

00008f82 <.Loc.1168.3>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    8f82:	1c 41 06 00 	mov	6(r1),	r12	;
    8f86:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8f8a:	1d 41 06 00 	mov	6(r1),	r13	;
    8f8e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8f92:	2d 4d       	mov	@r13,	r13	;
    8f94:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    8f98:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008f9c <.Loc.1170.3>:
    /* Generate restart */
    i2cp->regs->ctlw0 |= UCTXSTT;
    8f9c:	1c 41 06 00 	mov	6(r1),	r12	;
    8fa0:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8fa4:	1d 41 06 00 	mov	6(r1),	r13	;
    8fa8:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8fac:	2d 4d       	mov	@r13,	r13	;
    8fae:	2d d3       	bis	#2,	r13	;r3 As==10
    8fb0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008fb4 <.Loc.1172.3>:
    /* Generate stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    8fb4:	03 43       	nop			

00008fb6 <.L103>:
    8fb6:	1c 41 06 00 	mov	6(r1),	r12	;
    8fba:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8fbe:	2c 4c       	mov	@r12,	r12	;
    8fc0:	6c f3       	and.b	#2,	r12	;r3 As==10
    8fc2:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fc4:	f8 23       	jnz	$-14     	;abs 0x8fb6

00008fc6 <.Loc.1173.3>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    8fc6:	1c 41 06 00 	mov	6(r1),	r12	;
    8fca:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8fce:	1d 41 06 00 	mov	6(r1),	r13	;
    8fd2:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8fd6:	2d 4d       	mov	@r13,	r13	;
    8fd8:	2d d2       	bis	#4,	r13	;r2 As==10
    8fda:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008fde <.Loc.1175.3>:
    /* Enable RX interrupt to handle the single received byte */
    i2cp->regs->ie |= UCRXIE0;
    8fde:	1c 41 06 00 	mov	6(r1),	r12	;
    8fe2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8fe6:	1d 41 06 00 	mov	6(r1),	r13	;
    8fea:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8fee:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    8ff2:	1d d3       	bis	#1,	r13	;r3 As==01
    8ff4:	8c 4d 2a 00 	mov	r13,	42(r12)	; 0x002a
    8ff8:	4d 3c       	jmp	$+156    	;abs 0x9094

00008ffa <.L102>:
  }
  else {
    /* Set up DMA */
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    8ffa:	1c 41 06 00 	mov	6(r1),	r12	;
    8ffe:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    9002:	0d 4c       	mov	r12,	r13	;
    9004:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    9008:	1c 41 06 00 	mov	6(r1),	r12	;
    900c:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00009010 <.Loc.1180.3>:
    i2cp->req.dest_addr = rxbuf;
    9010:	1c 41 06 00 	mov	6(r1),	r12	;
    9014:	9c 41 10 00 	mov	16(r1),	16(r12)	;0x00010, 0x0010
    9018:	10 00 

0000901a <.Loc.1181.3>:
    i2cp->req.size = rxbytes - 1;
    901a:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    901e:	3d 53       	add	#-1,	r13	;r3 As==11
    9020:	1c 41 06 00 	mov	6(r1),	r12	;
    9024:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00009028 <.Loc.1182.3>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    9028:	1c 41 06 00 	mov	6(r1),	r12	;
    902c:	bc 40 00 0c 	mov	#3072,	20(r12)	;#0x0c00, 0x0014
    9030:	14 00 

00009032 <.Loc.1183.3>:
    i2cp->req.trigger = i2cp->rxtrig;
    9032:	1c 41 06 00 	mov	6(r1),	r12	;
    9036:	5c 4c 23 00 	mov.b	35(r12),r12	;0x00023
    903a:	0d 4c       	mov	r12,	r13	;
    903c:	1c 41 06 00 	mov	6(r1),	r12	;
    9040:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00009044 <.Loc.1184.3>:
    i2cp->req.callback.callback = &rx_complete;
    9044:	1c 41 06 00 	mov	6(r1),	r12	;
    9048:	bc 40 4e 84 	mov	#-31666,28(r12)	;#0x844e, 0x001c
    904c:	1c 00 

0000904e <.Loc.1186.3>:
    
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    904e:	1c 41 06 00 	mov	6(r1),	r12	;
    9052:	3c 50 24 00 	add	#36,	r12	;#0x0024
    9056:	1d 41 06 00 	mov	6(r1),	r13	;
    905a:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    905e:	b0 12 76 82 	call	#-32138	;#0x8276

00009062 <.Loc.1189.3>:
    
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    9062:	1c 41 06 00 	mov	6(r1),	r12	;
    9066:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    906a:	1d 41 06 00 	mov	6(r1),	r13	;
    906e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    9072:	2d 4d       	mov	@r13,	r13	;
    9074:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    9078:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000907c <.Loc.1191.3>:
    /* Generate restart */
    i2cp->regs->ctlw0 |= UCTXSTT;
    907c:	1c 41 06 00 	mov	6(r1),	r12	;
    9080:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    9084:	1d 41 06 00 	mov	6(r1),	r13	;
    9088:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    908c:	2d 4d       	mov	@r13,	r13	;
    908e:	2d d3       	bis	#2,	r13	;r3 As==10
    9090:	8c 4d 00 00 	mov	r13,	0(r12)	;

00009094 <.L101>:
  }
    
  /* Wait until timeout or until transfer complete */
  result = osalThreadSuspendTimeoutS(&i2cp->thread, 
    9094:	1a 41 06 00 	mov	6(r1),	r10	;
    9098:	3a 50 20 00 	add	#32,	r10	;#0x0020

0000909c <.Loc.1196.3>:
      timeout - (osalOsGetSystemTimeX() - start));
    909c:	b0 12 ec 83 	call	#-31764	;#0x83ec
    90a0:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    90a4:	0d 8c       	sub	r12,	r13	;
    90a6:	0c 4d       	mov	r13,	r12	;
    90a8:	1c 51 14 00 	add	20(r1),	r12	;0x00014

000090ac <.Loc.1195.3>:
  result = osalThreadSuspendTimeoutS(&i2cp->thread, 
    90ac:	0d 4c       	mov	r12,	r13	;
    90ae:	0c 4a       	mov	r10,	r12	;
    90b0:	b0 12 f2 83 	call	#-31758	;#0x83f2
    90b4:	81 4c 08 00 	mov	r12,	8(r1)	;

000090b8 <.Loc.1199.3>:
  
#if (MSP430X_I2C_EXCLUSIVE_DMA == TRUE)
  if (!(i2cp->dma_acquired)) {
    90b8:	1c 41 06 00 	mov	6(r1),	r12	;
    90bc:	5c 4c 2a 00 	mov.b	42(r12),r12	;0x0002a
    90c0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    90c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    90c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    90c8:	06 24       	jz	$+14     	;abs 0x90d6

000090ca <.Loc.1200.3>:
    dmaReleaseX(&(i2cp->dma));
    90ca:	1c 41 06 00 	mov	6(r1),	r12	;
    90ce:	3c 50 24 00 	add	#36,	r12	;#0x0024
    90d2:	b0 12 32 83 	call	#-31950	;#0x8332

000090d6 <.L104>:
  }
#else
  dmaReleaseX(&(i2cp->dma));
#endif
  
  return result;
    90d6:	1c 41 08 00 	mov	8(r1),	r12	;

000090da <.L99>:
}
    90da:	31 50 0c 00 	add	#12,	r1	;#0x000c
    90de:	0a 17       	popm	#1,	r10	;16-bit words
    90e0:	30 41       	ret			

000090e2 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    90e2:	32 c2       	dint			

000090e4 <.Loc.46.1>:

}
    90e4:	03 43       	nop			
    90e6:	30 41       	ret			

000090e8 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    90e8:	ff 3f       	jmp	$+0      	;abs 0x90e8

000090ea <Vector2>:
    90ea:	ff 3f       	jmp	$+0      	;abs 0x90ea

000090ec <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    90ec:	ff 3f       	jmp	$+0      	;abs 0x90ec

000090ee <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    90ee:	ff 3f       	jmp	$+0      	;abs 0x90ee

000090f0 <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    90f0:	ff 3f       	jmp	$+0      	;abs 0x90f0

000090f2 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    90f2:	ff 3f       	jmp	$+0      	;abs 0x90f2

000090f4 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    90f4:	ff 3f       	jmp	$+0      	;abs 0x90f4

000090f6 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    90f6:	ff 3f       	jmp	$+0      	;abs 0x90f6

000090f8 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    90f8:	ff 3f       	jmp	$+0      	;abs 0x90f8

000090fa <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    90fa:	ff 3f       	jmp	$+0      	;abs 0x90fa

000090fc <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    90fc:	ff 3f       	jmp	$+0      	;abs 0x90fc

000090fe <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    90fe:	ff 3f       	jmp	$+0      	;abs 0x90fe

00009100 <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    9100:	ff 3f       	jmp	$+0      	;abs 0x9100

00009102 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    9102:	ff 3f       	jmp	$+0      	;abs 0x9102

00009104 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    9104:	ff 3f       	jmp	$+0      	;abs 0x9104

00009106 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    9106:	ff 3f       	jmp	$+0      	;abs 0x9106

00009108 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    9108:	ff 3f       	jmp	$+0      	;abs 0x9108

0000910a <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    910a:	ff 3f       	jmp	$+0      	;abs 0x910a

0000910c <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    910c:	ff 3f       	jmp	$+0      	;abs 0x910c

0000910e <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    910e:	ff 3f       	jmp	$+0      	;abs 0x910e

00009110 <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    9110:	ff 3f       	jmp	$+0      	;abs 0x9110

00009112 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    9112:	ff 3f       	jmp	$+0      	;abs 0x9112

00009114 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    9114:	ff 3f       	jmp	$+0      	;abs 0x9114

00009116 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    9116:	ff 3f       	jmp	$+0      	;abs 0x9116

00009118 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    9118:	ff 3f       	jmp	$+0      	;abs 0x9118

0000911a <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    911a:	ff 3f       	jmp	$+0      	;abs 0x911a

0000911c <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    911c:	ff 3f       	jmp	$+0      	;abs 0x911c

0000911e <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    911e:	ff 3f       	jmp	$+0      	;abs 0x911e

00009120 <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    9120:	ff 3f       	jmp	$+0      	;abs 0x9120

00009122 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    9122:	ff 3f       	jmp	$+0      	;abs 0x9122

00009124 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    9124:	ff 3f       	jmp	$+0      	;abs 0x9124

00009126 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    9126:	ff 3f       	jmp	$+0      	;abs 0x9126

00009128 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    9128:	ff 3f       	jmp	$+0      	;abs 0x9128

0000912a <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    912a:	ff 3f       	jmp	$+0      	;abs 0x912a

0000912c <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    912c:	ff 3f       	jmp	$+0      	;abs 0x912c

0000912e <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    912e:	ff 3f       	jmp	$+0      	;abs 0x912e

00009130 <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    9130:	ff 3f       	jmp	$+0      	;abs 0x9130

00009132 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    9132:	ff 3f       	jmp	$+0      	;abs 0x9132

00009134 <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    9134:	ff 3f       	jmp	$+0      	;abs 0x9134

00009136 <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    9136:	ff 3f       	jmp	$+0      	;abs 0x9136

00009138 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    9138:	ff 3f       	jmp	$+0      	;abs 0x9138

0000913a <Vector47>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    913a:	ff 3f       	jmp	$+0      	;abs 0x913a

0000913c <Vector50>:
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {

  while (1) {
    913c:	ff 3f       	jmp	$+0      	;abs 0x913c

0000913e <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    913e:	ff 3f       	jmp	$+0      	;abs 0x913e

00009140 <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    9140:	ff 3f       	jmp	$+0      	;abs 0x9140

00009142 <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    9142:	ff 3f       	jmp	$+0      	;abs 0x9142

00009144 <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    9144:	ff 3f       	jmp	$+0      	;abs 0x9144

00009146 <port_lock>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    9146:	32 c2       	dint			

00009148 <L0>:
  asm volatile("nop");
    9148:	03 43       	nop			

0000914a <.Loc.349.1>:
}
    914a:	03 43       	nop			
    914c:	30 41       	ret			

0000914e <port_unlock>:
  asm volatile("nop");
    914e:	03 43       	nop			

00009150 <.Loc.356.1>:
  _enable_interrupts();
    9150:	32 d2       	eint			
    9152:	03 43       	nop			

00009154 <.Loc.357.1>:
}
    9154:	03 43       	nop			
    9156:	30 41       	ret			

00009158 <port_lock_from_isr>:
}
    9158:	03 43       	nop			
    915a:	30 41       	ret			

0000915c <port_unlock_from_isr>:
}
    915c:	03 43       	nop			
    915e:	30 41       	ret			

00009160 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
    9160:	21 83       	decd	r1		;

00009162 <.LCFI0>:
    9162:	81 4c 00 00 	mov	r12,	0(r1)	;

00009166 <.Loc.143.2>:

  return chSemWait(&bsp->sem);
    9166:	2c 41       	mov	@r1,	r12	;
    9168:	4d 43       	clr.b	r13		;
    916a:	b0 12 10 6a 	call	#27152		;#0x6a10

0000916e <.Loc.144.2>:
}
    916e:	21 53       	incd	r1		;
    9170:	30 41       	ret			

00009172 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
    9172:	21 83       	decd	r1		;

00009174 <.LCFI1>:
    9174:	81 4c 00 00 	mov	r12,	0(r1)	;

00009178 <.Loc.268.2>:

  chDbgCheckClassI();
    9178:	b0 12 7c 66 	call	#26236		;#0x667c

0000917c <.Loc.270.2>:

  if (bsp->sem.cnt < (cnt_t)1) {
    917c:	2c 41       	mov	@r1,	r12	;
    917e:	2d 4c       	mov	@r12,	r13	;
    9180:	4c 43       	clr.b	r12		;
    9182:	0c 9d       	cmp	r13,	r12	;
    9184:	03 38       	jl	$+8      	;abs 0x918c

00009186 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    9186:	2c 41       	mov	@r1,	r12	;
    9188:	b0 12 ce 6a 	call	#27342		;#0x6ace

0000918c <.L9>:
  }
}
    918c:	03 43       	nop			
    918e:	21 53       	incd	r1		;
    9190:	30 41       	ret			

00009192 <rx_cb>:
  7U          /* DMA index */
};

static BSEMAPHORE_DECL(callback_triggered, true);

static void rx_cb(I2CDriver * i2cp, uint8_t * buf) {
    9192:	21 82       	sub	#4,	r1	;r2 As==10

00009194 <.LCFI2>:
    9194:	81 4c 02 00 	mov	r12,	2(r1)	;
    9198:	81 4d 00 00 	mov	r13,	0(r1)	;

0000919c <.Loc.54.3>:
  (void)buf;
  /* Now be done */
  chSysLockFromISR();
    919c:	b0 12 58 91 	call	#-28328	;#0x9158
    91a0:	b0 12 d8 65 	call	#26072		;#0x65d8

000091a4 <.Loc.55.3>:
  i2cMSP430XEndTransferI(i2cp);
    91a4:	1c 41 02 00 	mov	2(r1),	r12	;
    91a8:	b0 12 10 8c 	call	#-29680	;#0x8c10

000091ac <.Loc.56.3>:
  chBSemSignalI(&callback_triggered);
    91ac:	3c 40 b0 54 	mov	#21680,	r12	;#0x54b0
    91b0:	b0 12 72 91 	call	#-28302	;#0x9172

000091b4 <.Loc.57.3>:
  chSysUnlockFromISR();
    91b4:	b0 12 fa 65 	call	#26106		;#0x65fa
    91b8:	b0 12 5c 91 	call	#-28324	;#0x915c

000091bc <.Loc.59.3>:
  
}
    91bc:	03 43       	nop			
    91be:	21 52       	add	#4,	r1	;r2 As==10
    91c0:	30 41       	ret			

000091c2 <tx_cb>:

static void tx_cb(I2CDriver * i2cp, uint8_t * buf) {
    91c2:	31 80 06 00 	sub	#6,	r1	;

000091c6 <.LCFI3>:
    91c6:	81 4c 04 00 	mov	r12,	4(r1)	;
    91ca:	81 4d 02 00 	mov	r13,	2(r1)	;

000091ce <.Loc.64.3>:
  (void)buf;
  /* Now read back the numbers */
  chSysLockFromISR();
    91ce:	b0 12 58 91 	call	#-28328	;#0x9158
    91d2:	b0 12 d8 65 	call	#26072		;#0x65d8

000091d6 <.Loc.65.3>:
  i2cMSP430XStartReceiveI(i2cp, 0x50, 127, inbuf+127, rx_cb);
    91d6:	3c 40 2f 53 	mov	#21295,	r12	;#0x532f
    91da:	b1 40 92 91 	mov	#-28270,0(r1)	;#0x9192
    91de:	00 00 
    91e0:	0f 4c       	mov	r12,	r15	;
    91e2:	7e 40 7f 00 	mov.b	#127,	r14	;#0x007f
    91e6:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    91ea:	1c 41 04 00 	mov	4(r1),	r12	;
    91ee:	b0 12 a6 87 	call	#-30810	;#0x87a6

000091f2 <.Loc.66.3>:
  chSysUnlockFromISR();
    91f2:	b0 12 fa 65 	call	#26106		;#0x65fa
    91f6:	b0 12 5c 91 	call	#-28324	;#0x915c

000091fa <.Loc.67.3>:
}
    91fa:	03 43       	nop			
    91fc:	31 50 06 00 	add	#6,	r1	;
    9200:	30 41       	ret			

00009202 <msb_cb>:

static void msb_cb(I2CDriver * i2cp, uint8_t * buf) {
    9202:	31 80 06 00 	sub	#6,	r1	;

00009206 <.LCFI4>:
    9206:	81 4c 04 00 	mov	r12,	4(r1)	;
    920a:	81 4d 02 00 	mov	r13,	2(r1)	;

0000920e <.Loc.72.3>:
  (void)buf;
  /* Write the numbers in MSB order */
  chSysLockFromISR();
    920e:	b0 12 58 91 	call	#-28328	;#0x9158
    9212:	b0 12 d8 65 	call	#26072		;#0x65d8

00009216 <.Loc.73.3>:
  i2cMSP430XContinueTransmitMSBI(i2cp, 0x50, 127, outbuf+8, rx_cb);
    9216:	3c 40 b8 53 	mov	#21432,	r12	;#0x53b8
    921a:	b1 40 92 91 	mov	#-28270,0(r1)	;#0x9192
    921e:	00 00 
    9220:	0f 4c       	mov	r12,	r15	;
    9222:	7e 40 7f 00 	mov.b	#127,	r14	;#0x007f
    9226:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    922a:	1c 41 04 00 	mov	4(r1),	r12	;
    922e:	b0 12 5c 8b 	call	#-29860	;#0x8b5c

00009232 <.Loc.74.3>:
  chSysUnlockFromISR();
    9232:	b0 12 fa 65 	call	#26106		;#0x65fa
    9236:	b0 12 5c 91 	call	#-28324	;#0x915c

0000923a <.Loc.75.3>:
}
    923a:	03 43       	nop			
    923c:	31 50 06 00 	add	#6,	r1	;
    9240:	30 41       	ret			

00009242 <Thread1>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread1, 4096);
THD_FUNCTION(Thread1, arg) {
    9242:	1a 15       	pushm	#2,	r10	;16-bit words

00009244 <.LCFI5>:
    9244:	31 80 10 00 	sub	#16,	r1	;#0x0010

00009248 <.LCFI6>:
    9248:	81 4c 06 00 	mov	r12,	6(r1)	;

0000924c <.Loc.86.3>:

  (void)arg;
  
  /* Write to 0x4400 */
  outbuf[0] = 0x44;
    924c:	f2 40 44 00 	mov.b	#68,	&0x53b0	;#0x0044
    9250:	b0 53 

00009252 <.Loc.87.3>:
  outbuf[1] = 0x00;
    9252:	c2 43 b1 53 	mov.b	#0,	&0x53b1	;r3 As==00

00009256 <.Loc.89.3>:
  /* Write 0xAA55AA55 */
  outbuf[2] = 0xAA;
    9256:	f2 40 aa ff 	mov.b	#-86,	&0x53b2	;#0xffaa
    925a:	b2 53 

0000925c <.Loc.90.3>:
  outbuf[3] = 0x55;
    925c:	f2 40 55 00 	mov.b	#85,	&0x53b3	;#0x0055
    9260:	b3 53 

00009262 <.Loc.91.3>:
  outbuf[4] = 0xAA;
    9262:	f2 40 aa ff 	mov.b	#-86,	&0x53b4	;#0xffaa
    9266:	b4 53 

00009268 <.Loc.92.3>:
  outbuf[5] = 0x55;
    9268:	f2 40 55 00 	mov.b	#85,	&0x53b5	;#0x0055
    926c:	b5 53 

0000926e <.Loc.94.3>:
  /* Write to 0x2000 */
  outbuf[6] = 0x20;
    926e:	f2 40 20 00 	mov.b	#32,	&0x53b6	;#0x0020
    9272:	b6 53 

00009274 <.Loc.95.3>:
  outbuf[7] = 0x00;
    9274:	c2 43 b7 53 	mov.b	#0,	&0x53b7	;r3 As==00

00009278 <.Loc.97.3>:
  /* Write increasing numbers up to 127 */
  outbuf[8] = 1;
    9278:	d2 43 b8 53 	mov.b	#1,	&0x53b8	;r3 As==01

0000927c <.Loc.98.3>:
  outbuf[9] = 2;
    927c:	e2 43 b9 53 	mov.b	#2,	&0x53b9	;r3 As==10

00009280 <.Loc.99.3>:
  outbuf[10] = 3;
    9280:	f2 40 03 00 	mov.b	#3,	&0x53ba	;
    9284:	ba 53 

00009286 <.Loc.100.3>:
  outbuf[11] = 4;
    9286:	e2 42 bb 53 	mov.b	#4,	&0x53bb	;r2 As==10

0000928a <.Loc.101.3>:
  outbuf[12] = 5;
    928a:	f2 40 05 00 	mov.b	#5,	&0x53bc	;
    928e:	bc 53 

00009290 <.Loc.102.3>:
  outbuf[13] = 6;
    9290:	f2 40 06 00 	mov.b	#6,	&0x53bd	;
    9294:	bd 53 

00009296 <.Loc.103.3>:
  outbuf[14] = 7;
    9296:	f2 40 07 00 	mov.b	#7,	&0x53be	;
    929a:	be 53 

0000929c <.Loc.104.3>:
  outbuf[15] = 8;
    929c:	f2 42 bf 53 	mov.b	#8,	&0x53bf	;r2 As==11

000092a0 <.Loc.105.3>:
  outbuf[16] = 9;
    92a0:	f2 40 09 00 	mov.b	#9,	&0x53c0	;
    92a4:	c0 53 

000092a6 <.Loc.106.3>:
  outbuf[17] = 10;
    92a6:	f2 40 0a 00 	mov.b	#10,	&0x53c1	;#0x000a
    92aa:	c1 53 

000092ac <.Loc.107.3>:
  outbuf[18] = 11;
    92ac:	f2 40 0b 00 	mov.b	#11,	&0x53c2	;#0x000b
    92b0:	c2 53 

000092b2 <.Loc.108.3>:
  outbuf[19] = 12;
    92b2:	f2 40 0c 00 	mov.b	#12,	&0x53c3	;#0x000c
    92b6:	c3 53 

000092b8 <.Loc.109.3>:
  outbuf[20] = 13;
    92b8:	f2 40 0d 00 	mov.b	#13,	&0x53c4	;#0x000d
    92bc:	c4 53 

000092be <.Loc.110.3>:
  outbuf[21] = 14;
    92be:	f2 40 0e 00 	mov.b	#14,	&0x53c5	;#0x000e
    92c2:	c5 53 

000092c4 <.Loc.111.3>:
  outbuf[22] = 15;
    92c4:	f2 40 0f 00 	mov.b	#15,	&0x53c6	;#0x000f
    92c8:	c6 53 

000092ca <.Loc.112.3>:
  outbuf[23] = 16;
    92ca:	f2 40 10 00 	mov.b	#16,	&0x53c7	;#0x0010
    92ce:	c7 53 

000092d0 <.Loc.113.3>:
  outbuf[24] = 17;
    92d0:	f2 40 11 00 	mov.b	#17,	&0x53c8	;#0x0011
    92d4:	c8 53 

000092d6 <.Loc.114.3>:
  outbuf[25] = 18;
    92d6:	f2 40 12 00 	mov.b	#18,	&0x53c9	;#0x0012
    92da:	c9 53 

000092dc <.Loc.115.3>:
  outbuf[26] = 19;
    92dc:	f2 40 13 00 	mov.b	#19,	&0x53ca	;#0x0013
    92e0:	ca 53 

000092e2 <.Loc.116.3>:
  outbuf[27] = 20;
    92e2:	f2 40 14 00 	mov.b	#20,	&0x53cb	;#0x0014
    92e6:	cb 53 

000092e8 <.Loc.117.3>:
  outbuf[28] = 21;
    92e8:	f2 40 15 00 	mov.b	#21,	&0x53cc	;#0x0015
    92ec:	cc 53 

000092ee <.Loc.118.3>:
  outbuf[29] = 22;
    92ee:	f2 40 16 00 	mov.b	#22,	&0x53cd	;#0x0016
    92f2:	cd 53 

000092f4 <.Loc.119.3>:
  outbuf[30] = 23;
    92f4:	f2 40 17 00 	mov.b	#23,	&0x53ce	;#0x0017
    92f8:	ce 53 

000092fa <.Loc.120.3>:
  outbuf[31] = 24;
    92fa:	f2 40 18 00 	mov.b	#24,	&0x53cf	;#0x0018
    92fe:	cf 53 

00009300 <.Loc.121.3>:
  outbuf[32] = 25;
    9300:	f2 40 19 00 	mov.b	#25,	&0x53d0	;#0x0019
    9304:	d0 53 

00009306 <.Loc.122.3>:
  outbuf[33] = 26;
    9306:	f2 40 1a 00 	mov.b	#26,	&0x53d1	;#0x001a
    930a:	d1 53 

0000930c <.Loc.123.3>:
  outbuf[34] = 27;
    930c:	f2 40 1b 00 	mov.b	#27,	&0x53d2	;#0x001b
    9310:	d2 53 

00009312 <.Loc.124.3>:
  outbuf[35] = 28;
    9312:	f2 40 1c 00 	mov.b	#28,	&0x53d3	;#0x001c
    9316:	d3 53 

00009318 <.Loc.125.3>:
  outbuf[36] = 29;
    9318:	f2 40 1d 00 	mov.b	#29,	&0x53d4	;#0x001d
    931c:	d4 53 

0000931e <.Loc.126.3>:
  outbuf[37] = 30;
    931e:	f2 40 1e 00 	mov.b	#30,	&0x53d5	;#0x001e
    9322:	d5 53 

00009324 <.Loc.127.3>:
  outbuf[38] = 31;
    9324:	f2 40 1f 00 	mov.b	#31,	&0x53d6	;#0x001f
    9328:	d6 53 

0000932a <.Loc.128.3>:
  outbuf[39] = 32;
    932a:	f2 40 20 00 	mov.b	#32,	&0x53d7	;#0x0020
    932e:	d7 53 

00009330 <.Loc.129.3>:
  outbuf[40] = 33;
    9330:	f2 40 21 00 	mov.b	#33,	&0x53d8	;#0x0021
    9334:	d8 53 

00009336 <.Loc.130.3>:
  outbuf[41] = 34;
    9336:	f2 40 22 00 	mov.b	#34,	&0x53d9	;#0x0022
    933a:	d9 53 

0000933c <.Loc.131.3>:
  outbuf[42] = 35;
    933c:	f2 40 23 00 	mov.b	#35,	&0x53da	;#0x0023
    9340:	da 53 

00009342 <.Loc.132.3>:
  outbuf[43] = 36;
    9342:	f2 40 24 00 	mov.b	#36,	&0x53db	;#0x0024
    9346:	db 53 

00009348 <.Loc.133.3>:
  outbuf[44] = 37;
    9348:	f2 40 25 00 	mov.b	#37,	&0x53dc	;#0x0025
    934c:	dc 53 

0000934e <.Loc.134.3>:
  outbuf[45] = 38;
    934e:	f2 40 26 00 	mov.b	#38,	&0x53dd	;#0x0026
    9352:	dd 53 

00009354 <.Loc.135.3>:
  outbuf[46] = 39;
    9354:	f2 40 27 00 	mov.b	#39,	&0x53de	;#0x0027
    9358:	de 53 

0000935a <.Loc.136.3>:
  outbuf[47] = 40;
    935a:	f2 40 28 00 	mov.b	#40,	&0x53df	;#0x0028
    935e:	df 53 

00009360 <.Loc.137.3>:
  outbuf[48] = 41;
    9360:	f2 40 29 00 	mov.b	#41,	&0x53e0	;#0x0029
    9364:	e0 53 

00009366 <.Loc.138.3>:
  outbuf[49] = 42;
    9366:	f2 40 2a 00 	mov.b	#42,	&0x53e1	;#0x002a
    936a:	e1 53 

0000936c <.Loc.139.3>:
  outbuf[50] = 43;
    936c:	f2 40 2b 00 	mov.b	#43,	&0x53e2	;#0x002b
    9370:	e2 53 

00009372 <.Loc.140.3>:
  outbuf[51] = 44;
    9372:	f2 40 2c 00 	mov.b	#44,	&0x53e3	;#0x002c
    9376:	e3 53 

00009378 <.Loc.141.3>:
  outbuf[52] = 45;
    9378:	f2 40 2d 00 	mov.b	#45,	&0x53e4	;#0x002d
    937c:	e4 53 

0000937e <.Loc.142.3>:
  outbuf[53] = 46;
    937e:	f2 40 2e 00 	mov.b	#46,	&0x53e5	;#0x002e
    9382:	e5 53 

00009384 <.Loc.143.3>:
  outbuf[54] = 47;
    9384:	f2 40 2f 00 	mov.b	#47,	&0x53e6	;#0x002f
    9388:	e6 53 

0000938a <.Loc.144.3>:
  outbuf[55] = 48;
    938a:	f2 40 30 00 	mov.b	#48,	&0x53e7	;#0x0030
    938e:	e7 53 

00009390 <.Loc.145.3>:
  outbuf[56] = 49;
    9390:	f2 40 31 00 	mov.b	#49,	&0x53e8	;#0x0031
    9394:	e8 53 

00009396 <.Loc.146.3>:
  outbuf[57] = 50;
    9396:	f2 40 32 00 	mov.b	#50,	&0x53e9	;#0x0032
    939a:	e9 53 

0000939c <.Loc.147.3>:
  outbuf[58] = 51;
    939c:	f2 40 33 00 	mov.b	#51,	&0x53ea	;#0x0033
    93a0:	ea 53 

000093a2 <.Loc.148.3>:
  outbuf[59] = 52;
    93a2:	f2 40 34 00 	mov.b	#52,	&0x53eb	;#0x0034
    93a6:	eb 53 

000093a8 <.Loc.149.3>:
  outbuf[60] = 53;
    93a8:	f2 40 35 00 	mov.b	#53,	&0x53ec	;#0x0035
    93ac:	ec 53 

000093ae <.Loc.150.3>:
  outbuf[61] = 54;
    93ae:	f2 40 36 00 	mov.b	#54,	&0x53ed	;#0x0036
    93b2:	ed 53 

000093b4 <.Loc.151.3>:
  outbuf[62] = 55;
    93b4:	f2 40 37 00 	mov.b	#55,	&0x53ee	;#0x0037
    93b8:	ee 53 

000093ba <.Loc.152.3>:
  outbuf[63] = 56;
    93ba:	f2 40 38 00 	mov.b	#56,	&0x53ef	;#0x0038
    93be:	ef 53 

000093c0 <.Loc.153.3>:
  outbuf[64] = 57;
    93c0:	f2 40 39 00 	mov.b	#57,	&0x53f0	;#0x0039
    93c4:	f0 53 

000093c6 <.Loc.154.3>:
  outbuf[65] = 58;
    93c6:	f2 40 3a 00 	mov.b	#58,	&0x53f1	;#0x003a
    93ca:	f1 53 

000093cc <.Loc.155.3>:
  outbuf[66] = 59;
    93cc:	f2 40 3b 00 	mov.b	#59,	&0x53f2	;#0x003b
    93d0:	f2 53 

000093d2 <.Loc.156.3>:
  outbuf[67] = 60;
    93d2:	f2 40 3c 00 	mov.b	#60,	&0x53f3	;#0x003c
    93d6:	f3 53 

000093d8 <.Loc.157.3>:
  outbuf[68] = 61;
    93d8:	f2 40 3d 00 	mov.b	#61,	&0x53f4	;#0x003d
    93dc:	f4 53 

000093de <.Loc.158.3>:
  outbuf[69] = 62;
    93de:	f2 40 3e 00 	mov.b	#62,	&0x53f5	;#0x003e
    93e2:	f5 53 

000093e4 <.Loc.159.3>:
  outbuf[70] = 63;
    93e4:	f2 40 3f 00 	mov.b	#63,	&0x53f6	;#0x003f
    93e8:	f6 53 

000093ea <.Loc.160.3>:
  outbuf[71] = 64;
    93ea:	f2 40 40 00 	mov.b	#64,	&0x53f7	;#0x0040
    93ee:	f7 53 

000093f0 <.Loc.161.3>:
  outbuf[72] = 65;
    93f0:	f2 40 41 00 	mov.b	#65,	&0x53f8	;#0x0041
    93f4:	f8 53 

000093f6 <.Loc.162.3>:
  outbuf[73] = 66;
    93f6:	f2 40 42 00 	mov.b	#66,	&0x53f9	;#0x0042
    93fa:	f9 53 

000093fc <.Loc.163.3>:
  outbuf[74] = 67;
    93fc:	f2 40 43 00 	mov.b	#67,	&0x53fa	;#0x0043
    9400:	fa 53 

00009402 <.Loc.164.3>:
  outbuf[75] = 68;
    9402:	f2 40 44 00 	mov.b	#68,	&0x53fb	;#0x0044
    9406:	fb 53 

00009408 <.Loc.165.3>:
  outbuf[76] = 69;
    9408:	f2 40 45 00 	mov.b	#69,	&0x53fc	;#0x0045
    940c:	fc 53 

0000940e <.Loc.166.3>:
  outbuf[77] = 70;
    940e:	f2 40 46 00 	mov.b	#70,	&0x53fd	;#0x0046
    9412:	fd 53 

00009414 <.Loc.167.3>:
  outbuf[78] = 71;
    9414:	f2 40 47 00 	mov.b	#71,	&0x53fe	;#0x0047
    9418:	fe 53 

0000941a <.Loc.168.3>:
  outbuf[79] = 72;
    941a:	f2 40 48 00 	mov.b	#72,	&0x53ff	;#0x0048
    941e:	ff 53 

00009420 <.Loc.169.3>:
  outbuf[80] = 73;
    9420:	f2 40 49 00 	mov.b	#73,	&0x5400	;#0x0049
    9424:	00 54 

00009426 <.Loc.170.3>:
  outbuf[81] = 74;
    9426:	f2 40 4a 00 	mov.b	#74,	&0x5401	;#0x004a
    942a:	01 54 

0000942c <.Loc.171.3>:
  outbuf[82] = 75;
    942c:	f2 40 4b 00 	mov.b	#75,	&0x5402	;#0x004b
    9430:	02 54 

00009432 <.Loc.172.3>:
  outbuf[83] = 76;
    9432:	f2 40 4c 00 	mov.b	#76,	&0x5403	;#0x004c
    9436:	03 54 

00009438 <.Loc.173.3>:
  outbuf[84] = 77;
    9438:	f2 40 4d 00 	mov.b	#77,	&0x5404	;#0x004d
    943c:	04 54 

0000943e <.Loc.174.3>:
  outbuf[85] = 78;
    943e:	f2 40 4e 00 	mov.b	#78,	&0x5405	;#0x004e
    9442:	05 54 

00009444 <.Loc.175.3>:
  outbuf[86] = 79;
    9444:	f2 40 4f 00 	mov.b	#79,	&0x5406	;#0x004f
    9448:	06 54 

0000944a <.Loc.176.3>:
  outbuf[87] = 80;
    944a:	f2 40 50 00 	mov.b	#80,	&0x5407	;#0x0050
    944e:	07 54 

00009450 <.Loc.177.3>:
  outbuf[88] = 81;
    9450:	f2 40 51 00 	mov.b	#81,	&0x5408	;#0x0051
    9454:	08 54 

00009456 <.Loc.178.3>:
  outbuf[89] = 82;
    9456:	f2 40 52 00 	mov.b	#82,	&0x5409	;#0x0052
    945a:	09 54 

0000945c <.Loc.179.3>:
  outbuf[90] = 83;
    945c:	f2 40 53 00 	mov.b	#83,	&0x540a	;#0x0053
    9460:	0a 54 

00009462 <.Loc.180.3>:
  outbuf[91] = 84;
    9462:	f2 40 54 00 	mov.b	#84,	&0x540b	;#0x0054
    9466:	0b 54 

00009468 <.Loc.181.3>:
  outbuf[92] = 85;
    9468:	f2 40 55 00 	mov.b	#85,	&0x540c	;#0x0055
    946c:	0c 54 

0000946e <.Loc.182.3>:
  outbuf[93] = 86;
    946e:	f2 40 56 00 	mov.b	#86,	&0x540d	;#0x0056
    9472:	0d 54 

00009474 <.Loc.183.3>:
  outbuf[94] = 87;
    9474:	f2 40 57 00 	mov.b	#87,	&0x540e	;#0x0057
    9478:	0e 54 

0000947a <.Loc.184.3>:
  outbuf[95] = 88;
    947a:	f2 40 58 00 	mov.b	#88,	&0x540f	;#0x0058
    947e:	0f 54 

00009480 <.Loc.185.3>:
  outbuf[96] = 89;
    9480:	f2 40 59 00 	mov.b	#89,	&0x5410	;#0x0059
    9484:	10 54 

00009486 <.Loc.186.3>:
  outbuf[97] = 90;
    9486:	f2 40 5a 00 	mov.b	#90,	&0x5411	;#0x005a
    948a:	11 54 

0000948c <.Loc.187.3>:
  outbuf[98] = 91;
    948c:	f2 40 5b 00 	mov.b	#91,	&0x5412	;#0x005b
    9490:	12 54 

00009492 <.Loc.188.3>:
  outbuf[99] = 92;
    9492:	f2 40 5c 00 	mov.b	#92,	&0x5413	;#0x005c
    9496:	13 54 

00009498 <.Loc.189.3>:
  outbuf[100] = 93;
    9498:	f2 40 5d 00 	mov.b	#93,	&0x5414	;#0x005d
    949c:	14 54 

0000949e <.Loc.190.3>:
  outbuf[101] = 94;
    949e:	f2 40 5e 00 	mov.b	#94,	&0x5415	;#0x005e
    94a2:	15 54 

000094a4 <.Loc.191.3>:
  outbuf[102] = 95;
    94a4:	f2 40 5f 00 	mov.b	#95,	&0x5416	;#0x005f
    94a8:	16 54 

000094aa <.Loc.192.3>:
  outbuf[103] = 96;
    94aa:	f2 40 60 00 	mov.b	#96,	&0x5417	;#0x0060
    94ae:	17 54 

000094b0 <.Loc.193.3>:
  outbuf[104] = 97;
    94b0:	f2 40 61 00 	mov.b	#97,	&0x5418	;#0x0061
    94b4:	18 54 

000094b6 <.Loc.194.3>:
  outbuf[105] = 98;
    94b6:	f2 40 62 00 	mov.b	#98,	&0x5419	;#0x0062
    94ba:	19 54 

000094bc <.Loc.195.3>:
  outbuf[106] = 99;
    94bc:	f2 40 63 00 	mov.b	#99,	&0x541a	;#0x0063
    94c0:	1a 54 

000094c2 <.Loc.196.3>:
  outbuf[107] = 100;
    94c2:	f2 40 64 00 	mov.b	#100,	&0x541b	;#0x0064
    94c6:	1b 54 

000094c8 <.Loc.197.3>:
  outbuf[108] = 101;
    94c8:	f2 40 65 00 	mov.b	#101,	&0x541c	;#0x0065
    94cc:	1c 54 

000094ce <.Loc.198.3>:
  outbuf[109] = 102;
    94ce:	f2 40 66 00 	mov.b	#102,	&0x541d	;#0x0066
    94d2:	1d 54 

000094d4 <.Loc.199.3>:
  outbuf[110] = 103;
    94d4:	f2 40 67 00 	mov.b	#103,	&0x541e	;#0x0067
    94d8:	1e 54 

000094da <.Loc.200.3>:
  outbuf[111] = 104;
    94da:	f2 40 68 00 	mov.b	#104,	&0x541f	;#0x0068
    94de:	1f 54 

000094e0 <.Loc.201.3>:
  outbuf[112] = 105;
    94e0:	f2 40 69 00 	mov.b	#105,	&0x5420	;#0x0069
    94e4:	20 54 

000094e6 <.Loc.202.3>:
  outbuf[113] = 106;
    94e6:	f2 40 6a 00 	mov.b	#106,	&0x5421	;#0x006a
    94ea:	21 54 

000094ec <.Loc.203.3>:
  outbuf[114] = 107;
    94ec:	f2 40 6b 00 	mov.b	#107,	&0x5422	;#0x006b
    94f0:	22 54 

000094f2 <.Loc.204.3>:
  outbuf[115] = 108;
    94f2:	f2 40 6c 00 	mov.b	#108,	&0x5423	;#0x006c
    94f6:	23 54 

000094f8 <.Loc.205.3>:
  outbuf[116] = 109;
    94f8:	f2 40 6d 00 	mov.b	#109,	&0x5424	;#0x006d
    94fc:	24 54 

000094fe <.Loc.206.3>:
  outbuf[117] = 110;
    94fe:	f2 40 6e 00 	mov.b	#110,	&0x5425	;#0x006e
    9502:	25 54 

00009504 <.Loc.207.3>:
  outbuf[118] = 111;
    9504:	f2 40 6f 00 	mov.b	#111,	&0x5426	;#0x006f
    9508:	26 54 

0000950a <.Loc.208.3>:
  outbuf[119] = 112;
    950a:	f2 40 70 00 	mov.b	#112,	&0x5427	;#0x0070
    950e:	27 54 

00009510 <.Loc.209.3>:
  outbuf[120] = 113;
    9510:	f2 40 71 00 	mov.b	#113,	&0x5428	;#0x0071
    9514:	28 54 

00009516 <.Loc.210.3>:
  outbuf[121] = 114;
    9516:	f2 40 72 00 	mov.b	#114,	&0x5429	;#0x0072
    951a:	29 54 

0000951c <.Loc.211.3>:
  outbuf[122] = 115;
    951c:	f2 40 73 00 	mov.b	#115,	&0x542a	;#0x0073
    9520:	2a 54 

00009522 <.Loc.212.3>:
  outbuf[123] = 116;
    9522:	f2 40 74 00 	mov.b	#116,	&0x542b	;#0x0074
    9526:	2b 54 

00009528 <.Loc.213.3>:
  outbuf[124] = 117;
    9528:	f2 40 75 00 	mov.b	#117,	&0x542c	;#0x0075
    952c:	2c 54 

0000952e <.Loc.214.3>:
  outbuf[125] = 118;
    952e:	f2 40 76 00 	mov.b	#118,	&0x542d	;#0x0076
    9532:	2d 54 

00009534 <.Loc.215.3>:
  outbuf[126] = 119;
    9534:	f2 40 77 00 	mov.b	#119,	&0x542e	;#0x0077
    9538:	2e 54 

0000953a <.Loc.216.3>:
  outbuf[127] = 120;
    953a:	f2 40 78 00 	mov.b	#120,	&0x542f	;#0x0078
    953e:	2f 54 

00009540 <.Loc.217.3>:
  outbuf[128] = 121;
    9540:	f2 40 79 00 	mov.b	#121,	&0x5430	;#0x0079
    9544:	30 54 

00009546 <.Loc.218.3>:
  outbuf[129] = 122;
    9546:	f2 40 7a 00 	mov.b	#122,	&0x5431	;#0x007a
    954a:	31 54 

0000954c <.Loc.219.3>:
  outbuf[130] = 123;
    954c:	f2 40 7b 00 	mov.b	#123,	&0x5432	;#0x007b
    9550:	32 54 

00009552 <.Loc.220.3>:
  outbuf[131] = 124;
    9552:	f2 40 7c 00 	mov.b	#124,	&0x5433	;#0x007c
    9556:	33 54 

00009558 <.Loc.221.3>:
  outbuf[132] = 125;
    9558:	f2 40 7d 00 	mov.b	#125,	&0x5434	;#0x007d
    955c:	34 54 

0000955e <.Loc.222.3>:
  outbuf[133] = 126;
    955e:	f2 40 7e 00 	mov.b	#126,	&0x5435	;#0x007e
    9562:	35 54 

00009564 <.Loc.223.3>:
  outbuf[134] = 127;
    9564:	f2 40 7f 00 	mov.b	#127,	&0x5436	;#0x007f
    9568:	36 54 

0000956a <.Loc.228.3>:

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    956a:	4d 43       	clr.b	r13		;
    956c:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9570:	b0 12 b8 76 	call	#30392		;#0x76b8

00009574 <.Loc.231.3>:

  /* Activate the I2C driver B0 using its config */
  i2cStart(&I2CDB0, &I2CDB0_config);
    9574:	3d 40 aa 51 	mov	#20906,	r13	;#0x51aa
    9578:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    957c:	b0 12 2e 73 	call	#29486		;#0x732e

00009580 <.Loc.233.3>:

  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    9580:	30 40 ae 9b 	br	#0x9bae		;

00009584 <.L51>:
    chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));
    9584:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9588:	2a 4c       	mov	@r12,	r10	;
    958a:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    958e:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9592:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9596:	0e 4c       	mov	r12,	r14	;
    9598:	0d 49       	mov	r9,	r13	;
    959a:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    959e:	8a 12       	call	r10		;

000095a0 <.Loc.235.3>:
    chThdSleepMilliseconds(2000);
    95a0:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    95a4:	b0 12 ec 69 	call	#27116		;#0x69ec

000095a8 <.Loc.238.3>:
    
    /* Test 1 - Standard */
    chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));
    95a8:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    95ac:	2a 4c       	mov	@r12,	r10	;
    95ae:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    95b2:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    95b6:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    95ba:	0e 4c       	mov	r12,	r14	;
    95bc:	0d 49       	mov	r9,	r13	;
    95be:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    95c2:	8a 12       	call	r10		;

000095c4 <.Loc.239.3>:
    chThdSleepMilliseconds(2000);
    95c4:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    95c8:	b0 12 ec 69 	call	#27116		;#0x69ec

000095cc <.Loc.240.3>:
    outbuf[2] = 0xAA;
    95cc:	f2 40 aa ff 	mov.b	#-86,	&0x53b2	;#0xffaa
    95d0:	b2 53 

000095d2 <.Loc.241.3>:
    outbuf[3] = 0x55;
    95d2:	f2 40 55 00 	mov.b	#85,	&0x53b3	;#0x0055
    95d6:	b3 53 

000095d8 <.Loc.243.3>:
    /* Write 0xAA55AA55 to address 0x4400 on an ST M24M01 */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 6, NULL, 0, TIME_INFINITE);
    95d8:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    95dc:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    95e0:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    95e4:	7f 40 06 00 	mov.b	#6,	r15	;
    95e8:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    95ec:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    95f0:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    95f4:	b0 12 5e 73 	call	#29534		;#0x735e

000095f8 <.Loc.245.3>:
    
    while (I2CDB0.state != I2C_READY)
    95f8:	03 43       	nop			

000095fa <.L16>:
    95fa:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    95fe:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9600:	fc 23       	jnz	$-6      	;abs 0x95fa

00009602 <.Loc.248.3>:
      ; /* wait for transaction to finish */
    /* Wait max required time for write cycle */
    chThdSleepMilliseconds(6);
    9602:	7c 40 06 00 	mov.b	#6,	r12	;
    9606:	b0 12 ec 69 	call	#27116		;#0x69ec

0000960a <.Loc.250.3>:
    /* Read back 0xAA as random address read */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 2, inbuf, 1, TIME_INFINITE);
    960a:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    960e:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    9612:	b1 40 b0 52 	mov	#21168,	0(r1)	;#0x52b0
    9616:	00 00 
    9618:	6f 43       	mov.b	#2,	r15	;r3 As==10
    961a:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    961e:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9622:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9626:	b0 12 5e 73 	call	#29534		;#0x735e

0000962a <.Loc.251.3>:
    while (I2CDB0.state != I2C_READY)
    962a:	03 43       	nop			

0000962c <.L17>:
    962c:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9630:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9632:	fc 23       	jnz	$-6      	;abs 0x962c

00009634 <.Loc.254.3>:
      ; /* wait for transaction to finish */
    /* Wait max required time for write cycle */
    chThdSleepMilliseconds(6);
    9634:	7c 40 06 00 	mov.b	#6,	r12	;
    9638:	b0 12 ec 69 	call	#27116		;#0x69ec

0000963c <.Loc.256.3>:
    /* Read back 0x55AA55 as sequential current read */
    i2cMasterReceiveTimeout(&I2CDB0, 0x50, inbuf + 1, 3, TIME_INFINITE);
    963c:	3c 40 b1 52 	mov	#21169,	r12	;#0x52b1
    9640:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9644:	7f 40 03 00 	mov.b	#3,	r15	;
    9648:	0e 4c       	mov	r12,	r14	;
    964a:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    964e:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9652:	b0 12 da 73 	call	#29658		;#0x73da

00009656 <.Loc.257.3>:
    while (I2CDB0.state != I2C_READY)
    9656:	03 43       	nop			

00009658 <.L18>:
    9658:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    965c:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    965e:	fc 23       	jnz	$-6      	;abs 0x9658

00009660 <.Loc.259.3>:
      ; /* wait for transaction to finish */
    if ((inbuf[0] != 0xAA) ||
    9660:	5c 42 b0 52 	mov.b	&0x52b0,r12	;0x52b0
    9664:	7c 90 aa ff 	cmp.b	#-86,	r12	;#0xffaa
    9668:	0f 20       	jnz	$+32     	;abs 0x9688

0000966a <.Loc.260.3>:
        (inbuf[1] != 0x55) ||
    966a:	5c 42 b1 52 	mov.b	&0x52b1,r12	;0x52b1

0000966e <.Loc.259.3>:
    if ((inbuf[0] != 0xAA) ||
    966e:	7c 90 55 00 	cmp.b	#85,	r12	;#0x0055
    9672:	0a 20       	jnz	$+22     	;abs 0x9688

00009674 <.Loc.261.3>:
        (inbuf[2] != 0xAA) ||
    9674:	5c 42 b2 52 	mov.b	&0x52b2,r12	;0x52b2

00009678 <.Loc.260.3>:
        (inbuf[1] != 0x55) ||
    9678:	7c 90 aa ff 	cmp.b	#-86,	r12	;#0xffaa
    967c:	05 20       	jnz	$+12     	;abs 0x9688

0000967e <.Loc.262.3>:
        (inbuf[3] != 0x55)) {
    967e:	5c 42 b3 52 	mov.b	&0x52b3,r12	;0x52b3

00009682 <.Loc.261.3>:
        (inbuf[2] != 0xAA) ||
    9682:	7c 90 55 00 	cmp.b	#85,	r12	;#0x0055
    9686:	0f 24       	jz	$+32     	;abs 0x96a6

00009688 <.L19>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9688:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    968c:	2a 4c       	mov	@r12,	r10	;
    968e:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    9692:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    9696:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    969a:	0e 4c       	mov	r12,	r14	;
    969c:	0d 49       	mov	r9,	r13	;
    969e:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    96a2:	8a 12       	call	r10		;
    96a4:	0e 3c       	jmp	$+30     	;abs 0x96c2

000096a6 <.L20>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    96a6:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    96aa:	2a 4c       	mov	@r12,	r10	;
    96ac:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    96b0:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    96b4:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    96b8:	0e 4c       	mov	r12,	r14	;
    96ba:	0d 49       	mov	r9,	r13	;
    96bc:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    96c0:	8a 12       	call	r10		;

000096c2 <.L21>:
    }
    
    /* Test 2 - Exclusive */
    chnWrite(&SD0, (const uint8_t *)test_2_msg, strlen(test_2_msg));
    96c2:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    96c6:	2a 4c       	mov	@r12,	r10	;
    96c8:	19 42 9c 51 	mov	&0x519c,r9	;0x519c
    96cc:	1c 42 9c 51 	mov	&0x519c,r12	;0x519c
    96d0:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    96d4:	0e 4c       	mov	r12,	r14	;
    96d6:	0d 49       	mov	r9,	r13	;
    96d8:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    96dc:	8a 12       	call	r10		;

000096de <.Loc.271.3>:
    chThdSleepMilliseconds(2000);
    96de:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    96e2:	b0 12 ec 69 	call	#27116		;#0x69ec

000096e6 <.Loc.272.3>:
    outbuf[2] = 0xAB;
    96e6:	f2 40 ab ff 	mov.b	#-85,	&0x53b2	;#0xffab
    96ea:	b2 53 

000096ec <.Loc.273.3>:
    outbuf[3] = 0x56;
    96ec:	f2 40 56 00 	mov.b	#86,	&0x53b3	;#0x0056
    96f0:	b3 53 

000096f2 <.Loc.275.3>:
    /* Acquire bus */
    i2cAcquireBus(&I2CDB0);
    96f2:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    96f6:	b0 12 48 74 	call	#29768		;#0x7448

000096fa <.Loc.277.3>:
    /* Write 0xAB56 to address 0x4400 on an ST M24M01 */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 4, NULL, 0, TIME_INFINITE);
    96fa:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    96fe:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9702:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9706:	6f 42       	mov.b	#4,	r15	;r2 As==10
    9708:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    970c:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9710:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9714:	b0 12 5e 73 	call	#29534		;#0x735e

00009718 <.Loc.278.3>:
    while (I2CDB0.state != I2C_READY)
    9718:	03 43       	nop			

0000971a <.L22>:
    971a:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    971e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9720:	fc 23       	jnz	$-6      	;abs 0x971a

00009722 <.Loc.280.3>:
      ; /* wait for transaction to finish */
    chThdSleepMilliseconds(6);
    9722:	7c 40 06 00 	mov.b	#6,	r12	;
    9726:	b0 12 ec 69 	call	#27116		;#0x69ec

0000972a <.Loc.282.3>:
    /* Read back 0xAB as random address read */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 2, inbuf, 1, TIME_INFINITE);
    972a:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    972e:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    9732:	b1 40 b0 52 	mov	#21168,	0(r1)	;#0x52b0
    9736:	00 00 
    9738:	6f 43       	mov.b	#2,	r15	;r3 As==10
    973a:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    973e:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9742:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9746:	b0 12 5e 73 	call	#29534		;#0x735e

0000974a <.Loc.283.3>:
    while (I2CDB0.state != I2C_READY)
    974a:	03 43       	nop			

0000974c <.L23>:
    974c:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9750:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9752:	fc 23       	jnz	$-6      	;abs 0x974c

00009754 <.Loc.286.3>:
      ; /* wait for transaction to finish */
    /* Read back 0x56 as sequential current read */
    i2cMasterReceiveTimeout(&I2CDB0, 0x50, inbuf + 1, 1, TIME_INFINITE);
    9754:	3c 40 b1 52 	mov	#21169,	r12	;#0x52b1
    9758:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    975c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    975e:	0e 4c       	mov	r12,	r14	;
    9760:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9764:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9768:	b0 12 da 73 	call	#29658		;#0x73da

0000976c <.Loc.287.3>:
    while (I2CDB0.state != I2C_READY)
    976c:	03 43       	nop			

0000976e <.L24>:
    976e:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9772:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9774:	fc 23       	jnz	$-6      	;abs 0x976e

00009776 <.Loc.290.3>:
      ; /* wait for transaction to finish */
    /* Release bus */
    i2cReleaseBus(&I2CDB0);
    9776:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    977a:	b0 12 5e 74 	call	#29790		;#0x745e

0000977e <.Loc.292.3>:
    
    if ((inbuf[0] != 0xAB) ||
    977e:	5c 42 b0 52 	mov.b	&0x52b0,r12	;0x52b0
    9782:	7c 90 ab ff 	cmp.b	#-85,	r12	;#0xffab
    9786:	05 20       	jnz	$+12     	;abs 0x9792

00009788 <.Loc.293.3>:
        (inbuf[1] != 0x56)) {
    9788:	5c 42 b1 52 	mov.b	&0x52b1,r12	;0x52b1

0000978c <.Loc.292.3>:
    if ((inbuf[0] != 0xAB) ||
    978c:	7c 90 56 00 	cmp.b	#86,	r12	;#0x0056
    9790:	0f 24       	jz	$+32     	;abs 0x97b0

00009792 <.L25>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9792:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9796:	2a 4c       	mov	@r12,	r10	;
    9798:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    979c:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    97a0:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    97a4:	0e 4c       	mov	r12,	r14	;
    97a6:	0d 49       	mov	r9,	r13	;
    97a8:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    97ac:	8a 12       	call	r10		;
    97ae:	0e 3c       	jmp	$+30     	;abs 0x97cc

000097b0 <.L26>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    97b0:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    97b4:	2a 4c       	mov	@r12,	r10	;
    97b6:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    97ba:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    97be:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    97c2:	0e 4c       	mov	r12,	r14	;
    97c4:	0d 49       	mov	r9,	r13	;
    97c6:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    97ca:	8a 12       	call	r10		;

000097cc <.L27>:
    }

    /* Test 3 - Exclusive DMA */
    chnWrite(&SD0, (const uint8_t *)test_3_msg, strlen(test_3_msg));
    97cc:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    97d0:	2a 4c       	mov	@r12,	r10	;
    97d2:	19 42 9e 51 	mov	&0x519e,r9	;0x519e
    97d6:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    97da:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    97de:	0e 4c       	mov	r12,	r14	;
    97e0:	0d 49       	mov	r9,	r13	;
    97e2:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    97e6:	8a 12       	call	r10		;

000097e8 <.Loc.302.3>:
    chThdSleepMilliseconds(2000);
    97e8:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    97ec:	b0 12 ec 69 	call	#27116		;#0x69ec

000097f0 <.Loc.303.3>:
    outbuf[2] = 0xAC;
    97f0:	f2 40 ac ff 	mov.b	#-84,	&0x53b2	;#0xffac
    97f4:	b2 53 

000097f6 <.Loc.304.3>:
    outbuf[3] = 0x57;
    97f6:	f2 40 57 00 	mov.b	#87,	&0x53b3	;#0x0057
    97fa:	b3 53 

000097fc <.Loc.306.3>:
    /* Reconfigure for exclusive DMA on channel 0 */
    I2CDB0_config.dma_index = 0;
    97fc:	5c 42 ae 51 	mov.b	&0x51ae,r12	;0x51ae
    9800:	7c f0 e1 ff 	and.b	#-31,	r12	;#0xffe1
    9804:	c2 4c ae 51 	mov.b	r12,	&0x51ae	;

00009808 <.Loc.307.3>:
    i2cStart(&I2CDB0, &I2CDB0_config);
    9808:	3d 40 aa 51 	mov	#20906,	r13	;#0x51aa
    980c:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9810:	b0 12 2e 73 	call	#29486		;#0x732e

00009814 <.Loc.309.3>:
    /* Write 0xAC57 to address 0x4400 on an ST M24M01 */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 4, NULL, 0, TIME_INFINITE);
    9814:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    9818:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    981c:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9820:	6f 42       	mov.b	#4,	r15	;r2 As==10
    9822:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    9826:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    982a:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    982e:	b0 12 5e 73 	call	#29534		;#0x735e

00009832 <.Loc.310.3>:
    while (I2CDB0.state != I2C_READY)
    9832:	03 43       	nop			

00009834 <.L28>:
    9834:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9838:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    983a:	fc 23       	jnz	$-6      	;abs 0x9834

0000983c <.Loc.312.3>:
      ; /* wait for transaction to finish */
    chThdSleepMilliseconds(6);
    983c:	7c 40 06 00 	mov.b	#6,	r12	;
    9840:	b0 12 ec 69 	call	#27116		;#0x69ec

00009844 <.Loc.314.3>:
    /* Read back 0xAC as random address read */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf, 2, inbuf, 1, TIME_INFINITE);
    9844:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    9848:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    984c:	b1 40 b0 52 	mov	#21168,	0(r1)	;#0x52b0
    9850:	00 00 
    9852:	6f 43       	mov.b	#2,	r15	;r3 As==10
    9854:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    9858:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    985c:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9860:	b0 12 5e 73 	call	#29534		;#0x735e

00009864 <.Loc.315.3>:
    while (I2CDB0.state != I2C_READY)
    9864:	03 43       	nop			

00009866 <.L29>:
    9866:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    986a:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    986c:	fc 23       	jnz	$-6      	;abs 0x9866

0000986e <.Loc.318.3>:
      ; /* wait for transaction to finish */
    /* Read back 0x57 as sequential current read */
    i2cMasterReceiveTimeout(&I2CDB0, 0x50, inbuf + 1, 1, TIME_INFINITE);
    986e:	3c 40 b1 52 	mov	#21169,	r12	;#0x52b1
    9872:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9876:	5f 43       	mov.b	#1,	r15	;r3 As==01
    9878:	0e 4c       	mov	r12,	r14	;
    987a:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    987e:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9882:	b0 12 da 73 	call	#29658		;#0x73da

00009886 <.Loc.319.3>:
    while (I2CDB0.state != I2C_READY)
    9886:	03 43       	nop			

00009888 <.L30>:
    9888:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    988c:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    988e:	fc 23       	jnz	$-6      	;abs 0x9888

00009890 <.Loc.323.3>:
      ; /* wait for transaction to finish */
    
    /* Revert DMA situation */
    I2CDB0_config.dma_index = 7U;
    9890:	5c 42 ae 51 	mov.b	&0x51ae,r12	;0x51ae
    9894:	7c f0 e1 ff 	and.b	#-31,	r12	;#0xffe1
    9898:	7c d0 0e 00 	bis.b	#14,	r12	;#0x000e
    989c:	c2 4c ae 51 	mov.b	r12,	&0x51ae	;

000098a0 <.Loc.324.3>:
    i2cStart(&I2CDB0, &I2CDB0_config);
    98a0:	3d 40 aa 51 	mov	#20906,	r13	;#0x51aa
    98a4:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    98a8:	b0 12 2e 73 	call	#29486		;#0x732e

000098ac <.Loc.326.3>:
    
    if ((inbuf[0] != 0xAC) ||
    98ac:	5c 42 b0 52 	mov.b	&0x52b0,r12	;0x52b0
    98b0:	7c 90 ac ff 	cmp.b	#-84,	r12	;#0xffac
    98b4:	05 20       	jnz	$+12     	;abs 0x98c0

000098b6 <.Loc.327.3>:
        (inbuf[1] != 0x57)) {
    98b6:	5c 42 b1 52 	mov.b	&0x52b1,r12	;0x52b1

000098ba <.Loc.326.3>:
    if ((inbuf[0] != 0xAC) ||
    98ba:	7c 90 57 00 	cmp.b	#87,	r12	;#0x0057
    98be:	0f 24       	jz	$+32     	;abs 0x98de

000098c0 <.L31>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    98c0:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    98c4:	2a 4c       	mov	@r12,	r10	;
    98c6:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    98ca:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    98ce:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    98d2:	0e 4c       	mov	r12,	r14	;
    98d4:	0d 49       	mov	r9,	r13	;
    98d6:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    98da:	8a 12       	call	r10		;
    98dc:	0e 3c       	jmp	$+30     	;abs 0x98fa

000098de <.L32>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    98de:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    98e2:	2a 4c       	mov	@r12,	r10	;
    98e4:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    98e8:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    98ec:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    98f0:	0e 4c       	mov	r12,	r14	;
    98f2:	0d 49       	mov	r9,	r13	;
    98f4:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    98f8:	8a 12       	call	r10		;

000098fa <.L33>:
    }

    /* Test 4 - Long transfer */
    chnWrite(&SD0, (const uint8_t *)test_4_msg, strlen(test_4_msg));
    98fa:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    98fe:	2a 4c       	mov	@r12,	r10	;
    9900:	19 42 a0 51 	mov	&0x51a0,r9	;0x51a0
    9904:	1c 42 a0 51 	mov	&0x51a0,r12	;0x51a0
    9908:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    990c:	0e 4c       	mov	r12,	r14	;
    990e:	0d 49       	mov	r9,	r13	;
    9910:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9914:	8a 12       	call	r10		;

00009916 <.Loc.336.3>:
    chThdSleepMilliseconds(2000);
    9916:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    991a:	b0 12 ec 69 	call	#27116		;#0x69ec

0000991e <.Loc.338.3>:
    /* Write increasing numbers to address 0x2000 on an ST M24M01 */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf+6, 129, NULL, 0, TIME_INFINITE);
    991e:	3c 40 b6 53 	mov	#21430,	r12	;#0x53b6
    9922:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    9926:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    992a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    992e:	7f 40 81 00 	mov.b	#129,	r15	;#0x0081
    9932:	0e 4c       	mov	r12,	r14	;
    9934:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9938:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    993c:	b0 12 5e 73 	call	#29534		;#0x735e

00009940 <.Loc.339.3>:
    while (I2CDB0.state != I2C_READY)
    9940:	03 43       	nop			

00009942 <.L34>:
    9942:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9946:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9948:	fc 23       	jnz	$-6      	;abs 0x9942

0000994a <.Loc.341.3>:
      ; /* wait for transaction to finish */
    chThdSleepMilliseconds(6);
    994a:	7c 40 06 00 	mov.b	#6,	r12	;
    994e:	b0 12 ec 69 	call	#27116		;#0x69ec

00009952 <.Loc.343.3>:
    /* Read back increasing numbers */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf+6, 2, inbuf, 127, TIME_INFINITE);
    9952:	3c 40 b6 53 	mov	#21430,	r12	;#0x53b6
    9956:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    995a:	b1 40 7f 00 	mov	#127,	2(r1)	;#0x007f
    995e:	02 00 
    9960:	b1 40 b0 52 	mov	#21168,	0(r1)	;#0x52b0
    9964:	00 00 
    9966:	6f 43       	mov.b	#2,	r15	;r3 As==10
    9968:	0e 4c       	mov	r12,	r14	;
    996a:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    996e:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9972:	b0 12 5e 73 	call	#29534		;#0x735e

00009976 <.Loc.344.3>:
    while (I2CDB0.state != I2C_READY)
    9976:	03 43       	nop			

00009978 <.L35>:
    9978:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    997c:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    997e:	fc 23       	jnz	$-6      	;abs 0x9978

00009980 <.LBB3>:
      ; /* wait for transaction to finish */
    
    for (int i = 0; i < 127; i++) {
    9980:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    9984:	1c 3c       	jmp	$+58     	;abs 0x99be

00009986 <.L39>:
      if (inbuf[i] != i+1) {
    9986:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    998a:	3c 50 b0 52 	add	#21168,	r12	;#0x52b0
    998e:	6c 4c       	mov.b	@r12,	r12	;
    9990:	0d 4c       	mov	r12,	r13	;
    9992:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    9996:	1c 53       	inc	r12		;
    9998:	0d 9c       	cmp	r12,	r13	;
    999a:	0f 24       	jz	$+32     	;abs 0x99ba

0000999c <.Loc.349.3>:
        chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    999c:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    99a0:	2a 4c       	mov	@r12,	r10	;
    99a2:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    99a6:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    99aa:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    99ae:	0e 4c       	mov	r12,	r14	;
    99b0:	0d 49       	mov	r9,	r13	;
    99b2:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    99b6:	8a 12       	call	r10		;

000099b8 <.Loc.350.3>:
        break;
    99b8:	07 3c       	jmp	$+16     	;abs 0x99c8

000099ba <.L37>:
    for (int i = 0; i < 127; i++) {
    99ba:	91 53 0e 00 	inc	14(r1)		;

000099be <.L36>:
    99be:	7c 40 7e 00 	mov.b	#126,	r12	;#0x007e
    99c2:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    99c6:	df 37       	jge	$-64     	;abs 0x9986

000099c8 <.L38>:
      }
    }
    chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    99c8:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    99cc:	2a 4c       	mov	@r12,	r10	;
    99ce:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    99d2:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    99d6:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    99da:	0e 4c       	mov	r12,	r14	;
    99dc:	0d 49       	mov	r9,	r13	;
    99de:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    99e2:	8a 12       	call	r10		;

000099e4 <.Loc.356.3>:
    
    /* Test 5 - Callback-driven */
    chnWrite(&SD0, (const uint8_t *)test_5_msg, strlen(test_5_msg));
    99e4:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    99e8:	2a 4c       	mov	@r12,	r10	;
    99ea:	19 42 a2 51 	mov	&0x51a2,r9	;0x51a2
    99ee:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    99f2:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    99f6:	0e 4c       	mov	r12,	r14	;
    99f8:	0d 49       	mov	r9,	r13	;
    99fa:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    99fe:	8a 12       	call	r10		;

00009a00 <.Loc.357.3>:
    chThdSleepMilliseconds(2000);
    9a00:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    9a04:	b0 12 ec 69 	call	#27116		;#0x69ec

00009a08 <.Loc.359.3>:
    /* Read increasing numbers from address 0x2000 on an ST M24M01 */
    chSysLock();
    9a08:	b0 12 46 91 	call	#-28346	;#0x9146
    9a0c:	b0 12 96 65 	call	#26006		;#0x6596

00009a10 <.Loc.361.3>:
    /* Address first */
    i2cMSP430XStartTransmitI(&I2CDB0, 0x50, 2, outbuf+6, tx_cb);
    9a10:	3c 40 b6 53 	mov	#21430,	r12	;#0x53b6
    9a14:	b1 40 c2 91 	mov	#-28222,0(r1)	;#0x91c2
    9a18:	00 00 
    9a1a:	0f 4c       	mov	r12,	r15	;
    9a1c:	6e 43       	mov.b	#2,	r14	;r3 As==10
    9a1e:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9a22:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9a26:	b0 12 5c 8a 	call	#-30116	;#0x8a5c

00009a2a <.Loc.362.3>:
    chSysUnlock();
    9a2a:	b0 12 b6 65 	call	#26038		;#0x65b6
    9a2e:	b0 12 4e 91 	call	#-28338	;#0x914e

00009a32 <.Loc.364.3>:
    
    chBSemWait(&callback_triggered);
    9a32:	3c 40 b0 54 	mov	#21680,	r12	;#0x54b0
    9a36:	b0 12 60 91 	call	#-28320	;#0x9160

00009a3a <.Loc.365.3>:
    while (I2CDB0.state != I2C_READY)
    9a3a:	03 43       	nop			

00009a3c <.L40>:
    9a3c:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9a40:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9a42:	fc 23       	jnz	$-6      	;abs 0x9a3c

00009a44 <.LBB4>:
      ; /* wait for last byte */
    
    for (int i = 127; i < 254; i++) {
    9a44:	b1 40 7f 00 	mov	#127,	12(r1)	;#0x007f, 0x000c
    9a48:	0c 00 
    9a4a:	1d 3c       	jmp	$+60     	;abs 0x9a86

00009a4c <.L44>:
      if (inbuf[i] != i-126) {
    9a4c:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    9a50:	3c 50 b0 52 	add	#21168,	r12	;#0x52b0
    9a54:	6c 4c       	mov.b	@r12,	r12	;
    9a56:	0d 4c       	mov	r12,	r13	;
    9a58:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    9a5c:	3c 50 82 ff 	add	#-126,	r12	;#0xff82
    9a60:	0d 9c       	cmp	r12,	r13	;
    9a62:	0f 24       	jz	$+32     	;abs 0x9a82

00009a64 <.Loc.370.3>:
        chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9a64:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9a68:	2a 4c       	mov	@r12,	r10	;
    9a6a:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    9a6e:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    9a72:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9a76:	0e 4c       	mov	r12,	r14	;
    9a78:	0d 49       	mov	r9,	r13	;
    9a7a:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9a7e:	8a 12       	call	r10		;

00009a80 <.Loc.371.3>:
        break;
    9a80:	07 3c       	jmp	$+16     	;abs 0x9a90

00009a82 <.L42>:
    for (int i = 127; i < 254; i++) {
    9a82:	91 53 0c 00 	inc	12(r1)		;

00009a86 <.L41>:
    9a86:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    9a8a:	1c 91 0c 00 	cmp	12(r1),	r12	;0x0000c
    9a8e:	de 37       	jge	$-66     	;abs 0x9a4c

00009a90 <.L43>:
      }
    }
    chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9a90:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9a94:	2a 4c       	mov	@r12,	r10	;
    9a96:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    9a9a:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    9a9e:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9aa2:	0e 4c       	mov	r12,	r14	;
    9aa4:	0d 49       	mov	r9,	r13	;
    9aa6:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9aaa:	8a 12       	call	r10		;

00009aac <.Loc.377.3>:
    
    /* Test 6 - MSB-style */
    chnWrite(&SD0, (const uint8_t *)test_6_msg, strlen(test_6_msg));
    9aac:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9ab0:	2a 4c       	mov	@r12,	r10	;
    9ab2:	19 42 a4 51 	mov	&0x51a4,r9	;0x51a4
    9ab6:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    9aba:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9abe:	0e 4c       	mov	r12,	r14	;
    9ac0:	0d 49       	mov	r9,	r13	;
    9ac2:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9ac6:	8a 12       	call	r10		;

00009ac8 <.Loc.378.3>:
    chThdSleepMilliseconds(2000);
    9ac8:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    9acc:	b0 12 ec 69 	call	#27116		;#0x69ec

00009ad0 <.Loc.380.3>:
    /* Write decreasing numbers to address 0x2000 on an ST M24M01 */
    chSysLock();
    9ad0:	b0 12 46 91 	call	#-28346	;#0x9146
    9ad4:	b0 12 96 65 	call	#26006		;#0x6596

00009ad8 <.Loc.382.3>:
    /* Address first */
    uint16_t address = 0x2000;
    9ad8:	b1 40 00 20 	mov	#8192,	8(r1)	;#0x2000
    9adc:	08 00 

00009ade <.Loc.383.3>:
    i2cMSP430XStartTransmitMSBI(&I2CDB0, 0x50, 2, (uint8_t *)(&address), msb_cb);
    9ade:	0c 41       	mov	r1,	r12	;
    9ae0:	3c 52       	add	#8,	r12	;r2 As==11
    9ae2:	b1 40 02 92 	mov	#-28158,0(r1)	;#0x9202
    9ae6:	00 00 
    9ae8:	0f 4c       	mov	r12,	r15	;
    9aea:	6e 43       	mov.b	#2,	r14	;r3 As==10
    9aec:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9af0:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9af4:	b0 12 52 89 	call	#-30382	;#0x8952

00009af8 <.Loc.384.3>:
    chSysUnlock();
    9af8:	b0 12 b6 65 	call	#26038		;#0x65b6
    9afc:	b0 12 4e 91 	call	#-28338	;#0x914e

00009b00 <.Loc.386.3>:
    
    chBSemWait(&callback_triggered);
    9b00:	3c 40 b0 54 	mov	#21680,	r12	;#0x54b0
    9b04:	b0 12 60 91 	call	#-28320	;#0x9160

00009b08 <.Loc.387.3>:
    while (I2CDB0.state != I2C_READY)
    9b08:	03 43       	nop			

00009b0a <.L45>:
    9b0a:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9b0e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9b10:	fc 23       	jnz	$-6      	;abs 0x9b0a

00009b12 <.Loc.390.3>:
      ; /* wait for last byte */
    
    chThdSleepMilliseconds(6);
    9b12:	7c 40 06 00 	mov.b	#6,	r12	;
    9b16:	b0 12 ec 69 	call	#27116		;#0x69ec

00009b1a <.Loc.392.3>:
    /* Read back increasing numbers */
    i2cMasterTransmitTimeout(&I2CDB0, 0x50, outbuf+6, 2, inbuf, 127, TIME_INFINITE);
    9b1a:	3c 40 b6 53 	mov	#21430,	r12	;#0x53b6
    9b1e:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    9b22:	b1 40 7f 00 	mov	#127,	2(r1)	;#0x007f
    9b26:	02 00 
    9b28:	b1 40 b0 52 	mov	#21168,	0(r1)	;#0x52b0
    9b2c:	00 00 
    9b2e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    9b30:	0e 4c       	mov	r12,	r14	;
    9b32:	7d 40 50 00 	mov.b	#80,	r13	;#0x0050
    9b36:	3c 40 84 52 	mov	#21124,	r12	;#0x5284
    9b3a:	b0 12 5e 73 	call	#29534		;#0x735e

00009b3e <.Loc.394.3>:
    
    while (I2CDB0.state != I2C_READY)
    9b3e:	03 43       	nop			

00009b40 <.L46>:
    9b40:	5c 42 84 52 	mov.b	&0x5284,r12	;0x5284
    9b44:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9b46:	fc 23       	jnz	$-6      	;abs 0x9b40

00009b48 <.LBB5>:
      ; /* wait for transaction to finish */
    
    for (int i = 0; i < 127; i++) {
    9b48:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a
    9b4c:	1d 3c       	jmp	$+60     	;abs 0x9b88

00009b4e <.L50>:
      if (inbuf[i] != 127-i) {
    9b4e:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    9b52:	3c 50 b0 52 	add	#21168,	r12	;#0x52b0
    9b56:	6c 4c       	mov.b	@r12,	r12	;
    9b58:	0d 4c       	mov	r12,	r13	;
    9b5a:	7c 40 7f 00 	mov.b	#127,	r12	;#0x007f
    9b5e:	1c 81 0a 00 	sub	10(r1),	r12	;0x0000a
    9b62:	0d 9c       	cmp	r12,	r13	;
    9b64:	0f 24       	jz	$+32     	;abs 0x9b84

00009b66 <.Loc.399.3>:
        chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9b66:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9b6a:	2a 4c       	mov	@r12,	r10	;
    9b6c:	19 42 a8 51 	mov	&0x51a8,r9	;0x51a8
    9b70:	1c 42 a8 51 	mov	&0x51a8,r12	;0x51a8
    9b74:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9b78:	0e 4c       	mov	r12,	r14	;
    9b7a:	0d 49       	mov	r9,	r13	;
    9b7c:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9b80:	8a 12       	call	r10		;

00009b82 <.Loc.400.3>:
        break;
    9b82:	07 3c       	jmp	$+16     	;abs 0x9b92

00009b84 <.L48>:
    for (int i = 0; i < 127; i++) {
    9b84:	91 53 0a 00 	inc	10(r1)		;

00009b88 <.L47>:
    9b88:	7c 40 7e 00 	mov.b	#126,	r12	;#0x007e
    9b8c:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    9b90:	de 37       	jge	$-66     	;abs 0x9b4e

00009b92 <.L49>:
      }
    }
    chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9b92:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9b96:	2a 4c       	mov	@r12,	r10	;
    9b98:	19 42 a6 51 	mov	&0x51a6,r9	;0x51a6
    9b9c:	1c 42 a6 51 	mov	&0x51a6,r12	;0x51a6
    9ba0:	b0 12 ba 9d 	call	#-25158	;#0x9dba
    9ba4:	0e 4c       	mov	r12,	r14	;
    9ba6:	0d 49       	mov	r9,	r13	;
    9ba8:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9bac:	8a 12       	call	r10		;

00009bae <.L15>:
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    9bae:	1c 42 ea 51 	mov	&0x51ea,r12	;0x51ea
    9bb2:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    9bb6:	4d 43       	clr.b	r13		;
    9bb8:	3c 40 ea 51 	mov	#20970,	r12	;#0x51ea
    9bbc:	8e 12       	call	r14		;
    9bbe:	0c 93       	cmp	#0,	r12	;r3 As==00
    9bc0:	02 24       	jz	$+6      	;abs 0x9bc6
    9bc2:	80 00 84 95 	mova	#38276,	r0	;0x09584

00009bc6 <.Loc.406.3>:
    
  }
}
    9bc6:	03 43       	nop			
    9bc8:	31 50 10 00 	add	#16,	r1	;#0x0010

00009bcc <L0>:
    9bcc:	19 17       	popm	#2,	r10	;16-bit words
    9bce:	30 41       	ret			

00009bd0 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    9bd0:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    9bd4:	5c 01 

00009bd6 <.Loc.430.3>:

  halInit();
    9bd6:	b0 12 5e 6c 	call	#27742		;#0x6c5e

00009bda <.Loc.431.3>:
  chSysInit();
    9bda:	b0 12 b8 66 	call	#26296		;#0x66b8

00009bde <.Loc.432.3>:
  dmaInit();
    9bde:	b0 12 48 81 	call	#-32440	;#0x8148

00009be2 <.L53>:

  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    9be2:	ff 3f       	jmp	$+0      	;abs 0x9be2

00009be4 <udivmodsi4>:
    9be4:	5a 15       	pushm	#6,	r10	;16-bit words

00009be6 <L0>:
    9be6:	0a 4c       	mov	r12,	r10	;
    9be8:	0b 4d       	mov	r13,	r11	;

00009bea <.LVL1>:
    9bea:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00009bee <.Loc.35.1>:
    9bee:	58 43       	mov.b	#1,	r8	;r3 As==01
    9bf0:	49 43       	clr.b	r9		;

00009bf2 <.Loc.38.1>:
    9bf2:	07 4b       	mov	r11,	r7	;

00009bf4 <.L2>:
    9bf4:	0f 9b       	cmp	r11,	r15	;
    9bf6:	11 28       	jnc	$+36     	;abs 0x9c1a
    9bf8:	07 9f       	cmp	r15,	r7	;
    9bfa:	02 20       	jnz	$+6      	;abs 0x9c00
    9bfc:	0e 9a       	cmp	r10,	r14	;
    9bfe:	0d 28       	jnc	$+28     	;abs 0x9c1a

00009c00 <.L20>:
    9c00:	4c 43       	clr.b	r12		;

00009c02 <.LVL3>:
    9c02:	0d 4c       	mov	r12,	r13	;

00009c04 <.L5>:
    9c04:	07 48       	mov	r8,	r7	;
    9c06:	07 d9       	bis	r9,	r7	;
    9c08:	07 93       	cmp	#0,	r7	;r3 As==00
    9c0a:	19 20       	jnz	$+52     	;abs 0x9c3e

00009c0c <.L6>:
    9c0c:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    9c10:	02 24       	jz	$+6      	;abs 0x9c16
    9c12:	0c 4a       	mov	r10,	r12	;
    9c14:	0d 4b       	mov	r11,	r13	;

00009c16 <.L1>:
    9c16:	55 17       	popm	#6,	r10	;16-bit words
    9c18:	30 41       	ret			

00009c1a <.L3>:
    9c1a:	3d 53       	add	#-1,	r13	;r3 As==11

00009c1c <.Loc.38.1>:
    9c1c:	0d 93       	cmp	#0,	r13	;r3 As==00
    9c1e:	20 24       	jz	$+66     	;abs 0x9c60

00009c20 <.Loc.38.1>:
    9c20:	0f 93       	cmp	#0,	r15	;r3 As==00
    9c22:	ee 3b       	jl	$-34     	;abs 0x9c00

00009c24 <.Loc.40.1>:
    9c24:	05 4e       	mov	r14,	r5	;
    9c26:	06 4f       	mov	r15,	r6	;
    9c28:	05 5e       	add	r14,	r5	;
    9c2a:	06 6f       	addc	r15,	r6	;
    9c2c:	0e 45       	mov	r5,	r14	;

00009c2e <.LVL7>:
    9c2e:	0f 46       	mov	r6,	r15	;

00009c30 <.LVL8>:
    9c30:	05 48       	mov	r8,	r5	;
    9c32:	06 49       	mov	r9,	r6	;
    9c34:	05 58       	add	r8,	r5	;
    9c36:	06 69       	addc	r9,	r6	;
    9c38:	08 45       	mov	r5,	r8	;

00009c3a <.LVL9>:
    9c3a:	09 46       	mov	r6,	r9	;

00009c3c <.LVL10>:
    9c3c:	db 3f       	jmp	$-72     	;abs 0x9bf4

00009c3e <.L12>:
    9c3e:	0b 9f       	cmp	r15,	r11	;
    9c40:	08 28       	jnc	$+18     	;abs 0x9c52
    9c42:	0f 9b       	cmp	r11,	r15	;
    9c44:	02 20       	jnz	$+6      	;abs 0x9c4a
    9c46:	0a 9e       	cmp	r14,	r10	;
    9c48:	04 28       	jnc	$+10     	;abs 0x9c52

00009c4a <.L16>:
    9c4a:	0a 8e       	sub	r14,	r10	;
    9c4c:	0b 7f       	subc	r15,	r11	;

00009c4e <.Loc.48.1>:
    9c4e:	0c d8       	bis	r8,	r12	;

00009c50 <.LVL13>:
    9c50:	0d d9       	bis	r9,	r13	;

00009c52 <.L10>:
    9c52:	12 c3       	clrc			
    9c54:	09 10       	rrc	r9		;
    9c56:	08 10       	rrc	r8		;

00009c58 <.Loc.51.1>:
    9c58:	12 c3       	clrc			
    9c5a:	0f 10       	rrc	r15		;
    9c5c:	0e 10       	rrc	r14		;
    9c5e:	d2 3f       	jmp	$-90     	;abs 0x9c04

00009c60 <.L14>:
    9c60:	0c 4d       	mov	r13,	r12	;

00009c62 <.LVL18>:
    9c62:	d4 3f       	jmp	$-86     	;abs 0x9c0c

00009c64 <__mspabi_divlu>:
    9c64:	21 83       	decd	r1		;

00009c66 <.LCFI5>:
    9c66:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00009c6a <L0>:
    9c6a:	b0 12 e4 9b 	call	#-25628	;#0x9be4

00009c6e <.LVL46>:
    9c6e:	21 53       	incd	r1		;
    9c70:	30 41       	ret			

00009c72 <__mspabi_slli_15>:
    9c72:	0c 5c       	rla	r12		;

00009c74 <__mspabi_slli_14>:
    9c74:	0c 5c       	rla	r12		;

00009c76 <__mspabi_slli_13>:
    9c76:	0c 5c       	rla	r12		;

00009c78 <__mspabi_slli_12>:
    9c78:	0c 5c       	rla	r12		;

00009c7a <__mspabi_slli_11>:
    9c7a:	0c 5c       	rla	r12		;

00009c7c <__mspabi_slli_10>:
    9c7c:	0c 5c       	rla	r12		;

00009c7e <__mspabi_slli_9>:
    9c7e:	0c 5c       	rla	r12		;

00009c80 <__mspabi_slli_8>:
    9c80:	0c 5c       	rla	r12		;

00009c82 <__mspabi_slli_7>:
    9c82:	0c 5c       	rla	r12		;

00009c84 <__mspabi_slli_6>:
    9c84:	0c 5c       	rla	r12		;

00009c86 <__mspabi_slli_5>:
    9c86:	0c 5c       	rla	r12		;

00009c88 <__mspabi_slli_4>:
    9c88:	0c 5c       	rla	r12		;

00009c8a <__mspabi_slli_3>:
    9c8a:	0c 5c       	rla	r12		;

00009c8c <__mspabi_slli_2>:
    9c8c:	0c 5c       	rla	r12		;

00009c8e <__mspabi_slli_1>:
    9c8e:	0c 5c       	rla	r12		;
    9c90:	30 41       	ret			

00009c92 <.L11>:
    9c92:	3d 53       	add	#-1,	r13	;r3 As==11
    9c94:	0c 5c       	rla	r12		;

00009c96 <__mspabi_slli>:
    9c96:	0d 93       	cmp	#0,	r13	;r3 As==00
    9c98:	fc 23       	jnz	$-6      	;abs 0x9c92
    9c9a:	30 41       	ret			

00009c9c <__mspabi_slll_15>:
    9c9c:	0c 5c       	rla	r12		;
    9c9e:	0d 6d       	rlc	r13		;

00009ca0 <__mspabi_slll_14>:
    9ca0:	0c 5c       	rla	r12		;
    9ca2:	0d 6d       	rlc	r13		;

00009ca4 <__mspabi_slll_13>:
    9ca4:	0c 5c       	rla	r12		;
    9ca6:	0d 6d       	rlc	r13		;

00009ca8 <__mspabi_slll_12>:
    9ca8:	0c 5c       	rla	r12		;
    9caa:	0d 6d       	rlc	r13		;

00009cac <__mspabi_slll_11>:
    9cac:	0c 5c       	rla	r12		;
    9cae:	0d 6d       	rlc	r13		;

00009cb0 <__mspabi_slll_10>:
    9cb0:	0c 5c       	rla	r12		;
    9cb2:	0d 6d       	rlc	r13		;

00009cb4 <__mspabi_slll_9>:
    9cb4:	0c 5c       	rla	r12		;
    9cb6:	0d 6d       	rlc	r13		;

00009cb8 <__mspabi_slll_8>:
    9cb8:	0c 5c       	rla	r12		;
    9cba:	0d 6d       	rlc	r13		;

00009cbc <__mspabi_slll_7>:
    9cbc:	0c 5c       	rla	r12		;
    9cbe:	0d 6d       	rlc	r13		;

00009cc0 <__mspabi_slll_6>:
    9cc0:	0c 5c       	rla	r12		;
    9cc2:	0d 6d       	rlc	r13		;

00009cc4 <__mspabi_slll_5>:
    9cc4:	0c 5c       	rla	r12		;
    9cc6:	0d 6d       	rlc	r13		;

00009cc8 <__mspabi_slll_4>:
    9cc8:	0c 5c       	rla	r12		;
    9cca:	0d 6d       	rlc	r13		;

00009ccc <__mspabi_slll_3>:
    9ccc:	0c 5c       	rla	r12		;
    9cce:	0d 6d       	rlc	r13		;

00009cd0 <__mspabi_slll_2>:
    9cd0:	0c 5c       	rla	r12		;
    9cd2:	0d 6d       	rlc	r13		;

00009cd4 <__mspabi_slll_1>:
    9cd4:	0c 5c       	rla	r12		;
    9cd6:	0d 6d       	rlc	r13		;
    9cd8:	30 41       	ret			

00009cda <.L12>:
    9cda:	3e 53       	add	#-1,	r14	;r3 As==11
    9cdc:	0c 5c       	rla	r12		;
    9cde:	0d 6d       	rlc	r13		;

00009ce0 <__mspabi_slll>:
    9ce0:	0e 93       	cmp	#0,	r14	;r3 As==00
    9ce2:	fb 23       	jnz	$-8      	;abs 0x9cda
    9ce4:	30 41       	ret			

00009ce6 <__mspabi_srli_15>:
    9ce6:	12 c3       	clrc			
    9ce8:	0c 10       	rrc	r12		;

00009cea <__mspabi_srli_14>:
    9cea:	12 c3       	clrc			
    9cec:	0c 10       	rrc	r12		;

00009cee <__mspabi_srli_13>:
    9cee:	12 c3       	clrc			
    9cf0:	0c 10       	rrc	r12		;

00009cf2 <__mspabi_srli_12>:
    9cf2:	12 c3       	clrc			
    9cf4:	0c 10       	rrc	r12		;

00009cf6 <__mspabi_srli_11>:
    9cf6:	12 c3       	clrc			
    9cf8:	0c 10       	rrc	r12		;

00009cfa <__mspabi_srli_10>:
    9cfa:	12 c3       	clrc			
    9cfc:	0c 10       	rrc	r12		;

00009cfe <__mspabi_srli_9>:
    9cfe:	12 c3       	clrc			
    9d00:	0c 10       	rrc	r12		;

00009d02 <__mspabi_srli_8>:
    9d02:	12 c3       	clrc			
    9d04:	0c 10       	rrc	r12		;

00009d06 <__mspabi_srli_7>:
    9d06:	12 c3       	clrc			
    9d08:	0c 10       	rrc	r12		;

00009d0a <__mspabi_srli_6>:
    9d0a:	12 c3       	clrc			
    9d0c:	0c 10       	rrc	r12		;

00009d0e <__mspabi_srli_5>:
    9d0e:	12 c3       	clrc			
    9d10:	0c 10       	rrc	r12		;

00009d12 <__mspabi_srli_4>:
    9d12:	12 c3       	clrc			
    9d14:	0c 10       	rrc	r12		;

00009d16 <__mspabi_srli_3>:
    9d16:	12 c3       	clrc			
    9d18:	0c 10       	rrc	r12		;

00009d1a <__mspabi_srli_2>:
    9d1a:	12 c3       	clrc			
    9d1c:	0c 10       	rrc	r12		;

00009d1e <__mspabi_srli_1>:
    9d1e:	12 c3       	clrc			
    9d20:	0c 10       	rrc	r12		;
    9d22:	30 41       	ret			

00009d24 <.L11>:
    9d24:	3d 53       	add	#-1,	r13	;r3 As==11
    9d26:	12 c3       	clrc			
    9d28:	0c 10       	rrc	r12		;

00009d2a <__mspabi_srli>:
    9d2a:	0d 93       	cmp	#0,	r13	;r3 As==00
    9d2c:	fb 23       	jnz	$-8      	;abs 0x9d24
    9d2e:	30 41       	ret			

00009d30 <__mspabi_srll_15>:
    9d30:	12 c3       	clrc			
    9d32:	0d 10       	rrc	r13		;
    9d34:	0c 10       	rrc	r12		;

00009d36 <__mspabi_srll_14>:
    9d36:	12 c3       	clrc			
    9d38:	0d 10       	rrc	r13		;
    9d3a:	0c 10       	rrc	r12		;

00009d3c <__mspabi_srll_13>:
    9d3c:	12 c3       	clrc			
    9d3e:	0d 10       	rrc	r13		;
    9d40:	0c 10       	rrc	r12		;

00009d42 <__mspabi_srll_12>:
    9d42:	12 c3       	clrc			
    9d44:	0d 10       	rrc	r13		;
    9d46:	0c 10       	rrc	r12		;

00009d48 <__mspabi_srll_11>:
    9d48:	12 c3       	clrc			
    9d4a:	0d 10       	rrc	r13		;
    9d4c:	0c 10       	rrc	r12		;

00009d4e <__mspabi_srll_10>:
    9d4e:	12 c3       	clrc			
    9d50:	0d 10       	rrc	r13		;
    9d52:	0c 10       	rrc	r12		;

00009d54 <__mspabi_srll_9>:
    9d54:	12 c3       	clrc			
    9d56:	0d 10       	rrc	r13		;
    9d58:	0c 10       	rrc	r12		;

00009d5a <__mspabi_srll_8>:
    9d5a:	12 c3       	clrc			
    9d5c:	0d 10       	rrc	r13		;
    9d5e:	0c 10       	rrc	r12		;

00009d60 <__mspabi_srll_7>:
    9d60:	12 c3       	clrc			
    9d62:	0d 10       	rrc	r13		;
    9d64:	0c 10       	rrc	r12		;

00009d66 <__mspabi_srll_6>:
    9d66:	12 c3       	clrc			
    9d68:	0d 10       	rrc	r13		;
    9d6a:	0c 10       	rrc	r12		;

00009d6c <__mspabi_srll_5>:
    9d6c:	12 c3       	clrc			
    9d6e:	0d 10       	rrc	r13		;
    9d70:	0c 10       	rrc	r12		;

00009d72 <__mspabi_srll_4>:
    9d72:	12 c3       	clrc			
    9d74:	0d 10       	rrc	r13		;
    9d76:	0c 10       	rrc	r12		;

00009d78 <__mspabi_srll_3>:
    9d78:	12 c3       	clrc			
    9d7a:	0d 10       	rrc	r13		;
    9d7c:	0c 10       	rrc	r12		;

00009d7e <__mspabi_srll_2>:
    9d7e:	12 c3       	clrc			
    9d80:	0d 10       	rrc	r13		;
    9d82:	0c 10       	rrc	r12		;

00009d84 <__mspabi_srll_1>:
    9d84:	12 c3       	clrc			
    9d86:	0d 10       	rrc	r13		;
    9d88:	0c 10       	rrc	r12		;
    9d8a:	30 41       	ret			

00009d8c <.L12>:
    9d8c:	3e 53       	add	#-1,	r14	;r3 As==11
    9d8e:	12 c3       	clrc			
    9d90:	0d 10       	rrc	r13		;
    9d92:	0c 10       	rrc	r12		;

00009d94 <__mspabi_srll>:
    9d94:	0e 93       	cmp	#0,	r14	;r3 As==00
    9d96:	fa 23       	jnz	$-10     	;abs 0x9d8c
    9d98:	30 41       	ret			

00009d9a <__mspabi_mpyl>:
    9d9a:	02 12       	push	r2		;
    9d9c:	32 c2       	dint			
    9d9e:	03 43       	nop			
    9da0:	82 4c d0 04 	mov	r12,	&0x04d0	;
    9da4:	82 4d d2 04 	mov	r13,	&0x04d2	;
    9da8:	82 4e e0 04 	mov	r14,	&0x04e0	;
    9dac:	82 4f e2 04 	mov	r15,	&0x04e2	;
    9db0:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    9db4:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    9db8:	00 13       	reti			

00009dba <strlen>:
    9dba:	0d 4c       	mov	r12,	r13	;

00009dbc <.L2>:
    9dbc:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    9dc0:	02 24       	jz	$+6      	;abs 0x9dc6

00009dc2 <.Loc.86.1>:
    9dc2:	1d 53       	inc	r13		;
    9dc4:	fb 3f       	jmp	$-8      	;abs 0x9dbc

00009dc6 <.L5>:
    9dc6:	0d 8c       	sub	r12,	r13	;

00009dc8 <.LVL4>:
    9dc8:	0c 4d       	mov	r13,	r12	;

00009dca <.LVL5>:
    9dca:	30 41       	ret			

00009dcc <memmove>:
    9dcc:	0b 4c       	mov	r12,	r11	;

00009dce <L0>:
    9dce:	0b 5e       	add	r14,	r11	;

00009dd0 <.Loc.69.1>:
    9dd0:	0d 9c       	cmp	r12,	r13	;
    9dd2:	02 28       	jnc	$+6      	;abs 0x9dd8

00009dd4 <.L4>:
    9dd4:	0e 4c       	mov	r12,	r14	;

00009dd6 <.LVL2>:
    9dd6:	0f 3c       	jmp	$+32     	;abs 0x9df6

00009dd8 <.L2>:
    9dd8:	0f 4d       	mov	r13,	r15	;
    9dda:	0f 5e       	add	r14,	r15	;
    9ddc:	0c 9f       	cmp	r15,	r12	;
    9dde:	fa 2f       	jc	$-10     	;abs 0x9dd4

00009de0 <.LVL4>:
    9de0:	0d 4f       	mov	r15,	r13	;

00009de2 <.LVL5>:
    9de2:	0e 8f       	sub	r15,	r14	;

00009de4 <.L5>:
    9de4:	0f 4d       	mov	r13,	r15	;
    9de6:	0f 5e       	add	r14,	r15	;
    9de8:	0f 93       	cmp	#0,	r15	;r3 As==00
    9dea:	0c 24       	jz	$+26     	;abs 0x9e04

00009dec <.Loc.76.1>:
    9dec:	3b 53       	add	#-1,	r11	;r3 As==11
    9dee:	3d 53       	add	#-1,	r13	;r3 As==11

00009df0 <.LVL8>:
    9df0:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    9df4:	f7 3f       	jmp	$-16     	;abs 0x9de4

00009df6 <.L3>:
    9df6:	0b 9e       	cmp	r14,	r11	;
    9df8:	05 24       	jz	$+12     	;abs 0x9e04

00009dfa <.LVL10>:
    9dfa:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    9dfe:	1e 53       	inc	r14		;

00009e00 <.LVL11>:
    9e00:	1d 53       	inc	r13		;
    9e02:	f9 3f       	jmp	$-12     	;abs 0x9df6

00009e04 <.L9>:
    9e04:	30 41       	ret			

00009e06 <memset>:
    9e06:	0f 4c       	mov	r12,	r15	;
    9e08:	0e 5c       	add	r12,	r14	;

00009e0a <.L2>:
    9e0a:	0f 9e       	cmp	r14,	r15	;

00009e0c <L0>:
    9e0c:	04 24       	jz	$+10     	;abs 0x9e16

00009e0e <.LVL3>:
    9e0e:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    9e12:	1f 53       	inc	r15		;

00009e14 <.LVL4>:
    9e14:	fa 3f       	jmp	$-10     	;abs 0x9e0a

00009e16 <.L5>:
    9e16:	30 41       	ret			
