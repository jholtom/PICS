
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	64 44       	mov.b	@r4,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	68 44       	mov.b	@r4,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	6c 44       	mov.b	@r4,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	70 44       	br	@r4+		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	74 44       	mov.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	78 44       	mov.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	7c 44       	mov.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	80 44 00 00 	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	84 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8c 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	90 44 00 00 	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	94 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	9c 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a0 44 00 00 	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a4 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	ac 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b0 44 00 00 	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b4 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b8 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c0 44 00 00 	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c4 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c8 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	cc 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 44 00 00 	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d4 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d8 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	dc 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e0 44 00 00 	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	52 f4       	and.b,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	e6 f3       	and.b	#2		;r3 As==10, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e4 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	e8 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	7a f3       	and.b	#-1,	r10	;r3 As==11

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	f0 44 00 00 	mov.b	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	1e f3       	and	#1,	r14	;r3 As==01

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	f8 f7       	interrupt service routine at 0xf7f8

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f4 44       	interrupt service routine at 0x44f4

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	be f4       	interrupt service routine at 0xf4be

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	ea f6       	interrupt service routine at 0xf6ea

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	f8 44       	interrupt service routine at 0x44f8

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	fc 44       	interrupt service routine at 0x44fc

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	00 45       	interrupt service routine at 0x4500

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	50 f5       	interrupt service routine at 0xf550

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	04 45       	interrupt service routine at 0x4504

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	08 45       	interrupt service routine at 0x4508

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	fc f2       	interrupt service routine at 0xf2fc

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	0c 45       	interrupt service routine at 0x450c

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	10 45       	interrupt service routine at 0x4510

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	14 45       	interrupt service routine at 0x4514

Disassembly of section .text:

00004400 <__crt0_start>:
#ifdef MINRT
	.refsym	__crt0_call_just_main
#else
	.refsym	__crt0_call_init_then_main
#endif
	mov_	#__stack, R1
    4400:	81 00 52 cf 	mova	#53074,	r1	;0x0cf52

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
;; application if it is needed.  It is responsible for initializing
;; the contents of the .bss section.

START_CRT_FUNC 0100 init_bss

	mov_	#__bssstart, R12
    440c:	8c 00 d0 cf 	mova	#53200,	r12	;0x0cfd0

00004410 <.Loc.74.1>:
	clr.w	R13
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
	mov.w	#__bsssize, R14
    4412:	3e 40 2c 23 	mov	#9004,	r14	;#0x232c

00004416 <.Loc.77.1>:
#ifdef __MSP430X_LARGE__
	clr.w	R15		; We assume that __bsssize is never > 64M
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
#endif
	call_	#memset
    4418:	b0 13 38 ce 	calla	#52792		;0x0ce38

0000441c <__crt0_init_highbss>:
;; application if it is needed.  It is responsible for initializing
;; the contents of the .upper.bss section.

START_CRT_FUNC 0200 init_highbss
	
	mov_	#__high_bssstart, R12
    441c:	8c 01 ea 14 	mova	#70890,	r12	;0x114ea

00004420 <.Loc.94.1>:
	mov.w	#0, R13
    4420:	0d 43       	clr	r13		;

00004422 <.Loc.95.1>:
	mov_	#__high_bsssize, R14
    4422:	8e 01 10 1c 	mova	#72720,	r14	;0x11c10

00004426 <.Loc.98.1>:
	;; If __high_bsssize is zero then skip the call to memset.
	;; This can happen if all of the bss data was placed into .either.bss.
	cmp.w	#0, R14
    4426:	0e 93       	cmp	#0,	r14	;r3 As==00

00004428 <.Loc.99.1>:
	jeq	1f
    4428:	02 24       	jz	$+6      	;abs 0x442e

0000442a <.Loc.100.1>:
	call_	#memset
    442a:	b0 13 38 ce 	calla	#52792		;0x0ce38

0000442e <__crt0_move_highdata>:
START_CRT_FUNC 0400 move_highdata
	;;  __rom_highdatacopysize may be zero.  Test this first because
	;; its value may come from the weak definitions above and we do
	;; not want to access the memory at address 0 pointed to by the
	;; weak definition of __upper_data_init.
	mov.w	#__rom_highdatacopysize, R14
    442e:	3e 40 7e 0a 	mov	#2686,	r14	;#0x0a7e

00004432 <.Loc.146.1>:
	cmp.w	#0, R14
    4432:	0e 93       	cmp	#0,	r14	;r3 As==00

00004434 <.Loc.147.1>:
	jeq	3f
    4434:	14 24       	jz	$+42     	;abs 0x445e

00004436 <.Loc.150.1>:

	/* Test our status word.  */
	cmpx.w  #0, &__upper_data_init
    4436:	41 18 82 93 	cmpx.w	#0,	&0x10a6a;r3 As==00
    443a:	6a 0a 

0000443c <.Loc.151.1>:
	jeq	1f
    443c:	05 24       	jz	$+12     	;abs 0x4448

0000443e <.Loc.153.1>:
	/* Status word is non-zero - copy from shadow into upper.  */
	mov_	#__high_datastart, R12
    443e:	8c 01 6c 0a 	mova	#68204,	r12	;0x10a6c

00004442 <.Loc.154.1>:
	mov_	#__rom_highdatastart, R13
    4442:	8d 01 6c 0a 	mova	#68204,	r13	;0x10a6c

00004446 <.Loc.155.1>:
	jmp	2f
    4446:	07 3c       	jmp	$+16     	;abs 0x4456

00004448 <.L11>:

1:	/* Status word is zero.  Copy from upper to shadow and change status word.  */
	movx.w  #1, &__upper_data_init
    4448:	41 18 92 43 	movx.w	#1,	&0x10a6a;r3 As==01
    444c:	6a 0a 

0000444e <.Loc.159.1>:
	mov_	#__rom_highdatastart, R12
    444e:	8c 01 6c 0a 	mova	#68204,	r12	;0x10a6c

00004452 <.Loc.160.1>:
	mov_	#__high_datastart, R13
    4452:	8d 01 6c 0a 	mova	#68204,	r13	;0x10a6c

00004456 <.L21>:

2:	;; __rom_highdatacopysize may be zero.  memmove should cope.
	mov.w	#__rom_highdatacopysize, R14
    4456:	3e 40 7e 0a 	mov	#2686,	r14	;#0x0a7e

0000445a <.Loc.165.1>:

	call_	#memmove
    445a:	b0 13 e2 cd 	calla	#52706		;0x0cde2

0000445e <__crt0_call_just_main>:
;; main.  No initialization code is called first, and main is not
;; expected to return.

START_CRT_FUNC 0600 call_just_main

	clr.w	R12		; Set argc == 0
    445e:	0c 43       	clr	r12		;

00004460 <.Loc.181.1>:
	call_	#main
    4460:	b0 13 8e c1 	calla	#49550		;0x0c18e

00004464 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4464:	80 00 64 44 	mova	#17508,	r0	;0x04464

00004468 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    4468:	80 00 68 44 	mova	#17512,	r0	;0x04468

0000446c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    446c:	80 00 6c 44 	mova	#17516,	r0	;0x0446c

00004470 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4470:	80 00 70 44 	mova	#17520,	r0	;0x04470

00004474 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4474:	80 00 74 44 	mova	#17524,	r0	;0x04474

00004478 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    4478:	80 00 78 44 	mova	#17528,	r0	;0x04478

0000447c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    447c:	80 00 7c 44 	mova	#17532,	r0	;0x0447c

00004480 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4480:	80 00 80 44 	mova	#17536,	r0	;0x04480

00004484 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4484:	80 00 84 44 	mova	#17540,	r0	;0x04484

00004488 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    4488:	80 00 88 44 	mova	#17544,	r0	;0x04488

0000448c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    448c:	80 00 8c 44 	mova	#17548,	r0	;0x0448c

00004490 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4490:	80 00 90 44 	mova	#17552,	r0	;0x04490

00004494 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4494:	80 00 94 44 	mova	#17556,	r0	;0x04494

00004498 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    4498:	80 00 98 44 	mova	#17560,	r0	;0x04498

0000449c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    449c:	80 00 9c 44 	mova	#17564,	r0	;0x0449c

000044a0 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    44a0:	80 00 a0 44 	mova	#17568,	r0	;0x044a0

000044a4 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    44a4:	80 00 a4 44 	mova	#17572,	r0	;0x044a4

000044a8 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    44a8:	80 00 a8 44 	mova	#17576,	r0	;0x044a8

000044ac <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    44ac:	80 00 ac 44 	mova	#17580,	r0	;0x044ac

000044b0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    44b0:	80 00 b0 44 	mova	#17584,	r0	;0x044b0

000044b4 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    44b4:	80 00 b4 44 	mova	#17588,	r0	;0x044b4

000044b8 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    44b8:	80 00 b8 44 	mova	#17592,	r0	;0x044b8

000044bc <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    44bc:	80 00 bc 44 	mova	#17596,	r0	;0x044bc

000044c0 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    44c0:	80 00 c0 44 	mova	#17600,	r0	;0x044c0

000044c4 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    44c4:	80 00 c4 44 	mova	#17604,	r0	;0x044c4

000044c8 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    44c8:	80 00 c8 44 	mova	#17608,	r0	;0x044c8

000044cc <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    44cc:	80 00 cc 44 	mova	#17612,	r0	;0x044cc

000044d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44d0:	80 00 d0 44 	mova	#17616,	r0	;0x044d0

000044d4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44d4:	80 00 d4 44 	mova	#17620,	r0	;0x044d4

000044d8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44d8:	80 00 d8 44 	mova	#17624,	r0	;0x044d8

000044dc <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44dc:	80 00 dc 44 	mova	#17628,	r0	;0x044dc

000044e0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44e0:	80 00 e0 44 	mova	#17632,	r0	;0x044e0

000044e4 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44e4:	80 00 e4 44 	mova	#17636,	r0	;0x044e4

000044e8 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44e8:	80 00 e8 44 	mova	#17640,	r0	;0x044e8

000044ec <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44ec:	80 00 ec 44 	mova	#17644,	r0	;0x044ec

000044f0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44f0:	80 00 f0 44 	mova	#17648,	r0	;0x044f0

000044f4 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44f4:	80 00 f4 44 	mova	#17652,	r0	;0x044f4

000044f8 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    44f8:	80 00 f8 44 	mova	#17656,	r0	;0x044f8

000044fc <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44fc:	80 00 fc 44 	mova	#17660,	r0	;0x044fc

00004500 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    4500:	80 00 00 45 	mova	#17664,	r0	;0x04500

00004504 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    4504:	80 00 04 45 	mova	#17668,	r0	;0x04504

00004508 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    4508:	80 00 08 45 	mova	#17672,	r0	;0x04508

0000450c <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    450c:	80 00 0c 45 	mova	#17676,	r0	;0x0450c

00004510 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    4510:	80 00 10 45 	mova	#17680,	r0	;0x04510

00004514 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    4514:	80 00 14 45 	mova	#17684,	r0	;0x04514

00004518 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    4518:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    451c:	48 15 

0000451e <.Loc.305.1>:
}
    451e:	10 01       	reta			;

00004520 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    4520:	03 43       	nop			

00004522 <.Loc.356.1>:
  _enable_interrupts();
    4522:	03 43       	nop			
    4524:	32 d2       	eint			
    4526:	03 43       	nop			

00004528 <.Loc.357.1>:
}
    4528:	10 01       	reta			;

0000452a <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    452a:	32 c2       	dint			
    452c:	03 43       	nop			

0000452e <.Loc.390.1>:
  asm volatile("nop");
    452e:	03 43       	nop			

00004530 <.Loc.391.1>:
}
    4530:	10 01       	reta			;

00004532 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    4532:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004536 <.LCFI0>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    4536:	80 18 f1 40 	movx.a	#70904,	16(r1)	;0x114f8, 0x00010
    453a:	f8 14 10 00 

0000453e <.Loc.234.2>:
  tcp = nil_thd_configs;
    453e:	80 18 f1 40 	movx.a	#68046,	12(r1)	;0x109ce, 0x0000c
    4542:	ce 09 0c 00 

00004546 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4546:	80 00 04 46 	mova	#17924,	r0	;0x04604

0000454a <.L6>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    454a:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    454e:	3c 0c 04 00 	mova	4(r12),	r12	;
    4552:	cd 0c       	mova	r12,	r13	;
    4554:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    4558:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    455c:	7c 0d 00 00 	mova	r13,	0(r12)	;
    4560:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4564:	0c 0c       	mova	@r12,	r12	;
    4566:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    456a:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    456e:	71 0d 08 00 	mova	r13,	8(r1)	;
    4572:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    4576:	00 00 
    4578:	3e 01 08 00 	mova	8(r1),	r14	;
    457c:	0e 14       	pushm.a	#1,	r14	;20-bit words
    457e:	0d 17       	popm	#1,	r13	;16-bit words
    4580:	0d 17       	popm	#1,	r13	;16-bit words
    4582:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4586:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    458a:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    458e:	4d de       	bis.b	r14,	r13	;
    4590:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    4594:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4598:	0c 0c       	mova	@r12,	r12	;
    459a:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    459e:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    45a2:	71 0d 04 00 	mova	r13,	4(r1)	;
    45a6:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    45aa:	04 00 
    45ac:	3e 01 04 00 	mova	4(r1),	r14	;
    45b0:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45b2:	0d 17       	popm	#1,	r13	;16-bit words
    45b4:	0d 17       	popm	#1,	r13	;16-bit words
    45b6:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45ba:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    45be:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45c2:	4d de       	bis.b	r14,	r13	;
    45c4:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    45c8:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    45cc:	0c 0c       	mova	@r12,	r12	;
    45ce:	00 18 f1 40 	movx.a	#19822,	0(r1)	;0x04d6e
    45d2:	6e 4d 00 00 
    45d6:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    45da:	0e 01       	mova	@r1,	r14	;
    45dc:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45de:	0d 17       	popm	#1,	r13	;16-bit words
    45e0:	0d 17       	popm	#1,	r13	;16-bit words
    45e2:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45e6:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    45ea:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45ee:	4d de       	bis.b	r14,	r13	;
    45f0:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

000045f4 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    45f4:	00 18 f1 50 	addx.a	#16,	16(r1)	;0x00010, 0x00010
    45f8:	10 00 10 00 

000045fc <.Loc.247.2>:
    tcp++;
    45fc:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    4600:	14 00 0c 00 

00004604 <.L5>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4604:	80 18 f1 90 	cmpx.a	#70968,	16(r1)	;0x11538, 0x00010
    4608:	38 15 10 00 
    460c:	9e 2b       	jnc	$-194    	;abs 0x454a

0000460e <.Loc.258.2>:
  tp->wabase  = THD_IDLE_BASE;
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    460e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004612 <.LVL4>:
  _heap_init();
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    4612:	b0 13 18 45 	calla	#17688		;0x04518

00004616 <.LVL5>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4616:	81 18 f2 40 	movx.a	#70904,	&0x114ee;0x114f8
    461a:	f8 14 ee 14 
    461e:	2c 01 ee 14 	mova	&70894,	r12	;0x114ee
    4622:	61 0c ea 14 	mova	r12,	&70890	; 0x114ea

00004626 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4626:	2c 01 ea 14 	mova	&70890,	r12	;0x114ea
    462a:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    462e:	b0 13 62 4d 	calla	#19810		;0x04d62

00004632 <.LVL6>:
  chSysUnlock();
    4632:	b0 13 20 45 	calla	#17696		;0x04520

00004636 <.LVL7>:
}
    4636:	03 43       	nop			
    4638:	a1 00 14 00 	adda	#20,	r1	;0x00014
    463c:	10 01       	reta			;

0000463e <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    463e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004640 <.LCFI1>:
    4640:	ca 0c       	mova	r12,	r10	;

00004642 <.Loc.293.2>:

  port_disable();
    4642:	b0 13 2a 45 	calla	#17706		;0x0452a

00004646 <.LVL9>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4646:	61 0a f4 14 	mova	r10,	&70900	; 0x114f4

0000464a <.L8>:
    464a:	80 00 4a 46 	mova	#17994,	r0	;0x0464a

0000464e <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    464e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004650 <.LCFI2>:
    4650:	08 14       	pushm.a	#1,	r8	;20-bit words

00004652 <.LCFI3>:
    4652:	06 14       	pushm.a	#1,	r6	;20-bit words

00004654 <.LCFI4>:

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    4654:	88 01 ea 14 	mova	#70890,	r8	;0x114ea
    4658:	98 53 08 00 	inc	8(r8)		;
    465c:	a8 00 14 00 	adda	#20,	r8	;0x00014

00004660 <.Loc.341.2>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4660:	8a 00 0e 47 	mova	#18190,	r10	;0x0470e
    4664:	86 0f ff ff 	mova	#-1,	r6	;0xffffffff

00004668 <.L17>:
    4668:	cc 08       	mova	r8,	r12	;
    466a:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

0000466e <.LVL12>:
    if (tp->timeout > (systime_t)0) {
    466e:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    4672:	0d 93       	cmp	#0,	r13	;r3 As==00
    4674:	1e 24       	jz	$+62     	;abs 0x46b2

00004676 <.Loc.327.2>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    4676:	5d 48 fe ff 	mov.b	-2(r8),	r13	;
    467a:	0d 93       	cmp	#0,	r13	;r3 As==00
    467c:	0b 20       	jnz	$+24     	;abs 0x4694

0000467e <.LBB72>:
  port_disable();
    467e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004682 <.LVL14>:
  nil.dbg_panic_msg = reason;
    4682:	81 18 f2 40 	movx.a	#65536,	&0x114f4;0x10000
    4686:	00 00 f4 14 

0000468a <.L13>:
    468a:	80 00 8a 46 	mova	#18058,	r0	;0x0468a

0000468e <.L18>:
    468e:	c8 0c       	mova	r12,	r8	;

00004690 <.LVL16>:
    4690:	80 00 68 46 	mova	#18024,	r0	;0x04668

00004694 <.L12>:
      if (--tp->timeout == (systime_t)0) {
    4694:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    4698:	3e 53       	add	#-1,	r14	;r3 As==11
    469a:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a
    469e:	0e 93       	cmp	#0,	r14	;r3 As==00
    46a0:	08 20       	jnz	$+18     	;abs 0x46b2

000046a2 <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    46a2:	7d 90 03 00 	cmp.b	#3,	r13	;
    46a6:	11 20       	jnz	$+36     	;abs 0x46ca

000046a8 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    46a8:	0e 08       	mova	@r8,	r14	;
    46aa:	9e 53 00 00 	inc	0(r14)		;

000046ae <.L16>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    46ae:	cd 06       	mova	r6,	r13	;
    46b0:	4a 13       	calla	r10		;

000046b2 <.L11>:
    46b2:	cc 08       	mova	r8,	r12	;
    46b4:	ac 00 10 00 	adda	#16,	r12	;0x00010

000046b8 <.Loc.349.2>:
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    tp++;
    chSysLockFromISR();
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    46b8:	a8 00 0a 00 	adda	#10,	r8	;0x0000a

000046bc <.LVL19>:
    46bc:	98 01 38 15 	cmpa	#70968,	r8	;0x11538
    46c0:	e6 2b       	jnc	$-50     	;abs 0x468e

000046c2 <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    46c2:	06 16       	popm.a	#1,	r6	;20-bit words
    46c4:	08 16       	popm.a	#1,	r8	;20-bit words
    46c6:	0a 16       	popm.a	#1,	r10	;20-bit words
    46c8:	10 01       	reta			;

000046ca <.L15>:
        else if (NIL_THD_IS_SUSP(tp)) {
    46ca:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    46cc:	f0 23       	jnz	$-30     	;abs 0x46ae

000046ce <.Loc.338.2>:
          *tp->u1.trp = NULL;
    46ce:	0e 08       	mova	@r8,	r14	;
    46d0:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    46d4:	00 00 
    46d6:	80 00 ae 46 	mova	#18094,	r0	;0x046ae

000046da <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    46da:	0a 14       	pushm.a	#1,	r10	;20-bit words

000046dc <.LBB78>:
  return __get_SR_register();
    46dc:	0a 42       	mov	r2,	r10	;

000046de <.LBE78>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    46de:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    46e2:	06 24       	jz	$+14     	;abs 0x46f0

000046e4 <.Loc.450.2>:
    if (port_is_isr_context()) {
    46e4:	41 18 c2 93 	cmpx.b	#0,	&0x11548;r3 As==00
    46e8:	48 15 
    46ea:	02 20       	jnz	$+6      	;abs 0x46f0

000046ec <.Loc.454.2>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    46ec:	b0 13 2a 45 	calla	#17706		;0x0452a

000046f0 <.L27>:
    }
  }
  return sts;
}
    46f0:	0c 4a       	mov	r10,	r12	;
    46f2:	0a 16       	popm.a	#1,	r10	;20-bit words
    46f4:	10 01       	reta			;

000046f6 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    46f6:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    46fa:	08 24       	jz	$+18     	;abs 0x470c

000046fc <.Loc.472.2>:
    if (port_is_isr_context()) {
    46fc:	41 18 c2 93 	cmpx.b	#0,	&0x11548;r3 As==00
    4700:	48 15 
    4702:	04 20       	jnz	$+10     	;abs 0x470c

00004704 <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    4704:	b0 13 c4 47 	calla	#18372		;0x047c4

00004708 <.LVL25>:
      chSysUnlock();
    4708:	b0 13 20 45 	calla	#17696		;0x04520

0000470c <.L31>:
    }
  }
}
    470c:	10 01       	reta			;

0000470e <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    470e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004710 <.LCFI6>:
    4710:	b1 00 04 00 	suba	#4,	r1	;

00004714 <.LCFI7>:
    4714:	71 0d 00 00 	mova	r13,	0(r1)	;

00004718 <.Loc.537.2>:

  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    4718:	9c 01 f8 14 	cmpa	#70904,	r12	;0x114f8
    471c:	03 28       	jnc	$+8      	;abs 0x4724

0000471e <.Loc.537.2>:
    471e:	9c 01 38 15 	cmpa	#70968,	r12	;0x11538
    4722:	08 28       	jnc	$+18     	;abs 0x4734

00004724 <.L37>:
  port_disable();
    4724:	b0 13 2a 45 	calla	#17706		;0x0452a

00004728 <.LVL29>:
  nil.dbg_panic_msg = reason;
    4728:	81 18 f2 40 	movx.a	#65555,	&0x114f4;0x10013
    472c:	13 00 f4 14 

00004730 <.L39>:
    4730:	80 00 30 47 	mova	#18224,	r0	;0x04730

00004734 <.L38>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    4734:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4738:	08 20       	jnz	$+18     	;abs 0x474a

0000473a <.LBB82>:
  port_disable();
    473a:	b0 13 2a 45 	calla	#17706		;0x0452a

0000473e <.LVL32>:
  nil.dbg_panic_msg = reason;
    473e:	81 18 f2 40 	movx.a	#65555,	&0x114f4;0x10013
    4742:	13 00 f4 14 

00004746 <.L41>:
    4746:	80 00 46 47 	mova	#18246,	r0	;0x04746

0000474a <.L40>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    474a:	8e 01 ea 14 	mova	#70890,	r14	;0x114ea
    474e:	3a 0e 04 00 	mova	4(r14),	r10	;
    4752:	01 18 c2 9a 	cmpx.a	r10,	&0x114ea;
    4756:	ea 14 
    4758:	08 2c       	jc	$+18     	;abs 0x476a

0000475a <.LBB84>:
  port_disable();
    475a:	b0 13 2a 45 	calla	#17706		;0x0452a

0000475e <.LVL35>:
  nil.dbg_panic_msg = reason;
    475e:	81 18 f2 40 	movx.a	#65555,	&0x114f4;0x10013
    4762:	13 00 f4 14 

00004766 <.L43>:
    4766:	80 00 66 47 	mova	#18278,	r0	;0x04766

0000476a <.L42>:

  tp->u1.msg = msg;
    476a:	ac 41 06 00 	mov	@r1,	6(r12)	;
    476e:	0f 01       	mova	@r1,	r15	;
    4770:	0f 14       	pushm.a	#1,	r15	;20-bit words
    4772:	0d 17       	popm	#1,	r13	;16-bit words
    4774:	0d 17       	popm	#1,	r13	;16-bit words

00004776 <.LVL37>:
    4776:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    477a:	5f 4c 08 00 	mov.b	8(r12),	r15	;
    477e:	7f f0 f0 ff 	and.b	#-16,	r15	;#0xfff0
    4782:	4f dd       	bis.b	r13,	r15	;
    4784:	cc 4f 08 00 	mov.b	r15,	8(r12)	;

00004788 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    4788:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

0000478c <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    478c:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00004790 <.Loc.544.2>:
  if (tp < nil.next) {
    4790:	dc 0a       	cmpa	r10,	r12	;
    4792:	02 2c       	jc	$+6      	;abs 0x4798

00004794 <.Loc.545.2>:
    nil.next = tp;
    4794:	7e 0c 04 00 	mova	r12,	4(r14)	;

00004798 <.L44>:
  }
  return tp;
}
    4798:	a1 00 04 00 	adda	#4,	r1	;

0000479c <.LVL38>:
    479c:	0a 16       	popm.a	#1,	r10	;20-bit words
    479e:	10 01       	reta			;

000047a0 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    47a0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    47a2:	81 18 d2 92 	cmpx.a	&0x114ee,&0x114ea;
    47a6:	ee 14 ea 14 
    47aa:	01 20       	jnz	$+4      	;abs 0x47ae
    47ac:	4c 43       	clr.b	r12		;

000047ae <.L46>:
}
    47ae:	10 01       	reta			;

000047b0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    47b0:	8e 01 ea 14 	mova	#70890,	r14	;0x114ea
    47b4:	0d 0e       	mova	@r14,	r13	;

000047b6 <.LVL39>:

  nil.current = nil.next;
    47b6:	3c 0e 04 00 	mova	4(r14),	r12	;
    47ba:	7e 0c 00 00 	mova	r12,	0(r14)	;

000047be <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    47be:	b0 13 62 4d 	calla	#19810		;0x04d62

000047c2 <.LVL40>:
}
    47c2:	10 01       	reta			;

000047c4 <chSchRescheduleS>:
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    47c4:	81 18 d2 92 	cmpx.a	&0x114ee,&0x114ea;
    47c8:	ee 14 ea 14 
    47cc:	02 24       	jz	$+6      	;abs 0x47d2

000047ce <.Loc.595.2>:
    chSchDoReschedule();
    47ce:	b0 13 b0 47 	calla	#18352		;0x047b0

000047d2 <.L48>:
  }
}
    47d2:	10 01       	reta			;

000047d4 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    47d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047d6 <.LCFI8>:
    47d6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000047da <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    47da:	8a 01 ea 14 	mova	#70890,	r10	;0x114ea
    47de:	0e 0a       	mova	@r10,	r14	;

000047e0 <.LVL43>:

  chDbgCheckClassS();

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    47e0:	9e 01 38 15 	cmpa	#70968,	r14	;0x11538
    47e4:	08 20       	jnz	$+18     	;abs 0x47f6

000047e6 <.LBB86>:
  port_disable();
    47e6:	b0 13 2a 45 	calla	#17706		;0x0452a

000047ea <.LVL45>:
  nil.dbg_panic_msg = reason;
    47ea:	81 18 f2 40 	movx.a	#65567,	&0x114f4;0x1001f
    47ee:	1f 00 f4 14 

000047f2 <.L52>:
    47f2:	80 00 f2 47 	mova	#18418,	r0	;0x047f2

000047f6 <.L51>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    47f6:	ce 4c 04 00 	mov.b	r12,	4(r14)	;

000047fa <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    47fa:	8e 4d 0a 00 	mov	r13,	10(r14)	; 0x000a

000047fe <.LVL47>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    47fe:	cc 0a       	mova	r10,	r12	;
    4800:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00004804 <.L54>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    4804:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4808:	0c 20       	jnz	$+26     	;abs 0x4822

0000480a <.Loc.668.2>:
      nil.current = nil.next = ntp;
    480a:	7a 0c 04 00 	mova	r12,	4(r10)	;
    480e:	7a 0c 00 00 	mova	r12,	0(r10)	;

00004812 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    4812:	cd 0e       	mova	r14,	r13	;
    4814:	b0 13 62 4d 	calla	#19810		;0x04d62

00004818 <.LVL49>:
      return nil.current->u1.msg;
    4818:	0c 0a       	mova	@r10,	r12	;
    481a:	3c 0c 06 00 	mova	6(r12),	r12	;

0000481e <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    481e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4820:	10 01       	reta			;

00004822 <.L53>:
    ntp++;
    4822:	ac 00 10 00 	adda	#16,	r12	;0x00010

00004826 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    4826:	8d 01 38 15 	mova	#70968,	r13	;0x11538
    482a:	dd 0c       	cmpa	r12,	r13	;
    482c:	eb 2f       	jc	$-40     	;abs 0x4804

0000482e <.LBB88>:
  port_disable();
    482e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004832 <.LVL53>:
  nil.dbg_panic_msg = reason;
    4832:	81 18 f2 40 	movx.a	#65567,	&0x114f4;0x1001f
    4836:	1f 00 f4 14 

0000483a <.L55>:
    483a:	80 00 3a 48 	mova	#18490,	r0	;0x0483a

0000483e <chThdSuspendTimeoutS>:
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {

  chDbgAssert(*trp == NULL, "not NULL");
    483e:	00 18 cc 93 	cmpx.a	#0,	0(r12)	;r3 As==00
    4842:	00 00 
    4844:	08 24       	jz	$+18     	;abs 0x4856

00004846 <.LBB90>:
  port_disable();
    4846:	b0 13 2a 45 	calla	#17706		;0x0452a

0000484a <.LVL56>:
  nil.dbg_panic_msg = reason;
    484a:	81 18 f2 40 	movx.a	#65588,	&0x114f4;0x10034
    484e:	34 00 f4 14 

00004852 <.L60>:
    4852:	80 00 52 48 	mova	#18514,	r0	;0x04852

00004856 <.L59>:

  *trp = nil.current;
    4856:	8e 01 ea 14 	mova	#70890,	r14	;0x114ea
    485a:	00 18 ec 4e 	movx.a	@r14,	0(r12)	;
    485e:	00 00 

00004860 <.Loc.702.2>:
  nil.current->u1.trp = trp;
    4860:	0e 0e       	mova	@r14,	r14	;
    4862:	7e 0c 06 00 	mova	r12,	6(r14)	;

00004866 <.Loc.703.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    4866:	6c 43       	mov.b	#2,	r12	;r3 As==10

00004868 <.LVL58>:
    4868:	b0 13 d4 47 	calla	#18388		;0x047d4

0000486c <.LVL59>:
}
    486c:	10 01       	reta			;

0000486e <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    486e:	ce 0c       	mova	r12,	r14	;

00004870 <.Loc.718.2>:

  if (*trp != NULL) {
    4870:	0c 0c       	mova	@r12,	r12	;

00004872 <.LVL61>:
    4872:	9c 00 00 00 	cmpa	#0,	r12	;
    4876:	10 24       	jz	$+34     	;abs 0x4898

00004878 <.LBB92>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4878:	ec 93 04 00 	cmp.b	#2,	4(r12)	;r3 As==10
    487c:	08 24       	jz	$+18     	;abs 0x488e

0000487e <.LBB93>:
  port_disable();
    487e:	b0 13 2a 45 	calla	#17706		;0x0452a

00004882 <.LVL64>:
  nil.dbg_panic_msg = reason;
    4882:	81 18 f2 40 	movx.a	#65609,	&0x114f4;0x10049
    4886:	49 00 f4 14 

0000488a <.L64>:
    488a:	80 00 8a 48 	mova	#18570,	r0	;0x0488a

0000488e <.L63>:

    *trp = NULL;
    488e:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    4892:	00 00 

00004894 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    4894:	b0 13 0e 47 	calla	#18190		;0x0470e

00004898 <.L61>:
  }
}
    4898:	10 01       	reta			;

0000489a <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    489a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000489c <.LCFI9>:
    489c:	0a 4c       	mov	r12,	r10	;

0000489e <.Loc.737.2>:

  chSysLock();
    489e:	b0 13 2a 45 	calla	#17706		;0x0452a

000048a2 <.LVL68>:
  chThdSleepS(timeout);
    48a2:	0d 4a       	mov	r10,	r13	;
    48a4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    48a6:	b0 13 d4 47 	calla	#18388		;0x047d4

000048aa <.LVL69>:
  chSysUnlock();
    48aa:	b0 13 20 45 	calla	#17696		;0x04520

000048ae <.LVL70>:
}
    48ae:	0a 16       	popm.a	#1,	r10	;20-bit words
    48b0:	10 01       	reta			;

000048b2 <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    48b2:	b1 00 08 00 	suba	#8,	r1	;

000048b6 <.LCFI11>:
  msg_t msg;

  chSysLock();
    48b6:	71 0c 00 00 	mova	r12,	0(r1)	;
    48ba:	71 0d 04 00 	mova	r13,	4(r1)	;
    48be:	b0 13 2a 45 	calla	#17706		;0x0452a

000048c2 <.LVL77>:
  msg = chSemWaitTimeoutS(sp, timeout);
    48c2:	3d 01 04 00 	mova	4(r1),	r13	;
    48c6:	0c 01       	mova	@r1,	r12	;
    48c8:	b0 13 dc 48 	calla	#18652		;0x048dc

000048cc <.LVL78>:
  chSysUnlock();
    48cc:	71 0c 00 00 	mova	r12,	0(r1)	;
    48d0:	b0 13 20 45 	calla	#17696		;0x04520

000048d4 <.LVL79>:

  return msg;
}
    48d4:	0c 01       	mova	@r1,	r12	;
    48d6:	a1 00 08 00 	adda	#8,	r1	;
    48da:	10 01       	reta			;

000048dc <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    48dc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000048de <.LCFI12>:

  chDbgCheckClassS();
  chDbgCheck(sp != NULL);
    48de:	9c 00 00 00 	cmpa	#0,	r12	;
    48e2:	08 20       	jnz	$+18     	;abs 0x48f4

000048e4 <.LBB95>:
  port_disable();
    48e4:	b0 13 2a 45 	calla	#17706		;0x0452a

000048e8 <.LVL82>:
  nil.dbg_panic_msg = reason;
    48e8:	81 18 f2 40 	movx.a	#65622,	&0x114f4;0x10056
    48ec:	56 00 f4 14 

000048f0 <.L73>:
    48f0:	80 00 f0 48 	mova	#18672,	r0	;0x048f0

000048f4 <.L72>:

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    48f4:	2e 4c       	mov	@r12,	r14	;

000048f6 <.LVL84>:
  if (cnt <= (cnt_t)0) {
    48f6:	4a 43       	clr.b	r10		;
    48f8:	0a 9e       	cmp	r14,	r10	;
    48fa:	0f 38       	jl	$+32     	;abs 0x491a

000048fc <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    48fc:	3d 93       	cmp	#-1,	r13	;r3 As==11
    48fe:	13 24       	jz	$+40     	;abs 0x4926

00004900 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    4900:	3e 53       	add	#-1,	r14	;r3 As==11

00004902 <.LVL85>:
    4902:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004906 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    4906:	2e 01 ea 14 	mova	&70890,	r14	;0x114ea

0000490a <.LVL86>:
    490a:	7e 0c 06 00 	mova	r12,	6(r14)	;

0000490e <.LVL87>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    490e:	7c 40 03 00 	mov.b	#3,	r12	;

00004912 <.LVL88>:
    4912:	b0 13 d4 47 	calla	#18388		;0x047d4

00004916 <.L71>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    4916:	0a 16       	popm.a	#1,	r10	;20-bit words
    4918:	10 01       	reta			;

0000491a <.L74>:
  sp->cnt = cnt - (cnt_t)1;
    491a:	3e 53       	add	#-1,	r14	;r3 As==11

0000491c <.LVL91>:
    491c:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004920 <.Loc.823.2>:
  return MSG_OK;
    4920:	4c 43       	clr.b	r12		;

00004922 <.LVL92>:
    4922:	80 00 16 49 	mova	#18710,	r0	;0x04916

00004926 <.L76>:
      return MSG_TIMEOUT;
    4926:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000492a <.LVL94>:
    492a:	80 00 16 49 	mova	#18710,	r0	;0x04916

0000492e <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    492e:	ce 0c       	mova	r12,	r14	;

00004930 <.Loc.855.2>:

  chDbgCheckClassI();
  chDbgCheck(sp != NULL);
    4930:	9c 00 00 00 	cmpa	#0,	r12	;
    4934:	08 20       	jnz	$+18     	;abs 0x4946

00004936 <.LBB109>:
  port_disable();
    4936:	b0 13 2a 45 	calla	#17706		;0x0452a

0000493a <.LVL102>:
  nil.dbg_panic_msg = reason;
    493a:	81 18 f2 40 	movx.a	#65640,	&0x114f4;0x10068
    493e:	68 00 f4 14 

00004942 <.L80>:
    4942:	80 00 42 49 	mova	#18754,	r0	;0x04942

00004946 <.L79>:

  if (++sp->cnt <= (cnt_t)0) {
    4946:	2c 4c       	mov	@r12,	r12	;

00004948 <.LVL104>:
    4948:	1c 53       	inc	r12		;
    494a:	8e 4c 00 00 	mov	r12,	0(r14)	;
    494e:	4d 43       	clr.b	r13		;
    4950:	0d 9c       	cmp	r12,	r13	;
    4952:	15 38       	jl	$+44     	;abs 0x497e
    4954:	8c 01 f8 14 	mova	#70904,	r12	;0x114f8

00004958 <.L85>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    4958:	00 18 5e 9c 	cmpx.a	6(r12),	r14	;
    495c:	06 00 
    495e:	10 20       	jnz	$+34     	;abs 0x4980

00004960 <.Loc.863.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4960:	fc 90 03 00 	cmp.b	#3,	4(r12)	;
    4964:	04 00 
    4966:	08 24       	jz	$+18     	;abs 0x4978

00004968 <.LBB114>:
  port_disable();
    4968:	b0 13 2a 45 	calla	#17706		;0x0452a

0000496c <.LVL107>:
  nil.dbg_panic_msg = reason;
    496c:	81 18 f2 40 	movx.a	#65640,	&0x114f4;0x10068
    4970:	68 00 f4 14 

00004974 <.L84>:
    4974:	80 00 74 49 	mova	#18804,	r0	;0x04974

00004978 <.L83>:

        (void) chSchReadyI(tr, MSG_OK);
    4978:	4d 43       	clr.b	r13		;
    497a:	b0 13 0e 47 	calla	#18190		;0x0470e

0000497e <.L78>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    497e:	10 01       	reta			;

00004980 <.L82>:
      tr++;
    4980:	ac 00 10 00 	adda	#16,	r12	;0x00010

00004984 <.Loc.870.2>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    4984:	9c 01 38 15 	cmpa	#70968,	r12	;0x11538
    4988:	e7 2b       	jnc	$-48     	;abs 0x4958

0000498a <.LBB116>:
  port_disable();
    498a:	b0 13 2a 45 	calla	#17706		;0x0452a

0000498e <.LVL113>:
  nil.dbg_panic_msg = reason;
    498e:	81 18 f2 40 	movx.a	#65640,	&0x114f4;0x10068
    4992:	68 00 f4 14 

00004996 <.L86>:
    4996:	80 00 96 49 	mova	#18838,	r0	;0x04996

0000499a <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    499a:	19 14       	pushm.a	#2,	r9	;20-bit words

0000499c <.LCFI17>:
    499c:	b1 00 04 00 	suba	#4,	r1	;

000049a0 <.LCFI18>:
    49a0:	08 4d       	mov	r13,	r8	;
    49a2:	09 4e       	mov	r14,	r9	;

000049a4 <.Loc.951.2>:

  chSysLock();
    49a4:	71 0c 00 00 	mova	r12,	0(r1)	;
    49a8:	b0 13 2a 45 	calla	#17706		;0x0452a

000049ac <.LVL137>:
  chEvtSignalI(tp, mask);
    49ac:	0d 48       	mov	r8,	r13	;
    49ae:	0e 49       	mov	r9,	r14	;
    49b0:	0c 01       	mova	@r1,	r12	;
    49b2:	b0 13 c6 49 	calla	#18886		;0x049c6

000049b6 <.LVL138>:
  chSchRescheduleS();
    49b6:	b0 13 c4 47 	calla	#18372		;0x047c4

000049ba <.LVL139>:
  chSysUnlock();
    49ba:	b0 13 20 45 	calla	#17696		;0x04520

000049be <.LVL140>:
}
    49be:	a1 00 04 00 	adda	#4,	r1	;
    49c2:	18 16       	popm.a	#2,	r9	;20-bit words
    49c4:	10 01       	reta			;

000049c6 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    49c6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000049c8 <.LCFI19>:
    49c8:	ca 0c       	mova	r12,	r10	;

000049ca <.Loc.972.2>:

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    49ca:	9c 00 00 00 	cmpa	#0,	r12	;
    49ce:	08 20       	jnz	$+18     	;abs 0x49e0

000049d0 <.LBB127>:
  port_disable();
    49d0:	b0 13 2a 45 	calla	#17706		;0x0452a

000049d4 <.LVL143>:
  nil.dbg_panic_msg = reason;
    49d4:	81 18 f2 40 	movx.a	#65665,	&0x114f4;0x10081
    49d8:	81 00 f4 14 

000049dc <.L106>:
    49dc:	80 00 dc 49 	mova	#18908,	r0	;0x049dc

000049e0 <.L105>:

  tp->epmask |= mask;
    49e0:	1d dc 0c 00 	bis	12(r12),r13	;0x0000c

000049e4 <.LVL145>:
    49e4:	1e dc 0e 00 	bis	14(r12),r14	;0x0000e
    49e8:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
    49ec:	8c 4e 0e 00 	mov	r14,	14(r12)	; 0x000e

000049f0 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49f0:	ec 92 04 00 	cmp.b	#4,	4(r12)	;r2 As==10
    49f4:	0a 20       	jnz	$+22     	;abs 0x4a0a

000049f6 <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    49f6:	1d fc 06 00 	and	6(r12),	r13	;
    49fa:	1e fc 08 00 	and	8(r12),	r14	;

000049fe <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49fe:	0d de       	bis	r14,	r13	;
    4a00:	0d 93       	cmp	#0,	r13	;r3 As==00
    4a02:	03 24       	jz	$+8      	;abs 0x4a0a

00004a04 <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    4a04:	4d 43       	clr.b	r13		;
    4a06:	b0 13 0e 47 	calla	#18190		;0x0470e

00004a0a <.L104>:
  }
}
    4a0a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4a0c:	10 01       	reta			;

00004a0e <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    4a0e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004a10 <.LCFI20>:
    4a10:	06 4c       	mov	r12,	r6	;
    4a12:	07 4d       	mov	r13,	r7	;
    4a14:	05 4e       	mov	r14,	r5	;

00004a16 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    4a16:	2a 01 ea 14 	mova	&70890,	r10	;0x114ea

00004a1a <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    4a1a:	b0 13 2a 45 	calla	#17706		;0x0452a

00004a1e <.LVL149>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    4a1e:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    4a22:	08 f6       	and	r6,	r8	;
    4a24:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4a28:	09 f7       	and	r7,	r9	;

00004a2a <.LVL150>:
    4a2a:	0c 48       	mov	r8,	r12	;
    4a2c:	0c d9       	bis	r9,	r12	;
    4a2e:	84 00 20 45 	mova	#17696,	r4	;0x04520
    4a32:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a34:	18 20       	jnz	$+50     	;abs 0x4a66

00004a36 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4a36:	35 93       	cmp	#-1,	r5	;r3 As==11
    4a38:	05 20       	jnz	$+12     	;abs 0x4a44

00004a3a <.L117>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    4a3a:	44 13       	calla	r4		;

00004a3c <.LVL152>:

  return m;
}
    4a3c:	0c 48       	mov	r8,	r12	;
    4a3e:	0d 49       	mov	r9,	r13	;
    4a40:	64 16       	popm.a	#7,	r10	;20-bit words
    4a42:	10 01       	reta			;

00004a44 <.L114>:
    ctp->u1.ewmask = mask;
    4a44:	8a 46 06 00 	mov	r6,	6(r10)	;
    4a48:	8a 47 08 00 	mov	r7,	8(r10)	;

00004a4c <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4a4c:	0d 45       	mov	r5,	r13	;
    4a4e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4a50:	b0 13 d4 47 	calla	#18388		;0x047d4

00004a54 <.LVL154>:
    4a54:	9c 00 00 00 	cmpa	#0,	r12	;
    4a58:	f0 3b       	jl	$-30     	;abs 0x4a3a

00004a5a <.Loc.1016.2>:
    m = ctp->epmask & mask;
    4a5a:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

00004a5e <.LVL155>:
    4a5e:	08 f6       	and	r6,	r8	;
    4a60:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4a64:	09 f7       	and	r7,	r9	;

00004a66 <.L113>:
  ctp->epmask &= ~m;
    4a66:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    4a6a:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e
    4a6e:	80 00 3a 4a 	mova	#19002,	r0	;0x04a3a

00004a72 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4a72:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a74 <.LCFI4>:
    4a74:	08 14       	pushm.a	#1,	r8	;20-bit words

00004a76 <.LCFI5>:
    4a76:	06 14       	pushm.a	#1,	r6	;20-bit words

00004a78 <.LCFI6>:
    4a78:	ca 0c       	mova	r12,	r10	;
    4a7a:	c6 0d       	mova	r13,	r6	;
    4a7c:	08 4e       	mov	r14,	r8	;

00004a7e <.Loc.188.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);
    4a7e:	9c 00 00 00 	cmpa	#0,	r12	;
    4a82:	04 20       	jnz	$+10     	;abs 0x4a8c

00004a84 <.Loc.188.1>:
    4a84:	8c 01 cc 00 	mova	#65740,	r12	;0x100cc

00004a88 <.LVL13>:
    4a88:	b0 13 3e 46 	calla	#17982		;0x0463e

00004a8c <.L13>:

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4a8c:	0d 48       	mov	r8,	r13	;
    4a8e:	cc 0a       	mova	r10,	r12	;
    4a90:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4a94:	b0 13 dc 48 	calla	#18652		;0x048dc

00004a98 <.LVL15>:
    4a98:	c8 0c       	mova	r12,	r8	;

00004a9a <.LVL16>:
  if (rdymsg == MSG_OK) {
    4a9a:	9c 00 00 00 	cmpa	#0,	r12	;
    4a9e:	17 20       	jnz	$+48     	;abs 0x4ace

00004aa0 <.LBB12>:
    *mbp->wrptr++ = msg;
    4aa0:	3e 0a 08 00 	mova	8(r10),	r14	;
    4aa4:	cc 0e       	mova	r14,	r12	;
    4aa6:	ac 00 04 00 	adda	#4,	r12	;
    4aaa:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4aae:	7e 06 00 00 	mova	r6,	0(r14)	;

00004ab2 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4ab2:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4ab6:	04 00 
    4ab8:	03 28       	jnc	$+8      	;abs 0x4ac0

00004aba <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4aba:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4abe:	08 00 

00004ac0 <.L15>:
    }
    chSemSignalI(&mbp->fullsem);
    4ac0:	cc 0a       	mova	r10,	r12	;
    4ac2:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4ac6:	b0 13 2e 49 	calla	#18734		;0x0492e

00004aca <.LVL18>:
    chSchRescheduleS();
    4aca:	b0 13 c4 47 	calla	#18372		;0x047c4

00004ace <.L12>:
  }

  return rdymsg;
}
    4ace:	cc 08       	mova	r8,	r12	;
    4ad0:	06 16       	popm.a	#1,	r6	;20-bit words
    4ad2:	08 16       	popm.a	#1,	r8	;20-bit words
    4ad4:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ad6:	10 01       	reta			;

00004ad8 <chMBPost>:
  _disable_interrupts();
    4ad8:	32 c2       	dint			
    4ada:	03 43       	nop			

00004adc <.Loc.348.2>:
  asm volatile("nop");
    4adc:	03 43       	nop			

00004ade <.LBE18>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4ade:	b0 13 72 4a 	calla	#19058		;0x04a72

00004ae2 <.LBB20>:
  asm volatile("nop");
    4ae2:	03 43       	nop			

00004ae4 <.Loc.356.2>:
  _enable_interrupts();
    4ae4:	03 43       	nop			
    4ae6:	32 d2       	eint			
    4ae8:	03 43       	nop			

00004aea <.LBE20>:
}
    4aea:	10 01       	reta			;

00004aec <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4aec:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004aee <.LCFI7>:
    4aee:	08 14       	pushm.a	#1,	r8	;20-bit words

00004af0 <.LCFI8>:
    4af0:	ca 0c       	mova	r12,	r10	;
    4af2:	c8 0d       	mova	r13,	r8	;

00004af4 <.Loc.220.1>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);
    4af4:	9c 00 00 00 	cmpa	#0,	r12	;
    4af8:	04 20       	jnz	$+10     	;abs 0x4b02

00004afa <.Loc.220.1>:
    4afa:	8c 01 c2 00 	mova	#65730,	r12	;0x100c2

00004afe <.LVL23>:
    4afe:	b0 13 3e 46 	calla	#17982		;0x0463e

00004b02 <.L18>:

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    4b02:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    4b06:	4d 43       	clr.b	r13		;
    4b08:	0d 9c       	cmp	r12,	r13	;
    4b0a:	1b 34       	jge	$+56     	;abs 0x4b42

00004b0c <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4b0c:	ba 53 12 00 	add	#-1,	18(r10)	;r3 As==11, 0x0012

00004b10 <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4b10:	3e 0a 08 00 	mova	8(r10),	r14	;
    4b14:	cc 0e       	mova	r14,	r12	;
    4b16:	ac 00 04 00 	adda	#4,	r12	;
    4b1a:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4b1e:	7e 08 00 00 	mova	r8,	0(r14)	;

00004b22 <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4b22:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4b26:	04 00 
    4b28:	03 28       	jnc	$+8      	;abs 0x4b30

00004b2a <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4b2a:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4b2e:	08 00 

00004b30 <.L20>:
  }
  chSemSignalI(&mbp->fullsem);
    4b30:	cc 0a       	mova	r10,	r12	;
    4b32:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b36:	b0 13 2e 49 	calla	#18734		;0x0492e

00004b3a <.LVL25>:

  return MSG_OK;
    4b3a:	4c 43       	clr.b	r12		;

00004b3c <.L17>:
}
    4b3c:	08 16       	popm.a	#1,	r8	;20-bit words
    4b3e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b40:	10 01       	reta			;

00004b42 <.L21>:
    return MSG_TIMEOUT;
    4b42:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    4b46:	80 00 3c 4b 	mova	#19260,	r0	;0x04b3c

00004b4a <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4b4a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b4c <.LCFI14>:
    4b4c:	08 14       	pushm.a	#1,	r8	;20-bit words

00004b4e <.LCFI15>:
    4b4e:	06 14       	pushm.a	#1,	r6	;20-bit words

00004b50 <.LCFI16>:
    4b50:	ca 0c       	mova	r12,	r10	;
    4b52:	c8 0d       	mova	r13,	r8	;
    4b54:	06 4e       	mov	r14,	r6	;

00004b56 <.Loc.387.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4b56:	9c 00 00 00 	cmpa	#0,	r12	;
    4b5a:	03 24       	jz	$+8      	;abs 0x4b62

00004b5c <.Loc.387.1>:
    4b5c:	9d 00 00 00 	cmpa	#0,	r13	;
    4b60:	04 20       	jnz	$+10     	;abs 0x4b6a

00004b62 <.L33>:
    4b62:	8c 01 99 00 	mova	#65689,	r12	;0x10099

00004b66 <.LVL41>:
    4b66:	b0 13 3e 46 	calla	#17982		;0x0463e

00004b6a <.L34>:

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4b6a:	0d 46       	mov	r6,	r13	;
    4b6c:	cc 0a       	mova	r10,	r12	;
    4b6e:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b72:	b0 13 dc 48 	calla	#18652		;0x048dc

00004b76 <.LVL43>:
    4b76:	c6 0c       	mova	r12,	r6	;

00004b78 <.LVL44>:
  if (rdymsg == MSG_OK) {
    4b78:	9c 00 00 00 	cmpa	#0,	r12	;
    4b7c:	18 20       	jnz	$+50     	;abs 0x4bae

00004b7e <.LBB36>:
    *msgp = *mbp->rdptr++;
    4b7e:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4b82:	ce 0c       	mova	r12,	r14	;
    4b84:	ae 00 04 00 	adda	#4,	r14	;
    4b88:	7a 0e 0c 00 	mova	r14,	12(r10)	; 0x0000c
    4b8c:	00 18 e8 4c 	movx.a	@r12,	0(r8)	;
    4b90:	00 00 

00004b92 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4b92:	00 18 5e 9a 	cmpx.a	4(r10),	r14	;
    4b96:	04 00 
    4b98:	03 28       	jnc	$+8      	;abs 0x4ba0

00004b9a <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4b9a:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4b9e:	0c 00 

00004ba0 <.L36>:
    }
    chSemSignalI(&mbp->emptysem);
    4ba0:	cc 0a       	mova	r10,	r12	;
    4ba2:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4ba6:	b0 13 2e 49 	calla	#18734		;0x0492e

00004baa <.LVL46>:
    chSchRescheduleS();
    4baa:	b0 13 c4 47 	calla	#18372		;0x047c4

00004bae <.L32>:
  }

  return rdymsg;
}
    4bae:	cc 06       	mova	r6,	r12	;
    4bb0:	06 16       	popm.a	#1,	r6	;20-bit words
    4bb2:	08 16       	popm.a	#1,	r8	;20-bit words
    4bb4:	0a 16       	popm.a	#1,	r10	;20-bit words
    4bb6:	10 01       	reta			;

00004bb8 <chMBFetch>:
  _disable_interrupts();
    4bb8:	32 c2       	dint			
    4bba:	03 43       	nop			

00004bbc <.Loc.348.2>:
  asm volatile("nop");
    4bbc:	03 43       	nop			

00004bbe <.LBE42>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4bbe:	b0 13 4a 4b 	calla	#19274		;0x04b4a

00004bc2 <.LBB44>:
  asm volatile("nop");
    4bc2:	03 43       	nop			

00004bc4 <.Loc.356.2>:
  _enable_interrupts();
    4bc4:	03 43       	nop			
    4bc6:	32 d2       	eint			
    4bc8:	03 43       	nop			

00004bca <.LBE44>:
}
    4bca:	10 01       	reta			;

00004bcc <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    4bcc:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004bce <.LCFI0>:
    4bce:	08 14       	pushm.a	#1,	r8	;20-bit words

00004bd0 <.LCFI1>:
    4bd0:	b1 00 04 00 	suba	#4,	r1	;

00004bd4 <.LCFI2>:
    4bd4:	ca 0c       	mova	r12,	r10	;
    4bd6:	71 0d 00 00 	mova	r13,	0(r1)	;
    4bda:	c8 0e       	mova	r14,	r8	;

00004bdc <.Loc.78.1>:

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    4bdc:	9c 00 00 00 	cmpa	#0,	r12	;
    4be0:	04 24       	jz	$+10     	;abs 0x4bea

00004be2 <.Loc.78.1>:
    4be2:	7c 40 03 00 	mov.b	#3,	r12	;

00004be6 <.LVL1>:
    4be6:	dc 0d       	cmpa	r13,	r12	;
    4be8:	04 28       	jnc	$+10     	;abs 0x4bf2

00004bea <.L2>:
    4bea:	8c 01 30 01 	mova	#65840,	r12	;0x10130
    4bee:	b0 13 3e 46 	calla	#17982		;0x0463e

00004bf2 <.L3>:

  mp->next = NULL;
    4bf2:	00 18 ca 43 	movx.a	#0,	0(r10)	;r3 As==00
    4bf6:	00 00 

00004bf8 <.Loc.81.1>:
  mp->object_size = size;
    4bf8:	aa 41 04 00 	mov	@r1,	4(r10)	;
    4bfc:	0d 01       	mova	@r1,	r13	;
    4bfe:	0d 14       	pushm.a	#1,	r13	;20-bit words
    4c00:	0c 17       	popm	#1,	r12	;16-bit words
    4c02:	0c 17       	popm	#1,	r12	;16-bit words
    4c04:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4c08:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    4c0c:	7d f0 f0 ff 	and.b	#-16,	r13	;#0xfff0
    4c10:	4d dc       	bis.b	r12,	r13	;
    4c12:	ca 4d 06 00 	mov.b	r13,	6(r10)	;

00004c16 <.Loc.82.1>:
  mp->provider = provider;
    4c16:	7a 08 08 00 	mova	r8,	8(r10)	;

00004c1a <.Loc.83.1>:
}
    4c1a:	a1 00 04 00 	adda	#4,	r1	;

00004c1e <.LVL3>:
    4c1e:	08 16       	popm.a	#1,	r8	;20-bit words
    4c20:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c22:	10 01       	reta			;

00004c24 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4c24:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c26 <.LCFI3>:
    4c26:	ca 0c       	mova	r12,	r10	;

00004c28 <.Loc.125.1>:
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);
    4c28:	9c 00 00 00 	cmpa	#0,	r12	;
    4c2c:	04 20       	jnz	$+10     	;abs 0x4c36

00004c2e <.Loc.125.1>:
    4c2e:	8c 01 13 01 	mova	#65811,	r12	;0x10113

00004c32 <.LVL5>:
    4c32:	b0 13 3e 46 	calla	#17982		;0x0463e

00004c36 <.L8>:

  objp = mp->next;
    4c36:	0c 0a       	mova	@r10,	r12	;

00004c38 <.LVL7>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4c38:	9c 00 00 00 	cmpa	#0,	r12	;
    4c3c:	05 24       	jz	$+12     	;abs 0x4c48

00004c3e <.Loc.130.1>:
    mp->next = mp->next->next;
    4c3e:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4c42:	00 00 

00004c44 <.L7>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4c44:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c46:	10 01       	reta			;

00004c48 <.L9>:
  else if (mp->provider != NULL) {
    4c48:	3e 0a 08 00 	mova	8(r10),	r14	;
    4c4c:	9e 00 00 00 	cmpa	#0,	r14	;
    4c50:	f9 27       	jz	$-12     	;abs 0x4c44

00004c52 <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4c52:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4c54:	3c 0a 04 00 	mova	4(r10),	r12	;

00004c58 <.LVL8>:
    4c58:	4e 13       	calla	r14		;

00004c5a <.LVL9>:
  return objp;
    4c5a:	80 00 44 4c 	mova	#19524,	r0	;0x04c44

00004c5e <chPoolAlloc>:
  _disable_interrupts();
    4c5e:	32 c2       	dint			
    4c60:	03 43       	nop			

00004c62 <.Loc.348.2>:
  asm volatile("nop");
    4c62:	03 43       	nop			

00004c64 <.LBE10>:
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
    4c64:	b0 13 24 4c 	calla	#19492		;0x04c24

00004c68 <.LBB12>:
  asm volatile("nop");
    4c68:	03 43       	nop			

00004c6a <.Loc.356.2>:
  _enable_interrupts();
    4c6a:	03 43       	nop			
    4c6c:	32 d2       	eint			
    4c6e:	03 43       	nop			

00004c70 <.LBE12>:
  chSysUnlock();

  return objp;
}
    4c70:	10 01       	reta			;

00004c72 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4c72:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c74 <.LCFI4>:
    4c74:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c76 <.LCFI5>:
    4c76:	ca 0c       	mova	r12,	r10	;
    4c78:	c8 0d       	mova	r13,	r8	;

00004c7a <.LVL13>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
    4c7a:	9c 00 00 00 	cmpa	#0,	r12	;
    4c7e:	03 24       	jz	$+8      	;abs 0x4c86

00004c80 <.Loc.176.1>:
    4c80:	9d 00 00 00 	cmpa	#0,	r13	;
    4c84:	04 20       	jnz	$+10     	;abs 0x4c8e

00004c86 <.L15>:
    4c86:	8c 01 07 01 	mova	#65799,	r12	;0x10107

00004c8a <.LVL14>:
    4c8a:	b0 13 3e 46 	calla	#17982		;0x0463e

00004c8e <.L16>:

  php->next = mp->next;
    4c8e:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4c92:	00 00 

00004c94 <.Loc.179.1>:
  mp->next = php;
    4c94:	7a 08 00 00 	mova	r8,	0(r10)	;

00004c98 <.Loc.180.1>:
}
    4c98:	08 16       	popm.a	#1,	r8	;20-bit words
    4c9a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c9c:	10 01       	reta			;

00004c9e <chPoolFree>:
  _disable_interrupts();
    4c9e:	32 c2       	dint			
    4ca0:	03 43       	nop			

00004ca2 <.Loc.348.2>:
  asm volatile("nop");
    4ca2:	03 43       	nop			

00004ca4 <.LBE18>:
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
    4ca4:	b0 13 72 4c 	calla	#19570		;0x04c72

00004ca8 <.LBB20>:
  asm volatile("nop");
    4ca8:	03 43       	nop			

00004caa <.Loc.356.2>:
  _enable_interrupts();
    4caa:	03 43       	nop			
    4cac:	32 d2       	eint			
    4cae:	03 43       	nop			

00004cb0 <.LBE20>:
  chSysUnlock();
}
    4cb0:	10 01       	reta			;

00004cb2 <chGuardedPoolObjectInit>:
 *                      memory pool, the minimum accepted size is the size
 *                      of a pointer to void.
 *
 * @init
 */
void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp, size_t size) {
    4cb2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cb4 <.LCFI10>:
    4cb4:	ca 0c       	mova	r12,	r10	;

00004cb6 <.Loc.214.1>:

  chPoolObjectInit(&gmp->pool, size, NULL);
    4cb6:	4e 43       	clr.b	r14		;
    4cb8:	ac 00 02 00 	adda	#2,	r12	;

00004cbc <.LVL26>:
    4cbc:	b0 13 cc 4b 	calla	#19404		;0x04bcc

00004cc0 <.LVL27>:
  chSemObjectInit(&gmp->sem, (cnt_t)0);
    4cc0:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00

00004cc4 <.Loc.216.1>:
}
    4cc4:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cc6:	10 01       	reta			;

00004cc8 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
    4cc8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cca <.LCFI11>:
    4cca:	ca 0c       	mova	r12,	r10	;

00004ccc <.Loc.263.1>:
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
    4ccc:	b0 13 dc 48 	calla	#18652		;0x048dc

00004cd0 <.LVL29>:
  if (msg != MSG_OK) {
    4cd0:	9c 00 00 00 	cmpa	#0,	r12	;
    4cd4:	07 20       	jnz	$+16     	;abs 0x4ce4

00004cd6 <.Loc.268.1>:
    return NULL;
  }

  return chPoolAllocI(&gmp->pool);
    4cd6:	cc 0a       	mova	r10,	r12	;

00004cd8 <.LVL30>:
    4cd8:	ac 00 02 00 	adda	#2,	r12	;
    4cdc:	b0 13 24 4c 	calla	#19492		;0x04c24

00004ce0 <.L30>:
}
    4ce0:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ce2:	10 01       	reta			;

00004ce4 <.L32>:
    return NULL;
    4ce4:	4c 43       	clr.b	r12		;

00004ce6 <.LVL33>:
    4ce6:	80 00 e0 4c 	mova	#19680,	r0	;0x04ce0

00004cea <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
    4cea:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cec <.LCFI12>:
    4cec:	ca 0c       	mova	r12,	r10	;

00004cee <.Loc.311.1>:

  chPoolFreeI(&gmp->pool, objp);
    4cee:	ac 00 02 00 	adda	#2,	r12	;

00004cf2 <.LVL37>:
    4cf2:	b0 13 72 4c 	calla	#19570		;0x04c72

00004cf6 <.LVL38>:
  chSemSignalI(&gmp->sem);
    4cf6:	cc 0a       	mova	r10,	r12	;
    4cf8:	b0 13 2e 49 	calla	#18734		;0x0492e

00004cfc <.LVL39>:
}
    4cfc:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cfe:	10 01       	reta			;

00004d00 <chGuardedPoolFree>:
  _disable_interrupts();
    4d00:	32 c2       	dint			
    4d02:	03 43       	nop			

00004d04 <.Loc.348.2>:
  asm volatile("nop");
    4d04:	03 43       	nop			

00004d06 <.LBE38>:
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
    4d06:	b0 13 ea 4c 	calla	#19690		;0x04cea

00004d0a <.LVL41>:
  chSchRescheduleS();
    4d0a:	b0 13 c4 47 	calla	#18372		;0x047c4

00004d0e <.LBB40>:
  asm volatile("nop");
    4d0e:	03 43       	nop			

00004d10 <.Loc.356.2>:
  _enable_interrupts();
    4d10:	03 43       	nop			
    4d12:	32 d2       	eint			
    4d14:	03 43       	nop			

00004d16 <.LBE40>:
  chSysUnlock();
}
    4d16:	10 01       	reta			;

00004d18 <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
    4d18:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d1a <.LCFI13>:
    4d1a:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d1c <.LCFI14>:
    4d1c:	06 14       	pushm.a	#1,	r6	;20-bit words

00004d1e <.LCFI15>:
    4d1e:	04 14       	pushm.a	#1,	r4	;20-bit words

00004d20 <.LCFI16>:
    4d20:	ca 0c       	mova	r12,	r10	;
    4d22:	c4 0d       	mova	r13,	r4	;
    4d24:	c6 0e       	mova	r14,	r6	;

00004d26 <.Loc.233.1>:
  chDbgCheck((gmp != NULL) && (n != 0U));
    4d26:	9c 00 00 00 	cmpa	#0,	r12	;
    4d2a:	03 24       	jz	$+8      	;abs 0x4d32

00004d2c <.Loc.233.1>:
    4d2c:	9e 00 00 00 	cmpa	#0,	r14	;
    4d30:	04 20       	jnz	$+10     	;abs 0x4d3a

00004d32 <.L37>:
    4d32:	8c 01 f0 00 	mova	#65776,	r12	;0x100f0

00004d36 <.LVL44>:
    4d36:	b0 13 3e 46 	calla	#17982		;0x0463e

00004d3a <.L38>:
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
    4d3a:	88 00 00 4d 	mova	#19712,	r8	;0x04d00

00004d3e <.L39>:
  while (n != 0U) {
    4d3e:	96 00 00 00 	cmpa	#0,	r6	;
    4d42:	05 20       	jnz	$+12     	;abs 0x4d4e

00004d44 <.Loc.242.1>:
}
    4d44:	04 16       	popm.a	#1,	r4	;20-bit words
    4d46:	06 16       	popm.a	#1,	r6	;20-bit words
    4d48:	08 16       	popm.a	#1,	r8	;20-bit words
    4d4a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4d4c:	10 01       	reta			;

00004d4e <.L40>:
    4d4e:	cd 04       	mova	r4,	r13	;
    4d50:	cc 0a       	mova	r10,	r12	;
    4d52:	48 13       	calla	r8		;

00004d54 <.LBE45>:
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
    4d54:	00 18 54 5a 	addx.a	6(r10),	r4	;
    4d58:	06 00 

00004d5a <.Loc.240.1>:
    n--;
    4d5a:	a6 0f ff ff 	adda	#1048575,r6	;0xfffff
    4d5e:	80 00 3e 4d 	mova	#19774,	r0	;0x04d3e

00004d62 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4d62:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004d64 <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4d64:	7d 01 00 00 	mova	r1,	0(r13)	;

00004d68 <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4d68:	01 0c       	mova	@r12,	r1	;

00004d6a <.Loc.76.1>:
  asm volatile ("popm.a #7, R10");
    4d6a:	64 16       	popm.a	#7,	r10	;20-bit words

00004d6c <.Loc.77.1>:
  asm volatile ("reta");
    4d6c:	10 01       	reta			;

00004d6e <_port_thread_start>:
  asm volatile("nop");
    4d6e:	03 43       	nop			

00004d70 <.Loc.356.2>:
  _enable_interrupts();
    4d70:	03 43       	nop			
    4d72:	32 d2       	eint			
    4d74:	03 43       	nop			

00004d76 <.LBE4>:
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4d76:	cc 05       	mova	r5,	r12	;

00004d78 <.Loc.98.1>:
  asm volatile ("calla R4");
    4d78:	44 13       	calla	r4		;

00004d7a <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4d7a:	4c 43       	clr.b	r12		;
    4d7c:	b0 13 3e 46 	calla	#17982		;0x0463e

00004d80 <.LVL1>:
#endif
}
    4d80:	10 01       	reta			;

00004d82 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4d82:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004d84 <.LCFI0>:
    4d84:	06 14       	pushm.a	#1,	r6	;20-bit words

00004d86 <.LCFI1>:
    4d86:	04 14       	pushm.a	#1,	r4	;20-bit words

00004d88 <.LCFI2>:
    4d88:	c6 0c       	mova	r12,	r6	;
    4d8a:	c4 0d       	mova	r13,	r4	;

00004d8c <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4d8c:	2c 4c       	mov	@r12,	r12	;

00004d8e <.LVL2>:
    4d8e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4d90:	18 34       	jge	$+50     	;abs 0x4dc2
    4d92:	8a 01 f8 14 	mova	#70904,	r10	;0x114f8

00004d96 <.LBB2>:
        (void) chSchReadyI(tp, msg);
        return;
      }
      tp++;

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4d96:	88 00 3e 46 	mova	#17982,	r8	;0x0463e
    4d9a:	89 01 57 01 	mova	#65879,	r9	;0x10157

00004d9e <.L3>:
      if (tp->u1.semp == sp) {
    4d9e:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    4da2:	06 00 
    4da4:	12 20       	jnz	$+38     	;abs 0x4dca

00004da6 <.Loc.67.1>:
        sp->cnt++;
    4da6:	96 53 00 00 	inc	0(r6)		;

00004daa <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4daa:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    4dae:	04 00 
    4db0:	04 24       	jz	$+10     	;abs 0x4dba

00004db2 <.Loc.69.1>:
    4db2:	8c 01 57 01 	mova	#65879,	r12	;0x10157
    4db6:	b0 13 3e 46 	calla	#17982		;0x0463e

00004dba <.L5>:
        (void) chSchReadyI(tp, msg);
    4dba:	cd 04       	mova	r4,	r13	;
    4dbc:	cc 0a       	mova	r10,	r12	;
    4dbe:	b0 13 0e 47 	calla	#18190		;0x0470e

00004dc2 <.L1>:
                  "pointer out of range");
    }
  }
}
    4dc2:	04 16       	popm.a	#1,	r4	;20-bit words
    4dc4:	06 16       	popm.a	#1,	r6	;20-bit words
    4dc6:	28 16       	popm.a	#3,	r10	;20-bit words
    4dc8:	10 01       	reta			;

00004dca <.L4>:
      tp++;
    4dca:	aa 00 10 00 	adda	#16,	r10	;0x00010

00004dce <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4dce:	9a 01 38 15 	cmpa	#70968,	r10	;0x11538
    4dd2:	e5 2b       	jnc	$-52     	;abs 0x4d9e

00004dd4 <.Loc.76.1>:
    4dd4:	cc 09       	mova	r9,	r12	;
    4dd6:	48 13       	calla	r8		;

00004dd8 <.LVL8>:
    4dd8:	80 00 9e 4d 	mova	#19870,	r0	;0x04d9e

00004ddc <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4ddc:	b0 13 92 51 	calla	#20882		;0x05192

00004de0 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4de0:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4de4:	b0 13 02 52 	calla	#20994		;0x05202

00004de8 <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4de8:	b0 13 1a 4e 	calla	#19994		;0x04e1a

00004dec <.LVL2>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    4dec:	b0 13 f0 4e 	calla	#20208		;0x04ef0

00004df0 <.LVL3>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4df0:	b0 13 6c 4f 	calla	#20332		;0x04f6c

00004df4 <.LVL4>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    4df4:	b0 13 34 50 	calla	#20532		;0x05034

00004df8 <.LVL5>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4df8:	b0 13 c0 65 	calla	#26048		;0x065c0

00004dfc <.LVL6>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4dfc:	b0 13 02 4e 	calla	#19970		;0x04e02

00004e00 <.LVL7>:
#endif
}
    4e00:	10 01       	reta			;

00004e02 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4e02:	b0 13 e2 51 	calla	#20962		;0x051e2

00004e06 <.LVL0>:
}
    4e06:	10 01       	reta			;

00004e08 <port_lock>:
  _disable_interrupts();
    4e08:	32 c2       	dint			
    4e0a:	03 43       	nop			

00004e0c <.Loc.348.1>:
  asm volatile("nop");
    4e0c:	03 43       	nop			

00004e0e <.Loc.349.1>:
}
    4e0e:	10 01       	reta			;

00004e10 <port_unlock>:
  asm volatile("nop");
    4e10:	03 43       	nop			

00004e12 <.Loc.356.1>:
  _enable_interrupts();
    4e12:	03 43       	nop			
    4e14:	32 d2       	eint			
    4e16:	03 43       	nop			

00004e18 <.Loc.357.1>:
}
    4e18:	10 01       	reta			;

00004e1a <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    4e1a:	b0 13 b8 64 	calla	#25784		;0x064b8

00004e1e <.LVL0>:
}
    4e1e:	10 01       	reta			;

00004e20 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    4e20:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004e24 <.Loc.71.2>:
  gptp->config = NULL;
    4e24:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4e28:	02 00 

00004e2a <.Loc.72.2>:
}
    4e2a:	10 01       	reta			;

00004e2c <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    4e2c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e2e <.LCFI0>:
    4e2e:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e30 <.LCFI1>:
    4e30:	ca 0c       	mova	r12,	r10	;
    4e32:	c8 0d       	mova	r13,	r8	;

00004e34 <.Loc.84.2>:

  osalDbgCheck((gptp != NULL) && (config != NULL));
    4e34:	9c 00 00 00 	cmpa	#0,	r12	;
    4e38:	03 24       	jz	$+8      	;abs 0x4e40

00004e3a <.Loc.84.2>:
    4e3a:	9d 00 00 00 	cmpa	#0,	r13	;
    4e3e:	04 20       	jnz	$+10     	;abs 0x4e48

00004e40 <.L6>:
    4e40:	8c 01 ca 01 	mova	#65994,	r12	;0x101ca

00004e44 <.LVL3>:
    4e44:	b0 13 3e 46 	calla	#17982		;0x0463e

00004e48 <.L7>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    4e48:	b0 13 08 4e 	calla	#19976		;0x04e08

00004e4c <.LBE26>:

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    4e4c:	6c 4a       	mov.b	@r10,	r12	;
    4e4e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4e50:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4e52:	4d 9c       	cmp.b	r12,	r13	;
    4e54:	04 2c       	jc	$+10     	;abs 0x4e5e

00004e56 <.Loc.87.2>:
    4e56:	8c 01 ca 01 	mova	#65994,	r12	;0x101ca
    4e5a:	b0 13 3e 46 	calla	#17982		;0x0463e

00004e5e <.L8>:
              "invalid state");
  gptp->config = config;
    4e5e:	7a 08 02 00 	mova	r8,	2(r10)	;

00004e62 <.Loc.90.2>:
  gpt_lld_start(gptp);
    4e62:	cc 0a       	mova	r10,	r12	;
    4e64:	b0 13 ca 64 	calla	#25802		;0x064ca

00004e68 <.LVL7>:
  gptp->state = GPT_READY;
    4e68:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004e6c <.LBB28>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    4e6c:	b0 13 10 4e 	calla	#19984		;0x04e10

00004e70 <.LBE28>:
  osalSysUnlock();
}
    4e70:	08 16       	popm.a	#1,	r8	;20-bit words
    4e72:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e74:	10 01       	reta			;

00004e76 <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    4e76:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004e78 <.LCFI6>:
    4e78:	ca 0c       	mova	r12,	r10	;
    4e7a:	09 4d       	mov	r13,	r9	;

00004e7c <.Loc.200.2>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4e7c:	9c 00 00 00 	cmpa	#0,	r12	;
    4e80:	04 20       	jnz	$+10     	;abs 0x4e8a

00004e82 <.Loc.200.2>:
    4e82:	8c 01 8b 01 	mova	#65931,	r12	;0x1018b

00004e86 <.LVL32>:
    4e86:	b0 13 3e 46 	calla	#17982		;0x0463e

00004e8a <.L23>:
  osalDbgCheck(gptp->config->callback != NULL);
    4e8a:	3c 0a 02 00 	mova	2(r10),	r12	;
    4e8e:	00 18 cc 93 	cmpx.a	#0,	4(r12)	;r3 As==00
    4e92:	04 00 
    4e94:	04 20       	jnz	$+10     	;abs 0x4e9e

00004e96 <.Loc.201.2>:
    4e96:	8c 01 8b 01 	mova	#65931,	r12	;0x1018b
    4e9a:	b0 13 3e 46 	calla	#17982		;0x0463e

00004e9e <.L24>:
  osalDbgAssert(gptp->state == GPT_READY,
    4e9e:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4ea2:	04 24       	jz	$+10     	;abs 0x4eac

00004ea4 <.Loc.202.2>:
    4ea4:	8c 01 8b 01 	mova	#65931,	r12	;0x1018b
    4ea8:	b0 13 3e 46 	calla	#17982		;0x0463e

00004eac <.L25>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    4eac:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00004eb0 <.Loc.206.2>:
  gpt_lld_start_timer(gptp, interval);
    4eb0:	0d 49       	mov	r9,	r13	;
    4eb2:	cc 0a       	mova	r10,	r12	;
    4eb4:	b0 13 90 65 	calla	#26000		;0x06590

00004eb8 <.LVL36>:
}
    4eb8:	19 16       	popm.a	#2,	r10	;20-bit words
    4eba:	10 01       	reta			;

00004ebc <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    4ebc:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ebe <.LCFI8>:
    4ebe:	ca 0c       	mova	r12,	r10	;

00004ec0 <.Loc.233.2>:

  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
    4ec0:	9c 00 00 00 	cmpa	#0,	r12	;
    4ec4:	04 20       	jnz	$+10     	;abs 0x4ece

00004ec6 <.Loc.233.2>:
    4ec6:	8c 01 7d 01 	mova	#65917,	r12	;0x1017d

00004eca <.LVL42>:
    4eca:	b0 13 3e 46 	calla	#17982		;0x0463e

00004ece <.L28>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4ece:	6c 4a       	mov.b	@r10,	r12	;
    4ed0:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    4ed4:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4ed6:	4d 9c       	cmp.b	r12,	r13	;
    4ed8:	04 2c       	jc	$+10     	;abs 0x4ee2

00004eda <.Loc.234.2>:
    4eda:	8c 01 7d 01 	mova	#65917,	r12	;0x1017d
    4ede:	b0 13 3e 46 	calla	#17982		;0x0463e

00004ee2 <.L29>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    4ee2:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004ee6 <.Loc.239.2>:
  gpt_lld_stop_timer(gptp);
    4ee6:	cc 0a       	mova	r10,	r12	;
    4ee8:	b0 13 b4 65 	calla	#26036		;0x065b4

00004eec <.LVL45>:
}
    4eec:	0a 16       	popm.a	#1,	r10	;20-bit words
    4eee:	10 01       	reta			;

00004ef0 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    4ef0:	b0 13 3e 59 	calla	#22846		;0x0593e

00004ef4 <.LVL0>:
}
    4ef4:	10 01       	reta			;

00004ef6 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    4ef6:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004efa <.Loc.74.1>:
  i2cp->config = NULL;
    4efa:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4efe:	02 00 

00004f00 <.Loc.83.1>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    4f00:	10 01       	reta			;

00004f02 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    4f02:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f04 <.LCFI0>:
    4f04:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f06 <.LCFI1>:
    4f06:	ca 0c       	mova	r12,	r10	;
    4f08:	c8 0d       	mova	r13,	r8	;

00004f0a <.Loc.95.1>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    4f0a:	9c 00 00 00 	cmpa	#0,	r12	;
    4f0e:	03 24       	jz	$+8      	;abs 0x4f16

00004f10 <.Loc.95.1>:
    4f10:	9d 00 00 00 	cmpa	#0,	r13	;
    4f14:	04 20       	jnz	$+10     	;abs 0x4f1e

00004f16 <.L4>:
    4f16:	8c 01 19 02 	mova	#66073,	r12	;0x10219

00004f1a <.LVL3>:
    4f1a:	b0 13 3e 46 	calla	#17982		;0x0463e

00004f1e <.L5>:
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    4f1e:	6c 4a       	mov.b	@r10,	r12	;
    4f20:	4d 4c       	mov.b	r12,	r13	;
    4f22:	7d 53       	add.b	#-1,	r13	;r3 As==11
    4f24:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4f26:	4e 9d       	cmp.b	r13,	r14	;
    4f28:	07 2c       	jc	$+16     	;abs 0x4f38

00004f2a <.Loc.96.1>:
    4f2a:	3c 90 05 00 	cmp	#5,	r12	;
    4f2e:	04 24       	jz	$+10     	;abs 0x4f38

00004f30 <.Loc.96.1>:
    4f30:	8c 01 19 02 	mova	#66073,	r12	;0x10219
    4f34:	b0 13 3e 46 	calla	#17982		;0x0463e

00004f38 <.L6>:
  _disable_interrupts();
    4f38:	32 c2       	dint			
    4f3a:	03 43       	nop			

00004f3c <.Loc.348.2>:
  asm volatile("nop");
    4f3c:	03 43       	nop			

00004f3e <.LBE26>:
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    4f3e:	7a 08 02 00 	mova	r8,	2(r10)	;

00004f42 <.Loc.101.1>:
  i2c_lld_start(i2cp);
    4f42:	cc 0a       	mova	r10,	r12	;
    4f44:	b0 13 76 59 	calla	#22902		;0x05976

00004f48 <.LVL6>:
  i2cp->state = I2C_READY;
    4f48:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004f4c <.LBB29>:
  asm volatile("nop");
    4f4c:	03 43       	nop			

00004f4e <.Loc.356.2>:
  _enable_interrupts();
    4f4e:	03 43       	nop			
    4f50:	32 d2       	eint			
    4f52:	03 43       	nop			

00004f54 <.LBE29>:
  osalSysUnlock();
}
    4f54:	08 16       	popm.a	#1,	r8	;20-bit words
    4f56:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f58:	10 01       	reta			;

00004f5a <port_lock>:
  _disable_interrupts();
    4f5a:	32 c2       	dint			
    4f5c:	03 43       	nop			

00004f5e <.Loc.348.1>:
  asm volatile("nop");
    4f5e:	03 43       	nop			

00004f60 <.Loc.349.1>:
}
    4f60:	10 01       	reta			;

00004f62 <port_unlock>:
  asm volatile("nop");
    4f62:	03 43       	nop			

00004f64 <.Loc.356.1>:
  _enable_interrupts();
    4f64:	03 43       	nop			
    4f66:	32 d2       	eint			
    4f68:	03 43       	nop			

00004f6a <.Loc.357.1>:
}
    4f6a:	10 01       	reta			;

00004f6c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    4f6c:	b0 13 56 57 	calla	#22358		;0x05756

00004f70 <.LVL2>:
}
    4f70:	10 01       	reta			;

00004f72 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    4f72:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004f76 <.Loc.71.3>:
  spip->config = NULL;
    4f76:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4f7a:	02 00 

00004f7c <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    4f7c:	00 18 cc 43 	movx.a	#0,	6(r12)	;r3 As==00
    4f80:	06 00 

00004f82 <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    4f82:	10 01       	reta			;

00004f84 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    4f84:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f86 <.LCFI0>:
    4f86:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f88 <.LCFI1>:
    4f88:	ca 0c       	mova	r12,	r10	;
    4f8a:	c8 0d       	mova	r13,	r8	;

00004f8c <.Loc.93.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));
    4f8c:	9c 00 00 00 	cmpa	#0,	r12	;
    4f90:	03 24       	jz	$+8      	;abs 0x4f98

00004f92 <.Loc.93.3>:
    4f92:	9d 00 00 00 	cmpa	#0,	r13	;
    4f96:	04 20       	jnz	$+10     	;abs 0x4fa0

00004f98 <.L7>:
    4f98:	8c 01 a6 02 	mova	#66214,	r12	;0x102a6

00004f9c <.LVL5>:
    4f9c:	b0 13 3e 46 	calla	#17982		;0x0463e

00004fa0 <.L8>:
  chSysLock();
    4fa0:	b0 13 5a 4f 	calla	#20314		;0x04f5a

00004fa4 <.LBE50>:

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
    4fa4:	6c 4a       	mov.b	@r10,	r12	;
    4fa6:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4fa8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4faa:	4d 9c       	cmp.b	r12,	r13	;
    4fac:	04 2c       	jc	$+10     	;abs 0x4fb6

00004fae <.Loc.96.3>:
    4fae:	8c 01 a6 02 	mova	#66214,	r12	;0x102a6
    4fb2:	b0 13 3e 46 	calla	#17982		;0x0463e

00004fb6 <.L9>:
                "invalid state");
  spip->config = config;
    4fb6:	7a 08 02 00 	mova	r8,	2(r10)	;

00004fba <.Loc.99.3>:
  spi_lld_start(spip);
    4fba:	cc 0a       	mova	r10,	r12	;
    4fbc:	b0 13 46 58 	calla	#22598		;0x05846

00004fc0 <.LVL9>:
  spip->state = SPI_READY;
    4fc0:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004fc4 <.LBB52>:
  chSysUnlock();
    4fc4:	b0 13 62 4f 	calla	#20322		;0x04f62

00004fc8 <.LBE52>:
  osalSysUnlock();
}
    4fc8:	08 16       	popm.a	#1,	r8	;20-bit words
    4fca:	0a 16       	popm.a	#1,	r10	;20-bit words
    4fcc:	10 01       	reta			;

00004fce <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
    4fce:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004fd0 <.LCFI11>:
    4fd0:	08 14       	pushm.a	#1,	r8	;20-bit words

00004fd2 <.LCFI12>:
    4fd2:	06 14       	pushm.a	#1,	r6	;20-bit words

00004fd4 <.LCFI13>:
    4fd4:	ca 0c       	mova	r12,	r10	;
    4fd6:	c6 0d       	mova	r13,	r6	;
    4fd8:	c8 0e       	mova	r14,	r8	;

00004fda <.Loc.233.3>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));
    4fda:	9c 00 00 00 	cmpa	#0,	r12	;
    4fde:	06 24       	jz	$+14     	;abs 0x4fec

00004fe0 <.Loc.233.3>:
    4fe0:	9d 00 00 00 	cmpa	#0,	r13	;
    4fe4:	03 24       	jz	$+8      	;abs 0x4fec

00004fe6 <.Loc.233.3>:
    4fe6:	9e 00 00 00 	cmpa	#0,	r14	;
    4fea:	04 20       	jnz	$+10     	;abs 0x4ff4

00004fec <.L41>:
    4fec:	8c 01 5b 02 	mova	#66139,	r12	;0x1025b

00004ff0 <.LVL47>:
    4ff0:	b0 13 3e 46 	calla	#17982		;0x0463e

00004ff4 <.L42>:
  chSysLock();
    4ff4:	b0 13 5a 4f 	calla	#20314		;0x04f5a

00004ff8 <.LBE74>:

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
    4ff8:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4ffc:	04 24       	jz	$+10     	;abs 0x5006

00004ffe <.Loc.236.3>:
    4ffe:	8c 01 5b 02 	mova	#66139,	r12	;0x1025b
    5002:	b0 13 3e 46 	calla	#17982		;0x0463e

00005006 <.L43>:
  spiStartSendI(spip, n, txbuf);
    5006:	fa 40 03 00 	mov.b	#3,	0(r10)	;
    500a:	00 00 
    500c:	ce 08       	mova	r8,	r14	;
    500e:	cd 06       	mova	r6,	r13	;
    5010:	cc 0a       	mova	r10,	r12	;
    5012:	b0 13 d4 58 	calla	#22740		;0x058d4

00005016 <.LBB76>:
  chSysUnlock();
    5016:	b0 13 62 4f 	calla	#20322		;0x04f62

0000501a <.LBE76>:
  osalSysUnlock();
}
    501a:	06 16       	popm.a	#1,	r6	;20-bit words
    501c:	08 16       	popm.a	#1,	r8	;20-bit words
    501e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5020:	10 01       	reta			;

00005022 <port_lock>:
  _disable_interrupts();
    5022:	32 c2       	dint			
    5024:	03 43       	nop			

00005026 <.Loc.348.1>:
  asm volatile("nop");
    5026:	03 43       	nop			

00005028 <.Loc.349.1>:
}
    5028:	10 01       	reta			;

0000502a <port_unlock>:
  asm volatile("nop");
    502a:	03 43       	nop			

0000502c <.Loc.356.1>:
  _enable_interrupts();
    502c:	03 43       	nop			
    502e:	32 d2       	eint			
    5030:	03 43       	nop			

00005032 <.Loc.357.1>:
}
    5032:	10 01       	reta			;

00005034 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    5034:	b0 13 68 61 	calla	#24936		;0x06168

00005038 <.LVL0>:
}
    5038:	10 01       	reta			;

0000503a <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    503a:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000503e <.Loc.71.2>:
  uartp->txstate    = UART_TX_IDLE;
    503e:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00005042 <.Loc.72.2>:
  uartp->rxstate    = UART_RX_IDLE;
    5042:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00005046 <.Loc.73.2>:
  uartp->config     = NULL;
    5046:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    504a:	04 00 

0000504c <.Loc.75.2>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    504c:	cc 43 08 00 	mov.b	#0,	8(r12)	;r3 As==00

00005050 <.Loc.76.2>:
  uartp->threadrx   = NULL;
    5050:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    5054:	0a 00 

00005056 <.Loc.77.2>:
  uartp->threadtx   = NULL;
    5056:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    505a:	0e 00 

0000505c <.Loc.87.2>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    505c:	10 01       	reta			;

0000505e <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    505e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005060 <.LCFI0>:
    5060:	08 14       	pushm.a	#1,	r8	;20-bit words

00005062 <.LCFI1>:
    5062:	ca 0c       	mova	r12,	r10	;
    5064:	c8 0d       	mova	r13,	r8	;

00005066 <.Loc.99.2>:

  osalDbgCheck((uartp != NULL) && (config != NULL));
    5066:	9c 00 00 00 	cmpa	#0,	r12	;
    506a:	03 24       	jz	$+8      	;abs 0x5072

0000506c <.Loc.99.2>:
    506c:	9d 00 00 00 	cmpa	#0,	r13	;
    5070:	04 20       	jnz	$+10     	;abs 0x507a

00005072 <.L6>:
    5072:	8c 01 6b 03 	mova	#66411,	r12	;0x1036b

00005076 <.LVL3>:
    5076:	b0 13 3e 46 	calla	#17982		;0x0463e

0000507a <.L7>:
  chSysLock();
    507a:	b0 13 22 50 	calla	#20514		;0x05022

0000507e <.LBE46>:

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    507e:	6c 4a       	mov.b	@r10,	r12	;
    5080:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5082:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5084:	4d 9c       	cmp.b	r12,	r13	;
    5086:	04 2c       	jc	$+10     	;abs 0x5090

00005088 <.Loc.102.2>:
    5088:	8c 01 6b 03 	mova	#66411,	r12	;0x1036b
    508c:	b0 13 3e 46 	calla	#17982		;0x0463e

00005090 <.L8>:
                "invalid state");

  uartp->config = config;
    5090:	7a 08 04 00 	mova	r8,	4(r10)	;

00005094 <.Loc.106.2>:
  uart_lld_start(uartp);
    5094:	cc 0a       	mova	r10,	r12	;
    5096:	b0 13 c8 61 	calla	#25032		;0x061c8

0000509a <.LVL7>:
  uartp->state = UART_READY;
    509a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000509e <.LBB48>:
  chSysUnlock();
    509e:	b0 13 2a 50 	calla	#20522		;0x0502a

000050a2 <.LBE48>:
  osalSysUnlock();
}
    50a2:	08 16       	popm.a	#1,	r8	;20-bit words
    50a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    50a6:	10 01       	reta			;

000050a8 <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    50a8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000050aa <.LCFI6>:
    50aa:	08 14       	pushm.a	#1,	r8	;20-bit words

000050ac <.LCFI7>:
    50ac:	06 14       	pushm.a	#1,	r6	;20-bit words

000050ae <.LCFI8>:
    50ae:	ca 0c       	mova	r12,	r10	;
    50b0:	c6 0d       	mova	r13,	r6	;
    50b2:	c8 0e       	mova	r14,	r8	;

000050b4 <.Loc.175.2>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
    50b4:	9c 00 00 00 	cmpa	#0,	r12	;
    50b8:	06 24       	jz	$+14     	;abs 0x50c6

000050ba <.Loc.175.2>:
    50ba:	9d 00 00 00 	cmpa	#0,	r13	;
    50be:	03 24       	jz	$+8      	;abs 0x50c6

000050c0 <.Loc.175.2>:
    50c0:	9e 00 00 00 	cmpa	#0,	r14	;
    50c4:	04 20       	jnz	$+10     	;abs 0x50ce

000050c6 <.L26>:
    50c6:	8c 01 45 03 	mova	#66373,	r12	;0x10345

000050ca <.LVL25>:
    50ca:	b0 13 3e 46 	calla	#17982		;0x0463e

000050ce <.L27>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    50ce:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    50d2:	04 24       	jz	$+10     	;abs 0x50dc

000050d4 <.Loc.176.2>:
    50d4:	8c 01 45 03 	mova	#66373,	r12	;0x10345
    50d8:	b0 13 3e 46 	calla	#17982		;0x0463e

000050dc <.L28>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    50dc:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    50e0:	04 20       	jnz	$+10     	;abs 0x50ea

000050e2 <.Loc.177.2>:
    50e2:	8c 01 45 03 	mova	#66373,	r12	;0x10345
    50e6:	b0 13 3e 46 	calla	#17982		;0x0463e

000050ea <.L29>:

  uart_lld_start_send(uartp, n, txbuf);
    50ea:	ce 08       	mova	r8,	r14	;
    50ec:	cd 06       	mova	r6,	r13	;
    50ee:	cc 0a       	mova	r10,	r12	;
    50f0:	b0 13 cc 63 	calla	#25548		;0x063cc

000050f4 <.LVL29>:
  uartp->txstate = UART_TX_ACTIVE;
    50f4:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

000050f8 <.Loc.181.2>:
}
    50f8:	06 16       	popm.a	#1,	r6	;20-bit words
    50fa:	08 16       	popm.a	#1,	r8	;20-bit words
    50fc:	0a 16       	popm.a	#1,	r10	;20-bit words
    50fe:	10 01       	reta			;

00005100 <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    5100:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005102 <.LCFI15>:
    5102:	08 14       	pushm.a	#1,	r8	;20-bit words

00005104 <.LCFI16>:
    5104:	06 14       	pushm.a	#1,	r6	;20-bit words

00005106 <.LCFI17>:
    5106:	ca 0c       	mova	r12,	r10	;
    5108:	c6 0d       	mova	r13,	r6	;
    510a:	c8 0e       	mova	r14,	r8	;

0000510c <.Loc.281.2>:

  osalDbgCheckClassI();
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
    510c:	9c 00 00 00 	cmpa	#0,	r12	;
    5110:	06 24       	jz	$+14     	;abs 0x511e

00005112 <.Loc.281.2>:
    5112:	9d 00 00 00 	cmpa	#0,	r13	;
    5116:	03 24       	jz	$+8      	;abs 0x511e

00005118 <.Loc.281.2>:
    5118:	9e 00 00 00 	cmpa	#0,	r14	;
    511c:	04 20       	jnz	$+10     	;abs 0x5126

0000511e <.L56>:
    511e:	8c 01 07 03 	mova	#66311,	r12	;0x10307

00005122 <.LVL54>:
    5122:	b0 13 3e 46 	calla	#17982		;0x0463e

00005126 <.L57>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    5126:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    512a:	04 24       	jz	$+10     	;abs 0x5134

0000512c <.Loc.282.2>:
    512c:	8c 01 07 03 	mova	#66311,	r12	;0x10307
    5130:	b0 13 3e 46 	calla	#17982		;0x0463e

00005134 <.L58>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    5134:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    5138:	04 20       	jnz	$+10     	;abs 0x5142

0000513a <.Loc.283.2>:
    513a:	8c 01 07 03 	mova	#66311,	r12	;0x10307
    513e:	b0 13 3e 46 	calla	#17982		;0x0463e

00005142 <.L59>:

  uart_lld_start_receive(uartp, n, rxbuf);
    5142:	ce 08       	mova	r8,	r14	;
    5144:	cd 06       	mova	r6,	r13	;
    5146:	cc 0a       	mova	r10,	r12	;
    5148:	b0 13 20 64 	calla	#25632		;0x06420

0000514c <.LVL58>:
  uartp->rxstate = UART_RX_ACTIVE;
    514c:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

00005150 <.Loc.287.2>:
}
    5150:	06 16       	popm.a	#1,	r6	;20-bit words
    5152:	08 16       	popm.a	#1,	r8	;20-bit words
    5154:	0a 16       	popm.a	#1,	r10	;20-bit words
    5156:	10 01       	reta			;

00005158 <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    5158:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000515a <.LCFI20>:
    515a:	ca 0c       	mova	r12,	r10	;

0000515c <.Loc.337.2>:

  osalDbgCheckClassI();
  osalDbgCheck(uartp != NULL);
    515c:	9c 00 00 00 	cmpa	#0,	r12	;
    5160:	04 20       	jnz	$+10     	;abs 0x516a

00005162 <.Loc.337.2>:
    5162:	8c 01 e6 02 	mova	#66278,	r12	;0x102e6

00005166 <.LVL68>:
    5166:	b0 13 3e 46 	calla	#17982		;0x0463e

0000516a <.L71>:
  osalDbgAssert(uartp->state == UART_READY, "not active");
    516a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    516e:	04 24       	jz	$+10     	;abs 0x5178

00005170 <.Loc.338.2>:
    5170:	8c 01 e6 02 	mova	#66278,	r12	;0x102e6
    5174:	b0 13 3e 46 	calla	#17982		;0x0463e

00005178 <.L72>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    5178:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    517c:	07 20       	jnz	$+16     	;abs 0x518c

0000517e <.LBB79>:
    size_t n = uart_lld_stop_receive(uartp);
    517e:	cc 0a       	mova	r10,	r12	;
    5180:	b0 13 78 64 	calla	#25720		;0x06478

00005184 <.LVL72>:
    uartp->rxstate = UART_RX_IDLE;
    5184:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00005188 <.L70>:
    return n;
  }
  return 0;
}
    5188:	0a 16       	popm.a	#1,	r10	;20-bit words
    518a:	10 01       	reta			;

0000518c <.L74>:
  return 0;
    518c:	4c 43       	clr.b	r12		;
    518e:	80 00 88 51 	mova	#20872,	r0	;0x05188

00005192 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    5192:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    5196:	80 5a 5c 01 

0000519a <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    519a:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    519e:	10 a5 40 01 

000051a2 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    51a2:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    51a6:	41 01 

000051a8 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    51a8:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    51ac:	00 a5 60 01 

000051b0 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    51b0:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    51b4:	48 00 62 01 

000051b8 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    51b8:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    51bc:	33 01 64 01 

000051c0 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    51c0:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    51c4:	66 01 

000051c6 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    51c6:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    51ca:	c9 c1 68 01 

000051ce <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    51ce:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    51d2:	0f 00 6c 01 

000051d6 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    51d6:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    51da:	61 01 

000051dc <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    51dc:	b0 13 b6 54 	calla	#21686		;0x054b6

000051e0 <.LVL0>:
#endif
}
    51e0:	10 01       	reta			;

000051e2 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    51e2:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    51e6:	7f 3e d2 03 

000051ea <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    51ea:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    51ee:	10 00 c2 03 

000051f2 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    51f2:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    51f6:	e0 03 

000051f8 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    51f8:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    51fc:	14 02 c0 03 

00005200 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    5200:	10 01       	reta			;

00005202 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    5202:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    5206:	02 02 

00005208 <.Loc.310.1>:
  PADIR = config->porta.dir;
    5208:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    520c:	02 00 04 02 

00005210 <.Loc.311.1>:
  PAREN = config->porta.ren;
    5210:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    5214:	04 00 06 02 

00005218 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    5218:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    521c:	06 00 0a 02 

00005220 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    5220:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    5224:	08 00 0c 02 

00005228 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    5228:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    522c:	0a 00 22 02 

00005230 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    5230:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    5234:	0c 00 24 02 

00005238 <.Loc.317.1>:
  PBREN = config->portb.ren;
    5238:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    523c:	0e 00 26 02 

00005240 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    5240:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    5244:	10 00 2a 02 

00005248 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    5248:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    524c:	12 00 2c 02 

00005250 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    5250:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    5254:	14 00 22 03 

00005258 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    5258:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    525c:	16 00 24 03 

00005260 <.Loc.351.1>:
  PJREN = config->portj.ren;
    5260:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    5264:	18 00 26 03 

00005268 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    5268:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    526c:	1a 00 2a 03 

00005270 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    5270:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    5274:	1c 00 2c 03 

00005278 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    5278:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    527c:	30 01 

0000527e <.Loc.356.1>:
}
    527e:	10 01       	reta			;

00005280 <_pal_lld_setgroupmode>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    5280:	2e 92       	cmp	#4,	r14	;r2 As==10
    5282:	4e 24       	jz	$+158    	;abs 0x5320
    5284:	6f 42       	mov.b	#4,	r15	;r2 As==10
    5286:	0f 9e       	cmp	r14,	r15	;
    5288:	0a 28       	jnc	$+22     	;abs 0x529e
    528a:	1e 93       	cmp	#1,	r14	;r3 As==01
    528c:	3f 24       	jz	$+128    	;abs 0x530c
    528e:	0e 93       	cmp	#0,	r14	;r3 As==00
    5290:	2d 24       	jz	$+92     	;abs 0x52ec
    5292:	2e 93       	cmp	#2,	r14	;r3 As==10
    5294:	2b 24       	jz	$+88     	;abs 0x52ec
    5296:	3e 90 03 00 	cmp	#3,	r14	;
    529a:	38 24       	jz	$+114    	;abs 0x530c

0000529c <.L38>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    529c:	10 01       	reta			;

0000529e <.L41>:
  switch (mode) {
    529e:	3e 92       	cmp	#8,	r14	;r2 As==11
    52a0:	4f 24       	jz	$+160    	;abs 0x5340
    52a2:	7f 42       	mov.b	#8,	r15	;r2 As==11
    52a4:	0f 9e       	cmp	r14,	r15	;
    52a6:	12 28       	jnc	$+38     	;abs 0x52cc
    52a8:	3e 90 06 00 	cmp	#6,	r14	;
    52ac:	f7 23       	jnz	$-16     	;abs 0x529c

000052ae <.Loc.410.1>:
      port->dir |= mask;
    52ae:	8c dd 04 00 	bis	r13,	4(r12)	;

000052b2 <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    52b2:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    52b6:	03 24       	jz	$+8      	;abs 0x52be

000052b8 <.Loc.411.1>:
    52b8:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    52bc:	23 20       	jnz	$+72     	;abs 0x5304

000052be <.L52>:
        port->sel0 &= ~mask;
    52be:	3d e3       	inv	r13		;

000052c0 <.LVL28>:
    52c0:	8c fd 0a 00 	and	r13,	10(r12)	; 0x000a

000052c4 <.Loc.415.1>:
        port->sel1 &= ~mask;
    52c4:	8c fd 0c 00 	and	r13,	12(r12)	; 0x000c
    52c8:	80 00 9c 52 	mova	#21148,	r0	;0x0529c

000052cc <.L45>:
  switch (mode) {
    52cc:	3e 90 09 00 	cmp	#9,	r14	;
    52d0:	43 24       	jz	$+136    	;abs 0x5358
    52d2:	3e 90 0a 00 	cmp	#10,	r14	;#0x000a
    52d6:	e2 23       	jnz	$-58     	;abs 0x529c

000052d8 <.Loc.435.1>:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    52d8:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    52dc:	03 20       	jnz	$+8      	;abs 0x52e4

000052de <.Loc.435.1>:
    52de:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    52e2:	10 24       	jz	$+34     	;abs 0x5304

000052e4 <.L55>:
        port->sel0 |= mask;
    52e4:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a
    52e8:	80 00 68 53 	mova	#21352,	r0	;0x05368

000052ec <.L43>:
      port->dir &= ~mask;
    52ec:	0e 4d       	mov	r13,	r14	;

000052ee <.LVL30>:
    52ee:	3e e3       	inv	r14		;
    52f0:	8c fe 04 00 	and	r14,	4(r12)	;

000052f4 <.Loc.378.1>:
      port->ren &= ~mask;
    52f4:	8c fe 08 00 	and	r14,	8(r12)	;

000052f8 <.L105>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    52f8:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    52fc:	1b 24       	jz	$+56     	;abs 0x5334

000052fe <.Loc.402.1>:
    52fe:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5302:	18 24       	jz	$+50     	;abs 0x5334

00005304 <.L99>:
        port->selc = mask;
    5304:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016
    5308:	80 00 9c 52 	mova	#21148,	r0	;0x0529c

0000530c <.L42>:
      port->dir &= ~mask;
    530c:	0e 4d       	mov	r13,	r14	;

0000530e <.LVL32>:
    530e:	3e e3       	inv	r14		;
    5310:	8c fe 04 00 	and	r14,	4(r12)	;

00005314 <.Loc.389.1>:
      port->ren |= mask;
    5314:	8c dd 08 00 	bis	r13,	8(r12)	;

00005318 <.Loc.390.1>:
      port->out |= mask;
    5318:	8c dd 02 00 	bis	r13,	2(r12)	;
    531c:	80 00 f8 52 	mova	#21240,	r0	;0x052f8

00005320 <.L40>:
      port->dir &= ~mask;
    5320:	0e 4d       	mov	r13,	r14	;

00005322 <.LVL34>:
    5322:	3e e3       	inv	r14		;
    5324:	8c fe 04 00 	and	r14,	4(r12)	;

00005328 <.Loc.400.1>:
      port->ren |= mask;
    5328:	8c dd 08 00 	bis	r13,	8(r12)	;

0000532c <.Loc.401.1>:
      port->out &= ~mask;
    532c:	8c fe 02 00 	and	r14,	2(r12)	;
    5330:	80 00 f8 52 	mova	#21240,	r0	;0x052f8

00005334 <.L51>:
        port->sel0 &= ~mask;
    5334:	8c fe 0a 00 	and	r14,	10(r12)	; 0x000a

00005338 <.Loc.406.1>:
        port->sel1 &= ~mask;
    5338:	8c fe 0c 00 	and	r14,	12(r12)	; 0x000c
    533c:	80 00 9c 52 	mova	#21148,	r0	;0x0529c

00005340 <.L44>:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    5340:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    5344:	03 20       	jnz	$+8      	;abs 0x534c

00005346 <.Loc.419.1>:
    5346:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    534a:	dc 23       	jnz	$-70     	;abs 0x5304

0000534c <.L53>:
        port->sel0 |= mask;
    534c:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a

00005350 <.Loc.423.1>:
        port->sel1 &= ~mask;
    5350:	8c cd 0c 00 	bic	r13,	12(r12)	; 0x000c
    5354:	80 00 9c 52 	mova	#21148,	r0	;0x0529c

00005358 <.L47>:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    5358:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    535c:	03 24       	jz	$+8      	;abs 0x5364

0000535e <.Loc.427.1>:
    535e:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5362:	d0 27       	jz	$-94     	;abs 0x5304

00005364 <.L54>:
        port->sel0 &= ~mask;
    5364:	8c cd 0a 00 	bic	r13,	10(r12)	; 0x000a

00005368 <.L98>:
        port->sel1 |= mask;
    5368:	8c dd 0c 00 	bis	r13,	12(r12)	; 0x000c

0000536c <.Loc.443.1>:
}
    536c:	80 00 9c 52 	mova	#21148,	r0	;0x0529c

00005370 <_pal_lld_enablepadevent>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    5370:	4a 14       	pushm.a	#5,	r10	;20-bit words

00005372 <.LCFI8>:
    5372:	b1 00 04 00 	suba	#4,	r1	;

00005376 <.LCFI9>:
    5376:	ca 0c       	mova	r12,	r10	;
    5378:	49 4d       	mov.b	r13,	r9	;
    537a:	47 4e       	mov.b	r14,	r7	;
    537c:	c6 0f       	mova	r15,	r6	;

0000537e <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    537e:	00 18 4d 4c 	movx.a	r12,	r13	;
    5382:	0c 4c       	mov	r12,	r12	;
    5384:	0f 18 4d 11 	rpt #16 { rrax.a	r13		;

00005388 <.LVL37>:
    5388:	b0 13 92 cc 	calla	#52370		;0x0cc92

0000538c <.LVL38>:
    538c:	0d 12       	push	r13		;
    538e:	0c 12       	push	r12		;
    5390:	0c 16       	popm.a	#1,	r12	;20-bit words
    5392:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    5396:	7d 40 07 00 	mov.b	#7,	r13	;
    539a:	4d 99       	cmp.b	r9,	r13	;
    539c:	41 28       	jnc	$+132    	;abs 0x5420
    539e:	5d 43       	mov.b	#1,	r13	;r3 As==01

000053a0 <.L108>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    53a0:	08 49       	mov	r9,	r8	;
    53a2:	78 f0 07 00 	and.b	#7,	r8	;
    53a6:	48 0e       	rlam.a	#4,	r8	;
    53a8:	48 0d       	rram.a	#4,	r8	;

000053aa <.Loc.448.1>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    53aa:	4d 5c       	add.b	r12,	r13	;

000053ac <.LVL40>:
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    53ac:	4c 4d       	mov.b	r13,	r12	;
    53ae:	3c 53       	add	#-1,	r12	;r3 As==11
    53b0:	4c 0e       	rlam.a	#4,	r12	;
    53b2:	4c 0d       	rram.a	#4,	r12	;
    53b4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    53b6:	40 18 3c 41 	popx.w	r12		;
    53ba:	40 18 3d 41 	popx.w	r13		;
    53be:	b0 13 22 cc 	calla	#52258		;0x0cc22
    53c2:	0d 12       	push	r13		;
    53c4:	0c 12       	push	r12		;
    53c6:	0c 16       	popm.a	#1,	r12	;20-bit words
    53c8:	e8 0c       	adda	r12,	r8	;
    53ca:	08 14       	pushm.a	#1,	r8	;20-bit words
    53cc:	40 18 3c 41 	popx.w	r12		;
    53d0:	40 18 3d 41 	popx.w	r13		;
    53d4:	0e 4c       	mov	r12,	r14	;
    53d6:	0f 4d       	mov	r13,	r15	;
    53d8:	0e 5e       	rla	r14		;
    53da:	0f 6f       	rlc	r15		;
    53dc:	0e 5e       	rla	r14		;
    53de:	0f 6f       	rlc	r15		;
    53e0:	81 4e 00 00 	mov	r14,	0(r1)	;
    53e4:	81 4f 02 00 	mov	r15,	2(r1)	;
    53e8:	0c 01       	mova	@r1,	r12	;
    53ea:	01 18 cc 46 	movx.a	r6,	70986(r12); 0x1154a
    53ee:	4a 15 

000053f0 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    53f0:	57 93       	cmp.b	#1,	r7	;r3 As==01
    53f2:	19 20       	jnz	$+52     	;abs 0x5426

000053f4 <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    53f4:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    53f8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    53fa:	0d 49       	mov	r9,	r13	;
    53fc:	b0 13 ec cb 	calla	#52204		;0x0cbec
    5400:	08 cc       	bic	r12,	r8	;
    5402:	8a 48 18 00 	mov	r8,	24(r10)	; 0x0018

00005406 <.L110>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    5406:	18 4a 1c 00 	mov	28(r10),r8	;0x0001c
    540a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    540c:	0d 49       	mov	r9,	r13	;
    540e:	b0 13 ec cb 	calla	#52204		;0x0cbec
    5412:	08 cc       	bic	r12,	r8	;
    5414:	8a 48 1c 00 	mov	r8,	28(r10)	; 0x001c

00005418 <.Loc.464.1>:
    port->ie |= (1 << pad);
    5418:	8a dc 1a 00 	bis	r12,	26(r10)	; 0x001a

0000541c <.Loc.466.1>:
  }
}
    541c:	80 00 56 54 	mova	#21590,	r0	;0x05456

00005420 <.L113>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5420:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5422:	80 00 a0 53 	mova	#21408,	r0	;0x053a0

00005426 <.L109>:
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    5426:	67 93       	cmp.b	#2,	r7	;r3 As==10
    5428:	0b 20       	jnz	$+24     	;abs 0x5440

0000542a <.Loc.456.1>:
    port->ies |= (1 << pad);
    542a:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    542e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5430:	0d 49       	mov	r9,	r13	;
    5432:	b0 13 ec cb 	calla	#52204		;0x0cbec
    5436:	0c d8       	bis	r8,	r12	;
    5438:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018
    543c:	80 00 06 54 	mova	#21510,	r0	;0x05406

00005440 <.L111>:
  if (mode == PAL_EVENT_MODE_DISABLED) {
    5440:	07 93       	cmp	#0,	r7	;r3 As==00
    5442:	e1 23       	jnz	$-60     	;abs 0x5406

00005444 <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    5444:	18 4a 1a 00 	mov	26(r10),r8	;0x0001a
    5448:	5c 43       	mov.b	#1,	r12	;r3 As==01
    544a:	0d 49       	mov	r9,	r13	;
    544c:	b0 13 ec cb 	calla	#52204		;0x0cbec
    5450:	08 cc       	bic	r12,	r8	;
    5452:	8a 48 1a 00 	mov	r8,	26(r10)	; 0x001a

00005456 <.L107>:
}
    5456:	a1 00 04 00 	adda	#4,	r1	;
    545a:	46 16       	popm.a	#5,	r10	;20-bit words
    545c:	10 01       	reta			;

0000545e <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    545e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005460 <.LCFI10>:
    5460:	ca 0c       	mova	r12,	r10	;

00005462 <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    5462:	19 4c 1a 00 	mov	26(r12),r9	;0x0001a
    5466:	5c 43       	mov.b	#1,	r12	;r3 As==01

00005468 <.LVL47>:
    5468:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    546c:	b0 13 ec cb 	calla	#52204		;0x0cbec

00005470 <.LVL48>:
    5470:	09 cc       	bic	r12,	r9	;
    5472:	8a 49 1a 00 	mov	r9,	26(r10)	; 0x001a

00005476 <.Loc.471.1>:
}
    5476:	19 16       	popm.a	#2,	r10	;20-bit words
    5478:	10 01       	reta			;

0000547a <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    547a:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000547c <.LCFI0>:
    547c:	49 4c       	mov.b	r12,	r9	;
    547e:	48 4d       	mov.b	r13,	r8	;

00005480 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5480:	0a 49       	mov	r9,	r10	;
    5482:	12 c3       	clrc			
    5484:	0a 10       	rrc	r10		;
    5486:	40 18 0a 4a 	movx.w	r10,	r10	;
    548a:	ea 0a       	adda	r10,	r10	;
    548c:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005490 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5490:	59 f3       	and.b	#1,	r9	;r3 As==01
    5492:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    5496:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

0000549a <.LVL2>:
    549a:	0d 49       	mov	r9,	r13	;

0000549c <.LVL3>:
    549c:	b0 13 f4 cc 	calla	#52468		;0x0ccf4
    54a0:	07 4c       	mov	r12,	r7	;
    54a2:	27 fa       	and	@r10,	r7	;

000054a4 <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    54a4:	0c 48       	mov	r8,	r12	;
    54a6:	0d 49       	mov	r9,	r13	;
    54a8:	b0 13 ec cb 	calla	#52204		;0x0cbec
    54ac:	07 dc       	bis	r12,	r7	;
    54ae:	8a 47 00 00 	mov	r7,	0(r10)	;

000054b2 <.Loc.65.1>:
}
    54b2:	37 16       	popm.a	#4,	r10	;20-bit words
    54b4:	10 01       	reta			;

000054b6 <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    54b6:	40 18 82 43 	movx.w	#0,	&0xfcfd0;r3 As==00
    54ba:	d0 cf 

000054bc <.LBE15>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    54bc:	10 01       	reta			;

000054be <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    54be:	2a 14       	pushm.a	#3,	r10	;20-bit words

000054c0 <.LCFI2>:
    54c0:	ca 0c       	mova	r12,	r10	;

000054c2 <.LVL19>:
  osalDbgCheckClassI();

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    54c2:	40 18 19 42 	movx.w	&0x00510,r9	;
    54c6:	10 05 
    54c8:	79 f0 10 00 	and.b	#16,	r9	;#0x0010
    54cc:	09 93       	cmp	#0,	r9	;r3 As==00
    54ce:	11 24       	jz	$+36     	;abs 0x54f2

000054d0 <.LVL20>:
    54d0:	8c 00 20 05 	mova	#1312,	r12	;0x00520

000054d4 <.LVL21>:
    54d4:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    54d8:	10 00 00 00 
    54dc:	09 24       	jz	$+20     	;abs 0x54f0

000054de <.LVL22>:
    54de:	40 18 bc b0 	bitx.w	#16,	16(r12)	;0x00010, 0x00010
    54e2:	10 00 10 00 
    54e6:	1f 24       	jz	$+64     	;abs 0x5526

000054e8 <.Loc.199.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    54e8:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000054ec <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    54ec:	28 16       	popm.a	#3,	r10	;20-bit words
    54ee:	10 01       	reta			;

000054f0 <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    54f0:	59 43       	mov.b	#1,	r9	;r3 As==01

000054f2 <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    54f2:	48 49       	mov.b	r9,	r8	;
    54f4:	4d 43       	clr.b	r13		;
    54f6:	4c 48       	mov.b	r8,	r12	;
    54f8:	b0 13 7a 54 	calla	#21626		;0x0547a

000054fc <.LVL26>:
  dma_regs[i].sz  = 0;
    54fc:	0c 49       	mov	r9,	r12	;
    54fe:	0d 43       	clr	r13		;
    5500:	b0 13 1e cc 	calla	#52254		;0x0cc1e
    5504:	0d 12       	push	r13		;
    5506:	0c 12       	push	r12		;
    5508:	0c 16       	popm.a	#1,	r12	;20-bit words
    550a:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    550e:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005512 <.Loc.205.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    5512:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5516:	00 00 

00005518 <.Loc.207.1>:
  channel->registers = dma_regs + i;
    5518:	7a 0c 00 00 	mova	r12,	0(r10)	;

0000551c <.Loc.208.1>:
  channel->index     = i;
    551c:	ca 48 04 00 	mov.b	r8,	4(r10)	;

00005520 <.Loc.210.1>:
  return MSG_OK;
    5520:	4c 43       	clr.b	r12		;
    5522:	80 00 ec 54 	mova	#21740,	r0	;0x054ec

00005526 <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    5526:	69 43       	mov.b	#2,	r9	;r3 As==10
    5528:	80 00 f2 54 	mova	#21746,	r0	;0x054f2

0000552c <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    552c:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000552e <.LCFI4>:
    552e:	c8 0c       	mova	r12,	r8	;
    5530:	49 4d       	mov.b	r13,	r9	;

00005532 <.Loc.232.1>:
  
  osalDbgCheckClassI();

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    5532:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005534 <.LVL37>:
    5534:	4c 99       	cmp.b	r9,	r12	;
    5536:	04 2c       	jc	$+10     	;abs 0x5540

00005538 <.Loc.232.1>:
    5538:	8c 01 8c 03 	mova	#66444,	r12	;0x1038c
    553c:	b0 13 3e 46 	calla	#17982		;0x0463e

00005540 <.L27>:
  if (dma_regs[index].ctl & DMAEN) {
    5540:	0c 49       	mov	r9,	r12	;
    5542:	0d 43       	clr	r13		;
    5544:	b0 13 1e cc 	calla	#52254		;0x0cc1e
    5548:	0d 12       	push	r13		;
    554a:	0c 12       	push	r12		;
    554c:	0a 16       	popm.a	#1,	r10	;20-bit words
    554e:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    5552:	27 4a       	mov	@r10,	r7	;
    5554:	77 f0 10 00 	and.b	#16,	r7	;#0x0010
    5558:	07 93       	cmp	#0,	r7	;r3 As==00
    555a:	10 20       	jnz	$+34     	;abs 0x557c

0000555c <.Loc.238.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    555c:	4d 47       	mov.b	r7,	r13	;
    555e:	4c 49       	mov.b	r9,	r12	;
    5560:	b0 13 7a 54 	calla	#21626		;0x0547a

00005564 <.LVL40>:
  dma_regs[index].sz  = 0;
    5564:	8a 47 0a 00 	mov	r7,	10(r10)	; 0x000a

00005568 <.Loc.240.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    5568:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    556c:	00 00 

0000556e <.Loc.242.1>:

  channel->registers = dma_regs + index;
    556e:	78 0a 00 00 	mova	r10,	0(r8)	;

00005572 <.Loc.243.1>:
  channel->index     = index;
    5572:	c8 49 04 00 	mov.b	r9,	4(r8)	;

00005576 <.Loc.245.1>:
  
  return MSG_OK;
    5576:	4c 43       	clr.b	r12		;

00005578 <.L26>:
}
    5578:	37 16       	popm.a	#4,	r10	;20-bit words
    557a:	10 01       	reta			;

0000557c <.L29>:
    return MSG_TIMEOUT;
    557c:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5580:	80 00 78 55 	mova	#21880,	r0	;0x05578

00005584 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5584:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005586 <.LCFI5>:
    5586:	08 14       	pushm.a	#1,	r8	;20-bit words

00005588 <.LCFI6>:
    5588:	c8 0c       	mova	r12,	r8	;
    558a:	ca 0d       	mova	r13,	r10	;

0000558c <.Loc.277.1>:

  osalDbgCheckClassI();

  channel->registers->ctl &= (~DMAEN);
    558c:	0c 0c       	mova	@r12,	r12	;

0000558e <.LVL42>:
    558e:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5592:	00 00 

00005594 <.Loc.278.1>:
  dma_trigger_set(channel->index, request->trigger);
    5594:	5d 4d 10 00 	mov.b	16(r13),r13	;0x00010

00005598 <.LVL43>:
    5598:	5c 48 04 00 	mov.b	4(r8),	r12	;
    559c:	b0 13 7a 54 	calla	#21626		;0x0547a

000055a0 <.LVL44>:
  callbacks[channel->index] = request->callback;
    55a0:	5c 48 04 00 	mov.b	4(r8),	r12	;
    55a4:	0d 43       	clr	r13		;
    55a6:	b0 13 22 cc 	calla	#52258		;0x0cc22
    55aa:	0d 12       	push	r13		;
    55ac:	0c 12       	push	r12		;
    55ae:	0c 16       	popm.a	#1,	r12	;20-bit words
    55b0:	ac 00 d2 cf 	adda	#53202,	r12	;0x0cfd2
    55b4:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    55b8:	00 00 
    55ba:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    55be:	02 00 
    55c0:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    55c4:	04 00 
    55c6:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    55ca:	06 00 

000055cc <.Loc.282.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    55cc:	0c 08       	mova	@r8,	r12	;
    55ce:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    55d2:	02 00 

000055d4 <.Loc.283.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    55d4:	0c 08       	mova	@r8,	r12	;
    55d6:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    55da:	04 00 06 00 

000055de <.Loc.288.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    55de:	0e 08       	mova	@r8,	r14	;
    55e0:	9e 4a 08 00 	mov	8(r10),	10(r14)	; 0x000a
    55e4:	0a 00 

000055e6 <.Loc.289.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    55e6:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    55ea:	1c da 0a 00 	bis	10(r10),r12	;0x0000a

000055ee <.Loc.290.1>:
                            request->transfer_mode | DMAEN |
    55ee:	3c d0 15 00 	bis	#21,	r12	;#0x0015

000055f2 <.Loc.289.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    55f2:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    55f6:	8e 4c 00 00 	mov	r12,	0(r14)	;

000055fa <.Loc.292.1>:
                            DMAREQ;
}
    55fa:	08 16       	popm.a	#1,	r8	;20-bit words
    55fc:	0a 16       	popm.a	#1,	r10	;20-bit words
    55fe:	10 01       	reta			;

00005600 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5600:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005602 <.LCFI7>:
    5602:	ca 0c       	mova	r12,	r10	;

00005604 <.LBB33>:
  return chSysGetStatusAndLockX();
    5604:	b0 13 da 46 	calla	#18138		;0x046da

00005608 <.LVL49>:
    5608:	09 4c       	mov	r12,	r9	;

0000560a <.LBE33>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
    560a:	9a 00 00 00 	cmpa	#0,	r10	;
    560e:	09 20       	jnz	$+20     	;abs 0x5622

00005610 <.Loc.307.1>:
    5610:	8c 01 80 03 	mova	#66432,	r12	;0x10380
    5614:	b0 13 3e 46 	calla	#17982		;0x0463e

00005618 <.L34>:
  chSysRestoreStatusX(sts);
    5618:	0c 49       	mov	r9,	r12	;
    561a:	b0 13 f6 46 	calla	#18166		;0x046f6

0000561e <.LBE35>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    561e:	19 16       	popm.a	#2,	r10	;20-bit words
    5620:	10 01       	reta			;

00005622 <.L33>:
  if (dmaIsClaimed(channel)) {
    5622:	0c 0a       	mova	@r10,	r12	;
    5624:	9c 00 00 00 	cmpa	#0,	r12	;
    5628:	f7 27       	jz	$-16     	;abs 0x5618

0000562a <.Loc.309.1>:
    562a:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    562e:	10 00 00 00 
    5632:	f2 27       	jz	$-26     	;abs 0x5618

00005634 <.Loc.312.1>:
    channel->registers->ctl = DMAABORT;
    5634:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00005638 <.Loc.315.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    5638:	4d 43       	clr.b	r13		;
    563a:	8c 00 d0 cf 	mova	#53200,	r12	;0x0cfd0
    563e:	b0 13 82 4d 	calla	#19842		;0x04d82

00005642 <.LVL52>:
    5642:	80 00 18 56 	mova	#22040,	r0	;0x05618

00005646 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    5646:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005648 <.LCFI8>:
    5648:	ca 0c       	mova	r12,	r10	;

0000564a <.Loc.332.1>:
  
  osalDbgCheckClassI();
  osalDbgCheck(channel != NULL);
    564a:	9c 00 00 00 	cmpa	#0,	r12	;
    564e:	04 20       	jnz	$+10     	;abs 0x5658

00005650 <.Loc.332.1>:
    5650:	8c 01 75 03 	mova	#66421,	r12	;0x10375

00005654 <.LVL54>:
    5654:	b0 13 3e 46 	calla	#17982		;0x0463e

00005658 <.L41>:
  
  if (!(channel->registers->ctl & DMAEN)) {
    5658:	0c 0a       	mova	@r10,	r12	;
    565a:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    565e:	10 00 00 00 
    5662:	0e 24       	jz	$+30     	;abs 0x5680

00005664 <.Loc.339.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    5664:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    5668:	00 00 

0000566a <.Loc.341.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    566a:	4d 43       	clr.b	r13		;
    566c:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5670:	b0 13 7a 54 	calla	#21626		;0x0547a

00005674 <.LVL56>:
  channel->registers->sz  = 0;
    5674:	0c 0a       	mova	@r10,	r12	;
    5676:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000567a <.Loc.343.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    567a:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    567e:	00 00 

00005680 <.L40>:
}
    5680:	0a 16       	popm.a	#1,	r10	;20-bit words
    5682:	10 01       	reta			;

00005684 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    5684:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005686 <.LCFI0>:
    5686:	08 14       	pushm.a	#1,	r8	;20-bit words

00005688 <.LCFI1>:
    5688:	06 14       	pushm.a	#1,	r6	;20-bit words

0000568a <.LCFI2>:
    568a:	04 14       	pushm.a	#1,	r4	;20-bit words

0000568c <.LCFI3>:
    568c:	ca 0c       	mova	r12,	r10	;

0000568e <.Loc.106.1>:

  if (!dmaIsClaimed(&(spip->dmarx))) {
    568e:	c8 0c       	mova	r12,	r8	;
    5690:	a8 00 50 00 	adda	#80,	r8	;0x00050
    5694:	98 00 00 00 	cmpa	#0,	r8	;
    5698:	09 24       	jz	$+20     	;abs 0x56ac

0000569a <.Loc.106.1>:
    569a:	3c 0c 50 00 	mova	80(r12),r12	;0x00050

0000569e <.LVL1>:
    569e:	9c 00 00 00 	cmpa	#0,	r12	;
    56a2:	04 24       	jz	$+10     	;abs 0x56ac

000056a4 <.Loc.106.1>:
    56a4:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    56a8:	00 00 
    56aa:	03 20       	jnz	$+8      	;abs 0x56b2

000056ac <.L2>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmarx));
    56ac:	cc 08       	mova	r8,	r12	;
    56ae:	b0 13 be 54 	calla	#21694		;0x054be

000056b2 <.L3>:
  }
  
  if (!dmaIsClaimed(&(spip->dmatx))) {
    56b2:	c6 0a       	mova	r10,	r6	;
    56b4:	a6 00 46 00 	adda	#70,	r6	;0x00046
    56b8:	96 00 00 00 	cmpa	#0,	r6	;
    56bc:	09 24       	jz	$+20     	;abs 0x56d0

000056be <.Loc.111.1>:
    56be:	3c 0a 46 00 	mova	70(r10),r12	;0x00046
    56c2:	9c 00 00 00 	cmpa	#0,	r12	;
    56c6:	04 24       	jz	$+10     	;abs 0x56d0

000056c8 <.Loc.111.1>:
    56c8:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    56cc:	00 00 
    56ce:	03 20       	jnz	$+8      	;abs 0x56d6

000056d0 <.L4>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmatx));
    56d0:	cc 06       	mova	r6,	r12	;
    56d2:	b0 13 be 54 	calla	#21694		;0x054be

000056d6 <.L5>:
  }
  
  dmaTransferI(&(spip->dmarx), &(spip->rx_req));
    56d6:	84 00 84 55 	mova	#21892,	r4	;0x05584
    56da:	cd 0a       	mova	r10,	r13	;
    56dc:	ad 00 2c 00 	adda	#44,	r13	;0x0002c
    56e0:	cc 08       	mova	r8,	r12	;
    56e2:	44 13       	calla	r4		;

000056e4 <.LVL4>:
  dmaTransferI(&(spip->dmatx), &(spip->tx_req));
    56e4:	cd 0a       	mova	r10,	r13	;
    56e6:	ad 00 12 00 	adda	#18,	r13	;0x00012
    56ea:	cc 06       	mova	r6,	r12	;
    56ec:	44 13       	calla	r4		;

000056ee <.LVL5>:

  *(spip->ifg) |= UCTXIFG;
    56ee:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    56f2:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000056f6 <.Loc.120.1>:
}
    56f6:	04 16       	popm.a	#1,	r4	;20-bit words
    56f8:	06 16       	popm.a	#1,	r6	;20-bit words
    56fa:	08 16       	popm.a	#1,	r8	;20-bit words
    56fc:	0a 16       	popm.a	#1,	r10	;20-bit words
    56fe:	10 01       	reta			;

00005700 <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    5700:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005702 <.LCFI4>:
    5702:	08 14       	pushm.a	#1,	r8	;20-bit words

00005704 <.LCFI5>:
    5704:	ca 0c       	mova	r12,	r10	;

00005706 <.LVL7>:
  SPIDriver * spip = (SPIDriver *)(arg);

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    5706:	3e 0c 0e 00 	mova	14(r12),r14	;0x0000e
    570a:	ae c3 00 00 	bic	#2,	0(r14)	;r3 As==10

0000570e <.Loc.136.1>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    570e:	3e 0c 02 00 	mova	2(r12),	r14	;
    5712:	0e 0e       	mova	@r14,	r14	;
    5714:	9e 00 00 00 	cmpa	#0,	r14	;
    5718:	06 24       	jz	$+14     	;abs 0x5726

0000571a <.Loc.136.1>:
    571a:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    571e:	4e 13       	calla	r14		;

00005720 <.LVL8>:
    5720:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    5724:	02 20       	jnz	$+6      	;abs 0x572a

00005726 <.L17>:
    5726:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000572a <.L18>:
  chThdResumeI(trp, msg);
    572a:	4d 43       	clr.b	r13		;
    572c:	cc 0a       	mova	r10,	r12	;
    572e:	ac 00 06 00 	adda	#6,	r12	;

00005732 <.LVL10>:
    5732:	b0 13 6e 48 	calla	#18542		;0x0486e

00005736 <.LBE20>:
  
  if (spip->state == SPI_READY) {
    5736:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    573a:	0a 20       	jnz	$+22     	;abs 0x5750

0000573c <.LBB22>:
    dmaReleaseX(&(spip->dmarx));
    573c:	88 00 00 56 	mova	#22016,	r8	;0x05600
    5740:	cc 0a       	mova	r10,	r12	;
    5742:	ac 00 50 00 	adda	#80,	r12	;0x00050
    5746:	48 13       	calla	r8		;

00005748 <.LVL13>:
    dmaReleaseX(&(spip->dmatx));
    5748:	cc 0a       	mova	r10,	r12	;
    574a:	ac 00 46 00 	adda	#70,	r12	;0x00046
    574e:	48 13       	calla	r8		;

00005750 <.L16>:
  }
}
    5750:	08 16       	popm.a	#1,	r8	;20-bit words
    5752:	0a 16       	popm.a	#1,	r10	;20-bit words
    5754:	10 01       	reta			;

00005756 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
    5756:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005758 <.LCFI6>:

#if MSP430X_SPI_USE_SPIA0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA0);
    5758:	8a 01 ca 15 	mova	#71114,	r10	;0x115ca
    575c:	cc 0a       	mova	r10,	r12	;
    575e:	b0 13 72 4f 	calla	#20338		;0x04f72

00005762 <.LVL15>:
  SPIDA0.regs                     = (msp430x_spi_reg_t *)(&UCA0CTLW0);
    5762:	00 18 fa 40 	movx.a	#1472,	10(r10)	;0x005c0, 0x0000a
    5766:	c0 05 0a 00 

0000576a <.Loc.162.1>:
  SPIDA0.ifg                      = (volatile uint16_t *)&UCA0IFG;
    576a:	00 18 fa 40 	movx.a	#1500,	14(r10)	;0x005dc, 0x0000e
    576e:	dc 05 0e 00 

00005772 <.Loc.163.1>:
  SPIDA0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA0TXIFG);
    5772:	ba 40 0f 00 	mov	#15,	34(r10)	;#0x000f, 0x0022
    5776:	22 00 

00005778 <.Loc.164.1>:
  SPIDA0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA0RXIFG);
    5778:	ba 40 0e 00 	mov	#14,	60(r10)	;#0x000e, 0x003c
    577c:	3c 00 

0000577e <.Loc.165.1>:
  SPIDA0.tx_req.dest_addr         = &(SPIDA0.regs->txbuf);
    577e:	00 18 fa 40 	movx.a	#1486,	22(r10)	;0x005ce, 0x00016
    5782:	ce 05 16 00 

00005786 <.Loc.166.1>:
  SPIDA0.rx_req.source_addr       = &(SPIDA0.regs->rxbuf);
    5786:	00 18 fa 40 	movx.a	#1484,	44(r10)	;0x005cc, 0x0002c
    578a:	cc 05 2c 00 

0000578e <.Loc.167.1>:
  SPIDA0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    578e:	ba 40 c0 00 	mov	#192,	30(r10)	;#0x00c0, 0x001e
    5792:	1e 00 

00005794 <.Loc.168.1>:
  SPIDA0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5794:	ba 40 c0 00 	mov	#192,	56(r10)	;#0x00c0, 0x0038
    5798:	38 00 

0000579a <.Loc.169.1>:
  SPIDA0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    579a:	8a 43 20 00 	mov	#0,	32(r10)	;r3 As==00, 0x0020

0000579e <.Loc.170.1>:
  SPIDA0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    579e:	8a 43 3a 00 	mov	#0,	58(r10)	;r3 As==00, 0x003a

000057a2 <.Loc.171.1>:
  SPIDA0.tx_req.callback.callback = NULL;
    57a2:	00 18 ca 43 	movx.a	#0,	36(r10)	;r3 As==00, 0x00024
    57a6:	24 00 

000057a8 <.Loc.172.1>:
  SPIDA0.tx_req.callback.args     = NULL;
    57a8:	00 18 ca 43 	movx.a	#0,	40(r10)	;r3 As==00, 0x00028
    57ac:	28 00 

000057ae <.Loc.173.1>:
  SPIDA0.rx_req.callback.callback = spi_lld_end_of_transfer;
    57ae:	00 18 fa 40 	movx.a	#22272,	62(r10)	;0x05700, 0x0003e
    57b2:	00 57 3e 00 

000057b6 <.Loc.174.1>:
  SPIDA0.rx_req.callback.args     = &SPIDA0;
    57b6:	7a 0a 42 00 	mova	r10,	66(r10)	; 0x00042

000057ba <.Loc.312.1>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    57ba:	0a 16       	popm.a	#1,	r10	;20-bit words
    57bc:	10 01       	reta			;

000057be <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    57be:	1a 14       	pushm.a	#2,	r10	;20-bit words

000057c0 <.LCFI7>:

  if (spip->config->ss_line) {
    57c0:	3c 0c 02 00 	mova	2(r12),	r12	;

000057c4 <.LVL19>:
    57c4:	3c 0c 04 00 	mova	4(r12),	r12	;
    57c8:	9c 00 00 00 	cmpa	#0,	r12	;
    57cc:	18 24       	jz	$+50     	;abs 0x57fe

000057ce <.Loc.432.1>:
    palClearLine(spip->config->ss_line);
    57ce:	ca 0c       	mova	r12,	r10	;
    57d0:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    57d4:	ff 0f 
    57d6:	19 4a 02 00 	mov	2(r10),	r9	;
    57da:	0c 14       	pushm.a	#1,	r12	;20-bit words
    57dc:	40 18 3c 41 	popx.w	r12		;
    57e0:	40 18 3d 41 	popx.w	r13		;
    57e4:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    57e8:	0d 12       	push	r13		;
    57ea:	0c 12       	push	r12		;
    57ec:	0c 16       	popm.a	#1,	r12	;20-bit words
    57ee:	40 18 0d 4c 	movx.w	r12,	r13	;
    57f2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    57f4:	b0 13 ec cb 	calla	#52204		;0x0cbec
    57f8:	09 cc       	bic	r12,	r9	;
    57fa:	8a 49 02 00 	mov	r9,	2(r10)	;

000057fe <.L26>:
  }
}
    57fe:	19 16       	popm.a	#2,	r10	;20-bit words
    5800:	10 01       	reta			;

00005802 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    5802:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005804 <.LCFI8>:

  if (spip->config->ss_line) {
    5804:	3c 0c 02 00 	mova	2(r12),	r12	;

00005808 <.LVL23>:
    5808:	3c 0c 04 00 	mova	4(r12),	r12	;
    580c:	9c 00 00 00 	cmpa	#0,	r12	;
    5810:	18 24       	jz	$+50     	;abs 0x5842

00005812 <.Loc.447.1>:
    palSetLine(spip->config->ss_line);
    5812:	ca 0c       	mova	r12,	r10	;
    5814:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    5818:	ff 0f 
    581a:	19 4a 02 00 	mov	2(r10),	r9	;
    581e:	0c 14       	pushm.a	#1,	r12	;20-bit words
    5820:	40 18 3c 41 	popx.w	r12		;
    5824:	40 18 3d 41 	popx.w	r13		;
    5828:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    582c:	0d 12       	push	r13		;
    582e:	0c 12       	push	r12		;
    5830:	0c 16       	popm.a	#1,	r12	;20-bit words
    5832:	40 18 0d 4c 	movx.w	r12,	r13	;
    5836:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5838:	b0 13 ec cb 	calla	#52204		;0x0cbec
    583c:	0c d9       	bis	r9,	r12	;
    583e:	8a 4c 02 00 	mov	r12,	2(r10)	;

00005842 <.L31>:
  }
}
    5842:	19 16       	popm.a	#2,	r10	;20-bit words
    5844:	10 01       	reta			;

00005846 <spi_lld_start>:
void spi_lld_start(SPIDriver * spip) {
    5846:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005848 <.LCFI9>:
    5848:	08 14       	pushm.a	#1,	r8	;20-bit words

0000584a <.LCFI10>:
    584a:	ca 0c       	mova	r12,	r10	;

0000584c <.LVL27>:
  if (spip == &SPIDA0) {
    584c:	9c 01 ca 15 	cmpa	#71114,	r12	;0x115ca
    5850:	3a 20       	jnz	$+118    	;abs 0x58c6

00005852 <.Loc.342.1>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    5852:	3c 0c 02 00 	mova	2(r12),	r12	;

00005856 <.LVL28>:
    5856:	1e 4c 08 00 	mov	8(r12),	r14	;
    585a:	1f 4c 0a 00 	mov	10(r12),r15	;0x0000a
    585e:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5862:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5866:	b0 13 b6 cb 	calla	#52150		;0x0cbb6

0000586a <.LVL29>:
    ssel = MSP430X_SPIA0_UCSSEL;
    586a:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080

0000586e <.L37>:
  spip->regs->ctlw0 = UCSWRST;
    586e:	3e 0a 0a 00 	mova	10(r10),r14	;0x0000a

00005872 <.Loc.390.1>:
  spip->regs->brw   = brw;
    5872:	8e 4c 06 00 	mov	r12,	6(r14)	;

00005876 <.Loc.392.1>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    5876:	38 0a 02 00 	mova	2(r10),	r8	;
    587a:	5c 48 0e 00 	mov.b	14(r8),	r12	;0x0000e

0000587e <.LVL31>:
    587e:	6c e3       	xor.b	#2,	r12	;r3 As==10
    5880:	0f 4c       	mov	r12,	r15	;
    5882:	4d 18 0f 5f 	rpt #14 { rlax.w	r15		;
    5886:	5c 48 0c 00 	mov.b	12(r8),	r12	;0x0000c
    588a:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;

0000588e <.Loc.393.1>:
      (spip->config->data_size << 12) | (UCMST) |
    588e:	5b 48 0d 00 	mov.b	13(r8),	r11	;0x0000d
    5892:	4b 18 0b 5b 	rpt #12 { rlax.w	r11		;
    5896:	0c db       	bis	r11,	r12	;

00005898 <.Loc.394.1>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    5898:	00 18 c8 93 	cmpx.a	#0,	4(r8)	;r3 As==00
    589c:	04 00 
    589e:	17 20       	jnz	$+48     	;abs 0x58ce
    58a0:	38 40 00 04 	mov	#1024,	r8	;#0x0400

000058a4 <.L38>:
    58a4:	3c d0 02 09 	bis	#2306,	r12	;#0x0902
    58a8:	0c df       	bis	r15,	r12	;
    58aa:	0c dd       	bis	r13,	r12	;
    58ac:	0c d8       	bis	r8,	r12	;
    58ae:	8e 4c 00 00 	mov	r12,	0(r14)	;

000058b2 <.Loc.395.1>:
  *(spip->ifg) = 0;
    58b2:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    58b6:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000058ba <.LVL32>:
  spi_lld_unselect(spip);
    58ba:	cc 0a       	mova	r10,	r12	;
    58bc:	b0 13 02 58 	calla	#22530		;0x05802

000058c0 <.LVL33>:
}
    58c0:	08 16       	popm.a	#1,	r8	;20-bit words
    58c2:	0a 16       	popm.a	#1,	r10	;20-bit words
    58c4:	10 01       	reta			;

000058c6 <.L39>:
  uint8_t ssel = 0;
    58c6:	4d 43       	clr.b	r13		;

000058c8 <.Loc.338.1>:
  uint16_t brw = 0;
    58c8:	0c 4d       	mov	r13,	r12	;
    58ca:	80 00 6e 58 	mova	#22638,	r0	;0x0586e

000058ce <.L40>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    58ce:	48 43       	clr.b	r8		;
    58d0:	80 00 a4 58 	mova	#22692,	r0	;0x058a4

000058d4 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {
    58d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000058d6 <.LCFI12>:
    58d6:	ca 0c       	mova	r12,	r10	;

000058d8 <.Loc.521.1>:

  spip->tx_req.source_addr = txbuf;
    58d8:	7c 0e 12 00 	mova	r14,	18(r12)	; 0x00012

000058dc <.Loc.522.1>:
  spip->tx_req.size        = n;
    58dc:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

000058e0 <.Loc.523.1>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    58e0:	bc 40 00 03 	mov	#768,	28(r12)	;#0x0300, 0x001c
    58e4:	1c 00 

000058e6 <.Loc.525.1>:

  spip->rx_req.dest_addr = &dummyrx;
    58e6:	00 18 fc 40 	movx.a	#53226,	48(r12)	;0x0cfea, 0x00030
    58ea:	ea cf 30 00 

000058ee <.Loc.526.1>:
  spip->rx_req.size      = n;
    58ee:	8c 4d 34 00 	mov	r13,	52(r12)	; 0x0034

000058f2 <.Loc.527.1>:
  spip->rx_req.addr_mode = 0;
    58f2:	8c 43 36 00 	mov	#0,	54(r12)	;r3 As==00, 0x0036

000058f6 <.Loc.529.1>:

  init_transfer(spip);
    58f6:	b0 13 84 56 	calla	#22148		;0x05684

000058fa <.LVL41>:
}
    58fa:	0a 16       	popm.a	#1,	r10	;20-bit words
    58fc:	10 01       	reta			;

000058fe <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {
    58fe:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005900 <.LCFI14>:
    5900:	ca 0c       	mova	r12,	r10	;
    5902:	49 4d       	mov.b	r13,	r9	;

00005904 <.Loc.572.1>:

  osalDbgAssert(spip->state == SPI_READY, "not ready");
    5904:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    5908:	04 24       	jz	$+10     	;abs 0x5912

0000590a <.Loc.572.1>:
    590a:	8c 01 96 03 	mova	#66454,	r12	;0x10396

0000590e <.LVL45>:
    590e:	b0 13 3e 46 	calla	#17982		;0x0463e

00005912 <.L46>:
  spip->regs->txbuf = frame;
    5912:	3e 0a 0a 00 	mova	10(r10),r14	;0x0000a
    5916:	8e 49 0e 00 	mov	r9,	14(r14)	; 0x000e

0000591a <.Loc.574.1>:
  while (!(*(spip->ifg) & UCRXIFG))
    591a:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e

0000591e <.L47>:
    591e:	40 18 9c b3 	bitx.w	#1,	0(r12)	;r3 As==01
    5922:	00 00 
    5924:	fc 27       	jz	$-6      	;abs 0x591e

00005926 <.Loc.576.1>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    5926:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    592a:	00 00 

0000592c <.Loc.578.1>:
  return spip->regs->rxbuf;
}
    592c:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    5930:	19 16       	popm.a	#2,	r10	;20-bit words
    5932:	10 01       	reta			;

00005934 <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    5934:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005938 <.LVL2>:
    5938:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

0000593c <.Loc.82.1>:
}
    593c:	10 01       	reta			;

0000593e <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    593e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005940 <.LCFI0>:

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5940:	8a 01 24 16 	mova	#71204,	r10	;0x11624
    5944:	cc 0a       	mova	r10,	r12	;
    5946:	b0 13 f6 4e 	calla	#20214		;0x04ef6

0000594a <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    594a:	00 18 fa 40 	movx.a	#1600,	16(r10)	;0x00640, 0x00010
    594e:	40 06 10 00 

00005952 <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5952:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    5956:	20 00 

00005958 <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    5958:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

0000595c <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    595c:	fa 40 13 00 	mov.b	#19,	50(r10)	;#0x0013, 0x0032
    5960:	32 00 

00005962 <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    5962:	fa 40 12 00 	mov.b	#18,	51(r10)	;#0x0012, 0x0033
    5966:	33 00 

00005968 <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    5968:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    596c:	26 00 

0000596e <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    596e:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005972 <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    5972:	0a 16       	popm.a	#1,	r10	;20-bit words
    5974:	10 01       	reta			;

00005976 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    5976:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005978 <.LCFI1>:
    5978:	ca 0c       	mova	r12,	r10	;

0000597a <.Loc.479.1>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    597a:	9c 01 24 16 	cmpa	#71204,	r12	;0x11624
    597e:	52 20       	jnz	$+166    	;abs 0x5a24

00005980 <.Loc.481.1>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    5980:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5984:	40 06 

00005986 <.Loc.483.1>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    5986:	3c 0c 02 00 	mova	2(r12),	r12	;

0000598a <.LVL8>:
    598a:	2e 4c       	mov	@r12,	r14	;
    598c:	1f 4c 02 00 	mov	2(r12),	r15	;
    5990:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5994:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5998:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    599c:	40 18 82 4c 	movx.w	r12,	&0x00646;
    59a0:	46 06 

000059a2 <.Loc.485.1>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    59a2:	40 18 b2 40 	movx.w	#192,	&0x00642;0x000c0
    59a6:	c0 00 42 06 

000059aa <.Loc.490.1>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
        | MSP430X_I2CB0_UCSSEL;
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    59aa:	40 18 b2 40 	movx.w	#3968,	&0x00640;0x00f80
    59ae:	80 0f 40 06 

000059b2 <.Loc.492.1>:
  #endif
      if (I2CDB0.regs->statw & BIT4) {
    59b2:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    59b6:	40 18 bc b0 	bitx.w	#16,	8(r12)	;0x00010
    59ba:	10 00 08 00 
    59be:	2b 24       	jz	$+88     	;abs 0x5a16

000059c0 <.Loc.494.1>:
        /* Disable again */
        UCB0CTLW0 |= 0x01;
    59c0:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    59c4:	40 06 

000059c6 <.Loc.496.1>:
        /* Set the SCL pin as an output */
        P1SEL1 &= ~0x80;
    59c6:	40 18 f2 f0 	andx.b	#127,	&0x0020c;0x0007f
    59ca:	7f 00 0c 02 

000059ce <.Loc.497.1>:
        P1DIR |= 0x80;
    59ce:	c0 1f f2 d0 	bisx.b	#-128,	&0x00204;0xfff80
    59d2:	80 ff 04 02 

000059d6 <.Loc.498.1>:
        P1REN &= ~0x80;
    59d6:	40 18 f2 f0 	andx.b	#127,	&0x00206;0x0007f
    59da:	7f 00 06 02 

000059de <.LVL10>:
    59de:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a

000059e2 <.L7>:
        /* Toggle it 10 times */
        for (int i = 0 ; i < 10; i++) {
          P1OUT &= ~0x80;
    59e2:	40 18 f2 f0 	andx.b	#127,	&0x00202;0x0007f
    59e6:	7f 00 02 02 

000059ea <.Loc.502.1>:
          P1OUT |= 0x80;
    59ea:	c0 1f f2 d0 	bisx.b	#-128,	&0x00202;0xfff80
    59ee:	80 ff 02 02 

000059f2 <.LVL12>:
    59f2:	3c 53       	add	#-1,	r12	;r3 As==11

000059f4 <.LVL13>:
        for (int i = 0 ; i < 10; i++) {
    59f4:	0c 93       	cmp	#0,	r12	;r3 As==00
    59f6:	f5 23       	jnz	$-20     	;abs 0x59e2

000059f8 <.LBE53>:
        }
        /* Reset it to I2C mode */
        P1DIR &= ~0x80;
    59f8:	40 18 f2 f0 	andx.b	#127,	&0x00204;0x0007f
    59fc:	7f 00 04 02 

00005a00 <.Loc.506.1>:
        P1SEL1 |= 0x80;
    5a00:	c0 1f f2 d0 	bisx.b	#-128,	&0x0020c;0xfff80
    5a04:	80 ff 0c 02 

00005a08 <.Loc.507.1>:
        P1REN |= 0x80;
    5a08:	c0 1f f2 d0 	bisx.b	#-128,	&0x00206;0xfff80
    5a0c:	80 ff 06 02 

00005a10 <.Loc.509.1>:
        /* Re-enable the peripheral */
        UCB0CTLW0 &= ~0x01;
    5a10:	40 18 92 c3 	bicx.w	#1,	&0x00640;r3 As==01
    5a14:	40 06 

00005a16 <.L6>:
      }
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    5a16:	40 18 b2 40 	movx.w	#184,	&0x0066a;0x000b8
    5a1a:	b8 00 6a 06 

00005a1e <.Loc.512.1>:
      UCB0IFG = 0;
    5a1e:	40 18 82 43 	movx.w	#0,	&0x0066c;r3 As==00
    5a22:	6c 06 

00005a24 <.L4>:
      }
  #endif
    }
#endif

}
    5a24:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a26:	10 01       	reta			;

00005a28 <i2cMSP430XStartReceiveToRegI>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    5a28:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005a2a <.LCFI3>:
    5a2a:	06 14       	pushm.a	#1,	r6	;20-bit words

00005a2c <.LCFI4>:
    5a2c:	04 14       	pushm.a	#1,	r4	;20-bit words

00005a2e <.LCFI5>:
    5a2e:	ca 0c       	mova	r12,	r10	;
    5a30:	49 4d       	mov.b	r13,	r9	;
    5a32:	c6 0e       	mova	r14,	r6	;
    5a34:	c8 0f       	mova	r15,	r8	;
    5a36:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005a3a <.Loc.680.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5a3a:	9e 00 00 00 	cmpa	#0,	r14	;
    5a3e:	04 20       	jnz	$+10     	;abs 0x5a48

00005a40 <.Loc.680.1>:
    5a40:	8c 01 b0 04 	mova	#66736,	r12	;0x104b0

00005a44 <.LVL20>:
    5a44:	b0 13 3e 46 	calla	#17982		;0x0463e

00005a48 <.L16>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5a48:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5a4a:	04 34       	jge	$+10     	;abs 0x5a54

00005a4c <.Loc.684.1>:
    5a4c:	8c 01 b0 04 	mova	#66736,	r12	;0x104b0
    5a50:	b0 13 3e 46 	calla	#17982		;0x0463e

00005a54 <.L17>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5a54:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005a58 <.Loc.690.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5a58:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005a5c <.Loc.692.1>:
  
  i2cp->buffer = regp;
    5a5c:	7a 08 08 00 	mova	r8,	8(r10)	;

00005a60 <.Loc.695.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5a60:	96 00 01 00 	cmpa	#1,	r6	;
    5a64:	1b 20       	jnz	$+56     	;abs 0x5a9c

00005a66 <.Loc.697.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = regp;
    5a66:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005a6a <.Loc.698.1>:
    i2cp->req.size = 0;
    5a6a:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005a6e <.Loc.700.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5a6e:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5a72:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5a76:	00 00 

00005a78 <.Loc.702.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5a78:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005a7c <.L19>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5a7c:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5a80:	fd 23       	jnz	$-4      	;abs 0x5a7c

00005a82 <.Loc.705.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    5a82:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005a86 <.Loc.707.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
    5a86:	94 00 00 00 	cmpa	#0,	r4	;
    5a8a:	04 24       	jz	$+10     	;abs 0x5a94

00005a8c <.Loc.708.1>:
      callback(i2cp, regp, 1);
    5a8c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5a8e:	cd 08       	mova	r8,	r13	;
    5a90:	cc 0a       	mova	r10,	r12	;
    5a92:	44 13       	calla	r4		;

00005a94 <.L15>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5a94:	04 16       	popm.a	#1,	r4	;20-bit words
    5a96:	06 16       	popm.a	#1,	r6	;20-bit words
    5a98:	28 16       	popm.a	#3,	r10	;20-bit words
    5a9a:	10 01       	reta			;

00005a9c <.L18>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5a9c:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5aa0:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5aa4:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

00005aa8 <.Loc.713.1>:
    i2cp->req.dest_addr = regp;
    5aa8:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005aac <.Loc.714.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5aac:	40 18 06 46 	movx.w	r6,	r6	;

00005ab0 <.LVL25>:
    5ab0:	36 53       	add	#-1,	r6	;r3 As==11
    5ab2:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

00005ab6 <.Loc.715.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5ab6:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

00005aba <.Loc.716.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5aba:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    5abe:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005ac2 <.Loc.718.1>:
    i2cp->callback = callback;
    5ac2:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

00005ac6 <.Loc.720.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5ac6:	00 18 fa 40 	movx.a	#24202,	38(r10)	;0x05e8a, 0x00026
    5aca:	8a 5e 26 00 

00005ace <.Loc.721.1>:
    i2cp->req.callback.args = i2cp;
    5ace:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005ad2 <.Loc.723.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5ad2:	c8 0a       	mova	r10,	r8	;

00005ad4 <.LVL26>:
    5ad4:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5ad8:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5adc:	9c 00 00 00 	cmpa	#0,	r12	;
    5ae0:	04 24       	jz	$+10     	;abs 0x5aea

00005ae2 <.Loc.723.1>:
    5ae2:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5ae6:	00 00 
    5ae8:	03 20       	jnz	$+8      	;abs 0x5af0

00005aea <.L21>:
      dmaAcquireI(&(i2cp->dma));
    5aea:	cc 08       	mova	r8,	r12	;
    5aec:	b0 13 be 54 	calla	#21694		;0x054be

00005af0 <.L22>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5af0:	cd 0a       	mova	r10,	r13	;
    5af2:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5af6:	cc 08       	mova	r8,	r12	;
    5af8:	b0 13 84 55 	calla	#21892		;0x05584

00005afc <.LVL28>:
    i2cp->regs->i2csa = addr;
    5afc:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5b00:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005b04 <.Loc.730.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5b04:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5b08:	00 00 

00005b0a <.Loc.731.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5b0a:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005b0e <.Loc.733.1>:
}
    5b0e:	80 00 94 5a 	mova	#23188,	r0	;0x05a94

00005b12 <i2cMSP430XStartReceiveI>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    5b12:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005b14 <.LCFI6>:
    5b14:	06 14       	pushm.a	#1,	r6	;20-bit words

00005b16 <.LCFI7>:
    5b16:	04 14       	pushm.a	#1,	r4	;20-bit words

00005b18 <.LCFI8>:
    5b18:	ca 0c       	mova	r12,	r10	;
    5b1a:	49 4d       	mov.b	r13,	r9	;
    5b1c:	c6 0e       	mova	r14,	r6	;
    5b1e:	c8 0f       	mova	r15,	r8	;
    5b20:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005b24 <.Loc.740.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5b24:	9e 00 00 00 	cmpa	#0,	r14	;
    5b28:	04 20       	jnz	$+10     	;abs 0x5b32

00005b2a <.Loc.740.1>:
    5b2a:	8c 01 98 04 	mova	#66712,	r12	;0x10498

00005b2e <.LVL30>:
    5b2e:	b0 13 3e 46 	calla	#17982		;0x0463e

00005b32 <.L31>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5b32:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5b34:	04 34       	jge	$+10     	;abs 0x5b3e

00005b36 <.Loc.744.1>:
    5b36:	8c 01 98 04 	mova	#66712,	r12	;0x10498
    5b3a:	b0 13 3e 46 	calla	#17982		;0x0463e

00005b3e <.L32>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5b3e:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005b42 <.Loc.750.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5b42:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005b46 <.Loc.752.1>:
  
  i2cp->buffer = rxbuf;
    5b46:	7a 08 08 00 	mova	r8,	8(r10)	;

00005b4a <.Loc.755.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5b4a:	96 00 01 00 	cmpa	#1,	r6	;
    5b4e:	18 20       	jnz	$+50     	;abs 0x5b80

00005b50 <.Loc.757.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    5b50:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005b54 <.Loc.758.1>:
    i2cp->req.size = 0;
    5b54:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005b58 <.Loc.760.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5b58:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5b5c:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5b60:	00 00 

00005b62 <.Loc.762.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5b62:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005b66 <.L34>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5b66:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5b6a:	fd 23       	jnz	$-4      	;abs 0x5b66

00005b6c <.Loc.765.1>:
    i2cp->regs->ctlw0 |= UCTXSTP;
    5b6c:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005b70 <.Loc.769.1>:
    /* Call the callback immediately as well */
    if (callback != NULL)
      chSysUnlockFromISR();
      callback(i2cp, rxbuf, 1);
    5b70:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5b72:	cd 08       	mova	r8,	r13	;
    5b74:	cc 0a       	mova	r10,	r12	;
    5b76:	44 13       	calla	r4		;

00005b78 <.L30>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5b78:	04 16       	popm.a	#1,	r4	;20-bit words
    5b7a:	06 16       	popm.a	#1,	r6	;20-bit words
    5b7c:	28 16       	popm.a	#3,	r10	;20-bit words
    5b7e:	10 01       	reta			;

00005b80 <.L33>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5b80:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5b84:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5b88:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

00005b8c <.Loc.775.1>:
    i2cp->req.dest_addr = rxbuf;
    5b8c:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005b90 <.Loc.776.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5b90:	40 18 06 46 	movx.w	r6,	r6	;

00005b94 <.LVL35>:
    5b94:	36 53       	add	#-1,	r6	;r3 As==11
    5b96:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

00005b9a <.Loc.777.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    5b9a:	ba 40 00 0c 	mov	#3072,	30(r10)	;#0x0c00, 0x001e
    5b9e:	1e 00 

00005ba0 <.Loc.778.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5ba0:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    5ba4:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005ba8 <.Loc.780.1>:
    i2cp->callback = callback;
    5ba8:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

00005bac <.Loc.782.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5bac:	00 18 fa 40 	movx.a	#24202,	38(r10)	;0x05e8a, 0x00026
    5bb0:	8a 5e 26 00 

00005bb4 <.Loc.783.1>:
    i2cp->req.callback.args = i2cp;
    5bb4:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005bb8 <.Loc.785.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5bb8:	c8 0a       	mova	r10,	r8	;

00005bba <.LVL36>:
    5bba:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5bbe:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5bc2:	9c 00 00 00 	cmpa	#0,	r12	;
    5bc6:	04 24       	jz	$+10     	;abs 0x5bd0

00005bc8 <.Loc.785.1>:
    5bc8:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5bcc:	00 00 
    5bce:	03 20       	jnz	$+8      	;abs 0x5bd6

00005bd0 <.L36>:
      dmaAcquireI(&(i2cp->dma));
    5bd0:	cc 08       	mova	r8,	r12	;
    5bd2:	b0 13 be 54 	calla	#21694		;0x054be

00005bd6 <.L37>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5bd6:	cd 0a       	mova	r10,	r13	;
    5bd8:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5bdc:	cc 08       	mova	r8,	r12	;
    5bde:	b0 13 84 55 	calla	#21892		;0x05584

00005be2 <.LVL38>:
    i2cp->regs->i2csa = addr;
    5be2:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5be6:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005bea <.Loc.792.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5bea:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5bee:	00 00 

00005bf0 <.Loc.793.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5bf0:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005bf4 <.Loc.795.1>:
}
    5bf4:	80 00 78 5b 	mova	#23416,	r0	;0x05b78

00005bf8 <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5bf8:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005bfa <.LCFI9>:
    5bfa:	06 14       	pushm.a	#1,	r6	;20-bit words

00005bfc <.LCFI10>:
    5bfc:	c6 0c       	mova	r12,	r6	;
    5bfe:	49 4d       	mov.b	r13,	r9	;
    5c00:	ca 0e       	mova	r14,	r10	;
    5c02:	c8 0f       	mova	r15,	r8	;

00005c04 <.Loc.802.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    5c04:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    5c08:	04 24       	jz	$+10     	;abs 0x5c12

00005c0a <.Loc.802.1>:
    5c0a:	8c 01 7c 04 	mova	#66684,	r12	;0x1047c

00005c0e <.LVL40>:
    5c0e:	b0 13 3e 46 	calla	#17982		;0x0463e

00005c12 <.L43>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5c12:	9a 00 00 00 	cmpa	#0,	r10	;
    5c16:	04 20       	jnz	$+10     	;abs 0x5c20

00005c18 <.Loc.804.1>:
    5c18:	8c 01 7c 04 	mova	#66684,	r12	;0x1047c
    5c1c:	b0 13 3e 46 	calla	#17982		;0x0463e

00005c20 <.L44>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5c20:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5c22:	04 34       	jge	$+10     	;abs 0x5c2c

00005c24 <.Loc.809.1>:
    5c24:	8c 01 7c 04 	mova	#66684,	r12	;0x1047c
    5c28:	b0 13 3e 46 	calla	#17982		;0x0463e

00005c2c <.L45>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5c2c:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005c30 <.Loc.815.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    5c30:	f6 40 03 00 	mov.b	#3,	0(r6)	;
    5c34:	00 00 

00005c36 <.Loc.817.1>:
  
  i2cp->buffer = txbuf;
    5c36:	76 08 08 00 	mova	r8,	8(r6)	;

00005c3a <.Loc.820.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    5c3a:	cc 0a       	mova	r10,	r12	;
    5c3c:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    5c40:	e8 0c       	adda	r12,	r8	;

00005c42 <.LVL44>:
    5c42:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005c46 <.Loc.821.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5c46:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5c4a:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5c4e:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005c52 <.Loc.822.1>:
  i2cp->req.size = n;
    5c52:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5c56:	1c 00 

00005c58 <.Loc.823.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    5c58:	b6 40 00 02 	mov	#512,	30(r6)	;#0x0200, 0x001e
    5c5c:	1e 00 

00005c5e <.Loc.824.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5c5e:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5c62:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005c66 <.Loc.826.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5c66:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5c6a:	14 00 0c 00 

00005c6e <.Loc.828.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5c6e:	00 18 f6 40 	movx.a	#22836,	38(r6)	;0x05934, 0x00026
    5c72:	34 59 26 00 

00005c76 <.Loc.830.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    5c76:	ca 06       	mova	r6,	r10	;

00005c78 <.LVL45>:
    5c78:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5c7c:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5c80:	9c 00 00 00 	cmpa	#0,	r12	;
    5c84:	04 24       	jz	$+10     	;abs 0x5c8e

00005c86 <.Loc.830.1>:
    5c86:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5c8a:	00 00 
    5c8c:	03 20       	jnz	$+8      	;abs 0x5c94

00005c8e <.L46>:
    dmaAcquireI(&(i2cp->dma));
    5c8e:	cc 0a       	mova	r10,	r12	;
    5c90:	b0 13 be 54 	calla	#21694		;0x054be

00005c94 <.L47>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5c94:	cd 06       	mova	r6,	r13	;
    5c96:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5c9a:	cc 0a       	mova	r10,	r12	;
    5c9c:	b0 13 84 55 	calla	#21892		;0x05584

00005ca0 <.LVL47>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    5ca0:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5ca4:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005ca8 <.Loc.837.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    5ca8:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    5cac:	00 00 

00005cae <.Loc.840.1>:
  /* IFG is set automatically after START */
  
}
    5cae:	06 16       	popm.a	#1,	r6	;20-bit words
    5cb0:	28 16       	popm.a	#3,	r10	;20-bit words
    5cb2:	10 01       	reta			;

00005cb4 <i2cMSP430XContinueTransmitMemsetI>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    5cb4:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005cb6 <.LCFI15>:
    5cb6:	06 14       	pushm.a	#1,	r6	;20-bit words

00005cb8 <.LCFI16>:
    5cb8:	c6 0c       	mova	r12,	r6	;
    5cba:	49 4d       	mov.b	r13,	r9	;
    5cbc:	ca 0e       	mova	r14,	r10	;
    5cbe:	c8 0f       	mova	r15,	r8	;

00005cc0 <.Loc.928.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5cc0:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    5cc4:	00 00 
    5cc6:	04 24       	jz	$+10     	;abs 0x5cd0

00005cc8 <.Loc.928.1>:
    5cc8:	8c 01 22 04 	mova	#66594,	r12	;0x10422

00005ccc <.LVL66>:
    5ccc:	b0 13 3e 46 	calla	#17982		;0x0463e

00005cd0 <.L76>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5cd0:	9a 00 00 00 	cmpa	#0,	r10	;
    5cd4:	04 20       	jnz	$+10     	;abs 0x5cde

00005cd6 <.Loc.930.1>:
    5cd6:	8c 01 22 04 	mova	#66594,	r12	;0x10422
    5cda:	b0 13 3e 46 	calla	#17982		;0x0463e

00005cde <.L77>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5cde:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5ce0:	04 34       	jge	$+10     	;abs 0x5cea

00005ce2 <.Loc.935.1>:
    5ce2:	8c 01 22 04 	mova	#66594,	r12	;0x10422
    5ce6:	b0 13 3e 46 	calla	#17982		;0x0463e

00005cea <.L78>:
#endif
  
  i2cp->buffer = value;
    5cea:	76 08 08 00 	mova	r8,	8(r6)	;

00005cee <.Loc.941.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    5cee:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005cf2 <.Loc.942.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5cf2:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5cf6:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5cfa:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005cfe <.Loc.943.1>:
  i2cp->req.size = n;
    5cfe:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5d02:	1c 00 

00005d04 <.Loc.944.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5d04:	86 43 1e 00 	mov	#0,	30(r6)	;r3 As==00, 0x001e

00005d08 <.Loc.945.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5d08:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5d0c:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005d10 <.Loc.947.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5d10:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5d14:	14 00 0c 00 

00005d18 <.Loc.949.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5d18:	00 18 f6 40 	movx.a	#22836,	38(r6)	;0x05934, 0x00026
    5d1c:	34 59 26 00 

00005d20 <.Loc.951.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5d20:	ca 06       	mova	r6,	r10	;

00005d22 <.LVL70>:
    5d22:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5d26:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5d2a:	9c 00 00 00 	cmpa	#0,	r12	;
    5d2e:	04 24       	jz	$+10     	;abs 0x5d38

00005d30 <.Loc.951.1>:
    5d30:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5d34:	00 00 
    5d36:	04 20       	jnz	$+10     	;abs 0x5d40

00005d38 <.L79>:
    5d38:	8c 01 22 04 	mova	#66594,	r12	;0x10422
    5d3c:	b0 13 3e 46 	calla	#17982		;0x0463e

00005d40 <.L80>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5d40:	cd 06       	mova	r6,	r13	;
    5d42:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5d46:	cc 0a       	mova	r10,	r12	;
    5d48:	b0 13 84 55 	calla	#21892		;0x05584

00005d4c <.LVL72>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5d4c:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5d50:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005d54 <.Loc.957.1>:
  
}
    5d54:	06 16       	popm.a	#1,	r6	;20-bit words
    5d56:	28 16       	popm.a	#3,	r10	;20-bit words
    5d58:	10 01       	reta			;

00005d5a <i2cMSP430XContinueTransmitI>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5d5a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005d5c <.LCFI17>:
    5d5c:	06 14       	pushm.a	#1,	r6	;20-bit words

00005d5e <.LCFI18>:
    5d5e:	c6 0c       	mova	r12,	r6	;
    5d60:	49 4d       	mov.b	r13,	r9	;
    5d62:	ca 0e       	mova	r14,	r10	;
    5d64:	c8 0f       	mova	r15,	r8	;

00005d66 <.Loc.964.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5d66:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    5d6a:	00 00 
    5d6c:	04 24       	jz	$+10     	;abs 0x5d76

00005d6e <.Loc.964.1>:
    5d6e:	8c 01 06 04 	mova	#66566,	r12	;0x10406

00005d72 <.LVL74>:
    5d72:	b0 13 3e 46 	calla	#17982		;0x0463e

00005d76 <.L85>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5d76:	9a 00 00 00 	cmpa	#0,	r10	;
    5d7a:	04 20       	jnz	$+10     	;abs 0x5d84

00005d7c <.Loc.966.1>:
    5d7c:	8c 01 06 04 	mova	#66566,	r12	;0x10406
    5d80:	b0 13 3e 46 	calla	#17982		;0x0463e

00005d84 <.L86>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5d84:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5d86:	04 34       	jge	$+10     	;abs 0x5d90

00005d88 <.Loc.971.1>:
    5d88:	8c 01 06 04 	mova	#66566,	r12	;0x10406
    5d8c:	b0 13 3e 46 	calla	#17982		;0x0463e

00005d90 <.L87>:
#endif
  
  i2cp->buffer = txbuf;
    5d90:	76 08 08 00 	mova	r8,	8(r6)	;

00005d94 <.Loc.977.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    5d94:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005d98 <.Loc.978.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5d98:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5d9c:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5da0:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005da4 <.Loc.979.1>:
  i2cp->req.size = n;
    5da4:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5da8:	1c 00 

00005daa <.Loc.980.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    5daa:	b6 40 00 03 	mov	#768,	30(r6)	;#0x0300, 0x001e
    5dae:	1e 00 

00005db0 <.Loc.981.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5db0:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5db4:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005db8 <.Loc.983.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5db8:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5dbc:	14 00 0c 00 

00005dc0 <.Loc.985.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5dc0:	00 18 f6 40 	movx.a	#22836,	38(r6)	;0x05934, 0x00026
    5dc4:	34 59 26 00 

00005dc8 <.Loc.987.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5dc8:	ca 06       	mova	r6,	r10	;

00005dca <.LVL78>:
    5dca:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5dce:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5dd2:	9c 00 00 00 	cmpa	#0,	r12	;
    5dd6:	04 24       	jz	$+10     	;abs 0x5de0

00005dd8 <.Loc.987.1>:
    5dd8:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5ddc:	00 00 
    5dde:	04 20       	jnz	$+10     	;abs 0x5de8

00005de0 <.L88>:
    5de0:	8c 01 06 04 	mova	#66566,	r12	;0x10406
    5de4:	b0 13 3e 46 	calla	#17982		;0x0463e

00005de8 <.L89>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5de8:	cd 06       	mova	r6,	r13	;
    5dea:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5dee:	cc 0a       	mova	r10,	r12	;
    5df0:	b0 13 84 55 	calla	#21892		;0x05584

00005df4 <.LVL80>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5df4:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5df8:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005dfc <.Loc.993.1>:
  
}
    5dfc:	06 16       	popm.a	#1,	r6	;20-bit words
    5dfe:	28 16       	popm.a	#3,	r10	;20-bit words
    5e00:	10 01       	reta			;

00005e02 <i2cMSP430XEndTransferI>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    5e02:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005e04 <.LCFI19>:
    5e04:	b1 00 02 00 	suba	#2,	r1	;

00005e08 <.LCFI20>:
    5e08:	ca 0c       	mova	r12,	r10	;

00005e0a <.Loc.999.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
    5e0a:	6c 4c       	mov.b	@r12,	r12	;

00005e0c <.LVL82>:
    5e0c:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    5e10:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5e12:	4d 9c       	cmp.b	r12,	r13	;
    5e14:	04 2c       	jc	$+10     	;abs 0x5e1e

00005e16 <.Loc.999.1>:
    5e16:	8c 01 ef 03 	mova	#66543,	r12	;0x103ef
    5e1a:	b0 13 3e 46 	calla	#17982		;0x0463e

00005e1e <.L94>:
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    5e1e:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5e22:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00005e26 <.Loc.1005.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    5e26:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    5e2a:	2a 20       	jnz	$+86     	;abs 0x5e80

00005e2c <.L107>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
    
    /* Wait for last RX byte */
    while (!(i2cp->regs->ifg & UCRXIFG0));
    5e2c:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    5e30:	2c 00 
    5e32:	fc 27       	jz	$-6      	;abs 0x5e2c
    5e34:	3e 0a 18 00 	mova	24(r10),r14	;0x00018

00005e38 <.Loc.1015.1>:
    
    if (i2cp->req.addr_mode) {
    5e38:	8a 93 1e 00 	cmp	#0,	30(r10)	;r3 As==00, 0x001e
    5e3c:	1b 24       	jz	$+56     	;abs 0x5e74

00005e3e <.Loc.1016.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    5e3e:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    5e42:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    5e46:	1c 00 
    5e48:	ec 0e       	adda	r14,	r12	;
    5e4a:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00005e4e <.L98>:
    }
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
    
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    5e4e:	3c 0a 10 00 	mova	16(r10),r12	;0x00010

00005e52 <.L99>:
    5e52:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    5e56:	fd 23       	jnz	$-4      	;abs 0x5e52

00005e58 <.Loc.1024.1>:
      
    if (i2cp->regs->ifg & UCRXIFG0) {
    5e58:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    5e5c:	2c 00 
    5e5e:	04 24       	jz	$+10     	;abs 0x5e68

00005e60 <.LBB68>:
      volatile uint8_t throwaway;
      throwaway = i2cp->regs->rxbuf;
    5e60:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    5e64:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00005e68 <.L101>:
  }
  else {
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
  }
  
  i2cp->state = I2C_READY;
    5e68:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005e6c <.Loc.1034.1>:
}
    5e6c:	a1 00 02 00 	adda	#2,	r1	;
    5e70:	0a 16       	popm.a	#1,	r10	;20-bit words
    5e72:	10 01       	reta			;

00005e74 <.L97>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    5e74:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    5e78:	ce 4c 00 00 	mov.b	r12,	0(r14)	;
    5e7c:	80 00 4e 5e 	mova	#24142,	r0	;0x05e4e

00005e80 <.L104>:
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    5e80:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    5e84:	fd 23       	jnz	$-4      	;abs 0x5e80
    5e86:	80 00 68 5e 	mova	#24168,	r0	;0x05e68

00005e8a <rx_async_callback>:
void rx_async_callback(void * args) {
    5e8a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005e8c <.LCFI21>:
    5e8c:	08 14       	pushm.a	#1,	r8	;20-bit words

00005e8e <.LCFI22>:
    5e8e:	ca 0c       	mova	r12,	r10	;

00005e90 <.LVL85>:
  if (NULL != i2cp->callback) {
    5e90:	38 0c 0c 00 	mova	12(r12),r8	;0x0000c
    5e94:	98 00 00 00 	cmpa	#0,	r8	;
    5e98:	08 24       	jz	$+18     	;abs 0x5eaa

00005e9a <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    5e9a:	1e 4c 1c 00 	mov	28(r12),r14	;0x0001c
    5e9e:	3d 0c 08 00 	mova	8(r12),	r13	;
    5ea2:	48 13       	calla	r8		;

00005ea4 <.L109>:
}
    5ea4:	08 16       	popm.a	#1,	r8	;20-bit words
    5ea6:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ea8:	10 01       	reta			;

00005eaa <.L110>:
    i2cMSP430XEndTransferI(i2cp);
    5eaa:	b0 13 02 5e 	calla	#24066		;0x05e02

00005eae <.LVL87>:
}
    5eae:	80 00 a4 5e 	mova	#24228,	r0	;0x05ea4

00005eb2 <rx_cb>:
static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
}

static void rx_cb(void * arg){
    5eb2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005eb4 <.LCFI0>:
    5eb4:	ca 0c       	mova	r12,	r10	;

00005eb6 <.LVL1>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5eb6:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    5eba:	3e 0c 04 00 	mova	4(r12),	r14	;
    5ebe:	3e 0e 08 00 	mova	8(r14),	r14	;
    5ec2:	9e 00 00 00 	cmpa	#0,	r14	;
    5ec6:	01 24       	jz	$+4      	;abs 0x5eca

00005ec8 <.Loc.204.1>:
    5ec8:	4e 13       	calla	r14		;

00005eca <.L2>:
    5eca:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    5ece:	06 20       	jnz	$+14     	;abs 0x5edc

00005ed0 <.Loc.204.1>:
    5ed0:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    5ed4:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00005ed8 <.LBB35>:
  uartp->regs->ie |= UCRXIE;
    5ed8:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005edc <.L3>:
    5edc:	4d 43       	clr.b	r13		;
    5ede:	cc 0a       	mova	r10,	r12	;
    5ee0:	ac 00 0a 00 	adda	#10,	r12	;0x0000a

00005ee4 <.LVL5>:
    5ee4:	b0 13 6e 48 	calla	#18542		;0x0486e

00005ee8 <.LBE37>:
}
    5ee8:	0a 16       	popm.a	#1,	r10	;20-bit words
    5eea:	10 01       	reta			;

00005eec <UCBRS>:
  if (frac < 529)
    5eec:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    5ef0:	0d 9c       	cmp	r12,	r13	;
    5ef2:	8b 2c       	jc	$+280    	;abs 0x600a

00005ef4 <.Loc.84.1>:
  else if (frac < 715)
    5ef4:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    5ef8:	0d 9c       	cmp	r12,	r13	;
    5efa:	8a 2c       	jc	$+278    	;abs 0x6010

00005efc <.Loc.86.1>:
  else if (frac < 835)
    5efc:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    5f00:	0d 9c       	cmp	r12,	r13	;
    5f02:	89 2c       	jc	$+276    	;abs 0x6016

00005f04 <.Loc.88.1>:
  else if (frac < 1001)
    5f04:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    5f08:	0d 9c       	cmp	r12,	r13	;
    5f0a:	88 2c       	jc	$+274    	;abs 0x601c

00005f0c <.Loc.90.1>:
  else if (frac < 1252)
    5f0c:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    5f10:	0d 9c       	cmp	r12,	r13	;
    5f12:	87 2c       	jc	$+272    	;abs 0x6022

00005f14 <.Loc.92.1>:
  else if (frac < 1430)
    5f14:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    5f18:	0d 9c       	cmp	r12,	r13	;
    5f1a:	86 2c       	jc	$+270    	;abs 0x6028

00005f1c <.Loc.94.1>:
  else if (frac < 1670)
    5f1c:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    5f20:	0d 9c       	cmp	r12,	r13	;
    5f22:	86 2c       	jc	$+270    	;abs 0x6030

00005f24 <.Loc.96.1>:
  else if (frac < 2147)
    5f24:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    5f28:	0d 9c       	cmp	r12,	r13	;
    5f2a:	86 2c       	jc	$+270    	;abs 0x6038

00005f2c <.Loc.98.1>:
  else if (frac < 2224)
    5f2c:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    5f30:	0d 9c       	cmp	r12,	r13	;
    5f32:	86 2c       	jc	$+270    	;abs 0x6040

00005f34 <.Loc.100.1>:
  else if (frac < 2503)
    5f34:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    5f38:	0d 9c       	cmp	r12,	r13	;
    5f3a:	86 2c       	jc	$+270    	;abs 0x6048

00005f3c <.Loc.102.1>:
  else if (frac < 3000)
    5f3c:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    5f40:	0d 9c       	cmp	r12,	r13	;
    5f42:	86 2c       	jc	$+270    	;abs 0x6050

00005f44 <.LBB41>:
  else if (frac < 3335)
    5f44:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    5f48:	0d 9c       	cmp	r12,	r13	;
    5f4a:	86 2c       	jc	$+270    	;abs 0x6058

00005f4c <.Loc.106.1>:
  else if (frac < 3575)
    5f4c:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    5f50:	0d 9c       	cmp	r12,	r13	;
    5f52:	86 2c       	jc	$+270    	;abs 0x6060

00005f54 <.Loc.108.1>:
  else if (frac < 3753)
    5f54:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    5f58:	0d 9c       	cmp	r12,	r13	;
    5f5a:	86 2c       	jc	$+270    	;abs 0x6068

00005f5c <.Loc.110.1>:
  else if (frac < 4003)
    5f5c:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    5f60:	0d 9c       	cmp	r12,	r13	;
    5f62:	86 2c       	jc	$+270    	;abs 0x6070

00005f64 <.Loc.112.1>:
  else if (frac < 4286)
    5f64:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    5f68:	0d 9c       	cmp	r12,	r13	;
    5f6a:	86 2c       	jc	$+270    	;abs 0x6078

00005f6c <.Loc.114.1>:
  else if (frac < 4378)
    5f6c:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    5f70:	0d 9c       	cmp	r12,	r13	;
    5f72:	86 2c       	jc	$+270    	;abs 0x6080

00005f74 <.Loc.116.1>:
  else if (frac < 5002)
    5f74:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    5f78:	0d 9c       	cmp	r12,	r13	;
    5f7a:	86 2c       	jc	$+270    	;abs 0x6088

00005f7c <.Loc.118.1>:
  else if (frac < 5715)
    5f7c:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    5f80:	0d 9c       	cmp	r12,	r13	;
    5f82:	86 2c       	jc	$+270    	;abs 0x6090

00005f84 <.Loc.120.1>:
  else if (frac < 6003)
    5f84:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    5f88:	0d 9c       	cmp	r12,	r13	;
    5f8a:	86 2c       	jc	$+270    	;abs 0x6098

00005f8c <.Loc.122.1>:
  else if (frac < 6254)
    5f8c:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    5f90:	0d 9c       	cmp	r12,	r13	;
    5f92:	86 2c       	jc	$+270    	;abs 0x60a0

00005f94 <.Loc.124.1>:
  else if (frac < 6432)
    5f94:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    5f98:	0d 9c       	cmp	r12,	r13	;
    5f9a:	86 2c       	jc	$+270    	;abs 0x60a8

00005f9c <.Loc.126.1>:
  else if (frac < 6667)
    5f9c:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    5fa0:	0d 9c       	cmp	r12,	r13	;
    5fa2:	86 2c       	jc	$+270    	;abs 0x60b0

00005fa4 <.Loc.128.1>:
  else if (frac < 7001)
    5fa4:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    5fa8:	0d 9c       	cmp	r12,	r13	;
    5faa:	86 2c       	jc	$+270    	;abs 0x60b8

00005fac <.Loc.130.1>:
  else if (frac < 7147)
    5fac:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    5fb0:	0d 9c       	cmp	r12,	r13	;
    5fb2:	86 2c       	jc	$+270    	;abs 0x60c0

00005fb4 <.Loc.132.1>:
  else if (frac < 7503)
    5fb4:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    5fb8:	0d 9c       	cmp	r12,	r13	;
    5fba:	86 2c       	jc	$+270    	;abs 0x60c8

00005fbc <.Loc.134.1>:
  else if (frac < 7861)
    5fbc:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    5fc0:	0d 9c       	cmp	r12,	r13	;
    5fc2:	86 2c       	jc	$+270    	;abs 0x60d0

00005fc4 <.Loc.136.1>:
  else if (frac < 8004)
    5fc4:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    5fc8:	0d 9c       	cmp	r12,	r13	;
    5fca:	86 2c       	jc	$+270    	;abs 0x60d8

00005fcc <.Loc.138.1>:
  else if (frac < 8333)
    5fcc:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    5fd0:	0d 9c       	cmp	r12,	r13	;
    5fd2:	86 2c       	jc	$+270    	;abs 0x60e0

00005fd4 <.Loc.140.1>:
  else if (frac < 8464)
    5fd4:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    5fd8:	0d 9c       	cmp	r12,	r13	;
    5fda:	86 2c       	jc	$+270    	;abs 0x60e8

00005fdc <.Loc.142.1>:
  else if (frac < 8572)
    5fdc:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    5fe0:	0d 9c       	cmp	r12,	r13	;
    5fe2:	86 2c       	jc	$+270    	;abs 0x60f0

00005fe4 <.Loc.144.1>:
  else if (frac < 8751)
    5fe4:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    5fe8:	0d 9c       	cmp	r12,	r13	;
    5fea:	86 2c       	jc	$+270    	;abs 0x60f8

00005fec <.Loc.146.1>:
  else if (frac < 9004)
    5fec:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    5ff0:	0d 9c       	cmp	r12,	r13	;
    5ff2:	86 2c       	jc	$+270    	;abs 0x6100

00005ff4 <.Loc.148.1>:
  else if (frac < 9170)
    5ff4:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    5ff8:	0d 9c       	cmp	r12,	r13	;
    5ffa:	86 2c       	jc	$+270    	;abs 0x6108

00005ffc <.Loc.150.1>:
  else if (frac < 9288)
    5ffc:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    6000:	0d 9c       	cmp	r12,	r13	;
    6002:	86 2c       	jc	$+270    	;abs 0x6110

00006004 <.Loc.153.1>:
    return 0xFE;
    6004:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00006008 <.L8>:
}
    6008:	10 01       	reta			;

0000600a <.L9>:
    return 0x00;
    600a:	4c 43       	clr.b	r12		;

0000600c <.LVL11>:
    600c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006010 <.L10>:
    return 0x01;
    6010:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006012 <.LVL13>:
    6012:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006016 <.L11>:
    return 0x02;
    6016:	6c 43       	mov.b	#2,	r12	;r3 As==10

00006018 <.LVL15>:
    6018:	80 00 08 60 	mova	#24584,	r0	;0x06008

0000601c <.L12>:
    return 0x04;
    601c:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000601e <.LVL17>:
    601e:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006022 <.L13>:
    return 0x08;
    6022:	7c 42       	mov.b	#8,	r12	;r2 As==11

00006024 <.LVL19>:
    6024:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006028 <.L14>:
    return 0x10;
    6028:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000602c <.LVL21>:
    602c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006030 <.L15>:
    return 0x20;
    6030:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

00006034 <.LVL23>:
    6034:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006038 <.L16>:
    return 0x11;
    6038:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

0000603c <.LVL25>:
    603c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006040 <.L17>:
    return 0x21;
    6040:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

00006044 <.LVL27>:
    6044:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006048 <.L18>:
    return 0x22;
    6048:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

0000604c <.LVL29>:
    604c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006050 <.L19>:
    return 0x44;
    6050:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00006054 <.LVL31>:
    6054:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006058 <.L20>:
    return 0x25;
    6058:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

0000605c <.LVL33>:
    605c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006060 <.L21>:
    return 0x49;
    6060:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00006064 <.LVL35>:
    6064:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006068 <.L22>:
    return 0x4A;
    6068:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

0000606c <.LVL37>:
    606c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006070 <.L23>:
    return 0x52;
    6070:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00006074 <.LVL39>:
    6074:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006078 <.L24>:
    return 0x92;
    6078:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

0000607c <.LVL41>:
    607c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006080 <.L25>:
    return 0x53;
    6080:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00006084 <.LVL43>:
    6084:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006088 <.L26>:
    return 0x55;
    6088:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

0000608c <.LVL45>:
    608c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006090 <.L27>:
    return 0xAA;
    6090:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00006094 <.LVL47>:
    6094:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006098 <.L28>:
    return 0x6B;
    6098:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

0000609c <.LVL49>:
    609c:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060a0 <.L29>:
    return 0xAD;
    60a0:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

000060a4 <.LVL51>:
    60a4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060a8 <.L30>:
    return 0xB5;
    60a8:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

000060ac <.LVL53>:
    60ac:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060b0 <.L31>:
    return 0xB6;
    60b0:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

000060b4 <.LVL55>:
    60b4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060b8 <.L32>:
    return 0xD6;
    60b8:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

000060bc <.LVL57>:
    60bc:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060c0 <.L33>:
    return 0xB7;
    60c0:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

000060c4 <.LVL59>:
    60c4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060c8 <.L34>:
    return 0xBB;
    60c8:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

000060cc <.LVL61>:
    60cc:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060d0 <.L35>:
    return 0xDD;
    60d0:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

000060d4 <.LVL63>:
    60d4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060d8 <.L36>:
    return 0xED;
    60d8:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

000060dc <.LVL65>:
    60dc:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060e0 <.L37>:
    return 0xEE;
    60e0:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

000060e4 <.LVL67>:
    60e4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060e8 <.L38>:
    return 0xBF;
    60e8:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

000060ec <.LVL69>:
    60ec:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060f0 <.L39>:
    return 0xDF;
    60f0:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

000060f4 <.LVL71>:
    60f4:	80 00 08 60 	mova	#24584,	r0	;0x06008

000060f8 <.L40>:
    return 0xEF;
    60f8:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

000060fc <.LVL73>:
    60fc:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006100 <.L41>:
    return 0xF7;
    6100:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00006104 <.LVL75>:
    6104:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006108 <.L42>:
    return 0xFB;
    6108:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

0000610c <.LVL77>:
    610c:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006110 <.L43>:
    return 0xFD;
    6110:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

00006114 <.LVL79>:
    6114:	80 00 08 60 	mova	#24584,	r0	;0x06008

00006118 <tx_cb>:
static void tx_cb(void * arg) {
    6118:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000611a <.LCFI1>:
    611a:	ca 0c       	mova	r12,	r10	;

0000611c <.LVL81>:
  _uart_tx1_isr_code(uartp);
    611c:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    6120:	3e 0c 04 00 	mova	4(r12),	r14	;
    6124:	0e 0e       	mova	@r14,	r14	;
    6126:	9e 00 00 00 	cmpa	#0,	r14	;
    612a:	01 24       	jz	$+4      	;abs 0x612e

0000612c <.Loc.183.1>:
    612c:	4e 13       	calla	r14		;

0000612e <.L45>:
    612e:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    6132:	02 20       	jnz	$+6      	;abs 0x6138

00006134 <.Loc.183.1>:
    6134:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00

00006138 <.L46>:
    6138:	ca 93 08 00 	cmp.b	#0,	8(r10)	;r3 As==00
    613c:	06 24       	jz	$+14     	;abs 0x614a

0000613e <.LBB51>:
    613e:	4d 43       	clr.b	r13		;
    6140:	cc 0a       	mova	r10,	r12	;
    6142:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00006146 <.LVL84>:
    6146:	b0 13 6e 48 	calla	#18542		;0x0486e

0000614a <.L47>:
  if (uartp->txstate == UART_TX_IDLE) {
    614a:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    614e:	0a 20       	jnz	$+22     	;abs 0x6164

00006150 <.LBB53>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    6150:	3c 0a 16 00 	mova	22(r10),r12	;0x00016

00006154 <.L49>:
    6154:	40 18 bc b2 	bitx.w	#8,	28(r12)	;r2 As==11, 0x0001c
    6158:	1c 00 
    615a:	fc 27       	jz	$-6      	;abs 0x6154

0000615c <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    615c:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

00006160 <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    6160:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

00006164 <.L44>:
}
    6164:	0a 16       	popm.a	#1,	r10	;20-bit words
    6166:	10 01       	reta			;

00006168 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
    6168:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000616a <.LCFI3>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
#endif
  
#if MSP430X_UART_USE_UARTA1 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA1);
    616a:	8a 01 62 16 	mova	#71266,	r10	;0x11662
    616e:	cc 0a       	mova	r10,	r12	;
    6170:	b0 13 3a 50 	calla	#20538		;0x0503a

00006174 <.LVL104>:
  UARTDA1.regs = (msp430x_uart_reg_t  *)(&UCA1CTLW0);
    6174:	00 18 fa 40 	movx.a	#1504,	22(r10)	;0x005e0, 0x00016
    6178:	e0 05 16 00 

0000617c <.Loc.463.1>:
  UARTDA1.freq = MSP430X_UARTA1_CLK_FREQ;
    617c:	ba 40 00 24 	mov	#9216,	18(r10)	;#0x2400, 0x0012
    6180:	12 00 
    6182:	ba 40 f4 00 	mov	#244,	20(r10)	;#0x00f4, 0x0014
    6186:	14 00 

00006188 <.Loc.464.1>:
  UARTDA1.dmareq_tx.dest_addr = (void*)(&UCA1TXBUF);
    6188:	00 18 fa 40 	movx.a	#1518,	30(r10)	;0x005ee, 0x0001e
    618c:	ee 05 1e 00 

00006190 <.Loc.465.1>:
  UARTDA1.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    6190:	ba 40 00 03 	mov	#768,	36(r10)	;#0x0300, 0x0024
    6194:	24 00 

00006196 <.Loc.466.1>:
  UARTDA1.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    6196:	ba 40 c0 00 	mov	#192,	38(r10)	;#0x00c0, 0x0026
    619a:	26 00 

0000619c <.Loc.467.1>:
  UARTDA1.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    619c:	8a 43 28 00 	mov	#0,	40(r10)	;r3 As==00, 0x0028

000061a0 <.Loc.468.1>:
  UARTDA1.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA1TXIFG);
    61a0:	ba 40 11 00 	mov	#17,	42(r10)	;#0x0011, 0x002a
    61a4:	2a 00 

000061a6 <.Loc.469.1>:
  UARTDA1.dmareq_rx.source_addr = (void*)(&UCA1RXBUF);
    61a6:	00 18 fa 40 	movx.a	#1516,	52(r10)	;0x005ec, 0x00034
    61aa:	ec 05 34 00 

000061ae <.Loc.470.1>:
  UARTDA1.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    61ae:	ba 40 00 0c 	mov	#3072,	62(r10)	;#0x0c00, 0x003e
    61b2:	3e 00 

000061b4 <.Loc.471.1>:
  UARTDA1.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    61b4:	ba 40 c0 00 	mov	#192,	64(r10)	;#0x00c0, 0x0040
    61b8:	40 00 

000061ba <.Loc.472.1>:
  UARTDA1.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    61ba:	8a 43 42 00 	mov	#0,	66(r10)	;r3 As==00, 0x0042

000061be <.Loc.473.1>:
  UARTDA1.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA1RXIFG);
    61be:	ba 40 10 00 	mov	#16,	68(r10)	;#0x0010, 0x0044
    61c2:	44 00 

000061c4 <.Loc.512.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    61c4:	0a 16       	popm.a	#1,	r10	;20-bit words
    61c6:	10 01       	reta			;

000061c8 <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    61c8:	6a 14       	pushm.a	#7,	r10	;20-bit words

000061ca <.LCFI4>:
    61ca:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000061ce <.LCFI5>:
    61ce:	ca 0c       	mova	r12,	r10	;

000061d0 <.Loc.523.1>:

  if (uartp->state != UART_STOP) {
    61d0:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    61d4:	16 24       	jz	$+46     	;abs 0x6202

000061d6 <.Loc.525.1>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    61d6:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

000061da <.L103>:
    61da:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    61de:	1c 00 
    61e0:	fc 27       	jz	$-6      	;abs 0x61da

000061e2 <.Loc.528.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    61e2:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    61e6:	05 24       	jz	$+12     	;abs 0x61f2

000061e8 <.Loc.529.1>:
      dmaReleaseX(&(uartp->dma_tx));
    61e8:	cc 0a       	mova	r10,	r12	;
    61ea:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    61ee:	b0 13 00 56 	calla	#22016		;0x05600

000061f2 <.L104>:
    }
    if (uartp->dma_acquired_rx) {
    61f2:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    61f6:	05 24       	jz	$+12     	;abs 0x6202

000061f8 <.Loc.532.1>:
      dmaReleaseX(&(uartp->dma_rx));
    61f8:	cc 0a       	mova	r10,	r12	;
    61fa:	ac 00 58 00 	adda	#88,	r12	;0x00058
    61fe:	b0 13 00 56 	calla	#22016		;0x05600

00006202 <.L102>:
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    6202:	34 0a 16 00 	mova	22(r10),r4	;0x00016
    6206:	94 d3 00 00 	bis	#1,	0(r4)	;r3 As==01

0000620a <.LBB63>:
  uint16_t n = uartp->freq / uartp->config->baud;
    620a:	91 4a 12 00 	mov	18(r10),10(r1)	;0x00012, 0x000a
    620e:	0a 00 
    6210:	91 4a 14 00 	mov	20(r10),12(r1)	;0x00014, 0x000c
    6214:	0c 00 
    6216:	35 0a 04 00 	mova	4(r10),	r5	;
    621a:	91 45 14 00 	mov	20(r5),	6(r1)	;0x00014
    621e:	06 00 
    6220:	91 45 16 00 	mov	22(r5),	8(r1)	;0x00016
    6224:	08 00 
    6226:	8b 00 b6 cb 	mova	#52150,	r11	;0x0cbb6
    622a:	1e 41 06 00 	mov	6(r1),	r14	;
    622e:	1f 41 08 00 	mov	8(r1),	r15	;
    6232:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    6236:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    623a:	71 0b 00 00 	mova	r11,	0(r1)	;
    623e:	4b 13       	calla	r11		;

00006240 <.LVL110>:
    6240:	07 4c       	mov	r12,	r7	;
    6242:	81 4c 04 00 	mov	r12,	4(r1)	;

00006246 <.Loc.158.1>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    6246:	86 00 a2 cd 	mova	#52642,	r6	;0x0cda2
    624a:	1e 41 06 00 	mov	6(r1),	r14	;
    624e:	1f 41 08 00 	mov	8(r1),	r15	;
    6252:	4d 43       	clr.b	r13		;
    6254:	46 13       	calla	r6		;

00006256 <.LVL112>:
    6256:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    625a:	4f 43       	clr.b	r15		;
    625c:	18 41 0a 00 	mov	10(r1),	r8	;0x0000a
    6260:	19 41 0c 00 	mov	12(r1),	r9	;0x0000c
    6264:	40 18 08 8c 	subx.w	r12,	r8	;
    6268:	40 18 09 7d 	subcx.w	r13,	r9	;
    626c:	0c 48       	mov	r8,	r12	;
    626e:	0d 49       	mov	r9,	r13	;
    6270:	46 13       	calla	r6		;

00006272 <.LVL113>:
    6272:	1e 41 06 00 	mov	6(r1),	r14	;
    6276:	1f 41 08 00 	mov	8(r1),	r15	;
    627a:	0b 01       	mova	@r1,	r11	;
    627c:	4b 13       	calla	r11		;

0000627e <.LVL114>:
    627e:	8e 00 ec 5e 	mova	#24300,	r14	;0x05eec

00006282 <.Loc.159.1>:
  if (n > 16) {
    6282:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    6286:	09 97       	cmp	r7,	r9	;
    6288:	90 2c       	jc	$+290    	;abs 0x63aa

0000628a <.Loc.160.1>:
    uartp->regs->brw = (n >> 4);
    628a:	0d 47       	mov	r7,	r13	;
    628c:	5d 0f       	rrum	#4,	r13	;
    628e:	84 4d 06 00 	mov	r13,	6(r4)	;

00006292 <.Loc.162.1>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    6292:	4e 13       	calla	r14		;

00006294 <.LVL115>:
    6294:	09 47       	mov	r7,	r9	;
    6296:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    629a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    629e:	19 d3       	bis	#1,	r9	;r3 As==01
    62a0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    62a4:	09 dc       	bis	r12,	r9	;
    62a6:	84 49 08 00 	mov	r9,	8(r4)	;

000062aa <.L107>:
  set_baud(uartp);
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    62aa:	5c 45 18 00 	mov.b	24(r5),	r12	;0x00018
    62ae:	5c 0f       	rrum	#4,	r12	;
    62b0:	5c 03       	rrum	#1,	r12	;
    62b2:	5c f3       	and.b	#1,	r12	;r3 As==01
    62b4:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    62b8:	84 4c 10 00 	mov	r12,	16(r4)	; 0x0010

000062bc <.Loc.543.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    62bc:	5d 45 19 00 	mov.b	25(r5),	r13	;0x00019
    62c0:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    62c4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    62c6:	0c 9d       	cmp	r13,	r12	;
    62c8:	79 38       	jl	$+244    	;abs 0x63bc

000062ca <.Loc.544.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    62ca:	cc 0a       	mova	r10,	r12	;
    62cc:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    62d0:	b0 13 2c 55 	calla	#21804		;0x0552c

000062d4 <.LVL117>:
    62d4:	c8 0c       	mova	r12,	r8	;

000062d6 <.LVL118>:
    osalDbgAssert(!b, "stream already allocated");
    62d6:	9c 00 00 00 	cmpa	#0,	r12	;
    62da:	04 24       	jz	$+10     	;abs 0x62e4

000062dc <.Loc.545.1>:
    62dc:	8c 01 ed 04 	mova	#66797,	r12	;0x104ed
    62e0:	b0 13 3e 46 	calla	#17982		;0x0463e

000062e4 <.L109>:
    uartp->dma_acquired_tx = !b;
    62e4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    62e6:	98 00 00 00 	cmpa	#0,	r8	;
    62ea:	01 24       	jz	$+4      	;abs 0x62ee
    62ec:	4c 43       	clr.b	r12		;

000062ee <.L110>:
    62ee:	ca 4c 62 00 	mov.b	r12,	98(r10)	; 0x0062

000062f2 <.L111>:
  }
  else {
    uartp->dma_acquired_tx = false;
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    62f2:	3c 0a 04 00 	mova	4(r10),	r12	;
    62f6:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    62fa:	5d 0f       	rrum	#4,	r13	;
    62fc:	68 43       	mov.b	#2,	r8	;r3 As==10
    62fe:	08 9d       	cmp	r13,	r8	;
    6300:	61 38       	jl	$+196    	;abs 0x63c4

00006302 <.Loc.552.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    6302:	cc 0a       	mova	r10,	r12	;
    6304:	ac 00 58 00 	adda	#88,	r12	;0x00058
    6308:	b0 13 2c 55 	calla	#21804		;0x0552c

0000630c <.LVL121>:
    630c:	c8 0c       	mova	r12,	r8	;

0000630e <.LVL122>:
    osalDbgAssert(!b, "stream already allocated");
    630e:	9c 00 00 00 	cmpa	#0,	r12	;
    6312:	04 24       	jz	$+10     	;abs 0x631c

00006314 <.Loc.553.1>:
    6314:	8c 01 ed 04 	mova	#66797,	r12	;0x104ed
    6318:	b0 13 3e 46 	calla	#17982		;0x0463e

0000631c <.L113>:
    uartp->dma_acquired_rx = !b;
    631c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    631e:	98 00 00 00 	cmpa	#0,	r8	;
    6322:	01 24       	jz	$+4      	;abs 0x6326
    6324:	4c 43       	clr.b	r12		;

00006326 <.L114>:
    6326:	ca 4c 63 00 	mov.b	r12,	99(r10)	; 0x0063

0000632a <.L115>:
  else {
    uartp->dma_acquired_rx = false;
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    632a:	00 18 fa 40 	movx.a	#24856,	44(r10)	;0x06118, 0x0002c
    632e:	18 61 2c 00 

00006332 <.Loc.562.1>:
  uartp->dmareq_tx.callback.args = uartp;
    6332:	7a 0a 30 00 	mova	r10,	48(r10)	; 0x00030

00006336 <.Loc.563.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    6336:	00 18 fa 40 	movx.a	#24242,	70(r10)	;0x05eb2, 0x00046
    633a:	b2 5e 46 00 

0000633e <.Loc.564.1>:
  uartp->dmareq_rx.callback.args = uartp;
    633e:	7a 0a 4a 00 	mova	r10,	74(r10)	; 0x0004a

00006342 <.Loc.578.1>:
        (UCRXEIE) | (UCBRKIE));

  }
#endif
#if MSP430X_UART_USE_UARTA1 == TRUE
  if (&UARTDA1 == uartp) {
    6342:	9a 01 62 16 	cmpa	#71266,	r10	;0x11662
    6346:	29 20       	jnz	$+84     	;abs 0x639a

00006348 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6348:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    634c:	38 0a 04 00 	mova	4(r10),	r8	;

00006350 <.Loc.583.1>:
        (uartp->config->order << 13) | 
        (uartp->config->char_size << 12) | 
        (uartp->config->stop_bits << 11) |
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    6350:	5e 48 18 00 	mov.b	24(r8),	r14	;0x00018
    6354:	0f 4e       	mov	r14,	r15	;
    6356:	5f 0f       	rrum	#4,	r15	;
    6358:	5f 03       	rrum	#1,	r15	;
    635a:	5f f3       	and.b	#1,	r15	;r3 As==01

0000635c <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    635c:	0d 4e       	mov	r14,	r13	;
    635e:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;

00006362 <.Loc.580.1>:
        (uartp->config->order << 13) | 
    6362:	09 4e       	mov	r14,	r9	;
    6364:	4a 18 09 59 	rpt #11 { rlax.w	r9		;
    6368:	39 f0 00 20 	and	#8192,	r9	;#0x2000

0000636c <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    636c:	0d d9       	bis	r9,	r13	;

0000636e <.Loc.585.1>:
        (MSP430X_UARTA1_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));
    636e:	3d d0 b0 00 	bis	#176,	r13	;#0x00b0

00006372 <.Loc.581.1>:
        (uartp->config->char_size << 12) | 
    6372:	09 4e       	mov	r14,	r9	;
    6374:	48 18 09 59 	rpt #9 { rlax.w	r9		;
    6378:	39 f0 00 10 	and	#4096,	r9	;#0x1000

0000637c <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    637c:	0d d9       	bis	r9,	r13	;

0000637e <.Loc.582.1>:
        (uartp->config->stop_bits << 11) |
    637e:	46 18 0e 5e 	rpt #7 { rlax.w	r14		;
    6382:	3e f0 00 08 	and	#2048,	r14	;#0x0800

00006386 <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    6386:	0d de       	bis	r14,	r13	;

00006388 <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    6388:	0e 4f       	mov	r15,	r14	;
    638a:	49 18 0e 5e 	rpt #10 { rlax.w	r14		;

0000638e <.Loc.585.1>:
        (UCRXEIE) | (UCBRKIE));
    638e:	0d de       	bis	r14,	r13	;

00006390 <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    6390:	48 18 0f 5f 	rpt #9 { rlax.w	r15		;

00006394 <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    6394:	0d df       	bis	r15,	r13	;
    6396:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000639a <.L116>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    639a:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    639e:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

000063a2 <.Loc.614.1>:
}
    63a2:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    63a6:	64 16       	popm.a	#7,	r10	;20-bit words
    63a8:	10 01       	reta			;

000063aa <.L106>:
    uartp->regs->brw = n;
    63aa:	84 47 06 00 	mov	r7,	6(r4)	;

000063ae <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    63ae:	4e 13       	calla	r14		;

000063b0 <.LVL126>:
    63b0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    63b4:	84 4c 08 00 	mov	r12,	8(r4)	;
    63b8:	80 00 aa 62 	mova	#25258,	r0	;0x062aa

000063bc <.L108>:
    uartp->dma_acquired_tx = false;
    63bc:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062
    63c0:	80 00 f2 62 	mova	#25330,	r0	;0x062f2

000063c4 <.L112>:
    uartp->dma_acquired_rx = false;
    63c4:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063
    63c8:	80 00 2a 63 	mova	#25386,	r0	;0x0632a

000063cc <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    63cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000063ce <.LCFI8>:
    63ce:	08 14       	pushm.a	#1,	r8	;20-bit words

000063d0 <.LCFI9>:
    63d0:	06 14       	pushm.a	#1,	r6	;20-bit words

000063d2 <.LCFI10>:
    63d2:	ca 0c       	mova	r12,	r10	;

000063d4 <.Loc.647.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    63d4:	7c 0e 1a 00 	mova	r14,	26(r12)	; 0x0001a

000063d8 <.Loc.648.1>:
  uartp->dmareq_tx.size = n;
    63d8:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

000063dc <.Loc.650.1>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    63dc:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

000063e0 <.L134>:
    63e0:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    63e4:	1c 00 
    63e6:	fc 27       	jz	$-6      	;abs 0x63e0

000063e8 <.Loc.651.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    63e8:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

000063ec <.Loc.653.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    63ec:	c8 0a       	mova	r10,	r8	;
    63ee:	a8 00 4e 00 	adda	#78,	r8	;0x0004e
    63f2:	c6 0a       	mova	r10,	r6	;
    63f4:	a6 00 1a 00 	adda	#26,	r6	;0x0001a

000063f8 <.LBB69>:
  if (!(*acquired)) {
    63f8:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    63fc:	05 20       	jnz	$+12     	;abs 0x6408

000063fe <.Loc.173.1>:
    dmaAcquireI(dma);
    63fe:	cc 08       	mova	r8,	r12	;
    6400:	b0 13 be 54 	calla	#21694		;0x054be

00006404 <.LVL135>:
    (*acquired) = true;
    6404:	da 43 62 00 	mov.b	#1,	98(r10)	;r3 As==01, 0x0062

00006408 <.L135>:
  dmaTransferI(dma, req);
    6408:	cd 06       	mova	r6,	r13	;
    640a:	cc 08       	mova	r8,	r12	;
    640c:	b0 13 84 55 	calla	#21892		;0x05584

00006410 <.LBE69>:
  
  uartp->regs->ifg |= UCTXIFG;
    6410:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    6414:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00006418 <.Loc.656.1>:
}
    6418:	06 16       	popm.a	#1,	r6	;20-bit words
    641a:	08 16       	popm.a	#1,	r8	;20-bit words
    641c:	0a 16       	popm.a	#1,	r10	;20-bit words
    641e:	10 01       	reta			;

00006420 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    6420:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006422 <.LCFI13>:
    6422:	08 14       	pushm.a	#1,	r8	;20-bit words

00006424 <.LCFI14>:
    6424:	06 14       	pushm.a	#1,	r6	;20-bit words

00006426 <.LCFI15>:
    6426:	ca 0c       	mova	r12,	r10	;

00006428 <.Loc.694.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    6428:	7c 0e 38 00 	mova	r14,	56(r12)	; 0x00038

0000642c <.Loc.695.1>:
  uartp->dmareq_rx.size = n;
    642c:	8c 4d 3c 00 	mov	r13,	60(r12)	; 0x003c

00006430 <.Loc.698.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    6430:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00006434 <.LVL142>:
    6434:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00006438 <.Loc.700.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    6438:	c8 0a       	mova	r10,	r8	;
    643a:	a8 00 58 00 	adda	#88,	r8	;0x00058
    643e:	c6 0a       	mova	r10,	r6	;
    6440:	a6 00 34 00 	adda	#52,	r6	;0x00034

00006444 <.LBB73>:
  if (!(*acquired)) {
    6444:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    6448:	05 20       	jnz	$+12     	;abs 0x6454

0000644a <.Loc.173.1>:
    dmaAcquireI(dma);
    644a:	cc 08       	mova	r8,	r12	;
    644c:	b0 13 be 54 	calla	#21694		;0x054be

00006450 <.LVL144>:
    (*acquired) = true;
    6450:	da 43 63 00 	mov.b	#1,	99(r10)	;r3 As==01, 0x0063

00006454 <.L141>:
  dmaTransferI(dma, req);
    6454:	cd 06       	mova	r6,	r13	;
    6456:	cc 08       	mova	r8,	r12	;
    6458:	b0 13 84 55 	calla	#21892		;0x05584

0000645c <.LBE73>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    645c:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    6460:	40 18 9c b3 	bitx.w	#1,	28(r12)	;r3 As==01, 0x0001c
    6464:	1c 00 
    6466:	04 24       	jz	$+10     	;abs 0x6470

00006468 <.Loc.704.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    6468:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

0000646c <.Loc.705.1>:
    uartp->regs->ifg |= UCRXIFG;
    646c:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00006470 <.L140>:
  }
}
    6470:	06 16       	popm.a	#1,	r6	;20-bit words
    6472:	08 16       	popm.a	#1,	r8	;20-bit words
    6474:	0a 16       	popm.a	#1,	r10	;20-bit words
    6476:	10 01       	reta			;

00006478 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    6478:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000647a <.LCFI16>:
    647a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000647c <.LCFI17>:
    647c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000647e <.LCFI18>:
    647e:	c8 0c       	mova	r12,	r8	;

00006480 <.Loc.722.1>:

  size_t result = uartp->dma_rx.registers->sz;
    6480:	3c 0c 58 00 	mova	88(r12),r12	;0x00058

00006484 <.LVL147>:
    6484:	40 18 1a 4c 	movx.w	10(r12),r10	;0x0000a
    6488:	0a 00 

0000648a <.Loc.723.1>:
  dmaCancelI(&(uartp->dma_rx));
    648a:	c6 08       	mova	r8,	r6	;
    648c:	a6 00 58 00 	adda	#88,	r6	;0x00058
    6490:	cc 06       	mova	r6,	r12	;
    6492:	b0 13 46 56 	calla	#22086		;0x05646

00006496 <.LVL149>:
  if (uartp->dma_acquired_rx) {
    6496:	c8 93 63 00 	cmp.b	#0,	99(r8)	;r3 As==00, 0x0063
    649a:	03 24       	jz	$+8      	;abs 0x64a2

0000649c <.Loc.725.1>:
    dmaReleaseX(&(uartp->dma_rx));
    649c:	cc 06       	mova	r6,	r12	;
    649e:	b0 13 00 56 	calla	#22016		;0x05600

000064a2 <.L147>:
  }
  
  uartp->regs->ifg &= ~UCRXIFG;
    64a2:	3c 08 16 00 	mova	22(r8),	r12	;0x00016
    64a6:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

000064aa <.Loc.729.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    64aa:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

000064ae <.Loc.732.1>:

  return result;
}
    64ae:	cc 0a       	mova	r10,	r12	;
    64b0:	06 16       	popm.a	#1,	r6	;20-bit words
    64b2:	08 16       	popm.a	#1,	r8	;20-bit words
    64b4:	0a 16       	popm.a	#1,	r10	;20-bit words
    64b6:	10 01       	reta			;

000064b8 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    64b8:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    64bc:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    64c0:	80 03 06 00 

000064c4 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    64c4:	b0 13 20 4e 	calla	#20000		;0x04e20

000064c8 <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    64c8:	10 01       	reta			;

000064ca <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    64ca:	2a 14       	pushm.a	#3,	r10	;20-bit words

000064cc <.LCFI0>:
    64cc:	ca 0c       	mova	r12,	r10	;

000064ce <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    64ce:	9c 01 c6 16 	cmpa	#71366,	r12	;0x116c6
    64d2:	32 20       	jnz	$+102    	;abs 0x6538

000064d4 <.Loc.301.1>:
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    64d4:	3c 0c 06 00 	mova	6(r12),	r12	;

000064d8 <.LVL3>:
    64d8:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    64dc:	00 00 

000064de <.Loc.304.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    64de:	3c 0a 02 00 	mova	2(r10),	r12	;
    64e2:	2e 4c       	mov	@r12,	r14	;
    64e4:	1f 4c 02 00 	mov	2(r12),	r15	;
    64e8:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    64ec:	4d 43       	clr.b	r13		;
    64ee:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    64f2:	08 4c       	mov	r12,	r8	;
    64f4:	09 4d       	mov	r13,	r9	;

000064f6 <.LVL5>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    64f6:	0d 93       	cmp	#0,	r13	;r3 As==00
    64f8:	04 20       	jnz	$+10     	;abs 0x6502
    64fa:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    64fe:	0c 98       	cmp	r8,	r12	;
    6500:	04 2c       	jc	$+10     	;abs 0x650a

00006502 <.L11>:
    6502:	8c 01 0f 05 	mova	#66831,	r12	;0x1050f
    6506:	b0 13 3e 46 	calla	#17982		;0x0463e

0000650a <.L3>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    650a:	0c 48       	mov	r8,	r12	;
    650c:	7c f0 07 00 	and.b	#7,	r12	;
    6510:	0c 93       	cmp	#0,	r12	;r3 As==00
    6512:	14 24       	jz	$+42     	;abs 0x653c

00006514 <.Loc.348.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    divider /= 8;
  }
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    6514:	0c 48       	mov	r8,	r12	;
    6516:	7c f0 03 00 	and.b	#3,	r12	;
    651a:	0c 93       	cmp	#0,	r12	;r3 As==00
    651c:	2b 20       	jnz	$+88     	;abs 0x6574

0000651e <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    651e:	3c 0a 06 00 	mova	6(r10),	r12	;
    6522:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    6526:	00 00 

00006528 <.Loc.350.1>:
    divider /= 4;
    6528:	40 19 09 10 	rrux.w	r9		;
    652c:	08 10       	rrc	r8		;
    652e:	40 19 09 10 	rrux.w	r9		;
    6532:	08 10       	rrc	r8		;
    6534:	80 00 52 65 	mova	#25938,	r0	;0x06552

00006538 <.L10>:
  uint32_t divider = 0;
    6538:	48 43       	clr.b	r8		;
    653a:	49 43       	clr.b	r9		;

0000653c <.L13>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    653c:	3c 0a 06 00 	mova	6(r10),	r12	;
    6540:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    6544:	00 00 

00006546 <.Loc.346.1>:
    divider /= 8;
    6546:	0c 48       	mov	r8,	r12	;
    6548:	0d 49       	mov	r9,	r13	;
    654a:	b0 13 42 cd 	calla	#52546		;0x0cd42
    654e:	08 4c       	mov	r12,	r8	;
    6550:	09 4d       	mov	r13,	r9	;

00006552 <.L6>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    6552:	09 93       	cmp	#0,	r9	;r3 As==00
    6554:	03 20       	jnz	$+8      	;abs 0x655c
    6556:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6558:	0d 98       	cmp	r8,	r13	;
    655a:	04 2c       	jc	$+10     	;abs 0x6564

0000655c <.L12>:
    655c:	8c 01 0f 05 	mova	#66831,	r12	;0x1050f
    6560:	b0 13 3e 46 	calla	#17982		;0x0463e

00006564 <.L8>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    6564:	3c 0a 06 00 	mova	6(r10),	r12	;
    6568:	0d 48       	mov	r8,	r13	;
    656a:	3d 53       	add	#-1,	r13	;r3 As==11
    656c:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

00006570 <.Loc.359.1>:

}
    6570:	28 16       	popm.a	#3,	r10	;20-bit words
    6572:	10 01       	reta			;

00006574 <.L7>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    6574:	0c 48       	mov	r8,	r12	;
    6576:	5c f3       	and.b	#1,	r12	;r3 As==01
    6578:	0c 93       	cmp	#0,	r12	;r3 As==00
    657a:	eb 23       	jnz	$-40     	;abs 0x6552

0000657c <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    657c:	3c 0a 06 00 	mova	6(r10),	r12	;
    6580:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    6584:	00 00 

00006586 <.Loc.354.1>:
    divider /= 2;
    6586:	12 c3       	clrc			
    6588:	09 10       	rrc	r9		;
    658a:	08 10       	rrc	r8		;
    658c:	80 00 52 65 	mova	#25938,	r0	;0x06552

00006590 <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    6590:	3e 0c 02 00 	mova	2(r12),	r14	;
    6594:	3c 0c 06 00 	mova	6(r12),	r12	;

00006598 <.LVL17>:
    6598:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    659c:	04 00 
    659e:	02 24       	jz	$+6      	;abs 0x65a4

000065a0 <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    65a0:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000065a4 <.L17>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    65a4:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

000065a8 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    65a8:	2d 4c       	mov	@r12,	r13	;

000065aa <.LVL18>:
    65aa:	3d d0 14 00 	bis	#20,	r13	;#0x0014
    65ae:	8c 4d 00 00 	mov	r13,	0(r12)	;

000065b2 <.Loc.398.1>:
}
    65b2:	10 01       	reta			;

000065b4 <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    65b4:	3c 0c 06 00 	mova	6(r12),	r12	;

000065b8 <.LVL20>:
    65b8:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    65bc:	00 00 

000065be <.Loc.412.1>:

}
    65be:	10 01       	reta			;

000065c0 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    65c0:	32 c2       	dint			
    65c2:	03 43       	nop			

000065c4 <.Loc.46.1>:

}
    65c4:	10 01       	reta			;

000065c6 <sx1278SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
uint8_t sx1278SetRegister(SX1278Driver *devp, uint8_t reg, 
    uint8_t value) {
    65c6:	5a 14       	pushm.a	#6,	r10	;20-bit words

000065c8 <.LCFI0>:
    65c8:	ca 0c       	mova	r12,	r10	;
    65ca:	49 4d       	mov.b	r13,	r9	;
    65cc:	47 4e       	mov.b	r14,	r7	;

000065ce <.Loc.105.1>:
  
  osalDbgAssert(reg & 0x7FU, "register address out of bounds");
    65ce:	39 b0 7f 00 	bit	#127,	r9	;#0x007f
    65d2:	04 20       	jnz	$+10     	;abs 0x65dc

000065d4 <.Loc.105.1>:
    65d4:	8c 01 3e 05 	mova	#66878,	r12	;0x1053e

000065d8 <.LVL3>:
    65d8:	b0 13 3e 46 	calla	#17982		;0x0463e

000065dc <.L3>:
  
  osalDbgAssert(reg != 0x11U && reg != 0x3CU && reg != 0x42U, 
    65dc:	79 90 11 00 	cmp.b	#17,	r9	;#0x0011
    65e0:	06 24       	jz	$+14     	;abs 0x65ee

000065e2 <.Loc.107.1>:
    65e2:	79 90 3c 00 	cmp.b	#60,	r9	;#0x003c
    65e6:	03 24       	jz	$+8      	;abs 0x65ee

000065e8 <.Loc.107.1>:
    65e8:	79 90 42 00 	cmp.b	#66,	r9	;#0x0042
    65ec:	04 20       	jnz	$+10     	;abs 0x65f6

000065ee <.L4>:
    65ee:	8c 01 3e 05 	mova	#66878,	r12	;0x1053e
    65f2:	b0 13 3e 46 	calla	#17982		;0x0463e

000065f6 <.L5>:
      "setting read-only registers");
  
  palClearLine(devp->config->ss_line);
    65f6:	06 0a       	mova	@r10,	r6	;
    65f8:	3c 06 22 00 	mova	34(r6),	r12	;0x00022
    65fc:	c8 0c       	mova	r12,	r8	;
    65fe:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6602:	ff 0f 
    6604:	15 48 02 00 	mov	2(r8),	r5	;
    6608:	0c 14       	pushm.a	#1,	r12	;20-bit words
    660a:	40 18 3c 41 	popx.w	r12		;
    660e:	40 18 3d 41 	popx.w	r13		;
    6612:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6616:	0d 12       	push	r13		;
    6618:	0c 12       	push	r12		;
    661a:	0c 16       	popm.a	#1,	r12	;20-bit words
    661c:	40 18 0d 4c 	movx.w	r12,	r13	;
    6620:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6622:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6626:	05 cc       	bic	r12,	r5	;
    6628:	88 45 02 00 	mov	r5,	2(r8)	;

0000662c <.Loc.111.1>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    662c:	88 00 fe 58 	mova	#22782,	r8	;0x058fe
    6630:	4d 49       	mov.b	r9,	r13	;
    6632:	7d d0 80 ff 	bis.b	#-128,	r13	;#0xff80
    6636:	0c 06       	mova	@r6,	r12	;
    6638:	48 13       	calla	r8		;

0000663a <.LVL8>:
  reg = spiPolledExchange(devp->config->spip, value);
    663a:	0c 0a       	mova	@r10,	r12	;
    663c:	4d 47       	mov.b	r7,	r13	;
    663e:	0c 0c       	mova	@r12,	r12	;
    6640:	48 13       	calla	r8		;

00006642 <.LVL9>:
    6642:	49 4c       	mov.b	r12,	r9	;

00006644 <.Loc.113.1>:
  palSetLine(devp->config->ss_line);
    6644:	0c 0a       	mova	@r10,	r12	;
    6646:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    664a:	ca 0c       	mova	r12,	r10	;

0000664c <.LVL11>:
    664c:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6650:	ff 0f 
    6652:	18 4a 02 00 	mov	2(r10),	r8	;
    6656:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6658:	40 18 3c 41 	popx.w	r12		;
    665c:	40 18 3d 41 	popx.w	r13		;
    6660:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6664:	0d 12       	push	r13		;
    6666:	0c 12       	push	r12		;
    6668:	0c 16       	popm.a	#1,	r12	;20-bit words
    666a:	40 18 0d 4c 	movx.w	r12,	r13	;
    666e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6670:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6674:	0c d8       	bis	r8,	r12	;
    6676:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000667a <.Loc.116.1>:
  
  return reg;
}
    667a:	4c 49       	mov.b	r9,	r12	;
    667c:	55 16       	popm.a	#6,	r10	;20-bit words
    667e:	10 01       	reta			;

00006680 <sx1278SetBitrate>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] rate bit rate in bits per second to be used
*/
void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    6680:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006682 <.LCFI1>:
    6682:	c8 0c       	mova	r12,	r8	;
    6684:	06 4d       	mov	r13,	r6	;
    6686:	0a 4e       	mov	r14,	r10	;

00006688 <.Loc.166.1>:
  uint32_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    6688:	0e 4d       	mov	r13,	r14	;
    668a:	0f 4a       	mov	r10,	r15	;
    668c:	3c 40 00 80 	mov	#-32768,r12	;#0x8000

00006690 <.LVL15>:
    6690:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84

00006694 <.LVL16>:
    6694:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    6698:	09 4c       	mov	r12,	r9	;

0000669a <.LVL18>:
  uint16_t regs = tmp >> 4;
    669a:	b0 13 3c cd 	calla	#52540		;0x0cd3c

0000669e <.LVL19>:
    669e:	07 4c       	mov	r12,	r7	;

000066a0 <.Loc.168.1>:
  uint8_t frac = tmp & 0x000F;
    66a0:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f

000066a4 <.Loc.170.1>:
  
  osalDbgAssert(rate < 300000, "bit rate too high");
    66a4:	6c 42       	mov.b	#4,	r12	;r2 As==10
    66a6:	0c 9a       	cmp	r10,	r12	;
    66a8:	06 28       	jnc	$+14     	;abs 0x66b6
    66aa:	0a 9c       	cmp	r12,	r10	;
    66ac:	08 20       	jnz	$+18     	;abs 0x66be
    66ae:	3c 40 df 93 	mov	#-27681,r12	;#0x93df
    66b2:	0c 96       	cmp	r6,	r12	;
    66b4:	04 2c       	jc	$+10     	;abs 0x66be

000066b6 <.L15>:
    66b6:	8c 01 50 05 	mova	#66896,	r12	;0x10550
    66ba:	b0 13 3e 46 	calla	#17982		;0x0463e

000066be <.L13>:
  
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    66be:	8a 00 c6 65 	mova	#26054,	r10	;0x065c6
    66c2:	0e 47       	mov	r7,	r14	;
    66c4:	5e 0f       	rrum	#4,	r14	;
    66c6:	5e 0f       	rrum	#4,	r14	;
    66c8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    66ca:	cc 08       	mova	r8,	r12	;
    66cc:	4a 13       	calla	r10		;

000066ce <.LVL23>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    66ce:	4e 47       	mov.b	r7,	r14	;
    66d0:	7d 40 03 00 	mov.b	#3,	r13	;
    66d4:	cc 08       	mova	r8,	r12	;
    66d6:	4a 13       	calla	r10		;

000066d8 <.LVL24>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    66d8:	4e 49       	mov.b	r9,	r14	;
    66da:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    66de:	cc 08       	mova	r8,	r12	;
    66e0:	4a 13       	calla	r10		;

000066e2 <.LVL25>:
}
    66e2:	46 16       	popm.a	#5,	r10	;20-bit words
    66e4:	10 01       	reta			;

000066e6 <sx1278SetDeviation>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    66e6:	4a 14       	pushm.a	#5,	r10	;20-bit words

000066e8 <.LCFI2>:
    66e8:	c8 0c       	mova	r12,	r8	;
    66ea:	06 4d       	mov	r13,	r6	;
    66ec:	09 4e       	mov	r14,	r9	;

000066ee <.Loc.186.1>:
  /* Fancy math for freq / FSTEP to correct for roundings */
  uint16_t regs = ((fdev << 11) + (SX1278_CLK_FREQ >> 9)) / 
    66ee:	0c 4d       	mov	r13,	r12	;

000066f0 <.LVL27>:
    66f0:	0d 4e       	mov	r14,	r13	;

000066f2 <.LVL28>:
    66f2:	b0 13 02 cc 	calla	#52226		;0x0cc02
    66f6:	3e 40 48 e8 	mov	#-6072,	r14	;#0xe848
    66fa:	5f 43       	mov.b	#1,	r15	;r3 As==01
    66fc:	3c 50 24 f4 	add	#-3036,	r12	;#0xf424
    6700:	0d 63       	adc	r13		;
    6702:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    6706:	07 4c       	mov	r12,	r7	;
    6708:	0a 4c       	mov	r12,	r10	;

0000670a <.Loc.189.1>:
    (SX1278_CLK_FREQ >> 8);
  
  osalDbgAssert(fdev < 200000, "deviation too high");
    670a:	7c 40 03 00 	mov.b	#3,	r12	;
    670e:	0c 99       	cmp	r9,	r12	;
    6710:	06 28       	jnc	$+14     	;abs 0x671e
    6712:	09 9c       	cmp	r12,	r9	;
    6714:	08 20       	jnz	$+18     	;abs 0x6726
    6716:	3c 40 3f 0d 	mov	#3391,	r12	;#0x0d3f
    671a:	0c 96       	cmp	r6,	r12	;
    671c:	04 2c       	jc	$+10     	;abs 0x6726

0000671e <.L19>:
    671e:	8c 01 61 05 	mova	#66913,	r12	;0x10561
    6722:	b0 13 3e 46 	calla	#17982		;0x0463e

00006726 <.L17>:
  
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    6726:	86 00 c6 65 	mova	#26054,	r6	;0x065c6
    672a:	0e 4a       	mov	r10,	r14	;
    672c:	5e 0f       	rrum	#4,	r14	;
    672e:	5e 0f       	rrum	#4,	r14	;
    6730:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6732:	cc 08       	mova	r8,	r12	;
    6734:	46 13       	calla	r6		;

00006736 <.LVL33>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    6736:	4e 47       	mov.b	r7,	r14	;
    6738:	7d 40 05 00 	mov.b	#5,	r13	;
    673c:	cc 08       	mova	r8,	r12	;
    673e:	46 13       	calla	r6		;

00006740 <.LVL34>:
}
    6740:	46 16       	popm.a	#5,	r10	;20-bit words
    6742:	10 01       	reta			;

00006744 <sx1278SetFrequency>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    6744:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006746 <.LCFI3>:
    6746:	ca 0c       	mova	r12,	r10	;
    6748:	08 4d       	mov	r13,	r8	;
    674a:	05 4e       	mov	r14,	r5	;

0000674c <.Loc.204.1>:
  /* Fancy math for freq / FSTEP to keep everything from rounding */
  uint32_t regs = (((freq + (SX1278_CLK_FREQ >> 12)) / 
    674c:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    6750:	4f 43       	clr.b	r15		;
    6752:	0c 4d       	mov	r13,	r12	;

00006754 <.LVL36>:
    6754:	3c 50 84 1e 	add	#7812,	r12	;#0x1e84
    6758:	0d 45       	mov	r5,	r13	;

0000675a <.LVL37>:
    675a:	0d 63       	adc	r13		;
    675c:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    6760:	07 4c       	mov	r12,	r7	;
    6762:	b0 13 0e cc 	calla	#52238		;0x0cc0e
    6766:	06 4c       	mov	r12,	r6	;
    6768:	09 4d       	mov	r13,	r9	;

0000676a <.Loc.207.1>:
        (SX1278_CLK_FREQ >> 11)) << 8);
  
  if ((freq >= 137000000 && freq <= 175000000) || 
    676a:	0d 48       	mov	r8,	r13	;
    676c:	3d 50 c0 8b 	add	#-29760,r13	;#0x8bc0
    6770:	0c 45       	mov	r5,	r12	;
    6772:	3c 60 d5 f7 	addc	#-2091,	r12	;#0xf7d5
    6776:	3e 40 43 02 	mov	#579,	r14	;#0x0243
    677a:	0e 9c       	cmp	r12,	r14	;
    677c:	06 28       	jnc	$+14     	;abs 0x678a
    677e:	0c 9e       	cmp	r14,	r12	;
    6780:	14 20       	jnz	$+42     	;abs 0x67aa
    6782:	3c 40 80 d5 	mov	#-10880,r12	;#0xd580
    6786:	0c 9d       	cmp	r13,	r12	;
    6788:	10 2c       	jc	$+34     	;abs 0x67aa

0000678a <.L30>:
      (freq >= 410000000 && freq <= 525000000)) {
    678a:	0d 48       	mov	r8,	r13	;
    678c:	3d 50 80 e5 	add	#-6784,	r13	;#0xe580
    6790:	0c 45       	mov	r5,	r12	;
    6792:	3c 60 8f e7 	addc	#-6257,	r12	;#0xe78f

00006796 <.Loc.207.1>:
  if ((freq >= 137000000 && freq <= 175000000) || 
    6796:	3e 40 da 06 	mov	#1754,	r14	;#0x06da
    679a:	0e 9c       	cmp	r12,	r14	;
    679c:	2c 28       	jnc	$+90     	;abs 0x67f6
    679e:	0c 9e       	cmp	r14,	r12	;
    67a0:	04 20       	jnz	$+10     	;abs 0x67aa
    67a2:	3c 40 c0 c2 	mov	#-15680,r12	;#0xc2c0
    67a6:	0c 9d       	cmp	r13,	r12	;
    67a8:	26 28       	jnc	$+78     	;abs 0x67f6

000067aa <.L21>:
    /* Bands 2 + 3 */
    devp->regs.opmode |= (1 << 3);
    67aa:	fa d2 05 00 	bis.b	#8,	5(r10)	;r2 As==11

000067ae <.L25>:
  }
  else {
    osalDbgAssert(false, "frequency out of range");
  }
  
  osalDbgAssert(!(regs & 0xFF000000), "incorrect register value calculated");
    67ae:	39 b0 00 ff 	bit	#-256,	r9	;#0xff00
    67b2:	04 24       	jz	$+10     	;abs 0x67bc
    67b4:	8c 01 74 05 	mova	#66932,	r12	;0x10574
    67b8:	b0 13 3e 46 	calla	#17982		;0x0463e

000067bc <.L28>:
  
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    67bc:	88 00 c6 65 	mova	#26054,	r8	;0x065c6
    67c0:	5e 4a 05 00 	mov.b	5(r10),	r14	;
    67c4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    67c6:	cc 0a       	mova	r10,	r12	;
    67c8:	48 13       	calla	r8		;

000067ca <.LVL42>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    67ca:	0c 46       	mov	r6,	r12	;
    67cc:	0d 49       	mov	r9,	r13	;
    67ce:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    67d2:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    67d6:	4e 4c       	mov.b	r12,	r14	;
    67d8:	7d 40 06 00 	mov.b	#6,	r13	;
    67dc:	cc 0a       	mova	r10,	r12	;
    67de:	48 13       	calla	r8		;

000067e0 <.LVL44>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    67e0:	4e 47       	mov.b	r7,	r14	;
    67e2:	7d 40 07 00 	mov.b	#7,	r13	;
    67e6:	cc 0a       	mova	r10,	r12	;
    67e8:	48 13       	calla	r8		;

000067ea <.LVL45>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    67ea:	4e 43       	clr.b	r14		;
    67ec:	7d 42       	mov.b	#8,	r13	;r2 As==11
    67ee:	cc 0a       	mova	r10,	r12	;
    67f0:	48 13       	calla	r8		;

000067f2 <.LVL46>:
}
    67f2:	55 16       	popm.a	#6,	r10	;20-bit words
    67f4:	10 01       	reta			;

000067f6 <.L23>:
  else if (freq >= 862000000 && freq <= 1020000000) {
    67f6:	38 50 80 ec 	add	#-4992,	r8	;#0xec80
    67fa:	35 60 9e cc 	addc	#-13154,r5	;#0xcc9e
    67fe:	3e 40 6a 09 	mov	#2410,	r14	;#0x096a
    6802:	0e 95       	cmp	r5,	r14	;
    6804:	0a 28       	jnc	$+22     	;abs 0x681a
    6806:	05 9e       	cmp	r14,	r5	;
    6808:	04 20       	jnz	$+10     	;abs 0x6812
    680a:	3c 40 80 e3 	mov	#-7296,	r12	;#0xe380
    680e:	0c 98       	cmp	r8,	r12	;
    6810:	04 28       	jnc	$+10     	;abs 0x681a

00006812 <.L31>:
    devp->regs.opmode &= ~(1 << 3);
    6812:	fa c2 05 00 	bic.b	#8,	5(r10)	;r2 As==11
    6816:	80 00 ae 67 	mova	#26542,	r0	;0x067ae

0000681a <.L26>:
    osalDbgAssert(false, "frequency out of range");
    681a:	8c 01 74 05 	mova	#66932,	r12	;0x10574
    681e:	b0 13 3e 46 	calla	#17982		;0x0463e

00006822 <.LVL47>:
    6822:	80 00 ae 67 	mova	#26542,	r0	;0x067ae

00006826 <sx1278SetPower>:
 * @param[in] pow  output power will be programmed as [10+(.2 * pow)], in dBm
*/
void sx1278SetPower(SX1278Driver * devp, uint8_t pow) {
  (void)(pow);
  /* TODO figure out how to set power properly. also add closed loop. */
  sx1278SetRegister(devp, RegPaConfig, 0x03);
    6826:	7e 40 03 00 	mov.b	#3,	r14	;
    682a:	7d 40 09 00 	mov.b	#9,	r13	;

0000682e <.LVL49>:
    682e:	b0 13 c6 65 	calla	#26054		;0x065c6

00006832 <.LVL50>:
  return;
}
    6832:	10 01       	reta			;

00006834 <sx1278SetSync>:
 * 
 * @param[in] devp  pointer to the SX1278 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    6834:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006836 <.LCFI6>:
    6836:	c4 0c       	mova	r12,	r4	;
    6838:	09 4d       	mov	r13,	r9	;
    683a:	07 4e       	mov	r14,	r7	;

0000683c <.LVL56>:
  
  osalDbgAssert(sizeof(sync) <= 8, "requested sync length too large");

  reg |= devp->config->packet_config->preamble_polarity << 5;
  
  if (sync == 0) {
    683c:	0d de       	bis	r14,	r13	;

0000683e <.LVL57>:
    683e:	0d 93       	cmp	#0,	r13	;r3 As==00
    6840:	2c 24       	jz	$+90     	;abs 0x689a

00006842 <.Loc.281.1>:
  reg |= devp->config->packet_config->preamble_polarity << 5;
    6842:	0e 0c       	mova	@r12,	r14	;
    6844:	3e 0e 26 00 	mova	38(r14),r14	;0x00026
    6848:	6e 4e       	mov.b	@r14,	r14	;
    684a:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

0000684e <.LVL58>:
  }
  else {
    reg |= 0x90 | (sizeof(sync) - 1);
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
    684e:	88 00 c6 65 	mova	#26054,	r8	;0x065c6
    6852:	7e d0 93 ff 	bis.b	#-109,	r14	;#0xff93

00006856 <.LVL59>:
    6856:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027
    685a:	48 13       	calla	r8		;

0000685c <.LVL60>:
    685c:	7a 40 28 00 	mov.b	#40,	r10	;#0x0028
    6860:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00006864 <.LBB39>:
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
    6864:	88 00 3e 46 	mova	#17982,	r8	;0x0463e

00006868 <.L41>:
    6868:	0c 49       	mov	r9,	r12	;
    686a:	0d 47       	mov	r7,	r13	;
    686c:	0e 46       	mov	r6,	r14	;
    686e:	0f 43       	clr	r15		;
    6870:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    6874:	05 4c       	mov	r12,	r5	;
    6876:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6878:	03 20       	jnz	$+8      	;abs 0x6880
    687a:	8c 01 9d 05 	mova	#66973,	r12	;0x1059d
    687e:	48 13       	calla	r8		;

00006880 <.L40>:
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    6880:	4e 45       	mov.b	r5,	r14	;
    6882:	4d 4a       	mov.b	r10,	r13	;
    6884:	cc 04       	mova	r4,	r12	;
    6886:	b0 13 c6 65 	calla	#26054		;0x065c6

0000688a <.LVL64>:
    688a:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8
    688e:	4c 4a       	mov.b	r10,	r12	;
    6890:	5c 53       	inc.b	r12		;
    6892:	4a 4c       	mov.b	r12,	r10	;

00006894 <.Loc.293.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    6894:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    6898:	e7 23       	jnz	$-48     	;abs 0x6868

0000689a <.L38>:
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
  }
}
    689a:	64 16       	popm.a	#7,	r10	;20-bit words
    689c:	10 01       	reta			;

0000689e <sx1278ObjectInit>:
 * @init
 */
void sx1278ObjectInit(SX1278Driver *devp) {
  
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    689e:	fc 40 09 00 	mov.b	#9,	5(r12)	;
    68a2:	05 00 

000068a4 <.Loc.511.1>:
  devp->regs.seq_config = 0x00;
    68a4:	cc 43 06 00 	mov.b	#0,	6(r12)	;r3 As==00

000068a8 <.Loc.513.1>:
  
  devp->state = SX1278_STOP;
    68a8:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

000068ac <.Loc.514.1>:
}
    68ac:	10 01       	reta			;

000068ae <spi_callback>:

void spi_callback(SPIDriver *spip) {
    68ae:	2a 14       	pushm.a	#3,	r10	;20-bit words

000068b0 <.LCFI9>:
    68b0:	06 14       	pushm.a	#1,	r6	;20-bit words

000068b2 <.LCFI10>:
    68b2:	ca 0c       	mova	r12,	r10	;

000068b4 <.Loc.517.1>:
  palSetLine(SX1278D1.config->ss_line);
    68b4:	88 01 d0 16 	mova	#71376,	r8	;0x116d0
    68b8:	0c 08       	mova	@r8,	r12	;

000068ba <.LVL102>:
    68ba:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    68be:	c6 0c       	mova	r12,	r6	;
    68c0:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    68c4:	ff 0f 
    68c6:	19 46 02 00 	mov	2(r6),	r9	;
    68ca:	0c 14       	pushm.a	#1,	r12	;20-bit words
    68cc:	40 18 3c 41 	popx.w	r12		;
    68d0:	40 18 3d 41 	popx.w	r13		;
    68d4:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    68d8:	0d 12       	push	r13		;
    68da:	0c 12       	push	r12		;
    68dc:	0c 16       	popm.a	#1,	r12	;20-bit words
    68de:	40 18 0d 4c 	movx.w	r12,	r13	;
    68e2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    68e4:	b0 13 ec cb 	calla	#52204		;0x0cbec
    68e8:	0c d9       	bis	r9,	r12	;
    68ea:	86 4c 02 00 	mov	r12,	2(r6)	;

000068ee <.Loc.518.1>:
  if (SX1278D1.callback != NULL) {
    68ee:	3e 08 08 00 	mova	8(r8),	r14	;
    68f2:	9e 00 00 00 	cmpa	#0,	r14	;
    68f6:	02 24       	jz	$+6      	;abs 0x68fc

000068f8 <.Loc.519.1>:
    SX1278D1.callback(spip);
    68f8:	cc 0a       	mova	r10,	r12	;
    68fa:	4e 13       	calla	r14		;

000068fc <.L61>:
  }
}
    68fc:	06 16       	popm.a	#1,	r6	;20-bit words
    68fe:	28 16       	popm.a	#3,	r10	;20-bit words
    6900:	10 01       	reta			;

00006902 <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    6902:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006904 <.LCFI11>:
    6904:	06 14       	pushm.a	#1,	r6	;20-bit words

00006906 <.LCFI12>:
    6906:	ca 0c       	mova	r12,	r10	;
    6908:	c8 0d       	mova	r13,	r8	;

0000690a <.Loc.533.1>:
  
  devp->config = config;
    690a:	7a 0d 00 00 	mova	r13,	0(r10)	;

0000690e <.Loc.535.1>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    690e:	b0 13 ee 6c 	calla	#27886		;0x06cee

00006912 <.LVL107>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Add the SPI callback to the SPI config */
  config->spicfgp->end_cb = spi_callback;
    6912:	3d 08 04 00 	mova	4(r8),	r13	;
    6916:	00 18 fd 40 	movx.a	#26798,	0(r13)	;0x068ae
    691a:	ae 68 00 00 

0000691e <.Loc.542.1>:
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    691e:	0c 08       	mova	@r8,	r12	;
    6920:	b0 13 84 4f 	calla	#20356		;0x04f84

00006924 <.LVL108>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, SX1278Sleep);
    6924:	cc 0a       	mova	r10,	r12	;
    6926:	b0 13 c8 6d 	calla	#28104		;0x06dc8

0000692a <.LVL109>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    692a:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    692e:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    6932:	cc 0a       	mova	r10,	r12	;
    6934:	b0 13 44 67 	calla	#26436		;0x06744

00006938 <.LVL110>:
  sx1278SetDeviation(devp, config->fdev);
    6938:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    693c:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    6940:	cc 0a       	mova	r10,	r12	;
    6942:	b0 13 e6 66 	calla	#26342		;0x066e6

00006946 <.LVL111>:
  sx1278SetBitrate(devp, config->bitrate);
    6946:	1d 48 08 00 	mov	8(r8),	r13	;
    694a:	1e 48 0a 00 	mov	10(r8),	r14	;0x0000a
    694e:	cc 0a       	mova	r10,	r12	;
    6950:	b0 13 80 66 	calla	#26240		;0x06680

00006954 <.LVL112>:
  sx1278SetPower(devp, config->pow);
    6954:	5d 48 15 00 	mov.b	21(r8),	r13	;0x00015
    6958:	cc 0a       	mova	r10,	r12	;
    695a:	b0 13 26 68 	calla	#26662		;0x06826

0000695e <.LVL113>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    695e:	19 48 16 00 	mov	22(r8),	r9	;0x00016

00006962 <.LBB88>:
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    6962:	86 00 c6 65 	mova	#26054,	r6	;0x065c6
    6966:	0e 49       	mov	r9,	r14	;
    6968:	5e 0f       	rrum	#4,	r14	;
    696a:	5e 0f       	rrum	#4,	r14	;
    696c:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    6970:	cc 0a       	mova	r10,	r12	;
    6972:	46 13       	calla	r6		;

00006974 <.LVL115>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    6974:	4e 49       	mov.b	r9,	r14	;
    6976:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    697a:	cc 0a       	mova	r10,	r12	;
    697c:	46 13       	calla	r6		;

0000697e <.LBE88>:
  sx1278SetSync(devp, config->sync_word);
    697e:	1d 48 18 00 	mov	24(r8),	r13	;0x00018
    6982:	1e 48 1a 00 	mov	26(r8),	r14	;0x0001a
    6986:	cc 0a       	mova	r10,	r12	;
    6988:	b0 13 34 68 	calla	#26676		;0x06834

0000698c <.LVL117>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 
  Don't set SequencerStart, SequencerStop, FromTransmit, and LowPowerSelection
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x18;
    698c:	fa 40 18 00 	mov.b	#24,	6(r10)	;#0x0018
    6990:	06 00 

00006992 <.Loc.559.1>:
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    6992:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    6996:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    699a:	cc 0a       	mova	r10,	r12	;
    699c:	46 13       	calla	r6		;

0000699e <.LVL118>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    699e:	0c 0a       	mova	@r10,	r12	;
    69a0:	38 0c 26 00 	mova	38(r12),r8	;0x00026

000069a4 <.LBB90>:
  if (packet_config->format == SX1278Variable) {
    69a4:	6c 48       	mov.b	@r8,	r12	;
    69a6:	4d 4c       	mov.b	r12,	r13	;
    69a8:	7d f0 03 00 	and.b	#3,	r13	;
    69ac:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    69ae:	5f 24       	jz	$+192    	;abs 0x6a6e

000069b0 <.Loc.381.1>:
  uint8_t reg = 0x00;
    69b0:	49 43       	clr.b	r9		;

000069b2 <.L67>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
    69b2:	7c f0 0c 00 	and.b	#12,	r12	;#0x000c
    69b6:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    69ba:	04 20       	jnz	$+10     	;abs 0x69c4
    69bc:	8c 01 c5 05 	mova	#67013,	r12	;0x105c5
    69c0:	b0 13 3e 46 	calla	#17982		;0x0463e

000069c4 <.L68>:
  reg |= packet_config->whitening << 6;
    69c4:	6d 48       	mov.b	@r8,	r13	;
    69c6:	0c 4d       	mov	r13,	r12	;
    69c8:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    69cc:	7c f0 40 00 	and.b	#64,	r12	;#0x0040

000069d0 <.Loc.394.1>:
  reg |= packet_config->manchester << 5;
    69d0:	0e 4d       	mov	r13,	r14	;
    69d2:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    69d6:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

000069da <.Loc.396.1>:
  reg |= packet_config->crc << 4;
    69da:	4c de       	bis.b	r14,	r12	;
    69dc:	0e 4d       	mov	r13,	r14	;
    69de:	7e f0 10 00 	and.b	#16,	r14	;#0x0010
    69e2:	4e dc       	bis.b	r12,	r14	;

000069e4 <.LVL122>:
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    69e4:	4e d9       	bis.b	r9,	r14	;

000069e6 <.LVL123>:
    69e6:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

000069ea <.LVL124>:
    69ea:	cc 0a       	mova	r10,	r12	;

000069ec <.LVL125>:
    69ec:	46 13       	calla	r6		;

000069ee <.LVL126>:
  if (packet_config->format == SX1278Fixed) {
    69ee:	6c 48       	mov.b	@r8,	r12	;
    69f0:	7c f0 03 00 	and.b	#3,	r12	;
    69f4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    69f6:	3f 20       	jnz	$+128    	;abs 0x6a76

000069f8 <.Loc.402.1>:
        0x40 | (devp->config->length >> 8));
    69f8:	0c 0a       	mova	@r10,	r12	;
    69fa:	1c 4c 2c 00 	mov	44(r12),r12	;0x0002c
    69fe:	b0 13 cc cc 	calla	#52428		;0x0cccc

00006a02 <.Loc.401.1>:
    sx1278SetRegister(devp, RegPacketConfig2, 
    6a02:	4e 4c       	mov.b	r12,	r14	;
    6a04:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6a08:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6a0c:	cc 0a       	mova	r10,	r12	;
    6a0e:	46 13       	calla	r6		;

00006a10 <.LVL128>:
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    6a10:	0c 0a       	mova	@r10,	r12	;
    6a12:	5e 4c 2c 00 	mov.b	44(r12),r14	;0x0002c
    6a16:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    6a1a:	cc 0a       	mova	r10,	r12	;
    6a1c:	46 13       	calla	r6		;

00006a1e <.L70>:
  
  sx1278MapIRQs(devp, devp->config->irq_map);
    6a1e:	08 0a       	mova	@r10,	r8	;

00006a20 <.LBB93>:
    if (irq_map[i] > 5) continue;
    6a20:	5c 48 1c 00 	mov.b	28(r8),	r12	;0x0001c
    6a24:	7d 40 05 00 	mov.b	#5,	r13	;
    6a28:	4d 9c       	cmp.b	r12,	r13	;
    6a2a:	06 28       	jnc	$+14     	;abs 0x6a38

00006a2c <.Loc.352.1>:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
    6a2c:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a2e:	04 24       	jz	$+10     	;abs 0x6a38
    6a30:	8c 01 dc 05 	mova	#67036,	r12	;0x105dc
    6a34:	b0 13 3e 46 	calla	#17982		;0x0463e

00006a38 <.L71>:
    if (irq_map[i] > 5) continue;
    6a38:	5c 48 1d 00 	mov.b	29(r8),	r12	;0x0001d
    6a3c:	7d 40 05 00 	mov.b	#5,	r13	;
    6a40:	4d 9c       	cmp.b	r12,	r13	;
    6a42:	06 28       	jnc	$+14     	;abs 0x6a50

00006a44 <.Loc.357.1>:
        osalDbgAssert(irq_map[i] == 1, "IRQ mapping invalid");
    6a44:	1c 93       	cmp	#1,	r12	;r3 As==01
    6a46:	04 24       	jz	$+10     	;abs 0x6a50

00006a48 <.Loc.352.1>:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
    6a48:	8c 01 dc 05 	mova	#67036,	r12	;0x105dc
    6a4c:	b0 13 3e 46 	calla	#17982		;0x0463e

00006a50 <.L74>:
  sx1278SetRegister(devp, RegDioMapping1, ((uint8_t *)(&dio_reg))[0]);
    6a50:	4e 43       	clr.b	r14		;
    6a52:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    6a56:	cc 0a       	mova	r10,	r12	;
    6a58:	46 13       	calla	r6		;

00006a5a <.LVL133>:
  sx1278SetRegister(devp, RegDioMapping2, ((uint8_t *)(&dio_reg))[1]);
    6a5a:	4e 43       	clr.b	r14		;
    6a5c:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    6a60:	cc 0a       	mova	r10,	r12	;
    6a62:	46 13       	calla	r6		;

00006a64 <.LBE93>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    6a64:	ea 43 04 00 	mov.b	#2,	4(r10)	;r3 As==10

00006a68 <.Loc.570.1>:
}
    6a68:	06 16       	popm.a	#1,	r6	;20-bit words
    6a6a:	28 16       	popm.a	#3,	r10	;20-bit words
    6a6c:	10 01       	reta			;

00006a6e <.L77>:
    reg |= 1 << 7;
    6a6e:	79 40 80 00 	mov.b	#128,	r9	;#0x0080
    6a72:	80 00 b2 69 	mova	#27058,	r0	;0x069b2

00006a76 <.L69>:
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    6a76:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    6a7a:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6a7e:	cc 0a       	mova	r10,	r12	;
    6a80:	46 13       	calla	r6		;

00006a82 <.LVL137>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    6a82:	4e 43       	clr.b	r14		;
    6a84:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    6a88:	cc 0a       	mova	r10,	r12	;
    6a8a:	46 13       	calla	r6		;

00006a8c <.LVL138>:
    6a8c:	80 00 1e 6a 	mova	#27166,	r0	;0x06a1e

00006a90 <sx1278FifoWriteAsync>:
  
  devp->state = SX1278_SLEEP;
}

__attribute__((optimize(0))) void sx1278FifoWriteAsync(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6a90:	1a 14       	pushm.a	#2,	r10	;20-bit words

00006a92 <.LCFI15>:
    6a92:	b1 00 10 00 	suba	#16,	r1	;0x00010

00006a96 <.LCFI16>:
    6a96:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c
    6a9a:	71 0d 08 00 	mova	r13,	8(r1)	;
    6a9e:	71 0e 04 00 	mova	r14,	4(r1)	;
    6aa2:	71 0f 00 00 	mova	r15,	0(r1)	;

00006aa6 <.Loc.624.1>:
  devp->callback = cb;
    6aa6:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6aaa:	00 18 ec 41 	movx.a	@r1,	8(r12)	;
    6aae:	08 00 

00006ab0 <.Loc.625.1>:
  palClearLine(devp->config->ss_line);
    6ab0:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6ab4:	0c 0c       	mova	@r12,	r12	;

00006ab6 <.LVL147>:
    6ab6:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6aba:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6abe:	ff 0f 
    6ac0:	ca 0c       	mova	r12,	r10	;
    6ac2:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6ac6:	0c 0c       	mova	@r12,	r12	;
    6ac8:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6acc:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6ad0:	ff 0f 
    6ad2:	19 4c 02 00 	mov	2(r12),	r9	;
    6ad6:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6ada:	0c 0c       	mova	@r12,	r12	;
    6adc:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6ae0:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6ae2:	40 18 3c 41 	popx.w	r12		;
    6ae6:	40 18 3d 41 	popx.w	r13		;
    6aea:	b0 13 0c cd 	calla	#52492		;0x0cd0c

00006aee <.LVL148>:
    6aee:	0d 12       	push	r13		;
    6af0:	0c 12       	push	r12		;
    6af2:	0c 16       	popm.a	#1,	r12	;20-bit words
    6af4:	40 18 0d 4c 	movx.w	r12,	r13	;
    6af8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6afa:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6afe:	3c e3       	inv	r12		;
    6b00:	0c f9       	and	r9,	r12	;
    6b02:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006b06 <.Loc.626.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    6b06:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b0a:	0c 0c       	mova	@r12,	r12	;
    6b0c:	0c 0c       	mova	@r12,	r12	;
    6b0e:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6b12:	b0 13 fe 58 	calla	#22782		;0x058fe

00006b16 <.LVL150>:
  devp->config->spicfgp->end_cb = spi_callback;
    6b16:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b1a:	0c 0c       	mova	@r12,	r12	;
    6b1c:	3c 0c 04 00 	mova	4(r12),	r12	;
    6b20:	00 18 fc 40 	movx.a	#26798,	0(r12)	;0x068ae
    6b24:	ae 68 00 00 

00006b28 <.Loc.628.1>:
  spiStartSend(devp->config->spip, n, buffer);
    6b28:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b2c:	0c 0c       	mova	@r12,	r12	;
    6b2e:	0c 0c       	mova	@r12,	r12	;
    6b30:	3e 01 04 00 	mova	4(r1),	r14	;
    6b34:	3d 01 08 00 	mova	8(r1),	r13	;
    6b38:	b0 13 ce 4f 	calla	#20430		;0x04fce

00006b3c <.LVL151>:
}
    6b3c:	03 43       	nop			
    6b3e:	a1 00 10 00 	adda	#16,	r1	;0x00010

00006b42 <.LVL152>:
    6b42:	19 16       	popm.a	#2,	r10	;20-bit words
    6b44:	10 01       	reta			;

00006b46 <sx1278FifoWriteAsyncS>:

__attribute__((optimize(0))) void sx1278FifoWriteAsyncS(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6b46:	1a 14       	pushm.a	#2,	r10	;20-bit words

00006b48 <.LCFI17>:
    6b48:	b1 00 10 00 	suba	#16,	r1	;0x00010

00006b4c <.LCFI18>:
    6b4c:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c
    6b50:	71 0d 08 00 	mova	r13,	8(r1)	;
    6b54:	71 0e 04 00 	mova	r14,	4(r1)	;
    6b58:	71 0f 00 00 	mova	r15,	0(r1)	;

00006b5c <.Loc.633.1>:
  devp->callback = cb;
    6b5c:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b60:	00 18 ec 41 	movx.a	@r1,	8(r12)	;
    6b64:	08 00 

00006b66 <.Loc.634.1>:
  palClearLine(devp->config->ss_line);
    6b66:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b6a:	0c 0c       	mova	@r12,	r12	;

00006b6c <.LVL154>:
    6b6c:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6b70:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6b74:	ff 0f 
    6b76:	ca 0c       	mova	r12,	r10	;
    6b78:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b7c:	0c 0c       	mova	@r12,	r12	;
    6b7e:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6b82:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6b86:	ff 0f 
    6b88:	19 4c 02 00 	mov	2(r12),	r9	;
    6b8c:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6b90:	0c 0c       	mova	@r12,	r12	;
    6b92:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6b96:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6b98:	40 18 3c 41 	popx.w	r12		;
    6b9c:	40 18 3d 41 	popx.w	r13		;
    6ba0:	b0 13 0c cd 	calla	#52492		;0x0cd0c

00006ba4 <.LVL155>:
    6ba4:	0d 12       	push	r13		;
    6ba6:	0c 12       	push	r12		;
    6ba8:	0c 16       	popm.a	#1,	r12	;20-bit words
    6baa:	40 18 0d 4c 	movx.w	r12,	r13	;
    6bae:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6bb0:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6bb4:	3c e3       	inv	r12		;
    6bb6:	0c f9       	and	r9,	r12	;
    6bb8:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006bbc <.Loc.635.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    6bbc:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6bc0:	0c 0c       	mova	@r12,	r12	;
    6bc2:	0c 0c       	mova	@r12,	r12	;
    6bc4:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6bc8:	b0 13 fe 58 	calla	#22782		;0x058fe

00006bcc <.LVL157>:
  devp->config->spicfgp->end_cb = spi_callback;
    6bcc:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6bd0:	0c 0c       	mova	@r12,	r12	;
    6bd2:	3c 0c 04 00 	mova	4(r12),	r12	;
    6bd6:	00 18 fc 40 	movx.a	#26798,	0(r12)	;0x068ae
    6bda:	ae 68 00 00 

00006bde <.Loc.637.1>:
  spiStartSendI(devp->config->spip, n, buffer);
    6bde:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6be2:	0c 0c       	mova	@r12,	r12	;
    6be4:	0c 0c       	mova	@r12,	r12	;
    6be6:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6bea:	00 00 
    6bec:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    6bf0:	0c 0c       	mova	@r12,	r12	;
    6bf2:	0c 0c       	mova	@r12,	r12	;
    6bf4:	3e 01 04 00 	mova	4(r1),	r14	;
    6bf8:	3d 01 08 00 	mova	8(r1),	r13	;
    6bfc:	b0 13 d4 58 	calla	#22740		;0x058d4

00006c00 <.LVL158>:
}
    6c00:	03 43       	nop			
    6c02:	a1 00 10 00 	adda	#16,	r1	;0x00010

00006c06 <.LVL159>:
    6c06:	19 16       	popm.a	#2,	r10	;20-bit words
    6c08:	10 01       	reta			;

00006c0a <sx1278StartTransmit>:

size_t sx1278StartTransmit(SX1278Driver * devp, size_t n, uint8_t * buffer, 
    palcallback_t pal_cb, spicallback_t spi_cb) {
    6c0a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006c0c <.LCFI19>:
    6c0c:	06 14       	pushm.a	#1,	r6	;20-bit words

00006c0e <.LCFI20>:
    6c0e:	04 14       	pushm.a	#1,	r4	;20-bit words

00006c10 <.LCFI21>:
    6c10:	b1 00 08 00 	suba	#8,	r1	;

00006c14 <.LCFI22>:
    6c14:	ca 0c       	mova	r12,	r10	;
    6c16:	c4 0d       	mova	r13,	r4	;
    6c18:	c6 0e       	mova	r14,	r6	;

00006c1a <.Loc.645.1>:
  
  /* We're in Sleep or Standby, TLS isn't started yet */
  /* Set FifoThreshold to 25% or packet size, whichever's smaller */
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6c1a:	78 40 18 00 	mov.b	#24,	r8	;#0x0018
    6c1e:	d8 0d       	cmpa	r13,	r8	;
    6c20:	62 28       	jnc	$+198    	;abs 0x6ce6

00006c22 <.Loc.645.1>:
    6c22:	4e 4d       	mov.b	r13,	r14	;

00006c24 <.LVL161>:
    6c24:	7e 53       	add.b	#-1,	r14	;r3 As==11
    6c26:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00006c2a <.L85>:
    6c2a:	88 00 c6 65 	mova	#26054,	r8	;0x065c6
    6c2e:	7d 40 35 00 	mov.b	#53,	r13	;#0x0035

00006c32 <.LVL162>:
    6c32:	cc 0a       	mova	r10,	r12	;

00006c34 <.LVL163>:
    6c34:	71 0f 00 00 	mova	r15,	0(r1)	;
    6c38:	48 13       	calla	r8		;

00006c3a <.LVL164>:
  /* Stop TLS */
  devp->regs.seq_config &= ~(0x80);
    6c3a:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6c3e:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    6c42:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006c46 <.Loc.648.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config | 0x40);
    6c46:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6c4a:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6c4e:	cc 0a       	mova	r10,	r12	;
    6c50:	48 13       	calla	r8		;

00006c52 <.LVL165>:
  /* Start TLS */
  devp->regs.seq_config |= 0x80;
    6c52:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6c56:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    6c5a:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006c5e <.Loc.651.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    6c5e:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6c62:	cc 0a       	mova	r10,	r12	;
    6c64:	48 13       	calla	r8		;

00006c66 <.LBB101>:
  _disable_interrupts();
    6c66:	32 c2       	dint			
    6c68:	03 43       	nop			

00006c6a <.Loc.348.3>:
  asm volatile("nop");
    6c6a:	03 43       	nop			

00006c6c <.LBE101>:
  
  /* Configure FifoLevel interrupt */
  chSysLock();
  palLineEnableEventI(devp->config->dio_map[devp->config->irq_map[SX1278FifoLevel]],
    6c6c:	0e 0a       	mova	@r10,	r14	;
    6c6e:	5c 4e 1d 00 	mov.b	29(r14),r12	;0x0001d
    6c72:	0d 43       	clr	r13		;
    6c74:	08 4c       	mov	r12,	r8	;
    6c76:	09 4d       	mov	r13,	r9	;
    6c78:	08 58       	rla	r8		;
    6c7a:	09 69       	rlc	r9		;
    6c7c:	08 58       	rla	r8		;
    6c7e:	09 69       	rlc	r9		;
    6c80:	81 48 04 00 	mov	r8,	4(r1)	;
    6c84:	81 49 06 00 	mov	r9,	6(r1)	;
    6c88:	00 18 5e 51 	addx.a	4(r1),	r14	;
    6c8c:	04 00 
    6c8e:	38 0e 2e 00 	mova	46(r14),r8	;0x0002e
    6c92:	08 14       	pushm.a	#1,	r8	;20-bit words
    6c94:	40 18 3c 41 	popx.w	r12		;
    6c98:	40 18 3d 41 	popx.w	r13		;
    6c9c:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6ca0:	0d 12       	push	r13		;
    6ca2:	0c 12       	push	r12		;
    6ca4:	0c 16       	popm.a	#1,	r12	;20-bit words
    6ca6:	0f 01       	mova	@r1,	r15	;
    6ca8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6caa:	4d 4c       	mov.b	r12,	r13	;
    6cac:	cc 08       	mova	r8,	r12	;
    6cae:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6cb2:	ff 0f 
    6cb4:	b0 13 70 53 	calla	#21360		;0x05370

00006cb8 <.LBB103>:
  asm volatile("nop");
    6cb8:	03 43       	nop			

00006cba <.Loc.356.3>:
  _enable_interrupts();
    6cba:	03 43       	nop			
    6cbc:	32 d2       	eint			
    6cbe:	03 43       	nop			

00006cc0 <.LBE103>:
      PAL_EVENT_MODE_FALLING_EDGE, pal_cb);
  chSysUnlock();
  /* Fill the FIFO */
  uint8_t to_write = (n > 47 ? 47 : n);
    6cc0:	79 40 2f 00 	mov.b	#47,	r9	;#0x002f
    6cc4:	d9 04       	cmpa	r4,	r9	;
    6cc6:	01 2c       	jc	$+4      	;abs 0x6cca
    6cc8:	c4 09       	mova	r9,	r4	;

00006cca <.L86>:
  sx1278FifoWriteAsync(devp, to_write, buffer, spi_cb);
    6cca:	3f 01 20 00 	mova	32(r1),	r15	;0x00020
    6cce:	ce 06       	mova	r6,	r14	;
    6cd0:	cd 04       	mova	r4,	r13	;
    6cd2:	cc 0a       	mova	r10,	r12	;
    6cd4:	b0 13 90 6a 	calla	#27280		;0x06a90

00006cd8 <.LVL170>:
  return to_write;
}
    6cd8:	cc 04       	mova	r4,	r12	;
    6cda:	a1 00 08 00 	adda	#8,	r1	;
    6cde:	04 16       	popm.a	#1,	r4	;20-bit words
    6ce0:	06 16       	popm.a	#1,	r6	;20-bit words
    6ce2:	28 16       	popm.a	#3,	r10	;20-bit words
    6ce4:	10 01       	reta			;

00006ce6 <.L87>:
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6ce6:	7e 40 17 00 	mov.b	#23,	r14	;#0x0017
    6cea:	80 00 2a 6c 	mova	#27690,	r0	;0x06c2a

00006cee <sx1278Reset.isra.1>:
static void sx1278Reset(SX1278Driver *devp) {
    6cee:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006cf0 <.LCFI25>:
    6cf0:	06 14       	pushm.a	#1,	r6	;20-bit words

00006cf2 <.LCFI26>:
    6cf2:	ca 0c       	mova	r12,	r10	;

00006cf4 <.Loc.308.1>:
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
    6cf4:	0c 0c       	mova	@r12,	r12	;
    6cf6:	00 18 cc 93 	cmpx.a	#0,	30(r12)	;r3 As==00, 0x0001e
    6cfa:	1e 00 
    6cfc:	04 20       	jnz	$+10     	;abs 0x6d06
    6cfe:	8c 01 ab 05 	mova	#66987,	r12	;0x105ab
    6d02:	b0 13 3e 46 	calla	#17982		;0x0463e

00006d06 <.L128>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    6d06:	0c 0a       	mova	@r10,	r12	;
    6d08:	38 0c 1e 00 	mova	30(r12),r8	;0x0001e
    6d0c:	08 14       	pushm.a	#1,	r8	;20-bit words
    6d0e:	40 18 3c 41 	popx.w	r12		;
    6d12:	40 18 3d 41 	popx.w	r13		;
    6d16:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6d1a:	0d 12       	push	r13		;
    6d1c:	0c 12       	push	r12		;
    6d1e:	0c 16       	popm.a	#1,	r12	;20-bit words
    6d20:	40 18 0d 4c 	movx.w	r12,	r13	;
    6d24:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d26:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6d2a:	86 00 80 52 	mova	#21120,	r6	;0x05280
    6d2e:	7e 40 06 00 	mov.b	#6,	r14	;
    6d32:	0d 4c       	mov	r12,	r13	;
    6d34:	cc 08       	mova	r8,	r12	;
    6d36:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6d3a:	ff 0f 
    6d3c:	46 13       	calla	r6		;

00006d3e <.LVL205>:
  palClearLine(devp->config->reset_line);
    6d3e:	0c 0a       	mova	@r10,	r12	;
    6d40:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    6d44:	c8 0c       	mova	r12,	r8	;
    6d46:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6d4a:	ff 0f 
    6d4c:	19 48 02 00 	mov	2(r8),	r9	;
    6d50:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6d52:	40 18 3c 41 	popx.w	r12		;
    6d56:	40 18 3d 41 	popx.w	r13		;
    6d5a:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6d5e:	0d 12       	push	r13		;
    6d60:	0c 12       	push	r12		;
    6d62:	0c 16       	popm.a	#1,	r12	;20-bit words
    6d64:	40 18 0d 4c 	movx.w	r12,	r13	;
    6d68:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d6a:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6d6e:	09 cc       	bic	r12,	r9	;
    6d70:	88 49 02 00 	mov	r9,	2(r8)	;

00006d74 <.LBB117>:
  chThdSleep(time);
    6d74:	88 00 9a 48 	mova	#18586,	r8	;0x0489a
    6d78:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d7a:	48 13       	calla	r8		;

00006d7c <.LBE117>:
  palSetLine(devp->config->reset_line);
    6d7c:	0c 0a       	mova	@r10,	r12	;
    6d7e:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    6d82:	ca 0c       	mova	r12,	r10	;
    6d84:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6d88:	ff 0f 
    6d8a:	19 4a 02 00 	mov	2(r10),	r9	;
    6d8e:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6d90:	40 18 3c 41 	popx.w	r12		;
    6d94:	40 18 3d 41 	popx.w	r13		;
    6d98:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6d9c:	0d 12       	push	r13		;
    6d9e:	0c 12       	push	r12		;
    6da0:	0c 16       	popm.a	#1,	r12	;20-bit words
    6da2:	40 18 0d 4c 	movx.w	r12,	r13	;
    6da6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6da8:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6dac:	09 dc       	bis	r12,	r9	;
    6dae:	8a 49 02 00 	mov	r9,	2(r10)	;

00006db2 <.Loc.314.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLUP);
    6db2:	7e 40 03 00 	mov.b	#3,	r14	;
    6db6:	0d 4c       	mov	r12,	r13	;
    6db8:	cc 0a       	mova	r10,	r12	;
    6dba:	46 13       	calla	r6		;

00006dbc <.LBB119>:
    6dbc:	7c 40 05 00 	mov.b	#5,	r12	;
    6dc0:	48 13       	calla	r8		;

00006dc2 <.LBE119>:
}
    6dc2:	06 16       	popm.a	#1,	r6	;20-bit words
    6dc4:	28 16       	popm.a	#3,	r10	;20-bit words
    6dc6:	10 01       	reta			;

00006dc8 <sx1278SetMode.constprop.4>:
static void sx1278SetMode(SX1278Driver *devp, SX1278ModeConstants mode) {
    6dc8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006dca <.LCFI27>:
    6dca:	ca 0c       	mova	r12,	r10	;

00006dcc <.Loc.329.1>:
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    6dcc:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    6dd0:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    6dd4:	cc 4e 05 00 	mov.b	r14,	5(r12)	;

00006dd8 <.Loc.330.1>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    6dd8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6dda:	b0 13 c6 65 	calla	#26054		;0x065c6

00006dde <.LVL216>:
}
    6dde:	0a 16       	popm.a	#1,	r10	;20-bit words
    6de0:	10 01       	reta			;

00006de2 <blockuntil_callback>:
  chThdResumeI(trp, msg);
    6de2:	4d 43       	clr.b	r13		;
    6de4:	8c 01 de 16 	mova	#71390,	r12	;0x116de
    6de8:	b0 13 6e 48 	calla	#18542		;0x0486e

00006dec <.LBE37>:

static void blockuntil_callback(void) {
  osalSysLockFromISR();
  osalThreadResumeI(&tr, MSG_OK);
  osalSysUnlockFromISR();
}
    6dec:	10 01       	reta			;

00006dee <sx1212SetRegister.isra.0>:
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1212SetRegister(SX1212Driver *devp, uint8_t reg, 
    6dee:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006df0 <.LCFI1>:
    6df0:	ca 0c       	mova	r12,	r10	;
    6df2:	49 4d       	mov.b	r13,	r9	;
    6df4:	47 4e       	mov.b	r14,	r7	;

00006df6 <.Loc.173.1>:
    uint8_t value) {
  
  osalDbgAssert(reg <= 30, "register address out of bounds");
    6df6:	7c 40 1e 00 	mov.b	#30,	r12	;#0x001e
    6dfa:	4c 99       	cmp.b	r9,	r12	;
    6dfc:	1b 2c       	jc	$+56     	;abs 0x6e34

00006dfe <.L6>:
    6dfe:	8c 01 ff 06 	mova	#67327,	r12	;0x106ff
    6e02:	b0 13 3e 46 	calla	#17982		;0x0463e

00006e06 <.L5>:
  osalDbgAssert(reg != 20, "setting read-only registers");
  
  /* 00xxxxx0 */
  reg = (reg << 1);
  
  spiSelectI(devp->config->spip);
    6e06:	0c 0a       	mova	@r10,	r12	;
    6e08:	0c 0c       	mova	@r12,	r12	;
    6e0a:	b0 13 be 57 	calla	#22462		;0x057be

00006e0e <.LVL8>:
  spiPolledExchange(devp->config->spip, reg);
    6e0e:	0c 0a       	mova	@r10,	r12	;
    6e10:	88 00 fe 58 	mova	#22782,	r8	;0x058fe
    6e14:	0d 49       	mov	r9,	r13	;
    6e16:	0d 5d       	rla	r13		;
    6e18:	0c 0c       	mova	@r12,	r12	;
    6e1a:	48 13       	calla	r8		;

00006e1c <.LVL9>:
  reg = spiPolledExchange(devp->config->spip, value);
    6e1c:	0c 0a       	mova	@r10,	r12	;
    6e1e:	4d 47       	mov.b	r7,	r13	;
    6e20:	0c 0c       	mova	@r12,	r12	;
    6e22:	48 13       	calla	r8		;

00006e24 <.LVL10>:
    6e24:	49 4c       	mov.b	r12,	r9	;

00006e26 <.LVL11>:
  spiUnselectI(devp->config->spip);
    6e26:	0c 0a       	mova	@r10,	r12	;
    6e28:	0c 0c       	mova	@r12,	r12	;
    6e2a:	b0 13 02 58 	calla	#22530		;0x05802

00006e2e <.LVL12>:
  
  return reg;
}
    6e2e:	4c 49       	mov.b	r9,	r12	;
    6e30:	37 16       	popm.a	#4,	r10	;20-bit words
    6e32:	10 01       	reta			;

00006e34 <.L4>:
  osalDbgAssert(reg != 20, "setting read-only registers");
    6e34:	39 90 14 00 	cmp	#20,	r9	;#0x0014
    6e38:	e6 23       	jnz	$-50     	;abs 0x6e06
    6e3a:	80 00 fe 6d 	mova	#28158,	r0	;0x06dfe

00006e3e <sx1212SetMode>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1212SetMode(SX1212Driver *devp, SX1212ModeConstants mode) {
    6e3e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006e40 <.LCFI2>:
    6e40:	ca 0c       	mova	r12,	r10	;

00006e42 <.Loc.607.1>:
  
  devp->regs.MCParam0 = (devp->regs.MCParam0 & 0x1F) | mode;
    6e42:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    6e46:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    6e4a:	4e dd       	bis.b	r13,	r14	;
    6e4c:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

00006e50 <.Loc.608.1>:
  sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    6e50:	4d 43       	clr.b	r13		;

00006e52 <.LVL15>:
    6e52:	b0 13 ee 6d 	calla	#28142		;0x06dee

00006e56 <.LVL16>:
}
    6e56:	0a 16       	popm.a	#1,	r10	;20-bit words
    6e58:	10 01       	reta			;

00006e5a <sx1212SetFifoThreshold>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] thresh  the threshold to set
 */
static void sx1212SetFifoThreshold(SX1212Driver *devp, uint8_t thresh) {
    6e5a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006e5c <.LCFI3>:
    6e5c:	08 14       	pushm.a	#1,	r8	;20-bit words

00006e5e <.LCFI4>:
    6e5e:	c8 0c       	mova	r12,	r8	;
    6e60:	4a 4d       	mov.b	r13,	r10	;

00006e62 <.Loc.706.1>:
  
  osalDbgAssert(thresh < 64, "threshold too high");
    6e62:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f

00006e66 <.LVL18>:
    6e66:	4c 9a       	cmp.b	r10,	r12	;
    6e68:	04 2c       	jc	$+10     	;abs 0x6e72

00006e6a <.Loc.706.1>:
    6e6a:	8c 01 62 06 	mova	#67170,	r12	;0x10662
    6e6e:	b0 13 3e 46 	calla	#17982		;0x0463e

00006e72 <.L12>:
  
  sx1212SetRegister(devp, IRQParam0, (0xC0 | thresh));
    6e72:	7a d0 c0 ff 	bis.b	#-64,	r10	;#0xffc0

00006e76 <.LVL20>:
    6e76:	4e 4a       	mov.b	r10,	r14	;
    6e78:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    6e7c:	cc 08       	mova	r8,	r12	;
    6e7e:	b0 13 ee 6d 	calla	#28142		;0x06dee

00006e82 <.LVL21>:
  devp->regs.IRQParam0 = (0xC0 | thresh);
    6e82:	c8 4a 05 00 	mov.b	r10,	5(r8)	;

00006e86 <.Loc.710.1>:
}
    6e86:	08 16       	popm.a	#1,	r8	;20-bit words
    6e88:	0a 16       	popm.a	#1,	r10	;20-bit words
    6e8a:	10 01       	reta			;

00006e8c <sx1212Reset.isra.2>:
static void sx1212Reset(SX1212Driver *devp) {
    6e8c:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006e8e <.LCFI5>:
    6e8e:	ca 0c       	mova	r12,	r10	;

00006e90 <.Loc.586.1>:
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
    6e90:	0c 0c       	mova	@r12,	r12	;
    6e92:	00 18 cc 93 	cmpx.a	#0,	34(r12)	;r3 As==00, 0x00022
    6e96:	22 00 
    6e98:	04 20       	jnz	$+10     	;abs 0x6ea2
    6e9a:	8c 01 9f 06 	mova	#67231,	r12	;0x1069f
    6e9e:	b0 13 3e 46 	calla	#17982		;0x0463e

00006ea2 <.L14>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    6ea2:	0c 0a       	mova	@r10,	r12	;
    6ea4:	38 0c 22 00 	mova	34(r12),r8	;0x00022
    6ea8:	08 14       	pushm.a	#1,	r8	;20-bit words
    6eaa:	40 18 3c 41 	popx.w	r12		;
    6eae:	40 18 3d 41 	popx.w	r13		;
    6eb2:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6eb6:	0d 12       	push	r13		;
    6eb8:	0c 12       	push	r12		;
    6eba:	0c 16       	popm.a	#1,	r12	;20-bit words
    6ebc:	40 18 0d 4c 	movx.w	r12,	r13	;
    6ec0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ec2:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6ec6:	86 00 80 52 	mova	#21120,	r6	;0x05280
    6eca:	7e 40 06 00 	mov.b	#6,	r14	;
    6ece:	0d 4c       	mov	r12,	r13	;
    6ed0:	cc 08       	mova	r8,	r12	;
    6ed2:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6ed6:	ff 0f 
    6ed8:	46 13       	calla	r6		;

00006eda <.LVL25>:
  palSetLine(devp->config->reset_line);
    6eda:	0c 0a       	mova	@r10,	r12	;
    6edc:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6ee0:	c8 0c       	mova	r12,	r8	;
    6ee2:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6ee6:	ff 0f 
    6ee8:	19 48 02 00 	mov	2(r8),	r9	;
    6eec:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6eee:	40 18 3c 41 	popx.w	r12		;
    6ef2:	40 18 3d 41 	popx.w	r13		;
    6ef6:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6efa:	0d 12       	push	r13		;
    6efc:	0c 12       	push	r12		;
    6efe:	0c 16       	popm.a	#1,	r12	;20-bit words
    6f00:	40 18 0d 4c 	movx.w	r12,	r13	;
    6f04:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f06:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6f0a:	0c d9       	bis	r9,	r12	;
    6f0c:	88 4c 02 00 	mov	r12,	2(r8)	;

00006f10 <.LBB39>:
  chThdSleep(time);
    6f10:	88 00 9a 48 	mova	#18586,	r8	;0x0489a
    6f14:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f16:	48 13       	calla	r8		;

00006f18 <.LBE39>:
  palClearLine(devp->config->reset_line);
    6f18:	0c 0a       	mova	@r10,	r12	;
    6f1a:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6f1e:	ca 0c       	mova	r12,	r10	;
    6f20:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6f24:	ff 0f 
    6f26:	19 4a 02 00 	mov	2(r10),	r9	;
    6f2a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6f2c:	40 18 3c 41 	popx.w	r12		;
    6f30:	40 18 3d 41 	popx.w	r13		;
    6f34:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    6f38:	0d 12       	push	r13		;
    6f3a:	0c 12       	push	r12		;
    6f3c:	0c 16       	popm.a	#1,	r12	;20-bit words
    6f3e:	40 18 07 4c 	movx.w	r12,	r7	;
    6f42:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f44:	0d 47       	mov	r7,	r13	;
    6f46:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6f4a:	09 cc       	bic	r12,	r9	;
    6f4c:	8a 49 02 00 	mov	r9,	2(r10)	;

00006f50 <.Loc.592.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLDOWN);
    6f50:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f52:	0d 47       	mov	r7,	r13	;
    6f54:	b0 13 ec cb 	calla	#52204		;0x0cbec
    6f58:	6e 42       	mov.b	#4,	r14	;r2 As==10
    6f5a:	0d 4c       	mov	r12,	r13	;
    6f5c:	cc 0a       	mova	r10,	r12	;
    6f5e:	46 13       	calla	r6		;

00006f60 <.LBB41>:
    6f60:	7c 40 05 00 	mov.b	#5,	r12	;
    6f64:	48 13       	calla	r8		;

00006f66 <.LBE41>:
}
    6f66:	46 16       	popm.a	#5,	r10	;20-bit words
    6f68:	10 01       	reta			;

00006f6a <irq_block_with_timeout.isra.3>:
static msg_t irq_block_with_timeout(SX1212Driver *devp, ioline_t irq, 
    6f6a:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006f6c <.LCFI6>:
    6f6c:	07 4d       	mov	r13,	r7	;

00006f6e <.LBB53>:
  _disable_interrupts();
    6f6e:	32 c2       	dint			
    6f70:	03 43       	nop			

00006f72 <.Loc.348.3>:
  asm volatile("nop");
    6f72:	03 43       	nop			

00006f74 <.LBE53>:
  palLineEnableEventI(irq, PAL_EVENT_MODE_RISING_EDGE, blockuntil_callback); 
    6f74:	c8 0c       	mova	r12,	r8	;
    6f76:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6f7a:	ff 0f 
    6f7c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6f7e:	40 18 3c 41 	popx.w	r12		;
    6f82:	40 18 3d 41 	popx.w	r13		;

00006f86 <.LVL37>:
    6f86:	b0 13 0c cd 	calla	#52492		;0x0cd0c

00006f8a <.LVL38>:
    6f8a:	0d 12       	push	r13		;
    6f8c:	0c 12       	push	r12		;
    6f8e:	0a 16       	popm.a	#1,	r10	;20-bit words
    6f90:	0a 14       	pushm.a	#1,	r10	;20-bit words
    6f92:	40 18 3c 41 	popx.w	r12		;
    6f96:	40 18 3d 41 	popx.w	r13		;
    6f9a:	49 4c       	mov.b	r12,	r9	;
    6f9c:	8f 00 e2 6d 	mova	#28130,	r15	;0x06de2
    6fa0:	5e 43       	mov.b	#1,	r14	;r3 As==01
    6fa2:	4d 4c       	mov.b	r12,	r13	;
    6fa4:	cc 08       	mova	r8,	r12	;
    6fa6:	b0 13 70 53 	calla	#21360		;0x05370

00006faa <.LVL39>:
  if (palReadLine(irq)) {
    6faa:	40 18 0d 4a 	movx.w	r10,	r13	;
    6fae:	2c 48       	mov	@r8,	r12	;
    6fb0:	b0 13 f4 cc 	calla	#52468		;0x0ccf4
    6fb4:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    6fb8:	0f 24       	jz	$+32     	;abs 0x6fd8

00006fba <.Loc.243.1>:
    suspend_result = MSG_OK;
    6fba:	00 18 c2 43 	movx.a	#0,	&0xfcff0;r3 As==00
    6fbe:	f0 cf 

00006fc0 <.L17>:
  palLineDisableEventI(irq);
    6fc0:	4d 49       	mov.b	r9,	r13	;
    6fc2:	cc 08       	mova	r8,	r12	;
    6fc4:	b0 13 5e 54 	calla	#21598		;0x0545e

00006fc8 <.LBB56>:
  asm volatile("nop");
    6fc8:	03 43       	nop			

00006fca <.Loc.356.3>:
  _enable_interrupts();
    6fca:	03 43       	nop			
    6fcc:	32 d2       	eint			
    6fce:	03 43       	nop			

00006fd0 <.LBE56>:
}
    6fd0:	2c 00 f0 cf 	mova	&53232,	r12	;0x0cff0
    6fd4:	37 16       	popm.a	#4,	r10	;20-bit words
    6fd6:	10 01       	reta			;

00006fd8 <.L16>:
  return chThdSuspendTimeoutS(trp, timeout);
    6fd8:	0d 47       	mov	r7,	r13	;
    6fda:	8c 01 de 16 	mova	#71390,	r12	;0x116de
    6fde:	b0 13 3e 48 	calla	#18494		;0x0483e

00006fe2 <.LBE59>:
    suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    6fe2:	60 0c f0 cf 	mova	r12,	&53232	; 0x0cff0
    6fe6:	80 00 c0 6f 	mova	#28608,	r0	;0x06fc0

00006fea <spi_mode_config>:
  devp->config->spicfgp->end_cb = NULL;
    6fea:	0c 0c       	mova	@r12,	r12	;

00006fec <.LVL45>:
    6fec:	3e 0c 04 00 	mova	4(r12),	r14	;
    6ff0:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    6ff4:	00 00 

00006ff6 <.Loc.66.1>:
  devp->config->spip->regs->ctlw0 &= ~UCMODE1;
    6ff6:	0c 0c       	mova	@r12,	r12	;
    6ff8:	3c 0c 0a 00 	mova	10(r12),r12	;0x0000a
    6ffc:	bc f0 ff fb 	and	#-1025,	0(r12)	;#0xfbff
    7000:	00 00 

00007002 <.Loc.67.1>:
}
    7002:	10 01       	reta			;

00007004 <sx1212SetBitrate>:
void sx1212SetBitrate(SX1212Driver *devp, uint32_t rate) {
    7004:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007006 <.LCFI8>:
    7006:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

0000700a <.LCFI9>:
    700a:	c6 0c       	mova	r12,	r6	;
    700c:	09 4d       	mov	r13,	r9	;
    700e:	0a 4e       	mov	r14,	r10	;

00007010 <.Loc.419.1>:
  osalDbgAssert(rate < 150000, "bit rate too high");
    7010:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007012 <.LVL55>:
    7012:	0c 9e       	cmp	r14,	r12	;
    7014:	06 28       	jnc	$+14     	;abs 0x7022
    7016:	0e 9c       	cmp	r12,	r14	;
    7018:	08 20       	jnz	$+18     	;abs 0x702a
    701a:	3d 40 ef 49 	mov	#18927,	r13	;#0x49ef

0000701e <.LVL56>:
    701e:	0d 99       	cmp	r9,	r13	;
    7020:	04 2c       	jc	$+10     	;abs 0x702a

00007022 <.L34>:
    7022:	8c 01 11 07 	mova	#67345,	r12	;0x10711
    7026:	b0 13 3e 46 	calla	#17982		;0x0463e

0000702a <.L24>:
  rate = (SX1212_CLK_FREQ >> 1)/rate;
    702a:	88 00 b6 cb 	mova	#52150,	r8	;0x0cbb6
    702e:	0e 49       	mov	r9,	r14	;
    7030:	0f 4a       	mov	r10,	r15	;
    7032:	3c 40 00 a8 	mov	#-22528,r12	;#0xa800
    7036:	7d 40 61 00 	mov.b	#97,	r13	;#0x0061
    703a:	48 13       	calla	r8		;

0000703c <.LVL58>:
    703c:	0a 4c       	mov	r12,	r10	;
    703e:	09 4d       	mov	r13,	r9	;

00007040 <.LVL59>:
  if (rate - 1 <= 255) {
    7040:	3c 53       	add	#-1,	r12	;r3 As==11
    7042:	07 4d       	mov	r13,	r7	;
    7044:	37 63       	addc	#-1,	r7	;r3 As==11
    7046:	07 93       	cmp	#0,	r7	;r3 As==00
    7048:	13 20       	jnz	$+40     	;abs 0x7070
    704a:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    704e:	0d 9c       	cmp	r12,	r13	;
    7050:	0f 28       	jnc	$+32     	;abs 0x7070

00007052 <.Loc.425.1>:
    sx1212SetRegister(devp, MCParam3, (rate & 0x00FF));
    7052:	88 00 ee 6d 	mova	#28142,	r8	;0x06dee
    7056:	4e 4a       	mov.b	r10,	r14	;
    7058:	7d 40 03 00 	mov.b	#3,	r13	;
    705c:	cc 06       	mova	r6,	r12	;
    705e:	48 13       	calla	r8		;

00007060 <.LVL60>:
    sx1212SetRegister(devp, MCParam4, 0);
    7060:	4e 47       	mov.b	r7,	r14	;
    7062:	6d 42       	mov.b	#4,	r13	;r2 As==10
    7064:	cc 06       	mova	r6,	r12	;
    7066:	48 13       	calla	r8		;

00007068 <.L23>:
}
    7068:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    706c:	64 16       	popm.a	#7,	r10	;20-bit words
    706e:	10 01       	reta			;

00007070 <.L26>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    7070:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    7074:	4f 43       	clr.b	r15		;
    7076:	0c 4a       	mov	r10,	r12	;
    7078:	0d 49       	mov	r9,	r13	;
    707a:	48 13       	calla	r8		;
    707c:	05 4c       	mov	r12,	r5	;
    707e:	15 53       	inc	r5		;

00007080 <.LBE64>:
    uint8_t bestd = 0;
    7080:	48 43       	clr.b	r8		;

00007082 <.Loc.429.1>:
    uint8_t bestc = 0;
    7082:	07 48       	mov	r8,	r7	;

00007084 <.LBB65>:
      err = rate - (tmp * i);
    7084:	84 00 8c cd 	mova	#52620,	r4	;0x0cd8c

00007088 <.Loc.442.1>:
      if (err == 0 || i*i > rate) break;
    7088:	81 4a 08 00 	mov	r10,	8(r1)	;

0000708c <.L29>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    708c:	7c 40 5c 00 	mov.b	#92,	r12	;#0x005c
    7090:	0c 95       	cmp	r5,	r12	;
    7092:	0d 2c       	jc	$+28     	;abs 0x70ae

00007094 <.L31>:
    sx1212SetRegister(devp, MCParam3, bestc);
    7094:	8a 00 ee 6d 	mova	#28142,	r10	;0x06dee

00007098 <.LVL67>:
    7098:	4e 47       	mov.b	r7,	r14	;
    709a:	7d 40 03 00 	mov.b	#3,	r13	;
    709e:	cc 06       	mova	r6,	r12	;
    70a0:	4a 13       	calla	r10		;

000070a2 <.LVL68>:
    sx1212SetRegister(devp, MCParam4, bestd);
    70a2:	4e 48       	mov.b	r8,	r14	;
    70a4:	6d 42       	mov.b	#4,	r13	;r2 As==10
    70a6:	cc 06       	mova	r6,	r12	;
    70a8:	4a 13       	calla	r10		;

000070aa <.LBE63>:
}
    70aa:	80 00 68 70 	mova	#28776,	r0	;0x07068

000070ae <.L33>:
      tmp = rate / i;
    70ae:	0e 45       	mov	r5,	r14	;
    70b0:	0f 43       	clr	r15		;
    70b2:	0c 4a       	mov	r10,	r12	;
    70b4:	0d 49       	mov	r9,	r13	;
    70b6:	b0 13 b6 cb 	calla	#52150		;0x0cbb6

000070ba <.Loc.437.1>:
      err = rate - (tmp * i);
    70ba:	4e 4c       	mov.b	r12,	r14	;
    70bc:	4f 45       	mov.b	r5,	r15	;
    70be:	0d 4f       	mov	r15,	r13	;
    70c0:	0c 4e       	mov	r14,	r12	;
    70c2:	71 0e 04 00 	mova	r14,	4(r1)	;
    70c6:	71 0f 00 00 	mova	r15,	0(r1)	;
    70ca:	44 13       	calla	r4		;
    70cc:	4d 4a       	mov.b	r10,	r13	;
    70ce:	4d 8c       	sub.b	r12,	r13	;
    70d0:	4c 4d       	mov.b	r13,	r12	;
    70d2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000070d6 <.LVL73>:
      if (err < besterr) {
    70d6:	3e 01 04 00 	mova	4(r1),	r14	;
    70da:	0f 01       	mova	@r1,	r15	;
    70dc:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    70de:	06 24       	jz	$+14     	;abs 0x70ec
    70e0:	7f 53       	add.b	#-1,	r15	;r3 As==11
    70e2:	47 4f       	mov.b	r15,	r7	;

000070e4 <.LVL74>:
        bestd = tmp - 1;
    70e4:	7e 53       	add.b	#-1,	r14	;r3 As==11
    70e6:	48 4e       	mov.b	r14,	r8	;

000070e8 <.LVL75>:
      if (err == 0 || i*i > rate) break;
    70e8:	0d 93       	cmp	#0,	r13	;r3 As==00
    70ea:	d4 27       	jz	$-86     	;abs 0x7094

000070ec <.L30>:
    70ec:	0d 45       	mov	r5,	r13	;
    70ee:	0c 45       	mov	r5,	r12	;

000070f0 <.LVL77>:
    70f0:	44 13       	calla	r4		;
    70f2:	4d 43       	clr.b	r13		;
    70f4:	0d 99       	cmp	r9,	r13	;
    70f6:	03 20       	jnz	$+8      	;abs 0x70fe
    70f8:	81 9c 08 00 	cmp	r12,	8(r1)	;
    70fc:	cb 2b       	jnc	$-104    	;abs 0x7094

000070fe <.L36>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    70fe:	15 53       	inc	r5		;
    7100:	80 00 8c 70 	mova	#28812,	r0	;0x0708c

00007104 <sx1212SetDeviation>:
void sx1212SetDeviation(SX1212Driver *devp, uint32_t fdev) {
    7104:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007106 <.LCFI10>:
    7106:	ca 0c       	mova	r12,	r10	;
    7108:	08 4d       	mov	r13,	r8	;
    710a:	09 4e       	mov	r14,	r9	;

0000710c <.Loc.459.1>:
  uint16_t regs = ((SX1212_CLK_FREQ >> 5) + (fdev >> 1))/ fdev;
    710c:	06 4d       	mov	r13,	r6	;
    710e:	07 4e       	mov	r14,	r7	;
    7110:	12 c3       	clrc			
    7112:	07 10       	rrc	r7		;
    7114:	06 10       	rrc	r6		;
    7116:	0e 4d       	mov	r13,	r14	;
    7118:	0f 49       	mov	r9,	r15	;
    711a:	0c 46       	mov	r6,	r12	;

0000711c <.LVL81>:
    711c:	3c 50 80 1a 	add	#6784,	r12	;#0x1a80
    7120:	0d 47       	mov	r7,	r13	;

00007122 <.LVL82>:
    7122:	3d 60 06 00 	addc	#6,	r13	;
    7126:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    712a:	07 4c       	mov	r12,	r7	;

0000712c <.Loc.461.1>:
  osalDbgAssert(fdev < 200000, "deviation too high");
    712c:	7c 40 03 00 	mov.b	#3,	r12	;
    7130:	0c 99       	cmp	r9,	r12	;
    7132:	07 28       	jnc	$+16     	;abs 0x7142
    7134:	39 90 03 00 	cmp	#3,	r9	;
    7138:	08 20       	jnz	$+18     	;abs 0x714a
    713a:	3c 40 3f 0d 	mov	#3391,	r12	;#0x0d3f
    713e:	0c 98       	cmp	r8,	r12	;
    7140:	04 2c       	jc	$+10     	;abs 0x714a

00007142 <.L46>:
    7142:	8c 01 ec 06 	mova	#67308,	r12	;0x106ec
    7146:	b0 13 3e 46 	calla	#17982		;0x0463e

0000714a <.L44>:
  sx1212SetRegister(devp, MCParam2, regs - 1);
    714a:	4e 47       	mov.b	r7,	r14	;
    714c:	7e 53       	add.b	#-1,	r14	;r3 As==11
    714e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7150:	cc 0a       	mova	r10,	r12	;
    7152:	b0 13 ee 6d 	calla	#28142		;0x06dee

00007156 <.LVL86>:
}
    7156:	46 16       	popm.a	#5,	r10	;20-bit words
    7158:	10 01       	reta			;

0000715a <sx1212SetFrequency>:
void sx1212SetFrequency(SX1212Driver *devp, uint32_t freq) {
    715a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000715c <.LCFI11>:
    715c:	b1 00 16 00 	suba	#22,	r1	;0x00016

00007160 <.LCFI12>:
    7160:	c4 0c       	mova	r12,	r4	;
    7162:	0a 4d       	mov	r13,	r10	;
    7164:	05 4e       	mov	r14,	r5	;

00007166 <.Loc.479.1>:
  osalDbgAssert(freq >= 300000000 && freq <= 510000000, 
    7166:	0c 4d       	mov	r13,	r12	;

00007168 <.LVL88>:
    7168:	3c 50 00 5d 	add	#23808,	r12	;#0x5d00
    716c:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    7170:	0d 4e       	mov	r14,	r13	;

00007172 <.LVL89>:
    7172:	3d 60 1e ee 	addc	#-4578,	r13	;#0xee1e
    7176:	81 4d 04 00 	mov	r13,	4(r1)	;
    717a:	3e 40 84 0c 	mov	#3204,	r14	;#0x0c84
    717e:	0e 9d       	cmp	r13,	r14	;
    7180:	07 28       	jnc	$+16     	;abs 0x7190
    7182:	0d 9e       	cmp	r14,	r13	;
    7184:	09 20       	jnz	$+20     	;abs 0x7198
    7186:	3c 40 80 58 	mov	#22656,	r12	;#0x5880
    718a:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    718e:	04 2c       	jc	$+10     	;abs 0x7198

00007190 <.L82>:
    7190:	8c 01 d9 06 	mova	#67289,	r12	;0x106d9
    7194:	b0 13 3e 46 	calla	#17982		;0x0463e

00007198 <.L48>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    7198:	0c 4a       	mov	r10,	r12	;
    719a:	0d 45       	mov	r5,	r13	;
    719c:	b0 13 22 cc 	calla	#52258		;0x0cc22
    71a0:	81 4c 06 00 	mov	r12,	6(r1)	;
    71a4:	81 4d 08 00 	mov	r13,	8(r1)	;

000071a8 <.LBB71>:
  osalDbgAssert(u != 0 && v != 0, "doesn't support 0s");
    71a8:	0c dd       	bis	r13,	r12	;

000071aa <.LVL93>:
    71aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    71ac:	04 20       	jnz	$+10     	;abs 0x71b6
    71ae:	8c 01 d5 06 	mova	#67285,	r12	;0x106d5
    71b2:	b0 13 3e 46 	calla	#17982		;0x0463e

000071b6 <.L50>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    71b6:	18 41 06 00 	mov	6(r1),	r8	;
    71ba:	19 41 08 00 	mov	8(r1),	r9	;
    71be:	4e 43       	clr.b	r14		;
    71c0:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    71c4:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd

000071c8 <.L51>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    71c8:	0f 48       	mov	r8,	r15	;
    71ca:	0f dc       	bis	r12,	r15	;
    71cc:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    71d0:	b9 24       	jz	$+372    	;abs 0x7344

000071d2 <.L54>:
  while((u & 1) == 0)
    71d2:	0f 48       	mov	r8,	r15	;
    71d4:	5f f3       	and.b	#1,	r15	;r3 As==01
    71d6:	0f 93       	cmp	#0,	r15	;r3 As==00
    71d8:	be 24       	jz	$+382    	;abs 0x7356

000071da <.L57>:
    while ((v & 1) == 0)
    71da:	0f 4c       	mov	r12,	r15	;
    71dc:	5f f3       	and.b	#1,	r15	;r3 As==01
    71de:	0f 93       	cmp	#0,	r15	;r3 As==00
    71e0:	bf 24       	jz	$+384    	;abs 0x7360

000071e2 <.Loc.395.1>:
    if (u > v) {
    71e2:	0d 99       	cmp	r9,	r13	;
    71e4:	0a 28       	jnc	$+22     	;abs 0x71fa
    71e6:	09 9d       	cmp	r13,	r9	;
    71e8:	02 20       	jnz	$+6      	;abs 0x71ee
    71ea:	0c 98       	cmp	r8,	r12	;
    71ec:	06 28       	jnc	$+14     	;abs 0x71fa

000071ee <.L83>:
    71ee:	06 4c       	mov	r12,	r6	;
    71f0:	07 4d       	mov	r13,	r7	;
    71f2:	0c 48       	mov	r8,	r12	;

000071f4 <.LVL97>:
    71f4:	0d 49       	mov	r9,	r13	;
    71f6:	08 46       	mov	r6,	r8	;

000071f8 <.LVL98>:
    71f8:	09 47       	mov	r7,	r9	;

000071fa <.L60>:
    v = v - u;
    71fa:	06 48       	mov	r8,	r6	;
    71fc:	07 49       	mov	r9,	r7	;
    71fe:	40 18 06 8c 	subx.w	r12,	r6	;
    7202:	40 18 07 7d 	subcx.w	r13,	r7	;

00007206 <.LVL100>:
  } while (v != 0);
    7206:	0f 46       	mov	r6,	r15	;
    7208:	0f d7       	bis	r7,	r15	;
    720a:	0f 93       	cmp	#0,	r15	;r3 As==00
    720c:	b0 20       	jnz	$+354    	;abs 0x736e

0000720e <.Loc.403.1>:
  return u << shift;
    720e:	0f 43       	clr	r15		;
    7210:	b0 13 36 cc 	calla	#52278		;0x0cc36

00007214 <.LVL101>:
    7214:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    7218:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

0000721c <.LBE75>:
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
    721c:	0e 4c       	mov	r12,	r14	;
    721e:	0f 4d       	mov	r13,	r15	;
    7220:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    7224:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    7228:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    722c:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    7230:	81 4d 0e 00 	mov	r13,	14(r1)	; 0x000e

00007234 <.LVL104>:
  while (r_mult - (75 * i) > 169) {
    7234:	08 4c       	mov	r12,	r8	;
    7236:	09 4d       	mov	r13,	r9	;

00007238 <.L63>:
    7238:	09 93       	cmp	#0,	r9	;r3 As==00
    723a:	9f 20       	jnz	$+320    	;abs 0x737a
    723c:	7d 40 a9 00 	mov.b	#169,	r13	;#0x00a9
    7240:	0d 98       	cmp	r8,	r13	;
    7242:	9b 28       	jnc	$+312    	;abs 0x737a

00007244 <.LVL106>:
  r = r_mult - 1;
    7244:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    7248:	46 48       	mov.b	r8,	r6	;
    724a:	76 53       	add.b	#-1,	r6	;r3 As==11

0000724c <.L91>:
    r += r_mult;
    724c:	36 f0 ff 00 	and	#255,	r6	;#0x00ff

00007250 <.LVL108>:
  while (r < 64 || r > 169) {
    7250:	4c 46       	mov.b	r6,	r12	;
    7252:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0
    7256:	7e 40 69 00 	mov.b	#105,	r14	;#0x0069
    725a:	4e 9c       	cmp.b	r12,	r14	;
    725c:	93 28       	jnc	$+296    	;abs 0x7384

0000725e <.Loc.511.1>:
  r -= r_mult;
    725e:	46 88       	sub.b	r8,	r6	;

00007260 <.LVL109>:
    7260:	49 46       	mov.b	r6,	r9	;

00007262 <.LVL110>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    7262:	86 00 b6 cb 	mova	#52150,	r6	;0x0cbb6

00007266 <.L68>:
    r += r_mult;
    7266:	4c 49       	mov.b	r9,	r12	;
    7268:	4c 58       	add.b	r8,	r12	;
    726a:	49 4c       	mov.b	r12,	r9	;

0000726c <.LVL112>:
  } while (r < 64 || r > 169 || s > p);
    726c:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0

00007270 <.LVL113>:
    7270:	7d 40 69 00 	mov.b	#105,	r13	;#0x0069
    7274:	4d 9c       	cmp.b	r12,	r13	;
    7276:	f7 2b       	jnc	$-16     	;abs 0x7266

00007278 <.Loc.514.1>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    7278:	1e 41 12 00 	mov	18(r1),	r14	;0x00012
    727c:	1f 41 14 00 	mov	20(r1),	r15	;0x00014
    7280:	1c 41 06 00 	mov	6(r1),	r12	;

00007284 <.LVL114>:
    7284:	1d 41 08 00 	mov	8(r1),	r13	;
    7288:	46 13       	calla	r6		;
    728a:	0e 49       	mov	r9,	r14	;
    728c:	1e 53       	inc	r14		;
    728e:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    7292:	0f 7f       	subc	r15,	r15	;
    7294:	3f e3       	inv	r15		;
    7296:	b0 13 a2 cd 	calla	#52642		;0x0cda2
    729a:	1e 41 0c 00 	mov	12(r1),	r14	;0x0000c
    729e:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    72a2:	46 13       	calla	r6		;
    72a4:	07 4c       	mov	r12,	r7	;

000072a6 <.Loc.515.1>:
    p = (temp / 75) - 1;
    72a6:	7e 40 4b 00 	mov.b	#75,	r14	;#0x004b
    72aa:	4f 43       	clr.b	r15		;
    72ac:	46 13       	calla	r6		;
    72ae:	4e 4c       	mov.b	r12,	r14	;
    72b0:	7e 53       	add.b	#-1,	r14	;r3 As==11
    72b2:	4c 4e       	mov.b	r14,	r12	;
    72b4:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010

000072b8 <.Loc.516.1>:
    s = temp - ((p+1)*75);
    72b8:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    72bc:	1c 53       	inc	r12		;
    72be:	71 0e 00 00 	mova	r14,	0(r1)	;
    72c2:	b0 13 8c cd 	calla	#52620		;0x0cd8c
    72c6:	47 8c       	sub.b	r12,	r7	;
    72c8:	4c 47       	mov.b	r7,	r12	;
    72ca:	37 f0 ff 00 	and	#255,	r7	;#0x00ff

000072ce <.Loc.517.1>:
  } while (r < 64 || r > 169 || s > p);
    72ce:	0e 01       	mova	@r1,	r14	;
    72d0:	4e 9c       	cmp.b	r12,	r14	;
    72d2:	c9 2b       	jnc	$-108    	;abs 0x7266

000072d4 <.Loc.519.1>:
  sx1212SetRegister(devp, MCParam6, r);
    72d4:	88 00 ee 6d 	mova	#28142,	r8	;0x06dee
    72d8:	4e 49       	mov.b	r9,	r14	;
    72da:	7d 40 06 00 	mov.b	#6,	r13	;
    72de:	cc 04       	mova	r4,	r12	;
    72e0:	48 13       	calla	r8		;

000072e2 <.LVL120>:
  sx1212SetRegister(devp, MCParam7, p);
    72e2:	1d 41 10 00 	mov	16(r1),	r13	;0x00010
    72e6:	4e 4d       	mov.b	r13,	r14	;
    72e8:	7d 40 07 00 	mov.b	#7,	r13	;
    72ec:	cc 04       	mova	r4,	r12	;
    72ee:	48 13       	calla	r8		;

000072f0 <.LVL121>:
  sx1212SetRegister(devp, MCParam8, s);
    72f0:	4e 47       	mov.b	r7,	r14	;
    72f2:	7d 42       	mov.b	#8,	r13	;r2 As==11
    72f4:	cc 04       	mova	r4,	r12	;
    72f6:	48 13       	calla	r8		;

000072f8 <.LVL122>:
  if (freq >= 300000000 && freq <= 330000000) {
    72f8:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    72fc:	1e 91 04 00 	cmp	4(r1),	r14	;
    7300:	44 28       	jnc	$+138    	;abs 0x738a
    7302:	1c 41 04 00 	mov	4(r1),	r12	;
    7306:	0c 9e       	cmp	r14,	r12	;
    7308:	05 20       	jnz	$+12     	;abs 0x7314
    730a:	3c 40 80 c3 	mov	#-15488,r12	;#0xc380
    730e:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7312:	3b 28       	jnc	$+120    	;abs 0x738a

00007314 <.L85>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    7314:	5a 44 04 00 	mov.b	4(r4),	r10	;
    7318:	7a f0 e0 ff 	and.b	#-32,	r10	;#0xffe0

0000731c <.Loc.526.1>:
      0x00 << 2 | ((freq - 300000000) / 7500000);
    731c:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    7320:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    7324:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7328:	1d 41 04 00 	mov	4(r1),	r13	;

0000732c <.L93>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    732c:	46 13       	calla	r6		;
    732e:	4e 4a       	mov.b	r10,	r14	;

00007330 <.L92>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    7330:	4e dc       	bis.b	r12,	r14	;

00007332 <.Loc.550.1>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    7332:	c4 4e 04 00 	mov.b	r14,	4(r4)	;

00007336 <.Loc.552.1>:
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    7336:	4d 43       	clr.b	r13		;
    7338:	cc 04       	mova	r4,	r12	;
    733a:	48 13       	calla	r8		;

0000733c <.L47>:
}
    733c:	a1 00 16 00 	adda	#22,	r1	;0x00016
    7340:	64 16       	popm.a	#7,	r10	;20-bit words
    7342:	10 01       	reta			;

00007344 <.L52>:
    u >>= 1;
    7344:	12 c3       	clrc			
    7346:	09 10       	rrc	r9		;
    7348:	08 10       	rrc	r8		;

0000734a <.Loc.385.1>:
    v >>= 1;
    734a:	12 c3       	clrc			
    734c:	0d 10       	rrc	r13		;
    734e:	0c 10       	rrc	r12		;

00007350 <.Loc.383.1>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    7350:	1e 53       	inc	r14		;
    7352:	80 00 c8 71 	mova	#29128,	r0	;0x071c8

00007356 <.L55>:
    u >>= 1;
    7356:	12 c3       	clrc			
    7358:	09 10       	rrc	r9		;
    735a:	08 10       	rrc	r8		;
    735c:	80 00 d2 71 	mova	#29138,	r0	;0x071d2

00007360 <.L58>:
      v >>= 1;
    7360:	06 4c       	mov	r12,	r6	;
    7362:	07 4d       	mov	r13,	r7	;
    7364:	12 c3       	clrc			
    7366:	07 10       	rrc	r7		;
    7368:	06 10       	rrc	r6		;

0000736a <.LVL131>:
    736a:	0c 48       	mov	r8,	r12	;
    736c:	0d 49       	mov	r9,	r13	;

0000736e <.L62>:
    736e:	08 4c       	mov	r12,	r8	;
    7370:	09 4d       	mov	r13,	r9	;
    7372:	0c 46       	mov	r6,	r12	;
    7374:	0d 47       	mov	r7,	r13	;
    7376:	80 00 da 71 	mova	#29146,	r0	;0x071da

0000737a <.L64>:
    737a:	38 50 b5 ff 	add	#-75,	r8	;#0xffb5
    737e:	39 63       	addc	#-1,	r9	;r3 As==11
    7380:	80 00 38 72 	mova	#29240,	r0	;0x07238

00007384 <.L67>:
    r += r_mult;
    7384:	46 58       	add.b	r8,	r6	;

00007386 <.LVL135>:
    7386:	80 00 4c 72 	mova	#29260,	r0	;0x0724c

0000738a <.L70>:
  else if (freq >= 320000000 && freq <= 350000000) {
    738a:	0c 4a       	mov	r10,	r12	;
    738c:	3c 50 00 30 	add	#12288,	r12	;#0x3000
    7390:	0d 45       	mov	r5,	r13	;
    7392:	3d 60 ed ec 	addc	#-4883,	r13	;#0xeced
    7396:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    739a:	0e 9d       	cmp	r13,	r14	;
    739c:	13 28       	jnc	$+40     	;abs 0x73c4
    739e:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    73a2:	04 20       	jnz	$+10     	;abs 0x73ac
    73a4:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    73a8:	0e 9c       	cmp	r12,	r14	;
    73aa:	0c 28       	jnc	$+26     	;abs 0x73c4

000073ac <.L86>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    73ac:	5e 44 04 00 	mov.b	4(r4),	r14	;
    73b0:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    73b4:	4a 4e       	mov.b	r14,	r10	;
    73b6:	6a d2       	bis.b	#4,	r10	;r2 As==10
    73b8:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    73bc:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    73c0:	80 00 2c 73 	mova	#29484,	r0	;0x0732c

000073c4 <.L73>:
  else if (freq >= 350000000 && freq <= 390000000) {
    73c4:	0c 4a       	mov	r10,	r12	;
    73c6:	3c 50 80 6c 	add	#27776,	r12	;#0x6c80
    73ca:	0d 45       	mov	r5,	r13	;
    73cc:	3d 60 23 eb 	addc	#-5341,	r13	;#0xeb23
    73d0:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    73d4:	0e 9d       	cmp	r13,	r14	;
    73d6:	13 28       	jnc	$+40     	;abs 0x73fe
    73d8:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    73dc:	04 20       	jnz	$+10     	;abs 0x73e6
    73de:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    73e2:	0e 9c       	cmp	r12,	r14	;
    73e4:	0c 28       	jnc	$+26     	;abs 0x73fe

000073e6 <.L87>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    73e6:	5e 44 04 00 	mov.b	4(r4),	r14	;
    73ea:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    73ee:	4a 4e       	mov.b	r14,	r10	;
    73f0:	7a d2       	bis.b	#8,	r10	;r2 As==11

000073f2 <.L94>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    73f2:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    73f6:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    73fa:	80 00 2c 73 	mova	#29484,	r0	;0x0732c

000073fe <.L75>:
  else if (freq >= 390000000 && freq <= 430000000) {
    73fe:	0c 4a       	mov	r10,	r12	;
    7400:	3c 50 80 12 	add	#4736,	r12	;#0x1280
    7404:	0d 45       	mov	r5,	r13	;
    7406:	3d 60 c1 e8 	addc	#-5951,	r13	;#0xe8c1
    740a:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    740e:	0e 9d       	cmp	r13,	r14	;
    7410:	10 28       	jnc	$+34     	;abs 0x7432
    7412:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    7416:	04 20       	jnz	$+10     	;abs 0x7420
    7418:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    741c:	0e 9c       	cmp	r12,	r14	;
    741e:	09 28       	jnc	$+20     	;abs 0x7432

00007420 <.L88>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    7420:	5e 44 04 00 	mov.b	4(r4),	r14	;
    7424:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7428:	4a 4e       	mov.b	r14,	r10	;
    742a:	7a d0 0c 00 	bis.b	#12,	r10	;#0x000c
    742e:	80 00 f2 73 	mova	#29682,	r0	;0x073f2

00007432 <.L77>:
  else if (freq >= 430000000 && freq <= 470000000) {
    7432:	0c 4a       	mov	r10,	r12	;
    7434:	3c 50 80 b8 	add	#-18304,r12	;#0xb880
    7438:	0d 45       	mov	r5,	r13	;
    743a:	3d 60 5e e6 	addc	#-6562,	r13	;#0xe65e
    743e:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    7442:	0e 9d       	cmp	r13,	r14	;
    7444:	10 28       	jnc	$+34     	;abs 0x7466
    7446:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    744a:	04 20       	jnz	$+10     	;abs 0x7454
    744c:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7450:	0e 9c       	cmp	r12,	r14	;
    7452:	09 28       	jnc	$+20     	;abs 0x7466

00007454 <.L89>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    7454:	5e 44 04 00 	mov.b	4(r4),	r14	;
    7458:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    745c:	4a 4e       	mov.b	r14,	r10	;
    745e:	7a d0 10 00 	bis.b	#16,	r10	;#0x0010
    7462:	80 00 f2 73 	mova	#29682,	r0	;0x073f2

00007466 <.L79>:
  else if (freq >= 470000000 && freq <= 510000000) {
    7466:	0c 4a       	mov	r10,	r12	;
    7468:	3c 50 80 5e 	add	#24192,	r12	;#0x5e80
    746c:	0d 45       	mov	r5,	r13	;
    746e:	3d 60 fc e3 	addc	#-7172,	r13	;#0xe3fc
    7472:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    7476:	0e 9d       	cmp	r13,	r14	;
    7478:	61 2b       	jnc	$-316    	;abs 0x733c
    747a:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    747e:	04 20       	jnz	$+10     	;abs 0x7488
    7480:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7484:	0e 9c       	cmp	r12,	r14	;
    7486:	5a 2b       	jnc	$-330    	;abs 0x733c

00007488 <.L90>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    7488:	5e 44 04 00 	mov.b	4(r4),	r14	;
    748c:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7490:	49 4e       	mov.b	r14,	r9	;

00007492 <.LVL137>:
    7492:	79 d0 14 00 	bis.b	#20,	r9	;#0x0014
    7496:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    749a:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    749e:	46 13       	calla	r6		;
    74a0:	4e 49       	mov.b	r9,	r14	;
    74a2:	80 00 30 73 	mova	#29488,	r0	;0x07330

000074a6 <sx1212SetSync>:
void sx1212SetSync(SX1212Driver *devp, SX1212_SYNC_TYPE sync) {
    74a6:	5a 14       	pushm.a	#6,	r10	;20-bit words

000074a8 <.LCFI13>:
    74a8:	ca 0c       	mova	r12,	r10	;
    74aa:	08 4d       	mov	r13,	r8	;
    74ac:	09 4e       	mov	r14,	r9	;

000074ae <.LVL140>:
    74ae:	77 40 16 00 	mov.b	#22,	r7	;#0x0016
    74b2:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

000074b6 <.LBB77>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    74b6:	86 00 ee 6d 	mova	#28142,	r6	;0x06dee

000074ba <.L96>:
        sync >> (8 * (sizeof(sync) - 1 - i)));
    74ba:	0c 48       	mov	r8,	r12	;
    74bc:	0d 49       	mov	r9,	r13	;
    74be:	0e 45       	mov	r5,	r14	;
    74c0:	0f 43       	clr	r15		;
    74c2:	b0 13 5e cd 	calla	#52574		;0x0cd5e

000074c6 <.Loc.574.1>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    74c6:	4e 4c       	mov.b	r12,	r14	;
    74c8:	4d 47       	mov.b	r7,	r13	;
    74ca:	cc 0a       	mova	r10,	r12	;
    74cc:	46 13       	calla	r6		;

000074ce <.LVL143>:
    74ce:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8
    74d2:	4c 47       	mov.b	r7,	r12	;
    74d4:	5c 53       	inc.b	r12		;
    74d6:	47 4c       	mov.b	r12,	r7	;

000074d8 <.Loc.573.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    74d8:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    74dc:	ee 23       	jnz	$-34     	;abs 0x74ba

000074de <.LBE77>:
}
    74de:	55 16       	popm.a	#6,	r10	;20-bit words
    74e0:	10 01       	reta			;

000074e2 <sx1212SetRxBw>:
 * @param[in] bandwidth the receiver bandwidth to use minus one, in steps of 25 kHz
 * 
 * @note The bandwidth specifiedd here is for the active filter. Passive
 *       filter bandwidth is set automatically according to datasheet
 */
void sx1212SetRxBw(SX1212Driver *devp, uint8_t bandwidth) {
    74e2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000074e4 <.LCFI14>:
    74e4:	08 14       	pushm.a	#1,	r8	;20-bit words

000074e6 <.LCFI15>:
    74e6:	c8 0c       	mova	r12,	r8	;
    74e8:	4a 4d       	mov.b	r13,	r10	;

000074ea <.Loc.729.1>:
  static const uint8_t passive[16] = {
    1, 4, 7, 9, 10, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15
  };
  
  osalDbgAssert(bandwidth < 16, "requested bandwidth is too wide");
    74ea:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

000074ee <.LVL145>:
    74ee:	4c 9a       	cmp.b	r10,	r12	;
    74f0:	04 2c       	jc	$+10     	;abs 0x74fa

000074f2 <.Loc.729.1>:
    74f2:	8c 01 c7 06 	mova	#67271,	r12	;0x106c7
    74f6:	b0 13 3e 46 	calla	#17982		;0x0463e

000074fa <.L99>:
  
  /* Passive filter bandwidth to be between 3 and 4 times active filter 
   * bandwidth, per datasheet. This is precalculated because there's no obvious
   * mapping. */
  sx1212SetRegister(devp, RXParam0, (passive[bandwidth] << 4) | bandwidth);
    74fa:	0d 4a       	mov	r10,	r13	;
    74fc:	4d 0e       	rlam.a	#4,	r13	;
    74fe:	4d 0d       	rram.a	#4,	r13	;
    7500:	c0 18 5e 4d 	movx.b	67255(r13),r14	;0x106b7
    7504:	b7 06 
    7506:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    750a:	4e da       	bis.b	r10,	r14	;
    750c:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    7510:	cc 08       	mova	r8,	r12	;
    7512:	b0 13 ee 6d 	calla	#28142		;0x06dee

00007516 <.LVL147>:
}
    7516:	08 16       	popm.a	#1,	r8	;20-bit words
    7518:	0a 16       	popm.a	#1,	r10	;20-bit words
    751a:	10 01       	reta			;

0000751c <sx1212Start>:
 * @param[in] devp      pointer to the @p SX1212Driver object
 * @param[in] config    pointer to the @p SX1212Config object
 *
 * @api
 */
void sx1212Start(SX1212Driver *devp, const SX1212Config *config) {
    751c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000751e <.LCFI16>:
    751e:	08 14       	pushm.a	#1,	r8	;20-bit words

00007520 <.LCFI17>:
    7520:	06 14       	pushm.a	#1,	r6	;20-bit words

00007522 <.LCFI18>:
    7522:	04 14       	pushm.a	#1,	r4	;20-bit words

00007524 <.LCFI19>:
    7524:	ca 0c       	mova	r12,	r10	;
    7526:	c8 0d       	mova	r13,	r8	;

00007528 <.Loc.957.1>:
  
  devp->config = config;
    7528:	7a 0d 00 00 	mova	r13,	0(r10)	;

0000752c <.Loc.959.1>:
  /* Reset the device to get it into a known state */
  sx1212Reset(devp);
    752c:	b0 13 8c 6e 	calla	#28300		;0x06e8c

00007530 <.LVL149>:
  /* Set all the stored registers to their reset states */
  devp->regs.MCParam0 = 0x30;
    7530:	fa 40 30 00 	mov.b	#48,	4(r10)	;#0x0030
    7534:	04 00 

00007536 <.Loc.962.1>:
  devp->regs.IRQParam0 = 0x0F;
    7536:	fa 40 0f 00 	mov.b	#15,	5(r10)	;#0x000f
    753a:	05 00 

0000753c <.Loc.965.1>:
  
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    753c:	3d 08 04 00 	mova	4(r8),	r13	;
    7540:	0c 08       	mova	@r8,	r12	;
    7542:	b0 13 84 4f 	calla	#20356		;0x04f84

00007546 <.LVL150>:
  /* Put the SPI interface into Config mode */
  spi_mode_config(devp);
    7546:	cc 0a       	mova	r10,	r12	;
    7548:	b0 13 ea 6f 	calla	#28650		;0x06fea

0000754c <.LVL151>:
  
  /* Put the device into sleep mode */
  sx1212SetMode(devp, SX1212Sleep);
    754c:	4d 43       	clr.b	r13		;
    754e:	cc 0a       	mova	r10,	r12	;
    7550:	b0 13 3e 6e 	calla	#28222		;0x06e3e

00007554 <.LVL152>:
  /* Set device configuration */
  sx1212SetFrequency(devp, config->freq);
    7554:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    7558:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    755c:	cc 0a       	mova	r10,	r12	;
    755e:	b0 13 5a 71 	calla	#29018		;0x0715a

00007562 <.LVL153>:
  sx1212SetDeviation(devp, config->fdev);
    7562:	1d 48 14 00 	mov	20(r8),	r13	;0x00014
    7566:	1e 48 16 00 	mov	22(r8),	r14	;0x00016
    756a:	cc 0a       	mova	r10,	r12	;
    756c:	b0 13 04 71 	calla	#28932		;0x07104

00007570 <.LVL154>:
  sx1212SetBitrate(devp, config->bitrate);
    7570:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    7574:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    7578:	cc 0a       	mova	r10,	r12	;
    757a:	b0 13 04 70 	calla	#28676		;0x07004

0000757e <.LVL155>:
  sx1212SetRxBw(devp, config->rx_bw);
    757e:	5d 48 18 00 	mov.b	24(r8),	r13	;0x00018
    7582:	cc 0a       	mova	r10,	r12	;
    7584:	b0 13 e2 74 	calla	#29922		;0x074e2

00007588 <.LVL156>:
  sx1212SetSync(devp, config->sync_word);
    7588:	1d 48 1c 00 	mov	28(r8),	r13	;0x0001c
    758c:	1e 48 1e 00 	mov	30(r8),	r14	;0x0001e
    7590:	cc 0a       	mova	r10,	r12	;
    7592:	b0 13 a6 74 	calla	#29862		;0x074a6

00007596 <.LVL157>:
    7596:	86 00 ee 6d 	mova	#28142,	r6	;0x06dee

0000759a <.Loc.977.1>:
  if (config->packet_config != NULL) {
    759a:	00 18 c8 93 	cmpx.a	#0,	38(r8)	;r3 As==00, 0x00026
    759e:	26 00 
    75a0:	8a 24       	jz	$+278    	;abs 0x76b6

000075a2 <.Loc.978.1>:
    sx1212ConfigurePackets(devp, devp->config->packet_config);
    75a2:	0c 0a       	mova	@r10,	r12	;
    75a4:	34 0c 26 00 	mova	38(r12),r4	;0x00026

000075a8 <.LBB80>:
  sx1212SetRegister(devp, MCParam1, 0xA4);
    75a8:	7e 40 a4 ff 	mov.b	#-92,	r14	;#0xffa4
    75ac:	5d 43       	mov.b	#1,	r13	;r3 As==01
    75ae:	cc 0a       	mova	r10,	r12	;
    75b0:	46 13       	calla	r6		;

000075b2 <.LVL159>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
    75b2:	6c 44       	mov.b	@r4,	r12	;
    75b4:	7c f0 06 00 	and.b	#6,	r12	;
    75b8:	7c 90 06 00 	cmp.b	#6,	r12	;
    75bc:	04 20       	jnz	$+10     	;abs 0x75c6
    75be:	8c 01 88 06 	mova	#67208,	r12	;0x10688
    75c2:	b0 13 3e 46 	calla	#17982		;0x0463e

000075c6 <.L102>:
  osalDbgAssert(devp->config->length < 128, "requested packet size too long");
    75c6:	0c 0a       	mova	@r10,	r12	;
    75c8:	cc 93 2b 00 	cmp.b	#0,	43(r12)	;r3 As==00, 0x002b
    75cc:	04 34       	jge	$+10     	;abs 0x75d6
    75ce:	8c 01 88 06 	mova	#67208,	r12	;0x10688
    75d2:	b0 13 3e 46 	calla	#17982		;0x0463e

000075d6 <.L103>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    75d6:	6e 44       	mov.b	@r4,	r14	;
    75d8:	44 18 0e 5e 	rpt #5 { rlax.w	r14		;
    75dc:	7e f0 80 00 	and.b	#128,	r14	;#0x0080

000075e0 <.Loc.763.1>:
     devp->config->length);
    75e0:	0c 0a       	mova	@r10,	r12	;

000075e2 <.Loc.762.1>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    75e2:	5e dc 2b 00 	bis.b	43(r12),r14	;0x0002b
    75e6:	7d 40 1c 00 	mov.b	#28,	r13	;#0x001c
    75ea:	cc 0a       	mova	r10,	r12	;
    75ec:	46 13       	calla	r6		;

000075ee <.LVL162>:
  if (!packet_config->broadcast) {
    75ee:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    75f2:	00 00 
    75f4:	0b 20       	jnz	$+24     	;abs 0x760c

000075f6 <.Loc.767.1>:
    packet_config->broadcast = packet_config->addressing;
    75f6:	6d 44       	mov.b	@r4,	r13	;
    75f8:	0c 4d       	mov	r13,	r12	;
    75fa:	5c 0f       	rrum	#4,	r12	;
    75fc:	5c f3       	and.b	#1,	r12	;r3 As==01
    75fe:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    7602:	7d f0 9f ff 	and.b	#-97,	r13	;#0xff9f
    7606:	4d dc       	bis.b	r12,	r13	;
    7608:	c4 4d 00 00 	mov.b	r13,	0(r4)	;

0000760c <.L104>:
  if (packet_config->broadcast) {
    760c:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    7610:	00 00 
    7612:	07 24       	jz	$+16     	;abs 0x7622

00007614 <.Loc.772.1>:
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
    7614:	0c 0a       	mova	@r10,	r12	;
    7616:	5e 4c 2a 00 	mov.b	42(r12),r14	;0x0002a
    761a:	7d 40 1d 00 	mov.b	#29,	r13	;#0x001d
    761e:	cc 0a       	mova	r10,	r12	;
    7620:	46 13       	calla	r6		;

00007622 <.L105>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    7622:	d4 b3 00 00 	bit.b	#1,	0(r4)	;r3 As==01
    7626:	43 20       	jnz	$+136    	;abs 0x76ae
    7628:	4d 43       	clr.b	r13		;

0000762a <.L106>:
      (packet_config->whitening << 4) |
    762a:	6f 44       	mov.b	@r4,	r15	;
    762c:	0c 4f       	mov	r15,	r12	;
    762e:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    7632:	7c f0 10 00 	and.b	#16,	r12	;#0x0010

00007636 <.Loc.779.1>:
      (packet_config->crc << 3) |
    7636:	0e 4f       	mov	r15,	r14	;
    7638:	7e f2       	and.b	#8,	r14	;r2 As==11
    763a:	4c de       	bis.b	r14,	r12	;

0000763c <.Loc.780.1>:
      (packet_config->broadcast << 1));
    763c:	0e 4f       	mov	r15,	r14	;
    763e:	5e 0f       	rrum	#4,	r14	;
    7640:	7e f0 06 00 	and.b	#6,	r14	;

00007644 <.Loc.779.1>:
      (packet_config->crc << 3) |
    7644:	4e dc       	bis.b	r12,	r14	;

00007646 <.Loc.775.1>:
  sx1212SetRegister(devp, PKTParam2, 
    7646:	4e dd       	bis.b	r13,	r14	;
    7648:	7d 40 1e 00 	mov.b	#30,	r13	;#0x001e
    764c:	cc 0a       	mova	r10,	r12	;
    764e:	46 13       	calla	r6		;

00007650 <.LVL164>:
  sx1212SetRegister(devp, PKTParam3, ((!packet_config->crc_autoclear) << 7));
    7650:	6e 44       	mov.b	@r4,	r14	;
    7652:	3e e0 80 00 	xor	#128,	r14	;#0x0080
    7656:	7e f0 80 ff 	and.b	#-128,	r14	;#0xff80
    765a:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

0000765e <.L115>:
  }
  else {
    /* Buffered mode */
    sx1212SetRegister(devp, MCParam1, 0x64);
    765e:	cc 0a       	mova	r10,	r12	;
    7660:	46 13       	calla	r6		;

00007662 <.LVL166>:
  }
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
    7662:	7c 40 03 00 	mov.b	#3,	r12	;
    7666:	5c 98 20 00 	cmp.b	32(r8),	r12	;0x00020
    766a:	04 2c       	jc	$+10     	;abs 0x7674

0000766c <.Loc.986.1>:
    766c:	8c 01 ab 06 	mova	#67243,	r12	;0x106ab
    7670:	b0 13 3e 46 	calla	#17982		;0x0463e

00007674 <.L109>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
    7674:	5e 48 20 00 	mov.b	32(r8),	r14	;0x00020
    7678:	0e 5e       	rla	r14		;

0000767a <.Loc.987.1>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
    767a:	7e d0 38 00 	bis.b	#56,	r14	;#0x0038
    767e:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    7682:	cc 0a       	mova	r10,	r12	;
    7684:	46 13       	calla	r6		;

00007686 <.LVL168>:
  
  /* IRQParam2 - enable PLL lock */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7686:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    768a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    768e:	cc 0a       	mova	r10,	r12	;
    7690:	46 13       	calla	r6		;

00007692 <.LVL169>:
  
  /* Set Fifo size to 64 */
  sx1212SetRegister(devp, IRQParam0, 0xC0);
    7692:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    7696:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    769a:	cc 0a       	mova	r10,	r12	;
    769c:	46 13       	calla	r6		;

0000769e <.LVL170>:
  devp->regs.IRQParam0 = 0xC0;
    769e:	fa 40 c0 ff 	mov.b	#-64,	5(r10)	;#0xffc0
    76a2:	05 00 

000076a4 <.Loc.1002.1>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(config->spip);
#endif

}
    76a4:	04 16       	popm.a	#1,	r4	;20-bit words
    76a6:	06 16       	popm.a	#1,	r6	;20-bit words
    76a8:	08 16       	popm.a	#1,	r8	;20-bit words
    76aa:	0a 16       	popm.a	#1,	r10	;20-bit words
    76ac:	10 01       	reta			;

000076ae <.L110>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    76ae:	3d 40 80 ff 	mov	#-128,	r13	;#0xff80
    76b2:	80 00 2a 76 	mova	#30250,	r0	;0x0762a

000076b6 <.L101>:
    sx1212SetRegister(devp, MCParam1, 0x64);
    76b6:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    76ba:	5d 43       	mov.b	#1,	r13	;r3 As==01
    76bc:	80 00 5e 76 	mova	#30302,	r0	;0x0765e

000076c0 <sx1212ReceiveI>:
      );
  
  return MSG_OK;
}

void sx1212ReceiveI(SX1212Driver * devp, size_t n, palcallback_t callback) {
    76c0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000076c2 <.LCFI21>:
    76c2:	08 14       	pushm.a	#1,	r8	;20-bit words

000076c4 <.LCFI22>:
    76c4:	06 14       	pushm.a	#1,	r6	;20-bit words

000076c6 <.LCFI23>:
    76c6:	c8 0c       	mova	r12,	r8	;
    76c8:	ca 0d       	mova	r13,	r10	;
    76ca:	c6 0e       	mova	r14,	r6	;

000076cc <.Loc.1066.1>:
  static volatile size_t fft;
  fft = n - 1;
    76cc:	cc 0d       	mova	r13,	r12	;

000076ce <.LVL179>:
    76ce:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    76d2:	60 0c ec cf 	mova	r12,	&53228	; 0x0cfec

000076d6 <.Loc.1070.1>:
  osalDbgCheckClassI();
  /* TODO state machine */
  
  osalDbgAssert(n < 64, "invalid threshold");
    76d6:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    76da:	dc 0d       	cmpa	r13,	r12	;
    76dc:	04 2c       	jc	$+10     	;abs 0x76e6

000076de <.Loc.1070.1>:
    76de:	8c 01 79 06 	mova	#67193,	r12	;0x10679
    76e2:	b0 13 3e 46 	calla	#17982		;0x0463e

000076e6 <.L118>:
  /* IRQs are Fifoempty_B and Fifo_threshold */
  
  /* Configure the Fifo_threshold callback appropriately */
  palLineEnableEventI(SX1212_IRQ_1, PAL_EVENT_MODE_RISING_EDGE, callback);
    76e6:	cf 06       	mova	r6,	r15	;
    76e8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    76ea:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    76ee:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    76f2:	b0 13 70 53 	calla	#21360		;0x05370

000076f6 <.LVL181>:
  
  /* Set Fifo threshold */
  sx1212SetFifoThreshold(devp, n);
    76f6:	4d 4a       	mov.b	r10,	r13	;
    76f8:	cc 08       	mova	r8,	r12	;
    76fa:	b0 13 5a 6e 	calla	#28250		;0x06e5a

000076fe <.LVL182>:
}
    76fe:	06 16       	popm.a	#1,	r6	;20-bit words
    7700:	08 16       	popm.a	#1,	r8	;20-bit words
    7702:	0a 16       	popm.a	#1,	r10	;20-bit words
    7704:	10 01       	reta			;

00007706 <sx1212StartReceive>:
msg_t sx1212StartReceive(SX1212Driver *devp, size_t n, palcallback_t callback) {
    7706:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007708 <.LCFI24>:
    7708:	08 14       	pushm.a	#1,	r8	;20-bit words

0000770a <.LCFI25>:
    770a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000770c <.LCFI26>:
    770c:	04 14       	pushm.a	#1,	r4	;20-bit words

0000770e <.LCFI27>:
    770e:	ca 0c       	mova	r12,	r10	;
    7710:	c6 0d       	mova	r13,	r6	;
    7712:	c8 0e       	mova	r14,	r8	;

00007714 <.LBB94>:
  devp->irq_mappings[0] = irq0;
    7714:	fc 40 80 ff 	mov.b	#-128,	6(r12)	;#0xff80
    7718:	06 00 

0000771a <.Loc.625.1>:
  devp->irq_mappings[1] = irq1;
    771a:	fc 40 30 00 	mov.b	#48,	7(r12)	;#0x0030
    771e:	07 00 

00007720 <.Loc.627.1>:
  sx1212SetRegister(devp, IRQParam1, irq0 | irq1);
    7720:	84 00 ee 6d 	mova	#28142,	r4	;0x06dee
    7724:	7e 40 b0 ff 	mov.b	#-80,	r14	;#0xffb0

00007728 <.LVL185>:
    7728:	7d 40 0d 00 	mov.b	#13,	r13	;#0x000d

0000772c <.LVL186>:
    772c:	44 13       	calla	r4		;

0000772e <.LBB96>:
  _disable_interrupts();
    772e:	32 c2       	dint			
    7730:	03 43       	nop			

00007732 <.Loc.348.3>:
  asm volatile("nop");
    7732:	03 43       	nop			

00007734 <.LBE96>:
  sx1212ReceiveI(devp, n, callback);
    7734:	ce 08       	mova	r8,	r14	;
    7736:	cd 06       	mova	r6,	r13	;
    7738:	cc 0a       	mova	r10,	r12	;
    773a:	b0 13 c0 76 	calla	#30400		;0x076c0

0000773e <.LBB98>:
  asm volatile("nop");
    773e:	03 43       	nop			

00007740 <.Loc.356.3>:
  _enable_interrupts();
    7740:	03 43       	nop			
    7742:	32 d2       	eint			
    7744:	03 43       	nop			

00007746 <.LBB100>:
  sx1212SetMode(devp, SX1212Stdby);
    7746:	88 00 3e 6e 	mova	#28222,	r8	;0x06e3e

0000774a <.LVL190>:
    774a:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    774e:	cc 0a       	mova	r10,	r12	;
    7750:	48 13       	calla	r8		;

00007752 <.LBB102>:
  chThdSleep(time);
    7752:	7c 40 05 00 	mov.b	#5,	r12	;
    7756:	b0 13 9a 48 	calla	#18586		;0x0489a

0000775a <.LBE102>:
  sx1212SetMode(devp, SX1212FS);
    775a:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    775e:	cc 0a       	mova	r10,	r12	;
    7760:	48 13       	calla	r8		;

00007762 <.LVL193>:
  suspend_result = irq_block_with_timeout(devp, SX1212_PLL_LOCK, timeout);
    7762:	4d 43       	clr.b	r13		;
    7764:	3c 40 20 b2 	mov	#-19936,r12	;#0xb220
    7768:	b0 13 6a 6f 	calla	#28522		;0x06f6a

0000776c <.LVL194>:
    776c:	c6 0c       	mova	r12,	r6	;

0000776e <.LVL195>:
    776e:	60 0c f0 cf 	mova	r12,	&53232	; 0x0cff0

00007772 <.Loc.677.1>:
  if (suspend_result != MSG_OK) {
    7772:	9c 00 00 00 	cmpa	#0,	r12	;
    7776:	0a 20       	jnz	$+22     	;abs 0x778c

00007778 <.Loc.682.1>:
  sx1212SetMode(devp, SX1212Rx);
    7778:	7d 40 60 00 	mov.b	#96,	r13	;#0x0060
    777c:	cc 0a       	mova	r10,	r12	;
    777e:	48 13       	calla	r8		;

00007780 <.LVL196>:
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7780:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7784:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7788:	cc 0a       	mova	r10,	r12	;
    778a:	44 13       	calla	r4		;

0000778c <.L120>:
  BLOCK_RETURN_ERROR(
    778c:	60 06 f0 cf 	mova	r6,	&53232	; 0x0cff0

00007790 <.Loc.1062.1>:
}
    7790:	cc 06       	mova	r6,	r12	;
    7792:	04 16       	popm.a	#1,	r4	;20-bit words
    7794:	06 16       	popm.a	#1,	r6	;20-bit words
    7796:	08 16       	popm.a	#1,	r8	;20-bit words
    7798:	0a 16       	popm.a	#1,	r10	;20-bit words
    779a:	10 01       	reta			;

0000779c <sx1212FifoRead>:
  
  devp->rx_callback = callback;
  spiStartReceive(devp->config->spip, n, buffer);
}

void sx1212FifoRead(SX1212Driver * devp, size_t n, uint8_t * buffer) {
    779c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000779e <.LCFI32>:
    779e:	b1 00 04 00 	suba	#4,	r1	;

000077a2 <.LCFI33>:
    77a2:	c4 0c       	mova	r12,	r4	;
    77a4:	c5 0e       	mova	r14,	r5	;

000077a6 <.LVL204>:
    77a6:	ed 0e       	adda	r14,	r13	;

000077a8 <.LVL205>:
    77a8:	71 0d 00 00 	mova	r13,	0(r1)	;

000077ac <.LBB104>:
  
  for (size_t i = 0; i < n; i++) {
    palClearLine(devp->config->data_ss_b);
    77ac:	5a 43       	mov.b	#1,	r10	;r3 As==01

000077ae <.Loc.1093.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    77ae:	79 43       	mov.b	#-1,	r9	;r3 As==11

000077b0 <.L124>:
  for (size_t i = 0; i < n; i++) {
    77b0:	00 18 c1 95 	cmpx.a	r5,	0(r1)	;
    77b4:	00 00 
    77b6:	04 20       	jnz	$+10     	;abs 0x77c0

000077b8 <.LBE104>:
    palSetLine(devp->config->data_ss_b);
  }
  
}
    77b8:	a1 00 04 00 	adda	#4,	r1	;
    77bc:	64 16       	popm.a	#7,	r10	;20-bit words
    77be:	10 01       	reta			;

000077c0 <.L125>:
    palClearLine(devp->config->data_ss_b);
    77c0:	08 04       	mova	@r4,	r8	;
    77c2:	3c 08 08 00 	mova	8(r8),	r12	;
    77c6:	c6 0c       	mova	r12,	r6	;
    77c8:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    77cc:	ff 0f 
    77ce:	17 46 02 00 	mov	2(r6),	r7	;
    77d2:	0c 14       	pushm.a	#1,	r12	;20-bit words
    77d4:	40 18 3c 41 	popx.w	r12		;
    77d8:	40 18 3d 41 	popx.w	r13		;
    77dc:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    77e0:	0d 12       	push	r13		;
    77e2:	0c 12       	push	r12		;
    77e4:	0c 16       	popm.a	#1,	r12	;20-bit words
    77e6:	40 18 0d 4c 	movx.w	r12,	r13	;
    77ea:	0c 4a       	mov	r10,	r12	;
    77ec:	b0 13 ec cb 	calla	#52204		;0x0cbec
    77f0:	07 cc       	bic	r12,	r7	;
    77f2:	86 47 02 00 	mov	r7,	2(r6)	;

000077f6 <.Loc.1093.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    77f6:	4d 49       	mov.b	r9,	r13	;
    77f8:	0c 08       	mova	@r8,	r12	;
    77fa:	b0 13 fe 58 	calla	#22782		;0x058fe

000077fe <.LVL209>:
    77fe:	c5 4c 00 00 	mov.b	r12,	0(r5)	;

00007802 <.Loc.1094.1>:
    palSetLine(devp->config->data_ss_b);
    7802:	0c 04       	mova	@r4,	r12	;
    7804:	3c 0c 08 00 	mova	8(r12),	r12	;
    7808:	c6 0c       	mova	r12,	r6	;
    780a:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    780e:	ff 0f 
    7810:	18 46 02 00 	mov	2(r6),	r8	;
    7814:	0c 14       	pushm.a	#1,	r12	;20-bit words
    7816:	40 18 3c 41 	popx.w	r12		;
    781a:	40 18 3d 41 	popx.w	r13		;
    781e:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    7822:	0d 12       	push	r13		;
    7824:	0c 12       	push	r12		;
    7826:	0c 16       	popm.a	#1,	r12	;20-bit words
    7828:	40 18 0d 4c 	movx.w	r12,	r13	;
    782c:	0c 4a       	mov	r10,	r12	;
    782e:	b0 13 ec cb 	calla	#52204		;0x0cbec
    7832:	0c d8       	bis	r8,	r12	;
    7834:	86 4c 02 00 	mov	r12,	2(r6)	;

00007838 <.LVL212>:
    7838:	a5 00 01 00 	adda	#1,	r5	;

0000783c <.LVL213>:
    783c:	80 00 b0 77 	mova	#30640,	r0	;0x077b0

00007840 <sx1212StopReceive>:
 * @post    NSS_CONFIG and NSS_DATA busses are both released (if enabled).
 *          SX1212 is in Sleep mode.
 *          
 * @param[in] devp    pointer to the SX1212 driver
 */
void sx1212StopReceive(SX1212Driver *devp) {
    7840:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007842 <.LCFI34>:
    7842:	ca 0c       	mova	r12,	r10	;

00007844 <.Loc.1147.1>:
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* Reset for next packet reception */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7844:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7848:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    784c:	b0 13 ee 6d 	calla	#28142		;0x06dee

00007850 <.LVL215>:
  /* Go to Sleep */
  sx1212SetMode(devp, SX1212Sleep);
    7850:	4d 43       	clr.b	r13		;
    7852:	cc 0a       	mova	r10,	r12	;
    7854:	b0 13 3e 6e 	calla	#28222		;0x06e3e

00007858 <.LVL216>:
  
  /* Release SPI bus */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
}
    7858:	0a 16       	popm.a	#1,	r10	;20-bit words
    785a:	10 01       	reta			;

0000785c <sx1212StopReceiveI>:
    785c:	b0 13 40 78 	calla	#30784		;0x07840
    7860:	10 01       	reta			;

00007862 <send_complete_cb>:

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    7862:	00 18 c2 43 	movx.a	#0,	&0xfcffe;r3 As==00
    7866:	fe cf 

00007868 <.Loc.56.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    7868:	40 18 f2 d0 	bisx.b	#3,	&0xfcffc;
    786c:	03 00 fc cf 

00007870 <.LBB10>:
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->fullsem);
    7870:	c0 18 1c 42 	movx.w	&0x10a96,r12	;
    7874:	96 0a 

00007876 <.LBE10>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    7876:	4d 43       	clr.b	r13		;
    7878:	0d 9c       	cmp	r12,	r13	;
    787a:	06 34       	jge	$+14     	;abs 0x7888

0000787c <.Loc.59.1>:
    events |= UARTBufferPosted;
    787c:	40 18 a2 d3 	bisx.w	#2,	&0xfcff8;r3 As==10
    7880:	f8 cf 
    7882:	40 18 82 dd 	bisx.w	r13,	&0xfcffa;
    7886:	fa cf 

00007888 <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    7888:	2c 00 f4 cf 	mova	&53236,	r12	;0x0cff4
    788c:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    7890:	04 24       	jz	$+10     	;abs 0x789a

00007892 <.Loc.63.1>:
    chSchReadyI(uart_thd, MSG_RESET);
    7892:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    7896:	b0 13 0e 47 	calla	#18190		;0x0470e

0000789a <.L1>:
  }
  chSysUnlockFromISR();
}
    789a:	10 01       	reta			;

0000789c <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    789c:	01 18 d2 92 	cmpx.a	&0x0cff4,&0x114ea;
    78a0:	f4 cf ea 14 
    78a4:	04 20       	jnz	$+10     	;abs 0x78ae

000078a6 <.Loc.19.1>:
    78a6:	8c 01 22 07 	mova	#67362,	r12	;0x10722
    78aa:	b0 13 3e 46 	calla	#17982		;0x0463e

000078ae <.L7>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    78ae:	5d 43       	mov.b	#1,	r13	;r3 As==01
    78b0:	4e 43       	clr.b	r14		;
    78b2:	2c 00 f4 cf 	mova	&53236,	r12	;0x0cff4
    78b6:	b0 13 9a 49 	calla	#18842		;0x0499a

000078ba <.LVL7>:
}
    78ba:	10 01       	reta			;

000078bc <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    78bc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000078be <.LCFI0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    78be:	cd 0c       	mova	r12,	r13	;
    78c0:	8c 01 86 0a 	mova	#68230,	r12	;0x10a86

000078c4 <.LVL9>:
    78c4:	b0 13 ec 4a 	calla	#19180		;0x04aec

000078c8 <.LVL10>:
    78c8:	ca 0c       	mova	r12,	r10	;

000078ca <.Loc.26.1>:
  if (MSG_OK == msg) {
    78ca:	9c 00 00 00 	cmpa	#0,	r12	;
    78ce:	06 20       	jnz	$+14     	;abs 0x78dc

000078d0 <.Loc.27.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    78d0:	6d 43       	mov.b	#2,	r13	;r3 As==10
    78d2:	4e 43       	clr.b	r14		;
    78d4:	2c 00 f4 cf 	mova	&53236,	r12	;0x0cff4
    78d8:	b0 13 c6 49 	calla	#18886		;0x049c6

000078dc <.L8>:
}
    78dc:	cc 0a       	mova	r10,	r12	;
    78de:	0a 16       	popm.a	#1,	r10	;20-bit words
    78e0:	10 01       	reta			;

000078e2 <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    78e2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000078e4 <.LBB16>:
  _disable_interrupts();
    78e4:	32 c2       	dint			
    78e6:	03 43       	nop			

000078e8 <.Loc.348.3>:
  asm volatile("nop");
    78e8:	03 43       	nop			

000078ea <.LBE16>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    78ea:	0e 4d       	mov	r13,	r14	;
    78ec:	cd 0c       	mova	r12,	r13	;

000078ee <.LVL14>:
    78ee:	8c 01 86 0a 	mova	#68230,	r12	;0x10a86

000078f2 <.LVL15>:
    78f2:	b0 13 72 4a 	calla	#19058		;0x04a72

000078f6 <.LVL16>:
    78f6:	ca 0c       	mova	r12,	r10	;

000078f8 <.Loc.41.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    78f8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    78fa:	4e 43       	clr.b	r14		;
    78fc:	2c 00 f4 cf 	mova	&53236,	r12	;0x0cff4
    7900:	b0 13 c6 49 	calla	#18886		;0x049c6

00007904 <.LBB18>:
  asm volatile("nop");
    7904:	03 43       	nop			

00007906 <.Loc.356.3>:
  _enable_interrupts();
    7906:	03 43       	nop			
    7908:	32 d2       	eint			
    790a:	03 43       	nop			

0000790c <.LBE18>:
}
    790c:	cc 0a       	mova	r10,	r12	;
    790e:	0a 16       	popm.a	#1,	r10	;20-bit words
    7910:	10 01       	reta			;

00007912 <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 256);
THD_FUNCTION(UARTThd, arg) {
    7912:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007914 <.LCFI2>:
    7914:	08 14       	pushm.a	#1,	r8	;20-bit words

00007916 <.LCFI3>:
    7916:	06 14       	pushm.a	#1,	r6	;20-bit words

00007918 <.LCFI4>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    7918:	80 18 d2 42 	movx.a	&0x114ea,&0xfcff4;
    791c:	ea 14 f4 cf 

00007920 <.Loc.98.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    7920:	40 18 f2 40 	movx.b	#7,	&0xfcffc;
    7924:	07 00 fc cf 

00007928 <.LBB36>:
  _disable_interrupts();
    7928:	32 c2       	dint			
    792a:	03 43       	nop			

0000792c <.Loc.348.3>:
  asm volatile("nop");
    792c:	03 43       	nop			

0000792e <.LBE36>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    792e:	00 18 c2 93 	cmpx.a	#0,	&0xfcffe;r3 As==00
    7932:	fe cf 
    7934:	06 20       	jnz	$+14     	;abs 0x7942

00007936 <.LBB38>:
    7936:	c0 18 1c 42 	movx.w	&0x10a96,r12	;
    793a:	96 0a 

0000793c <.LBE38>:
    793c:	4d 43       	clr.b	r13		;
    793e:	0d 9c       	cmp	r12,	r13	;
    7940:	06 34       	jge	$+14     	;abs 0x794e

00007942 <.L13>:
    events |= UARTBufferPosted;
    7942:	40 18 a2 d3 	bisx.w	#2,	&0xfcff8;r3 As==10
    7946:	f8 cf 
    7948:	40 18 82 d3 	bisx.w	#0,	&0xfcffa;r3 As==00
    794c:	fa cf 

0000794e <.L14>:
  asm volatile("nop");
    794e:	03 43       	nop			

00007950 <.Loc.356.3>:
  _enable_interrupts();
    7950:	03 43       	nop			
    7952:	32 d2       	eint			
    7954:	03 43       	nop			

00007956 <.LBE40>:
  }
  chSysUnlock();
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    7956:	40 18 92 d3 	bisx.w	#1,	&0xfcff8;r3 As==01
    795a:	f8 cf 
    795c:	40 18 82 d3 	bisx.w	#0,	&0xfcffa;r3 As==00
    7960:	fa cf 

00007962 <.Loc.111.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    7962:	8d 01 4c 07 	mova	#67404,	r13	;0x1074c
    7966:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    796a:	b0 13 2c 4e 	calla	#20012		;0x04e2c

0000796e <.LVL23>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    796e:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    7972:	b0 13 de a8 	calla	#43230		;0x0a8de

00007976 <.LVL24>:
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    7976:	2a 01 40 08 	mova	&67648,	r10	;0x10840
    797a:	86 01 84 0a 	mova	#68228,	r6	;0x10a84

0000797e <.Loc.128.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    797e:	88 01 6c 0a 	mova	#68204,	r8	;0x10a6c

00007982 <.L15>:
    if (events & UARTConfigUpdated) {
    7982:	40 18 d2 b3 	bitx.b	#1,	&0xfcff8;r3 As==01
    7986:	f8 cf 
    7988:	3d 24       	jz	$+124    	;abs 0x7a04

0000798a <.LBB42>:
  _disable_interrupts();
    798a:	32 c2       	dint			
    798c:	03 43       	nop			

0000798e <.Loc.348.3>:
  asm volatile("nop");
    798e:	03 43       	nop			

00007990 <.LBE42>:
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    7990:	5c 4a 26 00 	mov.b	38(r10),r12	;0x00026
    7994:	4f 4c       	mov.b	r12,	r15	;
    7996:	7f f0 03 00 	and.b	#3,	r15	;
    799a:	6d 46       	mov.b	@r6,	r13	;
    799c:	7d f0 ec ff 	and.b	#-20,	r13	;#0xffec

000079a0 <.Loc.124.1>:
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    79a0:	0e 4c       	mov	r12,	r14	;
    79a2:	5e 07       	rrum	#2,	r14	;
    79a4:	5e f3       	and.b	#1,	r14	;r3 As==01
    79a6:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    79aa:	4d df       	bis.b	r15,	r13	;
    79ac:	4d de       	bis.b	r14,	r13	;

000079ae <.Loc.126.1>:
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    79ae:	5c 0b       	rrum	#3,	r12	;
    79b0:	5c f3       	and.b	#1,	r12	;r3 As==01
    79b2:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    79b6:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    79ba:	4d dc       	bis.b	r12,	r13	;
    79bc:	c6 4d 00 00 	mov.b	r13,	0(r6)	;

000079c0 <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    79c0:	5d 4a 23 00 	mov.b	35(r10),r13	;0x00023
    79c4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    79c8:	5c 4a 25 00 	mov.b	37(r10),r12	;0x00025
    79cc:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    79d0:	5e 4a 24 00 	mov.b	36(r10),r14	;0x00024
    79d4:	0c de       	bis	r14,	r12	;

000079d6 <.Loc.128.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    79d6:	5e 4a 22 00 	mov.b	34(r10),r14	;0x00022
    79da:	0e dd       	bis	r13,	r14	;
    79dc:	88 4e 14 00 	mov	r14,	20(r8)	; 0x0014
    79e0:	88 4c 16 00 	mov	r12,	22(r8)	; 0x0016

000079e4 <.LBB44>:
  asm volatile("nop");
    79e4:	03 43       	nop			

000079e6 <.Loc.356.3>:
  _enable_interrupts();
    79e6:	03 43       	nop			
    79e8:	32 d2       	eint			
    79ea:	03 43       	nop			

000079ec <.LBE44>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
      
      chSysUnlock();
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    79ec:	8d 01 6c 0a 	mova	#68204,	r13	;0x10a6c
    79f0:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    79f4:	b0 13 5e 50 	calla	#20574		;0x0505e

000079f8 <.LVL25>:
      events &= ~UARTConfigUpdated;
    79f8:	40 18 92 c3 	bicx.w	#1,	&0xfcff8;r3 As==01
    79fc:	f8 cf 
    79fe:	40 18 82 c3 	bicx.w	#0,	&0xfcffa;r3 As==00
    7a02:	fa cf 

00007a04 <.L16>:
    }
    if (events & UARTBufferPosted) {
    7a04:	40 18 e2 b3 	bitx.b	#2,	&0xfcff8;r3 As==10
    7a08:	f8 cf 
    7a0a:	31 24       	jz	$+100    	;abs 0x7a6e

00007a0c <.Loc.139.1>:
      if (NULL == tx_active_buffer) {
    7a0c:	00 18 c2 93 	cmpx.a	#0,	&0xfcffe;r3 As==00
    7a10:	fe cf 
    7a12:	1d 20       	jnz	$+60     	;abs 0x7a4e

00007a14 <.LBB46>:
  _disable_interrupts();
    7a14:	32 c2       	dint			
    7a16:	03 43       	nop			

00007a18 <.Loc.348.3>:
  asm volatile("nop");
    7a18:	03 43       	nop			

00007a1a <.LBE46>:
        /* Get the buffer */
        chSysLock();
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    7a1a:	3e 43       	mov	#-1,	r14	;r3 As==11
    7a1c:	8d 00 fe cf 	mova	#53246,	r13	;0x0cffe
    7a20:	8c 01 86 0a 	mova	#68230,	r12	;0x10a86
    7a24:	b0 13 4a 4b 	calla	#19274		;0x04b4a

00007a28 <.LVL26>:
        if (result != MSG_OK) {
    7a28:	9c 00 00 00 	cmpa	#0,	r12	;
    7a2c:	0c 24       	jz	$+26     	;abs 0x7a46

00007a2e <.Loc.144.1>:
          events &= ~UARTBufferPosted;
    7a2e:	40 18 a2 c3 	bicx.w	#2,	&0xfcff8;r3 As==10
    7a32:	f8 cf 
    7a34:	40 18 82 c3 	bicx.w	#0,	&0xfcffa;r3 As==00
    7a38:	fa cf 

00007a3a <.LBB48>:
  asm volatile("nop");
    7a3a:	03 43       	nop			

00007a3c <.Loc.356.3>:
  _enable_interrupts();
    7a3c:	03 43       	nop			
    7a3e:	32 d2       	eint			
    7a40:	03 43       	nop			

00007a42 <.LBE48>:
          chSysUnlock();
          /* Skip to the next loop */
          continue;
    7a42:	80 00 82 79 	mova	#31106,	r0	;0x07982

00007a46 <.L21>:
  asm volatile("nop");
    7a46:	03 43       	nop			

00007a48 <.Loc.356.3>:
  _enable_interrupts();
    7a48:	03 43       	nop			
    7a4a:	32 d2       	eint			
    7a4c:	03 43       	nop			

00007a4e <.L20>:
        }
        chSysUnlock();
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    7a4e:	2d 00 fe cf 	mova	&53246,	r13	;0x0cffe
    7a52:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    7a56:	b0 13 38 a8 	calla	#43064		;0x0a838

00007a5a <.LVL28>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    7a5a:	c0 1f f2 f0 	andx.b	#-4,	&0xfcffc;0xffffc
    7a5e:	fc ff fc cf 

00007a62 <.Loc.158.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    7a62:	40 18 a2 c3 	bicx.w	#2,	&0xfcff8;r3 As==10
    7a66:	f8 cf 
    7a68:	40 18 82 c3 	bicx.w	#0,	&0xfcffa;r3 As==00
    7a6c:	fa cf 

00007a6e <.L18>:
    }
    if (events & UARTRxBufferReady) {
    7a6e:	40 18 e2 b2 	bitx.b	#4,	&0xfcff8;r2 As==10
    7a72:	f8 cf 
    7a74:	08 24       	jz	$+18     	;abs 0x7a86

00007a76 <.Loc.162.1>:
      
      elyUARTDLLRxHandleBuffer();
    7a76:	b0 13 e8 a8 	calla	#43240		;0x0a8e8

00007a7a <.LVL29>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    7a7a:	40 18 a2 c2 	bicx.w	#4,	&0xfcff8;r2 As==10
    7a7e:	f8 cf 
    7a80:	40 18 82 c3 	bicx.w	#0,	&0xfcffa;r3 As==00
    7a84:	fa cf 

00007a86 <.L23>:
    }
    /* Get next events */
    events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    7a86:	4e 43       	clr.b	r14		;
    7a88:	5c 42 fc cf 	mov.b	&0xcffc,r12	;0xcffc
    7a8c:	0d 43       	clr	r13		;
    7a8e:	b0 13 0e 4a 	calla	#18958		;0x04a0e

00007a92 <.LVL30>:
    7a92:	40 18 82 4c 	movx.w	r12,	&0xfcff8;
    7a96:	f8 cf 
    7a98:	40 18 82 4d 	movx.w	r13,	&0xfcffa;
    7a9c:	fa cf 
    7a9e:	80 00 82 79 	mova	#31106,	r0	;0x07982

00007aa2 <elyMainMBPost>:
static PERSIST msg_t main_buffer[elyNLMaxSlots];
static PERSIST MAILBOX_DECL(main_mbox, main_buffer, elyNLMaxSlots);
static PERSIST uint8_t * active_buffer = NULL;

msg_t elyMainMBPost(uint8_t * buffer, systime_t timeout) {
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    7aa2:	0e 4d       	mov	r13,	r14	;
    7aa4:	cd 0c       	mova	r12,	r13	;

00007aa6 <.LVL1>:
    7aa6:	8c 01 9a 0a 	mova	#68250,	r12	;0x10a9a

00007aaa <.LVL2>:
    7aaa:	b0 13 d8 4a 	calla	#19160		;0x04ad8

00007aae <.LVL3>:
}
    7aae:	10 01       	reta			;

00007ab0 <MainThd>:
msg_t elyMainMBPostI(uint8_t * buffer) {
  return chMBPostI(&main_mbox, (msg_t)(buffer));
}

THD_WORKING_AREA(waMainThd, 256);
THD_FUNCTION(MainThd, arg) {
    7ab0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007ab2 <.LCFI0>:
    7ab2:	08 14       	pushm.a	#1,	r8	;20-bit words

00007ab4 <.LCFI1>:
    7ab4:	06 14       	pushm.a	#1,	r6	;20-bit words

00007ab6 <.LCFI2>:
    7ab6:	b1 00 02 00 	suba	#2,	r1	;

00007aba <.LCFI3>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    7aba:	88 00 b8 4b 	mova	#19384,	r8	;0x04bb8

00007abe <.Loc.32.1>:
    }
    
    /* Run Network Layer validation checks */
    /* TODO figure out a better way to deal with this problem, here and below */
    if (!elyNLValidate(active_buffer)) {
    7abe:	86 00 0c be 	mova	#48652,	r6	;0x0be0c

00007ac2 <.L5>:
    if (NULL == active_buffer) {
    7ac2:	00 18 c2 93 	cmpx.a	#0,	&0xfd022;r3 As==00
    7ac6:	22 d0 
    7ac8:	06 20       	jnz	$+14     	;abs 0x7ad6

00007aca <.Loc.27.1>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    7aca:	4e 43       	clr.b	r14		;
    7acc:	8d 00 22 d0 	mova	#53282,	r13	;0x0d022
    7ad0:	8c 01 9a 0a 	mova	#68250,	r12	;0x10a9a
    7ad4:	48 13       	calla	r8		;

00007ad6 <.L6>:
    if (!elyNLValidate(active_buffer)) {
    7ad6:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7ada:	46 13       	calla	r6		;

00007adc <.LVL14>:
    7adc:	2e 00 22 d0 	mova	&53282,	r14	;0x0d022
    7ae0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7ae2:	05 20       	jnz	$+12     	;abs 0x7aee

00007ae4 <.Loc.33.1>:
      elyNLFreeBuffer(active_buffer);
    7ae4:	cc 0e       	mova	r14,	r12	;

00007ae6 <.L26>:
            }
            elyCmdDispatch(hdr, cmd_buffer);
          }
          else {
            /* Invalid command - free the buffer */
            elyNLFreeBuffer(active_buffer);
    7ae6:	b0 13 24 bd 	calla	#48420		;0x0bd24

00007aea <.LBE2>:
          }
        }
        break;
    7aea:	80 00 76 7b 	mova	#31606,	r0	;0x07b76

00007aee <.L7>:
    switch(elyNLGetDest(active_buffer)) {
    7aee:	cc 0e       	mova	r14,	r12	;
    7af0:	b0 13 3c bd 	calla	#48444		;0x0bd3c

00007af4 <.LVL16>:
    7af4:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7af6:	18 24       	jz	$+50     	;abs 0x7b28
    7af8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7afa:	08 24       	jz	$+18     	;abs 0x7b0c
    7afc:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    7afe:	20 24       	jz	$+66     	;abs 0x7b40

00007b00 <.Loc.78.1>:
      default:
        chDbgAssert(false, "shouldn't happen");
    7b00:	8c 01 54 07 	mova	#67412,	r12	;0x10754
    7b04:	b0 13 3e 46 	calla	#17982		;0x0463e

00007b08 <.LVL17>:
        /* ACTUALLY can't happen */
        break;
    7b08:	80 00 76 7b 	mova	#31606,	r0	;0x07b76

00007b0c <.L11>:
        if (MSG_OK != elyUARTPost(active_buffer, TIME_IMMEDIATE)) {
    7b0c:	3d 43       	mov	#-1,	r13	;r3 As==11
    7b0e:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b12:	b0 13 e2 78 	calla	#30946		;0x078e2

00007b16 <.LVL18>:
    7b16:	9c 00 00 00 	cmpa	#0,	r12	;
    7b1a:	2d 24       	jz	$+92     	;abs 0x7b76

00007b1c <.Loc.44.1>:
          elyNLFreeBuffer(active_buffer);
    7b1c:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b20:	b0 13 24 bd 	calla	#48420		;0x0bd24

00007b24 <.LVL19>:
          continue;
    7b24:	80 00 c2 7a 	mova	#31426,	r0	;0x07ac2

00007b28 <.L10>:
        if (MSG_OK != elyRFPost(active_buffer, TIME_IMMEDIATE)) {
    7b28:	3d 43       	mov	#-1,	r13	;r3 As==11
    7b2a:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b2e:	b0 13 06 ad 	calla	#44294		;0x0ad06

00007b32 <.LVL20>:
    7b32:	9c 00 00 00 	cmpa	#0,	r12	;
    7b36:	1f 24       	jz	$+64     	;abs 0x7b76

00007b38 <.L16>:
            elyNLFreeBuffer(active_buffer);
    7b38:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b3c:	80 00 e6 7a 	mova	#31462,	r0	;0x07ae6

00007b40 <.L12>:
          uint8_t * cmd_buffer = elyNLExtract(active_buffer);
    7b40:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b44:	b0 13 66 be 	calla	#48742		;0x0be66

00007b48 <.LVL21>:
    7b48:	ca 0c       	mova	r12,	r10	;

00007b4a <.LVL22>:
          hdr = elyCmdParse(cmd_buffer);
    7b4a:	cd 0c       	mova	r12,	r13	;
    7b4c:	cc 01       	mova	r1,	r12	;
    7b4e:	b0 13 52 7d 	calla	#32082		;0x07d52

00007b52 <.LVL23>:
          if (elyCmdValidate(hdr, cmd_buffer)) {
    7b52:	cd 0a       	mova	r10,	r13	;
    7b54:	cc 01       	mova	r1,	r12	;
    7b56:	b0 13 7e 7d 	calla	#32126		;0x07d7e

00007b5a <.LVL24>:
    7b5a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7b5c:	ed 27       	jz	$-36     	;abs 0x7b38

00007b5e <.Loc.63.1>:
            if (hdr.reply) {
    7b5e:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    7b62:	00 00 
    7b64:	04 24       	jz	$+10     	;abs 0x7b6e

00007b66 <.Loc.67.1>:
              elyNLSetDest(active_buffer);
    7b66:	2c 00 22 d0 	mova	&53282,	r12	;0x0d022
    7b6a:	b0 13 9e bd 	calla	#48542		;0x0bd9e

00007b6e <.L17>:
            elyCmdDispatch(hdr, cmd_buffer);
    7b6e:	cd 0a       	mova	r10,	r13	;
    7b70:	cc 01       	mova	r1,	r12	;
    7b72:	b0 13 fc 7f 	calla	#32764		;0x07ffc

00007b76 <.L14>:
    }
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    7b76:	00 18 c2 43 	movx.a	#0,	&0xfd022;r3 As==00
    7b7a:	22 d0 
    7b7c:	80 00 c2 7a 	mova	#31426,	r0	;0x07ac2

00007b80 <port_lock>:
  _disable_interrupts();
    7b80:	32 c2       	dint			
    7b82:	03 43       	nop			

00007b84 <.Loc.348.1>:
  asm volatile("nop");
    7b84:	03 43       	nop			

00007b86 <.Loc.349.1>:
}
    7b86:	10 01       	reta			;

00007b88 <port_unlock>:
  asm volatile("nop");
    7b88:	03 43       	nop			

00007b8a <.Loc.356.1>:
  _enable_interrupts();
    7b8a:	03 43       	nop			
    7b8c:	32 d2       	eint			
    7b8e:	03 43       	nop			

00007b90 <.Loc.357.1>:
}
    7b90:	10 01       	reta			;

00007b92 <reset>:
  }
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLPack(buffer));
    7b92:	b0 13 78 be 	calla	#48760		;0x0be78

00007b96 <.LVL1>:
    7b96:	b0 13 24 bd 	calla	#48420		;0x0bd24

00007b9a <.LVL2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7b9a:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    7b9e:	48 a5 20 01 

00007ba2 <.Loc.42.2>:
}
    7ba2:	10 01       	reta			;

00007ba4 <gen_success>:
static inline void gen_success(uint8_t *buffer, uint8_t crc) {
    7ba4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007ba8 <.Loc.18.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7ba8:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    7bac:	00 00 

00007bae <.Loc.19.2>:
  buffer[1] = (crc ? 3 : 1);
    7bae:	0d 93       	cmp	#0,	r13	;r3 As==00
    7bb0:	14 20       	jnz	$+42     	;abs 0x7bda
    7bb2:	5e 43       	mov.b	#1,	r14	;r3 As==01

00007bb4 <.L5>:
    7bb4:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00007bb8 <.Loc.20.2>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7bb8:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    7bbc:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7bc0:	02 00 

00007bc2 <.Loc.21.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7bc2:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7bc6:	03 00 

00007bc8 <.Loc.22.2>:
  buffer[4] = 1;
    7bc8:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00007bcc <.Loc.23.2>:
  if (crc) {
    7bcc:	0d 93       	cmp	#0,	r13	;r3 As==00
    7bce:	04 24       	jz	$+10     	;abs 0x7bd8

00007bd0 <.Loc.24.2>:
    crcGenX25(buffer, 7);
    7bd0:	7d 40 07 00 	mov.b	#7,	r13	;

00007bd4 <.LVL4>:
    7bd4:	b0 13 50 ab 	calla	#43856		;0x0ab50

00007bd8 <.L4>:
}
    7bd8:	10 01       	reta			;

00007bda <.L7>:
  buffer[1] = (crc ? 3 : 1);
    7bda:	7e 40 03 00 	mov.b	#3,	r14	;
    7bde:	80 00 b4 7b 	mova	#31668,	r0	;0x07bb4

00007be2 <gen_failure>:
static inline void gen_failure(uint8_t *buffer, uint8_t crc) {
    7be2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007be6 <.Loc.29.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    7be6:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    7bea:	00 00 

00007bec <.Loc.30.2>:
  buffer[1] = (crc ? 2 : 0);
    7bec:	0d 93       	cmp	#0,	r13	;r3 As==00
    7bee:	12 20       	jnz	$+38     	;abs 0x7c14
    7bf0:	0e 4d       	mov	r13,	r14	;

00007bf2 <.L12>:
    7bf2:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00007bf6 <.Loc.31.2>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    7bf6:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    7bfa:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7bfe:	02 00 

00007c00 <.Loc.32.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    7c00:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7c04:	03 00 

00007c06 <.Loc.33.2>:
  if (crc) {
    7c06:	0d 93       	cmp	#0,	r13	;r3 As==00
    7c08:	04 24       	jz	$+10     	;abs 0x7c12

00007c0a <.Loc.34.2>:
    crcGenX25(buffer, 6);
    7c0a:	7d 40 06 00 	mov.b	#6,	r13	;

00007c0e <.LVL8>:
    7c0e:	b0 13 50 ab 	calla	#43856		;0x0ab50

00007c12 <.L11>:
}
    7c12:	10 01       	reta			;

00007c14 <.L14>:
  buffer[1] = (crc ? 2 : 0);
    7c14:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7c16:	80 00 f2 7b 	mova	#31730,	r0	;0x07bf2

00007c1a <store_telem>:
  elyNLFreeBufferI(buffer);
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7c1a:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007c1c <.LCFI0>:
    7c1c:	b1 00 02 00 	suba	#2,	r1	;

00007c20 <.LCFI1>:
    7c20:	c8 0c       	mova	r12,	r8	;
    7c22:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00007c26 <.LVL12>:
    7c26:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00007c2a <.Loc.1645.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c2a:	6c 41       	mov.b	@r1,	r12	;

00007c2c <.LVL14>:
    7c2c:	4d 4c       	mov.b	r12,	r13	;

00007c2e <.LVL15>:
    7c2e:	6d f3       	and.b	#2,	r13	;r3 As==10
    7c30:	47 4d       	mov.b	r13,	r7	;
    7c32:	07 93       	cmp	#0,	r7	;r3 As==00
    7c34:	19 20       	jnz	$+52     	;abs 0x7c68
    7c36:	69 43       	mov.b	#2,	r9	;r3 As==10

00007c38 <.L19>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7c38:	1c b3       	bit	#1,	r12	;r3 As==01
    7c3a:	19 20       	jnz	$+52     	;abs 0x7c6e

00007c3c <.Loc.1646.2>:
    7c3c:	4c 43       	clr.b	r12		;

00007c3e <.L20>:
    7c3e:	4a 8d       	sub.b	r13,	r10	;

00007c40 <.LVL17>:
    7c40:	4a 8c       	sub.b	r12,	r10	;

00007c42 <.LVL18>:
  
  chSysLock();
    7c42:	b0 13 80 7b 	calla	#31616		;0x07b80

00007c46 <.LVL19>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    7c46:	40 18 0c 49 	movx.w	r9,	r12	;
    7c4a:	ec 08       	adda	r8,	r12	;
    7c4c:	40 18 0d 4a 	movx.w	r10,	r13	;
    7c50:	07 93       	cmp	#0,	r7	;r3 As==00
    7c52:	10 20       	jnz	$+34     	;abs 0x7c74

00007c54 <.Loc.1649.2>:
    7c54:	8e 00 7c 7c 	mova	#31868,	r14	;0x07c7c

00007c58 <.L21>:
    7c58:	b0 13 88 c1 	calla	#49544		;0x0c188

00007c5c <.LVL20>:
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
    7c5c:	b0 13 88 7b 	calla	#31624		;0x07b88

00007c60 <.LVL21>:
  
  /* Reply is posted from callback if needed */
}
    7c60:	a1 00 02 00 	adda	#2,	r1	;
    7c64:	37 16       	popm.a	#4,	r10	;20-bit words
    7c66:	10 01       	reta			;

00007c68 <.L22>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c68:	69 42       	mov.b	#4,	r9	;r2 As==10
    7c6a:	80 00 38 7c 	mova	#31800,	r0	;0x07c38

00007c6e <.L23>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7c6e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7c70:	80 00 3e 7c 	mova	#31806,	r0	;0x07c3e

00007c74 <.L24>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    7c74:	8e 00 88 80 	mova	#32904,	r14	;0x08088
    7c78:	80 00 58 7c 	mova	#31832,	r0	;0x07c58

00007c7c <store_telem_noreply_cb>:
  elyNLFreeBufferI(buffer);
    7c7c:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

00007c80 <.LVL27>:
    7c80:	b0 13 30 bd 	calla	#48432		;0x0bd30

00007c84 <.LVL28>:
}
    7c84:	10 01       	reta			;

00007c86 <upload_fw_noreply_cb>:
  elyNLFreeBufferI(elyNLPack(buffer));
    7c86:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

00007c8a <.LVL31>:
    7c8a:	b0 13 78 be 	calla	#48760		;0x0be78

00007c8e <.LVL32>:
    7c8e:	b0 13 30 bd 	calla	#48432		;0x0bd30

00007c92 <.LVL33>:
}
    7c92:	10 01       	reta			;

00007c94 <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7c94:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007c96 <.LCFI2>:
    7c96:	b1 00 06 00 	suba	#6,	r1	;

00007c9a <.LCFI3>:
    7c9a:	ce 0c       	mova	r12,	r14	;

00007c9c <.Loc.1476.2>:
    7c9c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7ca0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7ca4:	01 00 

00007ca6 <.Loc.1477.2>:
  if (hdr.reply) {
    7ca6:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    7caa:	00 00 
    7cac:	39 24       	jz	$+116    	;abs 0x7d20

00007cae <.LBB36>:
    stored_buff = buffer; /* store for freeing */
    7cae:	60 0c 4e d0 	mova	r12,	&53326	; 0x0d04e

00007cb2 <.Loc.1480.2>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    7cb2:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00007cb6 <.LVL36>:
    7cb6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7cba:	5e 4e 05 00 	mov.b	5(r14),	r14	;

00007cbe <.LVL37>:
    7cbe:	0e dc       	bis	r12,	r14	;
    7cc0:	40 18 82 4e 	movx.w	r14,	&0xfd052;
    7cc4:	52 d0 

00007cc6 <.Loc.1483.2>:
    volatile uint8_t * crc_addr = crcStart();
    7cc6:	b0 13 2e ac 	calla	#44078		;0x0ac2e

00007cca <.LVL38>:
    7cca:	ca 0c       	mova	r12,	r10	;

00007ccc <.LVL39>:
    elyFramGetRequest(&req);
    7ccc:	cc 01       	mova	r1,	r12	;
    7cce:	ac 00 02 00 	adda	#2,	r12	;
    7cd2:	b0 13 00 ba 	calla	#47616		;0x0ba00

00007cd6 <.LVL40>:
    req->address = FRAM_FW_BASE; 
    7cd6:	3c 01 02 00 	mova	2(r1),	r12	;
    7cda:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    7cde:	00 00 
    7ce0:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

00007ce4 <.Loc.1494.2>:
    req->special = 1; /* read to a constant register address */
    7ce4:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    7ce8:	04 00 

00007cea <.Loc.1495.2>:
    req->size = FRAM_FW_SIZE;
    7cea:	1d 4c 04 00 	mov	4(r12),	r13	;
    7cee:	7d f0 03 00 	and.b	#3,	r13	;
    7cf2:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    7cf6:	8c 4d 04 00 	mov	r13,	4(r12)	;
    7cfa:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    7cfe:	7d d0 03 00 	bis.b	#3,	r13	;
    7d02:	6d c2       	bic.b	#4,	r13	;r2 As==10
    7d04:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

00007d08 <.Loc.1497.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    7d08:	7c 0a 08 00 	mova	r10,	8(r12)	;

00007d0c <.Loc.1498.2>:
    req->callback = verify_fw_cb;
    7d0c:	00 18 fc 40 	movx.a	#32936,	12(r12)	;0x080a8, 0x0000c
    7d10:	a8 80 0c 00 

00007d14 <.Loc.1504.2>:
    elyFramPostRequest(req);
    7d14:	b0 13 1a ba 	calla	#47642		;0x0ba1a

00007d18 <.L27>:
}
    7d18:	a1 00 06 00 	adda	#6,	r1	;
    7d1c:	0a 16       	popm.a	#1,	r10	;20-bit words
    7d1e:	10 01       	reta			;

00007d20 <.L28>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7d20:	b0 13 78 be 	calla	#48760		;0x0be78

00007d24 <.LVL43>:
    7d24:	b0 13 24 bd 	calla	#48420		;0x0bd24

00007d28 <.LVL44>:
}
    7d28:	80 00 18 7d 	mova	#32024,	r0	;0x07d18

00007d2c <get_active_bank.part.12>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7d2c:	b0 13 78 be 	calla	#48760		;0x0be78

00007d30 <.LVL46>:
    7d30:	b0 13 24 bd 	calla	#48420		;0x0bd24

00007d34 <.LVL47>:
}
    7d34:	10 01       	reta			;

00007d36 <cancel_fw_eeprom_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    7d36:	40 18 1c 42 	movx.w	&0x0d04c,r12	;
    7d3a:	4c d0 

00007d3c <.LVL50>:
    7d3c:	4d 43       	clr.b	r13		;
    7d3e:	0d 9c       	cmp	r12,	r13	;
    7d40:	04 38       	jl	$+10     	;abs 0x7d4a

00007d42 <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    7d42:	8c 00 4c d0 	mova	#53324,	r12	;0x0d04c
    7d46:	b0 13 2e 49 	calla	#18734		;0x0492e

00007d4a <.L32>:
  pages_acked++;
    7d4a:	40 18 92 53 	incx.w	&0xd048		;
    7d4e:	48 d0 

00007d50 <.Loc.1517.2>:
}
    7d50:	10 01       	reta			;

00007d52 <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * buffer) {
    7d52:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007d54 <.LCFI4>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (buffer[0] >> 7);
    7d54:	6f 4d       	mov.b	@r13,	r15	;

00007d56 <.LVL53>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
  hdr.opcode = (buffer[0] & 0x3F);
  hdr.length = buffer[1];
    7d56:	5b 4d 01 00 	mov.b	1(r13),	r11	;

00007d5a <.LVL54>:
  return hdr;
    7d5a:	0a 4f       	mov	r15,	r10	;
    7d5c:	5a 0f       	rrum	#4,	r10	;
    7d5e:	5a 0b       	rrum	#3,	r10	;

00007d60 <.Loc.1758.2>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
    7d60:	0d 4f       	mov	r15,	r13	;

00007d62 <.LVL55>:
    7d62:	5d 0f       	rrum	#4,	r13	;
    7d64:	5d 07       	rrum	#2,	r13	;

00007d66 <.Loc.1761.2>:
  return hdr;
    7d66:	0d 5d       	rla	r13		;
    7d68:	6d f3       	and.b	#2,	r13	;r3 As==10
    7d6a:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;

00007d6e <.LVL56>:
    7d6e:	4d da       	bis.b	r10,	r13	;
    7d70:	4d df       	bis.b	r15,	r13	;
    7d72:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    7d76:	cc 4b 01 00 	mov.b	r11,	1(r12)	;

00007d7a <.LVL57>:
}
    7d7a:	0a 16       	popm.a	#1,	r10	;20-bit words
    7d7c:	10 01       	reta			;

00007d7e <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7d7e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007d80 <.LCFI5>:
    7d80:	b1 00 02 00 	suba	#2,	r1	;

00007d84 <.LCFI6>:
    7d84:	ca 0d       	mova	r13,	r10	;
    7d86:	69 4c       	mov.b	@r12,	r9	;
    7d88:	0f 49       	mov	r9,	r15	;
    7d8a:	5f 07       	rrum	#2,	r15	;

00007d8c <.LVL59>:
    7d8c:	58 4c 01 00 	mov.b	1(r12),	r8	;

00007d90 <.LVL60>:
    7d90:	c1 48 01 00 	mov.b	r8,	1(r1)	;

00007d94 <.Loc.1767.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    7d94:	77 40 2f 00 	mov.b	#47,	r7	;#0x002f
    7d98:	07 9f       	cmp	r15,	r7	;
    7d9a:	07 34       	jge	$+16     	;abs 0x7daa

00007d9c <.Loc.1768.2>:
    elyErrorSignal(ErrInvalidOpcode);
    7d9c:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

00007da0 <.L178>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    7da0:	b0 13 32 bf 	calla	#48946		;0x0bf32

00007da4 <.L66>:
      return false;
    7da4:	4a 43       	clr.b	r10		;

00007da6 <.LVL64>:
    7da6:	80 00 22 7e 	mova	#32290,	r0	;0x07e22

00007daa <.L35>:
  if (hdr.reply) {
    7daa:	79 f0 03 00 	and.b	#3,	r9	;
    7dae:	0c 4f       	mov	r15,	r12	;
    7db0:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7db4:	49 dc       	bis.b	r12,	r9	;
    7db6:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    7dba:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7dbe:	4d 49       	mov.b	r9,	r13	;
    7dc0:	6d f3       	and.b	#2,	r13	;r3 As==10
    7dc2:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    7dc4:	0a 24       	jz	$+22     	;abs 0x7dda

00007dc6 <.Loc.1774.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    7dc6:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    7dca:	da 9c 51 00 	cmp.b	81(r12),2(r10)	;0x00051
    7dce:	02 00 
    7dd0:	04 20       	jnz	$+10     	;abs 0x7dda

00007dd2 <.Loc.1774.2>:
    7dd2:	da 9c 50 00 	cmp.b	80(r12),3(r10)	;0x00050
    7dd6:	03 00 
    7dd8:	e5 27       	jz	$-52     	;abs 0x7da4

00007dda <.L37>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7dda:	59 f3       	and.b	#1,	r9	;r3 As==01
    7ddc:	09 93       	cmp	#0,	r9	;r3 As==00
    7dde:	26 24       	jz	$+78     	;abs 0x7e2c
    7de0:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007de2 <.L38>:
    7de2:	40 18 4e 48 	movx.b	r8,	r14	;
    7de6:	40 18 4e 8d 	subx.b	r13,	r14	;
    7dea:	4e 8c       	sub.b	r12,	r14	;
    7dec:	4d 4e       	mov.b	r14,	r13	;

00007dee <.LVL66>:
  switch(hdr.opcode) {
    7dee:	7f 90 16 00 	cmp.b	#22,	r15	;#0x0016
    7df2:	4f 24       	jz	$+160    	;abs 0x7e92
    7df4:	77 40 16 00 	mov.b	#22,	r7	;#0x0016
    7df8:	47 9f       	cmp.b	r15,	r7	;
    7dfa:	70 28       	jnc	$+226    	;abs 0x7edc
    7dfc:	7f 90 0a 00 	cmp.b	#10,	r15	;#0x000a
    7e00:	48 24       	jz	$+146    	;abs 0x7e92
    7e02:	77 40 0a 00 	mov.b	#10,	r7	;#0x000a
    7e06:	47 9f       	cmp.b	r15,	r7	;
    7e08:	30 28       	jnc	$+98     	;abs 0x7e6a
    7e0a:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    7e0c:	cf 24       	jz	$+416    	;abs 0x7fac
    7e0e:	67 42       	mov.b	#4,	r7	;r2 As==10
    7e10:	47 9f       	cmp.b	r15,	r7	;
    7e12:	0f 28       	jnc	$+32     	;abs 0x7e32
    7e14:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7e16:	3d 20       	jnz	$+124    	;abs 0x7e92

00007e18 <.L45>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    7e18:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    7e1a:	3d 20       	jnz	$+124    	;abs 0x7e96

00007e1c <.L62>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    7e1c:	09 93       	cmp	#0,	r9	;r3 As==00
    7e1e:	de 20       	jnz	$+446    	;abs 0x7fdc

00007e20 <.L65>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    7e20:	5a 43       	mov.b	#1,	r10	;r3 As==01

00007e22 <.L36>:
  
}
    7e22:	4c 4a       	mov.b	r10,	r12	;
    7e24:	a1 00 02 00 	adda	#2,	r1	;
    7e28:	37 16       	popm.a	#4,	r10	;20-bit words
    7e2a:	10 01       	reta			;

00007e2c <.L67>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7e2c:	0c 49       	mov	r9,	r12	;
    7e2e:	80 00 e2 7d 	mova	#32226,	r0	;0x07de2

00007e32 <.L44>:
  switch(hdr.opcode) {
    7e32:	7f 90 07 00 	cmp.b	#7,	r15	;
    7e36:	ca 24       	jz	$+406    	;abs 0x7fcc
    7e38:	77 40 07 00 	mov.b	#7,	r7	;
    7e3c:	47 9f       	cmp.b	r15,	r7	;
    7e3e:	0c 28       	jnc	$+26     	;abs 0x7e58
    7e40:	7f 90 05 00 	cmp.b	#5,	r15	;
    7e44:	b9 24       	jz	$+372    	;abs 0x7fb8
    7e46:	7f 90 06 00 	cmp.b	#6,	r15	;
    7e4a:	ab 24       	jz	$+344    	;abs 0x7fa2

00007e4c <.L39>:
      chDbgAssert(false, "invalid opcode in length check");
    7e4c:	8c 01 6d 07 	mova	#67437,	r12	;0x1076d
    7e50:	b0 13 3e 46 	calla	#17982		;0x0463e

00007e54 <.LVL71>:
    7e54:	80 00 1c 7e 	mova	#32284,	r0	;0x07e1c

00007e58 <.L47>:
  switch(hdr.opcode) {
    7e58:	7f 92       	cmp.b	#8,	r15	;r2 As==11
    7e5a:	1b 24       	jz	$+56     	;abs 0x7e92
    7e5c:	7f 90 09 00 	cmp.b	#9,	r15	;
    7e60:	f5 23       	jnz	$-20     	;abs 0x7e4c

00007e62 <.L175>:
      if (payload_len != 2 && payload_len != 4 && 
    7e62:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    7e64:	18 20       	jnz	$+50     	;abs 0x7e96
    7e66:	80 00 1c 7e 	mova	#32284,	r0	;0x07e1c

00007e6a <.L42>:
  switch(hdr.opcode) {
    7e6a:	7f 90 10 00 	cmp.b	#16,	r15	;#0x0010
    7e6e:	11 24       	jz	$+36     	;abs 0x7e92
    7e70:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    7e74:	47 9f       	cmp.b	r15,	r7	;
    7e76:	1b 28       	jnc	$+56     	;abs 0x7eae
    7e78:	7f 90 0d 00 	cmp.b	#13,	r15	;#0x000d
    7e7c:	f2 27       	jz	$-26     	;abs 0x7e62
    7e7e:	77 40 0d 00 	mov.b	#13,	r7	;#0x000d
    7e82:	47 9f       	cmp.b	r15,	r7	;
    7e84:	0c 28       	jnc	$+26     	;abs 0x7e9e
    7e86:	7f 90 0b 00 	cmp.b	#11,	r15	;#0x000b
    7e8a:	eb 27       	jz	$-40     	;abs 0x7e62
    7e8c:	7f 90 0c 00 	cmp.b	#12,	r15	;#0x000c
    7e90:	dd 23       	jnz	$-68     	;abs 0x7e4c

00007e92 <.L40>:
      if (payload_len != 0) {
    7e92:	0d 93       	cmp	#0,	r13	;r3 As==00
    7e94:	c3 27       	jz	$-120    	;abs 0x7e1c

00007e96 <.L63>:
        elyErrorSignal(ErrInvalidLength);
    7e96:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    7e9a:	80 00 a0 7d 	mova	#32160,	r0	;0x07da0

00007e9e <.L52>:
  switch(hdr.opcode) {
    7e9e:	7f 90 0e 00 	cmp.b	#14,	r15	;#0x000e
    7ea2:	f7 27       	jz	$-16     	;abs 0x7e92
    7ea4:	7f 90 0f 00 	cmp.b	#15,	r15	;#0x000f
    7ea8:	dc 27       	jz	$-70     	;abs 0x7e62
    7eaa:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007eae <.L51>:
    7eae:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    7eb2:	d7 27       	jz	$-80     	;abs 0x7e62
    7eb4:	77 40 13 00 	mov.b	#19,	r7	;#0x0013
    7eb8:	47 9f       	cmp.b	r15,	r7	;
    7eba:	08 28       	jnc	$+18     	;abs 0x7ecc
    7ebc:	7f 90 11 00 	cmp.b	#17,	r15	;#0x0011
    7ec0:	d0 27       	jz	$-94     	;abs 0x7e62
    7ec2:	7f 90 12 00 	cmp.b	#18,	r15	;#0x0012
    7ec6:	e5 27       	jz	$-52     	;abs 0x7e92
    7ec8:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007ecc <.L53>:
    7ecc:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    7ed0:	e0 27       	jz	$-62     	;abs 0x7e92
    7ed2:	7f 90 15 00 	cmp.b	#21,	r15	;#0x0015
    7ed6:	a0 27       	jz	$-190    	;abs 0x7e18
    7ed8:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007edc <.L41>:
    7edc:	7f 90 24 00 	cmp.b	#36,	r15	;#0x0024
    7ee0:	c0 27       	jz	$-126    	;abs 0x7e62
    7ee2:	77 40 24 00 	mov.b	#36,	r7	;#0x0024
    7ee6:	47 9f       	cmp.b	r15,	r7	;
    7ee8:	31 28       	jnc	$+100    	;abs 0x7f4c
    7eea:	7f 90 1c 00 	cmp.b	#28,	r15	;#0x001c
    7eee:	5e 24       	jz	$+190    	;abs 0x7fac
    7ef0:	77 40 1c 00 	mov.b	#28,	r7	;#0x001c
    7ef4:	47 9f       	cmp.b	r15,	r7	;
    7ef6:	1b 28       	jnc	$+56     	;abs 0x7f2e
    7ef8:	7f 90 19 00 	cmp.b	#25,	r15	;#0x0019
    7efc:	12 24       	jz	$+38     	;abs 0x7f22
    7efe:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    7f02:	4d 9f       	cmp.b	r15,	r13	;
    7f04:	08 28       	jnc	$+18     	;abs 0x7f16
    7f06:	7f 90 17 00 	cmp.b	#23,	r15	;#0x0017
    7f0a:	ab 27       	jz	$-168    	;abs 0x7e62
    7f0c:	7f 90 18 00 	cmp.b	#24,	r15	;#0x0018
    7f10:	83 27       	jz	$-248    	;abs 0x7e18
    7f12:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007f16 <.L57>:
    7f16:	7f 90 1a 00 	cmp.b	#26,	r15	;#0x001a
    7f1a:	48 24       	jz	$+146    	;abs 0x7fac
    7f1c:	7f 90 1b 00 	cmp.b	#27,	r15	;#0x001b
    7f20:	95 23       	jnz	$-212    	;abs 0x7e4c

00007f22 <.L56>:
      if (payload_len < 4 || payload_len > 251) {
    7f22:	7e 50 fc ff 	add.b	#-4,	r14	;#0xfffc

00007f26 <.LVL77>:
    7f26:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    7f2a:	80 00 b0 7f 	mova	#32688,	r0	;0x07fb0

00007f2e <.L55>:
  switch(hdr.opcode) {
    7f2e:	77 40 22 00 	mov.b	#34,	r7	;#0x0022
    7f32:	47 9f       	cmp.b	r15,	r7	;
    7f34:	ae 2b       	jnc	$-162    	;abs 0x7e92
    7f36:	7f 90 1f 00 	cmp.b	#31,	r15	;#0x001f
    7f3a:	38 2c       	jc	$+114    	;abs 0x7fac
    7f3c:	7f 90 1d 00 	cmp.b	#29,	r15	;#0x001d
    7f40:	6b 27       	jz	$-296    	;abs 0x7e18
    7f42:	7f 90 1e 00 	cmp.b	#30,	r15	;#0x001e
    7f46:	82 23       	jnz	$-250    	;abs 0x7e4c
    7f48:	80 00 92 7e 	mova	#32402,	r0	;0x07e92

00007f4c <.L54>:
    7f4c:	7f 90 2a 00 	cmp.b	#42,	r15	;#0x002a
    7f50:	e8 27       	jz	$-46     	;abs 0x7f22
    7f52:	77 40 2a 00 	mov.b	#42,	r7	;#0x002a
    7f56:	47 9f       	cmp.b	r15,	r7	;
    7f58:	0e 28       	jnc	$+30     	;abs 0x7f76
    7f5a:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    7f5e:	5c 27       	jz	$-326    	;abs 0x7e18
    7f60:	7f 90 27 00 	cmp.b	#39,	r15	;#0x0027
    7f64:	96 2b       	jnc	$-210    	;abs 0x7e92
    7f66:	7f 90 28 00 	cmp.b	#40,	r15	;#0x0028
    7f6a:	93 27       	jz	$-216    	;abs 0x7e92
    7f6c:	7f 90 29 00 	cmp.b	#41,	r15	;#0x0029
    7f70:	53 27       	jz	$-344    	;abs 0x7e18
    7f72:	80 00 4c 7e 	mova	#32332,	r0	;0x07e4c

00007f76 <.L58>:
    7f76:	77 40 2d 00 	mov.b	#45,	r7	;#0x002d
    7f7a:	47 9f       	cmp.b	r15,	r7	;
    7f7c:	07 28       	jnc	$+16     	;abs 0x7f8c
    7f7e:	7f 90 2c 00 	cmp.b	#44,	r15	;#0x002c
    7f82:	87 2f       	jc	$-240    	;abs 0x7e92

00007f84 <.Loc.1820.2>:
      if (payload_len != 2) {
    7f84:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    7f86:	4a 27       	jz	$-362    	;abs 0x7e1c
    7f88:	80 00 96 7e 	mova	#32406,	r0	;0x07e96

00007f8c <.L59>:
  switch(hdr.opcode) {
    7f8c:	7f 90 2e 00 	cmp.b	#46,	r15	;#0x002e
    7f90:	0d 24       	jz	$+28     	;abs 0x7fac
    7f92:	7f 90 2f 00 	cmp.b	#47,	r15	;#0x002f
    7f96:	5a 23       	jnz	$-330    	;abs 0x7e4c

00007f98 <.Loc.1848.2>:
      if (payload_len != 2 && payload_len != 4 && 
    7f98:	7e c2       	bic.b	#8,	r14	;r2 As==11

00007f9a <.LVL79>:
    7f9a:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    7f9c:	62 23       	jnz	$-314    	;abs 0x7e62
    7f9e:	80 00 1c 7e 	mova	#32284,	r0	;0x07e1c

00007fa2 <.L49>:
      if (payload_len != 3) {
    7fa2:	7e 90 03 00 	cmp.b	#3,	r14	;
    7fa6:	3a 27       	jz	$-394    	;abs 0x7e1c
    7fa8:	80 00 96 7e 	mova	#32406,	r0	;0x07e96

00007fac <.L43>:
      if (payload_len > 251) {
    7fac:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb

00007fb0 <.L177>:
      if (payload_len < 4 || payload_len > 251) {
    7fb0:	4c 9e       	cmp.b	r14,	r12	;
    7fb2:	34 2f       	jc	$-406    	;abs 0x7e1c
    7fb4:	80 00 96 7e 	mova	#32406,	r0	;0x07e96

00007fb8 <.L48>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    7fb8:	4c 4e       	mov.b	r14,	r12	;
    7fba:	7c 53       	add.b	#-1,	r12	;r3 As==11
    7fbc:	7d 40 fa ff 	mov.b	#-6,	r13	;#0xfffa
    7fc0:	4d 9c       	cmp.b	r12,	r13	;
    7fc2:	69 2b       	jnc	$-300    	;abs 0x7e96

00007fc4 <.Loc.1870.2>:
    7fc4:	1e b3       	bit	#1,	r14	;r3 As==01
    7fc6:	2a 23       	jnz	$-426    	;abs 0x7e1c
    7fc8:	80 00 96 7e 	mova	#32406,	r0	;0x07e96

00007fcc <.L46>:
      if (payload_len < 2 || payload_len > 251) {
    7fcc:	7e 50 fe ff 	add.b	#-2,	r14	;#0xfffe

00007fd0 <.LVL83>:
    7fd0:	77 40 f9 ff 	mov.b	#-7,	r7	;#0xfff9
    7fd4:	47 9e       	cmp.b	r14,	r7	;
    7fd6:	22 2f       	jc	$-442    	;abs 0x7e1c
    7fd8:	80 00 96 7e 	mova	#32406,	r0	;0x07e96

00007fdc <.L64>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    7fdc:	0d 48       	mov	r8,	r13	;
    7fde:	2d 53       	incd	r13		;
    7fe0:	4d 0e       	rlam.a	#4,	r13	;
    7fe2:	4d 0d       	rram.a	#4,	r13	;
    7fe4:	cc 0a       	mova	r10,	r12	;
    7fe6:	b0 13 c4 ab 	calla	#43972		;0x0abc4

00007fea <.LVL85>:
    7fea:	4a 4c       	mov.b	r12,	r10	;

00007fec <.LVL86>:
    7fec:	0a 93       	cmp	#0,	r10	;r3 As==00
    7fee:	18 23       	jnz	$-462    	;abs 0x7e20

00007ff0 <.Loc.1900.2>:
      elyErrorSignal(ErrFCSError);
    7ff0:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    7ff4:	b0 13 32 bf 	calla	#48946		;0x0bf32

00007ff8 <.LVL87>:
      return false;
    7ff8:	80 00 22 7e 	mova	#32290,	r0	;0x07e22

00007ffc <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7ffc:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007ffe <.LCFI7>:
    7ffe:	b1 00 06 00 	suba	#6,	r1	;

00008002 <.LCFI8>:
    8002:	ca 0c       	mova	r12,	r10	;
    8004:	cc 0d       	mova	r13,	r12	;
    8006:	6e 4a       	mov.b	@r10,	r14	;
    8008:	0d 4e       	mov	r14,	r13	;

0000800a <.LVL89>:
    800a:	5d 07       	rrum	#2,	r13	;

0000800c <.LVL90>:
    800c:	d1 4a 01 00 	mov.b	1(r10),	5(r1)	;
    8010:	05 00 

00008012 <.Loc.1911.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    8012:	0a 4d       	mov	r13,	r10	;
    8014:	0b 43       	clr	r11		;
    8016:	08 4a       	mov	r10,	r8	;
    8018:	09 4b       	mov	r11,	r9	;
    801a:	08 58       	rla	r8		;
    801c:	09 69       	rlc	r9		;
    801e:	08 58       	rla	r8		;
    8020:	09 69       	rlc	r9		;
    8022:	81 48 00 00 	mov	r8,	0(r1)	;
    8026:	81 49 02 00 	mov	r9,	2(r1)	;
    802a:	08 01       	mova	@r1,	r8	;
    802c:	80 18 5a 48 	movx.a	67452(r8),r10	;0x1077c
    8030:	7c 07 
    8032:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;

00008036 <.LVL92>:
    8036:	7e f0 03 00 	and.b	#3,	r14	;

0000803a <.LVL93>:
    803a:	4e dd       	bis.b	r13,	r14	;
    803c:	c1 4e 04 00 	mov.b	r14,	4(r1)	;
    8040:	cd 01       	mova	r1,	r13	;
    8042:	ad 00 04 00 	adda	#4,	r13	;
    8046:	4a 13       	calla	r10		;

00008048 <.LVL94>:
}
    8048:	a1 00 06 00 	adda	#6,	r1	;
    804c:	28 16       	popm.a	#3,	r10	;20-bit words
    804e:	10 01       	reta			;

00008050 <elyCmdSendReplyI>:
  msg = elyCmdSendReplyI(buff);
  chSysUnlock();
  return msg;
}

msg_t elyCmdSendReplyI(uint8_t * buff) {
    8050:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008052 <.LCFI9>:
  uint8_t * buffer = elyNLPack(buff);
    8052:	b0 13 78 be 	calla	#48760		;0x0be78

00008056 <.LVL96>:
    8056:	ca 0c       	mova	r12,	r10	;

00008058 <.Loc.1924.2>:
  switch (elyNLGetDest(buffer)) {
    8058:	b0 13 3c bd 	calla	#48444		;0x0bd3c

0000805c <.LVL98>:
    805c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    805e:	07 24       	jz	$+16     	;abs 0x806e
    8060:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    8062:	0a 20       	jnz	$+22     	;abs 0x8078

00008064 <.Loc.1926.2>:
    case ELY_DEST_RF:
      return elyRFPostI(buffer);
    8064:	cc 0a       	mova	r10,	r12	;
    8066:	b0 13 de ac 	calla	#44254		;0x0acde

0000806a <.L180>:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
  /* also shouldn't happen */
  return MSG_RESET;
}
    806a:	0a 16       	popm.a	#1,	r10	;20-bit words
    806c:	10 01       	reta			;

0000806e <.L182>:
      return elyUARTPostI(buffer);
    806e:	cc 0a       	mova	r10,	r12	;
    8070:	b0 13 bc 78 	calla	#30908		;0x078bc

00008074 <.LVL100>:
    8074:	80 00 6a 80 	mova	#32874,	r0	;0x0806a

00008078 <.L185>:
      chDbgAssert(false, "shouldn't happen");
    8078:	8c 01 5c 07 	mova	#67420,	r12	;0x1075c
    807c:	b0 13 3e 46 	calla	#17982		;0x0463e

00008080 <.LVL101>:
  return MSG_RESET;
    8080:	8c 0f fe ff 	mova	#-2,	r12	;0xfffffffe
    8084:	80 00 6a 80 	mova	#32874,	r0	;0x0806a

00008088 <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buffer) {
    8088:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000808a <.LCFI10>:
  buffer = buffer - 4;
    808a:	ca 0c       	mova	r12,	r10	;
    808c:	aa 0f fc ff 	adda	#1048572,r10	;0xffffc

00008090 <.LVL103>:
  gen_success(buffer, buffer[0] & 0x80); /* crc */
    8090:	5d 4c fc ff 	mov.b	-4(r12),r13	;
    8094:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    8098:	cc 0a       	mova	r10,	r12	;
    809a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000809e <.LVL104>:
  elyCmdSendReplyI(buffer);
    809e:	cc 0a       	mova	r10,	r12	;
    80a0:	b0 13 50 80 	calla	#32848		;0x08050

000080a4 <.LVL105>:
}
    80a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    80a6:	10 01       	reta			;

000080a8 <verify_fw_cb>:
  uint16_t result = crcStop();
    80a8:	b0 13 50 ac 	calla	#44112		;0x0ac50

000080ac <.LVL107>:
    80ac:	2e 00 4e d0 	mova	&53326,	r14	;0x0d04e

000080b0 <.Loc.1466.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    80b0:	6d 4e       	mov.b	@r14,	r13	;
    80b2:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80

000080b6 <.Loc.1465.2>:
  if (result == verify_crc) {
    80b6:	40 18 1c 92 	cmpx.w	&0x0d052,r12	;
    80ba:	52 d0 
    80bc:	08 20       	jnz	$+18     	;abs 0x80ce

000080be <.Loc.1466.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    80be:	cc 0e       	mova	r14,	r12	;

000080c0 <.LVL108>:
    80c0:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000080c4 <.L189>:
  elyCmdSendReplyI(stored_buff);
    80c4:	2c 00 4e d0 	mova	&53326,	r12	;0x0d04e
    80c8:	b0 13 50 80 	calla	#32848		;0x08050

000080cc <.LVL110>:
}
    80cc:	10 01       	reta			;

000080ce <.L188>:
    gen_failure(stored_buff, stored_buff[0] & 0x80); /* crc */
    80ce:	cc 0e       	mova	r14,	r12	;

000080d0 <.LVL112>:
    80d0:	b0 13 e2 7b 	calla	#31714		;0x07be2

000080d4 <.LVL113>:
    80d4:	80 00 c4 80 	mova	#32964,	r0	;0x080c4

000080d8 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buffer) {
    80d8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000080da <.LCFI11>:
  buffer = buffer - 8;
    80da:	ca 0c       	mova	r12,	r10	;
    80dc:	aa 0f f8 ff 	adda	#1048568,r10	;0xffff8

000080e0 <.LVL115>:
    gen_success(buffer, buffer[0] & 0x80); /* crc */
    80e0:	5d 4c f8 ff 	mov.b	-8(r12),r13	;
    80e4:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    80e8:	cc 0a       	mova	r10,	r12	;
    80ea:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000080ee <.LVL116>:
    elyCmdSendReplyI(buffer);
    80ee:	cc 0a       	mova	r10,	r12	;
    80f0:	b0 13 50 80 	calla	#32848		;0x08050

000080f4 <.LVL117>:
}
    80f4:	0a 16       	popm.a	#1,	r10	;20-bit words
    80f6:	10 01       	reta			;

000080f8 <elyCmdSendReply>:
msg_t elyCmdSendReply(uint8_t * buff) {
    80f8:	b1 00 04 00 	suba	#4,	r1	;

000080fc <.LCFI12>:
  chSysLock();
    80fc:	71 0c 00 00 	mova	r12,	0(r1)	;
    8100:	b0 13 80 7b 	calla	#31616		;0x07b80

00008104 <.LVL119>:
  msg = elyCmdSendReplyI(buff);
    8104:	0c 01       	mova	@r1,	r12	;
    8106:	b0 13 50 80 	calla	#32848		;0x08050

0000810a <.LVL120>:
  chSysUnlock();
    810a:	71 0c 00 00 	mova	r12,	0(r1)	;
    810e:	b0 13 88 7b 	calla	#31624		;0x07b88

00008112 <.LVL121>:
}
    8112:	0c 01       	mova	@r1,	r12	;
    8114:	a1 00 04 00 	adda	#4,	r1	;
    8118:	10 01       	reta			;

0000811a <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    811a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000811c <.LCFI13>:
    811c:	b1 00 18 00 	suba	#24,	r1	;0x00018

00008120 <.LCFI14>:
    8120:	c4 0c       	mova	r12,	r4	;
    8122:	cc 0d       	mova	r13,	r12	;

00008124 <.LVL123>:
    8124:	6d 4d       	mov.b	@r13,	r13	;
    8126:	5d f3       	and.b	#1,	r13	;r3 As==01
    8128:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

0000812c <.LVL124>:
    812c:	5f 4c 01 00 	mov.b	1(r12),	r15	;

00008130 <.LVL125>:
    8130:	c1 4f 09 00 	mov.b	r15,	9(r1)	;

00008134 <.Loc.1657.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8134:	6c 4c       	mov.b	@r12,	r12	;

00008136 <.LVL127>:
    8136:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8138:	4c dd       	bis.b	r13,	r12	;
    813a:	c1 4c 08 00 	mov.b	r12,	8(r1)	;
    813e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8142:	4e 4c       	mov.b	r12,	r14	;
    8144:	6e f3       	and.b	#2,	r14	;r3 As==10
    8146:	46 4e       	mov.b	r14,	r6	;
    8148:	06 93       	cmp	#0,	r6	;r3 As==00
    814a:	40 20       	jnz	$+130    	;abs 0x81cc
    814c:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000814e <.L193>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    814e:	1c b3       	bit	#1,	r12	;r3 As==01
    8150:	40 20       	jnz	$+130    	;abs 0x81d2

00008152 <.Loc.1658.2>:
    8152:	4c 43       	clr.b	r12		;

00008154 <.L194>:
    8154:	4f 8e       	sub.b	r14,	r15	;

00008156 <.LVL129>:
    8156:	4f 8c       	sub.b	r12,	r15	;

00008158 <.LVL130>:
  config.duration = ((buffer[hdr_ext] << 8) | buffer[hdr_ext+1]);
    8158:	40 18 0c 4d 	movx.w	r13,	r12	;
    815c:	ce 04       	mova	r4,	r14	;
    815e:	ee 0c       	adda	r12,	r14	;
    8160:	65 4e       	mov.b	@r14,	r5	;
    8162:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    8166:	5b 4e 01 00 	mov.b	1(r14),	r11	;
    816a:	0b d5       	bis	r5,	r11	;
    816c:	81 4b 12 00 	mov	r11,	18(r1)	; 0x0012

00008170 <.Loc.1663.2>:
  if (payload_len == 4 || payload_len == 12) {
    8170:	45 4f       	mov.b	r15,	r5	;
    8172:	75 c2       	bic.b	#8,	r5	;r2 As==11
    8174:	65 92       	cmp.b	#4,	r5	;r2 As==10
    8176:	68 20       	jnz	$+210    	;abs 0x8248

00008178 <.LVL131>:
    config.index_start = buffer[hdr_ext+2];
    8178:	d1 4e 02 00 	mov.b	2(r14),	20(r1)	; 0x0014
    817c:	14 00 

0000817e <.Loc.1666.2>:
    config.index_end = buffer[hdr_ext+3];
    817e:	d1 4e 03 00 	mov.b	3(r14),	21(r1)	; 0x0015
    8182:	15 00 

00008184 <.Loc.1672.2>:
  if (payload_len > 4) {
    8184:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    8186:	2f 20       	jnz	$+96     	;abs 0x81e6

00008188 <.L207>:
    config.use_index = true;
    8188:	55 43       	mov.b	#1,	r5	;r3 As==01

0000818a <.L197>:
  chSysLock();
    818a:	b0 13 80 7b 	calla	#31616		;0x07b80

0000818e <.LVL134>:
  elyTelemUpdateConfigS(config);
    818e:	81 4a 0a 00 	mov	r10,	10(r1)	; 0x000a
    8192:	81 49 0c 00 	mov	r9,	12(r1)	; 0x000c
    8196:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    819a:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    819e:	c1 45 16 00 	mov.b	r5,	22(r1)	; 0x0016
    81a2:	cc 01       	mova	r1,	r12	;
    81a4:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    81a8:	b0 13 8c c1 	calla	#49548		;0x0c18c

000081ac <.LVL135>:
  chSysUnlock();
    81ac:	b0 13 88 7b 	calla	#31624		;0x07b88

000081b0 <.LVL136>:
  if (hdr.reply) {
    81b0:	06 93       	cmp	#0,	r6	;r3 As==00
    81b2:	12 24       	jz	$+38     	;abs 0x81d8

000081b4 <.Loc.1694.2>:
    gen_success(buffer, hdr.crc);
    81b4:	5d 41 07 00 	mov.b	7(r1),	r13	;
    81b8:	cc 04       	mova	r4,	r12	;
    81ba:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000081be <.LVL137>:
    elyCmdSendReply(buffer);
    81be:	cc 04       	mova	r4,	r12	;
    81c0:	b0 13 f8 80 	calla	#33016		;0x080f8

000081c4 <.L192>:
}
    81c4:	a1 00 18 00 	adda	#24,	r1	;0x00018
    81c8:	64 16       	popm.a	#7,	r10	;20-bit words
    81ca:	10 01       	reta			;

000081cc <.L203>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    81cc:	6d 42       	mov.b	#4,	r13	;r2 As==10

000081ce <.LVL140>:
    81ce:	80 00 4e 81 	mova	#33102,	r0	;0x0814e

000081d2 <.L204>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    81d2:	6c 43       	mov.b	#2,	r12	;r3 As==10
    81d4:	80 00 54 81 	mova	#33108,	r0	;0x08154

000081d8 <.L200>:
    elyNLFreeBuffer(elyNLPack(buffer));
    81d8:	cc 04       	mova	r4,	r12	;
    81da:	b0 13 78 be 	calla	#48760		;0x0be78

000081de <.LVL143>:
    81de:	b0 13 24 bd 	calla	#48420		;0x0bd24

000081e2 <.LVL144>:
}
    81e2:	80 00 c4 81 	mova	#33220,	r0	;0x081c4

000081e6 <.L196>:
    config.use_timestamp = true;
    81e6:	d1 43 17 00 	mov.b	#1,	23(r1)	;r3 As==01, 0x0017

000081ea <.LBB42>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    81ea:	0e 4d       	mov	r13,	r14	;
    81ec:	3e 50 0b 00 	add	#11,	r14	;#0x000b
    81f0:	4e 0e       	rlam.a	#4,	r14	;
    81f2:	4e 0d       	rram.a	#4,	r14	;
    81f4:	ee 04       	adda	r4,	r14	;
    81f6:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    81fa:	81 4e 04 00 	mov	r14,	4(r1)	;
    81fe:	ac 00 07 00 	adda	#7,	r12	;
    8202:	ce 04       	mova	r4,	r14	;
    8204:	ee 0c       	adda	r12,	r14	;
    8206:	45 43       	clr.b	r5		;

00008208 <.L198>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    8208:	6c 4e       	mov.b	@r14,	r12	;
    820a:	0d 45       	mov	r5,	r13	;
    820c:	71 0e 00 00 	mova	r14,	0(r1)	;
    8210:	b0 13 ec cb 	calla	#52204		;0x0cbec
    8214:	0d 4c       	mov	r12,	r13	;
    8216:	0b 4c       	mov	r12,	r11	;
    8218:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    821c:	0a dd       	bis	r13,	r10	;

0000821e <.LVL148>:
    821e:	09 dc       	bis	r12,	r9	;

00008220 <.Loc.1677.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    8220:	1c 41 04 00 	mov	4(r1),	r12	;
    8224:	0d 45       	mov	r5,	r13	;
    8226:	b0 13 ec cb 	calla	#52204		;0x0cbec
    822a:	0d 4c       	mov	r12,	r13	;
    822c:	0b 4c       	mov	r12,	r11	;
    822e:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8232:	08 dd       	bis	r13,	r8	;

00008234 <.LVL150>:
    8234:	07 dc       	bis	r12,	r7	;
    8236:	0e 01       	mova	@r1,	r14	;
    8238:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    823c:	35 52       	add	#8,	r5	;r2 As==11

0000823e <.Loc.1675.2>:
      for (int i = 0; i < 4; i++) {
    823e:	35 90 20 00 	cmp	#32,	r5	;#0x0020
    8242:	e2 23       	jnz	$-58     	;abs 0x8208
    8244:	80 00 88 81 	mova	#33160,	r0	;0x08188

00008248 <.L195>:
  if (payload_len > 4) {
    8248:	6e 42       	mov.b	#4,	r14	;r2 As==10
    824a:	4e 9f       	cmp.b	r15,	r14	;
    824c:	2f 2c       	jc	$+96     	;abs 0x82ac

0000824e <.Loc.1673.2>:
    config.use_timestamp = true;
    824e:	d1 43 17 00 	mov.b	#1,	23(r1)	;r3 As==01, 0x0017

00008252 <.LBB43>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    8252:	0e 4d       	mov	r13,	r14	;
    8254:	3e 50 09 00 	add	#9,	r14	;
    8258:	4e 0e       	rlam.a	#4,	r14	;
    825a:	4e 0d       	rram.a	#4,	r14	;
    825c:	ee 04       	adda	r4,	r14	;
    825e:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    8262:	81 4e 04 00 	mov	r14,	4(r1)	;
    8266:	ac 00 05 00 	adda	#5,	r12	;
    826a:	ce 04       	mova	r4,	r14	;
    826c:	ee 0c       	adda	r12,	r14	;
    826e:	45 43       	clr.b	r5		;

00008270 <.L199>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    8270:	6c 4e       	mov.b	@r14,	r12	;
    8272:	0d 45       	mov	r5,	r13	;
    8274:	71 0e 00 00 	mova	r14,	0(r1)	;
    8278:	b0 13 ec cb 	calla	#52204		;0x0cbec
    827c:	0d 4c       	mov	r12,	r13	;
    827e:	0b 4c       	mov	r12,	r11	;
    8280:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8284:	0a dd       	bis	r13,	r10	;

00008286 <.LVL155>:
    8286:	09 dc       	bis	r12,	r9	;

00008288 <.Loc.1683.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    8288:	1c 41 04 00 	mov	4(r1),	r12	;
    828c:	0d 45       	mov	r5,	r13	;
    828e:	b0 13 ec cb 	calla	#52204		;0x0cbec
    8292:	0d 4c       	mov	r12,	r13	;
    8294:	0b 4c       	mov	r12,	r11	;
    8296:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    829a:	08 dd       	bis	r13,	r8	;

0000829c <.LVL157>:
    829c:	07 dc       	bis	r12,	r7	;
    829e:	0e 01       	mova	@r1,	r14	;
    82a0:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    82a4:	35 52       	add	#8,	r5	;r2 As==11

000082a6 <.Loc.1681.2>:
      for (int i = 0; i < 4; i++) {
    82a6:	35 90 20 00 	cmp	#32,	r5	;#0x0020
    82aa:	e2 23       	jnz	$-58     	;abs 0x8270

000082ac <.L208>:
    config.use_index = false;
    82ac:	45 43       	clr.b	r5		;
    82ae:	80 00 8a 81 	mova	#33162,	r0	;0x0818a

000082b2 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    82b2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000082b4 <.LCFI15>:
    82b4:	b1 00 02 00 	suba	#2,	r1	;

000082b8 <.LCFI16>:
    82b8:	ca 0c       	mova	r12,	r10	;
    82ba:	ce 0d       	mova	r13,	r14	;

000082bc <.LVL160>:
  if (hdr.reply) {
    82bc:	6d 4d       	mov.b	@r13,	r13	;

000082be <.LVL161>:
    82be:	5d f3       	and.b	#1,	r13	;r3 As==01
    82c0:	40 18 ee b3 	bitx.b	#2,	0(r14)	;r3 As==10
    82c4:	00 00 
    82c6:	10 24       	jz	$+34     	;abs 0x82e8

000082c8 <.Loc.1610.2>:
    gen_success(buffer, hdr.crc);
    82c8:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000082cc <.LVL162>:
    elyCmdSendReply(buffer);
    82cc:	cc 0a       	mova	r10,	r12	;
    82ce:	b0 13 f8 80 	calla	#33016		;0x080f8

000082d2 <.L211>:
  bootloader = 1;
    82d2:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    82d6:	fc 19 

000082d8 <.Loc.1619.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    82d8:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    82dc:	48 a5 20 01 

000082e0 <.Loc.1621.2>:
}
    82e0:	a1 00 02 00 	adda	#2,	r1	;
    82e4:	0a 16       	popm.a	#1,	r10	;20-bit words
    82e6:	10 01       	reta			;

000082e8 <.L210>:
    elyNLFreeBuffer(elyNLPack(buffer));
    82e8:	b0 13 78 be 	calla	#48760		;0x0be78

000082ec <.LVL165>:
    82ec:	b0 13 24 bd 	calla	#48420		;0x0bd24

000082f0 <.LVL166>:
    82f0:	80 00 d2 82 	mova	#33490,	r0	;0x082d2

000082f4 <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    82f4:	2a 14       	pushm.a	#3,	r10	;20-bit words

000082f6 <.LCFI17>:
    82f6:	26 14       	pushm.a	#3,	r6	;20-bit words

000082f8 <.LCFI18>:
    82f8:	b1 00 06 00 	suba	#6,	r1	;

000082fc <.LCFI19>:
    82fc:	ca 0c       	mova	r12,	r10	;
    82fe:	69 4d       	mov.b	@r13,	r9	;
    8300:	59 f3       	and.b	#1,	r9	;r3 As==01

00008302 <.Loc.1537.2>:
    8302:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8306:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    830a:	01 00 

0000830c <.Loc.1538.2>:
  stored_buff = buffer; /* store for freeing */
    830c:	60 0a 4e d0 	mova	r10,	&53326	; 0x0d04e

00008310 <.LVL170>:
    8310:	34 40 00 04 	mov	#1024,	r4	;#0x0400
    8314:	55 43       	mov.b	#1,	r5	;r3 As==01

00008316 <.LBB47>:
    chSysLock();
    8316:	86 00 80 7b 	mova	#31616,	r6	;0x07b80

0000831a <.Loc.1570.2>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    831a:	88 00 36 ba 	mova	#47670,	r8	;0x0ba36

0000831e <.L216>:
    chSysLock();
    831e:	46 13       	calla	r6		;

00008320 <.LVL172>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8320:	4d 43       	clr.b	r13		;
    8322:	cc 01       	mova	r1,	r12	;
    8324:	ac 00 02 00 	adda	#2,	r12	;
    8328:	48 13       	calla	r8		;

0000832a <.LVL173>:
    chSysUnlock();
    832a:	b0 13 88 7b 	calla	#31624		;0x07b88

0000832e <.LVL174>:
    pages_sent++;
    832e:	40 18 92 53 	incx.w	&0xd04a		;
    8332:	4a d0 

00008334 <.Loc.1576.2>:
    req->address = FRAM_FW_BASE + (i * 128); 
    8334:	3c 01 02 00 	mova	2(r1),	r12	;
    8338:	8c 44 00 00 	mov	r4,	0(r12)	;
    833c:	8c 45 02 00 	mov	r5,	2(r12)	;

00008340 <.Loc.1577.2>:
    req->read = 0;
    8340:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8344:	6d c3       	bic.b	#2,	r13	;r3 As==10

00008346 <.Loc.1578.2>:
    req->special = 1; /* write a constant value */
    8346:	5d d3       	bis.b	#1,	r13	;r3 As==01
    8348:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000834c <.Loc.1579.2>:
    req->size = 128;
    834c:	1d 4c 04 00 	mov	4(r12),	r13	;
    8350:	7d f0 03 00 	and.b	#3,	r13	;
    8354:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    8358:	8c 4d 04 00 	mov	r13,	4(r12)	;
    835c:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    8360:	06 00 

00008362 <.Loc.1580.2>:
    req->buffer = &fill_value; 
    8362:	00 18 fc 40 	movx.a	#53318,	8(r12)	;0x0d046
    8366:	46 d0 08 00 

0000836a <.Loc.1581.2>:
    req->callback = cancel_fw_eeprom_cb;
    836a:	00 18 fc 40 	movx.a	#32054,	12(r12)	;0x07d36, 0x0000c
    836e:	36 7d 0c 00 

00008372 <.Loc.1585.2>:
    elyFramPostRequest(req);
    8372:	b0 13 1a ba 	calla	#47642		;0x0ba1a

00008376 <.LBB48>:
  return chSemWaitTimeout(&bsp->sem, time);
    8376:	4d 43       	clr.b	r13		;
    8378:	8c 00 4c d0 	mova	#53324,	r12	;0x0d04c
    837c:	b0 13 b2 48 	calla	#18610		;0x048b2

00008380 <.LVL176>:
    8380:	34 50 80 00 	add	#128,	r4	;#0x0080
    8384:	05 63       	adc	r5		;

00008386 <.LBE48>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    8386:	04 93       	cmp	#0,	r4	;r3 As==00
    8388:	ca 23       	jnz	$-106    	;abs 0x831e
    838a:	25 93       	cmp	#2,	r5	;r3 As==10
    838c:	c8 23       	jnz	$-110    	;abs 0x831e

0000838e <.LBE47>:
  if (hdr.reply) {
    838e:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8392:	00 00 
    8394:	0c 24       	jz	$+26     	;abs 0x83ae

00008396 <.Loc.1593.2>:
    gen_success(buffer, hdr.crc);
    8396:	4d 49       	mov.b	r9,	r13	;
    8398:	cc 0a       	mova	r10,	r12	;
    839a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000839e <.LVL177>:
    elyCmdSendReply(buffer);
    839e:	cc 0a       	mova	r10,	r12	;
    83a0:	b0 13 f8 80 	calla	#33016		;0x080f8

000083a4 <.L212>:
}
    83a4:	a1 00 06 00 	adda	#6,	r1	;
    83a8:	24 16       	popm.a	#3,	r6	;20-bit words
    83aa:	28 16       	popm.a	#3,	r10	;20-bit words
    83ac:	10 01       	reta			;

000083ae <.L214>:
    elyNLFreeBuffer(elyNLPack(stored_buff));
    83ae:	2c 00 4e d0 	mova	&53326,	r12	;0x0d04e
    83b2:	b0 13 78 be 	calla	#48760		;0x0be78

000083b6 <.LVL179>:
    83b6:	b0 13 24 bd 	calla	#48420		;0x0bd24

000083ba <.LVL180>:
}
    83ba:	80 00 a4 83 	mova	#33700,	r0	;0x083a4

000083be <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    83be:	6a 14       	pushm.a	#7,	r10	;20-bit words

000083c0 <.LCFI20>:
    83c0:	b1 00 12 00 	suba	#18,	r1	;0x00012

000083c4 <.LCFI21>:
    83c4:	71 0c 08 00 	mova	r12,	8(r1)	;
    83c8:	6b 4d       	mov.b	@r13,	r11	;
    83ca:	5b f3       	and.b	#1,	r11	;r3 As==01

000083cc <.LVL182>:
    83cc:	5a 4d 01 00 	mov.b	1(r13),	r10	;
    83d0:	81 4a 04 00 	mov	r10,	4(r1)	;

000083d4 <.LVL183>:
    83d4:	c1 4a 0d 00 	mov.b	r10,	13(r1)	; 0x000d

000083d8 <.Loc.1420.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    83d8:	68 4d       	mov.b	@r13,	r8	;
    83da:	58 c3       	bic.b	#1,	r8	;r3 As==01
    83dc:	48 db       	bis.b	r11,	r8	;
    83de:	c1 48 0c 00 	mov.b	r8,	12(r1)	; 0x000c
    83e2:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    83e6:	46 48       	mov.b	r8,	r6	;
    83e8:	66 f3       	and.b	#2,	r6	;r3 As==10
    83ea:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    83ee:	06 93       	cmp	#0,	r6	;r3 As==00
    83f0:	37 20       	jnz	$+112    	;abs 0x8460
    83f2:	69 43       	mov.b	#2,	r9	;r3 As==10

000083f4 <.L218>:
    83f4:	40 18 0a 49 	movx.w	r9,	r10	;
    83f8:	00 18 5a 51 	addx.a	8(r1),	r10	;
    83fc:	08 00 

000083fe <.Loc.1420.2>:
    83fe:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

00008402 <.Loc.1421.2>:
  uint32_t address = 0;
    8402:	47 43       	clr.b	r7		;
    8404:	05 47       	mov	r7,	r5	;

00008406 <.L219>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    8406:	6c 4a       	mov.b	@r10,	r12	;
    8408:	0d 43       	clr	r13		;
    840a:	0e 44       	mov	r4,	r14	;
    840c:	0f 43       	clr	r15		;
    840e:	71 0b 00 00 	mova	r11,	0(r1)	;
    8412:	b0 13 36 cc 	calla	#52278		;0x0cc36
    8416:	0c d7       	bis	r7,	r12	;
    8418:	0d d5       	bis	r5,	r13	;
    841a:	07 4c       	mov	r12,	r7	;

0000841c <.LVL188>:
    841c:	05 4d       	mov	r13,	r5	;

0000841e <.LVL189>:
    841e:	aa 00 01 00 	adda	#1,	r10	;

00008422 <.LVL190>:
    8422:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

00008426 <.Loc.1424.2>:
  for (int i = 0; i < 4; i++) {
    8426:	0b 01       	mova	@r1,	r11	;
    8428:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    842c:	ec 23       	jnz	$-38     	;abs 0x8406

0000842e <.LBE50>:
  if (address < 0x4400 || address > 0x13FFF) {
    842e:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    8432:	04 4d       	mov	r13,	r4	;
    8434:	34 63       	addc	#-1,	r4	;r3 As==11
    8436:	04 93       	cmp	#0,	r4	;r3 As==00
    8438:	04 20       	jnz	$+10     	;abs 0x8442
    843a:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    843e:	0d 9c       	cmp	r12,	r13	;
    8440:	1e 2c       	jc	$+62     	;abs 0x847e

00008442 <.L230>:
    if (hdr.reply) {
    8442:	06 93       	cmp	#0,	r6	;r3 As==00
    8444:	10 24       	jz	$+34     	;abs 0x8466

00008446 <.Loc.1431.2>:
      gen_failure(buffer, hdr.crc);
    8446:	4d 4b       	mov.b	r11,	r13	;
    8448:	3c 01 08 00 	mova	8(r1),	r12	;
    844c:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008450 <.LVL191>:
      elyCmdSendReply(buffer);
    8450:	3c 01 08 00 	mova	8(r1),	r12	;
    8454:	b0 13 f8 80 	calla	#33016		;0x080f8

00008458 <.L217>:
}
    8458:	a1 00 12 00 	adda	#18,	r1	;0x00012
    845c:	64 16       	popm.a	#7,	r10	;20-bit words
    845e:	10 01       	reta			;

00008460 <.L227>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8460:	69 42       	mov.b	#4,	r9	;r2 As==10
    8462:	80 00 f4 83 	mova	#33780,	r0	;0x083f4

00008466 <.L222>:
      elyErrorSignal(ErrCmdFailure);
    8466:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    846a:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000846e <.LVL195>:
      elyNLFreeBuffer(elyNLPack(buffer));
    846e:	3c 01 08 00 	mova	8(r1),	r12	;
    8472:	b0 13 78 be 	calla	#48760		;0x0be78

00008476 <.LVL196>:
    8476:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000847a <.LVL197>:
    847a:	80 00 58 84 	mova	#33880,	r0	;0x08458

0000847e <.L232>:
  elyFramGetRequest(&req);
    847e:	cc 01       	mova	r1,	r12	;
    8480:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    8484:	b0 13 00 ba 	calla	#47616		;0x0ba00

00008488 <.LVL198>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    8488:	3c 01 0e 00 	mova	14(r1),	r12	;0x0000e
    848c:	37 50 00 c0 	add	#-16384,r7	;#0xc000

00008490 <.LVL199>:
    8490:	8c 47 00 00 	mov	r7,	0(r12)	;
    8494:	05 63       	adc	r5		;
    8496:	8c 45 02 00 	mov	r5,	2(r12)	;

0000849a <.Loc.1449.2>:
  req->read = 0;
    849a:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

0000849e <.Loc.1450.2>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    849e:	1a 41 04 00 	mov	4(r1),	r10	;

000084a2 <.LVL201>:
    84a2:	0a 86       	sub	r6,	r10	;
    84a4:	40 18 18 b3 	bitx.w	#1,	r8	;r3 As==01
    84a8:	01 24       	jz	$+4      	;abs 0x84ac
    84aa:	64 43       	mov.b	#2,	r4	;r3 As==10

000084ac <.L224>:
    84ac:	0a 84       	sub	r4,	r10	;
    84ae:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc
    84b2:	4a 0e       	rlam.a	#4,	r10	;
    84b4:	4a 0d       	rram.a	#4,	r10	;
    84b6:	80 18 7a f0 	andx.a	#131071,r10	;0x1ffff
    84ba:	ff ff 
    84bc:	71 0a 04 00 	mova	r10,	4(r1)	;

000084c0 <.LVL202>:
    84c0:	0d 4a       	mov	r10,	r13	;
    84c2:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    84c6:	1e 4c 04 00 	mov	4(r12),	r14	;
    84ca:	7e f0 03 00 	and.b	#3,	r14	;
    84ce:	0e dd       	bis	r13,	r14	;
    84d0:	8c 4e 04 00 	mov	r14,	4(r12)	;

000084d4 <.LVL203>:
    84d4:	0f 4a       	mov	r10,	r15	;
    84d6:	5f 03       	rrum	#1,	r15	;
    84d8:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    84dc:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    84e0:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    84e4:	3a 01 04 00 	mova	4(r1),	r10	;
    84e8:	0a 14       	pushm.a	#1,	r10	;20-bit words
    84ea:	0d 17       	popm	#1,	r13	;16-bit words
    84ec:	0d 17       	popm	#1,	r13	;16-bit words
    84ee:	5d f3       	and.b	#1,	r13	;r3 As==01
    84f0:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    84f4:	4e df       	bis.b	r15,	r14	;
    84f6:	4e dd       	bis.b	r13,	r14	;
    84f8:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

000084fc <.Loc.1451.2>:
  lookbehind = hdr_ext+4;
    84fc:	69 52       	add.b	#4,	r9	;r2 As==10

000084fe <.LVL204>:
  req->buffer = &buffer[lookbehind];
    84fe:	40 18 0e 49 	movx.w	r9,	r14	;
    8502:	00 18 5e 51 	addx.a	8(r1),	r14	;
    8506:	08 00 
    8508:	7c 0e 08 00 	mova	r14,	8(r12)	;

0000850c <.Loc.1453.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    850c:	06 93       	cmp	#0,	r6	;r3 As==00
    850e:	08 20       	jnz	$+18     	;abs 0x8520

00008510 <.Loc.1453.2>:
    8510:	8e 00 86 7c 	mova	#31878,	r14	;0x07c86

00008514 <.L225>:
    8514:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

00008518 <.Loc.1457.2>:
  elyFramPostRequest(req);
    8518:	b0 13 1a ba 	calla	#47642		;0x0ba1a

0000851c <.LVL205>:
    851c:	80 00 58 84 	mova	#33880,	r0	;0x08458

00008520 <.L229>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    8520:	8e 00 d8 80 	mova	#32984,	r14	;0x080d8
    8524:	80 00 14 85 	mova	#34068,	r0	;0x08514

00008528 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8528:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000852a <.LCFI22>:
    852a:	b1 00 02 00 	suba	#2,	r1	;

0000852e <.LCFI23>:
    852e:	ca 0c       	mova	r12,	r10	;

00008530 <.LVL207>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8530:	67 4d       	mov.b	@r13,	r7	;
    8532:	57 f3       	and.b	#1,	r7	;r3 As==01
    8534:	69 4d       	mov.b	@r13,	r9	;
    8536:	69 f3       	and.b	#2,	r9	;r3 As==10
    8538:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    853c:	09 93       	cmp	#0,	r9	;r3 As==00
    853e:	16 20       	jnz	$+46     	;abs 0x856c
    8540:	68 43       	mov.b	#2,	r8	;r3 As==10

00008542 <.L234>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    8542:	40 18 08 48 	movx.w	r8,	r8	;
    8546:	e8 0a       	adda	r10,	r8	;

00008548 <.LVL209>:
    8548:	6d 48       	mov.b	@r8,	r13	;

0000854a <.LVL210>:
    854a:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

0000854e <.LVL211>:
    854e:	4c 9d       	cmp.b	r13,	r12	;
    8550:	1b 2c       	jc	$+56     	;abs 0x8588

00008552 <.Loc.1372.2>:
    if (hdr.reply) {
    8552:	09 93       	cmp	#0,	r9	;r3 As==00
    8554:	0e 24       	jz	$+30     	;abs 0x8572

00008556 <.Loc.1374.2>:
      gen_failure(buffer, hdr.crc);
    8556:	4d 47       	mov.b	r7,	r13	;
    8558:	cc 0a       	mova	r10,	r12	;
    855a:	b0 13 e2 7b 	calla	#31714		;0x07be2

0000855e <.L240>:
    elyCmdSendReply(buffer);
    855e:	cc 0a       	mova	r10,	r12	;
    8560:	b0 13 f8 80 	calla	#33016		;0x080f8

00008564 <.L233>:
}
    8564:	a1 00 02 00 	adda	#2,	r1	;
    8568:	37 16       	popm.a	#4,	r10	;20-bit words
    856a:	10 01       	reta			;

0000856c <.L239>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    856c:	68 42       	mov.b	#4,	r8	;r2 As==10
    856e:	80 00 42 85 	mova	#34114,	r0	;0x08542

00008572 <.L236>:
      elyErrorSignal(ErrCmdFailure);
    8572:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8576:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000857a <.L238>:
    elyNLFreeBuffer(elyNLPack(buffer));
    857a:	cc 0a       	mova	r10,	r12	;
    857c:	b0 13 78 be 	calla	#48760		;0x0be78

00008580 <.LVL217>:
    8580:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008584 <.LVL218>:
    8584:	80 00 64 85 	mova	#34148,	r0	;0x08564

00008588 <.L235>:
  bank0w[RegErrLogLvl] = buffer[hdr_ext];
    8588:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    858c:	cc 4d 4d 00 	mov.b	r13,	77(r12)	; 0x004d

00008590 <.Loc.1387.2>:
  chSysLock();
    8590:	b0 13 80 7b 	calla	#31616		;0x07b80

00008594 <.LVL219>:
  elyErrorSetLogLvlS(buffer[hdr_ext]);
    8594:	6c 48       	mov.b	@r8,	r12	;
    8596:	b0 13 46 bf 	calla	#48966		;0x0bf46

0000859a <.LVL220>:
  chSysUnlock();
    859a:	b0 13 88 7b 	calla	#31624		;0x07b88

0000859e <.LVL221>:
  if (hdr.reply) {
    859e:	09 93       	cmp	#0,	r9	;r3 As==00
    85a0:	ec 27       	jz	$-38     	;abs 0x857a

000085a2 <.Loc.1393.2>:
    gen_success(buffer, hdr.crc);
    85a2:	4d 47       	mov.b	r7,	r13	;
    85a4:	cc 0a       	mova	r10,	r12	;
    85a6:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000085aa <.LVL222>:
    85aa:	80 00 5e 85 	mova	#34142,	r0	;0x0855e

000085ae <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    85ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

000085b0 <.LCFI24>:
    85b0:	b1 00 02 00 	suba	#2,	r1	;

000085b4 <.LCFI25>:
    85b4:	ca 0c       	mova	r12,	r10	;

000085b6 <.Loc.1345.2>:
    85b6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    85ba:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    85be:	01 00 

000085c0 <.Loc.1347.2>:
  if (hdr.reply) {
    85c0:	6d 41       	mov.b	@r1,	r13	;
    85c2:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    85c6:	23 24       	jz	$+72     	;abs 0x860e

000085c8 <.Loc.1348.2>:
    buffer[0] = buffer[0] & 0x3F;
    85c8:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    85cc:	00 00 

000085ce <.Loc.1349.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    85ce:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    85d2:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    85d6:	02 00 

000085d8 <.Loc.1350.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    85d8:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    85dc:	03 00 

000085de <.Loc.1351.2>:
    buffer[4] = bank0p[RegErrLogLvl];
    85de:	dc 4e 4d 00 	mov.b	77(r14),4(r12)	;0x0004d
    85e2:	04 00 

000085e4 <.Loc.1352.2>:
    if (hdr.crc) {
    85e4:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    85e8:	0e 24       	jz	$+30     	;abs 0x8606

000085ea <.Loc.1353.2>:
      buffer[1] = 3;
    85ea:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    85ee:	01 00 

000085f0 <.Loc.1354.2>:
      crcGenX25(buffer, 7);
    85f0:	7d 40 07 00 	mov.b	#7,	r13	;
    85f4:	b0 13 50 ab 	calla	#43856		;0x0ab50

000085f8 <.L244>:
    elyCmdSendReply(buffer);
    85f8:	cc 0a       	mova	r10,	r12	;
    85fa:	b0 13 f8 80 	calla	#33016		;0x080f8

000085fe <.L241>:
}
    85fe:	a1 00 02 00 	adda	#2,	r1	;
    8602:	0a 16       	popm.a	#1,	r10	;20-bit words
    8604:	10 01       	reta			;

00008606 <.L243>:
      buffer[1] = 1;
    8606:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    860a:	80 00 f8 85 	mova	#34296,	r0	;0x085f8

0000860e <.L242>:
    860e:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00008612 <.LVL226>:
}
    8612:	80 00 fe 85 	mova	#34302,	r0	;0x085fe

00008616 <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8616:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008618 <.LCFI26>:
    8618:	b1 00 02 00 	suba	#2,	r1	;

0000861c <.LCFI27>:
    861c:	ca 0c       	mova	r12,	r10	;

0000861e <.LVL228>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    861e:	67 4d       	mov.b	@r13,	r7	;
    8620:	57 f3       	and.b	#1,	r7	;r3 As==01
    8622:	69 4d       	mov.b	@r13,	r9	;
    8624:	69 f3       	and.b	#2,	r9	;r3 As==10
    8626:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    862a:	09 93       	cmp	#0,	r9	;r3 As==00
    862c:	16 20       	jnz	$+46     	;abs 0x865a
    862e:	68 43       	mov.b	#2,	r8	;r3 As==10

00008630 <.L247>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    8630:	40 18 08 48 	movx.w	r8,	r8	;
    8634:	e8 0a       	adda	r10,	r8	;

00008636 <.LVL230>:
    8636:	6d 48       	mov.b	@r8,	r13	;

00008638 <.LVL231>:
    8638:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

0000863c <.LVL232>:
    863c:	4c 9d       	cmp.b	r13,	r12	;
    863e:	1b 2c       	jc	$+56     	;abs 0x8676

00008640 <.Loc.1314.2>:
    if (hdr.reply) {
    8640:	09 93       	cmp	#0,	r9	;r3 As==00
    8642:	0e 24       	jz	$+30     	;abs 0x8660

00008644 <.Loc.1316.2>:
      gen_failure(buffer, hdr.crc);
    8644:	4d 47       	mov.b	r7,	r13	;
    8646:	cc 0a       	mova	r10,	r12	;
    8648:	b0 13 e2 7b 	calla	#31714		;0x07be2

0000864c <.L253>:
    elyCmdSendReply(buffer);
    864c:	cc 0a       	mova	r10,	r12	;
    864e:	b0 13 f8 80 	calla	#33016		;0x080f8

00008652 <.L246>:
}
    8652:	a1 00 02 00 	adda	#2,	r1	;
    8656:	37 16       	popm.a	#4,	r10	;20-bit words
    8658:	10 01       	reta			;

0000865a <.L252>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    865a:	68 42       	mov.b	#4,	r8	;r2 As==10
    865c:	80 00 30 86 	mova	#34352,	r0	;0x08630

00008660 <.L249>:
      elyErrorSignal(ErrCmdFailure);
    8660:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8664:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008668 <.L251>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8668:	cc 0a       	mova	r10,	r12	;
    866a:	b0 13 78 be 	calla	#48760		;0x0be78

0000866e <.LVL238>:
    866e:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008672 <.LVL239>:
    8672:	80 00 52 86 	mova	#34386,	r0	;0x08652

00008676 <.L248>:
  bank0w[RegErrRptLvl] = buffer[hdr_ext];
    8676:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    867a:	cc 4d 4c 00 	mov.b	r13,	76(r12)	; 0x004c

0000867e <.Loc.1329.2>:
  chSysLock();
    867e:	b0 13 80 7b 	calla	#31616		;0x07b80

00008682 <.LVL240>:
  elyErrorSetRptLvlS(buffer[hdr_ext]);
    8682:	6c 48       	mov.b	@r8,	r12	;
    8684:	b0 13 48 bf 	calla	#48968		;0x0bf48

00008688 <.LVL241>:
  chSysUnlock();
    8688:	b0 13 88 7b 	calla	#31624		;0x07b88

0000868c <.LVL242>:
  if (hdr.reply) {
    868c:	09 93       	cmp	#0,	r9	;r3 As==00
    868e:	ec 27       	jz	$-38     	;abs 0x8668

00008690 <.Loc.1335.2>:
    gen_success(buffer, hdr.crc);
    8690:	4d 47       	mov.b	r7,	r13	;
    8692:	cc 0a       	mova	r10,	r12	;
    8694:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008698 <.LVL243>:
    8698:	80 00 4c 86 	mova	#34380,	r0	;0x0864c

0000869c <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    869c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000869e <.LCFI28>:
    869e:	b1 00 02 00 	suba	#2,	r1	;

000086a2 <.LCFI29>:
    86a2:	ca 0c       	mova	r12,	r10	;

000086a4 <.Loc.1287.2>:
    86a4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    86a8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    86ac:	01 00 

000086ae <.Loc.1289.2>:
  if (hdr.reply) {
    86ae:	6d 41       	mov.b	@r1,	r13	;
    86b0:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    86b4:	23 24       	jz	$+72     	;abs 0x86fc

000086b6 <.Loc.1290.2>:
    buffer[0] = buffer[0] & 0x3F;
    86b6:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    86ba:	00 00 

000086bc <.Loc.1291.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    86bc:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    86c0:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    86c4:	02 00 

000086c6 <.Loc.1292.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    86c6:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    86ca:	03 00 

000086cc <.Loc.1293.2>:
    buffer[4] = bank0p[RegErrRptLvl];
    86cc:	dc 4e 4c 00 	mov.b	76(r14),4(r12)	;0x0004c
    86d0:	04 00 

000086d2 <.Loc.1294.2>:
    if (hdr.crc) {
    86d2:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    86d6:	0e 24       	jz	$+30     	;abs 0x86f4

000086d8 <.Loc.1295.2>:
      buffer[1] = 3;
    86d8:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    86dc:	01 00 

000086de <.Loc.1296.2>:
      crcGenX25(buffer, 7);
    86de:	7d 40 07 00 	mov.b	#7,	r13	;
    86e2:	b0 13 50 ab 	calla	#43856		;0x0ab50

000086e6 <.L257>:
    elyCmdSendReply(buffer);
    86e6:	cc 0a       	mova	r10,	r12	;
    86e8:	b0 13 f8 80 	calla	#33016		;0x080f8

000086ec <.L254>:
}
    86ec:	a1 00 02 00 	adda	#2,	r1	;
    86f0:	0a 16       	popm.a	#1,	r10	;20-bit words
    86f2:	10 01       	reta			;

000086f4 <.L256>:
      buffer[1] = 1;
    86f4:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    86f8:	80 00 e6 86 	mova	#34534,	r0	;0x086e6

000086fc <.L255>:
    86fc:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00008700 <.LVL247>:
}
    8700:	80 00 ec 86 	mova	#34540,	r0	;0x086ec

00008704 <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8704:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008706 <.LCFI30>:
    8706:	08 14       	pushm.a	#1,	r8	;20-bit words

00008708 <.LCFI31>:
    8708:	b1 00 02 00 	suba	#2,	r1	;

0000870c <.LCFI32>:
    870c:	ca 0c       	mova	r12,	r10	;

0000870e <.Loc.1264.2>:
    870e:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8712:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8716:	01 00 

00008718 <.Loc.1266.2>:
  if (hdr.reply) {
    8718:	6d 41       	mov.b	@r1,	r13	;
    871a:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    871e:	30 24       	jz	$+98     	;abs 0x8780

00008720 <.Loc.1267.2>:
    buffer[0] = buffer[0] & 0x3F;
    8720:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8724:	00 00 

00008726 <.Loc.1268.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8726:	2c 01 40 08 	mova	&67648,	r12	;0x10840

0000872a <.LVL249>:
    872a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    872e:	02 00 

00008730 <.Loc.1269.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8730:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8734:	03 00 

00008736 <.Loc.1270.2>:
    buffer[1] += 2;
    8736:	ea 53 01 00 	incd.b	1(r10)		;

0000873a <.LVL250>:
    873a:	ce 0c       	mova	r12,	r14	;
    873c:	ae 00 76 00 	adda	#118,	r14	;0x00076
    8740:	c8 0a       	mova	r10,	r8	;
    8742:	a8 00 04 00 	adda	#4,	r8	;
    8746:	ac 00 72 00 	adda	#114,	r12	;0x00072

0000874a <.L261>:
      buffer[i + 4] = bank0p[RegMissionTimeMsb - i];
    874a:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

0000874e <.LVL252>:
    874e:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    8752:	a8 00 01 00 	adda	#1,	r8	;

00008756 <.LVL253>:
    for (int i = 0; i < 4; i++) {
    8756:	de 0c       	cmpa	r12,	r14	;
    8758:	f8 23       	jnz	$-14     	;abs 0x874a

0000875a <.LBE51>:
    if (hdr.crc) {
    875a:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    875e:	08 24       	jz	$+18     	;abs 0x8770

00008760 <.Loc.1276.2>:
      crcGenX25(buffer, buffer[1]+4);
    8760:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    8764:	2d 52       	add	#4,	r13	;r2 As==10
    8766:	40 18 0d 4d 	movx.w	r13,	r13	;
    876a:	cc 0a       	mova	r10,	r12	;
    876c:	b0 13 50 ab 	calla	#43856		;0x0ab50

00008770 <.L262>:
    elyCmdSendReply(buffer);
    8770:	cc 0a       	mova	r10,	r12	;
    8772:	b0 13 f8 80 	calla	#33016		;0x080f8

00008776 <.L259>:
}
    8776:	a1 00 02 00 	adda	#2,	r1	;
    877a:	08 16       	popm.a	#1,	r8	;20-bit words
    877c:	0a 16       	popm.a	#1,	r10	;20-bit words
    877e:	10 01       	reta			;

00008780 <.L260>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8780:	b0 13 78 be 	calla	#48760		;0x0be78

00008784 <.LVL256>:
    8784:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008788 <.LVL257>:
}
    8788:	80 00 76 87 	mova	#34678,	r0	;0x08776

0000878c <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    878c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000878e <.LCFI33>:
    878e:	b1 00 02 00 	suba	#2,	r1	;

00008792 <.LCFI34>:
    8792:	ca 0c       	mova	r12,	r10	;

00008794 <.Loc.1238.2>:
    8794:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8798:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    879c:	01 00 

0000879e <.Loc.1239.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    879e:	6f 41       	mov.b	@r1,	r15	;
    87a0:	4d 4f       	mov.b	r15,	r13	;
    87a2:	6d f3       	and.b	#2,	r13	;r3 As==10
    87a4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    87a8:	0d 93       	cmp	#0,	r13	;r3 As==00
    87aa:	35 20       	jnz	$+108    	;abs 0x8816
    87ac:	6c 43       	mov.b	#2,	r12	;r3 As==10

000087ae <.L269>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    87ae:	2e 01 3c 08 	mova	&67644,	r14	;0x1083c
    87b2:	40 18 0c 4c 	movx.w	r12,	r12	;
    87b6:	ec 0a       	adda	r10,	r12	;

000087b8 <.LVL260>:
    87b8:	ee 4c 76 00 	mov.b	@r12,	118(r14); 0x0076

000087bc <.Loc.1243.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    87bc:	de 4c 01 00 	mov.b	1(r12),	117(r14); 0x0075
    87c0:	75 00 

000087c2 <.Loc.1244.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    87c2:	de 4c 02 00 	mov.b	2(r12),	116(r14); 0x0074
    87c6:	74 00 

000087c8 <.Loc.1245.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    87c8:	de 4c 03 00 	mov.b	3(r12),	115(r14); 0x0073
    87cc:	73 00 

000087ce <.Loc.1247.2>:
  if (hdr.reply) {
    87ce:	0d 93       	cmp	#0,	r13	;r3 As==00
    87d0:	25 24       	jz	$+76     	;abs 0x881c

000087d2 <.Loc.1248.2>:
    buffer[0] = buffer[0] & 0x3F;
    87d2:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    87d6:	00 00 

000087d8 <.Loc.1249.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    87d8:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    87dc:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    87e0:	02 00 

000087e2 <.Loc.1250.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    87e2:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    87e6:	03 00 

000087e8 <.Loc.1251.2>:
    buffer[1] -= 2;
    87e8:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    87ec:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    87f0:	4d 4c       	mov.b	r12,	r13	;
    87f2:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

000087f6 <.Loc.1252.2>:
    if (hdr.crc) {
    87f6:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    87fa:	06 24       	jz	$+14     	;abs 0x8808

000087fc <.Loc.1253.2>:
      crcGenX25(buffer, buffer[1]+4);
    87fc:	2d 52       	add	#4,	r13	;r2 As==10
    87fe:	4d 0e       	rlam.a	#4,	r13	;
    8800:	4d 0d       	rram.a	#4,	r13	;
    8802:	cc 0a       	mova	r10,	r12	;
    8804:	b0 13 50 ab 	calla	#43856		;0x0ab50

00008808 <.L271>:
    elyCmdSendReply(buffer);
    8808:	cc 0a       	mova	r10,	r12	;
    880a:	b0 13 f8 80 	calla	#33016		;0x080f8

0000880e <.L268>:
}
    880e:	a1 00 02 00 	adda	#2,	r1	;
    8812:	0a 16       	popm.a	#1,	r10	;20-bit words
    8814:	10 01       	reta			;

00008816 <.L273>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8816:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8818:	80 00 ae 87 	mova	#34734,	r0	;0x087ae

0000881c <.L270>:
    elyNLFreeBuffer(elyNLPack(buffer));
    881c:	cc 0a       	mova	r10,	r12	;
    881e:	b0 13 78 be 	calla	#48760		;0x0be78

00008822 <.LVL263>:
    8822:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008826 <.LVL264>:
}
    8826:	80 00 0e 88 	mova	#34830,	r0	;0x0880e

0000882a <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    882a:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000882c <.LCFI35>:
    882c:	b1 00 02 00 	suba	#2,	r1	;

00008830 <.LCFI36>:
    8830:	ca 0c       	mova	r12,	r10	;
    8832:	69 4d       	mov.b	@r13,	r9	;
    8834:	59 f3       	and.b	#1,	r9	;r3 As==01

00008836 <.Loc.1223.2>:
    8836:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

0000883a <.Loc.1225.2>:
  elyEventReset();
    883a:	b0 13 f4 bf 	calla	#49140		;0x0bff4

0000883e <.LVL268>:
  if (hdr.reply) {
    883e:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8842:	00 00 
    8844:	0b 24       	jz	$+24     	;abs 0x885c

00008846 <.Loc.1229.2>:
    gen_success(buffer, hdr.crc);
    8846:	4d 49       	mov.b	r9,	r13	;
    8848:	cc 0a       	mova	r10,	r12	;
    884a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000884e <.LVL269>:
    elyCmdSendReply(buffer);
    884e:	cc 0a       	mova	r10,	r12	;
    8850:	b0 13 f8 80 	calla	#33016		;0x080f8

00008854 <.L277>:
}
    8854:	a1 00 02 00 	adda	#2,	r1	;
    8858:	19 16       	popm.a	#2,	r10	;20-bit words
    885a:	10 01       	reta			;

0000885c <.L278>:
    885c:	cc 0a       	mova	r10,	r12	;
    885e:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00008862 <.LVL271>:
    8862:	80 00 54 88 	mova	#34900,	r0	;0x08854

00008866 <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8866:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008868 <.LCFI37>:
    8868:	b1 00 02 00 	suba	#2,	r1	;

0000886c <.LCFI38>:
    886c:	c8 0c       	mova	r12,	r8	;
    886e:	69 4d       	mov.b	@r13,	r9	;
    8870:	59 f3       	and.b	#1,	r9	;r3 As==01

00008872 <.LVL273>:
    8872:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008876 <.LVL274>:
    8876:	c1 45 01 00 	mov.b	r5,	1(r1)	;

0000887a <.Loc.1187.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    887a:	6c 4d       	mov.b	@r13,	r12	;

0000887c <.LVL276>:
    887c:	5c c3       	bic.b	#1,	r12	;r3 As==01
    887e:	4c d9       	bis.b	r9,	r12	;
    8880:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8884:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8888:	1c b3       	bit	#1,	r12	;r3 As==01
    888a:	1e 20       	jnz	$+62     	;abs 0x88c8
    888c:	4d 43       	clr.b	r13		;

0000888e <.L281>:
    888e:	6c f3       	and.b	#2,	r12	;r3 As==10
    8890:	47 4c       	mov.b	r12,	r7	;
    8892:	45 8c       	sub.b	r12,	r5	;

00008894 <.LVL278>:
    8894:	45 8d       	sub.b	r13,	r5	;
    8896:	35 f0 ff 00 	and	#255,	r5	;#0x00ff

0000889a <.LVL279>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    889a:	07 93       	cmp	#0,	r7	;r3 As==00
    889c:	18 20       	jnz	$+50     	;abs 0x88ce

0000889e <.Loc.1188.2>:
    889e:	6a 43       	mov.b	#2,	r10	;r3 As==10

000088a0 <.L282>:
    88a0:	40 18 04 4a 	movx.w	r10,	r4	;
    88a4:	e4 08       	adda	r8,	r4	;

000088a6 <.LBB52>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    88a6:	cc 04       	mova	r4,	r12	;
    88a8:	0d 4a       	mov	r10,	r13	;
    88aa:	05 5a       	add	r10,	r5	;

000088ac <.L283>:
    88ac:	0d 95       	cmp	r5,	r13	;
    88ae:	12 38       	jl	$+38     	;abs 0x88d4

000088b0 <.LBB53>:
    elyEventUnlog(buffer[i]);
    88b0:	86 00 d2 bf 	mova	#49106,	r6	;0x0bfd2

000088b4 <.L288>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    88b4:	0a 95       	cmp	r5,	r10	;
    88b6:	30 38       	jl	$+98     	;abs 0x8918

000088b8 <.LBE53>:
  if (hdr.reply) {
    88b8:	07 93       	cmp	#0,	r7	;r3 As==00
    88ba:	24 24       	jz	$+74     	;abs 0x8904

000088bc <.Loc.1213.2>:
    gen_success(buffer, hdr.crc);
    88bc:	4d 49       	mov.b	r9,	r13	;
    88be:	cc 08       	mova	r8,	r12	;
    88c0:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000088c4 <.LVL283>:
    88c4:	80 00 ee 88 	mova	#35054,	r0	;0x088ee

000088c8 <.L291>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    88c8:	6d 43       	mov.b	#2,	r13	;r3 As==10

000088ca <.LVL285>:
    88ca:	80 00 8e 88 	mova	#34958,	r0	;0x0888e

000088ce <.L292>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    88ce:	6a 42       	mov.b	#4,	r10	;r2 As==10
    88d0:	80 00 a0 88 	mova	#34976,	r0	;0x088a0

000088d4 <.L287>:
    88d4:	ac 00 01 00 	adda	#1,	r12	;

000088d8 <.LBB54>:
    if (buffer[i] < 0xC0) {
    88d8:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    88dc:	5e 9c ff ff 	cmp.b	-1(r12),r14	;
    88e0:	18 28       	jnc	$+50     	;abs 0x8912

000088e2 <.Loc.1193.2>:
      if (hdr.reply) {
    88e2:	07 93       	cmp	#0,	r7	;r3 As==00
    88e4:	0b 24       	jz	$+24     	;abs 0x88fc

000088e6 <.Loc.1195.2>:
        gen_failure(buffer, hdr.crc);
    88e6:	4d 49       	mov.b	r9,	r13	;

000088e8 <.LVL288>:
    88e8:	cc 08       	mova	r8,	r12	;
    88ea:	b0 13 e2 7b 	calla	#31714		;0x07be2

000088ee <.L293>:
    elyCmdSendReply(buffer);
    88ee:	cc 08       	mova	r8,	r12	;
    88f0:	b0 13 f8 80 	calla	#33016		;0x080f8

000088f4 <.L280>:
}
    88f4:	a1 00 02 00 	adda	#2,	r1	;
    88f8:	64 16       	popm.a	#7,	r10	;20-bit words
    88fa:	10 01       	reta			;

000088fc <.L285>:
        elyErrorSignal(ErrCmdFailure);
    88fc:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8900:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008904 <.L290>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8904:	cc 08       	mova	r8,	r12	;
    8906:	b0 13 78 be 	calla	#48760		;0x0be78

0000890a <.LVL293>:
    890a:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000890e <.LVL294>:
    890e:	80 00 f4 88 	mova	#35060,	r0	;0x088f4

00008912 <.L284>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8912:	1d 53       	inc	r13		;
    8914:	80 00 ac 88 	mova	#34988,	r0	;0x088ac

00008918 <.L289>:
    elyEventUnlog(buffer[i]);
    8918:	6c 44       	mov.b	@r4,	r12	;
    891a:	46 13       	calla	r6		;

0000891c <.LVL298>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    891c:	1a 53       	inc	r10		;
    891e:	a4 00 01 00 	adda	#1,	r4	;
    8922:	80 00 b4 88 	mova	#34996,	r0	;0x088b4

00008926 <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8926:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008928 <.LCFI39>:
    8928:	b1 00 02 00 	suba	#2,	r1	;

0000892c <.LCFI40>:
    892c:	c8 0c       	mova	r12,	r8	;

0000892e <.LVL301>:
    892e:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00008932 <.LVL302>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8932:	65 4d       	mov.b	@r13,	r5	;
    8934:	55 f3       	and.b	#1,	r5	;r3 As==01
    8936:	6c 4d       	mov.b	@r13,	r12	;

00008938 <.LVL303>:
    8938:	1c b3       	bit	#1,	r12	;r3 As==01
    893a:	1e 20       	jnz	$+62     	;abs 0x8978
    893c:	4d 43       	clr.b	r13		;

0000893e <.L295>:
    893e:	6c f3       	and.b	#2,	r12	;r3 As==10

00008940 <.LVL305>:
    8940:	47 4c       	mov.b	r12,	r7	;
    8942:	4a 8c       	sub.b	r12,	r10	;

00008944 <.LVL306>:
    8944:	4a 8d       	sub.b	r13,	r10	;
    8946:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

0000894a <.LVL307>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    894a:	07 93       	cmp	#0,	r7	;r3 As==00
    894c:	18 20       	jnz	$+50     	;abs 0x897e

0000894e <.Loc.1149.2>:
    894e:	69 43       	mov.b	#2,	r9	;r3 As==10

00008950 <.L296>:
    8950:	40 18 04 49 	movx.w	r9,	r4	;
    8954:	e4 08       	adda	r8,	r4	;

00008956 <.LBB58>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8956:	c6 04       	mova	r4,	r6	;
    8958:	0d 49       	mov	r9,	r13	;
    895a:	0a 59       	add	r9,	r10	;

0000895c <.L297>:
    895c:	0d 9a       	cmp	r10,	r13	;
    895e:	12 38       	jl	$+38     	;abs 0x8984

00008960 <.LBB59>:
    elyEventLog(buffer[i]);
    8960:	86 00 b0 bf 	mova	#49072,	r6	;0x0bfb0

00008964 <.L303>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8964:	09 9a       	cmp	r10,	r9	;
    8966:	3d 38       	jl	$+124    	;abs 0x89e2

00008968 <.LBE59>:
  if (hdr.reply) {
    8968:	07 93       	cmp	#0,	r7	;r3 As==00
    896a:	31 24       	jz	$+100    	;abs 0x89ce

0000896c <.Loc.1176.2>:
    gen_success(buffer, hdr.crc);
    896c:	4d 45       	mov.b	r5,	r13	;
    896e:	cc 08       	mova	r8,	r12	;
    8970:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008974 <.LVL311>:
    8974:	80 00 b8 89 	mova	#35256,	r0	;0x089b8

00008978 <.L306>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8978:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000897a <.LVL313>:
    897a:	80 00 3e 89 	mova	#35134,	r0	;0x0893e

0000897e <.L307>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    897e:	69 42       	mov.b	#4,	r9	;r2 As==10
    8980:	80 00 50 89 	mova	#35152,	r0	;0x08950

00008984 <.L302>:
    if ((buffer[i] < 0xC0) || 
    8984:	6c 46       	mov.b	@r6,	r12	;
    8986:	4e 4c       	mov.b	r12,	r14	;
    8988:	7e 50 40 00 	add.b	#64,	r14	;#0x0040
    898c:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    8990:	4f 9e       	cmp.b	r14,	r15	;
    8992:	0c 28       	jnc	$+26     	;abs 0x89ac

00008994 <.Loc.1153.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8994:	7e 50 ed ff 	add.b	#-19,	r14	;#0xffed

00008998 <.Loc.1152.2>:
    if ((buffer[i] < 0xC0) || 
    8998:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    899c:	4f 9e       	cmp.b	r14,	r15	;
    899e:	06 2c       	jc	$+14     	;abs 0x89ac
    89a0:	a6 00 01 00 	adda	#1,	r6	;

000089a4 <.Loc.1154.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    89a4:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

000089a8 <.Loc.1153.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    89a8:	4f 9c       	cmp.b	r12,	r15	;
    89aa:	18 28       	jnc	$+50     	;abs 0x89dc

000089ac <.L298>:
      if (hdr.reply) {
    89ac:	07 93       	cmp	#0,	r7	;r3 As==00
    89ae:	0b 24       	jz	$+24     	;abs 0x89c6

000089b0 <.Loc.1158.2>:
        gen_failure(buffer, hdr.crc);
    89b0:	4d 45       	mov.b	r5,	r13	;

000089b2 <.LVL316>:
    89b2:	cc 08       	mova	r8,	r12	;
    89b4:	b0 13 e2 7b 	calla	#31714		;0x07be2

000089b8 <.L308>:
    elyCmdSendReply(buffer);
    89b8:	cc 08       	mova	r8,	r12	;
    89ba:	b0 13 f8 80 	calla	#33016		;0x080f8

000089be <.L294>:
}
    89be:	a1 00 02 00 	adda	#2,	r1	;
    89c2:	64 16       	popm.a	#7,	r10	;20-bit words
    89c4:	10 01       	reta			;

000089c6 <.L300>:
        elyErrorSignal(ErrCmdFailure);
    89c6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    89ca:	b0 13 32 bf 	calla	#48946		;0x0bf32

000089ce <.L305>:
    elyNLFreeBuffer(elyNLPack(buffer));
    89ce:	cc 08       	mova	r8,	r12	;
    89d0:	b0 13 78 be 	calla	#48760		;0x0be78

000089d4 <.LVL321>:
    89d4:	b0 13 24 bd 	calla	#48420		;0x0bd24

000089d8 <.LVL322>:
    89d8:	80 00 be 89 	mova	#35262,	r0	;0x089be

000089dc <.L299>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    89dc:	1d 53       	inc	r13		;
    89de:	80 00 5c 89 	mova	#35164,	r0	;0x0895c

000089e2 <.L304>:
    elyEventLog(buffer[i]);
    89e2:	6c 44       	mov.b	@r4,	r12	;
    89e4:	46 13       	calla	r6		;

000089e6 <.LVL326>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    89e6:	19 53       	inc	r9		;
    89e8:	a4 00 01 00 	adda	#1,	r4	;
    89ec:	80 00 64 89 	mova	#35172,	r0	;0x08964

000089f0 <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    89f0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000089f2 <.LCFI41>:
    89f2:	b1 00 02 00 	suba	#2,	r1	;

000089f6 <.LCFI42>:
    89f6:	c8 0c       	mova	r12,	r8	;
    89f8:	69 4d       	mov.b	@r13,	r9	;
    89fa:	59 f3       	and.b	#1,	r9	;r3 As==01

000089fc <.LVL329>:
    89fc:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008a00 <.LVL330>:
    8a00:	c1 45 01 00 	mov.b	r5,	1(r1)	;

00008a04 <.Loc.1112.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8a04:	6c 4d       	mov.b	@r13,	r12	;

00008a06 <.LVL332>:
    8a06:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8a08:	4c d9       	bis.b	r9,	r12	;
    8a0a:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8a0e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a12:	1c b3       	bit	#1,	r12	;r3 As==01
    8a14:	1e 20       	jnz	$+62     	;abs 0x8a52
    8a16:	4d 43       	clr.b	r13		;

00008a18 <.L310>:
    8a18:	6c f3       	and.b	#2,	r12	;r3 As==10
    8a1a:	47 4c       	mov.b	r12,	r7	;
    8a1c:	45 8c       	sub.b	r12,	r5	;

00008a1e <.LVL334>:
    8a1e:	45 8d       	sub.b	r13,	r5	;
    8a20:	35 f0 ff 00 	and	#255,	r5	;#0x00ff

00008a24 <.LVL335>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a24:	07 93       	cmp	#0,	r7	;r3 As==00
    8a26:	18 20       	jnz	$+50     	;abs 0x8a58

00008a28 <.Loc.1113.2>:
    8a28:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008a2a <.L311>:
    8a2a:	40 18 04 4a 	movx.w	r10,	r4	;
    8a2e:	e4 08       	adda	r8,	r4	;

00008a30 <.LBB64>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8a30:	cc 04       	mova	r4,	r12	;
    8a32:	0d 4a       	mov	r10,	r13	;
    8a34:	05 5a       	add	r10,	r5	;

00008a36 <.L312>:
    8a36:	0d 95       	cmp	r5,	r13	;
    8a38:	12 38       	jl	$+38     	;abs 0x8a5e

00008a3a <.LBB65>:
    elyEventUnsubscribe(buffer[i]);
    8a3a:	86 00 8e bf 	mova	#49038,	r6	;0x0bf8e

00008a3e <.L317>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8a3e:	0a 95       	cmp	r5,	r10	;
    8a40:	30 38       	jl	$+98     	;abs 0x8aa2

00008a42 <.LBE65>:
  if (hdr.reply) {
    8a42:	07 93       	cmp	#0,	r7	;r3 As==00
    8a44:	24 24       	jz	$+74     	;abs 0x8a8e

00008a46 <.Loc.1137.2>:
    gen_success(buffer, hdr.crc);
    8a46:	4d 49       	mov.b	r9,	r13	;
    8a48:	cc 08       	mova	r8,	r12	;
    8a4a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008a4e <.LVL339>:
    8a4e:	80 00 78 8a 	mova	#35448,	r0	;0x08a78

00008a52 <.L320>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8a52:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008a54 <.LVL341>:
    8a54:	80 00 18 8a 	mova	#35352,	r0	;0x08a18

00008a58 <.L321>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a58:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8a5a:	80 00 2a 8a 	mova	#35370,	r0	;0x08a2a

00008a5e <.L316>:
    8a5e:	ac 00 01 00 	adda	#1,	r12	;

00008a62 <.LBB66>:
    if (buffer[i] < 0xC0) {
    8a62:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    8a66:	5e 9c ff ff 	cmp.b	-1(r12),r14	;
    8a6a:	18 28       	jnc	$+50     	;abs 0x8a9c

00008a6c <.Loc.1117.2>:
      if (hdr.reply) {
    8a6c:	07 93       	cmp	#0,	r7	;r3 As==00
    8a6e:	0b 24       	jz	$+24     	;abs 0x8a86

00008a70 <.Loc.1119.2>:
        gen_failure(buffer, hdr.crc);
    8a70:	4d 49       	mov.b	r9,	r13	;

00008a72 <.LVL344>:
    8a72:	cc 08       	mova	r8,	r12	;
    8a74:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008a78 <.L322>:
    elyCmdSendReply(buffer);
    8a78:	cc 08       	mova	r8,	r12	;
    8a7a:	b0 13 f8 80 	calla	#33016		;0x080f8

00008a7e <.L309>:
}
    8a7e:	a1 00 02 00 	adda	#2,	r1	;
    8a82:	64 16       	popm.a	#7,	r10	;20-bit words
    8a84:	10 01       	reta			;

00008a86 <.L314>:
        elyErrorSignal(ErrCmdFailure);
    8a86:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8a8a:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008a8e <.L319>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8a8e:	cc 08       	mova	r8,	r12	;
    8a90:	b0 13 78 be 	calla	#48760		;0x0be78

00008a94 <.LVL349>:
    8a94:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008a98 <.LVL350>:
    8a98:	80 00 7e 8a 	mova	#35454,	r0	;0x08a7e

00008a9c <.L313>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8a9c:	1d 53       	inc	r13		;
    8a9e:	80 00 36 8a 	mova	#35382,	r0	;0x08a36

00008aa2 <.L318>:
    elyEventUnsubscribe(buffer[i]);
    8aa2:	6c 44       	mov.b	@r4,	r12	;
    8aa4:	46 13       	calla	r6		;

00008aa6 <.LVL354>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8aa6:	1a 53       	inc	r10		;
    8aa8:	a4 00 01 00 	adda	#1,	r4	;
    8aac:	80 00 3e 8a 	mova	#35390,	r0	;0x08a3e

00008ab0 <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ab0:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008ab2 <.LCFI43>:
    8ab2:	b1 00 02 00 	suba	#2,	r1	;

00008ab6 <.LCFI44>:
    8ab6:	c8 0c       	mova	r12,	r8	;
    8ab8:	65 4d       	mov.b	@r13,	r5	;
    8aba:	55 f3       	and.b	#1,	r5	;r3 As==01

00008abc <.LVL357>:
    8abc:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00008ac0 <.LVL358>:
    8ac0:	c1 4a 01 00 	mov.b	r10,	1(r1)	;

00008ac4 <.Loc.1064.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8ac4:	6c 4d       	mov.b	@r13,	r12	;

00008ac6 <.LVL360>:
    8ac6:	5c c3       	bic.b	#1,	r12	;r3 As==01
    8ac8:	4c d5       	bis.b	r5,	r12	;
    8aca:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    8ace:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ad2:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8ad6:	25 24       	jz	$+76     	;abs 0x8b22
    8ad8:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008ada <.L324>:
    8ada:	6c f3       	and.b	#2,	r12	;r3 As==10
    8adc:	47 4c       	mov.b	r12,	r7	;
    8ade:	4a 8c       	sub.b	r12,	r10	;

00008ae0 <.LVL362>:
    8ae0:	4a 8d       	sub.b	r13,	r10	;
    8ae2:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00008ae6 <.LVL363>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8ae6:	07 93       	cmp	#0,	r7	;r3 As==00
    8ae8:	1f 24       	jz	$+64     	;abs 0x8b28

00008aea <.Loc.1065.2>:
    8aea:	69 42       	mov.b	#4,	r9	;r2 As==10

00008aec <.L325>:
    8aec:	40 18 06 49 	movx.w	r9,	r6	;
    8af0:	e6 08       	adda	r8,	r6	;

00008af2 <.LBB70>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8af2:	cc 06       	mova	r6,	r12	;
    8af4:	0e 49       	mov	r9,	r14	;
    8af6:	0a 59       	add	r9,	r10	;

00008af8 <.L326>:
    8af8:	0e 9a       	cmp	r10,	r14	;
    8afa:	19 38       	jl	$+52     	;abs 0x8b2e

00008afc <.LBE70>:
  if (hdr.reply) {
    8afc:	07 93       	cmp	#0,	r7	;r3 As==00
    8afe:	46 24       	jz	$+142    	;abs 0x8b8c

00008b00 <.Loc.1088.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    8b00:	54 48 02 00 	mov.b	2(r8),	r4	;
    8b04:	47 18 04 54 	rpt #8 { rlax.w	r4		;
    8b08:	5c 48 03 00 	mov.b	3(r8),	r12	;

00008b0c <.L339>:
    8b0c:	04 dc       	bis	r12,	r4	;

00008b0e <.L334>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8b0e:	09 9a       	cmp	r10,	r9	;
    8b10:	47 38       	jl	$+144    	;abs 0x8ba0

00008b12 <.LBE71>:
  if (hdr.reply) {
    8b12:	07 93       	cmp	#0,	r7	;r3 As==00
    8b14:	31 24       	jz	$+100    	;abs 0x8b78

00008b16 <.Loc.1101.2>:
    gen_success(buffer, hdr.crc);
    8b16:	4d 45       	mov.b	r5,	r13	;
    8b18:	cc 08       	mova	r8,	r12	;
    8b1a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008b1e <.LVL367>:
    8b1e:	80 00 62 8b 	mova	#35682,	r0	;0x08b62

00008b22 <.L337>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8b22:	4d 43       	clr.b	r13		;

00008b24 <.LVL369>:
    8b24:	80 00 da 8a 	mova	#35546,	r0	;0x08ada

00008b28 <.L338>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8b28:	69 43       	mov.b	#2,	r9	;r3 As==10
    8b2a:	80 00 ec 8a 	mova	#35564,	r0	;0x08aec

00008b2e <.L331>:
    if ((buffer[i] < 0xC0) || 
    8b2e:	6d 4c       	mov.b	@r12,	r13	;
    8b30:	4f 4d       	mov.b	r13,	r15	;
    8b32:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    8b36:	74 40 32 00 	mov.b	#50,	r4	;#0x0032
    8b3a:	44 9f       	cmp.b	r15,	r4	;
    8b3c:	0c 28       	jnc	$+26     	;abs 0x8b56

00008b3e <.Loc.1069.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8b3e:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00008b42 <.Loc.1068.2>:
    if ((buffer[i] < 0xC0) || 
    8b42:	74 40 0c 00 	mov.b	#12,	r4	;#0x000c
    8b46:	44 9f       	cmp.b	r15,	r4	;
    8b48:	06 2c       	jc	$+14     	;abs 0x8b56
    8b4a:	ac 00 01 00 	adda	#1,	r12	;

00008b4e <.Loc.1070.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    8b4e:	7d 50 1d 00 	add.b	#29,	r13	;#0x001d

00008b52 <.Loc.1069.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8b52:	44 9d       	cmp.b	r13,	r4	;
    8b54:	18 28       	jnc	$+50     	;abs 0x8b86

00008b56 <.L327>:
      if (hdr.reply) {
    8b56:	07 93       	cmp	#0,	r7	;r3 As==00
    8b58:	0b 24       	jz	$+24     	;abs 0x8b70

00008b5a <.Loc.1074.2>:
        gen_failure(buffer, hdr.crc);
    8b5a:	4d 45       	mov.b	r5,	r13	;
    8b5c:	cc 08       	mova	r8,	r12	;
    8b5e:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008b62 <.L340>:
    elyCmdSendReply(buffer);
    8b62:	cc 08       	mova	r8,	r12	;
    8b64:	b0 13 f8 80 	calla	#33016		;0x080f8

00008b68 <.L323>:
}
    8b68:	a1 00 02 00 	adda	#2,	r1	;
    8b6c:	64 16       	popm.a	#7,	r10	;20-bit words
    8b6e:	10 01       	reta			;

00008b70 <.L329>:
        elyErrorSignal(ErrCmdFailure);
    8b70:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8b74:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008b78 <.L336>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8b78:	cc 08       	mova	r8,	r12	;
    8b7a:	b0 13 78 be 	calla	#48760		;0x0be78

00008b7e <.LVL376>:
    8b7e:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008b82 <.LVL377>:
    8b82:	80 00 68 8b 	mova	#35688,	r0	;0x08b68

00008b86 <.L328>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8b86:	1e 53       	inc	r14		;
    8b88:	80 00 f8 8a 	mova	#35576,	r0	;0x08af8

00008b8c <.L332>:
    8b8c:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    8b90:	54 4c 55 00 	mov.b	85(r12),r4	;0x00055
    8b94:	47 18 04 54 	rpt #8 { rlax.w	r4		;
    8b98:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    8b9c:	80 00 0c 8b 	mova	#35596,	r0	;0x08b0c

00008ba0 <.L335>:
      elyEventSubscribe(buffer[i], addr);
    8ba0:	0d 44       	mov	r4,	r13	;
    8ba2:	6c 46       	mov.b	@r6,	r12	;
    8ba4:	b0 13 6c bf 	calla	#49004		;0x0bf6c

00008ba8 <.LVL381>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8ba8:	19 53       	inc	r9		;
    8baa:	a6 00 01 00 	adda	#1,	r6	;
    8bae:	80 00 0e 8b 	mova	#35598,	r0	;0x08b0e

00008bb2 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8bb2:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008bb4 <.LCFI45>:
    8bb4:	b1 00 02 00 	suba	#2,	r1	;

00008bb8 <.LCFI46>:
    8bb8:	ca 0c       	mova	r12,	r10	;
    8bba:	69 4d       	mov.b	@r13,	r9	;
    8bbc:	59 f3       	and.b	#1,	r9	;r3 As==01

00008bbe <.Loc.1048.2>:
    8bbe:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00008bc2 <.Loc.1050.2>:
  elyChanReset();
    8bc2:	b0 13 68 c1 	calla	#49512		;0x0c168

00008bc6 <.LVL386>:
  if (hdr.reply) {
    8bc6:	40 18 e1 b3 	bitx.b	#2,	0(r1)	;r3 As==10
    8bca:	00 00 
    8bcc:	0b 24       	jz	$+24     	;abs 0x8be4

00008bce <.Loc.1054.2>:
    gen_success(buffer, hdr.crc);
    8bce:	4d 49       	mov.b	r9,	r13	;
    8bd0:	cc 0a       	mova	r10,	r12	;
    8bd2:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008bd6 <.LVL387>:
    elyCmdSendReply(buffer);
    8bd6:	cc 0a       	mova	r10,	r12	;
    8bd8:	b0 13 f8 80 	calla	#33016		;0x080f8

00008bdc <.L341>:
}
    8bdc:	a1 00 02 00 	adda	#2,	r1	;
    8be0:	19 16       	popm.a	#2,	r10	;20-bit words
    8be2:	10 01       	reta			;

00008be4 <.L342>:
    8be4:	cc 0a       	mova	r10,	r12	;
    8be6:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00008bea <.LVL389>:
    8bea:	80 00 dc 8b 	mova	#35804,	r0	;0x08bdc

00008bee <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8bee:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008bf0 <.LCFI47>:
    8bf0:	b1 00 02 00 	suba	#2,	r1	;

00008bf4 <.LCFI48>:
    8bf4:	ca 0c       	mova	r12,	r10	;
    8bf6:	ce 0d       	mova	r13,	r14	;
    8bf8:	6d 4d       	mov.b	@r13,	r13	;
    8bfa:	5d f3       	and.b	#1,	r13	;r3 As==01

00008bfc <.LVL391>:
    8bfc:	d1 4e 01 00 	mov.b	1(r14),	1(r1)	;
    8c00:	01 00 

00008c02 <.Loc.1014.2>:
  if (hdr.reply) {
    8c02:	69 4e       	mov.b	@r14,	r9	;
    8c04:	59 c3       	bic.b	#1,	r9	;r3 As==01
    8c06:	49 dd       	bis.b	r13,	r9	;
    8c08:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    8c0c:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8c10:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    8c14:	49 24       	jz	$+148    	;abs 0x8ca8

00008c16 <.LBB76>:
    if ((buffer[4] < 0x40) || 
    8c16:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008c1a <.LVL393>:
    8c1a:	4e 4c       	mov.b	r12,	r14	;
    8c1c:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    8c20:	88 00 f8 80 	mova	#33016,	r8	;0x080f8
    8c24:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    8c28:	4f 9e       	cmp.b	r14,	r15	;
    8c2a:	0c 28       	jnc	$+26     	;abs 0x8c44

00008c2c <.Loc.1016.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8c2c:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

00008c30 <.Loc.1015.2>:
    if ((buffer[4] < 0x40) || 
    8c30:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    8c34:	4f 9e       	cmp.b	r14,	r15	;
    8c36:	06 2c       	jc	$+14     	;abs 0x8c44

00008c38 <.Loc.1017.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    8c38:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

00008c3c <.Loc.1016.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8c3c:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    8c40:	4e 9c       	cmp.b	r12,	r14	;
    8c42:	09 28       	jnc	$+20     	;abs 0x8c56

00008c44 <.L346>:
        gen_failure(buffer, hdr.crc);
    8c44:	cc 0a       	mova	r10,	r12	;
    8c46:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008c4a <.L350>:
    elyCmdSendReply(buffer);
    8c4a:	cc 0a       	mova	r10,	r12	;
    8c4c:	48 13       	calla	r8		;

00008c4e <.L344>:
}
    8c4e:	a1 00 02 00 	adda	#2,	r1	;
    8c52:	28 16       	popm.a	#3,	r10	;20-bit words
    8c54:	10 01       	reta			;

00008c56 <.L347>:
    buffer[0] = buffer[0] & 0x3F;
    8c56:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8c5a:	00 00 

00008c5c <.Loc.1026.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8c5c:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    8c60:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8c64:	02 00 

00008c66 <.Loc.1027.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8c66:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8c6a:	03 00 

00008c6c <.Loc.1030.2>:
    size_t n = elyChanGetValue(&buffer[4]);
    8c6c:	cc 0a       	mova	r10,	r12	;
    8c6e:	ac 00 04 00 	adda	#4,	r12	;
    8c72:	b0 13 60 c1 	calla	#49504		;0x0c160

00008c76 <.LVL397>:
    8c76:	0c 14       	pushm.a	#1,	r12	;20-bit words
    8c78:	40 18 3e 41 	popx.w	r14		;
    8c7c:	40 18 3f 41 	popx.w	r15		;

00008c80 <.Loc.1032.2>:
    if (hdr.crc) {
    8c80:	40 18 19 b3 	bitx.w	#1,	r9	;r3 As==01
    8c84:	0c 24       	jz	$+26     	;abs 0x8c9e

00008c86 <.Loc.1033.2>:
      buffer[1] = n + 3;
    8c86:	7e 50 03 00 	add.b	#3,	r14	;
    8c8a:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

00008c8e <.Loc.1034.2>:
      crcGenX25(buffer, 7+n);
    8c8e:	cd 0c       	mova	r12,	r13	;
    8c90:	ad 00 07 00 	adda	#7,	r13	;
    8c94:	cc 0a       	mova	r10,	r12	;

00008c96 <.LVL398>:
    8c96:	b0 13 50 ab 	calla	#43856		;0x0ab50

00008c9a <.LVL399>:
    8c9a:	80 00 4a 8c 	mova	#35914,	r0	;0x08c4a

00008c9e <.L349>:
      buffer[1] = n + 1;
    8c9e:	5e 53       	inc.b	r14		;
    8ca0:	ca 4e 01 00 	mov.b	r14,	1(r10)	;
    8ca4:	80 00 4a 8c 	mova	#35914,	r0	;0x08c4a

00008ca8 <.L345>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8ca8:	b0 13 78 be 	calla	#48760		;0x0be78

00008cac <.LVL402>:
    8cac:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008cb0 <.LVL403>:
    8cb0:	80 00 4e 8c 	mova	#35918,	r0	;0x08c4e

00008cb4 <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8cb4:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008cb6 <.LCFI49>:
    8cb6:	b1 00 02 00 	suba	#2,	r1	;

00008cba <.LCFI50>:
    8cba:	ca 0c       	mova	r12,	r10	;

00008cbc <.LVL405>:
    8cbc:	5f 4d 01 00 	mov.b	1(r13),	r15	;

00008cc0 <.LVL406>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8cc0:	68 4d       	mov.b	@r13,	r8	;
    8cc2:	58 f3       	and.b	#1,	r8	;r3 As==01
    8cc4:	6e 4d       	mov.b	@r13,	r14	;
    8cc6:	06 4e       	mov	r14,	r6	;
    8cc8:	56 f3       	and.b	#1,	r6	;r3 As==01
    8cca:	06 93       	cmp	#0,	r6	;r3 As==00
    8ccc:	23 20       	jnz	$+72     	;abs 0x8d14
    8cce:	07 46       	mov	r6,	r7	;

00008cd0 <.L352>:
    8cd0:	6e f3       	and.b	#2,	r14	;r3 As==10
    8cd2:	49 4e       	mov.b	r14,	r9	;

00008cd4 <.LVL407>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8cd4:	09 93       	cmp	#0,	r9	;r3 As==00
    8cd6:	21 20       	jnz	$+68     	;abs 0x8d1a

00008cd8 <.Loc.980.2>:
    8cd8:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008cda <.L353>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8cda:	0b 4c       	mov	r12,	r11	;

00008cdc <.LVL409>:
    8cdc:	0d 4f       	mov	r15,	r13	;

00008cde <.LVL410>:
    8cde:	0d 5c       	add	r12,	r13	;
    8ce0:	06 93       	cmp	#0,	r6	;r3 As==00
    8ce2:	01 24       	jz	$+4      	;abs 0x8ce6
    8ce4:	66 43       	mov.b	#2,	r6	;r3 As==10

00008ce6 <.L355>:
    8ce6:	0d 86       	sub	r6,	r13	;
    8ce8:	40 18 04 4c 	movx.w	r12,	r4	;
    8cec:	e4 0a       	adda	r10,	r4	;
    8cee:	cc 04       	mova	r4,	r12	;

00008cf0 <.L356>:
    8cf0:	0b 9d       	cmp	r13,	r11	;
    8cf2:	16 38       	jl	$+46     	;abs 0x8d20

00008cf4 <.LBE78>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8cf4:	40 18 4d 4f 	movx.b	r15,	r13	;
    8cf8:	40 18 4d 8e 	subx.b	r14,	r13	;

00008cfc <.Loc.998.2>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    8cfc:	4d 87       	sub.b	r7,	r13	;
    8cfe:	cc 04       	mova	r4,	r12	;
    8d00:	b0 13 10 c1 	calla	#49424		;0x0c110

00008d04 <.LVL412>:
  if (hdr.reply) {
    8d04:	09 93       	cmp	#0,	r9	;r3 As==00
    8d06:	26 24       	jz	$+78     	;abs 0x8d54

00008d08 <.Loc.1002.2>:
    gen_success(buffer, hdr.crc);
    8d08:	4d 48       	mov.b	r8,	r13	;
    8d0a:	cc 0a       	mova	r10,	r12	;
    8d0c:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008d10 <.LVL413>:
    8d10:	80 00 3e 8d 	mova	#36158,	r0	;0x08d3e

00008d14 <.L362>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8d14:	67 43       	mov.b	#2,	r7	;r3 As==10
    8d16:	80 00 d0 8c 	mova	#36048,	r0	;0x08cd0

00008d1a <.L363>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8d1a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8d1c:	80 00 da 8c 	mova	#36058,	r0	;0x08cda

00008d20 <.L360>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    8d20:	66 4c       	mov.b	@r12,	r6	;
    8d22:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    8d26:	ac 00 01 00 	adda	#1,	r12	;
    8d2a:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    8d2e:	45 96       	cmp.b	r6,	r5	;
    8d30:	18 2c       	jc	$+50     	;abs 0x8d62

00008d32 <.Loc.984.2>:
      if (hdr.reply) {
    8d32:	09 93       	cmp	#0,	r9	;r3 As==00
    8d34:	0b 24       	jz	$+24     	;abs 0x8d4c

00008d36 <.Loc.986.2>:
        gen_failure(buffer, hdr.crc);
    8d36:	4d 48       	mov.b	r8,	r13	;
    8d38:	cc 0a       	mova	r10,	r12	;
    8d3a:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008d3e <.L364>:
    elyCmdSendReply(buffer);
    8d3e:	cc 0a       	mova	r10,	r12	;
    8d40:	b0 13 f8 80 	calla	#33016		;0x080f8

00008d44 <.L351>:
}
    8d44:	a1 00 02 00 	adda	#2,	r1	;
    8d48:	64 16       	popm.a	#7,	r10	;20-bit words
    8d4a:	10 01       	reta			;

00008d4c <.L358>:
        elyErrorSignal(ErrCmdFailure);
    8d4c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8d50:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008d54 <.L361>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8d54:	cc 0a       	mova	r10,	r12	;
    8d56:	b0 13 78 be 	calla	#48760		;0x0be78

00008d5a <.LVL421>:
    8d5a:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008d5e <.LVL422>:
    8d5e:	80 00 44 8d 	mova	#36164,	r0	;0x08d44

00008d62 <.L357>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8d62:	1b 53       	inc	r11		;
    8d64:	80 00 f0 8c 	mova	#36080,	r0	;0x08cf0

00008d68 <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8d68:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008d6a <.LCFI51>:
    8d6a:	b1 00 10 00 	suba	#16,	r1	;0x00010

00008d6e <.LCFI52>:
    8d6e:	ca 0c       	mova	r12,	r10	;

00008d70 <.LVL426>:
    8d70:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008d74 <.LVL427>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8d74:	68 4d       	mov.b	@r13,	r8	;
    8d76:	58 f3       	and.b	#1,	r8	;r3 As==01
    8d78:	6c 4d       	mov.b	@r13,	r12	;

00008d7a <.LVL428>:
    8d7a:	1c b3       	bit	#1,	r12	;r3 As==01
    8d7c:	5f 20       	jnz	$+192    	;abs 0x8e3c
    8d7e:	4d 43       	clr.b	r13		;

00008d80 <.L366>:
    8d80:	6c f3       	and.b	#2,	r12	;r3 As==10

00008d82 <.LVL430>:
    8d82:	46 4c       	mov.b	r12,	r6	;
    8d84:	45 8c       	sub.b	r12,	r5	;

00008d86 <.LVL431>:
    8d86:	45 8d       	sub.b	r13,	r5	;
    8d88:	49 45       	mov.b	r5,	r9	;

00008d8a <.LVL432>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8d8a:	06 93       	cmp	#0,	r6	;r3 As==00
    8d8c:	5a 20       	jnz	$+182    	;abs 0x8e42

00008d8e <.Loc.934.2>:
    8d8e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008d90 <.L367>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8d90:	0f 4c       	mov	r12,	r15	;
    8d92:	2f 52       	add	#4,	r15	;r2 As==10

00008d94 <.LVL434>:
    8d94:	04 4f       	mov	r15,	r4	;
    8d96:	44 0e       	rlam.a	#4,	r4	;
    8d98:	44 0d       	rram.a	#4,	r4	;
    8d9a:	ce 04       	mova	r4,	r14	;
    8d9c:	ee 0a       	adda	r10,	r14	;
    8d9e:	09 5c       	add	r12,	r9	;

00008da0 <.L368>:
    8da0:	0f 99       	cmp	r9,	r15	;
    8da2:	52 38       	jl	$+166    	;abs 0x8e48
    8da4:	0d 4c       	mov	r12,	r13	;
    8da6:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    8daa:	0d 8c       	sub	r12,	r13	;
    8dac:	81 4d 08 00 	mov	r13,	8(r1)	;

00008db0 <.Loc.937.2>:
    8db0:	67 42       	mov.b	#4,	r7	;r2 As==10
    8db2:	49 43       	clr.b	r9		;
    8db4:	04 49       	mov	r9,	r4	;
    8db6:	4d 4c       	mov.b	r12,	r13	;
    8db8:	0e 43       	clr	r14		;
    8dba:	81 4d 04 00 	mov	r13,	4(r1)	;
    8dbe:	81 4e 06 00 	mov	r14,	6(r1)	;

00008dc2 <.LBB83>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8dc2:	0e 12       	push	r14		;
    8dc4:	0d 12       	push	r13		;
    8dc6:	0c 16       	popm.a	#1,	r12	;20-bit words
    8dc8:	ec 0a       	adda	r10,	r12	;
    8dca:	71 0c 0a 00 	mova	r12,	10(r1)	; 0x0000a

00008dce <.L374>:
    8dce:	37 53       	add	#-1,	r7	;r3 As==11

00008dd0 <.Loc.956.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    8dd0:	37 93       	cmp	#-1,	r7	;r3 As==11
    8dd2:	6b 20       	jnz	$+216    	;abs 0x8eaa

00008dd4 <.LBE83>:
  interval = (interval / 100) * 100;
    8dd4:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8dd8:	4f 43       	clr.b	r15		;
    8dda:	0c 49       	mov	r9,	r12	;
    8ddc:	0d 44       	mov	r4,	r13	;
    8dde:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    8de2:	07 4c       	mov	r12,	r7	;
    8de4:	09 4d       	mov	r13,	r9	;

00008de6 <.LVL437>:
    8de6:	0e 4c       	mov	r12,	r14	;
    8de8:	0e 5c       	add	r12,	r14	;
    8dea:	0d 6d       	rlc	r13		;
    8dec:	04 4e       	mov	r14,	r4	;
    8dee:	04 57       	add	r7,	r4	;
    8df0:	0f 4d       	mov	r13,	r15	;
    8df2:	0f 69       	addc	r9,	r15	;
    8df4:	0c 44       	mov	r4,	r12	;
    8df6:	0d 4f       	mov	r15,	r13	;
    8df8:	71 0f 00 00 	mova	r15,	0(r1)	;
    8dfc:	b0 13 1a cc 	calla	#52250		;0x0cc1a
    8e00:	0e 44       	mov	r4,	r14	;
    8e02:	0e 5c       	add	r12,	r14	;
    8e04:	0f 01       	mova	@r1,	r15	;
    8e06:	0f 6d       	addc	r13,	r15	;

00008e08 <.Loc.963.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    8e08:	1c 41 04 00 	mov	4(r1),	r12	;
    8e0c:	1d 41 06 00 	mov	6(r1),	r13	;
    8e10:	0d 12       	push	r13		;
    8e12:	0c 12       	push	r12		;
    8e14:	04 16       	popm.a	#1,	r4	;20-bit words
    8e16:	cc 04       	mova	r4,	r12	;
    8e18:	ac 00 04 00 	adda	#4,	r12	;
    8e1c:	0e 57       	add	r7,	r14	;
    8e1e:	0f 69       	addc	r9,	r15	;
    8e20:	4d 45       	mov.b	r5,	r13	;
    8e22:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    8e26:	ec 0a       	adda	r10,	r12	;
    8e28:	b0 13 c0 c0 	calla	#49344		;0x0c0c0

00008e2c <.LVL439>:
  if (hdr.reply) {
    8e2c:	06 93       	cmp	#0,	r6	;r3 As==00
    8e2e:	33 24       	jz	$+104    	;abs 0x8e96

00008e30 <.Loc.967.2>:
    gen_success(buffer, hdr.crc);
    8e30:	4d 48       	mov.b	r8,	r13	;
    8e32:	cc 0a       	mova	r10,	r12	;
    8e34:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008e38 <.LVL440>:
    8e38:	80 00 80 8e 	mova	#36480,	r0	;0x08e80

00008e3c <.L377>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8e3c:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008e3e <.LVL442>:
    8e3e:	80 00 80 8d 	mova	#36224,	r0	;0x08d80

00008e42 <.L378>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8e42:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8e44:	80 00 90 8d 	mova	#36240,	r0	;0x08d90

00008e48 <.L373>:
    if ((buffer[i] < 0x40) || 
    8e48:	6d 4e       	mov.b	@r14,	r13	;
    8e4a:	47 4d       	mov.b	r13,	r7	;
    8e4c:	77 50 c0 ff 	add.b	#-64,	r7	;#0xffc0
    8e50:	74 40 36 00 	mov.b	#54,	r4	;#0x0036
    8e54:	44 97       	cmp.b	r7,	r4	;
    8e56:	0e 28       	jnc	$+30     	;abs 0x8e74

00008e58 <.Loc.939.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8e58:	77 50 ef ff 	add.b	#-17,	r7	;#0xffef

00008e5c <.Loc.938.2>:
    if ((buffer[i] < 0x40) || 
    8e5c:	74 40 0e 00 	mov.b	#14,	r4	;#0x000e
    8e60:	44 97       	cmp.b	r7,	r4	;
    8e62:	08 2c       	jc	$+18     	;abs 0x8e74
    8e64:	ae 00 01 00 	adda	#1,	r14	;

00008e68 <.Loc.940.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    8e68:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00008e6c <.Loc.939.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8e6c:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    8e70:	47 9d       	cmp.b	r13,	r7	;
    8e72:	18 28       	jnc	$+50     	;abs 0x8ea4

00008e74 <.L369>:
      if (hdr.reply) {
    8e74:	06 93       	cmp	#0,	r6	;r3 As==00
    8e76:	0b 24       	jz	$+24     	;abs 0x8e8e

00008e78 <.Loc.944.2>:
        gen_failure(buffer, hdr.crc);
    8e78:	4d 48       	mov.b	r8,	r13	;
    8e7a:	cc 0a       	mova	r10,	r12	;
    8e7c:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008e80 <.L379>:
    elyCmdSendReply(buffer);
    8e80:	cc 0a       	mova	r10,	r12	;
    8e82:	b0 13 f8 80 	calla	#33016		;0x080f8

00008e86 <.L365>:
}
    8e86:	a1 00 10 00 	adda	#16,	r1	;0x00010
    8e8a:	64 16       	popm.a	#7,	r10	;20-bit words
    8e8c:	10 01       	reta			;

00008e8e <.L371>:
        elyErrorSignal(ErrCmdFailure);
    8e8e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8e92:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008e96 <.L376>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8e96:	cc 0a       	mova	r10,	r12	;
    8e98:	b0 13 78 be 	calla	#48760		;0x0be78

00008e9c <.LVL449>:
    8e9c:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008ea0 <.LVL450>:
    8ea0:	80 00 86 8e 	mova	#36486,	r0	;0x08e86

00008ea4 <.L370>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8ea4:	1f 53       	inc	r15		;
    8ea6:	80 00 a0 8d 	mova	#36256,	r0	;0x08da0

00008eaa <.L375>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8eaa:	1e 41 08 00 	mov	8(r1),	r14	;
    8eae:	0e 57       	add	r7,	r14	;
    8eb0:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8eb4:	3f 01 0a 00 	mova	10(r1),	r15	;0x0000a
    8eb8:	6c 4f       	mov.b	@r15,	r12	;
    8eba:	0d 43       	clr	r13		;
    8ebc:	0f 43       	clr	r15		;
    8ebe:	b0 13 36 cc 	calla	#52278		;0x0cc36
    8ec2:	09 dc       	bis	r12,	r9	;

00008ec4 <.LVL455>:
    8ec4:	04 dd       	bis	r13,	r4	;

00008ec6 <.LVL456>:
    8ec6:	80 00 ce 8d 	mova	#36302,	r0	;0x08dce

00008eca <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8eca:	4a 14       	pushm.a	#5,	r10	;20-bit words

00008ecc <.LCFI53>:
    8ecc:	b1 00 02 00 	suba	#2,	r1	;

00008ed0 <.LCFI54>:
    8ed0:	ca 0c       	mova	r12,	r10	;

00008ed2 <.LVL458>:
    8ed2:	5e 4d 01 00 	mov.b	1(r13),	r14	;

00008ed6 <.LVL459>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8ed6:	67 4d       	mov.b	@r13,	r7	;
    8ed8:	57 f3       	and.b	#1,	r7	;r3 As==01
    8eda:	6c 4d       	mov.b	@r13,	r12	;

00008edc <.LVL460>:
    8edc:	1c b3       	bit	#1,	r12	;r3 As==01
    8ede:	1d 20       	jnz	$+60     	;abs 0x8f1a
    8ee0:	4f 43       	clr.b	r15		;

00008ee2 <.L381>:
    8ee2:	6c f3       	and.b	#2,	r12	;r3 As==10
    8ee4:	49 4c       	mov.b	r12,	r9	;
    8ee6:	40 18 4d 4e 	movx.b	r14,	r13	;
    8eea:	40 18 4d 8c 	subx.b	r12,	r13	;

00008eee <.LVL461>:
    8eee:	4d 8f       	sub.b	r15,	r13	;
    8ef0:	4f 4d       	mov.b	r13,	r15	;

00008ef2 <.LVL462>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8ef2:	09 93       	cmp	#0,	r9	;r3 As==00
    8ef4:	15 20       	jnz	$+44     	;abs 0x8f20

00008ef6 <.Loc.900.2>:
    8ef6:	6e 43       	mov.b	#2,	r14	;r3 As==10

00008ef8 <.L382>:
    8ef8:	40 18 0c 4e 	movx.w	r14,	r12	;
    8efc:	ec 0a       	adda	r10,	r12	;
    8efe:	c8 0c       	mova	r12,	r8	;

00008f00 <.LBB88>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8f00:	0f 5e       	add	r14,	r15	;

00008f02 <.L383>:
    8f02:	0e 9f       	cmp	r15,	r14	;
    8f04:	10 38       	jl	$+34     	;abs 0x8f26

00008f06 <.LBE88>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    8f06:	b0 13 70 c0 	calla	#49264		;0x0c070

00008f0a <.LVL465>:
  if (hdr.reply) {
    8f0a:	09 93       	cmp	#0,	r9	;r3 As==00
    8f0c:	26 24       	jz	$+78     	;abs 0x8f5a

00008f0e <.Loc.922.2>:
    gen_success(buffer, hdr.crc);
    8f0e:	4d 47       	mov.b	r7,	r13	;
    8f10:	cc 0a       	mova	r10,	r12	;
    8f12:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00008f16 <.LVL466>:
    8f16:	80 00 44 8f 	mova	#36676,	r0	;0x08f44

00008f1a <.L389>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8f1a:	6f 43       	mov.b	#2,	r15	;r3 As==10
    8f1c:	80 00 e2 8e 	mova	#36578,	r0	;0x08ee2

00008f20 <.L390>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8f20:	6e 42       	mov.b	#4,	r14	;r2 As==10

00008f22 <.LVL469>:
    8f22:	80 00 f8 8e 	mova	#36600,	r0	;0x08ef8

00008f26 <.L387>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    8f26:	6b 48       	mov.b	@r8,	r11	;
    8f28:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    8f2c:	a8 00 01 00 	adda	#1,	r8	;
    8f30:	76 40 3f 00 	mov.b	#63,	r6	;#0x003f
    8f34:	46 9b       	cmp.b	r11,	r6	;
    8f36:	18 2c       	jc	$+50     	;abs 0x8f68

00008f38 <.Loc.904.2>:
      if (hdr.reply) {
    8f38:	09 93       	cmp	#0,	r9	;r3 As==00
    8f3a:	0b 24       	jz	$+24     	;abs 0x8f52

00008f3c <.Loc.906.2>:
        gen_failure(buffer, hdr.crc);
    8f3c:	4d 47       	mov.b	r7,	r13	;

00008f3e <.LVL471>:
    8f3e:	cc 0a       	mova	r10,	r12	;
    8f40:	b0 13 e2 7b 	calla	#31714		;0x07be2

00008f44 <.L391>:
    elyCmdSendReply(buffer);
    8f44:	cc 0a       	mova	r10,	r12	;
    8f46:	b0 13 f8 80 	calla	#33016		;0x080f8

00008f4a <.L380>:
}
    8f4a:	a1 00 02 00 	adda	#2,	r1	;
    8f4e:	46 16       	popm.a	#5,	r10	;20-bit words
    8f50:	10 01       	reta			;

00008f52 <.L385>:
        elyErrorSignal(ErrCmdFailure);
    8f52:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8f56:	b0 13 32 bf 	calla	#48946		;0x0bf32

00008f5a <.L388>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8f5a:	cc 0a       	mova	r10,	r12	;
    8f5c:	b0 13 78 be 	calla	#48760		;0x0be78

00008f60 <.LVL476>:
    8f60:	b0 13 24 bd 	calla	#48420		;0x0bd24

00008f64 <.LVL477>:
    8f64:	80 00 4a 8f 	mova	#36682,	r0	;0x08f4a

00008f68 <.L384>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8f68:	1e 53       	inc	r14		;
    8f6a:	80 00 02 8f 	mova	#36610,	r0	;0x08f02

00008f6e <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8f6e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008f70 <.LCFI55>:
    8f70:	b1 00 10 00 	suba	#16,	r1	;0x00010

00008f74 <.LCFI56>:
    8f74:	ca 0c       	mova	r12,	r10	;

00008f76 <.LVL481>:
    8f76:	55 4d 01 00 	mov.b	1(r13),	r5	;

00008f7a <.LVL482>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8f7a:	68 4d       	mov.b	@r13,	r8	;
    8f7c:	58 f3       	and.b	#1,	r8	;r3 As==01
    8f7e:	6c 4d       	mov.b	@r13,	r12	;

00008f80 <.LVL483>:
    8f80:	1c b3       	bit	#1,	r12	;r3 As==01
    8f82:	5f 20       	jnz	$+192    	;abs 0x9042
    8f84:	4d 43       	clr.b	r13		;

00008f86 <.L393>:
    8f86:	6c f3       	and.b	#2,	r12	;r3 As==10

00008f88 <.LVL485>:
    8f88:	46 4c       	mov.b	r12,	r6	;
    8f8a:	45 8c       	sub.b	r12,	r5	;

00008f8c <.LVL486>:
    8f8c:	45 8d       	sub.b	r13,	r5	;
    8f8e:	49 45       	mov.b	r5,	r9	;

00008f90 <.LVL487>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8f90:	06 93       	cmp	#0,	r6	;r3 As==00
    8f92:	5a 20       	jnz	$+182    	;abs 0x9048

00008f94 <.Loc.854.2>:
    8f94:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008f96 <.L394>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8f96:	0f 4c       	mov	r12,	r15	;
    8f98:	2f 52       	add	#4,	r15	;r2 As==10

00008f9a <.LVL489>:
    8f9a:	04 4f       	mov	r15,	r4	;
    8f9c:	44 0e       	rlam.a	#4,	r4	;
    8f9e:	44 0d       	rram.a	#4,	r4	;
    8fa0:	ce 04       	mova	r4,	r14	;
    8fa2:	ee 0a       	adda	r10,	r14	;
    8fa4:	09 5c       	add	r12,	r9	;

00008fa6 <.L395>:
    8fa6:	0f 99       	cmp	r9,	r15	;
    8fa8:	52 38       	jl	$+166    	;abs 0x904e
    8faa:	0d 4c       	mov	r12,	r13	;
    8fac:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    8fb0:	0d 8c       	sub	r12,	r13	;
    8fb2:	81 4d 08 00 	mov	r13,	8(r1)	;

00008fb6 <.Loc.857.2>:
    8fb6:	67 42       	mov.b	#4,	r7	;r2 As==10
    8fb8:	49 43       	clr.b	r9		;
    8fba:	04 49       	mov	r9,	r4	;
    8fbc:	4d 4c       	mov.b	r12,	r13	;
    8fbe:	0e 43       	clr	r14		;
    8fc0:	81 4d 04 00 	mov	r13,	4(r1)	;
    8fc4:	81 4e 06 00 	mov	r14,	6(r1)	;

00008fc8 <.LBB93>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8fc8:	0e 12       	push	r14		;
    8fca:	0d 12       	push	r13		;
    8fcc:	0c 16       	popm.a	#1,	r12	;20-bit words
    8fce:	ec 0a       	adda	r10,	r12	;
    8fd0:	71 0c 0a 00 	mova	r12,	10(r1)	; 0x0000a

00008fd4 <.L401>:
    8fd4:	37 53       	add	#-1,	r7	;r3 As==11

00008fd6 <.Loc.876.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    8fd6:	37 93       	cmp	#-1,	r7	;r3 As==11
    8fd8:	6b 20       	jnz	$+216    	;abs 0x90b0

00008fda <.LBE93>:
  interval = (interval / 100) * 100;
    8fda:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8fde:	4f 43       	clr.b	r15		;
    8fe0:	0c 49       	mov	r9,	r12	;
    8fe2:	0d 44       	mov	r4,	r13	;
    8fe4:	b0 13 b6 cb 	calla	#52150		;0x0cbb6
    8fe8:	07 4c       	mov	r12,	r7	;
    8fea:	09 4d       	mov	r13,	r9	;

00008fec <.LVL492>:
    8fec:	0e 4c       	mov	r12,	r14	;
    8fee:	0e 5c       	add	r12,	r14	;
    8ff0:	0d 6d       	rlc	r13		;
    8ff2:	04 4e       	mov	r14,	r4	;
    8ff4:	04 57       	add	r7,	r4	;
    8ff6:	0f 4d       	mov	r13,	r15	;
    8ff8:	0f 69       	addc	r9,	r15	;
    8ffa:	0c 44       	mov	r4,	r12	;
    8ffc:	0d 4f       	mov	r15,	r13	;
    8ffe:	71 0f 00 00 	mova	r15,	0(r1)	;
    9002:	b0 13 1a cc 	calla	#52250		;0x0cc1a
    9006:	0e 44       	mov	r4,	r14	;
    9008:	0e 5c       	add	r12,	r14	;
    900a:	0f 01       	mova	@r1,	r15	;
    900c:	0f 6d       	addc	r13,	r15	;

0000900e <.Loc.884.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    900e:	1c 41 04 00 	mov	4(r1),	r12	;
    9012:	1d 41 06 00 	mov	6(r1),	r13	;
    9016:	0d 12       	push	r13		;
    9018:	0c 12       	push	r12		;
    901a:	04 16       	popm.a	#1,	r4	;20-bit words
    901c:	cc 04       	mova	r4,	r12	;
    901e:	ac 00 04 00 	adda	#4,	r12	;
    9022:	0e 57       	add	r7,	r14	;
    9024:	0f 69       	addc	r9,	r15	;
    9026:	4d 45       	mov.b	r5,	r13	;
    9028:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    902c:	ec 0a       	adda	r10,	r12	;
    902e:	b0 13 20 c0 	calla	#49184		;0x0c020

00009032 <.LVL494>:
  if (hdr.reply) {
    9032:	06 93       	cmp	#0,	r6	;r3 As==00
    9034:	4d 24       	jz	$+156    	;abs 0x90d0

00009036 <.Loc.888.2>:
    gen_success(buffer, hdr.crc);
    9036:	4d 48       	mov.b	r8,	r13	;
    9038:	cc 0a       	mova	r10,	r12	;
    903a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000903e <.LVL495>:
    903e:	80 00 86 90 	mova	#36998,	r0	;0x09086

00009042 <.L404>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    9042:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009044 <.LVL497>:
    9044:	80 00 86 8f 	mova	#36742,	r0	;0x08f86

00009048 <.L405>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9048:	6c 42       	mov.b	#4,	r12	;r2 As==10
    904a:	80 00 96 8f 	mova	#36758,	r0	;0x08f96

0000904e <.L400>:
    if ((buffer[i] < 0x40) || 
    904e:	6d 4e       	mov.b	@r14,	r13	;
    9050:	47 4d       	mov.b	r13,	r7	;
    9052:	77 50 c0 ff 	add.b	#-64,	r7	;#0xffc0
    9056:	74 40 36 00 	mov.b	#54,	r4	;#0x0036
    905a:	44 97       	cmp.b	r7,	r4	;
    905c:	0e 28       	jnc	$+30     	;abs 0x907a

0000905e <.Loc.859.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    905e:	77 50 ef ff 	add.b	#-17,	r7	;#0xffef

00009062 <.Loc.858.2>:
    if ((buffer[i] < 0x40) || 
    9062:	74 40 0e 00 	mov.b	#14,	r4	;#0x000e
    9066:	44 97       	cmp.b	r7,	r4	;
    9068:	08 2c       	jc	$+18     	;abs 0x907a
    906a:	ae 00 01 00 	adda	#1,	r14	;

0000906e <.Loc.860.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    906e:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00009072 <.Loc.859.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    9072:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    9076:	47 9d       	cmp.b	r13,	r7	;
    9078:	18 28       	jnc	$+50     	;abs 0x90aa

0000907a <.L396>:
      if (hdr.reply) {
    907a:	06 93       	cmp	#0,	r6	;r3 As==00
    907c:	09 24       	jz	$+20     	;abs 0x9090

0000907e <.Loc.864.2>:
        gen_failure(buffer, hdr.crc);
    907e:	4d 48       	mov.b	r8,	r13	;
    9080:	cc 0a       	mova	r10,	r12	;
    9082:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009086 <.L406>:
    elyCmdSendReply(buffer);
    9086:	cc 0a       	mova	r10,	r12	;
    9088:	b0 13 f8 80 	calla	#33016		;0x080f8

0000908c <.LVL501>:
    908c:	80 00 a2 90 	mova	#37026,	r0	;0x090a2

00009090 <.L398>:
        elyNLFreeBuffer(elyNLPack(buffer));
    9090:	cc 0a       	mova	r10,	r12	;
    9092:	b0 13 78 be 	calla	#48760		;0x0be78

00009096 <.LVL503>:
    9096:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000909a <.LVL504>:
        elyErrorSignal(ErrCmdFailure);
    909a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    909e:	b0 13 32 bf 	calla	#48946		;0x0bf32

000090a2 <.L392>:
}
    90a2:	a1 00 10 00 	adda	#16,	r1	;0x00010
    90a6:	64 16       	popm.a	#7,	r10	;20-bit words
    90a8:	10 01       	reta			;

000090aa <.L397>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    90aa:	1f 53       	inc	r15		;
    90ac:	80 00 a6 8f 	mova	#36774,	r0	;0x08fa6

000090b0 <.L402>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    90b0:	1e 41 08 00 	mov	8(r1),	r14	;
    90b4:	0e 57       	add	r7,	r14	;
    90b6:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    90ba:	3f 01 0a 00 	mova	10(r1),	r15	;0x0000a
    90be:	6c 4f       	mov.b	@r15,	r12	;
    90c0:	0d 43       	clr	r13		;
    90c2:	0f 43       	clr	r15		;
    90c4:	b0 13 36 cc 	calla	#52278		;0x0cc36
    90c8:	09 dc       	bis	r12,	r9	;

000090ca <.LVL510>:
    90ca:	04 dd       	bis	r13,	r4	;

000090cc <.LVL511>:
    90cc:	80 00 d4 8f 	mova	#36820,	r0	;0x08fd4

000090d0 <.L403>:
    elyNLFreeBuffer(elyNLPack(buffer));
    90d0:	cc 0a       	mova	r10,	r12	;
    90d2:	b0 13 78 be 	calla	#48760		;0x0be78

000090d6 <.LVL513>:
    90d6:	b0 13 24 bd 	calla	#48420		;0x0bd24

000090da <.LVL514>:
    90da:	80 00 a2 90 	mova	#37026,	r0	;0x090a2

000090de <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    90de:	2a 14       	pushm.a	#3,	r10	;20-bit words

000090e0 <.LCFI57>:
    90e0:	06 14       	pushm.a	#1,	r6	;20-bit words

000090e2 <.LCFI58>:
    90e2:	b1 00 02 00 	suba	#2,	r1	;

000090e6 <.LCFI59>:
    90e6:	c6 0c       	mova	r12,	r6	;
    90e8:	cc 0d       	mova	r13,	r12	;

000090ea <.LVL516>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    90ea:	6d 4d       	mov.b	@r13,	r13	;
    90ec:	5d f3       	and.b	#1,	r13	;r3 As==01
    90ee:	6e 4c       	mov.b	@r12,	r14	;
    90f0:	6e f3       	and.b	#2,	r14	;r3 As==10
    90f2:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    90f6:	0e 93       	cmp	#0,	r14	;r3 As==00
    90f8:	18 20       	jnz	$+50     	;abs 0x912a
    90fa:	6c 43       	mov.b	#2,	r12	;r3 As==10

000090fc <.L408>:
  uint8_t bank = buffer[hdr_ext];
    90fc:	40 18 0c 4c 	movx.w	r12,	r12	;
    9100:	ec 06       	adda	r6,	r12	;

00009102 <.LVL518>:
    9102:	69 4c       	mov.b	@r12,	r9	;

00009104 <.LVL519>:
  if (bank == 0 || bank > 4) {
    9104:	4c 49       	mov.b	r9,	r12	;

00009106 <.LVL520>:
    9106:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9108:	7f 40 03 00 	mov.b	#3,	r15	;
    910c:	4f 9c       	cmp.b	r12,	r15	;
    910e:	1b 2c       	jc	$+56     	;abs 0x9146

00009110 <.Loc.824.2>:
    if (hdr.reply) {
    9110:	0e 93       	cmp	#0,	r14	;r3 As==00
    9112:	0e 24       	jz	$+30     	;abs 0x9130

00009114 <.Loc.826.2>:
      gen_failure(buffer, hdr.crc);
    9114:	cc 06       	mova	r6,	r12	;
    9116:	b0 13 e2 7b 	calla	#31714		;0x07be2

0000911a <.LVL521>:
      elyCmdSendReply(buffer);
    911a:	cc 06       	mova	r6,	r12	;
    911c:	b0 13 f8 80 	calla	#33016		;0x080f8

00009120 <.L407>:
}
    9120:	a1 00 02 00 	adda	#2,	r1	;
    9124:	06 16       	popm.a	#1,	r6	;20-bit words
    9126:	28 16       	popm.a	#3,	r10	;20-bit words
    9128:	10 01       	reta			;

0000912a <.L412>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    912a:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000912c <.LVL524>:
    912c:	80 00 fc 90 	mova	#37116,	r0	;0x090fc

00009130 <.L410>:
      elyErrorSignal(ErrCmdFailure);
    9130:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9134:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009138 <.LVL526>:
      elyNLFreeBuffer(elyNLPack(buffer));
    9138:	cc 06       	mova	r6,	r12	;
    913a:	b0 13 78 be 	calla	#48760		;0x0be78

0000913e <.LVL527>:
    913e:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009142 <.LVL528>:
    9142:	80 00 20 91 	mova	#37152,	r0	;0x09120

00009146 <.L409>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    9146:	2a 01 3c 08 	mova	&67644,	r10	;0x1083c
    914a:	88 00 cc a5 	mova	#42444,	r8	;0x0a5cc
    914e:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    9152:	4e 43       	clr.b	r14		;
    9154:	cd 0a       	mova	r10,	r13	;
    9156:	4c 49       	mov.b	r9,	r12	;
    9158:	48 13       	calla	r8		;

0000915a <.LVL529>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    915a:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    915e:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    9162:	cd 0a       	mova	r10,	r13	;
    9164:	ad 00 80 00 	adda	#128,	r13	;0x00080
    9168:	4c 49       	mov.b	r9,	r12	;
    916a:	48 13       	calla	r8		;

0000916c <.LVL530>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    916c:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    9170:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    9174:	cd 0a       	mova	r10,	r13	;
    9176:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    917a:	4c 49       	mov.b	r9,	r12	;
    917c:	48 13       	calla	r8		;

0000917e <.LVL531>:
  elyNLFreeBuffer(elyNLPack(buffer));
    917e:	cc 06       	mova	r6,	r12	;
    9180:	b0 13 78 be 	calla	#48760		;0x0be78

00009184 <.LVL532>:
    9184:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009188 <.LVL533>:
  bank0w[RegActiveBank] = bank;
    9188:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

0000918c <.Loc.849.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    918c:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    9190:	48 a5 20 01 
    9194:	80 00 20 91 	mova	#37152,	r0	;0x09120

00009198 <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9198:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000919a <.LCFI60>:
    919a:	b1 00 06 00 	suba	#6,	r1	;

0000919e <.LCFI61>:
    919e:	c8 0c       	mova	r12,	r8	;

000091a0 <.LVL535>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    91a0:	65 4d       	mov.b	@r13,	r5	;
    91a2:	55 f3       	and.b	#1,	r5	;r3 As==01
    91a4:	67 4d       	mov.b	@r13,	r7	;
    91a6:	67 f3       	and.b	#2,	r7	;r3 As==10
    91a8:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    91ac:	07 93       	cmp	#0,	r7	;r3 As==00
    91ae:	36 20       	jnz	$+110    	;abs 0x921c
    91b0:	64 43       	mov.b	#2,	r4	;r3 As==10

000091b2 <.L414>:
    91b2:	40 18 04 44 	movx.w	r4,	r4	;
    91b6:	e4 08       	adda	r8,	r4	;
    91b8:	cb 04       	mova	r4,	r11	;

000091ba <.Loc.775.2>:
    91ba:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

000091be <.Loc.776.2>:
  uint32_t baud = 0;
    91be:	49 43       	clr.b	r9		;
    91c0:	0a 49       	mov	r9,	r10	;

000091c2 <.L415>:
    baud |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    91c2:	6c 4b       	mov.b	@r11,	r12	;
    91c4:	0d 43       	clr	r13		;
    91c6:	0e 46       	mov	r6,	r14	;
    91c8:	0f 43       	clr	r15		;
    91ca:	71 0b 00 00 	mova	r11,	0(r1)	;
    91ce:	b0 13 36 cc 	calla	#52278		;0x0cc36
    91d2:	0c d9       	bis	r9,	r12	;
    91d4:	0d da       	bis	r10,	r13	;
    91d6:	09 4c       	mov	r12,	r9	;

000091d8 <.LVL539>:
    91d8:	0a 4d       	mov	r13,	r10	;

000091da <.LVL540>:
    91da:	0b 01       	mova	@r1,	r11	;
    91dc:	ab 00 01 00 	adda	#1,	r11	;
    91e0:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

000091e4 <.Loc.779.2>:
  for (int i = 0; i < 4; i++) {
    91e4:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    91e8:	ec 23       	jnz	$-38     	;abs 0x91c2

000091ea <.LBE98>:
  if (baud > UART_BAUD_MAX || 
    91ea:	39 53       	add	#-1,	r9	;r3 As==11

000091ec <.LVL541>:
    91ec:	3a 63       	addc	#-1,	r10	;r3 As==11

000091ee <.LVL542>:
    91ee:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

000091f2 <.LVL543>:
    91f2:	0c 9a       	cmp	r10,	r12	;
    91f4:	06 28       	jnc	$+14     	;abs 0x9202
    91f6:	0a 9c       	cmp	r12,	r10	;
    91f8:	1f 20       	jnz	$+64     	;abs 0x9238
    91fa:	3c 40 3f 42 	mov	#16959,	r12	;#0x423f
    91fe:	0c 99       	cmp	r9,	r12	;
    9200:	1b 2c       	jc	$+56     	;abs 0x9238

00009202 <.L422>:
    if (hdr.reply) {
    9202:	07 93       	cmp	#0,	r7	;r3 As==00
    9204:	0e 24       	jz	$+30     	;abs 0x9222

00009206 <.Loc.787.2>:
      gen_failure(buffer, hdr.crc);
    9206:	4d 45       	mov.b	r5,	r13	;
    9208:	cc 08       	mova	r8,	r12	;
    920a:	b0 13 e2 7b 	calla	#31714		;0x07be2

0000920e <.L424>:
    elyCmdSendReply(buffer);
    920e:	cc 08       	mova	r8,	r12	;
    9210:	b0 13 f8 80 	calla	#33016		;0x080f8

00009214 <.L413>:
}
    9214:	a1 00 06 00 	adda	#6,	r1	;
    9218:	64 16       	popm.a	#7,	r10	;20-bit words
    921a:	10 01       	reta			;

0000921c <.L421>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    921c:	64 42       	mov.b	#4,	r4	;r2 As==10
    921e:	80 00 b2 91 	mova	#37298,	r0	;0x091b2

00009222 <.L418>:
      elyErrorSignal(ErrCmdFailure);
    9222:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9226:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000922a <.L420>:
    elyNLFreeBuffer(elyNLPack(buffer));
    922a:	cc 08       	mova	r8,	r12	;
    922c:	b0 13 78 be 	calla	#48760		;0x0be78

00009230 <.LVL550>:
    9230:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009234 <.LVL551>:
    9234:	80 00 14 92 	mova	#37396,	r0	;0x09214

00009238 <.L416>:
  bank0w[RegUARTBaudMsb] = buffer[hdr_ext];
    9238:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    923c:	ec 44 25 00 	mov.b	@r4,	37(r12)	; 0x0025

00009240 <.Loc.799.2>:
  bank0w[RegUARTBaudHmb] = buffer[hdr_ext+1];
    9240:	dc 44 01 00 	mov.b	1(r4),	36(r12)	; 0x0024
    9244:	24 00 

00009246 <.Loc.800.2>:
  bank0w[RegUARTBaudLmb] = buffer[hdr_ext+2];
    9246:	dc 44 02 00 	mov.b	2(r4),	35(r12)	; 0x0023
    924a:	23 00 

0000924c <.Loc.801.2>:
  bank0w[RegUARTBaudLsb] = buffer[hdr_ext+3];
    924c:	dc 44 03 00 	mov.b	3(r4),	34(r12)	; 0x0022
    9250:	22 00 

00009252 <.Loc.804.2>:
  elyUARTCfgMarkDirty();
    9252:	b0 13 9c 78 	calla	#30876		;0x0789c

00009256 <.LVL553>:
  if (hdr.reply) {
    9256:	07 93       	cmp	#0,	r7	;r3 As==00
    9258:	e8 27       	jz	$-46     	;abs 0x922a

0000925a <.Loc.808.2>:
    gen_success(buffer, hdr.crc);
    925a:	4d 45       	mov.b	r5,	r13	;
    925c:	cc 08       	mova	r8,	r12	;
    925e:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009262 <.LVL554>:
    9262:	80 00 0e 92 	mova	#37390,	r0	;0x0920e

00009266 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9266:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009268 <.LCFI62>:
    9268:	08 14       	pushm.a	#1,	r8	;20-bit words

0000926a <.LCFI63>:
    926a:	b1 00 02 00 	suba	#2,	r1	;

0000926e <.LCFI64>:
    926e:	ca 0c       	mova	r12,	r10	;

00009270 <.Loc.748.2>:
    9270:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9274:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9278:	01 00 

0000927a <.Loc.750.2>:
  if (hdr.reply) {
    927a:	6d 41       	mov.b	@r1,	r13	;
    927c:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9280:	32 24       	jz	$+102    	;abs 0x92e6

00009282 <.Loc.751.2>:
    buffer[0] = buffer[0] & 0x3F;
    9282:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9286:	00 00 

00009288 <.Loc.752.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9288:	2c 01 40 08 	mova	&67648,	r12	;0x10840

0000928c <.LVL556>:
    928c:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9290:	02 00 

00009292 <.Loc.753.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9292:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9296:	03 00 

00009298 <.LVL557>:
    9298:	ce 0c       	mova	r12,	r14	;
    929a:	ae 00 25 00 	adda	#37,	r14	;0x00025
    929e:	c8 0a       	mova	r10,	r8	;
    92a0:	a8 00 04 00 	adda	#4,	r8	;
    92a4:	ac 00 21 00 	adda	#33,	r12	;0x00021

000092a8 <.L427>:
      buffer[i + 4] = bank0p[RegUARTBaudMsb - i];
    92a8:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

000092ac <.LVL559>:
    92ac:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    92b0:	a8 00 01 00 	adda	#1,	r8	;

000092b4 <.LVL560>:
    for (int i = 0; i < 4; i++) {
    92b4:	de 0c       	cmpa	r12,	r14	;
    92b6:	f8 23       	jnz	$-14     	;abs 0x92a8

000092b8 <.LBE99>:
    if (hdr.crc) {
    92b8:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    92bc:	10 24       	jz	$+34     	;abs 0x92de

000092be <.Loc.759.2>:
      buffer[1] = 6;
    92be:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    92c2:	01 00 

000092c4 <.Loc.760.2>:
      crcGenX25(buffer, 10);
    92c4:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    92c8:	cc 0a       	mova	r10,	r12	;
    92ca:	b0 13 50 ab 	calla	#43856		;0x0ab50

000092ce <.L429>:
    elyCmdSendReply(buffer);
    92ce:	cc 0a       	mova	r10,	r12	;
    92d0:	b0 13 f8 80 	calla	#33016		;0x080f8

000092d4 <.L425>:
}
    92d4:	a1 00 02 00 	adda	#2,	r1	;
    92d8:	08 16       	popm.a	#1,	r8	;20-bit words
    92da:	0a 16       	popm.a	#1,	r10	;20-bit words
    92dc:	10 01       	reta			;

000092de <.L428>:
      buffer[1] = 4;
    92de:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    92e2:	80 00 ce 92 	mova	#37582,	r0	;0x092ce

000092e6 <.L426>:
    92e6:	b0 13 2c 7d 	calla	#32044		;0x07d2c

000092ea <.LVL565>:
}
    92ea:	80 00 d4 92 	mova	#37588,	r0	;0x092d4

000092ee <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    92ee:	2a 14       	pushm.a	#3,	r10	;20-bit words

000092f0 <.LCFI65>:
    92f0:	b1 00 02 00 	suba	#2,	r1	;

000092f4 <.LCFI66>:
    92f4:	ca 0c       	mova	r12,	r10	;

000092f6 <.LVL567>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    92f6:	68 4d       	mov.b	@r13,	r8	;
    92f8:	58 f3       	and.b	#1,	r8	;r3 As==01
    92fa:	69 4d       	mov.b	@r13,	r9	;
    92fc:	69 f3       	and.b	#2,	r9	;r3 As==10
    92fe:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9302:	09 93       	cmp	#0,	r9	;r3 As==00
    9304:	15 20       	jnz	$+44     	;abs 0x9330
    9306:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009308 <.L433>:
  if ((int8_t)(buffer[hdr_ext]) > TX_POW_MAX) {
    9308:	40 18 0c 4c 	movx.w	r12,	r12	;
    930c:	ec 0a       	adda	r10,	r12	;

0000930e <.LVL569>:
    930e:	6d 4c       	mov.b	@r12,	r13	;

00009310 <.LVL570>:
    9310:	4c 43       	clr.b	r12		;
    9312:	4c 9d       	cmp.b	r13,	r12	;
    9314:	1b 34       	jge	$+56     	;abs 0x934c

00009316 <.Loc.718.2>:
    if (hdr.reply) {
    9316:	09 93       	cmp	#0,	r9	;r3 As==00
    9318:	0e 24       	jz	$+30     	;abs 0x9336

0000931a <.Loc.720.2>:
      gen_failure(buffer, hdr.crc);
    931a:	4d 48       	mov.b	r8,	r13	;
    931c:	cc 0a       	mova	r10,	r12	;
    931e:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009322 <.L439>:
    elyCmdSendReply(buffer);
    9322:	cc 0a       	mova	r10,	r12	;
    9324:	b0 13 f8 80 	calla	#33016		;0x080f8

00009328 <.L432>:
}
    9328:	a1 00 02 00 	adda	#2,	r1	;
    932c:	28 16       	popm.a	#3,	r10	;20-bit words
    932e:	10 01       	reta			;

00009330 <.L438>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9330:	6c 42       	mov.b	#4,	r12	;r2 As==10
    9332:	80 00 08 93 	mova	#37640,	r0	;0x09308

00009336 <.L435>:
      elyErrorSignal(ErrCmdFailure);
    9336:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    933a:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000933e <.L437>:
    elyNLFreeBuffer(elyNLPack(buffer));
    933e:	cc 0a       	mova	r10,	r12	;
    9340:	b0 13 78 be 	calla	#48760		;0x0be78

00009344 <.LVL576>:
    9344:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009348 <.LVL577>:
    9348:	80 00 28 93 	mova	#37672,	r0	;0x09328

0000934c <.L434>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    934c:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    9350:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

00009354 <.Loc.734.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    9354:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    9358:	4d 43       	clr.b	r13		;
    935a:	b0 13 3c ad 	calla	#44348		;0x0ad3c

0000935e <.LVL578>:
  if (hdr.reply) {
    935e:	09 93       	cmp	#0,	r9	;r3 As==00
    9360:	ee 27       	jz	$-34     	;abs 0x933e

00009362 <.Loc.738.2>:
    gen_success(buffer, hdr.crc);
    9362:	4d 48       	mov.b	r8,	r13	;
    9364:	cc 0a       	mova	r10,	r12	;
    9366:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000936a <.LVL579>:
    936a:	80 00 22 93 	mova	#37666,	r0	;0x09322

0000936e <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    936e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009370 <.LCFI67>:
    9370:	b1 00 02 00 	suba	#2,	r1	;

00009374 <.LCFI68>:
    9374:	ca 0c       	mova	r12,	r10	;

00009376 <.Loc.691.2>:
    9376:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    937a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    937e:	01 00 

00009380 <.Loc.693.2>:
  if (hdr.reply) {
    9380:	6d 41       	mov.b	@r1,	r13	;
    9382:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9386:	23 24       	jz	$+72     	;abs 0x93ce

00009388 <.Loc.694.2>:
    buffer[0] = buffer[0] & 0x3F;
    9388:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    938c:	00 00 

0000938e <.Loc.695.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    938e:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    9392:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    9396:	02 00 

00009398 <.Loc.696.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9398:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    939c:	03 00 

0000939e <.Loc.697.2>:
    buffer[4] = bank0p[RegOutputPower];
    939e:	dc 4e 21 00 	mov.b	33(r14),4(r12)	;0x00021
    93a2:	04 00 

000093a4 <.Loc.698.2>:
    if (hdr.crc) {
    93a4:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    93a8:	0e 24       	jz	$+30     	;abs 0x93c6

000093aa <.Loc.699.2>:
      buffer[1] = 3;
    93aa:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    93ae:	01 00 

000093b0 <.Loc.700.2>:
      crcGenX25(buffer, 7);
    93b0:	7d 40 07 00 	mov.b	#7,	r13	;
    93b4:	b0 13 50 ab 	calla	#43856		;0x0ab50

000093b8 <.L443>:
    elyCmdSendReply(buffer);
    93b8:	cc 0a       	mova	r10,	r12	;
    93ba:	b0 13 f8 80 	calla	#33016		;0x080f8

000093be <.L440>:
}
    93be:	a1 00 02 00 	adda	#2,	r1	;
    93c2:	0a 16       	popm.a	#1,	r10	;20-bit words
    93c4:	10 01       	reta			;

000093c6 <.L442>:
      buffer[1] = 1;
    93c6:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    93ca:	80 00 b8 93 	mova	#37816,	r0	;0x093b8

000093ce <.L441>:
    93ce:	b0 13 2c 7d 	calla	#32044		;0x07d2c

000093d2 <.LVL583>:
}
    93d2:	80 00 be 93 	mova	#37822,	r0	;0x093be

000093d6 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    93d6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000093d8 <.LCFI69>:
    93d8:	b1 00 06 00 	suba	#6,	r1	;

000093dc <.LCFI70>:
    93dc:	c8 0c       	mova	r12,	r8	;

000093de <.LVL585>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    93de:	65 4d       	mov.b	@r13,	r5	;
    93e0:	55 f3       	and.b	#1,	r5	;r3 As==01
    93e2:	67 4d       	mov.b	@r13,	r7	;
    93e4:	67 f3       	and.b	#2,	r7	;r3 As==10
    93e6:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    93ea:	07 93       	cmp	#0,	r7	;r3 As==00
    93ec:	36 20       	jnz	$+110    	;abs 0x945a
    93ee:	64 43       	mov.b	#2,	r4	;r3 As==10

000093f0 <.L446>:
    93f0:	40 18 04 44 	movx.w	r4,	r4	;
    93f4:	e4 08       	adda	r8,	r4	;
    93f6:	cb 04       	mova	r4,	r11	;

000093f8 <.Loc.648.2>:
    93f8:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

000093fc <.Loc.649.2>:
  uint32_t dev = 0;
    93fc:	49 43       	clr.b	r9		;
    93fe:	0a 49       	mov	r9,	r10	;

00009400 <.L447>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9400:	6c 4b       	mov.b	@r11,	r12	;
    9402:	0d 43       	clr	r13		;
    9404:	0e 46       	mov	r6,	r14	;
    9406:	0f 43       	clr	r15		;
    9408:	71 0b 00 00 	mova	r11,	0(r1)	;
    940c:	b0 13 36 cc 	calla	#52278		;0x0cc36
    9410:	0c d9       	bis	r9,	r12	;
    9412:	0d da       	bis	r10,	r13	;
    9414:	09 4c       	mov	r12,	r9	;

00009416 <.LVL589>:
    9416:	0a 4d       	mov	r13,	r10	;

00009418 <.LVL590>:
    9418:	0b 01       	mova	@r1,	r11	;
    941a:	ab 00 01 00 	adda	#1,	r11	;
    941e:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009422 <.Loc.652.2>:
  for (int i = 0; i < 4; i++) {
    9422:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9426:	ec 23       	jnz	$-38     	;abs 0x9400

00009428 <.LBE100>:
  if (dev > RX_DEV_MAX || 
    9428:	39 50 18 7f 	add	#32536,	r9	;#0x7f18

0000942c <.LVL591>:
    942c:	3a 63       	addc	#-1,	r10	;r3 As==11

0000942e <.LVL592>:
    942e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009430 <.LVL593>:
    9430:	0c 9a       	cmp	r10,	r12	;
    9432:	06 28       	jnc	$+14     	;abs 0x9440
    9434:	0a 9c       	cmp	r12,	r10	;
    9436:	1f 20       	jnz	$+64     	;abs 0x9476
    9438:	3c 40 58 8c 	mov	#-29608,r12	;#0x8c58
    943c:	0c 99       	cmp	r9,	r12	;
    943e:	1b 2c       	jc	$+56     	;abs 0x9476

00009440 <.L454>:
    if (hdr.reply) {
    9440:	07 93       	cmp	#0,	r7	;r3 As==00
    9442:	0e 24       	jz	$+30     	;abs 0x9460

00009444 <.Loc.660.2>:
      gen_failure(buffer, hdr.crc);
    9444:	4d 45       	mov.b	r5,	r13	;
    9446:	cc 08       	mova	r8,	r12	;
    9448:	b0 13 e2 7b 	calla	#31714		;0x07be2

0000944c <.L456>:
    elyCmdSendReply(buffer);
    944c:	cc 08       	mova	r8,	r12	;
    944e:	b0 13 f8 80 	calla	#33016		;0x080f8

00009452 <.L445>:
}
    9452:	a1 00 06 00 	adda	#6,	r1	;
    9456:	64 16       	popm.a	#7,	r10	;20-bit words
    9458:	10 01       	reta			;

0000945a <.L453>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    945a:	64 42       	mov.b	#4,	r4	;r2 As==10
    945c:	80 00 f0 93 	mova	#37872,	r0	;0x093f0

00009460 <.L450>:
      elyErrorSignal(ErrCmdFailure);
    9460:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9464:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009468 <.L452>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9468:	cc 08       	mova	r8,	r12	;
    946a:	b0 13 78 be 	calla	#48760		;0x0be78

0000946e <.LVL600>:
    946e:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009472 <.LVL601>:
    9472:	80 00 52 94 	mova	#37970,	r0	;0x09452

00009476 <.L448>:
  bank0w[RegRXDevMsb] = buffer[hdr_ext];
    9476:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    947a:	ec 44 0f 00 	mov.b	@r4,	15(r12)	; 0x000f

0000947e <.Loc.672.2>:
  bank0w[RegRXDevHmb] = buffer[hdr_ext+1];
    947e:	dc 44 01 00 	mov.b	1(r4),	14(r12)	; 0x000e
    9482:	0e 00 

00009484 <.Loc.673.2>:
  bank0w[RegRXDevLmb] = buffer[hdr_ext+2];
    9484:	dc 44 02 00 	mov.b	2(r4),	13(r12)	; 0x000d
    9488:	0d 00 

0000948a <.Loc.674.2>:
  bank0w[RegRXDevLsb] = buffer[hdr_ext+3];
    948a:	dc 44 03 00 	mov.b	3(r4),	12(r12)	; 0x000c
    948e:	0c 00 

00009490 <.Loc.677.2>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    9490:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    9494:	4d 43       	clr.b	r13		;
    9496:	b0 13 3c ad 	calla	#44348		;0x0ad3c

0000949a <.LVL604>:
  if (hdr.reply) {
    949a:	07 93       	cmp	#0,	r7	;r3 As==00
    949c:	e5 27       	jz	$-52     	;abs 0x9468

0000949e <.Loc.681.2>:
    gen_success(buffer, hdr.crc);
    949e:	4d 45       	mov.b	r5,	r13	;
    94a0:	cc 08       	mova	r8,	r12	;
    94a2:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000094a6 <.LVL605>:
    94a6:	80 00 4c 94 	mova	#37964,	r0	;0x0944c

000094aa <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    94aa:	0a 14       	pushm.a	#1,	r10	;20-bit words

000094ac <.LCFI71>:
    94ac:	08 14       	pushm.a	#1,	r8	;20-bit words

000094ae <.LCFI72>:
    94ae:	b1 00 02 00 	suba	#2,	r1	;

000094b2 <.LCFI73>:
    94b2:	ca 0c       	mova	r12,	r10	;

000094b4 <.Loc.621.2>:
    94b4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    94b8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    94bc:	01 00 

000094be <.Loc.623.2>:
  if (hdr.reply) {
    94be:	6d 41       	mov.b	@r1,	r13	;
    94c0:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    94c4:	32 24       	jz	$+102    	;abs 0x952a

000094c6 <.Loc.624.2>:
    buffer[0] = buffer[0] & 0x3F;
    94c6:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    94ca:	00 00 

000094cc <.Loc.625.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    94cc:	2c 01 40 08 	mova	&67648,	r12	;0x10840

000094d0 <.LVL607>:
    94d0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    94d4:	02 00 

000094d6 <.Loc.626.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    94d6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    94da:	03 00 

000094dc <.LVL608>:
    94dc:	ce 0c       	mova	r12,	r14	;
    94de:	ae 00 0f 00 	adda	#15,	r14	;0x0000f
    94e2:	c8 0a       	mova	r10,	r8	;
    94e4:	a8 00 04 00 	adda	#4,	r8	;
    94e8:	ac 00 0b 00 	adda	#11,	r12	;0x0000b

000094ec <.L459>:
      buffer[i + 4] = bank0p[RegRXDevMsb - i];
    94ec:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

000094f0 <.LVL610>:
    94f0:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    94f4:	a8 00 01 00 	adda	#1,	r8	;

000094f8 <.LVL611>:
    for (int i = 0; i < 4; i++) {
    94f8:	de 0c       	cmpa	r12,	r14	;
    94fa:	f8 23       	jnz	$-14     	;abs 0x94ec

000094fc <.LBE101>:
    if (hdr.crc) {
    94fc:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9500:	10 24       	jz	$+34     	;abs 0x9522

00009502 <.Loc.632.2>:
      buffer[1] = 6;
    9502:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9506:	01 00 

00009508 <.Loc.633.2>:
      crcGenX25(buffer, 10);
    9508:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    950c:	cc 0a       	mova	r10,	r12	;
    950e:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009512 <.L461>:
    elyCmdSendReply(buffer);
    9512:	cc 0a       	mova	r10,	r12	;
    9514:	b0 13 f8 80 	calla	#33016		;0x080f8

00009518 <.L457>:
}
    9518:	a1 00 02 00 	adda	#2,	r1	;
    951c:	08 16       	popm.a	#1,	r8	;20-bit words
    951e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9520:	10 01       	reta			;

00009522 <.L460>:
      buffer[1] = 4;
    9522:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9526:	80 00 12 95 	mova	#38162,	r0	;0x09512

0000952a <.L458>:
    952a:	b0 13 2c 7d 	calla	#32044		;0x07d2c

0000952e <.LVL616>:
}
    952e:	80 00 18 95 	mova	#38168,	r0	;0x09518

00009532 <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9532:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009534 <.LCFI74>:
    9534:	b1 00 06 00 	suba	#6,	r1	;

00009538 <.LCFI75>:
    9538:	c8 0c       	mova	r12,	r8	;

0000953a <.LVL618>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    953a:	65 4d       	mov.b	@r13,	r5	;
    953c:	55 f3       	and.b	#1,	r5	;r3 As==01
    953e:	67 4d       	mov.b	@r13,	r7	;
    9540:	67 f3       	and.b	#2,	r7	;r3 As==10
    9542:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9546:	07 93       	cmp	#0,	r7	;r3 As==00
    9548:	37 20       	jnz	$+112    	;abs 0x95b8
    954a:	64 43       	mov.b	#2,	r4	;r3 As==10

0000954c <.L465>:
    954c:	40 18 04 44 	movx.w	r4,	r4	;
    9550:	e4 08       	adda	r8,	r4	;
    9552:	cb 04       	mova	r4,	r11	;

00009554 <.Loc.578.2>:
    9554:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009558 <.Loc.579.2>:
  uint32_t dev = 0;
    9558:	49 43       	clr.b	r9		;
    955a:	0a 49       	mov	r9,	r10	;

0000955c <.L466>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    955c:	6c 4b       	mov.b	@r11,	r12	;
    955e:	0d 43       	clr	r13		;
    9560:	0e 46       	mov	r6,	r14	;
    9562:	0f 43       	clr	r15		;
    9564:	71 0b 00 00 	mova	r11,	0(r1)	;
    9568:	b0 13 36 cc 	calla	#52278		;0x0cc36
    956c:	0c d9       	bis	r9,	r12	;
    956e:	0d da       	bis	r10,	r13	;
    9570:	09 4c       	mov	r12,	r9	;

00009572 <.LVL622>:
    9572:	0a 4d       	mov	r13,	r10	;

00009574 <.LVL623>:
    9574:	0b 01       	mova	@r1,	r11	;
    9576:	ab 00 01 00 	adda	#1,	r11	;
    957a:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

0000957e <.Loc.582.2>:
  for (int i = 0; i < 4; i++) {
    957e:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9582:	ec 23       	jnz	$-38     	;abs 0x955c

00009584 <.LBE102>:
  if (dev > TX_DEV_MAX || 
    9584:	39 50 a8 fd 	add	#-600,	r9	;#0xfda8

00009588 <.LVL624>:
    9588:	3a 63       	addc	#-1,	r10	;r3 As==11

0000958a <.LVL625>:
    958a:	7c 40 03 00 	mov.b	#3,	r12	;

0000958e <.LVL626>:
    958e:	0c 9a       	cmp	r10,	r12	;
    9590:	06 28       	jnc	$+14     	;abs 0x959e
    9592:	0a 9c       	cmp	r12,	r10	;
    9594:	1f 20       	jnz	$+64     	;abs 0x95d4
    9596:	3c 40 e8 0a 	mov	#2792,	r12	;#0x0ae8
    959a:	0c 99       	cmp	r9,	r12	;
    959c:	1b 2c       	jc	$+56     	;abs 0x95d4

0000959e <.L473>:
    if (hdr.reply) {
    959e:	07 93       	cmp	#0,	r7	;r3 As==00
    95a0:	0e 24       	jz	$+30     	;abs 0x95be

000095a2 <.Loc.590.2>:
      gen_failure(buffer, hdr.crc);
    95a2:	4d 45       	mov.b	r5,	r13	;
    95a4:	cc 08       	mova	r8,	r12	;
    95a6:	b0 13 e2 7b 	calla	#31714		;0x07be2

000095aa <.L475>:
    elyCmdSendReply(buffer);
    95aa:	cc 08       	mova	r8,	r12	;
    95ac:	b0 13 f8 80 	calla	#33016		;0x080f8

000095b0 <.L464>:
}
    95b0:	a1 00 06 00 	adda	#6,	r1	;
    95b4:	64 16       	popm.a	#7,	r10	;20-bit words
    95b6:	10 01       	reta			;

000095b8 <.L472>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    95b8:	64 42       	mov.b	#4,	r4	;r2 As==10
    95ba:	80 00 4c 95 	mova	#38220,	r0	;0x0954c

000095be <.L469>:
      elyErrorSignal(ErrCmdFailure);
    95be:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    95c2:	b0 13 32 bf 	calla	#48946		;0x0bf32

000095c6 <.L471>:
    elyNLFreeBuffer(elyNLPack(buffer));
    95c6:	cc 08       	mova	r8,	r12	;
    95c8:	b0 13 78 be 	calla	#48760		;0x0be78

000095cc <.LVL633>:
    95cc:	b0 13 24 bd 	calla	#48420		;0x0bd24

000095d0 <.LVL634>:
    95d0:	80 00 b0 95 	mova	#38320,	r0	;0x095b0

000095d4 <.L467>:
  bank0w[RegTXDevMsb] = buffer[hdr_ext];
    95d4:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    95d8:	ec 44 0b 00 	mov.b	@r4,	11(r12)	; 0x000b

000095dc <.Loc.602.2>:
  bank0w[RegTXDevHmb] = buffer[hdr_ext+1];
    95dc:	dc 44 01 00 	mov.b	1(r4),	10(r12)	; 0x000a
    95e0:	0a 00 

000095e2 <.Loc.603.2>:
  bank0w[RegTXDevLmb] = buffer[hdr_ext+2];
    95e2:	dc 44 02 00 	mov.b	2(r4),	9(r12)	;
    95e6:	09 00 

000095e8 <.Loc.604.2>:
  bank0w[RegTXDevLsb] = buffer[hdr_ext+3];
    95e8:	dc 44 03 00 	mov.b	3(r4),	8(r12)	;
    95ec:	08 00 

000095ee <.Loc.607.2>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    95ee:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    95f2:	4d 43       	clr.b	r13		;
    95f4:	b0 13 3c ad 	calla	#44348		;0x0ad3c

000095f8 <.LVL637>:
  if (hdr.reply) {
    95f8:	07 93       	cmp	#0,	r7	;r3 As==00
    95fa:	e5 27       	jz	$-52     	;abs 0x95c6

000095fc <.Loc.611.2>:
    gen_success(buffer, hdr.crc);
    95fc:	4d 45       	mov.b	r5,	r13	;
    95fe:	cc 08       	mova	r8,	r12	;
    9600:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009604 <.LVL638>:
    9604:	80 00 aa 95 	mova	#38314,	r0	;0x095aa

00009608 <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9608:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000960a <.LCFI76>:
    960a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000960c <.LCFI77>:
    960c:	b1 00 02 00 	suba	#2,	r1	;

00009610 <.LCFI78>:
    9610:	ca 0c       	mova	r12,	r10	;

00009612 <.Loc.551.2>:
    9612:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9616:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    961a:	01 00 

0000961c <.Loc.553.2>:
  if (hdr.reply) {
    961c:	6d 41       	mov.b	@r1,	r13	;
    961e:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9622:	32 24       	jz	$+102    	;abs 0x9688

00009624 <.Loc.554.2>:
    buffer[0] = buffer[0] & 0x3F;
    9624:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9628:	00 00 

0000962a <.Loc.555.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    962a:	2c 01 40 08 	mova	&67648,	r12	;0x10840

0000962e <.LVL640>:
    962e:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9632:	02 00 

00009634 <.Loc.556.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9634:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9638:	03 00 

0000963a <.LVL641>:
    963a:	ce 0c       	mova	r12,	r14	;
    963c:	ae 00 0b 00 	adda	#11,	r14	;0x0000b
    9640:	c8 0a       	mova	r10,	r8	;
    9642:	a8 00 04 00 	adda	#4,	r8	;
    9646:	ac 00 07 00 	adda	#7,	r12	;

0000964a <.L478>:
      buffer[i + 4] = bank0p[RegTXDevMsb - i];
    964a:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

0000964e <.LVL643>:
    964e:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9652:	a8 00 01 00 	adda	#1,	r8	;

00009656 <.LVL644>:
    for (int i = 0; i < 4; i++) {
    9656:	de 0c       	cmpa	r12,	r14	;
    9658:	f8 23       	jnz	$-14     	;abs 0x964a

0000965a <.LBE103>:
    if (hdr.crc) {
    965a:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    965e:	10 24       	jz	$+34     	;abs 0x9680

00009660 <.Loc.562.2>:
      buffer[1] = 6;
    9660:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9664:	01 00 

00009666 <.Loc.563.2>:
      crcGenX25(buffer, 10);
    9666:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    966a:	cc 0a       	mova	r10,	r12	;
    966c:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009670 <.L480>:
    elyCmdSendReply(buffer);
    9670:	cc 0a       	mova	r10,	r12	;
    9672:	b0 13 f8 80 	calla	#33016		;0x080f8

00009676 <.L476>:
}
    9676:	a1 00 02 00 	adda	#2,	r1	;
    967a:	08 16       	popm.a	#1,	r8	;20-bit words
    967c:	0a 16       	popm.a	#1,	r10	;20-bit words
    967e:	10 01       	reta			;

00009680 <.L479>:
      buffer[1] = 4;
    9680:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9684:	80 00 70 96 	mova	#38512,	r0	;0x09670

00009688 <.L477>:
    9688:	b0 13 2c 7d 	calla	#32044		;0x07d2c

0000968c <.LVL649>:
}
    968c:	80 00 76 96 	mova	#38518,	r0	;0x09676

00009690 <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9690:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009692 <.LCFI79>:
    9692:	b1 00 06 00 	suba	#6,	r1	;

00009696 <.LCFI80>:
    9696:	c8 0c       	mova	r12,	r8	;

00009698 <.LVL651>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9698:	65 4d       	mov.b	@r13,	r5	;
    969a:	55 f3       	and.b	#1,	r5	;r3 As==01
    969c:	67 4d       	mov.b	@r13,	r7	;
    969e:	67 f3       	and.b	#2,	r7	;r3 As==10
    96a0:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    96a4:	07 93       	cmp	#0,	r7	;r3 As==00
    96a6:	36 20       	jnz	$+110    	;abs 0x9714
    96a8:	64 43       	mov.b	#2,	r4	;r3 As==10

000096aa <.L484>:
    96aa:	40 18 04 44 	movx.w	r4,	r4	;
    96ae:	e4 08       	adda	r8,	r4	;
    96b0:	cb 04       	mova	r4,	r11	;

000096b2 <.Loc.508.2>:
    96b2:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

000096b6 <.Loc.509.2>:
  uint32_t br = 0;
    96b6:	49 43       	clr.b	r9		;
    96b8:	0a 49       	mov	r9,	r10	;

000096ba <.L485>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    96ba:	6c 4b       	mov.b	@r11,	r12	;
    96bc:	0d 43       	clr	r13		;
    96be:	0e 46       	mov	r6,	r14	;
    96c0:	0f 43       	clr	r15		;
    96c2:	71 0b 00 00 	mova	r11,	0(r1)	;
    96c6:	b0 13 36 cc 	calla	#52278		;0x0cc36
    96ca:	0c d9       	bis	r9,	r12	;
    96cc:	0d da       	bis	r10,	r13	;
    96ce:	09 4c       	mov	r12,	r9	;

000096d0 <.LVL655>:
    96d0:	0a 4d       	mov	r13,	r10	;

000096d2 <.LVL656>:
    96d2:	0b 01       	mova	@r1,	r11	;
    96d4:	ab 00 01 00 	adda	#1,	r11	;
    96d8:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

000096dc <.Loc.512.2>:
  for (int i = 0; i < 4; i++) {
    96dc:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    96e0:	ec 23       	jnz	$-38     	;abs 0x96ba

000096e2 <.LBE104>:
  if (br > RX_BR_MAX || 
    96e2:	39 50 f4 fc 	add	#-780,	r9	;#0xfcf4

000096e6 <.LVL657>:
    96e6:	3a 63       	addc	#-1,	r10	;r3 As==11

000096e8 <.LVL658>:
    96e8:	6c 43       	mov.b	#2,	r12	;r3 As==10

000096ea <.LVL659>:
    96ea:	0c 9a       	cmp	r10,	r12	;
    96ec:	06 28       	jnc	$+14     	;abs 0x96fa
    96ee:	0a 9c       	cmp	r12,	r10	;
    96f0:	1f 20       	jnz	$+64     	;abs 0x9730
    96f2:	3c 40 e4 46 	mov	#18148,	r12	;#0x46e4
    96f6:	0c 99       	cmp	r9,	r12	;
    96f8:	1b 2c       	jc	$+56     	;abs 0x9730

000096fa <.L492>:
    if (hdr.reply) {
    96fa:	07 93       	cmp	#0,	r7	;r3 As==00
    96fc:	0e 24       	jz	$+30     	;abs 0x971a

000096fe <.Loc.520.2>:
      gen_failure(buffer, hdr.crc);
    96fe:	4d 45       	mov.b	r5,	r13	;
    9700:	cc 08       	mova	r8,	r12	;
    9702:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009706 <.L494>:
    elyCmdSendReply(buffer);
    9706:	cc 08       	mova	r8,	r12	;
    9708:	b0 13 f8 80 	calla	#33016		;0x080f8

0000970c <.L483>:
}
    970c:	a1 00 06 00 	adda	#6,	r1	;
    9710:	64 16       	popm.a	#7,	r10	;20-bit words
    9712:	10 01       	reta			;

00009714 <.L491>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9714:	64 42       	mov.b	#4,	r4	;r2 As==10
    9716:	80 00 aa 96 	mova	#38570,	r0	;0x096aa

0000971a <.L488>:
      elyErrorSignal(ErrCmdFailure);
    971a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    971e:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009722 <.L490>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9722:	cc 08       	mova	r8,	r12	;
    9724:	b0 13 78 be 	calla	#48760		;0x0be78

00009728 <.LVL666>:
    9728:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000972c <.LVL667>:
    972c:	80 00 0c 97 	mova	#38668,	r0	;0x0970c

00009730 <.L486>:
  bank0w[RegRXBRMsb] = buffer[hdr_ext];
    9730:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    9734:	ec 44 1f 00 	mov.b	@r4,	31(r12)	; 0x001f

00009738 <.Loc.532.2>:
  bank0w[RegRXBRHmb] = buffer[hdr_ext+1];
    9738:	dc 44 01 00 	mov.b	1(r4),	30(r12)	; 0x001e
    973c:	1e 00 

0000973e <.Loc.533.2>:
  bank0w[RegRXBRLmb] = buffer[hdr_ext+2];
    973e:	dc 44 02 00 	mov.b	2(r4),	29(r12)	; 0x001d
    9742:	1d 00 

00009744 <.Loc.534.2>:
  bank0w[RegRXBRLsb] = buffer[hdr_ext+3];
    9744:	dc 44 03 00 	mov.b	3(r4),	28(r12)	; 0x001c
    9748:	1c 00 

0000974a <.Loc.537.2>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    974a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    974c:	4d 43       	clr.b	r13		;
    974e:	b0 13 3c ad 	calla	#44348		;0x0ad3c

00009752 <.LVL670>:
  if (hdr.reply) {
    9752:	07 93       	cmp	#0,	r7	;r3 As==00
    9754:	e6 27       	jz	$-50     	;abs 0x9722

00009756 <.Loc.541.2>:
    gen_success(buffer, hdr.crc);
    9756:	4d 45       	mov.b	r5,	r13	;
    9758:	cc 08       	mova	r8,	r12	;
    975a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000975e <.LVL671>:
    975e:	80 00 06 97 	mova	#38662,	r0	;0x09706

00009762 <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9762:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009764 <.LCFI81>:
    9764:	08 14       	pushm.a	#1,	r8	;20-bit words

00009766 <.LCFI82>:
    9766:	b1 00 02 00 	suba	#2,	r1	;

0000976a <.LCFI83>:
    976a:	ca 0c       	mova	r12,	r10	;

0000976c <.Loc.481.2>:
    976c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9770:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9774:	01 00 

00009776 <.Loc.483.2>:
  if (hdr.reply) {
    9776:	6d 41       	mov.b	@r1,	r13	;
    9778:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    977c:	32 24       	jz	$+102    	;abs 0x97e2

0000977e <.Loc.484.2>:
    buffer[0] = buffer[0] & 0x3F;
    977e:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9782:	00 00 

00009784 <.Loc.485.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9784:	2c 01 40 08 	mova	&67648,	r12	;0x10840

00009788 <.LVL673>:
    9788:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    978c:	02 00 

0000978e <.Loc.486.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    978e:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9792:	03 00 

00009794 <.LVL674>:
    9794:	ce 0c       	mova	r12,	r14	;
    9796:	ae 00 1f 00 	adda	#31,	r14	;0x0001f
    979a:	c8 0a       	mova	r10,	r8	;
    979c:	a8 00 04 00 	adda	#4,	r8	;
    97a0:	ac 00 1b 00 	adda	#27,	r12	;0x0001b

000097a4 <.L497>:
      buffer[i + 4] = bank0p[RegRXBRMsb - i];
    97a4:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

000097a8 <.LVL676>:
    97a8:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    97ac:	a8 00 01 00 	adda	#1,	r8	;

000097b0 <.LVL677>:
    for (int i = 0; i < 4; i++) {
    97b0:	de 0c       	cmpa	r12,	r14	;
    97b2:	f8 23       	jnz	$-14     	;abs 0x97a4

000097b4 <.LBE105>:
    if (hdr.crc) {
    97b4:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    97b8:	10 24       	jz	$+34     	;abs 0x97da

000097ba <.Loc.492.2>:
      buffer[1] = 6;
    97ba:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    97be:	01 00 

000097c0 <.Loc.493.2>:
      crcGenX25(buffer, 10);
    97c0:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    97c4:	cc 0a       	mova	r10,	r12	;
    97c6:	b0 13 50 ab 	calla	#43856		;0x0ab50

000097ca <.L499>:
    elyCmdSendReply(buffer);
    97ca:	cc 0a       	mova	r10,	r12	;
    97cc:	b0 13 f8 80 	calla	#33016		;0x080f8

000097d0 <.L495>:
}
    97d0:	a1 00 02 00 	adda	#2,	r1	;
    97d4:	08 16       	popm.a	#1,	r8	;20-bit words
    97d6:	0a 16       	popm.a	#1,	r10	;20-bit words
    97d8:	10 01       	reta			;

000097da <.L498>:
      buffer[1] = 4;
    97da:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    97de:	80 00 ca 97 	mova	#38858,	r0	;0x097ca

000097e2 <.L496>:
    97e2:	b0 13 2c 7d 	calla	#32044		;0x07d2c

000097e6 <.LVL682>:
}
    97e6:	80 00 d0 97 	mova	#38864,	r0	;0x097d0

000097ea <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    97ea:	6a 14       	pushm.a	#7,	r10	;20-bit words

000097ec <.LCFI84>:
    97ec:	b1 00 06 00 	suba	#6,	r1	;

000097f0 <.LCFI85>:
    97f0:	c8 0c       	mova	r12,	r8	;

000097f2 <.LVL684>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    97f2:	65 4d       	mov.b	@r13,	r5	;
    97f4:	55 f3       	and.b	#1,	r5	;r3 As==01
    97f6:	67 4d       	mov.b	@r13,	r7	;
    97f8:	67 f3       	and.b	#2,	r7	;r3 As==10
    97fa:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    97fe:	07 93       	cmp	#0,	r7	;r3 As==00
    9800:	36 20       	jnz	$+110    	;abs 0x986e
    9802:	64 43       	mov.b	#2,	r4	;r3 As==10

00009804 <.L503>:
    9804:	40 18 04 44 	movx.w	r4,	r4	;
    9808:	e4 08       	adda	r8,	r4	;
    980a:	cb 04       	mova	r4,	r11	;

0000980c <.Loc.438.2>:
    980c:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009810 <.Loc.439.2>:
  uint32_t br = 0;
    9810:	49 43       	clr.b	r9		;
    9812:	0a 49       	mov	r9,	r10	;

00009814 <.L504>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9814:	6c 4b       	mov.b	@r11,	r12	;
    9816:	0d 43       	clr	r13		;
    9818:	0e 46       	mov	r6,	r14	;
    981a:	0f 43       	clr	r15		;
    981c:	71 0b 00 00 	mova	r11,	0(r1)	;
    9820:	b0 13 36 cc 	calla	#52278		;0x0cc36
    9824:	0c d9       	bis	r9,	r12	;
    9826:	0d da       	bis	r10,	r13	;
    9828:	09 4c       	mov	r12,	r9	;

0000982a <.LVL688>:
    982a:	0a 4d       	mov	r13,	r10	;

0000982c <.LVL689>:
    982c:	0b 01       	mova	@r1,	r11	;
    982e:	ab 00 01 00 	adda	#1,	r11	;
    9832:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009836 <.Loc.442.2>:
  for (int i = 0; i < 4; i++) {
    9836:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    983a:	ec 23       	jnz	$-38     	;abs 0x9814

0000983c <.LBE106>:
  if (br > TX_BR_MAX || 
    983c:	39 50 50 fb 	add	#-1200,	r9	;#0xfb50

00009840 <.LVL690>:
    9840:	3a 63       	addc	#-1,	r10	;r3 As==11

00009842 <.LVL691>:
    9842:	6c 42       	mov.b	#4,	r12	;r2 As==10

00009844 <.LVL692>:
    9844:	0c 9a       	cmp	r10,	r12	;
    9846:	06 28       	jnc	$+14     	;abs 0x9854
    9848:	0a 9c       	cmp	r12,	r10	;
    984a:	1f 20       	jnz	$+64     	;abs 0x988a
    984c:	3c 40 30 8f 	mov	#-28880,r12	;#0x8f30
    9850:	0c 99       	cmp	r9,	r12	;
    9852:	1b 2c       	jc	$+56     	;abs 0x988a

00009854 <.L511>:
    if (hdr.reply) {
    9854:	07 93       	cmp	#0,	r7	;r3 As==00
    9856:	0e 24       	jz	$+30     	;abs 0x9874

00009858 <.Loc.450.2>:
      gen_failure(buffer, hdr.crc);
    9858:	4d 45       	mov.b	r5,	r13	;
    985a:	cc 08       	mova	r8,	r12	;
    985c:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009860 <.L513>:
    elyCmdSendReply(buffer);
    9860:	cc 08       	mova	r8,	r12	;
    9862:	b0 13 f8 80 	calla	#33016		;0x080f8

00009866 <.L502>:
}
    9866:	a1 00 06 00 	adda	#6,	r1	;
    986a:	64 16       	popm.a	#7,	r10	;20-bit words
    986c:	10 01       	reta			;

0000986e <.L510>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    986e:	64 42       	mov.b	#4,	r4	;r2 As==10
    9870:	80 00 04 98 	mova	#38916,	r0	;0x09804

00009874 <.L507>:
      elyErrorSignal(ErrCmdFailure);
    9874:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9878:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000987c <.L509>:
    elyNLFreeBuffer(elyNLPack(buffer));
    987c:	cc 08       	mova	r8,	r12	;
    987e:	b0 13 78 be 	calla	#48760		;0x0be78

00009882 <.LVL699>:
    9882:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009886 <.LVL700>:
    9886:	80 00 66 98 	mova	#39014,	r0	;0x09866

0000988a <.L505>:
  bank0w[RegTXBRMsb] = buffer[hdr_ext];
    988a:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    988e:	ec 44 1b 00 	mov.b	@r4,	27(r12)	; 0x001b

00009892 <.Loc.462.2>:
  bank0w[RegTXBRHmb] = buffer[hdr_ext+1];
    9892:	dc 44 01 00 	mov.b	1(r4),	26(r12)	; 0x001a
    9896:	1a 00 

00009898 <.Loc.463.2>:
  bank0w[RegTXBRLmb] = buffer[hdr_ext+2];
    9898:	dc 44 02 00 	mov.b	2(r4),	25(r12)	; 0x0019
    989c:	19 00 

0000989e <.Loc.464.2>:
  bank0w[RegTXBRLsb] = buffer[hdr_ext+3];
    989e:	dc 44 03 00 	mov.b	3(r4),	24(r12)	; 0x0018
    98a2:	18 00 

000098a4 <.Loc.467.2>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    98a4:	6c 42       	mov.b	#4,	r12	;r2 As==10
    98a6:	4d 43       	clr.b	r13		;
    98a8:	b0 13 3c ad 	calla	#44348		;0x0ad3c

000098ac <.LVL703>:
  if (hdr.reply) {
    98ac:	07 93       	cmp	#0,	r7	;r3 As==00
    98ae:	e6 27       	jz	$-50     	;abs 0x987c

000098b0 <.Loc.471.2>:
    gen_success(buffer, hdr.crc);
    98b0:	4d 45       	mov.b	r5,	r13	;
    98b2:	cc 08       	mova	r8,	r12	;
    98b4:	b0 13 a4 7b 	calla	#31652		;0x07ba4

000098b8 <.LVL704>:
    98b8:	80 00 60 98 	mova	#39008,	r0	;0x09860

000098bc <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    98bc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000098be <.LCFI86>:
    98be:	08 14       	pushm.a	#1,	r8	;20-bit words

000098c0 <.LCFI87>:
    98c0:	b1 00 02 00 	suba	#2,	r1	;

000098c4 <.LCFI88>:
    98c4:	ca 0c       	mova	r12,	r10	;

000098c6 <.Loc.411.2>:
    98c6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    98ca:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    98ce:	01 00 

000098d0 <.Loc.413.2>:
  if (hdr.reply) {
    98d0:	6d 41       	mov.b	@r1,	r13	;
    98d2:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    98d6:	32 24       	jz	$+102    	;abs 0x993c

000098d8 <.Loc.414.2>:
    buffer[0] = buffer[0] & 0x3F;
    98d8:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    98dc:	00 00 

000098de <.Loc.415.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    98de:	2c 01 40 08 	mova	&67648,	r12	;0x10840

000098e2 <.LVL706>:
    98e2:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    98e6:	02 00 

000098e8 <.Loc.416.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    98e8:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    98ec:	03 00 

000098ee <.LVL707>:
    98ee:	ce 0c       	mova	r12,	r14	;
    98f0:	ae 00 1b 00 	adda	#27,	r14	;0x0001b
    98f4:	c8 0a       	mova	r10,	r8	;
    98f6:	a8 00 04 00 	adda	#4,	r8	;
    98fa:	ac 00 17 00 	adda	#23,	r12	;0x00017

000098fe <.L516>:
      buffer[i + 4] = bank0p[RegTXBRMsb - i];
    98fe:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

00009902 <.LVL709>:
    9902:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9906:	a8 00 01 00 	adda	#1,	r8	;

0000990a <.LVL710>:
    for (int i = 0; i < 4; i++) {
    990a:	de 0c       	cmpa	r12,	r14	;
    990c:	f8 23       	jnz	$-14     	;abs 0x98fe

0000990e <.LBE107>:
    if (hdr.crc) {
    990e:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9912:	10 24       	jz	$+34     	;abs 0x9934

00009914 <.Loc.422.2>:
      buffer[1] = 6;
    9914:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9918:	01 00 

0000991a <.Loc.423.2>:
      crcGenX25(buffer, 10);
    991a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    991e:	cc 0a       	mova	r10,	r12	;
    9920:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009924 <.L518>:
    elyCmdSendReply(buffer);
    9924:	cc 0a       	mova	r10,	r12	;
    9926:	b0 13 f8 80 	calla	#33016		;0x080f8

0000992a <.L514>:
}
    992a:	a1 00 02 00 	adda	#2,	r1	;
    992e:	08 16       	popm.a	#1,	r8	;20-bit words
    9930:	0a 16       	popm.a	#1,	r10	;20-bit words
    9932:	10 01       	reta			;

00009934 <.L517>:
      buffer[1] = 4;
    9934:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9938:	80 00 24 99 	mova	#39204,	r0	;0x09924

0000993c <.L515>:
    993c:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00009940 <.LVL715>:
}
    9940:	80 00 2a 99 	mova	#39210,	r0	;0x0992a

00009944 <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9944:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009946 <.LCFI89>:
    9946:	b1 00 06 00 	suba	#6,	r1	;

0000994a <.LCFI90>:
    994a:	c8 0c       	mova	r12,	r8	;

0000994c <.LVL717>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    994c:	65 4d       	mov.b	@r13,	r5	;
    994e:	55 f3       	and.b	#1,	r5	;r3 As==01
    9950:	67 4d       	mov.b	@r13,	r7	;
    9952:	67 f3       	and.b	#2,	r7	;r3 As==10
    9954:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9958:	07 93       	cmp	#0,	r7	;r3 As==00
    995a:	38 20       	jnz	$+114    	;abs 0x99cc
    995c:	64 43       	mov.b	#2,	r4	;r3 As==10

0000995e <.L522>:
    995e:	40 18 04 44 	movx.w	r4,	r4	;
    9962:	e4 08       	adda	r8,	r4	;
    9964:	cb 04       	mova	r4,	r11	;

00009966 <.Loc.368.2>:
    9966:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

0000996a <.Loc.369.2>:
  uint32_t freq = 0;
    996a:	49 43       	clr.b	r9		;
    996c:	0a 49       	mov	r9,	r10	;

0000996e <.L523>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    996e:	6c 4b       	mov.b	@r11,	r12	;
    9970:	0d 43       	clr	r13		;
    9972:	0e 46       	mov	r6,	r14	;
    9974:	0f 43       	clr	r15		;
    9976:	71 0b 00 00 	mova	r11,	0(r1)	;
    997a:	b0 13 36 cc 	calla	#52278		;0x0cc36
    997e:	0c d9       	bis	r9,	r12	;
    9980:	0d da       	bis	r10,	r13	;
    9982:	09 4c       	mov	r12,	r9	;

00009984 <.LVL721>:
    9984:	0a 4d       	mov	r13,	r10	;

00009986 <.LVL722>:
    9986:	0b 01       	mova	@r1,	r11	;
    9988:	ab 00 01 00 	adda	#1,	r11	;
    998c:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009990 <.Loc.372.2>:
  for (int i = 0; i < 4; i++) {
    9990:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9994:	ec 23       	jnz	$-38     	;abs 0x996e

00009996 <.LBE108>:
  if (freq > RX_BAND_MAX || 
    9996:	39 50 20 d5 	add	#-10976,r9	;#0xd520

0000999a <.LVL723>:
    999a:	3a 60 47 e6 	addc	#-6585,	r10	;#0xe647

0000999e <.LVL724>:
    999e:	7c 40 4c 00 	mov.b	#76,	r12	;#0x004c

000099a2 <.LVL725>:
    99a2:	0c 9a       	cmp	r10,	r12	;
    99a4:	06 28       	jnc	$+14     	;abs 0x99b2
    99a6:	0a 9c       	cmp	r12,	r10	;
    99a8:	1f 20       	jnz	$+64     	;abs 0x99e8
    99aa:	3c 40 40 4b 	mov	#19264,	r12	;#0x4b40
    99ae:	0c 99       	cmp	r9,	r12	;
    99b0:	1b 2c       	jc	$+56     	;abs 0x99e8

000099b2 <.L530>:
    if (hdr.reply) {
    99b2:	07 93       	cmp	#0,	r7	;r3 As==00
    99b4:	0e 24       	jz	$+30     	;abs 0x99d2

000099b6 <.Loc.380.2>:
      gen_failure(buffer, hdr.crc);
    99b6:	4d 45       	mov.b	r5,	r13	;
    99b8:	cc 08       	mova	r8,	r12	;
    99ba:	b0 13 e2 7b 	calla	#31714		;0x07be2

000099be <.L532>:
    elyCmdSendReply(buffer);
    99be:	cc 08       	mova	r8,	r12	;
    99c0:	b0 13 f8 80 	calla	#33016		;0x080f8

000099c4 <.L521>:
}
    99c4:	a1 00 06 00 	adda	#6,	r1	;
    99c8:	64 16       	popm.a	#7,	r10	;20-bit words
    99ca:	10 01       	reta			;

000099cc <.L529>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    99cc:	64 42       	mov.b	#4,	r4	;r2 As==10
    99ce:	80 00 5e 99 	mova	#39262,	r0	;0x0995e

000099d2 <.L526>:
      elyErrorSignal(ErrCmdFailure);
    99d2:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    99d6:	b0 13 32 bf 	calla	#48946		;0x0bf32

000099da <.L528>:
    elyNLFreeBuffer(elyNLPack(buffer));
    99da:	cc 08       	mova	r8,	r12	;
    99dc:	b0 13 78 be 	calla	#48760		;0x0be78

000099e0 <.LVL732>:
    99e0:	b0 13 24 bd 	calla	#48420		;0x0bd24

000099e4 <.LVL733>:
    99e4:	80 00 c4 99 	mova	#39364,	r0	;0x099c4

000099e8 <.L524>:
  bank0w[RegRXFreqMsb] = buffer[hdr_ext];
    99e8:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    99ec:	ec 44 07 00 	mov.b	@r4,	7(r12)	;

000099f0 <.Loc.392.2>:
  bank0w[RegRXFreqHmb] = buffer[hdr_ext+1];
    99f0:	dc 44 01 00 	mov.b	1(r4),	6(r12)	;
    99f4:	06 00 

000099f6 <.Loc.393.2>:
  bank0w[RegRXFreqLmb] = buffer[hdr_ext+2];
    99f6:	dc 44 02 00 	mov.b	2(r4),	5(r12)	;
    99fa:	05 00 

000099fc <.Loc.394.2>:
  bank0w[RegRXFreqLsb] = buffer[hdr_ext+3];
    99fc:	dc 44 03 00 	mov.b	3(r4),	4(r12)	;
    9a00:	04 00 

00009a02 <.Loc.397.2>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    9a02:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9a04:	4d 43       	clr.b	r13		;
    9a06:	b0 13 3c ad 	calla	#44348		;0x0ad3c

00009a0a <.LVL736>:
  if (hdr.reply) {
    9a0a:	07 93       	cmp	#0,	r7	;r3 As==00
    9a0c:	e6 27       	jz	$-50     	;abs 0x99da

00009a0e <.Loc.401.2>:
    gen_success(buffer, hdr.crc);
    9a0e:	4d 45       	mov.b	r5,	r13	;
    9a10:	cc 08       	mova	r8,	r12	;
    9a12:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009a16 <.LVL737>:
    9a16:	80 00 be 99 	mova	#39358,	r0	;0x099be

00009a1a <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9a1a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009a1c <.LCFI91>:
    9a1c:	08 14       	pushm.a	#1,	r8	;20-bit words

00009a1e <.LCFI92>:
    9a1e:	b1 00 02 00 	suba	#2,	r1	;

00009a22 <.LCFI93>:
    9a22:	ca 0c       	mova	r12,	r10	;

00009a24 <.Loc.341.2>:
    9a24:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9a28:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9a2c:	01 00 

00009a2e <.Loc.343.2>:
  if (hdr.reply) {
    9a2e:	6d 41       	mov.b	@r1,	r13	;
    9a30:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9a34:	32 24       	jz	$+102    	;abs 0x9a9a

00009a36 <.Loc.344.2>:
    buffer[0] = buffer[0] & 0x3F;
    9a36:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9a3a:	00 00 

00009a3c <.Loc.345.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9a3c:	2c 01 40 08 	mova	&67648,	r12	;0x10840

00009a40 <.LVL739>:
    9a40:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9a44:	02 00 

00009a46 <.Loc.346.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9a46:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9a4a:	03 00 

00009a4c <.LVL740>:
    9a4c:	ce 0c       	mova	r12,	r14	;
    9a4e:	ae 00 07 00 	adda	#7,	r14	;
    9a52:	c8 0a       	mova	r10,	r8	;
    9a54:	a8 00 04 00 	adda	#4,	r8	;
    9a58:	ac 00 03 00 	adda	#3,	r12	;

00009a5c <.L535>:
      buffer[i + 4] = bank0p[RegRXFreqMsb - i];
    9a5c:	e8 4e 00 00 	mov.b	@r14,	0(r8)	;

00009a60 <.LVL742>:
    9a60:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    9a64:	a8 00 01 00 	adda	#1,	r8	;

00009a68 <.LVL743>:
    for (int i = 0; i < 4; i++) {
    9a68:	de 0c       	cmpa	r12,	r14	;
    9a6a:	f8 23       	jnz	$-14     	;abs 0x9a5c

00009a6c <.LBE109>:
    if (hdr.crc) {
    9a6c:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9a70:	10 24       	jz	$+34     	;abs 0x9a92

00009a72 <.Loc.352.2>:
      buffer[1] = 6;
    9a72:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9a76:	01 00 

00009a78 <.Loc.353.2>:
      crcGenX25(buffer, 10);
    9a78:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9a7c:	cc 0a       	mova	r10,	r12	;
    9a7e:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009a82 <.L537>:
    elyCmdSendReply(buffer);
    9a82:	cc 0a       	mova	r10,	r12	;
    9a84:	b0 13 f8 80 	calla	#33016		;0x080f8

00009a88 <.L533>:
}
    9a88:	a1 00 02 00 	adda	#2,	r1	;
    9a8c:	08 16       	popm.a	#1,	r8	;20-bit words
    9a8e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9a90:	10 01       	reta			;

00009a92 <.L536>:
      buffer[1] = 4;
    9a92:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9a96:	80 00 82 9a 	mova	#39554,	r0	;0x09a82

00009a9a <.L534>:
    9a9a:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00009a9e <.LVL748>:
}
    9a9e:	80 00 88 9a 	mova	#39560,	r0	;0x09a88

00009aa2 <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9aa2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009aa4 <.LCFI94>:
    9aa4:	b1 00 06 00 	suba	#6,	r1	;

00009aa8 <.LCFI95>:
    9aa8:	c8 0c       	mova	r12,	r8	;

00009aaa <.LVL750>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9aaa:	65 4d       	mov.b	@r13,	r5	;
    9aac:	55 f3       	and.b	#1,	r5	;r3 As==01
    9aae:	67 4d       	mov.b	@r13,	r7	;
    9ab0:	67 f3       	and.b	#2,	r7	;r3 As==10
    9ab2:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9ab6:	07 93       	cmp	#0,	r7	;r3 As==00
    9ab8:	36 20       	jnz	$+110    	;abs 0x9b26
    9aba:	64 43       	mov.b	#2,	r4	;r3 As==10

00009abc <.L541>:
    9abc:	40 18 04 44 	movx.w	r4,	r4	;
    9ac0:	e4 08       	adda	r8,	r4	;
    9ac2:	cb 04       	mova	r4,	r11	;

00009ac4 <.Loc.295.2>:
    9ac4:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00009ac8 <.Loc.296.2>:
  uint32_t freq = 0;
    9ac8:	49 43       	clr.b	r9		;
    9aca:	0a 49       	mov	r9,	r10	;

00009acc <.L542>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    9acc:	6c 4b       	mov.b	@r11,	r12	;
    9ace:	0d 43       	clr	r13		;
    9ad0:	0e 46       	mov	r6,	r14	;
    9ad2:	0f 43       	clr	r15		;
    9ad4:	71 0b 00 00 	mova	r11,	0(r1)	;
    9ad8:	b0 13 36 cc 	calla	#52278		;0x0cc36
    9adc:	0c d9       	bis	r9,	r12	;
    9ade:	0d da       	bis	r10,	r13	;
    9ae0:	09 4c       	mov	r12,	r9	;

00009ae2 <.LVL754>:
    9ae2:	0a 4d       	mov	r13,	r10	;

00009ae4 <.LVL755>:
    9ae4:	0b 01       	mova	@r1,	r11	;
    9ae6:	ab 00 01 00 	adda	#1,	r11	;
    9aea:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00009aee <.Loc.299.2>:
  for (int i = 0; i < 4; i++) {
    9aee:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    9af2:	ec 23       	jnz	$-38     	;abs 0x9acc

00009af4 <.LBE110>:
  if (freq > TX_BAND_MAX || 
    9af4:	39 50 c0 f1 	add	#-3648,	r9	;#0xf1c0

00009af8 <.LVL756>:
    9af8:	3a 60 30 e6 	addc	#-6608,	r10	;#0xe630

00009afc <.LVL757>:
    9afc:	3c 40 34 02 	mov	#564,	r12	;#0x0234

00009b00 <.LVL758>:
    9b00:	0c 9a       	cmp	r10,	r12	;
    9b02:	06 28       	jnc	$+14     	;abs 0x9b10
    9b04:	0a 9c       	cmp	r12,	r10	;
    9b06:	1f 20       	jnz	$+64     	;abs 0x9b46
    9b08:	3c 40 40 93 	mov	#-27840,r12	;#0x9340
    9b0c:	0c 99       	cmp	r9,	r12	;
    9b0e:	1b 2c       	jc	$+56     	;abs 0x9b46

00009b10 <.L549>:
    if (hdr.reply) {
    9b10:	07 93       	cmp	#0,	r7	;r3 As==00
    9b12:	0c 24       	jz	$+26     	;abs 0x9b2c

00009b14 <.Loc.307.2>:
      gen_failure(buffer, hdr.crc);
    9b14:	4d 45       	mov.b	r5,	r13	;
    9b16:	cc 08       	mova	r8,	r12	;
    9b18:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009b1c <.L551>:
    elyCmdSendReply(buffer);
    9b1c:	cc 08       	mova	r8,	r12	;
    9b1e:	b0 13 f8 80 	calla	#33016		;0x080f8

00009b22 <.LVL761>:
    9b22:	80 00 3e 9b 	mova	#39742,	r0	;0x09b3e

00009b26 <.L548>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9b26:	64 42       	mov.b	#4,	r4	;r2 As==10
    9b28:	80 00 bc 9a 	mova	#39612,	r0	;0x09abc

00009b2c <.L545>:
      elyNLFreeBuffer(elyNLPack(buffer));
    9b2c:	cc 08       	mova	r8,	r12	;
    9b2e:	b0 13 78 be 	calla	#48760		;0x0be78

00009b32 <.LVL764>:
    9b32:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009b36 <.LVL765>:
      elyErrorSignal(ErrCmdFailure);
    9b36:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9b3a:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009b3e <.L540>:
}
    9b3e:	a1 00 06 00 	adda	#6,	r1	;
    9b42:	64 16       	popm.a	#7,	r10	;20-bit words
    9b44:	10 01       	reta			;

00009b46 <.L543>:
  bank0w[RegTXFreqMsb] = buffer[hdr_ext];
    9b46:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    9b4a:	ec 44 03 00 	mov.b	@r4,	3(r12)	;

00009b4e <.Loc.319.2>:
  bank0w[RegTXFreqHmb] = buffer[hdr_ext+1];
    9b4e:	dc 44 01 00 	mov.b	1(r4),	2(r12)	;
    9b52:	02 00 

00009b54 <.Loc.320.2>:
  bank0w[RegTXFreqLmb] = buffer[hdr_ext+2];
    9b54:	dc 44 02 00 	mov.b	2(r4),	1(r12)	;
    9b58:	01 00 

00009b5a <.Loc.321.2>:
  bank0w[RegTXFreqLsb] = buffer[hdr_ext+3];
    9b5a:	dc 44 03 00 	mov.b	3(r4),	0(r12)	;
    9b5e:	00 00 

00009b60 <.Loc.324.2>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    9b60:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9b62:	4d 43       	clr.b	r13		;
    9b64:	b0 13 3c ad 	calla	#44348		;0x0ad3c

00009b68 <.LVL769>:
  elyEventSignal(EvtTXFreqChange);
    9b68:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    9b6c:	b0 13 4a bf 	calla	#48970		;0x0bf4a

00009b70 <.LVL770>:
  if (hdr.reply) {
    9b70:	07 93       	cmp	#0,	r7	;r3 As==00
    9b72:	06 24       	jz	$+14     	;abs 0x9b80

00009b74 <.Loc.331.2>:
    gen_success(buffer, hdr.crc);
    9b74:	4d 45       	mov.b	r5,	r13	;
    9b76:	cc 08       	mova	r8,	r12	;
    9b78:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009b7c <.LVL771>:
    9b7c:	80 00 1c 9b 	mova	#39708,	r0	;0x09b1c

00009b80 <.L547>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9b80:	cc 08       	mova	r8,	r12	;
    9b82:	b0 13 78 be 	calla	#48760		;0x0be78

00009b86 <.LVL772>:
    9b86:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009b8a <.LVL773>:
    9b8a:	80 00 3e 9b 	mova	#39742,	r0	;0x09b3e

00009b8e <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9b8e:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009b90 <.LCFI96>:
    9b90:	b1 00 02 00 	suba	#2,	r1	;

00009b94 <.LCFI97>:
    9b94:	ca 0c       	mova	r12,	r10	;

00009b96 <.Loc.249.2>:
    9b96:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    9b9a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9b9e:	01 00 

00009ba0 <.Loc.251.2>:
  if (hdr.reply) {
    9ba0:	66 41       	mov.b	@r1,	r6	;
    9ba2:	40 18 26 b3 	bitx.w	#2,	r6	;r3 As==10
    9ba6:	88 24       	jz	$+274    	;abs 0x9cb8

00009ba8 <.LBB111>:
    buffer[0] = buffer[0] & 0x3F;
    9ba8:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9bac:	00 00 

00009bae <.Loc.253.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9bae:	28 01 40 08 	mova	&67648,	r8	;0x10840
    9bb2:	dc 48 51 00 	mov.b	81(r8),	2(r12)	;0x00051
    9bb6:	02 00 

00009bb8 <.Loc.254.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9bb8:	dc 48 50 00 	mov.b	80(r8),	3(r12)	;0x00050
    9bbc:	03 00 

00009bbe <.LVL775>:
    9bbe:	a8 00 03 00 	adda	#3,	r8	;
    9bc2:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

00009bc6 <.Loc.256.2>:
    uint32_t freq = 0;
    9bc6:	49 43       	clr.b	r9		;
    9bc8:	07 49       	mov	r9,	r7	;

00009bca <.L554>:
      freq |= ((uint32_t)(bank0p[RegTXFreqMsb - i]) << (8 * (3-i)));
    9bca:	6c 48       	mov.b	@r8,	r12	;
    9bcc:	0d 43       	clr	r13		;
    9bce:	0e 45       	mov	r5,	r14	;
    9bd0:	0f 43       	clr	r15		;
    9bd2:	b0 13 36 cc 	calla	#52278		;0x0cc36
    9bd6:	09 dc       	bis	r12,	r9	;

00009bd8 <.LVL778>:
    9bd8:	07 dd       	bis	r13,	r7	;

00009bda <.LVL779>:
    9bda:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    9bde:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8

00009be2 <.Loc.257.2>:
    for (int i = 0; i < 4; i++) {
    9be2:	35 90 f8 ff 	cmp	#-8,	r5	;#0xfff8
    9be6:	f1 23       	jnz	$-28     	;abs 0x9bca

00009be8 <.LBE112>:
    if (freq > TX_BAND_MAX) {
    9be8:	3c 40 03 1c 	mov	#7171,	r12	;#0x1c03
    9bec:	0c 97       	cmp	r7,	r12	;
    9bee:	06 28       	jnc	$+14     	;abs 0x9bfc
    9bf0:	07 9c       	cmp	r12,	r7	;
    9bf2:	40 20       	jnz	$+130    	;abs 0x9c74
    9bf4:	3c 40 80 a1 	mov	#-24192,r12	;#0xa180
    9bf8:	0c 99       	cmp	r9,	r12	;
    9bfa:	12 2c       	jc	$+38     	;abs 0x9c20

00009bfc <.L562>:
        bank0w[RegTXFreqMsb - i] = ((freq >> (8 * (3 - i))) & 0xFF);
    9bfc:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    9c00:	fc 40 1c 00 	mov.b	#28,	3(r12)	;#0x001c
    9c04:	03 00 

00009c06 <.LVL781>:
    9c06:	fc 40 03 00 	mov.b	#3,	2(r12)	;
    9c0a:	02 00 

00009c0c <.LVL782>:
    9c0c:	fc 40 a1 ff 	mov.b	#-95,	1(r12)	;#0xffa1
    9c10:	01 00 

00009c12 <.LVL783>:
    9c12:	fc 40 80 ff 	mov.b	#-128,	0(r12)	;#0xff80
    9c16:	00 00 

00009c18 <.LBE113>:
      freq = TX_BAND_MAX;
    9c18:	39 40 80 a1 	mov	#-24192,r9	;#0xa180

00009c1c <.LVL785>:
    9c1c:	37 40 03 1c 	mov	#7171,	r7	;#0x1c03

00009c20 <.L557>:
      buffer[i + 4] = ((freq >> (8 * (3 - i))) & 0xFF);
    9c20:	0c 49       	mov	r9,	r12	;
    9c22:	0d 47       	mov	r7,	r13	;
    9c24:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    9c28:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    9c2c:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

00009c30 <.LVL788>:
    9c30:	0c 49       	mov	r9,	r12	;
    9c32:	0d 47       	mov	r7,	r13	;
    9c34:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9c38:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    9c3c:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

00009c40 <.LVL790>:
    9c40:	0c 49       	mov	r9,	r12	;
    9c42:	0d 47       	mov	r7,	r13	;
    9c44:	b0 13 24 cd 	calla	#52516		;0x0cd24
    9c48:	ca 4c 06 00 	mov.b	r12,	6(r10)	;

00009c4c <.LVL792>:
    9c4c:	ca 49 07 00 	mov.b	r9,	7(r10)	;

00009c50 <.LBE114>:
    if (hdr.crc) {
    9c50:	40 18 16 b3 	bitx.w	#1,	r6	;r3 As==01
    9c54:	2d 24       	jz	$+92     	;abs 0x9cb0

00009c56 <.Loc.279.2>:
      buffer[1] = 6;
    9c56:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9c5a:	01 00 

00009c5c <.Loc.280.2>:
      crcGenX25(buffer, 10);
    9c5c:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9c60:	cc 0a       	mova	r10,	r12	;
    9c62:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009c66 <.L560>:
    elyCmdSendReply(buffer);
    9c66:	cc 0a       	mova	r10,	r12	;
    9c68:	b0 13 f8 80 	calla	#33016		;0x080f8

00009c6c <.L552>:
}
    9c6c:	a1 00 02 00 	adda	#2,	r1	;
    9c70:	55 16       	popm.a	#6,	r10	;20-bit words
    9c72:	10 01       	reta			;

00009c74 <.L555>:
    else if (freq < TX_BAND_MIN) {
    9c74:	3c 40 cf 19 	mov	#6607,	r12	;#0x19cf
    9c78:	0c 97       	cmp	r7,	r12	;
    9c7a:	d2 2b       	jnc	$-90     	;abs 0x9c20
    9c7c:	07 9c       	cmp	r12,	r7	;
    9c7e:	04 20       	jnz	$+10     	;abs 0x9c88
    9c80:	3c 40 3f 0e 	mov	#3647,	r12	;#0x0e3f
    9c84:	0c 99       	cmp	r9,	r12	;
    9c86:	cc 2b       	jnc	$-102    	;abs 0x9c20

00009c88 <.L563>:
        bank0w[RegTXFreqMsb - i] = ((freq >> (8 * (3 - i))) & 0xFF);
    9c88:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    9c8c:	fc 40 19 00 	mov.b	#25,	3(r12)	;#0x0019
    9c90:	03 00 

00009c92 <.LVL798>:
    9c92:	fc 40 cf ff 	mov.b	#-49,	2(r12)	;#0xffcf
    9c96:	02 00 

00009c98 <.LVL799>:
    9c98:	fc 40 0e 00 	mov.b	#14,	1(r12)	;#0x000e
    9c9c:	01 00 

00009c9e <.LVL800>:
    9c9e:	fc 40 40 00 	mov.b	#64,	0(r12)	;#0x0040
    9ca2:	00 00 

00009ca4 <.LBE115>:
      freq = TX_BAND_MIN;
    9ca4:	39 40 40 0e 	mov	#3648,	r9	;#0x0e40

00009ca8 <.LVL802>:
    9ca8:	37 40 cf 19 	mov	#6607,	r7	;#0x19cf

00009cac <.LBB116>:
    9cac:	80 00 20 9c 	mova	#39968,	r0	;0x09c20

00009cb0 <.L559>:
      buffer[1] = 4;
    9cb0:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    9cb4:	80 00 66 9c 	mova	#40038,	r0	;0x09c66

00009cb8 <.L553>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9cb8:	b0 13 78 be 	calla	#48760		;0x0be78

00009cbc <.LVL805>:
    9cbc:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009cc0 <.LVL806>:
}
    9cc0:	80 00 6c 9c 	mova	#40044,	r0	;0x09c6c

00009cc4 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9cc4:	4a 14       	pushm.a	#5,	r10	;20-bit words

00009cc6 <.LCFI98>:
    9cc6:	b1 00 02 00 	suba	#2,	r1	;

00009cca <.LCFI99>:
    9cca:	ca 0c       	mova	r12,	r10	;

00009ccc <.LVL808>:
    9ccc:	5f 4d 01 00 	mov.b	1(r13),	r15	;

00009cd0 <.LVL809>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9cd0:	67 4d       	mov.b	@r13,	r7	;
    9cd2:	57 f3       	and.b	#1,	r7	;r3 As==01
    9cd4:	66 4d       	mov.b	@r13,	r6	;
    9cd6:	4b 46       	mov.b	r6,	r11	;
    9cd8:	6b f3       	and.b	#2,	r11	;r3 As==10
    9cda:	49 4b       	mov.b	r11,	r9	;
    9cdc:	09 93       	cmp	#0,	r9	;r3 As==00
    9cde:	24 20       	jnz	$+74     	;abs 0x9d28
    9ce0:	68 43       	mov.b	#2,	r8	;r3 As==10

00009ce2 <.L566>:
  uint8_t bank = buffer[hdr_ext];
    9ce2:	40 18 08 48 	movx.w	r8,	r8	;
    9ce6:	ce 0a       	mova	r10,	r14	;
    9ce8:	ee 08       	adda	r8,	r14	;
    9cea:	6c 4e       	mov.b	@r14,	r12	;

00009cec <.LVL811>:
  uint8_t addr = buffer[hdr_ext+1];
    9cec:	5e 4e 01 00 	mov.b	1(r14),	r14	;

00009cf0 <.LVL812>:
    9cf0:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

00009cf4 <.Loc.221.2>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9cf4:	16 b3       	bit	#1,	r6	;r3 As==01
    9cf6:	1b 20       	jnz	$+56     	;abs 0x9d2e

00009cf8 <.Loc.221.2>:
    9cf8:	4d 43       	clr.b	r13		;

00009cfa <.L567>:
    9cfa:	4f 8b       	sub.b	r11,	r15	;

00009cfc <.LVL814>:
  if (!elyRegSetBlock(bank, buffer + hdr_ext + 2, addr, count)) {
    9cfc:	a8 00 02 00 	adda	#2,	r8	;

00009d00 <.LVL815>:
    9d00:	4f 8d       	sub.b	r13,	r15	;
    9d02:	cd 0a       	mova	r10,	r13	;
    9d04:	ed 08       	adda	r8,	r13	;
    9d06:	b0 13 6a a6 	calla	#42602		;0x0a66a

00009d0a <.LVL816>:
    9d0a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9d0c:	1e 20       	jnz	$+62     	;abs 0x9d4a

00009d0e <.Loc.224.2>:
    if (hdr.reply) {
    9d0e:	09 93       	cmp	#0,	r9	;r3 As==00
    9d10:	11 24       	jz	$+36     	;abs 0x9d34

00009d12 <.Loc.226.2>:
      gen_failure(buffer, hdr.crc);
    9d12:	4d 47       	mov.b	r7,	r13	;
    9d14:	cc 0a       	mova	r10,	r12	;
    9d16:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009d1a <.L574>:
    elyCmdSendReply(buffer);
    9d1a:	cc 0a       	mova	r10,	r12	;
    9d1c:	b0 13 f8 80 	calla	#33016		;0x080f8

00009d20 <.L565>:
}
    9d20:	a1 00 02 00 	adda	#2,	r1	;
    9d24:	46 16       	popm.a	#5,	r10	;20-bit words
    9d26:	10 01       	reta			;

00009d28 <.L572>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9d28:	68 42       	mov.b	#4,	r8	;r2 As==10
    9d2a:	80 00 e2 9c 	mova	#40162,	r0	;0x09ce2

00009d2e <.L573>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9d2e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009d30 <.LVL821>:
    9d30:	80 00 fa 9c 	mova	#40186,	r0	;0x09cfa

00009d34 <.L569>:
      elyErrorSignal(ErrCmdFailure);
    9d34:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9d38:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009d3c <.L571>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9d3c:	cc 0a       	mova	r10,	r12	;
    9d3e:	b0 13 78 be 	calla	#48760		;0x0be78

00009d42 <.LVL824>:
    9d42:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009d46 <.LVL825>:
    9d46:	80 00 20 9d 	mova	#40224,	r0	;0x09d20

00009d4a <.L568>:
  if (hdr.reply) {
    9d4a:	09 93       	cmp	#0,	r9	;r3 As==00
    9d4c:	f7 27       	jz	$-16     	;abs 0x9d3c

00009d4e <.Loc.240.2>:
    gen_success(buffer, hdr.crc);
    9d4e:	4d 47       	mov.b	r7,	r13	;
    9d50:	cc 0a       	mova	r10,	r12	;
    9d52:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009d56 <.LVL826>:
    9d56:	80 00 1a 9d 	mova	#40218,	r0	;0x09d1a

00009d5a <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9d5a:	4a 14       	pushm.a	#5,	r10	;20-bit words

00009d5c <.LCFI100>:
    9d5c:	b1 00 02 00 	suba	#2,	r1	;

00009d60 <.LCFI101>:
    9d60:	ca 0c       	mova	r12,	r10	;
    9d62:	67 4d       	mov.b	@r13,	r7	;
    9d64:	57 f3       	and.b	#1,	r7	;r3 As==01

00009d66 <.Loc.185.2>:
    9d66:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9d6a:	01 00 

00009d6c <.Loc.187.2>:
  if (hdr.reply) { /* reply requested */
    9d6c:	69 4d       	mov.b	@r13,	r9	;
    9d6e:	59 c3       	bic.b	#1,	r9	;r3 As==01
    9d70:	49 d7       	bis.b	r7,	r9	;
    9d72:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    9d76:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9d7a:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    9d7e:	3c 24       	jz	$+122    	;abs 0x9df8

00009d80 <.LBB118>:
    uint8_t count = buffer[6];
    9d80:	56 4c 06 00 	mov.b	6(r12),	r6	;

00009d84 <.LVL831>:
    if (!elyRegGetBlock(bank, buffer + 4, addr, count)) {
    9d84:	4f 46       	mov.b	r6,	r15	;
    9d86:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    9d8a:	cd 0c       	mova	r12,	r13	;
    9d8c:	ad 00 04 00 	adda	#4,	r13	;

00009d90 <.LVL832>:
    9d90:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00009d94 <.LVL833>:
    9d94:	b0 13 cc a5 	calla	#42444		;0x0a5cc

00009d98 <.LVL834>:
    9d98:	88 00 f8 80 	mova	#33016,	r8	;0x080f8
    9d9c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9d9e:	0a 20       	jnz	$+22     	;abs 0x9db4

00009da0 <.Loc.194.2>:
      gen_failure(buffer, hdr.crc);
    9da0:	4d 47       	mov.b	r7,	r13	;
    9da2:	cc 0a       	mova	r10,	r12	;
    9da4:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009da8 <.L580>:
    elyCmdSendReply(buffer);
    9da8:	cc 0a       	mova	r10,	r12	;
    9daa:	48 13       	calla	r8		;

00009dac <.L575>:
}
    9dac:	a1 00 02 00 	adda	#2,	r1	;
    9db0:	46 16       	popm.a	#5,	r10	;20-bit words
    9db2:	10 01       	reta			;

00009db4 <.L577>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    9db4:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    9db8:	00 00 

00009dba <.Loc.201.2>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    9dba:	0c 49       	mov	r9,	r12	;
    9dbc:	5c f3       	and.b	#1,	r12	;r3 As==01
    9dbe:	0c 93       	cmp	#0,	r12	;r3 As==00
    9dc0:	18 20       	jnz	$+50     	;abs 0x9df2
    9dc2:	0d 4c       	mov	r12,	r13	;

00009dc4 <.L579>:
    9dc4:	4d 56       	add.b	r6,	r13	;
    9dc6:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00009dca <.Loc.202.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9dca:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    9dce:	da 4e 51 00 	mov.b	81(r14),2(r10)	;0x00051
    9dd2:	02 00 

00009dd4 <.Loc.203.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9dd4:	da 4e 50 00 	mov.b	80(r14),3(r10)	;0x00050
    9dd8:	03 00 

00009dda <.Loc.205.2>:
    if (hdr.crc) {
    9dda:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ddc:	e5 27       	jz	$-52     	;abs 0x9da8

00009dde <.Loc.206.2>:
      crcGenX25(buffer, count + 6);
    9dde:	0d 46       	mov	r6,	r13	;
    9de0:	3d 50 06 00 	add	#6,	r13	;
    9de4:	4d 0e       	rlam.a	#4,	r13	;
    9de6:	4d 0d       	rram.a	#4,	r13	;
    9de8:	cc 0a       	mova	r10,	r12	;
    9dea:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009dee <.LVL838>:
    9dee:	80 00 a8 9d 	mova	#40360,	r0	;0x09da8

00009df2 <.L581>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    9df2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    9df4:	80 00 c4 9d 	mova	#40388,	r0	;0x09dc4

00009df8 <.L576>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9df8:	b0 13 78 be 	calla	#48760		;0x0be78

00009dfc <.LVL840>:
    9dfc:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009e00 <.LVL841>:
    9e00:	80 00 ac 9d 	mova	#40364,	r0	;0x09dac

00009e04 <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9e04:	2a 14       	pushm.a	#3,	r10	;20-bit words

00009e06 <.LCFI102>:
    9e06:	b1 00 02 00 	suba	#2,	r1	;

00009e0a <.LCFI103>:
    9e0a:	ca 0c       	mova	r12,	r10	;

00009e0c <.LVL843>:
    9e0c:	5e 4d 01 00 	mov.b	1(r13),	r14	;

00009e10 <.LVL844>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    9e10:	68 4d       	mov.b	@r13,	r8	;
    9e12:	58 f3       	and.b	#1,	r8	;r3 As==01
    9e14:	6f 4d       	mov.b	@r13,	r15	;
    9e16:	49 4f       	mov.b	r15,	r9	;
    9e18:	69 f3       	and.b	#2,	r9	;r3 As==10
    9e1a:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9e1e:	09 93       	cmp	#0,	r9	;r3 As==00
    9e20:	24 24       	jz	$+74     	;abs 0x9e6a

00009e22 <.Loc.154.2>:
    9e22:	5c 4a 04 00 	mov.b	4(r10),	r12	;

00009e26 <.LVL845>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    9e26:	7d 40 05 00 	mov.b	#5,	r13	;

00009e2a <.L587>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    9e2a:	1f b3       	bit	#1,	r15	;r3 As==01
    9e2c:	24 20       	jnz	$+74     	;abs 0x9e76

00009e2e <.Loc.156.2>:
    9e2e:	4f 43       	clr.b	r15		;

00009e30 <.L588>:
    9e30:	0e 8f       	sub	r15,	r14	;

00009e32 <.LVL848>:
    9e32:	0e 89       	sub	r9,	r14	;
    9e34:	0f 4e       	mov	r14,	r15	;
    9e36:	5f 03       	rrum	#1,	r15	;
    9e38:	4d 18 0f 11 	rpt #14 { rrax.w	r15		;
    9e3c:	0e 5f       	add	r15,	r14	;

00009e3e <.Loc.158.2>:
  if (!elyRegSet(bank, buffer + regs_offset, num_regs)) {
    9e3e:	40 18 0d 4d 	movx.w	r13,	r13	;
    9e42:	12 c3       	clrc			
    9e44:	0e 10       	rrc	r14		;
    9e46:	ed 0a       	adda	r10,	r13	;

00009e48 <.LVL849>:
    9e48:	b0 13 24 a5 	calla	#42276		;0x0a524

00009e4c <.LVL850>:
    9e4c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9e4e:	21 20       	jnz	$+68     	;abs 0x9e92

00009e50 <.Loc.159.2>:
    if (hdr.reply) {
    9e50:	09 93       	cmp	#0,	r9	;r3 As==00
    9e52:	14 24       	jz	$+42     	;abs 0x9e7c

00009e54 <.Loc.161.2>:
      gen_failure(buffer, hdr.crc);
    9e54:	4d 48       	mov.b	r8,	r13	;
    9e56:	cc 0a       	mova	r10,	r12	;
    9e58:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009e5c <.L594>:
    elyCmdSendReply(buffer);
    9e5c:	cc 0a       	mova	r10,	r12	;
    9e5e:	b0 13 f8 80 	calla	#33016		;0x080f8

00009e62 <.L585>:
}
    9e62:	a1 00 02 00 	adda	#2,	r1	;
    9e66:	28 16       	popm.a	#3,	r10	;20-bit words
    9e68:	10 01       	reta			;

00009e6a <.L586>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    9e6a:	5c 4a 02 00 	mov.b	2(r10),	r12	;

00009e6e <.LVL854>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    9e6e:	7d 40 03 00 	mov.b	#3,	r13	;

00009e72 <.LVL855>:
    9e72:	80 00 2a 9e 	mova	#40490,	r0	;0x09e2a

00009e76 <.L593>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    9e76:	6f 43       	mov.b	#2,	r15	;r3 As==10

00009e78 <.LVL857>:
    9e78:	80 00 30 9e 	mova	#40496,	r0	;0x09e30

00009e7c <.L590>:
      elyErrorSignal(ErrCmdFailure);
    9e7c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9e80:	b0 13 32 bf 	calla	#48946		;0x0bf32

00009e84 <.L592>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9e84:	cc 0a       	mova	r10,	r12	;
    9e86:	b0 13 78 be 	calla	#48760		;0x0be78

00009e8a <.LVL860>:
    9e8a:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009e8e <.LVL861>:
    9e8e:	80 00 62 9e 	mova	#40546,	r0	;0x09e62

00009e92 <.L589>:
  if (hdr.reply) {
    9e92:	09 93       	cmp	#0,	r9	;r3 As==00
    9e94:	f7 27       	jz	$-16     	;abs 0x9e84

00009e96 <.Loc.175.2>:
    gen_success(buffer, hdr.crc);
    9e96:	4d 48       	mov.b	r8,	r13	;
    9e98:	cc 0a       	mova	r10,	r12	;
    9e9a:	b0 13 a4 7b 	calla	#31652		;0x07ba4

00009e9e <.LVL862>:
    9e9e:	80 00 5c 9e 	mova	#40540,	r0	;0x09e5c

00009ea2 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9ea2:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009ea4 <.LCFI104>:
    9ea4:	b1 00 02 00 	suba	#2,	r1	;

00009ea8 <.LCFI105>:
    9ea8:	ca 0c       	mova	r12,	r10	;
    9eaa:	67 4d       	mov.b	@r13,	r7	;
    9eac:	57 f3       	and.b	#1,	r7	;r3 As==01

00009eae <.LVL864>:
    9eae:	55 4d 01 00 	mov.b	1(r13),	r5	;

00009eb2 <.LVL865>:
    9eb2:	c1 45 01 00 	mov.b	r5,	1(r1)	;

00009eb6 <.Loc.124.2>:
  if (hdr.reply) {
    9eb6:	69 4d       	mov.b	@r13,	r9	;
    9eb8:	59 c3       	bic.b	#1,	r9	;r3 As==01
    9eba:	49 d7       	bis.b	r7,	r9	;
    9ebc:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    9ec0:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9ec4:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    9ec8:	3c 24       	jz	$+122    	;abs 0x9f42

00009eca <.LBB120>:
    uint8_t bank = buffer[4];
    9eca:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00009ece <.LVL867>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    9ece:	59 f3       	and.b	#1,	r9	;r3 As==01
    9ed0:	09 93       	cmp	#0,	r9	;r3 As==00
    9ed2:	1b 24       	jz	$+56     	;abs 0x9f0a
    9ed4:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009ed6 <.L597>:
    9ed6:	75 50 fd ff 	add.b	#-3,	r5	;#0xfffd

00009eda <.LVL869>:
    9eda:	40 18 4e 45 	movx.b	r5,	r14	;
    9ede:	40 18 4e 8d 	subx.b	r13,	r14	;
    9ee2:	46 4e       	mov.b	r14,	r6	;

00009ee4 <.LVL870>:
    if (!elyRegGet(bank, buffer + regs_offset, num_regs)) {
    9ee4:	cd 0a       	mova	r10,	r13	;
    9ee6:	ad 00 05 00 	adda	#5,	r13	;
    9eea:	b0 13 76 a4 	calla	#42102		;0x0a476

00009eee <.LVL871>:
    9eee:	88 00 f8 80 	mova	#33016,	r8	;0x080f8
    9ef2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9ef4:	0d 20       	jnz	$+28     	;abs 0x9f10

00009ef6 <.Loc.131.2>:
      gen_failure(buffer, hdr.crc);
    9ef6:	4d 47       	mov.b	r7,	r13	;
    9ef8:	cc 0a       	mova	r10,	r12	;
    9efa:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009efe <.L600>:
    elyCmdSendReply(buffer);
    9efe:	cc 0a       	mova	r10,	r12	;
    9f00:	48 13       	calla	r8		;

00009f02 <.L595>:
}
    9f02:	a1 00 02 00 	adda	#2,	r1	;
    9f06:	55 16       	popm.a	#6,	r10	;20-bit words
    9f08:	10 01       	reta			;

00009f0a <.L601>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    9f0a:	0d 49       	mov	r9,	r13	;

00009f0c <.LVL875>:
    9f0c:	80 00 d6 9e 	mova	#40662,	r0	;0x09ed6

00009f10 <.L598>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    9f10:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    9f14:	00 00 

00009f16 <.Loc.138.2>:
    buffer[1] = hdr.length - 3; /* no Reply Address, no Bank Index */
    9f16:	ca 45 01 00 	mov.b	r5,	1(r10)	;

00009f1a <.Loc.139.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9f1a:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    9f1e:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9f22:	02 00 

00009f24 <.Loc.140.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9f24:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9f28:	03 00 

00009f2a <.Loc.142.2>:
    if (hdr.crc) {
    9f2a:	09 93       	cmp	#0,	r9	;r3 As==00
    9f2c:	e8 27       	jz	$-46     	;abs 0x9efe

00009f2e <.Loc.143.2>:
      crcGenX25(buffer, num_regs + 6);
    9f2e:	0d 46       	mov	r6,	r13	;
    9f30:	3d 50 06 00 	add	#6,	r13	;
    9f34:	4d 0e       	rlam.a	#4,	r13	;
    9f36:	4d 0d       	rram.a	#4,	r13	;
    9f38:	cc 0a       	mova	r10,	r12	;
    9f3a:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009f3e <.LVL877>:
    9f3e:	80 00 fe 9e 	mova	#40702,	r0	;0x09efe

00009f42 <.L596>:
    elyNLFreeBuffer(elyNLPack(buffer));
    9f42:	b0 13 78 be 	calla	#48760		;0x0be78

00009f46 <.LVL879>:
    9f46:	b0 13 24 bd 	calla	#48420		;0x0bd24

00009f4a <.LVL880>:
    9f4a:	80 00 02 9f 	mova	#40706,	r0	;0x09f02

00009f4e <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9f4e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009f50 <.LCFI106>:
    9f50:	b1 00 02 00 	suba	#2,	r1	;

00009f54 <.LCFI107>:
    9f54:	ca 0c       	mova	r12,	r10	;
    9f56:	6e 4d       	mov.b	@r13,	r14	;
    9f58:	5e f3       	and.b	#1,	r14	;r3 As==01

00009f5a <.LVL882>:
    9f5a:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9f5e:	01 00 

00009f60 <.Loc.105.2>:
  if (hdr.reply) { /* reply requested */
    9f60:	6d 4d       	mov.b	@r13,	r13	;
    9f62:	5d c3       	bic.b	#1,	r13	;r3 As==01
    9f64:	4d de       	bis.b	r14,	r13	;
    9f66:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    9f6a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    9f6e:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    9f72:	20 24       	jz	$+66     	;abs 0x9fb4

00009f74 <.Loc.106.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    9f74:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    9f78:	00 00 

00009f7a <.Loc.107.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    9f7a:	4e 5e       	rla.b	r14		;

00009f7c <.LVL884>:
    9f7c:	5e 53       	inc.b	r14		;
    9f7e:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00009f82 <.Loc.108.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    9f82:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    9f86:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    9f8a:	02 00 

00009f8c <.Loc.109.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    9f8c:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    9f90:	03 00 

00009f92 <.Loc.110.2>:
    buffer[4] = bank0p[RegActiveBank];
    9f92:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    9f96:	04 00 

00009f98 <.Loc.111.2>:
    if (hdr.crc) {
    9f98:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    9f9c:	04 24       	jz	$+10     	;abs 0x9fa6

00009f9e <.Loc.112.2>:
      crcGenX25(buffer, 7);
    9f9e:	7d 40 07 00 	mov.b	#7,	r13	;
    9fa2:	b0 13 50 ab 	calla	#43856		;0x0ab50

00009fa6 <.L607>:
    elyCmdSendReply(buffer);
    9fa6:	cc 0a       	mova	r10,	r12	;
    9fa8:	b0 13 f8 80 	calla	#33016		;0x080f8

00009fac <.L605>:
}
    9fac:	a1 00 02 00 	adda	#2,	r1	;
    9fb0:	0a 16       	popm.a	#1,	r10	;20-bit words
    9fb2:	10 01       	reta			;

00009fb4 <.L606>:
    9fb4:	b0 13 2c 7d 	calla	#32044		;0x07d2c

00009fb8 <.LVL888>:
    9fb8:	80 00 ac 9f 	mova	#40876,	r0	;0x09fac

00009fbc <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9fbc:	3a 14       	pushm.a	#4,	r10	;20-bit words

00009fbe <.LCFI108>:
    9fbe:	b1 00 02 00 	suba	#2,	r1	;

00009fc2 <.LCFI109>:
    9fc2:	ca 0c       	mova	r12,	r10	;
    9fc4:	68 4d       	mov.b	@r13,	r8	;
    9fc6:	58 f3       	and.b	#1,	r8	;r3 As==01

00009fc8 <.Loc.64.2>:
    9fc8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    9fcc:	01 00 

00009fce <.Loc.65.2>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    9fce:	69 4d       	mov.b	@r13,	r9	;
    9fd0:	59 c3       	bic.b	#1,	r9	;r3 As==01
    9fd2:	49 d8       	bis.b	r8,	r9	;
    9fd4:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    9fd8:	69 f3       	and.b	#2,	r9	;r3 As==10
    9fda:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    9fde:	09 93       	cmp	#0,	r9	;r3 As==00
    9fe0:	13 20       	jnz	$+40     	;abs 0xa008
    9fe2:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009fe4 <.L613>:
    9fe4:	ec 0a       	adda	r10,	r12	;
    9fe6:	67 4c       	mov.b	@r12,	r7	;

00009fe8 <.LVL893>:
  if (arg > 1) {
    9fe8:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009fea <.LVL894>:
    9fea:	4c 97       	cmp.b	r7,	r12	;
    9fec:	1b 2c       	jc	$+56     	;abs 0xa024

00009fee <.Loc.68.2>:
    if (hdr.reply) {
    9fee:	09 93       	cmp	#0,	r9	;r3 As==00
    9ff0:	0e 24       	jz	$+30     	;abs 0xa00e

00009ff2 <.Loc.70.2>:
      gen_failure(buffer, hdr.crc);
    9ff2:	4d 48       	mov.b	r8,	r13	;
    9ff4:	cc 0a       	mova	r10,	r12	;
    9ff6:	b0 13 e2 7b 	calla	#31714		;0x07be2

00009ffa <.L620>:
    elyCmdSendReply(buffer);
    9ffa:	cc 0a       	mova	r10,	r12	;
    9ffc:	b0 13 f8 80 	calla	#33016		;0x080f8

0000a000 <.L612>:
}
    a000:	a1 00 02 00 	adda	#2,	r1	;
    a004:	37 16       	popm.a	#4,	r10	;20-bit words
    a006:	10 01       	reta			;

0000a008 <.L619>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    a008:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a00a:	80 00 e4 9f 	mova	#40932,	r0	;0x09fe4

0000a00e <.L615>:
      elyErrorSignal(ErrCmdFailure);
    a00e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    a012:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a016 <.L618>:
    elyNLFreeBuffer(elyNLPack(buffer));
    a016:	cc 0a       	mova	r10,	r12	;
    a018:	b0 13 78 be 	calla	#48760		;0x0be78

0000a01c <.LVL900>:
    a01c:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000a020 <.LVL901>:
    a020:	80 00 00 a0 	mova	#40960,	r0	;0x0a000

0000a024 <.L614>:
  if (bank0p[RegGPOState] != arg) {
    a024:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    a028:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    a02c:	16 24       	jz	$+46     	;abs 0xa05a

0000a02e <.Loc.85.2>:
    palWriteLine(LINE_GPO, arg);
    a02e:	0c 47       	mov	r7,	r12	;
    a030:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    a034:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    a038:	40 18 1d 42 	movx.w	&0x00222,r13	;
    a03c:	22 02 
    a03e:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    a042:	0c dd       	bis	r13,	r12	;
    a044:	40 18 82 4c 	movx.w	r12,	&0x00222;
    a048:	22 02 

0000a04a <.Loc.87.2>:
    elyEventSignal(EvtGPOChange);
    a04a:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    a04e:	b0 13 4a bf 	calla	#48970		;0x0bf4a

0000a052 <.LVL902>:
    bank0w[RegGPOState] = arg;
    a052:	2c 01 3c 08 	mova	&67644,	r12	;0x1083c
    a056:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

0000a05a <.L617>:
  if (hdr.reply) {
    a05a:	09 93       	cmp	#0,	r9	;r3 As==00
    a05c:	dc 27       	jz	$-70     	;abs 0xa016

0000a05e <.Loc.93.2>:
    gen_success(buffer, hdr.crc);
    a05e:	4d 48       	mov.b	r8,	r13	;
    a060:	cc 0a       	mova	r10,	r12	;
    a062:	b0 13 a4 7b 	calla	#31652		;0x07ba4

0000a066 <.LVL903>:
    a066:	80 00 fa 9f 	mova	#40954,	r0	;0x09ffa

0000a06a <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a06a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a06c <.LCFI110>:
    a06c:	b1 00 02 00 	suba	#2,	r1	;

0000a070 <.LCFI111>:
    a070:	ca 0c       	mova	r12,	r10	;
    a072:	6e 4d       	mov.b	@r13,	r14	;
    a074:	5e f3       	and.b	#1,	r14	;r3 As==01

0000a076 <.LVL905>:
    a076:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    a07a:	01 00 

0000a07c <.Loc.46.2>:
  if (hdr.reply) { /* reply requested */
    a07c:	6d 4d       	mov.b	@r13,	r13	;
    a07e:	5d c3       	bic.b	#1,	r13	;r3 As==01
    a080:	4d de       	bis.b	r14,	r13	;
    a082:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    a086:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a08a:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    a08e:	20 24       	jz	$+66     	;abs 0xa0d0

0000a090 <.Loc.47.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    a090:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    a094:	00 00 

0000a096 <.Loc.48.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    a096:	4e 5e       	rla.b	r14		;

0000a098 <.LVL907>:
    a098:	5e 53       	inc.b	r14		;
    a09a:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000a09e <.Loc.49.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    a09e:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    a0a2:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    a0a6:	02 00 

0000a0a8 <.Loc.50.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    a0a8:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    a0ac:	03 00 

0000a0ae <.Loc.51.2>:
    buffer[4] = bank0p[RegGPOState];
    a0ae:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    a0b2:	04 00 

0000a0b4 <.Loc.52.2>:
    if (hdr.crc) {
    a0b4:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    a0b8:	04 24       	jz	$+10     	;abs 0xa0c2

0000a0ba <.Loc.53.2>:
      crcGenX25(buffer, 7);
    a0ba:	7d 40 07 00 	mov.b	#7,	r13	;
    a0be:	b0 13 50 ab 	calla	#43856		;0x0ab50

0000a0c2 <.L623>:
    elyCmdSendReply(buffer);
    a0c2:	cc 0a       	mova	r10,	r12	;
    a0c4:	b0 13 f8 80 	calla	#33016		;0x080f8

0000a0c8 <.L621>:
}
    a0c8:	a1 00 02 00 	adda	#2,	r1	;
    a0cc:	0a 16       	popm.a	#1,	r10	;20-bit words
    a0ce:	10 01       	reta			;

0000a0d0 <.L622>:
    a0d0:	b0 13 2c 7d 	calla	#32044		;0x07d2c

0000a0d4 <.LVL911>:
    a0d4:	80 00 c8 a0 	mova	#41160,	r0	;0x0a0c8

0000a0d8 <clamp>:

/* TODO persistent, really? */
static BSEMAPHORE_DECL(regs_sem, 1); /* 1 is taken which is cnt == 0 */
static uint8_t regs_in_progress = 0;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a0d8:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000a0da <.LCFI0>:
    a0da:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a0de:	49 4d       	mov.b	r13,	r9	;
    a0e0:	4a 4e       	mov.b	r14,	r10	;

0000a0e2 <.Loc.153.1>:
  if (value < min) {
    a0e2:	4c 99       	cmp.b	r9,	r12	;
    a0e4:	07 2c       	jc	$+16     	;abs 0xa0f4

0000a0e6 <.LVL1>:
    value = min;
    elyErrorSignal(ErrRegClip);
    a0e6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a0ea:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a0ee <.LVL2>:
    a0ee:	0c 49       	mov	r9,	r12	;

0000a0f0 <.L3>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    a0f0:	19 16       	popm.a	#2,	r10	;20-bit words
    a0f2:	10 01       	reta			;

0000a0f4 <.L2>:
  else if (value > max) {
    a0f4:	4a 9c       	cmp.b	r12,	r10	;
    a0f6:	fc 2f       	jc	$-6      	;abs 0xa0f0

0000a0f8 <.LVL5>:
    elyErrorSignal(ErrRegClip);
    a0f8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a0fc:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a100 <.LVL6>:
    a100:	0c 4a       	mov	r10,	r12	;
    a102:	80 00 f0 a0 	mova	#41200,	r0	;0x0a0f0

0000a106 <fram_reg_cb>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    a106:	40 18 5c 42 	movx.b	&0x0d054,r12	;
    a10a:	54 d0 

0000a10c <.LVL8>:
    a10c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a10e:	40 18 c2 4c 	movx.b	r12,	&0xfd054;
    a112:	54 d0 

0000a114 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    a114:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a116:	0a 20       	jnz	$+22     	;abs 0xa12c

0000a118 <.LBB12>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a118:	40 18 1c 42 	movx.w	&0x0d056,r12	;
    a11c:	56 d0 
    a11e:	4d 43       	clr.b	r13		;
    a120:	0d 9c       	cmp	r12,	r13	;
    a122:	04 38       	jl	$+10     	;abs 0xa12c

0000a124 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a124:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a128:	b0 13 2e 49 	calla	#18734		;0x0492e

0000a12c <.L4>:
    chSysLockFromISR();
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
  }
}
    a12c:	10 01       	reta			;

0000a12e <fram_block_cb>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a12e:	40 18 1c 42 	movx.w	&0x0d056,r12	;
    a132:	56 d0 

0000a134 <.LVL13>:
    a134:	4d 43       	clr.b	r13		;
    a136:	0d 9c       	cmp	r12,	r13	;
    a138:	04 38       	jl	$+10     	;abs 0xa142

0000a13a <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a13a:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a13e:	b0 13 2e 49 	calla	#18734		;0x0492e

0000a142 <.L6>:
void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
}
    a142:	10 01       	reta			;

0000a144 <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    a144:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a146 <.LCFI1>:
    a146:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a148 <.LCFI2>:
    a148:	b1 00 04 00 	suba	#4,	r1	;

0000a14c <.LCFI3>:
    a14c:	4a 4c       	mov.b	r12,	r10	;
    a14e:	49 4d       	mov.b	r13,	r9	;
    a150:	48 4e       	mov.b	r14,	r8	;
    a152:	c6 0f       	mova	r15,	r6	;

0000a154 <.LBB22>:
  _disable_interrupts();
    a154:	32 c2       	dint			
    a156:	03 43       	nop			

0000a158 <.Loc.348.3>:
  asm volatile("nop");
    a158:	03 43       	nop			

0000a15a <.LBE22>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a15a:	4d 43       	clr.b	r13		;

0000a15c <.LVL16>:
    a15c:	cc 01       	mova	r1,	r12	;

0000a15e <.LVL17>:
    a15e:	b0 13 36 ba 	calla	#47670		;0x0ba36

0000a162 <.LBB24>:
  asm volatile("nop");
    a162:	03 43       	nop			

0000a164 <.Loc.356.3>:
  _enable_interrupts();
    a164:	03 43       	nop			
    a166:	32 d2       	eint			
    a168:	03 43       	nop			

0000a16a <.LBE24>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a16a:	0c 01       	mova	@r1,	r12	;
    a16c:	39 53       	add	#-1,	r9	;r3 As==11

0000a16e <.LVL19>:
    a16e:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a172 <.LVL20>:
    a172:	0e 49       	mov	r9,	r14	;
    a174:	0f 49       	mov	r9,	r15	;
    a176:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a17a:	48 48       	mov.b	r8,	r8	;
    a17c:	09 43       	clr	r9		;

0000a17e <.LVL21>:
    a17e:	0d 48       	mov	r8,	r13	;
    a180:	0d 53       	add	#0,	r13	;r3 As==00
    a182:	19 63       	addc	#1,	r9	;r3 As==01
    a184:	0d 5e       	add	r14,	r13	;
    a186:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a18a:	09 6f       	addc	r15,	r9	;
    a18c:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a190 <.Loc.225.1>:
  req->read = read;
    a190:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a192 <.LVL22>:
    a192:	4a 5a       	rla.b	r10		;
    a194:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a198:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a19a:	4d da       	bis.b	r10,	r13	;
    a19c:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a1a0 <.Loc.226.1>:
  req->size = 1;
    a1a0:	1d 4c 04 00 	mov	4(r12),	r13	;
    a1a4:	7d f0 03 00 	and.b	#3,	r13	;
    a1a8:	2d d2       	bis	#4,	r13	;r2 As==10
    a1aa:	8c 4d 04 00 	mov	r13,	4(r12)	;
    a1ae:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    a1b2:	06 00 

0000a1b4 <.Loc.227.1>:
  req->buffer = valuep;
    a1b4:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a1b8 <.Loc.228.1>:
  req->callback = fram_reg_cb;
    a1b8:	00 18 fc 40 	movx.a	#41222,	12(r12)	;0x0a106, 0x0000c
    a1bc:	06 a1 0c 00 

0000a1c0 <.Loc.231.1>:
  elyFramPostRequest(req);
    a1c0:	b0 13 1a ba 	calla	#47642		;0x0ba1a

0000a1c4 <.LVL23>:
}
    a1c4:	a1 00 04 00 	adda	#4,	r1	;
    a1c8:	06 16       	popm.a	#1,	r6	;20-bit words
    a1ca:	28 16       	popm.a	#3,	r10	;20-bit words
    a1cc:	10 01       	reta			;

0000a1ce <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    a1ce:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a1d0 <.LCFI4>:
    a1d0:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a1d2 <.LCFI5>:
    a1d2:	b1 00 08 00 	suba	#8,	r1	;

0000a1d6 <.LCFI6>:
    a1d6:	4a 4c       	mov.b	r12,	r10	;
    a1d8:	49 4d       	mov.b	r13,	r9	;
    a1da:	48 4e       	mov.b	r14,	r8	;
    a1dc:	c6 0f       	mova	r15,	r6	;

0000a1de <.LBB30>:
  _disable_interrupts();
    a1de:	32 c2       	dint			
    a1e0:	03 43       	nop			

0000a1e2 <.Loc.348.3>:
  asm volatile("nop");
    a1e2:	03 43       	nop			

0000a1e4 <.LBE30>:
  fram_req_t * req;
  
  chSysLock();
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a1e4:	4d 43       	clr.b	r13		;

0000a1e6 <.LVL25>:
    a1e6:	cc 01       	mova	r1,	r12	;

0000a1e8 <.LVL26>:
    a1e8:	ac 00 04 00 	adda	#4,	r12	;
    a1ec:	b0 13 36 ba 	calla	#47670		;0x0ba36

0000a1f0 <.LBB32>:
  asm volatile("nop");
    a1f0:	03 43       	nop			

0000a1f2 <.Loc.356.3>:
  _enable_interrupts();
    a1f2:	03 43       	nop			
    a1f4:	32 d2       	eint			
    a1f6:	03 43       	nop			

0000a1f8 <.LBE32>:
  chSysUnlock();
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a1f8:	3c 01 04 00 	mova	4(r1),	r12	;
    a1fc:	39 53       	add	#-1,	r9	;r3 As==11

0000a1fe <.LVL28>:
    a1fe:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a202 <.LVL29>:
    a202:	0e 49       	mov	r9,	r14	;
    a204:	0f 49       	mov	r9,	r15	;
    a206:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a20a:	48 48       	mov.b	r8,	r8	;
    a20c:	09 43       	clr	r9		;

0000a20e <.LVL30>:
    a20e:	0d 48       	mov	r8,	r13	;
    a210:	0d 53       	add	#0,	r13	;r3 As==00
    a212:	19 63       	addc	#1,	r9	;r3 As==01
    a214:	0d 5e       	add	r14,	r13	;
    a216:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a21a:	09 6f       	addc	r15,	r9	;
    a21c:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a220 <.Loc.251.1>:
  req->read = read;
    a220:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a222 <.LVL31>:
    a222:	4a 5a       	rla.b	r10		;
    a224:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a228:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a22a:	4d da       	bis.b	r10,	r13	;
    a22c:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a230 <.Loc.252.1>:
  req->size = n;
    a230:	5d 41 1c 00 	mov.b	28(r1),	r13	;0x0001c
    a234:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    a238:	00 00 
    a23a:	2d 41       	mov	@r1,	r13	;
    a23c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a240:	1e 4c 04 00 	mov	4(r12),	r14	;
    a244:	7e f0 03 00 	and.b	#3,	r14	;
    a248:	0e dd       	bis	r13,	r14	;
    a24a:	8c 4e 04 00 	mov	r14,	4(r12)	;

0000a24e <.LVL32>:
    a24e:	2e 41       	mov	@r1,	r14	;
    a250:	0f 4e       	mov	r14,	r15	;
    a252:	5f 03       	rrum	#1,	r15	;
    a254:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    a258:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    a25c:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    a260:	0a 01       	mova	@r1,	r10	;
    a262:	0a 14       	pushm.a	#1,	r10	;20-bit words
    a264:	0d 17       	popm	#1,	r13	;16-bit words
    a266:	0d 17       	popm	#1,	r13	;16-bit words
    a268:	5d f3       	and.b	#1,	r13	;r3 As==01
    a26a:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a26e:	4e df       	bis.b	r15,	r14	;
    a270:	4e dd       	bis.b	r13,	r14	;
    a272:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000a276 <.Loc.253.1>:
  req->buffer = buffer;
    a276:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a27a <.Loc.254.1>:
  req->callback = fram_block_cb;
    a27a:	00 18 fc 40 	movx.a	#41262,	12(r12)	;0x0a12e, 0x0000c
    a27e:	2e a1 0c 00 

0000a282 <.Loc.257.1>:
  
  /* TODO handle failure */
  elyFramPostRequest(req);
    a282:	b0 13 1a ba 	calla	#47642		;0x0ba1a

0000a286 <.LVL33>:
}
    a286:	a1 00 08 00 	adda	#8,	r1	;
    a28a:	06 16       	popm.a	#1,	r6	;20-bit words
    a28c:	28 16       	popm.a	#3,	r10	;20-bit words
    a28e:	10 01       	reta			;

0000a290 <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    a290:	4e 4c       	mov.b	r12,	r14	;
    a292:	4c 4d       	mov.b	r13,	r12	;

0000a294 <.LVL35>:
  switch(addr) {
    a294:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    a298:	8a 24       	jz	$+278    	;abs 0xa3ae
    a29a:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    a29e:	4f 9e       	cmp.b	r14,	r15	;
    a2a0:	3b 28       	jnc	$+120    	;abs 0xa318
    a2a2:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    a2a6:	76 24       	jz	$+238    	;abs 0xa394
    a2a8:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    a2ac:	4f 9e       	cmp.b	r14,	r15	;
    a2ae:	13 28       	jnc	$+40     	;abs 0xa2d6
    a2b0:	7e 90 07 00 	cmp.b	#7,	r14	;
    a2b4:	6b 24       	jz	$+216    	;abs 0xa38c
    a2b6:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    a2ba:	6c 24       	jz	$+218    	;abs 0xa394
    a2bc:	7e 90 03 00 	cmp.b	#3,	r14	;
    a2c0:	14 20       	jnz	$+42     	;abs 0xa2ea

0000a2c2 <.Loc.263.1>:
    case RegTXFreqMsb:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    a2c2:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c

0000a2c6 <.L93>:
      break;
    case RegRXFreqMsb:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    a2c6:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019

0000a2ca <.L92>:
      break;
    case RegOutputPower:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    case RegUARTBaudLsb:
    case RegSCCommBaudLsb:
      value = clamp(value, 1, 0xFF);
    a2ca:	b0 13 d8 a0 	calla	#41176		;0x0a0d8

0000a2ce <.L91>:
    case RegPATempERR:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
      break;
    default:
      if (addr > 0x80 && addr < 0xBF) {
        value = elyNLClampReg(addr, value);
    a2ce:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a2d2 <.LVL39>:
    a2d2:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a2d6 <.L15>:
  switch(addr) {
    a2d6:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    a2da:	5c 24       	jz	$+186    	;abs 0xa394
    a2dc:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    a2e0:	4f 9e       	cmp.b	r14,	r15	;
    a2e2:	10 28       	jnc	$+34     	;abs 0xa304
    a2e4:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    a2e8:	55 24       	jz	$+172    	;abs 0xa394

0000a2ea <.L11>:
      if (addr > 0x80 && addr < 0xBF) {
    a2ea:	4d 4e       	mov.b	r14,	r13	;
    a2ec:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    a2f0:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    a2f4:	4f 9d       	cmp.b	r13,	r15	;
    a2f6:	b5 28       	jnc	$+364    	;abs 0xa462

0000a2f8 <.Loc.318.1>:
        value = elyNLClampReg(addr, value);
    a2f8:	4d 4c       	mov.b	r12,	r13	;
    a2fa:	4c 4e       	mov.b	r14,	r12	;

0000a2fc <.LVL42>:
    a2fc:	b0 13 0a bc 	calla	#48138		;0x0bc0a

0000a300 <.LVL43>:
    a300:	80 00 ce a2 	mova	#41678,	r0	;0x0a2ce

0000a304 <.L20>:
  switch(addr) {
    a304:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    a308:	49 24       	jz	$+148    	;abs 0xa39c
    a30a:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    a30e:	ed 23       	jnz	$-36     	;abs 0xa2ea

0000a310 <.L23>:
      value = clamp(value, 1, 0xFF);
    a310:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    a312:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a314:	80 00 ca a2 	mova	#41674,	r0	;0x0a2ca

0000a318 <.L13>:
  switch(addr) {
    a318:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    a31c:	48 24       	jz	$+146    	;abs 0xa3ae
    a31e:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    a322:	4f 9e       	cmp.b	r14,	r15	;
    a324:	12 28       	jnc	$+38     	;abs 0xa34a
    a326:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    a32a:	4f 9e       	cmp.b	r14,	r15	;
    a32c:	09 28       	jnc	$+20     	;abs 0xa340
    a32e:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    a332:	41 2c       	jc	$+132    	;abs 0xa3b6
    a334:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    a338:	d8 23       	jnz	$-78     	;abs 0xa2ea

0000a33a <.L38>:
      return 0; /* this is purely efficiency */
    a33a:	4c 43       	clr.b	r12		;
    a33c:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a340 <.L25>:
  switch(addr) {
    a340:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    a344:	e5 27       	jz	$-52     	;abs 0xa310
    a346:	80 00 ea a2 	mova	#41706,	r0	;0x0a2ea

0000a34a <.L24>:
    a34a:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    a34e:	7a 24       	jz	$+246    	;abs 0xa444
    a350:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    a354:	4f 9e       	cmp.b	r14,	r15	;
    a356:	05 28       	jnc	$+12     	;abs 0xa362
    a358:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    a35c:	ee 27       	jz	$-34     	;abs 0xa33a
    a35e:	80 00 ea a2 	mova	#41706,	r0	;0x0a2ea

0000a362 <.L29>:
    a362:	4d 4e       	mov.b	r14,	r13	;

0000a364 <.LVL49>:
    a364:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    a368:	7f 40 05 00 	mov.b	#5,	r15	;
    a36c:	4f 9d       	cmp.b	r13,	r15	;
    a36e:	bd 2b       	jnc	$-132    	;abs 0xa2ea

0000a370 <.LBB38>:
  if ((int8_t)(value) < min) {
    a370:	4d 4c       	mov.b	r12,	r13	;
    a372:	40 18 8d 11 	sxtx.w	r13		;
    a376:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    a37a:	67 34       	jge	$+208    	;abs 0xa44a

0000a37c <.Loc.195.1>:
    elyErrorSignal(ErrRegClip);
    a37c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a380 <.LVL51>:
    a380:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a384 <.LVL52>:
    value = (uint8_t)(min);
    a384:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    a388:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a38c <.L16>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    a38c:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    a390:	80 00 c6 a2 	mova	#41670,	r0	;0x0a2c6

0000a394 <.L19>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    a394:	4e 43       	clr.b	r14		;

0000a396 <.L94>:
      value = clamp(value, 0, 4);
    a396:	4d 43       	clr.b	r13		;

0000a398 <.LVL54>:
    a398:	80 00 ca a2 	mova	#41674,	r0	;0x0a2ca

0000a39c <.L22>:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    a39c:	4e 43       	clr.b	r14		;
    a39e:	7d 40 4f 00 	mov.b	#79,	r13	;#0x004f

0000a3a2 <.LVL56>:
    a3a2:	b0 13 d8 a0 	calla	#41176		;0x0a0d8

0000a3a6 <.LVL57>:
    a3a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a3aa <.LVL58>:
    a3aa:	80 00 10 a3 	mova	#41744,	r0	;0x0a310

0000a3ae <.L12>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    a3ae:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    a3b2:	80 00 96 a3 	mova	#41878,	r0	;0x0a396

0000a3b6 <.L26>:
  if ((value & 0x10) && value != 0x10) {
    a3b6:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    a3ba:	10 00 
    a3bc:	0a 24       	jz	$+22     	;abs 0xa3d2
    a3be:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a3c2:	07 24       	jz	$+16     	;abs 0xa3d2

0000a3c4 <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    a3c4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a3c8 <.LVL61>:
    a3c8:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a3cc <.LVL62>:
    return 0x10;
    a3cc:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000a3d0 <.L27>:
        value = elyDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    a3d0:	10 01       	reta			;

0000a3d2 <.L31>:
  if ((value & 0x08) && value != 0x08) {
    a3d2:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    a3d6:	09 24       	jz	$+20     	;abs 0xa3ea
    a3d8:	3c 92       	cmp	#8,	r12	;r2 As==11
    a3da:	07 24       	jz	$+16     	;abs 0xa3ea

0000a3dc <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    a3dc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a3e0 <.LVL65>:
    a3e0:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a3e4 <.LVL66>:
    return 0x08;
    a3e4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a3e6:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a3ea <.L32>:
  if ((value & 0x04) && value != 0x04) {
    a3ea:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    a3ee:	09 24       	jz	$+20     	;abs 0xa402
    a3f0:	2c 92       	cmp	#4,	r12	;r2 As==10
    a3f2:	07 24       	jz	$+16     	;abs 0xa402

0000a3f4 <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    a3f4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a3f8 <.LVL68>:
    a3f8:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a3fc <.LVL69>:
    return 0x04;
    a3fc:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a3fe:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a402 <.L33>:
  if ((value & 0x02) && value != 0x02) {
    a402:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    a406:	09 24       	jz	$+20     	;abs 0xa41a
    a408:	2c 93       	cmp	#2,	r12	;r3 As==10
    a40a:	07 24       	jz	$+16     	;abs 0xa41a

0000a40c <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    a40c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a410 <.LVL71>:
    a410:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a414 <.LVL72>:
    return 0x02;
    a414:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a416:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a41a <.L34>:
  if ((value & 0x01) && value != 0x01) {
    a41a:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    a41e:	09 24       	jz	$+20     	;abs 0xa432
    a420:	1c 93       	cmp	#1,	r12	;r3 As==01
    a422:	07 24       	jz	$+16     	;abs 0xa432

0000a424 <.Loc.182.1>:
    elyErrorSignal(ErrRegClip);
    a424:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a428 <.LVL74>:
    a428:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a42c <.LVL75>:
    return 0x01;
    a42c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a42e:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a432 <.L35>:
  if (value & 0xD0) {
    a432:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a436:	cc 27       	jz	$-102    	;abs 0xa3d0

0000a438 <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    a438:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a43c <.LVL77>:
    a43c:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a440 <.LVL78>:
    a440:	80 00 3a a3 	mova	#41786,	r0	;0x0a33a

0000a444 <.L28>:
      value = clamp(value, 0, 4);
    a444:	6e 42       	mov.b	#4,	r14	;r2 As==10
    a446:	80 00 96 a3 	mova	#41878,	r0	;0x0a396

0000a44a <.L36>:
  else if ((int8_t)(value) > max) {
    a44a:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    a44e:	4e 9d       	cmp.b	r13,	r14	;
    a450:	bf 37       	jge	$-128    	;abs 0xa3d0

0000a452 <.Loc.199.1>:
    elyErrorSignal(ErrRegClip);
    a452:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a456 <.LVL81>:
    a456:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000a45a <.LVL82>:
    value = (uint8_t)(max);
    a45a:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    a45e:	80 00 d0 a3 	mova	#41936,	r0	;0x0a3d0

0000a462 <.L37>:
      else if (addr > 0xC0) {
    a462:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    a466:	4d 9e       	cmp.b	r14,	r13	;
    a468:	b3 2f       	jc	$-152    	;abs 0xa3d0

0000a46a <.Loc.321.1>:
        value = elyDLLClampReg(addr, value);
    a46a:	4d 4c       	mov.b	r12,	r13	;
    a46c:	4c 4e       	mov.b	r14,	r12	;
    a46e:	b0 13 90 c2 	calla	#49808		;0x0c290

0000a472 <.LVL84>:
    a472:	80 00 ce a2 	mova	#41678,	r0	;0x0a2ce

0000a476 <elyRegGet>:

bool elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a476:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a478 <.LCFI7>:
    a478:	49 4c       	mov.b	r12,	r9	;
    a47a:	47 4e       	mov.b	r14,	r7	;

0000a47c <.Loc.329.1>:
  regs_in_progress = n;
    a47c:	40 18 c2 47 	movx.b	r7,	&0xfd054;
    a480:	54 d0 

0000a482 <.LVL86>:
    a482:	ca 0d       	mova	r13,	r10	;

0000a484 <.LBB54>:
  
  for (int i = 0; i < n; i++) {
    a484:	ce 0d       	mova	r13,	r14	;

0000a486 <.LVL87>:
    a486:	4d 43       	clr.b	r13		;

0000a488 <.L96>:
    a488:	0d 97       	cmp	r7,	r13	;
    a48a:	0f 38       	jl	$+32     	;abs 0xa4aa

0000a48c <.LBE54>:
        (addr >= RegDLLMAX)) {
      return false; /* other bits handled outside */
    }
  }
  
  if (bank == 0) {
    a48c:	09 93       	cmp	#0,	r9	;r3 As==00
    a48e:	36 24       	jz	$+110    	;abs 0xa4fc
    a490:	45 43       	clr.b	r5		;

0000a492 <.LBB57>:
  else {
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
  
      /* Get the register */
      fram_reg(1, bank, addr, (buffer+i-1));
    a492:	88 00 44 a1 	mova	#41284,	r8	;0x0a144
    a496:	56 43       	mov.b	#1,	r6	;r3 As==01

0000a498 <.L100>:
    for (int i = 0; i < n; i++) {
    a498:	05 97       	cmp	r7,	r5	;
    a49a:	35 20       	jnz	$+108    	;abs 0xa506

0000a49c <.LBB60>:
  return chSemWaitTimeout(&bsp->sem, time);
    a49c:	4d 43       	clr.b	r13		;
    a49e:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a4a2:	b0 13 b2 48 	calla	#18610		;0x048b2

0000a4a6 <.LVL91>:
    a4a6:	80 00 00 a5 	mova	#42240,	r0	;0x0a500

0000a4aa <.L98>:
    uint8_t addr = buffer[i];
    a4aa:	6c 4e       	mov.b	@r14,	r12	;

0000a4ac <.LVL93>:
    if ((bank > 4) ||
    a4ac:	68 42       	mov.b	#4,	r8	;r2 As==10
    a4ae:	48 99       	cmp.b	r9,	r8	;
    a4b0:	36 28       	jnc	$+110    	;abs 0xa51e

0000a4b2 <.Loc.335.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    a4b2:	4f 4c       	mov.b	r12,	r15	;
    a4b4:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

0000a4b8 <.Loc.334.1>:
    if ((bank > 4) ||
    a4b8:	78 40 09 00 	mov.b	#9,	r8	;
    a4bc:	48 9f       	cmp.b	r15,	r8	;
    a4be:	2f 2c       	jc	$+96     	;abs 0xa51e

0000a4c0 <.Loc.336.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    a4c0:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

0000a4c4 <.Loc.335.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    a4c4:	78 42       	mov.b	#8,	r8	;r2 As==11
    a4c6:	48 9f       	cmp.b	r15,	r8	;
    a4c8:	2a 2c       	jc	$+86     	;abs 0xa51e

0000a4ca <.Loc.337.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a4ca:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

0000a4ce <.Loc.336.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    a4ce:	78 40 35 00 	mov.b	#53,	r8	;#0x0035
    a4d2:	48 9f       	cmp.b	r15,	r8	;
    a4d4:	24 2c       	jc	$+74     	;abs 0xa51e
    a4d6:	ae 00 01 00 	adda	#1,	r14	;

0000a4da <.LVL94>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a4da:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    a4de:	4f 9c       	cmp.b	r12,	r15	;
    a4e0:	1e 28       	jnc	$+62     	;abs 0xa51e

0000a4e2 <.LBE55>:
  for (int i = 0; i < n; i++) {
    a4e2:	1d 53       	inc	r13		;
    a4e4:	80 00 88 a4 	mova	#42120,	r0	;0x0a488

0000a4e8 <.L101>:
      *(buffer+i-1) = bank0p[addr];
    a4e8:	68 4a       	mov.b	@r10,	r8	;
    a4ea:	40 18 0c 48 	movx.w	r8,	r12	;
    a4ee:	cf 18 da 4c 	movx.b	68270(r12),-1(r10)	;0x10aae, 0xfffff
    a4f2:	ae 0a ff ff 

0000a4f6 <.LBE64>:
    for (int i = 0; i < n; i++) {
    a4f6:	19 53       	inc	r9		;
    a4f8:	aa 00 01 00 	adda	#1,	r10	;

0000a4fc <.L99>:
    a4fc:	09 97       	cmp	r7,	r9	;
    a4fe:	f4 23       	jnz	$-22     	;abs 0xa4e8

0000a500 <.L109>:
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    a500:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a502 <.L97>:
}
    a502:	55 16       	popm.a	#6,	r10	;20-bit words
    a504:	10 01       	reta			;

0000a506 <.L102>:
      fram_reg(1, bank, addr, (buffer+i-1));
    a506:	cf 0a       	mova	r10,	r15	;
    a508:	af 0f ff ff 	adda	#1048575,r15	;0xfffff
    a50c:	6e 4a       	mov.b	@r10,	r14	;
    a50e:	4d 49       	mov.b	r9,	r13	;
    a510:	4c 46       	mov.b	r6,	r12	;
    a512:	48 13       	calla	r8		;

0000a514 <.LBE59>:
    for (int i = 0; i < n; i++) {
    a514:	15 53       	inc	r5		;
    a516:	aa 00 01 00 	adda	#1,	r10	;
    a51a:	80 00 98 a4 	mova	#42136,	r0	;0x0a498

0000a51e <.L107>:
      return false; /* other bits handled outside */
    a51e:	4c 43       	clr.b	r12		;

0000a520 <.LVL104>:
    a520:	80 00 02 a5 	mova	#42242,	r0	;0x0a502

0000a524 <elyRegSet>:

bool elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a524:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a526 <.LCFI8>:
    a526:	b1 00 04 00 	suba	#4,	r1	;

0000a52a <.LCFI9>:
    a52a:	49 4c       	mov.b	r12,	r9	;
    a52c:	ca 0d       	mova	r13,	r10	;
    a52e:	45 4e       	mov.b	r14,	r5	;

0000a530 <.Loc.365.1>:
  regs_in_progress = n;
    a530:	40 18 c2 45 	movx.b	r5,	&0xfd054;
    a534:	54 d0 

0000a536 <.LBB73>:
  
  for (int i = 0; i < n * 2; i += 2) {
    a536:	05 55       	rla	r5		;
    a538:	c4 0d       	mova	r13,	r4	;
    a53a:	cc 0d       	mova	r13,	r12	;

0000a53c <.LVL107>:
    a53c:	4d 43       	clr.b	r13		;

0000a53e <.LBB74>:
    uint8_t addr = buffer[i];
    
    if ((bank == 0) || (bank > 4) ||
    a53e:	4f 49       	mov.b	r9,	r15	;
    a540:	7f 53       	add.b	#-1,	r15	;r3 As==11

0000a542 <.L111>:
  for (int i = 0; i < n * 2; i += 2) {
    a542:	0d 95       	cmp	r5,	r13	;
    a544:	13 38       	jl	$+40     	;abs 0xa56c
    a546:	aa 00 01 00 	adda	#1,	r10	;

0000a54a <.Loc.367.1>:
    a54a:	47 43       	clr.b	r7		;

0000a54c <.LBB77>:
  }

  for (int i = 0; i < n * 2; i += 2) {
    uint8_t addr = buffer[i];
    uint8_t value = buffer[i+1];
    value = elyClampReg(addr, value);
    a54c:	86 00 90 a2 	mova	#41616,	r6	;0x0a290

0000a550 <.Loc.384.1>:
  
    /* Write the register */
    fram_reg(0, bank, addr, &buffer[i+1]);
    a550:	88 00 44 a1 	mova	#41284,	r8	;0x0a144

0000a554 <.L114>:
  for (int i = 0; i < n * 2; i += 2) {
    a554:	07 95       	cmp	r5,	r7	;
    a556:	25 38       	jl	$+76     	;abs 0xa5a2

0000a558 <.LBB80>:
    a558:	4d 43       	clr.b	r13		;
    a55a:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a55e:	b0 13 b2 48 	calla	#18610		;0x048b2

0000a562 <.LBE80>:
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    a562:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a564 <.L112>:
}
    a564:	a1 00 04 00 	adda	#4,	r1	;
    a568:	64 16       	popm.a	#7,	r10	;20-bit words
    a56a:	10 01       	reta			;

0000a56c <.L113>:
    uint8_t addr = buffer[i];
    a56c:	6e 4c       	mov.b	@r12,	r14	;

0000a56e <.LVL115>:
    if ((bank == 0) || (bank > 4) ||
    a56e:	77 40 03 00 	mov.b	#3,	r7	;
    a572:	47 9f       	cmp.b	r15,	r7	;
    a574:	28 28       	jnc	$+82     	;abs 0xa5c6

0000a576 <.Loc.371.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    a576:	48 4e       	mov.b	r14,	r8	;
    a578:	78 50 aa ff 	add.b	#-86,	r8	;#0xffaa

0000a57c <.Loc.370.1>:
    if ((bank == 0) || (bank > 4) ||
    a57c:	77 40 29 00 	mov.b	#41,	r7	;#0x0029
    a580:	47 98       	cmp.b	r8,	r7	;
    a582:	21 2c       	jc	$+68     	;abs 0xa5c6

0000a584 <.Loc.372.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a584:	78 50 cc ff 	add.b	#-52,	r8	;#0xffcc

0000a588 <.Loc.371.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    a588:	77 40 35 00 	mov.b	#53,	r7	;#0x0035
    a58c:	47 98       	cmp.b	r8,	r7	;
    a58e:	1b 2c       	jc	$+56     	;abs 0xa5c6
    a590:	ac 00 02 00 	adda	#2,	r12	;

0000a594 <.LVL116>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    a594:	78 40 d4 ff 	mov.b	#-44,	r8	;#0xffd4
    a598:	48 9e       	cmp.b	r14,	r8	;
    a59a:	15 28       	jnc	$+44     	;abs 0xa5c6

0000a59c <.LBE75>:
  for (int i = 0; i < n * 2; i += 2) {
    a59c:	2d 53       	incd	r13		;
    a59e:	80 00 42 a5 	mova	#42306,	r0	;0x0a542

0000a5a2 <.L115>:
    uint8_t addr = buffer[i];
    a5a2:	6e 44       	mov.b	@r4,	r14	;

0000a5a4 <.LVL119>:
    value = elyClampReg(addr, value);
    a5a4:	6d 4a       	mov.b	@r10,	r13	;
    a5a6:	4c 4e       	mov.b	r14,	r12	;
    a5a8:	71 0e 00 00 	mova	r14,	0(r1)	;

0000a5ac <.LVL120>:
    a5ac:	46 13       	calla	r6		;

0000a5ae <.LVL121>:
    fram_reg(0, bank, addr, &buffer[i+1]);
    a5ae:	cf 0a       	mova	r10,	r15	;
    a5b0:	0e 01       	mova	@r1,	r14	;
    a5b2:	4d 49       	mov.b	r9,	r13	;
    a5b4:	4c 43       	clr.b	r12		;
    a5b6:	48 13       	calla	r8		;

0000a5b8 <.LBE79>:
  for (int i = 0; i < n * 2; i += 2) {
    a5b8:	27 53       	incd	r7		;
    a5ba:	a4 00 02 00 	adda	#2,	r4	;
    a5be:	aa 00 02 00 	adda	#2,	r10	;
    a5c2:	80 00 54 a5 	mova	#42324,	r0	;0x0a554

0000a5c6 <.L119>:
      return false; /* other bits handled outside */
    a5c6:	4c 43       	clr.b	r12		;
    a5c8:	80 00 64 a5 	mova	#42340,	r0	;0x0a564

0000a5cc <elyRegGetBlock>:

bool elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a5cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a5ce <.LCFI10>:
    a5ce:	b1 00 02 00 	suba	#2,	r1	;

0000a5d2 <.LCFI11>:
    a5d2:	4b 4c       	mov.b	r12,	r11	;
    a5d4:	cc 0d       	mova	r13,	r12	;

0000a5d6 <.LVL126>:
    a5d6:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    a5da:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

0000a5de <.Loc.396.1>:
  
  if (bank > 4 || 
    a5de:	6a 42       	mov.b	#4,	r10	;r2 As==10
    a5e0:	4a 9b       	cmp.b	r11,	r10	;
    a5e2:	40 28       	jnc	$+130    	;abs 0xa664

0000a5e4 <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a5e4:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    a5e8:	57 00 
    a5ea:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a5ee <.LVL127>:
  if (bank > 4 || 
    a5ee:	0e 9d       	cmp	r13,	r14	;
    a5f0:	04 38       	jl	$+10     	;abs 0xa5fa

0000a5f2 <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a5f2:	7d 40 5f 00 	mov.b	#95,	r13	;#0x005f
    a5f6:	4d 9e       	cmp.b	r14,	r13	;
    a5f8:	35 2c       	jc	$+108    	;abs 0xa664

0000a5fa <.L122>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    a5fa:	4d 4e       	mov.b	r14,	r13	;
    a5fc:	7d 50 89 ff 	add.b	#-119,	r13	;#0xff89

0000a600 <.Loc.397.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    a600:	7a 42       	mov.b	#8,	r10	;r2 As==11
    a602:	4a 9d       	cmp.b	r13,	r10	;
    a604:	2f 2c       	jc	$+96     	;abs 0xa664

0000a606 <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a606:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    a60a:	8b 00 
    a60c:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a610 <.Loc.398.1>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    a610:	0e 9d       	cmp	r13,	r14	;
    a612:	04 38       	jl	$+10     	;abs 0xa61c

0000a614 <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a614:	7d 40 bf ff 	mov.b	#-65,	r13	;#0xffbf
    a618:	4d 9e       	cmp.b	r14,	r13	;
    a61a:	24 2c       	jc	$+74     	;abs 0xa664

0000a61c <.L123>:
      (addr >= RegDLLMAX - n + 1)) {
    a61c:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    a620:	d6 00 
    a622:	40 18 0d 8f 	subx.w	r15,	r13	;

0000a626 <.Loc.399.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a626:	0e 9d       	cmp	r13,	r14	;
    a628:	1d 34       	jge	$+60     	;abs 0xa664

0000a62a <.Loc.404.1>:
    return false; /* Other bits handled outside */
  }
  
  if (bank == 0) {
    a62a:	0b 93       	cmp	#0,	r11	;r3 As==00
    a62c:	0d 20       	jnz	$+28     	;abs 0xa648

0000a62e <.Loc.405.1>:
    memcpy(buffer, bank0p + addr, n);
    a62e:	40 18 0d 4e 	movx.w	r14,	r13	;
    a632:	40 18 0e 4f 	movx.w	r15,	r14	;

0000a636 <.LVL128>:
    a636:	ad 01 ae 0a 	adda	#68270,	r13	;0x10aae

0000a63a <.LVL129>:
    a63a:	b0 13 c4 cd 	calla	#52676		;0x0cdc4

0000a63e <.L130>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    a63e:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a640 <.L121>:
}
    a640:	a1 00 02 00 	adda	#2,	r1	;
    a644:	0a 16       	popm.a	#1,	r10	;20-bit words
    a646:	10 01       	reta			;

0000a648 <.L124>:
    fram_block(1, bank, addr, buffer, n);
    a648:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    a64c:	cf 0c       	mova	r12,	r15	;
    a64e:	4d 4b       	mov.b	r11,	r13	;
    a650:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a652 <.LVL132>:
    a652:	b0 13 ce a1 	calla	#41422		;0x0a1ce

0000a656 <.LBB87>:
    a656:	4d 43       	clr.b	r13		;
    a658:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a65c:	b0 13 b2 48 	calla	#18610		;0x048b2

0000a660 <.LVL134>:
    a660:	80 00 3e a6 	mova	#42558,	r0	;0x0a63e

0000a664 <.L129>:
    return false; /* Other bits handled outside */
    a664:	4c 43       	clr.b	r12		;

0000a666 <.LVL136>:
    a666:	80 00 40 a6 	mova	#42560,	r0	;0x0a640

0000a66a <elyRegSetBlock>:

bool elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a66a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a66c <.LCFI12>:
    a66c:	b1 00 02 00 	suba	#2,	r1	;

0000a670 <.LCFI13>:
    a670:	49 4c       	mov.b	r12,	r9	;
    a672:	c8 0d       	mova	r13,	r8	;
    a674:	4a 4e       	mov.b	r14,	r10	;
    a676:	47 4f       	mov.b	r15,	r7	;

0000a678 <.Loc.420.1>:
  
  if (bank == 0 || bank > 4 || 
    a678:	4c 49       	mov.b	r9,	r12	;

0000a67a <.LVL138>:
    a67a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a67c:	7d 40 03 00 	mov.b	#3,	r13	;

0000a680 <.LVL139>:
    a680:	4d 9c       	cmp.b	r12,	r13	;
    a682:	3e 28       	jnc	$+126    	;abs 0xa700

0000a684 <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a684:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    a688:	57 00 
    a68a:	40 18 0c 87 	subx.w	r7,	r12	;

0000a68e <.Loc.420.1>:
  if (bank == 0 || bank > 4 || 
    a68e:	0a 9c       	cmp	r12,	r10	;
    a690:	02 38       	jl	$+6      	;abs 0xa696

0000a692 <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a692:	4a 93       	cmp.b	#0,	r10	;r3 As==00
    a694:	35 34       	jge	$+108    	;abs 0xa700

0000a696 <.L133>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a696:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    a69a:	8b 00 
    a69c:	40 18 0c 87 	subx.w	r7,	r12	;

0000a6a0 <.Loc.421.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    a6a0:	0a 9c       	cmp	r12,	r10	;
    a6a2:	04 38       	jl	$+10     	;abs 0xa6ac

0000a6a4 <.Loc.422.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a6a4:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    a6a8:	4c 9a       	cmp.b	r10,	r12	;
    a6aa:	2a 2c       	jc	$+86     	;abs 0xa700

0000a6ac <.L134>:
      (addr >= RegDLLMAX - n + 1)) {
    a6ac:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    a6b0:	d6 00 
    a6b2:	40 18 0c 87 	subx.w	r7,	r12	;

0000a6b6 <.Loc.422.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    a6b6:	0a 9c       	cmp	r12,	r10	;
    a6b8:	23 34       	jge	$+72     	;abs 0xa700
    a6ba:	c4 08       	mova	r8,	r4	;

0000a6bc <.Loc.422.1>:
    a6bc:	45 43       	clr.b	r5		;

0000a6be <.LBB92>:
    return false; /* Other bits handled outside */
  }
  
  for (int i = 0; i < n; i++) {
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a6be:	86 00 90 a2 	mova	#41616,	r6	;0x0a290

0000a6c2 <.L135>:
  for (int i = 0; i < n; i++) {
    a6c2:	05 97       	cmp	r7,	r5	;
    a6c4:	12 38       	jl	$+38     	;abs 0xa6ea

0000a6c6 <.LBE92>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    a6c6:	c1 47 00 00 	mov.b	r7,	0(r1)	;
    a6ca:	cf 08       	mova	r8,	r15	;
    a6cc:	4e 4a       	mov.b	r10,	r14	;
    a6ce:	4d 49       	mov.b	r9,	r13	;
    a6d0:	4c 43       	clr.b	r12		;
    a6d2:	b0 13 ce a1 	calla	#41422		;0x0a1ce

0000a6d6 <.LBB93>:
    a6d6:	4d 43       	clr.b	r13		;
    a6d8:	8c 00 56 d0 	mova	#53334,	r12	;0x0d056
    a6dc:	b0 13 b2 48 	calla	#18610		;0x048b2

0000a6e0 <.LBE93>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    a6e0:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a6e2 <.L132>:
}
    a6e2:	a1 00 02 00 	adda	#2,	r1	;
    a6e6:	64 16       	popm.a	#7,	r10	;20-bit words
    a6e8:	10 01       	reta			;

0000a6ea <.L136>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a6ea:	6d 44       	mov.b	@r4,	r13	;
    a6ec:	4c 45       	mov.b	r5,	r12	;
    a6ee:	4c 5a       	add.b	r10,	r12	;
    a6f0:	46 13       	calla	r6		;

0000a6f2 <.LVL145>:
    a6f2:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000a6f6 <.Loc.427.1>:
  for (int i = 0; i < n; i++) {
    a6f6:	15 53       	inc	r5		;
    a6f8:	a4 00 01 00 	adda	#1,	r4	;
    a6fc:	80 00 c2 a6 	mova	#42690,	r0	;0x0a6c2

0000a700 <.L140>:
    return false; /* Other bits handled outside */
    a700:	4c 43       	clr.b	r12		;
    a702:	80 00 e2 a6 	mova	#42722,	r0	;0x0a6e2

0000a706 <calc_next_buff>:
static const uint8_t * next_tx_ptr;
static slip_uart_states_t tx_state = ELY_SLIP_NOT_ESCAPED;

static thread_t * uart_thd;
    
void calc_next_buff(void) {
    a706:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a708 <.LCFI0>:
    a708:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a70a <.LCFI1>:
  
  switch (tx_state) {
    a70a:	c0 18 5c 42 	movx.b	&0x10bb4,r12	;
    a70e:	b4 0b 
    a710:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a712:	2f 24       	jz	$+96     	;abs 0xa772
    a714:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a716:	59 20       	jnz	$+180    	;abs 0xa7ca

0000a718 <.Loc.28.1>:
    case ELY_SLIP_NOT_ESCAPED:
      next_tx_ptr = tx_read_ptr;
    a718:	2c 00 66 d0 	mova	&53350,	r12	;0x0d066
    a71c:	60 0c 5e d0 	mova	r12,	&53342	; 0x0d05e

0000a720 <.Loc.29.1>:
      next_cnt = 0;
    a720:	00 18 c2 43 	movx.a	#0,	&0xfd062;r3 As==00
    a724:	62 d0 

0000a726 <.Loc.30.1>:
      while (next_cnt != tx_n && 
    a726:	28 00 6a d0 	mova	&53354,	r8	;0x0d06a
    a72a:	4e 43       	clr.b	r14		;
    a72c:	4d 43       	clr.b	r13		;
    a72e:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000a730 <.L5>:
    a730:	d8 0e       	cmpa	r14,	r8	;
    a732:	0f 20       	jnz	$+32     	;abs 0xa752

0000a734 <.L33>:
    a734:	0d 93       	cmp	#0,	r13	;r3 As==00
    a736:	04 24       	jz	$+10     	;abs 0xa740
    a738:	60 0e 62 d0 	mova	r14,	&53346	; 0x0d062
    a73c:	60 0c 66 d0 	mova	r12,	&53350	; 0x0d066

0000a740 <.L11>:
          *tx_read_ptr != SLIP_END && 
          *tx_read_ptr != SLIP_ESC) {
        next_cnt++;
        tx_read_ptr++;
      }
      tx_state = ELY_SLIP_ESCAPED;
    a740:	41 18 d2 43 	movx.b	#1,	&0x10bb4;r3 As==01
    a744:	b4 0b 

0000a746 <.Loc.37.1>:
      if (next_cnt > 0) {
    a746:	9e 00 00 00 	cmpa	#0,	r14	;
    a74a:	13 24       	jz	$+40     	;abs 0xa772

0000a74c <.L1>:
      chDbgAssert(false, "State machine error");
      /* ACTUALLY can't happen */
      break;
  }
            
}
    a74c:	08 16       	popm.a	#1,	r8	;20-bit words
    a74e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a750:	10 01       	reta			;

0000a752 <.L6>:
      while (next_cnt != tx_n && 
    a752:	6f 4c       	mov.b	@r12,	r15	;
    a754:	7f 90 c0 ff 	cmp.b	#-64,	r15	;#0xffc0
    a758:	ed 27       	jz	$-36     	;abs 0xa734
    a75a:	ca 0e       	mova	r14,	r10	;
    a75c:	aa 00 01 00 	adda	#1,	r10	;

0000a760 <.Loc.31.1>:
          *tx_read_ptr != SLIP_END && 
    a760:	7f 90 db ff 	cmp.b	#-37,	r15	;#0xffdb
    a764:	e7 27       	jz	$-48     	;abs 0xa734

0000a766 <.Loc.34.1>:
        tx_read_ptr++;
    a766:	ac 00 01 00 	adda	#1,	r12	;
    a76a:	0d 4b       	mov	r11,	r13	;
    a76c:	ce 0a       	mova	r10,	r14	;
    a76e:	80 00 30 a7 	mova	#42800,	r0	;0x0a730

0000a772 <.L3>:
        switch(*tx_read_ptr++) {
    a772:	2c 00 66 d0 	mova	&53350,	r12	;0x0d066
    a776:	cd 0c       	mova	r12,	r13	;
    a778:	ad 00 01 00 	adda	#1,	r13	;
    a77c:	60 0d 66 d0 	mova	r13,	&53350	; 0x0d066
    a780:	6c 4c       	mov.b	@r12,	r12	;
    a782:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    a786:	12 24       	jz	$+38     	;abs 0xa7ac
    a788:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    a78c:	15 20       	jnz	$+44     	;abs 0xa7b8

0000a78e <.Loc.44.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    a78e:	80 18 f2 40 	movx.a	#67722,	&0xfd05e;0x1088a
    a792:	8a 08 5e d0 

0000a796 <.L17>:
        next_cnt = 2;
    a796:	00 18 e2 43 	movx.a	#2,	&0xfd062;r3 As==10
    a79a:	62 d0 

0000a79c <.Loc.58.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    a79c:	00 18 d2 53 	incx.a	&0xd06a		;
    a7a0:	6a d0 

0000a7a2 <.Loc.59.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    a7a2:	41 18 e2 43 	movx.b	#2,	&0x10bb4;r3 As==10
    a7a6:	b4 0b 
    a7a8:	80 00 4c a7 	mova	#42828,	r0	;0x0a74c

0000a7ac <.L15>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    a7ac:	80 18 f2 40 	movx.a	#67720,	&0xfd05e;0x10888
    a7b0:	88 08 5e d0 
    a7b4:	80 00 96 a7 	mova	#42902,	r0	;0x0a796

0000a7b8 <.L31>:
            chDbgAssert(false, "state machine error");
    a7b8:	8c 01 79 08 	mova	#67705,	r12	;0x10879
    a7bc:	b0 13 3e 46 	calla	#17982		;0x0463e

0000a7c0 <.LVL0>:
            tx_n--;
    a7c0:	00 18 f2 53 	addx.a	#-1,	&0xfd06a;r3 As==11
    a7c4:	6a d0 
    a7c6:	80 00 96 a7 	mova	#42902,	r0	;0x0a796

0000a7ca <.L30>:
      chDbgAssert(false, "State machine error");
    a7ca:	8c 01 79 08 	mova	#67705,	r12	;0x10879
    a7ce:	b0 13 3e 46 	calla	#17982		;0x0463e

0000a7d2 <.LVL1>:
}
    a7d2:	80 00 4c a7 	mova	#42828,	r0	;0x0a74c

0000a7d6 <elyUARTDLLTxCB>:

void elyUARTDLLTxCB(UARTDriver * uartp) {
  static bool done = false;
  static const uint8_t END = SLIP_END;
  
  if (done) {
    a7d6:	40 18 c2 93 	cmpx.b	#0,	&0xfd058;r3 As==00
    a7da:	58 d0 
    a7dc:	04 24       	jz	$+10     	;abs 0xa7e6

0000a7de <.Loc.75.1>:
    done = false;
    a7de:	40 18 c2 43 	movx.b	#0,	&0xfd058;r3 As==00
    a7e2:	58 d0 

0000a7e4 <.L34>:
    next_cnt = 1;
    return;
  }
  
  calc_next_buff();
}
    a7e4:	10 01       	reta			;

0000a7e6 <.L35>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    a7e6:	2e 00 5e d0 	mova	&53342,	r14	;0x0d05e
    a7ea:	2d 00 62 d0 	mova	&53346,	r13	;0x0d062
    a7ee:	b0 13 a8 50 	calla	#20648		;0x050a8

0000a7f2 <.LVL5>:
  if (tx_n == 0) {
    a7f2:	2c 00 6a d0 	mova	&53354,	r12	;0x0d06a
    a7f6:	9c 00 00 00 	cmpa	#0,	r12	;
    a7fa:	05 20       	jnz	$+12     	;abs 0xa806

0000a7fc <.Loc.84.1>:
    done = true;
    a7fc:	40 18 d2 43 	movx.b	#1,	&0xfd058;r3 As==01
    a800:	58 d0 

0000a802 <.Loc.85.1>:
    return;
    a802:	80 00 e4 a7 	mova	#42980,	r0	;0x0a7e4

0000a806 <.L37>:
  tx_n -= next_cnt;
    a806:	00 18 5c 82 	subx.a	&0x0d062,r12	;
    a80a:	62 d0 
    a80c:	60 0c 6a d0 	mova	r12,	&53354	; 0x0d06a

0000a810 <.Loc.90.1>:
  if (tx_n == 0) {
    a810:	9c 00 00 00 	cmpa	#0,	r12	;
    a814:	0d 20       	jnz	$+28     	;abs 0xa830

0000a816 <.Loc.92.1>:
    elyNLFreeBufferI(tx_active_buffer);
    a816:	2c 00 6e d0 	mova	&53358,	r12	;0x0d06e
    a81a:	b0 13 30 bd 	calla	#48432		;0x0bd30

0000a81e <.LVL6>:
    next_tx_ptr = &END;
    a81e:	80 18 f2 40 	movx.a	#67704,	&0xfd05e;0x10878
    a822:	78 08 5e d0 

0000a826 <.Loc.95.1>:
    next_cnt = 1;
    a826:	00 18 d2 43 	movx.a	#1,	&0xfd062;r3 As==01
    a82a:	62 d0 

0000a82c <.Loc.96.1>:
    return;
    a82c:	80 00 e4 a7 	mova	#42980,	r0	;0x0a7e4

0000a830 <.L38>:
  calc_next_buff();
    a830:	b0 13 06 a7 	calla	#42758		;0x0a706

0000a834 <.LVL7>:
    a834:	80 00 e4 a7 	mova	#42980,	r0	;0x0a7e4

0000a838 <elyUARTDLLStartTx>:

void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    a838:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a83a <.LCFI2>:
    a83a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a83c <.LCFI3>:
    a83c:	c8 0c       	mova	r12,	r8	;
    a83e:	ca 0d       	mova	r13,	r10	;

0000a840 <.Loc.105.1>:
  static const uint8_t END = SLIP_END;
  /* Calculate the length of the packet - store it in n */
  tx_n = elyNLGetLength(buffer);
    a840:	cc 0d       	mova	r13,	r12	;

0000a842 <.LVL9>:
    a842:	b0 13 f4 bd 	calla	#48628		;0x0bdf4

0000a846 <.LVL10>:
    a846:	60 0c 6a d0 	mova	r12,	&53354	; 0x0d06a

0000a84a <.Loc.106.1>:
  chDbgAssert(tx_n != 0 && tx_n <= elyNLMaxLen, "invalid packet length");
    a84a:	9c 00 00 00 	cmpa	#0,	r12	;
    a84e:	04 24       	jz	$+10     	;abs 0xa858

0000a850 <.Loc.106.1>:
    a850:	01 18 c2 9c 	cmpx.a	r12,	&0x10cd6;
    a854:	d6 0c 
    a856:	04 2c       	jc	$+10     	;abs 0xa860

0000a858 <.L40>:
    a858:	8c 01 66 08 	mova	#67686,	r12	;0x10866
    a85c:	b0 13 3e 46 	calla	#17982		;0x0463e

0000a860 <.L41>:
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    a860:	2c 00 6a d0 	mova	&53354,	r12	;0x0d06a
    a864:	9c 00 00 00 	cmpa	#0,	r12	;
    a868:	04 24       	jz	$+10     	;abs 0xa872

0000a86a <.Loc.107.1>:
    a86a:	01 18 c2 9c 	cmpx.a	r12,	&0x10cd6;
    a86e:	d6 0c 
    a870:	03 2c       	jc	$+8      	;abs 0xa878

0000a872 <.L42>:
    /* TODO signal an error here */
    elyNLFreeBuffer(buffer);
    a872:	cc 0a       	mova	r10,	r12	;
    a874:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000a878 <.L43>:
  }
  tx_read_ptr = buffer;
    a878:	60 0a 66 d0 	mova	r10,	&53350	; 0x0d066

0000a87c <.Loc.112.1>:
  tx_active_buffer = buffer;
    a87c:	60 0a 6e d0 	mova	r10,	&53358	; 0x0d06e

0000a880 <.Loc.113.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    a880:	41 18 e2 43 	movx.b	#2,	&0x10bb4;r3 As==10
    a884:	b4 0b 

0000a886 <.Loc.115.1>:
  
  calc_next_buff();
    a886:	8a 00 06 a7 	mova	#42758,	r10	;0x0a706

0000a88a <.LVL13>:
    a88a:	4a 13       	calla	r10		;

0000a88c <.LBB32>:
  _disable_interrupts();
    a88c:	32 c2       	dint			
    a88e:	03 43       	nop			

0000a890 <.Loc.348.2>:
  asm volatile("nop");
    a890:	03 43       	nop			

0000a892 <.LBE32>:
  
  chSysLock();
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    a892:	2e 00 5e d0 	mova	&53342,	r14	;0x0d05e
    a896:	2d 00 62 d0 	mova	&53346,	r13	;0x0d062
    a89a:	cc 08       	mova	r8,	r12	;
    a89c:	b0 13 a8 50 	calla	#20648		;0x050a8

0000a8a0 <.LVL15>:
  
  tx_n -= next_cnt;
    a8a0:	2c 00 6a d0 	mova	&53354,	r12	;0x0d06a
    a8a4:	00 18 5c 82 	subx.a	&0x0d062,r12	;
    a8a8:	62 d0 
    a8aa:	60 0c 6a d0 	mova	r12,	&53354	; 0x0d06a

0000a8ae <.Loc.122.1>:
  
  if (tx_n == 0) {
    a8ae:	9c 00 00 00 	cmpa	#0,	r12	;
    a8b2:	12 20       	jnz	$+38     	;abs 0xa8d8

0000a8b4 <.Loc.123.1>:
    elyNLFreeBufferI(tx_active_buffer);
    a8b4:	2c 00 6e d0 	mova	&53358,	r12	;0x0d06e
    a8b8:	b0 13 30 bd 	calla	#48432		;0x0bd30

0000a8bc <.LVL16>:
    next_tx_ptr = &END;
    a8bc:	80 18 f2 40 	movx.a	#67685,	&0xfd05e;0x10865
    a8c0:	65 08 5e d0 

0000a8c4 <.Loc.125.1>:
    next_cnt = 1;
    a8c4:	00 18 d2 43 	movx.a	#1,	&0xfd062;r3 As==01
    a8c8:	62 d0 

0000a8ca <.L52>:
  asm volatile("nop");
    a8ca:	03 43       	nop			

0000a8cc <.Loc.356.2>:
  _enable_interrupts();
    a8cc:	03 43       	nop			
    a8ce:	32 d2       	eint			
    a8d0:	03 43       	nop			

0000a8d2 <.LBE34>:
  }
  
  calc_next_buff();
  chSysUnlock();
  
}
    a8d2:	08 16       	popm.a	#1,	r8	;20-bit words
    a8d4:	0a 16       	popm.a	#1,	r10	;20-bit words
    a8d6:	10 01       	reta			;

0000a8d8 <.L44>:
  calc_next_buff();
    a8d8:	4a 13       	calla	r10		;

0000a8da <.LVL17>:
    a8da:	80 00 ca a8 	mova	#43210,	r0	;0x0a8ca

0000a8de <elyUARTDLLRxInit>:

void elyUARTDLLRxInit(UARTDriver * uartp) {
  (void)(uartp);
  
  uart_thd = chThdGetSelfX();
    a8de:	80 18 d2 42 	movx.a	&0x114ea,&0xfd05a;
    a8e2:	ea 14 5a d0 

0000a8e6 <.Loc.139.1>:
}
    a8e6:	10 01       	reta			;

0000a8e8 <elyUARTDLLRxHandleBuffer>:
    rx_state = ELY_SLIP_RESET;
  }

}

void elyUARTDLLRxHandleBuffer() {
    a8e8:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a8ea <.LCFI4>:
  handle_buffer(bytes_available, curr_rx_buf);
    a8ea:	28 00 72 d0 	mova	&53362,	r8	;0x0d072
    a8ee:	2a 01 ba 0b 	mova	&68538,	r10	;0x10bba

0000a8f2 <.LBB39>:
  const uint8_t * end = buffer + bytes_available;
    a8f2:	c5 0a       	mova	r10,	r5	;
    a8f4:	e5 08       	adda	r8,	r5	;

0000a8f6 <.LBB41>:
        rx_active_buffer = elyNLGetBuffer();
    a8f6:	87 00 1a bd 	mova	#48410,	r7	;0x0bd1a

0000a8fa <.Loc.228.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    a8fa:	84 00 f4 bd 	mova	#48628,	r4	;0x0bdf4

0000a8fe <.Loc.222.1>:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    a8fe:	86 00 3e 46 	mova	#17982,	r6	;0x0463e

0000a902 <.L55>:
  while (cp < end) {
    a902:	da 05       	cmpa	r5,	r10	;
    a904:	1c 28       	jnc	$+58     	;abs 0xa93e

0000a906 <.Loc.237.1>:
  if (bytes_available < SLIP_RX_BUF_LEN) {
    a906:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    a90a:	dc 08       	cmpa	r8,	r12	;
    a90c:	0d 28       	jnc	$+28     	;abs 0xa928

0000a90e <.Loc.238.1>:
    if (NULL != rx_active_buffer) {
    a90e:	2c 00 7a d0 	mova	&53370,	r12	;0x0d07a
    a912:	9c 00 00 00 	cmpa	#0,	r12	;
    a916:	05 24       	jz	$+12     	;abs 0xa922

0000a918 <.Loc.239.1>:
      elyNLFreeBuffer(rx_active_buffer);
    a918:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000a91c <.LVL22>:
      rx_active_buffer = NULL;
    a91c:	00 18 c2 43 	movx.a	#0,	&0xfd07a;r3 As==00
    a920:	7a d0 

0000a922 <.L78>:
    rx_state = ELY_SLIP_RESET;
    a922:	40 18 c2 43 	movx.b	#0,	&0xfd07e;r3 As==00
    a926:	7e d0 

0000a928 <.L59>:
  
  if (curr_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    a928:	01 18 f2 90 	cmpx.a	#53631,	&0x10bba;0x0d17f
    a92c:	7f d1 ba 0b 
    a930:	a9 20       	jnz	$+340    	;abs 0xaa84

0000a932 <.Loc.251.1>:
    curr_rx_buf = rx_buf;
    a932:	01 18 f2 40 	movx.a	#53375,	&0x10bba;0x0d07f
    a936:	7f d0 ba 0b 

0000a93a <.L54>:
  }
  else {
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
}
    a93a:	64 16       	popm.a	#7,	r10	;20-bit words
    a93c:	10 01       	reta			;

0000a93e <.L76>:
    uint8_t c = *cp;
    a93e:	69 4a       	mov.b	@r10,	r9	;

0000a940 <.LVL25>:
    if (rx_state == ELY_SLIP_RESET) {
    a940:	40 18 c2 93 	cmpx.b	#0,	&0xfd07e;r3 As==00
    a944:	7e d0 
    a946:	18 20       	jnz	$+50     	;abs 0xa978

0000a948 <.Loc.154.1>:
      if (NULL == rx_active_buffer) {
    a948:	00 18 c2 93 	cmpx.a	#0,	&0xfd07a;r3 As==00
    a94c:	7a d0 
    a94e:	03 20       	jnz	$+8      	;abs 0xa956

0000a950 <.Loc.155.1>:
        rx_active_buffer = elyNLGetBuffer();
    a950:	47 13       	calla	r7		;

0000a952 <.LVL26>:
    a952:	60 0c 7a d0 	mova	r12,	&53370	; 0x0d07a

0000a956 <.L57>:
      if (NULL == rx_active_buffer) {
    a956:	2c 00 7a d0 	mova	&53370,	r12	;0x0d07a
    a95a:	9c 00 00 00 	cmpa	#0,	r12	;
    a95e:	e4 27       	jz	$-54     	;abs 0xa928

0000a960 <.Loc.161.1>:
      rx_write_ptr = rx_active_buffer;
    a960:	60 0c 76 d0 	mova	r12,	&53366	; 0x0d076

0000a964 <.Loc.162.1>:
      rx_n = elyNLHeaderLen;
    a964:	01 18 f2 40 	movx.a	#6,	&0x10bb0;
    a968:	06 00 b0 0b 

0000a96c <.Loc.163.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    a96c:	40 18 e2 43 	movx.b	#2,	&0xfd07e;r3 As==10
    a970:	7e d0 

0000a972 <.Loc.164.1>:
      header = true;
    a972:	41 18 d2 43 	movx.b	#1,	&0x10bae;r3 As==01
    a976:	ae 0b 

0000a978 <.L56>:
    switch (rx_state) {
    a978:	40 18 5c 42 	movx.b	&0x0d07e,r12	;
    a97c:	7e d0 
    a97e:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a980:	07 24       	jz	$+16     	;abs 0xa990
    a982:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a984:	49 24       	jz	$+148    	;abs 0xaa18

0000a986 <.Loc.222.1>:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    a986:	8c 01 57 08 	mova	#67671,	r12	;0x10857
    a98a:	46 13       	calla	r6		;

0000a98c <.LVL27>:
    a98c:	80 00 ca a9 	mova	#43466,	r0	;0x0a9ca

0000a990 <.L61>:
          switch(c) {
    a990:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    a994:	08 24       	jz	$+18     	;abs 0xa9a6
    a996:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    a99a:	32 24       	jz	$+102    	;abs 0xaa00

0000a99c <.L75>:
        rx_state = ELY_SLIP_RESET;
    a99c:	40 18 c2 43 	movx.b	#0,	&0xfd07e;r3 As==00
    a9a0:	7e d0 
    a9a2:	80 00 02 a9 	mova	#43266,	r0	;0x0a902

0000a9a6 <.L64>:
              *rx_write_ptr++ = SLIP_END;
    a9a6:	2c 00 76 d0 	mova	&53366,	r12	;0x0d076
    a9aa:	cd 0c       	mova	r12,	r13	;
    a9ac:	ad 00 01 00 	adda	#1,	r13	;
    a9b0:	60 0d 76 d0 	mova	r13,	&53366	; 0x0d076
    a9b4:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    a9b8:	00 00 

0000a9ba <.L66>:
          rx_n--;
    a9ba:	01 18 f2 53 	addx.a	#-1,	&0x10bb0;r3 As==11
    a9be:	b0 0b 

0000a9c0 <.Loc.182.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    a9c0:	40 18 e2 43 	movx.b	#2,	&0xfd07e;r3 As==10
    a9c4:	7e d0 

0000a9c6 <.L89>:
                cp++;
    a9c6:	aa 00 01 00 	adda	#1,	r10	;

0000a9ca <.L68>:
    if (rx_n == 0 && header) { /* and we haven't reset */
    a9ca:	01 18 c2 93 	cmpx.a	#0,	&0x10bb0;r3 As==00
    a9ce:	b0 0b 
    a9d0:	98 23       	jnz	$-206    	;abs 0xa902
    a9d2:	41 18 c2 93 	cmpx.b	#0,	&0x10bae;r3 As==00
    a9d6:	ae 0b 
    a9d8:	94 27       	jz	$-214    	;abs 0xa902

0000a9da <.Loc.228.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    a9da:	2c 00 7a d0 	mova	&53370,	r12	;0x0d07a
    a9de:	44 13       	calla	r4		;

0000a9e0 <.LVL29>:
    a9e0:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    a9e4:	61 0c b0 0b 	mova	r12,	&68528	; 0x10bb0

0000a9e8 <.Loc.229.1>:
      header = false;
    a9e8:	41 18 c2 43 	movx.b	#0,	&0x10bae;r3 As==00
    a9ec:	ae 0b 

0000a9ee <.Loc.230.1>:
      if (rx_n == 0 || rx_n > elyNLMaxLen) {
    a9ee:	9c 00 00 00 	cmpa	#0,	r12	;
    a9f2:	d4 27       	jz	$-86     	;abs 0xa99c
    a9f4:	01 18 c2 9c 	cmpx.a	r12,	&0x10cd6;
    a9f8:	d6 0c 
    a9fa:	83 2f       	jc	$-248    	;abs 0xa902
    a9fc:	80 00 9c a9 	mova	#43420,	r0	;0x0a99c

0000aa00 <.L65>:
              *rx_write_ptr++ = SLIP_ESC;
    aa00:	2c 00 76 d0 	mova	&53366,	r12	;0x0d076
    aa04:	cd 0c       	mova	r12,	r13	;
    aa06:	ad 00 01 00 	adda	#1,	r13	;
    aa0a:	60 0d 76 d0 	mova	r13,	&53366	; 0x0d076
    aa0e:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    aa12:	00 00 
    aa14:	80 00 ba a9 	mova	#43450,	r0	;0x0a9ba

0000aa18 <.L62>:
          switch(c) {
    aa18:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    aa1c:	0c 24       	jz	$+26     	;abs 0xaa36
    aa1e:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    aa22:	1c 20       	jnz	$+58     	;abs 0xaa5c

0000aa24 <.Loc.190.1>:
              if (rx_n == 0) {
    aa24:	01 18 c2 93 	cmpx.a	#0,	&0x10bb0;r3 As==00
    aa28:	b0 0b 
    aa2a:	b8 27       	jz	$-142    	;abs 0xa99c

0000aa2c <.Loc.195.1>:
                rx_state = ELY_SLIP_ESCAPED;
    aa2c:	40 18 d2 43 	movx.b	#1,	&0xfd07e;r3 As==01
    aa30:	7e d0 
    aa32:	80 00 c6 a9 	mova	#43462,	r0	;0x0a9c6

0000aa36 <.L70>:
              if (rx_n == 0) {
    aa36:	01 18 c2 93 	cmpx.a	#0,	&0x10bb0;r3 As==00
    aa3a:	b0 0b 
    aa3c:	08 20       	jnz	$+18     	;abs 0xaa4e

0000aa3e <.Loc.202.1>:
                elyMainMBPost(rx_active_buffer, TIME_INFINITE);
    aa3e:	4d 43       	clr.b	r13		;
    aa40:	2c 00 7a d0 	mova	&53370,	r12	;0x0d07a
    aa44:	b0 13 a2 7a 	calla	#31394		;0x07aa2

0000aa48 <.LVL30>:
                rx_active_buffer = NULL;
    aa48:	00 18 c2 43 	movx.a	#0,	&0xfd07a;r3 As==00
    aa4c:	7a d0 

0000aa4e <.L73>:
              rx_state = ELY_SLIP_RESET;
    aa4e:	40 18 c2 43 	movx.b	#0,	&0xfd07e;r3 As==00
    aa52:	7e d0 

0000aa54 <.Loc.206.1>:
              cp++;
    aa54:	aa 00 01 00 	adda	#1,	r10	;
    aa58:	80 00 02 a9 	mova	#43266,	r0	;0x0a902

0000aa5c <.L88>:
              if (rx_n == 0) {
    aa5c:	2c 01 b0 0b 	mova	&68528,	r12	;0x10bb0
    aa60:	9c 00 00 00 	cmpa	#0,	r12	;
    aa64:	9b 27       	jz	$-200    	;abs 0xa99c

0000aa66 <.Loc.214.1>:
                *rx_write_ptr++ = c;
    aa66:	2e 00 76 d0 	mova	&53366,	r14	;0x0d076
    aa6a:	cd 0e       	mova	r14,	r13	;
    aa6c:	ad 00 01 00 	adda	#1,	r13	;
    aa70:	60 0d 76 d0 	mova	r13,	&53366	; 0x0d076
    aa74:	ce 49 00 00 	mov.b	r9,	0(r14)	;

0000aa78 <.Loc.215.1>:
                rx_n--;
    aa78:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    aa7c:	61 0c b0 0b 	mova	r12,	&68528	; 0x10bb0
    aa80:	80 00 c6 a9 	mova	#43462,	r0	;0x0a9c6

0000aa84 <.L79>:
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    aa84:	01 18 f2 40 	movx.a	#53631,	&0x10bba;0x0d17f
    aa88:	7f d1 ba 0b 

0000aa8c <.Loc.256.1>:
}
    aa8c:	80 00 3a a9 	mova	#43322,	r0	;0x0a93a

0000aa90 <elyUARTDLLTimeoutCB>:
/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    aa90:	8c 01 62 16 	mova	#71266,	r12	;0x11662

0000aa94 <.LVL34>:
    aa94:	b0 13 58 51 	calla	#20824		;0x05158

0000aa98 <.LVL35>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    aa98:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    aa9c:	fd 0c       	suba	r12,	r13	;
    aa9e:	60 0d 72 d0 	mova	r13,	&53362	; 0x0d072

0000aaa2 <.Loc.268.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    aaa2:	6d 42       	mov.b	#4,	r13	;r2 As==10
    aaa4:	4e 43       	clr.b	r14		;
    aaa6:	2c 00 5a d0 	mova	&53338,	r12	;0x0d05a

0000aaaa <.LVL36>:
    aaaa:	b0 13 c6 49 	calla	#18886		;0x049c6

0000aaae <.LVL37>:
  chSysUnlockFromISR();

}
    aaae:	10 01       	reta			;

0000aab0 <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    aab0:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000aab2 <.LCFI5>:
    aab2:	c8 0c       	mova	r12,	r8	;
    aab4:	09 4d       	mov	r13,	r9	;

0000aab6 <.Loc.274.1>:
  chDbgAssert(c < 0x100, "invalid char");
    aab6:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

0000aaba <.LVL39>:
    aaba:	0c 9d       	cmp	r13,	r12	;
    aabc:	04 2c       	jc	$+10     	;abs 0xaac6

0000aabe <.Loc.274.1>:
    aabe:	8c 01 44 08 	mova	#67652,	r12	;0x10844
    aac2:	b0 13 3e 46 	calla	#17982		;0x0463e

0000aac6 <.L92>:
  rx_buf[0] = (uint8_t)(c);
    aac6:	8a 00 7f d0 	mova	#53375,	r10	;0x0d07f
    aaca:	ca 49 00 00 	mov.b	r9,	0(r10)	;

0000aace <.Loc.277.1>:
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, rx_buf+1);
    aace:	ce 0a       	mova	r10,	r14	;
    aad0:	ae 00 01 00 	adda	#1,	r14	;
    aad4:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    aad8:	cc 08       	mova	r8,	r12	;
    aada:	b0 13 00 51 	calla	#20736		;0x05100

0000aade <.LVL41>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    aade:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    aae2:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    aae6:	b0 13 76 4e 	calla	#20086		;0x04e76

0000aaea <.LVL42>:
  
  curr_rx_buf = rx_buf;
    aaea:	61 0a ba 0b 	mova	r10,	&68538	; 0x10bba

0000aaee <.Loc.281.1>:
  next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    aaee:	aa 00 00 01 	adda	#256,	r10	;0x00100
    aaf2:	61 0a b6 0b 	mova	r10,	&68534	; 0x10bb6

0000aaf6 <.Loc.284.1>:
  
  chSysUnlockFromISR();
}
    aaf6:	28 16       	popm.a	#3,	r10	;20-bit words
    aaf8:	10 01       	reta			;

0000aafa <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    aafa:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aafc <.LCFI6>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, next_rx_buf); 
    aafc:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    ab00:	2e 01 b6 0b 	mova	&68534,	r14	;0x10bb6
    ab04:	cd 0a       	mova	r10,	r13	;
    ab06:	b0 13 00 51 	calla	#20736		;0x05100

0000ab0a <.LVL44>:
  gptStopTimerI(&uart_gpt);
    ab0a:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    ab0e:	b0 13 bc 4e 	calla	#20156		;0x04ebc

0000ab12 <.LVL45>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    ab12:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    ab16:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    ab1a:	b0 13 76 4e 	calla	#20086		;0x04e76

0000ab1e <.LVL46>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    ab1e:	60 0a 72 d0 	mova	r10,	&53362	; 0x0d072

0000ab22 <.Loc.295.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    ab22:	6d 42       	mov.b	#4,	r13	;r2 As==10
    ab24:	4e 43       	clr.b	r14		;
    ab26:	2c 00 5a d0 	mova	&53338,	r12	;0x0d05a
    ab2a:	b0 13 c6 49 	calla	#18886		;0x049c6

0000ab2e <.LVL47>:
  
  if (next_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    ab2e:	01 18 f2 90 	cmpx.a	#53631,	&0x10bb6;0x0d17f
    ab32:	7f d1 b6 0b 
    ab36:	06 20       	jnz	$+14     	;abs 0xab44

0000ab38 <.Loc.298.1>:
    next_rx_buf = rx_buf;
    ab38:	01 18 f2 40 	movx.a	#53375,	&0x10bb6;0x0d07f
    ab3c:	7f d0 b6 0b 

0000ab40 <.L93>:
  else {
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
  
  chSysUnlockFromISR();
}
    ab40:	0a 16       	popm.a	#1,	r10	;20-bit words
    ab42:	10 01       	reta			;

0000ab44 <.L94>:
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    ab44:	01 18 f2 40 	movx.a	#53631,	&0x10bb6;0x0d17f
    ab48:	7f d1 b6 0b 

0000ab4c <.Loc.305.1>:
}
    ab4c:	80 00 40 ab 	mova	#43840,	r0	;0x0ab40

0000ab50 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    ab50:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ab52 <.LCFI0>:
    ab52:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ab54 <.LCFI1>:
    ab54:	06 14       	pushm.a	#1,	r6	;20-bit words

0000ab56 <.LCFI2>:
    ab56:	ca 0c       	mova	r12,	r10	;
    ab58:	c8 0d       	mova	r13,	r8	;

0000ab5a <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    ab5a:	40 18 c2 93 	cmpx.b	#0,	&0xfd280;r3 As==00
    ab5e:	80 d2 
    ab60:	04 24       	jz	$+10     	;abs 0xab6a

0000ab62 <.Loc.34.1>:
    ab62:	8c 01 a9 08 	mova	#67753,	r12	;0x108a9

0000ab66 <.LVL1>:
    ab66:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ab6a <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    ab6a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ab6c:	dc 08       	cmpa	r8,	r12	;
    ab6e:	04 28       	jnc	$+10     	;abs 0xab78

0000ab70 <.Loc.38.1>:
    ab70:	8c 01 a9 08 	mova	#67753,	r12	;0x108a9
    ab74:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ab78 <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    ab78:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    ab7c:	54 01 

0000ab7e <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    ab7e:	ce 0a       	mova	r10,	r14	;
    ab80:	cc 08       	mova	r8,	r12	;
    ab82:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000ab86 <.L4>:
    ab86:	00 18 46 4e 	movx.a	r14,	r6	;
    ab8a:	00 18 46 8a 	subx.a	r10,	r6	;

0000ab8e <.LVL6>:
    ab8e:	d6 0c       	cmpa	r12,	r6	;
    ab90:	12 28       	jnc	$+38     	;abs 0xabb6

0000ab92 <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    ab92:	ec 0a       	adda	r10,	r12	;
    ab94:	40 18 5d 42 	movx.b	&0x00157,r13	;
    ab98:	57 01 
    ab9a:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    ab9c:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000aba0 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    aba0:	ea 08       	adda	r8,	r10	;

0000aba2 <.LVL7>:
    aba2:	40 18 5c 42 	movx.b	&0x00156,r12	;
    aba6:	56 01 
    aba8:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    abaa:	ca 4c ff ff 	mov.b	r12,	-1(r10)	; 0xffff

0000abae <.Loc.63.1>:
}
    abae:	06 16       	popm.a	#1,	r6	;20-bit words
    abb0:	08 16       	popm.a	#1,	r8	;20-bit words
    abb2:	0a 16       	popm.a	#1,	r10	;20-bit words
    abb4:	10 01       	reta			;

0000abb6 <.L5>:
      CRCDI_L = message[i];
    abb6:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    abba:	50 01 

0000abbc <.LVL9>:
    abbc:	ae 00 01 00 	adda	#1,	r14	;

0000abc0 <.LVL10>:
    abc0:	80 00 86 ab 	mova	#43910,	r0	;0x0ab86

0000abc4 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    abc4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000abc6 <.LCFI3>:
    abc6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000abc8 <.LCFI4>:
    abc8:	06 14       	pushm.a	#1,	r6	;20-bit words

0000abca <.LCFI5>:
    abca:	ca 0c       	mova	r12,	r10	;
    abcc:	c8 0d       	mova	r13,	r8	;

0000abce <.Loc.72.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    abce:	40 18 c2 93 	cmpx.b	#0,	&0xfd280;r3 As==00
    abd2:	80 d2 
    abd4:	04 24       	jz	$+10     	;abs 0xabde

0000abd6 <.Loc.72.1>:
    abd6:	8c 01 9d 08 	mova	#67741,	r12	;0x1089d

0000abda <.LVL12>:
    abda:	b0 13 3e 46 	calla	#17982		;0x0463e

0000abde <.L7>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    abde:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    abe2:	54 01 

0000abe4 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    abe4:	ce 0a       	mova	r10,	r14	;
    abe6:	cc 08       	mova	r8,	r12	;
    abe8:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000abec <.L8>:
    abec:	00 18 46 4e 	movx.a	r14,	r6	;
    abf0:	00 18 46 8a 	subx.a	r10,	r6	;

0000abf4 <.LVL16>:
    abf4:	d6 0c       	cmpa	r12,	r6	;
    abf6:	14 28       	jnc	$+42     	;abs 0xac20

0000abf8 <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    abf8:	ec 0a       	adda	r10,	r12	;
    abfa:	6d 4c       	mov.b	@r12,	r13	;
    abfc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    ac00:	ea 08       	adda	r8,	r10	;

0000ac02 <.LVL17>:
    ac02:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    ac06:	0d da       	bis	r10,	r13	;
    ac08:	40 18 1e 42 	movx.w	&0x00156,r14	;
    ac0c:	56 01 
    ac0e:	3e e3       	inv	r14		;
    ac10:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ac12:	0d 9e       	cmp	r14,	r13	;
    ac14:	01 24       	jz	$+4      	;abs 0xac18
    ac16:	4c 43       	clr.b	r12		;

0000ac18 <.L10>:
}
    ac18:	06 16       	popm.a	#1,	r6	;20-bit words
    ac1a:	08 16       	popm.a	#1,	r8	;20-bit words
    ac1c:	0a 16       	popm.a	#1,	r10	;20-bit words
    ac1e:	10 01       	reta			;

0000ac20 <.L9>:
      CRCDI_L = message[i];
    ac20:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    ac24:	50 01 

0000ac26 <.LVL19>:
    ac26:	ae 00 01 00 	adda	#1,	r14	;

0000ac2a <.LVL20>:
    ac2a:	80 00 ec ab 	mova	#44012,	r0	;0x0abec

0000ac2e <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    ac2e:	40 18 c2 93 	cmpx.b	#0,	&0xfd280;r3 As==00
    ac32:	80 d2 
    ac34:	04 24       	jz	$+10     	;abs 0xac3e

0000ac36 <.Loc.103.1>:
    ac36:	8c 01 94 08 	mova	#67732,	r12	;0x10894
    ac3a:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ac3e <.L12>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    ac3e:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    ac42:	54 01 

0000ac44 <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    ac44:	40 18 d2 43 	movx.b	#1,	&0xfd280;r3 As==01
    ac48:	80 d2 

0000ac4a <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    ac4a:	8c 00 50 01 	mova	#336,	r12	;0x00150
    ac4e:	10 01       	reta			;

0000ac50 <crcStop>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    ac50:	40 18 d2 93 	cmpx.b	#1,	&0xfd280;r3 As==01
    ac54:	80 d2 
    ac56:	04 24       	jz	$+10     	;abs 0xac60

0000ac58 <.Loc.119.1>:
    ac58:	8c 01 8c 08 	mova	#67724,	r12	;0x1088c
    ac5c:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ac60 <.L14>:
  /* Change state */
  crc_state = CRC_STOPPED;
    ac60:	40 18 c2 43 	movx.b	#0,	&0xfd280;r3 As==00
    ac64:	80 d2 

0000ac66 <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    ac66:	40 18 1c 42 	movx.w	&0x00156,r12	;
    ac6a:	56 01 
    ac6c:	3c e3       	inv	r12		;
    ac6e:	10 01       	reta			;

0000ac70 <crcGenSDLP>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenSDLP(uint8_t * message, size_t n) {
    ac70:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ac72 <.LCFI0>:
    ac72:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ac74 <.LCFI1>:
    ac74:	06 14       	pushm.a	#1,	r6	;20-bit words

0000ac76 <.LCFI2>:
    ac76:	ca 0c       	mova	r12,	r10	;
    ac78:	c8 0d       	mova	r13,	r8	;

0000ac7a <.Loc.30.1>:
  /* SDLP CRC is MSB first in and out (CRCDIRB+CRCINIRES), with an initial value
   * of 0xFFFF and no inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    ac7a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ac7c <.LVL1>:
    ac7c:	dc 0d       	cmpa	r13,	r12	;
    ac7e:	04 28       	jnc	$+10     	;abs 0xac88

0000ac80 <.Loc.30.1>:
    ac80:	8c 01 b3 08 	mova	#67763,	r12	;0x108b3
    ac84:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ac88 <.L2>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    ac88:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    ac8c:	54 01 

0000ac8e <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    ac8e:	ce 0a       	mova	r10,	r14	;
    ac90:	cc 08       	mova	r8,	r12	;
    ac92:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

0000ac96 <.L3>:
    ac96:	00 18 46 4e 	movx.a	r14,	r6	;
    ac9a:	00 18 46 8a 	subx.a	r10,	r6	;

0000ac9e <.LVL5>:
    ac9e:	d6 0c       	cmpa	r12,	r6	;
    aca0:	0e 28       	jnc	$+30     	;abs 0xacbe

0000aca2 <.LBE2>:
#endif
  
   
  /* Write result to final 2 bytes */
  /* MSB comes first because of how things are transmitted */
  *(message+n-2) = (CRCINIRES_H);
    aca2:	ec 0a       	adda	r10,	r12	;
    aca4:	40 18 dc 42 	movx.b	&0x00155,0(r12)	;
    aca8:	55 01 00 00 

0000acac <.Loc.55.1>:
  *(message+n-1) = (CRCINIRES_L);
    acac:	ea 08       	adda	r8,	r10	;

0000acae <.LVL6>:
    acae:	4f 18 da 42 	movx.b	&0x00154,-1(r10)	; 0xfffff
    acb2:	54 01 ff ff 

0000acb6 <.Loc.56.1>:
}
    acb6:	06 16       	popm.a	#1,	r6	;20-bit words
    acb8:	08 16       	popm.a	#1,	r8	;20-bit words
    acba:	0a 16       	popm.a	#1,	r10	;20-bit words
    acbc:	10 01       	reta			;

0000acbe <.L4>:
      CRCDIRB_L = message[i];
    acbe:	40 18 e2 4e 	movx.b	@r14,	&0x00152;
    acc2:	52 01 

0000acc4 <.LVL8>:
    acc4:	ae 00 01 00 	adda	#1,	r14	;

0000acc8 <.LVL9>:
    acc8:	80 00 96 ac 	mova	#44182,	r0	;0x0ac96

0000accc <port_lock>:
  _disable_interrupts();
    accc:	32 c2       	dint			
    acce:	03 43       	nop			

0000acd0 <.Loc.348.1>:
  asm volatile("nop");
    acd0:	03 43       	nop			

0000acd2 <.Loc.349.1>:
}
    acd2:	10 01       	reta			;

0000acd4 <port_unlock>:
  asm volatile("nop");
    acd4:	03 43       	nop			

0000acd6 <.Loc.356.1>:
  _enable_interrupts();
    acd6:	03 43       	nop			
    acd8:	32 d2       	eint			
    acda:	03 43       	nop			

0000acdc <.Loc.357.1>:
}
    acdc:	10 01       	reta			;

0000acde <elyRFPostI>:
static const PERSIST rf_events_t AllRfEvents = 0x1FFFF;
static const PERSIST rf_events_t RFTxCfgMask = 0x155;
static const PERSIST rf_events_t RFRxCfgMask = 0xAA;
static eventmask_t events;

msg_t elyRFPostI(uint8_t * buffer) {
    acde:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ace0 <.LCFI0>:
  msg_t msg;
  msg = chMBPostI(&rf_mbox, (msg_t)(buffer));
    ace0:	cd 0c       	mova	r12,	r13	;
    ace2:	8c 01 40 0c 	mova	#68672,	r12	;0x10c40

0000ace6 <.LVL1>:
    ace6:	b0 13 ec 4a 	calla	#19180		;0x04aec

0000acea <.LVL2>:
    acea:	ca 0c       	mova	r12,	r10	;

0000acec <.Loc.19.2>:
  if (MSG_OK == msg) {
    acec:	9c 00 00 00 	cmpa	#0,	r12	;
    acf0:	07 20       	jnz	$+16     	;abs 0xad00

0000acf2 <.Loc.20.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    acf2:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    acf6:	4e 43       	clr.b	r14		;
    acf8:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    acfc:	b0 13 c6 49 	calla	#18886		;0x049c6

0000ad00 <.L3>:
  }
  return msg;
}
    ad00:	cc 0a       	mova	r10,	r12	;
    ad02:	0a 16       	popm.a	#1,	r10	;20-bit words
    ad04:	10 01       	reta			;

0000ad06 <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
    ad06:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000ad08 <.LCFI1>:
    ad08:	ca 0c       	mova	r12,	r10	;
    ad0a:	09 4d       	mov	r13,	r9	;

0000ad0c <.Loc.27.2>:
  msg_t msg;
  chSysLock();
    ad0c:	b0 13 cc ac 	calla	#44236		;0x0accc

0000ad10 <.LVL6>:
  msg = chMBPostS(&rf_mbox, (msg_t)(buffer), timeout);
    ad10:	0e 49       	mov	r9,	r14	;
    ad12:	cd 0a       	mova	r10,	r13	;
    ad14:	8c 01 40 0c 	mova	#68672,	r12	;0x10c40
    ad18:	b0 13 72 4a 	calla	#19058		;0x04a72

0000ad1c <.LVL7>:
    ad1c:	ca 0c       	mova	r12,	r10	;

0000ad1e <.LVL8>:
  if (MSG_OK == msg) {
    ad1e:	9c 00 00 00 	cmpa	#0,	r12	;
    ad22:	07 20       	jnz	$+16     	;abs 0xad32

0000ad24 <.Loc.30.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    ad24:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    ad28:	4e 43       	clr.b	r14		;
    ad2a:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    ad2e:	b0 13 c6 49 	calla	#18886		;0x049c6

0000ad32 <.L6>:
  }
  chSysUnlock();
    ad32:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000ad36 <.LVL10>:
  return msg;
}
    ad36:	cc 0a       	mova	r10,	r12	;
    ad38:	19 16       	popm.a	#2,	r10	;20-bit words
    ad3a:	10 01       	reta			;

0000ad3c <elyRFCfgMarkDirty>:
  chDbgAssert(event & RFCfgMask, "invalid event");
  
  chEvtSignalI(rf_thd, event);
}

void elyRFCfgMarkDirty(rf_events_t event) {
    ad3c:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000ad3e <.LCFI3>:
    ad3e:	0a 4c       	mov	r12,	r10	;
    ad40:	09 4d       	mov	r13,	r9	;

0000ad42 <.Loc.44.2>:
  chDbgAssert(chThdGetSelfX() != rf_thd, "can't set your own config dirty");
    ad42:	81 18 d2 92 	cmpx.a	&0x11abe,&0x114ea;
    ad46:	be 1a ea 14 
    ad4a:	04 20       	jnz	$+10     	;abs 0xad54

0000ad4c <.Loc.44.2>:
    ad4c:	8c 01 c4 08 	mova	#67780,	r12	;0x108c4

0000ad50 <.LVL17>:
    ad50:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ad54 <.L11>:
  chDbgAssert(event & RFCfgMask, "invalid event");
    ad54:	3a b0 ff 03 	bit	#1023,	r10	;#0x03ff
    ad58:	04 20       	jnz	$+10     	;abs 0xad62

0000ad5a <.Loc.45.2>:
    ad5a:	8c 01 c4 08 	mova	#67780,	r12	;0x108c4
    ad5e:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ad62 <.L12>:
  
  chEvtSignal(rf_thd, event);
    ad62:	0d 4a       	mov	r10,	r13	;
    ad64:	0e 49       	mov	r9,	r14	;
    ad66:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    ad6a:	b0 13 9a 49 	calla	#18842		;0x0499a

0000ad6e <.LVL20>:
}
    ad6e:	19 16       	popm.a	#2,	r10	;20-bit words
    ad70:	10 01       	reta			;

0000ad72 <elyRFChangeTxFreqS>:
static eventmask_t get_next_event(eventmask_t mask) {
  mask ^= mask & (mask - (eventmask_t)1);
  return mask;
}

void __attribute__((weak)) elyRFChangeTxFreqS(SX1278Config * cfg) {
    ad72:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ad74 <.LCFI4>:
    ad74:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ad76 <.LCFI5>:
    ad76:	ca 0c       	mova	r12,	r10	;

0000ad78 <.Loc.56.2>:
  chSysLock();
    ad78:	b0 13 cc ac 	calla	#44236		;0x0accc

0000ad7c <.LVL22>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    ad7c:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    ad80:	5d 4e 01 00 	mov.b	1(r14),	r13	;
    ad84:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    ad88:	6c 4e       	mov.b	@r14,	r12	;
    ad8a:	0d dc       	bis	r12,	r13	;
    ad8c:	5c 4e 03 00 	mov.b	3(r14),	r12	;
    ad90:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    ad94:	5e 4e 02 00 	mov.b	2(r14),	r14	;
    ad98:	0c de       	bis	r14,	r12	;

0000ad9a <.Loc.61.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  if (cfg->freq > TX_BAND_MAX) {
    ad9a:	3e 40 03 1c 	mov	#7171,	r14	;#0x1c03
    ad9e:	0e 9c       	cmp	r12,	r14	;
    ada0:	4b 28       	jnc	$+152    	;abs 0xae38
    ada2:	0c 9e       	cmp	r14,	r12	;
    ada4:	04 20       	jnz	$+10     	;abs 0xadae
    ada6:	3e 40 80 a1 	mov	#-24192,r14	;#0xa180
    adaa:	0e 9d       	cmp	r13,	r14	;
    adac:	45 28       	jnc	$+140    	;abs 0xae38

0000adae <.L19>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    adae:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    adb2:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000adb6 <.L16>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < TX_BAND_MIN) {
    adb6:	3c 40 cf 19 	mov	#6607,	r12	;#0x19cf
    adba:	1c 9a 0e 00 	cmp	14(r10),r12	;0x0000e
    adbe:	2f 28       	jnc	$+96     	;abs 0xae1e
    adc0:	8a 9c 0e 00 	cmp	r12,	14(r10)	; 0x000e
    adc4:	05 20       	jnz	$+12     	;abs 0xadd0
    adc6:	3e 40 3f 0e 	mov	#3647,	r14	;#0x0e3f
    adca:	1e 9a 0c 00 	cmp	12(r10),r14	;0x0000c
    adce:	27 28       	jnc	$+80     	;abs 0xae1e

0000add0 <.L20>:
    cfg->freq = TX_BAND_MIN;
    add0:	ba 40 40 0e 	mov	#3648,	12(r10)	;#0x0e40, 0x000c
    add4:	0c 00 
    add6:	ba 40 cf 19 	mov	#6607,	14(r10)	;#0x19cf, 0x000e
    adda:	0e 00 

0000addc <.Loc.70.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    addc:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    ade0:	f8 40 40 00 	mov.b	#64,	0(r8)	;#0x0040
    ade4:	00 00 

0000ade6 <.Loc.71.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    ade6:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    adea:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    adee:	b0 13 24 cd 	calla	#52516		;0x0cd24
    adf2:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000adf6 <.Loc.72.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    adf6:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    adfa:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    adfe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ae02:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    ae06:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000ae0a <.Loc.73.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    ae0a:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    ae0e:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    ae12:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    ae16:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    ae1a:	c8 4c 03 00 	mov.b	r12,	3(r8)	;

0000ae1e <.L17>:
  }
  chSysUnlock();
    ae1e:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000ae22 <.LVL26>:
  
  /* This is pretty fast */
  sx1278SetFrequency(&SX1278D1, cfg->freq);
    ae22:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    ae26:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    ae2a:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    ae2e:	b0 13 44 67 	calla	#26436		;0x06744

0000ae32 <.LVL27>:
}
    ae32:	08 16       	popm.a	#1,	r8	;20-bit words
    ae34:	0a 16       	popm.a	#1,	r10	;20-bit words
    ae36:	10 01       	reta			;

0000ae38 <.L14>:
    cfg->freq = TX_BAND_MAX;
    ae38:	ba 40 80 a1 	mov	#-24192,12(r10)	;#0xa180, 0x000c
    ae3c:	0c 00 
    ae3e:	ba 40 03 1c 	mov	#7171,	14(r10)	;#0x1c03, 0x000e
    ae42:	0e 00 

0000ae44 <.Loc.63.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    ae44:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    ae48:	f8 40 80 ff 	mov.b	#-128,	0(r8)	;#0xff80
    ae4c:	00 00 

0000ae4e <.Loc.64.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    ae4e:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    ae52:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    ae56:	b0 13 24 cd 	calla	#52516		;0x0cd24
    ae5a:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000ae5e <.Loc.65.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    ae5e:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    ae62:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    ae66:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ae6a:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    ae6e:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000ae72 <.Loc.66.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    ae72:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    ae76:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    ae7a:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    ae7e:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    ae82:	c8 4c 03 00 	mov.b	r12,	3(r8)	;
    ae86:	80 00 b6 ad 	mova	#44470,	r0	;0x0adb6

0000ae8a <elyRFChangeRxFreqS>:

void __attribute__((weak)) elyRFChangeRxFreqS(SX1212Config * cfg) {
    ae8a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ae8c <.LCFI6>:
    ae8c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ae8e <.LCFI7>:
    ae8e:	ca 0c       	mova	r12,	r10	;

0000ae90 <.Loc.82.2>:
  chSysLock();
    ae90:	b0 13 cc ac 	calla	#44236		;0x0accc

0000ae94 <.LVL32>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    ae94:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    ae98:	5d 4e 05 00 	mov.b	5(r14),	r13	;
    ae9c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    aea0:	5c 4e 04 00 	mov.b	4(r14),	r12	;
    aea4:	0d dc       	bis	r12,	r13	;
    aea6:	5c 4e 07 00 	mov.b	7(r14),	r12	;
    aeaa:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    aeae:	5e 4e 06 00 	mov.b	6(r14),	r14	;
    aeb2:	0c de       	bis	r14,	r12	;

0000aeb4 <.Loc.87.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  if (cfg->freq > RX_BAND_MAX) {
    aeb4:	3e 40 04 1a 	mov	#6660,	r14	;#0x1a04
    aeb8:	0e 9c       	cmp	r12,	r14	;
    aeba:	4b 28       	jnc	$+152    	;abs 0xaf52
    aebc:	0c 9e       	cmp	r14,	r12	;
    aebe:	04 20       	jnz	$+10     	;abs 0xaec8
    aec0:	3e 40 20 76 	mov	#30240,	r14	;#0x7620
    aec4:	0e 9d       	cmp	r13,	r14	;
    aec6:	45 28       	jnc	$+140    	;abs 0xaf52

0000aec8 <.L27>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    aec8:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    aecc:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000aed0 <.L24>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < RX_BAND_MIN) {
    aed0:	3c 40 b8 19 	mov	#6584,	r12	;#0x19b8
    aed4:	1c 9a 12 00 	cmp	18(r10),r12	;0x00012
    aed8:	2f 28       	jnc	$+96     	;abs 0xaf38
    aeda:	8a 9c 12 00 	cmp	r12,	18(r10)	; 0x0012
    aede:	05 20       	jnz	$+12     	;abs 0xaeea
    aee0:	3e 40 df 2a 	mov	#10975,	r14	;#0x2adf
    aee4:	1e 9a 10 00 	cmp	16(r10),r14	;0x00010
    aee8:	27 28       	jnc	$+80     	;abs 0xaf38

0000aeea <.L28>:
    cfg->freq = RX_BAND_MIN;
    aeea:	ba 40 e0 2a 	mov	#10976,	16(r10)	;#0x2ae0, 0x0010
    aeee:	10 00 
    aef0:	ba 40 b8 19 	mov	#6584,	18(r10)	;#0x19b8, 0x0012
    aef4:	12 00 

0000aef6 <.Loc.96.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    aef6:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    aefa:	f8 40 e0 ff 	mov.b	#-32,	4(r8)	;#0xffe0
    aefe:	04 00 

0000af00 <.Loc.97.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    af00:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af04:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af08:	b0 13 24 cd 	calla	#52516		;0x0cd24
    af0c:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000af10 <.Loc.98.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    af10:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af14:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af18:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    af1c:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    af20:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000af24 <.Loc.99.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    af24:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af28:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af2c:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    af30:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    af34:	c8 4c 07 00 	mov.b	r12,	7(r8)	;

0000af38 <.L25>:
  }
  chSysUnlock();
    af38:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000af3c <.LVL36>:
  
  /* This is INCREDIBLY slow */
  sx1212SetFrequency(&SX1212D1, cfg->freq);
    af3c:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    af40:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    af44:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    af48:	b0 13 5a 71 	calla	#29018		;0x0715a

0000af4c <.LVL37>:
}
    af4c:	08 16       	popm.a	#1,	r8	;20-bit words
    af4e:	0a 16       	popm.a	#1,	r10	;20-bit words
    af50:	10 01       	reta			;

0000af52 <.L22>:
    cfg->freq = RX_BAND_MAX;
    af52:	ba 40 20 76 	mov	#30240,	16(r10)	;#0x7620, 0x0010
    af56:	10 00 
    af58:	ba 40 04 1a 	mov	#6660,	18(r10)	;#0x1a04, 0x0012
    af5c:	12 00 

0000af5e <.Loc.89.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    af5e:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    af62:	f8 40 20 00 	mov.b	#32,	4(r8)	;#0x0020
    af66:	04 00 

0000af68 <.Loc.90.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    af68:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af6c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af70:	b0 13 24 cd 	calla	#52516		;0x0cd24
    af74:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000af78 <.Loc.91.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    af78:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af7c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af80:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    af84:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    af88:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000af8c <.Loc.92.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    af8c:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    af90:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    af94:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    af98:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    af9c:	c8 4c 07 00 	mov.b	r12,	7(r8)	;
    afa0:	80 00 d0 ae 	mova	#44752,	r0	;0x0aed0

0000afa4 <elyRFChangeTxBRS>:

void __attribute__((weak)) elyRFChangeTxBRS(SX1278Config * cfg) {
    afa4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000afa6 <.LCFI8>:
    afa6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000afa8 <.LCFI9>:
    afa8:	ca 0c       	mova	r12,	r10	;

0000afaa <.Loc.108.2>:
  chSysLock();
    afaa:	b0 13 cc ac 	calla	#44236		;0x0accc

0000afae <.LVL42>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    afae:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    afb2:	5d 4e 19 00 	mov.b	25(r14),r13	;0x00019
    afb6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    afba:	5c 4e 18 00 	mov.b	24(r14),r12	;0x00018
    afbe:	0d dc       	bis	r12,	r13	;
    afc0:	5c 4e 1b 00 	mov.b	27(r14),r12	;0x0001b
    afc4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    afc8:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x0001a
    afcc:	0c de       	bis	r14,	r12	;

0000afce <.Loc.113.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  if (cfg->bitrate > TX_BR_MAX) {
    afce:	6e 42       	mov.b	#4,	r14	;r2 As==10
    afd0:	0e 9c       	cmp	r12,	r14	;
    afd2:	45 28       	jnc	$+140    	;abs 0xb05e
    afd4:	0c 9e       	cmp	r14,	r12	;
    afd6:	04 20       	jnz	$+10     	;abs 0xafe0
    afd8:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    afdc:	0e 9d       	cmp	r13,	r14	;
    afde:	3f 28       	jnc	$+128    	;abs 0xb05e

0000afe0 <.L35>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    afe0:	8a 4d 08 00 	mov	r13,	8(r10)	;
    afe4:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000afe8 <.L32>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < TX_BR_MIN) {
    afe8:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    afec:	2b 20       	jnz	$+88     	;abs 0xb044
    afee:	3c 40 af 04 	mov	#1199,	r12	;#0x04af
    aff2:	1c 9a 08 00 	cmp	8(r10),	r12	;
    aff6:	26 28       	jnc	$+78     	;abs 0xb044

0000aff8 <.Loc.121.2>:
    cfg->bitrate = TX_BR_MIN;
    aff8:	ba 40 b0 04 	mov	#1200,	8(r10)	;#0x04b0
    affc:	08 00 
    affe:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000b002 <.Loc.122.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b002:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b006:	f8 40 b0 ff 	mov.b	#-80,	24(r8)	;#0xffb0, 0x0018
    b00a:	18 00 

0000b00c <.Loc.123.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b00c:	1c 4a 08 00 	mov	8(r10),	r12	;
    b010:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b014:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b018:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b01c <.Loc.124.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b01c:	1c 4a 08 00 	mov	8(r10),	r12	;
    b020:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b024:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b028:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b02c:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b030 <.Loc.125.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b030:	1c 4a 08 00 	mov	8(r10),	r12	;
    b034:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b038:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b03c:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b040:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b

0000b044 <.L33>:
  }
  chSysUnlock();
    b044:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000b048 <.LVL46>:
  
  /* This is fast */
  sx1278SetBitrate(&SX1278D1, cfg->bitrate);
    b048:	1d 4a 08 00 	mov	8(r10),	r13	;
    b04c:	1e 4a 0a 00 	mov	10(r10),r14	;0x0000a
    b050:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b054:	b0 13 80 66 	calla	#26240		;0x06680

0000b058 <.LVL47>:
}
    b058:	08 16       	popm.a	#1,	r8	;20-bit words
    b05a:	0a 16       	popm.a	#1,	r10	;20-bit words
    b05c:	10 01       	reta			;

0000b05e <.L30>:
    cfg->bitrate = TX_BR_MAX;
    b05e:	ba 40 e0 93 	mov	#-27680,8(r10)	;#0x93e0
    b062:	08 00 
    b064:	aa 42 0a 00 	mov	#4,	10(r10)	;r2 As==10, 0x000a

0000b068 <.Loc.115.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b068:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b06c:	f8 40 e0 ff 	mov.b	#-32,	24(r8)	;#0xffe0, 0x0018
    b070:	18 00 

0000b072 <.Loc.116.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b072:	1c 4a 08 00 	mov	8(r10),	r12	;
    b076:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b07a:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b07e:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b082 <.Loc.117.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b082:	1c 4a 08 00 	mov	8(r10),	r12	;
    b086:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b08a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b08e:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b092:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b096 <.Loc.118.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b096:	1c 4a 08 00 	mov	8(r10),	r12	;
    b09a:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b09e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b0a2:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b0a6:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b
    b0aa:	80 00 e8 af 	mova	#45032,	r0	;0x0afe8

0000b0ae <elyRFChangeRxBRS>:

void __attribute__((weak)) elyRFChangeRxBRS(SX1212Config * cfg) {
    b0ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b0b0 <.LCFI10>:
    b0b0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b0b2 <.LCFI11>:
    b0b2:	ca 0c       	mova	r12,	r10	;

0000b0b4 <.Loc.134.2>:
  chSysLock();
    b0b4:	b0 13 cc ac 	calla	#44236		;0x0accc

0000b0b8 <.LVL52>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    b0b8:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b0bc:	5d 4e 1d 00 	mov.b	29(r14),r13	;0x0001d
    b0c0:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b0c4:	5c 4e 1c 00 	mov.b	28(r14),r12	;0x0001c
    b0c8:	0d dc       	bis	r12,	r13	;
    b0ca:	5c 4e 1f 00 	mov.b	31(r14),r12	;0x0001f
    b0ce:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b0d2:	5e 4e 1e 00 	mov.b	30(r14),r14	;0x0001e
    b0d6:	0c de       	bis	r14,	r12	;

0000b0d8 <.Loc.139.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  if (cfg->bitrate > RX_BR_MAX) {
    b0d8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    b0da:	0e 9c       	cmp	r12,	r14	;
    b0dc:	45 28       	jnc	$+140    	;abs 0xb168
    b0de:	0c 9e       	cmp	r14,	r12	;
    b0e0:	04 20       	jnz	$+10     	;abs 0xb0ea
    b0e2:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    b0e6:	0e 9d       	cmp	r13,	r14	;
    b0e8:	3f 28       	jnc	$+128    	;abs 0xb168

0000b0ea <.L43>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
    b0ea:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    b0ee:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000b0f2 <.L40>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < RX_BR_MIN) {
    b0f2:	8a 93 0e 00 	cmp	#0,	14(r10)	;r3 As==00, 0x000e
    b0f6:	2b 20       	jnz	$+88     	;abs 0xb14e
    b0f8:	3c 40 0b 03 	mov	#779,	r12	;#0x030b
    b0fc:	1c 9a 0c 00 	cmp	12(r10),r12	;0x0000c
    b100:	26 28       	jnc	$+78     	;abs 0xb14e

0000b102 <.Loc.147.2>:
    cfg->bitrate = RX_BR_MIN;
    b102:	ba 40 0c 03 	mov	#780,	12(r10)	;#0x030c, 0x000c
    b106:	0c 00 
    b108:	8a 43 0e 00 	mov	#0,	14(r10)	;r3 As==00, 0x000e

0000b10c <.Loc.148.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b10c:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b110:	f8 40 0c 00 	mov.b	#12,	28(r8)	;#0x000c, 0x001c
    b114:	1c 00 

0000b116 <.Loc.149.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b116:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b11a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b11e:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b122:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b126 <.Loc.150.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b126:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b12a:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b12e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b132:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b136:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b13a <.Loc.151.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b13a:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b13e:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b142:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b146:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b14a:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f

0000b14e <.L41>:
  }
  chSysUnlock();
    b14e:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000b152 <.LVL56>:
  
  /* This is only moderately slow */
  sx1212SetBitrate(&SX1212D1, cfg->bitrate);
    b152:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    b156:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    b15a:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b15e:	b0 13 04 70 	calla	#28676		;0x07004

0000b162 <.LVL57>:
}
    b162:	08 16       	popm.a	#1,	r8	;20-bit words
    b164:	0a 16       	popm.a	#1,	r10	;20-bit words
    b166:	10 01       	reta			;

0000b168 <.L38>:
    cfg->bitrate = RX_BR_MAX;
    b168:	ba 40 f0 49 	mov	#18928,	12(r10)	;#0x49f0, 0x000c
    b16c:	0c 00 
    b16e:	aa 43 0e 00 	mov	#2,	14(r10)	;r3 As==10, 0x000e

0000b172 <.Loc.141.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b172:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b176:	f8 40 f0 ff 	mov.b	#-16,	28(r8)	;#0xfff0, 0x001c
    b17a:	1c 00 

0000b17c <.Loc.142.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b17c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b180:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b184:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b188:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b18c <.Loc.143.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b18c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b190:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b194:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b198:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b19c:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b1a0 <.Loc.144.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b1a0:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b1a4:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b1a8:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b1ac:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b1b0:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f
    b1b4:	80 00 f2 b0 	mova	#45298,	r0	;0x0b0f2

0000b1b8 <elyRFChangeTxDevS>:

void __attribute__((weak)) elyRFChangeTxDevS(SX1278Config * cfg) {
    b1b8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b1ba <.LCFI12>:
    b1ba:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b1bc <.LCFI13>:
    b1bc:	ca 0c       	mova	r12,	r10	;

0000b1be <.Loc.160.2>:
  chSysLock();
    b1be:	b0 13 cc ac 	calla	#44236		;0x0accc

0000b1c2 <.LVL62>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    b1c2:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b1c6:	5d 4e 09 00 	mov.b	9(r14),	r13	;
    b1ca:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b1ce:	5c 4e 08 00 	mov.b	8(r14),	r12	;
    b1d2:	0d dc       	bis	r12,	r13	;
    b1d4:	5c 4e 0b 00 	mov.b	11(r14),r12	;0x0000b
    b1d8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b1dc:	5e 4e 0a 00 	mov.b	10(r14),r14	;0x0000a
    b1e0:	0c de       	bis	r14,	r12	;

0000b1e2 <.Loc.165.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  if (cfg->fdev > TX_DEV_MAX) {
    b1e2:	7e 40 03 00 	mov.b	#3,	r14	;
    b1e6:	0e 9c       	cmp	r12,	r14	;
    b1e8:	45 28       	jnc	$+140    	;abs 0xb274
    b1ea:	0c 9e       	cmp	r14,	r12	;
    b1ec:	04 20       	jnz	$+10     	;abs 0xb1f6
    b1ee:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    b1f2:	0e 9d       	cmp	r13,	r14	;
    b1f4:	3f 28       	jnc	$+128    	;abs 0xb274

0000b1f6 <.L51>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    b1f6:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    b1fa:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000b1fe <.L48>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < TX_DEV_MIN) {
    b1fe:	8a 93 12 00 	cmp	#0,	18(r10)	;r3 As==00, 0x0012
    b202:	2b 20       	jnz	$+88     	;abs 0xb25a
    b204:	3c 40 57 02 	mov	#599,	r12	;#0x0257
    b208:	1c 9a 10 00 	cmp	16(r10),r12	;0x00010
    b20c:	26 28       	jnc	$+78     	;abs 0xb25a

0000b20e <.Loc.173.2>:
    cfg->fdev = TX_DEV_MIN;
    b20e:	ba 40 58 02 	mov	#600,	16(r10)	;#0x0258, 0x0010
    b212:	10 00 
    b214:	8a 43 12 00 	mov	#0,	18(r10)	;r3 As==00, 0x0012

0000b218 <.Loc.174.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    b218:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b21c:	f8 40 58 00 	mov.b	#88,	8(r8)	;#0x0058
    b220:	08 00 

0000b222 <.Loc.175.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b222:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b226:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b22a:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b22e:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000b232 <.Loc.176.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b232:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b236:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b23a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b23e:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b242:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000b246 <.Loc.177.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    b246:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b24a:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b24e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b252:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b256:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b

0000b25a <.L49>:
  }
  chSysUnlock();
    b25a:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000b25e <.LVL66>:
  
  /* This is fast */
  sx1278SetDeviation(&SX1278D1, cfg->fdev);
    b25e:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    b262:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    b266:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b26a:	b0 13 e6 66 	calla	#26342		;0x066e6

0000b26e <.LVL67>:
}
    b26e:	08 16       	popm.a	#1,	r8	;20-bit words
    b270:	0a 16       	popm.a	#1,	r10	;20-bit words
    b272:	10 01       	reta			;

0000b274 <.L46>:
    cfg->fdev = TX_DEV_MAX;
    b274:	ba 40 40 0d 	mov	#3392,	16(r10)	;#0x0d40, 0x0010
    b278:	10 00 
    b27a:	ba 40 03 00 	mov	#3,	18(r10)	; 0x0012
    b27e:	12 00 

0000b280 <.Loc.167.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    b280:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b284:	f8 40 40 00 	mov.b	#64,	8(r8)	;#0x0040
    b288:	08 00 

0000b28a <.Loc.168.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b28a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b28e:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b292:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b296:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000b29a <.Loc.169.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b29a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b29e:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b2a2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b2a6:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b2aa:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000b2ae <.Loc.170.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    b2ae:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b2b2:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b2b6:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b2ba:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b2be:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b
    b2c2:	80 00 fe b1 	mova	#45566,	r0	;0x0b1fe

0000b2c6 <elyRFChangeRxDevS>:

void __attribute__((weak)) elyRFChangeRxDevS(SX1212Config * cfg) {
    b2c6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b2c8 <.LCFI14>:
    b2c8:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b2ca <.LCFI15>:
    b2ca:	ca 0c       	mova	r12,	r10	;

0000b2cc <.Loc.186.2>:
  chSysLock();
    b2cc:	b0 13 cc ac 	calla	#44236		;0x0accc

0000b2d0 <.LVL72>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    b2d0:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b2d4:	5d 4e 0d 00 	mov.b	13(r14),r13	;0x0000d
    b2d8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b2dc:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    b2e0:	0d dc       	bis	r12,	r13	;
    b2e2:	5c 4e 0f 00 	mov.b	15(r14),r12	;0x0000f
    b2e6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b2ea:	5e 4e 0e 00 	mov.b	14(r14),r14	;0x0000e
    b2ee:	0c de       	bis	r14,	r12	;

0000b2f0 <.Loc.191.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  if (cfg->fdev > RX_DEV_MAX) {
    b2f0:	7e 40 03 00 	mov.b	#3,	r14	;
    b2f4:	0e 9c       	cmp	r12,	r14	;
    b2f6:	45 28       	jnc	$+140    	;abs 0xb382
    b2f8:	0c 9e       	cmp	r14,	r12	;
    b2fa:	04 20       	jnz	$+10     	;abs 0xb304
    b2fc:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    b300:	0e 9d       	cmp	r13,	r14	;
    b302:	3f 28       	jnc	$+128    	;abs 0xb382

0000b304 <.L59>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    b304:	8a 4d 14 00 	mov	r13,	20(r10)	; 0x0014
    b308:	8a 4c 16 00 	mov	r12,	22(r10)	; 0x0016

0000b30c <.L56>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < RX_DEV_MIN) {
    b30c:	8a 93 16 00 	cmp	#0,	22(r10)	;r3 As==00, 0x0016
    b310:	2b 20       	jnz	$+88     	;abs 0xb368
    b312:	3c 40 e7 80 	mov	#-32537,r12	;#0x80e7
    b316:	1c 9a 14 00 	cmp	20(r10),r12	;0x00014
    b31a:	26 28       	jnc	$+78     	;abs 0xb368

0000b31c <.Loc.199.2>:
    cfg->fdev = RX_DEV_MIN;
    b31c:	ba 40 e8 80 	mov	#-32536,20(r10)	;#0x80e8, 0x0014
    b320:	14 00 
    b322:	8a 43 16 00 	mov	#0,	22(r10)	;r3 As==00, 0x0016

0000b326 <.Loc.200.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    b326:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b32a:	f8 40 e8 ff 	mov.b	#-24,	12(r8)	;#0xffe8, 0x000c
    b32e:	0c 00 

0000b330 <.Loc.201.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b330:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b334:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b338:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b33c:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000b340 <.Loc.202.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b340:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b344:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b348:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b34c:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b350:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000b354 <.Loc.203.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    b354:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b358:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b35c:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b360:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b364:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f

0000b368 <.L57>:
  }
  chSysUnlock();
    b368:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000b36c <.LVL76>:
  
  /* This is super fast */
  sx1212SetDeviation(&SX1212D1, cfg->fdev);
    b36c:	1d 4a 14 00 	mov	20(r10),r13	;0x00014
    b370:	1e 4a 16 00 	mov	22(r10),r14	;0x00016
    b374:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b378:	b0 13 04 71 	calla	#28932		;0x07104

0000b37c <.LVL77>:
}
    b37c:	08 16       	popm.a	#1,	r8	;20-bit words
    b37e:	0a 16       	popm.a	#1,	r10	;20-bit words
    b380:	10 01       	reta			;

0000b382 <.L54>:
    cfg->fdev = RX_DEV_MAX;
    b382:	ba 40 40 0d 	mov	#3392,	20(r10)	;#0x0d40, 0x0014
    b386:	14 00 
    b388:	ba 40 03 00 	mov	#3,	22(r10)	; 0x0016
    b38c:	16 00 

0000b38e <.Loc.193.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    b38e:	28 01 3c 08 	mova	&67644,	r8	;0x1083c
    b392:	f8 40 40 00 	mov.b	#64,	12(r8)	;#0x0040, 0x000c
    b396:	0c 00 

0000b398 <.Loc.194.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    b398:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b39c:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b3a0:	b0 13 24 cd 	calla	#52516		;0x0cd24
    b3a4:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000b3a8 <.Loc.195.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    b3a8:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b3ac:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b3b0:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b3b4:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b3b8:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000b3bc <.Loc.196.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    b3bc:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    b3c0:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    b3c4:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b3c8:	b0 13 5e cd 	calla	#52574		;0x0cd5e
    b3cc:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f
    b3d0:	80 00 0c b3 	mova	#45836,	r0	;0x0b30c

0000b3d4 <elyRFChangeRxSyncS>:
  
  /* This is reasonably fast */
  sx1278SetSync(&SX1278D1, cfg->sync_word);
}

void __attribute__((weak)) elyRFChangeRxSyncS(SX1212Config * cfg) {
    b3d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b3d6 <.LCFI17>:
    b3d6:	ca 0c       	mova	r12,	r10	;

0000b3d8 <.Loc.224.2>:
  chSysLock();
    b3d8:	b0 13 cc ac 	calla	#44236		;0x0accc

0000b3dc <.LVL86>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    b3dc:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b3e0:	5d 4e 15 00 	mov.b	21(r14),r13	;0x00015
    b3e4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b3e8:	5c 4e 17 00 	mov.b	23(r14),r12	;0x00017
    b3ec:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b3f0:	5f 4e 16 00 	mov.b	22(r14),r15	;0x00016
    b3f4:	0c df       	bis	r15,	r12	;

0000b3f6 <.Loc.225.2>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    b3f6:	5e 4e 14 00 	mov.b	20(r14),r14	;0x00014
    b3fa:	0e dd       	bis	r13,	r14	;
    b3fc:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c
    b400:	8a 4c 1e 00 	mov	r12,	30(r10)	; 0x001e

0000b404 <.Loc.229.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    b404:	b0 13 d4 ac 	calla	#44244		;0x0acd4

0000b408 <.LVL87>:
  
  /* This is reasonably fast */
  sx1212SetSync(&SX1212D1, cfg->sync_word);
    b408:	1d 4a 1c 00 	mov	28(r10),r13	;0x0001c
    b40c:	1e 4a 1e 00 	mov	30(r10),r14	;0x0001e
    b410:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b414:	b0 13 a6 74 	calla	#29862		;0x074a6

0000b418 <.LVL88>:
}
    b418:	0a 16       	popm.a	#1,	r10	;20-bit words
    b41a:	10 01       	reta			;

0000b41c <elyRFChangeTxPowerS>:

void __attribute__((weak)) elyRFChangeTxPowerS(SX1278Config * cfg) {
  cfg->pow = bank0p[RegOutputPower];
    b41c:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b420:	5d 4e 21 00 	mov.b	33(r14),r13	;0x00021
    b424:	cc 4d 15 00 	mov.b	r13,	21(r12)	; 0x0015

0000b428 <.Loc.239.2>:
  
  /* This is reasonably fast because I made it kind of sloppy */
  sx1278SetPower(&SX1278D1, cfg->pow);
    b428:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0

0000b42c <.LVL90>:
    b42c:	b0 13 26 68 	calla	#26662		;0x06826

0000b430 <.LVL91>:
}
    b430:	10 01       	reta			;

0000b432 <elyRFChangeRxFilterParamsS>:
  sx1278SetFilterParams(&SX1278D1, tx_cfg->filter);
}

void __attribute__((weak)) elyRFChangeRxFilterParamsS(SX1212Config * rx_cfg) {
  
  rx_cfg->rx_bw = (bank0p[RegFilterParams] & 0x0F);
    b432:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    b436:	5d 4e 20 00 	mov.b	32(r14),r13	;0x00020
    b43a:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    b43e:	4e 4d       	mov.b	r13,	r14	;
    b440:	0f 43       	clr	r15		;
    b442:	8c 4e 18 00 	mov	r14,	24(r12)	; 0x0018
    b446:	8c 4f 1a 00 	mov	r15,	26(r12)	; 0x001a

0000b44a <.Loc.253.2>:
  /* This is fast and I made it kind of sloppy anyway */
  sx1212SetRxBw(&SX1212D1, rx_cfg->rx_bw);
    b44a:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2

0000b44e <.LVL96>:
    b44e:	b0 13 e2 74 	calla	#29922		;0x074e2

0000b452 <.LVL97>:
}
    b452:	10 01       	reta			;

0000b454 <RFThd>:
static bool bits_set(eventmask_t events, eventmask_t bits) {
  return ((events & bits) == bits);
}

THD_WORKING_AREA(waRFThd, 256);
THD_FUNCTION(RFThd, arg) {
    b454:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000b456 <.LCFI18>:
    b456:	b1 00 08 00 	suba	#8,	r1	;

0000b45a <.LCFI19>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  rf_thd = chThdGetSelfX();
    b45a:	81 18 d2 42 	movx.a	&0x114ea,&0x11abe;
    b45e:	ea 14 be 1a 

0000b462 <.Loc.323.2>:
  
  /* Build the TX config out of the registers */
  chSysLock();
    b462:	88 00 cc ac 	mova	#44236,	r8	;0x0accc
    b466:	48 13       	calla	r8		;

0000b468 <.LVL99>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b468:	26 01 40 08 	mova	&67648,	r6	;0x10840
    b46c:	84 01 ea 0b 	mova	#68586,	r4	;0x10bea

0000b470 <.Loc.326.2>:
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    b470:	5d 46 19 00 	mov.b	25(r6),	r13	;0x00019
    b474:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b478:	5c 46 1b 00 	mov.b	27(r6),	r12	;0x0001b
    b47c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b480:	5e 46 1a 00 	mov.b	26(r6),	r14	;0x0001a
    b484:	0c de       	bis	r14,	r12	;

0000b486 <.Loc.324.2>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b486:	5e 46 18 00 	mov.b	24(r6),	r14	;0x00018
    b48a:	0e dd       	bis	r13,	r14	;
    b48c:	84 4e 08 00 	mov	r14,	8(r4)	;
    b490:	84 4c 0a 00 	mov	r12,	10(r4)	; 0x000a

0000b494 <.Loc.330.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    b494:	5d 46 01 00 	mov.b	1(r6),	r13	;
    b498:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b49c:	5c 46 03 00 	mov.b	3(r6),	r12	;
    b4a0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b4a4:	5e 46 02 00 	mov.b	2(r6),	r14	;
    b4a8:	0c de       	bis	r14,	r12	;

0000b4aa <.Loc.328.2>:
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    b4aa:	6e 46       	mov.b	@r6,	r14	;
    b4ac:	0e dd       	bis	r13,	r14	;
    b4ae:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    b4b2:	84 4c 0e 00 	mov	r12,	14(r4)	; 0x000e

0000b4b6 <.Loc.334.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    b4b6:	5d 46 09 00 	mov.b	9(r6),	r13	;
    b4ba:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b4be:	5c 46 0b 00 	mov.b	11(r6),	r12	;0x0000b
    b4c2:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b4c6:	5e 46 0a 00 	mov.b	10(r6),	r14	;0x0000a
    b4ca:	0c de       	bis	r14,	r12	;

0000b4cc <.Loc.332.2>:
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    b4cc:	5e 46 08 00 	mov.b	8(r6),	r14	;
    b4d0:	0e dd       	bis	r13,	r14	;
    b4d2:	84 4e 10 00 	mov	r14,	16(r4)	; 0x0010
    b4d6:	84 4c 12 00 	mov	r12,	18(r4)	; 0x0012

0000b4da <.Loc.336.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  tx_cfg.filter = ((bank0p[RegFilterParams] >> 4) & 0x03);
    b4da:	5c 46 20 00 	mov.b	32(r6),	r12	;0x00020
    b4de:	5c 0f       	rrum	#4,	r12	;
    b4e0:	7c f0 03 00 	and.b	#3,	r12	;
    b4e4:	c4 4c 14 00 	mov.b	r12,	20(r4)	; 0x0014

0000b4e8 <.Loc.337.2>:
  tx_cfg.pow = bank0p[RegOutputPower];
    b4e8:	d4 46 21 00 	mov.b	33(r6),	21(r4)	;0x00021, 0x0015
    b4ec:	15 00 

0000b4ee <.Loc.340.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
                ((uint32_t)(bank0p[RegTXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    b4ee:	5d 46 11 00 	mov.b	17(r6),	r13	;0x00011
    b4f2:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b4f6:	5c 46 13 00 	mov.b	19(r6),	r12	;0x00013
    b4fa:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b4fe:	5e 46 12 00 	mov.b	18(r6),	r14	;0x00012
    b502:	0c de       	bis	r14,	r12	;

0000b504 <.Loc.338.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
    b504:	5e 46 10 00 	mov.b	16(r6),	r14	;0x00010
    b508:	0e dd       	bis	r13,	r14	;
    b50a:	84 4e 18 00 	mov	r14,	24(r4)	; 0x0018
    b50e:	84 4c 1a 00 	mov	r12,	26(r4)	; 0x001a

0000b512 <.Loc.342.2>:
                ((uint32_t)(bank0p[RegTXSyncMsb]) << 24) );
  chSysUnlock();
    b512:	8a 00 d4 ac 	mova	#44244,	r10	;0x0acd4
    b516:	4a 13       	calla	r10		;

0000b518 <.LVL100>:
  
  /* Start the transmitter driver and initiate the transmit loop */
  sx1278ObjectInit(&SX1278D1);
    b518:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b51c:	b0 13 9e 68 	calla	#26782		;0x0689e

0000b520 <.LVL101>:
  sx1278Start(&SX1278D1, &tx_cfg);
    b520:	cd 04       	mova	r4,	r13	;
    b522:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b526:	b0 13 02 69 	calla	#26882		;0x06902

0000b52a <.LVL102>:
  
  elyRFDLLTxInit(&SX1278D1);
    b52a:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b52e:	b0 13 76 ca 	calla	#51830		;0x0ca76

0000b532 <.LVL103>:
  
  /* Build the RX config out of the registers */
  chSysLock();
    b532:	48 13       	calla	r8		;

0000b534 <.LVL104>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    b534:	84 01 be 0b 	mova	#68542,	r4	;0x10bbe

0000b538 <.Loc.354.2>:
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    b538:	5d 46 1d 00 	mov.b	29(r6),	r13	;0x0001d
    b53c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b540:	5c 46 1f 00 	mov.b	31(r6),	r12	;0x0001f
    b544:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b548:	5e 46 1e 00 	mov.b	30(r6),	r14	;0x0001e
    b54c:	0c de       	bis	r14,	r12	;

0000b54e <.Loc.352.2>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    b54e:	5e 46 1c 00 	mov.b	28(r6),	r14	;0x0001c
    b552:	0e dd       	bis	r13,	r14	;
    b554:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    b558:	84 4c 0e 00 	mov	r12,	14(r4)	; 0x000e

0000b55c <.Loc.358.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    b55c:	5d 46 05 00 	mov.b	5(r6),	r13	;
    b560:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b564:	5c 46 07 00 	mov.b	7(r6),	r12	;
    b568:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b56c:	5e 46 06 00 	mov.b	6(r6),	r14	;
    b570:	0c de       	bis	r14,	r12	;

0000b572 <.Loc.356.2>:
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    b572:	5e 46 04 00 	mov.b	4(r6),	r14	;
    b576:	0e dd       	bis	r13,	r14	;
    b578:	84 4e 10 00 	mov	r14,	16(r4)	; 0x0010
    b57c:	84 4c 12 00 	mov	r12,	18(r4)	; 0x0012

0000b580 <.Loc.362.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    b580:	5d 46 0d 00 	mov.b	13(r6),	r13	;0x0000d
    b584:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b588:	5c 46 0f 00 	mov.b	15(r6),	r12	;0x0000f
    b58c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b590:	5e 46 0e 00 	mov.b	14(r6),	r14	;0x0000e
    b594:	0c de       	bis	r14,	r12	;

0000b596 <.Loc.360.2>:
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    b596:	5e 46 0c 00 	mov.b	12(r6),	r14	;0x0000c
    b59a:	0e dd       	bis	r13,	r14	;
    b59c:	84 4e 14 00 	mov	r14,	20(r4)	; 0x0014
    b5a0:	84 4c 16 00 	mov	r12,	22(r4)	; 0x0016

0000b5a4 <.Loc.364.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  rx_cfg.rx_bw = (bank0p[RegFilterParams] & 0x0F);
    b5a4:	5c 46 20 00 	mov.b	32(r6),	r12	;0x00020
    b5a8:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    b5ac:	4d 4c       	mov.b	r12,	r13	;
    b5ae:	0e 43       	clr	r14		;
    b5b0:	84 4d 18 00 	mov	r13,	24(r4)	; 0x0018
    b5b4:	84 4e 1a 00 	mov	r14,	26(r4)	; 0x001a

0000b5b8 <.Loc.367.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    b5b8:	5d 46 15 00 	mov.b	21(r6),	r13	;0x00015
    b5bc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b5c0:	5c 46 17 00 	mov.b	23(r6),	r12	;0x00017
    b5c4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b5c8:	5e 46 16 00 	mov.b	22(r6),	r14	;0x00016
    b5cc:	0c de       	bis	r14,	r12	;

0000b5ce <.Loc.365.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    b5ce:	56 46 14 00 	mov.b	20(r6),	r6	;0x00014
    b5d2:	06 dd       	bis	r13,	r6	;
    b5d4:	84 46 1c 00 	mov	r6,	28(r4)	; 0x001c
    b5d8:	84 4c 1e 00 	mov	r12,	30(r4)	; 0x001e

0000b5dc <.Loc.369.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    b5dc:	4a 13       	calla	r10		;

0000b5de <.LVL105>:


  /* Start the receiver driver and initiate the receive loop */
  sx1212Start(&SX1212D1, &rx_cfg);
    b5de:	cd 04       	mova	r4,	r13	;
    b5e0:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b5e4:	b0 13 1c 75 	calla	#29980		;0x0751c

0000b5e8 <.LVL106>:
  
  elyRFDLLRxInit(&SX1212D1);
    b5e8:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b5ec:	b0 13 98 c6 	calla	#50840		;0x0c698

0000b5f0 <.LVL107>:
  
  events = (RFSpiAvailable | RFTxIdle);
    b5f0:	40 18 b2 40 	movx.w	#8192,	&0xfd282;0x02000
    b5f4:	00 20 82 d2 
    b5f8:	40 18 92 43 	movx.w	#1,	&0xfd284;r3 As==01
    b5fc:	84 d2 

0000b5fe <.Loc.380.2>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    b5fe:	48 13       	calla	r8		;

0000b600 <.LBB22>:
    b600:	c0 18 1c 42 	movx.w	&0x10c50,r12	;
    b604:	50 0c 

0000b606 <.LBE22>:
  if (chMBGetUsedCountI(&rf_mbox) > 0) {
    b606:	4d 43       	clr.b	r13		;
    b608:	0d 9c       	cmp	r12,	r13	;
    b60a:	07 34       	jge	$+16     	;abs 0xb61a

0000b60c <.Loc.382.2>:
    events |= RFPktAvailable;
    b60c:	40 18 b2 40 	movx.w	#9216,	&0xfd282;0x02400
    b610:	00 24 82 d2 
    b614:	40 18 92 43 	movx.w	#1,	&0xfd284;r3 As==01
    b618:	84 d2 

0000b61a <.L67>:
  }
  chSysUnlock();
    b61a:	4a 13       	calla	r10		;

0000b61c <.LVL110>:
      /* 
       * Read FifoThresh bytes from the Fifo using spiStartReceive
       *  In the callback - signal SpiAvailable, and post buffer and signal RxIdle if applicable
       * Clear RxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleRxFifo(&SX1212D1);
    b61c:	89 00 c6 c6 	mova	#50886,	r9	;0x0c6c6

0000b620 <.LBB24>:
  mask ^= mask & (mask - (eventmask_t)1);
    b620:	44 43       	clr.b	r4		;
    b622:	45 43       	clr.b	r5		;

0000b624 <.L92>:
  return ((events & bits) == bits);
    b624:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b628:	82 d2 
    b62a:	3c f0 00 30 	and	#12288,	r12	;#0x3000

0000b62e <.LBE29>:
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    b62e:	3c 90 00 30 	cmp	#12288,	r12	;#0x3000
    b632:	0a 20       	jnz	$+22     	;abs 0xb648

0000b634 <.Loc.393.2>:
      elyRFDLLHandleRxFifo(&SX1212D1);
    b634:	8c 01 e2 16 	mova	#71394,	r12	;0x116e2
    b638:	49 13       	calla	r9		;

0000b63a <.LVL111>:
      events &= ~(RFSpiAvailable | RFRxFifoThresh);
    b63a:	c0 1f b2 f0 	andx.w	#-12289,&0xfd282;0xfcfff
    b63e:	ff cf 82 d2 
    b642:	40 18 82 c3 	bicx.w	#0,	&0xfd284;r3 As==00
    b646:	84 d2 

0000b648 <.L68>:
  return ((events & bits) == bits);
    b648:	40 18 1d 42 	movx.w	&0x0d282,r13	;
    b64c:	82 d2 
    b64e:	3d f0 00 28 	and	#10240,	r13	;#0x2800
    b652:	40 18 1c 42 	movx.w	&0x0d284,r12	;
    b656:	84 d2 
    b658:	5c f3       	and.b	#1,	r12	;r3 As==01

0000b65a <.LBE31>:
    }
    if (bits_set(events, (RFSpiAvailable | RFTxFrameReady | RFTxIdle))) {
    b65a:	3d 90 00 28 	cmp	#10240,	r13	;#0x2800
    b65e:	0d 20       	jnz	$+28     	;abs 0xb67a
    b660:	1c 93       	cmp	#1,	r12	;r3 As==01
    b662:	0b 20       	jnz	$+24     	;abs 0xb67a

0000b664 <.Loc.397.2>:
      elyRFDLLInitiateTransmit(&SX1278D1);
    b664:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b668:	b0 13 ac ca 	calla	#51884		;0x0caac

0000b66c <.LVL112>:
      events &= ~(RFSpiAvailable | RFTxFrameReady | RFTxIdle);
    b66c:	c0 1f b2 f0 	andx.w	#-10241,&0xfd282;0xfd7ff
    b670:	ff d7 82 d2 
    b674:	40 18 92 c3 	bicx.w	#1,	&0xfd284;r3 As==01
    b678:	84 d2 

0000b67a <.L69>:
  return ((events & bits) == bits);
    b67a:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b67e:	82 d2 
    b680:	3c f0 00 a0 	and	#-24576,r12	;#0xa000

0000b684 <.LBE33>:
    }
    if (bits_set(events, (RFTxFifoLevel | RFSpiAvailable))) {
    b684:	3c 90 00 a0 	cmp	#-24576,r12	;#0xa000
    b688:	0b 20       	jnz	$+24     	;abs 0xb6a0

0000b68a <.Loc.407.2>:
       * Write FifoSize or BytesRemaining bytes to the Fifo using spiStartSend
       *  In the callback - signal SpiAvailable, and TxIdle if applicable
       *  TxFifoThresh signaled by PAL callback
       * Clear TxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleTxFifo(&SX1278D1);
    b68a:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0
    b68e:	b0 13 de ca 	calla	#51934		;0x0cade

0000b692 <.LVL113>:
      events &= ~(RFSpiAvailable | RFTxFifoLevel);
    b692:	40 18 b2 f0 	andx.w	#24575,	&0xfd282;0x05fff
    b696:	ff 5f 82 d2 
    b69a:	40 18 82 c3 	bicx.w	#0,	&0xfd284;r3 As==00
    b69e:	84 d2 

0000b6a0 <.L70>:
    }
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    b6a0:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b6a4:	82 d2 

0000b6a6 <.LBB35>:
  return ((events & bits) == bits);
    b6a6:	40 18 1d 42 	movx.w	&0x0d284,r13	;
    b6aa:	84 d2 
    b6ac:	5d f3       	and.b	#1,	r13	;r3 As==01

0000b6ae <.LBE35>:
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    b6ae:	40 18 3c b0 	bitx.w	#1024,	r12	;0x00400
    b6b2:	00 04 
    b6b4:	11 24       	jz	$+36     	;abs 0xb6d8
    b6b6:	1d 93       	cmp	#1,	r13	;r3 As==01
    b6b8:	0f 20       	jnz	$+32     	;abs 0xb6d8

0000b6ba <.Loc.410.2>:
    b6ba:	3c b0 00 08 	bit	#2048,	r12	;#0x0800
    b6be:	0c 20       	jnz	$+26     	;abs 0xb6d8

0000b6c0 <.Loc.416.2>:
      /*
       * Turn the NL packet into a DLL frame. Do it outside a lock zone.
       * Once the frame is ready, signal TxFrameReady to start transmission
       * Clear RFPktAvailable from Events variable
       */
      elyRFDLLBuildFrame();
    b6c0:	b0 13 e8 c3 	calla	#50152		;0x0c3e8

0000b6c4 <.LVL114>:
      events &= ~RFPktAvailable;
    b6c4:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b6c8:	82 d2 
    b6ca:	3c f0 ff fb 	and	#-1025,	r12	;#0xfbff

0000b6ce <.Loc.418.2>:
      events |= (RFTxFrameReady);
    b6ce:	3c d0 00 08 	bis	#2048,	r12	;#0x0800
    b6d2:	40 18 82 4c 	movx.w	r12,	&0xfd282;
    b6d6:	82 d2 

0000b6d8 <.L71>:
  return ((events & bits) == bits);
    b6d8:	40 18 1d 42 	movx.w	&0x0d282,r13	;
    b6dc:	82 d2 
    b6de:	3d f0 55 21 	and	#8533,	r13	;#0x2155
    b6e2:	40 18 1c 42 	movx.w	&0x0d284,r12	;
    b6e6:	84 d2 
    b6e8:	5c f3       	and.b	#1,	r12	;r3 As==01

0000b6ea <.LBE37>:
    }
    if (bits_set(events, (RFTxCfgMask | RFTxIdle | RFSpiAvailable))) {
    b6ea:	3d 90 55 21 	cmp	#8533,	r13	;#0x2155
    b6ee:	11 20       	jnz	$+36     	;abs 0xb712
    b6f0:	1c 93       	cmp	#1,	r12	;r3 As==01
    b6f2:	0f 20       	jnz	$+32     	;abs 0xb712

0000b6f4 <.LBB39>:
      while (events & RFTxCfgMask) {
        eventmask_t evt = get_next_event(events & RFTxCfgMask);
        
        switch (evt) {
    b6f4:	8a 00 7c cd 	mova	#52604,	r10	;0x0cd7c

0000b6f8 <.Loc.443.2>:
            break;
          case RFFilterParamsUpdated:
            elyRFChangeTxFilterParamsS(&tx_cfg);
            break;
          default:
            chDbgAssert(false, "shouldn't happen");
    b6f8:	88 00 3e 46 	mova	#17982,	r8	;0x0463e

0000b6fc <.L72>:
      while (events & RFTxCfgMask) {
    b6fc:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b700:	82 d2 
    b702:	3c f0 55 01 	and	#341,	r12	;#0x0155
    b706:	81 4c 04 00 	mov	r12,	4(r1)	;
    b70a:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    b70e:	0c 93       	cmp	#0,	r12	;r3 As==00
    b710:	24 20       	jnz	$+74     	;abs 0xb75a

0000b712 <.L91>:
  return ((events & bits) == bits);
    b712:	40 18 1c 42 	movx.w	&0x0d282,r12	;
    b716:	82 d2 
    b718:	3c f0 aa 60 	and	#24746,	r12	;#0x60aa

0000b71c <.LBE40>:
        
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    if (bits_set(events, (RFRxCfgMask | RFRxIdle | RFSpiAvailable))) {
    b71c:	3c 90 aa 60 	cmp	#24746,	r12	;#0x60aa
    b720:	0f 20       	jnz	$+32     	;abs 0xb740

0000b722 <.LBB42>:
      while (events & RFRxCfgMask) {
        eventmask_t evt = get_next_event(events & RFRxCfgMask);
        
        switch (evt) {
    b722:	8a 00 7c cd 	mova	#52604,	r10	;0x0cd7c

0000b726 <.Loc.470.2>:
            elyRFChangeRxSyncS(&rx_cfg);
          case RFFilterParamsUpdated:
            elyRFChangeRxFilterParamsS(&rx_cfg);
            break;
          default:
            chDbgAssert(false, "shouldn't happen");
    b726:	88 00 3e 46 	mova	#17982,	r8	;0x0463e

0000b72a <.L74>:
      while (events & RFRxCfgMask) {
    b72a:	40 18 1e 42 	movx.w	&0x0d282,r14	;
    b72e:	82 d2 
    b730:	7e f0 aa 00 	and.b	#170,	r14	;#0x00aa
    b734:	81 4e 00 00 	mov	r14,	0(r1)	;
    b738:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    b73c:	0e 93       	cmp	#0,	r14	;r3 As==00
    b73e:	53 20       	jnz	$+168    	;abs 0xb7e6

0000b740 <.L76>:
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    
    events |= chEvtWaitAnyTimeout(AllRfEvents, TIME_INFINITE);
    b740:	4e 43       	clr.b	r14		;
    b742:	3c 43       	mov	#-1,	r12	;r3 As==11
    b744:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b746:	b0 13 0e 4a 	calla	#18958		;0x04a0e

0000b74a <.LVL115>:
    b74a:	40 18 82 dc 	bisx.w	r12,	&0xfd282;
    b74e:	82 d2 
    b750:	40 18 82 dd 	bisx.w	r13,	&0xfd284;
    b754:	84 d2 

0000b756 <.Loc.387.2>:
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    b756:	80 00 24 b6 	mova	#46628,	r0	;0x0b624

0000b75a <.L90>:
  mask ^= mask & (mask - (eventmask_t)1);
    b75a:	06 44       	mov	r4,	r6	;
    b75c:	07 45       	mov	r5,	r7	;
    b75e:	40 18 16 81 	subx.w	4(r1),	r6	;
    b762:	04 00 
    b764:	40 18 17 71 	subcx.w	6(r1),	r7	;
    b768:	06 00 
    b76a:	16 f1 04 00 	and	4(r1),	r6	;

0000b76e <.LBE28>:
        switch (evt) {
    b76e:	36 90 10 00 	cmp	#16,	r6	;#0x0010
    b772:	09 20       	jnz	$+20     	;abs 0xb786

0000b774 <.Loc.432.2>:
            elyRFChangeTxDevS(&tx_cfg);
    b774:	8c 01 ea 0b 	mova	#68586,	r12	;0x10bea
    b778:	b0 13 b8 b1 	calla	#45496		;0x0b1b8

0000b77c <.L89>:
        events &= ~evt;
    b77c:	40 18 82 c6 	bicx.w	r6,	&0xfd282;
    b780:	82 d2 
    b782:	80 00 fc b6 	mova	#46844,	r0	;0x0b6fc

0000b786 <.L79>:
        switch (evt) {
    b786:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b78a:	4f 43       	clr.b	r15		;
    b78c:	0c 46       	mov	r6,	r12	;
    b78e:	4d 43       	clr.b	r13		;
    b790:	4a 13       	calla	r10		;
    b792:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b794:	0e 9c       	cmp	r12,	r14	;
    b796:	09 28       	jnc	$+20     	;abs 0xb7aa
    b798:	06 9e       	cmp	r14,	r6	;
    b79a:	13 24       	jz	$+40     	;abs 0xb7c2
    b79c:	26 92       	cmp	#4,	r6	;r2 As==10
    b79e:	17 24       	jz	$+48     	;abs 0xb7ce

0000b7a0 <.L77>:
            chDbgAssert(false, "shouldn't happen");
    b7a0:	8c 01 be 08 	mova	#67774,	r12	;0x108be
    b7a4:	48 13       	calla	r8		;

0000b7a6 <.LVL120>:
    b7a6:	80 00 7c b7 	mova	#46972,	r0	;0x0b77c

0000b7aa <.L80>:
        switch (evt) {
    b7aa:	36 90 40 00 	cmp	#64,	r6	;#0x0040
    b7ae:	15 24       	jz	$+44     	;abs 0xb7da
    b7b0:	36 90 00 01 	cmp	#256,	r6	;#0x0100
    b7b4:	f5 23       	jnz	$-20     	;abs 0xb7a0

0000b7b6 <.L87>:
            elyRFChangeTxPowerS(&tx_cfg);
    b7b6:	8c 01 ea 0b 	mova	#68586,	r12	;0x10bea
    b7ba:	b0 13 1c b4 	calla	#46108		;0x0b41c

0000b7be <.LVL121>:
            break;
    b7be:	80 00 7c b7 	mova	#46972,	r0	;0x0b77c

0000b7c2 <.L105>:
            elyRFChangeTxFreqS(&tx_cfg);
    b7c2:	8c 01 ea 0b 	mova	#68586,	r12	;0x10bea
    b7c6:	b0 13 72 ad 	calla	#44402		;0x0ad72

0000b7ca <.LVL122>:
            break;
    b7ca:	80 00 7c b7 	mova	#46972,	r0	;0x0b77c

0000b7ce <.L106>:
            elyRFChangeTxBRS(&tx_cfg);
    b7ce:	8c 01 ea 0b 	mova	#68586,	r12	;0x10bea
    b7d2:	b0 13 a4 af 	calla	#44964		;0x0afa4

0000b7d6 <.LVL123>:
            break;
    b7d6:	80 00 7c b7 	mova	#46972,	r0	;0x0b77c

0000b7da <.L107>:
            elyRFChangeTxSyncS(&tx_cfg);
    b7da:	8c 01 ea 0b 	mova	#68586,	r12	;0x10bea
    b7de:	b0 13 54 c2 	calla	#49748		;0x0c254

0000b7e2 <.LVL124>:
    b7e2:	80 00 b6 b7 	mova	#47030,	r0	;0x0b7b6

0000b7e6 <.L104>:
  mask ^= mask & (mask - (eventmask_t)1);
    b7e6:	06 44       	mov	r4,	r6	;
    b7e8:	07 45       	mov	r5,	r7	;
    b7ea:	40 18 26 81 	subx.w	@r1,	r6	;
    b7ee:	40 18 17 71 	subcx.w	2(r1),	r7	;
    b7f2:	02 00 
    b7f4:	26 f1       	and	@r1,	r6	;

0000b7f6 <.LBE43>:
        switch (evt) {
    b7f6:	36 92       	cmp	#8,	r6	;r2 As==11
    b7f8:	09 20       	jnz	$+20     	;abs 0xb80c

0000b7fa <.Loc.459.2>:
            elyRFChangeRxBRS(&rx_cfg);
    b7fa:	8c 01 be 0b 	mova	#68542,	r12	;0x10bbe
    b7fe:	b0 13 ae b0 	calla	#45230		;0x0b0ae

0000b802 <.L103>:
        events &= ~evt;
    b802:	40 18 82 c6 	bicx.w	r6,	&0xfd282;
    b806:	82 d2 
    b808:	80 00 2a b7 	mova	#46890,	r0	;0x0b72a

0000b80c <.L95>:
        switch (evt) {
    b80c:	7e 42       	mov.b	#8,	r14	;r2 As==11
    b80e:	4f 43       	clr.b	r15		;
    b810:	0c 46       	mov	r6,	r12	;
    b812:	4d 43       	clr.b	r13		;
    b814:	4a 13       	calla	r10		;
    b816:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b818:	0d 9c       	cmp	r12,	r13	;
    b81a:	07 28       	jnc	$+16     	;abs 0xb82a
    b81c:	26 93       	cmp	#2,	r6	;r3 As==10
    b81e:	15 24       	jz	$+44     	;abs 0xb84a

0000b820 <.L93>:
            chDbgAssert(false, "shouldn't happen");
    b820:	8c 01 be 08 	mova	#67774,	r12	;0x108be
    b824:	48 13       	calla	r8		;

0000b826 <.LVL129>:
    b826:	80 00 02 b8 	mova	#47106,	r0	;0x0b802

0000b82a <.L96>:
        switch (evt) {
    b82a:	36 90 20 00 	cmp	#32,	r6	;#0x0020
    b82e:	13 24       	jz	$+40     	;abs 0xb856
    b830:	36 90 80 00 	cmp	#128,	r6	;#0x0080
    b834:	f5 23       	jnz	$-20     	;abs 0xb820

0000b836 <.Loc.465.2>:
            elyRFChangeRxSyncS(&rx_cfg);
    b836:	8c 01 be 0b 	mova	#68542,	r12	;0x10bbe
    b83a:	b0 13 d4 b3 	calla	#46036		;0x0b3d4

0000b83e <.LVL130>:
            elyRFChangeRxFilterParamsS(&rx_cfg);
    b83e:	8c 01 be 0b 	mova	#68542,	r12	;0x10bbe
    b842:	b0 13 32 b4 	calla	#46130		;0x0b432

0000b846 <.LVL131>:
            break;
    b846:	80 00 02 b8 	mova	#47106,	r0	;0x0b802

0000b84a <.L108>:
            elyRFChangeRxFreqS(&rx_cfg);
    b84a:	8c 01 be 0b 	mova	#68542,	r12	;0x10bbe
    b84e:	b0 13 8a ae 	calla	#44682		;0x0ae8a

0000b852 <.LVL132>:
            break;
    b852:	80 00 02 b8 	mova	#47106,	r0	;0x0b802

0000b856 <.L109>:
            elyRFChangeRxDevS(&rx_cfg);
    b856:	8c 01 be 0b 	mova	#68542,	r12	;0x10bbe
    b85a:	b0 13 c6 b2 	calla	#45766		;0x0b2c6

0000b85e <.LVL133>:
            break;
    b85e:	80 00 02 b8 	mova	#47106,	r0	;0x0b802

0000b862 <addr_cb>:
  elyQueueFreeBufferI(&fram_queue, (uint8_t *)(active_req));
  chBSemSignalI(&fram_sem);
  chSysUnlockFromISR();
}

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    b862:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000b864 <.LCFI0>:
    b864:	06 14       	pushm.a	#1,	r6	;20-bit words

0000b866 <.LCFI1>:
    b866:	b1 00 08 00 	suba	#8,	r1	;

0000b86a <.LCFI2>:
    b86a:	c8 0c       	mova	r12,	r8	;

0000b86c <.Loc.38.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    b86c:	2c 00 a6 d2 	mova	&53926,	r12	;0x0d2a6

0000b870 <.LVL1>:
  
  chSysLockFromISR();
  /* TODO put in an assert in here for the Rev A crossing page boundaries */
  if (req->read) {
    b870:	5e 4c 04 00 	mov.b	4(r12),	r14	;

0000b874 <.LVL2>:
    b874:	4d 4e       	mov.b	r14,	r13	;

0000b876 <.LVL3>:
    b876:	5d f3       	and.b	#1,	r13	;r3 As==01
    b878:	36 0c 08 00 	mova	8(r12),	r6	;
    b87c:	5a 4c 06 00 	mov.b	6(r12),	r10	;
    b880:	59 4c 10 00 	mov.b	16(r12),r9	;0x00010

0000b884 <.Loc.45.1>:
    if (req->special) {
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    b884:	1c 4c 04 00 	mov	4(r12),	r12	;

0000b888 <.LVL4>:
  if (req->read) {
    b888:	40 18 2e b3 	bitx.w	#2,	r14	;r3 As==10
    b88c:	37 24       	jz	$+112    	;abs 0xb8fc

0000b88e <.Loc.43.1>:
    if (req->special) {
    b88e:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    b890:	1c 24       	jz	$+58     	;abs 0xb8ca

0000b892 <.Loc.45.1>:
          req->size, req->buffer, end_cb);
    b892:	b0 13 e4 cc 	calla	#52452		;0x0cce4

0000b896 <.LVL5>:
    b896:	0d 4a       	mov	r10,	r13	;
    b898:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b89c:	0d dc       	bis	r12,	r13	;
    b89e:	81 4d 04 00 	mov	r13,	4(r1)	;
    b8a2:	5a 07       	rrum	#2,	r10	;
    b8a4:	5a f3       	and.b	#1,	r10	;r3 As==01
    b8a6:	81 4a 06 00 	mov	r10,	6(r1)	;

0000b8aa <.Loc.44.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    b8aa:	00 18 f1 40 	movx.a	#47460,	0(r1)	;0x0b964
    b8ae:	64 b9 00 00 
    b8b2:	cf 06       	mova	r6,	r15	;
    b8b4:	3e 01 04 00 	mova	4(r1),	r14	;
    b8b8:	4d 49       	mov.b	r9,	r13	;
    b8ba:	cc 08       	mova	r8,	r12	;
    b8bc:	b0 13 28 5a 	calla	#23080		;0x05a28

0000b8c0 <.L1>:
          req->buffer, end_cb);
    }
  }
  current_callback = req->callback;
  chSysUnlockFromISR();
}
    b8c0:	a1 00 08 00 	adda	#8,	r1	;
    b8c4:	06 16       	popm.a	#1,	r6	;20-bit words
    b8c6:	28 16       	popm.a	#3,	r10	;20-bit words
    b8c8:	10 01       	reta			;

0000b8ca <.L3>:
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    b8ca:	b0 13 e4 cc 	calla	#52452		;0x0cce4

0000b8ce <.LVL8>:
    b8ce:	0d 4a       	mov	r10,	r13	;
    b8d0:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b8d4:	0d dc       	bis	r12,	r13	;
    b8d6:	81 4d 04 00 	mov	r13,	4(r1)	;
    b8da:	5a 07       	rrum	#2,	r10	;
    b8dc:	5a f3       	and.b	#1,	r10	;r3 As==01
    b8de:	81 4a 06 00 	mov	r10,	6(r1)	;
    b8e2:	00 18 f1 40 	movx.a	#47460,	0(r1)	;0x0b964
    b8e6:	64 b9 00 00 
    b8ea:	cf 06       	mova	r6,	r15	;
    b8ec:	3e 01 04 00 	mova	4(r1),	r14	;
    b8f0:	4d 49       	mov.b	r9,	r13	;
    b8f2:	cc 08       	mova	r8,	r12	;
    b8f4:	b0 13 12 5b 	calla	#23314		;0x05b12

0000b8f8 <.LVL9>:
    b8f8:	80 00 c0 b8 	mova	#47296,	r0	;0x0b8c0

0000b8fc <.L2>:
    if (req->special) {
    b8fc:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    b8fe:	19 24       	jz	$+52     	;abs 0xb932

0000b900 <.Loc.58.1>:
          req->size, req->buffer, end_cb);
    b900:	b0 13 e4 cc 	calla	#52452		;0x0cce4

0000b904 <.LVL11>:
    b904:	0d 4a       	mov	r10,	r13	;
    b906:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b90a:	0d dc       	bis	r12,	r13	;
    b90c:	81 4d 04 00 	mov	r13,	4(r1)	;
    b910:	5a 07       	rrum	#2,	r10	;
    b912:	5a f3       	and.b	#1,	r10	;r3 As==01
    b914:	81 4a 06 00 	mov	r10,	6(r1)	;

0000b918 <.Loc.57.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    b918:	00 18 f1 40 	movx.a	#47460,	0(r1)	;0x0b964
    b91c:	64 b9 00 00 
    b920:	cf 06       	mova	r6,	r15	;
    b922:	3e 01 04 00 	mova	4(r1),	r14	;
    b926:	4d 49       	mov.b	r9,	r13	;
    b928:	cc 08       	mova	r8,	r12	;
    b92a:	b0 13 b4 5c 	calla	#23732		;0x05cb4

0000b92e <.LVL12>:
    b92e:	80 00 c0 b8 	mova	#47296,	r0	;0x0b8c0

0000b932 <.L5>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    b932:	b0 13 e4 cc 	calla	#52452		;0x0cce4

0000b936 <.LVL14>:
    b936:	0d 4a       	mov	r10,	r13	;
    b938:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b93c:	0d dc       	bis	r12,	r13	;
    b93e:	81 4d 04 00 	mov	r13,	4(r1)	;
    b942:	5a 07       	rrum	#2,	r10	;
    b944:	5a f3       	and.b	#1,	r10	;r3 As==01
    b946:	81 4a 06 00 	mov	r10,	6(r1)	;
    b94a:	00 18 f1 40 	movx.a	#47460,	0(r1)	;0x0b964
    b94e:	64 b9 00 00 
    b952:	cf 06       	mova	r6,	r15	;
    b954:	3e 01 04 00 	mova	4(r1),	r14	;
    b958:	4d 49       	mov.b	r9,	r13	;
    b95a:	cc 08       	mova	r8,	r12	;
    b95c:	b0 13 5a 5d 	calla	#23898		;0x05d5a

0000b960 <.LVL15>:
}
    b960:	80 00 c0 b8 	mova	#47296,	r0	;0x0b8c0

0000b964 <end_cb>:
void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    b964:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b966 <.LCFI3>:
    b966:	ca 0d       	mova	r13,	r10	;

0000b968 <.Loc.22.1>:
  i2cMSP430XEndTransferI(i2cp);
    b968:	b0 13 02 5e 	calla	#24066		;0x05e02

0000b96c <.LVL17>:
  if (active_req->callback) {
    b96c:	2c 00 a6 d2 	mova	&53926,	r12	;0x0d2a6
    b970:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    b974:	9e 00 00 00 	cmpa	#0,	r14	;
    b978:	02 24       	jz	$+6      	;abs 0xb97e

0000b97a <.Loc.26.1>:
    active_req->callback(buffer);
    b97a:	cc 0a       	mova	r10,	r12	;
    b97c:	4e 13       	calla	r14		;

0000b97e <.L7>:
  elyQueueFreeBufferI(&fram_queue, (uint8_t *)(active_req));
    b97e:	2d 00 a6 d2 	mova	&53926,	r13	;0x0d2a6
    b982:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2
    b986:	b0 13 62 bb 	calla	#47970		;0x0bb62

0000b98a <.LBB16>:
  if (bsp->sem.cnt < (cnt_t)1) {
    b98a:	c0 18 1c 42 	movx.w	&0x10c58,r12	;
    b98e:	58 0c 
    b990:	4d 43       	clr.b	r13		;
    b992:	0d 9c       	cmp	r12,	r13	;
    b994:	04 38       	jl	$+10     	;abs 0xb99e

0000b996 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    b996:	8c 01 58 0c 	mova	#68696,	r12	;0x10c58
    b99a:	b0 13 2e 49 	calla	#18734		;0x0492e

0000b99e <.L6>:
}
    b99e:	0a 16       	popm.a	#1,	r10	;20-bit words
    b9a0:	10 01       	reta			;

0000b9a2 <fram_handle_request>:

void fram_handle_request(fram_req_t * req) {
    b9a2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b9a4 <.LCFI4>:
    b9a4:	b1 00 04 00 	suba	#4,	r1	;

0000b9a8 <.LCFI5>:
    b9a8:	ca 0c       	mova	r12,	r10	;

0000b9aa <.Loc.70.1>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    b9aa:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000b9ac <.LVL22>:
    b9ac:	1c 9a 02 00 	cmp	2(r10),	r12	;
    b9b0:	04 2c       	jc	$+10     	;abs 0xb9ba

0000b9b2 <.Loc.70.1>:
    b9b2:	8c 01 e9 08 	mova	#67817,	r12	;0x108e9
    b9b6:	b0 13 3e 46 	calla	#17982		;0x0463e

0000b9ba <.L13>:
  
  active_req = req;
    b9ba:	60 0a a6 d2 	mova	r10,	&53926	; 0x0d2a6

0000b9be <.Loc.75.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    b9be:	2c 4a       	mov	@r10,	r12	;
    b9c0:	1d 4a 02 00 	mov	2(r10),	r13	;
    b9c4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b9c8:	b0 13 5e cd 	calla	#52574		;0x0cd5e

0000b9cc <.Loc.74.1>:
  req->device_id = (slave_id | device_select | 
    b9cc:	4d 4c       	mov.b	r12,	r13	;
    b9ce:	7d d0 50 00 	bis.b	#80,	r13	;#0x0050
    b9d2:	ca 4d 10 00 	mov.b	r13,	16(r10)	; 0x0010

0000b9d6 <.LBB22>:
  _disable_interrupts();
    b9d6:	32 c2       	dint			
    b9d8:	03 43       	nop			

0000b9da <.Loc.348.3>:
  asm volatile("nop");
    b9da:	03 43       	nop			

0000b9dc <.LBE22>:
  
  /* Issue a write to set the address */
  chSysLock();
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    b9dc:	00 18 f1 40 	movx.a	#47202,	0(r1)	;0x0b862
    b9e0:	62 b8 00 00 
    b9e4:	cf 0a       	mova	r10,	r15	;
    b9e6:	6e 43       	mov.b	#2,	r14	;r3 As==10
    b9e8:	8c 01 24 16 	mova	#71204,	r12	;0x11624
    b9ec:	b0 13 f8 5b 	calla	#23544		;0x05bf8

0000b9f0 <.LBB24>:
  asm volatile("nop");
    b9f0:	03 43       	nop			

0000b9f2 <.Loc.356.3>:
  _enable_interrupts();
    b9f2:	03 43       	nop			
    b9f4:	32 d2       	eint			
    b9f6:	03 43       	nop			

0000b9f8 <.LBE24>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
  chSysUnlock();
}
    b9f8:	a1 00 04 00 	adda	#4,	r1	;
    b9fc:	0a 16       	popm.a	#1,	r10	;20-bit words
    b9fe:	10 01       	reta			;

0000ba00 <elyFramGetRequest>:

msg_t elyFramGetRequest(fram_req_t ** reqp) {
    ba00:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ba02 <.LCFI6>:
    ba02:	ca 0c       	mova	r12,	r10	;

0000ba04 <.Loc.86.1>:
  msg_t r = elyQueueGetEmptyBufferTimeout(&fram_queue, (uint8_t **)reqp, TIME_IMMEDIATE);
    ba04:	3e 43       	mov	#-1,	r14	;r3 As==11
    ba06:	cd 0c       	mova	r12,	r13	;
    ba08:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2

0000ba0c <.LVL27>:
    ba0c:	b0 13 4e bb 	calla	#47950		;0x0bb4e

0000ba10 <.LVL28>:
  /* ENH remove this hack - should be at PointOfCall */
  (*reqp)->special = 0;
    ba10:	0e 0a       	mova	@r10,	r14	;
    ba12:	de c3 04 00 	bic.b	#1,	4(r14)	;r3 As==01

0000ba16 <.Loc.90.1>:
  return r;
}
    ba16:	0a 16       	popm.a	#1,	r10	;20-bit words
    ba18:	10 01       	reta			;

0000ba1a <elyFramPostRequest>:
  _disable_interrupts();
    ba1a:	32 c2       	dint			
    ba1c:	03 43       	nop			

0000ba1e <.Loc.348.3>:
  asm volatile("nop");
    ba1e:	03 43       	nop			

0000ba20 <.LBE30>:

msg_t elyFramPostRequest(fram_req_t * req) {
  msg_t result;
  chSysLock();
  result = elyQueuePostFullBufferS(&fram_queue, (uint8_t *)(req), TIME_IMMEDIATE);
    ba20:	3e 43       	mov	#-1,	r14	;r3 As==11
    ba22:	cd 0c       	mova	r12,	r13	;
    ba24:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2

0000ba28 <.LVL30>:
    ba28:	b0 13 f2 ba 	calla	#47858		;0x0baf2

0000ba2c <.LBB32>:
  asm volatile("nop");
    ba2c:	03 43       	nop			

0000ba2e <.Loc.356.3>:
  _enable_interrupts();
    ba2e:	03 43       	nop			
    ba30:	32 d2       	eint			
    ba32:	03 43       	nop			

0000ba34 <.LBE32>:
  chSysUnlock();
  return result;
}
    ba34:	10 01       	reta			;

0000ba36 <elyFramGetRequestTimeoutS>:

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    ba36:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ba38 <.LCFI7>:
    ba38:	ca 0c       	mova	r12,	r10	;

0000ba3a <.Loc.101.1>:
  msg_t r = elyQueueGetEmptyBufferTimeoutS(&fram_queue, (uint8_t **)reqp, timeout);
    ba3a:	0e 4d       	mov	r13,	r14	;
    ba3c:	cd 0c       	mova	r12,	r13	;

0000ba3e <.LVL33>:
    ba3e:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2

0000ba42 <.LVL34>:
    ba42:	b0 13 28 bb 	calla	#47912		;0x0bb28

0000ba46 <.LVL35>:
  (*reqp)->special = 0;
    ba46:	0e 0a       	mova	@r10,	r14	;
    ba48:	de c3 04 00 	bic.b	#1,	4(r14)	;r3 As==01

0000ba4c <.Loc.104.1>:
  return r;
}
    ba4c:	0a 16       	popm.a	#1,	r10	;20-bit words
    ba4e:	10 01       	reta			;

0000ba50 <FramThd>:
static I2CConfig cfg = {
  400000, /* max bitrate supported by USCI */
};

THD_WORKING_AREA(waFramThd, 256);
THD_FUNCTION(FramThd, arg) {
    ba50:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ba52 <.LCFI8>:
    ba52:	08 14       	pushm.a	#1,	r8	;20-bit words

0000ba54 <.LCFI9>:
    ba54:	b1 00 04 00 	suba	#4,	r1	;

0000ba58 <.LCFI10>:
  (void)arg;
  fram_req_t * req;
  
  i2cStart(&I2CDB0, &cfg);
    ba58:	8d 01 54 0c 	mova	#68692,	r13	;0x10c54
    ba5c:	8c 01 24 16 	mova	#71204,	r12	;0x11624

0000ba60 <.LVL37>:
    ba60:	b0 13 02 4f 	calla	#20226		;0x04f02

0000ba64 <.LVL38>:
  
  if (!elyIsQueueInitialized(&fram_queue)) {
    ba64:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2
    ba68:	b0 13 ba ba 	calla	#47802		;0x0baba

0000ba6c <.LVL39>:
    ba6c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    ba6e:	08 20       	jnz	$+18     	;abs 0xba80

0000ba70 <.Loc.118.1>:
    elyQueueObjectInit(&fram_queue, sizeof(fram_req_t), (uint8_t *)(fram_queue_storage));
    ba70:	8e 01 5a 0c 	mova	#68698,	r14	;0x10c5a
    ba74:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    ba78:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2
    ba7c:	b0 13 ca ba 	calla	#47818		;0x0baca

0000ba80 <.L20>:
  }
  
  chSemObjectInit(&fram_queue.mbox.fullsem, (cnt_t)0);
    ba80:	41 18 82 43 	movx.w	#0,	&0x10cb6;r3 As==00
    ba84:	b6 0c 

0000ba86 <.Loc.123.1>:
  
  while (MSG_OK == elyQueuePend(&fram_queue, (uint8_t**)(&req), TIME_INFINITE)) {
    ba86:	8a 00 a2 bb 	mova	#48034,	r10	;0x0bba2

0000ba8a <.LBB36>:
  return chSemWaitTimeout(&bsp->sem, time);
    ba8a:	88 00 b2 48 	mova	#18610,	r8	;0x048b2

0000ba8e <.L21>:
    ba8e:	4e 43       	clr.b	r14		;
    ba90:	cd 01       	mova	r1,	r13	;
    ba92:	8c 01 a2 0c 	mova	#68770,	r12	;0x10ca2
    ba96:	4a 13       	calla	r10		;

0000ba98 <.LVL41>:
    ba98:	9c 00 00 00 	cmpa	#0,	r12	;
    ba9c:	05 24       	jz	$+12     	;abs 0xbaa8

0000ba9e <.Loc.132.1>:
#if ELY_REVISION == A
    chThdSleepMilliseconds(10);
#endif
  }
  
}
    ba9e:	a1 00 04 00 	adda	#4,	r1	;
    baa2:	08 16       	popm.a	#1,	r8	;20-bit words
    baa4:	0a 16       	popm.a	#1,	r10	;20-bit words
    baa6:	10 01       	reta			;

0000baa8 <.L22>:
    baa8:	4d 43       	clr.b	r13		;
    baaa:	8c 01 58 0c 	mova	#68696,	r12	;0x10c58
    baae:	48 13       	calla	r8		;

0000bab0 <.LBE39>:
    fram_handle_request(req);
    bab0:	0c 01       	mova	@r1,	r12	;
    bab2:	b0 13 a2 b9 	calla	#47522		;0x0b9a2

0000bab6 <.LVL44>:
    bab6:	80 00 8e ba 	mova	#47758,	r0	;0x0ba8e

0000baba <elyIsQueueInitialized>:
#include "queues.h"

bool elyIsQueueInitialized( queue_t * queue ) {
  return (queue->mpool.pool.object_size != 0);
    baba:	5d 43       	mov.b	#1,	r13	;r3 As==01
    babc:	00 18 cc 93 	cmpx.a	#0,	30(r12)	;r3 As==00, 0x0001e
    bac0:	1e 00 
    bac2:	01 20       	jnz	$+4      	;abs 0xbac6
    bac4:	4d 43       	clr.b	r13		;

0000bac6 <.L2>:
}
    bac6:	4c 4d       	mov.b	r13,	r12	;

0000bac8 <.LVL1>:
    bac8:	10 01       	reta			;

0000baca <elyQueueObjectInit>:

void elyQueueObjectInit( queue_t * queue, size_t buf_size, uint8_t * mpool_storage ) {
    baca:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bacc <.LCFI0>:
    bacc:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bace <.LCFI1>:
    bace:	06 14       	pushm.a	#1,	r6	;20-bit words

0000bad0 <.LCFI2>:
    bad0:	c8 0c       	mova	r12,	r8	;
    bad2:	c6 0e       	mova	r14,	r6	;

0000bad4 <.Loc.8.1>:
  chGuardedPoolObjectInit(&(queue->mpool), buf_size);
    bad4:	ca 0c       	mova	r12,	r10	;
    bad6:	aa 00 18 00 	adda	#24,	r10	;0x00018
    bada:	cc 0a       	mova	r10,	r12	;

0000badc <.LVL3>:
    badc:	b0 13 b2 4c 	calla	#19634		;0x04cb2

0000bae0 <.LVL4>:
  chGuardedPoolLoadArray(&(queue->mpool), mpool_storage, queue->queue_len);
    bae0:	0e 08       	mova	@r8,	r14	;
    bae2:	cd 06       	mova	r6,	r13	;
    bae4:	cc 0a       	mova	r10,	r12	;
    bae6:	b0 13 18 4d 	calla	#19736		;0x04d18

0000baea <.LVL5>:
}
    baea:	06 16       	popm.a	#1,	r6	;20-bit words
    baec:	08 16       	popm.a	#1,	r8	;20-bit words
    baee:	0a 16       	popm.a	#1,	r10	;20-bit words
    baf0:	10 01       	reta			;

0000baf2 <elyQueuePostFullBufferS>:

msg_t elyQueuePostFullBufferS(queue_t * queue, uint8_t * buffer, systime_t timeout) {
    baf2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000baf4 <.LCFI3>:
    baf4:	08 14       	pushm.a	#1,	r8	;20-bit words

0000baf6 <.LCFI4>:
    baf6:	b1 00 04 00 	suba	#4,	r1	;

0000bafa <.LCFI5>:
    bafa:	ca 0c       	mova	r12,	r10	;
    bafc:	c8 0d       	mova	r13,	r8	;

0000bafe <.Loc.14.1>:
  chDbgCheckClassS();
  chDbgCheck(queue != NULL);
    bafe:	9c 00 00 00 	cmpa	#0,	r12	;
    bb02:	07 20       	jnz	$+16     	;abs 0xbb12

0000bb04 <.Loc.14.1>:
    bb04:	8c 01 a8 09 	mova	#68008,	r12	;0x109a8

0000bb08 <.LVL7>:
    bb08:	71 0e 00 00 	mova	r14,	0(r1)	;
    bb0c:	b0 13 3e 46 	calla	#17982		;0x0463e

0000bb10 <.LVL8>:
    bb10:	0e 01       	mova	@r1,	r14	;

0000bb12 <.L5>:
  
  return chMBPostS(&(queue->mbox), (msg_t)(buffer), timeout);
    bb12:	cd 08       	mova	r8,	r13	;
    bb14:	cc 0a       	mova	r10,	r12	;
    bb16:	ac 00 04 00 	adda	#4,	r12	;
    bb1a:	b0 13 72 4a 	calla	#19058		;0x04a72

0000bb1e <.LVL9>:
}
    bb1e:	a1 00 04 00 	adda	#4,	r1	;
    bb22:	08 16       	popm.a	#1,	r8	;20-bit words
    bb24:	0a 16       	popm.a	#1,	r10	;20-bit words
    bb26:	10 01       	reta			;

0000bb28 <elyQueueGetEmptyBufferTimeoutS>:
  chDbgCheck(queue != NULL);
  
  return chMBPostAheadI(&(queue->mbox), (msg_t)(buffer));
}

msg_t elyQueueGetEmptyBufferTimeoutS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bb28:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bb2a <.LCFI13>:
    bb2a:	ca 0d       	mova	r13,	r10	;

0000bb2c <.Loc.41.1>:
  void * result = chGuardedPoolAllocTimeoutS(&(queue->mpool), timeout);
    bb2c:	0d 4e       	mov	r14,	r13	;

0000bb2e <.LVL23>:
    bb2e:	ac 00 18 00 	adda	#24,	r12	;0x00018

0000bb32 <.LVL24>:
    bb32:	b0 13 c8 4c 	calla	#19656		;0x04cc8

0000bb36 <.LVL25>:
  if (result == NULL) {
    bb36:	9c 00 00 00 	cmpa	#0,	r12	;
    bb3a:	05 24       	jz	$+12     	;abs 0xbb46

0000bb3c <.Loc.46.1>:
    return MSG_TIMEOUT;
  }
  
  (*bufferp) = result;
    bb3c:	7a 0c 00 00 	mova	r12,	0(r10)	;

0000bb40 <.Loc.47.1>:
  return MSG_OK;
    bb40:	4c 43       	clr.b	r12		;

0000bb42 <.L12>:
}
    bb42:	0a 16       	popm.a	#1,	r10	;20-bit words
    bb44:	10 01       	reta			;

0000bb46 <.L14>:
    return MSG_TIMEOUT;
    bb46:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000bb4a <.LVL28>:
    bb4a:	80 00 42 bb 	mova	#47938,	r0	;0x0bb42

0000bb4e <elyQueueGetEmptyBufferTimeout>:
  _disable_interrupts();
    bb4e:	32 c2       	dint			
    bb50:	03 43       	nop			

0000bb52 <.Loc.348.2>:
  asm volatile("nop");
    bb52:	03 43       	nop			

0000bb54 <.LBE12>:

msg_t elyQueueGetEmptyBufferTimeout(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
  msg_t result;
  chSysLock();
  result = elyQueueGetEmptyBufferTimeoutS(queue, bufferp, timeout);
    bb54:	b0 13 28 bb 	calla	#47912		;0x0bb28

0000bb58 <.LBB14>:
  asm volatile("nop");
    bb58:	03 43       	nop			

0000bb5a <.Loc.356.2>:
  _enable_interrupts();
    bb5a:	03 43       	nop			
    bb5c:	32 d2       	eint			
    bb5e:	03 43       	nop			

0000bb60 <.LBE14>:
  chSysUnlock();
  return result;
}
    bb60:	10 01       	reta			;

0000bb62 <elyQueueFreeBufferI>:

void elyQueueFreeBufferI(queue_t * queue, uint8_t * buffer) {
  chGuardedPoolFreeI(&(queue->mpool), buffer);
    bb62:	ac 00 18 00 	adda	#24,	r12	;0x00018

0000bb66 <.LVL32>:
    bb66:	b0 13 ea 4c 	calla	#19690		;0x04cea

0000bb6a <.LVL33>:
}
    bb6a:	10 01       	reta			;

0000bb6c <elyQueuePendS>:

/* TODO add timeout variant using guarded pools */

msg_t elyQueuePendS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    bb6c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bb6e <.LCFI14>:
    bb6e:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bb70 <.LCFI15>:
    bb70:	b1 00 04 00 	suba	#4,	r1	;

0000bb74 <.LCFI16>:
    bb74:	ca 0c       	mova	r12,	r10	;
    bb76:	c8 0d       	mova	r13,	r8	;

0000bb78 <.Loc.66.1>:
  chDbgCheckClassS();
  chDbgCheck(queue != NULL);
    bb78:	9c 00 00 00 	cmpa	#0,	r12	;
    bb7c:	07 20       	jnz	$+16     	;abs 0xbb8c

0000bb7e <.Loc.66.1>:
    bb7e:	8c 01 48 09 	mova	#67912,	r12	;0x10948

0000bb82 <.LVL35>:
    bb82:	71 0e 00 00 	mova	r14,	0(r1)	;
    bb86:	b0 13 3e 46 	calla	#17982		;0x0463e

0000bb8a <.LVL36>:
    bb8a:	0e 01       	mova	@r1,	r14	;

0000bb8c <.L18>:
  
  return chMBFetchS(&(queue->mbox), (msg_t *)(bufferp), timeout);
    bb8c:	cd 08       	mova	r8,	r13	;
    bb8e:	cc 0a       	mova	r10,	r12	;
    bb90:	ac 00 04 00 	adda	#4,	r12	;
    bb94:	b0 13 4a 4b 	calla	#19274		;0x04b4a

0000bb98 <.LVL37>:
}
    bb98:	a1 00 04 00 	adda	#4,	r1	;
    bb9c:	08 16       	popm.a	#1,	r8	;20-bit words
    bb9e:	0a 16       	popm.a	#1,	r10	;20-bit words
    bba0:	10 01       	reta			;

0000bba2 <elyQueuePend>:
  _disable_interrupts();
    bba2:	32 c2       	dint			
    bba4:	03 43       	nop			

0000bba6 <.Loc.348.2>:
  asm volatile("nop");
    bba6:	03 43       	nop			

0000bba8 <.LBE20>:

msg_t elyQueuePend(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
  msg_t result;
  chSysLock();
  result = elyQueuePendS(queue, bufferp, timeout);
    bba8:	b0 13 6c bb 	calla	#47980		;0x0bb6c

0000bbac <.LBB22>:
  asm volatile("nop");
    bbac:	03 43       	nop			

0000bbae <.Loc.356.2>:
  _enable_interrupts();
    bbae:	03 43       	nop			
    bbb0:	32 d2       	eint			
    bbb2:	03 43       	nop			

0000bbb4 <.LBE22>:
  chSysUnlock();
  return result;
}
    bbb4:	10 01       	reta			;

0000bbb6 <nl_allocator>:

static uint8_t PERSIST packets_received;
static uint16_t PERSIST packets_sent = 1;
static uint8_t PERSIST packets_relayed;

void * nl_allocator(size_t size, unsigned align) {
    bbb6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bbb8 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  /* TODO fix this to use PERSIST when GCC fixes bug #78818 */
  static size_t __attribute__((section(".persistent"))) curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    bbb8:	2e 00 cc cf 	mova	&53196,	r14	;0x0cfcc
    bbbc:	ca 0e       	mova	r14,	r10	;
    bbbe:	ea 0c       	adda	r12,	r10	;
    bbc0:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

0000bbc4 <.LVL1>:
    bbc4:	dc 0a       	cmpa	r10,	r12	;
    bbc6:	07 28       	jnc	$+16     	;abs 0xbbd6

0000bbc8 <.Loc.23.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    bbc8:	cc 0e       	mova	r14,	r12	;
    bbca:	ac 00 ba d2 	adda	#53946,	r12	;0x0d2ba

0000bbce <.LVL2>:
  
  curr_index += size;
    bbce:	60 0a cc cf 	mova	r10,	&53196	; 0x0cfcc

0000bbd2 <.L1>:
  return result;
}
    bbd2:	0a 16       	popm.a	#1,	r10	;20-bit words
    bbd4:	10 01       	reta			;

0000bbd6 <.L3>:
    return NULL;
    bbd6:	4c 43       	clr.b	r12		;
    bbd8:	80 00 d2 bb 	mova	#48082,	r0	;0x0bbd2

0000bbdc <clamp>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    bbdc:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000bbde <.LCFI1>:
    bbde:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    bbe2:	49 4d       	mov.b	r13,	r9	;
    bbe4:	4a 4e       	mov.b	r14,	r10	;

0000bbe6 <.Loc.32.1>:
  if (value < min) {
    bbe6:	4c 99       	cmp.b	r9,	r12	;
    bbe8:	07 2c       	jc	$+16     	;abs 0xbbf8

0000bbea <.LVL5>:
    value = min;
    elyErrorSignal(ErrRegClip);
    bbea:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bbee:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bbf2 <.LVL6>:
    bbf2:	0c 49       	mov	r9,	r12	;

0000bbf4 <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    bbf4:	19 16       	popm.a	#2,	r10	;20-bit words
    bbf6:	10 01       	reta			;

0000bbf8 <.L5>:
  else if (value > max) {
    bbf8:	4a 9c       	cmp.b	r12,	r10	;
    bbfa:	fc 2f       	jc	$-6      	;abs 0xbbf4

0000bbfc <.LVL9>:
    elyErrorSignal(ErrRegClip);
    bbfc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bc00:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bc04 <.LVL10>:
    bc04:	0c 4a       	mov	r10,	r12	;
    bc06:	80 00 f4 bb 	mova	#48116,	r0	;0x0bbf4

0000bc0a <elyNLClampReg>:
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}

uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    bc0a:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000bc0c <.LCFI2>:
    bc0c:	49 4c       	mov.b	r12,	r9	;
    bc0e:	4a 4d       	mov.b	r13,	r10	;

0000bc10 <.Loc.72.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    bc10:	4c 49       	mov.b	r9,	r12	;

0000bc12 <.LVL12>:
    bc12:	7c 50 80 ff 	add.b	#-128,	r12	;#0xff80
    bc16:	7d 40 09 00 	mov.b	#9,	r13	;

0000bc1a <.LVL13>:
    bc1a:	4d 9c       	cmp.b	r12,	r13	;
    bc1c:	04 2c       	jc	$+10     	;abs 0xbc26

0000bc1e <.Loc.72.1>:
    bc1e:	8c 01 c0 09 	mova	#68032,	r12	;0x109c0
    bc22:	b0 13 3e 46 	calla	#17982		;0x0463e

0000bc26 <.L8>:
  switch(addr) {
    bc26:	79 90 83 ff 	cmp.b	#-125,	r9	;#0xff83
    bc2a:	35 24       	jz	$+108    	;abs 0xbc96
    bc2c:	7d 40 83 ff 	mov.b	#-125,	r13	;#0xff83
    bc30:	4d 99       	cmp.b	r9,	r13	;
    bc32:	09 28       	jnc	$+20     	;abs 0xbc46
    bc34:	79 90 80 ff 	cmp.b	#-128,	r9	;#0xff80
    bc38:	20 24       	jz	$+66     	;abs 0xbc7a
    bc3a:	79 90 81 ff 	cmp.b	#-127,	r9	;#0xff81
    bc3e:	26 24       	jz	$+78     	;abs 0xbc8c

0000bc40 <.L9>:
    default:
      /* All other registers have ranges equal to their data type's */
      break;
  }
  return value;
}
    bc40:	4c 4a       	mov.b	r10,	r12	;
    bc42:	19 16       	popm.a	#2,	r10	;20-bit words
    bc44:	10 01       	reta			;

0000bc46 <.L11>:
  switch(addr) {
    bc46:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    bc4a:	29 24       	jz	$+84     	;abs 0xbc9e
    bc4c:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    bc50:	f7 2b       	jnc	$-16     	;abs 0xbc40
    bc52:	79 50 79 00 	add.b	#121,	r9	;#0x0079
    bc56:	5c 43       	mov.b	#1,	r12	;r3 As==01
    bc58:	4c 99       	cmp.b	r9,	r12	;
    bc5a:	f2 2b       	jnc	$-26     	;abs 0xbc40

0000bc5c <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    bc5c:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    bc60:	10 00 
    bc62:	21 24       	jz	$+68     	;abs 0xbca6
    bc64:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    bc68:	1e 24       	jz	$+62     	;abs 0xbca6

0000bc6a <.Loc.45.1>:
    elyErrorSignal(ErrRegClip);
    bc6a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bc6e:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bc72 <.LVL17>:
    return 0x10;
    bc72:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

0000bc76 <.LVL18>:
    bc76:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bc7a <.L12>:
      value = clamp(value, 7, 0xFF);
    bc7a:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    bc7c:	7d 40 07 00 	mov.b	#7,	r13	;

0000bc80 <.L55>:
      value = clamp(value, 0, 0x10);
    bc80:	4c 4a       	mov.b	r10,	r12	;
    bc82:	b0 13 dc bb 	calla	#48092		;0x0bbdc

0000bc86 <.LVL20>:
    bc86:	4a 4c       	mov.b	r12,	r10	;

0000bc88 <.LVL21>:
      break;
    bc88:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bc8c <.L13>:
      value = clamp(value, 0, 0x10);
    bc8c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

0000bc90 <.L56>:
    bc90:	4d 43       	clr.b	r13		;
    bc92:	80 00 80 bc 	mova	#48256,	r0	;0x0bc80

0000bc96 <.L10>:
      value = clamp(value, 0, 0x07);
    bc96:	7e 40 07 00 	mov.b	#7,	r14	;
    bc9a:	80 00 90 bc 	mova	#48272,	r0	;0x0bc90

0000bc9e <.L14>:
      value = clamp(value, 0, 0x3F);
    bc9e:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    bca2:	80 00 90 bc 	mova	#48272,	r0	;0x0bc90

0000bca6 <.L16>:
  if ((value & 0x08) && value != 0x08) {
    bca6:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    bcaa:	09 24       	jz	$+20     	;abs 0xbcbe
    bcac:	3a 92       	cmp	#8,	r10	;r2 As==11
    bcae:	07 24       	jz	$+16     	;abs 0xbcbe

0000bcb0 <.Loc.49.1>:
    elyErrorSignal(ErrRegClip);
    bcb0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bcb4:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bcb8 <.LVL24>:
    return 0x08;
    bcb8:	7a 42       	mov.b	#8,	r10	;r2 As==11

0000bcba <.LVL25>:
    bcba:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bcbe <.L17>:
  if ((value & 0x04) && value != 0x04) {
    bcbe:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    bcc2:	09 24       	jz	$+20     	;abs 0xbcd6
    bcc4:	2a 92       	cmp	#4,	r10	;r2 As==10
    bcc6:	07 24       	jz	$+16     	;abs 0xbcd6

0000bcc8 <.Loc.53.1>:
    elyErrorSignal(ErrRegClip);
    bcc8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bccc:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bcd0 <.LVL27>:
    return 0x04;
    bcd0:	6a 42       	mov.b	#4,	r10	;r2 As==10

0000bcd2 <.LVL28>:
    bcd2:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bcd6 <.L18>:
  if ((value & 0x02) && value != 0x02) {
    bcd6:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    bcda:	09 24       	jz	$+20     	;abs 0xbcee
    bcdc:	2a 93       	cmp	#2,	r10	;r3 As==10
    bcde:	07 24       	jz	$+16     	;abs 0xbcee

0000bce0 <.Loc.57.1>:
    elyErrorSignal(ErrRegClip);
    bce0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bce4:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bce8 <.LVL30>:
    return 0x02;
    bce8:	6a 43       	mov.b	#2,	r10	;r3 As==10

0000bcea <.LVL31>:
    bcea:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bcee <.L19>:
  if ((value & 0x01) && value != 0x01) {
    bcee:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    bcf2:	09 24       	jz	$+20     	;abs 0xbd06
    bcf4:	1a 93       	cmp	#1,	r10	;r3 As==01
    bcf6:	07 24       	jz	$+16     	;abs 0xbd06

0000bcf8 <.Loc.61.1>:
    elyErrorSignal(ErrRegClip);
    bcf8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bcfc:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bd00 <.LVL33>:
    return 0x01;
    bd00:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000bd02 <.LVL34>:
    bd02:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bd06 <.L20>:
  if (value & 0xD0) {
    bd06:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    bd0a:	9a 27       	jz	$-202    	;abs 0xbc40

0000bd0c <.Loc.65.1>:
    elyErrorSignal(ErrRegClip);
    bd0c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    bd10:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000bd14 <.LVL36>:
    return 0x00;
    bd14:	4a 43       	clr.b	r10		;

0000bd16 <.LVL37>:
    bd16:	80 00 40 bc 	mova	#48192,	r0	;0x0bc40

0000bd1a <elyNLGetBuffer>:
  elyNLMaxLen = len;
  main_mpool.object_size = elyNLMaxLen;
}

uint8_t * elyNLGetBuffer() {
  return chPoolAlloc(&main_mpool);
    bd1a:	8c 01 c8 0c 	mova	#68808,	r12	;0x10cc8
    bd1e:	b0 13 5e 4c 	calla	#19550		;0x04c5e

0000bd22 <.LVL45>:
}
    bd22:	10 01       	reta			;

0000bd24 <elyNLFreeBuffer>:

void elyNLFreeBuffer(uint8_t * buffer) {
  chPoolFree(&main_mpool, buffer);
    bd24:	cd 0c       	mova	r12,	r13	;
    bd26:	8c 01 c8 0c 	mova	#68808,	r12	;0x10cc8

0000bd2a <.LVL47>:
    bd2a:	b0 13 9e 4c 	calla	#19614		;0x04c9e

0000bd2e <.LVL48>:
}
    bd2e:	10 01       	reta			;

0000bd30 <elyNLFreeBufferI>:
  return chPoolAllocI(&main_mpool);
}

void elyNLFreeBufferI(uint8_t * buffer) {
  chDbgCheckClassI();
  chPoolFreeI(&main_mpool, buffer);
    bd30:	cd 0c       	mova	r12,	r13	;
    bd32:	8c 01 c8 0c 	mova	#68808,	r12	;0x10cc8

0000bd36 <.LVL51>:
    bd36:	b0 13 72 4c 	calla	#19570		;0x04c72

0000bd3a <.LVL52>:
}
    bd3a:	10 01       	reta			;

0000bd3c <elyNLGetDest>:
   * Else If (TC) UART
   * Else (TM) If (Source == Elysium AND APID != GroundAPID) UART
   * Else RF */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    bd3c:	6d 4c       	mov.b	@r12,	r13	;
    bd3e:	5f 4c 01 00 	mov.b	1(r12),	r15	;

0000bd42 <.LVL54>:
    bd42:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    bd46:	5c 4e 51 00 	mov.b	81(r14),r12	;0x00051

0000bd4a <.LVL55>:
    bd4a:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bd4e:	5e 4e 50 00 	mov.b	80(r14),r14	;0x00050
    bd52:	0c de       	bis	r14,	r12	;

0000bd54 <.LVL56>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (tc) {
    bd54:	40 18 3d b0 	bitx.w	#16,	r13	;0x00010
    bd58:	10 00 
    bd5a:	09 24       	jz	$+20     	;abs 0xbd6e

0000bd5c <.Loc.160.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    bd5c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;

0000bd60 <.LVL57>:
    bd60:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    bd64:	0d df       	bis	r15,	r13	;

0000bd66 <.Loc.166.1>:
    if (apid == elysium_apid)
    bd66:	0d 9c       	cmp	r12,	r13	;
    bd68:	05 24       	jz	$+12     	;abs 0xbd74

0000bd6a <.Loc.169.1>:
      return ELY_DEST_FW;
    else
      return ELY_DEST_UART;
    bd6a:	4c 43       	clr.b	r12		;

0000bd6c <.L67>:
    return ELY_DEST_RF;
  }
  
  chDbgAssert(false, "unreachable code path");
  return 0;
}
    bd6c:	10 01       	reta			;

0000bd6e <.L68>:
    return ELY_DEST_RF;
    bd6e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    bd70:	80 00 6c bd 	mova	#48492,	r0	;0x0bd6c

0000bd74 <.L69>:
      return ELY_DEST_FW;
    bd74:	6c 43       	mov.b	#2,	r12	;r3 As==10
    bd76:	80 00 6c bd 	mova	#48492,	r0	;0x0bd6c

0000bd7a <get_sh_len>:

size_t get_sh_len(void) {
  uint8_t options = bank0p[RegNLOptions];
    bd7a:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    bd7e:	5c 4c 86 00 	mov.b	134(r12),r12	;0x00086

0000bd82 <.Loc.183.1>:
  if (options & 0x02) { /* Timestamp */
    bd82:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    bd86:	04 24       	jz	$+10     	;abs 0xbd90

0000bd88 <.Loc.184.1>:
    if (options & 0x01) { /* P-field */
    bd88:	1c b3       	bit	#1,	r12	;r3 As==01
    bd8a:	05 20       	jnz	$+12     	;abs 0xbd96

0000bd8c <.Loc.190.1>:
      /* 5-byte Secondary Header + 6-byte Primary Header */
      return 5;
    }
    else { /* No P-field */
      /* 4-byte Secondary Header + 6-byte Primary Header */
      return 4;
    bd8c:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000bd8e <.L70>:
    }
  }
  
  return 0;
}
    bd8e:	10 01       	reta			;

0000bd90 <.L72>:
  return 0;
    bd90:	4c 43       	clr.b	r12		;
    bd92:	80 00 8e bd 	mova	#48526,	r0	;0x0bd8e

0000bd96 <.L73>:
      return 5;
    bd96:	7c 40 05 00 	mov.b	#5,	r12	;
    bd9a:	80 00 8e bd 	mova	#48526,	r0	;0x0bd8e

0000bd9e <elyNLSetDest>:

elysium_destinations_t elyNLSetDest(uint8_t * buffer) {
    bd9e:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bda0 <.LCFI7>:
    bda0:	2a 01 40 08 	mova	&67648,	r10	;0x10840

0000bda4 <.Loc.199.1>:
  uint16_t apid;
  if (buffer[0] & 0x08) { /* Secondary Header flag - Timestamp */
    bda4:	40 18 fc b2 	bitx.b	#8,	0(r12)	;r2 As==11
    bda8:	00 00 
    bdaa:	1d 24       	jz	$+60     	;abs 0xbde6

0000bdac <.Loc.200.1>:
    if (bank0p[RegNLOptions] & 0x01) { /* P-field - SH 5 bytes */
    bdac:	40 18 da b3 	bitx.b	#1,	134(r10);r3 As==01, 0x00086
    bdb0:	86 00 
    bdb2:	15 24       	jz	$+44     	;abs 0xbdde

0000bdb4 <.Loc.202.1>:
      /* PH 6 bytes, SH 5 bytes, EH 2 bytes */
      apid = ( ((buffer[13] << 8) & 0x07) | (buffer[14]) );
    bdb4:	5d 4c 0e 00 	mov.b	14(r12),r13	;0x0000e

0000bdb8 <.L77>:
    /* PH 6 bytes, EH 2 bytes */
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
  }
  
  /* Set APID */
  buffer[0] = (apid >> 8);
    bdb8:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

0000bdbc <.Loc.215.1>:
  buffer[1] = (apid & 0xFF);
    bdbc:	cc 4d 01 00 	mov.b	r13,	1(r12)	;

0000bdc0 <.Loc.220.1>:
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (apid == ground_apid) {
    bdc0:	5e 4a 83 00 	mov.b	131(r10),r14	;0x00083
    bdc4:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    bdc8:	5a 4a 82 00 	mov.b	130(r10),r10	;0x00082
    bdcc:	0e da       	bis	r10,	r14	;
    bdce:	0d 9e       	cmp	r14,	r13	;
    bdd0:	0e 24       	jz	$+30     	;abs 0xbdee

0000bdd2 <.Loc.225.1>:
    return ELY_DEST_RF;
  }
  else {
    /* Remember to set it to TC mode */
    buffer[0] |= 0x10;
    bdd2:	fc 40 10 00 	mov.b	#16,	0(r12)	;#0x0010
    bdd6:	00 00 

0000bdd8 <.Loc.226.1>:
    return ELY_DEST_UART;
    bdd8:	4c 43       	clr.b	r12		;

0000bdda <.L78>:
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    bdda:	0a 16       	popm.a	#1,	r10	;20-bit words
    bddc:	10 01       	reta			;

0000bdde <.L76>:
      apid = ( ((buffer[12] << 8) & 0x07) | (buffer[13]) );
    bdde:	5d 4c 0d 00 	mov.b	13(r12),r13	;0x0000d

0000bde2 <.LVL67>:
    bde2:	80 00 b8 bd 	mova	#48568,	r0	;0x0bdb8

0000bde6 <.L75>:
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
    bde6:	5d 4c 09 00 	mov.b	9(r12),	r13	;

0000bdea <.LVL69>:
    bdea:	80 00 b8 bd 	mova	#48568,	r0	;0x0bdb8

0000bdee <.L79>:
    return ELY_DEST_RF;
    bdee:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bdf0 <.LVL71>:
    bdf0:	80 00 da bd 	mova	#48602,	r0	;0x0bdda

0000bdf4 <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    bdf4:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    bdf8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bdfc:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000be00 <.LVL73>:
    be00:	0c dd       	bis	r13,	r12	;
    be02:	3c 50 07 00 	add	#7,	r12	;
    be06:	4c 0e       	rlam.a	#4,	r12	;
    be08:	4c 0d       	rram.a	#4,	r12	;

0000be0a <.Loc.235.1>:
}
    be0a:	10 01       	reta			;

0000be0c <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    be0c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000be0e <.LCFI8>:
  if (buffer[0] & 0xE0) {
    be0e:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    be12:	00 00 
    be14:	07 24       	jz	$+16     	;abs 0xbe24

0000be16 <.Loc.135.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    be16:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000be1a <.L85>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    be1a:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000be1e <.LVL76>:
    return false;
    be1e:	4c 43       	clr.b	r12		;

0000be20 <.L83>:
}
    be20:	0a 16       	popm.a	#1,	r10	;20-bit words
    be22:	10 01       	reta			;

0000be24 <.L82>:
  _disable_interrupts();
    be24:	32 c2       	dint			
    be26:	03 43       	nop			

0000be28 <.Loc.348.2>:
  asm volatile("nop");
    be28:	03 43       	nop			

0000be2a <.LBE15>:
  if ( elyNLGetLength(buffer) > 
    be2a:	b0 13 f4 bd 	calla	#48628		;0x0bdf4

0000be2e <.LVL78>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    be2e:	2a 01 40 08 	mova	&67648,	r10	;0x10840
    be32:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    be36:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    be3a:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    be3e:	0e da       	bis	r10,	r14	;
    be40:	40 18 0e 4e 	movx.w	r14,	r14	;

0000be44 <.Loc.141.1>:
  if ( elyNLGetLength(buffer) > 
    be44:	de 0c       	cmpa	r12,	r14	;
    be46:	08 2c       	jc	$+18     	;abs 0xbe58

0000be48 <.LBB17>:
  asm volatile("nop");
    be48:	03 43       	nop			

0000be4a <.Loc.356.2>:
  _enable_interrupts();
    be4a:	03 43       	nop			
    be4c:	32 d2       	eint			
    be4e:	03 43       	nop			

0000be50 <.LBE17>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    be50:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    be54:	80 00 1a be 	mova	#48666,	r0	;0x0be1a

0000be58 <.L84>:
  asm volatile("nop");
    be58:	03 43       	nop			

0000be5a <.Loc.356.2>:
  _enable_interrupts();
    be5a:	03 43       	nop			
    be5c:	32 d2       	eint			
    be5e:	03 43       	nop			

0000be60 <.LBE19>:
  return true;
    be60:	5c 43       	mov.b	#1,	r12	;r3 As==01
    be62:	80 00 20 be 	mova	#48672,	r0	;0x0be20

0000be66 <elyNLExtract>:

size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - get_sh_len() + 1;
}

uint8_t * elyNLExtract(uint8_t * buffer) {
    be66:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000be68 <.LCFI10>:
    be68:	ca 0c       	mova	r12,	r10	;

0000be6a <.Loc.243.1>:
  /* 6-byte Primary Header */
  return buffer + get_sh_len() + 6;
    be6a:	b0 13 7a bd 	calla	#48506		;0x0bd7a

0000be6e <.LVL83>:
    be6e:	ac 00 06 00 	adda	#6,	r12	;

0000be72 <.Loc.244.1>:
}
    be72:	ec 0a       	adda	r10,	r12	;
    be74:	0a 16       	popm.a	#1,	r10	;20-bit words
    be76:	10 01       	reta			;

0000be78 <elyNLPack>:

uint8_t * elyNLPack(uint8_t * buffer) {
    be78:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000be7a <.LCFI11>:
    be7a:	ca 0c       	mova	r12,	r10	;

0000be7c <.Loc.248.1>:
  /* 6-byte Primary Header */
  uint8_t * result = buffer - get_sh_len() - 6;
    be7c:	b0 13 7a bd 	calla	#48506		;0x0bd7a

0000be80 <.LVL85>:
    be80:	80 1f 7e 40 	movx.a	#-6,	r14	;0xffffa
    be84:	fa ff 
    be86:	fe 0c       	suba	r12,	r14	;
    be88:	ee 0a       	adda	r10,	r14	;

0000be8a <.Loc.249.1>:
  uint16_t length = (buffer[1] + 4 + get_sh_len() - 1);
    be8a:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    be8e:	3d 50 03 00 	add	#3,	r13	;
    be92:	40 18 0c 4c 	movx.w	r12,	r12	;
    be96:	0c 5d       	add	r13,	r12	;

0000be98 <.LVL87>:
  result[4] = (length >> 8);
    be98:	0d 4c       	mov	r12,	r13	;
    be9a:	5d 0f       	rrum	#4,	r13	;
    be9c:	5d 0f       	rrum	#4,	r13	;
    be9e:	ce 4d 04 00 	mov.b	r13,	4(r14)	;

0000bea2 <.Loc.251.1>:
  result[5] = (length & 0xFF);
    bea2:	ce 4c 05 00 	mov.b	r12,	5(r14)	;

0000bea6 <.Loc.253.1>:
  
  result[2] = (packets_sent >> 8) | 0xC0;
    bea6:	c0 18 1c 42 	movx.w	&0x10cd4,r12	;
    beaa:	d4 0c 

0000beac <.LVL88>:
    beac:	0d 4c       	mov	r12,	r13	;
    beae:	5d 0f       	rrum	#4,	r13	;
    beb0:	5d 0f       	rrum	#4,	r13	;
    beb2:	7d d0 c0 ff 	bis.b	#-64,	r13	;#0xffc0
    beb6:	ce 4d 02 00 	mov.b	r13,	2(r14)	;

0000beba <.Loc.254.1>:
  result[3] = (packets_sent & 0xFF);
    beba:	ce 4c 03 00 	mov.b	r12,	3(r14)	;

0000bebe <.Loc.255.1>:
  packets_sent = (packets_sent + 1) & 0x3FFF;
    bebe:	1c 53       	inc	r12		;
    bec0:	3c f0 ff 3f 	and	#16383,	r12	;#0x3fff
    bec4:	41 18 82 4c 	movx.w	r12,	&0x10cd4;
    bec8:	d4 0c 

0000beca <.Loc.258.1>:
  
  /* insert timestamps here too if required */
  uint8_t options = bank0p[RegNLOptions];
    beca:	2c 01 40 08 	mova	&67648,	r12	;0x10840
    bece:	5d 4c 86 00 	mov.b	134(r12),r13	;0x00086

0000bed2 <.LVL89>:
  if (options & 0x02) { /* Timestamp */
    bed2:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    bed6:	19 24       	jz	$+52     	;abs 0xbf0a

0000bed8 <.Loc.260.1>:
    if (options & 0x01) { /* P-field */
    bed8:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    bedc:	19 24       	jz	$+52     	;abs 0xbf10

0000bede <.Loc.261.1>:
      result[6] = SPP_PFIELD;
    bede:	fe 40 2c 00 	mov.b	#44,	6(r14)	;#0x002c
    bee2:	06 00 

0000bee4 <.LBB29>:
  _disable_interrupts();
    bee4:	32 c2       	dint			
    bee6:	03 43       	nop			

0000bee8 <.Loc.348.2>:
  asm volatile("nop");
    bee8:	03 43       	nop			

0000beea <.LBE29>:
      chSysLock();
      result[7] = bank0p[RegMissionTimeMsb];
    beea:	de 4c 76 00 	mov.b	118(r12),7(r14)	;0x00076
    beee:	07 00 

0000bef0 <.Loc.264.1>:
      result[8] = bank0p[RegMissionTimeHmb];
    bef0:	de 4c 75 00 	mov.b	117(r12),8(r14)	;0x00075
    bef4:	08 00 

0000bef6 <.Loc.265.1>:
      result[9] = bank0p[RegMissionTimeLmb];
    bef6:	de 4c 74 00 	mov.b	116(r12),9(r14)	;0x00074
    befa:	09 00 

0000befc <.Loc.266.1>:
      result[10] = bank0p[RegMissionTimeLsb];
    befc:	de 4c 73 00 	mov.b	115(r12),10(r14)	;0x00073, 0x000a
    bf00:	0a 00 

0000bf02 <.L94>:
  asm volatile("nop");
    bf02:	03 43       	nop			

0000bf04 <.Loc.356.2>:
  _enable_interrupts();
    bf04:	03 43       	nop			
    bf06:	32 d2       	eint			
    bf08:	03 43       	nop			

0000bf0a <.L88>:
      chSysUnlock();
    }
  }
  
  return result;
}
    bf0a:	cc 0e       	mova	r14,	r12	;
    bf0c:	0a 16       	popm.a	#1,	r10	;20-bit words
    bf0e:	10 01       	reta			;

0000bf10 <.L90>:
  _disable_interrupts();
    bf10:	32 c2       	dint			
    bf12:	03 43       	nop			

0000bf14 <.Loc.348.2>:
  asm volatile("nop");
    bf14:	03 43       	nop			

0000bf16 <.LBE33>:
      result[6] = bank0p[RegMissionTimeMsb];
    bf16:	de 4c 76 00 	mov.b	118(r12),6(r14)	;0x00076
    bf1a:	06 00 

0000bf1c <.LVL92>:
      result[7] = bank0p[RegMissionTimeHmb];
    bf1c:	de 4c 75 00 	mov.b	117(r12),7(r14)	;0x00075
    bf20:	07 00 

0000bf22 <.Loc.275.1>:
      result[8] = bank0p[RegMissionTimeLmb];
    bf22:	de 4c 74 00 	mov.b	116(r12),8(r14)	;0x00074
    bf26:	08 00 

0000bf28 <.Loc.276.1>:
      result[9] = bank0p[RegMissionTimeLsb];
    bf28:	de 4c 73 00 	mov.b	115(r12),9(r14)	;0x00073
    bf2c:	09 00 
    bf2e:	80 00 02 bf 	mova	#48898,	r0	;0x0bf02

0000bf32 <elyErrorSignal>:
/* Errors */
static uint16_t PERSIST err_log_lvl;
static uint16_t PERSIST err_rpt_lvl;
static uint16_t PERSIST signalled_errors;
static inline eventmask_t mask_from_error(uint8_t error) {
  return (1 << (error & 0x3F));
    bf32:	0d 4c       	mov	r12,	r13	;
    bf34:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bf38:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bf3a <.LVL1>:
    bf3a:	b0 13 ec cb 	calla	#52204		;0x0cbec

0000bf3e <.LBE26>:
}

void elyErrorSignal(uint8_t error) {
  signalled_errors |= mask_from_error(error);
    bf3e:	40 18 82 dc 	bisx.w	r12,	&0xff2ca;
    bf42:	ca f2 

0000bf44 <.Loc.40.1>:
}
    bf44:	10 01       	reta			;

0000bf46 <elyErrorSetLogLvlS>:

void elyErrorSetLogLvlS(uint8_t lvl) {
  err_log_lvl = lvl;
}
    bf46:	10 01       	reta			;

0000bf48 <elyErrorSetRptLvlS>:

void elyErrorSetRptLvlS(uint8_t lvl) {
  err_rpt_lvl = lvl;
}
    bf48:	10 01       	reta			;

0000bf4a <elyEventSignal>:
eventmask_t PERSIST logged_events;
eventmask_t PERSIST reported_events;
static eventmask_t PERSIST signalled_events;
size_t PERSIST event_resets = 0;
static inline eventmask_t mask_from_event(uint8_t event) {
  return (1 << (event & 0x3F));
    bf4a:	0d 4c       	mov	r12,	r13	;
    bf4c:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bf50:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bf52 <.LVL6>:
    bf52:	b0 13 ec cb 	calla	#52204		;0x0cbec
    bf56:	0e 4c       	mov	r12,	r14	;
    bf58:	0f 4c       	mov	r12,	r15	;
    bf5a:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000bf5e <.LBE28>:
}

void elyEventSignal(uint8_t event) {
  signalled_events |= mask_from_event(event);
    bf5e:	40 18 82 dc 	bisx.w	r12,	&0xff2c6;
    bf62:	c6 f2 
    bf64:	40 18 82 df 	bisx.w	r15,	&0xff2c8;
    bf68:	c8 f2 

0000bf6a <.Loc.61.1>:
}
    bf6a:	10 01       	reta			;

0000bf6c <elyEventSubscribe>:
  return (1 << (event & 0x3F));
    bf6c:	0d 4c       	mov	r12,	r13	;

0000bf6e <.LVL9>:
    bf6e:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bf72:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bf74 <.LVL10>:
    bf74:	b0 13 ec cb 	calla	#52204		;0x0cbec
    bf78:	0e 4c       	mov	r12,	r14	;
    bf7a:	0f 4c       	mov	r12,	r15	;
    bf7c:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000bf80 <.LBE30>:

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(addr);
  reported_events |= mask_from_event(event);
    bf80:	41 18 82 dc 	bisx.w	r12,	&0x11c06;
    bf84:	06 1c 
    bf86:	41 18 82 df 	bisx.w	r15,	&0x11c08;
    bf8a:	08 1c 

0000bf8c <.Loc.66.1>:
}
    bf8c:	10 01       	reta			;

0000bf8e <elyEventUnsubscribe>:
  return (1 << (event & 0x3F));
    bf8e:	0d 4c       	mov	r12,	r13	;
    bf90:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bf94:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bf96 <.LVL13>:
    bf96:	b0 13 ec cb 	calla	#52204		;0x0cbec
    bf9a:	0e 4c       	mov	r12,	r14	;
    bf9c:	0f 4c       	mov	r12,	r15	;
    bf9e:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000bfa2 <.LBE32>:

void elyEventUnsubscribe(uint8_t event) {
  reported_events &= ~mask_from_event(event);
    bfa2:	41 18 82 cc 	bicx.w	r12,	&0x11c06;
    bfa6:	06 1c 
    bfa8:	41 18 82 cf 	bicx.w	r15,	&0x11c08;
    bfac:	08 1c 

0000bfae <.Loc.70.1>:
}
    bfae:	10 01       	reta			;

0000bfb0 <elyEventLog>:
  return (1 << (event & 0x3F));
    bfb0:	0d 4c       	mov	r12,	r13	;
    bfb2:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bfb6:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bfb8 <.LVL16>:
    bfb8:	b0 13 ec cb 	calla	#52204		;0x0cbec
    bfbc:	0e 4c       	mov	r12,	r14	;
    bfbe:	0f 4c       	mov	r12,	r15	;
    bfc0:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000bfc4 <.LBE34>:

void elyEventLog(uint8_t event) {
  logged_events |= mask_from_event(event);
    bfc4:	41 18 82 dc 	bisx.w	r12,	&0x11c0a;
    bfc8:	0a 1c 
    bfca:	41 18 82 df 	bisx.w	r15,	&0x11c0c;
    bfce:	0c 1c 

0000bfd0 <.Loc.74.1>:
}
    bfd0:	10 01       	reta			;

0000bfd2 <elyEventUnlog>:
  return (1 << (event & 0x3F));
    bfd2:	0d 4c       	mov	r12,	r13	;
    bfd4:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    bfd8:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bfda <.LVL19>:
    bfda:	b0 13 ec cb 	calla	#52204		;0x0cbec
    bfde:	0e 4c       	mov	r12,	r14	;
    bfe0:	0f 4c       	mov	r12,	r15	;
    bfe2:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000bfe6 <.LBE36>:

void elyEventUnlog(uint8_t event) {
  logged_events &= ~mask_from_event(event);
    bfe6:	41 18 82 cc 	bicx.w	r12,	&0x11c0a;
    bfea:	0a 1c 
    bfec:	41 18 82 cf 	bicx.w	r15,	&0x11c0c;
    bff0:	0c 1c 

0000bff2 <.Loc.78.1>:
}
    bff2:	10 01       	reta			;

0000bff4 <elyEventReset>:

void elyEventReset() {
  logged_events = 0;
    bff4:	41 18 82 43 	movx.w	#0,	&0x11c0a;r3 As==00
    bff8:	0a 1c 
    bffa:	41 18 82 43 	movx.w	#0,	&0x11c0c;r3 As==00
    bffe:	0c 1c 

0000c000 <.Loc.82.1>:
  signalled_events = 0;
    c000:	40 18 82 43 	movx.w	#0,	&0xff2c6;r3 As==00
    c004:	c6 f2 
    c006:	40 18 82 43 	movx.w	#0,	&0xff2c8;r3 As==00
    c00a:	c8 f2 

0000c00c <.Loc.83.1>:
  reported_events = 0;
    c00c:	41 18 82 43 	movx.w	#0,	&0x11c06;r3 As==00
    c010:	06 1c 
    c012:	41 18 82 43 	movx.w	#0,	&0x11c08;r3 As==00
    c016:	08 1c 

0000c018 <.Loc.84.1>:
  event_resets++;
    c018:	01 18 d2 53 	incx.a	&0x11c02		;
    c01c:	02 1c 

0000c01e <.Loc.85.1>:
}
    c01e:	10 01       	reta			;

0000c020 <elyChanSubscribe>:
static size_t PERSIST chan_resets = 0;
static inline eventmask_t mask_from_chan(uint8_t chan) {
  return (1UL << (chan & 0x3F));
}

void elyChanSubscribe(uint8_t * buffer, uint8_t length, uint32_t interval) {
    c020:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c022 <.LCFI0>:
    c022:	47 4d       	mov.b	r13,	r7	;

0000c024 <.LVL22>:
    c024:	40 18 19 42 	movx.w	&0x0f2c2,r9	;
    c028:	c2 f2 
    c02a:	40 18 1a 42 	movx.w	&0x0f2c4,r10	;
    c02e:	c4 f2 
    c030:	c6 0c       	mova	r12,	r6	;

0000c032 <.LBB38>:
  (void)(interval);
  for (int i = 0; i < length; i++) {
    c032:	4c 43       	clr.b	r12		;

0000c034 <.LVL23>:
    c034:	08 4c       	mov	r12,	r8	;
    c036:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c038 <.L12>:
    c038:	08 97       	cmp	r7,	r8	;
    c03a:	0a 38       	jl	$+22     	;abs 0xc050
    c03c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c03e:	06 24       	jz	$+14     	;abs 0xc04c
    c040:	40 18 82 49 	movx.w	r9,	&0xff2c2;
    c044:	c2 f2 
    c046:	40 18 82 4a 	movx.w	r10,	&0xff2c4;
    c04a:	c4 f2 

0000c04c <.L11>:
    subscribed_channels |= mask_from_chan(buffer[i]);
  }
}
    c04c:	55 16       	popm.a	#6,	r10	;20-bit words
    c04e:	10 01       	reta			;

0000c050 <.L13>:
  return (1UL << (chan & 0x3F));
    c050:	6e 46       	mov.b	@r6,	r14	;
    c052:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c056:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c058:	4d 43       	clr.b	r13		;
    c05a:	0f 43       	clr	r15		;
    c05c:	b0 13 36 cc 	calla	#52278		;0x0cc36

0000c060 <.LBE39>:
    subscribed_channels |= mask_from_chan(buffer[i]);
    c060:	09 dc       	bis	r12,	r9	;
    c062:	0a dd       	bis	r13,	r10	;

0000c064 <.Loc.97.1>:
  for (int i = 0; i < length; i++) {
    c064:	18 53       	inc	r8		;
    c066:	a6 00 01 00 	adda	#1,	r6	;
    c06a:	0c 45       	mov	r5,	r12	;
    c06c:	80 00 38 c0 	mova	#49208,	r0	;0x0c038

0000c070 <elyChanUnsubscribe>:

void elyChanUnsubscribe(uint8_t * buffer, uint8_t length) {
    c070:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c072 <.LCFI1>:
    c072:	47 4d       	mov.b	r13,	r7	;

0000c074 <.LVL28>:
    c074:	40 18 19 42 	movx.w	&0x0f2c2,r9	;
    c078:	c2 f2 
    c07a:	40 18 1a 42 	movx.w	&0x0f2c4,r10	;
    c07e:	c4 f2 
    c080:	c6 0c       	mova	r12,	r6	;

0000c082 <.LBB42>:
  for (int i = 0; i < length; i++) {
    c082:	4c 43       	clr.b	r12		;

0000c084 <.LVL29>:
    c084:	08 4c       	mov	r12,	r8	;
    c086:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c088 <.L19>:
    c088:	08 97       	cmp	r7,	r8	;
    c08a:	0a 38       	jl	$+22     	;abs 0xc0a0
    c08c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c08e:	06 24       	jz	$+14     	;abs 0xc09c
    c090:	40 18 82 49 	movx.w	r9,	&0xff2c2;
    c094:	c2 f2 
    c096:	40 18 82 4a 	movx.w	r10,	&0xff2c4;
    c09a:	c4 f2 

0000c09c <.L18>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
  }
}
    c09c:	55 16       	popm.a	#6,	r10	;20-bit words
    c09e:	10 01       	reta			;

0000c0a0 <.L20>:
  return (1UL << (chan & 0x3F));
    c0a0:	6e 46       	mov.b	@r6,	r14	;
    c0a2:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c0a6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c0a8:	4d 43       	clr.b	r13		;
    c0aa:	0f 43       	clr	r15		;
    c0ac:	b0 13 36 cc 	calla	#52278		;0x0cc36

0000c0b0 <.LBE43>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
    c0b0:	09 cc       	bic	r12,	r9	;
    c0b2:	0a cd       	bic	r13,	r10	;

0000c0b4 <.Loc.103.1>:
  for (int i = 0; i < length; i++) {
    c0b4:	18 53       	inc	r8		;
    c0b6:	a6 00 01 00 	adda	#1,	r6	;
    c0ba:	0c 45       	mov	r5,	r12	;
    c0bc:	80 00 88 c0 	mova	#49288,	r0	;0x0c088

0000c0c0 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
    c0c0:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c0c2 <.LCFI2>:
    c0c2:	47 4d       	mov.b	r13,	r7	;

0000c0c4 <.LVL34>:
    c0c4:	40 18 19 42 	movx.w	&0x0f2be,r9	;
    c0c8:	be f2 
    c0ca:	40 18 1a 42 	movx.w	&0x0f2c0,r10	;
    c0ce:	c0 f2 
    c0d0:	c6 0c       	mova	r12,	r6	;

0000c0d2 <.LBB46>:
  (void)(interval);
  for (int i = 0; i < length; i++) {
    c0d2:	4c 43       	clr.b	r12		;

0000c0d4 <.LVL35>:
    c0d4:	08 4c       	mov	r12,	r8	;
    c0d6:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c0d8 <.L26>:
    c0d8:	08 97       	cmp	r7,	r8	;
    c0da:	0a 38       	jl	$+22     	;abs 0xc0f0
    c0dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    c0de:	06 24       	jz	$+14     	;abs 0xc0ec
    c0e0:	40 18 82 49 	movx.w	r9,	&0xff2be;
    c0e4:	be f2 
    c0e6:	40 18 82 4a 	movx.w	r10,	&0xff2c0;
    c0ea:	c0 f2 

0000c0ec <.L25>:
    logged_channels |= mask_from_chan(buffer[i]);
  }
}
    c0ec:	55 16       	popm.a	#6,	r10	;20-bit words
    c0ee:	10 01       	reta			;

0000c0f0 <.L27>:
  return (1UL << (chan & 0x3F));
    c0f0:	6e 46       	mov.b	@r6,	r14	;
    c0f2:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c0f6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c0f8:	4d 43       	clr.b	r13		;
    c0fa:	0f 43       	clr	r15		;
    c0fc:	b0 13 36 cc 	calla	#52278		;0x0cc36

0000c100 <.LBE47>:
    logged_channels |= mask_from_chan(buffer[i]);
    c100:	09 dc       	bis	r12,	r9	;
    c102:	0a dd       	bis	r13,	r10	;

0000c104 <.Loc.110.1>:
  for (int i = 0; i < length; i++) {
    c104:	18 53       	inc	r8		;
    c106:	a6 00 01 00 	adda	#1,	r6	;
    c10a:	0c 45       	mov	r5,	r12	;
    c10c:	80 00 d8 c0 	mova	#49368,	r0	;0x0c0d8

0000c110 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
    c110:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c112 <.LCFI3>:
    c112:	47 4d       	mov.b	r13,	r7	;

0000c114 <.LVL40>:
    c114:	40 18 19 42 	movx.w	&0x0f2be,r9	;
    c118:	be f2 
    c11a:	40 18 1a 42 	movx.w	&0x0f2c0,r10	;
    c11e:	c0 f2 
    c120:	c6 0c       	mova	r12,	r6	;

0000c122 <.LBB50>:
  for (int i = 0; i < length; i++) {
    c122:	4c 43       	clr.b	r12		;

0000c124 <.LVL41>:
    c124:	08 4c       	mov	r12,	r8	;
    c126:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c128 <.L33>:
    c128:	08 97       	cmp	r7,	r8	;
    c12a:	0a 38       	jl	$+22     	;abs 0xc140
    c12c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c12e:	06 24       	jz	$+14     	;abs 0xc13c
    c130:	40 18 82 49 	movx.w	r9,	&0xff2be;
    c134:	be f2 
    c136:	40 18 82 4a 	movx.w	r10,	&0xff2c0;
    c13a:	c0 f2 

0000c13c <.L32>:
    logged_channels &= ~mask_from_chan(buffer[i]);
  }
}
    c13c:	55 16       	popm.a	#6,	r10	;20-bit words
    c13e:	10 01       	reta			;

0000c140 <.L34>:
  return (1UL << (chan & 0x3F));
    c140:	6e 46       	mov.b	@r6,	r14	;
    c142:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c146:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c148:	4d 43       	clr.b	r13		;
    c14a:	0f 43       	clr	r15		;
    c14c:	b0 13 36 cc 	calla	#52278		;0x0cc36

0000c150 <.LBE51>:
    logged_channels &= ~mask_from_chan(buffer[i]);
    c150:	09 cc       	bic	r12,	r9	;
    c152:	0a cd       	bic	r13,	r10	;

0000c154 <.Loc.116.1>:
  for (int i = 0; i < length; i++) {
    c154:	18 53       	inc	r8		;
    c156:	a6 00 01 00 	adda	#1,	r6	;
    c15a:	0c 45       	mov	r5,	r12	;
    c15c:	80 00 28 c1 	mova	#49448,	r0	;0x0c128

0000c160 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer) {
  buffer[1] = 0;
    c160:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

0000c164 <.Loc.124.1>:
  return 1;
}
    c164:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c166 <.LVL46>:
    c166:	10 01       	reta			;

0000c168 <elyChanReset>:

void elyChanReset() {
  logged_channels = 0;
    c168:	40 18 82 43 	movx.w	#0,	&0xff2be;r3 As==00
    c16c:	be f2 
    c16e:	40 18 82 43 	movx.w	#0,	&0xff2c0;r3 As==00
    c172:	c0 f2 

0000c174 <.Loc.128.1>:
  subscribed_channels = 0;
    c174:	40 18 82 43 	movx.w	#0,	&0xff2c2;r3 As==00
    c178:	c2 f2 
    c17a:	40 18 82 43 	movx.w	#0,	&0xff2c4;r3 As==00
    c17e:	c4 f2 

0000c180 <.Loc.129.1>:
  chan_resets++;
    c180:	00 18 d2 53 	incx.a	&0xf2ba		;
    c184:	ba f2 

0000c186 <.Loc.130.1>:
}
    c186:	10 01       	reta			;

0000c188 <elyTelemPostBufferS>:
static PERSIST size_t last_n; 
static PERSIST telem_cfg_t telem_cfg;
void elyTelemPostBufferS(uint8_t * buffer, size_t n, telemcallback_t cb) {
  last_buffer = buffer;
  last_n = n;
  cb(buffer);
    c188:	4e 13       	calla	r14		;

0000c18a <.LVL48>:
}
    c18a:	10 01       	reta			;

0000c18c <elyTelemUpdateConfigS>:

void elyTelemUpdateConfigS(telem_cfg_t config) {
  chDbgCheckClassS();
  telem_cfg = config;
}
    c18c:	10 01       	reta			;

0000c18e <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    c18e:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    c192:	80 5a 5c 01 

0000c196 <.Loc.172.1>:

  halInit();
    c196:	b0 13 dc 4d 	calla	#19932		;0x04ddc

0000c19a <.LVL49>:
  chSysInit();
    c19a:	b0 13 32 45 	calla	#17714		;0x04532

0000c19e <.L44>:
    c19e:	80 00 9e c1 	mova	#49566,	r0	;0x0c19e

0000c1a2 <port_lock>:
  _disable_interrupts();
    c1a2:	32 c2       	dint			
    c1a4:	03 43       	nop			

0000c1a6 <.Loc.348.1>:
  asm volatile("nop");
    c1a6:	03 43       	nop			

0000c1a8 <.Loc.349.1>:
}
    c1a8:	10 01       	reta			;

0000c1aa <port_unlock>:
  asm volatile("nop");
    c1aa:	03 43       	nop			

0000c1ac <.Loc.356.1>:
  _enable_interrupts();
    c1ac:	03 43       	nop			
    c1ae:	32 d2       	eint			
    c1b0:	03 43       	nop			

0000c1b2 <.Loc.357.1>:
}
    c1b2:	10 01       	reta			;

0000c1b4 <rxfifothresh_callback>:
  chEvtSignal(rf_thd, RFTxFrameReady);
}

void rxfifothresh_callback(void) {
  chSysLockFromISR();
  chEvtSignalI(rf_thd, RFRxFifoThresh);
    c1b4:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    c1b8:	4e 43       	clr.b	r14		;
    c1ba:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c1be:	b0 13 c6 49 	calla	#18886		;0x049c6

0000c1c2 <.LVL0>:
  chSysUnlockFromISR();
}
    c1c2:	10 01       	reta			;

0000c1c4 <txlvl_callback>:
  
}

void txlvl_callback(void) {
  chSysLockFromISR();
  chEvtSignalI(rf_thd, RFTxFifoLevel);
    c1c4:	3d 40 00 80 	mov	#-32768,r13	;#0x8000
    c1c8:	4e 43       	clr.b	r14		;
    c1ca:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c1ce:	b0 13 c6 49 	calla	#18886		;0x049c6

0000c1d2 <.LVL1>:
  chSysUnlockFromISR();
}
    c1d2:	10 01       	reta			;

0000c1d4 <write_cb>:

void write_cb(SPIDriver * spip) {
    c1d4:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c1d6 <.LCFI0>:
  (void)(spip);
  chSysLockFromISR();
  palSetLine(SX1278D1.config->ss_line);
    c1d6:	2c 01 d0 16 	mova	&71376,	r12	;0x116d0

0000c1da <.LVL3>:
    c1da:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    c1de:	ca 0c       	mova	r12,	r10	;
    c1e0:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    c1e4:	ff 0f 
    c1e6:	19 4a 02 00 	mov	2(r10),	r9	;
    c1ea:	0c 14       	pushm.a	#1,	r12	;20-bit words
    c1ec:	40 18 3c 41 	popx.w	r12		;
    c1f0:	40 18 3d 41 	popx.w	r13		;
    c1f4:	b0 13 0c cd 	calla	#52492		;0x0cd0c
    c1f8:	0d 12       	push	r13		;
    c1fa:	0c 12       	push	r12		;
    c1fc:	0c 16       	popm.a	#1,	r12	;20-bit words
    c1fe:	40 18 0d 4c 	movx.w	r12,	r13	;
    c202:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c204:	b0 13 ec cb 	calla	#52204		;0x0cbec
    c208:	0c d9       	bis	r9,	r12	;
    c20a:	8a 4c 02 00 	mov	r12,	2(r10)	;
    c20e:	8a 00 c6 49 	mova	#18886,	r10	;0x049c6

0000c212 <.Loc.567.2>:
  if (tf_idx == tf_len) {
    c212:	c0 18 92 92 	cmpx.w	&0x10ce8,&0xff2fa;
    c216:	e8 0c fa f2 
    c21a:	14 20       	jnz	$+42     	;abs 0xc244

0000c21c <.LBB16>:
    /* TODO in this function, check for another available packet or frame and
     * if none exists, go to sleep mode */
    /* Done transmitting. Do the stuff */
#if ELY_DISCRETE_PA_CTL
    palClearLine(LINE_PA_PC_EN);
    c21c:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    c220:	ff ef 22 02 

0000c224 <.Loc.574.2>:
#endif
    palLineDisableEventI(LINE_SX1278_DIO1);
    c224:	6d 43       	mov.b	#2,	r13	;r3 As==10
    c226:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    c22a:	b0 13 5e 54 	calla	#21598		;0x0545e

0000c22e <.LVL7>:
    
    chEvtSignalI(rf_thd, RFSpiAvailable | RFTxIdle);
    c22e:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c232:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c234:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c238:	4a 13       	calla	r10		;

0000c23a <.LVL8>:
    tf_idx = 0;
    c23a:	40 18 82 43 	movx.w	#0,	&0xff2fa;r3 As==00
    c23e:	fa f2 

0000c240 <.L5>:
  }
  else {
    chEvtSignalI(rf_thd, RFSpiAvailable);
  }
  chSysUnlockFromISR();
}
    c240:	19 16       	popm.a	#2,	r10	;20-bit words
    c242:	10 01       	reta			;

0000c244 <.L6>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    c244:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c248:	4e 43       	clr.b	r14		;
    c24a:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c24e:	4a 13       	calla	r10		;

0000c250 <.LVL10>:
}
    c250:	80 00 40 c2 	mova	#49728,	r0	;0x0c240

0000c254 <elyRFChangeTxSyncS>:
void elyRFChangeTxSyncS(SX1278Config * cfg) {
    c254:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c256 <.LCFI1>:
  if (!(bank0p[RegDLLOptions] & BIT2)) { /* Compliant ASM */
    c256:	2a 01 40 08 	mova	&67648,	r10	;0x10840
    c25a:	ea b2 c4 00 	bit.b	#4,	196(r10);r2 As==10, 0x00c4
    c25e:	16 20       	jnz	$+46     	;abs 0xc28c

0000c260 <.Loc.82.2>:
                  ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    c260:	5d 4a 11 00 	mov.b	17(r10),r13	;0x00011
    c264:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c268:	5e 4a 10 00 	mov.b	16(r10),r14	;0x00010
    c26c:	0d de       	bis	r14,	r13	;
    c26e:	5e 4a 13 00 	mov.b	19(r10),r14	;0x00013
    c272:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c276:	5a 4a 12 00 	mov.b	18(r10),r10	;0x00012
    c27a:	0e da       	bis	r10,	r14	;

0000c27c <.Loc.80.2>:
    cfg->sync_word = ( (bank0p[RegTXSyncLsb]) |
    c27c:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018
    c280:	8c 4e 1a 00 	mov	r14,	26(r12)	; 0x001a

0000c284 <.Loc.85.2>:
    sx1278SetSync(&SX1278D1, cfg->sync_word);
    c284:	8c 01 d0 16 	mova	#71376,	r12	;0x116d0

0000c288 <.LVL12>:
    c288:	b0 13 34 68 	calla	#26676		;0x06834

0000c28c <.L8>:
}
    c28c:	0a 16       	popm.a	#1,	r10	;20-bit words
    c28e:	10 01       	reta			;

0000c290 <elyDLLClampReg>:
uint8_t elyDLLClampReg(uint8_t addr, uint8_t value) {
    c290:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c292 <.LCFI2>:
    c292:	49 4c       	mov.b	r12,	r9	;
    c294:	4a 4d       	mov.b	r13,	r10	;

0000c296 <.Loc.121.2>:
  chDbgAssert(addr >= 0xC0 && addr < RegDLLMAX, "invalid address");
    c296:	4c 49       	mov.b	r9,	r12	;

0000c298 <.LVL15>:
    c298:	7c 50 40 00 	add.b	#64,	r12	;#0x0040
    c29c:	7d 40 14 00 	mov.b	#20,	r13	;#0x0014

0000c2a0 <.LVL16>:
    c2a0:	4d 9c       	cmp.b	r12,	r13	;
    c2a2:	04 2c       	jc	$+10     	;abs 0xc2ac

0000c2a4 <.Loc.121.2>:
    c2a4:	8c 01 5a 0a 	mova	#68186,	r12	;0x10a5a
    c2a8:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c2ac <.L11>:
  switch (addr) {
    c2ac:	79 90 c3 ff 	cmp.b	#-61,	r9	;#0xffc3
    c2b0:	57 24       	jz	$+176    	;abs 0xc360
    c2b2:	7d 40 c3 ff 	mov.b	#-61,	r13	;#0xffc3
    c2b6:	4d 99       	cmp.b	r9,	r13	;
    c2b8:	0d 28       	jnc	$+28     	;abs 0xc2d4
    c2ba:	79 90 c1 ff 	cmp.b	#-63,	r9	;#0xffc1
    c2be:	30 24       	jz	$+98     	;abs 0xc320
    c2c0:	7d 40 c1 ff 	mov.b	#-63,	r13	;#0xffc1
    c2c4:	4d 99       	cmp.b	r9,	r13	;
    c2c6:	38 28       	jnc	$+114    	;abs 0xc338
    c2c8:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    c2cc:	1d 24       	jz	$+60     	;abs 0xc308

0000c2ce <.L12>:
}
    c2ce:	4c 4a       	mov.b	r10,	r12	;
    c2d0:	19 16       	popm.a	#2,	r10	;20-bit words
    c2d2:	10 01       	reta			;

0000c2d4 <.L14>:
  switch (addr) {
    c2d4:	79 90 c7 ff 	cmp.b	#-57,	r9	;#0xffc7
    c2d8:	49 24       	jz	$+148    	;abs 0xc36c
    c2da:	79 90 c7 ff 	cmp.b	#-57,	r9	;#0xffc7
    c2de:	f7 2b       	jnc	$-16     	;abs 0xc2ce
    c2e0:	79 50 35 00 	add.b	#53,	r9	;#0x0035
    c2e4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    c2e6:	4c 99       	cmp.b	r9,	r12	;
    c2e8:	f2 2b       	jnc	$-26     	;abs 0xc2ce

0000c2ea <.LBB24>:
  if ((value & 0x10) && value != 0x10) {
    c2ea:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    c2ee:	10 00 
    c2f0:	41 24       	jz	$+132    	;abs 0xc374
    c2f2:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    c2f6:	3e 24       	jz	$+126    	;abs 0xc374

0000c2f8 <.Loc.94.2>:
    elyErrorSignal(ErrRegClip);
    c2f8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c2fc:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c300 <.LVL21>:
    return 0x10;
    c300:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

0000c304 <.LVL22>:
    c304:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c308 <.L17>:
  if (value < min) {
    c308:	7d 40 06 00 	mov.b	#6,	r13	;
    c30c:	4d 9a       	cmp.b	r10,	r13	;
    c30e:	df 2b       	jnc	$-64     	;abs 0xc2ce

0000c310 <.LVL24>:
    elyErrorSignal(ErrRegClip);
    c310:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c314:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c318 <.LVL25>:
    value = min;
    c318:	7a 40 07 00 	mov.b	#7,	r10	;
    c31c:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c320 <.L15>:
  else if (value > max) {
    c320:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    c324:	4c 9a       	cmp.b	r10,	r12	;
    c326:	d3 2f       	jc	$-88     	;abs 0xc2ce

0000c328 <.LVL27>:
    elyErrorSignal(ErrRegClip);
    c328:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c32c:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c330 <.LVL28>:
    value = max;
    c330:	7a 40 40 00 	mov.b	#64,	r10	;#0x0040
    c334:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c338 <.L16>:
      if ((value & 0x38) == 0x38) {
    c338:	4c 4a       	mov.b	r10,	r12	;
    c33a:	7c f0 38 00 	and.b	#56,	r12	;#0x0038
    c33e:	7c 90 38 00 	cmp.b	#56,	r12	;#0x0038
    c342:	02 20       	jnz	$+6      	;abs 0xc348

0000c344 <.Loc.131.2>:
        value &= ~BIT3;
    c344:	7a f0 f7 00 	and.b	#247,	r10	;#0x00f7

0000c348 <.L20>:
      if ((value & 0x07) > 5) {
    c348:	4c 4a       	mov.b	r10,	r12	;
    c34a:	7c f0 07 00 	and.b	#7,	r12	;
    c34e:	7d 40 05 00 	mov.b	#5,	r13	;
    c352:	4d 9c       	cmp.b	r12,	r13	;
    c354:	bc 2f       	jc	$-134    	;abs 0xc2ce

0000c356 <.LVL31>:
        value |= BIT0;
    c356:	7a f0 fc 00 	and.b	#252,	r10	;#0x00fc

0000c35a <.LVL32>:
    c35a:	1a d3       	bis	#1,	r10	;r3 As==01

0000c35c <.LVL33>:
    c35c:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c360 <.L13>:
      if ((value & 0x03) == 0x03) {
    c360:	4c 4a       	mov.b	r10,	r12	;
    c362:	7c f0 03 00 	and.b	#3,	r12	;
    c366:	7c 90 03 00 	cmp.b	#3,	r12	;
    c36a:	b1 23       	jnz	$-156    	;abs 0xc2ce

0000c36c <.L18>:
      value &= ~BIT0;
    c36c:	7a f0 fe 00 	and.b	#254,	r10	;#0x00fe

0000c370 <.LVL35>:
      break;
    c370:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c374 <.L21>:
  if ((value & 0x08) && value != 0x08) {
    c374:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    c378:	09 24       	jz	$+20     	;abs 0xc38c
    c37a:	3a 92       	cmp	#8,	r10	;r2 As==11
    c37c:	07 24       	jz	$+16     	;abs 0xc38c

0000c37e <.Loc.98.2>:
    elyErrorSignal(ErrRegClip);
    c37e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c382:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c386 <.LVL37>:
    return 0x08;
    c386:	7a 42       	mov.b	#8,	r10	;r2 As==11
    c388:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c38c <.L22>:
  if ((value & 0x04) && value != 0x04) {
    c38c:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    c390:	09 24       	jz	$+20     	;abs 0xc3a4
    c392:	2a 92       	cmp	#4,	r10	;r2 As==10
    c394:	07 24       	jz	$+16     	;abs 0xc3a4

0000c396 <.Loc.102.2>:
    elyErrorSignal(ErrRegClip);
    c396:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c39a:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c39e <.LVL39>:
    return 0x04;
    c39e:	6a 42       	mov.b	#4,	r10	;r2 As==10
    c3a0:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c3a4 <.L23>:
  if ((value & 0x02) && value != 0x02) {
    c3a4:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    c3a8:	09 24       	jz	$+20     	;abs 0xc3bc
    c3aa:	2a 93       	cmp	#2,	r10	;r3 As==10
    c3ac:	07 24       	jz	$+16     	;abs 0xc3bc

0000c3ae <.Loc.106.2>:
    elyErrorSignal(ErrRegClip);
    c3ae:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c3b2:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c3b6 <.LVL41>:
    return 0x02;
    c3b6:	6a 43       	mov.b	#2,	r10	;r3 As==10
    c3b8:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c3bc <.L24>:
  if ((value & 0x01) && value != 0x01) {
    c3bc:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    c3c0:	09 24       	jz	$+20     	;abs 0xc3d4
    c3c2:	1a 93       	cmp	#1,	r10	;r3 As==01
    c3c4:	07 24       	jz	$+16     	;abs 0xc3d4

0000c3c6 <.Loc.110.2>:
    elyErrorSignal(ErrRegClip);
    c3c6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c3ca:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c3ce <.LVL43>:
    return 0x01;
    c3ce:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c3d0:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c3d4 <.L25>:
  if (value & 0xD0) {
    c3d4:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    c3d8:	7a 27       	jz	$-266    	;abs 0xc2ce

0000c3da <.Loc.114.2>:
    elyErrorSignal(ErrRegClip);
    c3da:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c3de:	b0 13 32 bf 	calla	#48946		;0x0bf32

0000c3e2 <.LVL45>:
    return 0x00;
    c3e2:	4a 43       	clr.b	r10		;
    c3e4:	80 00 ce c2 	mova	#49870,	r0	;0x0c2ce

0000c3e8 <elyRFDLLBuildFrame>:
void elyRFDLLBuildFrame(void) {
    c3e8:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000c3ea <.LCFI3>:
  chEvtSignal(rf_thd, RFPktAvailable);
    c3ea:	8a 00 9a 49 	mova	#18842,	r10	;0x0499a
    c3ee:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    c3f2:	4e 43       	clr.b	r14		;
    c3f4:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c3f8:	4a 13       	calla	r10		;

0000c3fa <.LVL47>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    c3fa:	24 01 40 08 	mova	&67648,	r4	;0x10840
    c3fe:	5c 44 ca 00 	mov.b	202(r4),r12	;0x000ca

0000c402 <.Loc.183.2>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    c402:	5d 44 c9 00 	mov.b	201(r4),r13	;0x000c9

0000c406 <.Loc.182.2>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    c406:	86 01 ea 0c 	mova	#68842,	r6	;0x10cea

0000c40a <.Loc.183.2>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    c40a:	0f 4d       	mov	r13,	r15	;
    c40c:	5f 0f       	rrum	#4,	r15	;

0000c40e <.Loc.182.2>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    c40e:	6f d6       	bis.b	@r6,	r15	;
    c410:	0e 4c       	mov	r12,	r14	;
    c412:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    c416:	7e f0 30 00 	and.b	#48,	r14	;#0x0030
    c41a:	4f de       	bis.b	r14,	r15	;
    c41c:	c6 4f 00 00 	mov.b	r15,	0(r6)	;

0000c420 <.Loc.185.2>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    c420:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    c424:	5d d6 01 00 	bis.b	1(r6),	r13	;

0000c428 <.Loc.186.2>:
      ((bank0p[RegDLLIDsMSB] & 0x1C) >> 1));
    c428:	0c 11       	rra	r12		;
    c42a:	7c f0 0e 00 	and.b	#14,	r12	;#0x000e

0000c42e <.Loc.185.2>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    c42e:	4d dc       	bis.b	r12,	r13	;
    c430:	c6 4d 01 00 	mov.b	r13,	1(r6)	;

0000c434 <.Loc.188.2>:
  tf_buffer[2] = mcfc;
    c434:	40 18 5e 42 	movx.b	&0x0f2f8,r14	;
    c438:	f8 f2 
    c43a:	c6 4e 02 00 	mov.b	r14,	2(r6)	;

0000c43e <.Loc.190.2>:
  tf_buffer[3] = vcfc[0];
    c43e:	8c 00 f6 f2 	mova	#62198,	r12	;0x0f2f6
    c442:	6d 4c       	mov.b	@r12,	r13	;
    c444:	c6 4d 03 00 	mov.b	r13,	3(r6)	;

0000c448 <.Loc.192.2>:
  mcfc++;
    c448:	5e 53       	inc.b	r14		;
    c44a:	40 18 c2 4e 	movx.b	r14,	&0xff2f8;
    c44e:	f8 f2 

0000c450 <.Loc.193.2>:
  vcfc[0]++;
    c450:	5d 53       	inc.b	r13		;
    c452:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000c456 <.Loc.195.2>:
  tf_buffer[4] &= ~BIT6;
    c456:	5c 46 04 00 	mov.b	4(r6),	r12	;
    c45a:	7c f0 bf ff 	and.b	#-65,	r12	;#0xffbf

0000c45e <.Loc.197.2>:
  tf_buffer[4] |= 0x07;
    c45e:	7c d0 07 00 	bis.b	#7,	r12	;
    c462:	c6 4c 04 00 	mov.b	r12,	4(r6)	;

0000c466 <.Loc.198.2>:
  tf_buffer[5] = 0xFF;
    c466:	41 18 f2 43 	movx.b	#-1,	&0x10cef;r3 As==11
    c46a:	ef 0c 

0000c46c <.Loc.201.2>:
  if (state == FB_STATE_UNINIT) {
    c46c:	40 18 c2 93 	cmpx.b	#0,	&0xff2e0;r3 As==00
    c470:	e0 f2 
    c472:	44 20       	jnz	$+138    	;abs 0xc4fc

0000c474 <.Loc.204.2>:
    if (MSG_OK != chMBFetch(&rf_mbox, (msg_t *)(&active_packet), 
    c474:	3e 43       	mov	#-1,	r14	;r3 As==11
    c476:	8d 00 dc f2 	mova	#62172,	r13	;0x0f2dc
    c47a:	8c 01 40 0c 	mova	#68672,	r12	;0x10c40
    c47e:	b0 13 b8 4b 	calla	#19384		;0x04bb8

0000c482 <.LVL48>:
    c482:	9c 00 00 00 	cmpa	#0,	r12	;
    c486:	04 24       	jz	$+10     	;abs 0xc490

0000c488 <.Loc.207.2>:
      chDbgAssert(false, "should have a packet available");
    c488:	8c 01 47 0a 	mova	#68167,	r12	;0x10a47
    c48c:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c490 <.L62>:
    pkt_len = elyNLGetLength(active_packet);
    c490:	2c 00 dc f2 	mova	&62172,	r12	;0x0f2dc
    c494:	b0 13 f4 bd 	calla	#48628		;0x0bdf4

0000c498 <.LVL50>:
    c498:	60 0c d8 f2 	mova	r12,	&62168	; 0x0f2d8

0000c49c <.Loc.211.2>:
    tf_buffer[4] &= ~0x07;
    c49c:	f6 f0 f8 ff 	and.b	#-8,	4(r6)	;#0xfff8
    c4a0:	04 00 

0000c4a2 <.Loc.212.2>:
    tf_buffer[5] = 0;
    c4a2:	41 18 c2 43 	movx.b	#0,	&0x10cef;r3 As==00
    c4a6:	ef 0c 

0000c4a8 <.LVL51>:
    idle_len = 0;
    c4a8:	00 18 c2 43 	movx.a	#0,	&0xff2d4;r3 As==00
    c4ac:	d4 f2 

0000c4ae <.Loc.215.2>:
    idle_idx = 0;
    c4ae:	00 18 c2 43 	movx.a	#0,	&0xff2d0;r3 As==00
    c4b2:	d0 f2 

0000c4b4 <.Loc.216.2>:
    pkt_idx = 0;
    c4b4:	00 18 c2 43 	movx.a	#0,	&0xff2cc;r3 As==00
    c4b8:	cc f2 

0000c4ba <.Loc.213.2>:
    fhp = true;
    c4ba:	59 43       	mov.b	#1,	r9	;r3 As==01

0000c4bc <.L61>:
  state = FB_STATE_HEADER;
    c4bc:	40 18 d2 43 	movx.b	#1,	&0xff2e0;r3 As==01
    c4c0:	e0 f2 

0000c4c2 <.Loc.171.2>:
  size_t tf_idx = SDLP_TM_PH_LEN;
    c4c2:	7a 40 06 00 	mov.b	#6,	r10	;

0000c4c6 <.LBB32>:
          elyNLFreeBuffer(active_packet);
    c4c6:	85 00 24 bd 	mova	#48420,	r5	;0x0bd24

0000c4ca <.Loc.240.2>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    c4ca:	87 00 b8 4b 	mova	#19384,	r7	;0x04bb8

0000c4ce <.L63>:
  while (tf_idx != tf_data_len) {
    c4ce:	28 01 e4 0c 	mova	&68836,	r8	;0x10ce4
    c4d2:	da 08       	cmpa	r8,	r10	;
    c4d4:	16 20       	jnz	$+46     	;abs 0xc502

0000c4d6 <.Loc.284.2>:
  if (bank0p[RegDLLTMFEC] & BIT7) {
    c4d6:	c4 93 c2 00 	cmp.b	#0,	194(r4)	;r3 As==00, 0x00c2
    c4da:	07 34       	jge	$+16     	;abs 0xc4ea

0000c4dc <.Loc.286.2>:
    crcGenSDLP(tf_buffer, tf_len);
    c4dc:	c0 18 1d 42 	movx.w	&0x10ce8,r13	;
    c4e0:	e8 0c 
    c4e2:	8c 01 ea 0c 	mova	#68842,	r12	;0x10cea
    c4e6:	b0 13 70 ac 	calla	#44144		;0x0ac70

0000c4ea <.L79>:
  chEvtSignal(rf_thd, RFTxFrameReady);
    c4ea:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    c4ee:	4e 43       	clr.b	r14		;
    c4f0:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c4f4:	b0 13 9a 49 	calla	#18842		;0x0499a

0000c4f8 <.LVL55>:
}
    c4f8:	64 16       	popm.a	#7,	r10	;20-bit words
    c4fa:	10 01       	reta			;

0000c4fc <.L80>:
  bool fhp = false;
    c4fc:	49 43       	clr.b	r9		;
    c4fe:	80 00 bc c4 	mova	#50364,	r0	;0x0c4bc

0000c502 <.L78>:
    switch(state) {
    c502:	40 18 5c 42 	movx.b	&0x0f2e0,r12	;
    c506:	e0 f2 
    c508:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    c50a:	14 24       	jz	$+42     	;abs 0xc534
    c50c:	7c 90 03 00 	cmp.b	#3,	r12	;
    c510:	86 24       	jz	$+270    	;abs 0xc61e
    c512:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    c514:	bb 20       	jnz	$+376    	;abs 0xc68c

0000c516 <.Loc.224.2>:
        if (idle_len > 0) {
    c516:	00 18 c2 93 	cmpx.a	#0,	&0xff2d4;r3 As==00
    c51a:	d4 f2 
    c51c:	06 24       	jz	$+14     	;abs 0xc52a

0000c51e <.Loc.225.2>:
          state = FB_STATE_IDLE;
    c51e:	40 18 f2 40 	movx.b	#3,	&0xff2e0;
    c522:	03 00 e0 f2 
    c526:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c52a <.L68>:
          state = FB_STATE_PAYLOAD;
    c52a:	40 18 e2 43 	movx.b	#2,	&0xff2e0;r3 As==10
    c52e:	e0 f2 
    c530:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c534 <.L65>:
        if (pkt_idx == pkt_len) {
    c534:	00 18 d2 92 	cmpx.a	&0x0f2d8,&0xff2cc;
    c538:	d8 f2 cc f2 
    c53c:	5f 20       	jnz	$+192    	;abs 0xc5fc

0000c53e <.LBB33>:
          pkt_idx = 0; /* either way - needs to be 0 when we come back around */
    c53e:	00 18 c2 43 	movx.a	#0,	&0xff2cc;r3 As==00
    c542:	cc f2 

0000c544 <.Loc.234.2>:
          elyNLFreeBuffer(active_packet);
    c544:	2c 00 dc f2 	mova	&62172,	r12	;0x0f2dc
    c548:	45 13       	calla	r5		;

0000c54a <.LVL58>:
          if (!fhp) {
    c54a:	09 93       	cmp	#0,	r9	;r3 As==00
    c54c:	14 20       	jnz	$+42     	;abs 0xc576

0000c54e <.Loc.236.2>:
            tf_buffer[4] |= (tf_idx-SDLP_TM_PH_LEN) >> 8;
    c54e:	cc 0a       	mova	r10,	r12	;
    c550:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    c554:	0c 14       	pushm.a	#1,	r12	;20-bit words
    c556:	40 18 3c 41 	popx.w	r12		;
    c55a:	40 18 3d 41 	popx.w	r13		;
    c55e:	b0 13 24 cd 	calla	#52516		;0x0cd24
    c562:	0d 12       	push	r13		;
    c564:	0c 12       	push	r12		;
    c566:	0c 16       	popm.a	#1,	r12	;20-bit words
    c568:	c6 dc 04 00 	bis.b	r12,	4(r6)	;

0000c56c <.Loc.237.2>:
            tf_buffer[5] = (tf_idx-SDLP_TM_PH_LEN) & 0xFF;
    c56c:	4c 4a       	mov.b	r10,	r12	;
    c56e:	7c 50 fa ff 	add.b	#-6,	r12	;#0xfffa
    c572:	c6 4c 05 00 	mov.b	r12,	5(r6)	;

0000c576 <.L71>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    c576:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    c57a:	8d 00 dc f2 	mova	#62172,	r13	;0x0f2dc
    c57e:	8c 01 40 0c 	mova	#68672,	r12	;0x10c40
    c582:	47 13       	calla	r7		;

0000c584 <.LVL61>:
          if (MSG_OK != r) {
    c584:	9c 00 00 00 	cmpa	#0,	r12	;
    c588:	32 24       	jz	$+102    	;abs 0xc5ee

0000c58a <.Loc.242.2>:
            idle_len = tf_data_len - tf_idx;
    c58a:	2e 01 e4 0c 	mova	&68836,	r14	;0x10ce4
    c58e:	00 18 4c 4e 	movx.a	r14,	r12	;
    c592:	00 18 4c 8a 	subx.a	r10,	r12	;

0000c596 <.LVL62>:
            if (idle_len < 7) {
    c596:	7d 40 06 00 	mov.b	#6,	r13	;
    c59a:	dd 0c       	cmpa	r12,	r13	;
    c59c:	23 2c       	jc	$+72     	;abs 0xc5e4

0000c59e <.Loc.242.2>:
            idle_len = tf_data_len - tf_idx;
    c59e:	60 0c d4 f2 	mova	r12,	&62164	; 0x0f2d4

0000c5a2 <.L74>:
            idle_header[4] = (idle_len - 7) >> 8;
    c5a2:	28 00 d4 f2 	mova	&62164,	r8	;0x0f2d4
    c5a6:	89 01 dc 0c 	mova	#68828,	r9	;0x10cdc
    c5aa:	cc 08       	mova	r8,	r12	;
    c5ac:	ac 0f f9 ff 	adda	#1048569,r12	;0xffff9
    c5b0:	0c 14       	pushm.a	#1,	r12	;20-bit words
    c5b2:	40 18 3c 41 	popx.w	r12		;
    c5b6:	40 18 3d 41 	popx.w	r13		;
    c5ba:	b0 13 24 cd 	calla	#52516		;0x0cd24
    c5be:	0d 12       	push	r13		;
    c5c0:	0c 12       	push	r12		;
    c5c2:	0c 16       	popm.a	#1,	r12	;20-bit words
    c5c4:	c9 4c 04 00 	mov.b	r12,	4(r9)	;

0000c5c8 <.Loc.247.2>:
            idle_header[5] = (idle_len - 7) & 0xFF;
    c5c8:	78 50 f9 ff 	add.b	#-7,	r8	;#0xfff9
    c5cc:	c9 48 05 00 	mov.b	r8,	5(r9)	;

0000c5d0 <.Loc.248.2>:
            idle_idx = 0;
    c5d0:	00 18 c2 43 	movx.a	#0,	&0xff2d0;r3 As==00
    c5d4:	d0 f2 

0000c5d6 <.Loc.249.2>:
            state = FB_STATE_IDLE;
    c5d6:	40 18 f2 40 	movx.b	#3,	&0xff2e0;
    c5da:	03 00 e0 f2 

0000c5de <.Loc.250.2>:
            continue;
    c5de:	59 43       	mov.b	#1,	r9	;r3 As==01
    c5e0:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c5e4 <.L73>:
              idle_len += tf_data_len;
    c5e4:	ee 0c       	adda	r12,	r14	;
    c5e6:	60 0e d4 f2 	mova	r14,	&62164	; 0x0f2d4
    c5ea:	80 00 a2 c5 	mova	#50594,	r0	;0x0c5a2

0000c5ee <.L72>:
            pkt_len = elyNLGetLength(active_packet);
    c5ee:	2c 00 dc f2 	mova	&62172,	r12	;0x0f2dc

0000c5f2 <.LVL65>:
    c5f2:	b0 13 f4 bd 	calla	#48628		;0x0bdf4

0000c5f6 <.LVL66>:
    c5f6:	60 0c d8 f2 	mova	r12,	&62168	; 0x0f2d8
    c5fa:	59 43       	mov.b	#1,	r9	;r3 As==01

0000c5fc <.L70>:
        tf_buffer[tf_idx++] = active_packet[pkt_idx++];
    c5fc:	2c 00 cc f2 	mova	&62156,	r12	;0x0f2cc
    c600:	cd 0c       	mova	r12,	r13	;
    c602:	ad 00 01 00 	adda	#1,	r13	;
    c606:	60 0d cc f2 	mova	r13,	&62156	; 0x0f2cc
    c60a:	00 18 5c 52 	addx.a	&0x0f2dc,r12	;
    c60e:	dc f2 
    c610:	41 18 ea 4c 	movx.b	@r12,	68842(r10); 0x10cea
    c614:	ea 0c 
    c616:	aa 00 01 00 	adda	#1,	r10	;

0000c61a <.LVL68>:
        break;
    c61a:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c61e <.L66>:
        if (idle_idx < 6) {
    c61e:	2c 00 d0 f2 	mova	&62160,	r12	;0x0f2d0
    c622:	ce 0a       	mova	r10,	r14	;
    c624:	ae 00 01 00 	adda	#1,	r14	;
    c628:	aa 01 ea 0c 	adda	#68842,	r10	;0x10cea

0000c62c <.LVL69>:
    c62c:	7d 40 05 00 	mov.b	#5,	r13	;
    c630:	dd 0c       	cmpa	r12,	r13	;
    c632:	23 28       	jnc	$+72     	;abs 0xc67a

0000c634 <.LVL70>:
          tf_buffer[tf_idx++] = idle_header[idle_idx++];
    c634:	cd 0c       	mova	r12,	r13	;
    c636:	ad 00 01 00 	adda	#1,	r13	;
    c63a:	60 0d d0 f2 	mova	r13,	&62160	; 0x0f2d0
    c63e:	c0 18 da 4c 	movx.b	68828(r12),0(r10)	;0x10cdc
    c642:	dc 0c 00 00 

0000c646 <.L85>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    c646:	ca 0e       	mova	r14,	r10	;

0000c648 <.LVL71>:
        if (idle_idx == idle_len) {
    c648:	00 18 d2 92 	cmpx.a	&0x0f2d4,&0xff2d0;
    c64c:	d4 f2 d0 f2 
    c650:	3e 23       	jnz	$-386    	;abs 0xc4ce

0000c652 <.Loc.267.2>:
          chDbgAssert(tf_idx == tf_data_len, "invalid framebuilder state");
    c652:	de 08       	cmpa	r8,	r14	;
    c654:	04 24       	jz	$+10     	;abs 0xc65e

0000c656 <.Loc.267.2>:
    c656:	8c 01 47 0a 	mova	#68167,	r12	;0x10a47
    c65a:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c65e <.L77>:
          idle_len = 0;
    c65e:	00 18 c2 43 	movx.a	#0,	&0xff2d4;r3 As==00
    c662:	d4 f2 

0000c664 <.Loc.269.2>:
          chEvtWaitAnyTimeout(RFPktAvailable, TIME_IMMEDIATE);
    c664:	3e 43       	mov	#-1,	r14	;r3 As==11
    c666:	3c 40 00 04 	mov	#1024,	r12	;#0x0400
    c66a:	4d 43       	clr.b	r13		;
    c66c:	b0 13 0e 4a 	calla	#18958		;0x04a0e

0000c670 <.LVL73>:
          state = FB_STATE_UNINIT;
    c670:	40 18 c2 43 	movx.b	#0,	&0xff2e0;r3 As==00
    c674:	e0 f2 

0000c676 <.Loc.271.2>:
          continue;
    c676:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c67a <.L75>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    c67a:	fa 40 aa ff 	mov.b	#-86,	0(r10)	;#0xffaa
    c67e:	00 00 

0000c680 <.Loc.264.2>:
          idle_idx++;
    c680:	ac 00 01 00 	adda	#1,	r12	;
    c684:	60 0c d0 f2 	mova	r12,	&62160	; 0x0f2d0
    c688:	80 00 46 c6 	mova	#50758,	r0	;0x0c646

0000c68c <.L84>:
        chDbgAssert(false, "invalid framebuilder state");
    c68c:	8c 01 47 0a 	mova	#68167,	r12	;0x10a47
    c690:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c694 <.LVL76>:
        break;
    c694:	80 00 ce c4 	mova	#50382,	r0	;0x0c4ce

0000c698 <elyRFDLLRxInit>:
void elyRFDLLRxInit(SX1212Driver * devp) {
    c698:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c69a <.LCFI4>:
    c69a:	ca 0c       	mova	r12,	r10	;

0000c69c <.Loc.371.2>:
  sx1212StopReceive(devp);
    c69c:	b0 13 40 78 	calla	#30784		;0x07840

0000c6a0 <.LVL78>:
  sx1212StartReceive(devp, SDLP_TM_PH_LEN, rxfifothresh_callback);
    c6a0:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c6a4:	7d 40 06 00 	mov.b	#6,	r13	;
    c6a8:	cc 0a       	mova	r10,	r12	;
    c6aa:	b0 13 06 77 	calla	#30470		;0x07706

0000c6ae <.LVL79>:
  rx_state = FB_STATE_HEADER;
    c6ae:	40 18 d2 43 	movx.b	#1,	&0xff2e4;r3 As==01
    c6b2:	e4 f2 

0000c6b4 <.Loc.378.2>:
  chEvtSignal(rf_thd, RFRxIdle);
    c6b4:	3d 40 00 40 	mov	#16384,	r13	;#0x4000
    c6b8:	4e 43       	clr.b	r14		;
    c6ba:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c6be:	b0 13 9a 49 	calla	#18842		;0x0499a

0000c6c2 <.LVL80>:
}
    c6c2:	0a 16       	popm.a	#1,	r10	;20-bit words
    c6c4:	10 01       	reta			;

0000c6c6 <elyRFDLLHandleRxFifo>:
void elyRFDLLHandleRxFifo(SX1212Driver * devp) {
    c6c6:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000c6c8 <.LCFI5>:
    c6c8:	04 14       	pushm.a	#1,	r4	;20-bit words

0000c6ca <.LCFI6>:
    c6ca:	c4 0c       	mova	r12,	r4	;

0000c6cc <.Loc.383.2>:
  if (rx_state == FB_STATE_HEADER) {
    c6cc:	40 18 5d 42 	movx.b	&0x0f2e4,r13	;
    c6d0:	e4 f2 
    c6d2:	8f 00 9c 77 	mova	#30620,	r15	;0x0779c
    c6d6:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    c6d8:	f5 20       	jnz	$+492    	;abs 0xc8c4

0000c6da <.Loc.387.2>:
    sx1212FifoRead(devp, SDLP_TM_PH_LEN, tm_hdr_buff);
    c6da:	8a 00 f0 f2 	mova	#62192,	r10	;0x0f2f0
    c6de:	ce 0a       	mova	r10,	r14	;
    c6e0:	7d 40 06 00 	mov.b	#6,	r13	;
    c6e4:	4f 13       	calla	r15		;

0000c6e6 <.LVL82>:
    if (tm_hdr_buff[0] & 0xC0) {
    c6e6:	6c 4a       	mov.b	@r10,	r12	;
    c6e8:	7c b0 c0 ff 	bit.b	#-64,	r12	;#0xffc0
    c6ec:	06 24       	jz	$+14     	;abs 0xc6fa

0000c6ee <.L91>:
      elyRFDLLRxInit(devp);
    c6ee:	cc 04       	mova	r4,	r12	;
    c6f0:	b0 13 98 c6 	calla	#50840		;0x0c698

0000c6f4 <.L87>:
}
    c6f4:	04 16       	popm.a	#1,	r4	;20-bit words
    c6f6:	46 16       	popm.a	#5,	r10	;20-bit words
    c6f8:	10 01       	reta			;

0000c6fa <.L89>:
            (((bank0p[RegDLLIDsMSB] & 0x03) << 2) |
    c6fa:	28 01 40 08 	mova	&67648,	r8	;0x10840
    c6fe:	5e 48 ca 00 	mov.b	202(r8),r14	;0x000ca

0000c702 <.Loc.399.2>:
            (bank0p[RegDLLIDsLSB] >> 4))) ||
    c702:	5f 48 c9 00 	mov.b	201(r8),r15	;0x000c9

0000c706 <.Loc.398.2>:
            (((bank0p[RegDLLIDsMSB] & 0x03) << 2) |
    c706:	0d 4e       	mov	r14,	r13	;
    c708:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    c70c:	7d f0 0c 00 	and.b	#12,	r13	;#0x000c

0000c710 <.Loc.399.2>:
            (bank0p[RegDLLIDsLSB] >> 4))) ||
    c710:	09 4f       	mov	r15,	r9	;
    c712:	59 0f       	rrum	#4,	r9	;

0000c714 <.Loc.398.2>:
            (((bank0p[RegDLLIDsMSB] & 0x03) << 2) |
    c714:	0d d9       	bis	r9,	r13	;

0000c716 <.Loc.397.2>:
    if (((tm_hdr_buff[0] & 0x3F) != 
    c716:	0c 9d       	cmp	r13,	r12	;
    c718:	ea 23       	jnz	$-42     	;abs 0xc6ee

0000c71a <.Loc.400.2>:
       ((tm_hdr_buff[1] >> 4) != (bank0p[RegDLLIDsLSB] & 0x0F))) {
    c71a:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    c71e:	0d 4c       	mov	r12,	r13	;
    c720:	5d 0f       	rrum	#4,	r13	;

0000c722 <.Loc.399.2>:
            (bank0p[RegDLLIDsLSB] >> 4))) ||
    c722:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    c726:	4f 9d       	cmp.b	r13,	r15	;
    c728:	e2 23       	jnz	$-58     	;abs 0xc6ee

0000c72a <.Loc.406.2>:
    if (((tm_hdr_buff[1] & 0x0F) >> 1) != ((bank0p[RegDLLIDsMSB] & 0x1C) >> 2)) {
    c72a:	0c 11       	rra	r12		;
    c72c:	41 18 0e 11 	rpt #2 { rrax.w	r14		;
    c730:	0c ee       	xor	r14,	r12	;
    c732:	3c b0 07 00 	bit	#7,	r12	;
    c736:	db 23       	jnz	$-72     	;abs 0xc6ee

0000c738 <.Loc.413.2>:
    rx_fhp = ((tm_hdr_buff[4] & 0x03) << 8) | (tm_hdr_buff[5]);
    c738:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    c73c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    c740:	3c f0 00 03 	and	#768,	r12	;#0x0300
    c744:	5a 4a 05 00 	mov.b	5(r10),	r10	;
    c748:	0c da       	bis	r10,	r12	;
    c74a:	40 18 82 4c 	movx.w	r12,	&0xff2e2;
    c74e:	e2 f2 

0000c750 <.Loc.414.2>:
    chDbgAssert(rx_fhp < tf_len || rx_fhp == 0x3FF, "invalid FHP");
    c750:	c0 18 1c 92 	cmpx.w	&0x10ce8,r12	;
    c754:	e8 0c 
    c756:	07 28       	jnc	$+16     	;abs 0xc766

0000c758 <.Loc.414.2>:
    c758:	3c 90 ff 03 	cmp	#1023,	r12	;#0x03ff
    c75c:	04 24       	jz	$+10     	;abs 0xc766

0000c75e <.Loc.414.2>:
    c75e:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    c762:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c766 <.L92>:
    if (rx_fhp == 0x3FF) {
    c766:	40 18 1c 42 	movx.w	&0x0f2e2,r12	;
    c76a:	e2 f2 
    c76c:	88 00 a2 c1 	mova	#49570,	r8	;0x0c1a2
    c770:	8a 00 c0 76 	mova	#30400,	r10	;0x076c0
    c774:	86 00 c6 49 	mova	#18886,	r6	;0x049c6
    c778:	3c 90 ff 03 	cmp	#1023,	r12	;#0x03ff
    c77c:	56 20       	jnz	$+174    	;abs 0xc82a

0000c77e <.Loc.417.2>:
      chDbgAssert(rx_pkt_len > tf_len - SDLP_TM_PH_LEN, "invalid fhp");
    c77e:	c0 18 1c 42 	movx.w	&0x10ce8,r12	;
    c782:	e8 0c 
    c784:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa
    c788:	40 18 1c 92 	cmpx.w	&0x0f2e8,r12	;
    c78c:	e8 f2 
    c78e:	04 28       	jnc	$+10     	;abs 0xc798

0000c790 <.L98>:
    c790:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    c794:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c798 <.L94>:
    if (NULL == rx_active_buffer) {
    c798:	00 18 c2 93 	cmpx.a	#0,	&0xff2ec;r3 As==00
    c79c:	ec f2 
    c79e:	15 20       	jnz	$+44     	;abs 0xc7ca

0000c7a0 <.Loc.437.2>:
      rx_active_buffer = elyNLGetBuffer();
    c7a0:	b0 13 1a bd 	calla	#48410		;0x0bd1a

0000c7a4 <.LVL86>:
    c7a4:	60 0c ec f2 	mova	r12,	&62188	; 0x0f2ec

0000c7a8 <.Loc.438.2>:
      if (NULL == rx_active_buffer) {
    c7a8:	9c 00 00 00 	cmpa	#0,	r12	;
    c7ac:	04 20       	jnz	$+10     	;abs 0xc7b6

0000c7ae <.Loc.440.2>:
        chDbgAssert(false, "bad juju");
    c7ae:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    c7b2:	b0 13 3e 46 	calla	#17982		;0x0463e

0000c7b6 <.L100>:
      rx_pkt_idx = 0;
    c7b6:	40 18 82 43 	movx.w	#0,	&0xff2ea;r3 As==00
    c7ba:	ea f2 

0000c7bc <.Loc.444.2>:
      rx_hdr = true;
    c7bc:	41 18 d2 43 	movx.b	#1,	&0x10ce3;r3 As==01
    c7c0:	e3 0c 

0000c7c2 <.Loc.445.2>:
      rx_pkt_len = elyNLHeaderLen;
    c7c2:	40 18 b2 40 	movx.w	#6,	&0xff2e8;
    c7c6:	06 00 e8 f2 

0000c7ca <.L99>:
    rx_tf_idx = SDLP_TM_PH_LEN;
    c7ca:	40 18 b2 40 	movx.w	#6,	&0xff2e6;
    c7ce:	06 00 e6 f2 

0000c7d2 <.Loc.451.2>:
    chSysLock();
    c7d2:	48 13       	calla	r8		;

0000c7d4 <.LVL88>:
    if (tf_len - rx_tf_idx < 48 && tf_len - rx_tf_idx < rx_pkt_len - rx_pkt_idx) {
    c7d4:	c0 18 1c 42 	movx.w	&0x10ce8,r12	;
    c7d8:	e8 0c 
    c7da:	0d 4c       	mov	r12,	r13	;
    c7dc:	3d 50 fa ff 	add	#-6,	r13	;#0xfffa
    c7e0:	7e 40 2f 00 	mov.b	#47,	r14	;#0x002f
    c7e4:	0e 9d       	cmp	r13,	r14	;
    c7e6:	54 28       	jnc	$+170    	;abs 0xc890

0000c7e8 <.Loc.452.2>:
    c7e8:	40 18 1e 42 	movx.w	&0x0f2e8,r14	;
    c7ec:	e8 f2 
    c7ee:	40 18 1e 82 	subx.w	&0x0f2ea,r14	;
    c7f2:	ea f2 
    c7f4:	0d 9e       	cmp	r14,	r13	;
    c7f6:	4c 2c       	jc	$+154    	;abs 0xc890

0000c7f8 <.Loc.453.2>:
      curr_threshold = tf_len - rx_tf_idx;
    c7f8:	7c 50 fa ff 	add.b	#-6,	r12	;#0xfffa
    c7fc:	40 18 c2 4c 	movx.b	r12,	&0xff2e5;
    c800:	e5 f2 

0000c802 <.L102>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    c802:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c806:	40 18 5c 42 	movx.b	&0x0f2e5,r12	;
    c80a:	e5 f2 
    c80c:	40 18 0d 4c 	movx.w	r12,	r13	;
    c810:	cc 04       	mova	r4,	r12	;
    c812:	4a 13       	calla	r10		;

0000c814 <.LVL89>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    c814:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c818:	4e 43       	clr.b	r14		;
    c81a:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c81e:	46 13       	calla	r6		;

0000c820 <.LVL90>:
    rx_state = FB_STATE_PAYLOAD;
    c820:	40 18 e2 43 	movx.b	#2,	&0xff2e4;r3 As==10
    c824:	e4 f2 
    c826:	80 00 6c c8 	mova	#51308,	r0	;0x0c86c

0000c82a <.L93>:
    else if (rx_fhp == 0x3FE) {
    c82a:	3c 90 fe 03 	cmp	#1022,	r12	;#0x03fe
    c82e:	22 20       	jnz	$+70     	;abs 0xc874

0000c830 <.Loc.421.2>:
      rx_state = FB_STATE_IDLE;
    c830:	40 18 f2 40 	movx.b	#3,	&0xff2e4;
    c834:	03 00 e4 f2 

0000c838 <.Loc.422.2>:
      curr_threshold = (tf_len - SDLP_TM_PH_LEN < 48 ? tf_len - SDLP_TM_PH_LEN : 48);
    c838:	c0 18 19 42 	movx.w	&0x10ce8,r9	;
    c83c:	e8 0c 
    c83e:	39 50 fa ff 	add	#-6,	r9	;#0xfffa
    c842:	7c 40 30 00 	mov.b	#48,	r12	;#0x0030
    c846:	0c 99       	cmp	r9,	r12	;
    c848:	01 2c       	jc	$+4      	;abs 0xc84c
    c84a:	09 4c       	mov	r12,	r9	;

0000c84c <.L96>:
    c84c:	40 18 c2 49 	movx.b	r9,	&0xff2e5;
    c850:	e5 f2 

0000c852 <.Loc.423.2>:
      chSysLock();
    c852:	48 13       	calla	r8		;

0000c854 <.LVL91>:
      sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    c854:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c858:	40 18 0d 49 	movx.w	r9,	r13	;
    c85c:	cc 04       	mova	r4,	r12	;
    c85e:	4a 13       	calla	r10		;

0000c860 <.LVL92>:
      chEvtSignalI(rf_thd, RFSpiAvailable);
    c860:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c864:	4e 43       	clr.b	r14		;
    c866:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c86a:	46 13       	calla	r6		;

0000c86c <.L122>:
    chSysUnlock();
    c86c:	b0 13 aa c1 	calla	#49578		;0x0c1aa

0000c870 <.LVL94>:
    c870:	80 00 f4 c6 	mova	#50932,	r0	;0x0c6f4

0000c874 <.L95>:
    else if (NULL == rx_active_buffer) {
    c874:	00 18 c2 93 	cmpx.a	#0,	&0xff2ec;r3 As==00
    c878:	ec f2 
    c87a:	04 20       	jnz	$+10     	;abs 0xc884

0000c87c <.Loc.430.2>:
      chDbgAssert(rx_fhp == 0, "invalid fhp");
    c87c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c87e:	8c 27       	jz	$-230    	;abs 0xc798
    c880:	80 00 90 c7 	mova	#51088,	r0	;0x0c790

0000c884 <.L97>:
      chDbgAssert(rx_fhp == rx_pkt_len, "invalid fhp");
    c884:	40 18 1c 92 	cmpx.w	&0x0f2e8,r12	;
    c888:	e8 f2 
    c88a:	82 23       	jnz	$-250    	;abs 0xc790
    c88c:	80 00 98 c7 	mova	#51096,	r0	;0x0c798

0000c890 <.L101>:
    else if (rx_pkt_len - rx_pkt_idx < 48) {
    c890:	40 18 1d 42 	movx.w	&0x0f2e8,r13	;
    c894:	e8 f2 
    c896:	40 18 1c 42 	movx.w	&0x0f2ea,r12	;
    c89a:	ea f2 
    c89c:	40 18 0e 4d 	movx.w	r13,	r14	;
    c8a0:	40 18 0e 8c 	subx.w	r12,	r14	;
    c8a4:	7f 40 2f 00 	mov.b	#47,	r15	;#0x002f
    c8a8:	0f 9e       	cmp	r14,	r15	;
    c8aa:	06 28       	jnc	$+14     	;abs 0xc8b8

0000c8ac <.Loc.456.2>:
      curr_threshold = rx_pkt_len - rx_pkt_idx;
    c8ac:	4d 8c       	sub.b	r12,	r13	;
    c8ae:	40 18 c2 4d 	movx.b	r13,	&0xff2e5;
    c8b2:	e5 f2 
    c8b4:	80 00 02 c8 	mova	#51202,	r0	;0x0c802

0000c8b8 <.L103>:
      curr_threshold = 48;
    c8b8:	40 18 f2 40 	movx.b	#48,	&0xff2e5;0x00030
    c8bc:	30 00 e5 f2 
    c8c0:	80 00 02 c8 	mova	#51202,	r0	;0x0c802

0000c8c4 <.L88>:
    c8c4:	8a 00 a2 c1 	mova	#49570,	r10	;0x0c1a2
    c8c8:	86 00 c0 76 	mova	#30400,	r6	;0x076c0
    c8cc:	87 00 c6 49 	mova	#18886,	r7	;0x049c6
    c8d0:	58 42 e5 f2 	mov.b	&0xf2e5,r8	;0xf2e5
    c8d4:	09 43       	clr	r9		;
    c8d6:	40 18 1e 42 	movx.w	&0x0f2ea,r14	;
    c8da:	ea f2 

0000c8dc <.Loc.468.2>:
  else if (rx_state == FB_STATE_IDLE) {
    c8dc:	7d 90 03 00 	cmp.b	#3,	r13	;
    c8e0:	43 20       	jnz	$+136    	;abs 0xc968

0000c8e2 <.Loc.473.2>:
    sx1212FifoRead(devp, curr_threshold, rx_active_buffer + rx_pkt_idx);
    c8e2:	09 12       	push	r9		;
    c8e4:	08 12       	push	r8		;
    c8e6:	0d 16       	popm.a	#1,	r13	;20-bit words
    c8e8:	00 18 5e 52 	addx.a	&0x0f2ec,r14	;
    c8ec:	ec f2 
    c8ee:	4f 13       	calla	r15		;

0000c8f0 <.LVL95>:
    rx_tf_idx += curr_threshold;
    c8f0:	40 18 5c 42 	movx.b	&0x0f2e5,r12	;
    c8f4:	e5 f2 
    c8f6:	40 18 1c 52 	addx.w	&0x0f2e6,r12	;
    c8fa:	e6 f2 
    c8fc:	40 18 82 4c 	movx.w	r12,	&0xff2e6;
    c900:	e6 f2 

0000c902 <.Loc.476.2>:
    if (rx_tf_idx == tf_len) {
    c902:	c0 18 19 42 	movx.w	&0x10ce8,r9	;
    c906:	e8 0c 
    c908:	0c 99       	cmp	r9,	r12	;
    c90a:	15 20       	jnz	$+44     	;abs 0xc936

0000c90c <.L123>:
      chSysLock();
    c90c:	4a 13       	calla	r10		;

0000c90e <.LVL96>:
      sx1212StopReceiveI(devp);
    c90e:	cc 04       	mova	r4,	r12	;
    c910:	b0 13 5c 78 	calla	#30812		;0x0785c

0000c914 <.LVL97>:
      sx1212ReceiveI(devp, SDLP_TM_PH_LEN, rxfifothresh_callback);
    c914:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c918:	7d 40 06 00 	mov.b	#6,	r13	;
    c91c:	cc 04       	mova	r4,	r12	;
    c91e:	46 13       	calla	r6		;

0000c920 <.LVL98>:
      chEvtSignalI(rf_thd, RFSpiAvailable | RFRxIdle);
    c920:	3d 40 00 60 	mov	#24576,	r13	;#0x6000
    c924:	4e 43       	clr.b	r14		;
    c926:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c92a:	47 13       	calla	r7		;

0000c92c <.LVL99>:
      rx_state = FB_STATE_HEADER;
    c92c:	40 18 d2 43 	movx.b	#1,	&0xff2e4;r3 As==01
    c930:	e4 f2 
    c932:	80 00 6c c8 	mova	#51308,	r0	;0x0c86c

0000c936 <.L105>:
    curr_threshold = (tf_len - SDLP_TM_PH_LEN < 48 ? tf_len - SDLP_TM_PH_LEN : 48);
    c936:	39 50 fa ff 	add	#-6,	r9	;#0xfffa
    c93a:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030
    c93e:	0d 99       	cmp	r9,	r13	;
    c940:	01 2c       	jc	$+4      	;abs 0xc944
    c942:	09 4d       	mov	r13,	r9	;

0000c944 <.L106>:
    c944:	40 18 c2 49 	movx.b	r9,	&0xff2e5;
    c948:	e5 f2 

0000c94a <.Loc.488.2>:
    chSysLock();
    c94a:	4a 13       	calla	r10		;

0000c94c <.LVL100>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    c94c:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c950:	40 18 0d 49 	movx.w	r9,	r13	;

0000c954 <.L121>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    c954:	cc 04       	mova	r4,	r12	;
    c956:	46 13       	calla	r6		;

0000c958 <.LVL101>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    c958:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    c95c:	4e 43       	clr.b	r14		;
    c95e:	2c 01 be 1a 	mova	&72382,	r12	;0x11abe
    c962:	47 13       	calla	r7		;

0000c964 <.LVL102>:
    c964:	80 00 6c c8 	mova	#51308,	r0	;0x0c86c

0000c968 <.L104>:
    sx1212FifoRead(devp, curr_threshold, rx_active_buffer + rx_pkt_idx);
    c968:	09 12       	push	r9		;
    c96a:	08 12       	push	r8		;
    c96c:	0d 16       	popm.a	#1,	r13	;20-bit words
    c96e:	00 18 5e 52 	addx.a	&0x0f2ec,r14	;
    c972:	ec f2 
    c974:	4f 13       	calla	r15		;

0000c976 <.LVL103>:
    rx_pkt_idx += curr_threshold;
    c976:	40 18 5d 42 	movx.b	&0x0f2e5,r13	;
    c97a:	e5 f2 
    c97c:	40 18 1c 42 	movx.w	&0x0f2ea,r12	;
    c980:	ea f2 
    c982:	0c 5d       	add	r13,	r12	;
    c984:	40 18 82 4c 	movx.w	r12,	&0xff2ea;
    c988:	ea f2 

0000c98a <.Loc.503.2>:
    rx_tf_idx += curr_threshold;
    c98a:	40 18 82 5d 	addx.w	r13,	&0xff2e6;
    c98e:	e6 f2 

0000c990 <.Loc.504.2>:
    if (rx_pkt_idx == rx_pkt_len) {
    c990:	40 18 1c 92 	cmpx.w	&0x0f2e8,r12	;
    c994:	e8 f2 
    c996:	0e 20       	jnz	$+30     	;abs 0xc9b4
    c998:	2c 00 ec f2 	mova	&62188,	r12	;0x0f2ec

0000c99c <.Loc.505.2>:
      if (rx_hdr) {
    c99c:	41 18 c2 93 	cmpx.b	#0,	&0x10ce3;r3 As==00
    c9a0:	e3 0c 
    c9a2:	2e 24       	jz	$+94     	;abs 0xca00

0000c9a4 <.Loc.506.2>:
        rx_hdr = false;
    c9a4:	41 18 c2 43 	movx.b	#0,	&0x10ce3;r3 As==00
    c9a8:	e3 0c 

0000c9aa <.Loc.507.2>:
        rx_pkt_len = elyNLGetLength(rx_active_buffer);
    c9aa:	b0 13 f4 bd 	calla	#48628		;0x0bdf4

0000c9ae <.LVL104>:
    c9ae:	40 18 82 4c 	movx.w	r12,	&0xff2e8;
    c9b2:	e8 f2 

0000c9b4 <.L107>:
    if (rx_tf_idx == tf_len) {
    c9b4:	40 18 19 42 	movx.w	&0x0f2e6,r9	;
    c9b8:	e6 f2 
    c9ba:	c0 18 18 42 	movx.w	&0x10ce8,r8	;
    c9be:	e8 0c 
    c9c0:	09 98       	cmp	r8,	r9	;
    c9c2:	a4 27       	jz	$-182    	;abs 0xc90c

0000c9c4 <.Loc.538.2>:
    chSysLock();
    c9c4:	4a 13       	calla	r10		;

0000c9c6 <.LVL105>:
    if (tf_len - rx_tf_idx < 48 && tf_len - rx_tf_idx < rx_pkt_len - rx_pkt_idx) {
    c9c6:	40 18 0c 48 	movx.w	r8,	r12	;
    c9ca:	40 18 0c 89 	subx.w	r9,	r12	;
    c9ce:	7e 40 2f 00 	mov.b	#47,	r14	;#0x002f
    c9d2:	0e 9c       	cmp	r12,	r14	;
    c9d4:	36 28       	jnc	$+110    	;abs 0xca42

0000c9d6 <.Loc.539.2>:
    c9d6:	40 18 1d 42 	movx.w	&0x0f2e8,r13	;
    c9da:	e8 f2 
    c9dc:	40 18 1d 82 	subx.w	&0x0f2ea,r13	;
    c9e0:	ea f2 
    c9e2:	0c 9d       	cmp	r13,	r12	;
    c9e4:	2e 2c       	jc	$+94     	;abs 0xca42

0000c9e6 <.Loc.540.2>:
      curr_threshold = tf_len - rx_tf_idx;
    c9e6:	48 89       	sub.b	r9,	r8	;
    c9e8:	40 18 c2 48 	movx.b	r8,	&0xff2e5;
    c9ec:	e5 f2 

0000c9ee <.L113>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    c9ee:	8e 00 b4 c1 	mova	#49588,	r14	;0x0c1b4
    c9f2:	40 18 5c 42 	movx.b	&0x0f2e5,r12	;
    c9f6:	e5 f2 
    c9f8:	40 18 0d 4c 	movx.w	r12,	r13	;
    c9fc:	80 00 54 c9 	mova	#51540,	r0	;0x0c954

0000ca00 <.L108>:
        if (MSG_OK != elyUARTPost(rx_active_buffer, TIME_IMMEDIATE)) {
    ca00:	3d 43       	mov	#-1,	r13	;r3 As==11
    ca02:	b0 13 e2 78 	calla	#30946		;0x078e2

0000ca06 <.LVL106>:
    ca06:	9c 00 00 00 	cmpa	#0,	r12	;
    ca0a:	04 24       	jz	$+10     	;abs 0xca14

0000ca0c <.Loc.512.2>:
          elyNLFreeBuffer(rx_active_buffer);
    ca0c:	2c 00 ec f2 	mova	&62188,	r12	;0x0f2ec
    ca10:	b0 13 24 bd 	calla	#48420		;0x0bd24

0000ca14 <.L109>:
        rx_active_buffer = elyNLGetBuffer();
    ca14:	b0 13 1a bd 	calla	#48410		;0x0bd1a

0000ca18 <.LVL108>:
    ca18:	60 0c ec f2 	mova	r12,	&62188	; 0x0f2ec

0000ca1c <.Loc.516.2>:
        if (NULL == rx_active_buffer) {
    ca1c:	9c 00 00 00 	cmpa	#0,	r12	;
    ca20:	04 20       	jnz	$+10     	;abs 0xca2a

0000ca22 <.Loc.518.2>:
          chDbgAssert(false, "bad juju");
    ca22:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    ca26:	b0 13 3e 46 	calla	#17982		;0x0463e

0000ca2a <.L110>:
        rx_hdr = true;
    ca2a:	41 18 d2 43 	movx.b	#1,	&0x10ce3;r3 As==01
    ca2e:	e3 0c 

0000ca30 <.Loc.521.2>:
        rx_pkt_len = elyNLHeaderLen;
    ca30:	40 18 b2 40 	movx.w	#6,	&0xff2e8;
    ca34:	06 00 e8 f2 

0000ca38 <.Loc.522.2>:
        rx_pkt_idx = 0;
    ca38:	40 18 82 43 	movx.w	#0,	&0xff2ea;r3 As==00
    ca3c:	ea f2 
    ca3e:	80 00 b4 c9 	mova	#51636,	r0	;0x0c9b4

0000ca42 <.L112>:
    else if (rx_pkt_len - rx_pkt_idx < 48) {
    ca42:	40 18 1d 42 	movx.w	&0x0f2e8,r13	;
    ca46:	e8 f2 
    ca48:	40 18 1c 42 	movx.w	&0x0f2ea,r12	;
    ca4c:	ea f2 
    ca4e:	40 18 0e 4d 	movx.w	r13,	r14	;
    ca52:	40 18 0e 8c 	subx.w	r12,	r14	;
    ca56:	7f 40 2f 00 	mov.b	#47,	r15	;#0x002f
    ca5a:	0f 9e       	cmp	r14,	r15	;
    ca5c:	06 28       	jnc	$+14     	;abs 0xca6a

0000ca5e <.Loc.543.2>:
      curr_threshold = rx_pkt_len - rx_pkt_idx;
    ca5e:	4d 8c       	sub.b	r12,	r13	;
    ca60:	40 18 c2 4d 	movx.b	r13,	&0xff2e5;
    ca64:	e5 f2 
    ca66:	80 00 ee c9 	mova	#51694,	r0	;0x0c9ee

0000ca6a <.L114>:
      curr_threshold = 48;
    ca6a:	40 18 f2 40 	movx.b	#48,	&0xff2e5;0x00030
    ca6e:	30 00 e5 f2 
    ca72:	80 00 ee c9 	mova	#51694,	r0	;0x0c9ee

0000ca76 <elyRFDLLTxInit>:

void elyRFDLLTxInit(SX1278Driver * devp) {
  chSysLock();
    ca76:	b0 13 a2 c1 	calla	#49570		;0x0c1a2

0000ca7a <.LVL111>:
  tf_len = ((uint16_t)(bank0p[RegDLLTFLengthMSB] << 8)) | ((uint16_t)(bank0p[RegDLLTFLengthLSB]));
    ca7a:	2e 01 40 08 	mova	&67648,	r14	;0x10840
    ca7e:	5c 4e c1 00 	mov.b	193(r14),r12	;0x000c1
    ca82:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    ca86:	5d 4e c0 00 	mov.b	192(r14),r13	;0x000c0
    ca8a:	0c dd       	bis	r13,	r12	;
    ca8c:	41 18 82 4c 	movx.w	r12,	&0x10ce8;
    ca90:	e8 0c 

0000ca92 <.Loc.588.2>:
  if (bank0p[RegDLLOptions] & BIT5) {
    ca92:	40 18 fe b0 	bitx.b	#32,	196(r14);0x00020, 0x000c4
    ca96:	20 00 c4 00 
    ca9a:	02 24       	jz	$+6      	;abs 0xcaa0

0000ca9c <.Loc.589.2>:
    tf_data_len = tf_len - 4;
    ca9c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

0000caa0 <.L125>:
  }
  else {
    tf_data_len = tf_len;
    caa0:	01 18 c2 4c 	movx.a	r12,	&0x10ce4;
    caa4:	e4 0c 

0000caa6 <.Loc.601.2>:
    /* TODO this depends on the FEC */
    sx1278SetSync(devp, 0x1ACFFC1D);
  }
#endif
  /* TODO data whitening, FARM */
  chSysUnlock();
    caa6:	b0 13 aa c1 	calla	#49578		;0x0c1aa

0000caaa <.LVL112>:
}
    caaa:	10 01       	reta			;

0000caac <elyRFDLLInitiateTransmit>:

void elyRFDLLInitiateTransmit(SX1278Driver * devp) {
    caac:	b1 00 04 00 	suba	#4,	r1	;

0000cab0 <.LCFI7>:
  
#if ELY_DISCRETE_PA_CTL
  palSetLine(LINE_PA_PC_EN);
    cab0:	40 18 b2 d0 	bisx.w	#4096,	&0x00222;0x01000
    cab4:	00 10 22 02 

0000cab8 <.Loc.610.2>:
#endif
  
  tf_idx = sx1278StartTransmit(devp, tf_len, tf_buffer, txlvl_callback, write_cb);
    cab8:	c0 18 1d 42 	movx.w	&0x10ce8,r13	;
    cabc:	e8 0c 
    cabe:	00 18 f1 40 	movx.a	#49620,	0(r1)	;0x0c1d4
    cac2:	d4 c1 00 00 
    cac6:	8f 00 c4 c1 	mova	#49604,	r15	;0x0c1c4
    caca:	8e 01 ea 0c 	mova	#68842,	r14	;0x10cea
    cace:	b0 13 0a 6c 	calla	#27658		;0x06c0a

0000cad2 <.LVL114>:
    cad2:	40 18 82 4c 	movx.w	r12,	&0xff2fa;
    cad6:	fa f2 

0000cad8 <.Loc.611.2>:
}
    cad8:	a1 00 04 00 	adda	#4,	r1	;
    cadc:	10 01       	reta			;

0000cade <elyRFDLLHandleTxFifo>:

void elyRFDLLHandleTxFifo(SX1278Driver * devp) {
    cade:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000cae0 <.LCFI8>:
    cae0:	b1 00 04 00 	suba	#4,	r1	;

0000cae4 <.LCFI9>:
  /* FIFO is sufficiently empty */
  uint8_t to_transmit = (tf_len - tf_idx <= 31 ? tf_len - tf_idx : 31);
    cae4:	40 18 19 42 	movx.w	&0x0f2fa,r9	;
    cae8:	fa f2 
    caea:	c0 18 1a 42 	movx.w	&0x10ce8,r10	;
    caee:	e8 0c 
    caf0:	0a 89       	sub	r9,	r10	;
    caf2:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f
    caf6:	0d 9a       	cmp	r10,	r13	;
    caf8:	01 2c       	jc	$+4      	;abs 0xcafc
    cafa:	0a 4d       	mov	r13,	r10	;

0000cafc <.L129>:
  chSysLock();
    cafc:	71 0c 00 00 	mova	r12,	0(r1)	;
    cb00:	b0 13 a2 c1 	calla	#49570		;0x0c1a2

0000cb04 <.LVL117>:
  sx1278FifoWriteAsyncS(devp, to_transmit, tf_buffer + tf_idx, write_cb);
    cb04:	40 18 0e 49 	movx.w	r9,	r14	;
    cb08:	8f 00 d4 c1 	mova	#49620,	r15	;0x0c1d4
    cb0c:	ae 01 ea 0c 	adda	#68842,	r14	;0x10cea
    cb10:	40 18 0d 4a 	movx.w	r10,	r13	;
    cb14:	0c 01       	mova	@r1,	r12	;
    cb16:	b0 13 46 6b 	calla	#27462		;0x06b46

0000cb1a <.LVL118>:
  tf_idx += to_transmit;
    cb1a:	40 18 82 5a 	addx.w	r10,	&0xff2fa;
    cb1e:	fa f2 

0000cb20 <.Loc.619.2>:
  chSysUnlock();
    cb20:	b0 13 aa c1 	calla	#49578		;0x0c1aa

0000cb24 <.LVL119>:
}
    cb24:	a1 00 04 00 	adda	#4,	r1	;
    cb28:	19 16       	popm.a	#2,	r10	;20-bit words
    cb2a:	10 01       	reta			;

0000cb2c <udivmodsi4>:
UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);
UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);

UINT_TYPE
C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)
{
    cb2c:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000cb2e <.LCFI0>:
    cb2e:	0a 4c       	mov	r12,	r10	;
    cb30:	0b 4d       	mov	r13,	r11	;

0000cb32 <.LVL1>:
  UINT_TYPE bit = 1;
  UINT_TYPE res = 0;

  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cb32:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000cb36 <.Loc.35.1>:
  UINT_TYPE bit = 1;
    cb36:	58 43       	mov.b	#1,	r8	;r3 As==01
    cb38:	49 43       	clr.b	r9		;

0000cb3a <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cb3a:	07 4b       	mov	r11,	r7	;

0000cb3c <.L2>:
    cb3c:	0f 9b       	cmp	r11,	r15	;
    cb3e:	11 28       	jnc	$+36     	;abs 0xcb62
    cb40:	07 9f       	cmp	r15,	r7	;
    cb42:	02 20       	jnz	$+6      	;abs 0xcb48
    cb44:	0e 9a       	cmp	r10,	r14	;
    cb46:	0d 28       	jnc	$+28     	;abs 0xcb62

0000cb48 <.L20>:
    cb48:	4c 43       	clr.b	r12		;

0000cb4a <.LVL3>:
    cb4a:	0d 4c       	mov	r12,	r13	;

0000cb4c <.L5>:
    {
      den <<= 1;
      bit <<= 1;
    }
  while (bit)
    cb4c:	07 48       	mov	r8,	r7	;
    cb4e:	07 d9       	bis	r9,	r7	;
    cb50:	07 93       	cmp	#0,	r7	;r3 As==00
    cb52:	1a 20       	jnz	$+54     	;abs 0xcb88

0000cb54 <.L6>:
	  res |= bit;
	}
      bit >>= 1;
      den >>= 1;
    }
  if (modwanted)
    cb54:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    cb58:	02 24       	jz	$+6      	;abs 0xcb5e
    cb5a:	0c 4a       	mov	r10,	r12	;
    cb5c:	0d 4b       	mov	r11,	r13	;

0000cb5e <.L1>:
    return num;
  return res;
}
    cb5e:	55 16       	popm.a	#6,	r10	;20-bit words
    cb60:	10 01       	reta			;

0000cb62 <.L3>:
    cb62:	3d 53       	add	#-1,	r13	;r3 As==11

0000cb64 <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    cb64:	0d 93       	cmp	#0,	r13	;r3 As==00
    cb66:	24 24       	jz	$+74     	;abs 0xcbb0

0000cb68 <.Loc.38.1>:
    cb68:	0f 93       	cmp	#0,	r15	;r3 As==00
    cb6a:	ee 3b       	jl	$-34     	;abs 0xcb48

0000cb6c <.Loc.40.1>:
      den <<= 1;
    cb6c:	05 4e       	mov	r14,	r5	;
    cb6e:	06 4f       	mov	r15,	r6	;
    cb70:	05 5e       	add	r14,	r5	;
    cb72:	06 6f       	addc	r15,	r6	;
    cb74:	0e 45       	mov	r5,	r14	;

0000cb76 <.LVL7>:
    cb76:	0f 46       	mov	r6,	r15	;

0000cb78 <.LVL8>:
      bit <<= 1;
    cb78:	05 48       	mov	r8,	r5	;
    cb7a:	06 49       	mov	r9,	r6	;
    cb7c:	05 58       	add	r8,	r5	;
    cb7e:	06 69       	addc	r9,	r6	;
    cb80:	08 45       	mov	r5,	r8	;

0000cb82 <.LVL9>:
    cb82:	09 46       	mov	r6,	r9	;

0000cb84 <.LVL10>:
    cb84:	80 00 3c cb 	mova	#52028,	r0	;0x0cb3c

0000cb88 <.L12>:
      if (num >= den)
    cb88:	0b 9f       	cmp	r15,	r11	;
    cb8a:	0a 28       	jnc	$+22     	;abs 0xcba0
    cb8c:	0f 9b       	cmp	r11,	r15	;
    cb8e:	02 20       	jnz	$+6      	;abs 0xcb94
    cb90:	0a 9e       	cmp	r14,	r10	;
    cb92:	06 28       	jnc	$+14     	;abs 0xcba0

0000cb94 <.L16>:
	  num -= den;
    cb94:	40 18 0a 8e 	subx.w	r14,	r10	;
    cb98:	40 18 0b 7f 	subcx.w	r15,	r11	;

0000cb9c <.Loc.48.1>:
	  res |= bit;
    cb9c:	0c d8       	bis	r8,	r12	;

0000cb9e <.LVL13>:
    cb9e:	0d d9       	bis	r9,	r13	;

0000cba0 <.L10>:
      bit >>= 1;
    cba0:	12 c3       	clrc			
    cba2:	09 10       	rrc	r9		;
    cba4:	08 10       	rrc	r8		;

0000cba6 <.Loc.51.1>:
      den >>= 1;
    cba6:	12 c3       	clrc			
    cba8:	0f 10       	rrc	r15		;
    cbaa:	0e 10       	rrc	r14		;
    cbac:	80 00 4c cb 	mova	#52044,	r0	;0x0cb4c

0000cbb0 <.L14>:
    cbb0:	0c 4d       	mov	r13,	r12	;

0000cbb2 <.LVL18>:
    cbb2:	80 00 54 cb 	mova	#52052,	r0	;0x0cb54

0000cbb6 <__mspabi_divlu>:
  return res;
}

UINT_TYPE
C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)
{
    cbb6:	b1 00 02 00 	suba	#2,	r1	;

0000cbba <.LCFI5>:
  return C3(udivmod,NAME_MODE,4) (a, b, 0);
    cbba:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    cbbe:	b0 13 2c cb 	calla	#52012		;0x0cb2c

0000cbc2 <.LVL46>:
}
    cbc2:	a1 00 02 00 	adda	#2,	r1	;
    cbc6:	10 01       	reta			;

0000cbc8 <__mspabi_slli_15>:
    cbc8:	0c 5c       	rla	r12		;

0000cbca <__mspabi_slli_14>:
    cbca:	0c 5c       	rla	r12		;

0000cbcc <__mspabi_slli_13>:
    cbcc:	0c 5c       	rla	r12		;

0000cbce <__mspabi_slli_12>:
    cbce:	0c 5c       	rla	r12		;

0000cbd0 <__mspabi_slli_11>:
    cbd0:	0c 5c       	rla	r12		;

0000cbd2 <__mspabi_slli_10>:
    cbd2:	0c 5c       	rla	r12		;

0000cbd4 <__mspabi_slli_9>:
    cbd4:	0c 5c       	rla	r12		;

0000cbd6 <__mspabi_slli_8>:
    cbd6:	0c 5c       	rla	r12		;

0000cbd8 <__mspabi_slli_7>:
    cbd8:	0c 5c       	rla	r12		;

0000cbda <__mspabi_slli_6>:
    cbda:	0c 5c       	rla	r12		;

0000cbdc <__mspabi_slli_5>:
    cbdc:	0c 5c       	rla	r12		;

0000cbde <__mspabi_slli_4>:
    cbde:	0c 5c       	rla	r12		;

0000cbe0 <__mspabi_slli_3>:
    cbe0:	0c 5c       	rla	r12		;

0000cbe2 <__mspabi_slli_2>:
    cbe2:	0c 5c       	rla	r12		;

0000cbe4 <__mspabi_slli_1>:
    cbe4:	0c 5c       	rla	r12		;
    cbe6:	10 01       	reta			;

0000cbe8 <.L11>:
    cbe8:	3d 53       	add	#-1,	r13	;r3 As==11
    cbea:	0c 5c       	rla	r12		;

0000cbec <__mspabi_slli>:
    cbec:	0d 93       	cmp	#0,	r13	;r3 As==00
    cbee:	fc 23       	jnz	$-6      	;abs 0xcbe8
    cbf0:	10 01       	reta			;

0000cbf2 <__mspabi_slll_15>:
    cbf2:	0c 5c       	rla	r12		;
    cbf4:	0d 6d       	rlc	r13		;

0000cbf6 <__mspabi_slll_14>:
    cbf6:	0c 5c       	rla	r12		;
    cbf8:	0d 6d       	rlc	r13		;

0000cbfa <__mspabi_slll_13>:
    cbfa:	0c 5c       	rla	r12		;
    cbfc:	0d 6d       	rlc	r13		;

0000cbfe <__mspabi_slll_12>:
    cbfe:	0c 5c       	rla	r12		;
    cc00:	0d 6d       	rlc	r13		;

0000cc02 <__mspabi_slll_11>:
    cc02:	0c 5c       	rla	r12		;
    cc04:	0d 6d       	rlc	r13		;

0000cc06 <__mspabi_slll_10>:
    cc06:	0c 5c       	rla	r12		;
    cc08:	0d 6d       	rlc	r13		;

0000cc0a <__mspabi_slll_9>:
    cc0a:	0c 5c       	rla	r12		;
    cc0c:	0d 6d       	rlc	r13		;

0000cc0e <__mspabi_slll_8>:
    cc0e:	0c 5c       	rla	r12		;
    cc10:	0d 6d       	rlc	r13		;

0000cc12 <__mspabi_slll_7>:
    cc12:	0c 5c       	rla	r12		;
    cc14:	0d 6d       	rlc	r13		;

0000cc16 <__mspabi_slll_6>:
    cc16:	0c 5c       	rla	r12		;
    cc18:	0d 6d       	rlc	r13		;

0000cc1a <__mspabi_slll_5>:
    cc1a:	0c 5c       	rla	r12		;
    cc1c:	0d 6d       	rlc	r13		;

0000cc1e <__mspabi_slll_4>:
    cc1e:	0c 5c       	rla	r12		;
    cc20:	0d 6d       	rlc	r13		;

0000cc22 <__mspabi_slll_3>:
    cc22:	0c 5c       	rla	r12		;
    cc24:	0d 6d       	rlc	r13		;

0000cc26 <__mspabi_slll_2>:
    cc26:	0c 5c       	rla	r12		;
    cc28:	0d 6d       	rlc	r13		;

0000cc2a <__mspabi_slll_1>:
    cc2a:	0c 5c       	rla	r12		;
    cc2c:	0d 6d       	rlc	r13		;
    cc2e:	10 01       	reta			;

0000cc30 <.L12>:
    cc30:	3e 53       	add	#-1,	r14	;r3 As==11
    cc32:	0c 5c       	rla	r12		;
    cc34:	0d 6d       	rlc	r13		;

0000cc36 <__mspabi_slll>:
    cc36:	0e 93       	cmp	#0,	r14	;r3 As==00
    cc38:	fb 23       	jnz	$-8      	;abs 0xcc30
    cc3a:	10 01       	reta			;

0000cc3c <__mspabi_srai_15>:
    cc3c:	0c 11       	rra	r12		;

0000cc3e <__mspabi_srai_14>:
    cc3e:	0c 11       	rra	r12		;

0000cc40 <__mspabi_srai_13>:
    cc40:	0c 11       	rra	r12		;

0000cc42 <__mspabi_srai_12>:
    cc42:	0c 11       	rra	r12		;

0000cc44 <__mspabi_srai_11>:
    cc44:	0c 11       	rra	r12		;

0000cc46 <__mspabi_srai_10>:
    cc46:	0c 11       	rra	r12		;

0000cc48 <__mspabi_srai_9>:
    cc48:	0c 11       	rra	r12		;

0000cc4a <__mspabi_srai_8>:
    cc4a:	0c 11       	rra	r12		;

0000cc4c <__mspabi_srai_7>:
    cc4c:	0c 11       	rra	r12		;

0000cc4e <__mspabi_srai_6>:
    cc4e:	0c 11       	rra	r12		;

0000cc50 <__mspabi_srai_5>:
    cc50:	0c 11       	rra	r12		;

0000cc52 <__mspabi_srai_4>:
    cc52:	0c 11       	rra	r12		;

0000cc54 <__mspabi_srai_3>:
    cc54:	0c 11       	rra	r12		;

0000cc56 <__mspabi_srai_2>:
    cc56:	0c 11       	rra	r12		;

0000cc58 <__mspabi_srai_1>:
    cc58:	0c 11       	rra	r12		;
    cc5a:	10 01       	reta			;

0000cc5c <.L11>:
    cc5c:	3d 53       	add	#-1,	r13	;r3 As==11
    cc5e:	0c 11       	rra	r12		;

0000cc60 <__mspabi_srai>:
    cc60:	0d 93       	cmp	#0,	r13	;r3 As==00
    cc62:	fc 23       	jnz	$-6      	;abs 0xcc5c
    cc64:	10 01       	reta			;

0000cc66 <__mspabi_sral_15>:
    cc66:	0d 11       	rra	r13		;
    cc68:	0c 10       	rrc	r12		;

0000cc6a <__mspabi_sral_14>:
    cc6a:	0d 11       	rra	r13		;
    cc6c:	0c 10       	rrc	r12		;

0000cc6e <__mspabi_sral_13>:
    cc6e:	0d 11       	rra	r13		;
    cc70:	0c 10       	rrc	r12		;

0000cc72 <__mspabi_sral_12>:
    cc72:	0d 11       	rra	r13		;
    cc74:	0c 10       	rrc	r12		;

0000cc76 <__mspabi_sral_11>:
    cc76:	0d 11       	rra	r13		;
    cc78:	0c 10       	rrc	r12		;

0000cc7a <__mspabi_sral_10>:
    cc7a:	0d 11       	rra	r13		;
    cc7c:	0c 10       	rrc	r12		;

0000cc7e <__mspabi_sral_9>:
    cc7e:	0d 11       	rra	r13		;
    cc80:	0c 10       	rrc	r12		;

0000cc82 <__mspabi_sral_8>:
    cc82:	0d 11       	rra	r13		;
    cc84:	0c 10       	rrc	r12		;

0000cc86 <__mspabi_sral_7>:
    cc86:	0d 11       	rra	r13		;
    cc88:	0c 10       	rrc	r12		;

0000cc8a <__mspabi_sral_6>:
    cc8a:	0d 11       	rra	r13		;
    cc8c:	0c 10       	rrc	r12		;

0000cc8e <__mspabi_sral_5>:
    cc8e:	0d 11       	rra	r13		;
    cc90:	0c 10       	rrc	r12		;

0000cc92 <__mspabi_sral_4>:
    cc92:	0d 11       	rra	r13		;
    cc94:	0c 10       	rrc	r12		;

0000cc96 <__mspabi_sral_3>:
    cc96:	0d 11       	rra	r13		;
    cc98:	0c 10       	rrc	r12		;

0000cc9a <__mspabi_sral_2>:
    cc9a:	0d 11       	rra	r13		;
    cc9c:	0c 10       	rrc	r12		;

0000cc9e <__mspabi_sral_1>:
    cc9e:	0d 11       	rra	r13		;
    cca0:	0c 10       	rrc	r12		;
    cca2:	10 01       	reta			;

0000cca4 <.L12>:
    cca4:	3e 53       	add	#-1,	r14	;r3 As==11
    cca6:	0d 11       	rra	r13		;
    cca8:	0c 10       	rrc	r12		;

0000ccaa <__mspabi_sral>:
    ccaa:	0e 93       	cmp	#0,	r14	;r3 As==00
    ccac:	fb 23       	jnz	$-8      	;abs 0xcca4
    ccae:	10 01       	reta			;

0000ccb0 <__mspabi_srli_15>:
    ccb0:	12 c3       	clrc			
    ccb2:	0c 10       	rrc	r12		;

0000ccb4 <__mspabi_srli_14>:
    ccb4:	12 c3       	clrc			
    ccb6:	0c 10       	rrc	r12		;

0000ccb8 <__mspabi_srli_13>:
    ccb8:	12 c3       	clrc			
    ccba:	0c 10       	rrc	r12		;

0000ccbc <__mspabi_srli_12>:
    ccbc:	12 c3       	clrc			
    ccbe:	0c 10       	rrc	r12		;

0000ccc0 <__mspabi_srli_11>:
    ccc0:	12 c3       	clrc			
    ccc2:	0c 10       	rrc	r12		;

0000ccc4 <__mspabi_srli_10>:
    ccc4:	12 c3       	clrc			
    ccc6:	0c 10       	rrc	r12		;

0000ccc8 <__mspabi_srli_9>:
    ccc8:	12 c3       	clrc			
    ccca:	0c 10       	rrc	r12		;

0000cccc <__mspabi_srli_8>:
    cccc:	12 c3       	clrc			
    ccce:	0c 10       	rrc	r12		;

0000ccd0 <__mspabi_srli_7>:
    ccd0:	12 c3       	clrc			
    ccd2:	0c 10       	rrc	r12		;

0000ccd4 <__mspabi_srli_6>:
    ccd4:	12 c3       	clrc			
    ccd6:	0c 10       	rrc	r12		;

0000ccd8 <__mspabi_srli_5>:
    ccd8:	12 c3       	clrc			
    ccda:	0c 10       	rrc	r12		;

0000ccdc <__mspabi_srli_4>:
    ccdc:	12 c3       	clrc			
    ccde:	0c 10       	rrc	r12		;

0000cce0 <__mspabi_srli_3>:
    cce0:	12 c3       	clrc			
    cce2:	0c 10       	rrc	r12		;

0000cce4 <__mspabi_srli_2>:
    cce4:	12 c3       	clrc			
    cce6:	0c 10       	rrc	r12		;

0000cce8 <__mspabi_srli_1>:
    cce8:	12 c3       	clrc			
    ccea:	0c 10       	rrc	r12		;
    ccec:	10 01       	reta			;

0000ccee <.L11>:
    ccee:	3d 53       	add	#-1,	r13	;r3 As==11
    ccf0:	12 c3       	clrc			
    ccf2:	0c 10       	rrc	r12		;

0000ccf4 <__mspabi_srli>:
    ccf4:	0d 93       	cmp	#0,	r13	;r3 As==00
    ccf6:	fb 23       	jnz	$-8      	;abs 0xccee
    ccf8:	10 01       	reta			;

0000ccfa <__mspabi_srll_15>:
    ccfa:	12 c3       	clrc			
    ccfc:	0d 10       	rrc	r13		;
    ccfe:	0c 10       	rrc	r12		;

0000cd00 <__mspabi_srll_14>:
    cd00:	12 c3       	clrc			
    cd02:	0d 10       	rrc	r13		;
    cd04:	0c 10       	rrc	r12		;

0000cd06 <__mspabi_srll_13>:
    cd06:	12 c3       	clrc			
    cd08:	0d 10       	rrc	r13		;
    cd0a:	0c 10       	rrc	r12		;

0000cd0c <__mspabi_srll_12>:
    cd0c:	12 c3       	clrc			
    cd0e:	0d 10       	rrc	r13		;
    cd10:	0c 10       	rrc	r12		;

0000cd12 <__mspabi_srll_11>:
    cd12:	12 c3       	clrc			
    cd14:	0d 10       	rrc	r13		;
    cd16:	0c 10       	rrc	r12		;

0000cd18 <__mspabi_srll_10>:
    cd18:	12 c3       	clrc			
    cd1a:	0d 10       	rrc	r13		;
    cd1c:	0c 10       	rrc	r12		;

0000cd1e <__mspabi_srll_9>:
    cd1e:	12 c3       	clrc			
    cd20:	0d 10       	rrc	r13		;
    cd22:	0c 10       	rrc	r12		;

0000cd24 <__mspabi_srll_8>:
    cd24:	12 c3       	clrc			
    cd26:	0d 10       	rrc	r13		;
    cd28:	0c 10       	rrc	r12		;

0000cd2a <__mspabi_srll_7>:
    cd2a:	12 c3       	clrc			
    cd2c:	0d 10       	rrc	r13		;
    cd2e:	0c 10       	rrc	r12		;

0000cd30 <__mspabi_srll_6>:
    cd30:	12 c3       	clrc			
    cd32:	0d 10       	rrc	r13		;
    cd34:	0c 10       	rrc	r12		;

0000cd36 <__mspabi_srll_5>:
    cd36:	12 c3       	clrc			
    cd38:	0d 10       	rrc	r13		;
    cd3a:	0c 10       	rrc	r12		;

0000cd3c <__mspabi_srll_4>:
    cd3c:	12 c3       	clrc			
    cd3e:	0d 10       	rrc	r13		;
    cd40:	0c 10       	rrc	r12		;

0000cd42 <__mspabi_srll_3>:
    cd42:	12 c3       	clrc			
    cd44:	0d 10       	rrc	r13		;
    cd46:	0c 10       	rrc	r12		;

0000cd48 <__mspabi_srll_2>:
    cd48:	12 c3       	clrc			
    cd4a:	0d 10       	rrc	r13		;
    cd4c:	0c 10       	rrc	r12		;

0000cd4e <__mspabi_srll_1>:
    cd4e:	12 c3       	clrc			
    cd50:	0d 10       	rrc	r13		;
    cd52:	0c 10       	rrc	r12		;
    cd54:	10 01       	reta			;

0000cd56 <.L12>:
    cd56:	3e 53       	add	#-1,	r14	;r3 As==11
    cd58:	12 c3       	clrc			
    cd5a:	0d 10       	rrc	r13		;
    cd5c:	0c 10       	rrc	r12		;

0000cd5e <__mspabi_srll>:
    cd5e:	0e 93       	cmp	#0,	r14	;r3 As==00
    cd60:	fa 23       	jnz	$-10     	;abs 0xcd56
    cd62:	10 01       	reta			;

0000cd64 <__cmpsi2>:
    cd64:	0f 9d       	cmp	r13,	r15	;
    cd66:	05 24       	jz	$+12     	;abs 0xcd72
    cd68:	02 34       	jge	$+6      	;abs 0xcd6e

0000cd6a <.L_greater_than>:
    cd6a:	2c 43       	mov	#2,	r12	;r3 As==10
    cd6c:	10 01       	reta			;

0000cd6e <.L_less_than>:
    cd6e:	0c 43       	clr	r12		;
    cd70:	10 01       	reta			;

0000cd72 <.L_compare_low>:
    cd72:	0e 9c       	cmp	r12,	r14	;
    cd74:	fa 3b       	jl	$-10     	;abs 0xcd6a
    cd76:	fb 23       	jnz	$-8      	;abs 0xcd6e
    cd78:	1c 43       	mov	#1,	r12	;r3 As==01
    cd7a:	10 01       	reta			;

0000cd7c <__ucmpsi2>:
    cd7c:	0d 93       	cmp	#0,	r13	;r3 As==00
    cd7e:	03 30       	jn	$+8      	;abs 0xcd86
    cd80:	0f 93       	cmp	#0,	r15	;r3 As==00
    cd82:	f5 33       	jn	$-20     	;abs 0xcd6e
    cd84:	ef 2f       	jc	$-32     	;abs 0xcd64

0000cd86 <.L_top_bit_set_in_A>:
    cd86:	0f 93       	cmp	#0,	r15	;r3 As==00
    cd88:	ed 33       	jn	$-36     	;abs 0xcd64
    cd8a:	ef 2f       	jc	$-32     	;abs 0xcd6a

0000cd8c <__mspabi_mpyi>:
    cd8c:	02 12       	push	r2		;
    cd8e:	32 c2       	dint			
    cd90:	03 43       	nop			
    cd92:	82 4c c0 04 	mov	r12,	&0x04c0	;
    cd96:	82 4d c8 04 	mov	r13,	&0x04c8	;
    cd9a:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    cd9e:	32 41       	pop	r2		;
    cda0:	10 01       	reta			;

0000cda2 <__mspabi_mpyl>:
    cda2:	02 12       	push	r2		;
    cda4:	32 c2       	dint			
    cda6:	03 43       	nop			
    cda8:	82 4c d0 04 	mov	r12,	&0x04d0	;
    cdac:	82 4d d2 04 	mov	r13,	&0x04d2	;
    cdb0:	82 4e e0 04 	mov	r14,	&0x04e0	;
    cdb4:	82 4f e2 04 	mov	r15,	&0x04e2	;
    cdb8:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    cdbc:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    cdc0:	32 41       	pop	r2		;
    cdc2:	10 01       	reta			;

0000cdc4 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
    cdc4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cdc6 <.LCFI0>:
    cdc6:	ca 0c       	mova	r12,	r10	;
    cdc8:	ee 0c       	adda	r12,	r14	;

0000cdca <.L2>:
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  _PTR save = dst0;

  while (len0--)
    cdca:	da 0e       	cmpa	r14,	r10	;
    cdcc:	08 24       	jz	$+18     	;abs 0xcdde

0000cdce <.LVL3>:
    {
      *dst++ = *src++;
    cdce:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    cdd2:	aa 00 01 00 	adda	#1,	r10	;

0000cdd6 <.LVL4>:
    cdd6:	ad 00 01 00 	adda	#1,	r13	;
    cdda:	80 00 ca cd 	mova	#52682,	r0	;0x0cdca

0000cdde <.L5>:
  while (len0--)
    *dst++ = *src++;

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
    cdde:	0a 16       	popm.a	#1,	r10	;20-bit words
    cde0:	10 01       	reta			;

0000cde2 <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
    cde2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cde4 <.LCFI0>:
    cde4:	08 14       	pushm.a	#1,	r8	;20-bit words

0000cde6 <.LCFI1>:
    cde6:	06 14       	pushm.a	#1,	r6	;20-bit words

0000cde8 <.LCFI2>:
    cde8:	c8 0c       	mova	r12,	r8	;
    cdea:	e8 0e       	adda	r14,	r8	;

0000cdec <.Loc.69.1>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dst = dst_void;
  _CONST char *src = src_void;

  if (src < dst && dst < src + length)
    cdec:	dd 0c       	cmpa	r12,	r13	;
    cdee:	04 28       	jnc	$+10     	;abs 0xcdf8

0000cdf0 <.L4>:
    cdf0:	ce 0c       	mova	r12,	r14	;

0000cdf2 <.LVL2>:
    cdf2:	ca 0d       	mova	r13,	r10	;
    cdf4:	80 00 1c ce 	mova	#52764,	r0	;0x0ce1c

0000cdf8 <.L2>:
    cdf8:	ca 0d       	mova	r13,	r10	;
    cdfa:	ea 0e       	adda	r14,	r10	;
    cdfc:	dc 0a       	cmpa	r10,	r12	;
    cdfe:	f8 2f       	jc	$-14     	;abs 0xcdf0

0000ce00 <.LVL4>:
    ce00:	fe 0a       	suba	r10,	r14	;

0000ce02 <.L5>:
    ce02:	c6 0a       	mova	r10,	r6	;
    ce04:	e6 0e       	adda	r14,	r6	;

0000ce06 <.Loc.74.1>:
    {
      /* Have to copy backwards */
      src += length;
      dst += length;
      while (length--)
    ce06:	96 00 00 00 	cmpa	#0,	r6	;
    ce0a:	12 24       	jz	$+38     	;abs 0xce30

0000ce0c <.Loc.76.1>:
	{
	  *--dst = *--src;
    ce0c:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    ce10:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000ce14 <.LVL7>:
    ce14:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    ce18:	80 00 02 ce 	mova	#52738,	r0	;0x0ce02

0000ce1c <.L3>:
	}
    }
  else
    {
      while (length--)
    ce1c:	d8 0e       	cmpa	r14,	r8	;
    ce1e:	08 24       	jz	$+18     	;abs 0xce30

0000ce20 <.LVL9>:
	{
	  *dst++ = *src++;
    ce20:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    ce24:	ae 00 01 00 	adda	#1,	r14	;

0000ce28 <.LVL10>:
    ce28:	aa 00 01 00 	adda	#1,	r10	;
    ce2c:	80 00 1c ce 	mova	#52764,	r0	;0x0ce1c

0000ce30 <.L9>:
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
    ce30:	06 16       	popm.a	#1,	r6	;20-bit words
    ce32:	08 16       	popm.a	#1,	r8	;20-bit words
    ce34:	0a 16       	popm.a	#1,	r10	;20-bit words
    ce36:	10 01       	reta			;

0000ce38 <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
    ce38:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ce3a <.LCFI0>:
    ce3a:	ca 0c       	mova	r12,	r10	;
    ce3c:	ee 0c       	adda	r12,	r14	;

0000ce3e <.L2>:
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
    ce3e:	da 0e       	cmpa	r14,	r10	;
    ce40:	06 24       	jz	$+14     	;abs 0xce4e

0000ce42 <.LVL3>:
    *s++ = (char) c;
    ce42:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    ce46:	aa 00 01 00 	adda	#1,	r10	;

0000ce4a <.LVL4>:
    ce4a:	80 00 3e ce 	mova	#52798,	r0	;0x0ce3e

0000ce4e <.L5>:

  return m;
}
    ce4e:	0a 16       	popm.a	#1,	r10	;20-bit words
    ce50:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000f2fc <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    f2fc:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f2fe <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    f2fe:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f302:	48 15 

0000f304 <.LBB12>:
  chSysTimerHandlerI();
    f304:	b0 13 4e 46 	calla	#17998		;0x0464e

0000f308 <.LBE12>:
  OSAL_IRQ_EPILOGUE();
    f308:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f30c:	48 15 
    f30e:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f312 <.LVL1>:
    f312:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f314:	02 24       	jz	$+6      	;abs 0xf31a

0000f316 <.Loc.174.1>:
    f316:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f31a <.L1>:
}
    f31a:	b4 16       	popm.a	#12,	r15	;20-bit words
    f31c:	00 13       	reti			

0000f31e <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    f31e:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f320 <.LCFI0>:
    f320:	b1 00 04 00 	suba	#4,	r1	;

0000f324 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f324:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f328:	48 15 

0000f32a <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    f32a:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    f32e:	0e 02 

0000f330 <.LVL0>:
    f330:	12 c3       	clrc			
    f332:	0c 10       	rrc	r12		;

0000f334 <.LVL1>:
    f334:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f336 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    f336:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f33a:	0d 43       	clr	r13		;
    f33c:	0e 4c       	mov	r12,	r14	;
    f33e:	0f 4d       	mov	r13,	r15	;
    f340:	0e 5e       	rla	r14		;
    f342:	0f 6f       	rlc	r15		;
    f344:	0e 5e       	rla	r14		;
    f346:	0f 6f       	rlc	r15		;
    f348:	81 4e 00 00 	mov	r14,	0(r1)	;
    f34c:	81 4f 02 00 	mov	r15,	2(r1)	;
    f350:	0d 01       	mova	@r1,	r13	;
    f352:	80 18 5c 4d 	movx.a	70986(r13),r12	;0x1154a
    f356:	4a 15 

0000f358 <.LVL2>:
  if (cb != NULL) {
    f358:	9c 00 00 00 	cmpa	#0,	r12	;
    f35c:	01 24       	jz	$+4      	;abs 0xf360

0000f35e <.Loc.81.1>:
    (*cb)();
    f35e:	4c 13       	calla	r12		;

0000f360 <.L2>:
  OSAL_IRQ_EPILOGUE();
    f360:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f364:	48 15 
    f366:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f36a <.LVL4>:
    f36a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f36c:	02 24       	jz	$+6      	;abs 0xf372

0000f36e <.Loc.84.1>:
    f36e:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f372 <.L1>:
}
    f372:	a1 00 04 00 	adda	#4,	r1	;
    f376:	b4 16       	popm.a	#12,	r15	;20-bit words
    f378:	00 13       	reti			

0000f37a <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    f37a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f37c <.LCFI2>:
    f37c:	b1 00 04 00 	suba	#4,	r1	;

0000f380 <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    f380:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f384:	48 15 

0000f386 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    f386:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    f38a:	1e 02 

0000f38c <.LVL6>:
    f38c:	12 c3       	clrc			
    f38e:	0c 10       	rrc	r12		;

0000f390 <.LVL7>:
    f390:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f392 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    f392:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f396:	4c 0e       	rlam.a	#4,	r12	;
    f398:	4c 0d       	rram.a	#4,	r12	;
    f39a:	ac 00 08 00 	adda	#8,	r12	;
    f39e:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f3a0:	40 18 3c 41 	popx.w	r12		;
    f3a4:	40 18 3d 41 	popx.w	r13		;
    f3a8:	0e 4c       	mov	r12,	r14	;
    f3aa:	0f 4d       	mov	r13,	r15	;
    f3ac:	0e 5e       	rla	r14		;
    f3ae:	0f 6f       	rlc	r15		;
    f3b0:	0e 5e       	rla	r14		;
    f3b2:	0f 6f       	rlc	r15		;
    f3b4:	81 4e 00 00 	mov	r14,	0(r1)	;
    f3b8:	81 4f 02 00 	mov	r15,	2(r1)	;
    f3bc:	0d 01       	mova	@r1,	r13	;
    f3be:	80 18 5c 4d 	movx.a	70986(r13),r12	;0x1154a
    f3c2:	4a 15 

0000f3c4 <.LVL8>:
  if (cb != NULL) {
    f3c4:	9c 00 00 00 	cmpa	#0,	r12	;
    f3c8:	01 24       	jz	$+4      	;abs 0xf3cc

0000f3ca <.Loc.99.1>:
    (*cb)();
    f3ca:	4c 13       	calla	r12		;

0000f3cc <.L11>:
  OSAL_IRQ_EPILOGUE();
    f3cc:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f3d0:	48 15 
    f3d2:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f3d6 <.LVL10>:
    f3d6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f3d8:	02 24       	jz	$+6      	;abs 0xf3de

0000f3da <.Loc.102.1>:
    f3da:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f3de <.L10>:
}
    f3de:	a1 00 04 00 	adda	#4,	r1	;
    f3e2:	b4 16       	popm.a	#12,	r15	;20-bit words
    f3e4:	00 13       	reti			

0000f3e6 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    f3e6:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f3e8 <.LCFI4>:
    f3e8:	b1 00 04 00 	suba	#4,	r1	;

0000f3ec <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    f3ec:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f3f0:	48 15 

0000f3f2 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    f3f2:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    f3f6:	2e 02 

0000f3f8 <.LVL12>:
    f3f8:	12 c3       	clrc			
    f3fa:	0c 10       	rrc	r12		;

0000f3fc <.LVL13>:
    f3fc:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f3fe <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    f3fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f402:	4c 0e       	rlam.a	#4,	r12	;
    f404:	4c 0d       	rram.a	#4,	r12	;
    f406:	ac 00 10 00 	adda	#16,	r12	;0x00010
    f40a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f40c:	40 18 3c 41 	popx.w	r12		;
    f410:	40 18 3d 41 	popx.w	r13		;
    f414:	0e 4c       	mov	r12,	r14	;
    f416:	0f 4d       	mov	r13,	r15	;
    f418:	0e 5e       	rla	r14		;
    f41a:	0f 6f       	rlc	r15		;
    f41c:	0e 5e       	rla	r14		;
    f41e:	0f 6f       	rlc	r15		;
    f420:	81 4e 00 00 	mov	r14,	0(r1)	;
    f424:	81 4f 02 00 	mov	r15,	2(r1)	;
    f428:	0d 01       	mova	@r1,	r13	;
    f42a:	80 18 5c 4d 	movx.a	70986(r13),r12	;0x1154a
    f42e:	4a 15 

0000f430 <.LVL14>:
  if (cb != NULL) {
    f430:	9c 00 00 00 	cmpa	#0,	r12	;
    f434:	01 24       	jz	$+4      	;abs 0xf438

0000f436 <.Loc.118.1>:
    (*cb)();
    f436:	4c 13       	calla	r12		;

0000f438 <.L20>:
  OSAL_IRQ_EPILOGUE();
    f438:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f43c:	48 15 
    f43e:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f442 <.LVL16>:
    f442:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f444:	02 24       	jz	$+6      	;abs 0xf44a

0000f446 <.Loc.121.1>:
    f446:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f44a <.L19>:
}
    f44a:	a1 00 04 00 	adda	#4,	r1	;
    f44e:	b4 16       	popm.a	#12,	r15	;20-bit words
    f450:	00 13       	reti			

0000f452 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    f452:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f454 <.LCFI6>:
    f454:	b1 00 04 00 	suba	#4,	r1	;

0000f458 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    f458:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f45c:	48 15 

0000f45e <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    f45e:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    f462:	3e 02 

0000f464 <.LVL18>:
    f464:	12 c3       	clrc			
    f466:	0c 10       	rrc	r12		;

0000f468 <.LVL19>:
    f468:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000f46a <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    f46a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    f46e:	4c 0e       	rlam.a	#4,	r12	;
    f470:	4c 0d       	rram.a	#4,	r12	;
    f472:	ac 00 18 00 	adda	#24,	r12	;0x00018
    f476:	0c 14       	pushm.a	#1,	r12	;20-bit words
    f478:	40 18 3c 41 	popx.w	r12		;
    f47c:	40 18 3d 41 	popx.w	r13		;
    f480:	0e 4c       	mov	r12,	r14	;
    f482:	0f 4d       	mov	r13,	r15	;
    f484:	0e 5e       	rla	r14		;
    f486:	0f 6f       	rlc	r15		;
    f488:	0e 5e       	rla	r14		;
    f48a:	0f 6f       	rlc	r15		;
    f48c:	81 4e 00 00 	mov	r14,	0(r1)	;
    f490:	81 4f 02 00 	mov	r15,	2(r1)	;
    f494:	0d 01       	mova	@r1,	r13	;
    f496:	80 18 5c 4d 	movx.a	70986(r13),r12	;0x1154a
    f49a:	4a 15 

0000f49c <.LVL20>:
  if (cb != NULL) {
    f49c:	9c 00 00 00 	cmpa	#0,	r12	;
    f4a0:	01 24       	jz	$+4      	;abs 0xf4a4

0000f4a2 <.Loc.136.1>:
    (*cb)();
    f4a2:	4c 13       	calla	r12		;

0000f4a4 <.L29>:
  OSAL_IRQ_EPILOGUE();
    f4a4:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f4a8:	48 15 
    f4aa:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f4ae <.LVL22>:
    f4ae:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f4b0:	02 24       	jz	$+6      	;abs 0xf4b6

0000f4b2 <.Loc.139.1>:
    f4b2:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f4b6 <.L28>:
}
    f4b6:	a1 00 04 00 	adda	#4,	r1	;
    f4ba:	b4 16       	popm.a	#12,	r15	;20-bit words
    f4bc:	00 13       	reti			

0000f4be <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    f4be:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f4c0 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f4c0:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f4c4:	48 15 

0000f4c6 <.Loc.75.1>:
  index = (DMAIV >> 1) - 1;
    f4c6:	40 18 18 42 	movx.w	&0x0050e,r8	;
    f4ca:	0e 05 
    f4cc:	12 c3       	clrc			
    f4ce:	08 10       	rrc	r8		;
    f4d0:	78 53       	add.b	#-1,	r8	;r3 As==11
    f4d2:	49 48       	mov.b	r8,	r9	;

0000f4d4 <.LVL6>:
  if (index < MSP430X_DMA_CHANNELS) {
    f4d4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    f4d6:	4c 98       	cmp.b	r8,	r12	;
    f4d8:	30 28       	jnc	$+98     	;abs 0xf53a

0000f4da <.LBB14>:
    dma_regs[index].ctl &= ~DMAEN;
    f4da:	4c 48       	mov.b	r8,	r12	;
    f4dc:	0d 43       	clr	r13		;
    f4de:	b0 13 1e cc 	calla	#52254		;0x0cc1e
    f4e2:	0d 12       	push	r13		;
    f4e4:	0c 12       	push	r12		;
    f4e6:	0a 16       	popm.a	#1,	r10	;20-bit words
    f4e8:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    f4ec:	ba f0 ef ff 	and	#-17,	0(r10)	;#0xffef
    f4f0:	00 00 

0000f4f2 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    f4f2:	4d 43       	clr.b	r13		;
    f4f4:	4c 48       	mov.b	r8,	r12	;
    f4f6:	b0 13 7a 54 	calla	#21626		;0x0547a

0000f4fa <.LVL8>:
    dma_regs[index].sz  = 0;
    f4fa:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000f4fe <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    f4fe:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    f502:	00 00 

0000f504 <.Loc.87.1>:
    if (cb->callback != NULL) {
    f504:	8a 00 d2 cf 	mova	#53202,	r10	;0x0cfd2
    f508:	08 49       	mov	r9,	r8	;
    f50a:	09 43       	clr	r9		;

0000f50c <.LVL10>:
    f50c:	0c 48       	mov	r8,	r12	;
    f50e:	0d 49       	mov	r9,	r13	;
    f510:	b0 13 22 cc 	calla	#52258		;0x0cc22
    f514:	0d 12       	push	r13		;
    f516:	0c 12       	push	r12		;
    f518:	0c 16       	popm.a	#1,	r12	;20-bit words
    f51a:	ec 0a       	adda	r10,	r12	;
    f51c:	06 0c       	mova	@r12,	r6	;
    f51e:	96 00 00 00 	cmpa	#0,	r6	;
    f522:	0b 24       	jz	$+24     	;abs 0xf53a

0000f524 <.Loc.88.1>:
      cb->callback(cb->args);
    f524:	0c 48       	mov	r8,	r12	;
    f526:	0d 49       	mov	r9,	r13	;
    f528:	b0 13 22 cc 	calla	#52258		;0x0cc22
    f52c:	0d 12       	push	r13		;
    f52e:	0c 12       	push	r12		;
    f530:	0c 16       	popm.a	#1,	r12	;20-bit words
    f532:	ea 0c       	adda	r12,	r10	;
    f534:	3c 0a 04 00 	mova	4(r10),	r12	;
    f538:	46 13       	calla	r6		;

0000f53a <.L4>:
  OSAL_IRQ_EPILOGUE();
    f53a:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f53e:	48 15 
    f540:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f544 <.LVL14>:
    f544:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f546:	02 24       	jz	$+6      	;abs 0xf54c

0000f548 <.Loc.92.1>:
    f548:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f54c <.L2>:
}
    f54c:	b4 16       	popm.a	#12,	r15	;20-bit words
    f54e:	00 13       	reti			

0000f550 <ISR_USCI_B0_VECTOR>:
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    f550:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f552 <.LCFI23>:
  OSAL_IRQ_PROLOGUE();
    f552:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f556:	48 15 

0000f558 <.Loc.110.1>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f558:	40 18 1c 42 	movx.w	&0x0066e,r12	;
    f55c:	6e 06 
    f55e:	8a 01 24 16 	mova	#71204,	r10	;0x11624
    f562:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    f566:	74 24       	jz	$+234    	;abs 0xf650
    f568:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    f56c:	0d 9c       	cmp	r12,	r13	;
    f56e:	60 28       	jnc	$+194    	;abs 0xf630
    f570:	3c 90 06 00 	cmp	#6,	r12	;
    f574:	6d 24       	jz	$+220    	;abs 0xf650
    f576:	7d 40 06 00 	mov.b	#6,	r13	;
    f57a:	0d 9c       	cmp	r12,	r13	;
    f57c:	3e 28       	jnc	$+126    	;abs 0xf5fa
    f57e:	2c 93       	cmp	#2,	r12	;r3 As==10
    f580:	8a 24       	jz	$+278    	;abs 0xf696
    f582:	2c 92       	cmp	#4,	r12	;r2 As==10
    f584:	8c 24       	jz	$+282    	;abs 0xf69e

0000f586 <.L113>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    f586:	41 18 82 93 	cmpx.w	#0,	&0x1162a;r3 As==00
    f58a:	2a 16 
    f58c:	2b 24       	jz	$+88     	;abs 0xf5e4

0000f58e <.LBB69>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    f58e:	17 4a 1c 00 	mov	28(r10),r7	;0x0001c
    f592:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    f596:	19 4c 0a 00 	mov	10(r12),r9	;0x0000a

0000f59a <.LVL88>:
    dmaCancelI(&I2CDB0.dma);
    f59a:	8c 01 58 16 	mova	#71256,	r12	;0x11658
    f59e:	b0 13 46 56 	calla	#22086		;0x05646

0000f5a2 <.LVL89>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    f5a2:	40 18 fa b0 	bitx.b	#32,	6(r10)	;0x00020
    f5a6:	20 00 06 00 
    f5aa:	04 24       	jz	$+10     	;abs 0xf5b4

0000f5ac <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    f5ac:	41 18 f2 40 	movx.b	#5,	&0x11624;
    f5b0:	05 00 24 16 

0000f5b4 <.L131>:
    if (NULL != I2CDB0.callback) {
    f5b4:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    f5b8:	98 00 00 00 	cmpa	#0,	r8	;
    f5bc:	09 24       	jz	$+20     	;abs 0xf5d0

0000f5be <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    f5be:	40 18 0e 47 	movx.w	r7,	r14	;
    f5c2:	40 18 0e 89 	subx.w	r9,	r14	;
    f5c6:	3d 0a 08 00 	mova	8(r10),	r13	;
    f5ca:	8c 01 24 16 	mova	#71204,	r12	;0x11624
    f5ce:	48 13       	calla	r8		;

0000f5d0 <.L132>:
    if (I2CDB0.thread != NULL) {
    f5d0:	01 18 c2 93 	cmpx.a	#0,	&0x11652;r3 As==00
    f5d4:	52 16 
    f5d6:	06 24       	jz	$+14     	;abs 0xf5e4

0000f5d8 <.LBB70>:
  chThdResumeI(trp, msg);
    f5d8:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    f5dc:	8c 01 52 16 	mova	#71250,	r12	;0x11652

0000f5e0 <.LVL92>:
    f5e0:	b0 13 6e 48 	calla	#18542		;0x0486e

0000f5e4 <.L130>:
  OSAL_IRQ_EPILOGUE();
    f5e4:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f5e8:	48 15 
    f5ea:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f5ee <.LVL94>:
    f5ee:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f5f0:	02 24       	jz	$+6      	;abs 0xf5f6

0000f5f2 <.Loc.211.1>:
    f5f2:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f5f6 <.L112>:
}
    f5f6:	b4 16       	popm.a	#12,	r15	;20-bit words
    f5f8:	00 13       	reti			

0000f5fa <.L117>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f5fa:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    f5fe:	28 24       	jz	$+82     	;abs 0xf650
    f600:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    f604:	25 24       	jz	$+76     	;abs 0xf650
    f606:	3c 92       	cmp	#8,	r12	;r2 As==11
    f608:	be 23       	jnz	$-130    	;abs 0xf586

0000f60a <.Loc.126.1>:
      I2CDB0.state = I2C_READY;
    f60a:	41 18 e2 43 	movx.b	#2,	&0x11624;r3 As==10
    f60e:	24 16 

0000f610 <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    f610:	01 18 c2 93 	cmpx.a	#0,	&0x11652;r3 As==00
    f614:	52 16 
    f616:	06 24       	jz	$+14     	;abs 0xf624

0000f618 <.LBB72>:
    f618:	4d 43       	clr.b	r13		;
    f61a:	cc 0a       	mova	r10,	r12	;
    f61c:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    f620:	b0 13 6e 48 	calla	#18542		;0x0486e

0000f624 <.L126>:
        dmaReleaseX(&(I2CDB0.dma));
    f624:	8c 01 58 16 	mova	#71256,	r12	;0x11658
    f628:	b0 13 00 56 	calla	#22016		;0x05600

0000f62c <.LVL98>:
      break;
    f62c:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f630 <.L115>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f630:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    f634:	38 24       	jz	$+114    	;abs 0xf6a6
    f636:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    f63a:	0d 9c       	cmp	r12,	r13	;
    f63c:	0f 28       	jnc	$+32     	;abs 0xf65c
    f63e:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    f642:	06 24       	jz	$+14     	;abs 0xf650
    f644:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    f648:	03 24       	jz	$+8      	;abs 0xf650
    f64a:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    f64e:	9b 23       	jnz	$-200    	;abs 0xf586

0000f650 <.L123>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    f650:	8c 01 da 04 	mova	#66778,	r12	;0x104da
    f654:	b0 13 3e 46 	calla	#17982		;0x0463e

0000f658 <.LVL99>:
      break;
    f658:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f65c <.L122>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    f65c:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    f660:	f7 27       	jz	$-16     	;abs 0xf650
    f662:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    f666:	3c 24       	jz	$+122    	;abs 0xf6e0
    f668:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    f66c:	8c 23       	jnz	$-230    	;abs 0xf586

0000f66e <.Loc.158.1>:
      UCB0IE &= ~(UCTXIE);
    f66e:	40 18 a2 c3 	bicx.w	#2,	&0x0066a;r3 As==10
    f672:	6a 06 

0000f674 <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    f674:	01 18 c2 93 	cmpx.a	#0,	&0x11652;r3 As==00
    f678:	52 16 
    f67a:	2a 20       	jnz	$+86     	;abs 0xf6d0

0000f67c <.Loc.162.1>:
        if (NULL != I2CDB0.callback) {
    f67c:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    f680:	98 00 00 00 	cmpa	#0,	r8	;
    f684:	20 24       	jz	$+66     	;abs 0xf6c6

0000f686 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    f686:	1e 4a 1c 00 	mov	28(r10),r14	;0x0001c
    f68a:	3d 0a 08 00 	mova	8(r10),	r13	;
    f68e:	cc 0a       	mova	r10,	r12	;
    f690:	48 13       	calla	r8		;

0000f692 <.LVL100>:
    f692:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f696 <.L118>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    f696:	aa d3 06 00 	bis	#2,	6(r10)	;r3 As==10

0000f69a <.Loc.116.1>:
      break;
    f69a:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f69e <.L119>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    f69e:	aa d2 06 00 	bis	#4,	6(r10)	;r2 As==10

0000f6a2 <.Loc.120.1>:
      break;
    f6a2:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f6a6 <.L121>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    f6a6:	40 18 1d 42 	movx.w	&0x0064c,r13	;
    f6aa:	4c 06 
    f6ac:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    f6b0:	1c 00 
    f6b2:	00 18 5c 5a 	addx.a	24(r10),r12	;0x00018
    f6b6:	18 00 
    f6b8:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000f6bc <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    f6bc:	40 18 92 c3 	bicx.w	#1,	&0x0066a;r3 As==01
    f6c0:	6a 06 

0000f6c2 <.Loc.155.1>:
      break;
    f6c2:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f6c6 <.L128>:
          i2cMSP430XEndTransferI(&I2CDB0);
    f6c6:	cc 0a       	mova	r10,	r12	;
    f6c8:	b0 13 02 5e 	calla	#24066		;0x05e02

0000f6cc <.LVL101>:
    f6cc:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f6d0 <.L127>:
    f6d0:	4d 43       	clr.b	r13		;
    f6d2:	cc 0a       	mova	r10,	r12	;
    f6d4:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    f6d8:	b0 13 6e 48 	calla	#18542		;0x0486e

0000f6dc <.LVL103>:
    f6dc:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f6e0 <.L124>:
      I2CDB0.errors |= I2C_TIMEOUT;
    f6e0:	ba d0 20 00 	bis	#32,	6(r10)	;#0x0020
    f6e4:	06 00 

0000f6e6 <.Loc.185.1>:
      break;
    f6e6:	80 00 86 f5 	mova	#62854,	r0	;0x0f586

0000f6ea <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    f6ea:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f6ec <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    f6ec:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f6f0:	48 15 

0000f6f2 <.Loc.267.1>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    f6f2:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    f6f6:	fe 05 
    f6f8:	2c 92       	cmp	#4,	r12	;r2 As==10
    f6fa:	78 24       	jz	$+242    	;abs 0xf7ec
    f6fc:	6d 42       	mov.b	#4,	r13	;r2 As==10
    f6fe:	0d 9c       	cmp	r12,	r13	;
    f700:	0d 28       	jnc	$+28     	;abs 0xf71c
    f702:	2c 93       	cmp	#2,	r12	;r3 As==10
    f704:	2b 24       	jz	$+88     	;abs 0xf75c

0000f706 <.L56>:
  OSAL_IRQ_EPILOGUE();
    f706:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f70a:	48 15 
    f70c:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f710 <.LVL86>:
    f710:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f712:	02 24       	jz	$+6      	;abs 0xf718

0000f714 <.Loc.311.1>:
    f714:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f718 <.L55>:
}
    f718:	b4 16       	popm.a	#12,	r15	;20-bit words
    f71a:	00 13       	reti			

0000f71c <.L58>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    f71c:	3c 90 06 00 	cmp	#6,	r12	;
    f720:	65 24       	jz	$+204    	;abs 0xf7ec
    f722:	3c 92       	cmp	#8,	r12	;r2 As==11
    f724:	f0 23       	jnz	$-30     	;abs 0xf706

0000f726 <.Loc.303.1>:
      _uart_tx2_isr_code(&UARTDA1);
    f726:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    f72a:	3e 0c 04 00 	mova	4(r12),	r14	;
    f72e:	3e 0e 04 00 	mova	4(r14),	r14	;
    f732:	9e 00 00 00 	cmpa	#0,	r14	;
    f736:	01 24       	jz	$+4      	;abs 0xf73a

0000f738 <.Loc.303.1>:
    f738:	4e 13       	calla	r14		;

0000f73a <.L68>:
    f73a:	41 18 c2 93 	cmpx.b	#0,	&0x1166a;r3 As==00
    f73e:	6a 16 
    f740:	05 20       	jnz	$+12     	;abs 0xf74c

0000f742 <.LBB55>:
    f742:	4d 43       	clr.b	r13		;
    f744:	8c 01 70 16 	mova	#71280,	r12	;0x11670

0000f748 <.LVL90>:
    f748:	b0 13 6e 48 	calla	#18542		;0x0486e

0000f74c <.L69>:
      UCA1IE &= ~UCTXCPTIE;
    f74c:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    f750:	fa 05 

0000f752 <.Loc.307.1>:
      UCA1IFG &= ~UCTXCPTIFG;
    f752:	40 18 b2 c2 	bicx.w	#8,	&0x005fc;r2 As==11
    f756:	fc 05 

0000f758 <.Loc.308.1>:
      break;
    f758:	80 00 06 f7 	mova	#63238,	r0	;0x0f706

0000f75c <.L59>:
    f75c:	8a 01 62 16 	mova	#71266,	r10	;0x11662

0000f760 <.Loc.272.1>:
      if (UCA1STATW & UCRXERR) {
    f760:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    f764:	ea 05 
    f766:	2a 24       	jz	$+86     	;abs 0xf7bc

0000f768 <.LBB57>:
        if (UCA1STATW & UCBRK)
    f768:	40 18 f2 b2 	bitx.b	#8,	&0x005ea;r2 As==11
    f76c:	ea 05 
    f76e:	35 24       	jz	$+108    	;abs 0xf7da

0000f770 <.Loc.277.1>:
          sts |= UART_BREAK_DETECTED;
    f770:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    f774:	4e 43       	clr.b	r14		;

0000f776 <.L62>:
        if (UCA1STATW & UCOE)
    f776:	40 18 f2 b0 	bitx.b	#32,	&0x005ea;0x00020
    f77a:	20 00 ea 05 
    f77e:	02 24       	jz	$+6      	;abs 0xf784

0000f780 <.Loc.279.1>:
          sts |= UART_OVERRUN_ERROR;
    f780:	3d d0 10 00 	bis	#16,	r13	;#0x0010

0000f784 <.L63>:
        if (UCA1STATW & UCFE)
    f784:	40 18 f2 b0 	bitx.b	#64,	&0x005ea;0x00040
    f788:	40 00 ea 05 
    f78c:	01 24       	jz	$+4      	;abs 0xf790

0000f78e <.Loc.281.1>:
          sts |= UART_FRAMING_ERROR;
    f78e:	3d d2       	bis	#8,	r13	;r2 As==11

0000f790 <.L64>:
        if (UCA1STATW & UCPE)
    f790:	40 18 f2 b0 	bitx.b	#16,	&0x005ea;0x00010
    f794:	10 00 ea 05 
    f798:	01 24       	jz	$+4      	;abs 0xf79c

0000f79a <.Loc.283.1>:
          sts |= UART_PARITY_ERROR;
    f79a:	2d d2       	bis	#4,	r13	;r2 As==10

0000f79c <.L65>:
        _uart_rx_error_isr_code(&UARTDA1, sts);
    f79c:	3c 0a 04 00 	mova	4(r10),	r12	;
    f7a0:	38 0c 10 00 	mova	16(r12),r8	;0x00010
    f7a4:	98 00 00 00 	cmpa	#0,	r8	;
    f7a8:	03 24       	jz	$+8      	;abs 0xf7b0

0000f7aa <.Loc.285.1>:
    f7aa:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    f7ae:	48 13       	calla	r8		;

0000f7b0 <.L66>:
    f7b0:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    f7b4:	8c 01 6c 16 	mova	#71276,	r12	;0x1166c

0000f7b8 <.LVL98>:
    f7b8:	b0 13 6e 48 	calla	#18542		;0x0486e

0000f7bc <.L61>:
      if (UARTDA1.config->rxchar_cb != NULL) {
    f7bc:	3c 0a 04 00 	mova	4(r10),	r12	;
    f7c0:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    f7c4:	9e 00 00 00 	cmpa	#0,	r14	;
    f7c8:	0c 24       	jz	$+26     	;abs 0xf7e2

0000f7ca <.Loc.290.1>:
        UARTDA1.config->rxchar_cb(&UARTDA1, UCA1RXBUF);
    f7ca:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    f7ce:	ec 05 
    f7d0:	8c 01 62 16 	mova	#71266,	r12	;0x11662
    f7d4:	4e 13       	calla	r14		;

0000f7d6 <.LVL100>:
    f7d6:	80 00 06 f7 	mova	#63238,	r0	;0x0f706

0000f7da <.L71>:
        uartflags_t sts = 0;
    f7da:	4d 43       	clr.b	r13		;
    f7dc:	0e 4d       	mov	r13,	r14	;
    f7de:	80 00 76 f7 	mova	#63350,	r0	;0x0f776

0000f7e2 <.L67>:
        UCA1IFG &= ~UCRXIFG;
    f7e2:	40 18 92 c3 	bicx.w	#1,	&0x005fc;r3 As==01
    f7e6:	fc 05 
    f7e8:	80 00 06 f7 	mova	#63238,	r0	;0x0f706

0000f7ec <.L57>:
      osalDbgAssert(false, "Spurious interrupt in USCI A1 UART");
    f7ec:	8c 01 fc 04 	mova	#66812,	r12	;0x104fc
    f7f0:	b0 13 3e 46 	calla	#17982		;0x0463e

0000f7f4 <.LVL103>:
      break;
    f7f4:	80 00 06 f7 	mova	#63238,	r0	;0x0f706

0000f7f8 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    f7f8:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000f7fa <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    f7fa:	41 18 d2 43 	movx.b	#1,	&0x11548;r3 As==01
    f7fe:	48 15 

0000f800 <.Loc.119.1>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    f800:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    f804:	ae 03 
    f806:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    f80a:	1b 20       	jnz	$+56     	;abs 0xf842

0000f80c <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    f80c:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    f810:	6d 4c       	mov.b	@r12,	r13	;
    f812:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    f816:	5e 43       	mov.b	#1,	r14	;r3 As==01
    f818:	4e 9d       	cmp.b	r13,	r14	;
    f81a:	08 28       	jnc	$+18     	;abs 0xf82c

0000f81c <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    f81c:	3e 0c 02 00 	mova	2(r12),	r14	;
    f820:	3e 0e 04 00 	mova	4(r14),	r14	;

0000f824 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    f824:	9e 00 00 00 	cmpa	#0,	r14	;
    f828:	01 24       	jz	$+4      	;abs 0xf82c

0000f82a <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    f82a:	4e 13       	calla	r14		;

0000f82c <.L22>:
      if (GPTDA1.state == GPT_ONESHOT) {
    f82c:	41 18 e2 92 	cmpx.b	#4,	&0x116c6;r2 As==10
    f830:	c6 16 
    f832:	07 20       	jnz	$+16     	;abs 0xf842

0000f834 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    f834:	41 18 e2 43 	movx.b	#2,	&0x116c6;r3 As==10
    f838:	c6 16 

0000f83a <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    f83a:	8c 01 c6 16 	mova	#71366,	r12	;0x116c6
    f83e:	b0 13 b4 65 	calla	#26036		;0x065b4

0000f842 <.L20>:
  OSAL_IRQ_EPILOGUE();
    f842:	41 18 c2 43 	movx.b	#0,	&0x11548;r3 As==00
    f846:	48 15 
    f848:	b0 13 a0 47 	calla	#18336		;0x047a0

0000f84c <.LVL23>:
    f84c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    f84e:	02 24       	jz	$+6      	;abs 0xf854

0000f850 <.Loc.135.1>:
    f850:	b0 13 b0 47 	calla	#18352		;0x047b0

0000f854 <.L19>:
}
    f854:	b4 16       	popm.a	#12,	r15	;20-bit words
    f856:	00 13       	reti			
