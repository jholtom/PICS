
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	64 44       	mov.b	@r4,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	68 44       	mov.b	@r4,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	6c 44       	mov.b	@r4,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	70 44       	br	@r4+		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	74 44       	mov.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	78 44       	mov.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	7c 44       	mov.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	80 44 00 00 	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	84 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8c 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	90 44 00 00 	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	94 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	9c 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a0 44 00 00 	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a4 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	ac 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b0 44 00 00 	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b4 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b8 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c0 44 00 00 	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c4 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c8 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	cc 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 44 00 00 	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d4 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d8 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	dc 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e0 44 00 00 	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	fc ce       	bic.b	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	90 ce 00 00 	bic			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e4 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	e8 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	24 ce       	bic	@r14,	r4	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	f0 44 00 00 	mov.b	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	c8 cd       	bic.b	r13		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	f4 d1       	interrupt service routine at 0xd1f4

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f4 44       	interrupt service routine at 0x44f4

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	68 cf       	interrupt service routine at 0xcf68

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	c2 cc       	interrupt service routine at 0xccc2

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	94 d1       	interrupt service routine at 0xd194

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	f8 44       	interrupt service routine at 0x44f8

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	fc 44       	interrupt service routine at 0x44fc

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	fa cf       	interrupt service routine at 0xcffa

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	00 45       	interrupt service routine at 0x4500

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	04 45       	interrupt service routine at 0x4504

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	a0 cc       	interrupt service routine at 0xcca0

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	08 45       	interrupt service routine at 0x4508

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	0c 45       	interrupt service routine at 0x450c

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	10 45       	interrupt service routine at 0x4510

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	81 00 94 a5 	mova	#42388,	r1	;0x0a594

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
    440c:	8c 00 a0 a7 	mova	#42912,	r12	;0x0a7a0

00004410 <.Loc.74.1>:
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
    4412:	3e 40 00 25 	mov	#9472,	r14	;#0x2500

00004416 <.Loc.77.1>:
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
    4418:	b0 13 24 a4 	calla	#42020		;0x0a424

0000441c <__crt0_init_highbss>:
    441c:	8c 01 7c 07 	mova	#67452,	r12	;0x1077c

00004420 <.Loc.94.1>:
    4420:	0d 43       	clr	r13		;

00004422 <.Loc.95.1>:
    4422:	8e 01 dc 0d 	mova	#69084,	r14	;0x10ddc

00004426 <.Loc.98.1>:
    4426:	0e 93       	cmp	#0,	r14	;r3 As==00

00004428 <.Loc.99.1>:
    4428:	02 24       	jz	$+6      	;abs 0x442e

0000442a <.Loc.100.1>:
    442a:	b0 13 24 a4 	calla	#42020		;0x0a424

0000442e <__crt0_move_highdata>:
    442e:	3e 40 42 00 	mov	#66,	r14	;#0x0042

00004432 <.Loc.146.1>:
    4432:	0e 93       	cmp	#0,	r14	;r3 As==00

00004434 <.Loc.147.1>:
    4434:	14 24       	jz	$+42     	;abs 0x445e

00004436 <.Loc.150.1>:
    4436:	41 18 82 93 	cmpx.w	#0,	&0x106f6;r3 As==00
    443a:	f6 06 

0000443c <.Loc.151.1>:
    443c:	05 24       	jz	$+12     	;abs 0x4448

0000443e <.Loc.153.1>:
    443e:	8c 01 f8 06 	mova	#67320,	r12	;0x106f8

00004442 <.Loc.154.1>:
    4442:	8d 01 3a 07 	mova	#67386,	r13	;0x1073a

00004446 <.Loc.155.1>:
    4446:	07 3c       	jmp	$+16     	;abs 0x4456

00004448 <.L11>:
    4448:	41 18 92 43 	movx.w	#1,	&0x106f6;r3 As==01
    444c:	f6 06 

0000444e <.Loc.159.1>:
    444e:	8c 01 3a 07 	mova	#67386,	r12	;0x1073a

00004452 <.Loc.160.1>:
    4452:	8d 01 f8 06 	mova	#67320,	r13	;0x106f8

00004456 <.L21>:
    4456:	3e 40 42 00 	mov	#66,	r14	;#0x0042

0000445a <.Loc.165.1>:
    445a:	b0 13 3e a4 	calla	#42046		;0x0a43e

0000445e <__crt0_call_just_main>:
    445e:	0c 43       	clr	r12		;

00004460 <.Loc.181.1>:
    4460:	b0 13 04 a2 	calla	#41476		;0x0a204

00004464 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4464:	80 00 64 44 	mova	#17508,	r0	;0x04464

00004468 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    4468:	80 00 68 44 	mova	#17512,	r0	;0x04468

0000446c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    446c:	80 00 6c 44 	mova	#17516,	r0	;0x0446c

00004470 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4470:	80 00 70 44 	mova	#17520,	r0	;0x04470

00004474 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4474:	80 00 74 44 	mova	#17524,	r0	;0x04474

00004478 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    4478:	80 00 78 44 	mova	#17528,	r0	;0x04478

0000447c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    447c:	80 00 7c 44 	mova	#17532,	r0	;0x0447c

00004480 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4480:	80 00 80 44 	mova	#17536,	r0	;0x04480

00004484 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4484:	80 00 84 44 	mova	#17540,	r0	;0x04484

00004488 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    4488:	80 00 88 44 	mova	#17544,	r0	;0x04488

0000448c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    448c:	80 00 8c 44 	mova	#17548,	r0	;0x0448c

00004490 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4490:	80 00 90 44 	mova	#17552,	r0	;0x04490

00004494 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4494:	80 00 94 44 	mova	#17556,	r0	;0x04494

00004498 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    4498:	80 00 98 44 	mova	#17560,	r0	;0x04498

0000449c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    449c:	80 00 9c 44 	mova	#17564,	r0	;0x0449c

000044a0 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    44a0:	80 00 a0 44 	mova	#17568,	r0	;0x044a0

000044a4 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    44a4:	80 00 a4 44 	mova	#17572,	r0	;0x044a4

000044a8 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    44a8:	80 00 a8 44 	mova	#17576,	r0	;0x044a8

000044ac <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    44ac:	80 00 ac 44 	mova	#17580,	r0	;0x044ac

000044b0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    44b0:	80 00 b0 44 	mova	#17584,	r0	;0x044b0

000044b4 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    44b4:	80 00 b4 44 	mova	#17588,	r0	;0x044b4

000044b8 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    44b8:	80 00 b8 44 	mova	#17592,	r0	;0x044b8

000044bc <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    44bc:	80 00 bc 44 	mova	#17596,	r0	;0x044bc

000044c0 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    44c0:	80 00 c0 44 	mova	#17600,	r0	;0x044c0

000044c4 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    44c4:	80 00 c4 44 	mova	#17604,	r0	;0x044c4

000044c8 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    44c8:	80 00 c8 44 	mova	#17608,	r0	;0x044c8

000044cc <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    44cc:	80 00 cc 44 	mova	#17612,	r0	;0x044cc

000044d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44d0:	80 00 d0 44 	mova	#17616,	r0	;0x044d0

000044d4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44d4:	80 00 d4 44 	mova	#17620,	r0	;0x044d4

000044d8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44d8:	80 00 d8 44 	mova	#17624,	r0	;0x044d8

000044dc <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44dc:	80 00 dc 44 	mova	#17628,	r0	;0x044dc

000044e0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44e0:	80 00 e0 44 	mova	#17632,	r0	;0x044e0

000044e4 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44e4:	80 00 e4 44 	mova	#17636,	r0	;0x044e4

000044e8 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44e8:	80 00 e8 44 	mova	#17640,	r0	;0x044e8

000044ec <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44ec:	80 00 ec 44 	mova	#17644,	r0	;0x044ec

000044f0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44f0:	80 00 f0 44 	mova	#17648,	r0	;0x044f0

000044f4 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44f4:	80 00 f4 44 	mova	#17652,	r0	;0x044f4

000044f8 <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44f8:	80 00 f8 44 	mova	#17656,	r0	;0x044f8

000044fc <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    44fc:	80 00 fc 44 	mova	#17660,	r0	;0x044fc

00004500 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    4500:	80 00 00 45 	mova	#17664,	r0	;0x04500

00004504 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    4504:	80 00 04 45 	mova	#17668,	r0	;0x04504

00004508 <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    4508:	80 00 08 45 	mova	#17672,	r0	;0x04508

0000450c <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    450c:	80 00 0c 45 	mova	#17676,	r0	;0x0450c

00004510 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    4510:	80 00 10 45 	mova	#17680,	r0	;0x04510

00004514 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    4514:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    4518:	da 07 

0000451a <.Loc.305.1>:
}
    451a:	10 01       	reta			;

0000451c <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    451c:	03 43       	nop			

0000451e <.Loc.356.1>:
  _enable_interrupts();
    451e:	03 43       	nop			
    4520:	32 d2       	eint			
    4522:	03 43       	nop			

00004524 <.Loc.357.1>:
}
    4524:	10 01       	reta			;

00004526 <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    4526:	32 c2       	dint			
    4528:	03 43       	nop			

0000452a <.Loc.390.1>:
  asm volatile("nop");
    452a:	03 43       	nop			

0000452c <.Loc.391.1>:
}
    452c:	10 01       	reta			;

0000452e <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    452e:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004532 <.LCFI0>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    4532:	80 18 f1 40 	movx.a	#67466,	16(r1)	;0x1078a, 0x00010
    4536:	8a 07 10 00 

0000453a <.Loc.234.2>:
  tcp = nil_thd_configs;
    453a:	80 18 f1 40 	movx.a	#67238,	12(r1)	;0x106a6, 0x0000c
    453e:	a6 06 0c 00 

00004542 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4542:	80 00 0e 46 	mova	#17934,	r0	;0x0460e

00004546 <.L6>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    4546:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    454a:	0d 0c       	mova	@r12,	r13	;
    454c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4550:	7c 0d 10 00 	mova	r13,	16(r12)	; 0x00010

00004554 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4554:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    4558:	3c 0c 04 00 	mova	4(r12),	r12	;
    455c:	cd 0c       	mova	r12,	r13	;
    455e:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    4562:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4566:	7c 0d 00 00 	mova	r13,	0(r12)	;
    456a:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    456e:	0c 0c       	mova	@r12,	r12	;
    4570:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    4574:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    4578:	71 0d 08 00 	mova	r13,	8(r1)	;
    457c:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    4580:	00 00 
    4582:	3e 01 08 00 	mova	8(r1),	r14	;
    4586:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4588:	0d 17       	popm	#1,	r13	;16-bit words
    458a:	0d 17       	popm	#1,	r13	;16-bit words
    458c:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4590:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    4594:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4598:	4d de       	bis.b	r14,	r13	;
    459a:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    459e:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    45a2:	0c 0c       	mova	@r12,	r12	;
    45a4:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    45a8:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    45ac:	71 0d 04 00 	mova	r13,	4(r1)	;
    45b0:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    45b4:	04 00 
    45b6:	3e 01 04 00 	mova	4(r1),	r14	;
    45ba:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45bc:	0d 17       	popm	#1,	r13	;16-bit words
    45be:	0d 17       	popm	#1,	r13	;16-bit words
    45c0:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45c4:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    45c8:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45cc:	4d de       	bis.b	r14,	r13	;
    45ce:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    45d2:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    45d6:	0c 0c       	mova	@r12,	r12	;
    45d8:	00 18 f1 40 	movx.a	#19752,	0(r1)	;0x04d28
    45dc:	28 4d 00 00 
    45e0:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    45e4:	0e 01       	mova	@r1,	r14	;
    45e6:	0e 14       	pushm.a	#1,	r14	;20-bit words
    45e8:	0d 17       	popm	#1,	r13	;16-bit words
    45ea:	0d 17       	popm	#1,	r13	;16-bit words
    45ec:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    45f0:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    45f4:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    45f8:	4d de       	bis.b	r14,	r13	;
    45fa:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

000045fe <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    45fe:	00 18 f1 50 	addx.a	#20,	16(r1)	;0x00014, 0x00010
    4602:	14 00 10 00 

00004606 <.Loc.247.2>:
    tcp++;
    4606:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    460a:	14 00 0c 00 

0000460e <.L5>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    460e:	80 18 f1 90 	cmpx.a	#67526,	16(r1)	;0x107c6, 0x00010
    4612:	c6 07 10 00 
    4616:	97 2b       	jnc	$-208    	;abs 0x4546

00004618 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    4618:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    461c:	00 18 fc 40 	movx.a	#42388,	16(r12)	;0x0a594, 0x00010
    4620:	94 a5 10 00 

00004624 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    4624:	b0 13 26 45 	calla	#17702		;0x04526

00004628 <.LVL4>:
  nil.lock_cnt = (cnt_t)1;
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    4628:	b0 13 10 4c 	calla	#19472		;0x04c10

0000462c <.LVL5>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    462c:	b0 13 14 45 	calla	#17684		;0x04514

00004630 <.LVL6>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4630:	81 18 f2 40 	movx.a	#67466,	&0x10780;0x1078a
    4634:	8a 07 80 07 
    4638:	2c 01 80 07 	mova	&67456,	r12	;0x10780
    463c:	61 0c 7c 07 	mova	r12,	&67452	; 0x1077c

00004640 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4640:	2c 01 7c 07 	mova	&67452,	r12	;0x1077c
    4644:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    4648:	b0 13 18 4d 	calla	#19736		;0x04d18

0000464c <.LVL7>:
  chSysUnlock();
    464c:	b0 13 1c 45 	calla	#17692		;0x0451c

00004650 <.LVL8>:
}
    4650:	03 43       	nop			
    4652:	a1 00 14 00 	adda	#20,	r1	;0x00014
    4656:	10 01       	reta			;

00004658 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    4658:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000465a <.LCFI1>:
    465a:	ca 0c       	mova	r12,	r10	;

0000465c <.Loc.293.2>:

  port_disable();
    465c:	b0 13 26 45 	calla	#17702		;0x04526

00004660 <.LVL10>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4660:	61 0a 86 07 	mova	r10,	&67462	; 0x10786

00004664 <.L8>:
    4664:	80 00 64 46 	mova	#18020,	r0	;0x04664

00004668 <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    4668:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000466a <.LCFI2>:
    466a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000466c <.LCFI3>:
    466c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000466e <.LCFI4>:

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    466e:	88 01 7c 07 	mova	#67452,	r8	;0x1077c
    4672:	98 53 08 00 	inc	8(r8)		;
    4676:	a8 00 14 00 	adda	#20,	r8	;0x00014

0000467a <.Loc.341.2>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    467a:	8a 00 28 47 	mova	#18216,	r10	;0x04728
    467e:	86 0f ff ff 	mova	#-1,	r6	;0xffffffff

00004682 <.L17>:
    4682:	cc 08       	mova	r8,	r12	;
    4684:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

00004688 <.LVL13>:
    if (tp->timeout > (systime_t)0) {
    4688:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    468c:	0d 93       	cmp	#0,	r13	;r3 As==00
    468e:	1e 24       	jz	$+62     	;abs 0x46cc

00004690 <.Loc.327.2>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    4690:	5d 48 fe ff 	mov.b	-2(r8),	r13	;
    4694:	0d 93       	cmp	#0,	r13	;r3 As==00
    4696:	0b 20       	jnz	$+24     	;abs 0x46ae

00004698 <.LBB72>:
  port_disable();
    4698:	b0 13 26 45 	calla	#17702		;0x04526

0000469c <.LVL15>:
  nil.dbg_panic_msg = reason;
    469c:	81 18 f2 40 	movx.a	#65536,	&0x10786;0x10000
    46a0:	00 00 86 07 

000046a4 <.L13>:
    46a4:	80 00 a4 46 	mova	#18084,	r0	;0x046a4

000046a8 <.L18>:
    46a8:	c8 0c       	mova	r12,	r8	;

000046aa <.LVL17>:
    46aa:	80 00 82 46 	mova	#18050,	r0	;0x04682

000046ae <.L12>:
      if (--tp->timeout == (systime_t)0) {
    46ae:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    46b2:	3e 53       	add	#-1,	r14	;r3 As==11
    46b4:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a
    46b8:	0e 93       	cmp	#0,	r14	;r3 As==00
    46ba:	08 20       	jnz	$+18     	;abs 0x46cc

000046bc <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    46bc:	7d 90 03 00 	cmp.b	#3,	r13	;
    46c0:	11 20       	jnz	$+36     	;abs 0x46e4

000046c2 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    46c2:	0e 08       	mova	@r8,	r14	;
    46c4:	9e 53 00 00 	inc	0(r14)		;

000046c8 <.L16>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    46c8:	cd 06       	mova	r6,	r13	;
    46ca:	4a 13       	calla	r10		;

000046cc <.L11>:
    46cc:	cc 08       	mova	r8,	r12	;
    46ce:	ac 00 14 00 	adda	#20,	r12	;0x00014

000046d2 <.Loc.349.2>:
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    tp++;
    chSysLockFromISR();
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    46d2:	a8 00 0e 00 	adda	#14,	r8	;0x0000e

000046d6 <.LVL20>:
    46d6:	98 01 c6 07 	cmpa	#67526,	r8	;0x107c6
    46da:	e6 2b       	jnc	$-50     	;abs 0x46a8

000046dc <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    46dc:	06 16       	popm.a	#1,	r6	;20-bit words
    46de:	08 16       	popm.a	#1,	r8	;20-bit words
    46e0:	0a 16       	popm.a	#1,	r10	;20-bit words
    46e2:	10 01       	reta			;

000046e4 <.L15>:
        else if (NIL_THD_IS_SUSP(tp)) {
    46e4:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    46e6:	f0 23       	jnz	$-30     	;abs 0x46c8

000046e8 <.Loc.338.2>:
          *tp->u1.trp = NULL;
    46e8:	0e 08       	mova	@r8,	r14	;
    46ea:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    46ee:	00 00 
    46f0:	80 00 c8 46 	mova	#18120,	r0	;0x046c8

000046f4 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    46f4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000046f6 <.LBB78>:
  return __get_SR_register();
    46f6:	0a 42       	mov	r2,	r10	;

000046f8 <.LBE78>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    46f8:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    46fc:	06 24       	jz	$+14     	;abs 0x470a

000046fe <.Loc.450.2>:
    if (port_is_isr_context()) {
    46fe:	41 18 c2 93 	cmpx.b	#0,	&0x107da;r3 As==00
    4702:	da 07 
    4704:	02 20       	jnz	$+6      	;abs 0x470a

00004706 <.Loc.454.2>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    4706:	b0 13 26 45 	calla	#17702		;0x04526

0000470a <.L27>:
    }
  }
  return sts;
}
    470a:	0c 4a       	mov	r10,	r12	;
    470c:	0a 16       	popm.a	#1,	r10	;20-bit words
    470e:	10 01       	reta			;

00004710 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    4710:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    4714:	08 24       	jz	$+18     	;abs 0x4726

00004716 <.Loc.472.2>:
    if (port_is_isr_context()) {
    4716:	41 18 c2 93 	cmpx.b	#0,	&0x107da;r3 As==00
    471a:	da 07 
    471c:	04 20       	jnz	$+10     	;abs 0x4726

0000471e <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    471e:	b0 13 de 47 	calla	#18398		;0x047de

00004722 <.LVL26>:
      chSysUnlock();
    4722:	b0 13 1c 45 	calla	#17692		;0x0451c

00004726 <.L31>:
    }
  }
}
    4726:	10 01       	reta			;

00004728 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    4728:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000472a <.LCFI6>:
    472a:	b1 00 04 00 	suba	#4,	r1	;

0000472e <.LCFI7>:
    472e:	71 0d 00 00 	mova	r13,	0(r1)	;

00004732 <.Loc.537.2>:

  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    4732:	9c 01 8a 07 	cmpa	#67466,	r12	;0x1078a
    4736:	03 28       	jnc	$+8      	;abs 0x473e

00004738 <.Loc.537.2>:
    4738:	9c 01 c6 07 	cmpa	#67526,	r12	;0x107c6
    473c:	08 28       	jnc	$+18     	;abs 0x474e

0000473e <.L37>:
  port_disable();
    473e:	b0 13 26 45 	calla	#17702		;0x04526

00004742 <.LVL30>:
  nil.dbg_panic_msg = reason;
    4742:	81 18 f2 40 	movx.a	#65555,	&0x10786;0x10013
    4746:	13 00 86 07 

0000474a <.L39>:
    474a:	80 00 4a 47 	mova	#18250,	r0	;0x0474a

0000474e <.L38>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    474e:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4752:	08 20       	jnz	$+18     	;abs 0x4764

00004754 <.LBB82>:
  port_disable();
    4754:	b0 13 26 45 	calla	#17702		;0x04526

00004758 <.LVL33>:
  nil.dbg_panic_msg = reason;
    4758:	81 18 f2 40 	movx.a	#65555,	&0x10786;0x10013
    475c:	13 00 86 07 

00004760 <.L41>:
    4760:	80 00 60 47 	mova	#18272,	r0	;0x04760

00004764 <.L40>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    4764:	8e 01 7c 07 	mova	#67452,	r14	;0x1077c
    4768:	3a 0e 04 00 	mova	4(r14),	r10	;
    476c:	01 18 c2 9a 	cmpx.a	r10,	&0x1077c;
    4770:	7c 07 
    4772:	08 2c       	jc	$+18     	;abs 0x4784

00004774 <.LBB84>:
  port_disable();
    4774:	b0 13 26 45 	calla	#17702		;0x04526

00004778 <.LVL36>:
  nil.dbg_panic_msg = reason;
    4778:	81 18 f2 40 	movx.a	#65555,	&0x10786;0x10013
    477c:	13 00 86 07 

00004780 <.L43>:
    4780:	80 00 80 47 	mova	#18304,	r0	;0x04780

00004784 <.L42>:

  tp->u1.msg = msg;
    4784:	ac 41 06 00 	mov	@r1,	6(r12)	;
    4788:	0f 01       	mova	@r1,	r15	;
    478a:	0f 14       	pushm.a	#1,	r15	;20-bit words
    478c:	0d 17       	popm	#1,	r13	;16-bit words
    478e:	0d 17       	popm	#1,	r13	;16-bit words

00004790 <.LVL38>:
    4790:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4794:	5f 4c 08 00 	mov.b	8(r12),	r15	;
    4798:	7f f0 f0 ff 	and.b	#-16,	r15	;#0xfff0
    479c:	4f dd       	bis.b	r13,	r15	;
    479e:	cc 4f 08 00 	mov.b	r15,	8(r12)	;

000047a2 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    47a2:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

000047a6 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    47a6:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000047aa <.Loc.544.2>:
  if (tp < nil.next) {
    47aa:	dc 0a       	cmpa	r10,	r12	;
    47ac:	02 2c       	jc	$+6      	;abs 0x47b2

000047ae <.Loc.545.2>:
    nil.next = tp;
    47ae:	7e 0c 04 00 	mova	r12,	4(r14)	;

000047b2 <.L44>:
  }
  return tp;
}
    47b2:	a1 00 04 00 	adda	#4,	r1	;

000047b6 <.LVL39>:
    47b6:	0a 16       	popm.a	#1,	r10	;20-bit words
    47b8:	10 01       	reta			;

000047ba <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    47ba:	5c 43       	mov.b	#1,	r12	;r3 As==01
    47bc:	81 18 d2 92 	cmpx.a	&0x10780,&0x1077c;
    47c0:	80 07 7c 07 
    47c4:	01 20       	jnz	$+4      	;abs 0x47c8
    47c6:	4c 43       	clr.b	r12		;

000047c8 <.L46>:
}
    47c8:	10 01       	reta			;

000047ca <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    47ca:	8e 01 7c 07 	mova	#67452,	r14	;0x1077c
    47ce:	0d 0e       	mova	@r14,	r13	;

000047d0 <.LVL40>:

  nil.current = nil.next;
    47d0:	3c 0e 04 00 	mova	4(r14),	r12	;
    47d4:	7e 0c 00 00 	mova	r12,	0(r14)	;

000047d8 <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    47d8:	b0 13 18 4d 	calla	#19736		;0x04d18

000047dc <.LVL41>:
}
    47dc:	10 01       	reta			;

000047de <chSchRescheduleS>:
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    47de:	81 18 d2 92 	cmpx.a	&0x10780,&0x1077c;
    47e2:	80 07 7c 07 
    47e6:	02 24       	jz	$+6      	;abs 0x47ec

000047e8 <.Loc.595.2>:
    chSchDoReschedule();
    47e8:	b0 13 ca 47 	calla	#18378		;0x047ca

000047ec <.L48>:
  }
}
    47ec:	10 01       	reta			;

000047ee <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    47ee:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047f0 <.LCFI8>:
    47f0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000047f4 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    47f4:	8a 01 7c 07 	mova	#67452,	r10	;0x1077c
    47f8:	0e 0a       	mova	@r10,	r14	;

000047fa <.LVL44>:

  chDbgCheckClassS();

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    47fa:	9e 01 c6 07 	cmpa	#67526,	r14	;0x107c6
    47fe:	08 20       	jnz	$+18     	;abs 0x4810

00004800 <.LBB86>:
  port_disable();
    4800:	b0 13 26 45 	calla	#17702		;0x04526

00004804 <.LVL46>:
  nil.dbg_panic_msg = reason;
    4804:	81 18 f2 40 	movx.a	#65567,	&0x10786;0x1001f
    4808:	1f 00 86 07 

0000480c <.L52>:
    480c:	80 00 0c 48 	mova	#18444,	r0	;0x0480c

00004810 <.L51>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    4810:	ce 4c 04 00 	mov.b	r12,	4(r14)	;

00004814 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    4814:	8e 4d 0a 00 	mov	r13,	10(r14)	; 0x000a

00004818 <.LVL48>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    4818:	cc 0a       	mova	r10,	r12	;
    481a:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

0000481e <.L54>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    481e:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4822:	0c 20       	jnz	$+26     	;abs 0x483c

00004824 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    4824:	7a 0c 04 00 	mova	r12,	4(r10)	;
    4828:	7a 0c 00 00 	mova	r12,	0(r10)	;

0000482c <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    482c:	cd 0e       	mova	r14,	r13	;
    482e:	b0 13 18 4d 	calla	#19736		;0x04d18

00004832 <.LVL50>:
      return nil.current->u1.msg;
    4832:	0c 0a       	mova	@r10,	r12	;
    4834:	3c 0c 06 00 	mova	6(r12),	r12	;

00004838 <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    4838:	0a 16       	popm.a	#1,	r10	;20-bit words
    483a:	10 01       	reta			;

0000483c <.L53>:
    ntp++;
    483c:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004840 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    4840:	8d 01 c6 07 	mova	#67526,	r13	;0x107c6
    4844:	dd 0c       	cmpa	r12,	r13	;
    4846:	eb 2f       	jc	$-40     	;abs 0x481e

00004848 <.LBB88>:
  port_disable();
    4848:	b0 13 26 45 	calla	#17702		;0x04526

0000484c <.LVL54>:
  nil.dbg_panic_msg = reason;
    484c:	81 18 f2 40 	movx.a	#65567,	&0x10786;0x1001f
    4850:	1f 00 86 07 

00004854 <.L55>:
    4854:	80 00 54 48 	mova	#18516,	r0	;0x04854

00004858 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    4858:	ce 0c       	mova	r12,	r14	;

0000485a <.Loc.718.2>:

  if (*trp != NULL) {
    485a:	0c 0c       	mova	@r12,	r12	;

0000485c <.LVL62>:
    485c:	9c 00 00 00 	cmpa	#0,	r12	;
    4860:	10 24       	jz	$+34     	;abs 0x4882

00004862 <.LBB92>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4862:	ec 93 04 00 	cmp.b	#2,	4(r12)	;r3 As==10
    4866:	08 24       	jz	$+18     	;abs 0x4878

00004868 <.LBB93>:
  port_disable();
    4868:	b0 13 26 45 	calla	#17702		;0x04526

0000486c <.LVL65>:
  nil.dbg_panic_msg = reason;
    486c:	81 18 f2 40 	movx.a	#65609,	&0x10786;0x10049
    4870:	49 00 86 07 

00004874 <.L64>:
    4874:	80 00 74 48 	mova	#18548,	r0	;0x04874

00004878 <.L63>:

    *trp = NULL;
    4878:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    487c:	00 00 

0000487e <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    487e:	b0 13 28 47 	calla	#18216		;0x04728

00004882 <.L61>:
  }
}
    4882:	10 01       	reta			;

00004884 <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    4884:	b1 00 08 00 	suba	#8,	r1	;

00004888 <.LCFI11>:
  msg_t msg;

  chSysLock();
    4888:	71 0c 00 00 	mova	r12,	0(r1)	;
    488c:	71 0d 04 00 	mova	r13,	4(r1)	;
    4890:	b0 13 26 45 	calla	#17702		;0x04526

00004894 <.LVL78>:
  msg = chSemWaitTimeoutS(sp, timeout);
    4894:	3d 01 04 00 	mova	4(r1),	r13	;
    4898:	0c 01       	mova	@r1,	r12	;
    489a:	b0 13 ae 48 	calla	#18606		;0x048ae

0000489e <.LVL79>:
  chSysUnlock();
    489e:	71 0c 00 00 	mova	r12,	0(r1)	;
    48a2:	b0 13 1c 45 	calla	#17692		;0x0451c

000048a6 <.LVL80>:

  return msg;
}
    48a6:	0c 01       	mova	@r1,	r12	;
    48a8:	a1 00 08 00 	adda	#8,	r1	;
    48ac:	10 01       	reta			;

000048ae <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    48ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

000048b0 <.LCFI12>:

  chDbgCheckClassS();
  chDbgCheck(sp != NULL);
    48b0:	9c 00 00 00 	cmpa	#0,	r12	;
    48b4:	08 20       	jnz	$+18     	;abs 0x48c6

000048b6 <.LBB95>:
  port_disable();
    48b6:	b0 13 26 45 	calla	#17702		;0x04526

000048ba <.LVL83>:
  nil.dbg_panic_msg = reason;
    48ba:	81 18 f2 40 	movx.a	#65622,	&0x10786;0x10056
    48be:	56 00 86 07 

000048c2 <.L73>:
    48c2:	80 00 c2 48 	mova	#18626,	r0	;0x048c2

000048c6 <.L72>:

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    48c6:	2e 4c       	mov	@r12,	r14	;

000048c8 <.LVL85>:
  if (cnt <= (cnt_t)0) {
    48c8:	4a 43       	clr.b	r10		;
    48ca:	0a 9e       	cmp	r14,	r10	;
    48cc:	0f 38       	jl	$+32     	;abs 0x48ec

000048ce <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    48ce:	3d 93       	cmp	#-1,	r13	;r3 As==11
    48d0:	13 24       	jz	$+40     	;abs 0x48f8

000048d2 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    48d2:	3e 53       	add	#-1,	r14	;r3 As==11

000048d4 <.LVL86>:
    48d4:	8c 4e 00 00 	mov	r14,	0(r12)	;

000048d8 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    48d8:	2e 01 7c 07 	mova	&67452,	r14	;0x1077c

000048dc <.LVL87>:
    48dc:	7e 0c 06 00 	mova	r12,	6(r14)	;

000048e0 <.LVL88>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    48e0:	7c 40 03 00 	mov.b	#3,	r12	;

000048e4 <.LVL89>:
    48e4:	b0 13 ee 47 	calla	#18414		;0x047ee

000048e8 <.L71>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    48e8:	0a 16       	popm.a	#1,	r10	;20-bit words
    48ea:	10 01       	reta			;

000048ec <.L74>:
  sp->cnt = cnt - (cnt_t)1;
    48ec:	3e 53       	add	#-1,	r14	;r3 As==11

000048ee <.LVL92>:
    48ee:	8c 4e 00 00 	mov	r14,	0(r12)	;

000048f2 <.Loc.823.2>:
  return MSG_OK;
    48f2:	4c 43       	clr.b	r12		;

000048f4 <.LVL93>:
    48f4:	80 00 e8 48 	mova	#18664,	r0	;0x048e8

000048f8 <.L76>:
      return MSG_TIMEOUT;
    48f8:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000048fc <.LVL95>:
    48fc:	80 00 e8 48 	mova	#18664,	r0	;0x048e8

00004900 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    4900:	ce 0c       	mova	r12,	r14	;

00004902 <.Loc.855.2>:

  chDbgCheckClassI();
  chDbgCheck(sp != NULL);
    4902:	9c 00 00 00 	cmpa	#0,	r12	;
    4906:	08 20       	jnz	$+18     	;abs 0x4918

00004908 <.LBB109>:
  port_disable();
    4908:	b0 13 26 45 	calla	#17702		;0x04526

0000490c <.LVL103>:
  nil.dbg_panic_msg = reason;
    490c:	81 18 f2 40 	movx.a	#65640,	&0x10786;0x10068
    4910:	68 00 86 07 

00004914 <.L80>:
    4914:	80 00 14 49 	mova	#18708,	r0	;0x04914

00004918 <.L79>:

  if (++sp->cnt <= (cnt_t)0) {
    4918:	2c 4c       	mov	@r12,	r12	;

0000491a <.LVL105>:
    491a:	1c 53       	inc	r12		;
    491c:	8e 4c 00 00 	mov	r12,	0(r14)	;
    4920:	4d 43       	clr.b	r13		;
    4922:	0d 9c       	cmp	r12,	r13	;
    4924:	15 38       	jl	$+44     	;abs 0x4950
    4926:	8c 01 8a 07 	mova	#67466,	r12	;0x1078a

0000492a <.L85>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    492a:	00 18 5e 9c 	cmpx.a	6(r12),	r14	;
    492e:	06 00 
    4930:	10 20       	jnz	$+34     	;abs 0x4952

00004932 <.Loc.863.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4932:	fc 90 03 00 	cmp.b	#3,	4(r12)	;
    4936:	04 00 
    4938:	08 24       	jz	$+18     	;abs 0x494a

0000493a <.LBB114>:
  port_disable();
    493a:	b0 13 26 45 	calla	#17702		;0x04526

0000493e <.LVL108>:
  nil.dbg_panic_msg = reason;
    493e:	81 18 f2 40 	movx.a	#65640,	&0x10786;0x10068
    4942:	68 00 86 07 

00004946 <.L84>:
    4946:	80 00 46 49 	mova	#18758,	r0	;0x04946

0000494a <.L83>:

        (void) chSchReadyI(tr, MSG_OK);
    494a:	4d 43       	clr.b	r13		;
    494c:	b0 13 28 47 	calla	#18216		;0x04728

00004950 <.L78>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4950:	10 01       	reta			;

00004952 <.L82>:
      tr++;
    4952:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004956 <.Loc.870.2>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    4956:	9c 01 c6 07 	cmpa	#67526,	r12	;0x107c6
    495a:	e7 2b       	jnc	$-48     	;abs 0x492a

0000495c <.LBB116>:
  port_disable();
    495c:	b0 13 26 45 	calla	#17702		;0x04526

00004960 <.LVL114>:
  nil.dbg_panic_msg = reason;
    4960:	81 18 f2 40 	movx.a	#65640,	&0x10786;0x10068
    4964:	68 00 86 07 

00004968 <.L86>:
    4968:	80 00 68 49 	mova	#18792,	r0	;0x04968

0000496c <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    496c:	19 14       	pushm.a	#2,	r9	;20-bit words

0000496e <.LCFI17>:
    496e:	b1 00 04 00 	suba	#4,	r1	;

00004972 <.LCFI18>:
    4972:	08 4d       	mov	r13,	r8	;
    4974:	09 4e       	mov	r14,	r9	;

00004976 <.Loc.951.2>:

  chSysLock();
    4976:	71 0c 00 00 	mova	r12,	0(r1)	;
    497a:	b0 13 26 45 	calla	#17702		;0x04526

0000497e <.LVL138>:
  chEvtSignalI(tp, mask);
    497e:	0d 48       	mov	r8,	r13	;
    4980:	0e 49       	mov	r9,	r14	;
    4982:	0c 01       	mova	@r1,	r12	;
    4984:	b0 13 98 49 	calla	#18840		;0x04998

00004988 <.LVL139>:
  chSchRescheduleS();
    4988:	b0 13 de 47 	calla	#18398		;0x047de

0000498c <.LVL140>:
  chSysUnlock();
    498c:	b0 13 1c 45 	calla	#17692		;0x0451c

00004990 <.LVL141>:
}
    4990:	a1 00 04 00 	adda	#4,	r1	;
    4994:	18 16       	popm.a	#2,	r9	;20-bit words
    4996:	10 01       	reta			;

00004998 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    4998:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000499a <.LCFI19>:
    499a:	ca 0c       	mova	r12,	r10	;

0000499c <.Loc.972.2>:

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
    499c:	9c 00 00 00 	cmpa	#0,	r12	;
    49a0:	08 20       	jnz	$+18     	;abs 0x49b2

000049a2 <.LBB127>:
  port_disable();
    49a2:	b0 13 26 45 	calla	#17702		;0x04526

000049a6 <.LVL144>:
  nil.dbg_panic_msg = reason;
    49a6:	81 18 f2 40 	movx.a	#65665,	&0x10786;0x10081
    49aa:	81 00 86 07 

000049ae <.L106>:
    49ae:	80 00 ae 49 	mova	#18862,	r0	;0x049ae

000049b2 <.L105>:

  tp->epmask |= mask;
    49b2:	1d dc 0c 00 	bis	12(r12),r13	;0x0000c

000049b6 <.LVL146>:
    49b6:	1e dc 0e 00 	bis	14(r12),r14	;0x0000e
    49ba:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
    49be:	8c 4e 0e 00 	mov	r14,	14(r12)	; 0x000e

000049c2 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49c2:	ec 92 04 00 	cmp.b	#4,	4(r12)	;r2 As==10
    49c6:	0a 20       	jnz	$+22     	;abs 0x49dc

000049c8 <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    49c8:	1d fc 06 00 	and	6(r12),	r13	;
    49cc:	1e fc 08 00 	and	8(r12),	r14	;

000049d0 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    49d0:	0d de       	bis	r14,	r13	;
    49d2:	0d 93       	cmp	#0,	r13	;r3 As==00
    49d4:	03 24       	jz	$+8      	;abs 0x49dc

000049d6 <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    49d6:	4d 43       	clr.b	r13		;
    49d8:	b0 13 28 47 	calla	#18216		;0x04728

000049dc <.L104>:
  }
}
    49dc:	0a 16       	popm.a	#1,	r10	;20-bit words
    49de:	10 01       	reta			;

000049e0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    49e0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000049e2 <.LCFI20>:
    49e2:	06 4c       	mov	r12,	r6	;
    49e4:	07 4d       	mov	r13,	r7	;
    49e6:	05 4e       	mov	r14,	r5	;

000049e8 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    49e8:	2a 01 7c 07 	mova	&67452,	r10	;0x1077c

000049ec <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    49ec:	b0 13 26 45 	calla	#17702		;0x04526

000049f0 <.LVL150>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    49f0:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    49f4:	08 f6       	and	r6,	r8	;
    49f6:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    49fa:	09 f7       	and	r7,	r9	;

000049fc <.LVL151>:
    49fc:	0c 48       	mov	r8,	r12	;
    49fe:	0c d9       	bis	r9,	r12	;
    4a00:	84 00 1c 45 	mova	#17692,	r4	;0x0451c
    4a04:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a06:	18 20       	jnz	$+50     	;abs 0x4a38

00004a08 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4a08:	35 93       	cmp	#-1,	r5	;r3 As==11
    4a0a:	05 20       	jnz	$+12     	;abs 0x4a16

00004a0c <.L117>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    4a0c:	44 13       	calla	r4		;

00004a0e <.LVL153>:

  return m;
}
    4a0e:	0c 48       	mov	r8,	r12	;
    4a10:	0d 49       	mov	r9,	r13	;
    4a12:	64 16       	popm.a	#7,	r10	;20-bit words
    4a14:	10 01       	reta			;

00004a16 <.L114>:
    ctp->u1.ewmask = mask;
    4a16:	8a 46 06 00 	mov	r6,	6(r10)	;
    4a1a:	8a 47 08 00 	mov	r7,	8(r10)	;

00004a1e <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4a1e:	0d 45       	mov	r5,	r13	;
    4a20:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4a22:	b0 13 ee 47 	calla	#18414		;0x047ee

00004a26 <.LVL155>:
    4a26:	9c 00 00 00 	cmpa	#0,	r12	;
    4a2a:	f0 3b       	jl	$-30     	;abs 0x4a0c

00004a2c <.Loc.1016.2>:
    m = ctp->epmask & mask;
    4a2c:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

00004a30 <.LVL156>:
    4a30:	08 f6       	and	r6,	r8	;
    4a32:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4a36:	09 f7       	and	r7,	r9	;

00004a38 <.L113>:
  ctp->epmask &= ~m;
    4a38:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    4a3c:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e
    4a40:	80 00 0c 4a 	mova	#18956,	r0	;0x04a0c

00004a44 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4a44:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a46 <.LCFI4>:
    4a46:	08 14       	pushm.a	#1,	r8	;20-bit words

00004a48 <.LCFI5>:
    4a48:	06 14       	pushm.a	#1,	r6	;20-bit words

00004a4a <.LCFI6>:
    4a4a:	ca 0c       	mova	r12,	r10	;
    4a4c:	c6 0d       	mova	r13,	r6	;
    4a4e:	08 4e       	mov	r14,	r8	;

00004a50 <.Loc.188.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);
    4a50:	9c 00 00 00 	cmpa	#0,	r12	;
    4a54:	04 20       	jnz	$+10     	;abs 0x4a5e

00004a56 <.Loc.188.1>:
    4a56:	8c 01 cc 00 	mova	#65740,	r12	;0x100cc

00004a5a <.LVL13>:
    4a5a:	b0 13 58 46 	calla	#18008		;0x04658

00004a5e <.L13>:

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4a5e:	0d 48       	mov	r8,	r13	;
    4a60:	cc 0a       	mova	r10,	r12	;
    4a62:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4a66:	b0 13 ae 48 	calla	#18606		;0x048ae

00004a6a <.LVL15>:
    4a6a:	c8 0c       	mova	r12,	r8	;

00004a6c <.LVL16>:
  if (rdymsg == MSG_OK) {
    4a6c:	9c 00 00 00 	cmpa	#0,	r12	;
    4a70:	17 20       	jnz	$+48     	;abs 0x4aa0

00004a72 <.LBB12>:
    *mbp->wrptr++ = msg;
    4a72:	3e 0a 08 00 	mova	8(r10),	r14	;
    4a76:	cc 0e       	mova	r14,	r12	;
    4a78:	ac 00 04 00 	adda	#4,	r12	;
    4a7c:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4a80:	7e 06 00 00 	mova	r6,	0(r14)	;

00004a84 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4a84:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4a88:	04 00 
    4a8a:	03 28       	jnc	$+8      	;abs 0x4a92

00004a8c <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4a8c:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4a90:	08 00 

00004a92 <.L15>:
    }
    chSemSignalI(&mbp->fullsem);
    4a92:	cc 0a       	mova	r10,	r12	;
    4a94:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4a98:	b0 13 00 49 	calla	#18688		;0x04900

00004a9c <.LVL18>:
    chSchRescheduleS();
    4a9c:	b0 13 de 47 	calla	#18398		;0x047de

00004aa0 <.L12>:
  }

  return rdymsg;
}
    4aa0:	cc 08       	mova	r8,	r12	;
    4aa2:	06 16       	popm.a	#1,	r6	;20-bit words
    4aa4:	08 16       	popm.a	#1,	r8	;20-bit words
    4aa6:	0a 16       	popm.a	#1,	r10	;20-bit words
    4aa8:	10 01       	reta			;

00004aaa <chMBPost>:
  _disable_interrupts();
    4aaa:	32 c2       	dint			
    4aac:	03 43       	nop			

00004aae <.Loc.348.2>:
  asm volatile("nop");
    4aae:	03 43       	nop			

00004ab0 <.LBE18>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4ab0:	b0 13 44 4a 	calla	#19012		;0x04a44

00004ab4 <.LBB20>:
  asm volatile("nop");
    4ab4:	03 43       	nop			

00004ab6 <.Loc.356.2>:
  _enable_interrupts();
    4ab6:	03 43       	nop			
    4ab8:	32 d2       	eint			
    4aba:	03 43       	nop			

00004abc <.LBE20>:
}
    4abc:	10 01       	reta			;

00004abe <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4abe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ac0 <.LCFI7>:
    4ac0:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ac2 <.LCFI8>:
    4ac2:	ca 0c       	mova	r12,	r10	;
    4ac4:	c8 0d       	mova	r13,	r8	;

00004ac6 <.Loc.220.1>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);
    4ac6:	9c 00 00 00 	cmpa	#0,	r12	;
    4aca:	04 20       	jnz	$+10     	;abs 0x4ad4

00004acc <.Loc.220.1>:
    4acc:	8c 01 c2 00 	mova	#65730,	r12	;0x100c2

00004ad0 <.LVL23>:
    4ad0:	b0 13 58 46 	calla	#18008		;0x04658

00004ad4 <.L18>:

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    4ad4:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    4ad8:	4d 43       	clr.b	r13		;
    4ada:	0d 9c       	cmp	r12,	r13	;
    4adc:	1b 34       	jge	$+56     	;abs 0x4b14

00004ade <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4ade:	ba 53 12 00 	add	#-1,	18(r10)	;r3 As==11, 0x0012

00004ae2 <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4ae2:	3e 0a 08 00 	mova	8(r10),	r14	;
    4ae6:	cc 0e       	mova	r14,	r12	;
    4ae8:	ac 00 04 00 	adda	#4,	r12	;
    4aec:	7a 0c 08 00 	mova	r12,	8(r10)	;
    4af0:	7e 08 00 00 	mova	r8,	0(r14)	;

00004af4 <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4af4:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    4af8:	04 00 
    4afa:	03 28       	jnc	$+8      	;abs 0x4b02

00004afc <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4afc:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4b00:	08 00 

00004b02 <.L20>:
  }
  chSemSignalI(&mbp->fullsem);
    4b02:	cc 0a       	mova	r10,	r12	;
    4b04:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b08:	b0 13 00 49 	calla	#18688		;0x04900

00004b0c <.LVL25>:

  return MSG_OK;
    4b0c:	4c 43       	clr.b	r12		;

00004b0e <.L17>:
}
    4b0e:	08 16       	popm.a	#1,	r8	;20-bit words
    4b10:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b12:	10 01       	reta			;

00004b14 <.L21>:
    return MSG_TIMEOUT;
    4b14:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    4b18:	80 00 0e 4b 	mova	#19214,	r0	;0x04b0e

00004b1c <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4b1c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b1e <.LCFI14>:
    4b1e:	08 14       	pushm.a	#1,	r8	;20-bit words

00004b20 <.LCFI15>:
    4b20:	06 14       	pushm.a	#1,	r6	;20-bit words

00004b22 <.LCFI16>:
    4b22:	ca 0c       	mova	r12,	r10	;
    4b24:	c8 0d       	mova	r13,	r8	;
    4b26:	06 4e       	mov	r14,	r6	;

00004b28 <.Loc.387.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4b28:	9c 00 00 00 	cmpa	#0,	r12	;
    4b2c:	03 24       	jz	$+8      	;abs 0x4b34

00004b2e <.Loc.387.1>:
    4b2e:	9d 00 00 00 	cmpa	#0,	r13	;
    4b32:	04 20       	jnz	$+10     	;abs 0x4b3c

00004b34 <.L33>:
    4b34:	8c 01 99 00 	mova	#65689,	r12	;0x10099

00004b38 <.LVL41>:
    4b38:	b0 13 58 46 	calla	#18008		;0x04658

00004b3c <.L34>:

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4b3c:	0d 46       	mov	r6,	r13	;
    4b3e:	cc 0a       	mova	r10,	r12	;
    4b40:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b44:	b0 13 ae 48 	calla	#18606		;0x048ae

00004b48 <.LVL43>:
    4b48:	c6 0c       	mova	r12,	r6	;

00004b4a <.LVL44>:
  if (rdymsg == MSG_OK) {
    4b4a:	9c 00 00 00 	cmpa	#0,	r12	;
    4b4e:	18 20       	jnz	$+50     	;abs 0x4b80

00004b50 <.LBB36>:
    *msgp = *mbp->rdptr++;
    4b50:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4b54:	ce 0c       	mova	r12,	r14	;
    4b56:	ae 00 04 00 	adda	#4,	r14	;
    4b5a:	7a 0e 0c 00 	mova	r14,	12(r10)	; 0x0000c
    4b5e:	00 18 e8 4c 	movx.a	@r12,	0(r8)	;
    4b62:	00 00 

00004b64 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4b64:	00 18 5e 9a 	cmpx.a	4(r10),	r14	;
    4b68:	04 00 
    4b6a:	03 28       	jnc	$+8      	;abs 0x4b72

00004b6c <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4b6c:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4b70:	0c 00 

00004b72 <.L36>:
    }
    chSemSignalI(&mbp->emptysem);
    4b72:	cc 0a       	mova	r10,	r12	;
    4b74:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4b78:	b0 13 00 49 	calla	#18688		;0x04900

00004b7c <.LVL46>:
    chSchRescheduleS();
    4b7c:	b0 13 de 47 	calla	#18398		;0x047de

00004b80 <.L32>:
  }

  return rdymsg;
}
    4b80:	cc 06       	mova	r6,	r12	;
    4b82:	06 16       	popm.a	#1,	r6	;20-bit words
    4b84:	08 16       	popm.a	#1,	r8	;20-bit words
    4b86:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b88:	10 01       	reta			;

00004b8a <chMBFetch>:
  _disable_interrupts();
    4b8a:	32 c2       	dint			
    4b8c:	03 43       	nop			

00004b8e <.Loc.348.2>:
  asm volatile("nop");
    4b8e:	03 43       	nop			

00004b90 <.LBE42>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4b90:	b0 13 1c 4b 	calla	#19228		;0x04b1c

00004b94 <.LBB44>:
  asm volatile("nop");
    4b94:	03 43       	nop			

00004b96 <.Loc.356.2>:
  _enable_interrupts();
    4b96:	03 43       	nop			
    4b98:	32 d2       	eint			
    4b9a:	03 43       	nop			

00004b9c <.LBE44>:
}
    4b9c:	10 01       	reta			;

00004b9e <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    4b9e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ba0 <.LCFI0>:
    4ba0:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ba2 <.LCFI1>:
    4ba2:	ca 0c       	mova	r12,	r10	;
    4ba4:	40 18 08 4d 	movx.w	r13,	r8	;

00004ba8 <.Loc.112.1>:
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    4ba8:	0d 93       	cmp	#0,	r13	;r3 As==00
    4baa:	06 24       	jz	$+14     	;abs 0x4bb8

00004bac <.Loc.112.1>:
    4bac:	cc 08       	mova	r8,	r12	;

00004bae <.LVL1>:
    4bae:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4bb2:	00 18 4c b8 	bitx.a	r8,	r12	;
    4bb6:	04 24       	jz	$+10     	;abs 0x4bc0

00004bb8 <.L3>:
    4bb8:	8c 01 f0 00 	mova	#65776,	r12	;0x100f0
    4bbc:	b0 13 58 46 	calla	#18008		;0x04658

00004bc0 <.L4>:

  size = MEM_ALIGN_NEXT(size, align);
    4bc0:	ce 0a       	mova	r10,	r14	;
    4bc2:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    4bc6:	ee 08       	adda	r8,	r14	;
    4bc8:	00 18 4a 43 	clrx.a	r10		;
    4bcc:	fa 08       	suba	r8,	r10	;

00004bce <.LVL3>:
    4bce:	00 18 4e fa 	andx.a	r10,	r14	;

00004bd2 <.LVL4>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    4bd2:	2c 00 a4 a7 	mova	&42916,	r12	;0x0a7a4
    4bd6:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4bda:	ec 08       	adda	r8,	r12	;
    4bdc:	00 18 4c fa 	andx.a	r10,	r12	;

00004be0 <.LVL5>:

  if (((size_t)endmem - (size_t)p) < size) {
    4be0:	2a 00 a0 a7 	mova	&42912,	r10	;0x0a7a0
    4be4:	fa 0c       	suba	r12,	r10	;
    4be6:	da 0e       	cmpa	r14,	r10	;
    4be8:	06 28       	jnc	$+14     	;abs 0x4bf6

00004bea <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    4bea:	ee 0c       	adda	r12,	r14	;

00004bec <.LVL6>:
    4bec:	60 0e a4 a7 	mova	r14,	&42916	; 0x0a7a4

00004bf0 <.L2>:

  return p;
}
    4bf0:	08 16       	popm.a	#1,	r8	;20-bit words
    4bf2:	0a 16       	popm.a	#1,	r10	;20-bit words
    4bf4:	10 01       	reta			;

00004bf6 <.L6>:
    return NULL;
    4bf6:	4c 43       	clr.b	r12		;

00004bf8 <.LVL9>:
    4bf8:	80 00 f0 4b 	mova	#19440,	r0	;0x04bf0

00004bfc <chCoreAllocAligned>:
  _disable_interrupts();
    4bfc:	32 c2       	dint			
    4bfe:	03 43       	nop			

00004c00 <.Loc.348.2>:
  asm volatile("nop");
    4c00:	03 43       	nop			

00004c02 <.LBE6>:
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  void *p;

  chSysLock();
  p = chCoreAllocAlignedI(size, align);
    4c02:	b0 13 9e 4b 	calla	#19358		;0x04b9e

00004c06 <.LBB8>:
  asm volatile("nop");
    4c06:	03 43       	nop			

00004c08 <.Loc.356.2>:
  _enable_interrupts();
    4c08:	03 43       	nop			
    4c0a:	32 d2       	eint			
    4c0c:	03 43       	nop			

00004c0e <.LBE8>:
  chSysUnlock();

  return p;
}
    4c0e:	10 01       	reta			;

00004c10 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    4c10:	8c 00 a8 a7 	mova	#42920,	r12	;0x0a7a8
    4c14:	00 18 fc 40 	movx.a	#19452,	0(r12)	;0x04bfc
    4c18:	fc 4b 00 00 

00004c1c <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    4c1c:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4c20:	04 00 

00004c22 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    4c22:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    4c26:	fc f0 f0 ff 	and.b	#-16,	10(r12)	;#0xfff0, 0x000a
    4c2a:	0a 00 

00004c2c <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    4c2c:	9c 43 0c 00 	mov	#1,	12(r12)	;r3 As==01, 0x000c

00004c30 <.Loc.117.1>:
#endif
}
    4c30:	10 01       	reta			;

00004c32 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    4c32:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c34 <.LCFI0>:
    4c34:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c36 <.LCFI1>:
    4c36:	b1 00 04 00 	suba	#4,	r1	;

00004c3a <.LCFI2>:
    4c3a:	ca 0c       	mova	r12,	r10	;
    4c3c:	71 0d 00 00 	mova	r13,	0(r1)	;
    4c40:	c8 0e       	mova	r14,	r8	;

00004c42 <.Loc.78.1>:

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    4c42:	9c 00 00 00 	cmpa	#0,	r12	;
    4c46:	04 24       	jz	$+10     	;abs 0x4c50

00004c48 <.Loc.78.1>:
    4c48:	7c 40 03 00 	mov.b	#3,	r12	;

00004c4c <.LVL1>:
    4c4c:	dc 0d       	cmpa	r13,	r12	;
    4c4e:	04 28       	jnc	$+10     	;abs 0x4c58

00004c50 <.L2>:
    4c50:	8c 01 44 01 	mova	#65860,	r12	;0x10144
    4c54:	b0 13 58 46 	calla	#18008		;0x04658

00004c58 <.L3>:

  mp->next = NULL;
    4c58:	00 18 ca 43 	movx.a	#0,	0(r10)	;r3 As==00
    4c5c:	00 00 

00004c5e <.Loc.81.1>:
  mp->object_size = size;
    4c5e:	aa 41 04 00 	mov	@r1,	4(r10)	;
    4c62:	0d 01       	mova	@r1,	r13	;
    4c64:	0d 14       	pushm.a	#1,	r13	;20-bit words
    4c66:	0c 17       	popm	#1,	r12	;16-bit words
    4c68:	0c 17       	popm	#1,	r12	;16-bit words
    4c6a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4c6e:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    4c72:	7d f0 f0 ff 	and.b	#-16,	r13	;#0xfff0
    4c76:	4d dc       	bis.b	r12,	r13	;
    4c78:	ca 4d 06 00 	mov.b	r13,	6(r10)	;

00004c7c <.Loc.82.1>:
  mp->provider = provider;
    4c7c:	7a 08 08 00 	mova	r8,	8(r10)	;

00004c80 <.Loc.83.1>:
}
    4c80:	a1 00 04 00 	adda	#4,	r1	;

00004c84 <.LVL3>:
    4c84:	08 16       	popm.a	#1,	r8	;20-bit words
    4c86:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c88:	10 01       	reta			;

00004c8a <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4c8a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c8c <.LCFI3>:
    4c8c:	ca 0c       	mova	r12,	r10	;

00004c8e <.Loc.125.1>:
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);
    4c8e:	9c 00 00 00 	cmpa	#0,	r12	;
    4c92:	04 20       	jnz	$+10     	;abs 0x4c9c

00004c94 <.Loc.125.1>:
    4c94:	8c 01 27 01 	mova	#65831,	r12	;0x10127

00004c98 <.LVL5>:
    4c98:	b0 13 58 46 	calla	#18008		;0x04658

00004c9c <.L8>:

  objp = mp->next;
    4c9c:	0c 0a       	mova	@r10,	r12	;

00004c9e <.LVL7>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4c9e:	9c 00 00 00 	cmpa	#0,	r12	;
    4ca2:	05 24       	jz	$+12     	;abs 0x4cae

00004ca4 <.Loc.130.1>:
    mp->next = mp->next->next;
    4ca4:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4ca8:	00 00 

00004caa <.L7>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4caa:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cac:	10 01       	reta			;

00004cae <.L9>:
  else if (mp->provider != NULL) {
    4cae:	3e 0a 08 00 	mova	8(r10),	r14	;
    4cb2:	9e 00 00 00 	cmpa	#0,	r14	;
    4cb6:	f9 27       	jz	$-12     	;abs 0x4caa

00004cb8 <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4cb8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4cba:	3c 0a 04 00 	mova	4(r10),	r12	;

00004cbe <.LVL8>:
    4cbe:	4e 13       	calla	r14		;

00004cc0 <.LVL9>:
  return objp;
    4cc0:	80 00 aa 4c 	mova	#19626,	r0	;0x04caa

00004cc4 <chPoolAlloc>:
  _disable_interrupts();
    4cc4:	32 c2       	dint			
    4cc6:	03 43       	nop			

00004cc8 <.Loc.348.2>:
  asm volatile("nop");
    4cc8:	03 43       	nop			

00004cca <.LBE10>:
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
    4cca:	b0 13 8a 4c 	calla	#19594		;0x04c8a

00004cce <.LBB12>:
  asm volatile("nop");
    4cce:	03 43       	nop			

00004cd0 <.Loc.356.2>:
  _enable_interrupts();
    4cd0:	03 43       	nop			
    4cd2:	32 d2       	eint			
    4cd4:	03 43       	nop			

00004cd6 <.LBE12>:
  chSysUnlock();

  return objp;
}
    4cd6:	10 01       	reta			;

00004cd8 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4cd8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cda <.LCFI4>:
    4cda:	08 14       	pushm.a	#1,	r8	;20-bit words

00004cdc <.LCFI5>:
    4cdc:	ca 0c       	mova	r12,	r10	;
    4cde:	c8 0d       	mova	r13,	r8	;

00004ce0 <.LVL13>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
    4ce0:	9c 00 00 00 	cmpa	#0,	r12	;
    4ce4:	03 24       	jz	$+8      	;abs 0x4cec

00004ce6 <.Loc.176.1>:
    4ce6:	9d 00 00 00 	cmpa	#0,	r13	;
    4cea:	04 20       	jnz	$+10     	;abs 0x4cf4

00004cec <.L15>:
    4cec:	8c 01 1b 01 	mova	#65819,	r12	;0x1011b

00004cf0 <.LVL14>:
    4cf0:	b0 13 58 46 	calla	#18008		;0x04658

00004cf4 <.L16>:

  php->next = mp->next;
    4cf4:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4cf8:	00 00 

00004cfa <.Loc.179.1>:
  mp->next = php;
    4cfa:	7a 08 00 00 	mova	r8,	0(r10)	;

00004cfe <.Loc.180.1>:
}
    4cfe:	08 16       	popm.a	#1,	r8	;20-bit words
    4d00:	0a 16       	popm.a	#1,	r10	;20-bit words
    4d02:	10 01       	reta			;

00004d04 <chPoolFree>:
  _disable_interrupts();
    4d04:	32 c2       	dint			
    4d06:	03 43       	nop			

00004d08 <.Loc.348.2>:
  asm volatile("nop");
    4d08:	03 43       	nop			

00004d0a <.LBE18>:
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
    4d0a:	b0 13 d8 4c 	calla	#19672		;0x04cd8

00004d0e <.LBB20>:
  asm volatile("nop");
    4d0e:	03 43       	nop			

00004d10 <.Loc.356.2>:
  _enable_interrupts();
    4d10:	03 43       	nop			
    4d12:	32 d2       	eint			
    4d14:	03 43       	nop			

00004d16 <.LBE20>:
  chSysUnlock();
}
    4d16:	10 01       	reta			;

00004d18 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4d18:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004d1a <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4d1a:	7d 01 00 00 	mova	r1,	0(r13)	;

00004d1e <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4d1e:	01 0c       	mova	@r12,	r1	;

00004d20 <.Loc.76.1>:
  asm volatile ("popm.a #6, R9");
    4d20:	54 16       	popm.a	#6,	r9	;20-bit words

00004d22 <.Loc.77.1>:
  asm volatile ("popx.a R10");
    4d22:	00 18 7a 41 	popx.a	r10		;

00004d26 <.Loc.78.1>:
  asm volatile ("reta");
    4d26:	10 01       	reta			;

00004d28 <_port_thread_start>:
  asm volatile("nop");
    4d28:	03 43       	nop			

00004d2a <.Loc.356.2>:
  _enable_interrupts();
    4d2a:	03 43       	nop			
    4d2c:	32 d2       	eint			
    4d2e:	03 43       	nop			

00004d30 <.LBE4>:
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4d30:	cc 05       	mova	r5,	r12	;

00004d32 <.Loc.99.1>:
  asm volatile ("calla R4");
    4d32:	44 13       	calla	r4		;

00004d34 <.Loc.108.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4d34:	4c 43       	clr.b	r12		;
    4d36:	b0 13 58 46 	calla	#18008		;0x04658

00004d3a <.LVL1>:
#endif
}
    4d3a:	10 01       	reta			;

00004d3c <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4d3c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004d3e <.LCFI0>:
    4d3e:	06 14       	pushm.a	#1,	r6	;20-bit words

00004d40 <.LCFI1>:
    4d40:	04 14       	pushm.a	#1,	r4	;20-bit words

00004d42 <.LCFI2>:
    4d42:	c6 0c       	mova	r12,	r6	;
    4d44:	c4 0d       	mova	r13,	r4	;

00004d46 <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4d46:	2c 4c       	mov	@r12,	r12	;

00004d48 <.LVL2>:
    4d48:	0c 93       	cmp	#0,	r12	;r3 As==00
    4d4a:	18 34       	jge	$+50     	;abs 0x4d7c
    4d4c:	8a 01 8a 07 	mova	#67466,	r10	;0x1078a

00004d50 <.LBB2>:
        (void) chSchReadyI(tp, msg);
        return;
      }
      tp++;

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4d50:	88 00 58 46 	mova	#18008,	r8	;0x04658
    4d54:	89 01 6b 01 	mova	#65899,	r9	;0x1016b

00004d58 <.L3>:
      if (tp->u1.semp == sp) {
    4d58:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    4d5c:	06 00 
    4d5e:	12 20       	jnz	$+38     	;abs 0x4d84

00004d60 <.Loc.67.1>:
        sp->cnt++;
    4d60:	96 53 00 00 	inc	0(r6)		;

00004d64 <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4d64:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    4d68:	04 00 
    4d6a:	04 24       	jz	$+10     	;abs 0x4d74

00004d6c <.Loc.69.1>:
    4d6c:	8c 01 6b 01 	mova	#65899,	r12	;0x1016b
    4d70:	b0 13 58 46 	calla	#18008		;0x04658

00004d74 <.L5>:
        (void) chSchReadyI(tp, msg);
    4d74:	cd 04       	mova	r4,	r13	;
    4d76:	cc 0a       	mova	r10,	r12	;
    4d78:	b0 13 28 47 	calla	#18216		;0x04728

00004d7c <.L1>:
                  "pointer out of range");
    }
  }
}
    4d7c:	04 16       	popm.a	#1,	r4	;20-bit words
    4d7e:	06 16       	popm.a	#1,	r6	;20-bit words
    4d80:	28 16       	popm.a	#3,	r10	;20-bit words
    4d82:	10 01       	reta			;

00004d84 <.L4>:
      tp++;
    4d84:	aa 00 14 00 	adda	#20,	r10	;0x00014

00004d88 <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4d88:	9a 01 c6 07 	cmpa	#67526,	r10	;0x107c6
    4d8c:	e5 2b       	jnc	$-52     	;abs 0x4d58

00004d8e <.Loc.76.1>:
    4d8e:	cc 09       	mova	r9,	r12	;
    4d90:	48 13       	calla	r8		;

00004d92 <.LVL8>:
    4d92:	80 00 58 4d 	mova	#19800,	r0	;0x04d58

00004d96 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4d96:	b0 13 32 55 	calla	#21810		;0x05532

00004d9a <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4d9a:	8c 01 54 04 	mova	#66644,	r12	;0x10454
    4d9e:	b0 13 06 59 	calla	#22790		;0x05906

00004da2 <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4da2:	b0 13 86 52 	calla	#21126		;0x05286

00004da6 <.LVL2>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    4da6:	b0 13 e2 52 	calla	#21218		;0x052e2

00004daa <.LVL3>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    4daa:	b0 13 e2 53 	calla	#21474		;0x053e2

00004dae <.LVL4>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4dae:	b0 13 2c 55 	calla	#21804		;0x0552c

00004db2 <.LVL5>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4db2:	b0 13 c8 61 	calla	#25032		;0x061c8

00004db6 <.LVL6>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4db6:	b0 13 bc 4d 	calla	#19900		;0x04dbc

00004dba <.LVL7>:
#endif
}
    4dba:	10 01       	reta			;

00004dbc <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4dbc:	b0 13 82 55 	calla	#21890		;0x05582

00004dc0 <.LVL0>:
}
    4dc0:	10 01       	reta			;

00004dc2 <port_lock>:
  _disable_interrupts();
    4dc2:	32 c2       	dint			
    4dc4:	03 43       	nop			

00004dc6 <.Loc.348.1>:
  asm volatile("nop");
    4dc6:	03 43       	nop			

00004dc8 <.Loc.349.1>:
}
    4dc8:	10 01       	reta			;

00004dca <port_unlock>:
  asm volatile("nop");
    4dca:	03 43       	nop			

00004dcc <.Loc.356.1>:
  _enable_interrupts();
    4dcc:	03 43       	nop			
    4dce:	32 d2       	eint			
    4dd0:	03 43       	nop			

00004dd2 <.Loc.357.1>:
}
    4dd2:	10 01       	reta			;

00004dd4 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    4dd4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004dd6 <.LCFI0>:
    4dd6:	ca 0d       	mova	r13,	r10	;

00004dd8 <.LBB64>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    4dd8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00004ddc <.LBE64>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    4ddc:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    4de0:	bc f0 f0 ff 	and	#-16,	4(r12)	;#0xfff0
    4de4:	04 00 

00004de6 <.Loc.60.2>:
  iqp->q_buffer  = bp;
    4de6:	7c 0d 06 00 	mova	r13,	6(r12)	;

00004dea <.Loc.61.2>:
  iqp->q_rdptr   = bp;
    4dea:	7c 0d 12 00 	mova	r13,	18(r12)	; 0x00012

00004dee <.Loc.62.2>:
  iqp->q_wrptr   = bp;
    4dee:	7c 0d 0e 00 	mova	r13,	14(r12)	; 0x0000e

00004df2 <.Loc.63.2>:
  iqp->q_top     = bp + size;
    4df2:	ea 0e       	adda	r14,	r10	;
    4df4:	7c 0a 0a 00 	mova	r10,	10(r12)	; 0x0000a

00004df8 <.Loc.64.2>:
  iqp->q_notify  = infy;
    4df8:	7c 0f 16 00 	mova	r15,	22(r12)	; 0x00016

00004dfc <.Loc.65.2>:
  iqp->q_link    = link;
    4dfc:	00 18 dc 41 	movx.a	8(r1),	26(r12)	; 0x0001a
    4e00:	08 00 1a 00 

00004e04 <.Loc.66.2>:
}
    4e04:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e06:	10 01       	reta			;

00004e08 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    4e08:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e0a <.LCFI2>:
    4e0a:	b1 00 04 00 	suba	#4,	r1	;

00004e0e <.LCFI3>:
    4e0e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00004e12 <.Loc.106.2>:

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
    4e12:	3e 0c 0e 00 	mova	14(r12),r14	;0x0000e
    4e16:	00 18 5e 9c 	cmpx.a	18(r12),r14	;0x00012
    4e1a:	12 00 
    4e1c:	05 20       	jnz	$+12     	;abs 0x4e28

00004e1e <.Loc.106.2>:
    4e1e:	3a 0c 02 00 	mova	2(r12),	r10	;
    4e22:	9a 00 00 00 	cmpa	#0,	r10	;
    4e26:	2b 20       	jnz	$+88     	;abs 0x4e7e

00004e28 <.L6>:
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
    4e28:	3f 0c 02 00 	mova	2(r12),	r15	;
    4e2c:	af 00 01 00 	adda	#1,	r15	;
    4e30:	71 0f 00 00 	mova	r15,	0(r1)	;
    4e34:	8c 4f 02 00 	mov	r15,	2(r12)	;
    4e38:	1f 41 02 00 	mov	2(r1),	r15	;
    4e3c:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4e40:	1b 4c 04 00 	mov	4(r12),	r11	;
    4e44:	3b f0 f0 ff 	and	#-16,	r11	;#0xfff0
    4e48:	0b df       	bis	r15,	r11	;
    4e4a:	8c 4b 04 00 	mov	r11,	4(r12)	;

00004e4e <.Loc.111.2>:
  *iqp->q_wrptr++ = b;
    4e4e:	cf 0e       	mova	r14,	r15	;
    4e50:	af 00 01 00 	adda	#1,	r15	;
    4e54:	7c 0f 0e 00 	mova	r15,	14(r12)	; 0x0000e
    4e58:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00004e5c <.Loc.112.2>:
  if (iqp->q_wrptr >= iqp->q_top) {
    4e5c:	00 18 dc 9c 	cmpx.a	10(r12),14(r12)	;0x0000a, 0x0000e
    4e60:	0a 00 0e 00 
    4e64:	04 28       	jnc	$+10     	;abs 0x4e6e

00004e66 <.Loc.113.2>:
    iqp->q_wrptr = iqp->q_buffer;
    4e66:	00 18 dc 4c 	movx.a	6(r12),	14(r12)	; 0x0000e
    4e6a:	06 00 0e 00 

00004e6e <.L9>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    4e6e:	4d 43       	clr.b	r13		;

00004e70 <.LVL6>:
    4e70:	b0 13 3c 4d 	calla	#19772		;0x04d3c

00004e74 <.LVL7>:

  return MSG_OK;
    4e74:	4c 43       	clr.b	r12		;

00004e76 <.L5>:
}
    4e76:	a1 00 04 00 	adda	#4,	r1	;
    4e7a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e7c:	10 01       	reta			;

00004e7e <.L10>:
    return MSG_TIMEOUT;
    4e7e:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004e82 <.LVL9>:
    4e82:	80 00 76 4e 	mova	#20086,	r0	;0x04e76

00004e86 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    4e86:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004e88 <.LCFI4>:
    4e88:	b1 00 08 00 	suba	#8,	r1	;

00004e8c <.LCFI5>:
    4e8c:	ca 0c       	mova	r12,	r10	;
    4e8e:	09 4d       	mov	r13,	r9	;

00004e90 <.LBB66>:
  chSysLock();
    4e90:	b0 13 c2 4d 	calla	#19906		;0x04dc2

00004e94 <.LBB68>:
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chSemWaitTimeoutS(&tqp->sem, time);
    4e94:	88 00 ae 48 	mova	#18606,	r8	;0x048ae

00004e98 <.L12>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    4e98:	3c 0a 02 00 	mova	2(r10),	r12	;
    4e9c:	9c 00 00 00 	cmpa	#0,	r12	;
    4ea0:	30 24       	jz	$+98     	;abs 0x4f02

00004ea2 <.Loc.156.2>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    4ea2:	3c 0a 02 00 	mova	2(r10),	r12	;
    4ea6:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4eaa:	71 0c 04 00 	mova	r12,	4(r1)	;
    4eae:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4eb2:	1c 41 06 00 	mov	6(r1),	r12	;
    4eb6:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4eba:	1d 4a 04 00 	mov	4(r10),	r13	;
    4ebe:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4ec2:	0d dc       	bis	r12,	r13	;
    4ec4:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004ec8 <.Loc.157.2>:
  b = *iqp->q_rdptr++;
    4ec8:	3e 0a 12 00 	mova	18(r10),r14	;0x00012
    4ecc:	cc 0e       	mova	r14,	r12	;
    4ece:	ac 00 01 00 	adda	#1,	r12	;
    4ed2:	7a 0c 12 00 	mova	r12,	18(r10)	; 0x00012
    4ed6:	68 4e       	mov.b	@r14,	r8	;

00004ed8 <.LVL12>:
  if (iqp->q_rdptr >= iqp->q_top) {
    4ed8:	00 18 5c 9a 	cmpx.a	10(r10),r12	;0x0000a
    4edc:	0a 00 
    4ede:	04 28       	jnc	$+10     	;abs 0x4ee8

00004ee0 <.Loc.159.2>:
    iqp->q_rdptr = iqp->q_buffer;
    4ee0:	00 18 da 4a 	movx.a	6(r10),	18(r10)	; 0x00012
    4ee4:	06 00 12 00 

00004ee8 <.L15>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    4ee8:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    4eec:	9e 00 00 00 	cmpa	#0,	r14	;
    4ef0:	02 24       	jz	$+6      	;abs 0x4ef6

00004ef2 <.Loc.164.2>:
    iqp->q_notify(iqp);
    4ef2:	cc 0a       	mova	r10,	r12	;
    4ef4:	4e 13       	calla	r14		;

00004ef6 <.L16>:
  chSysUnlock();
    4ef6:	b0 13 ca 4d 	calla	#19914		;0x04dca

00004efa <.LBE75>:
  }

  osalSysUnlock();

  return (msg_t)b;
    4efa:	40 18 0c 48 	movx.w	r8,	r12	;
    4efe:	80 00 18 4f 	mova	#20248,	r0	;0x04f18

00004f02 <.L14>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4f02:	0d 49       	mov	r9,	r13	;
    4f04:	cc 0a       	mova	r10,	r12	;
    4f06:	48 13       	calla	r8		;

00004f08 <.LBE72>:
    if (msg < MSG_OK) {
    4f08:	9c 00 00 00 	cmpa	#0,	r12	;
    4f0c:	c5 37       	jge	$-116    	;abs 0x4e98

00004f0e <.LBB73>:
  chSysUnlock();
    4f0e:	71 0c 00 00 	mova	r12,	0(r1)	;
    4f12:	b0 13 ca 4d 	calla	#19914		;0x04dca

00004f16 <.LBE73>:
      return msg;
    4f16:	0c 01       	mova	@r1,	r12	;

00004f18 <.L11>:
}
    4f18:	a1 00 08 00 	adda	#8,	r1	;
    4f1c:	28 16       	popm.a	#3,	r10	;20-bit words
    4f1e:	10 01       	reta			;

00004f20 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    4f20:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004f22 <.LCFI6>:
    4f22:	b1 00 06 00 	suba	#6,	r1	;

00004f26 <.LCFI7>:
    4f26:	ca 0c       	mova	r12,	r10	;
    4f28:	c6 0d       	mova	r13,	r6	;
    4f2a:	c5 0e       	mova	r14,	r5	;
    4f2c:	09 4f       	mov	r15,	r9	;

00004f2e <.Loc.199.2>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    4f2e:	37 0c 16 00 	mova	22(r12),r7	;0x00016

00004f32 <.LVL20>:
  size_t r = 0;

  osalDbgCheck(n > 0U);
    4f32:	9e 00 00 00 	cmpa	#0,	r14	;
    4f36:	04 20       	jnz	$+10     	;abs 0x4f40

00004f38 <.Loc.202.2>:
    4f38:	8c 01 91 01 	mova	#65937,	r12	;0x10191

00004f3c <.LVL21>:
    4f3c:	b0 13 58 46 	calla	#18008		;0x04658

00004f40 <.L22>:
  chSysLock();
    4f40:	88 00 c2 4d 	mova	#19906,	r8	;0x04dc2
    4f44:	48 13       	calla	r8		;

00004f46 <.LBB80>:
  return chVTGetSystemTimeX();
    4f46:	8c 01 7c 07 	mova	#67452,	r12	;0x1077c

00004f4a <.LBE80>:
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    4f4a:	0d 49       	mov	r9,	r13	;
    4f4c:	1d 5c 08 00 	add	8(r12),	r13	;
    4f50:	81 4d 04 00 	mov	r13,	4(r1)	;

00004f54 <.LVL24>:
  size_t r = 0;
    4f54:	44 43       	clr.b	r4		;

00004f56 <.L23>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    4f56:	3c 0a 02 00 	mova	2(r10),	r12	;
    4f5a:	9c 00 00 00 	cmpa	#0,	r12	;
    4f5e:	3c 24       	jz	$+122    	;abs 0x4fd8

00004f60 <.Loc.243.2>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    4f60:	3c 0a 02 00 	mova	2(r10),	r12	;
    4f64:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4f68:	71 0c 00 00 	mova	r12,	0(r1)	;
    4f6c:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4f70:	1c 41 02 00 	mov	2(r1),	r12	;
    4f74:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4f78:	1d 4a 04 00 	mov	4(r10),	r13	;
    4f7c:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4f80:	0d dc       	bis	r12,	r13	;
    4f82:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004f86 <.Loc.244.2>:
    *bp++ = *iqp->q_rdptr++;
    4f86:	cd 06       	mova	r6,	r13	;
    4f88:	ad 00 01 00 	adda	#1,	r13	;
    4f8c:	71 0d 00 00 	mova	r13,	0(r1)	;

00004f90 <.LVL26>:
    4f90:	3c 0a 12 00 	mova	18(r10),r12	;0x00012
    4f94:	cd 0c       	mova	r12,	r13	;

00004f96 <.LVL27>:
    4f96:	ad 00 01 00 	adda	#1,	r13	;
    4f9a:	7a 0d 12 00 	mova	r13,	18(r10)	; 0x00012
    4f9e:	e6 4c 00 00 	mov.b	@r12,	0(r6)	;

00004fa2 <.Loc.245.2>:
    if (iqp->q_rdptr >= iqp->q_top) {
    4fa2:	00 18 da 9a 	cmpx.a	10(r10),18(r10)	;0x0000a, 0x00012
    4fa6:	0a 00 12 00 
    4faa:	04 28       	jnc	$+10     	;abs 0x4fb4

00004fac <.Loc.246.2>:
      iqp->q_rdptr = iqp->q_buffer;
    4fac:	00 18 da 4a 	movx.a	6(r10),	18(r10)	; 0x00012
    4fb0:	06 00 12 00 

00004fb4 <.L30>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    4fb4:	97 00 00 00 	cmpa	#0,	r7	;
    4fb8:	02 24       	jz	$+6      	;abs 0x4fbe

00004fba <.Loc.251.2>:
      nfy(iqp);
    4fba:	cc 0a       	mova	r10,	r12	;
    4fbc:	47 13       	calla	r7		;

00004fbe <.L31>:
  chSysUnlock();
    4fbe:	b0 13 ca 4d 	calla	#19914		;0x04dca

00004fc2 <.LBE82>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    4fc2:	a4 00 01 00 	adda	#1,	r4	;

00004fc6 <.Loc.258.2>:
    if (--n == 0U) {
    4fc6:	a5 0f ff ff 	adda	#1048575,r5	;0xfffff
    4fca:	95 00 00 00 	cmpa	#0,	r5	;
    4fce:	1d 24       	jz	$+60     	;abs 0x500a

00004fd0 <.LBB84>:
  chSysLock();
    4fd0:	48 13       	calla	r8		;

00004fd2 <.LBE84>:
    *bp++ = *iqp->q_rdptr++;
    4fd2:	06 01       	mova	@r1,	r6	;
    4fd4:	80 00 56 4f 	mova	#20310,	r0	;0x04f56

00004fd8 <.L29>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    4fd8:	0c 49       	mov	r9,	r12	;
    4fda:	3c 53       	add	#-1,	r12	;r3 As==11
    4fdc:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    4fe0:	0d 9c       	cmp	r12,	r13	;
    4fe2:	09 2c       	jc	$+20     	;abs 0x4ff6

00004fe4 <.LBB87>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4fe4:	0d 49       	mov	r9,	r13	;

00004fe6 <.L26>:
    4fe6:	cc 0a       	mova	r10,	r12	;
    4fe8:	b0 13 ae 48 	calla	#18606		;0x048ae

00004fec <.LBE89>:
      if (msg != MSG_OK) {
    4fec:	9c 00 00 00 	cmpa	#0,	r12	;
    4ff0:	b2 27       	jz	$-154    	;abs 0x4f56
    4ff2:	80 00 06 50 	mova	#20486,	r0	;0x05006

00004ff6 <.L24>:
  return chVTGetSystemTimeX();
    4ff6:	c0 18 1c 42 	movx.w	&0x10784,r12	;
    4ffa:	84 07 

00004ffc <.LBE92>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    4ffc:	1d 41 04 00 	mov	4(r1),	r13	;
    5000:	0d 8c       	sub	r12,	r13	;

00005002 <.LVL38>:
        if (next_timeout > timeout) {
    5002:	09 9d       	cmp	r13,	r9	;
    5004:	f0 2f       	jc	$-30     	;abs 0x4fe6

00005006 <.L41>:
  chSysUnlock();
    5006:	b0 13 ca 4d 	calla	#19914		;0x04dca

0000500a <.L21>:
      return r;
    }

    osalSysLock();
  }
}
    500a:	cc 04       	mova	r4,	r12	;
    500c:	a1 00 06 00 	adda	#6,	r1	;
    5010:	64 16       	popm.a	#7,	r10	;20-bit words
    5012:	10 01       	reta			;

00005014 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    5014:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005016 <.LCFI8>:
    5016:	b1 00 04 00 	suba	#4,	r1	;

0000501a <.LCFI9>:
    501a:	ca 0d       	mova	r13,	r10	;
    501c:	71 0e 00 00 	mova	r14,	0(r1)	;

00005020 <.LBB97>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    5020:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005024 <.LBE97>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
    5024:	ac 41 02 00 	mov	@r1,	2(r12)	;
    5028:	1d 41 02 00 	mov	2(r1),	r13	;

0000502c <.LVL44>:
    502c:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    5030:	1e 4c 04 00 	mov	4(r12),	r14	;

00005034 <.LVL45>:
    5034:	3e f0 f0 ff 	and	#-16,	r14	;#0xfff0
    5038:	0e dd       	bis	r13,	r14	;
    503a:	8c 4e 04 00 	mov	r14,	4(r12)	;

0000503e <.Loc.286.2>:
  oqp->q_buffer  = bp;
    503e:	7c 0a 06 00 	mova	r10,	6(r12)	;

00005042 <.Loc.287.2>:
  oqp->q_rdptr   = bp;
    5042:	7c 0a 12 00 	mova	r10,	18(r12)	; 0x00012

00005046 <.Loc.288.2>:
  oqp->q_wrptr   = bp;
    5046:	7c 0a 0e 00 	mova	r10,	14(r12)	; 0x0000e

0000504a <.Loc.289.2>:
  oqp->q_top     = bp + size;
    504a:	00 18 6a 51 	addx.a	@r1,	r10	;

0000504e <.LVL46>:
    504e:	7c 0a 0a 00 	mova	r10,	10(r12)	; 0x0000a

00005052 <.Loc.290.2>:
  oqp->q_notify  = onfy;
    5052:	7c 0f 16 00 	mova	r15,	22(r12)	; 0x00016

00005056 <.Loc.291.2>:
  oqp->q_link    = link;
    5056:	00 18 dc 41 	movx.a	12(r1),	26(r12)	;0x0000c, 0x0001a
    505a:	0c 00 1a 00 

0000505e <.Loc.292.2>:
}
    505e:	a1 00 04 00 	adda	#4,	r1	;

00005062 <.LVL47>:
    5062:	0a 16       	popm.a	#1,	r10	;20-bit words
    5064:	10 01       	reta			;

00005066 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    5066:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005068 <.LCFI12>:
    5068:	b1 00 08 00 	suba	#8,	r1	;

0000506c <.LCFI13>:
    506c:	ca 0c       	mova	r12,	r10	;
    506e:	49 4d       	mov.b	r13,	r9	;
    5070:	07 4e       	mov	r14,	r7	;

00005072 <.LBB99>:
  chSysLock();
    5072:	b0 13 c2 4d 	calla	#19906		;0x04dc2

00005076 <.LBB101>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    5076:	88 00 ae 48 	mova	#18606,	r8	;0x048ae

0000507a <.L45>:

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    507a:	3c 0a 02 00 	mova	2(r10),	r12	;
    507e:	9c 00 00 00 	cmpa	#0,	r12	;
    5082:	31 24       	jz	$+100    	;abs 0x50e6

00005084 <.Loc.351.2>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    5084:	3c 0a 02 00 	mova	2(r10),	r12	;
    5088:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    508c:	71 0c 04 00 	mova	r12,	4(r1)	;
    5090:	8a 4c 02 00 	mov	r12,	2(r10)	;
    5094:	1c 41 06 00 	mov	6(r1),	r12	;
    5098:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    509c:	1d 4a 04 00 	mov	4(r10),	r13	;
    50a0:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    50a4:	0d dc       	bis	r12,	r13	;
    50a6:	8a 4d 04 00 	mov	r13,	4(r10)	;

000050aa <.Loc.352.2>:
  *oqp->q_wrptr++ = b;
    50aa:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    50ae:	cd 0c       	mova	r12,	r13	;
    50b0:	ad 00 01 00 	adda	#1,	r13	;
    50b4:	7a 0d 0e 00 	mova	r13,	14(r10)	; 0x0000e
    50b8:	cc 49 00 00 	mov.b	r9,	0(r12)	;

000050bc <.Loc.353.2>:
  if (oqp->q_wrptr >= oqp->q_top) {
    50bc:	00 18 da 9a 	cmpx.a	10(r10),14(r10)	;0x0000a, 0x0000e
    50c0:	0a 00 0e 00 
    50c4:	04 28       	jnc	$+10     	;abs 0x50ce

000050c6 <.Loc.354.2>:
    oqp->q_wrptr = oqp->q_buffer;
    50c6:	00 18 da 4a 	movx.a	6(r10),	14(r10)	; 0x0000e
    50ca:	06 00 0e 00 

000050ce <.L48>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    50ce:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    50d2:	9e 00 00 00 	cmpa	#0,	r14	;
    50d6:	02 24       	jz	$+6      	;abs 0x50dc

000050d8 <.Loc.359.2>:
    oqp->q_notify(oqp);
    50d8:	cc 0a       	mova	r10,	r12	;
    50da:	4e 13       	calla	r14		;

000050dc <.L49>:
  chSysUnlock();
    50dc:	b0 13 ca 4d 	calla	#19914		;0x04dca

000050e0 <.LBE108>:
  }

  osalSysUnlock();

  return MSG_OK;
    50e0:	4c 43       	clr.b	r12		;
    50e2:	80 00 fc 50 	mova	#20732,	r0	;0x050fc

000050e6 <.L47>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    50e6:	0d 47       	mov	r7,	r13	;
    50e8:	cc 0a       	mova	r10,	r12	;
    50ea:	48 13       	calla	r8		;

000050ec <.LBE105>:
    if (msg < MSG_OK) {
    50ec:	9c 00 00 00 	cmpa	#0,	r12	;
    50f0:	c4 37       	jge	$-118    	;abs 0x507a

000050f2 <.LBB106>:
  chSysUnlock();
    50f2:	71 0c 00 00 	mova	r12,	0(r1)	;
    50f6:	b0 13 ca 4d 	calla	#19914		;0x04dca

000050fa <.LBE106>:
      return msg;
    50fa:	0c 01       	mova	@r1,	r12	;

000050fc <.L44>:
}
    50fc:	a1 00 08 00 	adda	#8,	r1	;
    5100:	37 16       	popm.a	#4,	r10	;20-bit words
    5102:	10 01       	reta			;

00005104 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    5104:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005106 <.LCFI14>:
    5106:	08 14       	pushm.a	#1,	r8	;20-bit words

00005108 <.LCFI15>:
    5108:	b1 00 04 00 	suba	#4,	r1	;

0000510c <.LCFI16>:
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
    510c:	3e 0c 12 00 	mova	18(r12),r14	;0x00012
    5110:	00 18 cc 9e 	cmpx.a	r14,	14(r12)	; 0x0000e
    5114:	0e 00 
    5116:	05 20       	jnz	$+12     	;abs 0x5122

00005118 <.Loc.382.2>:
    5118:	3a 0c 02 00 	mova	2(r12),	r10	;
    511c:	9a 00 00 00 	cmpa	#0,	r10	;
    5120:	2b 20       	jnz	$+88     	;abs 0x5178

00005122 <.L55>:
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
    5122:	3d 0c 02 00 	mova	2(r12),	r13	;
    5126:	ad 00 01 00 	adda	#1,	r13	;
    512a:	71 0d 00 00 	mova	r13,	0(r1)	;
    512e:	8c 4d 02 00 	mov	r13,	2(r12)	;
    5132:	1d 41 02 00 	mov	2(r1),	r13	;
    5136:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    513a:	1f 4c 04 00 	mov	4(r12),	r15	;
    513e:	3f f0 f0 ff 	and	#-16,	r15	;#0xfff0
    5142:	0f dd       	bis	r13,	r15	;
    5144:	8c 4f 04 00 	mov	r15,	4(r12)	;

00005148 <.Loc.387.2>:
  b = *oqp->q_rdptr++;
    5148:	c8 0e       	mova	r14,	r8	;
    514a:	a8 00 01 00 	adda	#1,	r8	;
    514e:	7c 08 12 00 	mova	r8,	18(r12)	; 0x00012
    5152:	6a 4e       	mov.b	@r14,	r10	;

00005154 <.LVL58>:
  if (oqp->q_rdptr >= oqp->q_top) {
    5154:	00 18 58 9c 	cmpx.a	10(r12),r8	;0x0000a
    5158:	0a 00 
    515a:	04 28       	jnc	$+10     	;abs 0x5164

0000515c <.Loc.389.2>:
    oqp->q_rdptr = oqp->q_buffer;
    515c:	00 18 dc 4c 	movx.a	6(r12),	18(r12)	; 0x00012
    5160:	06 00 12 00 

00005164 <.L58>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    5164:	4d 43       	clr.b	r13		;
    5166:	b0 13 3c 4d 	calla	#19772		;0x04d3c

0000516a <.LVL60>:

  return (msg_t)b;
    516a:	40 18 0c 4a 	movx.w	r10,	r12	;

0000516e <.L54>:
}
    516e:	a1 00 04 00 	adda	#4,	r1	;
    5172:	08 16       	popm.a	#1,	r8	;20-bit words
    5174:	0a 16       	popm.a	#1,	r10	;20-bit words
    5176:	10 01       	reta			;

00005178 <.L59>:
    return MSG_TIMEOUT;
    5178:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000517c <.LVL63>:
    517c:	80 00 6e 51 	mova	#20846,	r0	;0x0516e

00005180 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    5180:	6a 14       	pushm.a	#7,	r10	;20-bit words

00005182 <.LCFI17>:
    5182:	b1 00 06 00 	suba	#6,	r1	;

00005186 <.LCFI18>:
    5186:	ca 0c       	mova	r12,	r10	;
    5188:	c6 0d       	mova	r13,	r6	;
    518a:	c5 0e       	mova	r14,	r5	;
    518c:	09 4f       	mov	r15,	r9	;

0000518e <.Loc.424.2>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    518e:	37 0c 16 00 	mova	22(r12),r7	;0x00016

00005192 <.LVL65>:
  size_t w = 0;

  osalDbgCheck(n > 0U);
    5192:	9e 00 00 00 	cmpa	#0,	r14	;
    5196:	04 20       	jnz	$+10     	;abs 0x51a0

00005198 <.Loc.427.2>:
    5198:	8c 01 82 01 	mova	#65922,	r12	;0x10182

0000519c <.LVL66>:
    519c:	b0 13 58 46 	calla	#18008		;0x04658

000051a0 <.L61>:
  chSysLock();
    51a0:	88 00 c2 4d 	mova	#19906,	r8	;0x04dc2
    51a4:	48 13       	calla	r8		;

000051a6 <.LBB113>:
  return chVTGetSystemTimeX();
    51a6:	8c 01 7c 07 	mova	#67452,	r12	;0x1077c

000051aa <.LBE113>:
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    51aa:	0d 49       	mov	r9,	r13	;
    51ac:	1d 5c 08 00 	add	8(r12),	r13	;
    51b0:	81 4d 04 00 	mov	r13,	4(r1)	;

000051b4 <.LVL69>:
  size_t w = 0;
    51b4:	44 43       	clr.b	r4		;

000051b6 <.L62>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    51b6:	3c 0a 02 00 	mova	2(r10),	r12	;
    51ba:	9c 00 00 00 	cmpa	#0,	r12	;
    51be:	3c 24       	jz	$+122    	;abs 0x5238

000051c0 <.Loc.467.2>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    51c0:	3c 0a 02 00 	mova	2(r10),	r12	;
    51c4:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    51c8:	71 0c 00 00 	mova	r12,	0(r1)	;
    51cc:	8a 4c 02 00 	mov	r12,	2(r10)	;
    51d0:	1c 41 02 00 	mov	2(r1),	r12	;
    51d4:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    51d8:	1d 4a 04 00 	mov	4(r10),	r13	;
    51dc:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    51e0:	0d dc       	bis	r12,	r13	;
    51e2:	8a 4d 04 00 	mov	r13,	4(r10)	;

000051e6 <.Loc.468.2>:
    *oqp->q_wrptr++ = *bp++;
    51e6:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    51ea:	cd 0c       	mova	r12,	r13	;
    51ec:	ad 00 01 00 	adda	#1,	r13	;
    51f0:	7a 0d 0e 00 	mova	r13,	14(r10)	; 0x0000e
    51f4:	cd 06       	mova	r6,	r13	;
    51f6:	ad 00 01 00 	adda	#1,	r13	;
    51fa:	71 0d 00 00 	mova	r13,	0(r1)	;

000051fe <.LVL71>:
    51fe:	ec 46 00 00 	mov.b	@r6,	0(r12)	;

00005202 <.Loc.469.2>:
    if (oqp->q_wrptr >= oqp->q_top) {
    5202:	00 18 da 9a 	cmpx.a	10(r10),14(r10)	;0x0000a, 0x0000e
    5206:	0a 00 0e 00 
    520a:	04 28       	jnc	$+10     	;abs 0x5214

0000520c <.Loc.470.2>:
      oqp->q_wrptr = oqp->q_buffer;
    520c:	00 18 da 4a 	movx.a	6(r10),	14(r10)	; 0x0000e
    5210:	06 00 0e 00 

00005214 <.L69>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    5214:	97 00 00 00 	cmpa	#0,	r7	;
    5218:	02 24       	jz	$+6      	;abs 0x521e

0000521a <.Loc.475.2>:
      nfy(oqp);
    521a:	cc 0a       	mova	r10,	r12	;
    521c:	47 13       	calla	r7		;

0000521e <.L70>:
  chSysUnlock();
    521e:	b0 13 ca 4d 	calla	#19914		;0x04dca

00005222 <.LBE116>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    5222:	a4 00 01 00 	adda	#1,	r4	;

00005226 <.Loc.482.2>:
    if (--n == 0U) {
    5226:	a5 0f ff ff 	adda	#1048575,r5	;0xfffff
    522a:	95 00 00 00 	cmpa	#0,	r5	;
    522e:	1d 24       	jz	$+60     	;abs 0x526a

00005230 <.LBB118>:
  chSysLock();
    5230:	48 13       	calla	r8		;

00005232 <.LBE118>:
    *oqp->q_wrptr++ = *bp++;
    5232:	06 01       	mova	@r1,	r6	;
    5234:	80 00 b6 51 	mova	#20918,	r0	;0x051b6

00005238 <.L68>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    5238:	0c 49       	mov	r9,	r12	;
    523a:	3c 53       	add	#-1,	r12	;r3 As==11
    523c:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    5240:	0d 9c       	cmp	r12,	r13	;
    5242:	09 2c       	jc	$+20     	;abs 0x5256

00005244 <.LBB120>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    5244:	0d 49       	mov	r9,	r13	;

00005246 <.L65>:
    5246:	cc 0a       	mova	r10,	r12	;
    5248:	b0 13 ae 48 	calla	#18606		;0x048ae

0000524c <.LBE122>:
      if (msg != MSG_OK) {
    524c:	9c 00 00 00 	cmpa	#0,	r12	;
    5250:	b2 27       	jz	$-154    	;abs 0x51b6
    5252:	80 00 66 52 	mova	#21094,	r0	;0x05266

00005256 <.L63>:
  return chVTGetSystemTimeX();
    5256:	c0 18 1c 42 	movx.w	&0x10784,r12	;
    525a:	84 07 

0000525c <.LBE125>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    525c:	1d 41 04 00 	mov	4(r1),	r13	;
    5260:	0d 8c       	sub	r12,	r13	;

00005262 <.LVL82>:
        if (next_timeout > timeout) {
    5262:	09 9d       	cmp	r13,	r9	;
    5264:	f0 2f       	jc	$-30     	;abs 0x5246

00005266 <.L80>:
  chSysUnlock();
    5266:	b0 13 ca 4d 	calla	#19914		;0x04dca

0000526a <.L60>:
      return w;
    }

    osalSysLock();
  }
}
    526a:	cc 04       	mova	r4,	r12	;
    526c:	a1 00 06 00 	adda	#6,	r1	;
    5270:	64 16       	popm.a	#7,	r10	;20-bit words
    5272:	10 01       	reta			;

00005274 <port_lock>:
  _disable_interrupts();
    5274:	32 c2       	dint			
    5276:	03 43       	nop			

00005278 <.Loc.348.1>:
  asm volatile("nop");
    5278:	03 43       	nop			

0000527a <.Loc.349.1>:
}
    527a:	10 01       	reta			;

0000527c <port_unlock>:
  asm volatile("nop");
    527c:	03 43       	nop			

0000527e <.Loc.356.1>:
  _enable_interrupts();
    527e:	03 43       	nop			
    5280:	32 d2       	eint			
    5282:	03 43       	nop			

00005284 <.Loc.357.1>:
}
    5284:	10 01       	reta			;

00005286 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    5286:	b0 13 c8 60 	calla	#24776		;0x060c8

0000528a <.LVL0>:
}
    528a:	10 01       	reta			;

0000528c <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    528c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00005290 <.Loc.71.2>:
  gptp->config = NULL;
    5290:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    5294:	02 00 

00005296 <.Loc.72.2>:
}
    5296:	10 01       	reta			;

00005298 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    5298:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000529a <.LCFI0>:
    529a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000529c <.LCFI1>:
    529c:	ca 0c       	mova	r12,	r10	;
    529e:	c8 0d       	mova	r13,	r8	;

000052a0 <.Loc.84.2>:

  osalDbgCheck((gptp != NULL) && (config != NULL));
    52a0:	9c 00 00 00 	cmpa	#0,	r12	;
    52a4:	03 24       	jz	$+8      	;abs 0x52ac

000052a6 <.Loc.84.2>:
    52a6:	9d 00 00 00 	cmpa	#0,	r13	;
    52aa:	04 20       	jnz	$+10     	;abs 0x52b4

000052ac <.L6>:
    52ac:	8c 01 fb 01 	mova	#66043,	r12	;0x101fb

000052b0 <.LVL3>:
    52b0:	b0 13 58 46 	calla	#18008		;0x04658

000052b4 <.L7>:
  chSysLock();
    52b4:	b0 13 74 52 	calla	#21108		;0x05274

000052b8 <.LBE26>:

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    52b8:	6c 4a       	mov.b	@r10,	r12	;
    52ba:	7c 53       	add.b	#-1,	r12	;r3 As==11
    52bc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    52be:	4d 9c       	cmp.b	r12,	r13	;
    52c0:	04 2c       	jc	$+10     	;abs 0x52ca

000052c2 <.Loc.87.2>:
    52c2:	8c 01 fb 01 	mova	#66043,	r12	;0x101fb
    52c6:	b0 13 58 46 	calla	#18008		;0x04658

000052ca <.L8>:
              "invalid state");
  gptp->config = config;
    52ca:	7a 08 02 00 	mova	r8,	2(r10)	;

000052ce <.Loc.90.2>:
  gpt_lld_start(gptp);
    52ce:	cc 0a       	mova	r10,	r12	;
    52d0:	b0 13 ee 60 	calla	#24814		;0x060ee

000052d4 <.LVL7>:
  gptp->state = GPT_READY;
    52d4:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000052d8 <.LBB28>:
  chSysUnlock();
    52d8:	b0 13 7c 52 	calla	#21116		;0x0527c

000052dc <.LBE28>:
  osalSysUnlock();
}
    52dc:	08 16       	popm.a	#1,	r8	;20-bit words
    52de:	0a 16       	popm.a	#1,	r10	;20-bit words
    52e0:	10 01       	reta			;

000052e2 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    52e2:	b0 13 42 5b 	calla	#23362		;0x05b42

000052e6 <.LVL0>:
}
    52e6:	10 01       	reta			;

000052e8 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    52e8:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000052ec <.Loc.74.1>:
  i2cp->config = NULL;
    52ec:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    52f0:	02 00 

000052f2 <.Loc.83.1>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    52f2:	10 01       	reta			;

000052f4 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    52f4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052f6 <.LCFI0>:
    52f6:	08 14       	pushm.a	#1,	r8	;20-bit words

000052f8 <.LCFI1>:
    52f8:	ca 0c       	mova	r12,	r10	;
    52fa:	c8 0d       	mova	r13,	r8	;

000052fc <.Loc.95.1>:

  osalDbgCheck((i2cp != NULL) && (config != NULL));
    52fc:	9c 00 00 00 	cmpa	#0,	r12	;
    5300:	03 24       	jz	$+8      	;abs 0x5308

00005302 <.Loc.95.1>:
    5302:	9d 00 00 00 	cmpa	#0,	r13	;
    5306:	04 20       	jnz	$+10     	;abs 0x5310

00005308 <.L4>:
    5308:	8c 01 4a 02 	mova	#66122,	r12	;0x1024a

0000530c <.LVL3>:
    530c:	b0 13 58 46 	calla	#18008		;0x04658

00005310 <.L5>:
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    5310:	6c 4a       	mov.b	@r10,	r12	;
    5312:	4d 4c       	mov.b	r12,	r13	;
    5314:	7d 53       	add.b	#-1,	r13	;r3 As==11
    5316:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5318:	4e 9d       	cmp.b	r13,	r14	;
    531a:	07 2c       	jc	$+16     	;abs 0x532a

0000531c <.Loc.96.1>:
    531c:	3c 90 05 00 	cmp	#5,	r12	;
    5320:	04 24       	jz	$+10     	;abs 0x532a

00005322 <.Loc.96.1>:
    5322:	8c 01 4a 02 	mova	#66122,	r12	;0x1024a
    5326:	b0 13 58 46 	calla	#18008		;0x04658

0000532a <.L6>:
  _disable_interrupts();
    532a:	32 c2       	dint			
    532c:	03 43       	nop			

0000532e <.Loc.348.2>:
  asm volatile("nop");
    532e:	03 43       	nop			

00005330 <.LBE26>:
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    5330:	7a 08 02 00 	mova	r8,	2(r10)	;

00005334 <.Loc.101.1>:
  i2c_lld_start(i2cp);
    5334:	cc 0a       	mova	r10,	r12	;
    5336:	b0 13 7a 5b 	calla	#23418		;0x05b7a

0000533a <.LVL6>:
  i2cp->state = I2C_READY;
    533a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000533e <.LBB29>:
  asm volatile("nop");
    533e:	03 43       	nop			

00005340 <.Loc.356.2>:
  _enable_interrupts();
    5340:	03 43       	nop			
    5342:	32 d2       	eint			
    5344:	03 43       	nop			

00005346 <.LBE29>:
  osalSysUnlock();
}
    5346:	08 16       	popm.a	#1,	r8	;20-bit words
    5348:	0a 16       	popm.a	#1,	r10	;20-bit words
    534a:	10 01       	reta			;

0000534c <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    534c:	ac 00 12 00 	adda	#18,	r12	;0x00012

00005350 <.LVL1>:
    5350:	b0 13 20 4f 	calla	#20256		;0x04f20

00005354 <.LVL2>:
}
    5354:	10 01       	reta			;

00005356 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    5356:	4f 43       	clr.b	r15		;
    5358:	ac 00 12 00 	adda	#18,	r12	;0x00012

0000535c <.LVL4>:
    535c:	b0 13 20 4f 	calla	#20256		;0x04f20

00005360 <.LVL5>:
}
    5360:	10 01       	reta			;

00005362 <writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    5362:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005366 <.LVL7>:
    5366:	b0 13 80 51 	calla	#20864		;0x05180

0000536a <.LVL8>:
}
    536a:	10 01       	reta			;

0000536c <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    536c:	4f 43       	clr.b	r15		;
    536e:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005372 <.LVL10>:
    5372:	b0 13 80 51 	calla	#20864		;0x05180

00005376 <.LVL11>:
}
    5376:	10 01       	reta			;

00005378 <gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    5378:	ac 00 12 00 	adda	#18,	r12	;0x00012

0000537c <.LVL13>:
    537c:	b0 13 86 4e 	calla	#20102		;0x04e86

00005380 <.LVL14>:
}
    5380:	10 01       	reta			;

00005382 <get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    5382:	4d 43       	clr.b	r13		;
    5384:	ac 00 12 00 	adda	#18,	r12	;0x00012

00005388 <.LVL16>:
    5388:	b0 13 86 4e 	calla	#20102		;0x04e86

0000538c <.LVL17>:
}
    538c:	10 01       	reta			;

0000538e <putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    538e:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005392 <.LVL19>:
    5392:	b0 13 66 50 	calla	#20582		;0x05066

00005396 <.LVL20>:
}
    5396:	10 01       	reta			;

00005398 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    5398:	4e 43       	clr.b	r14		;
    539a:	ac 00 30 00 	adda	#48,	r12	;0x00030

0000539e <.LVL22>:
    539e:	b0 13 66 50 	calla	#20582		;0x05066

000053a2 <.LVL23>:
}
    53a2:	10 01       	reta			;

000053a4 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    53a4:	4a 14       	pushm.a	#5,	r10	;20-bit words

000053a6 <.LCFI0>:
    53a6:	ca 0c       	mova	r12,	r10	;
    53a8:	06 4d       	mov	r13,	r6	;
    53aa:	07 4e       	mov	r14,	r7	;

000053ac <.Loc.826.2>:

  osalDbgCheck(esp != NULL);
    53ac:	9c 00 00 00 	cmpa	#0,	r12	;
    53b0:	04 20       	jnz	$+10     	;abs 0x53ba

000053b2 <.Loc.826.2>:
    53b2:	8c 01 63 02 	mova	#66147,	r12	;0x10263

000053b6 <.LVL25>:
    53b6:	b0 13 58 46 	calla	#18008		;0x04658

000053ba <.L10>:

  esp->flags |= flags;
    53ba:	28 4a       	mov	@r10,	r8	;
    53bc:	19 4a 02 00 	mov	2(r10),	r9	;
    53c0:	0c 48       	mov	r8,	r12	;
    53c2:	0c d6       	bis	r6,	r12	;
    53c4:	0d 49       	mov	r9,	r13	;
    53c6:	0d d7       	bis	r7,	r13	;
    53c8:	8a 4c 00 00 	mov	r12,	0(r10)	;
    53cc:	8a 4d 02 00 	mov	r13,	2(r10)	;

000053d0 <.Loc.829.2>:
  if (esp->cb != NULL) {
    53d0:	3e 0a 04 00 	mova	4(r10),	r14	;
    53d4:	9e 00 00 00 	cmpa	#0,	r14	;
    53d8:	02 24       	jz	$+6      	;abs 0x53de

000053da <.Loc.830.2>:
    esp->cb(esp);
    53da:	cc 0a       	mova	r10,	r12	;
    53dc:	4e 13       	calla	r14		;

000053de <.L9>:
  }
}
    53de:	46 16       	popm.a	#5,	r10	;20-bit words
    53e0:	10 01       	reta			;

000053e2 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    53e2:	b0 13 14 58 	calla	#22548		;0x05814

000053e6 <.LVL28>:
}
    53e6:	10 01       	reta			;

000053e8 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    53e8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000053ea <.LCFI1>:
    53ea:	08 14       	pushm.a	#1,	r8	;20-bit words

000053ec <.LCFI2>:
    53ec:	06 14       	pushm.a	#1,	r6	;20-bit words

000053ee <.LCFI3>:
    53ee:	b1 00 04 00 	suba	#4,	r1	;

000053f2 <.LCFI4>:
    53f2:	c6 0c       	mova	r12,	r6	;
    53f4:	c8 0e       	mova	r14,	r8	;

000053f6 <.Loc.133.1>:

  sdp->vmt = &vmt;
    53f6:	80 18 fc 40 	movx.a	#66204,	0(r12)	;0x1029c
    53fa:	9c 02 00 00 

000053fe <.LBB22>:
  esp->flags = 0;
    53fe:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    5402:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00005406 <.Loc.811.2>:
  esp->cb    = NULL;
    5406:	00 18 cc 43 	movx.a	#0,	8(r12)	;r3 As==00
    540a:	08 00 

0000540c <.Loc.812.2>:
  esp->param = NULL;
    540c:	00 18 cc 43 	movx.a	#0,	12(r12)	;r3 As==00, 0x0000c
    5410:	0c 00 

00005412 <.LBE22>:
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    5412:	dc 43 10 00 	mov.b	#1,	16(r12)	;r3 As==01, 0x0010

00005416 <.Loc.136.1>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    5416:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010
    541a:	71 0c 00 00 	mova	r12,	0(r1)	;
    541e:	cf 0d       	mova	r13,	r15	;
    5420:	ce 0a       	mova	r10,	r14	;

00005422 <.LVL32>:
    5422:	cd 0c       	mova	r12,	r13	;

00005424 <.LVL33>:
    5424:	ad 00 4e 00 	adda	#78,	r13	;0x0004e
    5428:	ac 00 12 00 	adda	#18,	r12	;0x00012

0000542c <.LVL34>:
    542c:	b0 13 d4 4d 	calla	#19924		;0x04dd4

00005430 <.LVL35>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    5430:	71 06 00 00 	mova	r6,	0(r1)	;
    5434:	cf 08       	mova	r8,	r15	;
    5436:	ce 0a       	mova	r10,	r14	;
    5438:	cd 06       	mova	r6,	r13	;
    543a:	ad 00 5e 00 	adda	#94,	r13	;0x0005e
    543e:	cc 06       	mova	r6,	r12	;
    5440:	ac 00 30 00 	adda	#48,	r12	;0x00030
    5444:	b0 13 14 50 	calla	#20500		;0x05014

00005448 <.LVL36>:
}
    5448:	a1 00 04 00 	adda	#4,	r1	;
    544c:	06 16       	popm.a	#1,	r6	;20-bit words
    544e:	08 16       	popm.a	#1,	r8	;20-bit words
    5450:	0a 16       	popm.a	#1,	r10	;20-bit words
    5452:	10 01       	reta			;

00005454 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    5454:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005456 <.LCFI5>:
    5456:	08 14       	pushm.a	#1,	r8	;20-bit words

00005458 <.LCFI6>:
    5458:	ca 0c       	mova	r12,	r10	;
    545a:	c8 0d       	mova	r13,	r8	;

0000545c <.Loc.160.1>:

  osalDbgCheck(sdp != NULL);
    545c:	9c 00 00 00 	cmpa	#0,	r12	;
    5460:	04 20       	jnz	$+10     	;abs 0x546a

00005462 <.Loc.160.1>:
    5462:	8c 01 93 02 	mova	#66195,	r12	;0x10293

00005466 <.LVL38>:
    5466:	b0 13 58 46 	calla	#18008		;0x04658

0000546a <.L18>:
  _disable_interrupts();
    546a:	32 c2       	dint			
    546c:	03 43       	nop			

0000546e <.Loc.348.3>:
  asm volatile("nop");
    546e:	03 43       	nop			

00005470 <.LBE32>:

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    5470:	5c 4a 10 00 	mov.b	16(r10),r12	;0x00010
    5474:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5476:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5478:	4d 9c       	cmp.b	r12,	r13	;
    547a:	04 2c       	jc	$+10     	;abs 0x5484

0000547c <.Loc.163.1>:
    547c:	8c 01 93 02 	mova	#66195,	r12	;0x10293
    5480:	b0 13 58 46 	calla	#18008		;0x04658

00005484 <.L19>:
                "invalid state");
  sd_lld_start(sdp, config);
    5484:	cd 08       	mova	r8,	r13	;
    5486:	cc 0a       	mova	r10,	r12	;
    5488:	b0 13 24 58 	calla	#22564		;0x05824

0000548c <.LVL41>:
  sdp->state = SD_READY;
    548c:	ea 43 10 00 	mov.b	#2,	16(r10)	;r3 As==10, 0x0010

00005490 <.LBB35>:
  asm volatile("nop");
    5490:	03 43       	nop			

00005492 <.Loc.356.3>:
  _enable_interrupts();
    5492:	03 43       	nop			
    5494:	32 d2       	eint			
    5496:	03 43       	nop			

00005498 <.LBE35>:
  osalSysUnlock();
}
    5498:	08 16       	popm.a	#1,	r8	;20-bit words
    549a:	0a 16       	popm.a	#1,	r10	;20-bit words
    549c:	10 01       	reta			;

0000549e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    549e:	1a 14       	pushm.a	#2,	r10	;20-bit words

000054a0 <.LCFI8>:
    54a0:	ca 0c       	mova	r12,	r10	;
    54a2:	49 4d       	mov.b	r13,	r9	;

000054a4 <.Loc.216.1>:

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);
    54a4:	9c 00 00 00 	cmpa	#0,	r12	;
    54a8:	04 20       	jnz	$+10     	;abs 0x54b2

000054aa <.Loc.216.1>:
    54aa:	8c 01 7c 02 	mova	#66172,	r12	;0x1027c

000054ae <.LVL51>:
    54ae:	b0 13 58 46 	calla	#18008		;0x04658

000054b2 <.L24>:

  if (iqIsEmptyI(&sdp->iqueue))
    54b2:	3c 0a 14 00 	mova	20(r10),r12	;0x00014
    54b6:	9c 00 00 00 	cmpa	#0,	r12	;
    54ba:	07 20       	jnz	$+16     	;abs 0x54ca

000054bc <.Loc.219.1>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    54bc:	6d 42       	mov.b	#4,	r13	;r2 As==10
    54be:	4e 43       	clr.b	r14		;
    54c0:	cc 0a       	mova	r10,	r12	;
    54c2:	ac 00 04 00 	adda	#4,	r12	;
    54c6:	b0 13 a4 53 	calla	#21412		;0x053a4

000054ca <.L25>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    54ca:	4d 49       	mov.b	r9,	r13	;
    54cc:	cc 0a       	mova	r10,	r12	;
    54ce:	ac 00 12 00 	adda	#18,	r12	;0x00012
    54d2:	b0 13 08 4e 	calla	#19976		;0x04e08

000054d6 <.LVL54>:
    54d6:	9c 00 00 00 	cmpa	#0,	r12	;
    54da:	08 34       	jge	$+18     	;abs 0x54ec

000054dc <.Loc.221.1>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    54dc:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    54e0:	4e 43       	clr.b	r14		;
    54e2:	cc 0a       	mova	r10,	r12	;
    54e4:	ac 00 04 00 	adda	#4,	r12	;
    54e8:	b0 13 a4 53 	calla	#21412		;0x053a4

000054ec <.L23>:
}
    54ec:	19 16       	popm.a	#2,	r10	;20-bit words
    54ee:	10 01       	reta			;

000054f0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    54f0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000054f2 <.LCFI9>:
    54f2:	08 14       	pushm.a	#1,	r8	;20-bit words

000054f4 <.LCFI10>:
    54f4:	ca 0c       	mova	r12,	r10	;

000054f6 <.Loc.243.1>:
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);
    54f6:	9c 00 00 00 	cmpa	#0,	r12	;
    54fa:	04 20       	jnz	$+10     	;abs 0x5504

000054fc <.Loc.243.1>:
    54fc:	8c 01 54 02 	mova	#66132,	r12	;0x10254

00005500 <.LVL57>:
    5500:	b0 13 58 46 	calla	#18008		;0x04658

00005504 <.L28>:

  b = oqGetI(&sdp->oqueue);
    5504:	cc 0a       	mova	r10,	r12	;
    5506:	ac 00 30 00 	adda	#48,	r12	;0x00030
    550a:	b0 13 04 51 	calla	#20740		;0x05104

0000550e <.LVL59>:
    550e:	c8 0c       	mova	r12,	r8	;

00005510 <.Loc.246.1>:
  if (b < MSG_OK)
    5510:	9c 00 00 00 	cmpa	#0,	r12	;
    5514:	07 34       	jge	$+16     	;abs 0x5524

00005516 <.Loc.247.1>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    5516:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5518:	4e 43       	clr.b	r14		;
    551a:	cc 0a       	mova	r10,	r12	;
    551c:	ac 00 04 00 	adda	#4,	r12	;
    5520:	b0 13 a4 53 	calla	#21412		;0x053a4

00005524 <.L27>:
  return b;
}
    5524:	cc 08       	mova	r8,	r12	;
    5526:	08 16       	popm.a	#1,	r8	;20-bit words
    5528:	0a 16       	popm.a	#1,	r10	;20-bit words
    552a:	10 01       	reta			;

0000552c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    552c:	b0 13 36 5b 	calla	#23350		;0x05b36

00005530 <.LVL2>:
}
    5530:	10 01       	reta			;

00005532 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    5532:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    5536:	80 5a 5c 01 

0000553a <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    553a:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    553e:	10 a5 40 01 

00005542 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    5542:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    5546:	41 01 

00005548 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    5548:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    554c:	00 a5 60 01 

00005550 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    5550:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    5554:	48 00 62 01 

00005558 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    5558:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    555c:	33 01 64 01 

00005560 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    5560:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    5564:	66 01 

00005566 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    5566:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    556a:	c9 c1 68 01 

0000556e <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    556e:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    5572:	0f 00 6c 01 

00005576 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    5576:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    557a:	61 01 

0000557c <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    557c:	b0 13 c0 59 	calla	#22976		;0x059c0

00005580 <.LVL0>:
#endif
}
    5580:	10 01       	reta			;

00005582 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    5582:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    5586:	7f 3e d2 03 

0000558a <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    558a:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    558e:	10 00 c2 03 

00005592 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    5592:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    5596:	e0 03 

00005598 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    5598:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    559c:	14 02 c0 03 

000055a0 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    55a0:	10 01       	reta			;

000055a2 <notify1>:

#if (MSP430X_SERIAL_USE_USART1 == TRUE) || defined(__DOXYGEN__)
static void notify1(io_queue_t * qp) {

  (void)qp;
  UCA1IE |= UCTXIE;
    55a2:	40 18 a2 d3 	bisx.w	#2,	&0x005fa;r3 As==10
    55a6:	fa 05 

000055a8 <.Loc.288.1>:
}
    55a8:	10 01       	reta			;

000055aa <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    55aa:	4a 14       	pushm.a	#5,	r10	;20-bit words

000055ac <.LCFI0>:
    55ac:	ca 0c       	mova	r12,	r10	;
    55ae:	06 4d       	mov	r13,	r6	;
    55b0:	07 4e       	mov	r14,	r7	;

000055b2 <.Loc.826.2>:
  osalDbgCheck(esp != NULL);
    55b2:	9c 00 00 00 	cmpa	#0,	r12	;
    55b6:	04 20       	jnz	$+10     	;abs 0x55c0

000055b8 <.Loc.826.2>:
    55b8:	8c 01 bc 02 	mova	#66236,	r12	;0x102bc

000055bc <.LVL2>:
    55bc:	b0 13 58 46 	calla	#18008		;0x04658

000055c0 <.L3>:
  esp->flags |= flags;
    55c0:	28 4a       	mov	@r10,	r8	;
    55c2:	19 4a 02 00 	mov	2(r10),	r9	;
    55c6:	0c 48       	mov	r8,	r12	;
    55c8:	0c d6       	bis	r6,	r12	;
    55ca:	0d 49       	mov	r9,	r13	;
    55cc:	0d d7       	bis	r7,	r13	;
    55ce:	8a 4c 00 00 	mov	r12,	0(r10)	;
    55d2:	8a 4d 02 00 	mov	r13,	2(r10)	;

000055d6 <.Loc.829.2>:
  if (esp->cb != NULL) {
    55d6:	3e 0a 04 00 	mova	4(r10),	r14	;
    55da:	9e 00 00 00 	cmpa	#0,	r14	;
    55de:	02 24       	jz	$+6      	;abs 0x55e4

000055e0 <.Loc.830.2>:
    esp->cb(esp);
    55e0:	cc 0a       	mova	r10,	r12	;
    55e2:	4e 13       	calla	r14		;

000055e4 <.L2>:
}
    55e4:	46 16       	popm.a	#5,	r10	;20-bit words
    55e6:	10 01       	reta			;

000055e8 <UCBRS>:
  if (frac < 529)
    55e8:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    55ec:	0d 9c       	cmp	r12,	r13	;
    55ee:	8b 2c       	jc	$+280    	;abs 0x5706

000055f0 <.Loc.109.1>:
  else if (frac < 715)
    55f0:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    55f4:	0d 9c       	cmp	r12,	r13	;
    55f6:	8a 2c       	jc	$+278    	;abs 0x570c

000055f8 <.Loc.111.1>:
  else if (frac < 835)
    55f8:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    55fc:	0d 9c       	cmp	r12,	r13	;
    55fe:	89 2c       	jc	$+276    	;abs 0x5712

00005600 <.Loc.113.1>:
  else if (frac < 1001)
    5600:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    5604:	0d 9c       	cmp	r12,	r13	;
    5606:	88 2c       	jc	$+274    	;abs 0x5718

00005608 <.Loc.115.1>:
  else if (frac < 1252)
    5608:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    560c:	0d 9c       	cmp	r12,	r13	;
    560e:	87 2c       	jc	$+272    	;abs 0x571e

00005610 <.Loc.117.1>:
  else if (frac < 1430)
    5610:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    5614:	0d 9c       	cmp	r12,	r13	;
    5616:	86 2c       	jc	$+270    	;abs 0x5724

00005618 <.Loc.119.1>:
  else if (frac < 1670)
    5618:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    561c:	0d 9c       	cmp	r12,	r13	;
    561e:	86 2c       	jc	$+270    	;abs 0x572c

00005620 <.Loc.121.1>:
  else if (frac < 2147)
    5620:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    5624:	0d 9c       	cmp	r12,	r13	;
    5626:	86 2c       	jc	$+270    	;abs 0x5734

00005628 <.Loc.123.1>:
  else if (frac < 2224)
    5628:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    562c:	0d 9c       	cmp	r12,	r13	;
    562e:	86 2c       	jc	$+270    	;abs 0x573c

00005630 <.Loc.125.1>:
  else if (frac < 2503)
    5630:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    5634:	0d 9c       	cmp	r12,	r13	;
    5636:	86 2c       	jc	$+270    	;abs 0x5744

00005638 <.Loc.127.1>:
  else if (frac < 3000)
    5638:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    563c:	0d 9c       	cmp	r12,	r13	;
    563e:	86 2c       	jc	$+270    	;abs 0x574c

00005640 <.LBB26>:
  else if (frac < 3335)
    5640:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    5644:	0d 9c       	cmp	r12,	r13	;
    5646:	86 2c       	jc	$+270    	;abs 0x5754

00005648 <.Loc.131.1>:
  else if (frac < 3575)
    5648:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    564c:	0d 9c       	cmp	r12,	r13	;
    564e:	86 2c       	jc	$+270    	;abs 0x575c

00005650 <.Loc.133.1>:
  else if (frac < 3753)
    5650:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    5654:	0d 9c       	cmp	r12,	r13	;
    5656:	86 2c       	jc	$+270    	;abs 0x5764

00005658 <.Loc.135.1>:
  else if (frac < 4003)
    5658:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    565c:	0d 9c       	cmp	r12,	r13	;
    565e:	86 2c       	jc	$+270    	;abs 0x576c

00005660 <.Loc.137.1>:
  else if (frac < 4286)
    5660:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    5664:	0d 9c       	cmp	r12,	r13	;
    5666:	86 2c       	jc	$+270    	;abs 0x5774

00005668 <.Loc.139.1>:
  else if (frac < 4378)
    5668:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    566c:	0d 9c       	cmp	r12,	r13	;
    566e:	86 2c       	jc	$+270    	;abs 0x577c

00005670 <.Loc.141.1>:
  else if (frac < 5002)
    5670:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    5674:	0d 9c       	cmp	r12,	r13	;
    5676:	86 2c       	jc	$+270    	;abs 0x5784

00005678 <.Loc.143.1>:
  else if (frac < 5715)
    5678:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    567c:	0d 9c       	cmp	r12,	r13	;
    567e:	86 2c       	jc	$+270    	;abs 0x578c

00005680 <.Loc.145.1>:
  else if (frac < 6003)
    5680:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    5684:	0d 9c       	cmp	r12,	r13	;
    5686:	86 2c       	jc	$+270    	;abs 0x5794

00005688 <.Loc.147.1>:
  else if (frac < 6254)
    5688:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    568c:	0d 9c       	cmp	r12,	r13	;
    568e:	86 2c       	jc	$+270    	;abs 0x579c

00005690 <.Loc.149.1>:
  else if (frac < 6432)
    5690:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    5694:	0d 9c       	cmp	r12,	r13	;
    5696:	86 2c       	jc	$+270    	;abs 0x57a4

00005698 <.Loc.151.1>:
  else if (frac < 6667)
    5698:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    569c:	0d 9c       	cmp	r12,	r13	;
    569e:	86 2c       	jc	$+270    	;abs 0x57ac

000056a0 <.Loc.153.1>:
  else if (frac < 7001)
    56a0:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    56a4:	0d 9c       	cmp	r12,	r13	;
    56a6:	86 2c       	jc	$+270    	;abs 0x57b4

000056a8 <.Loc.155.1>:
  else if (frac < 7147)
    56a8:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    56ac:	0d 9c       	cmp	r12,	r13	;
    56ae:	86 2c       	jc	$+270    	;abs 0x57bc

000056b0 <.Loc.157.1>:
  else if (frac < 7503)
    56b0:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    56b4:	0d 9c       	cmp	r12,	r13	;
    56b6:	86 2c       	jc	$+270    	;abs 0x57c4

000056b8 <.Loc.159.1>:
  else if (frac < 7861)
    56b8:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    56bc:	0d 9c       	cmp	r12,	r13	;
    56be:	86 2c       	jc	$+270    	;abs 0x57cc

000056c0 <.Loc.161.1>:
  else if (frac < 8004)
    56c0:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    56c4:	0d 9c       	cmp	r12,	r13	;
    56c6:	86 2c       	jc	$+270    	;abs 0x57d4

000056c8 <.Loc.163.1>:
  else if (frac < 8333)
    56c8:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    56cc:	0d 9c       	cmp	r12,	r13	;
    56ce:	86 2c       	jc	$+270    	;abs 0x57dc

000056d0 <.Loc.165.1>:
  else if (frac < 8464)
    56d0:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    56d4:	0d 9c       	cmp	r12,	r13	;
    56d6:	86 2c       	jc	$+270    	;abs 0x57e4

000056d8 <.Loc.167.1>:
  else if (frac < 8572)
    56d8:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    56dc:	0d 9c       	cmp	r12,	r13	;
    56de:	86 2c       	jc	$+270    	;abs 0x57ec

000056e0 <.Loc.169.1>:
  else if (frac < 8751)
    56e0:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    56e4:	0d 9c       	cmp	r12,	r13	;
    56e6:	86 2c       	jc	$+270    	;abs 0x57f4

000056e8 <.Loc.171.1>:
  else if (frac < 9004)
    56e8:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    56ec:	0d 9c       	cmp	r12,	r13	;
    56ee:	86 2c       	jc	$+270    	;abs 0x57fc

000056f0 <.Loc.173.1>:
  else if (frac < 9170)
    56f0:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    56f4:	0d 9c       	cmp	r12,	r13	;
    56f6:	86 2c       	jc	$+270    	;abs 0x5804

000056f8 <.Loc.175.1>:
  else if (frac < 9288)
    56f8:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    56fc:	0d 9c       	cmp	r12,	r13	;
    56fe:	86 2c       	jc	$+270    	;abs 0x580c

00005700 <.Loc.178.1>:
    return 0xFE;
    5700:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00005704 <.L9>:
}
    5704:	10 01       	reta			;

00005706 <.L10>:
    return 0x00;
    5706:	4c 43       	clr.b	r12		;

00005708 <.LVL9>:
    5708:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000570c <.L11>:
    return 0x01;
    570c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000570e <.LVL11>:
    570e:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005712 <.L12>:
    return 0x02;
    5712:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005714 <.LVL13>:
    5714:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005718 <.L13>:
    return 0x04;
    5718:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000571a <.LVL15>:
    571a:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000571e <.L14>:
    return 0x08;
    571e:	7c 42       	mov.b	#8,	r12	;r2 As==11

00005720 <.LVL17>:
    5720:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005724 <.L15>:
    return 0x10;
    5724:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

00005728 <.LVL19>:
    5728:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000572c <.L16>:
    return 0x20;
    572c:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

00005730 <.LVL21>:
    5730:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005734 <.L17>:
    return 0x11;
    5734:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

00005738 <.LVL23>:
    5738:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000573c <.L18>:
    return 0x21;
    573c:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

00005740 <.LVL25>:
    5740:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005744 <.L19>:
    return 0x22;
    5744:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00005748 <.LVL27>:
    5748:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000574c <.L20>:
    return 0x44;
    574c:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00005750 <.LVL29>:
    5750:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005754 <.L21>:
    return 0x25;
    5754:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00005758 <.LVL31>:
    5758:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000575c <.L22>:
    return 0x49;
    575c:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00005760 <.LVL33>:
    5760:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005764 <.L23>:
    return 0x4A;
    5764:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

00005768 <.LVL35>:
    5768:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000576c <.L24>:
    return 0x52;
    576c:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00005770 <.LVL37>:
    5770:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005774 <.L25>:
    return 0x92;
    5774:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00005778 <.LVL39>:
    5778:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000577c <.L26>:
    return 0x53;
    577c:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00005780 <.LVL41>:
    5780:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005784 <.L27>:
    return 0x55;
    5784:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00005788 <.LVL43>:
    5788:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000578c <.L28>:
    return 0xAA;
    578c:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00005790 <.LVL45>:
    5790:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005794 <.L29>:
    return 0x6B;
    5794:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00005798 <.LVL47>:
    5798:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000579c <.L30>:
    return 0xAD;
    579c:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

000057a0 <.LVL49>:
    57a0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057a4 <.L31>:
    return 0xB5;
    57a4:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

000057a8 <.LVL51>:
    57a8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057ac <.L32>:
    return 0xB6;
    57ac:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

000057b0 <.LVL53>:
    57b0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057b4 <.L33>:
    return 0xD6;
    57b4:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

000057b8 <.LVL55>:
    57b8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057bc <.L34>:
    return 0xB7;
    57bc:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

000057c0 <.LVL57>:
    57c0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057c4 <.L35>:
    return 0xBB;
    57c4:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

000057c8 <.LVL59>:
    57c8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057cc <.L36>:
    return 0xDD;
    57cc:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

000057d0 <.LVL61>:
    57d0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057d4 <.L37>:
    return 0xED;
    57d4:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

000057d8 <.LVL63>:
    57d8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057dc <.L38>:
    return 0xEE;
    57dc:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

000057e0 <.LVL65>:
    57e0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057e4 <.L39>:
    return 0xBF;
    57e4:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

000057e8 <.LVL67>:
    57e8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057ec <.L40>:
    return 0xDF;
    57ec:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

000057f0 <.LVL69>:
    57f0:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057f4 <.L41>:
    return 0xEF;
    57f4:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

000057f8 <.LVL71>:
    57f8:	80 00 04 57 	mova	#22276,	r0	;0x05704

000057fc <.L42>:
    return 0xF7;
    57fc:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00005800 <.LVL73>:
    5800:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005804 <.L43>:
    return 0xFB;
    5804:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

00005808 <.LVL75>:
    5808:	80 00 04 57 	mova	#22276,	r0	;0x05704

0000580c <.L44>:
    return 0xFD;
    580c:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

00005810 <.LVL77>:
    5810:	80 00 04 57 	mova	#22276,	r0	;0x05704

00005814 <sd_lld_init>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
#endif

#if MSP430X_SERIAL_USE_USART1 == TRUE
  sdObjectInit(&SD1, NULL, notify1);
    5814:	8e 00 a2 55 	mova	#21922,	r14	;0x055a2
    5818:	4d 43       	clr.b	r13		;
    581a:	8c 01 dc 07 	mova	#67548,	r12	;0x107dc
    581e:	b0 13 e8 53 	calla	#21480		;0x053e8

00005822 <.LVL96>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    5822:	10 01       	reta			;

00005824 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    5824:	5a 14       	pushm.a	#6,	r10	;20-bit words

00005826 <.LCFI2>:

  if (config == NULL) {
    5826:	9d 00 00 00 	cmpa	#0,	r13	;
    582a:	1c 24       	jz	$+58     	;abs 0x5864

0000582c <.Loc.613.1>:
  if (&SD0 == sdp) {
    usart0_init(config);
  }
#endif
#if MSP430X_SERIAL_USE_USART1 == TRUE
  if (&SD1 == sdp) {
    582c:	9c 01 dc 07 	cmpa	#67548,	r12	;0x107dc
    5830:	68 20       	jnz	$+210    	;abs 0x5902

00005832 <.LBB42>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    5832:	28 4d       	mov	@r13,	r8	;
    5834:	19 4d 02 00 	mov	2(r13),	r9	;

00005838 <.LBB44>:
  uint16_t n = freq / baud;
    5838:	0e 48       	mov	r8,	r14	;
    583a:	0f 49       	mov	r9,	r15	;
    583c:	3c 40 00 24 	mov	#9216,	r12	;#0x2400

00005840 <.LVL100>:
    5840:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4

00005844 <.LVL101>:
    5844:	b0 13 aa a2 	calla	#41642		;0x0a2aa

00005848 <.LVL102>:
    5848:	07 4c       	mov	r12,	r7	;
    584a:	0d 4c       	mov	r12,	r13	;

0000584c <.LVL103>:
  if (n > 16) {
    584c:	76 40 10 00 	mov.b	#16,	r6	;#0x0010
    5850:	06 97       	cmp	r7,	r6	;
    5852:	11 28       	jnc	$+36     	;abs 0x5876
    5854:	05 4c       	mov	r12,	r5	;
    5856:	80 00 7a 58 	mova	#22650,	r0	;0x0587a

0000585a <.L78>:
  return UCBRS(frac) << 8;
    585a:	4e 13       	calla	r14		;

0000585c <.LVL105>:
    585c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5860:	80 00 dc 58 	mova	#22748,	r0	;0x058dc

00005864 <.L75>:
  if (&SD1 == sdp) {
    5864:	9c 01 dc 07 	cmpa	#67548,	r12	;0x107dc
    5868:	4c 20       	jnz	$+154    	;abs 0x5902

0000586a <.LBB51>:
  uint16_t n = freq / baud;
    586a:	3d 40 a0 01 	mov	#416,	r13	;#0x01a0
    586e:	07 4d       	mov	r13,	r7	;

00005870 <.LBE51>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    5870:	38 40 00 96 	mov	#-27136,r8	;#0x9600
    5874:	49 43       	clr.b	r9		;

00005876 <.L80>:
    return n >> 4;
    5876:	05 4d       	mov	r13,	r5	;
    5878:	5d 0f       	rrum	#4,	r13	;

0000587a <.L77>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    587a:	40 18 82 4d 	movx.w	r13,	&0x005e6;
    587e:	e6 05 

00005880 <.LBB53>:
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    5880:	8a 00 e4 a3 	mova	#41956,	r10	;0x0a3e4
    5884:	0e 48       	mov	r8,	r14	;
    5886:	0f 49       	mov	r9,	r15	;
    5888:	0c 47       	mov	r7,	r12	;
    588a:	4d 43       	clr.b	r13		;
    588c:	4a 13       	calla	r10		;

0000588e <.LVL110>:
    588e:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    5892:	4f 43       	clr.b	r15		;
    5894:	36 40 00 24 	mov	#9216,	r6	;#0x2400
    5898:	77 40 f4 00 	mov.b	#244,	r7	;#0x00f4
    589c:	40 18 06 8c 	subx.w	r12,	r6	;
    58a0:	40 18 07 7d 	subcx.w	r13,	r7	;
    58a4:	0c 46       	mov	r6,	r12	;
    58a6:	0d 47       	mov	r7,	r13	;
    58a8:	4a 13       	calla	r10		;

000058aa <.LVL111>:
    58aa:	0e 48       	mov	r8,	r14	;
    58ac:	0f 49       	mov	r9,	r15	;
    58ae:	b0 13 aa a2 	calla	#41642		;0x0a2aa

000058b2 <.LVL112>:
    58b2:	8e 00 e8 55 	mova	#21992,	r14	;0x055e8

000058b6 <.Loc.194.1>:
  if (n > 16) {
    58b6:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    58ba:	07 95       	cmp	r5,	r7	;
    58bc:	ce 2f       	jc	$-98     	;abs 0x585a

000058be <.LVL113>:
    58be:	0d 45       	mov	r5,	r13	;
    58c0:	3d 50 ef ff 	add	#-17,	r13	;#0xffef
    58c4:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    58c8:	35 50 f0 ff 	add	#-16,	r5	;#0xfff0
    58cc:	05 8d       	sub	r13,	r5	;

000058ce <.Loc.198.1>:
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    58ce:	4e 13       	calla	r14		;

000058d0 <.LVL114>:
    58d0:	43 18 05 55 	rpt #4 { rlax.w	r5		;
    58d4:	15 d3       	bis	#1,	r5	;r3 As==01
    58d6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    58da:	0c d5       	bis	r5,	r12	;

000058dc <.L79>:
  UCA1MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    58dc:	40 18 82 4c 	movx.w	r12,	&0x005e8;
    58e0:	e8 05 

000058e2 <.Loc.237.1>:
  UCA1STATW = 0;
    58e2:	40 18 c2 43 	movx.b	#0,	&0x005ea;r3 As==00
    58e6:	ea 05 

000058e8 <.Loc.238.1>:
  UCA1ABCTL = 0;
    58e8:	40 18 c2 43 	movx.b	#0,	&0x005f0;r3 As==00
    58ec:	f0 05 

000058ee <.Loc.239.1>:
  UCA1IRCTL = 0;
    58ee:	40 18 82 43 	movx.w	#0,	&0x005f2;r3 As==00
    58f2:	f2 05 

000058f4 <.Loc.240.1>:
  UCA1CTLW0 = (MSP430X_USART1_PARITY << 14) | (MSP430X_USART1_ORDER << 13) |
    58f4:	40 18 b2 40 	movx.w	#128,	&0x005e0;0x00080
    58f8:	80 00 e0 05 

000058fc <.Loc.243.1>:
  UCA1IE = UCRXIE;
    58fc:	40 18 92 43 	movx.w	#1,	&0x005fa;r3 As==01
    5900:	fa 05 

00005902 <.L74>:
#if MSP430X_SERIAL_USE_USART3 == TRUE
  if (&SD3 == sdp) {
    usart3_init(config);
  }
#endif
}
    5902:	55 16       	popm.a	#6,	r10	;20-bit words
    5904:	10 01       	reta			;

00005906 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    5906:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    590a:	02 02 

0000590c <.Loc.310.1>:
  PADIR = config->porta.dir;
    590c:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    5910:	02 00 04 02 

00005914 <.Loc.311.1>:
  PAREN = config->porta.ren;
    5914:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    5918:	04 00 06 02 

0000591c <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    591c:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    5920:	06 00 0a 02 

00005924 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    5924:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    5928:	08 00 0c 02 

0000592c <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    592c:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    5930:	0a 00 22 02 

00005934 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    5934:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    5938:	0c 00 24 02 

0000593c <.Loc.317.1>:
  PBREN = config->portb.ren;
    593c:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    5940:	0e 00 26 02 

00005944 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    5944:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    5948:	10 00 2a 02 

0000594c <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    594c:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    5950:	12 00 2c 02 

00005954 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    5954:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    5958:	14 00 22 03 

0000595c <.Loc.350.1>:
  PJDIR = config->portj.dir;
    595c:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    5960:	16 00 24 03 

00005964 <.Loc.351.1>:
  PJREN = config->portj.ren;
    5964:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    5968:	18 00 26 03 

0000596c <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    596c:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    5970:	1a 00 2a 03 

00005974 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    5974:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    5978:	1c 00 2c 03 

0000597c <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    597c:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    5980:	30 01 

00005982 <.Loc.356.1>:
}
    5982:	10 01       	reta			;

00005984 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    5984:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005986 <.LCFI0>:
    5986:	49 4c       	mov.b	r12,	r9	;
    5988:	48 4d       	mov.b	r13,	r8	;

0000598a <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    598a:	0a 49       	mov	r9,	r10	;
    598c:	12 c3       	clrc			
    598e:	0a 10       	rrc	r10		;
    5990:	40 18 0a 4a 	movx.w	r10,	r10	;
    5994:	ea 0a       	adda	r10,	r10	;
    5996:	aa 00 00 05 	adda	#1280,	r10	;0x00500

0000599a <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    599a:	59 f3       	and.b	#1,	r9	;r3 As==01
    599c:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    59a0:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

000059a4 <.LVL2>:
    59a4:	0d 49       	mov	r9,	r13	;

000059a6 <.LVL3>:
    59a6:	b0 13 74 a3 	calla	#41844		;0x0a374
    59aa:	07 4c       	mov	r12,	r7	;
    59ac:	27 fa       	and	@r10,	r7	;

000059ae <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    59ae:	0c 48       	mov	r8,	r12	;
    59b0:	0d 49       	mov	r9,	r13	;
    59b2:	b0 13 e0 a2 	calla	#41696		;0x0a2e0
    59b6:	07 dc       	bis	r12,	r7	;
    59b8:	8a 47 00 00 	mov	r7,	0(r10)	;

000059bc <.Loc.65.1>:
}
    59bc:	37 16       	popm.a	#4,	r10	;20-bit words
    59be:	10 01       	reta			;

000059c0 <dmaInit>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    59c0:	40 18 82 43 	movx.w	#0,	&0xfa7b6;r3 As==00
    59c4:	b6 a7 

000059c6 <.LBE15>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    59c6:	10 01       	reta			;

000059c8 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    59c8:	2a 14       	pushm.a	#3,	r10	;20-bit words

000059ca <.LCFI2>:
    59ca:	ca 0c       	mova	r12,	r10	;

000059cc <.LVL19>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    59cc:	40 18 19 42 	movx.w	&0x00510,r9	;
    59d0:	10 05 
    59d2:	79 f0 10 00 	and.b	#16,	r9	;#0x0010
    59d6:	09 93       	cmp	#0,	r9	;r3 As==00
    59d8:	11 24       	jz	$+36     	;abs 0x59fc

000059da <.LVL20>:
    59da:	8c 00 20 05 	mova	#1312,	r12	;0x00520

000059de <.LVL21>:
    59de:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    59e2:	10 00 00 00 
    59e6:	09 24       	jz	$+20     	;abs 0x59fa

000059e8 <.LVL22>:
    59e8:	40 18 bc b0 	bitx.w	#16,	16(r12)	;0x00010, 0x00010
    59ec:	10 00 10 00 
    59f0:	1f 24       	jz	$+64     	;abs 0x5a30

000059f2 <.Loc.198.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    59f2:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000059f6 <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    59f6:	28 16       	popm.a	#3,	r10	;20-bit words
    59f8:	10 01       	reta			;

000059fa <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    59fa:	59 43       	mov.b	#1,	r9	;r3 As==01

000059fc <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    59fc:	48 49       	mov.b	r9,	r8	;
    59fe:	4d 43       	clr.b	r13		;
    5a00:	4c 48       	mov.b	r8,	r12	;
    5a02:	b0 13 84 59 	calla	#22916		;0x05984

00005a06 <.LVL26>:
  dma_regs[i].sz  = 0;
    5a06:	0c 49       	mov	r9,	r12	;
    5a08:	0d 43       	clr	r13		;
    5a0a:	b0 13 12 a3 	calla	#41746		;0x0a312
    5a0e:	0d 12       	push	r13		;
    5a10:	0c 12       	push	r12		;
    5a12:	0c 16       	popm.a	#1,	r12	;20-bit words
    5a14:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    5a18:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005a1c <.Loc.204.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    5a1c:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5a20:	00 00 

00005a22 <.Loc.206.1>:
  channel->registers = dma_regs + i;
    5a22:	7a 0c 00 00 	mova	r12,	0(r10)	;

00005a26 <.Loc.207.1>:
  channel->index     = i;
    5a26:	ca 48 04 00 	mov.b	r8,	4(r10)	;

00005a2a <.Loc.209.1>:
  return MSG_OK;
    5a2a:	4c 43       	clr.b	r12		;
    5a2c:	80 00 f6 59 	mova	#23030,	r0	;0x059f6

00005a30 <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    5a30:	69 43       	mov.b	#2,	r9	;r3 As==10
    5a32:	80 00 fc 59 	mova	#23036,	r0	;0x059fc

00005a36 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5a36:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005a38 <.LCFI5>:
    5a38:	08 14       	pushm.a	#1,	r8	;20-bit words

00005a3a <.LCFI6>:
    5a3a:	c8 0c       	mova	r12,	r8	;
    5a3c:	ca 0d       	mova	r13,	r10	;

00005a3e <.Loc.273.1>:


  channel->registers->ctl &= (~DMAEN);
    5a3e:	0c 0c       	mova	@r12,	r12	;

00005a40 <.LVL42>:
    5a40:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5a44:	00 00 

00005a46 <.Loc.274.1>:
  dma_trigger_set(channel->index, request->trigger);
    5a46:	5d 4d 10 00 	mov.b	16(r13),r13	;0x00010

00005a4a <.LVL43>:
    5a4a:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5a4e:	b0 13 84 59 	calla	#22916		;0x05984

00005a52 <.LVL44>:
  callbacks[channel->index] = request->callback;
    5a52:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5a56:	0d 43       	clr	r13		;
    5a58:	b0 13 16 a3 	calla	#41750		;0x0a316
    5a5c:	0d 12       	push	r13		;
    5a5e:	0c 12       	push	r12		;
    5a60:	0c 16       	popm.a	#1,	r12	;20-bit words
    5a62:	ac 00 b8 a7 	adda	#42936,	r12	;0x0a7b8
    5a66:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    5a6a:	00 00 
    5a6c:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    5a70:	02 00 
    5a72:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    5a76:	04 00 
    5a78:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    5a7c:	06 00 

00005a7e <.Loc.278.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    5a7e:	0c 08       	mova	@r8,	r12	;
    5a80:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    5a84:	02 00 

00005a86 <.Loc.279.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    5a86:	0c 08       	mova	@r8,	r12	;
    5a88:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    5a8c:	04 00 06 00 

00005a90 <.Loc.284.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    5a90:	0e 08       	mova	@r8,	r14	;
    5a92:	9e 4a 08 00 	mov	8(r10),	10(r14)	; 0x000a
    5a96:	0a 00 

00005a98 <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5a98:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    5a9c:	1c da 0a 00 	bis	10(r10),r12	;0x0000a

00005aa0 <.Loc.286.1>:
                            request->transfer_mode | DMAEN |
    5aa0:	3c d0 15 00 	bis	#21,	r12	;#0x0015

00005aa4 <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5aa4:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    5aa8:	8e 4c 00 00 	mov	r12,	0(r14)	;

00005aac <.Loc.288.1>:
                            DMAREQ;
}
    5aac:	08 16       	popm.a	#1,	r8	;20-bit words
    5aae:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ab0:	10 01       	reta			;

00005ab2 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5ab2:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005ab4 <.LCFI7>:
    5ab4:	ca 0c       	mova	r12,	r10	;

00005ab6 <.LBB33>:
  return chSysGetStatusAndLockX();
    5ab6:	b0 13 f4 46 	calla	#18164		;0x046f4

00005aba <.LVL49>:
    5aba:	09 4c       	mov	r12,	r9	;

00005abc <.LBE33>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
    5abc:	9a 00 00 00 	cmpa	#0,	r10	;
    5ac0:	09 20       	jnz	$+20     	;abs 0x5ad4

00005ac2 <.Loc.303.1>:
    5ac2:	8c 01 f3 02 	mova	#66291,	r12	;0x102f3
    5ac6:	b0 13 58 46 	calla	#18008		;0x04658

00005aca <.L34>:
  chSysRestoreStatusX(sts);
    5aca:	0c 49       	mov	r9,	r12	;
    5acc:	b0 13 10 47 	calla	#18192		;0x04710

00005ad0 <.LBE35>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    5ad0:	19 16       	popm.a	#2,	r10	;20-bit words
    5ad2:	10 01       	reta			;

00005ad4 <.L33>:
  if (dmaIsClaimed(channel)) {
    5ad4:	0c 0a       	mova	@r10,	r12	;
    5ad6:	9c 00 00 00 	cmpa	#0,	r12	;
    5ada:	f7 27       	jz	$-16     	;abs 0x5aca

00005adc <.Loc.305.1>:
    5adc:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5ae0:	10 00 00 00 
    5ae4:	f2 27       	jz	$-26     	;abs 0x5aca

00005ae6 <.Loc.308.1>:
    channel->registers->ctl = DMAABORT;
    5ae6:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00005aea <.Loc.311.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    5aea:	4d 43       	clr.b	r13		;
    5aec:	8c 00 b6 a7 	mova	#42934,	r12	;0x0a7b6
    5af0:	b0 13 3c 4d 	calla	#19772		;0x04d3c

00005af4 <.LVL52>:
    5af4:	80 00 ca 5a 	mova	#23242,	r0	;0x05aca

00005af8 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    5af8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005afa <.LCFI8>:
    5afa:	ca 0c       	mova	r12,	r10	;

00005afc <.Loc.327.1>:
  
  osalDbgCheck(channel != NULL);
    5afc:	9c 00 00 00 	cmpa	#0,	r12	;
    5b00:	04 20       	jnz	$+10     	;abs 0x5b0a

00005b02 <.Loc.327.1>:
    5b02:	8c 01 e8 02 	mova	#66280,	r12	;0x102e8

00005b06 <.LVL54>:
    5b06:	b0 13 58 46 	calla	#18008		;0x04658

00005b0a <.L41>:
  
  if (!(channel->registers->ctl & DMAEN)) {
    5b0a:	0c 0a       	mova	@r10,	r12	;
    5b0c:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5b10:	10 00 00 00 
    5b14:	0e 24       	jz	$+30     	;abs 0x5b32

00005b16 <.Loc.334.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    5b16:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    5b1a:	00 00 

00005b1c <.Loc.336.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    5b1c:	4d 43       	clr.b	r13		;
    5b1e:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5b22:	b0 13 84 59 	calla	#22916		;0x05984

00005b26 <.LVL56>:
  channel->registers->sz  = 0;
    5b26:	0c 0a       	mova	@r10,	r12	;
    5b28:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005b2c <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    5b2c:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5b30:	00 00 

00005b32 <.L40>:
}
    5b32:	0a 16       	popm.a	#1,	r10	;20-bit words
    5b34:	10 01       	reta			;

00005b36 <spi_lld_init>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    5b36:	10 01       	reta			;

00005b38 <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    5b38:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005b3c <.LVL2>:
    5b3c:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

00005b40 <.Loc.82.1>:
}
    5b40:	10 01       	reta			;

00005b42 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    5b42:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005b44 <.LCFI0>:

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5b44:	8a 01 ca 08 	mova	#67786,	r10	;0x108ca
    5b48:	cc 0a       	mova	r10,	r12	;
    5b4a:	b0 13 e8 52 	calla	#21224		;0x052e8

00005b4e <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    5b4e:	00 18 fa 40 	movx.a	#1600,	16(r10)	;0x00640, 0x00010
    5b52:	40 06 10 00 

00005b56 <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5b56:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    5b5a:	20 00 

00005b5c <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    5b5c:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

00005b60 <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    5b60:	fa 40 13 00 	mov.b	#19,	50(r10)	;#0x0013, 0x0032
    5b64:	32 00 

00005b66 <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    5b66:	fa 40 12 00 	mov.b	#18,	51(r10)	;#0x0012, 0x0033
    5b6a:	33 00 

00005b6c <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    5b6c:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    5b70:	26 00 

00005b72 <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    5b72:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005b76 <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    5b76:	0a 16       	popm.a	#1,	r10	;20-bit words
    5b78:	10 01       	reta			;

00005b7a <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    5b7a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005b7c <.LCFI1>:
    5b7c:	ca 0c       	mova	r12,	r10	;

00005b7e <.Loc.479.1>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    5b7e:	9c 01 ca 08 	cmpa	#67786,	r12	;0x108ca
    5b82:	52 20       	jnz	$+166    	;abs 0x5c28

00005b84 <.Loc.481.1>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    5b84:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5b88:	40 06 

00005b8a <.Loc.483.1>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    5b8a:	3c 0c 02 00 	mova	2(r12),	r12	;

00005b8e <.LVL8>:
    5b8e:	2e 4c       	mov	@r12,	r14	;
    5b90:	1f 4c 02 00 	mov	2(r12),	r15	;
    5b94:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5b98:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5b9c:	b0 13 aa a2 	calla	#41642		;0x0a2aa
    5ba0:	40 18 82 4c 	movx.w	r12,	&0x00646;
    5ba4:	46 06 

00005ba6 <.Loc.485.1>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    5ba6:	40 18 b2 40 	movx.w	#192,	&0x00642;0x000c0
    5baa:	c0 00 42 06 

00005bae <.Loc.490.1>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
        | MSP430X_I2CB0_UCSSEL;
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    5bae:	40 18 b2 40 	movx.w	#3968,	&0x00640;0x00f80
    5bb2:	80 0f 40 06 

00005bb6 <.Loc.492.1>:
  #endif
      if (I2CDB0.regs->statw & BIT4) {
    5bb6:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5bba:	40 18 bc b0 	bitx.w	#16,	8(r12)	;0x00010
    5bbe:	10 00 08 00 
    5bc2:	2b 24       	jz	$+88     	;abs 0x5c1a

00005bc4 <.Loc.494.1>:
        /* Disable again */
        UCB0CTLW0 |= 0x01;
    5bc4:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5bc8:	40 06 

00005bca <.Loc.496.1>:
        /* Set the SCL pin as an output */
        P1SEL1 &= ~0x80;
    5bca:	40 18 f2 f0 	andx.b	#127,	&0x0020c;0x0007f
    5bce:	7f 00 0c 02 

00005bd2 <.Loc.497.1>:
        P1DIR |= 0x80;
    5bd2:	c0 1f f2 d0 	bisx.b	#-128,	&0x00204;0xfff80
    5bd6:	80 ff 04 02 

00005bda <.Loc.498.1>:
        P1REN &= ~0x80;
    5bda:	40 18 f2 f0 	andx.b	#127,	&0x00206;0x0007f
    5bde:	7f 00 06 02 

00005be2 <.LVL10>:
    5be2:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a

00005be6 <.L7>:
        /* Toggle it 10 times */
        for (int i = 0 ; i < 10; i++) {
          P1OUT &= ~0x80;
    5be6:	40 18 f2 f0 	andx.b	#127,	&0x00202;0x0007f
    5bea:	7f 00 02 02 

00005bee <.Loc.502.1>:
          P1OUT |= 0x80;
    5bee:	c0 1f f2 d0 	bisx.b	#-128,	&0x00202;0xfff80
    5bf2:	80 ff 02 02 

00005bf6 <.LVL12>:
    5bf6:	3c 53       	add	#-1,	r12	;r3 As==11

00005bf8 <.LVL13>:
        for (int i = 0 ; i < 10; i++) {
    5bf8:	0c 93       	cmp	#0,	r12	;r3 As==00
    5bfa:	f5 23       	jnz	$-20     	;abs 0x5be6

00005bfc <.LBE53>:
        }
        /* Reset it to I2C mode */
        P1DIR &= ~0x80;
    5bfc:	40 18 f2 f0 	andx.b	#127,	&0x00204;0x0007f
    5c00:	7f 00 04 02 

00005c04 <.Loc.506.1>:
        P1SEL1 |= 0x80;
    5c04:	c0 1f f2 d0 	bisx.b	#-128,	&0x0020c;0xfff80
    5c08:	80 ff 0c 02 

00005c0c <.Loc.507.1>:
        P1REN |= 0x80;
    5c0c:	c0 1f f2 d0 	bisx.b	#-128,	&0x00206;0xfff80
    5c10:	80 ff 06 02 

00005c14 <.Loc.509.1>:
        /* Re-enable the peripheral */
        UCB0CTLW0 &= ~0x01;
    5c14:	40 18 92 c3 	bicx.w	#1,	&0x00640;r3 As==01
    5c18:	40 06 

00005c1a <.L6>:
      }
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    5c1a:	40 18 b2 40 	movx.w	#184,	&0x0066a;0x000b8
    5c1e:	b8 00 6a 06 

00005c22 <.Loc.512.1>:
      UCB0IFG = 0;
    5c22:	40 18 82 43 	movx.w	#0,	&0x0066c;r3 As==00
    5c26:	6c 06 

00005c28 <.L4>:
      }
  #endif
    }
#endif

}
    5c28:	0a 16       	popm.a	#1,	r10	;20-bit words
    5c2a:	10 01       	reta			;

00005c2c <i2cMSP430XStartReceiveToRegI>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    5c2c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005c2e <.LCFI3>:
    5c2e:	06 14       	pushm.a	#1,	r6	;20-bit words

00005c30 <.LCFI4>:
    5c30:	04 14       	pushm.a	#1,	r4	;20-bit words

00005c32 <.LCFI5>:
    5c32:	ca 0c       	mova	r12,	r10	;
    5c34:	49 4d       	mov.b	r13,	r9	;
    5c36:	c6 0e       	mova	r14,	r6	;
    5c38:	c8 0f       	mova	r15,	r8	;
    5c3a:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005c3e <.Loc.680.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5c3e:	9e 00 00 00 	cmpa	#0,	r14	;
    5c42:	04 20       	jnz	$+10     	;abs 0x5c4c

00005c44 <.Loc.680.1>:
    5c44:	8c 01 09 04 	mova	#66569,	r12	;0x10409

00005c48 <.LVL20>:
    5c48:	b0 13 58 46 	calla	#18008		;0x04658

00005c4c <.L16>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5c4c:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5c4e:	04 34       	jge	$+10     	;abs 0x5c58

00005c50 <.Loc.684.1>:
    5c50:	8c 01 09 04 	mova	#66569,	r12	;0x10409
    5c54:	b0 13 58 46 	calla	#18008		;0x04658

00005c58 <.L17>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5c58:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005c5c <.Loc.690.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5c5c:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005c60 <.Loc.692.1>:
  
  i2cp->buffer = regp;
    5c60:	7a 08 08 00 	mova	r8,	8(r10)	;

00005c64 <.Loc.695.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5c64:	96 00 01 00 	cmpa	#1,	r6	;
    5c68:	19 20       	jnz	$+52     	;abs 0x5c9c

00005c6a <.Loc.697.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = regp;
    5c6a:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005c6e <.Loc.698.1>:
    i2cp->req.size = 0;
    5c6e:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005c72 <.Loc.700.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5c72:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5c76:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5c7a:	00 00 

00005c7c <.Loc.702.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5c7c:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005c80 <.L19>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5c80:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5c84:	fd 23       	jnz	$-4      	;abs 0x5c80

00005c86 <.Loc.706.1>:
    /* Call the callback immediately as well */
    if (callback != NULL) {
    5c86:	94 00 00 00 	cmpa	#0,	r4	;
    5c8a:	04 24       	jz	$+10     	;abs 0x5c94

00005c8c <.Loc.707.1>:
      callback(i2cp, regp, 1);
    5c8c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5c8e:	cd 08       	mova	r8,	r13	;
    5c90:	cc 0a       	mova	r10,	r12	;
    5c92:	44 13       	calla	r4		;

00005c94 <.L15>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5c94:	04 16       	popm.a	#1,	r4	;20-bit words
    5c96:	06 16       	popm.a	#1,	r6	;20-bit words
    5c98:	28 16       	popm.a	#3,	r10	;20-bit words
    5c9a:	10 01       	reta			;

00005c9c <.L18>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5c9c:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5ca0:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5ca4:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

00005ca8 <.Loc.713.1>:
    i2cp->req.dest_addr = regp;
    5ca8:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005cac <.Loc.714.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5cac:	40 18 06 46 	movx.w	r6,	r6	;

00005cb0 <.LVL25>:
    5cb0:	36 53       	add	#-1,	r6	;r3 As==11
    5cb2:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

00005cb6 <.Loc.715.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5cb6:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

00005cba <.Loc.716.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5cba:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    5cbe:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005cc2 <.Loc.718.1>:
    i2cp->callback = callback;
    5cc2:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

00005cc6 <.Loc.720.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5cc6:	00 18 fa 40 	movx.a	#24736,	38(r10)	;0x060a0, 0x00026
    5cca:	a0 60 26 00 

00005cce <.Loc.721.1>:
    i2cp->req.callback.args = i2cp;
    5cce:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005cd2 <.Loc.723.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5cd2:	c8 0a       	mova	r10,	r8	;

00005cd4 <.LVL26>:
    5cd4:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5cd8:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5cdc:	9c 00 00 00 	cmpa	#0,	r12	;
    5ce0:	04 24       	jz	$+10     	;abs 0x5cea

00005ce2 <.Loc.723.1>:
    5ce2:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5ce6:	00 00 
    5ce8:	03 20       	jnz	$+8      	;abs 0x5cf0

00005cea <.L21>:
      dmaAcquireI(&(i2cp->dma));
    5cea:	cc 08       	mova	r8,	r12	;
    5cec:	b0 13 c8 59 	calla	#22984		;0x059c8

00005cf0 <.L22>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5cf0:	cd 0a       	mova	r10,	r13	;
    5cf2:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5cf6:	cc 08       	mova	r8,	r12	;
    5cf8:	b0 13 36 5a 	calla	#23094		;0x05a36

00005cfc <.LVL28>:
    i2cp->regs->i2csa = addr;
    5cfc:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5d00:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005d04 <.Loc.730.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5d04:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5d08:	00 00 

00005d0a <.Loc.731.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5d0a:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005d0e <.Loc.733.1>:
}
    5d0e:	80 00 94 5c 	mova	#23700,	r0	;0x05c94

00005d12 <i2cMSP430XStartReceiveI>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    5d12:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005d14 <.LCFI6>:
    5d14:	06 14       	pushm.a	#1,	r6	;20-bit words

00005d16 <.LCFI7>:
    5d16:	04 14       	pushm.a	#1,	r4	;20-bit words

00005d18 <.LCFI8>:
    5d18:	ca 0c       	mova	r12,	r10	;
    5d1a:	49 4d       	mov.b	r13,	r9	;
    5d1c:	c6 0e       	mova	r14,	r6	;
    5d1e:	c8 0f       	mova	r15,	r8	;
    5d20:	34 01 18 00 	mova	24(r1),	r4	;0x00018

00005d24 <.Loc.740.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(n > 0, "can't receive no bytes");
    5d24:	9e 00 00 00 	cmpa	#0,	r14	;
    5d28:	04 20       	jnz	$+10     	;abs 0x5d32

00005d2a <.Loc.740.1>:
    5d2a:	8c 01 f1 03 	mova	#66545,	r12	;0x103f1

00005d2e <.LVL30>:
    5d2e:	b0 13 58 46 	calla	#18008		;0x04658

00005d32 <.L31>:
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5d32:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5d34:	04 34       	jge	$+10     	;abs 0x5d3e

00005d36 <.Loc.744.1>:
    5d36:	8c 01 f1 03 	mova	#66545,	r12	;0x103f1
    5d3a:	b0 13 58 46 	calla	#18008		;0x04658

00005d3e <.L32>:
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5d3e:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005d42 <.Loc.750.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5d42:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005d46 <.Loc.752.1>:
  
  i2cp->buffer = rxbuf;
    5d46:	7a 08 08 00 	mova	r8,	8(r10)	;

00005d4a <.Loc.755.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5d4a:	96 00 01 00 	cmpa	#1,	r6	;
    5d4e:	19 20       	jnz	$+52     	;abs 0x5d82

00005d50 <.Loc.757.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    5d50:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005d54 <.Loc.758.1>:
    i2cp->req.size = 0;
    5d54:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005d58 <.Loc.760.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5d58:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5d5c:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5d60:	00 00 

00005d62 <.Loc.762.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5d62:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005d66 <.L34>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5d66:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    5d6a:	fd 23       	jnz	$-4      	;abs 0x5d66

00005d6c <.Loc.766.1>:
    /* Call the callback immediately as well */
    if (callback != NULL) {
    5d6c:	94 00 00 00 	cmpa	#0,	r4	;
    5d70:	04 24       	jz	$+10     	;abs 0x5d7a

00005d72 <.Loc.768.1>:
      chSysUnlockFromISR();
      callback(i2cp, rxbuf, 1);
    5d72:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5d74:	cd 08       	mova	r8,	r13	;
    5d76:	cc 0a       	mova	r10,	r12	;
    5d78:	44 13       	calla	r4		;

00005d7a <.L30>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5d7a:	04 16       	popm.a	#1,	r4	;20-bit words
    5d7c:	06 16       	popm.a	#1,	r6	;20-bit words
    5d7e:	28 16       	popm.a	#3,	r10	;20-bit words
    5d80:	10 01       	reta			;

00005d82 <.L33>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5d82:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5d86:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    5d8a:	7a 0c 14 00 	mova	r12,	20(r10)	; 0x00014

00005d8e <.Loc.775.1>:
    i2cp->req.dest_addr = rxbuf;
    5d8e:	7a 08 18 00 	mova	r8,	24(r10)	; 0x00018

00005d92 <.Loc.776.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5d92:	40 18 06 46 	movx.w	r6,	r6	;

00005d96 <.LVL35>:
    5d96:	36 53       	add	#-1,	r6	;r3 As==11
    5d98:	8a 46 1c 00 	mov	r6,	28(r10)	; 0x001c

00005d9c <.Loc.777.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    5d9c:	ba 40 00 0c 	mov	#3072,	30(r10)	;#0x0c00, 0x001e
    5da0:	1e 00 

00005da2 <.Loc.778.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5da2:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033
    5da6:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005daa <.Loc.780.1>:
    i2cp->callback = callback;
    5daa:	7a 04 0c 00 	mova	r4,	12(r10)	; 0x0000c

00005dae <.Loc.782.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5dae:	00 18 fa 40 	movx.a	#24736,	38(r10)	;0x060a0, 0x00026
    5db2:	a0 60 26 00 

00005db6 <.Loc.783.1>:
    i2cp->req.callback.args = i2cp;
    5db6:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005dba <.Loc.785.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5dba:	c8 0a       	mova	r10,	r8	;

00005dbc <.LVL36>:
    5dbc:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5dc0:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5dc4:	9c 00 00 00 	cmpa	#0,	r12	;
    5dc8:	04 24       	jz	$+10     	;abs 0x5dd2

00005dca <.Loc.785.1>:
    5dca:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5dce:	00 00 
    5dd0:	03 20       	jnz	$+8      	;abs 0x5dd8

00005dd2 <.L36>:
      dmaAcquireI(&(i2cp->dma));
    5dd2:	cc 08       	mova	r8,	r12	;
    5dd4:	b0 13 c8 59 	calla	#22984		;0x059c8

00005dd8 <.L37>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5dd8:	cd 0a       	mova	r10,	r13	;
    5dda:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5dde:	cc 08       	mova	r8,	r12	;
    5de0:	b0 13 36 5a 	calla	#23094		;0x05a36

00005de4 <.LVL38>:
    i2cp->regs->i2csa = addr;
    5de4:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5de8:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005dec <.Loc.792.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5dec:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5df0:	00 00 

00005df2 <.Loc.793.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5df2:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005df6 <.Loc.795.1>:
}
    5df6:	80 00 7a 5d 	mova	#23930,	r0	;0x05d7a

00005dfa <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5dfa:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005dfc <.LCFI9>:
    5dfc:	06 14       	pushm.a	#1,	r6	;20-bit words

00005dfe <.LCFI10>:
    5dfe:	c6 0c       	mova	r12,	r6	;
    5e00:	49 4d       	mov.b	r13,	r9	;
    5e02:	ca 0e       	mova	r14,	r10	;
    5e04:	c8 0f       	mova	r15,	r8	;

00005e06 <.Loc.802.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
    5e06:	ec 93 00 00 	cmp.b	#2,	0(r12)	;r3 As==10
    5e0a:	04 24       	jz	$+10     	;abs 0x5e14

00005e0c <.Loc.802.1>:
    5e0c:	8c 01 d5 03 	mova	#66517,	r12	;0x103d5

00005e10 <.LVL40>:
    5e10:	b0 13 58 46 	calla	#18008		;0x04658

00005e14 <.L46>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5e14:	9a 00 00 00 	cmpa	#0,	r10	;
    5e18:	04 20       	jnz	$+10     	;abs 0x5e22

00005e1a <.Loc.804.1>:
    5e1a:	8c 01 d5 03 	mova	#66517,	r12	;0x103d5
    5e1e:	b0 13 58 46 	calla	#18008		;0x04658

00005e22 <.L47>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5e22:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5e24:	04 34       	jge	$+10     	;abs 0x5e2e

00005e26 <.Loc.809.1>:
    5e26:	8c 01 d5 03 	mova	#66517,	r12	;0x103d5
    5e2a:	b0 13 58 46 	calla	#18008		;0x04658

00005e2e <.L48>:
#endif
  
  i2cp->regs->ifg &= ~UCTXIFG;
    5e2e:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5e32:	ac c3 2c 00 	bic	#2,	44(r12)	;r3 As==10, 0x002c

00005e36 <.Loc.813.1>:
  i2cp->regs->ie &= ~UCTXIE;
    5e36:	ac c3 2a 00 	bic	#2,	42(r12)	;r3 As==10, 0x002a

00005e3a <.Loc.816.1>:
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5e3a:	86 43 06 00 	mov	#0,	6(r6)	;r3 As==00

00005e3e <.Loc.818.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    5e3e:	f6 40 03 00 	mov.b	#3,	0(r6)	;
    5e42:	00 00 

00005e44 <.Loc.820.1>:
  
  i2cp->buffer = txbuf;
    5e44:	76 08 08 00 	mova	r8,	8(r6)	;

00005e48 <.Loc.823.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    5e48:	ce 0a       	mova	r10,	r14	;
    5e4a:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    5e4e:	e8 0e       	adda	r14,	r8	;

00005e50 <.LVL44>:
    5e50:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005e54 <.Loc.824.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5e54:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5e58:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005e5c <.Loc.825.1>:
  i2cp->req.size = n;
    5e5c:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5e60:	1c 00 

00005e62 <.Loc.826.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    5e62:	b6 40 00 02 	mov	#512,	30(r6)	;#0x0200, 0x001e
    5e66:	1e 00 

00005e68 <.Loc.827.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5e68:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5e6c:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005e70 <.Loc.829.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5e70:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5e74:	14 00 0c 00 

00005e78 <.Loc.831.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5e78:	00 18 f6 40 	movx.a	#23352,	38(r6)	;0x05b38, 0x00026
    5e7c:	38 5b 26 00 

00005e80 <.Loc.833.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    5e80:	ca 06       	mova	r6,	r10	;

00005e82 <.LVL45>:
    5e82:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5e86:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5e8a:	9c 00 00 00 	cmpa	#0,	r12	;
    5e8e:	04 24       	jz	$+10     	;abs 0x5e98

00005e90 <.Loc.833.1>:
    5e90:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5e94:	00 00 
    5e96:	03 20       	jnz	$+8      	;abs 0x5e9e

00005e98 <.L49>:
    dmaAcquireI(&(i2cp->dma));
    5e98:	cc 0a       	mova	r10,	r12	;
    5e9a:	b0 13 c8 59 	calla	#22984		;0x059c8

00005e9e <.L50>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5e9e:	cd 06       	mova	r6,	r13	;
    5ea0:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5ea4:	cc 0a       	mova	r10,	r12	;
    5ea6:	b0 13 36 5a 	calla	#23094		;0x05a36

00005eaa <.LVL47>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    5eaa:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5eae:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005eb2 <.Loc.840.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    5eb2:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    5eb6:	00 00 

00005eb8 <.Loc.843.1>:
  /* IFG is set automatically after START */
  
}
    5eb8:	06 16       	popm.a	#1,	r6	;20-bit words
    5eba:	28 16       	popm.a	#3,	r10	;20-bit words
    5ebc:	10 01       	reta			;

00005ebe <i2cMSP430XContinueTransmitMemsetI>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    5ebe:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005ec0 <.LCFI15>:
    5ec0:	06 14       	pushm.a	#1,	r6	;20-bit words

00005ec2 <.LCFI16>:
    5ec2:	c6 0c       	mova	r12,	r6	;
    5ec4:	49 4d       	mov.b	r13,	r9	;
    5ec6:	ca 0e       	mova	r14,	r10	;
    5ec8:	c8 0f       	mova	r15,	r8	;

00005eca <.Loc.931.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5eca:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    5ece:	00 00 
    5ed0:	04 24       	jz	$+10     	;abs 0x5eda

00005ed2 <.Loc.931.1>:
    5ed2:	8c 01 7b 03 	mova	#66427,	r12	;0x1037b

00005ed6 <.LVL66>:
    5ed6:	b0 13 58 46 	calla	#18008		;0x04658

00005eda <.L79>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5eda:	9a 00 00 00 	cmpa	#0,	r10	;
    5ede:	04 20       	jnz	$+10     	;abs 0x5ee8

00005ee0 <.Loc.933.1>:
    5ee0:	8c 01 7b 03 	mova	#66427,	r12	;0x1037b
    5ee4:	b0 13 58 46 	calla	#18008		;0x04658

00005ee8 <.L80>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5ee8:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5eea:	04 34       	jge	$+10     	;abs 0x5ef4

00005eec <.Loc.938.1>:
    5eec:	8c 01 7b 03 	mova	#66427,	r12	;0x1037b
    5ef0:	b0 13 58 46 	calla	#18008		;0x04658

00005ef4 <.L81>:
#endif
  
  i2cp->buffer = value;
    5ef4:	76 08 08 00 	mova	r8,	8(r6)	;

00005ef8 <.Loc.944.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    5ef8:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005efc <.Loc.945.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5efc:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5f00:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5f04:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005f08 <.Loc.946.1>:
  i2cp->req.size = n;
    5f08:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5f0c:	1c 00 

00005f0e <.Loc.947.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5f0e:	86 43 1e 00 	mov	#0,	30(r6)	;r3 As==00, 0x001e

00005f12 <.Loc.948.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5f12:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5f16:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005f1a <.Loc.950.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5f1a:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5f1e:	14 00 0c 00 

00005f22 <.Loc.952.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5f22:	00 18 f6 40 	movx.a	#23352,	38(r6)	;0x05b38, 0x00026
    5f26:	38 5b 26 00 

00005f2a <.Loc.954.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5f2a:	ca 06       	mova	r6,	r10	;

00005f2c <.LVL70>:
    5f2c:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5f30:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5f34:	9c 00 00 00 	cmpa	#0,	r12	;
    5f38:	04 24       	jz	$+10     	;abs 0x5f42

00005f3a <.Loc.954.1>:
    5f3a:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5f3e:	00 00 
    5f40:	04 20       	jnz	$+10     	;abs 0x5f4a

00005f42 <.L82>:
    5f42:	8c 01 7b 03 	mova	#66427,	r12	;0x1037b
    5f46:	b0 13 58 46 	calla	#18008		;0x04658

00005f4a <.L83>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5f4a:	cd 06       	mova	r6,	r13	;
    5f4c:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5f50:	cc 0a       	mova	r10,	r12	;
    5f52:	b0 13 36 5a 	calla	#23094		;0x05a36

00005f56 <.LVL72>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5f56:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5f5a:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00005f5e <.Loc.960.1>:
  
}
    5f5e:	06 16       	popm.a	#1,	r6	;20-bit words
    5f60:	28 16       	popm.a	#3,	r10	;20-bit words
    5f62:	10 01       	reta			;

00005f64 <i2cMSP430XContinueTransmitI>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    5f64:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005f66 <.LCFI17>:
    5f66:	06 14       	pushm.a	#1,	r6	;20-bit words

00005f68 <.LCFI18>:
    5f68:	c6 0c       	mova	r12,	r6	;
    5f6a:	49 4d       	mov.b	r13,	r9	;
    5f6c:	ca 0e       	mova	r14,	r10	;
    5f6e:	c8 0f       	mova	r15,	r8	;

00005f70 <.Loc.967.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_TX, "can't continue");
    5f70:	fc 90 03 00 	cmp.b	#3,	0(r12)	;
    5f74:	00 00 
    5f76:	04 24       	jz	$+10     	;abs 0x5f80

00005f78 <.Loc.967.1>:
    5f78:	8c 01 5f 03 	mova	#66399,	r12	;0x1035f

00005f7c <.LVL74>:
    5f7c:	b0 13 58 46 	calla	#18008		;0x04658

00005f80 <.L88>:
  
  osalDbgAssert(n > 0, "can't transmit no bytes");
    5f80:	9a 00 00 00 	cmpa	#0,	r10	;
    5f84:	04 20       	jnz	$+10     	;abs 0x5f8e

00005f86 <.Loc.969.1>:
    5f86:	8c 01 5f 03 	mova	#66399,	r12	;0x1035f
    5f8a:	b0 13 58 46 	calla	#18008		;0x04658

00005f8e <.L89>:
  
#if MSP430X_I2C_10BIT
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
    5f8e:	49 93       	cmp.b	#0,	r9	;r3 As==00
    5f90:	04 34       	jge	$+10     	;abs 0x5f9a

00005f92 <.Loc.974.1>:
    5f92:	8c 01 5f 03 	mova	#66399,	r12	;0x1035f
    5f96:	b0 13 58 46 	calla	#18008		;0x04658

00005f9a <.L90>:
#endif
  
  i2cp->buffer = txbuf;
    5f9a:	76 08 08 00 	mova	r8,	8(r6)	;

00005f9e <.Loc.980.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    5f9e:	76 08 14 00 	mova	r8,	20(r6)	; 0x00014

00005fa2 <.Loc.981.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    5fa2:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    5fa6:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    5faa:	76 0c 18 00 	mova	r12,	24(r6)	; 0x00018

00005fae <.Loc.982.1>:
  i2cp->req.size = n;
    5fae:	40 18 86 4a 	movx.w	r10,	28(r6)	; 0x0001c
    5fb2:	1c 00 

00005fb4 <.Loc.983.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    5fb4:	b6 40 00 03 	mov	#768,	30(r6)	;#0x0300, 0x001e
    5fb8:	1e 00 

00005fba <.Loc.984.1>:
  i2cp->req.trigger = i2cp->txtrig;
    5fba:	5c 46 32 00 	mov.b	50(r6),	r12	;0x00032
    5fbe:	86 4c 24 00 	mov	r12,	36(r6)	; 0x0024

00005fc2 <.Loc.986.1>:
  /* Custom callback */
  i2cp->callback = callback;
    5fc2:	00 18 d6 41 	movx.a	20(r1),	12(r6)	;0x00014, 0x0000c
    5fc6:	14 00 0c 00 

00005fca <.Loc.988.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    5fca:	00 18 f6 40 	movx.a	#23352,	38(r6)	;0x05b38, 0x00026
    5fce:	38 5b 26 00 

00005fd2 <.Loc.990.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
    5fd2:	ca 06       	mova	r6,	r10	;

00005fd4 <.LVL78>:
    5fd4:	aa 00 34 00 	adda	#52,	r10	;0x00034
    5fd8:	3c 06 34 00 	mova	52(r6),	r12	;0x00034
    5fdc:	9c 00 00 00 	cmpa	#0,	r12	;
    5fe0:	04 24       	jz	$+10     	;abs 0x5fea

00005fe2 <.Loc.990.1>:
    5fe2:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5fe6:	00 00 
    5fe8:	04 20       	jnz	$+10     	;abs 0x5ff2

00005fea <.L91>:
    5fea:	8c 01 5f 03 	mova	#66399,	r12	;0x1035f
    5fee:	b0 13 58 46 	calla	#18008		;0x04658

00005ff2 <.L92>:
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5ff2:	cd 06       	mova	r6,	r13	;
    5ff4:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5ff8:	cc 0a       	mova	r10,	r12	;
    5ffa:	b0 13 36 5a 	calla	#23094		;0x05a36

00005ffe <.LVL80>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    5ffe:	3c 06 10 00 	mova	16(r6),	r12	;0x00010
    6002:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

00006006 <.Loc.996.1>:
  
}
    6006:	06 16       	popm.a	#1,	r6	;20-bit words
    6008:	28 16       	popm.a	#3,	r10	;20-bit words
    600a:	10 01       	reta			;

0000600c <i2cMSP430XEndTransferI>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    600c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000600e <.LCFI19>:
    600e:	b1 00 02 00 	suba	#2,	r1	;

00006012 <.LCFI20>:
    6012:	ca 0c       	mova	r12,	r10	;

00006014 <.Loc.1002.1>:
  
  osalDbgCheckClassI();
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
    6014:	6c 4c       	mov.b	@r12,	r12	;

00006016 <.LVL82>:
    6016:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    601a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    601c:	4d 9c       	cmp.b	r12,	r13	;
    601e:	04 2c       	jc	$+10     	;abs 0x6028

00006020 <.Loc.1002.1>:
    6020:	8c 01 48 03 	mova	#66376,	r12	;0x10348
    6024:	b0 13 58 46 	calla	#18008		;0x04658

00006028 <.L97>:
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    6028:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    602c:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

00006030 <.Loc.1008.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    6030:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    6034:	2e 20       	jnz	$+94     	;abs 0x6092

00006036 <.L110>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
    
    /* Wait for last RX byte */
    while (!(i2cp->regs->ifg & UCRXIFG0));
    6036:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    603a:	2c 00 
    603c:	fc 27       	jz	$-6      	;abs 0x6036
    603e:	3e 0a 18 00 	mova	24(r10),r14	;0x00018

00006042 <.Loc.1018.1>:
    
    if (i2cp->req.addr_mode) {
    6042:	8a 93 1e 00 	cmp	#0,	30(r10)	;r3 As==00, 0x001e
    6046:	1f 24       	jz	$+64     	;abs 0x6086

00006048 <.Loc.1019.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    6048:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    604c:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    6050:	1c 00 
    6052:	ec 0e       	adda	r14,	r12	;
    6054:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006058 <.L101>:
    }
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
    
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    6058:	3c 0a 10 00 	mova	16(r10),r12	;0x00010

0000605c <.L102>:
    605c:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    6060:	fd 23       	jnz	$-4      	;abs 0x605c

00006062 <.Loc.1026.1>:
    i2cp->regs->ifg &= ~UCSTPIFG;
    6062:	bc c2 2c 00 	bic	#8,	44(r12)	;r2 As==11, 0x002c

00006066 <.Loc.1028.1>:
      
    if (i2cp->regs->ifg & UCRXIFG0) {
    6066:	40 18 9c b3 	bitx.w	#1,	44(r12)	;r3 As==01, 0x0002c
    606a:	2c 00 
    606c:	06 24       	jz	$+14     	;abs 0x607a

0000606e <.LBB68>:
      /* Need to read the buffer to reset the state */
      volatile uint8_t throwaway;
      throwaway = i2cp->regs->rxbuf;
    606e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6072:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00006076 <.Loc.1032.1>:
      (void)(throwaway);
    6076:	5c 41 01 00 	mov.b	1(r1),	r12	;

0000607a <.L103>:
  else {
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    i2cp->regs->ifg &= ~UCSTPIFG;
  }
  
  i2cp->state = I2C_READY;
    607a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000607e <.Loc.1041.1>:
}
    607e:	a1 00 02 00 	adda	#2,	r1	;
    6082:	0a 16       	popm.a	#1,	r10	;20-bit words
    6084:	10 01       	reta			;

00006086 <.L100>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    6086:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    608a:	ce 4c 00 00 	mov.b	r12,	0(r14)	;
    608e:	80 00 58 60 	mova	#24664,	r0	;0x06058

00006092 <.L107>:
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    6092:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    6096:	fd 23       	jnz	$-4      	;abs 0x6092

00006098 <.Loc.1037.1>:
    i2cp->regs->ifg &= ~UCSTPIFG;
    6098:	bc c2 2c 00 	bic	#8,	44(r12)	;r2 As==11, 0x002c
    609c:	80 00 7a 60 	mova	#24698,	r0	;0x0607a

000060a0 <rx_async_callback>:
void rx_async_callback(void * args) {
    60a0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000060a2 <.LCFI21>:
    60a2:	08 14       	pushm.a	#1,	r8	;20-bit words

000060a4 <.LCFI22>:
    60a4:	ca 0c       	mova	r12,	r10	;

000060a6 <.LVL85>:
  if (NULL != i2cp->callback) {
    60a6:	38 0c 0c 00 	mova	12(r12),r8	;0x0000c
    60aa:	98 00 00 00 	cmpa	#0,	r8	;
    60ae:	08 24       	jz	$+18     	;abs 0x60c0

000060b0 <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    60b0:	1e 4c 1c 00 	mov	28(r12),r14	;0x0001c
    60b4:	3d 0c 08 00 	mova	8(r12),	r13	;
    60b8:	48 13       	calla	r8		;

000060ba <.L113>:
}
    60ba:	08 16       	popm.a	#1,	r8	;20-bit words
    60bc:	0a 16       	popm.a	#1,	r10	;20-bit words
    60be:	10 01       	reta			;

000060c0 <.L114>:
    i2cMSP430XEndTransferI(i2cp);
    60c0:	b0 13 0c 60 	calla	#24588		;0x0600c

000060c4 <.LVL87>:
}
    60c4:	80 00 ba 60 	mova	#24762,	r0	;0x060ba

000060c8 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
    60c8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000060ca <.LCFI0>:

#if MSP430X_GPT_USE_TA0 == TRUE
  /* Driver initialization.*/
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
    60ca:	8c 01 12 09 	mova	#67858,	r12	;0x10912
    60ce:	00 18 fc 40 	movx.a	#832,	6(r12)	;0x00340
    60d2:	40 03 06 00 

000060d6 <.Loc.249.1>:
  gptObjectInit(&GPTDA0);
    60d6:	8a 00 8c 52 	mova	#21132,	r10	;0x0528c
    60da:	4a 13       	calla	r10		;

000060dc <.LVL0>:
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    60dc:	8c 01 08 09 	mova	#67848,	r12	;0x10908
    60e0:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    60e4:	80 03 06 00 

000060e8 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    60e8:	4a 13       	calla	r10		;

000060ea <.LVL1>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    60ea:	0a 16       	popm.a	#1,	r10	;20-bit words
    60ec:	10 01       	reta			;

000060ee <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    60ee:	2a 14       	pushm.a	#3,	r10	;20-bit words

000060f0 <.LCFI1>:
    60f0:	ca 0c       	mova	r12,	r10	;

000060f2 <.LVL3>:
  uint32_t divider = 0;

  /* Configures the peripheral.*/
#if MSP430X_GPT_USE_TA0 == TRUE
  if (&GPTDA0 == gptp) {
    60f2:	9c 01 12 09 	cmpa	#67858,	r12	;0x10912
    60f6:	2d 20       	jnz	$+92     	;abs 0x6152

000060f8 <.L16>:
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    60f8:	3c 0a 06 00 	mova	6(r10),	r12	;

000060fc <.LVL4>:
    60fc:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    6100:	00 00 

00006102 <.Loc.304.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    6102:	3c 0a 02 00 	mova	2(r10),	r12	;
    6106:	2e 4c       	mov	@r12,	r14	;
    6108:	1f 4c 02 00 	mov	2(r12),	r15	;
    610c:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    6110:	4d 43       	clr.b	r13		;
    6112:	b0 13 aa a2 	calla	#41642		;0x0a2aa

00006116 <.L4>:
    6116:	08 4c       	mov	r12,	r8	;
    6118:	09 4d       	mov	r13,	r9	;
    611a:	0d 93       	cmp	#0,	r13	;r3 As==00
    611c:	04 20       	jnz	$+10     	;abs 0x6126
    611e:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040

00006122 <.LVL6>:
    6122:	0c 98       	cmp	r8,	r12	;
    6124:	1d 2c       	jc	$+60     	;abs 0x6160

00006126 <.L6>:
    6126:	78 40 40 00 	mov.b	#64,	r8	;#0x0040
    612a:	49 43       	clr.b	r9		;

0000612c <.L15>:
  if (divider > 64) {
    divider = 64;
  }
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    612c:	3c 0a 06 00 	mova	6(r10),	r12	;
    6130:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    6134:	00 00 

00006136 <.Loc.349.1>:
    divider /= 8;
    6136:	0c 48       	mov	r8,	r12	;
    6138:	0d 49       	mov	r9,	r13	;
    613a:	b0 13 c2 a3 	calla	#41922		;0x0a3c2
    613e:	08 4c       	mov	r12,	r8	;

00006140 <.LVL9>:
    6140:	09 4d       	mov	r13,	r9	;

00006142 <.L8>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    6142:	3c 0a 06 00 	mova	6(r10),	r12	;
    6146:	0d 48       	mov	r8,	r13	;
    6148:	3d 53       	add	#-1,	r13	;r3 As==11
    614a:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

0000614e <.Loc.362.1>:

}
    614e:	28 16       	popm.a	#3,	r10	;20-bit words
    6150:	10 01       	reta			;

00006152 <.L3>:
  if (&GPTDA1 == gptp) {
    6152:	9c 01 08 09 	cmpa	#67848,	r12	;0x10908
    6156:	d0 27       	jz	$-94     	;abs 0x60f8

00006158 <.Loc.286.1>:
  uint32_t divider = 0;
    6158:	4c 43       	clr.b	r12		;
    615a:	4d 43       	clr.b	r13		;
    615c:	80 00 16 61 	mova	#24854,	r0	;0x06116

00006160 <.L14>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    6160:	0c 48       	mov	r8,	r12	;
    6162:	7c f0 07 00 	and.b	#7,	r12	;
    6166:	0c 93       	cmp	#0,	r12	;r3 As==00
    6168:	e1 27       	jz	$-60     	;abs 0x612c

0000616a <.Loc.351.1>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    616a:	0c 48       	mov	r8,	r12	;
    616c:	7c f0 03 00 	and.b	#3,	r12	;
    6170:	0c 93       	cmp	#0,	r12	;r3 As==00
    6172:	16 20       	jnz	$+46     	;abs 0x61a0

00006174 <.Loc.352.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    6174:	3c 0a 06 00 	mova	6(r10),	r12	;
    6178:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    617c:	00 00 

0000617e <.Loc.353.1>:
    divider /= 4;
    617e:	40 19 09 10 	rrux.w	r9		;
    6182:	08 10       	rrc	r8		;
    6184:	40 19 09 10 	rrux.w	r9		;
    6188:	08 10       	rrc	r8		;

0000618a <.L10>:
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    618a:	09 93       	cmp	#0,	r9	;r3 As==00
    618c:	03 20       	jnz	$+8      	;abs 0x6194
    618e:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6190:	0d 98       	cmp	r8,	r13	;
    6192:	d7 2f       	jc	$-80     	;abs 0x6142

00006194 <.L13>:
    6194:	8c 01 46 04 	mova	#66630,	r12	;0x10446
    6198:	b0 13 58 46 	calla	#18008		;0x04658

0000619c <.LVL14>:
    619c:	80 00 42 61 	mova	#24898,	r0	;0x06142

000061a0 <.L9>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    61a0:	0c 48       	mov	r8,	r12	;
    61a2:	5c f3       	and.b	#1,	r12	;r3 As==01
    61a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    61a6:	f1 23       	jnz	$-28     	;abs 0x618a

000061a8 <.Loc.356.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    61a8:	3c 0a 06 00 	mova	6(r10),	r12	;
    61ac:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    61b0:	00 00 

000061b2 <.Loc.357.1>:
    divider /= 2;
    61b2:	12 c3       	clrc			
    61b4:	09 10       	rrc	r9		;
    61b6:	08 10       	rrc	r8		;
    61b8:	80 00 8a 61 	mova	#24970,	r0	;0x0618a

000061bc <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    61bc:	3c 0c 06 00 	mova	6(r12),	r12	;

000061c0 <.LVL22>:
    61c0:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    61c4:	00 00 

000061c6 <.Loc.415.1>:

}
    61c6:	10 01       	reta			;

000061c8 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    61c8:	32 c2       	dint			
    61ca:	03 43       	nop			

000061cc <.Loc.46.1>:

}
    61cc:	10 01       	reta			;

000061ce <serial_callback>:
/* Using UARTDA1 */
SerialConfig __attribute__((section(".persistent"))) A1_cfg = {
  UART_BAUD, /* Baud rate */
};

static void serial_callback(event_source_t *p) {
    61ce:	0a 14       	pushm.a	#1,	r10	;20-bit words

000061d0 <.LCFI0>:
    61d0:	ca 0c       	mova	r12,	r10	;

000061d2 <.Loc.58.1>:
  chEvtSignalI(uart_thd, p->flags);
    61d2:	2d 4c       	mov	@r12,	r13	;
    61d4:	1e 4c 02 00 	mov	2(r12),	r14	;
    61d8:	2c 00 d4 a7 	mova	&42964,	r12	;0x0a7d4

000061dc <.LVL1>:
    61dc:	b0 13 98 49 	calla	#18840		;0x04998

000061e0 <.LVL2>:
  p->flags = 0;
    61e0:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00
    61e4:	8a 43 02 00 	mov	#0,	2(r10)	;r3 As==00

000061e8 <.Loc.60.1>:
}
    61e8:	0a 16       	popm.a	#1,	r10	;20-bit words
    61ea:	10 01       	reta			;

000061ec <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    61ec:	01 18 d2 92 	cmpx.a	&0x0a7d4,&0x1077c;
    61f0:	d4 a7 7c 07 
    61f4:	04 20       	jnz	$+10     	;abs 0x61fe

000061f6 <.Loc.19.1>:
    61f6:	8c 01 7a 04 	mova	#66682,	r12	;0x1047a
    61fa:	b0 13 58 46 	calla	#18008		;0x04658

000061fe <.L5>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    61fe:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    6202:	4e 43       	clr.b	r14		;
    6204:	2c 00 d4 a7 	mova	&42964,	r12	;0x0a7d4
    6208:	b0 13 6c 49 	calla	#18796		;0x0496c

0000620c <.LVL6>:
}
    620c:	10 01       	reta			;

0000620e <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    620e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006210 <.LCFI1>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    6210:	cd 0c       	mova	r12,	r13	;
    6212:	8c 01 fa 06 	mova	#67322,	r12	;0x106fa

00006216 <.LVL8>:
    6216:	b0 13 be 4a 	calla	#19134		;0x04abe

0000621a <.LVL9>:
    621a:	ca 0c       	mova	r12,	r10	;

0000621c <.Loc.26.1>:
  if (MSG_OK == msg) {
    621c:	9c 00 00 00 	cmpa	#0,	r12	;
    6220:	0a 20       	jnz	$+22     	;abs 0x6236

00006222 <.Loc.27.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    6222:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    6226:	4e 43       	clr.b	r14		;
    6228:	2c 00 d4 a7 	mova	&42964,	r12	;0x0a7d4
    622c:	b0 13 98 49 	calla	#18840		;0x04998

00006230 <.L6>:
}
    6230:	cc 0a       	mova	r10,	r12	;
    6232:	0a 16       	popm.a	#1,	r10	;20-bit words
    6234:	10 01       	reta			;

00006236 <.L7>:
    chSysHalt("an error");
    6236:	8c 00 94 a5 	mova	#42388,	r12	;0x0a594
    623a:	b0 13 58 46 	calla	#18008		;0x04658

0000623e <.LVL12>:
  return msg;
    623e:	80 00 30 62 	mova	#25136,	r0	;0x06230

00006242 <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    6242:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006244 <.LBB18>:
  _disable_interrupts();
    6244:	32 c2       	dint			
    6246:	03 43       	nop			

00006248 <.Loc.348.2>:
  asm volatile("nop");
    6248:	03 43       	nop			

0000624a <.LBE18>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    624a:	0e 4d       	mov	r13,	r14	;
    624c:	cd 0c       	mova	r12,	r13	;

0000624e <.LVL14>:
    624e:	8c 01 fa 06 	mova	#67322,	r12	;0x106fa

00006252 <.LVL15>:
    6252:	b0 13 44 4a 	calla	#19012		;0x04a44

00006256 <.LVL16>:
    6256:	ca 0c       	mova	r12,	r10	;

00006258 <.Loc.42.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    6258:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    625c:	4e 43       	clr.b	r14		;
    625e:	2c 00 d4 a7 	mova	&42964,	r12	;0x0a7d4
    6262:	b0 13 98 49 	calla	#18840		;0x04998

00006266 <.LBB20>:
  asm volatile("nop");
    6266:	03 43       	nop			

00006268 <.Loc.356.2>:
  _enable_interrupts();
    6268:	03 43       	nop			
    626a:	32 d2       	eint			
    626c:	03 43       	nop			

0000626e <.LBE20>:
}
    626e:	cc 0a       	mova	r10,	r12	;
    6270:	0a 16       	popm.a	#1,	r10	;20-bit words
    6272:	10 01       	reta			;

00006274 <UARTThd>:
static bool is_byte(msg_t c) {
  return (c >= 0 && c < 256);
}

THD_WORKING_AREA(waUARTThd, 512);
THD_FUNCTION(UARTThd, arg) {
    6274:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006276 <.LCFI3>:
    6276:	04 14       	pushm.a	#1,	r4	;20-bit words

00006278 <.LCFI4>:
    6278:	b1 00 04 00 	suba	#4,	r1	;

0000627c <.LCFI5>:
  (void)arg;
  static msg_t tx_char;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    627c:	80 18 d2 42 	movx.a	&0x1077c,&0xfa7d4;
    6280:	7c 07 d4 a7 

00006284 <.Loc.74.1>:
  
  events = UARTConfigUpdated;
    6284:	40 18 b2 40 	movx.w	#1024,	&0xfa7dc;0x00400
    6288:	00 04 dc a7 
    628c:	40 18 82 43 	movx.w	#0,	&0xfa7de;r3 As==00
    6290:	de a7 

00006292 <.LBB50>:
                                        eventcallback_t cb,
                                        void *param) {

  osalDbgCheck(esp != NULL);

  esp->cb    = cb;
    6292:	86 01 dc 07 	mova	#67548,	r6	;0x107dc
    6296:	01 18 f2 40 	movx.a	#25038,	&0x107e4;0x061ce
    629a:	ce 61 e4 07 

0000629e <.Loc.873.3>:
  esp->param = param;
    629e:	cc 06       	mova	r6,	r12	;

000062a0 <.LVL21>:
    62a0:	ac 00 04 00 	adda	#4,	r12	;
    62a4:	76 0c 0c 00 	mova	r12,	12(r6)	; 0x0000c

000062a8 <.LBE50>:
  
  osalEventSetCallback(chnGetEventSource(&ELY_UART), 
      serial_callback, chnGetEventSource(&ELY_UART));
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    62a8:	8d 01 a4 04 	mova	#66724,	r13	;0x104a4
    62ac:	8c 01 08 09 	mova	#67848,	r12	;0x10908
    62b0:	b0 13 98 52 	calla	#21144		;0x05298

000062b4 <.LVL23>:
  
  elyUARTDLLRxInit();
    62b4:	b0 13 0c 98 	calla	#38924		;0x0980c

000062b8 <.LVL24>:
      /* Autobaud */
      /*A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);*/
      /* Baud rate */
      A1_cfg.sc_bitrate = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    62b8:	24 01 b0 05 	mova	&66992,	r4	;0x105b0

000062bc <.LBB52>:
      ELY_UART.event.flags |= CHN_OUTPUT_EMPTY;
      events &= ~UARTConfigUpdated;
    }
    if (events & CHN_INPUT_AVAILABLE) {
      msg_t c;
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    62bc:	c7 06       	mova	r6,	r7	;
    62be:	a7 00 12 00 	adda	#18,	r7	;0x00012

000062c2 <.LBE52>:
      events &= ~UARTBufferPosted;
    }
    if (events & CHN_OUTPUT_EMPTY) {
      /* Take characters from the TX state machine until the buffer ends or
       * the queue is full */
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    62c2:	c9 06       	mova	r6,	r9	;
    62c4:	a9 00 30 00 	adda	#48,	r9	;0x00030

000062c8 <.L28>:
    if (events & UARTConfigUpdated) {
    62c8:	40 18 e2 b2 	bitx.b	#4,	&0xfa7dd;r2 As==10
    62cc:	dd a7 
    62ce:	37 24       	jz	$+112    	;abs 0x633e

000062d0 <.LBB53>:
  _disable_interrupts();
    62d0:	32 c2       	dint			
    62d2:	03 43       	nop			

000062d4 <.Loc.348.2>:
  asm volatile("nop");
    62d4:	03 43       	nop			

000062d6 <.LBE53>:
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    62d6:	5d 44 23 00 	mov.b	35(r4),	r13	;0x00023
    62da:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    62de:	5c 44 25 00 	mov.b	37(r4),	r12	;0x00025
    62e2:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    62e6:	5e 44 24 00 	mov.b	36(r4),	r14	;0x00024
    62ea:	0c de       	bis	r14,	r12	;

000062ec <.Loc.95.1>:
      A1_cfg.sc_bitrate = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    62ec:	5f 44 22 00 	mov.b	34(r4),	r15	;0x00022
    62f0:	0f dd       	bis	r13,	r15	;
    62f2:	40 18 82 4f 	movx.w	r15,	&0xfa618;
    62f6:	18 a6 
    62f8:	40 18 82 4c 	movx.w	r12,	&0xfa61a;
    62fc:	1a a6 

000062fe <.LBB55>:
  asm volatile("nop");
    62fe:	03 43       	nop			

00006300 <.Loc.356.2>:
  _enable_interrupts();
    6300:	03 43       	nop			
    6302:	32 d2       	eint			
    6304:	03 43       	nop			

00006306 <.LBE55>:
      sdStart(&ELY_UART, &A1_cfg);
    6306:	8d 00 18 a6 	mova	#42520,	r13	;0x0a618
    630a:	8c 01 dc 07 	mova	#67548,	r12	;0x107dc
    630e:	b0 13 54 54 	calla	#21588		;0x05454

00006312 <.LVL25>:
      ELY_UART.event.flags |= CHN_OUTPUT_EMPTY;
    6312:	1c 46 04 00 	mov	4(r6),	r12	;
    6316:	1d 46 06 00 	mov	6(r6),	r13	;
    631a:	0e 4c       	mov	r12,	r14	;
    631c:	3e d2       	bis	#8,	r14	;r2 As==11
    631e:	81 4e 00 00 	mov	r14,	0(r1)	;
    6322:	81 4d 02 00 	mov	r13,	2(r1)	;
    6326:	a6 41 04 00 	mov	@r1,	4(r6)	;
    632a:	96 41 02 00 	mov	2(r1),	6(r6)	;
    632e:	06 00 

00006330 <.Loc.104.1>:
      events &= ~UARTConfigUpdated;
    6330:	c0 1f b2 f0 	andx.w	#-1025,	&0xfa7dc;0xffbff
    6334:	ff fb dc a7 
    6338:	40 18 82 c3 	bicx.w	#0,	&0xfa7de;r3 As==00
    633c:	de a7 

0000633e <.L11>:
    if (events & CHN_INPUT_AVAILABLE) {
    633e:	40 18 e2 b2 	bitx.b	#4,	&0xfa7dc;r2 As==10
    6342:	dc a7 
    6344:	9b 20       	jnz	$+312    	;abs 0x647c

00006346 <.L14>:
    if (events & UARTBufferPosted) {
    6346:	40 18 f2 b2 	bitx.b	#8,	&0xfa7dd;r2 As==11
    634a:	dd a7 
    634c:	35 24       	jz	$+108    	;abs 0x63b8

0000634e <.LBB57>:
  _disable_interrupts();
    634e:	32 c2       	dint			
    6350:	03 43       	nop			

00006352 <.Loc.348.2>:
  asm volatile("nop");
    6352:	03 43       	nop			

00006354 <.LBE58>:
      msg_t result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    6354:	3e 43       	mov	#-1,	r14	;r3 As==11
    6356:	8d 00 d8 a7 	mova	#42968,	r13	;0x0a7d8
    635a:	8c 01 fa 06 	mova	#67322,	r12	;0x106fa
    635e:	b0 13 1c 4b 	calla	#19228		;0x04b1c

00006362 <.LBB60>:
  asm volatile("nop");
    6362:	03 43       	nop			

00006364 <.Loc.356.2>:
  _enable_interrupts();
    6364:	03 43       	nop			
    6366:	32 d2       	eint			
    6368:	03 43       	nop			

0000636a <.LBE60>:
      chDbgAssert(result == MSG_OK, "Incorrect event on buffer posting");
    636a:	9c 00 00 00 	cmpa	#0,	r12	;
    636e:	04 24       	jz	$+10     	;abs 0x6378

00006370 <.Loc.117.1>:
    6370:	8c 01 72 04 	mova	#66674,	r12	;0x10472

00006374 <.LVL27>:
    6374:	b0 13 58 46 	calla	#18008		;0x04658

00006378 <.L18>:
      elyUARTDLLTxSetBuffer(tx_active_buffer);
    6378:	2c 00 d8 a7 	mova	&42968,	r12	;0x0a7d8
    637c:	b0 13 e2 97 	calla	#38882		;0x097e2

00006380 <.LVL29>:
      tx_char = elyUARTDLLTxStateMachine();
    6380:	b0 13 20 97 	calla	#38688		;0x09720

00006384 <.LVL30>:
    6384:	60 0c d0 a7 	mova	r12,	&42960	; 0x0a7d0

00006388 <.Loc.120.1>:
      chDbgAssert(is_byte(tx_char), "Null TX Buffer");
    6388:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    638c:	dd 0c       	cmpa	r12,	r13	;
    638e:	04 2c       	jc	$+10     	;abs 0x6398

00006390 <.Loc.120.1>:
    6390:	8c 01 72 04 	mova	#66674,	r12	;0x10472
    6394:	b0 13 58 46 	calla	#18008		;0x04658

00006398 <.L19>:
      UARTEvtMask &= ~UARTBufferPosted;
    6398:	c0 18 1c 42 	movx.w	&0x106f8,r12	;
    639c:	f8 06 
    639e:	3c f0 ff f7 	and	#-2049,	r12	;#0xf7ff

000063a2 <.Loc.122.1>:
      UARTEvtMask |= CHN_OUTPUT_EMPTY;
    63a2:	3c d2       	bis	#8,	r12	;r2 As==11
    63a4:	41 18 82 4c 	movx.w	r12,	&0x106f8;
    63a8:	f8 06 

000063aa <.Loc.123.1>:
      events &= ~UARTBufferPosted;
    63aa:	c0 1f b2 f0 	andx.w	#-2049,	&0xfa7dc;0xff7ff
    63ae:	ff f7 dc a7 
    63b2:	40 18 82 c3 	bicx.w	#0,	&0xfa7de;r3 As==00
    63b6:	de a7 

000063b8 <.L16>:
    if (events & CHN_OUTPUT_EMPTY) {
    63b8:	40 18 f2 b2 	bitx.b	#8,	&0xfa7dc;r2 As==11
    63bc:	dc a7 
    63be:	64 20       	jnz	$+202    	;abs 0x6488

000063c0 <.L21>:
          break;
        }
      }
      events &= ~CHN_OUTPUT_EMPTY;
    }
    if (events & CHN_TRANSMISSION_END) {
    63c0:	40 18 f2 b0 	bitx.b	#16,	&0xfa7dc;0x00010
    63c4:	10 00 dc a7 
    63c8:	32 24       	jz	$+102    	;abs 0x642e

000063ca <.Loc.139.1>:
      chDbgAssert(NULL != tx_active_buffer, "Transmission ended but we weren't sending");
    63ca:	00 18 c2 93 	cmpx.a	#0,	&0xfa7d8;r3 As==00
    63ce:	d8 a7 
    63d0:	04 20       	jnz	$+10     	;abs 0x63da

000063d2 <.Loc.139.1>:
    63d2:	8c 01 72 04 	mova	#66674,	r12	;0x10472
    63d6:	b0 13 58 46 	calla	#18008		;0x04658

000063da <.L26>:
      elyNLFreeBufferChecked(tx_active_buffer);
    63da:	2c 00 d8 a7 	mova	&42968,	r12	;0x0a7d8
    63de:	b0 13 ba 9f 	calla	#40890		;0x09fba

000063e2 <.LVL33>:
      tx_active_buffer = NULL;
    63e2:	00 18 c2 43 	movx.a	#0,	&0xfa7d8;r3 As==00
    63e6:	d8 a7 

000063e8 <.Loc.142.1>:
      UARTEvtMask |= UARTBufferPosted;
    63e8:	41 18 b2 d0 	bisx.w	#2048,	&0x106f8;0x00800
    63ec:	00 08 f8 06 

000063f0 <.LBB62>:
  _disable_interrupts();
    63f0:	32 c2       	dint			
    63f2:	03 43       	nop			

000063f4 <.Loc.348.2>:
  asm volatile("nop");
    63f4:	03 43       	nop			

000063f6 <.LBB64>:
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->fullsem);
    63f6:	c0 18 1c 42 	movx.w	&0x1070a,r12	;
    63fa:	0a 07 

000063fc <.LBE64>:
      /* are there more buffers to be sent? */
      chSysLock();
      if (chMBGetUsedCountI(&uart_mbox) > 0) {
    63fc:	4f 43       	clr.b	r15		;
    63fe:	0f 9c       	cmp	r12,	r15	;
    6400:	07 34       	jge	$+16     	;abs 0x6410

00006402 <.Loc.146.1>:
        chEvtSignalI(uart_thd, UARTBufferPosted);
    6402:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    6406:	4e 43       	clr.b	r14		;
    6408:	2c 00 d4 a7 	mova	&42964,	r12	;0x0a7d4
    640c:	b0 13 98 49 	calla	#18840		;0x04998

00006410 <.L27>:
  asm volatile("nop");
    6410:	03 43       	nop			

00006412 <.Loc.356.2>:
  _enable_interrupts();
    6412:	03 43       	nop			
    6414:	32 d2       	eint			
    6416:	03 43       	nop			

00006418 <.LBE66>:
      }
      chSysUnlock();
      UARTEvtMask &= ~CHN_TRANSMISSION_END;
    6418:	c1 1f b2 f0 	andx.w	#-17,	&0x106f8;0xfffef
    641c:	ef ff f8 06 

00006420 <.Loc.150.1>:
      events &= ~CHN_TRANSMISSION_END;
    6420:	c0 1f b2 f0 	andx.w	#-17,	&0xfa7dc;0xfffef
    6424:	ef ff dc a7 
    6428:	40 18 82 c3 	bicx.w	#0,	&0xfa7de;r3 As==00
    642c:	de a7 

0000642e <.L24>:
  _disable_interrupts();
    642e:	32 c2       	dint			
    6430:	03 43       	nop			

00006432 <.Loc.348.2>:
  asm volatile("nop");
    6432:	03 43       	nop			

00006434 <.LBE68>:
    }
    
    chSysLock();
    events |= chEvtWaitAnyTimeoutS(UARTEvtMask, TIME_INFINITE);
    6434:	4e 43       	clr.b	r14		;
    6436:	c0 18 1f 42 	movx.w	&0x106f8,r15	;
    643a:	f8 06 
    643c:	0c 4f       	mov	r15,	r12	;
    643e:	0d 43       	clr	r13		;
    6440:	b0 13 92 65 	calla	#26002		;0x06592

00006444 <.LVL37>:
    6444:	40 18 82 dc 	bisx.w	r12,	&0xfa7dc;
    6448:	dc a7 
    644a:	40 18 82 dd 	bisx.w	r13,	&0xfa7de;
    644e:	de a7 

00006450 <.LBB70>:
  asm volatile("nop");
    6450:	03 43       	nop			

00006452 <.Loc.356.2>:
  _enable_interrupts();
    6452:	03 43       	nop			
    6454:	32 d2       	eint			
    6456:	03 43       	nop			
    6458:	80 00 c8 62 	mova	#25288,	r0	;0x062c8

0000645c <.L15>:
        elyUARTDLLRxStateMachine(c);
    645c:	48 13       	calla	r8		;

0000645e <.L43>:
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    645e:	3d 43       	mov	#-1,	r13	;r3 As==11
    6460:	cc 07       	mova	r7,	r12	;
    6462:	4a 13       	calla	r10		;

00006464 <.LVL40>:
    6464:	7f 40 ff 00 	mov.b	#255,	r15	;#0x00ff
    6468:	df 0c       	cmpa	r12,	r15	;
    646a:	f8 2f       	jc	$-14     	;abs 0x645c

0000646c <.Loc.111.1>:
      events &= ~CHN_INPUT_AVAILABLE;
    646c:	40 18 a2 c2 	bicx.w	#4,	&0xfa7dc;r2 As==10
    6470:	dc a7 
    6472:	40 18 82 c3 	bicx.w	#0,	&0xfa7de;r3 As==00
    6476:	de a7 
    6478:	80 00 46 63 	mova	#25414,	r0	;0x06346

0000647c <.L13>:
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    647c:	8a 00 86 4e 	mova	#20102,	r10	;0x04e86

00006480 <.Loc.109.1>:
        elyUARTDLLRxStateMachine(c);
    6480:	88 00 24 98 	mova	#38948,	r8	;0x09824
    6484:	80 00 5e 64 	mova	#25694,	r0	;0x0645e

00006488 <.L20>:
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    6488:	8a 00 66 50 	mova	#20582,	r10	;0x05066

0000648c <.Loc.129.1>:
        tx_char = elyUARTDLLTxStateMachine();
    648c:	88 00 20 97 	mova	#38688,	r8	;0x09720

00006490 <.L37>:
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    6490:	3e 43       	mov	#-1,	r14	;r3 As==11
    6492:	40 18 5d 42 	movx.b	&0x0a7d0,r13	;
    6496:	d0 a7 
    6498:	cc 09       	mova	r9,	r12	;
    649a:	4a 13       	calla	r10		;

0000649c <.LVL42>:
    649c:	9c 00 00 00 	cmpa	#0,	r12	;
    64a0:	10 20       	jnz	$+34     	;abs 0x64c2

000064a2 <.Loc.129.1>:
        tx_char = elyUARTDLLTxStateMachine();
    64a2:	48 13       	calla	r8		;

000064a4 <.LVL43>:
    64a4:	60 0c d0 a7 	mova	r12,	&42960	; 0x0a7d0

000064a8 <.Loc.130.1>:
        if (!(is_byte(tx_char))) {
    64a8:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    64ac:	de 0c       	cmpa	r12,	r14	;
    64ae:	f0 2f       	jc	$-30     	;abs 0x6490

000064b0 <.Loc.131.1>:
          UARTEvtMask &= ~CHN_OUTPUT_EMPTY;
    64b0:	c0 18 1c 42 	movx.w	&0x106f8,r12	;
    64b4:	f8 06 
    64b6:	3c c2       	bic	#8,	r12	;r2 As==11

000064b8 <.Loc.132.1>:
          UARTEvtMask |= CHN_TRANSMISSION_END;
    64b8:	3c d0 10 00 	bis	#16,	r12	;#0x0010
    64bc:	41 18 82 4c 	movx.w	r12,	&0x106f8;
    64c0:	f8 06 

000064c2 <.L22>:
      events &= ~CHN_OUTPUT_EMPTY;
    64c2:	40 18 b2 c2 	bicx.w	#8,	&0xfa7dc;r2 As==11
    64c6:	dc a7 
    64c8:	40 18 82 c3 	bicx.w	#0,	&0xfa7de;r3 As==00
    64cc:	de a7 
    64ce:	80 00 c0 63 	mova	#25536,	r0	;0x063c0

000064d2 <fw_allocator>:

#include "main.h"

static uint8_t fw_storage[elyFWTotalBuffer];

void * fw_allocator(size_t size, unsigned align) {
    64d2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000064d4 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t curr_index = 0;
  
  if (curr_index + size > elyFWTotalBuffer) {
    64d4:	2e 00 00 a8 	mova	&43008,	r14	;0x0a800
    64d8:	ca 0e       	mova	r14,	r10	;
    64da:	ea 0c       	adda	r12,	r10	;
    64dc:	3c 40 24 04 	mov	#1060,	r12	;#0x0424

000064e0 <.LVL1>:
    64e0:	dc 0a       	cmpa	r10,	r12	;
    64e2:	07 28       	jnc	$+16     	;abs 0x64f2

000064e4 <.Loc.15.1>:
    return NULL;
  }

  void * result = fw_storage + curr_index;
    64e4:	cc 0e       	mova	r14,	r12	;
    64e6:	ac 00 04 a8 	adda	#43012,	r12	;0x0a804

000064ea <.LVL2>:
  
  curr_index += size;
    64ea:	60 0a 00 a8 	mova	r10,	&43008	; 0x0a800

000064ee <.L1>:
  return result;
}
    64ee:	0a 16       	popm.a	#1,	r10	;20-bit words
    64f0:	10 01       	reta			;

000064f2 <.L3>:
    return NULL;
    64f2:	4c 43       	clr.b	r12		;
    64f4:	80 00 ee 64 	mova	#25838,	r0	;0x064ee

000064f8 <elyFWGetBufferI>:

static MEMORYPOOL_DECL(fw_mpool, elyFWBufferMaxSize, fw_allocator);
static SEMAPHORE_DECL(fw_sem, (cnt_t)(elyFWMaxSlots));

uint8_t * elyFWGetBufferI() {
  uint8_t * result =  chPoolAllocI(&fw_mpool);
    64f8:	8c 01 10 07 	mova	#67344,	r12	;0x10710
    64fc:	b0 13 8a 4c 	calla	#19594		;0x04c8a

00006500 <.LVL4>:
    6500:	ce 0c       	mova	r12,	r14	;

00006502 <.LVL5>:
  
  if (result == NULL) {
    6502:	9c 00 00 00 	cmpa	#0,	r12	;
    6506:	06 24       	jz	$+14     	;abs 0x6514

00006508 <.Loc.32.1>:
    return NULL;
  }
  
  /* semaphore must be >0 if we got a non-null result */
  chSemFastWaitI(&fw_sem);
    6508:	41 18 b2 53 	addx.w	#-1,	&0x1070e;r3 As==11
    650c:	0e 07 

0000650e <.Loc.33.1>:
  return elyNLToFW(result);
    650e:	b0 13 ea a1 	calla	#41450		;0x0a1ea

00006512 <.LVL6>:
    6512:	ce 0c       	mova	r12,	r14	;

00006514 <.L4>:
}
    6514:	cc 0e       	mova	r14,	r12	;
    6516:	10 01       	reta			;

00006518 <elyFWGetBuffer>:
  _disable_interrupts();
    6518:	32 c2       	dint			
    651a:	03 43       	nop			

0000651c <.Loc.348.2>:
  asm volatile("nop");
    651c:	03 43       	nop			

0000651e <.LBE6>:

uint8_t * elyFWGetBuffer() {
  chSysLock();
  uint8_t * result = elyFWGetBufferI();
    651e:	b0 13 f8 64 	calla	#25848		;0x064f8

00006522 <.LBB8>:
  asm volatile("nop");
    6522:	03 43       	nop			

00006524 <.Loc.356.2>:
  _enable_interrupts();
    6524:	03 43       	nop			
    6526:	32 d2       	eint			
    6528:	03 43       	nop			

0000652a <.LBE8>:
  chSysUnlock();
  
  return result;
}
    652a:	10 01       	reta			;

0000652c <elyFWGetBufferTimeoutS>:

uint8_t * elyFWGetBufferTimeoutS(systime_t timeout) {
    652c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000652e <.LCFI1>:
  msg_t msg;
  
  msg = chSemWaitTimeoutS(&fw_sem, timeout);
    652e:	0d 4c       	mov	r12,	r13	;
    6530:	8c 01 0e 07 	mova	#67342,	r12	;0x1070e

00006534 <.LVL9>:
    6534:	b0 13 ae 48 	calla	#18606		;0x048ae

00006538 <.LVL10>:
  if (MSG_OK != msg) {
    6538:	9c 00 00 00 	cmpa	#0,	r12	;
    653c:	11 20       	jnz	$+36     	;abs 0x6560

0000653e <.Loc.52.1>:
    return NULL;
  }
  
  uint8_t * result = chPoolAllocI(&fw_mpool);
    653e:	8c 01 10 07 	mova	#67344,	r12	;0x10710

00006542 <.LVL11>:
    6542:	b0 13 8a 4c 	calla	#19594		;0x04c8a

00006546 <.LVL12>:
    6546:	ca 0c       	mova	r12,	r10	;

00006548 <.LVL13>:
  chDbgAssert(NULL != result, "Guarded pool failure");
    6548:	9c 00 00 00 	cmpa	#0,	r12	;
    654c:	04 20       	jnz	$+10     	;abs 0x6556

0000654e <.Loc.53.1>:
    654e:	8c 01 ac 04 	mova	#66732,	r12	;0x104ac
    6552:	b0 13 58 46 	calla	#18008		;0x04658

00006556 <.L12>:
  return elyNLToFW(result);
    6556:	cc 0a       	mova	r10,	r12	;
    6558:	b0 13 ea a1 	calla	#41450		;0x0a1ea

0000655c <.L10>:
}
    655c:	0a 16       	popm.a	#1,	r10	;20-bit words
    655e:	10 01       	reta			;

00006560 <.L13>:
    return NULL;
    6560:	4c 43       	clr.b	r12		;

00006562 <.LVL17>:
    6562:	80 00 5c 65 	mova	#25948,	r0	;0x0655c

00006566 <elyFWFreeBufferI>:

void elyFWFreeBufferI(uint8_t * buffer) {
  chPoolFreeI(&fw_mpool, buffer);
    6566:	cd 0c       	mova	r12,	r13	;
    6568:	8c 01 10 07 	mova	#67344,	r12	;0x10710

0000656c <.LVL19>:
    656c:	b0 13 d8 4c 	calla	#19672		;0x04cd8

00006570 <.LVL20>:
  chSemSignalI(&fw_sem);
    6570:	8c 01 0e 07 	mova	#67342,	r12	;0x1070e
    6574:	b0 13 00 49 	calla	#18688		;0x04900

00006578 <.LVL21>:
}
    6578:	10 01       	reta			;

0000657a <elyFWFreeBuffer>:
  _disable_interrupts();
    657a:	32 c2       	dint			
    657c:	03 43       	nop			

0000657e <.Loc.348.2>:
  asm volatile("nop");
    657e:	03 43       	nop			

00006580 <.LBE14>:

void elyFWFreeBuffer(uint8_t * buffer) {
  chSysLock();
  elyFWFreeBufferI(buffer);
    6580:	b0 13 66 65 	calla	#25958		;0x06566

00006584 <.LVL23>:
  chSchRescheduleS();
    6584:	b0 13 de 47 	calla	#18398		;0x047de

00006588 <.LBB16>:
  asm volatile("nop");
    6588:	03 43       	nop			

0000658a <.Loc.356.2>:
  _enable_interrupts();
    658a:	03 43       	nop			
    658c:	32 d2       	eint			
    658e:	03 43       	nop			

00006590 <.LBE16>:
  chSysUnlock();
}
    6590:	10 01       	reta			;

00006592 <chEvtWaitAnyTimeoutS>:
#include "mych.h"

#if CH_CFG_USE_EVENTS == TRUE
eventmask_t chEvtWaitAnyTimeoutS(eventmask_t mask, systime_t timeout) {
    6592:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006594 <.LCFI0>:
    6594:	06 4c       	mov	r12,	r6	;
    6596:	07 4d       	mov	r13,	r7	;
    6598:	0d 4e       	mov	r14,	r13	;

0000659a <.Loc.6.1>:
  chDbgCheckClassS();
  thread_t *ctp = nil.current;
    659a:	2a 01 7c 07 	mova	&67452,	r10	;0x1077c

0000659e <.Loc.9.1>:
  eventmask_t m;

  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    659e:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    65a2:	08 fc       	and	r12,	r8	;
    65a4:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    65a8:	09 f7       	and	r7,	r9	;

000065aa <.LVL2>:
    65aa:	0c 48       	mov	r8,	r12	;

000065ac <.LVL3>:
    65ac:	0c d9       	bis	r9,	r12	;
    65ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    65b0:	12 20       	jnz	$+38     	;abs 0x65d6

000065b2 <.Loc.10.1>:
    if (TIME_IMMEDIATE == timeout) {
    65b2:	3e 93       	cmp	#-1,	r14	;r3 As==11
    65b4:	14 24       	jz	$+42     	;abs 0x65de

000065b6 <.Loc.14.1>:

      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    65b6:	8a 46 06 00 	mov	r6,	6(r10)	;
    65ba:	8a 47 08 00 	mov	r7,	8(r10)	;

000065be <.Loc.15.1>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    65be:	6c 42       	mov.b	#4,	r12	;r2 As==10
    65c0:	b0 13 ee 47 	calla	#18414		;0x047ee

000065c4 <.LVL4>:
    65c4:	9c 00 00 00 	cmpa	#0,	r12	;
    65c8:	0a 38       	jl	$+22     	;abs 0x65de

000065ca <.Loc.19.1>:

      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    65ca:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

000065ce <.LVL5>:
    65ce:	08 f6       	and	r6,	r8	;
    65d0:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    65d4:	09 f7       	and	r7,	r9	;

000065d6 <.L2>:
  }
  ctp->epmask &= ~m;
    65d6:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    65da:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e

000065de <.L1>:

  return m;
}
    65de:	0c 48       	mov	r8,	r12	;
    65e0:	0d 49       	mov	r9,	r13	;
    65e2:	46 16       	popm.a	#5,	r10	;20-bit words
    65e4:	10 01       	reta			;

000065e6 <port_lock>:
  _disable_interrupts();
    65e6:	32 c2       	dint			
    65e8:	03 43       	nop			

000065ea <.Loc.348.1>:
  asm volatile("nop");
    65ea:	03 43       	nop			

000065ec <.Loc.349.1>:
}
    65ec:	10 01       	reta			;

000065ee <port_unlock>:
  asm volatile("nop");
    65ee:	03 43       	nop			

000065f0 <.Loc.356.1>:
  _enable_interrupts();
    65f0:	03 43       	nop			
    65f2:	32 d2       	eint			
    65f4:	03 43       	nop			

000065f6 <.Loc.357.1>:
}
    65f6:	10 01       	reta			;

000065f8 <reset>:
  
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLFromFW(buffer));
    65f8:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000065fc <.LVL1>:
    65fc:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00006600 <.LVL2>:
  active_buffer = NULL; /* have to null before reset */
    6600:	00 18 c2 43 	movx.a	#0,	&0xfac3a;r3 As==00
    6604:	3a ac 

00006606 <.Loc.168.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6606:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    660a:	48 a5 20 01 

0000660e <.Loc.169.2>:
}
    660e:	10 01       	reta			;

00006610 <write_failure>:
static void write_failure(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    6610:	2d 4d       	mov	@r13,	r13	;

00006612 <.LVL4>:
    6612:	0e 4d       	mov	r13,	r14	;
    6614:	5e 07       	rrum	#2,	r14	;
    6616:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f

0000661a <.Loc.61.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    661a:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

0000661e <.Loc.62.2>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    661e:	5d f3       	and.b	#1,	r13	;r3 As==01
    6620:	0d 93       	cmp	#0,	r13	;r3 As==00
    6622:	12 20       	jnz	$+38     	;abs 0x6648
    6624:	0e 4d       	mov	r13,	r14	;

00006626 <.L5>:
    6626:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000662a <.Loc.63.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    662a:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    662e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    6632:	02 00 

00006634 <.Loc.64.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    6634:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    6638:	03 00 

0000663a <.Loc.65.2>:
  if (hdr.crc) {
    663a:	0d 93       	cmp	#0,	r13	;r3 As==00
    663c:	04 24       	jz	$+10     	;abs 0x6646

0000663e <.Loc.66.2>:
    crcGenX25(reply_buff, 6);
    663e:	7d 40 06 00 	mov.b	#6,	r13	;
    6642:	b0 13 ec 99 	calla	#39404		;0x099ec

00006646 <.L4>:
}
    6646:	10 01       	reta			;

00006648 <.L7>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    6648:	6e 43       	mov.b	#2,	r14	;r3 As==10
    664a:	80 00 26 66 	mova	#26150,	r0	;0x06626

0000664e <store_telem>:
  elyFWFreeBufferI(elyNLFromFW(buff));
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    664e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006650 <.LCFI0>:
    6650:	b1 00 06 00 	suba	#6,	r1	;

00006654 <.LCFI1>:
    6654:	c8 0c       	mova	r12,	r8	;
    6656:	2a 4d       	mov	@r13,	r10	;

00006658 <.LVL11>:
    6658:	91 4d 02 00 	mov	2(r13),	4(r1)	;
    665c:	04 00 
    665e:	09 4a       	mov	r10,	r9	;
    6660:	59 0f       	rrum	#4,	r9	;
    6662:	59 0f       	rrum	#4,	r9	;

00006664 <.Loc.1472.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6664:	4c 4a       	mov.b	r10,	r12	;

00006666 <.LVL13>:
    6666:	4f 4c       	mov.b	r12,	r15	;
    6668:	6f f3       	and.b	#2,	r15	;r3 As==10
    666a:	47 4f       	mov.b	r15,	r7	;
    666c:	07 93       	cmp	#0,	r7	;r3 As==00
    666e:	1f 20       	jnz	$+64     	;abs 0x66ae
    6670:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006672 <.L12>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6672:	1c b3       	bit	#1,	r12	;r3 As==01
    6674:	1f 20       	jnz	$+64     	;abs 0x66b4

00006676 <.Loc.1473.2>:
    6676:	4c 43       	clr.b	r12		;

00006678 <.L13>:
    6678:	40 18 4e 49 	movx.b	r9,	r14	;
    667c:	40 18 4e 8f 	subx.b	r15,	r14	;
    6680:	40 18 46 4e 	movx.b	r14,	r6	;
    6684:	40 18 46 8c 	subx.b	r12,	r6	;
    6688:	45 46       	mov.b	r6,	r5	;

0000668a <.LVL15>:
  
  uint8_t * reply_buff = elyFWGetBuffer();
    668a:	71 0d 00 00 	mova	r13,	0(r1)	;
    668e:	b0 13 18 65 	calla	#25880		;0x06518

00006692 <.LVL16>:
    6692:	c4 0c       	mova	r12,	r4	;

00006694 <.LVL17>:
  if (reply_buff == NULL) {
    6694:	0d 01       	mova	@r1,	r13	;
    6696:	9c 00 00 00 	cmpa	#0,	r12	;
    669a:	0f 20       	jnz	$+32     	;abs 0x66ba

0000669c <.Loc.1478.2>:
    /* TODO signal a buffer overflow here */
    elyNLFreeBuffer(elyNLFromFW(buffer));
    669c:	cc 08       	mova	r8,	r12	;
    669e:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000066a2 <.LVL18>:
    66a2:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000066a6 <.L11>:
  elyTelemPostBufferS(reply_buff, 
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
  
  /* Reply is posted from callback if needed */
}
    66a6:	a1 00 06 00 	adda	#6,	r1	;
    66aa:	64 16       	popm.a	#7,	r10	;20-bit words
    66ac:	10 01       	reta			;

000066ae <.L17>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    66ae:	6d 42       	mov.b	#4,	r13	;r2 As==10
    66b0:	80 00 72 66 	mova	#26226,	r0	;0x06672

000066b4 <.L18>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    66b4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    66b6:	80 00 78 66 	mova	#26232,	r0	;0x06678

000066ba <.L14>:
  memcpy(reply_buff + 5, buffer + hdr_ext, payload_len);
    66ba:	40 18 06 46 	movx.w	r6,	r6	;

000066be <.LVL23>:
    66be:	40 18 0d 4d 	movx.w	r13,	r13	;
    66c2:	ce 06       	mova	r6,	r14	;
    66c4:	ed 08       	adda	r8,	r13	;
    66c6:	ac 00 05 00 	adda	#5,	r12	;
    66ca:	b0 13 06 a4 	calla	#41990		;0x0a406

000066ce <.LVL24>:
  memset(reply_buff + 5 + payload_len, 0, 251 - payload_len);
    66ce:	40 18 3e 40 	movx.w	#251,	r14	;0x000fb
    66d2:	fb 00 
    66d4:	40 18 0e 85 	subx.w	r5,	r14	;
    66d8:	4e 0e       	rlam.a	#4,	r14	;
    66da:	4e 0d       	rram.a	#4,	r14	;
    66dc:	cc 06       	mova	r6,	r12	;
    66de:	ac 00 05 00 	adda	#5,	r12	;
    66e2:	4d 43       	clr.b	r13		;
    66e4:	ec 04       	adda	r4,	r12	;
    66e6:	b0 13 24 a4 	calla	#42020		;0x0a424

000066ea <.LVL25>:
  telem_stored_hdr = hdr;
    66ea:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    66ee:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000066f2 <.LVL27>:
    66f2:	0a d9       	bis	r9,	r10	;
    66f4:	40 18 82 4a 	movx.w	r10,	&0xfac2e;
    66f8:	2e ac 
    66fa:	40 18 92 41 	movx.w	4(r1),	&0xfac30;
    66fe:	04 00 30 ac 

00006702 <.Loc.1486.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6702:	cc 08       	mova	r8,	r12	;
    6704:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006708 <.LVL28>:
    6708:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000670c <.LVL29>:
  chSysLock();
    670c:	b0 13 e6 65 	calla	#26086		;0x065e6

00006710 <.LVL30>:
  elyTelemPostBufferS(reply_buff, 
    6710:	07 93       	cmp	#0,	r7	;r3 As==00
    6712:	09 20       	jnz	$+20     	;abs 0x6726
    6714:	8d 00 2e 67 	mova	#26414,	r13	;0x0672e

00006718 <.L16>:
    6718:	cc 04       	mova	r4,	r12	;
    671a:	b0 13 d2 95 	calla	#38354		;0x095d2

0000671e <.LVL31>:
  chSysUnlock();
    671e:	b0 13 ee 65 	calla	#26094		;0x065ee

00006722 <.LVL32>:
    6722:	80 00 a6 66 	mova	#26278,	r0	;0x066a6

00006726 <.L19>:
  elyTelemPostBufferS(reply_buff, 
    6726:	8d 00 d4 6b 	mova	#27604,	r13	;0x06bd4
    672a:	80 00 18 67 	mova	#26392,	r0	;0x06718

0000672e <store_telem_noreply_cb>:
  elyFWFreeBufferI(elyNLFromFW(buff));
    672e:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006732 <.LVL34>:
    6732:	b0 13 66 65 	calla	#25958		;0x06566

00006736 <.LVL35>:
}
    6736:	10 01       	reta			;

00006738 <upload_fw_noreply_cb>:
    6738:	b0 13 2e 67 	calla	#26414		;0x0672e
    673c:	10 01       	reta			;

0000673e <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    673e:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006740 <.LCFI2>:
    6740:	06 14       	pushm.a	#1,	r6	;20-bit words

00006742 <.LCFI3>:
    6742:	b1 00 04 00 	suba	#4,	r1	;

00006746 <.LCFI4>:
    6746:	c6 0c       	mova	r12,	r6	;
    6748:	29 4d       	mov	@r13,	r9	;

0000674a <.LVL37>:
    674a:	1a 4d 02 00 	mov	2(r13),	r10	;

0000674e <.LVL38>:
    674e:	8e 00 f6 a1 	mova	#41462,	r14	;0x0a1f6
    6752:	88 00 4a 9f 	mova	#40778,	r8	;0x09f4a

00006756 <.Loc.1307.2>:
  if (hdr.reply) {
    6756:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    675a:	47 24       	jz	$+144    	;abs 0x67ea

0000675c <.LBB26>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    675c:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    6760:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6764:	56 4c 05 00 	mov.b	5(r12),	r6	;
    6768:	06 dd       	bis	r13,	r6	;
    676a:	40 18 82 46 	movx.w	r6,	&0xfac2c;
    676e:	2c ac 

00006770 <.Loc.1311.2>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6770:	4e 13       	calla	r14		;

00006772 <.LVL40>:
    6772:	48 13       	calla	r8		;

00006774 <.LVL41>:
    volatile uint8_t * crc_addr = crcStart();
    6774:	b0 13 ca 9a 	calla	#39626		;0x09aca

00006778 <.LVL42>:
    6778:	c8 0c       	mova	r12,	r8	;

0000677a <.LVL43>:
    verify_stored_hdr = hdr;
    677a:	40 18 82 49 	movx.w	r9,	&0xfac32;
    677e:	32 ac 
    6780:	40 18 82 4a 	movx.w	r10,	&0xfac34;
    6784:	34 ac 

00006786 <.Loc.1321.2>:
    chSysLock();
    6786:	8a 00 e6 65 	mova	#26086,	r10	;0x065e6

0000678a <.LVL45>:
    678a:	4a 13       	calla	r10		;

0000678c <.LVL46>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    678c:	4d 43       	clr.b	r13		;
    678e:	cc 01       	mova	r1,	r12	;
    6790:	b0 13 78 9d 	calla	#40312		;0x09d78

00006794 <.LVL47>:
    chSysUnlock();
    6794:	86 00 ee 65 	mova	#26094,	r6	;0x065ee
    6798:	46 13       	calla	r6		;

0000679a <.LVL48>:
    req->address = FRAM_FW_BASE; 
    679a:	0c 01       	mova	@r1,	r12	;
    679c:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    67a0:	00 00 
    67a2:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

000067a6 <.Loc.1328.2>:
    req->special = 1; /* read to a constant register address */
    67a6:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    67aa:	04 00 

000067ac <.Loc.1329.2>:
    req->size = FRAM_FW_SIZE;
    67ac:	1d 4c 04 00 	mov	4(r12),	r13	;
    67b0:	7d f0 03 00 	and.b	#3,	r13	;
    67b4:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    67b8:	8c 4d 04 00 	mov	r13,	4(r12)	;
    67bc:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    67c0:	7d d0 03 00 	bis.b	#3,	r13	;
    67c4:	6d c2       	bic.b	#4,	r13	;r2 As==10
    67c6:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

000067ca <.Loc.1330.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    67ca:	7c 08 08 00 	mova	r8,	8(r12)	;

000067ce <.Loc.1331.2>:
    req->callback = verify_fw_cb;
    67ce:	00 18 fc 40 	movx.a	#27636,	12(r12)	;0x06bf4, 0x0000c
    67d2:	f4 6b 0c 00 

000067d6 <.Loc.1334.2>:
    chSysLock();
    67d6:	4a 13       	calla	r10		;

000067d8 <.LVL49>:
    elyFramPostRequestS(req);
    67d8:	0c 01       	mova	@r1,	r12	;
    67da:	b0 13 54 9d 	calla	#40276		;0x09d54

000067de <.LVL50>:
    chSysUnlock();
    67de:	46 13       	calla	r6		;

000067e0 <.L22>:
}
    67e0:	a1 00 04 00 	adda	#4,	r1	;
    67e4:	06 16       	popm.a	#1,	r6	;20-bit words
    67e6:	28 16       	popm.a	#3,	r10	;20-bit words
    67e8:	10 01       	reta			;

000067ea <.L23>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    67ea:	4e 13       	calla	r14		;

000067ec <.LVL53>:
    67ec:	48 13       	calla	r8		;

000067ee <.LVL54>:
}
    67ee:	80 00 e0 67 	mova	#26592,	r0	;0x067e0

000067f2 <write_success>:
static void write_success(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    67f2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000067f4 <.LCFI5>:
    67f4:	2f 4d       	mov	@r13,	r15	;

000067f6 <.LVL56>:
    67f6:	0d 4f       	mov	r15,	r13	;
    67f8:	5d 07       	rrum	#2,	r13	;
    67fa:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

000067fe <.Loc.35.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    67fe:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006802 <.Loc.36.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    6802:	2a 01 b0 05 	mova	&66992,	r10	;0x105b0
    6806:	dc 4a 51 00 	mov.b	81(r10),2(r12)	;0x00051
    680a:	02 00 

0000680c <.Loc.37.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    680c:	dc 4a 50 00 	mov.b	80(r10),3(r12)	;0x00050
    6810:	03 00 

00006812 <.Loc.38.2>:
  reply_buff[4] = 1;
    6812:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00006816 <.Loc.39.2>:
  if (hdr.crc) {
    6816:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    681a:	09 24       	jz	$+20     	;abs 0x682e

0000681c <.LBB29>:
    reply_buff[1] = 3;
    681c:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    6820:	01 00 

00006822 <.Loc.41.2>:
    crcGenX25(reply_buff, 7);
    6822:	7d 40 07 00 	mov.b	#7,	r13	;
    6826:	b0 13 ec 99 	calla	#39404		;0x099ec

0000682a <.L25>:
}
    682a:	0a 16       	popm.a	#1,	r10	;20-bit words
    682c:	10 01       	reta			;

0000682e <.L26>:
    reply_buff[1] = 1;
    682e:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01

00006832 <.Loc.46.2>:
}
    6832:	80 00 2a 68 	mova	#26666,	r0	;0x0682a

00006836 <cancel_fw_eeprom_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    6836:	40 18 1c 42 	movx.w	&0x0ac2a,r12	;
    683a:	2a ac 

0000683c <.LVL64>:
    683c:	4d 43       	clr.b	r13		;
    683e:	0d 9c       	cmp	r12,	r13	;
    6840:	04 38       	jl	$+10     	;abs 0x684a

00006842 <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    6842:	8c 00 2a ac 	mova	#44074,	r12	;0x0ac2a
    6846:	b0 13 00 49 	calla	#18688		;0x04900

0000684a <.L28>:
}
    684a:	10 01       	reta			;

0000684c <elyMainMBPost>:
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    684c:	0e 4d       	mov	r13,	r14	;
    684e:	cd 0c       	mova	r12,	r13	;

00006850 <.LVL67>:
    6850:	8c 01 1c 07 	mova	#67356,	r12	;0x1071c

00006854 <.LVL68>:
    6854:	b0 13 aa 4a 	calla	#19114		;0x04aaa

00006858 <.LVL69>:
}
    6858:	10 01       	reta			;

0000685a <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * fw_buffer) {
    685a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000685c <.LCFI6>:
    685c:	ca 0d       	mova	r13,	r10	;

0000685e <.Loc.1594.2>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (fw_buffer[0] >> 7);
    685e:	6d 4d       	mov.b	@r13,	r13	;

00006860 <.LVL78>:
    6860:	09 4d       	mov	r13,	r9	;
    6862:	59 0f       	rrum	#4,	r9	;
    6864:	59 0b       	rrum	#3,	r9	;

00006866 <.LVL79>:
  hdr.reply = ((fw_buffer[0] >> 6) & 0x01);
    6866:	0e 4d       	mov	r13,	r14	;
    6868:	5e 0f       	rrum	#4,	r14	;
    686a:	5e 07       	rrum	#2,	r14	;
    686c:	5e f3       	and.b	#1,	r14	;r3 As==01

0000686e <.LVL80>:
  hdr.opcode = (fw_buffer[0] & 0x3F);
    686e:	08 4d       	mov	r13,	r8	;
    6870:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f

00006874 <.LVL81>:
  hdr.length = fw_buffer[1];
    6874:	5b 4a 01 00 	mov.b	1(r10),	r11	;

00006878 <.LVL82>:
  if (hdr.reply) {
    6878:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    687a:	07 24       	jz	$+16     	;abs 0x688a

0000687c <.Loc.1599.2>:
    hdr.reply_addr = (((uint16_t)(fw_buffer[2]) << 8) | (fw_buffer[3]));
    687c:	5f 4a 02 00 	mov.b	2(r10),	r15	;
    6880:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    6884:	5a 4a 03 00 	mov.b	3(r10),	r10	;

00006888 <.LVL83>:
    6888:	0f da       	bis	r10,	r15	;

0000688a <.L34>:
  }
  return hdr;
    688a:	4d 4e       	mov.b	r14,	r13	;

0000688c <.LVL85>:
    688c:	5d f3       	and.b	#1,	r13	;r3 As==01
    688e:	4d 5d       	rla.b	r13		;
    6890:	7d f0 03 00 	and.b	#3,	r13	;
    6894:	0e 48       	mov	r8,	r14	;

00006896 <.LVL86>:
    6896:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    689a:	4d d9       	bis.b	r9,	r13	;
    689c:	4d de       	bis.b	r14,	r13	;
    689e:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    68a2:	cc 4b 01 00 	mov.b	r11,	1(r12)	;
    68a6:	8c 4f 02 00 	mov	r15,	2(r12)	;

000068aa <.LVL87>:
}
    68aa:	28 16       	popm.a	#3,	r10	;20-bit words
    68ac:	10 01       	reta			;

000068ae <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    68ae:	2a 14       	pushm.a	#3,	r10	;20-bit words

000068b0 <.LCFI7>:
    68b0:	2e 4c       	mov	@r12,	r14	;

000068b2 <.LVL89>:
    68b2:	ca 0d       	mova	r13,	r10	;
    68b4:	0c 4e       	mov	r14,	r12	;
    68b6:	5c 07       	rrum	#2,	r12	;
    68b8:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    68bc:	49 4c       	mov.b	r12,	r9	;
    68be:	08 4e       	mov	r14,	r8	;
    68c0:	58 0f       	rrum	#4,	r8	;
    68c2:	58 0f       	rrum	#4,	r8	;

000068c4 <.Loc.1607.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    68c4:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f

000068c8 <.LVL91>:
    68c8:	0d 99       	cmp	r9,	r13	;
    68ca:	07 34       	jge	$+16     	;abs 0x68da

000068cc <.Loc.1608.2>:
    elyErrorSignal(ErrInvalidOpcode);
    68cc:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

000068d0 <.L182>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    68d0:	b0 13 ca 94 	calla	#38090		;0x094ca

000068d4 <.L70>:
      return false;
    68d4:	4a 43       	clr.b	r10		;

000068d6 <.LVL94>:
    68d6:	80 00 4c 69 	mova	#26956,	r0	;0x0694c

000068da <.L39>:
  if (hdr.reply) {
    68da:	0d 49       	mov	r9,	r13	;
    68dc:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    68e0:	09 4e       	mov	r14,	r9	;
    68e2:	79 f0 03 00 	and.b	#3,	r9	;
    68e6:	09 dd       	bis	r13,	r9	;
    68e8:	4f 49       	mov.b	r9,	r15	;
    68ea:	6f f3       	and.b	#2,	r15	;r3 As==10
    68ec:	4f 93       	cmp.b	#0,	r15	;r3 As==00
    68ee:	0a 24       	jz	$+22     	;abs 0x6904

000068f0 <.Loc.1614.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    68f0:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    68f4:	da 9e 51 00 	cmp.b	81(r14),2(r10)	;0x00051
    68f8:	02 00 
    68fa:	04 20       	jnz	$+10     	;abs 0x6904

000068fc <.Loc.1614.2>:
    68fc:	da 9e 50 00 	cmp.b	80(r14),3(r10)	;0x00050
    6900:	03 00 
    6902:	e8 27       	jz	$-46     	;abs 0x68d4

00006904 <.L41>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6904:	59 f3       	and.b	#1,	r9	;r3 As==01
    6906:	09 93       	cmp	#0,	r9	;r3 As==00
    6908:	24 24       	jz	$+74     	;abs 0x6952
    690a:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000690c <.L42>:
    690c:	40 18 4e 48 	movx.b	r8,	r14	;
    6910:	40 18 4e 8f 	subx.b	r15,	r14	;
    6914:	4e 8d       	sub.b	r13,	r14	;
    6916:	4d 4e       	mov.b	r14,	r13	;

00006918 <.LVL96>:
  switch(hdr.opcode) {
    6918:	7c 90 16 00 	cmp.b	#22,	r12	;#0x0016
    691c:	4d 24       	jz	$+156    	;abs 0x69b8
    691e:	7f 40 16 00 	mov.b	#22,	r15	;#0x0016
    6922:	4f 9c       	cmp.b	r12,	r15	;
    6924:	6e 28       	jnc	$+222    	;abs 0x6a02
    6926:	7c 90 0a 00 	cmp.b	#10,	r12	;#0x000a
    692a:	46 24       	jz	$+142    	;abs 0x69b8
    692c:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    6930:	4f 9c       	cmp.b	r12,	r15	;
    6932:	2e 28       	jnc	$+94     	;abs 0x6990
    6934:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    6936:	cd 24       	jz	$+412    	;abs 0x6ad2
    6938:	6f 42       	mov.b	#4,	r15	;r2 As==10
    693a:	4f 9c       	cmp.b	r12,	r15	;
    693c:	0d 28       	jnc	$+28     	;abs 0x6958
    693e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    6940:	3b 20       	jnz	$+120    	;abs 0x69b8

00006942 <.L49>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    6942:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    6944:	3b 20       	jnz	$+120    	;abs 0x69bc

00006946 <.L66>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    6946:	09 93       	cmp	#0,	r9	;r3 As==00
    6948:	dc 20       	jnz	$+442    	;abs 0x6b02

0000694a <.L69>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    694a:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000694c <.L40>:
  
}
    694c:	4c 4a       	mov.b	r10,	r12	;
    694e:	28 16       	popm.a	#3,	r10	;20-bit words
    6950:	10 01       	reta			;

00006952 <.L71>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6952:	0d 49       	mov	r9,	r13	;
    6954:	80 00 0c 69 	mova	#26892,	r0	;0x0690c

00006958 <.L48>:
  switch(hdr.opcode) {
    6958:	7c 90 07 00 	cmp.b	#7,	r12	;
    695c:	ca 24       	jz	$+406    	;abs 0x6af2
    695e:	7f 40 07 00 	mov.b	#7,	r15	;
    6962:	4f 9c       	cmp.b	r12,	r15	;
    6964:	0c 28       	jnc	$+26     	;abs 0x697e
    6966:	7c 90 05 00 	cmp.b	#5,	r12	;
    696a:	b9 24       	jz	$+372    	;abs 0x6ade
    696c:	7c 90 06 00 	cmp.b	#6,	r12	;
    6970:	ab 24       	jz	$+344    	;abs 0x6ac8

00006972 <.L43>:
      chDbgAssert(false, "invalid opcode in length check");
    6972:	8c 01 d5 04 	mova	#66773,	r12	;0x104d5
    6976:	b0 13 58 46 	calla	#18008		;0x04658

0000697a <.LVL102>:
    697a:	80 00 46 69 	mova	#26950,	r0	;0x06946

0000697e <.L51>:
  switch(hdr.opcode) {
    697e:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    6980:	1b 24       	jz	$+56     	;abs 0x69b8
    6982:	7c 90 09 00 	cmp.b	#9,	r12	;
    6986:	f5 23       	jnz	$-20     	;abs 0x6972

00006988 <.L179>:
      if (payload_len != 2 && payload_len != 4 && 
    6988:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    698a:	18 20       	jnz	$+50     	;abs 0x69bc
    698c:	80 00 46 69 	mova	#26950,	r0	;0x06946

00006990 <.L46>:
  switch(hdr.opcode) {
    6990:	7c 90 10 00 	cmp.b	#16,	r12	;#0x0010
    6994:	11 24       	jz	$+36     	;abs 0x69b8
    6996:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    699a:	4f 9c       	cmp.b	r12,	r15	;
    699c:	1b 28       	jnc	$+56     	;abs 0x69d4
    699e:	7c 90 0d 00 	cmp.b	#13,	r12	;#0x000d
    69a2:	f2 27       	jz	$-26     	;abs 0x6988
    69a4:	7f 40 0d 00 	mov.b	#13,	r15	;#0x000d
    69a8:	4f 9c       	cmp.b	r12,	r15	;
    69aa:	0c 28       	jnc	$+26     	;abs 0x69c4
    69ac:	7c 90 0b 00 	cmp.b	#11,	r12	;#0x000b
    69b0:	eb 27       	jz	$-40     	;abs 0x6988
    69b2:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    69b6:	dd 23       	jnz	$-68     	;abs 0x6972

000069b8 <.L44>:
      if (payload_len != 0) {
    69b8:	0d 93       	cmp	#0,	r13	;r3 As==00
    69ba:	c5 27       	jz	$-116    	;abs 0x6946

000069bc <.L67>:
        elyErrorSignal(ErrInvalidLength);
    69bc:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    69c0:	80 00 d0 68 	mova	#26832,	r0	;0x068d0

000069c4 <.L56>:
  switch(hdr.opcode) {
    69c4:	7c 90 0e 00 	cmp.b	#14,	r12	;#0x000e
    69c8:	f7 27       	jz	$-16     	;abs 0x69b8
    69ca:	7c 90 0f 00 	cmp.b	#15,	r12	;#0x000f
    69ce:	dc 27       	jz	$-70     	;abs 0x6988
    69d0:	80 00 72 69 	mova	#26994,	r0	;0x06972

000069d4 <.L55>:
    69d4:	7c 90 13 00 	cmp.b	#19,	r12	;#0x0013
    69d8:	d7 27       	jz	$-80     	;abs 0x6988
    69da:	7f 40 13 00 	mov.b	#19,	r15	;#0x0013
    69de:	4f 9c       	cmp.b	r12,	r15	;
    69e0:	08 28       	jnc	$+18     	;abs 0x69f2
    69e2:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    69e6:	d0 27       	jz	$-94     	;abs 0x6988
    69e8:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    69ec:	e5 27       	jz	$-52     	;abs 0x69b8
    69ee:	80 00 72 69 	mova	#26994,	r0	;0x06972

000069f2 <.L57>:
    69f2:	7c 90 14 00 	cmp.b	#20,	r12	;#0x0014
    69f6:	e0 27       	jz	$-62     	;abs 0x69b8
    69f8:	7c 90 15 00 	cmp.b	#21,	r12	;#0x0015
    69fc:	a2 27       	jz	$-186    	;abs 0x6942
    69fe:	80 00 72 69 	mova	#26994,	r0	;0x06972

00006a02 <.L45>:
    6a02:	7c 90 24 00 	cmp.b	#36,	r12	;#0x0024
    6a06:	c0 27       	jz	$-126    	;abs 0x6988
    6a08:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    6a0c:	4f 9c       	cmp.b	r12,	r15	;
    6a0e:	31 28       	jnc	$+100    	;abs 0x6a72
    6a10:	7c 90 1c 00 	cmp.b	#28,	r12	;#0x001c
    6a14:	5e 24       	jz	$+190    	;abs 0x6ad2
    6a16:	7f 40 1c 00 	mov.b	#28,	r15	;#0x001c
    6a1a:	4f 9c       	cmp.b	r12,	r15	;
    6a1c:	1b 28       	jnc	$+56     	;abs 0x6a54
    6a1e:	7c 90 19 00 	cmp.b	#25,	r12	;#0x0019
    6a22:	12 24       	jz	$+38     	;abs 0x6a48
    6a24:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019
    6a28:	4d 9c       	cmp.b	r12,	r13	;
    6a2a:	08 28       	jnc	$+18     	;abs 0x6a3c
    6a2c:	7c 90 17 00 	cmp.b	#23,	r12	;#0x0017
    6a30:	ab 27       	jz	$-168    	;abs 0x6988
    6a32:	7c 90 18 00 	cmp.b	#24,	r12	;#0x0018
    6a36:	85 27       	jz	$-244    	;abs 0x6942
    6a38:	80 00 72 69 	mova	#26994,	r0	;0x06972

00006a3c <.L61>:
    6a3c:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    6a40:	48 24       	jz	$+146    	;abs 0x6ad2
    6a42:	7c 90 1b 00 	cmp.b	#27,	r12	;#0x001b
    6a46:	95 23       	jnz	$-212    	;abs 0x6972

00006a48 <.L60>:
      if (payload_len < 4 || payload_len > 251) {
    6a48:	7e 50 fc ff 	add.b	#-4,	r14	;#0xfffc

00006a4c <.LVL108>:
    6a4c:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    6a50:	80 00 d6 6a 	mova	#27350,	r0	;0x06ad6

00006a54 <.L59>:
  switch(hdr.opcode) {
    6a54:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    6a58:	4f 9c       	cmp.b	r12,	r15	;
    6a5a:	ae 2b       	jnc	$-162    	;abs 0x69b8
    6a5c:	7c 90 1f 00 	cmp.b	#31,	r12	;#0x001f
    6a60:	38 2c       	jc	$+114    	;abs 0x6ad2
    6a62:	7c 90 1d 00 	cmp.b	#29,	r12	;#0x001d
    6a66:	6d 27       	jz	$-292    	;abs 0x6942
    6a68:	7c 90 1e 00 	cmp.b	#30,	r12	;#0x001e
    6a6c:	82 23       	jnz	$-250    	;abs 0x6972
    6a6e:	80 00 b8 69 	mova	#27064,	r0	;0x069b8

00006a72 <.L58>:
    6a72:	7c 90 2a 00 	cmp.b	#42,	r12	;#0x002a
    6a76:	e8 27       	jz	$-46     	;abs 0x6a48
    6a78:	7f 40 2a 00 	mov.b	#42,	r15	;#0x002a
    6a7c:	4f 9c       	cmp.b	r12,	r15	;
    6a7e:	0e 28       	jnc	$+30     	;abs 0x6a9c
    6a80:	7c 90 27 00 	cmp.b	#39,	r12	;#0x0027
    6a84:	5e 27       	jz	$-322    	;abs 0x6942
    6a86:	7c 90 27 00 	cmp.b	#39,	r12	;#0x0027
    6a8a:	96 2b       	jnc	$-210    	;abs 0x69b8
    6a8c:	7c 90 28 00 	cmp.b	#40,	r12	;#0x0028
    6a90:	93 27       	jz	$-216    	;abs 0x69b8
    6a92:	7c 90 29 00 	cmp.b	#41,	r12	;#0x0029
    6a96:	55 27       	jz	$-340    	;abs 0x6942
    6a98:	80 00 72 69 	mova	#26994,	r0	;0x06972

00006a9c <.L62>:
    6a9c:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    6aa0:	4f 9c       	cmp.b	r12,	r15	;
    6aa2:	07 28       	jnc	$+16     	;abs 0x6ab2
    6aa4:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    6aa8:	87 2f       	jc	$-240    	;abs 0x69b8

00006aaa <.Loc.1660.2>:
      if (payload_len != 2) {
    6aaa:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    6aac:	4c 27       	jz	$-358    	;abs 0x6946
    6aae:	80 00 bc 69 	mova	#27068,	r0	;0x069bc

00006ab2 <.L63>:
  switch(hdr.opcode) {
    6ab2:	7c 90 2e 00 	cmp.b	#46,	r12	;#0x002e
    6ab6:	0d 24       	jz	$+28     	;abs 0x6ad2
    6ab8:	7c 90 2f 00 	cmp.b	#47,	r12	;#0x002f
    6abc:	5a 23       	jnz	$-330    	;abs 0x6972

00006abe <.Loc.1688.2>:
      if (payload_len != 2 && payload_len != 4 && 
    6abe:	7e c2       	bic.b	#8,	r14	;r2 As==11

00006ac0 <.LVL111>:
    6ac0:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    6ac2:	62 23       	jnz	$-314    	;abs 0x6988
    6ac4:	80 00 46 69 	mova	#26950,	r0	;0x06946

00006ac8 <.L53>:
      if (payload_len != 3) {
    6ac8:	7e 90 03 00 	cmp.b	#3,	r14	;
    6acc:	3c 27       	jz	$-390    	;abs 0x6946
    6ace:	80 00 bc 69 	mova	#27068,	r0	;0x069bc

00006ad2 <.L47>:
      if (payload_len > 251) {
    6ad2:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb

00006ad6 <.L181>:
      if (payload_len < 4 || payload_len > 251) {
    6ad6:	4c 9e       	cmp.b	r14,	r12	;
    6ad8:	36 2f       	jc	$-402    	;abs 0x6946
    6ada:	80 00 bc 69 	mova	#27068,	r0	;0x069bc

00006ade <.L52>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    6ade:	4c 4e       	mov.b	r14,	r12	;
    6ae0:	7c 53       	add.b	#-1,	r12	;r3 As==11
    6ae2:	7d 40 fa ff 	mov.b	#-6,	r13	;#0xfffa
    6ae6:	4d 9c       	cmp.b	r12,	r13	;
    6ae8:	69 2b       	jnc	$-300    	;abs 0x69bc

00006aea <.Loc.1710.2>:
    6aea:	1e b3       	bit	#1,	r14	;r3 As==01
    6aec:	2c 23       	jnz	$-422    	;abs 0x6946
    6aee:	80 00 bc 69 	mova	#27068,	r0	;0x069bc

00006af2 <.L50>:
      if (payload_len < 2 || payload_len > 251) {
    6af2:	7e 50 fe ff 	add.b	#-2,	r14	;#0xfffe

00006af6 <.LVL117>:
    6af6:	7f 40 f9 ff 	mov.b	#-7,	r15	;#0xfff9
    6afa:	4f 9e       	cmp.b	r14,	r15	;
    6afc:	24 2f       	jc	$-438    	;abs 0x6946
    6afe:	80 00 bc 69 	mova	#27068,	r0	;0x069bc

00006b02 <.L68>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    6b02:	0d 48       	mov	r8,	r13	;
    6b04:	2d 53       	incd	r13		;
    6b06:	4d 0e       	rlam.a	#4,	r13	;
    6b08:	4d 0d       	rram.a	#4,	r13	;
    6b0a:	cc 0a       	mova	r10,	r12	;
    6b0c:	b0 13 60 9a 	calla	#39520		;0x09a60

00006b10 <.LVL119>:
    6b10:	4a 4c       	mov.b	r12,	r10	;

00006b12 <.LVL120>:
    6b12:	0a 93       	cmp	#0,	r10	;r3 As==00
    6b14:	1a 23       	jnz	$-458    	;abs 0x694a

00006b16 <.Loc.1740.2>:
      elyErrorSignal(ErrFCSError);
    6b16:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    6b1a:	b0 13 ca 94 	calla	#38090		;0x094ca

00006b1e <.LVL121>:
      return false;
    6b1e:	80 00 4c 69 	mova	#26956,	r0	;0x0694c

00006b22 <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    6b22:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006b24 <.LCFI8>:
    6b24:	b1 00 08 00 	suba	#8,	r1	;

00006b28 <.LCFI9>:
    6b28:	2f 4c       	mov	@r12,	r15	;

00006b2a <.LVL123>:
    6b2a:	91 4c 02 00 	mov	2(r12),	6(r1)	;
    6b2e:	06 00 
    6b30:	cc 0d       	mova	r13,	r12	;
    6b32:	0d 4f       	mov	r15,	r13	;

00006b34 <.LVL124>:
    6b34:	5d 07       	rrum	#2,	r13	;
    6b36:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

00006b3a <.Loc.1751.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    6b3a:	0a 4d       	mov	r13,	r10	;
    6b3c:	0b 43       	clr	r11		;
    6b3e:	08 4a       	mov	r10,	r8	;
    6b40:	09 4b       	mov	r11,	r9	;
    6b42:	08 58       	rla	r8		;
    6b44:	09 69       	rlc	r9		;
    6b46:	08 58       	rla	r8		;
    6b48:	09 69       	rlc	r9		;
    6b4a:	81 48 00 00 	mov	r8,	0(r1)	;
    6b4e:	81 49 02 00 	mov	r9,	2(r1)	;
    6b52:	09 01       	mova	@r1,	r9	;
    6b54:	80 18 5e 49 	movx.a	66788(r9),r14	;0x104e4
    6b58:	e4 04 
    6b5a:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    6b5e:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

00006b62 <.LVL126>:
    6b62:	0f dd       	bis	r13,	r15	;
    6b64:	81 4f 04 00 	mov	r15,	4(r1)	;
    6b68:	cd 01       	mova	r1,	r13	;
    6b6a:	ad 00 04 00 	adda	#4,	r13	;
    6b6e:	4e 13       	calla	r14		;

00006b70 <.LVL127>:
}
    6b70:	a1 00 08 00 	adda	#8,	r1	;
    6b74:	28 16       	popm.a	#3,	r10	;20-bit words
    6b76:	10 01       	reta			;

00006b78 <elyCmdSendReplyI>:
  chSysLock();
  elyCmdSendReplyI(buff, dest_addr);
  chSysUnlock();
}

void elyCmdSendReplyI(uint8_t * buff, uint16_t dest_addr) {
    6b78:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006b7a <.LCFI10>:
    6b7a:	09 4d       	mov	r13,	r9	;

00006b7c <.Loc.1761.2>:
  uint8_t length = buff[1];
    6b7c:	58 4c 01 00 	mov.b	1(r12),	r8	;

00006b80 <.LVL129>:
  uint8_t * buffer = elyNLFromFW(buff);
    6b80:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006b84 <.LVL130>:
    6b84:	ca 0c       	mova	r12,	r10	;

00006b86 <.Loc.1764.2>:
  
  elyNLSetHeader(buffer, length+4, dest_addr);
    6b86:	0e 49       	mov	r9,	r14	;
    6b88:	0d 48       	mov	r8,	r13	;
    6b8a:	2d 52       	add	#4,	r13	;r2 As==10
    6b8c:	b0 13 f2 9f 	calla	#40946		;0x09ff2

00006b90 <.LVL132>:
  switch (elyNLGetDest(buffer, dest_addr)) {
    6b90:	0d 49       	mov	r9,	r13	;
    6b92:	cc 0a       	mova	r10,	r12	;
    6b94:	b0 13 62 9f 	calla	#40802		;0x09f62

00006b98 <.LVL133>:
    6b98:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6b9a:	11 24       	jz	$+36     	;abs 0x6bbe
    6b9c:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    6b9e:	14 20       	jnz	$+42     	;abs 0x6bc8

00006ba0 <.Loc.1767.2>:
    case ELY_DEST_RF:
      if (MSG_OK != elyRFPostI(buffer)) {
    6ba0:	cc 0a       	mova	r10,	r12	;
    6ba2:	b0 13 0e 97 	calla	#38670		;0x0970e

00006ba6 <.L197>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
      }
      break;
    case ELY_DEST_UART:
      if (MSG_OK != elyUARTPostI(buffer)) {
    6ba6:	9c 00 00 00 	cmpa	#0,	r12	;
    6baa:	07 24       	jz	$+16     	;abs 0x6bba

00006bac <.Loc.1777.2>:
        /* We should never hit this because everyone allocates the same amount */
        chDbgAssert(false, "internal buffer overflows should be impossible");
    6bac:	8c 01 c4 04 	mova	#66756,	r12	;0x104c4
    6bb0:	b0 13 58 46 	calla	#18008		;0x04658

00006bb4 <.LVL135>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
    6bb4:	cc 0a       	mova	r10,	r12	;
    6bb6:	b0 13 7a 65 	calla	#25978		;0x0657a

00006bba <.L184>:
      break;
    default:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
}
    6bba:	28 16       	popm.a	#3,	r10	;20-bit words
    6bbc:	10 01       	reta			;

00006bbe <.L186>:
      if (MSG_OK != elyUARTPostI(buffer)) {
    6bbe:	cc 0a       	mova	r10,	r12	;
    6bc0:	b0 13 0e 62 	calla	#25102		;0x0620e

00006bc4 <.LVL137>:
    6bc4:	80 00 a6 6b 	mova	#27558,	r0	;0x06ba6

00006bc8 <.L194>:
      chDbgAssert(false, "shouldn't happen");
    6bc8:	8c 01 c4 04 	mova	#66756,	r12	;0x104c4
    6bcc:	b0 13 58 46 	calla	#18008		;0x04658

00006bd0 <.LVL138>:
}
    6bd0:	80 00 ba 6b 	mova	#27578,	r0	;0x06bba

00006bd4 <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buff) {
    6bd4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006bd6 <.LCFI11>:
    6bd6:	08 14       	pushm.a	#1,	r8	;20-bit words

00006bd8 <.LCFI12>:
    6bd8:	c8 0c       	mova	r12,	r8	;

00006bda <.Loc.1456.2>:
  write_success(buff, telem_stored_hdr); /* crc */
    6bda:	8a 00 2e ac 	mova	#44078,	r10	;0x0ac2e
    6bde:	cd 0a       	mova	r10,	r13	;
    6be0:	b0 13 f2 67 	calla	#26610		;0x067f2

00006be4 <.LVL140>:
  elyCmdSendReplyI(buff, telem_stored_hdr.reply_addr);
    6be4:	1d 4a 02 00 	mov	2(r10),	r13	;
    6be8:	cc 08       	mova	r8,	r12	;
    6bea:	b0 13 78 6b 	calla	#27512		;0x06b78

00006bee <.LVL141>:
}
    6bee:	08 16       	popm.a	#1,	r8	;20-bit words
    6bf0:	0a 16       	popm.a	#1,	r10	;20-bit words
    6bf2:	10 01       	reta			;

00006bf4 <verify_fw_cb>:
static void verify_fw_cb(uint8_t * buffer) {
    6bf4:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006bf6 <.LCFI13>:
    6bf6:	06 14       	pushm.a	#1,	r6	;20-bit words

00006bf8 <.LCFI14>:
  uint16_t result = crcStop();
    6bf8:	b0 13 ec 9a 	calla	#39660		;0x09aec

00006bfc <.LVL143>:
    6bfc:	09 4c       	mov	r12,	r9	;

00006bfe <.Loc.1288.2>:
  uint8_t * reply_buff = elyFWGetBufferI();
    6bfe:	b0 13 f8 64 	calla	#25848		;0x064f8

00006c02 <.LVL145>:
    6c02:	c6 0c       	mova	r12,	r6	;

00006c04 <.Loc.1289.2>:
  if (reply_buff == NULL) {
    6c04:	9c 00 00 00 	cmpa	#0,	r12	;
    6c08:	10 24       	jz	$+34     	;abs 0x6c2a
    6c0a:	88 00 36 ac 	mova	#44086,	r8	;0x0ac36
    6c0e:	8a 00 78 6b 	mova	#27512,	r10	;0x06b78

00006c12 <.Loc.1295.2>:
    write_success(reply_buff, verify_stored_hdr);
    6c12:	8d 00 32 ac 	mova	#44082,	r13	;0x0ac32

00006c16 <.Loc.1294.2>:
  if (result == verify_crc) {
    6c16:	40 18 19 92 	cmpx.w	&0x0ac2c,r9	;
    6c1a:	2c ac 
    6c1c:	09 20       	jnz	$+20     	;abs 0x6c30

00006c1e <.Loc.1295.2>:
    write_success(reply_buff, verify_stored_hdr);
    6c1e:	b0 13 f2 67 	calla	#26610		;0x067f2

00006c22 <.L205>:
    elyCmdSendReplyI(reply_buff, stored_hdr.reply_addr);
    6c22:	1d 48 02 00 	mov	2(r8),	r13	;
    6c26:	cc 06       	mova	r6,	r12	;
    6c28:	4a 13       	calla	r10		;

00006c2a <.L199>:
}
    6c2a:	06 16       	popm.a	#1,	r6	;20-bit words
    6c2c:	28 16       	popm.a	#3,	r10	;20-bit words
    6c2e:	10 01       	reta			;

00006c30 <.L201>:
    write_failure(reply_buff, verify_stored_hdr);
    6c30:	b0 13 10 66 	calla	#26128		;0x06610

00006c34 <.LVL149>:
    6c34:	80 00 22 6c 	mova	#27682,	r0	;0x06c22

00006c38 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buff) {
    6c38:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006c3a <.LCFI15>:
    6c3a:	08 14       	pushm.a	#1,	r8	;20-bit words

00006c3c <.LCFI16>:
    6c3c:	c8 0c       	mova	r12,	r8	;

00006c3e <.Loc.1217.2>:
    write_success(buff, stored_hdr);
    6c3e:	8a 00 36 ac 	mova	#44086,	r10	;0x0ac36
    6c42:	cd 0a       	mova	r10,	r13	;
    6c44:	b0 13 f2 67 	calla	#26610		;0x067f2

00006c48 <.LVL151>:
    elyCmdSendReplyI(buff, stored_hdr.reply_addr);
    6c48:	1d 4a 02 00 	mov	2(r10),	r13	;
    6c4c:	cc 08       	mova	r8,	r12	;
    6c4e:	b0 13 78 6b 	calla	#27512		;0x06b78

00006c52 <.LVL152>:
}
    6c52:	08 16       	popm.a	#1,	r8	;20-bit words
    6c54:	0a 16       	popm.a	#1,	r10	;20-bit words
    6c56:	10 01       	reta			;

00006c58 <elyCmdSendReply>:
void elyCmdSendReply(uint8_t * buff, uint16_t dest_addr) {
    6c58:	b1 00 08 00 	suba	#8,	r1	;

00006c5c <.LCFI17>:
  chSysLock();
    6c5c:	71 0c 04 00 	mova	r12,	4(r1)	;
    6c60:	71 0d 00 00 	mova	r13,	0(r1)	;
    6c64:	b0 13 e6 65 	calla	#26086		;0x065e6

00006c68 <.LVL154>:
  elyCmdSendReplyI(buff, dest_addr);
    6c68:	0d 01       	mova	@r1,	r13	;
    6c6a:	3c 01 04 00 	mova	4(r1),	r12	;
    6c6e:	b0 13 78 6b 	calla	#27512		;0x06b78

00006c72 <.LVL155>:
  chSysUnlock();
    6c72:	b0 13 ee 65 	calla	#26094		;0x065ee

00006c76 <.LVL156>:
}
    6c76:	a1 00 08 00 	adda	#8,	r1	;
    6c7a:	10 01       	reta			;

00006c7c <gen_success>:
static void gen_success(elysium_cmd_hdr_t hdr) {
    6c7c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006c7e <.LCFI18>:
    6c7e:	b1 00 04 00 	suba	#4,	r1	;

00006c82 <.LCFI19>:
    6c82:	28 4c       	mov	@r12,	r8	;

00006c84 <.LVL158>:
    6c84:	19 4c 02 00 	mov	2(r12),	r9	;

00006c88 <.LVL159>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6c88:	b0 13 18 65 	calla	#25880		;0x06518

00006c8c <.LVL160>:
    6c8c:	ca 0c       	mova	r12,	r10	;

00006c8e <.Loc.50.2>:
  if (reply_buff == NULL) {
    6c8e:	9c 00 00 00 	cmpa	#0,	r12	;
    6c92:	0b 24       	jz	$+24     	;abs 0x6caa

00006c94 <.Loc.54.2>:
  write_success(reply_buff, hdr);
    6c94:	81 48 00 00 	mov	r8,	0(r1)	;
    6c98:	81 49 02 00 	mov	r9,	2(r1)	;
    6c9c:	cd 01       	mova	r1,	r13	;
    6c9e:	b0 13 f2 67 	calla	#26610		;0x067f2

00006ca2 <.LVL163>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    6ca2:	0d 49       	mov	r9,	r13	;
    6ca4:	cc 0a       	mova	r10,	r12	;
    6ca6:	b0 13 58 6c 	calla	#27736		;0x06c58

00006caa <.L208>:
}
    6caa:	a1 00 04 00 	adda	#4,	r1	;
    6cae:	28 16       	popm.a	#3,	r10	;20-bit words
    6cb0:	10 01       	reta			;

00006cb2 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6cb2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006cb4 <.LCFI20>:
    6cb4:	b1 00 1c 00 	suba	#28,	r1	;0x0001c

00006cb8 <.LCFI21>:
    6cb8:	c8 0c       	mova	r12,	r8	;
    6cba:	2a 4d       	mov	@r13,	r10	;

00006cbc <.LVL167>:
    6cbc:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    6cc0:	0a 00 
    6cc2:	0c 4a       	mov	r10,	r12	;

00006cc4 <.LVL168>:
    6cc4:	5c 0f       	rrum	#4,	r12	;
    6cc6:	5c 0f       	rrum	#4,	r12	;
    6cc8:	81 4c 08 00 	mov	r12,	8(r1)	;

00006ccc <.Loc.1497.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ccc:	4c 4a       	mov.b	r10,	r12	;
    6cce:	4e 4c       	mov.b	r12,	r14	;
    6cd0:	6e f3       	and.b	#2,	r14	;r3 As==10
    6cd2:	4d 4e       	mov.b	r14,	r13	;
    6cd4:	81 4d 06 00 	mov	r13,	6(r1)	;
    6cd8:	0d 93       	cmp	#0,	r13	;r3 As==00
    6cda:	49 20       	jnz	$+148    	;abs 0x6d6e
    6cdc:	6f 43       	mov.b	#2,	r15	;r3 As==10

00006cde <.L214>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6cde:	1c b3       	bit	#1,	r12	;r3 As==01
    6ce0:	49 20       	jnz	$+148    	;abs 0x6d74

00006ce2 <.Loc.1498.2>:
    6ce2:	4c 43       	clr.b	r12		;

00006ce4 <.L215>:
    6ce4:	1d 41 08 00 	mov	8(r1),	r13	;
    6ce8:	4d 8e       	sub.b	r14,	r13	;
    6cea:	4d 8c       	sub.b	r12,	r13	;

00006cec <.LVL171>:
  if (payload_len == 4 || payload_len == 12) {
    6cec:	4c 4d       	mov.b	r13,	r12	;
    6cee:	7c c2       	bic.b	#8,	r12	;r2 As==11
    6cf0:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    6cf2:	74 20       	jnz	$+234    	;abs 0x6ddc

00006cf4 <.LVL172>:
    config.index_start = buffer[hdr_ext+2];
    6cf4:	40 18 0c 4f 	movx.w	r15,	r12	;
    6cf8:	ce 08       	mova	r8,	r14	;
    6cfa:	ee 0c       	adda	r12,	r14	;
    6cfc:	d1 4e 02 00 	mov.b	2(r14),	24(r1)	; 0x0018
    6d00:	18 00 

00006d02 <.Loc.1506.2>:
    config.index_end = buffer[hdr_ext+3];
    6d02:	d1 4e 03 00 	mov.b	3(r14),	25(r1)	; 0x0019
    6d06:	19 00 

00006d08 <.Loc.1512.2>:
  if (payload_len > 4) {
    6d08:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    6d0a:	37 20       	jnz	$+112    	;abs 0x6d7a

00006d0c <.L230>:
    config.use_index = true;
    6d0c:	54 43       	mov.b	#1,	r4	;r3 As==01

00006d0e <.L218>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6d0e:	cc 08       	mova	r8,	r12	;
    6d10:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006d14 <.LVL175>:
    6d14:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00006d18 <.LVL176>:
  chSysLock();
    6d18:	b0 13 e6 65 	calla	#26086		;0x065e6

00006d1c <.LVL177>:
  elyTelemUpdateConfigS(config);
    6d1c:	81 49 10 00 	mov	r9,	16(r1)	; 0x0010
    6d20:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    6d24:	81 46 14 00 	mov	r6,	20(r1)	; 0x0014
    6d28:	81 45 16 00 	mov	r5,	22(r1)	; 0x0016
    6d2c:	c1 44 1a 00 	mov.b	r4,	26(r1)	; 0x001a
    6d30:	cc 01       	mova	r1,	r12	;
    6d32:	ac 00 10 00 	adda	#16,	r12	;0x00010
    6d36:	b0 13 56 95 	calla	#38230		;0x09556

00006d3a <.LVL178>:
  chSysUnlock();
    6d3a:	b0 13 ee 65 	calla	#26094		;0x065ee

00006d3e <.LVL179>:
  if (hdr.reply) {
    6d3e:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6d42:	11 24       	jz	$+36     	;abs 0x6d66

00006d44 <.Loc.1536.2>:
    gen_success(hdr);
    6d44:	19 41 08 00 	mov	8(r1),	r9	;

00006d48 <.LVL180>:
    6d48:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    6d4c:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00006d50 <.LVL181>:
    6d50:	0a d9       	bis	r9,	r10	;
    6d52:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    6d56:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    6d5a:	0e 00 
    6d5c:	cc 01       	mova	r1,	r12	;
    6d5e:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    6d62:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00006d66 <.L213>:
}
    6d66:	a1 00 1c 00 	adda	#28,	r1	;0x0001c
    6d6a:	64 16       	popm.a	#7,	r10	;20-bit words
    6d6c:	10 01       	reta			;

00006d6e <.L223>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6d6e:	6f 42       	mov.b	#4,	r15	;r2 As==10
    6d70:	80 00 de 6c 	mova	#27870,	r0	;0x06cde

00006d74 <.L224>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6d74:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6d76:	80 00 e4 6c 	mova	#27876,	r0	;0x06ce4

00006d7a <.L217>:
    config.use_timestamp = true;
    6d7a:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00006d7e <.LBB35>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    6d7e:	0e 4f       	mov	r15,	r14	;
    6d80:	3e 50 0b 00 	add	#11,	r14	;#0x000b
    6d84:	4e 0e       	rlam.a	#4,	r14	;
    6d86:	4e 0d       	rram.a	#4,	r14	;
    6d88:	ee 08       	adda	r8,	r14	;
    6d8a:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    6d8e:	81 4e 04 00 	mov	r14,	4(r1)	;
    6d92:	ac 00 07 00 	adda	#7,	r12	;
    6d96:	ce 08       	mova	r8,	r14	;
    6d98:	ee 0c       	adda	r12,	r14	;
    6d9a:	44 43       	clr.b	r4		;

00006d9c <.L219>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    6d9c:	6c 4e       	mov.b	@r14,	r12	;
    6d9e:	0d 44       	mov	r4,	r13	;
    6da0:	71 0e 00 00 	mova	r14,	0(r1)	;
    6da4:	b0 13 e0 a2 	calla	#41696		;0x0a2e0
    6da8:	0d 4c       	mov	r12,	r13	;
    6daa:	0b 4c       	mov	r12,	r11	;
    6dac:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6db0:	09 dd       	bis	r13,	r9	;

00006db2 <.LVL187>:
    6db2:	07 dc       	bis	r12,	r7	;

00006db4 <.Loc.1517.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    6db4:	1c 41 04 00 	mov	4(r1),	r12	;
    6db8:	0d 44       	mov	r4,	r13	;
    6dba:	b0 13 e0 a2 	calla	#41696		;0x0a2e0
    6dbe:	0d 4c       	mov	r12,	r13	;
    6dc0:	0b 4c       	mov	r12,	r11	;
    6dc2:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6dc6:	06 dd       	bis	r13,	r6	;

00006dc8 <.LVL189>:
    6dc8:	05 dc       	bis	r12,	r5	;
    6dca:	0e 01       	mova	@r1,	r14	;
    6dcc:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    6dd0:	34 52       	add	#8,	r4	;r2 As==11

00006dd2 <.Loc.1515.2>:
      for (int i = 0; i < 4; i++) {
    6dd2:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    6dd6:	e2 23       	jnz	$-58     	;abs 0x6d9c
    6dd8:	80 00 0c 6d 	mova	#27916,	r0	;0x06d0c

00006ddc <.L216>:
  if (payload_len > 4) {
    6ddc:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6dde:	4c 9d       	cmp.b	r13,	r12	;
    6de0:	30 2c       	jc	$+98     	;abs 0x6e42

00006de2 <.Loc.1513.2>:
    config.use_timestamp = true;
    6de2:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00006de6 <.LBB36>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6de6:	0c 4f       	mov	r15,	r12	;
    6de8:	3c 50 09 00 	add	#9,	r12	;
    6dec:	4c 0e       	rlam.a	#4,	r12	;
    6dee:	4c 0d       	rram.a	#4,	r12	;
    6df0:	ec 08       	adda	r8,	r12	;
    6df2:	5c 4c ff ff 	mov.b	-1(r12),r12	;
    6df6:	81 4c 04 00 	mov	r12,	4(r1)	;
    6dfa:	40 18 0e 4f 	movx.w	r15,	r14	;
    6dfe:	ae 00 05 00 	adda	#5,	r14	;
    6e02:	ee 08       	adda	r8,	r14	;
    6e04:	44 43       	clr.b	r4		;

00006e06 <.L220>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    6e06:	6c 4e       	mov.b	@r14,	r12	;
    6e08:	0d 44       	mov	r4,	r13	;
    6e0a:	71 0e 00 00 	mova	r14,	0(r1)	;
    6e0e:	b0 13 e0 a2 	calla	#41696		;0x0a2e0
    6e12:	0d 4c       	mov	r12,	r13	;
    6e14:	0b 4c       	mov	r12,	r11	;
    6e16:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6e1a:	09 dd       	bis	r13,	r9	;

00006e1c <.LVL194>:
    6e1c:	07 dc       	bis	r12,	r7	;

00006e1e <.Loc.1523.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6e1e:	1c 41 04 00 	mov	4(r1),	r12	;
    6e22:	0d 44       	mov	r4,	r13	;
    6e24:	b0 13 e0 a2 	calla	#41696		;0x0a2e0
    6e28:	0d 4c       	mov	r12,	r13	;
    6e2a:	0b 4c       	mov	r12,	r11	;
    6e2c:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    6e30:	06 dd       	bis	r13,	r6	;

00006e32 <.LVL196>:
    6e32:	05 dc       	bis	r12,	r5	;
    6e34:	0e 01       	mova	@r1,	r14	;
    6e36:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    6e3a:	34 52       	add	#8,	r4	;r2 As==11

00006e3c <.Loc.1521.2>:
      for (int i = 0; i < 4; i++) {
    6e3c:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    6e40:	e2 23       	jnz	$-58     	;abs 0x6e06

00006e42 <.L231>:
    config.use_index = false;
    6e42:	44 43       	clr.b	r4		;
    6e44:	80 00 0e 6d 	mova	#27918,	r0	;0x06d0e

00006e48 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6e48:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006e4a <.LCFI22>:
    6e4a:	04 14       	pushm.a	#1,	r4	;20-bit words

00006e4c <.LCFI23>:
    6e4c:	b1 00 04 00 	suba	#4,	r1	;

00006e50 <.LCFI24>:
    6e50:	c6 0c       	mova	r12,	r6	;
    6e52:	27 4d       	mov	@r13,	r7	;

00006e54 <.LVL199>:
    6e54:	1a 4d 02 00 	mov	2(r13),	r10	;

00006e58 <.LVL200>:
    6e58:	09 47       	mov	r7,	r9	;

00006e5a <.Loc.1438.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6e5a:	84 00 f6 a1 	mova	#41462,	r4	;0x0a1f6
    6e5e:	44 13       	calla	r4		;

00006e60 <.LVL202>:
    6e60:	88 00 4a 9f 	mova	#40778,	r8	;0x09f4a
    6e64:	48 13       	calla	r8		;

00006e66 <.LVL203>:
  if (hdr.reply) {
    6e66:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    6e6a:	13 24       	jz	$+40     	;abs 0x6e92

00006e6c <.Loc.1442.2>:
    gen_success(hdr);
    6e6c:	81 47 00 00 	mov	r7,	0(r1)	;
    6e70:	81 4a 02 00 	mov	r10,	2(r1)	;
    6e74:	cc 01       	mova	r1,	r12	;
    6e76:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00006e7a <.L234>:
  bootloader = 1;
    6e7a:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    6e7e:	fc 19 

00006e80 <.Loc.1450.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6e80:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    6e84:	48 a5 20 01 

00006e88 <.Loc.1452.2>:
}
    6e88:	a1 00 04 00 	adda	#4,	r1	;
    6e8c:	04 16       	popm.a	#1,	r4	;20-bit words
    6e8e:	46 16       	popm.a	#5,	r10	;20-bit words
    6e90:	10 01       	reta			;

00006e92 <.L233>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6e92:	cc 06       	mova	r6,	r12	;
    6e94:	44 13       	calla	r4		;

00006e96 <.LVL207>:
    6e96:	48 13       	calla	r8		;

00006e98 <.LVL208>:
    6e98:	80 00 7a 6e 	mova	#28282,	r0	;0x06e7a

00006e9c <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6e9c:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006e9e <.LCFI25>:
    6e9e:	b1 00 08 00 	suba	#8,	r1	;

00006ea2 <.LCFI26>:
    6ea2:	2a 4d       	mov	@r13,	r10	;

00006ea4 <.LVL210>:
    6ea4:	17 4d 02 00 	mov	2(r13),	r7	;

00006ea8 <.LVL211>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6ea8:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006eac <.LVL212>:
    6eac:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00006eb0 <.LVL213>:
    6eb0:	38 40 00 04 	mov	#1024,	r8	;#0x0400
    6eb4:	59 43       	mov.b	#1,	r9	;r3 As==01

00006eb6 <.LBB40>:
    chSysLock();
    6eb6:	84 00 e6 65 	mova	#26086,	r4	;0x065e6

00006eba <.Loc.1404.2>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6eba:	85 00 78 9d 	mova	#40312,	r5	;0x09d78

00006ebe <.L240>:
    chSysLock();
    6ebe:	44 13       	calla	r4		;

00006ec0 <.LVL215>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6ec0:	4d 43       	clr.b	r13		;
    6ec2:	cc 01       	mova	r1,	r12	;
    6ec4:	ac 00 04 00 	adda	#4,	r12	;
    6ec8:	45 13       	calla	r5		;

00006eca <.LVL216>:
    chSysUnlock();
    6eca:	86 00 ee 65 	mova	#26094,	r6	;0x065ee
    6ece:	46 13       	calla	r6		;

00006ed0 <.LVL217>:
    req->address = FRAM_FW_BASE + (i * 128); 
    6ed0:	3c 01 04 00 	mova	4(r1),	r12	;
    6ed4:	8c 48 00 00 	mov	r8,	0(r12)	;
    6ed8:	8c 49 02 00 	mov	r9,	2(r12)	;

00006edc <.Loc.1409.2>:
    req->read = 0;
    6edc:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    6ee0:	6d c3       	bic.b	#2,	r13	;r3 As==10

00006ee2 <.Loc.1410.2>:
    req->special = 1; /* write a constant value */
    6ee2:	5d d3       	bis.b	#1,	r13	;r3 As==01
    6ee4:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00006ee8 <.Loc.1411.2>:
    req->size = 128;
    6ee8:	1d 4c 04 00 	mov	4(r12),	r13	;
    6eec:	7d f0 03 00 	and.b	#3,	r13	;
    6ef0:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    6ef4:	8c 4d 04 00 	mov	r13,	4(r12)	;
    6ef8:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    6efc:	06 00 

00006efe <.Loc.1412.2>:
    req->buffer = &fill_value; 
    6efe:	00 18 fc 40 	movx.a	#44072,	8(r12)	;0x0ac28
    6f02:	28 ac 08 00 

00006f06 <.Loc.1413.2>:
    req->callback = cancel_fw_eeprom_cb;
    6f06:	00 18 fc 40 	movx.a	#26678,	12(r12)	;0x06836, 0x0000c
    6f0a:	36 68 0c 00 

00006f0e <.Loc.1417.2>:
    chSysLock();
    6f0e:	44 13       	calla	r4		;

00006f10 <.LVL218>:
    elyFramPostRequestS(req);
    6f10:	3c 01 04 00 	mova	4(r1),	r12	;
    6f14:	b0 13 54 9d 	calla	#40276		;0x09d54

00006f18 <.LVL219>:
    chSysUnlock();
    6f18:	46 13       	calla	r6		;

00006f1a <.LBB41>:
  return chSemWaitTimeout(&bsp->sem, time);
    6f1a:	4d 43       	clr.b	r13		;
    6f1c:	8c 00 2a ac 	mova	#44074,	r12	;0x0ac2a
    6f20:	b0 13 84 48 	calla	#18564		;0x04884

00006f24 <.LVL221>:
    6f24:	38 50 80 00 	add	#128,	r8	;#0x0080
    6f28:	09 63       	adc	r9		;

00006f2a <.LBE41>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    6f2a:	08 93       	cmp	#0,	r8	;r3 As==00
    6f2c:	c8 23       	jnz	$-110    	;abs 0x6ebe
    6f2e:	29 93       	cmp	#2,	r9	;r3 As==10
    6f30:	c6 23       	jnz	$-114    	;abs 0x6ebe

00006f32 <.LBE40>:
  if (hdr.reply) {
    6f32:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    6f36:	07 24       	jz	$+16     	;abs 0x6f46

00006f38 <.Loc.1427.2>:
    gen_success(hdr);
    6f38:	81 4a 00 00 	mov	r10,	0(r1)	;
    6f3c:	81 47 02 00 	mov	r7,	2(r1)	;
    6f40:	cc 01       	mova	r1,	r12	;
    6f42:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00006f46 <.L235>:
}
    6f46:	a1 00 08 00 	adda	#8,	r1	;
    6f4a:	64 16       	popm.a	#7,	r10	;20-bit words
    6f4c:	10 01       	reta			;

00006f4e <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6f4e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006f50 <.LCFI27>:
    6f50:	b1 00 04 00 	suba	#4,	r1	;

00006f54 <.LCFI28>:
    6f54:	c8 0c       	mova	r12,	r8	;
    6f56:	29 4d       	mov	@r13,	r9	;

00006f58 <.LVL226>:
    6f58:	1a 4d 02 00 	mov	2(r13),	r10	;

00006f5c <.LVL227>:
    6f5c:	07 49       	mov	r9,	r7	;

00006f5e <.Loc.1024.2>:
  elyEventReset();
    6f5e:	b0 13 da 94 	calla	#38106		;0x094da

00006f62 <.LVL229>:
  if (hdr.reply) {
    6f62:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    6f66:	07 24       	jz	$+16     	;abs 0x6f76

00006f68 <.Loc.1028.2>:
    gen_success(hdr);
    6f68:	81 49 00 00 	mov	r9,	0(r1)	;
    6f6c:	81 4a 02 00 	mov	r10,	2(r1)	;
    6f70:	cc 01       	mova	r1,	r12	;
    6f72:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00006f76 <.L243>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6f76:	cc 08       	mova	r8,	r12	;
    6f78:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006f7c <.LVL232>:
    6f7c:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00006f80 <.LVL233>:
}
    6f80:	a1 00 04 00 	adda	#4,	r1	;
    6f84:	37 16       	popm.a	#4,	r10	;20-bit words
    6f86:	10 01       	reta			;

00006f88 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6f88:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006f8a <.LCFI29>:
    6f8a:	b1 00 04 00 	suba	#4,	r1	;

00006f8e <.LCFI30>:
    6f8e:	c8 0c       	mova	r12,	r8	;
    6f90:	29 4d       	mov	@r13,	r9	;

00006f92 <.LVL235>:
    6f92:	1a 4d 02 00 	mov	2(r13),	r10	;

00006f96 <.LVL236>:
    6f96:	07 49       	mov	r9,	r7	;

00006f98 <.Loc.871.2>:
  elyChanReset();
    6f98:	b0 13 e8 94 	calla	#38120		;0x094e8

00006f9c <.LVL238>:
  if (hdr.reply) {
    6f9c:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    6fa0:	07 24       	jz	$+16     	;abs 0x6fb0

00006fa2 <.Loc.875.2>:
    gen_success(hdr);
    6fa2:	81 49 00 00 	mov	r9,	0(r1)	;
    6fa6:	81 4a 02 00 	mov	r10,	2(r1)	;
    6faa:	cc 01       	mova	r1,	r12	;
    6fac:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00006fb0 <.L248>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6fb0:	cc 08       	mova	r8,	r12	;
    6fb2:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00006fb6 <.LVL241>:
    6fb6:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00006fba <.LVL242>:
}
    6fba:	a1 00 04 00 	adda	#4,	r1	;
    6fbe:	37 16       	popm.a	#4,	r10	;20-bit words
    6fc0:	10 01       	reta			;

00006fc2 <gen_failure>:
static void gen_failure(elysium_cmd_hdr_t hdr) {
    6fc2:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006fc4 <.LCFI31>:
    6fc4:	b1 00 04 00 	suba	#4,	r1	;

00006fc8 <.LCFI32>:
    6fc8:	28 4c       	mov	@r12,	r8	;

00006fca <.LVL244>:
    6fca:	19 4c 02 00 	mov	2(r12),	r9	;

00006fce <.LVL245>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6fce:	b0 13 18 65 	calla	#25880		;0x06518

00006fd2 <.LVL246>:
    6fd2:	ca 0c       	mova	r12,	r10	;

00006fd4 <.Loc.72.2>:
  if (reply_buff == NULL) {
    6fd4:	9c 00 00 00 	cmpa	#0,	r12	;
    6fd8:	0b 24       	jz	$+24     	;abs 0x6ff0

00006fda <.Loc.77.2>:
  write_failure(reply_buff, hdr);
    6fda:	81 48 00 00 	mov	r8,	0(r1)	;
    6fde:	81 49 02 00 	mov	r9,	2(r1)	;
    6fe2:	cd 01       	mova	r1,	r13	;
    6fe4:	b0 13 10 66 	calla	#26128		;0x06610

00006fe8 <.LVL249>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    6fe8:	0d 49       	mov	r9,	r13	;
    6fea:	cc 0a       	mova	r10,	r12	;
    6fec:	b0 13 58 6c 	calla	#27736		;0x06c58

00006ff0 <.L252>:
}
    6ff0:	a1 00 04 00 	adda	#4,	r1	;
    6ff4:	28 16       	popm.a	#3,	r10	;20-bit words
    6ff6:	10 01       	reta			;

00006ff8 <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6ff8:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006ffa <.LCFI33>:
    6ffa:	b1 00 14 00 	suba	#20,	r1	;0x00014

00006ffe <.LCFI34>:
    6ffe:	c6 0c       	mova	r12,	r6	;
    7000:	2a 4d       	mov	@r13,	r10	;

00007002 <.LVL253>:
    7002:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    7006:	0a 00 
    7008:	09 4a       	mov	r10,	r9	;
    700a:	59 0f       	rrum	#4,	r9	;
    700c:	59 0f       	rrum	#4,	r9	;
    700e:	81 49 04 00 	mov	r9,	4(r1)	;

00007012 <.Loc.1229.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7012:	49 4a       	mov.b	r10,	r9	;
    7014:	81 49 00 00 	mov	r9,	0(r1)	;
    7018:	0c 49       	mov	r9,	r12	;

0000701a <.LVL255>:
    701a:	6c f3       	and.b	#2,	r12	;r3 As==10
    701c:	47 4c       	mov.b	r12,	r7	;
    701e:	07 93       	cmp	#0,	r7	;r3 As==00
    7020:	42 20       	jnz	$+134    	;abs 0x70a6
    7022:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007024 <.L258>:
    7024:	00 18 c1 4d 	movx.a	r13,	6(r1)	;
    7028:	06 00 
    702a:	38 01 06 00 	mova	6(r1),	r8	;
    702e:	e8 06       	adda	r6,	r8	;

00007030 <.Loc.1229.2>:
    7030:	79 40 18 00 	mov.b	#24,	r9	;#0x0018

00007034 <.Loc.1230.2>:
  uint32_t address = 0;
    7034:	44 43       	clr.b	r4		;
    7036:	05 44       	mov	r4,	r5	;

00007038 <.L259>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    7038:	6c 48       	mov.b	@r8,	r12	;
    703a:	0d 43       	clr	r13		;
    703c:	0e 49       	mov	r9,	r14	;
    703e:	0f 43       	clr	r15		;
    7040:	b0 13 2a a3 	calla	#41770		;0x0a32a
    7044:	0c d4       	bis	r4,	r12	;
    7046:	0d d5       	bis	r5,	r13	;
    7048:	04 4c       	mov	r12,	r4	;

0000704a <.LVL259>:
    704a:	05 4d       	mov	r13,	r5	;

0000704c <.LVL260>:
    704c:	a8 00 01 00 	adda	#1,	r8	;
    7050:	39 50 f8 ff 	add	#-8,	r9	;#0xfff8

00007054 <.Loc.1233.2>:
  for (int i = 0; i < 4; i++) {
    7054:	39 90 f8 ff 	cmp	#-8,	r9	;#0xfff8
    7058:	ef 23       	jnz	$-32     	;abs 0x7038

0000705a <.LBE43>:
  if (address < 0x4400 || address > 0x13FFF) {
    705a:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    705e:	09 4d       	mov	r13,	r9	;
    7060:	39 63       	addc	#-1,	r9	;r3 As==11
    7062:	09 93       	cmp	#0,	r9	;r3 As==00
    7064:	04 20       	jnz	$+10     	;abs 0x706e
    7066:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    706a:	0d 9c       	cmp	r12,	r13	;
    706c:	25 2c       	jc	$+76     	;abs 0x70b8

0000706e <.L272>:
    if (hdr.reply) {
    706e:	07 93       	cmp	#0,	r7	;r3 As==00
    7070:	1d 24       	jz	$+60     	;abs 0x70ac

00007072 <.Loc.1240.2>:
      gen_failure(hdr);
    7072:	1c 41 04 00 	mov	4(r1),	r12	;
    7076:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    707a:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

0000707e <.LVL261>:
    707e:	0a dc       	bis	r12,	r10	;
    7080:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    7084:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    7088:	0e 00 
    708a:	cc 01       	mova	r1,	r12	;
    708c:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    7090:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007094 <.L275>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    7094:	cc 06       	mova	r6,	r12	;
    7096:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000709a <.LVL263>:
    709a:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000709e <.L257>:
}
    709e:	a1 00 14 00 	adda	#20,	r1	;0x00014
    70a2:	64 16       	popm.a	#7,	r10	;20-bit words
    70a4:	10 01       	reta			;

000070a6 <.L269>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    70a6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    70a8:	80 00 24 70 	mova	#28708,	r0	;0x07024

000070ac <.L262>:
      elyErrorSignal(ErrCmdFailure);
    70ac:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    70b0:	b0 13 ca 94 	calla	#38090		;0x094ca

000070b4 <.LVL267>:
    70b4:	80 00 94 70 	mova	#28820,	r0	;0x07094

000070b8 <.L274>:
  uint8_t * reply_buff = elyFWGetBuffer();
    70b8:	b0 13 18 65 	calla	#25880		;0x06518

000070bc <.LVL268>:
    70bc:	c8 0c       	mova	r12,	r8	;

000070be <.Loc.1250.2>:
  if (reply_buff == NULL) {
    70be:	9c 00 00 00 	cmpa	#0,	r12	;
    70c2:	e8 27       	jz	$-46     	;abs 0x7094

000070c4 <.Loc.1259.2>:
  chSysLock();
    70c4:	b0 13 e6 65 	calla	#26086		;0x065e6

000070c8 <.LVL270>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    70c8:	0d 49       	mov	r9,	r13	;
    70ca:	cc 01       	mova	r1,	r12	;
    70cc:	ac 00 10 00 	adda	#16,	r12	;0x00010
    70d0:	b0 13 78 9d 	calla	#40312		;0x09d78

000070d4 <.LVL271>:
  chSysUnlock();
    70d4:	b0 13 ee 65 	calla	#26094		;0x065ee

000070d8 <.LVL272>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    70d8:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    70dc:	1d 41 04 00 	mov	4(r1),	r13	;
    70e0:	0d 87       	sub	r7,	r13	;
    70e2:	40 18 91 b3 	bitx.w	#1,	0(r1)	;r3 As==01
    70e6:	00 00 
    70e8:	01 24       	jz	$+4      	;abs 0x70ec
    70ea:	69 43       	mov.b	#2,	r9	;r3 As==10

000070ec <.L266>:
    70ec:	0d 89       	sub	r9,	r13	;
    70ee:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc
    70f2:	0e 4d       	mov	r13,	r14	;
    70f4:	4e 0e       	rlam.a	#4,	r14	;
    70f6:	4e 0d       	rram.a	#4,	r14	;
    70f8:	80 18 7e f0 	andx.a	#131071,r14	;0x1ffff
    70fc:	ff ff 
    70fe:	71 0e 00 00 	mova	r14,	0(r1)	;
    7102:	0d 4e       	mov	r14,	r13	;
    7104:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    7108:	1e 4c 04 00 	mov	4(r12),	r14	;
    710c:	7e f0 03 00 	and.b	#3,	r14	;
    7110:	0e dd       	bis	r13,	r14	;
    7112:	8c 4e 04 00 	mov	r14,	4(r12)	;
    7116:	2e 41       	mov	@r1,	r14	;
    7118:	0f 4e       	mov	r14,	r15	;
    711a:	5f 03       	rrum	#1,	r15	;
    711c:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    7120:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    7124:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    7128:	09 01       	mova	@r1,	r9	;
    712a:	09 14       	pushm.a	#1,	r9	;20-bit words
    712c:	0d 17       	popm	#1,	r13	;16-bit words
    712e:	0d 17       	popm	#1,	r13	;16-bit words
    7130:	5d f3       	and.b	#1,	r13	;r3 As==01
    7132:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    7136:	4e df       	bis.b	r15,	r14	;
    7138:	4e dd       	bis.b	r13,	r14	;
    713a:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000713e <.Loc.1264.2>:
  memcpy(reply_buff, buffer + hdr_ext + 4, req->size);
    713e:	3d 01 06 00 	mova	6(r1),	r13	;
    7142:	ad 00 04 00 	adda	#4,	r13	;
    7146:	ce 09       	mova	r9,	r14	;
    7148:	ed 06       	adda	r6,	r13	;
    714a:	cc 08       	mova	r8,	r12	;
    714c:	b0 13 06 a4 	calla	#41990		;0x0a406

00007150 <.LVL274>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7150:	cc 06       	mova	r6,	r12	;
    7152:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007156 <.LVL275>:
    7156:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000715a <.LVL276>:
  stored_hdr = hdr;
    715a:	1c 41 04 00 	mov	4(r1),	r12	;
    715e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7162:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00007166 <.LVL277>:
    7166:	0a dc       	bis	r12,	r10	;
    7168:	40 18 82 4a 	movx.w	r10,	&0xfac36;
    716c:	36 ac 
    716e:	40 18 92 41 	movx.w	10(r1),	&0xfac38;0x0000a
    7172:	0a 00 38 ac 

00007176 <.Loc.1271.2>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    7176:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    717a:	34 50 00 c0 	add	#-16384,r4	;#0xc000

0000717e <.LVL278>:
    717e:	8c 44 00 00 	mov	r4,	0(r12)	;
    7182:	05 63       	adc	r5		;
    7184:	8c 45 02 00 	mov	r5,	2(r12)	;

00007188 <.Loc.1272.2>:
  req->read = 0;
    7188:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

0000718c <.Loc.1273.2>:
  req->buffer = reply_buff;
    718c:	7c 08 08 00 	mova	r8,	8(r12)	;

00007190 <.Loc.1274.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    7190:	07 93       	cmp	#0,	r7	;r3 As==00
    7192:	0e 20       	jnz	$+30     	;abs 0x71b0

00007194 <.Loc.1274.2>:
    7194:	8e 00 38 67 	mova	#26424,	r14	;0x06738

00007198 <.L267>:
    7198:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

0000719c <.Loc.1277.2>:
  chSysLock();
    719c:	b0 13 e6 65 	calla	#26086		;0x065e6

000071a0 <.LVL280>:
  elyFramPostRequestS(req);
    71a0:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    71a4:	b0 13 54 9d 	calla	#40276		;0x09d54

000071a8 <.LVL281>:
  chSysUnlock();
    71a8:	b0 13 ee 65 	calla	#26094		;0x065ee

000071ac <.LVL282>:
    71ac:	80 00 9e 70 	mova	#28830,	r0	;0x0709e

000071b0 <.L271>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    71b0:	8e 00 38 6c 	mova	#27704,	r14	;0x06c38
    71b4:	80 00 98 71 	mova	#29080,	r0	;0x07198

000071b8 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    71b8:	3a 14       	pushm.a	#4,	r10	;20-bit words

000071ba <.LCFI35>:
    71ba:	b1 00 04 00 	suba	#4,	r1	;

000071be <.LCFI36>:
    71be:	2a 4d       	mov	@r13,	r10	;

000071c0 <.LVL284>:
    71c0:	18 4d 02 00 	mov	2(r13),	r8	;

000071c4 <.LVL285>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    71c4:	49 4a       	mov.b	r10,	r9	;
    71c6:	69 f3       	and.b	#2,	r9	;r3 As==10
    71c8:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    71cc:	09 93       	cmp	#0,	r9	;r3 As==00
    71ce:	1a 20       	jnz	$+54     	;abs 0x7204
    71d0:	6e 43       	mov.b	#2,	r14	;r3 As==10

000071d2 <.L277>:
  uint8_t err = buffer[hdr_ext];
    71d2:	40 18 0e 4e 	movx.w	r14,	r14	;
    71d6:	ee 0c       	adda	r12,	r14	;

000071d8 <.LVL287>:
    71d8:	67 4e       	mov.b	@r14,	r7	;

000071da <.LVL288>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    71da:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000071de <.LVL289>:
    71de:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000071e2 <.LVL290>:
  if (err > ELY_ALL_ERRORS) {
    71e2:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    71e6:	4c 97       	cmp.b	r7,	r12	;
    71e8:	16 2c       	jc	$+46     	;abs 0x7216

000071ea <.Loc.1191.2>:
    if (hdr.reply) {
    71ea:	09 93       	cmp	#0,	r9	;r3 As==00
    71ec:	0e 24       	jz	$+30     	;abs 0x720a

000071ee <.Loc.1193.2>:
      gen_failure(hdr);
    71ee:	81 4a 00 00 	mov	r10,	0(r1)	;
    71f2:	81 48 02 00 	mov	r8,	2(r1)	;
    71f6:	cc 01       	mova	r1,	r12	;
    71f8:	b0 13 c2 6f 	calla	#28610		;0x06fc2

000071fc <.L276>:
}
    71fc:	a1 00 04 00 	adda	#4,	r1	;
    7200:	37 16       	popm.a	#4,	r10	;20-bit words
    7202:	10 01       	reta			;

00007204 <.L281>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7204:	6e 42       	mov.b	#4,	r14	;r2 As==10
    7206:	80 00 d2 71 	mova	#29138,	r0	;0x071d2

0000720a <.L279>:
      elyErrorSignal(ErrCmdFailure);
    720a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    720e:	b0 13 ca 94 	calla	#38090		;0x094ca

00007212 <.LVL296>:
    7212:	80 00 fc 71 	mova	#29180,	r0	;0x071fc

00007216 <.L278>:
  bank0w[RegErrLogLvl] = err;
    7216:	2c 01 ac 05 	mova	&66988,	r12	;0x105ac
    721a:	cc 47 4d 00 	mov.b	r7,	77(r12)	; 0x004d

0000721e <.Loc.1203.2>:
  chSysLock();
    721e:	b0 13 e6 65 	calla	#26086		;0x065e6

00007222 <.LVL297>:
  elyErrorSetLogLvlS(err);
    7222:	4c 47       	mov.b	r7,	r12	;
    7224:	b0 13 ce 94 	calla	#38094		;0x094ce

00007228 <.LVL298>:
  chSysUnlock();
    7228:	b0 13 ee 65 	calla	#26094		;0x065ee

0000722c <.LVL299>:
  if (hdr.reply) {
    722c:	09 93       	cmp	#0,	r9	;r3 As==00
    722e:	e6 27       	jz	$-50     	;abs 0x71fc

00007230 <.Loc.1209.2>:
    gen_success(hdr);
    7230:	81 4a 00 00 	mov	r10,	0(r1)	;
    7234:	81 48 02 00 	mov	r8,	2(r1)	;
    7238:	cc 01       	mova	r1,	r12	;
    723a:	b0 13 7c 6c 	calla	#27772		;0x06c7c

0000723e <.LVL301>:
    723e:	80 00 fc 71 	mova	#29180,	r0	;0x071fc

00007242 <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7242:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007244 <.LCFI37>:
    7244:	b1 00 04 00 	suba	#4,	r1	;

00007248 <.LCFI38>:
    7248:	2a 4d       	mov	@r13,	r10	;

0000724a <.LVL303>:
    724a:	18 4d 02 00 	mov	2(r13),	r8	;

0000724e <.LVL304>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    724e:	49 4a       	mov.b	r10,	r9	;
    7250:	69 f3       	and.b	#2,	r9	;r3 As==10
    7252:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7256:	09 93       	cmp	#0,	r9	;r3 As==00
    7258:	1a 20       	jnz	$+54     	;abs 0x728e
    725a:	6e 43       	mov.b	#2,	r14	;r3 As==10

0000725c <.L286>:
  uint8_t err = buffer[hdr_ext];
    725c:	40 18 0e 4e 	movx.w	r14,	r14	;
    7260:	ee 0c       	adda	r12,	r14	;

00007262 <.LVL306>:
    7262:	67 4e       	mov.b	@r14,	r7	;

00007264 <.LVL307>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7264:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007268 <.LVL308>:
    7268:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000726c <.LVL309>:
  if (err > ELY_ALL_ERRORS) {
    726c:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    7270:	4c 97       	cmp.b	r7,	r12	;
    7272:	16 2c       	jc	$+46     	;abs 0x72a0

00007274 <.Loc.1132.2>:
    if (hdr.reply) {
    7274:	09 93       	cmp	#0,	r9	;r3 As==00
    7276:	0e 24       	jz	$+30     	;abs 0x7294

00007278 <.Loc.1134.2>:
      gen_failure(hdr);
    7278:	81 4a 00 00 	mov	r10,	0(r1)	;
    727c:	81 48 02 00 	mov	r8,	2(r1)	;
    7280:	cc 01       	mova	r1,	r12	;
    7282:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007286 <.L285>:
}
    7286:	a1 00 04 00 	adda	#4,	r1	;
    728a:	37 16       	popm.a	#4,	r10	;20-bit words
    728c:	10 01       	reta			;

0000728e <.L290>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    728e:	6e 42       	mov.b	#4,	r14	;r2 As==10
    7290:	80 00 5c 72 	mova	#29276,	r0	;0x0725c

00007294 <.L288>:
      elyErrorSignal(ErrCmdFailure);
    7294:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7298:	b0 13 ca 94 	calla	#38090		;0x094ca

0000729c <.LVL315>:
    729c:	80 00 86 72 	mova	#29318,	r0	;0x07286

000072a0 <.L287>:
  bank0w[RegErrRptLvl] = err;
    72a0:	2c 01 ac 05 	mova	&66988,	r12	;0x105ac
    72a4:	cc 47 4c 00 	mov.b	r7,	76(r12)	; 0x004c

000072a8 <.Loc.1144.2>:
  chSysLock();
    72a8:	b0 13 e6 65 	calla	#26086		;0x065e6

000072ac <.LVL316>:
  elyErrorSetRptLvlS(err);
    72ac:	4c 47       	mov.b	r7,	r12	;
    72ae:	b0 13 cc 94 	calla	#38092		;0x094cc

000072b2 <.LVL317>:
  chSysUnlock();
    72b2:	b0 13 ee 65 	calla	#26094		;0x065ee

000072b6 <.LVL318>:
  if (hdr.reply) {
    72b6:	09 93       	cmp	#0,	r9	;r3 As==00
    72b8:	e6 27       	jz	$-50     	;abs 0x7286

000072ba <.Loc.1150.2>:
    gen_success(hdr);
    72ba:	81 4a 00 00 	mov	r10,	0(r1)	;
    72be:	81 48 02 00 	mov	r8,	2(r1)	;
    72c2:	cc 01       	mova	r1,	r12	;
    72c4:	b0 13 7c 6c 	calla	#27772		;0x06c7c

000072c8 <.LVL320>:
    72c8:	80 00 86 72 	mova	#29318,	r0	;0x07286

000072cc <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    72cc:	6a 14       	pushm.a	#7,	r10	;20-bit words

000072ce <.LCFI39>:
    72ce:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

000072d2 <.LCFI40>:
    72d2:	c8 0c       	mova	r12,	r8	;
    72d4:	29 4d       	mov	@r13,	r9	;

000072d6 <.LVL322>:
    72d6:	14 4d 02 00 	mov	2(r13),	r4	;

000072da <.LVL323>:
    72da:	07 49       	mov	r9,	r7	;
    72dc:	57 0f       	rrum	#4,	r7	;
    72de:	57 0f       	rrum	#4,	r7	;

000072e0 <.Loc.991.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    72e0:	4c 49       	mov.b	r9,	r12	;

000072e2 <.LVL325>:
    72e2:	1c b3       	bit	#1,	r12	;r3 As==01
    72e4:	2b 20       	jnz	$+88     	;abs 0x733c
    72e6:	4e 43       	clr.b	r14		;

000072e8 <.L295>:
    72e8:	6c f3       	and.b	#2,	r12	;r3 As==10
    72ea:	45 4c       	mov.b	r12,	r5	;
    72ec:	40 18 4d 47 	movx.b	r7,	r13	;
    72f0:	40 18 4d 8c 	subx.b	r12,	r13	;
    72f4:	4d 8e       	sub.b	r14,	r13	;
    72f6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000072fa <.LVL326>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    72fa:	05 93       	cmp	#0,	r5	;r3 As==00
    72fc:	22 20       	jnz	$+70     	;abs 0x7342

000072fe <.Loc.992.2>:
    72fe:	6a 43       	mov.b	#2,	r10	;r3 As==10

00007300 <.L296>:
    7300:	40 18 0e 4a 	movx.w	r10,	r14	;
    7304:	ee 08       	adda	r8,	r14	;

00007306 <.LBB44>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7306:	c6 0e       	mova	r14,	r6	;
    7308:	0c 4a       	mov	r10,	r12	;
    730a:	0d 5a       	add	r10,	r13	;

0000730c <.L297>:
    730c:	0c 9d       	cmp	r13,	r12	;
    730e:	1c 38       	jl	$+58     	;abs 0x7348

00007310 <.LBB45>:
    elyEventUnlog(buffer[i]);
    7310:	86 00 d8 94 	mova	#38104,	r6	;0x094d8

00007314 <.L303>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7314:	0a 9d       	cmp	r13,	r10	;
    7316:	41 38       	jl	$+132    	;abs 0x739a

00007318 <.LBE45>:
  if (hdr.reply) {
    7318:	05 93       	cmp	#0,	r5	;r3 As==00
    731a:	2d 24       	jz	$+92     	;abs 0x7376

0000731c <.Loc.1015.2>:
    gen_success(hdr);
    731c:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    7320:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007324 <.LVL331>:
    7324:	09 d7       	bis	r7,	r9	;
    7326:	81 49 08 00 	mov	r9,	8(r1)	;
    732a:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    732e:	cc 01       	mova	r1,	r12	;
    7330:	ac 00 08 00 	adda	#8,	r12	;
    7334:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007338 <.LVL332>:
    7338:	80 00 76 73 	mova	#29558,	r0	;0x07376

0000733c <.L306>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    733c:	6e 43       	mov.b	#2,	r14	;r3 As==10
    733e:	80 00 e8 72 	mova	#29416,	r0	;0x072e8

00007342 <.L307>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7342:	6a 42       	mov.b	#4,	r10	;r2 As==10
    7344:	80 00 00 73 	mova	#29440,	r0	;0x07300

00007348 <.L302>:
    7348:	a6 00 01 00 	adda	#1,	r6	;

0000734c <.LBB46>:
    if (buffer[i] < 0xC0) {
    734c:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    7350:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    7354:	1f 28       	jnc	$+64     	;abs 0x7394

00007356 <.Loc.997.2>:
      if (hdr.reply) {
    7356:	05 93       	cmp	#0,	r5	;r3 As==00
    7358:	17 24       	jz	$+48     	;abs 0x7388

0000735a <.Loc.999.2>:
        gen_failure(hdr);
    735a:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    735e:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007362 <.LVL337>:
    7362:	09 d7       	bis	r7,	r9	;
    7364:	81 49 08 00 	mov	r9,	8(r1)	;
    7368:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    736c:	cc 01       	mova	r1,	r12	;

0000736e <.LVL338>:
    736e:	ac 00 08 00 	adda	#8,	r12	;
    7372:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007376 <.L305>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7376:	cc 08       	mova	r8,	r12	;
    7378:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000737c <.LVL340>:
    737c:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007380 <.LVL341>:
}
    7380:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    7384:	64 16       	popm.a	#7,	r10	;20-bit words
    7386:	10 01       	reta			;

00007388 <.L299>:
        elyErrorSignal(ErrCmdFailure);
    7388:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

0000738c <.LVL343>:
    738c:	b0 13 ca 94 	calla	#38090		;0x094ca

00007390 <.LVL344>:
    7390:	80 00 76 73 	mova	#29558,	r0	;0x07376

00007394 <.L298>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7394:	1c 53       	inc	r12		;
    7396:	80 00 0c 73 	mova	#29452,	r0	;0x0730c

0000739a <.L304>:
    elyEventUnlog(buffer[i]);
    739a:	6c 4e       	mov.b	@r14,	r12	;
    739c:	71 0d 00 00 	mova	r13,	0(r1)	;
    73a0:	71 0e 04 00 	mova	r14,	4(r1)	;
    73a4:	46 13       	calla	r6		;

000073a6 <.LVL348>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73a6:	1a 53       	inc	r10		;
    73a8:	3e 01 04 00 	mova	4(r1),	r14	;
    73ac:	ae 00 01 00 	adda	#1,	r14	;
    73b0:	0d 01       	mova	@r1,	r13	;
    73b2:	80 00 14 73 	mova	#29460,	r0	;0x07314

000073b6 <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    73b6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000073b8 <.LCFI41>:
    73b8:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000073bc <.LCFI42>:
    73bc:	c8 0c       	mova	r12,	r8	;
    73be:	29 4d       	mov	@r13,	r9	;

000073c0 <.LVL351>:
    73c0:	1b 4d 02 00 	mov	2(r13),	r11	;

000073c4 <.LVL352>:
    73c4:	07 49       	mov	r9,	r7	;
    73c6:	57 0f       	rrum	#4,	r7	;
    73c8:	57 0f       	rrum	#4,	r7	;

000073ca <.Loc.957.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    73ca:	4c 49       	mov.b	r9,	r12	;

000073cc <.LVL354>:
    73cc:	1c b3       	bit	#1,	r12	;r3 As==01
    73ce:	2b 20       	jnz	$+88     	;abs 0x7426
    73d0:	4e 43       	clr.b	r14		;

000073d2 <.L312>:
    73d2:	6c f3       	and.b	#2,	r12	;r3 As==10
    73d4:	45 4c       	mov.b	r12,	r5	;
    73d6:	40 18 4d 47 	movx.b	r7,	r13	;
    73da:	40 18 4d 8c 	subx.b	r12,	r13	;
    73de:	4d 8e       	sub.b	r14,	r13	;
    73e0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000073e4 <.LVL355>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    73e4:	05 93       	cmp	#0,	r5	;r3 As==00
    73e6:	22 20       	jnz	$+70     	;abs 0x742c

000073e8 <.Loc.958.2>:
    73e8:	6a 43       	mov.b	#2,	r10	;r3 As==10

000073ea <.L313>:
    73ea:	40 18 04 4a 	movx.w	r10,	r4	;
    73ee:	e4 08       	adda	r8,	r4	;

000073f0 <.LBB49>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73f0:	c6 04       	mova	r4,	r6	;
    73f2:	0e 4a       	mov	r10,	r14	;
    73f4:	0d 5a       	add	r10,	r13	;

000073f6 <.L314>:
    73f6:	0e 9d       	cmp	r13,	r14	;
    73f8:	1c 38       	jl	$+58     	;abs 0x7432

000073fa <.LBB50>:
    elyEventLog(buffer[i]);
    73fa:	86 00 d6 94 	mova	#38102,	r6	;0x094d6

000073fe <.L321>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    73fe:	0a 9d       	cmp	r13,	r10	;
    7400:	55 38       	jl	$+172    	;abs 0x74ac

00007402 <.LBE50>:
  if (hdr.reply) {
    7402:	05 93       	cmp	#0,	r5	;r3 As==00
    7404:	41 24       	jz	$+132    	;abs 0x7488

00007406 <.Loc.983.2>:
    gen_success(hdr);
    7406:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    740a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000740e <.LVL360>:
    740e:	09 d7       	bis	r7,	r9	;
    7410:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7414:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    7418:	cc 01       	mova	r1,	r12	;
    741a:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    741e:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007422 <.LVL361>:
    7422:	80 00 88 74 	mova	#29832,	r0	;0x07488

00007426 <.L324>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7426:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7428:	80 00 d2 73 	mova	#29650,	r0	;0x073d2

0000742c <.L325>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    742c:	6a 42       	mov.b	#4,	r10	;r2 As==10
    742e:	80 00 ea 73 	mova	#29674,	r0	;0x073ea

00007432 <.L320>:
    if ((buffer[i] < 0xC0) || 
    7432:	6c 46       	mov.b	@r6,	r12	;
    7434:	4f 4c       	mov.b	r12,	r15	;
    7436:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    743a:	c1 4f 01 00 	mov.b	r15,	1(r1)	;
    743e:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    7442:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    7446:	10 28       	jnc	$+34     	;abs 0x7468

00007448 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7448:	4f 4c       	mov.b	r12,	r15	;
    744a:	7f 50 2d 00 	add.b	#45,	r15	;#0x002d
    744e:	c1 4f 01 00 	mov.b	r15,	1(r1)	;

00007452 <.Loc.961.2>:
    if ((buffer[i] < 0xC0) || 
    7452:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    7456:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    745a:	06 2c       	jc	$+14     	;abs 0x7468
    745c:	a6 00 01 00 	adda	#1,	r6	;

00007460 <.Loc.963.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7460:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

00007464 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7464:	4f 9c       	cmp.b	r12,	r15	;
    7466:	1f 28       	jnc	$+64     	;abs 0x74a6

00007468 <.L315>:
      if (hdr.reply) {
    7468:	05 93       	cmp	#0,	r5	;r3 As==00
    746a:	17 24       	jz	$+48     	;abs 0x749a

0000746c <.Loc.967.2>:
        gen_failure(hdr);
    746c:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    7470:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007474 <.LVL366>:
    7474:	09 d7       	bis	r7,	r9	;
    7476:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    747a:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    747e:	cc 01       	mova	r1,	r12	;
    7480:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    7484:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007488 <.L323>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7488:	cc 08       	mova	r8,	r12	;
    748a:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000748e <.LVL368>:
    748e:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007492 <.LVL369>:
}
    7492:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    7496:	64 16       	popm.a	#7,	r10	;20-bit words
    7498:	10 01       	reta			;

0000749a <.L317>:
        elyErrorSignal(ErrCmdFailure);
    749a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    749e:	b0 13 ca 94 	calla	#38090		;0x094ca

000074a2 <.LVL371>:
    74a2:	80 00 88 74 	mova	#29832,	r0	;0x07488

000074a6 <.L316>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    74a6:	1e 53       	inc	r14		;
    74a8:	80 00 f6 73 	mova	#29686,	r0	;0x073f6

000074ac <.L322>:
    elyEventLog(buffer[i]);
    74ac:	6c 44       	mov.b	@r4,	r12	;
    74ae:	71 0b 02 00 	mova	r11,	2(r1)	;
    74b2:	71 0d 06 00 	mova	r13,	6(r1)	;
    74b6:	46 13       	calla	r6		;

000074b8 <.LVL375>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    74b8:	1a 53       	inc	r10		;
    74ba:	a4 00 01 00 	adda	#1,	r4	;
    74be:	3d 01 06 00 	mova	6(r1),	r13	;
    74c2:	3b 01 02 00 	mova	2(r1),	r11	;
    74c6:	80 00 fe 73 	mova	#29694,	r0	;0x073fe

000074ca <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    74ca:	6a 14       	pushm.a	#7,	r10	;20-bit words

000074cc <.LCFI43>:
    74cc:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

000074d0 <.LCFI44>:
    74d0:	c8 0c       	mova	r12,	r8	;
    74d2:	29 4d       	mov	@r13,	r9	;

000074d4 <.LVL378>:
    74d4:	14 4d 02 00 	mov	2(r13),	r4	;

000074d8 <.LVL379>:
    74d8:	07 49       	mov	r9,	r7	;
    74da:	57 0f       	rrum	#4,	r7	;
    74dc:	57 0f       	rrum	#4,	r7	;

000074de <.Loc.926.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    74de:	4c 49       	mov.b	r9,	r12	;

000074e0 <.LVL381>:
    74e0:	1c b3       	bit	#1,	r12	;r3 As==01
    74e2:	2b 20       	jnz	$+88     	;abs 0x753a
    74e4:	4e 43       	clr.b	r14		;

000074e6 <.L330>:
    74e6:	6c f3       	and.b	#2,	r12	;r3 As==10
    74e8:	45 4c       	mov.b	r12,	r5	;
    74ea:	40 18 4d 47 	movx.b	r7,	r13	;
    74ee:	40 18 4d 8c 	subx.b	r12,	r13	;
    74f2:	4d 8e       	sub.b	r14,	r13	;
    74f4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000074f8 <.LVL382>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    74f8:	05 93       	cmp	#0,	r5	;r3 As==00
    74fa:	22 20       	jnz	$+70     	;abs 0x7540

000074fc <.Loc.927.2>:
    74fc:	6a 43       	mov.b	#2,	r10	;r3 As==10

000074fe <.L331>:
    74fe:	40 18 0e 4a 	movx.w	r10,	r14	;
    7502:	ee 08       	adda	r8,	r14	;

00007504 <.LBB54>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7504:	c6 0e       	mova	r14,	r6	;
    7506:	0c 4a       	mov	r10,	r12	;
    7508:	0d 5a       	add	r10,	r13	;

0000750a <.L332>:
    750a:	0c 9d       	cmp	r13,	r12	;
    750c:	1c 38       	jl	$+58     	;abs 0x7546

0000750e <.LBB55>:
    elyEventUnsubscribe(buffer[i]);
    750e:	86 00 d4 94 	mova	#38100,	r6	;0x094d4

00007512 <.L338>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7512:	0a 9d       	cmp	r13,	r10	;
    7514:	41 38       	jl	$+132    	;abs 0x7598

00007516 <.LBE55>:
  if (hdr.reply) {
    7516:	05 93       	cmp	#0,	r5	;r3 As==00
    7518:	2d 24       	jz	$+92     	;abs 0x7574

0000751a <.Loc.949.2>:
    gen_success(hdr);
    751a:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    751e:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007522 <.LVL387>:
    7522:	09 d7       	bis	r7,	r9	;
    7524:	81 49 08 00 	mov	r9,	8(r1)	;
    7528:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    752c:	cc 01       	mova	r1,	r12	;
    752e:	ac 00 08 00 	adda	#8,	r12	;
    7532:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007536 <.LVL388>:
    7536:	80 00 74 75 	mova	#30068,	r0	;0x07574

0000753a <.L341>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    753a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    753c:	80 00 e6 74 	mova	#29926,	r0	;0x074e6

00007540 <.L342>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7540:	6a 42       	mov.b	#4,	r10	;r2 As==10
    7542:	80 00 fe 74 	mova	#29950,	r0	;0x074fe

00007546 <.L337>:
    7546:	a6 00 01 00 	adda	#1,	r6	;

0000754a <.LBB56>:
    if (buffer[i] < 0xC0) {
    754a:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    754e:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    7552:	1f 28       	jnc	$+64     	;abs 0x7592

00007554 <.Loc.931.2>:
      if (hdr.reply) {
    7554:	05 93       	cmp	#0,	r5	;r3 As==00
    7556:	17 24       	jz	$+48     	;abs 0x7586

00007558 <.Loc.933.2>:
        gen_failure(hdr);
    7558:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    755c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007560 <.LVL393>:
    7560:	09 d7       	bis	r7,	r9	;
    7562:	81 49 08 00 	mov	r9,	8(r1)	;
    7566:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    756a:	cc 01       	mova	r1,	r12	;

0000756c <.LVL394>:
    756c:	ac 00 08 00 	adda	#8,	r12	;
    7570:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007574 <.L340>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7574:	cc 08       	mova	r8,	r12	;
    7576:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000757a <.LVL396>:
    757a:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000757e <.LVL397>:
}
    757e:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    7582:	64 16       	popm.a	#7,	r10	;20-bit words
    7584:	10 01       	reta			;

00007586 <.L334>:
        elyErrorSignal(ErrCmdFailure);
    7586:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

0000758a <.LVL399>:
    758a:	b0 13 ca 94 	calla	#38090		;0x094ca

0000758e <.LVL400>:
    758e:	80 00 74 75 	mova	#30068,	r0	;0x07574

00007592 <.L333>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7592:	1c 53       	inc	r12		;
    7594:	80 00 0a 75 	mova	#29962,	r0	;0x0750a

00007598 <.L339>:
    elyEventUnsubscribe(buffer[i]);
    7598:	6c 4e       	mov.b	@r14,	r12	;
    759a:	71 0d 00 00 	mova	r13,	0(r1)	;
    759e:	71 0e 04 00 	mova	r14,	4(r1)	;
    75a2:	46 13       	calla	r6		;

000075a4 <.LVL404>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    75a4:	1a 53       	inc	r10		;
    75a6:	3e 01 04 00 	mova	4(r1),	r14	;
    75aa:	ae 00 01 00 	adda	#1,	r14	;
    75ae:	0d 01       	mova	@r1,	r13	;
    75b0:	80 00 12 75 	mova	#29970,	r0	;0x07512

000075b4 <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    75b4:	6a 14       	pushm.a	#7,	r10	;20-bit words

000075b6 <.LCFI45>:
    75b6:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000075ba <.LCFI46>:
    75ba:	c4 0c       	mova	r12,	r4	;
    75bc:	29 4d       	mov	@r13,	r9	;

000075be <.LVL407>:
    75be:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    75c2:	08 00 
    75c4:	06 49       	mov	r9,	r6	;
    75c6:	56 0f       	rrum	#4,	r6	;
    75c8:	56 0f       	rrum	#4,	r6	;

000075ca <.Loc.883.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    75ca:	4c 49       	mov.b	r9,	r12	;

000075cc <.LVL409>:
    75cc:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    75d0:	36 24       	jz	$+110    	;abs 0x763e
    75d2:	6d 43       	mov.b	#2,	r13	;r3 As==10

000075d4 <.L347>:
    75d4:	6c f3       	and.b	#2,	r12	;r3 As==10
    75d6:	4e 4c       	mov.b	r12,	r14	;
    75d8:	40 18 47 46 	movx.b	r6,	r7	;
    75dc:	40 18 47 8c 	subx.b	r12,	r7	;
    75e0:	47 8d       	sub.b	r13,	r7	;
    75e2:	37 f0 ff 00 	and	#255,	r7	;#0x00ff

000075e6 <.LVL410>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    75e6:	0e 93       	cmp	#0,	r14	;r3 As==00
    75e8:	2d 24       	jz	$+92     	;abs 0x7644

000075ea <.Loc.884.2>:
    75ea:	6a 42       	mov.b	#4,	r10	;r2 As==10

000075ec <.L348>:
    75ec:	40 18 0c 4a 	movx.w	r10,	r12	;
    75f0:	cb 04       	mova	r4,	r11	;
    75f2:	eb 0c       	adda	r12,	r11	;

000075f4 <.LBB59>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    75f4:	c8 0b       	mova	r11,	r8	;
    75f6:	0d 4a       	mov	r10,	r13	;
    75f8:	07 5a       	add	r10,	r7	;

000075fa <.L349>:
    75fa:	0d 97       	cmp	r7,	r13	;
    75fc:	26 38       	jl	$+78     	;abs 0x764a

000075fe <.LBE59>:
  if (hdr.reply) {
    75fe:	0e 93       	cmp	#0,	r14	;r3 As==00
    7600:	5b 24       	jz	$+184    	;abs 0x76b8

00007602 <.Loc.905.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    7602:	55 44 02 00 	mov.b	2(r4),	r5	;
    7606:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    760a:	5c 44 03 00 	mov.b	3(r4),	r12	;

0000760e <.L366>:
    760e:	05 dc       	bis	r12,	r5	;

00007610 <.LBB60>:
      elyEventSubscribe(buffer[i], addr);
    7610:	88 00 d2 94 	mova	#38098,	r8	;0x094d2

00007614 <.L358>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7614:	0a 97       	cmp	r7,	r10	;
    7616:	5a 38       	jl	$+182    	;abs 0x76cc

00007618 <.LBE60>:
  if (hdr.reply) {
    7618:	0e 93       	cmp	#0,	r14	;r3 As==00
    761a:	3c 24       	jz	$+122    	;abs 0x7694

0000761c <.Loc.918.2>:
    gen_success(hdr);
    761c:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    7620:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007624 <.LVL416>:
    7624:	09 d6       	bis	r6,	r9	;
    7626:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    762a:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    762e:	0c 00 
    7630:	cc 01       	mova	r1,	r12	;
    7632:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    7636:	b0 13 7c 6c 	calla	#27772		;0x06c7c

0000763a <.LVL417>:
    763a:	80 00 94 76 	mova	#30356,	r0	;0x07694

0000763e <.L361>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    763e:	4d 43       	clr.b	r13		;
    7640:	80 00 d4 75 	mova	#30164,	r0	;0x075d4

00007644 <.L362>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7644:	6a 43       	mov.b	#2,	r10	;r3 As==10
    7646:	80 00 ec 75 	mova	#30188,	r0	;0x075ec

0000764a <.L355>:
    if ((buffer[i] < 0xC0) || 
    764a:	6c 48       	mov.b	@r8,	r12	;
    764c:	4f 4c       	mov.b	r12,	r15	;
    764e:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    7652:	75 40 32 00 	mov.b	#50,	r5	;#0x0032
    7656:	45 9f       	cmp.b	r15,	r5	;
    7658:	0c 28       	jnc	$+26     	;abs 0x7672

0000765a <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    765a:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

0000765e <.Loc.887.2>:
    if ((buffer[i] < 0xC0) || 
    765e:	75 40 0c 00 	mov.b	#12,	r5	;#0x000c
    7662:	45 9f       	cmp.b	r15,	r5	;
    7664:	06 2c       	jc	$+14     	;abs 0x7672
    7666:	a8 00 01 00 	adda	#1,	r8	;

0000766a <.Loc.889.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    766a:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

0000766e <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    766e:	45 9c       	cmp.b	r12,	r5	;
    7670:	20 28       	jnc	$+66     	;abs 0x76b2

00007672 <.L350>:
      if (hdr.reply) {
    7672:	0e 93       	cmp	#0,	r14	;r3 As==00
    7674:	18 24       	jz	$+50     	;abs 0x76a6

00007676 <.Loc.893.2>:
        gen_failure(hdr);
    7676:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    767a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000767e <.LVL422>:
    767e:	09 d6       	bis	r6,	r9	;
    7680:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    7684:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    7688:	0c 00 
    768a:	cc 01       	mova	r1,	r12	;
    768c:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    7690:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007694 <.L360>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7694:	cc 04       	mova	r4,	r12	;
    7696:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000769a <.LVL424>:
    769a:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000769e <.LVL425>:
}
    769e:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    76a2:	64 16       	popm.a	#7,	r10	;20-bit words
    76a4:	10 01       	reta			;

000076a6 <.L352>:
        elyErrorSignal(ErrCmdFailure);
    76a6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    76aa:	b0 13 ca 94 	calla	#38090		;0x094ca

000076ae <.LVL427>:
    76ae:	80 00 94 76 	mova	#30356,	r0	;0x07694

000076b2 <.L351>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    76b2:	1d 53       	inc	r13		;
    76b4:	80 00 fa 75 	mova	#30202,	r0	;0x075fa

000076b8 <.L356>:
    76b8:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    76bc:	55 4c 55 00 	mov.b	85(r12),r5	;0x00055
    76c0:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    76c4:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    76c8:	80 00 0e 76 	mova	#30222,	r0	;0x0760e

000076cc <.L359>:
      elyEventSubscribe(buffer[i], addr);
    76cc:	0d 45       	mov	r5,	r13	;
    76ce:	6c 4b       	mov.b	@r11,	r12	;
    76d0:	71 0b 00 00 	mova	r11,	0(r1)	;
    76d4:	71 0e 04 00 	mova	r14,	4(r1)	;
    76d8:	48 13       	calla	r8		;

000076da <.LVL431>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    76da:	1a 53       	inc	r10		;
    76dc:	0b 01       	mova	@r1,	r11	;
    76de:	ab 00 01 00 	adda	#1,	r11	;
    76e2:	3e 01 04 00 	mova	4(r1),	r14	;
    76e6:	80 00 14 76 	mova	#30228,	r0	;0x07614

000076ea <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    76ea:	6a 14       	pushm.a	#7,	r10	;20-bit words

000076ec <.LCFI47>:
    76ec:	b1 00 06 00 	suba	#6,	r1	;

000076f0 <.LCFI48>:
    76f0:	c6 0c       	mova	r12,	r6	;
    76f2:	29 4d       	mov	@r13,	r9	;

000076f4 <.LVL434>:
    76f4:	17 4d 02 00 	mov	2(r13),	r7	;

000076f8 <.LVL435>:
    76f8:	0a 49       	mov	r9,	r10	;
    76fa:	5a 0f       	rrum	#4,	r10	;
    76fc:	5a 0f       	rrum	#4,	r10	;

000076fe <.Loc.796.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    76fe:	4e 49       	mov.b	r9,	r14	;
    7700:	04 4e       	mov	r14,	r4	;
    7702:	54 f3       	and.b	#1,	r4	;r3 As==01
    7704:	04 93       	cmp	#0,	r4	;r3 As==00
    7706:	30 20       	jnz	$+98     	;abs 0x7768
    7708:	0d 44       	mov	r4,	r13	;

0000770a <.L368>:
    770a:	6e f3       	and.b	#2,	r14	;r3 As==10
    770c:	48 4e       	mov.b	r14,	r8	;

0000770e <.LVL437>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    770e:	08 93       	cmp	#0,	r8	;r3 As==00
    7710:	2e 20       	jnz	$+94     	;abs 0x776e

00007712 <.Loc.797.2>:
    7712:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007714 <.L369>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7714:	0f 4c       	mov	r12,	r15	;

00007716 <.LVL439>:
    7716:	05 4a       	mov	r10,	r5	;
    7718:	05 5c       	add	r12,	r5	;
    771a:	04 93       	cmp	#0,	r4	;r3 As==00
    771c:	01 24       	jz	$+4      	;abs 0x7720
    771e:	64 43       	mov.b	#2,	r4	;r3 As==10

00007720 <.L371>:
    7720:	05 84       	sub	r4,	r5	;
    7722:	81 45 00 00 	mov	r5,	0(r1)	;
    7726:	40 18 04 4c 	movx.w	r12,	r4	;
    772a:	e4 06       	adda	r6,	r4	;
    772c:	cc 04       	mova	r4,	r12	;

0000772e <.L372>:
    772e:	2f 91       	cmp	@r1,	r15	;
    7730:	21 38       	jl	$+68     	;abs 0x7774

00007732 <.LBE64>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7732:	40 18 4c 4a 	movx.b	r10,	r12	;
    7736:	40 18 4c 8e 	subx.b	r14,	r12	;

0000773a <.Loc.813.2>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    773a:	4c 8d       	sub.b	r13,	r12	;
    773c:	4d 4c       	mov.b	r12,	r13	;

0000773e <.LVL441>:
    773e:	cc 04       	mova	r4,	r12	;
    7740:	b0 13 e2 94 	calla	#38114		;0x094e2

00007744 <.LVL442>:
  if (hdr.reply) {
    7744:	08 93       	cmp	#0,	r8	;r3 As==00
    7746:	2f 24       	jz	$+96     	;abs 0x77a6

00007748 <.Loc.817.2>:
    gen_success(hdr);
    7748:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;
    774c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007750 <.LVL444>:
    7750:	09 da       	bis	r10,	r9	;
    7752:	81 49 02 00 	mov	r9,	2(r1)	;
    7756:	81 47 04 00 	mov	r7,	4(r1)	;
    775a:	cc 01       	mova	r1,	r12	;
    775c:	ac 00 02 00 	adda	#2,	r12	;
    7760:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007764 <.LVL445>:
    7764:	80 00 a6 77 	mova	#30630,	r0	;0x077a6

00007768 <.L379>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7768:	6d 43       	mov.b	#2,	r13	;r3 As==10
    776a:	80 00 0a 77 	mova	#30474,	r0	;0x0770a

0000776e <.L380>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    776e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7770:	80 00 14 77 	mova	#30484,	r0	;0x07714

00007774 <.L377>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7774:	6b 4c       	mov.b	@r12,	r11	;
    7776:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    777a:	ac 00 01 00 	adda	#1,	r12	;
    777e:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    7782:	45 9b       	cmp.b	r11,	r5	;
    7784:	1f 2c       	jc	$+64     	;abs 0x77c4

00007786 <.Loc.801.2>:
      if (hdr.reply) {
    7786:	08 93       	cmp	#0,	r8	;r3 As==00
    7788:	17 24       	jz	$+48     	;abs 0x77b8

0000778a <.Loc.803.2>:
        gen_failure(hdr);
    778a:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;

0000778e <.LVL449>:
    778e:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00007792 <.LVL450>:
    7792:	09 da       	bis	r10,	r9	;
    7794:	81 49 02 00 	mov	r9,	2(r1)	;
    7798:	81 47 04 00 	mov	r7,	4(r1)	;
    779c:	cc 01       	mova	r1,	r12	;
    779e:	ac 00 02 00 	adda	#2,	r12	;
    77a2:	b0 13 c2 6f 	calla	#28610		;0x06fc2

000077a6 <.L378>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    77a6:	cc 06       	mova	r6,	r12	;
    77a8:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000077ac <.LVL452>:
    77ac:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000077b0 <.LVL453>:
}
    77b0:	a1 00 06 00 	adda	#6,	r1	;
    77b4:	64 16       	popm.a	#7,	r10	;20-bit words
    77b6:	10 01       	reta			;

000077b8 <.L374>:
        elyErrorSignal(ErrCmdFailure);
    77b8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    77bc:	b0 13 ca 94 	calla	#38090		;0x094ca

000077c0 <.LVL455>:
    77c0:	80 00 a6 77 	mova	#30630,	r0	;0x077a6

000077c4 <.L373>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    77c4:	1f 53       	inc	r15		;
    77c6:	80 00 2e 77 	mova	#30510,	r0	;0x0772e

000077ca <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    77ca:	6a 14       	pushm.a	#7,	r10	;20-bit words

000077cc <.LCFI49>:
    77cc:	b1 00 14 00 	suba	#20,	r1	;0x00014

000077d0 <.LCFI50>:
    77d0:	c8 0c       	mova	r12,	r8	;
    77d2:	27 4d       	mov	@r13,	r7	;

000077d4 <.LVL459>:
    77d4:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    77d8:	08 00 
    77da:	09 47       	mov	r7,	r9	;
    77dc:	59 0f       	rrum	#4,	r9	;
    77de:	59 0f       	rrum	#4,	r9	;

000077e0 <.Loc.755.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    77e0:	4c 47       	mov.b	r7,	r12	;

000077e2 <.LVL461>:
    77e2:	1c b3       	bit	#1,	r12	;r3 As==01
    77e4:	66 20       	jnz	$+206    	;abs 0x78b2
    77e6:	4d 43       	clr.b	r13		;

000077e8 <.L385>:
    77e8:	6c f3       	and.b	#2,	r12	;r3 As==10
    77ea:	45 4c       	mov.b	r12,	r5	;
    77ec:	81 45 04 00 	mov	r5,	4(r1)	;
    77f0:	40 18 4e 49 	movx.b	r9,	r14	;
    77f4:	40 18 4e 8c 	subx.b	r12,	r14	;
    77f8:	4e 8d       	sub.b	r13,	r14	;
    77fa:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    77fe:	4f 4e       	mov.b	r14,	r15	;

00007800 <.LVL462>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7800:	05 93       	cmp	#0,	r5	;r3 As==00
    7802:	5a 20       	jnz	$+182    	;abs 0x78b8

00007804 <.Loc.756.2>:
    7804:	6a 43       	mov.b	#2,	r10	;r3 As==10

00007806 <.L386>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7806:	0e 4a       	mov	r10,	r14	;

00007808 <.LVL464>:
    7808:	2e 52       	add	#4,	r14	;r2 As==10

0000780a <.LVL465>:
    780a:	06 4e       	mov	r14,	r6	;
    780c:	46 0e       	rlam.a	#4,	r6	;
    780e:	46 0d       	rram.a	#4,	r6	;
    7810:	cc 06       	mova	r6,	r12	;
    7812:	ec 08       	adda	r8,	r12	;
    7814:	0f 5a       	add	r10,	r15	;

00007816 <.L387>:
    7816:	0e 9f       	cmp	r15,	r14	;
    7818:	52 38       	jl	$+166    	;abs 0x78be
    781a:	04 4a       	mov	r10,	r4	;
    781c:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    7820:	04 8a       	sub	r10,	r4	;
    7822:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00007826 <.Loc.759.2>:
    7826:	65 42       	mov.b	#4,	r5	;r2 As==10
    7828:	46 43       	clr.b	r6		;
    782a:	04 46       	mov	r6,	r4	;

0000782c <.LBB68>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    782c:	40 18 0c 4a 	movx.w	r10,	r12	;
    7830:	ec 08       	adda	r8,	r12	;
    7832:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

00007836 <.L394>:
    7836:	35 53       	add	#-1,	r5	;r3 As==11

00007838 <.LVL467>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7838:	35 93       	cmp	#-1,	r5	;r3 As==11
    783a:	7b 20       	jnz	$+248    	;abs 0x7932

0000783c <.LBE68>:
  interval = (interval / 100) * 100;
    783c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7840:	4f 43       	clr.b	r15		;
    7842:	0c 46       	mov	r6,	r12	;
    7844:	0d 44       	mov	r4,	r13	;
    7846:	b0 13 aa a2 	calla	#41642		;0x0a2aa
    784a:	05 4c       	mov	r12,	r5	;

0000784c <.LVL469>:
    784c:	06 4d       	mov	r13,	r6	;

0000784e <.LVL470>:
    784e:	0c 5c       	rla	r12		;
    7850:	0d 6d       	rlc	r13		;
    7852:	0e 4c       	mov	r12,	r14	;
    7854:	0e 55       	add	r5,	r14	;
    7856:	04 4d       	mov	r13,	r4	;
    7858:	04 66       	addc	r6,	r4	;
    785a:	0c 4e       	mov	r14,	r12	;
    785c:	0d 44       	mov	r4,	r13	;
    785e:	71 0e 00 00 	mova	r14,	0(r1)	;
    7862:	b0 13 0e a3 	calla	#41742		;0x0a30e
    7866:	0e 01       	mova	@r1,	r14	;
    7868:	0e 5c       	add	r12,	r14	;
    786a:	0d 64       	addc	r4,	r13	;

0000786c <.Loc.783.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    786c:	40 18 0a 4a 	movx.w	r10,	r10	;
    7870:	aa 00 04 00 	adda	#4,	r10	;

00007874 <.LVL472>:
    7874:	0e 55       	add	r5,	r14	;
    7876:	0f 4d       	mov	r13,	r15	;
    7878:	0f 66       	addc	r6,	r15	;
    787a:	5d 41 07 00 	mov.b	7(r1),	r13	;
    787e:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    7882:	cc 08       	mova	r8,	r12	;
    7884:	ec 0a       	adda	r10,	r12	;
    7886:	b0 13 e0 94 	calla	#38112		;0x094e0

0000788a <.LVL473>:
  if (hdr.reply) {
    788a:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    788e:	3f 24       	jz	$+128    	;abs 0x790e

00007890 <.Loc.787.2>:
    gen_success(hdr);
    7890:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    7894:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00007898 <.LVL475>:
    7898:	07 d9       	bis	r9,	r7	;
    789a:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    789e:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    78a2:	12 00 
    78a4:	cc 01       	mova	r1,	r12	;
    78a6:	ac 00 10 00 	adda	#16,	r12	;0x00010
    78aa:	b0 13 7c 6c 	calla	#27772		;0x06c7c

000078ae <.LVL476>:
    78ae:	80 00 0e 79 	mova	#30990,	r0	;0x0790e

000078b2 <.L397>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    78b2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    78b4:	80 00 e8 77 	mova	#30696,	r0	;0x077e8

000078b8 <.L398>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    78b8:	6a 42       	mov.b	#4,	r10	;r2 As==10
    78ba:	80 00 06 78 	mova	#30726,	r0	;0x07806

000078be <.L393>:
    if ((buffer[i] < 0x40) || 
    78be:	6d 4c       	mov.b	@r12,	r13	;
    78c0:	46 4d       	mov.b	r13,	r6	;
    78c2:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    78c6:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    78ca:	45 96       	cmp.b	r6,	r5	;
    78cc:	0e 28       	jnc	$+30     	;abs 0x78ea

000078ce <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    78ce:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

000078d2 <.Loc.760.2>:
    if ((buffer[i] < 0x40) || 
    78d2:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    78d6:	45 96       	cmp.b	r6,	r5	;
    78d8:	08 2c       	jc	$+18     	;abs 0x78ea
    78da:	ac 00 01 00 	adda	#1,	r12	;

000078de <.Loc.762.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    78de:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

000078e2 <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    78e2:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    78e6:	46 9d       	cmp.b	r13,	r6	;
    78e8:	21 28       	jnc	$+68     	;abs 0x792c

000078ea <.L388>:
      if (hdr.reply) {
    78ea:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    78ee:	18 24       	jz	$+50     	;abs 0x7920

000078f0 <.Loc.766.2>:
        gen_failure(hdr);
    78f0:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    78f4:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

000078f8 <.LVL481>:
    78f8:	07 d9       	bis	r9,	r7	;
    78fa:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    78fe:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7902:	12 00 
    7904:	cc 01       	mova	r1,	r12	;
    7906:	ac 00 10 00 	adda	#16,	r12	;0x00010
    790a:	b0 13 c2 6f 	calla	#28610		;0x06fc2

0000790e <.L396>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    790e:	cc 08       	mova	r8,	r12	;
    7910:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007914 <.LVL483>:
    7914:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007918 <.LVL484>:
}
    7918:	a1 00 14 00 	adda	#20,	r1	;0x00014
    791c:	64 16       	popm.a	#7,	r10	;20-bit words
    791e:	10 01       	reta			;

00007920 <.L390>:
        elyErrorSignal(ErrCmdFailure);
    7920:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7924:	b0 13 ca 94 	calla	#38090		;0x094ca

00007928 <.LVL486>:
    7928:	80 00 0e 79 	mova	#30990,	r0	;0x0790e

0000792c <.L389>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    792c:	1e 53       	inc	r14		;
    792e:	80 00 16 78 	mova	#30742,	r0	;0x07816

00007932 <.L395>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7932:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7936:	0e 55       	add	r5,	r14	;
    7938:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    793c:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    7940:	6c 4f       	mov.b	@r15,	r12	;
    7942:	0d 43       	clr	r13		;
    7944:	0f 43       	clr	r15		;
    7946:	b0 13 2a a3 	calla	#41770		;0x0a32a
    794a:	06 dc       	bis	r12,	r6	;

0000794c <.LVL491>:
    794c:	04 dd       	bis	r13,	r4	;

0000794e <.LVL492>:
    794e:	80 00 36 78 	mova	#30774,	r0	;0x07836

00007952 <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7952:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007954 <.LCFI51>:
    7954:	b1 00 04 00 	suba	#4,	r1	;

00007958 <.LCFI52>:
    7958:	c8 0c       	mova	r12,	r8	;
    795a:	2a 4d       	mov	@r13,	r10	;

0000795c <.LVL494>:
    795c:	16 4d 02 00 	mov	2(r13),	r6	;

00007960 <.LVL495>:
    7960:	09 4a       	mov	r10,	r9	;
    7962:	59 0f       	rrum	#4,	r9	;
    7964:	59 0f       	rrum	#4,	r9	;

00007966 <.Loc.727.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7966:	4c 4a       	mov.b	r10,	r12	;

00007968 <.LVL497>:
    7968:	1c b3       	bit	#1,	r12	;r3 As==01
    796a:	26 20       	jnz	$+78     	;abs 0x79b8
    796c:	4e 43       	clr.b	r14		;

0000796e <.L403>:
    796e:	6c f3       	and.b	#2,	r12	;r3 As==10
    7970:	47 4c       	mov.b	r12,	r7	;
    7972:	40 18 4d 49 	movx.b	r9,	r13	;
    7976:	40 18 4d 8c 	subx.b	r12,	r13	;
    797a:	4d 8e       	sub.b	r14,	r13	;
    797c:	4f 4d       	mov.b	r13,	r15	;

0000797e <.LVL498>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    797e:	07 93       	cmp	#0,	r7	;r3 As==00
    7980:	1e 20       	jnz	$+62     	;abs 0x79be

00007982 <.Loc.728.2>:
    7982:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007984 <.L404>:
    7984:	40 18 04 4e 	movx.w	r14,	r4	;
    7988:	e4 08       	adda	r8,	r4	;
    798a:	cc 04       	mova	r4,	r12	;

0000798c <.LBB72>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    798c:	0f 5e       	add	r14,	r15	;

0000798e <.L405>:
    798e:	0e 9f       	cmp	r15,	r14	;
    7990:	19 38       	jl	$+52     	;abs 0x79c4

00007992 <.LBE72>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    7992:	cc 04       	mova	r4,	r12	;
    7994:	b0 13 de 94 	calla	#38110		;0x094de

00007998 <.LVL501>:
  if (hdr.reply) {
    7998:	07 93       	cmp	#0,	r7	;r3 As==00
    799a:	2b 24       	jz	$+88     	;abs 0x79f2

0000799c <.Loc.748.2>:
    gen_success(hdr);
    799c:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    79a0:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000079a4 <.LVL503>:
    79a4:	0a d9       	bis	r9,	r10	;
    79a6:	81 4a 00 00 	mov	r10,	0(r1)	;
    79aa:	81 46 02 00 	mov	r6,	2(r1)	;
    79ae:	cc 01       	mova	r1,	r12	;
    79b0:	b0 13 7c 6c 	calla	#27772		;0x06c7c

000079b4 <.LVL504>:
    79b4:	80 00 f2 79 	mova	#31218,	r0	;0x079f2

000079b8 <.L412>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    79b8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    79ba:	80 00 6e 79 	mova	#31086,	r0	;0x0796e

000079be <.L413>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    79be:	6e 42       	mov.b	#4,	r14	;r2 As==10
    79c0:	80 00 84 79 	mova	#31108,	r0	;0x07984

000079c4 <.L410>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    79c4:	6b 4c       	mov.b	@r12,	r11	;
    79c6:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    79ca:	ac 00 01 00 	adda	#1,	r12	;
    79ce:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    79d2:	45 9b       	cmp.b	r11,	r5	;
    79d4:	1d 2c       	jc	$+60     	;abs 0x7a10

000079d6 <.Loc.732.2>:
      if (hdr.reply) {
    79d6:	07 93       	cmp	#0,	r7	;r3 As==00
    79d8:	15 24       	jz	$+44     	;abs 0x7a04

000079da <.Loc.734.2>:
        gen_failure(hdr);
    79da:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    79de:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000079e2 <.LVL509>:
    79e2:	0a d9       	bis	r9,	r10	;
    79e4:	81 4a 00 00 	mov	r10,	0(r1)	;
    79e8:	81 46 02 00 	mov	r6,	2(r1)	;
    79ec:	cc 01       	mova	r1,	r12	;
    79ee:	b0 13 c2 6f 	calla	#28610		;0x06fc2

000079f2 <.L411>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    79f2:	cc 08       	mova	r8,	r12	;
    79f4:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000079f8 <.LVL511>:
    79f8:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000079fc <.LVL512>:
}
    79fc:	a1 00 04 00 	adda	#4,	r1	;
    7a00:	64 16       	popm.a	#7,	r10	;20-bit words
    7a02:	10 01       	reta			;

00007a04 <.L407>:
        elyErrorSignal(ErrCmdFailure);
    7a04:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7a08:	b0 13 ca 94 	calla	#38090		;0x094ca

00007a0c <.LVL514>:
    7a0c:	80 00 f2 79 	mova	#31218,	r0	;0x079f2

00007a10 <.L406>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7a10:	1e 53       	inc	r14		;
    7a12:	80 00 8e 79 	mova	#31118,	r0	;0x0798e

00007a16 <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a16:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007a18 <.LCFI53>:
    7a18:	b1 00 14 00 	suba	#20,	r1	;0x00014

00007a1c <.LCFI54>:
    7a1c:	c8 0c       	mova	r12,	r8	;
    7a1e:	27 4d       	mov	@r13,	r7	;

00007a20 <.LVL518>:
    7a20:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7a24:	08 00 
    7a26:	09 47       	mov	r7,	r9	;
    7a28:	59 0f       	rrum	#4,	r9	;
    7a2a:	59 0f       	rrum	#4,	r9	;

00007a2c <.Loc.686.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7a2c:	4c 47       	mov.b	r7,	r12	;

00007a2e <.LVL520>:
    7a2e:	1c b3       	bit	#1,	r12	;r3 As==01
    7a30:	66 20       	jnz	$+206    	;abs 0x7afe
    7a32:	4d 43       	clr.b	r13		;

00007a34 <.L418>:
    7a34:	6c f3       	and.b	#2,	r12	;r3 As==10
    7a36:	45 4c       	mov.b	r12,	r5	;
    7a38:	81 45 04 00 	mov	r5,	4(r1)	;
    7a3c:	40 18 4e 49 	movx.b	r9,	r14	;
    7a40:	40 18 4e 8c 	subx.b	r12,	r14	;
    7a44:	4e 8d       	sub.b	r13,	r14	;
    7a46:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    7a4a:	4f 4e       	mov.b	r14,	r15	;

00007a4c <.LVL521>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7a4c:	05 93       	cmp	#0,	r5	;r3 As==00
    7a4e:	5a 20       	jnz	$+182    	;abs 0x7b04

00007a50 <.Loc.687.2>:
    7a50:	6a 43       	mov.b	#2,	r10	;r3 As==10

00007a52 <.L419>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7a52:	0e 4a       	mov	r10,	r14	;

00007a54 <.LVL523>:
    7a54:	2e 52       	add	#4,	r14	;r2 As==10

00007a56 <.LVL524>:
    7a56:	06 4e       	mov	r14,	r6	;
    7a58:	46 0e       	rlam.a	#4,	r6	;
    7a5a:	46 0d       	rram.a	#4,	r6	;
    7a5c:	cc 06       	mova	r6,	r12	;
    7a5e:	ec 08       	adda	r8,	r12	;
    7a60:	0f 5a       	add	r10,	r15	;

00007a62 <.L420>:
    7a62:	0e 9f       	cmp	r15,	r14	;
    7a64:	52 38       	jl	$+166    	;abs 0x7b0a
    7a66:	04 4a       	mov	r10,	r4	;
    7a68:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    7a6c:	04 8a       	sub	r10,	r4	;
    7a6e:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00007a72 <.Loc.690.2>:
    7a72:	65 42       	mov.b	#4,	r5	;r2 As==10
    7a74:	46 43       	clr.b	r6		;
    7a76:	04 46       	mov	r6,	r4	;

00007a78 <.LBB76>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7a78:	40 18 0c 4a 	movx.w	r10,	r12	;
    7a7c:	ec 08       	adda	r8,	r12	;
    7a7e:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

00007a82 <.L427>:
    7a82:	35 53       	add	#-1,	r5	;r3 As==11

00007a84 <.LVL526>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7a84:	35 93       	cmp	#-1,	r5	;r3 As==11
    7a86:	7b 20       	jnz	$+248    	;abs 0x7b7e

00007a88 <.LBE76>:
  interval = (interval / 100) * 100;
    7a88:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7a8c:	4f 43       	clr.b	r15		;
    7a8e:	0c 46       	mov	r6,	r12	;
    7a90:	0d 44       	mov	r4,	r13	;
    7a92:	b0 13 aa a2 	calla	#41642		;0x0a2aa
    7a96:	05 4c       	mov	r12,	r5	;

00007a98 <.LVL528>:
    7a98:	06 4d       	mov	r13,	r6	;

00007a9a <.LVL529>:
    7a9a:	0c 5c       	rla	r12		;
    7a9c:	0d 6d       	rlc	r13		;
    7a9e:	0e 4c       	mov	r12,	r14	;
    7aa0:	0e 55       	add	r5,	r14	;
    7aa2:	04 4d       	mov	r13,	r4	;
    7aa4:	04 66       	addc	r6,	r4	;
    7aa6:	0c 4e       	mov	r14,	r12	;
    7aa8:	0d 44       	mov	r4,	r13	;
    7aaa:	71 0e 00 00 	mova	r14,	0(r1)	;
    7aae:	b0 13 0e a3 	calla	#41742		;0x0a30e
    7ab2:	0e 01       	mova	@r1,	r14	;
    7ab4:	0e 5c       	add	r12,	r14	;
    7ab6:	0d 64       	addc	r4,	r13	;

00007ab8 <.Loc.715.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    7ab8:	40 18 0a 4a 	movx.w	r10,	r10	;
    7abc:	aa 00 04 00 	adda	#4,	r10	;

00007ac0 <.LVL531>:
    7ac0:	0e 55       	add	r5,	r14	;
    7ac2:	0f 4d       	mov	r13,	r15	;
    7ac4:	0f 66       	addc	r6,	r15	;
    7ac6:	5d 41 07 00 	mov.b	7(r1),	r13	;
    7aca:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    7ace:	cc 08       	mova	r8,	r12	;
    7ad0:	ec 0a       	adda	r10,	r12	;
    7ad2:	b0 13 dc 94 	calla	#38108		;0x094dc

00007ad6 <.LVL532>:
  if (hdr.reply) {
    7ad6:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    7ada:	3f 24       	jz	$+128    	;abs 0x7b5a

00007adc <.Loc.719.2>:
    gen_success(hdr);
    7adc:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    7ae0:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00007ae4 <.LVL534>:
    7ae4:	07 d9       	bis	r9,	r7	;
    7ae6:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    7aea:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7aee:	12 00 
    7af0:	cc 01       	mova	r1,	r12	;
    7af2:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7af6:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007afa <.LVL535>:
    7afa:	80 00 5a 7b 	mova	#31578,	r0	;0x07b5a

00007afe <.L430>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7afe:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7b00:	80 00 34 7a 	mova	#31284,	r0	;0x07a34

00007b04 <.L431>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7b04:	6a 42       	mov.b	#4,	r10	;r2 As==10
    7b06:	80 00 52 7a 	mova	#31314,	r0	;0x07a52

00007b0a <.L426>:
    if ((buffer[i] < 0x40) || 
    7b0a:	6d 4c       	mov.b	@r12,	r13	;
    7b0c:	46 4d       	mov.b	r13,	r6	;
    7b0e:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    7b12:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    7b16:	45 96       	cmp.b	r6,	r5	;
    7b18:	0e 28       	jnc	$+30     	;abs 0x7b36

00007b1a <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7b1a:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

00007b1e <.Loc.691.2>:
    if ((buffer[i] < 0x40) || 
    7b1e:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    7b22:	45 96       	cmp.b	r6,	r5	;
    7b24:	08 2c       	jc	$+18     	;abs 0x7b36
    7b26:	ac 00 01 00 	adda	#1,	r12	;

00007b2a <.Loc.693.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7b2a:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00007b2e <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7b2e:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    7b32:	46 9d       	cmp.b	r13,	r6	;
    7b34:	21 28       	jnc	$+68     	;abs 0x7b78

00007b36 <.L421>:
      if (hdr.reply) {
    7b36:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    7b3a:	18 24       	jz	$+50     	;abs 0x7b6c

00007b3c <.Loc.697.2>:
        gen_failure(hdr);
    7b3c:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    7b40:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00007b44 <.LVL540>:
    7b44:	07 d9       	bis	r9,	r7	;
    7b46:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    7b4a:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7b4e:	12 00 
    7b50:	cc 01       	mova	r1,	r12	;
    7b52:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7b56:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007b5a <.L429>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7b5a:	cc 08       	mova	r8,	r12	;
    7b5c:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007b60 <.LVL542>:
    7b60:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007b64 <.LVL543>:
}
    7b64:	a1 00 14 00 	adda	#20,	r1	;0x00014
    7b68:	64 16       	popm.a	#7,	r10	;20-bit words
    7b6a:	10 01       	reta			;

00007b6c <.L423>:
        elyErrorSignal(ErrCmdFailure);
    7b6c:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7b70:	b0 13 ca 94 	calla	#38090		;0x094ca

00007b74 <.LVL545>:
    7b74:	80 00 5a 7b 	mova	#31578,	r0	;0x07b5a

00007b78 <.L422>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7b78:	1e 53       	inc	r14		;
    7b7a:	80 00 62 7a 	mova	#31330,	r0	;0x07a62

00007b7e <.L428>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7b7e:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7b82:	0e 55       	add	r5,	r14	;
    7b84:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7b88:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    7b8c:	6c 4f       	mov.b	@r15,	r12	;
    7b8e:	0d 43       	clr	r13		;
    7b90:	0f 43       	clr	r15		;
    7b92:	b0 13 2a a3 	calla	#41770		;0x0a32a
    7b96:	06 dc       	bis	r12,	r6	;

00007b98 <.LVL550>:
    7b98:	04 dd       	bis	r13,	r4	;

00007b9a <.LVL551>:
    7b9a:	80 00 82 7a 	mova	#31362,	r0	;0x07a82

00007b9e <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7b9e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007ba0 <.LCFI55>:
    7ba0:	b1 00 04 00 	suba	#4,	r1	;

00007ba4 <.LCFI56>:
    7ba4:	28 4d       	mov	@r13,	r8	;

00007ba6 <.LVL553>:
    7ba6:	1a 4d 02 00 	mov	2(r13),	r10	;

00007baa <.LVL554>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7baa:	47 48       	mov.b	r8,	r7	;
    7bac:	67 f3       	and.b	#2,	r7	;r3 As==10
    7bae:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    7bb2:	07 93       	cmp	#0,	r7	;r3 As==00
    7bb4:	1c 20       	jnz	$+58     	;abs 0x7bee
    7bb6:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007bb8 <.L436>:
  uint8_t bank = buffer[hdr_ext];
    7bb8:	40 18 0e 4e 	movx.w	r14,	r14	;
    7bbc:	ee 0c       	adda	r12,	r14	;

00007bbe <.LVL556>:
    7bbe:	69 4e       	mov.b	@r14,	r9	;

00007bc0 <.LVL557>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7bc0:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007bc4 <.LVL558>:
    7bc4:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007bc8 <.LVL559>:
  if (bank == 0 || bank > 4) {
    7bc8:	4c 49       	mov.b	r9,	r12	;
    7bca:	7c 53       	add.b	#-1,	r12	;r3 As==11
    7bcc:	7d 40 03 00 	mov.b	#3,	r13	;
    7bd0:	4d 9c       	cmp.b	r12,	r13	;
    7bd2:	16 2c       	jc	$+46     	;abs 0x7c00

00007bd4 <.Loc.660.2>:
    if (hdr.reply) {
    7bd4:	07 93       	cmp	#0,	r7	;r3 As==00
    7bd6:	0e 24       	jz	$+30     	;abs 0x7bf4

00007bd8 <.Loc.662.2>:
      gen_failure(hdr);
    7bd8:	81 48 00 00 	mov	r8,	0(r1)	;
    7bdc:	81 4a 02 00 	mov	r10,	2(r1)	;
    7be0:	cc 01       	mova	r1,	r12	;
    7be2:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007be6 <.L435>:
}
    7be6:	a1 00 04 00 	adda	#4,	r1	;
    7bea:	37 16       	popm.a	#4,	r10	;20-bit words
    7bec:	10 01       	reta			;

00007bee <.L440>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7bee:	6e 42       	mov.b	#4,	r14	;r2 As==10
    7bf0:	80 00 b8 7b 	mova	#31672,	r0	;0x07bb8

00007bf4 <.L438>:
      elyErrorSignal(ErrCmdFailure);
    7bf4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7bf8:	b0 13 ca 94 	calla	#38090		;0x094ca

00007bfc <.LVL565>:
    7bfc:	80 00 e6 7b 	mova	#31718,	r0	;0x07be6

00007c00 <.L437>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    7c00:	2a 01 ac 05 	mova	&66988,	r10	;0x105ac

00007c04 <.LVL566>:
    7c04:	88 00 32 94 	mova	#37938,	r8	;0x09432
    7c08:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    7c0c:	4e 43       	clr.b	r14		;
    7c0e:	cd 0a       	mova	r10,	r13	;
    7c10:	4c 49       	mov.b	r9,	r12	;
    7c12:	48 13       	calla	r8		;

00007c14 <.LVL567>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    7c14:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    7c18:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    7c1c:	cd 0a       	mova	r10,	r13	;
    7c1e:	ad 00 80 00 	adda	#128,	r13	;0x00080
    7c22:	4c 49       	mov.b	r9,	r12	;
    7c24:	48 13       	calla	r8		;

00007c26 <.LVL568>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    7c26:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    7c2a:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    7c2e:	cd 0a       	mova	r10,	r13	;
    7c30:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    7c34:	4c 49       	mov.b	r9,	r12	;
    7c36:	48 13       	calla	r8		;

00007c38 <.LVL569>:
  bank0w[RegActiveBank] = bank;
    7c38:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

00007c3c <.Loc.678.2>:
  active_buffer = NULL; /* have to null before reset */
    7c3c:	00 18 c2 43 	movx.a	#0,	&0xfac3a;r3 As==00
    7c40:	3a ac 

00007c42 <.Loc.682.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7c42:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    7c46:	48 a5 20 01 
    7c4a:	80 00 e6 7b 	mova	#31718,	r0	;0x07be6

00007c4e <set_u32>:
    const uint32_t max, const uint32_t min) {
    7c4e:	b1 00 02 00 	suba	#2,	r1	;
    7c52:	00 18 d1 41 	movx.a	2(r1),	0(r1)	;
    7c56:	02 00 00 00 

00007c5a <.LCFI57>:
    7c5a:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007c5c <.LCFI58>:
    7c5c:	b1 00 14 00 	suba	#20,	r1	;0x00014

00007c60 <.LCFI59>:
    7c60:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7c64:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    7c68:	2a 4e       	mov	@r14,	r10	;

00007c6a <.LVL571>:
    7c6a:	1c 4e 02 00 	mov	2(r14),	r12	;

00007c6e <.LVL572>:
    7c6e:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034
    7c72:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c
    7c76:	1b 41 36 00 	mov	54(r1),	r11	;0x00036
    7c7a:	91 41 38 00 	mov	56(r1),	14(r1)	;0x00038, 0x000e
    7c7e:	0e 00 
    7c80:	15 41 3a 00 	mov	58(r1),	r5	;0x0003a

00007c84 <.Loc.130.2>:
static void set_u32(const uint8_t addr, const uint8_t * buffer, elysium_cmd_hdr_t hdr,
    7c84:	81 4c 08 00 	mov	r12,	8(r1)	;

00007c88 <.Loc.132.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c88:	49 4a       	mov.b	r10,	r9	;
    7c8a:	69 f3       	and.b	#2,	r9	;r3 As==10
    7c8c:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7c90:	09 93       	cmp	#0,	r9	;r3 As==00
    7c92:	44 20       	jnz	$+138    	;abs 0x7d1c
    7c94:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007c96 <.L442>:
    7c96:	40 18 04 4c 	movx.w	r12,	r4	;
    7c9a:	e4 0d       	adda	r13,	r4	;
    7c9c:	71 04 04 00 	mova	r4,	4(r1)	;

00007ca0 <.Loc.132.2>:
    7ca0:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00007ca4 <.Loc.133.2>:
  uint32_t val = 0;
    7ca4:	48 43       	clr.b	r8		;
    7ca6:	07 48       	mov	r8,	r7	;

00007ca8 <.L443>:
    val |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    7ca8:	3e 01 04 00 	mova	4(r1),	r14	;
    7cac:	6c 4e       	mov.b	@r14,	r12	;
    7cae:	0d 43       	clr	r13		;
    7cb0:	0e 46       	mov	r6,	r14	;
    7cb2:	0f 43       	clr	r15		;
    7cb4:	71 0b 00 00 	mova	r11,	0(r1)	;
    7cb8:	b0 13 2a a3 	calla	#41770		;0x0a32a
    7cbc:	0c d8       	bis	r8,	r12	;
    7cbe:	0d d7       	bis	r7,	r13	;
    7cc0:	08 4c       	mov	r12,	r8	;

00007cc2 <.LVL576>:
    7cc2:	07 4d       	mov	r13,	r7	;

00007cc4 <.LVL577>:
    7cc4:	00 18 d1 53 	incx.a	4(r1)		;
    7cc8:	04 00 
    7cca:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00007cce <.Loc.136.2>:
  for (int i = 0; i < 4; i++) {
    7cce:	0b 01       	mova	@r1,	r11	;
    7cd0:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    7cd4:	e9 23       	jnz	$-44     	;abs 0x7ca8

00007cd6 <.LBE80>:
  if (val > max || 
    7cd6:	0b 9d       	cmp	r13,	r11	;
    7cd8:	0c 28       	jnc	$+26     	;abs 0x7cf2
    7cda:	0d 9b       	cmp	r11,	r13	;
    7cdc:	03 20       	jnz	$+8      	;abs 0x7ce4
    7cde:	81 9c 0c 00 	cmp	r12,	12(r1)	; 0x000c
    7ce2:	07 28       	jnc	$+16     	;abs 0x7cf2

00007ce4 <.L451>:
    7ce4:	0d 95       	cmp	r5,	r13	;
    7ce6:	05 28       	jnc	$+12     	;abs 0x7cf2
    7ce8:	05 9d       	cmp	r13,	r5	;
    7cea:	21 20       	jnz	$+68     	;abs 0x7d2e
    7cec:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    7cf0:	1e 2c       	jc	$+62     	;abs 0x7d2e

00007cf2 <.L444>:
    if (hdr.reply) {
    7cf2:	09 93       	cmp	#0,	r9	;r3 As==00
    7cf4:	16 24       	jz	$+46     	;abs 0x7d22

00007cf6 <.Loc.144.2>:
      gen_failure(hdr);
    7cf6:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    7cfa:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7cfe:	12 00 
    7d00:	cc 01       	mova	r1,	r12	;
    7d02:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7d06:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00007d0a <.L441>:
}
    7d0a:	a1 00 14 00 	adda	#20,	r1	;0x00014
    7d0e:	64 16       	popm.a	#7,	r10	;20-bit words
    7d10:	00 18 e1 41 	movx.a	@r1,	2(r1)	;
    7d14:	02 00 
    7d16:	a1 00 02 00 	adda	#2,	r1	;
    7d1a:	10 01       	reta			;

00007d1c <.L450>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7d1c:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007d1e <.LVL581>:
    7d1e:	80 00 96 7c 	mova	#31894,	r0	;0x07c96

00007d22 <.L448>:
      elyErrorSignal(ErrCmdFailure);
    7d22:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7d26:	b0 13 ca 94 	calla	#38090		;0x094ca

00007d2a <.LVL583>:
    7d2a:	80 00 0a 7d 	mova	#32010,	r0	;0x07d0a

00007d2e <.L446>:
  bank0w[addr+3] = buffer[hdr_ext];
    7d2e:	40 18 1c 41 	movx.w	10(r1),	r12	;0x0000a
    7d32:	0a 00 
    7d34:	80 18 5c 52 	addx.a	&0x105ac,r12	;
    7d38:	ac 05 
    7d3a:	ec 44 03 00 	mov.b	@r4,	3(r12)	;

00007d3e <.Loc.153.2>:
  bank0w[addr+2] = buffer[hdr_ext+1];
    7d3e:	dc 44 01 00 	mov.b	1(r4),	2(r12)	;
    7d42:	02 00 

00007d44 <.Loc.154.2>:
  bank0w[addr+1] = buffer[hdr_ext+2];
    7d44:	dc 44 02 00 	mov.b	2(r4),	1(r12)	;
    7d48:	01 00 

00007d4a <.Loc.155.2>:
  bank0w[addr] = buffer[hdr_ext+3];
    7d4a:	dc 44 03 00 	mov.b	3(r4),	0(r12)	;
    7d4e:	00 00 

00007d50 <.Loc.157.2>:
  if (hdr.reply) {
    7d50:	09 93       	cmp	#0,	r9	;r3 As==00
    7d52:	db 27       	jz	$-72     	;abs 0x7d0a

00007d54 <.Loc.159.2>:
    gen_success(hdr);
    7d54:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    7d58:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    7d5c:	12 00 
    7d5e:	cc 01       	mova	r1,	r12	;
    7d60:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7d64:	b0 13 7c 6c 	calla	#27772		;0x06c7c

00007d68 <.LVL584>:
    7d68:	80 00 0a 7d 	mova	#32010,	r0	;0x07d0a

00007d6c <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7d6c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007d6e <.LCFI60>:
    7d6e:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007d72 <.LCFI61>:
    7d72:	ca 0c       	mova	r12,	r10	;

00007d74 <.Loc.643.2>:
  set_u32(RegUARTBaudLsb, buffer, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    7d74:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7d78:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7d7c:	08 00 
    7d7e:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    7d82:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7d86:	b1 40 0f 00 	mov	#15,	0(r1)	;#0x000f
    7d8a:	00 00 
    7d8c:	3f 40 40 42 	mov	#16960,	r15	;#0x4240
    7d90:	ce 01       	mova	r1,	r14	;
    7d92:	ae 00 06 00 	adda	#6,	r14	;
    7d96:	cd 0c       	mova	r12,	r13	;
    7d98:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00007d9c <.LVL586>:
    7d9c:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007da0 <.LVL587>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7da0:	cc 0a       	mova	r10,	r12	;
    7da2:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007da6 <.LVL588>:
    7da6:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007daa <.LVL589>:
  elyUARTCfgMarkDirty();
    7daa:	b0 13 ec 61 	calla	#25068		;0x061ec

00007dae <.LVL590>:
}
    7dae:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7db2:	0a 16       	popm.a	#1,	r10	;20-bit words
    7db4:	10 01       	reta			;

00007db6 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7db6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007db8 <.LCFI62>:
    7db8:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007dbc <.LCFI63>:
    7dbc:	ca 0c       	mova	r12,	r10	;

00007dbe <.Loc.565.2>:
  set_u32(RegRXDevLsb, buffer, hdr, RX_DEV_MAX, RX_DEV_MIN);
    7dbe:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7dc2:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7dc6:	08 00 
    7dc8:	b1 40 e8 80 	mov	#-32536,2(r1)	;#0x80e8
    7dcc:	02 00 
    7dce:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7dd2:	b1 40 03 00 	mov	#3,	0(r1)	;
    7dd6:	00 00 
    7dd8:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7ddc:	ce 01       	mova	r1,	r14	;
    7dde:	ae 00 06 00 	adda	#6,	r14	;
    7de2:	cd 0c       	mova	r12,	r13	;
    7de4:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c

00007de8 <.LVL592>:
    7de8:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007dec <.LVL593>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7dec:	cc 0a       	mova	r10,	r12	;
    7dee:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007df2 <.LVL594>:
    7df2:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007df6 <.LVL595>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    7df6:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    7dfa:	4d 43       	clr.b	r13		;
    7dfc:	b0 13 1a 97 	calla	#38682		;0x0971a

00007e00 <.LVL596>:
  elyEventSignal(EvtRXDevChange);
    7e00:	7c 40 ca ff 	mov.b	#-54,	r12	;#0xffca
    7e04:	b0 13 d0 94 	calla	#38096		;0x094d0

00007e08 <.LVL597>:
}
    7e08:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7e0c:	0a 16       	popm.a	#1,	r10	;20-bit words
    7e0e:	10 01       	reta			;

00007e10 <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e10:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007e12 <.LCFI64>:
    7e12:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007e16 <.LCFI65>:
    7e16:	ca 0c       	mova	r12,	r10	;

00007e18 <.Loc.543.2>:
  set_u32(RegTXDevLsb, buffer, hdr, TX_DEV_MAX, TX_DEV_MIN);
    7e18:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7e1c:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7e20:	08 00 
    7e22:	b1 40 58 02 	mov	#600,	2(r1)	;#0x0258
    7e26:	02 00 
    7e28:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7e2c:	b1 40 03 00 	mov	#3,	0(r1)	;
    7e30:	00 00 
    7e32:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7e36:	ce 01       	mova	r1,	r14	;
    7e38:	ae 00 06 00 	adda	#6,	r14	;
    7e3c:	cd 0c       	mova	r12,	r13	;
    7e3e:	7c 42       	mov.b	#8,	r12	;r2 As==11

00007e40 <.LVL599>:
    7e40:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007e44 <.LVL600>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7e44:	cc 0a       	mova	r10,	r12	;
    7e46:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007e4a <.LVL601>:
    7e4a:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007e4e <.LVL602>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    7e4e:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7e52:	4d 43       	clr.b	r13		;
    7e54:	b0 13 1a 97 	calla	#38682		;0x0971a

00007e58 <.LVL603>:
  elyEventSignal(EvtTXDevChange);
    7e58:	7c 40 c9 ff 	mov.b	#-55,	r12	;#0xffc9
    7e5c:	b0 13 d0 94 	calla	#38096		;0x094d0

00007e60 <.LVL604>:
}
    7e60:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7e64:	0a 16       	popm.a	#1,	r10	;20-bit words
    7e66:	10 01       	reta			;

00007e68 <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e68:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007e6a <.LCFI66>:
    7e6a:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007e6e <.LCFI67>:
    7e6e:	ca 0c       	mova	r12,	r10	;

00007e70 <.Loc.521.2>:
  set_u32(RegRXBRLsb, buffer, hdr, RX_BR_MAX, RX_BR_MIN);
    7e70:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7e74:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7e78:	08 00 
    7e7a:	b1 40 0c 03 	mov	#780,	2(r1)	;#0x030c
    7e7e:	02 00 
    7e80:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7e84:	a1 43 00 00 	mov	#2,	0(r1)	;r3 As==10
    7e88:	3f 40 f0 49 	mov	#18928,	r15	;#0x49f0
    7e8c:	ce 01       	mova	r1,	r14	;
    7e8e:	ae 00 06 00 	adda	#6,	r14	;
    7e92:	cd 0c       	mova	r12,	r13	;
    7e94:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c

00007e98 <.LVL606>:
    7e98:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007e9c <.LVL607>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7e9c:	cc 0a       	mova	r10,	r12	;
    7e9e:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007ea2 <.LVL608>:
    7ea2:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007ea6 <.LVL609>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    7ea6:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7ea8:	4d 43       	clr.b	r13		;
    7eaa:	b0 13 1a 97 	calla	#38682		;0x0971a

00007eae <.LVL610>:
  elyEventSignal(EvtRXBRChange);
    7eae:	7c 40 c8 ff 	mov.b	#-56,	r12	;#0xffc8
    7eb2:	b0 13 d0 94 	calla	#38096		;0x094d0

00007eb6 <.LVL611>:
}
    7eb6:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7eba:	0a 16       	popm.a	#1,	r10	;20-bit words
    7ebc:	10 01       	reta			;

00007ebe <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7ebe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007ec0 <.LCFI68>:
    7ec0:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007ec4 <.LCFI69>:
    7ec4:	ca 0c       	mova	r12,	r10	;

00007ec6 <.Loc.499.2>:
  set_u32(RegTXBRLsb, buffer, hdr, TX_BR_MAX, TX_BR_MIN);
    7ec6:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7eca:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7ece:	08 00 
    7ed0:	b1 40 b0 04 	mov	#1200,	2(r1)	;#0x04b0
    7ed4:	02 00 
    7ed6:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7eda:	a1 42 00 00 	mov	#4,	0(r1)	;r2 As==10
    7ede:	3f 40 e0 93 	mov	#-27680,r15	;#0x93e0
    7ee2:	ce 01       	mova	r1,	r14	;
    7ee4:	ae 00 06 00 	adda	#6,	r14	;
    7ee8:	cd 0c       	mova	r12,	r13	;
    7eea:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018

00007eee <.LVL613>:
    7eee:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007ef2 <.LVL614>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7ef2:	cc 0a       	mova	r10,	r12	;
    7ef4:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007ef8 <.LVL615>:
    7ef8:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007efc <.LVL616>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    7efc:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7efe:	4d 43       	clr.b	r13		;
    7f00:	b0 13 1a 97 	calla	#38682		;0x0971a

00007f04 <.LVL617>:
  elyEventSignal(EvtTXBRChange);
    7f04:	7c 40 c7 ff 	mov.b	#-57,	r12	;#0xffc7
    7f08:	b0 13 d0 94 	calla	#38096		;0x094d0

00007f0c <.LVL618>:
}
    7f0c:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7f10:	0a 16       	popm.a	#1,	r10	;20-bit words
    7f12:	10 01       	reta			;

00007f14 <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f14:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007f16 <.LCFI70>:
    7f16:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007f1a <.LCFI71>:
    7f1a:	ca 0c       	mova	r12,	r10	;

00007f1c <.Loc.477.2>:
  set_u32(RegRXFreqLsb, buffer, hdr, RX_BAND_MAX, RX_BAND_MIN);
    7f1c:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7f20:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7f24:	08 00 
    7f26:	b1 40 40 44 	mov	#17472,	2(r1)	;#0x4440
    7f2a:	02 00 
    7f2c:	b1 40 3d 1b 	mov	#6973,	4(r1)	;#0x1b3d
    7f30:	04 00 
    7f32:	b1 40 12 1c 	mov	#7186,	0(r1)	;#0x1c12
    7f36:	00 00 
    7f38:	3f 40 c0 e3 	mov	#-7232,	r15	;#0xe3c0
    7f3c:	ce 01       	mova	r1,	r14	;
    7f3e:	ae 00 06 00 	adda	#6,	r14	;
    7f42:	cd 0c       	mova	r12,	r13	;
    7f44:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007f46 <.LVL620>:
    7f46:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007f4a <.LVL621>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7f4a:	cc 0a       	mova	r10,	r12	;
    7f4c:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007f50 <.LVL622>:
    7f50:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007f54 <.LVL623>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    7f54:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7f56:	4d 43       	clr.b	r13		;
    7f58:	b0 13 1a 97 	calla	#38682		;0x0971a

00007f5c <.LVL624>:
  elyEventSignal(EvtRXFreqChange);
    7f5c:	7c 40 c6 ff 	mov.b	#-58,	r12	;#0xffc6
    7f60:	b0 13 d0 94 	calla	#38096		;0x094d0

00007f64 <.LVL625>:
}
    7f64:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7f68:	0a 16       	popm.a	#1,	r10	;20-bit words
    7f6a:	10 01       	reta			;

00007f6c <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f6c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007f6e <.LCFI72>:
    7f6e:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007f72 <.LCFI73>:
    7f72:	ca 0c       	mova	r12,	r10	;

00007f74 <.Loc.455.2>:
  set_u32(RegTXFreqLsb, buffer, hdr, TX_BAND_MAX, TX_BAND_MIN);
    7f74:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7f78:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7f7c:	08 00 
    7f7e:	b1 40 40 da 	mov	#-9664,	2(r1)	;#0xda40
    7f82:	02 00 
    7f84:	b1 40 8e 33 	mov	#13198,	4(r1)	;#0x338e
    7f88:	04 00 
    7f8a:	b1 40 ec 38 	mov	#14572,	0(r1)	;#0x38ec
    7f8e:	00 00 
    7f90:	3f 40 c0 24 	mov	#9408,	r15	;#0x24c0
    7f94:	ce 01       	mova	r1,	r14	;
    7f96:	ae 00 06 00 	adda	#6,	r14	;
    7f9a:	cd 0c       	mova	r12,	r13	;
    7f9c:	4c 43       	clr.b	r12		;

00007f9e <.LVL627>:
    7f9e:	b0 13 4e 7c 	calla	#31822		;0x07c4e

00007fa2 <.LVL628>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7fa2:	cc 0a       	mova	r10,	r12	;
    7fa4:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00007fa8 <.LVL629>:
    7fa8:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00007fac <.LVL630>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    7fac:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7fae:	4d 43       	clr.b	r13		;
    7fb0:	b0 13 1a 97 	calla	#38682		;0x0971a

00007fb4 <.LVL631>:
  elyEventSignal(EvtTXFreqChange);
    7fb4:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    7fb8:	b0 13 d0 94 	calla	#38096		;0x094d0

00007fbc <.LVL632>:
}
    7fbc:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7fc0:	0a 16       	popm.a	#1,	r10	;20-bit words
    7fc2:	10 01       	reta			;

00007fc4 <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7fc4:	5a 14       	pushm.a	#6,	r10	;20-bit words

00007fc6 <.LCFI74>:
    7fc6:	b1 00 04 00 	suba	#4,	r1	;

00007fca <.LCFI75>:
    7fca:	ca 0c       	mova	r12,	r10	;
    7fcc:	29 4d       	mov	@r13,	r9	;

00007fce <.LVL634>:
    7fce:	15 4d 02 00 	mov	2(r13),	r5	;

00007fd2 <.LVL635>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7fd2:	47 49       	mov.b	r9,	r7	;
    7fd4:	67 f3       	and.b	#2,	r7	;r3 As==10
    7fd6:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    7fda:	07 93       	cmp	#0,	r7	;r3 As==00
    7fdc:	1d 20       	jnz	$+60     	;abs 0x8018
    7fde:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007fe0 <.L464>:
  if (buffer[hdr_ext] > TX_POW_MAX) {
    7fe0:	40 18 0c 4c 	movx.w	r12,	r12	;
    7fe4:	ec 0a       	adda	r10,	r12	;

00007fe6 <.LVL637>:
    7fe6:	6d 4c       	mov.b	@r12,	r13	;
    7fe8:	88 00 f6 a1 	mova	#41462,	r8	;0x0a1f6
    7fec:	86 00 4a 9f 	mova	#40778,	r6	;0x09f4a
    7ff0:	7c 40 82 ff 	mov.b	#-126,	r12	;#0xff82
    7ff4:	4c 9d       	cmp.b	r13,	r12	;
    7ff6:	19 2c       	jc	$+52     	;abs 0x802a

00007ff8 <.Loc.608.2>:
    if (hdr.reply) {
    7ff8:	07 93       	cmp	#0,	r7	;r3 As==00
    7ffa:	11 24       	jz	$+36     	;abs 0x801e

00007ffc <.Loc.610.2>:
      gen_failure(hdr);
    7ffc:	81 49 00 00 	mov	r9,	0(r1)	;
    8000:	81 45 02 00 	mov	r5,	2(r1)	;
    8004:	cc 01       	mova	r1,	r12	;
    8006:	b0 13 c2 6f 	calla	#28610		;0x06fc2

0000800a <.L469>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    800a:	cc 0a       	mova	r10,	r12	;
    800c:	48 13       	calla	r8		;

0000800e <.LVL641>:
    800e:	46 13       	calla	r6		;

00008010 <.LBE83>:
}
    8010:	a1 00 04 00 	adda	#4,	r1	;
    8014:	55 16       	popm.a	#6,	r10	;20-bit words
    8016:	10 01       	reta			;

00008018 <.L470>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8018:	6c 42       	mov.b	#4,	r12	;r2 As==10
    801a:	80 00 e0 7f 	mova	#32736,	r0	;0x07fe0

0000801e <.L466>:
      elyErrorSignal(ErrCmdFailure);
    801e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8022:	b0 13 ca 94 	calla	#38090		;0x094ca

00008026 <.LVL644>:
    8026:	80 00 0a 80 	mova	#32778,	r0	;0x0800a

0000802a <.L465>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    802a:	2c 01 ac 05 	mova	&66988,	r12	;0x105ac
    802e:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

00008032 <.Loc.622.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    8032:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    8036:	4d 43       	clr.b	r13		;
    8038:	b0 13 1a 97 	calla	#38682		;0x0971a

0000803c <.LVL645>:
  if (hdr.reply) {
    803c:	07 93       	cmp	#0,	r7	;r3 As==00
    803e:	e5 27       	jz	$-52     	;abs 0x800a

00008040 <.Loc.626.2>:
    gen_success(hdr);
    8040:	81 49 00 00 	mov	r9,	0(r1)	;
    8044:	81 45 02 00 	mov	r5,	2(r1)	;
    8048:	cc 01       	mova	r1,	r12	;
    804a:	b0 13 7c 6c 	calla	#27772		;0x06c7c

0000804e <.LVL647>:
    804e:	80 00 0a 80 	mova	#32778,	r0	;0x0800a

00008052 <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8052:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008054 <.LCFI76>:
    8054:	b1 00 04 00 	suba	#4,	r1	;

00008058 <.LCFI77>:
    8058:	2a 4d       	mov	@r13,	r10	;

0000805a <.LVL649>:
    805a:	18 4d 02 00 	mov	2(r13),	r8	;

0000805e <.LVL650>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    805e:	49 4a       	mov.b	r10,	r9	;
    8060:	69 f3       	and.b	#2,	r9	;r3 As==10
    8062:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8066:	09 93       	cmp	#0,	r9	;r3 As==00
    8068:	17 20       	jnz	$+48     	;abs 0x8098
    806a:	6e 43       	mov.b	#2,	r14	;r3 As==10

0000806c <.L475>:
    806c:	ee 0c       	adda	r12,	r14	;
    806e:	67 4e       	mov.b	@r14,	r7	;

00008070 <.LVL651>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8070:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008074 <.LVL652>:
    8074:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008078 <.LVL653>:
  if (arg > 1) {
    8078:	5c 43       	mov.b	#1,	r12	;r3 As==01
    807a:	4c 97       	cmp.b	r7,	r12	;
    807c:	16 2c       	jc	$+46     	;abs 0x80aa

0000807e <.Loc.201.2>:
    if (hdr.reply) {
    807e:	09 93       	cmp	#0,	r9	;r3 As==00
    8080:	0e 24       	jz	$+30     	;abs 0x809e

00008082 <.Loc.203.2>:
      gen_failure(hdr);
    8082:	81 4a 00 00 	mov	r10,	0(r1)	;
    8086:	81 48 02 00 	mov	r8,	2(r1)	;
    808a:	cc 01       	mova	r1,	r12	;
    808c:	b0 13 c2 6f 	calla	#28610		;0x06fc2

00008090 <.L474>:
}
    8090:	a1 00 04 00 	adda	#4,	r1	;
    8094:	37 16       	popm.a	#4,	r10	;20-bit words
    8096:	10 01       	reta			;

00008098 <.L480>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    8098:	6e 42       	mov.b	#4,	r14	;r2 As==10
    809a:	80 00 6c 80 	mova	#32876,	r0	;0x0806c

0000809e <.L477>:
      elyErrorSignal(ErrCmdFailure);
    809e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    80a2:	b0 13 ca 94 	calla	#38090		;0x094ca

000080a6 <.LVL659>:
    80a6:	80 00 90 80 	mova	#32912,	r0	;0x08090

000080aa <.L476>:
  if (bank0p[RegGPOState] != arg) {
    80aa:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    80ae:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    80b2:	16 24       	jz	$+46     	;abs 0x80e0

000080b4 <.Loc.214.2>:
    palWriteLine(LINE_GPO, arg);
    80b4:	0c 47       	mov	r7,	r12	;
    80b6:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    80ba:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    80be:	40 18 1d 42 	movx.w	&0x00222,r13	;
    80c2:	22 02 
    80c4:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    80c8:	0c dd       	bis	r13,	r12	;
    80ca:	40 18 82 4c 	movx.w	r12,	&0x00222;
    80ce:	22 02 

000080d0 <.Loc.216.2>:
    elyEventSignal(EvtGPOChange);
    80d0:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    80d4:	b0 13 d0 94 	calla	#38096		;0x094d0

000080d8 <.LVL660>:
    bank0w[RegGPOState] = arg;
    80d8:	2c 01 ac 05 	mova	&66988,	r12	;0x105ac
    80dc:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

000080e0 <.L479>:
  if (hdr.reply) {
    80e0:	09 93       	cmp	#0,	r9	;r3 As==00
    80e2:	d6 27       	jz	$-82     	;abs 0x8090

000080e4 <.Loc.222.2>:
    gen_success(hdr);
    80e4:	81 4a 00 00 	mov	r10,	0(r1)	;
    80e8:	81 48 02 00 	mov	r8,	2(r1)	;
    80ec:	cc 01       	mova	r1,	r12	;
    80ee:	b0 13 7c 6c 	calla	#27772		;0x06c7c

000080f2 <.LVL662>:
    80f2:	80 00 90 80 	mova	#32912,	r0	;0x08090

000080f6 <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    80f6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000080f8 <.LCFI78>:
    80f8:	c8 0c       	mova	r12,	r8	;
    80fa:	24 4d       	mov	@r13,	r4	;

000080fc <.LVL664>:
    80fc:	19 4d 02 00 	mov	2(r13),	r9	;

00008100 <.LVL665>:
    8100:	07 44       	mov	r4,	r7	;
    8102:	57 07       	rrum	#2,	r7	;
    8104:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    8108:	45 47       	mov.b	r7,	r5	;

0000810a <.Loc.1157.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    810a:	8a 00 f6 a1 	mova	#41462,	r10	;0x0a1f6
    810e:	4a 13       	calla	r10		;

00008110 <.LVL667>:
    8110:	86 00 4a 9f 	mova	#40778,	r6	;0x09f4a
    8114:	46 13       	calla	r6		;

00008116 <.LVL668>:
  if (hdr.reply) {
    8116:	41 18 05 55 	rpt #2 { rlax.w	r5		;
    811a:	74 f0 03 00 	and.b	#3,	r4	;

0000811e <.LVL669>:
    811e:	05 d4       	bis	r4,	r5	;
    8120:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    8124:	09 24       	jz	$+20     	;abs 0x8138

00008126 <.LBB85>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8126:	b0 13 18 65 	calla	#25880		;0x06518

0000812a <.LVL670>:
    812a:	c4 0c       	mova	r12,	r4	;

0000812c <.LVL671>:
    if (reply_buff == NULL) {
    812c:	9c 00 00 00 	cmpa	#0,	r12	;
    8130:	05 20       	jnz	$+12     	;abs 0x813c

00008132 <.Loc.1163.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    8132:	cc 08       	mova	r8,	r12	;
    8134:	4a 13       	calla	r10		;

00008136 <.LVL672>:
    8136:	46 13       	calla	r6		;

00008138 <.L484>:
}
    8138:	64 16       	popm.a	#7,	r10	;20-bit words
    813a:	10 01       	reta			;

0000813c <.L486>:
    reply_buff[0] = hdr.opcode;
    813c:	cc 47 00 00 	mov.b	r7,	0(r12)	;

00008140 <.Loc.1168.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8140:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    8144:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8148:	02 00 

0000814a <.Loc.1169.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    814a:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    814e:	03 00 

00008150 <.Loc.1170.2>:
    reply_buff[4] = bank0p[RegErrLogLvl];
    8150:	dc 4e 4d 00 	mov.b	77(r14),4(r12)	;0x0004d
    8154:	04 00 

00008156 <.Loc.1171.2>:
    if (hdr.crc) {
    8156:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    815a:	0d 24       	jz	$+28     	;abs 0x8176

0000815c <.Loc.1172.2>:
      reply_buff[1] = 3;
    815c:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    8160:	01 00 

00008162 <.Loc.1173.2>:
      crcGenX25(reply_buff, 7);
    8162:	7d 40 07 00 	mov.b	#7,	r13	;
    8166:	b0 13 ec 99 	calla	#39404		;0x099ec

0000816a <.L488>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    816a:	0d 49       	mov	r9,	r13	;
    816c:	cc 04       	mova	r4,	r12	;
    816e:	b0 13 58 6c 	calla	#27736		;0x06c58

00008172 <.LVL676>:
    8172:	80 00 38 81 	mova	#33080,	r0	;0x08138

00008176 <.L487>:
      reply_buff[1] = 1;
    8176:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    817a:	80 00 6a 81 	mova	#33130,	r0	;0x0816a

0000817e <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    817e:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008180 <.LCFI79>:
    8180:	c8 0c       	mova	r12,	r8	;
    8182:	2c 4d       	mov	@r13,	r12	;

00008184 <.LVL678>:
    8184:	19 4d 02 00 	mov	2(r13),	r9	;

00008188 <.LVL679>:
    8188:	05 4c       	mov	r12,	r5	;
    818a:	55 07       	rrum	#2,	r5	;
    818c:	75 f0 3f 00 	and.b	#63,	r5	;#0x003f

00008190 <.Loc.1098.2>:
  if (hdr.reply) {
    8190:	07 45       	mov	r5,	r7	;
    8192:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    8196:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    819a:	7c f0 03 00 	and.b	#3,	r12	;

0000819e <.LVL681>:
    819e:	07 dc       	bis	r12,	r7	;
    81a0:	8a 00 f6 a1 	mova	#41462,	r10	;0x0a1f6
    81a4:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    81a8:	06 24       	jz	$+14     	;abs 0x81b6

000081aa <.LBB87>:
    uint8_t * reply_buff = elyFWGetBuffer();
    81aa:	b0 13 18 65 	calla	#25880		;0x06518

000081ae <.LVL682>:
    81ae:	c6 0c       	mova	r12,	r6	;

000081b0 <.LVL683>:
    if (reply_buff == NULL) {
    81b0:	9c 00 00 00 	cmpa	#0,	r12	;
    81b4:	06 20       	jnz	$+14     	;abs 0x81c2

000081b6 <.L493>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    81b6:	cc 08       	mova	r8,	r12	;
    81b8:	4a 13       	calla	r10		;

000081ba <.LVL685>:
    81ba:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000081be <.LVL686>:
}
    81be:	55 16       	popm.a	#6,	r10	;20-bit words
    81c0:	10 01       	reta			;

000081c2 <.L494>:
    reply_buff[0] = hdr.opcode;
    81c2:	cc 45 00 00 	mov.b	r5,	0(r12)	;

000081c6 <.Loc.1107.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    81c6:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    81ca:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    81ce:	02 00 

000081d0 <.Loc.1108.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    81d0:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    81d4:	03 00 

000081d6 <.Loc.1109.2>:
    reply_buff[4] = bank0p[RegErrRptLvl];
    81d6:	dc 4e 4c 00 	mov.b	76(r14),4(r12)	;0x0004c
    81da:	04 00 

000081dc <.Loc.1110.2>:
    if (hdr.crc) {
    81dc:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    81e0:	0d 24       	jz	$+28     	;abs 0x81fc

000081e2 <.Loc.1111.2>:
      reply_buff[1] = 3;
    81e2:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    81e6:	01 00 

000081e8 <.Loc.1112.2>:
      crcGenX25(reply_buff, 7);
    81e8:	7d 40 07 00 	mov.b	#7,	r13	;
    81ec:	b0 13 ec 99 	calla	#39404		;0x099ec

000081f0 <.L497>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    81f0:	0d 49       	mov	r9,	r13	;
    81f2:	cc 06       	mova	r6,	r12	;
    81f4:	b0 13 58 6c 	calla	#27736		;0x06c58

000081f8 <.LVL689>:
    81f8:	80 00 b6 81 	mova	#33206,	r0	;0x081b6

000081fc <.L496>:
      reply_buff[1] = 1;
    81fc:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    8200:	80 00 f0 81 	mova	#33264,	r0	;0x081f0

00008204 <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8204:	4a 14       	pushm.a	#5,	r10	;20-bit words

00008206 <.LCFI80>:
    8206:	2a 4d       	mov	@r13,	r10	;

00008208 <.LVL691>:
    8208:	19 4d 02 00 	mov	2(r13),	r9	;

0000820c <.LVL692>:
    820c:	08 4a       	mov	r10,	r8	;
    820e:	58 07       	rrum	#2,	r8	;
    8210:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    8214:	47 48       	mov.b	r8,	r7	;
    8216:	06 4a       	mov	r10,	r6	;
    8218:	56 0f       	rrum	#4,	r6	;
    821a:	56 0f       	rrum	#4,	r6	;

0000821c <.Loc.1071.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    821c:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008220 <.LVL694>:
    8220:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008224 <.LVL695>:
  if (hdr.reply) {
    8224:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    8228:	7a f0 03 00 	and.b	#3,	r10	;

0000822c <.LVL696>:
    822c:	07 da       	bis	r10,	r7	;
    822e:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    8232:	32 24       	jz	$+102    	;abs 0x8298

00008234 <.LBB89>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8234:	b0 13 18 65 	calla	#25880		;0x06518

00008238 <.LVL697>:
    8238:	ca 0c       	mova	r12,	r10	;

0000823a <.LVL698>:
    if (reply_buff == NULL) {
    823a:	9c 00 00 00 	cmpa	#0,	r12	;
    823e:	2c 24       	jz	$+90     	;abs 0x8298

00008240 <.Loc.1080.2>:
    reply_buff[0] = hdr.opcode;
    8240:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00008244 <.Loc.1081.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8244:	28 01 b0 05 	mova	&66992,	r8	;0x105b0
    8248:	dc 48 51 00 	mov.b	81(r8),	2(r12)	;0x00051
    824c:	02 00 

0000824e <.Loc.1082.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    824e:	dc 48 50 00 	mov.b	80(r8),	3(r12)	;0x00050
    8252:	03 00 

00008254 <.Loc.1083.2>:
    reply_buff[1] = hdr.length + 2;
    8254:	66 53       	incd.b	r6		;
    8256:	cc 46 01 00 	mov.b	r6,	1(r12)	;

0000825a <.LVL701>:
    825a:	cc 08       	mova	r8,	r12	;
    825c:	ac 00 76 00 	adda	#118,	r12	;0x00076
    8260:	ce 0a       	mova	r10,	r14	;
    8262:	ae 00 04 00 	adda	#4,	r14	;
    8266:	a8 00 72 00 	adda	#114,	r8	;0x00072

0000826a <.L505>:
      reply_buff[i + 4] = bank0p[RegMissionTimeMsb - i];
    826a:	ee 4c 00 00 	mov.b	@r12,	0(r14)	;

0000826e <.LVL703>:
    826e:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    8272:	ae 00 01 00 	adda	#1,	r14	;

00008276 <.LVL704>:
    for (int i = 0; i < 4; i++) {
    8276:	dc 08       	cmpa	r8,	r12	;
    8278:	f8 23       	jnz	$-14     	;abs 0x826a

0000827a <.LBE90>:
    if (hdr.crc) {
    827a:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    827e:	08 24       	jz	$+18     	;abs 0x8290

00008280 <.Loc.1089.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    8280:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    8284:	2d 52       	add	#4,	r13	;r2 As==10
    8286:	40 18 0d 4d 	movx.w	r13,	r13	;
    828a:	cc 0a       	mova	r10,	r12	;
    828c:	b0 13 ec 99 	calla	#39404		;0x099ec

00008290 <.L506>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8290:	0d 49       	mov	r9,	r13	;
    8292:	cc 0a       	mova	r10,	r12	;
    8294:	b0 13 58 6c 	calla	#27736		;0x06c58

00008298 <.L501>:
}
    8298:	46 16       	popm.a	#5,	r10	;20-bit words
    829a:	10 01       	reta			;

0000829c <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    829c:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000829e <.LCFI81>:
    829e:	2e 4d       	mov	@r13,	r14	;

000082a0 <.LVL708>:
    82a0:	17 4d 02 00 	mov	2(r13),	r7	;

000082a4 <.LVL709>:
    82a4:	09 4e       	mov	r14,	r9	;
    82a6:	59 07       	rrum	#2,	r9	;
    82a8:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
    82ac:	05 4e       	mov	r14,	r5	;
    82ae:	55 0f       	rrum	#4,	r5	;
    82b0:	55 0f       	rrum	#4,	r5	;

000082b2 <.Loc.1035.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    82b2:	06 49       	mov	r9,	r6	;
    82b4:	76 f0 3f 00 	and.b	#63,	r6	;#0x003f
    82b8:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    82bc:	7e f0 03 00 	and.b	#3,	r14	;

000082c0 <.LVL711>:
    82c0:	06 de       	bis	r14,	r6	;
    82c2:	4a 46       	mov.b	r6,	r10	;
    82c4:	6a f3       	and.b	#2,	r10	;r3 As==10
    82c6:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    82ca:	0a 93       	cmp	#0,	r10	;r3 As==00
    82cc:	46 20       	jnz	$+142    	;abs 0x835a
    82ce:	6e 43       	mov.b	#2,	r14	;r3 As==10

000082d0 <.L515>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    82d0:	28 01 ac 05 	mova	&66988,	r8	;0x105ac
    82d4:	40 18 0e 4e 	movx.w	r14,	r14	;
    82d8:	ee 0c       	adda	r12,	r14	;

000082da <.LVL713>:
    82da:	e8 4e 76 00 	mov.b	@r14,	118(r8)	; 0x0076

000082de <.Loc.1039.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    82de:	d8 4e 01 00 	mov.b	1(r14),	117(r8)	; 0x0075
    82e2:	75 00 

000082e4 <.Loc.1040.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    82e4:	d8 4e 02 00 	mov.b	2(r14),	116(r8)	; 0x0074
    82e8:	74 00 

000082ea <.Loc.1041.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    82ea:	d8 4e 03 00 	mov.b	3(r14),	115(r8)	; 0x0073
    82ee:	73 00 

000082f0 <.Loc.1043.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    82f0:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000082f4 <.LVL714>:
    82f4:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000082f8 <.LVL715>:
  if (hdr.reply) {
    82f8:	0a 93       	cmp	#0,	r10	;r3 As==00
    82fa:	2d 24       	jz	$+92     	;abs 0x8356

000082fc <.LBB91>:
    uint8_t * reply_buff = elyFWGetBuffer();
    82fc:	b0 13 18 65 	calla	#25880		;0x06518

00008300 <.LVL716>:
    8300:	ca 0c       	mova	r12,	r10	;

00008302 <.LVL717>:
    if (reply_buff == NULL) {
    8302:	9c 00 00 00 	cmpa	#0,	r12	;
    8306:	27 24       	jz	$+80     	;abs 0x8356

00008308 <.Loc.1052.2>:
    reply_buff[0] = hdr.opcode;
    8308:	cc 49 00 00 	mov.b	r9,	0(r12)	;

0000830c <.Loc.1053.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    830c:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    8310:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8314:	02 00 

00008316 <.Loc.1054.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8316:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    831a:	03 00 

0000831c <.Loc.1055.2>:
    reply_buff[1] = hdr.length - 2;
    831c:	75 50 fe ff 	add.b	#-2,	r5	;#0xfffe
    8320:	4d 45       	mov.b	r5,	r13	;
    8322:	cc 45 01 00 	mov.b	r5,	1(r12)	;

00008326 <.Loc.1056.2>:
    reply_buff[4] = bank0w[RegMissionTimeMsb];
    8326:	dc 48 76 00 	mov.b	118(r8),4(r12)	;0x00076
    832a:	04 00 

0000832c <.Loc.1057.2>:
    reply_buff[5] = bank0w[RegMissionTimeHmb];
    832c:	dc 48 75 00 	mov.b	117(r8),5(r12)	;0x00075
    8330:	05 00 

00008332 <.Loc.1058.2>:
    reply_buff[6] = bank0w[RegMissionTimeLmb];
    8332:	dc 48 74 00 	mov.b	116(r8),6(r12)	;0x00074
    8336:	06 00 

00008338 <.Loc.1059.2>:
    reply_buff[7] = bank0w[RegMissionTimeLsb];
    8338:	dc 48 73 00 	mov.b	115(r8),7(r12)	;0x00073
    833c:	07 00 

0000833e <.Loc.1060.2>:
    if (hdr.crc) {
    833e:	40 18 16 b3 	bitx.w	#1,	r6	;r3 As==01
    8342:	05 24       	jz	$+12     	;abs 0x834e

00008344 <.Loc.1061.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    8344:	2d 52       	add	#4,	r13	;r2 As==10
    8346:	4d 0e       	rlam.a	#4,	r13	;
    8348:	4d 0d       	rram.a	#4,	r13	;
    834a:	b0 13 ec 99 	calla	#39404		;0x099ec

0000834e <.L519>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    834e:	0d 47       	mov	r7,	r13	;
    8350:	cc 0a       	mova	r10,	r12	;
    8352:	b0 13 58 6c 	calla	#27736		;0x06c58

00008356 <.L514>:
}
    8356:	55 16       	popm.a	#6,	r10	;20-bit words
    8358:	10 01       	reta			;

0000835a <.L520>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    835a:	6e 42       	mov.b	#4,	r14	;r2 As==10
    835c:	80 00 d0 82 	mova	#33488,	r0	;0x082d0

00008360 <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8360:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008362 <.LCFI82>:
    8362:	b1 00 04 00 	suba	#4,	r1	;

00008366 <.LCFI83>:
    8366:	ca 0c       	mova	r12,	r10	;
    8368:	2e 4d       	mov	@r13,	r14	;

0000836a <.LVL723>:
    836a:	17 4d 02 00 	mov	2(r13),	r7	;

0000836e <.LVL724>:
    836e:	09 4e       	mov	r14,	r9	;
    8370:	59 07       	rrum	#2,	r9	;
    8372:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

00008376 <.Loc.826.2>:
  if (hdr.reply) {
    8376:	0d 49       	mov	r9,	r13	;
    8378:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    837c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8380:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

00008384 <.LVL727>:
    8384:	0d de       	bis	r14,	r13	;
    8386:	45 4d       	mov.b	r13,	r5	;
    8388:	88 00 f6 a1 	mova	#41462,	r8	;0x0a1f6
    838c:	86 00 4a 9f 	mova	#40778,	r6	;0x09f4a
    8390:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    8394:	1d 24       	jz	$+60     	;abs 0x83d0

00008396 <.LBB92>:
    if ((buffer[4] < 0x40) || 
    8396:	5c 4c 04 00 	mov.b	4(r12),	r12	;

0000839a <.LVL728>:
    839a:	4e 4c       	mov.b	r12,	r14	;
    839c:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    83a0:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    83a4:	4f 9e       	cmp.b	r14,	r15	;
    83a6:	0c 28       	jnc	$+26     	;abs 0x83c0

000083a8 <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    83a8:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

000083ac <.Loc.827.2>:
    if ((buffer[4] < 0x40) || 
    83ac:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    83b0:	4f 9e       	cmp.b	r14,	r15	;
    83b2:	06 2c       	jc	$+14     	;abs 0x83c0

000083b4 <.Loc.829.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    83b4:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

000083b8 <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    83b8:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    83bc:	4e 9c       	cmp.b	r12,	r14	;
    83be:	0c 28       	jnc	$+26     	;abs 0x83d8

000083c0 <.L529>:
        gen_failure(hdr);
    83c0:	81 4d 00 00 	mov	r13,	0(r1)	;
    83c4:	81 47 02 00 	mov	r7,	2(r1)	;
    83c8:	cc 01       	mova	r1,	r12	;
    83ca:	b0 13 c2 6f 	calla	#28610		;0x06fc2

000083ce <.L535>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    83ce:	cc 0a       	mova	r10,	r12	;

000083d0 <.L528>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    83d0:	48 13       	calla	r8		;

000083d2 <.LVL731>:
    83d2:	46 13       	calla	r6		;

000083d4 <.LVL732>:
    83d4:	80 00 3a 84 	mova	#33850,	r0	;0x0843a

000083d8 <.L530>:
    uint8_t * reply_buff = elyFWGetBuffer();
    83d8:	b0 13 18 65 	calla	#25880		;0x06518

000083dc <.LVL733>:
    83dc:	c4 0c       	mova	r12,	r4	;

000083de <.LVL734>:
    if (reply_buff == NULL) {
    83de:	9c 00 00 00 	cmpa	#0,	r12	;
    83e2:	f5 27       	jz	$-20     	;abs 0x83ce

000083e4 <.Loc.844.2>:
    reply_buff[0] = hdr.opcode;
    83e4:	cc 49 00 00 	mov.b	r9,	0(r12)	;

000083e8 <.Loc.845.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    83e8:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    83ec:	d4 4c 51 00 	mov.b	81(r12),2(r4)	;0x00051
    83f0:	02 00 

000083f2 <.Loc.846.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    83f2:	d4 4c 50 00 	mov.b	80(r12),3(r4)	;0x00050
    83f6:	03 00 

000083f8 <.Loc.849.2>:
    size_t n = elyChanGetValue(&reply_buff[4], buffer[4]);
    83f8:	5d 4a 04 00 	mov.b	4(r10),	r13	;
    83fc:	cc 04       	mova	r4,	r12	;
    83fe:	ac 00 04 00 	adda	#4,	r12	;
    8402:	b0 13 e4 94 	calla	#38116		;0x094e4

00008406 <.LVL735>:
    8406:	c9 0c       	mova	r12,	r9	;

00008408 <.LVL736>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8408:	cc 0a       	mova	r10,	r12	;
    840a:	48 13       	calla	r8		;

0000840c <.LVL737>:
    840c:	46 13       	calla	r6		;

0000840e <.LVL738>:
    840e:	09 14       	pushm.a	#1,	r9	;20-bit words
    8410:	40 18 3c 41 	popx.w	r12		;
    8414:	40 18 3d 41 	popx.w	r13		;

00008418 <.Loc.853.2>:
    if (hdr.crc) {
    8418:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    841c:	12 24       	jz	$+38     	;abs 0x8442

0000841e <.Loc.854.2>:
      reply_buff[1] = n + 3;
    841e:	7c 50 03 00 	add.b	#3,	r12	;
    8422:	c4 4c 01 00 	mov.b	r12,	1(r4)	;

00008426 <.Loc.855.2>:
      crcGenX25(reply_buff, 7+n);
    8426:	cd 09       	mova	r9,	r13	;
    8428:	ad 00 07 00 	adda	#7,	r13	;
    842c:	cc 04       	mova	r4,	r12	;
    842e:	b0 13 ec 99 	calla	#39404		;0x099ec

00008432 <.L534>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8432:	0d 47       	mov	r7,	r13	;
    8434:	cc 04       	mova	r4,	r12	;
    8436:	b0 13 58 6c 	calla	#27736		;0x06c58

0000843a <.L527>:
}
    843a:	a1 00 04 00 	adda	#4,	r1	;
    843e:	64 16       	popm.a	#7,	r10	;20-bit words
    8440:	10 01       	reta			;

00008442 <.L533>:
      reply_buff[1] = n + 1;
    8442:	5c 53       	inc.b	r12		;
    8444:	c4 4c 01 00 	mov.b	r12,	1(r4)	;
    8448:	80 00 32 84 	mova	#33842,	r0	;0x08432

0000844c <get_u32>:
    const uint32_t max, const uint32_t min) {
    844c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000844e <.LCFI84>:
    844e:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00008452 <.LCFI85>:
    8452:	46 4c       	mov.b	r12,	r6	;
    8454:	2c 4d       	mov	@r13,	r12	;

00008456 <.LVL743>:
    8456:	91 4d 02 00 	mov	2(r13),	12(r1)	; 0x000c
    845a:	0c 00 
    845c:	07 4e       	mov	r14,	r7	;
    845e:	08 4f       	mov	r15,	r8	;
    8460:	91 41 2e 00 	mov	46(r1),	8(r1)	;0x0002e
    8464:	08 00 
    8466:	15 41 30 00 	mov	48(r1),	r5	;0x00030
    846a:	09 4c       	mov	r12,	r9	;
    846c:	59 07       	rrum	#2,	r9	;
    846e:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

00008472 <.Loc.85.2>:
  if (hdr.reply) {
    8472:	0d 49       	mov	r9,	r13	;
    8474:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    8478:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    847c:	7c f0 03 00 	and.b	#3,	r12	;

00008480 <.LVL746>:
    8480:	0c dd       	bis	r13,	r12	;
    8482:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    8486:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    848a:	71 24       	jz	$+228    	;abs 0x856e

0000848c <.LBB95>:
    uint8_t * reply_buff = elyFWGetBuffer();
    848c:	b0 13 18 65 	calla	#25880		;0x06518

00008490 <.LVL747>:
    8490:	ca 0c       	mova	r12,	r10	;

00008492 <.LVL748>:
    if (reply_buff == NULL) {
    8492:	9c 00 00 00 	cmpa	#0,	r12	;
    8496:	6b 24       	jz	$+216    	;abs 0x856e

00008498 <.Loc.92.2>:
    reply_buff[0] = hdr.opcode;
    8498:	cc 49 00 00 	mov.b	r9,	0(r12)	;

0000849c <.Loc.93.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    849c:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    84a0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    84a4:	02 00 

000084a6 <.Loc.94.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    84a6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    84aa:	03 00 

000084ac <.LVL749>:
    84ac:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    84b0:	04 00 
    84b2:	3b 01 04 00 	mova	4(r1),	r11	;
    84b6:	eb 0c       	adda	r12,	r11	;
    84b8:	44 43       	clr.b	r4		;

000084ba <.Loc.96.2>:
    uint32_t val = 0;
    84ba:	09 44       	mov	r4,	r9	;
    84bc:	06 44       	mov	r4,	r6	;

000084be <.L540>:
      val |= ((uint32_t)(bank0p[addr + i]) << (8 * i));
    84be:	6c 4b       	mov.b	@r11,	r12	;
    84c0:	0d 43       	clr	r13		;
    84c2:	0e 44       	mov	r4,	r14	;
    84c4:	0f 43       	clr	r15		;
    84c6:	71 0b 00 00 	mova	r11,	0(r1)	;
    84ca:	b0 13 2a a3 	calla	#41770		;0x0a32a
    84ce:	0c d9       	bis	r9,	r12	;
    84d0:	0d d6       	bis	r6,	r13	;
    84d2:	09 4c       	mov	r12,	r9	;

000084d4 <.LVL753>:
    84d4:	06 4d       	mov	r13,	r6	;

000084d6 <.LVL754>:
    84d6:	0b 01       	mova	@r1,	r11	;
    84d8:	ab 00 01 00 	adda	#1,	r11	;
    84dc:	34 52       	add	#8,	r4	;r2 As==11

000084de <.Loc.97.2>:
    for (int i = 0; i < 4; i++) {
    84de:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    84e2:	ed 23       	jnz	$-36     	;abs 0x84be

000084e4 <.LBE96>:
    if (val > max) {
    84e4:	08 9d       	cmp	r13,	r8	;
    84e6:	04 28       	jnc	$+10     	;abs 0x84f0
    84e8:	0d 98       	cmp	r8,	r13	;
    84ea:	45 20       	jnz	$+140    	;abs 0x8576
    84ec:	07 9c       	cmp	r12,	r7	;
    84ee:	43 2c       	jc	$+136    	;abs 0x8576

000084f0 <.L549>:
    84f0:	36 01 04 00 	mova	4(r1),	r6	;

000084f4 <.LVL755>:
    84f4:	80 18 56 52 	addx.a	&0x105ac,r6	;
    84f8:	ac 05 

000084fa <.LBB97>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    84fa:	49 43       	clr.b	r9		;

000084fc <.L543>:
    84fc:	0c 47       	mov	r7,	r12	;
    84fe:	0d 48       	mov	r8,	r13	;
    8500:	0e 49       	mov	r9,	r14	;
    8502:	0f 43       	clr	r15		;
    8504:	b0 13 de a3 	calla	#41950		;0x0a3de
    8508:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    850c:	39 52       	add	#8,	r9	;r2 As==11
    850e:	a6 00 01 00 	adda	#1,	r6	;

00008512 <.Loc.103.2>:
      for (int i = 0; i < 4; i++) {
    8512:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    8516:	f2 23       	jnz	$-26     	;abs 0x84fc
    8518:	09 47       	mov	r7,	r9	;
    851a:	06 48       	mov	r8,	r6	;

0000851c <.L544>:
      reply_buff[i + 4] = ((val >> (8 * (3 - i))) & 0xFF);
    851c:	0c 49       	mov	r9,	r12	;
    851e:	0d 46       	mov	r6,	r13	;
    8520:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    8524:	b0 13 de a3 	calla	#41950		;0x0a3de
    8528:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

0000852c <.LVL762>:
    852c:	0c 49       	mov	r9,	r12	;
    852e:	0d 46       	mov	r6,	r13	;
    8530:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8534:	b0 13 de a3 	calla	#41950		;0x0a3de
    8538:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

0000853c <.LVL764>:
    853c:	0c 49       	mov	r9,	r12	;
    853e:	0d 46       	mov	r6,	r13	;
    8540:	b0 13 a4 a3 	calla	#41892		;0x0a3a4
    8544:	ca 4c 06 00 	mov.b	r12,	6(r10)	;

00008548 <.LVL766>:
    8548:	ca 49 07 00 	mov.b	r9,	7(r10)	;

0000854c <.LBE98>:
    if (hdr.crc) {
    854c:	40 18 91 b3 	bitx.w	#1,	10(r1)	;r3 As==01, 0x0000a
    8550:	0a 00 
    8552:	32 24       	jz	$+102    	;abs 0x85b8

00008554 <.Loc.119.2>:
      reply_buff[1] = 6;
    8554:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8558:	01 00 

0000855a <.Loc.120.2>:
      crcGenX25(reply_buff, 10);
    855a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    855e:	cc 0a       	mova	r10,	r12	;
    8560:	b0 13 ec 99 	calla	#39404		;0x099ec

00008564 <.L548>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8564:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8568:	cc 0a       	mova	r10,	r12	;
    856a:	b0 13 58 6c 	calla	#27736		;0x06c58

0000856e <.L536>:
}
    856e:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    8572:	64 16       	popm.a	#7,	r10	;20-bit words
    8574:	10 01       	reta			;

00008576 <.L541>:
    else if (val < min) {
    8576:	0d 95       	cmp	r5,	r13	;
    8578:	05 28       	jnc	$+12     	;abs 0x8584
    857a:	05 9d       	cmp	r13,	r5	;
    857c:	cf 23       	jnz	$-96     	;abs 0x851c
    857e:	1c 91 08 00 	cmp	8(r1),	r12	;
    8582:	cc 2f       	jc	$-102    	;abs 0x851c

00008584 <.L550>:
    8584:	36 01 04 00 	mova	4(r1),	r6	;

00008588 <.LVL771>:
    8588:	80 18 56 52 	addx.a	&0x105ac,r6	;
    858c:	ac 05 

0000858e <.LBB99>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    858e:	49 43       	clr.b	r9		;

00008590 <.L546>:
    8590:	1c 41 08 00 	mov	8(r1),	r12	;
    8594:	0d 45       	mov	r5,	r13	;
    8596:	0e 49       	mov	r9,	r14	;
    8598:	0f 43       	clr	r15		;
    859a:	b0 13 de a3 	calla	#41950		;0x0a3de
    859e:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    85a2:	39 52       	add	#8,	r9	;r2 As==11
    85a4:	a6 00 01 00 	adda	#1,	r6	;

000085a8 <.Loc.109.2>:
      for (int i = 0; i < 4; i++) {
    85a8:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    85ac:	f1 23       	jnz	$-28     	;abs 0x8590
    85ae:	19 41 08 00 	mov	8(r1),	r9	;
    85b2:	06 45       	mov	r5,	r6	;
    85b4:	80 00 1c 85 	mova	#34076,	r0	;0x0851c

000085b8 <.L547>:
      reply_buff[1] = 4;
    85b8:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    85bc:	80 00 64 85 	mova	#34148,	r0	;0x08564

000085c0 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    85c0:	19 14       	pushm.a	#2,	r9	;20-bit words

000085c2 <.LCFI86>:
    85c2:	b1 00 08 00 	suba	#8,	r1	;

000085c6 <.LCFI87>:
    85c6:	28 4d       	mov	@r13,	r8	;

000085c8 <.LVL779>:
    85c8:	19 4d 02 00 	mov	2(r13),	r9	;

000085cc <.LVL780>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    85cc:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000085d0 <.LVL781>:
    85d0:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000085d4 <.LVL782>:
  get_u32(RegUARTBaudLsb, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    85d4:	81 48 04 00 	mov	r8,	4(r1)	;
    85d8:	81 49 06 00 	mov	r9,	6(r1)	;
    85dc:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    85e0:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    85e4:	3e 40 40 42 	mov	#16960,	r14	;#0x4240
    85e8:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    85ec:	cd 01       	mova	r1,	r13	;
    85ee:	ad 00 04 00 	adda	#4,	r13	;
    85f2:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    85f6:	b0 13 4c 84 	calla	#33868		;0x0844c

000085fa <.LVL783>:
}
    85fa:	a1 00 08 00 	adda	#8,	r1	;
    85fe:	18 16       	popm.a	#2,	r9	;20-bit words
    8600:	10 01       	reta			;

00008602 <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8602:	19 14       	pushm.a	#2,	r9	;20-bit words

00008604 <.LCFI88>:
    8604:	b1 00 08 00 	suba	#8,	r1	;

00008608 <.LCFI89>:
    8608:	28 4d       	mov	@r13,	r8	;

0000860a <.LVL785>:
    860a:	19 4d 02 00 	mov	2(r13),	r9	;

0000860e <.LVL786>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    860e:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008612 <.LVL787>:
    8612:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008616 <.LVL788>:
  get_u32(RegRXDevLsb, hdr, RX_DEV_MAX, RX_DEV_MIN);
    8616:	81 48 04 00 	mov	r8,	4(r1)	;
    861a:	81 49 06 00 	mov	r9,	6(r1)	;
    861e:	b1 40 e8 80 	mov	#-32536,0(r1)	;#0x80e8
    8622:	00 00 
    8624:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8628:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    862c:	7f 40 03 00 	mov.b	#3,	r15	;
    8630:	cd 01       	mova	r1,	r13	;
    8632:	ad 00 04 00 	adda	#4,	r13	;
    8636:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c
    863a:	b0 13 4c 84 	calla	#33868		;0x0844c

0000863e <.LVL789>:
}
    863e:	a1 00 08 00 	adda	#8,	r1	;
    8642:	18 16       	popm.a	#2,	r9	;20-bit words
    8644:	10 01       	reta			;

00008646 <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8646:	19 14       	pushm.a	#2,	r9	;20-bit words

00008648 <.LCFI90>:
    8648:	b1 00 08 00 	suba	#8,	r1	;

0000864c <.LCFI91>:
    864c:	28 4d       	mov	@r13,	r8	;

0000864e <.LVL791>:
    864e:	19 4d 02 00 	mov	2(r13),	r9	;

00008652 <.LVL792>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8652:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008656 <.LVL793>:
    8656:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000865a <.LVL794>:
  get_u32(RegTXDevLsb, hdr, TX_DEV_MAX, TX_DEV_MIN);
    865a:	81 48 04 00 	mov	r8,	4(r1)	;
    865e:	81 49 06 00 	mov	r9,	6(r1)	;
    8662:	b1 40 58 02 	mov	#600,	0(r1)	;#0x0258
    8666:	00 00 
    8668:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    866c:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    8670:	7f 40 03 00 	mov.b	#3,	r15	;
    8674:	cd 01       	mova	r1,	r13	;
    8676:	ad 00 04 00 	adda	#4,	r13	;
    867a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    867c:	b0 13 4c 84 	calla	#33868		;0x0844c

00008680 <.LVL795>:
}
    8680:	a1 00 08 00 	adda	#8,	r1	;
    8684:	18 16       	popm.a	#2,	r9	;20-bit words
    8686:	10 01       	reta			;

00008688 <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8688:	19 14       	pushm.a	#2,	r9	;20-bit words

0000868a <.LCFI92>:
    868a:	b1 00 08 00 	suba	#8,	r1	;

0000868e <.LCFI93>:
    868e:	28 4d       	mov	@r13,	r8	;

00008690 <.LVL797>:
    8690:	19 4d 02 00 	mov	2(r13),	r9	;

00008694 <.LVL798>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8694:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008698 <.LVL799>:
    8698:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000869c <.LVL800>:
  get_u32(RegRXBRLsb, hdr, RX_BR_MAX, RX_BR_MIN);
    869c:	81 48 04 00 	mov	r8,	4(r1)	;
    86a0:	81 49 06 00 	mov	r9,	6(r1)	;
    86a4:	b1 40 0c 03 	mov	#780,	0(r1)	;#0x030c
    86a8:	00 00 
    86aa:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    86ae:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    86b2:	6f 43       	mov.b	#2,	r15	;r3 As==10
    86b4:	cd 01       	mova	r1,	r13	;
    86b6:	ad 00 04 00 	adda	#4,	r13	;
    86ba:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c
    86be:	b0 13 4c 84 	calla	#33868		;0x0844c

000086c2 <.LVL801>:
}
    86c2:	a1 00 08 00 	adda	#8,	r1	;
    86c6:	18 16       	popm.a	#2,	r9	;20-bit words
    86c8:	10 01       	reta			;

000086ca <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    86ca:	19 14       	pushm.a	#2,	r9	;20-bit words

000086cc <.LCFI94>:
    86cc:	b1 00 08 00 	suba	#8,	r1	;

000086d0 <.LCFI95>:
    86d0:	28 4d       	mov	@r13,	r8	;

000086d2 <.LVL803>:
    86d2:	19 4d 02 00 	mov	2(r13),	r9	;

000086d6 <.LVL804>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    86d6:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000086da <.LVL805>:
    86da:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000086de <.LVL806>:
  get_u32(RegTXBRLsb, hdr, TX_BR_MAX, TX_BR_MIN);
    86de:	81 48 04 00 	mov	r8,	4(r1)	;
    86e2:	81 49 06 00 	mov	r9,	6(r1)	;
    86e6:	b1 40 b0 04 	mov	#1200,	0(r1)	;#0x04b0
    86ea:	00 00 
    86ec:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    86f0:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    86f4:	6f 42       	mov.b	#4,	r15	;r2 As==10
    86f6:	cd 01       	mova	r1,	r13	;
    86f8:	ad 00 04 00 	adda	#4,	r13	;
    86fc:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    8700:	b0 13 4c 84 	calla	#33868		;0x0844c

00008704 <.LVL807>:
}
    8704:	a1 00 08 00 	adda	#8,	r1	;
    8708:	18 16       	popm.a	#2,	r9	;20-bit words
    870a:	10 01       	reta			;

0000870c <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    870c:	19 14       	pushm.a	#2,	r9	;20-bit words

0000870e <.LCFI96>:
    870e:	b1 00 08 00 	suba	#8,	r1	;

00008712 <.LCFI97>:
    8712:	28 4d       	mov	@r13,	r8	;

00008714 <.LVL809>:
    8714:	19 4d 02 00 	mov	2(r13),	r9	;

00008718 <.LVL810>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8718:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

0000871c <.LVL811>:
    871c:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008720 <.LVL812>:
  get_u32(RegRXFreqLsb, hdr, RX_BAND_MAX, RX_BAND_MIN);
    8720:	81 48 04 00 	mov	r8,	4(r1)	;
    8724:	81 49 06 00 	mov	r9,	6(r1)	;
    8728:	b1 40 40 44 	mov	#17472,	0(r1)	;#0x4440
    872c:	00 00 
    872e:	b1 40 3d 1b 	mov	#6973,	2(r1)	;#0x1b3d
    8732:	02 00 
    8734:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    8738:	3f 40 12 1c 	mov	#7186,	r15	;#0x1c12
    873c:	cd 01       	mova	r1,	r13	;
    873e:	ad 00 04 00 	adda	#4,	r13	;
    8742:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8744:	b0 13 4c 84 	calla	#33868		;0x0844c

00008748 <.LVL813>:
}
    8748:	a1 00 08 00 	adda	#8,	r1	;
    874c:	18 16       	popm.a	#2,	r9	;20-bit words
    874e:	10 01       	reta			;

00008750 <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8750:	19 14       	pushm.a	#2,	r9	;20-bit words

00008752 <.LCFI98>:
    8752:	b1 00 08 00 	suba	#8,	r1	;

00008756 <.LCFI99>:
    8756:	28 4d       	mov	@r13,	r8	;

00008758 <.LVL815>:
    8758:	19 4d 02 00 	mov	2(r13),	r9	;

0000875c <.LVL816>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    875c:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008760 <.LVL817>:
    8760:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008764 <.LVL818>:
  get_u32(RegTXFreqLsb, hdr, TX_BAND_MAX, TX_BAND_MIN);
    8764:	81 48 04 00 	mov	r8,	4(r1)	;
    8768:	81 49 06 00 	mov	r9,	6(r1)	;
    876c:	b1 40 40 da 	mov	#-9664,	0(r1)	;#0xda40
    8770:	00 00 
    8772:	b1 40 8e 33 	mov	#13198,	2(r1)	;#0x338e
    8776:	02 00 
    8778:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    877c:	3f 40 ec 38 	mov	#14572,	r15	;#0x38ec
    8780:	cd 01       	mova	r1,	r13	;
    8782:	ad 00 04 00 	adda	#4,	r13	;
    8786:	4c 43       	clr.b	r12		;
    8788:	b0 13 4c 84 	calla	#33868		;0x0844c

0000878c <.LVL819>:
}
    878c:	a1 00 08 00 	adda	#8,	r1	;
    8790:	18 16       	popm.a	#2,	r9	;20-bit words
    8792:	10 01       	reta			;

00008794 <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8794:	4a 14       	pushm.a	#5,	r10	;20-bit words

00008796 <.LCFI100>:
    8796:	c8 0c       	mova	r12,	r8	;
    8798:	2a 4d       	mov	@r13,	r10	;

0000879a <.LVL821>:
    879a:	16 4d 02 00 	mov	2(r13),	r6	;

0000879e <.LVL822>:
    879e:	07 4a       	mov	r10,	r7	;
    87a0:	57 07       	rrum	#2,	r7	;
    87a2:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    87a6:	49 47       	mov.b	r7,	r9	;

000087a8 <.Loc.579.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    87a8:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000087ac <.LVL824>:
    87ac:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000087b0 <.LVL825>:
  if (hdr.reply) {
    87b0:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    87b4:	7a f0 03 00 	and.b	#3,	r10	;

000087b8 <.LVL826>:
    87b8:	09 da       	bis	r10,	r9	;
    87ba:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    87be:	22 24       	jz	$+70     	;abs 0x8804

000087c0 <.LBB101>:
    uint8_t * reply_buff = elyFWGetBuffer();
    87c0:	b0 13 18 65 	calla	#25880		;0x06518

000087c4 <.LVL827>:
    87c4:	ca 0c       	mova	r12,	r10	;

000087c6 <.LVL828>:
    if (reply_buff == NULL) {
    87c6:	9c 00 00 00 	cmpa	#0,	r12	;
    87ca:	1c 24       	jz	$+58     	;abs 0x8804

000087cc <.Loc.588.2>:
    reply_buff[0] = hdr.opcode;
    87cc:	cc 47 00 00 	mov.b	r7,	0(r12)	;

000087d0 <.Loc.589.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    87d0:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    87d4:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    87d8:	02 00 

000087da <.Loc.590.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    87da:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    87de:	03 00 

000087e0 <.Loc.591.2>:
    reply_buff[4] = bank0p[RegOutputPower];
    87e0:	da 4c 21 00 	mov.b	33(r12),4(r10)	;0x00021
    87e4:	04 00 

000087e6 <.Loc.592.2>:
    if (hdr.crc) {
    87e6:	40 18 19 b3 	bitx.w	#1,	r9	;r3 As==01
    87ea:	0e 24       	jz	$+30     	;abs 0x8808

000087ec <.Loc.593.2>:
      reply_buff[1] = 3;
    87ec:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    87f0:	01 00 

000087f2 <.Loc.594.2>:
      crcGenX25(buffer, 7);
    87f2:	7d 40 07 00 	mov.b	#7,	r13	;
    87f6:	cc 08       	mova	r8,	r12	;
    87f8:	b0 13 ec 99 	calla	#39404		;0x099ec

000087fc <.L569>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    87fc:	0d 46       	mov	r6,	r13	;
    87fe:	cc 0a       	mova	r10,	r12	;
    8800:	b0 13 58 6c 	calla	#27736		;0x06c58

00008804 <.L564>:
}
    8804:	46 16       	popm.a	#5,	r10	;20-bit words
    8806:	10 01       	reta			;

00008808 <.L568>:
      reply_buff[1] = 1;
    8808:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01
    880c:	80 00 fc 87 	mova	#34812,	r0	;0x087fc

00008810 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8810:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008812 <.LCFI101>:
    8812:	b1 00 16 00 	suba	#22,	r1	;0x00016

00008816 <.LCFI102>:
    8816:	71 0c 08 00 	mova	r12,	8(r1)	;
    881a:	2a 4d       	mov	@r13,	r10	;

0000881c <.LVL833>:
    881c:	15 4d 02 00 	mov	2(r13),	r5	;

00008820 <.LVL834>:
    8820:	09 4a       	mov	r10,	r9	;
    8822:	59 0f       	rrum	#4,	r9	;
    8824:	59 0f       	rrum	#4,	r9	;

00008826 <.Loc.405.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8826:	4f 4a       	mov.b	r10,	r15	;
    8828:	4b 4f       	mov.b	r15,	r11	;
    882a:	6b f3       	and.b	#2,	r11	;r3 As==10
    882c:	47 4b       	mov.b	r11,	r7	;
    882e:	07 93       	cmp	#0,	r7	;r3 As==00
    8830:	26 20       	jnz	$+78     	;abs 0x887e
    8832:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008834 <.L574>:
  uint8_t bank = buffer[hdr_ext];
    8834:	40 18 06 4d 	movx.w	r13,	r6	;
    8838:	3c 01 08 00 	mova	8(r1),	r12	;

0000883c <.LVL837>:
    883c:	ec 06       	adda	r6,	r12	;
    883e:	64 4c       	mov.b	@r12,	r4	;
    8840:	81 44 10 00 	mov	r4,	16(r1)	; 0x0010

00008844 <.LVL838>:
  uint8_t addr = buffer[hdr_ext+1];
    8844:	54 4c 01 00 	mov.b	1(r12),	r4	;

00008848 <.LVL839>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8848:	1f b3       	bit	#1,	r15	;r3 As==01
    884a:	1c 20       	jnz	$+58     	;abs 0x8884

0000884c <.Loc.408.2>:
    884c:	4d 43       	clr.b	r13		;

0000884e <.L575>:
  uint8_t * reply_buff = elyFWGetBuffer();
    884e:	71 0b 00 00 	mova	r11,	0(r1)	;

00008852 <.LVL841>:
    8852:	71 0d 04 00 	mova	r13,	4(r1)	;
    8856:	b0 13 18 65 	calla	#25880		;0x06518

0000885a <.LVL842>:
    885a:	c8 0c       	mova	r12,	r8	;

0000885c <.LVL843>:
    885c:	8e 00 f6 a1 	mova	#41462,	r14	;0x0a1f6

00008860 <.Loc.410.2>:
  if (reply_buff == NULL) {
    8860:	0b 01       	mova	@r1,	r11	;
    8862:	3d 01 04 00 	mova	4(r1),	r13	;
    8866:	9c 00 00 00 	cmpa	#0,	r12	;
    886a:	0f 20       	jnz	$+32     	;abs 0x888a

0000886c <.L582>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    886c:	3c 01 08 00 	mova	8(r1),	r12	;
    8870:	4e 13       	calla	r14		;

00008872 <.LVL845>:
    8872:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008876 <.L573>:
}
    8876:	a1 00 16 00 	adda	#22,	r1	;0x00016
    887a:	64 16       	popm.a	#7,	r10	;20-bit words
    887c:	10 01       	reta			;

0000887e <.L584>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    887e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8880:	80 00 34 88 	mova	#34868,	r0	;0x08834

00008884 <.L585>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8884:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008886 <.LVL850>:
    8886:	80 00 4e 88 	mova	#34894,	r0	;0x0884e

0000888a <.L576>:
  if (bank == 0 || bank > 4 || 
    888a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    888e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8890:	7f 40 03 00 	mov.b	#3,	r15	;
    8894:	4f 9c       	cmp.b	r12,	r15	;
    8896:	21 28       	jnc	$+68     	;abs 0x88da

00008898 <.Loc.408.2>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8898:	4f 49       	mov.b	r9,	r15	;
    889a:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe
    889e:	4f 8b       	sub.b	r11,	r15	;
    88a0:	4f 8d       	sub.b	r13,	r15	;
    88a2:	4c 4f       	mov.b	r15,	r12	;

000088a4 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    88a4:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    88a8:	57 00 
    88aa:	40 18 0d 8c 	subx.w	r12,	r13	;

000088ae <.Loc.417.2>:
  if (bank == 0 || bank > 4 || 
    88ae:	04 9d       	cmp	r13,	r4	;
    88b0:	02 38       	jl	$+6      	;abs 0x88b6

000088b2 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    88b2:	44 93       	cmp.b	#0,	r4	;r3 As==00
    88b4:	12 34       	jge	$+38     	;abs 0x88da

000088b6 <.L579>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    88b6:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    88ba:	8b 00 
    88bc:	40 18 0d 8c 	subx.w	r12,	r13	;

000088c0 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    88c0:	04 9d       	cmp	r13,	r4	;
    88c2:	04 38       	jl	$+10     	;abs 0x88cc

000088c4 <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    88c4:	7b 40 bf ff 	mov.b	#-65,	r11	;#0xffbf
    88c8:	4b 94       	cmp.b	r4,	r11	;
    88ca:	07 2c       	jc	$+16     	;abs 0x88da

000088cc <.L580>:
      (addr >= RegDLLMAX - count + 1)) {
    88cc:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    88d0:	d6 00 
    88d2:	40 18 0d 8c 	subx.w	r12,	r13	;

000088d6 <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    88d6:	04 9d       	cmp	r13,	r4	;
    88d8:	1b 38       	jl	$+56     	;abs 0x8910

000088da <.L578>:
    if (hdr.reply) {
    88da:	07 93       	cmp	#0,	r7	;r3 As==00
    88dc:	c7 27       	jz	$-112    	;abs 0x886c

000088de <.Loc.422.2>:
      write_failure(reply_buff, hdr);
    88de:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    88e2:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000088e6 <.LVL854>:
    88e6:	0a d9       	bis	r9,	r10	;
    88e8:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    88ec:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    88f0:	cd 01       	mova	r1,	r13	;
    88f2:	ad 00 12 00 	adda	#18,	r13	;0x00012
    88f6:	cc 08       	mova	r8,	r12	;
    88f8:	71 0e 04 00 	mova	r14,	4(r1)	;
    88fc:	b0 13 10 66 	calla	#26128		;0x06610

00008900 <.LVL855>:
      elyCmdSendReply(reply_buff, hdr.reply_addr);
    8900:	0d 45       	mov	r5,	r13	;
    8902:	cc 08       	mova	r8,	r12	;
    8904:	b0 13 58 6c 	calla	#27736		;0x06c58

00008908 <.LVL856>:
    8908:	3e 01 04 00 	mova	4(r1),	r14	;
    890c:	80 00 6c 88 	mova	#34924,	r0	;0x0886c

00008910 <.L581>:
  memcpy(reply_buff + 4, buffer + hdr_ext + 2, count);
    8910:	cd 06       	mova	r6,	r13	;
    8912:	ad 00 02 00 	adda	#2,	r13	;
    8916:	40 18 0e 4f 	movx.w	r15,	r14	;
    891a:	00 18 5d 51 	addx.a	8(r1),	r13	;
    891e:	08 00 
    8920:	cb 08       	mova	r8,	r11	;
    8922:	ab 00 04 00 	adda	#4,	r11	;
    8926:	71 0b 0c 00 	mova	r11,	12(r1)	; 0x0000c
    892a:	cc 0b       	mova	r11,	r12	;
    892c:	71 0f 04 00 	mova	r15,	4(r1)	;
    8930:	b0 13 06 a4 	calla	#41990		;0x0a406

00008934 <.LVL858>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8934:	86 00 f6 a1 	mova	#41462,	r6	;0x0a1f6

00008938 <.LVL859>:
    8938:	3c 01 08 00 	mova	8(r1),	r12	;
    893c:	46 13       	calla	r6		;

0000893e <.LVL860>:
    893e:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008942 <.LVL861>:
  elyRegSetBlock(bank, reply_buff + 4, addr, count);
    8942:	3f 01 04 00 	mova	4(r1),	r15	;
    8946:	4e 44       	mov.b	r4,	r14	;
    8948:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    894c:	14 41 10 00 	mov	16(r1),	r4	;0x00010

00008950 <.LVL862>:
    8950:	4c 44       	mov.b	r4,	r12	;
    8952:	b0 13 78 94 	calla	#38008		;0x09478

00008956 <.LVL863>:
  if (hdr.reply) {
    8956:	07 93       	cmp	#0,	r7	;r3 As==00
    8958:	15 24       	jz	$+44     	;abs 0x8984

0000895a <.Loc.437.2>:
    write_success(reply_buff, hdr);
    895a:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    895e:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00008962 <.LVL866>:
    8962:	0a d9       	bis	r9,	r10	;
    8964:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    8968:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    896c:	cd 01       	mova	r1,	r13	;
    896e:	ad 00 12 00 	adda	#18,	r13	;0x00012
    8972:	cc 08       	mova	r8,	r12	;
    8974:	b0 13 f2 67 	calla	#26610		;0x067f2

00008978 <.LVL867>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8978:	0d 45       	mov	r5,	r13	;
    897a:	cc 08       	mova	r8,	r12	;
    897c:	b0 13 58 6c 	calla	#27736		;0x06c58

00008980 <.LVL868>:
    8980:	80 00 76 88 	mova	#34934,	r0	;0x08876

00008984 <.L583>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    8984:	cc 08       	mova	r8,	r12	;
    8986:	46 13       	calla	r6		;

00008988 <.LVL870>:
    8988:	b0 13 7a 65 	calla	#25978		;0x0657a

0000898c <.LVL871>:
    898c:	80 00 76 88 	mova	#34934,	r0	;0x08876

00008990 <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8990:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008992 <.LCFI103>:
    8992:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00008996 <.LCFI104>:
    8996:	2f 4d       	mov	@r13,	r15	;

00008998 <.LVL873>:
    8998:	16 4d 02 00 	mov	2(r13),	r6	;

0000899c <.LVL874>:
    899c:	07 4f       	mov	r15,	r7	;
    899e:	57 07       	rrum	#2,	r7	;
    89a0:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f

000089a4 <.Loc.358.2>:
  if (hdr.reply) { /* reply requested */
    89a4:	08 47       	mov	r7,	r8	;
    89a6:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    89aa:	41 18 08 58 	rpt #2 { rlax.w	r8		;
    89ae:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

000089b2 <.LVL876>:
    89b2:	08 df       	bis	r15,	r8	;
    89b4:	45 48       	mov.b	r8,	r5	;
    89b6:	8f 00 f6 a1 	mova	#41462,	r15	;0x0a1f6
    89ba:	84 00 4a 9f 	mova	#40778,	r4	;0x09f4a
    89be:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    89c2:	0e 24       	jz	$+30     	;abs 0x89e0

000089c4 <.LBB103>:
    uint8_t * reply_buff = elyFWGetBuffer();
    89c4:	71 0c 04 00 	mova	r12,	4(r1)	;
    89c8:	71 0f 00 00 	mova	r15,	0(r1)	;
    89cc:	b0 13 18 65 	calla	#25880		;0x06518

000089d0 <.LVL878>:
    89d0:	ca 0c       	mova	r12,	r10	;

000089d2 <.LVL879>:
    if (reply_buff == NULL) {
    89d2:	3e 01 04 00 	mova	4(r1),	r14	;
    89d6:	0f 01       	mova	@r1,	r15	;
    89d8:	9c 00 00 00 	cmpa	#0,	r12	;
    89dc:	05 20       	jnz	$+12     	;abs 0x89e8

000089de <.Loc.362.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    89de:	cc 0e       	mova	r14,	r12	;

000089e0 <.L590>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    89e0:	4f 13       	calla	r15		;

000089e2 <.LVL881>:
    89e2:	44 13       	calla	r4		;

000089e4 <.LVL882>:
    89e4:	80 00 70 8a 	mova	#35440,	r0	;0x08a70

000089e8 <.L591>:
    uint8_t bank = buffer[4];
    89e8:	5b 4e 04 00 	mov.b	4(r14),	r11	;

000089ec <.LVL884>:
    uint8_t addr = buffer[5];
    89ec:	5d 4e 05 00 	mov.b	5(r14),	r13	;

000089f0 <.LVL885>:
    uint8_t count = buffer[6];
    89f0:	59 4e 06 00 	mov.b	6(r14),	r9	;

000089f4 <.LVL886>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    89f4:	cc 0e       	mova	r14,	r12	;
    89f6:	71 0b 04 00 	mova	r11,	4(r1)	;

000089fa <.LVL887>:
    89fa:	71 0d 00 00 	mova	r13,	0(r1)	;
    89fe:	4f 13       	calla	r15		;

00008a00 <.LVL888>:
    8a00:	44 13       	calla	r4		;

00008a02 <.LVL889>:
    if (bank > 4 || 
    8a02:	3b 01 04 00 	mova	4(r1),	r11	;
    8a06:	0d 01       	mova	@r1,	r13	;
    8a08:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8a0a:	4c 9b       	cmp.b	r11,	r12	;
    8a0c:	23 28       	jnc	$+72     	;abs 0x8a54

00008a0e <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    8a0e:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    8a12:	57 00 
    8a14:	40 18 0c 89 	subx.w	r9,	r12	;

00008a18 <.Loc.373.2>:
    if (bank > 4 || 
    8a18:	0d 9c       	cmp	r12,	r13	;
    8a1a:	04 38       	jl	$+10     	;abs 0x8a24

00008a1c <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    8a1c:	7e 40 5f 00 	mov.b	#95,	r14	;#0x005f
    8a20:	4e 9d       	cmp.b	r13,	r14	;
    8a22:	18 2c       	jc	$+50     	;abs 0x8a54

00008a24 <.L594>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    8a24:	4c 4d       	mov.b	r13,	r12	;
    8a26:	7c 50 89 ff 	add.b	#-119,	r12	;#0xff89

00008a2a <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    8a2a:	7e 42       	mov.b	#8,	r14	;r2 As==11
    8a2c:	4e 9c       	cmp.b	r12,	r14	;
    8a2e:	12 2c       	jc	$+38     	;abs 0x8a54

00008a30 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8a30:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    8a34:	8b 00 
    8a36:	40 18 0c 89 	subx.w	r9,	r12	;

00008a3a <.Loc.375.2>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    8a3a:	0d 9c       	cmp	r12,	r13	;
    8a3c:	04 38       	jl	$+10     	;abs 0x8a46

00008a3e <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8a3e:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    8a42:	4c 9d       	cmp.b	r13,	r12	;
    8a44:	07 2c       	jc	$+16     	;abs 0x8a54

00008a46 <.L595>:
        (addr >= RegDLLMAX - count + 1)) {
    8a46:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    8a4a:	d6 00 
    8a4c:	40 18 0c 89 	subx.w	r9,	r12	;

00008a50 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8a50:	0d 9c       	cmp	r12,	r13	;
    8a52:	12 38       	jl	$+38     	;abs 0x8a78

00008a54 <.L593>:
      write_failure(reply_buff, hdr);
    8a54:	81 48 08 00 	mov	r8,	8(r1)	;
    8a58:	81 46 0a 00 	mov	r6,	10(r1)	; 0x000a
    8a5c:	cd 01       	mova	r1,	r13	;
    8a5e:	ad 00 08 00 	adda	#8,	r13	;
    8a62:	cc 0a       	mova	r10,	r12	;
    8a64:	b0 13 10 66 	calla	#26128		;0x06610

00008a68 <.L598>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8a68:	0d 46       	mov	r6,	r13	;
    8a6a:	cc 0a       	mova	r10,	r12	;
    8a6c:	b0 13 58 6c 	calla	#27736		;0x06c58

00008a70 <.L589>:
}
    8a70:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    8a74:	64 16       	popm.a	#7,	r10	;20-bit words
    8a76:	10 01       	reta			;

00008a78 <.L596>:
    elyRegGetBlock(bank, reply_buff + 4, addr, count);
    8a78:	4f 49       	mov.b	r9,	r15	;
    8a7a:	4e 4d       	mov.b	r13,	r14	;
    8a7c:	cd 0a       	mova	r10,	r13	;
    8a7e:	ad 00 04 00 	adda	#4,	r13	;
    8a82:	4c 4b       	mov.b	r11,	r12	;
    8a84:	b0 13 32 94 	calla	#37938		;0x09432

00008a88 <.LVL894>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8a88:	ca 47 00 00 	mov.b	r7,	0(r10)	;

00008a8c <.Loc.386.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8a8c:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    8a90:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8a94:	02 00 

00008a96 <.Loc.387.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8a96:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8a9a:	03 00 

00008a9c <.Loc.389.2>:
    if (hdr.crc) {
    8a9c:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    8aa0:	0e 24       	jz	$+30     	;abs 0x8abe

00008aa2 <.Loc.390.2>:
      reply_buff[1] = count + 2; 
    8aa2:	4e 49       	mov.b	r9,	r14	;
    8aa4:	6e 53       	incd.b	r14		;
    8aa6:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

00008aaa <.Loc.391.2>:
      crcGenX25(reply_buff, count + 6);
    8aaa:	0d 49       	mov	r9,	r13	;
    8aac:	3d 50 06 00 	add	#6,	r13	;
    8ab0:	4d 0e       	rlam.a	#4,	r13	;
    8ab2:	4d 0d       	rram.a	#4,	r13	;
    8ab4:	cc 0a       	mova	r10,	r12	;
    8ab6:	b0 13 ec 99 	calla	#39404		;0x099ec

00008aba <.LVL895>:
    8aba:	80 00 68 8a 	mova	#35432,	r0	;0x08a68

00008abe <.L597>:
      reply_buff[1] = count; 
    8abe:	ca 49 01 00 	mov.b	r9,	1(r10)	;
    8ac2:	80 00 68 8a 	mova	#35432,	r0	;0x08a68

00008ac6 <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ac6:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008ac8 <.LCFI105>:
    8ac8:	b1 00 10 00 	suba	#16,	r1	;0x00010

00008acc <.LCFI106>:
    8acc:	c8 0c       	mova	r12,	r8	;
    8ace:	25 4d       	mov	@r13,	r5	;

00008ad0 <.LVL897>:
    8ad0:	91 4d 02 00 	mov	2(r13),	2(r1)	;
    8ad4:	02 00 
    8ad6:	09 45       	mov	r5,	r9	;
    8ad8:	59 0f       	rrum	#4,	r9	;
    8ada:	59 0f       	rrum	#4,	r9	;

00008adc <.Loc.309.2>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8adc:	4c 45       	mov.b	r5,	r12	;

00008ade <.LVL899>:
    8ade:	44 4c       	mov.b	r12,	r4	;
    8ae0:	64 f3       	and.b	#2,	r4	;r3 As==10
    8ae2:	34 f0 ff 00 	and	#255,	r4	;#0x00ff
    8ae6:	04 93       	cmp	#0,	r4	;r3 As==00
    8ae8:	5b 24       	jz	$+184    	;abs 0x8ba0

00008aea <.Loc.309.2>:
    8aea:	57 48 04 00 	mov.b	4(r8),	r7	;

00008aee <.LVL900>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8aee:	76 40 05 00 	mov.b	#5,	r6	;

00008af2 <.L601>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8af2:	1c b3       	bit	#1,	r12	;r3 As==01
    8af4:	5b 20       	jnz	$+184    	;abs 0x8bac

00008af6 <.Loc.311.2>:
    8af6:	4d 43       	clr.b	r13		;

00008af8 <.L602>:
    8af8:	40 18 0c 49 	movx.w	r9,	r12	;
    8afc:	40 18 0c 8d 	subx.w	r13,	r12	;
    8b00:	0c 84       	sub	r4,	r12	;
    8b02:	0d 4c       	mov	r12,	r13	;
    8b04:	5d 03       	rrum	#1,	r13	;
    8b06:	4d 18 0d 11 	rpt #14 { rrax.w	r13		;
    8b0a:	0c 5d       	add	r13,	r12	;
    8b0c:	0c 11       	rra	r12		;
    8b0e:	81 4c 08 00 	mov	r12,	8(r1)	;

00008b12 <.LVL903>:
  uint8_t * reply_buff = elyFWGetBuffer();
    8b12:	b0 13 18 65 	calla	#25880		;0x06518

00008b16 <.LVL904>:
    8b16:	ca 0c       	mova	r12,	r10	;

00008b18 <.LVL905>:
  if (reply_buff == NULL) {
    8b18:	9c 00 00 00 	cmpa	#0,	r12	;
    8b1c:	7a 24       	jz	$+246    	;abs 0x8c12

00008b1e <.LBB106>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    8b1e:	1b 41 08 00 	mov	8(r1),	r11	;
    8b22:	7b f0 ff 00 	and.b	#255,	r11	;#0x00ff
    8b26:	0b 5b       	rla	r11		;
    8b28:	81 4b 00 00 	mov	r11,	0(r1)	;
    8b2c:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    8b30:	04 00 
    8b32:	36 01 04 00 	mova	4(r1),	r6	;

00008b36 <.LVL906>:
    8b36:	e6 0c       	adda	r12,	r6	;
    8b38:	3e 01 04 00 	mova	4(r1),	r14	;
    8b3c:	ee 08       	adda	r8,	r14	;
    8b3e:	4d 43       	clr.b	r13		;

00008b40 <.LBB107>:
    if ((bank == 0) || (bank > 4) ||
    8b40:	4b 47       	mov.b	r7,	r11	;
    8b42:	7b 53       	add.b	#-1,	r11	;r3 As==11
    8b44:	c1 4b 0b 00 	mov.b	r11,	11(r1)	; 0x000b

00008b48 <.L604>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    8b48:	2d 91       	cmp	@r1,	r13	;
    8b4a:	33 38       	jl	$+104    	;abs 0x8bb2

00008b4c <.LBE106>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8b4c:	86 00 f6 a1 	mova	#41462,	r6	;0x0a1f6
    8b50:	cc 08       	mova	r8,	r12	;
    8b52:	46 13       	calla	r6		;

00008b54 <.LVL908>:
    8b54:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008b58 <.LVL909>:
  elyRegSet(bank, reply_buff + regs_offset-1, num_regs);
    8b58:	3d 01 04 00 	mova	4(r1),	r13	;
    8b5c:	ad 0f ff ff 	adda	#1048575,r13	;0xfffff
    8b60:	1b 41 08 00 	mov	8(r1),	r11	;
    8b64:	4e 4b       	mov.b	r11,	r14	;
    8b66:	ed 0a       	adda	r10,	r13	;
    8b68:	4c 47       	mov.b	r7,	r12	;
    8b6a:	b0 13 c6 93 	calla	#37830		;0x093c6

00008b6e <.LVL910>:
  if (hdr.reply) {
    8b6e:	04 93       	cmp	#0,	r4	;r3 As==00
    8b70:	63 24       	jz	$+200    	;abs 0x8c38

00008b72 <.Loc.347.2>:
    write_success(reply_buff, hdr);
    8b72:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8b76:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

00008b7a <.LVL912>:
    8b7a:	05 d9       	bis	r9,	r5	;
    8b7c:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    8b80:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    8b84:	0e 00 
    8b86:	cd 01       	mova	r1,	r13	;
    8b88:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    8b8c:	cc 0a       	mova	r10,	r12	;
    8b8e:	b0 13 f2 67 	calla	#26610		;0x067f2

00008b92 <.LVL913>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8b92:	1d 41 02 00 	mov	2(r1),	r13	;
    8b96:	cc 0a       	mova	r10,	r12	;
    8b98:	b0 13 58 6c 	calla	#27736		;0x06c58

00008b9c <.LVL914>:
    8b9c:	80 00 1c 8c 	mova	#35868,	r0	;0x08c1c

00008ba0 <.L600>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8ba0:	57 48 02 00 	mov.b	2(r8),	r7	;

00008ba4 <.LVL916>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8ba4:	76 40 03 00 	mov.b	#3,	r6	;
    8ba8:	80 00 f2 8a 	mova	#35570,	r0	;0x08af2

00008bac <.L611>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8bac:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8bae:	80 00 f8 8a 	mova	#35576,	r0	;0x08af8

00008bb2 <.L609>:
    uint8_t addr = buffer[i + regs_offset];
    8bb2:	6c 4e       	mov.b	@r14,	r12	;

00008bb4 <.LVL920>:
    if ((bank == 0) || (bank > 4) ||
    8bb4:	7f 40 03 00 	mov.b	#3,	r15	;
    8bb8:	5f 91 0b 00 	cmp.b	11(r1),	r15	;0x0000b
    8bbc:	13 28       	jnc	$+40     	;abs 0x8be4

00008bbe <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    8bbe:	4f 4c       	mov.b	r12,	r15	;
    8bc0:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00008bc4 <.Loc.323.2>:
    if ((bank == 0) || (bank > 4) ||
    8bc4:	7b 40 29 00 	mov.b	#41,	r11	;#0x0029
    8bc8:	4b 9f       	cmp.b	r15,	r11	;
    8bca:	0c 2c       	jc	$+26     	;abs 0x8be4

00008bcc <.Loc.325.2>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    8bcc:	7f 50 cc ff 	add.b	#-52,	r15	;#0xffcc

00008bd0 <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    8bd0:	7b 40 35 00 	mov.b	#53,	r11	;#0x0035
    8bd4:	4b 9f       	cmp.b	r15,	r11	;
    8bd6:	06 2c       	jc	$+14     	;abs 0x8be4
    8bd8:	ae 00 02 00 	adda	#2,	r14	;

00008bdc <.LVL921>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    8bdc:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    8be0:	4f 9c       	cmp.b	r12,	r15	;
    8be2:	20 2c       	jc	$+66     	;abs 0x8c24

00008be4 <.L606>:
      if (hdr.reply) {
    8be4:	04 93       	cmp	#0,	r4	;r3 As==00
    8be6:	15 24       	jz	$+44     	;abs 0x8c12

00008be8 <.Loc.328.2>:
        write_failure(reply_buff, hdr);
    8be8:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8bec:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

00008bf0 <.LVL924>:
    8bf0:	05 d9       	bis	r9,	r5	;
    8bf2:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    8bf6:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    8bfa:	0e 00 
    8bfc:	cd 01       	mova	r1,	r13	;

00008bfe <.LVL925>:
    8bfe:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    8c02:	cc 0a       	mova	r10,	r12	;

00008c04 <.LVL926>:
    8c04:	b0 13 10 66 	calla	#26128		;0x06610

00008c08 <.LVL927>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    8c08:	1d 41 02 00 	mov	2(r1),	r13	;
    8c0c:	cc 0a       	mova	r10,	r12	;
    8c0e:	b0 13 58 6c 	calla	#27736		;0x06c58

00008c12 <.L608>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    8c12:	cc 08       	mova	r8,	r12	;
    8c14:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008c18 <.LVL929>:
    8c18:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008c1c <.L599>:
}
    8c1c:	a1 00 10 00 	adda	#16,	r1	;0x00010
    8c20:	64 16       	popm.a	#7,	r10	;20-bit words
    8c22:	10 01       	reta			;

00008c24 <.L607>:
    reply_buff[i+regs_offset-1] = addr;
    8c24:	c6 4c ff ff 	mov.b	r12,	-1(r6)	; 0xffff

00008c28 <.LVL932>:
    reply_buff[i+regs_offset] = buffer[i+regs_offset+1];
    8c28:	d6 4e ff ff 	mov.b	-1(r14),0(r6)	;
    8c2c:	00 00 

00008c2e <.LBE109>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    8c2e:	2d 53       	incd	r13		;
    8c30:	a6 00 02 00 	adda	#2,	r6	;
    8c34:	80 00 48 8b 	mova	#35656,	r0	;0x08b48

00008c38 <.L610>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    8c38:	cc 0a       	mova	r10,	r12	;
    8c3a:	46 13       	calla	r6		;

00008c3c <.LVL935>:
    8c3c:	b0 13 7a 65 	calla	#25978		;0x0657a

00008c40 <.LVL936>:
    8c40:	80 00 1c 8c 	mova	#35868,	r0	;0x08c1c

00008c44 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8c44:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008c46 <.LCFI107>:
    8c46:	b1 00 12 00 	suba	#18,	r1	;0x00012

00008c4a <.LCFI108>:
    8c4a:	c8 0c       	mova	r12,	r8	;
    8c4c:	2e 4d       	mov	@r13,	r14	;

00008c4e <.LVL938>:
    8c4e:	16 4d 02 00 	mov	2(r13),	r6	;

00008c52 <.LVL939>:
    8c52:	0d 4e       	mov	r14,	r13	;
    8c54:	5d 07       	rrum	#2,	r13	;
    8c56:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    8c5a:	c1 4d 0a 00 	mov.b	r13,	10(r1)	; 0x000a
    8c5e:	09 4e       	mov	r14,	r9	;
    8c60:	59 0f       	rrum	#4,	r9	;
    8c62:	59 0f       	rrum	#4,	r9	;
    8c64:	81 49 08 00 	mov	r9,	8(r1)	;

00008c68 <.Loc.252.2>:
  if (hdr.reply) {
    8c68:	49 4d       	mov.b	r13,	r9	;
    8c6a:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
    8c6e:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    8c72:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

00008c76 <.LVL941>:
    8c76:	09 de       	bis	r14,	r9	;
    8c78:	81 49 00 00 	mov	r9,	0(r1)	;
    8c7c:	07 49       	mov	r9,	r7	;
    8c7e:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    8c82:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    8c86:	07 24       	jz	$+16     	;abs 0x8c96

00008c88 <.LBB112>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8c88:	b0 13 18 65 	calla	#25880		;0x06518

00008c8c <.LVL942>:
    8c8c:	ca 0c       	mova	r12,	r10	;

00008c8e <.LVL943>:
    if (reply_buff == NULL) {
    8c8e:	9c 00 00 00 	cmpa	#0,	r12	;
    8c92:	07 20       	jnz	$+16     	;abs 0x8ca2

00008c94 <.L627>:
        elyNLFreeBuffer(elyNLFromFW(buffer));
    8c94:	cc 08       	mova	r8,	r12	;

00008c96 <.L616>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8c96:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008c9a <.LVL945>:
    8c9a:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008c9e <.LVL946>:
    8c9e:	80 00 30 8d 	mova	#36144,	r0	;0x08d30

00008ca2 <.L617>:
    uint8_t bank = buffer[4];
    8ca2:	54 48 04 00 	mov.b	4(r8),	r4	;

00008ca6 <.LVL948>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8ca6:	57 f3       	and.b	#1,	r7	;r3 As==01
    8ca8:	07 93       	cmp	#0,	r7	;r3 As==00
    8caa:	46 20       	jnz	$+142    	;abs 0x8d38
    8cac:	0c 47       	mov	r7,	r12	;

00008cae <.L619>:
    8cae:	1f 41 08 00 	mov	8(r1),	r15	;
    8cb2:	4f 8c       	sub.b	r12,	r15	;
    8cb4:	c1 4f 0d 00 	mov.b	r15,	13(r1)	; 0x000d
    8cb8:	45 4f       	mov.b	r15,	r5	;
    8cba:	75 50 fd ff 	add.b	#-3,	r5	;#0xfffd
    8cbe:	49 45       	mov.b	r5,	r9	;
    8cc0:	81 49 02 00 	mov	r9,	2(r1)	;

00008cc4 <.LVL949>:
    8cc4:	cd 0a       	mova	r10,	r13	;
    8cc6:	ad 00 04 00 	adda	#4,	r13	;
    8cca:	71 0d 04 00 	mova	r13,	4(r1)	;
    8cce:	cb 08       	mova	r8,	r11	;
    8cd0:	ab 00 05 00 	adda	#5,	r11	;

00008cd4 <.LBB116>:
    for (int i = 0; i < num_regs; i++) {
    8cd4:	4e 43       	clr.b	r14		;

00008cd6 <.L620>:
    8cd6:	1e 91 02 00 	cmp	2(r1),	r14	;
    8cda:	31 38       	jl	$+100    	;abs 0x8d3e

00008cdc <.LBE116>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8cdc:	cc 08       	mova	r8,	r12	;
    8cde:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008ce2 <.LVL951>:
    8ce2:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008ce6 <.LVL952>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8ce6:	da 41 0a 00 	mov.b	10(r1),	0(r10)	;0x0000a
    8cea:	00 00 

00008cec <.Loc.287.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8cec:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    8cf0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8cf4:	02 00 

00008cf6 <.Loc.288.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8cf6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8cfa:	03 00 

00008cfc <.Loc.291.2>:
    elyRegGet(bank, reply_buff + 4, num_regs);
    8cfc:	4e 45       	mov.b	r5,	r14	;
    8cfe:	3d 01 04 00 	mova	4(r1),	r13	;
    8d02:	4c 44       	mov.b	r4,	r12	;
    8d04:	b0 13 6a 93 	calla	#37738		;0x0936a

00008d08 <.LVL953>:
    if (hdr.crc) {
    8d08:	07 93       	cmp	#0,	r7	;r3 As==00
    8d0a:	54 24       	jz	$+170    	;abs 0x8db4

00008d0c <.Loc.294.2>:
      reply_buff[1] = num_regs + 2;
    8d0c:	59 41 0d 00 	mov.b	13(r1),	r9	;0x0000d
    8d10:	79 53       	add.b	#-1,	r9	;r3 As==11
    8d12:	ca 49 01 00 	mov.b	r9,	1(r10)	;

00008d16 <.Loc.295.2>:
      crcGenX25(reply_buff, num_regs + 6);
    8d16:	1d 41 02 00 	mov	2(r1),	r13	;
    8d1a:	3d 50 06 00 	add	#6,	r13	;
    8d1e:	4d 0e       	rlam.a	#4,	r13	;
    8d20:	4d 0d       	rram.a	#4,	r13	;
    8d22:	cc 0a       	mova	r10,	r12	;
    8d24:	b0 13 ec 99 	calla	#39404		;0x099ec

00008d28 <.L625>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8d28:	0d 46       	mov	r6,	r13	;
    8d2a:	cc 0a       	mova	r10,	r12	;
    8d2c:	b0 13 58 6c 	calla	#27736		;0x06c58

00008d30 <.L615>:
}
    8d30:	a1 00 12 00 	adda	#18,	r1	;0x00012
    8d34:	64 16       	popm.a	#7,	r10	;20-bit words
    8d36:	10 01       	reta			;

00008d38 <.L626>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8d38:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8d3a:	80 00 ae 8c 	mova	#36014,	r0	;0x08cae

00008d3e <.L623>:
      uint8_t addr = buffer[i + regs_offset];
    8d3e:	6c 4b       	mov.b	@r11,	r12	;

00008d40 <.LVL958>:
      if ((bank > 4) ||
    8d40:	69 42       	mov.b	#4,	r9	;r2 As==10
    8d42:	49 94       	cmp.b	r4,	r9	;
    8d44:	18 28       	jnc	$+50     	;abs 0x8d76

00008d46 <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    8d46:	4f 4c       	mov.b	r12,	r15	;
    8d48:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00008d4c <.Loc.269.2>:
      if ((bank > 4) ||
    8d4c:	79 40 09 00 	mov.b	#9,	r9	;
    8d50:	49 9f       	cmp.b	r15,	r9	;
    8d52:	11 2c       	jc	$+36     	;abs 0x8d76

00008d54 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8d54:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

00008d58 <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    8d58:	79 42       	mov.b	#8,	r9	;r2 As==11
    8d5a:	49 9f       	cmp.b	r15,	r9	;
    8d5c:	0c 2c       	jc	$+26     	;abs 0x8d76

00008d5e <.Loc.272.2>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    8d5e:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00008d62 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8d62:	79 40 35 00 	mov.b	#53,	r9	;#0x0035
    8d66:	49 9f       	cmp.b	r15,	r9	;
    8d68:	06 2c       	jc	$+14     	;abs 0x8d76
    8d6a:	ab 00 01 00 	adda	#1,	r11	;

00008d6e <.LVL959>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    8d6e:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    8d72:	4f 9c       	cmp.b	r12,	r15	;
    8d74:	18 2c       	jc	$+50     	;abs 0x8da6

00008d76 <.L621>:
        write_failure(reply_buff, hdr);
    8d76:	1d 41 08 00 	mov	8(r1),	r13	;
    8d7a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    8d7e:	29 41       	mov	@r1,	r9	;
    8d80:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    8d84:	09 dd       	bis	r13,	r9	;
    8d86:	81 49 0e 00 	mov	r9,	14(r1)	; 0x000e
    8d8a:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    8d8e:	cd 01       	mova	r1,	r13	;
    8d90:	ad 00 0e 00 	adda	#14,	r13	;0x0000e
    8d94:	cc 0a       	mova	r10,	r12	;

00008d96 <.LVL961>:
    8d96:	b0 13 10 66 	calla	#26128		;0x06610

00008d9a <.LVL962>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    8d9a:	0d 46       	mov	r6,	r13	;
    8d9c:	cc 0a       	mova	r10,	r12	;
    8d9e:	b0 13 58 6c 	calla	#27736		;0x06c58

00008da2 <.LVL963>:
    8da2:	80 00 94 8c 	mova	#35988,	r0	;0x08c94

00008da6 <.L622>:
      reply_buff[i+4] = addr;
    8da6:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

00008daa <.LBE115>:
    for (int i = 0; i < num_regs; i++) {
    8daa:	1e 53       	inc	r14		;
    8dac:	ad 00 01 00 	adda	#1,	r13	;
    8db0:	80 00 d6 8c 	mova	#36054,	r0	;0x08cd6

00008db4 <.L624>:
      reply_buff[1] = num_regs;
    8db4:	ca 45 01 00 	mov.b	r5,	1(r10)	;
    8db8:	80 00 28 8d 	mova	#36136,	r0	;0x08d28

00008dbc <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8dbc:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008dbe <.LCFI109>:
    8dbe:	2a 4d       	mov	@r13,	r10	;

00008dc0 <.LVL969>:
    8dc0:	17 4d 02 00 	mov	2(r13),	r7	;

00008dc4 <.LVL970>:
    8dc4:	49 4a       	mov.b	r10,	r9	;
    8dc6:	59 f3       	and.b	#1,	r9	;r3 As==01
    8dc8:	45 49       	mov.b	r9,	r5	;
    8dca:	08 4a       	mov	r10,	r8	;
    8dcc:	58 07       	rrum	#2,	r8	;
    8dce:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    8dd2:	46 48       	mov.b	r8,	r6	;

00008dd4 <.Loc.229.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8dd4:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008dd8 <.LVL972>:
    8dd8:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008ddc <.LVL973>:
  if (hdr.reply) { /* reply requested */
    8ddc:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

00008de0 <.LVL974>:
    8de0:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    8de4:	0a d5       	bis	r5,	r10	;
    8de6:	0a d6       	bis	r6,	r10	;
    8de8:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8dec:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    8df0:	22 24       	jz	$+70     	;abs 0x8e36

00008df2 <.LBB120>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8df2:	b0 13 18 65 	calla	#25880		;0x06518

00008df6 <.LVL975>:
    8df6:	c6 0c       	mova	r12,	r6	;

00008df8 <.LVL976>:
    if (reply_buff == NULL) {
    8df8:	9c 00 00 00 	cmpa	#0,	r12	;
    8dfc:	1c 24       	jz	$+58     	;abs 0x8e36

00008dfe <.Loc.238.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8dfe:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00008e02 <.Loc.239.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8e02:	49 59       	rla.b	r9		;
    8e04:	59 53       	inc.b	r9		;
    8e06:	cc 49 01 00 	mov.b	r9,	1(r12)	;

00008e0a <.Loc.240.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8e0a:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    8e0e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8e12:	02 00 

00008e14 <.Loc.241.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8e14:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8e18:	03 00 

00008e1a <.Loc.242.2>:
    reply_buff[4] = bank0p[RegActiveBank];
    8e1a:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    8e1e:	04 00 

00008e20 <.Loc.243.2>:
    if (hdr.crc) {
    8e20:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    8e24:	04 24       	jz	$+10     	;abs 0x8e2e

00008e26 <.Loc.244.2>:
      crcGenX25(reply_buff, 7);
    8e26:	7d 40 07 00 	mov.b	#7,	r13	;
    8e2a:	b0 13 ec 99 	calla	#39404		;0x099ec

00008e2e <.L632>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8e2e:	0d 47       	mov	r7,	r13	;
    8e30:	cc 06       	mova	r6,	r12	;
    8e32:	b0 13 58 6c 	calla	#27736		;0x06c58

00008e36 <.L628>:
}
    8e36:	55 16       	popm.a	#6,	r10	;20-bit words
    8e38:	10 01       	reta			;

00008e3a <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8e3a:	5a 14       	pushm.a	#6,	r10	;20-bit words

00008e3c <.LCFI110>:
    8e3c:	2a 4d       	mov	@r13,	r10	;

00008e3e <.LVL981>:
    8e3e:	17 4d 02 00 	mov	2(r13),	r7	;

00008e42 <.LVL982>:
    8e42:	49 4a       	mov.b	r10,	r9	;
    8e44:	59 f3       	and.b	#1,	r9	;r3 As==01
    8e46:	45 49       	mov.b	r9,	r5	;
    8e48:	08 4a       	mov	r10,	r8	;
    8e4a:	58 07       	rrum	#2,	r8	;
    8e4c:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    8e50:	46 48       	mov.b	r8,	r6	;

00008e52 <.Loc.173.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8e52:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

00008e56 <.LVL984>:
    8e56:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008e5a <.LVL985>:
  if (hdr.reply) { /* reply requested */
    8e5a:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

00008e5e <.LVL986>:
    8e5e:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    8e62:	0a d5       	bis	r5,	r10	;
    8e64:	0a d6       	bis	r6,	r10	;
    8e66:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8e6a:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    8e6e:	22 24       	jz	$+70     	;abs 0x8eb4

00008e70 <.LBB121>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8e70:	b0 13 18 65 	calla	#25880		;0x06518

00008e74 <.LVL987>:
    8e74:	c6 0c       	mova	r12,	r6	;

00008e76 <.LVL988>:
    if (reply_buff == NULL) {
    8e76:	9c 00 00 00 	cmpa	#0,	r12	;
    8e7a:	1c 24       	jz	$+58     	;abs 0x8eb4

00008e7c <.Loc.182.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8e7c:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00008e80 <.Loc.183.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8e80:	49 59       	rla.b	r9		;
    8e82:	59 53       	inc.b	r9		;
    8e84:	cc 49 01 00 	mov.b	r9,	1(r12)	;

00008e88 <.Loc.184.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8e88:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0
    8e8c:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8e90:	02 00 

00008e92 <.Loc.185.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8e92:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8e96:	03 00 

00008e98 <.Loc.186.2>:
    reply_buff[4] = bank0p[RegGPOState];
    8e98:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    8e9c:	04 00 

00008e9e <.Loc.187.2>:
    if (hdr.crc) {
    8e9e:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    8ea2:	04 24       	jz	$+10     	;abs 0x8eac

00008ea4 <.Loc.188.2>:
      crcGenX25(reply_buff, 7);
    8ea4:	7d 40 07 00 	mov.b	#7,	r13	;
    8ea8:	b0 13 ec 99 	calla	#39404		;0x099ec

00008eac <.L643>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8eac:	0d 47       	mov	r7,	r13	;
    8eae:	cc 06       	mova	r6,	r12	;
    8eb0:	b0 13 58 6c 	calla	#27736		;0x06c58

00008eb4 <.L639>:
}
    8eb4:	55 16       	popm.a	#6,	r10	;20-bit words
    8eb6:	10 01       	reta			;

00008eb8 <CmdThd>:

THD_WORKING_AREA(waCmdThd, 256);
THD_FUNCTION(CmdThd, arg) {
    8eb8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008eba <.LCFI111>:
    8eba:	08 14       	pushm.a	#1,	r8	;20-bit words

00008ebc <.LCFI112>:
    8ebc:	26 14       	pushm.a	#3,	r6	;20-bit words

00008ebe <.LCFI113>:
    8ebe:	b1 00 04 00 	suba	#4,	r1	;

00008ec2 <.LBB122>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    8ec2:	88 00 8a 4b 	mova	#19338,	r8	;0x04b8a

00008ec6 <.Loc.1797.2>:
    }
    
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    8ec6:	8a 00 ea a1 	mova	#41450,	r10	;0x0a1ea

00008eca <.L654>:
    if (NULL == active_buffer) {
    8eca:	00 18 c2 93 	cmpx.a	#0,	&0xfac3a;r3 As==00
    8ece:	3a ac 
    8ed0:	06 20       	jnz	$+14     	;abs 0x8ede

00008ed2 <.Loc.1794.2>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    8ed2:	4e 43       	clr.b	r14		;
    8ed4:	8d 00 3a ac 	mova	#44090,	r13	;0x0ac3a
    8ed8:	8c 01 1c 07 	mova	#67356,	r12	;0x1071c
    8edc:	48 13       	calla	r8		;

00008ede <.L651>:
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    8ede:	2c 00 3a ac 	mova	&44090,	r12	;0x0ac3a
    8ee2:	4a 13       	calla	r10		;

00008ee4 <.LVL995>:
    8ee4:	c6 0c       	mova	r12,	r6	;

00008ee6 <.Loc.1800.2>:
    elysium_cmd_hdr_t hdr;
    
    hdr = elyCmdParse(cmd_buffer);
    8ee6:	cd 0c       	mova	r12,	r13	;
    8ee8:	cc 01       	mova	r1,	r12	;
    8eea:	b0 13 5a 68 	calla	#26714		;0x0685a

00008eee <.LVL997>:
    8eee:	24 41       	mov	@r1,	r4	;

00008ef0 <.LVL998>:
    8ef0:	15 41 02 00 	mov	2(r1),	r5	;

00008ef4 <.Loc.1801.2>:
    if (elyCmdValidate(hdr, cmd_buffer)) {
    8ef4:	cd 06       	mova	r6,	r13	;
    8ef6:	cc 01       	mova	r1,	r12	;
    8ef8:	b0 13 ae 68 	calla	#26798		;0x068ae

00008efc <.LVL999>:
    8efc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8efe:	0d 24       	jz	$+28     	;abs 0x8f1a

00008f00 <.Loc.1802.2>:
      elyCmdDispatch(hdr, cmd_buffer);
    8f00:	81 44 00 00 	mov	r4,	0(r1)	;

00008f04 <.LVL1000>:
    8f04:	81 45 02 00 	mov	r5,	2(r1)	;
    8f08:	cd 06       	mova	r6,	r13	;
    8f0a:	cc 01       	mova	r1,	r12	;
    8f0c:	b0 13 22 6b 	calla	#27426		;0x06b22

00008f10 <.L653>:
      /* Invalid command - free the buffer (guaranteed to be NL) */
      elyNLFreeBuffer(active_buffer);
    }
    
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    8f10:	00 18 c2 43 	movx.a	#0,	&0xfac3a;r3 As==00
    8f14:	3a ac 

00008f16 <.LBE122>:
  while (true) {
    8f16:	80 00 ca 8e 	mova	#36554,	r0	;0x08eca

00008f1a <.L652>:
      elyNLFreeBuffer(active_buffer);
    8f1a:	2c 00 3a ac 	mova	&44090,	r12	;0x0ac3a
    8f1e:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00008f22 <.LVL1003>:
    8f22:	80 00 10 8f 	mova	#36624,	r0	;0x08f10

00008f26 <time_timer_cb>:
  
}

void time_timer_cb(GPTDriver * gptp) {
  int32_t * uptime = &bank0w[RegUptimeLsb];
  (*uptime)++;
    8f26:	8c 00 1c a6 	mova	#42524,	r12	;0x0a61c

00008f2a <.LVL2>:
    8f2a:	5d 4c 6c 00 	mov.b	108(r12),r13	;0x0006c
    8f2e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    8f32:	5e 4c 6b 00 	mov.b	107(r12),r14	;0x0006b
    8f36:	0d de       	bis	r14,	r13	;
    8f38:	5e 4c 6e 00 	mov.b	110(r12),r14	;0x0006e
    8f3c:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    8f40:	5f 4c 6d 00 	mov.b	109(r12),r15	;0x0006d
    8f44:	0e df       	bis	r15,	r14	;
    8f46:	1d 53       	inc	r13		;
    8f48:	0e 63       	adc	r14		;
    8f4a:	cc 4d 6b 00 	mov.b	r13,	107(r12); 0x006b
    8f4e:	5d 0f       	rrum	#4,	r13	;
    8f50:	5d 0f       	rrum	#4,	r13	;
    8f52:	cc 4d 6c 00 	mov.b	r13,	108(r12); 0x006c
    8f56:	cc 4e 6d 00 	mov.b	r14,	109(r12); 0x006d
    8f5a:	5e 0f       	rrum	#4,	r14	;
    8f5c:	5e 0f       	rrum	#4,	r14	;
    8f5e:	cc 4e 6e 00 	mov.b	r14,	110(r12); 0x006e

00008f62 <.Loc.414.1>:
  int32_t * mission_time = &bank0w[RegMissionTimeLsb];
  (*mission_time)++;
    8f62:	5d 4c 74 00 	mov.b	116(r12),r13	;0x00074
    8f66:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    8f6a:	5e 4c 73 00 	mov.b	115(r12),r14	;0x00073
    8f6e:	0d de       	bis	r14,	r13	;
    8f70:	5e 4c 76 00 	mov.b	118(r12),r14	;0x00076
    8f74:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    8f78:	5f 4c 75 00 	mov.b	117(r12),r15	;0x00075
    8f7c:	0e df       	bis	r15,	r14	;
    8f7e:	1d 53       	inc	r13		;
    8f80:	0e 63       	adc	r14		;
    8f82:	cc 4d 73 00 	mov.b	r13,	115(r12); 0x0073
    8f86:	5d 0f       	rrum	#4,	r13	;
    8f88:	5d 0f       	rrum	#4,	r13	;
    8f8a:	cc 4d 74 00 	mov.b	r13,	116(r12); 0x0074
    8f8e:	cc 4e 75 00 	mov.b	r14,	117(r12); 0x0075
    8f92:	5e 0f       	rrum	#4,	r14	;
    8f94:	5e 0f       	rrum	#4,	r14	;
    8f96:	cc 4e 76 00 	mov.b	r14,	118(r12); 0x0076

00008f9a <.Loc.415.1>:
}
    8f9a:	10 01       	reta			;

00008f9c <clamp>:
static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    8f9c:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008f9e <.LCFI0>:
    8f9e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8fa2:	49 4d       	mov.b	r13,	r9	;
    8fa4:	4a 4e       	mov.b	r14,	r10	;

00008fa6 <.Loc.152.1>:
  if (value < min) {
    8fa6:	4c 99       	cmp.b	r9,	r12	;
    8fa8:	07 2c       	jc	$+16     	;abs 0x8fb8

00008faa <.LVL5>:
    elyErrorSignal(ErrRegClip);
    8faa:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8fae:	b0 13 ca 94 	calla	#38090		;0x094ca

00008fb2 <.LVL6>:
    8fb2:	0c 49       	mov	r9,	r12	;

00008fb4 <.L4>:
}
    8fb4:	19 16       	popm.a	#2,	r10	;20-bit words
    8fb6:	10 01       	reta			;

00008fb8 <.L3>:
  else if (value > max) {
    8fb8:	4a 9c       	cmp.b	r12,	r10	;
    8fba:	fc 2f       	jc	$-6      	;abs 0x8fb4

00008fbc <.LVL9>:
    elyErrorSignal(ErrRegClip);
    8fbc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8fc0:	b0 13 ca 94 	calla	#38090		;0x094ca

00008fc4 <.LVL10>:
    8fc4:	0c 4a       	mov	r10,	r12	;
    8fc6:	80 00 b4 8f 	mova	#36788,	r0	;0x08fb4

00008fca <fram_reg_cb>:
  regs_in_progress--;
    8fca:	40 18 5c 42 	movx.b	&0x0ac5e,r12	;
    8fce:	5e ac 

00008fd0 <.LVL12>:
    8fd0:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8fd2:	40 18 c2 4c 	movx.b	r12,	&0xfac5e;
    8fd6:	5e ac 

00008fd8 <.Loc.207.1>:
  if (regs_in_progress == 0) {
    8fd8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8fda:	0a 20       	jnz	$+22     	;abs 0x8ff0

00008fdc <.LBB12>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8fdc:	40 18 1c 42 	movx.w	&0x0ac60,r12	;
    8fe0:	60 ac 
    8fe2:	4d 43       	clr.b	r13		;
    8fe4:	0d 9c       	cmp	r12,	r13	;
    8fe6:	04 38       	jl	$+10     	;abs 0x8ff0

00008fe8 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8fe8:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    8fec:	b0 13 00 49 	calla	#18688		;0x04900

00008ff0 <.L5>:
}
    8ff0:	10 01       	reta			;

00008ff2 <fram_block_cb>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8ff2:	40 18 1c 42 	movx.w	&0x0ac60,r12	;
    8ff6:	60 ac 

00008ff8 <.LVL17>:
    8ff8:	4d 43       	clr.b	r13		;
    8ffa:	0d 9c       	cmp	r12,	r13	;
    8ffc:	04 38       	jl	$+10     	;abs 0x9006

00008ffe <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8ffe:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    9002:	b0 13 00 49 	calla	#18688		;0x04900

00009006 <.L7>:
}
    9006:	10 01       	reta			;

00009008 <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    9008:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000900a <.LCFI1>:
    900a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000900c <.LCFI2>:
    900c:	b1 00 04 00 	suba	#4,	r1	;

00009010 <.LCFI3>:
    9010:	4a 4c       	mov.b	r12,	r10	;
    9012:	49 4d       	mov.b	r13,	r9	;
    9014:	48 4e       	mov.b	r14,	r8	;
    9016:	c6 0f       	mova	r15,	r6	;

00009018 <.LBB26>:
  _disable_interrupts();
    9018:	32 c2       	dint			
    901a:	03 43       	nop			

0000901c <.Loc.348.3>:
  asm volatile("nop");
    901c:	03 43       	nop			

0000901e <.LBE26>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    901e:	4d 43       	clr.b	r13		;

00009020 <.LVL20>:
    9020:	cc 01       	mova	r1,	r12	;

00009022 <.LVL21>:
    9022:	b0 13 78 9d 	calla	#40312		;0x09d78

00009026 <.LBB28>:
  asm volatile("nop");
    9026:	03 43       	nop			

00009028 <.Loc.356.3>:
  _enable_interrupts();
    9028:	03 43       	nop			
    902a:	32 d2       	eint			
    902c:	03 43       	nop			

0000902e <.LBE28>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    902e:	0c 01       	mova	@r1,	r12	;
    9030:	39 53       	add	#-1,	r9	;r3 As==11

00009032 <.LVL23>:
    9032:	47 18 09 59 	rpt #8 { rlax.w	r9		;

00009036 <.LVL24>:
    9036:	0e 49       	mov	r9,	r14	;
    9038:	0f 49       	mov	r9,	r15	;
    903a:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    903e:	48 48       	mov.b	r8,	r8	;
    9040:	09 43       	clr	r9		;

00009042 <.LVL25>:
    9042:	0d 48       	mov	r8,	r13	;
    9044:	0d 53       	add	#0,	r13	;r3 As==00
    9046:	19 63       	addc	#1,	r9	;r3 As==01
    9048:	0d 5e       	add	r14,	r13	;
    904a:	8c 4d 00 00 	mov	r13,	0(r12)	;
    904e:	09 6f       	addc	r15,	r9	;
    9050:	8c 49 02 00 	mov	r9,	2(r12)	;

00009054 <.Loc.224.1>:
  req->read = read;
    9054:	5a f3       	and.b	#1,	r10	;r3 As==01

00009056 <.LVL26>:
    9056:	4a 5a       	rla.b	r10		;
    9058:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    905c:	6d c3       	bic.b	#2,	r13	;r3 As==10
    905e:	4d da       	bis.b	r10,	r13	;
    9060:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00009064 <.Loc.225.1>:
  req->size = 1;
    9064:	1d 4c 04 00 	mov	4(r12),	r13	;
    9068:	7d f0 03 00 	and.b	#3,	r13	;
    906c:	2d d2       	bis	#4,	r13	;r2 As==10
    906e:	8c 4d 04 00 	mov	r13,	4(r12)	;
    9072:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    9076:	06 00 

00009078 <.Loc.226.1>:
  req->buffer = valuep;
    9078:	7c 06 08 00 	mova	r6,	8(r12)	;

0000907c <.Loc.227.1>:
  req->callback = fram_reg_cb;
    907c:	00 18 fc 40 	movx.a	#36810,	12(r12)	;0x08fca, 0x0000c
    9080:	ca 8f 0c 00 

00009084 <.LBB30>:
  _disable_interrupts();
    9084:	32 c2       	dint			
    9086:	03 43       	nop			

00009088 <.Loc.348.3>:
  asm volatile("nop");
    9088:	03 43       	nop			

0000908a <.LBE30>:
  elyFramPostRequestS(req);
    908a:	b0 13 54 9d 	calla	#40276		;0x09d54

0000908e <.LBB32>:
  asm volatile("nop");
    908e:	03 43       	nop			

00009090 <.Loc.356.3>:
  _enable_interrupts();
    9090:	03 43       	nop			
    9092:	32 d2       	eint			
    9094:	03 43       	nop			

00009096 <.LBE32>:
}
    9096:	a1 00 04 00 	adda	#4,	r1	;
    909a:	06 16       	popm.a	#1,	r6	;20-bit words
    909c:	28 16       	popm.a	#3,	r10	;20-bit words
    909e:	10 01       	reta			;

000090a0 <fram_block>:
void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    90a0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000090a2 <.LCFI4>:
    90a2:	06 14       	pushm.a	#1,	r6	;20-bit words

000090a4 <.LCFI5>:
    90a4:	b1 00 08 00 	suba	#8,	r1	;

000090a8 <.LCFI6>:
    90a8:	4a 4c       	mov.b	r12,	r10	;
    90aa:	49 4d       	mov.b	r13,	r9	;
    90ac:	48 4e       	mov.b	r14,	r8	;
    90ae:	c6 0f       	mova	r15,	r6	;

000090b0 <.LBB42>:
  _disable_interrupts();
    90b0:	32 c2       	dint			
    90b2:	03 43       	nop			

000090b4 <.Loc.348.3>:
  asm volatile("nop");
    90b4:	03 43       	nop			

000090b6 <.LBE42>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    90b6:	4d 43       	clr.b	r13		;

000090b8 <.LVL29>:
    90b8:	cc 01       	mova	r1,	r12	;

000090ba <.LVL30>:
    90ba:	ac 00 04 00 	adda	#4,	r12	;
    90be:	b0 13 78 9d 	calla	#40312		;0x09d78

000090c2 <.LBB44>:
  asm volatile("nop");
    90c2:	03 43       	nop			

000090c4 <.Loc.356.3>:
  _enable_interrupts();
    90c4:	03 43       	nop			
    90c6:	32 d2       	eint			
    90c8:	03 43       	nop			

000090ca <.LBE44>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    90ca:	3c 01 04 00 	mova	4(r1),	r12	;
    90ce:	39 53       	add	#-1,	r9	;r3 As==11

000090d0 <.LVL32>:
    90d0:	47 18 09 59 	rpt #8 { rlax.w	r9		;

000090d4 <.LVL33>:
    90d4:	0e 49       	mov	r9,	r14	;
    90d6:	0f 49       	mov	r9,	r15	;
    90d8:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    90dc:	48 48       	mov.b	r8,	r8	;
    90de:	09 43       	clr	r9		;

000090e0 <.LVL34>:
    90e0:	0d 48       	mov	r8,	r13	;
    90e2:	0d 53       	add	#0,	r13	;r3 As==00
    90e4:	19 63       	addc	#1,	r9	;r3 As==01
    90e6:	0d 5e       	add	r14,	r13	;
    90e8:	8c 4d 00 00 	mov	r13,	0(r12)	;
    90ec:	09 6f       	addc	r15,	r9	;
    90ee:	8c 49 02 00 	mov	r9,	2(r12)	;

000090f2 <.Loc.252.1>:
  req->read = read;
    90f2:	5a f3       	and.b	#1,	r10	;r3 As==01

000090f4 <.LVL35>:
    90f4:	4a 5a       	rla.b	r10		;
    90f6:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    90fa:	6d c3       	bic.b	#2,	r13	;r3 As==10
    90fc:	4d da       	bis.b	r10,	r13	;
    90fe:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00009102 <.Loc.253.1>:
  req->size = n;
    9102:	5d 41 1c 00 	mov.b	28(r1),	r13	;0x0001c
    9106:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    910a:	00 00 
    910c:	2d 41       	mov	@r1,	r13	;
    910e:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    9112:	1e 4c 04 00 	mov	4(r12),	r14	;
    9116:	7e f0 03 00 	and.b	#3,	r14	;
    911a:	0e dd       	bis	r13,	r14	;
    911c:	8c 4e 04 00 	mov	r14,	4(r12)	;

00009120 <.LVL36>:
    9120:	2e 41       	mov	@r1,	r14	;
    9122:	0f 4e       	mov	r14,	r15	;
    9124:	5f 03       	rrum	#1,	r15	;
    9126:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    912a:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    912e:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    9132:	0a 01       	mova	@r1,	r10	;
    9134:	0a 14       	pushm.a	#1,	r10	;20-bit words
    9136:	0d 17       	popm	#1,	r13	;16-bit words
    9138:	0d 17       	popm	#1,	r13	;16-bit words
    913a:	5d f3       	and.b	#1,	r13	;r3 As==01
    913c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    9140:	4e df       	bis.b	r15,	r14	;
    9142:	4e dd       	bis.b	r13,	r14	;
    9144:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00009148 <.Loc.254.1>:
  req->buffer = buffer;
    9148:	7c 06 08 00 	mova	r6,	8(r12)	;

0000914c <.Loc.255.1>:
  req->callback = fram_block_cb;
    914c:	00 18 fc 40 	movx.a	#36850,	12(r12)	;0x08ff2, 0x0000c
    9150:	f2 8f 0c 00 

00009154 <.LBB46>:
  _disable_interrupts();
    9154:	32 c2       	dint			
    9156:	03 43       	nop			

00009158 <.Loc.348.3>:
  asm volatile("nop");
    9158:	03 43       	nop			

0000915a <.LBE46>:
  elyFramPostRequestS(req);
    915a:	b0 13 54 9d 	calla	#40276		;0x09d54

0000915e <.LBB48>:
  asm volatile("nop");
    915e:	03 43       	nop			

00009160 <.Loc.356.3>:
  _enable_interrupts();
    9160:	03 43       	nop			
    9162:	32 d2       	eint			
    9164:	03 43       	nop			

00009166 <.LBE48>:
}
    9166:	a1 00 08 00 	adda	#8,	r1	;
    916a:	06 16       	popm.a	#1,	r6	;20-bit words
    916c:	28 16       	popm.a	#3,	r10	;20-bit words
    916e:	10 01       	reta			;

00009170 <elyClampReg>:
uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    9170:	4e 4c       	mov.b	r12,	r14	;
    9172:	4c 4d       	mov.b	r13,	r12	;

00009174 <.LVL39>:
  switch(addr) {
    9174:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    9178:	9e 24       	jz	$+318    	;abs 0x92b6
    917a:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    917e:	4f 9e       	cmp.b	r14,	r15	;
    9180:	33 28       	jnc	$+104    	;abs 0x91e8
    9182:	7f 40 17 00 	mov.b	#23,	r15	;#0x0017
    9186:	4f 9e       	cmp.b	r14,	r15	;
    9188:	24 28       	jnc	$+74     	;abs 0x91d2
    918a:	7e 90 10 00 	cmp.b	#16,	r14	;#0x0010
    918e:	df 2c       	jc	$+448    	;abs 0x934e
    9190:	7e 90 07 00 	cmp.b	#7,	r14	;
    9194:	82 24       	jz	$+262    	;abs 0x929a
    9196:	7f 40 07 00 	mov.b	#7,	r15	;
    919a:	4f 9e       	cmp.b	r14,	r15	;
    919c:	10 28       	jnc	$+34     	;abs 0x91be
    919e:	7e 90 03 00 	cmp.b	#3,	r14	;
    91a2:	71 24       	jz	$+228    	;abs 0x9286

000091a4 <.L12>:
      if (addr > 0x80 && addr < 0xBF) {
    91a4:	4d 4e       	mov.b	r14,	r13	;
    91a6:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    91aa:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    91ae:	4f 9d       	cmp.b	r13,	r15	;
    91b0:	d2 28       	jnc	$+422    	;abs 0x9356

000091b2 <.Loc.331.1>:
        value = elyNLClampReg(addr, value);
    91b2:	4d 4c       	mov.b	r12,	r13	;
    91b4:	4c 4e       	mov.b	r14,	r12	;

000091b6 <.LVL41>:
    91b6:	b0 13 30 9e 	calla	#40496		;0x09e30

000091ba <.LVL42>:
    91ba:	80 00 92 92 	mova	#37522,	r0	;0x09292

000091be <.L18>:
  switch(addr) {
    91be:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    91c2:	03 24       	jz	$+8      	;abs 0x91ca
    91c4:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    91c8:	ed 23       	jnz	$-36     	;abs 0x91a4

000091ca <.L22>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    91ca:	4e 43       	clr.b	r14		;

000091cc <.L97>:
      value = clamp(value, 0, 4);
    91cc:	4d 43       	clr.b	r13		;

000091ce <.LVL44>:
    91ce:	80 00 8e 92 	mova	#37518,	r0	;0x0928e

000091d2 <.L15>:
  switch(addr) {
    91d2:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    91d6:	f9 27       	jz	$-12     	;abs 0x91ca
    91d8:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    91dc:	64 24       	jz	$+202    	;abs 0x92a6
    91de:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    91e2:	e0 23       	jnz	$-62     	;abs 0x91a4
    91e4:	80 00 ca 91 	mova	#37322,	r0	;0x091ca

000091e8 <.L14>:
    91e8:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    91ec:	64 24       	jz	$+202    	;abs 0x92b6
    91ee:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    91f2:	4f 9e       	cmp.b	r14,	r15	;
    91f4:	23 28       	jnc	$+72     	;abs 0x923c
    91f6:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    91fa:	2d 24       	jz	$+92     	;abs 0x9256
    91fc:	7f 40 25 00 	mov.b	#37,	r15	;#0x0025
    9200:	4f 9e       	cmp.b	r14,	r15	;
    9202:	07 28       	jnc	$+16     	;abs 0x9212
    9204:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    9208:	cd 23       	jnz	$-100    	;abs 0x91a4

0000920a <.L28>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    920a:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    920e:	80 00 cc 91 	mova	#37324,	r0	;0x091cc

00009212 <.L27>:
  switch(addr) {
    9212:	4d 4e       	mov.b	r14,	r13	;

00009214 <.LVL46>:
    9214:	7d 50 d6 ff 	add.b	#-42,	r13	;#0xffd6
    9218:	7f 40 09 00 	mov.b	#9,	r15	;
    921c:	4f 9d       	cmp.b	r13,	r15	;
    921e:	c2 2b       	jnc	$-122    	;abs 0x91a4

00009220 <.LBB54>:
  if ((value & 0x10) && value != 0x10) {
    9220:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    9224:	10 00 
    9226:	4b 24       	jz	$+152    	;abs 0x92be
    9228:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    922c:	48 24       	jz	$+146    	;abs 0x92be

0000922e <.Loc.165.1>:
    elyErrorSignal(ErrRegClip);
    922e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009232 <.LVL48>:
    9232:	b0 13 ca 94 	calla	#38090		;0x094ca

00009236 <.LVL49>:
    return 0x10;
    9236:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000923a <.L26>:
}
    923a:	10 01       	reta			;

0000923c <.L25>:
  switch(addr) {
    923c:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    9240:	77 24       	jz	$+240    	;abs 0x9330
    9242:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    9246:	4f 9e       	cmp.b	r14,	r15	;
    9248:	09 28       	jnc	$+20     	;abs 0x925c
    924a:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    924e:	dd 27       	jz	$-68     	;abs 0x920a
    9250:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    9254:	a7 23       	jnz	$-176    	;abs 0x91a4

00009256 <.L40>:
      return 0; /* this is purely efficiency */
    9256:	4c 43       	clr.b	r12		;
    9258:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

0000925c <.L31>:
  switch(addr) {
    925c:	4d 4e       	mov.b	r14,	r13	;

0000925e <.LVL54>:
    925e:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    9262:	7f 40 05 00 	mov.b	#5,	r15	;
    9266:	4f 9d       	cmp.b	r13,	r15	;
    9268:	9d 2b       	jnc	$-196    	;abs 0x91a4

0000926a <.LBB58>:
  if ((int8_t)(value) < min) {
    926a:	4d 4c       	mov.b	r12,	r13	;
    926c:	40 18 8d 11 	sxtx.w	r13		;
    9270:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    9274:	60 34       	jge	$+194    	;abs 0x9336

00009276 <.Loc.194.1>:
    elyErrorSignal(ErrRegClip);
    9276:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000927a <.LVL56>:
    927a:	b0 13 ca 94 	calla	#38090		;0x094ca

0000927e <.LVL57>:
    value = (uint8_t)(min);
    927e:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    9282:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

00009286 <.L19>:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    9286:	7e 40 38 00 	mov.b	#56,	r14	;#0x0038
    928a:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033

0000928e <.L96>:
      value = clamp(value, 1, 0xFF);
    928e:	b0 13 9c 8f 	calla	#36764		;0x08f9c

00009292 <.L95>:
        value = elyRFDLLClampReg(addr, value);
    9292:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009296 <.LVL61>:
    9296:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

0000929a <.L17>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    929a:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    929e:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b

000092a2 <.LVL63>:
    92a2:	80 00 8e 92 	mova	#37518,	r0	;0x0928e

000092a6 <.L23>:
      value = clamp(value, TX_POW_MIN, TX_POW_MAX);
    92a6:	7e 40 82 ff 	mov.b	#-126,	r14	;#0xff82
    92aa:	7d 40 3b 00 	mov.b	#59,	r13	;#0x003b

000092ae <.LVL65>:
    92ae:	b0 13 9c 8f 	calla	#36764		;0x08f9c

000092b2 <.LVL66>:
    92b2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000092b6 <.L13>:
      value = clamp(value, 1, 0xFF);
    92b6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    92b8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    92ba:	80 00 8e 92 	mova	#37518,	r0	;0x0928e

000092be <.L33>:
  if ((value & 0x08) && value != 0x08) {
    92be:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    92c2:	09 24       	jz	$+20     	;abs 0x92d6
    92c4:	3c 92       	cmp	#8,	r12	;r2 As==11
    92c6:	07 24       	jz	$+16     	;abs 0x92d6

000092c8 <.Loc.169.1>:
    elyErrorSignal(ErrRegClip);
    92c8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000092cc <.LVL69>:
    92cc:	b0 13 ca 94 	calla	#38090		;0x094ca

000092d0 <.LVL70>:
    return 0x08;
    92d0:	7c 42       	mov.b	#8,	r12	;r2 As==11
    92d2:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

000092d6 <.L34>:
  if ((value & 0x04) && value != 0x04) {
    92d6:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    92da:	09 24       	jz	$+20     	;abs 0x92ee
    92dc:	2c 92       	cmp	#4,	r12	;r2 As==10
    92de:	07 24       	jz	$+16     	;abs 0x92ee

000092e0 <.Loc.173.1>:
    elyErrorSignal(ErrRegClip);
    92e0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000092e4 <.LVL72>:
    92e4:	b0 13 ca 94 	calla	#38090		;0x094ca

000092e8 <.LVL73>:
    return 0x04;
    92e8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    92ea:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

000092ee <.L35>:
  if ((value & 0x02) && value != 0x02) {
    92ee:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    92f2:	09 24       	jz	$+20     	;abs 0x9306
    92f4:	2c 93       	cmp	#2,	r12	;r3 As==10
    92f6:	07 24       	jz	$+16     	;abs 0x9306

000092f8 <.Loc.177.1>:
    elyErrorSignal(ErrRegClip);
    92f8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000092fc <.LVL75>:
    92fc:	b0 13 ca 94 	calla	#38090		;0x094ca

00009300 <.LVL76>:
    return 0x02;
    9300:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9302:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

00009306 <.L36>:
  if ((value & 0x01) && value != 0x01) {
    9306:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    930a:	09 24       	jz	$+20     	;abs 0x931e
    930c:	1c 93       	cmp	#1,	r12	;r3 As==01
    930e:	07 24       	jz	$+16     	;abs 0x931e

00009310 <.Loc.181.1>:
    elyErrorSignal(ErrRegClip);
    9310:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009314 <.LVL78>:
    9314:	b0 13 ca 94 	calla	#38090		;0x094ca

00009318 <.L41>:
      value = (value == 0x00 ? 0x01 : value);
    9318:	5c 43       	mov.b	#1,	r12	;r3 As==01
    931a:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

0000931e <.L37>:
  if (value & 0xD0) {
    931e:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    9322:	8b 27       	jz	$-232    	;abs 0x923a

00009324 <.Loc.185.1>:
    elyErrorSignal(ErrRegClip);
    9324:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009328 <.LVL81>:
    9328:	b0 13 ca 94 	calla	#38090		;0x094ca

0000932c <.LVL82>:
    932c:	80 00 56 92 	mova	#37462,	r0	;0x09256

00009330 <.L30>:
      value = clamp(value, 0, 4);
    9330:	6e 42       	mov.b	#4,	r14	;r2 As==10
    9332:	80 00 cc 91 	mova	#37324,	r0	;0x091cc

00009336 <.L38>:
  else if ((int8_t)(value) > max) {
    9336:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    933a:	4e 9d       	cmp.b	r13,	r14	;
    933c:	7e 37       	jge	$-258    	;abs 0x923a

0000933e <.Loc.198.1>:
    elyErrorSignal(ErrRegClip);
    933e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009342 <.LVL85>:
    9342:	b0 13 ca 94 	calla	#38090		;0x094ca

00009346 <.LVL86>:
    value = (uint8_t)(max);
    9346:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    934a:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

0000934e <.L16>:
      value = (value == 0x00 ? 0x01 : value);
    934e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9350:	e3 27       	jz	$-56     	;abs 0x9318
    9352:	80 00 3a 92 	mova	#37434,	r0	;0x0923a

00009356 <.L39>:
      else if (addr > 0xC0) {
    9356:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    935a:	4d 9e       	cmp.b	r14,	r13	;
    935c:	6e 2f       	jc	$-290    	;abs 0x923a

0000935e <.Loc.334.1>:
        value = elyRFDLLClampReg(addr, value);
    935e:	4d 4c       	mov.b	r12,	r13	;
    9360:	4c 4e       	mov.b	r14,	r12	;

00009362 <.LVL89>:
    9362:	b0 13 1c 97 	calla	#38684		;0x0971c

00009366 <.LVL90>:
    9366:	80 00 92 92 	mova	#37522,	r0	;0x09292

0000936a <elyRegGet>:
void elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    936a:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000936c <.LCFI7>:
    936c:	49 4c       	mov.b	r12,	r9	;
    936e:	ca 0d       	mova	r13,	r10	;
    9370:	47 4e       	mov.b	r14,	r7	;

00009372 <.Loc.342.1>:
  regs_in_progress = n;
    9372:	40 18 c2 47 	movx.b	r7,	&0xfac5e;
    9376:	5e ac 

00009378 <.Loc.344.1>:
  if (bank == 0) {
    9378:	09 93       	cmp	#0,	r9	;r3 As==00
    937a:	17 24       	jz	$+48     	;abs 0x93aa
    937c:	45 43       	clr.b	r5		;

0000937e <.LBB70>:
      fram_reg(1, bank, addr, (buffer+i));
    937e:	88 00 08 90 	mova	#36872,	r8	;0x09008
    9382:	56 43       	mov.b	#1,	r6	;r3 As==01

00009384 <.L100>:
    for (int i = 0; i < n; i++) {
    9384:	05 97       	cmp	r7,	r5	;
    9386:	15 38       	jl	$+44     	;abs 0x93b2

00009388 <.LBB73>:
  return chSemWaitTimeout(&bsp->sem, time);
    9388:	4d 43       	clr.b	r13		;
    938a:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    938e:	b0 13 84 48 	calla	#18564		;0x04884

00009392 <.LBE73>:
}
    9392:	80 00 ae 93 	mova	#37806,	r0	;0x093ae

00009396 <.L102>:
      *(buffer+i) = bank0p[addr];
    9396:	6d 4a       	mov.b	@r10,	r13	;
    9398:	40 18 0c 4d 	movx.w	r13,	r12	;
    939c:	40 18 da 4c 	movx.b	42524(r12),0(r10)	;0x0a61c
    93a0:	1c a6 00 00 

000093a4 <.LBE76>:
    for (int i = 0; i < n; i++) {
    93a4:	19 53       	inc	r9		;
    93a6:	aa 00 01 00 	adda	#1,	r10	;

000093aa <.L101>:
    93aa:	09 97       	cmp	r7,	r9	;
    93ac:	f4 3b       	jl	$-22     	;abs 0x9396

000093ae <.L98>:
}
    93ae:	55 16       	popm.a	#6,	r10	;20-bit words
    93b0:	10 01       	reta			;

000093b2 <.L104>:
      fram_reg(1, bank, addr, (buffer+i));
    93b2:	cf 0a       	mova	r10,	r15	;
    93b4:	6e 4a       	mov.b	@r10,	r14	;
    93b6:	4d 49       	mov.b	r9,	r13	;
    93b8:	4c 46       	mov.b	r6,	r12	;
    93ba:	48 13       	calla	r8		;

000093bc <.LBE72>:
    for (int i = 0; i < n; i++) {
    93bc:	15 53       	inc	r5		;
    93be:	aa 00 01 00 	adda	#1,	r10	;
    93c2:	80 00 84 93 	mova	#37764,	r0	;0x09384

000093c6 <elyRegSet>:
void elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    93c6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000093c8 <.LCFI8>:
    93c8:	b1 00 06 00 	suba	#6,	r1	;

000093cc <.LCFI9>:
    93cc:	47 4c       	mov.b	r12,	r7	;
    93ce:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

000093d2 <.Loc.364.1>:
  regs_in_progress = n;
    93d2:	40 18 c2 4e 	movx.b	r14,	&0xfac5e;
    93d6:	5e ac 

000093d8 <.LBB82>:
  for (int i = 0; i < n * 2; i += 2) {
    93d8:	0e 5e       	rla	r14		;

000093da <.LVL105>:
    93da:	81 4e 04 00 	mov	r14,	4(r1)	;
    93de:	c6 0d       	mova	r13,	r6	;
    93e0:	ca 0d       	mova	r13,	r10	;
    93e2:	aa 00 01 00 	adda	#1,	r10	;
    93e6:	49 43       	clr.b	r9		;

000093e8 <.LBB83>:
    (*valuep) = elyClampReg(addr, (*valuep));
    93e8:	84 00 70 91 	mova	#37232,	r4	;0x09170

000093ec <.Loc.372.1>:
    fram_reg(0, bank, addr, valuep);
    93ec:	88 00 08 90 	mova	#36872,	r8	;0x09008
    93f0:	45 49       	mov.b	r9,	r5	;

000093f2 <.L106>:
  for (int i = 0; i < n * 2; i += 2) {
    93f2:	19 91 04 00 	cmp	4(r1),	r9	;
    93f6:	09 38       	jl	$+20     	;abs 0x940a

000093f8 <.LBB85>:
    93f8:	4d 43       	clr.b	r13		;
    93fa:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    93fe:	b0 13 84 48 	calla	#18564		;0x04884

00009402 <.LBE85>:
}
    9402:	a1 00 06 00 	adda	#6,	r1	;
    9406:	64 16       	popm.a	#7,	r10	;20-bit words
    9408:	10 01       	reta			;

0000940a <.L107>:
    uint8_t addr = buffer[i];
    940a:	6e 46       	mov.b	@r6,	r14	;

0000940c <.LVL109>:
    (*valuep) = elyClampReg(addr, (*valuep));
    940c:	6d 4a       	mov.b	@r10,	r13	;
    940e:	4c 4e       	mov.b	r14,	r12	;
    9410:	71 0e 00 00 	mova	r14,	0(r1)	;

00009414 <.LVL110>:
    9414:	44 13       	calla	r4		;

00009416 <.LVL111>:
    9416:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

0000941a <.Loc.372.1>:
    fram_reg(0, bank, addr, valuep);
    941a:	cf 0a       	mova	r10,	r15	;
    941c:	0e 01       	mova	@r1,	r14	;
    941e:	4d 47       	mov.b	r7,	r13	;
    9420:	4c 45       	mov.b	r5,	r12	;
    9422:	48 13       	calla	r8		;

00009424 <.LBE84>:
  for (int i = 0; i < n * 2; i += 2) {
    9424:	29 53       	incd	r9		;
    9426:	a6 00 02 00 	adda	#2,	r6	;
    942a:	aa 00 02 00 	adda	#2,	r10	;

0000942e <.LVL114>:
    942e:	80 00 f2 93 	mova	#37874,	r0	;0x093f2

00009432 <elyRegGetBlock>:
void elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9432:	b1 00 02 00 	suba	#2,	r1	;

00009436 <.LCFI10>:
    9436:	4b 4c       	mov.b	r12,	r11	;
    9438:	cc 0d       	mova	r13,	r12	;

0000943a <.LVL116>:
    943a:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    943e:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

00009442 <.Loc.382.1>:
  if (bank == 0) {
    9442:	0b 93       	cmp	#0,	r11	;r3 As==00
    9444:	0b 20       	jnz	$+24     	;abs 0x945c

00009446 <.Loc.383.1>:
    memcpy(buffer, bank0p + addr, n);
    9446:	40 18 0d 4e 	movx.w	r14,	r13	;

0000944a <.LVL117>:
    944a:	40 18 0e 4f 	movx.w	r15,	r14	;

0000944e <.LVL118>:
    944e:	ad 00 1c a6 	adda	#42524,	r13	;0x0a61c

00009452 <.LVL119>:
    9452:	b0 13 06 a4 	calla	#41990		;0x0a406

00009456 <.L108>:
}
    9456:	a1 00 02 00 	adda	#2,	r1	;
    945a:	10 01       	reta			;

0000945c <.L109>:
    fram_block(1, bank, addr, buffer, n);
    945c:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    9460:	cf 0d       	mova	r13,	r15	;
    9462:	4d 4b       	mov.b	r11,	r13	;
    9464:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009466 <.LVL122>:
    9466:	b0 13 a0 90 	calla	#37024		;0x090a0

0000946a <.LBB90>:
    946a:	4d 43       	clr.b	r13		;
    946c:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    9470:	b0 13 84 48 	calla	#18564		;0x04884

00009474 <.LBE90>:
}
    9474:	80 00 56 94 	mova	#37974,	r0	;0x09456

00009478 <elyRegSetBlock>:
void elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9478:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000947a <.LCFI11>:
    947a:	b1 00 02 00 	suba	#2,	r1	;

0000947e <.LCFI12>:
    947e:	49 4c       	mov.b	r12,	r9	;
    9480:	ca 0d       	mova	r13,	r10	;
    9482:	45 4e       	mov.b	r14,	r5	;
    9484:	44 4f       	mov.b	r15,	r4	;

00009486 <.LVL126>:
    9486:	c6 0d       	mova	r13,	r6	;

00009488 <.LBB95>:
  for (int i = 0; i < n; i++) {
    9488:	47 43       	clr.b	r7		;

0000948a <.Loc.398.1>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    948a:	88 00 70 91 	mova	#37232,	r8	;0x09170

0000948e <.L112>:
  for (int i = 0; i < n; i++) {
    948e:	07 94       	cmp	r4,	r7	;
    9490:	11 38       	jl	$+36     	;abs 0x94b4

00009492 <.LBE95>:
  fram_block(0, bank, addr, buffer, n);
    9492:	c1 44 00 00 	mov.b	r4,	0(r1)	;
    9496:	cf 0a       	mova	r10,	r15	;
    9498:	4e 45       	mov.b	r5,	r14	;
    949a:	4d 49       	mov.b	r9,	r13	;
    949c:	4c 43       	clr.b	r12		;
    949e:	b0 13 a0 90 	calla	#37024		;0x090a0

000094a2 <.LBB96>:
    94a2:	4d 43       	clr.b	r13		;
    94a4:	8c 00 60 ac 	mova	#44128,	r12	;0x0ac60
    94a8:	b0 13 84 48 	calla	#18564		;0x04884

000094ac <.LBE96>:
}
    94ac:	a1 00 02 00 	adda	#2,	r1	;
    94b0:	64 16       	popm.a	#7,	r10	;20-bit words
    94b2:	10 01       	reta			;

000094b4 <.L113>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    94b4:	6d 46       	mov.b	@r6,	r13	;
    94b6:	4c 47       	mov.b	r7,	r12	;
    94b8:	4c 55       	add.b	r5,	r12	;
    94ba:	48 13       	calla	r8		;

000094bc <.LVL130>:
    94bc:	c6 4c 00 00 	mov.b	r12,	0(r6)	;

000094c0 <.Loc.397.1>:
  for (int i = 0; i < n; i++) {
    94c0:	17 53       	inc	r7		;
    94c2:	a6 00 01 00 	adda	#1,	r6	;
    94c6:	80 00 8e 94 	mova	#38030,	r0	;0x0948e

000094ca <elyErrorSignal>:
    94ca:	10 01       	reta			;

000094cc <elyErrorSetRptLvlS>:
    94cc:	10 01       	reta			;

000094ce <elyErrorSetLogLvlS>:
  (void)(lvl);
}

void elyErrorSetLogLvlS(uint8_t lvl) {
  (void)(lvl);
}
    94ce:	10 01       	reta			;

000094d0 <elyEventSignal>:
    94d0:	10 01       	reta			;

000094d2 <elyEventSubscribe>:
}

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(event);
  (void)(addr);
}
    94d2:	10 01       	reta			;

000094d4 <elyEventUnsubscribe>:
    94d4:	10 01       	reta			;

000094d6 <elyEventLog>:
    94d6:	10 01       	reta			;

000094d8 <elyEventUnlog>:
  (void)(event);
}

void elyEventUnlog(uint8_t event) {
  (void)(event);
}
    94d8:	10 01       	reta			;

000094da <elyEventReset>:

void elyEventReset() {
}
    94da:	10 01       	reta			;

000094dc <elyChanSubscribe>:
    94dc:	10 01       	reta			;

000094de <elyChanUnsubscribe>:
    94de:	10 01       	reta			;

000094e0 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
  (void)(buffer);
  (void)(length);
  (void)(interval);
}
    94e0:	10 01       	reta			;

000094e2 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
  (void)(buffer);
  (void)(length);
}
    94e2:	10 01       	reta			;

000094e4 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer, uint8_t id) {
  (void)(buffer);
  (void)(id);
  return 4;
}
    94e4:	6c 42       	mov.b	#4,	r12	;r2 As==10

000094e6 <.LVL3>:
    94e6:	10 01       	reta			;

000094e8 <elyChanReset>:

void elyChanReset() {
}
    94e8:	10 01       	reta			;

000094ea <telem_fram_cb>:
  }
  
  return index;
}

static void telem_fram_cb(uint8_t * buffer) {
    94ea:	0a 14       	pushm.a	#1,	r10	;20-bit words

000094ec <.LCFI0>:
  
  chSysLockFromISR();
  
  buffer = elyNLFromFW(buffer);
    94ec:	b0 13 f6 a1 	calla	#41462		;0x0a1f6

000094f0 <.LVL1>:
    94f0:	ca 0c       	mova	r12,	r10	;

000094f2 <.LVL2>:
  
  /* Update read_index per filters */
  read_index = filter_index(read_index, &cfg);
    94f2:	40 18 5c 42 	movx.b	&0x0a71c,r12	;
    94f6:	1c a7 
    94f8:	8e 00 1e a7 	mova	#42782,	r14	;0x0a71e
    94fc:	5d 4e 08 00 	mov.b	8(r14),	r13	;
    9500:	5e 4e 09 00 	mov.b	9(r14),	r14	;

00009504 <.LBB8>:
  if (cfg->use_index) {
    9504:	40 18 c2 93 	cmpx.b	#0,	&0xfa728;r3 As==00
    9508:	28 a7 
    950a:	10 24       	jz	$+34     	;abs 0x952c

0000950c <.Loc.20.1>:
    if (cfg->index_start < cfg->index_end) {
    950c:	4d 9e       	cmp.b	r14,	r13	;
    950e:	07 2c       	jc	$+16     	;abs 0x951e

00009510 <.Loc.21.1>:
      if (index < cfg->index_start || index > cfg->index_end) {
    9510:	4c 9d       	cmp.b	r13,	r12	;
    9512:	02 28       	jnc	$+6      	;abs 0x9518
    9514:	4e 9c       	cmp.b	r12,	r14	;
    9516:	0a 2c       	jc	$+22     	;abs 0x952c

00009518 <.L6>:
    9518:	0c 4d       	mov	r13,	r12	;
    951a:	80 00 2c 95 	mova	#38188,	r0	;0x0952c

0000951e <.L3>:
      if (index > cfg->index_end && index < cfg->index_start) {
    951e:	4e 9c       	cmp.b	r12,	r14	;
    9520:	05 2c       	jc	$+12     	;abs 0x952c
    9522:	4c 9d       	cmp.b	r13,	r12	;
    9524:	01 2c       	jc	$+4      	;abs 0x9528
    9526:	4c 4d       	mov.b	r13,	r12	;

00009528 <.L4>:
    9528:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000952c <.L2>:
  read_index = filter_index(read_index, &cfg);
    952c:	40 18 c2 4c 	movx.b	r12,	&0xfa71c;
    9530:	1c a7 

00009532 <.Loc.46.1>:
  
  /* Send the buffer */
  /* TODO the hardcoded 0 here for dest_addr is fine for SPP, not for others */
  elyNLSetHeader(buffer, 256, 0);
    9532:	4e 43       	clr.b	r14		;
    9534:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9538:	cc 0a       	mova	r10,	r12	;
    953a:	b0 13 f2 9f 	calla	#40946		;0x09ff2

0000953e <.LVL5>:
  if (MSG_OK != elyRFPostI(buffer)) {
    953e:	cc 0a       	mova	r10,	r12	;
    9540:	b0 13 0e 97 	calla	#38670		;0x0970e

00009544 <.LVL6>:
    9544:	9c 00 00 00 	cmpa	#0,	r12	;
    9548:	04 24       	jz	$+10     	;abs 0x9552

0000954a <.Loc.48.1>:
    chDbgAssert(false, "internal buffer overruns should be impossible");
    954a:	8c 01 b4 05 	mova	#66996,	r12	;0x105b4
    954e:	b0 13 58 46 	calla	#18008		;0x04658

00009552 <.L1>:
  }
  
  chSysUnlockFromISR();
}
    9552:	0a 16       	popm.a	#1,	r10	;20-bit words
    9554:	10 01       	reta			;

00009556 <elyTelemUpdateConfigS>:

/* S-class due to lack of mutexes */
void elyTelemUpdateConfigS(telem_cfg_t config) {
    9556:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009558 <.LCFI1>:
    9558:	08 14       	pushm.a	#1,	r8	;20-bit words

0000955a <.LCFI2>:
    955a:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

0000955e <.LCFI3>:
    955e:	88 00 06 a4 	mova	#41990,	r8	;0x0a406
    9562:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    9566:	cd 0c       	mova	r12,	r13	;
    9568:	cc 01       	mova	r1,	r12	;
    956a:	48 13       	calla	r8		;

0000956c <.LVL8>:
  
  chDbgCheckClassS();
  
  /* Autogenerated shallow copy */
  cfg = config;
    956c:	8a 00 1e a7 	mova	#42782,	r10	;0x0a71e
    9570:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    9574:	cd 01       	mova	r1,	r13	;
    9576:	cc 0a       	mova	r10,	r12	;
    9578:	48 13       	calla	r8		;

0000957a <.LVL9>:
  
  /* Set up indexes per filters */
  init_index = filter_index(write_index, &cfg);
    957a:	40 18 5c 42 	movx.b	&0x0a71d,r12	;
    957e:	1d a7 
    9580:	5d 4a 08 00 	mov.b	8(r10),	r13	;
    9584:	5e 4a 09 00 	mov.b	9(r10),	r14	;

00009588 <.LBB12>:
  if (cfg->use_index) {
    9588:	40 18 c2 93 	cmpx.b	#0,	&0xfa728;r3 As==00
    958c:	28 a7 
    958e:	10 24       	jz	$+34     	;abs 0x95b0

00009590 <.Loc.20.1>:
    if (cfg->index_start < cfg->index_end) {
    9590:	4d 9e       	cmp.b	r14,	r13	;
    9592:	07 2c       	jc	$+16     	;abs 0x95a2

00009594 <.Loc.21.1>:
      if (index < cfg->index_start || index > cfg->index_end) {
    9594:	4c 9d       	cmp.b	r13,	r12	;
    9596:	02 28       	jnc	$+6      	;abs 0x959c
    9598:	4e 9c       	cmp.b	r12,	r14	;
    959a:	0a 2c       	jc	$+22     	;abs 0x95b0

0000959c <.L14>:
    959c:	0c 4d       	mov	r13,	r12	;
    959e:	80 00 b0 95 	mova	#38320,	r0	;0x095b0

000095a2 <.L12>:
      if (index > cfg->index_end && index < cfg->index_start) {
    95a2:	4e 9c       	cmp.b	r12,	r14	;
    95a4:	05 2c       	jc	$+12     	;abs 0x95b0
    95a6:	4c 9d       	cmp.b	r13,	r12	;
    95a8:	01 2c       	jc	$+4      	;abs 0x95ac
    95aa:	4c 4d       	mov.b	r13,	r12	;

000095ac <.L13>:
    95ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000095b0 <.L11>:
  init_index = filter_index(write_index, &cfg);
    95b0:	40 18 c2 4c 	movx.b	r12,	&0xfac6a;
    95b4:	6a ac 

000095b6 <.Loc.64.1>:
  read_index = init_index;
    95b6:	40 18 c2 4c 	movx.b	r12,	&0xfa71c;
    95ba:	1c a7 

000095bc <.Loc.67.1>:
    
  /* Signal the thread */
  chEvtSignalI(telem_thd, TelemConfigUpdated);
    95bc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    95be:	4e 43       	clr.b	r14		;
    95c0:	2c 00 62 ac 	mova	&44130,	r12	;0x0ac62
    95c4:	b0 13 98 49 	calla	#18840		;0x04998

000095c8 <.LVL12>:
}
    95c8:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    95cc:	08 16       	popm.a	#1,	r8	;20-bit words
    95ce:	0a 16       	popm.a	#1,	r10	;20-bit words
    95d0:	10 01       	reta			;

000095d2 <elyTelemPostBufferS>:

void elyTelemPostBufferS(uint8_t * buff, telemcallback_t cb) {
    95d2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000095d4 <.LCFI4>:
    95d4:	28 14       	pushm.a	#3,	r8	;20-bit words

000095d6 <.LCFI5>:
    95d6:	c8 0c       	mova	r12,	r8	;
    95d8:	ca 0d       	mova	r13,	r10	;

000095da <.Loc.74.1>:
  
  chDbgCheckClassS();
  
  buff[0] = write_index;
    95da:	40 18 dc 42 	movx.b	&0x0a71d,0(r12)	;
    95de:	1d a7 00 00 

000095e2 <.Loc.75.1>:
  buff[1] = bank0p[RegMissionTimeMsb];
    95e2:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0

000095e6 <.LVL14>:
    95e6:	d8 4c 76 00 	mov.b	118(r12),1(r8)	;0x00076
    95ea:	01 00 

000095ec <.Loc.76.1>:
  buff[2] = bank0p[RegMissionTimeHmb];
    95ec:	d8 4c 75 00 	mov.b	117(r12),2(r8)	;0x00075
    95f0:	02 00 

000095f2 <.Loc.77.1>:
  buff[3] = bank0p[RegMissionTimeLmb];
    95f2:	d8 4c 74 00 	mov.b	116(r12),3(r8)	;0x00074
    95f6:	03 00 

000095f8 <.Loc.78.1>:
  buff[4] = bank0p[RegMissionTimeLsb];
    95f8:	d8 4c 73 00 	mov.b	115(r12),4(r8)	;0x00073
    95fc:	04 00 

000095fe <.Loc.82.1>:

  /* Get an FRAM request block */
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&request, TIME_INFINITE);
    95fe:	4d 43       	clr.b	r13		;

00009600 <.LVL15>:
    9600:	8c 00 66 ac 	mova	#44134,	r12	;0x0ac66
    9604:	b0 13 78 9d 	calla	#40312		;0x09d78

00009608 <.LVL16>:
  
  /* Calculate the FRAM address based on the current index */
  request->address = FRAM_TELEM_BASE + (256U * write_index);
    9608:	2c 00 66 ac 	mova	&44134,	r12	;0x0ac66
    960c:	40 18 5d 42 	movx.b	&0x0a71d,r13	;
    9610:	1d a7 
    9612:	0e 4d       	mov	r13,	r14	;
    9614:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9618:	06 4e       	mov	r14,	r6	;
    961a:	07 43       	clr	r7		;
    961c:	8c 46 00 00 	mov	r6,	0(r12)	;
    9620:	8c 47 02 00 	mov	r7,	2(r12)	;

00009624 <.Loc.86.1>:
  write_index++;
    9624:	5d 53       	inc.b	r13		;
    9626:	40 18 c2 4d 	movx.b	r13,	&0xfa71d;
    962a:	1d a7 

0000962c <.Loc.88.1>:
  /* Fill in the rest of the request block */
  request->read = 0;
    962c:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

00009630 <.Loc.89.1>:
  request->size = 256;
    9630:	1d 4c 04 00 	mov	4(r12),	r13	;
    9634:	7d f0 03 00 	and.b	#3,	r13	;
    9638:	3d d0 00 04 	bis	#1024,	r13	;#0x0400
    963c:	8c 4d 04 00 	mov	r13,	4(r12)	;
    9640:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    9644:	06 00 

00009646 <.Loc.90.1>:
  request->buffer = buff;
    9646:	7c 08 08 00 	mova	r8,	8(r12)	;

0000964a <.Loc.91.1>:
  request->callback = cb;
    964a:	7c 0a 0c 00 	mova	r10,	12(r12)	; 0x0000c

0000964e <.Loc.94.1>:
  
  /* Post the request */
  elyFramPostRequestS(request);
    964e:	b0 13 54 9d 	calla	#40276		;0x09d54

00009652 <.LVL17>:
}
    9652:	26 16       	popm.a	#3,	r8	;20-bit words
    9654:	0a 16       	popm.a	#1,	r10	;20-bit words
    9656:	10 01       	reta			;

00009658 <TelemThd>:

THD_WORKING_AREA(waTelemThd, 256);
THD_FUNCTION(TelemThd, arg) {
    9658:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000965a <.LCFI6>:
  (void)(arg);
  
  /* Store a thread pointer for later use */
  telem_thd = chThdGetSelfX();
    965a:	80 18 d2 42 	movx.a	&0x1077c,&0xfac62;
    965e:	7c 07 62 ac 

00009662 <.LBB24>:
  
  /* Event loop */
  while (true) {
    eventmask_t evt = chEvtWaitAnyTimeout(TelemConfigUpdated, TIME_INFINITE);
    9662:	87 00 e0 49 	mova	#18912,	r7	;0x049e0

00009666 <.Loc.107.1>:
    chDbgAssert(TelemConfigUpdated == evt, "Woke up without an event!");
    9666:	84 00 58 46 	mova	#18008,	r4	;0x04658

0000966a <.LBB25>:
    
    do {
      /* Get the firmware buffer */
      chSysLock();
      uint8_t * buff = elyFWGetBufferTimeoutS(TIME_INFINITE);
    966a:	89 00 2c 65 	mova	#25900,	r9	;0x0652c

0000966e <.L20>:
    eventmask_t evt = chEvtWaitAnyTimeout(TelemConfigUpdated, TIME_INFINITE);
    966e:	4e 43       	clr.b	r14		;
    9670:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9672:	4d 43       	clr.b	r13		;
    9674:	47 13       	calla	r7		;

00009676 <.LVL20>:
    chDbgAssert(TelemConfigUpdated == evt, "Woke up without an event!");
    9676:	1c 93       	cmp	#1,	r12	;r3 As==01
    9678:	02 20       	jnz	$+6      	;abs 0x967e
    967a:	0d 93       	cmp	#0,	r13	;r3 As==00
    967c:	03 24       	jz	$+8      	;abs 0x9684

0000967e <.L21>:
    967e:	8c 01 c2 05 	mova	#67010,	r12	;0x105c2

00009682 <.LVL21>:
    9682:	44 13       	calla	r4		;

00009684 <.L17>:
      
      /* Get an FRAM request block */
      elyFramGetRequestTimeoutS(&request, TIME_INFINITE);
    9684:	88 00 78 9d 	mova	#40312,	r8	;0x09d78

00009688 <.L19>:
  _disable_interrupts();
    9688:	32 c2       	dint			
    968a:	03 43       	nop			

0000968c <.Loc.348.2>:
  asm volatile("nop");
    968c:	03 43       	nop			

0000968e <.LBE26>:
      uint8_t * buff = elyFWGetBufferTimeoutS(TIME_INFINITE);
    968e:	4c 43       	clr.b	r12		;
    9690:	49 13       	calla	r9		;

00009692 <.LVL23>:
    9692:	ca 0c       	mova	r12,	r10	;

00009694 <.Loc.115.1>:
      elyFramGetRequestTimeoutS(&request, TIME_INFINITE);
    9694:	4d 43       	clr.b	r13		;
    9696:	8c 00 66 ac 	mova	#44134,	r12	;0x0ac66
    969a:	48 13       	calla	r8		;

0000969c <.LBB28>:
  asm volatile("nop");
    969c:	03 43       	nop			

0000969e <.Loc.356.2>:
  _enable_interrupts();
    969e:	03 43       	nop			
    96a0:	32 d2       	eint			
    96a2:	03 43       	nop			

000096a4 <.LBE28>:
      chSysUnlock();
      
      /* Calculate the FRAM address based on the current index */
      request->address = FRAM_TELEM_BASE + (256U * read_index);
    96a4:	2c 00 66 ac 	mova	&44134,	r12	;0x0ac66
    96a8:	40 18 5d 42 	movx.b	&0x0a71c,r13	;
    96ac:	1c a7 
    96ae:	0e 4d       	mov	r13,	r14	;
    96b0:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    96b4:	05 4e       	mov	r14,	r5	;
    96b6:	06 43       	clr	r6		;
    96b8:	8c 45 00 00 	mov	r5,	0(r12)	;
    96bc:	8c 46 02 00 	mov	r6,	2(r12)	;

000096c0 <.Loc.120.1>:
      read_index++;
    96c0:	5d 53       	inc.b	r13		;
    96c2:	40 18 c2 4d 	movx.b	r13,	&0xfa71c;
    96c6:	1c a7 

000096c8 <.Loc.122.1>:
      /* Fill in the rest of the request block */
      request->read = 1;
    96c8:	ec d3 04 00 	bis.b	#2,	4(r12)	;r3 As==10

000096cc <.Loc.123.1>:
      request->size = 256;
    96cc:	1d 4c 04 00 	mov	4(r12),	r13	;
    96d0:	7d f0 03 00 	and.b	#3,	r13	;
    96d4:	3d d0 00 04 	bis	#1024,	r13	;#0x0400
    96d8:	8c 4d 04 00 	mov	r13,	4(r12)	;
    96dc:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    96e0:	06 00 

000096e2 <.Loc.124.1>:
      request->buffer = buff;
    96e2:	7c 0a 08 00 	mova	r10,	8(r12)	;

000096e6 <.Loc.125.1>:
      request->callback = telem_fram_cb;
    96e6:	00 18 fc 40 	movx.a	#38122,	12(r12)	;0x094ea, 0x0000c
    96ea:	ea 94 0c 00 

000096ee <.LBB30>:
  _disable_interrupts();
    96ee:	32 c2       	dint			
    96f0:	03 43       	nop			

000096f2 <.Loc.348.2>:
  asm volatile("nop");
    96f2:	03 43       	nop			

000096f4 <.LBE30>:
      
      /* Post the request */
      chSysLock();
      elyFramPostRequestS(request);
    96f4:	b0 13 54 9d 	calla	#40276		;0x09d54

000096f8 <.LBB32>:
  asm volatile("nop");
    96f8:	03 43       	nop			

000096fa <.Loc.356.2>:
  _enable_interrupts();
    96fa:	03 43       	nop			
    96fc:	32 d2       	eint			
    96fe:	03 43       	nop			

00009700 <.LBE32>:
      chSysUnlock();
    } while (read_index != init_index);
    9700:	40 18 d2 92 	cmpx.b	&0x0ac6a,&0xfa71c;
    9704:	6a ac 1c a7 
    9708:	bf 23       	jnz	$-128    	;abs 0x9688
    970a:	80 00 6e 96 	mova	#38510,	r0	;0x0966e

0000970e <elyRFPostI>:

#include "rf.h"

msg_t elyRFPostI(uint8_t * buffer) {
  return elyUARTPostI(buffer);
    970e:	b0 13 0e 62 	calla	#25102		;0x0620e

00009712 <.LVL1>:
}
    9712:	10 01       	reta			;

00009714 <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
  return elyUARTPost(buffer, timeout);
    9714:	b0 13 42 62 	calla	#25154		;0x06242

00009718 <.LVL3>:
}
    9718:	10 01       	reta			;

0000971a <elyRFCfgMarkDirty>:
  (void)(event);
}

void elyRFCfgMarkDirty(rf_events_t event) {
  (void)(event);
}
    971a:	10 01       	reta			;

0000971c <elyRFDLLClampReg>:
#include "core.h"

uint8_t elyRFDLLClampReg(uint8_t addr, uint8_t value) {
  (void)(addr);
  return value;
}
    971c:	4c 4d       	mov.b	r13,	r12	;

0000971e <.LVL1>:
    971e:	10 01       	reta			;

00009720 <elyUARTDLLTxStateMachine>:

msg_t elyUARTDLLTxStateMachine() {
  static slip_uart_states_t tx_state = ELY_SLIP_NOT_ESCAPED;
  static msg_t escaped_char;
  
  if (NULL == tx_active_buffer) {
    9720:	2c 00 7c ac 	mova	&44156,	r12	;0x0ac7c
    9724:	9c 00 00 00 	cmpa	#0,	r12	;
    9728:	50 24       	jz	$+162    	;abs 0x97ca

0000972a <.Loc.19.1>:
    return MSG_RESET; /* state machine parked until next buffer posted */
  }
  
  chDbgAssert((tx_read_ptr - tx_active_buffer) >= 0, "Somehow read backwards");
    972a:	2e 00 78 ac 	mova	&44152,	r14	;0x0ac78
    972e:	fe 0c       	suba	r12,	r14	;
    9730:	9e 00 00 00 	cmpa	#0,	r14	;
    9734:	04 34       	jge	$+10     	;abs 0x973e

00009736 <.Loc.19.1>:
    9736:	8c 01 fa 05 	mova	#67066,	r12	;0x105fa
    973a:	b0 13 58 46 	calla	#18008		;0x04658

0000973e <.L3>:
  if ((size_t)(tx_read_ptr - tx_active_buffer) == tx_n) {
    973e:	2e 00 78 ac 	mova	&44152,	r14	;0x0ac78
    9742:	00 18 4c 4e 	movx.a	r14,	r12	;
    9746:	00 18 5c 82 	subx.a	&0x0ac7c,r12	;
    974a:	7c ac 
    974c:	00 18 5c 92 	cmpx.a	&0x0ac74,r12	;
    9750:	74 ac 
    9752:	09 20       	jnz	$+20     	;abs 0x9766

00009754 <.Loc.21.1>:
    tx_state = ELY_SLIP_NOT_ESCAPED;
    9754:	41 18 e2 43 	movx.b	#2,	&0x10735;r3 As==10
    9758:	35 07 

0000975a <.Loc.22.1>:
    tx_active_buffer = NULL;
    975a:	00 18 c2 43 	movx.a	#0,	&0xfac7c;r3 As==00
    975e:	7c ac 

00009760 <.Loc.23.1>:
    return SLIP_END;
    9760:	7c 40 c0 00 	mov.b	#192,	r12	;#0x00c0

00009764 <.L1>:
    default:
      chSysHalt("unreachable");
  }
  
  return MSG_RESET; /* unreachable */
}
    9764:	10 01       	reta			;

00009766 <.L4>:
  switch (tx_state) {
    9766:	c0 18 5c 42 	movx.b	&0x10735,r12	;
    976a:	35 07 
    976c:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    976e:	1a 24       	jz	$+54     	;abs 0x97a4
    9770:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9772:	27 20       	jnz	$+80     	;abs 0x97c2

00009774 <.Loc.26.1>:
  msg_t c = *tx_read_ptr;
    9774:	6d 4e       	mov.b	@r14,	r13	;
    9776:	40 18 0c 4d 	movx.w	r13,	r12	;

0000977a <.Loc.30.1>:
      if (c == SLIP_ESC || c == SLIP_END) {
    977a:	9c 00 db 00 	cmpa	#219,	r12	;0x000db
    977e:	03 24       	jz	$+8      	;abs 0x9786

00009780 <.Loc.30.1>:
    9780:	9c 00 c0 00 	cmpa	#192,	r12	;0x000c0
    9784:	09 20       	jnz	$+20     	;abs 0x9798

00009786 <.L8>:
        tx_state = ELY_SLIP_ESCAPED;
    9786:	41 18 d2 43 	movx.b	#1,	&0x10735;r3 As==01
    978a:	35 07 

0000978c <.Loc.32.1>:
        escaped_char = c;
    978c:	60 0c 70 ac 	mova	r12,	&44144	; 0x0ac70

00009790 <.Loc.33.1>:
        return SLIP_ESC;
    9790:	7c 40 db 00 	mov.b	#219,	r12	;#0x00db
    9794:	80 00 64 97 	mova	#38756,	r0	;0x09764

00009798 <.L9>:
        tx_read_ptr++;
    9798:	ae 00 01 00 	adda	#1,	r14	;
    979c:	60 0e 78 ac 	mova	r14,	&44152	; 0x0ac78

000097a0 <.Loc.37.1>:
        return c;
    97a0:	80 00 64 97 	mova	#38756,	r0	;0x09764

000097a4 <.L6>:
      tx_read_ptr++;
    97a4:	ae 00 01 00 	adda	#1,	r14	;
    97a8:	60 0e 78 ac 	mova	r14,	&44152	; 0x0ac78

000097ac <.Loc.42.1>:
      tx_state = ELY_SLIP_NOT_ESCAPED;
    97ac:	41 18 e2 43 	movx.b	#2,	&0x10735;r3 As==10
    97b0:	35 07 

000097b2 <.Loc.43.1>:
      if (escaped_char == SLIP_ESC) {
    97b2:	2c 00 70 ac 	mova	&44144,	r12	;0x0ac70
    97b6:	9c 00 db 00 	cmpa	#219,	r12	;0x000db
    97ba:	0b 24       	jz	$+24     	;abs 0x97d2

000097bc <.Loc.46.1>:
      else if (escaped_char == SLIP_END) {
    97bc:	9c 00 c0 00 	cmpa	#192,	r12	;0x000c0
    97c0:	0c 24       	jz	$+26     	;abs 0x97da

000097c2 <.L16>:
      chSysHalt("unreachable");
    97c2:	8c 00 9d a5 	mova	#42397,	r12	;0x0a59d
    97c6:	b0 13 58 46 	calla	#18008		;0x04658

000097ca <.L10>:
    return MSG_RESET; /* state machine parked until next buffer posted */
    97ca:	8c 0f fe ff 	mova	#-2,	r12	;0xfffffffe
    97ce:	80 00 64 97 	mova	#38756,	r0	;0x09764

000097d2 <.L11>:
        return SLIP_ESC_ESC;
    97d2:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    97d6:	80 00 64 97 	mova	#38756,	r0	;0x09764

000097da <.L12>:
        return SLIP_ESC_END;
    97da:	7c 40 dc 00 	mov.b	#220,	r12	;#0x00dc
    97de:	80 00 64 97 	mova	#38756,	r0	;0x09764

000097e2 <elyUARTDLLTxSetBuffer>:

void elyUARTDLLTxSetBuffer(uint8_t * buffer) {
    97e2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000097e4 <.LCFI0>:
    97e4:	ca 0c       	mova	r12,	r10	;

000097e6 <.Loc.61.1>:
  chDbgAssert(NULL == tx_active_buffer, "Incorrect event on buffer posting");
    97e6:	00 18 c2 93 	cmpx.a	#0,	&0xfac7c;r3 As==00
    97ea:	7c ac 
    97ec:	04 24       	jz	$+10     	;abs 0x97f6

000097ee <.Loc.61.1>:
    97ee:	8c 01 e4 05 	mova	#67044,	r12	;0x105e4

000097f2 <.LVL13>:
    97f2:	b0 13 58 46 	calla	#18008		;0x04658

000097f6 <.L18>:
  tx_active_buffer = buffer;
    97f6:	60 0a 7c ac 	mova	r10,	&44156	; 0x0ac7c

000097fa <.Loc.63.1>:
  tx_read_ptr = tx_active_buffer;
    97fa:	60 0a 78 ac 	mova	r10,	&44152	; 0x0ac78

000097fe <.Loc.64.1>:
  tx_n = elyNLGetLength(tx_active_buffer);
    97fe:	cc 0a       	mova	r10,	r12	;
    9800:	b0 13 e0 a0 	calla	#41184		;0x0a0e0

00009804 <.LVL15>:
    9804:	60 0c 74 ac 	mova	r12,	&44148	; 0x0ac74

00009808 <.Loc.65.1>:
}
    9808:	0a 16       	popm.a	#1,	r10	;20-bit words
    980a:	10 01       	reta			;

0000980c <elyUARTDLLRxInit>:

void elyUARTDLLRxInit() {
  
}
    980c:	10 01       	reta			;

0000980e <elyUARTDLLTimeoutCB>:
 * timeouts differently in uart.c */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
  
  elyNLFreeBufferI(rx_active_buffer);
    980e:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82

00009812 <.LVL17>:
    9812:	b0 13 56 9f 	calla	#40790		;0x09f56

00009816 <.LVL18>:
  rx_active_buffer = NULL;
    9816:	00 18 c2 43 	movx.a	#0,	&0xfac82;r3 As==00
    981a:	82 ac 

0000981c <.Loc.79.1>:
  rx_state = ELY_SLIP_RESET;
    981c:	40 18 c2 43 	movx.b	#0,	&0xfac80;r3 As==00
    9820:	80 ac 

00009822 <.Loc.83.1>:
  
  chSysUnlockFromISR();

}
    9822:	10 01       	reta			;

00009824 <elyUARTDLLRxStateMachine>:

void elyUARTDLLRxStateMachine(msg_t c) {
    9824:	2a 14       	pushm.a	#3,	r10	;20-bit words

00009826 <.LCFI1>:
    9826:	ca 0c       	mova	r12,	r10	;

00009828 <.Loc.90.1>:
  static uint8_t * rx_write_ptr = NULL;
  static size_t rx_n = elyNLHeaderLen;
  static bool header = true;
  
  size_t pkt_len = (size_t)(rx_write_ptr - rx_active_buffer);
    9828:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82

0000982c <.LVL20>:
    982c:	28 00 6c ac 	mova	&44140,	r8	;0x0ac6c
    9830:	f8 0c       	suba	r12,	r8	;

00009832 <.Loc.92.1>:
  
  if (header && pkt_len == rx_n) {
    9832:	41 18 c2 93 	cmpx.b	#0,	&0x10734;r3 As==00
    9836:	34 07 
    9838:	1e 24       	jz	$+62     	;abs 0x9876

0000983a <.Loc.92.1>:
    983a:	80 18 58 92 	cmpx.a	&0x10730,r8	;
    983e:	30 07 
    9840:	16 20       	jnz	$+46     	;abs 0x986e

00009842 <.Loc.93.1>:
    if (elyNLValidate(rx_active_buffer)) {
    9842:	b0 13 f8 a0 	calla	#41208		;0x0a0f8

00009846 <.LVL22>:
    9846:	49 4c       	mov.b	r12,	r9	;
    9848:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82
    984c:	49 93       	cmp.b	#0,	r9	;r3 As==00
    984e:	69 24       	jz	$+212    	;abs 0x9922

00009850 <.Loc.94.1>:
        rx_n = elyNLGetLength(rx_active_buffer);
    9850:	b0 13 e0 a0 	calla	#41184		;0x0a0e0

00009854 <.LVL23>:
    9854:	61 0c 30 07 	mova	r12,	&67376	; 0x10730

00009858 <.Loc.95.1>:
        if (rx_n <= elyNLMaxLen && rx_n > elyNLHeaderLen) {
    9858:	00 18 c2 9c 	cmpx.a	r12,	&0xfa79c;
    985c:	9c a7 
    985e:	55 28       	jnc	$+172    	;abs 0x990a

00009860 <.Loc.95.1>:
    9860:	7d 40 06 00 	mov.b	#6,	r13	;
    9864:	dd 0c       	cmpa	r12,	r13	;
    9866:	51 2c       	jc	$+164    	;abs 0x990a

00009868 <.Loc.96.1>:
          header = false;
    9868:	41 18 c2 43 	movx.b	#0,	&0x10734;r3 As==00
    986c:	34 07 

0000986e <.L22>:
      rx_active_buffer = NULL;
      rx_state = ELY_SLIP_RESET;
    }
  }
  
  if (!header && pkt_len == rx_n && (c != SLIP_END || rx_state != ELY_SLIP_NOT_ESCAPED)) {
    986e:	41 18 c2 93 	cmpx.b	#0,	&0x10734;r3 As==00
    9872:	34 07 
    9874:	15 20       	jnz	$+44     	;abs 0x98a0

00009876 <.L43>:
    9876:	80 18 58 92 	cmpx.a	&0x10730,r8	;
    987a:	30 07 
    987c:	11 20       	jnz	$+36     	;abs 0x98a0

0000987e <.Loc.113.1>:
    987e:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    9882:	04 20       	jnz	$+10     	;abs 0x988c

00009884 <.Loc.113.1>:
    9884:	40 18 e2 93 	cmpx.b	#2,	&0xfac80;r3 As==10
    9888:	80 ac 
    988a:	0a 24       	jz	$+22     	;abs 0x98a0

0000988c <.L26>:
    /* Packet too long or invalid */
    elyNLFreeBuffer(rx_active_buffer);
    988c:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82
    9890:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00009894 <.LVL24>:
    rx_active_buffer = NULL;
    9894:	00 18 c2 43 	movx.a	#0,	&0xfac82;r3 As==00
    9898:	82 ac 

0000989a <.Loc.117.1>:
    rx_state = ELY_SLIP_RESET;
    989a:	40 18 c2 43 	movx.b	#0,	&0xfac80;r3 As==00
    989e:	80 ac 

000098a0 <.L25>:
  }
  
  if (rx_state == ELY_SLIP_RESET) {
    98a0:	40 18 5c 42 	movx.b	&0x0ac80,r12	;
    98a4:	80 ac 
    98a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    98a8:	46 20       	jnz	$+142    	;abs 0x9936

000098aa <.Loc.121.1>:
    chDbgAssert(NULL == rx_active_buffer, "Reset without freeing buffer");
    98aa:	00 18 c2 93 	cmpx.a	#0,	&0xfac82;r3 As==00
    98ae:	82 ac 
    98b0:	04 24       	jz	$+10     	;abs 0x98ba

000098b2 <.Loc.121.1>:
    98b2:	8c 01 cb 05 	mova	#67019,	r12	;0x105cb
    98b6:	b0 13 58 46 	calla	#18008		;0x04658

000098ba <.L28>:
    rx_active_buffer = elyNLGetBuffer();
    98ba:	b0 13 40 9f 	calla	#40768		;0x09f40

000098be <.LVL26>:
    98be:	60 0c 82 ac 	mova	r12,	&44162	; 0x0ac82

000098c2 <.Loc.123.1>:
    if (NULL == rx_active_buffer) {
    98c2:	9c 00 00 00 	cmpa	#0,	r12	;
    98c6:	78 24       	jz	$+242    	;abs 0x99b8

000098c8 <.Loc.127.1>:
      /* TODO signal a buffer overflow here */
      return;
    }
    rx_write_ptr = rx_active_buffer;
    98c8:	60 0c 6c ac 	mova	r12,	&44140	; 0x0ac6c

000098cc <.Loc.128.1>:
    rx_n = elyNLHeaderLen;
    98cc:	01 18 f2 40 	movx.a	#6,	&0x10730;
    98d0:	06 00 30 07 

000098d4 <.Loc.129.1>:
    header = true;
    98d4:	41 18 d2 43 	movx.b	#1,	&0x10734;r3 As==01
    98d8:	34 07 

000098da <.Loc.130.1>:
    rx_state = ELY_SLIP_NOT_ESCAPED;
    98da:	40 18 e2 43 	movx.b	#2,	&0xfac80;r3 As==10
    98de:	80 ac 

000098e0 <.Loc.136.1>:
  }
  
  /*gptStopTimerI(&uart_gpt);*/
  /*gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);*/
  
  switch (c) {
    98e0:	9a 00 db 00 	cmpa	#219,	r10	;0x000db
    98e4:	61 24       	jz	$+196    	;abs 0x99a8
    98e6:	7c 40 db 00 	mov.b	#219,	r12	;#0x00db
    98ea:	dc 0a       	cmpa	r10,	r12	;
    98ec:	44 38       	jl	$+138    	;abs 0x9976
    98ee:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    98f2:	2d 24       	jz	$+92     	;abs 0x994e

000098f4 <.L31>:
        rx_state = ELY_SLIP_NOT_ESCAPED;
        return;
      }
      /* intentional fallthrough */
    default:
      *rx_write_ptr++ = (uint8_t)(c);
    98f4:	2c 00 6c ac 	mova	&44140,	r12	;0x0ac6c
    98f8:	cd 0c       	mova	r12,	r13	;
    98fa:	ad 00 01 00 	adda	#1,	r13	;
    98fe:	60 0d 6c ac 	mova	r13,	&44140	; 0x0ac6c
    9902:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00009906 <.Loc.177.1>:
      return;
    9906:	80 00 b8 99 	mova	#39352,	r0	;0x099b8

0000990a <.L24>:
          elyNLFreeBuffer(rx_active_buffer);
    990a:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82
    990e:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00009912 <.LVL27>:
          rx_active_buffer = NULL;
    9912:	00 18 c2 43 	movx.a	#0,	&0xfac82;r3 As==00
    9916:	82 ac 

00009918 <.Loc.102.1>:
          rx_state = ELY_SLIP_RESET;
    9918:	40 18 c2 43 	movx.b	#0,	&0xfac80;r3 As==00
    991c:	80 ac 
    991e:	80 00 6e 98 	mova	#39022,	r0	;0x0986e

00009922 <.L23>:
      elyNLFreeBuffer(rx_active_buffer);
    9922:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00009926 <.LVL28>:
      rx_active_buffer = NULL;
    9926:	00 18 c2 43 	movx.a	#0,	&0xfac82;r3 As==00
    992a:	82 ac 

0000992c <.Loc.109.1>:
      rx_state = ELY_SLIP_RESET;
    992c:	40 18 c2 49 	movx.b	r9,	&0xfac80;
    9930:	80 ac 
    9932:	80 00 6e 98 	mova	#39022,	r0	;0x0986e

00009936 <.L27>:
  switch (c) {
    9936:	9a 00 db 00 	cmpa	#219,	r10	;0x000db
    993a:	36 24       	jz	$+110    	;abs 0x99a8
    993c:	7d 40 db 00 	mov.b	#219,	r13	;#0x00db
    9940:	dd 0a       	cmpa	r10,	r13	;
    9942:	19 38       	jl	$+52     	;abs 0x9976
    9944:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    9948:	d5 23       	jnz	$-84     	;abs 0x98f4

0000994a <.Loc.150.1>:
      if (rx_state == ELY_SLIP_NOT_ESCAPED && pkt_len == rx_n && !header) {
    994a:	2c 93       	cmp	#2,	r12	;r3 As==10
    994c:	39 20       	jnz	$+116    	;abs 0x99c0

0000994e <.L34>:
    994e:	80 18 58 92 	cmpx.a	&0x10730,r8	;
    9952:	30 07 
    9954:	35 20       	jnz	$+108    	;abs 0x99c0

00009956 <.Loc.150.1>:
    9956:	41 18 c2 93 	cmpx.b	#0,	&0x10734;r3 As==00
    995a:	34 07 
    995c:	31 20       	jnz	$+100    	;abs 0x99c0

0000995e <.Loc.151.1>:
        elyNLRouteUART(rx_active_buffer);
    995e:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82
    9962:	b0 13 d8 a1 	calla	#41432		;0x0a1d8

00009966 <.L42>:
      rx_active_buffer = NULL;
    9966:	00 18 c2 43 	movx.a	#0,	&0xfac82;r3 As==00
    996a:	82 ac 

0000996c <.Loc.158.1>:
      rx_state = ELY_SLIP_RESET;
    996c:	40 18 c2 43 	movx.b	#0,	&0xfac80;r3 As==00
    9970:	80 ac 

00009972 <.Loc.160.1>:
      return;
    9972:	80 00 b8 99 	mova	#39352,	r0	;0x099b8

00009976 <.L37>:
  switch (c) {
    9976:	9a 00 dc 00 	cmpa	#220,	r10	;0x000dc
    997a:	28 24       	jz	$+82     	;abs 0x99cc
    997c:	9a 00 dd 00 	cmpa	#221,	r10	;0x000dd
    9980:	b9 23       	jnz	$-140    	;abs 0x98f4

00009982 <.Loc.162.1>:
      if (rx_state == ELY_SLIP_ESCAPED) {
    9982:	40 18 d2 93 	cmpx.b	#1,	&0xfac80;r3 As==01
    9986:	80 ac 
    9988:	b5 23       	jnz	$-148    	;abs 0x98f4

0000998a <.Loc.163.1>:
        *rx_write_ptr++ = SLIP_ESC;
    998a:	2c 00 6c ac 	mova	&44140,	r12	;0x0ac6c
    998e:	cd 0c       	mova	r12,	r13	;
    9990:	ad 00 01 00 	adda	#1,	r13	;
    9994:	60 0d 6c ac 	mova	r13,	&44140	; 0x0ac6c
    9998:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    999c:	00 00 

0000999e <.L66>:
        rx_state = ELY_SLIP_NOT_ESCAPED;
    999e:	40 18 e2 43 	movx.b	#2,	&0xfac80;r3 As==10
    99a2:	80 ac 

000099a4 <.Loc.172.1>:
        return;
    99a4:	80 00 b8 99 	mova	#39352,	r0	;0x099b8

000099a8 <.L32>:
      if (rx_state == ELY_SLIP_NOT_ESCAPED) {
    99a8:	40 18 5c 42 	movx.b	&0x0ac80,r12	;
    99ac:	80 ac 
    99ae:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    99b0:	05 20       	jnz	$+12     	;abs 0x99bc

000099b2 <.Loc.139.1>:
        rx_state = ELY_SLIP_ESCAPED;
    99b2:	40 18 d2 43 	movx.b	#1,	&0xfac80;r3 As==01
    99b6:	80 ac 

000099b8 <.L21>:
  }
}
    99b8:	28 16       	popm.a	#3,	r10	;20-bit words
    99ba:	10 01       	reta			;

000099bc <.L39>:
      else if (rx_state == ELY_SLIP_ESCAPED) {
    99bc:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    99be:	fc 23       	jnz	$-6      	;abs 0x99b8

000099c0 <.L41>:
        elyNLFreeBuffer(rx_active_buffer);
    99c0:	2c 00 82 ac 	mova	&44162,	r12	;0x0ac82
    99c4:	b0 13 4a 9f 	calla	#40778		;0x09f4a

000099c8 <.LVL30>:
    99c8:	80 00 66 99 	mova	#39270,	r0	;0x09966

000099cc <.L35>:
      if (rx_state == ELY_SLIP_ESCAPED) {
    99cc:	40 18 d2 93 	cmpx.b	#1,	&0xfac80;r3 As==01
    99d0:	80 ac 
    99d2:	90 23       	jnz	$-222    	;abs 0x98f4

000099d4 <.Loc.170.1>:
        *rx_write_ptr++ = SLIP_END;
    99d4:	2c 00 6c ac 	mova	&44140,	r12	;0x0ac6c
    99d8:	cd 0c       	mova	r12,	r13	;
    99da:	ad 00 01 00 	adda	#1,	r13	;
    99de:	60 0d 6c ac 	mova	r13,	&44140	; 0x0ac6c
    99e2:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    99e6:	00 00 
    99e8:	80 00 9e 99 	mova	#39326,	r0	;0x0999e

000099ec <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    99ec:	0a 14       	pushm.a	#1,	r10	;20-bit words

000099ee <.LCFI0>:
    99ee:	08 14       	pushm.a	#1,	r8	;20-bit words

000099f0 <.LCFI1>:
    99f0:	06 14       	pushm.a	#1,	r6	;20-bit words

000099f2 <.LCFI2>:
    99f2:	ca 0c       	mova	r12,	r10	;
    99f4:	c8 0d       	mova	r13,	r8	;

000099f6 <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    99f6:	40 18 c2 93 	cmpx.b	#0,	&0xfac86;r3 As==00
    99fa:	86 ac 
    99fc:	04 24       	jz	$+10     	;abs 0x9a06

000099fe <.Loc.34.1>:
    99fe:	8c 01 30 06 	mova	#67120,	r12	;0x10630

00009a02 <.LVL1>:
    9a02:	b0 13 58 46 	calla	#18008		;0x04658

00009a06 <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    9a06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9a08:	dc 08       	cmpa	r8,	r12	;
    9a0a:	04 28       	jnc	$+10     	;abs 0x9a14

00009a0c <.Loc.38.1>:
    9a0c:	8c 01 30 06 	mova	#67120,	r12	;0x10630
    9a10:	b0 13 58 46 	calla	#18008		;0x04658

00009a14 <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9a14:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    9a18:	54 01 

00009a1a <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9a1a:	ce 0a       	mova	r10,	r14	;
    9a1c:	cc 08       	mova	r8,	r12	;
    9a1e:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

00009a22 <.L4>:
    9a22:	00 18 46 4e 	movx.a	r14,	r6	;
    9a26:	00 18 46 8a 	subx.a	r10,	r6	;

00009a2a <.LVL6>:
    9a2a:	d6 0c       	cmpa	r12,	r6	;
    9a2c:	12 28       	jnc	$+38     	;abs 0x9a52

00009a2e <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    9a2e:	ec 0a       	adda	r10,	r12	;
    9a30:	40 18 5d 42 	movx.b	&0x00157,r13	;
    9a34:	57 01 
    9a36:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    9a38:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00009a3c <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    9a3c:	ea 08       	adda	r8,	r10	;

00009a3e <.LVL7>:
    9a3e:	40 18 5c 42 	movx.b	&0x00156,r12	;
    9a42:	56 01 
    9a44:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    9a46:	ca 4c ff ff 	mov.b	r12,	-1(r10)	; 0xffff

00009a4a <.Loc.63.1>:
}
    9a4a:	06 16       	popm.a	#1,	r6	;20-bit words
    9a4c:	08 16       	popm.a	#1,	r8	;20-bit words
    9a4e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9a50:	10 01       	reta			;

00009a52 <.L5>:
      CRCDI_L = message[i];
    9a52:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    9a56:	50 01 

00009a58 <.LVL9>:
    9a58:	ae 00 01 00 	adda	#1,	r14	;

00009a5c <.LVL10>:
    9a5c:	80 00 22 9a 	mova	#39458,	r0	;0x09a22

00009a60 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    9a60:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009a62 <.LCFI3>:
    9a62:	08 14       	pushm.a	#1,	r8	;20-bit words

00009a64 <.LCFI4>:
    9a64:	06 14       	pushm.a	#1,	r6	;20-bit words

00009a66 <.LCFI5>:
    9a66:	ca 0c       	mova	r12,	r10	;
    9a68:	c8 0d       	mova	r13,	r8	;

00009a6a <.Loc.72.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9a6a:	40 18 c2 93 	cmpx.b	#0,	&0xfac86;r3 As==00
    9a6e:	86 ac 
    9a70:	04 24       	jz	$+10     	;abs 0x9a7a

00009a72 <.Loc.72.1>:
    9a72:	8c 01 24 06 	mova	#67108,	r12	;0x10624

00009a76 <.LVL12>:
    9a76:	b0 13 58 46 	calla	#18008		;0x04658

00009a7a <.L7>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9a7a:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    9a7e:	54 01 

00009a80 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9a80:	ce 0a       	mova	r10,	r14	;
    9a82:	cc 08       	mova	r8,	r12	;
    9a84:	ac 0f fe ff 	adda	#1048574,r12	;0xffffe

00009a88 <.L8>:
    9a88:	00 18 46 4e 	movx.a	r14,	r6	;
    9a8c:	00 18 46 8a 	subx.a	r10,	r6	;

00009a90 <.LVL16>:
    9a90:	d6 0c       	cmpa	r12,	r6	;
    9a92:	14 28       	jnc	$+42     	;abs 0x9abc

00009a94 <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    9a94:	ec 0a       	adda	r10,	r12	;
    9a96:	6d 4c       	mov.b	@r12,	r13	;
    9a98:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9a9c:	ea 08       	adda	r8,	r10	;

00009a9e <.LVL17>:
    9a9e:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    9aa2:	0d da       	bis	r10,	r13	;
    9aa4:	40 18 1e 42 	movx.w	&0x00156,r14	;
    9aa8:	56 01 
    9aaa:	3e e3       	inv	r14		;
    9aac:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9aae:	0d 9e       	cmp	r14,	r13	;
    9ab0:	01 24       	jz	$+4      	;abs 0x9ab4
    9ab2:	4c 43       	clr.b	r12		;

00009ab4 <.L10>:
}
    9ab4:	06 16       	popm.a	#1,	r6	;20-bit words
    9ab6:	08 16       	popm.a	#1,	r8	;20-bit words
    9ab8:	0a 16       	popm.a	#1,	r10	;20-bit words
    9aba:	10 01       	reta			;

00009abc <.L9>:
      CRCDI_L = message[i];
    9abc:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    9ac0:	50 01 

00009ac2 <.LVL19>:
    9ac2:	ae 00 01 00 	adda	#1,	r14	;

00009ac6 <.LVL20>:
    9ac6:	80 00 88 9a 	mova	#39560,	r0	;0x09a88

00009aca <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9aca:	40 18 c2 93 	cmpx.b	#0,	&0xfac86;r3 As==00
    9ace:	86 ac 
    9ad0:	04 24       	jz	$+10     	;abs 0x9ada

00009ad2 <.Loc.103.1>:
    9ad2:	8c 01 1b 06 	mova	#67099,	r12	;0x1061b
    9ad6:	b0 13 58 46 	calla	#18008		;0x04658

00009ada <.L12>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9ada:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    9ade:	54 01 

00009ae0 <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    9ae0:	40 18 d2 43 	movx.b	#1,	&0xfac86;r3 As==01
    9ae4:	86 ac 

00009ae6 <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    9ae6:	8c 00 50 01 	mova	#336,	r12	;0x00150
    9aea:	10 01       	reta			;

00009aec <crcStop>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    9aec:	40 18 d2 93 	cmpx.b	#1,	&0xfac86;r3 As==01
    9af0:	86 ac 
    9af2:	04 24       	jz	$+10     	;abs 0x9afc

00009af4 <.Loc.119.1>:
    9af4:	8c 01 13 06 	mova	#67091,	r12	;0x10613
    9af8:	b0 13 58 46 	calla	#18008		;0x04658

00009afc <.L14>:
  /* Change state */
  crc_state = CRC_STOPPED;
    9afc:	40 18 c2 43 	movx.b	#0,	&0xfac86;r3 As==00
    9b00:	86 ac 

00009b02 <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    9b02:	40 18 1c 42 	movx.w	&0x00156,r12	;
    9b06:	56 01 
    9b08:	3c e3       	inv	r12		;
    9b0a:	10 01       	reta			;

00009b0c <fram_mpool_alloc>:
static const uint8_t slave_id = 0x50;
static const uint8_t device_select = 0x00;

static PERSIST uint8_t fram_storage[FRAM_REQ_STORAGE];

void * fram_mpool_alloc(size_t size, unsigned align) {
    9b0c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009b0e <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > FRAM_REQ_STORAGE) {
    9b0e:	2e 00 4a a7 	mova	&42826,	r14	;0x0a74a
    9b12:	ca 0e       	mova	r14,	r10	;
    9b14:	ea 0c       	adda	r12,	r10	;
    9b16:	7c 40 48 00 	mov.b	#72,	r12	;#0x0048

00009b1a <.LVL1>:
    9b1a:	dc 0a       	cmpa	r10,	r12	;
    9b1c:	07 28       	jnc	$+16     	;abs 0x9b2c

00009b1e <.Loc.18.1>:
    return NULL;
  }

  void * result = fram_storage + curr_index;
    9b1e:	cc 0e       	mova	r14,	r12	;
    9b20:	ac 00 4e a7 	adda	#42830,	r12	;0x0a74e

00009b24 <.LVL2>:
  
  curr_index += size;
    9b24:	60 0a 4a a7 	mova	r10,	&42826	; 0x0a74a

00009b28 <.L1>:
  return result;
}
    9b28:	0a 16       	popm.a	#1,	r10	;20-bit words
    9b2a:	10 01       	reta			;

00009b2c <.L3>:
    return NULL;
    9b2c:	4c 43       	clr.b	r12		;
    9b2e:	80 00 28 9b 	mova	#39720,	r0	;0x09b28

00009b32 <addr_cb>:
    /* Process next request */
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
  }
}

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    9b32:	2a 14       	pushm.a	#3,	r10	;20-bit words

00009b34 <.LCFI1>:
    9b34:	06 14       	pushm.a	#1,	r6	;20-bit words

00009b36 <.LCFI2>:
    9b36:	b1 00 08 00 	suba	#8,	r1	;

00009b3a <.LCFI3>:
    9b3a:	c8 0c       	mova	r12,	r8	;

00009b3c <.Loc.64.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    9b3c:	2c 00 88 ac 	mova	&44168,	r12	;0x0ac88

00009b40 <.LVL5>:
  
  chSysLockFromISR();
  /* TODO put in an assert in here for the Rev A crossing bank boundaries */
  if (req->read) {
    9b40:	5e 4c 04 00 	mov.b	4(r12),	r14	;

00009b44 <.LVL6>:
    9b44:	4d 4e       	mov.b	r14,	r13	;

00009b46 <.LVL7>:
    9b46:	5d f3       	and.b	#1,	r13	;r3 As==01
    9b48:	36 0c 08 00 	mova	8(r12),	r6	;
    9b4c:	5a 4c 06 00 	mov.b	6(r12),	r10	;
    9b50:	59 4c 10 00 	mov.b	16(r12),r9	;0x00010

00009b54 <.Loc.71.1>:
    if (req->special) {
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    9b54:	1c 4c 04 00 	mov	4(r12),	r12	;

00009b58 <.LVL8>:
  if (req->read) {
    9b58:	40 18 2e b3 	bitx.w	#2,	r14	;r3 As==10
    9b5c:	37 24       	jz	$+112    	;abs 0x9bcc

00009b5e <.Loc.69.1>:
    if (req->special) {
    9b5e:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    9b60:	1c 24       	jz	$+58     	;abs 0x9b9a

00009b62 <.Loc.71.1>:
          req->size, req->buffer, end_cb);
    9b62:	b0 13 64 a3 	calla	#41828		;0x0a364

00009b66 <.LVL9>:
    9b66:	0d 4a       	mov	r10,	r13	;
    9b68:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    9b6c:	0d dc       	bis	r12,	r13	;
    9b6e:	81 4d 04 00 	mov	r13,	4(r1)	;
    9b72:	5a 07       	rrum	#2,	r10	;
    9b74:	5a f3       	and.b	#1,	r10	;r3 As==01
    9b76:	81 4a 06 00 	mov	r10,	6(r1)	;

00009b7a <.Loc.70.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    9b7a:	00 18 f1 40 	movx.a	#40068,	0(r1)	;0x09c84
    9b7e:	84 9c 00 00 
    9b82:	cf 06       	mova	r6,	r15	;
    9b84:	3e 01 04 00 	mova	4(r1),	r14	;
    9b88:	4d 49       	mov.b	r9,	r13	;
    9b8a:	cc 08       	mova	r8,	r12	;
    9b8c:	b0 13 2c 5c 	calla	#23596		;0x05c2c

00009b90 <.L4>:
          req->buffer, end_cb);
    }
  }
  current_callback = req->callback;
  chSysUnlockFromISR();
}
    9b90:	a1 00 08 00 	adda	#8,	r1	;
    9b94:	06 16       	popm.a	#1,	r6	;20-bit words
    9b96:	28 16       	popm.a	#3,	r10	;20-bit words
    9b98:	10 01       	reta			;

00009b9a <.L6>:
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    9b9a:	b0 13 64 a3 	calla	#41828		;0x0a364

00009b9e <.LVL12>:
    9b9e:	0d 4a       	mov	r10,	r13	;
    9ba0:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    9ba4:	0d dc       	bis	r12,	r13	;
    9ba6:	81 4d 04 00 	mov	r13,	4(r1)	;
    9baa:	5a 07       	rrum	#2,	r10	;
    9bac:	5a f3       	and.b	#1,	r10	;r3 As==01
    9bae:	81 4a 06 00 	mov	r10,	6(r1)	;
    9bb2:	00 18 f1 40 	movx.a	#40068,	0(r1)	;0x09c84
    9bb6:	84 9c 00 00 
    9bba:	cf 06       	mova	r6,	r15	;
    9bbc:	3e 01 04 00 	mova	4(r1),	r14	;
    9bc0:	4d 49       	mov.b	r9,	r13	;
    9bc2:	cc 08       	mova	r8,	r12	;
    9bc4:	b0 13 12 5d 	calla	#23826		;0x05d12

00009bc8 <.LVL13>:
    9bc8:	80 00 90 9b 	mova	#39824,	r0	;0x09b90

00009bcc <.L5>:
    if (req->special) {
    9bcc:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    9bce:	19 24       	jz	$+52     	;abs 0x9c02

00009bd0 <.Loc.84.1>:
          req->size, req->buffer, end_cb);
    9bd0:	b0 13 64 a3 	calla	#41828		;0x0a364

00009bd4 <.LVL15>:
    9bd4:	0d 4a       	mov	r10,	r13	;
    9bd6:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    9bda:	0d dc       	bis	r12,	r13	;
    9bdc:	81 4d 04 00 	mov	r13,	4(r1)	;
    9be0:	5a 07       	rrum	#2,	r10	;
    9be2:	5a f3       	and.b	#1,	r10	;r3 As==01
    9be4:	81 4a 06 00 	mov	r10,	6(r1)	;

00009be8 <.Loc.83.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    9be8:	00 18 f1 40 	movx.a	#40068,	0(r1)	;0x09c84
    9bec:	84 9c 00 00 
    9bf0:	cf 06       	mova	r6,	r15	;
    9bf2:	3e 01 04 00 	mova	4(r1),	r14	;
    9bf6:	4d 49       	mov.b	r9,	r13	;
    9bf8:	cc 08       	mova	r8,	r12	;
    9bfa:	b0 13 be 5e 	calla	#24254		;0x05ebe

00009bfe <.LVL16>:
    9bfe:	80 00 90 9b 	mova	#39824,	r0	;0x09b90

00009c02 <.L8>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    9c02:	b0 13 64 a3 	calla	#41828		;0x0a364

00009c06 <.LVL18>:
    9c06:	0d 4a       	mov	r10,	r13	;
    9c08:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    9c0c:	0d dc       	bis	r12,	r13	;
    9c0e:	81 4d 04 00 	mov	r13,	4(r1)	;
    9c12:	5a 07       	rrum	#2,	r10	;
    9c14:	5a f3       	and.b	#1,	r10	;r3 As==01
    9c16:	81 4a 06 00 	mov	r10,	6(r1)	;
    9c1a:	00 18 f1 40 	movx.a	#40068,	0(r1)	;0x09c84
    9c1e:	84 9c 00 00 
    9c22:	cf 06       	mova	r6,	r15	;
    9c24:	3e 01 04 00 	mova	4(r1),	r14	;
    9c28:	4d 49       	mov.b	r9,	r13	;
    9c2a:	cc 08       	mova	r8,	r12	;
    9c2c:	b0 13 64 5f 	calla	#24420		;0x05f64

00009c30 <.LVL19>:
}
    9c30:	80 00 90 9b 	mova	#39824,	r0	;0x09b90

00009c34 <fram_handle_request>:

/* called from i-class */
void fram_handle_request(fram_req_t * req) {
    9c34:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009c36 <.LCFI4>:
    9c36:	b1 00 04 00 	suba	#4,	r1	;

00009c3a <.LCFI5>:
    9c3a:	ca 0c       	mova	r12,	r10	;

00009c3c <.Loc.97.1>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
    9c3c:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009c3e <.LVL21>:
    9c3e:	1c 9a 02 00 	cmp	2(r10),	r12	;
    9c42:	04 2c       	jc	$+10     	;abs 0x9c4c

00009c44 <.Loc.97.1>:
    9c44:	8c 01 7b 06 	mova	#67195,	r12	;0x1067b
    9c48:	b0 13 58 46 	calla	#18008		;0x04658

00009c4c <.L10>:
  
  active_req = req;
    9c4c:	60 0a 88 ac 	mova	r10,	&44168	; 0x0ac88

00009c50 <.Loc.102.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    9c50:	2c 4a       	mov	@r10,	r12	;
    9c52:	1d 4a 02 00 	mov	2(r10),	r13	;
    9c56:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9c5a:	b0 13 de a3 	calla	#41950		;0x0a3de

00009c5e <.Loc.101.1>:
  req->device_id = (slave_id | device_select | 
    9c5e:	4d 4c       	mov.b	r12,	r13	;
    9c60:	7d d0 50 00 	bis.b	#80,	r13	;#0x0050
    9c64:	ca 4d 10 00 	mov.b	r13,	16(r10)	; 0x0010

00009c68 <.Loc.105.1>:
  
  /* Issue a write to set the address */
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    9c68:	00 18 f1 40 	movx.a	#39730,	0(r1)	;0x09b32
    9c6c:	32 9b 00 00 
    9c70:	cf 0a       	mova	r10,	r15	;
    9c72:	6e 43       	mov.b	#2,	r14	;r3 As==10
    9c74:	8c 01 ca 08 	mova	#67786,	r12	;0x108ca
    9c78:	b0 13 fa 5d 	calla	#24058		;0x05dfa

00009c7c <.LVL24>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
}
    9c7c:	a1 00 04 00 	adda	#4,	r1	;
    9c80:	0a 16       	popm.a	#1,	r10	;20-bit words
    9c82:	10 01       	reta			;

00009c84 <end_cb>:
void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    9c84:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009c86 <.LCFI6>:
    9c86:	b1 00 04 00 	suba	#4,	r1	;

00009c8a <.LCFI7>:
    9c8a:	ca 0d       	mova	r13,	r10	;

00009c8c <.Loc.43.1>:
  i2cMSP430XEndTransferI(i2cp);
    9c8c:	b0 13 0c 60 	calla	#24588		;0x0600c

00009c90 <.LVL26>:
  fram_read_idx++;
    9c90:	40 18 d2 53 	incx.b	&0xa738		;
    9c94:	38 a7 

00009c96 <.Loc.47.1>:
  chPoolFreeI(&fram_mpool, active_req);
    9c96:	2d 00 88 ac 	mova	&44168,	r13	;0x0ac88
    9c9a:	8c 00 2c a7 	mova	#42796,	r12	;0x0a72c
    9c9e:	b0 13 d8 4c 	calla	#19672		;0x04cd8

00009ca2 <.LVL27>:
  chSemSignalI(&fram_pool_sem);
    9ca2:	8c 00 2a a7 	mova	#42794,	r12	;0x0a72a
    9ca6:	b0 13 00 49 	calla	#18688		;0x04900

00009caa <.LVL28>:
  if (active_req->callback) {
    9caa:	2c 00 88 ac 	mova	&44168,	r12	;0x0ac88
    9cae:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    9cb2:	9e 00 00 00 	cmpa	#0,	r14	;
    9cb6:	02 24       	jz	$+6      	;abs 0x9cbc

00009cb8 <.Loc.52.1>:
    active_req->callback(buffer);
    9cb8:	cc 0a       	mova	r10,	r12	;
    9cba:	4e 13       	calla	r14		;

00009cbc <.L14>:
  if (!QUEUE_EMPTY()) {
    9cbc:	40 18 5c 42 	movx.b	&0x0a738,r12	;
    9cc0:	38 a7 
    9cc2:	40 18 c2 9c 	cmpx.b	r12,	&0xfa739;
    9cc6:	39 a7 
    9cc8:	13 24       	jz	$+40     	;abs 0x9cf0

00009cca <.Loc.57.1>:
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
    9cca:	7c f0 03 00 	and.b	#3,	r12	;
    9cce:	0d 43       	clr	r13		;
    9cd0:	0e 4c       	mov	r12,	r14	;
    9cd2:	0f 4d       	mov	r13,	r15	;
    9cd4:	0e 5e       	rla	r14		;
    9cd6:	0f 6f       	rlc	r15		;
    9cd8:	0e 5e       	rla	r14		;
    9cda:	0f 6f       	rlc	r15		;
    9cdc:	81 4e 00 00 	mov	r14,	0(r1)	;
    9ce0:	81 4f 02 00 	mov	r15,	2(r1)	;
    9ce4:	0d 01       	mova	@r1,	r13	;
    9ce6:	00 18 5c 4d 	movx.a	42810(r13),r12	;0x0a73a
    9cea:	3a a7 
    9cec:	b0 13 34 9c 	calla	#39988		;0x09c34

00009cf0 <.L13>:
}
    9cf0:	a1 00 04 00 	adda	#4,	r1	;
    9cf4:	0a 16       	popm.a	#1,	r10	;20-bit words
    9cf6:	10 01       	reta			;

00009cf8 <elyFramPostRequestI>:

void elyFramPostRequestI(fram_req_t * req) {
    9cf8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009cfa <.LCFI8>:
    9cfa:	b1 00 04 00 	suba	#4,	r1	;

00009cfe <.LCFI9>:
    9cfe:	ca 0c       	mova	r12,	r10	;

00009d00 <.Loc.114.1>:
  chDbgCheckClassI();
  
  /* We should never hit this if we've managed to get a request in the first place */
  chDbgAssert(!QUEUE_FULL(), "internal buffer overflows should be impossible");
    9d00:	40 18 5c 42 	movx.b	&0x0a739,r12	;
    9d04:	39 a7 

00009d06 <.LVL32>:
    9d06:	40 18 5d 42 	movx.b	&0x0a738,r13	;
    9d0a:	38 a7 
    9d0c:	0c 8d       	sub	r13,	r12	;
    9d0e:	2c 92       	cmp	#4,	r12	;r2 As==10
    9d10:	04 20       	jnz	$+10     	;abs 0x9d1a

00009d12 <.Loc.114.1>:
    9d12:	8c 01 67 06 	mova	#67175,	r12	;0x10667
    9d16:	b0 13 58 46 	calla	#18008		;0x04658

00009d1a <.L20>:
  
  fram_mbox_buffer[QUEUE_MASK(fram_write_idx++)] = req;
    9d1a:	40 18 5c 42 	movx.b	&0x0a739,r12	;
    9d1e:	39 a7 
    9d20:	4e 4c       	mov.b	r12,	r14	;
    9d22:	5e 53       	inc.b	r14		;
    9d24:	40 18 c2 4e 	movx.b	r14,	&0xfa739;
    9d28:	39 a7 
    9d2a:	7c f0 03 00 	and.b	#3,	r12	;
    9d2e:	0d 43       	clr	r13		;
    9d30:	0e 4c       	mov	r12,	r14	;
    9d32:	0f 4d       	mov	r13,	r15	;
    9d34:	0e 5e       	rla	r14		;
    9d36:	0f 6f       	rlc	r15		;
    9d38:	0e 5e       	rla	r14		;
    9d3a:	0f 6f       	rlc	r15		;
    9d3c:	81 4e 00 00 	mov	r14,	0(r1)	;
    9d40:	81 4f 02 00 	mov	r15,	2(r1)	;
    9d44:	0c 01       	mova	@r1,	r12	;
    9d46:	00 18 cc 4a 	movx.a	r10,	-22726(r12); 0xfa73a
    9d4a:	3a a7 

00009d4c <.Loc.117.1>:
}
    9d4c:	a1 00 04 00 	adda	#4,	r1	;
    9d50:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d52:	10 01       	reta			;

00009d54 <elyFramPostRequestS>:

void elyFramPostRequestS(fram_req_t * req) {
    9d54:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009d56 <.LCFI10>:
    9d56:	ca 0c       	mova	r12,	r10	;
    9d58:	8e 00 f8 9c 	mova	#40184,	r14	;0x09cf8

00009d5c <.Loc.122.1>:
  chDbgCheckClassS();
  
  if (QUEUE_EMPTY()) {
    9d5c:	40 18 d2 92 	cmpx.b	&0x0a738,&0xfa739;
    9d60:	38 a7 39 a7 
    9d64:	06 20       	jnz	$+14     	;abs 0x9d72

00009d66 <.Loc.123.1>:
    elyFramPostRequestI(req);
    9d66:	4e 13       	calla	r14		;

00009d68 <.LVL35>:
    fram_handle_request(req);
    9d68:	cc 0a       	mova	r10,	r12	;
    9d6a:	b0 13 34 9c 	calla	#39988		;0x09c34

00009d6e <.L21>:
  }
  else {
    elyFramPostRequestI(req);
  }
}
    9d6e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d70:	10 01       	reta			;

00009d72 <.L22>:
    elyFramPostRequestI(req);
    9d72:	4e 13       	calla	r14		;

00009d74 <.LVL37>:
}
    9d74:	80 00 6e 9d 	mova	#40302,	r0	;0x09d6e

00009d78 <elyFramGetRequestTimeoutS>:
  (*reqp)->special = 0;
  
  return MSG_OK;
}

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    9d78:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009d7a <.LCFI12>:
    9d7a:	08 14       	pushm.a	#1,	r8	;20-bit words

00009d7c <.LCFI13>:
    9d7c:	c8 0c       	mova	r12,	r8	;

00009d7e <.Loc.152.1>:
  chDbgCheckClassS();
  
  msg_t r = chSemWaitTimeoutS(&fram_pool_sem, timeout);
    9d7e:	8c 00 2a a7 	mova	#42794,	r12	;0x0a72a

00009d82 <.LVL46>:
    9d82:	b0 13 ae 48 	calla	#18606		;0x048ae

00009d86 <.LVL47>:
    9d86:	ca 0c       	mova	r12,	r10	;

00009d88 <.Loc.153.1>:
  if (MSG_OK != r) {
    9d88:	9c 00 00 00 	cmpa	#0,	r12	;
    9d8c:	10 20       	jnz	$+34     	;abs 0x9dae

00009d8e <.Loc.157.1>:
    return r;
  }
  
  (*reqp) = (fram_req_t *)(chPoolAllocI(&fram_mpool));
    9d8e:	8c 00 2c a7 	mova	#42796,	r12	;0x0a72c
    9d92:	b0 13 8a 4c 	calla	#19594		;0x04c8a

00009d96 <.LVL49>:
    9d96:	78 0c 00 00 	mova	r12,	0(r8)	;

00009d9a <.Loc.158.1>:
  chDbgAssert( (*reqp) != NULL, "internal pool overflow should be impossible");
    9d9a:	9c 00 00 00 	cmpa	#0,	r12	;
    9d9e:	04 20       	jnz	$+10     	;abs 0x9da8

00009da0 <.Loc.158.1>:
    9da0:	8c 01 3a 06 	mova	#67130,	r12	;0x1063a
    9da4:	b0 13 58 46 	calla	#18008		;0x04658

00009da8 <.L30>:
  (*reqp)->special = 0;
    9da8:	0c 08       	mova	@r8,	r12	;
    9daa:	dc c3 04 00 	bic.b	#1,	4(r12)	;r3 As==01

00009dae <.L28>:
  return r;
}
    9dae:	cc 0a       	mova	r10,	r12	;
    9db0:	08 16       	popm.a	#1,	r8	;20-bit words
    9db2:	0a 16       	popm.a	#1,	r10	;20-bit words
    9db4:	10 01       	reta			;

00009db6 <elyFramInit>:

  
void elyFramInit() {
  chDbgAssert((FRAM_QUEUE_LEN & (FRAM_QUEUE_LEN -1)) == 0, 
      "queue length must be power of 2");
  i2cStart(&I2CDB0, &cfg);
    9db6:	8d 01 36 07 	mova	#67382,	r13	;0x10736
    9dba:	8c 01 ca 08 	mova	#67786,	r12	;0x108ca
    9dbe:	b0 13 f4 52 	calla	#21236		;0x052f4

00009dc2 <.LVL51>:
}
    9dc2:	10 01       	reta			;

00009dc4 <nl_allocator>:
uint8_t PERSIST packets_received;
uint16_t PERSIST packets_sent = 1;
uint8_t PERSIST packets_relayed;
static size_t sh_len;

void * nl_allocator(size_t size, unsigned align) {
    9dc4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009dc6 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    9dc6:	2e 00 8c cc 	mova	&52364,	r14	;0x0cc8c
    9dca:	ca 0e       	mova	r14,	r10	;
    9dcc:	ea 0c       	adda	r12,	r10	;
    9dce:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

00009dd2 <.LVL1>:
    9dd2:	dc 0a       	cmpa	r10,	r12	;
    9dd4:	07 28       	jnc	$+16     	;abs 0x9de4

00009dd6 <.Loc.26.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    9dd6:	cc 0e       	mova	r14,	r12	;
    9dd8:	ac 00 8c ac 	adda	#44172,	r12	;0x0ac8c

00009ddc <.LVL2>:
  
  curr_index += size;
    9ddc:	60 0a 8c cc 	mova	r10,	&52364	; 0x0cc8c

00009de0 <.L1>:
  return result;
}
    9de0:	0a 16       	popm.a	#1,	r10	;20-bit words
    9de2:	10 01       	reta			;

00009de4 <.L3>:
    return NULL;
    9de4:	4c 43       	clr.b	r12		;
    9de6:	80 00 e0 9d 	mova	#40416,	r0	;0x09de0

00009dea <clamp>:

static memory_pool_t main_mpool;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    9dea:	1a 14       	pushm.a	#2,	r10	;20-bit words

00009dec <.LCFI1>:
    9dec:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9df0:	49 4d       	mov.b	r13,	r9	;
    9df2:	4a 4e       	mov.b	r14,	r10	;

00009df4 <.Loc.35.1>:
  if (value < min) {
    9df4:	4c 99       	cmp.b	r9,	r12	;
    9df6:	07 2c       	jc	$+16     	;abs 0x9e06

00009df8 <.LVL5>:
    value = min;
    elyErrorSignal(ErrRegClip);
    9df8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9dfc:	b0 13 ca 94 	calla	#38090		;0x094ca

00009e00 <.LVL6>:
    9e00:	0c 49       	mov	r9,	r12	;

00009e02 <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    9e02:	19 16       	popm.a	#2,	r10	;20-bit words
    9e04:	10 01       	reta			;

00009e06 <.L5>:
  else if (value > max) {
    9e06:	4a 9c       	cmp.b	r12,	r10	;
    9e08:	fc 2f       	jc	$-6      	;abs 0x9e02

00009e0a <.LVL9>:
    elyErrorSignal(ErrRegClip);
    9e0a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9e0e:	b0 13 ca 94 	calla	#38090		;0x094ca

00009e12 <.LVL10>:
    9e12:	0c 4a       	mov	r10,	r12	;
    9e14:	80 00 02 9e 	mova	#40450,	r0	;0x09e02

00009e18 <uart_pass>:
  
  return;
}

static inline msg_t uart_pass(uint8_t * buffer) {
  return elyUARTPost(buffer, TIME_INFINITE);
    9e18:	4d 43       	clr.b	r13		;
    9e1a:	b0 13 42 62 	calla	#25154		;0x06242

00009e1e <.LVL12>:
}
    9e1e:	10 01       	reta			;

00009e20 <fw>:
static inline msg_t uart_pass_i(uint8_t * buffer) {
  return elyUARTPostI(buffer);
}

static inline msg_t fw(uint8_t * buffer) {
  return elyMainMBPost(buffer, TIME_INFINITE);
    9e20:	4d 43       	clr.b	r13		;
    9e22:	b0 13 4c 68 	calla	#26700		;0x0684c

00009e26 <.LVL14>:
}
    9e26:	10 01       	reta			;

00009e28 <rf_pass>:
  return elyRFPost(buffer, TIME_INFINITE);
    9e28:	4d 43       	clr.b	r13		;
    9e2a:	b0 13 14 97 	calla	#38676		;0x09714

00009e2e <.LVL16>:
}
    9e2e:	10 01       	reta			;

00009e30 <elyNLClampReg>:
uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    9e30:	1a 14       	pushm.a	#2,	r10	;20-bit words

00009e32 <.LCFI2>:
    9e32:	49 4c       	mov.b	r12,	r9	;
    9e34:	4a 4d       	mov.b	r13,	r10	;

00009e36 <.Loc.75.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    9e36:	4c 49       	mov.b	r9,	r12	;

00009e38 <.LVL24>:
    9e38:	7c 50 80 ff 	add.b	#-128,	r12	;#0xff80
    9e3c:	7d 40 09 00 	mov.b	#9,	r13	;

00009e40 <.LVL25>:
    9e40:	4d 9c       	cmp.b	r12,	r13	;
    9e42:	04 2c       	jc	$+10     	;abs 0x9e4c

00009e44 <.Loc.75.1>:
    9e44:	8c 01 98 06 	mova	#67224,	r12	;0x10698
    9e48:	b0 13 58 46 	calla	#18008		;0x04658

00009e4c <.L14>:
  switch(addr) {
    9e4c:	79 90 83 ff 	cmp.b	#-125,	r9	;#0xff83
    9e50:	35 24       	jz	$+108    	;abs 0x9ebc
    9e52:	7d 40 83 ff 	mov.b	#-125,	r13	;#0xff83
    9e56:	4d 99       	cmp.b	r9,	r13	;
    9e58:	09 28       	jnc	$+20     	;abs 0x9e6c
    9e5a:	79 90 80 ff 	cmp.b	#-128,	r9	;#0xff80
    9e5e:	20 24       	jz	$+66     	;abs 0x9ea0
    9e60:	79 90 81 ff 	cmp.b	#-127,	r9	;#0xff81
    9e64:	26 24       	jz	$+78     	;abs 0x9eb2

00009e66 <.L15>:
}
    9e66:	4c 4a       	mov.b	r10,	r12	;
    9e68:	19 16       	popm.a	#2,	r10	;20-bit words
    9e6a:	10 01       	reta			;

00009e6c <.L17>:
  switch(addr) {
    9e6c:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    9e70:	29 24       	jz	$+84     	;abs 0x9ec4
    9e72:	79 90 85 ff 	cmp.b	#-123,	r9	;#0xff85
    9e76:	f7 2b       	jnc	$-16     	;abs 0x9e66
    9e78:	79 50 79 00 	add.b	#121,	r9	;#0x0079
    9e7c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e7e:	4c 99       	cmp.b	r9,	r12	;
    9e80:	f2 2b       	jnc	$-26     	;abs 0x9e66

00009e82 <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    9e82:	40 18 3a b0 	bitx.w	#16,	r10	;0x00010
    9e86:	10 00 
    9e88:	21 24       	jz	$+68     	;abs 0x9ecc
    9e8a:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    9e8e:	1e 24       	jz	$+62     	;abs 0x9ecc

00009e90 <.Loc.48.1>:
    elyErrorSignal(ErrRegClip);
    9e90:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9e94:	b0 13 ca 94 	calla	#38090		;0x094ca

00009e98 <.LVL29>:
    return 0x10;
    9e98:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010

00009e9c <.LVL30>:
    9e9c:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009ea0 <.L18>:
      value = clamp(value, 7, 0xFF);
    9ea0:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9ea2:	7d 40 07 00 	mov.b	#7,	r13	;

00009ea6 <.L61>:
      value = clamp(value, 0, 0x10);
    9ea6:	4c 4a       	mov.b	r10,	r12	;
    9ea8:	b0 13 ea 9d 	calla	#40426		;0x09dea

00009eac <.LVL32>:
    9eac:	4a 4c       	mov.b	r12,	r10	;

00009eae <.LVL33>:
      break;
    9eae:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009eb2 <.L19>:
      value = clamp(value, 0, 0x10);
    9eb2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

00009eb6 <.L62>:
    9eb6:	4d 43       	clr.b	r13		;
    9eb8:	80 00 a6 9e 	mova	#40614,	r0	;0x09ea6

00009ebc <.L16>:
      value = clamp(value, 0, 0x07);
    9ebc:	7e 40 07 00 	mov.b	#7,	r14	;
    9ec0:	80 00 b6 9e 	mova	#40630,	r0	;0x09eb6

00009ec4 <.L20>:
      value = clamp(value, 0, 0x3F);
    9ec4:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    9ec8:	80 00 b6 9e 	mova	#40630,	r0	;0x09eb6

00009ecc <.L22>:
  if ((value & 0x08) && value != 0x08) {
    9ecc:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    9ed0:	09 24       	jz	$+20     	;abs 0x9ee4
    9ed2:	3a 92       	cmp	#8,	r10	;r2 As==11
    9ed4:	07 24       	jz	$+16     	;abs 0x9ee4

00009ed6 <.Loc.52.1>:
    elyErrorSignal(ErrRegClip);
    9ed6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9eda:	b0 13 ca 94 	calla	#38090		;0x094ca

00009ede <.LVL36>:
    return 0x08;
    9ede:	7a 42       	mov.b	#8,	r10	;r2 As==11

00009ee0 <.LVL37>:
    9ee0:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009ee4 <.L23>:
  if ((value & 0x04) && value != 0x04) {
    9ee4:	40 18 2a b2 	bitx.w	#4,	r10	;r2 As==10
    9ee8:	09 24       	jz	$+20     	;abs 0x9efc
    9eea:	2a 92       	cmp	#4,	r10	;r2 As==10
    9eec:	07 24       	jz	$+16     	;abs 0x9efc

00009eee <.Loc.56.1>:
    elyErrorSignal(ErrRegClip);
    9eee:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9ef2:	b0 13 ca 94 	calla	#38090		;0x094ca

00009ef6 <.LVL39>:
    return 0x04;
    9ef6:	6a 42       	mov.b	#4,	r10	;r2 As==10

00009ef8 <.LVL40>:
    9ef8:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009efc <.L24>:
  if ((value & 0x02) && value != 0x02) {
    9efc:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    9f00:	09 24       	jz	$+20     	;abs 0x9f14
    9f02:	2a 93       	cmp	#2,	r10	;r3 As==10
    9f04:	07 24       	jz	$+16     	;abs 0x9f14

00009f06 <.Loc.60.1>:
    elyErrorSignal(ErrRegClip);
    9f06:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9f0a:	b0 13 ca 94 	calla	#38090		;0x094ca

00009f0e <.LVL42>:
    return 0x02;
    9f0e:	6a 43       	mov.b	#2,	r10	;r3 As==10

00009f10 <.LVL43>:
    9f10:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009f14 <.L25>:
  if ((value & 0x01) && value != 0x01) {
    9f14:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    9f18:	09 24       	jz	$+20     	;abs 0x9f2c
    9f1a:	1a 93       	cmp	#1,	r10	;r3 As==01
    9f1c:	07 24       	jz	$+16     	;abs 0x9f2c

00009f1e <.Loc.64.1>:
    elyErrorSignal(ErrRegClip);
    9f1e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9f22:	b0 13 ca 94 	calla	#38090		;0x094ca

00009f26 <.LVL45>:
    return 0x01;
    9f26:	5a 43       	mov.b	#1,	r10	;r3 As==01

00009f28 <.LVL46>:
    9f28:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009f2c <.L26>:
  if (value & 0xD0) {
    9f2c:	7a b0 d0 ff 	bit.b	#-48,	r10	;#0xffd0
    9f30:	9a 27       	jz	$-202    	;abs 0x9e66

00009f32 <.Loc.68.1>:
    elyErrorSignal(ErrRegClip);
    9f32:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9f36:	b0 13 ca 94 	calla	#38090		;0x094ca

00009f3a <.LVL48>:
    return 0x00;
    9f3a:	4a 43       	clr.b	r10		;

00009f3c <.LVL49>:
    9f3c:	80 00 66 9e 	mova	#40550,	r0	;0x09e66

00009f40 <elyNLGetBuffer>:
  return chPoolAlloc(&main_mpool);
    9f40:	8c 00 90 cc 	mova	#52368,	r12	;0x0cc90
    9f44:	b0 13 c4 4c 	calla	#19652		;0x04cc4

00009f48 <.LVL57>:
}
    9f48:	10 01       	reta			;

00009f4a <elyNLFreeBuffer>:
  chPoolFree(&main_mpool, buffer);
    9f4a:	cd 0c       	mova	r12,	r13	;
    9f4c:	8c 00 90 cc 	mova	#52368,	r12	;0x0cc90

00009f50 <.LVL59>:
    9f50:	b0 13 04 4d 	calla	#19716		;0x04d04

00009f54 <.LVL60>:
}
    9f54:	10 01       	reta			;

00009f56 <elyNLFreeBufferI>:
  chPoolFreeI(&main_mpool, buffer);
    9f56:	cd 0c       	mova	r12,	r13	;
    9f58:	8c 00 90 cc 	mova	#52368,	r12	;0x0cc90

00009f5c <.LVL63>:
    9f5c:	b0 13 d8 4c 	calla	#19672		;0x04cd8

00009f60 <.LVL64>:
}
    9f60:	10 01       	reta			;

00009f62 <elyNLGetDest>:
  (void)(buffer);
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (dest_addr == ground_apid) {
    9f62:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0

00009f66 <.LVL67>:
    9f66:	5e 4c 83 00 	mov.b	131(r12),r14	;0x00083
    9f6a:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9f6e:	5c 4c 82 00 	mov.b	130(r12),r12	;0x00082
    9f72:	0e dc       	bis	r12,	r14	;
    9f74:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9f76:	0e 9d       	cmp	r13,	r14	;
    9f78:	01 24       	jz	$+4      	;abs 0x9f7c
    9f7a:	4c 43       	clr.b	r12		;

00009f7c <.L73>:
    return ELY_DEST_RF;
  }
  
  return ELY_DEST_UART;
}
    9f7c:	10 01       	reta			;

00009f7e <is_fw_buf>:

bool is_fw_buf(uint8_t * buffer) {
    9f7e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009f80 <.LCFI7>:
   * If (TM AND APID == Elysium) FW Reply
   * If (TC AND APID == Elysium) Coding error
   * Else NL packet */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    9f80:	6d 4c       	mov.b	@r12,	r13	;

00009f82 <.LVL69>:
    9f82:	0e 4d       	mov	r13,	r14	;
    9f84:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9f88:	3e f0 00 07 	and	#1792,	r14	;#0x0700
    9f8c:	5c 4c 01 00 	mov.b	1(r12),	r12	;

00009f90 <.LVL70>:
    9f90:	0c de       	bis	r14,	r12	;

00009f92 <.LVL71>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9f92:	2a 01 b0 05 	mova	&66992,	r10	;0x105b0
    9f96:	5e 4a 51 00 	mov.b	81(r10),r14	;0x00051
    9f9a:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9f9e:	5a 4a 50 00 	mov.b	80(r10),r10	;0x00050
    9fa2:	0e da       	bis	r10,	r14	;

00009fa4 <.Loc.277.1>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (apid == elysium_apid) {
    9fa4:	0c 9e       	cmp	r14,	r12	;
    9fa6:	06 20       	jnz	$+14     	;abs 0x9fb4

00009fa8 <.Loc.278.1>:
    if (!tc) {
    9fa8:	0c 4d       	mov	r13,	r12	;
    9faa:	5c 0f       	rrum	#4,	r12	;
    9fac:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9fae:	5c f3       	and.b	#1,	r12	;r3 As==01

00009fb0 <.L75>:
      /* Fall through to NL to allow loopback */
    }
  }
  
  return false;
}
    9fb0:	0a 16       	popm.a	#1,	r10	;20-bit words
    9fb2:	10 01       	reta			;

00009fb4 <.L76>:
  return false;
    9fb4:	4c 43       	clr.b	r12		;
    9fb6:	80 00 b0 9f 	mova	#40880,	r0	;0x09fb0

00009fba <elyNLFreeBufferChecked>:
  
void elyNLFreeBufferChecked(uint8_t * buffer) {
    9fba:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009fbc <.LCFI8>:
    9fbc:	ca 0c       	mova	r12,	r10	;

00009fbe <.Loc.290.1>:
  if (is_fw_buf(buffer)) {
    9fbe:	b0 13 7e 9f 	calla	#40830		;0x09f7e

00009fc2 <.LVL73>:
    9fc2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9fc4:	05 24       	jz	$+12     	;abs 0x9fd0

00009fc6 <.Loc.291.1>:
      elyFWFreeBuffer(buffer);
    9fc6:	cc 0a       	mova	r10,	r12	;
    9fc8:	b0 13 7a 65 	calla	#25978		;0x0657a

00009fcc <.L77>:
  }
  else {
    elyNLFreeBuffer(buffer);
  }
}
    9fcc:	0a 16       	popm.a	#1,	r10	;20-bit words
    9fce:	10 01       	reta			;

00009fd0 <.L78>:
    elyNLFreeBuffer(buffer);
    9fd0:	cc 0a       	mova	r10,	r12	;
    9fd2:	b0 13 4a 9f 	calla	#40778		;0x09f4a

00009fd6 <.LVL75>:
}
    9fd6:	80 00 cc 9f 	mova	#40908,	r0	;0x09fcc

00009fda <elyNLInit>:
}

void elyNLInit(void) {
  uint8_t options = bank0p[RegNLOptions];
  
  chPoolObjectInit(&main_mpool, elyNLMaxLen, nl_allocator);
    9fda:	8e 00 c4 9d 	mova	#40388,	r14	;0x09dc4
    9fde:	2d 00 9c a7 	mova	&42908,	r13	;0x0a79c
    9fe2:	8c 00 90 cc 	mova	#52368,	r12	;0x0cc90
    9fe6:	b0 13 32 4c 	calla	#19506		;0x04c32

00009fea <.LVL81>:
      /* 4-byte Secondary Header + 6-byte Primary Header */
      sh_len = 4;
    }
  }
  
  sh_len = 0;
    9fea:	00 18 c2 43 	movx.a	#0,	&0xfcc9c;r3 As==00
    9fee:	9c cc 

00009ff0 <.Loc.324.1>:
}
    9ff0:	10 01       	reta			;

00009ff2 <elyNLSetHeader>:

void elyNLSetHeader(uint8_t * buffer, uint16_t length, uint16_t dest_addr) {
    9ff2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009ff4 <.LCFI10>:
  /* dest_addr not used for SPP */
  (void)(dest_addr);
  
  /* Set APID */
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9ff4:	2e 01 b0 05 	mova	&66992,	r14	;0x105b0

00009ff8 <.LVL83>:
    9ff8:	5f 4e 51 00 	mov.b	81(r14),r15	;0x00051
    9ffc:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    a000:	5a 4e 50 00 	mov.b	80(r14),r10	;0x00050
    a004:	0f da       	bis	r10,	r15	;

0000a006 <.LVL84>:
        (bank0p[RegSrcAddrLsb])) );
  buffer[0] = (elysium_apid >> 8);
    a006:	0b 4f       	mov	r15,	r11	;
    a008:	5b 0f       	rrum	#4,	r11	;
    a00a:	5b 0f       	rrum	#4,	r11	;
    a00c:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

0000a010 <.Loc.334.1>:
  buffer[1] = (elysium_apid & 0xFF);
    a010:	cc 4f 01 00 	mov.b	r15,	1(r12)	;

0000a014 <.Loc.336.1>:
  
  length = (length + sh_len - 1);
    a014:	40 18 1f 42 	movx.w	&0x0cc9c,r15	;
    a018:	9c cc 

0000a01a <.LVL85>:
    a01a:	3f 53       	add	#-1,	r15	;r3 As==11
    a01c:	0d 5f       	add	r15,	r13	;

0000a01e <.LVL86>:
  buffer[4] = (length >> 8);
    a01e:	0f 4d       	mov	r13,	r15	;
    a020:	5f 0f       	rrum	#4,	r15	;
    a022:	5f 0f       	rrum	#4,	r15	;
    a024:	cc 4f 04 00 	mov.b	r15,	4(r12)	;

0000a028 <.Loc.338.1>:
  buffer[5] = (length & 0xFF);
    a028:	cc 4d 05 00 	mov.b	r13,	5(r12)	;

0000a02c <.Loc.340.1>:
  
  uint8_t options = bank0p[RegNLOptions];
    a02c:	5d 4e 86 00 	mov.b	134(r14),r13	;0x00086

0000a030 <.LVL87>:
  
  if (options & 0x04) {
    a030:	40 18 2d b2 	bitx.w	#4,	r13	;r2 As==10
    a034:	36 24       	jz	$+110    	;abs 0xa0a2

0000a036 <.LBB21>:
  _disable_interrupts();
    a036:	32 c2       	dint			
    a038:	03 43       	nop			

0000a03a <.Loc.348.2>:
  asm volatile("nop");
    a03a:	03 43       	nop			

0000a03c <.LBE21>:
    chSysLock();
    buffer[2] = bank0p[RegNLPktNameMsb];
    a03c:	dc 4e 85 00 	mov.b	133(r14),2(r12)	;0x00085
    a040:	02 00 

0000a042 <.LVL88>:
    buffer[3] = bank0p[RegNLPktNameLsb];
    a042:	dc 4e 84 00 	mov.b	132(r14),3(r12)	;0x00084
    a046:	03 00 

0000a048 <.LBB23>:
  asm volatile("nop");
    a048:	03 43       	nop			

0000a04a <.Loc.356.2>:
  _enable_interrupts();
    a04a:	03 43       	nop			
    a04c:	32 d2       	eint			
    a04e:	03 43       	nop			

0000a050 <.L86>:
  else {
    buffer[2] = (packets_sent >> 8) | 0xC0;
    buffer[3] = (packets_sent & 0xFF);
  }
  
  packets_sent = (packets_sent + 1) & 0x3FFF;
    a050:	40 18 1f 42 	movx.w	&0x0a798,r15	;
    a054:	98 a7 
    a056:	1f 53       	inc	r15		;
    a058:	3f f0 ff 3f 	and	#16383,	r15	;#0x3fff
    a05c:	40 18 82 4f 	movx.w	r15,	&0xfa798;
    a060:	98 a7 

0000a062 <.Loc.356.1>:
  
  /* insert timestamps here too if required */
  if (options & 0x02) { /* Timestamp */
    a062:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    a066:	1b 24       	jz	$+56     	;abs 0xa09e

0000a068 <.Loc.357.1>:
    buffer[0] |= 0x08; /* Sec Hdr Flag */
    a068:	fc d2 00 00 	bis.b	#8,	0(r12)	;r2 As==11

0000a06c <.Loc.358.1>:
    if (options & 0x01) { /* P-field */
    a06c:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    a070:	26 24       	jz	$+78     	;abs 0xa0be

0000a072 <.Loc.359.1>:
      buffer[6] = SPP_PFIELD;
    a072:	fc 40 2c 00 	mov.b	#44,	6(r12)	;#0x002c
    a076:	06 00 

0000a078 <.LBB25>:
  _disable_interrupts();
    a078:	32 c2       	dint			
    a07a:	03 43       	nop			

0000a07c <.Loc.348.2>:
  asm volatile("nop");
    a07c:	03 43       	nop			

0000a07e <.LBE25>:
      chSysLock();
      buffer[7] = bank0p[RegMissionTimeMsb];
    a07e:	dc 4e 76 00 	mov.b	118(r14),7(r12)	;0x00076
    a082:	07 00 

0000a084 <.Loc.362.1>:
      buffer[8] = bank0p[RegMissionTimeHmb];
    a084:	dc 4e 75 00 	mov.b	117(r14),8(r12)	;0x00075
    a088:	08 00 

0000a08a <.Loc.363.1>:
      buffer[9] = bank0p[RegMissionTimeLmb];
    a08a:	dc 4e 74 00 	mov.b	116(r14),9(r12)	;0x00074
    a08e:	09 00 

0000a090 <.Loc.364.1>:
      buffer[10] = bank0p[RegMissionTimeLsb];
    a090:	dc 4e 73 00 	mov.b	115(r14),10(r12)	;0x00073, 0x000a
    a094:	0a 00 

0000a096 <.L92>:
  asm volatile("nop");
    a096:	03 43       	nop			

0000a098 <.Loc.356.2>:
  _enable_interrupts();
    a098:	03 43       	nop			
    a09a:	32 d2       	eint			
    a09c:	03 43       	nop			

0000a09e <.L84>:
      chSysUnlock();
    }
  }
  
  return;
}
    a09e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a0a0:	10 01       	reta			;

0000a0a2 <.L85>:
    buffer[2] = (packets_sent >> 8) | 0xC0;
    a0a2:	40 18 1f 42 	movx.w	&0x0a798,r15	;
    a0a6:	98 a7 
    a0a8:	0b 4f       	mov	r15,	r11	;
    a0aa:	5b 0f       	rrum	#4,	r11	;
    a0ac:	5b 0f       	rrum	#4,	r11	;
    a0ae:	7b d0 c0 ff 	bis.b	#-64,	r11	;#0xffc0
    a0b2:	cc 4b 02 00 	mov.b	r11,	2(r12)	;

0000a0b6 <.LVL90>:
    buffer[3] = (packets_sent & 0xFF);
    a0b6:	cc 4f 03 00 	mov.b	r15,	3(r12)	;
    a0ba:	80 00 50 a0 	mova	#41040,	r0	;0x0a050

0000a0be <.L88>:
  _disable_interrupts();
    a0be:	32 c2       	dint			
    a0c0:	03 43       	nop			

0000a0c2 <.Loc.348.2>:
  asm volatile("nop");
    a0c2:	03 43       	nop			

0000a0c4 <.LBE29>:
      buffer[6] = bank0p[RegMissionTimeMsb];
    a0c4:	dc 4e 76 00 	mov.b	118(r14),6(r12)	;0x00076
    a0c8:	06 00 

0000a0ca <.Loc.372.1>:
      buffer[7] = bank0p[RegMissionTimeHmb];
    a0ca:	dc 4e 75 00 	mov.b	117(r14),7(r12)	;0x00075
    a0ce:	07 00 

0000a0d0 <.Loc.373.1>:
      buffer[8] = bank0p[RegMissionTimeLmb];
    a0d0:	dc 4e 74 00 	mov.b	116(r14),8(r12)	;0x00074
    a0d4:	08 00 

0000a0d6 <.Loc.374.1>:
      buffer[9] = bank0p[RegMissionTimeLsb];
    a0d6:	dc 4e 73 00 	mov.b	115(r14),9(r12)	;0x00073
    a0da:	09 00 
    a0dc:	80 00 96 a0 	mova	#41110,	r0	;0x0a096

0000a0e0 <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    a0e0:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a0e4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a0e8:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000a0ec <.LVL92>:
    a0ec:	0c dd       	bis	r13,	r12	;
    a0ee:	3c 50 07 00 	add	#7,	r12	;
    a0f2:	4c 0e       	rlam.a	#4,	r12	;
    a0f4:	4c 0d       	rram.a	#4,	r12	;

0000a0f6 <.Loc.384.1>:
}
    a0f6:	10 01       	reta			;

0000a0f8 <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    a0f8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a0fa <.LCFI11>:
  if (buffer[0] & 0xE0) {
    a0fa:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    a0fe:	00 00 
    a100:	07 24       	jz	$+16     	;abs 0xa110

0000a102 <.Loc.139.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    a102:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000a106 <.L98>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    a106:	b0 13 ca 94 	calla	#38090		;0x094ca

0000a10a <.LVL95>:
    a10a:	4c 43       	clr.b	r12		;

0000a10c <.L96>:
}
    a10c:	0a 16       	popm.a	#1,	r10	;20-bit words
    a10e:	10 01       	reta			;

0000a110 <.L95>:
  _disable_interrupts();
    a110:	32 c2       	dint			
    a112:	03 43       	nop			

0000a114 <.Loc.348.2>:
  asm volatile("nop");
    a114:	03 43       	nop			

0000a116 <.LBE44>:
  if ( elyNLGetLength(buffer) > 
    a116:	b0 13 e0 a0 	calla	#41184		;0x0a0e0

0000a11a <.LVL97>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    a11a:	2a 01 b0 05 	mova	&66992,	r10	;0x105b0
    a11e:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    a122:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a126:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    a12a:	0e da       	bis	r10,	r14	;
    a12c:	40 18 0e 4e 	movx.w	r14,	r14	;

0000a130 <.Loc.145.1>:
  if ( elyNLGetLength(buffer) > 
    a130:	de 0c       	cmpa	r12,	r14	;
    a132:	08 2c       	jc	$+18     	;abs 0xa144

0000a134 <.LBB41>:
  asm volatile("nop");
    a134:	03 43       	nop			

0000a136 <.Loc.356.2>:
  _enable_interrupts();
    a136:	03 43       	nop			
    a138:	32 d2       	eint			
    a13a:	03 43       	nop			

0000a13c <.LBE41>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    a13c:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    a140:	80 00 06 a1 	mova	#41222,	r0	;0x0a106

0000a144 <.L97>:
  asm volatile("nop");
    a144:	03 43       	nop			

0000a146 <.Loc.356.2>:
  _enable_interrupts();
    a146:	03 43       	nop			
    a148:	32 d2       	eint			
    a14a:	03 43       	nop			

0000a14c <.LBE47>:
  return true;
    a14c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a14e:	80 00 0c a1 	mova	#41228,	r0	;0x0a10c

0000a152 <nl_route>:
    msg_t (*loop_func)(uint8_t *)) {
    a152:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a154 <.LCFI12>:
    a154:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a156 <.LCFI13>:
    a156:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a158 <.LCFI14>:
    a158:	04 14       	pushm.a	#1,	r4	;20-bit words

0000a15a <.LCFI15>:
    a15a:	ca 0c       	mova	r12,	r10	;
    a15c:	c4 0d       	mova	r13,	r4	;
    a15e:	c6 0e       	mova	r14,	r6	;
    a160:	c8 0f       	mova	r15,	r8	;

0000a162 <.Loc.166.1>:
  if (!elyNLValidate(buffer)) {
    a162:	b0 13 f8 a0 	calla	#41208		;0x0a0f8

0000a166 <.LVL101>:
    a166:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a168:	08 20       	jnz	$+18     	;abs 0xa17a

0000a16a <.L108>:
        elyNLFreeBuffer(buffer);
    a16a:	cc 0a       	mova	r10,	r12	;
    a16c:	b0 13 4a 9f 	calla	#40778		;0x09f4a

0000a170 <.L99>:
}
    a170:	04 16       	popm.a	#1,	r4	;20-bit words
    a172:	06 16       	popm.a	#1,	r6	;20-bit words
    a174:	08 16       	popm.a	#1,	r8	;20-bit words
    a176:	0a 16       	popm.a	#1,	r10	;20-bit words
    a178:	10 01       	reta			;

0000a17a <.L100>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    a17a:	6e 4a       	mov.b	@r10,	r14	;

0000a17c <.LVL103>:
    a17c:	0d 4e       	mov	r14,	r13	;
    a17e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a182:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    a186:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    a18a:	0d dc       	bis	r12,	r13	;

0000a18c <.Loc.173.1>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    a18c:	2c 01 b0 05 	mova	&66992,	r12	;0x105b0
    a190:	5f 4c 51 00 	mov.b	81(r12),r15	;0x00051
    a194:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    a198:	5c 4c 50 00 	mov.b	80(r12),r12	;0x00050
    a19c:	0f dc       	bis	r12,	r15	;

0000a19e <.Loc.177.1>:
  if (apid == elysium_apid) {
    a19e:	0d 9f       	cmp	r15,	r13	;
    a1a0:	17 20       	jnz	$+48     	;abs 0xa1d0

0000a1a2 <.Loc.178.1>:
    if (tc) {
    a1a2:	40 18 3e b0 	bitx.w	#16,	r14	;0x00010
    a1a6:	10 00 
    a1a8:	0b 24       	jz	$+24     	;abs 0xa1c0

0000a1aa <.Loc.179.1>:
      if (MSG_OK != fw_func(buffer)) {
    a1aa:	cc 0a       	mova	r10,	r12	;
    a1ac:	46 13       	calla	r6		;

0000a1ae <.L106>:
    a1ae:	9c 00 00 00 	cmpa	#0,	r12	;
    a1b2:	de 27       	jz	$-66     	;abs 0xa170

0000a1b4 <.Loc.181.1>:
        chDbgAssert(false, "internal buffer overflows should be impossible");
    a1b4:	8c 01 8f 06 	mova	#67215,	r12	;0x1068f
    a1b8:	b0 13 58 46 	calla	#18008		;0x04658

0000a1bc <.LVL105>:
    a1bc:	80 00 6a a1 	mova	#41322,	r0	;0x0a16a

0000a1c0 <.L103>:
      buffer[0] |= 0x10; /* set apid to free properly */
    a1c0:	7e d0 10 00 	bis.b	#16,	r14	;#0x0010

0000a1c4 <.LVL107>:
    a1c4:	ca 4e 00 00 	mov.b	r14,	0(r10)	;

0000a1c8 <.LVL108>:
      if (MSG_OK != loop_func(buffer)) {
    a1c8:	cc 0a       	mova	r10,	r12	;
    a1ca:	48 13       	calla	r8		;

0000a1cc <.LVL109>:
    a1cc:	80 00 ae a1 	mova	#41390,	r0	;0x0a1ae

0000a1d0 <.L102>:
  if (MSG_OK != pass_func(buffer)) {
    a1d0:	cc 0a       	mova	r10,	r12	;
    a1d2:	44 13       	calla	r4		;

0000a1d4 <.LVL111>:
    a1d4:	80 00 ae a1 	mova	#41390,	r0	;0x0a1ae

0000a1d8 <elyNLRouteUART>:
  nl_route(buffer, rf_pass, fw, uart_pass);
    a1d8:	8f 00 18 9e 	mova	#40472,	r15	;0x09e18
    a1dc:	8e 00 20 9e 	mova	#40480,	r14	;0x09e20
    a1e0:	8d 00 28 9e 	mova	#40488,	r13	;0x09e28
    a1e4:	b0 13 52 a1 	calla	#41298		;0x0a152

0000a1e8 <.LVL113>:
}
    a1e8:	10 01       	reta			;

0000a1ea <elyNLToFW>:
size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - sh_len + 1;
}

uint8_t * elyNLToFW(uint8_t * buffer) {
  return buffer + sh_len + 6;
    a1ea:	2e 00 9c cc 	mova	&52380,	r14	;0x0cc9c
    a1ee:	ae 00 06 00 	adda	#6,	r14	;

0000a1f2 <.Loc.392.1>:
}
    a1f2:	ec 0e       	adda	r14,	r12	;

0000a1f4 <.LVL121>:
    a1f4:	10 01       	reta			;

0000a1f6 <elyNLFromFW>:

uint8_t * elyNLFromFW(uint8_t * buffer) {
  return buffer - sh_len - 6;
    a1f6:	8e 0f fa ff 	mova	#-6,	r14	;0xfffffffa
    a1fa:	00 18 5e 82 	subx.a	&0x0cc9c,r14	;
    a1fe:	9c cc 

0000a200 <.Loc.396.1>:
}
    a200:	ec 0e       	adda	r14,	r12	;

0000a202 <.LVL123>:
    a202:	10 01       	reta			;

0000a204 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    a204:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    a208:	80 5a 5c 01 

0000a20c <.Loc.52.1>:

  halInit();
    a20c:	b0 13 96 4d 	calla	#19862		;0x04d96

0000a210 <.LVL0>:
  elyNLInit();
    a210:	b0 13 da 9f 	calla	#40922		;0x09fda

0000a214 <.LVL1>:
  elyFramInit();
    a214:	b0 13 b6 9d 	calla	#40374		;0x09db6

0000a218 <.LVL2>:
  chSysInit();
    a218:	b0 13 2e 45 	calla	#17710		;0x0452e

0000a21c <.L3>:
    a21c:	80 00 1c a2 	mova	#41500,	r0	;0x0a21c

0000a220 <udivmodsi4>:
    a220:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a222 <.LCFI0>:
    a222:	0a 4c       	mov	r12,	r10	;
    a224:	0b 4d       	mov	r13,	r11	;

0000a226 <.LVL1>:
    a226:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000a22a <.Loc.35.1>:
    a22a:	58 43       	mov.b	#1,	r8	;r3 As==01
    a22c:	49 43       	clr.b	r9		;

0000a22e <.Loc.38.1>:
    a22e:	07 4b       	mov	r11,	r7	;

0000a230 <.L2>:
    a230:	0f 9b       	cmp	r11,	r15	;
    a232:	11 28       	jnc	$+36     	;abs 0xa256
    a234:	07 9f       	cmp	r15,	r7	;
    a236:	02 20       	jnz	$+6      	;abs 0xa23c
    a238:	0e 9a       	cmp	r10,	r14	;
    a23a:	0d 28       	jnc	$+28     	;abs 0xa256

0000a23c <.L20>:
    a23c:	4c 43       	clr.b	r12		;

0000a23e <.LVL3>:
    a23e:	0d 4c       	mov	r12,	r13	;

0000a240 <.L5>:
    a240:	07 48       	mov	r8,	r7	;
    a242:	07 d9       	bis	r9,	r7	;
    a244:	07 93       	cmp	#0,	r7	;r3 As==00
    a246:	1a 20       	jnz	$+54     	;abs 0xa27c

0000a248 <.L6>:
    a248:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    a24c:	02 24       	jz	$+6      	;abs 0xa252
    a24e:	0c 4a       	mov	r10,	r12	;
    a250:	0d 4b       	mov	r11,	r13	;

0000a252 <.L1>:
    a252:	55 16       	popm.a	#6,	r10	;20-bit words
    a254:	10 01       	reta			;

0000a256 <.L3>:
    a256:	3d 53       	add	#-1,	r13	;r3 As==11

0000a258 <.Loc.38.1>:
    a258:	0d 93       	cmp	#0,	r13	;r3 As==00
    a25a:	24 24       	jz	$+74     	;abs 0xa2a4

0000a25c <.Loc.38.1>:
    a25c:	0f 93       	cmp	#0,	r15	;r3 As==00
    a25e:	ee 3b       	jl	$-34     	;abs 0xa23c

0000a260 <.Loc.40.1>:
    a260:	05 4e       	mov	r14,	r5	;
    a262:	06 4f       	mov	r15,	r6	;
    a264:	05 5e       	add	r14,	r5	;
    a266:	06 6f       	addc	r15,	r6	;
    a268:	0e 45       	mov	r5,	r14	;

0000a26a <.LVL7>:
    a26a:	0f 46       	mov	r6,	r15	;

0000a26c <.LVL8>:
    a26c:	05 48       	mov	r8,	r5	;
    a26e:	06 49       	mov	r9,	r6	;
    a270:	05 58       	add	r8,	r5	;
    a272:	06 69       	addc	r9,	r6	;
    a274:	08 45       	mov	r5,	r8	;

0000a276 <.LVL9>:
    a276:	09 46       	mov	r6,	r9	;

0000a278 <.LVL10>:
    a278:	80 00 30 a2 	mova	#41520,	r0	;0x0a230

0000a27c <.L12>:
    a27c:	0b 9f       	cmp	r15,	r11	;
    a27e:	0a 28       	jnc	$+22     	;abs 0xa294
    a280:	0f 9b       	cmp	r11,	r15	;
    a282:	02 20       	jnz	$+6      	;abs 0xa288
    a284:	0a 9e       	cmp	r14,	r10	;
    a286:	06 28       	jnc	$+14     	;abs 0xa294

0000a288 <.L16>:
    a288:	40 18 0a 8e 	subx.w	r14,	r10	;
    a28c:	40 18 0b 7f 	subcx.w	r15,	r11	;

0000a290 <.Loc.48.1>:
    a290:	0c d8       	bis	r8,	r12	;

0000a292 <.LVL13>:
    a292:	0d d9       	bis	r9,	r13	;

0000a294 <.L10>:
    a294:	12 c3       	clrc			
    a296:	09 10       	rrc	r9		;
    a298:	08 10       	rrc	r8		;

0000a29a <.Loc.51.1>:
    a29a:	12 c3       	clrc			
    a29c:	0f 10       	rrc	r15		;
    a29e:	0e 10       	rrc	r14		;
    a2a0:	80 00 40 a2 	mova	#41536,	r0	;0x0a240

0000a2a4 <.L14>:
    a2a4:	0c 4d       	mov	r13,	r12	;

0000a2a6 <.LVL18>:
    a2a6:	80 00 48 a2 	mova	#41544,	r0	;0x0a248

0000a2aa <__mspabi_divlu>:
    a2aa:	b1 00 02 00 	suba	#2,	r1	;

0000a2ae <.LCFI5>:
    a2ae:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    a2b2:	b0 13 20 a2 	calla	#41504		;0x0a220

0000a2b6 <.LVL46>:
    a2b6:	a1 00 02 00 	adda	#2,	r1	;
    a2ba:	10 01       	reta			;

0000a2bc <__mspabi_slli_15>:
    a2bc:	0c 5c       	rla	r12		;

0000a2be <__mspabi_slli_14>:
    a2be:	0c 5c       	rla	r12		;

0000a2c0 <__mspabi_slli_13>:
    a2c0:	0c 5c       	rla	r12		;

0000a2c2 <__mspabi_slli_12>:
    a2c2:	0c 5c       	rla	r12		;

0000a2c4 <__mspabi_slli_11>:
    a2c4:	0c 5c       	rla	r12		;

0000a2c6 <__mspabi_slli_10>:
    a2c6:	0c 5c       	rla	r12		;

0000a2c8 <__mspabi_slli_9>:
    a2c8:	0c 5c       	rla	r12		;

0000a2ca <__mspabi_slli_8>:
    a2ca:	0c 5c       	rla	r12		;

0000a2cc <__mspabi_slli_7>:
    a2cc:	0c 5c       	rla	r12		;

0000a2ce <__mspabi_slli_6>:
    a2ce:	0c 5c       	rla	r12		;

0000a2d0 <__mspabi_slli_5>:
    a2d0:	0c 5c       	rla	r12		;

0000a2d2 <__mspabi_slli_4>:
    a2d2:	0c 5c       	rla	r12		;

0000a2d4 <__mspabi_slli_3>:
    a2d4:	0c 5c       	rla	r12		;

0000a2d6 <__mspabi_slli_2>:
    a2d6:	0c 5c       	rla	r12		;

0000a2d8 <__mspabi_slli_1>:
    a2d8:	0c 5c       	rla	r12		;
    a2da:	10 01       	reta			;

0000a2dc <.L11>:
    a2dc:	3d 53       	add	#-1,	r13	;r3 As==11
    a2de:	0c 5c       	rla	r12		;

0000a2e0 <__mspabi_slli>:
    a2e0:	0d 93       	cmp	#0,	r13	;r3 As==00
    a2e2:	fc 23       	jnz	$-6      	;abs 0xa2dc
    a2e4:	10 01       	reta			;

0000a2e6 <__mspabi_slll_15>:
    a2e6:	0c 5c       	rla	r12		;
    a2e8:	0d 6d       	rlc	r13		;

0000a2ea <__mspabi_slll_14>:
    a2ea:	0c 5c       	rla	r12		;
    a2ec:	0d 6d       	rlc	r13		;

0000a2ee <__mspabi_slll_13>:
    a2ee:	0c 5c       	rla	r12		;
    a2f0:	0d 6d       	rlc	r13		;

0000a2f2 <__mspabi_slll_12>:
    a2f2:	0c 5c       	rla	r12		;
    a2f4:	0d 6d       	rlc	r13		;

0000a2f6 <__mspabi_slll_11>:
    a2f6:	0c 5c       	rla	r12		;
    a2f8:	0d 6d       	rlc	r13		;

0000a2fa <__mspabi_slll_10>:
    a2fa:	0c 5c       	rla	r12		;
    a2fc:	0d 6d       	rlc	r13		;

0000a2fe <__mspabi_slll_9>:
    a2fe:	0c 5c       	rla	r12		;
    a300:	0d 6d       	rlc	r13		;

0000a302 <__mspabi_slll_8>:
    a302:	0c 5c       	rla	r12		;
    a304:	0d 6d       	rlc	r13		;

0000a306 <__mspabi_slll_7>:
    a306:	0c 5c       	rla	r12		;
    a308:	0d 6d       	rlc	r13		;

0000a30a <__mspabi_slll_6>:
    a30a:	0c 5c       	rla	r12		;
    a30c:	0d 6d       	rlc	r13		;

0000a30e <__mspabi_slll_5>:
    a30e:	0c 5c       	rla	r12		;
    a310:	0d 6d       	rlc	r13		;

0000a312 <__mspabi_slll_4>:
    a312:	0c 5c       	rla	r12		;
    a314:	0d 6d       	rlc	r13		;

0000a316 <__mspabi_slll_3>:
    a316:	0c 5c       	rla	r12		;
    a318:	0d 6d       	rlc	r13		;

0000a31a <__mspabi_slll_2>:
    a31a:	0c 5c       	rla	r12		;
    a31c:	0d 6d       	rlc	r13		;

0000a31e <__mspabi_slll_1>:
    a31e:	0c 5c       	rla	r12		;
    a320:	0d 6d       	rlc	r13		;
    a322:	10 01       	reta			;

0000a324 <.L12>:
    a324:	3e 53       	add	#-1,	r14	;r3 As==11
    a326:	0c 5c       	rla	r12		;
    a328:	0d 6d       	rlc	r13		;

0000a32a <__mspabi_slll>:
    a32a:	0e 93       	cmp	#0,	r14	;r3 As==00
    a32c:	fb 23       	jnz	$-8      	;abs 0xa324
    a32e:	10 01       	reta			;

0000a330 <__mspabi_srli_15>:
    a330:	12 c3       	clrc			
    a332:	0c 10       	rrc	r12		;

0000a334 <__mspabi_srli_14>:
    a334:	12 c3       	clrc			
    a336:	0c 10       	rrc	r12		;

0000a338 <__mspabi_srli_13>:
    a338:	12 c3       	clrc			
    a33a:	0c 10       	rrc	r12		;

0000a33c <__mspabi_srli_12>:
    a33c:	12 c3       	clrc			
    a33e:	0c 10       	rrc	r12		;

0000a340 <__mspabi_srli_11>:
    a340:	12 c3       	clrc			
    a342:	0c 10       	rrc	r12		;

0000a344 <__mspabi_srli_10>:
    a344:	12 c3       	clrc			
    a346:	0c 10       	rrc	r12		;

0000a348 <__mspabi_srli_9>:
    a348:	12 c3       	clrc			
    a34a:	0c 10       	rrc	r12		;

0000a34c <__mspabi_srli_8>:
    a34c:	12 c3       	clrc			
    a34e:	0c 10       	rrc	r12		;

0000a350 <__mspabi_srli_7>:
    a350:	12 c3       	clrc			
    a352:	0c 10       	rrc	r12		;

0000a354 <__mspabi_srli_6>:
    a354:	12 c3       	clrc			
    a356:	0c 10       	rrc	r12		;

0000a358 <__mspabi_srli_5>:
    a358:	12 c3       	clrc			
    a35a:	0c 10       	rrc	r12		;

0000a35c <__mspabi_srli_4>:
    a35c:	12 c3       	clrc			
    a35e:	0c 10       	rrc	r12		;

0000a360 <__mspabi_srli_3>:
    a360:	12 c3       	clrc			
    a362:	0c 10       	rrc	r12		;

0000a364 <__mspabi_srli_2>:
    a364:	12 c3       	clrc			
    a366:	0c 10       	rrc	r12		;

0000a368 <__mspabi_srli_1>:
    a368:	12 c3       	clrc			
    a36a:	0c 10       	rrc	r12		;
    a36c:	10 01       	reta			;

0000a36e <.L11>:
    a36e:	3d 53       	add	#-1,	r13	;r3 As==11
    a370:	12 c3       	clrc			
    a372:	0c 10       	rrc	r12		;

0000a374 <__mspabi_srli>:
    a374:	0d 93       	cmp	#0,	r13	;r3 As==00
    a376:	fb 23       	jnz	$-8      	;abs 0xa36e
    a378:	10 01       	reta			;

0000a37a <__mspabi_srll_15>:
    a37a:	12 c3       	clrc			
    a37c:	0d 10       	rrc	r13		;
    a37e:	0c 10       	rrc	r12		;

0000a380 <__mspabi_srll_14>:
    a380:	12 c3       	clrc			
    a382:	0d 10       	rrc	r13		;
    a384:	0c 10       	rrc	r12		;

0000a386 <__mspabi_srll_13>:
    a386:	12 c3       	clrc			
    a388:	0d 10       	rrc	r13		;
    a38a:	0c 10       	rrc	r12		;

0000a38c <__mspabi_srll_12>:
    a38c:	12 c3       	clrc			
    a38e:	0d 10       	rrc	r13		;
    a390:	0c 10       	rrc	r12		;

0000a392 <__mspabi_srll_11>:
    a392:	12 c3       	clrc			
    a394:	0d 10       	rrc	r13		;
    a396:	0c 10       	rrc	r12		;

0000a398 <__mspabi_srll_10>:
    a398:	12 c3       	clrc			
    a39a:	0d 10       	rrc	r13		;
    a39c:	0c 10       	rrc	r12		;

0000a39e <__mspabi_srll_9>:
    a39e:	12 c3       	clrc			
    a3a0:	0d 10       	rrc	r13		;
    a3a2:	0c 10       	rrc	r12		;

0000a3a4 <__mspabi_srll_8>:
    a3a4:	12 c3       	clrc			
    a3a6:	0d 10       	rrc	r13		;
    a3a8:	0c 10       	rrc	r12		;

0000a3aa <__mspabi_srll_7>:
    a3aa:	12 c3       	clrc			
    a3ac:	0d 10       	rrc	r13		;
    a3ae:	0c 10       	rrc	r12		;

0000a3b0 <__mspabi_srll_6>:
    a3b0:	12 c3       	clrc			
    a3b2:	0d 10       	rrc	r13		;
    a3b4:	0c 10       	rrc	r12		;

0000a3b6 <__mspabi_srll_5>:
    a3b6:	12 c3       	clrc			
    a3b8:	0d 10       	rrc	r13		;
    a3ba:	0c 10       	rrc	r12		;

0000a3bc <__mspabi_srll_4>:
    a3bc:	12 c3       	clrc			
    a3be:	0d 10       	rrc	r13		;
    a3c0:	0c 10       	rrc	r12		;

0000a3c2 <__mspabi_srll_3>:
    a3c2:	12 c3       	clrc			
    a3c4:	0d 10       	rrc	r13		;
    a3c6:	0c 10       	rrc	r12		;

0000a3c8 <__mspabi_srll_2>:
    a3c8:	12 c3       	clrc			
    a3ca:	0d 10       	rrc	r13		;
    a3cc:	0c 10       	rrc	r12		;

0000a3ce <__mspabi_srll_1>:
    a3ce:	12 c3       	clrc			
    a3d0:	0d 10       	rrc	r13		;
    a3d2:	0c 10       	rrc	r12		;
    a3d4:	10 01       	reta			;

0000a3d6 <.L12>:
    a3d6:	3e 53       	add	#-1,	r14	;r3 As==11
    a3d8:	12 c3       	clrc			
    a3da:	0d 10       	rrc	r13		;
    a3dc:	0c 10       	rrc	r12		;

0000a3de <__mspabi_srll>:
    a3de:	0e 93       	cmp	#0,	r14	;r3 As==00
    a3e0:	fa 23       	jnz	$-10     	;abs 0xa3d6
    a3e2:	10 01       	reta			;

0000a3e4 <__mspabi_mpyl>:
    a3e4:	02 12       	push	r2		;
    a3e6:	32 c2       	dint			
    a3e8:	03 43       	nop			
    a3ea:	82 4c d0 04 	mov	r12,	&0x04d0	;
    a3ee:	82 4d d2 04 	mov	r13,	&0x04d2	;
    a3f2:	82 4e e0 04 	mov	r14,	&0x04e0	;
    a3f6:	82 4f e2 04 	mov	r15,	&0x04e2	;
    a3fa:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    a3fe:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    a402:	32 41       	pop	r2		;
    a404:	10 01       	reta			;

0000a406 <memcpy>:
    a406:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a408 <.LCFI0>:
    a408:	ca 0c       	mova	r12,	r10	;
    a40a:	ee 0c       	adda	r12,	r14	;

0000a40c <.L2>:
    a40c:	da 0e       	cmpa	r14,	r10	;
    a40e:	08 24       	jz	$+18     	;abs 0xa420

0000a410 <.LVL3>:
    a410:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    a414:	aa 00 01 00 	adda	#1,	r10	;

0000a418 <.LVL4>:
    a418:	ad 00 01 00 	adda	#1,	r13	;
    a41c:	80 00 0c a4 	mova	#41996,	r0	;0x0a40c

0000a420 <.L5>:
    a420:	0a 16       	popm.a	#1,	r10	;20-bit words
    a422:	10 01       	reta			;

0000a424 <memset>:
    a424:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a426 <.LCFI0>:
    a426:	ca 0c       	mova	r12,	r10	;
    a428:	ee 0c       	adda	r12,	r14	;

0000a42a <.L2>:
    a42a:	da 0e       	cmpa	r14,	r10	;
    a42c:	06 24       	jz	$+14     	;abs 0xa43a

0000a42e <.LVL3>:
    a42e:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    a432:	aa 00 01 00 	adda	#1,	r10	;

0000a436 <.LVL4>:
    a436:	80 00 2a a4 	mova	#42026,	r0	;0x0a42a

0000a43a <.L5>:
    a43a:	0a 16       	popm.a	#1,	r10	;20-bit words
    a43c:	10 01       	reta			;

0000a43e <memmove>:
    a43e:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a440 <.LCFI0>:
    a440:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a442 <.LCFI1>:
    a442:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a444 <.LCFI2>:
    a444:	c8 0c       	mova	r12,	r8	;
    a446:	e8 0e       	adda	r14,	r8	;

0000a448 <.Loc.69.1>:
    a448:	dd 0c       	cmpa	r12,	r13	;
    a44a:	04 28       	jnc	$+10     	;abs 0xa454

0000a44c <.L4>:
    a44c:	ce 0c       	mova	r12,	r14	;

0000a44e <.LVL2>:
    a44e:	ca 0d       	mova	r13,	r10	;
    a450:	80 00 78 a4 	mova	#42104,	r0	;0x0a478

0000a454 <.L2>:
    a454:	ca 0d       	mova	r13,	r10	;
    a456:	ea 0e       	adda	r14,	r10	;
    a458:	dc 0a       	cmpa	r10,	r12	;
    a45a:	f8 2f       	jc	$-14     	;abs 0xa44c

0000a45c <.LVL4>:
    a45c:	fe 0a       	suba	r10,	r14	;

0000a45e <.L5>:
    a45e:	c6 0a       	mova	r10,	r6	;
    a460:	e6 0e       	adda	r14,	r6	;

0000a462 <.Loc.74.1>:
    a462:	96 00 00 00 	cmpa	#0,	r6	;
    a466:	12 24       	jz	$+38     	;abs 0xa48c

0000a468 <.Loc.76.1>:
    a468:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    a46c:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000a470 <.LVL7>:
    a470:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    a474:	80 00 5e a4 	mova	#42078,	r0	;0x0a45e

0000a478 <.L3>:
    a478:	d8 0e       	cmpa	r14,	r8	;
    a47a:	08 24       	jz	$+18     	;abs 0xa48c

0000a47c <.LVL9>:
    a47c:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    a480:	ae 00 01 00 	adda	#1,	r14	;

0000a484 <.LVL10>:
    a484:	aa 00 01 00 	adda	#1,	r10	;
    a488:	80 00 78 a4 	mova	#42104,	r0	;0x0a478

0000a48c <.L9>:
    a48c:	06 16       	popm.a	#1,	r6	;20-bit words
    a48e:	08 16       	popm.a	#1,	r8	;20-bit words
    a490:	0a 16       	popm.a	#1,	r10	;20-bit words
    a492:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000cca0 <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    cca0:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cca2 <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    cca2:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    cca6:	da 07 

0000cca8 <.LBB12>:
  chSysTimerHandlerI();
    cca8:	b0 13 68 46 	calla	#18024		;0x04668

0000ccac <.LBE12>:
  OSAL_IRQ_EPILOGUE();
    ccac:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    ccb0:	da 07 
    ccb2:	b0 13 ba 47 	calla	#18362		;0x047ba

0000ccb6 <.LVL1>:
    ccb6:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    ccb8:	02 24       	jz	$+6      	;abs 0xccbe

0000ccba <.Loc.174.1>:
    ccba:	b0 13 ca 47 	calla	#18378		;0x047ca

0000ccbe <.L1>:
}
    ccbe:	b4 16       	popm.a	#12,	r15	;20-bit words
    ccc0:	00 13       	reti			

0000ccc2 <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    ccc2:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000ccc4 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    ccc4:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    ccc8:	da 07 

0000ccca <.Loc.400.1>:
  switch (__even_in_range(UCA1IV, USCI_UART_UCTXCPTIFG)) {
    ccca:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    ccce:	fe 05 
    ccd0:	2c 92       	cmp	#4,	r12	;r2 As==10
    ccd2:	38 24       	jz	$+114    	;abs 0xcd44
    ccd4:	3c 92       	cmp	#8,	r12	;r2 As==11
    ccd6:	58 24       	jz	$+178    	;abs 0xcd88
    ccd8:	2c 93       	cmp	#2,	r12	;r3 As==10
    ccda:	67 20       	jnz	$+208    	;abs 0xcdaa

0000ccdc <.Loc.404.1>:
    if (UCA1STATW & UCRXERR)
    ccdc:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    cce0:	ea 05 
    cce2:	1a 24       	jz	$+54     	;abs 0xcd18

0000cce4 <.Loc.405.1>:
      set_error(UCA1STATW, &SD1);
    cce4:	40 18 5c 42 	movx.b	&0x005ea,r12	;
    cce8:	ea 05 

0000ccea <.LBB32>:
  if (sra & UCOE)
    ccea:	40 18 3c b0 	bitx.w	#32,	r12	;0x00020
    ccee:	20 00 
    ccf0:	25 24       	jz	$+76     	;abs 0xcd3c

0000ccf2 <.Loc.317.1>:
    sts |= SD_OVERRUN_ERROR;
    ccf2:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    ccf6:	4e 43       	clr.b	r14		;

0000ccf8 <.L51>:
  if (sra & UCPE)
    ccf8:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    ccfc:	10 00 
    ccfe:	02 24       	jz	$+6      	;abs 0xcd04

0000cd00 <.Loc.319.1>:
    sts |= SD_PARITY_ERROR;
    cd00:	3d d0 20 00 	bis	#32,	r13	;#0x0020

0000cd04 <.L52>:
  if (sra & UCFE)
    cd04:	40 18 3c b0 	bitx.w	#64,	r12	;0x00040
    cd08:	40 00 
    cd0a:	02 24       	jz	$+6      	;abs 0xcd10

0000cd0c <.Loc.321.1>:
    sts |= SD_FRAMING_ERROR;
    cd0c:	3d d0 40 00 	bis	#64,	r13	;#0x0040

0000cd10 <.L53>:
  chnAddFlagsI(sdp, sts);
    cd10:	8c 01 e0 07 	mova	#67552,	r12	;0x107e0

0000cd14 <.LVL82>:
    cd14:	b0 13 aa 55 	calla	#21930		;0x055aa

0000cd18 <.L50>:
    sdIncomingDataI(&SD1, UCA1RXBUF);
    cd18:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    cd1c:	ec 05 
    cd1e:	8c 01 dc 07 	mova	#67548,	r12	;0x107dc
    cd22:	b0 13 9e 54 	calla	#21662		;0x0549e

0000cd26 <.L54>:
  OSAL_IRQ_EPILOGUE();
    cd26:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    cd2a:	da 07 
    cd2c:	b0 13 ba 47 	calla	#18362		;0x047ba

0000cd30 <.LVL85>:
    cd30:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cd32:	02 24       	jz	$+6      	;abs 0xcd38

0000cd34 <.Loc.443.1>:
    cd34:	b0 13 ca 47 	calla	#18378		;0x047ca

0000cd38 <.L45>:
}
    cd38:	b4 16       	popm.a	#12,	r15	;20-bit words
    cd3a:	00 13       	reti			

0000cd3c <.L59>:
  eventflags_t sts = 0;
    cd3c:	4d 43       	clr.b	r13		;
    cd3e:	0e 4d       	mov	r13,	r14	;
    cd40:	80 00 f8 cc 	mova	#52472,	r0	;0x0ccf8

0000cd44 <.L47>:
    b = sdRequestDataI(&SD1);
    cd44:	8c 01 dc 07 	mova	#67548,	r12	;0x107dc
    cd48:	b0 13 f0 54 	calla	#21744		;0x054f0

0000cd4c <.LVL89>:
    if (b < Q_OK) {
    cd4c:	9c 00 00 00 	cmpa	#0,	r12	;
    cd50:	14 34       	jge	$+42     	;abs 0xcd7a

0000cd52 <.Loc.419.1>:
      chnAddFlagsI(&SD1, CHN_OUTPUT_EMPTY);
    cd52:	7d 42       	mov.b	#8,	r13	;r2 As==11
    cd54:	4e 43       	clr.b	r14		;
    cd56:	8c 01 e0 07 	mova	#67552,	r12	;0x107e0

0000cd5a <.LVL90>:
    cd5a:	b0 13 aa 55 	calla	#21930		;0x055aa

0000cd5e <.LVL91>:
      UCA1IE = (UCA1IE & ~UCTXIE) | UCTXCPTIE;
    cd5e:	40 18 1c 42 	movx.w	&0x005fa,r12	;
    cd62:	fa 05 
    cd64:	3c f0 f5 ff 	and	#-11,	r12	;#0xfff5
    cd68:	3c d2       	bis	#8,	r12	;r2 As==11
    cd6a:	40 18 82 4c 	movx.w	r12,	&0x005fa;
    cd6e:	fa 05 

0000cd70 <.Loc.421.1>:
      UCA1IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    cd70:	40 18 a2 d3 	bisx.w	#2,	&0x005fc;r3 As==10
    cd74:	fc 05 
    cd76:	80 00 26 cd 	mova	#52518,	r0	;0x0cd26

0000cd7a <.L55>:
      UCA1TXBUF = b;
    cd7a:	40 18 0c 4c 	movx.w	r12,	r12	;

0000cd7e <.LVL93>:
    cd7e:	40 18 82 4c 	movx.w	r12,	&0x005ee;
    cd82:	ee 05 
    cd84:	80 00 26 cd 	mova	#52518,	r0	;0x0cd26

0000cd88 <.L48>:
    if (oqIsEmptyI(&SD1.oqueue))
    cd88:	8c 01 dc 07 	mova	#67548,	r12	;0x107dc
    cd8c:	81 18 d2 92 	cmpx.a	&0x1081e,&0x1081a;
    cd90:	1e 08 1a 08 
    cd94:	05 20       	jnz	$+12     	;abs 0xcda0

0000cd96 <.Loc.432.1>:
    cd96:	3e 0c 32 00 	mova	50(r12),r14	;0x00032
    cd9a:	9e 00 00 00 	cmpa	#0,	r14	;
    cd9e:	0b 20       	jnz	$+24     	;abs 0xcdb6

0000cda0 <.L56>:
    UCA1IE &= ~UCTXCPTIE;
    cda0:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    cda4:	fa 05 
    cda6:	80 00 26 cd 	mova	#52518,	r0	;0x0cd26

0000cdaa <.L72>:
    osalDbgAssert(false, "unhandled serial interrupt");
    cdaa:	8c 01 d5 02 	mova	#66261,	r12	;0x102d5
    cdae:	b0 13 58 46 	calla	#18008		;0x04658

0000cdb2 <.LVL94>:
    break;
    cdb2:	80 00 26 cd 	mova	#52518,	r0	;0x0cd26

0000cdb6 <.L57>:
      chnAddFlagsI(&SD1, CHN_TRANSMISSION_END);
    cdb6:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    cdba:	4e 43       	clr.b	r14		;
    cdbc:	ac 00 04 00 	adda	#4,	r12	;
    cdc0:	b0 13 aa 55 	calla	#21930		;0x055aa

0000cdc4 <.LVL95>:
    cdc4:	80 00 a0 cd 	mova	#52640,	r0	;0x0cda0

0000cdc8 <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    cdc8:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cdca <.LCFI0>:
    cdca:	b1 00 04 00 	suba	#4,	r1	;

0000cdce <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    cdce:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    cdd2:	da 07 

0000cdd4 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    cdd4:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    cdd8:	0e 02 

0000cdda <.LVL0>:
    cdda:	12 c3       	clrc			
    cddc:	0c 10       	rrc	r12		;

0000cdde <.LVL1>:
    cdde:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cde0 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    cde0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cde4:	0d 43       	clr	r13		;
    cde6:	0e 4c       	mov	r12,	r14	;
    cde8:	0f 4d       	mov	r13,	r15	;
    cdea:	0e 5e       	rla	r14		;
    cdec:	0f 6f       	rlc	r15		;
    cdee:	0e 5e       	rla	r14		;
    cdf0:	0f 6f       	rlc	r15		;
    cdf2:	81 4e 00 00 	mov	r14,	0(r1)	;
    cdf6:	81 4f 02 00 	mov	r15,	2(r1)	;
    cdfa:	0d 01       	mova	@r1,	r13	;
    cdfc:	80 18 5c 4d 	movx.a	67658(r13),r12	;0x1084a
    ce00:	4a 08 

0000ce02 <.LVL2>:
  if (cb != NULL) {
    ce02:	9c 00 00 00 	cmpa	#0,	r12	;
    ce06:	01 24       	jz	$+4      	;abs 0xce0a

0000ce08 <.Loc.81.1>:
    (*cb)();
    ce08:	4c 13       	calla	r12		;

0000ce0a <.L2>:
  OSAL_IRQ_EPILOGUE();
    ce0a:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    ce0e:	da 07 
    ce10:	b0 13 ba 47 	calla	#18362		;0x047ba

0000ce14 <.LVL4>:
    ce14:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    ce16:	02 24       	jz	$+6      	;abs 0xce1c

0000ce18 <.Loc.84.1>:
    ce18:	b0 13 ca 47 	calla	#18378		;0x047ca

0000ce1c <.L1>:
}
    ce1c:	a1 00 04 00 	adda	#4,	r1	;
    ce20:	b4 16       	popm.a	#12,	r15	;20-bit words
    ce22:	00 13       	reti			

0000ce24 <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    ce24:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000ce26 <.LCFI2>:
    ce26:	b1 00 04 00 	suba	#4,	r1	;

0000ce2a <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    ce2a:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    ce2e:	da 07 

0000ce30 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    ce30:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    ce34:	1e 02 

0000ce36 <.LVL6>:
    ce36:	12 c3       	clrc			
    ce38:	0c 10       	rrc	r12		;

0000ce3a <.LVL7>:
    ce3a:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000ce3c <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    ce3c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ce40:	4c 0e       	rlam.a	#4,	r12	;
    ce42:	4c 0d       	rram.a	#4,	r12	;
    ce44:	ac 00 08 00 	adda	#8,	r12	;
    ce48:	0c 14       	pushm.a	#1,	r12	;20-bit words
    ce4a:	40 18 3c 41 	popx.w	r12		;
    ce4e:	40 18 3d 41 	popx.w	r13		;
    ce52:	0e 4c       	mov	r12,	r14	;
    ce54:	0f 4d       	mov	r13,	r15	;
    ce56:	0e 5e       	rla	r14		;
    ce58:	0f 6f       	rlc	r15		;
    ce5a:	0e 5e       	rla	r14		;
    ce5c:	0f 6f       	rlc	r15		;
    ce5e:	81 4e 00 00 	mov	r14,	0(r1)	;
    ce62:	81 4f 02 00 	mov	r15,	2(r1)	;
    ce66:	0d 01       	mova	@r1,	r13	;
    ce68:	80 18 5c 4d 	movx.a	67658(r13),r12	;0x1084a
    ce6c:	4a 08 

0000ce6e <.LVL8>:
  if (cb != NULL) {
    ce6e:	9c 00 00 00 	cmpa	#0,	r12	;
    ce72:	01 24       	jz	$+4      	;abs 0xce76

0000ce74 <.Loc.99.1>:
    (*cb)();
    ce74:	4c 13       	calla	r12		;

0000ce76 <.L11>:
  OSAL_IRQ_EPILOGUE();
    ce76:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    ce7a:	da 07 
    ce7c:	b0 13 ba 47 	calla	#18362		;0x047ba

0000ce80 <.LVL10>:
    ce80:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    ce82:	02 24       	jz	$+6      	;abs 0xce88

0000ce84 <.Loc.102.1>:
    ce84:	b0 13 ca 47 	calla	#18378		;0x047ca

0000ce88 <.L10>:
}
    ce88:	a1 00 04 00 	adda	#4,	r1	;
    ce8c:	b4 16       	popm.a	#12,	r15	;20-bit words
    ce8e:	00 13       	reti			

0000ce90 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    ce90:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000ce92 <.LCFI4>:
    ce92:	b1 00 04 00 	suba	#4,	r1	;

0000ce96 <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    ce96:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    ce9a:	da 07 

0000ce9c <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    ce9c:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    cea0:	2e 02 

0000cea2 <.LVL12>:
    cea2:	12 c3       	clrc			
    cea4:	0c 10       	rrc	r12		;

0000cea6 <.LVL13>:
    cea6:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cea8 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    cea8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ceac:	4c 0e       	rlam.a	#4,	r12	;
    ceae:	4c 0d       	rram.a	#4,	r12	;
    ceb0:	ac 00 10 00 	adda	#16,	r12	;0x00010
    ceb4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    ceb6:	40 18 3c 41 	popx.w	r12		;
    ceba:	40 18 3d 41 	popx.w	r13		;
    cebe:	0e 4c       	mov	r12,	r14	;
    cec0:	0f 4d       	mov	r13,	r15	;
    cec2:	0e 5e       	rla	r14		;
    cec4:	0f 6f       	rlc	r15		;
    cec6:	0e 5e       	rla	r14		;
    cec8:	0f 6f       	rlc	r15		;
    ceca:	81 4e 00 00 	mov	r14,	0(r1)	;
    cece:	81 4f 02 00 	mov	r15,	2(r1)	;
    ced2:	0d 01       	mova	@r1,	r13	;
    ced4:	80 18 5c 4d 	movx.a	67658(r13),r12	;0x1084a
    ced8:	4a 08 

0000ceda <.LVL14>:
  if (cb != NULL) {
    ceda:	9c 00 00 00 	cmpa	#0,	r12	;
    cede:	01 24       	jz	$+4      	;abs 0xcee2

0000cee0 <.Loc.118.1>:
    (*cb)();
    cee0:	4c 13       	calla	r12		;

0000cee2 <.L20>:
  OSAL_IRQ_EPILOGUE();
    cee2:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    cee6:	da 07 
    cee8:	b0 13 ba 47 	calla	#18362		;0x047ba

0000ceec <.LVL16>:
    ceec:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    ceee:	02 24       	jz	$+6      	;abs 0xcef4

0000cef0 <.Loc.121.1>:
    cef0:	b0 13 ca 47 	calla	#18378		;0x047ca

0000cef4 <.L19>:
}
    cef4:	a1 00 04 00 	adda	#4,	r1	;
    cef8:	b4 16       	popm.a	#12,	r15	;20-bit words
    cefa:	00 13       	reti			

0000cefc <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    cefc:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cefe <.LCFI6>:
    cefe:	b1 00 04 00 	suba	#4,	r1	;

0000cf02 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    cf02:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    cf06:	da 07 

0000cf08 <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    cf08:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    cf0c:	3e 02 

0000cf0e <.LVL18>:
    cf0e:	12 c3       	clrc			
    cf10:	0c 10       	rrc	r12		;

0000cf12 <.LVL19>:
    cf12:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000cf14 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    cf14:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    cf18:	4c 0e       	rlam.a	#4,	r12	;
    cf1a:	4c 0d       	rram.a	#4,	r12	;
    cf1c:	ac 00 18 00 	adda	#24,	r12	;0x00018
    cf20:	0c 14       	pushm.a	#1,	r12	;20-bit words
    cf22:	40 18 3c 41 	popx.w	r12		;
    cf26:	40 18 3d 41 	popx.w	r13		;
    cf2a:	0e 4c       	mov	r12,	r14	;
    cf2c:	0f 4d       	mov	r13,	r15	;
    cf2e:	0e 5e       	rla	r14		;
    cf30:	0f 6f       	rlc	r15		;
    cf32:	0e 5e       	rla	r14		;
    cf34:	0f 6f       	rlc	r15		;
    cf36:	81 4e 00 00 	mov	r14,	0(r1)	;
    cf3a:	81 4f 02 00 	mov	r15,	2(r1)	;
    cf3e:	0d 01       	mova	@r1,	r13	;
    cf40:	80 18 5c 4d 	movx.a	67658(r13),r12	;0x1084a
    cf44:	4a 08 

0000cf46 <.LVL20>:
  if (cb != NULL) {
    cf46:	9c 00 00 00 	cmpa	#0,	r12	;
    cf4a:	01 24       	jz	$+4      	;abs 0xcf4e

0000cf4c <.Loc.136.1>:
    (*cb)();
    cf4c:	4c 13       	calla	r12		;

0000cf4e <.L29>:
  OSAL_IRQ_EPILOGUE();
    cf4e:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    cf52:	da 07 
    cf54:	b0 13 ba 47 	calla	#18362		;0x047ba

0000cf58 <.LVL22>:
    cf58:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cf5a:	02 24       	jz	$+6      	;abs 0xcf60

0000cf5c <.Loc.139.1>:
    cf5c:	b0 13 ca 47 	calla	#18378		;0x047ca

0000cf60 <.L28>:
}
    cf60:	a1 00 04 00 	adda	#4,	r1	;
    cf64:	b4 16       	popm.a	#12,	r15	;20-bit words
    cf66:	00 13       	reti			

0000cf68 <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    cf68:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cf6a <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    cf6a:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    cf6e:	da 07 

0000cf70 <.Loc.75.1>:
  index = (DMAIV >> 1) - 1;
    cf70:	40 18 18 42 	movx.w	&0x0050e,r8	;
    cf74:	0e 05 
    cf76:	12 c3       	clrc			
    cf78:	08 10       	rrc	r8		;
    cf7a:	78 53       	add.b	#-1,	r8	;r3 As==11
    cf7c:	49 48       	mov.b	r8,	r9	;

0000cf7e <.LVL6>:
  if (index < MSP430X_DMA_CHANNELS) {
    cf7e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    cf80:	4c 98       	cmp.b	r8,	r12	;
    cf82:	30 28       	jnc	$+98     	;abs 0xcfe4

0000cf84 <.LBB14>:
    dma_regs[index].ctl &= ~DMAEN;
    cf84:	4c 48       	mov.b	r8,	r12	;
    cf86:	0d 43       	clr	r13		;
    cf88:	b0 13 12 a3 	calla	#41746		;0x0a312
    cf8c:	0d 12       	push	r13		;
    cf8e:	0c 12       	push	r12		;
    cf90:	0a 16       	popm.a	#1,	r10	;20-bit words
    cf92:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    cf96:	ba f0 ef ff 	and	#-17,	0(r10)	;#0xffef
    cf9a:	00 00 

0000cf9c <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    cf9c:	4d 43       	clr.b	r13		;
    cf9e:	4c 48       	mov.b	r8,	r12	;
    cfa0:	b0 13 84 59 	calla	#22916		;0x05984

0000cfa4 <.LVL8>:
    dma_regs[index].sz  = 0;
    cfa4:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000cfa8 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    cfa8:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    cfac:	00 00 

0000cfae <.Loc.87.1>:
    if (cb->callback != NULL) {
    cfae:	8a 00 b8 a7 	mova	#42936,	r10	;0x0a7b8
    cfb2:	08 49       	mov	r9,	r8	;
    cfb4:	09 43       	clr	r9		;

0000cfb6 <.LVL10>:
    cfb6:	0c 48       	mov	r8,	r12	;
    cfb8:	0d 49       	mov	r9,	r13	;
    cfba:	b0 13 16 a3 	calla	#41750		;0x0a316
    cfbe:	0d 12       	push	r13		;
    cfc0:	0c 12       	push	r12		;
    cfc2:	0c 16       	popm.a	#1,	r12	;20-bit words
    cfc4:	ec 0a       	adda	r10,	r12	;
    cfc6:	06 0c       	mova	@r12,	r6	;
    cfc8:	96 00 00 00 	cmpa	#0,	r6	;
    cfcc:	0b 24       	jz	$+24     	;abs 0xcfe4

0000cfce <.Loc.88.1>:
      cb->callback(cb->args);
    cfce:	0c 48       	mov	r8,	r12	;
    cfd0:	0d 49       	mov	r9,	r13	;
    cfd2:	b0 13 16 a3 	calla	#41750		;0x0a316
    cfd6:	0d 12       	push	r13		;
    cfd8:	0c 12       	push	r12		;
    cfda:	0c 16       	popm.a	#1,	r12	;20-bit words
    cfdc:	ea 0c       	adda	r12,	r10	;
    cfde:	3c 0a 04 00 	mova	4(r10),	r12	;
    cfe2:	46 13       	calla	r6		;

0000cfe4 <.L4>:
  OSAL_IRQ_EPILOGUE();
    cfe4:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    cfe8:	da 07 
    cfea:	b0 13 ba 47 	calla	#18362		;0x047ba

0000cfee <.LVL14>:
    cfee:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cff0:	02 24       	jz	$+6      	;abs 0xcff6

0000cff2 <.Loc.92.1>:
    cff2:	b0 13 ca 47 	calla	#18378		;0x047ca

0000cff6 <.L2>:
}
    cff6:	b4 16       	popm.a	#12,	r15	;20-bit words
    cff8:	00 13       	reti			

0000cffa <ISR_USCI_B0_VECTOR>:
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    cffa:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000cffc <.LCFI23>:
  OSAL_IRQ_PROLOGUE();
    cffc:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    d000:	da 07 

0000d002 <.Loc.110.1>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    d002:	40 18 1c 42 	movx.w	&0x0066e,r12	;
    d006:	6e 06 
    d008:	8a 01 ca 08 	mova	#67786,	r10	;0x108ca
    d00c:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    d010:	74 24       	jz	$+234    	;abs 0xd0fa
    d012:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    d016:	0d 9c       	cmp	r12,	r13	;
    d018:	60 28       	jnc	$+194    	;abs 0xd0da
    d01a:	3c 90 06 00 	cmp	#6,	r12	;
    d01e:	6d 24       	jz	$+220    	;abs 0xd0fa
    d020:	7d 40 06 00 	mov.b	#6,	r13	;
    d024:	0d 9c       	cmp	r12,	r13	;
    d026:	3e 28       	jnc	$+126    	;abs 0xd0a4
    d028:	2c 93       	cmp	#2,	r12	;r3 As==10
    d02a:	8a 24       	jz	$+278    	;abs 0xd140
    d02c:	2c 92       	cmp	#4,	r12	;r2 As==10
    d02e:	8c 24       	jz	$+282    	;abs 0xd148

0000d030 <.L117>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    d030:	41 18 82 93 	cmpx.w	#0,	&0x108d0;r3 As==00
    d034:	d0 08 
    d036:	2b 24       	jz	$+88     	;abs 0xd08e

0000d038 <.LBB69>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    d038:	17 4a 1c 00 	mov	28(r10),r7	;0x0001c
    d03c:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    d040:	19 4c 0a 00 	mov	10(r12),r9	;0x0000a

0000d044 <.LVL88>:
    dmaCancelI(&I2CDB0.dma);
    d044:	8c 01 fe 08 	mova	#67838,	r12	;0x108fe
    d048:	b0 13 f8 5a 	calla	#23288		;0x05af8

0000d04c <.LVL89>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    d04c:	40 18 fa b0 	bitx.b	#32,	6(r10)	;0x00020
    d050:	20 00 06 00 
    d054:	04 24       	jz	$+10     	;abs 0xd05e

0000d056 <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    d056:	41 18 f2 40 	movx.b	#5,	&0x108ca;
    d05a:	05 00 ca 08 

0000d05e <.L135>:
    if (NULL != I2CDB0.callback) {
    d05e:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    d062:	98 00 00 00 	cmpa	#0,	r8	;
    d066:	09 24       	jz	$+20     	;abs 0xd07a

0000d068 <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    d068:	40 18 0e 47 	movx.w	r7,	r14	;
    d06c:	40 18 0e 89 	subx.w	r9,	r14	;
    d070:	3d 0a 08 00 	mova	8(r10),	r13	;
    d074:	8c 01 ca 08 	mova	#67786,	r12	;0x108ca
    d078:	48 13       	calla	r8		;

0000d07a <.L136>:
    if (I2CDB0.thread != NULL) {
    d07a:	01 18 c2 93 	cmpx.a	#0,	&0x108f8;r3 As==00
    d07e:	f8 08 
    d080:	06 24       	jz	$+14     	;abs 0xd08e

0000d082 <.LBB70>:
  chThdResumeI(trp, msg);
    d082:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    d086:	8c 01 f8 08 	mova	#67832,	r12	;0x108f8

0000d08a <.LVL92>:
    d08a:	b0 13 58 48 	calla	#18520		;0x04858

0000d08e <.L134>:
  OSAL_IRQ_EPILOGUE();
    d08e:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    d092:	da 07 
    d094:	b0 13 ba 47 	calla	#18362		;0x047ba

0000d098 <.LVL94>:
    d098:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d09a:	02 24       	jz	$+6      	;abs 0xd0a0

0000d09c <.Loc.211.1>:
    d09c:	b0 13 ca 47 	calla	#18378		;0x047ca

0000d0a0 <.L116>:
}
    d0a0:	b4 16       	popm.a	#12,	r15	;20-bit words
    d0a2:	00 13       	reti			

0000d0a4 <.L121>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    d0a4:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    d0a8:	28 24       	jz	$+82     	;abs 0xd0fa
    d0aa:	3c 90 0c 00 	cmp	#12,	r12	;#0x000c
    d0ae:	25 24       	jz	$+76     	;abs 0xd0fa
    d0b0:	3c 92       	cmp	#8,	r12	;r2 As==11
    d0b2:	be 23       	jnz	$-130    	;abs 0xd030

0000d0b4 <.Loc.126.1>:
      I2CDB0.state = I2C_READY;
    d0b4:	41 18 e2 43 	movx.b	#2,	&0x108ca;r3 As==10
    d0b8:	ca 08 

0000d0ba <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    d0ba:	01 18 c2 93 	cmpx.a	#0,	&0x108f8;r3 As==00
    d0be:	f8 08 
    d0c0:	06 24       	jz	$+14     	;abs 0xd0ce

0000d0c2 <.LBB72>:
    d0c2:	4d 43       	clr.b	r13		;
    d0c4:	cc 0a       	mova	r10,	r12	;
    d0c6:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    d0ca:	b0 13 58 48 	calla	#18520		;0x04858

0000d0ce <.L130>:
        dmaReleaseX(&(I2CDB0.dma));
    d0ce:	8c 01 fe 08 	mova	#67838,	r12	;0x108fe
    d0d2:	b0 13 b2 5a 	calla	#23218		;0x05ab2

0000d0d6 <.LVL98>:
      break;
    d0d6:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d0da <.L119>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    d0da:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    d0de:	38 24       	jz	$+114    	;abs 0xd150
    d0e0:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    d0e4:	0d 9c       	cmp	r12,	r13	;
    d0e6:	0f 28       	jnc	$+32     	;abs 0xd106
    d0e8:	3c 90 12 00 	cmp	#18,	r12	;#0x0012
    d0ec:	06 24       	jz	$+14     	;abs 0xd0fa
    d0ee:	3c 90 14 00 	cmp	#20,	r12	;#0x0014
    d0f2:	03 24       	jz	$+8      	;abs 0xd0fa
    d0f4:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    d0f8:	9b 23       	jnz	$-200    	;abs 0xd030

0000d0fa <.L127>:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
    d0fa:	8c 01 33 04 	mova	#66611,	r12	;0x10433
    d0fe:	b0 13 58 46 	calla	#18008		;0x04658

0000d102 <.LVL99>:
      break;
    d102:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d106 <.L126>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    d106:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    d10a:	f7 27       	jz	$-16     	;abs 0xd0fa
    d10c:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    d110:	3c 24       	jz	$+122    	;abs 0xd18a
    d112:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    d116:	8c 23       	jnz	$-230    	;abs 0xd030

0000d118 <.Loc.158.1>:
      UCB0IE &= ~(UCTXIE);
    d118:	40 18 a2 c3 	bicx.w	#2,	&0x0066a;r3 As==10
    d11c:	6a 06 

0000d11e <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    d11e:	01 18 c2 93 	cmpx.a	#0,	&0x108f8;r3 As==00
    d122:	f8 08 
    d124:	2a 20       	jnz	$+86     	;abs 0xd17a

0000d126 <.Loc.162.1>:
        if (NULL != I2CDB0.callback) {
    d126:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    d12a:	98 00 00 00 	cmpa	#0,	r8	;
    d12e:	20 24       	jz	$+66     	;abs 0xd170

0000d130 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    d130:	1e 4a 1c 00 	mov	28(r10),r14	;0x0001c
    d134:	3d 0a 08 00 	mova	8(r10),	r13	;
    d138:	cc 0a       	mova	r10,	r12	;
    d13a:	48 13       	calla	r8		;

0000d13c <.LVL100>:
    d13c:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d140 <.L122>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    d140:	aa d3 06 00 	bis	#2,	6(r10)	;r3 As==10

0000d144 <.Loc.116.1>:
      break;
    d144:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d148 <.L123>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    d148:	aa d2 06 00 	bis	#4,	6(r10)	;r2 As==10

0000d14c <.Loc.120.1>:
      break;
    d14c:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d150 <.L125>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    d150:	40 18 1d 42 	movx.w	&0x0064c,r13	;
    d154:	4c 06 
    d156:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    d15a:	1c 00 
    d15c:	00 18 5c 5a 	addx.a	24(r10),r12	;0x00018
    d160:	18 00 
    d162:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000d166 <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    d166:	40 18 92 c3 	bicx.w	#1,	&0x0066a;r3 As==01
    d16a:	6a 06 

0000d16c <.Loc.155.1>:
      break;
    d16c:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d170 <.L132>:
          i2cMSP430XEndTransferI(&I2CDB0);
    d170:	cc 0a       	mova	r10,	r12	;
    d172:	b0 13 0c 60 	calla	#24588		;0x0600c

0000d176 <.LVL101>:
    d176:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d17a <.L131>:
    d17a:	4d 43       	clr.b	r13		;
    d17c:	cc 0a       	mova	r10,	r12	;
    d17e:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    d182:	b0 13 58 48 	calla	#18520		;0x04858

0000d186 <.LVL103>:
    d186:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d18a <.L128>:
      I2CDB0.errors |= I2C_TIMEOUT;
    d18a:	ba d0 20 00 	bis	#32,	6(r10)	;#0x0020
    d18e:	06 00 

0000d190 <.Loc.185.1>:
      break;
    d190:	80 00 30 d0 	mova	#53296,	r0	;0x0d030

0000d194 <ISR_TIMER0_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER0_A1_VECTOR) {
    d194:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d196 <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    d196:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    d19a:	da 07 

0000d19c <.Loc.95.1>:
  switch(__even_in_range(TA0IV, TA0IV_TAIFG)) {
    d19c:	40 18 1c 42 	movx.w	&0x0036e,r12	;
    d1a0:	6e 03 
    d1a2:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    d1a6:	1b 20       	jnz	$+56     	;abs 0xd1de

0000d1a8 <.Loc.98.1>:
      if ((GPTDA0.state == GPT_ONESHOT || 
    d1a8:	8c 01 12 09 	mova	#67858,	r12	;0x10912
    d1ac:	6d 4c       	mov.b	@r12,	r13	;
    d1ae:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    d1b2:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d1b4:	4e 9d       	cmp.b	r13,	r14	;
    d1b6:	08 28       	jnc	$+18     	;abs 0xd1c8

0000d1b8 <.Loc.100.1>:
          NULL != GPTDA0.config->callback) {
    d1b8:	3e 0c 02 00 	mova	2(r12),	r14	;
    d1bc:	3e 0e 04 00 	mova	4(r14),	r14	;

0000d1c0 <.Loc.99.1>:
            GPTDA0.state == GPT_CONTINUOUS) &&
    d1c0:	9e 00 00 00 	cmpa	#0,	r14	;
    d1c4:	01 24       	jz	$+4      	;abs 0xd1c8

0000d1c6 <.Loc.101.1>:
        GPTDA0.config->callback(&GPTDA0);
    d1c6:	4e 13       	calla	r14		;

0000d1c8 <.L25>:
      if (GPTDA0.state == GPT_ONESHOT) {
    d1c8:	41 18 e2 92 	cmpx.b	#4,	&0x10912;r2 As==10
    d1cc:	12 09 
    d1ce:	07 20       	jnz	$+16     	;abs 0xd1de

0000d1d0 <.Loc.105.1>:
        GPTDA0.state = GPT_READY;
    d1d0:	41 18 e2 43 	movx.b	#2,	&0x10912;r3 As==10
    d1d4:	12 09 

0000d1d6 <.Loc.106.1>:
        gpt_lld_stop_timer(&GPTDA0);
    d1d6:	8c 01 12 09 	mova	#67858,	r12	;0x10912
    d1da:	b0 13 bc 61 	calla	#25020		;0x061bc

0000d1de <.L23>:
  OSAL_IRQ_EPILOGUE();
    d1de:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    d1e2:	da 07 
    d1e4:	b0 13 ba 47 	calla	#18362		;0x047ba

0000d1e8 <.LVL25>:
    d1e8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d1ea:	02 24       	jz	$+6      	;abs 0xd1f0

0000d1ec <.Loc.111.1>:
    d1ec:	b0 13 ca 47 	calla	#18378		;0x047ca

0000d1f0 <.L22>:
}
    d1f0:	b4 16       	popm.a	#12,	r15	;20-bit words
    d1f2:	00 13       	reti			

0000d1f4 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    d1f4:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d1f6 <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    d1f6:	41 18 d2 43 	movx.b	#1,	&0x107da;r3 As==01
    d1fa:	da 07 

0000d1fc <.Loc.119.1>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    d1fc:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    d200:	ae 03 
    d202:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    d206:	1b 20       	jnz	$+56     	;abs 0xd23e

0000d208 <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    d208:	8c 01 08 09 	mova	#67848,	r12	;0x10908
    d20c:	6d 4c       	mov.b	@r12,	r13	;
    d20e:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    d212:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d214:	4e 9d       	cmp.b	r13,	r14	;
    d216:	08 28       	jnc	$+18     	;abs 0xd228

0000d218 <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    d218:	3e 0c 02 00 	mova	2(r12),	r14	;
    d21c:	3e 0e 04 00 	mova	4(r14),	r14	;

0000d220 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    d220:	9e 00 00 00 	cmpa	#0,	r14	;
    d224:	01 24       	jz	$+4      	;abs 0xd228

0000d226 <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    d226:	4e 13       	calla	r14		;

0000d228 <.L36>:
      if (GPTDA1.state == GPT_ONESHOT) {
    d228:	41 18 e2 92 	cmpx.b	#4,	&0x10908;r2 As==10
    d22c:	08 09 
    d22e:	07 20       	jnz	$+16     	;abs 0xd23e

0000d230 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    d230:	41 18 e2 43 	movx.b	#2,	&0x10908;r3 As==10
    d234:	08 09 

0000d236 <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    d236:	8c 01 08 09 	mova	#67848,	r12	;0x10908
    d23a:	b0 13 bc 61 	calla	#25020		;0x061bc

0000d23e <.L34>:
  OSAL_IRQ_EPILOGUE();
    d23e:	41 18 c2 43 	movx.b	#0,	&0x107da;r3 As==00
    d242:	da 07 
    d244:	b0 13 ba 47 	calla	#18362		;0x047ba

0000d248 <.LVL29>:
    d248:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d24a:	02 24       	jz	$+6      	;abs 0xd250

0000d24c <.Loc.135.1>:
    d24c:	b0 13 ca 47 	calla	#18378		;0x047ca

0000d250 <.L33>:
}
    d250:	b4 16       	popm.a	#12,	r15	;20-bit words
    d252:	00 13       	reti			
