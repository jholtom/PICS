
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	36 44       	mov	@r4+,	r6	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	3a 44       	mov	@r4+,	r10	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	3e 44       	mov	@r4+,	r14	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	42 44       	mov.b	r4,	r2	;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	46 44       	mov.b	r4,	r6	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	4a 44       	mov.b	r4,	r10	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	4e 44       	mov.b	r4,	r14	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	52 44       	mov.b,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	56 44       	mov.b,		r6	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	5a 44       	mov.b,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	5e 44       	mov.b,		r14	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	62 44       	mov.b	@r4,	r2	;

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	66 44       	mov.b	@r4,	r6	;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	6a 44       	mov.b	@r4,	r10	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	6e 44       	mov.b	@r4,	r14	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	72 44       	mov.b	@r4+,	r2	;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	76 44       	mov.b	@r4+,	r6	;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	7a 44       	mov.b	@r4+,	r10	;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	7e 44       	mov.b	@r4+,	r14	;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	82 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	86 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	8a 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	8e 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	92 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	96 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	9a 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	9e 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	a2 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	a6 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	aa 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	ae 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	b2 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	e2 a1       	dadd.b	@r1		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	62 a1       	dadd.b	@r1,	r2	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	b6 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	ba 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	e2 a0       	dadd.b	@r0		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	be 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	c2 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	66 a0       	dadd.b	@r0,	r6	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	50 a4       	interrupt service routine at 0xa450

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	c6 44       	interrupt service routine at 0x44c6

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	62 a2       	interrupt service routine at 0xa262

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	20 a3       	interrupt service routine at 0xa320

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	ca 44       	interrupt service routine at 0x44ca

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	ce 44       	interrupt service routine at 0x44ce

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	d2 44       	interrupt service routine at 0x44d2

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	d6 44       	interrupt service routine at 0x44d6

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	da 44       	interrupt service routine at 0x44da

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	de 44       	interrupt service routine at 0x44de

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	28 a0       	interrupt service routine at 0xa028

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	e2 44       	interrupt service routine at 0x44e2

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	e6 44       	interrupt service routine at 0x44e6

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	ea 44       	interrupt service routine at 0x44ea

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	81 00 32 72 	mova	#29234,	r1	;0x07232

00004404 <disable_watchdog>:


/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
    440c:	8c 00 bc 9d 	mova	#40380,	r12	;0x09dbc

00004410 <.Loc.74.1>:
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
    4412:	3e 40 6c 02 	mov	#620,	r14	;#0x026c

00004416 <.Loc.77.1>:
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
    4418:	b0 13 18 66 	calla	#26136		;0x06618

0000441c <__crt0_movedata>:
    441c:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00

00004420 <.Loc.116.1>:
    4420:	8d 00 50 9b 	mova	#39760,	r13	;0x09b50

00004424 <.Loc.119.1>:
    4424:	dd 0c       	cmpa	r12,	r13	;

00004426 <.Loc.120.1>:
    4426:	04 24       	jz	$+10     	;abs 0x4430

00004428 <.Loc.122.1>:
    4428:	8e 00 6c 02 	mova	#620,	r14	;0x0026c

0000442c <.Loc.124.1>:
    442c:	b0 13 c2 65 	calla	#26050		;0x065c2

00004430 <__crt0_call_just_main>:
    4430:	0c 43       	clr	r12		;

00004432 <.Loc.181.1>:
    4432:	b0 13 c4 63 	calla	#25540		;0x063c4

00004436 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4436:	80 00 36 44 	mova	#17462,	r0	;0x04436

0000443a <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    443a:	80 00 3a 44 	mova	#17466,	r0	;0x0443a

0000443e <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    443e:	80 00 3e 44 	mova	#17470,	r0	;0x0443e

00004442 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4442:	80 00 42 44 	mova	#17474,	r0	;0x04442

00004446 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4446:	80 00 46 44 	mova	#17478,	r0	;0x04446

0000444a <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    444a:	80 00 4a 44 	mova	#17482,	r0	;0x0444a

0000444e <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    444e:	80 00 4e 44 	mova	#17486,	r0	;0x0444e

00004452 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4452:	80 00 52 44 	mova	#17490,	r0	;0x04452

00004456 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4456:	80 00 56 44 	mova	#17494,	r0	;0x04456

0000445a <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    445a:	80 00 5a 44 	mova	#17498,	r0	;0x0445a

0000445e <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    445e:	80 00 5e 44 	mova	#17502,	r0	;0x0445e

00004462 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4462:	80 00 62 44 	mova	#17506,	r0	;0x04462

00004466 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4466:	80 00 66 44 	mova	#17510,	r0	;0x04466

0000446a <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    446a:	80 00 6a 44 	mova	#17514,	r0	;0x0446a

0000446e <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    446e:	80 00 6e 44 	mova	#17518,	r0	;0x0446e

00004472 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    4472:	80 00 72 44 	mova	#17522,	r0	;0x04472

00004476 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    4476:	80 00 76 44 	mova	#17526,	r0	;0x04476

0000447a <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    447a:	80 00 7a 44 	mova	#17530,	r0	;0x0447a

0000447e <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    447e:	80 00 7e 44 	mova	#17534,	r0	;0x0447e

00004482 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    4482:	80 00 82 44 	mova	#17538,	r0	;0x04482

00004486 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    4486:	80 00 86 44 	mova	#17542,	r0	;0x04486

0000448a <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    448a:	80 00 8a 44 	mova	#17546,	r0	;0x0448a

0000448e <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    448e:	80 00 8e 44 	mova	#17550,	r0	;0x0448e

00004492 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    4492:	80 00 92 44 	mova	#17554,	r0	;0x04492

00004496 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    4496:	80 00 96 44 	mova	#17558,	r0	;0x04496

0000449a <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    449a:	80 00 9a 44 	mova	#17562,	r0	;0x0449a

0000449e <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    449e:	80 00 9e 44 	mova	#17566,	r0	;0x0449e

000044a2 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44a2:	80 00 a2 44 	mova	#17570,	r0	;0x044a2

000044a6 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44a6:	80 00 a6 44 	mova	#17574,	r0	;0x044a6

000044aa <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44aa:	80 00 aa 44 	mova	#17578,	r0	;0x044aa

000044ae <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44ae:	80 00 ae 44 	mova	#17582,	r0	;0x044ae

000044b2 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44b2:	80 00 b2 44 	mova	#17586,	r0	;0x044b2

000044b6 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44b6:	80 00 b6 44 	mova	#17590,	r0	;0x044b6

000044ba <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44ba:	80 00 ba 44 	mova	#17594,	r0	;0x044ba

000044be <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44be:	80 00 be 44 	mova	#17598,	r0	;0x044be

000044c2 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44c2:	80 00 c2 44 	mova	#17602,	r0	;0x044c2

000044c6 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44c6:	80 00 c6 44 	mova	#17606,	r0	;0x044c6

000044ca <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    44ca:	80 00 ca 44 	mova	#17610,	r0	;0x044ca

000044ce <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44ce:	80 00 ce 44 	mova	#17614,	r0	;0x044ce

000044d2 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    44d2:	80 00 d2 44 	mova	#17618,	r0	;0x044d2

000044d6 <Vector48>:

  while (1) {
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {
    44d6:	80 00 d6 44 	mova	#17622,	r0	;0x044d6

000044da <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    44da:	80 00 da 44 	mova	#17626,	r0	;0x044da

000044de <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    44de:	80 00 de 44 	mova	#17630,	r0	;0x044de

000044e2 <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    44e2:	80 00 e2 44 	mova	#17634,	r0	;0x044e2

000044e6 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    44e6:	80 00 e6 44 	mova	#17638,	r0	;0x044e6

000044ea <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    44ea:	80 00 ea 44 	mova	#17642,	r0	;0x044ea

000044ee <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    44ee:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    44f2:	3a 1c 

000044f4 <.Loc.305.1>:
}
    44f4:	10 01       	reta			;

000044f6 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    44f6:	03 43       	nop			

000044f8 <.Loc.356.1>:
  _enable_interrupts();
    44f8:	03 43       	nop			
    44fa:	32 d2       	eint			
    44fc:	03 43       	nop			

000044fe <.Loc.357.1>:
}
    44fe:	10 01       	reta			;

00004500 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    4500:	32 c2       	dint			
    4502:	03 43       	nop			

00004504 <.Loc.390.1>:
  asm volatile("nop");
    4504:	03 43       	nop			

00004506 <.Loc.391.1>:
}
    4506:	10 01       	reta			;

00004508 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4508:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    450c:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    4510:	04 20       	jnz	$+10     	;abs 0x451a

00004512 <.Loc.79.2>:
    4512:	8c 93 0c 00 	cmp	#0,	12(r12)	;r3 As==00, 0x000c
    4516:	01 20       	jnz	$+4      	;abs 0x451a

00004518 <.Loc.82.2>:
    chSysHalt("SV#2");
  }
}
    4518:	10 01       	reta			;

0000451a <.L8>:
    chSysHalt("SV#2");
    451a:	8c 00 37 72 	mova	#29239,	r12	;0x07237
    451e:	b0 13 72 47 	calla	#18290		;0x04772

00004522 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4522:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4526:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    452a:	07 20       	jnz	$+16     	;abs 0x453a

0000452c <.Loc.103.2>:
    452c:	8c 93 0c 00 	cmp	#0,	12(r12)	;r3 As==00, 0x000c
    4530:	04 20       	jnz	$+10     	;abs 0x453a

00004532 <.Loc.106.2>:
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
    4532:	40 18 92 43 	movx.w	#1,	&0x01c0c;r3 As==01
    4536:	0c 1c 

00004538 <.Loc.107.2>:
}
    4538:	10 01       	reta			;

0000453a <.L14>:
    chSysHalt("SV#4");
    453a:	8c 00 41 72 	mova	#29249,	r12	;0x07241
    453e:	b0 13 72 47 	calla	#18290		;0x04772

00004542 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4542:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4546:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    454a:	08 20       	jnz	$+18     	;abs 0x455c

0000454c <.Loc.116.2>:
    454c:	4d 43       	clr.b	r13		;
    454e:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4552:	04 34       	jge	$+10     	;abs 0x455c

00004554 <.Loc.119.2>:
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
    4554:	40 18 82 43 	movx.w	#0,	&0x01c0c;r3 As==00
    4558:	0c 1c 

0000455a <.Loc.120.2>:
}
    455a:	10 01       	reta			;

0000455c <.L17>:
    chSysHalt("SV#5");
    455c:	8c 00 46 72 	mova	#29254,	r12	;0x07246
    4560:	b0 13 72 47 	calla	#18290		;0x04772

00004564 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4564:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4568:	4d 43       	clr.b	r13		;
    456a:	1d 9c 0a 00 	cmp	10(r12),r13	;0x0000a
    456e:	07 34       	jge	$+16     	;abs 0x457e

00004570 <.Loc.129.2>:
    4570:	8c 9d 0c 00 	cmp	r13,	12(r12)	; 0x000c
    4574:	04 20       	jnz	$+10     	;abs 0x457e

00004576 <.Loc.132.2>:
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
    4576:	40 18 92 43 	movx.w	#1,	&0x01c0c;r3 As==01
    457a:	0c 1c 

0000457c <.Loc.133.2>:
}
    457c:	10 01       	reta			;

0000457e <.L20>:
    chSysHalt("SV#6");
    457e:	8c 00 4b 72 	mova	#29259,	r12	;0x0724b
    4582:	b0 13 72 47 	calla	#18290		;0x04772

00004586 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4586:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    458a:	4d 43       	clr.b	r13		;
    458c:	1d 9c 0a 00 	cmp	10(r12),r13	;0x0000a
    4590:	07 34       	jge	$+16     	;abs 0x45a0

00004592 <.Loc.142.2>:
    4592:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4596:	04 34       	jge	$+10     	;abs 0x45a0

00004598 <.Loc.145.2>:
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
    4598:	40 18 82 43 	movx.w	#0,	&0x01c0c;r3 As==00
    459c:	0c 1c 

0000459e <.Loc.146.2>:
}
    459e:	10 01       	reta			;

000045a0 <.L23>:
    chSysHalt("SV#7");
    45a0:	8c 00 50 72 	mova	#29264,	r12	;0x07250
    45a4:	b0 13 72 47 	calla	#18290		;0x04772

000045a8 <_dbg_check_enter_isr>:
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45a8:	40 18 1c 42 	movx.w	&0x01c0a,r12	;
    45ac:	0a 1c 
    45ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    45b0:	0a 38       	jl	$+22     	;abs 0x45c6

000045b2 <.Loc.156.2>:
    45b2:	8e 00 00 1c 	mova	#7168,	r14	;0x01c00
    45b6:	8e 93 0c 00 	cmp	#0,	12(r14)	;r3 As==00, 0x000c
    45ba:	05 20       	jnz	$+12     	;abs 0x45c6

000045bc <.Loc.159.2>:
    chSysHalt("SV#8");
  }
  nil.isr_cnt++;
    45bc:	1c 53       	inc	r12		;
    45be:	40 18 82 4c 	movx.w	r12,	&0x01c0a;
    45c2:	0a 1c 

000045c4 <.Loc.161.2>:
  port_unlock_from_isr();
}
    45c4:	10 01       	reta			;

000045c6 <.L26>:
    chSysHalt("SV#8");
    45c6:	8c 00 55 72 	mova	#29269,	r12	;0x07255
    45ca:	b0 13 72 47 	calla	#18290		;0x04772

000045ce <_dbg_check_leave_isr>:
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45ce:	40 18 1c 42 	movx.w	&0x01c0a,r12	;
    45d2:	0a 1c 
    45d4:	4d 43       	clr.b	r13		;
    45d6:	0d 9c       	cmp	r12,	r13	;
    45d8:	0a 34       	jge	$+22     	;abs 0x45ee

000045da <.Loc.171.2>:
    45da:	8e 00 00 1c 	mova	#7168,	r14	;0x01c00
    45de:	8e 9d 0c 00 	cmp	r13,	12(r14)	; 0x000c
    45e2:	05 20       	jnz	$+12     	;abs 0x45ee

000045e4 <.Loc.174.2>:
    chSysHalt("SV#9");
  }
  nil.isr_cnt--;
    45e4:	3c 53       	add	#-1,	r12	;r3 As==11
    45e6:	40 18 82 4c 	movx.w	r12,	&0x01c0a;
    45ea:	0a 1c 

000045ec <.Loc.176.2>:
  port_unlock_from_isr();
}
    45ec:	10 01       	reta			;

000045ee <.L29>:
    chSysHalt("SV#9");
    45ee:	8c 00 5a 72 	mova	#29274,	r12	;0x0725a
    45f2:	b0 13 72 47 	calla	#18290		;0x04772

000045f6 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    45f6:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    45fa:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    45fe:	05 38       	jl	$+12     	;abs 0x460a

00004600 <.Loc.188.2>:
    4600:	4d 43       	clr.b	r13		;
    4602:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4606:	01 34       	jge	$+4      	;abs 0x460a

00004608 <.Loc.191.2>:
    chSysHalt("SV#10");
  }
}
    4608:	10 01       	reta			;

0000460a <.L32>:
    chSysHalt("SV#10");
    460a:	8c 00 5f 72 	mova	#29279,	r12	;0x0725f
    460e:	b0 13 72 47 	calla	#18290		;0x04772

00004612 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4612:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4616:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    461a:	05 20       	jnz	$+12     	;abs 0x4626

0000461c <.Loc.203.2>:
    461c:	4d 43       	clr.b	r13		;
    461e:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4622:	01 34       	jge	$+4      	;abs 0x4626

00004624 <.Loc.206.2>:
    chSysHalt("SV#11");
  }
}
    4624:	10 01       	reta			;

00004626 <.L35>:
    chSysHalt("SV#11");
    4626:	8c 00 65 72 	mova	#29285,	r12	;0x07265
    462a:	b0 13 72 47 	calla	#18290		;0x04772

0000462e <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    462e:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004632 <.LCFI0>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    4632:	40 18 82 43 	movx.w	#0,	&0x01c0a;r3 As==00
    4636:	0a 1c 

00004638 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    4638:	40 18 82 43 	movx.w	#0,	&0x01c0c;r3 As==00
    463c:	0c 1c 

0000463e <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    463e:	00 18 f1 40 	movx.a	#7186,	16(r1)	;0x01c12, 0x00010
    4642:	12 1c 10 00 

00004646 <.Loc.234.2>:
  tcp = nil_thd_configs;
    4646:	00 18 f1 40 	movx.a	#30014,	12(r1)	;0x0753e, 0x0000c
    464a:	3e 75 0c 00 

0000464e <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    464e:	80 00 1a 47 	mova	#18202,	r0	;0x0471a

00004652 <.L39>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    4652:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    4656:	0d 0c       	mova	@r12,	r13	;
    4658:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    465c:	7c 0d 10 00 	mova	r13,	16(r12)	; 0x00010

00004660 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4660:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    4664:	3c 0c 04 00 	mova	4(r12),	r12	;
    4668:	cd 0c       	mova	r12,	r13	;
    466a:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    466e:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4672:	7c 0d 00 00 	mova	r13,	0(r12)	;
    4676:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    467a:	0c 0c       	mova	@r12,	r12	;
    467c:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    4680:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    4684:	71 0d 08 00 	mova	r13,	8(r1)	;
    4688:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    468c:	00 00 
    468e:	3e 01 08 00 	mova	8(r1),	r14	;
    4692:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4694:	0d 17       	popm	#1,	r13	;16-bit words
    4696:	0d 17       	popm	#1,	r13	;16-bit words
    4698:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    469c:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    46a0:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    46a4:	4d de       	bis.b	r14,	r13	;
    46a6:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    46aa:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46ae:	0c 0c       	mova	@r12,	r12	;
    46b0:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    46b4:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    46b8:	71 0d 04 00 	mova	r13,	4(r1)	;
    46bc:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    46c0:	04 00 
    46c2:	3e 01 04 00 	mova	4(r1),	r14	;
    46c6:	0e 14       	pushm.a	#1,	r14	;20-bit words
    46c8:	0d 17       	popm	#1,	r13	;16-bit words
    46ca:	0d 17       	popm	#1,	r13	;16-bit words
    46cc:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    46d0:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    46d4:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    46d8:	4d de       	bis.b	r14,	r13	;
    46da:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    46de:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46e2:	0c 0c       	mova	@r12,	r12	;
    46e4:	00 18 f1 40 	movx.a	#19686,	0(r1)	;0x04ce6
    46e8:	e6 4c 00 00 
    46ec:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    46f0:	0e 01       	mova	@r1,	r14	;
    46f2:	0e 14       	pushm.a	#1,	r14	;20-bit words
    46f4:	0d 17       	popm	#1,	r13	;16-bit words
    46f6:	0d 17       	popm	#1,	r13	;16-bit words
    46f8:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    46fc:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    4700:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4704:	4d de       	bis.b	r14,	r13	;
    4706:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

0000470a <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    470a:	00 18 f1 50 	addx.a	#20,	16(r1)	;0x00014, 0x00010
    470e:	14 00 10 00 

00004712 <.Loc.247.2>:
    tcp++;
    4712:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    4716:	14 00 0c 00 

0000471a <.L38>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    471a:	00 18 f1 90 	cmpx.a	#7206,	16(r1)	;0x01c26, 0x00010
    471e:	26 1c 10 00 
    4722:	97 2b       	jnc	$-208    	;abs 0x4652

00004724 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    4724:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4728:	00 18 fc 40 	movx.a	#29234,	16(r12)	;0x07232, 0x00010
    472c:	32 72 10 00 

00004730 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    4730:	b0 13 00 45 	calla	#17664		;0x04500

00004734 <.LVL15>:
    4734:	b0 13 08 45 	calla	#17672		;0x04508

00004738 <.LVL16>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    4738:	40 18 92 43 	movx.w	#1,	&0x01c0c;r3 As==01
    473c:	0c 1c 

0000473e <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    473e:	b0 13 18 4c 	calla	#19480		;0x04c18

00004742 <.LVL17>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    4742:	b0 13 ee 44 	calla	#17646		;0x044ee

00004746 <.LVL18>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4746:	00 18 f2 40 	movx.a	#7186,	&0x01c04;0x01c12
    474a:	12 1c 04 1c 
    474e:	2c 00 04 1c 	mova	&7172,	r12	;0x01c04
    4752:	60 0c 00 1c 	mova	r12,	&7168	; 0x01c00

00004756 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4756:	2c 00 00 1c 	mova	&7168,	r12	;0x01c00
    475a:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    475e:	b0 13 da 4c 	calla	#19674		;0x04cda

00004762 <.LVL19>:
  chSysUnlock();
    4762:	b0 13 42 45 	calla	#17730		;0x04542

00004766 <.LVL20>:
    4766:	b0 13 f6 44 	calla	#17654		;0x044f6

0000476a <.LVL21>:
}
    476a:	03 43       	nop			
    476c:	a1 00 14 00 	adda	#20,	r1	;0x00014
    4770:	10 01       	reta			;

00004772 <chSysHalt>:
  _disable_interrupts();
    4772:	32 c2       	dint			
    4774:	03 43       	nop			

00004776 <.Loc.381.1>:
  asm volatile("nop");
    4776:	03 43       	nop			

00004778 <.LBE81>:
void chSysHalt(const char *reason) {

  port_disable();

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4778:	60 0c 0e 1c 	mova	r12,	&7182	; 0x01c0e

0000477c <.L41>:
    477c:	80 00 7c 47 	mova	#18300,	r0	;0x0477c

00004780 <chSysTimerHandlerI>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    4780:	b0 13 f6 45 	calla	#17910		;0x045f6

00004784 <.LVL23>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    4784:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4788:	9c 53 08 00 	inc	8(r12)		;

0000478c <.Loc.325.2>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    478c:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    4790:	0c 93       	cmp	#0,	r12	;r3 As==00
    4792:	19 24       	jz	$+52     	;abs 0x47c6

00004794 <.Loc.327.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    4794:	40 18 5c 42 	movx.b	&0x01c16,r12	;
    4798:	16 1c 
    479a:	0c 93       	cmp	#0,	r12	;r3 As==00
    479c:	19 24       	jz	$+52     	;abs 0x47d0

0000479e <.Loc.330.2>:

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    479e:	8e 00 00 1c 	mova	#7168,	r14	;0x01c00
    47a2:	1d 4e 1c 00 	mov	28(r14),r13	;0x0001c
    47a6:	3d 53       	add	#-1,	r13	;r3 As==11
    47a8:	8e 4d 1c 00 	mov	r13,	28(r14)	; 0x001c
    47ac:	0d 93       	cmp	#0,	r13	;r3 As==00
    47ae:	0b 20       	jnz	$+24     	;abs 0x47c6

000047b0 <.Loc.334.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    47b0:	3c 90 03 00 	cmp	#3,	r12	;
    47b4:	11 24       	jz	$+36     	;abs 0x47d8

000047b6 <.Loc.337.2>:
          tp->u1.semp->cnt++;
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    47b6:	2c 93       	cmp	#2,	r12	;r3 As==10
    47b8:	15 24       	jz	$+44     	;abs 0x47e4

000047ba <.L46>:
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    47ba:	8d 0f ff ff 	mova	#-1,	r13	;0xffffffff
    47be:	8c 00 12 1c 	mova	#7186,	r12	;0x01c12

000047c2 <.LVL24>:
    47c2:	b0 13 44 48 	calla	#18500		;0x04844

000047c6 <.L43>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    47c6:	b0 13 86 45 	calla	#17798		;0x04586

000047ca <.LVL26>:
    tp++;
    chSysLockFromISR();
    47ca:	b0 13 64 45 	calla	#17764		;0x04564

000047ce <.LVL27>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    47ce:	10 01       	reta			;

000047d0 <.L47>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    47d0:	8c 00 6b 72 	mova	#29291,	r12	;0x0726b
    47d4:	b0 13 72 47 	calla	#18290		;0x04772

000047d8 <.L48>:
          tp->u1.semp->cnt++;
    47d8:	2c 00 18 1c 	mova	&7192,	r12	;0x01c18
    47dc:	9c 53 00 00 	inc	0(r12)		;
    47e0:	80 00 ba 47 	mova	#18362,	r0	;0x047ba

000047e4 <.L49>:
          *tp->u1.trp = NULL;
    47e4:	2c 00 18 1c 	mova	&7192,	r12	;0x01c18
    47e8:	00 18 cc 43 	movx.a	#0,	0(r12)	;r3 As==00
    47ec:	00 00 
    47ee:	80 00 ba 47 	mova	#18362,	r0	;0x047ba

000047f2 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    47f2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047f4 <.LBB91>:
  return __get_SR_register();
    47f4:	0a 42       	mov	r2,	r10	;

000047f6 <.LBE91>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    47f6:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    47fa:	09 24       	jz	$+20     	;abs 0x480e

000047fc <.Loc.450.2>:
    if (port_is_isr_context()) {
    47fc:	40 18 c2 93 	cmpx.b	#0,	&0x01c3a;r3 As==00
    4800:	3a 1c 
    4802:	08 20       	jnz	$+18     	;abs 0x4814

00004804 <.LBB93>:
  _disable_interrupts();
    4804:	32 c2       	dint			
    4806:	03 43       	nop			

00004808 <.Loc.348.1>:
  asm volatile("nop");
    4808:	03 43       	nop			

0000480a <.LBE93>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    480a:	b0 13 22 45 	calla	#17698		;0x04522

0000480e <.L57>:
    }
  }
  return sts;
}
    480e:	0c 4a       	mov	r10,	r12	;
    4810:	0a 16       	popm.a	#1,	r10	;20-bit words
    4812:	10 01       	reta			;

00004814 <.L59>:
      chSysLockFromISR();
    4814:	b0 13 64 45 	calla	#17764		;0x04564

00004818 <.LVL33>:
    4818:	80 00 0e 48 	mova	#18446,	r0	;0x0480e

0000481c <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    481c:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    4820:	0c 24       	jz	$+26     	;abs 0x483a

00004822 <.Loc.472.2>:
    if (port_is_isr_context()) {
    4822:	40 18 c2 93 	cmpx.b	#0,	&0x01c3a;r3 As==00
    4826:	3a 1c 
    4828:	09 20       	jnz	$+20     	;abs 0x483c

0000482a <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    482a:	b0 13 e4 48 	calla	#18660		;0x048e4

0000482e <.LVL35>:
      chSysUnlock();
    482e:	b0 13 42 45 	calla	#17730		;0x04542

00004832 <.LBB95>:
  asm volatile("nop");
    4832:	03 43       	nop			

00004834 <.Loc.356.1>:
  _enable_interrupts();
    4834:	03 43       	nop			
    4836:	32 d2       	eint			
    4838:	03 43       	nop			

0000483a <.L60>:
    }
  }
}
    483a:	10 01       	reta			;

0000483c <.L63>:
      chSysUnlockFromISR();
    483c:	b0 13 86 45 	calla	#17798		;0x04586

00004840 <.LVL38>:
    4840:	80 00 3a 48 	mova	#18490,	r0	;0x0483a

00004844 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    4844:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004846 <.LCFI2>:
    4846:	b1 00 04 00 	suba	#4,	r1	;

0000484a <.LCFI3>:
    484a:	ca 0c       	mova	r12,	r10	;
    484c:	71 0d 00 00 	mova	r13,	0(r1)	;

00004850 <.Loc.536.2>:

  chDbgCheckClassI();
    4850:	b0 13 f6 45 	calla	#17910		;0x045f6

00004854 <.LVL40>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    4854:	ca 93 04 00 	cmp.b	#0,	4(r10)	;r3 As==00
    4858:	27 24       	jz	$+80     	;abs 0x48a8

0000485a <.Loc.539.2>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    485a:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    485e:	00 18 dc 9c 	cmpx.a	4(r12),	0(r12)	;
    4862:	04 00 00 00 
    4866:	24 28       	jnc	$+74     	;abs 0x48b0

00004868 <.Loc.541.2>:

  tp->u1.msg = msg;
    4868:	aa 41 06 00 	mov	@r1,	6(r10)	;
    486c:	0d 01       	mova	@r1,	r13	;
    486e:	0d 14       	pushm.a	#1,	r13	;20-bit words
    4870:	0c 17       	popm	#1,	r12	;16-bit words
    4872:	0c 17       	popm	#1,	r12	;16-bit words
    4874:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4878:	5d 4a 08 00 	mov.b	8(r10),	r13	;
    487c:	7d f0 f0 ff 	and.b	#-16,	r13	;#0xfff0
    4880:	4d dc       	bis.b	r12,	r13	;
    4882:	ca 4d 08 00 	mov.b	r13,	8(r10)	;

00004886 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    4886:	ca 43 04 00 	mov.b	#0,	4(r10)	;r3 As==00

0000488a <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    488a:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000488e <.Loc.544.2>:
  if (tp < nil.next) {
    488e:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    4892:	00 18 5a 9c 	cmpx.a	4(r12),	r10	;
    4896:	04 00 
    4898:	02 2c       	jc	$+6      	;abs 0x489e

0000489a <.Loc.545.2>:
    nil.next = tp;
    489a:	60 0a 04 1c 	mova	r10,	&7172	; 0x01c04

0000489e <.L67>:
  }
  return tp;
}
    489e:	cc 0a       	mova	r10,	r12	;
    48a0:	a1 00 04 00 	adda	#4,	r1	;

000048a4 <.LVL41>:
    48a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    48a6:	10 01       	reta			;

000048a8 <.L68>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    48a8:	8c 00 7e 72 	mova	#29310,	r12	;0x0727e
    48ac:	b0 13 72 47 	calla	#18290		;0x04772

000048b0 <.L69>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    48b0:	8c 00 7e 72 	mova	#29310,	r12	;0x0727e
    48b4:	b0 13 72 47 	calla	#18290		;0x04772

000048b8 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    48b8:	8e 00 00 1c 	mova	#7168,	r14	;0x01c00
    48bc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    48be:	00 18 de 9e 	cmpx.a	4(r14),	0(r14)	;
    48c2:	04 00 00 00 
    48c6:	01 24       	jz	$+4      	;abs 0x48ca

000048c8 <.L71>:
}
    48c8:	10 01       	reta			;

000048ca <.L72>:
  return chSchIsRescRequiredI();
    48ca:	4c 43       	clr.b	r12		;
    48cc:	80 00 c8 48 	mova	#18632,	r0	;0x048c8

000048d0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    48d0:	8e 00 00 1c 	mova	#7168,	r14	;0x01c00
    48d4:	0d 0e       	mova	@r14,	r13	;

000048d6 <.LVL45>:

  nil.current = nil.next;
    48d6:	3c 0e 04 00 	mova	4(r14),	r12	;
    48da:	7e 0c 00 00 	mova	r12,	0(r14)	;

000048de <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    48de:	b0 13 da 4c 	calla	#19674		;0x04cda

000048e2 <.LVL46>:
}
    48e2:	10 01       	reta			;

000048e4 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    48e4:	b0 13 12 46 	calla	#17938		;0x04612

000048e8 <.LVL47>:

  if (chSchIsRescRequiredI()) {
    48e8:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    48ec:	00 18 dc 9c 	cmpx.a	4(r12),	0(r12)	;
    48f0:	04 00 00 00 
    48f4:	02 24       	jz	$+6      	;abs 0x48fa

000048f6 <.Loc.595.2>:
    chSchDoReschedule();
    48f6:	b0 13 d0 48 	calla	#18640		;0x048d0

000048fa <.L74>:
  }
}
    48fa:	10 01       	reta			;

000048fc <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    48fc:	2a 14       	pushm.a	#3,	r10	;20-bit words

000048fe <.LCFI4>:
    48fe:	49 4c       	mov.b	r12,	r9	;
    4900:	08 4d       	mov	r13,	r8	;

00004902 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    4902:	2a 00 00 1c 	mova	&7168,	r10	;0x01c00

00004906 <.Loc.619.2>:

  chDbgCheckClassS();
    4906:	b0 13 12 46 	calla	#17938		;0x04612

0000490a <.LVL51>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    490a:	9a 00 26 1c 	cmpa	#7206,	r10	;0x01c26
    490e:	13 24       	jz	$+40     	;abs 0x4936

00004910 <.Loc.625.2>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    4910:	ca 49 04 00 	mov.b	r9,	4(r10)	;

00004914 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    4914:	8a 48 0a 00 	mov	r8,	10(r10)	; 0x000a

00004918 <.LVL52>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    4918:	8c 00 12 1c 	mova	#7186,	r12	;0x01c12

0000491c <.L79>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    491c:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    4920:	0e 24       	jz	$+30     	;abs 0x493e

00004922 <.Loc.677.2>:
      port_switch(ntp, otp);
      return nil.current->u1.msg;
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    4922:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004926 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    4926:	8d 00 26 1c 	mova	#7206,	r13	;0x01c26
    492a:	dd 0c       	cmpa	r12,	r13	;
    492c:	f7 2f       	jc	$-16     	;abs 0x491c

0000492e <.Loc.678.2>:
    492e:	8c 00 8a 72 	mova	#29322,	r12	;0x0728a

00004932 <.LVL55>:
    4932:	b0 13 72 47 	calla	#18290		;0x04772

00004936 <.L81>:
  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    4936:	8c 00 8a 72 	mova	#29322,	r12	;0x0728a
    493a:	b0 13 72 47 	calla	#18290		;0x04772

0000493e <.L82>:
      nil.current = nil.next = ntp;
    493e:	88 00 00 1c 	mova	#7168,	r8	;0x01c00

00004942 <.LVL58>:
    4942:	78 0c 04 00 	mova	r12,	4(r8)	;
    4946:	78 0c 00 00 	mova	r12,	0(r8)	;

0000494a <.Loc.672.2>:
      port_switch(ntp, otp);
    494a:	cd 0a       	mova	r10,	r13	;
    494c:	b0 13 da 4c 	calla	#19674		;0x04cda

00004950 <.LVL59>:
      return nil.current->u1.msg;
    4950:	0c 08       	mova	@r8,	r12	;
    4952:	3c 0c 06 00 	mova	6(r12),	r12	;

00004956 <.Loc.681.2>:
                "pointer out of range");
  }
}
    4956:	28 16       	popm.a	#3,	r10	;20-bit words
    4958:	10 01       	reta			;

0000495a <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    495a:	0e 0c       	mova	@r12,	r14	;
    495c:	9e 00 00 00 	cmpa	#0,	r14	;
    4960:	09 24       	jz	$+20     	;abs 0x4974

00004962 <.LBB97>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4962:	ee 93 04 00 	cmp.b	#2,	4(r14)	;r3 As==10
    4966:	07 20       	jnz	$+16     	;abs 0x4976

00004968 <.Loc.723.2>:

    *trp = NULL;
    4968:	00 18 cc 43 	movx.a	#0,	0(r12)	;r3 As==00
    496c:	00 00 

0000496e <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    496e:	cc 0e       	mova	r14,	r12	;

00004970 <.LVL68>:
    4970:	b0 13 44 48 	calla	#18500		;0x04844

00004974 <.L86>:
  }
}
    4974:	10 01       	reta			;

00004976 <.L89>:
    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    4976:	8c 00 b4 72 	mova	#29364,	r12	;0x072b4

0000497a <.LVL71>:
    497a:	b0 13 72 47 	calla	#18290		;0x04772

0000497e <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    497e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004980 <.LCFI8>:
    4980:	ca 0c       	mova	r12,	r10	;
    4982:	09 4d       	mov	r13,	r9	;

00004984 <.Loc.808.2>:

  chDbgCheckClassS();
    4984:	b0 13 12 46 	calla	#17938		;0x04612

00004988 <.LVL88>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    4988:	2c 4a       	mov	@r10,	r12	;

0000498a <.LVL89>:
  if (cnt <= (cnt_t)0) {
    498a:	4d 43       	clr.b	r13		;
    498c:	0d 9c       	cmp	r12,	r13	;
    498e:	06 34       	jge	$+14     	;abs 0x499c

00004990 <.Loc.822.2>:
    }
    sp->cnt = cnt - (cnt_t)1;
    nil.current->u1.semp = sp;
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
  }
  sp->cnt = cnt - (cnt_t)1;
    4990:	3c 53       	add	#-1,	r12	;r3 As==11

00004992 <.LVL90>:
    4992:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004996 <.Loc.823.2>:
  return MSG_OK;
    4996:	4c 43       	clr.b	r12		;

00004998 <.L93>:
}
    4998:	19 16       	popm.a	#2,	r10	;20-bit words
    499a:	10 01       	reta			;

0000499c <.L97>:
    if (TIME_IMMEDIATE == timeout) {
    499c:	39 93       	cmp	#-1,	r9	;r3 As==11
    499e:	0e 24       	jz	$+30     	;abs 0x49bc

000049a0 <.Loc.818.2>:
    sp->cnt = cnt - (cnt_t)1;
    49a0:	3c 53       	add	#-1,	r12	;r3 As==11

000049a2 <.LVL93>:
    49a2:	8a 4c 00 00 	mov	r12,	0(r10)	;

000049a6 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    49a6:	2c 00 00 1c 	mova	&7168,	r12	;0x01c00

000049aa <.LVL94>:
    49aa:	7c 0a 06 00 	mova	r10,	6(r12)	;

000049ae <.LVL95>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    49ae:	0d 49       	mov	r9,	r13	;
    49b0:	7c 40 03 00 	mov.b	#3,	r12	;
    49b4:	b0 13 fc 48 	calla	#18684		;0x048fc

000049b8 <.LVL96>:
    49b8:	80 00 98 49 	mova	#18840,	r0	;0x04998

000049bc <.L96>:
      return MSG_TIMEOUT;
    49bc:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000049c0 <.LVL98>:
    49c0:	80 00 98 49 	mova	#18840,	r0	;0x04998

000049c4 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    49c4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000049c6 <.LCFI10>:
    49c6:	ca 0c       	mova	r12,	r10	;

000049c8 <.Loc.854.2>:

  chDbgCheckClassI();
    49c8:	b0 13 f6 45 	calla	#17910		;0x045f6

000049cc <.LVL105>:
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    49cc:	2c 4a       	mov	@r10,	r12	;
    49ce:	1c 53       	inc	r12		;
    49d0:	8a 4c 00 00 	mov	r12,	0(r10)	;
    49d4:	4d 43       	clr.b	r13		;
    49d6:	0d 9c       	cmp	r12,	r13	;
    49d8:	02 34       	jge	$+6      	;abs 0x49de

000049da <.L99>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    49da:	0a 16       	popm.a	#1,	r10	;20-bit words
    49dc:	10 01       	reta			;

000049de <.L103>:
      if (tr->u1.semp == sp) {
    49de:	8c 00 00 1c 	mova	#7168,	r12	;0x01c00
    49e2:	00 18 5a 9c 	cmpx.a	24(r12),r10	;0x00018
    49e6:	18 00 
    49e8:	0f 20       	jnz	$+32     	;abs 0x4a08

000049ea <.Loc.863.2>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    49ea:	fc 90 03 00 	cmp.b	#3,	22(r12)	; 0x0016
    49ee:	16 00 
    49f0:	07 20       	jnz	$+16     	;abs 0x4a00

000049f2 <.Loc.865.2>:
        (void) chSchReadyI(tr, MSG_OK);
    49f2:	4d 43       	clr.b	r13		;
    49f4:	8c 00 12 1c 	mova	#7186,	r12	;0x01c12

000049f8 <.LVL107>:
    49f8:	b0 13 44 48 	calla	#18500		;0x04844

000049fc <.LVL108>:
        return;
    49fc:	80 00 da 49 	mova	#18906,	r0	;0x049da

00004a00 <.L104>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4a00:	8c 00 c1 72 	mova	#29377,	r12	;0x072c1
    4a04:	b0 13 72 47 	calla	#18290		;0x04772

00004a08 <.L101>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    4a08:	8c 00 c1 72 	mova	#29377,	r12	;0x072c1
    4a0c:	b0 13 72 47 	calla	#18290		;0x04772

00004a10 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    4a10:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004a12 <.LCFI14>:
    4a12:	ca 0c       	mova	r12,	r10	;
    4a14:	09 4d       	mov	r13,	r9	;
    4a16:	08 4e       	mov	r14,	r8	;

00004a18 <.Loc.971.2>:

  chDbgCheckClassI();
    4a18:	b0 13 f6 45 	calla	#17910		;0x045f6

00004a1c <.LVL132>:
  chDbgCheck(tp != NULL);

  tp->epmask |= mask;
    4a1c:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    4a20:	0d d9       	bis	r9,	r13	;
    4a22:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    4a26:	0e d8       	bis	r8,	r14	;
    4a28:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    4a2c:	8a 4e 0e 00 	mov	r14,	14(r10)	; 0x000e

00004a30 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4a30:	ea 92 04 00 	cmp.b	#4,	4(r10)	;r2 As==10
    4a34:	02 24       	jz	$+6      	;abs 0x4a3a

00004a36 <.L116>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    (void) chSchReadyI(tp, MSG_OK);
  }
}
    4a36:	28 16       	popm.a	#3,	r10	;20-bit words
    4a38:	10 01       	reta			;

00004a3a <.L119>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4a3a:	1d fa 06 00 	and	6(r10),	r13	;
    4a3e:	1e fa 08 00 	and	8(r10),	r14	;

00004a42 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4a42:	0c 4d       	mov	r13,	r12	;
    4a44:	0c de       	bis	r14,	r12	;
    4a46:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a48:	f6 27       	jz	$-18     	;abs 0x4a36

00004a4a <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    4a4a:	4d 43       	clr.b	r13		;
    4a4c:	cc 0a       	mova	r10,	r12	;
    4a4e:	b0 13 44 48 	calla	#18500		;0x04844

00004a52 <.LVL133>:
}
    4a52:	80 00 36 4a 	mova	#18998,	r0	;0x04a36

00004a56 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    4a56:	5a 14       	pushm.a	#6,	r10	;20-bit words

00004a58 <.LCFI15>:
    4a58:	06 4c       	mov	r12,	r6	;
    4a5a:	07 4d       	mov	r13,	r7	;
    4a5c:	05 4e       	mov	r14,	r5	;

00004a5e <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    4a5e:	2a 00 00 1c 	mova	&7168,	r10	;0x01c00

00004a62 <.LBB124>:
  _disable_interrupts();
    4a62:	32 c2       	dint			
    4a64:	03 43       	nop			

00004a66 <.Loc.348.1>:
  asm volatile("nop");
    4a66:	03 43       	nop			

00004a68 <.LBE124>:
  eventmask_t m;

  chSysLock();
    4a68:	b0 13 22 45 	calla	#17698		;0x04522

00004a6c <.LVL136>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    4a6c:	19 4a 0c 00 	mov	12(r10),r9	;0x0000c
    4a70:	09 f6       	and	r6,	r9	;
    4a72:	18 4a 0e 00 	mov	14(r10),r8	;0x0000e
    4a76:	08 f7       	and	r7,	r8	;

00004a78 <.LVL137>:
    4a78:	0c 49       	mov	r9,	r12	;
    4a7a:	0c d8       	bis	r8,	r12	;
    4a7c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a7e:	13 20       	jnz	$+40     	;abs 0x4aa6

00004a80 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4a80:	35 93       	cmp	#-1,	r5	;r3 As==11
    4a82:	1f 24       	jz	$+64     	;abs 0x4ac2

00004a84 <.Loc.1010.2>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    4a84:	8a 46 06 00 	mov	r6,	6(r10)	;
    4a88:	8a 47 08 00 	mov	r7,	8(r10)	;

00004a8c <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4a8c:	0d 45       	mov	r5,	r13	;
    4a8e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4a90:	b0 13 fc 48 	calla	#18684		;0x048fc

00004a94 <.LVL138>:
    4a94:	9c 00 00 00 	cmpa	#0,	r12	;
    4a98:	1c 38       	jl	$+58     	;abs 0x4ad2

00004a9a <.Loc.1016.2>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    4a9a:	09 46       	mov	r6,	r9	;

00004a9c <.LVL139>:
    4a9c:	19 fa 0c 00 	and	12(r10),r9	;0x0000c
    4aa0:	08 47       	mov	r7,	r8	;
    4aa2:	18 fa 0e 00 	and	14(r10),r8	;0x0000e

00004aa6 <.L121>:
  }
  ctp->epmask &= ~m;
    4aa6:	8a c9 0c 00 	bic	r9,	12(r10)	; 0x000c
    4aaa:	8a c8 0e 00 	bic	r8,	14(r10)	; 0x000e

00004aae <.Loc.1019.2>:
  chSysUnlock();
    4aae:	b0 13 42 45 	calla	#17730		;0x04542

00004ab2 <.LBB126>:
  asm volatile("nop");
    4ab2:	03 43       	nop			

00004ab4 <.Loc.356.1>:
  _enable_interrupts();
    4ab4:	03 43       	nop			
    4ab6:	32 d2       	eint			
    4ab8:	03 43       	nop			

00004aba <.L120>:

  return m;
}
    4aba:	0c 49       	mov	r9,	r12	;
    4abc:	0d 48       	mov	r8,	r13	;
    4abe:	55 16       	popm.a	#6,	r10	;20-bit words
    4ac0:	10 01       	reta			;

00004ac2 <.L125>:
      chSysUnlock();
    4ac2:	b0 13 42 45 	calla	#17730		;0x04542

00004ac6 <.LBB128>:
  asm volatile("nop");
    4ac6:	03 43       	nop			

00004ac8 <.Loc.356.1>:
  _enable_interrupts();
    4ac8:	03 43       	nop			
    4aca:	32 d2       	eint			
    4acc:	03 43       	nop			

00004ace <.LBE128>:
      return (eventmask_t)0;
    4ace:	80 00 ba 4a 	mova	#19130,	r0	;0x04aba

00004ad2 <.L126>:
      chSysUnlock();
    4ad2:	b0 13 42 45 	calla	#17730		;0x04542

00004ad6 <.LBB130>:
  asm volatile("nop");
    4ad6:	03 43       	nop			

00004ad8 <.Loc.356.1>:
  _enable_interrupts();
    4ad8:	03 43       	nop			
    4ada:	32 d2       	eint			
    4adc:	03 43       	nop			

00004ade <.LBE130>:
      return (eventmask_t)0;
    4ade:	80 00 ba 4a 	mova	#19130,	r0	;0x04aba

00004ae2 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4ae2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ae4 <.LCFI6>:
    4ae4:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ae6 <.LCFI7>:
    4ae6:	06 14       	pushm.a	#1,	r6	;20-bit words

00004ae8 <.LCFI8>:
    4ae8:	ca 0c       	mova	r12,	r10	;
    4aea:	c6 0d       	mova	r13,	r6	;
    4aec:	08 4e       	mov	r14,	r8	;

00004aee <.Loc.187.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4aee:	b0 13 12 46 	calla	#17938		;0x04612

00004af2 <.LVL11>:
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4af2:	0d 48       	mov	r8,	r13	;
    4af4:	cc 0a       	mova	r10,	r12	;
    4af6:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4afa:	b0 13 7e 49 	calla	#18814		;0x0497e

00004afe <.LVL12>:
    4afe:	c8 0c       	mova	r12,	r8	;

00004b00 <.LVL13>:
  if (rdymsg == MSG_OK) {
    4b00:	9c 00 00 00 	cmpa	#0,	r12	;
    4b04:	18 20       	jnz	$+50     	;abs 0x4b36

00004b06 <.Loc.192.1>:
    *mbp->wrptr++ = msg;
    4b06:	3c 0a 08 00 	mova	8(r10),	r12	;
    4b0a:	cd 0c       	mova	r12,	r13	;
    4b0c:	ad 00 04 00 	adda	#4,	r13	;
    4b10:	7a 0d 08 00 	mova	r13,	8(r10)	;
    4b14:	7c 06 00 00 	mova	r6,	0(r12)	;

00004b18 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4b18:	00 18 da 9a 	cmpx.a	4(r10),	8(r10)	;
    4b1c:	04 00 08 00 
    4b20:	03 28       	jnc	$+8      	;abs 0x4b28

00004b22 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4b22:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4b26:	08 00 

00004b28 <.L6>:
    }
    chSemSignalI(&mbp->fullsem);
    4b28:	cc 0a       	mova	r10,	r12	;
    4b2a:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b2e:	b0 13 c4 49 	calla	#18884		;0x049c4

00004b32 <.LVL14>:
    chSchRescheduleS();
    4b32:	b0 13 e4 48 	calla	#18660		;0x048e4

00004b36 <.L4>:
  }

  return rdymsg;
}
    4b36:	cc 08       	mova	r8,	r12	;
    4b38:	06 16       	popm.a	#1,	r6	;20-bit words
    4b3a:	08 16       	popm.a	#1,	r8	;20-bit words
    4b3c:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b3e:	10 01       	reta			;

00004b40 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4b40:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b42 <.LCFI18>:
    4b42:	08 14       	pushm.a	#1,	r8	;20-bit words

00004b44 <.LCFI19>:
    4b44:	06 14       	pushm.a	#1,	r6	;20-bit words

00004b46 <.LCFI20>:
    4b46:	ca 0c       	mova	r12,	r10	;
    4b48:	c6 0d       	mova	r13,	r6	;
    4b4a:	08 4e       	mov	r14,	r8	;

00004b4c <.Loc.386.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4b4c:	b0 13 12 46 	calla	#17938		;0x04612

00004b50 <.LVL39>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4b50:	0d 48       	mov	r8,	r13	;
    4b52:	cc 0a       	mova	r10,	r12	;
    4b54:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4b58:	b0 13 7e 49 	calla	#18814		;0x0497e

00004b5c <.LVL40>:
    4b5c:	c8 0c       	mova	r12,	r8	;

00004b5e <.LVL41>:
  if (rdymsg == MSG_OK) {
    4b5e:	9c 00 00 00 	cmpa	#0,	r12	;
    4b62:	19 20       	jnz	$+52     	;abs 0x4b96

00004b64 <.Loc.391.1>:
    *msgp = *mbp->rdptr++;
    4b64:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4b68:	cd 0c       	mova	r12,	r13	;
    4b6a:	ad 00 04 00 	adda	#4,	r13	;
    4b6e:	7a 0d 0c 00 	mova	r13,	12(r10)	; 0x0000c
    4b72:	00 18 e6 4c 	movx.a	@r12,	0(r6)	;
    4b76:	00 00 

00004b78 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4b78:	00 18 da 9a 	cmpx.a	4(r10),	12(r10)	; 0x0000c
    4b7c:	04 00 0c 00 
    4b80:	03 28       	jnc	$+8      	;abs 0x4b88

00004b82 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4b82:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4b86:	0c 00 

00004b88 <.L22>:
    }
    chSemSignalI(&mbp->emptysem);
    4b88:	cc 0a       	mova	r10,	r12	;
    4b8a:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4b8e:	b0 13 c4 49 	calla	#18884		;0x049c4

00004b92 <.LVL42>:
    chSchRescheduleS();
    4b92:	b0 13 e4 48 	calla	#18660		;0x048e4

00004b96 <.L20>:
  }

  return rdymsg;
}
    4b96:	cc 08       	mova	r8,	r12	;
    4b98:	06 16       	popm.a	#1,	r6	;20-bit words
    4b9a:	08 16       	popm.a	#1,	r8	;20-bit words
    4b9c:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b9e:	10 01       	reta			;

00004ba0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    4ba0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ba2 <.LCFI0>:
    4ba2:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ba4 <.LCFI1>:
    4ba4:	ca 0c       	mova	r12,	r10	;
    4ba6:	08 4d       	mov	r13,	r8	;

00004ba8 <.Loc.111.1>:
  uint8_t *p;

  chDbgCheckClassI();
    4ba8:	b0 13 f6 45 	calla	#17910		;0x045f6

00004bac <.LVL1>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    4bac:	40 18 0e 48 	movx.w	r8,	r14	;
    4bb0:	ea 0e       	adda	r14,	r10	;

00004bb2 <.LVL2>:
    4bb2:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff
    4bb6:	00 18 48 43 	clrx.a	r8		;
    4bba:	f8 0e       	suba	r14,	r8	;

00004bbc <.LVL3>:
    4bbc:	00 18 4a f8 	andx.a	r8,	r10	;

00004bc0 <.LVL4>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    4bc0:	00 18 5e 52 	addx.a	&0x09dc0,r14	;
    4bc4:	c0 9d 

00004bc6 <.LVL5>:
    4bc6:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    4bca:	00 18 48 fe 	andx.a	r14,	r8	;

00004bce <.Loc.117.1>:

  if (((size_t)endmem - (size_t)p) < size) {
    4bce:	2e 00 bc 9d 	mova	&40380,	r14	;0x09dbc
    4bd2:	fe 08       	suba	r8,	r14	;
    4bd4:	de 0a       	cmpa	r10,	r14	;
    4bd6:	07 28       	jnc	$+16     	;abs 0x4be6

00004bd8 <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    4bd8:	ea 08       	adda	r8,	r10	;

00004bda <.LVL7>:
    4bda:	60 0a c0 9d 	mova	r10,	&40384	; 0x09dc0

00004bde <.Loc.122.1>:

  return p;
    4bde:	cc 08       	mova	r8,	r12	;

00004be0 <.L2>:
}
    4be0:	08 16       	popm.a	#1,	r8	;20-bit words
    4be2:	0a 16       	popm.a	#1,	r10	;20-bit words
    4be4:	10 01       	reta			;

00004be6 <.L4>:
    return NULL;
    4be6:	4c 43       	clr.b	r12		;
    4be8:	80 00 e0 4b 	mova	#19424,	r0	;0x04be0

00004bec <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    4bec:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004bee <.LCFI2>:
    4bee:	ca 0c       	mova	r12,	r10	;
    4bf0:	09 4d       	mov	r13,	r9	;

00004bf2 <.LBB6>:
  _disable_interrupts();
    4bf2:	32 c2       	dint			
    4bf4:	03 43       	nop			

00004bf6 <.Loc.348.2>:
  asm volatile("nop");
    4bf6:	03 43       	nop			

00004bf8 <.LBE6>:
  void *p;

  chSysLock();
    4bf8:	b0 13 22 45 	calla	#17698		;0x04522

00004bfc <.LVL10>:
  p = chCoreAllocAlignedI(size, align);
    4bfc:	0d 49       	mov	r9,	r13	;
    4bfe:	cc 0a       	mova	r10,	r12	;
    4c00:	b0 13 a0 4b 	calla	#19360		;0x04ba0

00004c04 <.LVL11>:
    4c04:	ca 0c       	mova	r12,	r10	;

00004c06 <.LVL12>:
  chSysUnlock();
    4c06:	b0 13 42 45 	calla	#17730		;0x04542

00004c0a <.LBB8>:
  asm volatile("nop");
    4c0a:	03 43       	nop			

00004c0c <.Loc.356.2>:
  _enable_interrupts();
    4c0c:	03 43       	nop			
    4c0e:	32 d2       	eint			
    4c10:	03 43       	nop			

00004c12 <.LBE8>:

  return p;
}
    4c12:	cc 0a       	mova	r10,	r12	;
    4c14:	19 16       	popm.a	#2,	r10	;20-bit words
    4c16:	10 01       	reta			;

00004c18 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    4c18:	8c 00 c4 9d 	mova	#40388,	r12	;0x09dc4
    4c1c:	00 18 fc 40 	movx.a	#19436,	0(r12)	;0x04bec
    4c20:	ec 4b 00 00 

00004c24 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    4c24:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4c28:	04 00 

00004c2a <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    4c2a:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    4c2e:	fc f0 f0 ff 	and.b	#-16,	10(r12)	;#0xfff0, 0x000a
    4c32:	0a 00 

00004c34 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    4c34:	9c 43 0c 00 	mov	#1,	12(r12)	;r3 As==01, 0x000c

00004c38 <.Loc.117.1>:
#endif
}
    4c38:	10 01       	reta			;

00004c3a <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4c3a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c3c <.LCFI1>:
    4c3c:	ca 0c       	mova	r12,	r10	;

00004c3e <.Loc.124.1>:
  void *objp;

  chDbgCheckClassI();
    4c3e:	b0 13 f6 45 	calla	#17910		;0x045f6

00004c42 <.LVL4>:
  chDbgCheck(mp != NULL);

  objp = mp->next;
    4c42:	0c 0a       	mova	@r10,	r12	;

00004c44 <.LVL5>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4c44:	9c 00 00 00 	cmpa	#0,	r12	;
    4c48:	05 24       	jz	$+12     	;abs 0x4c54

00004c4a <.Loc.130.1>:
    mp->next = mp->next->next;
    4c4a:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4c4e:	00 00 

00004c50 <.L2>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4c50:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c52:	10 01       	reta			;

00004c54 <.L3>:
  else if (mp->provider != NULL) {
    4c54:	3e 0a 08 00 	mova	8(r10),	r14	;
    4c58:	9e 00 00 00 	cmpa	#0,	r14	;
    4c5c:	f9 27       	jz	$-12     	;abs 0x4c50

00004c5e <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4c5e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4c60:	3c 0a 04 00 	mova	4(r10),	r12	;

00004c64 <.LVL6>:
    4c64:	4e 13       	calla	r14		;

00004c66 <.LVL7>:
  return objp;
    4c66:	80 00 50 4c 	mova	#19536,	r0	;0x04c50

00004c6a <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
    4c6a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c6c <.LCFI2>:
    4c6c:	ca 0c       	mova	r12,	r10	;

00004c6e <.LBB22>:
  _disable_interrupts();
    4c6e:	32 c2       	dint			
    4c70:	03 43       	nop			

00004c72 <.Loc.348.2>:
  asm volatile("nop");
    4c72:	03 43       	nop			

00004c74 <.LBE22>:
  void *objp;

  chSysLock();
    4c74:	b0 13 22 45 	calla	#17698		;0x04522

00004c78 <.LVL9>:
  objp = chPoolAllocI(mp);
    4c78:	cc 0a       	mova	r10,	r12	;
    4c7a:	b0 13 3a 4c 	calla	#19514		;0x04c3a

00004c7e <.LVL10>:
    4c7e:	ca 0c       	mova	r12,	r10	;

00004c80 <.LVL11>:
  chSysUnlock();
    4c80:	b0 13 42 45 	calla	#17730		;0x04542

00004c84 <.LBB24>:
  asm volatile("nop");
    4c84:	03 43       	nop			

00004c86 <.Loc.356.2>:
  _enable_interrupts();
    4c86:	03 43       	nop			
    4c88:	32 d2       	eint			
    4c8a:	03 43       	nop			

00004c8c <.LBE24>:

  return objp;
}
    4c8c:	cc 0a       	mova	r10,	r12	;
    4c8e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c90:	10 01       	reta			;

00004c92 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4c92:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c94 <.LCFI3>:
    4c94:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c96 <.LCFI4>:
    4c96:	ca 0c       	mova	r12,	r10	;
    4c98:	c8 0d       	mova	r13,	r8	;

00004c9a <.LVL14>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
    4c9a:	b0 13 f6 45 	calla	#17910		;0x045f6

00004c9e <.LVL15>:
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
    4c9e:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4ca2:	00 00 

00004ca4 <.Loc.179.1>:
  mp->next = php;
    4ca4:	7a 08 00 00 	mova	r8,	0(r10)	;

00004ca8 <.Loc.180.1>:
}
    4ca8:	08 16       	popm.a	#1,	r8	;20-bit words
    4caa:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cac:	10 01       	reta			;

00004cae <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    4cae:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cb0 <.LCFI5>:
    4cb0:	08 14       	pushm.a	#1,	r8	;20-bit words

00004cb2 <.LCFI6>:
    4cb2:	ca 0c       	mova	r12,	r10	;
    4cb4:	c8 0d       	mova	r13,	r8	;

00004cb6 <.LBB26>:
  _disable_interrupts();
    4cb6:	32 c2       	dint			
    4cb8:	03 43       	nop			

00004cba <.Loc.348.2>:
  asm volatile("nop");
    4cba:	03 43       	nop			

00004cbc <.LBE26>:

  chSysLock();
    4cbc:	b0 13 22 45 	calla	#17698		;0x04522

00004cc0 <.LVL17>:
  chPoolFreeI(mp, objp);
    4cc0:	cd 08       	mova	r8,	r13	;
    4cc2:	cc 0a       	mova	r10,	r12	;
    4cc4:	b0 13 92 4c 	calla	#19602		;0x04c92

00004cc8 <.LVL18>:
  chSysUnlock();
    4cc8:	b0 13 42 45 	calla	#17730		;0x04542

00004ccc <.LBB28>:
  asm volatile("nop");
    4ccc:	03 43       	nop			

00004cce <.Loc.356.2>:
  _enable_interrupts();
    4cce:	03 43       	nop			
    4cd0:	32 d2       	eint			
    4cd2:	03 43       	nop			

00004cd4 <.LBE28>:
}
    4cd4:	08 16       	popm.a	#1,	r8	;20-bit words
    4cd6:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cd8:	10 01       	reta			;

00004cda <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4cda:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004cdc <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4cdc:	7d 01 00 00 	mova	r1,	0(r13)	;

00004ce0 <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4ce0:	01 0c       	mova	@r12,	r1	;

00004ce2 <.Loc.76.1>:
  asm volatile ("popm.a #7, R10");
    4ce2:	64 16       	popm.a	#7,	r10	;20-bit words

00004ce4 <.Loc.77.1>:
  asm volatile ("reta");
    4ce4:	10 01       	reta			;

00004ce6 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    4ce6:	b0 13 42 45 	calla	#17730		;0x04542

00004cea <.LBB4>:
  asm volatile("nop");
    4cea:	03 43       	nop			

00004cec <.Loc.356.2>:
  _enable_interrupts();
    4cec:	03 43       	nop			
    4cee:	32 d2       	eint			
    4cf0:	03 43       	nop			

00004cf2 <.LBE4>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4cf2:	cc 05       	mova	r5,	r12	;

00004cf4 <.Loc.98.1>:
  asm volatile ("calla R4");
    4cf4:	44 13       	calla	r4		;

00004cf6 <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4cf6:	4c 43       	clr.b	r12		;
    4cf8:	b0 13 72 47 	calla	#18290		;0x04772

00004cfc <.LVL2>:
#endif
}
    4cfc:	10 01       	reta			;

00004cfe <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4cfe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d00 <.LCFI0>:
    4d00:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d02 <.LCFI1>:
    4d02:	06 14       	pushm.a	#1,	r6	;20-bit words

00004d04 <.LCFI2>:
    4d04:	04 14       	pushm.a	#1,	r4	;20-bit words

00004d06 <.LCFI3>:
    4d06:	c8 0c       	mova	r12,	r8	;
    4d08:	c4 0d       	mova	r13,	r4	;

00004d0a <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    4d0a:	c6 0c       	mova	r12,	r6	;

00004d0c <.LVL1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4d0c:	2c 4c       	mov	@r12,	r12	;

00004d0e <.LVL2>:
    4d0e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4d10:	05 38       	jl	$+12     	;abs 0x4d1c

00004d12 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4d12:	04 16       	popm.a	#1,	r4	;20-bit words
    4d14:	06 16       	popm.a	#1,	r6	;20-bit words
    4d16:	08 16       	popm.a	#1,	r8	;20-bit words
    4d18:	0a 16       	popm.a	#1,	r10	;20-bit words
    4d1a:	10 01       	reta			;

00004d1c <.L8>:
    4d1c:	8a 00 12 1c 	mova	#7186,	r10	;0x01c12

00004d20 <.L2>:
      if (tp->u1.semp == sp) {
    4d20:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    4d24:	06 00 
    4d26:	0b 24       	jz	$+24     	;abs 0x4d3e

00004d28 <.Loc.74.1>:
      tp++;
    4d28:	aa 00 14 00 	adda	#20,	r10	;0x00014

00004d2c <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    4d2c:	9a 00 26 1c 	cmpa	#7206,	r10	;0x01c26
    4d30:	f7 2b       	jnc	$-16     	;abs 0x4d20

00004d32 <.Loc.76.1>:
    4d32:	8c 00 f0 72 	mova	#29424,	r12	;0x072f0
    4d36:	b0 13 72 47 	calla	#18290		;0x04772

00004d3a <.LVL6>:
    4d3a:	80 00 20 4d 	mova	#19744,	r0	;0x04d20

00004d3e <.L9>:
        sp->cnt++;
    4d3e:	98 53 00 00 	inc	0(r8)		;

00004d42 <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    4d42:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    4d46:	04 00 
    4d48:	04 24       	jz	$+10     	;abs 0x4d52

00004d4a <.Loc.69.1>:
    4d4a:	8c 00 f0 72 	mova	#29424,	r12	;0x072f0
    4d4e:	b0 13 72 47 	calla	#18290		;0x04772

00004d52 <.L5>:
        (void) chSchReadyI(tp, msg);
    4d52:	cd 04       	mova	r4,	r13	;
    4d54:	cc 0a       	mova	r10,	r12	;
    4d56:	b0 13 44 48 	calla	#18500		;0x04844

00004d5a <.LVL8>:
        return;
    4d5a:	80 00 12 4d 	mova	#19730,	r0	;0x04d12

00004d5e <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4d5e:	b0 13 62 4f 	calla	#20322		;0x04f62

00004d62 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4d62:	8c 00 6c 74 	mova	#29804,	r12	;0x0746c
    4d66:	b0 13 d2 4f 	calla	#20434		;0x04fd2

00004d6a <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4d6a:	b0 13 86 4d 	calla	#19846		;0x04d86

00004d6e <.LVL2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4d6e:	b0 13 32 4e 	calla	#20018		;0x04e32

00004d72 <.LVL3>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    4d72:	b0 13 38 4e 	calla	#20024		;0x04e38

00004d76 <.LVL4>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4d76:	b0 13 06 5a 	calla	#23046		;0x05a06

00004d7a <.LVL5>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4d7a:	b0 13 80 4d 	calla	#19840		;0x04d80

00004d7e <.LVL6>:
#endif
}
    4d7e:	10 01       	reta			;

00004d80 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4d80:	b0 13 b2 4f 	calla	#20402		;0x04fb2

00004d84 <.LVL0>:
}
    4d84:	10 01       	reta			;

00004d86 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    4d86:	b0 13 e2 58 	calla	#22754		;0x058e2

00004d8a <.LVL0>:
}
    4d8a:	10 01       	reta			;

00004d8c <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    4d8c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004d90 <.Loc.71.1>:
  gptp->config = NULL;
    4d90:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    4d94:	02 00 

00004d96 <.Loc.72.1>:
}
    4d96:	10 01       	reta			;

00004d98 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    4d98:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d9a <.LCFI0>:
    4d9a:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d9c <.LCFI1>:
    4d9c:	ca 0c       	mova	r12,	r10	;
    4d9e:	c8 0d       	mova	r13,	r8	;

00004da0 <.LBB54>:
  _disable_interrupts();
    4da0:	32 c2       	dint			
    4da2:	03 43       	nop			

00004da4 <.Loc.348.2>:
  asm volatile("nop");
    4da4:	03 43       	nop			

00004da6 <.LBE56>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    4da6:	b0 13 22 45 	calla	#17698		;0x04522

00004daa <.LBE54>:

  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    4daa:	6c 4a       	mov.b	@r10,	r12	;
    4dac:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4dae:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4db0:	4d 9c       	cmp.b	r12,	r13	;
    4db2:	04 2c       	jc	$+10     	;abs 0x4dbc

00004db4 <.Loc.87.1>:
    4db4:	8c 00 63 73 	mova	#29539,	r12	;0x07363
    4db8:	b0 13 72 47 	calla	#18290		;0x04772

00004dbc <.L4>:
              "invalid state");
  gptp->config = config;
    4dbc:	7a 08 02 00 	mova	r8,	2(r10)	;

00004dc0 <.Loc.90.1>:
  gpt_lld_start(gptp);
    4dc0:	cc 0a       	mova	r10,	r12	;
    4dc2:	b0 13 f4 58 	calla	#22772		;0x058f4

00004dc6 <.LVL5>:
  gptp->state = GPT_READY;
    4dc6:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004dca <.LBB58>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    4dca:	b0 13 42 45 	calla	#17730		;0x04542

00004dce <.LBB60>:
  asm volatile("nop");
    4dce:	03 43       	nop			

00004dd0 <.Loc.356.2>:
  _enable_interrupts();
    4dd0:	03 43       	nop			
    4dd2:	32 d2       	eint			
    4dd4:	03 43       	nop			

00004dd6 <.LBE58>:
  osalSysUnlock();
}
    4dd6:	08 16       	popm.a	#1,	r8	;20-bit words
    4dd8:	0a 16       	popm.a	#1,	r10	;20-bit words
    4dda:	10 01       	reta			;

00004ddc <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    4ddc:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004dde <.LCFI6>:
    4dde:	ca 0c       	mova	r12,	r10	;
    4de0:	09 4d       	mov	r13,	r9	;

00004de2 <.Loc.199.1>:

  osalDbgCheckClassI();
    4de2:	b0 13 f6 45 	calla	#17910		;0x045f6

00004de6 <.LVL25>:
  osalDbgCheck(gptp != NULL);
  osalDbgCheck(gptp->config->callback != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
    4de6:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4dea:	04 24       	jz	$+10     	;abs 0x4df4

00004dec <.Loc.202.1>:
    4dec:	8c 00 24 73 	mova	#29476,	r12	;0x07324
    4df0:	b0 13 72 47 	calla	#18290		;0x04772

00004df4 <.L13>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    4df4:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00004df8 <.Loc.206.1>:
  gpt_lld_start_timer(gptp, interval);
    4df8:	0d 49       	mov	r9,	r13	;
    4dfa:	cc 0a       	mova	r10,	r12	;
    4dfc:	b0 13 ca 59 	calla	#22986		;0x059ca

00004e00 <.LVL27>:
}
    4e00:	19 16       	popm.a	#2,	r10	;20-bit words
    4e02:	10 01       	reta			;

00004e04 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    4e04:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e06 <.LCFI8>:
    4e06:	ca 0c       	mova	r12,	r10	;

00004e08 <.Loc.232.1>:

  osalDbgCheckClassI();
    4e08:	b0 13 f6 45 	calla	#17910		;0x045f6

00004e0c <.LVL33>:
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4e0c:	6c 4a       	mov.b	@r10,	r12	;
    4e0e:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    4e12:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4e14:	4d 9c       	cmp.b	r12,	r13	;
    4e16:	07 28       	jnc	$+16     	;abs 0x4e26

00004e18 <.L16>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    4e18:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004e1c <.Loc.239.1>:
  gpt_lld_stop_timer(gptp);
    4e1c:	cc 0a       	mova	r10,	r12	;
    4e1e:	b0 13 fa 59 	calla	#23034		;0x059fa

00004e22 <.LVL34>:
}
    4e22:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e24:	10 01       	reta			;

00004e26 <.L17>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    4e26:	8c 00 16 73 	mova	#29462,	r12	;0x07316
    4e2a:	b0 13 72 47 	calla	#18290		;0x04772

00004e2e <.LVL35>:
    4e2e:	80 00 18 4e 	mova	#19992,	r0	;0x04e18

00004e32 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    4e32:	b0 13 7a 52 	calla	#21114		;0x0527a

00004e36 <.LVL0>:
}
    4e36:	10 01       	reta			;

00004e38 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    4e38:	b0 13 3e 56 	calla	#22078		;0x0563e

00004e3c <.LVL0>:
}
    4e3c:	10 01       	reta			;

00004e3e <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    4e3e:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004e42 <.Loc.71.1>:
  uartp->txstate    = UART_TX_IDLE;
    4e42:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00004e46 <.Loc.72.1>:
  uartp->rxstate    = UART_RX_IDLE;
    4e46:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00004e4a <.Loc.73.1>:
  uartp->config     = NULL;
    4e4a:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4e4e:	04 00 

00004e50 <.Loc.75.1>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    4e50:	cc 43 08 00 	mov.b	#0,	8(r12)	;r3 As==00

00004e54 <.Loc.76.1>:
  uartp->threadrx   = NULL;
    4e54:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    4e58:	0a 00 

00004e5a <.Loc.77.1>:
  uartp->threadtx   = NULL;
    4e5a:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    4e5e:	0e 00 

00004e60 <.Loc.87.1>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    4e60:	10 01       	reta			;

00004e62 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    4e62:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e64 <.LCFI0>:
    4e64:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e66 <.LCFI1>:
    4e66:	ca 0c       	mova	r12,	r10	;
    4e68:	c8 0d       	mova	r13,	r8	;

00004e6a <.LBB84>:
  _disable_interrupts();
    4e6a:	32 c2       	dint			
    4e6c:	03 43       	nop			

00004e6e <.Loc.348.2>:
  asm volatile("nop");
    4e6e:	03 43       	nop			

00004e70 <.LBE86>:
  chSysLock();
    4e70:	b0 13 22 45 	calla	#17698		;0x04522

00004e74 <.LBE84>:

  osalDbgCheck((uartp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    4e74:	6c 4a       	mov.b	@r10,	r12	;
    4e76:	7c 53       	add.b	#-1,	r12	;r3 As==11
    4e78:	5d 43       	mov.b	#1,	r13	;r3 As==01
    4e7a:	4d 9c       	cmp.b	r12,	r13	;
    4e7c:	04 2c       	jc	$+10     	;abs 0x4e86

00004e7e <.Loc.102.1>:
    4e7e:	8c 00 28 74 	mova	#29736,	r12	;0x07428
    4e82:	b0 13 72 47 	calla	#18290		;0x04772

00004e86 <.L4>:
                "invalid state");

  uartp->config = config;
    4e86:	7a 08 04 00 	mova	r8,	4(r10)	;

00004e8a <.Loc.106.1>:
  uart_lld_start(uartp);
    4e8a:	cc 0a       	mova	r10,	r12	;
    4e8c:	b0 13 9e 56 	calla	#22174		;0x0569e

00004e90 <.LVL5>:
  uartp->state = UART_READY;
    4e90:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004e94 <.LBB88>:
  chSysUnlock();
    4e94:	b0 13 42 45 	calla	#17730		;0x04542

00004e98 <.LBB90>:
  asm volatile("nop");
    4e98:	03 43       	nop			

00004e9a <.Loc.356.2>:
  _enable_interrupts();
    4e9a:	03 43       	nop			
    4e9c:	32 d2       	eint			
    4e9e:	03 43       	nop			

00004ea0 <.LBE88>:
  osalSysUnlock();
}
    4ea0:	08 16       	popm.a	#1,	r8	;20-bit words
    4ea2:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ea4:	10 01       	reta			;

00004ea6 <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    4ea6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ea8 <.LCFI6>:
    4ea8:	08 14       	pushm.a	#1,	r8	;20-bit words

00004eaa <.LCFI7>:
    4eaa:	06 14       	pushm.a	#1,	r6	;20-bit words

00004eac <.LCFI8>:
    4eac:	ca 0c       	mova	r12,	r10	;
    4eae:	c6 0d       	mova	r13,	r6	;
    4eb0:	c8 0e       	mova	r14,	r8	;

00004eb2 <.Loc.174.1>:

  osalDbgCheckClassI();
    4eb2:	b0 13 f6 45 	calla	#17910		;0x045f6

00004eb6 <.LVL19>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4eb6:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4eba:	04 24       	jz	$+10     	;abs 0x4ec4

00004ebc <.Loc.176.1>:
    4ebc:	8c 00 02 74 	mova	#29698,	r12	;0x07402
    4ec0:	b0 13 72 47 	calla	#18290		;0x04772

00004ec4 <.L12>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    4ec4:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    4ec8:	0b 24       	jz	$+24     	;abs 0x4ee0

00004eca <.L13>:

  uart_lld_start_send(uartp, n, txbuf);
    4eca:	ce 08       	mova	r8,	r14	;
    4ecc:	cd 06       	mova	r6,	r13	;
    4ece:	cc 0a       	mova	r10,	r12	;
    4ed0:	b0 13 16 58 	calla	#22550		;0x05816

00004ed4 <.LVL21>:
  uartp->txstate = UART_TX_ACTIVE;
    4ed4:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00004ed8 <.Loc.181.1>:
}
    4ed8:	06 16       	popm.a	#1,	r6	;20-bit words
    4eda:	08 16       	popm.a	#1,	r8	;20-bit words
    4edc:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ede:	10 01       	reta			;

00004ee0 <.L14>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    4ee0:	8c 00 02 74 	mova	#29698,	r12	;0x07402
    4ee4:	b0 13 72 47 	calla	#18290		;0x04772

00004ee8 <.LVL22>:
    4ee8:	80 00 ca 4e 	mova	#20170,	r0	;0x04eca

00004eec <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    4eec:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004eee <.LCFI15>:
    4eee:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ef0 <.LCFI16>:
    4ef0:	06 14       	pushm.a	#1,	r6	;20-bit words

00004ef2 <.LCFI17>:
    4ef2:	ca 0c       	mova	r12,	r10	;
    4ef4:	c6 0d       	mova	r13,	r6	;
    4ef6:	c8 0e       	mova	r14,	r8	;

00004ef8 <.Loc.280.1>:

  osalDbgCheckClassI();
    4ef8:	b0 13 f6 45 	calla	#17910		;0x045f6

00004efc <.LVL42>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
    4efc:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4f00:	04 24       	jz	$+10     	;abs 0x4f0a

00004f02 <.Loc.282.1>:
    4f02:	8c 00 c4 73 	mova	#29636,	r12	;0x073c4
    4f06:	b0 13 72 47 	calla	#18290		;0x04772

00004f0a <.L30>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    4f0a:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4f0e:	0b 24       	jz	$+24     	;abs 0x4f26

00004f10 <.L31>:

  uart_lld_start_receive(uartp, n, rxbuf);
    4f10:	ce 08       	mova	r8,	r14	;
    4f12:	cd 06       	mova	r6,	r13	;
    4f14:	cc 0a       	mova	r10,	r12	;
    4f16:	b0 13 54 58 	calla	#22612		;0x05854

00004f1a <.LVL44>:
  uartp->rxstate = UART_RX_ACTIVE;
    4f1a:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

00004f1e <.Loc.287.1>:
}
    4f1e:	06 16       	popm.a	#1,	r6	;20-bit words
    4f20:	08 16       	popm.a	#1,	r8	;20-bit words
    4f22:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f24:	10 01       	reta			;

00004f26 <.L32>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    4f26:	8c 00 c4 73 	mova	#29636,	r12	;0x073c4
    4f2a:	b0 13 72 47 	calla	#18290		;0x04772

00004f2e <.LVL45>:
    4f2e:	80 00 10 4f 	mova	#20240,	r0	;0x04f10

00004f32 <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    4f32:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f34 <.LCFI20>:
    4f34:	ca 0c       	mova	r12,	r10	;

00004f36 <.Loc.336.1>:

  osalDbgCheckClassI();
    4f36:	b0 13 f6 45 	calla	#17910		;0x045f6

00004f3a <.LVL55>:
  osalDbgCheck(uartp != NULL);
  osalDbgAssert(uartp->state == UART_READY, "not active");
    4f3a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    4f3e:	04 24       	jz	$+10     	;abs 0x4f48

00004f40 <.Loc.338.1>:
    4f40:	8c 00 a3 73 	mova	#29603,	r12	;0x073a3
    4f44:	b0 13 72 47 	calla	#18290		;0x04772

00004f48 <.L39>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    4f48:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4f4c:	03 24       	jz	$+8      	;abs 0x4f54

00004f4e <.Loc.345.1>:
    size_t n = uart_lld_stop_receive(uartp);
    uartp->rxstate = UART_RX_IDLE;
    return n;
  }
  return 0;
    4f4e:	4c 43       	clr.b	r12		;

00004f50 <.L38>:
}
    4f50:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f52:	10 01       	reta			;

00004f54 <.L42>:
    size_t n = uart_lld_stop_receive(uartp);
    4f54:	cc 0a       	mova	r10,	r12	;
    4f56:	b0 13 9a 58 	calla	#22682		;0x0589a

00004f5a <.LVL57>:
    uartp->rxstate = UART_RX_IDLE;
    4f5a:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00004f5e <.Loc.343.1>:
    return n;
    4f5e:	80 00 50 4f 	mova	#20304,	r0	;0x04f50

00004f62 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    4f62:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4f66:	80 5a 5c 01 

00004f6a <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    4f6a:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    4f6e:	10 a5 40 01 

00004f72 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    4f72:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    4f76:	41 01 

00004f78 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    4f78:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    4f7c:	00 a5 60 01 

00004f80 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    4f80:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    4f84:	48 00 62 01 

00004f88 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    4f88:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    4f8c:	33 01 64 01 

00004f90 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    4f90:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    4f94:	66 01 

00004f96 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    4f96:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    4f9a:	c9 c1 68 01 

00004f9e <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    4f9e:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    4fa2:	0f 00 6c 01 

00004fa6 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    4fa6:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    4faa:	61 01 

00004fac <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    4fac:	b0 13 8c 50 	calla	#20620		;0x0508c

00004fb0 <.LVL0>:
#endif
}
    4fb0:	10 01       	reta			;

00004fb2 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    4fb2:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    4fb6:	7f 3e d2 03 

00004fba <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    4fba:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    4fbe:	10 00 c2 03 

00004fc2 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    4fc2:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    4fc6:	e0 03 

00004fc8 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    4fc8:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    4fcc:	14 02 c0 03 

00004fd0 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    4fd0:	10 01       	reta			;

00004fd2 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    4fd2:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    4fd6:	02 02 

00004fd8 <.Loc.310.1>:
  PADIR = config->porta.dir;
    4fd8:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    4fdc:	02 00 04 02 

00004fe0 <.Loc.311.1>:
  PAREN = config->porta.ren;
    4fe0:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    4fe4:	04 00 06 02 

00004fe8 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    4fe8:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    4fec:	06 00 0a 02 

00004ff0 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    4ff0:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    4ff4:	08 00 0c 02 

00004ff8 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    4ff8:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    4ffc:	0a 00 22 02 

00005000 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    5000:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    5004:	0c 00 24 02 

00005008 <.Loc.317.1>:
  PBREN = config->portb.ren;
    5008:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    500c:	0e 00 26 02 

00005010 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    5010:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    5014:	10 00 2a 02 

00005018 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    5018:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    501c:	12 00 2c 02 

00005020 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    5020:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    5024:	14 00 22 03 

00005028 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    5028:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    502c:	16 00 24 03 

00005030 <.Loc.351.1>:
  PJREN = config->portj.ren;
    5030:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    5034:	18 00 26 03 

00005038 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    5038:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    503c:	1a 00 2a 03 

00005040 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    5040:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    5044:	1c 00 2c 03 

00005048 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    5048:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    504c:	30 01 

0000504e <.Loc.356.1>:
}
    504e:	10 01       	reta			;

00005050 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    5050:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005052 <.LCFI0>:
    5052:	49 4c       	mov.b	r12,	r9	;
    5054:	48 4d       	mov.b	r13,	r8	;

00005056 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5056:	0a 49       	mov	r9,	r10	;
    5058:	12 c3       	clrc			
    505a:	0a 10       	rrc	r10		;
    505c:	40 18 0a 4a 	movx.w	r10,	r10	;
    5060:	ea 0a       	adda	r10,	r10	;
    5062:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005066 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5066:	59 f3       	and.b	#1,	r9	;r3 As==01
    5068:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    506c:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00005070 <.LVL2>:
    5070:	0d 49       	mov	r9,	r13	;

00005072 <.LVL3>:
    5072:	b0 13 30 65 	calla	#25904		;0x06530
    5076:	07 4c       	mov	r12,	r7	;
    5078:	27 fa       	and	@r10,	r7	;

0000507a <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    507a:	0c 48       	mov	r8,	r12	;
    507c:	0d 49       	mov	r9,	r13	;
    507e:	b0 13 9c 64 	calla	#25756		;0x0649c
    5082:	07 dc       	bis	r12,	r7	;
    5084:	8a 47 00 00 	mov	r7,	0(r10)	;

00005088 <.Loc.65.1>:
}
    5088:	37 16       	popm.a	#4,	r10	;20-bit words
    508a:	10 01       	reta			;

0000508c <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    508c:	40 18 82 43 	movx.w	#0,	&0xf9dd2;r3 As==00
    5090:	d2 9d 

00005092 <.LBE23>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    5092:	10 01       	reta			;

00005094 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5094:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005096 <.LCFI2>:
    5096:	c8 0c       	mova	r12,	r8	;

00005098 <.Loc.188.1>:
  
  osalDbgCheckClassI();
    5098:	b0 13 f6 45 	calla	#17910		;0x045f6

0000509c <.LVL26>:

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    509c:	4a 43       	clr.b	r10		;

0000509e <.L9>:
    509e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    50a0:	0c 9a       	cmp	r10,	r12	;
    50a2:	15 38       	jl	$+44     	;abs 0x50ce

000050a4 <.Loc.193.1>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    50a4:	0d 4a       	mov	r10,	r13	;
    50a6:	4d 0e       	rlam.a	#4,	r13	;
    50a8:	4d 0d       	rram.a	#4,	r13	;
    50aa:	0d 14       	pushm.a	#1,	r13	;20-bit words
    50ac:	40 18 3c 41 	popx.w	r12		;
    50b0:	40 18 3d 41 	popx.w	r13		;
    50b4:	b0 13 ce 64 	calla	#25806		;0x064ce
    50b8:	0d 12       	push	r13		;
    50ba:	0c 12       	push	r12		;
    50bc:	0c 16       	popm.a	#1,	r12	;20-bit words
    50be:	40 18 bc b0 	bitx.w	#16,	1296(r12);0x00010, 0x00510
    50c2:	10 00 10 05 
    50c6:	03 24       	jz	$+8      	;abs 0x50ce

000050c8 <.Loc.192.1>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    50c8:	1a 53       	inc	r10		;
    50ca:	80 00 9e 50 	mova	#20638,	r0	;0x0509e

000050ce <.L10>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    50ce:	6d 43       	mov.b	#2,	r13	;r3 As==10
    50d0:	0d 9a       	cmp	r10,	r13	;
    50d2:	1f 38       	jl	$+64     	;abs 0x5112

000050d4 <.Loc.203.1>:
    return MSG_TIMEOUT;
  }
  
  /* Acquire the channel in an idle mode */
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    50d4:	49 4a       	mov.b	r10,	r9	;
    50d6:	4d 43       	clr.b	r13		;
    50d8:	4c 49       	mov.b	r9,	r12	;
    50da:	b0 13 50 50 	calla	#20560		;0x05050

000050de <.LVL30>:
  dma_regs[i].sz  = 0;
    50de:	4a 0e       	rlam.a	#4,	r10	;
    50e0:	4a 0d       	rram.a	#4,	r10	;

000050e2 <.LVL31>:
    50e2:	0a 14       	pushm.a	#1,	r10	;20-bit words
    50e4:	40 18 3c 41 	popx.w	r12		;
    50e8:	40 18 3d 41 	popx.w	r13		;
    50ec:	b0 13 ce 64 	calla	#25806		;0x064ce
    50f0:	0d 12       	push	r13		;
    50f2:	0c 12       	push	r12		;
    50f4:	0c 16       	popm.a	#1,	r12	;20-bit words
    50f6:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    50fa:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000050fe <.Loc.205.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    50fe:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5102:	00 00 

00005104 <.Loc.207.1>:

  channel->registers = dma_regs + i;
    5104:	78 0c 00 00 	mova	r12,	0(r8)	;

00005108 <.Loc.208.1>:
  channel->index     = i;
    5108:	c8 49 04 00 	mov.b	r9,	4(r8)	;

0000510c <.Loc.210.1>:
  
  return MSG_OK;
    510c:	4c 43       	clr.b	r12		;

0000510e <.L8>:
}
    510e:	28 16       	popm.a	#3,	r10	;20-bit words
    5110:	10 01       	reta			;

00005112 <.L13>:
    return MSG_TIMEOUT;
    5112:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5116:	80 00 0e 51 	mova	#20750,	r0	;0x0510e

0000511a <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    511a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000511c <.LCFI5>:
    511c:	c8 0c       	mova	r12,	r8	;
    511e:	49 4d       	mov.b	r13,	r9	;

00005120 <.Loc.229.1>:
  
  osalDbgCheckClassI();
    5120:	b0 13 f6 45 	calla	#17910		;0x045f6

00005124 <.LVL43>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    5124:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5126:	4c 99       	cmp.b	r9,	r12	;
    5128:	1d 28       	jnc	$+60     	;abs 0x5164

0000512a <.L18>:
  if (dma_regs[index].ctl & DMAEN) {
    512a:	0c 49       	mov	r9,	r12	;
    512c:	0d 43       	clr	r13		;
    512e:	b0 13 ce 64 	calla	#25806		;0x064ce
    5132:	0d 12       	push	r13		;
    5134:	0c 12       	push	r12		;
    5136:	0a 16       	popm.a	#1,	r10	;20-bit words
    5138:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    513c:	ba b0 10 00 	bit	#16,	0(r10)	;#0x0010
    5140:	00 00 
    5142:	16 20       	jnz	$+46     	;abs 0x5170

00005144 <.Loc.238.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5144:	4d 43       	clr.b	r13		;
    5146:	4c 49       	mov.b	r9,	r12	;
    5148:	b0 13 50 50 	calla	#20560		;0x05050

0000514c <.LVL45>:
  dma_regs[index].sz  = 0;
    514c:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

00005150 <.Loc.240.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    5150:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    5154:	00 00 

00005156 <.Loc.242.1>:

  channel->registers = dma_regs + index;
    5156:	78 0a 00 00 	mova	r10,	0(r8)	;

0000515a <.Loc.243.1>:
  channel->index     = index;
    515a:	c8 49 04 00 	mov.b	r9,	4(r8)	;

0000515e <.Loc.245.1>:
  
  return MSG_OK;
    515e:	4c 43       	clr.b	r12		;

00005160 <.L17>:
}
    5160:	28 16       	popm.a	#3,	r10	;20-bit words
    5162:	10 01       	reta			;

00005164 <.L21>:
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    5164:	8c 00 32 74 	mova	#29746,	r12	;0x07432
    5168:	b0 13 72 47 	calla	#18290		;0x04772

0000516c <.LVL46>:
    516c:	80 00 2a 51 	mova	#20778,	r0	;0x0512a

00005170 <.L20>:
    return MSG_TIMEOUT;
    5170:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5174:	80 00 60 51 	mova	#20832,	r0	;0x05160

00005178 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5178:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000517a <.LCFI6>:
    517a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000517c <.LCFI7>:
    517c:	c8 0c       	mova	r12,	r8	;
    517e:	ca 0d       	mova	r13,	r10	;

00005180 <.Loc.275.1>:

  osalDbgCheckClassI();
    5180:	b0 13 f6 45 	calla	#17910		;0x045f6

00005184 <.LVL48>:

  channel->registers->ctl &= (~DMAEN);
    5184:	0c 08       	mova	@r8,	r12	;
    5186:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    518a:	00 00 

0000518c <.Loc.278.1>:
  dma_trigger_set(channel->index, request->trigger);
    518c:	5d 4a 10 00 	mov.b	16(r10),r13	;0x00010
    5190:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5194:	b0 13 50 50 	calla	#20560		;0x05050

00005198 <.LVL49>:
  callbacks[channel->index] = request->callback;
    5198:	5c 48 04 00 	mov.b	4(r8),	r12	;
    519c:	4c 0e       	rlam.a	#4,	r12	;
    519e:	4c 0d       	rram.a	#4,	r12	;
    51a0:	0c 14       	pushm.a	#1,	r12	;20-bit words
    51a2:	40 18 3c 41 	popx.w	r12		;
    51a6:	40 18 3d 41 	popx.w	r13		;
    51aa:	b0 13 d2 64 	calla	#25810		;0x064d2
    51ae:	0d 12       	push	r13		;
    51b0:	0c 12       	push	r12		;
    51b2:	0c 16       	popm.a	#1,	r12	;20-bit words
    51b4:	ac 00 d4 9d 	adda	#40404,	r12	;0x09dd4
    51b8:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    51bc:	00 00 
    51be:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    51c2:	02 00 
    51c4:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    51c8:	04 00 
    51ca:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    51ce:	06 00 

000051d0 <.Loc.282.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    51d0:	0c 08       	mova	@r8,	r12	;
    51d2:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    51d6:	02 00 

000051d8 <.Loc.283.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    51d8:	0c 08       	mova	@r8,	r12	;
    51da:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    51de:	04 00 06 00 

000051e2 <.Loc.288.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    51e2:	0c 08       	mova	@r8,	r12	;
    51e4:	9c 4a 08 00 	mov	8(r10),	10(r12)	; 0x000a
    51e8:	0a 00 

000051ea <.Loc.289.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    51ea:	0e 08       	mova	@r8,	r14	;
    51ec:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    51f0:	1c da 0a 00 	bis	10(r10),r12	;0x0000a
    51f4:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    51f8:	3c d0 15 00 	bis	#21,	r12	;#0x0015
    51fc:	8e 4c 00 00 	mov	r12,	0(r14)	;

00005200 <.Loc.292.1>:
                            request->transfer_mode | DMAEN |
                            DMAREQ;
}
    5200:	08 16       	popm.a	#1,	r8	;20-bit words
    5202:	0a 16       	popm.a	#1,	r10	;20-bit words
    5204:	10 01       	reta			;

00005206 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5206:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005208 <.LCFI10>:
    5208:	ca 0c       	mova	r12,	r10	;

0000520a <.LBB35>:
  return chSysGetStatusAndLockX();
    520a:	b0 13 f2 47 	calla	#18418		;0x047f2

0000520e <.LVL56>:
    520e:	09 4c       	mov	r12,	r9	;

00005210 <.LBE35>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    5210:	9a 00 00 00 	cmpa	#0,	r10	;
    5214:	08 24       	jz	$+18     	;abs 0x5226

00005216 <.Loc.309.1>:
    5216:	0c 0a       	mova	@r10,	r12	;
    5218:	9c 00 00 00 	cmpa	#0,	r12	;
    521c:	04 24       	jz	$+10     	;abs 0x5226

0000521e <.Loc.309.1>:
    521e:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5222:	00 00 
    5224:	05 20       	jnz	$+12     	;abs 0x5230

00005226 <.L25>:
  chSysRestoreStatusX(sts);
    5226:	0c 49       	mov	r9,	r12	;
    5228:	b0 13 1c 48 	calla	#18460		;0x0481c

0000522c <.LBE37>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    522c:	19 16       	popm.a	#2,	r10	;20-bit words
    522e:	10 01       	reta			;

00005230 <.L26>:
    channel->registers->ctl = DMAABORT;
    5230:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00005234 <.Loc.315.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    5234:	4d 43       	clr.b	r13		;
    5236:	8c 00 d2 9d 	mova	#40402,	r12	;0x09dd2
    523a:	b0 13 fe 4c 	calla	#19710		;0x04cfe

0000523e <.LVL59>:
    523e:	80 00 26 52 	mova	#21030,	r0	;0x05226

00005242 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    5242:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005244 <.LCFI11>:
    5244:	ca 0c       	mova	r12,	r10	;

00005246 <.Loc.331.1>:
  
  osalDbgCheckClassI();
    5246:	b0 13 f6 45 	calla	#17910		;0x045f6

0000524a <.LVL61>:
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    524a:	0c 0a       	mova	@r10,	r12	;
    524c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5250:	00 00 
    5252:	02 20       	jnz	$+6      	;abs 0x5258

00005254 <.L27>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
  channel->registers->sz  = 0;
  channel->registers->ctl = DMAEN | DMAABORT;
}
    5254:	0a 16       	popm.a	#1,	r10	;20-bit words
    5256:	10 01       	reta			;

00005258 <.L29>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    5258:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    525c:	00 00 

0000525e <.Loc.341.1>:
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    525e:	4d 43       	clr.b	r13		;
    5260:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5264:	b0 13 50 50 	calla	#20560		;0x05050

00005268 <.LVL62>:
  channel->registers->sz  = 0;
    5268:	0c 0a       	mova	@r10,	r12	;
    526a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000526e <.Loc.343.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    526e:	0c 0a       	mova	@r10,	r12	;
    5270:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5274:	00 00 
    5276:	80 00 54 52 	mova	#21076,	r0	;0x05254

0000527a <spi_lld_init>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    527a:	10 01       	reta			;

0000527c <UCBRS>:
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
  /* TODO there must be a better way */
  if (frac < 529)
    527c:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    5280:	0d 9c       	cmp	r12,	r13	;
    5282:	a9 2c       	jc	$+340    	;abs 0x53d6

00005284 <.Loc.84.1>:
    return 0x00;
  else if (frac < 715)
    5284:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    5288:	0d 9c       	cmp	r12,	r13	;
    528a:	a7 2c       	jc	$+336    	;abs 0x53da

0000528c <.Loc.86.1>:
    return 0x01;
  else if (frac < 835)
    528c:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    5290:	0d 9c       	cmp	r12,	r13	;
    5292:	03 28       	jnc	$+8      	;abs 0x529a

00005294 <.Loc.87.1>:
    return 0x02;
    5294:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005296 <.LVL1>:
    5296:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

0000529a <.L38>:
  else if (frac < 1001)
    529a:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    529e:	0d 9c       	cmp	r12,	r13	;
    52a0:	03 28       	jnc	$+8      	;abs 0x52a8

000052a2 <.Loc.89.1>:
    return 0x04;
    52a2:	6c 42       	mov.b	#4,	r12	;r2 As==10

000052a4 <.LVL3>:
    52a4:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052a8 <.L39>:
  else if (frac < 1252)
    52a8:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    52ac:	0d 9c       	cmp	r12,	r13	;
    52ae:	03 28       	jnc	$+8      	;abs 0x52b6

000052b0 <.Loc.91.1>:
    return 0x08;
    52b0:	7c 42       	mov.b	#8,	r12	;r2 As==11

000052b2 <.LVL5>:
    52b2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052b6 <.L40>:
  else if (frac < 1430)
    52b6:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    52ba:	0d 9c       	cmp	r12,	r13	;
    52bc:	04 28       	jnc	$+10     	;abs 0x52c6

000052be <.Loc.93.1>:
    return 0x10;
    52be:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000052c2 <.LVL7>:
    52c2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052c6 <.L41>:
  else if (frac < 1670)
    52c6:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    52ca:	0d 9c       	cmp	r12,	r13	;
    52cc:	04 28       	jnc	$+10     	;abs 0x52d6

000052ce <.Loc.95.1>:
    return 0x20;
    52ce:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000052d2 <.LVL9>:
    52d2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052d6 <.L42>:
  else if (frac < 2147)
    52d6:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    52da:	0d 9c       	cmp	r12,	r13	;
    52dc:	04 28       	jnc	$+10     	;abs 0x52e6

000052de <.Loc.97.1>:
    return 0x11;
    52de:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000052e2 <.LVL11>:
    52e2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052e6 <.L43>:
  else if (frac < 2224)
    52e6:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    52ea:	0d 9c       	cmp	r12,	r13	;
    52ec:	04 28       	jnc	$+10     	;abs 0x52f6

000052ee <.Loc.99.1>:
    return 0x21;
    52ee:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

000052f2 <.LVL13>:
    52f2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000052f6 <.L44>:
  else if (frac < 2503)
    52f6:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    52fa:	0d 9c       	cmp	r12,	r13	;
    52fc:	71 2c       	jc	$+228    	;abs 0x53e0

000052fe <.Loc.102.1>:
    return 0x22;
  else if (frac < 3000)
    52fe:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    5302:	0d 9c       	cmp	r12,	r13	;
    5304:	04 28       	jnc	$+10     	;abs 0x530e

00005306 <.Loc.103.1>:
    return 0x44;
    5306:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

0000530a <.LVL15>:
    530a:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

0000530e <.L45>:
  else if (frac < 3335)
    530e:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    5312:	0d 9c       	cmp	r12,	r13	;
    5314:	69 2c       	jc	$+212    	;abs 0x53e8

00005316 <.Loc.106.1>:
    return 0x25;
  else if (frac < 3575)
    5316:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    531a:	0d 9c       	cmp	r12,	r13	;
    531c:	69 2c       	jc	$+212    	;abs 0x53f0

0000531e <.Loc.108.1>:
    return 0x49;
  else if (frac < 3753)
    531e:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    5322:	0d 9c       	cmp	r12,	r13	;
    5324:	69 2c       	jc	$+212    	;abs 0x53f8

00005326 <.Loc.110.1>:
    return 0x4A;
  else if (frac < 4003)
    5326:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    532a:	0d 9c       	cmp	r12,	r13	;
    532c:	69 2c       	jc	$+212    	;abs 0x5400

0000532e <.Loc.112.1>:
    return 0x52;
  else if (frac < 4286)
    532e:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    5332:	0d 9c       	cmp	r12,	r13	;
    5334:	69 2c       	jc	$+212    	;abs 0x5408

00005336 <.Loc.114.1>:
    return 0x92;
  else if (frac < 4378)
    5336:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    533a:	0d 9c       	cmp	r12,	r13	;
    533c:	69 2c       	jc	$+212    	;abs 0x5410

0000533e <.Loc.116.1>:
    return 0x53;
  else if (frac < 5002)
    533e:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    5342:	0d 9c       	cmp	r12,	r13	;
    5344:	69 2c       	jc	$+212    	;abs 0x5418

00005346 <.Loc.118.1>:
    return 0x55;
  else if (frac < 5715)
    5346:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    534a:	0d 9c       	cmp	r12,	r13	;
    534c:	69 2c       	jc	$+212    	;abs 0x5420

0000534e <.Loc.120.1>:
    return 0xAA;
  else if (frac < 6003)
    534e:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    5352:	0d 9c       	cmp	r12,	r13	;
    5354:	69 2c       	jc	$+212    	;abs 0x5428

00005356 <.Loc.122.1>:
    return 0x6B;
  else if (frac < 6254)
    5356:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    535a:	0d 9c       	cmp	r12,	r13	;
    535c:	69 2c       	jc	$+212    	;abs 0x5430

0000535e <.Loc.124.1>:
    return 0xAD;
  else if (frac < 6432)
    535e:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    5362:	0d 9c       	cmp	r12,	r13	;
    5364:	69 2c       	jc	$+212    	;abs 0x5438

00005366 <.Loc.126.1>:
    return 0xB5;
  else if (frac < 6667)
    5366:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    536a:	0d 9c       	cmp	r12,	r13	;
    536c:	69 2c       	jc	$+212    	;abs 0x5440

0000536e <.Loc.128.1>:
    return 0xB6;
  else if (frac < 7001)
    536e:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    5372:	0d 9c       	cmp	r12,	r13	;
    5374:	69 2c       	jc	$+212    	;abs 0x5448

00005376 <.Loc.130.1>:
    return 0xD6;
  else if (frac < 7147)
    5376:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    537a:	0d 9c       	cmp	r12,	r13	;
    537c:	69 2c       	jc	$+212    	;abs 0x5450

0000537e <.Loc.132.1>:
    return 0xB7;
  else if (frac < 7503)
    537e:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    5382:	0d 9c       	cmp	r12,	r13	;
    5384:	69 2c       	jc	$+212    	;abs 0x5458

00005386 <.Loc.134.1>:
    return 0xBB;
  else if (frac < 7861)
    5386:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    538a:	0d 9c       	cmp	r12,	r13	;
    538c:	69 2c       	jc	$+212    	;abs 0x5460

0000538e <.Loc.136.1>:
    return 0xDD;
  else if (frac < 8004)
    538e:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    5392:	0d 9c       	cmp	r12,	r13	;
    5394:	69 2c       	jc	$+212    	;abs 0x5468

00005396 <.Loc.138.1>:
    return 0xED;
  else if (frac < 8333)
    5396:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    539a:	0d 9c       	cmp	r12,	r13	;
    539c:	69 2c       	jc	$+212    	;abs 0x5470

0000539e <.Loc.140.1>:
    return 0xEE;
  else if (frac < 8464)
    539e:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    53a2:	0d 9c       	cmp	r12,	r13	;
    53a4:	69 2c       	jc	$+212    	;abs 0x5478

000053a6 <.Loc.142.1>:
    return 0xBF;
  else if (frac < 8572)
    53a6:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    53aa:	0d 9c       	cmp	r12,	r13	;
    53ac:	69 2c       	jc	$+212    	;abs 0x5480

000053ae <.Loc.144.1>:
    return 0xDF;
  else if (frac < 8751)
    53ae:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    53b2:	0d 9c       	cmp	r12,	r13	;
    53b4:	69 2c       	jc	$+212    	;abs 0x5488

000053b6 <.Loc.146.1>:
    return 0xEF;
  else if (frac < 9004)
    53b6:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    53ba:	0d 9c       	cmp	r12,	r13	;
    53bc:	69 2c       	jc	$+212    	;abs 0x5490

000053be <.Loc.148.1>:
    return 0xF7;
  else if (frac < 9170)
    53be:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    53c2:	0d 9c       	cmp	r12,	r13	;
    53c4:	69 2c       	jc	$+212    	;abs 0x5498

000053c6 <.Loc.150.1>:
    return 0xFB;
  else if (frac < 9288)
    53c6:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    53ca:	0d 9c       	cmp	r12,	r13	;
    53cc:	69 28       	jnc	$+212    	;abs 0x54a0

000053ce <.Loc.151.1>:
    return 0xFD;
    53ce:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

000053d2 <.LVL17>:
    53d2:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000053d6 <.L3>:
    return 0x00;
    53d6:	4c 43       	clr.b	r12		;

000053d8 <.L2>:
  else
    return 0xFE;
}
    53d8:	10 01       	reta			;

000053da <.L4>:
    return 0x01;
    53da:	5c 43       	mov.b	#1,	r12	;r3 As==01

000053dc <.LVL21>:
    53dc:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000053e0 <.L12>:
    return 0x22;
    53e0:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

000053e4 <.LVL23>:
    53e4:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000053e8 <.L14>:
    return 0x25;
    53e8:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

000053ec <.LVL25>:
    53ec:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000053f0 <.L15>:
    return 0x49;
    53f0:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

000053f4 <.LVL27>:
    53f4:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000053f8 <.L16>:
    return 0x4A;
    53f8:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

000053fc <.LVL29>:
    53fc:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005400 <.L17>:
    return 0x52;
    5400:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00005404 <.LVL31>:
    5404:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005408 <.L18>:
    return 0x92;
    5408:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

0000540c <.LVL33>:
    540c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005410 <.L19>:
    return 0x53;
    5410:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00005414 <.LVL35>:
    5414:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005418 <.L20>:
    return 0x55;
    5418:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

0000541c <.LVL37>:
    541c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005420 <.L21>:
    return 0xAA;
    5420:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00005424 <.LVL39>:
    5424:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005428 <.L22>:
    return 0x6B;
    5428:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

0000542c <.LVL41>:
    542c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005430 <.L23>:
    return 0xAD;
    5430:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00005434 <.LVL43>:
    5434:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005438 <.L24>:
    return 0xB5;
    5438:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

0000543c <.LVL45>:
    543c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005440 <.L25>:
    return 0xB6;
    5440:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00005444 <.LVL47>:
    5444:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005448 <.L26>:
    return 0xD6;
    5448:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

0000544c <.LVL49>:
    544c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005450 <.L27>:
    return 0xB7;
    5450:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00005454 <.LVL51>:
    5454:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005458 <.L28>:
    return 0xBB;
    5458:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

0000545c <.LVL53>:
    545c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005460 <.L29>:
    return 0xDD;
    5460:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00005464 <.LVL55>:
    5464:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005468 <.L30>:
    return 0xED;
    5468:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

0000546c <.LVL57>:
    546c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005470 <.L31>:
    return 0xEE;
    5470:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00005474 <.LVL59>:
    5474:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005478 <.L32>:
    return 0xBF;
    5478:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

0000547c <.LVL61>:
    547c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005480 <.L33>:
    return 0xDF;
    5480:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

00005484 <.LVL63>:
    5484:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005488 <.L34>:
    return 0xEF;
    5488:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

0000548c <.LVL65>:
    548c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005490 <.L35>:
    return 0xF7;
    5490:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00005494 <.LVL67>:
    5494:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

00005498 <.L36>:
    return 0xFB;
    5498:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

0000549c <.LVL69>:
    549c:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000054a0 <.L37>:
    return 0xFE;
    54a0:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000054a4 <.LVL71>:
    54a4:	80 00 d8 53 	mova	#21464,	r0	;0x053d8

000054a8 <set_baud>:

static void set_baud(UARTDriver * uartp) {
    54a8:	6a 14       	pushm.a	#7,	r10	;20-bit words

000054aa <.LCFI0>:
    54aa:	b1 00 04 00 	suba	#4,	r1	;

000054ae <.LCFI1>:
    54ae:	c6 0c       	mova	r12,	r6	;

000054b0 <.Loc.157.1>:
  uint16_t n = uartp->freq / uartp->config->baud;
    54b0:	91 4c 12 00 	mov	18(r12),0(r1)	;0x00012
    54b4:	00 00 
    54b6:	91 4c 14 00 	mov	20(r12),2(r1)	;0x00014
    54ba:	02 00 
    54bc:	3c 0c 04 00 	mova	4(r12),	r12	;

000054c0 <.LVL73>:
    54c0:	14 4c 14 00 	mov	20(r12),r4	;0x00014
    54c4:	15 4c 16 00 	mov	22(r12),r5	;0x00016
    54c8:	87 00 66 64 	mova	#25702,	r7	;0x06466
    54cc:	0e 44       	mov	r4,	r14	;
    54ce:	0f 45       	mov	r5,	r15	;
    54d0:	2c 41       	mov	@r1,	r12	;
    54d2:	1d 41 02 00 	mov	2(r1),	r13	;
    54d6:	47 13       	calla	r7		;

000054d8 <.LVL74>:
    54d8:	09 4c       	mov	r12,	r9	;

000054da <.LVL75>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    54da:	88 00 a0 65 	mova	#26016,	r8	;0x065a0
    54de:	0e 44       	mov	r4,	r14	;
    54e0:	0f 45       	mov	r5,	r15	;
    54e2:	4d 43       	clr.b	r13		;
    54e4:	48 13       	calla	r8		;

000054e6 <.LVL76>:
    54e6:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    54ea:	4f 43       	clr.b	r15		;
    54ec:	2a 41       	mov	@r1,	r10	;
    54ee:	1b 41 02 00 	mov	2(r1),	r11	;
    54f2:	40 18 0a 8c 	subx.w	r12,	r10	;
    54f6:	40 18 0b 7d 	subcx.w	r13,	r11	;
    54fa:	0c 4a       	mov	r10,	r12	;
    54fc:	0d 4b       	mov	r11,	r13	;
    54fe:	48 13       	calla	r8		;

00005500 <.LVL77>:
    5500:	0e 44       	mov	r4,	r14	;
    5502:	0f 45       	mov	r5,	r15	;
    5504:	47 13       	calla	r7		;

00005506 <.LVL78>:
  if (n > 16) {
    5506:	7b 40 10 00 	mov.b	#16,	r11	;#0x0010
    550a:	0b 99       	cmp	r9,	r11	;
    550c:	10 28       	jnc	$+34     	;abs 0x552e

0000550e <.Loc.165.1>:
    uartp->regs->brw = (n >> 4);
    n = (n & 0x0F);
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
  }
  else {
    uartp->regs->brw = n;
    550e:	3e 06 16 00 	mova	22(r6),	r14	;0x00016
    5512:	8e 49 06 00 	mov	r9,	6(r14)	;

00005516 <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    5516:	3a 06 16 00 	mova	22(r6),	r10	;0x00016
    551a:	b0 13 7c 52 	calla	#21116		;0x0527c

0000551e <.LVL79>:
    551e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5522:	8a 4c 08 00 	mov	r12,	8(r10)	;

00005526 <.L46>:
  }
}
    5526:	a1 00 04 00 	adda	#4,	r1	;
    552a:	64 16       	popm.a	#7,	r10	;20-bit words
    552c:	10 01       	reta			;

0000552e <.L49>:
    uartp->regs->brw = (n >> 4);
    552e:	3e 06 16 00 	mova	22(r6),	r14	;0x00016
    5532:	0d 49       	mov	r9,	r13	;
    5534:	5d 0f       	rrum	#4,	r13	;
    5536:	8e 4d 06 00 	mov	r13,	6(r14)	;

0000553a <.LVL82>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    553a:	3a 06 16 00 	mova	22(r6),	r10	;0x00016
    553e:	b0 13 7c 52 	calla	#21116		;0x0527c

00005542 <.LVL83>:
    5542:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5546:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    554a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    554e:	0c d9       	bis	r9,	r12	;
    5550:	1c d3       	bis	#1,	r12	;r3 As==01
    5552:	8a 4c 08 00 	mov	r12,	8(r10)	;
    5556:	80 00 26 55 	mova	#21798,	r0	;0x05526

0000555a <uart_enter_rx_idle_loop>:
  }
}

static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
    555a:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

0000555e <.LVL85>:
    555e:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005562 <.Loc.198.1>:
}
    5562:	10 01       	reta			;

00005564 <rx_cb>:

static void rx_cb(void * arg){
    5564:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005566 <.LCFI2>:
    5566:	ca 0c       	mova	r12,	r10	;

00005568 <.LVL87>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5568:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    556c:	3c 0c 04 00 	mova	4(r12),	r12	;

00005570 <.LVL88>:
    5570:	3e 0c 08 00 	mova	8(r12),	r14	;
    5574:	9e 00 00 00 	cmpa	#0,	r14	;
    5578:	02 24       	jz	$+6      	;abs 0x557e

0000557a <.Loc.204.1>:
    557a:	cc 0a       	mova	r10,	r12	;
    557c:	4e 13       	calla	r14		;

0000557e <.L52>:
    557e:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    5582:	0c 24       	jz	$+26     	;abs 0x559c

00005584 <.L53>:
  chSysLockFromISR();
    5584:	b0 13 64 45 	calla	#17764		;0x04564

00005588 <.LBB33>:
  chThdResumeI(trp, msg);
    5588:	4d 43       	clr.b	r13		;
    558a:	cc 0a       	mova	r10,	r12	;
    558c:	ac 00 0a 00 	adda	#10,	r12	;0x0000a

00005590 <.LVL91>:
    5590:	b0 13 5a 49 	calla	#18778		;0x0495a

00005594 <.LBB35>:
  chSysUnlockFromISR();
    5594:	b0 13 86 45 	calla	#17798		;0x04586

00005598 <.LBE35>:
}
    5598:	0a 16       	popm.a	#1,	r10	;20-bit words
    559a:	10 01       	reta			;

0000559c <.L54>:
  _uart_rx_complete_isr_code(uartp);
    559c:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    55a0:	cc 0a       	mova	r10,	r12	;
    55a2:	b0 13 5a 55 	calla	#21850		;0x0555a

000055a6 <.LVL94>:
    55a6:	80 00 84 55 	mova	#21892,	r0	;0x05584

000055aa <tx_cb>:
static void tx_cb(void * arg) {
    55aa:	0a 14       	pushm.a	#1,	r10	;20-bit words

000055ac <.LCFI3>:
    55ac:	ca 0c       	mova	r12,	r10	;

000055ae <.LVL96>:
  _uart_tx1_isr_code(uartp);
    55ae:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    55b2:	3c 0c 04 00 	mova	4(r12),	r12	;

000055b6 <.LVL97>:
    55b6:	0e 0c       	mova	@r12,	r14	;
    55b8:	9e 00 00 00 	cmpa	#0,	r14	;
    55bc:	02 24       	jz	$+6      	;abs 0x55c2

000055be <.Loc.183.1>:
    55be:	cc 0a       	mova	r10,	r12	;
    55c0:	4e 13       	calla	r14		;

000055c2 <.L56>:
    55c2:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    55c6:	14 24       	jz	$+42     	;abs 0x55f0

000055c8 <.L57>:
    55c8:	ca 93 08 00 	cmp.b	#0,	8(r10)	;r3 As==00
    55cc:	15 20       	jnz	$+44     	;abs 0x55f8

000055ce <.L58>:
  if (uartp->txstate == UART_TX_IDLE) {
    55ce:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    55d2:	0c 20       	jnz	$+26     	;abs 0x55ec

000055d4 <.L60>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    55d4:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    55d8:	40 18 bc b2 	bitx.w	#8,	28(r12)	;r2 As==11, 0x0001c
    55dc:	1c 00 
    55de:	fa 27       	jz	$-10     	;abs 0x55d4

000055e0 <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    55e0:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

000055e4 <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    55e4:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    55e8:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

000055ec <.L55>:
}
    55ec:	0a 16       	popm.a	#1,	r10	;20-bit words
    55ee:	10 01       	reta			;

000055f0 <.L61>:
  _uart_tx1_isr_code(uartp);
    55f0:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00
    55f4:	80 00 c8 55 	mova	#21960,	r0	;0x055c8

000055f8 <.L62>:
  chSysLockFromISR();
    55f8:	b0 13 64 45 	calla	#17764		;0x04564

000055fc <.LBB39>:
  chThdResumeI(trp, msg);
    55fc:	4d 43       	clr.b	r13		;
    55fe:	cc 0a       	mova	r10,	r12	;
    5600:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00005604 <.LVL100>:
    5604:	b0 13 5a 49 	calla	#18778		;0x0495a

00005608 <.LBB41>:
  chSysUnlockFromISR();
    5608:	b0 13 86 45 	calla	#17798		;0x04586

0000560c <.LVL102>:
    560c:	80 00 ce 55 	mova	#21966,	r0	;0x055ce

00005610 <init_transfer>:
static void init_transfer(msp430x_dma_ch_t * dma, msp430x_dma_req_t * req, bool *acquired) {
    5610:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005612 <.LCFI4>:
    5612:	08 14       	pushm.a	#1,	r8	;20-bit words

00005614 <.LCFI5>:
    5614:	06 14       	pushm.a	#1,	r6	;20-bit words

00005616 <.LCFI6>:
    5616:	ca 0c       	mova	r12,	r10	;
    5618:	c6 0d       	mova	r13,	r6	;
    561a:	c8 0e       	mova	r14,	r8	;

0000561c <.Loc.171.1>:
  if (!(*acquired)) {
    561c:	ce 93 00 00 	cmp.b	#0,	0(r14)	;r3 As==00
    5620:	08 24       	jz	$+18     	;abs 0x5632

00005622 <.L64>:
  dmaTransferI(dma, req);
    5622:	cd 06       	mova	r6,	r13	;
    5624:	cc 0a       	mova	r10,	r12	;
    5626:	b0 13 78 51 	calla	#20856		;0x05178

0000562a <.LVL105>:
}
    562a:	06 16       	popm.a	#1,	r6	;20-bit words
    562c:	08 16       	popm.a	#1,	r8	;20-bit words
    562e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5630:	10 01       	reta			;

00005632 <.L65>:
    dmaAcquireI(dma);
    5632:	b0 13 94 50 	calla	#20628		;0x05094

00005636 <.LVL106>:
    (*acquired) = true;
    5636:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01
    563a:	80 00 22 56 	mova	#22050,	r0	;0x05622

0000563e <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
    563e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005640 <.LCFI8>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
#endif
  
#if MSP430X_UART_USE_UARTA1 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA1);
    5640:	8a 00 bc 1c 	mova	#7356,	r10	;0x01cbc
    5644:	cc 0a       	mova	r10,	r12	;
    5646:	b0 13 3e 4e 	calla	#20030		;0x04e3e

0000564a <.LVL132>:
  UARTDA1.regs = (msp430x_uart_reg_t  *)(&UCA1CTLW0);
    564a:	00 18 fa 40 	movx.a	#1504,	22(r10)	;0x005e0, 0x00016
    564e:	e0 05 16 00 

00005652 <.Loc.463.1>:
  UARTDA1.freq = MSP430X_UARTA1_CLK_FREQ;
    5652:	ba 40 00 24 	mov	#9216,	18(r10)	;#0x2400, 0x0012
    5656:	12 00 
    5658:	ba 40 f4 00 	mov	#244,	20(r10)	;#0x00f4, 0x0014
    565c:	14 00 

0000565e <.Loc.464.1>:
  UARTDA1.dmareq_tx.dest_addr = (void*)(&UCA1TXBUF);
    565e:	00 18 fa 40 	movx.a	#1518,	30(r10)	;0x005ee, 0x0001e
    5662:	ee 05 1e 00 

00005666 <.Loc.465.1>:
  UARTDA1.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    5666:	ba 40 00 03 	mov	#768,	36(r10)	;#0x0300, 0x0024
    566a:	24 00 

0000566c <.Loc.466.1>:
  UARTDA1.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    566c:	ba 40 c0 00 	mov	#192,	38(r10)	;#0x00c0, 0x0026
    5670:	26 00 

00005672 <.Loc.467.1>:
  UARTDA1.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    5672:	8a 43 28 00 	mov	#0,	40(r10)	;r3 As==00, 0x0028

00005676 <.Loc.468.1>:
  UARTDA1.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA1TXIFG);
    5676:	ba 40 11 00 	mov	#17,	42(r10)	;#0x0011, 0x002a
    567a:	2a 00 

0000567c <.Loc.469.1>:
  UARTDA1.dmareq_rx.source_addr = (void*)(&UCA1RXBUF);
    567c:	00 18 fa 40 	movx.a	#1516,	52(r10)	;0x005ec, 0x00034
    5680:	ec 05 34 00 

00005684 <.Loc.470.1>:
  UARTDA1.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    5684:	ba 40 00 0c 	mov	#3072,	62(r10)	;#0x0c00, 0x003e
    5688:	3e 00 

0000568a <.Loc.471.1>:
  UARTDA1.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    568a:	ba 40 c0 00 	mov	#192,	64(r10)	;#0x00c0, 0x0040
    568e:	40 00 

00005690 <.Loc.472.1>:
  UARTDA1.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    5690:	8a 43 42 00 	mov	#0,	66(r10)	;r3 As==00, 0x0042

00005694 <.Loc.473.1>:
  UARTDA1.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA1RXIFG);
    5694:	ba 40 10 00 	mov	#16,	68(r10)	;#0x0010, 0x0044
    5698:	44 00 

0000569a <.Loc.512.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    569a:	0a 16       	popm.a	#1,	r10	;20-bit words
    569c:	10 01       	reta			;

0000569e <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    569e:	0a 14       	pushm.a	#1,	r10	;20-bit words

000056a0 <.LCFI9>:
    56a0:	08 14       	pushm.a	#1,	r8	;20-bit words

000056a2 <.LCFI10>:
    56a2:	ca 0c       	mova	r12,	r10	;

000056a4 <.Loc.523.1>:

  if (uartp->state != UART_STOP) {
    56a4:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    56a8:	0c 24       	jz	$+26     	;abs 0x56c2

000056aa <.L89>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    56aa:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    56ae:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    56b2:	1c 00 
    56b4:	fa 27       	jz	$-10     	;abs 0x56aa

000056b6 <.Loc.528.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    56b6:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    56ba:	43 20       	jnz	$+136    	;abs 0x5742

000056bc <.L90>:
      dmaReleaseX(&(uartp->dma_tx));
    }
    if (uartp->dma_acquired_rx) {
    56bc:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    56c0:	47 20       	jnz	$+144    	;abs 0x5750

000056c2 <.L88>:
      dmaReleaseX(&(uartp->dma_rx));
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    56c2:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    56c6:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

000056ca <.Loc.538.1>:
  set_baud(uartp);
    56ca:	cc 0a       	mova	r10,	r12	;
    56cc:	b0 13 a8 54 	calla	#21672		;0x054a8

000056d0 <.LVL135>:
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    56d0:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    56d4:	3c 0a 04 00 	mova	4(r10),	r12	;
    56d8:	5c 4c 18 00 	mov.b	24(r12),r12	;0x00018
    56dc:	5c 0f       	rrum	#4,	r12	;
    56de:	5c 03       	rrum	#1,	r12	;
    56e0:	5c f3       	and.b	#1,	r12	;r3 As==01
    56e2:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    56e6:	8e 4c 10 00 	mov	r12,	16(r14)	; 0x0010

000056ea <.Loc.543.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    56ea:	3c 0a 04 00 	mova	4(r10),	r12	;
    56ee:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    56f2:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    56f6:	4c 4d       	mov.b	r13,	r12	;
    56f8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    56fa:	0e 9c       	cmp	r12,	r14	;
    56fc:	30 34       	jge	$+98     	;abs 0x575e

000056fe <.Loc.549.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_tx = !b;
  }
  else {
    uartp->dma_acquired_tx = false;
    56fe:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062

00005702 <.L94>:
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    5702:	3c 0a 04 00 	mova	4(r10),	r12	;
    5706:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    570a:	5d 0f       	rrum	#4,	r13	;
    570c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    570e:	0c 9d       	cmp	r13,	r12	;
    5710:	3e 34       	jge	$+126    	;abs 0x578e

00005712 <.Loc.557.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_rx = !b;
  }
  else {
    uartp->dma_acquired_rx = false;
    5712:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063

00005716 <.L98>:
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    5716:	00 18 fa 40 	movx.a	#21930,	44(r10)	;0x055aa, 0x0002c
    571a:	aa 55 2c 00 

0000571e <.Loc.562.1>:
  uartp->dmareq_tx.callback.args = uartp;
    571e:	7a 0a 30 00 	mova	r10,	48(r10)	; 0x00030

00005722 <.Loc.563.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    5722:	00 18 fa 40 	movx.a	#21860,	70(r10)	;0x05564, 0x00046
    5726:	64 55 46 00 

0000572a <.Loc.564.1>:
  uartp->dmareq_rx.callback.args = uartp;
    572a:	7a 0a 4a 00 	mova	r10,	74(r10)	; 0x0004a

0000572e <.Loc.578.1>:
        (UCRXEIE) | (UCBRKIE));

  }
#endif
#if MSP430X_UART_USE_UARTA1 == TRUE
  if (&UARTDA1 == uartp) {
    572e:	9a 00 bc 1c 	cmpa	#7356,	r10	;0x01cbc
    5732:	45 24       	jz	$+140    	;abs 0x57be

00005734 <.L99>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    5734:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5738:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

0000573c <.Loc.614.1>:
}
    573c:	08 16       	popm.a	#1,	r8	;20-bit words
    573e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5740:	10 01       	reta			;

00005742 <.L100>:
      dmaReleaseX(&(uartp->dma_tx));
    5742:	cc 0a       	mova	r10,	r12	;
    5744:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5748:	b0 13 06 52 	calla	#20998		;0x05206

0000574c <.LVL136>:
    574c:	80 00 bc 56 	mova	#22204,	r0	;0x056bc

00005750 <.L101>:
      dmaReleaseX(&(uartp->dma_rx));
    5750:	cc 0a       	mova	r10,	r12	;
    5752:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5756:	b0 13 06 52 	calla	#20998		;0x05206

0000575a <.LVL137>:
    575a:	80 00 c2 56 	mova	#22210,	r0	;0x056c2

0000575e <.L102>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    575e:	cc 0a       	mova	r10,	r12	;
    5760:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5764:	b0 13 1a 51 	calla	#20762		;0x0511a

00005768 <.LVL138>:
    5768:	c8 0c       	mova	r12,	r8	;

0000576a <.LVL139>:
    osalDbgAssert(!b, "stream already allocated");
    576a:	9c 00 00 00 	cmpa	#0,	r12	;
    576e:	09 20       	jnz	$+20     	;abs 0x5782

00005770 <.L92>:
    uartp->dma_acquired_tx = !b;
    5770:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5772:	98 00 00 00 	cmpa	#0,	r8	;
    5776:	01 24       	jz	$+4      	;abs 0x577a
    5778:	4c 43       	clr.b	r12		;

0000577a <.L93>:
    577a:	ca 4c 62 00 	mov.b	r12,	98(r10)	; 0x0062
    577e:	80 00 02 57 	mova	#22274,	r0	;0x05702

00005782 <.L105>:
    osalDbgAssert(!b, "stream already allocated");
    5782:	8c 00 3c 74 	mova	#29756,	r12	;0x0743c
    5786:	b0 13 72 47 	calla	#18290		;0x04772

0000578a <.LVL140>:
    578a:	80 00 70 57 	mova	#22384,	r0	;0x05770

0000578e <.L103>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    578e:	cc 0a       	mova	r10,	r12	;
    5790:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5794:	b0 13 1a 51 	calla	#20762		;0x0511a

00005798 <.LVL142>:
    5798:	c8 0c       	mova	r12,	r8	;

0000579a <.LVL143>:
    osalDbgAssert(!b, "stream already allocated");
    579a:	9c 00 00 00 	cmpa	#0,	r12	;
    579e:	09 20       	jnz	$+20     	;abs 0x57b2

000057a0 <.L96>:
    uartp->dma_acquired_rx = !b;
    57a0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    57a2:	98 00 00 00 	cmpa	#0,	r8	;
    57a6:	01 24       	jz	$+4      	;abs 0x57aa
    57a8:	4c 43       	clr.b	r12		;

000057aa <.L97>:
    57aa:	ca 4c 63 00 	mov.b	r12,	99(r10)	; 0x0063
    57ae:	80 00 16 57 	mova	#22294,	r0	;0x05716

000057b2 <.L106>:
    osalDbgAssert(!b, "stream already allocated");
    57b2:	8c 00 3c 74 	mova	#29756,	r12	;0x0743c
    57b6:	b0 13 72 47 	calla	#18290		;0x04772

000057ba <.LVL144>:
    57ba:	80 00 a0 57 	mova	#22432,	r0	;0x057a0

000057be <.L104>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    57be:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    57c2:	3e 0a 04 00 	mova	4(r10),	r14	;
    57c6:	5d 4e 18 00 	mov.b	24(r14),r13	;0x00018
    57ca:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;

000057ce <.Loc.580.1>:
        (uartp->config->order << 13) | 
    57ce:	5e 4e 18 00 	mov.b	24(r14),r14	;0x00018
    57d2:	0f 4e       	mov	r14,	r15	;
    57d4:	5f 07       	rrum	#2,	r15	;
    57d6:	5f f3       	and.b	#1,	r15	;r3 As==01
    57d8:	4c 18 0f 5f 	rpt #13 { rlax.w	r15		;

000057dc <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    57dc:	0d df       	bis	r15,	r13	;

000057de <.Loc.581.1>:
        (uartp->config->char_size << 12) | 
    57de:	0f 4e       	mov	r14,	r15	;
    57e0:	5f 0b       	rrum	#3,	r15	;
    57e2:	5f f3       	and.b	#1,	r15	;r3 As==01
    57e4:	4b 18 0f 5f 	rpt #12 { rlax.w	r15		;

000057e8 <.Loc.580.1>:
        (uartp->config->order << 13) | 
    57e8:	0d df       	bis	r15,	r13	;

000057ea <.Loc.582.1>:
        (uartp->config->stop_bits << 11) |
    57ea:	0f 4e       	mov	r14,	r15	;
    57ec:	5f 0f       	rrum	#4,	r15	;
    57ee:	5f f3       	and.b	#1,	r15	;r3 As==01
    57f0:	4a 18 0f 5f 	rpt #11 { rlax.w	r15		;

000057f4 <.Loc.581.1>:
        (uartp->config->char_size << 12) | 
    57f4:	0d df       	bis	r15,	r13	;

000057f6 <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    57f6:	5e 0f       	rrum	#4,	r14	;
    57f8:	5e 03       	rrum	#1,	r14	;
    57fa:	5e f3       	and.b	#1,	r14	;r3 As==01
    57fc:	0f 4e       	mov	r14,	r15	;
    57fe:	49 18 0f 5f 	rpt #10 { rlax.w	r15		;

00005802 <.Loc.582.1>:
        (uartp->config->stop_bits << 11) |
    5802:	0d df       	bis	r15,	r13	;

00005804 <.Loc.583.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5804:	48 18 0e 5e 	rpt #9 { rlax.w	r14		;
    5808:	0d de       	bis	r14,	r13	;

0000580a <.Loc.579.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    580a:	3d d0 b0 00 	bis	#176,	r13	;#0x00b0
    580e:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5812:	80 00 34 57 	mova	#22324,	r0	;0x05734

00005816 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    5816:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005818 <.LCFI13>:
    5818:	ca 0c       	mova	r12,	r10	;

0000581a <.Loc.647.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    581a:	7c 0e 1a 00 	mova	r14,	26(r12)	; 0x0001a

0000581e <.Loc.648.1>:
  uartp->dmareq_tx.size = n;
    581e:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

00005822 <.L111>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    5822:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5826:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    582a:	1c 00 
    582c:	fa 27       	jz	$-10     	;abs 0x5822

0000582e <.Loc.651.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    582e:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

00005832 <.Loc.653.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    5832:	ce 0a       	mova	r10,	r14	;

00005834 <.LVL152>:
    5834:	ae 00 62 00 	adda	#98,	r14	;0x00062
    5838:	cd 0a       	mova	r10,	r13	;

0000583a <.LVL153>:
    583a:	ad 00 1a 00 	adda	#26,	r13	;0x0001a
    583e:	cc 0a       	mova	r10,	r12	;
    5840:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5844:	b0 13 10 56 	calla	#22032		;0x05610

00005848 <.LVL154>:
  
  uartp->regs->ifg |= UCTXIFG;
    5848:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    584c:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00005850 <.Loc.656.1>:
}
    5850:	0a 16       	popm.a	#1,	r10	;20-bit words
    5852:	10 01       	reta			;

00005854 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    5854:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005856 <.LCFI16>:
    5856:	ca 0c       	mova	r12,	r10	;

00005858 <.Loc.694.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    5858:	7c 0e 38 00 	mova	r14,	56(r12)	; 0x00038

0000585c <.Loc.695.1>:
  uartp->dmareq_rx.size = n;
    585c:	8c 4d 3c 00 	mov	r13,	60(r12)	; 0x003c

00005860 <.Loc.698.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    5860:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00005864 <.LVL160>:
    5864:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00005868 <.Loc.700.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    5868:	ce 0a       	mova	r10,	r14	;

0000586a <.LVL161>:
    586a:	ae 00 63 00 	adda	#99,	r14	;0x00063
    586e:	cd 0a       	mova	r10,	r13	;

00005870 <.LVL162>:
    5870:	ad 00 34 00 	adda	#52,	r13	;0x00034
    5874:	cc 0a       	mova	r10,	r12	;
    5876:	ac 00 58 00 	adda	#88,	r12	;0x00058
    587a:	b0 13 10 56 	calla	#22032		;0x05610

0000587e <.LVL163>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    587e:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5882:	40 18 9c b3 	bitx.w	#1,	28(r12)	;r3 As==01, 0x0001c
    5886:	1c 00 
    5888:	06 24       	jz	$+14     	;abs 0x5896

0000588a <.Loc.704.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    588a:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

0000588e <.Loc.705.1>:
    uartp->regs->ifg |= UCRXIFG;
    588e:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5892:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00005896 <.L115>:
  }
}
    5896:	0a 16       	popm.a	#1,	r10	;20-bit words
    5898:	10 01       	reta			;

0000589a <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    589a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000589c <.LCFI17>:
    589c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000589e <.LCFI18>:
    589e:	06 14       	pushm.a	#1,	r6	;20-bit words

000058a0 <.LCFI19>:
    58a0:	ca 0c       	mova	r12,	r10	;

000058a2 <.Loc.722.1>:

  size_t result = uartp->dma_rx.registers->sz;
    58a2:	3c 0c 58 00 	mova	88(r12),r12	;0x00058

000058a6 <.LVL165>:
    58a6:	40 18 18 4c 	movx.w	10(r12),r8	;0x0000a
    58aa:	0a 00 

000058ac <.Loc.723.1>:
  dmaCancelI(&(uartp->dma_rx));
    58ac:	c6 0a       	mova	r10,	r6	;
    58ae:	a6 00 58 00 	adda	#88,	r6	;0x00058
    58b2:	cc 06       	mova	r6,	r12	;
    58b4:	b0 13 42 52 	calla	#21058		;0x05242

000058b8 <.LVL167>:
  if (uartp->dma_acquired_rx) {
    58b8:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    58bc:	0d 20       	jnz	$+28     	;abs 0x58d8

000058be <.L118>:
    dmaReleaseX(&(uartp->dma_rx));
  }
  
  uartp->regs->ifg &= ~UCRXIFG;
    58be:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    58c2:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

000058c6 <.Loc.729.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    58c6:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    58ca:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

000058ce <.Loc.732.1>:

  return result;
}
    58ce:	cc 08       	mova	r8,	r12	;
    58d0:	06 16       	popm.a	#1,	r6	;20-bit words
    58d2:	08 16       	popm.a	#1,	r8	;20-bit words
    58d4:	0a 16       	popm.a	#1,	r10	;20-bit words
    58d6:	10 01       	reta			;

000058d8 <.L119>:
    dmaReleaseX(&(uartp->dma_rx));
    58d8:	cc 06       	mova	r6,	r12	;
    58da:	b0 13 06 52 	calla	#20998		;0x05206

000058de <.LVL168>:
    58de:	80 00 be 58 	mova	#22718,	r0	;0x058be

000058e2 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    58e2:	8c 00 20 1d 	mova	#7456,	r12	;0x01d20
    58e6:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    58ea:	80 03 06 00 

000058ee <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    58ee:	b0 13 8c 4d 	calla	#19852		;0x04d8c

000058f2 <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    58f2:	10 01       	reta			;

000058f4 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    58f4:	2a 14       	pushm.a	#3,	r10	;20-bit words

000058f6 <.LCFI0>:
    58f6:	ca 0c       	mova	r12,	r10	;

000058f8 <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    58f8:	9c 00 20 1d 	cmpa	#7456,	r12	;0x01d20
    58fc:	29 24       	jz	$+84     	;abs 0x5950

000058fe <.Loc.286.1>:
  uint32_t divider = 0;
    58fe:	48 43       	clr.b	r8		;
    5900:	49 43       	clr.b	r9		;

00005902 <.L3>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5902:	09 93       	cmp	#0,	r9	;r3 As==00
    5904:	3c 20       	jnz	$+122    	;abs 0x597e
    5906:	09 93       	cmp	#0,	r9	;r3 As==00
    5908:	36 24       	jz	$+110    	;abs 0x5976

0000590a <.L4>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    590a:	0c 48       	mov	r8,	r12	;
    590c:	7c f0 07 00 	and.b	#7,	r12	;
    5910:	0c 93       	cmp	#0,	r12	;r3 As==00
    5912:	3b 20       	jnz	$+120    	;abs 0x598a

00005914 <.Loc.345.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    5914:	3c 0a 06 00 	mova	6(r10),	r12	;
    5918:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    591c:	00 00 

0000591e <.Loc.346.1>:
    divider /= 8;
    591e:	0c 48       	mov	r8,	r12	;
    5920:	0d 49       	mov	r9,	r13	;
    5922:	b0 13 7e 65 	calla	#25982		;0x0657e
    5926:	08 4c       	mov	r12,	r8	;

00005928 <.LVL5>:
    5928:	09 4d       	mov	r13,	r9	;

0000592a <.L7>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    592a:	09 93       	cmp	#0,	r9	;r3 As==00
    592c:	05 20       	jnz	$+12     	;abs 0x5938
    592e:	09 93       	cmp	#0,	r9	;r3 As==00
    5930:	07 20       	jnz	$+16     	;abs 0x5940
    5932:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5934:	0d 98       	cmp	r8,	r13	;
    5936:	04 2c       	jc	$+10     	;abs 0x5940

00005938 <.L13>:
    5938:	8c 00 5e 74 	mova	#29790,	r12	;0x0745e
    593c:	b0 13 72 47 	calla	#18290		;0x04772

00005940 <.L9>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    5940:	3c 0a 06 00 	mova	6(r10),	r12	;
    5944:	0d 48       	mov	r8,	r13	;
    5946:	3d 53       	add	#-1,	r13	;r3 As==11
    5948:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

0000594c <.Loc.359.1>:

}
    594c:	28 16       	popm.a	#3,	r10	;20-bit words
    594e:	10 01       	reta			;

00005950 <.L14>:
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    5950:	3c 0c 06 00 	mova	6(r12),	r12	;
    5954:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    5958:	00 00 

0000595a <.Loc.304.1>:
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    595a:	3c 0a 02 00 	mova	2(r10),	r12	;
    595e:	2e 4c       	mov	@r12,	r14	;
    5960:	1f 4c 02 00 	mov	2(r12),	r15	;
    5964:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    5968:	4d 43       	clr.b	r13		;
    596a:	b0 13 66 64 	calla	#25702		;0x06466
    596e:	08 4c       	mov	r12,	r8	;
    5970:	09 4d       	mov	r13,	r9	;

00005972 <.LVL10>:
    5972:	80 00 02 59 	mova	#22786,	r0	;0x05902

00005976 <.L15>:
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5976:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    597a:	0c 98       	cmp	r8,	r12	;
    597c:	c6 2f       	jc	$-114    	;abs 0x590a

0000597e <.L12>:
    597e:	8c 00 5e 74 	mova	#29790,	r12	;0x0745e
    5982:	b0 13 72 47 	calla	#18290		;0x04772

00005986 <.LVL11>:
    5986:	80 00 0a 59 	mova	#22794,	r0	;0x0590a

0000598a <.L6>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    598a:	0c 48       	mov	r8,	r12	;
    598c:	7c f0 03 00 	and.b	#3,	r12	;
    5990:	0c 93       	cmp	#0,	r12	;r3 As==00
    5992:	0d 20       	jnz	$+28     	;abs 0x59ae

00005994 <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    5994:	3c 0a 06 00 	mova	6(r10),	r12	;
    5998:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    599c:	00 00 

0000599e <.Loc.350.1>:
    divider /= 4;
    599e:	40 19 09 10 	rrux.w	r9		;
    59a2:	08 10       	rrc	r8		;
    59a4:	40 19 09 10 	rrux.w	r9		;
    59a8:	08 10       	rrc	r8		;
    59aa:	80 00 2a 59 	mova	#22826,	r0	;0x0592a

000059ae <.L8>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    59ae:	0c 48       	mov	r8,	r12	;
    59b0:	5c f3       	and.b	#1,	r12	;r3 As==01
    59b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    59b4:	ba 23       	jnz	$-138    	;abs 0x592a

000059b6 <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    59b6:	3c 0a 06 00 	mova	6(r10),	r12	;
    59ba:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    59be:	00 00 

000059c0 <.Loc.354.1>:
    divider /= 2;
    59c0:	12 c3       	clrc			
    59c2:	09 10       	rrc	r9		;
    59c4:	08 10       	rrc	r8		;
    59c6:	80 00 2a 59 	mova	#22826,	r0	;0x0592a

000059ca <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    59ca:	3e 0c 02 00 	mova	2(r12),	r14	;
    59ce:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    59d2:	04 00 
    59d4:	04 24       	jz	$+10     	;abs 0x59de

000059d6 <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    59d6:	3e 0c 06 00 	mova	6(r12),	r14	;
    59da:	ae d3 00 00 	bis	#2,	0(r14)	;r3 As==10

000059de <.L20>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
    59de:	3e 0c 06 00 	mova	6(r12),	r14	;
    59e2:	ae d2 00 00 	bis	#4,	0(r14)	;r2 As==10

000059e6 <.Loc.395.1>:
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    59e6:	3e 0c 06 00 	mova	6(r12),	r14	;
    59ea:	8e 4d 12 00 	mov	r13,	18(r14)	; 0x0012

000059ee <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    59ee:	3c 0c 06 00 	mova	6(r12),	r12	;

000059f2 <.LVL19>:
    59f2:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    59f6:	00 00 

000059f8 <.Loc.398.1>:
}
    59f8:	10 01       	reta			;

000059fa <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    59fa:	3c 0c 06 00 	mova	6(r12),	r12	;

000059fe <.LVL21>:
    59fe:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    5a02:	00 00 

00005a04 <.Loc.412.1>:

}
    5a04:	10 01       	reta			;

00005a06 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    5a06:	32 c2       	dint			
    5a08:	03 43       	nop			

00005a0a <.Loc.46.1>:

}
    5a0a:	10 01       	reta			;

00005a0c <send_complete_cb>:
  chEvtSignalI(uart_thd, UARTRxBufferReady);
}

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
    5a0c:	b0 13 64 45 	calla	#17764		;0x04564

00005a10 <.LVL1>:
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    5a10:	00 18 c2 43 	movx.a	#0,	&0x075ca;r3 As==00
    5a14:	ca 75 

00005a16 <.Loc.56.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    5a16:	40 18 f2 d0 	bisx.b	#3,	&0xf9df4;
    5a1a:	03 00 f4 9d 

00005a1e <.LBB28>:
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
    5a1e:	b0 13 f6 45 	calla	#17910		;0x045f6

00005a22 <.LVL3>:

  return chSemGetCounterI(&mbp->fullsem);
    5a22:	40 18 1c 42 	movx.w	&0x075de,r12	;
    5a26:	de 75 

00005a28 <.LBE28>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    5a28:	4d 43       	clr.b	r13		;
    5a2a:	0d 9c       	cmp	r12,	r13	;
    5a2c:	06 34       	jge	$+14     	;abs 0x5a3a

00005a2e <.Loc.59.1>:
    events |= UARTBufferPosted;
    5a2e:	40 18 a2 d3 	bisx.w	#2,	&0xf9df0;r3 As==10
    5a32:	f0 9d 
    5a34:	40 18 82 dd 	bisx.w	r13,	&0xf9df2;
    5a38:	f2 9d 

00005a3a <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    5a3a:	2c 00 ec 9d 	mova	&40428,	r12	;0x09dec
    5a3e:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    5a42:	03 20       	jnz	$+8      	;abs 0x5a4a

00005a44 <.L3>:
    chSchReadyI(uart_thd, MSG_RESET);
  }
  chSysUnlockFromISR();
    5a44:	b0 13 86 45 	calla	#17798		;0x04586

00005a48 <.LVL5>:
}
    5a48:	10 01       	reta			;

00005a4a <.L4>:
    chSchReadyI(uart_thd, MSG_RESET);
    5a4a:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    5a4e:	b0 13 44 48 	calla	#18500		;0x04844

00005a52 <.LVL6>:
    5a52:	80 00 44 5a 	mova	#23108,	r0	;0x05a44

00005a56 <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    5a56:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005a58 <.LCFI1>:
    5a58:	ca 0c       	mova	r12,	r10	;
    5a5a:	09 4d       	mov	r13,	r9	;

00005a5c <.LBB30>:
  _disable_interrupts();
    5a5c:	32 c2       	dint			
    5a5e:	03 43       	nop			

00005a60 <.Loc.348.3>:
  asm volatile("nop");
    5a60:	03 43       	nop			

00005a62 <.LBE30>:
  chSysLock();
    5a62:	b0 13 22 45 	calla	#17698		;0x04522

00005a66 <.LVL17>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    5a66:	0e 49       	mov	r9,	r14	;
    5a68:	cd 0a       	mova	r10,	r13	;
    5a6a:	8c 00 ce 75 	mova	#30158,	r12	;0x075ce
    5a6e:	b0 13 e2 4a 	calla	#19170		;0x04ae2

00005a72 <.LVL18>:
    5a72:	ca 0c       	mova	r12,	r10	;

00005a74 <.LVL19>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    5a74:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5a76:	4e 43       	clr.b	r14		;
    5a78:	2c 00 ec 9d 	mova	&40428,	r12	;0x09dec
    5a7c:	b0 13 10 4a 	calla	#18960		;0x04a10

00005a80 <.LVL20>:
  chSysUnlock();
    5a80:	b0 13 42 45 	calla	#17730		;0x04542

00005a84 <.LBB32>:
  asm volatile("nop");
    5a84:	03 43       	nop			

00005a86 <.Loc.356.3>:
  _enable_interrupts();
    5a86:	03 43       	nop			
    5a88:	32 d2       	eint			
    5a8a:	03 43       	nop			

00005a8c <.LBE32>:
}
    5a8c:	cc 0a       	mova	r10,	r12	;
    5a8e:	19 16       	popm.a	#2,	r10	;20-bit words
    5a90:	10 01       	reta			;

00005a92 <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 256);
THD_FUNCTION(UARTThd, arg) {
    5a92:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005a94 <.LCFI2>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    5a94:	00 18 d2 42 	movx.a	&0x01c00,&0xf9dec;
    5a98:	00 1c ec 9d 

00005a9c <.Loc.98.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    5a9c:	40 18 f2 40 	movx.b	#7,	&0xf9df4;
    5aa0:	07 00 f4 9d 

00005aa4 <.LBB34>:
  _disable_interrupts();
    5aa4:	32 c2       	dint			
    5aa6:	03 43       	nop			

00005aa8 <.Loc.348.3>:
  asm volatile("nop");
    5aa8:	03 43       	nop			

00005aaa <.LBE34>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    5aaa:	b0 13 22 45 	calla	#17698		;0x04522

00005aae <.LVL24>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    5aae:	00 18 c2 93 	cmpx.a	#0,	&0x075ca;r3 As==00
    5ab2:	ca 75 
    5ab4:	1e 24       	jz	$+62     	;abs 0x5af2

00005ab6 <.L17>:
    events |= UARTBufferPosted;
    5ab6:	40 18 a2 d3 	bisx.w	#2,	&0xf9df0;r3 As==10
    5aba:	f0 9d 
    5abc:	40 18 82 d3 	bisx.w	#0,	&0xf9df2;r3 As==00
    5ac0:	f2 9d 

00005ac2 <.L18>:
  }
  chSysUnlock();
    5ac2:	b0 13 42 45 	calla	#17730		;0x04542

00005ac6 <.LBB36>:
  asm volatile("nop");
    5ac6:	03 43       	nop			

00005ac8 <.Loc.356.3>:
  _enable_interrupts();
    5ac8:	03 43       	nop			
    5aca:	32 d2       	eint			
    5acc:	03 43       	nop			

00005ace <.LBE36>:
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    5ace:	40 18 92 d3 	bisx.w	#1,	&0xf9df0;r3 As==01
    5ad2:	f0 9d 
    5ad4:	40 18 82 d3 	bisx.w	#0,	&0xf9df2;r3 As==00
    5ad8:	f2 9d 

00005ada <.Loc.111.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    5ada:	8d 00 b4 74 	mova	#29876,	r13	;0x074b4
    5ade:	8c 00 20 1d 	mova	#7456,	r12	;0x01d20
    5ae2:	b0 13 98 4d 	calla	#19864		;0x04d98

00005ae6 <.LVL26>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    5ae6:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    5aea:	b0 13 a4 60 	calla	#24740		;0x060a4

00005aee <.LVL27>:
    5aee:	80 00 02 5c 	mova	#23554,	r0	;0x05c02

00005af2 <.L29>:
  chDbgCheckClassI();
    5af2:	b0 13 f6 45 	calla	#17910		;0x045f6

00005af6 <.LVL29>:
  return chSemGetCounterI(&mbp->fullsem);
    5af6:	40 18 1c 42 	movx.w	&0x075de,r12	;
    5afa:	de 75 

00005afc <.LBE38>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    5afc:	4d 43       	clr.b	r13		;
    5afe:	0d 9c       	cmp	r12,	r13	;
    5b00:	da 3b       	jl	$-74     	;abs 0x5ab6
    5b02:	80 00 c2 5a 	mova	#23234,	r0	;0x05ac2

00005b06 <.L31>:
  _disable_interrupts();
    5b06:	32 c2       	dint			
    5b08:	03 43       	nop			

00005b0a <.Loc.348.3>:
  asm volatile("nop");
    5b0a:	03 43       	nop			

00005b0c <.LBE40>:
  
  msg_t result;
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
    5b0c:	b0 13 22 45 	calla	#17698		;0x04522

00005b10 <.LVL31>:
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    5b10:	2a 00 c0 74 	mova	&29888,	r10	;0x074c0
    5b14:	5c 4a 26 00 	mov.b	38(r10),r12	;0x00026
    5b18:	8e 00 c8 75 	mova	#30152,	r14	;0x075c8
    5b1c:	4f 4c       	mov.b	r12,	r15	;
    5b1e:	7f f0 03 00 	and.b	#3,	r15	;
    5b22:	6d 4e       	mov.b	@r14,	r13	;
    5b24:	7d f0 fc ff 	and.b	#-4,	r13	;#0xfffc
    5b28:	4d df       	bis.b	r15,	r13	;

00005b2a <.Loc.124.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    5b2a:	0f 4c       	mov	r12,	r15	;
    5b2c:	5f 07       	rrum	#2,	r15	;
    5b2e:	5f f3       	and.b	#1,	r15	;r3 As==01
    5b30:	43 18 0f 5f 	rpt #4 { rlax.w	r15		;
    5b34:	7d f0 ef ff 	and.b	#-17,	r13	;#0xffef
    5b38:	4d df       	bis.b	r15,	r13	;

00005b3a <.Loc.126.1>:
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    5b3a:	5c 0b       	rrum	#3,	r12	;
    5b3c:	5c f3       	and.b	#1,	r12	;r3 As==01
    5b3e:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    5b42:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    5b46:	4d dc       	bis.b	r12,	r13	;
    5b48:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00005b4c <.Loc.128.1>:
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    5b4c:	58 4a 22 00 	mov.b	34(r10),r8	;0x00022
    5b50:	09 43       	clr	r9		;

00005b52 <.Loc.129.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    5b52:	5c 4a 23 00 	mov.b	35(r10),r12	;0x00023
    5b56:	0d 43       	clr	r13		;
    5b58:	b0 13 be 64 	calla	#25790		;0x064be
    5b5c:	09 4d       	mov	r13,	r9	;

00005b5e <.Loc.128.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    5b5e:	08 dc       	bis	r12,	r8	;

00005b60 <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    5b60:	5c 4a 24 00 	mov.b	36(r10),r12	;0x00024
    5b64:	0d 43       	clr	r13		;
    5b66:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    5b6a:	b0 13 e6 64 	calla	#25830		;0x064e6

00005b6e <.Loc.129.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    5b6e:	08 dc       	bis	r12,	r8	;
    5b70:	09 dd       	bis	r13,	r9	;

00005b72 <.Loc.131.1>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
    5b72:	5c 4a 25 00 	mov.b	37(r10),r12	;0x00025
    5b76:	0d 43       	clr	r13		;
    5b78:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    5b7c:	b0 13 e6 64 	calla	#25830		;0x064e6

00005b80 <.Loc.128.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    5b80:	8a 00 b0 75 	mova	#30128,	r10	;0x075b0
    5b84:	08 dc       	bis	r12,	r8	;
    5b86:	8a 48 14 00 	mov	r8,	20(r10)	; 0x0014
    5b8a:	09 dd       	bis	r13,	r9	;
    5b8c:	8a 49 16 00 	mov	r9,	22(r10)	; 0x0016

00005b90 <.Loc.133.1>:
      
      chSysUnlock();
    5b90:	b0 13 42 45 	calla	#17730		;0x04542

00005b94 <.LBB42>:
  asm volatile("nop");
    5b94:	03 43       	nop			

00005b96 <.Loc.356.3>:
  _enable_interrupts();
    5b96:	03 43       	nop			
    5b98:	32 d2       	eint			
    5b9a:	03 43       	nop			

00005b9c <.LBE42>:
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    5b9c:	cd 0a       	mova	r10,	r13	;
    5b9e:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    5ba2:	b0 13 62 4e 	calla	#20066		;0x04e62

00005ba6 <.LVL36>:
      events &= ~UARTConfigUpdated;
    5ba6:	40 18 92 c3 	bicx.w	#1,	&0xf9df0;r3 As==01
    5baa:	f0 9d 
    5bac:	40 18 82 c3 	bicx.w	#0,	&0xf9df2;r3 As==00
    5bb0:	f2 9d 
    5bb2:	80 00 0a 5c 	mova	#23562,	r0	;0x05c0a

00005bb6 <.L25>:
          events &= ~UARTBufferPosted;
          chSysUnlock();
          /* Skip to the next loop */
          continue;
        }
        chSysUnlock();
    5bb6:	b0 13 42 45 	calla	#17730		;0x04542

00005bba <.LBB44>:
  asm volatile("nop");
    5bba:	03 43       	nop			

00005bbc <.Loc.356.3>:
  _enable_interrupts();
    5bbc:	03 43       	nop			
    5bbe:	32 d2       	eint			
    5bc0:	03 43       	nop			

00005bc2 <.L24>:
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    5bc2:	2d 00 ca 75 	mova	&30154,	r13	;0x075ca
    5bc6:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    5bca:	b0 13 ea 5f 	calla	#24554		;0x05fea

00005bce <.LVL39>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    5bce:	c0 1f f2 f0 	andx.b	#-4,	&0xf9df4;0xffffc
    5bd2:	fc ff f4 9d 

00005bd6 <.Loc.158.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    5bd6:	40 18 a2 c3 	bicx.w	#2,	&0xf9df0;r3 As==10
    5bda:	f0 9d 
    5bdc:	40 18 82 c3 	bicx.w	#0,	&0xf9df2;r3 As==00
    5be0:	f2 9d 

00005be2 <.L22>:
    }
    if (events & UARTRxBufferReady) {
    5be2:	40 18 e2 b2 	bitx.b	#4,	&0xf9df0;r2 As==10
    5be6:	f0 9d 
    5be8:	35 20       	jnz	$+108    	;abs 0x5c54

00005bea <.L27>:
      
      elyUARTDLLRxHandleBuffer();
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    }
    /* Get next events */
    events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    5bea:	4e 43       	clr.b	r14		;
    5bec:	5c 42 f4 9d 	mov.b	&0x9df4,r12	;0x9df4
    5bf0:	0d 43       	clr	r13		;
    5bf2:	b0 13 56 4a 	calla	#19030		;0x04a56

00005bf6 <.LVL40>:
    5bf6:	40 18 82 4c 	movx.w	r12,	&0xf9df0;
    5bfa:	f0 9d 
    5bfc:	40 18 82 4d 	movx.w	r13,	&0xf9df2;
    5c00:	f2 9d 

00005c02 <.L19>:
    if (events & UARTConfigUpdated) {
    5c02:	40 18 d2 b3 	bitx.b	#1,	&0xf9df0;r3 As==01
    5c06:	f0 9d 
    5c08:	7e 23       	jnz	$-258    	;abs 0x5b06

00005c0a <.L20>:
    if (events & UARTBufferPosted) {
    5c0a:	40 18 e2 b3 	bitx.b	#2,	&0xf9df0;r3 As==10
    5c0e:	f0 9d 
    5c10:	e8 27       	jz	$-46     	;abs 0x5be2

00005c12 <.Loc.139.1>:
      if (NULL == tx_active_buffer) {
    5c12:	00 18 c2 93 	cmpx.a	#0,	&0x075ca;r3 As==00
    5c16:	ca 75 
    5c18:	d4 23       	jnz	$-86     	;abs 0x5bc2

00005c1a <.LBB46>:
  _disable_interrupts();
    5c1a:	32 c2       	dint			
    5c1c:	03 43       	nop			

00005c1e <.Loc.348.3>:
  asm volatile("nop");
    5c1e:	03 43       	nop			

00005c20 <.LBE46>:
        chSysLock();
    5c20:	b0 13 22 45 	calla	#17698		;0x04522

00005c24 <.LVL41>:
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    5c24:	3e 43       	mov	#-1,	r14	;r3 As==11
    5c26:	8d 00 ca 75 	mova	#30154,	r13	;0x075ca
    5c2a:	8c 00 ce 75 	mova	#30158,	r12	;0x075ce
    5c2e:	b0 13 40 4b 	calla	#19264		;0x04b40

00005c32 <.LVL42>:
        if (result != MSG_OK) {
    5c32:	9c 00 00 00 	cmpa	#0,	r12	;
    5c36:	bf 27       	jz	$-128    	;abs 0x5bb6

00005c38 <.Loc.144.1>:
          events &= ~UARTBufferPosted;
    5c38:	40 18 a2 c3 	bicx.w	#2,	&0xf9df0;r3 As==10
    5c3c:	f0 9d 
    5c3e:	40 18 82 c3 	bicx.w	#0,	&0xf9df2;r3 As==00
    5c42:	f2 9d 

00005c44 <.Loc.145.1>:
          chSysUnlock();
    5c44:	b0 13 42 45 	calla	#17730		;0x04542

00005c48 <.LBB48>:
  asm volatile("nop");
    5c48:	03 43       	nop			

00005c4a <.Loc.356.3>:
  _enable_interrupts();
    5c4a:	03 43       	nop			
    5c4c:	32 d2       	eint			
    5c4e:	03 43       	nop			

00005c50 <.LBE48>:
          continue;
    5c50:	80 00 02 5c 	mova	#23554,	r0	;0x05c02

00005c54 <.L30>:
      elyUARTDLLRxHandleBuffer();
    5c54:	b0 13 ae 60 	calla	#24750		;0x060ae

00005c58 <.LVL44>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    5c58:	40 18 a2 c2 	bicx.w	#4,	&0xf9df0;r2 As==10
    5c5c:	f0 9d 
    5c5e:	40 18 82 c3 	bicx.w	#0,	&0xf9df2;r3 As==00
    5c62:	f2 9d 
    5c64:	80 00 ea 5b 	mova	#23530,	r0	;0x05bea

00005c68 <fw_allocator>:

#include "main.h"

static uint8_t PERSIST fw_storage[elyFWTotalBuffer];

void * fw_allocator(size_t size, unsigned align) {
    5c68:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005c6a <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyFWTotalBuffer) {
    5c6a:	2e 00 1e 76 	mova	&30238,	r14	;0x0761e
    5c6e:	ca 0e       	mova	r14,	r10	;
    5c70:	ea 0c       	adda	r12,	r10	;
    5c72:	3c 40 10 04 	mov	#1040,	r12	;#0x0410

00005c76 <.LVL1>:
    5c76:	dc 0a       	cmpa	r10,	r12	;
    5c78:	07 28       	jnc	$+16     	;abs 0x5c88

00005c7a <.Loc.15.1>:
    return NULL;
  }

  void * result = fw_storage + curr_index;
    5c7a:	cc 0e       	mova	r14,	r12	;
    5c7c:	ac 00 22 76 	adda	#30242,	r12	;0x07622

00005c80 <.LVL2>:
  
  curr_index += size;
    5c80:	60 0a 1e 76 	mova	r10,	&30238	; 0x0761e

00005c84 <.L1>:
  return result;
}
    5c84:	0a 16       	popm.a	#1,	r10	;20-bit words
    5c86:	10 01       	reta			;

00005c88 <.L3>:
    return NULL;
    5c88:	4c 43       	clr.b	r12		;
    5c8a:	80 00 84 5c 	mova	#23684,	r0	;0x05c84

00005c8e <elyFWFreeBuffer>:
  
  return elyNLToFW(result);
}

void elyFWFreeBuffer(uint8_t * buffer) {
  chPoolFree(&fw_mpool, buffer);
    5c8e:	cd 0c       	mova	r12,	r13	;
    5c90:	8c 00 12 76 	mova	#30226,	r12	;0x07612

00005c94 <.LVL9>:
    5c94:	b0 13 ae 4c 	calla	#19630		;0x04cae

00005c98 <.LVL10>:
}
    5c98:	10 01       	reta			;

00005c9a <elyFWFreeBufferI>:

void elyFWFreeBufferI(uint8_t * buffer) {
  chPoolFreeI(&fw_mpool, buffer);
    5c9a:	cd 0c       	mova	r12,	r13	;
    5c9c:	8c 00 12 76 	mova	#30226,	r12	;0x07612

00005ca0 <.LVL12>:
    5ca0:	b0 13 92 4c 	calla	#19602		;0x04c92

00005ca4 <.LVL13>:
}
    5ca4:	10 01       	reta			;

00005ca6 <elyMainMBPost>:

#include "cmds.h"

msg_t elyMainMBPost(uint8_t * buffer, systime_t timeout) {
  return elyUARTPost(buffer, timeout);
    5ca6:	b0 13 56 5a 	calla	#23126		;0x05a56

00005caa <.LVL1>:
}
    5caa:	10 01       	reta			;

00005cac <elyRFPost>:
msg_t elyRFPostI(uint8_t * buffer) {
  return elyMainMBPostI(buffer);
}

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
  return elyMainMBPost(buffer, timeout);
    5cac:	b0 13 a6 5c 	calla	#23718		;0x05ca6

00005cb0 <.LVL3>:
}
    5cb0:	10 01       	reta			;

00005cb2 <elyErrorSignal>:
#include "errors.h"
#include "registers.h"

void elyErrorSignal(uint8_t error) {
  (void)(error);
}
    5cb2:	10 01       	reta			;

00005cb4 <dbuf_get_write>:
  uint8_t buf[2][SLIP_RX_BUF_LEN];
  uint16_t write_idx;
  uint16_t read_idx;
} double_buff;

static uint8_t * dbuf_get_write(double_buff * rb) {
    5cb4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005cb6 <.LCFI0>:
    5cb6:	ca 0c       	mova	r12,	r10	;

00005cb8 <.Loc.14.1>:
  return rb->buf[rb->write_idx++ & 1];
    5cb8:	1c 4c 00 02 	mov	512(r12),r12	;0x00200

00005cbc <.LVL1>:
    5cbc:	0d 4c       	mov	r12,	r13	;
    5cbe:	1d 53       	inc	r13		;
    5cc0:	8a 4d 00 02 	mov	r13,	512(r10); 0x0200
    5cc4:	5c f3       	and.b	#1,	r12	;r3 As==01
    5cc6:	0d 43       	clr	r13		;
    5cc8:	b0 13 be 64 	calla	#25790		;0x064be
    5ccc:	0d 12       	push	r13		;
    5cce:	0c 12       	push	r12		;
    5cd0:	0c 16       	popm.a	#1,	r12	;20-bit words

00005cd2 <.Loc.15.1>:
}
    5cd2:	ec 0a       	adda	r10,	r12	;
    5cd4:	0a 16       	popm.a	#1,	r10	;20-bit words
    5cd6:	10 01       	reta			;

00005cd8 <dbuf_get_read>:

static uint8_t * dbuf_get_read(double_buff * rb) {
    5cd8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005cda <.LCFI1>:
    5cda:	ca 0c       	mova	r12,	r10	;

00005cdc <.Loc.18.1>:
  return rb->buf[rb->read_idx++ & 1];
    5cdc:	1c 4c 02 02 	mov	514(r12),r12	;0x00202

00005ce0 <.LVL4>:
    5ce0:	0d 4c       	mov	r12,	r13	;
    5ce2:	1d 53       	inc	r13		;
    5ce4:	8a 4d 02 02 	mov	r13,	514(r10); 0x0202
    5ce8:	5c f3       	and.b	#1,	r12	;r3 As==01
    5cea:	0d 43       	clr	r13		;
    5cec:	b0 13 be 64 	calla	#25790		;0x064be
    5cf0:	0d 12       	push	r13		;
    5cf2:	0c 12       	push	r12		;
    5cf4:	0c 16       	popm.a	#1,	r12	;20-bit words

00005cf6 <.Loc.19.1>:
}
    5cf6:	ec 0a       	adda	r10,	r12	;
    5cf8:	0a 16       	popm.a	#1,	r10	;20-bit words
    5cfa:	10 01       	reta			;

00005cfc <dbuf_init>:

static void dbuf_init(double_buff * rb) {
  chDbgAssert(SLIP_RX_BUF_LEN <= ((UINT16_MAX - 1) / 2), 
      "RX buffer length too long");
  
  rb->write_idx = 0;
    5cfc:	8c 43 00 02 	mov	#0,	512(r12);r3 As==00, 0x0200

00005d00 <.Loc.26.1>:
  rb->read_idx = 0;
    5d00:	8c 43 02 02 	mov	#0,	514(r12);r3 As==00, 0x0202

00005d04 <.Loc.27.1>:
}
    5d04:	10 01       	reta			;

00005d06 <handle_buffer>:
  (void)(uartp);
  
  uart_thd = chThdGetSelfX();
}

static void handle_buffer(size_t bytes_available, const uint8_t * buffer) {
    5d06:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005d08 <.LCFI2>:
    5d08:	06 14       	pushm.a	#1,	r6	;20-bit words

00005d0a <.LCFI3>:
    5d0a:	c6 0c       	mova	r12,	r6	;
    5d0c:	ca 0d       	mova	r13,	r10	;

00005d0e <.Loc.167.1>:
  static size_t rx_n;
  static bool header;
  /* We have now received 256 bytes of data somewhere in rx_buf */
  
  const uint8_t * end = buffer + bytes_available;
    5d0e:	c8 0d       	mova	r13,	r8	;
    5d10:	e8 0c       	adda	r12,	r8	;

00005d12 <.LVL8>:
  const uint8_t * cp = buffer;
  
  while (cp < end) {
    5d12:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005d16 <.L31>:
    
    if (rx_state == ELY_SLIP_RESET) {
      /* allocate a working buffer from the main pool */
      /* TODO this section is dangerous re: resets. Figure out how to fix it. */
      if (NULL == rx_active_buffer) {
        rx_active_buffer = elyNLGetBuffer();
    5d16:	b0 13 cc 61 	calla	#25036		;0x061cc

00005d1a <.LVL10>:
    5d1a:	60 0c 32 7b 	mova	r12,	&31538	; 0x07b32
    5d1e:	80 00 4a 5d 	mova	#23882,	r0	;0x05d4a

00005d22 <.L10>:
    }
    
    switch (rx_state) {
      case ELY_SLIP_ESCAPED:
        {
          switch(c) {
    5d22:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    5d26:	40 24       	jz	$+130    	;abs 0x5da8
    5d28:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    5d2c:	51 24       	jz	$+164    	;abs 0x5dd0

00005d2e <.Loc.201.1>:
              break;
            case SLIP_ESC_ESC:
              *rx_write_ptr++ = SLIP_ESC;
              break;
            default:
              rx_state = ELY_SLIP_RESET;
    5d2e:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5d32:	1e 9e 

00005d34 <.L5>:
  while (cp < end) {
    5d34:	da 08       	cmpa	r8,	r10	;
    5d36:	aa 2c       	jc	$+342    	;abs 0x5e8c

00005d38 <.LBB29>:
    uint8_t c = *cp;
    5d38:	69 4a       	mov.b	@r10,	r9	;

00005d3a <.LVL12>:
    if (rx_state == ELY_SLIP_RESET) {
    5d3a:	40 18 c2 93 	cmpx.b	#0,	&0xf9e1e;r3 As==00
    5d3e:	1e 9e 
    5d40:	15 20       	jnz	$+44     	;abs 0x5d6c

00005d42 <.Loc.176.1>:
      if (NULL == rx_active_buffer) {
    5d42:	00 18 c2 93 	cmpx.a	#0,	&0x07b32;r3 As==00
    5d46:	32 7b 
    5d48:	e6 27       	jz	$-50     	;abs 0x5d16

00005d4a <.L7>:
      if (NULL == rx_active_buffer) {
    5d4a:	2c 00 32 7b 	mova	&31538,	r12	;0x07b32
    5d4e:	9c 00 00 00 	cmpa	#0,	r12	;
    5d52:	ad 24       	jz	$+348    	;abs 0x5eae

00005d54 <.Loc.184.1>:
      rx_write_ptr = rx_active_buffer;
    5d54:	60 0c 1a 9e 	mova	r12,	&40474	; 0x09e1a

00005d58 <.Loc.185.1>:
      rx_n = elyNLHeaderLen;
    5d58:	00 18 f2 40 	movx.a	#6,	&0xf9df8;
    5d5c:	06 00 f8 9d 

00005d60 <.Loc.186.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    5d60:	40 18 e2 43 	movx.b	#2,	&0xf9e1e;r3 As==10
    5d64:	1e 9e 

00005d66 <.Loc.187.1>:
      header = true;
    5d66:	40 18 d2 43 	movx.b	#1,	&0xf9df6;r3 As==01
    5d6a:	f6 9d 

00005d6c <.L6>:
    switch (rx_state) {
    5d6c:	40 18 5c 42 	movx.b	&0x09e1e,r12	;
    5d70:	1e 9e 
    5d72:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    5d74:	d6 27       	jz	$-82     	;abs 0x5d22
    5d76:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    5d78:	37 24       	jz	$+112    	;abs 0x5de8

00005d7a <.Loc.244.1>:
              }
          }
        }
        break;
      default:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    5d7a:	8c 00 d7 74 	mova	#29911,	r12	;0x074d7
    5d7e:	b0 13 72 47 	calla	#18290		;0x04772

00005d82 <.L17>:
        /* ACTUALLY can't happen */
        break;
    }
    
    if (rx_n == 0 && header) { /* and we haven't reset */
    5d82:	00 18 c2 93 	cmpx.a	#0,	&0xf9df8;r3 As==00
    5d86:	f8 9d 
    5d88:	d5 23       	jnz	$-84     	;abs 0x5d34

00005d8a <.Loc.249.1>:
    5d8a:	40 18 c2 93 	cmpx.b	#0,	&0xf9df6;r3 As==00
    5d8e:	f6 9d 
    5d90:	d1 27       	jz	$-92     	;abs 0x5d34

00005d92 <.Loc.250.1>:
      if (elyNLValidate(rx_active_buffer)) {
    5d92:	2c 00 32 7b 	mova	&31538,	r12	;0x07b32
    5d96:	b0 13 aa 62 	calla	#25258		;0x062aa

00005d9a <.LVL15>:
    5d9a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5d9c:	6a 20       	jnz	$+214    	;abs 0x5e72

00005d9e <.Loc.256.1>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
        header = false;
      } 
      else {
        /* junk - reset state machine */
        rx_state = ELY_SLIP_RESET;
    5d9e:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5da2:	1e 9e 
    5da4:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005da8 <.L13>:
              *rx_write_ptr++ = SLIP_END;
    5da8:	2c 00 1a 9e 	mova	&40474,	r12	;0x09e1a
    5dac:	cd 0c       	mova	r12,	r13	;
    5dae:	ad 00 01 00 	adda	#1,	r13	;
    5db2:	60 0d 1a 9e 	mova	r13,	&40474	; 0x09e1a
    5db6:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    5dba:	00 00 

00005dbc <.L15>:
          rx_n--;
    5dbc:	00 18 f2 53 	addx.a	#-1,	&0xf9df8;r3 As==11
    5dc0:	f8 9d 

00005dc2 <.Loc.205.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    5dc2:	40 18 e2 43 	movx.b	#2,	&0xf9e1e;r3 As==10
    5dc6:	1e 9e 

00005dc8 <.Loc.206.1>:
          cp++;
    5dc8:	aa 00 01 00 	adda	#1,	r10	;

00005dcc <.Loc.208.1>:
        break;
    5dcc:	80 00 82 5d 	mova	#23938,	r0	;0x05d82

00005dd0 <.L14>:
              *rx_write_ptr++ = SLIP_ESC;
    5dd0:	2c 00 1a 9e 	mova	&40474,	r12	;0x09e1a
    5dd4:	cd 0c       	mova	r12,	r13	;
    5dd6:	ad 00 01 00 	adda	#1,	r13	;
    5dda:	60 0d 1a 9e 	mova	r13,	&40474	; 0x09e1a
    5dde:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    5de2:	00 00 

00005de4 <.Loc.199.1>:
              break;
    5de4:	80 00 bc 5d 	mova	#23996,	r0	;0x05dbc

00005de8 <.L11>:
          switch(c) {
    5de8:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    5dec:	13 24       	jz	$+40     	;abs 0x5e14
    5dee:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    5df2:	24 20       	jnz	$+74     	;abs 0x5e3c

00005df4 <.Loc.213.1>:
              if (rx_n == 0) {
    5df4:	00 18 c2 93 	cmpx.a	#0,	&0xf9df8;r3 As==00
    5df8:	f8 9d 
    5dfa:	05 20       	jnz	$+12     	;abs 0x5e06

00005dfc <.Loc.214.1>:
                rx_state = ELY_SLIP_RESET;
    5dfc:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5e00:	1e 9e 

00005e02 <.Loc.215.1>:
                continue;
    5e02:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005e06 <.L21>:
                rx_state = ELY_SLIP_ESCAPED;
    5e06:	40 18 d2 43 	movx.b	#1,	&0xf9e1e;r3 As==01
    5e0a:	1e 9e 

00005e0c <.Loc.219.1>:
                cp++;
    5e0c:	aa 00 01 00 	adda	#1,	r10	;

00005e10 <.Loc.221.1>:
              break;
    5e10:	80 00 82 5d 	mova	#23938,	r0	;0x05d82

00005e14 <.L19>:
              if (rx_n == 0) {
    5e14:	00 18 c2 93 	cmpx.a	#0,	&0xf9df8;r3 As==00
    5e18:	f8 9d 
    5e1a:	07 24       	jz	$+16     	;abs 0x5e2a

00005e1c <.L22>:
              rx_state = ELY_SLIP_RESET;
    5e1c:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5e20:	1e 9e 

00005e22 <.Loc.228.1>:
              cp++;
    5e22:	aa 00 01 00 	adda	#1,	r10	;

00005e26 <.Loc.229.1>:
              continue;
    5e26:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005e2a <.L33>:
                elyNLRouteUART(rx_active_buffer);
    5e2a:	2c 00 32 7b 	mova	&31538,	r12	;0x07b32
    5e2e:	b0 13 b6 63 	calla	#25526		;0x063b6

00005e32 <.LVL19>:
                rx_active_buffer = NULL;
    5e32:	00 18 c2 43 	movx.a	#0,	&0x07b32;r3 As==00
    5e36:	32 7b 
    5e38:	80 00 1c 5e 	mova	#24092,	r0	;0x05e1c

00005e3c <.L29>:
              if (rx_n == 0) {
    5e3c:	2c 00 f8 9d 	mova	&40440,	r12	;0x09df8
    5e40:	9c 00 00 00 	cmpa	#0,	r12	;
    5e44:	05 20       	jnz	$+12     	;abs 0x5e50

00005e46 <.Loc.232.1>:
                rx_state = ELY_SLIP_RESET;
    5e46:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5e4a:	1e 9e 

00005e4c <.Loc.233.1>:
                continue;
    5e4c:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005e50 <.L23>:
                *rx_write_ptr++ = c;
    5e50:	2e 00 1a 9e 	mova	&40474,	r14	;0x09e1a
    5e54:	cd 0e       	mova	r14,	r13	;
    5e56:	ad 00 01 00 	adda	#1,	r13	;
    5e5a:	60 0d 1a 9e 	mova	r13,	&40474	; 0x09e1a
    5e5e:	ce 49 00 00 	mov.b	r9,	0(r14)	;

00005e62 <.Loc.237.1>:
                rx_n--;
    5e62:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    5e66:	60 0c f8 9d 	mova	r12,	&40440	; 0x09df8

00005e6a <.Loc.238.1>:
                cp++;
    5e6a:	aa 00 01 00 	adda	#1,	r10	;
    5e6e:	80 00 82 5d 	mova	#23938,	r0	;0x05d82

00005e72 <.L32>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    5e72:	2c 00 32 7b 	mova	&31538,	r12	;0x07b32
    5e76:	b0 13 90 62 	calla	#25232		;0x06290

00005e7a <.LVL21>:
    5e7a:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    5e7e:	60 0c f8 9d 	mova	r12,	&40440	; 0x09df8

00005e82 <.Loc.252.1>:
        header = false;
    5e82:	40 18 c2 43 	movx.b	#0,	&0xf9df6;r3 As==00
    5e86:	f6 9d 
    5e88:	80 00 34 5d 	mova	#23860,	r0	;0x05d34

00005e8c <.L30>:
      }
    }
  }
  
  if (bytes_available < SLIP_RX_BUF_LEN) {
    5e8c:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    5e90:	dc 06       	cmpa	r6,	r12	;
    5e92:	0d 28       	jnc	$+28     	;abs 0x5eae

00005e94 <.Loc.262.1>:
    if (NULL != rx_active_buffer) {
    5e94:	2c 00 32 7b 	mova	&31538,	r12	;0x07b32
    5e98:	9c 00 00 00 	cmpa	#0,	r12	;
    5e9c:	05 24       	jz	$+12     	;abs 0x5ea8

00005e9e <.Loc.263.1>:
      elyNLFreeBuffer(rx_active_buffer);
    5e9e:	b0 13 d6 61 	calla	#25046		;0x061d6

00005ea2 <.LVL23>:
      rx_active_buffer = NULL;
    5ea2:	00 18 c2 43 	movx.a	#0,	&0x07b32;r3 As==00
    5ea6:	32 7b 

00005ea8 <.L26>:
    }
    rx_state = ELY_SLIP_RESET;
    5ea8:	40 18 c2 43 	movx.b	#0,	&0xf9e1e;r3 As==00
    5eac:	1e 9e 

00005eae <.L4>:
  }

}
    5eae:	06 16       	popm.a	#1,	r6	;20-bit words
    5eb0:	28 16       	popm.a	#3,	r10	;20-bit words
    5eb2:	10 01       	reta			;

00005eb4 <calc_next_buff>:
  switch (tx_state) {
    5eb4:	40 18 5c 42 	movx.b	&0x01e6a,r12	;
    5eb8:	6a 1e 
    5eba:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    5ebc:	28 24       	jz	$+82     	;abs 0x5f0e
    5ebe:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    5ec0:	51 20       	jnz	$+164    	;abs 0x5f64

00005ec2 <.Loc.48.1>:
      next_tx_ptr = tx_read_ptr;
    5ec2:	00 18 d2 42 	movx.a	&0x09e0a,&0xf9e02;
    5ec6:	0a 9e 02 9e 

00005eca <.Loc.49.1>:
      next_cnt = 0;
    5eca:	00 18 c2 43 	movx.a	#0,	&0xf9e06;r3 As==00
    5ece:	06 9e 

00005ed0 <.Loc.50.1>:
      while (next_cnt != tx_n && 
    5ed0:	80 00 e4 5e 	mova	#24292,	r0	;0x05ee4

00005ed4 <.L40>:
        next_cnt++;
    5ed4:	ac 00 01 00 	adda	#1,	r12	;
    5ed8:	60 0c 06 9e 	mova	r12,	&40454	; 0x09e06

00005edc <.Loc.54.1>:
        tx_read_ptr++;
    5edc:	ae 00 01 00 	adda	#1,	r14	;
    5ee0:	60 0e 0a 9e 	mova	r14,	&40458	; 0x09e0a

00005ee4 <.L38>:
      while (next_cnt != tx_n && 
    5ee4:	2c 00 06 9e 	mova	&40454,	r12	;0x09e06
    5ee8:	00 18 5c 92 	cmpx.a	&0x09e0e,r12	;
    5eec:	0e 9e 
    5eee:	09 24       	jz	$+20     	;abs 0x5f02

00005ef0 <.Loc.51.1>:
          *tx_read_ptr != SLIP_END && 
    5ef0:	2e 00 0a 9e 	mova	&40458,	r14	;0x09e0a
    5ef4:	6d 4e       	mov.b	@r14,	r13	;

00005ef6 <.Loc.50.1>:
      while (next_cnt != tx_n && 
    5ef6:	7d 90 c0 ff 	cmp.b	#-64,	r13	;#0xffc0
    5efa:	03 24       	jz	$+8      	;abs 0x5f02

00005efc <.Loc.51.1>:
          *tx_read_ptr != SLIP_END && 
    5efc:	7d 90 db ff 	cmp.b	#-37,	r13	;#0xffdb
    5f00:	e9 23       	jnz	$-44     	;abs 0x5ed4

00005f02 <.L39>:
      tx_state = ELY_SLIP_ESCAPED;
    5f02:	40 18 d2 43 	movx.b	#1,	&0x01e6a;r3 As==01
    5f06:	6a 1e 

00005f08 <.Loc.57.1>:
      if (next_cnt > 0) {
    5f08:	9c 00 00 00 	cmpa	#0,	r12	;
    5f0c:	1b 20       	jnz	$+56     	;abs 0x5f44

00005f0e <.L36>:
        switch(*tx_read_ptr++) {
    5f0e:	2c 00 0a 9e 	mova	&40458,	r12	;0x09e0a
    5f12:	cd 0c       	mova	r12,	r13	;
    5f14:	ad 00 01 00 	adda	#1,	r13	;
    5f18:	60 0d 0a 9e 	mova	r13,	&40458	; 0x09e0a
    5f1c:	6c 4c       	mov.b	@r12,	r12	;
    5f1e:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    5f22:	11 24       	jz	$+36     	;abs 0x5f46
    5f24:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    5f28:	14 20       	jnz	$+42     	;abs 0x5f52

00005f2a <.Loc.64.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    5f2a:	00 18 f2 40 	movx.a	#29962,	&0xf9e02;0x0750a
    5f2e:	0a 75 02 9e 

00005f32 <.L45>:
        next_cnt = 2;
    5f32:	00 18 e2 43 	movx.a	#2,	&0xf9e06;r3 As==10
    5f36:	06 9e 

00005f38 <.Loc.78.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    5f38:	00 18 d2 53 	incx.a	&0x9e0e		;
    5f3c:	0e 9e 

00005f3e <.Loc.79.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    5f3e:	40 18 e2 43 	movx.b	#2,	&0x01e6a;r3 As==10
    5f42:	6a 1e 

00005f44 <.L34>:
}
    5f44:	10 01       	reta			;

00005f46 <.L43>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    5f46:	00 18 f2 40 	movx.a	#29960,	&0xf9e02;0x07508
    5f4a:	08 75 02 9e 

00005f4e <.Loc.68.1>:
            break;
    5f4e:	80 00 32 5f 	mova	#24370,	r0	;0x05f32

00005f52 <.L47>:
            chDbgAssert(false, "state machine error");
    5f52:	8c 00 f9 74 	mova	#29945,	r12	;0x074f9
    5f56:	b0 13 72 47 	calla	#18290		;0x04772

00005f5a <.LVL24>:
            tx_n--;
    5f5a:	00 18 f2 53 	addx.a	#-1,	&0xf9e0e;r3 As==11
    5f5e:	0e 9e 

00005f60 <.Loc.75.1>:
            break;
    5f60:	80 00 32 5f 	mova	#24370,	r0	;0x05f32

00005f64 <.L46>:
      chDbgAssert(false, "State machine error");
    5f64:	8c 00 f9 74 	mova	#29945,	r12	;0x074f9
    5f68:	b0 13 72 47 	calla	#18290		;0x04772

00005f6c <.LVL25>:
}
    5f6c:	80 00 44 5f 	mova	#24388,	r0	;0x05f44

00005f70 <elyUARTDLLTxCB>:
void elyUARTDLLTxCB(UARTDriver * uartp) {
    5f70:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005f72 <.LCFI4>:
    5f72:	ca 0c       	mova	r12,	r10	;

00005f74 <.Loc.94.1>:
  if (done) {
    5f74:	40 18 c2 93 	cmpx.b	#0,	&0xf9dfc;r3 As==00
    5f78:	fc 9d 
    5f7a:	05 24       	jz	$+12     	;abs 0x5f86

00005f7c <.Loc.95.1>:
    done = false;
    5f7c:	40 18 c2 43 	movx.b	#0,	&0xf9dfc;r3 As==00
    5f80:	fc 9d 

00005f82 <.L48>:
}
    5f82:	0a 16       	popm.a	#1,	r10	;20-bit words
    5f84:	10 01       	reta			;

00005f86 <.L49>:
  chSysLockFromISR();
    5f86:	b0 13 64 45 	calla	#17764		;0x04564

00005f8a <.LVL28>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    5f8a:	2e 00 02 9e 	mova	&40450,	r14	;0x09e02
    5f8e:	2d 00 06 9e 	mova	&40454,	r13	;0x09e06
    5f92:	cc 0a       	mova	r10,	r12	;
    5f94:	b0 13 a6 4e 	calla	#20134		;0x04ea6

00005f98 <.LVL29>:
  chSysUnlockFromISR();
    5f98:	b0 13 86 45 	calla	#17798		;0x04586

00005f9c <.LVL30>:
  if (tx_n == 0) {
    5f9c:	2c 00 0e 9e 	mova	&40462,	r12	;0x09e0e
    5fa0:	9c 00 00 00 	cmpa	#0,	r12	;
    5fa4:	0c 24       	jz	$+26     	;abs 0x5fbe

00005fa6 <.Loc.108.1>:
  tx_n -= next_cnt;
    5fa6:	00 18 5c 82 	subx.a	&0x09e06,r12	;
    5faa:	06 9e 
    5fac:	60 0c 0e 9e 	mova	r12,	&40462	; 0x09e0e

00005fb0 <.Loc.110.1>:
  if (tx_n == 0) {
    5fb0:	9c 00 00 00 	cmpa	#0,	r12	;
    5fb4:	09 24       	jz	$+20     	;abs 0x5fc8

00005fb6 <.Loc.119.1>:
  calc_next_buff();
    5fb6:	b0 13 b4 5e 	calla	#24244		;0x05eb4

00005fba <.LVL31>:
    5fba:	80 00 82 5f 	mova	#24450,	r0	;0x05f82

00005fbe <.L53>:
    done = true;
    5fbe:	40 18 d2 43 	movx.b	#1,	&0xf9dfc;r3 As==01
    5fc2:	fc 9d 

00005fc4 <.Loc.105.1>:
    return;
    5fc4:	80 00 82 5f 	mova	#24450,	r0	;0x05f82

00005fc8 <.L54>:
    chSysLockFromISR();
    5fc8:	b0 13 64 45 	calla	#17764		;0x04564

00005fcc <.LVL32>:
    elyNLFreeBufferCheckedI(tx_active_buffer);
    5fcc:	2c 00 12 9e 	mova	&40466,	r12	;0x09e12
    5fd0:	b0 13 68 62 	calla	#25192		;0x06268

00005fd4 <.LVL33>:
    chSysUnlockFromISR();
    5fd4:	b0 13 86 45 	calla	#17798		;0x04586

00005fd8 <.LVL34>:
    next_tx_ptr = &END;
    5fd8:	00 18 f2 40 	movx.a	#29944,	&0xf9e02;0x074f8
    5fdc:	f8 74 02 9e 

00005fe0 <.Loc.115.1>:
    next_cnt = 1;
    5fe0:	00 18 d2 43 	movx.a	#1,	&0xf9e06;r3 As==01
    5fe4:	06 9e 

00005fe6 <.Loc.116.1>:
    return;
    5fe6:	80 00 82 5f 	mova	#24450,	r0	;0x05f82

00005fea <elyUARTDLLStartTx>:
void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    5fea:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005fec <.LCFI5>:
    5fec:	08 14       	pushm.a	#1,	r8	;20-bit words

00005fee <.LCFI6>:
    5fee:	c8 0c       	mova	r12,	r8	;
    5ff0:	ca 0d       	mova	r13,	r10	;

00005ff2 <.Loc.125.1>:
  tx_n = elyNLGetLength(buffer);
    5ff2:	cc 0d       	mova	r13,	r12	;

00005ff4 <.LVL36>:
    5ff4:	b0 13 90 62 	calla	#25232		;0x06290

00005ff8 <.LVL37>:
    5ff8:	60 0c 0e 9e 	mova	r12,	&40462	; 0x09e0e

00005ffc <.Loc.126.1>:
  chDbgAssert(tx_n != 0 && tx_n <= elyNLMaxLen, "invalid packet length");
    5ffc:	9c 00 00 00 	cmpa	#0,	r12	;
    6000:	04 24       	jz	$+10     	;abs 0x600a

00006002 <.Loc.126.1>:
    6002:	00 18 c2 9c 	cmpx.a	r12,	&0xf9b4c;
    6006:	4c 9b 
    6008:	04 2c       	jc	$+10     	;abs 0x6012

0000600a <.L56>:
    600a:	8c 00 e6 74 	mova	#29926,	r12	;0x074e6
    600e:	b0 13 72 47 	calla	#18290		;0x04772

00006012 <.L57>:
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    6012:	2c 00 0e 9e 	mova	&40462,	r12	;0x09e0e
    6016:	9c 00 00 00 	cmpa	#0,	r12	;
    601a:	04 24       	jz	$+10     	;abs 0x6024

0000601c <.Loc.128.1>:
    601c:	00 18 c2 9c 	cmpx.a	r12,	&0xf9b4c;
    6020:	4c 9b 
    6022:	03 2c       	jc	$+8      	;abs 0x602a

00006024 <.L58>:
    elyNLFreeBufferChecked(buffer);
    6024:	cc 0a       	mova	r10,	r12	;
    6026:	b0 13 48 62 	calla	#25160		;0x06248

0000602a <.L59>:
  tx_read_ptr = buffer;
    602a:	60 0a 0a 9e 	mova	r10,	&40458	; 0x09e0a

0000602e <.Loc.133.1>:
  tx_active_buffer = buffer;
    602e:	60 0a 12 9e 	mova	r10,	&40466	; 0x09e12

00006032 <.Loc.134.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    6032:	40 18 e2 43 	movx.b	#2,	&0x01e6a;r3 As==10
    6036:	6a 1e 

00006038 <.Loc.136.1>:
  calc_next_buff();
    6038:	b0 13 b4 5e 	calla	#24244		;0x05eb4

0000603c <.LBB30>:
  _disable_interrupts();
    603c:	32 c2       	dint			
    603e:	03 43       	nop			

00006040 <.Loc.348.2>:
  asm volatile("nop");
    6040:	03 43       	nop			

00006042 <.LBE30>:
  chSysLock();
    6042:	b0 13 22 45 	calla	#17698		;0x04522

00006046 <.LVL41>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    6046:	2e 00 02 9e 	mova	&40450,	r14	;0x09e02
    604a:	2d 00 06 9e 	mova	&40454,	r13	;0x09e06
    604e:	cc 08       	mova	r8,	r12	;
    6050:	b0 13 a6 4e 	calla	#20134		;0x04ea6

00006054 <.LVL42>:
  tx_n -= next_cnt;
    6054:	2c 00 0e 9e 	mova	&40462,	r12	;0x09e0e
    6058:	00 18 5c 82 	subx.a	&0x09e06,r12	;
    605c:	06 9e 
    605e:	60 0c 0e 9e 	mova	r12,	&40462	; 0x09e0e

00006062 <.Loc.143.1>:
  if (tx_n == 0) {
    6062:	9c 00 00 00 	cmpa	#0,	r12	;
    6066:	0b 24       	jz	$+24     	;abs 0x607e

00006068 <.Loc.151.1>:
  calc_next_buff();
    6068:	b0 13 b4 5e 	calla	#24244		;0x05eb4

0000606c <.LVL43>:
  chSysUnlock();
    606c:	b0 13 42 45 	calla	#17730		;0x04542

00006070 <.LBB32>:
  asm volatile("nop");
    6070:	03 43       	nop			

00006072 <.Loc.356.2>:
  _enable_interrupts();
    6072:	03 43       	nop			
    6074:	32 d2       	eint			
    6076:	03 43       	nop			

00006078 <.L55>:
}
    6078:	08 16       	popm.a	#1,	r8	;20-bit words
    607a:	0a 16       	popm.a	#1,	r10	;20-bit words
    607c:	10 01       	reta			;

0000607e <.L62>:
    elyNLFreeBufferChecked(tx_active_buffer);
    607e:	2c 00 12 9e 	mova	&40466,	r12	;0x09e12
    6082:	b0 13 48 62 	calla	#25160		;0x06248

00006086 <.LVL45>:
    next_tx_ptr = &END;
    6086:	00 18 f2 40 	movx.a	#29925,	&0xf9e02;0x074e5
    608a:	e5 74 02 9e 

0000608e <.Loc.146.1>:
    next_cnt = 1;
    608e:	00 18 d2 43 	movx.a	#1,	&0xf9e06;r3 As==01
    6092:	06 9e 

00006094 <.Loc.147.1>:
    chSysUnlock();
    6094:	b0 13 42 45 	calla	#17730		;0x04542

00006098 <.LBB34>:
  asm volatile("nop");
    6098:	03 43       	nop			

0000609a <.Loc.356.2>:
  _enable_interrupts();
    609a:	03 43       	nop			
    609c:	32 d2       	eint			
    609e:	03 43       	nop			
    60a0:	80 00 78 60 	mova	#24696,	r0	;0x06078

000060a4 <elyUARTDLLRxInit>:
  uart_thd = chThdGetSelfX();
    60a4:	00 18 d2 42 	movx.a	&0x01c00,&0xf9dfe;
    60a8:	00 1c fe 9d 

000060ac <.Loc.160.1>:
}
    60ac:	10 01       	reta			;

000060ae <elyUARTDLLRxHandleBuffer>:

void elyUARTDLLRxHandleBuffer() {
    60ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

000060b0 <.LCFI7>:
  handle_buffer(bytes_available, dbuf_get_read(&rx_buf));
    60b0:	2a 00 16 9e 	mova	&40470,	r10	;0x09e16
    60b4:	8c 00 20 9e 	mova	#40480,	r12	;0x09e20
    60b8:	b0 13 d8 5c 	calla	#23768		;0x05cd8

000060bc <.LVL48>:
    60bc:	cd 0c       	mova	r12,	r13	;
    60be:	cc 0a       	mova	r10,	r12	;
    60c0:	b0 13 06 5d 	calla	#23814		;0x05d06

000060c4 <.LVL49>:
}
    60c4:	0a 16       	popm.a	#1,	r10	;20-bit words
    60c6:	10 01       	reta			;

000060c8 <elyUARTDLLTimeoutCB>:

/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
    60c8:	b0 13 64 45 	calla	#17764		;0x04564

000060cc <.LVL51>:
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    60cc:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    60d0:	b0 13 32 4f 	calla	#20274		;0x04f32

000060d4 <.LVL52>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    60d4:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    60d8:	fd 0c       	suba	r12,	r13	;
    60da:	60 0d 16 9e 	mova	r13,	&40470	; 0x09e16

000060de <.Loc.285.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    60de:	6d 42       	mov.b	#4,	r13	;r2 As==10
    60e0:	4e 43       	clr.b	r14		;
    60e2:	2c 00 fe 9d 	mova	&40446,	r12	;0x09dfe

000060e6 <.LVL53>:
    60e6:	b0 13 10 4a 	calla	#18960		;0x04a10

000060ea <.LVL54>:
  chSysUnlockFromISR();
    60ea:	b0 13 86 45 	calla	#17798		;0x04586

000060ee <.LVL55>:

}
    60ee:	10 01       	reta			;

000060f0 <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    60f0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000060f2 <.LCFI8>:
    60f2:	c8 0c       	mova	r12,	r8	;
    60f4:	09 4d       	mov	r13,	r9	;

000060f6 <.Loc.291.1>:
  chDbgAssert(c < 0x100, "invalid char");
    60f6:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

000060fa <.LVL57>:
    60fa:	0c 9d       	cmp	r13,	r12	;
    60fc:	1f 28       	jnc	$+64     	;abs 0x613c

000060fe <.L67>:
  dbuf_init(&rx_buf);
    60fe:	8a 00 20 9e 	mova	#40480,	r10	;0x09e20
    6102:	cc 0a       	mova	r10,	r12	;
    6104:	b0 13 fc 5c 	calla	#23804		;0x05cfc

00006108 <.LVL59>:
  
  uint8_t * buf = dbuf_get_write(&rx_buf);
    6108:	cc 0a       	mova	r10,	r12	;
    610a:	b0 13 b4 5c 	calla	#23732		;0x05cb4

0000610e <.LVL60>:
    610e:	ca 0c       	mova	r12,	r10	;

00006110 <.LVL61>:
  buf[0] = (uint8_t)(c);
    6110:	cc 49 00 00 	mov.b	r9,	0(r12)	;

00006114 <.Loc.296.1>:
  chSysLockFromISR();
    6114:	b0 13 64 45 	calla	#17764		;0x04564

00006118 <.LVL62>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, buf+1);
    6118:	ce 0a       	mova	r10,	r14	;
    611a:	ae 00 01 00 	adda	#1,	r14	;
    611e:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    6122:	cc 08       	mova	r8,	r12	;
    6124:	b0 13 ec 4e 	calla	#20204		;0x04eec

00006128 <.LVL63>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    6128:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    612c:	8c 00 20 1d 	mova	#7456,	r12	;0x01d20
    6130:	b0 13 dc 4d 	calla	#19932		;0x04ddc

00006134 <.LVL64>:
  
  
  chSysUnlockFromISR();
    6134:	b0 13 86 45 	calla	#17798		;0x04586

00006138 <.LVL65>:
}
    6138:	28 16       	popm.a	#3,	r10	;20-bit words
    613a:	10 01       	reta			;

0000613c <.L68>:
  chDbgAssert(c < 0x100, "invalid char");
    613c:	8c 00 c4 74 	mova	#29892,	r12	;0x074c4
    6140:	b0 13 72 47 	calla	#18290		;0x04772

00006144 <.LVL67>:
    6144:	80 00 fe 60 	mova	#24830,	r0	;0x060fe

00006148 <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    6148:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000614a <.LCFI9>:
    614a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000614c <.LCFI10>:
    614c:	c8 0c       	mova	r12,	r8	;

0000614e <.Loc.306.1>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
    614e:	b0 13 64 45 	calla	#17764		;0x04564

00006152 <.LVL69>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, dbuf_get_write(&rx_buf)); 
    6152:	8c 00 20 9e 	mova	#40480,	r12	;0x09e20
    6156:	b0 13 b4 5c 	calla	#23732		;0x05cb4

0000615a <.LVL70>:
    615a:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    615e:	ce 0c       	mova	r12,	r14	;
    6160:	cd 0a       	mova	r10,	r13	;
    6162:	cc 08       	mova	r8,	r12	;
    6164:	b0 13 ec 4e 	calla	#20204		;0x04eec

00006168 <.LVL71>:
  gptStopTimerI(&uart_gpt);
    6168:	88 00 20 1d 	mova	#7456,	r8	;0x01d20

0000616c <.LVL72>:
    616c:	cc 08       	mova	r8,	r12	;
    616e:	b0 13 04 4e 	calla	#19972		;0x04e04

00006172 <.LVL73>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    6172:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    6176:	cc 08       	mova	r8,	r12	;
    6178:	b0 13 dc 4d 	calla	#19932		;0x04ddc

0000617c <.LVL74>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    617c:	60 0a 16 9e 	mova	r10,	&40470	; 0x09e16

00006180 <.Loc.313.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    6180:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6182:	4e 43       	clr.b	r14		;
    6184:	2c 00 fe 9d 	mova	&40446,	r12	;0x09dfe
    6188:	b0 13 10 4a 	calla	#18960		;0x04a10

0000618c <.LVL75>:
  
  chSysUnlockFromISR();
    618c:	b0 13 86 45 	calla	#17798		;0x04586

00006190 <.LVL76>:
}
    6190:	08 16       	popm.a	#1,	r8	;20-bit words
    6192:	0a 16       	popm.a	#1,	r10	;20-bit words
    6194:	10 01       	reta			;

00006196 <nl_allocator>:
uint8_t PERSIST packets_received;
uint16_t PERSIST packets_sent = 1;
uint8_t PERSIST packets_relayed;
static size_t sh_len;

void * nl_allocator(size_t size, unsigned align) {
    6196:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006198 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    6198:	2e 00 42 7b 	mova	&31554,	r14	;0x07b42
    619c:	ca 0e       	mova	r14,	r10	;
    619e:	ea 0c       	adda	r12,	r10	;
    61a0:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

000061a4 <.LVL1>:
    61a4:	dc 0a       	cmpa	r10,	r12	;
    61a6:	07 28       	jnc	$+16     	;abs 0x61b6

000061a8 <.Loc.26.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    61a8:	cc 0e       	mova	r14,	r12	;
    61aa:	ac 00 4b 7b 	adda	#31563,	r12	;0x07b4b

000061ae <.LVL2>:
  
  curr_index += size;
    61ae:	60 0a 42 7b 	mova	r10,	&31554	; 0x07b42

000061b2 <.L1>:
  return result;
}
    61b2:	0a 16       	popm.a	#1,	r10	;20-bit words
    61b4:	10 01       	reta			;

000061b6 <.L3>:
    return NULL;
    61b6:	4c 43       	clr.b	r12		;
    61b8:	80 00 b2 61 	mova	#25010,	r0	;0x061b2

000061bc <fw>:
static inline msg_t uart_pass_i(uint8_t * buffer) {
  return elyUARTPostI(buffer);
}

static inline msg_t fw(uint8_t * buffer) {
  return elyMainMBPost(buffer, TIME_INFINITE);
    61bc:	4d 43       	clr.b	r13		;
    61be:	b0 13 a6 5c 	calla	#23718		;0x05ca6

000061c2 <.LVL19>:
}
    61c2:	10 01       	reta			;

000061c4 <rf_pass>:
  return elyRFPost(buffer, TIME_INFINITE);
    61c4:	4d 43       	clr.b	r13		;
    61c6:	b0 13 ac 5c 	calla	#23724		;0x05cac

000061ca <.LVL21>:
}
    61ca:	10 01       	reta			;

000061cc <elyNLGetBuffer>:
  return chPoolAlloc(&main_mpool);
    61cc:	8c 00 36 7b 	mova	#31542,	r12	;0x07b36
    61d0:	b0 13 6a 4c 	calla	#19562		;0x04c6a

000061d4 <.LVL54>:
}
    61d4:	10 01       	reta			;

000061d6 <elyNLFreeBuffer>:
  chPoolFree(&main_mpool, buffer);
    61d6:	cd 0c       	mova	r12,	r13	;
    61d8:	8c 00 36 7b 	mova	#31542,	r12	;0x07b36

000061dc <.LVL56>:
    61dc:	b0 13 ae 4c 	calla	#19630		;0x04cae

000061e0 <.LVL57>:
}
    61e0:	10 01       	reta			;

000061e2 <elyNLFreeBufferI>:
void elyNLFreeBufferI(uint8_t * buffer) {
    61e2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000061e4 <.LCFI5>:
    61e4:	ca 0c       	mova	r12,	r10	;

000061e6 <.Loc.128.1>:
  chDbgCheckClassI();
    61e6:	b0 13 f6 45 	calla	#17910		;0x045f6

000061ea <.LVL61>:
  chPoolFreeI(&main_mpool, buffer);
    61ea:	cd 0a       	mova	r10,	r13	;
    61ec:	8c 00 36 7b 	mova	#31542,	r12	;0x07b36
    61f0:	b0 13 92 4c 	calla	#19602		;0x04c92

000061f4 <.LVL62>:
}
    61f4:	0a 16       	popm.a	#1,	r10	;20-bit words
    61f6:	10 01       	reta			;

000061f8 <is_fw_buf>:
  }
  
  return ELY_DEST_UART;
}

bool is_fw_buf(uint8_t * buffer) {
    61f8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000061fa <.LCFI6>:
   * If (TM AND APID == Elysium) FW Reply
   * If (TC AND APID == Elysium) Coding error
   * Else NL packet */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    61fa:	6d 4c       	mov.b	@r12,	r13	;
    61fc:	0e 4d       	mov	r13,	r14	;
    61fe:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    6202:	3e f0 00 07 	and	#1792,	r14	;#0x0700
    6206:	5c 4c 01 00 	mov.b	1(r12),	r12	;

0000620a <.LVL70>:
    620a:	0c de       	bis	r14,	r12	;

0000620c <.LVL71>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    620c:	2a 00 c0 74 	mova	&29888,	r10	;0x074c0
    6210:	5e 4a 51 00 	mov.b	81(r10),r14	;0x00051
    6214:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    6218:	5a 4a 50 00 	mov.b	80(r10),r10	;0x00050
    621c:	0e da       	bis	r10,	r14	;

0000621e <.LVL72>:
    621e:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    6222:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006226 <.LVL73>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (apid == elysium_apid) {
    6226:	0c 9e       	cmp	r14,	r12	;
    6228:	03 24       	jz	$+8      	;abs 0x6230

0000622a <.Loc.272.1>:
      chDbgAssert(false, "internal coding error");
      /* Fall through to NL if Asserts are disabled and not set to Abort - stupid */
    }
  }
  
  return false;
    622a:	4c 43       	clr.b	r12		;

0000622c <.L46>:
}
    622c:	0a 16       	popm.a	#1,	r10	;20-bit words
    622e:	10 01       	reta			;

00006230 <.L49>:
    if (!tc) {
    6230:	0d 93       	cmp	#0,	r13	;r3 As==00
    6232:	03 20       	jnz	$+8      	;abs 0x623a

00006234 <.Loc.264.1>:
      return true;
    6234:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006236 <.LVL76>:
    6236:	80 00 2c 62 	mova	#25132,	r0	;0x0622c

0000623a <.L50>:
      chDbgAssert(false, "internal coding error");
    623a:	8c 00 0c 75 	mova	#29964,	r12	;0x0750c

0000623e <.LVL78>:
    623e:	b0 13 72 47 	calla	#18290		;0x04772

00006242 <.LVL79>:
  return false;
    6242:	4c 43       	clr.b	r12		;
    6244:	80 00 2c 62 	mova	#25132,	r0	;0x0622c

00006248 <elyNLFreeBufferChecked>:
  
void elyNLFreeBufferChecked(uint8_t * buffer) {
    6248:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000624a <.LCFI7>:
    624a:	ca 0c       	mova	r12,	r10	;

0000624c <.Loc.276.1>:
  if (is_fw_buf(buffer)) {
    624c:	b0 13 f8 61 	calla	#25080		;0x061f8

00006250 <.LVL81>:
    6250:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6252:	05 20       	jnz	$+12     	;abs 0x625e

00006254 <.Loc.280.1>:
      elyFWFreeBuffer(buffer);
  }
  else {
    elyNLFreeBuffer(buffer);
    6254:	cc 0a       	mova	r10,	r12	;
    6256:	b0 13 d6 61 	calla	#25046		;0x061d6

0000625a <.L51>:
  }
}
    625a:	0a 16       	popm.a	#1,	r10	;20-bit words
    625c:	10 01       	reta			;

0000625e <.L54>:
      elyFWFreeBuffer(buffer);
    625e:	cc 0a       	mova	r10,	r12	;
    6260:	b0 13 8e 5c 	calla	#23694		;0x05c8e

00006264 <.LVL83>:
    6264:	80 00 5a 62 	mova	#25178,	r0	;0x0625a

00006268 <elyNLFreeBufferCheckedI>:

void elyNLFreeBufferCheckedI(uint8_t * buffer) {
    6268:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000626a <.LCFI8>:
    626a:	ca 0c       	mova	r12,	r10	;

0000626c <.Loc.285.1>:
  if (is_fw_buf(buffer)) {
    626c:	b0 13 f8 61 	calla	#25080		;0x061f8

00006270 <.LVL85>:
    6270:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6272:	05 20       	jnz	$+12     	;abs 0x627e

00006274 <.Loc.289.1>:
      elyFWFreeBufferI(buffer);
  }
  else {
    elyNLFreeBufferI(buffer);
    6274:	cc 0a       	mova	r10,	r12	;
    6276:	b0 13 e2 61 	calla	#25058		;0x061e2

0000627a <.L55>:
  }
}
    627a:	0a 16       	popm.a	#1,	r10	;20-bit words
    627c:	10 01       	reta			;

0000627e <.L58>:
      elyFWFreeBufferI(buffer);
    627e:	cc 0a       	mova	r10,	r12	;
    6280:	b0 13 9a 5c 	calla	#23706		;0x05c9a

00006284 <.LVL87>:
    6284:	80 00 7a 62 	mova	#25210,	r0	;0x0627a

00006288 <elyNLInit>:
      /* 4-byte Secondary Header + 6-byte Primary Header */
      sh_len = 4;
    }
  }
  
  sh_len = 0;
    6288:	00 18 c2 43 	movx.a	#0,	&0xfa024;r3 As==00
    628c:	24 a0 

0000628e <.Loc.306.1>:
}
    628e:	10 01       	reta			;

00006290 <elyNLGetLength>:
  }
  
  return;
}

size_t elyNLGetLength(const uint8_t * buffer) {
    6290:	ce 0c       	mova	r12,	r14	;

00006292 <.Loc.366.1>:
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    6292:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00006296 <.LVL91>:
    6296:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    629a:	5e 4e 05 00 	mov.b	5(r14),	r14	;

0000629e <.LVL92>:
    629e:	0c de       	bis	r14,	r12	;
    62a0:	3c 50 07 00 	add	#7,	r12	;
    62a4:	4c 0e       	rlam.a	#4,	r12	;
    62a6:	4c 0d       	rram.a	#4,	r12	;

000062a8 <.Loc.367.1>:
}
    62a8:	10 01       	reta			;

000062aa <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    62aa:	0a 14       	pushm.a	#1,	r10	;20-bit words

000062ac <.LCFI9>:
    62ac:	ca 0c       	mova	r12,	r10	;

000062ae <.Loc.137.1>:
  if (buffer[0] & 0xE0) {
    62ae:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    62b2:	00 00 
    62b4:	1e 20       	jnz	$+62     	;abs 0x62f2

000062b6 <.LBB21>:
  _disable_interrupts();
    62b6:	32 c2       	dint			
    62b8:	03 43       	nop			

000062ba <.Loc.348.2>:
  asm volatile("nop");
    62ba:	03 43       	nop			

000062bc <.LBE21>:
  chSysLock();
    62bc:	b0 13 22 45 	calla	#17698		;0x04522

000062c0 <.LVL94>:
  if ( elyNLGetLength(buffer) > 
    62c0:	cc 0a       	mova	r10,	r12	;
    62c2:	b0 13 90 62 	calla	#25232		;0x06290

000062c6 <.LVL95>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    62c6:	2a 00 c0 74 	mova	&29888,	r10	;0x074c0

000062ca <.LVL96>:
    62ca:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    62ce:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    62d2:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    62d6:	0e da       	bis	r10,	r14	;
    62d8:	40 18 0e 4e 	movx.w	r14,	r14	;

000062dc <.Loc.145.1>:
  if ( elyNLGetLength(buffer) > 
    62dc:	de 0c       	cmpa	r12,	r14	;
    62de:	10 28       	jnc	$+34     	;abs 0x6300

000062e0 <.Loc.152.1>:
  chSysUnlock();
    62e0:	b0 13 42 45 	calla	#17730		;0x04542

000062e4 <.LBB23>:
  asm volatile("nop");
    62e4:	03 43       	nop			

000062e6 <.Loc.356.2>:
  _enable_interrupts();
    62e6:	03 43       	nop			
    62e8:	32 d2       	eint			
    62ea:	03 43       	nop			

000062ec <.LBE23>:
  return true;
    62ec:	5c 43       	mov.b	#1,	r12	;r3 As==01
    62ee:	80 00 fc 62 	mova	#25340,	r0	;0x062fc

000062f2 <.L65>:
    elyErrorSignal(ErrNLPVNMismatch);
    62f2:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0
    62f6:	b0 13 b2 5c 	calla	#23730		;0x05cb2

000062fa <.LVL99>:
    return false;
    62fa:	4c 43       	clr.b	r12		;

000062fc <.L63>:
}
    62fc:	0a 16       	popm.a	#1,	r10	;20-bit words
    62fe:	10 01       	reta			;

00006300 <.L66>:
    chSysUnlock();
    6300:	b0 13 42 45 	calla	#17730		;0x04542

00006304 <.LBB25>:
  asm volatile("nop");
    6304:	03 43       	nop			

00006306 <.Loc.356.2>:
  _enable_interrupts();
    6306:	03 43       	nop			
    6308:	32 d2       	eint			
    630a:	03 43       	nop			

0000630c <.LBE25>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    630c:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    6310:	b0 13 b2 5c 	calla	#23730		;0x05cb2

00006314 <.LVL102>:
    return false;
    6314:	4c 43       	clr.b	r12		;
    6316:	80 00 fc 62 	mova	#25340,	r0	;0x062fc

0000631a <nl_route>:
    msg_t (*fw_func)(uint8_t *)) {
    631a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000631c <.LCFI10>:
    631c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000631e <.LCFI11>:
    631e:	06 14       	pushm.a	#1,	r6	;20-bit words

00006320 <.LCFI12>:
    6320:	ca 0c       	mova	r12,	r10	;
    6322:	c8 0d       	mova	r13,	r8	;
    6324:	c6 0e       	mova	r14,	r6	;

00006326 <.Loc.165.1>:
  if (!elyNLValidate(buffer)) {
    6326:	b0 13 aa 62 	calla	#25258		;0x062aa

0000632a <.LVL104>:
    632a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    632c:	21 24       	jz	$+68     	;abs 0x6370

0000632e <.Loc.171.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    632e:	6c 4a       	mov.b	@r10,	r12	;
    6330:	0d 4c       	mov	r12,	r13	;
    6332:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6336:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    633a:	5e 4a 01 00 	mov.b	1(r10),	r14	;
    633e:	0d de       	bis	r14,	r13	;

00006340 <.LVL105>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    6340:	2e 00 c0 74 	mova	&29888,	r14	;0x074c0
    6344:	5f 4e 51 00 	mov.b	81(r14),r15	;0x00051
    6348:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    634c:	5e 4e 50 00 	mov.b	80(r14),r14	;0x00050
    6350:	0e df       	bis	r15,	r14	;

00006352 <.LVL106>:
    6352:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    6356:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000635a <.LVL107>:
  if (apid == elysium_apid) {
    635a:	0d 9e       	cmp	r14,	r13	;
    635c:	0e 24       	jz	$+30     	;abs 0x637a

0000635e <.Loc.194.1>:
  if (MSG_OK != pass_func(buffer)) {
    635e:	cc 0a       	mova	r10,	r12	;

00006360 <.LVL108>:
    6360:	48 13       	calla	r8		;

00006362 <.LVL109>:
    6362:	9c 00 00 00 	cmpa	#0,	r12	;
    6366:	1e 20       	jnz	$+62     	;abs 0x63a4

00006368 <.L67>:
}
    6368:	06 16       	popm.a	#1,	r6	;20-bit words
    636a:	08 16       	popm.a	#1,	r8	;20-bit words
    636c:	0a 16       	popm.a	#1,	r10	;20-bit words
    636e:	10 01       	reta			;

00006370 <.L72>:
    elyNLFreeBuffer(buffer);
    6370:	cc 0a       	mova	r10,	r12	;
    6372:	b0 13 d6 61 	calla	#25046		;0x061d6

00006376 <.LVL110>:
    return;
    6376:	80 00 68 63 	mova	#25448,	r0	;0x06368

0000637a <.L73>:
    if (tc) {
    637a:	0c 93       	cmp	#0,	r12	;r3 As==00
    637c:	0e 24       	jz	$+30     	;abs 0x639a

0000637e <.Loc.178.1>:
      if (MSG_OK != fw_func(buffer)) {
    637e:	cc 0a       	mova	r10,	r12	;

00006380 <.LVL112>:
    6380:	46 13       	calla	r6		;

00006382 <.LVL113>:
    6382:	9c 00 00 00 	cmpa	#0,	r12	;
    6386:	f0 27       	jz	$-30     	;abs 0x6368

00006388 <.Loc.180.1>:
        chDbgAssert(false, "internal buffer overflows should be impossible");
    6388:	8c 00 16 75 	mova	#29974,	r12	;0x07516
    638c:	b0 13 72 47 	calla	#18290		;0x04772

00006390 <.LVL114>:
        elyNLFreeBuffer(buffer);
    6390:	cc 0a       	mova	r10,	r12	;
    6392:	b0 13 d6 61 	calla	#25046		;0x061d6

00006396 <.LVL115>:
    6396:	80 00 68 63 	mova	#25448,	r0	;0x06368

0000639a <.L71>:
      elyNLFreeBuffer(buffer);
    639a:	cc 0a       	mova	r10,	r12	;

0000639c <.LVL117>:
    639c:	b0 13 d6 61 	calla	#25046		;0x061d6

000063a0 <.LVL118>:
      return;
    63a0:	80 00 68 63 	mova	#25448,	r0	;0x06368

000063a4 <.L74>:
    chDbgAssert(false, "internal buffer overflows should be impossible");
    63a4:	8c 00 16 75 	mova	#29974,	r12	;0x07516
    63a8:	b0 13 72 47 	calla	#18290		;0x04772

000063ac <.LVL119>:
    elyNLFreeBuffer(buffer);
    63ac:	cc 0a       	mova	r10,	r12	;
    63ae:	b0 13 d6 61 	calla	#25046		;0x061d6

000063b2 <.LVL120>:
    63b2:	80 00 68 63 	mova	#25448,	r0	;0x06368

000063b6 <elyNLRouteUART>:
  nl_route(buffer, rf_pass, fw);
    63b6:	8e 00 bc 61 	mova	#25020,	r14	;0x061bc
    63ba:	8d 00 c4 61 	mova	#25028,	r13	;0x061c4
    63be:	b0 13 1a 63 	calla	#25370		;0x0631a

000063c2 <.LVL122>:
}
    63c2:	10 01       	reta			;

000063c4 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    63c4:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    63c8:	80 5a 5c 01 

000063cc <.Loc.52.1>:

  halInit();
    63cc:	b0 13 5e 4d 	calla	#19806		;0x04d5e

000063d0 <.LVL0>:
  chSysInit();
    63d0:	b0 13 2e 46 	calla	#17966		;0x0462e

000063d4 <.LVL1>:
  elyNLInit();
    63d4:	b0 13 88 62 	calla	#25224		;0x06288

000063d8 <.L3>:
    63d8:	80 00 d8 63 	mova	#25560,	r0	;0x063d8

000063dc <udivmodsi4>:
    63dc:	5a 14       	pushm.a	#6,	r10	;20-bit words

000063de <.LCFI0>:
    63de:	0a 4c       	mov	r12,	r10	;
    63e0:	0b 4d       	mov	r13,	r11	;

000063e2 <.LVL1>:
    63e2:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

000063e6 <.Loc.35.1>:
    63e6:	58 43       	mov.b	#1,	r8	;r3 As==01
    63e8:	49 43       	clr.b	r9		;

000063ea <.Loc.38.1>:
    63ea:	07 4b       	mov	r11,	r7	;

000063ec <.L2>:
    63ec:	0f 9b       	cmp	r11,	r15	;
    63ee:	11 28       	jnc	$+36     	;abs 0x6412
    63f0:	07 9f       	cmp	r15,	r7	;
    63f2:	02 20       	jnz	$+6      	;abs 0x63f8
    63f4:	0e 9a       	cmp	r10,	r14	;
    63f6:	0d 28       	jnc	$+28     	;abs 0x6412

000063f8 <.L20>:
    63f8:	4c 43       	clr.b	r12		;

000063fa <.LVL3>:
    63fa:	0d 4c       	mov	r12,	r13	;

000063fc <.L5>:
    63fc:	07 48       	mov	r8,	r7	;
    63fe:	07 d9       	bis	r9,	r7	;
    6400:	07 93       	cmp	#0,	r7	;r3 As==00
    6402:	1a 20       	jnz	$+54     	;abs 0x6438

00006404 <.L6>:
    6404:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    6408:	02 24       	jz	$+6      	;abs 0x640e
    640a:	0c 4a       	mov	r10,	r12	;
    640c:	0d 4b       	mov	r11,	r13	;

0000640e <.L1>:
    640e:	55 16       	popm.a	#6,	r10	;20-bit words
    6410:	10 01       	reta			;

00006412 <.L3>:
    6412:	3d 53       	add	#-1,	r13	;r3 As==11

00006414 <.Loc.38.1>:
    6414:	0d 93       	cmp	#0,	r13	;r3 As==00
    6416:	24 24       	jz	$+74     	;abs 0x6460

00006418 <.Loc.38.1>:
    6418:	0f 93       	cmp	#0,	r15	;r3 As==00
    641a:	ee 3b       	jl	$-34     	;abs 0x63f8

0000641c <.Loc.40.1>:
    641c:	05 4e       	mov	r14,	r5	;
    641e:	06 4f       	mov	r15,	r6	;
    6420:	05 5e       	add	r14,	r5	;
    6422:	06 6f       	addc	r15,	r6	;
    6424:	0e 45       	mov	r5,	r14	;

00006426 <.LVL7>:
    6426:	0f 46       	mov	r6,	r15	;

00006428 <.LVL8>:
    6428:	05 48       	mov	r8,	r5	;
    642a:	06 49       	mov	r9,	r6	;
    642c:	05 58       	add	r8,	r5	;
    642e:	06 69       	addc	r9,	r6	;
    6430:	08 45       	mov	r5,	r8	;

00006432 <.LVL9>:
    6432:	09 46       	mov	r6,	r9	;

00006434 <.LVL10>:
    6434:	80 00 ec 63 	mova	#25580,	r0	;0x063ec

00006438 <.L12>:
    6438:	0b 9f       	cmp	r15,	r11	;
    643a:	0a 28       	jnc	$+22     	;abs 0x6450
    643c:	0f 9b       	cmp	r11,	r15	;
    643e:	02 20       	jnz	$+6      	;abs 0x6444
    6440:	0a 9e       	cmp	r14,	r10	;
    6442:	06 28       	jnc	$+14     	;abs 0x6450

00006444 <.L16>:
    6444:	40 18 0a 8e 	subx.w	r14,	r10	;
    6448:	40 18 0b 7f 	subcx.w	r15,	r11	;

0000644c <.Loc.48.1>:
    644c:	0c d8       	bis	r8,	r12	;

0000644e <.LVL13>:
    644e:	0d d9       	bis	r9,	r13	;

00006450 <.L10>:
    6450:	12 c3       	clrc			
    6452:	09 10       	rrc	r9		;
    6454:	08 10       	rrc	r8		;

00006456 <.Loc.51.1>:
    6456:	12 c3       	clrc			
    6458:	0f 10       	rrc	r15		;
    645a:	0e 10       	rrc	r14		;
    645c:	80 00 fc 63 	mova	#25596,	r0	;0x063fc

00006460 <.L14>:
    6460:	0c 4d       	mov	r13,	r12	;

00006462 <.LVL18>:
    6462:	80 00 04 64 	mova	#25604,	r0	;0x06404

00006466 <__mspabi_divlu>:
    6466:	b1 00 02 00 	suba	#2,	r1	;

0000646a <.LCFI5>:
    646a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    646e:	b0 13 dc 63 	calla	#25564		;0x063dc

00006472 <.LVL46>:
    6472:	a1 00 02 00 	adda	#2,	r1	;
    6476:	10 01       	reta			;

00006478 <__mspabi_slli_15>:
    6478:	0c 5c       	rla	r12		;

0000647a <__mspabi_slli_14>:
    647a:	0c 5c       	rla	r12		;

0000647c <__mspabi_slli_13>:
    647c:	0c 5c       	rla	r12		;

0000647e <__mspabi_slli_12>:
    647e:	0c 5c       	rla	r12		;

00006480 <__mspabi_slli_11>:
    6480:	0c 5c       	rla	r12		;

00006482 <__mspabi_slli_10>:
    6482:	0c 5c       	rla	r12		;

00006484 <__mspabi_slli_9>:
    6484:	0c 5c       	rla	r12		;

00006486 <__mspabi_slli_8>:
    6486:	0c 5c       	rla	r12		;

00006488 <__mspabi_slli_7>:
    6488:	0c 5c       	rla	r12		;

0000648a <__mspabi_slli_6>:
    648a:	0c 5c       	rla	r12		;

0000648c <__mspabi_slli_5>:
    648c:	0c 5c       	rla	r12		;

0000648e <__mspabi_slli_4>:
    648e:	0c 5c       	rla	r12		;

00006490 <__mspabi_slli_3>:
    6490:	0c 5c       	rla	r12		;

00006492 <__mspabi_slli_2>:
    6492:	0c 5c       	rla	r12		;

00006494 <__mspabi_slli_1>:
    6494:	0c 5c       	rla	r12		;
    6496:	10 01       	reta			;

00006498 <.L11>:
    6498:	3d 53       	add	#-1,	r13	;r3 As==11
    649a:	0c 5c       	rla	r12		;

0000649c <__mspabi_slli>:
    649c:	0d 93       	cmp	#0,	r13	;r3 As==00
    649e:	fc 23       	jnz	$-6      	;abs 0x6498
    64a0:	10 01       	reta			;

000064a2 <__mspabi_slll_15>:
    64a2:	0c 5c       	rla	r12		;
    64a4:	0d 6d       	rlc	r13		;

000064a6 <__mspabi_slll_14>:
    64a6:	0c 5c       	rla	r12		;
    64a8:	0d 6d       	rlc	r13		;

000064aa <__mspabi_slll_13>:
    64aa:	0c 5c       	rla	r12		;
    64ac:	0d 6d       	rlc	r13		;

000064ae <__mspabi_slll_12>:
    64ae:	0c 5c       	rla	r12		;
    64b0:	0d 6d       	rlc	r13		;

000064b2 <__mspabi_slll_11>:
    64b2:	0c 5c       	rla	r12		;
    64b4:	0d 6d       	rlc	r13		;

000064b6 <__mspabi_slll_10>:
    64b6:	0c 5c       	rla	r12		;
    64b8:	0d 6d       	rlc	r13		;

000064ba <__mspabi_slll_9>:
    64ba:	0c 5c       	rla	r12		;
    64bc:	0d 6d       	rlc	r13		;

000064be <__mspabi_slll_8>:
    64be:	0c 5c       	rla	r12		;
    64c0:	0d 6d       	rlc	r13		;

000064c2 <__mspabi_slll_7>:
    64c2:	0c 5c       	rla	r12		;
    64c4:	0d 6d       	rlc	r13		;

000064c6 <__mspabi_slll_6>:
    64c6:	0c 5c       	rla	r12		;
    64c8:	0d 6d       	rlc	r13		;

000064ca <__mspabi_slll_5>:
    64ca:	0c 5c       	rla	r12		;
    64cc:	0d 6d       	rlc	r13		;

000064ce <__mspabi_slll_4>:
    64ce:	0c 5c       	rla	r12		;
    64d0:	0d 6d       	rlc	r13		;

000064d2 <__mspabi_slll_3>:
    64d2:	0c 5c       	rla	r12		;
    64d4:	0d 6d       	rlc	r13		;

000064d6 <__mspabi_slll_2>:
    64d6:	0c 5c       	rla	r12		;
    64d8:	0d 6d       	rlc	r13		;

000064da <__mspabi_slll_1>:
    64da:	0c 5c       	rla	r12		;
    64dc:	0d 6d       	rlc	r13		;
    64de:	10 01       	reta			;

000064e0 <.L12>:
    64e0:	3e 53       	add	#-1,	r14	;r3 As==11
    64e2:	0c 5c       	rla	r12		;
    64e4:	0d 6d       	rlc	r13		;

000064e6 <__mspabi_slll>:
    64e6:	0e 93       	cmp	#0,	r14	;r3 As==00
    64e8:	fb 23       	jnz	$-8      	;abs 0x64e0
    64ea:	10 01       	reta			;

000064ec <__mspabi_srli_15>:
    64ec:	12 c3       	clrc			
    64ee:	0c 10       	rrc	r12		;

000064f0 <__mspabi_srli_14>:
    64f0:	12 c3       	clrc			
    64f2:	0c 10       	rrc	r12		;

000064f4 <__mspabi_srli_13>:
    64f4:	12 c3       	clrc			
    64f6:	0c 10       	rrc	r12		;

000064f8 <__mspabi_srli_12>:
    64f8:	12 c3       	clrc			
    64fa:	0c 10       	rrc	r12		;

000064fc <__mspabi_srli_11>:
    64fc:	12 c3       	clrc			
    64fe:	0c 10       	rrc	r12		;

00006500 <__mspabi_srli_10>:
    6500:	12 c3       	clrc			
    6502:	0c 10       	rrc	r12		;

00006504 <__mspabi_srli_9>:
    6504:	12 c3       	clrc			
    6506:	0c 10       	rrc	r12		;

00006508 <__mspabi_srli_8>:
    6508:	12 c3       	clrc			
    650a:	0c 10       	rrc	r12		;

0000650c <__mspabi_srli_7>:
    650c:	12 c3       	clrc			
    650e:	0c 10       	rrc	r12		;

00006510 <__mspabi_srli_6>:
    6510:	12 c3       	clrc			
    6512:	0c 10       	rrc	r12		;

00006514 <__mspabi_srli_5>:
    6514:	12 c3       	clrc			
    6516:	0c 10       	rrc	r12		;

00006518 <__mspabi_srli_4>:
    6518:	12 c3       	clrc			
    651a:	0c 10       	rrc	r12		;

0000651c <__mspabi_srli_3>:
    651c:	12 c3       	clrc			
    651e:	0c 10       	rrc	r12		;

00006520 <__mspabi_srli_2>:
    6520:	12 c3       	clrc			
    6522:	0c 10       	rrc	r12		;

00006524 <__mspabi_srli_1>:
    6524:	12 c3       	clrc			
    6526:	0c 10       	rrc	r12		;
    6528:	10 01       	reta			;

0000652a <.L11>:
    652a:	3d 53       	add	#-1,	r13	;r3 As==11
    652c:	12 c3       	clrc			
    652e:	0c 10       	rrc	r12		;

00006530 <__mspabi_srli>:
    6530:	0d 93       	cmp	#0,	r13	;r3 As==00
    6532:	fb 23       	jnz	$-8      	;abs 0x652a
    6534:	10 01       	reta			;

00006536 <__mspabi_srll_15>:
    6536:	12 c3       	clrc			
    6538:	0d 10       	rrc	r13		;
    653a:	0c 10       	rrc	r12		;

0000653c <__mspabi_srll_14>:
    653c:	12 c3       	clrc			
    653e:	0d 10       	rrc	r13		;
    6540:	0c 10       	rrc	r12		;

00006542 <__mspabi_srll_13>:
    6542:	12 c3       	clrc			
    6544:	0d 10       	rrc	r13		;
    6546:	0c 10       	rrc	r12		;

00006548 <__mspabi_srll_12>:
    6548:	12 c3       	clrc			
    654a:	0d 10       	rrc	r13		;
    654c:	0c 10       	rrc	r12		;

0000654e <__mspabi_srll_11>:
    654e:	12 c3       	clrc			
    6550:	0d 10       	rrc	r13		;
    6552:	0c 10       	rrc	r12		;

00006554 <__mspabi_srll_10>:
    6554:	12 c3       	clrc			
    6556:	0d 10       	rrc	r13		;
    6558:	0c 10       	rrc	r12		;

0000655a <__mspabi_srll_9>:
    655a:	12 c3       	clrc			
    655c:	0d 10       	rrc	r13		;
    655e:	0c 10       	rrc	r12		;

00006560 <__mspabi_srll_8>:
    6560:	12 c3       	clrc			
    6562:	0d 10       	rrc	r13		;
    6564:	0c 10       	rrc	r12		;

00006566 <__mspabi_srll_7>:
    6566:	12 c3       	clrc			
    6568:	0d 10       	rrc	r13		;
    656a:	0c 10       	rrc	r12		;

0000656c <__mspabi_srll_6>:
    656c:	12 c3       	clrc			
    656e:	0d 10       	rrc	r13		;
    6570:	0c 10       	rrc	r12		;

00006572 <__mspabi_srll_5>:
    6572:	12 c3       	clrc			
    6574:	0d 10       	rrc	r13		;
    6576:	0c 10       	rrc	r12		;

00006578 <__mspabi_srll_4>:
    6578:	12 c3       	clrc			
    657a:	0d 10       	rrc	r13		;
    657c:	0c 10       	rrc	r12		;

0000657e <__mspabi_srll_3>:
    657e:	12 c3       	clrc			
    6580:	0d 10       	rrc	r13		;
    6582:	0c 10       	rrc	r12		;

00006584 <__mspabi_srll_2>:
    6584:	12 c3       	clrc			
    6586:	0d 10       	rrc	r13		;
    6588:	0c 10       	rrc	r12		;

0000658a <__mspabi_srll_1>:
    658a:	12 c3       	clrc			
    658c:	0d 10       	rrc	r13		;
    658e:	0c 10       	rrc	r12		;
    6590:	10 01       	reta			;

00006592 <.L12>:
    6592:	3e 53       	add	#-1,	r14	;r3 As==11
    6594:	12 c3       	clrc			
    6596:	0d 10       	rrc	r13		;
    6598:	0c 10       	rrc	r12		;

0000659a <__mspabi_srll>:
    659a:	0e 93       	cmp	#0,	r14	;r3 As==00
    659c:	fa 23       	jnz	$-10     	;abs 0x6592
    659e:	10 01       	reta			;

000065a0 <__mspabi_mpyl>:
    65a0:	02 12       	push	r2		;
    65a2:	32 c2       	dint			
    65a4:	03 43       	nop			
    65a6:	82 4c d0 04 	mov	r12,	&0x04d0	;
    65aa:	82 4d d2 04 	mov	r13,	&0x04d2	;
    65ae:	82 4e e0 04 	mov	r14,	&0x04e0	;
    65b2:	82 4f e2 04 	mov	r15,	&0x04e2	;
    65b6:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    65ba:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    65be:	32 41       	pop	r2		;
    65c0:	10 01       	reta			;

000065c2 <memmove>:
    65c2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000065c4 <.LCFI0>:
    65c4:	08 14       	pushm.a	#1,	r8	;20-bit words

000065c6 <.LCFI1>:
    65c6:	06 14       	pushm.a	#1,	r6	;20-bit words

000065c8 <.LCFI2>:
    65c8:	c8 0c       	mova	r12,	r8	;
    65ca:	e8 0e       	adda	r14,	r8	;

000065cc <.Loc.69.1>:
    65cc:	dd 0c       	cmpa	r12,	r13	;
    65ce:	04 28       	jnc	$+10     	;abs 0x65d8

000065d0 <.L4>:
    65d0:	ce 0c       	mova	r12,	r14	;

000065d2 <.LVL2>:
    65d2:	ca 0d       	mova	r13,	r10	;
    65d4:	80 00 fc 65 	mova	#26108,	r0	;0x065fc

000065d8 <.L2>:
    65d8:	ca 0d       	mova	r13,	r10	;
    65da:	ea 0e       	adda	r14,	r10	;
    65dc:	dc 0a       	cmpa	r10,	r12	;
    65de:	f8 2f       	jc	$-14     	;abs 0x65d0

000065e0 <.LVL4>:
    65e0:	fe 0a       	suba	r10,	r14	;

000065e2 <.L5>:
    65e2:	c6 0a       	mova	r10,	r6	;
    65e4:	e6 0e       	adda	r14,	r6	;

000065e6 <.Loc.74.1>:
    65e6:	96 00 00 00 	cmpa	#0,	r6	;
    65ea:	12 24       	jz	$+38     	;abs 0x6610

000065ec <.Loc.76.1>:
    65ec:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    65f0:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

000065f4 <.LVL7>:
    65f4:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    65f8:	80 00 e2 65 	mova	#26082,	r0	;0x065e2

000065fc <.L3>:
    65fc:	d8 0e       	cmpa	r14,	r8	;
    65fe:	08 24       	jz	$+18     	;abs 0x6610

00006600 <.LVL9>:
    6600:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    6604:	ae 00 01 00 	adda	#1,	r14	;

00006608 <.LVL10>:
    6608:	aa 00 01 00 	adda	#1,	r10	;
    660c:	80 00 fc 65 	mova	#26108,	r0	;0x065fc

00006610 <.L9>:
    6610:	06 16       	popm.a	#1,	r6	;20-bit words
    6612:	08 16       	popm.a	#1,	r8	;20-bit words
    6614:	0a 16       	popm.a	#1,	r10	;20-bit words
    6616:	10 01       	reta			;

00006618 <memset>:
    6618:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000661a <.LCFI0>:
    661a:	ca 0c       	mova	r12,	r10	;
    661c:	ee 0c       	adda	r12,	r14	;

0000661e <.L2>:
    661e:	da 0e       	cmpa	r14,	r10	;
    6620:	06 24       	jz	$+14     	;abs 0x662e

00006622 <.LVL3>:
    6622:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    6626:	aa 00 01 00 	adda	#1,	r10	;

0000662a <.LVL4>:
    662a:	80 00 1e 66 	mova	#26142,	r0	;0x0661e

0000662e <.L5>:
    662e:	0a 16       	popm.a	#1,	r10	;20-bit words
    6630:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000a028 <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    a028:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a02a <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    a02a:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a02e:	3a 1c 
    a030:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a034 <.LBB12>:
  chSysLockFromISR();
    a034:	b0 13 64 45 	calla	#17764		;0x04564

0000a038 <.LBB14>:
  chSysTimerHandlerI();
    a038:	b0 13 80 47 	calla	#18304		;0x04780

0000a03c <.LBB16>:
  chSysUnlockFromISR();
    a03c:	b0 13 86 45 	calla	#17798		;0x04586

0000a040 <.LBE16>:
  OSAL_IRQ_EPILOGUE();
    a040:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a044 <.LVL4>:
    a044:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a048:	3a 1c 
    a04a:	b0 13 22 45 	calla	#17698		;0x04522

0000a04e <.LVL5>:
    a04e:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a052 <.LVL6>:
    a052:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a054:	04 20       	jnz	$+10     	;abs 0xa05e

0000a056 <.L2>:
    a056:	b0 13 42 45 	calla	#17730		;0x04542

0000a05a <.LVL7>:
}
    a05a:	b4 16       	popm.a	#12,	r15	;20-bit words
    a05c:	00 13       	reti			

0000a05e <.L3>:
  OSAL_IRQ_EPILOGUE();
    a05e:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a062 <.LVL8>:
    a062:	80 00 56 a0 	mova	#41046,	r0	;0x0a056

0000a066 <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    a066:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a068 <.LCFI0>:
    a068:	b1 00 04 00 	suba	#4,	r1	;

0000a06c <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    a06c:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a070:	3a 1c 
    a072:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a076 <.LVL0>:
  pad = (P1IV >> 1) - 1;
    a076:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    a07a:	0e 02 
    a07c:	12 c3       	clrc			
    a07e:	0c 10       	rrc	r12		;
    a080:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a082:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a086 <.LVL1>:
  cb = port_callback_map[0][pad];
    a086:	4c 0e       	rlam.a	#4,	r12	;
    a088:	4c 0d       	rram.a	#4,	r12	;

0000a08a <.LVL2>:
    a08a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    a08c:	40 18 3c 41 	popx.w	r12		;
    a090:	40 18 3d 41 	popx.w	r13		;
    a094:	0e 4c       	mov	r12,	r14	;
    a096:	0f 4d       	mov	r13,	r15	;
    a098:	0e 5e       	rla	r14		;
    a09a:	0f 6f       	rlc	r15		;
    a09c:	0e 5e       	rla	r14		;
    a09e:	0f 6f       	rlc	r15		;
    a0a0:	81 4e 00 00 	mov	r14,	0(r1)	;
    a0a4:	81 4f 02 00 	mov	r15,	2(r1)	;
    a0a8:	0d 01       	mova	@r1,	r13	;
    a0aa:	00 18 5c 4d 	movx.a	7228(r13),r12	;0x01c3c
    a0ae:	3c 1c 

0000a0b0 <.LVL3>:
  if (cb != NULL) {
    a0b0:	9c 00 00 00 	cmpa	#0,	r12	;
    a0b4:	01 24       	jz	$+4      	;abs 0xa0b8

0000a0b6 <.Loc.81.1>:
    (*cb)();
    a0b6:	4c 13       	calla	r12		;

0000a0b8 <.L2>:
  OSAL_IRQ_EPILOGUE();
    a0b8:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a0bc <.LVL5>:
    a0bc:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a0c0:	3a 1c 
    a0c2:	b0 13 22 45 	calla	#17698		;0x04522

0000a0c6 <.LVL6>:
    a0c6:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a0ca <.LVL7>:
    a0ca:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a0cc:	06 20       	jnz	$+14     	;abs 0xa0da

0000a0ce <.L3>:
    a0ce:	b0 13 42 45 	calla	#17730		;0x04542

0000a0d2 <.LVL8>:
}
    a0d2:	a1 00 04 00 	adda	#4,	r1	;
    a0d6:	b4 16       	popm.a	#12,	r15	;20-bit words
    a0d8:	00 13       	reti			

0000a0da <.L4>:
  OSAL_IRQ_EPILOGUE();
    a0da:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a0de <.LVL9>:
    a0de:	80 00 ce a0 	mova	#41166,	r0	;0x0a0ce

0000a0e2 <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    a0e2:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a0e4 <.LCFI2>:
    a0e4:	b1 00 04 00 	suba	#4,	r1	;

0000a0e8 <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    a0e8:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a0ec:	3a 1c 
    a0ee:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a0f2 <.LVL10>:
  pad = (P2IV >> 1) - 1;
    a0f2:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    a0f6:	1e 02 
    a0f8:	12 c3       	clrc			
    a0fa:	0c 10       	rrc	r12		;
    a0fc:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a0fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a102 <.LVL11>:
  cb = port_callback_map[1][pad];
    a102:	4c 0e       	rlam.a	#4,	r12	;
    a104:	4c 0d       	rram.a	#4,	r12	;

0000a106 <.LVL12>:
    a106:	ac 00 08 00 	adda	#8,	r12	;
    a10a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    a10c:	40 18 3c 41 	popx.w	r12		;
    a110:	40 18 3d 41 	popx.w	r13		;
    a114:	0e 4c       	mov	r12,	r14	;
    a116:	0f 4d       	mov	r13,	r15	;
    a118:	0e 5e       	rla	r14		;
    a11a:	0f 6f       	rlc	r15		;
    a11c:	0e 5e       	rla	r14		;
    a11e:	0f 6f       	rlc	r15		;
    a120:	81 4e 00 00 	mov	r14,	0(r1)	;
    a124:	81 4f 02 00 	mov	r15,	2(r1)	;
    a128:	0d 01       	mova	@r1,	r13	;
    a12a:	00 18 5c 4d 	movx.a	7228(r13),r12	;0x01c3c
    a12e:	3c 1c 

0000a130 <.LVL13>:
  if (cb != NULL) {
    a130:	9c 00 00 00 	cmpa	#0,	r12	;
    a134:	01 24       	jz	$+4      	;abs 0xa138

0000a136 <.Loc.99.1>:
    (*cb)();
    a136:	4c 13       	calla	r12		;

0000a138 <.L6>:
  OSAL_IRQ_EPILOGUE();
    a138:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a13c <.LVL15>:
    a13c:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a140:	3a 1c 
    a142:	b0 13 22 45 	calla	#17698		;0x04522

0000a146 <.LVL16>:
    a146:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a14a <.LVL17>:
    a14a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a14c:	06 20       	jnz	$+14     	;abs 0xa15a

0000a14e <.L7>:
    a14e:	b0 13 42 45 	calla	#17730		;0x04542

0000a152 <.LVL18>:
}
    a152:	a1 00 04 00 	adda	#4,	r1	;
    a156:	b4 16       	popm.a	#12,	r15	;20-bit words
    a158:	00 13       	reti			

0000a15a <.L8>:
  OSAL_IRQ_EPILOGUE();
    a15a:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a15e <.LVL19>:
    a15e:	80 00 4e a1 	mova	#41294,	r0	;0x0a14e

0000a162 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    a162:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a164 <.LCFI4>:
    a164:	b1 00 04 00 	suba	#4,	r1	;

0000a168 <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    a168:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a16c:	3a 1c 
    a16e:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a172 <.LVL20>:
  pad = (P3IV >> 1) - 1;
    a172:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    a176:	2e 02 
    a178:	12 c3       	clrc			
    a17a:	0c 10       	rrc	r12		;
    a17c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a17e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a182 <.LVL21>:
  cb = port_callback_map[2][pad];
    a182:	4c 0e       	rlam.a	#4,	r12	;
    a184:	4c 0d       	rram.a	#4,	r12	;

0000a186 <.LVL22>:
    a186:	ac 00 10 00 	adda	#16,	r12	;0x00010
    a18a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    a18c:	40 18 3c 41 	popx.w	r12		;
    a190:	40 18 3d 41 	popx.w	r13		;
    a194:	0e 4c       	mov	r12,	r14	;
    a196:	0f 4d       	mov	r13,	r15	;
    a198:	0e 5e       	rla	r14		;
    a19a:	0f 6f       	rlc	r15		;
    a19c:	0e 5e       	rla	r14		;
    a19e:	0f 6f       	rlc	r15		;
    a1a0:	81 4e 00 00 	mov	r14,	0(r1)	;
    a1a4:	81 4f 02 00 	mov	r15,	2(r1)	;
    a1a8:	0d 01       	mova	@r1,	r13	;
    a1aa:	00 18 5c 4d 	movx.a	7228(r13),r12	;0x01c3c
    a1ae:	3c 1c 

0000a1b0 <.LVL23>:
  if (cb != NULL) {
    a1b0:	9c 00 00 00 	cmpa	#0,	r12	;
    a1b4:	01 24       	jz	$+4      	;abs 0xa1b8

0000a1b6 <.Loc.118.1>:
    (*cb)();
    a1b6:	4c 13       	calla	r12		;

0000a1b8 <.L10>:
  OSAL_IRQ_EPILOGUE();
    a1b8:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a1bc <.LVL25>:
    a1bc:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a1c0:	3a 1c 
    a1c2:	b0 13 22 45 	calla	#17698		;0x04522

0000a1c6 <.LVL26>:
    a1c6:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a1ca <.LVL27>:
    a1ca:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a1cc:	06 20       	jnz	$+14     	;abs 0xa1da

0000a1ce <.L11>:
    a1ce:	b0 13 42 45 	calla	#17730		;0x04542

0000a1d2 <.LVL28>:
}
    a1d2:	a1 00 04 00 	adda	#4,	r1	;
    a1d6:	b4 16       	popm.a	#12,	r15	;20-bit words
    a1d8:	00 13       	reti			

0000a1da <.L12>:
  OSAL_IRQ_EPILOGUE();
    a1da:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a1de <.LVL29>:
    a1de:	80 00 ce a1 	mova	#41422,	r0	;0x0a1ce

0000a1e2 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    a1e2:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a1e4 <.LCFI6>:
    a1e4:	b1 00 04 00 	suba	#4,	r1	;

0000a1e8 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    a1e8:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a1ec:	3a 1c 
    a1ee:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a1f2 <.LVL30>:
  pad = (P4IV >> 1) - 1;
    a1f2:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    a1f6:	3e 02 
    a1f8:	12 c3       	clrc			
    a1fa:	0c 10       	rrc	r12		;
    a1fc:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a1fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a202 <.LVL31>:
  cb = port_callback_map[3][pad];
    a202:	4c 0e       	rlam.a	#4,	r12	;
    a204:	4c 0d       	rram.a	#4,	r12	;

0000a206 <.LVL32>:
    a206:	ac 00 18 00 	adda	#24,	r12	;0x00018
    a20a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    a20c:	40 18 3c 41 	popx.w	r12		;
    a210:	40 18 3d 41 	popx.w	r13		;
    a214:	0e 4c       	mov	r12,	r14	;
    a216:	0f 4d       	mov	r13,	r15	;
    a218:	0e 5e       	rla	r14		;
    a21a:	0f 6f       	rlc	r15		;
    a21c:	0e 5e       	rla	r14		;
    a21e:	0f 6f       	rlc	r15		;
    a220:	81 4e 00 00 	mov	r14,	0(r1)	;
    a224:	81 4f 02 00 	mov	r15,	2(r1)	;
    a228:	0d 01       	mova	@r1,	r13	;
    a22a:	00 18 5c 4d 	movx.a	7228(r13),r12	;0x01c3c
    a22e:	3c 1c 

0000a230 <.LVL33>:
  if (cb != NULL) {
    a230:	9c 00 00 00 	cmpa	#0,	r12	;
    a234:	01 24       	jz	$+4      	;abs 0xa238

0000a236 <.Loc.136.1>:
    (*cb)();
    a236:	4c 13       	calla	r12		;

0000a238 <.L14>:
  OSAL_IRQ_EPILOGUE();
    a238:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a23c <.LVL35>:
    a23c:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a240:	3a 1c 
    a242:	b0 13 22 45 	calla	#17698		;0x04522

0000a246 <.LVL36>:
    a246:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a24a <.LVL37>:
    a24a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a24c:	06 20       	jnz	$+14     	;abs 0xa25a

0000a24e <.L15>:
    a24e:	b0 13 42 45 	calla	#17730		;0x04542

0000a252 <.LVL38>:
}
    a252:	a1 00 04 00 	adda	#4,	r1	;
    a256:	b4 16       	popm.a	#12,	r15	;20-bit words
    a258:	00 13       	reti			

0000a25a <.L16>:
  OSAL_IRQ_EPILOGUE();
    a25a:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a25e <.LVL39>:
    a25e:	80 00 4e a2 	mova	#41550,	r0	;0x0a24e

0000a262 <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    a262:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a264 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    a264:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a268:	3a 1c 
    a26a:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a26e <.LVL6>:
  index = (DMAIV >> 1) - 1;
    a26e:	40 18 1a 42 	movx.w	&0x0050e,r10	;
    a272:	0e 05 
    a274:	12 c3       	clrc			
    a276:	0a 10       	rrc	r10		;
    a278:	7a 53       	add.b	#-1,	r10	;r3 As==11
    a27a:	49 4a       	mov.b	r10,	r9	;

0000a27c <.LVL7>:
  if (index < MSP430X_DMA_CHANNELS) {
    a27c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a27e:	4c 9a       	cmp.b	r10,	r12	;
    a280:	0f 2c       	jc	$+32     	;abs 0xa2a0

0000a282 <.L3>:
  OSAL_IRQ_EPILOGUE();
    a282:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a286 <.LVL9>:
    a286:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a28a:	3a 1c 
    a28c:	b0 13 22 45 	calla	#17698		;0x04522

0000a290 <.LVL10>:
    a290:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a294 <.LVL11>:
    a294:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a296:	40 20       	jnz	$+130    	;abs 0xa318

0000a298 <.L4>:
    a298:	b0 13 42 45 	calla	#17730		;0x04542

0000a29c <.LVL12>:
}
    a29c:	b4 16       	popm.a	#12,	r15	;20-bit words
    a29e:	00 13       	reti			

0000a2a0 <.L5>:
    dma_regs[index].ctl &= ~DMAEN;
    a2a0:	4c 4a       	mov.b	r10,	r12	;
    a2a2:	0d 43       	clr	r13		;
    a2a4:	b0 13 ce 64 	calla	#25806		;0x064ce
    a2a8:	0d 12       	push	r13		;
    a2aa:	0c 12       	push	r12		;
    a2ac:	08 16       	popm.a	#1,	r8	;20-bit words
    a2ae:	a8 00 10 05 	adda	#1296,	r8	;0x00510
    a2b2:	b8 f0 ef ff 	and	#-17,	0(r8)	;#0xffef
    a2b6:	00 00 

0000a2b8 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    a2b8:	4d 43       	clr.b	r13		;
    a2ba:	4c 4a       	mov.b	r10,	r12	;
    a2bc:	b0 13 50 50 	calla	#20560		;0x05050

0000a2c0 <.LVL15>:
    dma_regs[index].sz  = 0;
    a2c0:	88 43 0a 00 	mov	#0,	10(r8)	;r3 As==00, 0x000a

0000a2c4 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    a2c4:	b8 40 12 00 	mov	#18,	0(r8)	;#0x0012
    a2c8:	00 00 

0000a2ca <.Loc.87.1>:
    if (cb->callback != NULL) {
    a2ca:	0d 49       	mov	r9,	r13	;
    a2cc:	4d 0e       	rlam.a	#4,	r13	;
    a2ce:	4d 0d       	rram.a	#4,	r13	;
    a2d0:	0d 14       	pushm.a	#1,	r13	;20-bit words
    a2d2:	40 18 3c 41 	popx.w	r12		;
    a2d6:	40 18 3d 41 	popx.w	r13		;
    a2da:	b0 13 d2 64 	calla	#25810		;0x064d2
    a2de:	0d 12       	push	r13		;
    a2e0:	0c 12       	push	r12		;
    a2e2:	0c 16       	popm.a	#1,	r12	;20-bit words
    a2e4:	00 18 5a 4c 	movx.a	40404(r12),r10	;0x09dd4
    a2e8:	d4 9d 

0000a2ea <.LVL18>:
    a2ea:	9a 00 00 00 	cmpa	#0,	r10	;
    a2ee:	c9 27       	jz	$-108    	;abs 0xa282

0000a2f0 <.Loc.88.1>:
      cb->callback(cb->args);
    a2f0:	0d 49       	mov	r9,	r13	;
    a2f2:	4d 0e       	rlam.a	#4,	r13	;
    a2f4:	4d 0d       	rram.a	#4,	r13	;
    a2f6:	0d 14       	pushm.a	#1,	r13	;20-bit words
    a2f8:	40 18 3c 41 	popx.w	r12		;
    a2fc:	40 18 3d 41 	popx.w	r13		;
    a300:	b0 13 d2 64 	calla	#25810		;0x064d2
    a304:	0d 12       	push	r13		;
    a306:	0c 12       	push	r12		;
    a308:	0c 16       	popm.a	#1,	r12	;20-bit words
    a30a:	ac 00 d4 9d 	adda	#40404,	r12	;0x09dd4
    a30e:	3c 0c 04 00 	mova	4(r12),	r12	;
    a312:	4a 13       	calla	r10		;

0000a314 <.LVL20>:
    a314:	80 00 82 a2 	mova	#41602,	r0	;0x0a282

0000a318 <.L6>:
  OSAL_IRQ_EPILOGUE();
    a318:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a31c <.LVL22>:
    a31c:	80 00 98 a2 	mova	#41624,	r0	;0x0a298

0000a320 <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    a320:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a322 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    a322:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a326:	3a 1c 
    a328:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a32c <.LVL107>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    a32c:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    a330:	fe 05 
    a332:	2c 92       	cmp	#4,	r12	;r2 As==10
    a334:	6b 24       	jz	$+216    	;abs 0xa40c
    a336:	6d 42       	mov.b	#4,	r13	;r2 As==10
    a338:	0d 9c       	cmp	r12,	r13	;
    a33a:	1c 2c       	jc	$+58     	;abs 0xa374
    a33c:	3c 90 06 00 	cmp	#6,	r12	;
    a340:	65 24       	jz	$+204    	;abs 0xa40c
    a342:	3c 92       	cmp	#8,	r12	;r2 As==11
    a344:	67 20       	jnz	$+208    	;abs 0xa414

0000a346 <.Loc.303.1>:
      _uart_tx2_isr_code(&UARTDA1);
    a346:	2c 00 c0 1c 	mova	&7360,	r12	;0x01cc0
    a34a:	3e 0c 04 00 	mova	4(r12),	r14	;
    a34e:	9e 00 00 00 	cmpa	#0,	r14	;
    a352:	03 24       	jz	$+8      	;abs 0xa35a

0000a354 <.Loc.303.1>:
    a354:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    a358:	4e 13       	calla	r14		;

0000a35a <.L79>:
    a35a:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    a35e:	cc 93 08 00 	cmp.b	#0,	8(r12)	;r3 As==00
    a362:	67 24       	jz	$+208    	;abs 0xa432

0000a364 <.L80>:
      UCA1IE &= ~UCTXCPTIE;
    a364:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    a368:	fa 05 

0000a36a <.Loc.307.1>:
      UCA1IFG &= ~UCTXCPTIFG;
    a36a:	40 18 b2 c2 	bicx.w	#8,	&0x005fc;r2 As==11
    a36e:	fc 05 

0000a370 <.Loc.308.1>:
      break;
    a370:	80 00 14 a4 	mova	#42004,	r0	;0x0a414

0000a374 <.L83>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    a374:	2c 93       	cmp	#2,	r12	;r3 As==10
    a376:	4e 20       	jnz	$+158    	;abs 0xa414

0000a378 <.Loc.272.1>:
      if (UCA1STATW & UCRXERR) {
    a378:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    a37c:	ea 05 
    a37e:	2d 24       	jz	$+92     	;abs 0xa3da

0000a380 <.LBB43>:
        if (UCA1STATW & UCBRK)
    a380:	40 18 f2 b2 	bitx.b	#8,	&0x005ea;r2 As==11
    a384:	ea 05 
    a386:	38 20       	jnz	$+114    	;abs 0xa3f8

0000a388 <.Loc.274.1>:
        uartflags_t sts = 0;
    a388:	4d 43       	clr.b	r13		;
    a38a:	0e 4d       	mov	r13,	r14	;

0000a38c <.L73>:
        if (UCA1STATW & UCOE)
    a38c:	40 18 f2 b0 	bitx.b	#32,	&0x005ea;0x00020
    a390:	20 00 ea 05 
    a394:	02 24       	jz	$+6      	;abs 0xa39a

0000a396 <.Loc.279.1>:
          sts |= UART_OVERRUN_ERROR;
    a396:	3d d0 10 00 	bis	#16,	r13	;#0x0010

0000a39a <.L74>:
        if (UCA1STATW & UCFE)
    a39a:	40 18 f2 b0 	bitx.b	#64,	&0x005ea;0x00040
    a39e:	40 00 ea 05 
    a3a2:	01 24       	jz	$+4      	;abs 0xa3a6

0000a3a4 <.Loc.281.1>:
          sts |= UART_FRAMING_ERROR;
    a3a4:	3d d2       	bis	#8,	r13	;r2 As==11

0000a3a6 <.L75>:
        if (UCA1STATW & UCPE)
    a3a6:	40 18 f2 b0 	bitx.b	#16,	&0x005ea;0x00010
    a3aa:	10 00 ea 05 
    a3ae:	01 24       	jz	$+4      	;abs 0xa3b2

0000a3b0 <.Loc.283.1>:
          sts |= UART_PARITY_ERROR;
    a3b0:	2d d2       	bis	#4,	r13	;r2 As==10

0000a3b2 <.L76>:
        _uart_rx_error_isr_code(&UARTDA1, sts);
    a3b2:	2c 00 c0 1c 	mova	&7360,	r12	;0x01cc0
    a3b6:	3a 0c 10 00 	mova	16(r12),r10	;0x00010
    a3ba:	9a 00 00 00 	cmpa	#0,	r10	;
    a3be:	03 24       	jz	$+8      	;abs 0xa3c6

0000a3c0 <.Loc.285.1>:
    a3c0:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    a3c4:	4a 13       	calla	r10		;

0000a3c6 <.L77>:
  chSysLockFromISR();
    a3c6:	b0 13 64 45 	calla	#17764		;0x04564

0000a3ca <.LBB46>:
  chThdResumeI(trp, msg);
    a3ca:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    a3ce:	8c 00 c6 1c 	mova	#7366,	r12	;0x01cc6

0000a3d2 <.LVL116>:
    a3d2:	b0 13 5a 49 	calla	#18778		;0x0495a

0000a3d6 <.LBB48>:
  chSysUnlockFromISR();
    a3d6:	b0 13 86 45 	calla	#17798		;0x04586

0000a3da <.L72>:
      if (UARTDA1.config->rxchar_cb != NULL) {
    a3da:	2c 00 c0 1c 	mova	&7360,	r12	;0x01cc0
    a3de:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    a3e2:	9e 00 00 00 	cmpa	#0,	r14	;
    a3e6:	0d 24       	jz	$+28     	;abs 0xa402

0000a3e8 <.Loc.290.1>:
        UARTDA1.config->rxchar_cb(&UARTDA1, UCA1RXBUF);
    a3e8:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    a3ec:	ec 05 
    a3ee:	8c 00 bc 1c 	mova	#7356,	r12	;0x01cbc
    a3f2:	4e 13       	calla	r14		;

0000a3f4 <.LVL119>:
    a3f4:	80 00 14 a4 	mova	#42004,	r0	;0x0a414

0000a3f8 <.L82>:
          sts |= UART_BREAK_DETECTED;
    a3f8:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    a3fc:	4e 43       	clr.b	r14		;
    a3fe:	80 00 8c a3 	mova	#41868,	r0	;0x0a38c

0000a402 <.L78>:
        UCA1IFG &= ~UCRXIFG;
    a402:	40 18 92 c3 	bicx.w	#1,	&0x005fc;r3 As==01
    a406:	fc 05 
    a408:	80 00 14 a4 	mova	#42004,	r0	;0x0a414

0000a40c <.L68>:
      osalDbgAssert(false, "Spurious interrupt in USCI A1 UART");
    a40c:	8c 00 4b 74 	mova	#29771,	r12	;0x0744b
    a410:	b0 13 72 47 	calla	#18290		;0x04772

0000a414 <.L67>:
  OSAL_IRQ_EPILOGUE();
    a414:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a418 <.LVL123>:
    a418:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a41c:	3a 1c 
    a41e:	b0 13 22 45 	calla	#17698		;0x04522

0000a422 <.LVL124>:
    a422:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a426 <.LVL125>:
    a426:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a428:	0f 20       	jnz	$+32     	;abs 0xa448

0000a42a <.L81>:
    a42a:	b0 13 42 45 	calla	#17730		;0x04542

0000a42e <.LVL126>:
}
    a42e:	b4 16       	popm.a	#12,	r15	;20-bit words
    a430:	00 13       	reti			

0000a432 <.L84>:
  chSysLockFromISR();
    a432:	b0 13 64 45 	calla	#17764		;0x04564

0000a436 <.LBB53>:
  chThdResumeI(trp, msg);
    a436:	4d 43       	clr.b	r13		;
    a438:	8c 00 ca 1c 	mova	#7370,	r12	;0x01cca

0000a43c <.LVL128>:
    a43c:	b0 13 5a 49 	calla	#18778		;0x0495a

0000a440 <.LBB55>:
  chSysUnlockFromISR();
    a440:	b0 13 86 45 	calla	#17798		;0x04586

0000a444 <.LVL130>:
    a444:	80 00 64 a3 	mova	#41828,	r0	;0x0a364

0000a448 <.L85>:
  OSAL_IRQ_EPILOGUE();
    a448:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a44c <.LVL131>:
    a44c:	80 00 2a a4 	mova	#42026,	r0	;0x0a42a

0000a450 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    a450:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000a452 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    a452:	40 18 d2 43 	movx.b	#1,	&0x01c3a;r3 As==01
    a456:	3a 1c 
    a458:	b0 13 a8 45 	calla	#17832		;0x045a8

0000a45c <.LVL22>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    a45c:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    a460:	ae 03 
    a462:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    a466:	0c 20       	jnz	$+26     	;abs 0xa480

0000a468 <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    a468:	40 18 5c 42 	movx.b	&0x01d20,r12	;
    a46c:	20 1d 
    a46e:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    a472:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a474:	4d 9c       	cmp.b	r12,	r13	;
    a476:	13 2c       	jc	$+40     	;abs 0xa49e

0000a478 <.L25>:
      if (GPTDA1.state == GPT_ONESHOT) {
    a478:	40 18 e2 92 	cmpx.b	#4,	&0x01d20;r2 As==10
    a47c:	20 1d 
    a47e:	1b 24       	jz	$+56     	;abs 0xa4b6

0000a480 <.L23>:
  OSAL_IRQ_EPILOGUE();
    a480:	b0 13 ce 45 	calla	#17870		;0x045ce

0000a484 <.LVL23>:
    a484:	40 18 c2 43 	movx.b	#0,	&0x01c3a;r3 As==00
    a488:	3a 1c 
    a48a:	b0 13 22 45 	calla	#17698		;0x04522

0000a48e <.LVL24>:
    a48e:	b0 13 b8 48 	calla	#18616		;0x048b8

0000a492 <.LVL25>:
    a492:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a494:	18 20       	jnz	$+50     	;abs 0xa4c6

0000a496 <.L26>:
    a496:	b0 13 42 45 	calla	#17730		;0x04542

0000a49a <.LVL26>:
}
    a49a:	b4 16       	popm.a	#12,	r15	;20-bit words
    a49c:	00 13       	reti			

0000a49e <.L27>:
          NULL != GPTDA1.config->callback) {
    a49e:	2c 00 22 1d 	mova	&7458,	r12	;0x01d22
    a4a2:	3e 0c 04 00 	mova	4(r12),	r14	;

0000a4a6 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    a4a6:	9e 00 00 00 	cmpa	#0,	r14	;
    a4aa:	e6 27       	jz	$-50     	;abs 0xa478

0000a4ac <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    a4ac:	8c 00 20 1d 	mova	#7456,	r12	;0x01d20
    a4b0:	4e 13       	calla	r14		;

0000a4b2 <.LVL27>:
    a4b2:	80 00 78 a4 	mova	#42104,	r0	;0x0a478

0000a4b6 <.L28>:
        GPTDA1.state = GPT_READY;
    a4b6:	8c 00 20 1d 	mova	#7456,	r12	;0x01d20
    a4ba:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000a4be <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    a4be:	b0 13 fa 59 	calla	#23034		;0x059fa

0000a4c2 <.LVL28>:
    a4c2:	80 00 80 a4 	mova	#42112,	r0	;0x0a480

0000a4c6 <.L29>:
  OSAL_IRQ_EPILOGUE();
    a4c6:	b0 13 d0 48 	calla	#18640		;0x048d0

0000a4ca <.LVL29>:
    a4ca:	80 00 96 a4 	mova	#42134,	r0	;0x0a496
