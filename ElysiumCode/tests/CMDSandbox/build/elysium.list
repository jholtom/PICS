
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	64 44       	mov.b	@r4,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	68 44       	mov.b	@r4,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	6c 44       	mov.b	@r4,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	70 44       	br	@r4+		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	74 44       	mov.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	78 44       	mov.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	7c 44       	mov.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	80 44 00 00 	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	84 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8c 44       	mov	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	90 44 00 00 	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	94 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	9c 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a0 44 00 00 	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a4 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	ac 44       	mov	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b0 44 00 00 	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b4 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b8 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 44       	mov	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	c0 44 00 00 	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c4 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c8 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	cc 44       	mov.b	r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	d0 44 00 00 	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	d4 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	d8 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	dc 44       	mov.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e0 44 00 00 	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	c4 d7       	bis.b	r7		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	44 d7       	bis.b	r7,	r4	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e4 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	e8 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	c4 d6       	bis.b	r6		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 44       	mov.b	@r4		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	f0 44 00 00 	mov.b	@r4+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	48 d6       	bis.b	r6,	r8	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	32 da       	interrupt service routine at 0xda32

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f4 44       	interrupt service routine at 0x44f4

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	44 d8       	interrupt service routine at 0xd844

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	02 d9       	interrupt service routine at 0xd902

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	f8 44       	interrupt service routine at 0x44f8

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	fc 44       	interrupt service routine at 0x44fc

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	00 45       	interrupt service routine at 0x4500

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	04 45       	interrupt service routine at 0x4504

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	08 45       	interrupt service routine at 0x4508

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	0c 45       	interrupt service routine at 0x450c

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	0a d6       	interrupt service routine at 0xd60a

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	10 45       	interrupt service routine at 0x4510

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	14 45       	interrupt service routine at 0x4514

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	18 45       	interrupt service routine at 0x4518

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	81 00 82 ac 	mova	#44162,	r1	;0x0ac82

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_bss>:
    440c:	8c 00 52 d3 	mova	#54098,	r12	;0x0d352

00004410 <.Loc.74.1>:
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.75.1>:
    4412:	3e 40 b8 02 	mov	#696,	r14	;#0x02b8

00004416 <.Loc.77.1>:
    4416:	0f 43       	clr	r15		;

00004418 <.Loc.79.1>:
    4418:	b0 13 12 a0 	calla	#40978		;0x0a012

0000441c <__crt0_init_highbss>:
    441c:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e

00004420 <.Loc.94.1>:
    4420:	0d 43       	clr	r13		;

00004422 <.Loc.95.1>:
    4422:	8e 01 dc 08 	mova	#67804,	r14	;0x108dc

00004426 <.Loc.98.1>:
    4426:	0e 93       	cmp	#0,	r14	;r3 As==00

00004428 <.Loc.99.1>:
    4428:	02 24       	jz	$+6      	;abs 0x442e

0000442a <.Loc.100.1>:
    442a:	b0 13 12 a0 	calla	#40978		;0x0a012

0000442e <__crt0_move_highdata>:
    442e:	3e 40 17 00 	mov	#23,	r14	;#0x0017

00004432 <.Loc.146.1>:
    4432:	0e 93       	cmp	#0,	r14	;r3 As==00

00004434 <.Loc.147.1>:
    4434:	14 24       	jz	$+42     	;abs 0x445e

00004436 <.Loc.150.1>:
    4436:	41 18 82 93 	cmpx.w	#0,	&0x10504;r3 As==00
    443a:	04 05 

0000443c <.Loc.151.1>:
    443c:	05 24       	jz	$+12     	;abs 0x4448

0000443e <.Loc.153.1>:
    443e:	8c 01 06 05 	mova	#66822,	r12	;0x10506

00004442 <.Loc.154.1>:
    4442:	8d 01 06 05 	mova	#66822,	r13	;0x10506

00004446 <.Loc.155.1>:
    4446:	07 3c       	jmp	$+16     	;abs 0x4456

00004448 <.L11>:
    4448:	41 18 92 43 	movx.w	#1,	&0x10504;r3 As==01
    444c:	04 05 

0000444e <.Loc.159.1>:
    444e:	8c 01 06 05 	mova	#66822,	r12	;0x10506

00004452 <.Loc.160.1>:
    4452:	8d 01 06 05 	mova	#66822,	r13	;0x10506

00004456 <.L21>:
    4456:	3e 40 17 00 	mov	#23,	r14	;#0x0017

0000445a <.Loc.165.1>:
    445a:	b0 13 2c a0 	calla	#41004		;0x0a02c

0000445e <__crt0_call_just_main>:
    445e:	0c 43       	clr	r12		;

00004460 <.Loc.181.1>:
    4460:	b0 13 fa 9d 	calla	#40442		;0x09dfa

00004464 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    4464:	80 00 64 44 	mova	#17508,	r0	;0x04464

00004468 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    4468:	80 00 68 44 	mova	#17512,	r0	;0x04468

0000446c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    446c:	80 00 6c 44 	mova	#17516,	r0	;0x0446c

00004470 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    4470:	80 00 70 44 	mova	#17520,	r0	;0x04470

00004474 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    4474:	80 00 74 44 	mova	#17524,	r0	;0x04474

00004478 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    4478:	80 00 78 44 	mova	#17528,	r0	;0x04478

0000447c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    447c:	80 00 7c 44 	mova	#17532,	r0	;0x0447c

00004480 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    4480:	80 00 80 44 	mova	#17536,	r0	;0x04480

00004484 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    4484:	80 00 84 44 	mova	#17540,	r0	;0x04484

00004488 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    4488:	80 00 88 44 	mova	#17544,	r0	;0x04488

0000448c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    448c:	80 00 8c 44 	mova	#17548,	r0	;0x0448c

00004490 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    4490:	80 00 90 44 	mova	#17552,	r0	;0x04490

00004494 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    4494:	80 00 94 44 	mova	#17556,	r0	;0x04494

00004498 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    4498:	80 00 98 44 	mova	#17560,	r0	;0x04498

0000449c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    449c:	80 00 9c 44 	mova	#17564,	r0	;0x0449c

000044a0 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    44a0:	80 00 a0 44 	mova	#17568,	r0	;0x044a0

000044a4 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    44a4:	80 00 a4 44 	mova	#17572,	r0	;0x044a4

000044a8 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    44a8:	80 00 a8 44 	mova	#17576,	r0	;0x044a8

000044ac <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    44ac:	80 00 ac 44 	mova	#17580,	r0	;0x044ac

000044b0 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    44b0:	80 00 b0 44 	mova	#17584,	r0	;0x044b0

000044b4 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    44b4:	80 00 b4 44 	mova	#17588,	r0	;0x044b4

000044b8 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    44b8:	80 00 b8 44 	mova	#17592,	r0	;0x044b8

000044bc <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    44bc:	80 00 bc 44 	mova	#17596,	r0	;0x044bc

000044c0 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    44c0:	80 00 c0 44 	mova	#17600,	r0	;0x044c0

000044c4 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    44c4:	80 00 c4 44 	mova	#17604,	r0	;0x044c4

000044c8 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    44c8:	80 00 c8 44 	mova	#17608,	r0	;0x044c8

000044cc <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    44cc:	80 00 cc 44 	mova	#17612,	r0	;0x044cc

000044d0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    44d0:	80 00 d0 44 	mova	#17616,	r0	;0x044d0

000044d4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    44d4:	80 00 d4 44 	mova	#17620,	r0	;0x044d4

000044d8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    44d8:	80 00 d8 44 	mova	#17624,	r0	;0x044d8

000044dc <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    44dc:	80 00 dc 44 	mova	#17628,	r0	;0x044dc

000044e0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    44e0:	80 00 e0 44 	mova	#17632,	r0	;0x044e0

000044e4 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    44e4:	80 00 e4 44 	mova	#17636,	r0	;0x044e4

000044e8 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    44e8:	80 00 e8 44 	mova	#17640,	r0	;0x044e8

000044ec <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    44ec:	80 00 ec 44 	mova	#17644,	r0	;0x044ec

000044f0 <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    44f0:	80 00 f0 44 	mova	#17648,	r0	;0x044f0

000044f4 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    44f4:	80 00 f4 44 	mova	#17652,	r0	;0x044f4

000044f8 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    44f8:	80 00 f8 44 	mova	#17656,	r0	;0x044f8

000044fc <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    44fc:	80 00 fc 44 	mova	#17660,	r0	;0x044fc

00004500 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    4500:	80 00 00 45 	mova	#17664,	r0	;0x04500

00004504 <Vector48>:

  while (1) {
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {
    4504:	80 00 04 45 	mova	#17668,	r0	;0x04504

00004508 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    4508:	80 00 08 45 	mova	#17672,	r0	;0x04508

0000450c <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    450c:	80 00 0c 45 	mova	#17676,	r0	;0x0450c

00004510 <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    4510:	80 00 10 45 	mova	#17680,	r0	;0x04510

00004514 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    4514:	80 00 14 45 	mova	#17684,	r0	;0x04514

00004518 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    4518:	80 00 18 45 	mova	#17688,	r0	;0x04518

0000451c <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    451c:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    4520:	6c 05 

00004522 <.Loc.305.1>:
}
    4522:	10 01       	reta			;

00004524 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    4524:	03 43       	nop			

00004526 <.Loc.356.1>:
  _enable_interrupts();
    4526:	03 43       	nop			
    4528:	32 d2       	eint			
    452a:	03 43       	nop			

0000452c <.Loc.357.1>:
}
    452c:	10 01       	reta			;

0000452e <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    452e:	32 c2       	dint			
    4530:	03 43       	nop			

00004532 <.Loc.390.1>:
  asm volatile("nop");
    4532:	03 43       	nop			

00004534 <.Loc.391.1>:
}
    4534:	10 01       	reta			;

00004536 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4536:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    453a:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    453e:	04 20       	jnz	$+10     	;abs 0x4548

00004540 <.Loc.79.2>:
    4540:	8c 93 0c 00 	cmp	#0,	12(r12)	;r3 As==00, 0x000c
    4544:	01 20       	jnz	$+4      	;abs 0x4548

00004546 <.Loc.82.2>:
    chSysHalt("SV#2");
  }
}
    4546:	10 01       	reta			;

00004548 <.L8>:
    chSysHalt("SV#2");
    4548:	8c 00 87 ac 	mova	#44167,	r12	;0x0ac87
    454c:	b0 13 a0 47 	calla	#18336		;0x047a0

00004550 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4550:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4554:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    4558:	07 20       	jnz	$+16     	;abs 0x4568

0000455a <.Loc.103.2>:
    455a:	8c 93 0c 00 	cmp	#0,	12(r12)	;r3 As==00, 0x000c
    455e:	04 20       	jnz	$+10     	;abs 0x4568

00004560 <.Loc.106.2>:
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
    4560:	41 18 92 43 	movx.w	#1,	&0x1052a;r3 As==01
    4564:	2a 05 

00004566 <.Loc.107.2>:
}
    4566:	10 01       	reta			;

00004568 <.L14>:
    chSysHalt("SV#4");
    4568:	8c 00 91 ac 	mova	#44177,	r12	;0x0ac91
    456c:	b0 13 a0 47 	calla	#18336		;0x047a0

00004570 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4570:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4574:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    4578:	08 20       	jnz	$+18     	;abs 0x458a

0000457a <.Loc.116.2>:
    457a:	4d 43       	clr.b	r13		;
    457c:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4580:	04 34       	jge	$+10     	;abs 0x458a

00004582 <.Loc.119.2>:
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
    4582:	41 18 82 43 	movx.w	#0,	&0x1052a;r3 As==00
    4586:	2a 05 

00004588 <.Loc.120.2>:
}
    4588:	10 01       	reta			;

0000458a <.L17>:
    chSysHalt("SV#5");
    458a:	8c 00 96 ac 	mova	#44182,	r12	;0x0ac96
    458e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004592 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4592:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4596:	4d 43       	clr.b	r13		;
    4598:	1d 9c 0a 00 	cmp	10(r12),r13	;0x0000a
    459c:	07 34       	jge	$+16     	;abs 0x45ac

0000459e <.Loc.129.2>:
    459e:	8c 9d 0c 00 	cmp	r13,	12(r12)	; 0x000c
    45a2:	04 20       	jnz	$+10     	;abs 0x45ac

000045a4 <.Loc.132.2>:
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
    45a4:	41 18 92 43 	movx.w	#1,	&0x1052a;r3 As==01
    45a8:	2a 05 

000045aa <.Loc.133.2>:
}
    45aa:	10 01       	reta			;

000045ac <.L20>:
    chSysHalt("SV#6");
    45ac:	8c 00 9b ac 	mova	#44187,	r12	;0x0ac9b
    45b0:	b0 13 a0 47 	calla	#18336		;0x047a0

000045b4 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    45b4:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    45b8:	4d 43       	clr.b	r13		;
    45ba:	1d 9c 0a 00 	cmp	10(r12),r13	;0x0000a
    45be:	07 34       	jge	$+16     	;abs 0x45ce

000045c0 <.Loc.142.2>:
    45c0:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    45c4:	04 34       	jge	$+10     	;abs 0x45ce

000045c6 <.Loc.145.2>:
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
    45c6:	41 18 82 43 	movx.w	#0,	&0x1052a;r3 As==00
    45ca:	2a 05 

000045cc <.Loc.146.2>:
}
    45cc:	10 01       	reta			;

000045ce <.L23>:
    chSysHalt("SV#7");
    45ce:	8c 00 a0 ac 	mova	#44192,	r12	;0x0aca0
    45d2:	b0 13 a0 47 	calla	#18336		;0x047a0

000045d6 <_dbg_check_enter_isr>:
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45d6:	c0 18 1c 42 	movx.w	&0x10528,r12	;
    45da:	28 05 
    45dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    45de:	0a 38       	jl	$+22     	;abs 0x45f4

000045e0 <.Loc.156.2>:
    45e0:	8e 01 1e 05 	mova	#66846,	r14	;0x1051e
    45e4:	8e 93 0c 00 	cmp	#0,	12(r14)	;r3 As==00, 0x000c
    45e8:	05 20       	jnz	$+12     	;abs 0x45f4

000045ea <.Loc.159.2>:
    chSysHalt("SV#8");
  }
  nil.isr_cnt++;
    45ea:	1c 53       	inc	r12		;
    45ec:	41 18 82 4c 	movx.w	r12,	&0x10528;
    45f0:	28 05 

000045f2 <.Loc.161.2>:
  port_unlock_from_isr();
}
    45f2:	10 01       	reta			;

000045f4 <.L26>:
    chSysHalt("SV#8");
    45f4:	8c 00 a5 ac 	mova	#44197,	r12	;0x0aca5
    45f8:	b0 13 a0 47 	calla	#18336		;0x047a0

000045fc <_dbg_check_leave_isr>:
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    45fc:	c0 18 1c 42 	movx.w	&0x10528,r12	;
    4600:	28 05 
    4602:	4d 43       	clr.b	r13		;
    4604:	0d 9c       	cmp	r12,	r13	;
    4606:	0a 34       	jge	$+22     	;abs 0x461c

00004608 <.Loc.171.2>:
    4608:	8e 01 1e 05 	mova	#66846,	r14	;0x1051e
    460c:	8e 9d 0c 00 	cmp	r13,	12(r14)	; 0x000c
    4610:	05 20       	jnz	$+12     	;abs 0x461c

00004612 <.Loc.174.2>:
    chSysHalt("SV#9");
  }
  nil.isr_cnt--;
    4612:	3c 53       	add	#-1,	r12	;r3 As==11
    4614:	41 18 82 4c 	movx.w	r12,	&0x10528;
    4618:	28 05 

0000461a <.Loc.176.2>:
  port_unlock_from_isr();
}
    461a:	10 01       	reta			;

0000461c <.L29>:
    chSysHalt("SV#9");
    461c:	8c 00 aa ac 	mova	#44202,	r12	;0x0acaa
    4620:	b0 13 a0 47 	calla	#18336		;0x047a0

00004624 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4624:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4628:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    462c:	05 38       	jl	$+12     	;abs 0x4638

0000462e <.Loc.188.2>:
    462e:	4d 43       	clr.b	r13		;
    4630:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4634:	01 34       	jge	$+4      	;abs 0x4638

00004636 <.Loc.191.2>:
    chSysHalt("SV#10");
  }
}
    4636:	10 01       	reta			;

00004638 <.L32>:
    chSysHalt("SV#10");
    4638:	8c 00 af ac 	mova	#44207,	r12	;0x0acaf
    463c:	b0 13 a0 47 	calla	#18336		;0x047a0

00004640 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4640:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4644:	8c 93 0a 00 	cmp	#0,	10(r12)	;r3 As==00, 0x000a
    4648:	05 20       	jnz	$+12     	;abs 0x4654

0000464a <.Loc.203.2>:
    464a:	4d 43       	clr.b	r13		;
    464c:	1d 9c 0c 00 	cmp	12(r12),r13	;0x0000c
    4650:	01 34       	jge	$+4      	;abs 0x4654

00004652 <.Loc.206.2>:
    chSysHalt("SV#11");
  }
}
    4652:	10 01       	reta			;

00004654 <.L35>:
    chSysHalt("SV#11");
    4654:	8c 00 b5 ac 	mova	#44213,	r12	;0x0acb5
    4658:	b0 13 a0 47 	calla	#18336		;0x047a0

0000465c <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    465c:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004660 <.LCFI0>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    4660:	41 18 82 43 	movx.w	#0,	&0x10528;r3 As==00
    4664:	28 05 

00004666 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    4666:	41 18 82 43 	movx.w	#0,	&0x1052a;r3 As==00
    466a:	2a 05 

0000466c <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    466c:	80 18 f1 40 	movx.a	#66864,	16(r1)	;0x10530, 0x00010
    4670:	30 05 10 00 

00004674 <.Loc.234.2>:
  tcp = nil_thd_configs;
    4674:	80 18 f1 40 	movx.a	#66760,	12(r1)	;0x104c8, 0x0000c
    4678:	c8 04 0c 00 

0000467c <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    467c:	80 00 48 47 	mova	#18248,	r0	;0x04748

00004680 <.L39>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    4680:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    4684:	0d 0c       	mova	@r12,	r13	;
    4686:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    468a:	7c 0d 10 00 	mova	r13,	16(r12)	; 0x00010

0000468e <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    468e:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    4692:	3c 0c 04 00 	mova	4(r12),	r12	;
    4696:	cd 0c       	mova	r12,	r13	;
    4698:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    469c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46a0:	7c 0d 00 00 	mova	r13,	0(r12)	;
    46a4:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46a8:	0c 0c       	mova	@r12,	r12	;
    46aa:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    46ae:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    46b2:	71 0d 08 00 	mova	r13,	8(r1)	;
    46b6:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    46ba:	00 00 
    46bc:	3e 01 08 00 	mova	8(r1),	r14	;
    46c0:	0e 14       	pushm.a	#1,	r14	;20-bit words
    46c2:	0d 17       	popm	#1,	r13	;16-bit words
    46c4:	0d 17       	popm	#1,	r13	;16-bit words
    46c6:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    46ca:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    46ce:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    46d2:	4d de       	bis.b	r14,	r13	;
    46d4:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    46d8:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    46dc:	0c 0c       	mova	@r12,	r12	;
    46de:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    46e2:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    46e6:	71 0d 04 00 	mova	r13,	4(r1)	;
    46ea:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    46ee:	04 00 
    46f0:	3e 01 04 00 	mova	4(r1),	r14	;
    46f4:	0e 14       	pushm.a	#1,	r14	;20-bit words
    46f6:	0d 17       	popm	#1,	r13	;16-bit words
    46f8:	0d 17       	popm	#1,	r13	;16-bit words
    46fa:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    46fe:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    4702:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4706:	4d de       	bis.b	r14,	r13	;
    4708:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    470c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4710:	0c 0c       	mova	@r12,	r12	;
    4712:	00 18 f1 40 	movx.a	#20496,	0(r1)	;0x05010
    4716:	10 50 00 00 
    471a:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    471e:	0e 01       	mova	@r1,	r14	;
    4720:	0e 14       	pushm.a	#1,	r14	;20-bit words
    4722:	0d 17       	popm	#1,	r13	;16-bit words
    4724:	0d 17       	popm	#1,	r13	;16-bit words
    4726:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    472a:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    472e:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    4732:	4d de       	bis.b	r14,	r13	;
    4734:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

00004738 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    4738:	00 18 f1 50 	addx.a	#20,	16(r1)	;0x00014, 0x00010
    473c:	14 00 10 00 

00004740 <.Loc.247.2>:
    tcp++;
    4740:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    4744:	14 00 0c 00 

00004748 <.L38>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4748:	80 18 f1 90 	cmpx.a	#66904,	16(r1)	;0x10558, 0x00010
    474c:	58 05 10 00 
    4750:	97 2b       	jnc	$-208    	;abs 0x4680

00004752 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    4752:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4756:	00 18 fc 40 	movx.a	#44162,	16(r12)	;0x0ac82, 0x00010
    475a:	82 ac 10 00 

0000475e <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    475e:	b0 13 2e 45 	calla	#17710		;0x0452e

00004762 <.LVL15>:
    4762:	b0 13 36 45 	calla	#17718		;0x04536

00004766 <.LVL16>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    4766:	41 18 92 43 	movx.w	#1,	&0x1052a;r3 As==01
    476a:	2a 05 

0000476c <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    476c:	b0 13 fe 4d 	calla	#19966		;0x04dfe

00004770 <.LVL17>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    4770:	b0 13 1c 45 	calla	#17692		;0x0451c

00004774 <.LVL18>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4774:	81 18 f2 40 	movx.a	#66864,	&0x10522;0x10530
    4778:	30 05 22 05 
    477c:	2c 01 22 05 	mova	&66850,	r12	;0x10522
    4780:	61 0c 1e 05 	mova	r12,	&66846	; 0x1051e

00004784 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4784:	2c 01 1e 05 	mova	&66846,	r12	;0x1051e
    4788:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    478c:	b0 13 04 50 	calla	#20484		;0x05004

00004790 <.LVL19>:
  chSysUnlock();
    4790:	b0 13 70 45 	calla	#17776		;0x04570

00004794 <.LVL20>:
    4794:	b0 13 24 45 	calla	#17700		;0x04524

00004798 <.LVL21>:
}
    4798:	03 43       	nop			
    479a:	a1 00 14 00 	adda	#20,	r1	;0x00014
    479e:	10 01       	reta			;

000047a0 <chSysHalt>:
  _disable_interrupts();
    47a0:	32 c2       	dint			
    47a2:	03 43       	nop			

000047a4 <.Loc.381.1>:
  asm volatile("nop");
    47a4:	03 43       	nop			

000047a6 <.LBE81>:
void chSysHalt(const char *reason) {

  port_disable();

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    47a6:	61 0c 2c 05 	mova	r12,	&66860	; 0x1052c

000047aa <.L41>:
    47aa:	80 00 aa 47 	mova	#18346,	r0	;0x047aa

000047ae <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    47ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047b0 <.LCFI1>:

  chDbgCheckClassI();
    47b0:	b0 13 24 46 	calla	#17956		;0x04624

000047b4 <.LVL23>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    47b4:	8a 01 1e 05 	mova	#66846,	r10	;0x1051e
    47b8:	9a 53 08 00 	inc	8(r10)		;

000047bc <.Loc.321.2>:
  thread_t *tp = &nil.threads[0];
    47bc:	aa 00 12 00 	adda	#18,	r10	;0x00012
    47c0:	80 00 f0 47 	mova	#18416,	r0	;0x047f0

000047c4 <.L49>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    47c4:	8c 01 00 00 	mova	#65536,	r12	;0x10000
    47c8:	b0 13 a0 47 	calla	#18336		;0x047a0

000047cc <.L50>:
      if (--tp->timeout == (systime_t)0) {
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
          tp->u1.semp->cnt++;
    47cc:	3c 0a 06 00 	mova	6(r10),	r12	;
    47d0:	9c 53 00 00 	inc	0(r12)		;

000047d4 <.L46>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    47d4:	8d 0f ff ff 	mova	#-1,	r13	;0xffffffff
    47d8:	cc 0a       	mova	r10,	r12	;
    47da:	b0 13 7c 48 	calla	#18556		;0x0487c

000047de <.L43>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    47de:	b0 13 b4 45 	calla	#17844		;0x045b4

000047e2 <.LVL27>:
    tp++;
    47e2:	aa 00 14 00 	adda	#20,	r10	;0x00014

000047e6 <.Loc.348.2>:
    chSysLockFromISR();
    47e6:	b0 13 92 45 	calla	#17810		;0x04592

000047ea <.LVL29>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    47ea:	9a 01 58 05 	cmpa	#66904,	r10	;0x10558
    47ee:	1b 2c       	jc	$+56     	;abs 0x4826

000047f0 <.L47>:
    if (tp->timeout > (systime_t)0) {
    47f0:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    47f4:	0c 93       	cmp	#0,	r12	;r3 As==00
    47f6:	f3 27       	jz	$-24     	;abs 0x47de

000047f8 <.Loc.327.2>:
      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");
    47f8:	5d 4a 04 00 	mov.b	4(r10),	r13	;
    47fc:	0d 93       	cmp	#0,	r13	;r3 As==00
    47fe:	e2 27       	jz	$-58     	;abs 0x47c4

00004800 <.Loc.330.2>:
      if (--tp->timeout == (systime_t)0) {
    4800:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    4804:	3c 53       	add	#-1,	r12	;r3 As==11
    4806:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a
    480a:	0c 93       	cmp	#0,	r12	;r3 As==00
    480c:	e8 23       	jnz	$-46     	;abs 0x47de

0000480e <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    480e:	3d 90 03 00 	cmp	#3,	r13	;
    4812:	dc 27       	jz	$-70     	;abs 0x47cc

00004814 <.Loc.337.2>:
        else if (NIL_THD_IS_SUSP(tp)) {
    4814:	2d 93       	cmp	#2,	r13	;r3 As==10
    4816:	de 23       	jnz	$-66     	;abs 0x47d4

00004818 <.Loc.338.2>:
          *tp->u1.trp = NULL;
    4818:	3c 0a 06 00 	mova	6(r10),	r12	;
    481c:	00 18 cc 43 	movx.a	#0,	0(r12)	;r3 As==00
    4820:	00 00 
    4822:	80 00 d4 47 	mova	#18388,	r0	;0x047d4

00004826 <.L48>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    4826:	0a 16       	popm.a	#1,	r10	;20-bit words
    4828:	10 01       	reta			;

0000482a <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    482a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000482c <.LBB91>:
  return __get_SR_register();
    482c:	0a 42       	mov	r2,	r10	;

0000482e <.LBE91>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    482e:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    4832:	09 24       	jz	$+20     	;abs 0x4846

00004834 <.Loc.450.2>:
    if (port_is_isr_context()) {
    4834:	41 18 c2 93 	cmpx.b	#0,	&0x1056c;r3 As==00
    4838:	6c 05 
    483a:	08 20       	jnz	$+18     	;abs 0x484c

0000483c <.LBB93>:
  _disable_interrupts();
    483c:	32 c2       	dint			
    483e:	03 43       	nop			

00004840 <.Loc.348.1>:
  asm volatile("nop");
    4840:	03 43       	nop			

00004842 <.LBE93>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    4842:	b0 13 50 45 	calla	#17744		;0x04550

00004846 <.L58>:
    }
  }
  return sts;
}
    4846:	0c 4a       	mov	r10,	r12	;
    4848:	0a 16       	popm.a	#1,	r10	;20-bit words
    484a:	10 01       	reta			;

0000484c <.L60>:
      chSysLockFromISR();
    484c:	b0 13 92 45 	calla	#17810		;0x04592

00004850 <.LVL34>:
    4850:	80 00 46 48 	mova	#18502,	r0	;0x04846

00004854 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    4854:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    4858:	0c 24       	jz	$+26     	;abs 0x4872

0000485a <.Loc.472.2>:
    if (port_is_isr_context()) {
    485a:	41 18 c2 93 	cmpx.b	#0,	&0x1056c;r3 As==00
    485e:	6c 05 
    4860:	09 20       	jnz	$+20     	;abs 0x4874

00004862 <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    4862:	b0 13 30 49 	calla	#18736		;0x04930

00004866 <.LVL36>:
      chSysUnlock();
    4866:	b0 13 70 45 	calla	#17776		;0x04570

0000486a <.LBB95>:
  asm volatile("nop");
    486a:	03 43       	nop			

0000486c <.Loc.356.1>:
  _enable_interrupts();
    486c:	03 43       	nop			
    486e:	32 d2       	eint			
    4870:	03 43       	nop			

00004872 <.L61>:
    }
  }
}
    4872:	10 01       	reta			;

00004874 <.L64>:
      chSysUnlockFromISR();
    4874:	b0 13 b4 45 	calla	#17844		;0x045b4

00004878 <.LVL39>:
    4878:	80 00 72 48 	mova	#18546,	r0	;0x04872

0000487c <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    487c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000487e <.LCFI3>:
    487e:	b1 00 04 00 	suba	#4,	r1	;

00004882 <.LCFI4>:
    4882:	ca 0c       	mova	r12,	r10	;
    4884:	71 0d 00 00 	mova	r13,	0(r1)	;

00004888 <.Loc.536.2>:

  chDbgCheckClassI();
    4888:	b0 13 24 46 	calla	#17956		;0x04624

0000488c <.LVL41>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    488c:	9a 01 30 05 	cmpa	#66864,	r10	;0x10530
    4890:	2d 28       	jnc	$+92     	;abs 0x48ec

00004892 <.Loc.537.2>:
    4892:	9a 01 58 05 	cmpa	#66904,	r10	;0x10558
    4896:	2a 2c       	jc	$+86     	;abs 0x48ec

00004898 <.Loc.538.2>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    4898:	ca 93 04 00 	cmp.b	#0,	4(r10)	;r3 As==00
    489c:	2b 24       	jz	$+88     	;abs 0x48f4

0000489e <.Loc.539.2>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    489e:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    48a2:	00 18 dc 9c 	cmpx.a	4(r12),	0(r12)	;
    48a6:	04 00 00 00 
    48aa:	28 28       	jnc	$+82     	;abs 0x48fc

000048ac <.Loc.541.2>:

  tp->u1.msg = msg;
    48ac:	aa 41 06 00 	mov	@r1,	6(r10)	;
    48b0:	0d 01       	mova	@r1,	r13	;
    48b2:	0d 14       	pushm.a	#1,	r13	;20-bit words
    48b4:	0c 17       	popm	#1,	r12	;16-bit words
    48b6:	0c 17       	popm	#1,	r12	;16-bit words
    48b8:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    48bc:	5d 4a 08 00 	mov.b	8(r10),	r13	;
    48c0:	7d f0 f0 ff 	and.b	#-16,	r13	;#0xfff0
    48c4:	4d dc       	bis.b	r12,	r13	;
    48c6:	ca 4d 08 00 	mov.b	r13,	8(r10)	;

000048ca <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    48ca:	ca 43 04 00 	mov.b	#0,	4(r10)	;r3 As==00

000048ce <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    48ce:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

000048d2 <.Loc.544.2>:
  if (tp < nil.next) {
    48d2:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    48d6:	00 18 5a 9c 	cmpx.a	4(r12),	r10	;
    48da:	04 00 
    48dc:	02 2c       	jc	$+6      	;abs 0x48e2

000048de <.Loc.545.2>:
    nil.next = tp;
    48de:	61 0a 22 05 	mova	r10,	&66850	; 0x10522

000048e2 <.L70>:
  }
  return tp;
}
    48e2:	cc 0a       	mova	r10,	r12	;
    48e4:	a1 00 04 00 	adda	#4,	r1	;

000048e8 <.LVL42>:
    48e8:	0a 16       	popm.a	#1,	r10	;20-bit words
    48ea:	10 01       	reta			;

000048ec <.L66>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
    48ec:	8c 01 13 00 	mova	#65555,	r12	;0x10013
    48f0:	b0 13 a0 47 	calla	#18336		;0x047a0

000048f4 <.L71>:
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
    48f4:	8c 01 13 00 	mova	#65555,	r12	;0x10013
    48f8:	b0 13 a0 47 	calla	#18336		;0x047a0

000048fc <.L72>:
  chDbgAssert(nil.next <= nil.current, "priority ordering");
    48fc:	8c 01 13 00 	mova	#65555,	r12	;0x10013
    4900:	b0 13 a0 47 	calla	#18336		;0x047a0

00004904 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    4904:	8e 01 1e 05 	mova	#66846,	r14	;0x1051e
    4908:	5c 43       	mov.b	#1,	r12	;r3 As==01
    490a:	00 18 de 9e 	cmpx.a	4(r14),	0(r14)	;
    490e:	04 00 00 00 
    4912:	01 24       	jz	$+4      	;abs 0x4916

00004914 <.L74>:
}
    4914:	10 01       	reta			;

00004916 <.L75>:
  return chSchIsRescRequiredI();
    4916:	4c 43       	clr.b	r12		;
    4918:	80 00 14 49 	mova	#18708,	r0	;0x04914

0000491c <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    491c:	8e 01 1e 05 	mova	#66846,	r14	;0x1051e
    4920:	0d 0e       	mova	@r14,	r13	;

00004922 <.LVL47>:

  nil.current = nil.next;
    4922:	3c 0e 04 00 	mova	4(r14),	r12	;
    4926:	7e 0c 00 00 	mova	r12,	0(r14)	;

0000492a <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    492a:	b0 13 04 50 	calla	#20484		;0x05004

0000492e <.LVL48>:
}
    492e:	10 01       	reta			;

00004930 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    4930:	b0 13 40 46 	calla	#17984		;0x04640

00004934 <.LVL49>:

  if (chSchIsRescRequiredI()) {
    4934:	8c 01 1e 05 	mova	#66846,	r12	;0x1051e
    4938:	00 18 dc 9c 	cmpx.a	4(r12),	0(r12)	;
    493c:	04 00 00 00 
    4940:	02 24       	jz	$+6      	;abs 0x4946

00004942 <.Loc.595.2>:
    chSchDoReschedule();
    4942:	b0 13 1c 49 	calla	#18716		;0x0491c

00004946 <.L77>:
  }
}
    4946:	10 01       	reta			;

00004948 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    4948:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000494a <.LCFI5>:
    494a:	49 4c       	mov.b	r12,	r9	;
    494c:	08 4d       	mov	r13,	r8	;

0000494e <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    494e:	2a 01 1e 05 	mova	&66846,	r10	;0x1051e

00004952 <.Loc.619.2>:

  chDbgCheckClassS();
    4952:	b0 13 40 46 	calla	#17984		;0x04640

00004956 <.LVL53>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    4956:	9a 01 58 05 	cmpa	#66904,	r10	;0x10558
    495a:	13 24       	jz	$+40     	;abs 0x4982

0000495c <.Loc.625.2>:
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    495c:	ca 49 04 00 	mov.b	r9,	4(r10)	;

00004960 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    4960:	8a 48 0a 00 	mov	r8,	10(r10)	; 0x000a

00004964 <.LVL54>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    4964:	8c 01 30 05 	mova	#66864,	r12	;0x10530

00004968 <.L82>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    4968:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    496c:	0e 24       	jz	$+30     	;abs 0x498a

0000496e <.Loc.677.2>:
      port_switch(ntp, otp);
      return nil.current->u1.msg;
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    496e:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004972 <.Loc.678.2>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
    4972:	8d 01 58 05 	mova	#66904,	r13	;0x10558
    4976:	dd 0c       	cmpa	r12,	r13	;
    4978:	f7 2f       	jc	$-16     	;abs 0x4968

0000497a <.Loc.678.2>:
    497a:	8c 01 1f 00 	mova	#65567,	r12	;0x1001f

0000497e <.LVL57>:
    497e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004982 <.L84>:
  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
    4982:	8c 01 1f 00 	mova	#65567,	r12	;0x1001f
    4986:	b0 13 a0 47 	calla	#18336		;0x047a0

0000498a <.L85>:
      nil.current = nil.next = ntp;
    498a:	88 01 1e 05 	mova	#66846,	r8	;0x1051e

0000498e <.LVL60>:
    498e:	78 0c 04 00 	mova	r12,	4(r8)	;
    4992:	78 0c 00 00 	mova	r12,	0(r8)	;

00004996 <.Loc.672.2>:
      port_switch(ntp, otp);
    4996:	cd 0a       	mova	r10,	r13	;
    4998:	b0 13 04 50 	calla	#20484		;0x05004

0000499c <.LVL61>:
      return nil.current->u1.msg;
    499c:	0c 08       	mova	@r8,	r12	;
    499e:	3c 0c 06 00 	mova	6(r12),	r12	;

000049a2 <.Loc.681.2>:
                "pointer out of range");
  }
}
    49a2:	28 16       	popm.a	#3,	r10	;20-bit words
    49a4:	10 01       	reta			;

000049a6 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    49a6:	0e 0c       	mova	@r12,	r14	;
    49a8:	9e 00 00 00 	cmpa	#0,	r14	;
    49ac:	09 24       	jz	$+20     	;abs 0x49c0

000049ae <.LBB97>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    49ae:	ee 93 04 00 	cmp.b	#2,	4(r14)	;r3 As==10
    49b2:	07 20       	jnz	$+16     	;abs 0x49c2

000049b4 <.Loc.723.2>:

    *trp = NULL;
    49b4:	00 18 cc 43 	movx.a	#0,	0(r12)	;r3 As==00
    49b8:	00 00 

000049ba <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    49ba:	cc 0e       	mova	r14,	r12	;

000049bc <.LVL70>:
    49bc:	b0 13 7c 48 	calla	#18556		;0x0487c

000049c0 <.L89>:
  }
}
    49c0:	10 01       	reta			;

000049c2 <.L92>:
    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");
    49c2:	8c 01 49 00 	mova	#65609,	r12	;0x10049

000049c6 <.LVL73>:
    49c6:	b0 13 a0 47 	calla	#18336		;0x047a0

000049ca <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    49ca:	1a 14       	pushm.a	#2,	r10	;20-bit words

000049cc <.LCFI8>:
    49cc:	ca 0c       	mova	r12,	r10	;
    49ce:	09 4d       	mov	r13,	r9	;

000049d0 <.LBB107>:
  _disable_interrupts();
    49d0:	32 c2       	dint			
    49d2:	03 43       	nop			

000049d4 <.Loc.348.1>:
  asm volatile("nop");
    49d4:	03 43       	nop			

000049d6 <.LBE107>:
  msg_t msg;

  chSysLock();
    49d6:	b0 13 50 45 	calla	#17744		;0x04550

000049da <.LVL85>:
  msg = chSemWaitTimeoutS(sp, timeout);
    49da:	0d 49       	mov	r9,	r13	;
    49dc:	cc 0a       	mova	r10,	r12	;
    49de:	b0 13 f6 49 	calla	#18934		;0x049f6

000049e2 <.LVL86>:
    49e2:	ca 0c       	mova	r12,	r10	;

000049e4 <.LVL87>:
  chSysUnlock();
    49e4:	b0 13 70 45 	calla	#17776		;0x04570

000049e8 <.LBB109>:
  asm volatile("nop");
    49e8:	03 43       	nop			

000049ea <.Loc.356.1>:
  _enable_interrupts();
    49ea:	03 43       	nop			
    49ec:	32 d2       	eint			
    49ee:	03 43       	nop			

000049f0 <.LBE109>:

  return msg;
}
    49f0:	cc 0a       	mova	r10,	r12	;
    49f2:	19 16       	popm.a	#2,	r10	;20-bit words
    49f4:	10 01       	reta			;

000049f6 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    49f6:	1a 14       	pushm.a	#2,	r10	;20-bit words

000049f8 <.LCFI9>:
    49f8:	ca 0c       	mova	r12,	r10	;
    49fa:	09 4d       	mov	r13,	r9	;

000049fc <.Loc.808.2>:

  chDbgCheckClassS();
    49fc:	b0 13 40 46 	calla	#17984		;0x04640

00004a00 <.LVL90>:
  chDbgCheck(sp != NULL);
    4a00:	9a 00 00 00 	cmpa	#0,	r10	;
    4a04:	0a 24       	jz	$+22     	;abs 0x4a1a

00004a06 <.Loc.813.2>:

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    4a06:	2c 4a       	mov	@r10,	r12	;

00004a08 <.LVL91>:
  if (cnt <= (cnt_t)0) {
    4a08:	4d 43       	clr.b	r13		;
    4a0a:	0d 9c       	cmp	r12,	r13	;
    4a0c:	0a 34       	jge	$+22     	;abs 0x4a22

00004a0e <.Loc.822.2>:
    }
    sp->cnt = cnt - (cnt_t)1;
    nil.current->u1.semp = sp;
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
  }
  sp->cnt = cnt - (cnt_t)1;
    4a0e:	3c 53       	add	#-1,	r12	;r3 As==11

00004a10 <.LVL92>:
    4a10:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004a14 <.Loc.823.2>:
  return MSG_OK;
    4a14:	4c 43       	clr.b	r12		;

00004a16 <.L96>:
}
    4a16:	19 16       	popm.a	#2,	r10	;20-bit words
    4a18:	10 01       	reta			;

00004a1a <.L101>:
  chDbgCheck(sp != NULL);
    4a1a:	8c 01 56 00 	mova	#65622,	r12	;0x10056
    4a1e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004a22 <.L102>:
    if (TIME_IMMEDIATE == timeout) {
    4a22:	39 93       	cmp	#-1,	r9	;r3 As==11
    4a24:	0e 24       	jz	$+30     	;abs 0x4a42

00004a26 <.Loc.818.2>:
    sp->cnt = cnt - (cnt_t)1;
    4a26:	3c 53       	add	#-1,	r12	;r3 As==11

00004a28 <.LVL95>:
    4a28:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004a2c <.Loc.819.2>:
    nil.current->u1.semp = sp;
    4a2c:	2c 01 1e 05 	mova	&66846,	r12	;0x1051e

00004a30 <.LVL96>:
    4a30:	7c 0a 06 00 	mova	r10,	6(r12)	;

00004a34 <.LVL97>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    4a34:	0d 49       	mov	r9,	r13	;
    4a36:	7c 40 03 00 	mov.b	#3,	r12	;
    4a3a:	b0 13 48 49 	calla	#18760		;0x04948

00004a3e <.LVL98>:
    4a3e:	80 00 16 4a 	mova	#18966,	r0	;0x04a16

00004a42 <.L100>:
      return MSG_TIMEOUT;
    4a42:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004a46 <.LVL100>:
    4a46:	80 00 16 4a 	mova	#18966,	r0	;0x04a16

00004a4a <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    4a4a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a4c <.LCFI11>:
    4a4c:	ca 0c       	mova	r12,	r10	;

00004a4e <.Loc.854.2>:

  chDbgCheckClassI();
    4a4e:	b0 13 24 46 	calla	#17956		;0x04624

00004a52 <.LVL107>:
  chDbgCheck(sp != NULL);
    4a52:	9a 00 00 00 	cmpa	#0,	r10	;
    4a56:	09 24       	jz	$+20     	;abs 0x4a6a

00004a58 <.Loc.857.2>:

  if (++sp->cnt <= (cnt_t)0) {
    4a58:	2c 4a       	mov	@r10,	r12	;
    4a5a:	1c 53       	inc	r12		;
    4a5c:	8a 4c 00 00 	mov	r12,	0(r10)	;
    4a60:	4d 43       	clr.b	r13		;
    4a62:	0d 9c       	cmp	r12,	r13	;
    4a64:	06 34       	jge	$+14     	;abs 0x4a72

00004a66 <.L104>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4a66:	0a 16       	popm.a	#1,	r10	;20-bit words
    4a68:	10 01       	reta			;

00004a6a <.L110>:
  chDbgCheck(sp != NULL);
    4a6a:	8c 01 68 00 	mova	#65640,	r12	;0x10068
    4a6e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004a72 <.L111>:
    4a72:	8c 01 30 05 	mova	#66864,	r12	;0x10530

00004a76 <.L109>:
      if (tr->u1.semp == sp) {
    4a76:	00 18 5a 9c 	cmpx.a	6(r12),	r10	;
    4a7a:	06 00 
    4a7c:	09 24       	jz	$+20     	;abs 0x4a90

00004a7e <.Loc.868.2>:
      tr++;
    4a7e:	ac 00 14 00 	adda	#20,	r12	;0x00014

00004a82 <.Loc.870.2>:
      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
    4a82:	9c 01 58 05 	cmpa	#66904,	r12	;0x10558
    4a86:	f7 2b       	jnc	$-16     	;abs 0x4a76

00004a88 <.Loc.870.2>:
    4a88:	8c 01 68 00 	mova	#65640,	r12	;0x10068

00004a8c <.LVL111>:
    4a8c:	b0 13 a0 47 	calla	#18336		;0x047a0

00004a90 <.L112>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4a90:	fc 90 03 00 	cmp.b	#3,	4(r12)	;
    4a94:	04 00 
    4a96:	05 20       	jnz	$+12     	;abs 0x4aa2

00004a98 <.Loc.865.2>:
        (void) chSchReadyI(tr, MSG_OK);
    4a98:	4d 43       	clr.b	r13		;
    4a9a:	b0 13 7c 48 	calla	#18556		;0x0487c

00004a9e <.LVL113>:
        return;
    4a9e:	80 00 66 4a 	mova	#19046,	r0	;0x04a66

00004aa2 <.L113>:
        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");
    4aa2:	8c 01 68 00 	mova	#65640,	r12	;0x10068

00004aa6 <.LVL115>:
    4aa6:	b0 13 a0 47 	calla	#18336		;0x047a0

00004aaa <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    4aaa:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004aac <.LCFI14>:
    4aac:	ca 0c       	mova	r12,	r10	;
    4aae:	08 4d       	mov	r13,	r8	;
    4ab0:	09 4e       	mov	r14,	r9	;

00004ab2 <.LBB120>:
  _disable_interrupts();
    4ab2:	32 c2       	dint			
    4ab4:	03 43       	nop			

00004ab6 <.Loc.348.1>:
  asm volatile("nop");
    4ab6:	03 43       	nop			

00004ab8 <.LBE120>:

  chSysLock();
    4ab8:	b0 13 50 45 	calla	#17744		;0x04550

00004abc <.LVL135>:
  chEvtSignalI(tp, mask);
    4abc:	0d 48       	mov	r8,	r13	;
    4abe:	0e 49       	mov	r9,	r14	;
    4ac0:	cc 0a       	mova	r10,	r12	;
    4ac2:	b0 13 da 4a 	calla	#19162		;0x04ada

00004ac6 <.LVL136>:
  chSchRescheduleS();
    4ac6:	b0 13 30 49 	calla	#18736		;0x04930

00004aca <.LVL137>:
  chSysUnlock();
    4aca:	b0 13 70 45 	calla	#17776		;0x04570

00004ace <.LBB122>:
  asm volatile("nop");
    4ace:	03 43       	nop			

00004ad0 <.Loc.356.1>:
  _enable_interrupts();
    4ad0:	03 43       	nop			
    4ad2:	32 d2       	eint			
    4ad4:	03 43       	nop			

00004ad6 <.LBE122>:
}
    4ad6:	28 16       	popm.a	#3,	r10	;20-bit words
    4ad8:	10 01       	reta			;

00004ada <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    4ada:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004adc <.LCFI15>:
    4adc:	ca 0c       	mova	r12,	r10	;
    4ade:	09 4d       	mov	r13,	r9	;
    4ae0:	08 4e       	mov	r14,	r8	;

00004ae2 <.Loc.971.2>:

  chDbgCheckClassI();
    4ae2:	b0 13 24 46 	calla	#17956		;0x04624

00004ae6 <.LVL140>:
  chDbgCheck(tp != NULL);
    4ae6:	9a 00 00 00 	cmpa	#0,	r10	;
    4aea:	0f 24       	jz	$+32     	;abs 0x4b0a

00004aec <.Loc.974.2>:

  tp->epmask |= mask;
    4aec:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    4af0:	0d d9       	bis	r9,	r13	;
    4af2:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    4af6:	0e d8       	bis	r8,	r14	;
    4af8:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    4afc:	8a 4e 0e 00 	mov	r14,	14(r10)	; 0x000e

00004b00 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4b00:	ea 92 04 00 	cmp.b	#4,	4(r10)	;r2 As==10
    4b04:	06 24       	jz	$+14     	;abs 0x4b12

00004b06 <.L127>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    (void) chSchReadyI(tp, MSG_OK);
  }
}
    4b06:	28 16       	popm.a	#3,	r10	;20-bit words
    4b08:	10 01       	reta			;

00004b0a <.L131>:
  chDbgCheck(tp != NULL);
    4b0a:	8c 01 81 00 	mova	#65665,	r12	;0x10081
    4b0e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004b12 <.L132>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4b12:	1d fa 06 00 	and	6(r10),	r13	;
    4b16:	1e fa 08 00 	and	8(r10),	r14	;

00004b1a <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4b1a:	0c 4d       	mov	r13,	r12	;
    4b1c:	0c de       	bis	r14,	r12	;
    4b1e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4b20:	f2 27       	jz	$-26     	;abs 0x4b06

00004b22 <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    4b22:	4d 43       	clr.b	r13		;
    4b24:	cc 0a       	mova	r10,	r12	;
    4b26:	b0 13 7c 48 	calla	#18556		;0x0487c

00004b2a <.LVL142>:
}
    4b2a:	80 00 06 4b 	mova	#19206,	r0	;0x04b06

00004b2e <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    4b2e:	5a 14       	pushm.a	#6,	r10	;20-bit words

00004b30 <.LCFI16>:
    4b30:	06 4c       	mov	r12,	r6	;
    4b32:	07 4d       	mov	r13,	r7	;
    4b34:	05 4e       	mov	r14,	r5	;

00004b36 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    4b36:	2a 01 1e 05 	mova	&66846,	r10	;0x1051e

00004b3a <.LBB124>:
  _disable_interrupts();
    4b3a:	32 c2       	dint			
    4b3c:	03 43       	nop			

00004b3e <.Loc.348.1>:
  asm volatile("nop");
    4b3e:	03 43       	nop			

00004b40 <.LBE124>:
  eventmask_t m;

  chSysLock();
    4b40:	b0 13 50 45 	calla	#17744		;0x04550

00004b44 <.LVL145>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    4b44:	19 4a 0c 00 	mov	12(r10),r9	;0x0000c
    4b48:	09 f6       	and	r6,	r9	;
    4b4a:	18 4a 0e 00 	mov	14(r10),r8	;0x0000e
    4b4e:	08 f7       	and	r7,	r8	;

00004b50 <.LVL146>:
    4b50:	0c 49       	mov	r9,	r12	;
    4b52:	0c d8       	bis	r8,	r12	;
    4b54:	0c 93       	cmp	#0,	r12	;r3 As==00
    4b56:	13 20       	jnz	$+40     	;abs 0x4b7e

00004b58 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4b58:	35 93       	cmp	#-1,	r5	;r3 As==11
    4b5a:	1f 24       	jz	$+64     	;abs 0x4b9a

00004b5c <.Loc.1010.2>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    4b5c:	8a 46 06 00 	mov	r6,	6(r10)	;
    4b60:	8a 47 08 00 	mov	r7,	8(r10)	;

00004b64 <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    4b64:	0d 45       	mov	r5,	r13	;
    4b66:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4b68:	b0 13 48 49 	calla	#18760		;0x04948

00004b6c <.LVL147>:
    4b6c:	9c 00 00 00 	cmpa	#0,	r12	;
    4b70:	1c 38       	jl	$+58     	;abs 0x4baa

00004b72 <.Loc.1016.2>:
      chSysUnlock();

      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    4b72:	09 46       	mov	r6,	r9	;

00004b74 <.LVL148>:
    4b74:	19 fa 0c 00 	and	12(r10),r9	;0x0000c
    4b78:	08 47       	mov	r7,	r8	;
    4b7a:	18 fa 0e 00 	and	14(r10),r8	;0x0000e

00004b7e <.L134>:
  }
  ctp->epmask &= ~m;
    4b7e:	8a c9 0c 00 	bic	r9,	12(r10)	; 0x000c
    4b82:	8a c8 0e 00 	bic	r8,	14(r10)	; 0x000e

00004b86 <.Loc.1019.2>:
  chSysUnlock();
    4b86:	b0 13 70 45 	calla	#17776		;0x04570

00004b8a <.LBB126>:
  asm volatile("nop");
    4b8a:	03 43       	nop			

00004b8c <.Loc.356.1>:
  _enable_interrupts();
    4b8c:	03 43       	nop			
    4b8e:	32 d2       	eint			
    4b90:	03 43       	nop			

00004b92 <.L133>:

  return m;
}
    4b92:	0c 49       	mov	r9,	r12	;
    4b94:	0d 48       	mov	r8,	r13	;
    4b96:	55 16       	popm.a	#6,	r10	;20-bit words
    4b98:	10 01       	reta			;

00004b9a <.L138>:
      chSysUnlock();
    4b9a:	b0 13 70 45 	calla	#17776		;0x04570

00004b9e <.LBB128>:
  asm volatile("nop");
    4b9e:	03 43       	nop			

00004ba0 <.Loc.356.1>:
  _enable_interrupts();
    4ba0:	03 43       	nop			
    4ba2:	32 d2       	eint			
    4ba4:	03 43       	nop			

00004ba6 <.LBE128>:
      return (eventmask_t)0;
    4ba6:	80 00 92 4b 	mova	#19346,	r0	;0x04b92

00004baa <.L139>:
      chSysUnlock();
    4baa:	b0 13 70 45 	calla	#17776		;0x04570

00004bae <.LBB130>:
  asm volatile("nop");
    4bae:	03 43       	nop			

00004bb0 <.Loc.356.1>:
  _enable_interrupts();
    4bb0:	03 43       	nop			
    4bb2:	32 d2       	eint			
    4bb4:	03 43       	nop			

00004bb6 <.LBE130>:
      return (eventmask_t)0;
    4bb6:	80 00 92 4b 	mova	#19346,	r0	;0x04b92

00004bba <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4bba:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004bbc <.LCFI6>:
    4bbc:	08 14       	pushm.a	#1,	r8	;20-bit words

00004bbe <.LCFI7>:
    4bbe:	06 14       	pushm.a	#1,	r6	;20-bit words

00004bc0 <.LCFI8>:
    4bc0:	ca 0c       	mova	r12,	r10	;
    4bc2:	c6 0d       	mova	r13,	r6	;
    4bc4:	08 4e       	mov	r14,	r8	;

00004bc6 <.Loc.187.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4bc6:	b0 13 40 46 	calla	#17984		;0x04640

00004bca <.LVL17>:
  chDbgCheck(mbp != NULL);
    4bca:	9a 00 00 00 	cmpa	#0,	r10	;
    4bce:	27 24       	jz	$+80     	;abs 0x4c1e

00004bd0 <.L9>:

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4bd0:	0d 48       	mov	r8,	r13	;
    4bd2:	cc 0a       	mova	r10,	r12	;
    4bd4:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4bd8:	b0 13 f6 49 	calla	#18934		;0x049f6

00004bdc <.LVL18>:
    4bdc:	c8 0c       	mova	r12,	r8	;

00004bde <.LVL19>:
  if (rdymsg == MSG_OK) {
    4bde:	9c 00 00 00 	cmpa	#0,	r12	;
    4be2:	18 20       	jnz	$+50     	;abs 0x4c14

00004be4 <.Loc.192.1>:
    *mbp->wrptr++ = msg;
    4be4:	3c 0a 08 00 	mova	8(r10),	r12	;
    4be8:	cd 0c       	mova	r12,	r13	;
    4bea:	ad 00 04 00 	adda	#4,	r13	;
    4bee:	7a 0d 08 00 	mova	r13,	8(r10)	;
    4bf2:	7c 06 00 00 	mova	r6,	0(r12)	;

00004bf6 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4bf6:	00 18 da 9a 	cmpx.a	4(r10),	8(r10)	;
    4bfa:	04 00 08 00 
    4bfe:	03 28       	jnc	$+8      	;abs 0x4c06

00004c00 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    4c00:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4c04:	08 00 

00004c06 <.L11>:
    }
    chSemSignalI(&mbp->fullsem);
    4c06:	cc 0a       	mova	r10,	r12	;
    4c08:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4c0c:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00004c10 <.LVL20>:
    chSchRescheduleS();
    4c10:	b0 13 30 49 	calla	#18736		;0x04930

00004c14 <.L8>:
  }

  return rdymsg;
}
    4c14:	cc 08       	mova	r8,	r12	;
    4c16:	06 16       	popm.a	#1,	r6	;20-bit words
    4c18:	08 16       	popm.a	#1,	r8	;20-bit words
    4c1a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4c1c:	10 01       	reta			;

00004c1e <.L12>:
  chDbgCheck(mbp != NULL);
    4c1e:	8c 01 cc 00 	mova	#65740,	r12	;0x100cc
    4c22:	b0 13 a0 47 	calla	#18336		;0x047a0

00004c26 <.LVL23>:
    4c26:	80 00 d0 4b 	mova	#19408,	r0	;0x04bd0

00004c2a <chMBPost>:
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4c2a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004c2c <.LCFI9>:
    4c2c:	ca 0c       	mova	r12,	r10	;
    4c2e:	c8 0d       	mova	r13,	r8	;
    4c30:	09 4e       	mov	r14,	r9	;

00004c32 <.LBB22>:
  _disable_interrupts();
    4c32:	32 c2       	dint			
    4c34:	03 43       	nop			

00004c36 <.Loc.348.2>:
  asm volatile("nop");
    4c36:	03 43       	nop			

00004c38 <.LBE22>:
  chSysLock();
    4c38:	b0 13 50 45 	calla	#17744		;0x04550

00004c3c <.LVL25>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    4c3c:	0e 49       	mov	r9,	r14	;
    4c3e:	cd 08       	mova	r8,	r13	;
    4c40:	cc 0a       	mova	r10,	r12	;
    4c42:	b0 13 ba 4b 	calla	#19386		;0x04bba

00004c46 <.LVL26>:
    4c46:	ca 0c       	mova	r12,	r10	;

00004c48 <.LVL27>:
  chSysUnlock();
    4c48:	b0 13 70 45 	calla	#17776		;0x04570

00004c4c <.LBB24>:
  asm volatile("nop");
    4c4c:	03 43       	nop			

00004c4e <.Loc.356.2>:
  _enable_interrupts();
    4c4e:	03 43       	nop			
    4c50:	32 d2       	eint			
    4c52:	03 43       	nop			

00004c54 <.LBE24>:
}
    4c54:	cc 0a       	mova	r10,	r12	;
    4c56:	28 16       	popm.a	#3,	r10	;20-bit words
    4c58:	10 01       	reta			;

00004c5a <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    4c5a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004c5c <.LCFI10>:
    4c5c:	08 14       	pushm.a	#1,	r8	;20-bit words

00004c5e <.LCFI11>:
    4c5e:	ca 0c       	mova	r12,	r10	;
    4c60:	c8 0d       	mova	r13,	r8	;

00004c62 <.Loc.219.1>:

  chDbgCheckClassI();
    4c62:	b0 13 24 46 	calla	#17956		;0x04624

00004c66 <.LVL30>:
  chDbgCheck(mbp != NULL);
    4c66:	9a 00 00 00 	cmpa	#0,	r10	;
    4c6a:	21 24       	jz	$+68     	;abs 0x4cae

00004c6c <.L15>:

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    4c6c:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    4c70:	4d 43       	clr.b	r13		;
    4c72:	0d 9c       	cmp	r12,	r13	;
    4c74:	22 34       	jge	$+70     	;abs 0x4cba

00004c76 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    4c76:	ba 53 12 00 	add	#-1,	18(r10)	;r3 As==11, 0x0012

00004c7a <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    4c7a:	3c 0a 08 00 	mova	8(r10),	r12	;
    4c7e:	cd 0c       	mova	r12,	r13	;
    4c80:	ad 00 04 00 	adda	#4,	r13	;
    4c84:	7a 0d 08 00 	mova	r13,	8(r10)	;
    4c88:	7c 08 00 00 	mova	r8,	0(r12)	;

00004c8c <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    4c8c:	00 18 da 9a 	cmpx.a	4(r10),	8(r10)	;
    4c90:	04 00 08 00 
    4c94:	03 28       	jnc	$+8      	;abs 0x4c9c

00004c96 <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4c96:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    4c9a:	08 00 

00004c9c <.L17>:
  }
  chSemSignalI(&mbp->fullsem);
    4c9c:	cc 0a       	mova	r10,	r12	;
    4c9e:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4ca2:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00004ca6 <.LVL31>:

  return MSG_OK;
    4ca6:	4c 43       	clr.b	r12		;

00004ca8 <.L14>:
}
    4ca8:	08 16       	popm.a	#1,	r8	;20-bit words
    4caa:	0a 16       	popm.a	#1,	r10	;20-bit words
    4cac:	10 01       	reta			;

00004cae <.L19>:
  chDbgCheck(mbp != NULL);
    4cae:	8c 01 c2 00 	mova	#65730,	r12	;0x100c2
    4cb2:	b0 13 a0 47 	calla	#18336		;0x047a0

00004cb6 <.LVL32>:
    4cb6:	80 00 6c 4c 	mova	#19564,	r0	;0x04c6c

00004cba <.L18>:
    return MSG_TIMEOUT;
    4cba:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    4cbe:	80 00 a8 4c 	mova	#19624,	r0	;0x04ca8

00004cc2 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4cc2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004cc4 <.LCFI18>:
    4cc4:	08 14       	pushm.a	#1,	r8	;20-bit words

00004cc6 <.LCFI19>:
    4cc6:	06 14       	pushm.a	#1,	r6	;20-bit words

00004cc8 <.LCFI20>:
    4cc8:	ca 0c       	mova	r12,	r10	;
    4cca:	c6 0d       	mova	r13,	r6	;
    4ccc:	08 4e       	mov	r14,	r8	;

00004cce <.Loc.386.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4cce:	b0 13 40 46 	calla	#17984		;0x04640

00004cd2 <.LVL51>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4cd2:	9a 00 00 00 	cmpa	#0,	r10	;
    4cd6:	2b 24       	jz	$+88     	;abs 0x4d2e

00004cd8 <.Loc.387.1>:
    4cd8:	96 00 00 00 	cmpa	#0,	r6	;
    4cdc:	28 24       	jz	$+82     	;abs 0x4d2e

00004cde <.L34>:

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4cde:	0d 48       	mov	r8,	r13	;
    4ce0:	cc 0a       	mova	r10,	r12	;
    4ce2:	ac 00 10 00 	adda	#16,	r12	;0x00010
    4ce6:	b0 13 f6 49 	calla	#18934		;0x049f6

00004cea <.LVL52>:
    4cea:	c8 0c       	mova	r12,	r8	;

00004cec <.LVL53>:
  if (rdymsg == MSG_OK) {
    4cec:	9c 00 00 00 	cmpa	#0,	r12	;
    4cf0:	19 20       	jnz	$+52     	;abs 0x4d24

00004cf2 <.Loc.391.1>:
    *msgp = *mbp->rdptr++;
    4cf2:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4cf6:	cd 0c       	mova	r12,	r13	;
    4cf8:	ad 00 04 00 	adda	#4,	r13	;
    4cfc:	7a 0d 0c 00 	mova	r13,	12(r10)	; 0x0000c
    4d00:	00 18 e6 4c 	movx.a	@r12,	0(r6)	;
    4d04:	00 00 

00004d06 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4d06:	00 18 da 9a 	cmpx.a	4(r10),	12(r10)	; 0x0000c
    4d0a:	04 00 0c 00 
    4d0e:	03 28       	jnc	$+8      	;abs 0x4d16

00004d10 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4d10:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    4d14:	0c 00 

00004d16 <.L36>:
    }
    chSemSignalI(&mbp->emptysem);
    4d16:	cc 0a       	mova	r10,	r12	;
    4d18:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4d1c:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00004d20 <.LVL54>:
    chSchRescheduleS();
    4d20:	b0 13 30 49 	calla	#18736		;0x04930

00004d24 <.L32>:
  }

  return rdymsg;
}
    4d24:	cc 08       	mova	r8,	r12	;
    4d26:	06 16       	popm.a	#1,	r6	;20-bit words
    4d28:	08 16       	popm.a	#1,	r8	;20-bit words
    4d2a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4d2c:	10 01       	reta			;

00004d2e <.L33>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    4d2e:	8c 01 99 00 	mova	#65689,	r12	;0x10099
    4d32:	b0 13 a0 47 	calla	#18336		;0x047a0

00004d36 <.LVL57>:
    4d36:	80 00 de 4c 	mova	#19678,	r0	;0x04cde

00004d3a <chMBFetch>:
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4d3a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004d3c <.LCFI21>:
    4d3c:	ca 0c       	mova	r12,	r10	;
    4d3e:	c8 0d       	mova	r13,	r8	;
    4d40:	09 4e       	mov	r14,	r9	;

00004d42 <.LBB30>:
  _disable_interrupts();
    4d42:	32 c2       	dint			
    4d44:	03 43       	nop			

00004d46 <.Loc.348.2>:
  asm volatile("nop");
    4d46:	03 43       	nop			

00004d48 <.LBE30>:
  chSysLock();
    4d48:	b0 13 50 45 	calla	#17744		;0x04550

00004d4c <.LVL59>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4d4c:	0e 49       	mov	r9,	r14	;
    4d4e:	cd 08       	mova	r8,	r13	;
    4d50:	cc 0a       	mova	r10,	r12	;
    4d52:	b0 13 c2 4c 	calla	#19650		;0x04cc2

00004d56 <.LVL60>:
    4d56:	ca 0c       	mova	r12,	r10	;

00004d58 <.LVL61>:
  chSysUnlock();
    4d58:	b0 13 70 45 	calla	#17776		;0x04570

00004d5c <.LBB32>:
  asm volatile("nop");
    4d5c:	03 43       	nop			

00004d5e <.Loc.356.2>:
  _enable_interrupts();
    4d5e:	03 43       	nop			
    4d60:	32 d2       	eint			
    4d62:	03 43       	nop			

00004d64 <.LBE32>:
}
    4d64:	cc 0a       	mova	r10,	r12	;
    4d66:	28 16       	popm.a	#3,	r10	;20-bit words
    4d68:	10 01       	reta			;

00004d6a <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    4d6a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d6c <.LCFI0>:
    4d6c:	08 14       	pushm.a	#1,	r8	;20-bit words

00004d6e <.LCFI1>:
    4d6e:	ca 0c       	mova	r12,	r10	;
    4d70:	08 4d       	mov	r13,	r8	;

00004d72 <.Loc.111.1>:
  uint8_t *p;

  chDbgCheckClassI();
    4d72:	b0 13 24 46 	calla	#17956		;0x04624

00004d76 <.LVL1>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    4d76:	08 93       	cmp	#0,	r8	;r3 As==00
    4d78:	08 24       	jz	$+18     	;abs 0x4d8a

00004d7a <.Loc.112.1>:
    4d7a:	40 18 0c 48 	movx.w	r8,	r12	;
    4d7e:	ce 0c       	mova	r12,	r14	;
    4d80:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    4d84:	00 18 4c be 	bitx.a	r14,	r12	;
    4d88:	04 24       	jz	$+10     	;abs 0x4d92

00004d8a <.L3>:
    4d8a:	8c 01 f0 00 	mova	#65776,	r12	;0x100f0
    4d8e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004d92 <.L4>:

  size = MEM_ALIGN_NEXT(size, align);
    4d92:	40 18 0e 48 	movx.w	r8,	r14	;
    4d96:	ea 0e       	adda	r14,	r10	;

00004d98 <.LVL3>:
    4d98:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff
    4d9c:	00 18 48 43 	clrx.a	r8		;
    4da0:	f8 0e       	suba	r14,	r8	;

00004da2 <.LVL4>:
    4da2:	00 18 4a f8 	andx.a	r8,	r10	;

00004da6 <.LVL5>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    4da6:	00 18 5e 52 	addx.a	&0x0d356,r14	;
    4daa:	56 d3 

00004dac <.LVL6>:
    4dac:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    4db0:	00 18 48 fe 	andx.a	r14,	r8	;

00004db4 <.Loc.117.1>:

  if (((size_t)endmem - (size_t)p) < size) {
    4db4:	2e 00 52 d3 	mova	&54098,	r14	;0x0d352
    4db8:	fe 08       	suba	r8,	r14	;
    4dba:	de 0a       	cmpa	r10,	r14	;
    4dbc:	07 28       	jnc	$+16     	;abs 0x4dcc

00004dbe <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    4dbe:	ea 08       	adda	r8,	r10	;

00004dc0 <.LVL8>:
    4dc0:	60 0a 56 d3 	mova	r10,	&54102	; 0x0d356

00004dc4 <.Loc.122.1>:

  return p;
    4dc4:	cc 08       	mova	r8,	r12	;

00004dc6 <.L2>:
}
    4dc6:	08 16       	popm.a	#1,	r8	;20-bit words
    4dc8:	0a 16       	popm.a	#1,	r10	;20-bit words
    4dca:	10 01       	reta			;

00004dcc <.L6>:
    return NULL;
    4dcc:	4c 43       	clr.b	r12		;
    4dce:	80 00 c6 4d 	mova	#19910,	r0	;0x04dc6

00004dd2 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    4dd2:	1a 14       	pushm.a	#2,	r10	;20-bit words

00004dd4 <.LCFI2>:
    4dd4:	ca 0c       	mova	r12,	r10	;
    4dd6:	09 4d       	mov	r13,	r9	;

00004dd8 <.LBB6>:
  _disable_interrupts();
    4dd8:	32 c2       	dint			
    4dda:	03 43       	nop			

00004ddc <.Loc.348.2>:
  asm volatile("nop");
    4ddc:	03 43       	nop			

00004dde <.LBE6>:
  void *p;

  chSysLock();
    4dde:	b0 13 50 45 	calla	#17744		;0x04550

00004de2 <.LVL11>:
  p = chCoreAllocAlignedI(size, align);
    4de2:	0d 49       	mov	r9,	r13	;
    4de4:	cc 0a       	mova	r10,	r12	;
    4de6:	b0 13 6a 4d 	calla	#19818		;0x04d6a

00004dea <.LVL12>:
    4dea:	ca 0c       	mova	r12,	r10	;

00004dec <.LVL13>:
  chSysUnlock();
    4dec:	b0 13 70 45 	calla	#17776		;0x04570

00004df0 <.LBB8>:
  asm volatile("nop");
    4df0:	03 43       	nop			

00004df2 <.Loc.356.2>:
  _enable_interrupts();
    4df2:	03 43       	nop			
    4df4:	32 d2       	eint			
    4df6:	03 43       	nop			

00004df8 <.LBE8>:

  return p;
}
    4df8:	cc 0a       	mova	r10,	r12	;
    4dfa:	19 16       	popm.a	#2,	r10	;20-bit words
    4dfc:	10 01       	reta			;

00004dfe <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    4dfe:	8c 00 5a d3 	mova	#54106,	r12	;0x0d35a
    4e02:	00 18 fc 40 	movx.a	#19922,	0(r12)	;0x04dd2
    4e06:	d2 4d 00 00 

00004e0a <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    4e0a:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    4e0e:	04 00 

00004e10 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    4e10:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    4e14:	fc f0 f0 ff 	and.b	#-16,	10(r12)	;#0xfff0, 0x000a
    4e18:	0a 00 

00004e1a <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    4e1a:	9c 43 0c 00 	mov	#1,	12(r12)	;r3 As==01, 0x000c

00004e1e <.Loc.117.1>:
#endif
}
    4e1e:	10 01       	reta			;

00004e20 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    4e20:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e22 <.LCFI0>:
    4e22:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e24 <.LCFI1>:
    4e24:	b1 00 04 00 	suba	#4,	r1	;

00004e28 <.LCFI2>:
    4e28:	ca 0c       	mova	r12,	r10	;
    4e2a:	71 0d 00 00 	mova	r13,	0(r1)	;
    4e2e:	c8 0e       	mova	r14,	r8	;

00004e30 <.Loc.78.1>:

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    4e30:	9c 00 00 00 	cmpa	#0,	r12	;
    4e34:	04 24       	jz	$+10     	;abs 0x4e3e

00004e36 <.Loc.78.1>:
    4e36:	7c 40 03 00 	mov.b	#3,	r12	;

00004e3a <.LVL1>:
    4e3a:	dc 0d       	cmpa	r13,	r12	;
    4e3c:	04 28       	jnc	$+10     	;abs 0x4e46

00004e3e <.L2>:
    4e3e:	8c 01 44 01 	mova	#65860,	r12	;0x10144
    4e42:	b0 13 a0 47 	calla	#18336		;0x047a0

00004e46 <.L3>:

  mp->next = NULL;
    4e46:	00 18 ca 43 	movx.a	#0,	0(r10)	;r3 As==00
    4e4a:	00 00 

00004e4c <.Loc.81.1>:
  mp->object_size = size;
    4e4c:	aa 41 04 00 	mov	@r1,	4(r10)	;
    4e50:	0d 01       	mova	@r1,	r13	;
    4e52:	0d 14       	pushm.a	#1,	r13	;20-bit words
    4e54:	0c 17       	popm	#1,	r12	;16-bit words
    4e56:	0c 17       	popm	#1,	r12	;16-bit words
    4e58:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4e5c:	5d 4a 06 00 	mov.b	6(r10),	r13	;
    4e60:	7d f0 f0 ff 	and.b	#-16,	r13	;#0xfff0
    4e64:	4d dc       	bis.b	r12,	r13	;
    4e66:	ca 4d 06 00 	mov.b	r13,	6(r10)	;

00004e6a <.Loc.82.1>:
  mp->provider = provider;
    4e6a:	7a 08 08 00 	mova	r8,	8(r10)	;

00004e6e <.Loc.83.1>:
}
    4e6e:	a1 00 04 00 	adda	#4,	r1	;

00004e72 <.LVL3>:
    4e72:	08 16       	popm.a	#1,	r8	;20-bit words
    4e74:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e76:	10 01       	reta			;

00004e78 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4e78:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e7a <.LCFI3>:
    4e7a:	ca 0c       	mova	r12,	r10	;

00004e7c <.Loc.124.1>:
  void *objp;

  chDbgCheckClassI();
    4e7c:	b0 13 24 46 	calla	#17956		;0x04624

00004e80 <.LVL5>:
  chDbgCheck(mp != NULL);
    4e80:	9a 00 00 00 	cmpa	#0,	r10	;
    4e84:	09 24       	jz	$+20     	;abs 0x4e98

00004e86 <.L5>:

  objp = mp->next;
    4e86:	0c 0a       	mova	@r10,	r12	;

00004e88 <.LVL6>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4e88:	9c 00 00 00 	cmpa	#0,	r12	;
    4e8c:	0b 24       	jz	$+24     	;abs 0x4ea4

00004e8e <.Loc.130.1>:
    mp->next = mp->next->next;
    4e8e:	00 18 ea 4c 	movx.a	@r12,	0(r10)	;
    4e92:	00 00 

00004e94 <.L4>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4e94:	0a 16       	popm.a	#1,	r10	;20-bit words
    4e96:	10 01       	reta			;

00004e98 <.L8>:
  chDbgCheck(mp != NULL);
    4e98:	8c 01 27 01 	mova	#65831,	r12	;0x10127
    4e9c:	b0 13 a0 47 	calla	#18336		;0x047a0

00004ea0 <.LVL8>:
    4ea0:	80 00 86 4e 	mova	#20102,	r0	;0x04e86

00004ea4 <.L6>:
  else if (mp->provider != NULL) {
    4ea4:	3e 0a 08 00 	mova	8(r10),	r14	;
    4ea8:	9e 00 00 00 	cmpa	#0,	r14	;
    4eac:	f3 27       	jz	$-24     	;abs 0x4e94

00004eae <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4eae:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4eb0:	3c 0a 04 00 	mova	4(r10),	r12	;

00004eb4 <.LVL10>:
    4eb4:	4e 13       	calla	r14		;

00004eb6 <.LVL11>:
  return objp;
    4eb6:	80 00 94 4e 	mova	#20116,	r0	;0x04e94

00004eba <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
    4eba:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ebc <.LCFI4>:
    4ebc:	ca 0c       	mova	r12,	r10	;

00004ebe <.LBB22>:
  _disable_interrupts();
    4ebe:	32 c2       	dint			
    4ec0:	03 43       	nop			

00004ec2 <.Loc.348.2>:
  asm volatile("nop");
    4ec2:	03 43       	nop			

00004ec4 <.LBE22>:
  void *objp;

  chSysLock();
    4ec4:	b0 13 50 45 	calla	#17744		;0x04550

00004ec8 <.LVL13>:
  objp = chPoolAllocI(mp);
    4ec8:	cc 0a       	mova	r10,	r12	;
    4eca:	b0 13 78 4e 	calla	#20088		;0x04e78

00004ece <.LVL14>:
    4ece:	ca 0c       	mova	r12,	r10	;

00004ed0 <.LVL15>:
  chSysUnlock();
    4ed0:	b0 13 70 45 	calla	#17776		;0x04570

00004ed4 <.LBB24>:
  asm volatile("nop");
    4ed4:	03 43       	nop			

00004ed6 <.Loc.356.2>:
  _enable_interrupts();
    4ed6:	03 43       	nop			
    4ed8:	32 d2       	eint			
    4eda:	03 43       	nop			

00004edc <.LBE24>:

  return objp;
}
    4edc:	cc 0a       	mova	r10,	r12	;
    4ede:	0a 16       	popm.a	#1,	r10	;20-bit words
    4ee0:	10 01       	reta			;

00004ee2 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4ee2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004ee4 <.LCFI5>:
    4ee4:	08 14       	pushm.a	#1,	r8	;20-bit words

00004ee6 <.LCFI6>:
    4ee6:	ca 0c       	mova	r12,	r10	;
    4ee8:	c8 0d       	mova	r13,	r8	;

00004eea <.LVL18>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
    4eea:	b0 13 24 46 	calla	#17956		;0x04624

00004eee <.LVL19>:
  chDbgCheck((mp != NULL) && (objp != NULL));
    4eee:	9a 00 00 00 	cmpa	#0,	r10	;
    4ef2:	0b 24       	jz	$+24     	;abs 0x4f0a

00004ef4 <.Loc.176.1>:
    4ef4:	98 00 00 00 	cmpa	#0,	r8	;
    4ef8:	08 24       	jz	$+18     	;abs 0x4f0a

00004efa <.L12>:

  php->next = mp->next;
    4efa:	00 18 e8 4a 	movx.a	@r10,	0(r8)	;
    4efe:	00 00 

00004f00 <.Loc.179.1>:
  mp->next = php;
    4f00:	7a 08 00 00 	mova	r8,	0(r10)	;

00004f04 <.Loc.180.1>:
}
    4f04:	08 16       	popm.a	#1,	r8	;20-bit words
    4f06:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f08:	10 01       	reta			;

00004f0a <.L11>:
  chDbgCheck((mp != NULL) && (objp != NULL));
    4f0a:	8c 01 1b 01 	mova	#65819,	r12	;0x1011b
    4f0e:	b0 13 a0 47 	calla	#18336		;0x047a0

00004f12 <.LVL20>:
    4f12:	80 00 fa 4e 	mova	#20218,	r0	;0x04efa

00004f16 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    4f16:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f18 <.LCFI7>:
    4f18:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f1a <.LCFI8>:
    4f1a:	ca 0c       	mova	r12,	r10	;
    4f1c:	c8 0d       	mova	r13,	r8	;

00004f1e <.LBB26>:
  _disable_interrupts();
    4f1e:	32 c2       	dint			
    4f20:	03 43       	nop			

00004f22 <.Loc.348.2>:
  asm volatile("nop");
    4f22:	03 43       	nop			

00004f24 <.LBE26>:

  chSysLock();
    4f24:	b0 13 50 45 	calla	#17744		;0x04550

00004f28 <.LVL22>:
  chPoolFreeI(mp, objp);
    4f28:	cd 08       	mova	r8,	r13	;
    4f2a:	cc 0a       	mova	r10,	r12	;
    4f2c:	b0 13 e2 4e 	calla	#20194		;0x04ee2

00004f30 <.LVL23>:
  chSysUnlock();
    4f30:	b0 13 70 45 	calla	#17776		;0x04570

00004f34 <.LBB28>:
  asm volatile("nop");
    4f34:	03 43       	nop			

00004f36 <.Loc.356.2>:
  _enable_interrupts();
    4f36:	03 43       	nop			
    4f38:	32 d2       	eint			
    4f3a:	03 43       	nop			

00004f3c <.LBE28>:
}
    4f3c:	08 16       	popm.a	#1,	r8	;20-bit words
    4f3e:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f40:	10 01       	reta			;

00004f42 <chGuardedPoolObjectInit>:
 *                      memory pool, the minimum accepted size is the size
 *                      of a pointer to void.
 *
 * @init
 */
void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp, size_t size) {
    4f42:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f44 <.LCFI12>:
    4f44:	ca 0c       	mova	r12,	r10	;

00004f46 <.Loc.214.1>:

  chPoolObjectInit(&gmp->pool, size, NULL);
    4f46:	4e 43       	clr.b	r14		;
    4f48:	ac 00 02 00 	adda	#2,	r12	;

00004f4c <.LVL33>:
    4f4c:	b0 13 20 4e 	calla	#20000		;0x04e20

00004f50 <.LVL34>:
  chSemObjectInit(&gmp->sem, (cnt_t)0);
    4f50:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00

00004f54 <.Loc.216.1>:
}
    4f54:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f56:	10 01       	reta			;

00004f58 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
    4f58:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f5a <.LCFI13>:
    4f5a:	ca 0c       	mova	r12,	r10	;

00004f5c <.Loc.263.1>:
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
    4f5c:	b0 13 f6 49 	calla	#18934		;0x049f6

00004f60 <.LVL36>:
  if (msg != MSG_OK) {
    4f60:	9c 00 00 00 	cmpa	#0,	r12	;
    4f64:	07 20       	jnz	$+16     	;abs 0x4f74

00004f66 <.Loc.268.1>:
    return NULL;
  }

  return chPoolAllocI(&gmp->pool);
    4f66:	cc 0a       	mova	r10,	r12	;

00004f68 <.LVL37>:
    4f68:	ac 00 02 00 	adda	#2,	r12	;
    4f6c:	b0 13 78 4e 	calla	#20088		;0x04e78

00004f70 <.L20>:
}
    4f70:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f72:	10 01       	reta			;

00004f74 <.L22>:
    return NULL;
    4f74:	4c 43       	clr.b	r12		;

00004f76 <.LVL40>:
    4f76:	80 00 70 4f 	mova	#20336,	r0	;0x04f70

00004f7a <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
    4f7a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f7c <.LCFI15>:
    4f7c:	ca 0c       	mova	r12,	r10	;

00004f7e <.Loc.311.1>:

  chPoolFreeI(&gmp->pool, objp);
    4f7e:	ac 00 02 00 	adda	#2,	r12	;

00004f82 <.LVL47>:
    4f82:	b0 13 e2 4e 	calla	#20194		;0x04ee2

00004f86 <.LVL48>:
  chSemSignalI(&gmp->sem);
    4f86:	cc 0a       	mova	r10,	r12	;
    4f88:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00004f8c <.LVL49>:
}
    4f8c:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f8e:	10 01       	reta			;

00004f90 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
    4f90:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004f92 <.LCFI16>:
    4f92:	08 14       	pushm.a	#1,	r8	;20-bit words

00004f94 <.LCFI17>:
    4f94:	ca 0c       	mova	r12,	r10	;
    4f96:	c8 0d       	mova	r13,	r8	;

00004f98 <.LBB36>:
  _disable_interrupts();
    4f98:	32 c2       	dint			
    4f9a:	03 43       	nop			

00004f9c <.Loc.348.2>:
  asm volatile("nop");
    4f9c:	03 43       	nop			

00004f9e <.LBE36>:

  chSysLock();
    4f9e:	b0 13 50 45 	calla	#17744		;0x04550

00004fa2 <.LVL51>:
  chGuardedPoolFreeI(gmp, objp);
    4fa2:	cd 08       	mova	r8,	r13	;
    4fa4:	cc 0a       	mova	r10,	r12	;
    4fa6:	b0 13 7a 4f 	calla	#20346		;0x04f7a

00004faa <.LVL52>:
  chSchRescheduleS();
    4faa:	b0 13 30 49 	calla	#18736		;0x04930

00004fae <.LVL53>:
  chSysUnlock();
    4fae:	b0 13 70 45 	calla	#17776		;0x04570

00004fb2 <.LBB38>:
  asm volatile("nop");
    4fb2:	03 43       	nop			

00004fb4 <.Loc.356.2>:
  _enable_interrupts();
    4fb4:	03 43       	nop			
    4fb6:	32 d2       	eint			
    4fb8:	03 43       	nop			

00004fba <.LBE38>:
}
    4fba:	08 16       	popm.a	#1,	r8	;20-bit words
    4fbc:	0a 16       	popm.a	#1,	r10	;20-bit words
    4fbe:	10 01       	reta			;

00004fc0 <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
    4fc0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004fc2 <.LCFI18>:
    4fc2:	08 14       	pushm.a	#1,	r8	;20-bit words

00004fc4 <.LCFI19>:
    4fc4:	06 14       	pushm.a	#1,	r6	;20-bit words

00004fc6 <.LCFI20>:
    4fc6:	c8 0c       	mova	r12,	r8	;
    4fc8:	c6 0d       	mova	r13,	r6	;
    4fca:	ca 0e       	mova	r14,	r10	;

00004fcc <.Loc.233.1>:
  chDbgCheck((gmp != NULL) && (n != 0U));
    4fcc:	9c 00 00 00 	cmpa	#0,	r12	;
    4fd0:	03 24       	jz	$+8      	;abs 0x4fd8

00004fd2 <.Loc.233.1>:
    4fd2:	9e 00 00 00 	cmpa	#0,	r14	;
    4fd6:	0f 20       	jnz	$+32     	;abs 0x4ff6

00004fd8 <.L27>:
    4fd8:	8c 01 04 01 	mova	#65796,	r12	;0x10104

00004fdc <.LVL56>:
    4fdc:	b0 13 a0 47 	calla	#18336		;0x047a0

00004fe0 <.LVL57>:
    4fe0:	80 00 f6 4f 	mova	#20470,	r0	;0x04ff6

00004fe4 <.L30>:
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
    4fe4:	cd 06       	mova	r6,	r13	;
    4fe6:	cc 08       	mova	r8,	r12	;
    4fe8:	b0 13 90 4f 	calla	#20368		;0x04f90

00004fec <.LBE40>:
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
    4fec:	00 18 56 58 	addx.a	6(r8),	r6	;
    4ff0:	06 00 

00004ff2 <.Loc.240.1>:
    n--;
    4ff2:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

00004ff6 <.L29>:
  while (n != 0U) {
    4ff6:	9a 00 00 00 	cmpa	#0,	r10	;
    4ffa:	f4 23       	jnz	$-22     	;abs 0x4fe4

00004ffc <.Loc.242.1>:
}
    4ffc:	06 16       	popm.a	#1,	r6	;20-bit words
    4ffe:	08 16       	popm.a	#1,	r8	;20-bit words
    5000:	0a 16       	popm.a	#1,	r10	;20-bit words
    5002:	10 01       	reta			;

00005004 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    5004:	6a 14       	pushm.a	#7,	r10	;20-bit words

00005006 <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    5006:	7d 01 00 00 	mova	r1,	0(r13)	;

0000500a <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    500a:	01 0c       	mova	@r12,	r1	;

0000500c <.Loc.76.1>:
  asm volatile ("popm.a #7, R10");
    500c:	64 16       	popm.a	#7,	r10	;20-bit words

0000500e <.Loc.77.1>:
  asm volatile ("reta");
    500e:	10 01       	reta			;

00005010 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    5010:	b0 13 70 45 	calla	#17776		;0x04570

00005014 <.LBB4>:
  asm volatile("nop");
    5014:	03 43       	nop			

00005016 <.Loc.356.2>:
  _enable_interrupts();
    5016:	03 43       	nop			
    5018:	32 d2       	eint			
    501a:	03 43       	nop			

0000501c <.LBE4>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    501c:	cc 05       	mova	r5,	r12	;

0000501e <.Loc.98.1>:
  asm volatile ("calla R4");
    501e:	44 13       	calla	r4		;

00005020 <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    5020:	4c 43       	clr.b	r12		;
    5022:	b0 13 a0 47 	calla	#18336		;0x047a0

00005026 <.LVL2>:
#endif
}
    5026:	10 01       	reta			;

00005028 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    5028:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000502a <.LCFI0>:
    502a:	08 14       	pushm.a	#1,	r8	;20-bit words

0000502c <.LCFI1>:
    502c:	06 14       	pushm.a	#1,	r6	;20-bit words

0000502e <.LCFI2>:
    502e:	04 14       	pushm.a	#1,	r4	;20-bit words

00005030 <.LCFI3>:
    5030:	c8 0c       	mova	r12,	r8	;
    5032:	c4 0d       	mova	r13,	r4	;

00005034 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    5034:	c6 0c       	mova	r12,	r6	;

00005036 <.LVL1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    5036:	2c 4c       	mov	@r12,	r12	;

00005038 <.LVL2>:
    5038:	0c 93       	cmp	#0,	r12	;r3 As==00
    503a:	05 38       	jl	$+12     	;abs 0x5046

0000503c <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    503c:	04 16       	popm.a	#1,	r4	;20-bit words
    503e:	06 16       	popm.a	#1,	r6	;20-bit words
    5040:	08 16       	popm.a	#1,	r8	;20-bit words
    5042:	0a 16       	popm.a	#1,	r10	;20-bit words
    5044:	10 01       	reta			;

00005046 <.L8>:
    5046:	8a 01 30 05 	mova	#66864,	r10	;0x10530

0000504a <.L2>:
      if (tp->u1.semp == sp) {
    504a:	00 18 56 9a 	cmpx.a	6(r10),	r6	;
    504e:	06 00 
    5050:	0b 24       	jz	$+24     	;abs 0x5068

00005052 <.Loc.74.1>:
      tp++;
    5052:	aa 00 14 00 	adda	#20,	r10	;0x00014

00005056 <.Loc.76.1>:
      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
    5056:	9a 01 58 05 	cmpa	#66904,	r10	;0x10558
    505a:	f7 2b       	jnc	$-16     	;abs 0x504a

0000505c <.Loc.76.1>:
    505c:	8c 01 6b 01 	mova	#65899,	r12	;0x1016b
    5060:	b0 13 a0 47 	calla	#18336		;0x047a0

00005064 <.LVL6>:
    5064:	80 00 4a 50 	mova	#20554,	r0	;0x0504a

00005068 <.L9>:
        sp->cnt++;
    5068:	98 53 00 00 	inc	0(r8)		;

0000506c <.Loc.69.1>:
        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");
    506c:	fa 90 03 00 	cmp.b	#3,	4(r10)	;
    5070:	04 00 
    5072:	04 24       	jz	$+10     	;abs 0x507c

00005074 <.Loc.69.1>:
    5074:	8c 01 6b 01 	mova	#65899,	r12	;0x1016b
    5078:	b0 13 a0 47 	calla	#18336		;0x047a0

0000507c <.L5>:
        (void) chSchReadyI(tp, msg);
    507c:	cd 04       	mova	r4,	r13	;
    507e:	cc 0a       	mova	r10,	r12	;
    5080:	b0 13 7c 48 	calla	#18556		;0x0487c

00005084 <.LVL8>:
        return;
    5084:	80 00 3c 50 	mova	#20540,	r0	;0x0503c

00005088 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    5088:	b0 13 3e 53 	calla	#21310		;0x0533e

0000508c <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    508c:	8c 01 fe 02 	mova	#66302,	r12	;0x102fe
    5090:	b0 13 ae 53 	calla	#21422		;0x053ae

00005094 <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    5094:	b0 13 b0 50 	calla	#20656		;0x050b0

00005098 <.LVL2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    5098:	b0 13 b0 51 	calla	#20912		;0x051b0

0000509c <.LVL3>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    509c:	b0 13 b6 51 	calla	#20918		;0x051b6

000050a0 <.LVL4>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    50a0:	b0 13 4c 5e 	calla	#24140		;0x05e4c

000050a4 <.LVL5>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    50a4:	b0 13 aa 50 	calla	#20650		;0x050aa

000050a8 <.LVL6>:
#endif
}
    50a8:	10 01       	reta			;

000050aa <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    50aa:	b0 13 8e 53 	calla	#21390		;0x0538e

000050ae <.LVL0>:
}
    50ae:	10 01       	reta			;

000050b0 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    50b0:	b0 13 28 5d 	calla	#23848		;0x05d28

000050b4 <.LVL0>:
}
    50b4:	10 01       	reta			;

000050b6 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    50b6:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000050ba <.Loc.71.1>:
  gptp->config = NULL;
    50ba:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    50be:	02 00 

000050c0 <.Loc.72.1>:
}
    50c0:	10 01       	reta			;

000050c2 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    50c2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000050c4 <.LCFI0>:
    50c4:	08 14       	pushm.a	#1,	r8	;20-bit words

000050c6 <.LCFI1>:
    50c6:	ca 0c       	mova	r12,	r10	;
    50c8:	c8 0d       	mova	r13,	r8	;

000050ca <.Loc.84.1>:

  osalDbgCheck((gptp != NULL) && (config != NULL));
    50ca:	9c 00 00 00 	cmpa	#0,	r12	;
    50ce:	21 24       	jz	$+68     	;abs 0x5112

000050d0 <.Loc.84.1>:
    50d0:	9d 00 00 00 	cmpa	#0,	r13	;
    50d4:	1e 24       	jz	$+62     	;abs 0x5112

000050d6 <.L5>:
  _disable_interrupts();
    50d6:	32 c2       	dint			
    50d8:	03 43       	nop			

000050da <.Loc.348.2>:
  asm volatile("nop");
    50da:	03 43       	nop			

000050dc <.LBE56>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    50dc:	b0 13 50 45 	calla	#17744		;0x04550

000050e0 <.LBE54>:

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
    50e0:	6c 4a       	mov.b	@r10,	r12	;
    50e2:	7c 53       	add.b	#-1,	r12	;r3 As==11
    50e4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    50e6:	4d 9c       	cmp.b	r12,	r13	;
    50e8:	04 2c       	jc	$+10     	;abs 0x50f2

000050ea <.Loc.87.1>:
    50ea:	8c 01 de 01 	mova	#66014,	r12	;0x101de
    50ee:	b0 13 a0 47 	calla	#18336		;0x047a0

000050f2 <.L6>:
              "invalid state");
  gptp->config = config;
    50f2:	7a 08 02 00 	mova	r8,	2(r10)	;

000050f6 <.Loc.90.1>:
  gpt_lld_start(gptp);
    50f6:	cc 0a       	mova	r10,	r12	;
    50f8:	b0 13 3a 5d 	calla	#23866		;0x05d3a

000050fc <.LVL6>:
  gptp->state = GPT_READY;
    50fc:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005100 <.LBB58>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    5100:	b0 13 70 45 	calla	#17776		;0x04570

00005104 <.LBB60>:
  asm volatile("nop");
    5104:	03 43       	nop			

00005106 <.Loc.356.2>:
  _enable_interrupts();
    5106:	03 43       	nop			
    5108:	32 d2       	eint			
    510a:	03 43       	nop			

0000510c <.LBE58>:
  osalSysUnlock();
}
    510c:	08 16       	popm.a	#1,	r8	;20-bit words
    510e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5110:	10 01       	reta			;

00005112 <.L4>:
  osalDbgCheck((gptp != NULL) && (config != NULL));
    5112:	8c 01 de 01 	mova	#66014,	r12	;0x101de
    5116:	b0 13 a0 47 	calla	#18336		;0x047a0

0000511a <.LVL8>:
    511a:	80 00 d6 50 	mova	#20694,	r0	;0x050d6

0000511e <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    511e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005120 <.LCFI6>:
    5120:	ca 0c       	mova	r12,	r10	;
    5122:	09 4d       	mov	r13,	r9	;

00005124 <.Loc.199.1>:

  osalDbgCheckClassI();
    5124:	b0 13 24 46 	calla	#17956		;0x04624

00005128 <.LVL33>:
  osalDbgCheck(gptp != NULL);
    5128:	9a 00 00 00 	cmpa	#0,	r10	;
    512c:	15 24       	jz	$+44     	;abs 0x5158

0000512e <.L21>:
  osalDbgCheck(gptp->config->callback != NULL);
    512e:	3c 0a 02 00 	mova	2(r10),	r12	;
    5132:	00 18 cc 93 	cmpx.a	#0,	4(r12)	;r3 As==00
    5136:	04 00 
    5138:	15 24       	jz	$+44     	;abs 0x5164

0000513a <.L22>:
  osalDbgAssert(gptp->state == GPT_READY,
    513a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    513e:	04 24       	jz	$+10     	;abs 0x5148

00005140 <.Loc.202.1>:
    5140:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f
    5144:	b0 13 a0 47 	calla	#18336		;0x047a0

00005148 <.L23>:
                "invalid state");

  gptp->state = GPT_ONESHOT;
    5148:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

0000514c <.Loc.206.1>:
  gpt_lld_start_timer(gptp, interval);
    514c:	0d 49       	mov	r9,	r13	;
    514e:	cc 0a       	mova	r10,	r12	;
    5150:	b0 13 10 5e 	calla	#24080		;0x05e10

00005154 <.LVL35>:
}
    5154:	19 16       	popm.a	#2,	r10	;20-bit words
    5156:	10 01       	reta			;

00005158 <.L24>:
  osalDbgCheck(gptp != NULL);
    5158:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f
    515c:	b0 13 a0 47 	calla	#18336		;0x047a0

00005160 <.LVL36>:
    5160:	80 00 2e 51 	mova	#20782,	r0	;0x0512e

00005164 <.L25>:
  osalDbgCheck(gptp->config->callback != NULL);
    5164:	8c 01 9f 01 	mova	#65951,	r12	;0x1019f
    5168:	b0 13 a0 47 	calla	#18336		;0x047a0

0000516c <.LVL37>:
    516c:	80 00 3a 51 	mova	#20794,	r0	;0x0513a

00005170 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    5170:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005172 <.LCFI8>:
    5172:	ca 0c       	mova	r12,	r10	;

00005174 <.Loc.232.1>:

  osalDbgCheckClassI();
    5174:	b0 13 24 46 	calla	#17956		;0x04624

00005178 <.LVL43>:
  osalDbgCheck(gptp != NULL);
    5178:	9a 00 00 00 	cmpa	#0,	r10	;
    517c:	0d 24       	jz	$+28     	;abs 0x5198

0000517e <.L28>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    517e:	6c 4a       	mov.b	@r10,	r12	;
    5180:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    5184:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5186:	4d 9c       	cmp.b	r12,	r13	;
    5188:	0d 28       	jnc	$+28     	;abs 0x51a4

0000518a <.L29>:
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    518a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000518e <.Loc.239.1>:
  gpt_lld_stop_timer(gptp);
    518e:	cc 0a       	mova	r10,	r12	;
    5190:	b0 13 40 5e 	calla	#24128		;0x05e40

00005194 <.LVL44>:
}
    5194:	0a 16       	popm.a	#1,	r10	;20-bit words
    5196:	10 01       	reta			;

00005198 <.L30>:
  osalDbgCheck(gptp != NULL);
    5198:	8c 01 91 01 	mova	#65937,	r12	;0x10191
    519c:	b0 13 a0 47 	calla	#18336		;0x047a0

000051a0 <.LVL45>:
    51a0:	80 00 7e 51 	mova	#20862,	r0	;0x0517e

000051a4 <.L31>:
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
    51a4:	8c 01 91 01 	mova	#65937,	r12	;0x10191
    51a8:	b0 13 a0 47 	calla	#18336		;0x047a0

000051ac <.LVL46>:
    51ac:	80 00 8a 51 	mova	#20874,	r0	;0x0518a

000051b0 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    51b0:	b0 13 6a 56 	calla	#22122		;0x0566a

000051b4 <.LVL0>:
}
    51b4:	10 01       	reta			;

000051b6 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    51b6:	b0 13 78 5a 	calla	#23160		;0x05a78

000051ba <.LVL0>:
}
    51ba:	10 01       	reta			;

000051bc <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    51bc:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000051c0 <.Loc.71.1>:
  uartp->txstate    = UART_TX_IDLE;
    51c0:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

000051c4 <.Loc.72.1>:
  uartp->rxstate    = UART_RX_IDLE;
    51c4:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000051c8 <.Loc.73.1>:
  uartp->config     = NULL;
    51c8:	00 18 cc 43 	movx.a	#0,	4(r12)	;r3 As==00
    51cc:	04 00 

000051ce <.Loc.75.1>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    51ce:	cc 43 08 00 	mov.b	#0,	8(r12)	;r3 As==00

000051d2 <.Loc.76.1>:
  uartp->threadrx   = NULL;
    51d2:	00 18 cc 43 	movx.a	#0,	10(r12)	;r3 As==00, 0x0000a
    51d6:	0a 00 

000051d8 <.Loc.77.1>:
  uartp->threadtx   = NULL;
    51d8:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    51dc:	0e 00 

000051de <.Loc.87.1>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    51de:	10 01       	reta			;

000051e0 <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    51e0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000051e2 <.LCFI0>:
    51e2:	08 14       	pushm.a	#1,	r8	;20-bit words

000051e4 <.LCFI1>:
    51e4:	ca 0c       	mova	r12,	r10	;
    51e6:	c8 0d       	mova	r13,	r8	;

000051e8 <.Loc.99.1>:

  osalDbgCheck((uartp != NULL) && (config != NULL));
    51e8:	9c 00 00 00 	cmpa	#0,	r12	;
    51ec:	21 24       	jz	$+68     	;abs 0x5230

000051ee <.Loc.99.1>:
    51ee:	9d 00 00 00 	cmpa	#0,	r13	;
    51f2:	1e 24       	jz	$+62     	;abs 0x5230

000051f4 <.L5>:
  _disable_interrupts();
    51f4:	32 c2       	dint			
    51f6:	03 43       	nop			

000051f8 <.Loc.348.2>:
  asm volatile("nop");
    51f8:	03 43       	nop			

000051fa <.LBE86>:
  chSysLock();
    51fa:	b0 13 50 45 	calla	#17744		;0x04550

000051fe <.LBE84>:

  osalSysLock();
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
    51fe:	6c 4a       	mov.b	@r10,	r12	;
    5200:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5202:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5204:	4d 9c       	cmp.b	r12,	r13	;
    5206:	04 2c       	jc	$+10     	;abs 0x5210

00005208 <.Loc.102.1>:
    5208:	8c 01 a3 02 	mova	#66211,	r12	;0x102a3
    520c:	b0 13 a0 47 	calla	#18336		;0x047a0

00005210 <.L6>:
                "invalid state");

  uartp->config = config;
    5210:	7a 08 04 00 	mova	r8,	4(r10)	;

00005214 <.Loc.106.1>:
  uart_lld_start(uartp);
    5214:	cc 0a       	mova	r10,	r12	;
    5216:	b0 13 d8 5a 	calla	#23256		;0x05ad8

0000521a <.LVL6>:
  uartp->state = UART_READY;
    521a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000521e <.LBB88>:
  chSysUnlock();
    521e:	b0 13 70 45 	calla	#17776		;0x04570

00005222 <.LBB90>:
  asm volatile("nop");
    5222:	03 43       	nop			

00005224 <.Loc.356.2>:
  _enable_interrupts();
    5224:	03 43       	nop			
    5226:	32 d2       	eint			
    5228:	03 43       	nop			

0000522a <.LBE88>:
  osalSysUnlock();
}
    522a:	08 16       	popm.a	#1,	r8	;20-bit words
    522c:	0a 16       	popm.a	#1,	r10	;20-bit words
    522e:	10 01       	reta			;

00005230 <.L4>:
  osalDbgCheck((uartp != NULL) && (config != NULL));
    5230:	8c 01 a3 02 	mova	#66211,	r12	;0x102a3
    5234:	b0 13 a0 47 	calla	#18336		;0x047a0

00005238 <.LVL8>:
    5238:	80 00 f4 51 	mova	#20980,	r0	;0x051f4

0000523c <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    523c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000523e <.LCFI6>:
    523e:	08 14       	pushm.a	#1,	r8	;20-bit words

00005240 <.LCFI7>:
    5240:	06 14       	pushm.a	#1,	r6	;20-bit words

00005242 <.LCFI8>:
    5242:	ca 0c       	mova	r12,	r10	;
    5244:	c8 0d       	mova	r13,	r8	;
    5246:	c6 0e       	mova	r14,	r6	;

00005248 <.Loc.174.1>:

  osalDbgCheckClassI();
    5248:	b0 13 24 46 	calla	#17956		;0x04624

0000524c <.LVL25>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
    524c:	9a 00 00 00 	cmpa	#0,	r10	;
    5250:	06 24       	jz	$+14     	;abs 0x525e

00005252 <.Loc.175.1>:
    5252:	98 00 00 00 	cmpa	#0,	r8	;
    5256:	03 24       	jz	$+8      	;abs 0x525e

00005258 <.Loc.175.1>:
    5258:	96 00 00 00 	cmpa	#0,	r6	;
    525c:	04 20       	jnz	$+10     	;abs 0x5266

0000525e <.L18>:
    525e:	8c 01 7d 02 	mova	#66173,	r12	;0x1027d
    5262:	b0 13 a0 47 	calla	#18336		;0x047a0

00005266 <.L19>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    5266:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    526a:	04 24       	jz	$+10     	;abs 0x5274

0000526c <.Loc.176.1>:
    526c:	8c 01 7d 02 	mova	#66173,	r12	;0x1027d
    5270:	b0 13 a0 47 	calla	#18336		;0x047a0

00005274 <.L20>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    5274:	da 93 01 00 	cmp.b	#1,	1(r10)	;r3 As==01
    5278:	0b 24       	jz	$+24     	;abs 0x5290

0000527a <.L21>:

  uart_lld_start_send(uartp, n, txbuf);
    527a:	ce 06       	mova	r6,	r14	;
    527c:	cd 08       	mova	r8,	r13	;
    527e:	cc 0a       	mova	r10,	r12	;
    5280:	b0 13 50 5c 	calla	#23632		;0x05c50

00005284 <.LVL28>:
  uartp->txstate = UART_TX_ACTIVE;
    5284:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00005288 <.Loc.181.1>:
}
    5288:	06 16       	popm.a	#1,	r6	;20-bit words
    528a:	08 16       	popm.a	#1,	r8	;20-bit words
    528c:	0a 16       	popm.a	#1,	r10	;20-bit words
    528e:	10 01       	reta			;

00005290 <.L22>:
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");
    5290:	8c 01 7d 02 	mova	#66173,	r12	;0x1027d
    5294:	b0 13 a0 47 	calla	#18336		;0x047a0

00005298 <.LVL29>:
    5298:	80 00 7a 52 	mova	#21114,	r0	;0x0527a

0000529c <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    529c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000529e <.LCFI15>:
    529e:	08 14       	pushm.a	#1,	r8	;20-bit words

000052a0 <.LCFI16>:
    52a0:	06 14       	pushm.a	#1,	r6	;20-bit words

000052a2 <.LCFI17>:
    52a2:	ca 0c       	mova	r12,	r10	;
    52a4:	c8 0d       	mova	r13,	r8	;
    52a6:	c6 0e       	mova	r14,	r6	;

000052a8 <.Loc.280.1>:

  osalDbgCheckClassI();
    52a8:	b0 13 24 46 	calla	#17956		;0x04624

000052ac <.LVL54>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
    52ac:	9a 00 00 00 	cmpa	#0,	r10	;
    52b0:	06 24       	jz	$+14     	;abs 0x52be

000052b2 <.Loc.281.1>:
    52b2:	98 00 00 00 	cmpa	#0,	r8	;
    52b6:	03 24       	jz	$+8      	;abs 0x52be

000052b8 <.Loc.281.1>:
    52b8:	96 00 00 00 	cmpa	#0,	r6	;
    52bc:	04 20       	jnz	$+10     	;abs 0x52c6

000052be <.L44>:
    52be:	8c 01 3f 02 	mova	#66111,	r12	;0x1023f
    52c2:	b0 13 a0 47 	calla	#18336		;0x047a0

000052c6 <.L45>:
  osalDbgAssert(uartp->state == UART_READY, "is active");
    52c6:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    52ca:	04 24       	jz	$+10     	;abs 0x52d4

000052cc <.Loc.282.1>:
    52cc:	8c 01 3f 02 	mova	#66111,	r12	;0x1023f
    52d0:	b0 13 a0 47 	calla	#18336		;0x047a0

000052d4 <.L46>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    52d4:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    52d8:	0b 24       	jz	$+24     	;abs 0x52f0

000052da <.L47>:

  uart_lld_start_receive(uartp, n, rxbuf);
    52da:	ce 06       	mova	r6,	r14	;
    52dc:	cd 08       	mova	r8,	r13	;
    52de:	cc 0a       	mova	r10,	r12	;
    52e0:	b0 13 8e 5c 	calla	#23694		;0x05c8e

000052e4 <.LVL57>:
  uartp->rxstate = UART_RX_ACTIVE;
    52e4:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

000052e8 <.Loc.287.1>:
}
    52e8:	06 16       	popm.a	#1,	r6	;20-bit words
    52ea:	08 16       	popm.a	#1,	r8	;20-bit words
    52ec:	0a 16       	popm.a	#1,	r10	;20-bit words
    52ee:	10 01       	reta			;

000052f0 <.L48>:
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");
    52f0:	8c 01 3f 02 	mova	#66111,	r12	;0x1023f
    52f4:	b0 13 a0 47 	calla	#18336		;0x047a0

000052f8 <.LVL58>:
    52f8:	80 00 da 52 	mova	#21210,	r0	;0x052da

000052fc <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    52fc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052fe <.LCFI20>:
    52fe:	ca 0c       	mova	r12,	r10	;

00005300 <.Loc.336.1>:

  osalDbgCheckClassI();
    5300:	b0 13 24 46 	calla	#17956		;0x04624

00005304 <.LVL70>:
  osalDbgCheck(uartp != NULL);
    5304:	9a 00 00 00 	cmpa	#0,	r10	;
    5308:	0d 24       	jz	$+28     	;abs 0x5324

0000530a <.L57>:
  osalDbgAssert(uartp->state == UART_READY, "not active");
    530a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    530e:	04 24       	jz	$+10     	;abs 0x5318

00005310 <.Loc.338.1>:
    5310:	8c 01 1e 02 	mova	#66078,	r12	;0x1021e
    5314:	b0 13 a0 47 	calla	#18336		;0x047a0

00005318 <.L58>:

  if (uartp->rxstate == UART_RX_ACTIVE) {
    5318:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    531c:	09 24       	jz	$+20     	;abs 0x5330

0000531e <.Loc.345.1>:
    size_t n = uart_lld_stop_receive(uartp);
    uartp->rxstate = UART_RX_IDLE;
    return n;
  }
  return 0;
    531e:	4c 43       	clr.b	r12		;

00005320 <.L56>:
}
    5320:	0a 16       	popm.a	#1,	r10	;20-bit words
    5322:	10 01       	reta			;

00005324 <.L61>:
  osalDbgCheck(uartp != NULL);
    5324:	8c 01 1e 02 	mova	#66078,	r12	;0x1021e
    5328:	b0 13 a0 47 	calla	#18336		;0x047a0

0000532c <.LVL72>:
    532c:	80 00 0a 53 	mova	#21258,	r0	;0x0530a

00005330 <.L62>:
    size_t n = uart_lld_stop_receive(uartp);
    5330:	cc 0a       	mova	r10,	r12	;
    5332:	b0 13 d4 5c 	calla	#23764		;0x05cd4

00005336 <.LVL73>:
    uartp->rxstate = UART_RX_IDLE;
    5336:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

0000533a <.Loc.343.1>:
    return n;
    533a:	80 00 20 53 	mova	#21280,	r0	;0x05320

0000533e <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    533e:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    5342:	80 5a 5c 01 

00005346 <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    5346:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    534a:	10 a5 40 01 

0000534e <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    534e:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    5352:	41 01 

00005354 <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    5354:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    5358:	00 a5 60 01 

0000535c <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    535c:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    5360:	48 00 62 01 

00005364 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    5364:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    5368:	33 01 64 01 

0000536c <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    536c:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    5370:	66 01 

00005372 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    5372:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    5376:	c9 c1 68 01 

0000537a <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    537a:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    537e:	0f 00 6c 01 

00005382 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    5382:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    5386:	61 01 

00005388 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    5388:	b0 13 68 54 	calla	#21608		;0x05468

0000538c <.LVL0>:
#endif
}
    538c:	10 01       	reta			;

0000538e <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    538e:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    5392:	7f 3e d2 03 

00005396 <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    5396:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    539a:	10 00 c2 03 

0000539e <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    539e:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    53a2:	e0 03 

000053a4 <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    53a4:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    53a8:	14 02 c0 03 

000053ac <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    53ac:	10 01       	reta			;

000053ae <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    53ae:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    53b2:	02 02 

000053b4 <.Loc.310.1>:
  PADIR = config->porta.dir;
    53b4:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    53b8:	02 00 04 02 

000053bc <.Loc.311.1>:
  PAREN = config->porta.ren;
    53bc:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    53c0:	04 00 06 02 

000053c4 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    53c4:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    53c8:	06 00 0a 02 

000053cc <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    53cc:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    53d0:	08 00 0c 02 

000053d4 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    53d4:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    53d8:	0a 00 22 02 

000053dc <.Loc.316.1>:
  PBDIR = config->portb.dir;
    53dc:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    53e0:	0c 00 24 02 

000053e4 <.Loc.317.1>:
  PBREN = config->portb.ren;
    53e4:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    53e8:	0e 00 26 02 

000053ec <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    53ec:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    53f0:	10 00 2a 02 

000053f4 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    53f4:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    53f8:	12 00 2c 02 

000053fc <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    53fc:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    5400:	14 00 22 03 

00005404 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    5404:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    5408:	16 00 24 03 

0000540c <.Loc.351.1>:
  PJREN = config->portj.ren;
    540c:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    5410:	18 00 26 03 

00005414 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    5414:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    5418:	1a 00 2a 03 

0000541c <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    541c:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    5420:	1c 00 2c 03 

00005424 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    5424:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    5428:	30 01 

0000542a <.Loc.356.1>:
}
    542a:	10 01       	reta			;

0000542c <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    542c:	3a 14       	pushm.a	#4,	r10	;20-bit words

0000542e <.LCFI0>:
    542e:	49 4c       	mov.b	r12,	r9	;
    5430:	48 4d       	mov.b	r13,	r8	;

00005432 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5432:	0a 49       	mov	r9,	r10	;
    5434:	12 c3       	clrc			
    5436:	0a 10       	rrc	r10		;
    5438:	40 18 0a 4a 	movx.w	r10,	r10	;
    543c:	ea 0a       	adda	r10,	r10	;
    543e:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005442 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5442:	59 f3       	and.b	#1,	r9	;r3 As==01
    5444:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    5448:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

0000544c <.LVL2>:
    544c:	0d 49       	mov	r9,	r13	;

0000544e <.LVL3>:
    544e:	b0 13 62 9f 	calla	#40802		;0x09f62
    5452:	07 4c       	mov	r12,	r7	;
    5454:	27 fa       	and	@r10,	r7	;

00005456 <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    5456:	0c 48       	mov	r8,	r12	;
    5458:	0d 49       	mov	r9,	r13	;
    545a:	b0 13 ce 9e 	calla	#40654		;0x09ece
    545e:	07 dc       	bis	r12,	r7	;
    5460:	8a 47 00 00 	mov	r7,	0(r10)	;

00005464 <.Loc.65.1>:
}
    5464:	37 16       	popm.a	#4,	r10	;20-bit words
    5466:	10 01       	reta			;

00005468 <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    5468:	40 18 82 43 	movx.w	#0,	&0xfd368;r3 As==00
    546c:	68 d3 

0000546e <.LBE23>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    546e:	10 01       	reta			;

00005470 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5470:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005472 <.LCFI2>:
    5472:	c8 0c       	mova	r12,	r8	;

00005474 <.LVL26>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    5474:	4a 43       	clr.b	r10		;

00005476 <.L9>:
    5476:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5478:	0c 9a       	cmp	r10,	r12	;
    547a:	15 38       	jl	$+44     	;abs 0x54a6

0000547c <.Loc.192.1>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    547c:	0d 4a       	mov	r10,	r13	;
    547e:	4d 0e       	rlam.a	#4,	r13	;
    5480:	4d 0d       	rram.a	#4,	r13	;
    5482:	0d 14       	pushm.a	#1,	r13	;20-bit words
    5484:	40 18 3c 41 	popx.w	r12		;
    5488:	40 18 3d 41 	popx.w	r13		;
    548c:	b0 13 00 9f 	calla	#40704		;0x09f00
    5490:	0d 12       	push	r13		;
    5492:	0c 12       	push	r12		;
    5494:	0c 16       	popm.a	#1,	r12	;20-bit words
    5496:	40 18 bc b0 	bitx.w	#16,	1296(r12);0x00010, 0x00510
    549a:	10 00 10 05 
    549e:	03 24       	jz	$+8      	;abs 0x54a6

000054a0 <.Loc.191.1>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    54a0:	1a 53       	inc	r10		;
    54a2:	80 00 76 54 	mova	#21622,	r0	;0x05476

000054a6 <.L10>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    54a6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    54a8:	0d 9a       	cmp	r10,	r13	;
    54aa:	1f 38       	jl	$+64     	;abs 0x54ea

000054ac <.Loc.202.1>:
    return MSG_TIMEOUT;
  }
  
  /* Acquire the channel in an idle mode */
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    54ac:	49 4a       	mov.b	r10,	r9	;
    54ae:	4d 43       	clr.b	r13		;
    54b0:	4c 49       	mov.b	r9,	r12	;
    54b2:	b0 13 2c 54 	calla	#21548		;0x0542c

000054b6 <.LVL30>:
  dma_regs[i].sz  = 0;
    54b6:	4a 0e       	rlam.a	#4,	r10	;
    54b8:	4a 0d       	rram.a	#4,	r10	;

000054ba <.LVL31>:
    54ba:	0a 14       	pushm.a	#1,	r10	;20-bit words
    54bc:	40 18 3c 41 	popx.w	r12		;
    54c0:	40 18 3d 41 	popx.w	r13		;
    54c4:	b0 13 00 9f 	calla	#40704		;0x09f00
    54c8:	0d 12       	push	r13		;
    54ca:	0c 12       	push	r12		;
    54cc:	0c 16       	popm.a	#1,	r12	;20-bit words
    54ce:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    54d2:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000054d6 <.Loc.204.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    54d6:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    54da:	00 00 

000054dc <.Loc.206.1>:

  channel->registers = dma_regs + i;
    54dc:	78 0c 00 00 	mova	r12,	0(r8)	;

000054e0 <.Loc.207.1>:
  channel->index     = i;
    54e0:	c8 49 04 00 	mov.b	r9,	4(r8)	;

000054e4 <.Loc.209.1>:
  
  return MSG_OK;
    54e4:	4c 43       	clr.b	r12		;

000054e6 <.L8>:
}
    54e6:	28 16       	popm.a	#3,	r10	;20-bit words
    54e8:	10 01       	reta			;

000054ea <.L13>:
    return MSG_TIMEOUT;
    54ea:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    54ee:	80 00 e6 54 	mova	#21734,	r0	;0x054e6

000054f2 <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    54f2:	2a 14       	pushm.a	#3,	r10	;20-bit words

000054f4 <.LCFI5>:
    54f4:	c8 0c       	mova	r12,	r8	;
    54f6:	49 4d       	mov.b	r13,	r9	;

000054f8 <.Loc.229.1>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    54f8:	6c 43       	mov.b	#2,	r12	;r3 As==10

000054fa <.LVL43>:
    54fa:	4c 99       	cmp.b	r9,	r12	;
    54fc:	1d 28       	jnc	$+60     	;abs 0x5538

000054fe <.L18>:
  if (dma_regs[index].ctl & DMAEN) {
    54fe:	0c 49       	mov	r9,	r12	;
    5500:	0d 43       	clr	r13		;
    5502:	b0 13 00 9f 	calla	#40704		;0x09f00
    5506:	0d 12       	push	r13		;
    5508:	0c 12       	push	r12		;
    550a:	0a 16       	popm.a	#1,	r10	;20-bit words
    550c:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    5510:	ba b0 10 00 	bit	#16,	0(r10)	;#0x0010
    5514:	00 00 
    5516:	16 20       	jnz	$+46     	;abs 0x5544

00005518 <.Loc.235.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5518:	4d 43       	clr.b	r13		;
    551a:	4c 49       	mov.b	r9,	r12	;
    551c:	b0 13 2c 54 	calla	#21548		;0x0542c

00005520 <.LVL46>:
  dma_regs[index].sz  = 0;
    5520:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

00005524 <.Loc.237.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    5524:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    5528:	00 00 

0000552a <.Loc.239.1>:

  channel->registers = dma_regs + index;
    552a:	78 0a 00 00 	mova	r10,	0(r8)	;

0000552e <.Loc.240.1>:
  channel->index     = index;
    552e:	c8 49 04 00 	mov.b	r9,	4(r8)	;

00005532 <.Loc.242.1>:
  
  return MSG_OK;
    5532:	4c 43       	clr.b	r12		;

00005534 <.L17>:
}
    5534:	28 16       	popm.a	#3,	r10	;20-bit words
    5536:	10 01       	reta			;

00005538 <.L21>:
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
    5538:	8c 01 c4 02 	mova	#66244,	r12	;0x102c4
    553c:	b0 13 a0 47 	calla	#18336		;0x047a0

00005540 <.LVL48>:
    5540:	80 00 fe 54 	mova	#21758,	r0	;0x054fe

00005544 <.L20>:
    return MSG_TIMEOUT;
    5544:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff
    5548:	80 00 34 55 	mova	#21812,	r0	;0x05534

0000554c <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    554c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000554e <.LCFI6>:
    554e:	08 14       	pushm.a	#1,	r8	;20-bit words

00005550 <.LCFI7>:
    5550:	c8 0c       	mova	r12,	r8	;
    5552:	ca 0d       	mova	r13,	r10	;

00005554 <.Loc.273.1>:


  channel->registers->ctl &= (~DMAEN);
    5554:	0c 0c       	mova	@r12,	r12	;

00005556 <.LVL50>:
    5556:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    555a:	00 00 

0000555c <.Loc.274.1>:
  dma_trigger_set(channel->index, request->trigger);
    555c:	5d 4d 10 00 	mov.b	16(r13),r13	;0x00010

00005560 <.LVL51>:
    5560:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5564:	b0 13 2c 54 	calla	#21548		;0x0542c

00005568 <.LVL52>:
  callbacks[channel->index] = request->callback;
    5568:	5c 48 04 00 	mov.b	4(r8),	r12	;
    556c:	4c 0e       	rlam.a	#4,	r12	;
    556e:	4c 0d       	rram.a	#4,	r12	;
    5570:	0c 14       	pushm.a	#1,	r12	;20-bit words
    5572:	40 18 3c 41 	popx.w	r12		;
    5576:	40 18 3d 41 	popx.w	r13		;
    557a:	b0 13 04 9f 	calla	#40708		;0x09f04
    557e:	0d 12       	push	r13		;
    5580:	0c 12       	push	r12		;
    5582:	0c 16       	popm.a	#1,	r12	;20-bit words
    5584:	ac 00 6a d3 	adda	#54122,	r12	;0x0d36a
    5588:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    558c:	00 00 
    558e:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    5592:	02 00 
    5594:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    5598:	04 00 
    559a:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    559e:	06 00 

000055a0 <.Loc.278.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    55a0:	0c 08       	mova	@r8,	r12	;
    55a2:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    55a6:	02 00 

000055a8 <.Loc.279.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    55a8:	0c 08       	mova	@r8,	r12	;
    55aa:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    55ae:	04 00 06 00 

000055b2 <.Loc.284.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    55b2:	0c 08       	mova	@r8,	r12	;
    55b4:	9c 4a 08 00 	mov	8(r10),	10(r12)	; 0x000a
    55b8:	0a 00 

000055ba <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    55ba:	0e 08       	mova	@r8,	r14	;
    55bc:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    55c0:	1c da 0a 00 	bis	10(r10),r12	;0x0000a
    55c4:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    55c8:	3c d0 15 00 	bis	#21,	r12	;#0x0015
    55cc:	8e 4c 00 00 	mov	r12,	0(r14)	;

000055d0 <.Loc.288.1>:
                            request->transfer_mode | DMAEN |
                            DMAREQ;
}
    55d0:	08 16       	popm.a	#1,	r8	;20-bit words
    55d2:	0a 16       	popm.a	#1,	r10	;20-bit words
    55d4:	10 01       	reta			;

000055d6 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    55d6:	1a 14       	pushm.a	#2,	r10	;20-bit words

000055d8 <.LCFI10>:
    55d8:	ca 0c       	mova	r12,	r10	;

000055da <.LBB35>:
  return chSysGetStatusAndLockX();
    55da:	b0 13 2a 48 	calla	#18474		;0x0482a

000055de <.LVL59>:
    55de:	09 4c       	mov	r12,	r9	;

000055e0 <.LBE35>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
    55e0:	9a 00 00 00 	cmpa	#0,	r10	;
    55e4:	10 24       	jz	$+34     	;abs 0x5606

000055e6 <.L25>:
  
  if (dmaIsClaimed(channel)) {
    55e6:	9a 00 00 00 	cmpa	#0,	r10	;
    55ea:	08 24       	jz	$+18     	;abs 0x55fc

000055ec <.Loc.305.1>:
    55ec:	0c 0a       	mova	@r10,	r12	;
    55ee:	9c 00 00 00 	cmpa	#0,	r12	;
    55f2:	04 24       	jz	$+10     	;abs 0x55fc

000055f4 <.Loc.305.1>:
    55f4:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    55f8:	00 00 
    55fa:	0b 20       	jnz	$+24     	;abs 0x5612

000055fc <.L26>:
  chSysRestoreStatusX(sts);
    55fc:	0c 49       	mov	r9,	r12	;
    55fe:	b0 13 54 48 	calla	#18516		;0x04854

00005602 <.LBE37>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  osalSysRestoreStatusX(sts);
}
    5602:	19 16       	popm.a	#2,	r10	;20-bit words
    5604:	10 01       	reta			;

00005606 <.L27>:
  osalDbgCheck(channel != NULL);
    5606:	8c 01 b8 02 	mova	#66232,	r12	;0x102b8
    560a:	b0 13 a0 47 	calla	#18336		;0x047a0

0000560e <.LVL62>:
    560e:	80 00 e6 55 	mova	#21990,	r0	;0x055e6

00005612 <.L28>:
    channel->registers->ctl = DMAABORT;
    5612:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00005616 <.Loc.311.1>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    5616:	4d 43       	clr.b	r13		;
    5618:	8c 00 68 d3 	mova	#54120,	r12	;0x0d368
    561c:	b0 13 28 50 	calla	#20520		;0x05028

00005620 <.LVL63>:
    5620:	80 00 fc 55 	mova	#22012,	r0	;0x055fc

00005624 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    5624:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005626 <.LCFI11>:
    5626:	ca 0c       	mova	r12,	r10	;

00005628 <.Loc.327.1>:
  
  osalDbgCheck(channel != NULL);
    5628:	9c 00 00 00 	cmpa	#0,	r12	;
    562c:	07 24       	jz	$+16     	;abs 0x563c

0000562e <.L30>:
  
  if (!(channel->registers->ctl & DMAEN)) {
    562e:	0c 0a       	mova	@r10,	r12	;
    5630:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5634:	00 00 
    5636:	08 20       	jnz	$+18     	;abs 0x5648

00005638 <.L29>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
  channel->registers->sz  = 0;
  channel->registers->ctl = DMAEN | DMAABORT;
}
    5638:	0a 16       	popm.a	#1,	r10	;20-bit words
    563a:	10 01       	reta			;

0000563c <.L32>:
  osalDbgCheck(channel != NULL);
    563c:	8c 01 ad 02 	mova	#66221,	r12	;0x102ad
    5640:	b0 13 a0 47 	calla	#18336		;0x047a0

00005644 <.LVL66>:
    5644:	80 00 2e 56 	mova	#22062,	r0	;0x0562e

00005648 <.L33>:
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    5648:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    564c:	00 00 

0000564e <.Loc.336.1>:
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    564e:	4d 43       	clr.b	r13		;
    5650:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5654:	b0 13 2c 54 	calla	#21548		;0x0542c

00005658 <.LVL67>:
  channel->registers->sz  = 0;
    5658:	0c 0a       	mova	@r10,	r12	;
    565a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000565e <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    565e:	0c 0a       	mova	@r10,	r12	;
    5660:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5664:	00 00 
    5666:	80 00 38 56 	mova	#22072,	r0	;0x05638

0000566a <spi_lld_init>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    566a:	10 01       	reta			;

0000566c <UCBRS>:
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
  /* TODO there must be a better way */
  if (frac < 529)
    566c:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    5670:	0d 9c       	cmp	r12,	r13	;
    5672:	a9 2c       	jc	$+340    	;abs 0x57c6

00005674 <.Loc.84.1>:
    return 0x00;
  else if (frac < 715)
    5674:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    5678:	0d 9c       	cmp	r12,	r13	;
    567a:	a7 2c       	jc	$+336    	;abs 0x57ca

0000567c <.Loc.86.1>:
    return 0x01;
  else if (frac < 835)
    567c:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    5680:	0d 9c       	cmp	r12,	r13	;
    5682:	03 28       	jnc	$+8      	;abs 0x568a

00005684 <.Loc.87.1>:
    return 0x02;
    5684:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005686 <.LVL1>:
    5686:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

0000568a <.L38>:
  else if (frac < 1001)
    568a:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    568e:	0d 9c       	cmp	r12,	r13	;
    5690:	03 28       	jnc	$+8      	;abs 0x5698

00005692 <.Loc.89.1>:
    return 0x04;
    5692:	6c 42       	mov.b	#4,	r12	;r2 As==10

00005694 <.LVL3>:
    5694:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005698 <.L39>:
  else if (frac < 1252)
    5698:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    569c:	0d 9c       	cmp	r12,	r13	;
    569e:	03 28       	jnc	$+8      	;abs 0x56a6

000056a0 <.Loc.91.1>:
    return 0x08;
    56a0:	7c 42       	mov.b	#8,	r12	;r2 As==11

000056a2 <.LVL5>:
    56a2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056a6 <.L40>:
  else if (frac < 1430)
    56a6:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    56aa:	0d 9c       	cmp	r12,	r13	;
    56ac:	04 28       	jnc	$+10     	;abs 0x56b6

000056ae <.Loc.93.1>:
    return 0x10;
    56ae:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000056b2 <.LVL7>:
    56b2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056b6 <.L41>:
  else if (frac < 1670)
    56b6:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    56ba:	0d 9c       	cmp	r12,	r13	;
    56bc:	04 28       	jnc	$+10     	;abs 0x56c6

000056be <.Loc.95.1>:
    return 0x20;
    56be:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000056c2 <.LVL9>:
    56c2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056c6 <.L42>:
  else if (frac < 2147)
    56c6:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    56ca:	0d 9c       	cmp	r12,	r13	;
    56cc:	04 28       	jnc	$+10     	;abs 0x56d6

000056ce <.Loc.97.1>:
    return 0x11;
    56ce:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000056d2 <.LVL11>:
    56d2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056d6 <.L43>:
  else if (frac < 2224)
    56d6:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    56da:	0d 9c       	cmp	r12,	r13	;
    56dc:	04 28       	jnc	$+10     	;abs 0x56e6

000056de <.Loc.99.1>:
    return 0x21;
    56de:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

000056e2 <.LVL13>:
    56e2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056e6 <.L44>:
  else if (frac < 2503)
    56e6:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    56ea:	0d 9c       	cmp	r12,	r13	;
    56ec:	71 2c       	jc	$+228    	;abs 0x57d0

000056ee <.Loc.102.1>:
    return 0x22;
  else if (frac < 3000)
    56ee:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    56f2:	0d 9c       	cmp	r12,	r13	;
    56f4:	04 28       	jnc	$+10     	;abs 0x56fe

000056f6 <.Loc.103.1>:
    return 0x44;
    56f6:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

000056fa <.LVL15>:
    56fa:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000056fe <.L45>:
  else if (frac < 3335)
    56fe:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    5702:	0d 9c       	cmp	r12,	r13	;
    5704:	69 2c       	jc	$+212    	;abs 0x57d8

00005706 <.Loc.106.1>:
    return 0x25;
  else if (frac < 3575)
    5706:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    570a:	0d 9c       	cmp	r12,	r13	;
    570c:	69 2c       	jc	$+212    	;abs 0x57e0

0000570e <.Loc.108.1>:
    return 0x49;
  else if (frac < 3753)
    570e:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    5712:	0d 9c       	cmp	r12,	r13	;
    5714:	69 2c       	jc	$+212    	;abs 0x57e8

00005716 <.Loc.110.1>:
    return 0x4A;
  else if (frac < 4003)
    5716:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    571a:	0d 9c       	cmp	r12,	r13	;
    571c:	69 2c       	jc	$+212    	;abs 0x57f0

0000571e <.Loc.112.1>:
    return 0x52;
  else if (frac < 4286)
    571e:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    5722:	0d 9c       	cmp	r12,	r13	;
    5724:	69 2c       	jc	$+212    	;abs 0x57f8

00005726 <.Loc.114.1>:
    return 0x92;
  else if (frac < 4378)
    5726:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    572a:	0d 9c       	cmp	r12,	r13	;
    572c:	69 2c       	jc	$+212    	;abs 0x5800

0000572e <.Loc.116.1>:
    return 0x53;
  else if (frac < 5002)
    572e:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    5732:	0d 9c       	cmp	r12,	r13	;
    5734:	69 2c       	jc	$+212    	;abs 0x5808

00005736 <.Loc.118.1>:
    return 0x55;
  else if (frac < 5715)
    5736:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    573a:	0d 9c       	cmp	r12,	r13	;
    573c:	69 2c       	jc	$+212    	;abs 0x5810

0000573e <.Loc.120.1>:
    return 0xAA;
  else if (frac < 6003)
    573e:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    5742:	0d 9c       	cmp	r12,	r13	;
    5744:	69 2c       	jc	$+212    	;abs 0x5818

00005746 <.Loc.122.1>:
    return 0x6B;
  else if (frac < 6254)
    5746:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    574a:	0d 9c       	cmp	r12,	r13	;
    574c:	69 2c       	jc	$+212    	;abs 0x5820

0000574e <.Loc.124.1>:
    return 0xAD;
  else if (frac < 6432)
    574e:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    5752:	0d 9c       	cmp	r12,	r13	;
    5754:	69 2c       	jc	$+212    	;abs 0x5828

00005756 <.Loc.126.1>:
    return 0xB5;
  else if (frac < 6667)
    5756:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    575a:	0d 9c       	cmp	r12,	r13	;
    575c:	69 2c       	jc	$+212    	;abs 0x5830

0000575e <.Loc.128.1>:
    return 0xB6;
  else if (frac < 7001)
    575e:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    5762:	0d 9c       	cmp	r12,	r13	;
    5764:	69 2c       	jc	$+212    	;abs 0x5838

00005766 <.Loc.130.1>:
    return 0xD6;
  else if (frac < 7147)
    5766:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    576a:	0d 9c       	cmp	r12,	r13	;
    576c:	69 2c       	jc	$+212    	;abs 0x5840

0000576e <.Loc.132.1>:
    return 0xB7;
  else if (frac < 7503)
    576e:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    5772:	0d 9c       	cmp	r12,	r13	;
    5774:	69 2c       	jc	$+212    	;abs 0x5848

00005776 <.Loc.134.1>:
    return 0xBB;
  else if (frac < 7861)
    5776:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    577a:	0d 9c       	cmp	r12,	r13	;
    577c:	69 2c       	jc	$+212    	;abs 0x5850

0000577e <.Loc.136.1>:
    return 0xDD;
  else if (frac < 8004)
    577e:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    5782:	0d 9c       	cmp	r12,	r13	;
    5784:	69 2c       	jc	$+212    	;abs 0x5858

00005786 <.Loc.138.1>:
    return 0xED;
  else if (frac < 8333)
    5786:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    578a:	0d 9c       	cmp	r12,	r13	;
    578c:	69 2c       	jc	$+212    	;abs 0x5860

0000578e <.Loc.140.1>:
    return 0xEE;
  else if (frac < 8464)
    578e:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    5792:	0d 9c       	cmp	r12,	r13	;
    5794:	69 2c       	jc	$+212    	;abs 0x5868

00005796 <.Loc.142.1>:
    return 0xBF;
  else if (frac < 8572)
    5796:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    579a:	0d 9c       	cmp	r12,	r13	;
    579c:	69 2c       	jc	$+212    	;abs 0x5870

0000579e <.Loc.144.1>:
    return 0xDF;
  else if (frac < 8751)
    579e:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    57a2:	0d 9c       	cmp	r12,	r13	;
    57a4:	69 2c       	jc	$+212    	;abs 0x5878

000057a6 <.Loc.146.1>:
    return 0xEF;
  else if (frac < 9004)
    57a6:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    57aa:	0d 9c       	cmp	r12,	r13	;
    57ac:	69 2c       	jc	$+212    	;abs 0x5880

000057ae <.Loc.148.1>:
    return 0xF7;
  else if (frac < 9170)
    57ae:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    57b2:	0d 9c       	cmp	r12,	r13	;
    57b4:	69 2c       	jc	$+212    	;abs 0x5888

000057b6 <.Loc.150.1>:
    return 0xFB;
  else if (frac < 9288)
    57b6:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    57ba:	0d 9c       	cmp	r12,	r13	;
    57bc:	69 28       	jnc	$+212    	;abs 0x5890

000057be <.Loc.151.1>:
    return 0xFD;
    57be:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

000057c2 <.LVL17>:
    57c2:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057c6 <.L3>:
    return 0x00;
    57c6:	4c 43       	clr.b	r12		;

000057c8 <.L2>:
  else
    return 0xFE;
}
    57c8:	10 01       	reta			;

000057ca <.L4>:
    return 0x01;
    57ca:	5c 43       	mov.b	#1,	r12	;r3 As==01

000057cc <.LVL21>:
    57cc:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057d0 <.L12>:
    return 0x22;
    57d0:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

000057d4 <.LVL23>:
    57d4:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057d8 <.L14>:
    return 0x25;
    57d8:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

000057dc <.LVL25>:
    57dc:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057e0 <.L15>:
    return 0x49;
    57e0:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

000057e4 <.LVL27>:
    57e4:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057e8 <.L16>:
    return 0x4A;
    57e8:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

000057ec <.LVL29>:
    57ec:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057f0 <.L17>:
    return 0x52;
    57f0:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

000057f4 <.LVL31>:
    57f4:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

000057f8 <.L18>:
    return 0x92;
    57f8:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

000057fc <.LVL33>:
    57fc:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005800 <.L19>:
    return 0x53;
    5800:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00005804 <.LVL35>:
    5804:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005808 <.L20>:
    return 0x55;
    5808:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

0000580c <.LVL37>:
    580c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005810 <.L21>:
    return 0xAA;
    5810:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00005814 <.LVL39>:
    5814:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005818 <.L22>:
    return 0x6B;
    5818:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

0000581c <.LVL41>:
    581c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005820 <.L23>:
    return 0xAD;
    5820:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00005824 <.LVL43>:
    5824:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005828 <.L24>:
    return 0xB5;
    5828:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

0000582c <.LVL45>:
    582c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005830 <.L25>:
    return 0xB6;
    5830:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00005834 <.LVL47>:
    5834:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005838 <.L26>:
    return 0xD6;
    5838:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

0000583c <.LVL49>:
    583c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005840 <.L27>:
    return 0xB7;
    5840:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00005844 <.LVL51>:
    5844:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005848 <.L28>:
    return 0xBB;
    5848:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

0000584c <.LVL53>:
    584c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005850 <.L29>:
    return 0xDD;
    5850:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00005854 <.LVL55>:
    5854:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005858 <.L30>:
    return 0xED;
    5858:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

0000585c <.LVL57>:
    585c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005860 <.L31>:
    return 0xEE;
    5860:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00005864 <.LVL59>:
    5864:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005868 <.L32>:
    return 0xBF;
    5868:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

0000586c <.LVL61>:
    586c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005870 <.L33>:
    return 0xDF;
    5870:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

00005874 <.LVL63>:
    5874:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005878 <.L34>:
    return 0xEF;
    5878:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

0000587c <.LVL65>:
    587c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005880 <.L35>:
    return 0xF7;
    5880:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00005884 <.LVL67>:
    5884:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005888 <.L36>:
    return 0xFB;
    5888:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

0000588c <.LVL69>:
    588c:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005890 <.L37>:
    return 0xFE;
    5890:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00005894 <.LVL71>:
    5894:	80 00 c8 57 	mova	#22472,	r0	;0x057c8

00005898 <set_baud>:

static void set_baud(UARTDriver * uartp) {
    5898:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000589a <.LCFI0>:
    589a:	b1 00 04 00 	suba	#4,	r1	;

0000589e <.LCFI1>:
    589e:	c6 0c       	mova	r12,	r6	;

000058a0 <.Loc.157.1>:
  uint16_t n = uartp->freq / uartp->config->baud;
    58a0:	91 4c 12 00 	mov	18(r12),0(r1)	;0x00012
    58a4:	00 00 
    58a6:	91 4c 14 00 	mov	20(r12),2(r1)	;0x00014
    58aa:	02 00 
    58ac:	3c 0c 04 00 	mova	4(r12),	r12	;

000058b0 <.LVL73>:
    58b0:	14 4c 14 00 	mov	20(r12),r4	;0x00014
    58b4:	15 4c 16 00 	mov	22(r12),r5	;0x00016
    58b8:	87 00 98 9e 	mova	#40600,	r7	;0x09e98
    58bc:	0e 44       	mov	r4,	r14	;
    58be:	0f 45       	mov	r5,	r15	;
    58c0:	2c 41       	mov	@r1,	r12	;
    58c2:	1d 41 02 00 	mov	2(r1),	r13	;
    58c6:	47 13       	calla	r7		;

000058c8 <.LVL74>:
    58c8:	09 4c       	mov	r12,	r9	;

000058ca <.LVL75>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    58ca:	88 00 d2 9f 	mova	#40914,	r8	;0x09fd2
    58ce:	0e 44       	mov	r4,	r14	;
    58d0:	0f 45       	mov	r5,	r15	;
    58d2:	4d 43       	clr.b	r13		;
    58d4:	48 13       	calla	r8		;

000058d6 <.LVL76>:
    58d6:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    58da:	4f 43       	clr.b	r15		;
    58dc:	2a 41       	mov	@r1,	r10	;
    58de:	1b 41 02 00 	mov	2(r1),	r11	;
    58e2:	40 18 0a 8c 	subx.w	r12,	r10	;
    58e6:	40 18 0b 7d 	subcx.w	r13,	r11	;
    58ea:	0c 4a       	mov	r10,	r12	;
    58ec:	0d 4b       	mov	r11,	r13	;
    58ee:	48 13       	calla	r8		;

000058f0 <.LVL77>:
    58f0:	0e 44       	mov	r4,	r14	;
    58f2:	0f 45       	mov	r5,	r15	;
    58f4:	47 13       	calla	r7		;

000058f6 <.LVL78>:
  if (n > 16) {
    58f6:	7b 40 10 00 	mov.b	#16,	r11	;#0x0010
    58fa:	0b 99       	cmp	r9,	r11	;
    58fc:	10 28       	jnc	$+34     	;abs 0x591e

000058fe <.Loc.165.1>:
    uartp->regs->brw = (n >> 4);
    n = (n & 0x0F);
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
  }
  else {
    uartp->regs->brw = n;
    58fe:	3e 06 16 00 	mova	22(r6),	r14	;0x00016
    5902:	8e 49 06 00 	mov	r9,	6(r14)	;

00005906 <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    5906:	3a 06 16 00 	mova	22(r6),	r10	;0x00016
    590a:	b0 13 6c 56 	calla	#22124		;0x0566c

0000590e <.LVL79>:
    590e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5912:	8a 4c 08 00 	mov	r12,	8(r10)	;

00005916 <.L46>:
  }
}
    5916:	a1 00 04 00 	adda	#4,	r1	;
    591a:	64 16       	popm.a	#7,	r10	;20-bit words
    591c:	10 01       	reta			;

0000591e <.L49>:
    uartp->regs->brw = (n >> 4);
    591e:	3e 06 16 00 	mova	22(r6),	r14	;0x00016
    5922:	0d 49       	mov	r9,	r13	;
    5924:	5d 0f       	rrum	#4,	r13	;
    5926:	8e 4d 06 00 	mov	r13,	6(r14)	;

0000592a <.LVL82>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    592a:	3a 06 16 00 	mova	22(r6),	r10	;0x00016
    592e:	b0 13 6c 56 	calla	#22124		;0x0566c

00005932 <.LVL83>:
    5932:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5936:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    593a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    593e:	0c d9       	bis	r9,	r12	;
    5940:	1c d3       	bis	#1,	r12	;r3 As==01
    5942:	8a 4c 08 00 	mov	r12,	8(r10)	;
    5946:	80 00 16 59 	mova	#22806,	r0	;0x05916

0000594a <uart_enter_rx_idle_loop>:
  }
}

static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
    594a:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

0000594e <.LVL85>:
    594e:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005952 <.Loc.207.1>:
}
    5952:	10 01       	reta			;

00005954 <rx_cb>:

static void rx_cb(void * arg){
    5954:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005956 <.LCFI2>:
    5956:	ca 0c       	mova	r12,	r10	;

00005958 <.LVL87>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5958:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    595c:	3c 0c 04 00 	mova	4(r12),	r12	;

00005960 <.LVL88>:
    5960:	3e 0c 08 00 	mova	8(r12),	r14	;
    5964:	9e 00 00 00 	cmpa	#0,	r14	;
    5968:	02 24       	jz	$+6      	;abs 0x596e

0000596a <.Loc.213.1>:
    596a:	cc 0a       	mova	r10,	r12	;
    596c:	4e 13       	calla	r14		;

0000596e <.L52>:
    596e:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    5972:	16 24       	jz	$+46     	;abs 0x59a0

00005974 <.L53>:
  chSysLockFromISR();
    5974:	b0 13 92 45 	calla	#17810		;0x04592

00005978 <.LBB33>:
  chThdResumeI(trp, msg);
    5978:	4d 43       	clr.b	r13		;
    597a:	cc 0a       	mova	r10,	r12	;
    597c:	ac 00 0a 00 	adda	#10,	r12	;0x0000a

00005980 <.LVL91>:
    5980:	b0 13 a6 49 	calla	#18854		;0x049a6

00005984 <.LBB35>:
  chSysUnlockFromISR();
    5984:	b0 13 b4 45 	calla	#17844		;0x045b4

00005988 <.LBE35>:
  if (uartp->rxstate == UART_RX_IDLE) {
    5988:	ca 93 02 00 	cmp.b	#0,	2(r10)	;r3 As==00
    598c:	07 20       	jnz	$+16     	;abs 0x599c

0000598e <.Loc.216.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
    if (uartp->config->dmarx_index >= MSP430X_DMA_CHANNELS) {
    598e:	3c 0a 04 00 	mova	4(r10),	r12	;
    5992:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f
    5996:	5d 9c 19 00 	cmp.b	25(r12),r13	;0x00019
    599a:	09 28       	jnc	$+20     	;abs 0x59ae

0000599c <.L51>:
#else
    dmaReleaseX(&(uartp->dmta_rx));
    uartp->dma_acquired_rx = false;
#endif
  }
}
    599c:	0a 16       	popm.a	#1,	r10	;20-bit words
    599e:	10 01       	reta			;

000059a0 <.L55>:
  _uart_rx_complete_isr_code(uartp);
    59a0:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    59a4:	cc 0a       	mova	r10,	r12	;
    59a6:	b0 13 4a 59 	calla	#22858		;0x0594a

000059aa <.LVL94>:
    59aa:	80 00 74 59 	mova	#22900,	r0	;0x05974

000059ae <.L56>:
      dmaReleaseX(&(uartp->dma_rx));
    59ae:	cc 0a       	mova	r10,	r12	;
    59b0:	ac 00 58 00 	adda	#88,	r12	;0x00058
    59b4:	b0 13 d6 55 	calla	#21974		;0x055d6

000059b8 <.LVL95>:
      uartp->dma_acquired_rx = false;
    59b8:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063

000059bc <.Loc.225.1>:
}
    59bc:	80 00 9c 59 	mova	#22940,	r0	;0x0599c

000059c0 <tx_cb>:
static void tx_cb(void * arg) {
    59c0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000059c2 <.LCFI3>:
    59c2:	ca 0c       	mova	r12,	r10	;

000059c4 <.LVL97>:
  _uart_tx1_isr_code(uartp);
    59c4:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    59c8:	3c 0c 04 00 	mova	4(r12),	r12	;

000059cc <.LVL98>:
    59cc:	0e 0c       	mova	@r12,	r14	;
    59ce:	9e 00 00 00 	cmpa	#0,	r14	;
    59d2:	02 24       	jz	$+6      	;abs 0x59d8

000059d4 <.Loc.183.1>:
    59d4:	cc 0a       	mova	r10,	r12	;
    59d6:	4e 13       	calla	r14		;

000059d8 <.L58>:
    59d8:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    59dc:	1d 24       	jz	$+60     	;abs 0x5a18

000059de <.L59>:
    59de:	ca 93 08 00 	cmp.b	#0,	8(r10)	;r3 As==00
    59e2:	1e 20       	jnz	$+62     	;abs 0x5a20

000059e4 <.L60>:
  if (uartp->txstate == UART_TX_IDLE) {
    59e4:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    59e8:	15 20       	jnz	$+44     	;abs 0x5a14

000059ea <.L62>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    59ea:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    59ee:	40 18 bc b2 	bitx.w	#8,	28(r12)	;r2 As==11, 0x0001c
    59f2:	1c 00 
    59f4:	fa 27       	jz	$-10     	;abs 0x59ea

000059f6 <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    59f6:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

000059fa <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    59fa:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    59fe:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

00005a02 <.Loc.193.1>:
    if (uartp->config->dmatx_index >= MSP430X_DMA_CHANNELS) {
    5a02:	3c 0a 04 00 	mova	4(r10),	r12	;
    5a06:	5c 4c 19 00 	mov.b	25(r12),r12	;0x00019
    5a0a:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    5a0e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5a10:	0d 9c       	cmp	r12,	r13	;
    5a12:	12 38       	jl	$+38     	;abs 0x5a38

00005a14 <.L57>:
}
    5a14:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a16:	10 01       	reta			;

00005a18 <.L63>:
  _uart_tx1_isr_code(uartp);
    5a18:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00
    5a1c:	80 00 de 59 	mova	#23006,	r0	;0x059de

00005a20 <.L64>:
  chSysLockFromISR();
    5a20:	b0 13 92 45 	calla	#17810		;0x04592

00005a24 <.LBB39>:
  chThdResumeI(trp, msg);
    5a24:	4d 43       	clr.b	r13		;
    5a26:	cc 0a       	mova	r10,	r12	;
    5a28:	ac 00 0e 00 	adda	#14,	r12	;0x0000e

00005a2c <.LVL101>:
    5a2c:	b0 13 a6 49 	calla	#18854		;0x049a6

00005a30 <.LBB41>:
  chSysUnlockFromISR();
    5a30:	b0 13 b4 45 	calla	#17844		;0x045b4

00005a34 <.LVL103>:
    5a34:	80 00 e4 59 	mova	#23012,	r0	;0x059e4

00005a38 <.L65>:
      dmaReleaseX(&(uartp->dma_tx));
    5a38:	cc 0a       	mova	r10,	r12	;
    5a3a:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5a3e:	b0 13 d6 55 	calla	#21974		;0x055d6

00005a42 <.LVL104>:
      uartp->dma_acquired_tx = false;
    5a42:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062

00005a46 <.Loc.202.1>:
}
    5a46:	80 00 14 5a 	mova	#23060,	r0	;0x05a14

00005a4a <init_transfer>:
static void init_transfer(msp430x_dma_ch_t * dma, msp430x_dma_req_t * req, bool *acquired) {
    5a4a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005a4c <.LCFI4>:
    5a4c:	08 14       	pushm.a	#1,	r8	;20-bit words

00005a4e <.LCFI5>:
    5a4e:	06 14       	pushm.a	#1,	r6	;20-bit words

00005a50 <.LCFI6>:
    5a50:	ca 0c       	mova	r12,	r10	;
    5a52:	c6 0d       	mova	r13,	r6	;
    5a54:	c8 0e       	mova	r14,	r8	;

00005a56 <.Loc.171.1>:
  if (!(*acquired)) {
    5a56:	ce 93 00 00 	cmp.b	#0,	0(r14)	;r3 As==00
    5a5a:	08 24       	jz	$+18     	;abs 0x5a6c

00005a5c <.L67>:
  dmaTransferI(dma, req);
    5a5c:	cd 06       	mova	r6,	r13	;
    5a5e:	cc 0a       	mova	r10,	r12	;
    5a60:	b0 13 4c 55 	calla	#21836		;0x0554c

00005a64 <.LVL107>:
}
    5a64:	06 16       	popm.a	#1,	r6	;20-bit words
    5a66:	08 16       	popm.a	#1,	r8	;20-bit words
    5a68:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a6a:	10 01       	reta			;

00005a6c <.L68>:
    dmaAcquireI(dma);
    5a6c:	b0 13 70 54 	calla	#21616		;0x05470

00005a70 <.LVL108>:
    (*acquired) = true;
    5a70:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01
    5a74:	80 00 5c 5a 	mova	#23132,	r0	;0x05a5c

00005a78 <uart_lld_init>:
/**
 * @brief   Low level UART driver initialization.
 *
 * @notapi
 */
void uart_lld_init(void) {
    5a78:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005a7a <.LCFI8>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
#endif
  
#if MSP430X_UART_USE_UARTA1 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA1);
    5a7a:	8a 01 ee 05 	mova	#67054,	r10	;0x105ee
    5a7e:	cc 0a       	mova	r10,	r12	;
    5a80:	b0 13 bc 51 	calla	#20924		;0x051bc

00005a84 <.LVL134>:
  UARTDA1.regs = (msp430x_uart_reg_t  *)(&UCA1CTLW0);
    5a84:	00 18 fa 40 	movx.a	#1504,	22(r10)	;0x005e0, 0x00016
    5a88:	e0 05 16 00 

00005a8c <.Loc.483.1>:
  UARTDA1.freq = MSP430X_UARTA1_CLK_FREQ;
    5a8c:	ba 40 00 24 	mov	#9216,	18(r10)	;#0x2400, 0x0012
    5a90:	12 00 
    5a92:	ba 40 f4 00 	mov	#244,	20(r10)	;#0x00f4, 0x0014
    5a96:	14 00 

00005a98 <.Loc.484.1>:
  UARTDA1.dmareq_tx.dest_addr = (void*)(&UCA1TXBUF);
    5a98:	00 18 fa 40 	movx.a	#1518,	30(r10)	;0x005ee, 0x0001e
    5a9c:	ee 05 1e 00 

00005aa0 <.Loc.485.1>:
  UARTDA1.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    5aa0:	ba 40 00 03 	mov	#768,	36(r10)	;#0x0300, 0x0024
    5aa4:	24 00 

00005aa6 <.Loc.486.1>:
  UARTDA1.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5aa6:	ba 40 c0 00 	mov	#192,	38(r10)	;#0x00c0, 0x0026
    5aaa:	26 00 

00005aac <.Loc.487.1>:
  UARTDA1.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    5aac:	8a 43 28 00 	mov	#0,	40(r10)	;r3 As==00, 0x0028

00005ab0 <.Loc.488.1>:
  UARTDA1.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA1TXIFG);
    5ab0:	ba 40 11 00 	mov	#17,	42(r10)	;#0x0011, 0x002a
    5ab4:	2a 00 

00005ab6 <.Loc.489.1>:
  UARTDA1.dmareq_rx.source_addr = (void*)(&UCA1RXBUF);
    5ab6:	00 18 fa 40 	movx.a	#1516,	52(r10)	;0x005ec, 0x00034
    5aba:	ec 05 34 00 

00005abe <.Loc.490.1>:
  UARTDA1.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    5abe:	ba 40 00 0c 	mov	#3072,	62(r10)	;#0x0c00, 0x003e
    5ac2:	3e 00 

00005ac4 <.Loc.491.1>:
  UARTDA1.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    5ac4:	ba 40 c0 00 	mov	#192,	64(r10)	;#0x00c0, 0x0040
    5ac8:	40 00 

00005aca <.Loc.492.1>:
  UARTDA1.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    5aca:	8a 43 42 00 	mov	#0,	66(r10)	;r3 As==00, 0x0042

00005ace <.Loc.493.1>:
  UARTDA1.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA1RXIFG);
    5ace:	ba 40 10 00 	mov	#16,	68(r10)	;#0x0010, 0x0044
    5ad2:	44 00 

00005ad4 <.Loc.532.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    5ad4:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ad6:	10 01       	reta			;

00005ad8 <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    5ad8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005ada <.LCFI9>:
    5ada:	08 14       	pushm.a	#1,	r8	;20-bit words

00005adc <.LCFI10>:
    5adc:	ca 0c       	mova	r12,	r10	;

00005ade <.Loc.543.1>:

  if (uartp->state != UART_STOP) {
    5ade:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    5ae2:	0c 24       	jz	$+26     	;abs 0x5afc

00005ae4 <.L92>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    5ae4:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5ae8:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    5aec:	1c 00 
    5aee:	fa 27       	jz	$-10     	;abs 0x5ae4

00005af0 <.Loc.548.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    5af0:	ca 93 62 00 	cmp.b	#0,	98(r10)	;r3 As==00, 0x0062
    5af4:	43 20       	jnz	$+136    	;abs 0x5b7c

00005af6 <.L93>:
      dmaReleaseX(&(uartp->dma_tx));
    }
    if (uartp->dma_acquired_rx) {
    5af6:	ca 93 63 00 	cmp.b	#0,	99(r10)	;r3 As==00, 0x0063
    5afa:	47 20       	jnz	$+144    	;abs 0x5b8a

00005afc <.L91>:
      dmaReleaseX(&(uartp->dma_rx));
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    5afc:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5b00:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

00005b04 <.Loc.558.1>:
  set_baud(uartp);
    5b04:	cc 0a       	mova	r10,	r12	;
    5b06:	b0 13 98 58 	calla	#22680		;0x05898

00005b0a <.LVL137>:
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    5b0a:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    5b0e:	3c 0a 04 00 	mova	4(r10),	r12	;
    5b12:	5c 4c 18 00 	mov.b	24(r12),r12	;0x00018
    5b16:	5c 0f       	rrum	#4,	r12	;
    5b18:	5c 03       	rrum	#1,	r12	;
    5b1a:	5c f3       	and.b	#1,	r12	;r3 As==01
    5b1c:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    5b20:	8e 4c 10 00 	mov	r12,	16(r14)	; 0x0010

00005b24 <.Loc.563.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    5b24:	3c 0a 04 00 	mova	4(r10),	r12	;
    5b28:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    5b2c:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    5b30:	4c 4d       	mov.b	r13,	r12	;
    5b32:	6e 43       	mov.b	#2,	r14	;r3 As==10
    5b34:	0e 9c       	cmp	r12,	r14	;
    5b36:	30 34       	jge	$+98     	;abs 0x5b98

00005b38 <.Loc.569.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_tx = !b;
  }
  else {
    uartp->dma_acquired_tx = false;
    5b38:	ca 43 62 00 	mov.b	#0,	98(r10)	;r3 As==00, 0x0062

00005b3c <.L97>:
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    5b3c:	3c 0a 04 00 	mova	4(r10),	r12	;
    5b40:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    5b44:	5d 0f       	rrum	#4,	r13	;
    5b46:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5b48:	0c 9d       	cmp	r13,	r12	;
    5b4a:	3e 34       	jge	$+126    	;abs 0x5bc8

00005b4c <.Loc.577.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_rx = !b;
  }
  else {
    uartp->dma_acquired_rx = false;
    5b4c:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063

00005b50 <.L101>:
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    5b50:	00 18 fa 40 	movx.a	#22976,	44(r10)	;0x059c0, 0x0002c
    5b54:	c0 59 2c 00 

00005b58 <.Loc.582.1>:
  uartp->dmareq_tx.callback.args = uartp;
    5b58:	7a 0a 30 00 	mova	r10,	48(r10)	; 0x00030

00005b5c <.Loc.583.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    5b5c:	00 18 fa 40 	movx.a	#22868,	70(r10)	;0x05954, 0x00046
    5b60:	54 59 46 00 

00005b64 <.Loc.584.1>:
  uartp->dmareq_rx.callback.args = uartp;
    5b64:	7a 0a 4a 00 	mova	r10,	74(r10)	; 0x0004a

00005b68 <.Loc.598.1>:
        (UCRXEIE) | (UCBRKIE));

  }
#endif
#if MSP430X_UART_USE_UARTA1 == TRUE
  if (&UARTDA1 == uartp) {
    5b68:	9a 01 ee 05 	cmpa	#67054,	r10	;0x105ee
    5b6c:	45 24       	jz	$+140    	;abs 0x5bf8

00005b6e <.L102>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    5b6e:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5b72:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005b76 <.Loc.634.1>:
}
    5b76:	08 16       	popm.a	#1,	r8	;20-bit words
    5b78:	0a 16       	popm.a	#1,	r10	;20-bit words
    5b7a:	10 01       	reta			;

00005b7c <.L103>:
      dmaReleaseX(&(uartp->dma_tx));
    5b7c:	cc 0a       	mova	r10,	r12	;
    5b7e:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5b82:	b0 13 d6 55 	calla	#21974		;0x055d6

00005b86 <.LVL138>:
    5b86:	80 00 f6 5a 	mova	#23286,	r0	;0x05af6

00005b8a <.L104>:
      dmaReleaseX(&(uartp->dma_rx));
    5b8a:	cc 0a       	mova	r10,	r12	;
    5b8c:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5b90:	b0 13 d6 55 	calla	#21974		;0x055d6

00005b94 <.LVL139>:
    5b94:	80 00 fc 5a 	mova	#23292,	r0	;0x05afc

00005b98 <.L105>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    5b98:	cc 0a       	mova	r10,	r12	;
    5b9a:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5b9e:	b0 13 f2 54 	calla	#21746		;0x054f2

00005ba2 <.LVL140>:
    5ba2:	c8 0c       	mova	r12,	r8	;

00005ba4 <.LVL141>:
    osalDbgAssert(!b, "stream already allocated");
    5ba4:	9c 00 00 00 	cmpa	#0,	r12	;
    5ba8:	09 20       	jnz	$+20     	;abs 0x5bbc

00005baa <.L95>:
    uartp->dma_acquired_tx = !b;
    5baa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5bac:	98 00 00 00 	cmpa	#0,	r8	;
    5bb0:	01 24       	jz	$+4      	;abs 0x5bb4
    5bb2:	4c 43       	clr.b	r12		;

00005bb4 <.L96>:
    5bb4:	ca 4c 62 00 	mov.b	r12,	98(r10)	; 0x0062
    5bb8:	80 00 3c 5b 	mova	#23356,	r0	;0x05b3c

00005bbc <.L108>:
    osalDbgAssert(!b, "stream already allocated");
    5bbc:	8c 01 ce 02 	mova	#66254,	r12	;0x102ce
    5bc0:	b0 13 a0 47 	calla	#18336		;0x047a0

00005bc4 <.LVL142>:
    5bc4:	80 00 aa 5b 	mova	#23466,	r0	;0x05baa

00005bc8 <.L106>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    5bc8:	cc 0a       	mova	r10,	r12	;
    5bca:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5bce:	b0 13 f2 54 	calla	#21746		;0x054f2

00005bd2 <.LVL144>:
    5bd2:	c8 0c       	mova	r12,	r8	;

00005bd4 <.LVL145>:
    osalDbgAssert(!b, "stream already allocated");
    5bd4:	9c 00 00 00 	cmpa	#0,	r12	;
    5bd8:	09 20       	jnz	$+20     	;abs 0x5bec

00005bda <.L99>:
    uartp->dma_acquired_rx = !b;
    5bda:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5bdc:	98 00 00 00 	cmpa	#0,	r8	;
    5be0:	01 24       	jz	$+4      	;abs 0x5be4
    5be2:	4c 43       	clr.b	r12		;

00005be4 <.L100>:
    5be4:	ca 4c 63 00 	mov.b	r12,	99(r10)	; 0x0063
    5be8:	80 00 50 5b 	mova	#23376,	r0	;0x05b50

00005bec <.L109>:
    osalDbgAssert(!b, "stream already allocated");
    5bec:	8c 01 ce 02 	mova	#66254,	r12	;0x102ce
    5bf0:	b0 13 a0 47 	calla	#18336		;0x047a0

00005bf4 <.LVL146>:
    5bf4:	80 00 da 5b 	mova	#23514,	r0	;0x05bda

00005bf8 <.L107>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5bf8:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5bfc:	3e 0a 04 00 	mova	4(r10),	r14	;
    5c00:	5d 4e 18 00 	mov.b	24(r14),r13	;0x00018
    5c04:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;

00005c08 <.Loc.600.1>:
        (uartp->config->order << 13) | 
    5c08:	5e 4e 18 00 	mov.b	24(r14),r14	;0x00018
    5c0c:	0f 4e       	mov	r14,	r15	;
    5c0e:	5f 07       	rrum	#2,	r15	;
    5c10:	5f f3       	and.b	#1,	r15	;r3 As==01
    5c12:	4c 18 0f 5f 	rpt #13 { rlax.w	r15		;

00005c16 <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5c16:	0d df       	bis	r15,	r13	;

00005c18 <.Loc.601.1>:
        (uartp->config->char_size << 12) | 
    5c18:	0f 4e       	mov	r14,	r15	;
    5c1a:	5f 0b       	rrum	#3,	r15	;
    5c1c:	5f f3       	and.b	#1,	r15	;r3 As==01
    5c1e:	4b 18 0f 5f 	rpt #12 { rlax.w	r15		;

00005c22 <.Loc.600.1>:
        (uartp->config->order << 13) | 
    5c22:	0d df       	bis	r15,	r13	;

00005c24 <.Loc.602.1>:
        (uartp->config->stop_bits << 11) |
    5c24:	0f 4e       	mov	r14,	r15	;
    5c26:	5f 0f       	rrum	#4,	r15	;
    5c28:	5f f3       	and.b	#1,	r15	;r3 As==01
    5c2a:	4a 18 0f 5f 	rpt #11 { rlax.w	r15		;

00005c2e <.Loc.601.1>:
        (uartp->config->char_size << 12) | 
    5c2e:	0d df       	bis	r15,	r13	;

00005c30 <.Loc.603.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5c30:	5e 0f       	rrum	#4,	r14	;
    5c32:	5e 03       	rrum	#1,	r14	;
    5c34:	5e f3       	and.b	#1,	r14	;r3 As==01
    5c36:	0f 4e       	mov	r14,	r15	;
    5c38:	49 18 0f 5f 	rpt #10 { rlax.w	r15		;

00005c3c <.Loc.602.1>:
        (uartp->config->stop_bits << 11) |
    5c3c:	0d df       	bis	r15,	r13	;

00005c3e <.Loc.603.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5c3e:	48 18 0e 5e 	rpt #9 { rlax.w	r14		;
    5c42:	0d de       	bis	r14,	r13	;

00005c44 <.Loc.599.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5c44:	3d d0 b0 00 	bis	#176,	r13	;#0x00b0
    5c48:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5c4c:	80 00 6e 5b 	mova	#23406,	r0	;0x05b6e

00005c50 <uart_lld_start_send>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    5c50:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005c52 <.LCFI13>:
    5c52:	ca 0c       	mova	r12,	r10	;

00005c54 <.Loc.667.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    5c54:	7c 0e 1a 00 	mova	r14,	26(r12)	; 0x0001a

00005c58 <.Loc.668.1>:
  uartp->dmareq_tx.size = n;
    5c58:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

00005c5c <.L114>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    5c5c:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5c60:	40 18 ac b3 	bitx.w	#2,	28(r12)	;r3 As==10, 0x0001c
    5c64:	1c 00 
    5c66:	fa 27       	jz	$-10     	;abs 0x5c5c

00005c68 <.Loc.671.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    5c68:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

00005c6c <.Loc.673.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    5c6c:	ce 0a       	mova	r10,	r14	;

00005c6e <.LVL154>:
    5c6e:	ae 00 62 00 	adda	#98,	r14	;0x00062
    5c72:	cd 0a       	mova	r10,	r13	;

00005c74 <.LVL155>:
    5c74:	ad 00 1a 00 	adda	#26,	r13	;0x0001a
    5c78:	cc 0a       	mova	r10,	r12	;
    5c7a:	ac 00 4e 00 	adda	#78,	r12	;0x0004e
    5c7e:	b0 13 4a 5a 	calla	#23114		;0x05a4a

00005c82 <.LVL156>:
  
  uartp->regs->ifg |= UCTXIFG;
    5c82:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5c86:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00005c8a <.Loc.676.1>:
}
    5c8a:	0a 16       	popm.a	#1,	r10	;20-bit words
    5c8c:	10 01       	reta			;

00005c8e <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    5c8e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005c90 <.LCFI16>:
    5c90:	ca 0c       	mova	r12,	r10	;

00005c92 <.Loc.720.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    5c92:	7c 0e 38 00 	mova	r14,	56(r12)	; 0x00038

00005c96 <.Loc.721.1>:
  uartp->dmareq_rx.size = n;
    5c96:	8c 4d 3c 00 	mov	r13,	60(r12)	; 0x003c

00005c9a <.Loc.724.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    5c9a:	3c 0c 16 00 	mova	22(r12),r12	;0x00016

00005c9e <.LVL162>:
    5c9e:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00005ca2 <.Loc.726.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    5ca2:	ce 0a       	mova	r10,	r14	;

00005ca4 <.LVL163>:
    5ca4:	ae 00 63 00 	adda	#99,	r14	;0x00063
    5ca8:	cd 0a       	mova	r10,	r13	;

00005caa <.LVL164>:
    5caa:	ad 00 34 00 	adda	#52,	r13	;0x00034
    5cae:	cc 0a       	mova	r10,	r12	;
    5cb0:	ac 00 58 00 	adda	#88,	r12	;0x00058
    5cb4:	b0 13 4a 5a 	calla	#23114		;0x05a4a

00005cb8 <.LVL165>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    5cb8:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5cbc:	40 18 9c b3 	bitx.w	#1,	28(r12)	;r3 As==01, 0x0001c
    5cc0:	1c 00 
    5cc2:	06 24       	jz	$+14     	;abs 0x5cd0

00005cc4 <.Loc.730.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    5cc4:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005cc8 <.Loc.731.1>:
    uartp->regs->ifg |= UCRXIFG;
    5cc8:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5ccc:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00005cd0 <.L118>:
  }
}
    5cd0:	0a 16       	popm.a	#1,	r10	;20-bit words
    5cd2:	10 01       	reta			;

00005cd4 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    5cd4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005cd6 <.LCFI17>:
    5cd6:	08 14       	pushm.a	#1,	r8	;20-bit words

00005cd8 <.LCFI18>:
    5cd8:	06 14       	pushm.a	#1,	r6	;20-bit words

00005cda <.LCFI19>:
    5cda:	ca 0c       	mova	r12,	r10	;

00005cdc <.Loc.748.1>:

  size_t result = uartp->dma_rx.registers->sz;
    5cdc:	3c 0c 58 00 	mova	88(r12),r12	;0x00058

00005ce0 <.LVL167>:
    5ce0:	40 18 18 4c 	movx.w	10(r12),r8	;0x0000a
    5ce4:	0a 00 

00005ce6 <.Loc.749.1>:
  dmaCancelI(&(uartp->dma_rx));
    5ce6:	c6 0a       	mova	r10,	r6	;
    5ce8:	a6 00 58 00 	adda	#88,	r6	;0x00058
    5cec:	cc 06       	mova	r6,	r12	;
    5cee:	b0 13 24 56 	calla	#22052		;0x05624

00005cf2 <.LVL169>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  if (uartp->config->dmarx_index >= MSP430X_DMA_CHANNELS) {
    5cf2:	3c 0a 04 00 	mova	4(r10),	r12	;
    5cf6:	7d 40 2f 00 	mov.b	#47,	r13	;#0x002f
    5cfa:	5d 9c 19 00 	cmp.b	25(r12),r13	;0x00019
    5cfe:	0d 28       	jnc	$+28     	;abs 0x5d1a

00005d00 <.L121>:
#else
  dmaReleaseX(&(uartp->dma_rx));
  uartp->dma_acquired_rx = false;
#endif
  
  uartp->regs->ifg &= ~UCRXIFG;
    5d00:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5d04:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005d08 <.Loc.761.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    5d08:	3c 0a 16 00 	mova	22(r10),r12	;0x00016
    5d0c:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005d10 <.Loc.764.1>:

  return result;
}
    5d10:	cc 08       	mova	r8,	r12	;
    5d12:	06 16       	popm.a	#1,	r6	;20-bit words
    5d14:	08 16       	popm.a	#1,	r8	;20-bit words
    5d16:	0a 16       	popm.a	#1,	r10	;20-bit words
    5d18:	10 01       	reta			;

00005d1a <.L122>:
    dmaReleaseX(&(uartp->dma_rx));
    5d1a:	cc 06       	mova	r6,	r12	;
    5d1c:	b0 13 d6 55 	calla	#21974		;0x055d6

00005d20 <.LVL170>:
    uartp->dma_acquired_rx = false;
    5d20:	ca 43 63 00 	mov.b	#0,	99(r10)	;r3 As==00, 0x0063
    5d24:	80 00 00 5d 	mova	#23808,	r0	;0x05d00

00005d28 <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    5d28:	8c 01 52 06 	mova	#67154,	r12	;0x10652
    5d2c:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    5d30:	80 03 06 00 

00005d34 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    5d34:	b0 13 b6 50 	calla	#20662		;0x050b6

00005d38 <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    5d38:	10 01       	reta			;

00005d3a <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    5d3a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005d3c <.LCFI0>:
    5d3c:	ca 0c       	mova	r12,	r10	;

00005d3e <.LVL2>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    5d3e:	9c 01 52 06 	cmpa	#67154,	r12	;0x10652
    5d42:	29 24       	jz	$+84     	;abs 0x5d96

00005d44 <.Loc.286.1>:
  uint32_t divider = 0;
    5d44:	48 43       	clr.b	r8		;
    5d46:	49 43       	clr.b	r9		;

00005d48 <.L3>:
    
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5d48:	09 93       	cmp	#0,	r9	;r3 As==00
    5d4a:	3c 20       	jnz	$+122    	;abs 0x5dc4
    5d4c:	09 93       	cmp	#0,	r9	;r3 As==00
    5d4e:	36 24       	jz	$+110    	;abs 0x5dbc

00005d50 <.L4>:
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    5d50:	0c 48       	mov	r8,	r12	;
    5d52:	7c f0 07 00 	and.b	#7,	r12	;
    5d56:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d58:	3b 20       	jnz	$+120    	;abs 0x5dd0

00005d5a <.Loc.345.1>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    5d5a:	3c 0a 06 00 	mova	6(r10),	r12	;
    5d5e:	bc d0 c0 00 	bis	#192,	0(r12)	;#0x00c0
    5d62:	00 00 

00005d64 <.Loc.346.1>:
    divider /= 8;
    5d64:	0c 48       	mov	r8,	r12	;
    5d66:	0d 49       	mov	r9,	r13	;
    5d68:	b0 13 b0 9f 	calla	#40880		;0x09fb0
    5d6c:	08 4c       	mov	r12,	r8	;

00005d6e <.LVL5>:
    5d6e:	09 4d       	mov	r13,	r9	;

00005d70 <.L7>:
  }
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
    5d70:	09 93       	cmp	#0,	r9	;r3 As==00
    5d72:	05 20       	jnz	$+12     	;abs 0x5d7e
    5d74:	09 93       	cmp	#0,	r9	;r3 As==00
    5d76:	07 20       	jnz	$+16     	;abs 0x5d86
    5d78:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5d7a:	0d 98       	cmp	r8,	r13	;
    5d7c:	04 2c       	jc	$+10     	;abs 0x5d86

00005d7e <.L13>:
    5d7e:	8c 01 f0 02 	mova	#66288,	r12	;0x102f0
    5d82:	b0 13 a0 47 	calla	#18336		;0x047a0

00005d86 <.L9>:
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    5d86:	3c 0a 06 00 	mova	6(r10),	r12	;
    5d8a:	0d 48       	mov	r8,	r13	;
    5d8c:	3d 53       	add	#-1,	r13	;r3 As==11
    5d8e:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

00005d92 <.Loc.359.1>:

}
    5d92:	28 16       	popm.a	#3,	r10	;20-bit words
    5d94:	10 01       	reta			;

00005d96 <.L14>:
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    5d96:	3c 0c 06 00 	mova	6(r12),	r12	;
    5d9a:	bc 40 04 01 	mov	#260,	0(r12)	;#0x0104
    5d9e:	00 00 

00005da0 <.Loc.304.1>:
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    5da0:	3c 0a 02 00 	mova	2(r10),	r12	;
    5da4:	2e 4c       	mov	@r12,	r14	;
    5da6:	1f 4c 02 00 	mov	2(r12),	r15	;
    5daa:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    5dae:	4d 43       	clr.b	r13		;
    5db0:	b0 13 98 9e 	calla	#40600		;0x09e98
    5db4:	08 4c       	mov	r12,	r8	;
    5db6:	09 4d       	mov	r13,	r9	;

00005db8 <.LVL10>:
    5db8:	80 00 48 5d 	mova	#23880,	r0	;0x05d48

00005dbc <.L15>:
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
    5dbc:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    5dc0:	0c 98       	cmp	r8,	r12	;
    5dc2:	c6 2f       	jc	$-114    	;abs 0x5d50

00005dc4 <.L12>:
    5dc4:	8c 01 f0 02 	mova	#66288,	r12	;0x102f0
    5dc8:	b0 13 a0 47 	calla	#18336		;0x047a0

00005dcc <.LVL11>:
    5dcc:	80 00 50 5d 	mova	#23888,	r0	;0x05d50

00005dd0 <.L6>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    5dd0:	0c 48       	mov	r8,	r12	;
    5dd2:	7c f0 03 00 	and.b	#3,	r12	;
    5dd6:	0c 93       	cmp	#0,	r12	;r3 As==00
    5dd8:	0d 20       	jnz	$+28     	;abs 0x5df4

00005dda <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    5dda:	3c 0a 06 00 	mova	6(r10),	r12	;
    5dde:	bc d0 80 00 	bis	#128,	0(r12)	;#0x0080
    5de2:	00 00 

00005de4 <.Loc.350.1>:
    divider /= 4;
    5de4:	40 19 09 10 	rrux.w	r9		;
    5de8:	08 10       	rrc	r8		;
    5dea:	40 19 09 10 	rrux.w	r9		;
    5dee:	08 10       	rrc	r8		;
    5df0:	80 00 70 5d 	mova	#23920,	r0	;0x05d70

00005df4 <.L8>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    5df4:	0c 48       	mov	r8,	r12	;
    5df6:	5c f3       	and.b	#1,	r12	;r3 As==01
    5df8:	0c 93       	cmp	#0,	r12	;r3 As==00
    5dfa:	ba 23       	jnz	$-138    	;abs 0x5d70

00005dfc <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    5dfc:	3c 0a 06 00 	mova	6(r10),	r12	;
    5e00:	bc d0 40 00 	bis	#64,	0(r12)	;#0x0040
    5e04:	00 00 

00005e06 <.Loc.354.1>:
    divider /= 2;
    5e06:	12 c3       	clrc			
    5e08:	09 10       	rrc	r9		;
    5e0a:	08 10       	rrc	r8		;
    5e0c:	80 00 70 5d 	mova	#23920,	r0	;0x05d70

00005e10 <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    5e10:	3e 0c 02 00 	mova	2(r12),	r14	;
    5e14:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    5e18:	04 00 
    5e1a:	04 24       	jz	$+10     	;abs 0x5e24

00005e1c <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    5e1c:	3e 0c 06 00 	mova	6(r12),	r14	;
    5e20:	ae d3 00 00 	bis	#2,	0(r14)	;r3 As==10

00005e24 <.L20>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
    5e24:	3e 0c 06 00 	mova	6(r12),	r14	;
    5e28:	ae d2 00 00 	bis	#4,	0(r14)	;r2 As==10

00005e2c <.Loc.395.1>:
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    5e2c:	3e 0c 06 00 	mova	6(r12),	r14	;
    5e30:	8e 4d 12 00 	mov	r13,	18(r14)	; 0x0012

00005e34 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    5e34:	3c 0c 06 00 	mova	6(r12),	r12	;

00005e38 <.LVL19>:
    5e38:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    5e3c:	00 00 

00005e3e <.Loc.398.1>:
}
    5e3e:	10 01       	reta			;

00005e40 <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    5e40:	3c 0c 06 00 	mova	6(r12),	r12	;

00005e44 <.LVL21>:
    5e44:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    5e48:	00 00 

00005e4a <.Loc.412.1>:

}
    5e4a:	10 01       	reta			;

00005e4c <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    5e4c:	32 c2       	dint			
    5e4e:	03 43       	nop			

00005e50 <.Loc.46.1>:

}
    5e50:	10 01       	reta			;

00005e52 <send_complete_cb>:
  chEvtSignalI(uart_thd, UARTRxBufferReady);
}

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
    5e52:	b0 13 92 45 	calla	#17810		;0x04592

00005e56 <.LVL1>:
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    5e56:	00 18 c2 43 	movx.a	#0,	&0xfad3a;r3 As==00
    5e5a:	3a ad 

00005e5c <.Loc.57.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    5e5c:	40 18 f2 d0 	bisx.b	#3,	&0xfd38a;
    5e60:	03 00 8a d3 

00005e64 <.LBB28>:
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
    5e64:	b0 13 24 46 	calla	#17956		;0x04624

00005e68 <.LVL3>:

  return chSemGetCounterI(&mbp->fullsem);
    5e68:	40 18 1c 42 	movx.w	&0x0ad4e,r12	;
    5e6c:	4e ad 

00005e6e <.LBE28>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    5e6e:	4d 43       	clr.b	r13		;
    5e70:	0d 9c       	cmp	r12,	r13	;
    5e72:	06 34       	jge	$+14     	;abs 0x5e80

00005e74 <.Loc.60.1>:
    events |= UARTBufferPosted;
    5e74:	40 18 a2 d3 	bisx.w	#2,	&0xfd386;r3 As==10
    5e78:	86 d3 
    5e7a:	40 18 82 dd 	bisx.w	r13,	&0xfd388;
    5e7e:	88 d3 

00005e80 <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    5e80:	2c 00 82 d3 	mova	&54146,	r12	;0x0d382
    5e84:	cc 93 04 00 	cmp.b	#0,	4(r12)	;r3 As==00
    5e88:	03 20       	jnz	$+8      	;abs 0x5e90

00005e8a <.L3>:
    chSchReadyI(uart_thd, MSG_RESET);
  }
  chSysUnlockFromISR();
    5e8a:	b0 13 b4 45 	calla	#17844		;0x045b4

00005e8e <.LVL5>:
}
    5e8e:	10 01       	reta			;

00005e90 <.L4>:
    chSchReadyI(uart_thd, MSG_RESET);
    5e90:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    5e94:	b0 13 7c 48 	calla	#18556		;0x0487c

00005e98 <.LVL6>:
    5e98:	80 00 8a 5e 	mova	#24202,	r0	;0x05e8a

00005e9c <elyUARTCfgMarkDirty>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    5e9c:	01 18 d2 92 	cmpx.a	&0x0d382,&0x1051e;
    5ea0:	82 d3 1e 05 
    5ea4:	07 24       	jz	$+16     	;abs 0x5eb4

00005ea6 <.L9>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    5ea6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5ea8:	4e 43       	clr.b	r14		;
    5eaa:	2c 00 82 d3 	mova	&54146,	r12	;0x0d382
    5eae:	b0 13 aa 4a 	calla	#19114		;0x04aaa

00005eb2 <.LVL9>:
}
    5eb2:	10 01       	reta			;

00005eb4 <.L10>:
  chDbgAssert(chThdGetSelfX() != uart_thd, "can't set your own config dirty");
    5eb4:	8c 01 29 03 	mova	#66345,	r12	;0x10329
    5eb8:	b0 13 a0 47 	calla	#18336		;0x047a0

00005ebc <.LVL10>:
    5ebc:	80 00 a6 5e 	mova	#24230,	r0	;0x05ea6

00005ec0 <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    5ec0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005ec2 <.LCFI0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    5ec2:	cd 0c       	mova	r12,	r13	;
    5ec4:	8c 00 3e ad 	mova	#44350,	r12	;0x0ad3e

00005ec8 <.LVL12>:
    5ec8:	b0 13 5a 4c 	calla	#19546		;0x04c5a

00005ecc <.LVL13>:
    5ecc:	ca 0c       	mova	r12,	r10	;

00005ece <.Loc.26.1>:
  if (MSG_OK == msg) {
    5ece:	9c 00 00 00 	cmpa	#0,	r12	;
    5ed2:	07 24       	jz	$+16     	;abs 0x5ee2

00005ed4 <.Loc.32.1>:
    chDbgAssert(false, "an error");
    5ed4:	8c 01 1c 03 	mova	#66332,	r12	;0x1031c
    5ed8:	b0 13 a0 47 	calla	#18336		;0x047a0

00005edc <.L11>:
}
    5edc:	cc 0a       	mova	r10,	r12	;
    5ede:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ee0:	10 01       	reta			;

00005ee2 <.L14>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    5ee2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5ee4:	4e 43       	clr.b	r14		;
    5ee6:	2c 00 82 d3 	mova	&54146,	r12	;0x0d382
    5eea:	b0 13 da 4a 	calla	#19162		;0x04ada

00005eee <.LVL16>:
    5eee:	80 00 dc 5e 	mova	#24284,	r0	;0x05edc

00005ef2 <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    5ef2:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005ef4 <.LCFI1>:
    5ef4:	ca 0c       	mova	r12,	r10	;
    5ef6:	09 4d       	mov	r13,	r9	;

00005ef8 <.LBB30>:
  _disable_interrupts();
    5ef8:	32 c2       	dint			
    5efa:	03 43       	nop			

00005efc <.Loc.348.3>:
  asm volatile("nop");
    5efc:	03 43       	nop			

00005efe <.LBE30>:
  chSysLock();
    5efe:	b0 13 50 45 	calla	#17744		;0x04550

00005f02 <.LVL18>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    5f02:	0e 49       	mov	r9,	r14	;
    5f04:	cd 0a       	mova	r10,	r13	;
    5f06:	8c 00 3e ad 	mova	#44350,	r12	;0x0ad3e
    5f0a:	b0 13 ba 4b 	calla	#19386		;0x04bba

00005f0e <.LVL19>:
    5f0e:	ca 0c       	mova	r12,	r10	;

00005f10 <.LVL20>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    5f10:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5f12:	4e 43       	clr.b	r14		;
    5f14:	2c 00 82 d3 	mova	&54146,	r12	;0x0d382
    5f18:	b0 13 da 4a 	calla	#19162		;0x04ada

00005f1c <.LVL21>:
  chSysUnlock();
    5f1c:	b0 13 70 45 	calla	#17776		;0x04570

00005f20 <.LBB32>:
  asm volatile("nop");
    5f20:	03 43       	nop			

00005f22 <.Loc.356.3>:
  _enable_interrupts();
    5f22:	03 43       	nop			
    5f24:	32 d2       	eint			
    5f26:	03 43       	nop			

00005f28 <.LBE32>:
}
    5f28:	cc 0a       	mova	r10,	r12	;
    5f2a:	19 16       	popm.a	#2,	r10	;20-bit words
    5f2c:	10 01       	reta			;

00005f2e <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 256);
THD_FUNCTION(UARTThd, arg) {
    5f2e:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005f30 <.LCFI2>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    5f30:	80 18 d2 42 	movx.a	&0x1051e,&0xfd382;
    5f34:	1e 05 82 d3 

00005f38 <.Loc.99.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    5f38:	40 18 f2 40 	movx.b	#7,	&0xfd38a;
    5f3c:	07 00 8a d3 

00005f40 <.LBB34>:
  _disable_interrupts();
    5f40:	32 c2       	dint			
    5f42:	03 43       	nop			

00005f44 <.Loc.348.3>:
  asm volatile("nop");
    5f44:	03 43       	nop			

00005f46 <.LBE34>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    5f46:	b0 13 50 45 	calla	#17744		;0x04550

00005f4a <.LVL25>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    5f4a:	00 18 c2 93 	cmpx.a	#0,	&0xfad3a;r3 As==00
    5f4e:	3a ad 
    5f50:	1e 24       	jz	$+62     	;abs 0x5f8e

00005f52 <.L18>:
    events |= UARTBufferPosted;
    5f52:	40 18 a2 d3 	bisx.w	#2,	&0xfd386;r3 As==10
    5f56:	86 d3 
    5f58:	40 18 82 d3 	bisx.w	#0,	&0xfd388;r3 As==00
    5f5c:	88 d3 

00005f5e <.L19>:
  }
  chSysUnlock();
    5f5e:	b0 13 70 45 	calla	#17776		;0x04570

00005f62 <.LBB36>:
  asm volatile("nop");
    5f62:	03 43       	nop			

00005f64 <.Loc.356.3>:
  _enable_interrupts();
    5f64:	03 43       	nop			
    5f66:	32 d2       	eint			
    5f68:	03 43       	nop			

00005f6a <.LBE36>:
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    5f6a:	40 18 92 d3 	bisx.w	#1,	&0xfd386;r3 As==01
    5f6e:	86 d3 
    5f70:	40 18 82 d3 	bisx.w	#0,	&0xfd388;r3 As==00
    5f74:	88 d3 

00005f76 <.Loc.112.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    5f76:	8d 01 52 03 	mova	#66386,	r13	;0x10352
    5f7a:	8c 01 52 06 	mova	#67154,	r12	;0x10652
    5f7e:	b0 13 c2 50 	calla	#20674		;0x050c2

00005f82 <.LVL27>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    5f82:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    5f86:	b0 13 6e 95 	calla	#38254		;0x0956e

00005f8a <.LVL28>:
    5f8a:	80 00 9e 60 	mova	#24734,	r0	;0x0609e

00005f8e <.L30>:
  chDbgCheckClassI();
    5f8e:	b0 13 24 46 	calla	#17956		;0x04624

00005f92 <.LVL30>:
  return chSemGetCounterI(&mbp->fullsem);
    5f92:	40 18 1c 42 	movx.w	&0x0ad4e,r12	;
    5f96:	4e ad 

00005f98 <.LBE38>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    5f98:	4d 43       	clr.b	r13		;
    5f9a:	0d 9c       	cmp	r12,	r13	;
    5f9c:	da 3b       	jl	$-74     	;abs 0x5f52
    5f9e:	80 00 5e 5f 	mova	#24414,	r0	;0x05f5e

00005fa2 <.L32>:
  _disable_interrupts();
    5fa2:	32 c2       	dint			
    5fa4:	03 43       	nop			

00005fa6 <.Loc.348.3>:
  asm volatile("nop");
    5fa6:	03 43       	nop			

00005fa8 <.LBE40>:
  
  msg_t result;
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
    5fa8:	b0 13 50 45 	calla	#17744		;0x04550

00005fac <.LVL32>:
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    5fac:	2a 01 3e 04 	mova	&66622,	r10	;0x1043e
    5fb0:	5c 4a 26 00 	mov.b	38(r10),r12	;0x00026
    5fb4:	8e 00 38 ad 	mova	#44344,	r14	;0x0ad38
    5fb8:	4f 4c       	mov.b	r12,	r15	;
    5fba:	7f f0 03 00 	and.b	#3,	r15	;
    5fbe:	6d 4e       	mov.b	@r14,	r13	;
    5fc0:	7d f0 fc ff 	and.b	#-4,	r13	;#0xfffc
    5fc4:	4d df       	bis.b	r15,	r13	;

00005fc6 <.Loc.125.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    5fc6:	0f 4c       	mov	r12,	r15	;
    5fc8:	5f 07       	rrum	#2,	r15	;
    5fca:	5f f3       	and.b	#1,	r15	;r3 As==01
    5fcc:	43 18 0f 5f 	rpt #4 { rlax.w	r15		;
    5fd0:	7d f0 ef ff 	and.b	#-17,	r13	;#0xffef
    5fd4:	4d df       	bis.b	r15,	r13	;

00005fd6 <.Loc.127.1>:
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    5fd6:	5c 0b       	rrum	#3,	r12	;
    5fd8:	5c f3       	and.b	#1,	r12	;r3 As==01
    5fda:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    5fde:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    5fe2:	4d dc       	bis.b	r12,	r13	;
    5fe4:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00005fe8 <.Loc.129.1>:
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    5fe8:	58 4a 22 00 	mov.b	34(r10),r8	;0x00022
    5fec:	09 43       	clr	r9		;

00005fee <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    5fee:	5c 4a 23 00 	mov.b	35(r10),r12	;0x00023
    5ff2:	0d 43       	clr	r13		;
    5ff4:	b0 13 f0 9e 	calla	#40688		;0x09ef0
    5ff8:	09 4d       	mov	r13,	r9	;

00005ffa <.Loc.129.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    5ffa:	08 dc       	bis	r12,	r8	;

00005ffc <.Loc.131.1>:
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    5ffc:	5c 4a 24 00 	mov.b	36(r10),r12	;0x00024
    6000:	0d 43       	clr	r13		;
    6002:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6006:	b0 13 18 9f 	calla	#40728		;0x09f18

0000600a <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
    600a:	08 dc       	bis	r12,	r8	;
    600c:	09 dd       	bis	r13,	r9	;

0000600e <.Loc.132.1>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
    600e:	5c 4a 25 00 	mov.b	37(r10),r12	;0x00025
    6012:	0d 43       	clr	r13		;
    6014:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    6018:	b0 13 18 9f 	calla	#40728		;0x09f18

0000601c <.Loc.129.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    601c:	8a 00 20 ad 	mova	#44320,	r10	;0x0ad20
    6020:	08 dc       	bis	r12,	r8	;
    6022:	8a 48 14 00 	mov	r8,	20(r10)	; 0x0014
    6026:	09 dd       	bis	r13,	r9	;
    6028:	8a 49 16 00 	mov	r9,	22(r10)	; 0x0016

0000602c <.Loc.134.1>:
      
      chSysUnlock();
    602c:	b0 13 70 45 	calla	#17776		;0x04570

00006030 <.LBB42>:
  asm volatile("nop");
    6030:	03 43       	nop			

00006032 <.Loc.356.3>:
  _enable_interrupts();
    6032:	03 43       	nop			
    6034:	32 d2       	eint			
    6036:	03 43       	nop			

00006038 <.LBE42>:
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    6038:	cd 0a       	mova	r10,	r13	;
    603a:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    603e:	b0 13 e0 51 	calla	#20960		;0x051e0

00006042 <.LVL37>:
      events &= ~UARTConfigUpdated;
    6042:	40 18 92 c3 	bicx.w	#1,	&0xfd386;r3 As==01
    6046:	86 d3 
    6048:	40 18 82 c3 	bicx.w	#0,	&0xfd388;r3 As==00
    604c:	88 d3 
    604e:	80 00 a6 60 	mova	#24742,	r0	;0x060a6

00006052 <.L26>:
          events &= ~UARTBufferPosted;
          chSysUnlock();
          /* Skip to the next loop */
          continue;
        }
        chSysUnlock();
    6052:	b0 13 70 45 	calla	#17776		;0x04570

00006056 <.LBB44>:
  asm volatile("nop");
    6056:	03 43       	nop			

00006058 <.Loc.356.3>:
  _enable_interrupts();
    6058:	03 43       	nop			
    605a:	32 d2       	eint			
    605c:	03 43       	nop			

0000605e <.L25>:
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    605e:	2d 00 3a ad 	mova	&44346,	r13	;0x0ad3a
    6062:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    6066:	b0 13 b4 94 	calla	#38068		;0x094b4

0000606a <.LVL40>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    606a:	c0 1f f2 f0 	andx.b	#-4,	&0xfd38a;0xffffc
    606e:	fc ff 8a d3 

00006072 <.Loc.159.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    6072:	40 18 a2 c3 	bicx.w	#2,	&0xfd386;r3 As==10
    6076:	86 d3 
    6078:	40 18 82 c3 	bicx.w	#0,	&0xfd388;r3 As==00
    607c:	88 d3 

0000607e <.L23>:
    }
    if (events & UARTRxBufferReady) {
    607e:	40 18 e2 b2 	bitx.b	#4,	&0xfd386;r2 As==10
    6082:	86 d3 
    6084:	35 20       	jnz	$+108    	;abs 0x60f0

00006086 <.L28>:
      
      elyUARTDLLRxHandleBuffer();
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    }
    /* Get next events */
    events |= chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    6086:	4e 43       	clr.b	r14		;
    6088:	5c 42 8a d3 	mov.b	&0xd38a,r12	;0xd38a
    608c:	0d 43       	clr	r13		;
    608e:	b0 13 2e 4b 	calla	#19246		;0x04b2e

00006092 <.LVL41>:
    6092:	40 18 82 dc 	bisx.w	r12,	&0xfd386;
    6096:	86 d3 
    6098:	40 18 82 dd 	bisx.w	r13,	&0xfd388;
    609c:	88 d3 

0000609e <.L20>:
    if (events & UARTConfigUpdated) {
    609e:	40 18 d2 b3 	bitx.b	#1,	&0xfd386;r3 As==01
    60a2:	86 d3 
    60a4:	7e 23       	jnz	$-258    	;abs 0x5fa2

000060a6 <.L21>:
    if (events & UARTBufferPosted) {
    60a6:	40 18 e2 b3 	bitx.b	#2,	&0xfd386;r3 As==10
    60aa:	86 d3 
    60ac:	e8 27       	jz	$-46     	;abs 0x607e

000060ae <.Loc.140.1>:
      if (NULL == tx_active_buffer) {
    60ae:	00 18 c2 93 	cmpx.a	#0,	&0xfad3a;r3 As==00
    60b2:	3a ad 
    60b4:	d4 23       	jnz	$-86     	;abs 0x605e

000060b6 <.LBB46>:
  _disable_interrupts();
    60b6:	32 c2       	dint			
    60b8:	03 43       	nop			

000060ba <.Loc.348.3>:
  asm volatile("nop");
    60ba:	03 43       	nop			

000060bc <.LBE46>:
        chSysLock();
    60bc:	b0 13 50 45 	calla	#17744		;0x04550

000060c0 <.LVL42>:
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    60c0:	3e 43       	mov	#-1,	r14	;r3 As==11
    60c2:	8d 00 3a ad 	mova	#44346,	r13	;0x0ad3a
    60c6:	8c 00 3e ad 	mova	#44350,	r12	;0x0ad3e
    60ca:	b0 13 c2 4c 	calla	#19650		;0x04cc2

000060ce <.LVL43>:
        if (result != MSG_OK) {
    60ce:	9c 00 00 00 	cmpa	#0,	r12	;
    60d2:	bf 27       	jz	$-128    	;abs 0x6052

000060d4 <.Loc.145.1>:
          events &= ~UARTBufferPosted;
    60d4:	40 18 a2 c3 	bicx.w	#2,	&0xfd386;r3 As==10
    60d8:	86 d3 
    60da:	40 18 82 c3 	bicx.w	#0,	&0xfd388;r3 As==00
    60de:	88 d3 

000060e0 <.Loc.146.1>:
          chSysUnlock();
    60e0:	b0 13 70 45 	calla	#17776		;0x04570

000060e4 <.LBB48>:
  asm volatile("nop");
    60e4:	03 43       	nop			

000060e6 <.Loc.356.3>:
  _enable_interrupts();
    60e6:	03 43       	nop			
    60e8:	32 d2       	eint			
    60ea:	03 43       	nop			

000060ec <.LBE48>:
          continue;
    60ec:	80 00 9e 60 	mova	#24734,	r0	;0x0609e

000060f0 <.L31>:
      elyUARTDLLRxHandleBuffer();
    60f0:	b0 13 78 95 	calla	#38264		;0x09578

000060f4 <.LVL45>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    60f4:	40 18 a2 c2 	bicx.w	#4,	&0xfd386;r2 As==10
    60f8:	86 d3 
    60fa:	40 18 82 c3 	bicx.w	#0,	&0xfd388;r3 As==00
    60fe:	88 d3 
    6100:	80 00 86 60 	mova	#24710,	r0	;0x06086

00006104 <fw_allocator>:

#include "main.h"

static uint8_t PERSIST fw_storage[elyFWTotalBuffer];

void * fw_allocator(size_t size, unsigned align) {
    6104:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006106 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyFWTotalBuffer) {
    6106:	2e 00 8e ad 	mova	&44430,	r14	;0x0ad8e
    610a:	ca 0e       	mova	r14,	r10	;
    610c:	ea 0c       	adda	r12,	r10	;
    610e:	3c 40 24 04 	mov	#1060,	r12	;#0x0424

00006112 <.LVL1>:
    6112:	dc 0a       	cmpa	r10,	r12	;
    6114:	07 28       	jnc	$+16     	;abs 0x6124

00006116 <.Loc.15.1>:
    return NULL;
  }

  void * result = fw_storage + curr_index;
    6116:	cc 0e       	mova	r14,	r12	;
    6118:	ac 00 92 ad 	adda	#44434,	r12	;0x0ad92

0000611c <.LVL2>:
  
  curr_index += size;
    611c:	60 0a 8e ad 	mova	r10,	&44430	; 0x0ad8e

00006120 <.L1>:
  return result;
}
    6120:	0a 16       	popm.a	#1,	r10	;20-bit words
    6122:	10 01       	reta			;

00006124 <.L3>:
    return NULL;
    6124:	4c 43       	clr.b	r12		;
    6126:	80 00 20 61 	mova	#24864,	r0	;0x06120

0000612a <elyFWGetBufferI>:

static PERSIST MEMORYPOOL_DECL(fw_mpool, elyFWBufferMaxSize, fw_allocator);
static SEMAPHORE_DECL(fw_sem, (cnt_t)(elyFWMaxSlots));

uint8_t * elyFWGetBufferI() {
  uint8_t * result =  chPoolAllocI(&fw_mpool);
    612a:	8c 00 82 ad 	mova	#44418,	r12	;0x0ad82
    612e:	b0 13 78 4e 	calla	#20088		;0x04e78

00006132 <.LVL4>:
  
  if (result == NULL) {
    6132:	9c 00 00 00 	cmpa	#0,	r12	;
    6136:	05 24       	jz	$+12     	;abs 0x6142

00006138 <.Loc.32.1>:
    return NULL;
  }
  
  /* semaphore must be >0 if we got a non-null result */
  chSemFastWaitI(&fw_sem);
    6138:	41 18 b2 53 	addx.w	#-1,	&0x10506;r3 As==11
    613c:	06 05 

0000613e <.Loc.33.1>:
  return elyNLToFW(result);
    613e:	b0 13 e0 9d 	calla	#40416		;0x09de0

00006142 <.L4>:
}
    6142:	10 01       	reta			;

00006144 <elyFWGetBuffer>:

uint8_t * elyFWGetBuffer() {
    6144:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006146 <.LBB10>:
  _disable_interrupts();
    6146:	32 c2       	dint			
    6148:	03 43       	nop			

0000614a <.Loc.348.2>:
  asm volatile("nop");
    614a:	03 43       	nop			

0000614c <.LBE10>:
  chSysLock();
    614c:	b0 13 50 45 	calla	#17744		;0x04550

00006150 <.LVL6>:
  uint8_t * result = elyFWGetBufferI();
    6150:	b0 13 2a 61 	calla	#24874		;0x0612a

00006154 <.LVL7>:
    6154:	ca 0c       	mova	r12,	r10	;

00006156 <.Loc.39.1>:
  chSysUnlock();
    6156:	b0 13 70 45 	calla	#17776		;0x04570

0000615a <.LBB12>:
  asm volatile("nop");
    615a:	03 43       	nop			

0000615c <.Loc.356.2>:
  _enable_interrupts();
    615c:	03 43       	nop			
    615e:	32 d2       	eint			
    6160:	03 43       	nop			

00006162 <.LBE12>:
  
  return result;
}
    6162:	cc 0a       	mova	r10,	r12	;
    6164:	0a 16       	popm.a	#1,	r10	;20-bit words
    6166:	10 01       	reta			;

00006168 <elyFWFreeBufferI>:
  chDbgAssert(NULL != result, "Guarded pool failure");
  return elyNLToFW(result);
}

void elyFWFreeBufferI(uint8_t * buffer) {
  chPoolFreeI(&fw_mpool, buffer);
    6168:	cd 0c       	mova	r12,	r13	;
    616a:	8c 00 82 ad 	mova	#44418,	r12	;0x0ad82

0000616e <.LVL22>:
    616e:	b0 13 e2 4e 	calla	#20194		;0x04ee2

00006172 <.LVL23>:
  chSemSignalI(&fw_sem);
    6172:	8c 01 06 05 	mova	#66822,	r12	;0x10506
    6176:	b0 13 4a 4a 	calla	#19018		;0x04a4a

0000617a <.LVL24>:
}
    617a:	10 01       	reta			;

0000617c <elyFWFreeBuffer>:

void elyFWFreeBuffer(uint8_t * buffer) {
    617c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000617e <.LCFI3>:
    617e:	ca 0c       	mova	r12,	r10	;

00006180 <.LBB14>:
  _disable_interrupts();
    6180:	32 c2       	dint			
    6182:	03 43       	nop			

00006184 <.Loc.348.2>:
  asm volatile("nop");
    6184:	03 43       	nop			

00006186 <.LBE14>:
  chSysLock();
    6186:	b0 13 50 45 	calla	#17744		;0x04550

0000618a <.LVL26>:
  elyFWFreeBufferI(buffer);
    618a:	cc 0a       	mova	r10,	r12	;
    618c:	b0 13 68 61 	calla	#24936		;0x06168

00006190 <.LVL27>:
  chSchRescheduleS();
    6190:	b0 13 30 49 	calla	#18736		;0x04930

00006194 <.LVL28>:
  chSysUnlock();
    6194:	b0 13 70 45 	calla	#17776		;0x04570

00006198 <.LBB16>:
  asm volatile("nop");
    6198:	03 43       	nop			

0000619a <.Loc.356.2>:
  _enable_interrupts();
    619a:	03 43       	nop			
    619c:	32 d2       	eint			
    619e:	03 43       	nop			

000061a0 <.LBE16>:
}
    61a0:	0a 16       	popm.a	#1,	r10	;20-bit words
    61a2:	10 01       	reta			;

000061a4 <reset>:
  
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLFromFW(buffer));
    61a4:	b0 13 ec 9d 	calla	#40428		;0x09dec

000061a8 <.LVL1>:
    61a8:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000061ac <.LVL2>:
  active_buffer = NULL; /* have to null before reset */
    61ac:	00 18 c2 43 	movx.a	#0,	&0xfd39e;r3 As==00
    61b0:	9e d3 

000061b2 <.Loc.168.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    61b2:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    61b6:	48 a5 20 01 

000061ba <.Loc.169.1>:
}
    61ba:	10 01       	reta			;

000061bc <write_success>:
static void write_success(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    61bc:	2d 4d       	mov	@r13,	r13	;

000061be <.Loc.35.1>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    61be:	0e 4d       	mov	r13,	r14	;
    61c0:	5e 07       	rrum	#2,	r14	;
    61c2:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    61c6:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

000061ca <.Loc.36.1>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    61ca:	2e 01 3e 04 	mova	&66622,	r14	;0x1043e
    61ce:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    61d2:	02 00 

000061d4 <.Loc.37.1>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    61d4:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    61d8:	03 00 

000061da <.Loc.38.1>:
  reply_buff[4] = 1;
    61da:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

000061de <.Loc.39.1>:
  if (hdr.crc) {
    61de:	1d b3       	bit	#1,	r13	;r3 As==01
    61e0:	03 20       	jnz	$+8      	;abs 0x61e8

000061e2 <.Loc.44.1>:
    reply_buff[1] = 1;
    61e2:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01

000061e6 <.L2>:
}
    61e6:	10 01       	reta			;

000061e8 <.L5>:
    reply_buff[1] = 3;
    61e8:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    61ec:	01 00 

000061ee <.Loc.41.1>:
    crcGenX25(reply_buff, 7);
    61ee:	7d 40 07 00 	mov.b	#7,	r13	;
    61f2:	b0 13 d2 97 	calla	#38866		;0x097d2

000061f6 <.LVL7>:
    61f6:	80 00 e6 61 	mova	#25062,	r0	;0x061e6

000061fa <write_failure>:
static void write_failure(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    61fa:	2d 4d       	mov	@r13,	r13	;

000061fc <.Loc.61.1>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    61fc:	0e 4d       	mov	r13,	r14	;
    61fe:	5e 07       	rrum	#2,	r14	;
    6200:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    6204:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

00006208 <.Loc.62.1>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    6208:	5d f3       	and.b	#1,	r13	;r3 As==01
    620a:	0d 93       	cmp	#0,	r13	;r3 As==00
    620c:	0e 24       	jz	$+30     	;abs 0x622a
    620e:	6e 43       	mov.b	#2,	r14	;r3 As==10

00006210 <.L7>:
    6210:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00006214 <.Loc.63.1>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    6214:	2e 01 3e 04 	mova	&66622,	r14	;0x1043e
    6218:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    621c:	02 00 

0000621e <.Loc.64.1>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    621e:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    6222:	03 00 

00006224 <.Loc.65.1>:
  if (hdr.crc) {
    6224:	0d 93       	cmp	#0,	r13	;r3 As==00
    6226:	04 20       	jnz	$+10     	;abs 0x6230

00006228 <.L6>:
}
    6228:	10 01       	reta			;

0000622a <.L9>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    622a:	4e 43       	clr.b	r14		;
    622c:	80 00 10 62 	mova	#25104,	r0	;0x06210

00006230 <.L10>:
    crcGenX25(reply_buff, 6);
    6230:	7d 40 06 00 	mov.b	#6,	r13	;
    6234:	b0 13 d2 97 	calla	#38866		;0x097d2

00006238 <.LVL12>:
}
    6238:	80 00 28 62 	mova	#25128,	r0	;0x06228

0000623c <store_telem>:
  elyFWFreeBufferI(elyNLFromFW(buff));
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    623c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000623e <.LCFI0>:
    623e:	b1 00 02 00 	suba	#2,	r1	;

00006242 <.LCFI1>:
    6242:	c7 0c       	mova	r12,	r7	;
    6244:	2a 4d       	mov	@r13,	r10	;

00006246 <.LVL14>:
    6246:	14 4d 02 00 	mov	2(r13),	r4	;

0000624a <.LVL15>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    624a:	4d 4a       	mov.b	r10,	r13	;
    624c:	4e 4d       	mov.b	r13,	r14	;
    624e:	6e f3       	and.b	#2,	r14	;r3 As==10
    6250:	46 4e       	mov.b	r14,	r6	;
    6252:	06 93       	cmp	#0,	r6	;r3 As==00
    6254:	4b 24       	jz	$+152    	;abs 0x62ec
    6256:	a1 42 00 00 	mov	#4,	0(r1)	;r2 As==10

0000625a <.L12>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    625a:	09 4a       	mov	r10,	r9	;
    625c:	59 0f       	rrum	#4,	r9	;
    625e:	59 0f       	rrum	#4,	r9	;
    6260:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    6264:	47 24       	jz	$+144    	;abs 0x62f4

00006266 <.Loc.1469.1>:
    6266:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006268 <.L13>:
    6268:	4d 5e       	add.b	r14,	r13	;
    626a:	49 8d       	sub.b	r13,	r9	;
    626c:	45 49       	mov.b	r9,	r5	;

0000626e <.LVL17>:
  
  uint8_t * reply_buff = elyFWGetBuffer();
    626e:	b0 13 44 61 	calla	#24900		;0x06144

00006272 <.LVL18>:
    6272:	c8 0c       	mova	r12,	r8	;

00006274 <.LVL19>:
  if (reply_buff == NULL) {
    6274:	9c 00 00 00 	cmpa	#0,	r12	;
    6278:	40 24       	jz	$+130    	;abs 0x62fa

0000627a <.Loc.1478.1>:
    /* TODO signal a buffer overflow here */
    elyNLFreeBuffer(elyNLFromFW(buffer));
    return;
  }
  
  memcpy(reply_buff + 5, buffer + hdr_ext, payload_len);
    627a:	40 18 2d 41 	movx.w	@r1,	r13	;
    627e:	40 18 09 49 	movx.w	r9,	r9	;

00006282 <.LVL20>:
    6282:	ce 09       	mova	r9,	r14	;
    6284:	ed 07       	adda	r7,	r13	;
    6286:	ac 00 05 00 	adda	#5,	r12	;
    628a:	b0 13 f4 9f 	calla	#40948		;0x09ff4

0000628e <.LVL21>:
  memset(reply_buff + 5 + payload_len, 0, 251 - payload_len);
    628e:	cc 09       	mova	r9,	r12	;
    6290:	ac 00 05 00 	adda	#5,	r12	;
    6294:	40 18 3e 40 	movx.w	#251,	r14	;0x000fb
    6298:	fb 00 
    629a:	40 18 0e 85 	subx.w	r5,	r14	;
    629e:	4e 0e       	rlam.a	#4,	r14	;
    62a0:	4e 0d       	rram.a	#4,	r14	;
    62a2:	4d 43       	clr.b	r13		;
    62a4:	ec 08       	adda	r8,	r12	;
    62a6:	b0 13 12 a0 	calla	#40978		;0x0a012

000062aa <.LVL22>:
  telem_stored_hdr = hdr;
    62aa:	40 18 82 4a 	movx.w	r10,	&0xfd392;
    62ae:	92 d3 
    62b0:	40 18 82 44 	movx.w	r4,	&0xfd394;
    62b4:	94 d3 

000062b6 <.Loc.1482.1>:
  
  elyNLFreeBuffer(elyNLFromFW(buffer));
    62b6:	cc 07       	mova	r7,	r12	;
    62b8:	b0 13 ec 9d 	calla	#40428		;0x09dec

000062bc <.LVL23>:
    62bc:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000062c0 <.LBB79>:
  _disable_interrupts();
    62c0:	32 c2       	dint			
    62c2:	03 43       	nop			

000062c4 <.Loc.348.2>:
  asm volatile("nop");
    62c4:	03 43       	nop			

000062c6 <.LBE79>:

  chSysLock();
    62c6:	b0 13 50 45 	calla	#17744		;0x04550

000062ca <.LVL25>:
  elyTelemPostBufferS(reply_buff, 
    62ca:	06 93       	cmp	#0,	r6	;r3 As==00
    62cc:	1d 24       	jz	$+60     	;abs 0x6308
    62ce:	8d 00 4c 68 	mova	#26700,	r13	;0x0684c

000062d2 <.L16>:
    62d2:	cc 08       	mova	r8,	r12	;
    62d4:	b0 13 20 97 	calla	#38688		;0x09720

000062d8 <.LVL26>:
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
    62d8:	b0 13 70 45 	calla	#17776		;0x04570

000062dc <.LBB81>:
  asm volatile("nop");
    62dc:	03 43       	nop			

000062de <.Loc.356.2>:
  _enable_interrupts();
    62de:	03 43       	nop			
    62e0:	32 d2       	eint			
    62e2:	03 43       	nop			

000062e4 <.L11>:
  
  /* Reply is posted from callback if needed */
}
    62e4:	a1 00 02 00 	adda	#2,	r1	;

000062e8 <.LVL28>:
    62e8:	64 16       	popm.a	#7,	r10	;20-bit words
    62ea:	10 01       	reta			;

000062ec <.L17>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    62ec:	a1 43 00 00 	mov	#2,	0(r1)	;r3 As==10
    62f0:	80 00 5a 62 	mova	#25178,	r0	;0x0625a

000062f4 <.L18>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    62f4:	4d 43       	clr.b	r13		;
    62f6:	80 00 68 62 	mova	#25192,	r0	;0x06268

000062fa <.L20>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    62fa:	cc 07       	mova	r7,	r12	;
    62fc:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006300 <.LVL32>:
    6300:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006304 <.LVL33>:
    return;
    6304:	80 00 e4 62 	mova	#25316,	r0	;0x062e4

00006308 <.L19>:
  elyTelemPostBufferS(reply_buff, 
    6308:	8d 00 10 63 	mova	#25360,	r13	;0x06310
    630c:	80 00 d2 62 	mova	#25298,	r0	;0x062d2

00006310 <store_telem_noreply_cb>:
static void store_telem_noreply_cb(uint8_t * buff) {
    6310:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006312 <.LCFI2>:
    6312:	ca 0c       	mova	r12,	r10	;

00006314 <.Loc.1461.1>:
  chSysLockFromISR();
    6314:	b0 13 92 45 	calla	#17810		;0x04592

00006318 <.LVL36>:
  elyFWFreeBufferI(elyNLFromFW(buff));
    6318:	cc 0a       	mova	r10,	r12	;
    631a:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000631e <.LVL37>:
    631e:	b0 13 68 61 	calla	#24936		;0x06168

00006322 <.LVL38>:
  chSysUnlockFromISR();
    6322:	b0 13 b4 45 	calla	#17844		;0x045b4

00006326 <.LVL39>:
}
    6326:	0a 16       	popm.a	#1,	r10	;20-bit words
    6328:	10 01       	reta			;

0000632a <upload_fw_noreply_cb>:
static void upload_fw_noreply_cb(uint8_t * buff) {
    632a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000632c <.LCFI3>:
    632c:	ca 0c       	mova	r12,	r10	;

0000632e <.Loc.1219.1>:
  chSysLockFromISR();
    632e:	b0 13 92 45 	calla	#17810		;0x04592

00006332 <.LVL41>:
  elyFWFreeBufferI(elyNLFromFW(buff));
    6332:	cc 0a       	mova	r10,	r12	;
    6334:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006338 <.LVL42>:
    6338:	b0 13 68 61 	calla	#24936		;0x06168

0000633c <.LVL43>:
  chSysUnlockFromISR();
    633c:	b0 13 b4 45 	calla	#17844		;0x045b4

00006340 <.LVL44>:
}
    6340:	0a 16       	popm.a	#1,	r10	;20-bit words
    6342:	10 01       	reta			;

00006344 <cancel_fw_eeprom_cb>:
  chSysLockFromISR();
    6344:	b0 13 92 45 	calla	#17810		;0x04592

00006348 <.LBB83>:
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
    6348:	b0 13 24 46 	calla	#17956		;0x04624

0000634c <.LVL47>:

  if (bsp->sem.cnt < (cnt_t)1) {
    634c:	40 18 1c 42 	movx.w	&0x0d38e,r12	;
    6350:	8e d3 
    6352:	4d 43       	clr.b	r13		;
    6354:	0d 9c       	cmp	r12,	r13	;
    6356:	03 34       	jge	$+8      	;abs 0x635e

00006358 <.L24>:
  chSysUnlockFromISR();
    6358:	b0 13 b4 45 	calla	#17844		;0x045b4

0000635c <.LVL49>:
}
    635c:	10 01       	reta			;

0000635e <.L25>:
    chSemSignalI(&bsp->sem);
    635e:	8c 00 8e d3 	mova	#54158,	r12	;0x0d38e
    6362:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00006366 <.LVL51>:
    6366:	80 00 58 63 	mova	#25432,	r0	;0x06358

0000636a <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    636a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000636c <.LCFI4>:
    636c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000636e <.LCFI5>:
    636e:	06 14       	pushm.a	#1,	r6	;20-bit words

00006370 <.LCFI6>:
    6370:	b1 00 04 00 	suba	#4,	r1	;

00006374 <.LCFI7>:
    6374:	2a 4d       	mov	@r13,	r10	;

00006376 <.LVL53>:
    6376:	1d 4d 02 00 	mov	2(r13),	r13	;

0000637a <.LVL54>:
    637a:	08 4d       	mov	r13,	r8	;

0000637c <.Loc.1303.1>:
  if (hdr.reply) {
    637c:	4d 4a       	mov.b	r10,	r13	;

0000637e <.LVL56>:
    637e:	6d f3       	and.b	#2,	r13	;r3 As==10
    6380:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    6382:	0a 20       	jnz	$+22     	;abs 0x6398

00006384 <.Loc.1335.1>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6384:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006388 <.LVL57>:
    6388:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000638c <.L26>:
}
    638c:	a1 00 04 00 	adda	#4,	r1	;
    6390:	06 16       	popm.a	#1,	r6	;20-bit words
    6392:	08 16       	popm.a	#1,	r8	;20-bit words
    6394:	0a 16       	popm.a	#1,	r10	;20-bit words
    6396:	10 01       	reta			;

00006398 <.L29>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    6398:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    639c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    63a0:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    63a4:	0e dd       	bis	r13,	r14	;
    63a6:	40 18 82 4e 	movx.w	r14,	&0xfd390;
    63aa:	90 d3 

000063ac <.Loc.1307.1>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    63ac:	b0 13 ec 9d 	calla	#40428		;0x09dec

000063b0 <.LVL60>:
    63b0:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000063b4 <.LVL61>:
    volatile uint8_t * crc_addr = crcStart();
    63b4:	b0 13 b0 98 	calla	#39088		;0x098b0

000063b8 <.LVL62>:
    63b8:	c6 0c       	mova	r12,	r6	;

000063ba <.Loc.1314.1>:
    verify_stored_hdr = hdr;
    63ba:	40 18 82 4a 	movx.w	r10,	&0xfd396;
    63be:	96 d3 
    63c0:	40 18 82 48 	movx.w	r8,	&0xfd398;
    63c4:	98 d3 

000063c6 <.LBB88>:
  _disable_interrupts();
    63c6:	32 c2       	dint			
    63c8:	03 43       	nop			

000063ca <.Loc.348.2>:
  asm volatile("nop");
    63ca:	03 43       	nop			

000063cc <.LBE88>:
    chSysLock();
    63cc:	88 00 50 45 	mova	#17744,	r8	;0x04550
    63d0:	48 13       	calla	r8		;

000063d2 <.LVL66>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    63d2:	4d 43       	clr.b	r13		;
    63d4:	cc 01       	mova	r1,	r12	;
    63d6:	b0 13 b0 96 	calla	#38576		;0x096b0

000063da <.LVL67>:
    chSysUnlock();
    63da:	8a 00 70 45 	mova	#17776,	r10	;0x04570
    63de:	4a 13       	calla	r10		;

000063e0 <.LBB90>:
  asm volatile("nop");
    63e0:	03 43       	nop			

000063e2 <.Loc.356.2>:
  _enable_interrupts();
    63e2:	03 43       	nop			
    63e4:	32 d2       	eint			
    63e6:	03 43       	nop			

000063e8 <.LBE90>:
    req->address = FRAM_FW_BASE; 
    63e8:	0c 01       	mova	@r1,	r12	;
    63ea:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    63ee:	00 00 
    63f0:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

000063f4 <.Loc.1323.1>:
    req->read = 1;
    63f4:	0c 01       	mova	@r1,	r12	;

000063f6 <.Loc.1324.1>:
    req->special = 1; /* read to a constant register address */
    63f6:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    63fa:	04 00 

000063fc <.Loc.1325.1>:
    req->size = FRAM_FW_SIZE;
    63fc:	1d 4c 04 00 	mov	4(r12),	r13	;
    6400:	7d f0 03 00 	and.b	#3,	r13	;
    6404:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    6408:	8c 4d 04 00 	mov	r13,	4(r12)	;
    640c:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    6410:	7d d0 03 00 	bis.b	#3,	r13	;
    6414:	6d c2       	bic.b	#4,	r13	;r2 As==10
    6416:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

0000641a <.Loc.1326.1>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    641a:	7c 06 08 00 	mova	r6,	8(r12)	;

0000641e <.Loc.1327.1>:
    req->callback = verify_fw_cb;
    641e:	00 18 fc 40 	movx.a	#26740,	12(r12)	;0x06874, 0x0000c
    6422:	74 68 0c 00 

00006426 <.LBB92>:
  _disable_interrupts();
    6426:	32 c2       	dint			
    6428:	03 43       	nop			

0000642a <.Loc.348.2>:
  asm volatile("nop");
    642a:	03 43       	nop			

0000642c <.LBE92>:
    chSysLock();
    642c:	48 13       	calla	r8		;

0000642e <.LVL69>:
    elyFramPostRequestS(req);
    642e:	0c 01       	mova	@r1,	r12	;
    6430:	b0 13 60 96 	calla	#38496		;0x09660

00006434 <.LVL70>:
    chSysUnlock();
    6434:	4a 13       	calla	r10		;

00006436 <.LBB94>:
  asm volatile("nop");
    6436:	03 43       	nop			

00006438 <.Loc.356.2>:
  _enable_interrupts();
    6438:	03 43       	nop			
    643a:	32 d2       	eint			
    643c:	03 43       	nop			

0000643e <.LBE87>:
    643e:	80 00 8c 63 	mova	#25484,	r0	;0x0638c

00006442 <elyMainMBPost>:
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    6442:	0e 4d       	mov	r13,	r14	;
    6444:	cd 0c       	mova	r12,	r13	;

00006446 <.LVL73>:
    6446:	8c 01 08 05 	mova	#66824,	r12	;0x10508

0000644a <.LVL74>:
    644a:	b0 13 2a 4c 	calla	#19498		;0x04c2a

0000644e <.LVL75>:
}
    644e:	10 01       	reta			;

00006450 <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * fw_buffer) {
    6450:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006452 <.LCFI9>:
    6452:	ca 0d       	mova	r13,	r10	;

00006454 <.Loc.1590.1>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (fw_buffer[0] >> 7);
    6454:	6f 4d       	mov.b	@r13,	r15	;
    6456:	0d 4f       	mov	r15,	r13	;

00006458 <.LVL83>:
    6458:	5d 0f       	rrum	#4,	r13	;
    645a:	5d 0b       	rrum	#3,	r13	;
    645c:	6e 4c       	mov.b	@r12,	r14	;
    645e:	5e c3       	bic.b	#1,	r14	;r3 As==01
    6460:	4e dd       	bis.b	r13,	r14	;

00006462 <.Loc.1591.1>:
  hdr.reply = ((fw_buffer[0] >> 6) & 0x01);
    6462:	0d 4f       	mov	r15,	r13	;
    6464:	5d 0f       	rrum	#4,	r13	;
    6466:	5d 07       	rrum	#2,	r13	;
    6468:	5d f3       	and.b	#1,	r13	;r3 As==01
    646a:	4d 5d       	rla.b	r13		;
    646c:	6e c3       	bic.b	#2,	r14	;r3 As==10
    646e:	4e dd       	bis.b	r13,	r14	;

00006470 <.Loc.1592.1>:
  hdr.opcode = (fw_buffer[0] & 0x3F);
    6470:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    6474:	7e f0 03 00 	and.b	#3,	r14	;
    6478:	4e df       	bis.b	r15,	r14	;
    647a:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

0000647e <.Loc.1593.1>:
  hdr.length = fw_buffer[1];
    647e:	dc 4a 01 00 	mov.b	1(r10),	1(r12)	;
    6482:	01 00 

00006484 <.Loc.1594.1>:
  if (hdr.reply) {
    6484:	6e f3       	and.b	#2,	r14	;r3 As==10
    6486:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    6488:	09 24       	jz	$+20     	;abs 0x649c

0000648a <.Loc.1595.1>:
    hdr.reply_addr = (((uint16_t)(fw_buffer[2]) << 8) | (fw_buffer[3]));
    648a:	5d 4a 02 00 	mov.b	2(r10),	r13	;
    648e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6492:	5a 4a 03 00 	mov.b	3(r10),	r10	;

00006496 <.LVL84>:
    6496:	0a dd       	bis	r13,	r10	;
    6498:	8c 4a 02 00 	mov	r10,	2(r12)	;

0000649c <.L33>:
  }
  return hdr;
}
    649c:	0a 16       	popm.a	#1,	r10	;20-bit words
    649e:	10 01       	reta			;

000064a0 <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    64a0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000064a2 <.LCFI10>:
    64a2:	ca 0d       	mova	r13,	r10	;

000064a4 <.Loc.1600.1>:
    64a4:	2d 4c       	mov	@r12,	r13	;

000064a6 <.LVL86>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    64a6:	0c 4d       	mov	r13,	r12	;
    64a8:	5c 07       	rrum	#2,	r12	;
    64aa:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    64ae:	4e 4c       	mov.b	r12,	r14	;
    64b0:	7f 40 2f 00 	mov.b	#47,	r15	;#0x002f
    64b4:	0f 9e       	cmp	r14,	r15	;
    64b6:	48 38       	jl	$+146    	;abs 0x6548

000064b8 <.Loc.1609.1>:
    elyErrorSignal(ErrInvalidOpcode);
    return false;
  }
  
  /* Check return address */
  if (hdr.reply) {
    64b8:	49 4d       	mov.b	r13,	r9	;
    64ba:	4f 49       	mov.b	r9,	r15	;
    64bc:	6f f3       	and.b	#2,	r15	;r3 As==10
    64be:	4f 93       	cmp.b	#0,	r15	;r3 As==00
    64c0:	06 24       	jz	$+14     	;abs 0x64ce

000064c2 <.Loc.1610.1>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    64c2:	2e 01 3e 04 	mova	&66622,	r14	;0x1043e
    64c6:	da 9e 51 00 	cmp.b	81(r14),2(r10)	;0x00051
    64ca:	02 00 
    64cc:	44 24       	jz	$+138    	;abs 0x6556

000064ce <.L38>:
      return false;
    }
  }
  
  /* Check length */
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    64ce:	08 4d       	mov	r13,	r8	;
    64d0:	58 0f       	rrum	#4,	r8	;
    64d2:	58 0f       	rrum	#4,	r8	;
    64d4:	59 f3       	and.b	#1,	r9	;r3 As==01
    64d6:	09 93       	cmp	#0,	r9	;r3 As==00
    64d8:	45 24       	jz	$+140    	;abs 0x6564
    64da:	6e 43       	mov.b	#2,	r14	;r3 As==10

000064dc <.L39>:
    64dc:	4e 5f       	add.b	r15,	r14	;
    64de:	40 18 4d 48 	movx.b	r8,	r13	;
    64e2:	40 18 4d 8e 	subx.b	r14,	r13	;
    64e6:	4e 4d       	mov.b	r13,	r14	;

000064e8 <.LVL87>:
  switch(hdr.opcode) {
    64e8:	7c 90 16 00 	cmp.b	#22,	r12	;#0x0016
    64ec:	63 24       	jz	$+200    	;abs 0x65b4
    64ee:	7f 40 16 00 	mov.b	#22,	r15	;#0x0016
    64f2:	4f 9c       	cmp.b	r12,	r15	;
    64f4:	3a 2c       	jc	$+118    	;abs 0x656a
    64f6:	7c 90 24 00 	cmp.b	#36,	r12	;#0x0024
    64fa:	6a 24       	jz	$+214    	;abs 0x65d0
    64fc:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    6500:	4f 9c       	cmp.b	r12,	r15	;
    6502:	ab 2c       	jc	$+344    	;abs 0x665a
    6504:	7c 90 2a 00 	cmp.b	#42,	r12	;#0x002a
    6508:	bc 24       	jz	$+378    	;abs 0x6682
    650a:	7f 40 2a 00 	mov.b	#42,	r15	;#0x002a
    650e:	4f 9c       	cmp.b	r12,	r15	;
    6510:	e4 2c       	jc	$+458    	;abs 0x66da
    6512:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    6516:	4f 9c       	cmp.b	r12,	r15	;
    6518:	ef 2c       	jc	$+480    	;abs 0x66f8
    651a:	7c 90 2e 00 	cmp.b	#46,	r12	;#0x002e
    651e:	f9 24       	jz	$+500    	;abs 0x6712
    6520:	7c 90 2f 00 	cmp.b	#47,	r12	;#0x002f
    6524:	d0 20       	jnz	$+418    	;abs 0x66c6

00006526 <.Loc.1684.1>:
        return false;
      }
      break;
      
    case CmdGetTelem: /* 2 + 2 + 8 */
      if (payload_len != 2 && payload_len != 4 && 
    6526:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    6528:	d2 24       	jz	$+422    	;abs 0x66ce

0000652a <.Loc.1684.1>:
    652a:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    652c:	d0 24       	jz	$+418    	;abs 0x66ce

0000652e <.Loc.1684.1>:
    652e:	7d 90 0a 00 	cmp.b	#10,	r13	;#0x000a
    6532:	cd 24       	jz	$+412    	;abs 0x66ce

00006534 <.Loc.1685.1>:
          payload_len != 10 && payload_len != 12) {
    6534:	7d 90 0c 00 	cmp.b	#12,	r13	;#0x000c
    6538:	ca 24       	jz	$+406    	;abs 0x66ce

0000653a <.Loc.1686.1>:
        elyErrorSignal(ErrInvalidLength);
    653a:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    653e:	b0 13 fa 96 	calla	#38650		;0x096fa

00006542 <.LVL88>:
        return false;
    6542:	4a 43       	clr.b	r10		;

00006544 <.LVL89>:
    6544:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006548 <.L69>:
    elyErrorSignal(ErrInvalidOpcode);
    6548:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89
    654c:	b0 13 fa 96 	calla	#38650		;0x096fa

00006550 <.LVL91>:
    return false;
    6550:	4a 43       	clr.b	r10		;

00006552 <.LVL92>:
    6552:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006556 <.L70>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    6556:	da 9e 50 00 	cmp.b	80(r14),3(r10)	;0x00050
    655a:	03 00 
    655c:	b8 23       	jnz	$-142    	;abs 0x64ce

0000655e <.Loc.1612.1>:
      return false;
    655e:	4a 43       	clr.b	r10		;

00006560 <.LVL94>:
    6560:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006564 <.L66>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6564:	4e 43       	clr.b	r14		;
    6566:	80 00 dc 64 	mova	#25820,	r0	;0x064dc

0000656a <.L71>:
  switch(hdr.opcode) {
    656a:	7c 90 0a 00 	cmp.b	#10,	r12	;#0x000a
    656e:	22 24       	jz	$+70     	;abs 0x65b4
    6570:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    6574:	4f 9c       	cmp.b	r12,	r15	;
    6576:	35 28       	jnc	$+108    	;abs 0x65e2
    6578:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    657a:	cb 24       	jz	$+408    	;abs 0x6712
    657c:	6f 42       	mov.b	#4,	r15	;r2 As==10
    657e:	4f 9c       	cmp.b	r12,	r15	;
    6580:	17 2c       	jc	$+48     	;abs 0x65b0
    6582:	7c 90 07 00 	cmp.b	#7,	r12	;
    6586:	e0 24       	jz	$+450    	;abs 0x6748
    6588:	7f 40 07 00 	mov.b	#7,	r15	;
    658c:	4f 9c       	cmp.b	r12,	r15	;
    658e:	1b 28       	jnc	$+56     	;abs 0x65c6
    6590:	7c 90 05 00 	cmp.b	#5,	r12	;
    6594:	c9 24       	jz	$+404    	;abs 0x6728
    6596:	7c 90 06 00 	cmp.b	#6,	r12	;
    659a:	95 20       	jnz	$+300    	;abs 0x66c6

0000659c <.Loc.1663.1>:
      if (payload_len != 3) {
    659c:	7d 90 03 00 	cmp.b	#3,	r13	;
    65a0:	96 24       	jz	$+302    	;abs 0x66ce

000065a2 <.Loc.1664.1>:
        elyErrorSignal(ErrInvalidLength);
    65a2:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    65a6:	b0 13 fa 96 	calla	#38650		;0x096fa

000065aa <.LVL97>:
        return false;
    65aa:	4a 43       	clr.b	r10		;

000065ac <.LVL98>:
    65ac:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

000065b0 <.L75>:
  switch(hdr.opcode) {
    65b0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    65b2:	2b 24       	jz	$+88     	;abs 0x660a

000065b4 <.L41>:
      if (payload_len != 0) {
    65b4:	0e 93       	cmp	#0,	r14	;r3 As==00
    65b6:	8b 24       	jz	$+280    	;abs 0x66ce

000065b8 <.Loc.1638.1>:
        elyErrorSignal(ErrInvalidLength);
    65b8:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    65bc:	b0 13 fa 96 	calla	#38650		;0x096fa

000065c0 <.LVL100>:
        return false;
    65c0:	4a 43       	clr.b	r10		;

000065c2 <.LVL101>:
    65c2:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

000065c6 <.L48>:
  switch(hdr.opcode) {
    65c6:	7c 92       	cmp.b	#8,	r12	;r2 As==11
    65c8:	f5 27       	jz	$-20     	;abs 0x65b4
    65ca:	7c 90 09 00 	cmp.b	#9,	r12	;
    65ce:	7b 20       	jnz	$+248    	;abs 0x66c6

000065d0 <.L51>:
      if (payload_len != 4) {
    65d0:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    65d2:	7d 24       	jz	$+252    	;abs 0x66ce

000065d4 <.Loc.1678.1>:
        elyErrorSignal(ErrInvalidLength);
    65d4:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    65d8:	b0 13 fa 96 	calla	#38650		;0x096fa

000065dc <.LVL103>:
        return false;
    65dc:	4a 43       	clr.b	r10		;

000065de <.LVL104>:
    65de:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

000065e2 <.L43>:
  switch(hdr.opcode) {
    65e2:	7c 90 10 00 	cmp.b	#16,	r12	;#0x0010
    65e6:	e6 27       	jz	$-50     	;abs 0x65b4
    65e8:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    65ec:	4f 9c       	cmp.b	r12,	r15	;
    65ee:	16 2c       	jc	$+46     	;abs 0x661c
    65f0:	7c 90 13 00 	cmp.b	#19,	r12	;#0x0013
    65f4:	ed 27       	jz	$-36     	;abs 0x65d0
    65f6:	7f 40 13 00 	mov.b	#19,	r15	;#0x0013
    65fa:	4f 9c       	cmp.b	r12,	r15	;
    65fc:	26 2c       	jc	$+78     	;abs 0x664a
    65fe:	7c 90 14 00 	cmp.b	#20,	r12	;#0x0014
    6602:	d8 27       	jz	$-78     	;abs 0x65b4
    6604:	7c 90 15 00 	cmp.b	#21,	r12	;#0x0015
    6608:	5e 20       	jnz	$+190    	;abs 0x66c6

0000660a <.L46>:
      if (payload_len != 1) {
    660a:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    660c:	60 24       	jz	$+194    	;abs 0x66ce

0000660e <.Loc.1650.1>:
        elyErrorSignal(ErrInvalidLength);
    660e:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    6612:	b0 13 fa 96 	calla	#38650		;0x096fa

00006616 <.LVL106>:
        return false;
    6616:	4a 43       	clr.b	r10		;

00006618 <.LVL107>:
    6618:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

0000661c <.L76>:
  switch(hdr.opcode) {
    661c:	7c 90 0d 00 	cmp.b	#13,	r12	;#0x000d
    6620:	d7 27       	jz	$-80     	;abs 0x65d0
    6622:	7f 40 0d 00 	mov.b	#13,	r15	;#0x000d
    6626:	4f 9c       	cmp.b	r12,	r15	;
    6628:	08 28       	jnc	$+18     	;abs 0x663a
    662a:	7c 90 0b 00 	cmp.b	#11,	r12	;#0x000b
    662e:	d0 27       	jz	$-94     	;abs 0x65d0
    6630:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    6634:	bf 27       	jz	$-128    	;abs 0x65b4
    6636:	80 00 c6 66 	mova	#26310,	r0	;0x066c6

0000663a <.L53>:
    663a:	7c 90 0e 00 	cmp.b	#14,	r12	;#0x000e
    663e:	ba 27       	jz	$-138    	;abs 0x65b4
    6640:	7c 90 0f 00 	cmp.b	#15,	r12	;#0x000f
    6644:	c5 27       	jz	$-116    	;abs 0x65d0
    6646:	80 00 c6 66 	mova	#26310,	r0	;0x066c6

0000664a <.L77>:
    664a:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    664e:	c0 27       	jz	$-126    	;abs 0x65d0
    6650:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    6654:	af 27       	jz	$-160    	;abs 0x65b4
    6656:	80 00 c6 66 	mova	#26310,	r0	;0x066c6

0000665a <.L72>:
    665a:	7c 90 1c 00 	cmp.b	#28,	r12	;#0x001c
    665e:	59 24       	jz	$+180    	;abs 0x6712
    6660:	7f 40 1c 00 	mov.b	#28,	r15	;#0x001c
    6664:	4f 9c       	cmp.b	r12,	r15	;
    6666:	22 28       	jnc	$+70     	;abs 0x66ac
    6668:	7c 90 19 00 	cmp.b	#25,	r12	;#0x0019
    666c:	0a 24       	jz	$+22     	;abs 0x6682
    666e:	7e 40 19 00 	mov.b	#25,	r14	;#0x0019
    6672:	4e 9c       	cmp.b	r12,	r14	;
    6674:	13 2c       	jc	$+40     	;abs 0x669c
    6676:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    667a:	4b 24       	jz	$+152    	;abs 0x6712
    667c:	7c 90 1b 00 	cmp.b	#27,	r12	;#0x001b
    6680:	22 20       	jnz	$+70     	;abs 0x66c6

00006682 <.L57>:
      break;
      
    case CmdChannelSub: /* 4 + 8-bit aligned */
    case CmdLogChan: /* 4 + 8-bit aligned */
    case CmdUploadFW: /* 4 + 8-bit aligned */
      if (payload_len < 4 || payload_len > 251) {
    6682:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc

00006686 <.LVL109>:
    6686:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    668a:	4c 9d       	cmp.b	r13,	r12	;
    668c:	20 2c       	jc	$+66     	;abs 0x66ce

0000668e <.Loc.1723.1>:
        elyErrorSignal(ErrInvalidLength);
    668e:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    6692:	b0 13 fa 96 	calla	#38650		;0x096fa

00006696 <.LVL110>:
        return false;
    6696:	4a 43       	clr.b	r10		;

00006698 <.LVL111>:
    6698:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

0000669c <.L78>:
  switch(hdr.opcode) {
    669c:	7c 90 17 00 	cmp.b	#23,	r12	;#0x0017
    66a0:	97 27       	jz	$-208    	;abs 0x65d0
    66a2:	7c 90 18 00 	cmp.b	#24,	r12	;#0x0018
    66a6:	b1 27       	jz	$-156    	;abs 0x660a
    66a8:	80 00 c6 66 	mova	#26310,	r0	;0x066c6

000066ac <.L56>:
    66ac:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    66b0:	4f 9c       	cmp.b	r12,	r15	;
    66b2:	80 2b       	jnc	$-254    	;abs 0x65b4
    66b4:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    66b8:	4f 9c       	cmp.b	r12,	r15	;
    66ba:	2b 28       	jnc	$+88     	;abs 0x6712
    66bc:	7c 90 1d 00 	cmp.b	#29,	r12	;#0x001d
    66c0:	a4 27       	jz	$-182    	;abs 0x660a
    66c2:	4c 9f       	cmp.b	r15,	r12	;
    66c4:	77 27       	jz	$-272    	;abs 0x65b4

000066c6 <.L40>:
      }
      break;
      
    default:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
    66c6:	8c 01 6b 03 	mova	#66411,	r12	;0x1036b
    66ca:	b0 13 a0 47 	calla	#18336		;0x047a0

000066ce <.L63>:
  }
  
  /* Check CRC */
  if (hdr.crc) {
    66ce:	09 93       	cmp	#0,	r9	;r3 As==00
    66d0:	48 20       	jnz	$+146    	;abs 0x6762

000066d2 <.Loc.1741.1>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    66d2:	5a 43       	mov.b	#1,	r10	;r3 As==01

000066d4 <.L37>:
  
}
    66d4:	4c 4a       	mov.b	r10,	r12	;
    66d6:	28 16       	popm.a	#3,	r10	;20-bit words
    66d8:	10 01       	reta			;

000066da <.L73>:
  switch(hdr.opcode) {
    66da:	7c 90 27 00 	cmp.b	#39,	r12	;#0x0027
    66de:	95 27       	jz	$-212    	;abs 0x660a
    66e0:	7f 40 26 00 	mov.b	#38,	r15	;#0x0026
    66e4:	4f 9c       	cmp.b	r12,	r15	;
    66e6:	66 2f       	jc	$-306    	;abs 0x65b4
    66e8:	7c 90 28 00 	cmp.b	#40,	r12	;#0x0028
    66ec:	63 27       	jz	$-312    	;abs 0x65b4
    66ee:	7c 90 29 00 	cmp.b	#41,	r12	;#0x0029
    66f2:	8b 27       	jz	$-232    	;abs 0x660a
    66f4:	80 00 c6 66 	mova	#26310,	r0	;0x066c6

000066f8 <.L74>:
    66f8:	7f 40 2b 00 	mov.b	#43,	r15	;#0x002b
    66fc:	4f 9c       	cmp.b	r12,	r15	;
    66fe:	5a 2b       	jnc	$-330    	;abs 0x65b4

00006700 <.Loc.1656.1>:
      if (payload_len != 2) {
    6700:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    6702:	e5 27       	jz	$-52     	;abs 0x66ce

00006704 <.Loc.1657.1>:
        elyErrorSignal(ErrInvalidLength);
    6704:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    6708:	b0 13 fa 96 	calla	#38650		;0x096fa

0000670c <.LVL116>:
        return false;
    670c:	4a 43       	clr.b	r10		;

0000670e <.LVL117>:
    670e:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006712 <.L44>:
      if (payload_len > 251) {
    6712:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb
    6716:	4c 9d       	cmp.b	r13,	r12	;
    6718:	da 2f       	jc	$-74     	;abs 0x66ce

0000671a <.Loc.1700.1>:
        elyErrorSignal(ErrInvalidLength);
    671a:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    671e:	b0 13 fa 96 	calla	#38650		;0x096fa

00006722 <.LVL119>:
        return false;
    6722:	4a 43       	clr.b	r10		;

00006724 <.LVL120>:
    6724:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006728 <.L49>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    6728:	0e 93       	cmp	#0,	r14	;r3 As==00
    672a:	07 24       	jz	$+16     	;abs 0x673a

0000672c <.Loc.1706.1>:
    672c:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    6730:	04 24       	jz	$+10     	;abs 0x673a

00006732 <.Loc.1706.1>:
    6732:	7e 40 fb ff 	mov.b	#-5,	r14	;#0xfffb
    6736:	4e 9d       	cmp.b	r13,	r14	;
    6738:	ca 2f       	jc	$-106    	;abs 0x66ce

0000673a <.L64>:
        elyErrorSignal(ErrInvalidLength);
    673a:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    673e:	b0 13 fa 96 	calla	#38650		;0x096fa

00006742 <.LVL122>:
        return false;
    6742:	4a 43       	clr.b	r10		;

00006744 <.LVL123>:
    6744:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006748 <.L47>:
      if (payload_len < 2 || payload_len > 251) {
    6748:	7d 50 fe ff 	add.b	#-2,	r13	;#0xfffe

0000674c <.LVL125>:
    674c:	7f 40 f9 ff 	mov.b	#-7,	r15	;#0xfff9
    6750:	4f 9d       	cmp.b	r13,	r15	;
    6752:	bd 2f       	jc	$-132    	;abs 0x66ce

00006754 <.Loc.1714.1>:
        elyErrorSignal(ErrInvalidLength);
    6754:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    6758:	b0 13 fa 96 	calla	#38650		;0x096fa

0000675c <.LVL126>:
        return false;
    675c:	4a 43       	clr.b	r10		;

0000675e <.LVL127>:
    675e:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006762 <.L79>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    6762:	0d 48       	mov	r8,	r13	;
    6764:	2d 53       	incd	r13		;
    6766:	4d 0e       	rlam.a	#4,	r13	;
    6768:	4d 0d       	rram.a	#4,	r13	;
    676a:	cc 0a       	mova	r10,	r12	;
    676c:	b0 13 4a 98 	calla	#38986		;0x0984a

00006770 <.LVL129>:
    6770:	4a 4c       	mov.b	r12,	r10	;

00006772 <.LVL130>:
    6772:	0a 93       	cmp	#0,	r10	;r3 As==00
    6774:	af 23       	jnz	$-160    	;abs 0x66d4

00006776 <.Loc.1736.1>:
      elyErrorSignal(ErrFCSError);
    6776:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    677a:	b0 13 fa 96 	calla	#38650		;0x096fa

0000677e <.LVL131>:
      return false;
    677e:	80 00 d4 66 	mova	#26324,	r0	;0x066d4

00006782 <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    6782:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006784 <.LCFI11>:
    6784:	b1 00 08 00 	suba	#8,	r1	;

00006788 <.LCFI12>:
    6788:	2f 4c       	mov	@r12,	r15	;

0000678a <.LVL133>:
    678a:	1a 4c 02 00 	mov	2(r12),	r10	;

0000678e <.LVL134>:
    678e:	cc 0d       	mova	r13,	r12	;

00006790 <.Loc.1745.1>:
    6790:	0e 4f       	mov	r15,	r14	;
    6792:	0d 4a       	mov	r10,	r13	;

00006794 <.LVL136>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    6794:	5e 07       	rrum	#2,	r14	;
    6796:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    679a:	4e 0e       	rlam.a	#4,	r14	;
    679c:	4e 0d       	rram.a	#4,	r14	;
    679e:	0e 14       	pushm.a	#1,	r14	;20-bit words
    67a0:	40 18 3a 41 	popx.w	r10		;
    67a4:	40 18 3b 41 	popx.w	r11		;

000067a8 <.LVL137>:
    67a8:	08 4a       	mov	r10,	r8	;
    67aa:	09 4b       	mov	r11,	r9	;
    67ac:	08 58       	rla	r8		;
    67ae:	09 69       	rlc	r9		;
    67b0:	08 58       	rla	r8		;
    67b2:	09 69       	rlc	r9		;
    67b4:	81 48 00 00 	mov	r8,	0(r1)	;
    67b8:	81 49 02 00 	mov	r9,	2(r1)	;
    67bc:	09 01       	mova	@r1,	r9	;
    67be:	80 18 5e 49 	movx.a	66426(r9),r14	;0x1037a
    67c2:	7a 03 
    67c4:	81 4f 04 00 	mov	r15,	4(r1)	;
    67c8:	81 4d 06 00 	mov	r13,	6(r1)	;
    67cc:	cd 01       	mova	r1,	r13	;
    67ce:	ad 00 04 00 	adda	#4,	r13	;
    67d2:	4e 13       	calla	r14		;

000067d4 <.LVL138>:
}
    67d4:	a1 00 08 00 	adda	#8,	r1	;
    67d8:	28 16       	popm.a	#3,	r10	;20-bit words
    67da:	10 01       	reta			;

000067dc <elyCmdSendReplyI>:
  chSysLock();
  elyCmdSendReplyI(buff, dest_addr);
  chSysUnlock();
}

void elyCmdSendReplyI(uint8_t * buff, uint16_t dest_addr) {
    67dc:	2a 14       	pushm.a	#3,	r10	;20-bit words

000067de <.LCFI13>:
    67de:	0a 4d       	mov	r13,	r10	;

000067e0 <.Loc.1757.1>:
  uint8_t length = buff[1];
    67e0:	59 4c 01 00 	mov.b	1(r12),	r9	;

000067e4 <.LVL140>:
  uint8_t * buffer = elyNLFromFW(buff);
    67e4:	b0 13 ec 9d 	calla	#40428		;0x09dec

000067e8 <.LVL141>:
    67e8:	c8 0c       	mova	r12,	r8	;

000067ea <.Loc.1760.1>:
  
  elyNLSetHeader(buffer, length+4, dest_addr);
    67ea:	0e 4a       	mov	r10,	r14	;
    67ec:	0d 49       	mov	r9,	r13	;
    67ee:	2d 52       	add	#4,	r13	;r2 As==10
    67f0:	b0 13 74 9b 	calla	#39796		;0x09b74

000067f4 <.LVL143>:
  switch (elyNLGetDest(buffer, dest_addr)) {
    67f4:	0d 4a       	mov	r10,	r13	;
    67f6:	cc 08       	mova	r8,	r12	;
    67f8:	b0 13 cc 9a 	calla	#39628		;0x09acc

000067fc <.LVL144>:
    67fc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    67fe:	11 24       	jz	$+36     	;abs 0x6822
    6800:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    6802:	1e 20       	jnz	$+62     	;abs 0x6840

00006804 <.Loc.1763.1>:
    case ELY_DEST_RF:
      if (MSG_OK != elyRFPostI(buffer)) {
    6804:	cc 08       	mova	r8,	r12	;
    6806:	b0 13 0c 97 	calla	#38668		;0x0970c

0000680a <.LVL145>:
    680a:	9c 00 00 00 	cmpa	#0,	r12	;
    680e:	1c 24       	jz	$+58     	;abs 0x6848

00006810 <.Loc.1765.1>:
        /* We should never hit this because everyone allocates the same amount */
        chDbgAssert(false, "internal buffer overflows should be impossible");
    6810:	8c 01 5a 03 	mova	#66394,	r12	;0x1035a
    6814:	b0 13 a0 47 	calla	#18336		;0x047a0

00006818 <.LVL146>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
    6818:	cc 08       	mova	r8,	r12	;
    681a:	b0 13 7c 61 	calla	#24956		;0x0617c

0000681e <.LVL147>:
    681e:	80 00 48 68 	mova	#26696,	r0	;0x06848

00006822 <.L83>:
      }
      break;
    case ELY_DEST_UART:
      if (MSG_OK != elyUARTPostI(buffer)) {
    6822:	cc 08       	mova	r8,	r12	;
    6824:	b0 13 c0 5e 	calla	#24256		;0x05ec0

00006828 <.LVL148>:
    6828:	9c 00 00 00 	cmpa	#0,	r12	;
    682c:	0d 24       	jz	$+28     	;abs 0x6848

0000682e <.Loc.1773.1>:
        /* We should never hit this because everyone allocates the same amount */
        chDbgAssert(false, "internal buffer overflows should be impossible");
    682e:	8c 01 5a 03 	mova	#66394,	r12	;0x1035a
    6832:	b0 13 a0 47 	calla	#18336		;0x047a0

00006836 <.LVL149>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
    6836:	cc 08       	mova	r8,	r12	;
    6838:	b0 13 7c 61 	calla	#24956		;0x0617c

0000683c <.LVL150>:
    683c:	80 00 48 68 	mova	#26696,	r0	;0x06848

00006840 <.L86>:
      }
      break;
    default:
      chDbgAssert(false, "shouldn't happen");
    6840:	8c 01 5a 03 	mova	#66394,	r12	;0x1035a
    6844:	b0 13 a0 47 	calla	#18336		;0x047a0

00006848 <.L81>:
      break;
  }
}
    6848:	28 16       	popm.a	#3,	r10	;20-bit words
    684a:	10 01       	reta			;

0000684c <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buff) {
    684c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000684e <.LCFI14>:
    684e:	08 14       	pushm.a	#1,	r8	;20-bit words

00006850 <.LCFI15>:
    6850:	c8 0c       	mova	r12,	r8	;

00006852 <.Loc.1452.1>:
  write_success(buff, telem_stored_hdr); /* crc */
    6852:	8a 00 92 d3 	mova	#54162,	r10	;0x0d392
    6856:	cd 0a       	mova	r10,	r13	;
    6858:	b0 13 bc 61 	calla	#25020		;0x061bc

0000685c <.LVL153>:
  chSysLockFromISR();
    685c:	b0 13 92 45 	calla	#17810		;0x04592

00006860 <.LVL154>:
  elyCmdSendReplyI(buff, telem_stored_hdr.reply_addr);
    6860:	1d 4a 02 00 	mov	2(r10),	r13	;
    6864:	cc 08       	mova	r8,	r12	;
    6866:	b0 13 dc 67 	calla	#26588		;0x067dc

0000686a <.LVL155>:
  chSysUnlockFromISR();
    686a:	b0 13 b4 45 	calla	#17844		;0x045b4

0000686e <.LVL156>:
}
    686e:	08 16       	popm.a	#1,	r8	;20-bit words
    6870:	0a 16       	popm.a	#1,	r10	;20-bit words
    6872:	10 01       	reta			;

00006874 <verify_fw_cb>:
static void verify_fw_cb(uint8_t * buffer) {
    6874:	1a 14       	pushm.a	#2,	r10	;20-bit words

00006876 <.LCFI16>:
  uint16_t result = crcStop();
    6876:	b0 13 d6 98 	calla	#39126		;0x098d6

0000687a <.LVL158>:
    687a:	09 4c       	mov	r12,	r9	;

0000687c <.Loc.1283.1>:
  chSysLockFromISR();
    687c:	b0 13 92 45 	calla	#17810		;0x04592

00006880 <.LVL160>:
  uint8_t * reply_buff = elyFWGetBufferI();
    6880:	b0 13 2a 61 	calla	#24874		;0x0612a

00006884 <.LVL161>:
    6884:	ca 0c       	mova	r12,	r10	;

00006886 <.Loc.1285.1>:
  if (reply_buff == NULL) {
    6886:	9c 00 00 00 	cmpa	#0,	r12	;
    688a:	10 24       	jz	$+34     	;abs 0x68ac

0000688c <.Loc.1290.1>:
  if (result == verify_crc) {
    688c:	40 18 19 92 	cmpx.w	&0x0d390,r9	;
    6890:	90 d3 
    6892:	0e 24       	jz	$+30     	;abs 0x68b0

00006894 <.Loc.1295.1>:
    write_failure(reply_buff, verify_stored_hdr);
    6894:	8d 00 96 d3 	mova	#54166,	r13	;0x0d396
    6898:	b0 13 fa 61 	calla	#25082		;0x061fa

0000689c <.LVL163>:
    elyCmdSendReplyI(reply_buff, stored_hdr.reply_addr);
    689c:	40 18 1d 42 	movx.w	&0x0d39c,r13	;
    68a0:	9c d3 
    68a2:	cc 0a       	mova	r10,	r12	;
    68a4:	b0 13 dc 67 	calla	#26588		;0x067dc

000068a8 <.L91>:
  chSysUnlockFromISR();
    68a8:	b0 13 b4 45 	calla	#17844		;0x045b4

000068ac <.L88>:
}
    68ac:	19 16       	popm.a	#2,	r10	;20-bit words
    68ae:	10 01       	reta			;

000068b0 <.L92>:
    write_success(reply_buff, verify_stored_hdr);
    68b0:	8d 00 96 d3 	mova	#54166,	r13	;0x0d396
    68b4:	b0 13 bc 61 	calla	#25020		;0x061bc

000068b8 <.LVL166>:
    elyCmdSendReplyI(reply_buff, stored_hdr.reply_addr);
    68b8:	40 18 1d 42 	movx.w	&0x0d39c,r13	;
    68bc:	9c d3 
    68be:	cc 0a       	mova	r10,	r12	;
    68c0:	b0 13 dc 67 	calla	#26588		;0x067dc

000068c4 <.LVL167>:
    68c4:	80 00 a8 68 	mova	#26792,	r0	;0x068a8

000068c8 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buff) {
    68c8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000068ca <.LCFI17>:
    68ca:	08 14       	pushm.a	#1,	r8	;20-bit words

000068cc <.LCFI18>:
    68cc:	ca 0c       	mova	r12,	r10	;

000068ce <.Loc.1212.1>:
  chSysLockFromISR();
    68ce:	b0 13 92 45 	calla	#17810		;0x04592

000068d2 <.LVL169>:
    write_success(buff, stored_hdr);
    68d2:	88 00 9a d3 	mova	#54170,	r8	;0x0d39a
    68d6:	cd 08       	mova	r8,	r13	;
    68d8:	cc 0a       	mova	r10,	r12	;
    68da:	b0 13 bc 61 	calla	#25020		;0x061bc

000068de <.LVL170>:
    elyCmdSendReplyI(buff, stored_hdr.reply_addr);
    68de:	1d 48 02 00 	mov	2(r8),	r13	;
    68e2:	cc 0a       	mova	r10,	r12	;
    68e4:	b0 13 dc 67 	calla	#26588		;0x067dc

000068e8 <.LVL171>:
  chSysUnlockFromISR();
    68e8:	b0 13 b4 45 	calla	#17844		;0x045b4

000068ec <.LVL172>:
}
    68ec:	08 16       	popm.a	#1,	r8	;20-bit words
    68ee:	0a 16       	popm.a	#1,	r10	;20-bit words
    68f0:	10 01       	reta			;

000068f2 <elyCmdSendReply>:
void elyCmdSendReply(uint8_t * buff, uint16_t dest_addr) {
    68f2:	1a 14       	pushm.a	#2,	r10	;20-bit words

000068f4 <.LCFI19>:
    68f4:	ca 0c       	mova	r12,	r10	;
    68f6:	09 4d       	mov	r13,	r9	;

000068f8 <.LBB96>:
  _disable_interrupts();
    68f8:	32 c2       	dint			
    68fa:	03 43       	nop			

000068fc <.Loc.348.2>:
  asm volatile("nop");
    68fc:	03 43       	nop			

000068fe <.LBE96>:
  chSysLock();
    68fe:	b0 13 50 45 	calla	#17744		;0x04550

00006902 <.LVL174>:
  elyCmdSendReplyI(buff, dest_addr);
    6902:	0d 49       	mov	r9,	r13	;
    6904:	cc 0a       	mova	r10,	r12	;
    6906:	b0 13 dc 67 	calla	#26588		;0x067dc

0000690a <.LVL175>:
  chSysUnlock();
    690a:	b0 13 70 45 	calla	#17776		;0x04570

0000690e <.LBB98>:
  asm volatile("nop");
    690e:	03 43       	nop			

00006910 <.Loc.356.2>:
  _enable_interrupts();
    6910:	03 43       	nop			
    6912:	32 d2       	eint			
    6914:	03 43       	nop			

00006916 <.LBE98>:
}
    6916:	19 16       	popm.a	#2,	r10	;20-bit words
    6918:	10 01       	reta			;

0000691a <gen_success>:
static void gen_success(elysium_cmd_hdr_t hdr) {
    691a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000691c <.LCFI20>:
    691c:	b1 00 04 00 	suba	#4,	r1	;

00006920 <.LCFI21>:
    6920:	2d 4c       	mov	@r12,	r13	;

00006922 <.LVL178>:
    6922:	1a 4c 02 00 	mov	2(r12),	r10	;

00006926 <.LVL179>:
    6926:	09 4d       	mov	r13,	r9	;

00006928 <.Loc.49.1>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6928:	b0 13 44 61 	calla	#24900		;0x06144

0000692c <.LVL181>:
    692c:	c8 0c       	mova	r12,	r8	;

0000692e <.Loc.50.1>:
  if (reply_buff == NULL) {
    692e:	9c 00 00 00 	cmpa	#0,	r12	;
    6932:	0b 24       	jz	$+24     	;abs 0x694a

00006934 <.Loc.54.1>:
  write_success(reply_buff, hdr);
    6934:	81 49 00 00 	mov	r9,	0(r1)	;
    6938:	81 4a 02 00 	mov	r10,	2(r1)	;
    693c:	cd 01       	mova	r1,	r13	;
    693e:	b0 13 bc 61 	calla	#25020		;0x061bc

00006942 <.LVL184>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    6942:	0d 4a       	mov	r10,	r13	;
    6944:	cc 08       	mova	r8,	r12	;
    6946:	b0 13 f2 68 	calla	#26866		;0x068f2

0000694a <.L95>:
}
    694a:	a1 00 04 00 	adda	#4,	r1	;
    694e:	28 16       	popm.a	#3,	r10	;20-bit words
    6950:	10 01       	reta			;

00006952 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6952:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006954 <.LCFI22>:
    6954:	b1 00 10 00 	suba	#16,	r1	;0x00010

00006958 <.LCFI23>:
    6958:	ca 0c       	mova	r12,	r10	;
    695a:	29 4d       	mov	@r13,	r9	;

0000695c <.LVL187>:
    695c:	16 4d 02 00 	mov	2(r13),	r6	;

00006960 <.LVL188>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6960:	4d 49       	mov.b	r9,	r13	;
    6962:	4e 4d       	mov.b	r13,	r14	;
    6964:	6e f3       	and.b	#2,	r14	;r3 As==10
    6966:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    6968:	1c 24       	jz	$+58     	;abs 0x69a2
    696a:	67 42       	mov.b	#4,	r7	;r2 As==10

0000696c <.L98>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    696c:	0c 49       	mov	r9,	r12	;

0000696e <.LVL190>:
    696e:	5c 0f       	rrum	#4,	r12	;
    6970:	5c 0f       	rrum	#4,	r12	;
    6972:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    6976:	18 24       	jz	$+50     	;abs 0x69a8

00006978 <.Loc.1494.1>:
    6978:	6d 43       	mov.b	#2,	r13	;r3 As==10

0000697a <.L99>:
    697a:	4d 5e       	add.b	r14,	r13	;
    697c:	4c 8d       	sub.b	r13,	r12	;

0000697e <.LVL191>:
  if (payload_len == 4 || payload_len == 12) {
    697e:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    6980:	16 24       	jz	$+46     	;abs 0x69ae

00006982 <.Loc.1499.1>:
    6982:	7c 90 0c 00 	cmp.b	#12,	r12	;#0x000c
    6986:	13 24       	jz	$+40     	;abs 0x69ae

00006988 <.Loc.1505.1>:
    config.use_index = false;
    6988:	c1 43 0e 00 	mov.b	#0,	14(r1)	;r3 As==00, 0x000e

0000698c <.L102>:
  if (payload_len > 4) {
    698c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    698e:	4d 9c       	cmp.b	r12,	r13	;
    6990:	49 2c       	jc	$+148    	;abs 0x6a24

00006992 <.Loc.1509.1>:
    config.use_timestamp = true;
    6992:	d1 43 0f 00 	mov.b	#1,	15(r1)	;r3 As==01, 0x000f

00006996 <.Loc.1510.1>:
    if (config.use_index) {
    6996:	c1 93 0e 00 	cmp.b	#0,	14(r1)	;r3 As==00, 0x000e
    699a:	61 20       	jnz	$+196    	;abs 0x6a5e
    699c:	48 43       	clr.b	r8		;
    699e:	80 00 b8 6a 	mova	#27320,	r0	;0x06ab8

000069a2 <.L109>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    69a2:	67 43       	mov.b	#2,	r7	;r3 As==10
    69a4:	80 00 6c 69 	mova	#26988,	r0	;0x0696c

000069a8 <.L110>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    69a8:	4d 43       	clr.b	r13		;
    69aa:	80 00 7a 69 	mova	#27002,	r0	;0x0697a

000069ae <.L100>:
    config.use_index = true;
    69ae:	d1 43 0e 00 	mov.b	#1,	14(r1)	;r3 As==01, 0x000e

000069b2 <.Loc.1501.1>:
    config.index_start = buffer[hdr_ext+2];
    69b2:	40 18 0e 47 	movx.w	r7,	r14	;
    69b6:	ee 0a       	adda	r10,	r14	;
    69b8:	d1 4e 02 00 	mov.b	2(r14),	12(r1)	; 0x000c
    69bc:	0c 00 

000069be <.Loc.1502.1>:
    config.index_end = buffer[hdr_ext+3];
    69be:	d1 4e 03 00 	mov.b	3(r14),	13(r1)	; 0x000d
    69c2:	0d 00 
    69c4:	80 00 8c 69 	mova	#27020,	r0	;0x0698c

000069c8 <.L106>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    69c8:	0c 47       	mov	r7,	r12	;
    69ca:	3c 50 07 00 	add	#7,	r12	;
    69ce:	0c 88       	sub	r8,	r12	;
    69d0:	4c 0e       	rlam.a	#4,	r12	;
    69d2:	4c 0d       	rram.a	#4,	r12	;
    69d4:	ec 0a       	adda	r10,	r12	;
    69d6:	05 48       	mov	r8,	r5	;
    69d8:	42 18 05 55 	rpt #3 { rlax.w	r5		;
    69dc:	6c 4c       	mov.b	@r12,	r12	;
    69de:	0d 45       	mov	r5,	r13	;
    69e0:	b0 13 ce 9e 	calla	#40654		;0x09ece
    69e4:	0e 4c       	mov	r12,	r14	;
    69e6:	0f 4c       	mov	r12,	r15	;
    69e8:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    69ec:	81 dc 04 00 	bis	r12,	4(r1)	;
    69f0:	81 df 06 00 	bis	r15,	6(r1)	;

000069f4 <.Loc.1513.1>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    69f4:	0c 47       	mov	r7,	r12	;
    69f6:	3c 50 0b 00 	add	#11,	r12	;#0x000b
    69fa:	4c 0e       	rlam.a	#4,	r12	;
    69fc:	4c 0d       	rram.a	#4,	r12	;
    69fe:	ec 0a       	adda	r10,	r12	;
    6a00:	5c 4c ff ff 	mov.b	-1(r12),r12	;
    6a04:	0d 45       	mov	r5,	r13	;
    6a06:	b0 13 ce 9e 	calla	#40654		;0x09ece
    6a0a:	0e 4c       	mov	r12,	r14	;
    6a0c:	0f 4c       	mov	r12,	r15	;
    6a0e:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6a12:	81 dc 08 00 	bis	r12,	8(r1)	;
    6a16:	81 df 0a 00 	bis	r15,	10(r1)	; 0x000a

00006a1a <.Loc.1511.1>:
      for (int i = 0; i < 4; i++) {
    6a1a:	18 53       	inc	r8		;

00006a1c <.L104>:
    6a1c:	7c 40 03 00 	mov.b	#3,	r12	;
    6a20:	0c 98       	cmp	r8,	r12	;
    6a22:	d2 37       	jge	$-90     	;abs 0x69c8

00006a24 <.L103>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6a24:	cc 0a       	mova	r10,	r12	;
    6a26:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006a2a <.LVL200>:
    6a2a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006a2e <.LBB101>:
  _disable_interrupts();
    6a2e:	32 c2       	dint			
    6a30:	03 43       	nop			

00006a32 <.Loc.348.2>:
  asm volatile("nop");
    6a32:	03 43       	nop			

00006a34 <.LBE101>:
  chSysLock();
    6a34:	b0 13 50 45 	calla	#17744		;0x04550

00006a38 <.LVL202>:
  elyTelemUpdateConfigS(config);
    6a38:	cc 01       	mova	r1,	r12	;
    6a3a:	ac 00 04 00 	adda	#4,	r12	;
    6a3e:	b0 13 1e 97 	calla	#38686		;0x0971e

00006a42 <.LVL203>:
  chSysUnlock();
    6a42:	b0 13 70 45 	calla	#17776		;0x04570

00006a46 <.LBB103>:
  asm volatile("nop");
    6a46:	03 43       	nop			

00006a48 <.Loc.356.2>:
  _enable_interrupts();
    6a48:	03 43       	nop			
    6a4a:	32 d2       	eint			
    6a4c:	03 43       	nop			

00006a4e <.LBE103>:
  if (hdr.reply) {
    6a4e:	4c 49       	mov.b	r9,	r12	;
    6a50:	6c f3       	and.b	#2,	r12	;r3 As==10
    6a52:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6a54:	37 20       	jnz	$+112    	;abs 0x6ac4

00006a56 <.L97>:
}
    6a56:	a1 00 10 00 	adda	#16,	r1	;0x00010
    6a5a:	55 16       	popm.a	#6,	r10	;20-bit words
    6a5c:	10 01       	reta			;

00006a5e <.L111>:
    6a5e:	48 43       	clr.b	r8		;
    6a60:	80 00 1c 6a 	mova	#27164,	r0	;0x06a1c

00006a64 <.L107>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    6a64:	0c 47       	mov	r7,	r12	;
    6a66:	3c 50 05 00 	add	#5,	r12	;
    6a6a:	0c 88       	sub	r8,	r12	;
    6a6c:	4c 0e       	rlam.a	#4,	r12	;
    6a6e:	4c 0d       	rram.a	#4,	r12	;
    6a70:	ec 0a       	adda	r10,	r12	;
    6a72:	05 48       	mov	r8,	r5	;
    6a74:	42 18 05 55 	rpt #3 { rlax.w	r5		;
    6a78:	6c 4c       	mov.b	@r12,	r12	;
    6a7a:	0d 45       	mov	r5,	r13	;
    6a7c:	b0 13 ce 9e 	calla	#40654		;0x09ece
    6a80:	0e 4c       	mov	r12,	r14	;
    6a82:	0f 4c       	mov	r12,	r15	;
    6a84:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6a88:	81 dc 04 00 	bis	r12,	4(r1)	;
    6a8c:	81 df 06 00 	bis	r15,	6(r1)	;

00006a90 <.Loc.1519.1>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    6a90:	0c 47       	mov	r7,	r12	;
    6a92:	3c 50 09 00 	add	#9,	r12	;
    6a96:	4c 0e       	rlam.a	#4,	r12	;
    6a98:	4c 0d       	rram.a	#4,	r12	;
    6a9a:	ec 0a       	adda	r10,	r12	;
    6a9c:	5c 4c ff ff 	mov.b	-1(r12),r12	;
    6aa0:	0d 45       	mov	r5,	r13	;
    6aa2:	b0 13 ce 9e 	calla	#40654		;0x09ece
    6aa6:	0e 4c       	mov	r12,	r14	;
    6aa8:	0f 4c       	mov	r12,	r15	;
    6aaa:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    6aae:	81 dc 08 00 	bis	r12,	8(r1)	;
    6ab2:	81 df 0a 00 	bis	r15,	10(r1)	; 0x000a

00006ab6 <.Loc.1517.1>:
      for (int i = 0; i < 4; i++) {
    6ab6:	18 53       	inc	r8		;

00006ab8 <.L105>:
    6ab8:	7d 40 03 00 	mov.b	#3,	r13	;
    6abc:	0d 98       	cmp	r8,	r13	;
    6abe:	d2 37       	jge	$-90     	;abs 0x6a64
    6ac0:	80 00 24 6a 	mova	#27172,	r0	;0x06a24

00006ac4 <.L112>:
    gen_success(hdr);
    6ac4:	81 49 00 00 	mov	r9,	0(r1)	;
    6ac8:	81 46 02 00 	mov	r6,	2(r1)	;
    6acc:	cc 01       	mova	r1,	r12	;
    6ace:	b0 13 1a 69 	calla	#26906		;0x0691a

00006ad2 <.LVL211>:
}
    6ad2:	80 00 56 6a 	mova	#27222,	r0	;0x06a56

00006ad6 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6ad6:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006ad8 <.LCFI24>:
    6ad8:	b1 00 04 00 	suba	#4,	r1	;

00006adc <.LCFI25>:
    6adc:	c8 0c       	mova	r12,	r8	;
    6ade:	2a 4d       	mov	@r13,	r10	;

00006ae0 <.LVL213>:
    6ae0:	1d 4d 02 00 	mov	2(r13),	r13	;

00006ae4 <.LVL214>:
    6ae4:	09 4d       	mov	r13,	r9	;

00006ae6 <.Loc.1434.1>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6ae6:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006aea <.LVL216>:
    6aea:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006aee <.LVL217>:
  if (hdr.reply) {
    6aee:	4c 4a       	mov.b	r10,	r12	;
    6af0:	6c f3       	and.b	#2,	r12	;r3 As==10
    6af2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6af4:	10 20       	jnz	$+34     	;abs 0x6b16

00006af6 <.Loc.1441.1>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6af6:	cc 08       	mova	r8,	r12	;
    6af8:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006afc <.LVL218>:
    6afc:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006b00 <.L115>:
  bootloader = 1;
    6b00:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    6b04:	fc 19 

00006b06 <.Loc.1446.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6b06:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    6b0a:	48 a5 20 01 

00006b0e <.Loc.1448.1>:
}
    6b0e:	a1 00 04 00 	adda	#4,	r1	;
    6b12:	28 16       	popm.a	#3,	r10	;20-bit words
    6b14:	10 01       	reta			;

00006b16 <.L116>:
    gen_success(hdr);
    6b16:	81 4a 00 00 	mov	r10,	0(r1)	;
    6b1a:	81 49 02 00 	mov	r9,	2(r1)	;
    6b1e:	cc 01       	mova	r1,	r12	;
    6b20:	b0 13 1a 69 	calla	#26906		;0x0691a

00006b24 <.LVL222>:
    6b24:	80 00 00 6b 	mova	#27392,	r0	;0x06b00

00006b28 <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6b28:	4a 14       	pushm.a	#5,	r10	;20-bit words

00006b2a <.LCFI26>:
    6b2a:	04 14       	pushm.a	#1,	r4	;20-bit words

00006b2c <.LCFI27>:
    6b2c:	b1 00 08 00 	suba	#8,	r1	;

00006b30 <.LCFI28>:
    6b30:	29 4d       	mov	@r13,	r9	;

00006b32 <.LVL224>:
    6b32:	17 4d 02 00 	mov	2(r13),	r7	;

00006b36 <.LVL225>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6b36:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006b3a <.LVL226>:
    6b3a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006b3e <.LBB106>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    6b3e:	4a 43       	clr.b	r10		;
    6b40:	80 00 fc 6b 	mova	#27644,	r0	;0x06bfc

00006b44 <.L119>:
  _disable_interrupts();
    6b44:	32 c2       	dint			
    6b46:	03 43       	nop			

00006b48 <.Loc.348.2>:
  asm volatile("nop");
    6b48:	03 43       	nop			

00006b4a <.LBE107>:
    chSysLock();
    6b4a:	86 00 50 45 	mova	#17744,	r6	;0x04550
    6b4e:	46 13       	calla	r6		;

00006b50 <.LVL229>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6b50:	4d 43       	clr.b	r13		;
    6b52:	cc 01       	mova	r1,	r12	;
    6b54:	ac 00 04 00 	adda	#4,	r12	;
    6b58:	b0 13 b0 96 	calla	#38576		;0x096b0

00006b5c <.LVL230>:
    chSysUnlock();
    6b5c:	84 00 70 45 	mova	#17776,	r4	;0x04570
    6b60:	44 13       	calla	r4		;

00006b62 <.LBB109>:
  asm volatile("nop");
    6b62:	03 43       	nop			

00006b64 <.Loc.356.2>:
  _enable_interrupts();
    6b64:	03 43       	nop			
    6b66:	32 d2       	eint			
    6b68:	03 43       	nop			

00006b6a <.LBE109>:
    req->address = FRAM_FW_BASE + (i * 128); 
    6b6a:	38 01 04 00 	mova	4(r1),	r8	;
    6b6e:	0a 14       	pushm.a	#1,	r10	;20-bit words
    6b70:	40 18 3c 41 	popx.w	r12		;
    6b74:	40 18 3d 41 	popx.w	r13		;
    6b78:	b0 13 f4 9e 	calla	#40692		;0x09ef4
    6b7c:	0d 12       	push	r13		;
    6b7e:	0c 12       	push	r12		;
    6b80:	0c 16       	popm.a	#1,	r12	;20-bit words
    6b82:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6b84:	40 18 3c 41 	popx.w	r12		;
    6b88:	40 18 3d 41 	popx.w	r13		;
    6b8c:	0e 4c       	mov	r12,	r14	;
    6b8e:	3e 50 00 04 	add	#1024,	r14	;#0x0400
    6b92:	88 4e 00 00 	mov	r14,	0(r8)	;
    6b96:	0e 4d       	mov	r13,	r14	;
    6b98:	1e 63       	addc	#1,	r14	;r3 As==01
    6b9a:	88 4e 02 00 	mov	r14,	2(r8)	;

00006b9e <.Loc.1405.1>:
    req->read = 0;
    6b9e:	3c 01 04 00 	mova	4(r1),	r12	;
    6ba2:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    6ba6:	6d c3       	bic.b	#2,	r13	;r3 As==10

00006ba8 <.Loc.1406.1>:
    req->special = 1; /* write a constant value */
    6ba8:	5d d3       	bis.b	#1,	r13	;r3 As==01
    6baa:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00006bae <.Loc.1407.1>:
    req->size = 128;
    6bae:	1d 4c 04 00 	mov	4(r12),	r13	;
    6bb2:	7d f0 03 00 	and.b	#3,	r13	;
    6bb6:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    6bba:	8c 4d 04 00 	mov	r13,	4(r12)	;
    6bbe:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    6bc2:	06 00 

00006bc4 <.Loc.1408.1>:
    req->buffer = &fill_value; 
    6bc4:	00 18 fc 40 	movx.a	#54156,	8(r12)	;0x0d38c
    6bc8:	8c d3 08 00 

00006bcc <.Loc.1409.1>:
    req->callback = cancel_fw_eeprom_cb;
    6bcc:	00 18 fc 40 	movx.a	#25412,	12(r12)	;0x06344, 0x0000c
    6bd0:	44 63 0c 00 

00006bd4 <.LBB111>:
  _disable_interrupts();
    6bd4:	32 c2       	dint			
    6bd6:	03 43       	nop			

00006bd8 <.Loc.348.2>:
  asm volatile("nop");
    6bd8:	03 43       	nop			

00006bda <.LBE111>:
    chSysLock();
    6bda:	46 13       	calla	r6		;

00006bdc <.LVL233>:
    elyFramPostRequestS(req);
    6bdc:	3c 01 04 00 	mova	4(r1),	r12	;
    6be0:	b0 13 60 96 	calla	#38496		;0x09660

00006be4 <.LVL234>:
    chSysUnlock();
    6be4:	44 13       	calla	r4		;

00006be6 <.LBB113>:
  asm volatile("nop");
    6be6:	03 43       	nop			

00006be8 <.Loc.356.2>:
  _enable_interrupts();
    6be8:	03 43       	nop			
    6bea:	32 d2       	eint			
    6bec:	03 43       	nop			

00006bee <.LBB115>:
  return chSemWaitTimeout(&bsp->sem, time);
    6bee:	4d 43       	clr.b	r13		;
    6bf0:	8c 00 8e d3 	mova	#54158,	r12	;0x0d38e
    6bf4:	b0 13 ca 49 	calla	#18890		;0x049ca

00006bf8 <.LBE115>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    6bf8:	aa 00 01 00 	adda	#1,	r10	;

00006bfc <.L118>:
    6bfc:	3c 40 f7 01 	mov	#503,	r12	;#0x01f7
    6c00:	dc 0a       	cmpa	r10,	r12	;
    6c02:	a0 2f       	jc	$-190    	;abs 0x6b44

00006c04 <.LBE106>:
  if (hdr.reply) {
    6c04:	4c 49       	mov.b	r9,	r12	;
    6c06:	6c f3       	and.b	#2,	r12	;r3 As==10
    6c08:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6c0a:	05 20       	jnz	$+12     	;abs 0x6c16

00006c0c <.L117>:
}
    6c0c:	a1 00 08 00 	adda	#8,	r1	;
    6c10:	04 16       	popm.a	#1,	r4	;20-bit words
    6c12:	46 16       	popm.a	#5,	r10	;20-bit words
    6c14:	10 01       	reta			;

00006c16 <.L121>:
    gen_success(hdr);
    6c16:	81 49 00 00 	mov	r9,	0(r1)	;
    6c1a:	81 47 02 00 	mov	r7,	2(r1)	;
    6c1e:	cc 01       	mova	r1,	r12	;
    6c20:	b0 13 1a 69 	calla	#26906		;0x0691a

00006c24 <.LVL242>:
}
    6c24:	80 00 0c 6c 	mova	#27660,	r0	;0x06c0c

00006c28 <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6c28:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006c2a <.LCFI29>:
    6c2a:	b1 00 04 00 	suba	#4,	r1	;

00006c2e <.LCFI30>:
    6c2e:	c8 0c       	mova	r12,	r8	;
    6c30:	2a 4d       	mov	@r13,	r10	;

00006c32 <.LVL244>:
    6c32:	1c 4d 02 00 	mov	2(r13),	r12	;

00006c36 <.LVL245>:
    6c36:	09 4c       	mov	r12,	r9	;

00006c38 <.Loc.1024.1>:
  elyEventReset();
    6c38:	b0 13 0a 97 	calla	#38666		;0x0970a

00006c3c <.LVL247>:
  if (hdr.reply) {
    6c3c:	4c 4a       	mov.b	r10,	r12	;
    6c3e:	6c f3       	and.b	#2,	r12	;r3 As==10
    6c40:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6c42:	09 20       	jnz	$+20     	;abs 0x6c56

00006c44 <.L123>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6c44:	cc 08       	mova	r8,	r12	;
    6c46:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006c4a <.LVL249>:
    6c4a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006c4e <.LVL250>:
}
    6c4e:	a1 00 04 00 	adda	#4,	r1	;
    6c52:	28 16       	popm.a	#3,	r10	;20-bit words
    6c54:	10 01       	reta			;

00006c56 <.L124>:
    gen_success(hdr);
    6c56:	81 4a 00 00 	mov	r10,	0(r1)	;
    6c5a:	81 49 02 00 	mov	r9,	2(r1)	;
    6c5e:	cc 01       	mova	r1,	r12	;
    6c60:	b0 13 1a 69 	calla	#26906		;0x0691a

00006c64 <.LVL253>:
    6c64:	80 00 44 6c 	mova	#27716,	r0	;0x06c44

00006c68 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6c68:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006c6a <.LCFI31>:
    6c6a:	b1 00 04 00 	suba	#4,	r1	;

00006c6e <.LCFI32>:
    6c6e:	c8 0c       	mova	r12,	r8	;
    6c70:	2a 4d       	mov	@r13,	r10	;

00006c72 <.LVL255>:
    6c72:	1c 4d 02 00 	mov	2(r13),	r12	;

00006c76 <.LVL256>:
    6c76:	09 4c       	mov	r12,	r9	;

00006c78 <.Loc.871.1>:
  elyChanReset();
    6c78:	b0 13 f8 96 	calla	#38648		;0x096f8

00006c7c <.LVL258>:
  if (hdr.reply) {
    6c7c:	4c 4a       	mov.b	r10,	r12	;
    6c7e:	6c f3       	and.b	#2,	r12	;r3 As==10
    6c80:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6c82:	09 20       	jnz	$+20     	;abs 0x6c96

00006c84 <.L126>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6c84:	cc 08       	mova	r8,	r12	;
    6c86:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006c8a <.LVL260>:
    6c8a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006c8e <.LVL261>:
}
    6c8e:	a1 00 04 00 	adda	#4,	r1	;
    6c92:	28 16       	popm.a	#3,	r10	;20-bit words
    6c94:	10 01       	reta			;

00006c96 <.L127>:
    gen_success(hdr);
    6c96:	81 4a 00 00 	mov	r10,	0(r1)	;
    6c9a:	81 49 02 00 	mov	r9,	2(r1)	;
    6c9e:	cc 01       	mova	r1,	r12	;
    6ca0:	b0 13 1a 69 	calla	#26906		;0x0691a

00006ca4 <.LVL264>:
    6ca4:	80 00 84 6c 	mova	#27780,	r0	;0x06c84

00006ca8 <gen_failure>:
static void gen_failure(elysium_cmd_hdr_t hdr) {
    6ca8:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006caa <.LCFI33>:
    6caa:	b1 00 04 00 	suba	#4,	r1	;

00006cae <.LCFI34>:
    6cae:	2d 4c       	mov	@r12,	r13	;

00006cb0 <.LVL266>:
    6cb0:	1a 4c 02 00 	mov	2(r12),	r10	;

00006cb4 <.LVL267>:
    6cb4:	09 4d       	mov	r13,	r9	;

00006cb6 <.Loc.71.1>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6cb6:	b0 13 44 61 	calla	#24900		;0x06144

00006cba <.LVL269>:
    6cba:	c8 0c       	mova	r12,	r8	;

00006cbc <.Loc.72.1>:
  if (reply_buff == NULL) {
    6cbc:	9c 00 00 00 	cmpa	#0,	r12	;
    6cc0:	0b 24       	jz	$+24     	;abs 0x6cd8

00006cc2 <.Loc.77.1>:
  write_failure(reply_buff, hdr);
    6cc2:	81 49 00 00 	mov	r9,	0(r1)	;
    6cc6:	81 4a 02 00 	mov	r10,	2(r1)	;
    6cca:	cd 01       	mova	r1,	r13	;
    6ccc:	b0 13 fa 61 	calla	#25082		;0x061fa

00006cd0 <.LVL272>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    6cd0:	0d 4a       	mov	r10,	r13	;
    6cd2:	cc 08       	mova	r8,	r12	;
    6cd4:	b0 13 f2 68 	calla	#26866		;0x068f2

00006cd8 <.L128>:
}
    6cd8:	a1 00 04 00 	adda	#4,	r1	;
    6cdc:	28 16       	popm.a	#3,	r10	;20-bit words
    6cde:	10 01       	reta			;

00006ce0 <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6ce0:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006ce2 <.LCFI35>:
    6ce2:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00006ce6 <.LCFI36>:
    6ce6:	c4 0c       	mova	r12,	r4	;
    6ce8:	2e 4d       	mov	@r13,	r14	;

00006cea <.LVL275>:
    6cea:	1c 4d 02 00 	mov	2(r13),	r12	;

00006cee <.LVL276>:
    6cee:	05 4e       	mov	r14,	r5	;
    6cf0:	81 4c 04 00 	mov	r12,	4(r1)	;

00006cf4 <.Loc.1225.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6cf4:	4c 4e       	mov.b	r14,	r12	;

00006cf6 <.LVL278>:
    6cf6:	81 4c 00 00 	mov	r12,	0(r1)	;
    6cfa:	06 4c       	mov	r12,	r6	;
    6cfc:	66 f3       	and.b	#2,	r6	;r3 As==10
    6cfe:	36 f0 ff 00 	and	#255,	r6	;#0x00ff
    6d02:	06 93       	cmp	#0,	r6	;r3 As==00
    6d04:	06 24       	jz	$+14     	;abs 0x6d12
    6d06:	67 42       	mov.b	#4,	r7	;r2 As==10

00006d08 <.L131>:
  for (int i = 0; i < 4; i++) {
    6d08:	4a 43       	clr.b	r10		;

00006d0a <.LBE117>:
  uint32_t address = 0;
    6d0a:	09 4a       	mov	r10,	r9	;
    6d0c:	08 4a       	mov	r10,	r8	;

00006d0e <.LBB118>:
  for (int i = 0; i < 4; i++) {
    6d0e:	80 00 44 6d 	mova	#27972,	r0	;0x06d44

00006d12 <.L143>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6d12:	67 43       	mov.b	#2,	r7	;r3 As==10
    6d14:	80 00 08 6d 	mova	#27912,	r0	;0x06d08

00006d18 <.L133>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    6d18:	0c 47       	mov	r7,	r12	;
    6d1a:	0c 5a       	add	r10,	r12	;
    6d1c:	4c 0e       	rlam.a	#4,	r12	;
    6d1e:	4c 0d       	rram.a	#4,	r12	;
    6d20:	ec 04       	adda	r4,	r12	;
    6d22:	40 18 3e 40 	movx.w	#3,	r14	;
    6d26:	03 00 
    6d28:	40 18 0e 8a 	subx.w	r10,	r14	;
    6d2c:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    6d30:	6c 4c       	mov.b	@r12,	r12	;
    6d32:	0d 43       	clr	r13		;
    6d34:	0f 43       	clr	r15		;
    6d36:	b0 13 18 9f 	calla	#40728		;0x09f18
    6d3a:	0c d9       	bis	r9,	r12	;
    6d3c:	0d d8       	bis	r8,	r13	;
    6d3e:	09 4c       	mov	r12,	r9	;

00006d40 <.LVL283>:
    6d40:	08 4d       	mov	r13,	r8	;

00006d42 <.LVL284>:
  for (int i = 0; i < 4; i++) {
    6d42:	1a 53       	inc	r10		;

00006d44 <.L132>:
    6d44:	7d 40 03 00 	mov.b	#3,	r13	;
    6d48:	0d 9a       	cmp	r10,	r13	;
    6d4a:	e6 37       	jge	$-50     	;abs 0x6d18

00006d4c <.LBE119>:
  if (address < 0x4400 || address > 0x13FFF) {
    6d4c:	0e 49       	mov	r9,	r14	;
    6d4e:	3e 50 00 bc 	add	#-17408,r14	;#0xbc00
    6d52:	0c 48       	mov	r8,	r12	;
    6d54:	3c 63       	addc	#-1,	r12	;r3 As==11
    6d56:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d58:	15 24       	jz	$+44     	;abs 0x6d84

00006d5a <.L146>:
    if (hdr.reply) {
    6d5a:	06 93       	cmp	#0,	r6	;r3 As==00
    6d5c:	a0 24       	jz	$+322    	;abs 0x6e9e

00006d5e <.Loc.1236.1>:
      gen_failure(hdr);
    6d5e:	81 45 06 00 	mov	r5,	6(r1)	;
    6d62:	91 41 04 00 	mov	4(r1),	8(r1)	;
    6d66:	08 00 
    6d68:	cc 01       	mova	r1,	r12	;
    6d6a:	ac 00 06 00 	adda	#6,	r12	;
    6d6e:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00006d72 <.L137>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6d72:	cc 04       	mova	r4,	r12	;
    6d74:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006d78 <.LVL287>:
    6d78:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006d7c <.L130>:
}
    6d7c:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    6d80:	64 16       	popm.a	#7,	r10	;20-bit words
    6d82:	10 01       	reta			;

00006d84 <.L147>:
  if (address < 0x4400 || address > 0x13FFF) {
    6d84:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d86:	04 20       	jnz	$+10     	;abs 0x6d90
    6d88:	3f 40 ff fb 	mov	#-1025,	r15	;#0xfbff
    6d8c:	0f 9e       	cmp	r14,	r15	;
    6d8e:	e5 2b       	jnc	$-52     	;abs 0x6d5a

00006d90 <.L134>:
  uint8_t * reply_buff = elyFWGetBuffer();
    6d90:	b0 13 44 61 	calla	#24900		;0x06144

00006d94 <.LVL290>:
    6d94:	ca 0c       	mova	r12,	r10	;

00006d96 <.LVL291>:
  if (reply_buff == NULL) {
    6d96:	9c 00 00 00 	cmpa	#0,	r12	;
    6d9a:	87 24       	jz	$+272    	;abs 0x6eaa

00006d9c <.LBB120>:
  _disable_interrupts();
    6d9c:	32 c2       	dint			
    6d9e:	03 43       	nop			

00006da0 <.Loc.348.2>:
  asm volatile("nop");
    6da0:	03 43       	nop			

00006da2 <.LBE120>:
  chSysLock();
    6da2:	b0 13 50 45 	calla	#17744		;0x04550

00006da6 <.LVL292>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    6da6:	4d 43       	clr.b	r13		;
    6da8:	cc 01       	mova	r1,	r12	;
    6daa:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    6dae:	b0 13 b0 96 	calla	#38576		;0x096b0

00006db2 <.LVL293>:
  chSysUnlock();
    6db2:	b0 13 70 45 	calla	#17776		;0x04570

00006db6 <.LBB122>:
  asm volatile("nop");
    6db6:	03 43       	nop			

00006db8 <.Loc.356.2>:
  _enable_interrupts();
    6db8:	03 43       	nop			
    6dba:	32 d2       	eint			
    6dbc:	03 43       	nop			

00006dbe <.LBE122>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    6dbe:	3e 01 0a 00 	mova	10(r1),	r14	;0x0000a
    6dc2:	0c 45       	mov	r5,	r12	;
    6dc4:	5c 0f       	rrum	#4,	r12	;
    6dc6:	5c 0f       	rrum	#4,	r12	;
    6dc8:	0c 86       	sub	r6,	r12	;
    6dca:	40 18 91 b3 	bitx.w	#1,	0(r1)	;r3 As==01
    6dce:	00 00 
    6dd0:	73 24       	jz	$+232    	;abs 0x6eb8
    6dd2:	6d 43       	mov.b	#2,	r13	;r3 As==10

00006dd4 <.L140>:
    6dd4:	0c 8d       	sub	r13,	r12	;
    6dd6:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc
    6dda:	0d 4c       	mov	r12,	r13	;
    6ddc:	4d 0e       	rlam.a	#4,	r13	;
    6dde:	4d 0d       	rram.a	#4,	r13	;
    6de0:	80 18 7d f0 	andx.a	#131071,r13	;0x1ffff
    6de4:	ff ff 
    6de6:	71 0d 00 00 	mova	r13,	0(r1)	;
    6dea:	0c 4d       	mov	r13,	r12	;
    6dec:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    6df0:	1d 4e 04 00 	mov	4(r14),	r13	;
    6df4:	7d f0 03 00 	and.b	#3,	r13	;
    6df8:	0d dc       	bis	r12,	r13	;
    6dfa:	8e 4d 04 00 	mov	r13,	4(r14)	;
    6dfe:	2d 41       	mov	@r1,	r13	;
    6e00:	5d 03       	rrum	#1,	r13	;
    6e02:	4c 18 0d 11 	rpt #13 { rrax.w	r13		;
    6e06:	5c 4e 06 00 	mov.b	6(r14),	r12	;
    6e0a:	7c f0 fc ff 	and.b	#-4,	r12	;#0xfffc
    6e0e:	4d dc       	bis.b	r12,	r13	;
    6e10:	0f 01       	mova	@r1,	r15	;
    6e12:	0f 14       	pushm.a	#1,	r15	;20-bit words
    6e14:	0c 17       	popm	#1,	r12	;16-bit words
    6e16:	0c 17       	popm	#1,	r12	;16-bit words
    6e18:	5c f3       	and.b	#1,	r12	;r3 As==01
    6e1a:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    6e1e:	6d c2       	bic.b	#4,	r13	;r2 As==10
    6e20:	4d dc       	bis.b	r12,	r13	;
    6e22:	ce 4d 06 00 	mov.b	r13,	6(r14)	;

00006e26 <.Loc.1260.1>:
  memcpy(reply_buff, buffer + hdr_ext + 4, req->size);
    6e26:	40 18 0c 47 	movx.w	r7,	r12	;
    6e2a:	ac 00 04 00 	adda	#4,	r12	;
    6e2e:	ce 0f       	mova	r15,	r14	;
    6e30:	cd 04       	mova	r4,	r13	;
    6e32:	ed 0c       	adda	r12,	r13	;
    6e34:	cc 0a       	mova	r10,	r12	;
    6e36:	b0 13 f4 9f 	calla	#40948		;0x09ff4

00006e3a <.LVL295>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6e3a:	cc 04       	mova	r4,	r12	;
    6e3c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006e40 <.LVL296>:
    6e40:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006e44 <.LVL297>:
  stored_hdr = hdr;
    6e44:	40 18 82 45 	movx.w	r5,	&0xfd39a;
    6e48:	9a d3 
    6e4a:	40 18 92 41 	movx.w	4(r1),	&0xfd39c;
    6e4e:	04 00 9c d3 

00006e52 <.Loc.1267.1>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    6e52:	3c 01 0a 00 	mova	10(r1),	r12	;0x0000a
    6e56:	39 50 00 c0 	add	#-16384,r9	;#0xc000

00006e5a <.LVL298>:
    6e5a:	8c 49 00 00 	mov	r9,	0(r12)	;
    6e5e:	08 63       	adc	r8		;
    6e60:	8c 48 02 00 	mov	r8,	2(r12)	;

00006e64 <.Loc.1268.1>:
  req->read = 0;
    6e64:	3c 01 0a 00 	mova	10(r1),	r12	;0x0000a
    6e68:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

00006e6c <.Loc.1269.1>:
  req->buffer = reply_buff;
    6e6c:	7c 0a 08 00 	mova	r10,	8(r12)	;

00006e70 <.Loc.1270.1>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6e70:	06 93       	cmp	#0,	r6	;r3 As==00
    6e72:	25 20       	jnz	$+76     	;abs 0x6ebe

00006e74 <.Loc.1270.1>:
    6e74:	8e 00 2a 63 	mova	#25386,	r14	;0x0632a

00006e78 <.L141>:
    6e78:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

00006e7c <.LBB124>:
  _disable_interrupts();
    6e7c:	32 c2       	dint			
    6e7e:	03 43       	nop			

00006e80 <.Loc.348.2>:
  asm volatile("nop");
    6e80:	03 43       	nop			

00006e82 <.LBE124>:
  chSysLock();
    6e82:	b0 13 50 45 	calla	#17744		;0x04550

00006e86 <.LVL300>:
  elyFramPostRequestS(req);
    6e86:	3c 01 0a 00 	mova	10(r1),	r12	;0x0000a
    6e8a:	b0 13 60 96 	calla	#38496		;0x09660

00006e8e <.LVL301>:
  chSysUnlock();
    6e8e:	b0 13 70 45 	calla	#17776		;0x04570

00006e92 <.LBB126>:
  asm volatile("nop");
    6e92:	03 43       	nop			

00006e94 <.Loc.356.2>:
  _enable_interrupts();
    6e94:	03 43       	nop			
    6e96:	32 d2       	eint			
    6e98:	03 43       	nop			

00006e9a <.LBE126>:
    6e9a:	80 00 7c 6d 	mova	#28028,	r0	;0x06d7c

00006e9e <.L136>:
      elyErrorSignal(ErrCmdFailure);
    6e9e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6ea2:	b0 13 fa 96 	calla	#38650		;0x096fa

00006ea6 <.LVL304>:
    6ea6:	80 00 72 6d 	mova	#28018,	r0	;0x06d72

00006eaa <.L148>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    6eaa:	cc 04       	mova	r4,	r12	;
    6eac:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006eb0 <.LVL306>:
    6eb0:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006eb4 <.LVL307>:
    return;
    6eb4:	80 00 7c 6d 	mova	#28028,	r0	;0x06d7c

00006eb8 <.L144>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    6eb8:	4d 43       	clr.b	r13		;
    6eba:	80 00 d4 6d 	mova	#28116,	r0	;0x06dd4

00006ebe <.L149>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    6ebe:	8e 00 c8 68 	mova	#26824,	r14	;0x068c8
    6ec2:	80 00 78 6e 	mova	#28280,	r0	;0x06e78

00006ec6 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6ec6:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006ec8 <.LCFI37>:
    6ec8:	b1 00 04 00 	suba	#4,	r1	;

00006ecc <.LCFI38>:
    6ecc:	29 4d       	mov	@r13,	r9	;

00006ece <.LVL310>:
    6ece:	18 4d 02 00 	mov	2(r13),	r8	;

00006ed2 <.LVL311>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ed2:	4a 49       	mov.b	r9,	r10	;
    6ed4:	6a f3       	and.b	#2,	r10	;r3 As==10
    6ed6:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    6eda:	0a 93       	cmp	#0,	r10	;r3 As==00
    6edc:	1a 24       	jz	$+54     	;abs 0x6f12
    6ede:	6e 42       	mov.b	#4,	r14	;r2 As==10

00006ee0 <.L151>:
  uint8_t err = buffer[hdr_ext];
    6ee0:	40 18 0e 4e 	movx.w	r14,	r14	;
    6ee4:	ee 0c       	adda	r12,	r14	;

00006ee6 <.LVL313>:
    6ee6:	67 4e       	mov.b	@r14,	r7	;

00006ee8 <.LVL314>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6ee8:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006eec <.LVL315>:
    6eec:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006ef0 <.LVL316>:
  if (err > ELY_ALL_ERRORS) {
    6ef0:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    6ef4:	4c 97       	cmp.b	r7,	r12	;
    6ef6:	16 2c       	jc	$+46     	;abs 0x6f24

00006ef8 <.Loc.1187.1>:
    if (hdr.reply) {
    6ef8:	0a 93       	cmp	#0,	r10	;r3 As==00
    6efa:	0e 24       	jz	$+30     	;abs 0x6f18

00006efc <.Loc.1189.1>:
      gen_failure(hdr);
    6efc:	81 49 00 00 	mov	r9,	0(r1)	;
    6f00:	81 48 02 00 	mov	r8,	2(r1)	;
    6f04:	cc 01       	mova	r1,	r12	;
    6f06:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00006f0a <.L150>:
}
    6f0a:	a1 00 04 00 	adda	#4,	r1	;
    6f0e:	37 16       	popm.a	#4,	r10	;20-bit words
    6f10:	10 01       	reta			;

00006f12 <.L155>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f12:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6f14:	80 00 e0 6e 	mova	#28384,	r0	;0x06ee0

00006f18 <.L153>:
      elyErrorSignal(ErrCmdFailure);
    6f18:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6f1c:	b0 13 fa 96 	calla	#38650		;0x096fa

00006f20 <.LVL322>:
    6f20:	80 00 0a 6f 	mova	#28426,	r0	;0x06f0a

00006f24 <.L152>:
  bank0w[RegErrLogLvl] = err;
    6f24:	2c 01 3a 04 	mova	&66618,	r12	;0x1043a
    6f28:	cc 47 4d 00 	mov.b	r7,	77(r12)	; 0x004d

00006f2c <.LBB128>:
  _disable_interrupts();
    6f2c:	32 c2       	dint			
    6f2e:	03 43       	nop			

00006f30 <.Loc.348.2>:
  asm volatile("nop");
    6f30:	03 43       	nop			

00006f32 <.LBE128>:
  chSysLock();
    6f32:	b0 13 50 45 	calla	#17744		;0x04550

00006f36 <.LVL323>:
  elyErrorSetLogLvlS(err);
    6f36:	4c 47       	mov.b	r7,	r12	;
    6f38:	b0 13 fe 96 	calla	#38654		;0x096fe

00006f3c <.LVL324>:
  chSysUnlock();
    6f3c:	b0 13 70 45 	calla	#17776		;0x04570

00006f40 <.LBB130>:
  asm volatile("nop");
    6f40:	03 43       	nop			

00006f42 <.Loc.356.2>:
  _enable_interrupts();
    6f42:	03 43       	nop			
    6f44:	32 d2       	eint			
    6f46:	03 43       	nop			

00006f48 <.LBE130>:
  if (hdr.reply) {
    6f48:	0a 93       	cmp	#0,	r10	;r3 As==00
    6f4a:	df 27       	jz	$-64     	;abs 0x6f0a

00006f4c <.Loc.1205.1>:
    gen_success(hdr);
    6f4c:	81 49 00 00 	mov	r9,	0(r1)	;
    6f50:	81 48 02 00 	mov	r8,	2(r1)	;
    6f54:	cc 01       	mova	r1,	r12	;
    6f56:	b0 13 1a 69 	calla	#26906		;0x0691a

00006f5a <.LVL327>:
    6f5a:	80 00 0a 6f 	mova	#28426,	r0	;0x06f0a

00006f5e <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6f5e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006f60 <.LCFI39>:
    6f60:	b1 00 04 00 	suba	#4,	r1	;

00006f64 <.LCFI40>:
    6f64:	29 4d       	mov	@r13,	r9	;

00006f66 <.LVL329>:
    6f66:	18 4d 02 00 	mov	2(r13),	r8	;

00006f6a <.LVL330>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f6a:	4a 49       	mov.b	r9,	r10	;
    6f6c:	6a f3       	and.b	#2,	r10	;r3 As==10
    6f6e:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    6f72:	0a 93       	cmp	#0,	r10	;r3 As==00
    6f74:	1a 24       	jz	$+54     	;abs 0x6faa
    6f76:	6e 42       	mov.b	#4,	r14	;r2 As==10

00006f78 <.L157>:
  uint8_t err = buffer[hdr_ext];
    6f78:	40 18 0e 4e 	movx.w	r14,	r14	;
    6f7c:	ee 0c       	adda	r12,	r14	;

00006f7e <.LVL332>:
    6f7e:	67 4e       	mov.b	@r14,	r7	;

00006f80 <.LVL333>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    6f80:	b0 13 ec 9d 	calla	#40428		;0x09dec

00006f84 <.LVL334>:
    6f84:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00006f88 <.LVL335>:
  if (err > ELY_ALL_ERRORS) {
    6f88:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    6f8c:	4c 97       	cmp.b	r7,	r12	;
    6f8e:	16 2c       	jc	$+46     	;abs 0x6fbc

00006f90 <.Loc.1128.1>:
    if (hdr.reply) {
    6f90:	0a 93       	cmp	#0,	r10	;r3 As==00
    6f92:	0e 24       	jz	$+30     	;abs 0x6fb0

00006f94 <.Loc.1130.1>:
      gen_failure(hdr);
    6f94:	81 49 00 00 	mov	r9,	0(r1)	;
    6f98:	81 48 02 00 	mov	r8,	2(r1)	;
    6f9c:	cc 01       	mova	r1,	r12	;
    6f9e:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00006fa2 <.L156>:
}
    6fa2:	a1 00 04 00 	adda	#4,	r1	;
    6fa6:	37 16       	popm.a	#4,	r10	;20-bit words
    6fa8:	10 01       	reta			;

00006faa <.L161>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6faa:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6fac:	80 00 78 6f 	mova	#28536,	r0	;0x06f78

00006fb0 <.L159>:
      elyErrorSignal(ErrCmdFailure);
    6fb0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    6fb4:	b0 13 fa 96 	calla	#38650		;0x096fa

00006fb8 <.LVL341>:
    6fb8:	80 00 a2 6f 	mova	#28578,	r0	;0x06fa2

00006fbc <.L158>:
  bank0w[RegErrRptLvl] = err;
    6fbc:	2c 01 3a 04 	mova	&66618,	r12	;0x1043a
    6fc0:	cc 47 4c 00 	mov.b	r7,	76(r12)	; 0x004c

00006fc4 <.LBB132>:
  _disable_interrupts();
    6fc4:	32 c2       	dint			
    6fc6:	03 43       	nop			

00006fc8 <.Loc.348.2>:
  asm volatile("nop");
    6fc8:	03 43       	nop			

00006fca <.LBE132>:
  chSysLock();
    6fca:	b0 13 50 45 	calla	#17744		;0x04550

00006fce <.LVL342>:
  elyErrorSetRptLvlS(err);
    6fce:	4c 47       	mov.b	r7,	r12	;
    6fd0:	b0 13 fc 96 	calla	#38652		;0x096fc

00006fd4 <.LVL343>:
  chSysUnlock();
    6fd4:	b0 13 70 45 	calla	#17776		;0x04570

00006fd8 <.LBB134>:
  asm volatile("nop");
    6fd8:	03 43       	nop			

00006fda <.Loc.356.2>:
  _enable_interrupts();
    6fda:	03 43       	nop			
    6fdc:	32 d2       	eint			
    6fde:	03 43       	nop			

00006fe0 <.LBE134>:
  if (hdr.reply) {
    6fe0:	0a 93       	cmp	#0,	r10	;r3 As==00
    6fe2:	df 27       	jz	$-64     	;abs 0x6fa2

00006fe4 <.Loc.1146.1>:
    gen_success(hdr);
    6fe4:	81 49 00 00 	mov	r9,	0(r1)	;
    6fe8:	81 48 02 00 	mov	r8,	2(r1)	;
    6fec:	cc 01       	mova	r1,	r12	;
    6fee:	b0 13 1a 69 	calla	#26906		;0x0691a

00006ff2 <.LVL346>:
    6ff2:	80 00 a2 6f 	mova	#28578,	r0	;0x06fa2

00006ff6 <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6ff6:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006ff8 <.LCFI41>:
    6ff8:	b1 00 04 00 	suba	#4,	r1	;

00006ffc <.LCFI42>:
    6ffc:	c8 0c       	mova	r12,	r8	;
    6ffe:	27 4d       	mov	@r13,	r7	;

00007000 <.LVL348>:
    7000:	15 4d 02 00 	mov	2(r13),	r5	;

00007004 <.LVL349>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7004:	0d 47       	mov	r7,	r13	;
    7006:	5d 0f       	rrum	#4,	r13	;
    7008:	5d 0f       	rrum	#4,	r13	;
    700a:	4c 47       	mov.b	r7,	r12	;

0000700c <.LVL350>:
    700c:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    7010:	1b 24       	jz	$+56     	;abs 0x7048
    7012:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007014 <.L163>:
    7014:	6c f3       	and.b	#2,	r12	;r3 As==10
    7016:	46 4c       	mov.b	r12,	r6	;
    7018:	4c 5e       	add.b	r14,	r12	;
    701a:	4d 8c       	sub.b	r12,	r13	;
    701c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007020 <.LVL351>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7020:	06 93       	cmp	#0,	r6	;r3 As==00
    7022:	15 24       	jz	$+44     	;abs 0x704e

00007024 <.Loc.992.1>:
    7024:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007026 <.L164>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7026:	0a 4c       	mov	r12,	r10	;

00007028 <.L165>:
    7028:	09 4d       	mov	r13,	r9	;
    702a:	09 5a       	add	r10,	r9	;
    702c:	0c 99       	cmp	r9,	r12	;
    702e:	31 34       	jge	$+100    	;abs 0x7092

00007030 <.Loc.996.1>:
    if (buffer[i] < 0xC0) {
    7030:	0f 4c       	mov	r12,	r15	;
    7032:	4f 0e       	rlam.a	#4,	r15	;
    7034:	4f 0d       	rram.a	#4,	r15	;
    7036:	ce 0f       	mova	r15,	r14	;
    7038:	ee 08       	adda	r8,	r14	;
    703a:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    703e:	6f 9e       	cmp.b	@r14,	r15	;
    7040:	09 2c       	jc	$+20     	;abs 0x7054

00007042 <.Loc.994.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7042:	1c 53       	inc	r12		;
    7044:	80 00 28 70 	mova	#28712,	r0	;0x07028

00007048 <.L174>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7048:	4e 43       	clr.b	r14		;
    704a:	80 00 14 70 	mova	#28692,	r0	;0x07014

0000704e <.L175>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    704e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7050:	80 00 26 70 	mova	#28710,	r0	;0x07026

00007054 <.L176>:
      if (hdr.reply) {
    7054:	06 93       	cmp	#0,	r6	;r3 As==00
    7056:	0e 24       	jz	$+30     	;abs 0x7074

00007058 <.Loc.999.1>:
        gen_failure(hdr);
    7058:	81 47 00 00 	mov	r7,	0(r1)	;
    705c:	81 45 02 00 	mov	r5,	2(r1)	;
    7060:	cc 01       	mova	r1,	r12	;

00007062 <.LVL359>:
    7062:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007066 <.L168>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7066:	cc 08       	mova	r8,	r12	;
    7068:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000706c <.LVL361>:
    706c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007070 <.LVL362>:
      return;
    7070:	80 00 a4 70 	mova	#28836,	r0	;0x070a4

00007074 <.L167>:
        elyErrorSignal(ErrCmdFailure);
    7074:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007078 <.LVL364>:
    7078:	b0 13 fa 96 	calla	#38650		;0x096fa

0000707c <.LVL365>:
    707c:	80 00 66 70 	mova	#28774,	r0	;0x07066

00007080 <.L172>:
    elyEventUnlog(buffer[i]);
    7080:	0d 4a       	mov	r10,	r13	;
    7082:	4d 0e       	rlam.a	#4,	r13	;
    7084:	4d 0d       	rram.a	#4,	r13	;
    7086:	cc 0d       	mova	r13,	r12	;
    7088:	ec 08       	adda	r8,	r12	;
    708a:	6c 4c       	mov.b	@r12,	r12	;
    708c:	b0 13 08 97 	calla	#38664		;0x09708

00007090 <.LVL367>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7090:	1a 53       	inc	r10		;

00007092 <.L171>:
    7092:	0a 99       	cmp	r9,	r10	;
    7094:	f5 3b       	jl	$-20     	;abs 0x7080

00007096 <.LBE138>:
  if (hdr.reply) {
    7096:	06 93       	cmp	#0,	r6	;r3 As==00
    7098:	09 20       	jnz	$+20     	;abs 0x70ac

0000709a <.L173>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    709a:	cc 08       	mova	r8,	r12	;
    709c:	b0 13 ec 9d 	calla	#40428		;0x09dec

000070a0 <.LVL370>:
    70a0:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000070a4 <.L162>:
}
    70a4:	a1 00 04 00 	adda	#4,	r1	;
    70a8:	55 16       	popm.a	#6,	r10	;20-bit words
    70aa:	10 01       	reta			;

000070ac <.L177>:
    gen_success(hdr);
    70ac:	81 47 00 00 	mov	r7,	0(r1)	;
    70b0:	81 45 02 00 	mov	r5,	2(r1)	;
    70b4:	cc 01       	mova	r1,	r12	;
    70b6:	b0 13 1a 69 	calla	#26906		;0x0691a

000070ba <.LVL374>:
    70ba:	80 00 9a 70 	mova	#28826,	r0	;0x0709a

000070be <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    70be:	5a 14       	pushm.a	#6,	r10	;20-bit words

000070c0 <.LCFI43>:
    70c0:	b1 00 04 00 	suba	#4,	r1	;

000070c4 <.LCFI44>:
    70c4:	c8 0c       	mova	r12,	r8	;
    70c6:	27 4d       	mov	@r13,	r7	;

000070c8 <.LVL376>:
    70c8:	15 4d 02 00 	mov	2(r13),	r5	;

000070cc <.LVL377>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    70cc:	0d 47       	mov	r7,	r13	;
    70ce:	5d 0f       	rrum	#4,	r13	;
    70d0:	5d 0f       	rrum	#4,	r13	;
    70d2:	4c 47       	mov.b	r7,	r12	;

000070d4 <.LVL378>:
    70d4:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    70d8:	2b 24       	jz	$+88     	;abs 0x7130
    70da:	6e 43       	mov.b	#2,	r14	;r3 As==10

000070dc <.L179>:
    70dc:	6c f3       	and.b	#2,	r12	;r3 As==10
    70de:	46 4c       	mov.b	r12,	r6	;
    70e0:	4c 5e       	add.b	r14,	r12	;
    70e2:	4d 8c       	sub.b	r12,	r13	;
    70e4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000070e8 <.LVL379>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    70e8:	06 93       	cmp	#0,	r6	;r3 As==00
    70ea:	25 24       	jz	$+76     	;abs 0x7136

000070ec <.Loc.958.1>:
    70ec:	6c 42       	mov.b	#4,	r12	;r2 As==10

000070ee <.L180>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    70ee:	09 4c       	mov	r12,	r9	;

000070f0 <.L181>:
    70f0:	0a 4d       	mov	r13,	r10	;
    70f2:	0a 59       	add	r9,	r10	;
    70f4:	0c 9a       	cmp	r10,	r12	;
    70f6:	43 34       	jge	$+136    	;abs 0x717e

000070f8 <.Loc.961.1>:
    if ((buffer[i] < 0xC0) || 
    70f8:	0a 4c       	mov	r12,	r10	;
    70fa:	4a 0e       	rlam.a	#4,	r10	;
    70fc:	4a 0d       	rram.a	#4,	r10	;
    70fe:	ce 0a       	mova	r10,	r14	;
    7100:	ee 08       	adda	r8,	r14	;
    7102:	6e 4e       	mov.b	@r14,	r14	;
    7104:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    7108:	4f 9e       	cmp.b	r14,	r15	;
    710a:	18 2c       	jc	$+50     	;abs 0x713c

0000710c <.Loc.962.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    710c:	4f 4e       	mov.b	r14,	r15	;
    710e:	7f 50 2d 00 	add.b	#45,	r15	;#0x002d

00007112 <.Loc.961.1>:
    if ((buffer[i] < 0xC0) || 
    7112:	7a 40 0c 00 	mov.b	#12,	r10	;#0x000c
    7116:	4a 9f       	cmp.b	r15,	r10	;
    7118:	11 2c       	jc	$+36     	;abs 0x713c

0000711a <.Loc.963.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    711a:	7f 50 f0 ff 	add.b	#-16,	r15	;#0xfff0

0000711e <.Loc.962.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    711e:	4a 9f       	cmp.b	r15,	r10	;
    7120:	0d 2c       	jc	$+28     	;abs 0x713c

00007122 <.Loc.963.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7122:	7f 40 f2 ff 	mov.b	#-14,	r15	;#0xfff2
    7126:	4f 9e       	cmp.b	r14,	r15	;
    7128:	09 28       	jnc	$+20     	;abs 0x713c

0000712a <.Loc.960.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    712a:	1c 53       	inc	r12		;
    712c:	80 00 f0 70 	mova	#28912,	r0	;0x070f0

00007130 <.L191>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7130:	4e 43       	clr.b	r14		;
    7132:	80 00 dc 70 	mova	#28892,	r0	;0x070dc

00007136 <.L192>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7136:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7138:	80 00 ee 70 	mova	#28910,	r0	;0x070ee

0000713c <.L182>:
      if (hdr.reply) {
    713c:	06 93       	cmp	#0,	r6	;r3 As==00
    713e:	10 24       	jz	$+34     	;abs 0x7160

00007140 <.Loc.967.1>:
        gen_failure(hdr);
    7140:	81 47 00 00 	mov	r7,	0(r1)	;
    7144:	81 45 02 00 	mov	r5,	2(r1)	;
    7148:	cc 01       	mova	r1,	r12	;

0000714a <.LVL387>:
    714a:	b0 13 a8 6c 	calla	#27816		;0x06ca8

0000714e <.L185>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    714e:	cc 08       	mova	r8,	r12	;
    7150:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007154 <.LVL389>:
    7154:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007158 <.L178>:
}
    7158:	a1 00 04 00 	adda	#4,	r1	;
    715c:	55 16       	popm.a	#6,	r10	;20-bit words
    715e:	10 01       	reta			;

00007160 <.L184>:
        elyErrorSignal(ErrCmdFailure);
    7160:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007164 <.LVL392>:
    7164:	b0 13 fa 96 	calla	#38650		;0x096fa

00007168 <.LVL393>:
    7168:	80 00 4e 71 	mova	#29006,	r0	;0x0714e

0000716c <.L189>:
    elyEventLog(buffer[i]);
    716c:	0d 49       	mov	r9,	r13	;
    716e:	4d 0e       	rlam.a	#4,	r13	;
    7170:	4d 0d       	rram.a	#4,	r13	;
    7172:	cc 0d       	mova	r13,	r12	;
    7174:	ec 08       	adda	r8,	r12	;
    7176:	6c 4c       	mov.b	@r12,	r12	;
    7178:	b0 13 06 97 	calla	#38662		;0x09706

0000717c <.LVL395>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    717c:	19 53       	inc	r9		;

0000717e <.L188>:
    717e:	09 9a       	cmp	r10,	r9	;
    7180:	f5 3b       	jl	$-20     	;abs 0x716c

00007182 <.LBE142>:
  if (hdr.reply) {
    7182:	06 93       	cmp	#0,	r6	;r3 As==00
    7184:	07 20       	jnz	$+16     	;abs 0x7194

00007186 <.L190>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7186:	cc 08       	mova	r8,	r12	;
    7188:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000718c <.LVL398>:
    718c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007190 <.LVL399>:
    7190:	80 00 58 71 	mova	#29016,	r0	;0x07158

00007194 <.L193>:
    gen_success(hdr);
    7194:	81 47 00 00 	mov	r7,	0(r1)	;
    7198:	81 45 02 00 	mov	r5,	2(r1)	;
    719c:	cc 01       	mova	r1,	r12	;
    719e:	b0 13 1a 69 	calla	#26906		;0x0691a

000071a2 <.LVL402>:
    71a2:	80 00 86 71 	mova	#29062,	r0	;0x07186

000071a6 <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    71a6:	5a 14       	pushm.a	#6,	r10	;20-bit words

000071a8 <.LCFI45>:
    71a8:	b1 00 04 00 	suba	#4,	r1	;

000071ac <.LCFI46>:
    71ac:	c8 0c       	mova	r12,	r8	;
    71ae:	27 4d       	mov	@r13,	r7	;

000071b0 <.LVL404>:
    71b0:	15 4d 02 00 	mov	2(r13),	r5	;

000071b4 <.LVL405>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    71b4:	0d 47       	mov	r7,	r13	;
    71b6:	5d 0f       	rrum	#4,	r13	;
    71b8:	5d 0f       	rrum	#4,	r13	;
    71ba:	4c 47       	mov.b	r7,	r12	;

000071bc <.LVL406>:
    71bc:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    71c0:	1b 24       	jz	$+56     	;abs 0x71f8
    71c2:	6e 43       	mov.b	#2,	r14	;r3 As==10

000071c4 <.L195>:
    71c4:	6c f3       	and.b	#2,	r12	;r3 As==10
    71c6:	46 4c       	mov.b	r12,	r6	;
    71c8:	4c 5e       	add.b	r14,	r12	;
    71ca:	4d 8c       	sub.b	r12,	r13	;
    71cc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000071d0 <.LVL407>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    71d0:	06 93       	cmp	#0,	r6	;r3 As==00
    71d2:	15 24       	jz	$+44     	;abs 0x71fe

000071d4 <.Loc.927.1>:
    71d4:	6c 42       	mov.b	#4,	r12	;r2 As==10

000071d6 <.L196>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    71d6:	0a 4c       	mov	r12,	r10	;

000071d8 <.L197>:
    71d8:	09 4d       	mov	r13,	r9	;
    71da:	09 5a       	add	r10,	r9	;
    71dc:	0c 99       	cmp	r9,	r12	;
    71de:	31 34       	jge	$+100    	;abs 0x7242

000071e0 <.Loc.930.1>:
    if (buffer[i] < 0xC0) {
    71e0:	0f 4c       	mov	r12,	r15	;
    71e2:	4f 0e       	rlam.a	#4,	r15	;
    71e4:	4f 0d       	rram.a	#4,	r15	;
    71e6:	ce 0f       	mova	r15,	r14	;
    71e8:	ee 08       	adda	r8,	r14	;
    71ea:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    71ee:	6f 9e       	cmp.b	@r14,	r15	;
    71f0:	09 2c       	jc	$+20     	;abs 0x7204

000071f2 <.Loc.929.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    71f2:	1c 53       	inc	r12		;
    71f4:	80 00 d8 71 	mova	#29144,	r0	;0x071d8

000071f8 <.L206>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    71f8:	4e 43       	clr.b	r14		;
    71fa:	80 00 c4 71 	mova	#29124,	r0	;0x071c4

000071fe <.L207>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    71fe:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7200:	80 00 d6 71 	mova	#29142,	r0	;0x071d6

00007204 <.L208>:
      if (hdr.reply) {
    7204:	06 93       	cmp	#0,	r6	;r3 As==00
    7206:	0e 24       	jz	$+30     	;abs 0x7224

00007208 <.Loc.933.1>:
        gen_failure(hdr);
    7208:	81 47 00 00 	mov	r7,	0(r1)	;
    720c:	81 45 02 00 	mov	r5,	2(r1)	;
    7210:	cc 01       	mova	r1,	r12	;

00007212 <.LVL415>:
    7212:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007216 <.L200>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7216:	cc 08       	mova	r8,	r12	;
    7218:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000721c <.LVL417>:
    721c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007220 <.LVL418>:
      return;
    7220:	80 00 54 72 	mova	#29268,	r0	;0x07254

00007224 <.L199>:
        elyErrorSignal(ErrCmdFailure);
    7224:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007228 <.LVL420>:
    7228:	b0 13 fa 96 	calla	#38650		;0x096fa

0000722c <.LVL421>:
    722c:	80 00 16 72 	mova	#29206,	r0	;0x07216

00007230 <.L204>:
    elyEventUnsubscribe(buffer[i]);
    7230:	0d 4a       	mov	r10,	r13	;
    7232:	4d 0e       	rlam.a	#4,	r13	;
    7234:	4d 0d       	rram.a	#4,	r13	;
    7236:	cc 0d       	mova	r13,	r12	;
    7238:	ec 08       	adda	r8,	r12	;
    723a:	6c 4c       	mov.b	@r12,	r12	;
    723c:	b0 13 04 97 	calla	#38660		;0x09704

00007240 <.LVL423>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7240:	1a 53       	inc	r10		;

00007242 <.L203>:
    7242:	0a 99       	cmp	r9,	r10	;
    7244:	f5 3b       	jl	$-20     	;abs 0x7230

00007246 <.LBE145>:
  if (hdr.reply) {
    7246:	06 93       	cmp	#0,	r6	;r3 As==00
    7248:	09 20       	jnz	$+20     	;abs 0x725c

0000724a <.L205>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    724a:	cc 08       	mova	r8,	r12	;
    724c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007250 <.LVL426>:
    7250:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007254 <.L194>:
}
    7254:	a1 00 04 00 	adda	#4,	r1	;
    7258:	55 16       	popm.a	#6,	r10	;20-bit words
    725a:	10 01       	reta			;

0000725c <.L209>:
    gen_success(hdr);
    725c:	81 47 00 00 	mov	r7,	0(r1)	;
    7260:	81 45 02 00 	mov	r5,	2(r1)	;
    7264:	cc 01       	mova	r1,	r12	;
    7266:	b0 13 1a 69 	calla	#26906		;0x0691a

0000726a <.LVL430>:
    726a:	80 00 4a 72 	mova	#29258,	r0	;0x0724a

0000726e <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    726e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007270 <.LCFI47>:
    7270:	b1 00 04 00 	suba	#4,	r1	;

00007274 <.LCFI48>:
    7274:	c8 0c       	mova	r12,	r8	;
    7276:	27 4d       	mov	@r13,	r7	;

00007278 <.LVL432>:
    7278:	14 4d 02 00 	mov	2(r13),	r4	;

0000727c <.LVL433>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    727c:	0d 47       	mov	r7,	r13	;
    727e:	5d 0f       	rrum	#4,	r13	;
    7280:	5d 0f       	rrum	#4,	r13	;
    7282:	4c 47       	mov.b	r7,	r12	;

00007284 <.LVL434>:
    7284:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    7288:	2b 24       	jz	$+88     	;abs 0x72e0
    728a:	6e 43       	mov.b	#2,	r14	;r3 As==10

0000728c <.L211>:
    728c:	6c f3       	and.b	#2,	r12	;r3 As==10
    728e:	46 4c       	mov.b	r12,	r6	;
    7290:	4c 5e       	add.b	r14,	r12	;
    7292:	4d 8c       	sub.b	r12,	r13	;
    7294:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00007298 <.LVL435>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7298:	06 93       	cmp	#0,	r6	;r3 As==00
    729a:	25 24       	jz	$+76     	;abs 0x72e6

0000729c <.Loc.884.1>:
    729c:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000729e <.L212>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    729e:	09 4c       	mov	r12,	r9	;

000072a0 <.L213>:
    72a0:	0a 4d       	mov	r13,	r10	;
    72a2:	0a 59       	add	r9,	r10	;
    72a4:	0c 9a       	cmp	r10,	r12	;
    72a6:	3a 34       	jge	$+118    	;abs 0x731c

000072a8 <.Loc.887.1>:
    if ((buffer[i] < 0xC0) || 
    72a8:	0a 4c       	mov	r12,	r10	;
    72aa:	4a 0e       	rlam.a	#4,	r10	;
    72ac:	4a 0d       	rram.a	#4,	r10	;
    72ae:	ce 0a       	mova	r10,	r14	;
    72b0:	ee 08       	adda	r8,	r14	;
    72b2:	6e 4e       	mov.b	@r14,	r14	;
    72b4:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    72b8:	4f 9e       	cmp.b	r14,	r15	;
    72ba:	18 2c       	jc	$+50     	;abs 0x72ec

000072bc <.Loc.888.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    72bc:	4f 4e       	mov.b	r14,	r15	;
    72be:	7f 50 2d 00 	add.b	#45,	r15	;#0x002d

000072c2 <.Loc.887.1>:
    if ((buffer[i] < 0xC0) || 
    72c2:	7a 40 0c 00 	mov.b	#12,	r10	;#0x000c
    72c6:	4a 9f       	cmp.b	r15,	r10	;
    72c8:	11 2c       	jc	$+36     	;abs 0x72ec

000072ca <.Loc.889.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    72ca:	7f 50 f0 ff 	add.b	#-16,	r15	;#0xfff0

000072ce <.Loc.888.1>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    72ce:	4a 9f       	cmp.b	r15,	r10	;
    72d0:	0d 2c       	jc	$+28     	;abs 0x72ec

000072d2 <.Loc.889.1>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    72d2:	7f 40 f2 ff 	mov.b	#-14,	r15	;#0xfff2
    72d6:	4f 9e       	cmp.b	r14,	r15	;
    72d8:	09 28       	jnc	$+20     	;abs 0x72ec

000072da <.Loc.886.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    72da:	1c 53       	inc	r12		;
    72dc:	80 00 a0 72 	mova	#29344,	r0	;0x072a0

000072e0 <.L225>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    72e0:	4e 43       	clr.b	r14		;
    72e2:	80 00 8c 72 	mova	#29324,	r0	;0x0728c

000072e6 <.L226>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    72e6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    72e8:	80 00 9e 72 	mova	#29342,	r0	;0x0729e

000072ec <.L214>:
      if (hdr.reply) {
    72ec:	06 93       	cmp	#0,	r6	;r3 As==00
    72ee:	10 24       	jz	$+34     	;abs 0x7310

000072f0 <.Loc.893.1>:
        gen_failure(hdr);
    72f0:	81 47 00 00 	mov	r7,	0(r1)	;
    72f4:	81 44 02 00 	mov	r4,	2(r1)	;
    72f8:	cc 01       	mova	r1,	r12	;

000072fa <.LVL443>:
    72fa:	b0 13 a8 6c 	calla	#27816		;0x06ca8

000072fe <.L217>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    72fe:	cc 08       	mova	r8,	r12	;
    7300:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007304 <.LVL445>:
    7304:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007308 <.L210>:
}
    7308:	a1 00 04 00 	adda	#4,	r1	;
    730c:	64 16       	popm.a	#7,	r10	;20-bit words
    730e:	10 01       	reta			;

00007310 <.L216>:
        elyErrorSignal(ErrCmdFailure);
    7310:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007314 <.LVL448>:
    7314:	b0 13 fa 96 	calla	#38650		;0x096fa

00007318 <.LVL449>:
    7318:	80 00 fe 72 	mova	#29438,	r0	;0x072fe

0000731c <.L227>:
  if (hdr.reply) {
    731c:	06 93       	cmp	#0,	r6	;r3 As==00
    731e:	09 24       	jz	$+20     	;abs 0x7332

00007320 <.Loc.905.1>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    7320:	55 48 02 00 	mov.b	2(r8),	r5	;
    7324:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    7328:	5c 48 03 00 	mov.b	3(r8),	r12	;

0000732c <.LVL451>:
    732c:	05 dc       	bis	r12,	r5	;

0000732e <.LVL452>:
    732e:	80 00 5c 73 	mova	#29532,	r0	;0x0735c

00007332 <.L220>:
    addr = ((bank0p[RegEventDefaultAddrMsb] << 8) | (bank0p[RegEventDefaultAddrLsb]));
    7332:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e

00007336 <.LVL454>:
    7336:	55 4c 55 00 	mov.b	85(r12),r5	;0x00055
    733a:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    733e:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    7342:	05 dc       	bis	r12,	r5	;

00007344 <.LBB149>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7344:	80 00 5c 73 	mova	#29532,	r0	;0x0735c

00007348 <.L223>:
      elyEventSubscribe(buffer[i], addr);
    7348:	0d 49       	mov	r9,	r13	;
    734a:	4d 0e       	rlam.a	#4,	r13	;
    734c:	4d 0d       	rram.a	#4,	r13	;
    734e:	cc 0d       	mova	r13,	r12	;
    7350:	ec 08       	adda	r8,	r12	;
    7352:	0d 45       	mov	r5,	r13	;
    7354:	6c 4c       	mov.b	@r12,	r12	;
    7356:	b0 13 02 97 	calla	#38658		;0x09702

0000735a <.LVL457>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    735a:	19 53       	inc	r9		;

0000735c <.L222>:
    735c:	09 9a       	cmp	r10,	r9	;
    735e:	f4 3b       	jl	$-22     	;abs 0x7348

00007360 <.LBE149>:
  if (hdr.reply) {
    7360:	06 93       	cmp	#0,	r6	;r3 As==00
    7362:	07 20       	jnz	$+16     	;abs 0x7372

00007364 <.L224>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7364:	cc 08       	mova	r8,	r12	;
    7366:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000736a <.LVL460>:
    736a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000736e <.LVL461>:
    736e:	80 00 08 73 	mova	#29448,	r0	;0x07308

00007372 <.L228>:
    gen_success(hdr);
    7372:	81 47 00 00 	mov	r7,	0(r1)	;
    7376:	81 44 02 00 	mov	r4,	2(r1)	;
    737a:	cc 01       	mova	r1,	r12	;
    737c:	b0 13 1a 69 	calla	#26906		;0x0691a

00007380 <.LVL464>:
    7380:	80 00 64 73 	mova	#29540,	r0	;0x07364

00007384 <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7384:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007386 <.LCFI49>:
    7386:	b1 00 04 00 	suba	#4,	r1	;

0000738a <.LCFI50>:
    738a:	ca 0c       	mova	r12,	r10	;
    738c:	29 4d       	mov	@r13,	r9	;

0000738e <.LVL466>:
    738e:	14 4d 02 00 	mov	2(r13),	r4	;

00007392 <.LVL467>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7392:	0f 49       	mov	r9,	r15	;
    7394:	5f 0f       	rrum	#4,	r15	;
    7396:	5f 0f       	rrum	#4,	r15	;
    7398:	4c 49       	mov.b	r9,	r12	;

0000739a <.LVL468>:
    739a:	0b 4c       	mov	r12,	r11	;
    739c:	5b f3       	and.b	#1,	r11	;r3 As==01
    739e:	0b 93       	cmp	#0,	r11	;r3 As==00
    73a0:	0f 24       	jz	$+32     	;abs 0x73c0
    73a2:	6d 43       	mov.b	#2,	r13	;r3 As==10

000073a4 <.L230>:
    73a4:	6c f3       	and.b	#2,	r12	;r3 As==10
    73a6:	47 4c       	mov.b	r12,	r7	;
    73a8:	4c 5d       	add.b	r13,	r12	;
    73aa:	40 18 46 4f 	movx.b	r15,	r6	;
    73ae:	40 18 46 8c 	subx.b	r12,	r6	;

000073b2 <.LVL469>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    73b2:	07 93       	cmp	#0,	r7	;r3 As==00
    73b4:	08 24       	jz	$+18     	;abs 0x73c6

000073b6 <.Loc.797.1>:
    73b6:	68 42       	mov.b	#4,	r8	;r2 As==10

000073b8 <.L231>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    73b8:	0c 48       	mov	r8,	r12	;

000073ba <.LVL471>:
    73ba:	0d 48       	mov	r8,	r13	;
    73bc:	80 00 1a 74 	mova	#29722,	r0	;0x0741a

000073c0 <.L240>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    73c0:	4d 43       	clr.b	r13		;
    73c2:	80 00 a4 73 	mova	#29604,	r0	;0x073a4

000073c6 <.L241>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    73c6:	68 43       	mov.b	#2,	r8	;r3 As==10
    73c8:	80 00 b8 73 	mova	#29624,	r0	;0x073b8

000073cc <.L244>:
      if (hdr.reply) {
    73cc:	07 93       	cmp	#0,	r7	;r3 As==00
    73ce:	0e 24       	jz	$+30     	;abs 0x73ec

000073d0 <.Loc.803.1>:
        gen_failure(hdr);
    73d0:	81 49 00 00 	mov	r9,	0(r1)	;
    73d4:	81 44 02 00 	mov	r4,	2(r1)	;
    73d8:	cc 01       	mova	r1,	r12	;
    73da:	b0 13 a8 6c 	calla	#27816		;0x06ca8

000073de <.L235>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    73de:	cc 0a       	mova	r10,	r12	;
    73e0:	b0 13 ec 9d 	calla	#40428		;0x09dec

000073e4 <.LVL477>:
    73e4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000073e8 <.LVL478>:
      return;
    73e8:	80 00 42 74 	mova	#29762,	r0	;0x07442

000073ec <.L234>:
        elyErrorSignal(ErrCmdFailure);
    73ec:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    73f0:	b0 13 fa 96 	calla	#38650		;0x096fa

000073f4 <.LVL480>:
    73f4:	80 00 de 73 	mova	#29662,	r0	;0x073de

000073f8 <.L242>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    73f8:	45 43       	clr.b	r5		;

000073fa <.L237>:
    73fa:	0e 85       	sub	r5,	r14	;
    73fc:	0d 9e       	cmp	r14,	r13	;
    73fe:	14 34       	jge	$+42     	;abs 0x7428

00007400 <.Loc.800.1>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7400:	05 4d       	mov	r13,	r5	;
    7402:	45 0e       	rlam.a	#4,	r5	;
    7404:	45 0d       	rram.a	#4,	r5	;
    7406:	ce 05       	mova	r5,	r14	;
    7408:	ee 0a       	adda	r10,	r14	;
    740a:	6e 4e       	mov.b	@r14,	r14	;
    740c:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    7410:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    7414:	45 9e       	cmp.b	r14,	r5	;
    7416:	da 2b       	jnc	$-74     	;abs 0x73cc

00007418 <.Loc.799.1>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7418:	1d 53       	inc	r13		;

0000741a <.L232>:
    741a:	0e 4c       	mov	r12,	r14	;
    741c:	0e 5f       	add	r15,	r14	;
    741e:	0b 93       	cmp	#0,	r11	;r3 As==00
    7420:	eb 27       	jz	$-40     	;abs 0x73f8

00007422 <.Loc.799.1>:
    7422:	65 43       	mov.b	#2,	r5	;r3 As==10
    7424:	80 00 fa 73 	mova	#29690,	r0	;0x073fa

00007428 <.L243>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    7428:	40 18 0c 48 	movx.w	r8,	r12	;
    742c:	4d 46       	mov.b	r6,	r13	;

0000742e <.LVL483>:
    742e:	ec 0a       	adda	r10,	r12	;
    7430:	b0 13 f2 96 	calla	#38642		;0x096f2

00007434 <.LVL484>:
  if (hdr.reply) {
    7434:	07 93       	cmp	#0,	r7	;r3 As==00
    7436:	09 20       	jnz	$+20     	;abs 0x744a

00007438 <.L239>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7438:	cc 0a       	mova	r10,	r12	;
    743a:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000743e <.LVL486>:
    743e:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007442 <.L229>:
}
    7442:	a1 00 04 00 	adda	#4,	r1	;
    7446:	64 16       	popm.a	#7,	r10	;20-bit words
    7448:	10 01       	reta			;

0000744a <.L245>:
    gen_success(hdr);
    744a:	81 49 00 00 	mov	r9,	0(r1)	;
    744e:	81 44 02 00 	mov	r4,	2(r1)	;
    7452:	cc 01       	mova	r1,	r12	;
    7454:	b0 13 1a 69 	calla	#26906		;0x0691a

00007458 <.LVL490>:
    7458:	80 00 38 74 	mova	#29752,	r0	;0x07438

0000745c <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    745c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000745e <.LCFI51>:
    745e:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007462 <.LCFI52>:
    7462:	c8 0c       	mova	r12,	r8	;
    7464:	2e 4d       	mov	@r13,	r14	;

00007466 <.LVL492>:
    7466:	1c 4d 02 00 	mov	2(r13),	r12	;

0000746a <.LVL493>:
    746a:	04 4e       	mov	r14,	r4	;
    746c:	81 4c 04 00 	mov	r12,	4(r1)	;

00007470 <.Loc.755.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7470:	5e 0f       	rrum	#4,	r14	;
    7472:	5e 0f       	rrum	#4,	r14	;

00007474 <.LVL495>:
    7474:	4c 44       	mov.b	r4,	r12	;
    7476:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    747a:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    747e:	33 24       	jz	$+104    	;abs 0x74e6
    7480:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007482 <.L247>:
    7482:	6c f3       	and.b	#2,	r12	;r3 As==10
    7484:	47 4c       	mov.b	r12,	r7	;
    7486:	81 47 00 00 	mov	r7,	0(r1)	;
    748a:	4c 5d       	add.b	r13,	r12	;
    748c:	4e 8c       	sub.b	r12,	r14	;
    748e:	c1 4e 03 00 	mov.b	r14,	3(r1)	;
    7492:	4d 4e       	mov.b	r14,	r13	;

00007494 <.LVL496>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7494:	07 93       	cmp	#0,	r7	;r3 As==00
    7496:	2a 24       	jz	$+86     	;abs 0x74ec

00007498 <.Loc.756.1>:
    7498:	69 42       	mov.b	#4,	r9	;r2 As==10

0000749a <.L248>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    749a:	0a 49       	mov	r9,	r10	;
    749c:	05 49       	mov	r9,	r5	;
    749e:	25 52       	add	#4,	r5	;r2 As==10

000074a0 <.LVL498>:
    74a0:	0c 45       	mov	r5,	r12	;

000074a2 <.L249>:
    74a2:	0e 4d       	mov	r13,	r14	;
    74a4:	0e 5a       	add	r10,	r14	;
    74a6:	0c 9e       	cmp	r14,	r12	;
    74a8:	40 34       	jge	$+130    	;abs 0x752a

000074aa <.Loc.760.1>:
    if ((buffer[i] < 0x40) || 
    74aa:	0f 4c       	mov	r12,	r15	;
    74ac:	4f 0e       	rlam.a	#4,	r15	;
    74ae:	4f 0d       	rram.a	#4,	r15	;
    74b0:	ce 0f       	mova	r15,	r14	;
    74b2:	ee 08       	adda	r8,	r14	;
    74b4:	6e 4e       	mov.b	@r14,	r14	;
    74b6:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    74ba:	47 9e       	cmp.b	r14,	r7	;
    74bc:	1a 2c       	jc	$+54     	;abs 0x74f2

000074be <.Loc.761.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    74be:	4f 4e       	mov.b	r14,	r15	;
    74c0:	7f 50 af ff 	add.b	#-81,	r15	;#0xffaf

000074c4 <.Loc.760.1>:
    if ((buffer[i] < 0x40) || 
    74c4:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    74c8:	47 9f       	cmp.b	r15,	r7	;
    74ca:	13 2c       	jc	$+40     	;abs 0x74f2

000074cc <.Loc.762.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    74cc:	7f 50 ee ff 	add.b	#-18,	r15	;#0xffee

000074d0 <.Loc.761.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    74d0:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    74d4:	47 9f       	cmp.b	r15,	r7	;
    74d6:	0d 2c       	jc	$+28     	;abs 0x74f2

000074d8 <.Loc.762.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    74d8:	7f 40 76 00 	mov.b	#118,	r15	;#0x0076
    74dc:	4f 9e       	cmp.b	r14,	r15	;
    74de:	09 28       	jnc	$+20     	;abs 0x74f2

000074e0 <.Loc.759.1>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    74e0:	1c 53       	inc	r12		;
    74e2:	80 00 a2 74 	mova	#29858,	r0	;0x074a2

000074e6 <.L259>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    74e6:	4d 43       	clr.b	r13		;
    74e8:	80 00 82 74 	mova	#29826,	r0	;0x07482

000074ec <.L260>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    74ec:	69 43       	mov.b	#2,	r9	;r3 As==10
    74ee:	80 00 9a 74 	mova	#29850,	r0	;0x0749a

000074f2 <.L250>:
      if (hdr.reply) {
    74f2:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    74f6:	13 24       	jz	$+40     	;abs 0x751e

000074f8 <.Loc.766.1>:
        gen_failure(hdr);
    74f8:	81 44 06 00 	mov	r4,	6(r1)	;
    74fc:	91 41 04 00 	mov	4(r1),	8(r1)	;
    7500:	08 00 
    7502:	cc 01       	mova	r1,	r12	;

00007504 <.LVL504>:
    7504:	ac 00 06 00 	adda	#6,	r12	;
    7508:	b0 13 a8 6c 	calla	#27816		;0x06ca8

0000750c <.L253>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    750c:	cc 08       	mova	r8,	r12	;
    750e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007512 <.LVL506>:
    7512:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007516 <.L246>:
}
    7516:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    751a:	64 16       	popm.a	#7,	r10	;20-bit words
    751c:	10 01       	reta			;

0000751e <.L252>:
        elyErrorSignal(ErrCmdFailure);
    751e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007522 <.LVL509>:
    7522:	b0 13 fa 96 	calla	#38650		;0x096fa

00007526 <.LVL510>:
    7526:	80 00 0c 75 	mova	#29964,	r0	;0x0750c

0000752a <.L261>:
    752a:	47 43       	clr.b	r7		;
    752c:	06 47       	mov	r7,	r6	;
    752e:	80 00 56 75 	mova	#30038,	r0	;0x07556

00007532 <.L257>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7532:	40 18 0c 49 	movx.w	r9,	r12	;
    7536:	ec 08       	adda	r8,	r12	;
    7538:	40 18 3e 40 	movx.w	#3,	r14	;
    753c:	03 00 
    753e:	40 18 0e 8a 	subx.w	r10,	r14	;
    7542:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7546:	6c 4c       	mov.b	@r12,	r12	;
    7548:	0d 43       	clr	r13		;
    754a:	0f 43       	clr	r15		;
    754c:	b0 13 18 9f 	calla	#40728		;0x09f18
    7550:	07 dc       	bis	r12,	r7	;

00007552 <.LVL514>:
    7552:	06 dd       	bis	r13,	r6	;

00007554 <.LVL515>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7554:	1a 53       	inc	r10		;

00007556 <.L256>:
    7556:	0a 95       	cmp	r5,	r10	;
    7558:	ec 3b       	jl	$-38     	;abs 0x7532

0000755a <.LBE155>:
  interval = (interval / 100) * 100;
    755a:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    755e:	4f 43       	clr.b	r15		;
    7560:	0c 47       	mov	r7,	r12	;
    7562:	0d 46       	mov	r6,	r13	;
    7564:	b0 13 98 9e 	calla	#40600		;0x09e98
    7568:	07 4c       	mov	r12,	r7	;

0000756a <.LVL518>:
    756a:	05 4d       	mov	r13,	r5	;
    756c:	0a 4c       	mov	r12,	r10	;

0000756e <.LVL519>:
    756e:	0a 5c       	add	r12,	r10	;
    7570:	06 4d       	mov	r13,	r6	;
    7572:	06 6d       	addc	r13,	r6	;
    7574:	0a 5c       	add	r12,	r10	;
    7576:	06 6d       	addc	r13,	r6	;
    7578:	0c 4a       	mov	r10,	r12	;
    757a:	0d 46       	mov	r6,	r13	;
    757c:	b0 13 fc 9e 	calla	#40700		;0x09efc
    7580:	0e 4a       	mov	r10,	r14	;
    7582:	0e 5c       	add	r12,	r14	;
    7584:	0d 66       	addc	r6,	r13	;

00007586 <.Loc.783.1>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    7586:	40 18 0c 49 	movx.w	r9,	r12	;
    758a:	ac 00 04 00 	adda	#4,	r12	;
    758e:	0e 57       	add	r7,	r14	;
    7590:	0f 4d       	mov	r13,	r15	;
    7592:	0f 65       	addc	r5,	r15	;
    7594:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7598:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    759c:	ec 08       	adda	r8,	r12	;
    759e:	b0 13 f0 96 	calla	#38640		;0x096f0

000075a2 <.LVL523>:
  if (hdr.reply) {
    75a2:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    75a6:	07 20       	jnz	$+16     	;abs 0x75b6

000075a8 <.L258>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    75a8:	cc 08       	mova	r8,	r12	;
    75aa:	b0 13 ec 9d 	calla	#40428		;0x09dec

000075ae <.LVL524>:
    75ae:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000075b2 <.LVL525>:
    75b2:	80 00 16 75 	mova	#29974,	r0	;0x07516

000075b6 <.L262>:
    gen_success(hdr);
    75b6:	81 44 06 00 	mov	r4,	6(r1)	;
    75ba:	91 41 04 00 	mov	4(r1),	8(r1)	;
    75be:	08 00 
    75c0:	cc 01       	mova	r1,	r12	;
    75c2:	ac 00 06 00 	adda	#6,	r12	;
    75c6:	b0 13 1a 69 	calla	#26906		;0x0691a

000075ca <.LVL526>:
    75ca:	80 00 a8 75 	mova	#30120,	r0	;0x075a8

000075ce <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    75ce:	5a 14       	pushm.a	#6,	r10	;20-bit words

000075d0 <.LCFI53>:
    75d0:	b1 00 04 00 	suba	#4,	r1	;

000075d4 <.LCFI54>:
    75d4:	ca 0c       	mova	r12,	r10	;
    75d6:	29 4d       	mov	@r13,	r9	;

000075d8 <.LVL528>:
    75d8:	16 4d 02 00 	mov	2(r13),	r6	;

000075dc <.LVL529>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    75dc:	07 49       	mov	r9,	r7	;
    75de:	57 0f       	rrum	#4,	r7	;
    75e0:	57 0f       	rrum	#4,	r7	;
    75e2:	4c 49       	mov.b	r9,	r12	;

000075e4 <.LVL530>:
    75e4:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    75e8:	1e 24       	jz	$+62     	;abs 0x7626
    75ea:	6e 43       	mov.b	#2,	r14	;r3 As==10

000075ec <.L264>:
    75ec:	6c f3       	and.b	#2,	r12	;r3 As==10
    75ee:	48 4c       	mov.b	r12,	r8	;
    75f0:	4c 5e       	add.b	r14,	r12	;
    75f2:	47 8c       	sub.b	r12,	r7	;
    75f4:	4b 47       	mov.b	r7,	r11	;

000075f6 <.LVL531>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    75f6:	08 93       	cmp	#0,	r8	;r3 As==00
    75f8:	19 24       	jz	$+52     	;abs 0x762c

000075fa <.Loc.728.1>:
    75fa:	6c 42       	mov.b	#4,	r12	;r2 As==10

000075fc <.L265>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    75fc:	0f 4c       	mov	r12,	r15	;

000075fe <.LVL533>:
    75fe:	0d 4c       	mov	r12,	r13	;

00007600 <.L266>:
    7600:	0e 4b       	mov	r11,	r14	;
    7602:	0e 5f       	add	r15,	r14	;
    7604:	0d 9e       	cmp	r14,	r13	;
    7606:	2b 34       	jge	$+88     	;abs 0x765e

00007608 <.Loc.731.1>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7608:	05 4d       	mov	r13,	r5	;
    760a:	45 0e       	rlam.a	#4,	r5	;
    760c:	45 0d       	rram.a	#4,	r5	;
    760e:	ce 05       	mova	r5,	r14	;
    7610:	ee 0a       	adda	r10,	r14	;
    7612:	6e 4e       	mov.b	@r14,	r14	;
    7614:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    7618:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    761c:	45 9e       	cmp.b	r14,	r5	;
    761e:	09 28       	jnc	$+20     	;abs 0x7632

00007620 <.Loc.730.1>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7620:	1d 53       	inc	r13		;
    7622:	80 00 00 76 	mova	#30208,	r0	;0x07600

00007626 <.L273>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7626:	4e 43       	clr.b	r14		;
    7628:	80 00 ec 75 	mova	#30188,	r0	;0x075ec

0000762c <.L274>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    762c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    762e:	80 00 fc 75 	mova	#30204,	r0	;0x075fc

00007632 <.L276>:
      if (hdr.reply) {
    7632:	08 93       	cmp	#0,	r8	;r3 As==00
    7634:	0e 24       	jz	$+30     	;abs 0x7652

00007636 <.Loc.734.1>:
        gen_failure(hdr);
    7636:	81 49 00 00 	mov	r9,	0(r1)	;
    763a:	81 46 02 00 	mov	r6,	2(r1)	;
    763e:	cc 01       	mova	r1,	r12	;

00007640 <.LVL540>:
    7640:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007644 <.L269>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7644:	cc 0a       	mova	r10,	r12	;
    7646:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000764a <.LVL542>:
    764a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000764e <.LVL543>:
      return;
    764e:	80 00 78 76 	mova	#30328,	r0	;0x07678

00007652 <.L268>:
        elyErrorSignal(ErrCmdFailure);
    7652:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007656 <.LVL545>:
    7656:	b0 13 fa 96 	calla	#38650		;0x096fa

0000765a <.LVL546>:
    765a:	80 00 44 76 	mova	#30276,	r0	;0x07644

0000765e <.L275>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    765e:	40 18 0c 4c 	movx.w	r12,	r12	;

00007662 <.LVL548>:
    7662:	4d 47       	mov.b	r7,	r13	;

00007664 <.LVL549>:
    7664:	ec 0a       	adda	r10,	r12	;
    7666:	b0 13 ee 96 	calla	#38638		;0x096ee

0000766a <.LVL550>:
  if (hdr.reply) {
    766a:	08 93       	cmp	#0,	r8	;r3 As==00
    766c:	09 20       	jnz	$+20     	;abs 0x7680

0000766e <.L272>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    766e:	cc 0a       	mova	r10,	r12	;
    7670:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007674 <.LVL552>:
    7674:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007678 <.L263>:
}
    7678:	a1 00 04 00 	adda	#4,	r1	;
    767c:	55 16       	popm.a	#6,	r10	;20-bit words
    767e:	10 01       	reta			;

00007680 <.L277>:
    gen_success(hdr);
    7680:	81 49 00 00 	mov	r9,	0(r1)	;
    7684:	81 46 02 00 	mov	r6,	2(r1)	;
    7688:	cc 01       	mova	r1,	r12	;
    768a:	b0 13 1a 69 	calla	#26906		;0x0691a

0000768e <.LVL556>:
    768e:	80 00 6e 76 	mova	#30318,	r0	;0x0766e

00007692 <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7692:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007694 <.LCFI55>:
    7694:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007698 <.LCFI56>:
    7698:	c8 0c       	mova	r12,	r8	;
    769a:	2e 4d       	mov	@r13,	r14	;

0000769c <.LVL558>:
    769c:	1c 4d 02 00 	mov	2(r13),	r12	;

000076a0 <.LVL559>:
    76a0:	04 4e       	mov	r14,	r4	;
    76a2:	81 4c 04 00 	mov	r12,	4(r1)	;

000076a6 <.Loc.686.1>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    76a6:	5e 0f       	rrum	#4,	r14	;
    76a8:	5e 0f       	rrum	#4,	r14	;

000076aa <.LVL561>:
    76aa:	4c 44       	mov.b	r4,	r12	;
    76ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76b0:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    76b4:	33 24       	jz	$+104    	;abs 0x771c
    76b6:	6d 43       	mov.b	#2,	r13	;r3 As==10

000076b8 <.L279>:
    76b8:	6c f3       	and.b	#2,	r12	;r3 As==10
    76ba:	47 4c       	mov.b	r12,	r7	;
    76bc:	81 47 00 00 	mov	r7,	0(r1)	;
    76c0:	4c 5d       	add.b	r13,	r12	;
    76c2:	4e 8c       	sub.b	r12,	r14	;
    76c4:	c1 4e 03 00 	mov.b	r14,	3(r1)	;
    76c8:	4d 4e       	mov.b	r14,	r13	;

000076ca <.LVL562>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    76ca:	07 93       	cmp	#0,	r7	;r3 As==00
    76cc:	2a 24       	jz	$+86     	;abs 0x7722

000076ce <.Loc.687.1>:
    76ce:	69 42       	mov.b	#4,	r9	;r2 As==10

000076d0 <.L280>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    76d0:	0a 49       	mov	r9,	r10	;
    76d2:	05 49       	mov	r9,	r5	;
    76d4:	25 52       	add	#4,	r5	;r2 As==10

000076d6 <.LVL564>:
    76d6:	0c 45       	mov	r5,	r12	;

000076d8 <.L281>:
    76d8:	0e 4d       	mov	r13,	r14	;
    76da:	0e 5a       	add	r10,	r14	;
    76dc:	0c 9e       	cmp	r14,	r12	;
    76de:	40 34       	jge	$+130    	;abs 0x7760

000076e0 <.Loc.691.1>:
    if ((buffer[i] < 0x40) || 
    76e0:	0f 4c       	mov	r12,	r15	;
    76e2:	4f 0e       	rlam.a	#4,	r15	;
    76e4:	4f 0d       	rram.a	#4,	r15	;
    76e6:	ce 0f       	mova	r15,	r14	;
    76e8:	ee 08       	adda	r8,	r14	;
    76ea:	6e 4e       	mov.b	@r14,	r14	;
    76ec:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    76f0:	47 9e       	cmp.b	r14,	r7	;
    76f2:	1a 2c       	jc	$+54     	;abs 0x7728

000076f4 <.Loc.692.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    76f4:	4f 4e       	mov.b	r14,	r15	;
    76f6:	7f 50 af ff 	add.b	#-81,	r15	;#0xffaf

000076fa <.Loc.691.1>:
    if ((buffer[i] < 0x40) || 
    76fa:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    76fe:	47 9f       	cmp.b	r15,	r7	;
    7700:	13 2c       	jc	$+40     	;abs 0x7728

00007702 <.Loc.693.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7702:	7f 50 ee ff 	add.b	#-18,	r15	;#0xffee

00007706 <.Loc.692.1>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7706:	77 40 0c 00 	mov.b	#12,	r7	;#0x000c
    770a:	47 9f       	cmp.b	r15,	r7	;
    770c:	0d 2c       	jc	$+28     	;abs 0x7728

0000770e <.Loc.693.1>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    770e:	7f 40 76 00 	mov.b	#118,	r15	;#0x0076
    7712:	4f 9e       	cmp.b	r14,	r15	;
    7714:	09 28       	jnc	$+20     	;abs 0x7728

00007716 <.Loc.690.1>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7716:	1c 53       	inc	r12		;
    7718:	80 00 d8 76 	mova	#30424,	r0	;0x076d8

0000771c <.L291>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    771c:	4d 43       	clr.b	r13		;
    771e:	80 00 b8 76 	mova	#30392,	r0	;0x076b8

00007722 <.L292>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7722:	69 43       	mov.b	#2,	r9	;r3 As==10
    7724:	80 00 d0 76 	mova	#30416,	r0	;0x076d0

00007728 <.L282>:
      if (hdr.reply) {
    7728:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    772c:	13 24       	jz	$+40     	;abs 0x7754

0000772e <.Loc.697.1>:
        gen_failure(hdr);
    772e:	81 44 06 00 	mov	r4,	6(r1)	;
    7732:	91 41 04 00 	mov	4(r1),	8(r1)	;
    7736:	08 00 
    7738:	cc 01       	mova	r1,	r12	;

0000773a <.LVL570>:
    773a:	ac 00 06 00 	adda	#6,	r12	;
    773e:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007742 <.L285>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7742:	cc 08       	mova	r8,	r12	;
    7744:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007748 <.LVL572>:
    7748:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000774c <.L278>:
}
    774c:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7750:	64 16       	popm.a	#7,	r10	;20-bit words
    7752:	10 01       	reta			;

00007754 <.L284>:
        elyErrorSignal(ErrCmdFailure);
    7754:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007758 <.LVL575>:
    7758:	b0 13 fa 96 	calla	#38650		;0x096fa

0000775c <.LVL576>:
    775c:	80 00 42 77 	mova	#30530,	r0	;0x07742

00007760 <.L293>:
    7760:	47 43       	clr.b	r7		;
    7762:	06 47       	mov	r7,	r6	;
    7764:	80 00 8c 77 	mova	#30604,	r0	;0x0778c

00007768 <.L289>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7768:	40 18 0c 49 	movx.w	r9,	r12	;
    776c:	ec 08       	adda	r8,	r12	;
    776e:	40 18 3e 40 	movx.w	#3,	r14	;
    7772:	03 00 
    7774:	40 18 0e 8a 	subx.w	r10,	r14	;
    7778:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    777c:	6c 4c       	mov.b	@r12,	r12	;
    777e:	0d 43       	clr	r13		;
    7780:	0f 43       	clr	r15		;
    7782:	b0 13 18 9f 	calla	#40728		;0x09f18
    7786:	07 dc       	bis	r12,	r7	;

00007788 <.LVL580>:
    7788:	06 dd       	bis	r13,	r6	;

0000778a <.LVL581>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    778a:	1a 53       	inc	r10		;

0000778c <.L288>:
    778c:	0a 95       	cmp	r5,	r10	;
    778e:	ec 3b       	jl	$-38     	;abs 0x7768

00007790 <.LBE161>:
  interval = (interval / 100) * 100;
    7790:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7794:	4f 43       	clr.b	r15		;
    7796:	0c 47       	mov	r7,	r12	;
    7798:	0d 46       	mov	r6,	r13	;
    779a:	b0 13 98 9e 	calla	#40600		;0x09e98
    779e:	07 4c       	mov	r12,	r7	;

000077a0 <.LVL584>:
    77a0:	05 4d       	mov	r13,	r5	;
    77a2:	0a 4c       	mov	r12,	r10	;

000077a4 <.LVL585>:
    77a4:	0a 5c       	add	r12,	r10	;
    77a6:	06 4d       	mov	r13,	r6	;
    77a8:	06 6d       	addc	r13,	r6	;
    77aa:	0a 5c       	add	r12,	r10	;
    77ac:	06 6d       	addc	r13,	r6	;
    77ae:	0c 4a       	mov	r10,	r12	;
    77b0:	0d 46       	mov	r6,	r13	;
    77b2:	b0 13 fc 9e 	calla	#40700		;0x09efc
    77b6:	0e 4a       	mov	r10,	r14	;
    77b8:	0e 5c       	add	r12,	r14	;
    77ba:	0d 66       	addc	r6,	r13	;

000077bc <.Loc.715.1>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    77bc:	40 18 0c 49 	movx.w	r9,	r12	;
    77c0:	ac 00 04 00 	adda	#4,	r12	;
    77c4:	0e 57       	add	r7,	r14	;
    77c6:	0f 4d       	mov	r13,	r15	;
    77c8:	0f 65       	addc	r5,	r15	;
    77ca:	5d 41 03 00 	mov.b	3(r1),	r13	;
    77ce:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    77d2:	ec 08       	adda	r8,	r12	;
    77d4:	b0 13 ec 96 	calla	#38636		;0x096ec

000077d8 <.LVL589>:
  if (hdr.reply) {
    77d8:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    77dc:	07 20       	jnz	$+16     	;abs 0x77ec

000077de <.L290>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    77de:	cc 08       	mova	r8,	r12	;
    77e0:	b0 13 ec 9d 	calla	#40428		;0x09dec

000077e4 <.LVL590>:
    77e4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000077e8 <.LVL591>:
    77e8:	80 00 4c 77 	mova	#30540,	r0	;0x0774c

000077ec <.L294>:
    gen_success(hdr);
    77ec:	81 44 06 00 	mov	r4,	6(r1)	;
    77f0:	91 41 04 00 	mov	4(r1),	8(r1)	;
    77f4:	08 00 
    77f6:	cc 01       	mova	r1,	r12	;
    77f8:	ac 00 06 00 	adda	#6,	r12	;
    77fc:	b0 13 1a 69 	calla	#26906		;0x0691a

00007800 <.LVL592>:
    7800:	80 00 de 77 	mova	#30686,	r0	;0x077de

00007804 <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7804:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007806 <.LCFI57>:
    7806:	b1 00 04 00 	suba	#4,	r1	;

0000780a <.LCFI58>:
    780a:	29 4d       	mov	@r13,	r9	;

0000780c <.LVL594>:
    780c:	18 4d 02 00 	mov	2(r13),	r8	;

00007810 <.LVL595>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7810:	4a 49       	mov.b	r9,	r10	;
    7812:	6a f3       	and.b	#2,	r10	;r3 As==10
    7814:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    7818:	0a 93       	cmp	#0,	r10	;r3 As==00
    781a:	1c 24       	jz	$+58     	;abs 0x7854
    781c:	6e 42       	mov.b	#4,	r14	;r2 As==10

0000781e <.L296>:
  uint8_t bank = buffer[hdr_ext];
    781e:	40 18 0e 4e 	movx.w	r14,	r14	;
    7822:	ee 0c       	adda	r12,	r14	;

00007824 <.LVL597>:
    7824:	67 4e       	mov.b	@r14,	r7	;

00007826 <.LVL598>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7826:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000782a <.LVL599>:
    782a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000782e <.LVL600>:
  if (bank == 0 || bank > 4) {
    782e:	4c 47       	mov.b	r7,	r12	;
    7830:	7c 53       	add.b	#-1,	r12	;r3 As==11
    7832:	7d 40 03 00 	mov.b	#3,	r13	;
    7836:	4d 9c       	cmp.b	r12,	r13	;
    7838:	16 2c       	jc	$+46     	;abs 0x7866

0000783a <.Loc.660.1>:
    if (hdr.reply) {
    783a:	0a 93       	cmp	#0,	r10	;r3 As==00
    783c:	0e 24       	jz	$+30     	;abs 0x785a

0000783e <.Loc.662.1>:
      gen_failure(hdr);
    783e:	81 49 00 00 	mov	r9,	0(r1)	;
    7842:	81 48 02 00 	mov	r8,	2(r1)	;
    7846:	cc 01       	mova	r1,	r12	;
    7848:	b0 13 a8 6c 	calla	#27816		;0x06ca8

0000784c <.L295>:
}
    784c:	a1 00 04 00 	adda	#4,	r1	;
    7850:	37 16       	popm.a	#4,	r10	;20-bit words
    7852:	10 01       	reta			;

00007854 <.L300>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7854:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7856:	80 00 1e 78 	mova	#30750,	r0	;0x0781e

0000785a <.L298>:
      elyErrorSignal(ErrCmdFailure);
    785a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    785e:	b0 13 fa 96 	calla	#38650		;0x096fa

00007862 <.LVL606>:
    7862:	80 00 4c 78 	mova	#30796,	r0	;0x0784c

00007866 <.L297>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    7866:	2a 01 3a 04 	mova	&66618,	r10	;0x1043a
    786a:	88 00 e4 90 	mova	#37092,	r8	;0x090e4

0000786e <.LVL607>:
    786e:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    7872:	4e 43       	clr.b	r14		;
    7874:	cd 0a       	mova	r10,	r13	;
    7876:	4c 47       	mov.b	r7,	r12	;
    7878:	48 13       	calla	r8		;

0000787a <.LVL608>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    787a:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    787e:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    7882:	cd 0a       	mova	r10,	r13	;
    7884:	ad 00 80 00 	adda	#128,	r13	;0x00080
    7888:	4c 47       	mov.b	r7,	r12	;
    788a:	48 13       	calla	r8		;

0000788c <.LVL609>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    788c:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    7890:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    7894:	cd 0a       	mova	r10,	r13	;
    7896:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    789a:	4c 47       	mov.b	r7,	r12	;
    789c:	48 13       	calla	r8		;

0000789e <.LVL610>:
  bank0w[RegActiveBank] = bank;
    789e:	ca 47 69 00 	mov.b	r7,	105(r10); 0x0069

000078a2 <.Loc.678.1>:
  active_buffer = NULL; /* have to null before reset */
    78a2:	00 18 c2 43 	movx.a	#0,	&0xfd39e;r3 As==00
    78a6:	9e d3 

000078a8 <.Loc.682.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    78a8:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    78ac:	48 a5 20 01 
    78b0:	80 00 4c 78 	mova	#30796,	r0	;0x0784c

000078b4 <set_u32>:
    const uint32_t max, const uint32_t min) {
    78b4:	b1 00 02 00 	suba	#2,	r1	;
    78b8:	00 18 d1 41 	movx.a	2(r1),	0(r1)	;
    78bc:	02 00 00 00 

000078c0 <.LCFI59>:
    78c0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000078c2 <.LCFI60>:
    78c2:	b1 00 10 00 	suba	#16,	r1	;0x00010

000078c6 <.LCFI61>:
    78c6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    78ca:	81 4c 06 00 	mov	r12,	6(r1)	;
    78ce:	c4 0d       	mova	r13,	r4	;
    78d0:	29 4e       	mov	@r14,	r9	;

000078d2 <.LVL612>:
    78d2:	1c 4e 02 00 	mov	2(r14),	r12	;

000078d6 <.LVL613>:
    78d6:	81 4f 30 00 	mov	r15,	48(r1)	; 0x0030
    78da:	81 4f 08 00 	mov	r15,	8(r1)	;
    78de:	91 41 32 00 	mov	50(r1),	0(r1)	;0x00032
    78e2:	00 00 
    78e4:	91 41 34 00 	mov	52(r1),	10(r1)	;0x00034, 0x000a
    78e8:	0a 00 
    78ea:	91 41 36 00 	mov	54(r1),	2(r1)	;0x00036
    78ee:	02 00 

000078f0 <.Loc.130.1>:
static void set_u32(const uint8_t addr, const uint8_t * buffer, elysium_cmd_hdr_t hdr,
    78f0:	81 4c 04 00 	mov	r12,	4(r1)	;

000078f4 <.Loc.132.1>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    78f4:	47 49       	mov.b	r9,	r7	;
    78f6:	67 f3       	and.b	#2,	r7	;r3 As==10
    78f8:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    78fc:	07 93       	cmp	#0,	r7	;r3 As==00
    78fe:	06 24       	jz	$+14     	;abs 0x790c
    7900:	6a 42       	mov.b	#4,	r10	;r2 As==10

00007902 <.L302>:
  for (int i = 0; i < 4; i++) {
    7902:	48 43       	clr.b	r8		;

00007904 <.LBE162>:
  uint32_t val = 0;
    7904:	05 48       	mov	r8,	r5	;
    7906:	06 48       	mov	r8,	r6	;

00007908 <.LBB163>:
  for (int i = 0; i < 4; i++) {
    7908:	80 00 3a 79 	mova	#31034,	r0	;0x0793a

0000790c <.L311>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    790c:	6a 43       	mov.b	#2,	r10	;r3 As==10
    790e:	80 00 02 79 	mova	#30978,	r0	;0x07902

00007912 <.L304>:
    val |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    7912:	0c 4a       	mov	r10,	r12	;
    7914:	0c 58       	add	r8,	r12	;
    7916:	4c 0e       	rlam.a	#4,	r12	;
    7918:	4c 0d       	rram.a	#4,	r12	;
    791a:	ec 04       	adda	r4,	r12	;
    791c:	40 18 3e 40 	movx.w	#3,	r14	;
    7920:	03 00 
    7922:	40 18 0e 88 	subx.w	r8,	r14	;
    7926:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    792a:	6c 4c       	mov.b	@r12,	r12	;
    792c:	0d 43       	clr	r13		;
    792e:	0f 43       	clr	r15		;
    7930:	b0 13 18 9f 	calla	#40728		;0x09f18
    7934:	05 dc       	bis	r12,	r5	;

00007936 <.LVL618>:
    7936:	06 dd       	bis	r13,	r6	;

00007938 <.LVL619>:
  for (int i = 0; i < 4; i++) {
    7938:	18 53       	inc	r8		;

0000793a <.L303>:
    793a:	7c 40 03 00 	mov.b	#3,	r12	;

0000793e <.LVL621>:
    793e:	0c 98       	cmp	r8,	r12	;
    7940:	e8 37       	jge	$-46     	;abs 0x7912

00007942 <.LBE164>:
  if (val > max || 
    7942:	81 96 00 00 	cmp	r6,	0(r1)	;
    7946:	0e 28       	jnc	$+30     	;abs 0x7964
    7948:	26 91       	cmp	@r1,	r6	;
    794a:	03 20       	jnz	$+8      	;abs 0x7952
    794c:	81 95 08 00 	cmp	r5,	8(r1)	;
    7950:	09 28       	jnc	$+20     	;abs 0x7964

00007952 <.L312>:
    7952:	16 91 02 00 	cmp	2(r1),	r6	;
    7956:	06 28       	jnc	$+14     	;abs 0x7964
    7958:	81 96 02 00 	cmp	r6,	2(r1)	;
    795c:	1e 20       	jnz	$+62     	;abs 0x799a
    795e:	15 91 0a 00 	cmp	10(r1),	r5	;0x0000a
    7962:	1b 2c       	jc	$+56     	;abs 0x799a

00007964 <.L305>:
    if (hdr.reply) {
    7964:	07 93       	cmp	#0,	r7	;r3 As==00
    7966:	13 24       	jz	$+40     	;abs 0x798e

00007968 <.Loc.144.1>:
      gen_failure(hdr);
    7968:	81 49 0c 00 	mov	r9,	12(r1)	; 0x000c
    796c:	91 41 04 00 	mov	4(r1),	14(r1)	; 0x000e
    7970:	0e 00 
    7972:	cc 01       	mova	r1,	r12	;
    7974:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    7978:	b0 13 a8 6c 	calla	#27816		;0x06ca8

0000797c <.L301>:
}
    797c:	a1 00 10 00 	adda	#16,	r1	;0x00010
    7980:	64 16       	popm.a	#7,	r10	;20-bit words
    7982:	00 18 e1 41 	movx.a	@r1,	2(r1)	;
    7986:	02 00 
    7988:	a1 00 02 00 	adda	#2,	r1	;
    798c:	10 01       	reta			;

0000798e <.L309>:
      elyErrorSignal(ErrCmdFailure);
    798e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7992:	b0 13 fa 96 	calla	#38650		;0x096fa

00007996 <.LVL625>:
    7996:	80 00 7c 79 	mova	#31100,	r0	;0x0797c

0000799a <.L307>:
  bank0w[addr+3] = buffer[hdr_ext];
    799a:	2c 01 3a 04 	mova	&66618,	r12	;0x1043a
    799e:	40 18 1e 41 	movx.w	6(r1),	r14	;
    79a2:	06 00 
    79a4:	c8 0e       	mova	r14,	r8	;

000079a6 <.LVL626>:
    79a6:	a8 00 03 00 	adda	#3,	r8	;
    79aa:	e8 0c       	adda	r12,	r8	;
    79ac:	40 18 0a 4a 	movx.w	r10,	r10	;
    79b0:	ea 04       	adda	r4,	r10	;

000079b2 <.LVL627>:
    79b2:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;

000079b6 <.Loc.153.1>:
  bank0w[addr+2] = buffer[hdr_ext+1];
    79b6:	c8 0e       	mova	r14,	r8	;
    79b8:	a8 00 02 00 	adda	#2,	r8	;
    79bc:	e8 0c       	adda	r12,	r8	;
    79be:	d8 4a 01 00 	mov.b	1(r10),	0(r8)	;
    79c2:	00 00 

000079c4 <.Loc.154.1>:
  bank0w[addr+1] = buffer[hdr_ext+2];
    79c4:	c8 0e       	mova	r14,	r8	;
    79c6:	a8 00 01 00 	adda	#1,	r8	;
    79ca:	e8 0c       	adda	r12,	r8	;
    79cc:	d8 4a 02 00 	mov.b	2(r10),	0(r8)	;
    79d0:	00 00 

000079d2 <.Loc.155.1>:
  bank0w[addr] = buffer[hdr_ext+3];
    79d2:	ec 0e       	adda	r14,	r12	;
    79d4:	dc 4a 03 00 	mov.b	3(r10),	0(r12)	;
    79d8:	00 00 

000079da <.Loc.157.1>:
  if (hdr.reply) {
    79da:	07 93       	cmp	#0,	r7	;r3 As==00
    79dc:	cf 27       	jz	$-96     	;abs 0x797c

000079de <.Loc.159.1>:
    gen_success(hdr);
    79de:	81 49 0c 00 	mov	r9,	12(r1)	; 0x000c
    79e2:	91 41 04 00 	mov	4(r1),	14(r1)	; 0x000e
    79e6:	0e 00 
    79e8:	cc 01       	mova	r1,	r12	;
    79ea:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    79ee:	b0 13 1a 69 	calla	#26906		;0x0691a

000079f2 <.LVL628>:
    79f2:	80 00 7c 79 	mova	#31100,	r0	;0x0797c

000079f6 <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    79f6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000079f8 <.LCFI62>:
    79f8:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

000079fc <.LCFI63>:
    79fc:	ca 0c       	mova	r12,	r10	;

000079fe <.Loc.643.1>:
  set_u32(RegUARTBaudLsb, buffer, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    79fe:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7a02:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7a06:	08 00 
    7a08:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    7a0c:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7a10:	b1 40 0f 00 	mov	#15,	0(r1)	;#0x000f
    7a14:	00 00 
    7a16:	3f 40 40 42 	mov	#16960,	r15	;#0x4240
    7a1a:	ce 01       	mova	r1,	r14	;
    7a1c:	ae 00 06 00 	adda	#6,	r14	;
    7a20:	cd 0c       	mova	r12,	r13	;
    7a22:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00007a26 <.LVL630>:
    7a26:	b0 13 b4 78 	calla	#30900		;0x078b4

00007a2a <.LVL631>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7a2a:	cc 0a       	mova	r10,	r12	;
    7a2c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007a30 <.LVL632>:
    7a30:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007a34 <.LVL633>:
  elyUARTCfgMarkDirty();
    7a34:	b0 13 9c 5e 	calla	#24220		;0x05e9c

00007a38 <.LVL634>:
}
    7a38:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7a3c:	0a 16       	popm.a	#1,	r10	;20-bit words
    7a3e:	10 01       	reta			;

00007a40 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a40:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007a42 <.LCFI64>:
    7a42:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007a46 <.LCFI65>:
    7a46:	ca 0c       	mova	r12,	r10	;

00007a48 <.Loc.565.1>:
  set_u32(RegRXDevLsb, buffer, hdr, RX_DEV_MAX, RX_DEV_MIN);
    7a48:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7a4c:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7a50:	08 00 
    7a52:	b1 40 e8 80 	mov	#-32536,2(r1)	;#0x80e8
    7a56:	02 00 
    7a58:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7a5c:	b1 40 03 00 	mov	#3,	0(r1)	;
    7a60:	00 00 
    7a62:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7a66:	ce 01       	mova	r1,	r14	;
    7a68:	ae 00 06 00 	adda	#6,	r14	;
    7a6c:	cd 0c       	mova	r12,	r13	;
    7a6e:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c

00007a72 <.LVL636>:
    7a72:	b0 13 b4 78 	calla	#30900		;0x078b4

00007a76 <.LVL637>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7a76:	cc 0a       	mova	r10,	r12	;
    7a78:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007a7c <.LVL638>:
    7a7c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007a80 <.LVL639>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    7a80:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    7a84:	4d 43       	clr.b	r13		;
    7a86:	b0 13 18 97 	calla	#38680		;0x09718

00007a8a <.LVL640>:
  elyEventSignal(EvtRXDevChange);
    7a8a:	7c 40 ca ff 	mov.b	#-54,	r12	;#0xffca
    7a8e:	b0 13 00 97 	calla	#38656		;0x09700

00007a92 <.LVL641>:
}
    7a92:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7a96:	0a 16       	popm.a	#1,	r10	;20-bit words
    7a98:	10 01       	reta			;

00007a9a <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a9a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007a9c <.LCFI66>:
    7a9c:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007aa0 <.LCFI67>:
    7aa0:	ca 0c       	mova	r12,	r10	;

00007aa2 <.Loc.543.1>:
  set_u32(RegTXDevLsb, buffer, hdr, TX_DEV_MAX, TX_DEV_MIN);
    7aa2:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7aa6:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7aaa:	08 00 
    7aac:	b1 40 58 02 	mov	#600,	2(r1)	;#0x0258
    7ab0:	02 00 
    7ab2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7ab6:	b1 40 03 00 	mov	#3,	0(r1)	;
    7aba:	00 00 
    7abc:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    7ac0:	ce 01       	mova	r1,	r14	;
    7ac2:	ae 00 06 00 	adda	#6,	r14	;
    7ac6:	cd 0c       	mova	r12,	r13	;
    7ac8:	7c 42       	mov.b	#8,	r12	;r2 As==11

00007aca <.LVL643>:
    7aca:	b0 13 b4 78 	calla	#30900		;0x078b4

00007ace <.LVL644>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7ace:	cc 0a       	mova	r10,	r12	;
    7ad0:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007ad4 <.LVL645>:
    7ad4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007ad8 <.LVL646>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    7ad8:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7adc:	4d 43       	clr.b	r13		;
    7ade:	b0 13 18 97 	calla	#38680		;0x09718

00007ae2 <.LVL647>:
  elyEventSignal(EvtTXDevChange);
    7ae2:	7c 40 c9 ff 	mov.b	#-55,	r12	;#0xffc9
    7ae6:	b0 13 00 97 	calla	#38656		;0x09700

00007aea <.LVL648>:
}
    7aea:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7aee:	0a 16       	popm.a	#1,	r10	;20-bit words
    7af0:	10 01       	reta			;

00007af2 <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7af2:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007af4 <.LCFI68>:
    7af4:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007af8 <.LCFI69>:
    7af8:	ca 0c       	mova	r12,	r10	;

00007afa <.Loc.521.1>:
  set_u32(RegRXBRLsb, buffer, hdr, RX_BR_MAX, RX_BR_MIN);
    7afa:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7afe:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7b02:	08 00 
    7b04:	b1 40 0c 03 	mov	#780,	2(r1)	;#0x030c
    7b08:	02 00 
    7b0a:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7b0e:	a1 43 00 00 	mov	#2,	0(r1)	;r3 As==10
    7b12:	3f 40 f0 49 	mov	#18928,	r15	;#0x49f0
    7b16:	ce 01       	mova	r1,	r14	;
    7b18:	ae 00 06 00 	adda	#6,	r14	;
    7b1c:	cd 0c       	mova	r12,	r13	;
    7b1e:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c

00007b22 <.LVL650>:
    7b22:	b0 13 b4 78 	calla	#30900		;0x078b4

00007b26 <.LVL651>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7b26:	cc 0a       	mova	r10,	r12	;
    7b28:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007b2c <.LVL652>:
    7b2c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007b30 <.LVL653>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    7b30:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7b32:	4d 43       	clr.b	r13		;
    7b34:	b0 13 18 97 	calla	#38680		;0x09718

00007b38 <.LVL654>:
  elyEventSignal(EvtRXBRChange);
    7b38:	7c 40 c8 ff 	mov.b	#-56,	r12	;#0xffc8
    7b3c:	b0 13 00 97 	calla	#38656		;0x09700

00007b40 <.LVL655>:
}
    7b40:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7b44:	0a 16       	popm.a	#1,	r10	;20-bit words
    7b46:	10 01       	reta			;

00007b48 <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7b48:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007b4a <.LCFI70>:
    7b4a:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007b4e <.LCFI71>:
    7b4e:	ca 0c       	mova	r12,	r10	;

00007b50 <.Loc.499.1>:
  set_u32(RegTXBRLsb, buffer, hdr, TX_BR_MAX, TX_BR_MIN);
    7b50:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7b54:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7b58:	08 00 
    7b5a:	b1 40 b0 04 	mov	#1200,	2(r1)	;#0x04b0
    7b5e:	02 00 
    7b60:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7b64:	a1 42 00 00 	mov	#4,	0(r1)	;r2 As==10
    7b68:	3f 40 e0 93 	mov	#-27680,r15	;#0x93e0
    7b6c:	ce 01       	mova	r1,	r14	;
    7b6e:	ae 00 06 00 	adda	#6,	r14	;
    7b72:	cd 0c       	mova	r12,	r13	;
    7b74:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018

00007b78 <.LVL657>:
    7b78:	b0 13 b4 78 	calla	#30900		;0x078b4

00007b7c <.LVL658>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7b7c:	cc 0a       	mova	r10,	r12	;
    7b7e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007b82 <.LVL659>:
    7b82:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007b86 <.LVL660>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    7b86:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7b88:	4d 43       	clr.b	r13		;
    7b8a:	b0 13 18 97 	calla	#38680		;0x09718

00007b8e <.LVL661>:
  elyEventSignal(EvtTXBRChange);
    7b8e:	7c 40 c7 ff 	mov.b	#-57,	r12	;#0xffc7
    7b92:	b0 13 00 97 	calla	#38656		;0x09700

00007b96 <.LVL662>:
}
    7b96:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7b9a:	0a 16       	popm.a	#1,	r10	;20-bit words
    7b9c:	10 01       	reta			;

00007b9e <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7b9e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007ba0 <.LCFI72>:
    7ba0:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007ba4 <.LCFI73>:
    7ba4:	ca 0c       	mova	r12,	r10	;

00007ba6 <.Loc.477.1>:
  set_u32(RegRXFreqLsb, buffer, hdr, RX_BAND_MAX, RX_BAND_MIN);
    7ba6:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7baa:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7bae:	08 00 
    7bb0:	b1 40 40 44 	mov	#17472,	2(r1)	;#0x4440
    7bb4:	02 00 
    7bb6:	b1 40 3d 1b 	mov	#6973,	4(r1)	;#0x1b3d
    7bba:	04 00 
    7bbc:	b1 40 12 1c 	mov	#7186,	0(r1)	;#0x1c12
    7bc0:	00 00 
    7bc2:	3f 40 c0 e3 	mov	#-7232,	r15	;#0xe3c0
    7bc6:	ce 01       	mova	r1,	r14	;
    7bc8:	ae 00 06 00 	adda	#6,	r14	;
    7bcc:	cd 0c       	mova	r12,	r13	;
    7bce:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007bd0 <.LVL664>:
    7bd0:	b0 13 b4 78 	calla	#30900		;0x078b4

00007bd4 <.LVL665>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7bd4:	cc 0a       	mova	r10,	r12	;
    7bd6:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007bda <.LVL666>:
    7bda:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007bde <.LVL667>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    7bde:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7be0:	4d 43       	clr.b	r13		;
    7be2:	b0 13 18 97 	calla	#38680		;0x09718

00007be6 <.LVL668>:
  elyEventSignal(EvtRXFreqChange);
    7be6:	7c 40 c6 ff 	mov.b	#-58,	r12	;#0xffc6
    7bea:	b0 13 00 97 	calla	#38656		;0x09700

00007bee <.LVL669>:
}
    7bee:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7bf2:	0a 16       	popm.a	#1,	r10	;20-bit words
    7bf4:	10 01       	reta			;

00007bf6 <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7bf6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007bf8 <.LCFI74>:
    7bf8:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00007bfc <.LCFI75>:
    7bfc:	ca 0c       	mova	r12,	r10	;

00007bfe <.Loc.455.1>:
  set_u32(RegTXFreqLsb, buffer, hdr, TX_BAND_MAX, TX_BAND_MIN);
    7bfe:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    7c02:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    7c06:	08 00 
    7c08:	b1 40 40 da 	mov	#-9664,	2(r1)	;#0xda40
    7c0c:	02 00 
    7c0e:	b1 40 8e 33 	mov	#13198,	4(r1)	;#0x338e
    7c12:	04 00 
    7c14:	b1 40 ec 38 	mov	#14572,	0(r1)	;#0x38ec
    7c18:	00 00 
    7c1a:	3f 40 c0 24 	mov	#9408,	r15	;#0x24c0
    7c1e:	ce 01       	mova	r1,	r14	;
    7c20:	ae 00 06 00 	adda	#6,	r14	;
    7c24:	cd 0c       	mova	r12,	r13	;
    7c26:	4c 43       	clr.b	r12		;

00007c28 <.LVL671>:
    7c28:	b0 13 b4 78 	calla	#30900		;0x078b4

00007c2c <.LVL672>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7c2c:	cc 0a       	mova	r10,	r12	;
    7c2e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007c32 <.LVL673>:
    7c32:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007c36 <.LVL674>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    7c36:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7c38:	4d 43       	clr.b	r13		;
    7c3a:	b0 13 18 97 	calla	#38680		;0x09718

00007c3e <.LVL675>:
  elyEventSignal(EvtTXFreqChange);
    7c3e:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    7c42:	b0 13 00 97 	calla	#38656		;0x09700

00007c46 <.LVL676>:
}
    7c46:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    7c4a:	0a 16       	popm.a	#1,	r10	;20-bit words
    7c4c:	10 01       	reta			;

00007c4e <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7c4e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007c50 <.LCFI76>:
    7c50:	b1 00 04 00 	suba	#4,	r1	;

00007c54 <.LCFI77>:
    7c54:	c8 0c       	mova	r12,	r8	;
    7c56:	29 4d       	mov	@r13,	r9	;

00007c58 <.LVL678>:
    7c58:	17 4d 02 00 	mov	2(r13),	r7	;

00007c5c <.LVL679>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c5c:	4a 49       	mov.b	r9,	r10	;
    7c5e:	6a f3       	and.b	#2,	r10	;r3 As==10
    7c60:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    7c64:	0a 93       	cmp	#0,	r10	;r3 As==00
    7c66:	1b 24       	jz	$+56     	;abs 0x7c9e
    7c68:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007c6a <.L321>:
  if (buffer[hdr_ext] > TX_POW_MAX) {
    7c6a:	40 18 0c 4c 	movx.w	r12,	r12	;
    7c6e:	ec 08       	adda	r8,	r12	;

00007c70 <.LVL681>:
    7c70:	6d 4c       	mov.b	@r12,	r13	;
    7c72:	7c 40 82 ff 	mov.b	#-126,	r12	;#0xff82
    7c76:	4c 9d       	cmp.b	r13,	r12	;
    7c78:	1b 2c       	jc	$+56     	;abs 0x7cb0

00007c7a <.Loc.608.1>:
    if (hdr.reply) {
    7c7a:	0a 93       	cmp	#0,	r10	;r3 As==00
    7c7c:	13 24       	jz	$+40     	;abs 0x7ca4

00007c7e <.Loc.610.1>:
      gen_failure(hdr);
    7c7e:	81 49 00 00 	mov	r9,	0(r1)	;
    7c82:	81 47 02 00 	mov	r7,	2(r1)	;
    7c86:	cc 01       	mova	r1,	r12	;
    7c88:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007c8c <.L324>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    7c8c:	cc 08       	mova	r8,	r12	;
    7c8e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007c92 <.LVL685>:
    7c92:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007c96 <.L320>:
}
    7c96:	a1 00 04 00 	adda	#4,	r1	;
    7c9a:	37 16       	popm.a	#4,	r10	;20-bit words
    7c9c:	10 01       	reta			;

00007c9e <.L327>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c9e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7ca0:	80 00 6a 7c 	mova	#31850,	r0	;0x07c6a

00007ca4 <.L323>:
      elyErrorSignal(ErrCmdFailure);
    7ca4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7ca8:	b0 13 fa 96 	calla	#38650		;0x096fa

00007cac <.LVL688>:
    7cac:	80 00 8c 7c 	mova	#31884,	r0	;0x07c8c

00007cb0 <.L322>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    7cb0:	2c 01 3a 04 	mova	&66618,	r12	;0x1043a
    7cb4:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

00007cb8 <.Loc.622.1>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    7cb8:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    7cbc:	4d 43       	clr.b	r13		;
    7cbe:	b0 13 18 97 	calla	#38680		;0x09718

00007cc2 <.LVL689>:
  if (hdr.reply) {
    7cc2:	0a 93       	cmp	#0,	r10	;r3 As==00
    7cc4:	07 20       	jnz	$+16     	;abs 0x7cd4

00007cc6 <.L326>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7cc6:	cc 08       	mova	r8,	r12	;
    7cc8:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007ccc <.LVL691>:
    7ccc:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007cd0 <.LVL692>:
    7cd0:	80 00 96 7c 	mova	#31894,	r0	;0x07c96

00007cd4 <.L328>:
    gen_success(hdr);
    7cd4:	81 49 00 00 	mov	r9,	0(r1)	;
    7cd8:	81 47 02 00 	mov	r7,	2(r1)	;
    7cdc:	cc 01       	mova	r1,	r12	;
    7cde:	b0 13 1a 69 	calla	#26906		;0x0691a

00007ce2 <.LVL695>:
    7ce2:	80 00 c6 7c 	mova	#31942,	r0	;0x07cc6

00007ce6 <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7ce6:	3a 14       	pushm.a	#4,	r10	;20-bit words

00007ce8 <.LCFI78>:
    7ce8:	b1 00 04 00 	suba	#4,	r1	;

00007cec <.LCFI79>:
    7cec:	29 4d       	mov	@r13,	r9	;

00007cee <.LVL697>:
    7cee:	18 4d 02 00 	mov	2(r13),	r8	;

00007cf2 <.LVL698>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    7cf2:	4a 49       	mov.b	r9,	r10	;
    7cf4:	6a f3       	and.b	#2,	r10	;r3 As==10
    7cf6:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    7cfa:	0a 93       	cmp	#0,	r10	;r3 As==00
    7cfc:	17 24       	jz	$+48     	;abs 0x7d2c
    7cfe:	6e 42       	mov.b	#4,	r14	;r2 As==10

00007d00 <.L330>:
    7d00:	ee 0c       	adda	r12,	r14	;
    7d02:	67 4e       	mov.b	@r14,	r7	;

00007d04 <.LVL699>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7d04:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007d08 <.LVL700>:
    7d08:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007d0c <.LVL701>:
  if (arg > 1) {
    7d0c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d0e:	4c 97       	cmp.b	r7,	r12	;
    7d10:	16 2c       	jc	$+46     	;abs 0x7d3e

00007d12 <.Loc.201.1>:
    if (hdr.reply) {
    7d12:	0a 93       	cmp	#0,	r10	;r3 As==00
    7d14:	0e 24       	jz	$+30     	;abs 0x7d32

00007d16 <.Loc.203.1>:
      gen_failure(hdr);
    7d16:	81 49 00 00 	mov	r9,	0(r1)	;
    7d1a:	81 48 02 00 	mov	r8,	2(r1)	;
    7d1e:	cc 01       	mova	r1,	r12	;
    7d20:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00007d24 <.L329>:
}
    7d24:	a1 00 04 00 	adda	#4,	r1	;
    7d28:	37 16       	popm.a	#4,	r10	;20-bit words
    7d2a:	10 01       	reta			;

00007d2c <.L335>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    7d2c:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7d2e:	80 00 00 7d 	mova	#32000,	r0	;0x07d00

00007d32 <.L332>:
      elyErrorSignal(ErrCmdFailure);
    7d32:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7d36:	b0 13 fa 96 	calla	#38650		;0x096fa

00007d3a <.LVL707>:
    7d3a:	80 00 24 7d 	mova	#32036,	r0	;0x07d24

00007d3e <.L331>:
  if (bank0p[RegGPOState] != arg) {
    7d3e:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    7d42:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    7d46:	16 24       	jz	$+46     	;abs 0x7d74

00007d48 <.Loc.214.1>:
    palWriteLine(LINE_GPO, arg);
    7d48:	40 18 1d 42 	movx.w	&0x00222,r13	;
    7d4c:	22 02 
    7d4e:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    7d52:	0c 47       	mov	r7,	r12	;
    7d54:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    7d58:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    7d5c:	0d dc       	bis	r12,	r13	;
    7d5e:	40 18 82 4d 	movx.w	r13,	&0x00222;
    7d62:	22 02 

00007d64 <.Loc.216.1>:
    elyEventSignal(EvtGPOChange);
    7d64:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    7d68:	b0 13 00 97 	calla	#38656		;0x09700

00007d6c <.LVL708>:
    bank0w[RegGPOState] = arg;
    7d6c:	2c 01 3a 04 	mova	&66618,	r12	;0x1043a
    7d70:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

00007d74 <.L334>:
  if (hdr.reply) {
    7d74:	0a 93       	cmp	#0,	r10	;r3 As==00
    7d76:	d6 27       	jz	$-82     	;abs 0x7d24

00007d78 <.Loc.222.1>:
    gen_success(hdr);
    7d78:	81 49 00 00 	mov	r9,	0(r1)	;
    7d7c:	81 48 02 00 	mov	r8,	2(r1)	;
    7d80:	cc 01       	mova	r1,	r12	;
    7d82:	b0 13 1a 69 	calla	#26906		;0x0691a

00007d86 <.LVL710>:
    7d86:	80 00 24 7d 	mova	#32036,	r0	;0x07d24

00007d8a <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7d8a:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007d8c <.LCFI80>:
    7d8c:	c6 0c       	mova	r12,	r6	;
    7d8e:	2a 4d       	mov	@r13,	r10	;

00007d90 <.LVL712>:
    7d90:	19 4d 02 00 	mov	2(r13),	r9	;

00007d94 <.LVL713>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7d94:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007d98 <.LVL714>:
    7d98:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007d9c <.LVL715>:
  if (hdr.reply) {
    7d9c:	47 4a       	mov.b	r10,	r7	;
    7d9e:	4c 47       	mov.b	r7,	r12	;
    7da0:	6c f3       	and.b	#2,	r12	;r3 As==10
    7da2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7da4:	02 20       	jnz	$+6      	;abs 0x7daa

00007da6 <.L336>:
}
    7da6:	46 16       	popm.a	#5,	r10	;20-bit words
    7da8:	10 01       	reta			;

00007daa <.L341>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7daa:	b0 13 44 61 	calla	#24900		;0x06144

00007dae <.LVL716>:
    7dae:	c8 0c       	mova	r12,	r8	;

00007db0 <.Loc.1157.1>:
    if (reply_buff == NULL) {
    7db0:	9c 00 00 00 	cmpa	#0,	r12	;
    7db4:	1a 24       	jz	$+54     	;abs 0x7dea

00007db6 <.Loc.1163.1>:
    reply_buff[0] = hdr.opcode;
    7db6:	5a 07       	rrum	#2,	r10	;

00007db8 <.LVL718>:
    7db8:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    7dbc:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00007dc0 <.Loc.1164.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7dc0:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    7dc4:	d8 4c 51 00 	mov.b	81(r12),2(r8)	;0x00051
    7dc8:	02 00 

00007dca <.Loc.1165.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7dca:	d8 4c 50 00 	mov.b	80(r12),3(r8)	;0x00050
    7dce:	03 00 

00007dd0 <.Loc.1166.1>:
    reply_buff[4] = bank0p[RegErrLogLvl];
    7dd0:	d8 4c 4d 00 	mov.b	77(r12),4(r8)	;0x0004d
    7dd4:	04 00 

00007dd6 <.Loc.1167.1>:
    if (hdr.crc) {
    7dd6:	17 b3       	bit	#1,	r7	;r3 As==01
    7dd8:	0f 20       	jnz	$+32     	;abs 0x7df8

00007dda <.Loc.1172.1>:
      reply_buff[1] = 1;
    7dda:	d8 43 01 00 	mov.b	#1,	1(r8)	;r3 As==01

00007dde <.L340>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7dde:	0d 49       	mov	r9,	r13	;
    7de0:	cc 08       	mova	r8,	r12	;
    7de2:	b0 13 f2 68 	calla	#26866		;0x068f2

00007de6 <.LVL719>:
    7de6:	80 00 a6 7d 	mova	#32166,	r0	;0x07da6

00007dea <.L342>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7dea:	cc 06       	mova	r6,	r12	;
    7dec:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007df0 <.LVL721>:
    7df0:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007df4 <.LVL722>:
      return;
    7df4:	80 00 a6 7d 	mova	#32166,	r0	;0x07da6

00007df8 <.L343>:
      reply_buff[1] = 3;
    7df8:	f8 40 03 00 	mov.b	#3,	1(r8)	;
    7dfc:	01 00 

00007dfe <.Loc.1169.1>:
      crcGenX25(reply_buff, 7);
    7dfe:	7d 40 07 00 	mov.b	#7,	r13	;
    7e02:	cc 08       	mova	r8,	r12	;
    7e04:	b0 13 d2 97 	calla	#38866		;0x097d2

00007e08 <.LVL724>:
    7e08:	80 00 de 7d 	mova	#32222,	r0	;0x07dde

00007e0c <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e0c:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007e0e <.LCFI81>:
    7e0e:	c6 0c       	mova	r12,	r6	;
    7e10:	2a 4d       	mov	@r13,	r10	;

00007e12 <.LVL726>:
    7e12:	19 4d 02 00 	mov	2(r13),	r9	;

00007e16 <.LVL727>:
  if (hdr.reply) {
    7e16:	47 4a       	mov.b	r10,	r7	;
    7e18:	4c 47       	mov.b	r7,	r12	;

00007e1a <.LVL728>:
    7e1a:	6c f3       	and.b	#2,	r12	;r3 As==10
    7e1c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7e1e:	1e 24       	jz	$+62     	;abs 0x7e5c

00007e20 <.LBB166>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7e20:	b0 13 44 61 	calla	#24900		;0x06144

00007e24 <.LVL729>:
    7e24:	c8 0c       	mova	r12,	r8	;

00007e26 <.LVL730>:
    if (reply_buff == NULL) {
    7e26:	9c 00 00 00 	cmpa	#0,	r12	;
    7e2a:	1f 24       	jz	$+64     	;abs 0x7e6a

00007e2c <.Loc.1102.1>:
    reply_buff[0] = hdr.opcode;
    7e2c:	5a 07       	rrum	#2,	r10	;

00007e2e <.LVL731>:
    7e2e:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    7e32:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00007e36 <.Loc.1103.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7e36:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    7e3a:	d8 4c 51 00 	mov.b	81(r12),2(r8)	;0x00051
    7e3e:	02 00 

00007e40 <.Loc.1104.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7e40:	d8 4c 50 00 	mov.b	80(r12),3(r8)	;0x00050
    7e44:	03 00 

00007e46 <.Loc.1105.1>:
    reply_buff[4] = bank0p[RegErrRptLvl];
    7e46:	d8 4c 4c 00 	mov.b	76(r12),4(r8)	;0x0004c
    7e4a:	04 00 

00007e4c <.Loc.1106.1>:
    if (hdr.crc) {
    7e4c:	17 b3       	bit	#1,	r7	;r3 As==01
    7e4e:	14 20       	jnz	$+42     	;abs 0x7e78

00007e50 <.Loc.1111.1>:
      reply_buff[1] = 1;
    7e50:	d8 43 01 00 	mov.b	#1,	1(r8)	;r3 As==01

00007e54 <.L349>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7e54:	0d 49       	mov	r9,	r13	;
    7e56:	cc 08       	mova	r8,	r12	;
    7e58:	b0 13 f2 68 	calla	#26866		;0x068f2

00007e5c <.L345>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7e5c:	cc 06       	mova	r6,	r12	;
    7e5e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007e62 <.LVL733>:
    7e62:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007e66 <.L344>:
}
    7e66:	46 16       	popm.a	#5,	r10	;20-bit words
    7e68:	10 01       	reta			;

00007e6a <.L350>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    7e6a:	cc 06       	mova	r6,	r12	;
    7e6c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007e70 <.LVL736>:
    7e70:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007e74 <.LVL737>:
      return;
    7e74:	80 00 66 7e 	mova	#32358,	r0	;0x07e66

00007e78 <.L351>:
      reply_buff[1] = 3;
    7e78:	f8 40 03 00 	mov.b	#3,	1(r8)	;
    7e7c:	01 00 

00007e7e <.Loc.1108.1>:
      crcGenX25(reply_buff, 7);
    7e7e:	7d 40 07 00 	mov.b	#7,	r13	;
    7e82:	cc 08       	mova	r8,	r12	;
    7e84:	b0 13 d2 97 	calla	#38866		;0x097d2

00007e88 <.LVL739>:
    7e88:	80 00 54 7e 	mova	#32340,	r0	;0x07e54

00007e8c <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e8c:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007e8e <.LCFI82>:
    7e8e:	27 4d       	mov	@r13,	r7	;

00007e90 <.LVL741>:
    7e90:	19 4d 02 00 	mov	2(r13),	r9	;

00007e94 <.LVL742>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7e94:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007e98 <.LVL743>:
    7e98:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007e9c <.LVL744>:
  if (hdr.reply) {
    7e9c:	48 47       	mov.b	r7,	r8	;
    7e9e:	4c 48       	mov.b	r8,	r12	;
    7ea0:	6c f3       	and.b	#2,	r12	;r3 As==10
    7ea2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7ea4:	02 20       	jnz	$+6      	;abs 0x7eaa

00007ea6 <.L352>:
}
    7ea6:	46 16       	popm.a	#5,	r10	;20-bit words
    7ea8:	10 01       	reta			;

00007eaa <.L357>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7eaa:	b0 13 44 61 	calla	#24900		;0x06144

00007eae <.LVL745>:
    7eae:	ca 0c       	mova	r12,	r10	;

00007eb0 <.Loc.1071.1>:
    if (reply_buff == NULL) {
    7eb0:	9c 00 00 00 	cmpa	#0,	r12	;
    7eb4:	f8 27       	jz	$-14     	;abs 0x7ea6

00007eb6 <.Loc.1076.1>:
    reply_buff[0] = hdr.opcode;
    7eb6:	0c 47       	mov	r7,	r12	;
    7eb8:	5c 07       	rrum	#2,	r12	;
    7eba:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    7ebe:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00007ec2 <.Loc.1077.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7ec2:	26 01 3e 04 	mova	&66622,	r6	;0x1043e
    7ec6:	da 46 51 00 	mov.b	81(r6),	2(r10)	;0x00051
    7eca:	02 00 

00007ecc <.Loc.1078.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7ecc:	da 46 50 00 	mov.b	80(r6),	3(r10)	;0x00050
    7ed0:	03 00 

00007ed2 <.Loc.1079.1>:
    reply_buff[1] = hdr.length + 2;
    7ed2:	57 0f       	rrum	#4,	r7	;
    7ed4:	57 0f       	rrum	#4,	r7	;

00007ed6 <.LVL747>:
    7ed6:	67 53       	incd.b	r7		;
    7ed8:	ca 47 01 00 	mov.b	r7,	1(r10)	;

00007edc <.LBB169>:
    for (int i = 0; i < 4; i++) {
    7edc:	4d 43       	clr.b	r13		;
    7ede:	80 00 06 7f 	mova	#32518,	r0	;0x07f06

00007ee2 <.L355>:
      reply_buff[i + 4] = bank0p[RegMissionTimeMsb - i];
    7ee2:	0e 4d       	mov	r13,	r14	;
    7ee4:	4e 0e       	rlam.a	#4,	r14	;
    7ee6:	4e 0d       	rram.a	#4,	r14	;
    7ee8:	cc 0e       	mova	r14,	r12	;
    7eea:	ac 00 04 00 	adda	#4,	r12	;
    7eee:	ec 0a       	adda	r10,	r12	;
    7ef0:	40 18 3e 40 	movx.w	#118,	r14	;0x00076
    7ef4:	76 00 
    7ef6:	40 18 0e 8d 	subx.w	r13,	r14	;
    7efa:	4e 0e       	rlam.a	#4,	r14	;
    7efc:	4e 0d       	rram.a	#4,	r14	;
    7efe:	ee 06       	adda	r6,	r14	;
    7f00:	ec 4e 00 00 	mov.b	@r14,	0(r12)	;

00007f04 <.Loc.1081.1>:
    for (int i = 0; i < 4; i++) {
    7f04:	1d 53       	inc	r13		;

00007f06 <.L354>:
    7f06:	7c 40 03 00 	mov.b	#3,	r12	;
    7f0a:	0c 9d       	cmp	r13,	r12	;
    7f0c:	ea 37       	jge	$-42     	;abs 0x7ee2

00007f0e <.LBE169>:
    if (hdr.crc) {
    7f0e:	18 b3       	bit	#1,	r8	;r3 As==01
    7f10:	06 20       	jnz	$+14     	;abs 0x7f1e

00007f12 <.L356>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7f12:	0d 49       	mov	r9,	r13	;
    7f14:	cc 0a       	mova	r10,	r12	;
    7f16:	b0 13 f2 68 	calla	#26866		;0x068f2

00007f1a <.LVL752>:
    7f1a:	80 00 a6 7e 	mova	#32422,	r0	;0x07ea6

00007f1e <.L358>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    7f1e:	5d 4a 01 00 	mov.b	1(r10),	r13	;

00007f22 <.LVL754>:
    7f22:	2d 52       	add	#4,	r13	;r2 As==10
    7f24:	4d 0e       	rlam.a	#4,	r13	;
    7f26:	4d 0d       	rram.a	#4,	r13	;
    7f28:	cc 0a       	mova	r10,	r12	;
    7f2a:	b0 13 d2 97 	calla	#38866		;0x097d2

00007f2e <.LVL755>:
    7f2e:	80 00 12 7f 	mova	#32530,	r0	;0x07f12

00007f32 <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f32:	4a 14       	pushm.a	#5,	r10	;20-bit words

00007f34 <.LCFI83>:
    7f34:	27 4d       	mov	@r13,	r7	;

00007f36 <.LVL757>:
    7f36:	16 4d 02 00 	mov	2(r13),	r6	;

00007f3a <.LVL758>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7f3a:	49 47       	mov.b	r7,	r9	;
    7f3c:	4a 49       	mov.b	r9,	r10	;
    7f3e:	6a f3       	and.b	#2,	r10	;r3 As==10
    7f40:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    7f44:	0a 93       	cmp	#0,	r10	;r3 As==00
    7f46:	19 24       	jz	$+52     	;abs 0x7f7a
    7f48:	6e 42       	mov.b	#4,	r14	;r2 As==10

00007f4a <.L360>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    7f4a:	28 01 3a 04 	mova	&66618,	r8	;0x1043a
    7f4e:	40 18 0e 4e 	movx.w	r14,	r14	;
    7f52:	ee 0c       	adda	r12,	r14	;

00007f54 <.LVL760>:
    7f54:	e8 4e 76 00 	mov.b	@r14,	118(r8)	; 0x0076

00007f58 <.Loc.1039.1>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    7f58:	d8 4e 01 00 	mov.b	1(r14),	117(r8)	; 0x0075
    7f5c:	75 00 

00007f5e <.Loc.1040.1>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    7f5e:	d8 4e 02 00 	mov.b	2(r14),	116(r8)	; 0x0074
    7f62:	74 00 

00007f64 <.Loc.1041.1>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    7f64:	d8 4e 03 00 	mov.b	3(r14),	115(r8)	; 0x0073
    7f68:	73 00 

00007f6a <.Loc.1043.1>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7f6a:	b0 13 ec 9d 	calla	#40428		;0x09dec

00007f6e <.LVL761>:
    7f6e:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00007f72 <.LVL762>:
  if (hdr.reply) {
    7f72:	0a 93       	cmp	#0,	r10	;r3 As==00
    7f74:	05 20       	jnz	$+12     	;abs 0x7f80

00007f76 <.L359>:
}
    7f76:	46 16       	popm.a	#5,	r10	;20-bit words
    7f78:	10 01       	reta			;

00007f7a <.L363>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7f7a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7f7c:	80 00 4a 7f 	mova	#32586,	r0	;0x07f4a

00007f80 <.L364>:
    uint8_t * reply_buff = elyFWGetBuffer();
    7f80:	b0 13 44 61 	calla	#24900		;0x06144

00007f84 <.LVL765>:
    7f84:	ca 0c       	mova	r12,	r10	;

00007f86 <.Loc.1047.1>:
    if (reply_buff == NULL) {
    7f86:	9c 00 00 00 	cmpa	#0,	r12	;
    7f8a:	f5 27       	jz	$-20     	;abs 0x7f76

00007f8c <.Loc.1052.1>:
    reply_buff[0] = hdr.opcode;
    7f8c:	0c 47       	mov	r7,	r12	;
    7f8e:	5c 07       	rrum	#2,	r12	;
    7f90:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    7f94:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00007f98 <.Loc.1053.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    7f98:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    7f9c:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    7fa0:	02 00 

00007fa2 <.Loc.1054.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    7fa2:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7fa6:	03 00 

00007fa8 <.Loc.1055.1>:
    reply_buff[1] = hdr.length - 2;
    7fa8:	57 0f       	rrum	#4,	r7	;
    7faa:	57 0f       	rrum	#4,	r7	;

00007fac <.LVL767>:
    7fac:	77 50 fe ff 	add.b	#-2,	r7	;#0xfffe
    7fb0:	4d 47       	mov.b	r7,	r13	;
    7fb2:	ca 47 01 00 	mov.b	r7,	1(r10)	;

00007fb6 <.Loc.1056.1>:
    if (hdr.crc) {
    7fb6:	19 b3       	bit	#1,	r9	;r3 As==01
    7fb8:	06 20       	jnz	$+14     	;abs 0x7fc6

00007fba <.L362>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    7fba:	0d 46       	mov	r6,	r13	;
    7fbc:	cc 0a       	mova	r10,	r12	;
    7fbe:	b0 13 f2 68 	calla	#26866		;0x068f2

00007fc2 <.LVL768>:
    7fc2:	80 00 76 7f 	mova	#32630,	r0	;0x07f76

00007fc6 <.L365>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    7fc6:	2d 52       	add	#4,	r13	;r2 As==10
    7fc8:	4d 0e       	rlam.a	#4,	r13	;
    7fca:	4d 0d       	rram.a	#4,	r13	;
    7fcc:	cc 0a       	mova	r10,	r12	;
    7fce:	b0 13 d2 97 	calla	#38866		;0x097d2

00007fd2 <.LVL769>:
    7fd2:	80 00 ba 7f 	mova	#32698,	r0	;0x07fba

00007fd6 <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7fd6:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007fd8 <.LCFI84>:
    7fd8:	06 14       	pushm.a	#1,	r6	;20-bit words

00007fda <.LCFI85>:
    7fda:	04 14       	pushm.a	#1,	r4	;20-bit words

00007fdc <.LCFI86>:
    7fdc:	b1 00 04 00 	suba	#4,	r1	;

00007fe0 <.LCFI87>:
    7fe0:	c8 0c       	mova	r12,	r8	;
    7fe2:	24 4d       	mov	@r13,	r4	;

00007fe4 <.LVL771>:
    7fe4:	1a 4d 02 00 	mov	2(r13),	r10	;

00007fe8 <.LVL772>:
  if (hdr.reply) {
    7fe8:	49 44       	mov.b	r4,	r9	;
    7fea:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7fee:	4c 49       	mov.b	r9,	r12	;

00007ff0 <.LVL773>:
    7ff0:	6c f3       	and.b	#2,	r12	;r3 As==10
    7ff2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7ff4:	68 24       	jz	$+210    	;abs 0x80c6

00007ff6 <.LBB171>:
    if ((buffer[4] < 0x40) || 
    7ff6:	5c 48 04 00 	mov.b	4(r8),	r12	;
    7ffa:	7d 40 3f 00 	mov.b	#63,	r13	;#0x003f
    7ffe:	4d 9c       	cmp.b	r12,	r13	;
    8000:	11 2c       	jc	$+36     	;abs 0x8024

00008002 <.Loc.828.1>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8002:	4d 4c       	mov.b	r12,	r13	;
    8004:	7d 50 af ff 	add.b	#-81,	r13	;#0xffaf

00008008 <.Loc.827.1>:
    if ((buffer[4] < 0x40) || 
    8008:	7e 40 0e 00 	mov.b	#14,	r14	;#0x000e
    800c:	4e 9d       	cmp.b	r13,	r14	;
    800e:	0a 2c       	jc	$+22     	;abs 0x8024

00008010 <.Loc.829.1>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    8010:	7d 50 ee ff 	add.b	#-18,	r13	;#0xffee

00008014 <.Loc.828.1>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    8014:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    8018:	4e 9d       	cmp.b	r13,	r14	;
    801a:	04 2c       	jc	$+10     	;abs 0x8024

0000801c <.Loc.829.1>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    801c:	7d 40 76 00 	mov.b	#118,	r13	;#0x0076
    8020:	4d 9c       	cmp.b	r12,	r13	;
    8022:	12 2c       	jc	$+38     	;abs 0x8048

00008024 <.L368>:
        gen_failure(hdr);
    8024:	81 44 00 00 	mov	r4,	0(r1)	;
    8028:	81 4a 02 00 	mov	r10,	2(r1)	;
    802c:	cc 01       	mova	r1,	r12	;
    802e:	b0 13 a8 6c 	calla	#27816		;0x06ca8

00008032 <.LVL776>:
        elyNLFreeBuffer(elyNLFromFW(buffer));
    8032:	cc 08       	mova	r8,	r12	;
    8034:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008038 <.LVL777>:
    8038:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000803c <.L366>:
}
    803c:	a1 00 04 00 	adda	#4,	r1	;
    8040:	04 16       	popm.a	#1,	r4	;20-bit words
    8042:	06 16       	popm.a	#1,	r6	;20-bit words
    8044:	28 16       	popm.a	#3,	r10	;20-bit words
    8046:	10 01       	reta			;

00008048 <.L369>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8048:	b0 13 44 61 	calla	#24900		;0x06144

0000804c <.LVL780>:
    804c:	c6 0c       	mova	r12,	r6	;

0000804e <.LVL781>:
    if (reply_buff == NULL) {
    804e:	9c 00 00 00 	cmpa	#0,	r12	;
    8052:	25 24       	jz	$+76     	;abs 0x809e

00008054 <.Loc.844.1>:
    reply_buff[0] = hdr.opcode;
    8054:	54 07       	rrum	#2,	r4	;

00008056 <.LVL782>:
    8056:	74 f0 3f 00 	and.b	#63,	r4	;#0x003f
    805a:	cc 44 00 00 	mov.b	r4,	0(r12)	;

0000805e <.Loc.845.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    805e:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    8062:	d6 4c 51 00 	mov.b	81(r12),2(r6)	;0x00051
    8066:	02 00 

00008068 <.Loc.846.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8068:	d6 4c 50 00 	mov.b	80(r12),3(r6)	;0x00050
    806c:	03 00 

0000806e <.Loc.849.1>:
    size_t n = elyChanGetValue(&reply_buff[4], buffer[4]);
    806e:	5d 48 04 00 	mov.b	4(r8),	r13	;
    8072:	cc 06       	mova	r6,	r12	;
    8074:	ac 00 04 00 	adda	#4,	r12	;
    8078:	b0 13 f4 96 	calla	#38644		;0x096f4

0000807c <.LVL783>:
    807c:	c4 0c       	mova	r12,	r4	;

0000807e <.LVL784>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    807e:	cc 08       	mova	r8,	r12	;
    8080:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008084 <.LVL785>:
    8084:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008088 <.LVL786>:
    if (hdr.crc) {
    8088:	19 b3       	bit	#1,	r9	;r3 As==01
    808a:	10 20       	jnz	$+34     	;abs 0x80ac

0000808c <.Loc.858.1>:
      reply_buff[1] = n + 1;
    808c:	54 53       	inc.b	r4		;

0000808e <.LVL787>:
    808e:	c6 44 01 00 	mov.b	r4,	1(r6)	;

00008092 <.L373>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8092:	0d 4a       	mov	r10,	r13	;
    8094:	cc 06       	mova	r6,	r12	;
    8096:	b0 13 f2 68 	calla	#26866		;0x068f2

0000809a <.LBE172>:
    809a:	80 00 3c 80 	mova	#32828,	r0	;0x0803c

0000809e <.L374>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    809e:	cc 08       	mova	r8,	r12	;
    80a0:	b0 13 ec 9d 	calla	#40428		;0x09dec

000080a4 <.LVL790>:
    80a4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000080a8 <.LVL791>:
      return;
    80a8:	80 00 3c 80 	mova	#32828,	r0	;0x0803c

000080ac <.L375>:
      reply_buff[1] = n + 3;
    80ac:	4c 44       	mov.b	r4,	r12	;
    80ae:	7c 50 03 00 	add.b	#3,	r12	;
    80b2:	c6 4c 01 00 	mov.b	r12,	1(r6)	;

000080b6 <.Loc.855.1>:
      crcGenX25(reply_buff, 7+n);
    80b6:	cd 04       	mova	r4,	r13	;
    80b8:	ad 00 07 00 	adda	#7,	r13	;
    80bc:	cc 06       	mova	r6,	r12	;
    80be:	b0 13 d2 97 	calla	#38866		;0x097d2

000080c2 <.LVL793>:
    80c2:	80 00 92 80 	mova	#32914,	r0	;0x08092

000080c6 <.L367>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    80c6:	cc 08       	mova	r8,	r12	;
    80c8:	b0 13 ec 9d 	calla	#40428		;0x09dec

000080cc <.LVL795>:
    80cc:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000080d0 <.LVL796>:
    80d0:	80 00 3c 80 	mova	#32828,	r0	;0x0803c

000080d4 <get_u32>:
    const uint32_t max, const uint32_t min) {
    80d4:	6a 14       	pushm.a	#7,	r10	;20-bit words

000080d6 <.LCFI88>:
    80d6:	b1 00 08 00 	suba	#8,	r1	;

000080da <.LCFI89>:
    80da:	46 4c       	mov.b	r12,	r6	;
    80dc:	2a 4d       	mov	@r13,	r10	;

000080de <.LVL798>:
    80de:	1c 4d 02 00 	mov	2(r13),	r12	;

000080e2 <.LVL799>:
    80e2:	81 4e 00 00 	mov	r14,	0(r1)	;
    80e6:	05 4f       	mov	r15,	r5	;
    80e8:	91 41 28 00 	mov	40(r1),	6(r1)	;0x00028
    80ec:	06 00 
    80ee:	91 41 2a 00 	mov	42(r1),	2(r1)	;0x0002a
    80f2:	02 00 

000080f4 <.Loc.82.1>:
static void get_u32(const uint8_t addr, elysium_cmd_hdr_t hdr, 
    80f4:	81 4c 04 00 	mov	r12,	4(r1)	;

000080f8 <.Loc.85.1>:
  if (hdr.reply) {
    80f8:	47 4a       	mov.b	r10,	r7	;
    80fa:	4c 47       	mov.b	r7,	r12	;

000080fc <.LVL801>:
    80fc:	6c f3       	and.b	#2,	r12	;r3 As==10
    80fe:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8100:	04 20       	jnz	$+10     	;abs 0x810a

00008102 <.L376>:
}
    8102:	a1 00 08 00 	adda	#8,	r1	;
    8106:	64 16       	popm.a	#7,	r10	;20-bit words
    8108:	10 01       	reta			;

0000810a <.L394>:
    uint8_t * reply_buff = elyFWGetBuffer();
    810a:	b0 13 44 61 	calla	#24900		;0x06144

0000810e <.LVL804>:
    810e:	c4 0c       	mova	r12,	r4	;

00008110 <.Loc.87.1>:
    if (reply_buff == NULL) {
    8110:	9c 00 00 00 	cmpa	#0,	r12	;
    8114:	f6 27       	jz	$-18     	;abs 0x8102

00008116 <.Loc.92.1>:
    reply_buff[0] = hdr.opcode;
    8116:	5a 07       	rrum	#2,	r10	;
    8118:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    811c:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00008120 <.Loc.93.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8120:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    8124:	d4 4c 51 00 	mov.b	81(r12),2(r4)	;0x00051
    8128:	02 00 

0000812a <.Loc.94.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    812a:	d4 4c 50 00 	mov.b	80(r12),3(r4)	;0x00050
    812e:	03 00 

00008130 <.LBB175>:
    for (int i = 0; i < 4; i++) {
    8130:	4a 43       	clr.b	r10		;

00008132 <.LBE175>:
    uint32_t val = 0;
    8132:	08 4a       	mov	r10,	r8	;
    8134:	09 4a       	mov	r10,	r9	;

00008136 <.LBB176>:
    for (int i = 0; i < 4; i++) {
    8136:	80 00 5e 81 	mova	#33118,	r0	;0x0815e

0000813a <.L379>:
      val |= ((uint32_t)(bank0p[addr + i]) << (8 * i));
    813a:	0c 46       	mov	r6,	r12	;
    813c:	0c 5a       	add	r10,	r12	;
    813e:	4c 0e       	rlam.a	#4,	r12	;
    8140:	4c 0d       	rram.a	#4,	r12	;
    8142:	80 18 5c 52 	addx.a	&0x1043e,r12	;
    8146:	3e 04 
    8148:	0e 4a       	mov	r10,	r14	;
    814a:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    814e:	6c 4c       	mov.b	@r12,	r12	;
    8150:	0d 43       	clr	r13		;
    8152:	0f 43       	clr	r15		;
    8154:	b0 13 18 9f 	calla	#40728		;0x09f18
    8158:	08 dc       	bis	r12,	r8	;

0000815a <.LVL809>:
    815a:	09 dd       	bis	r13,	r9	;

0000815c <.LVL810>:
    for (int i = 0; i < 4; i++) {
    815c:	1a 53       	inc	r10		;

0000815e <.L378>:
    815e:	7c 40 03 00 	mov.b	#3,	r12	;
    8162:	0c 9a       	cmp	r10,	r12	;
    8164:	ea 37       	jge	$-42     	;abs 0x813a

00008166 <.LBE176>:
    if (val > max) {
    8166:	05 99       	cmp	r9,	r5	;
    8168:	30 28       	jnc	$+98     	;abs 0x81ca
    816a:	09 95       	cmp	r5,	r9	;
    816c:	03 20       	jnz	$+8      	;abs 0x8174
    816e:	81 98 00 00 	cmp	r8,	0(r1)	;
    8172:	2b 28       	jnc	$+88     	;abs 0x81ca

00008174 <.L382>:
    else if (val < min) {
    8174:	19 91 02 00 	cmp	2(r1),	r9	;
    8178:	06 28       	jnc	$+14     	;abs 0x8186
    817a:	81 99 02 00 	cmp	r9,	2(r1)	;
    817e:	22 20       	jnz	$+70     	;abs 0x81c4
    8180:	18 91 06 00 	cmp	6(r1),	r8	;
    8184:	1f 2c       	jc	$+64     	;abs 0x81c4

00008186 <.L393>:
    8186:	49 43       	clr.b	r9		;

00008188 <.LVL812>:
    8188:	15 41 06 00 	mov	6(r1),	r5	;
    818c:	18 41 02 00 	mov	2(r1),	r8	;
    8190:	80 00 f6 81 	mova	#33270,	r0	;0x081f6

00008194 <.L383>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    8194:	0a 46       	mov	r6,	r10	;
    8196:	0a 59       	add	r9,	r10	;
    8198:	4a 0e       	rlam.a	#4,	r10	;
    819a:	4a 0d       	rram.a	#4,	r10	;
    819c:	80 18 5a 52 	addx.a	&0x1043a,r10	;
    81a0:	3a 04 
    81a2:	0e 49       	mov	r9,	r14	;
    81a4:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    81a8:	0c 48       	mov	r8,	r12	;
    81aa:	0d 45       	mov	r5,	r13	;
    81ac:	0f 43       	clr	r15		;
    81ae:	b0 13 cc 9f 	calla	#40908		;0x09fcc
    81b2:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

000081b6 <.Loc.103.1>:
      for (int i = 0; i < 4; i++) {
    81b6:	19 53       	inc	r9		;

000081b8 <.L380>:
    81b8:	7c 40 03 00 	mov.b	#3,	r12	;
    81bc:	0c 99       	cmp	r9,	r12	;
    81be:	ea 37       	jge	$-42     	;abs 0x8194

000081c0 <.LBE177>:
      val = max;
    81c0:	28 41       	mov	@r1,	r8	;
    81c2:	09 45       	mov	r5,	r9	;

000081c4 <.L384>:
    for (int i = 0; i < 4; i++) {
    81c4:	46 43       	clr.b	r6		;
    81c6:	80 00 36 82 	mova	#33334,	r0	;0x08236

000081ca <.L392>:
    81ca:	49 43       	clr.b	r9		;

000081cc <.LVL818>:
    81cc:	28 41       	mov	@r1,	r8	;
    81ce:	80 00 b8 81 	mova	#33208,	r0	;0x081b8

000081d2 <.L387>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    81d2:	0a 46       	mov	r6,	r10	;
    81d4:	0a 59       	add	r9,	r10	;
    81d6:	4a 0e       	rlam.a	#4,	r10	;
    81d8:	4a 0d       	rram.a	#4,	r10	;
    81da:	80 18 5a 52 	addx.a	&0x1043a,r10	;
    81de:	3a 04 
    81e0:	0e 49       	mov	r9,	r14	;
    81e2:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    81e6:	0c 45       	mov	r5,	r12	;
    81e8:	0d 48       	mov	r8,	r13	;
    81ea:	0f 43       	clr	r15		;
    81ec:	b0 13 cc 9f 	calla	#40908		;0x09fcc
    81f0:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

000081f4 <.Loc.109.1>:
      for (int i = 0; i < 4; i++) {
    81f4:	19 53       	inc	r9		;

000081f6 <.L385>:
    81f6:	7c 40 03 00 	mov.b	#3,	r12	;
    81fa:	0c 99       	cmp	r9,	r12	;
    81fc:	ea 37       	jge	$-42     	;abs 0x81d2

000081fe <.LBE179>:
      val = min;
    81fe:	18 41 06 00 	mov	6(r1),	r8	;
    8202:	19 41 02 00 	mov	2(r1),	r9	;

00008206 <.LVL822>:
    8206:	80 00 c4 81 	mova	#33220,	r0	;0x081c4

0000820a <.L389>:
      reply_buff[i + 4] = ((val >> (8 * (3 - i))) & 0xFF);
    820a:	0c 46       	mov	r6,	r12	;
    820c:	4c 0e       	rlam.a	#4,	r12	;
    820e:	4c 0d       	rram.a	#4,	r12	;
    8210:	ca 0c       	mova	r12,	r10	;
    8212:	aa 00 04 00 	adda	#4,	r10	;
    8216:	ea 04       	adda	r4,	r10	;
    8218:	40 18 3e 40 	movx.w	#3,	r14	;
    821c:	03 00 
    821e:	40 18 0e 86 	subx.w	r6,	r14	;
    8222:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8226:	0c 48       	mov	r8,	r12	;
    8228:	0d 49       	mov	r9,	r13	;
    822a:	0f 43       	clr	r15		;
    822c:	b0 13 cc 9f 	calla	#40908		;0x09fcc
    8230:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00008234 <.Loc.114.1>:
    for (int i = 0; i < 4; i++) {
    8234:	16 53       	inc	r6		;

00008236 <.L388>:
    8236:	7c 40 03 00 	mov.b	#3,	r12	;
    823a:	0c 96       	cmp	r6,	r12	;
    823c:	e6 37       	jge	$-50     	;abs 0x820a

0000823e <.LBE180>:
    if (hdr.crc) {
    823e:	17 b3       	bit	#1,	r7	;r3 As==01
    8240:	09 20       	jnz	$+20     	;abs 0x8254

00008242 <.Loc.123.1>:
      reply_buff[1] = 4;
    8242:	e4 42 01 00 	mov.b	#4,	1(r4)	;r2 As==10

00008246 <.L391>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8246:	1d 41 04 00 	mov	4(r1),	r13	;
    824a:	cc 04       	mova	r4,	r12	;
    824c:	b0 13 f2 68 	calla	#26866		;0x068f2

00008250 <.LVL826>:
    8250:	80 00 02 81 	mova	#33026,	r0	;0x08102

00008254 <.L395>:
      reply_buff[1] = 6;
    8254:	f4 40 06 00 	mov.b	#6,	1(r4)	;
    8258:	01 00 

0000825a <.Loc.120.1>:
      crcGenX25(reply_buff, 10);
    825a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    825e:	cc 04       	mova	r4,	r12	;
    8260:	b0 13 d2 97 	calla	#38866		;0x097d2

00008264 <.LVL827>:
    8264:	80 00 46 82 	mova	#33350,	r0	;0x08246

00008268 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8268:	19 14       	pushm.a	#2,	r9	;20-bit words

0000826a <.LCFI90>:
    826a:	b1 00 08 00 	suba	#8,	r1	;

0000826e <.LCFI91>:
    826e:	28 4d       	mov	@r13,	r8	;

00008270 <.LVL829>:
    8270:	19 4d 02 00 	mov	2(r13),	r9	;

00008274 <.LVL830>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8274:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008278 <.LVL831>:
    8278:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000827c <.LVL832>:
  get_u32(RegUARTBaudLsb, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    827c:	81 48 04 00 	mov	r8,	4(r1)	;
    8280:	81 49 06 00 	mov	r9,	6(r1)	;
    8284:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    8288:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    828c:	3e 40 40 42 	mov	#16960,	r14	;#0x4240
    8290:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    8294:	cd 01       	mova	r1,	r13	;
    8296:	ad 00 04 00 	adda	#4,	r13	;
    829a:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    829e:	b0 13 d4 80 	calla	#32980		;0x080d4

000082a2 <.LVL833>:
}
    82a2:	a1 00 08 00 	adda	#8,	r1	;
    82a6:	18 16       	popm.a	#2,	r9	;20-bit words
    82a8:	10 01       	reta			;

000082aa <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    82aa:	19 14       	pushm.a	#2,	r9	;20-bit words

000082ac <.LCFI92>:
    82ac:	b1 00 08 00 	suba	#8,	r1	;

000082b0 <.LCFI93>:
    82b0:	28 4d       	mov	@r13,	r8	;

000082b2 <.LVL835>:
    82b2:	19 4d 02 00 	mov	2(r13),	r9	;

000082b6 <.LVL836>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    82b6:	b0 13 ec 9d 	calla	#40428		;0x09dec

000082ba <.LVL837>:
    82ba:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000082be <.LVL838>:
  get_u32(RegRXDevLsb, hdr, RX_DEV_MAX, RX_DEV_MIN);
    82be:	81 48 04 00 	mov	r8,	4(r1)	;
    82c2:	81 49 06 00 	mov	r9,	6(r1)	;
    82c6:	b1 40 e8 80 	mov	#-32536,0(r1)	;#0x80e8
    82ca:	00 00 
    82cc:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    82d0:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    82d4:	7f 40 03 00 	mov.b	#3,	r15	;
    82d8:	cd 01       	mova	r1,	r13	;
    82da:	ad 00 04 00 	adda	#4,	r13	;
    82de:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c
    82e2:	b0 13 d4 80 	calla	#32980		;0x080d4

000082e6 <.LVL839>:
}
    82e6:	a1 00 08 00 	adda	#8,	r1	;
    82ea:	18 16       	popm.a	#2,	r9	;20-bit words
    82ec:	10 01       	reta			;

000082ee <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    82ee:	19 14       	pushm.a	#2,	r9	;20-bit words

000082f0 <.LCFI94>:
    82f0:	b1 00 08 00 	suba	#8,	r1	;

000082f4 <.LCFI95>:
    82f4:	28 4d       	mov	@r13,	r8	;

000082f6 <.LVL841>:
    82f6:	19 4d 02 00 	mov	2(r13),	r9	;

000082fa <.LVL842>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    82fa:	b0 13 ec 9d 	calla	#40428		;0x09dec

000082fe <.LVL843>:
    82fe:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008302 <.LVL844>:
  get_u32(RegTXDevLsb, hdr, TX_DEV_MAX, TX_DEV_MIN);
    8302:	81 48 04 00 	mov	r8,	4(r1)	;
    8306:	81 49 06 00 	mov	r9,	6(r1)	;
    830a:	b1 40 58 02 	mov	#600,	0(r1)	;#0x0258
    830e:	00 00 
    8310:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8314:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    8318:	7f 40 03 00 	mov.b	#3,	r15	;
    831c:	cd 01       	mova	r1,	r13	;
    831e:	ad 00 04 00 	adda	#4,	r13	;
    8322:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8324:	b0 13 d4 80 	calla	#32980		;0x080d4

00008328 <.LVL845>:
}
    8328:	a1 00 08 00 	adda	#8,	r1	;
    832c:	18 16       	popm.a	#2,	r9	;20-bit words
    832e:	10 01       	reta			;

00008330 <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8330:	19 14       	pushm.a	#2,	r9	;20-bit words

00008332 <.LCFI96>:
    8332:	b1 00 08 00 	suba	#8,	r1	;

00008336 <.LCFI97>:
    8336:	28 4d       	mov	@r13,	r8	;

00008338 <.LVL847>:
    8338:	19 4d 02 00 	mov	2(r13),	r9	;

0000833c <.LVL848>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    833c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008340 <.LVL849>:
    8340:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008344 <.LVL850>:
  get_u32(RegRXBRLsb, hdr, RX_BR_MAX, RX_BR_MIN);
    8344:	81 48 04 00 	mov	r8,	4(r1)	;
    8348:	81 49 06 00 	mov	r9,	6(r1)	;
    834c:	b1 40 0c 03 	mov	#780,	0(r1)	;#0x030c
    8350:	00 00 
    8352:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8356:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    835a:	6f 43       	mov.b	#2,	r15	;r3 As==10
    835c:	cd 01       	mova	r1,	r13	;
    835e:	ad 00 04 00 	adda	#4,	r13	;
    8362:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c
    8366:	b0 13 d4 80 	calla	#32980		;0x080d4

0000836a <.LVL851>:
}
    836a:	a1 00 08 00 	adda	#8,	r1	;
    836e:	18 16       	popm.a	#2,	r9	;20-bit words
    8370:	10 01       	reta			;

00008372 <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8372:	19 14       	pushm.a	#2,	r9	;20-bit words

00008374 <.LCFI98>:
    8374:	b1 00 08 00 	suba	#8,	r1	;

00008378 <.LCFI99>:
    8378:	28 4d       	mov	@r13,	r8	;

0000837a <.LVL853>:
    837a:	19 4d 02 00 	mov	2(r13),	r9	;

0000837e <.LVL854>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    837e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008382 <.LVL855>:
    8382:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008386 <.LVL856>:
  get_u32(RegTXBRLsb, hdr, TX_BR_MAX, TX_BR_MIN);
    8386:	81 48 04 00 	mov	r8,	4(r1)	;
    838a:	81 49 06 00 	mov	r9,	6(r1)	;
    838e:	b1 40 b0 04 	mov	#1200,	0(r1)	;#0x04b0
    8392:	00 00 
    8394:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8398:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    839c:	6f 42       	mov.b	#4,	r15	;r2 As==10
    839e:	cd 01       	mova	r1,	r13	;
    83a0:	ad 00 04 00 	adda	#4,	r13	;
    83a4:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    83a8:	b0 13 d4 80 	calla	#32980		;0x080d4

000083ac <.LVL857>:
}
    83ac:	a1 00 08 00 	adda	#8,	r1	;
    83b0:	18 16       	popm.a	#2,	r9	;20-bit words
    83b2:	10 01       	reta			;

000083b4 <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83b4:	19 14       	pushm.a	#2,	r9	;20-bit words

000083b6 <.LCFI100>:
    83b6:	b1 00 08 00 	suba	#8,	r1	;

000083ba <.LCFI101>:
    83ba:	28 4d       	mov	@r13,	r8	;

000083bc <.LVL859>:
    83bc:	19 4d 02 00 	mov	2(r13),	r9	;

000083c0 <.LVL860>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    83c0:	b0 13 ec 9d 	calla	#40428		;0x09dec

000083c4 <.LVL861>:
    83c4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000083c8 <.LVL862>:
  get_u32(RegRXFreqLsb, hdr, RX_BAND_MAX, RX_BAND_MIN);
    83c8:	81 48 04 00 	mov	r8,	4(r1)	;
    83cc:	81 49 06 00 	mov	r9,	6(r1)	;
    83d0:	b1 40 40 44 	mov	#17472,	0(r1)	;#0x4440
    83d4:	00 00 
    83d6:	b1 40 3d 1b 	mov	#6973,	2(r1)	;#0x1b3d
    83da:	02 00 
    83dc:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    83e0:	3f 40 12 1c 	mov	#7186,	r15	;#0x1c12
    83e4:	cd 01       	mova	r1,	r13	;
    83e6:	ad 00 04 00 	adda	#4,	r13	;
    83ea:	6c 42       	mov.b	#4,	r12	;r2 As==10
    83ec:	b0 13 d4 80 	calla	#32980		;0x080d4

000083f0 <.LVL863>:
}
    83f0:	a1 00 08 00 	adda	#8,	r1	;
    83f4:	18 16       	popm.a	#2,	r9	;20-bit words
    83f6:	10 01       	reta			;

000083f8 <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83f8:	19 14       	pushm.a	#2,	r9	;20-bit words

000083fa <.LCFI102>:
    83fa:	b1 00 08 00 	suba	#8,	r1	;

000083fe <.LCFI103>:
    83fe:	28 4d       	mov	@r13,	r8	;

00008400 <.LVL865>:
    8400:	19 4d 02 00 	mov	2(r13),	r9	;

00008404 <.LVL866>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8404:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008408 <.LVL867>:
    8408:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000840c <.LVL868>:
  get_u32(RegTXFreqLsb, hdr, TX_BAND_MAX, TX_BAND_MIN);
    840c:	81 48 04 00 	mov	r8,	4(r1)	;
    8410:	81 49 06 00 	mov	r9,	6(r1)	;
    8414:	b1 40 40 da 	mov	#-9664,	0(r1)	;#0xda40
    8418:	00 00 
    841a:	b1 40 8e 33 	mov	#13198,	2(r1)	;#0x338e
    841e:	02 00 
    8420:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    8424:	3f 40 ec 38 	mov	#14572,	r15	;#0x38ec
    8428:	cd 01       	mova	r1,	r13	;
    842a:	ad 00 04 00 	adda	#4,	r13	;
    842e:	4c 43       	clr.b	r12		;
    8430:	b0 13 d4 80 	calla	#32980		;0x080d4

00008434 <.LVL869>:
}
    8434:	a1 00 08 00 	adda	#8,	r1	;
    8438:	18 16       	popm.a	#2,	r9	;20-bit words
    843a:	10 01       	reta			;

0000843c <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    843c:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000843e <.LCFI104>:
    843e:	c6 0c       	mova	r12,	r6	;
    8440:	2a 4d       	mov	@r13,	r10	;

00008442 <.LVL871>:
    8442:	19 4d 02 00 	mov	2(r13),	r9	;

00008446 <.LVL872>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8446:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000844a <.LVL873>:
    844a:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000844e <.LVL874>:
  if (hdr.reply) {
    844e:	47 4a       	mov.b	r10,	r7	;
    8450:	4c 47       	mov.b	r7,	r12	;
    8452:	6c f3       	and.b	#2,	r12	;r3 As==10
    8454:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8456:	02 20       	jnz	$+6      	;abs 0x845c

00008458 <.L403>:
}
    8458:	46 16       	popm.a	#5,	r10	;20-bit words
    845a:	10 01       	reta			;

0000845c <.L407>:
    uint8_t * reply_buff = elyFWGetBuffer();
    845c:	b0 13 44 61 	calla	#24900		;0x06144

00008460 <.LVL875>:
    8460:	c8 0c       	mova	r12,	r8	;

00008462 <.Loc.583.1>:
    if (reply_buff == NULL) {
    8462:	9c 00 00 00 	cmpa	#0,	r12	;
    8466:	f8 27       	jz	$-14     	;abs 0x8458

00008468 <.Loc.588.1>:
    reply_buff[0] = hdr.opcode;
    8468:	5a 07       	rrum	#2,	r10	;

0000846a <.LVL877>:
    846a:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    846e:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

00008472 <.Loc.589.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8472:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    8476:	d8 4c 51 00 	mov.b	81(r12),2(r8)	;0x00051
    847a:	02 00 

0000847c <.Loc.590.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    847c:	d8 4c 50 00 	mov.b	80(r12),3(r8)	;0x00050
    8480:	03 00 

00008482 <.Loc.591.1>:
    reply_buff[4] = bank0p[RegOutputPower];
    8482:	d8 4c 21 00 	mov.b	33(r12),4(r8)	;0x00021
    8486:	04 00 

00008488 <.Loc.592.1>:
    if (hdr.crc) {
    8488:	17 b3       	bit	#1,	r7	;r3 As==01
    848a:	08 20       	jnz	$+18     	;abs 0x849c

0000848c <.Loc.597.1>:
      reply_buff[1] = 1;
    848c:	d8 43 01 00 	mov.b	#1,	1(r8)	;r3 As==01

00008490 <.L406>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8490:	0d 49       	mov	r9,	r13	;
    8492:	cc 08       	mova	r8,	r12	;
    8494:	b0 13 f2 68 	calla	#26866		;0x068f2

00008498 <.LVL878>:
    8498:	80 00 58 84 	mova	#33880,	r0	;0x08458

0000849c <.L408>:
      reply_buff[1] = 3;
    849c:	f8 40 03 00 	mov.b	#3,	1(r8)	;
    84a0:	01 00 

000084a2 <.Loc.594.1>:
      crcGenX25(buffer, 7);
    84a2:	7d 40 07 00 	mov.b	#7,	r13	;
    84a6:	cc 06       	mova	r6,	r12	;
    84a8:	b0 13 d2 97 	calla	#38866		;0x097d2

000084ac <.LVL879>:
    84ac:	80 00 90 84 	mova	#33936,	r0	;0x08490

000084b0 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    84b0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000084b2 <.LCFI105>:
    84b2:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

000084b6 <.LCFI106>:
    84b6:	c4 0c       	mova	r12,	r4	;
    84b8:	2a 4d       	mov	@r13,	r10	;

000084ba <.LVL881>:
    84ba:	19 4d 02 00 	mov	2(r13),	r9	;

000084be <.LVL882>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    84be:	4c 4a       	mov.b	r10,	r12	;

000084c0 <.LVL883>:
    84c0:	4f 4c       	mov.b	r12,	r15	;
    84c2:	6f f3       	and.b	#2,	r15	;r3 As==10
    84c4:	48 4f       	mov.b	r15,	r8	;
    84c6:	08 93       	cmp	#0,	r8	;r3 As==00
    84c8:	41 24       	jz	$+132    	;abs 0x854c
    84ca:	6d 42       	mov.b	#4,	r13	;r2 As==10

000084cc <.L410>:
  uint8_t bank = buffer[hdr_ext];
    84cc:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    84d0:	00 00 
    84d2:	0e 01       	mova	@r1,	r14	;
    84d4:	ee 04       	adda	r4,	r14	;
    84d6:	6e 4e       	mov.b	@r14,	r14	;
    84d8:	81 4e 06 00 	mov	r14,	6(r1)	;

000084dc <.LVL885>:
  uint8_t addr = buffer[hdr_ext+1];
    84dc:	0e 01       	mova	@r1,	r14	;
    84de:	ae 00 01 00 	adda	#1,	r14	;
    84e2:	ee 04       	adda	r4,	r14	;
    84e4:	67 4e       	mov.b	@r14,	r7	;

000084e6 <.LVL886>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    84e6:	0d 4a       	mov	r10,	r13	;

000084e8 <.LVL887>:
    84e8:	5d 0f       	rrum	#4,	r13	;
    84ea:	5d 0f       	rrum	#4,	r13	;
    84ec:	4d 8f       	sub.b	r15,	r13	;
    84ee:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    84f2:	2f 24       	jz	$+96     	;abs 0x8552

000084f4 <.Loc.408.1>:
    84f4:	6e 43       	mov.b	#2,	r14	;r3 As==10

000084f6 <.L411>:
    84f6:	40 18 4c 4d 	movx.b	r13,	r12	;
    84fa:	40 18 4c 8e 	subx.b	r14,	r12	;
    84fe:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    8502:	c1 4c 04 00 	mov.b	r12,	4(r1)	;
    8506:	45 4c       	mov.b	r12,	r5	;

00008508 <.LVL889>:
  uint8_t * reply_buff = elyFWGetBuffer();
    8508:	b0 13 44 61 	calla	#24900		;0x06144

0000850c <.LVL890>:
    850c:	c6 0c       	mova	r12,	r6	;

0000850e <.LVL891>:
  if (reply_buff == NULL) {
    850e:	9c 00 00 00 	cmpa	#0,	r12	;
    8512:	22 24       	jz	$+70     	;abs 0x8558

00008514 <.Loc.417.1>:
  if (bank == 0 || bank > 4 || 
    8514:	1c 41 06 00 	mov	6(r1),	r12	;
    8518:	7c 53       	add.b	#-1,	r12	;r3 As==11
    851a:	7d 40 03 00 	mov.b	#3,	r13	;
    851e:	4d 9c       	cmp.b	r12,	r13	;
    8520:	0a 28       	jnc	$+22     	;abs 0x8536

00008522 <.Loc.418.1>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    8522:	0c 47       	mov	r7,	r12	;
    8524:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    8528:	57 00 
    852a:	40 18 0d 85 	subx.w	r5,	r13	;

0000852e <.Loc.417.1>:
  if (bank == 0 || bank > 4 || 
    852e:	07 9d       	cmp	r13,	r7	;
    8530:	1a 38       	jl	$+54     	;abs 0x8566

00008532 <.Loc.418.1>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    8532:	47 93       	cmp.b	#0,	r7	;r3 As==00
    8534:	18 38       	jl	$+50     	;abs 0x8566

00008536 <.L414>:
    if (hdr.reply) {
    8536:	08 93       	cmp	#0,	r8	;r3 As==00
    8538:	4d 20       	jnz	$+156    	;abs 0x85d4

0000853a <.L418>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    853a:	cc 04       	mova	r4,	r12	;
    853c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008540 <.LVL892>:
    8540:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008544 <.L409>:
}
    8544:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    8548:	64 16       	popm.a	#7,	r10	;20-bit words
    854a:	10 01       	reta			;

0000854c <.L420>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    854c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    854e:	80 00 cc 84 	mova	#33996,	r0	;0x084cc

00008552 <.L421>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8552:	4e 43       	clr.b	r14		;

00008554 <.LVL896>:
    8554:	80 00 f6 84 	mova	#34038,	r0	;0x084f6

00008558 <.L422>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8558:	cc 04       	mova	r4,	r12	;
    855a:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000855e <.LVL898>:
    855e:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008562 <.LVL899>:
    return;
    8562:	80 00 44 85 	mova	#34116,	r0	;0x08544

00008566 <.L415>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8566:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    856a:	8b 00 
    856c:	40 18 0d 85 	subx.w	r5,	r13	;

00008570 <.Loc.418.1>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    8570:	0c 9d       	cmp	r13,	r12	;
    8572:	04 38       	jl	$+10     	;abs 0x857c

00008574 <.Loc.419.1>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8574:	7d 40 bf ff 	mov.b	#-65,	r13	;#0xffbf
    8578:	4d 97       	cmp.b	r7,	r13	;
    857a:	dd 2f       	jc	$-68     	;abs 0x8536

0000857c <.L416>:
      (addr >= RegDLLMAX - count + 1)) {
    857c:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    8580:	d6 00 
    8582:	40 18 0d 85 	subx.w	r5,	r13	;

00008586 <.Loc.419.1>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    8586:	0c 9d       	cmp	r13,	r12	;
    8588:	d6 37       	jge	$-82     	;abs 0x8536

0000858a <.Loc.429.1>:
  memcpy(reply_buff + 4, buffer + hdr_ext + 2, count);
    858a:	0d 01       	mova	@r1,	r13	;
    858c:	ad 00 02 00 	adda	#2,	r13	;
    8590:	5c 41 04 00 	mov.b	4(r1),	r12	;
    8594:	40 18 0e 4c 	movx.w	r12,	r14	;
    8598:	ed 04       	adda	r4,	r13	;
    859a:	c5 06       	mova	r6,	r5	;
    859c:	a5 00 04 00 	adda	#4,	r5	;
    85a0:	cc 05       	mova	r5,	r12	;
    85a2:	b0 13 f4 9f 	calla	#40948		;0x09ff4

000085a6 <.LVL900>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    85a6:	cc 04       	mova	r4,	r12	;
    85a8:	b0 13 ec 9d 	calla	#40428		;0x09dec

000085ac <.LVL901>:
    85ac:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000085b0 <.LVL902>:
  elyRegSetBlock(bank, reply_buff + 4, addr, count);
    85b0:	5f 41 04 00 	mov.b	4(r1),	r15	;
    85b4:	4e 47       	mov.b	r7,	r14	;
    85b6:	cd 05       	mova	r5,	r13	;
    85b8:	17 41 06 00 	mov	6(r1),	r7	;

000085bc <.LVL903>:
    85bc:	4c 47       	mov.b	r7,	r12	;
    85be:	b0 13 2a 91 	calla	#37162		;0x0912a

000085c2 <.LVL904>:
  if (hdr.reply) {
    85c2:	08 93       	cmp	#0,	r8	;r3 As==00
    85c4:	17 20       	jnz	$+48     	;abs 0x85f4

000085c6 <.Loc.441.1>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    85c6:	cc 06       	mova	r6,	r12	;
    85c8:	b0 13 ec 9d 	calla	#40428		;0x09dec

000085cc <.LVL905>:
    85cc:	b0 13 7c 61 	calla	#24956		;0x0617c

000085d0 <.LVL906>:
    85d0:	80 00 44 85 	mova	#34116,	r0	;0x08544

000085d4 <.L423>:
      write_failure(reply_buff, hdr);
    85d4:	81 4a 08 00 	mov	r10,	8(r1)	;
    85d8:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    85dc:	cd 01       	mova	r1,	r13	;
    85de:	ad 00 08 00 	adda	#8,	r13	;
    85e2:	cc 06       	mova	r6,	r12	;
    85e4:	b0 13 fa 61 	calla	#25082		;0x061fa

000085e8 <.LVL908>:
      elyCmdSendReply(reply_buff, hdr.reply_addr);
    85e8:	0d 49       	mov	r9,	r13	;
    85ea:	cc 06       	mova	r6,	r12	;
    85ec:	b0 13 f2 68 	calla	#26866		;0x068f2

000085f0 <.LVL909>:
    85f0:	80 00 3a 85 	mova	#34106,	r0	;0x0853a

000085f4 <.L424>:
    write_success(reply_buff, hdr);
    85f4:	81 4a 08 00 	mov	r10,	8(r1)	;
    85f8:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    85fc:	cd 01       	mova	r1,	r13	;
    85fe:	ad 00 08 00 	adda	#8,	r13	;
    8602:	cc 06       	mova	r6,	r12	;
    8604:	b0 13 bc 61 	calla	#25020		;0x061bc

00008608 <.LVL911>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8608:	0d 49       	mov	r9,	r13	;
    860a:	cc 06       	mova	r6,	r12	;
    860c:	b0 13 f2 68 	calla	#26866		;0x068f2

00008610 <.LVL912>:
    8610:	80 00 44 85 	mova	#34116,	r0	;0x08544

00008614 <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8614:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008616 <.LCFI107>:
    8616:	b1 00 06 00 	suba	#6,	r1	;

0000861a <.LCFI108>:
    861a:	c8 0c       	mova	r12,	r8	;
    861c:	25 4d       	mov	@r13,	r5	;

0000861e <.LVL914>:
    861e:	1a 4d 02 00 	mov	2(r13),	r10	;

00008622 <.LVL915>:
  if (hdr.reply) { /* reply requested */
    8622:	49 45       	mov.b	r5,	r9	;
    8624:	4c 49       	mov.b	r9,	r12	;

00008626 <.LVL916>:
    8626:	6c f3       	and.b	#2,	r12	;r3 As==10
    8628:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    862a:	80 24       	jz	$+258    	;abs 0x872c

0000862c <.LBB182>:
    uint8_t * reply_buff = elyFWGetBuffer();
    862c:	b0 13 44 61 	calla	#24900		;0x06144

00008630 <.LVL917>:
    8630:	c6 0c       	mova	r12,	r6	;

00008632 <.LVL918>:
    if (reply_buff == NULL) {
    8632:	9c 00 00 00 	cmpa	#0,	r12	;
    8636:	45 24       	jz	$+140    	;abs 0x86c2

00008638 <.Loc.366.1>:
    uint8_t bank = buffer[4];
    8638:	5c 48 04 00 	mov.b	4(r8),	r12	;
    863c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008640 <.LVL919>:
    uint8_t addr = buffer[5];
    8640:	57 48 05 00 	mov.b	5(r8),	r7	;

00008644 <.LVL920>:
    uint8_t count = buffer[6];
    8644:	54 48 06 00 	mov.b	6(r8),	r4	;

00008648 <.LVL921>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8648:	cc 08       	mova	r8,	r12	;
    864a:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000864e <.LVL922>:
    864e:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008652 <.LVL923>:
    if (bank > 4 || 
    8652:	28 41       	mov	@r1,	r8	;

00008654 <.LVL924>:
    8654:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8656:	4c 98       	cmp.b	r8,	r12	;
    8658:	24 28       	jnc	$+74     	;abs 0x86a2

0000865a <.Loc.374.1>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    865a:	0d 47       	mov	r7,	r13	;
    865c:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    8660:	57 00 
    8662:	40 18 0c 84 	subx.w	r4,	r12	;

00008666 <.Loc.373.1>:
    if (bank > 4 || 
    8666:	07 9c       	cmp	r12,	r7	;
    8668:	04 38       	jl	$+10     	;abs 0x8672

0000866a <.Loc.374.1>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    866a:	7e 40 5f 00 	mov.b	#95,	r14	;#0x005f
    866e:	4e 97       	cmp.b	r7,	r14	;
    8670:	18 2c       	jc	$+50     	;abs 0x86a2

00008672 <.L430>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    8672:	4c 47       	mov.b	r7,	r12	;
    8674:	7c 50 89 ff 	add.b	#-119,	r12	;#0xff89

00008678 <.Loc.374.1>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    8678:	78 42       	mov.b	#8,	r8	;r2 As==11
    867a:	48 9c       	cmp.b	r12,	r8	;
    867c:	12 2c       	jc	$+38     	;abs 0x86a2

0000867e <.Loc.376.1>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    867e:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    8682:	8b 00 
    8684:	40 18 0c 84 	subx.w	r4,	r12	;

00008688 <.Loc.375.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    8688:	0d 9c       	cmp	r12,	r13	;
    868a:	04 38       	jl	$+10     	;abs 0x8694

0000868c <.Loc.376.1>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    868c:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    8690:	4c 97       	cmp.b	r7,	r12	;
    8692:	07 2c       	jc	$+16     	;abs 0x86a2

00008694 <.L431>:
        (addr >= RegDLLMAX - count + 1)) {
    8694:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    8698:	d6 00 
    869a:	40 18 0c 84 	subx.w	r4,	r12	;

0000869e <.Loc.376.1>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    869e:	0d 9c       	cmp	r12,	r13	;
    86a0:	17 38       	jl	$+48     	;abs 0x86d0

000086a2 <.L429>:
      write_failure(reply_buff, hdr);
    86a2:	81 45 02 00 	mov	r5,	2(r1)	;
    86a6:	81 4a 04 00 	mov	r10,	4(r1)	;
    86aa:	cd 01       	mova	r1,	r13	;
    86ac:	ad 00 02 00 	adda	#2,	r13	;
    86b0:	cc 06       	mova	r6,	r12	;
    86b2:	b0 13 fa 61 	calla	#25082		;0x061fa

000086b6 <.LVL925>:
      elyCmdSendReply(reply_buff, hdr.reply_addr);
    86b6:	0d 4a       	mov	r10,	r13	;
    86b8:	cc 06       	mova	r6,	r12	;
    86ba:	b0 13 f2 68 	calla	#26866		;0x068f2

000086be <.LVL926>:
      return; 
    86be:	80 00 36 87 	mova	#34614,	r0	;0x08736

000086c2 <.L435>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    86c2:	cc 08       	mova	r8,	r12	;
    86c4:	b0 13 ec 9d 	calla	#40428		;0x09dec

000086c8 <.LVL928>:
    86c8:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000086cc <.LVL929>:
      return;
    86cc:	80 00 36 87 	mova	#34614,	r0	;0x08736

000086d0 <.L432>:
    elyRegGetBlock(bank, reply_buff + 4, addr, count);
    86d0:	4f 44       	mov.b	r4,	r15	;
    86d2:	4e 47       	mov.b	r7,	r14	;
    86d4:	cd 06       	mova	r6,	r13	;
    86d6:	ad 00 04 00 	adda	#4,	r13	;
    86da:	28 41       	mov	@r1,	r8	;
    86dc:	4c 48       	mov.b	r8,	r12	;
    86de:	b0 13 e4 90 	calla	#37092		;0x090e4

000086e2 <.LVL931>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    86e2:	55 07       	rrum	#2,	r5	;

000086e4 <.LVL932>:
    86e4:	75 f0 3f 00 	and.b	#63,	r5	;#0x003f
    86e8:	c6 45 00 00 	mov.b	r5,	0(r6)	;

000086ec <.Loc.386.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    86ec:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    86f0:	d6 4c 51 00 	mov.b	81(r12),2(r6)	;0x00051
    86f4:	02 00 

000086f6 <.Loc.387.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    86f6:	d6 4c 50 00 	mov.b	80(r12),3(r6)	;0x00050
    86fa:	03 00 

000086fc <.Loc.389.1>:
    if (hdr.crc) {
    86fc:	19 b3       	bit	#1,	r9	;r3 As==01
    86fe:	08 20       	jnz	$+18     	;abs 0x8710

00008700 <.Loc.394.1>:
      reply_buff[1] = count; 
    8700:	c6 44 01 00 	mov.b	r4,	1(r6)	;

00008704 <.L434>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8704:	0d 4a       	mov	r10,	r13	;
    8706:	cc 06       	mova	r6,	r12	;
    8708:	b0 13 f2 68 	calla	#26866		;0x068f2

0000870c <.LBE182>:
    870c:	80 00 36 87 	mova	#34614,	r0	;0x08736

00008710 <.L436>:
      reply_buff[1] = count + 2; 
    8710:	4c 44       	mov.b	r4,	r12	;
    8712:	6c 53       	incd.b	r12		;
    8714:	c6 4c 01 00 	mov.b	r12,	1(r6)	;

00008718 <.Loc.391.1>:
      crcGenX25(reply_buff, count + 6);
    8718:	0d 44       	mov	r4,	r13	;
    871a:	3d 50 06 00 	add	#6,	r13	;
    871e:	4d 0e       	rlam.a	#4,	r13	;
    8720:	4d 0d       	rram.a	#4,	r13	;
    8722:	cc 06       	mova	r6,	r12	;
    8724:	b0 13 d2 97 	calla	#38866		;0x097d2

00008728 <.LVL934>:
    8728:	80 00 04 87 	mova	#34564,	r0	;0x08704

0000872c <.L426>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    872c:	cc 08       	mova	r8,	r12	;
    872e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008732 <.LVL936>:
    8732:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008736 <.L425>:
}
    8736:	a1 00 06 00 	adda	#6,	r1	;
    873a:	64 16       	popm.a	#7,	r10	;20-bit words
    873c:	10 01       	reta			;

0000873e <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    873e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008740 <.LCFI109>:
    8740:	b1 00 08 00 	suba	#8,	r1	;

00008744 <.LCFI110>:
    8744:	c6 0c       	mova	r12,	r6	;
    8746:	25 4d       	mov	@r13,	r5	;

00008748 <.LVL939>:
    8748:	1c 4d 02 00 	mov	2(r13),	r12	;

0000874c <.LVL940>:
    874c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008750 <.Loc.309.1>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8750:	4c 45       	mov.b	r5,	r12	;

00008752 <.LVL942>:
    8752:	47 4c       	mov.b	r12,	r7	;
    8754:	67 f3       	and.b	#2,	r7	;r3 As==10
    8756:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    875a:	07 93       	cmp	#0,	r7	;r3 As==00
    875c:	52 24       	jz	$+166    	;abs 0x8802

0000875e <.Loc.309.1>:
    875e:	59 46 04 00 	mov.b	4(r6),	r9	;

00008762 <.L439>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8762:	07 93       	cmp	#0,	r7	;r3 As==00
    8764:	52 24       	jz	$+166    	;abs 0x880a

00008766 <.Loc.310.1>:
    8766:	78 40 05 00 	mov.b	#5,	r8	;

0000876a <.L440>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    876a:	0a 45       	mov	r5,	r10	;
    876c:	5a 0f       	rrum	#4,	r10	;
    876e:	5a 0f       	rrum	#4,	r10	;
    8770:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8774:	4e 24       	jz	$+158    	;abs 0x8812

00008776 <.Loc.311.1>:
    8776:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008778 <.L441>:
    8778:	0a 8c       	sub	r12,	r10	;
    877a:	0a 87       	sub	r7,	r10	;
    877c:	0c 4a       	mov	r10,	r12	;
    877e:	5c 03       	rrum	#1,	r12	;
    8780:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    8784:	0a 5c       	add	r12,	r10	;
    8786:	0a 11       	rra	r10		;
    8788:	4b 4a       	mov.b	r10,	r11	;
    878a:	81 4b 02 00 	mov	r11,	2(r1)	;

0000878e <.LVL945>:
  uint8_t * reply_buff = elyFWGetBuffer();
    878e:	b0 13 44 61 	calla	#24900		;0x06144

00008792 <.LVL946>:
    8792:	c4 0c       	mova	r12,	r4	;

00008794 <.LVL947>:
  if (reply_buff == NULL) {
    8794:	9c 00 00 00 	cmpa	#0,	r12	;
    8798:	3f 24       	jz	$+128    	;abs 0x8818
    879a:	4d 43       	clr.b	r13		;

0000879c <.L442>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    879c:	0c 4a       	mov	r10,	r12	;
    879e:	7c f0 ff 00 	and.b	#255,	r12	;#0x00ff
    87a2:	0c 5c       	rla	r12		;
    87a4:	0d 9c       	cmp	r12,	r13	;
    87a6:	5a 34       	jge	$+182    	;abs 0x885c

000087a8 <.LBB185>:
    uint8_t addr = buffer[i + regs_offset];
    87a8:	0c 48       	mov	r8,	r12	;
    87aa:	0c 5d       	add	r13,	r12	;
    87ac:	4c 0e       	rlam.a	#4,	r12	;
    87ae:	4c 0d       	rram.a	#4,	r12	;
    87b0:	ce 06       	mova	r6,	r14	;
    87b2:	ee 0c       	adda	r12,	r14	;
    87b4:	6f 4e       	mov.b	@r14,	r15	;

000087b6 <.LVL949>:
    if ((bank == 0) || (bank > 4) ||
    87b6:	4e 49       	mov.b	r9,	r14	;

000087b8 <.LVL950>:
    87b8:	7e 53       	add.b	#-1,	r14	;r3 As==11
    87ba:	7b 40 03 00 	mov.b	#3,	r11	;
    87be:	4b 9e       	cmp.b	r14,	r11	;
    87c0:	32 28       	jnc	$+102    	;abs 0x8826

000087c2 <.Loc.324.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    87c2:	4e 4f       	mov.b	r15,	r14	;
    87c4:	7e 50 aa ff 	add.b	#-86,	r14	;#0xffaa

000087c8 <.Loc.323.1>:
    if ((bank == 0) || (bank > 4) ||
    87c8:	7b 40 29 00 	mov.b	#41,	r11	;#0x0029
    87cc:	4b 9e       	cmp.b	r14,	r11	;
    87ce:	2b 2c       	jc	$+88     	;abs 0x8826

000087d0 <.Loc.325.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    87d0:	7e 50 cc ff 	add.b	#-52,	r14	;#0xffcc

000087d4 <.Loc.324.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    87d4:	7b 40 35 00 	mov.b	#53,	r11	;#0x0035
    87d8:	4b 9e       	cmp.b	r14,	r11	;
    87da:	25 2c       	jc	$+76     	;abs 0x8826

000087dc <.Loc.325.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    87dc:	7e 40 d4 ff 	mov.b	#-44,	r14	;#0xffd4
    87e0:	4e 9f       	cmp.b	r15,	r14	;
    87e2:	21 28       	jnc	$+68     	;abs 0x8826

000087e4 <.Loc.335.1>:
    reply_buff[i+regs_offset-1] = addr;
    87e4:	ce 0c       	mova	r12,	r14	;
    87e6:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    87ea:	ee 04       	adda	r4,	r14	;
    87ec:	ce 4f 00 00 	mov.b	r15,	0(r14)	;

000087f0 <.LVL951>:
    reply_buff[i+regs_offset] = buffer[i+regs_offset+1];
    87f0:	ce 04       	mova	r4,	r14	;
    87f2:	ee 0c       	adda	r12,	r14	;
    87f4:	ec 06       	adda	r6,	r12	;
    87f6:	de 4c 01 00 	mov.b	1(r12),	0(r14)	;
    87fa:	00 00 

000087fc <.LBE185>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    87fc:	2d 53       	incd	r13		;
    87fe:	80 00 9c 87 	mova	#34716,	r0	;0x0879c

00008802 <.L438>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8802:	59 46 02 00 	mov.b	2(r6),	r9	;
    8806:	80 00 62 87 	mova	#34658,	r0	;0x08762

0000880a <.L449>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    880a:	78 40 03 00 	mov.b	#3,	r8	;
    880e:	80 00 6a 87 	mova	#34666,	r0	;0x0876a

00008812 <.L450>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8812:	4c 43       	clr.b	r12		;
    8814:	80 00 78 87 	mova	#34680,	r0	;0x08778

00008818 <.L452>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8818:	cc 06       	mova	r6,	r12	;
    881a:	b0 13 ec 9d 	calla	#40428		;0x09dec

0000881e <.LVL957>:
    881e:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008822 <.LVL958>:
    return;
    8822:	80 00 34 88 	mova	#34868,	r0	;0x08834

00008826 <.L444>:
      if (hdr.reply) {
    8826:	07 93       	cmp	#0,	r7	;r3 As==00
    8828:	09 20       	jnz	$+20     	;abs 0x883c

0000882a <.L446>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    882a:	cc 06       	mova	r6,	r12	;
    882c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008830 <.LVL961>:
    8830:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008834 <.L437>:
}
    8834:	a1 00 08 00 	adda	#8,	r1	;
    8838:	64 16       	popm.a	#7,	r10	;20-bit words
    883a:	10 01       	reta			;

0000883c <.L454>:
        write_failure(reply_buff, hdr);
    883c:	81 45 04 00 	mov	r5,	4(r1)	;

00008840 <.LVL964>:
    8840:	a1 41 06 00 	mov	@r1,	6(r1)	;
    8844:	cd 01       	mova	r1,	r13	;

00008846 <.LVL965>:
    8846:	ad 00 04 00 	adda	#4,	r13	;
    884a:	cc 04       	mova	r4,	r12	;
    884c:	b0 13 fa 61 	calla	#25082		;0x061fa

00008850 <.LVL966>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    8850:	2d 41       	mov	@r1,	r13	;
    8852:	cc 04       	mova	r4,	r12	;
    8854:	b0 13 f2 68 	calla	#26866		;0x068f2

00008858 <.LVL967>:
    8858:	80 00 2a 88 	mova	#34858,	r0	;0x0882a

0000885c <.L453>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    885c:	cc 06       	mova	r6,	r12	;
    885e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008862 <.LVL969>:
    8862:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008866 <.LVL970>:
  elyRegSet(bank, reply_buff + regs_offset-1, num_regs);
    8866:	40 18 08 48 	movx.w	r8,	r8	;
    886a:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff

0000886e <.LVL971>:
    886e:	1b 41 02 00 	mov	2(r1),	r11	;
    8872:	4e 4b       	mov.b	r11,	r14	;
    8874:	cd 04       	mova	r4,	r13	;
    8876:	ed 08       	adda	r8,	r13	;
    8878:	4c 49       	mov.b	r9,	r12	;
    887a:	b0 13 8c 90 	calla	#37004		;0x0908c

0000887e <.LVL972>:
  if (hdr.reply) {
    887e:	07 93       	cmp	#0,	r7	;r3 As==00
    8880:	07 20       	jnz	$+16     	;abs 0x8890

00008882 <.Loc.351.1>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    8882:	cc 04       	mova	r4,	r12	;
    8884:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008888 <.LVL973>:
    8888:	b0 13 7c 61 	calla	#24956		;0x0617c

0000888c <.LVL974>:
    888c:	80 00 34 88 	mova	#34868,	r0	;0x08834

00008890 <.L455>:
    write_success(reply_buff, hdr);
    8890:	81 45 04 00 	mov	r5,	4(r1)	;
    8894:	a1 41 06 00 	mov	@r1,	6(r1)	;
    8898:	cd 01       	mova	r1,	r13	;
    889a:	ad 00 04 00 	adda	#4,	r13	;
    889e:	cc 04       	mova	r4,	r12	;
    88a0:	b0 13 bc 61 	calla	#25020		;0x061bc

000088a4 <.LVL975>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    88a4:	2d 41       	mov	@r1,	r13	;
    88a6:	cc 04       	mova	r4,	r12	;
    88a8:	b0 13 f2 68 	calla	#26866		;0x068f2

000088ac <.LVL976>:
    88ac:	80 00 34 88 	mova	#34868,	r0	;0x08834

000088b0 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    88b0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000088b2 <.LCFI111>:
    88b2:	b1 00 06 00 	suba	#6,	r1	;

000088b6 <.LCFI112>:
    88b6:	c6 0c       	mova	r12,	r6	;
    88b8:	2a 4d       	mov	@r13,	r10	;

000088ba <.LVL978>:
    88ba:	18 4d 02 00 	mov	2(r13),	r8	;

000088be <.LVL979>:
  if (hdr.reply) {
    88be:	45 4a       	mov.b	r10,	r5	;
    88c0:	4c 45       	mov.b	r5,	r12	;

000088c2 <.LVL980>:
    88c2:	6c f3       	and.b	#2,	r12	;r3 As==10
    88c4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    88c6:	9d 24       	jz	$+316    	;abs 0x8a02

000088c8 <.LBB190>:
    uint8_t * reply_buff = elyFWGetBuffer();
    88c8:	b0 13 44 61 	calla	#24900		;0x06144

000088cc <.LVL981>:
    88cc:	c4 0c       	mova	r12,	r4	;

000088ce <.LVL982>:
    if (reply_buff == NULL) {
    88ce:	9c 00 00 00 	cmpa	#0,	r12	;
    88d2:	44 24       	jz	$+138    	;abs 0x895c

000088d4 <.Loc.260.1>:
    uint8_t bank = buffer[4];
    88d4:	59 46 04 00 	mov.b	4(r6),	r9	;

000088d8 <.LVL983>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    88d8:	0d 4a       	mov	r10,	r13	;
    88da:	5d 0f       	rrum	#4,	r13	;
    88dc:	5d 0f       	rrum	#4,	r13	;
    88de:	55 f3       	and.b	#1,	r5	;r3 As==01
    88e0:	05 93       	cmp	#0,	r5	;r3 As==00
    88e2:	43 24       	jz	$+136    	;abs 0x896a
    88e4:	6c 43       	mov.b	#2,	r12	;r3 As==10

000088e6 <.L460>:
    88e6:	4d 8c       	sub.b	r12,	r13	;
    88e8:	c1 4d 01 00 	mov.b	r13,	1(r1)	;
    88ec:	57 41 01 00 	mov.b	1(r1),	r7	;
    88f0:	77 50 fd ff 	add.b	#-3,	r7	;#0xfffd
    88f4:	c1 47 00 00 	mov.b	r7,	0(r1)	;
    88f8:	4e 47       	mov.b	r7,	r14	;

000088fa <.LBB191>:
    for (int i = 0; i < num_regs; i++) {
    88fa:	4d 43       	clr.b	r13		;
    88fc:	0f 4a       	mov	r10,	r15	;

000088fe <.L461>:
    88fe:	07 4e       	mov	r14,	r7	;
    8900:	0d 9e       	cmp	r14,	r13	;
    8902:	4c 34       	jge	$+154    	;abs 0x899c

00008904 <.LBB192>:
      uint8_t addr = buffer[i + regs_offset];
    8904:	0c 4d       	mov	r13,	r12	;
    8906:	3c 50 05 00 	add	#5,	r12	;
    890a:	4c 0e       	rlam.a	#4,	r12	;
    890c:	4c 0d       	rram.a	#4,	r12	;
    890e:	ec 06       	adda	r6,	r12	;
    8910:	6c 4c       	mov.b	@r12,	r12	;

00008912 <.Loc.269.1>:
      if ((bank > 4) ||
    8912:	6a 42       	mov.b	#4,	r10	;r2 As==10

00008914 <.LVL987>:
    8914:	4a 99       	cmp.b	r9,	r10	;
    8916:	2c 28       	jnc	$+90     	;abs 0x8970

00008918 <.Loc.270.1>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    8918:	4a 4c       	mov.b	r12,	r10	;
    891a:	7a 50 aa ff 	add.b	#-86,	r10	;#0xffaa

0000891e <.Loc.269.1>:
      if ((bank > 4) ||
    891e:	77 40 09 00 	mov.b	#9,	r7	;
    8922:	47 9a       	cmp.b	r10,	r7	;
    8924:	25 2c       	jc	$+76     	;abs 0x8970

00008926 <.Loc.271.1>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8926:	7a 50 df ff 	add.b	#-33,	r10	;#0xffdf

0000892a <.Loc.270.1>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    892a:	77 42       	mov.b	#8,	r7	;r2 As==11
    892c:	47 9a       	cmp.b	r10,	r7	;
    892e:	20 2c       	jc	$+66     	;abs 0x8970

00008930 <.Loc.272.1>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    8930:	7a 50 ed ff 	add.b	#-19,	r10	;#0xffed

00008934 <.Loc.271.1>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    8934:	77 40 35 00 	mov.b	#53,	r7	;#0x0035
    8938:	47 9a       	cmp.b	r10,	r7	;
    893a:	1a 2c       	jc	$+54     	;abs 0x8970

0000893c <.Loc.272.1>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    893c:	7a 40 d4 ff 	mov.b	#-44,	r10	;#0xffd4
    8940:	4a 9c       	cmp.b	r12,	r10	;
    8942:	16 28       	jnc	$+46     	;abs 0x8970

00008944 <.Loc.280.1>:
      reply_buff[i+4] = addr;
    8944:	07 4d       	mov	r13,	r7	;
    8946:	47 0e       	rlam.a	#4,	r7	;
    8948:	47 0d       	rram.a	#4,	r7	;
    894a:	ca 07       	mova	r7,	r10	;
    894c:	aa 00 04 00 	adda	#4,	r10	;
    8950:	ea 04       	adda	r4,	r10	;
    8952:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00008956 <.LBE192>:
    for (int i = 0; i < num_regs; i++) {
    8956:	1d 53       	inc	r13		;
    8958:	80 00 fe 88 	mova	#35070,	r0	;0x088fe

0000895c <.L468>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    895c:	cc 06       	mova	r6,	r12	;
    895e:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008962 <.LVL991>:
    8962:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008966 <.LVL992>:
      return;
    8966:	80 00 0c 8a 	mova	#35340,	r0	;0x08a0c

0000896a <.L467>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    896a:	4c 43       	clr.b	r12		;
    896c:	80 00 e6 88 	mova	#35046,	r0	;0x088e6

00008970 <.L462>:
    8970:	0a 4f       	mov	r15,	r10	;

00008972 <.LBB193>:
        write_failure(reply_buff, hdr);
    8972:	81 4f 02 00 	mov	r15,	2(r1)	;

00008976 <.LVL995>:
    8976:	81 48 04 00 	mov	r8,	4(r1)	;
    897a:	cd 01       	mova	r1,	r13	;

0000897c <.LVL996>:
    897c:	ad 00 02 00 	adda	#2,	r13	;
    8980:	cc 04       	mova	r4,	r12	;

00008982 <.LVL997>:
    8982:	b0 13 fa 61 	calla	#25082		;0x061fa

00008986 <.LVL998>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    8986:	0d 48       	mov	r8,	r13	;
    8988:	cc 04       	mova	r4,	r12	;
    898a:	b0 13 f2 68 	calla	#26866		;0x068f2

0000898e <.LVL999>:
        elyNLFreeBuffer(elyNLFromFW(buffer));
    898e:	cc 06       	mova	r6,	r12	;
    8990:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008994 <.LVL1000>:
    8994:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008998 <.LVL1001>:
        return;
    8998:	80 00 0c 8a 	mova	#35340,	r0	;0x08a0c

0000899c <.L469>:
    899c:	0a 4f       	mov	r15,	r10	;

0000899e <.LBE193>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    899e:	cc 06       	mova	r6,	r12	;
    89a0:	b0 13 ec 9d 	calla	#40428		;0x09dec

000089a4 <.LVL1004>:
    89a4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

000089a8 <.LVL1005>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    89a8:	5a 07       	rrum	#2,	r10	;
    89aa:	7a f0 3f 00 	and.b	#63,	r10	;#0x003f
    89ae:	c4 4a 00 00 	mov.b	r10,	0(r4)	;

000089b2 <.Loc.287.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    89b2:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    89b6:	d4 4c 51 00 	mov.b	81(r12),2(r4)	;0x00051
    89ba:	02 00 

000089bc <.Loc.288.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    89bc:	d4 4c 50 00 	mov.b	80(r12),3(r4)	;0x00050
    89c0:	03 00 

000089c2 <.Loc.291.1>:
    elyRegGet(bank, reply_buff + 4, num_regs);
    89c2:	6e 41       	mov.b	@r1,	r14	;
    89c4:	cd 04       	mova	r4,	r13	;
    89c6:	ad 00 04 00 	adda	#4,	r13	;
    89ca:	4c 49       	mov.b	r9,	r12	;
    89cc:	b0 13 22 90 	calla	#36898		;0x09022

000089d0 <.LVL1006>:
    if (hdr.crc) {
    89d0:	05 93       	cmp	#0,	r5	;r3 As==00
    89d2:	08 20       	jnz	$+18     	;abs 0x89e4

000089d4 <.Loc.298.1>:
      reply_buff[1] = num_regs;
    89d4:	e4 41 01 00 	mov.b	@r1,	1(r4)	;

000089d8 <.L466>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    89d8:	0d 48       	mov	r8,	r13	;
    89da:	cc 04       	mova	r4,	r12	;
    89dc:	b0 13 f2 68 	calla	#26866		;0x068f2

000089e0 <.LBE190>:
    89e0:	80 00 0c 8a 	mova	#35340,	r0	;0x08a0c

000089e4 <.L470>:
      reply_buff[1] = num_regs + 2;
    89e4:	5a 41 01 00 	mov.b	1(r1),	r10	;
    89e8:	7a 53       	add.b	#-1,	r10	;r3 As==11
    89ea:	c4 4a 01 00 	mov.b	r10,	1(r4)	;

000089ee <.Loc.295.1>:
      crcGenX25(reply_buff, num_regs + 6);
    89ee:	0d 47       	mov	r7,	r13	;
    89f0:	3d 50 06 00 	add	#6,	r13	;
    89f4:	4d 0e       	rlam.a	#4,	r13	;
    89f6:	4d 0d       	rram.a	#4,	r13	;
    89f8:	cc 04       	mova	r4,	r12	;
    89fa:	b0 13 d2 97 	calla	#38866		;0x097d2

000089fe <.LVL1008>:
    89fe:	80 00 d8 89 	mova	#35288,	r0	;0x089d8

00008a02 <.L457>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    8a02:	cc 06       	mova	r6,	r12	;
    8a04:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008a08 <.LVL1010>:
    8a08:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008a0c <.L456>:
}
    8a0c:	a1 00 06 00 	adda	#6,	r1	;
    8a10:	64 16       	popm.a	#7,	r10	;20-bit words
    8a12:	10 01       	reta			;

00008a14 <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a14:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008a16 <.LCFI113>:
    8a16:	2a 4d       	mov	@r13,	r10	;

00008a18 <.LVL1013>:
    8a18:	19 4d 02 00 	mov	2(r13),	r9	;

00008a1c <.LVL1014>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8a1c:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008a20 <.LVL1015>:
    8a20:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008a24 <.LVL1016>:
  if (hdr.reply) { /* reply requested */
    8a24:	47 4a       	mov.b	r10,	r7	;
    8a26:	4c 47       	mov.b	r7,	r12	;
    8a28:	6c f3       	and.b	#2,	r12	;r3 As==10
    8a2a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8a2c:	02 20       	jnz	$+6      	;abs 0x8a32

00008a2e <.L471>:
}
    8a2e:	37 16       	popm.a	#4,	r10	;20-bit words
    8a30:	10 01       	reta			;

00008a32 <.L474>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8a32:	b0 13 44 61 	calla	#24900		;0x06144

00008a36 <.LVL1017>:
    8a36:	c8 0c       	mova	r12,	r8	;

00008a38 <.Loc.233.1>:
    if (reply_buff == NULL) {
    8a38:	9c 00 00 00 	cmpa	#0,	r12	;
    8a3c:	f8 27       	jz	$-14     	;abs 0x8a2e

00008a3e <.Loc.238.1>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8a3e:	0c 4a       	mov	r10,	r12	;
    8a40:	5c 07       	rrum	#2,	r12	;
    8a42:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    8a46:	c8 4c 00 00 	mov.b	r12,	0(r8)	;

00008a4a <.Loc.239.1>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8a4a:	5a f3       	and.b	#1,	r10	;r3 As==01

00008a4c <.LVL1019>:
    8a4c:	4a 5a       	rla.b	r10		;
    8a4e:	5a 53       	inc.b	r10		;
    8a50:	c8 4a 01 00 	mov.b	r10,	1(r8)	;

00008a54 <.Loc.240.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8a54:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    8a58:	d8 4c 51 00 	mov.b	81(r12),2(r8)	;0x00051
    8a5c:	02 00 

00008a5e <.Loc.241.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8a5e:	d8 4c 50 00 	mov.b	80(r12),3(r8)	;0x00050
    8a62:	03 00 

00008a64 <.Loc.242.1>:
    reply_buff[4] = bank0p[RegActiveBank];
    8a64:	d8 4c 69 00 	mov.b	105(r12),4(r8)	;0x00069
    8a68:	04 00 

00008a6a <.Loc.243.1>:
    if (hdr.crc) {
    8a6a:	17 b3       	bit	#1,	r7	;r3 As==01
    8a6c:	06 20       	jnz	$+14     	;abs 0x8a7a

00008a6e <.L473>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8a6e:	0d 49       	mov	r9,	r13	;
    8a70:	cc 08       	mova	r8,	r12	;
    8a72:	b0 13 f2 68 	calla	#26866		;0x068f2

00008a76 <.LVL1020>:
    8a76:	80 00 2e 8a 	mova	#35374,	r0	;0x08a2e

00008a7a <.L475>:
      crcGenX25(reply_buff, 7);
    8a7a:	7d 40 07 00 	mov.b	#7,	r13	;
    8a7e:	cc 08       	mova	r8,	r12	;
    8a80:	b0 13 d2 97 	calla	#38866		;0x097d2

00008a84 <.LVL1021>:
    8a84:	80 00 6e 8a 	mova	#35438,	r0	;0x08a6e

00008a88 <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a88:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008a8a <.LCFI114>:
    8a8a:	2a 4d       	mov	@r13,	r10	;

00008a8c <.LVL1023>:
    8a8c:	19 4d 02 00 	mov	2(r13),	r9	;

00008a90 <.LVL1024>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8a90:	b0 13 ec 9d 	calla	#40428		;0x09dec

00008a94 <.LVL1025>:
    8a94:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008a98 <.LVL1026>:
  if (hdr.reply) { /* reply requested */
    8a98:	47 4a       	mov.b	r10,	r7	;
    8a9a:	4c 47       	mov.b	r7,	r12	;
    8a9c:	6c f3       	and.b	#2,	r12	;r3 As==10
    8a9e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8aa0:	02 20       	jnz	$+6      	;abs 0x8aa6

00008aa2 <.L476>:
}
    8aa2:	37 16       	popm.a	#4,	r10	;20-bit words
    8aa4:	10 01       	reta			;

00008aa6 <.L479>:
    uint8_t * reply_buff = elyFWGetBuffer();
    8aa6:	b0 13 44 61 	calla	#24900		;0x06144

00008aaa <.LVL1027>:
    8aaa:	c8 0c       	mova	r12,	r8	;

00008aac <.Loc.177.1>:
    if (reply_buff == NULL) {
    8aac:	9c 00 00 00 	cmpa	#0,	r12	;
    8ab0:	f8 27       	jz	$-14     	;abs 0x8aa2

00008ab2 <.Loc.182.1>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    8ab2:	0c 4a       	mov	r10,	r12	;
    8ab4:	5c 07       	rrum	#2,	r12	;
    8ab6:	7c f0 3f 00 	and.b	#63,	r12	;#0x003f
    8aba:	c8 4c 00 00 	mov.b	r12,	0(r8)	;

00008abe <.Loc.183.1>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    8abe:	5a f3       	and.b	#1,	r10	;r3 As==01

00008ac0 <.LVL1029>:
    8ac0:	4a 5a       	rla.b	r10		;
    8ac2:	5a 53       	inc.b	r10		;
    8ac4:	c8 4a 01 00 	mov.b	r10,	1(r8)	;

00008ac8 <.Loc.184.1>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    8ac8:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    8acc:	d8 4c 51 00 	mov.b	81(r12),2(r8)	;0x00051
    8ad0:	02 00 

00008ad2 <.Loc.185.1>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    8ad2:	d8 4c 50 00 	mov.b	80(r12),3(r8)	;0x00050
    8ad6:	03 00 

00008ad8 <.Loc.186.1>:
    reply_buff[4] = bank0p[RegGPOState];
    8ad8:	d8 4c 61 00 	mov.b	97(r12),4(r8)	;0x00061
    8adc:	04 00 

00008ade <.Loc.187.1>:
    if (hdr.crc) {
    8ade:	17 b3       	bit	#1,	r7	;r3 As==01
    8ae0:	06 20       	jnz	$+14     	;abs 0x8aee

00008ae2 <.L478>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    8ae2:	0d 49       	mov	r9,	r13	;
    8ae4:	cc 08       	mova	r8,	r12	;
    8ae6:	b0 13 f2 68 	calla	#26866		;0x068f2

00008aea <.LVL1030>:
    8aea:	80 00 a2 8a 	mova	#35490,	r0	;0x08aa2

00008aee <.L480>:
      crcGenX25(reply_buff, 7);
    8aee:	7d 40 07 00 	mov.b	#7,	r13	;
    8af2:	cc 08       	mova	r8,	r12	;
    8af4:	b0 13 d2 97 	calla	#38866		;0x097d2

00008af8 <.LVL1031>:
    8af8:	80 00 e2 8a 	mova	#35554,	r0	;0x08ae2

00008afc <CmdThd>:

THD_WORKING_AREA(waCmdThd, 256);
THD_FUNCTION(CmdThd, arg) {
    8afc:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008afe <.LCFI115>:
    8afe:	b1 00 04 00 	suba	#4,	r1	;

00008b02 <.LCFI116>:
    8b02:	80 00 26 8b 	mova	#35622,	r0	;0x08b26

00008b06 <.L486>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    8b06:	4e 43       	clr.b	r14		;
    8b08:	8d 00 9e d3 	mova	#54174,	r13	;0x0d39e
    8b0c:	8c 01 08 05 	mova	#66824,	r12	;0x10508
    8b10:	b0 13 3a 4d 	calla	#19770		;0x04d3a

00008b14 <.LVL1034>:
    8b14:	80 00 2e 8b 	mova	#35630,	r0	;0x08b2e

00008b18 <.L483>:
    if (elyCmdValidate(hdr, cmd_buffer)) {
      elyCmdDispatch(hdr, cmd_buffer);
    }
    else {
      /* Invalid command - free the buffer (guaranteed to be NL) */
      elyNLFreeBuffer(active_buffer);
    8b18:	2c 00 9e d3 	mova	&54174,	r12	;0x0d39e
    8b1c:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00008b20 <.L484>:
    }
    
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    8b20:	00 18 c2 43 	movx.a	#0,	&0xfd39e;r3 As==00
    8b24:	9e d3 

00008b26 <.L485>:
    if (NULL == active_buffer) {
    8b26:	00 18 c2 93 	cmpx.a	#0,	&0xfd39e;r3 As==00
    8b2a:	9e d3 
    8b2c:	ec 27       	jz	$-38     	;abs 0x8b06

00008b2e <.L482>:
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    8b2e:	2c 00 9e d3 	mova	&54174,	r12	;0x0d39e
    8b32:	b0 13 e0 9d 	calla	#40416		;0x09de0

00008b36 <.LVL1038>:
    8b36:	ca 0c       	mova	r12,	r10	;

00008b38 <.LVL1039>:
    hdr = elyCmdParse(cmd_buffer);
    8b38:	cd 0c       	mova	r12,	r13	;
    8b3a:	cc 01       	mova	r1,	r12	;
    8b3c:	b0 13 50 64 	calla	#25680		;0x06450

00008b40 <.LVL1040>:
    8b40:	28 41       	mov	@r1,	r8	;
    8b42:	19 41 02 00 	mov	2(r1),	r9	;

00008b46 <.Loc.1797.1>:
    if (elyCmdValidate(hdr, cmd_buffer)) {
    8b46:	cd 0a       	mova	r10,	r13	;
    8b48:	cc 01       	mova	r1,	r12	;
    8b4a:	b0 13 a0 64 	calla	#25760		;0x064a0

00008b4e <.LVL1042>:
    8b4e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8b50:	e3 27       	jz	$-56     	;abs 0x8b18

00008b52 <.Loc.1798.1>:
      elyCmdDispatch(hdr, cmd_buffer);
    8b52:	81 48 00 00 	mov	r8,	0(r1)	;

00008b56 <.LVL1043>:
    8b56:	81 49 02 00 	mov	r9,	2(r1)	;
    8b5a:	cd 0a       	mova	r10,	r13	;
    8b5c:	cc 01       	mova	r1,	r12	;
    8b5e:	b0 13 82 67 	calla	#26498		;0x06782

00008b62 <.LVL1044>:
    8b62:	80 00 20 8b 	mova	#35616,	r0	;0x08b20

00008b66 <fram_reg_cb>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    8b66:	40 18 5c 42 	movx.b	&0x0d3d2,r12	;
    8b6a:	d2 d3 

00008b6c <.LVL1>:
    8b6c:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8b6e:	40 18 c2 4c 	movx.b	r12,	&0xfd3d2;
    8b72:	d2 d3 

00008b74 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    8b74:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8b76:	01 24       	jz	$+4      	;abs 0x8b7a

00008b78 <.L1>:
    chSysLockFromISR();
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
  }
}
    8b78:	10 01       	reta			;

00008b7a <.L4>:
    chSysLockFromISR();
    8b7a:	b0 13 92 45 	calla	#17810		;0x04592

00008b7e <.LBB45>:
  chDbgCheckClassI();
    8b7e:	b0 13 24 46 	calla	#17956		;0x04624

00008b82 <.LVL3>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8b82:	40 18 1c 42 	movx.w	&0x0d3d4,r12	;
    8b86:	d4 d3 
    8b88:	4d 43       	clr.b	r13		;
    8b8a:	0d 9c       	cmp	r12,	r13	;
    8b8c:	04 34       	jge	$+10     	;abs 0x8b96

00008b8e <.L3>:
    chSysUnlockFromISR();
    8b8e:	b0 13 b4 45 	calla	#17844		;0x045b4

00008b92 <.LVL5>:
}
    8b92:	80 00 78 8b 	mova	#35704,	r0	;0x08b78

00008b96 <.L5>:
    chSemSignalI(&bsp->sem);
    8b96:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    8b9a:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00008b9e <.LVL7>:
    8b9e:	80 00 8e 8b 	mova	#35726,	r0	;0x08b8e

00008ba2 <fram_block_cb>:
  chSysUnlock();
}

void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
    8ba2:	b0 13 92 45 	calla	#17810		;0x04592

00008ba6 <.LBB49>:
  chDbgCheckClassI();
    8ba6:	b0 13 24 46 	calla	#17956		;0x04624

00008baa <.LVL10>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8baa:	40 18 1c 42 	movx.w	&0x0d3d4,r12	;
    8bae:	d4 d3 
    8bb0:	4d 43       	clr.b	r13		;
    8bb2:	0d 9c       	cmp	r12,	r13	;
    8bb4:	03 34       	jge	$+8      	;abs 0x8bbc

00008bb6 <.L7>:
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
    8bb6:	b0 13 b4 45 	calla	#17844		;0x045b4

00008bba <.LVL12>:
}
    8bba:	10 01       	reta			;

00008bbc <.L8>:
    chSemSignalI(&bsp->sem);
    8bbc:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    8bc0:	b0 13 4a 4a 	calla	#19018		;0x04a4a

00008bc4 <.LVL14>:
    8bc4:	80 00 b6 8b 	mova	#35766,	r0	;0x08bb6

00008bc8 <clamp_err>:
static uint8_t clamp_err(uint8_t value) {
    8bc8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008bcc <.Loc.165.1>:
  if ((value & 0x10) && value != 0x10) {
    8bcc:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    8bd0:	10 00 
    8bd2:	0a 24       	jz	$+22     	;abs 0x8be8

00008bd4 <.Loc.165.1>:
    8bd4:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    8bd8:	07 24       	jz	$+16     	;abs 0x8be8

00008bda <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    8bda:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008bde <.LVL16>:
    8bde:	b0 13 fa 96 	calla	#38650		;0x096fa

00008be2 <.LVL17>:
    return 0x10;
    8be2:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

00008be6 <.L11>:
}
    8be6:	10 01       	reta			;

00008be8 <.L10>:
  if ((value & 0x08) && value != 0x08) {
    8be8:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    8bec:	09 24       	jz	$+20     	;abs 0x8c00

00008bee <.Loc.169.1>:
    8bee:	3c 92       	cmp	#8,	r12	;r2 As==11
    8bf0:	07 24       	jz	$+16     	;abs 0x8c00

00008bf2 <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    8bf2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8bf6:	b0 13 fa 96 	calla	#38650		;0x096fa

00008bfa <.LVL18>:
    return 0x08;
    8bfa:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8bfc:	80 00 e6 8b 	mova	#35814,	r0	;0x08be6

00008c00 <.L12>:
  if ((value & 0x04) && value != 0x04) {
    8c00:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    8c04:	09 24       	jz	$+20     	;abs 0x8c18

00008c06 <.Loc.173.1>:
    8c06:	2c 92       	cmp	#4,	r12	;r2 As==10
    8c08:	07 24       	jz	$+16     	;abs 0x8c18

00008c0a <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    8c0a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c0e:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c12 <.LVL19>:
    return 0x04;
    8c12:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8c14:	80 00 e6 8b 	mova	#35814,	r0	;0x08be6

00008c18 <.L13>:
  if ((value & 0x02) && value != 0x02) {
    8c18:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    8c1c:	09 24       	jz	$+20     	;abs 0x8c30

00008c1e <.Loc.177.1>:
    8c1e:	2c 93       	cmp	#2,	r12	;r3 As==10
    8c20:	07 24       	jz	$+16     	;abs 0x8c30

00008c22 <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    8c22:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c26:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c2a <.LVL20>:
    return 0x02;
    8c2a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8c2c:	80 00 e6 8b 	mova	#35814,	r0	;0x08be6

00008c30 <.L14>:
  if ((value & 0x01) && value != 0x01) {
    8c30:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8c34:	02 24       	jz	$+6      	;abs 0x8c3a

00008c36 <.Loc.181.1>:
    8c36:	1c 93       	cmp	#1,	r12	;r3 As==01
    8c38:	0a 20       	jnz	$+22     	;abs 0x8c4e

00008c3a <.L15>:
  if (value & 0xD0) {
    8c3a:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    8c3e:	d3 27       	jz	$-88     	;abs 0x8be6

00008c40 <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    8c40:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c44:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c48 <.LVL21>:
    return 0x00;
    8c48:	4c 43       	clr.b	r12		;
    8c4a:	80 00 e6 8b 	mova	#35814,	r0	;0x08be6

00008c4e <.L16>:
    elyErrorSignal(ErrRegClip);
    8c4e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c52:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c56 <.LVL22>:
    return 0x01;
    8c56:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c58:	80 00 e6 8b 	mova	#35814,	r0	;0x08be6

00008c5c <clamp>:
static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    8c5c:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008c5e <.LCFI0>:
    8c5e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c62:	4a 4d       	mov.b	r13,	r10	;
    8c64:	49 4e       	mov.b	r14,	r9	;

00008c66 <.Loc.153.1>:
  if (value < min) {
    8c66:	4c 9a       	cmp.b	r10,	r12	;
    8c68:	04 28       	jnc	$+10     	;abs 0x8c72

00008c6a <.Loc.157.1>:
  else if (value > max) {
    8c6a:	49 9c       	cmp.b	r12,	r9	;
    8c6c:	09 28       	jnc	$+20     	;abs 0x8c80

00008c6e <.L19>:
}
    8c6e:	19 16       	popm.a	#2,	r10	;20-bit words
    8c70:	10 01       	reta			;

00008c72 <.L20>:
    elyErrorSignal(ErrRegClip);
    8c72:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c76:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c7a <.LVL26>:
    value = min;
    8c7a:	0c 4a       	mov	r10,	r12	;
    8c7c:	80 00 6e 8c 	mova	#35950,	r0	;0x08c6e

00008c80 <.L21>:
    elyErrorSignal(ErrRegClip);
    8c80:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8c84:	b0 13 fa 96 	calla	#38650		;0x096fa

00008c88 <.LVL28>:
    value = max;
    8c88:	0c 49       	mov	r9,	r12	;
    8c8a:	80 00 6e 8c 	mova	#35950,	r0	;0x08c6e

00008c8e <clamps>:
static uint8_t clamps(uint8_t value, int8_t min, int8_t max) {
    8c8e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00008c90 <.LCFI1>:
    8c90:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c94:	4a 4d       	mov.b	r13,	r10	;
    8c96:	40 18 8a 11 	sxtx.w	r10		;
    8c9a:	49 4e       	mov.b	r14,	r9	;
    8c9c:	40 18 89 11 	sxtx.w	r9		;

00008ca0 <.Loc.194.1>:
  if ((int8_t)(value) < min) {
    8ca0:	4d 4c       	mov.b	r12,	r13	;

00008ca2 <.LVL30>:
    8ca2:	40 18 8d 11 	sxtx.w	r13		;
    8ca6:	4d 9a       	cmp.b	r10,	r13	;
    8ca8:	04 38       	jl	$+10     	;abs 0x8cb2

00008caa <.Loc.198.1>:
  else if ((int8_t)(value) > max) {
    8caa:	49 9d       	cmp.b	r13,	r9	;
    8cac:	09 38       	jl	$+20     	;abs 0x8cc0

00008cae <.L24>:
}
    8cae:	19 16       	popm.a	#2,	r10	;20-bit words
    8cb0:	10 01       	reta			;

00008cb2 <.L25>:
    elyErrorSignal(ErrRegClip);
    8cb2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00008cb6 <.LVL33>:
    8cb6:	b0 13 fa 96 	calla	#38650		;0x096fa

00008cba <.LVL34>:
    value = (uint8_t)(min);
    8cba:	4c 4a       	mov.b	r10,	r12	;

00008cbc <.LVL35>:
    8cbc:	80 00 ae 8c 	mova	#36014,	r0	;0x08cae

00008cc0 <.L26>:
    elyErrorSignal(ErrRegClip);
    8cc0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8cc4:	b0 13 fa 96 	calla	#38650		;0x096fa

00008cc8 <.LVL37>:
    value = (uint8_t)(max);
    8cc8:	4c 49       	mov.b	r9,	r12	;

00008cca <.LVL38>:
    8cca:	80 00 ae 8c 	mova	#36014,	r0	;0x08cae

00008cce <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    8cce:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008cd0 <.LCFI2>:
    8cd0:	b1 00 08 00 	suba	#8,	r1	;

00008cd4 <.LCFI3>:
    8cd4:	4a 4c       	mov.b	r12,	r10	;
    8cd6:	47 4d       	mov.b	r13,	r7	;
    8cd8:	49 4e       	mov.b	r14,	r9	;
    8cda:	71 0f 00 00 	mova	r15,	0(r1)	;

00008cde <.LBB53>:
  _disable_interrupts();
    8cde:	32 c2       	dint			
    8ce0:	03 43       	nop			

00008ce2 <.Loc.348.3>:
  asm volatile("nop");
    8ce2:	03 43       	nop			

00008ce4 <.LBE53>:
  chSysLock();
    8ce4:	86 00 50 45 	mova	#17744,	r6	;0x04550
    8ce8:	46 13       	calla	r6		;

00008cea <.LVL40>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8cea:	4d 43       	clr.b	r13		;
    8cec:	cc 01       	mova	r1,	r12	;
    8cee:	ac 00 04 00 	adda	#4,	r12	;
    8cf2:	b0 13 b0 96 	calla	#38576		;0x096b0

00008cf6 <.LVL41>:
  chSysUnlock();
    8cf6:	88 00 70 45 	mova	#17776,	r8	;0x04570
    8cfa:	48 13       	calla	r8		;

00008cfc <.LBB55>:
  asm volatile("nop");
    8cfc:	03 43       	nop			

00008cfe <.Loc.356.3>:
  _enable_interrupts();
    8cfe:	03 43       	nop			
    8d00:	32 d2       	eint			
    8d02:	03 43       	nop			

00008d04 <.LBE55>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    8d04:	3c 01 04 00 	mova	4(r1),	r12	;
    8d08:	37 53       	add	#-1,	r7	;r3 As==11

00008d0a <.LVL43>:
    8d0a:	47 18 07 57 	rpt #8 { rlax.w	r7		;

00008d0e <.LVL44>:
    8d0e:	04 47       	mov	r7,	r4	;
    8d10:	05 47       	mov	r7,	r5	;
    8d12:	4e 18 05 11 	rpt #15 { rrax.w	r5		;
    8d16:	4e 49       	mov.b	r9,	r14	;
    8d18:	0f 43       	clr	r15		;
    8d1a:	0d 44       	mov	r4,	r13	;
    8d1c:	0d 5e       	add	r14,	r13	;
    8d1e:	0e 45       	mov	r5,	r14	;
    8d20:	0e 6f       	addc	r15,	r14	;
    8d22:	0d 53       	add	#0,	r13	;r3 As==00
    8d24:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8d28:	1e 63       	addc	#1,	r14	;r3 As==01
    8d2a:	8c 4e 02 00 	mov	r14,	2(r12)	;

00008d2e <.Loc.225.1>:
  req->read = read;
    8d2e:	3c 01 04 00 	mova	4(r1),	r12	;
    8d32:	5a f3       	and.b	#1,	r10	;r3 As==01

00008d34 <.LVL45>:
    8d34:	4a 5a       	rla.b	r10		;
    8d36:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8d3a:	6d c3       	bic.b	#2,	r13	;r3 As==10
    8d3c:	4d da       	bis.b	r10,	r13	;
    8d3e:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008d42 <.Loc.226.1>:
  req->size = 1;
    8d42:	1d 4c 04 00 	mov	4(r12),	r13	;
    8d46:	7d f0 03 00 	and.b	#3,	r13	;
    8d4a:	2d d2       	bis	#4,	r13	;r2 As==10
    8d4c:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008d50 <.LVL46>:
    8d50:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    8d54:	06 00 

00008d56 <.Loc.227.1>:
  req->buffer = valuep;
    8d56:	00 18 ec 41 	movx.a	@r1,	8(r12)	;
    8d5a:	08 00 

00008d5c <.Loc.228.1>:
  req->callback = fram_reg_cb;
    8d5c:	00 18 fc 40 	movx.a	#35686,	12(r12)	;0x08b66, 0x0000c
    8d60:	66 8b 0c 00 

00008d64 <.LBB57>:
  _disable_interrupts();
    8d64:	32 c2       	dint			
    8d66:	03 43       	nop			

00008d68 <.Loc.348.3>:
  asm volatile("nop");
    8d68:	03 43       	nop			

00008d6a <.LBE57>:
  chSysLock();
    8d6a:	46 13       	calla	r6		;

00008d6c <.LVL47>:
  elyFramPostRequestS(req);
    8d6c:	3c 01 04 00 	mova	4(r1),	r12	;
    8d70:	b0 13 60 96 	calla	#38496		;0x09660

00008d74 <.LVL48>:
  chSysUnlock();
    8d74:	48 13       	calla	r8		;

00008d76 <.LBB59>:
  asm volatile("nop");
    8d76:	03 43       	nop			

00008d78 <.Loc.356.3>:
  _enable_interrupts();
    8d78:	03 43       	nop			
    8d7a:	32 d2       	eint			
    8d7c:	03 43       	nop			

00008d7e <.LBE59>:
}
    8d7e:	a1 00 08 00 	adda	#8,	r1	;
    8d82:	64 16       	popm.a	#7,	r10	;20-bit words
    8d84:	10 01       	reta			;

00008d86 <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    8d86:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008d88 <.LCFI4>:
    8d88:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00008d8c <.LCFI5>:
    8d8c:	4a 4c       	mov.b	r12,	r10	;
    8d8e:	47 4d       	mov.b	r13,	r7	;
    8d90:	49 4e       	mov.b	r14,	r9	;
    8d92:	71 0f 04 00 	mova	r15,	4(r1)	;

00008d96 <.LBB61>:
  _disable_interrupts();
    8d96:	32 c2       	dint			
    8d98:	03 43       	nop			

00008d9a <.Loc.348.3>:
  asm volatile("nop");
    8d9a:	03 43       	nop			

00008d9c <.LBE61>:
  fram_req_t * req;
  
  chSysLock();
    8d9c:	86 00 50 45 	mova	#17744,	r6	;0x04550
    8da0:	46 13       	calla	r6		;

00008da2 <.LVL51>:
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8da2:	4d 43       	clr.b	r13		;
    8da4:	cc 01       	mova	r1,	r12	;
    8da6:	ac 00 08 00 	adda	#8,	r12	;
    8daa:	b0 13 b0 96 	calla	#38576		;0x096b0

00008dae <.LVL52>:
  chSysUnlock();
    8dae:	88 00 70 45 	mova	#17776,	r8	;0x04570
    8db2:	48 13       	calla	r8		;

00008db4 <.LBB63>:
  asm volatile("nop");
    8db4:	03 43       	nop			

00008db6 <.Loc.356.3>:
  _enable_interrupts();
    8db6:	03 43       	nop			
    8db8:	32 d2       	eint			
    8dba:	03 43       	nop			

00008dbc <.LBE63>:
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    8dbc:	3c 01 08 00 	mova	8(r1),	r12	;
    8dc0:	37 53       	add	#-1,	r7	;r3 As==11

00008dc2 <.LVL54>:
    8dc2:	47 18 07 57 	rpt #8 { rlax.w	r7		;

00008dc6 <.LVL55>:
    8dc6:	04 47       	mov	r7,	r4	;
    8dc8:	05 47       	mov	r7,	r5	;
    8dca:	4e 18 05 11 	rpt #15 { rrax.w	r5		;
    8dce:	4e 49       	mov.b	r9,	r14	;
    8dd0:	0f 43       	clr	r15		;
    8dd2:	0d 44       	mov	r4,	r13	;
    8dd4:	0d 5e       	add	r14,	r13	;
    8dd6:	0e 45       	mov	r5,	r14	;
    8dd8:	0e 6f       	addc	r15,	r14	;
    8dda:	0d 53       	add	#0,	r13	;r3 As==00
    8ddc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8de0:	1e 63       	addc	#1,	r14	;r3 As==01
    8de2:	8c 4e 02 00 	mov	r14,	2(r12)	;

00008de6 <.Loc.253.1>:
  req->read = read;
    8de6:	3c 01 08 00 	mova	8(r1),	r12	;
    8dea:	5a f3       	and.b	#1,	r10	;r3 As==01

00008dec <.LVL56>:
    8dec:	4a 5a       	rla.b	r10		;
    8dee:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8df2:	6d c3       	bic.b	#2,	r13	;r3 As==10
    8df4:	4d da       	bis.b	r10,	r13	;
    8df6:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008dfa <.Loc.254.1>:
  req->size = n;
    8dfa:	5d 41 2c 00 	mov.b	44(r1),	r13	;0x0002c
    8dfe:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    8e02:	00 00 
    8e04:	2d 41       	mov	@r1,	r13	;
    8e06:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8e0a:	1e 4c 04 00 	mov	4(r12),	r14	;
    8e0e:	7e f0 03 00 	and.b	#3,	r14	;
    8e12:	0e dd       	bis	r13,	r14	;
    8e14:	8c 4e 04 00 	mov	r14,	4(r12)	;

00008e18 <.LVL57>:
    8e18:	2e 41       	mov	@r1,	r14	;
    8e1a:	0d 4e       	mov	r14,	r13	;
    8e1c:	5d 03       	rrum	#1,	r13	;
    8e1e:	4c 18 0d 11 	rpt #13 { rrax.w	r13		;
    8e22:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    8e26:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
    8e2a:	4e dd       	bis.b	r13,	r14	;
    8e2c:	0f 01       	mova	@r1,	r15	;
    8e2e:	0f 14       	pushm.a	#1,	r15	;20-bit words
    8e30:	0d 17       	popm	#1,	r13	;16-bit words
    8e32:	0d 17       	popm	#1,	r13	;16-bit words
    8e34:	5d f3       	and.b	#1,	r13	;r3 As==01
    8e36:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8e3a:	6e c2       	bic.b	#4,	r14	;r2 As==10
    8e3c:	4e dd       	bis.b	r13,	r14	;
    8e3e:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00008e42 <.Loc.255.1>:
  req->buffer = buffer;
    8e42:	00 18 dc 41 	movx.a	4(r1),	8(r12)	;
    8e46:	04 00 08 00 

00008e4a <.Loc.256.1>:
  req->callback = fram_block_cb;
    8e4a:	00 18 fc 40 	movx.a	#35746,	12(r12)	;0x08ba2, 0x0000c
    8e4e:	a2 8b 0c 00 

00008e52 <.LBB65>:
  _disable_interrupts();
    8e52:	32 c2       	dint			
    8e54:	03 43       	nop			

00008e56 <.Loc.348.3>:
  asm volatile("nop");
    8e56:	03 43       	nop			

00008e58 <.LBE65>:
  
  /* TODO handle failure */
  chSysLock();
    8e58:	46 13       	calla	r6		;

00008e5a <.LVL58>:
  elyFramPostRequestS(req);
    8e5a:	3c 01 08 00 	mova	8(r1),	r12	;
    8e5e:	b0 13 60 96 	calla	#38496		;0x09660

00008e62 <.LVL59>:
  chSysUnlock();
    8e62:	48 13       	calla	r8		;

00008e64 <.LBB67>:
  asm volatile("nop");
    8e64:	03 43       	nop			

00008e66 <.Loc.356.3>:
  _enable_interrupts();
    8e66:	03 43       	nop			
    8e68:	32 d2       	eint			
    8e6a:	03 43       	nop			

00008e6c <.LBE67>:
}
    8e6c:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    8e70:	64 16       	popm.a	#7,	r10	;20-bit words
    8e72:	10 01       	reta			;

00008e74 <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    8e74:	4e 4c       	mov.b	r12,	r14	;
    8e76:	4c 4d       	mov.b	r13,	r12	;

00008e78 <.LVL62>:
  switch(addr) {
    8e78:	3e 90 24 00 	cmp	#36,	r14	;#0x0024
    8e7c:	b3 24       	jz	$+360    	;abs 0x8fe4
    8e7e:	7d 40 24 00 	mov.b	#36,	r13	;#0x0024

00008e82 <.LVL63>:
    8e82:	4d 9e       	cmp.b	r14,	r13	;
    8e84:	4c 28       	jnc	$+154    	;abs 0x8f1e
    8e86:	3e 90 0f 00 	cmp	#15,	r14	;#0x000f
    8e8a:	9c 24       	jz	$+314    	;abs 0x8fc4
    8e8c:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    8e90:	4f 9e       	cmp.b	r14,	r15	;
    8e92:	19 2c       	jc	$+52     	;abs 0x8ec6
    8e94:	3e 90 1f 00 	cmp	#31,	r14	;#0x001f
    8e98:	9d 24       	jz	$+316    	;abs 0x8fd4
    8e9a:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f
    8e9e:	4d 9e       	cmp.b	r14,	r13	;
    8ea0:	2e 2c       	jc	$+94     	;abs 0x8efe
    8ea2:	3e 90 21 00 	cmp	#33,	r14	;#0x0021
    8ea6:	36 20       	jnz	$+110    	;abs 0x8f14

00008ea8 <.Loc.285.1>:
      break;
    case RegRXBRMsb:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
      break;
    case RegOutputPower:
      value = clamp(value, TX_POW_MIN, TX_POW_MAX);
    8ea8:	7e 40 82 ff 	mov.b	#-126,	r14	;#0xff82

00008eac <.LVL64>:
    8eac:	7d 40 3b 00 	mov.b	#59,	r13	;#0x003b
    8eb0:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008eb4 <.LVL65>:
    8eb4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008eb8 <.L42>:
    case RegUARTBaudLsb:
    case RegSCCommBaudLsb:
      value = clamp(value, 1, 0xFF);
    8eb8:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    8eba:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8ebc:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008ec0 <.LVL67>:
    8ec0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008ec4 <.L46>:
        value = elyRFDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    8ec4:	10 01       	reta			;

00008ec6 <.L53>:
  switch(addr) {
    8ec6:	3e 90 07 00 	cmp	#7,	r14	;
    8eca:	6a 24       	jz	$+214    	;abs 0x8fa0
    8ecc:	3e 90 0b 00 	cmp	#11,	r14	;#0x000b
    8ed0:	71 24       	jz	$+228    	;abs 0x8fb4
    8ed2:	3e 90 03 00 	cmp	#3,	r14	;
    8ed6:	5a 24       	jz	$+182    	;abs 0x8f8c

00008ed8 <.L30>:
      if (addr > 0x80 && addr < 0xBF) {
    8ed8:	4d 4e       	mov.b	r14,	r13	;
    8eda:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    8ede:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    8ee2:	4f 9d       	cmp.b	r13,	r15	;
    8ee4:	96 2c       	jc	$+302    	;abs 0x9012

00008ee6 <.Loc.324.1>:
      else if (addr > 0xC0) {
    8ee6:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    8eea:	4d 9e       	cmp.b	r14,	r13	;
    8eec:	eb 2f       	jc	$-40     	;abs 0x8ec4

00008eee <.Loc.325.1>:
        value = elyRFDLLClampReg(addr, value);
    8eee:	4d 4c       	mov.b	r12,	r13	;
    8ef0:	4c 4e       	mov.b	r14,	r12	;
    8ef2:	b0 13 1a 97 	calla	#38682		;0x0971a

00008ef6 <.LVL70>:
    8ef6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008efa <.LVL71>:
    8efa:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008efe <.L54>:
  switch(addr) {
    8efe:	3e 90 1b 00 	cmp	#27,	r14	;#0x001b
    8f02:	ea 23       	jnz	$-42     	;abs 0x8ed8

00008f04 <.Loc.279.1>:
      value = clamp(value, TX_BR_MIN_MSB, TX_BR_MAX_MSB);
    8f04:	4e 43       	clr.b	r14		;
    8f06:	4d 4e       	mov.b	r14,	r13	;
    8f08:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008f0c <.LVL73>:
    8f0c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008f10 <.LVL74>:
      break;
    8f10:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008f14 <.L55>:
  switch(addr) {
    8f14:	3e 90 22 00 	cmp	#34,	r14	;#0x0022
    8f18:	cf 27       	jz	$-96     	;abs 0x8eb8
    8f1a:	80 00 d8 8e 	mova	#36568,	r0	;0x08ed8

00008f1e <.L32>:
    8f1e:	3e 90 3a 00 	cmp	#58,	r14	;#0x003a
    8f22:	60 24       	jz	$+194    	;abs 0x8fe4
    8f24:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    8f28:	4f 9e       	cmp.b	r14,	r15	;
    8f2a:	18 2c       	jc	$+50     	;abs 0x8f5c
    8f2c:	3e 90 40 00 	cmp	#64,	r14	;#0x0040
    8f30:	68 24       	jz	$+210    	;abs 0x9002
    8f32:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    8f36:	4d 9e       	cmp.b	r14,	r13	;
    8f38:	24 2c       	jc	$+74     	;abs 0x8f82
    8f3a:	4d 4e       	mov.b	r14,	r13	;
    8f3c:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    8f40:	7f 40 05 00 	mov.b	#5,	r15	;
    8f44:	4f 9d       	cmp.b	r13,	r15	;
    8f46:	c8 2b       	jnc	$-110    	;abs 0x8ed8

00008f48 <.Loc.318.1>:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
    8f48:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    8f4c:	7d 40 b0 ff 	mov.b	#-80,	r13	;#0xffb0
    8f50:	b0 13 8e 8c 	calla	#35982		;0x08c8e

00008f54 <.LVL76>:
    8f54:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008f58 <.LVL77>:
      break;
    8f58:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008f5c <.L58>:
  switch(addr) {
    8f5c:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033
    8f60:	4d 9e       	cmp.b	r14,	r13	;
    8f62:	0a 28       	jnc	$+22     	;abs 0x8f78
    8f64:	7f 40 29 00 	mov.b	#41,	r15	;#0x0029
    8f68:	4f 9e       	cmp.b	r14,	r15	;
    8f6a:	45 28       	jnc	$+140    	;abs 0x8ff6
    8f6c:	3e 90 25 00 	cmp	#37,	r14	;#0x0025
    8f70:	b3 23       	jnz	$-152    	;abs 0x8ed8

00008f72 <.L51>:
      return 0; /* this is purely efficiency */
    8f72:	4c 43       	clr.b	r12		;
    8f74:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008f78 <.L44>:
  switch(addr) {
    8f78:	3e 90 38 00 	cmp	#56,	r14	;#0x0038
    8f7c:	9d 27       	jz	$-196    	;abs 0x8eb8
    8f7e:	80 00 d8 8e 	mova	#36568,	r0	;0x08ed8

00008f82 <.L59>:
    8f82:	3e 90 3b 00 	cmp	#59,	r14	;#0x003b
    8f86:	f5 27       	jz	$-20     	;abs 0x8f72
    8f88:	80 00 d8 8e 	mova	#36568,	r0	;0x08ed8

00008f8c <.L56>:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    8f8c:	7e 40 38 00 	mov.b	#56,	r14	;#0x0038
    8f90:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033
    8f94:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008f98 <.LVL79>:
    8f98:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008f9c <.LVL80>:
      break;
    8f9c:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008fa0 <.L35>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    8fa0:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    8fa4:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b
    8fa8:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008fac <.LVL82>:
    8fac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008fb0 <.LVL83>:
      break;
    8fb0:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008fb4 <.L36>:
      value = clamp(value, TX_DEV_MIN_MSB, TX_DEV_MAX_MSB);
    8fb4:	4e 43       	clr.b	r14		;
    8fb6:	4d 4e       	mov.b	r14,	r13	;
    8fb8:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008fbc <.LVL85>:
    8fbc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008fc0 <.LVL86>:
      break;
    8fc0:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008fc4 <.L33>:
      value = clamp(value, RX_DEV_MIN_MSB, RX_DEV_MAX_MSB);
    8fc4:	4e 43       	clr.b	r14		;
    8fc6:	4d 4e       	mov.b	r14,	r13	;
    8fc8:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008fcc <.LVL88>:
    8fcc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008fd0 <.LVL89>:
      break;
    8fd0:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008fd4 <.L38>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    8fd4:	4e 43       	clr.b	r14		;
    8fd6:	4d 4e       	mov.b	r14,	r13	;
    8fd8:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008fdc <.LVL91>:
    8fdc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008fe0 <.LVL92>:
      break;
    8fe0:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008fe4 <.L31>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    8fe4:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    8fe8:	4d 43       	clr.b	r13		;
    8fea:	b0 13 5c 8c 	calla	#35932		;0x08c5c

00008fee <.LVL94>:
    8fee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008ff2 <.LVL95>:
      break;
    8ff2:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00008ff6 <.L45>:
      value = clamp_err(value);
    8ff6:	b0 13 c8 8b 	calla	#35784		;0x08bc8

00008ffa <.LVL97>:
    8ffa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008ffe <.LVL98>:
      break;
    8ffe:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00009002 <.L47>:
      value = clamp(value, 0, 4);
    9002:	6e 42       	mov.b	#4,	r14	;r2 As==10
    9004:	4d 43       	clr.b	r13		;
    9006:	b0 13 5c 8c 	calla	#35932		;0x08c5c

0000900a <.LVL100>:
    900a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000900e <.LVL101>:
      break;
    900e:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00009012 <.L57>:
        value = elyNLClampReg(addr, value);
    9012:	4d 4c       	mov.b	r12,	r13	;
    9014:	4c 4e       	mov.b	r14,	r12	;
    9016:	b0 13 fa 99 	calla	#39418		;0x099fa

0000901a <.LVL103>:
    901a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000901e <.LVL104>:
    901e:	80 00 c4 8e 	mova	#36548,	r0	;0x08ec4

00009022 <elyRegGet>:

void elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    9022:	3a 14       	pushm.a	#4,	r10	;20-bit words

00009024 <.LCFI6>:
    9024:	47 4c       	mov.b	r12,	r7	;
    9026:	c8 0d       	mova	r13,	r8	;
    9028:	49 4e       	mov.b	r14,	r9	;

0000902a <.Loc.333.1>:
  regs_in_progress = n;
    902a:	40 18 c2 49 	movx.b	r9,	&0xfd3d2;
    902e:	d2 d3 

00009030 <.Loc.335.1>:
  
  if (bank == 0) {
    9030:	07 93       	cmp	#0,	r7	;r3 As==00
    9032:	14 24       	jz	$+42     	;abs 0x905c
    9034:	4a 43       	clr.b	r10		;
    9036:	80 00 7a 90 	mova	#36986,	r0	;0x0907a

0000903a <.L63>:
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
    903a:	0e 4d       	mov	r13,	r14	;
    903c:	4e 0e       	rlam.a	#4,	r14	;
    903e:	4e 0d       	rram.a	#4,	r14	;
    9040:	cc 0e       	mova	r14,	r12	;
    9042:	ec 08       	adda	r8,	r12	;

00009044 <.LVL107>:
      *(buffer+i) = bank0p[addr];
    9044:	6f 4c       	mov.b	@r12,	r15	;
    9046:	40 18 0e 4f 	movx.w	r15,	r14	;
    904a:	40 18 dc 4e 	movx.b	45494(r14),0(r12)	;0x0b1b6
    904e:	b6 b1 00 00 

00009052 <.LBE70>:
    for (int i = 0; i < n; i++) {
    9052:	1d 53       	inc	r13		;

00009054 <.L61>:
    9054:	0d 99       	cmp	r9,	r13	;
    9056:	f1 3b       	jl	$-28     	;abs 0x903a

00009058 <.L60>:
    }
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
}
    9058:	37 16       	popm.a	#4,	r10	;20-bit words
    905a:	10 01       	reta			;

0000905c <.L66>:
    905c:	4d 43       	clr.b	r13		;
    905e:	80 00 54 90 	mova	#36948,	r0	;0x09054

00009062 <.L65>:
      uint8_t addr = buffer[i];
    9062:	0d 4a       	mov	r10,	r13	;
    9064:	4d 0e       	rlam.a	#4,	r13	;
    9066:	4d 0d       	rram.a	#4,	r13	;
    9068:	cc 0d       	mova	r13,	r12	;
    906a:	ec 08       	adda	r8,	r12	;

0000906c <.LVL113>:
      fram_reg(1, bank, addr, (buffer+i));
    906c:	cf 0c       	mova	r12,	r15	;
    906e:	6e 4c       	mov.b	@r12,	r14	;
    9070:	4d 47       	mov.b	r7,	r13	;
    9072:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009074 <.LVL114>:
    9074:	b0 13 ce 8c 	calla	#36046		;0x08cce

00009078 <.LBE72>:
    for (int i = 0; i < n; i++) {
    9078:	1a 53       	inc	r10		;

0000907a <.L62>:
    907a:	0a 99       	cmp	r9,	r10	;
    907c:	f2 3b       	jl	$-26     	;abs 0x9062

0000907e <.LBB73>:
  return chSemWaitTimeout(&bsp->sem, time);
    907e:	4d 43       	clr.b	r13		;
    9080:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    9084:	b0 13 ca 49 	calla	#18890		;0x049ca

00009088 <.LBE73>:
}
    9088:	80 00 58 90 	mova	#36952,	r0	;0x09058

0000908c <elyRegSet>:

void elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    908c:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000908e <.LCFI7>:
    908e:	45 4c       	mov.b	r12,	r5	;
    9090:	c8 0d       	mova	r13,	r8	;
    9092:	46 4e       	mov.b	r14,	r6	;

00009094 <.Loc.355.1>:
  regs_in_progress = n;
    9094:	40 18 c2 46 	movx.b	r6,	&0xfd3d2;
    9098:	d2 d3 

0000909a <.LBB75>:
  
  for (int i = 0; i < n * 2; i += 2) {
    909a:	49 43       	clr.b	r9		;
    909c:	80 00 ce 90 	mova	#37070,	r0	;0x090ce

000090a0 <.L69>:
    uint8_t addr = buffer[i];
    90a0:	0c 49       	mov	r9,	r12	;
    90a2:	4c 0e       	rlam.a	#4,	r12	;
    90a4:	4c 0d       	rram.a	#4,	r12	;
    90a6:	ca 0c       	mova	r12,	r10	;
    90a8:	cc 08       	mova	r8,	r12	;
    90aa:	ec 0a       	adda	r10,	r12	;
    90ac:	67 4c       	mov.b	@r12,	r7	;

000090ae <.LVL122>:
    uint8_t *valuep = &buffer[i+1];
    90ae:	aa 00 01 00 	adda	#1,	r10	;
    90b2:	ea 08       	adda	r8,	r10	;

000090b4 <.LVL123>:
    (*valuep) = elyClampReg(addr, (*valuep));
    90b4:	6d 4a       	mov.b	@r10,	r13	;
    90b6:	4c 47       	mov.b	r7,	r12	;

000090b8 <.LVL124>:
    90b8:	b0 13 74 8e 	calla	#36468		;0x08e74

000090bc <.LVL125>:
    90bc:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

000090c0 <.Loc.363.1>:
  
    /* Write the register */
    fram_reg(0, bank, addr, valuep);
    90c0:	cf 0a       	mova	r10,	r15	;
    90c2:	4e 47       	mov.b	r7,	r14	;
    90c4:	4d 45       	mov.b	r5,	r13	;
    90c6:	4c 43       	clr.b	r12		;
    90c8:	b0 13 ce 8c 	calla	#36046		;0x08cce

000090cc <.LBE76>:
  for (int i = 0; i < n * 2; i += 2) {
    90cc:	29 53       	incd	r9		;

000090ce <.L68>:
    90ce:	0c 46       	mov	r6,	r12	;
    90d0:	0c 56       	add	r6,	r12	;
    90d2:	09 9c       	cmp	r12,	r9	;
    90d4:	e5 3b       	jl	$-52     	;abs 0x90a0

000090d6 <.LBB77>:
    90d6:	4d 43       	clr.b	r13		;
    90d8:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    90dc:	b0 13 ca 49 	calla	#18890		;0x049ca

000090e0 <.LBE77>:
  }
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
}
    90e0:	55 16       	popm.a	#6,	r10	;20-bit words
    90e2:	10 01       	reta			;

000090e4 <elyRegGetBlock>:

void elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    90e4:	b1 00 02 00 	suba	#2,	r1	;

000090e8 <.LCFI8>:
    90e8:	4b 4c       	mov.b	r12,	r11	;
    90ea:	cc 0d       	mova	r13,	r12	;

000090ec <.LVL131>:
    90ec:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    90f0:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

000090f4 <.Loc.373.1>:
  
  if (bank == 0) {
    90f4:	0b 93       	cmp	#0,	r11	;r3 As==00
    90f6:	0f 24       	jz	$+32     	;abs 0x9116

000090f8 <.Loc.378.1>:
    memcpy(buffer, bank0p + addr, n);
  }
  else {
    /* Read the block */
    fram_block(1, bank, addr, buffer, n);
    90f8:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    90fc:	cf 0d       	mova	r13,	r15	;

000090fe <.LVL132>:
    90fe:	4d 4b       	mov.b	r11,	r13	;

00009100 <.LVL133>:
    9100:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009102 <.LVL134>:
    9102:	b0 13 86 8d 	calla	#36230		;0x08d86

00009106 <.LBB79>:
    9106:	4d 43       	clr.b	r13		;
    9108:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    910c:	b0 13 ca 49 	calla	#18890		;0x049ca

00009110 <.L70>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
}
    9110:	a1 00 02 00 	adda	#2,	r1	;
    9114:	10 01       	reta			;

00009116 <.L73>:
    memcpy(buffer, bank0p + addr, n);
    9116:	40 18 0d 4e 	movx.w	r14,	r13	;
    911a:	40 18 0e 4f 	movx.w	r15,	r14	;
    911e:	ad 00 b6 b1 	adda	#45494,	r13	;0x0b1b6
    9122:	b0 13 f4 9f 	calla	#40948		;0x09ff4

00009126 <.LVL138>:
    9126:	80 00 10 91 	mova	#37136,	r0	;0x09110

0000912a <elyRegSetBlock>:

void elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    912a:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000912c <.LCFI9>:
    912c:	b1 00 02 00 	suba	#2,	r1	;

00009130 <.LCFI10>:
    9130:	45 4c       	mov.b	r12,	r5	;
    9132:	c6 0d       	mova	r13,	r6	;
    9134:	47 4e       	mov.b	r14,	r7	;
    9136:	49 4f       	mov.b	r15,	r9	;

00009138 <.LBB81>:
  
  for (int i = 0; i < n; i++) {
    9138:	4a 43       	clr.b	r10		;
    913a:	80 00 58 91 	mova	#37208,	r0	;0x09158

0000913e <.L76>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    913e:	0c 4a       	mov	r10,	r12	;
    9140:	4c 0e       	rlam.a	#4,	r12	;
    9142:	4c 0d       	rram.a	#4,	r12	;
    9144:	c8 0c       	mova	r12,	r8	;
    9146:	e8 06       	adda	r6,	r8	;
    9148:	6d 48       	mov.b	@r8,	r13	;
    914a:	4c 4a       	mov.b	r10,	r12	;
    914c:	4c 57       	add.b	r7,	r12	;
    914e:	b0 13 74 8e 	calla	#36468		;0x08e74

00009152 <.LVL142>:
    9152:	c8 4c 00 00 	mov.b	r12,	0(r8)	;

00009156 <.Loc.388.1>:
  for (int i = 0; i < n; i++) {
    9156:	1a 53       	inc	r10		;

00009158 <.L75>:
    9158:	0a 99       	cmp	r9,	r10	;
    915a:	f1 3b       	jl	$-28     	;abs 0x913e

0000915c <.LBE81>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    915c:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    9160:	cf 06       	mova	r6,	r15	;
    9162:	4e 47       	mov.b	r7,	r14	;
    9164:	4d 45       	mov.b	r5,	r13	;
    9166:	4c 43       	clr.b	r12		;
    9168:	b0 13 86 8d 	calla	#36230		;0x08d86

0000916c <.LBB82>:
    916c:	4d 43       	clr.b	r13		;
    916e:	8c 00 d4 d3 	mova	#54228,	r12	;0x0d3d4
    9172:	b0 13 ca 49 	calla	#18890		;0x049ca

00009176 <.LBE82>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
}
    9176:	a1 00 02 00 	adda	#2,	r1	;
    917a:	55 16       	popm.a	#6,	r10	;20-bit words
    917c:	10 01       	reta			;

0000917e <dbuf_get_write>:
  uint8_t buf[2][SLIP_RX_BUF_LEN];
  uint16_t write_idx;
  uint16_t read_idx;
} double_buff;

static uint8_t * dbuf_get_write(double_buff * rb) {
    917e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009180 <.LCFI0>:
    9180:	ca 0c       	mova	r12,	r10	;

00009182 <.Loc.14.1>:
  return rb->buf[rb->write_idx++ & 1];
    9182:	1c 4c 00 02 	mov	512(r12),r12	;0x00200

00009186 <.LVL1>:
    9186:	0d 4c       	mov	r12,	r13	;
    9188:	1d 53       	inc	r13		;
    918a:	8a 4d 00 02 	mov	r13,	512(r10); 0x0200
    918e:	5c f3       	and.b	#1,	r12	;r3 As==01
    9190:	0d 43       	clr	r13		;
    9192:	b0 13 f0 9e 	calla	#40688		;0x09ef0
    9196:	0d 12       	push	r13		;
    9198:	0c 12       	push	r12		;
    919a:	0c 16       	popm.a	#1,	r12	;20-bit words

0000919c <.Loc.15.1>:
}
    919c:	ec 0a       	adda	r10,	r12	;
    919e:	0a 16       	popm.a	#1,	r10	;20-bit words
    91a0:	10 01       	reta			;

000091a2 <dbuf_get_read>:

static uint8_t * dbuf_get_read(double_buff * rb) {
    91a2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000091a4 <.LCFI1>:
    91a4:	ca 0c       	mova	r12,	r10	;

000091a6 <.Loc.18.1>:
  return rb->buf[rb->read_idx++ & 1];
    91a6:	1c 4c 02 02 	mov	514(r12),r12	;0x00202

000091aa <.LVL4>:
    91aa:	0d 4c       	mov	r12,	r13	;
    91ac:	1d 53       	inc	r13		;
    91ae:	8a 4d 02 02 	mov	r13,	514(r10); 0x0202
    91b2:	5c f3       	and.b	#1,	r12	;r3 As==01
    91b4:	0d 43       	clr	r13		;
    91b6:	b0 13 f0 9e 	calla	#40688		;0x09ef0
    91ba:	0d 12       	push	r13		;
    91bc:	0c 12       	push	r12		;
    91be:	0c 16       	popm.a	#1,	r12	;20-bit words

000091c0 <.Loc.19.1>:
}
    91c0:	ec 0a       	adda	r10,	r12	;
    91c2:	0a 16       	popm.a	#1,	r10	;20-bit words
    91c4:	10 01       	reta			;

000091c6 <dbuf_init>:

static void dbuf_init(double_buff * rb) {
  chDbgAssert(SLIP_RX_BUF_LEN <= ((UINT16_MAX - 1) / 2), 
      "RX buffer length too long");
  
  rb->write_idx = 0;
    91c6:	8c 43 00 02 	mov	#0,	512(r12);r3 As==00, 0x0200

000091ca <.Loc.26.1>:
  rb->read_idx = 0;
    91ca:	8c 43 02 02 	mov	#0,	514(r12);r3 As==00, 0x0202

000091ce <.Loc.27.1>:
}
    91ce:	10 01       	reta			;

000091d0 <handle_buffer>:
  (void)(uartp);
  
  uart_thd = chThdGetSelfX();
}

static void handle_buffer(size_t bytes_available, const uint8_t * buffer) {
    91d0:	2a 14       	pushm.a	#3,	r10	;20-bit words

000091d2 <.LCFI2>:
    91d2:	06 14       	pushm.a	#1,	r6	;20-bit words

000091d4 <.LCFI3>:
    91d4:	c6 0c       	mova	r12,	r6	;
    91d6:	ca 0d       	mova	r13,	r10	;

000091d8 <.Loc.167.1>:
  static size_t rx_n;
  static bool header;
  /* We have now received 256 bytes of data somewhere in rx_buf */
  
  const uint8_t * end = buffer + bytes_available;
    91d8:	c8 0d       	mova	r13,	r8	;
    91da:	e8 0c       	adda	r12,	r8	;

000091dc <.LVL8>:
  const uint8_t * cp = buffer;
  
  while (cp < end) {
    91dc:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

000091e0 <.L31>:
    
    if (rx_state == ELY_SLIP_RESET) {
      /* allocate a working buffer from the main pool */
      /* TODO this section is dangerous re: resets. Figure out how to fix it. */
      if (NULL == rx_active_buffer) {
        rx_active_buffer = elyNLGetBuffer();
    91e0:	b0 13 a0 9a 	calla	#39584		;0x09aa0

000091e4 <.LVL10>:
    91e4:	60 0c b6 b2 	mova	r12,	&45750	; 0x0b2b6
    91e8:	80 00 14 92 	mova	#37396,	r0	;0x09214

000091ec <.L10>:
    }
    
    switch (rx_state) {
      case ELY_SLIP_ESCAPED:
        {
          switch(c) {
    91ec:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    91f0:	40 24       	jz	$+130    	;abs 0x9272
    91f2:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    91f6:	51 24       	jz	$+164    	;abs 0x929a

000091f8 <.Loc.201.1>:
              break;
            case SLIP_ESC_ESC:
              *rx_write_ptr++ = SLIP_ESC;
              break;
            default:
              rx_state = ELY_SLIP_RESET;
    91f8:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    91fc:	fe d3 

000091fe <.L5>:
  while (cp < end) {
    91fe:	da 08       	cmpa	r8,	r10	;
    9200:	aa 2c       	jc	$+342    	;abs 0x9356

00009202 <.LBB29>:
    uint8_t c = *cp;
    9202:	69 4a       	mov.b	@r10,	r9	;

00009204 <.LVL12>:
    if (rx_state == ELY_SLIP_RESET) {
    9204:	40 18 c2 93 	cmpx.b	#0,	&0xfd3fe;r3 As==00
    9208:	fe d3 
    920a:	15 20       	jnz	$+44     	;abs 0x9236

0000920c <.Loc.176.1>:
      if (NULL == rx_active_buffer) {
    920c:	00 18 c2 93 	cmpx.a	#0,	&0xfb2b6;r3 As==00
    9210:	b6 b2 
    9212:	e6 27       	jz	$-50     	;abs 0x91e0

00009214 <.L7>:
      if (NULL == rx_active_buffer) {
    9214:	2c 00 b6 b2 	mova	&45750,	r12	;0x0b2b6
    9218:	9c 00 00 00 	cmpa	#0,	r12	;
    921c:	ad 24       	jz	$+348    	;abs 0x9378

0000921e <.Loc.184.1>:
      rx_write_ptr = rx_active_buffer;
    921e:	60 0c fa d3 	mova	r12,	&54266	; 0x0d3fa

00009222 <.Loc.185.1>:
      rx_n = elyNLHeaderLen;
    9222:	00 18 f2 40 	movx.a	#6,	&0xfd3d8;
    9226:	06 00 d8 d3 

0000922a <.Loc.186.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    922a:	40 18 e2 43 	movx.b	#2,	&0xfd3fe;r3 As==10
    922e:	fe d3 

00009230 <.Loc.187.1>:
      header = true;
    9230:	40 18 d2 43 	movx.b	#1,	&0xfd3d6;r3 As==01
    9234:	d6 d3 

00009236 <.L6>:
    switch (rx_state) {
    9236:	40 18 5c 42 	movx.b	&0x0d3fe,r12	;
    923a:	fe d3 
    923c:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    923e:	d6 27       	jz	$-82     	;abs 0x91ec
    9240:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9242:	37 24       	jz	$+112    	;abs 0x92b2

00009244 <.Loc.244.1>:
              }
          }
        }
        break;
      default:
        chDbgAssert(false, "shouldn't happen - unreachable code");
    9244:	8c 01 55 04 	mova	#66645,	r12	;0x10455
    9248:	b0 13 a0 47 	calla	#18336		;0x047a0

0000924c <.L17>:
        /* ACTUALLY can't happen */
        break;
    }
    
    if (rx_n == 0 && header) { /* and we haven't reset */
    924c:	00 18 c2 93 	cmpx.a	#0,	&0xfd3d8;r3 As==00
    9250:	d8 d3 
    9252:	d5 23       	jnz	$-84     	;abs 0x91fe

00009254 <.Loc.249.1>:
    9254:	40 18 c2 93 	cmpx.b	#0,	&0xfd3d6;r3 As==00
    9258:	d6 d3 
    925a:	d1 27       	jz	$-92     	;abs 0x91fe

0000925c <.Loc.250.1>:
      if (elyNLValidate(rx_active_buffer)) {
    925c:	2c 00 b6 b2 	mova	&45750,	r12	;0x0b2b6
    9260:	b0 13 a0 9c 	calla	#40096		;0x09ca0

00009264 <.LVL15>:
    9264:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9266:	6a 20       	jnz	$+214    	;abs 0x933c

00009268 <.Loc.256.1>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
        header = false;
      } 
      else {
        /* junk - reset state machine */
        rx_state = ELY_SLIP_RESET;
    9268:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    926c:	fe d3 
    926e:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

00009272 <.L13>:
              *rx_write_ptr++ = SLIP_END;
    9272:	2c 00 fa d3 	mova	&54266,	r12	;0x0d3fa
    9276:	cd 0c       	mova	r12,	r13	;
    9278:	ad 00 01 00 	adda	#1,	r13	;
    927c:	60 0d fa d3 	mova	r13,	&54266	; 0x0d3fa
    9280:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    9284:	00 00 

00009286 <.L15>:
          rx_n--;
    9286:	00 18 f2 53 	addx.a	#-1,	&0xfd3d8;r3 As==11
    928a:	d8 d3 

0000928c <.Loc.205.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    928c:	40 18 e2 43 	movx.b	#2,	&0xfd3fe;r3 As==10
    9290:	fe d3 

00009292 <.Loc.206.1>:
          cp++;
    9292:	aa 00 01 00 	adda	#1,	r10	;

00009296 <.Loc.208.1>:
        break;
    9296:	80 00 4c 92 	mova	#37452,	r0	;0x0924c

0000929a <.L14>:
              *rx_write_ptr++ = SLIP_ESC;
    929a:	2c 00 fa d3 	mova	&54266,	r12	;0x0d3fa
    929e:	cd 0c       	mova	r12,	r13	;
    92a0:	ad 00 01 00 	adda	#1,	r13	;
    92a4:	60 0d fa d3 	mova	r13,	&54266	; 0x0d3fa
    92a8:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    92ac:	00 00 

000092ae <.Loc.199.1>:
              break;
    92ae:	80 00 86 92 	mova	#37510,	r0	;0x09286

000092b2 <.L11>:
          switch(c) {
    92b2:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    92b6:	13 24       	jz	$+40     	;abs 0x92de
    92b8:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    92bc:	24 20       	jnz	$+74     	;abs 0x9306

000092be <.Loc.213.1>:
              if (rx_n == 0) {
    92be:	00 18 c2 93 	cmpx.a	#0,	&0xfd3d8;r3 As==00
    92c2:	d8 d3 
    92c4:	05 20       	jnz	$+12     	;abs 0x92d0

000092c6 <.Loc.214.1>:
                rx_state = ELY_SLIP_RESET;
    92c6:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    92ca:	fe d3 

000092cc <.Loc.215.1>:
                continue;
    92cc:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

000092d0 <.L21>:
                rx_state = ELY_SLIP_ESCAPED;
    92d0:	40 18 d2 43 	movx.b	#1,	&0xfd3fe;r3 As==01
    92d4:	fe d3 

000092d6 <.Loc.219.1>:
                cp++;
    92d6:	aa 00 01 00 	adda	#1,	r10	;

000092da <.Loc.221.1>:
              break;
    92da:	80 00 4c 92 	mova	#37452,	r0	;0x0924c

000092de <.L19>:
              if (rx_n == 0) {
    92de:	00 18 c2 93 	cmpx.a	#0,	&0xfd3d8;r3 As==00
    92e2:	d8 d3 
    92e4:	07 24       	jz	$+16     	;abs 0x92f4

000092e6 <.L22>:
              rx_state = ELY_SLIP_RESET;
    92e6:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    92ea:	fe d3 

000092ec <.Loc.228.1>:
              cp++;
    92ec:	aa 00 01 00 	adda	#1,	r10	;

000092f0 <.Loc.229.1>:
              continue;
    92f0:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

000092f4 <.L33>:
                elyNLRouteUART(rx_active_buffer);
    92f4:	2c 00 b6 b2 	mova	&45750,	r12	;0x0b2b6
    92f8:	b0 13 ce 9d 	calla	#40398		;0x09dce

000092fc <.LVL19>:
                rx_active_buffer = NULL;
    92fc:	00 18 c2 43 	movx.a	#0,	&0xfb2b6;r3 As==00
    9300:	b6 b2 
    9302:	80 00 e6 92 	mova	#37606,	r0	;0x092e6

00009306 <.L29>:
              if (rx_n == 0) {
    9306:	2c 00 d8 d3 	mova	&54232,	r12	;0x0d3d8
    930a:	9c 00 00 00 	cmpa	#0,	r12	;
    930e:	05 20       	jnz	$+12     	;abs 0x931a

00009310 <.Loc.232.1>:
                rx_state = ELY_SLIP_RESET;
    9310:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    9314:	fe d3 

00009316 <.Loc.233.1>:
                continue;
    9316:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

0000931a <.L23>:
                *rx_write_ptr++ = c;
    931a:	2e 00 fa d3 	mova	&54266,	r14	;0x0d3fa
    931e:	cd 0e       	mova	r14,	r13	;
    9320:	ad 00 01 00 	adda	#1,	r13	;
    9324:	60 0d fa d3 	mova	r13,	&54266	; 0x0d3fa
    9328:	ce 49 00 00 	mov.b	r9,	0(r14)	;

0000932c <.Loc.237.1>:
                rx_n--;
    932c:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    9330:	60 0c d8 d3 	mova	r12,	&54232	; 0x0d3d8

00009334 <.Loc.238.1>:
                cp++;
    9334:	aa 00 01 00 	adda	#1,	r10	;
    9338:	80 00 4c 92 	mova	#37452,	r0	;0x0924c

0000933c <.L32>:
        rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    933c:	2c 00 b6 b2 	mova	&45750,	r12	;0x0b2b6
    9340:	b0 13 86 9c 	calla	#40070		;0x09c86

00009344 <.LVL21>:
    9344:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    9348:	60 0c d8 d3 	mova	r12,	&54232	; 0x0d3d8

0000934c <.Loc.252.1>:
        header = false;
    934c:	40 18 c2 43 	movx.b	#0,	&0xfd3d6;r3 As==00
    9350:	d6 d3 
    9352:	80 00 fe 91 	mova	#37374,	r0	;0x091fe

00009356 <.L30>:
      }
    }
  }
  
  if (bytes_available < SLIP_RX_BUF_LEN) {
    9356:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    935a:	dc 06       	cmpa	r6,	r12	;
    935c:	0d 28       	jnc	$+28     	;abs 0x9378

0000935e <.Loc.262.1>:
    if (NULL != rx_active_buffer) {
    935e:	2c 00 b6 b2 	mova	&45750,	r12	;0x0b2b6
    9362:	9c 00 00 00 	cmpa	#0,	r12	;
    9366:	05 24       	jz	$+12     	;abs 0x9372

00009368 <.Loc.263.1>:
      elyNLFreeBuffer(rx_active_buffer);
    9368:	b0 13 aa 9a 	calla	#39594		;0x09aaa

0000936c <.LVL23>:
      rx_active_buffer = NULL;
    936c:	00 18 c2 43 	movx.a	#0,	&0xfb2b6;r3 As==00
    9370:	b6 b2 

00009372 <.L26>:
    }
    rx_state = ELY_SLIP_RESET;
    9372:	40 18 c2 43 	movx.b	#0,	&0xfd3fe;r3 As==00
    9376:	fe d3 

00009378 <.L4>:
  }

}
    9378:	06 16       	popm.a	#1,	r6	;20-bit words
    937a:	28 16       	popm.a	#3,	r10	;20-bit words
    937c:	10 01       	reta			;

0000937e <calc_next_buff>:
  switch (tx_state) {
    937e:	c0 18 5c 42 	movx.b	&0x1051c,r12	;
    9382:	1c 05 
    9384:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9386:	28 24       	jz	$+82     	;abs 0x93d8
    9388:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    938a:	51 20       	jnz	$+164    	;abs 0x942e

0000938c <.Loc.48.1>:
      next_tx_ptr = tx_read_ptr;
    938c:	00 18 d2 42 	movx.a	&0x0d3ea,&0xfd3e2;
    9390:	ea d3 e2 d3 

00009394 <.Loc.49.1>:
      next_cnt = 0;
    9394:	00 18 c2 43 	movx.a	#0,	&0xfd3e6;r3 As==00
    9398:	e6 d3 

0000939a <.Loc.50.1>:
      while (next_cnt != tx_n && 
    939a:	80 00 ae 93 	mova	#37806,	r0	;0x093ae

0000939e <.L40>:
        next_cnt++;
    939e:	ac 00 01 00 	adda	#1,	r12	;
    93a2:	60 0c e6 d3 	mova	r12,	&54246	; 0x0d3e6

000093a6 <.Loc.54.1>:
        tx_read_ptr++;
    93a6:	ae 00 01 00 	adda	#1,	r14	;
    93aa:	60 0e ea d3 	mova	r14,	&54250	; 0x0d3ea

000093ae <.L38>:
      while (next_cnt != tx_n && 
    93ae:	2c 00 e6 d3 	mova	&54246,	r12	;0x0d3e6
    93b2:	00 18 5c 92 	cmpx.a	&0x0d3ee,r12	;
    93b6:	ee d3 
    93b8:	09 24       	jz	$+20     	;abs 0x93cc

000093ba <.Loc.51.1>:
          *tx_read_ptr != SLIP_END && 
    93ba:	2e 00 ea d3 	mova	&54250,	r14	;0x0d3ea
    93be:	6d 4e       	mov.b	@r14,	r13	;

000093c0 <.Loc.50.1>:
      while (next_cnt != tx_n && 
    93c0:	7d 90 c0 ff 	cmp.b	#-64,	r13	;#0xffc0
    93c4:	03 24       	jz	$+8      	;abs 0x93cc

000093c6 <.Loc.51.1>:
          *tx_read_ptr != SLIP_END && 
    93c6:	7d 90 db ff 	cmp.b	#-37,	r13	;#0xffdb
    93ca:	e9 23       	jnz	$-44     	;abs 0x939e

000093cc <.L39>:
      tx_state = ELY_SLIP_ESCAPED;
    93cc:	41 18 d2 43 	movx.b	#1,	&0x1051c;r3 As==01
    93d0:	1c 05 

000093d2 <.Loc.57.1>:
      if (next_cnt > 0) {
    93d2:	9c 00 00 00 	cmpa	#0,	r12	;
    93d6:	1b 20       	jnz	$+56     	;abs 0x940e

000093d8 <.L36>:
        switch(*tx_read_ptr++) {
    93d8:	2c 00 ea d3 	mova	&54250,	r12	;0x0d3ea
    93dc:	cd 0c       	mova	r12,	r13	;
    93de:	ad 00 01 00 	adda	#1,	r13	;
    93e2:	60 0d ea d3 	mova	r13,	&54250	; 0x0d3ea
    93e6:	6c 4c       	mov.b	@r12,	r12	;
    93e8:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    93ec:	11 24       	jz	$+36     	;abs 0x9410
    93ee:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    93f2:	14 20       	jnz	$+42     	;abs 0x941c

000093f4 <.Loc.64.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    93f4:	80 18 f2 40 	movx.a	#66696,	&0xfd3e2;0x10488
    93f8:	88 04 e2 d3 

000093fc <.L45>:
        next_cnt = 2;
    93fc:	00 18 e2 43 	movx.a	#2,	&0xfd3e6;r3 As==10
    9400:	e6 d3 

00009402 <.Loc.78.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    9402:	00 18 d2 53 	incx.a	&0xd3ee		;
    9406:	ee d3 

00009408 <.Loc.79.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    9408:	41 18 e2 43 	movx.b	#2,	&0x1051c;r3 As==10
    940c:	1c 05 

0000940e <.L34>:
}
    940e:	10 01       	reta			;

00009410 <.L43>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    9410:	80 18 f2 40 	movx.a	#66694,	&0xfd3e2;0x10486
    9414:	86 04 e2 d3 

00009418 <.Loc.68.1>:
            break;
    9418:	80 00 fc 93 	mova	#37884,	r0	;0x093fc

0000941c <.L47>:
            chDbgAssert(false, "state machine error");
    941c:	8c 01 77 04 	mova	#66679,	r12	;0x10477
    9420:	b0 13 a0 47 	calla	#18336		;0x047a0

00009424 <.LVL24>:
            tx_n--;
    9424:	00 18 f2 53 	addx.a	#-1,	&0xfd3ee;r3 As==11
    9428:	ee d3 

0000942a <.Loc.75.1>:
            break;
    942a:	80 00 fc 93 	mova	#37884,	r0	;0x093fc

0000942e <.L46>:
      chDbgAssert(false, "State machine error");
    942e:	8c 01 77 04 	mova	#66679,	r12	;0x10477
    9432:	b0 13 a0 47 	calla	#18336		;0x047a0

00009436 <.LVL25>:
}
    9436:	80 00 0e 94 	mova	#37902,	r0	;0x0940e

0000943a <elyUARTDLLTxCB>:
void elyUARTDLLTxCB(UARTDriver * uartp) {
    943a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000943c <.LCFI4>:
    943c:	ca 0c       	mova	r12,	r10	;

0000943e <.Loc.94.1>:
  if (done) {
    943e:	40 18 c2 93 	cmpx.b	#0,	&0xfd3dc;r3 As==00
    9442:	dc d3 
    9444:	05 24       	jz	$+12     	;abs 0x9450

00009446 <.Loc.95.1>:
    done = false;
    9446:	40 18 c2 43 	movx.b	#0,	&0xfd3dc;r3 As==00
    944a:	dc d3 

0000944c <.L48>:
}
    944c:	0a 16       	popm.a	#1,	r10	;20-bit words
    944e:	10 01       	reta			;

00009450 <.L49>:
  chSysLockFromISR();
    9450:	b0 13 92 45 	calla	#17810		;0x04592

00009454 <.LVL28>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    9454:	2e 00 e2 d3 	mova	&54242,	r14	;0x0d3e2
    9458:	2d 00 e6 d3 	mova	&54246,	r13	;0x0d3e6
    945c:	cc 0a       	mova	r10,	r12	;
    945e:	b0 13 3c 52 	calla	#21052		;0x0523c

00009462 <.LVL29>:
  chSysUnlockFromISR();
    9462:	b0 13 b4 45 	calla	#17844		;0x045b4

00009466 <.LVL30>:
  if (tx_n == 0) {
    9466:	2c 00 ee d3 	mova	&54254,	r12	;0x0d3ee
    946a:	9c 00 00 00 	cmpa	#0,	r12	;
    946e:	0c 24       	jz	$+26     	;abs 0x9488

00009470 <.Loc.108.1>:
  tx_n -= next_cnt;
    9470:	00 18 5c 82 	subx.a	&0x0d3e6,r12	;
    9474:	e6 d3 
    9476:	60 0c ee d3 	mova	r12,	&54254	; 0x0d3ee

0000947a <.Loc.110.1>:
  if (tx_n == 0) {
    947a:	9c 00 00 00 	cmpa	#0,	r12	;
    947e:	09 24       	jz	$+20     	;abs 0x9492

00009480 <.Loc.119.1>:
  calc_next_buff();
    9480:	b0 13 7e 93 	calla	#37758		;0x0937e

00009484 <.LVL31>:
    9484:	80 00 4c 94 	mova	#37964,	r0	;0x0944c

00009488 <.L53>:
    done = true;
    9488:	40 18 d2 43 	movx.b	#1,	&0xfd3dc;r3 As==01
    948c:	dc d3 

0000948e <.Loc.105.1>:
    return;
    948e:	80 00 4c 94 	mova	#37964,	r0	;0x0944c

00009492 <.L54>:
    chSysLockFromISR();
    9492:	b0 13 92 45 	calla	#17810		;0x04592

00009496 <.LVL32>:
    elyNLFreeBufferCheckedI(tx_active_buffer);
    9496:	2c 00 f2 d3 	mova	&54258,	r12	;0x0d3f2
    949a:	b0 13 54 9b 	calla	#39764		;0x09b54

0000949e <.LVL33>:
    chSysUnlockFromISR();
    949e:	b0 13 b4 45 	calla	#17844		;0x045b4

000094a2 <.LVL34>:
    next_tx_ptr = &END;
    94a2:	80 18 f2 40 	movx.a	#66678,	&0xfd3e2;0x10476
    94a6:	76 04 e2 d3 

000094aa <.Loc.115.1>:
    next_cnt = 1;
    94aa:	00 18 d2 43 	movx.a	#1,	&0xfd3e6;r3 As==01
    94ae:	e6 d3 

000094b0 <.Loc.116.1>:
    return;
    94b0:	80 00 4c 94 	mova	#37964,	r0	;0x0944c

000094b4 <elyUARTDLLStartTx>:
void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    94b4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000094b6 <.LCFI5>:
    94b6:	08 14       	pushm.a	#1,	r8	;20-bit words

000094b8 <.LCFI6>:
    94b8:	c8 0c       	mova	r12,	r8	;
    94ba:	ca 0d       	mova	r13,	r10	;

000094bc <.Loc.125.1>:
  tx_n = elyNLGetLength(buffer);
    94bc:	cc 0d       	mova	r13,	r12	;

000094be <.LVL36>:
    94be:	b0 13 86 9c 	calla	#40070		;0x09c86

000094c2 <.LVL37>:
    94c2:	60 0c ee d3 	mova	r12,	&54254	; 0x0d3ee

000094c6 <.Loc.126.1>:
  chDbgAssert(tx_n != 0 && tx_n <= elyNLMaxLen, "invalid packet length");
    94c6:	9c 00 00 00 	cmpa	#0,	r12	;
    94ca:	04 24       	jz	$+10     	;abs 0x94d4

000094cc <.Loc.126.1>:
    94cc:	00 18 c2 9c 	cmpx.a	r12,	&0xfd34e;
    94d0:	4e d3 
    94d2:	04 2c       	jc	$+10     	;abs 0x94dc

000094d4 <.L56>:
    94d4:	8c 01 64 04 	mova	#66660,	r12	;0x10464
    94d8:	b0 13 a0 47 	calla	#18336		;0x047a0

000094dc <.L57>:
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    94dc:	2c 00 ee d3 	mova	&54254,	r12	;0x0d3ee
    94e0:	9c 00 00 00 	cmpa	#0,	r12	;
    94e4:	04 24       	jz	$+10     	;abs 0x94ee

000094e6 <.Loc.128.1>:
    94e6:	00 18 c2 9c 	cmpx.a	r12,	&0xfd34e;
    94ea:	4e d3 
    94ec:	03 2c       	jc	$+8      	;abs 0x94f4

000094ee <.L58>:
    elyNLFreeBufferChecked(buffer);
    94ee:	cc 0a       	mova	r10,	r12	;
    94f0:	b0 13 34 9b 	calla	#39732		;0x09b34

000094f4 <.L59>:
  tx_read_ptr = buffer;
    94f4:	60 0a ea d3 	mova	r10,	&54250	; 0x0d3ea

000094f8 <.Loc.133.1>:
  tx_active_buffer = buffer;
    94f8:	60 0a f2 d3 	mova	r10,	&54258	; 0x0d3f2

000094fc <.Loc.134.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    94fc:	41 18 e2 43 	movx.b	#2,	&0x1051c;r3 As==10
    9500:	1c 05 

00009502 <.Loc.136.1>:
  calc_next_buff();
    9502:	b0 13 7e 93 	calla	#37758		;0x0937e

00009506 <.LBB30>:
  _disable_interrupts();
    9506:	32 c2       	dint			
    9508:	03 43       	nop			

0000950a <.Loc.348.2>:
  asm volatile("nop");
    950a:	03 43       	nop			

0000950c <.LBE30>:
  chSysLock();
    950c:	b0 13 50 45 	calla	#17744		;0x04550

00009510 <.LVL41>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    9510:	2e 00 e2 d3 	mova	&54242,	r14	;0x0d3e2
    9514:	2d 00 e6 d3 	mova	&54246,	r13	;0x0d3e6
    9518:	cc 08       	mova	r8,	r12	;
    951a:	b0 13 3c 52 	calla	#21052		;0x0523c

0000951e <.LVL42>:
  tx_n -= next_cnt;
    951e:	2c 00 ee d3 	mova	&54254,	r12	;0x0d3ee
    9522:	00 18 5c 82 	subx.a	&0x0d3e6,r12	;
    9526:	e6 d3 
    9528:	60 0c ee d3 	mova	r12,	&54254	; 0x0d3ee

0000952c <.Loc.143.1>:
  if (tx_n == 0) {
    952c:	9c 00 00 00 	cmpa	#0,	r12	;
    9530:	0b 24       	jz	$+24     	;abs 0x9548

00009532 <.Loc.151.1>:
  calc_next_buff();
    9532:	b0 13 7e 93 	calla	#37758		;0x0937e

00009536 <.LVL43>:
  chSysUnlock();
    9536:	b0 13 70 45 	calla	#17776		;0x04570

0000953a <.LBB32>:
  asm volatile("nop");
    953a:	03 43       	nop			

0000953c <.Loc.356.2>:
  _enable_interrupts();
    953c:	03 43       	nop			
    953e:	32 d2       	eint			
    9540:	03 43       	nop			

00009542 <.L55>:
}
    9542:	08 16       	popm.a	#1,	r8	;20-bit words
    9544:	0a 16       	popm.a	#1,	r10	;20-bit words
    9546:	10 01       	reta			;

00009548 <.L62>:
    elyNLFreeBufferCheckedI(tx_active_buffer);
    9548:	2c 00 f2 d3 	mova	&54258,	r12	;0x0d3f2
    954c:	b0 13 54 9b 	calla	#39764		;0x09b54

00009550 <.LVL45>:
    next_tx_ptr = &END;
    9550:	80 18 f2 40 	movx.a	#66659,	&0xfd3e2;0x10463
    9554:	63 04 e2 d3 

00009558 <.Loc.146.1>:
    next_cnt = 1;
    9558:	00 18 d2 43 	movx.a	#1,	&0xfd3e6;r3 As==01
    955c:	e6 d3 

0000955e <.Loc.147.1>:
    chSysUnlock();
    955e:	b0 13 70 45 	calla	#17776		;0x04570

00009562 <.LBB34>:
  asm volatile("nop");
    9562:	03 43       	nop			

00009564 <.Loc.356.2>:
  _enable_interrupts();
    9564:	03 43       	nop			
    9566:	32 d2       	eint			
    9568:	03 43       	nop			
    956a:	80 00 42 95 	mova	#38210,	r0	;0x09542

0000956e <elyUARTDLLRxInit>:
  uart_thd = chThdGetSelfX();
    956e:	80 18 d2 42 	movx.a	&0x1051e,&0xfd3de;
    9572:	1e 05 de d3 

00009576 <.Loc.160.1>:
}
    9576:	10 01       	reta			;

00009578 <elyUARTDLLRxHandleBuffer>:

void elyUARTDLLRxHandleBuffer() {
    9578:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000957a <.LCFI7>:
  handle_buffer(bytes_available, dbuf_get_read(&rx_buf));
    957a:	2a 00 f6 d3 	mova	&54262,	r10	;0x0d3f6
    957e:	8c 00 00 d4 	mova	#54272,	r12	;0x0d400
    9582:	b0 13 a2 91 	calla	#37282		;0x091a2

00009586 <.LVL48>:
    9586:	cd 0c       	mova	r12,	r13	;
    9588:	cc 0a       	mova	r10,	r12	;
    958a:	b0 13 d0 91 	calla	#37328		;0x091d0

0000958e <.LVL49>:
}
    958e:	0a 16       	popm.a	#1,	r10	;20-bit words
    9590:	10 01       	reta			;

00009592 <elyUARTDLLTimeoutCB>:

/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
    9592:	b0 13 92 45 	calla	#17810		;0x04592

00009596 <.LVL51>:
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    9596:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    959a:	b0 13 fc 52 	calla	#21244		;0x052fc

0000959e <.LVL52>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    959e:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    95a2:	fd 0c       	suba	r12,	r13	;
    95a4:	60 0d f6 d3 	mova	r13,	&54262	; 0x0d3f6

000095a8 <.Loc.285.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    95a8:	6d 42       	mov.b	#4,	r13	;r2 As==10
    95aa:	4e 43       	clr.b	r14		;
    95ac:	2c 00 de d3 	mova	&54238,	r12	;0x0d3de

000095b0 <.LVL53>:
    95b0:	b0 13 da 4a 	calla	#19162		;0x04ada

000095b4 <.LVL54>:
  chSysUnlockFromISR();
    95b4:	b0 13 b4 45 	calla	#17844		;0x045b4

000095b8 <.LVL55>:

}
    95b8:	10 01       	reta			;

000095ba <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    95ba:	2a 14       	pushm.a	#3,	r10	;20-bit words

000095bc <.LCFI8>:
    95bc:	c8 0c       	mova	r12,	r8	;
    95be:	09 4d       	mov	r13,	r9	;

000095c0 <.Loc.291.1>:
  chDbgAssert(c < 0x100, "invalid char");
    95c0:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff

000095c4 <.LVL57>:
    95c4:	0c 9d       	cmp	r13,	r12	;
    95c6:	1f 28       	jnc	$+64     	;abs 0x9606

000095c8 <.L67>:
  dbuf_init(&rx_buf);
    95c8:	8a 00 00 d4 	mova	#54272,	r10	;0x0d400
    95cc:	cc 0a       	mova	r10,	r12	;
    95ce:	b0 13 c6 91 	calla	#37318		;0x091c6

000095d2 <.LVL59>:
  
  uint8_t * buf = dbuf_get_write(&rx_buf);
    95d2:	cc 0a       	mova	r10,	r12	;
    95d4:	b0 13 7e 91 	calla	#37246		;0x0917e

000095d8 <.LVL60>:
    95d8:	ca 0c       	mova	r12,	r10	;

000095da <.LVL61>:
  buf[0] = (uint8_t)(c);
    95da:	cc 49 00 00 	mov.b	r9,	0(r12)	;

000095de <.Loc.296.1>:
  chSysLockFromISR();
    95de:	b0 13 92 45 	calla	#17810		;0x04592

000095e2 <.LVL62>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, buf+1);
    95e2:	ce 0a       	mova	r10,	r14	;
    95e4:	ae 00 01 00 	adda	#1,	r14	;
    95e8:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    95ec:	cc 08       	mova	r8,	r12	;
    95ee:	b0 13 9c 52 	calla	#21148		;0x0529c

000095f2 <.LVL63>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    95f2:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    95f6:	8c 01 52 06 	mova	#67154,	r12	;0x10652
    95fa:	b0 13 1e 51 	calla	#20766		;0x0511e

000095fe <.LVL64>:
  
  
  chSysUnlockFromISR();
    95fe:	b0 13 b4 45 	calla	#17844		;0x045b4

00009602 <.LVL65>:
}
    9602:	28 16       	popm.a	#3,	r10	;20-bit words
    9604:	10 01       	reta			;

00009606 <.L68>:
  chDbgAssert(c < 0x100, "invalid char");
    9606:	8c 01 42 04 	mova	#66626,	r12	;0x10442
    960a:	b0 13 a0 47 	calla	#18336		;0x047a0

0000960e <.LVL67>:
    960e:	80 00 c8 95 	mova	#38344,	r0	;0x095c8

00009612 <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    9612:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009614 <.LCFI9>:
    9614:	08 14       	pushm.a	#1,	r8	;20-bit words

00009616 <.LCFI10>:
    9616:	c8 0c       	mova	r12,	r8	;

00009618 <.Loc.306.1>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
    9618:	b0 13 92 45 	calla	#17810		;0x04592

0000961c <.LVL69>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, dbuf_get_write(&rx_buf)); 
    961c:	8c 00 00 d4 	mova	#54272,	r12	;0x0d400
    9620:	b0 13 7e 91 	calla	#37246		;0x0917e

00009624 <.LVL70>:
    9624:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    9628:	ce 0c       	mova	r12,	r14	;
    962a:	cd 0a       	mova	r10,	r13	;
    962c:	cc 08       	mova	r8,	r12	;
    962e:	b0 13 9c 52 	calla	#21148		;0x0529c

00009632 <.LVL71>:
  gptStopTimerI(&uart_gpt);
    9632:	88 01 52 06 	mova	#67154,	r8	;0x10652

00009636 <.LVL72>:
    9636:	cc 08       	mova	r8,	r12	;
    9638:	b0 13 70 51 	calla	#20848		;0x05170

0000963c <.LVL73>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    963c:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9640:	cc 08       	mova	r8,	r12	;
    9642:	b0 13 1e 51 	calla	#20766		;0x0511e

00009646 <.LVL74>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    9646:	60 0a f6 d3 	mova	r10,	&54262	; 0x0d3f6

0000964a <.Loc.313.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    964a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    964c:	4e 43       	clr.b	r14		;
    964e:	2c 00 de d3 	mova	&54238,	r12	;0x0d3de
    9652:	b0 13 da 4a 	calla	#19162		;0x04ada

00009656 <.LVL75>:
  
  chSysUnlockFromISR();
    9656:	b0 13 b4 45 	calla	#17844		;0x045b4

0000965a <.LVL76>:
}
    965a:	08 16       	popm.a	#1,	r8	;20-bit words
    965c:	0a 16       	popm.a	#1,	r10	;20-bit words
    965e:	10 01       	reta			;

00009660 <elyFramPostRequestS>:
  /* ENH remove this hack - should be at PointOfCall */
  (*reqp)->special = 0;
  return r;
}

void elyFramPostRequestS(fram_req_t * req) {
    9660:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009662 <.LCFI1>:
    9662:	ca 0c       	mova	r12,	r10	;

00009664 <.Loc.23.1>:
  /* WARNING this is an abominable hack! */
  OSAL_IRQ_PROLOGUE();
    9664:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    9668:	6c 05 
    966a:	b0 13 d6 45 	calla	#17878		;0x045d6

0000966e <.LVL7>:
  chSysLockFromISR();
    966e:	b0 13 92 45 	calla	#17810		;0x04592

00009672 <.LVL8>:
    req->callback(req->buffer);
    9672:	3c 0a 08 00 	mova	8(r10),	r12	;
    9676:	3d 0a 0c 00 	mova	12(r10),r13	;0x0000c
    967a:	4d 13       	calla	r13		;

0000967c <.Loc.26.1>:
    elyQueueFreeBufferI(&fram_queue, (uint8_t *)(req));
    967c:	cd 0a       	mova	r10,	r13	;
    967e:	8c 00 02 b3 	mova	#45826,	r12	;0x0b302
    9682:	b0 13 c8 97 	calla	#38856		;0x097c8

00009686 <.LVL10>:
  chSysUnlockFromISR();
    9686:	b0 13 b4 45 	calla	#17844		;0x045b4

0000968a <.LVL11>:
  OSAL_IRQ_EPILOGUE();
    968a:	b0 13 fc 45 	calla	#17916		;0x045fc

0000968e <.LVL12>:
    968e:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    9692:	6c 05 
    9694:	b0 13 50 45 	calla	#17744		;0x04550

00009698 <.LVL13>:
    9698:	b0 13 04 49 	calla	#18692		;0x04904

0000969c <.LVL14>:
    969c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    969e:	04 20       	jnz	$+10     	;abs 0x96a8

000096a0 <.L5>:
    96a0:	b0 13 70 45 	calla	#17776		;0x04570

000096a4 <.LVL15>:
}
    96a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    96a6:	10 01       	reta			;

000096a8 <.L6>:
  OSAL_IRQ_EPILOGUE();
    96a8:	b0 13 1c 49 	calla	#18716		;0x0491c

000096ac <.LVL16>:
    96ac:	80 00 a0 96 	mova	#38560,	r0	;0x096a0

000096b0 <elyFramGetRequestTimeoutS>:
    elyQueueFreeBufferI(&fram_queue, (uint8_t *)(req));
  chSysUnlockFromISR();
  OSAL_IRQ_EPILOGUE();
}

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    96b0:	1a 14       	pushm.a	#2,	r10	;20-bit words

000096b2 <.LCFI3>:
    96b2:	ca 0c       	mova	r12,	r10	;
    96b4:	09 4d       	mov	r13,	r9	;

000096b6 <.Loc.42.1>:
  if (!elyIsQueueInitialized(&fram_queue)) {
    96b6:	8c 00 02 b3 	mova	#45826,	r12	;0x0b302

000096ba <.LVL29>:
    96ba:	b0 13 66 97 	calla	#38758		;0x09766

000096be <.LVL30>:
    96be:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    96c0:	0b 24       	jz	$+24     	;abs 0x96d8

000096c2 <.L11>:
    elyQueueObjectInit(&fram_queue, sizeof(fram_req_t), (uint8_t *)(fram_queue_storage));
  }
  
  msg_t r = elyQueueGetEmptyBufferTimeoutS(&fram_queue, (uint8_t **)reqp, timeout);
    96c2:	0e 49       	mov	r9,	r14	;
    96c4:	cd 0a       	mova	r10,	r13	;
    96c6:	8c 00 02 b3 	mova	#45826,	r12	;0x0b302
    96ca:	b0 13 a2 97 	calla	#38818		;0x097a2

000096ce <.LVL31>:
  (*reqp)->special = 0;
    96ce:	0e 0a       	mova	@r10,	r14	;
    96d0:	de c3 04 00 	bic.b	#1,	4(r14)	;r3 As==01

000096d4 <.Loc.49.1>:
  return r;
}
    96d4:	19 16       	popm.a	#2,	r10	;20-bit words
    96d6:	10 01       	reta			;

000096d8 <.L12>:
    elyQueueObjectInit(&fram_queue, sizeof(fram_req_t), (uint8_t *)(fram_queue_storage));
    96d8:	8e 00 ba b2 	mova	#45754,	r14	;0x0b2ba
    96dc:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    96e0:	8c 00 02 b3 	mova	#45826,	r12	;0x0b302
    96e4:	b0 13 7a 97 	calla	#38778		;0x0977a

000096e8 <.LVL33>:
    96e8:	80 00 c2 96 	mova	#38594,	r0	;0x096c2

000096ec <elyChanSubscribe>:

void elyChanSubscribe(uint8_t * buffer, uint8_t length, uint32_t interval) {
  (void)(buffer);
  (void)(length);
  (void)(interval);
}
    96ec:	10 01       	reta			;

000096ee <elyChanUnsubscribe>:

void elyChanUnsubscribe(uint8_t * buffer, uint8_t length) {
  (void)(buffer);
  (void)(length);
}
    96ee:	10 01       	reta			;

000096f0 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
  (void)(buffer);
  (void)(length);
  (void)(interval);
}
    96f0:	10 01       	reta			;

000096f2 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
  (void)(buffer);
  (void)(length);
}
    96f2:	10 01       	reta			;

000096f4 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer, uint8_t id) {
  (void)(buffer);
  (void)(id);
  return 4;
}
    96f4:	6c 42       	mov.b	#4,	r12	;r2 As==10

000096f6 <.LVL5>:
    96f6:	10 01       	reta			;

000096f8 <elyChanReset>:

void elyChanReset() {
}
    96f8:	10 01       	reta			;

000096fa <elyErrorSignal>:
#include "errors.h"
#include "registers.h"

void elyErrorSignal(uint8_t error) {
  (void)(error);
}
    96fa:	10 01       	reta			;

000096fc <elyErrorSetRptLvlS>:
  (void)(error);
}

void elyErrorSetRptLvlS(uint8_t lvl) {
  (void)(lvl);
}
    96fc:	10 01       	reta			;

000096fe <elyErrorSetLogLvlS>:

void elyErrorSetLogLvlS(uint8_t lvl) {
  (void)(lvl);
}
    96fe:	10 01       	reta			;

00009700 <elyEventSignal>:
#include "events.h"
#include "registers.h"

void elyEventSignal(uint8_t event) {
  (void)(event);
}
    9700:	10 01       	reta			;

00009702 <elyEventSubscribe>:
}

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(event);
  (void)(addr);
}
    9702:	10 01       	reta			;

00009704 <elyEventUnsubscribe>:

void elyEventUnsubscribe(uint8_t event) {
  (void)(event);
}
    9704:	10 01       	reta			;

00009706 <elyEventLog>:

void elyEventLog(uint8_t event) {
  (void)(event);
}
    9706:	10 01       	reta			;

00009708 <elyEventUnlog>:

void elyEventUnlog(uint8_t event) {
  (void)(event);
}
    9708:	10 01       	reta			;

0000970a <elyEventReset>:

void elyEventReset() {
}
    970a:	10 01       	reta			;

0000970c <elyRFPostI>:

#include "rf.h"

msg_t elyRFPostI(uint8_t * buffer) {
  return elyUARTPostI(buffer);
    970c:	b0 13 c0 5e 	calla	#24256		;0x05ec0

00009710 <.LVL1>:
}
    9710:	10 01       	reta			;

00009712 <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
  return elyUARTPost(buffer, timeout);
    9712:	b0 13 f2 5e 	calla	#24306		;0x05ef2

00009716 <.LVL3>:
}
    9716:	10 01       	reta			;

00009718 <elyRFCfgMarkDirty>:
  (void)(event);
}

void elyRFCfgMarkDirty(rf_events_t event) {
  (void)(event);
}
    9718:	10 01       	reta			;

0000971a <elyRFDLLClampReg>:
#include "core.h"

uint8_t elyRFDLLClampReg(uint8_t addr, uint8_t value) {
  (void)(addr);
  return value;
}
    971a:	4c 4d       	mov.b	r13,	r12	;

0000971c <.LVL1>:
    971c:	10 01       	reta			;

0000971e <elyTelemUpdateConfigS>:

#include "telem.h"

void elyTelemUpdateConfigS(telem_cfg_t config) {
  (void)(config);
}
    971e:	10 01       	reta			;

00009720 <elyTelemPostBufferS>:

void elyTelemPostBufferS(uint8_t * buffer, telemcallback_t cb) {
    9720:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009722 <.LCFI0>:
    9722:	08 14       	pushm.a	#1,	r8	;20-bit words

00009724 <.LCFI1>:
    9724:	c8 0c       	mova	r12,	r8	;
    9726:	ca 0d       	mova	r13,	r10	;

00009728 <.Loc.10.1>:
  /* WARNING this is an abominable hack! */
  OSAL_IRQ_PROLOGUE();
    9728:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    972c:	6c 05 
    972e:	b0 13 d6 45 	calla	#17878		;0x045d6

00009732 <.LVL1>:
  chSysLockFromISR();
    9732:	b0 13 92 45 	calla	#17810		;0x04592

00009736 <.LVL2>:
  cb(buffer);
    9736:	cc 08       	mova	r8,	r12	;
    9738:	4a 13       	calla	r10		;

0000973a <.LVL3>:
  chSysUnlockFromISR();
    973a:	b0 13 b4 45 	calla	#17844		;0x045b4

0000973e <.LVL4>:
  OSAL_IRQ_EPILOGUE();
    973e:	b0 13 fc 45 	calla	#17916		;0x045fc

00009742 <.LVL5>:
    9742:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    9746:	6c 05 
    9748:	b0 13 50 45 	calla	#17744		;0x04550

0000974c <.LVL6>:
    974c:	b0 13 04 49 	calla	#18692		;0x04904

00009750 <.LVL7>:
    9750:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9752:	05 20       	jnz	$+12     	;abs 0x975e

00009754 <.L3>:
    9754:	b0 13 70 45 	calla	#17776		;0x04570

00009758 <.LVL8>:
}
    9758:	08 16       	popm.a	#1,	r8	;20-bit words
    975a:	0a 16       	popm.a	#1,	r10	;20-bit words
    975c:	10 01       	reta			;

0000975e <.L4>:
  OSAL_IRQ_EPILOGUE();
    975e:	b0 13 1c 49 	calla	#18716		;0x0491c

00009762 <.LVL9>:
    9762:	80 00 54 97 	mova	#38740,	r0	;0x09754

00009766 <elyIsQueueInitialized>:
#include "queues.h"

bool elyIsQueueInitialized( queue_t * queue ) {
  return (queue->mpool.pool.object_size != 0);
    9766:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9768:	00 18 cc 93 	cmpx.a	#0,	30(r12)	;r3 As==00, 0x0001e
    976c:	1e 00 
    976e:	02 24       	jz	$+6      	;abs 0x9774

00009770 <.L2>:
}
    9770:	4c 4d       	mov.b	r13,	r12	;

00009772 <.LVL1>:
    9772:	10 01       	reta			;

00009774 <.L3>:
  return (queue->mpool.pool.object_size != 0);
    9774:	4d 43       	clr.b	r13		;
    9776:	80 00 70 97 	mova	#38768,	r0	;0x09770

0000977a <elyQueueObjectInit>:

void elyQueueObjectInit( queue_t * queue, size_t buf_size, uint8_t * mpool_storage ) {
    977a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000977c <.LCFI0>:
    977c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000977e <.LCFI1>:
    977e:	06 14       	pushm.a	#1,	r6	;20-bit words

00009780 <.LCFI2>:
    9780:	c8 0c       	mova	r12,	r8	;
    9782:	c6 0e       	mova	r14,	r6	;

00009784 <.Loc.8.1>:
  chGuardedPoolObjectInit(&(queue->mpool), buf_size);
    9784:	ca 0c       	mova	r12,	r10	;
    9786:	aa 00 18 00 	adda	#24,	r10	;0x00018
    978a:	cc 0a       	mova	r10,	r12	;

0000978c <.LVL4>:
    978c:	b0 13 42 4f 	calla	#20290		;0x04f42

00009790 <.LVL5>:
  chGuardedPoolLoadArray(&(queue->mpool), mpool_storage, queue->queue_len);
    9790:	0e 08       	mova	@r8,	r14	;
    9792:	cd 06       	mova	r6,	r13	;
    9794:	cc 0a       	mova	r10,	r12	;
    9796:	b0 13 c0 4f 	calla	#20416		;0x04fc0

0000979a <.LVL6>:
}
    979a:	06 16       	popm.a	#1,	r6	;20-bit words
    979c:	08 16       	popm.a	#1,	r8	;20-bit words
    979e:	0a 16       	popm.a	#1,	r10	;20-bit words
    97a0:	10 01       	reta			;

000097a2 <elyQueueGetEmptyBufferTimeoutS>:
  chDbgCheck(queue != NULL);
  
  return chMBPostAheadI(&(queue->mbox), (msg_t)(buffer));
}

msg_t elyQueueGetEmptyBufferTimeoutS(queue_t * queue, uint8_t ** bufferp, systime_t timeout) {
    97a2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000097a4 <.LCFI9>:
    97a4:	ca 0d       	mova	r13,	r10	;

000097a6 <.Loc.41.1>:
  void * result = chGuardedPoolAllocTimeoutS(&(queue->mpool), timeout);
    97a6:	0d 4e       	mov	r14,	r13	;

000097a8 <.LVL24>:
    97a8:	ac 00 18 00 	adda	#24,	r12	;0x00018

000097ac <.LVL25>:
    97ac:	b0 13 58 4f 	calla	#20312		;0x04f58

000097b0 <.LVL26>:
  if (result == NULL) {
    97b0:	9c 00 00 00 	cmpa	#0,	r12	;
    97b4:	05 24       	jz	$+12     	;abs 0x97c0

000097b6 <.Loc.46.1>:
    return MSG_TIMEOUT;
  }
  
  (*bufferp) = result;
    97b6:	7a 0c 00 00 	mova	r12,	0(r10)	;

000097ba <.Loc.47.1>:
  return MSG_OK;
    97ba:	4c 43       	clr.b	r12		;

000097bc <.L17>:
}
    97bc:	0a 16       	popm.a	#1,	r10	;20-bit words
    97be:	10 01       	reta			;

000097c0 <.L19>:
    return MSG_TIMEOUT;
    97c0:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000097c4 <.LVL29>:
    97c4:	80 00 bc 97 	mova	#38844,	r0	;0x097bc

000097c8 <elyQueueFreeBufferI>:
  chSysUnlock();
  return result;
}

void elyQueueFreeBufferI(queue_t * queue, uint8_t * buffer) {
  chGuardedPoolFreeI(&(queue->mpool), buffer);
    97c8:	ac 00 18 00 	adda	#24,	r12	;0x00018

000097cc <.LVL36>:
    97cc:	b0 13 7a 4f 	calla	#20346		;0x04f7a

000097d0 <.LVL37>:
}
    97d0:	10 01       	reta			;

000097d2 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    97d2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000097d4 <.LCFI0>:
    97d4:	08 14       	pushm.a	#1,	r8	;20-bit words

000097d6 <.LCFI1>:
    97d6:	c8 0c       	mova	r12,	r8	;
    97d8:	ca 0d       	mova	r13,	r10	;

000097da <.Loc.34.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    97da:	40 18 c2 93 	cmpx.b	#0,	&0xfd604;r3 As==00
    97de:	04 d6 
    97e0:	09 20       	jnz	$+20     	;abs 0x97f4

000097e2 <.L2>:
  /* X.25 CRC is LSB first in and out (CRCDI+CRCRESR), with an initial value
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
    97e2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    97e4:	dc 0a       	cmpa	r10,	r12	;
    97e6:	0c 2c       	jc	$+26     	;abs 0x9800

000097e8 <.L3>:
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    97e8:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    97ec:	54 01 

000097ee <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    97ee:	4c 43       	clr.b	r12		;
    97f0:	80 00 1a 98 	mova	#38938,	r0	;0x0981a

000097f4 <.L6>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    97f4:	8c 01 a7 04 	mova	#66727,	r12	;0x104a7
    97f8:	b0 13 a0 47 	calla	#18336		;0x047a0

000097fc <.LVL4>:
    97fc:	80 00 e2 97 	mova	#38882,	r0	;0x097e2

00009800 <.L7>:
  chDbgAssert(n >= 2, "message too small to CRC");
    9800:	8c 01 a7 04 	mova	#66727,	r12	;0x104a7
    9804:	b0 13 a0 47 	calla	#18336		;0x047a0

00009808 <.LVL5>:
    9808:	80 00 e8 97 	mova	#38888,	r0	;0x097e8

0000980c <.L5>:
      CRCDI_L = message[i];
    980c:	ce 08       	mova	r8,	r14	;
    980e:	ee 0c       	adda	r12,	r14	;
    9810:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    9814:	50 01 

00009816 <.Loc.51.1>:
    for (size_t i = 0; i < n-2; i++) {
    9816:	ac 00 01 00 	adda	#1,	r12	;

0000981a <.L4>:
    981a:	ce 0a       	mova	r10,	r14	;
    981c:	ae 0f fe ff 	adda	#1048574,r14	;0xffffe
    9820:	dc 0e       	cmpa	r14,	r12	;
    9822:	f4 2b       	jnc	$-22     	;abs 0x980c

00009824 <.LBE3>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    9824:	ee 08       	adda	r8,	r14	;
    9826:	40 18 5c 42 	movx.b	&0x00157,r12	;
    982a:	57 01 

0000982c <.LVL8>:
    982c:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    982e:	ce 4c 00 00 	mov.b	r12,	0(r14)	;

00009832 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    9832:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

00009836 <.LVL9>:
    9836:	ea 08       	adda	r8,	r10	;

00009838 <.LVL10>:
    9838:	40 18 5c 42 	movx.b	&0x00156,r12	;
    983c:	56 01 
    983e:	7c e3       	xor.b	#-1,	r12	;r3 As==11
    9840:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00009844 <.Loc.63.1>:
}
    9844:	08 16       	popm.a	#1,	r8	;20-bit words
    9846:	0a 16       	popm.a	#1,	r10	;20-bit words
    9848:	10 01       	reta			;

0000984a <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    984a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000984c <.LCFI2>:
    984c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000984e <.LCFI3>:
    984e:	ca 0c       	mova	r12,	r10	;
    9850:	c8 0d       	mova	r13,	r8	;

00009852 <.Loc.72.1>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9852:	40 18 c2 93 	cmpx.b	#0,	&0xfd604;r3 As==00
    9856:	04 d6 
    9858:	06 20       	jnz	$+14     	;abs 0x9866

0000985a <.L9>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    985a:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    985e:	54 01 

00009860 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9860:	4c 43       	clr.b	r12		;
    9862:	80 00 80 98 	mova	#39040,	r0	;0x09880

00009866 <.L13>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    9866:	8c 01 9b 04 	mova	#66715,	r12	;0x1049b
    986a:	b0 13 a0 47 	calla	#18336		;0x047a0

0000986e <.LVL15>:
    986e:	80 00 5a 98 	mova	#39002,	r0	;0x0985a

00009872 <.L11>:
      CRCDI_L = message[i];
    9872:	ce 0a       	mova	r10,	r14	;
    9874:	ee 0c       	adda	r12,	r14	;
    9876:	40 18 e2 4e 	movx.b	@r14,	&0x00150;
    987a:	50 01 

0000987c <.Loc.85.1>:
    for (size_t i = 0; i < n-2; i++) {
    987c:	ac 00 01 00 	adda	#1,	r12	;

00009880 <.L10>:
    9880:	ce 08       	mova	r8,	r14	;
    9882:	ae 0f fe ff 	adda	#1048574,r14	;0xffffe
    9886:	dc 0e       	cmpa	r14,	r12	;
    9888:	f4 2b       	jnc	$-22     	;abs 0x9872

0000988a <.LBE5>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    988a:	40 18 1f 42 	movx.w	&0x00156,r15	;
    988e:	56 01 
    9890:	3f e3       	inv	r15		;
    9892:	ee 0a       	adda	r10,	r14	;
    9894:	6d 4e       	mov.b	@r14,	r13	;
    9896:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    989a:	ea 08       	adda	r8,	r10	;

0000989c <.LVL18>:
    989c:	5a 4a ff ff 	mov.b	-1(r10),r10	;
    98a0:	0d da       	bis	r10,	r13	;
    98a2:	5c 43       	mov.b	#1,	r12	;r3 As==01

000098a4 <.LVL19>:
    98a4:	0f 9d       	cmp	r13,	r15	;
    98a6:	01 24       	jz	$+4      	;abs 0x98aa
    98a8:	4c 43       	clr.b	r12		;

000098aa <.L12>:
}
    98aa:	08 16       	popm.a	#1,	r8	;20-bit words
    98ac:	0a 16       	popm.a	#1,	r10	;20-bit words
    98ae:	10 01       	reta			;

000098b0 <crcStart>:
/** @brief    Sets up to generate the CRC of a large message according to X.25 rules
 * 
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    98b0:	40 18 c2 93 	cmpx.b	#0,	&0xfd604;r3 As==00
    98b4:	04 d6 
    98b6:	09 20       	jnz	$+20     	;abs 0x98ca

000098b8 <.L15>:
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    98b8:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    98bc:	54 01 

000098be <.Loc.108.1>:
   
  /* Change state */
  crc_state = CRC_RUNNING;
    98be:	40 18 d2 43 	movx.b	#1,	&0xfd604;r3 As==01
    98c2:	04 d6 

000098c4 <.Loc.112.1>:
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    98c4:	8c 00 50 01 	mova	#336,	r12	;0x00150
    98c8:	10 01       	reta			;

000098ca <.L16>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
    98ca:	8c 01 92 04 	mova	#66706,	r12	;0x10492
    98ce:	b0 13 a0 47 	calla	#18336		;0x047a0

000098d2 <.LVL20>:
    98d2:	80 00 b8 98 	mova	#39096,	r0	;0x098b8

000098d6 <crcStop>:
/** @brief    Returns the CRC of a large message according to X.25 rules
 * 
 * @return    The CRC of the large message
 */
uint16_t crcStop() {
  chDbgAssert(crc_state == CRC_RUNNING, "invalid call order");
    98d6:	40 18 d2 93 	cmpx.b	#1,	&0xfd604;r3 As==01
    98da:	04 d6 
    98dc:	04 24       	jz	$+10     	;abs 0x98e6

000098de <.Loc.119.1>:
    98de:	8c 01 8a 04 	mova	#66698,	r12	;0x1048a
    98e2:	b0 13 a0 47 	calla	#18336		;0x047a0

000098e6 <.L18>:
  /* Change state */
  crc_state = CRC_STOPPED;
    98e6:	40 18 c2 43 	movx.b	#0,	&0xfd604;r3 As==00
    98ea:	04 d6 

000098ec <.Loc.125.1>:
  
  /* Return the result */
  return ~CRCRESR;
}
    98ec:	40 18 1c 42 	movx.w	&0x00156,r12	;
    98f0:	56 01 
    98f2:	3c e3       	inv	r12		;
    98f4:	10 01       	reta			;

000098f6 <nl_allocator>:
uint8_t PERSIST packets_received;
uint16_t PERSIST packets_sent = 1;
uint8_t PERSIST packets_relayed;
static size_t sh_len;

void * nl_allocator(size_t size, unsigned align) {
    98f6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000098f8 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    98f8:	2e 00 44 b3 	mova	&45892,	r14	;0x0b344
    98fc:	ca 0e       	mova	r14,	r10	;
    98fe:	ea 0c       	adda	r12,	r10	;
    9900:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

00009904 <.LVL1>:
    9904:	dc 0a       	cmpa	r10,	r12	;
    9906:	07 28       	jnc	$+16     	;abs 0x9916

00009908 <.Loc.26.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    9908:	cc 0e       	mova	r14,	r12	;
    990a:	ac 00 4d b3 	adda	#45901,	r12	;0x0b34d

0000990e <.LVL2>:
  
  curr_index += size;
    990e:	60 0a 44 b3 	mova	r10,	&45892	; 0x0b344

00009912 <.L1>:
  return result;
}
    9912:	0a 16       	popm.a	#1,	r10	;20-bit words
    9914:	10 01       	reta			;

00009916 <.L3>:
    return NULL;
    9916:	4c 43       	clr.b	r12		;
    9918:	80 00 12 99 	mova	#39186,	r0	;0x09912

0000991c <clamp>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    991c:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000991e <.LCFI1>:
    991e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9922:	4a 4d       	mov.b	r13,	r10	;
    9924:	49 4e       	mov.b	r14,	r9	;

00009926 <.Loc.35.1>:
  if (value < min) {
    9926:	4c 9a       	cmp.b	r10,	r12	;
    9928:	04 28       	jnc	$+10     	;abs 0x9932

0000992a <.Loc.39.1>:
    value = min;
    elyErrorSignal(ErrRegClip);
  }
  else if (value > max) {
    992a:	49 9c       	cmp.b	r12,	r9	;
    992c:	09 28       	jnc	$+20     	;abs 0x9940

0000992e <.L6>:
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    992e:	19 16       	popm.a	#2,	r10	;20-bit words
    9930:	10 01       	reta			;

00009932 <.L7>:
    elyErrorSignal(ErrRegClip);
    9932:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9936:	b0 13 fa 96 	calla	#38650		;0x096fa

0000993a <.LVL7>:
    value = min;
    993a:	0c 4a       	mov	r10,	r12	;
    993c:	80 00 2e 99 	mova	#39214,	r0	;0x0992e

00009940 <.L8>:
    elyErrorSignal(ErrRegClip);
    9940:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9944:	b0 13 fa 96 	calla	#38650		;0x096fa

00009948 <.LVL9>:
    value = max;
    9948:	0c 49       	mov	r9,	r12	;
    994a:	80 00 2e 99 	mova	#39214,	r0	;0x0992e

0000994e <clamp_err>:

static uint8_t clamp_err(uint8_t value) {
    994e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009952 <.Loc.47.1>:
  if ((value & 0x10) && value != 0x10) {
    9952:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    9956:	10 00 
    9958:	0a 24       	jz	$+22     	;abs 0x996e

0000995a <.Loc.47.1>:
    995a:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    995e:	07 24       	jz	$+16     	;abs 0x996e

00009960 <.Loc.48.1>:
    elyErrorSignal(ErrRegClip);
    9960:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009964 <.LVL11>:
    9964:	b0 13 fa 96 	calla	#38650		;0x096fa

00009968 <.LVL12>:
    return 0x10;
    9968:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000996c <.L11>:
  if (value & 0xD0) {
    elyErrorSignal(ErrRegClip);
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}
    996c:	10 01       	reta			;

0000996e <.L10>:
  if ((value & 0x08) && value != 0x08) {
    996e:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    9972:	09 24       	jz	$+20     	;abs 0x9986

00009974 <.Loc.51.1>:
    9974:	3c 92       	cmp	#8,	r12	;r2 As==11
    9976:	07 24       	jz	$+16     	;abs 0x9986

00009978 <.Loc.52.1>:
    elyErrorSignal(ErrRegClip);
    9978:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    997c:	b0 13 fa 96 	calla	#38650		;0x096fa

00009980 <.LVL13>:
    return 0x08;
    9980:	7c 42       	mov.b	#8,	r12	;r2 As==11
    9982:	80 00 6c 99 	mova	#39276,	r0	;0x0996c

00009986 <.L12>:
  if ((value & 0x04) && value != 0x04) {
    9986:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    998a:	09 24       	jz	$+20     	;abs 0x999e

0000998c <.Loc.55.1>:
    998c:	2c 92       	cmp	#4,	r12	;r2 As==10
    998e:	07 24       	jz	$+16     	;abs 0x999e

00009990 <.Loc.56.1>:
    elyErrorSignal(ErrRegClip);
    9990:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9994:	b0 13 fa 96 	calla	#38650		;0x096fa

00009998 <.LVL14>:
    return 0x04;
    9998:	6c 42       	mov.b	#4,	r12	;r2 As==10
    999a:	80 00 6c 99 	mova	#39276,	r0	;0x0996c

0000999e <.L13>:
  if ((value & 0x02) && value != 0x02) {
    999e:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    99a2:	09 24       	jz	$+20     	;abs 0x99b6

000099a4 <.Loc.59.1>:
    99a4:	2c 93       	cmp	#2,	r12	;r3 As==10
    99a6:	07 24       	jz	$+16     	;abs 0x99b6

000099a8 <.Loc.60.1>:
    elyErrorSignal(ErrRegClip);
    99a8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    99ac:	b0 13 fa 96 	calla	#38650		;0x096fa

000099b0 <.LVL15>:
    return 0x02;
    99b0:	6c 43       	mov.b	#2,	r12	;r3 As==10
    99b2:	80 00 6c 99 	mova	#39276,	r0	;0x0996c

000099b6 <.L14>:
  if ((value & 0x01) && value != 0x01) {
    99b6:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    99ba:	02 24       	jz	$+6      	;abs 0x99c0

000099bc <.Loc.63.1>:
    99bc:	1c 93       	cmp	#1,	r12	;r3 As==01
    99be:	0a 20       	jnz	$+22     	;abs 0x99d4

000099c0 <.L15>:
  if (value & 0xD0) {
    99c0:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    99c4:	d3 27       	jz	$-88     	;abs 0x996c

000099c6 <.Loc.68.1>:
    elyErrorSignal(ErrRegClip);
    99c6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    99ca:	b0 13 fa 96 	calla	#38650		;0x096fa

000099ce <.LVL16>:
    return 0x00;
    99ce:	4c 43       	clr.b	r12		;
    99d0:	80 00 6c 99 	mova	#39276,	r0	;0x0996c

000099d4 <.L16>:
    elyErrorSignal(ErrRegClip);
    99d4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    99d8:	b0 13 fa 96 	calla	#38650		;0x096fa

000099dc <.LVL17>:
    return 0x01;
    99dc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    99de:	80 00 6c 99 	mova	#39276,	r0	;0x0996c

000099e2 <uart_pass>:
  
  return;
}

static inline msg_t uart_pass(uint8_t * buffer) {
  return elyUARTPost(buffer, TIME_INFINITE);
    99e2:	4d 43       	clr.b	r13		;
    99e4:	b0 13 f2 5e 	calla	#24306		;0x05ef2

000099e8 <.LVL19>:
}
    99e8:	10 01       	reta			;

000099ea <fw>:
static inline msg_t uart_pass_i(uint8_t * buffer) {
  return elyUARTPostI(buffer);
}

static inline msg_t fw(uint8_t * buffer) {
  return elyMainMBPost(buffer, TIME_INFINITE);
    99ea:	4d 43       	clr.b	r13		;
    99ec:	b0 13 42 64 	calla	#25666		;0x06442

000099f0 <.LVL21>:
}
    99f0:	10 01       	reta			;

000099f2 <rf_pass>:
  return elyRFPost(buffer, TIME_INFINITE);
    99f2:	4d 43       	clr.b	r13		;
    99f4:	b0 13 12 97 	calla	#38674		;0x09712

000099f8 <.LVL23>:
}
    99f8:	10 01       	reta			;

000099fa <elyNLClampReg>:
uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    99fa:	1a 14       	pushm.a	#2,	r10	;20-bit words

000099fc <.LCFI2>:
    99fc:	4a 4c       	mov.b	r12,	r10	;
    99fe:	49 4d       	mov.b	r13,	r9	;

00009a00 <.Loc.75.1>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    9a00:	4c 4a       	mov.b	r10,	r12	;

00009a02 <.LVL31>:
    9a02:	7c 50 80 ff 	add.b	#-128,	r12	;#0xff80
    9a06:	7d 40 09 00 	mov.b	#9,	r13	;

00009a0a <.LVL32>:
    9a0a:	4d 9c       	cmp.b	r12,	r13	;
    9a0c:	16 28       	jnc	$+46     	;abs 0x9a3a

00009a0e <.L24>:
  switch(addr) {
    9a0e:	7a 90 83 ff 	cmp.b	#-125,	r10	;#0xff83
    9a12:	34 24       	jz	$+106    	;abs 0x9a7c
    9a14:	7c 40 83 ff 	mov.b	#-125,	r12	;#0xff83
    9a18:	4c 9a       	cmp.b	r10,	r12	;
    9a1a:	15 28       	jnc	$+44     	;abs 0x9a46
    9a1c:	7a 90 80 ff 	cmp.b	#-128,	r10	;#0xff80
    9a20:	23 24       	jz	$+72     	;abs 0x9a68
    9a22:	7a 90 81 ff 	cmp.b	#-127,	r10	;#0xff81
    9a26:	27 20       	jnz	$+80     	;abs 0x9a76

00009a28 <.Loc.81.1>:
      value = clamp(value, 0, 0x10);
    9a28:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9a2c:	4d 43       	clr.b	r13		;
    9a2e:	4c 49       	mov.b	r9,	r12	;
    9a30:	b0 13 1c 99 	calla	#39196		;0x0991c

00009a34 <.LVL33>:
    9a34:	49 4c       	mov.b	r12,	r9	;

00009a36 <.LVL34>:
      break;
    9a36:	80 00 76 9a 	mova	#39542,	r0	;0x09a76

00009a3a <.L33>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
    9a3a:	8c 01 ba 04 	mova	#66746,	r12	;0x104ba
    9a3e:	b0 13 a0 47 	calla	#18336		;0x047a0

00009a42 <.LVL36>:
    9a42:	80 00 0e 9a 	mova	#39438,	r0	;0x09a0e

00009a46 <.L27>:
  switch(addr) {
    9a46:	7a 90 85 ff 	cmp.b	#-123,	r10	;#0xff85
    9a4a:	21 24       	jz	$+68     	;abs 0x9a8e
    9a4c:	7a 90 85 ff 	cmp.b	#-123,	r10	;#0xff85
    9a50:	12 28       	jnc	$+38     	;abs 0x9a76
    9a52:	7a 50 79 00 	add.b	#121,	r10	;#0x0079

00009a56 <.LVL37>:
    9a56:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9a58:	4d 9a       	cmp.b	r10,	r13	;
    9a5a:	0d 28       	jnc	$+28     	;abs 0x9a76

00009a5c <.Loc.91.1>:
      value = clamp_err(value);
    9a5c:	4c 49       	mov.b	r9,	r12	;
    9a5e:	b0 13 4e 99 	calla	#39246		;0x0994e

00009a62 <.LVL38>:
    9a62:	49 4c       	mov.b	r12,	r9	;

00009a64 <.LVL39>:
      break;
    9a64:	80 00 76 9a 	mova	#39542,	r0	;0x09a76

00009a68 <.L28>:
      value = clamp(value, 7, 0xFF);
    9a68:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9a6a:	7d 40 07 00 	mov.b	#7,	r13	;
    9a6e:	4c 49       	mov.b	r9,	r12	;
    9a70:	b0 13 1c 99 	calla	#39196		;0x0991c

00009a74 <.LVL41>:
    9a74:	49 4c       	mov.b	r12,	r9	;

00009a76 <.L25>:
}
    9a76:	4c 49       	mov.b	r9,	r12	;
    9a78:	19 16       	popm.a	#2,	r10	;20-bit words
    9a7a:	10 01       	reta			;

00009a7c <.L26>:
      value = clamp(value, 0, 0x07);
    9a7c:	7e 40 07 00 	mov.b	#7,	r14	;
    9a80:	4d 43       	clr.b	r13		;
    9a82:	4c 49       	mov.b	r9,	r12	;
    9a84:	b0 13 1c 99 	calla	#39196		;0x0991c

00009a88 <.LVL44>:
    9a88:	49 4c       	mov.b	r12,	r9	;

00009a8a <.LVL45>:
      break;
    9a8a:	80 00 76 9a 	mova	#39542,	r0	;0x09a76

00009a8e <.L30>:
      value = clamp(value, 0, 0x3F);
    9a8e:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    9a92:	4d 43       	clr.b	r13		;
    9a94:	4c 49       	mov.b	r9,	r12	;
    9a96:	b0 13 1c 99 	calla	#39196		;0x0991c

00009a9a <.LVL47>:
    9a9a:	49 4c       	mov.b	r12,	r9	;

00009a9c <.LVL48>:
      break;
    9a9c:	80 00 76 9a 	mova	#39542,	r0	;0x09a76

00009aa0 <elyNLGetBuffer>:
  return chPoolAlloc(&main_mpool);
    9aa0:	8c 00 38 b3 	mova	#45880,	r12	;0x0b338
    9aa4:	b0 13 ba 4e 	calla	#20154		;0x04eba

00009aa8 <.LVL56>:
}
    9aa8:	10 01       	reta			;

00009aaa <elyNLFreeBuffer>:
  chPoolFree(&main_mpool, buffer);
    9aaa:	cd 0c       	mova	r12,	r13	;
    9aac:	8c 00 38 b3 	mova	#45880,	r12	;0x0b338

00009ab0 <.LVL58>:
    9ab0:	b0 13 16 4f 	calla	#20246		;0x04f16

00009ab4 <.LVL59>:
}
    9ab4:	10 01       	reta			;

00009ab6 <elyNLFreeBufferI>:
void elyNLFreeBufferI(uint8_t * buffer) {
    9ab6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009ab8 <.LCFI5>:
    9ab8:	ca 0c       	mova	r12,	r10	;

00009aba <.Loc.128.1>:
  chDbgCheckClassI();
    9aba:	b0 13 24 46 	calla	#17956		;0x04624

00009abe <.LVL63>:
  chPoolFreeI(&main_mpool, buffer);
    9abe:	cd 0a       	mova	r10,	r13	;
    9ac0:	8c 00 38 b3 	mova	#45880,	r12	;0x0b338
    9ac4:	b0 13 e2 4e 	calla	#20194		;0x04ee2

00009ac8 <.LVL64>:
}
    9ac8:	0a 16       	popm.a	#1,	r10	;20-bit words
    9aca:	10 01       	reta			;

00009acc <elyNLGetDest>:

elysium_destinations_t elyNLGetDest(uint8_t * buffer, uint16_t dest_addr) {
  /* buffer ignored for SPP */
  (void)(buffer);
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
    9acc:	2e 01 3e 04 	mova	&66622,	r14	;0x1043e
    9ad0:	5c 4e 83 00 	mov.b	131(r14),r12	;0x00083

00009ad4 <.LVL66>:
    9ad4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    9ad8:	5e 4e 82 00 	mov.b	130(r14),r14	;0x00082
    9adc:	0c de       	bis	r14,	r12	;

00009ade <.LVL67>:
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (dest_addr == ground_apid) {
    9ade:	0c 9d       	cmp	r13,	r12	;
    9ae0:	02 24       	jz	$+6      	;abs 0x9ae6

00009ae2 <.Loc.262.1>:
    return ELY_DEST_RF;
  }
  
  return ELY_DEST_UART;
    9ae2:	4c 43       	clr.b	r12		;

00009ae4 <.L43>:
}
    9ae4:	10 01       	reta			;

00009ae6 <.L45>:
    return ELY_DEST_RF;
    9ae6:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009ae8 <.LVL70>:
    9ae8:	80 00 e4 9a 	mova	#39652,	r0	;0x09ae4

00009aec <is_fw_buf>:

bool is_fw_buf(uint8_t * buffer) {
    9aec:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009aee <.LCFI6>:
   * If (TM AND APID == Elysium) FW Reply
   * If (TC AND APID == Elysium) Coding error
   * Else NL packet */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    9aee:	6d 4c       	mov.b	@r12,	r13	;
    9af0:	0e 4d       	mov	r13,	r14	;
    9af2:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9af6:	3e f0 00 07 	and	#1792,	r14	;#0x0700
    9afa:	5c 4c 01 00 	mov.b	1(r12),	r12	;

00009afe <.LVL72>:
    9afe:	0c de       	bis	r14,	r12	;

00009b00 <.LVL73>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9b00:	2a 01 3e 04 	mova	&66622,	r10	;0x1043e
    9b04:	5e 4a 51 00 	mov.b	81(r10),r14	;0x00051
    9b08:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9b0c:	5a 4a 50 00 	mov.b	80(r10),r10	;0x00050
    9b10:	0e da       	bis	r10,	r14	;
    9b12:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    9b16:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00009b1a <.Loc.277.1>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (apid == elysium_apid) {
    9b1a:	0c 9e       	cmp	r14,	r12	;
    9b1c:	03 24       	jz	$+8      	;abs 0x9b24

00009b1e <.Loc.286.1>:
    else {
      /* Fall through to NL to allow loopback */
    }
  }
  
  return false;
    9b1e:	4c 43       	clr.b	r12		;

00009b20 <.L47>:
}
    9b20:	0a 16       	popm.a	#1,	r10	;20-bit words
    9b22:	10 01       	reta			;

00009b24 <.L50>:
    if (!tc) {
    9b24:	0d 93       	cmp	#0,	r13	;r3 As==00
    9b26:	03 24       	jz	$+8      	;abs 0x9b2e

00009b28 <.Loc.286.1>:
  return false;
    9b28:	4c 43       	clr.b	r12		;

00009b2a <.LVL78>:
    9b2a:	80 00 20 9b 	mova	#39712,	r0	;0x09b20

00009b2e <.L49>:
      return true;
    9b2e:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009b30 <.LVL80>:
    9b30:	80 00 20 9b 	mova	#39712,	r0	;0x09b20

00009b34 <elyNLFreeBufferChecked>:
  
void elyNLFreeBufferChecked(uint8_t * buffer) {
    9b34:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009b36 <.LCFI7>:
    9b36:	ca 0c       	mova	r12,	r10	;

00009b38 <.Loc.290.1>:
  if (is_fw_buf(buffer)) {
    9b38:	b0 13 ec 9a 	calla	#39660		;0x09aec

00009b3c <.LVL82>:
    9b3c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9b3e:	05 20       	jnz	$+12     	;abs 0x9b4a

00009b40 <.Loc.294.1>:
      elyFWFreeBuffer(buffer);
  }
  else {
    elyNLFreeBuffer(buffer);
    9b40:	cc 0a       	mova	r10,	r12	;
    9b42:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00009b46 <.L51>:
  }
}
    9b46:	0a 16       	popm.a	#1,	r10	;20-bit words
    9b48:	10 01       	reta			;

00009b4a <.L54>:
      elyFWFreeBuffer(buffer);
    9b4a:	cc 0a       	mova	r10,	r12	;
    9b4c:	b0 13 7c 61 	calla	#24956		;0x0617c

00009b50 <.LVL84>:
    9b50:	80 00 46 9b 	mova	#39750,	r0	;0x09b46

00009b54 <elyNLFreeBufferCheckedI>:

void elyNLFreeBufferCheckedI(uint8_t * buffer) {
    9b54:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009b56 <.LCFI8>:
    9b56:	ca 0c       	mova	r12,	r10	;

00009b58 <.Loc.299.1>:
  if (is_fw_buf(buffer)) {
    9b58:	b0 13 ec 9a 	calla	#39660		;0x09aec

00009b5c <.LVL86>:
    9b5c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9b5e:	05 20       	jnz	$+12     	;abs 0x9b6a

00009b60 <.Loc.303.1>:
      elyFWFreeBufferI(buffer);
  }
  else {
    elyNLFreeBufferI(buffer);
    9b60:	cc 0a       	mova	r10,	r12	;
    9b62:	b0 13 b6 9a 	calla	#39606		;0x09ab6

00009b66 <.L55>:
  }
}
    9b66:	0a 16       	popm.a	#1,	r10	;20-bit words
    9b68:	10 01       	reta			;

00009b6a <.L58>:
      elyFWFreeBufferI(buffer);
    9b6a:	cc 0a       	mova	r10,	r12	;
    9b6c:	b0 13 68 61 	calla	#24936		;0x06168

00009b70 <.LVL88>:
    9b70:	80 00 66 9b 	mova	#39782,	r0	;0x09b66

00009b74 <elyNLSetHeader>:
  }
  
  sh_len = 0;
}

void elyNLSetHeader(uint8_t * buffer, uint16_t length, uint16_t dest_addr) {
    9b74:	2a 14       	pushm.a	#3,	r10	;20-bit words

00009b76 <.LCFI9>:
    9b76:	ca 0c       	mova	r12,	r10	;

00009b78 <.Loc.328.1>:
  /* dest_addr not used for SPP */
  (void)(dest_addr);
  
  /* Set APID */
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9b78:	28 01 3e 04 	mova	&66622,	r8	;0x1043e
    9b7c:	5c 48 51 00 	mov.b	81(r8),	r12	;0x00051

00009b80 <.LVL92>:
    9b80:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    9b84:	5e 48 50 00 	mov.b	80(r8),	r14	;0x00050

00009b88 <.LVL93>:
    9b88:	0c de       	bis	r14,	r12	;

00009b8a <.LVL94>:
        (bank0p[RegSrcAddrLsb])) );
  buffer[0] = (elysium_apid >> 8);
    9b8a:	0e 4c       	mov	r12,	r14	;
    9b8c:	5e 0f       	rrum	#4,	r14	;
    9b8e:	5e 0f       	rrum	#4,	r14	;
    9b90:	ca 4e 00 00 	mov.b	r14,	0(r10)	;

00009b94 <.Loc.331.1>:
  buffer[1] = (elysium_apid & 0xFF);
    9b94:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00009b98 <.Loc.333.1>:
  
  length = (length + sh_len - 1);
    9b98:	40 18 1d 52 	addx.w	&0x0d606,r13	;
    9b9c:	06 d6 

00009b9e <.LVL95>:
    9b9e:	3d 53       	add	#-1,	r13	;r3 As==11

00009ba0 <.LVL96>:
  buffer[4] = (length >> 8);
    9ba0:	0c 4d       	mov	r13,	r12	;

00009ba2 <.LVL97>:
    9ba2:	5c 0f       	rrum	#4,	r12	;
    9ba4:	5c 0f       	rrum	#4,	r12	;
    9ba6:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

00009baa <.Loc.335.1>:
  buffer[5] = (length & 0xFF);
    9baa:	ca 4d 05 00 	mov.b	r13,	5(r10)	;

00009bae <.Loc.337.1>:
  
  uint8_t options = bank0p[RegNLOptions];
    9bae:	59 48 86 00 	mov.b	134(r8),r9	;0x00086

00009bb2 <.LVL98>:
  
  if (options & 0x04) {
    9bb2:	29 b2       	bit	#4,	r9	;r2 As==10
    9bb4:	37 20       	jnz	$+112    	;abs 0x9c24

00009bb6 <.Loc.346.1>:
    buffer[2] = bank0p[RegNLPktNameMsb];
    buffer[3] = bank0p[RegNLPktNameLsb];
    chSysUnlock();
  }
  else {
    buffer[2] = (packets_sent >> 8) | 0xC0;
    9bb6:	40 18 1c 42 	movx.w	&0x0b34a,r12	;
    9bba:	4a b3 
    9bbc:	0d 4c       	mov	r12,	r13	;

00009bbe <.LVL99>:
    9bbe:	5d 0f       	rrum	#4,	r13	;
    9bc0:	5d 0f       	rrum	#4,	r13	;
    9bc2:	7d d0 c0 ff 	bis.b	#-64,	r13	;#0xffc0
    9bc6:	ca 4d 02 00 	mov.b	r13,	2(r10)	;

00009bca <.LVL100>:
    buffer[3] = (packets_sent & 0xFF);
    9bca:	ca 4c 03 00 	mov.b	r12,	3(r10)	;

00009bce <.L62>:
  }
  
  packets_sent = (packets_sent + 1) & 0x3FFF;
    9bce:	40 18 1c 42 	movx.w	&0x0b34a,r12	;
    9bd2:	4a b3 
    9bd4:	1c 53       	inc	r12		;
    9bd6:	3c f0 ff 3f 	and	#16383,	r12	;#0x3fff
    9bda:	40 18 82 4c 	movx.w	r12,	&0xfb34a;
    9bde:	4a b3 

00009be0 <.Loc.353.1>:
  
  /* insert timestamps here too if required */
  if (options & 0x02) { /* Timestamp */
    9be0:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    9be4:	1d 24       	jz	$+60     	;abs 0x9c20

00009be6 <.Loc.354.1>:
    buffer[0] |= 0x08; /* Sec Hdr Flag */
    9be6:	fa d2 00 00 	bis.b	#8,	0(r10)	;r2 As==11

00009bea <.Loc.355.1>:
    if (options & 0x01) { /* P-field */
    9bea:	19 b3       	bit	#1,	r9	;r3 As==01
    9bec:	2e 20       	jnz	$+94     	;abs 0x9c4a

00009bee <.LBB21>:
  _disable_interrupts();
    9bee:	32 c2       	dint			
    9bf0:	03 43       	nop			

00009bf2 <.Loc.348.2>:
  asm volatile("nop");
    9bf2:	03 43       	nop			

00009bf4 <.LBE21>:
      chSysUnlock();
      
    }
    else { /* No P-field */
      /* 4-byte Secondary Header + 6-byte Primary Header */
      chSysLock();
    9bf4:	b0 13 50 45 	calla	#17744		;0x04550

00009bf8 <.LVL102>:
      buffer[6] = bank0p[RegMissionTimeMsb];
    9bf8:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    9bfc:	da 4c 76 00 	mov.b	118(r12),6(r10)	;0x00076
    9c00:	06 00 

00009c02 <.Loc.369.1>:
      buffer[7] = bank0p[RegMissionTimeHmb];
    9c02:	da 4c 75 00 	mov.b	117(r12),7(r10)	;0x00075
    9c06:	07 00 

00009c08 <.Loc.370.1>:
      buffer[8] = bank0p[RegMissionTimeLmb];
    9c08:	da 4c 74 00 	mov.b	116(r12),8(r10)	;0x00074
    9c0c:	08 00 

00009c0e <.Loc.371.1>:
      buffer[9] = bank0p[RegMissionTimeLsb];
    9c0e:	da 4c 73 00 	mov.b	115(r12),9(r10)	;0x00073
    9c12:	09 00 

00009c14 <.Loc.372.1>:
      chSysUnlock();
    9c14:	b0 13 70 45 	calla	#17776		;0x04570

00009c18 <.LBB23>:
  asm volatile("nop");
    9c18:	03 43       	nop			

00009c1a <.Loc.356.2>:
  _enable_interrupts();
    9c1a:	03 43       	nop			
    9c1c:	32 d2       	eint			
    9c1e:	03 43       	nop			

00009c20 <.L60>:
    }
  }
  
  return;
}
    9c20:	28 16       	popm.a	#3,	r10	;20-bit words
    9c22:	10 01       	reta			;

00009c24 <.L65>:
  _disable_interrupts();
    9c24:	32 c2       	dint			
    9c26:	03 43       	nop			

00009c28 <.Loc.348.2>:
  asm volatile("nop");
    9c28:	03 43       	nop			

00009c2a <.LBE25>:
    chSysLock();
    9c2a:	b0 13 50 45 	calla	#17744		;0x04550

00009c2e <.LVL105>:
    buffer[2] = bank0p[RegNLPktNameMsb];
    9c2e:	da 48 85 00 	mov.b	133(r8),2(r10)	;0x00085
    9c32:	02 00 

00009c34 <.Loc.342.1>:
    buffer[3] = bank0p[RegNLPktNameLsb];
    9c34:	da 48 84 00 	mov.b	132(r8),3(r10)	;0x00084
    9c38:	03 00 

00009c3a <.Loc.343.1>:
    chSysUnlock();
    9c3a:	b0 13 70 45 	calla	#17776		;0x04570

00009c3e <.LBB27>:
  asm volatile("nop");
    9c3e:	03 43       	nop			

00009c40 <.Loc.356.2>:
  _enable_interrupts();
    9c40:	03 43       	nop			
    9c42:	32 d2       	eint			
    9c44:	03 43       	nop			
    9c46:	80 00 ce 9b 	mova	#39886,	r0	;0x09bce

00009c4a <.L66>:
      buffer[6] = SPP_PFIELD;
    9c4a:	fa 40 2c 00 	mov.b	#44,	6(r10)	;#0x002c
    9c4e:	06 00 

00009c50 <.LBB29>:
  _disable_interrupts();
    9c50:	32 c2       	dint			
    9c52:	03 43       	nop			

00009c54 <.Loc.348.2>:
  asm volatile("nop");
    9c54:	03 43       	nop			

00009c56 <.LBE29>:
      chSysLock();
    9c56:	b0 13 50 45 	calla	#17744		;0x04550

00009c5a <.LVL107>:
      buffer[7] = bank0p[RegMissionTimeMsb];
    9c5a:	2c 01 3e 04 	mova	&66622,	r12	;0x1043e
    9c5e:	da 4c 76 00 	mov.b	118(r12),7(r10)	;0x00076
    9c62:	07 00 

00009c64 <.Loc.359.1>:
      buffer[8] = bank0p[RegMissionTimeHmb];
    9c64:	da 4c 75 00 	mov.b	117(r12),8(r10)	;0x00075
    9c68:	08 00 

00009c6a <.Loc.360.1>:
      buffer[9] = bank0p[RegMissionTimeLmb];
    9c6a:	da 4c 74 00 	mov.b	116(r12),9(r10)	;0x00074
    9c6e:	09 00 

00009c70 <.Loc.361.1>:
      buffer[10] = bank0p[RegMissionTimeLsb];
    9c70:	da 4c 73 00 	mov.b	115(r12),10(r10)	;0x00073, 0x000a
    9c74:	0a 00 

00009c76 <.Loc.362.1>:
      chSysUnlock();
    9c76:	b0 13 70 45 	calla	#17776		;0x04570

00009c7a <.LBB31>:
  asm volatile("nop");
    9c7a:	03 43       	nop			

00009c7c <.Loc.356.2>:
  _enable_interrupts();
    9c7c:	03 43       	nop			
    9c7e:	32 d2       	eint			
    9c80:	03 43       	nop			
    9c82:	80 00 20 9c 	mova	#39968,	r0	;0x09c20

00009c86 <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
    9c86:	ce 0c       	mova	r12,	r14	;

00009c88 <.Loc.380.1>:
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    9c88:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00009c8c <.LVL110>:
    9c8c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    9c90:	5e 4e 05 00 	mov.b	5(r14),	r14	;

00009c94 <.LVL111>:
    9c94:	0c de       	bis	r14,	r12	;
    9c96:	3c 50 07 00 	add	#7,	r12	;
    9c9a:	4c 0e       	rlam.a	#4,	r12	;
    9c9c:	4c 0d       	rram.a	#4,	r12	;

00009c9e <.Loc.381.1>:
}
    9c9e:	10 01       	reta			;

00009ca0 <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    9ca0:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009ca2 <.LCFI10>:
    9ca2:	ca 0c       	mova	r12,	r10	;

00009ca4 <.Loc.137.1>:
  if (buffer[0] & 0xE0) {
    9ca4:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    9ca8:	00 00 
    9caa:	1e 20       	jnz	$+62     	;abs 0x9ce8

00009cac <.LBB33>:
  _disable_interrupts();
    9cac:	32 c2       	dint			
    9cae:	03 43       	nop			

00009cb0 <.Loc.348.2>:
  asm volatile("nop");
    9cb0:	03 43       	nop			

00009cb2 <.LBE33>:
  chSysLock();
    9cb2:	b0 13 50 45 	calla	#17744		;0x04550

00009cb6 <.LVL113>:
  if ( elyNLGetLength(buffer) > 
    9cb6:	cc 0a       	mova	r10,	r12	;
    9cb8:	b0 13 86 9c 	calla	#40070		;0x09c86

00009cbc <.LVL114>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    9cbc:	2a 01 3e 04 	mova	&66622,	r10	;0x1043e

00009cc0 <.LVL115>:
    9cc0:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    9cc4:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9cc8:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    9ccc:	0e da       	bis	r10,	r14	;
    9cce:	40 18 0e 4e 	movx.w	r14,	r14	;

00009cd2 <.Loc.145.1>:
  if ( elyNLGetLength(buffer) > 
    9cd2:	de 0c       	cmpa	r12,	r14	;
    9cd4:	10 28       	jnc	$+34     	;abs 0x9cf6

00009cd6 <.Loc.152.1>:
  chSysUnlock();
    9cd6:	b0 13 70 45 	calla	#17776		;0x04570

00009cda <.LBB35>:
  asm volatile("nop");
    9cda:	03 43       	nop			

00009cdc <.Loc.356.2>:
  _enable_interrupts();
    9cdc:	03 43       	nop			
    9cde:	32 d2       	eint			
    9ce0:	03 43       	nop			

00009ce2 <.LBE35>:
  return true;
    9ce2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9ce4:	80 00 f2 9c 	mova	#40178,	r0	;0x09cf2

00009ce8 <.L72>:
    elyErrorSignal(ErrNLPVNMismatch);
    9ce8:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0
    9cec:	b0 13 fa 96 	calla	#38650		;0x096fa

00009cf0 <.LVL118>:
    return false;
    9cf0:	4c 43       	clr.b	r12		;

00009cf2 <.L70>:
}
    9cf2:	0a 16       	popm.a	#1,	r10	;20-bit words
    9cf4:	10 01       	reta			;

00009cf6 <.L73>:
    chSysUnlock();
    9cf6:	b0 13 70 45 	calla	#17776		;0x04570

00009cfa <.LBB37>:
  asm volatile("nop");
    9cfa:	03 43       	nop			

00009cfc <.Loc.356.2>:
  _enable_interrupts();
    9cfc:	03 43       	nop			
    9cfe:	32 d2       	eint			
    9d00:	03 43       	nop			

00009d02 <.LBE37>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    9d02:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    9d06:	b0 13 fa 96 	calla	#38650		;0x096fa

00009d0a <.LVL121>:
    return false;
    9d0a:	4c 43       	clr.b	r12		;
    9d0c:	80 00 f2 9c 	mova	#40178,	r0	;0x09cf2

00009d10 <nl_route>:
    msg_t (*loop_func)(uint8_t *)) {
    9d10:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009d12 <.LCFI11>:
    9d12:	08 14       	pushm.a	#1,	r8	;20-bit words

00009d14 <.LCFI12>:
    9d14:	06 14       	pushm.a	#1,	r6	;20-bit words

00009d16 <.LCFI13>:
    9d16:	04 14       	pushm.a	#1,	r4	;20-bit words

00009d18 <.LCFI14>:
    9d18:	ca 0c       	mova	r12,	r10	;
    9d1a:	c8 0d       	mova	r13,	r8	;
    9d1c:	c6 0e       	mova	r14,	r6	;
    9d1e:	c4 0f       	mova	r15,	r4	;

00009d20 <.Loc.166.1>:
  if (!elyNLValidate(buffer)) {
    9d20:	b0 13 a0 9c 	calla	#40096		;0x09ca0

00009d24 <.LVL123>:
    9d24:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    9d26:	23 24       	jz	$+72     	;abs 0x9d6e

00009d28 <.Loc.172.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    9d28:	6f 4a       	mov.b	@r10,	r15	;
    9d2a:	0c 4f       	mov	r15,	r12	;
    9d2c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    9d30:	3c f0 00 07 	and	#1792,	r12	;#0x0700
    9d34:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    9d38:	0c dd       	bis	r13,	r12	;

00009d3a <.LVL124>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    9d3a:	2e 01 3e 04 	mova	&66622,	r14	;0x1043e
    9d3e:	5d 4e 51 00 	mov.b	81(r14),r13	;0x00051
    9d42:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9d46:	5e 4e 50 00 	mov.b	80(r14),r14	;0x00050
    9d4a:	0d de       	bis	r14,	r13	;

00009d4c <.LVL125>:
    9d4c:	4e 4f       	mov.b	r15,	r14	;
    9d4e:	7e f0 10 00 	and.b	#16,	r14	;#0x0010
    9d52:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00009d56 <.LVL126>:
  if (apid == elysium_apid) {
    9d56:	0c 9d       	cmp	r13,	r12	;
    9d58:	0f 24       	jz	$+32     	;abs 0x9d78

00009d5a <.Loc.205.1>:
  if (MSG_OK != pass_func(buffer)) {
    9d5a:	cc 0a       	mova	r10,	r12	;

00009d5c <.LVL127>:
    9d5c:	48 13       	calla	r8		;

00009d5e <.LVL128>:
    9d5e:	9c 00 00 00 	cmpa	#0,	r12	;
    9d62:	2c 20       	jnz	$+90     	;abs 0x9dbc

00009d64 <.L74>:
}
    9d64:	04 16       	popm.a	#1,	r4	;20-bit words
    9d66:	06 16       	popm.a	#1,	r6	;20-bit words
    9d68:	08 16       	popm.a	#1,	r8	;20-bit words
    9d6a:	0a 16       	popm.a	#1,	r10	;20-bit words
    9d6c:	10 01       	reta			;

00009d6e <.L79>:
    elyNLFreeBuffer(buffer);
    9d6e:	cc 0a       	mova	r10,	r12	;
    9d70:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00009d74 <.LVL129>:
    return;
    9d74:	80 00 64 9d 	mova	#40292,	r0	;0x09d64

00009d78 <.L80>:
    if (tc) {
    9d78:	0e 93       	cmp	#0,	r14	;r3 As==00
    9d7a:	0e 24       	jz	$+30     	;abs 0x9d98

00009d7c <.Loc.179.1>:
      if (MSG_OK != fw_func(buffer)) {
    9d7c:	cc 0a       	mova	r10,	r12	;

00009d7e <.LVL131>:
    9d7e:	46 13       	calla	r6		;

00009d80 <.LVL132>:
    9d80:	9c 00 00 00 	cmpa	#0,	r12	;
    9d84:	ef 27       	jz	$-32     	;abs 0x9d64

00009d86 <.Loc.181.1>:
        chDbgAssert(false, "internal buffer overflows should be impossible");
    9d86:	8c 01 b1 04 	mova	#66737,	r12	;0x104b1
    9d8a:	b0 13 a0 47 	calla	#18336		;0x047a0

00009d8e <.LVL133>:
        elyNLFreeBuffer(buffer);
    9d8e:	cc 0a       	mova	r10,	r12	;
    9d90:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00009d94 <.LVL134>:
    9d94:	80 00 64 9d 	mova	#40292,	r0	;0x09d64

00009d98 <.L78>:
      buffer[0] |= 0x10; /* set apid to free properly */
    9d98:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    9d9c:	ca 4f 00 00 	mov.b	r15,	0(r10)	;

00009da0 <.Loc.190.1>:
      if (MSG_OK != loop_func(buffer)) {
    9da0:	cc 0a       	mova	r10,	r12	;

00009da2 <.LVL136>:
    9da2:	44 13       	calla	r4		;

00009da4 <.LVL137>:
    9da4:	9c 00 00 00 	cmpa	#0,	r12	;
    9da8:	dd 27       	jz	$-68     	;abs 0x9d64

00009daa <.Loc.192.1>:
        chDbgAssert(false, "internal buffer overflows should be impossible");
    9daa:	8c 01 b1 04 	mova	#66737,	r12	;0x104b1
    9dae:	b0 13 a0 47 	calla	#18336		;0x047a0

00009db2 <.LVL138>:
        elyNLFreeBuffer(buffer);
    9db2:	cc 0a       	mova	r10,	r12	;
    9db4:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00009db8 <.LVL139>:
    9db8:	80 00 64 9d 	mova	#40292,	r0	;0x09d64

00009dbc <.L81>:
    chDbgAssert(false, "internal buffer overflows should be impossible");
    9dbc:	8c 01 b1 04 	mova	#66737,	r12	;0x104b1
    9dc0:	b0 13 a0 47 	calla	#18336		;0x047a0

00009dc4 <.LVL140>:
    elyNLFreeBuffer(buffer);
    9dc4:	cc 0a       	mova	r10,	r12	;
    9dc6:	b0 13 aa 9a 	calla	#39594		;0x09aaa

00009dca <.LVL141>:
    9dca:	80 00 64 9d 	mova	#40292,	r0	;0x09d64

00009dce <elyNLRouteUART>:
  nl_route(buffer, rf_pass, fw, uart_pass);
    9dce:	8f 00 e2 99 	mova	#39394,	r15	;0x099e2
    9dd2:	8e 00 ea 99 	mova	#39402,	r14	;0x099ea
    9dd6:	8d 00 f2 99 	mova	#39410,	r13	;0x099f2
    9dda:	b0 13 10 9d 	calla	#40208		;0x09d10

00009dde <.LVL143>:
}
    9dde:	10 01       	reta			;

00009de0 <elyNLToFW>:
size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - sh_len + 1;
}

uint8_t * elyNLToFW(uint8_t * buffer) {
  return buffer + sh_len + 6;
    9de0:	2e 00 06 d6 	mova	&54790,	r14	;0x0d606
    9de4:	ae 00 06 00 	adda	#6,	r14	;

00009de8 <.Loc.389.1>:
}
    9de8:	ec 0e       	adda	r14,	r12	;

00009dea <.LVL152>:
    9dea:	10 01       	reta			;

00009dec <elyNLFromFW>:

uint8_t * elyNLFromFW(uint8_t * buffer) {
  return buffer - sh_len - 6;
    9dec:	8e 0f fa ff 	mova	#-6,	r14	;0xfffffffa
    9df0:	00 18 5e 82 	subx.a	&0x0d606,r14	;
    9df4:	06 d6 

00009df6 <.Loc.393.1>:
}
    9df6:	ec 0e       	adda	r14,	r12	;

00009df8 <.LVL154>:
    9df8:	10 01       	reta			;

00009dfa <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    9dfa:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    9dfe:	80 5a 5c 01 

00009e02 <.Loc.51.1>:

  halInit();
    9e02:	b0 13 88 50 	calla	#20616		;0x05088

00009e06 <.LVL0>:
  chSysInit();
    9e06:	b0 13 5c 46 	calla	#18012		;0x0465c

00009e0a <.L3>:
    9e0a:	80 00 0a 9e 	mova	#40458,	r0	;0x09e0a

00009e0e <udivmodsi4>:
    9e0e:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009e10 <.LCFI0>:
    9e10:	0a 4c       	mov	r12,	r10	;
    9e12:	0b 4d       	mov	r13,	r11	;

00009e14 <.LVL1>:
    9e14:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00009e18 <.Loc.35.1>:
    9e18:	58 43       	mov.b	#1,	r8	;r3 As==01
    9e1a:	49 43       	clr.b	r9		;

00009e1c <.Loc.38.1>:
    9e1c:	07 4b       	mov	r11,	r7	;

00009e1e <.L2>:
    9e1e:	0f 9b       	cmp	r11,	r15	;
    9e20:	11 28       	jnc	$+36     	;abs 0x9e44
    9e22:	07 9f       	cmp	r15,	r7	;
    9e24:	02 20       	jnz	$+6      	;abs 0x9e2a
    9e26:	0e 9a       	cmp	r10,	r14	;
    9e28:	0d 28       	jnc	$+28     	;abs 0x9e44

00009e2a <.L20>:
    9e2a:	4c 43       	clr.b	r12		;

00009e2c <.LVL3>:
    9e2c:	0d 4c       	mov	r12,	r13	;

00009e2e <.L5>:
    9e2e:	07 48       	mov	r8,	r7	;
    9e30:	07 d9       	bis	r9,	r7	;
    9e32:	07 93       	cmp	#0,	r7	;r3 As==00
    9e34:	1a 20       	jnz	$+54     	;abs 0x9e6a

00009e36 <.L6>:
    9e36:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    9e3a:	02 24       	jz	$+6      	;abs 0x9e40
    9e3c:	0c 4a       	mov	r10,	r12	;
    9e3e:	0d 4b       	mov	r11,	r13	;

00009e40 <.L1>:
    9e40:	55 16       	popm.a	#6,	r10	;20-bit words
    9e42:	10 01       	reta			;

00009e44 <.L3>:
    9e44:	3d 53       	add	#-1,	r13	;r3 As==11

00009e46 <.Loc.38.1>:
    9e46:	0d 93       	cmp	#0,	r13	;r3 As==00
    9e48:	24 24       	jz	$+74     	;abs 0x9e92

00009e4a <.Loc.38.1>:
    9e4a:	0f 93       	cmp	#0,	r15	;r3 As==00
    9e4c:	ee 3b       	jl	$-34     	;abs 0x9e2a

00009e4e <.Loc.40.1>:
    9e4e:	05 4e       	mov	r14,	r5	;
    9e50:	06 4f       	mov	r15,	r6	;
    9e52:	05 5e       	add	r14,	r5	;
    9e54:	06 6f       	addc	r15,	r6	;
    9e56:	0e 45       	mov	r5,	r14	;

00009e58 <.LVL7>:
    9e58:	0f 46       	mov	r6,	r15	;

00009e5a <.LVL8>:
    9e5a:	05 48       	mov	r8,	r5	;
    9e5c:	06 49       	mov	r9,	r6	;
    9e5e:	05 58       	add	r8,	r5	;
    9e60:	06 69       	addc	r9,	r6	;
    9e62:	08 45       	mov	r5,	r8	;

00009e64 <.LVL9>:
    9e64:	09 46       	mov	r6,	r9	;

00009e66 <.LVL10>:
    9e66:	80 00 1e 9e 	mova	#40478,	r0	;0x09e1e

00009e6a <.L12>:
    9e6a:	0b 9f       	cmp	r15,	r11	;
    9e6c:	0a 28       	jnc	$+22     	;abs 0x9e82
    9e6e:	0f 9b       	cmp	r11,	r15	;
    9e70:	02 20       	jnz	$+6      	;abs 0x9e76
    9e72:	0a 9e       	cmp	r14,	r10	;
    9e74:	06 28       	jnc	$+14     	;abs 0x9e82

00009e76 <.L16>:
    9e76:	40 18 0a 8e 	subx.w	r14,	r10	;
    9e7a:	40 18 0b 7f 	subcx.w	r15,	r11	;

00009e7e <.Loc.48.1>:
    9e7e:	0c d8       	bis	r8,	r12	;

00009e80 <.LVL13>:
    9e80:	0d d9       	bis	r9,	r13	;

00009e82 <.L10>:
    9e82:	12 c3       	clrc			
    9e84:	09 10       	rrc	r9		;
    9e86:	08 10       	rrc	r8		;

00009e88 <.Loc.51.1>:
    9e88:	12 c3       	clrc			
    9e8a:	0f 10       	rrc	r15		;
    9e8c:	0e 10       	rrc	r14		;
    9e8e:	80 00 2e 9e 	mova	#40494,	r0	;0x09e2e

00009e92 <.L14>:
    9e92:	0c 4d       	mov	r13,	r12	;

00009e94 <.LVL18>:
    9e94:	80 00 36 9e 	mova	#40502,	r0	;0x09e36

00009e98 <__mspabi_divlu>:
    9e98:	b1 00 02 00 	suba	#2,	r1	;

00009e9c <.LCFI5>:
    9e9c:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    9ea0:	b0 13 0e 9e 	calla	#40462		;0x09e0e

00009ea4 <.LVL46>:
    9ea4:	a1 00 02 00 	adda	#2,	r1	;
    9ea8:	10 01       	reta			;

00009eaa <__mspabi_slli_15>:
    9eaa:	0c 5c       	rla	r12		;

00009eac <__mspabi_slli_14>:
    9eac:	0c 5c       	rla	r12		;

00009eae <__mspabi_slli_13>:
    9eae:	0c 5c       	rla	r12		;

00009eb0 <__mspabi_slli_12>:
    9eb0:	0c 5c       	rla	r12		;

00009eb2 <__mspabi_slli_11>:
    9eb2:	0c 5c       	rla	r12		;

00009eb4 <__mspabi_slli_10>:
    9eb4:	0c 5c       	rla	r12		;

00009eb6 <__mspabi_slli_9>:
    9eb6:	0c 5c       	rla	r12		;

00009eb8 <__mspabi_slli_8>:
    9eb8:	0c 5c       	rla	r12		;

00009eba <__mspabi_slli_7>:
    9eba:	0c 5c       	rla	r12		;

00009ebc <__mspabi_slli_6>:
    9ebc:	0c 5c       	rla	r12		;

00009ebe <__mspabi_slli_5>:
    9ebe:	0c 5c       	rla	r12		;

00009ec0 <__mspabi_slli_4>:
    9ec0:	0c 5c       	rla	r12		;

00009ec2 <__mspabi_slli_3>:
    9ec2:	0c 5c       	rla	r12		;

00009ec4 <__mspabi_slli_2>:
    9ec4:	0c 5c       	rla	r12		;

00009ec6 <__mspabi_slli_1>:
    9ec6:	0c 5c       	rla	r12		;
    9ec8:	10 01       	reta			;

00009eca <.L11>:
    9eca:	3d 53       	add	#-1,	r13	;r3 As==11
    9ecc:	0c 5c       	rla	r12		;

00009ece <__mspabi_slli>:
    9ece:	0d 93       	cmp	#0,	r13	;r3 As==00
    9ed0:	fc 23       	jnz	$-6      	;abs 0x9eca
    9ed2:	10 01       	reta			;

00009ed4 <__mspabi_slll_15>:
    9ed4:	0c 5c       	rla	r12		;
    9ed6:	0d 6d       	rlc	r13		;

00009ed8 <__mspabi_slll_14>:
    9ed8:	0c 5c       	rla	r12		;
    9eda:	0d 6d       	rlc	r13		;

00009edc <__mspabi_slll_13>:
    9edc:	0c 5c       	rla	r12		;
    9ede:	0d 6d       	rlc	r13		;

00009ee0 <__mspabi_slll_12>:
    9ee0:	0c 5c       	rla	r12		;
    9ee2:	0d 6d       	rlc	r13		;

00009ee4 <__mspabi_slll_11>:
    9ee4:	0c 5c       	rla	r12		;
    9ee6:	0d 6d       	rlc	r13		;

00009ee8 <__mspabi_slll_10>:
    9ee8:	0c 5c       	rla	r12		;
    9eea:	0d 6d       	rlc	r13		;

00009eec <__mspabi_slll_9>:
    9eec:	0c 5c       	rla	r12		;
    9eee:	0d 6d       	rlc	r13		;

00009ef0 <__mspabi_slll_8>:
    9ef0:	0c 5c       	rla	r12		;
    9ef2:	0d 6d       	rlc	r13		;

00009ef4 <__mspabi_slll_7>:
    9ef4:	0c 5c       	rla	r12		;
    9ef6:	0d 6d       	rlc	r13		;

00009ef8 <__mspabi_slll_6>:
    9ef8:	0c 5c       	rla	r12		;
    9efa:	0d 6d       	rlc	r13		;

00009efc <__mspabi_slll_5>:
    9efc:	0c 5c       	rla	r12		;
    9efe:	0d 6d       	rlc	r13		;

00009f00 <__mspabi_slll_4>:
    9f00:	0c 5c       	rla	r12		;
    9f02:	0d 6d       	rlc	r13		;

00009f04 <__mspabi_slll_3>:
    9f04:	0c 5c       	rla	r12		;
    9f06:	0d 6d       	rlc	r13		;

00009f08 <__mspabi_slll_2>:
    9f08:	0c 5c       	rla	r12		;
    9f0a:	0d 6d       	rlc	r13		;

00009f0c <__mspabi_slll_1>:
    9f0c:	0c 5c       	rla	r12		;
    9f0e:	0d 6d       	rlc	r13		;
    9f10:	10 01       	reta			;

00009f12 <.L12>:
    9f12:	3e 53       	add	#-1,	r14	;r3 As==11
    9f14:	0c 5c       	rla	r12		;
    9f16:	0d 6d       	rlc	r13		;

00009f18 <__mspabi_slll>:
    9f18:	0e 93       	cmp	#0,	r14	;r3 As==00
    9f1a:	fb 23       	jnz	$-8      	;abs 0x9f12
    9f1c:	10 01       	reta			;

00009f1e <__mspabi_srli_15>:
    9f1e:	12 c3       	clrc			
    9f20:	0c 10       	rrc	r12		;

00009f22 <__mspabi_srli_14>:
    9f22:	12 c3       	clrc			
    9f24:	0c 10       	rrc	r12		;

00009f26 <__mspabi_srli_13>:
    9f26:	12 c3       	clrc			
    9f28:	0c 10       	rrc	r12		;

00009f2a <__mspabi_srli_12>:
    9f2a:	12 c3       	clrc			
    9f2c:	0c 10       	rrc	r12		;

00009f2e <__mspabi_srli_11>:
    9f2e:	12 c3       	clrc			
    9f30:	0c 10       	rrc	r12		;

00009f32 <__mspabi_srli_10>:
    9f32:	12 c3       	clrc			
    9f34:	0c 10       	rrc	r12		;

00009f36 <__mspabi_srli_9>:
    9f36:	12 c3       	clrc			
    9f38:	0c 10       	rrc	r12		;

00009f3a <__mspabi_srli_8>:
    9f3a:	12 c3       	clrc			
    9f3c:	0c 10       	rrc	r12		;

00009f3e <__mspabi_srli_7>:
    9f3e:	12 c3       	clrc			
    9f40:	0c 10       	rrc	r12		;

00009f42 <__mspabi_srli_6>:
    9f42:	12 c3       	clrc			
    9f44:	0c 10       	rrc	r12		;

00009f46 <__mspabi_srli_5>:
    9f46:	12 c3       	clrc			
    9f48:	0c 10       	rrc	r12		;

00009f4a <__mspabi_srli_4>:
    9f4a:	12 c3       	clrc			
    9f4c:	0c 10       	rrc	r12		;

00009f4e <__mspabi_srli_3>:
    9f4e:	12 c3       	clrc			
    9f50:	0c 10       	rrc	r12		;

00009f52 <__mspabi_srli_2>:
    9f52:	12 c3       	clrc			
    9f54:	0c 10       	rrc	r12		;

00009f56 <__mspabi_srli_1>:
    9f56:	12 c3       	clrc			
    9f58:	0c 10       	rrc	r12		;
    9f5a:	10 01       	reta			;

00009f5c <.L11>:
    9f5c:	3d 53       	add	#-1,	r13	;r3 As==11
    9f5e:	12 c3       	clrc			
    9f60:	0c 10       	rrc	r12		;

00009f62 <__mspabi_srli>:
    9f62:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f64:	fb 23       	jnz	$-8      	;abs 0x9f5c
    9f66:	10 01       	reta			;

00009f68 <__mspabi_srll_15>:
    9f68:	12 c3       	clrc			
    9f6a:	0d 10       	rrc	r13		;
    9f6c:	0c 10       	rrc	r12		;

00009f6e <__mspabi_srll_14>:
    9f6e:	12 c3       	clrc			
    9f70:	0d 10       	rrc	r13		;
    9f72:	0c 10       	rrc	r12		;

00009f74 <__mspabi_srll_13>:
    9f74:	12 c3       	clrc			
    9f76:	0d 10       	rrc	r13		;
    9f78:	0c 10       	rrc	r12		;

00009f7a <__mspabi_srll_12>:
    9f7a:	12 c3       	clrc			
    9f7c:	0d 10       	rrc	r13		;
    9f7e:	0c 10       	rrc	r12		;

00009f80 <__mspabi_srll_11>:
    9f80:	12 c3       	clrc			
    9f82:	0d 10       	rrc	r13		;
    9f84:	0c 10       	rrc	r12		;

00009f86 <__mspabi_srll_10>:
    9f86:	12 c3       	clrc			
    9f88:	0d 10       	rrc	r13		;
    9f8a:	0c 10       	rrc	r12		;

00009f8c <__mspabi_srll_9>:
    9f8c:	12 c3       	clrc			
    9f8e:	0d 10       	rrc	r13		;
    9f90:	0c 10       	rrc	r12		;

00009f92 <__mspabi_srll_8>:
    9f92:	12 c3       	clrc			
    9f94:	0d 10       	rrc	r13		;
    9f96:	0c 10       	rrc	r12		;

00009f98 <__mspabi_srll_7>:
    9f98:	12 c3       	clrc			
    9f9a:	0d 10       	rrc	r13		;
    9f9c:	0c 10       	rrc	r12		;

00009f9e <__mspabi_srll_6>:
    9f9e:	12 c3       	clrc			
    9fa0:	0d 10       	rrc	r13		;
    9fa2:	0c 10       	rrc	r12		;

00009fa4 <__mspabi_srll_5>:
    9fa4:	12 c3       	clrc			
    9fa6:	0d 10       	rrc	r13		;
    9fa8:	0c 10       	rrc	r12		;

00009faa <__mspabi_srll_4>:
    9faa:	12 c3       	clrc			
    9fac:	0d 10       	rrc	r13		;
    9fae:	0c 10       	rrc	r12		;

00009fb0 <__mspabi_srll_3>:
    9fb0:	12 c3       	clrc			
    9fb2:	0d 10       	rrc	r13		;
    9fb4:	0c 10       	rrc	r12		;

00009fb6 <__mspabi_srll_2>:
    9fb6:	12 c3       	clrc			
    9fb8:	0d 10       	rrc	r13		;
    9fba:	0c 10       	rrc	r12		;

00009fbc <__mspabi_srll_1>:
    9fbc:	12 c3       	clrc			
    9fbe:	0d 10       	rrc	r13		;
    9fc0:	0c 10       	rrc	r12		;
    9fc2:	10 01       	reta			;

00009fc4 <.L12>:
    9fc4:	3e 53       	add	#-1,	r14	;r3 As==11
    9fc6:	12 c3       	clrc			
    9fc8:	0d 10       	rrc	r13		;
    9fca:	0c 10       	rrc	r12		;

00009fcc <__mspabi_srll>:
    9fcc:	0e 93       	cmp	#0,	r14	;r3 As==00
    9fce:	fa 23       	jnz	$-10     	;abs 0x9fc4
    9fd0:	10 01       	reta			;

00009fd2 <__mspabi_mpyl>:
    9fd2:	02 12       	push	r2		;
    9fd4:	32 c2       	dint			
    9fd6:	03 43       	nop			
    9fd8:	82 4c d0 04 	mov	r12,	&0x04d0	;
    9fdc:	82 4d d2 04 	mov	r13,	&0x04d2	;
    9fe0:	82 4e e0 04 	mov	r14,	&0x04e0	;
    9fe4:	82 4f e2 04 	mov	r15,	&0x04e2	;
    9fe8:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    9fec:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    9ff0:	32 41       	pop	r2		;
    9ff2:	10 01       	reta			;

00009ff4 <memcpy>:
    9ff4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009ff6 <.LCFI0>:
    9ff6:	ca 0c       	mova	r12,	r10	;
    9ff8:	ee 0c       	adda	r12,	r14	;

00009ffa <.L2>:
    9ffa:	da 0e       	cmpa	r14,	r10	;
    9ffc:	08 24       	jz	$+18     	;abs 0xa00e

00009ffe <.LVL3>:
    9ffe:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    a002:	aa 00 01 00 	adda	#1,	r10	;

0000a006 <.LVL4>:
    a006:	ad 00 01 00 	adda	#1,	r13	;
    a00a:	80 00 fa 9f 	mova	#40954,	r0	;0x09ffa

0000a00e <.L5>:
    a00e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a010:	10 01       	reta			;

0000a012 <memset>:
    a012:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a014 <.LCFI0>:
    a014:	ca 0c       	mova	r12,	r10	;
    a016:	ee 0c       	adda	r12,	r14	;

0000a018 <.L2>:
    a018:	da 0e       	cmpa	r14,	r10	;
    a01a:	06 24       	jz	$+14     	;abs 0xa028

0000a01c <.LVL3>:
    a01c:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    a020:	aa 00 01 00 	adda	#1,	r10	;

0000a024 <.LVL4>:
    a024:	80 00 18 a0 	mova	#40984,	r0	;0x0a018

0000a028 <.L5>:
    a028:	0a 16       	popm.a	#1,	r10	;20-bit words
    a02a:	10 01       	reta			;

0000a02c <memmove>:
    a02c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a02e <.LCFI0>:
    a02e:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a030 <.LCFI1>:
    a030:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a032 <.LCFI2>:
    a032:	c8 0c       	mova	r12,	r8	;
    a034:	e8 0e       	adda	r14,	r8	;

0000a036 <.Loc.69.1>:
    a036:	dd 0c       	cmpa	r12,	r13	;
    a038:	04 28       	jnc	$+10     	;abs 0xa042

0000a03a <.L4>:
    a03a:	ce 0c       	mova	r12,	r14	;

0000a03c <.LVL2>:
    a03c:	ca 0d       	mova	r13,	r10	;
    a03e:	80 00 66 a0 	mova	#41062,	r0	;0x0a066

0000a042 <.L2>:
    a042:	ca 0d       	mova	r13,	r10	;
    a044:	ea 0e       	adda	r14,	r10	;
    a046:	dc 0a       	cmpa	r10,	r12	;
    a048:	f8 2f       	jc	$-14     	;abs 0xa03a

0000a04a <.LVL4>:
    a04a:	fe 0a       	suba	r10,	r14	;

0000a04c <.L5>:
    a04c:	c6 0a       	mova	r10,	r6	;
    a04e:	e6 0e       	adda	r14,	r6	;

0000a050 <.Loc.74.1>:
    a050:	96 00 00 00 	cmpa	#0,	r6	;
    a054:	12 24       	jz	$+38     	;abs 0xa07a

0000a056 <.Loc.76.1>:
    a056:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    a05a:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000a05e <.LVL7>:
    a05e:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    a062:	80 00 4c a0 	mova	#41036,	r0	;0x0a04c

0000a066 <.L3>:
    a066:	d8 0e       	cmpa	r14,	r8	;
    a068:	08 24       	jz	$+18     	;abs 0xa07a

0000a06a <.LVL9>:
    a06a:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    a06e:	ae 00 01 00 	adda	#1,	r14	;

0000a072 <.LVL10>:
    a072:	aa 00 01 00 	adda	#1,	r10	;
    a076:	80 00 66 a0 	mova	#41062,	r0	;0x0a066

0000a07a <.L9>:
    a07a:	06 16       	popm.a	#1,	r6	;20-bit words
    a07c:	08 16       	popm.a	#1,	r8	;20-bit words
    a07e:	0a 16       	popm.a	#1,	r10	;20-bit words
    a080:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000d60a <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    d60a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d60c <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    d60c:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d610:	6c 05 
    d612:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d616 <.LBB12>:
  chSysLockFromISR();
    d616:	b0 13 92 45 	calla	#17810		;0x04592

0000d61a <.LBB14>:
  chSysTimerHandlerI();
    d61a:	b0 13 ae 47 	calla	#18350		;0x047ae

0000d61e <.LBB16>:
  chSysUnlockFromISR();
    d61e:	b0 13 b4 45 	calla	#17844		;0x045b4

0000d622 <.LBE16>:
  OSAL_IRQ_EPILOGUE();
    d622:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d626 <.LVL4>:
    d626:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d62a:	6c 05 
    d62c:	b0 13 50 45 	calla	#17744		;0x04550

0000d630 <.LVL5>:
    d630:	b0 13 04 49 	calla	#18692		;0x04904

0000d634 <.LVL6>:
    d634:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d636:	04 20       	jnz	$+10     	;abs 0xd640

0000d638 <.L2>:
    d638:	b0 13 70 45 	calla	#17776		;0x04570

0000d63c <.LVL7>:
}
    d63c:	b4 16       	popm.a	#12,	r15	;20-bit words
    d63e:	00 13       	reti			

0000d640 <.L3>:
  OSAL_IRQ_EPILOGUE();
    d640:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d644 <.LVL8>:
    d644:	80 00 38 d6 	mova	#54840,	r0	;0x0d638

0000d648 <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    d648:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d64a <.LCFI0>:
    d64a:	b1 00 04 00 	suba	#4,	r1	;

0000d64e <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    d64e:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d652:	6c 05 
    d654:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d658 <.LVL0>:
  pad = (P1IV >> 1) - 1;
    d658:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    d65c:	0e 02 
    d65e:	12 c3       	clrc			
    d660:	0c 10       	rrc	r12		;
    d662:	7c 53       	add.b	#-1,	r12	;r3 As==11
    d664:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000d668 <.LVL1>:
  cb = port_callback_map[0][pad];
    d668:	4c 0e       	rlam.a	#4,	r12	;
    d66a:	4c 0d       	rram.a	#4,	r12	;

0000d66c <.LVL2>:
    d66c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d66e:	40 18 3c 41 	popx.w	r12		;
    d672:	40 18 3d 41 	popx.w	r13		;
    d676:	0e 4c       	mov	r12,	r14	;
    d678:	0f 4d       	mov	r13,	r15	;
    d67a:	0e 5e       	rla	r14		;
    d67c:	0f 6f       	rlc	r15		;
    d67e:	0e 5e       	rla	r14		;
    d680:	0f 6f       	rlc	r15		;
    d682:	81 4e 00 00 	mov	r14,	0(r1)	;
    d686:	81 4f 02 00 	mov	r15,	2(r1)	;
    d68a:	0d 01       	mova	@r1,	r13	;
    d68c:	80 18 5c 4d 	movx.a	66926(r13),r12	;0x1056e
    d690:	6e 05 

0000d692 <.LVL3>:
  if (cb != NULL) {
    d692:	9c 00 00 00 	cmpa	#0,	r12	;
    d696:	01 24       	jz	$+4      	;abs 0xd69a

0000d698 <.Loc.81.1>:
    (*cb)();
    d698:	4c 13       	calla	r12		;

0000d69a <.L2>:
  OSAL_IRQ_EPILOGUE();
    d69a:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d69e <.LVL5>:
    d69e:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d6a2:	6c 05 
    d6a4:	b0 13 50 45 	calla	#17744		;0x04550

0000d6a8 <.LVL6>:
    d6a8:	b0 13 04 49 	calla	#18692		;0x04904

0000d6ac <.LVL7>:
    d6ac:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d6ae:	06 20       	jnz	$+14     	;abs 0xd6bc

0000d6b0 <.L3>:
    d6b0:	b0 13 70 45 	calla	#17776		;0x04570

0000d6b4 <.LVL8>:
}
    d6b4:	a1 00 04 00 	adda	#4,	r1	;
    d6b8:	b4 16       	popm.a	#12,	r15	;20-bit words
    d6ba:	00 13       	reti			

0000d6bc <.L4>:
  OSAL_IRQ_EPILOGUE();
    d6bc:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d6c0 <.LVL9>:
    d6c0:	80 00 b0 d6 	mova	#54960,	r0	;0x0d6b0

0000d6c4 <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    d6c4:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d6c6 <.LCFI2>:
    d6c6:	b1 00 04 00 	suba	#4,	r1	;

0000d6ca <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    d6ca:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d6ce:	6c 05 
    d6d0:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d6d4 <.LVL10>:
  pad = (P2IV >> 1) - 1;
    d6d4:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    d6d8:	1e 02 
    d6da:	12 c3       	clrc			
    d6dc:	0c 10       	rrc	r12		;
    d6de:	7c 53       	add.b	#-1,	r12	;r3 As==11
    d6e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000d6e4 <.LVL11>:
  cb = port_callback_map[1][pad];
    d6e4:	4c 0e       	rlam.a	#4,	r12	;
    d6e6:	4c 0d       	rram.a	#4,	r12	;

0000d6e8 <.LVL12>:
    d6e8:	ac 00 08 00 	adda	#8,	r12	;
    d6ec:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d6ee:	40 18 3c 41 	popx.w	r12		;
    d6f2:	40 18 3d 41 	popx.w	r13		;
    d6f6:	0e 4c       	mov	r12,	r14	;
    d6f8:	0f 4d       	mov	r13,	r15	;
    d6fa:	0e 5e       	rla	r14		;
    d6fc:	0f 6f       	rlc	r15		;
    d6fe:	0e 5e       	rla	r14		;
    d700:	0f 6f       	rlc	r15		;
    d702:	81 4e 00 00 	mov	r14,	0(r1)	;
    d706:	81 4f 02 00 	mov	r15,	2(r1)	;
    d70a:	0d 01       	mova	@r1,	r13	;
    d70c:	80 18 5c 4d 	movx.a	66926(r13),r12	;0x1056e
    d710:	6e 05 

0000d712 <.LVL13>:
  if (cb != NULL) {
    d712:	9c 00 00 00 	cmpa	#0,	r12	;
    d716:	01 24       	jz	$+4      	;abs 0xd71a

0000d718 <.Loc.99.1>:
    (*cb)();
    d718:	4c 13       	calla	r12		;

0000d71a <.L6>:
  OSAL_IRQ_EPILOGUE();
    d71a:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d71e <.LVL15>:
    d71e:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d722:	6c 05 
    d724:	b0 13 50 45 	calla	#17744		;0x04550

0000d728 <.LVL16>:
    d728:	b0 13 04 49 	calla	#18692		;0x04904

0000d72c <.LVL17>:
    d72c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d72e:	06 20       	jnz	$+14     	;abs 0xd73c

0000d730 <.L7>:
    d730:	b0 13 70 45 	calla	#17776		;0x04570

0000d734 <.LVL18>:
}
    d734:	a1 00 04 00 	adda	#4,	r1	;
    d738:	b4 16       	popm.a	#12,	r15	;20-bit words
    d73a:	00 13       	reti			

0000d73c <.L8>:
  OSAL_IRQ_EPILOGUE();
    d73c:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d740 <.LVL19>:
    d740:	80 00 30 d7 	mova	#55088,	r0	;0x0d730

0000d744 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    d744:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d746 <.LCFI4>:
    d746:	b1 00 04 00 	suba	#4,	r1	;

0000d74a <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    d74a:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d74e:	6c 05 
    d750:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d754 <.LVL20>:
  pad = (P3IV >> 1) - 1;
    d754:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    d758:	2e 02 
    d75a:	12 c3       	clrc			
    d75c:	0c 10       	rrc	r12		;
    d75e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    d760:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000d764 <.LVL21>:
  cb = port_callback_map[2][pad];
    d764:	4c 0e       	rlam.a	#4,	r12	;
    d766:	4c 0d       	rram.a	#4,	r12	;

0000d768 <.LVL22>:
    d768:	ac 00 10 00 	adda	#16,	r12	;0x00010
    d76c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d76e:	40 18 3c 41 	popx.w	r12		;
    d772:	40 18 3d 41 	popx.w	r13		;
    d776:	0e 4c       	mov	r12,	r14	;
    d778:	0f 4d       	mov	r13,	r15	;
    d77a:	0e 5e       	rla	r14		;
    d77c:	0f 6f       	rlc	r15		;
    d77e:	0e 5e       	rla	r14		;
    d780:	0f 6f       	rlc	r15		;
    d782:	81 4e 00 00 	mov	r14,	0(r1)	;
    d786:	81 4f 02 00 	mov	r15,	2(r1)	;
    d78a:	0d 01       	mova	@r1,	r13	;
    d78c:	80 18 5c 4d 	movx.a	66926(r13),r12	;0x1056e
    d790:	6e 05 

0000d792 <.LVL23>:
  if (cb != NULL) {
    d792:	9c 00 00 00 	cmpa	#0,	r12	;
    d796:	01 24       	jz	$+4      	;abs 0xd79a

0000d798 <.Loc.118.1>:
    (*cb)();
    d798:	4c 13       	calla	r12		;

0000d79a <.L10>:
  OSAL_IRQ_EPILOGUE();
    d79a:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d79e <.LVL25>:
    d79e:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d7a2:	6c 05 
    d7a4:	b0 13 50 45 	calla	#17744		;0x04550

0000d7a8 <.LVL26>:
    d7a8:	b0 13 04 49 	calla	#18692		;0x04904

0000d7ac <.LVL27>:
    d7ac:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d7ae:	06 20       	jnz	$+14     	;abs 0xd7bc

0000d7b0 <.L11>:
    d7b0:	b0 13 70 45 	calla	#17776		;0x04570

0000d7b4 <.LVL28>:
}
    d7b4:	a1 00 04 00 	adda	#4,	r1	;
    d7b8:	b4 16       	popm.a	#12,	r15	;20-bit words
    d7ba:	00 13       	reti			

0000d7bc <.L12>:
  OSAL_IRQ_EPILOGUE();
    d7bc:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d7c0 <.LVL29>:
    d7c0:	80 00 b0 d7 	mova	#55216,	r0	;0x0d7b0

0000d7c4 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    d7c4:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d7c6 <.LCFI6>:
    d7c6:	b1 00 04 00 	suba	#4,	r1	;

0000d7ca <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    d7ca:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d7ce:	6c 05 
    d7d0:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d7d4 <.LVL30>:
  pad = (P4IV >> 1) - 1;
    d7d4:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    d7d8:	3e 02 
    d7da:	12 c3       	clrc			
    d7dc:	0c 10       	rrc	r12		;
    d7de:	7c 53       	add.b	#-1,	r12	;r3 As==11
    d7e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000d7e4 <.LVL31>:
  cb = port_callback_map[3][pad];
    d7e4:	4c 0e       	rlam.a	#4,	r12	;
    d7e6:	4c 0d       	rram.a	#4,	r12	;

0000d7e8 <.LVL32>:
    d7e8:	ac 00 18 00 	adda	#24,	r12	;0x00018
    d7ec:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d7ee:	40 18 3c 41 	popx.w	r12		;
    d7f2:	40 18 3d 41 	popx.w	r13		;
    d7f6:	0e 4c       	mov	r12,	r14	;
    d7f8:	0f 4d       	mov	r13,	r15	;
    d7fa:	0e 5e       	rla	r14		;
    d7fc:	0f 6f       	rlc	r15		;
    d7fe:	0e 5e       	rla	r14		;
    d800:	0f 6f       	rlc	r15		;
    d802:	81 4e 00 00 	mov	r14,	0(r1)	;
    d806:	81 4f 02 00 	mov	r15,	2(r1)	;
    d80a:	0d 01       	mova	@r1,	r13	;
    d80c:	80 18 5c 4d 	movx.a	66926(r13),r12	;0x1056e
    d810:	6e 05 

0000d812 <.LVL33>:
  if (cb != NULL) {
    d812:	9c 00 00 00 	cmpa	#0,	r12	;
    d816:	01 24       	jz	$+4      	;abs 0xd81a

0000d818 <.Loc.136.1>:
    (*cb)();
    d818:	4c 13       	calla	r12		;

0000d81a <.L14>:
  OSAL_IRQ_EPILOGUE();
    d81a:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d81e <.LVL35>:
    d81e:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d822:	6c 05 
    d824:	b0 13 50 45 	calla	#17744		;0x04550

0000d828 <.LVL36>:
    d828:	b0 13 04 49 	calla	#18692		;0x04904

0000d82c <.LVL37>:
    d82c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d82e:	06 20       	jnz	$+14     	;abs 0xd83c

0000d830 <.L15>:
    d830:	b0 13 70 45 	calla	#17776		;0x04570

0000d834 <.LVL38>:
}
    d834:	a1 00 04 00 	adda	#4,	r1	;
    d838:	b4 16       	popm.a	#12,	r15	;20-bit words
    d83a:	00 13       	reti			

0000d83c <.L16>:
  OSAL_IRQ_EPILOGUE();
    d83c:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d840 <.LVL39>:
    d840:	80 00 30 d8 	mova	#55344,	r0	;0x0d830

0000d844 <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    d844:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d846 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    d846:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d84a:	6c 05 
    d84c:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d850 <.LVL6>:
  index = (DMAIV >> 1) - 1;
    d850:	40 18 1a 42 	movx.w	&0x0050e,r10	;
    d854:	0e 05 
    d856:	12 c3       	clrc			
    d858:	0a 10       	rrc	r10		;
    d85a:	7a 53       	add.b	#-1,	r10	;r3 As==11
    d85c:	49 4a       	mov.b	r10,	r9	;

0000d85e <.LVL7>:
  if (index < MSP430X_DMA_CHANNELS) {
    d85e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    d860:	4c 9a       	cmp.b	r10,	r12	;
    d862:	0f 2c       	jc	$+32     	;abs 0xd882

0000d864 <.L3>:
  OSAL_IRQ_EPILOGUE();
    d864:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d868 <.LVL9>:
    d868:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d86c:	6c 05 
    d86e:	b0 13 50 45 	calla	#17744		;0x04550

0000d872 <.LVL10>:
    d872:	b0 13 04 49 	calla	#18692		;0x04904

0000d876 <.LVL11>:
    d876:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d878:	40 20       	jnz	$+130    	;abs 0xd8fa

0000d87a <.L4>:
    d87a:	b0 13 70 45 	calla	#17776		;0x04570

0000d87e <.LVL12>:
}
    d87e:	b4 16       	popm.a	#12,	r15	;20-bit words
    d880:	00 13       	reti			

0000d882 <.L5>:
    dma_regs[index].ctl &= ~DMAEN;
    d882:	4c 4a       	mov.b	r10,	r12	;
    d884:	0d 43       	clr	r13		;
    d886:	b0 13 00 9f 	calla	#40704		;0x09f00
    d88a:	0d 12       	push	r13		;
    d88c:	0c 12       	push	r12		;
    d88e:	08 16       	popm.a	#1,	r8	;20-bit words
    d890:	a8 00 10 05 	adda	#1296,	r8	;0x00510
    d894:	b8 f0 ef ff 	and	#-17,	0(r8)	;#0xffef
    d898:	00 00 

0000d89a <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    d89a:	4d 43       	clr.b	r13		;
    d89c:	4c 4a       	mov.b	r10,	r12	;
    d89e:	b0 13 2c 54 	calla	#21548		;0x0542c

0000d8a2 <.LVL15>:
    dma_regs[index].sz  = 0;
    d8a2:	88 43 0a 00 	mov	#0,	10(r8)	;r3 As==00, 0x000a

0000d8a6 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    d8a6:	b8 40 12 00 	mov	#18,	0(r8)	;#0x0012
    d8aa:	00 00 

0000d8ac <.Loc.87.1>:
    if (cb->callback != NULL) {
    d8ac:	0d 49       	mov	r9,	r13	;
    d8ae:	4d 0e       	rlam.a	#4,	r13	;
    d8b0:	4d 0d       	rram.a	#4,	r13	;
    d8b2:	0d 14       	pushm.a	#1,	r13	;20-bit words
    d8b4:	40 18 3c 41 	popx.w	r12		;
    d8b8:	40 18 3d 41 	popx.w	r13		;
    d8bc:	b0 13 04 9f 	calla	#40708		;0x09f04
    d8c0:	0d 12       	push	r13		;
    d8c2:	0c 12       	push	r12		;
    d8c4:	0c 16       	popm.a	#1,	r12	;20-bit words
    d8c6:	00 18 5a 4c 	movx.a	54122(r12),r10	;0x0d36a
    d8ca:	6a d3 

0000d8cc <.LVL18>:
    d8cc:	9a 00 00 00 	cmpa	#0,	r10	;
    d8d0:	c9 27       	jz	$-108    	;abs 0xd864

0000d8d2 <.Loc.88.1>:
      cb->callback(cb->args);
    d8d2:	0d 49       	mov	r9,	r13	;
    d8d4:	4d 0e       	rlam.a	#4,	r13	;
    d8d6:	4d 0d       	rram.a	#4,	r13	;
    d8d8:	0d 14       	pushm.a	#1,	r13	;20-bit words
    d8da:	40 18 3c 41 	popx.w	r12		;
    d8de:	40 18 3d 41 	popx.w	r13		;
    d8e2:	b0 13 04 9f 	calla	#40708		;0x09f04
    d8e6:	0d 12       	push	r13		;
    d8e8:	0c 12       	push	r12		;
    d8ea:	0c 16       	popm.a	#1,	r12	;20-bit words
    d8ec:	ac 00 6a d3 	adda	#54122,	r12	;0x0d36a
    d8f0:	3c 0c 04 00 	mova	4(r12),	r12	;
    d8f4:	4a 13       	calla	r10		;

0000d8f6 <.LVL20>:
    d8f6:	80 00 64 d8 	mova	#55396,	r0	;0x0d864

0000d8fa <.L6>:
  OSAL_IRQ_EPILOGUE();
    d8fa:	b0 13 1c 49 	calla	#18716		;0x0491c

0000d8fe <.LVL22>:
    d8fe:	80 00 7a d8 	mova	#55418,	r0	;0x0d87a

0000d902 <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    d902:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d904 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    d904:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    d908:	6c 05 
    d90a:	b0 13 d6 45 	calla	#17878		;0x045d6

0000d90e <.LVL109>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    d90e:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    d912:	fe 05 
    d914:	2c 92       	cmp	#4,	r12	;r2 As==10
    d916:	6b 24       	jz	$+216    	;abs 0xd9ee
    d918:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d91a:	0d 9c       	cmp	r12,	r13	;
    d91c:	1c 2c       	jc	$+58     	;abs 0xd956
    d91e:	3c 90 06 00 	cmp	#6,	r12	;
    d922:	65 24       	jz	$+204    	;abs 0xd9ee
    d924:	3c 92       	cmp	#8,	r12	;r2 As==11
    d926:	67 20       	jnz	$+208    	;abs 0xd9f6

0000d928 <.Loc.323.1>:
      _uart_tx2_isr_code(&UARTDA1);
    d928:	2c 01 f2 05 	mova	&67058,	r12	;0x105f2
    d92c:	3e 0c 04 00 	mova	4(r12),	r14	;
    d930:	9e 00 00 00 	cmpa	#0,	r14	;
    d934:	03 24       	jz	$+8      	;abs 0xd93c

0000d936 <.Loc.323.1>:
    d936:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    d93a:	4e 13       	calla	r14		;

0000d93c <.L82>:
    d93c:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    d940:	cc 93 08 00 	cmp.b	#0,	8(r12)	;r3 As==00
    d944:	67 24       	jz	$+208    	;abs 0xda14

0000d946 <.L83>:
      UCA1IE &= ~UCTXCPTIE;
    d946:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    d94a:	fa 05 

0000d94c <.Loc.327.1>:
      UCA1IFG &= ~UCTXCPTIFG;
    d94c:	40 18 b2 c2 	bicx.w	#8,	&0x005fc;r2 As==11
    d950:	fc 05 

0000d952 <.Loc.328.1>:
      break;
    d952:	80 00 f6 d9 	mova	#55798,	r0	;0x0d9f6

0000d956 <.L86>:
  switch(__even_in_range(UCA1IV, UCTXCPTIFG)) {
    d956:	2c 93       	cmp	#2,	r12	;r3 As==10
    d958:	4e 20       	jnz	$+158    	;abs 0xd9f6

0000d95a <.Loc.292.1>:
      if (UCA1STATW & UCRXERR) {
    d95a:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    d95e:	ea 05 
    d960:	2d 24       	jz	$+92     	;abs 0xd9bc

0000d962 <.LBB43>:
        if (UCA1STATW & UCBRK)
    d962:	40 18 f2 b2 	bitx.b	#8,	&0x005ea;r2 As==11
    d966:	ea 05 
    d968:	38 20       	jnz	$+114    	;abs 0xd9da

0000d96a <.Loc.294.1>:
        uartflags_t sts = 0;
    d96a:	4d 43       	clr.b	r13		;
    d96c:	0e 4d       	mov	r13,	r14	;

0000d96e <.L76>:
        if (UCA1STATW & UCOE)
    d96e:	40 18 f2 b0 	bitx.b	#32,	&0x005ea;0x00020
    d972:	20 00 ea 05 
    d976:	02 24       	jz	$+6      	;abs 0xd97c

0000d978 <.Loc.299.1>:
          sts |= UART_OVERRUN_ERROR;
    d978:	3d d0 10 00 	bis	#16,	r13	;#0x0010

0000d97c <.L77>:
        if (UCA1STATW & UCFE)
    d97c:	40 18 f2 b0 	bitx.b	#64,	&0x005ea;0x00040
    d980:	40 00 ea 05 
    d984:	01 24       	jz	$+4      	;abs 0xd988

0000d986 <.Loc.301.1>:
          sts |= UART_FRAMING_ERROR;
    d986:	3d d2       	bis	#8,	r13	;r2 As==11

0000d988 <.L78>:
        if (UCA1STATW & UCPE)
    d988:	40 18 f2 b0 	bitx.b	#16,	&0x005ea;0x00010
    d98c:	10 00 ea 05 
    d990:	01 24       	jz	$+4      	;abs 0xd994

0000d992 <.Loc.303.1>:
          sts |= UART_PARITY_ERROR;
    d992:	2d d2       	bis	#4,	r13	;r2 As==10

0000d994 <.L79>:
        _uart_rx_error_isr_code(&UARTDA1, sts);
    d994:	2c 01 f2 05 	mova	&67058,	r12	;0x105f2
    d998:	3a 0c 10 00 	mova	16(r12),r10	;0x00010
    d99c:	9a 00 00 00 	cmpa	#0,	r10	;
    d9a0:	03 24       	jz	$+8      	;abs 0xd9a8

0000d9a2 <.Loc.305.1>:
    d9a2:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    d9a6:	4a 13       	calla	r10		;

0000d9a8 <.L80>:
  chSysLockFromISR();
    d9a8:	b0 13 92 45 	calla	#17810		;0x04592

0000d9ac <.LBB46>:
  chThdResumeI(trp, msg);
    d9ac:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    d9b0:	8c 01 f8 05 	mova	#67064,	r12	;0x105f8

0000d9b4 <.LVL118>:
    d9b4:	b0 13 a6 49 	calla	#18854		;0x049a6

0000d9b8 <.LBB48>:
  chSysUnlockFromISR();
    d9b8:	b0 13 b4 45 	calla	#17844		;0x045b4

0000d9bc <.L75>:
      if (UARTDA1.config->rxchar_cb != NULL) {
    d9bc:	2c 01 f2 05 	mova	&67058,	r12	;0x105f2
    d9c0:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    d9c4:	9e 00 00 00 	cmpa	#0,	r14	;
    d9c8:	0d 24       	jz	$+28     	;abs 0xd9e4

0000d9ca <.Loc.310.1>:
        UARTDA1.config->rxchar_cb(&UARTDA1, UCA1RXBUF);
    d9ca:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    d9ce:	ec 05 
    d9d0:	8c 01 ee 05 	mova	#67054,	r12	;0x105ee
    d9d4:	4e 13       	calla	r14		;

0000d9d6 <.LVL121>:
    d9d6:	80 00 f6 d9 	mova	#55798,	r0	;0x0d9f6

0000d9da <.L85>:
          sts |= UART_BREAK_DETECTED;
    d9da:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    d9de:	4e 43       	clr.b	r14		;
    d9e0:	80 00 6e d9 	mova	#55662,	r0	;0x0d96e

0000d9e4 <.L81>:
        UCA1IFG &= ~UCRXIFG;
    d9e4:	40 18 92 c3 	bicx.w	#1,	&0x005fc;r3 As==01
    d9e8:	fc 05 
    d9ea:	80 00 f6 d9 	mova	#55798,	r0	;0x0d9f6

0000d9ee <.L71>:
      osalDbgAssert(false, "Spurious interrupt in USCI A1 UART");
    d9ee:	8c 01 dd 02 	mova	#66269,	r12	;0x102dd
    d9f2:	b0 13 a0 47 	calla	#18336		;0x047a0

0000d9f6 <.L70>:
  OSAL_IRQ_EPILOGUE();
    d9f6:	b0 13 fc 45 	calla	#17916		;0x045fc

0000d9fa <.LVL125>:
    d9fa:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    d9fe:	6c 05 
    da00:	b0 13 50 45 	calla	#17744		;0x04550

0000da04 <.LVL126>:
    da04:	b0 13 04 49 	calla	#18692		;0x04904

0000da08 <.LVL127>:
    da08:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    da0a:	0f 20       	jnz	$+32     	;abs 0xda2a

0000da0c <.L84>:
    da0c:	b0 13 70 45 	calla	#17776		;0x04570

0000da10 <.LVL128>:
}
    da10:	b4 16       	popm.a	#12,	r15	;20-bit words
    da12:	00 13       	reti			

0000da14 <.L87>:
  chSysLockFromISR();
    da14:	b0 13 92 45 	calla	#17810		;0x04592

0000da18 <.LBB53>:
  chThdResumeI(trp, msg);
    da18:	4d 43       	clr.b	r13		;
    da1a:	8c 01 fc 05 	mova	#67068,	r12	;0x105fc

0000da1e <.LVL130>:
    da1e:	b0 13 a6 49 	calla	#18854		;0x049a6

0000da22 <.LBB55>:
  chSysUnlockFromISR();
    da22:	b0 13 b4 45 	calla	#17844		;0x045b4

0000da26 <.LVL132>:
    da26:	80 00 46 d9 	mova	#55622,	r0	;0x0d946

0000da2a <.L88>:
  OSAL_IRQ_EPILOGUE();
    da2a:	b0 13 1c 49 	calla	#18716		;0x0491c

0000da2e <.LVL133>:
    da2e:	80 00 0c da 	mova	#55820,	r0	;0x0da0c

0000da32 <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    da32:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000da34 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    da34:	41 18 d2 43 	movx.b	#1,	&0x1056c;r3 As==01
    da38:	6c 05 
    da3a:	b0 13 d6 45 	calla	#17878		;0x045d6

0000da3e <.LVL22>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    da3e:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    da42:	ae 03 
    da44:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    da48:	0c 20       	jnz	$+26     	;abs 0xda62

0000da4a <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    da4a:	c0 18 5c 42 	movx.b	&0x10652,r12	;
    da4e:	52 06 
    da50:	7c 50 fd ff 	add.b	#-3,	r12	;#0xfffd
    da54:	5d 43       	mov.b	#1,	r13	;r3 As==01
    da56:	4d 9c       	cmp.b	r12,	r13	;
    da58:	13 2c       	jc	$+40     	;abs 0xda80

0000da5a <.L25>:
      if (GPTDA1.state == GPT_ONESHOT) {
    da5a:	41 18 e2 92 	cmpx.b	#4,	&0x10652;r2 As==10
    da5e:	52 06 
    da60:	1b 24       	jz	$+56     	;abs 0xda98

0000da62 <.L23>:
  OSAL_IRQ_EPILOGUE();
    da62:	b0 13 fc 45 	calla	#17916		;0x045fc

0000da66 <.LVL23>:
    da66:	41 18 c2 43 	movx.b	#0,	&0x1056c;r3 As==00
    da6a:	6c 05 
    da6c:	b0 13 50 45 	calla	#17744		;0x04550

0000da70 <.LVL24>:
    da70:	b0 13 04 49 	calla	#18692		;0x04904

0000da74 <.LVL25>:
    da74:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    da76:	18 20       	jnz	$+50     	;abs 0xdaa8

0000da78 <.L26>:
    da78:	b0 13 70 45 	calla	#17776		;0x04570

0000da7c <.LVL26>:
}
    da7c:	b4 16       	popm.a	#12,	r15	;20-bit words
    da7e:	00 13       	reti			

0000da80 <.L27>:
          NULL != GPTDA1.config->callback) {
    da80:	2c 01 54 06 	mova	&67156,	r12	;0x10654
    da84:	3e 0c 04 00 	mova	4(r12),	r14	;

0000da88 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    da88:	9e 00 00 00 	cmpa	#0,	r14	;
    da8c:	e6 27       	jz	$-50     	;abs 0xda5a

0000da8e <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    da8e:	8c 01 52 06 	mova	#67154,	r12	;0x10652
    da92:	4e 13       	calla	r14		;

0000da94 <.LVL27>:
    da94:	80 00 5a da 	mova	#55898,	r0	;0x0da5a

0000da98 <.L28>:
        GPTDA1.state = GPT_READY;
    da98:	8c 01 52 06 	mova	#67154,	r12	;0x10652
    da9c:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000daa0 <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    daa0:	b0 13 40 5e 	calla	#24128		;0x05e40

0000daa4 <.LVL28>:
    daa4:	80 00 62 da 	mova	#55906,	r0	;0x0da62

0000daa8 <.L29>:
  OSAL_IRQ_EPILOGUE();
    daa8:	b0 13 1c 49 	calla	#18716		;0x0491c

0000daac <.LVL29>:
    daac:	80 00 78 da 	mova	#55928,	r0	;0x0da78
