
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	34 de       	bis	@r14+,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	38 de       	bis	@r14+,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	3c de       	bis	@r14+,	r12	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	40 de       	bis.b	r14,	r0	;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	44 de       	bis.b	r14,	r4	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	48 de       	bis.b	r14,	r8	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	4c de       	bis.b	r14,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	50 de       	bis.b,		r0	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	54 de       	bis.b,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	58 de       	bis.b,		r8	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	5c de       	bis.b,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	60 de       	bis.b	@r14,	r0	;

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	64 de       	bis.b	@r14,	r4	;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	68 de       	bis.b	@r14,	r8	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	6c de       	bis.b	@r14,	r12	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	70 de       	bis.b	@r14+,	r0	;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	74 de       	bis.b	@r14+,	r4	;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	78 de       	bis.b	@r14+,	r8	;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	7c de       	bis.b	@r14+,	r12	;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	80 de 00 00 	bis	r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	84 de       	bis	r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	88 de       	bis	r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	8c de       	bis	r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	90 de 00 00 	bis			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	94 de       	bis			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	98 de       	bis			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	9c de       	bis			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	a0 de 00 00 	bis	@r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	a4 de       	bis	@r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	a8 de       	bis	@r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	ac de       	bis	@r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	b0 de 00 00 	bis	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	c0 d9 00 00 	bis.b	r9		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	54 d9       	bis.b,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	ca dc       	bis.b	r12		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	b4 de       	bis	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	e8 d8       	bis.b	@r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	b8 de       	bis	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	bc de       	bis	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	8c d8       	bis	r8		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	6a dc       	interrupt service routine at 0xdc6a

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	c0 de       	interrupt service routine at 0xdec0

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	2c da       	interrupt service routine at 0xda2c

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	92 d7       	interrupt service routine at 0xd792

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	0a dc       	interrupt service routine at 0xdc0a

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	c4 de       	interrupt service routine at 0xdec4

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	2a dd       	interrupt service routine at 0xdd2a

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	be da       	interrupt service routine at 0xdabe

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	c8 de       	interrupt service routine at 0xdec8

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	cc de       	interrupt service routine at 0xdecc

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	70 d7       	interrupt service routine at 0xd770

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	d0 de       	interrupt service routine at 0xded0

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	d4 de       	interrupt service routine at 0xded4

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	d8 de       	interrupt service routine at 0xded8

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	81 00 d0 d4 	mova	#54480,	r1	;0x0d4d0

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    4408:	80 5a 5c 01 

0000440c <__crt0_init_highbss>:
    440c:	8c 01 ec 12 	mova	#70380,	r12	;0x112ec

00004410 <.Loc.94.1>:
    4410:	0d 43       	clr	r13		;

00004412 <.Loc.95.1>:
    4412:	8e 01 a4 39 	mova	#80292,	r14	;0x139a4

00004416 <.Loc.98.1>:
    4416:	0e 93       	cmp	#0,	r14	;r3 As==00

00004418 <.Loc.99.1>:
    4418:	02 24       	jz	$+6      	;abs 0x441e

0000441a <.Loc.100.1>:
    441a:	b0 13 60 d3 	calla	#54112		;0x0d360

0000441e <__crt0_move_highdata>:
    441e:	3e 40 88 08 	mov	#2184,	r14	;#0x0888

00004422 <.Loc.146.1>:
    4422:	0e 93       	cmp	#0,	r14	;r3 As==00

00004424 <.Loc.147.1>:
    4424:	14 24       	jz	$+42     	;abs 0x444e

00004426 <.Loc.150.1>:
    4426:	41 18 82 93 	cmpx.w	#0,	&0x101da;r3 As==00
    442a:	da 01 

0000442c <.Loc.151.1>:
    442c:	05 24       	jz	$+12     	;abs 0x4438

0000442e <.Loc.153.1>:
    442e:	8c 01 dc 01 	mova	#66012,	r12	;0x101dc

00004432 <.Loc.154.1>:
    4432:	8d 01 64 0a 	mova	#68196,	r13	;0x10a64

00004436 <.Loc.155.1>:
    4436:	07 3c       	jmp	$+16     	;abs 0x4446

00004438 <.L11>:
    4438:	41 18 92 43 	movx.w	#1,	&0x101da;r3 As==01
    443c:	da 01 

0000443e <.Loc.159.1>:
    443e:	8c 01 64 0a 	mova	#68196,	r12	;0x10a64

00004442 <.Loc.160.1>:
    4442:	8d 01 dc 01 	mova	#66012,	r13	;0x101dc

00004446 <.L21>:
    4446:	3e 40 88 08 	mov	#2184,	r14	;#0x0888

0000444a <.Loc.165.1>:
    444a:	b0 13 7a d3 	calla	#54138		;0x0d37a

0000444e <__crt0_call_just_main>:
    444e:	0c 43       	clr	r12		;

00004450 <.Loc.181.1>:
    4450:	b0 13 ae cd 	calla	#52654		;0x0cdae

00004454 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    4454:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    4458:	36 13 

0000445a <.Loc.305.1>:
}
    445a:	10 01       	reta			;

0000445c <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    445c:	03 43       	nop			

0000445e <.Loc.356.1>:
  _enable_interrupts();
    445e:	03 43       	nop			
    4460:	32 d2       	eint			
    4462:	03 43       	nop			

00004464 <.Loc.357.1>:
}
    4464:	10 01       	reta			;

00004466 <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    4466:	32 c2       	dint			
    4468:	03 43       	nop			

0000446a <.Loc.390.1>:
  asm volatile("nop");
    446a:	03 43       	nop			

0000446c <.Loc.391.1>:
}
    446c:	10 01       	reta			;

0000446e <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    446e:	b1 00 14 00 	suba	#20,	r1	;0x00014

00004472 <.LCFI0>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    4472:	80 18 f1 40 	movx.a	#70390,	16(r1)	;0x112f6, 0x00010
    4476:	f6 12 10 00 

0000447a <.Loc.234.2>:
  tcp = nil_thd_configs;
    447a:	80 18 f1 40 	movx.a	#65930,	12(r1)	;0x1018a, 0x0000c
    447e:	8a 01 0c 00 

00004482 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4482:	80 00 40 45 	mova	#17728,	r0	;0x04540

00004486 <.L6>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4486:	3c 01 0c 00 	mova	12(r1),	r12	;0x0000c
    448a:	3c 0c 04 00 	mova	4(r12),	r12	;
    448e:	cd 0c       	mova	r12,	r13	;
    4490:	ad 0f e0 ff 	adda	#1048544,r13	;0xfffe0
    4494:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4498:	7c 0d 00 00 	mova	r13,	0(r12)	;
    449c:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    44a0:	0c 0c       	mova	@r12,	r12	;
    44a2:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    44a6:	3d 0d 0c 00 	mova	12(r13),r13	;0x0000c
    44aa:	71 0d 08 00 	mova	r13,	8(r1)	;
    44ae:	9c 41 08 00 	mov	8(r1),	0(r12)	;
    44b2:	00 00 
    44b4:	3e 01 08 00 	mova	8(r1),	r14	;
    44b8:	0e 14       	pushm.a	#1,	r14	;20-bit words
    44ba:	0d 17       	popm	#1,	r13	;16-bit words
    44bc:	0d 17       	popm	#1,	r13	;16-bit words
    44be:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    44c2:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    44c6:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    44ca:	4d de       	bis.b	r14,	r13	;
    44cc:	cc 4d 02 00 	mov.b	r13,	2(r12)	;
    44d0:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    44d4:	0c 0c       	mova	@r12,	r12	;
    44d6:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    44da:	3d 0d 10 00 	mova	16(r13),r13	;0x00010
    44de:	71 0d 04 00 	mova	r13,	4(r1)	;
    44e2:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    44e6:	04 00 
    44e8:	3e 01 04 00 	mova	4(r1),	r14	;
    44ec:	0e 14       	pushm.a	#1,	r14	;20-bit words
    44ee:	0d 17       	popm	#1,	r13	;16-bit words
    44f0:	0d 17       	popm	#1,	r13	;16-bit words
    44f2:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    44f6:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    44fa:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    44fe:	4d de       	bis.b	r14,	r13	;
    4500:	cc 4d 06 00 	mov.b	r13,	6(r12)	;
    4504:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    4508:	0c 0c       	mova	@r12,	r12	;
    450a:	00 18 f1 40 	movx.a	#19012,	0(r1)	;0x04a44
    450e:	44 4a 00 00 
    4512:	ac 41 1c 00 	mov	@r1,	28(r12)	; 0x001c
    4516:	0e 01       	mova	@r1,	r14	;
    4518:	0e 14       	pushm.a	#1,	r14	;20-bit words
    451a:	0d 17       	popm	#1,	r13	;16-bit words
    451c:	0d 17       	popm	#1,	r13	;16-bit words
    451e:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4522:	5e 4c 1e 00 	mov.b	30(r12),r14	;0x0001e
    4526:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    452a:	4d de       	bis.b	r14,	r13	;
    452c:	cc 4d 1e 00 	mov.b	r13,	30(r12)	; 0x001e

00004530 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    4530:	00 18 f1 50 	addx.a	#16,	16(r1)	;0x00010, 0x00010
    4534:	10 00 10 00 

00004538 <.Loc.247.2>:
    tcp++;
    4538:	00 18 f1 50 	addx.a	#20,	12(r1)	;0x00014, 0x0000c
    453c:	14 00 0c 00 

00004540 <.L5>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    4540:	80 18 f1 90 	cmpx.a	#70438,	16(r1)	;0x11326, 0x00010
    4544:	26 13 10 00 
    4548:	9e 2b       	jnc	$-194    	;abs 0x4486

0000454a <.Loc.258.2>:
  tp->wabase  = THD_IDLE_BASE;
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    454a:	b0 13 66 44 	calla	#17510		;0x04466

0000454e <.LVL4>:
  _heap_init();
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    454e:	b0 13 54 44 	calla	#17492		;0x04454

00004552 <.LVL5>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    4552:	81 18 f2 40 	movx.a	#70390,	&0x112f0;0x112f6
    4556:	f6 12 f0 12 
    455a:	2c 01 f0 12 	mova	&70384,	r12	;0x112f0
    455e:	61 0c ec 12 	mova	r12,	&70380	; 0x112ec

00004562 <.Loc.275.2>:
  port_switch(nil.current, tp);
    4562:	2c 01 ec 12 	mova	&70380,	r12	;0x112ec
    4566:	3d 01 10 00 	mova	16(r1),	r13	;0x00010
    456a:	b0 13 34 4a 	calla	#18996		;0x04a34

0000456e <.LVL6>:
  chSysUnlock();
    456e:	b0 13 5c 44 	calla	#17500		;0x0445c

00004572 <.LVL7>:
}
    4572:	03 43       	nop			
    4574:	a1 00 14 00 	adda	#20,	r1	;0x00014
    4578:	10 01       	reta			;

0000457a <chSysHalt>:
 *
 * @special
 */
void chSysHalt(const char *reason) {

  port_disable();
    457a:	b0 13 66 44 	calla	#17510		;0x04466

0000457e <.L8>:
    457e:	80 00 7e 45 	mova	#17790,	r0	;0x0457e

00004582 <chSysTimerHandlerI>:
 * @note    This handler has to be invoked by a periodic ISR in order to
 *          reschedule the waiting threads.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
    4582:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004584 <.LCFI1>:
    4584:	08 14       	pushm.a	#1,	r8	;20-bit words

00004586 <.LCFI2>:
    4586:	06 14       	pushm.a	#1,	r6	;20-bit words

00004588 <.LCFI3>:

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    4588:	88 01 ec 12 	mova	#70380,	r8	;0x112ec
    458c:	98 53 08 00 	inc	8(r8)		;
    4590:	a8 00 10 00 	adda	#16,	r8	;0x00010

00004594 <.Loc.341.2>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4594:	8a 00 2e 46 	mova	#17966,	r10	;0x0462e
    4598:	86 0f ff ff 	mova	#-1,	r6	;0xffffffff

0000459c <.L15>:
    459c:	cc 08       	mova	r8,	r12	;
    459e:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

000045a2 <.LVL12>:
    if (tp->timeout > (systime_t)0) {
    45a2:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    45a6:	0d 93       	cmp	#0,	r13	;r3 As==00
    45a8:	11 24       	jz	$+36     	;abs 0x45cc

000045aa <.Loc.330.2>:
      if (--tp->timeout == (systime_t)0) {
    45aa:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    45ae:	3d 53       	add	#-1,	r13	;r3 As==11
    45b0:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a
    45b4:	0d 93       	cmp	#0,	r13	;r3 As==00
    45b6:	0a 20       	jnz	$+22     	;abs 0x45cc

000045b8 <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    45b8:	5d 48 fe ff 	mov.b	-2(r8),	r13	;
    45bc:	7d 90 03 00 	cmp.b	#3,	r13	;
    45c0:	14 20       	jnz	$+42     	;abs 0x45ea

000045c2 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    45c2:	0e 08       	mova	@r8,	r14	;
    45c4:	9e 53 00 00 	inc	0(r14)		;

000045c8 <.L14>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    45c8:	cd 06       	mova	r6,	r13	;
    45ca:	4a 13       	calla	r10		;

000045cc <.L11>:
    45cc:	cc 08       	mova	r8,	r12	;
    45ce:	ac 00 10 00 	adda	#16,	r12	;0x00010

000045d2 <.Loc.349.2>:
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    tp++;
    chSysLockFromISR();
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    45d2:	a8 00 0a 00 	adda	#10,	r8	;0x0000a

000045d6 <.LVL14>:
    45d6:	98 01 26 13 	cmpa	#70438,	r8	;0x11326
    45da:	04 28       	jnc	$+10     	;abs 0x45e4

000045dc <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    45dc:	06 16       	popm.a	#1,	r6	;20-bit words
    45de:	08 16       	popm.a	#1,	r8	;20-bit words
    45e0:	0a 16       	popm.a	#1,	r10	;20-bit words
    45e2:	10 01       	reta			;

000045e4 <.L16>:
    45e4:	c8 0c       	mova	r12,	r8	;

000045e6 <.LVL15>:
    45e6:	80 00 9c 45 	mova	#17820,	r0	;0x0459c

000045ea <.L13>:
        else if (NIL_THD_IS_SUSP(tp)) {
    45ea:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    45ec:	ed 23       	jnz	$-36     	;abs 0x45c8

000045ee <.Loc.338.2>:
          *tp->u1.trp = NULL;
    45ee:	0e 08       	mova	@r8,	r14	;
    45f0:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    45f4:	00 00 
    45f6:	80 00 c8 45 	mova	#17864,	r0	;0x045c8

000045fa <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    45fa:	0a 14       	pushm.a	#1,	r10	;20-bit words

000045fc <.LBB36>:
  return __get_SR_register();
    45fc:	0a 42       	mov	r2,	r10	;

000045fe <.LBE36>:

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    45fe:	40 18 3a b2 	bitx.w	#8,	r10	;r2 As==11
    4602:	06 24       	jz	$+14     	;abs 0x4610

00004604 <.Loc.450.2>:
    if (port_is_isr_context()) {
    4604:	41 18 c2 93 	cmpx.b	#0,	&0x11336;r3 As==00
    4608:	36 13 
    460a:	02 20       	jnz	$+6      	;abs 0x4610

0000460c <.Loc.454.2>:
      chSysLockFromISR();
    }
    else {
      chSysLock();
    460c:	b0 13 66 44 	calla	#17510		;0x04466

00004610 <.L25>:
    }
  }
  return sts;
}
    4610:	0c 4a       	mov	r10,	r12	;
    4612:	0a 16       	popm.a	#1,	r10	;20-bit words
    4614:	10 01       	reta			;

00004616 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    4616:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    461a:	08 24       	jz	$+18     	;abs 0x462c

0000461c <.Loc.472.2>:
    if (port_is_isr_context()) {
    461c:	41 18 c2 93 	cmpx.b	#0,	&0x11336;r3 As==00
    4620:	36 13 
    4622:	04 20       	jnz	$+10     	;abs 0x462c

00004624 <.Loc.476.2>:
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    4624:	b0 13 90 46 	calla	#18064		;0x04690

00004628 <.LVL21>:
      chSysUnlock();
    4628:	b0 13 5c 44 	calla	#17500		;0x0445c

0000462c <.L29>:
    }
  }
}
    462c:	10 01       	reta			;

0000462e <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    462e:	b1 00 04 00 	suba	#4,	r1	;

00004632 <.LCFI5>:
    4632:	71 0d 00 00 	mova	r13,	0(r1)	;

00004636 <.Loc.541.2>:
  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    4636:	ac 41 06 00 	mov	@r1,	6(r12)	;
    463a:	0d 14       	pushm.a	#1,	r13	;20-bit words
    463c:	0d 17       	popm	#1,	r13	;16-bit words
    463e:	0d 17       	popm	#1,	r13	;16-bit words

00004640 <.LVL24>:
    4640:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4644:	5e 4c 08 00 	mov.b	8(r12),	r14	;
    4648:	7e f0 f0 ff 	and.b	#-16,	r14	;#0xfff0
    464c:	4e dd       	bis.b	r13,	r14	;
    464e:	cc 4e 08 00 	mov.b	r14,	8(r12)	;

00004652 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    4652:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

00004656 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    4656:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000465a <.Loc.544.2>:
  if (tp < nil.next) {
    465a:	80 18 5c 92 	cmpx.a	&0x112f0,r12	;
    465e:	f0 12 
    4660:	02 2c       	jc	$+6      	;abs 0x4666

00004662 <.Loc.545.2>:
    nil.next = tp;
    4662:	61 0c f0 12 	mova	r12,	&70384	; 0x112f0

00004666 <.L35>:
  }
  return tp;
}
    4666:	a1 00 04 00 	adda	#4,	r1	;

0000466a <.LVL25>:
    466a:	10 01       	reta			;

0000466c <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    466c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    466e:	81 18 d2 92 	cmpx.a	&0x112f0,&0x112ec;
    4672:	f0 12 ec 12 
    4676:	01 20       	jnz	$+4      	;abs 0x467a
    4678:	4c 43       	clr.b	r12		;

0000467a <.L37>:
}
    467a:	10 01       	reta			;

0000467c <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    467c:	8e 01 ec 12 	mova	#70380,	r14	;0x112ec
    4680:	0d 0e       	mova	@r14,	r13	;

00004682 <.LVL26>:

  nil.current = nil.next;
    4682:	3c 0e 04 00 	mova	4(r14),	r12	;
    4686:	7e 0c 00 00 	mova	r12,	0(r14)	;

0000468a <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    468a:	b0 13 34 4a 	calla	#18996		;0x04a34

0000468e <.LVL27>:
}
    468e:	10 01       	reta			;

00004690 <chSchRescheduleS>:
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    4690:	81 18 d2 92 	cmpx.a	&0x112f0,&0x112ec;
    4694:	f0 12 ec 12 
    4698:	02 24       	jz	$+6      	;abs 0x469e

0000469a <.Loc.595.2>:
    chSchDoReschedule();
    469a:	b0 13 7c 46 	calla	#18044		;0x0467c

0000469e <.L39>:
  }
}
    469e:	10 01       	reta			;

000046a0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    46a0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000046a2 <.LCFI6>:
    46a2:	08 14       	pushm.a	#1,	r8	;20-bit words

000046a4 <.LCFI7>:
  thread_t *ntp, *otp = nil.current;
    46a4:	8a 01 ec 12 	mova	#70380,	r10	;0x112ec
    46a8:	08 0a       	mova	@r10,	r8	;

000046aa <.Loc.625.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    46aa:	c8 4c 04 00 	mov.b	r12,	4(r8)	;

000046ae <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    46ae:	88 4d 0a 00 	mov	r13,	10(r8)	; 0x000a

000046b2 <.LVL31>:
    46b2:	ce 0a       	mova	r10,	r14	;
    46b4:	ae 00 0e 00 	adda	#14,	r14	;0x0000e

000046b8 <.L42>:
    46b8:	cc 0e       	mova	r14,	r12	;
    46ba:	ac 0f fc ff 	adda	#1048572,r12	;0xffffc

000046be <.LVL33>:
    46be:	ae 00 10 00 	adda	#16,	r14	;0x00010

000046c2 <.Loc.667.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    46c2:	ce 93 f0 ff 	cmp.b	#0,	-16(r14);r3 As==00, 0xfff0
    46c6:	f8 23       	jnz	$-14     	;abs 0x46b8

000046c8 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    46c8:	7a 0c 04 00 	mova	r12,	4(r10)	;

000046cc <.LVL34>:
    46cc:	7a 0c 00 00 	mova	r12,	0(r10)	;

000046d0 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    46d0:	cd 08       	mova	r8,	r13	;

000046d2 <.LVL35>:
    46d2:	b0 13 34 4a 	calla	#18996		;0x04a34

000046d6 <.LVL36>:
      return nil.current->u1.msg;
    46d6:	0c 0a       	mova	@r10,	r12	;

000046d8 <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    46d8:	3c 0c 06 00 	mova	6(r12),	r12	;
    46dc:	08 16       	popm.a	#1,	r8	;20-bit words
    46de:	0a 16       	popm.a	#1,	r10	;20-bit words
    46e0:	10 01       	reta			;

000046e2 <chThdSuspendTimeoutS>:
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    46e2:	8e 01 ec 12 	mova	#70380,	r14	;0x112ec
    46e6:	00 18 ec 4e 	movx.a	@r14,	0(r12)	;
    46ea:	00 00 

000046ec <.Loc.702.2>:
  nil.current->u1.trp = trp;
    46ec:	0e 0e       	mova	@r14,	r14	;
    46ee:	7e 0c 06 00 	mova	r12,	6(r14)	;

000046f2 <.Loc.703.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    46f2:	6c 43       	mov.b	#2,	r12	;r3 As==10

000046f4 <.LVL38>:
    46f4:	b0 13 a0 46 	calla	#18080		;0x046a0

000046f8 <.LVL39>:
}
    46f8:	10 01       	reta			;

000046fa <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    46fa:	ce 0c       	mova	r12,	r14	;

000046fc <.Loc.718.2>:

  if (*trp != NULL) {
    46fc:	0c 0c       	mova	@r12,	r12	;

000046fe <.LVL41>:
    46fe:	9c 00 00 00 	cmpa	#0,	r12	;
    4702:	05 24       	jz	$+12     	;abs 0x470e

00004704 <.LBB38>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    4704:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    4708:	00 00 

0000470a <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    470a:	b0 13 2e 46 	calla	#17966		;0x0462e

0000470e <.L45>:
  }
}
    470e:	10 01       	reta			;

00004710 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    4710:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004712 <.LCFI8>:
    4712:	0a 4c       	mov	r12,	r10	;

00004714 <.Loc.737.2>:

  chSysLock();
    4714:	b0 13 66 44 	calla	#17510		;0x04466

00004718 <.LVL45>:
  chThdSleepS(timeout);
    4718:	0d 4a       	mov	r10,	r13	;
    471a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    471c:	b0 13 a0 46 	calla	#18080		;0x046a0

00004720 <.LVL46>:
  chSysUnlock();
    4720:	b0 13 5c 44 	calla	#17500		;0x0445c

00004724 <.LVL47>:
}
    4724:	0a 16       	popm.a	#1,	r10	;20-bit words
    4726:	10 01       	reta			;

00004728 <chSemWaitTimeout>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t timeout) {
    4728:	b1 00 08 00 	suba	#8,	r1	;

0000472c <.LCFI10>:
  msg_t msg;

  chSysLock();
    472c:	71 0c 00 00 	mova	r12,	0(r1)	;
    4730:	71 0d 04 00 	mova	r13,	4(r1)	;
    4734:	b0 13 66 44 	calla	#17510		;0x04466

00004738 <.LVL54>:
  msg = chSemWaitTimeoutS(sp, timeout);
    4738:	3d 01 04 00 	mova	4(r1),	r13	;
    473c:	0c 01       	mova	@r1,	r12	;
    473e:	b0 13 52 47 	calla	#18258		;0x04752

00004742 <.LVL55>:
  chSysUnlock();
    4742:	71 0c 00 00 	mova	r12,	0(r1)	;
    4746:	b0 13 5c 44 	calla	#17500		;0x0445c

0000474a <.LVL56>:

  return msg;
}
    474a:	0c 01       	mova	@r1,	r12	;
    474c:	a1 00 08 00 	adda	#8,	r1	;
    4750:	10 01       	reta			;

00004752 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    4752:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004754 <.LCFI11>:
  chDbgCheckClassS();
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    4754:	2e 4c       	mov	@r12,	r14	;

00004756 <.LVL58>:
  if (cnt <= (cnt_t)0) {
    4756:	4a 43       	clr.b	r10		;
    4758:	0a 9e       	cmp	r14,	r10	;
    475a:	0f 38       	jl	$+32     	;abs 0x477a

0000475c <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    475c:	3d 93       	cmp	#-1,	r13	;r3 As==11
    475e:	13 24       	jz	$+40     	;abs 0x4786

00004760 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    4760:	3e 53       	add	#-1,	r14	;r3 As==11

00004762 <.LVL59>:
    4762:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004766 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    4766:	2e 01 ec 12 	mova	&70380,	r14	;0x112ec

0000476a <.LVL60>:
    476a:	7e 0c 06 00 	mova	r12,	6(r14)	;

0000476e <.LVL61>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    476e:	7c 40 03 00 	mov.b	#3,	r12	;

00004772 <.LVL62>:
    4772:	b0 13 a0 46 	calla	#18080		;0x046a0

00004776 <.L53>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    4776:	0a 16       	popm.a	#1,	r10	;20-bit words
    4778:	10 01       	reta			;

0000477a <.L54>:
  sp->cnt = cnt - (cnt_t)1;
    477a:	3e 53       	add	#-1,	r14	;r3 As==11

0000477c <.LVL65>:
    477c:	8c 4e 00 00 	mov	r14,	0(r12)	;

00004780 <.Loc.823.2>:
  return MSG_OK;
    4780:	4c 43       	clr.b	r12		;

00004782 <.LVL66>:
    4782:	80 00 76 47 	mova	#18294,	r0	;0x04776

00004786 <.L56>:
      return MSG_TIMEOUT;
    4786:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000478a <.LVL68>:
    478a:	80 00 76 47 	mova	#18294,	r0	;0x04776

0000478e <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    478e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004790 <.LCFI13>:

  chDbgCheckClassI();
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    4790:	2d 4c       	mov	@r12,	r13	;
    4792:	1d 53       	inc	r13		;
    4794:	8c 4d 00 00 	mov	r13,	0(r12)	;
    4798:	4e 43       	clr.b	r14		;
    479a:	0e 9d       	cmp	r13,	r14	;
    479c:	0f 38       	jl	$+32     	;abs 0x47bc
    479e:	8e 01 fc 12 	mova	#70396,	r14	;0x112fc

000047a2 <.L60>:
    47a2:	ca 0e       	mova	r14,	r10	;
    47a4:	aa 0f fa ff 	adda	#1048570,r10	;0xffffa

000047a8 <.LVL75>:
    47a8:	ae 00 10 00 	adda	#16,	r14	;0x00010

000047ac <.LBB43>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    47ac:	80 1f 5c 9e 	cmpx.a	-16(r14),r12	;0xfffffff0
    47b0:	f0 ff 
    47b2:	f7 23       	jnz	$-16     	;abs 0x47a2

000047b4 <.Loc.865.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        (void) chSchReadyI(tr, MSG_OK);
    47b4:	4d 43       	clr.b	r13		;
    47b6:	cc 0a       	mova	r10,	r12	;

000047b8 <.LVL76>:
    47b8:	b0 13 2e 46 	calla	#17966		;0x0462e

000047bc <.L58>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    47bc:	0a 16       	popm.a	#1,	r10	;20-bit words
    47be:	10 01       	reta			;

000047c0 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    47c0:	19 14       	pushm.a	#2,	r9	;20-bit words

000047c2 <.LCFI18>:
    47c2:	b1 00 04 00 	suba	#4,	r1	;

000047c6 <.LCFI19>:
    47c6:	08 4d       	mov	r13,	r8	;
    47c8:	09 4e       	mov	r14,	r9	;

000047ca <.Loc.951.2>:

  chSysLock();
    47ca:	71 0c 00 00 	mova	r12,	0(r1)	;
    47ce:	b0 13 66 44 	calla	#17510		;0x04466

000047d2 <.LVL92>:
  chEvtSignalI(tp, mask);
    47d2:	0d 48       	mov	r8,	r13	;
    47d4:	0e 49       	mov	r9,	r14	;
    47d6:	0c 01       	mova	@r1,	r12	;
    47d8:	b0 13 ec 47 	calla	#18412		;0x047ec

000047dc <.LVL93>:
  chSchRescheduleS();
    47dc:	b0 13 90 46 	calla	#18064		;0x04690

000047e0 <.LVL94>:
  chSysUnlock();
    47e0:	b0 13 5c 44 	calla	#17500		;0x0445c

000047e4 <.LVL95>:
}
    47e4:	a1 00 04 00 	adda	#4,	r1	;
    47e8:	18 16       	popm.a	#2,	r9	;20-bit words
    47ea:	10 01       	reta			;

000047ec <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    47ec:	0a 14       	pushm.a	#1,	r10	;20-bit words

000047ee <.LCFI20>:
    47ee:	ca 0c       	mova	r12,	r10	;

000047f0 <.Loc.974.2>:

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epmask |= mask;
    47f0:	1d dc 0c 00 	bis	12(r12),r13	;0x0000c

000047f4 <.LVL97>:
    47f4:	1e dc 0e 00 	bis	14(r12),r14	;0x0000e
    47f8:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c
    47fc:	8c 4e 0e 00 	mov	r14,	14(r12)	; 0x000e

00004800 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4800:	ec 92 04 00 	cmp.b	#4,	4(r12)	;r2 As==10
    4804:	0a 20       	jnz	$+22     	;abs 0x481a

00004806 <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4806:	1d fc 06 00 	and	6(r12),	r13	;
    480a:	1e fc 08 00 	and	8(r12),	r14	;

0000480e <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    480e:	0d de       	bis	r14,	r13	;
    4810:	0d 93       	cmp	#0,	r13	;r3 As==00
    4812:	03 24       	jz	$+8      	;abs 0x481a

00004814 <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    4814:	4d 43       	clr.b	r13		;
    4816:	b0 13 2e 46 	calla	#17966		;0x0462e

0000481a <.L68>:
  }
}
    481a:	0a 16       	popm.a	#1,	r10	;20-bit words
    481c:	10 01       	reta			;

0000481e <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    481e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004820 <.LCFI21>:
    4820:	06 4c       	mov	r12,	r6	;
    4822:	07 4d       	mov	r13,	r7	;
    4824:	05 4e       	mov	r14,	r5	;

00004826 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    4826:	2a 01 ec 12 	mova	&70380,	r10	;0x112ec

0000482a <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    482a:	b0 13 66 44 	calla	#17510		;0x04466

0000482e <.LVL101>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    482e:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    4832:	08 f6       	and	r6,	r8	;
    4834:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4838:	09 f7       	and	r7,	r9	;

0000483a <.LVL102>:
    483a:	0c 48       	mov	r8,	r12	;
    483c:	0c d9       	bis	r9,	r12	;
    483e:	84 00 5c 44 	mova	#17500,	r4	;0x0445c
    4842:	0c 93       	cmp	#0,	r12	;r3 As==00
    4844:	18 20       	jnz	$+50     	;abs 0x4876

00004846 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    4846:	35 93       	cmp	#-1,	r5	;r3 As==11
    4848:	05 20       	jnz	$+12     	;abs 0x4854

0000484a <.L79>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    484a:	44 13       	calla	r4		;

0000484c <.LVL104>:

  return m;
}
    484c:	0c 48       	mov	r8,	r12	;
    484e:	0d 49       	mov	r9,	r13	;
    4850:	64 16       	popm.a	#7,	r10	;20-bit words
    4852:	10 01       	reta			;

00004854 <.L76>:
    ctp->u1.ewmask = mask;
    4854:	8a 46 06 00 	mov	r6,	6(r10)	;
    4858:	8a 47 08 00 	mov	r7,	8(r10)	;

0000485c <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    485c:	0d 45       	mov	r5,	r13	;
    485e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    4860:	b0 13 a0 46 	calla	#18080		;0x046a0

00004864 <.LVL106>:
    4864:	9c 00 00 00 	cmpa	#0,	r12	;
    4868:	f0 3b       	jl	$-30     	;abs 0x484a

0000486a <.Loc.1016.2>:
    m = ctp->epmask & mask;
    486a:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

0000486e <.LVL107>:
    486e:	08 f6       	and	r6,	r8	;
    4870:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    4874:	09 f7       	and	r7,	r9	;

00004876 <.L75>:
  ctp->epmask &= ~m;
    4876:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    487a:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e
    487e:	80 00 4a 48 	mova	#18506,	r0	;0x0484a

00004882 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4882:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004884 <.LCFI4>:
    4884:	08 14       	pushm.a	#1,	r8	;20-bit words

00004886 <.LCFI5>:
    4886:	06 14       	pushm.a	#1,	r6	;20-bit words

00004888 <.LCFI6>:
    4888:	ca 0c       	mova	r12,	r10	;
    488a:	c6 0d       	mova	r13,	r6	;

0000488c <.Loc.190.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    488c:	0d 4e       	mov	r14,	r13	;

0000488e <.LVL9>:
    488e:	ac 00 12 00 	adda	#18,	r12	;0x00012

00004892 <.LVL10>:
    4892:	b0 13 52 47 	calla	#18258		;0x04752

00004896 <.LVL11>:
    4896:	c8 0c       	mova	r12,	r8	;

00004898 <.Loc.191.1>:
  if (rdymsg == MSG_OK) {
    4898:	9c 00 00 00 	cmpa	#0,	r12	;
    489c:	17 20       	jnz	$+48     	;abs 0x48cc

0000489e <.LBB12>:
    *mbp->wrptr++ = msg;
    489e:	3e 0a 08 00 	mova	8(r10),	r14	;
    48a2:	cc 0e       	mova	r14,	r12	;
    48a4:	ac 00 04 00 	adda	#4,	r12	;
    48a8:	7a 0c 08 00 	mova	r12,	8(r10)	;
    48ac:	7e 06 00 00 	mova	r6,	0(r14)	;

000048b0 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    48b0:	00 18 5c 9a 	cmpx.a	4(r10),	r12	;
    48b4:	04 00 
    48b6:	03 28       	jnc	$+8      	;abs 0x48be

000048b8 <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    48b8:	00 18 ea 4a 	movx.a	@r10,	8(r10)	;
    48bc:	08 00 

000048be <.L6>:
    }
    chSemSignalI(&mbp->fullsem);
    48be:	cc 0a       	mova	r10,	r12	;
    48c0:	ac 00 10 00 	adda	#16,	r12	;0x00010
    48c4:	b0 13 8e 47 	calla	#18318		;0x0478e

000048c8 <.LVL14>:
    chSchRescheduleS();
    48c8:	b0 13 90 46 	calla	#18064		;0x04690

000048cc <.L4>:
  }

  return rdymsg;
}
    48cc:	cc 08       	mova	r8,	r12	;
    48ce:	06 16       	popm.a	#1,	r6	;20-bit words
    48d0:	08 16       	popm.a	#1,	r8	;20-bit words
    48d2:	0a 16       	popm.a	#1,	r10	;20-bit words
    48d4:	10 01       	reta			;

000048d6 <chMBPost>:
  _disable_interrupts();
    48d6:	32 c2       	dint			
    48d8:	03 43       	nop			

000048da <.Loc.348.2>:
  asm volatile("nop");
    48da:	03 43       	nop			

000048dc <.LBE18>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    48dc:	b0 13 82 48 	calla	#18562		;0x04882

000048e0 <.LBB20>:
  asm volatile("nop");
    48e0:	03 43       	nop			

000048e2 <.Loc.356.2>:
  _enable_interrupts();
    48e2:	03 43       	nop			
    48e4:	32 d2       	eint			
    48e6:	03 43       	nop			

000048e8 <.LBE20>:
}
    48e8:	10 01       	reta			;

000048ea <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    48ea:	0a 14       	pushm.a	#1,	r10	;20-bit words

000048ec <.LCFI7>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    48ec:	1e 4c 12 00 	mov	18(r12),r14	;0x00012
    48f0:	4f 43       	clr.b	r15		;
    48f2:	0f 9e       	cmp	r14,	r15	;
    48f4:	19 34       	jge	$+52     	;abs 0x4928

000048f6 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    48f6:	bc 53 12 00 	add	#-1,	18(r12)	;r3 As==11, 0x0012

000048fa <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    48fa:	3a 0c 08 00 	mova	8(r12),	r10	;
    48fe:	ce 0a       	mova	r10,	r14	;
    4900:	ae 00 04 00 	adda	#4,	r14	;
    4904:	7c 0e 08 00 	mova	r14,	8(r12)	;
    4908:	7a 0d 00 00 	mova	r13,	0(r10)	;

0000490c <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    490c:	00 18 5e 9c 	cmpx.a	4(r12),	r14	;
    4910:	04 00 
    4912:	03 28       	jnc	$+8      	;abs 0x491a

00004914 <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    4914:	00 18 ec 4c 	movx.a	@r12,	8(r12)	;
    4918:	08 00 

0000491a <.L10>:
  }
  chSemSignalI(&mbp->fullsem);
    491a:	ac 00 10 00 	adda	#16,	r12	;0x00010

0000491e <.LVL19>:
    491e:	b0 13 8e 47 	calla	#18318		;0x0478e

00004922 <.LVL20>:

  return MSG_OK;
    4922:	4c 43       	clr.b	r12		;

00004924 <.L8>:
}
    4924:	0a 16       	popm.a	#1,	r10	;20-bit words
    4926:	10 01       	reta			;

00004928 <.L11>:
    return MSG_TIMEOUT;
    4928:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

0000492c <.LVL22>:
    492c:	80 00 24 49 	mova	#18724,	r0	;0x04924

00004930 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4930:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004932 <.LCFI11>:
    4932:	08 14       	pushm.a	#1,	r8	;20-bit words

00004934 <.LCFI12>:
    4934:	06 14       	pushm.a	#1,	r6	;20-bit words

00004936 <.LCFI13>:
    4936:	ca 0c       	mova	r12,	r10	;
    4938:	c8 0d       	mova	r13,	r8	;

0000493a <.Loc.389.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    493a:	0d 4e       	mov	r14,	r13	;

0000493c <.LVL39>:
    493c:	ac 00 10 00 	adda	#16,	r12	;0x00010

00004940 <.LVL40>:
    4940:	b0 13 52 47 	calla	#18258		;0x04752

00004944 <.LVL41>:
    4944:	c6 0c       	mova	r12,	r6	;

00004946 <.Loc.390.1>:
  if (rdymsg == MSG_OK) {
    4946:	9c 00 00 00 	cmpa	#0,	r12	;
    494a:	18 20       	jnz	$+50     	;abs 0x497c

0000494c <.LBB36>:
    *msgp = *mbp->rdptr++;
    494c:	3c 0a 0c 00 	mova	12(r10),r12	;0x0000c
    4950:	ce 0c       	mova	r12,	r14	;
    4952:	ae 00 04 00 	adda	#4,	r14	;
    4956:	7a 0e 0c 00 	mova	r14,	12(r10)	; 0x0000c
    495a:	00 18 e8 4c 	movx.a	@r12,	0(r8)	;
    495e:	00 00 

00004960 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4960:	00 18 5e 9a 	cmpx.a	4(r10),	r14	;
    4964:	04 00 
    4966:	03 28       	jnc	$+8      	;abs 0x496e

00004968 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4968:	00 18 ea 4a 	movx.a	@r10,	12(r10)	; 0x0000c
    496c:	0c 00 

0000496e <.L22>:
    }
    chSemSignalI(&mbp->emptysem);
    496e:	cc 0a       	mova	r10,	r12	;
    4970:	ac 00 12 00 	adda	#18,	r12	;0x00012
    4974:	b0 13 8e 47 	calla	#18318		;0x0478e

00004978 <.LVL44>:
    chSchRescheduleS();
    4978:	b0 13 90 46 	calla	#18064		;0x04690

0000497c <.L20>:
  }

  return rdymsg;
}
    497c:	cc 06       	mova	r6,	r12	;
    497e:	06 16       	popm.a	#1,	r6	;20-bit words
    4980:	08 16       	popm.a	#1,	r8	;20-bit words
    4982:	0a 16       	popm.a	#1,	r10	;20-bit words
    4984:	10 01       	reta			;

00004986 <chMBFetch>:
  _disable_interrupts();
    4986:	32 c2       	dint			
    4988:	03 43       	nop			

0000498a <.Loc.348.2>:
  asm volatile("nop");
    498a:	03 43       	nop			

0000498c <.LBE42>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    498c:	b0 13 30 49 	calla	#18736		;0x04930

00004990 <.LBB44>:
  asm volatile("nop");
    4990:	03 43       	nop			

00004992 <.Loc.356.2>:
  _enable_interrupts();
    4992:	03 43       	nop			
    4994:	32 d2       	eint			
    4996:	03 43       	nop			

00004998 <.LBE44>:
}
    4998:	10 01       	reta			;

0000499a <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    499a:	b1 00 04 00 	suba	#4,	r1	;

0000499e <.LCFI0>:
    499e:	71 0d 00 00 	mova	r13,	0(r1)	;

000049a2 <.Loc.80.1>:

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
    49a2:	00 18 cc 43 	movx.a	#0,	0(r12)	;r3 As==00
    49a6:	00 00 

000049a8 <.Loc.81.1>:
  mp->object_size = size;
    49a8:	ac 41 04 00 	mov	@r1,	4(r12)	;
    49ac:	0d 14       	pushm.a	#1,	r13	;20-bit words
    49ae:	0d 17       	popm	#1,	r13	;16-bit words
    49b0:	0d 17       	popm	#1,	r13	;16-bit words

000049b2 <.LVL1>:
    49b2:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    49b6:	5f 4c 06 00 	mov.b	6(r12),	r15	;
    49ba:	7f f0 f0 ff 	and.b	#-16,	r15	;#0xfff0
    49be:	4f dd       	bis.b	r13,	r15	;
    49c0:	cc 4f 06 00 	mov.b	r15,	6(r12)	;

000049c4 <.Loc.82.1>:
  mp->provider = provider;
    49c4:	7c 0e 08 00 	mova	r14,	8(r12)	;

000049c8 <.Loc.83.1>:
}
    49c8:	a1 00 04 00 	adda	#4,	r1	;

000049cc <.LVL2>:
    49cc:	10 01       	reta			;

000049ce <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    49ce:	0a 14       	pushm.a	#1,	r10	;20-bit words

000049d0 <.LCFI1>:
    49d0:	ce 0c       	mova	r12,	r14	;

000049d2 <.Loc.127.1>:
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
    49d2:	0c 0c       	mova	@r12,	r12	;

000049d4 <.LVL4>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    49d4:	9c 00 00 00 	cmpa	#0,	r12	;
    49d8:	05 24       	jz	$+12     	;abs 0x49e4

000049da <.Loc.130.1>:
    mp->next = mp->next->next;
    49da:	00 18 ee 4c 	movx.a	@r12,	0(r14)	;
    49de:	00 00 

000049e0 <.L2>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    49e0:	0a 16       	popm.a	#1,	r10	;20-bit words
    49e2:	10 01       	reta			;

000049e4 <.L3>:
  else if (mp->provider != NULL) {
    49e4:	3a 0e 08 00 	mova	8(r14),	r10	;
    49e8:	9a 00 00 00 	cmpa	#0,	r10	;
    49ec:	f9 27       	jz	$-12     	;abs 0x49e0

000049ee <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    49ee:	6d 43       	mov.b	#2,	r13	;r3 As==10
    49f0:	3c 0e 04 00 	mova	4(r14),	r12	;

000049f4 <.LVL7>:
    49f4:	4a 13       	calla	r10		;

000049f6 <.LVL8>:
  return objp;
    49f6:	80 00 e0 49 	mova	#18912,	r0	;0x049e0

000049fa <chPoolAlloc>:
  _disable_interrupts();
    49fa:	32 c2       	dint			
    49fc:	03 43       	nop			

000049fe <.Loc.348.2>:
  asm volatile("nop");
    49fe:	03 43       	nop			

00004a00 <.LBE16>:
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
    4a00:	b0 13 ce 49 	calla	#18894		;0x049ce

00004a04 <.LBB18>:
  asm volatile("nop");
    4a04:	03 43       	nop			

00004a06 <.Loc.356.2>:
  _enable_interrupts();
    4a06:	03 43       	nop			
    4a08:	32 d2       	eint			
    4a0a:	03 43       	nop			

00004a0c <.LBE18>:
  chSysUnlock();

  return objp;
}
    4a0c:	10 01       	reta			;

00004a0e <chPoolFreeI>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
    4a0e:	00 18 ed 4c 	movx.a	@r12,	0(r13)	;
    4a12:	00 00 

00004a14 <.Loc.179.1>:
  mp->next = php;
    4a14:	7c 0d 00 00 	mova	r13,	0(r12)	;

00004a18 <.Loc.180.1>:
}
    4a18:	10 01       	reta			;

00004a1a <chPoolFree>:
  _disable_interrupts();
    4a1a:	32 c2       	dint			
    4a1c:	03 43       	nop			

00004a1e <.Loc.348.2>:
  asm volatile("nop");
    4a1e:	03 43       	nop			

00004a20 <.LBB28>:
  php->next = mp->next;
    4a20:	00 18 ed 4c 	movx.a	@r12,	0(r13)	;
    4a24:	00 00 

00004a26 <.Loc.179.1>:
  mp->next = php;
    4a26:	7c 0d 00 00 	mova	r13,	0(r12)	;

00004a2a <.LBB30>:
  asm volatile("nop");
    4a2a:	03 43       	nop			

00004a2c <.Loc.356.2>:
  _enable_interrupts();
    4a2c:	03 43       	nop			
    4a2e:	32 d2       	eint			
    4a30:	03 43       	nop			

00004a32 <.LBE30>:
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
  chSysUnlock();
}
    4a32:	10 01       	reta			;

00004a34 <_port_switch>:
  asm volatile ("add #4, r1");
#endif
  (void)(ntp);
  (void)(otp);
#if defined(__MSP430X_LARGE__)
  asm volatile ("pushm.a #7, R10");
    4a34:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004a36 <.Loc.74.1>:
  asm volatile ("mova r1, @R13");
    4a36:	7d 01 00 00 	mova	r1,	0(r13)	;

00004a3a <.Loc.75.1>:
  asm volatile ("mova @R12, r1");
    4a3a:	01 0c       	mova	@r12,	r1	;

00004a3c <.Loc.76.1>:
  asm volatile ("popm.a #6, R9");
    4a3c:	54 16       	popm.a	#6,	r9	;20-bit words

00004a3e <.Loc.77.1>:
  asm volatile ("popx.a R10");
    4a3e:	00 18 7a 41 	popx.a	r10		;

00004a42 <.Loc.78.1>:
  asm volatile ("reta");
    4a42:	10 01       	reta			;

00004a44 <_port_thread_start>:
  asm volatile("nop");
    4a44:	03 43       	nop			

00004a46 <.Loc.356.2>:
  _enable_interrupts();
    4a46:	03 43       	nop			
    4a48:	32 d2       	eint			
    4a4a:	03 43       	nop			

00004a4c <.LBE4>:
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
    4a4c:	cc 05       	mova	r5,	r12	;

00004a4e <.Loc.99.1>:
  asm volatile ("calla R4");
    4a4e:	44 13       	calla	r4		;

00004a50 <.Loc.108.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4a50:	4c 43       	clr.b	r12		;
    4a52:	b0 13 7a 45 	calla	#17786		;0x0457a

00004a56 <.LVL1>:
#endif
}
    4a56:	10 01       	reta			;

00004a58 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4a58:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004a5a <.LCFI0>:
    4a5a:	08 14       	pushm.a	#1,	r8	;20-bit words

00004a5c <.LCFI1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4a5c:	2e 4c       	mov	@r12,	r14	;
    4a5e:	0e 93       	cmp	#0,	r14	;r3 As==00
    4a60:	0f 34       	jge	$+32     	;abs 0x4a80
    4a62:	8e 01 fc 12 	mova	#70396,	r14	;0x112fc

00004a66 <.L3>:
    4a66:	ca 0e       	mova	r14,	r10	;
    4a68:	aa 0f fa ff 	adda	#1048570,r10	;0xffffa

00004a6c <.LBB2>:
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    4a6c:	08 0e       	mova	@r14,	r8	;
    4a6e:	ae 00 10 00 	adda	#16,	r14	;0x00010
    4a72:	dc 08       	cmpa	r8,	r12	;
    4a74:	f8 23       	jnz	$-14     	;abs 0x4a66

00004a76 <.Loc.67.1>:
        sp->cnt++;
    4a76:	9c 53 00 00 	inc	0(r12)		;

00004a7a <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    4a7a:	cc 0a       	mova	r10,	r12	;

00004a7c <.LVL3>:
    4a7c:	b0 13 2e 46 	calla	#17966		;0x0462e

00004a80 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4a80:	08 16       	popm.a	#1,	r8	;20-bit words
    4a82:	0a 16       	popm.a	#1,	r10	;20-bit words
    4a84:	10 01       	reta			;

00004a86 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
    4a86:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004a88 <.LCFI2>:
    4a88:	06 14       	pushm.a	#1,	r6	;20-bit words

00004a8a <.LCFI3>:
    4a8a:	04 14       	pushm.a	#1,	r4	;20-bit words

00004a8c <.LCFI4>:
    4a8c:	c6 0c       	mova	r12,	r6	;
    4a8e:	c4 0d       	mova	r13,	r4	;

00004a90 <.LVL6>:
  semaphore_t *sp = &tqp->sem;
  thread_t *tp;
  cnt_t cnt;

  cnt = sp->cnt;
    4a90:	29 4c       	mov	@r12,	r9	;

00004a92 <.Loc.96.1>:
  sp->cnt = (cnt_t)0;
    4a92:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    4a96:	8a 01 fc 12 	mova	#70396,	r10	;0x112fc

00004a9a <.Loc.109.1>:
    if (tp->u1.semp == sp) {

      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
      (void) chSchReadyI(tp, msg);
    4a9a:	88 00 2e 46 	mova	#17966,	r8	;0x0462e

00004a9e <.L6>:
    4a9e:	cc 0a       	mova	r10,	r12	;
    4aa0:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa

00004aa4 <.LVL10>:
  while (cnt < (cnt_t)0) {
    4aa4:	09 93       	cmp	#0,	r9	;r3 As==00
    4aa6:	04 38       	jl	$+10     	;abs 0x4ab0

00004aa8 <.Loc.113.1>:
    }
    tp++;
  }
}
    4aa8:	04 16       	popm.a	#1,	r4	;20-bit words
    4aaa:	06 16       	popm.a	#1,	r6	;20-bit words
    4aac:	28 16       	popm.a	#3,	r10	;20-bit words
    4aae:	10 01       	reta			;

00004ab0 <.L8>:
    if (tp->u1.semp == sp) {
    4ab0:	00 18 66 9a 	cmpx.a	@r10,	r6	;
    4ab4:	03 20       	jnz	$+8      	;abs 0x4abc

00004ab6 <.Loc.108.1>:
      cnt++;
    4ab6:	19 53       	inc	r9		;

00004ab8 <.Loc.109.1>:
      (void) chSchReadyI(tp, msg);
    4ab8:	cd 04       	mova	r4,	r13	;
    4aba:	48 13       	calla	r8		;

00004abc <.L7>:
    4abc:	aa 00 10 00 	adda	#16,	r10	;0x00010

00004ac0 <.LVL13>:
    4ac0:	80 00 9e 4a 	mova	#19102,	r0	;0x04a9e

00004ac4 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4ac4:	b0 13 04 53 	calla	#21252		;0x05304

00004ac8 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4ac8:	8c 01 20 00 	mova	#65568,	r12	;0x10020
    4acc:	b0 13 d8 56 	calla	#22232		;0x056d8

00004ad0 <.LVL1>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    4ad0:	b0 13 f4 4f 	calla	#20468		;0x04ff4

00004ad4 <.LVL2>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4ad4:	b0 13 2e 50 	calla	#20526		;0x0502e

00004ad8 <.LVL3>:
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    4ad8:	b0 13 94 50 	calla	#20628		;0x05094

00004adc <.LVL4>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    4adc:	b0 13 4a 51 	calla	#20810		;0x0514a

00004ae0 <.LVL5>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4ae0:	b0 13 92 52 	calla	#21138		;0x05292

00004ae4 <.LVL6>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4ae4:	b0 13 30 64 	calla	#25648		;0x06430

00004ae8 <.LVL7>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4ae8:	b0 13 ee 4a 	calla	#19182		;0x04aee

00004aec <.LVL8>:
#endif
}
    4aec:	10 01       	reta			;

00004aee <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4aee:	b0 13 54 53 	calla	#21332		;0x05354

00004af2 <.LVL0>:
}
    4af2:	10 01       	reta			;

00004af4 <port_lock>:
  _disable_interrupts();
    4af4:	32 c2       	dint			
    4af6:	03 43       	nop			

00004af8 <.Loc.348.1>:
  asm volatile("nop");
    4af8:	03 43       	nop			

00004afa <.Loc.349.1>:
}
    4afa:	10 01       	reta			;

00004afc <port_unlock>:
  asm volatile("nop");
    4afc:	03 43       	nop			

00004afe <.Loc.356.1>:
  _enable_interrupts();
    4afe:	03 43       	nop			
    4b00:	32 d2       	eint			
    4b02:	03 43       	nop			

00004b04 <.Loc.357.1>:
}
    4b04:	10 01       	reta			;

00004b06 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    4b06:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b08 <.LCFI0>:
    4b08:	ca 0d       	mova	r13,	r10	;

00004b0a <.LBB64>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    4b0a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00004b0e <.LBE64>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    4b0e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    4b12:	bc f0 f0 ff 	and	#-16,	4(r12)	;#0xfff0
    4b16:	04 00 

00004b18 <.Loc.60.2>:
  iqp->q_buffer  = bp;
    4b18:	7c 0d 06 00 	mova	r13,	6(r12)	;

00004b1c <.Loc.61.2>:
  iqp->q_rdptr   = bp;
    4b1c:	7c 0d 12 00 	mova	r13,	18(r12)	; 0x00012

00004b20 <.Loc.62.2>:
  iqp->q_wrptr   = bp;
    4b20:	7c 0d 0e 00 	mova	r13,	14(r12)	; 0x0000e

00004b24 <.Loc.63.2>:
  iqp->q_top     = bp + size;
    4b24:	ea 0e       	adda	r14,	r10	;
    4b26:	7c 0a 0a 00 	mova	r10,	10(r12)	; 0x0000a

00004b2a <.Loc.64.2>:
  iqp->q_notify  = infy;
    4b2a:	7c 0f 16 00 	mova	r15,	22(r12)	; 0x00016

00004b2e <.Loc.65.2>:
  iqp->q_link    = link;
    4b2e:	00 18 dc 41 	movx.a	8(r1),	26(r12)	; 0x0001a
    4b32:	08 00 1a 00 

00004b36 <.Loc.66.2>:
}
    4b36:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b38:	10 01       	reta			;

00004b3a <iqResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void iqResetI(input_queue_t *iqp) {
    4b3a:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b3c <.LCFI1>:

  osalDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
    4b3c:	3a 0c 06 00 	mova	6(r12),	r10	;
    4b40:	7c 0a 12 00 	mova	r10,	18(r12)	; 0x00012

00004b44 <.Loc.84.2>:
  iqp->q_wrptr = iqp->q_buffer;
    4b44:	7c 0a 0e 00 	mova	r10,	14(r12)	; 0x0000e

00004b48 <.Loc.85.2>:
  iqp->q_counter = 0;
    4b48:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    4b4c:	bc f0 f0 ff 	and	#-16,	4(r12)	;#0xfff0
    4b50:	04 00 

00004b52 <.Loc.86.2>:
  osalThreadDequeueAllI(&iqp->q_waiting, MSG_RESET);
    4b52:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    4b56:	b0 13 86 4a 	calla	#19078		;0x04a86

00004b5a <.LVL4>:
}
    4b5a:	0a 16       	popm.a	#1,	r10	;20-bit words
    4b5c:	10 01       	reta			;

00004b5e <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    4b5e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004b60 <.LCFI2>:
    4b60:	b1 00 04 00 	suba	#4,	r1	;

00004b64 <.LCFI3>:
    4b64:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00004b68 <.Loc.106.2>:

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
    4b68:	3e 0c 0e 00 	mova	14(r12),r14	;0x0000e
    4b6c:	00 18 5e 9c 	cmpx.a	18(r12),r14	;0x00012
    4b70:	12 00 
    4b72:	05 20       	jnz	$+12     	;abs 0x4b7e

00004b74 <.Loc.106.2>:
    4b74:	3a 0c 02 00 	mova	2(r12),	r10	;
    4b78:	9a 00 00 00 	cmpa	#0,	r10	;
    4b7c:	2b 20       	jnz	$+88     	;abs 0x4bd4

00004b7e <.L6>:
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
    4b7e:	3f 0c 02 00 	mova	2(r12),	r15	;
    4b82:	af 00 01 00 	adda	#1,	r15	;
    4b86:	71 0f 00 00 	mova	r15,	0(r1)	;
    4b8a:	8c 4f 02 00 	mov	r15,	2(r12)	;
    4b8e:	1f 41 02 00 	mov	2(r1),	r15	;
    4b92:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4b96:	1b 4c 04 00 	mov	4(r12),	r11	;
    4b9a:	3b f0 f0 ff 	and	#-16,	r11	;#0xfff0
    4b9e:	0b df       	bis	r15,	r11	;
    4ba0:	8c 4b 04 00 	mov	r11,	4(r12)	;

00004ba4 <.Loc.111.2>:
  *iqp->q_wrptr++ = b;
    4ba4:	cf 0e       	mova	r14,	r15	;
    4ba6:	af 00 01 00 	adda	#1,	r15	;
    4baa:	7c 0f 0e 00 	mova	r15,	14(r12)	; 0x0000e
    4bae:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00004bb2 <.Loc.112.2>:
  if (iqp->q_wrptr >= iqp->q_top) {
    4bb2:	00 18 dc 9c 	cmpx.a	10(r12),14(r12)	;0x0000a, 0x0000e
    4bb6:	0a 00 0e 00 
    4bba:	04 28       	jnc	$+10     	;abs 0x4bc4

00004bbc <.Loc.113.2>:
    iqp->q_wrptr = iqp->q_buffer;
    4bbc:	00 18 dc 4c 	movx.a	6(r12),	14(r12)	; 0x0000e
    4bc0:	06 00 0e 00 

00004bc4 <.L9>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    4bc4:	4d 43       	clr.b	r13		;

00004bc6 <.LVL6>:
    4bc6:	b0 13 58 4a 	calla	#19032		;0x04a58

00004bca <.LVL7>:

  return MSG_OK;
    4bca:	4c 43       	clr.b	r12		;

00004bcc <.L5>:
}
    4bcc:	a1 00 04 00 	adda	#4,	r1	;
    4bd0:	0a 16       	popm.a	#1,	r10	;20-bit words
    4bd2:	10 01       	reta			;

00004bd4 <.L10>:
    return MSG_TIMEOUT;
    4bd4:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004bd8 <.LVL9>:
    4bd8:	80 00 cc 4b 	mova	#19404,	r0	;0x04bcc

00004bdc <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    4bdc:	2a 14       	pushm.a	#3,	r10	;20-bit words

00004bde <.LCFI4>:
    4bde:	b1 00 08 00 	suba	#8,	r1	;

00004be2 <.LCFI5>:
    4be2:	ca 0c       	mova	r12,	r10	;
    4be4:	09 4d       	mov	r13,	r9	;

00004be6 <.LBB66>:
  chSysLock();
    4be6:	b0 13 f4 4a 	calla	#19188		;0x04af4

00004bea <.LBB68>:
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chSemWaitTimeoutS(&tqp->sem, time);
    4bea:	88 00 52 47 	mova	#18258,	r8	;0x04752

00004bee <.L12>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    4bee:	3c 0a 02 00 	mova	2(r10),	r12	;
    4bf2:	9c 00 00 00 	cmpa	#0,	r12	;
    4bf6:	30 24       	jz	$+98     	;abs 0x4c58

00004bf8 <.Loc.156.2>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    4bf8:	3c 0a 02 00 	mova	2(r10),	r12	;
    4bfc:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4c00:	71 0c 04 00 	mova	r12,	4(r1)	;
    4c04:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4c08:	1c 41 06 00 	mov	6(r1),	r12	;
    4c0c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4c10:	1d 4a 04 00 	mov	4(r10),	r13	;
    4c14:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4c18:	0d dc       	bis	r12,	r13	;
    4c1a:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004c1e <.Loc.157.2>:
  b = *iqp->q_rdptr++;
    4c1e:	3e 0a 12 00 	mova	18(r10),r14	;0x00012
    4c22:	cc 0e       	mova	r14,	r12	;
    4c24:	ac 00 01 00 	adda	#1,	r12	;
    4c28:	7a 0c 12 00 	mova	r12,	18(r10)	; 0x00012
    4c2c:	68 4e       	mov.b	@r14,	r8	;

00004c2e <.LVL12>:
  if (iqp->q_rdptr >= iqp->q_top) {
    4c2e:	00 18 5c 9a 	cmpx.a	10(r10),r12	;0x0000a
    4c32:	0a 00 
    4c34:	04 28       	jnc	$+10     	;abs 0x4c3e

00004c36 <.Loc.159.2>:
    iqp->q_rdptr = iqp->q_buffer;
    4c36:	00 18 da 4a 	movx.a	6(r10),	18(r10)	; 0x00012
    4c3a:	06 00 12 00 

00004c3e <.L15>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    4c3e:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    4c42:	9e 00 00 00 	cmpa	#0,	r14	;
    4c46:	02 24       	jz	$+6      	;abs 0x4c4c

00004c48 <.Loc.164.2>:
    iqp->q_notify(iqp);
    4c48:	cc 0a       	mova	r10,	r12	;
    4c4a:	4e 13       	calla	r14		;

00004c4c <.L16>:
  chSysUnlock();
    4c4c:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004c50 <.LBE75>:
  }

  osalSysUnlock();

  return (msg_t)b;
    4c50:	40 18 0c 48 	movx.w	r8,	r12	;
    4c54:	80 00 6e 4c 	mova	#19566,	r0	;0x04c6e

00004c58 <.L14>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4c58:	0d 49       	mov	r9,	r13	;
    4c5a:	cc 0a       	mova	r10,	r12	;
    4c5c:	48 13       	calla	r8		;

00004c5e <.LBE72>:
    if (msg < MSG_OK) {
    4c5e:	9c 00 00 00 	cmpa	#0,	r12	;
    4c62:	c5 37       	jge	$-116    	;abs 0x4bee

00004c64 <.LBB73>:
  chSysUnlock();
    4c64:	71 0c 00 00 	mova	r12,	0(r1)	;
    4c68:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004c6c <.LBE73>:
      return msg;
    4c6c:	0c 01       	mova	@r1,	r12	;

00004c6e <.L11>:
}
    4c6e:	a1 00 08 00 	adda	#8,	r1	;
    4c72:	28 16       	popm.a	#3,	r10	;20-bit words
    4c74:	10 01       	reta			;

00004c76 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    4c76:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004c78 <.LCFI6>:
    4c78:	b1 00 06 00 	suba	#6,	r1	;

00004c7c <.LCFI7>:
    4c7c:	ca 0c       	mova	r12,	r10	;
    4c7e:	c6 0d       	mova	r13,	r6	;
    4c80:	c5 0e       	mova	r14,	r5	;
    4c82:	09 4f       	mov	r15,	r9	;

00004c84 <.Loc.199.2>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    4c84:	37 0c 16 00 	mova	22(r12),r7	;0x00016

00004c88 <.LBB78>:
  chSysLock();
    4c88:	88 00 f4 4a 	mova	#19188,	r8	;0x04af4
    4c8c:	48 13       	calla	r8		;

00004c8e <.LBB80>:
  return chVTGetSystemTimeX();
    4c8e:	8c 01 ec 12 	mova	#70380,	r12	;0x112ec

00004c92 <.LBE80>:
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    4c92:	0d 49       	mov	r9,	r13	;
    4c94:	1d 5c 08 00 	add	8(r12),	r13	;
    4c98:	81 4d 04 00 	mov	r13,	4(r1)	;

00004c9c <.LVL22>:
  size_t r = 0;
    4c9c:	44 43       	clr.b	r4		;

00004c9e <.L22>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    4c9e:	3c 0a 02 00 	mova	2(r10),	r12	;
    4ca2:	9c 00 00 00 	cmpa	#0,	r12	;
    4ca6:	3c 24       	jz	$+122    	;abs 0x4d20

00004ca8 <.Loc.243.2>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    4ca8:	3c 0a 02 00 	mova	2(r10),	r12	;
    4cac:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4cb0:	71 0c 00 00 	mova	r12,	0(r1)	;
    4cb4:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4cb8:	1c 41 02 00 	mov	2(r1),	r12	;
    4cbc:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4cc0:	1d 4a 04 00 	mov	4(r10),	r13	;
    4cc4:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4cc8:	0d dc       	bis	r12,	r13	;
    4cca:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004cce <.Loc.244.2>:
    *bp++ = *iqp->q_rdptr++;
    4cce:	cd 06       	mova	r6,	r13	;
    4cd0:	ad 00 01 00 	adda	#1,	r13	;
    4cd4:	71 0d 00 00 	mova	r13,	0(r1)	;

00004cd8 <.LVL24>:
    4cd8:	3c 0a 12 00 	mova	18(r10),r12	;0x00012
    4cdc:	cd 0c       	mova	r12,	r13	;

00004cde <.LVL25>:
    4cde:	ad 00 01 00 	adda	#1,	r13	;
    4ce2:	7a 0d 12 00 	mova	r13,	18(r10)	; 0x00012
    4ce6:	e6 4c 00 00 	mov.b	@r12,	0(r6)	;

00004cea <.Loc.245.2>:
    if (iqp->q_rdptr >= iqp->q_top) {
    4cea:	00 18 da 9a 	cmpx.a	10(r10),18(r10)	;0x0000a, 0x00012
    4cee:	0a 00 12 00 
    4cf2:	04 28       	jnc	$+10     	;abs 0x4cfc

00004cf4 <.Loc.246.2>:
      iqp->q_rdptr = iqp->q_buffer;
    4cf4:	00 18 da 4a 	movx.a	6(r10),	18(r10)	; 0x00012
    4cf8:	06 00 12 00 

00004cfc <.L29>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    4cfc:	97 00 00 00 	cmpa	#0,	r7	;
    4d00:	02 24       	jz	$+6      	;abs 0x4d06

00004d02 <.Loc.251.2>:
      nfy(iqp);
    4d02:	cc 0a       	mova	r10,	r12	;
    4d04:	47 13       	calla	r7		;

00004d06 <.L30>:
  chSysUnlock();
    4d06:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004d0a <.LBE82>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    4d0a:	a4 00 01 00 	adda	#1,	r4	;

00004d0e <.Loc.258.2>:
    if (--n == 0U) {
    4d0e:	a5 0f ff ff 	adda	#1048575,r5	;0xfffff
    4d12:	95 00 00 00 	cmpa	#0,	r5	;
    4d16:	1d 24       	jz	$+60     	;abs 0x4d52

00004d18 <.LBB84>:
  chSysLock();
    4d18:	48 13       	calla	r8		;

00004d1a <.LBE84>:
    *bp++ = *iqp->q_rdptr++;
    4d1a:	06 01       	mova	@r1,	r6	;
    4d1c:	80 00 9e 4c 	mova	#19614,	r0	;0x04c9e

00004d20 <.L28>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    4d20:	0c 49       	mov	r9,	r12	;
    4d22:	3c 53       	add	#-1,	r12	;r3 As==11
    4d24:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    4d28:	0d 9c       	cmp	r12,	r13	;
    4d2a:	09 2c       	jc	$+20     	;abs 0x4d3e

00004d2c <.LBB87>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4d2c:	0d 49       	mov	r9,	r13	;

00004d2e <.L25>:
    4d2e:	cc 0a       	mova	r10,	r12	;
    4d30:	b0 13 52 47 	calla	#18258		;0x04752

00004d34 <.LBE89>:
      if (msg != MSG_OK) {
    4d34:	9c 00 00 00 	cmpa	#0,	r12	;
    4d38:	b2 27       	jz	$-154    	;abs 0x4c9e
    4d3a:	80 00 4e 4d 	mova	#19790,	r0	;0x04d4e

00004d3e <.L23>:
  return chVTGetSystemTimeX();
    4d3e:	c0 18 1c 42 	movx.w	&0x112f4,r12	;
    4d42:	f4 12 

00004d44 <.LBE92>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    4d44:	1d 41 04 00 	mov	4(r1),	r13	;
    4d48:	0d 8c       	sub	r12,	r13	;

00004d4a <.LVL36>:
        if (next_timeout > timeout) {
    4d4a:	09 9d       	cmp	r13,	r9	;
    4d4c:	f0 2f       	jc	$-30     	;abs 0x4d2e

00004d4e <.L40>:
  chSysUnlock();
    4d4e:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004d52 <.L21>:
      return r;
    }

    osalSysLock();
  }
}
    4d52:	cc 04       	mova	r4,	r12	;
    4d54:	a1 00 06 00 	adda	#6,	r1	;
    4d58:	64 16       	popm.a	#7,	r10	;20-bit words
    4d5a:	10 01       	reta			;

00004d5c <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    4d5c:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004d5e <.LCFI8>:
    4d5e:	b1 00 04 00 	suba	#4,	r1	;

00004d62 <.LCFI9>:
    4d62:	ca 0d       	mova	r13,	r10	;
    4d64:	71 0e 00 00 	mova	r14,	0(r1)	;

00004d68 <.LBB97>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    4d68:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00004d6c <.LBE97>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
    4d6c:	ac 41 02 00 	mov	@r1,	2(r12)	;
    4d70:	1d 41 02 00 	mov	2(r1),	r13	;

00004d74 <.LVL42>:
    4d74:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4d78:	1e 4c 04 00 	mov	4(r12),	r14	;

00004d7c <.LVL43>:
    4d7c:	3e f0 f0 ff 	and	#-16,	r14	;#0xfff0
    4d80:	0e dd       	bis	r13,	r14	;
    4d82:	8c 4e 04 00 	mov	r14,	4(r12)	;

00004d86 <.Loc.286.2>:
  oqp->q_buffer  = bp;
    4d86:	7c 0a 06 00 	mova	r10,	6(r12)	;

00004d8a <.Loc.287.2>:
  oqp->q_rdptr   = bp;
    4d8a:	7c 0a 12 00 	mova	r10,	18(r12)	; 0x00012

00004d8e <.Loc.288.2>:
  oqp->q_wrptr   = bp;
    4d8e:	7c 0a 0e 00 	mova	r10,	14(r12)	; 0x0000e

00004d92 <.Loc.289.2>:
  oqp->q_top     = bp + size;
    4d92:	00 18 6a 51 	addx.a	@r1,	r10	;

00004d96 <.LVL44>:
    4d96:	7c 0a 0a 00 	mova	r10,	10(r12)	; 0x0000a

00004d9a <.Loc.290.2>:
  oqp->q_notify  = onfy;
    4d9a:	7c 0f 16 00 	mova	r15,	22(r12)	; 0x00016

00004d9e <.Loc.291.2>:
  oqp->q_link    = link;
    4d9e:	00 18 dc 41 	movx.a	12(r1),	26(r12)	;0x0000c, 0x0001a
    4da2:	0c 00 1a 00 

00004da6 <.Loc.292.2>:
}
    4da6:	a1 00 04 00 	adda	#4,	r1	;

00004daa <.LVL45>:
    4daa:	0a 16       	popm.a	#1,	r10	;20-bit words
    4dac:	10 01       	reta			;

00004dae <oqResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void oqResetI(output_queue_t *oqp) {
    4dae:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004db0 <.LCFI10>:
    4db0:	b1 00 04 00 	suba	#4,	r1	;

00004db4 <.LCFI11>:

  osalDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
    4db4:	3a 0c 06 00 	mova	6(r12),	r10	;
    4db8:	7c 0a 12 00 	mova	r10,	18(r12)	; 0x00012

00004dbc <.Loc.310.2>:
  oqp->q_wrptr = oqp->q_buffer;
    4dbc:	7c 0a 0e 00 	mova	r10,	14(r12)	; 0x0000e

00004dc0 <.Loc.311.2>:
  oqp->q_counter = qSizeX(oqp);
    4dc0:	3d 0c 0a 00 	mova	10(r12),r13	;0x0000a
    4dc4:	fd 0a       	suba	r10,	r13	;
    4dc6:	71 0d 00 00 	mova	r13,	0(r1)	;
    4dca:	8c 4d 02 00 	mov	r13,	2(r12)	;
    4dce:	1d 41 02 00 	mov	2(r1),	r13	;
    4dd2:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4dd6:	1f 4c 04 00 	mov	4(r12),	r15	;
    4dda:	3f f0 f0 ff 	and	#-16,	r15	;#0xfff0
    4dde:	0f dd       	bis	r13,	r15	;
    4de0:	8c 4f 04 00 	mov	r15,	4(r12)	;

00004de4 <.Loc.312.2>:
  osalThreadDequeueAllI(&oqp->q_waiting, MSG_RESET);
    4de4:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    4de8:	b0 13 86 4a 	calla	#19078		;0x04a86

00004dec <.LVL47>:
}
    4dec:	a1 00 04 00 	adda	#4,	r1	;
    4df0:	0a 16       	popm.a	#1,	r10	;20-bit words
    4df2:	10 01       	reta			;

00004df4 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    4df4:	3a 14       	pushm.a	#4,	r10	;20-bit words

00004df6 <.LCFI12>:
    4df6:	b1 00 08 00 	suba	#8,	r1	;

00004dfa <.LCFI13>:
    4dfa:	ca 0c       	mova	r12,	r10	;
    4dfc:	49 4d       	mov.b	r13,	r9	;
    4dfe:	07 4e       	mov	r14,	r7	;

00004e00 <.LBB99>:
  chSysLock();
    4e00:	b0 13 f4 4a 	calla	#19188		;0x04af4

00004e04 <.LBB101>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4e04:	88 00 52 47 	mova	#18258,	r8	;0x04752

00004e08 <.L44>:

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    4e08:	3c 0a 02 00 	mova	2(r10),	r12	;
    4e0c:	9c 00 00 00 	cmpa	#0,	r12	;
    4e10:	31 24       	jz	$+100    	;abs 0x4e74

00004e12 <.Loc.351.2>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    4e12:	3c 0a 02 00 	mova	2(r10),	r12	;
    4e16:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4e1a:	71 0c 04 00 	mova	r12,	4(r1)	;
    4e1e:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4e22:	1c 41 06 00 	mov	6(r1),	r12	;
    4e26:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4e2a:	1d 4a 04 00 	mov	4(r10),	r13	;
    4e2e:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4e32:	0d dc       	bis	r12,	r13	;
    4e34:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004e38 <.Loc.352.2>:
  *oqp->q_wrptr++ = b;
    4e38:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    4e3c:	cd 0c       	mova	r12,	r13	;
    4e3e:	ad 00 01 00 	adda	#1,	r13	;
    4e42:	7a 0d 0e 00 	mova	r13,	14(r10)	; 0x0000e
    4e46:	cc 49 00 00 	mov.b	r9,	0(r12)	;

00004e4a <.Loc.353.2>:
  if (oqp->q_wrptr >= oqp->q_top) {
    4e4a:	00 18 da 9a 	cmpx.a	10(r10),14(r10)	;0x0000a, 0x0000e
    4e4e:	0a 00 0e 00 
    4e52:	04 28       	jnc	$+10     	;abs 0x4e5c

00004e54 <.Loc.354.2>:
    oqp->q_wrptr = oqp->q_buffer;
    4e54:	00 18 da 4a 	movx.a	6(r10),	14(r10)	; 0x0000e
    4e58:	06 00 0e 00 

00004e5c <.L47>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    4e5c:	3e 0a 16 00 	mova	22(r10),r14	;0x00016
    4e60:	9e 00 00 00 	cmpa	#0,	r14	;
    4e64:	02 24       	jz	$+6      	;abs 0x4e6a

00004e66 <.Loc.359.2>:
    oqp->q_notify(oqp);
    4e66:	cc 0a       	mova	r10,	r12	;
    4e68:	4e 13       	calla	r14		;

00004e6a <.L48>:
  chSysUnlock();
    4e6a:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004e6e <.LBE108>:
  }

  osalSysUnlock();

  return MSG_OK;
    4e6e:	4c 43       	clr.b	r12		;
    4e70:	80 00 8a 4e 	mova	#20106,	r0	;0x04e8a

00004e74 <.L46>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4e74:	0d 47       	mov	r7,	r13	;
    4e76:	cc 0a       	mova	r10,	r12	;
    4e78:	48 13       	calla	r8		;

00004e7a <.LBE105>:
    if (msg < MSG_OK) {
    4e7a:	9c 00 00 00 	cmpa	#0,	r12	;
    4e7e:	c4 37       	jge	$-118    	;abs 0x4e08

00004e80 <.LBB106>:
  chSysUnlock();
    4e80:	71 0c 00 00 	mova	r12,	0(r1)	;
    4e84:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004e88 <.LBE106>:
      return msg;
    4e88:	0c 01       	mova	@r1,	r12	;

00004e8a <.L43>:
}
    4e8a:	a1 00 08 00 	adda	#8,	r1	;
    4e8e:	37 16       	popm.a	#4,	r10	;20-bit words
    4e90:	10 01       	reta			;

00004e92 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    4e92:	0a 14       	pushm.a	#1,	r10	;20-bit words

00004e94 <.LCFI14>:
    4e94:	08 14       	pushm.a	#1,	r8	;20-bit words

00004e96 <.LCFI15>:
    4e96:	b1 00 04 00 	suba	#4,	r1	;

00004e9a <.LCFI16>:
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
    4e9a:	3e 0c 12 00 	mova	18(r12),r14	;0x00012
    4e9e:	00 18 cc 9e 	cmpx.a	r14,	14(r12)	; 0x0000e
    4ea2:	0e 00 
    4ea4:	05 20       	jnz	$+12     	;abs 0x4eb0

00004ea6 <.Loc.382.2>:
    4ea6:	3a 0c 02 00 	mova	2(r12),	r10	;
    4eaa:	9a 00 00 00 	cmpa	#0,	r10	;
    4eae:	2b 20       	jnz	$+88     	;abs 0x4f06

00004eb0 <.L54>:
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
    4eb0:	3d 0c 02 00 	mova	2(r12),	r13	;
    4eb4:	ad 00 01 00 	adda	#1,	r13	;
    4eb8:	71 0d 00 00 	mova	r13,	0(r1)	;
    4ebc:	8c 4d 02 00 	mov	r13,	2(r12)	;
    4ec0:	1d 41 02 00 	mov	2(r1),	r13	;
    4ec4:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    4ec8:	1f 4c 04 00 	mov	4(r12),	r15	;
    4ecc:	3f f0 f0 ff 	and	#-16,	r15	;#0xfff0
    4ed0:	0f dd       	bis	r13,	r15	;
    4ed2:	8c 4f 04 00 	mov	r15,	4(r12)	;

00004ed6 <.Loc.387.2>:
  b = *oqp->q_rdptr++;
    4ed6:	c8 0e       	mova	r14,	r8	;
    4ed8:	a8 00 01 00 	adda	#1,	r8	;
    4edc:	7c 08 12 00 	mova	r8,	18(r12)	; 0x00012
    4ee0:	6a 4e       	mov.b	@r14,	r10	;

00004ee2 <.LVL56>:
  if (oqp->q_rdptr >= oqp->q_top) {
    4ee2:	00 18 58 9c 	cmpx.a	10(r12),r8	;0x0000a
    4ee6:	0a 00 
    4ee8:	04 28       	jnc	$+10     	;abs 0x4ef2

00004eea <.Loc.389.2>:
    oqp->q_rdptr = oqp->q_buffer;
    4eea:	00 18 dc 4c 	movx.a	6(r12),	18(r12)	; 0x00012
    4eee:	06 00 12 00 

00004ef2 <.L57>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    4ef2:	4d 43       	clr.b	r13		;
    4ef4:	b0 13 58 4a 	calla	#19032		;0x04a58

00004ef8 <.LVL58>:

  return (msg_t)b;
    4ef8:	40 18 0c 4a 	movx.w	r10,	r12	;

00004efc <.L53>:
}
    4efc:	a1 00 04 00 	adda	#4,	r1	;
    4f00:	08 16       	popm.a	#1,	r8	;20-bit words
    4f02:	0a 16       	popm.a	#1,	r10	;20-bit words
    4f04:	10 01       	reta			;

00004f06 <.L58>:
    return MSG_TIMEOUT;
    4f06:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

00004f0a <.LVL61>:
    4f0a:	80 00 fc 4e 	mova	#20220,	r0	;0x04efc

00004f0e <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    4f0e:	6a 14       	pushm.a	#7,	r10	;20-bit words

00004f10 <.LCFI17>:
    4f10:	b1 00 06 00 	suba	#6,	r1	;

00004f14 <.LCFI18>:
    4f14:	ca 0c       	mova	r12,	r10	;
    4f16:	c6 0d       	mova	r13,	r6	;
    4f18:	c5 0e       	mova	r14,	r5	;
    4f1a:	09 4f       	mov	r15,	r9	;

00004f1c <.Loc.424.2>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    4f1c:	37 0c 16 00 	mova	22(r12),r7	;0x00016

00004f20 <.LBB111>:
  chSysLock();
    4f20:	88 00 f4 4a 	mova	#19188,	r8	;0x04af4
    4f24:	48 13       	calla	r8		;

00004f26 <.LBB113>:
  return chVTGetSystemTimeX();
    4f26:	8c 01 ec 12 	mova	#70380,	r12	;0x112ec

00004f2a <.LBE113>:
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    4f2a:	0d 49       	mov	r9,	r13	;
    4f2c:	1d 5c 08 00 	add	8(r12),	r13	;
    4f30:	81 4d 04 00 	mov	r13,	4(r1)	;

00004f34 <.LVL65>:
  size_t w = 0;
    4f34:	44 43       	clr.b	r4		;

00004f36 <.L60>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    4f36:	3c 0a 02 00 	mova	2(r10),	r12	;
    4f3a:	9c 00 00 00 	cmpa	#0,	r12	;
    4f3e:	3c 24       	jz	$+122    	;abs 0x4fb8

00004f40 <.Loc.467.2>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    4f40:	3c 0a 02 00 	mova	2(r10),	r12	;
    4f44:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    4f48:	71 0c 00 00 	mova	r12,	0(r1)	;
    4f4c:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4f50:	1c 41 02 00 	mov	2(r1),	r12	;
    4f54:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    4f58:	1d 4a 04 00 	mov	4(r10),	r13	;
    4f5c:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    4f60:	0d dc       	bis	r12,	r13	;
    4f62:	8a 4d 04 00 	mov	r13,	4(r10)	;

00004f66 <.Loc.468.2>:
    *oqp->q_wrptr++ = *bp++;
    4f66:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    4f6a:	cd 0c       	mova	r12,	r13	;
    4f6c:	ad 00 01 00 	adda	#1,	r13	;
    4f70:	7a 0d 0e 00 	mova	r13,	14(r10)	; 0x0000e
    4f74:	cd 06       	mova	r6,	r13	;
    4f76:	ad 00 01 00 	adda	#1,	r13	;
    4f7a:	71 0d 00 00 	mova	r13,	0(r1)	;

00004f7e <.LVL67>:
    4f7e:	ec 46 00 00 	mov.b	@r6,	0(r12)	;

00004f82 <.Loc.469.2>:
    if (oqp->q_wrptr >= oqp->q_top) {
    4f82:	00 18 da 9a 	cmpx.a	10(r10),14(r10)	;0x0000a, 0x0000e
    4f86:	0a 00 0e 00 
    4f8a:	04 28       	jnc	$+10     	;abs 0x4f94

00004f8c <.Loc.470.2>:
      oqp->q_wrptr = oqp->q_buffer;
    4f8c:	00 18 da 4a 	movx.a	6(r10),	14(r10)	; 0x0000e
    4f90:	06 00 0e 00 

00004f94 <.L67>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    4f94:	97 00 00 00 	cmpa	#0,	r7	;
    4f98:	02 24       	jz	$+6      	;abs 0x4f9e

00004f9a <.Loc.475.2>:
      nfy(oqp);
    4f9a:	cc 0a       	mova	r10,	r12	;
    4f9c:	47 13       	calla	r7		;

00004f9e <.L68>:
  chSysUnlock();
    4f9e:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004fa2 <.LBE116>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    4fa2:	a4 00 01 00 	adda	#1,	r4	;

00004fa6 <.Loc.482.2>:
    if (--n == 0U) {
    4fa6:	a5 0f ff ff 	adda	#1048575,r5	;0xfffff
    4faa:	95 00 00 00 	cmpa	#0,	r5	;
    4fae:	1d 24       	jz	$+60     	;abs 0x4fea

00004fb0 <.LBB118>:
  chSysLock();
    4fb0:	48 13       	calla	r8		;

00004fb2 <.LBE118>:
    *oqp->q_wrptr++ = *bp++;
    4fb2:	06 01       	mova	@r1,	r6	;
    4fb4:	80 00 36 4f 	mova	#20278,	r0	;0x04f36

00004fb8 <.L66>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    4fb8:	0c 49       	mov	r9,	r12	;
    4fba:	3c 53       	add	#-1,	r12	;r3 As==11
    4fbc:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    4fc0:	0d 9c       	cmp	r12,	r13	;
    4fc2:	09 2c       	jc	$+20     	;abs 0x4fd6

00004fc4 <.LBB120>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    4fc4:	0d 49       	mov	r9,	r13	;

00004fc6 <.L63>:
    4fc6:	cc 0a       	mova	r10,	r12	;
    4fc8:	b0 13 52 47 	calla	#18258		;0x04752

00004fcc <.LBE122>:
      if (msg != MSG_OK) {
    4fcc:	9c 00 00 00 	cmpa	#0,	r12	;
    4fd0:	b2 27       	jz	$-154    	;abs 0x4f36
    4fd2:	80 00 e6 4f 	mova	#20454,	r0	;0x04fe6

00004fd6 <.L61>:
  return chVTGetSystemTimeX();
    4fd6:	c0 18 1c 42 	movx.w	&0x112f4,r12	;
    4fda:	f4 12 

00004fdc <.LBE125>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    4fdc:	1d 41 04 00 	mov	4(r1),	r13	;
    4fe0:	0d 8c       	sub	r12,	r13	;

00004fe2 <.LVL78>:
        if (next_timeout > timeout) {
    4fe2:	09 9d       	cmp	r13,	r9	;
    4fe4:	f0 2f       	jc	$-30     	;abs 0x4fc6

00004fe6 <.L78>:
  chSysUnlock();
    4fe6:	b0 13 fc 4a 	calla	#19196		;0x04afc

00004fea <.L59>:
      return w;
    }

    osalSysLock();
  }
}
    4fea:	cc 04       	mova	r4,	r12	;
    4fec:	a1 00 06 00 	adda	#6,	r1	;
    4ff0:	64 16       	popm.a	#7,	r10	;20-bit words
    4ff2:	10 01       	reta			;

00004ff4 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    4ff4:	b0 13 ee 62 	calla	#25326		;0x062ee

00004ff8 <.LVL0>:
}
    4ff8:	10 01       	reta			;

00004ffa <adcObjectInit>:
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
    4ffa:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004ffe <.Loc.71.1>:
  adcp->config   = NULL;
    4ffe:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    5002:	02 00 

00005004 <.Loc.72.1>:
  adcp->samples  = NULL;
    5004:	00 18 cc 43 	movx.a	#0,	6(r12)	;r3 As==00
    5008:	06 00 

0000500a <.Loc.73.1>:
  adcp->depth    = 0;
    500a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a
    500e:	fc f0 f0 ff 	and.b	#-16,	12(r12)	;#0xfff0, 0x000c
    5012:	0c 00 

00005014 <.Loc.74.1>:
  adcp->grpp     = NULL;
    5014:	00 18 cc 43 	movx.a	#0,	14(r12)	;r3 As==00, 0x0000e
    5018:	0e 00 

0000501a <.Loc.84.1>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    501a:	10 01       	reta			;

0000501c <port_lock>:
  _disable_interrupts();
    501c:	32 c2       	dint			
    501e:	03 43       	nop			

00005020 <.Loc.348.1>:
  asm volatile("nop");
    5020:	03 43       	nop			

00005022 <.Loc.349.1>:
}
    5022:	10 01       	reta			;

00005024 <port_unlock>:
  asm volatile("nop");
    5024:	03 43       	nop			

00005026 <.Loc.356.1>:
  _enable_interrupts();
    5026:	03 43       	nop			
    5028:	32 d2       	eint			
    502a:	03 43       	nop			

0000502c <.Loc.357.1>:
}
    502c:	10 01       	reta			;

0000502e <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    502e:	b0 13 e4 61 	calla	#25060		;0x061e4

00005032 <.LVL0>:
}
    5032:	10 01       	reta			;

00005034 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    5034:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00005038 <.Loc.71.2>:
  gptp->config = NULL;
    5038:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    503c:	02 00 

0000503e <.Loc.72.2>:
}
    503e:	10 01       	reta			;

00005040 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    5040:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005042 <.LCFI0>:
    5042:	08 14       	pushm.a	#1,	r8	;20-bit words

00005044 <.LCFI1>:
    5044:	ca 0c       	mova	r12,	r10	;
    5046:	c8 0d       	mova	r13,	r8	;

00005048 <.LBB26>:
  chSysLock();
    5048:	b0 13 1c 50 	calla	#20508		;0x0501c

0000504c <.LBE26>:
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
    504c:	7a 08 02 00 	mova	r8,	2(r10)	;

00005050 <.Loc.90.2>:
  gpt_lld_start(gptp);
    5050:	cc 0a       	mova	r10,	r12	;
    5052:	b0 13 18 62 	calla	#25112		;0x06218

00005056 <.LVL4>:
  gptp->state = GPT_READY;
    5056:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000505a <.LBB28>:
  chSysUnlock();
    505a:	b0 13 24 50 	calla	#20516		;0x05024

0000505e <.LBE28>:
  osalSysUnlock();
}
    505e:	08 16       	popm.a	#1,	r8	;20-bit words
    5060:	0a 16       	popm.a	#1,	r10	;20-bit words
    5062:	10 01       	reta			;

00005064 <gptStartContinuousI>:
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
    5064:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    5068:	00 00 

0000506a <.Loc.171.2>:
  gpt_lld_start_timer(gptp, interval);
    506a:	b0 13 be 62 	calla	#25278		;0x062be

0000506e <.LVL14>:
}
    506e:	10 01       	reta			;

00005070 <gptStartContinuous>:
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
    5070:	b1 00 08 00 	suba	#8,	r1	;

00005074 <.LBB38>:
  chSysLock();
    5074:	71 0c 04 00 	mova	r12,	4(r1)	;
    5078:	71 0d 00 00 	mova	r13,	0(r1)	;
    507c:	b0 13 1c 50 	calla	#20508		;0x0501c

00005080 <.LBE38>:
  gptStartContinuousI(gptp, interval);
    5080:	0d 01       	mova	@r1,	r13	;
    5082:	3c 01 04 00 	mova	4(r1),	r12	;
    5086:	b0 13 64 50 	calla	#20580		;0x05064

0000508a <.LBB40>:
  chSysUnlock();
    508a:	b0 13 24 50 	calla	#20516		;0x05024

0000508e <.LBE40>:
}
    508e:	a1 00 08 00 	adda	#8,	r1	;
    5092:	10 01       	reta			;

00005094 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    5094:	b0 13 90 5d 	calla	#23952		;0x05d90

00005098 <.LVL0>:
}
    5098:	10 01       	reta			;

0000509a <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
    509a:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000509e <.Loc.74.1>:
  i2cp->config = NULL;
    509e:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    50a2:	02 00 

000050a4 <.Loc.83.1>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    50a4:	10 01       	reta			;

000050a6 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
    50a6:	0a 14       	pushm.a	#1,	r10	;20-bit words

000050a8 <.LCFI0>:
    50a8:	ca 0c       	mova	r12,	r10	;

000050aa <.LBB26>:
  _disable_interrupts();
    50aa:	32 c2       	dint			
    50ac:	03 43       	nop			

000050ae <.Loc.348.2>:
  asm volatile("nop");
    50ae:	03 43       	nop			

000050b0 <.LBE26>:
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
    50b0:	7c 0d 02 00 	mova	r13,	2(r12)	;

000050b4 <.Loc.101.1>:
  i2c_lld_start(i2cp);
    50b4:	b0 13 c8 5d 	calla	#24008		;0x05dc8

000050b8 <.LVL3>:
  i2cp->state = I2C_READY;
    50b8:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000050bc <.LBB29>:
  asm volatile("nop");
    50bc:	03 43       	nop			

000050be <.Loc.356.2>:
  _enable_interrupts();
    50be:	03 43       	nop			
    50c0:	32 d2       	eint			
    50c2:	03 43       	nop			

000050c4 <.LBE29>:
  osalSysUnlock();
}
    50c4:	0a 16       	popm.a	#1,	r10	;20-bit words
    50c6:	10 01       	reta			;

000050c8 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    50c8:	4a 14       	pushm.a	#5,	r10	;20-bit words

000050ca <.LCFI0>:
    50ca:	ca 0c       	mova	r12,	r10	;

000050cc <.Loc.828.1>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    50cc:	26 4c       	mov	@r12,	r6	;
    50ce:	17 4c 02 00 	mov	2(r12),	r7	;
    50d2:	08 4d       	mov	r13,	r8	;
    50d4:	08 d6       	bis	r6,	r8	;
    50d6:	09 4e       	mov	r14,	r9	;
    50d8:	09 d7       	bis	r7,	r9	;
    50da:	8c 48 00 00 	mov	r8,	0(r12)	;
    50de:	8c 49 02 00 	mov	r9,	2(r12)	;

000050e2 <.Loc.829.1>:
  if (esp->cb != NULL) {
    50e2:	3e 0c 04 00 	mova	4(r12),	r14	;
    50e6:	9e 00 00 00 	cmpa	#0,	r14	;
    50ea:	01 24       	jz	$+4      	;abs 0x50ee

000050ec <.Loc.830.1>:
    esp->cb(esp);
    50ec:	4e 13       	calla	r14		;

000050ee <.L1>:
  }
}
    50ee:	46 16       	popm.a	#5,	r10	;20-bit words
    50f0:	10 01       	reta			;

000050f2 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    50f2:	ac 00 12 00 	adda	#18,	r12	;0x00012

000050f6 <.LVL3>:
    50f6:	b0 13 76 4c 	calla	#19574		;0x04c76

000050fa <.LVL4>:
}
    50fa:	10 01       	reta			;

000050fc <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    50fc:	4f 43       	clr.b	r15		;
    50fe:	ac 00 12 00 	adda	#18,	r12	;0x00012

00005102 <.LVL6>:
    5102:	b0 13 76 4c 	calla	#19574		;0x04c76

00005106 <.LVL7>:
}
    5106:	10 01       	reta			;

00005108 <writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    5108:	ac 00 30 00 	adda	#48,	r12	;0x00030

0000510c <.LVL9>:
    510c:	b0 13 0e 4f 	calla	#20238		;0x04f0e

00005110 <.LVL10>:
}
    5110:	10 01       	reta			;

00005112 <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    5112:	4f 43       	clr.b	r15		;
    5114:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005118 <.LVL12>:
    5118:	b0 13 0e 4f 	calla	#20238		;0x04f0e

0000511c <.LVL13>:
}
    511c:	10 01       	reta			;

0000511e <gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    511e:	ac 00 12 00 	adda	#18,	r12	;0x00012

00005122 <.LVL15>:
    5122:	b0 13 dc 4b 	calla	#19420		;0x04bdc

00005126 <.LVL16>:
}
    5126:	10 01       	reta			;

00005128 <get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    5128:	4d 43       	clr.b	r13		;
    512a:	ac 00 12 00 	adda	#18,	r12	;0x00012

0000512e <.LVL18>:
    512e:	b0 13 dc 4b 	calla	#19420		;0x04bdc

00005132 <.LVL19>:
}
    5132:	10 01       	reta			;

00005134 <putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    5134:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005138 <.LVL21>:
    5138:	b0 13 f4 4d 	calla	#19956		;0x04df4

0000513c <.LVL22>:
}
    513c:	10 01       	reta			;

0000513e <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    513e:	4e 43       	clr.b	r14		;
    5140:	ac 00 30 00 	adda	#48,	r12	;0x00030

00005144 <.LVL24>:
    5144:	b0 13 f4 4d 	calla	#19956		;0x04df4

00005148 <.LVL25>:
}
    5148:	10 01       	reta			;

0000514a <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    514a:	b0 13 d2 55 	calla	#21970		;0x055d2

0000514e <.LVL26>:
}
    514e:	10 01       	reta			;

00005150 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    5150:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005152 <.LCFI1>:
    5152:	08 14       	pushm.a	#1,	r8	;20-bit words

00005154 <.LCFI2>:
    5154:	06 14       	pushm.a	#1,	r6	;20-bit words

00005156 <.LCFI3>:
    5156:	b1 00 04 00 	suba	#4,	r1	;

0000515a <.LCFI4>:
    515a:	c6 0c       	mova	r12,	r6	;
    515c:	c8 0e       	mova	r14,	r8	;

0000515e <.Loc.133.2>:

  sdp->vmt = &vmt;
    515e:	80 18 fc 40 	movx.a	#65536,	0(r12)	;0x10000
    5162:	00 00 00 00 

00005166 <.LBB22>:
  esp->flags = 0;
    5166:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    516a:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

0000516e <.Loc.811.1>:
  esp->cb    = NULL;
    516e:	00 18 cc 43 	movx.a	#0,	8(r12)	;r3 As==00
    5172:	08 00 

00005174 <.Loc.812.1>:
  esp->param = NULL;
    5174:	00 18 cc 43 	movx.a	#0,	12(r12)	;r3 As==00, 0x0000c
    5178:	0c 00 

0000517a <.LBE22>:
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    517a:	dc 43 10 00 	mov.b	#1,	16(r12)	;r3 As==01, 0x0010

0000517e <.Loc.136.2>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    517e:	7a 40 20 00 	mov.b	#32,	r10	;#0x0020
    5182:	71 0c 00 00 	mova	r12,	0(r1)	;
    5186:	cf 0d       	mova	r13,	r15	;
    5188:	ce 0a       	mova	r10,	r14	;

0000518a <.LVL30>:
    518a:	cd 0c       	mova	r12,	r13	;

0000518c <.LVL31>:
    518c:	ad 00 4e 00 	adda	#78,	r13	;0x0004e
    5190:	ac 00 12 00 	adda	#18,	r12	;0x00012

00005194 <.LVL32>:
    5194:	b0 13 06 4b 	calla	#19206		;0x04b06

00005198 <.LVL33>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    5198:	71 06 00 00 	mova	r6,	0(r1)	;
    519c:	cf 08       	mova	r8,	r15	;
    519e:	ce 0a       	mova	r10,	r14	;
    51a0:	cd 06       	mova	r6,	r13	;
    51a2:	ad 00 6e 00 	adda	#110,	r13	;0x0006e
    51a6:	cc 06       	mova	r6,	r12	;
    51a8:	ac 00 30 00 	adda	#48,	r12	;0x00030
    51ac:	b0 13 5c 4d 	calla	#19804		;0x04d5c

000051b0 <.LVL34>:
}
    51b0:	a1 00 04 00 	adda	#4,	r1	;
    51b4:	06 16       	popm.a	#1,	r6	;20-bit words
    51b6:	08 16       	popm.a	#1,	r8	;20-bit words
    51b8:	0a 16       	popm.a	#1,	r10	;20-bit words
    51ba:	10 01       	reta			;

000051bc <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    51bc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000051be <.LCFI5>:
    51be:	ca 0c       	mova	r12,	r10	;

000051c0 <.LBB32>:
  _disable_interrupts();
    51c0:	32 c2       	dint			
    51c2:	03 43       	nop			

000051c4 <.Loc.348.3>:
  asm volatile("nop");
    51c4:	03 43       	nop			

000051c6 <.LBE32>:
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    51c6:	b0 13 e2 55 	calla	#21986		;0x055e2

000051ca <.LVL36>:
  sdp->state = SD_READY;
    51ca:	ea 43 10 00 	mov.b	#2,	16(r10)	;r3 As==10, 0x0010

000051ce <.LBB35>:
  asm volatile("nop");
    51ce:	03 43       	nop			

000051d0 <.Loc.356.3>:
  _enable_interrupts();
    51d0:	03 43       	nop			
    51d2:	32 d2       	eint			
    51d4:	03 43       	nop			

000051d6 <.LBE35>:
  osalSysUnlock();
}
    51d6:	0a 16       	popm.a	#1,	r10	;20-bit words
    51d8:	10 01       	reta			;

000051da <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
    51da:	0a 14       	pushm.a	#1,	r10	;20-bit words

000051dc <.LCFI6>:
    51dc:	ca 0c       	mova	r12,	r10	;

000051de <.LBB48>:
  _disable_interrupts();
    51de:	32 c2       	dint			
    51e0:	03 43       	nop			

000051e2 <.Loc.348.3>:
  asm volatile("nop");
    51e2:	03 43       	nop			

000051e4 <.LBE48>:
  osalSysLock();

  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");

  sd_lld_stop(sdp);
    51e4:	b0 13 c4 56 	calla	#22212		;0x056c4

000051e8 <.LVL38>:
  sdp->state = SD_STOP;
    51e8:	da 43 10 00 	mov.b	#1,	16(r10)	;r3 As==01, 0x0010

000051ec <.Loc.190.2>:
  oqResetI(&sdp->oqueue);
    51ec:	cc 0a       	mova	r10,	r12	;
    51ee:	ac 00 30 00 	adda	#48,	r12	;0x00030
    51f2:	b0 13 ae 4d 	calla	#19886		;0x04dae

000051f6 <.LVL39>:
  iqResetI(&sdp->iqueue);
    51f6:	cc 0a       	mova	r10,	r12	;
    51f8:	ac 00 12 00 	adda	#18,	r12	;0x00012
    51fc:	b0 13 3a 4b 	calla	#19258		;0x04b3a

00005200 <.LBB51>:
  chSchRescheduleS();
    5200:	b0 13 90 46 	calla	#18064		;0x04690

00005204 <.LBB53>:
  asm volatile("nop");
    5204:	03 43       	nop			

00005206 <.Loc.356.3>:
  _enable_interrupts();
    5206:	03 43       	nop			
    5208:	32 d2       	eint			
    520a:	03 43       	nop			

0000520c <.LBE53>:
  osalOsRescheduleS();

  osalSysUnlock();
}
    520c:	0a 16       	popm.a	#1,	r10	;20-bit words
    520e:	10 01       	reta			;

00005210 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    5210:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005212 <.LCFI7>:
    5212:	ca 0c       	mova	r12,	r10	;
    5214:	49 4d       	mov.b	r13,	r9	;

00005216 <.Loc.218.2>:

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    5216:	3c 0c 14 00 	mova	20(r12),r12	;0x00014

0000521a <.LVL43>:
    521a:	9c 00 00 00 	cmpa	#0,	r12	;
    521e:	07 20       	jnz	$+16     	;abs 0x522e

00005220 <.Loc.219.2>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    5220:	6d 42       	mov.b	#4,	r13	;r2 As==10

00005222 <.LVL44>:
    5222:	4e 43       	clr.b	r14		;
    5224:	cc 0a       	mova	r10,	r12	;
    5226:	ac 00 04 00 	adda	#4,	r12	;
    522a:	b0 13 c8 50 	calla	#20680		;0x050c8

0000522e <.L19>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    522e:	4d 49       	mov.b	r9,	r13	;
    5230:	cc 0a       	mova	r10,	r12	;
    5232:	ac 00 12 00 	adda	#18,	r12	;0x00012
    5236:	b0 13 5e 4b 	calla	#19294		;0x04b5e

0000523a <.LVL46>:
    523a:	9c 00 00 00 	cmpa	#0,	r12	;
    523e:	08 34       	jge	$+18     	;abs 0x5250

00005240 <.Loc.221.2>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    5240:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    5244:	4e 43       	clr.b	r14		;
    5246:	cc 0a       	mova	r10,	r12	;
    5248:	ac 00 04 00 	adda	#4,	r12	;
    524c:	b0 13 c8 50 	calla	#20680		;0x050c8

00005250 <.L18>:
}
    5250:	19 16       	popm.a	#2,	r10	;20-bit words
    5252:	10 01       	reta			;

00005254 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    5254:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005256 <.LCFI8>:
    5256:	08 14       	pushm.a	#1,	r8	;20-bit words

00005258 <.LCFI9>:
    5258:	c8 0c       	mova	r12,	r8	;

0000525a <.Loc.245.2>:
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    525a:	ac 00 30 00 	adda	#48,	r12	;0x00030

0000525e <.LVL49>:
    525e:	b0 13 92 4e 	calla	#20114		;0x04e92

00005262 <.LVL50>:
    5262:	ca 0c       	mova	r12,	r10	;

00005264 <.Loc.246.2>:
  if (b < MSG_OK)
    5264:	9c 00 00 00 	cmpa	#0,	r12	;
    5268:	07 34       	jge	$+16     	;abs 0x5278

0000526a <.Loc.247.2>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    526a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    526c:	4e 43       	clr.b	r14		;
    526e:	cc 08       	mova	r8,	r12	;
    5270:	ac 00 04 00 	adda	#4,	r12	;
    5274:	b0 13 c8 50 	calla	#20680		;0x050c8

00005278 <.L21>:
  return b;
}
    5278:	cc 0a       	mova	r10,	r12	;
    527a:	08 16       	popm.a	#1,	r8	;20-bit words
    527c:	0a 16       	popm.a	#1,	r10	;20-bit words
    527e:	10 01       	reta			;

00005280 <port_lock>:
  _disable_interrupts();
    5280:	32 c2       	dint			
    5282:	03 43       	nop			

00005284 <.Loc.348.1>:
  asm volatile("nop");
    5284:	03 43       	nop			

00005286 <.Loc.349.1>:
}
    5286:	10 01       	reta			;

00005288 <port_unlock>:
  asm volatile("nop");
    5288:	03 43       	nop			

0000528a <.Loc.356.1>:
  _enable_interrupts();
    528a:	03 43       	nop			
    528c:	32 d2       	eint			
    528e:	03 43       	nop			

00005290 <.Loc.357.1>:
}
    5290:	10 01       	reta			;

00005292 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    5292:	b0 13 ba 5b 	calla	#23482		;0x05bba

00005296 <.LVL2>:
}
    5296:	10 01       	reta			;

00005298 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    5298:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000529c <.Loc.71.3>:
  spip->config = NULL;
    529c:	00 18 cc 43 	movx.a	#0,	2(r12)	;r3 As==00
    52a0:	02 00 

000052a2 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    52a2:	00 18 cc 43 	movx.a	#0,	6(r12)	;r3 As==00
    52a6:	06 00 

000052a8 <.LBB54>:
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

  chSemObjectInit((semaphore_t *)mp, (cnt_t)1);
    52a8:	9c 43 0a 00 	mov	#1,	10(r12)	;r3 As==01, 0x000a

000052ac <.LBE54>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    52ac:	10 01       	reta			;

000052ae <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    52ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052b0 <.LCFI0>:
    52b0:	08 14       	pushm.a	#1,	r8	;20-bit words

000052b2 <.LCFI1>:
    52b2:	ca 0c       	mova	r12,	r10	;
    52b4:	c8 0d       	mova	r13,	r8	;

000052b6 <.LBB56>:
  chSysLock();
    52b6:	b0 13 80 52 	calla	#21120		;0x05280

000052ba <.LBE56>:
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    52ba:	7a 08 02 00 	mova	r8,	2(r10)	;

000052be <.Loc.99.3>:
  spi_lld_start(spip);
    52be:	cc 0a       	mova	r10,	r12	;
    52c0:	b0 13 aa 5c 	calla	#23722		;0x05caa

000052c4 <.LVL8>:
  spip->state = SPI_READY;
    52c4:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

000052c8 <.LBB58>:
  chSysUnlock();
    52c8:	b0 13 88 52 	calla	#21128		;0x05288

000052cc <.LBE58>:
  osalSysUnlock();
}
    52cc:	08 16       	popm.a	#1,	r8	;20-bit words
    52ce:	0a 16       	popm.a	#1,	r10	;20-bit words
    52d0:	10 01       	reta			;

000052d2 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
    52d2:	0a 14       	pushm.a	#1,	r10	;20-bit words

000052d4 <.LCFI10>:
    52d4:	b1 00 08 00 	suba	#8,	r1	;

000052d8 <.LCFI11>:
    52d8:	ca 0d       	mova	r13,	r10	;

000052da <.LBB80>:
  chSysLock();
    52da:	71 0c 04 00 	mova	r12,	4(r1)	;
    52de:	71 0e 00 00 	mova	r14,	0(r1)	;
    52e2:	b0 13 80 52 	calla	#21120		;0x05280

000052e6 <.LBE80>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
    52e6:	3c 01 04 00 	mova	4(r1),	r12	;
    52ea:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    52ee:	00 00 
    52f0:	0e 01       	mova	@r1,	r14	;
    52f2:	cd 0a       	mova	r10,	r13	;
    52f4:	b0 13 38 5d 	calla	#23864		;0x05d38

000052f8 <.LBB82>:
  chSysUnlock();
    52f8:	b0 13 88 52 	calla	#21128		;0x05288

000052fc <.LBE82>:
  osalSysUnlock();
}
    52fc:	a1 00 08 00 	adda	#8,	r1	;
    5300:	0a 16       	popm.a	#1,	r10	;20-bit words
    5302:	10 01       	reta			;

00005304 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    5304:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    5308:	80 5a 5c 01 

0000530c <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    530c:	c0 1f b2 40 	movx.w	#-23280,&0x00140;0xfa510
    5310:	10 a5 40 01 

00005314 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    5314:	40 18 f2 43 	movx.b	#-1,	&0x00141;r3 As==11
    5318:	41 01 

0000531a <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    531a:	c0 1f b2 40 	movx.w	#-23296,&0x00160;0xfa500
    531e:	00 a5 60 01 

00005322 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    5322:	40 18 b2 40 	movx.w	#72,	&0x00162;0x00048
    5326:	48 00 62 01 

0000532a <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    532a:	40 18 b2 40 	movx.w	#307,	&0x00164;0x00133
    532e:	33 01 64 01 

00005332 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    5332:	40 18 82 43 	movx.w	#0,	&0x00166;r3 As==00
    5336:	66 01 

00005338 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    5338:	c0 1f b2 40 	movx.w	#-15927,&0x00168;0xfc1c9
    533c:	c9 c1 68 01 

00005340 <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    5340:	40 18 b2 40 	movx.w	#15,	&0x0016c;0x0000f
    5344:	0f 00 6c 01 

00005348 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    5348:	40 18 f2 43 	movx.b	#-1,	&0x00161;r3 As==11
    534c:	61 01 

0000534e <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    534e:	b0 13 8c 59 	calla	#22924		;0x0598c

00005352 <.LVL0>:
#endif
}
    5352:	10 01       	reta			;

00005354 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    5354:	40 18 b2 40 	movx.w	#15999,	&0x003d2;0x03e7f
    5358:	7f 3e d2 03 

0000535c <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    535c:	40 18 b2 40 	movx.w	#16,	&0x003c2;0x00010
    5360:	10 00 c2 03 

00005364 <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    5364:	40 18 82 43 	movx.w	#0,	&0x003e0;r3 As==00
    5368:	e0 03 

0000536a <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    536a:	40 18 b2 40 	movx.w	#532,	&0x003c0;0x00214
    536e:	14 02 c0 03 

00005372 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    5372:	10 01       	reta			;

00005374 <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    5374:	4a 14       	pushm.a	#5,	r10	;20-bit words

00005376 <.LCFI0>:
    5376:	ca 0c       	mova	r12,	r10	;

00005378 <.Loc.828.1>:
  esp->flags |= flags;
    5378:	26 4c       	mov	@r12,	r6	;
    537a:	17 4c 02 00 	mov	2(r12),	r7	;
    537e:	08 4d       	mov	r13,	r8	;
    5380:	08 d6       	bis	r6,	r8	;
    5382:	09 4e       	mov	r14,	r9	;
    5384:	09 d7       	bis	r7,	r9	;
    5386:	8c 48 00 00 	mov	r8,	0(r12)	;
    538a:	8c 49 02 00 	mov	r9,	2(r12)	;

0000538e <.Loc.829.1>:
  if (esp->cb != NULL) {
    538e:	3e 0c 04 00 	mova	4(r12),	r14	;
    5392:	9e 00 00 00 	cmpa	#0,	r14	;
    5396:	01 24       	jz	$+4      	;abs 0x539a

00005398 <.Loc.830.1>:
    esp->cb(esp);
    5398:	4e 13       	calla	r14		;

0000539a <.L1>:
}
    539a:	46 16       	popm.a	#5,	r10	;20-bit words
    539c:	10 01       	reta			;

0000539e <notify1>:

#if (MSP430X_SERIAL_USE_USART1 == TRUE) || defined(__DOXYGEN__)
static void notify1(io_queue_t * qp) {

  (void)qp;
  UCA1IE |= UCTXIE;
    539e:	40 18 a2 d3 	bisx.w	#2,	&0x005fa;r3 As==10
    53a2:	fa 05 

000053a4 <.Loc.288.2>:
}
    53a4:	10 01       	reta			;

000053a6 <UCBRS>:
  if (frac < 529)
    53a6:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    53aa:	0d 9c       	cmp	r12,	r13	;
    53ac:	8b 2c       	jc	$+280    	;abs 0x54c4

000053ae <.Loc.109.2>:
  else if (frac < 715)
    53ae:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    53b2:	0d 9c       	cmp	r12,	r13	;
    53b4:	8a 2c       	jc	$+278    	;abs 0x54ca

000053b6 <.Loc.111.2>:
  else if (frac < 835)
    53b6:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    53ba:	0d 9c       	cmp	r12,	r13	;
    53bc:	89 2c       	jc	$+276    	;abs 0x54d0

000053be <.Loc.113.2>:
  else if (frac < 1001)
    53be:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    53c2:	0d 9c       	cmp	r12,	r13	;
    53c4:	88 2c       	jc	$+274    	;abs 0x54d6

000053c6 <.Loc.115.2>:
  else if (frac < 1252)
    53c6:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    53ca:	0d 9c       	cmp	r12,	r13	;
    53cc:	87 2c       	jc	$+272    	;abs 0x54dc

000053ce <.Loc.117.2>:
  else if (frac < 1430)
    53ce:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    53d2:	0d 9c       	cmp	r12,	r13	;
    53d4:	86 2c       	jc	$+270    	;abs 0x54e2

000053d6 <.Loc.119.2>:
  else if (frac < 1670)
    53d6:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    53da:	0d 9c       	cmp	r12,	r13	;
    53dc:	86 2c       	jc	$+270    	;abs 0x54ea

000053de <.Loc.121.2>:
  else if (frac < 2147)
    53de:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    53e2:	0d 9c       	cmp	r12,	r13	;
    53e4:	86 2c       	jc	$+270    	;abs 0x54f2

000053e6 <.Loc.123.2>:
  else if (frac < 2224)
    53e6:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    53ea:	0d 9c       	cmp	r12,	r13	;
    53ec:	86 2c       	jc	$+270    	;abs 0x54fa

000053ee <.Loc.125.2>:
  else if (frac < 2503)
    53ee:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    53f2:	0d 9c       	cmp	r12,	r13	;
    53f4:	86 2c       	jc	$+270    	;abs 0x5502

000053f6 <.Loc.127.2>:
  else if (frac < 3000)
    53f6:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    53fa:	0d 9c       	cmp	r12,	r13	;
    53fc:	86 2c       	jc	$+270    	;abs 0x550a

000053fe <.LBB26>:
  else if (frac < 3335)
    53fe:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    5402:	0d 9c       	cmp	r12,	r13	;
    5404:	86 2c       	jc	$+270    	;abs 0x5512

00005406 <.Loc.131.2>:
  else if (frac < 3575)
    5406:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    540a:	0d 9c       	cmp	r12,	r13	;
    540c:	86 2c       	jc	$+270    	;abs 0x551a

0000540e <.Loc.133.2>:
  else if (frac < 3753)
    540e:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    5412:	0d 9c       	cmp	r12,	r13	;
    5414:	86 2c       	jc	$+270    	;abs 0x5522

00005416 <.Loc.135.2>:
  else if (frac < 4003)
    5416:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    541a:	0d 9c       	cmp	r12,	r13	;
    541c:	86 2c       	jc	$+270    	;abs 0x552a

0000541e <.Loc.137.2>:
  else if (frac < 4286)
    541e:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    5422:	0d 9c       	cmp	r12,	r13	;
    5424:	86 2c       	jc	$+270    	;abs 0x5532

00005426 <.Loc.139.2>:
  else if (frac < 4378)
    5426:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    542a:	0d 9c       	cmp	r12,	r13	;
    542c:	86 2c       	jc	$+270    	;abs 0x553a

0000542e <.Loc.141.2>:
  else if (frac < 5002)
    542e:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    5432:	0d 9c       	cmp	r12,	r13	;
    5434:	86 2c       	jc	$+270    	;abs 0x5542

00005436 <.Loc.143.2>:
  else if (frac < 5715)
    5436:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    543a:	0d 9c       	cmp	r12,	r13	;
    543c:	86 2c       	jc	$+270    	;abs 0x554a

0000543e <.Loc.145.2>:
  else if (frac < 6003)
    543e:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    5442:	0d 9c       	cmp	r12,	r13	;
    5444:	86 2c       	jc	$+270    	;abs 0x5552

00005446 <.Loc.147.2>:
  else if (frac < 6254)
    5446:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    544a:	0d 9c       	cmp	r12,	r13	;
    544c:	86 2c       	jc	$+270    	;abs 0x555a

0000544e <.Loc.149.2>:
  else if (frac < 6432)
    544e:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    5452:	0d 9c       	cmp	r12,	r13	;
    5454:	86 2c       	jc	$+270    	;abs 0x5562

00005456 <.Loc.151.2>:
  else if (frac < 6667)
    5456:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    545a:	0d 9c       	cmp	r12,	r13	;
    545c:	86 2c       	jc	$+270    	;abs 0x556a

0000545e <.Loc.153.2>:
  else if (frac < 7001)
    545e:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    5462:	0d 9c       	cmp	r12,	r13	;
    5464:	86 2c       	jc	$+270    	;abs 0x5572

00005466 <.Loc.155.2>:
  else if (frac < 7147)
    5466:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    546a:	0d 9c       	cmp	r12,	r13	;
    546c:	86 2c       	jc	$+270    	;abs 0x557a

0000546e <.Loc.157.2>:
  else if (frac < 7503)
    546e:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    5472:	0d 9c       	cmp	r12,	r13	;
    5474:	86 2c       	jc	$+270    	;abs 0x5582

00005476 <.Loc.159.2>:
  else if (frac < 7861)
    5476:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    547a:	0d 9c       	cmp	r12,	r13	;
    547c:	86 2c       	jc	$+270    	;abs 0x558a

0000547e <.Loc.161.2>:
  else if (frac < 8004)
    547e:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    5482:	0d 9c       	cmp	r12,	r13	;
    5484:	86 2c       	jc	$+270    	;abs 0x5592

00005486 <.Loc.163.2>:
  else if (frac < 8333)
    5486:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    548a:	0d 9c       	cmp	r12,	r13	;
    548c:	86 2c       	jc	$+270    	;abs 0x559a

0000548e <.Loc.165.2>:
  else if (frac < 8464)
    548e:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    5492:	0d 9c       	cmp	r12,	r13	;
    5494:	86 2c       	jc	$+270    	;abs 0x55a2

00005496 <.Loc.167.2>:
  else if (frac < 8572)
    5496:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    549a:	0d 9c       	cmp	r12,	r13	;
    549c:	86 2c       	jc	$+270    	;abs 0x55aa

0000549e <.Loc.169.2>:
  else if (frac < 8751)
    549e:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    54a2:	0d 9c       	cmp	r12,	r13	;
    54a4:	86 2c       	jc	$+270    	;abs 0x55b2

000054a6 <.Loc.171.2>:
  else if (frac < 9004)
    54a6:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    54aa:	0d 9c       	cmp	r12,	r13	;
    54ac:	86 2c       	jc	$+270    	;abs 0x55ba

000054ae <.Loc.173.2>:
  else if (frac < 9170)
    54ae:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    54b2:	0d 9c       	cmp	r12,	r13	;
    54b4:	86 2c       	jc	$+270    	;abs 0x55c2

000054b6 <.Loc.175.2>:
  else if (frac < 9288)
    54b6:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    54ba:	0d 9c       	cmp	r12,	r13	;
    54bc:	86 2c       	jc	$+270    	;abs 0x55ca

000054be <.Loc.178.2>:
    return 0xFE;
    54be:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000054c2 <.L8>:
}
    54c2:	10 01       	reta			;

000054c4 <.L9>:
    return 0x00;
    54c4:	4c 43       	clr.b	r12		;

000054c6 <.LVL7>:
    54c6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054ca <.L10>:
    return 0x01;
    54ca:	5c 43       	mov.b	#1,	r12	;r3 As==01

000054cc <.LVL9>:
    54cc:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054d0 <.L11>:
    return 0x02;
    54d0:	6c 43       	mov.b	#2,	r12	;r3 As==10

000054d2 <.LVL11>:
    54d2:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054d6 <.L12>:
    return 0x04;
    54d6:	6c 42       	mov.b	#4,	r12	;r2 As==10

000054d8 <.LVL13>:
    54d8:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054dc <.L13>:
    return 0x08;
    54dc:	7c 42       	mov.b	#8,	r12	;r2 As==11

000054de <.LVL15>:
    54de:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054e2 <.L14>:
    return 0x10;
    54e2:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000054e6 <.LVL17>:
    54e6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054ea <.L15>:
    return 0x20;
    54ea:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000054ee <.LVL19>:
    54ee:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054f2 <.L16>:
    return 0x11;
    54f2:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000054f6 <.LVL21>:
    54f6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000054fa <.L17>:
    return 0x21;
    54fa:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

000054fe <.LVL23>:
    54fe:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005502 <.L18>:
    return 0x22;
    5502:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00005506 <.LVL25>:
    5506:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000550a <.L19>:
    return 0x44;
    550a:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

0000550e <.LVL27>:
    550e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005512 <.L20>:
    return 0x25;
    5512:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00005516 <.LVL29>:
    5516:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000551a <.L21>:
    return 0x49;
    551a:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

0000551e <.LVL31>:
    551e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005522 <.L22>:
    return 0x4A;
    5522:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

00005526 <.LVL33>:
    5526:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000552a <.L23>:
    return 0x52;
    552a:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

0000552e <.LVL35>:
    552e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005532 <.L24>:
    return 0x92;
    5532:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00005536 <.LVL37>:
    5536:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000553a <.L25>:
    return 0x53;
    553a:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

0000553e <.LVL39>:
    553e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005542 <.L26>:
    return 0x55;
    5542:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00005546 <.LVL41>:
    5546:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000554a <.L27>:
    return 0xAA;
    554a:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

0000554e <.LVL43>:
    554e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005552 <.L28>:
    return 0x6B;
    5552:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00005556 <.LVL45>:
    5556:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000555a <.L29>:
    return 0xAD;
    555a:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

0000555e <.LVL47>:
    555e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005562 <.L30>:
    return 0xB5;
    5562:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

00005566 <.LVL49>:
    5566:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000556a <.L31>:
    return 0xB6;
    556a:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

0000556e <.LVL51>:
    556e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005572 <.L32>:
    return 0xD6;
    5572:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00005576 <.LVL53>:
    5576:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000557a <.L33>:
    return 0xB7;
    557a:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

0000557e <.LVL55>:
    557e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005582 <.L34>:
    return 0xBB;
    5582:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

00005586 <.LVL57>:
    5586:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000558a <.L35>:
    return 0xDD;
    558a:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

0000558e <.LVL59>:
    558e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

00005592 <.L36>:
    return 0xED;
    5592:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00005596 <.LVL61>:
    5596:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

0000559a <.L37>:
    return 0xEE;
    559a:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

0000559e <.LVL63>:
    559e:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055a2 <.L38>:
    return 0xBF;
    55a2:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

000055a6 <.LVL65>:
    55a6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055aa <.L39>:
    return 0xDF;
    55aa:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

000055ae <.LVL67>:
    55ae:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055b2 <.L40>:
    return 0xEF;
    55b2:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

000055b6 <.LVL69>:
    55b6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055ba <.L41>:
    return 0xF7;
    55ba:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

000055be <.LVL71>:
    55be:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055c2 <.L42>:
    return 0xFB;
    55c2:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

000055c6 <.LVL73>:
    55c6:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055ca <.L43>:
    return 0xFD;
    55ca:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

000055ce <.LVL75>:
    55ce:	80 00 c2 54 	mova	#21698,	r0	;0x054c2

000055d2 <sd_lld_init>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
#endif

#if MSP430X_SERIAL_USE_USART1 == TRUE
  sdObjectInit(&SD1, NULL, notify1);
    55d2:	8e 00 9e 53 	mova	#21406,	r14	;0x0539e
    55d6:	4d 43       	clr.b	r13		;
    55d8:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    55dc:	b0 13 50 51 	calla	#20816		;0x05150

000055e0 <.LVL93>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    55e0:	10 01       	reta			;

000055e2 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    55e2:	5a 14       	pushm.a	#6,	r10	;20-bit words

000055e4 <.LCFI2>:

  if (config == NULL) {
    55e4:	9d 00 00 00 	cmpa	#0,	r13	;
    55e8:	1c 24       	jz	$+58     	;abs 0x5622

000055ea <.Loc.613.2>:
  if (&SD0 == sdp) {
    usart0_init(config);
  }
#endif
#if MSP430X_SERIAL_USE_USART1 == TRUE
  if (&SD1 == sdp) {
    55ea:	9c 01 38 13 	cmpa	#70456,	r12	;0x11338
    55ee:	68 20       	jnz	$+210    	;abs 0x56c0

000055f0 <.LBB42>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    55f0:	28 4d       	mov	@r13,	r8	;
    55f2:	19 4d 02 00 	mov	2(r13),	r9	;

000055f6 <.LBB44>:
  uint16_t n = freq / baud;
    55f6:	0e 48       	mov	r8,	r14	;
    55f8:	0f 49       	mov	r9,	r15	;
    55fa:	3c 40 00 24 	mov	#9216,	r12	;#0x2400

000055fe <.LVL97>:
    55fe:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4

00005602 <.LVL98>:
    5602:	b0 13 34 d1 	calla	#53556		;0x0d134

00005606 <.LVL99>:
    5606:	07 4c       	mov	r12,	r7	;
    5608:	0d 4c       	mov	r12,	r13	;

0000560a <.LVL100>:
  if (n > 16) {
    560a:	76 40 10 00 	mov.b	#16,	r6	;#0x0010
    560e:	06 97       	cmp	r7,	r6	;
    5610:	11 28       	jnc	$+36     	;abs 0x5634
    5612:	05 4c       	mov	r12,	r5	;
    5614:	80 00 38 56 	mova	#22072,	r0	;0x05638

00005618 <.L75>:
  return UCBRS(frac) << 8;
    5618:	4e 13       	calla	r14		;

0000561a <.LVL102>:
    561a:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    561e:	80 00 9a 56 	mova	#22170,	r0	;0x0569a

00005622 <.L72>:
  if (&SD1 == sdp) {
    5622:	9c 01 38 13 	cmpa	#70456,	r12	;0x11338
    5626:	4c 20       	jnz	$+154    	;abs 0x56c0

00005628 <.LBB51>:
  uint16_t n = freq / baud;
    5628:	3d 40 a0 01 	mov	#416,	r13	;#0x01a0
    562c:	07 4d       	mov	r13,	r7	;

0000562e <.LBE51>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    562e:	38 40 00 96 	mov	#-27136,r8	;#0x9600
    5632:	49 43       	clr.b	r9		;

00005634 <.L77>:
    return n >> 4;
    5634:	05 4d       	mov	r13,	r5	;
    5636:	5d 0f       	rrum	#4,	r13	;

00005638 <.L74>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    5638:	40 18 82 4d 	movx.w	r13,	&0x005e6;
    563c:	e6 05 

0000563e <.LBB53>:
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    563e:	8a 00 20 d3 	mova	#54048,	r10	;0x0d320
    5642:	0e 48       	mov	r8,	r14	;
    5644:	0f 49       	mov	r9,	r15	;
    5646:	0c 47       	mov	r7,	r12	;
    5648:	4d 43       	clr.b	r13		;
    564a:	4a 13       	calla	r10		;

0000564c <.LVL107>:
    564c:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    5650:	4f 43       	clr.b	r15		;
    5652:	36 40 00 24 	mov	#9216,	r6	;#0x2400
    5656:	77 40 f4 00 	mov.b	#244,	r7	;#0x00f4
    565a:	40 18 06 8c 	subx.w	r12,	r6	;
    565e:	40 18 07 7d 	subcx.w	r13,	r7	;
    5662:	0c 46       	mov	r6,	r12	;
    5664:	0d 47       	mov	r7,	r13	;
    5666:	4a 13       	calla	r10		;

00005668 <.LVL108>:
    5668:	0e 48       	mov	r8,	r14	;
    566a:	0f 49       	mov	r9,	r15	;
    566c:	b0 13 34 d1 	calla	#53556		;0x0d134

00005670 <.LVL109>:
    5670:	8e 00 a6 53 	mova	#21414,	r14	;0x053a6

00005674 <.Loc.194.2>:
  if (n > 16) {
    5674:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    5678:	07 95       	cmp	r5,	r7	;
    567a:	ce 2f       	jc	$-98     	;abs 0x5618

0000567c <.LVL110>:
    567c:	0d 45       	mov	r5,	r13	;
    567e:	3d 50 ef ff 	add	#-17,	r13	;#0xffef
    5682:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    5686:	35 50 f0 ff 	add	#-16,	r5	;#0xfff0
    568a:	05 8d       	sub	r13,	r5	;

0000568c <.Loc.198.2>:
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    568c:	4e 13       	calla	r14		;

0000568e <.LVL111>:
    568e:	43 18 05 55 	rpt #4 { rlax.w	r5		;
    5692:	15 d3       	bis	#1,	r5	;r3 As==01
    5694:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5698:	0c d5       	bis	r5,	r12	;

0000569a <.L76>:
  UCA1MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    569a:	40 18 82 4c 	movx.w	r12,	&0x005e8;
    569e:	e8 05 

000056a0 <.Loc.237.2>:
  UCA1STATW = 0;
    56a0:	40 18 c2 43 	movx.b	#0,	&0x005ea;r3 As==00
    56a4:	ea 05 

000056a6 <.Loc.238.2>:
  UCA1ABCTL = 0;
    56a6:	40 18 c2 43 	movx.b	#0,	&0x005f0;r3 As==00
    56aa:	f0 05 

000056ac <.Loc.239.2>:
  UCA1IRCTL = 0;
    56ac:	40 18 82 43 	movx.w	#0,	&0x005f2;r3 As==00
    56b0:	f2 05 

000056b2 <.Loc.240.2>:
  UCA1CTLW0 = (MSP430X_USART1_PARITY << 14) | (MSP430X_USART1_ORDER << 13) |
    56b2:	40 18 b2 40 	movx.w	#128,	&0x005e0;0x00080
    56b6:	80 00 e0 05 

000056ba <.Loc.243.2>:
  UCA1IE = UCRXIE;
    56ba:	40 18 92 43 	movx.w	#1,	&0x005fa;r3 As==01
    56be:	fa 05 

000056c0 <.L71>:
#if MSP430X_SERIAL_USE_USART3 == TRUE
  if (&SD3 == sdp) {
    usart3_init(config);
  }
#endif
}
    56c0:	55 16       	popm.a	#6,	r10	;20-bit words
    56c2:	10 01       	reta			;

000056c4 <sd_lld_stop>:
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver * sdp) {

  if (sdp->state == SD_READY) {
    56c4:	ec 93 10 00 	cmp.b	#2,	16(r12)	;r3 As==10, 0x0010
    56c8:	06 20       	jnz	$+14     	;abs 0x56d6

000056ca <.Loc.647.2>:
    if (&SD0 == sdp) {
      UCA0CTLW0 = UCSWRST;
    }
#endif
#if MSP430X_SERIAL_USE_USART1 == TRUE
    if (&SD1 == sdp) {
    56ca:	9c 01 38 13 	cmpa	#70456,	r12	;0x11338
    56ce:	03 20       	jnz	$+8      	;abs 0x56d6

000056d0 <.Loc.648.2>:
      UCA1CTLW0 = UCSWRST;
    56d0:	40 18 92 43 	movx.w	#1,	&0x005e0;r3 As==01
    56d4:	e0 05 

000056d6 <.L80>:
    if (&SD3 == sdp) {
      UCA3CTLW0 = UCSWRST;
    }
#endif
  }
}
    56d6:	10 01       	reta			;

000056d8 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    56d8:	40 18 a2 4c 	movx.w	@r12,	&0x00202;
    56dc:	02 02 

000056de <.Loc.310.1>:
  PADIR = config->porta.dir;
    56de:	40 18 92 4c 	movx.w	2(r12),	&0x00204;
    56e2:	02 00 04 02 

000056e6 <.Loc.311.1>:
  PAREN = config->porta.ren;
    56e6:	40 18 92 4c 	movx.w	4(r12),	&0x00206;
    56ea:	04 00 06 02 

000056ee <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    56ee:	40 18 92 4c 	movx.w	6(r12),	&0x0020a;
    56f2:	06 00 0a 02 

000056f6 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    56f6:	40 18 92 4c 	movx.w	8(r12),	&0x0020c;
    56fa:	08 00 0c 02 

000056fe <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    56fe:	40 18 92 4c 	movx.w	10(r12),&0x00222;0x0000a
    5702:	0a 00 22 02 

00005706 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    5706:	40 18 92 4c 	movx.w	12(r12),&0x00224;0x0000c
    570a:	0c 00 24 02 

0000570e <.Loc.317.1>:
  PBREN = config->portb.ren;
    570e:	40 18 92 4c 	movx.w	14(r12),&0x00226;0x0000e
    5712:	0e 00 26 02 

00005716 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    5716:	40 18 92 4c 	movx.w	16(r12),&0x0022a;0x00010
    571a:	10 00 2a 02 

0000571e <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    571e:	40 18 92 4c 	movx.w	18(r12),&0x0022c;0x00012
    5722:	12 00 2c 02 

00005726 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    5726:	40 18 92 4c 	movx.w	20(r12),&0x00322;0x00014
    572a:	14 00 22 03 

0000572e <.Loc.350.1>:
  PJDIR = config->portj.dir;
    572e:	40 18 92 4c 	movx.w	22(r12),&0x00324;0x00016
    5732:	16 00 24 03 

00005736 <.Loc.351.1>:
  PJREN = config->portj.ren;
    5736:	40 18 92 4c 	movx.w	24(r12),&0x00326;0x00018
    573a:	18 00 26 03 

0000573e <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    573e:	40 18 92 4c 	movx.w	26(r12),&0x0032a;0x0001a
    5742:	1a 00 2a 03 

00005746 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    5746:	40 18 92 4c 	movx.w	28(r12),&0x0032c;0x0001c
    574a:	1c 00 2c 03 

0000574e <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    574e:	40 18 92 c3 	bicx.w	#1,	&0x00130;r3 As==01
    5752:	30 01 

00005754 <.Loc.356.1>:
}
    5754:	10 01       	reta			;

00005756 <_pal_lld_setgroupmode>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    5756:	2e 92       	cmp	#4,	r14	;r2 As==10
    5758:	4e 24       	jz	$+158    	;abs 0x57f6
    575a:	6f 42       	mov.b	#4,	r15	;r2 As==10
    575c:	0f 9e       	cmp	r14,	r15	;
    575e:	0a 28       	jnc	$+22     	;abs 0x5774
    5760:	1e 93       	cmp	#1,	r14	;r3 As==01
    5762:	3f 24       	jz	$+128    	;abs 0x57e2
    5764:	0e 93       	cmp	#0,	r14	;r3 As==00
    5766:	2d 24       	jz	$+92     	;abs 0x57c2
    5768:	2e 93       	cmp	#2,	r14	;r3 As==10
    576a:	2b 24       	jz	$+88     	;abs 0x57c2
    576c:	3e 90 03 00 	cmp	#3,	r14	;
    5770:	38 24       	jz	$+114    	;abs 0x57e2

00005772 <.L38>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    5772:	10 01       	reta			;

00005774 <.L41>:
  switch (mode) {
    5774:	3e 92       	cmp	#8,	r14	;r2 As==11
    5776:	4f 24       	jz	$+160    	;abs 0x5816
    5778:	7f 42       	mov.b	#8,	r15	;r2 As==11
    577a:	0f 9e       	cmp	r14,	r15	;
    577c:	12 28       	jnc	$+38     	;abs 0x57a2
    577e:	3e 90 06 00 	cmp	#6,	r14	;
    5782:	f7 23       	jnz	$-16     	;abs 0x5772

00005784 <.Loc.410.1>:
      port->dir |= mask;
    5784:	8c dd 04 00 	bis	r13,	4(r12)	;

00005788 <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    5788:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    578c:	03 24       	jz	$+8      	;abs 0x5794

0000578e <.Loc.411.1>:
    578e:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5792:	23 20       	jnz	$+72     	;abs 0x57da

00005794 <.L52>:
        port->sel0 &= ~mask;
    5794:	3d e3       	inv	r13		;

00005796 <.LVL28>:
    5796:	8c fd 0a 00 	and	r13,	10(r12)	; 0x000a

0000579a <.Loc.415.1>:
        port->sel1 &= ~mask;
    579a:	8c fd 0c 00 	and	r13,	12(r12)	; 0x000c
    579e:	80 00 72 57 	mova	#22386,	r0	;0x05772

000057a2 <.L45>:
  switch (mode) {
    57a2:	3e 90 09 00 	cmp	#9,	r14	;
    57a6:	43 24       	jz	$+136    	;abs 0x582e
    57a8:	3e 90 0a 00 	cmp	#10,	r14	;#0x000a
    57ac:	e2 23       	jnz	$-58     	;abs 0x5772

000057ae <.Loc.435.1>:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    57ae:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    57b2:	03 20       	jnz	$+8      	;abs 0x57ba

000057b4 <.Loc.435.1>:
    57b4:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    57b8:	10 24       	jz	$+34     	;abs 0x57da

000057ba <.L55>:
        port->sel0 |= mask;
    57ba:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a
    57be:	80 00 3e 58 	mova	#22590,	r0	;0x0583e

000057c2 <.L43>:
      port->dir &= ~mask;
    57c2:	0e 4d       	mov	r13,	r14	;

000057c4 <.LVL30>:
    57c4:	3e e3       	inv	r14		;
    57c6:	8c fe 04 00 	and	r14,	4(r12)	;

000057ca <.Loc.378.1>:
      port->ren &= ~mask;
    57ca:	8c fe 08 00 	and	r14,	8(r12)	;

000057ce <.L105>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    57ce:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    57d2:	1b 24       	jz	$+56     	;abs 0x580a

000057d4 <.Loc.402.1>:
    57d4:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    57d8:	18 24       	jz	$+50     	;abs 0x580a

000057da <.L99>:
        port->selc = mask;
    57da:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016
    57de:	80 00 72 57 	mova	#22386,	r0	;0x05772

000057e2 <.L42>:
      port->dir &= ~mask;
    57e2:	0e 4d       	mov	r13,	r14	;

000057e4 <.LVL32>:
    57e4:	3e e3       	inv	r14		;
    57e6:	8c fe 04 00 	and	r14,	4(r12)	;

000057ea <.Loc.389.1>:
      port->ren |= mask;
    57ea:	8c dd 08 00 	bis	r13,	8(r12)	;

000057ee <.Loc.390.1>:
      port->out |= mask;
    57ee:	8c dd 02 00 	bis	r13,	2(r12)	;
    57f2:	80 00 ce 57 	mova	#22478,	r0	;0x057ce

000057f6 <.L40>:
      port->dir &= ~mask;
    57f6:	0e 4d       	mov	r13,	r14	;

000057f8 <.LVL34>:
    57f8:	3e e3       	inv	r14		;
    57fa:	8c fe 04 00 	and	r14,	4(r12)	;

000057fe <.Loc.400.1>:
      port->ren |= mask;
    57fe:	8c dd 08 00 	bis	r13,	8(r12)	;

00005802 <.Loc.401.1>:
      port->out &= ~mask;
    5802:	8c fe 02 00 	and	r14,	2(r12)	;
    5806:	80 00 ce 57 	mova	#22478,	r0	;0x057ce

0000580a <.L51>:
        port->sel0 &= ~mask;
    580a:	8c fe 0a 00 	and	r14,	10(r12)	; 0x000a

0000580e <.Loc.406.1>:
        port->sel1 &= ~mask;
    580e:	8c fe 0c 00 	and	r14,	12(r12)	; 0x000c
    5812:	80 00 72 57 	mova	#22386,	r0	;0x05772

00005816 <.L44>:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    5816:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    581a:	03 20       	jnz	$+8      	;abs 0x5822

0000581c <.Loc.419.1>:
    581c:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5820:	dc 23       	jnz	$-70     	;abs 0x57da

00005822 <.L53>:
        port->sel0 |= mask;
    5822:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a

00005826 <.Loc.423.1>:
        port->sel1 &= ~mask;
    5826:	8c cd 0c 00 	bic	r13,	12(r12)	; 0x000c
    582a:	80 00 72 57 	mova	#22386,	r0	;0x05772

0000582e <.L47>:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    582e:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    5832:	03 24       	jz	$+8      	;abs 0x583a

00005834 <.Loc.427.1>:
    5834:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5838:	d0 27       	jz	$-94     	;abs 0x57da

0000583a <.L54>:
        port->sel0 &= ~mask;
    583a:	8c cd 0a 00 	bic	r13,	10(r12)	; 0x000a

0000583e <.L98>:
        port->sel1 |= mask;
    583e:	8c dd 0c 00 	bis	r13,	12(r12)	; 0x000c

00005842 <.Loc.443.1>:
}
    5842:	80 00 72 57 	mova	#22386,	r0	;0x05772

00005846 <_pal_lld_enablepadevent>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    5846:	4a 14       	pushm.a	#5,	r10	;20-bit words

00005848 <.LCFI8>:
    5848:	b1 00 04 00 	suba	#4,	r1	;

0000584c <.LCFI9>:
    584c:	ca 0c       	mova	r12,	r10	;
    584e:	49 4d       	mov.b	r13,	r9	;
    5850:	47 4e       	mov.b	r14,	r7	;
    5852:	c6 0f       	mova	r15,	r6	;

00005854 <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5854:	00 18 4d 4c 	movx.a	r12,	r13	;
    5858:	0c 4c       	mov	r12,	r12	;
    585a:	0f 18 4d 11 	rpt #16 { rrax.a	r13		;

0000585e <.LVL37>:
    585e:	b0 13 10 d2 	calla	#53776		;0x0d210

00005862 <.LVL38>:
    5862:	0d 12       	push	r13		;
    5864:	0c 12       	push	r12		;
    5866:	0c 16       	popm.a	#1,	r12	;20-bit words
    5868:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    586c:	7d 40 07 00 	mov.b	#7,	r13	;
    5870:	4d 99       	cmp.b	r9,	r13	;
    5872:	41 28       	jnc	$+132    	;abs 0x58f6
    5874:	5d 43       	mov.b	#1,	r13	;r3 As==01

00005876 <.L108>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    5876:	08 49       	mov	r9,	r8	;
    5878:	78 f0 07 00 	and.b	#7,	r8	;
    587c:	48 0e       	rlam.a	#4,	r8	;
    587e:	48 0d       	rram.a	#4,	r8	;

00005880 <.Loc.448.1>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5880:	4d 5c       	add.b	r12,	r13	;

00005882 <.LVL40>:
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    5882:	4c 4d       	mov.b	r13,	r12	;
    5884:	3c 53       	add	#-1,	r12	;r3 As==11
    5886:	4c 0e       	rlam.a	#4,	r12	;
    5888:	4c 0d       	rram.a	#4,	r12	;
    588a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    588c:	40 18 3c 41 	popx.w	r12		;
    5890:	40 18 3d 41 	popx.w	r13		;
    5894:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    5898:	0d 12       	push	r13		;
    589a:	0c 12       	push	r12		;
    589c:	0c 16       	popm.a	#1,	r12	;20-bit words
    589e:	e8 0c       	adda	r12,	r8	;
    58a0:	08 14       	pushm.a	#1,	r8	;20-bit words
    58a2:	40 18 3c 41 	popx.w	r12		;
    58a6:	40 18 3d 41 	popx.w	r13		;
    58aa:	0e 4c       	mov	r12,	r14	;
    58ac:	0f 4d       	mov	r13,	r15	;
    58ae:	0e 5e       	rla	r14		;
    58b0:	0f 6f       	rlc	r15		;
    58b2:	0e 5e       	rla	r14		;
    58b4:	0f 6f       	rlc	r15		;
    58b6:	81 4e 00 00 	mov	r14,	0(r1)	;
    58ba:	81 4f 02 00 	mov	r15,	2(r1)	;
    58be:	0c 01       	mova	@r1,	r12	;
    58c0:	01 18 cc 46 	movx.a	r6,	70598(r12); 0x113c6
    58c4:	c6 13 

000058c6 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    58c6:	57 93       	cmp.b	#1,	r7	;r3 As==01
    58c8:	19 20       	jnz	$+52     	;abs 0x58fc

000058ca <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    58ca:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    58ce:	5c 43       	mov.b	#1,	r12	;r3 As==01
    58d0:	0d 49       	mov	r9,	r13	;
    58d2:	b0 13 6a d1 	calla	#53610		;0x0d16a
    58d6:	08 cc       	bic	r12,	r8	;
    58d8:	8a 48 18 00 	mov	r8,	24(r10)	; 0x0018

000058dc <.L110>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    58dc:	18 4a 1c 00 	mov	28(r10),r8	;0x0001c
    58e0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    58e2:	0d 49       	mov	r9,	r13	;
    58e4:	b0 13 6a d1 	calla	#53610		;0x0d16a
    58e8:	08 cc       	bic	r12,	r8	;
    58ea:	8a 48 1c 00 	mov	r8,	28(r10)	; 0x001c

000058ee <.Loc.464.1>:
    port->ie |= (1 << pad);
    58ee:	8a dc 1a 00 	bis	r12,	26(r10)	; 0x001a

000058f2 <.Loc.466.1>:
  }
}
    58f2:	80 00 2c 59 	mova	#22828,	r0	;0x0592c

000058f6 <.L113>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    58f6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    58f8:	80 00 76 58 	mova	#22646,	r0	;0x05876

000058fc <.L109>:
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    58fc:	67 93       	cmp.b	#2,	r7	;r3 As==10
    58fe:	0b 20       	jnz	$+24     	;abs 0x5916

00005900 <.Loc.456.1>:
    port->ies |= (1 << pad);
    5900:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    5904:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5906:	0d 49       	mov	r9,	r13	;
    5908:	b0 13 6a d1 	calla	#53610		;0x0d16a
    590c:	0c d8       	bis	r8,	r12	;
    590e:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018
    5912:	80 00 dc 58 	mova	#22748,	r0	;0x058dc

00005916 <.L111>:
  if (mode == PAL_EVENT_MODE_DISABLED) {
    5916:	07 93       	cmp	#0,	r7	;r3 As==00
    5918:	e1 23       	jnz	$-60     	;abs 0x58dc

0000591a <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    591a:	18 4a 1a 00 	mov	26(r10),r8	;0x0001a
    591e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5920:	0d 49       	mov	r9,	r13	;
    5922:	b0 13 6a d1 	calla	#53610		;0x0d16a
    5926:	08 cc       	bic	r12,	r8	;
    5928:	8a 48 1a 00 	mov	r8,	26(r10)	; 0x001a

0000592c <.L107>:
}
    592c:	a1 00 04 00 	adda	#4,	r1	;
    5930:	46 16       	popm.a	#5,	r10	;20-bit words
    5932:	10 01       	reta			;

00005934 <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    5934:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005936 <.LCFI10>:
    5936:	ca 0c       	mova	r12,	r10	;

00005938 <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    5938:	19 4c 1a 00 	mov	26(r12),r9	;0x0001a
    593c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000593e <.LVL47>:
    593e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    5942:	b0 13 6a d1 	calla	#53610		;0x0d16a

00005946 <.LVL48>:
    5946:	09 cc       	bic	r12,	r9	;
    5948:	8a 49 1a 00 	mov	r9,	26(r10)	; 0x001a

0000594c <.Loc.471.1>:
}
    594c:	19 16       	popm.a	#2,	r10	;20-bit words
    594e:	10 01       	reta			;

00005950 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    5950:	3a 14       	pushm.a	#4,	r10	;20-bit words

00005952 <.LCFI0>:
    5952:	49 4c       	mov.b	r12,	r9	;
    5954:	48 4d       	mov.b	r13,	r8	;

00005956 <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    5956:	0a 49       	mov	r9,	r10	;
    5958:	12 c3       	clrc			
    595a:	0a 10       	rrc	r10		;
    595c:	40 18 0a 4a 	movx.w	r10,	r10	;
    5960:	ea 0a       	adda	r10,	r10	;
    5962:	aa 00 00 05 	adda	#1280,	r10	;0x00500

00005966 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    5966:	59 f3       	and.b	#1,	r9	;r3 As==01
    5968:	42 18 09 59 	rpt #3 { rlax.w	r9		;
    596c:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00005970 <.LVL2>:
    5970:	0d 49       	mov	r9,	r13	;

00005972 <.LVL3>:
    5972:	b0 13 72 d2 	calla	#53874		;0x0d272
    5976:	07 4c       	mov	r12,	r7	;
    5978:	27 fa       	and	@r10,	r7	;

0000597a <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    597a:	0c 48       	mov	r8,	r12	;
    597c:	0d 49       	mov	r9,	r13	;
    597e:	b0 13 6a d1 	calla	#53610		;0x0d16a
    5982:	07 dc       	bis	r12,	r7	;
    5984:	8a 47 00 00 	mov	r7,	0(r10)	;

00005988 <.Loc.65.1>:
}
    5988:	37 16       	popm.a	#4,	r10	;20-bit words
    598a:	10 01       	reta			;

0000598c <dmaInit>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    598c:	41 18 82 43 	movx.w	#0,	&0x11446;r3 As==00
    5990:	46 14 

00005992 <.LBE15>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    5992:	10 01       	reta			;

00005994 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5994:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005996 <.LCFI2>:
    5996:	ca 0c       	mova	r12,	r10	;

00005998 <.LVL19>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    5998:	40 18 19 42 	movx.w	&0x00510,r9	;
    599c:	10 05 
    599e:	79 f0 10 00 	and.b	#16,	r9	;#0x0010
    59a2:	09 93       	cmp	#0,	r9	;r3 As==00
    59a4:	11 24       	jz	$+36     	;abs 0x59c8

000059a6 <.LVL20>:
    59a6:	8c 00 20 05 	mova	#1312,	r12	;0x00520

000059aa <.LVL21>:
    59aa:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    59ae:	10 00 00 00 
    59b2:	09 24       	jz	$+20     	;abs 0x59c6

000059b4 <.LVL22>:
    59b4:	40 18 bc b0 	bitx.w	#16,	16(r12)	;0x00010, 0x00010
    59b8:	10 00 10 00 
    59bc:	1f 24       	jz	$+64     	;abs 0x59fc

000059be <.Loc.198.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    59be:	8c 0f ff ff 	mova	#-1,	r12	;0xffffffff

000059c2 <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    59c2:	28 16       	popm.a	#3,	r10	;20-bit words
    59c4:	10 01       	reta			;

000059c6 <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    59c6:	59 43       	mov.b	#1,	r9	;r3 As==01

000059c8 <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    59c8:	48 49       	mov.b	r9,	r8	;
    59ca:	4d 43       	clr.b	r13		;
    59cc:	4c 48       	mov.b	r8,	r12	;
    59ce:	b0 13 50 59 	calla	#22864		;0x05950

000059d2 <.LVL26>:
  dma_regs[i].sz  = 0;
    59d2:	0c 49       	mov	r9,	r12	;
    59d4:	0d 43       	clr	r13		;
    59d6:	b0 13 9c d1 	calla	#53660		;0x0d19c
    59da:	0d 12       	push	r13		;
    59dc:	0c 12       	push	r12		;
    59de:	0c 16       	popm.a	#1,	r12	;20-bit words
    59e0:	ac 00 10 05 	adda	#1296,	r12	;0x00510
    59e4:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000059e8 <.Loc.204.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    59e8:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    59ec:	00 00 

000059ee <.Loc.206.1>:
  channel->registers = dma_regs + i;
    59ee:	7a 0c 00 00 	mova	r12,	0(r10)	;

000059f2 <.Loc.207.1>:
  channel->index     = i;
    59f2:	ca 48 04 00 	mov.b	r8,	4(r10)	;

000059f6 <.Loc.209.1>:
  return MSG_OK;
    59f6:	4c 43       	clr.b	r12		;
    59f8:	80 00 c2 59 	mova	#22978,	r0	;0x059c2

000059fc <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    59fc:	69 43       	mov.b	#2,	r9	;r3 As==10
    59fe:	80 00 c8 59 	mova	#22984,	r0	;0x059c8

00005a02 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5a02:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005a04 <.LCFI5>:
    5a04:	08 14       	pushm.a	#1,	r8	;20-bit words

00005a06 <.LCFI6>:
    5a06:	c8 0c       	mova	r12,	r8	;
    5a08:	ca 0d       	mova	r13,	r10	;

00005a0a <.Loc.273.1>:


  channel->registers->ctl &= (~DMAEN);
    5a0a:	0c 0c       	mova	@r12,	r12	;

00005a0c <.LVL41>:
    5a0c:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5a10:	00 00 

00005a12 <.Loc.274.1>:
  dma_trigger_set(channel->index, request->trigger);
    5a12:	5d 4d 10 00 	mov.b	16(r13),r13	;0x00010

00005a16 <.LVL42>:
    5a16:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5a1a:	b0 13 50 59 	calla	#22864		;0x05950

00005a1e <.LVL43>:
  callbacks[channel->index] = request->callback;
    5a1e:	5c 48 04 00 	mov.b	4(r8),	r12	;
    5a22:	0d 43       	clr	r13		;
    5a24:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    5a28:	0d 12       	push	r13		;
    5a2a:	0c 12       	push	r12		;
    5a2c:	0c 16       	popm.a	#1,	r12	;20-bit words
    5a2e:	ac 01 48 14 	adda	#70728,	r12	;0x11448
    5a32:	9c 4a 12 00 	mov	18(r10),0(r12)	;0x00012
    5a36:	00 00 
    5a38:	9c 4a 14 00 	mov	20(r10),2(r12)	;0x00014
    5a3c:	02 00 
    5a3e:	9c 4a 16 00 	mov	22(r10),4(r12)	;0x00016
    5a42:	04 00 
    5a44:	9c 4a 18 00 	mov	24(r10),6(r12)	;0x00018
    5a48:	06 00 

00005a4a <.Loc.278.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
    5a4a:	0c 08       	mova	@r8,	r12	;
    5a4c:	00 18 ec 4a 	movx.a	@r10,	2(r12)	;
    5a50:	02 00 

00005a52 <.Loc.279.1>:
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
    5a52:	0c 08       	mova	@r8,	r12	;
    5a54:	00 18 dc 4a 	movx.a	4(r10),	6(r12)	;
    5a58:	04 00 06 00 

00005a5c <.Loc.284.1>:
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
#endif
  channel->registers->sz  = request->size;
    5a5c:	0e 08       	mova	@r8,	r14	;
    5a5e:	9e 4a 08 00 	mov	8(r10),	10(r14)	; 0x000a
    5a62:	0a 00 

00005a64 <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5a64:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    5a68:	1c da 0a 00 	bis	10(r10),r12	;0x0000a

00005a6c <.Loc.286.1>:
                            request->transfer_mode | DMAEN |
    5a6c:	3c d0 15 00 	bis	#21,	r12	;#0x0015

00005a70 <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5a70:	1c da 0e 00 	bis	14(r10),r12	;0x0000e
    5a74:	8e 4c 00 00 	mov	r12,	0(r14)	;

00005a78 <.Loc.288.1>:
                            DMAREQ;
}
    5a78:	08 16       	popm.a	#1,	r8	;20-bit words
    5a7a:	0a 16       	popm.a	#1,	r10	;20-bit words
    5a7c:	10 01       	reta			;

00005a7e <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5a7e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005a80 <.LCFI7>:
    5a80:	ca 0c       	mova	r12,	r10	;

00005a82 <.LBB33>:
  return chSysGetStatusAndLockX();
    5a82:	b0 13 fa 45 	calla	#17914		;0x045fa

00005a86 <.LVL48>:
    5a86:	09 4c       	mov	r12,	r9	;

00005a88 <.LBE33>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    5a88:	9a 00 00 00 	cmpa	#0,	r10	;
    5a8c:	10 24       	jz	$+34     	;abs 0x5aae

00005a8e <.Loc.305.1>:
    5a8e:	0c 0a       	mova	@r10,	r12	;
    5a90:	9c 00 00 00 	cmpa	#0,	r12	;
    5a94:	0c 24       	jz	$+26     	;abs 0x5aae

00005a96 <.Loc.305.1>:
    5a96:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5a9a:	10 00 00 00 
    5a9e:	07 24       	jz	$+16     	;abs 0x5aae

00005aa0 <.Loc.308.1>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    5aa0:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00005aa4 <.Loc.311.1>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    5aa4:	4d 43       	clr.b	r13		;
    5aa6:	8c 01 46 14 	mova	#70726,	r12	;0x11446
    5aaa:	b0 13 58 4a 	calla	#19032		;0x04a58

00005aae <.L32>:
  chSysRestoreStatusX(sts);
    5aae:	0c 49       	mov	r9,	r12	;
    5ab0:	b0 13 16 46 	calla	#17942		;0x04616

00005ab4 <.LBE35>:
  }
  osalSysRestoreStatusX(sts);
}
    5ab4:	19 16       	popm.a	#2,	r10	;20-bit words
    5ab6:	10 01       	reta			;

00005ab8 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    5ab8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005aba <.LCFI8>:
    5aba:	ca 0c       	mova	r12,	r10	;

00005abc <.Loc.329.1>:
  
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    5abc:	0c 0c       	mova	@r12,	r12	;

00005abe <.LVL52>:
    5abe:	40 18 bc b0 	bitx.w	#16,	0(r12)	;0x00010
    5ac2:	10 00 00 00 
    5ac6:	0e 24       	jz	$+30     	;abs 0x5ae4

00005ac8 <.Loc.334.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    5ac8:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    5acc:	00 00 

00005ace <.Loc.336.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    5ace:	4d 43       	clr.b	r13		;
    5ad0:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    5ad4:	b0 13 50 59 	calla	#22864		;0x05950

00005ad8 <.LVL53>:
  channel->registers->sz  = 0;
    5ad8:	0c 0a       	mova	@r10,	r12	;
    5ada:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00005ade <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    5ade:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    5ae2:	00 00 

00005ae4 <.L41>:
}
    5ae4:	0a 16       	popm.a	#1,	r10	;20-bit words
    5ae6:	10 01       	reta			;

00005ae8 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    5ae8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005aea <.LCFI0>:
    5aea:	08 14       	pushm.a	#1,	r8	;20-bit words

00005aec <.LCFI1>:
    5aec:	06 14       	pushm.a	#1,	r6	;20-bit words

00005aee <.LCFI2>:
    5aee:	04 14       	pushm.a	#1,	r4	;20-bit words

00005af0 <.LCFI3>:
    5af0:	ca 0c       	mova	r12,	r10	;

00005af2 <.Loc.106.1>:

  if (!dmaIsClaimed(&(spip->dmarx))) {
    5af2:	c8 0c       	mova	r12,	r8	;
    5af4:	a8 00 52 00 	adda	#82,	r8	;0x00052
    5af8:	98 00 00 00 	cmpa	#0,	r8	;
    5afc:	09 24       	jz	$+20     	;abs 0x5b10

00005afe <.Loc.106.1>:
    5afe:	3c 0c 52 00 	mova	82(r12),r12	;0x00052

00005b02 <.LVL1>:
    5b02:	9c 00 00 00 	cmpa	#0,	r12	;
    5b06:	04 24       	jz	$+10     	;abs 0x5b10

00005b08 <.Loc.106.1>:
    5b08:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5b0c:	00 00 
    5b0e:	03 20       	jnz	$+8      	;abs 0x5b16

00005b10 <.L2>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmarx));
    5b10:	cc 08       	mova	r8,	r12	;
    5b12:	b0 13 94 59 	calla	#22932		;0x05994

00005b16 <.L3>:
  }
  
  if (!dmaIsClaimed(&(spip->dmatx))) {
    5b16:	c6 0a       	mova	r10,	r6	;
    5b18:	a6 00 48 00 	adda	#72,	r6	;0x00048
    5b1c:	96 00 00 00 	cmpa	#0,	r6	;
    5b20:	09 24       	jz	$+20     	;abs 0x5b34

00005b22 <.Loc.111.1>:
    5b22:	3c 0a 48 00 	mova	72(r10),r12	;0x00048
    5b26:	9c 00 00 00 	cmpa	#0,	r12	;
    5b2a:	04 24       	jz	$+10     	;abs 0x5b34

00005b2c <.Loc.111.1>:
    5b2c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5b30:	00 00 
    5b32:	03 20       	jnz	$+8      	;abs 0x5b3a

00005b34 <.L4>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmatx));
    5b34:	cc 06       	mova	r6,	r12	;
    5b36:	b0 13 94 59 	calla	#22932		;0x05994

00005b3a <.L5>:
  }
  
  dmaTransferI(&(spip->dmarx), &(spip->rx_req));
    5b3a:	84 00 02 5a 	mova	#23042,	r4	;0x05a02
    5b3e:	cd 0a       	mova	r10,	r13	;
    5b40:	ad 00 2e 00 	adda	#46,	r13	;0x0002e
    5b44:	cc 08       	mova	r8,	r12	;
    5b46:	44 13       	calla	r4		;

00005b48 <.LVL4>:
  dmaTransferI(&(spip->dmatx), &(spip->tx_req));
    5b48:	cd 0a       	mova	r10,	r13	;
    5b4a:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5b4e:	cc 06       	mova	r6,	r12	;
    5b50:	44 13       	calla	r4		;

00005b52 <.LVL5>:

  *(spip->ifg) |= UCTXIFG;
    5b52:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5b56:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005b5a <.Loc.120.1>:
}
    5b5a:	04 16       	popm.a	#1,	r4	;20-bit words
    5b5c:	06 16       	popm.a	#1,	r6	;20-bit words
    5b5e:	08 16       	popm.a	#1,	r8	;20-bit words
    5b60:	0a 16       	popm.a	#1,	r10	;20-bit words
    5b62:	10 01       	reta			;

00005b64 <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    5b64:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005b66 <.LCFI4>:
    5b66:	08 14       	pushm.a	#1,	r8	;20-bit words

00005b68 <.LCFI5>:
    5b68:	ca 0c       	mova	r12,	r10	;

00005b6a <.LVL7>:
  SPIDriver * spip = (SPIDriver *)(arg);

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    5b6a:	3e 0c 10 00 	mova	16(r12),r14	;0x00010
    5b6e:	ae c3 00 00 	bic	#2,	0(r14)	;r3 As==10

00005b72 <.Loc.136.1>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    5b72:	3e 0c 02 00 	mova	2(r12),	r14	;
    5b76:	0e 0e       	mova	@r14,	r14	;
    5b78:	9e 00 00 00 	cmpa	#0,	r14	;
    5b7c:	06 24       	jz	$+14     	;abs 0x5b8a

00005b7e <.Loc.136.1>:
    5b7e:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    5b82:	4e 13       	calla	r14		;

00005b84 <.LVL8>:
    5b84:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    5b88:	02 20       	jnz	$+6      	;abs 0x5b8e

00005b8a <.L17>:
    5b8a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005b8e <.L18>:
  chThdResumeI(trp, msg);
    5b8e:	4d 43       	clr.b	r13		;
    5b90:	cc 0a       	mova	r10,	r12	;
    5b92:	ac 00 06 00 	adda	#6,	r12	;

00005b96 <.LVL10>:
    5b96:	b0 13 fa 46 	calla	#18170		;0x046fa

00005b9a <.LBE20>:
  
  if (spip->state == SPI_READY) {
    5b9a:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    5b9e:	0a 20       	jnz	$+22     	;abs 0x5bb4

00005ba0 <.LBB22>:
    dmaReleaseX(&(spip->dmarx));
    5ba0:	88 00 7e 5a 	mova	#23166,	r8	;0x05a7e
    5ba4:	cc 0a       	mova	r10,	r12	;
    5ba6:	ac 00 52 00 	adda	#82,	r12	;0x00052
    5baa:	48 13       	calla	r8		;

00005bac <.LVL13>:
    dmaReleaseX(&(spip->dmatx));
    5bac:	cc 0a       	mova	r10,	r12	;
    5bae:	ac 00 48 00 	adda	#72,	r12	;0x00048
    5bb2:	48 13       	calla	r8		;

00005bb4 <.L16>:
  }
}
    5bb4:	08 16       	popm.a	#1,	r8	;20-bit words
    5bb6:	0a 16       	popm.a	#1,	r10	;20-bit words
    5bb8:	10 01       	reta			;

00005bba <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
    5bba:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005bbc <.LCFI6>:

#if MSP430X_SPI_USE_SPIA0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA0);
    5bbc:	8a 01 62 14 	mova	#70754,	r10	;0x11462
    5bc0:	cc 0a       	mova	r10,	r12	;
    5bc2:	b0 13 98 52 	calla	#21144		;0x05298

00005bc6 <.LVL15>:
  SPIDA0.regs                     = (msp430x_spi_reg_t *)(&UCA0CTLW0);
    5bc6:	00 18 fa 40 	movx.a	#1472,	12(r10)	;0x005c0, 0x0000c
    5bca:	c0 05 0c 00 

00005bce <.Loc.162.1>:
  SPIDA0.ifg                      = (volatile uint16_t *)&UCA0IFG;
    5bce:	00 18 fa 40 	movx.a	#1500,	16(r10)	;0x005dc, 0x00010
    5bd2:	dc 05 10 00 

00005bd6 <.Loc.163.1>:
  SPIDA0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA0TXIFG);
    5bd6:	ba 40 0f 00 	mov	#15,	36(r10)	;#0x000f, 0x0024
    5bda:	24 00 

00005bdc <.Loc.164.1>:
  SPIDA0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA0RXIFG);
    5bdc:	ba 40 0e 00 	mov	#14,	62(r10)	;#0x000e, 0x003e
    5be0:	3e 00 

00005be2 <.Loc.165.1>:
  SPIDA0.tx_req.dest_addr         = &(SPIDA0.regs->txbuf);
    5be2:	00 18 fa 40 	movx.a	#1486,	24(r10)	;0x005ce, 0x00018
    5be6:	ce 05 18 00 

00005bea <.Loc.166.1>:
  SPIDA0.rx_req.source_addr       = &(SPIDA0.regs->rxbuf);
    5bea:	00 18 fa 40 	movx.a	#1484,	46(r10)	;0x005cc, 0x0002e
    5bee:	cc 05 2e 00 

00005bf2 <.Loc.167.1>:
  SPIDA0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5bf2:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    5bf6:	20 00 

00005bf8 <.Loc.168.1>:
  SPIDA0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5bf8:	ba 40 c0 00 	mov	#192,	58(r10)	;#0x00c0, 0x003a
    5bfc:	3a 00 

00005bfe <.Loc.169.1>:
  SPIDA0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    5bfe:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

00005c02 <.Loc.170.1>:
  SPIDA0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    5c02:	8a 43 3c 00 	mov	#0,	60(r10)	;r3 As==00, 0x003c

00005c06 <.Loc.171.1>:
  SPIDA0.tx_req.callback.callback = NULL;
    5c06:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    5c0a:	26 00 

00005c0c <.Loc.172.1>:
  SPIDA0.tx_req.callback.args     = NULL;
    5c0c:	00 18 ca 43 	movx.a	#0,	42(r10)	;r3 As==00, 0x0002a
    5c10:	2a 00 

00005c12 <.Loc.173.1>:
  SPIDA0.rx_req.callback.callback = spi_lld_end_of_transfer;
    5c12:	00 18 fa 40 	movx.a	#23396,	64(r10)	;0x05b64, 0x00040
    5c16:	64 5b 40 00 

00005c1a <.Loc.174.1>:
  SPIDA0.rx_req.callback.args     = &SPIDA0;
    5c1a:	7a 0a 44 00 	mova	r10,	68(r10)	; 0x00044

00005c1e <.Loc.312.1>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    5c1e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5c20:	10 01       	reta			;

00005c22 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    5c22:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005c24 <.LCFI7>:

  if (spip->config->ss_line) {
    5c24:	3c 0c 02 00 	mova	2(r12),	r12	;

00005c28 <.LVL19>:
    5c28:	3c 0c 04 00 	mova	4(r12),	r12	;
    5c2c:	9c 00 00 00 	cmpa	#0,	r12	;
    5c30:	18 24       	jz	$+50     	;abs 0x5c62

00005c32 <.Loc.432.1>:
    palClearLine(spip->config->ss_line);
    5c32:	ca 0c       	mova	r12,	r10	;
    5c34:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    5c38:	ff 0f 
    5c3a:	19 4a 02 00 	mov	2(r10),	r9	;
    5c3e:	0c 14       	pushm.a	#1,	r12	;20-bit words
    5c40:	40 18 3c 41 	popx.w	r12		;
    5c44:	40 18 3d 41 	popx.w	r13		;
    5c48:	b0 13 8a d2 	calla	#53898		;0x0d28a
    5c4c:	0d 12       	push	r13		;
    5c4e:	0c 12       	push	r12		;
    5c50:	0c 16       	popm.a	#1,	r12	;20-bit words
    5c52:	40 18 0d 4c 	movx.w	r12,	r13	;
    5c56:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5c58:	b0 13 6a d1 	calla	#53610		;0x0d16a
    5c5c:	09 cc       	bic	r12,	r9	;
    5c5e:	8a 49 02 00 	mov	r9,	2(r10)	;

00005c62 <.L26>:
  }
}
    5c62:	19 16       	popm.a	#2,	r10	;20-bit words
    5c64:	10 01       	reta			;

00005c66 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    5c66:	1a 14       	pushm.a	#2,	r10	;20-bit words

00005c68 <.LCFI8>:

  if (spip->config->ss_line) {
    5c68:	3c 0c 02 00 	mova	2(r12),	r12	;

00005c6c <.LVL23>:
    5c6c:	3c 0c 04 00 	mova	4(r12),	r12	;
    5c70:	9c 00 00 00 	cmpa	#0,	r12	;
    5c74:	18 24       	jz	$+50     	;abs 0x5ca6

00005c76 <.Loc.447.1>:
    palSetLine(spip->config->ss_line);
    5c76:	ca 0c       	mova	r12,	r10	;
    5c78:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    5c7c:	ff 0f 
    5c7e:	19 4a 02 00 	mov	2(r10),	r9	;
    5c82:	0c 14       	pushm.a	#1,	r12	;20-bit words
    5c84:	40 18 3c 41 	popx.w	r12		;
    5c88:	40 18 3d 41 	popx.w	r13		;
    5c8c:	b0 13 8a d2 	calla	#53898		;0x0d28a
    5c90:	0d 12       	push	r13		;
    5c92:	0c 12       	push	r12		;
    5c94:	0c 16       	popm.a	#1,	r12	;20-bit words
    5c96:	40 18 0d 4c 	movx.w	r12,	r13	;
    5c9a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5c9c:	b0 13 6a d1 	calla	#53610		;0x0d16a
    5ca0:	0c d9       	bis	r9,	r12	;
    5ca2:	8a 4c 02 00 	mov	r12,	2(r10)	;

00005ca6 <.L31>:
  }
}
    5ca6:	19 16       	popm.a	#2,	r10	;20-bit words
    5ca8:	10 01       	reta			;

00005caa <spi_lld_start>:
void spi_lld_start(SPIDriver * spip) {
    5caa:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005cac <.LCFI9>:
    5cac:	08 14       	pushm.a	#1,	r8	;20-bit words

00005cae <.LCFI10>:
    5cae:	ca 0c       	mova	r12,	r10	;

00005cb0 <.LVL27>:
  if (spip == &SPIDA0) {
    5cb0:	9c 01 62 14 	cmpa	#70754,	r12	;0x11462
    5cb4:	3a 20       	jnz	$+118    	;abs 0x5d2a

00005cb6 <.Loc.342.1>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    5cb6:	3c 0c 02 00 	mova	2(r12),	r12	;

00005cba <.LVL28>:
    5cba:	1e 4c 08 00 	mov	8(r12),	r14	;
    5cbe:	1f 4c 0a 00 	mov	10(r12),r15	;0x0000a
    5cc2:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5cc6:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5cca:	b0 13 34 d1 	calla	#53556		;0x0d134

00005cce <.LVL29>:
    ssel = MSP430X_SPIA0_UCSSEL;
    5cce:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080

00005cd2 <.L37>:
  spip->regs->ctlw0 = UCSWRST;
    5cd2:	3e 0a 0c 00 	mova	12(r10),r14	;0x0000c

00005cd6 <.Loc.390.1>:
  spip->regs->brw   = brw;
    5cd6:	8e 4c 06 00 	mov	r12,	6(r14)	;

00005cda <.Loc.392.1>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    5cda:	38 0a 02 00 	mova	2(r10),	r8	;
    5cde:	5c 48 0e 00 	mov.b	14(r8),	r12	;0x0000e

00005ce2 <.LVL31>:
    5ce2:	6c e3       	xor.b	#2,	r12	;r3 As==10
    5ce4:	0f 4c       	mov	r12,	r15	;
    5ce6:	4d 18 0f 5f 	rpt #14 { rlax.w	r15		;
    5cea:	5c 48 0c 00 	mov.b	12(r8),	r12	;0x0000c
    5cee:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;

00005cf2 <.Loc.393.1>:
      (spip->config->data_size << 12) | (UCMST) |
    5cf2:	5b 48 0d 00 	mov.b	13(r8),	r11	;0x0000d
    5cf6:	4b 18 0b 5b 	rpt #12 { rlax.w	r11		;
    5cfa:	0c db       	bis	r11,	r12	;

00005cfc <.Loc.394.1>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    5cfc:	00 18 c8 93 	cmpx.a	#0,	4(r8)	;r3 As==00
    5d00:	04 00 
    5d02:	17 20       	jnz	$+48     	;abs 0x5d32
    5d04:	38 40 00 04 	mov	#1024,	r8	;#0x0400

00005d08 <.L38>:
    5d08:	3c d0 02 09 	bis	#2306,	r12	;#0x0902
    5d0c:	0c df       	bis	r15,	r12	;
    5d0e:	0c dd       	bis	r13,	r12	;
    5d10:	0c d8       	bis	r8,	r12	;
    5d12:	8e 4c 00 00 	mov	r12,	0(r14)	;

00005d16 <.Loc.395.1>:
  *(spip->ifg) = 0;
    5d16:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5d1a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005d1e <.LVL32>:
  spi_lld_unselect(spip);
    5d1e:	cc 0a       	mova	r10,	r12	;
    5d20:	b0 13 66 5c 	calla	#23654		;0x05c66

00005d24 <.LVL33>:
}
    5d24:	08 16       	popm.a	#1,	r8	;20-bit words
    5d26:	0a 16       	popm.a	#1,	r10	;20-bit words
    5d28:	10 01       	reta			;

00005d2a <.L39>:
  uint8_t ssel = 0;
    5d2a:	4d 43       	clr.b	r13		;

00005d2c <.Loc.338.1>:
  uint16_t brw = 0;
    5d2c:	0c 4d       	mov	r13,	r12	;
    5d2e:	80 00 d2 5c 	mova	#23762,	r0	;0x05cd2

00005d32 <.L40>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    5d32:	48 43       	clr.b	r8		;
    5d34:	80 00 08 5d 	mova	#23816,	r0	;0x05d08

00005d38 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {
    5d38:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005d3a <.LCFI12>:
    5d3a:	ca 0c       	mova	r12,	r10	;

00005d3c <.Loc.521.1>:

  spip->tx_req.source_addr = txbuf;
    5d3c:	7c 0e 14 00 	mova	r14,	20(r12)	; 0x00014

00005d40 <.Loc.522.1>:
  spip->tx_req.size        = n;
    5d40:	8c 4d 1c 00 	mov	r13,	28(r12)	; 0x001c

00005d44 <.Loc.523.1>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    5d44:	bc 40 00 03 	mov	#768,	30(r12)	;#0x0300, 0x001e
    5d48:	1e 00 

00005d4a <.Loc.525.1>:

  spip->rx_req.dest_addr = &dummyrx;
    5d4a:	80 18 fc 40 	movx.a	#70752,	50(r12)	;0x11460, 0x00032
    5d4e:	60 14 32 00 

00005d52 <.Loc.526.1>:
  spip->rx_req.size      = n;
    5d52:	8c 4d 36 00 	mov	r13,	54(r12)	; 0x0036

00005d56 <.Loc.527.1>:
  spip->rx_req.addr_mode = 0;
    5d56:	8c 43 38 00 	mov	#0,	56(r12)	;r3 As==00, 0x0038

00005d5a <.Loc.529.1>:

  init_transfer(spip);
    5d5a:	b0 13 e8 5a 	calla	#23272		;0x05ae8

00005d5e <.LVL41>:
}
    5d5e:	0a 16       	popm.a	#1,	r10	;20-bit words
    5d60:	10 01       	reta			;

00005d62 <spi_lld_polled_exchange>:
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {

  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spip->regs->txbuf = frame;
    5d62:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    5d66:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    5d6a:	8e 4d 0e 00 	mov	r13,	14(r14)	; 0x000e

00005d6e <.Loc.574.1>:
  while (!(*(spip->ifg) & UCRXIFG))
    5d6e:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005d72 <.L46>:
    5d72:	40 18 9c b3 	bitx.w	#1,	0(r12)	;r3 As==01
    5d76:	00 00 
    5d78:	fc 27       	jz	$-6      	;abs 0x5d72

00005d7a <.Loc.576.1>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    5d7a:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    5d7e:	00 00 

00005d80 <.Loc.578.1>:
  return spip->regs->rxbuf;
}
    5d80:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    5d84:	10 01       	reta			;

00005d86 <tx_complete>:

void tx_complete(void * args) {
  I2CDriver * i2cp = (I2CDriver *)(args);
  
  /* Enable TX IE to wake the thread or call the callback */
  i2cp->regs->ie |= UCTXIE0;
    5d86:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

00005d8a <.LVL2>:
    5d8a:	ac d3 2a 00 	bis	#2,	42(r12)	;r3 As==10, 0x002a

00005d8e <.Loc.82.1>:
}
    5d8e:	10 01       	reta			;

00005d90 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
    5d90:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005d92 <.LCFI0>:

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    5d92:	8a 01 be 14 	mova	#70846,	r10	;0x114be
    5d96:	cc 0a       	mova	r10,	r12	;
    5d98:	b0 13 9a 50 	calla	#20634		;0x0509a

00005d9c <.LVL6>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    5d9c:	00 18 fa 40 	movx.a	#1600,	16(r10)	;0x00640, 0x00010
    5da0:	40 06 10 00 

00005da4 <.Loc.424.1>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    5da4:	ba 40 c0 00 	mov	#192,	32(r10)	;#0x00c0, 0x0020
    5da8:	20 00 

00005daa <.Loc.425.1>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    5daa:	8a 43 22 00 	mov	#0,	34(r10)	;r3 As==00, 0x0022

00005dae <.Loc.426.1>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    5dae:	fa 40 13 00 	mov.b	#19,	50(r10)	;#0x0013, 0x0032
    5db2:	32 00 

00005db4 <.Loc.427.1>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    5db4:	fa 40 12 00 	mov.b	#18,	51(r10)	;#0x0012, 0x0033
    5db8:	33 00 

00005dba <.Loc.428.1>:
  I2CDB0.req.callback.callback = NULL;
    5dba:	00 18 ca 43 	movx.a	#0,	38(r10)	;r3 As==00, 0x00026
    5dbe:	26 00 

00005dc0 <.Loc.429.1>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    5dc0:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005dc4 <.Loc.466.1>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    5dc4:	0a 16       	popm.a	#1,	r10	;20-bit words
    5dc6:	10 01       	reta			;

00005dc8 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
    5dc8:	0a 14       	pushm.a	#1,	r10	;20-bit words

00005dca <.LCFI1>:
    5dca:	ca 0c       	mova	r12,	r10	;

00005dcc <.Loc.479.1>:

    /* Enables the peripheral.*/
#if MSP430X_I2C_USE_I2CB0 == TRUE
    if (&I2CDB0 == i2cp) {
    5dcc:	9c 01 be 14 	cmpa	#70846,	r12	;0x114be
    5dd0:	52 20       	jnz	$+166    	;abs 0x5e76

00005dd2 <.Loc.481.1>:
      /* Stop the peripheral */
      UCB0CTLW0 |= 0x01;
    5dd2:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5dd6:	40 06 

00005dd8 <.Loc.483.1>:
      /* Configure bit rate */
      UCB0BRW = MSP430X_I2CB0_CLK_FREQ / I2CDB0.config->bit_rate;
    5dd8:	3c 0c 02 00 	mova	2(r12),	r12	;

00005ddc <.LVL8>:
    5ddc:	2e 4c       	mov	@r12,	r14	;
    5dde:	1f 4c 02 00 	mov	2(r12),	r15	;
    5de2:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5de6:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5dea:	b0 13 34 d1 	calla	#53556		;0x0d134
    5dee:	40 18 82 4c 	movx.w	r12,	&0x00646;
    5df2:	46 06 

00005df4 <.Loc.485.1>:
      /* Clock low timeout 34 ms, manual STOP condition */
      UCB0CTLW1 = UCCLTO_3 | UCASTP_0;
    5df4:	40 18 b2 40 	movx.w	#192,	&0x00642;0x000c0
    5df8:	c0 00 42 06 

00005dfc <.Loc.490.1>:
  #if MSP430X_I2C_10BIT
      UCB0CTLW0 = (I2CDB0.config->long_addr << 14) | UCMST | UCMODE_3 | UCSYNC
        | MSP430X_I2CB0_UCSSEL;
  #else
      UCB0CTLW0 = UCMST | UCMODE_3 | UCSYNC | MSP430X_I2CB0_UCSSEL;
    5dfc:	40 18 b2 40 	movx.w	#3968,	&0x00640;0x00f80
    5e00:	80 0f 40 06 

00005e04 <.Loc.492.1>:
  #endif
      if (I2CDB0.regs->statw & BIT4) {
    5e04:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5e08:	40 18 bc b0 	bitx.w	#16,	8(r12)	;0x00010
    5e0c:	10 00 08 00 
    5e10:	2b 24       	jz	$+88     	;abs 0x5e68

00005e12 <.Loc.494.1>:
        /* Disable again */
        UCB0CTLW0 |= 0x01;
    5e12:	40 18 92 d3 	bisx.w	#1,	&0x00640;r3 As==01
    5e16:	40 06 

00005e18 <.Loc.496.1>:
        /* Set the SCL pin as an output */
        P1SEL1 &= ~0x80;
    5e18:	40 18 f2 f0 	andx.b	#127,	&0x0020c;0x0007f
    5e1c:	7f 00 0c 02 

00005e20 <.Loc.497.1>:
        P1DIR |= 0x80;
    5e20:	c0 1f f2 d0 	bisx.b	#-128,	&0x00204;0xfff80
    5e24:	80 ff 04 02 

00005e28 <.Loc.498.1>:
        P1REN &= ~0x80;
    5e28:	40 18 f2 f0 	andx.b	#127,	&0x00206;0x0007f
    5e2c:	7f 00 06 02 

00005e30 <.LVL10>:
    5e30:	7c 40 0a 00 	mov.b	#10,	r12	;#0x000a

00005e34 <.L7>:
        /* Toggle it 10 times */
        for (int i = 0 ; i < 10; i++) {
          P1OUT &= ~0x80;
    5e34:	40 18 f2 f0 	andx.b	#127,	&0x00202;0x0007f
    5e38:	7f 00 02 02 

00005e3c <.Loc.502.1>:
          P1OUT |= 0x80;
    5e3c:	c0 1f f2 d0 	bisx.b	#-128,	&0x00202;0xfff80
    5e40:	80 ff 02 02 

00005e44 <.LVL12>:
    5e44:	3c 53       	add	#-1,	r12	;r3 As==11

00005e46 <.LVL13>:
        for (int i = 0 ; i < 10; i++) {
    5e46:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e48:	f5 23       	jnz	$-20     	;abs 0x5e34

00005e4a <.LBE53>:
        }
        /* Reset it to I2C mode */
        P1DIR &= ~0x80;
    5e4a:	40 18 f2 f0 	andx.b	#127,	&0x00204;0x0007f
    5e4e:	7f 00 04 02 

00005e52 <.Loc.506.1>:
        P1SEL1 |= 0x80;
    5e52:	c0 1f f2 d0 	bisx.b	#-128,	&0x0020c;0xfff80
    5e56:	80 ff 0c 02 

00005e5a <.Loc.507.1>:
        P1REN |= 0x80;
    5e5a:	c0 1f f2 d0 	bisx.b	#-128,	&0x00206;0xfff80
    5e5e:	80 ff 06 02 

00005e62 <.Loc.509.1>:
        /* Re-enable the peripheral */
        UCB0CTLW0 &= ~0x01;
    5e62:	40 18 92 c3 	bicx.w	#1,	&0x00640;r3 As==01
    5e66:	40 06 

00005e68 <.L6>:
      }
      UCB0IE = UCCLTOIE | UCNACKIE | UCALIE | UCSTPIE;
    5e68:	40 18 b2 40 	movx.w	#184,	&0x0066a;0x000b8
    5e6c:	b8 00 6a 06 

00005e70 <.Loc.512.1>:
      UCB0IFG = 0;
    5e70:	40 18 82 43 	movx.w	#0,	&0x0066c;r3 As==00
    5e74:	6c 06 

00005e76 <.L4>:
      }
  #endif
    }
#endif

}
    5e76:	0a 16       	popm.a	#1,	r10	;20-bit words
    5e78:	10 01       	reta			;

00005e7a <i2cMSP430XStartReceiveToRegI>:
#endif
  }
}

void i2cMSP430XStartReceiveToRegI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * regp, i2ccallback_t callback) {
    5e7a:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005e7c <.LCFI2>:
    5e7c:	ca 0c       	mova	r12,	r10	;
    5e7e:	49 4d       	mov.b	r13,	r9	;
    5e80:	cc 0f       	mova	r15,	r12	;

00005e82 <.LVL19>:
    5e82:	38 01 10 00 	mova	16(r1),	r8	;0x00010

00005e86 <.Loc.688.1>:
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5e86:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005e8a <.Loc.690.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5e8a:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005e8e <.Loc.692.1>:
  
  i2cp->buffer = regp;
    5e8e:	7a 0f 08 00 	mova	r15,	8(r10)	;

00005e92 <.Loc.695.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5e92:	9e 00 01 00 	cmpa	#1,	r14	;
    5e96:	17 20       	jnz	$+48     	;abs 0x5ec6

00005e98 <.Loc.697.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = regp;
    5e98:	7a 0f 18 00 	mova	r15,	24(r10)	; 0x00018

00005e9c <.Loc.698.1>:
    i2cp->req.size = 0;
    5e9c:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005ea0 <.Loc.700.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5ea0:	3e 0a 10 00 	mova	16(r10),r14	;0x00010

00005ea4 <.LVL20>:
    5ea4:	be f0 ef ff 	and	#-17,	0(r14)	;#0xffef
    5ea8:	00 00 

00005eaa <.Loc.702.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5eaa:	ae d3 00 00 	bis	#2,	0(r14)	;r3 As==10

00005eae <.L16>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5eae:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    5eb2:	fd 23       	jnz	$-4      	;abs 0x5eae

00005eb4 <.Loc.706.1>:
    /* Call the callback immediately as well */
    if (callback != NULL) {
    5eb4:	98 00 00 00 	cmpa	#0,	r8	;
    5eb8:	04 24       	jz	$+10     	;abs 0x5ec2

00005eba <.Loc.707.1>:
      callback(i2cp, regp, 1);
    5eba:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5ebc:	cd 0c       	mova	r12,	r13	;

00005ebe <.LVL21>:
    5ebe:	cc 0a       	mova	r10,	r12	;
    5ec0:	48 13       	calla	r8		;

00005ec2 <.L14>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5ec2:	28 16       	popm.a	#3,	r10	;20-bit words
    5ec4:	10 01       	reta			;

00005ec6 <.L15>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5ec6:	3d 0a 10 00 	mova	16(r10),r13	;0x00010

00005eca <.LVL24>:
    5eca:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    5ece:	7a 0d 14 00 	mova	r13,	20(r10)	; 0x00014

00005ed2 <.Loc.713.1>:
    i2cp->req.dest_addr = regp;
    5ed2:	7a 0f 18 00 	mova	r15,	24(r10)	; 0x00018

00005ed6 <.Loc.714.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5ed6:	40 18 0e 4e 	movx.w	r14,	r14	;

00005eda <.LVL25>:
    5eda:	3e 53       	add	#-1,	r14	;r3 As==11
    5edc:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c

00005ee0 <.Loc.715.1>:
    i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    5ee0:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

00005ee4 <.Loc.716.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5ee4:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033

00005ee8 <.LVL26>:
    5ee8:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005eec <.Loc.718.1>:
    i2cp->callback = callback;
    5eec:	7a 08 0c 00 	mova	r8,	12(r10)	; 0x0000c

00005ef0 <.Loc.720.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5ef0:	00 18 fa 40 	movx.a	#25020,	38(r10)	;0x061bc, 0x00026
    5ef4:	bc 61 26 00 

00005ef8 <.Loc.721.1>:
    i2cp->req.callback.args = i2cp;
    5ef8:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005efc <.Loc.723.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5efc:	c8 0a       	mova	r10,	r8	;

00005efe <.LVL27>:
    5efe:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5f02:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5f06:	9c 00 00 00 	cmpa	#0,	r12	;
    5f0a:	04 24       	jz	$+10     	;abs 0x5f14

00005f0c <.Loc.723.1>:
    5f0c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5f10:	00 00 
    5f12:	03 20       	jnz	$+8      	;abs 0x5f1a

00005f14 <.L18>:
      dmaAcquireI(&(i2cp->dma));
    5f14:	cc 08       	mova	r8,	r12	;
    5f16:	b0 13 94 59 	calla	#22932		;0x05994

00005f1a <.L19>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5f1a:	cd 0a       	mova	r10,	r13	;
    5f1c:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5f20:	cc 08       	mova	r8,	r12	;
    5f22:	b0 13 02 5a 	calla	#23042		;0x05a02

00005f26 <.LVL29>:
    i2cp->regs->i2csa = addr;
    5f26:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5f2a:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005f2e <.Loc.730.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5f2e:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5f32:	00 00 

00005f34 <.Loc.731.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5f34:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005f38 <.Loc.733.1>:
}
    5f38:	80 00 c2 5e 	mova	#24258,	r0	;0x05ec2

00005f3c <i2cMSP430XStartReceiveI>:

void i2cMSP430XStartReceiveI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * rxbuf, i2ccallback_t callback) {
    5f3c:	2a 14       	pushm.a	#3,	r10	;20-bit words

00005f3e <.LCFI3>:
    5f3e:	ca 0c       	mova	r12,	r10	;
    5f40:	49 4d       	mov.b	r13,	r9	;
    5f42:	cc 0f       	mova	r15,	r12	;

00005f44 <.LVL31>:
    5f44:	38 01 10 00 	mova	16(r1),	r8	;0x00010

00005f48 <.Loc.748.1>:
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    5f48:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00005f4c <.Loc.750.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_RX;
    5f4c:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10

00005f50 <.Loc.752.1>:
  
  i2cp->buffer = rxbuf;
    5f50:	7a 0f 08 00 	mova	r15,	8(r10)	;

00005f54 <.Loc.755.1>:
  
  /* DMA only works for more than 2 bytes */
  if (1 == n) {
    5f54:	9e 00 01 00 	cmpa	#1,	r14	;
    5f58:	17 20       	jnz	$+48     	;abs 0x5f88

00005f5a <.Loc.757.1>:
    /* DMA request is referenced by interrupt handler */
    i2cp->req.dest_addr = rxbuf;
    5f5a:	7a 0f 18 00 	mova	r15,	24(r10)	; 0x00018

00005f5e <.Loc.758.1>:
    i2cp->req.size = 0;
    5f5e:	8a 43 1c 00 	mov	#0,	28(r10)	;r3 As==00, 0x001c

00005f62 <.Loc.760.1>:
    /* Receiver mode */
    i2cp->regs->ctlw0 &= ~UCTR;
    5f62:	3e 0a 10 00 	mova	16(r10),r14	;0x00010

00005f66 <.LVL32>:
    5f66:	be f0 ef ff 	and	#-17,	0(r14)	;#0xffef
    5f6a:	00 00 

00005f6c <.Loc.762.1>:
    /* Generate Start */
    i2cp->regs->ctlw0 |= UCTXSTT;
    5f6c:	ae d3 00 00 	bis	#2,	0(r14)	;r3 As==10

00005f70 <.L29>:
    /* Generate Stop immediately */
    while (i2cp->regs->ctlw0 & UCTXSTT);
    5f70:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    5f74:	fd 23       	jnz	$-4      	;abs 0x5f70

00005f76 <.Loc.766.1>:
    /* Call the callback immediately as well */
    if (callback != NULL) {
    5f76:	98 00 00 00 	cmpa	#0,	r8	;
    5f7a:	04 24       	jz	$+10     	;abs 0x5f84

00005f7c <.Loc.768.1>:
      chSysUnlockFromISR();
      callback(i2cp, rxbuf, 1);
    5f7c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5f7e:	cd 0c       	mova	r12,	r13	;

00005f80 <.LVL33>:
    5f80:	cc 0a       	mova	r10,	r12	;
    5f82:	48 13       	calla	r8		;

00005f84 <.L27>:
    /* Slave address first, then receiver mode, then START */
    i2cp->regs->i2csa = addr;
    i2cp->regs->ctlw0 &= ~UCTR;
    i2cp->regs->ctlw0 |= UCTXSTT;
  }
}
    5f84:	28 16       	popm.a	#3,	r10	;20-bit words
    5f86:	10 01       	reta			;

00005f88 <.L28>:
    i2cp->req.source_addr = &(i2cp->regs->rxbuf);
    5f88:	3d 0a 10 00 	mova	16(r10),r13	;0x00010

00005f8c <.LVL36>:
    5f8c:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    5f90:	7a 0d 14 00 	mova	r13,	20(r10)	; 0x00014

00005f94 <.Loc.775.1>:
    i2cp->req.dest_addr = rxbuf;
    5f94:	7a 0f 18 00 	mova	r15,	24(r10)	; 0x00018

00005f98 <.Loc.776.1>:
    i2cp->req.size = n - 1; /* have to stop early to generate STOP */
    5f98:	40 18 0e 4e 	movx.w	r14,	r14	;

00005f9c <.LVL37>:
    5f9c:	3e 53       	add	#-1,	r14	;r3 As==11
    5f9e:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c

00005fa2 <.Loc.777.1>:
    i2cp->req.addr_mode = MSP430X_DMA_DSTINCR;
    5fa2:	ba 40 00 0c 	mov	#3072,	30(r10)	;#0x0c00, 0x001e
    5fa6:	1e 00 

00005fa8 <.Loc.778.1>:
    i2cp->req.trigger = i2cp->rxtrig;
    5fa8:	5c 4a 33 00 	mov.b	51(r10),r12	;0x00033

00005fac <.LVL38>:
    5fac:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00005fb0 <.Loc.780.1>:
    i2cp->callback = callback;
    5fb0:	7a 08 0c 00 	mova	r8,	12(r10)	; 0x0000c

00005fb4 <.Loc.782.1>:
    i2cp->req.callback.callback = &rx_async_callback;
    5fb4:	00 18 fa 40 	movx.a	#25020,	38(r10)	;0x061bc, 0x00026
    5fb8:	bc 61 26 00 

00005fbc <.Loc.783.1>:
    i2cp->req.callback.args = i2cp;
    5fbc:	7a 0a 2a 00 	mova	r10,	42(r10)	; 0x0002a

00005fc0 <.Loc.785.1>:
    if (!dmaIsClaimed(&(i2cp->dma))) {
    5fc0:	c8 0a       	mova	r10,	r8	;

00005fc2 <.LVL39>:
    5fc2:	a8 00 34 00 	adda	#52,	r8	;0x00034
    5fc6:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    5fca:	9c 00 00 00 	cmpa	#0,	r12	;
    5fce:	04 24       	jz	$+10     	;abs 0x5fd8

00005fd0 <.Loc.785.1>:
    5fd0:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5fd4:	00 00 
    5fd6:	03 20       	jnz	$+8      	;abs 0x5fde

00005fd8 <.L31>:
      dmaAcquireI(&(i2cp->dma));
    5fd8:	cc 08       	mova	r8,	r12	;
    5fda:	b0 13 94 59 	calla	#22932		;0x05994

00005fde <.L32>:
    dmaTransferI(&(i2cp->dma), &(i2cp->req));
    5fde:	cd 0a       	mova	r10,	r13	;
    5fe0:	ad 00 14 00 	adda	#20,	r13	;0x00014
    5fe4:	cc 08       	mova	r8,	r12	;
    5fe6:	b0 13 02 5a 	calla	#23042		;0x05a02

00005fea <.LVL41>:
    i2cp->regs->i2csa = addr;
    5fea:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    5fee:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

00005ff2 <.Loc.792.1>:
    i2cp->regs->ctlw0 &= ~UCTR;
    5ff2:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5ff6:	00 00 

00005ff8 <.Loc.793.1>:
    i2cp->regs->ctlw0 |= UCTXSTT;
    5ff8:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005ffc <.Loc.795.1>:
}
    5ffc:	80 00 84 5f 	mova	#24452,	r0	;0x05f84

00006000 <i2cMSP430XStartTransmitMSBI>:

void i2cMSP430XStartTransmitMSBI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    6000:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006002 <.LCFI4>:
    6002:	ca 0c       	mova	r12,	r10	;
    6004:	49 4d       	mov.b	r13,	r9	;

00006006 <.Loc.812.1>:
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  i2cp->regs->ifg &= ~UCTXIFG;
    6006:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

0000600a <.LVL43>:
    600a:	ac c3 2c 00 	bic	#2,	44(r12)	;r3 As==10, 0x002c

0000600e <.Loc.813.1>:
  i2cp->regs->ie &= ~UCTXIE;
    600e:	ac c3 2a 00 	bic	#2,	42(r12)	;r3 As==10, 0x002a

00006012 <.Loc.816.1>:
  
  /* Reset error flags */
  i2cp->errors = I2C_NO_ERROR;
    6012:	8a 43 06 00 	mov	#0,	6(r10)	;r3 As==00

00006016 <.Loc.818.1>:
  /* Set state */
  i2cp->state = I2C_ACTIVE_TX;
    6016:	fa 40 03 00 	mov.b	#3,	0(r10)	;
    601a:	00 00 

0000601c <.Loc.820.1>:
  
  i2cp->buffer = txbuf;
    601c:	7a 0f 08 00 	mova	r15,	8(r10)	;

00006020 <.Loc.823.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf + n - 1;
    6020:	c8 0e       	mova	r14,	r8	;
    6022:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    6026:	ef 08       	adda	r8,	r15	;

00006028 <.LVL44>:
    6028:	7a 0f 14 00 	mova	r15,	20(r10)	; 0x00014

0000602c <.Loc.824.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    602c:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    6030:	7a 0c 18 00 	mova	r12,	24(r10)	; 0x00018

00006034 <.Loc.825.1>:
  i2cp->req.size = n;
    6034:	40 18 8a 4e 	movx.w	r14,	28(r10)	; 0x0001c
    6038:	1c 00 

0000603a <.Loc.826.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCDECR;
    603a:	ba 40 00 02 	mov	#512,	30(r10)	;#0x0200, 0x001e
    603e:	1e 00 

00006040 <.Loc.827.1>:
  i2cp->req.trigger = i2cp->txtrig;
    6040:	5c 4a 32 00 	mov.b	50(r10),r12	;0x00032
    6044:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00006048 <.Loc.829.1>:
  /* Custom callback */
  i2cp->callback = callback;
    6048:	00 18 da 41 	movx.a	16(r1),	12(r10)	;0x00010, 0x0000c
    604c:	10 00 0c 00 

00006050 <.Loc.831.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    6050:	00 18 fa 40 	movx.a	#23942,	38(r10)	;0x05d86, 0x00026
    6054:	86 5d 26 00 

00006058 <.Loc.833.1>:
  
  if (!dmaIsClaimed(&(i2cp->dma))) {
    6058:	c8 0a       	mova	r10,	r8	;
    605a:	a8 00 34 00 	adda	#52,	r8	;0x00034
    605e:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    6062:	9c 00 00 00 	cmpa	#0,	r12	;
    6066:	04 24       	jz	$+10     	;abs 0x6070

00006068 <.Loc.833.1>:
    6068:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    606c:	00 00 
    606e:	03 20       	jnz	$+8      	;abs 0x6076

00006070 <.L41>:
    dmaAcquireI(&(i2cp->dma));
    6070:	cc 08       	mova	r8,	r12	;
    6072:	b0 13 94 59 	calla	#22932		;0x05994

00006076 <.L42>:
  }
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    6076:	cd 0a       	mova	r10,	r13	;
    6078:	ad 00 14 00 	adda	#20,	r13	;0x00014
    607c:	cc 08       	mova	r8,	r12	;
    607e:	b0 13 02 5a 	calla	#23042		;0x05a02

00006082 <.LVL46>:
    
  /* Slave address first, then transmitter mode and START */
  i2cp->regs->i2csa = addr;
    6082:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    6086:	8c 49 20 00 	mov	r9,	32(r12)	; 0x0020

0000608a <.Loc.840.1>:
  i2cp->regs->ctlw0 |= (UCTR | UCTXSTT);
    608a:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    608e:	00 00 

00006090 <.Loc.843.1>:
  /* IFG is set automatically after START */
  
}
    6090:	28 16       	popm.a	#3,	r10	;20-bit words
    6092:	10 01       	reta			;

00006094 <i2cMSP430XContinueTransmitMemsetI>:
  i2cp->regs->ifg |= UCTXIFG;
  
}

void i2cMSP430XContinueTransmitMemsetI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * value, i2ccallback_t callback) {
    6094:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006096 <.LCFI7>:
    6096:	ca 0c       	mova	r12,	r10	;

00006098 <.Loc.941.1>:
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  i2cp->buffer = value;
    6098:	7c 0f 08 00 	mova	r15,	8(r12)	;

0000609c <.Loc.944.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = value;
    609c:	7c 0f 14 00 	mova	r15,	20(r12)	; 0x00014

000060a0 <.Loc.945.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    60a0:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

000060a4 <.LVL57>:
    60a4:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    60a8:	7a 0c 18 00 	mova	r12,	24(r10)	; 0x00018

000060ac <.Loc.946.1>:
  i2cp->req.size = n;
    60ac:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c

000060b0 <.Loc.947.1>:
  i2cp->req.addr_mode = 0; /* neither increment nor decrement */
    60b0:	8a 43 1e 00 	mov	#0,	30(r10)	;r3 As==00, 0x001e

000060b4 <.Loc.948.1>:
  i2cp->req.trigger = i2cp->txtrig;
    60b4:	5c 4a 32 00 	mov.b	50(r10),r12	;0x00032
    60b8:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

000060bc <.Loc.950.1>:
  /* Custom callback */
  i2cp->callback = callback;
    60bc:	00 18 da 41 	movx.a	8(r1),	12(r10)	; 0x0000c
    60c0:	08 00 0c 00 

000060c4 <.Loc.952.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    60c4:	00 18 fa 40 	movx.a	#23942,	38(r10)	;0x05d86, 0x00026
    60c8:	86 5d 26 00 

000060cc <.Loc.955.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    60cc:	cd 0a       	mova	r10,	r13	;

000060ce <.LVL58>:
    60ce:	ad 00 14 00 	adda	#20,	r13	;0x00014
    60d2:	cc 0a       	mova	r10,	r12	;
    60d4:	ac 00 34 00 	adda	#52,	r12	;0x00034
    60d8:	b0 13 02 5a 	calla	#23042		;0x05a02

000060dc <.LVL59>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    60dc:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    60e0:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

000060e4 <.Loc.960.1>:
  
}
    60e4:	0a 16       	popm.a	#1,	r10	;20-bit words
    60e6:	10 01       	reta			;

000060e8 <i2cMSP430XContinueTransmitI>:

void i2cMSP430XContinueTransmitI(I2CDriver *i2cp, i2caddr_t addr, size_t n, 
    uint8_t * txbuf, i2ccallback_t callback) {
    60e8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000060ea <.LCFI8>:
    60ea:	ca 0c       	mova	r12,	r10	;

000060ec <.Loc.977.1>:
  osalDbgAssert(!(addr & 0xFC00), "Invalid address");
#else
  osalDbgAssert(!(addr & 0x80), "Invalid address");
#endif
  
  i2cp->buffer = txbuf;
    60ec:	7c 0f 08 00 	mova	r15,	8(r12)	;

000060f0 <.Loc.980.1>:
  
  /* Set up DMA */
  i2cp->req.source_addr = txbuf;
    60f0:	7c 0f 14 00 	mova	r15,	20(r12)	; 0x00014

000060f4 <.Loc.981.1>:
  i2cp->req.dest_addr = &(i2cp->regs->txbuf);
    60f4:	3c 0c 10 00 	mova	16(r12),r12	;0x00010

000060f8 <.LVL61>:
    60f8:	ac 00 0e 00 	adda	#14,	r12	;0x0000e
    60fc:	7a 0c 18 00 	mova	r12,	24(r10)	; 0x00018

00006100 <.Loc.982.1>:
  i2cp->req.size = n;
    6100:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c

00006104 <.Loc.983.1>:
  i2cp->req.addr_mode = MSP430X_DMA_SRCINCR;
    6104:	ba 40 00 03 	mov	#768,	30(r10)	;#0x0300, 0x001e
    6108:	1e 00 

0000610a <.Loc.984.1>:
  i2cp->req.trigger = i2cp->txtrig;
    610a:	5c 4a 32 00 	mov.b	50(r10),r12	;0x00032
    610e:	8a 4c 24 00 	mov	r12,	36(r10)	; 0x0024

00006112 <.Loc.986.1>:
  /* Custom callback */
  i2cp->callback = callback;
    6112:	00 18 da 41 	movx.a	8(r1),	12(r10)	; 0x0000c
    6116:	08 00 0c 00 

0000611a <.Loc.988.1>:
  /* DMA callback handler */
  i2cp->req.callback.callback = &tx_complete;
    611a:	00 18 fa 40 	movx.a	#23942,	38(r10)	;0x05d86, 0x00026
    611e:	86 5d 26 00 

00006122 <.Loc.991.1>:
  
  osalDbgAssert(dmaIsClaimed(&(i2cp->dma)), "continuation should have DMA");
  dmaTransferI(&(i2cp->dma), &(i2cp->req));
    6122:	cd 0a       	mova	r10,	r13	;

00006124 <.LVL62>:
    6124:	ad 00 14 00 	adda	#20,	r13	;0x00014
    6128:	cc 0a       	mova	r10,	r12	;
    612a:	ac 00 34 00 	adda	#52,	r12	;0x00034
    612e:	b0 13 02 5a 	calla	#23042		;0x05a02

00006132 <.LVL63>:
    
  /* Reset IFG to restart the DMA */
  i2cp->regs->ifg |= UCTXIFG;
    6132:	3c 0a 10 00 	mova	16(r10),r12	;0x00010
    6136:	ac d3 2c 00 	bis	#2,	44(r12)	;r3 As==10, 0x002c

0000613a <.Loc.996.1>:
  
}
    613a:	0a 16       	popm.a	#1,	r10	;20-bit words
    613c:	10 01       	reta			;

0000613e <i2cMSP430XEndTransferI>:

void i2cMSP430XEndTransferI(I2CDriver *i2cp) {
    613e:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006140 <.LCFI9>:
    6140:	b1 00 02 00 	suba	#2,	r1	;

00006144 <.LCFI10>:
  
  osalDbgAssert(i2cp->state == I2C_ACTIVE_RX || i2cp->state == I2C_ACTIVE_TX,
      "can't cancel a transaction that's not happening");
  
  /* Generate STOP condition*/
  i2cp->regs->ctlw0 |= UCTXSTP;
    6144:	3e 0c 10 00 	mova	16(r12),r14	;0x00010
    6148:	ae d2 00 00 	bis	#4,	0(r14)	;r2 As==10

0000614c <.Loc.1008.1>:
  
  if (i2cp->state == I2C_ACTIVE_RX) {
    614c:	ec 92 00 00 	cmp.b	#4,	0(r12)	;r2 As==10
    6150:	2e 20       	jnz	$+94     	;abs 0x61ae

00006152 <.L68>:
    
    /* Ensure we don't accidentally continue before receiving the last byte */
    /*i2cp->state = I2C_ACTIVE_RX;*/
    
    /* Wait for last RX byte */
    while (!(i2cp->regs->ifg & UCRXIFG0));
    6152:	40 18 9e b3 	bitx.w	#1,	44(r14)	;r3 As==01, 0x0002c
    6156:	2c 00 
    6158:	fc 27       	jz	$-6      	;abs 0x6152
    615a:	3a 0c 18 00 	mova	24(r12),r10	;0x00018

0000615e <.Loc.1018.1>:
    
    if (i2cp->req.addr_mode) {
    615e:	8c 93 1e 00 	cmp	#0,	30(r12)	;r3 As==00, 0x001e
    6162:	1f 24       	jz	$+64     	;abs 0x61a2

00006164 <.Loc.1019.1>:
      ((uint8_t *)(i2cp->req.dest_addr))[i2cp->req.size] = i2cp->regs->rxbuf;
    6164:	1d 4e 0c 00 	mov	12(r14),r13	;0x0000c
    6168:	40 18 1e 4c 	movx.w	28(r12),r14	;0x0001c
    616c:	1c 00 
    616e:	ee 0a       	adda	r10,	r14	;
    6170:	ce 4d 00 00 	mov.b	r13,	0(r14)	;

00006174 <.L59>:
    }
    else {
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    }
    
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    6174:	3e 0c 10 00 	mova	16(r12),r14	;0x00010

00006178 <.L60>:
    6178:	ae b2 00 00 	bit	#4,	0(r14)	;r2 As==10
    617c:	fd 23       	jnz	$-4      	;abs 0x6178

0000617e <.Loc.1026.1>:
    i2cp->regs->ifg &= ~UCSTPIFG;
    617e:	be c2 2c 00 	bic	#8,	44(r14)	;r2 As==11, 0x002c

00006182 <.Loc.1028.1>:
      
    if (i2cp->regs->ifg & UCRXIFG0) {
    6182:	40 18 9e b3 	bitx.w	#1,	44(r14)	;r3 As==01, 0x0002c
    6186:	2c 00 
    6188:	06 24       	jz	$+14     	;abs 0x6196

0000618a <.LBB68>:
      /* Need to read the buffer to reset the state */
      volatile uint8_t throwaway;
      throwaway = i2cp->regs->rxbuf;
    618a:	1d 4e 0c 00 	mov	12(r14),r13	;0x0000c
    618e:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006192 <.Loc.1032.1>:
      (void)(throwaway);
    6192:	5d 41 01 00 	mov.b	1(r1),	r13	;

00006196 <.L61>:
  else {
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    i2cp->regs->ifg &= ~UCSTPIFG;
  }
  
  i2cp->state = I2C_READY;
    6196:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000619a <.Loc.1041.1>:
}
    619a:	a1 00 02 00 	adda	#2,	r1	;
    619e:	0a 16       	popm.a	#1,	r10	;20-bit words
    61a0:	10 01       	reta			;

000061a2 <.L58>:
      *((uint8_t *)(i2cp->req.dest_addr)) = i2cp->regs->rxbuf;
    61a2:	1d 4e 0c 00 	mov	12(r14),r13	;0x0000c
    61a6:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    61aa:	80 00 74 61 	mova	#24948,	r0	;0x06174

000061ae <.L65>:
    while (i2cp->regs->ctlw0 & UCTXSTP) ;
    61ae:	ae b2 00 00 	bit	#4,	0(r14)	;r2 As==10
    61b2:	fd 23       	jnz	$-4      	;abs 0x61ae

000061b4 <.Loc.1037.1>:
    i2cp->regs->ifg &= ~UCSTPIFG;
    61b4:	be c2 2c 00 	bic	#8,	44(r14)	;r2 As==11, 0x002c
    61b8:	80 00 96 61 	mova	#24982,	r0	;0x06196

000061bc <rx_async_callback>:
void rx_async_callback(void * args) {
    61bc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000061be <.LCFI11>:
    61be:	08 14       	pushm.a	#1,	r8	;20-bit words

000061c0 <.LCFI12>:
    61c0:	ca 0c       	mova	r12,	r10	;

000061c2 <.LVL66>:
  if (NULL != i2cp->callback) {
    61c2:	38 0c 0c 00 	mova	12(r12),r8	;0x0000c
    61c6:	98 00 00 00 	cmpa	#0,	r8	;
    61ca:	08 24       	jz	$+18     	;abs 0x61dc

000061cc <.Loc.99.1>:
    i2cp->callback(i2cp, i2cp->buffer, i2cp->req.size);
    61cc:	1e 4c 1c 00 	mov	28(r12),r14	;0x0001c
    61d0:	3d 0c 08 00 	mova	8(r12),	r13	;
    61d4:	48 13       	calla	r8		;

000061d6 <.L71>:
}
    61d6:	08 16       	popm.a	#1,	r8	;20-bit words
    61d8:	0a 16       	popm.a	#1,	r10	;20-bit words
    61da:	10 01       	reta			;

000061dc <.L72>:
    i2cMSP430XEndTransferI(i2cp);
    61dc:	b0 13 3e 61 	calla	#24894		;0x0613e

000061e0 <.LVL68>:
}
    61e0:	80 00 d6 61 	mova	#25046,	r0	;0x061d6

000061e4 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
    61e4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000061e6 <.LCFI0>:

#if MSP430X_GPT_USE_TA0 == TRUE
  /* Driver initialization.*/
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
    61e6:	8c 01 10 15 	mova	#70928,	r12	;0x11510
    61ea:	00 18 fc 40 	movx.a	#832,	6(r12)	;0x00340
    61ee:	40 03 06 00 

000061f2 <.Loc.249.1>:
  gptObjectInit(&GPTDA0);
    61f2:	8a 00 34 50 	mova	#20532,	r10	;0x05034
    61f6:	4a 13       	calla	r10		;

000061f8 <.LVL0>:
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    61f8:	8c 01 06 15 	mova	#70918,	r12	;0x11506
    61fc:	00 18 fc 40 	movx.a	#896,	6(r12)	;0x00380
    6200:	80 03 06 00 

00006204 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    6204:	4a 13       	calla	r10		;

00006206 <.LVL1>:
  GPTDA2.regs = (msp430x_timer_reg_t *)(&TA2CTL);
  gptObjectInit(&GPTDA2);
#endif
#if MSP430X_GPT_USE_TA3 == TRUE
  /* Driver initialization.*/
  GPTDA3.regs = (msp430x_timer_reg_t *)(&TA3CTL);
    6206:	8c 01 fc 14 	mova	#70908,	r12	;0x114fc
    620a:	00 18 fc 40 	movx.a	#1088,	6(r12)	;0x00440
    620e:	40 04 06 00 

00006212 <.Loc.264.1>:
  gptObjectInit(&GPTDA3);
    6212:	4a 13       	calla	r10		;

00006214 <.LVL2>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    6214:	0a 16       	popm.a	#1,	r10	;20-bit words
    6216:	10 01       	reta			;

00006218 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    6218:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000621a <.LCFI1>:
    621a:	3a 0c 06 00 	mova	6(r12),	r10	;

0000621e <.Loc.290.1>:
  uint32_t divider = 0;

  /* Configures the peripheral.*/
#if MSP430X_GPT_USE_TA0 == TRUE
  if (&GPTDA0 == gptp) {
    621e:	9c 01 10 15 	cmpa	#70928,	r12	;0x11510
    6222:	18 20       	jnz	$+50     	;abs 0x6254

00006224 <.L11>:
  }
#endif
#if MSP430X_GPT_USE_TA3 == TRUE
  if (&GPTDA3 == gptp) {
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA3_TASSEL | TACLR;
    6224:	ba 40 04 01 	mov	#260,	0(r10)	;#0x0104
    6228:	00 00 

0000622a <.Loc.322.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA3_CLK_FREQ / gptp->config->frequency;
    622a:	3c 0c 02 00 	mova	2(r12),	r12	;

0000622e <.LVL5>:
    622e:	2e 4c       	mov	@r12,	r14	;
    6230:	1f 4c 02 00 	mov	2(r12),	r15	;
    6234:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    6238:	4d 43       	clr.b	r13		;
    623a:	b0 13 34 d1 	calla	#53556		;0x0d134

0000623e <.LVL6>:
    623e:	0d 93       	cmp	#0,	r13	;r3 As==00
    6240:	04 20       	jnz	$+10     	;abs 0x624a
    6242:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    6246:	0e 9c       	cmp	r12,	r14	;
    6248:	0e 2c       	jc	$+30     	;abs 0x6266

0000624a <.L7>:
    624a:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040

0000624e <.L15>:
  if (&GPTDA3 == gptp) {
    624e:	4d 43       	clr.b	r13		;
    6250:	80 00 70 62 	mova	#25200,	r0	;0x06270

00006254 <.L3>:
  if (&GPTDA1 == gptp) {
    6254:	9c 01 06 15 	cmpa	#70918,	r12	;0x11506
    6258:	e5 27       	jz	$-52     	;abs 0x6224

0000625a <.Loc.317.1>:
  if (&GPTDA3 == gptp) {
    625a:	9c 01 fc 14 	cmpa	#70908,	r12	;0x114fc
    625e:	e2 27       	jz	$-58     	;abs 0x6224
    6260:	4c 43       	clr.b	r12		;

00006262 <.LVL9>:
    6262:	80 00 4e 62 	mova	#25166,	r0	;0x0624e

00006266 <.L13>:
#endif
  if (divider > 64) {
    divider = 64;
  }
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    6266:	0e 4c       	mov	r12,	r14	;
    6268:	7e f0 07 00 	and.b	#7,	r14	;
    626c:	0e 93       	cmp	#0,	r14	;r3 As==00
    626e:	0b 20       	jnz	$+24     	;abs 0x6286

00006270 <.L12>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    6270:	ba d0 c0 00 	bis	#192,	0(r10)	;#0x00c0
    6274:	00 00 

00006276 <.Loc.349.1>:
    divider /= 8;
    6276:	b0 13 c0 d2 	calla	#53952		;0x0d2c0

0000627a <.L9>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    627a:	0e 4c       	mov	r12,	r14	;
    627c:	3e 53       	add	#-1,	r14	;r3 As==11
    627e:	8a 4e 20 00 	mov	r14,	32(r10)	; 0x0020

00006282 <.Loc.362.1>:

}
    6282:	0a 16       	popm.a	#1,	r10	;20-bit words
    6284:	10 01       	reta			;

00006286 <.L8>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    6286:	0e 4c       	mov	r12,	r14	;
    6288:	7e f0 03 00 	and.b	#3,	r14	;
    628c:	0e 93       	cmp	#0,	r14	;r3 As==00
    628e:	0b 20       	jnz	$+24     	;abs 0x62a6

00006290 <.Loc.352.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    6290:	ba d0 80 00 	bis	#128,	0(r10)	;#0x0080
    6294:	00 00 

00006296 <.Loc.353.1>:
    divider /= 4;
    6296:	40 19 0d 10 	rrux.w	r13		;
    629a:	0c 10       	rrc	r12		;
    629c:	40 19 0d 10 	rrux.w	r13		;
    62a0:	0c 10       	rrc	r12		;

000062a2 <.LVL14>:
    62a2:	80 00 7a 62 	mova	#25210,	r0	;0x0627a

000062a6 <.L10>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    62a6:	0e 4c       	mov	r12,	r14	;
    62a8:	5e f3       	and.b	#1,	r14	;r3 As==01
    62aa:	0e 93       	cmp	#0,	r14	;r3 As==00
    62ac:	e6 23       	jnz	$-50     	;abs 0x627a

000062ae <.Loc.356.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    62ae:	ba d0 40 00 	bis	#64,	0(r10)	;#0x0040
    62b2:	00 00 

000062b4 <.Loc.357.1>:
    divider /= 2;
    62b4:	12 c3       	clrc			
    62b6:	0d 10       	rrc	r13		;
    62b8:	0c 10       	rrc	r12		;

000062ba <.LVL16>:
    62ba:	80 00 7a 62 	mova	#25210,	r0	;0x0627a

000062be <gpt_lld_start_timer>:
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    62be:	3e 0c 02 00 	mova	2(r12),	r14	;
    62c2:	3c 0c 06 00 	mova	6(r12),	r12	;

000062c6 <.LVL20>:
    62c6:	00 18 ce 93 	cmpx.a	#0,	4(r14)	;r3 As==00
    62ca:	04 00 
    62cc:	02 24       	jz	$+6      	;abs 0x62d2

000062ce <.Loc.393.1>:
    gptp->regs->ctl |= TAIE;
    62ce:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

000062d2 <.L19>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    62d2:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

000062d6 <.Loc.400.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    62d6:	2d 4c       	mov	@r12,	r13	;

000062d8 <.LVL21>:
    62d8:	3d d0 14 00 	bis	#20,	r13	;#0x0014
    62dc:	8c 4d 00 00 	mov	r13,	0(r12)	;

000062e0 <.Loc.401.1>:
}
    62e0:	10 01       	reta			;

000062e2 <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    62e2:	3c 0c 06 00 	mova	6(r12),	r12	;

000062e6 <.LVL23>:
    62e6:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    62ea:	00 00 

000062ec <.Loc.415.1>:

}
    62ec:	10 01       	reta			;

000062ee <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    62ee:	0a 14       	pushm.a	#1,	r10	;20-bit words

000062f0 <.LCFI0>:

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    62f0:	8c 01 1a 15 	mova	#70938,	r12	;0x1151a
    62f4:	b0 13 fa 4f 	calla	#20474		;0x04ffa

000062f8 <.LVL0>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    62f8:	01 18 f2 40 	movx.a	#2048,	&0x1152c;0x00800
    62fc:	00 08 2c 15 

00006300 <.LBB8>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    6300:	3c 40 08 1a 	mov	#6664,	r12	;#0x1a08

00006304 <.Loc.63.1>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    6304:	8a 01 1a 15 	mova	#70938,	r10	;0x1151a

00006308 <.L2>:
  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    6308:	6d 4c       	mov.b	@r12,	r13	;
    630a:	7d 93       	cmp.b	#-1,	r13	;r3 As==11
    630c:	04 24       	jz	$+10     	;abs 0x6316
    630e:	3e 40 fe 1a 	mov	#6910,	r14	;#0x1afe
    6312:	de 0c       	cmpa	r12,	r14	;
    6314:	02 2c       	jc	$+6      	;abs 0x631a

00006316 <.L1>:
  populate_tlv(&ADCD1);
#endif
}
    6316:	0a 16       	popm.a	#1,	r10	;20-bit words
    6318:	10 01       	reta			;

0000631a <.L6>:
    if (*tlv_addr == TLV_ADC12CAL) {
    631a:	7d 90 11 00 	cmp.b	#17,	r13	;#0x0011
    631e:	0e 20       	jnz	$+30     	;abs 0x633c

00006320 <.Loc.60.1>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    6320:	cd 0c       	mova	r12,	r13	;
    6322:	ad 00 02 00 	adda	#2,	r13	;
    6326:	7a 0d 30 00 	mova	r13,	48(r10)	; 0x00030

0000632a <.L4>:
    tlv_addr += (tlv_addr[1] + 2);
    632a:	5d 4c 01 00 	mov.b	1(r12),	r13	;
    632e:	40 18 0e 4d 	movx.w	r13,	r14	;
    6332:	ae 00 02 00 	adda	#2,	r14	;
    6336:	ec 0e       	adda	r14,	r12	;
    6338:	80 00 08 63 	mova	#25352,	r0	;0x06308

0000633c <.L3>:
    else if (*tlv_addr == TLV_REFCAL) {
    633c:	7d 90 12 00 	cmp.b	#18,	r13	;#0x0012
    6340:	f4 23       	jnz	$-22     	;abs 0x632a

00006342 <.Loc.63.1>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    6342:	ce 0c       	mova	r12,	r14	;
    6344:	ae 00 02 00 	adda	#2,	r14	;
    6348:	7a 0e 34 00 	mova	r14,	52(r10)	; 0x00034
    634c:	80 00 2a 63 	mova	#25386,	r0	;0x0632a

00006350 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {

  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    6350:	3c 0c 12 00 	mova	18(r12),r12	;0x00012

00006354 <.LVL14>:
    6354:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    6358:	00 00 

0000635a <.Loc.215.1>:

}
    635a:	10 01       	reta			;

0000635c <adcMSP430XAdjustResult>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
    635c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000635e <.LCFI5>:
    635e:	08 14       	pushm.a	#1,	r8	;20-bit words

00006360 <.LCFI6>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    6360:	1e 4c 2e 00 	mov	46(r12),r14	;0x0002e
    6364:	0f 4e       	mov	r14,	r15	;
    6366:	3f f0 ff f7 	and	#-2049,	r15	;#0xf7ff
    636a:	8a 01 1a 15 	mova	#70938,	r10	;0x1151a
    636e:	88 00 20 d3 	mova	#54048,	r8	;0x0d320
    6372:	3f 90 00 01 	cmp	#256,	r15	;#0x0100
    6376:	09 24       	jz	$+20     	;abs 0x638a

00006378 <.Loc.221.1>:
    6378:	3e 90 00 07 	cmp	#1792,	r14	;#0x0700
    637c:	06 24       	jz	$+14     	;abs 0x638a

0000637e <.Loc.223.1>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    637e:	3e 90 00 0b 	cmp	#2816,	r14	;#0x0b00
    6382:	03 24       	jz	$+8      	;abs 0x638a

00006384 <.Loc.224.1>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    6384:	3e 90 00 0d 	cmp	#3328,	r14	;#0x0d00
    6388:	14 20       	jnz	$+42     	;abs 0x63b2

0000638a <.L47>:
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    /* Retrieve proper reference correction factor from TLV */
    fact = (&(ADCD1.ref_cal->CAL_ADC_12VREF_FACTOR))[grpp->vref_src >> 4];
    638a:	5c 4c 30 00 	mov.b	48(r12),r12	;0x00030

0000638e <.LVL25>:
    638e:	5c 0f       	rrum	#4,	r12	;
    6390:	40 18 0c 4c 	movx.w	r12,	r12	;
    6394:	ec 0c       	adda	r12,	r12	;
    6396:	00 18 5c 5a 	addx.a	52(r10),r12	;0x00034
    639a:	34 00 

0000639c <.Loc.229.1>:
    /* Calculate corrected value */
    tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    639c:	0d 5d       	rla	r13		;

0000639e <.LVL27>:
    639e:	0e 4d       	mov	r13,	r14	;
    63a0:	0f 43       	clr	r15		;
    63a2:	2c 4c       	mov	@r12,	r12	;
    63a4:	0d 43       	clr	r13		;
    63a6:	48 13       	calla	r8		;

000063a8 <.Loc.230.1>:
    sample = tmp >> 16;
    63a8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    63ac:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    63b0:	0d 4c       	mov	r12,	r13	;

000063b2 <.L48>:
  }

  /* Gain correction */
  fact   = ADCD1.adc_cal->CAL_ADC_GAIN_FACTOR;
    63b2:	3a 0a 30 00 	mova	48(r10),r10	;0x00030

000063b6 <.LVL31>:
  tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    63b6:	0d 5d       	rla	r13		;

000063b8 <.LVL32>:
    63b8:	2c 4a       	mov	@r10,	r12	;
    63ba:	0e 4c       	mov	r12,	r14	;
    63bc:	0f 43       	clr	r15		;
    63be:	0c 4d       	mov	r13,	r12	;
    63c0:	0d 43       	clr	r13		;
    63c2:	48 13       	calla	r8		;

000063c4 <.LVL33>:
  sample = tmp >> 16;
    63c4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    63c8:	b0 13 dc d2 	calla	#53980		;0x0d2dc

000063cc <.LVL34>:

  /* Offset correction */
  sample += ADCD1.adc_cal->CAL_ADC_OFFSET;

  return sample;
}
    63cc:	1c 5a 02 00 	add	2(r10),	r12	;

000063d0 <.LVL35>:
    63d0:	08 16       	popm.a	#1,	r8	;20-bit words
    63d2:	0a 16       	popm.a	#1,	r10	;20-bit words
    63d4:	10 01       	reta			;

000063d6 <adcMSP430XAdjustTemp>:

adcsample_t adcMSP430XAdjustTemp(ADCConversionGroup * grpp,
                                 adcsample_t sample) {
    63d6:	3a 14       	pushm.a	#4,	r10	;20-bit words

000063d8 <.LCFI7>:
  uint16_t t30;
  uint16_t t85;

  /* Retrieve proper T = 30 correction value from TLV */
  t30 = (&(ADCD1.adc_cal->CAL_ADC_12T30))[grpp->vref_src >> 3];
    63d8:	2a 01 4a 15 	mova	&70986,	r10	;0x1154a
    63dc:	aa 00 04 00 	adda	#4,	r10	;
    63e0:	5c 4c 30 00 	mov.b	48(r12),r12	;0x00030

000063e4 <.LVL37>:
    63e4:	5c 0b       	rrum	#3,	r12	;
    63e6:	40 18 0c 4c 	movx.w	r12,	r12	;
    63ea:	ec 0c       	adda	r12,	r12	;
    63ec:	ea 0c       	adda	r12,	r10	;
    63ee:	27 4a       	mov	@r10,	r7	;

000063f0 <.LVL38>:
  /* Retrieve proper T = 85 correction value from TLV */
  t85 = (&(ADCD1.adc_cal->CAL_ADC_12T30))[(grpp->vref_src >> 3) + 1];

  return ((((int32_t)sample - (int32_t)t30) * (85 - 30)) / (t85 - t30)) + 30;
    63f0:	08 4d       	mov	r13,	r8	;
    63f2:	09 43       	clr	r9		;
    63f4:	0c 47       	mov	r7,	r12	;
    63f6:	0d 43       	clr	r13		;

000063f8 <.LVL39>:
    63f8:	40 18 08 8c 	subx.w	r12,	r8	;
    63fc:	40 18 09 7d 	subcx.w	r13,	r9	;
    6400:	0c 48       	mov	r8,	r12	;
    6402:	0d 49       	mov	r9,	r13	;

00006404 <.LVL40>:
    6404:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    6408:	40 18 0c 88 	subx.w	r8,	r12	;
    640c:	40 18 0d 79 	subcx.w	r9,	r13	;
    6410:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    6414:	1e 4a 02 00 	mov	2(r10),	r14	;
    6418:	0e 87       	sub	r7,	r14	;
    641a:	0f 43       	clr	r15		;
    641c:	40 18 0c 88 	subx.w	r8,	r12	;
    6420:	40 18 0d 79 	subcx.w	r9,	r13	;
    6424:	b0 13 a8 d0 	calla	#53416		;0x0d0a8

00006428 <.Loc.255.1>:
}
    6428:	3c 50 1e 00 	add	#30,	r12	;#0x001e
    642c:	37 16       	popm.a	#4,	r10	;20-bit words
    642e:	10 01       	reta			;

00006430 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    6430:	32 c2       	dint			
    6432:	03 43       	nop			

00006434 <.Loc.46.1>:

}
    6434:	10 01       	reta			;

00006436 <spi_callback>:
  devp->regs.seq_config = 0x00;
  
  devp->state = SX1278_STOP;
}

void spi_callback(SPIDriver *spip) {
    6436:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006438 <.LCFI0>:
    6438:	06 14       	pushm.a	#1,	r6	;20-bit words

0000643a <.LCFI1>:
    643a:	ca 0c       	mova	r12,	r10	;

0000643c <.Loc.513.1>:
  palSetLine(SX1278D1.config->ss_line);
    643c:	88 01 5e 15 	mova	#71006,	r8	;0x1155e
    6440:	0c 08       	mova	@r8,	r12	;

00006442 <.LVL1>:
    6442:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6446:	c6 0c       	mova	r12,	r6	;
    6448:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    644c:	ff 0f 
    644e:	19 46 02 00 	mov	2(r6),	r9	;
    6452:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6454:	40 18 3c 41 	popx.w	r12		;
    6458:	40 18 3d 41 	popx.w	r13		;
    645c:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6460:	0d 12       	push	r13		;
    6462:	0c 12       	push	r12		;
    6464:	0c 16       	popm.a	#1,	r12	;20-bit words
    6466:	40 18 0d 4c 	movx.w	r12,	r13	;
    646a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    646c:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6470:	0c d9       	bis	r9,	r12	;
    6472:	86 4c 02 00 	mov	r12,	2(r6)	;

00006476 <.Loc.514.1>:
  if (SX1278D1.callback != NULL) {
    6476:	3e 08 08 00 	mova	8(r8),	r14	;
    647a:	9e 00 00 00 	cmpa	#0,	r14	;
    647e:	02 24       	jz	$+6      	;abs 0x6484

00006480 <.Loc.515.1>:
    SX1278D1.callback(spip);
    6480:	cc 0a       	mova	r10,	r12	;
    6482:	4e 13       	calla	r14		;

00006484 <.L1>:
  }
}
    6484:	06 16       	popm.a	#1,	r6	;20-bit words
    6486:	28 16       	popm.a	#3,	r10	;20-bit words
    6488:	10 01       	reta			;

0000648a <sx1278Reset.isra.0>:
static void sx1278Reset(SX1278Driver *devp) {
    648a:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000648c <.LCFI2>:
    648c:	c8 0c       	mova	r12,	r8	;

0000648e <.Loc.307.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    648e:	0c 0c       	mova	@r12,	r12	;
    6490:	3a 0c 1e 00 	mova	30(r12),r10	;0x0001e
    6494:	0a 14       	pushm.a	#1,	r10	;20-bit words
    6496:	40 18 3c 41 	popx.w	r12		;
    649a:	40 18 3d 41 	popx.w	r13		;
    649e:	b0 13 8a d2 	calla	#53898		;0x0d28a
    64a2:	0d 12       	push	r13		;
    64a4:	0c 12       	push	r12		;
    64a6:	0c 16       	popm.a	#1,	r12	;20-bit words
    64a8:	40 18 0d 4c 	movx.w	r12,	r13	;
    64ac:	5c 43       	mov.b	#1,	r12	;r3 As==01
    64ae:	b0 13 6a d1 	calla	#53610		;0x0d16a
    64b2:	7e 40 06 00 	mov.b	#6,	r14	;
    64b6:	0d 4c       	mov	r12,	r13	;
    64b8:	cc 0a       	mova	r10,	r12	;
    64ba:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    64be:	ff 0f 
    64c0:	b0 13 56 57 	calla	#22358		;0x05756

000064c4 <.LVL9>:
  palClearLine(devp->config->reset_line);
    64c4:	0c 08       	mova	@r8,	r12	;
    64c6:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    64ca:	ca 0c       	mova	r12,	r10	;
    64cc:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    64d0:	ff 0f 
    64d2:	19 4a 02 00 	mov	2(r10),	r9	;
    64d6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    64d8:	40 18 3c 41 	popx.w	r12		;
    64dc:	40 18 3d 41 	popx.w	r13		;
    64e0:	b0 13 8a d2 	calla	#53898		;0x0d28a
    64e4:	0d 12       	push	r13		;
    64e6:	0c 12       	push	r12		;
    64e8:	0c 16       	popm.a	#1,	r12	;20-bit words
    64ea:	40 18 0d 4c 	movx.w	r12,	r13	;
    64ee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    64f0:	b0 13 6a d1 	calla	#53610		;0x0d16a
    64f4:	09 cc       	bic	r12,	r9	;
    64f6:	8a 49 02 00 	mov	r9,	2(r10)	;

000064fa <.LBB37>:
  chThdSleep(time);
    64fa:	8a 00 10 47 	mova	#18192,	r10	;0x04710
    64fe:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6500:	4a 13       	calla	r10		;

00006502 <.LBE37>:
  palSetLine(devp->config->reset_line);
    6502:	0c 08       	mova	@r8,	r12	;
    6504:	3c 0c 1e 00 	mova	30(r12),r12	;0x0001e
    6508:	c8 0c       	mova	r12,	r8	;
    650a:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    650e:	ff 0f 
    6510:	19 48 02 00 	mov	2(r8),	r9	;
    6514:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6516:	40 18 3c 41 	popx.w	r12		;
    651a:	40 18 3d 41 	popx.w	r13		;
    651e:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6522:	0d 12       	push	r13		;
    6524:	0c 12       	push	r12		;
    6526:	0c 16       	popm.a	#1,	r12	;20-bit words
    6528:	40 18 0d 4c 	movx.w	r12,	r13	;
    652c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    652e:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6532:	0c d9       	bis	r9,	r12	;
    6534:	88 4c 02 00 	mov	r12,	2(r8)	;

00006538 <.LBB39>:
    6538:	7c 40 05 00 	mov.b	#5,	r12	;
    653c:	4a 13       	calla	r10		;

0000653e <.LBE39>:
}
    653e:	28 16       	popm.a	#3,	r10	;20-bit words
    6540:	10 01       	reta			;

00006542 <sx1278SetRegister>:
    uint8_t value) {
    6542:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006544 <.LCFI6>:
    6544:	ca 0c       	mova	r12,	r10	;
    6546:	49 4d       	mov.b	r13,	r9	;
    6548:	47 4e       	mov.b	r14,	r7	;

0000654a <.Loc.108.1>:
  palClearLine(devp->config->ss_line);
    654a:	06 0c       	mova	@r12,	r6	;
    654c:	3c 06 22 00 	mova	34(r6),	r12	;0x00022

00006550 <.LVL56>:
    6550:	c8 0c       	mova	r12,	r8	;
    6552:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6556:	ff 0f 
    6558:	15 48 02 00 	mov	2(r8),	r5	;
    655c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    655e:	40 18 3c 41 	popx.w	r12		;
    6562:	40 18 3d 41 	popx.w	r13		;
    6566:	b0 13 8a d2 	calla	#53898		;0x0d28a

0000656a <.LVL57>:
    656a:	0d 12       	push	r13		;
    656c:	0c 12       	push	r12		;
    656e:	0c 16       	popm.a	#1,	r12	;20-bit words
    6570:	40 18 0d 4c 	movx.w	r12,	r13	;
    6574:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6576:	b0 13 6a d1 	calla	#53610		;0x0d16a
    657a:	05 cc       	bic	r12,	r5	;
    657c:	88 45 02 00 	mov	r5,	2(r8)	;

00006580 <.Loc.109.1>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    6580:	88 00 62 5d 	mova	#23906,	r8	;0x05d62
    6584:	4d 49       	mov.b	r9,	r13	;
    6586:	7d d0 80 ff 	bis.b	#-128,	r13	;#0xff80
    658a:	0c 06       	mova	@r6,	r12	;
    658c:	48 13       	calla	r8		;

0000658e <.LVL59>:
  reg = spiPolledExchange(devp->config->spip, value);
    658e:	0c 0a       	mova	@r10,	r12	;
    6590:	4d 47       	mov.b	r7,	r13	;
    6592:	0c 0c       	mova	@r12,	r12	;
    6594:	48 13       	calla	r8		;

00006596 <.LVL60>:
    6596:	49 4c       	mov.b	r12,	r9	;

00006598 <.Loc.111.1>:
  palSetLine(devp->config->ss_line);
    6598:	0c 0a       	mova	@r10,	r12	;
    659a:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    659e:	ca 0c       	mova	r12,	r10	;

000065a0 <.LVL62>:
    65a0:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    65a4:	ff 0f 
    65a6:	18 4a 02 00 	mov	2(r10),	r8	;
    65aa:	0c 14       	pushm.a	#1,	r12	;20-bit words
    65ac:	40 18 3c 41 	popx.w	r12		;
    65b0:	40 18 3d 41 	popx.w	r13		;
    65b4:	b0 13 8a d2 	calla	#53898		;0x0d28a
    65b8:	0d 12       	push	r13		;
    65ba:	0c 12       	push	r12		;
    65bc:	0c 16       	popm.a	#1,	r12	;20-bit words
    65be:	40 18 0d 4c 	movx.w	r12,	r13	;
    65c2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    65c4:	b0 13 6a d1 	calla	#53610		;0x0d16a
    65c8:	0c d8       	bis	r8,	r12	;
    65ca:	8a 4c 02 00 	mov	r12,	2(r10)	;

000065ce <.Loc.114.1>:
}
    65ce:	4c 49       	mov.b	r9,	r12	;
    65d0:	55 16       	popm.a	#6,	r10	;20-bit words
    65d2:	10 01       	reta			;

000065d4 <sx1278SetMode.constprop.4>:
static void sx1278SetMode(SX1278Driver *devp, SX1278ModeConstants mode) {
    65d4:	0a 14       	pushm.a	#1,	r10	;20-bit words

000065d6 <.LCFI7>:
    65d6:	ca 0c       	mova	r12,	r10	;

000065d8 <.Loc.326.1>:
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    65d8:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    65dc:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    65e0:	cc 4e 05 00 	mov.b	r14,	5(r12)	;

000065e4 <.Loc.327.1>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    65e4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    65e6:	b0 13 42 65 	calla	#25922		;0x06542

000065ea <.LVL67>:
}
    65ea:	0a 16       	popm.a	#1,	r10	;20-bit words
    65ec:	10 01       	reta			;

000065ee <sx1278SetBitrate>:
void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    65ee:	3a 14       	pushm.a	#4,	r10	;20-bit words

000065f0 <.LCFI8>:
    65f0:	c8 0c       	mova	r12,	r8	;

000065f2 <.Loc.164.1>:
  uint32_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    65f2:	0f 4e       	mov	r14,	r15	;
    65f4:	0e 4d       	mov	r13,	r14	;
    65f6:	3c 40 00 80 	mov	#-32768,r12	;#0x8000

000065fa <.LVL69>:
    65fa:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84

000065fe <.LVL70>:
    65fe:	b0 13 34 d1 	calla	#53556		;0x0d134
    6602:	09 4c       	mov	r12,	r9	;

00006604 <.LVL72>:
  uint16_t regs = tmp >> 4;
    6604:	b0 13 ba d2 	calla	#53946		;0x0d2ba

00006608 <.LVL73>:
    6608:	07 4c       	mov	r12,	r7	;

0000660a <.Loc.170.1>:
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    660a:	8a 00 42 65 	mova	#25922,	r10	;0x06542
    660e:	0e 4c       	mov	r12,	r14	;
    6610:	5e 0f       	rrum	#4,	r14	;
    6612:	5e 0f       	rrum	#4,	r14	;
    6614:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6616:	cc 08       	mova	r8,	r12	;
    6618:	4a 13       	calla	r10		;

0000661a <.LVL75>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    661a:	4e 47       	mov.b	r7,	r14	;
    661c:	7d 40 03 00 	mov.b	#3,	r13	;
    6620:	cc 08       	mova	r8,	r12	;
    6622:	4a 13       	calla	r10		;

00006624 <.LVL76>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    6624:	4e 49       	mov.b	r9,	r14	;
    6626:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    662a:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    662e:	cc 08       	mova	r8,	r12	;
    6630:	4a 13       	calla	r10		;

00006632 <.LVL77>:
}
    6632:	37 16       	popm.a	#4,	r10	;20-bit words
    6634:	10 01       	reta			;

00006636 <sx1278SetDeviation>:
void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    6636:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006638 <.LCFI9>:
    6638:	c8 0c       	mova	r12,	r8	;

0000663a <.Loc.184.1>:
  uint16_t regs = ((fdev << 11) + (SX1278_CLK_FREQ >> 9)) / 
    663a:	0c 4d       	mov	r13,	r12	;

0000663c <.LVL79>:
    663c:	0d 4e       	mov	r14,	r13	;

0000663e <.LVL80>:
    663e:	b0 13 80 d1 	calla	#53632		;0x0d180
    6642:	3e 40 48 e8 	mov	#-6072,	r14	;#0xe848
    6646:	5f 43       	mov.b	#1,	r15	;r3 As==01
    6648:	3c 50 24 f4 	add	#-3036,	r12	;#0xf424
    664c:	0d 63       	adc	r13		;
    664e:	b0 13 34 d1 	calla	#53556		;0x0d134
    6652:	09 4c       	mov	r12,	r9	;

00006654 <.Loc.189.1>:
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    6654:	8a 00 42 65 	mova	#25922,	r10	;0x06542
    6658:	0e 4c       	mov	r12,	r14	;
    665a:	5e 0f       	rrum	#4,	r14	;
    665c:	5e 0f       	rrum	#4,	r14	;
    665e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6660:	cc 08       	mova	r8,	r12	;
    6662:	4a 13       	calla	r10		;

00006664 <.LVL84>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    6664:	4e 49       	mov.b	r9,	r14	;
    6666:	7d 40 05 00 	mov.b	#5,	r13	;
    666a:	cc 08       	mova	r8,	r12	;
    666c:	4a 13       	calla	r10		;

0000666e <.LVL85>:
}
    666e:	28 16       	popm.a	#3,	r10	;20-bit words
    6670:	10 01       	reta			;

00006672 <sx1278SetFrequency>:
void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    6672:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006674 <.LCFI10>:
    6674:	ca 0c       	mova	r12,	r10	;
    6676:	08 4d       	mov	r13,	r8	;
    6678:	05 4e       	mov	r14,	r5	;

0000667a <.Loc.202.1>:
  uint32_t regs = (((freq + (SX1278_CLK_FREQ >> 12)) / 
    667a:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    667e:	4f 43       	clr.b	r15		;
    6680:	0c 4d       	mov	r13,	r12	;

00006682 <.LVL87>:
    6682:	3c 50 84 1e 	add	#7812,	r12	;#0x1e84
    6686:	0d 45       	mov	r5,	r13	;

00006688 <.LVL88>:
    6688:	0d 63       	adc	r13		;
    668a:	b0 13 34 d1 	calla	#53556		;0x0d134
    668e:	09 4c       	mov	r12,	r9	;
    6690:	b0 13 8c d1 	calla	#53644		;0x0d18c
    6694:	06 4c       	mov	r12,	r6	;
    6696:	07 4d       	mov	r13,	r7	;

00006698 <.Loc.205.1>:
  if ((freq >= 137000000 && freq <= 175000000) || 
    6698:	0d 48       	mov	r8,	r13	;
    669a:	3d 50 c0 8b 	add	#-29760,r13	;#0x8bc0
    669e:	0c 45       	mov	r5,	r12	;
    66a0:	3c 60 d5 f7 	addc	#-2091,	r12	;#0xf7d5
    66a4:	3e 40 43 02 	mov	#579,	r14	;#0x0243
    66a8:	0e 9c       	cmp	r12,	r14	;
    66aa:	06 28       	jnc	$+14     	;abs 0x66b8
    66ac:	0c 9e       	cmp	r14,	r12	;
    66ae:	14 20       	jnz	$+42     	;abs 0x66d8
    66b0:	3c 40 80 d5 	mov	#-10880,r12	;#0xd580
    66b4:	0c 9d       	cmp	r13,	r12	;
    66b6:	10 2c       	jc	$+34     	;abs 0x66d8

000066b8 <.L35>:
      (freq >= 410000000 && freq <= 525000000)) {
    66b8:	0d 48       	mov	r8,	r13	;
    66ba:	3d 50 80 e5 	add	#-6784,	r13	;#0xe580
    66be:	0c 45       	mov	r5,	r12	;
    66c0:	3c 60 8f e7 	addc	#-6257,	r12	;#0xe78f

000066c4 <.Loc.205.1>:
  if ((freq >= 137000000 && freq <= 175000000) || 
    66c4:	3e 40 da 06 	mov	#1754,	r14	;#0x06da
    66c8:	0e 9c       	cmp	r12,	r14	;
    66ca:	25 28       	jnc	$+76     	;abs 0x6716
    66cc:	0c 9e       	cmp	r14,	r12	;
    66ce:	04 20       	jnz	$+10     	;abs 0x66d8
    66d0:	3c 40 c0 c2 	mov	#-15680,r12	;#0xc2c0
    66d4:	0c 9d       	cmp	r13,	r12	;
    66d6:	1f 28       	jnc	$+64     	;abs 0x6716

000066d8 <.L29>:
    devp->regs.opmode |= (1 << 3);
    66d8:	fa d2 05 00 	bis.b	#8,	5(r10)	;r2 As==11

000066dc <.L33>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    66dc:	88 00 42 65 	mova	#25922,	r8	;0x06542
    66e0:	5e 4a 05 00 	mov.b	5(r10),	r14	;
    66e4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    66e6:	cc 0a       	mova	r10,	r12	;
    66e8:	48 13       	calla	r8		;

000066ea <.LVL92>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    66ea:	0c 46       	mov	r6,	r12	;
    66ec:	0d 47       	mov	r7,	r13	;
    66ee:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    66f2:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    66f6:	4e 4c       	mov.b	r12,	r14	;
    66f8:	7d 40 06 00 	mov.b	#6,	r13	;
    66fc:	cc 0a       	mova	r10,	r12	;
    66fe:	48 13       	calla	r8		;

00006700 <.LVL94>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    6700:	4e 49       	mov.b	r9,	r14	;
    6702:	7d 40 07 00 	mov.b	#7,	r13	;
    6706:	cc 0a       	mova	r10,	r12	;
    6708:	48 13       	calla	r8		;

0000670a <.LVL95>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    670a:	4e 43       	clr.b	r14		;
    670c:	7d 42       	mov.b	#8,	r13	;r2 As==11
    670e:	cc 0a       	mova	r10,	r12	;
    6710:	48 13       	calla	r8		;

00006712 <.LVL96>:
}
    6712:	55 16       	popm.a	#6,	r10	;20-bit words
    6714:	10 01       	reta			;

00006716 <.L31>:
  else if (freq >= 862000000 && freq <= 1020000000) {
    6716:	38 50 80 ec 	add	#-4992,	r8	;#0xec80
    671a:	35 60 9e cc 	addc	#-13154,r5	;#0xcc9e
    671e:	3e 40 6a 09 	mov	#2410,	r14	;#0x096a
    6722:	0e 95       	cmp	r5,	r14	;
    6724:	db 2b       	jnc	$-72     	;abs 0x66dc
    6726:	05 9e       	cmp	r14,	r5	;
    6728:	04 20       	jnz	$+10     	;abs 0x6732
    672a:	3c 40 80 e3 	mov	#-7296,	r12	;#0xe380
    672e:	0c 98       	cmp	r8,	r12	;
    6730:	d5 2b       	jnc	$-84     	;abs 0x66dc

00006732 <.L36>:
    devp->regs.opmode &= ~(1 << 3);
    6732:	fa c2 05 00 	bic.b	#8,	5(r10)	;r2 As==11
    6736:	80 00 dc 66 	mova	#26332,	r0	;0x066dc

0000673a <sx1278SetPower>:
  sx1278SetRegister(devp, RegPaConfig, pow);
    673a:	4e 4d       	mov.b	r13,	r14	;
    673c:	7d 40 09 00 	mov.b	#9,	r13	;

00006740 <.LVL98>:
    6740:	b0 13 42 65 	calla	#25922		;0x06542

00006744 <.LVL99>:
}
    6744:	10 01       	reta			;

00006746 <sx1278SetSync>:
void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    6746:	5a 14       	pushm.a	#6,	r10	;20-bit words

00006748 <.LCFI11>:
    6748:	ca 0c       	mova	r12,	r10	;
    674a:	08 4d       	mov	r13,	r8	;
    674c:	09 4e       	mov	r14,	r9	;

0000674e <.LVL104>:
  if (sync == 0) {
    674e:	0d de       	bis	r14,	r13	;

00006750 <.LVL105>:
    6750:	0d 93       	cmp	#0,	r13	;r3 As==00
    6752:	23 24       	jz	$+72     	;abs 0x679a

00006754 <.Loc.278.1>:
  reg |= devp->config->packet_config->preamble_polarity << 5;
    6754:	0e 0c       	mova	@r12,	r14	;
    6756:	3e 0e 26 00 	mova	38(r14),r14	;0x00026
    675a:	6e 4e       	mov.b	@r14,	r14	;
    675c:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00006760 <.LVL106>:
  sx1278SetRegister(devp, RegSyncConfig, reg);
    6760:	86 00 42 65 	mova	#25922,	r6	;0x06542
    6764:	7e d0 93 ff 	bis.b	#-109,	r14	;#0xff93

00006768 <.LVL107>:
    6768:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027
    676c:	46 13       	calla	r6		;

0000676e <.LVL108>:
    676e:	77 40 28 00 	mov.b	#40,	r7	;#0x0028
    6772:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

00006776 <.L41>:
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
    6776:	0c 48       	mov	r8,	r12	;
    6778:	0d 49       	mov	r9,	r13	;
    677a:	0e 45       	mov	r5,	r14	;
    677c:	0f 43       	clr	r15		;
    677e:	b0 13 dc d2 	calla	#53980		;0x0d2dc

00006782 <.Loc.293.1>:
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    6782:	4e 4c       	mov.b	r12,	r14	;
    6784:	4d 47       	mov.b	r7,	r13	;
    6786:	cc 0a       	mova	r10,	r12	;
    6788:	46 13       	calla	r6		;

0000678a <.LVL111>:
    678a:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8
    678e:	4c 47       	mov.b	r7,	r12	;
    6790:	5c 53       	inc.b	r12		;
    6792:	47 4c       	mov.b	r12,	r7	;

00006794 <.Loc.290.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    6794:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    6798:	ee 23       	jnz	$-34     	;abs 0x6776

0000679a <.L39>:
}
    679a:	55 16       	popm.a	#6,	r10	;20-bit words
    679c:	10 01       	reta			;

0000679e <sx1278ObjectInit>:
  devp->regs.opmode = 0x09;
    679e:	fc 40 09 00 	mov.b	#9,	5(r12)	;
    67a2:	05 00 

000067a4 <.Loc.507.1>:
  devp->regs.seq_config = 0x00;
    67a4:	cc 43 06 00 	mov.b	#0,	6(r12)	;r3 As==00

000067a8 <.Loc.509.1>:
  devp->state = SX1278_STOP;
    67a8:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

000067ac <.Loc.510.1>:
}
    67ac:	10 01       	reta			;

000067ae <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    67ae:	2a 14       	pushm.a	#3,	r10	;20-bit words

000067b0 <.LCFI12>:
    67b0:	06 14       	pushm.a	#1,	r6	;20-bit words

000067b2 <.LCFI13>:
    67b2:	ca 0c       	mova	r12,	r10	;
    67b4:	c8 0d       	mova	r13,	r8	;

000067b6 <.Loc.529.1>:
  
  devp->config = config;
    67b6:	7a 0d 00 00 	mova	r13,	0(r10)	;

000067ba <.Loc.531.1>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    67ba:	b0 13 8a 64 	calla	#25738		;0x0648a

000067be <.LVL115>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Add the SPI callback to the SPI config */
  config->spicfgp->end_cb = spi_callback;
    67be:	3d 08 04 00 	mova	4(r8),	r13	;
    67c2:	00 18 fd 40 	movx.a	#25654,	0(r13)	;0x06436
    67c6:	36 64 00 00 

000067ca <.Loc.538.1>:
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    67ca:	0c 08       	mova	@r8,	r12	;
    67cc:	b0 13 ae 52 	calla	#21166		;0x052ae

000067d0 <.LVL116>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, SX1278Sleep);
    67d0:	cc 0a       	mova	r10,	r12	;
    67d2:	b0 13 d4 65 	calla	#26068		;0x065d4

000067d6 <.LVL117>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    67d6:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    67da:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    67de:	cc 0a       	mova	r10,	r12	;
    67e0:	b0 13 72 66 	calla	#26226		;0x06672

000067e4 <.LVL118>:
  sx1278SetDeviation(devp, config->fdev);
    67e4:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    67e8:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    67ec:	cc 0a       	mova	r10,	r12	;
    67ee:	b0 13 36 66 	calla	#26166		;0x06636

000067f2 <.LVL119>:
  sx1278SetBitrate(devp, config->bitrate);
    67f2:	1d 48 08 00 	mov	8(r8),	r13	;
    67f6:	1e 48 0a 00 	mov	10(r8),	r14	;0x0000a
    67fa:	cc 0a       	mova	r10,	r12	;
    67fc:	b0 13 ee 65 	calla	#26094		;0x065ee

00006800 <.LVL120>:
  sx1278SetPower(devp, config->pow);
    6800:	5d 48 15 00 	mov.b	21(r8),	r13	;0x00015
    6804:	cc 0a       	mova	r10,	r12	;
    6806:	b0 13 3a 67 	calla	#26426		;0x0673a

0000680a <.LVL121>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    680a:	19 48 16 00 	mov	22(r8),	r9	;0x00016

0000680e <.LBB87>:
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    680e:	86 00 42 65 	mova	#25922,	r6	;0x06542
    6812:	0e 49       	mov	r9,	r14	;
    6814:	5e 0f       	rrum	#4,	r14	;
    6816:	5e 0f       	rrum	#4,	r14	;
    6818:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    681c:	cc 0a       	mova	r10,	r12	;
    681e:	46 13       	calla	r6		;

00006820 <.LVL123>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    6820:	4e 49       	mov.b	r9,	r14	;
    6822:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    6826:	cc 0a       	mova	r10,	r12	;
    6828:	46 13       	calla	r6		;

0000682a <.LBE87>:
  sx1278SetSync(devp, config->sync_word);
    682a:	1d 48 18 00 	mov	24(r8),	r13	;0x00018
    682e:	1e 48 1a 00 	mov	26(r8),	r14	;0x0001a
    6832:	cc 0a       	mova	r10,	r12	;
    6834:	b0 13 46 67 	calla	#26438		;0x06746

00006838 <.LVL125>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 
  Don't set SequencerStart, SequencerStop, FromTransmit, and LowPowerSelection
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x18;
    6838:	fa 40 18 00 	mov.b	#24,	6(r10)	;#0x0018
    683c:	06 00 

0000683e <.Loc.555.1>:
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    683e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    6842:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6846:	cc 0a       	mova	r10,	r12	;
    6848:	46 13       	calla	r6		;

0000684a <.LVL126>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    684a:	0c 0a       	mova	@r10,	r12	;
    684c:	38 0c 26 00 	mova	38(r12),r8	;0x00026

00006850 <.LBB89>:
  if (packet_config->format == SX1278Variable) {
    6850:	6c 48       	mov.b	@r8,	r12	;
    6852:	7c f0 03 00 	and.b	#3,	r12	;
    6856:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    6858:	3f 20       	jnz	$+128    	;abs 0x68d8

0000685a <.Loc.381.1>:
    reg |= 1 << 7;
    685a:	7f 40 80 00 	mov.b	#128,	r15	;#0x0080

0000685e <.L46>:
  reg |= packet_config->whitening << 6;
    685e:	6d 48       	mov.b	@r8,	r13	;
    6860:	0c 4d       	mov	r13,	r12	;
    6862:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    6866:	7c f0 40 00 	and.b	#64,	r12	;#0x0040

0000686a <.Loc.390.1>:
  reg |= packet_config->manchester << 5;
    686a:	0e 4d       	mov	r13,	r14	;
    686c:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    6870:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00006874 <.Loc.392.1>:
  reg |= packet_config->crc << 4;
    6874:	4c de       	bis.b	r14,	r12	;
    6876:	0e 4d       	mov	r13,	r14	;
    6878:	7e f0 10 00 	and.b	#16,	r14	;#0x0010
    687c:	4e dc       	bis.b	r12,	r14	;

0000687e <.LVL129>:
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    687e:	4e df       	bis.b	r15,	r14	;

00006880 <.LVL130>:
    6880:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

00006884 <.LVL131>:
    6884:	cc 0a       	mova	r10,	r12	;

00006886 <.LVL132>:
    6886:	46 13       	calla	r6		;

00006888 <.LVL133>:
  if (packet_config->format == SX1278Fixed) {
    6888:	6c 48       	mov.b	@r8,	r12	;
    688a:	7c f0 03 00 	and.b	#3,	r12	;
    688e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6890:	26 20       	jnz	$+78     	;abs 0x68de

00006892 <.Loc.398.1>:
        0x40 | (devp->config->length >> 8));
    6892:	0c 0a       	mova	@r10,	r12	;
    6894:	1c 4c 2c 00 	mov	44(r12),r12	;0x0002c
    6898:	b0 13 4a d2 	calla	#53834		;0x0d24a

0000689c <.Loc.397.1>:
    sx1278SetRegister(devp, RegPacketConfig2, 
    689c:	4e 4c       	mov.b	r12,	r14	;
    689e:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    68a2:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    68a6:	cc 0a       	mova	r10,	r12	;
    68a8:	46 13       	calla	r6		;

000068aa <.LVL135>:
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    68aa:	0c 0a       	mova	@r10,	r12	;
    68ac:	5e 4c 2c 00 	mov.b	44(r12),r14	;0x0002c

000068b0 <.L50>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    68b0:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    68b4:	cc 0a       	mova	r10,	r12	;
    68b6:	46 13       	calla	r6		;

000068b8 <.LBB92>:
  sx1278SetRegister(devp, RegDioMapping1, 0);
    68b8:	4e 43       	clr.b	r14		;
    68ba:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    68be:	cc 0a       	mova	r10,	r12	;
    68c0:	46 13       	calla	r6		;

000068c2 <.LVL137>:
  sx1278SetRegister(devp, RegDioMapping2, 0x40);
    68c2:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    68c6:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    68ca:	cc 0a       	mova	r10,	r12	;
    68cc:	46 13       	calla	r6		;

000068ce <.LBE92>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    68ce:	ea 43 04 00 	mov.b	#2,	4(r10)	;r3 As==10

000068d2 <.Loc.566.1>:
}
    68d2:	06 16       	popm.a	#1,	r6	;20-bit words
    68d4:	28 16       	popm.a	#3,	r10	;20-bit words
    68d6:	10 01       	reta			;

000068d8 <.L49>:
  uint8_t reg = 0x00;
    68d8:	4f 43       	clr.b	r15		;
    68da:	80 00 5e 68 	mova	#26718,	r0	;0x0685e

000068de <.L47>:
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    68de:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    68e2:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    68e6:	cc 0a       	mova	r10,	r12	;
    68e8:	46 13       	calla	r6		;

000068ea <.LVL141>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    68ea:	4e 43       	clr.b	r14		;
    68ec:	80 00 b0 68 	mova	#26800,	r0	;0x068b0

000068f0 <sx1278Stop>:
 *
 * @param[in] devp       pointer to the @p SX1278Driver object
 *
 * @api
 */
void sx1278Stop(SX1278Driver *devp) {
    68f0:	0a 14       	pushm.a	#1,	r10	;20-bit words

000068f2 <.LCFI14>:
    68f2:	ca 0c       	mova	r12,	r10	;

000068f4 <.Loc.578.1>:
  
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    68f4:	b0 13 8a 64 	calla	#25738		;0x0648a

000068f8 <.LVL143>:
#if SX1278_SHARED_SPI
  spiAcquireBus(devp->config->spip);
#endif
  /* Start device SPI interface - in case of repeated stops */
  spiStart(devp->config->spip, devp->config->spicfgp);
    68f8:	0c 0a       	mova	@r10,	r12	;
    68fa:	3d 0c 04 00 	mova	4(r12),	r13	;
    68fe:	0c 0c       	mova	@r12,	r12	;
    6900:	b0 13 ae 52 	calla	#21166		;0x052ae

00006904 <.LVL144>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, SX1278Sleep);
    6904:	cc 0a       	mova	r10,	r12	;
    6906:	b0 13 d4 65 	calla	#26068		;0x065d4

0000690a <.LVL145>:
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    690a:	fa 40 09 00 	mov.b	#9,	5(r10)	;
    690e:	05 00 

00006910 <.Loc.592.1>:
#if SX1278_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
  
  devp->state = SX1278_STOP;
    6910:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006914 <.Loc.593.1>:
}
    6914:	0a 16       	popm.a	#1,	r10	;20-bit words
    6916:	10 01       	reta			;

00006918 <sx1278FifoWriteAsync>:
  
  devp->state = SX1278_SLEEP;
}

void sx1278FifoWriteAsync(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6918:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000691a <.LCFI16>:
    691a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000691c <.LCFI17>:
    691c:	04 14       	pushm.a	#1,	r4	;20-bit words

0000691e <.LCFI18>:
    691e:	b1 00 04 00 	suba	#4,	r1	;

00006922 <.LCFI19>:
    6922:	ca 0c       	mova	r12,	r10	;
    6924:	c8 0d       	mova	r13,	r8	;

00006926 <.Loc.619.1>:
  devp->callback = cb;
    6926:	7c 0f 08 00 	mova	r15,	8(r12)	;

0000692a <.Loc.620.1>:
  palClearLine(devp->config->ss_line);
    692a:	06 0c       	mova	@r12,	r6	;
    692c:	3c 06 22 00 	mova	34(r6),	r12	;0x00022

00006930 <.LVL149>:
    6930:	c4 0c       	mova	r12,	r4	;
    6932:	00 18 74 f0 	andx.a	#4095,	r4	;0x00fff
    6936:	ff 0f 
    6938:	19 44 02 00 	mov	2(r4),	r9	;
    693c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    693e:	40 18 3c 41 	popx.w	r12		;
    6942:	40 18 3d 41 	popx.w	r13		;
    6946:	71 0e 00 00 	mova	r14,	0(r1)	;
    694a:	b0 13 8a d2 	calla	#53898		;0x0d28a

0000694e <.LVL150>:
    694e:	0d 12       	push	r13		;
    6950:	0c 12       	push	r12		;
    6952:	0c 16       	popm.a	#1,	r12	;20-bit words
    6954:	40 18 0d 4c 	movx.w	r12,	r13	;
    6958:	5c 43       	mov.b	#1,	r12	;r3 As==01
    695a:	b0 13 6a d1 	calla	#53610		;0x0d16a
    695e:	09 cc       	bic	r12,	r9	;
    6960:	84 49 02 00 	mov	r9,	2(r4)	;

00006964 <.Loc.621.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    6964:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6968:	0c 06       	mova	@r6,	r12	;
    696a:	b0 13 62 5d 	calla	#23906		;0x05d62

0000696e <.LVL152>:
  devp->config->spicfgp->end_cb = spi_callback;
    696e:	0a 0a       	mova	@r10,	r10	;

00006970 <.LVL153>:
    6970:	3c 0a 04 00 	mova	4(r10),	r12	;
    6974:	00 18 fc 40 	movx.a	#25654,	0(r12)	;0x06436
    6978:	36 64 00 00 

0000697c <.Loc.623.1>:
  spiStartSend(devp->config->spip, n, buffer);
    697c:	0e 01       	mova	@r1,	r14	;
    697e:	cd 08       	mova	r8,	r13	;
    6980:	0c 0a       	mova	@r10,	r12	;
    6982:	b0 13 d2 52 	calla	#21202		;0x052d2

00006986 <.LVL154>:
}
    6986:	a1 00 04 00 	adda	#4,	r1	;
    698a:	04 16       	popm.a	#1,	r4	;20-bit words
    698c:	06 16       	popm.a	#1,	r6	;20-bit words
    698e:	28 16       	popm.a	#3,	r10	;20-bit words
    6990:	10 01       	reta			;

00006992 <sx1278FifoWriteAsyncS>:

void sx1278FifoWriteAsyncS(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6992:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006994 <.LCFI20>:
    6994:	06 14       	pushm.a	#1,	r6	;20-bit words

00006996 <.LCFI21>:
    6996:	04 14       	pushm.a	#1,	r4	;20-bit words

00006998 <.LCFI22>:
    6998:	b1 00 04 00 	suba	#4,	r1	;

0000699c <.LCFI23>:
    699c:	ca 0c       	mova	r12,	r10	;
    699e:	c8 0d       	mova	r13,	r8	;

000069a0 <.Loc.628.1>:
  devp->callback = cb;
    69a0:	7c 0f 08 00 	mova	r15,	8(r12)	;

000069a4 <.Loc.629.1>:
  palClearLine(devp->config->ss_line);
    69a4:	06 0c       	mova	@r12,	r6	;
    69a6:	3c 06 22 00 	mova	34(r6),	r12	;0x00022

000069aa <.LVL156>:
    69aa:	c4 0c       	mova	r12,	r4	;
    69ac:	00 18 74 f0 	andx.a	#4095,	r4	;0x00fff
    69b0:	ff 0f 
    69b2:	19 44 02 00 	mov	2(r4),	r9	;
    69b6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    69b8:	40 18 3c 41 	popx.w	r12		;
    69bc:	40 18 3d 41 	popx.w	r13		;
    69c0:	71 0e 00 00 	mova	r14,	0(r1)	;
    69c4:	b0 13 8a d2 	calla	#53898		;0x0d28a

000069c8 <.LVL157>:
    69c8:	0d 12       	push	r13		;
    69ca:	0c 12       	push	r12		;
    69cc:	0c 16       	popm.a	#1,	r12	;20-bit words
    69ce:	40 18 0d 4c 	movx.w	r12,	r13	;
    69d2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    69d4:	b0 13 6a d1 	calla	#53610		;0x0d16a
    69d8:	09 cc       	bic	r12,	r9	;
    69da:	84 49 02 00 	mov	r9,	2(r4)	;

000069de <.Loc.630.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    69de:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    69e2:	0c 06       	mova	@r6,	r12	;
    69e4:	b0 13 62 5d 	calla	#23906		;0x05d62

000069e8 <.LVL159>:
  devp->config->spicfgp->end_cb = spi_callback;
    69e8:	0a 0a       	mova	@r10,	r10	;

000069ea <.LVL160>:
    69ea:	3c 0a 04 00 	mova	4(r10),	r12	;
    69ee:	00 18 fc 40 	movx.a	#25654,	0(r12)	;0x06436
    69f2:	36 64 00 00 

000069f6 <.Loc.632.1>:
  spiStartSendI(devp->config->spip, n, buffer);
    69f6:	0c 0a       	mova	@r10,	r12	;
    69f8:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    69fc:	00 00 
    69fe:	0e 01       	mova	@r1,	r14	;
    6a00:	cd 08       	mova	r8,	r13	;
    6a02:	b0 13 38 5d 	calla	#23864		;0x05d38

00006a06 <.LVL161>:
}
    6a06:	a1 00 04 00 	adda	#4,	r1	;
    6a0a:	04 16       	popm.a	#1,	r4	;20-bit words
    6a0c:	06 16       	popm.a	#1,	r6	;20-bit words
    6a0e:	28 16       	popm.a	#3,	r10	;20-bit words
    6a10:	10 01       	reta			;

00006a12 <sx1278StartTransmit>:

size_t sx1278StartTransmit(SX1278Driver * devp, size_t n, uint8_t * buffer, 
    palcallback_t pal_cb, spicallback_t spi_cb) {
    6a12:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006a14 <.LCFI24>:
    6a14:	06 14       	pushm.a	#1,	r6	;20-bit words

00006a16 <.LCFI25>:
    6a16:	04 14       	pushm.a	#1,	r4	;20-bit words

00006a18 <.LCFI26>:
    6a18:	b1 00 08 00 	suba	#8,	r1	;

00006a1c <.LCFI27>:
    6a1c:	ca 0c       	mova	r12,	r10	;
    6a1e:	c4 0d       	mova	r13,	r4	;
    6a20:	c6 0e       	mova	r14,	r6	;

00006a22 <.Loc.640.1>:
  
  /* We're in Sleep or Standby, TLS isn't started yet */
  /* Set FifoThreshold to 25% or packet size, whichever's smaller */
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6a22:	78 40 18 00 	mov.b	#24,	r8	;#0x0018
    6a26:	d8 0d       	cmpa	r13,	r8	;
    6a28:	62 28       	jnc	$+198    	;abs 0x6aee

00006a2a <.Loc.640.1>:
    6a2a:	4e 4d       	mov.b	r13,	r14	;

00006a2c <.LVL163>:
    6a2c:	7e 53       	add.b	#-1,	r14	;r3 As==11
    6a2e:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00006a32 <.L56>:
    6a32:	88 00 42 65 	mova	#25922,	r8	;0x06542
    6a36:	7d 40 35 00 	mov.b	#53,	r13	;#0x0035

00006a3a <.LVL164>:
    6a3a:	cc 0a       	mova	r10,	r12	;

00006a3c <.LVL165>:
    6a3c:	71 0f 00 00 	mova	r15,	0(r1)	;
    6a40:	48 13       	calla	r8		;

00006a42 <.LVL166>:
  /* Stop TLS */
  devp->regs.seq_config &= ~(0x80);
    6a42:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6a46:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    6a4a:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006a4e <.Loc.643.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config | 0x40);
    6a4e:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6a52:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6a56:	cc 0a       	mova	r10,	r12	;
    6a58:	48 13       	calla	r8		;

00006a5a <.LVL167>:
  /* Start TLS */
  devp->regs.seq_config |= 0x80;
    6a5a:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    6a5e:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    6a62:	ca 4e 06 00 	mov.b	r14,	6(r10)	;

00006a66 <.Loc.646.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    6a66:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    6a6a:	cc 0a       	mova	r10,	r12	;
    6a6c:	48 13       	calla	r8		;

00006a6e <.LBB99>:
  _disable_interrupts();
    6a6e:	32 c2       	dint			
    6a70:	03 43       	nop			

00006a72 <.Loc.348.3>:
  asm volatile("nop");
    6a72:	03 43       	nop			

00006a74 <.LBE99>:
  
  /* Configure FifoLevel interrupt */
  chSysLock();
  palLineEnableEventI(devp->config->dio_map[devp->config->irq_map[SX1278FifoLevel]],
    6a74:	0e 0a       	mova	@r10,	r14	;
    6a76:	5c 4e 1d 00 	mov.b	29(r14),r12	;0x0001d
    6a7a:	0d 43       	clr	r13		;
    6a7c:	08 4c       	mov	r12,	r8	;
    6a7e:	09 4d       	mov	r13,	r9	;
    6a80:	08 58       	rla	r8		;
    6a82:	09 69       	rlc	r9		;
    6a84:	08 58       	rla	r8		;
    6a86:	09 69       	rlc	r9		;
    6a88:	81 48 04 00 	mov	r8,	4(r1)	;
    6a8c:	81 49 06 00 	mov	r9,	6(r1)	;
    6a90:	00 18 5e 51 	addx.a	4(r1),	r14	;
    6a94:	04 00 
    6a96:	38 0e 2e 00 	mova	46(r14),r8	;0x0002e
    6a9a:	08 14       	pushm.a	#1,	r8	;20-bit words
    6a9c:	40 18 3c 41 	popx.w	r12		;
    6aa0:	40 18 3d 41 	popx.w	r13		;
    6aa4:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6aa8:	0d 12       	push	r13		;
    6aaa:	0c 12       	push	r12		;
    6aac:	0c 16       	popm.a	#1,	r12	;20-bit words
    6aae:	0f 01       	mova	@r1,	r15	;
    6ab0:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6ab2:	4d 4c       	mov.b	r12,	r13	;
    6ab4:	cc 08       	mova	r8,	r12	;
    6ab6:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6aba:	ff 0f 
    6abc:	b0 13 46 58 	calla	#22598		;0x05846

00006ac0 <.LBB101>:
  asm volatile("nop");
    6ac0:	03 43       	nop			

00006ac2 <.Loc.356.3>:
  _enable_interrupts();
    6ac2:	03 43       	nop			
    6ac4:	32 d2       	eint			
    6ac6:	03 43       	nop			

00006ac8 <.LBE101>:
      PAL_EVENT_MODE_FALLING_EDGE, pal_cb);
  chSysUnlock();
  /* Fill the FIFO */
  uint8_t to_write = (n > 47 ? 47 : n);
    6ac8:	79 40 2f 00 	mov.b	#47,	r9	;#0x002f
    6acc:	d9 04       	cmpa	r4,	r9	;
    6ace:	01 2c       	jc	$+4      	;abs 0x6ad2
    6ad0:	c4 09       	mova	r9,	r4	;

00006ad2 <.L57>:
  sx1278FifoWriteAsync(devp, to_write, buffer, spi_cb);
    6ad2:	3f 01 20 00 	mova	32(r1),	r15	;0x00020
    6ad6:	ce 06       	mova	r6,	r14	;
    6ad8:	cd 04       	mova	r4,	r13	;
    6ada:	cc 0a       	mova	r10,	r12	;
    6adc:	b0 13 18 69 	calla	#26904		;0x06918

00006ae0 <.LVL172>:
  return to_write;
}
    6ae0:	cc 04       	mova	r4,	r12	;
    6ae2:	a1 00 08 00 	adda	#8,	r1	;
    6ae6:	04 16       	popm.a	#1,	r4	;20-bit words
    6ae8:	06 16       	popm.a	#1,	r6	;20-bit words
    6aea:	28 16       	popm.a	#3,	r10	;20-bit words
    6aec:	10 01       	reta			;

00006aee <.L58>:
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6aee:	7e 40 17 00 	mov.b	#23,	r14	;#0x0017
    6af2:	80 00 32 6a 	mova	#27186,	r0	;0x06a32

00006af6 <blockuntil_callback>:
  chThdResumeI(trp, msg);
    6af6:	4d 43       	clr.b	r13		;
    6af8:	8c 01 6e 15 	mova	#71022,	r12	;0x1156e
    6afc:	b0 13 fa 46 	calla	#18170		;0x046fa

00006b00 <.LBE37>:

static void blockuntil_callback(void) {
  osalSysLockFromISR();
  osalThreadResumeI(&tr, MSG_OK);
  osalSysUnlockFromISR();
}
    6b00:	10 01       	reta			;

00006b02 <sx1212SetRegister.isra.0>:
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1212SetRegister(SX1212Driver *devp, uint8_t reg, 
    6b02:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006b04 <.LCFI1>:
    6b04:	ca 0c       	mova	r12,	r10	;
    6b06:	47 4d       	mov.b	r13,	r7	;
    6b08:	49 4e       	mov.b	r14,	r9	;

00006b0a <.LVL7>:
  osalDbgAssert(reg != 20, "setting read-only registers");
  
  /* 00xxxxx0 */
  reg = (reg << 1);
  
  spiSelectI(devp->config->spip);
    6b0a:	0c 0c       	mova	@r12,	r12	;
    6b0c:	0c 0c       	mova	@r12,	r12	;
    6b0e:	b0 13 22 5c 	calla	#23586		;0x05c22

00006b12 <.LVL8>:
  spiPolledExchange(devp->config->spip, reg);
    6b12:	0c 0a       	mova	@r10,	r12	;
    6b14:	88 00 62 5d 	mova	#23906,	r8	;0x05d62
    6b18:	0d 47       	mov	r7,	r13	;
    6b1a:	0d 5d       	rla	r13		;
    6b1c:	0c 0c       	mova	@r12,	r12	;
    6b1e:	48 13       	calla	r8		;

00006b20 <.LVL9>:
  reg = spiPolledExchange(devp->config->spip, value);
    6b20:	0c 0a       	mova	@r10,	r12	;
    6b22:	4d 49       	mov.b	r9,	r13	;
    6b24:	0c 0c       	mova	@r12,	r12	;
    6b26:	48 13       	calla	r8		;

00006b28 <.LVL10>:
    6b28:	49 4c       	mov.b	r12,	r9	;

00006b2a <.LVL11>:
  spiUnselectI(devp->config->spip);
    6b2a:	0c 0a       	mova	@r10,	r12	;
    6b2c:	0c 0c       	mova	@r12,	r12	;
    6b2e:	b0 13 66 5c 	calla	#23654		;0x05c66

00006b32 <.LVL12>:
  
  return reg;
}
    6b32:	4c 49       	mov.b	r9,	r12	;
    6b34:	37 16       	popm.a	#4,	r10	;20-bit words
    6b36:	10 01       	reta			;

00006b38 <sx1212SetMode>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1212SetMode(SX1212Driver *devp, SX1212ModeConstants mode) {
    6b38:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006b3a <.LCFI2>:
    6b3a:	ca 0c       	mova	r12,	r10	;

00006b3c <.Loc.610.1>:
  
  devp->regs.MCParam0 = (devp->regs.MCParam0 & 0x1F) | mode;
    6b3c:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    6b40:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    6b44:	4e dd       	bis.b	r13,	r14	;
    6b46:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

00006b4a <.Loc.611.1>:
  sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    6b4a:	4d 43       	clr.b	r13		;

00006b4c <.LVL14>:
    6b4c:	b0 13 02 6b 	calla	#27394		;0x06b02

00006b50 <.LVL15>:
}
    6b50:	0a 16       	popm.a	#1,	r10	;20-bit words
    6b52:	10 01       	reta			;

00006b54 <sx1212Reset.isra.2>:
static void sx1212Reset(SX1212Driver *devp) {
    6b54:	2a 14       	pushm.a	#3,	r10	;20-bit words

00006b56 <.LCFI3>:
    6b56:	06 14       	pushm.a	#1,	r6	;20-bit words

00006b58 <.LCFI4>:
    6b58:	04 14       	pushm.a	#1,	r4	;20-bit words

00006b5a <.LCFI5>:
    6b5a:	c6 0c       	mova	r12,	r6	;

00006b5c <.Loc.591.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    6b5c:	0c 0c       	mova	@r12,	r12	;
    6b5e:	3a 0c 22 00 	mova	34(r12),r10	;0x00022
    6b62:	0a 14       	pushm.a	#1,	r10	;20-bit words
    6b64:	40 18 3c 41 	popx.w	r12		;
    6b68:	40 18 3d 41 	popx.w	r13		;
    6b6c:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6b70:	0d 12       	push	r13		;
    6b72:	0c 12       	push	r12		;
    6b74:	0c 16       	popm.a	#1,	r12	;20-bit words
    6b76:	40 18 0d 4c 	movx.w	r12,	r13	;
    6b7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6b7c:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6b80:	88 00 56 57 	mova	#22358,	r8	;0x05756
    6b84:	7e 40 06 00 	mov.b	#6,	r14	;
    6b88:	0d 4c       	mov	r12,	r13	;
    6b8a:	cc 0a       	mova	r10,	r12	;
    6b8c:	00 18 7c f0 	andx.a	#4095,	r12	;0x00fff
    6b90:	ff 0f 
    6b92:	48 13       	calla	r8		;

00006b94 <.LVL18>:
  palSetLine(devp->config->reset_line);
    6b94:	0c 06       	mova	@r6,	r12	;
    6b96:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6b9a:	ca 0c       	mova	r12,	r10	;
    6b9c:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6ba0:	ff 0f 
    6ba2:	19 4a 02 00 	mov	2(r10),	r9	;
    6ba6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6ba8:	40 18 3c 41 	popx.w	r12		;
    6bac:	40 18 3d 41 	popx.w	r13		;
    6bb0:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6bb4:	0d 12       	push	r13		;
    6bb6:	0c 12       	push	r12		;
    6bb8:	0c 16       	popm.a	#1,	r12	;20-bit words
    6bba:	40 18 0d 4c 	movx.w	r12,	r13	;
    6bbe:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6bc0:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6bc4:	0c d9       	bis	r9,	r12	;
    6bc6:	8a 4c 02 00 	mov	r12,	2(r10)	;

00006bca <.LBB39>:
  chThdSleep(time);
    6bca:	84 00 10 47 	mova	#18192,	r4	;0x04710
    6bce:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6bd0:	44 13       	calla	r4		;

00006bd2 <.LBE39>:
  palClearLine(devp->config->reset_line);
    6bd2:	0c 06       	mova	@r6,	r12	;
    6bd4:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    6bd8:	ca 0c       	mova	r12,	r10	;
    6bda:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    6bde:	ff 0f 
    6be0:	16 4a 02 00 	mov	2(r10),	r6	;
    6be4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6be6:	40 18 3c 41 	popx.w	r12		;
    6bea:	40 18 3d 41 	popx.w	r13		;
    6bee:	b0 13 8a d2 	calla	#53898		;0x0d28a
    6bf2:	0d 12       	push	r13		;
    6bf4:	0c 12       	push	r12		;
    6bf6:	0c 16       	popm.a	#1,	r12	;20-bit words
    6bf8:	40 18 09 4c 	movx.w	r12,	r9	;
    6bfc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6bfe:	0d 49       	mov	r9,	r13	;
    6c00:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6c04:	06 cc       	bic	r12,	r6	;
    6c06:	8a 46 02 00 	mov	r6,	2(r10)	;

00006c0a <.Loc.595.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLDOWN);
    6c0a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6c0c:	0d 49       	mov	r9,	r13	;
    6c0e:	b0 13 6a d1 	calla	#53610		;0x0d16a
    6c12:	6e 42       	mov.b	#4,	r14	;r2 As==10
    6c14:	0d 4c       	mov	r12,	r13	;
    6c16:	cc 0a       	mova	r10,	r12	;
    6c18:	48 13       	calla	r8		;

00006c1a <.LBB41>:
    6c1a:	7c 40 05 00 	mov.b	#5,	r12	;
    6c1e:	44 13       	calla	r4		;

00006c20 <.LBE41>:
}
    6c20:	04 16       	popm.a	#1,	r4	;20-bit words
    6c22:	06 16       	popm.a	#1,	r6	;20-bit words
    6c24:	28 16       	popm.a	#3,	r10	;20-bit words
    6c26:	10 01       	reta			;

00006c28 <irq_block_with_timeout.isra.3>:
static msg_t irq_block_with_timeout(SX1212Driver *devp, ioline_t irq, 
    6c28:	3a 14       	pushm.a	#4,	r10	;20-bit words

00006c2a <.LCFI6>:
    6c2a:	07 4d       	mov	r13,	r7	;

00006c2c <.LBB53>:
  _disable_interrupts();
    6c2c:	32 c2       	dint			
    6c2e:	03 43       	nop			

00006c30 <.Loc.348.3>:
  asm volatile("nop");
    6c30:	03 43       	nop			

00006c32 <.LBE53>:
  palLineEnableEventI(irq, PAL_EVENT_MODE_RISING_EDGE, blockuntil_callback); 
    6c32:	c8 0c       	mova	r12,	r8	;
    6c34:	00 18 78 f0 	andx.a	#4095,	r8	;0x00fff
    6c38:	ff 0f 
    6c3a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    6c3c:	40 18 3c 41 	popx.w	r12		;
    6c40:	40 18 3d 41 	popx.w	r13		;

00006c44 <.LVL30>:
    6c44:	b0 13 8a d2 	calla	#53898		;0x0d28a

00006c48 <.LVL31>:
    6c48:	0d 12       	push	r13		;
    6c4a:	0c 12       	push	r12		;
    6c4c:	0a 16       	popm.a	#1,	r10	;20-bit words
    6c4e:	0a 14       	pushm.a	#1,	r10	;20-bit words
    6c50:	40 18 3c 41 	popx.w	r12		;
    6c54:	40 18 3d 41 	popx.w	r13		;
    6c58:	49 4c       	mov.b	r12,	r9	;
    6c5a:	8f 00 f6 6a 	mova	#27382,	r15	;0x06af6
    6c5e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    6c60:	4d 4c       	mov.b	r12,	r13	;
    6c62:	cc 08       	mova	r8,	r12	;
    6c64:	b0 13 46 58 	calla	#22598		;0x05846

00006c68 <.LVL32>:
  if (palReadLine(irq)) {
    6c68:	40 18 0d 4a 	movx.w	r10,	r13	;
    6c6c:	2c 48       	mov	@r8,	r12	;
    6c6e:	b0 13 72 d2 	calla	#53874		;0x0d272
    6c72:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    6c76:	0f 24       	jz	$+32     	;abs 0x6c96

00006c78 <.Loc.243.1>:
    suspend_result = MSG_OK;
    6c78:	01 18 c2 43 	movx.a	#0,	&0x1156a;r3 As==00
    6c7c:	6a 15 

00006c7e <.L8>:
  palLineDisableEventI(irq);
    6c7e:	4d 49       	mov.b	r9,	r13	;
    6c80:	cc 08       	mova	r8,	r12	;
    6c82:	b0 13 34 59 	calla	#22836		;0x05934

00006c86 <.LBB56>:
  asm volatile("nop");
    6c86:	03 43       	nop			

00006c88 <.Loc.356.3>:
  _enable_interrupts();
    6c88:	03 43       	nop			
    6c8a:	32 d2       	eint			
    6c8c:	03 43       	nop			

00006c8e <.LBE56>:
}
    6c8e:	2c 01 6a 15 	mova	&71018,	r12	;0x1156a
    6c92:	37 16       	popm.a	#4,	r10	;20-bit words
    6c94:	10 01       	reta			;

00006c96 <.L7>:
  return chThdSuspendTimeoutS(trp, timeout);
    6c96:	0d 47       	mov	r7,	r13	;
    6c98:	8c 01 6e 15 	mova	#71022,	r12	;0x1156e
    6c9c:	b0 13 e2 46 	calla	#18146		;0x046e2

00006ca0 <.LBE59>:
    suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    6ca0:	61 0c 6a 15 	mova	r12,	&71018	; 0x1156a
    6ca4:	80 00 7e 6c 	mova	#27774,	r0	;0x06c7e

00006ca8 <spi_mode_config>:
  devp->config->spicfgp->end_cb = NULL;
    6ca8:	0c 0c       	mova	@r12,	r12	;

00006caa <.LVL38>:
    6caa:	3e 0c 04 00 	mova	4(r12),	r14	;
    6cae:	00 18 ce 43 	movx.a	#0,	0(r14)	;r3 As==00
    6cb2:	00 00 

00006cb4 <.Loc.66.1>:
  devp->config->spip->regs->ctlw0 &= ~UCMODE1;
    6cb4:	0c 0c       	mova	@r12,	r12	;
    6cb6:	3c 0c 0c 00 	mova	12(r12),r12	;0x0000c
    6cba:	bc f0 ff fb 	and	#-1025,	0(r12)	;#0xfbff
    6cbe:	00 00 

00006cc0 <.Loc.67.1>:
}
    6cc0:	10 01       	reta			;

00006cc2 <sx1212SetBitrate>:
void sx1212SetBitrate(SX1212Driver *devp, uint32_t rate) {
    6cc2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006cc4 <.LCFI8>:
    6cc4:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00006cc8 <.LCFI9>:
    6cc8:	c6 0c       	mova	r12,	r6	;

00006cca <.Loc.422.1>:
  rate = (SX1212_CLK_FREQ >> 1)/rate;
    6cca:	88 00 34 d1 	mova	#53556,	r8	;0x0d134
    6cce:	0f 4e       	mov	r14,	r15	;
    6cd0:	0e 4d       	mov	r13,	r14	;
    6cd2:	3c 40 00 a8 	mov	#-22528,r12	;#0xa800

00006cd6 <.LVL48>:
    6cd6:	7d 40 61 00 	mov.b	#97,	r13	;#0x0061

00006cda <.LVL49>:
    6cda:	48 13       	calla	r8		;

00006cdc <.LVL50>:
    6cdc:	0a 4c       	mov	r12,	r10	;
    6cde:	09 4d       	mov	r13,	r9	;

00006ce0 <.LVL51>:
  if (rate - 1 <= 255) {
    6ce0:	3c 53       	add	#-1,	r12	;r3 As==11
    6ce2:	07 4d       	mov	r13,	r7	;
    6ce4:	37 63       	addc	#-1,	r7	;r3 As==11
    6ce6:	07 93       	cmp	#0,	r7	;r3 As==00
    6ce8:	13 20       	jnz	$+40     	;abs 0x6d10
    6cea:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    6cee:	0d 9c       	cmp	r12,	r13	;
    6cf0:	0f 28       	jnc	$+32     	;abs 0x6d10

00006cf2 <.Loc.425.1>:
    sx1212SetRegister(devp, MCParam3, (rate & 0x00FF));
    6cf2:	88 00 02 6b 	mova	#27394,	r8	;0x06b02
    6cf6:	4e 4a       	mov.b	r10,	r14	;
    6cf8:	7d 40 03 00 	mov.b	#3,	r13	;
    6cfc:	cc 06       	mova	r6,	r12	;
    6cfe:	48 13       	calla	r8		;

00006d00 <.LVL52>:
    sx1212SetRegister(devp, MCParam4, 0);
    6d00:	4e 47       	mov.b	r7,	r14	;
    6d02:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6d04:	cc 06       	mova	r6,	r12	;
    6d06:	48 13       	calla	r8		;

00006d08 <.L14>:
}
    6d08:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    6d0c:	64 16       	popm.a	#7,	r10	;20-bit words
    6d0e:	10 01       	reta			;

00006d10 <.L15>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    6d10:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    6d14:	4f 43       	clr.b	r15		;
    6d16:	0c 4a       	mov	r10,	r12	;
    6d18:	0d 49       	mov	r9,	r13	;
    6d1a:	48 13       	calla	r8		;
    6d1c:	05 4c       	mov	r12,	r5	;
    6d1e:	15 53       	inc	r5		;

00006d20 <.LBE64>:
    uint8_t bestd = 0;
    6d20:	48 43       	clr.b	r8		;

00006d22 <.Loc.429.1>:
    uint8_t bestc = 0;
    6d22:	07 48       	mov	r8,	r7	;

00006d24 <.LBB65>:
      err = rate - (tmp * i);
    6d24:	84 00 0a d3 	mova	#54026,	r4	;0x0d30a

00006d28 <.Loc.442.1>:
      if (err == 0 || i*i > rate) break;
    6d28:	81 4a 08 00 	mov	r10,	8(r1)	;

00006d2c <.L18>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    6d2c:	7c 40 5c 00 	mov.b	#92,	r12	;#0x005c
    6d30:	0c 95       	cmp	r5,	r12	;
    6d32:	0d 2c       	jc	$+28     	;abs 0x6d4e

00006d34 <.L20>:
    sx1212SetRegister(devp, MCParam3, bestc);
    6d34:	8a 00 02 6b 	mova	#27394,	r10	;0x06b02

00006d38 <.LVL59>:
    6d38:	4e 47       	mov.b	r7,	r14	;
    6d3a:	7d 40 03 00 	mov.b	#3,	r13	;
    6d3e:	cc 06       	mova	r6,	r12	;
    6d40:	4a 13       	calla	r10		;

00006d42 <.LVL60>:
    sx1212SetRegister(devp, MCParam4, bestd);
    6d42:	4e 48       	mov.b	r8,	r14	;
    6d44:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6d46:	cc 06       	mova	r6,	r12	;
    6d48:	4a 13       	calla	r10		;

00006d4a <.LBE63>:
}
    6d4a:	80 00 08 6d 	mova	#27912,	r0	;0x06d08

00006d4e <.L22>:
      tmp = rate / i;
    6d4e:	0e 45       	mov	r5,	r14	;
    6d50:	0f 43       	clr	r15		;
    6d52:	0c 4a       	mov	r10,	r12	;
    6d54:	0d 49       	mov	r9,	r13	;
    6d56:	b0 13 34 d1 	calla	#53556		;0x0d134

00006d5a <.Loc.437.1>:
      err = rate - (tmp * i);
    6d5a:	4e 4c       	mov.b	r12,	r14	;
    6d5c:	4f 45       	mov.b	r5,	r15	;
    6d5e:	0d 4f       	mov	r15,	r13	;
    6d60:	0c 4e       	mov	r14,	r12	;
    6d62:	71 0e 04 00 	mova	r14,	4(r1)	;
    6d66:	71 0f 00 00 	mova	r15,	0(r1)	;
    6d6a:	44 13       	calla	r4		;
    6d6c:	4d 4a       	mov.b	r10,	r13	;
    6d6e:	4d 8c       	sub.b	r12,	r13	;
    6d70:	4c 4d       	mov.b	r13,	r12	;
    6d72:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006d76 <.LVL65>:
      if (err < besterr) {
    6d76:	3e 01 04 00 	mova	4(r1),	r14	;
    6d7a:	0f 01       	mova	@r1,	r15	;
    6d7c:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    6d7e:	06 24       	jz	$+14     	;abs 0x6d8c
    6d80:	7f 53       	add.b	#-1,	r15	;r3 As==11
    6d82:	47 4f       	mov.b	r15,	r7	;

00006d84 <.LVL66>:
        bestd = tmp - 1;
    6d84:	7e 53       	add.b	#-1,	r14	;r3 As==11
    6d86:	48 4e       	mov.b	r14,	r8	;

00006d88 <.LVL67>:
      if (err == 0 || i*i > rate) break;
    6d88:	0d 93       	cmp	#0,	r13	;r3 As==00
    6d8a:	d4 27       	jz	$-86     	;abs 0x6d34

00006d8c <.L19>:
    6d8c:	0d 45       	mov	r5,	r13	;
    6d8e:	0c 45       	mov	r5,	r12	;

00006d90 <.LVL69>:
    6d90:	44 13       	calla	r4		;
    6d92:	4d 43       	clr.b	r13		;
    6d94:	0d 99       	cmp	r9,	r13	;
    6d96:	03 20       	jnz	$+8      	;abs 0x6d9e
    6d98:	81 9c 08 00 	cmp	r12,	8(r1)	;
    6d9c:	cb 2b       	jnc	$-104    	;abs 0x6d34

00006d9e <.L24>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    6d9e:	15 53       	inc	r5		;
    6da0:	80 00 2c 6d 	mova	#27948,	r0	;0x06d2c

00006da4 <sx1212SetDeviation>:
void sx1212SetDeviation(SX1212Driver *devp, uint32_t fdev) {
    6da4:	0a 14       	pushm.a	#1,	r10	;20-bit words

00006da6 <.LCFI10>:
    6da6:	08 14       	pushm.a	#1,	r8	;20-bit words

00006da8 <.LCFI11>:
    6da8:	c8 0c       	mova	r12,	r8	;
    6daa:	0f 4e       	mov	r14,	r15	;
    6dac:	0e 4d       	mov	r13,	r14	;

00006dae <.LVL73>:
  uint16_t regs = ((SX1212_CLK_FREQ >> 5) + (fdev >> 1))/ fdev;
    6dae:	0a 4d       	mov	r13,	r10	;
    6db0:	0b 4f       	mov	r15,	r11	;
    6db2:	12 c3       	clrc			
    6db4:	0b 10       	rrc	r11		;
    6db6:	0a 10       	rrc	r10		;
    6db8:	0c 4a       	mov	r10,	r12	;

00006dba <.LVL74>:
    6dba:	3c 50 80 1a 	add	#6784,	r12	;#0x1a80
    6dbe:	0d 4b       	mov	r11,	r13	;

00006dc0 <.LVL75>:
    6dc0:	3d 60 06 00 	addc	#6,	r13	;
    6dc4:	b0 13 34 d1 	calla	#53556		;0x0d134

00006dc8 <.LVL76>:
  sx1212SetRegister(devp, MCParam2, regs - 1);
    6dc8:	4e 4c       	mov.b	r12,	r14	;
    6dca:	7e 53       	add.b	#-1,	r14	;r3 As==11
    6dcc:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6dce:	cc 08       	mova	r8,	r12	;
    6dd0:	b0 13 02 6b 	calla	#27394		;0x06b02

00006dd4 <.LVL77>:
}
    6dd4:	08 16       	popm.a	#1,	r8	;20-bit words
    6dd6:	0a 16       	popm.a	#1,	r10	;20-bit words
    6dd8:	10 01       	reta			;

00006dda <sx1212SetFrequency>:
void sx1212SetFrequency(SX1212Driver *devp, uint32_t freq) {
    6dda:	6a 14       	pushm.a	#7,	r10	;20-bit words

00006ddc <.LCFI12>:
    6ddc:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00006de0 <.LCFI13>:
    6de0:	c4 0c       	mova	r12,	r4	;
    6de2:	0a 4d       	mov	r13,	r10	;
    6de4:	05 4e       	mov	r14,	r5	;

00006de6 <.LVL79>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    6de6:	0c 4d       	mov	r13,	r12	;

00006de8 <.LVL80>:
    6de8:	0d 4e       	mov	r14,	r13	;

00006dea <.LVL81>:
    6dea:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    6dee:	81 4c 00 00 	mov	r12,	0(r1)	;
    6df2:	81 4d 02 00 	mov	r13,	2(r1)	;

00006df6 <.LVL83>:
    6df6:	08 4c       	mov	r12,	r8	;
    6df8:	09 4d       	mov	r13,	r9	;

00006dfa <.LBB71>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    6dfa:	4e 43       	clr.b	r14		;

00006dfc <.LBE71>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    6dfc:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    6e00:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd

00006e04 <.L33>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    6e04:	0f 48       	mov	r8,	r15	;
    6e06:	0f dc       	bis	r12,	r15	;
    6e08:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    6e0c:	b1 24       	jz	$+356    	;abs 0x6f70

00006e0e <.L36>:
  while((u & 1) == 0)
    6e0e:	0f 48       	mov	r8,	r15	;
    6e10:	5f f3       	and.b	#1,	r15	;r3 As==01
    6e12:	0f 93       	cmp	#0,	r15	;r3 As==00
    6e14:	b6 24       	jz	$+366    	;abs 0x6f82

00006e16 <.L39>:
    while ((v & 1) == 0)
    6e16:	0f 4c       	mov	r12,	r15	;
    6e18:	5f f3       	and.b	#1,	r15	;r3 As==01
    6e1a:	0f 93       	cmp	#0,	r15	;r3 As==00
    6e1c:	b7 24       	jz	$+368    	;abs 0x6f8c

00006e1e <.Loc.395.1>:
    if (u > v) {
    6e1e:	0d 99       	cmp	r9,	r13	;
    6e20:	0a 28       	jnc	$+22     	;abs 0x6e36
    6e22:	09 9d       	cmp	r13,	r9	;
    6e24:	02 20       	jnz	$+6      	;abs 0x6e2a
    6e26:	0c 98       	cmp	r8,	r12	;
    6e28:	06 28       	jnc	$+14     	;abs 0x6e36

00006e2a <.L64>:
    6e2a:	06 4c       	mov	r12,	r6	;
    6e2c:	07 4d       	mov	r13,	r7	;
    6e2e:	0c 48       	mov	r8,	r12	;

00006e30 <.LVL86>:
    6e30:	0d 49       	mov	r9,	r13	;
    6e32:	08 46       	mov	r6,	r8	;

00006e34 <.LVL87>:
    6e34:	09 47       	mov	r7,	r9	;

00006e36 <.L42>:
    v = v - u;
    6e36:	06 48       	mov	r8,	r6	;
    6e38:	07 49       	mov	r9,	r7	;
    6e3a:	40 18 06 8c 	subx.w	r12,	r6	;
    6e3e:	40 18 07 7d 	subcx.w	r13,	r7	;

00006e42 <.LVL89>:
  } while (v != 0);
    6e42:	0f 46       	mov	r6,	r15	;
    6e44:	0f d7       	bis	r7,	r15	;
    6e46:	0f 93       	cmp	#0,	r15	;r3 As==00
    6e48:	a8 20       	jnz	$+338    	;abs 0x6f9a

00006e4a <.Loc.403.1>:
  return u << shift;
    6e4a:	0f 43       	clr	r15		;
    6e4c:	b0 13 b4 d1 	calla	#53684		;0x0d1b4

00006e50 <.LVL90>:
    6e50:	81 4c 08 00 	mov	r12,	8(r1)	;
    6e54:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006e58 <.LBE75>:
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
    6e58:	0e 4c       	mov	r12,	r14	;
    6e5a:	0f 4d       	mov	r13,	r15	;
    6e5c:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    6e60:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    6e64:	b0 13 34 d1 	calla	#53556		;0x0d134
    6e68:	81 4c 04 00 	mov	r12,	4(r1)	;
    6e6c:	81 4d 06 00 	mov	r13,	6(r1)	;

00006e70 <.L45>:
  while (r_mult - (75 * i) > 169) {
    6e70:	0d 93       	cmp	#0,	r13	;r3 As==00
    6e72:	99 20       	jnz	$+308    	;abs 0x6fa6
    6e74:	7e 40 a9 00 	mov.b	#169,	r14	;#0x00a9
    6e78:	0e 9c       	cmp	r12,	r14	;
    6e7a:	95 28       	jnc	$+300    	;abs 0x6fa6

00006e7c <.LVL94>:
  r = r_mult - 1;
    6e7c:	47 4c       	mov.b	r12,	r7	;
    6e7e:	49 47       	mov.b	r7,	r9	;
    6e80:	79 53       	add.b	#-1,	r9	;r3 As==11

00006e82 <.L72>:
    r += r_mult;
    6e82:	39 f0 ff 00 	and	#255,	r9	;#0x00ff

00006e86 <.LVL96>:
  while (r < 64 || r > 169) {
    6e86:	4c 49       	mov.b	r9,	r12	;
    6e88:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0
    6e8c:	7d 40 69 00 	mov.b	#105,	r13	;#0x0069
    6e90:	4d 9c       	cmp.b	r12,	r13	;
    6e92:	8e 28       	jnc	$+286    	;abs 0x6fb0

00006e94 <.Loc.511.1>:
  r -= r_mult;
    6e94:	49 87       	sub.b	r7,	r9	;

00006e96 <.LVL97>:
    6e96:	39 f0 ff 00 	and	#255,	r9	;#0x00ff

00006e9a <.LVL98>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    6e9a:	86 00 34 d1 	mova	#53556,	r6	;0x0d134

00006e9e <.L50>:
    r += r_mult;
    6e9e:	4c 49       	mov.b	r9,	r12	;
    6ea0:	4c 57       	add.b	r7,	r12	;
    6ea2:	49 4c       	mov.b	r12,	r9	;

00006ea4 <.LVL100>:
  } while (r < 64 || r > 169 || s > p);
    6ea4:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0

00006ea8 <.LVL101>:
    6ea8:	7e 40 69 00 	mov.b	#105,	r14	;#0x0069
    6eac:	4e 9c       	cmp.b	r12,	r14	;
    6eae:	f7 2b       	jnc	$-16     	;abs 0x6e9e

00006eb0 <.Loc.514.1>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    6eb0:	1e 41 08 00 	mov	8(r1),	r14	;
    6eb4:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    6eb8:	2c 41       	mov	@r1,	r12	;

00006eba <.LVL102>:
    6eba:	1d 41 02 00 	mov	2(r1),	r13	;
    6ebe:	46 13       	calla	r6		;
    6ec0:	0e 49       	mov	r9,	r14	;
    6ec2:	1e 53       	inc	r14		;
    6ec4:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    6ec8:	0f 7f       	subc	r15,	r15	;
    6eca:	3f e3       	inv	r15		;
    6ecc:	b0 13 20 d3 	calla	#54048		;0x0d320
    6ed0:	1e 41 04 00 	mov	4(r1),	r14	;
    6ed4:	1f 41 06 00 	mov	6(r1),	r15	;
    6ed8:	46 13       	calla	r6		;
    6eda:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

00006ede <.Loc.515.1>:
    p = (temp / 75) - 1;
    6ede:	7e 40 4b 00 	mov.b	#75,	r14	;#0x004b
    6ee2:	4f 43       	clr.b	r15		;
    6ee4:	46 13       	calla	r6		;
    6ee6:	48 4c       	mov.b	r12,	r8	;
    6ee8:	78 53       	add.b	#-1,	r8	;r3 As==11
    6eea:	4c 48       	mov.b	r8,	r12	;

00006eec <.Loc.516.1>:
    s = temp - ((p+1)*75);
    6eec:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    6ef0:	1c 53       	inc	r12		;
    6ef2:	b0 13 0a d3 	calla	#54026		;0x0d30a
    6ef6:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6efa:	4d 8c       	sub.b	r12,	r13	;

00006efc <.Loc.517.1>:
  } while (r < 64 || r > 169 || s > p);
    6efc:	48 9d       	cmp.b	r13,	r8	;
    6efe:	cf 2b       	jnc	$-96     	;abs 0x6e9e

00006f00 <.Loc.522.1>:
  sx1212SetRegister(devp, MCParam6, 116);
    6f00:	88 00 02 6b 	mova	#27394,	r8	;0x06b02
    6f04:	7e 40 74 00 	mov.b	#116,	r14	;#0x0074
    6f08:	7d 40 06 00 	mov.b	#6,	r13	;
    6f0c:	cc 04       	mova	r4,	r12	;
    6f0e:	48 13       	calla	r8		;

00006f10 <.LVL108>:
  sx1212SetRegister(devp, MCParam7, 49);
    6f10:	7e 40 31 00 	mov.b	#49,	r14	;#0x0031
    6f14:	7d 40 07 00 	mov.b	#7,	r13	;
    6f18:	cc 04       	mova	r4,	r12	;
    6f1a:	48 13       	calla	r8		;

00006f1c <.LVL109>:
  sx1212SetRegister(devp, MCParam8, 20);
    6f1c:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    6f20:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6f22:	cc 04       	mova	r4,	r12	;
    6f24:	48 13       	calla	r8		;

00006f26 <.LVL110>:
  if (freq >= 300000000 && freq <= 330000000) {
    6f26:	0c 4a       	mov	r10,	r12	;
    6f28:	3c 50 00 5d 	add	#23808,	r12	;#0x5d00
    6f2c:	0d 45       	mov	r5,	r13	;
    6f2e:	3d 60 1e ee 	addc	#-4578,	r13	;#0xee1e
    6f32:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    6f36:	0e 9d       	cmp	r13,	r14	;
    6f38:	3e 28       	jnc	$+126    	;abs 0x6fb6
    6f3a:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    6f3e:	04 20       	jnz	$+10     	;abs 0x6f48
    6f40:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    6f44:	0e 9c       	cmp	r12,	r14	;
    6f46:	37 28       	jnc	$+112    	;abs 0x6fb6

00006f48 <.L66>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    6f48:	5a 44 04 00 	mov.b	4(r4),	r10	;
    6f4c:	7a f0 e0 ff 	and.b	#-32,	r10	;#0xffe0

00006f50 <.L76>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    6f50:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    6f54:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072

00006f58 <.L74>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    6f58:	46 13       	calla	r6		;
    6f5a:	4e 4a       	mov.b	r10,	r14	;

00006f5c <.L73>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    6f5c:	4e dc       	bis.b	r12,	r14	;

00006f5e <.Loc.553.1>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    6f5e:	c4 4e 04 00 	mov.b	r14,	4(r4)	;

00006f62 <.Loc.555.1>:
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    6f62:	4d 43       	clr.b	r13		;
    6f64:	cc 04       	mova	r4,	r12	;
    6f66:	48 13       	calla	r8		;

00006f68 <.L32>:
}
    6f68:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    6f6c:	64 16       	popm.a	#7,	r10	;20-bit words
    6f6e:	10 01       	reta			;

00006f70 <.L34>:
    u >>= 1;
    6f70:	12 c3       	clrc			
    6f72:	09 10       	rrc	r9		;
    6f74:	08 10       	rrc	r8		;

00006f76 <.Loc.385.1>:
    v >>= 1;
    6f76:	12 c3       	clrc			
    6f78:	0d 10       	rrc	r13		;
    6f7a:	0c 10       	rrc	r12		;

00006f7c <.Loc.383.1>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    6f7c:	1e 53       	inc	r14		;
    6f7e:	80 00 04 6e 	mova	#28164,	r0	;0x06e04

00006f82 <.L37>:
    u >>= 1;
    6f82:	12 c3       	clrc			
    6f84:	09 10       	rrc	r9		;
    6f86:	08 10       	rrc	r8		;
    6f88:	80 00 0e 6e 	mova	#28174,	r0	;0x06e0e

00006f8c <.L40>:
      v >>= 1;
    6f8c:	06 4c       	mov	r12,	r6	;
    6f8e:	07 4d       	mov	r13,	r7	;
    6f90:	12 c3       	clrc			
    6f92:	07 10       	rrc	r7		;
    6f94:	06 10       	rrc	r6		;

00006f96 <.LVL119>:
    6f96:	0c 48       	mov	r8,	r12	;
    6f98:	0d 49       	mov	r9,	r13	;

00006f9a <.L44>:
    6f9a:	08 4c       	mov	r12,	r8	;
    6f9c:	09 4d       	mov	r13,	r9	;
    6f9e:	0c 46       	mov	r6,	r12	;
    6fa0:	0d 47       	mov	r7,	r13	;
    6fa2:	80 00 16 6e 	mova	#28182,	r0	;0x06e16

00006fa6 <.L46>:
    6fa6:	3c 50 b5 ff 	add	#-75,	r12	;#0xffb5
    6faa:	3d 63       	addc	#-1,	r13	;r3 As==11
    6fac:	80 00 70 6e 	mova	#28272,	r0	;0x06e70

00006fb0 <.L49>:
    r += r_mult;
    6fb0:	49 57       	add.b	r7,	r9	;

00006fb2 <.LVL123>:
    6fb2:	80 00 82 6e 	mova	#28290,	r0	;0x06e82

00006fb6 <.L52>:
  else if (freq >= 320000000 && freq <= 350000000) {
    6fb6:	0c 4a       	mov	r10,	r12	;
    6fb8:	3c 50 00 30 	add	#12288,	r12	;#0x3000
    6fbc:	0d 45       	mov	r5,	r13	;
    6fbe:	3d 60 ed ec 	addc	#-4883,	r13	;#0xeced
    6fc2:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    6fc6:	0e 9d       	cmp	r13,	r14	;
    6fc8:	0f 28       	jnc	$+32     	;abs 0x6fe8
    6fca:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    6fce:	04 20       	jnz	$+10     	;abs 0x6fd8
    6fd0:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    6fd4:	0e 9c       	cmp	r12,	r14	;
    6fd6:	08 28       	jnc	$+18     	;abs 0x6fe8

00006fd8 <.L67>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    6fd8:	5e 44 04 00 	mov.b	4(r4),	r14	;
    6fdc:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    6fe0:	4a 4e       	mov.b	r14,	r10	;
    6fe2:	6a d2       	bis.b	#4,	r10	;r2 As==10
    6fe4:	80 00 50 6f 	mova	#28496,	r0	;0x06f50

00006fe8 <.L55>:
  else if (freq >= 350000000 && freq <= 390000000) {
    6fe8:	0c 4a       	mov	r10,	r12	;
    6fea:	3c 50 80 6c 	add	#27776,	r12	;#0x6c80
    6fee:	0d 45       	mov	r5,	r13	;
    6ff0:	3d 60 23 eb 	addc	#-5341,	r13	;#0xeb23
    6ff4:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    6ff8:	0e 9d       	cmp	r13,	r14	;
    6ffa:	13 28       	jnc	$+40     	;abs 0x7022
    6ffc:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    7000:	04 20       	jnz	$+10     	;abs 0x700a
    7002:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7006:	0e 9c       	cmp	r12,	r14	;
    7008:	0c 28       	jnc	$+26     	;abs 0x7022

0000700a <.L68>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    700a:	5e 44 04 00 	mov.b	4(r4),	r14	;
    700e:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7012:	4a 4e       	mov.b	r14,	r10	;
    7014:	7a d2       	bis.b	#8,	r10	;r2 As==11

00007016 <.L75>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    7016:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    701a:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    701e:	80 00 58 6f 	mova	#28504,	r0	;0x06f58

00007022 <.L57>:
  else if (freq >= 390000000 && freq <= 430000000) {
    7022:	0c 4a       	mov	r10,	r12	;
    7024:	3c 50 80 12 	add	#4736,	r12	;#0x1280
    7028:	0d 45       	mov	r5,	r13	;
    702a:	3d 60 c1 e8 	addc	#-5951,	r13	;#0xe8c1
    702e:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    7032:	0e 9d       	cmp	r13,	r14	;
    7034:	10 28       	jnc	$+34     	;abs 0x7056
    7036:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    703a:	04 20       	jnz	$+10     	;abs 0x7044
    703c:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7040:	0e 9c       	cmp	r12,	r14	;
    7042:	09 28       	jnc	$+20     	;abs 0x7056

00007044 <.L69>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    7044:	5e 44 04 00 	mov.b	4(r4),	r14	;
    7048:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    704c:	4a 4e       	mov.b	r14,	r10	;
    704e:	7a d0 0c 00 	bis.b	#12,	r10	;#0x000c
    7052:	80 00 16 70 	mova	#28694,	r0	;0x07016

00007056 <.L59>:
  else if (freq >= 430000000 && freq <= 470000000) {
    7056:	0c 4a       	mov	r10,	r12	;
    7058:	3c 50 80 b8 	add	#-18304,r12	;#0xb880
    705c:	0d 45       	mov	r5,	r13	;
    705e:	3d 60 5e e6 	addc	#-6562,	r13	;#0xe65e
    7062:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    7066:	0e 9d       	cmp	r13,	r14	;
    7068:	10 28       	jnc	$+34     	;abs 0x708a
    706a:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    706e:	04 20       	jnz	$+10     	;abs 0x7078
    7070:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    7074:	0e 9c       	cmp	r12,	r14	;
    7076:	09 28       	jnc	$+20     	;abs 0x708a

00007078 <.L70>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    7078:	5e 44 04 00 	mov.b	4(r4),	r14	;
    707c:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    7080:	4a 4e       	mov.b	r14,	r10	;
    7082:	7a d0 10 00 	bis.b	#16,	r10	;#0x0010
    7086:	80 00 16 70 	mova	#28694,	r0	;0x07016

0000708a <.L61>:
  else if (freq >= 470000000 && freq <= 510000000) {
    708a:	0c 4a       	mov	r10,	r12	;
    708c:	3c 50 80 5e 	add	#24192,	r12	;#0x5e80
    7090:	0d 45       	mov	r5,	r13	;
    7092:	3d 60 fc e3 	addc	#-7172,	r13	;#0xe3fc
    7096:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    709a:	0e 9d       	cmp	r13,	r14	;
    709c:	65 2b       	jnc	$-308    	;abs 0x6f68
    709e:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    70a2:	04 20       	jnz	$+10     	;abs 0x70ac
    70a4:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    70a8:	0e 9c       	cmp	r12,	r14	;
    70aa:	5e 2b       	jnc	$-322    	;abs 0x6f68

000070ac <.L71>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    70ac:	5e 44 04 00 	mov.b	4(r4),	r14	;
    70b0:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    70b4:	49 4e       	mov.b	r14,	r9	;

000070b6 <.LVL125>:
    70b6:	79 d0 14 00 	bis.b	#20,	r9	;#0x0014
    70ba:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    70be:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    70c2:	46 13       	calla	r6		;
    70c4:	4e 49       	mov.b	r9,	r14	;
    70c6:	80 00 5c 6f 	mova	#28508,	r0	;0x06f5c

000070ca <sx1212SetSync>:
void sx1212SetSync(SX1212Driver *devp, SX1212_SYNC_TYPE sync) {
    70ca:	5a 14       	pushm.a	#6,	r10	;20-bit words

000070cc <.LCFI14>:
    70cc:	ca 0c       	mova	r12,	r10	;
    70ce:	08 4d       	mov	r13,	r8	;
    70d0:	09 4e       	mov	r14,	r9	;

000070d2 <.LVL128>:
    70d2:	77 40 16 00 	mov.b	#22,	r7	;#0x0016
    70d6:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

000070da <.LBB77>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    70da:	86 00 02 6b 	mova	#27394,	r6	;0x06b02

000070de <.L78>:
        sync >> (8 * (sizeof(sync) - 1 - i)));
    70de:	0c 48       	mov	r8,	r12	;
    70e0:	0d 49       	mov	r9,	r13	;
    70e2:	0e 45       	mov	r5,	r14	;
    70e4:	0f 43       	clr	r15		;
    70e6:	b0 13 dc d2 	calla	#53980		;0x0d2dc

000070ea <.Loc.577.1>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    70ea:	4e 4c       	mov.b	r12,	r14	;
    70ec:	4d 47       	mov.b	r7,	r13	;
    70ee:	cc 0a       	mova	r10,	r12	;
    70f0:	46 13       	calla	r6		;

000070f2 <.LVL131>:
    70f2:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8
    70f6:	4c 47       	mov.b	r7,	r12	;
    70f8:	5c 53       	inc.b	r12		;
    70fa:	47 4c       	mov.b	r12,	r7	;

000070fc <.Loc.576.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    70fc:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    7100:	ee 23       	jnz	$-34     	;abs 0x70de

00007102 <.LBE77>:
}
    7102:	55 16       	popm.a	#6,	r10	;20-bit words
    7104:	10 01       	reta			;

00007106 <sx1212SetRxBw>:
 * @param[in] bandwidth the receiver bandwidth to use minus one, in steps of 25 kHz
 * 
 * @note The bandwidth specifiedd here is for the active filter. Passive
 *       filter bandwidth is set automatically according to datasheet
 */
void sx1212SetRxBw(SX1212Driver *devp, uint8_t bandwidth) {
    7106:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    710a:	4e 9d       	cmp.b	r13,	r14	;
    710c:	01 2c       	jc	$+4      	;abs 0x7110
    710e:	4d 4e       	mov.b	r14,	r13	;

00007110 <.L81>:
    7110:	4e 4d       	mov.b	r13,	r14	;

00007112 <.LVL134>:
  osalDbgAssert(bandwidth < 16, "requested bandwidth is too wide");
  
  /* Passive filter bandwidth to be between 3 and 4 times active filter 
   * bandwidth, per datasheet. This is precalculated because there's no obvious
   * mapping. */
  sx1212SetRegister(devp, RXParam0, (passive[bandwidth] << 4) | bandwidth);
    7112:	4e 0e       	rlam.a	#4,	r14	;
    7114:	4e 0d       	rram.a	#4,	r14	;
    7116:	c0 18 5e 4e 	movx.b	65598(r14),r14	;0x1003e
    711a:	3e 00 
    711c:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    7120:	4e dd       	bis.b	r13,	r14	;
    7122:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010

00007126 <.LVL135>:
    7126:	b0 13 02 6b 	calla	#27394		;0x06b02

0000712a <.LVL136>:
}
    712a:	10 01       	reta			;

0000712c <sx1212Start>:
 * @param[in] devp      pointer to the @p SX1212Driver object
 * @param[in] config    pointer to the @p SX1212Config object
 *
 * @api
 */
void sx1212Start(SX1212Driver *devp, const SX1212Config *config) {
    712c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000712e <.LCFI15>:
    712e:	08 14       	pushm.a	#1,	r8	;20-bit words

00007130 <.LCFI16>:
    7130:	06 14       	pushm.a	#1,	r6	;20-bit words

00007132 <.LCFI17>:
    7132:	04 14       	pushm.a	#1,	r4	;20-bit words

00007134 <.LCFI18>:
    7134:	ca 0c       	mova	r12,	r10	;
    7136:	c8 0d       	mova	r13,	r8	;

00007138 <.Loc.963.1>:
  
  devp->config = config;
    7138:	7a 0d 00 00 	mova	r13,	0(r10)	;

0000713c <.Loc.965.1>:
  /* Reset the device to get it into a known state */
  sx1212Reset(devp);
    713c:	b0 13 54 6b 	calla	#27476		;0x06b54

00007140 <.LVL138>:
  /* Set all the stored registers to their reset states */
  devp->regs.MCParam0 = 0x30;
    7140:	fa 40 30 00 	mov.b	#48,	4(r10)	;#0x0030
    7144:	04 00 

00007146 <.Loc.968.1>:
  devp->regs.IRQParam0 = 0x0F;
    7146:	fa 40 0f 00 	mov.b	#15,	5(r10)	;#0x000f
    714a:	05 00 

0000714c <.Loc.971.1>:
  
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    714c:	3d 08 04 00 	mova	4(r8),	r13	;
    7150:	0c 08       	mova	@r8,	r12	;
    7152:	b0 13 ae 52 	calla	#21166		;0x052ae

00007156 <.LVL139>:
  /* Put the SPI interface into Config mode */
  spi_mode_config(devp);
    7156:	cc 0a       	mova	r10,	r12	;
    7158:	b0 13 a8 6c 	calla	#27816		;0x06ca8

0000715c <.LVL140>:
  
  /* Put the device into sleep mode */
  sx1212SetMode(devp, SX1212Sleep);
    715c:	4d 43       	clr.b	r13		;
    715e:	cc 0a       	mova	r10,	r12	;
    7160:	b0 13 38 6b 	calla	#27448		;0x06b38

00007164 <.LVL141>:
  /* Set device configuration */
  sx1212SetFrequency(devp, config->freq);
    7164:	1d 48 10 00 	mov	16(r8),	r13	;0x00010
    7168:	1e 48 12 00 	mov	18(r8),	r14	;0x00012
    716c:	cc 0a       	mova	r10,	r12	;
    716e:	b0 13 da 6d 	calla	#28122		;0x06dda

00007172 <.LVL142>:
  sx1212SetDeviation(devp, config->fdev);
    7172:	1d 48 14 00 	mov	20(r8),	r13	;0x00014
    7176:	1e 48 16 00 	mov	22(r8),	r14	;0x00016
    717a:	cc 0a       	mova	r10,	r12	;
    717c:	b0 13 a4 6d 	calla	#28068		;0x06da4

00007180 <.LVL143>:
  sx1212SetBitrate(devp, config->bitrate);
    7180:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    7184:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    7188:	cc 0a       	mova	r10,	r12	;
    718a:	b0 13 c2 6c 	calla	#27842		;0x06cc2

0000718e <.LVL144>:
  sx1212SetRxBw(devp, config->rx_bw);
    718e:	5d 48 18 00 	mov.b	24(r8),	r13	;0x00018
    7192:	cc 0a       	mova	r10,	r12	;
    7194:	b0 13 06 71 	calla	#28934		;0x07106

00007198 <.LVL145>:
  sx1212SetSync(devp, config->sync_word);
    7198:	1d 48 1c 00 	mov	28(r8),	r13	;0x0001c
    719c:	1e 48 1e 00 	mov	30(r8),	r14	;0x0001e
    71a0:	cc 0a       	mova	r10,	r12	;
    71a2:	b0 13 ca 70 	calla	#28874		;0x070ca

000071a6 <.LVL146>:
    71a6:	86 00 02 6b 	mova	#27394,	r6	;0x06b02

000071aa <.Loc.983.1>:
  if (config->packet_config != NULL) {
    71aa:	00 18 c8 93 	cmpx.a	#0,	38(r8)	;r3 As==00, 0x00026
    71ae:	26 00 
    71b0:	6f 24       	jz	$+224    	;abs 0x7290

000071b2 <.Loc.984.1>:
    sx1212ConfigurePackets(devp, devp->config->packet_config);
    71b2:	0c 0a       	mova	@r10,	r12	;
    71b4:	34 0c 26 00 	mova	38(r12),r4	;0x00026

000071b8 <.LBB80>:
  sx1212SetRegister(devp, MCParam1, 0xA4);
    71b8:	7e 40 a4 ff 	mov.b	#-92,	r14	;#0xffa4
    71bc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    71be:	cc 0a       	mova	r10,	r12	;
    71c0:	46 13       	calla	r6		;

000071c2 <.LVL148>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    71c2:	6e 44       	mov.b	@r4,	r14	;
    71c4:	44 18 0e 5e 	rpt #5 { rlax.w	r14		;
    71c8:	7e f0 80 00 	and.b	#128,	r14	;#0x0080

000071cc <.Loc.769.1>:
     devp->config->length);
    71cc:	0c 0a       	mova	@r10,	r12	;

000071ce <.Loc.768.1>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    71ce:	5e dc 2b 00 	bis.b	43(r12),r14	;0x0002b
    71d2:	7d 40 1c 00 	mov.b	#28,	r13	;#0x001c
    71d6:	cc 0a       	mova	r10,	r12	;
    71d8:	46 13       	calla	r6		;

000071da <.LVL149>:
  if (!packet_config->broadcast) {
    71da:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    71de:	00 00 
    71e0:	0b 20       	jnz	$+24     	;abs 0x71f8

000071e2 <.Loc.773.1>:
    packet_config->broadcast = packet_config->addressing;
    71e2:	6d 44       	mov.b	@r4,	r13	;
    71e4:	0c 4d       	mov	r13,	r12	;
    71e6:	5c 0f       	rrum	#4,	r12	;
    71e8:	5c f3       	and.b	#1,	r12	;r3 As==01
    71ea:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    71ee:	7d f0 9f ff 	and.b	#-97,	r13	;#0xff9f
    71f2:	4d dc       	bis.b	r12,	r13	;
    71f4:	c4 4d 00 00 	mov.b	r13,	0(r4)	;

000071f8 <.L84>:
  if (packet_config->broadcast) {
    71f8:	f4 b0 60 00 	bit.b	#96,	0(r4)	;#0x0060
    71fc:	00 00 
    71fe:	07 24       	jz	$+16     	;abs 0x720e

00007200 <.Loc.778.1>:
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
    7200:	0c 0a       	mova	@r10,	r12	;
    7202:	5e 4c 2a 00 	mov.b	42(r12),r14	;0x0002a
    7206:	7d 40 1d 00 	mov.b	#29,	r13	;#0x001d
    720a:	cc 0a       	mova	r10,	r12	;
    720c:	46 13       	calla	r6		;

0000720e <.L85>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    720e:	d4 b3 00 00 	bit.b	#1,	0(r4)	;r3 As==01
    7212:	3a 20       	jnz	$+118    	;abs 0x7288
    7214:	4d 43       	clr.b	r13		;

00007216 <.L86>:
      (packet_config->whitening << 4) |
    7216:	6f 44       	mov.b	@r4,	r15	;
    7218:	0c 4f       	mov	r15,	r12	;
    721a:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    721e:	7c f0 10 00 	and.b	#16,	r12	;#0x0010

00007222 <.Loc.785.1>:
      (packet_config->crc << 3) |
    7222:	0e 4f       	mov	r15,	r14	;
    7224:	7e f2       	and.b	#8,	r14	;r2 As==11
    7226:	4c de       	bis.b	r14,	r12	;

00007228 <.Loc.786.1>:
      (packet_config->broadcast << 1));
    7228:	0e 4f       	mov	r15,	r14	;
    722a:	5e 0f       	rrum	#4,	r14	;
    722c:	7e f0 06 00 	and.b	#6,	r14	;

00007230 <.Loc.785.1>:
      (packet_config->crc << 3) |
    7230:	4e dc       	bis.b	r12,	r14	;

00007232 <.Loc.781.1>:
  sx1212SetRegister(devp, PKTParam2, 
    7232:	4e dd       	bis.b	r13,	r14	;
    7234:	7d 40 1e 00 	mov.b	#30,	r13	;#0x001e
    7238:	cc 0a       	mova	r10,	r12	;
    723a:	46 13       	calla	r6		;

0000723c <.LVL151>:
  sx1212SetRegister(devp, PKTParam3, ((!packet_config->crc_autoclear) << 7));
    723c:	6e 44       	mov.b	@r4,	r14	;
    723e:	3e e0 80 00 	xor	#128,	r14	;#0x0080
    7242:	7e f0 80 ff 	and.b	#-128,	r14	;#0xff80
    7246:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

0000724a <.L94>:
  }
  else {
    /* Buffered mode */
    sx1212SetRegister(devp, MCParam1, 0x64);
    724a:	cc 0a       	mova	r10,	r12	;
    724c:	46 13       	calla	r6		;

0000724e <.LVL153>:
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
  sx1212SetRegister(devp, RXParam2, 0x20 | 
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
    724e:	5e 48 20 00 	mov.b	32(r8),	r14	;0x00020
    7252:	0e 5e       	rla	r14		;

00007254 <.Loc.993.1>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
    7254:	7e d0 38 00 	bis.b	#56,	r14	;#0x0038
    7258:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    725c:	cc 0a       	mova	r10,	r12	;
    725e:	46 13       	calla	r6		;

00007260 <.LVL154>:
  
  /* IRQParam2 - enable PLL lock */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7260:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    7264:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7268:	cc 0a       	mova	r10,	r12	;
    726a:	46 13       	calla	r6		;

0000726c <.LVL155>:
  
  /* Set Fifo size to 64 */
  sx1212SetRegister(devp, IRQParam0, 0xC0);
    726c:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    7270:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    7274:	cc 0a       	mova	r10,	r12	;
    7276:	46 13       	calla	r6		;

00007278 <.LVL156>:
  devp->regs.IRQParam0 = 0xC0;
    7278:	fa 40 c0 ff 	mov.b	#-64,	5(r10)	;#0xffc0
    727c:	05 00 

0000727e <.Loc.1008.1>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(config->spip);
#endif

}
    727e:	04 16       	popm.a	#1,	r4	;20-bit words
    7280:	06 16       	popm.a	#1,	r6	;20-bit words
    7282:	08 16       	popm.a	#1,	r8	;20-bit words
    7284:	0a 16       	popm.a	#1,	r10	;20-bit words
    7286:	10 01       	reta			;

00007288 <.L89>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    7288:	3d 40 80 ff 	mov	#-128,	r13	;#0xff80
    728c:	80 00 16 72 	mova	#29206,	r0	;0x07216

00007290 <.L83>:
    sx1212SetRegister(devp, MCParam1, 0x64);
    7290:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7294:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7296:	80 00 4a 72 	mova	#29258,	r0	;0x0724a

0000729a <sx1212ReceiveI>:
      );
  
  return MSG_OK;
}

void sx1212ReceiveI(SX1212Driver * devp, size_t n, palcallback_t callback) {
    729a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000729c <.LCFI20>:
    729c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000729e <.LCFI21>:
    729e:	c8 0c       	mova	r12,	r8	;
    72a0:	ca 0d       	mova	r13,	r10	;

000072a2 <.Loc.1077.1>:
  
  osalDbgAssert(n < 64, "invalid threshold");
  /* IRQs are Fifoempty_B and Fifo_threshold */
  
  /* Configure the Fifo_threshold callback appropriately */
  palLineEnableEventI(SX1212_IRQ_1, PAL_EVENT_MODE_RISING_EDGE, callback);
    72a2:	cf 0e       	mova	r14,	r15	;
    72a4:	5e 43       	mov.b	#1,	r14	;r3 As==01

000072a6 <.LVL164>:
    72a6:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a

000072aa <.LVL165>:
    72aa:	3c 40 20 02 	mov	#544,	r12	;#0x0220

000072ae <.LVL166>:
    72ae:	b0 13 46 58 	calla	#22598		;0x05846

000072b2 <.LBB86>:
  sx1212SetRegister(devp, IRQParam0, (0xC0 | thresh));
    72b2:	7a d0 c0 ff 	bis.b	#-64,	r10	;#0xffc0

000072b6 <.LVL168>:
    72b6:	4e 4a       	mov.b	r10,	r14	;
    72b8:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    72bc:	cc 08       	mova	r8,	r12	;
    72be:	b0 13 02 6b 	calla	#27394		;0x06b02

000072c2 <.LVL169>:
  devp->regs.IRQParam0 = (0xC0 | thresh);
    72c2:	c8 4a 05 00 	mov.b	r10,	5(r8)	;

000072c6 <.LBE86>:
  
  /* Set Fifo threshold */
  sx1212SetFifoThreshold(devp, n);
}
    72c6:	08 16       	popm.a	#1,	r8	;20-bit words
    72c8:	0a 16       	popm.a	#1,	r10	;20-bit words
    72ca:	10 01       	reta			;

000072cc <sx1212StartReceive>:
msg_t sx1212StartReceive(SX1212Driver *devp, size_t n, palcallback_t callback) {
    72cc:	0a 14       	pushm.a	#1,	r10	;20-bit words

000072ce <.LCFI22>:
    72ce:	08 14       	pushm.a	#1,	r8	;20-bit words

000072d0 <.LCFI23>:
    72d0:	06 14       	pushm.a	#1,	r6	;20-bit words

000072d2 <.LCFI24>:
    72d2:	04 14       	pushm.a	#1,	r4	;20-bit words

000072d4 <.LCFI25>:
    72d4:	ca 0c       	mova	r12,	r10	;
    72d6:	c6 0d       	mova	r13,	r6	;
    72d8:	c8 0e       	mova	r14,	r8	;

000072da <.LBB98>:
  devp->irq_mappings[0] = irq0;
    72da:	fc 40 80 ff 	mov.b	#-128,	6(r12)	;#0xff80
    72de:	06 00 

000072e0 <.Loc.628.1>:
  devp->irq_mappings[1] = irq1;
    72e0:	fc 40 30 00 	mov.b	#48,	7(r12)	;#0x0030
    72e4:	07 00 

000072e6 <.Loc.630.1>:
  sx1212SetRegister(devp, IRQParam1, irq0 | irq1);
    72e6:	84 00 02 6b 	mova	#27394,	r4	;0x06b02
    72ea:	7e 40 b0 ff 	mov.b	#-80,	r14	;#0xffb0

000072ee <.LVL173>:
    72ee:	7d 40 0d 00 	mov.b	#13,	r13	;#0x000d

000072f2 <.LVL174>:
    72f2:	44 13       	calla	r4		;

000072f4 <.LBB100>:
  _disable_interrupts();
    72f4:	32 c2       	dint			
    72f6:	03 43       	nop			

000072f8 <.Loc.348.3>:
  asm volatile("nop");
    72f8:	03 43       	nop			

000072fa <.LBE100>:
  sx1212ReceiveI(devp, n, callback);
    72fa:	ce 08       	mova	r8,	r14	;
    72fc:	cd 06       	mova	r6,	r13	;
    72fe:	cc 0a       	mova	r10,	r12	;
    7300:	b0 13 9a 72 	calla	#29338		;0x0729a

00007304 <.LBB102>:
  asm volatile("nop");
    7304:	03 43       	nop			

00007306 <.Loc.356.3>:
  _enable_interrupts();
    7306:	03 43       	nop			
    7308:	32 d2       	eint			
    730a:	03 43       	nop			

0000730c <.LBB104>:
  sx1212SetMode(devp, SX1212Stdby);
    730c:	88 00 38 6b 	mova	#27448,	r8	;0x06b38

00007310 <.LVL178>:
    7310:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    7314:	cc 0a       	mova	r10,	r12	;
    7316:	48 13       	calla	r8		;

00007318 <.LBB106>:
  chThdSleep(time);
    7318:	7c 40 05 00 	mov.b	#5,	r12	;
    731c:	b0 13 10 47 	calla	#18192		;0x04710

00007320 <.LBE106>:
  sx1212SetMode(devp, SX1212FS);
    7320:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    7324:	cc 0a       	mova	r10,	r12	;
    7326:	48 13       	calla	r8		;

00007328 <.LVL181>:
  suspend_result = irq_block_with_timeout(devp, SX1212_PLL_LOCK, timeout);
    7328:	4d 43       	clr.b	r13		;
    732a:	3c 40 20 b2 	mov	#-19936,r12	;#0xb220
    732e:	b0 13 28 6c 	calla	#27688		;0x06c28

00007332 <.LVL182>:
    7332:	c6 0c       	mova	r12,	r6	;

00007334 <.LVL183>:
    7334:	61 0c 6a 15 	mova	r12,	&71018	; 0x1156a

00007338 <.Loc.680.1>:
  if (suspend_result != MSG_OK) {
    7338:	9c 00 00 00 	cmpa	#0,	r12	;
    733c:	0a 20       	jnz	$+22     	;abs 0x7352

0000733e <.Loc.685.1>:
  sx1212SetMode(devp, SX1212Rx);
    733e:	7d 40 60 00 	mov.b	#96,	r13	;#0x0060
    7342:	cc 0a       	mova	r10,	r12	;
    7344:	48 13       	calla	r8		;

00007346 <.LVL184>:
  sx1212SetRegister(devp, IRQParam2, 0x51);
    7346:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    734a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    734e:	cc 0a       	mova	r10,	r12	;
    7350:	44 13       	calla	r4		;

00007352 <.L98>:
  BLOCK_RETURN_ERROR(
    7352:	61 06 6a 15 	mova	r6,	&71018	; 0x1156a

00007356 <.Loc.1067.1>:
}
    7356:	cc 06       	mova	r6,	r12	;
    7358:	04 16       	popm.a	#1,	r4	;20-bit words
    735a:	06 16       	popm.a	#1,	r6	;20-bit words
    735c:	08 16       	popm.a	#1,	r8	;20-bit words
    735e:	0a 16       	popm.a	#1,	r10	;20-bit words
    7360:	10 01       	reta			;

00007362 <sx1212FifoRead>:
  
  devp->rx_callback = callback;
  spiStartReceive(devp->config->spip, n, buffer);
}

void sx1212FifoRead(SX1212Driver * devp, size_t n, uint8_t * buffer) {
    7362:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007364 <.LCFI30>:
    7364:	b1 00 04 00 	suba	#4,	r1	;

00007368 <.LCFI31>:
    7368:	c4 0c       	mova	r12,	r4	;
    736a:	c5 0e       	mova	r14,	r5	;

0000736c <.LVL190>:
    736c:	ed 0e       	adda	r14,	r13	;

0000736e <.LVL191>:
    736e:	71 0d 00 00 	mova	r13,	0(r1)	;

00007372 <.LBB108>:
  
  for (size_t i = 0; i < n; i++) {
    palClearLine(devp->config->data_ss_b);
    7372:	5a 43       	mov.b	#1,	r10	;r3 As==01

00007374 <.Loc.1096.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    7374:	79 43       	mov.b	#-1,	r9	;r3 As==11

00007376 <.L101>:
  for (size_t i = 0; i < n; i++) {
    7376:	00 18 c1 95 	cmpx.a	r5,	0(r1)	;
    737a:	00 00 
    737c:	04 20       	jnz	$+10     	;abs 0x7386

0000737e <.LBE108>:
    palSetLine(devp->config->data_ss_b);
  }
  
}
    737e:	a1 00 04 00 	adda	#4,	r1	;
    7382:	64 16       	popm.a	#7,	r10	;20-bit words
    7384:	10 01       	reta			;

00007386 <.L102>:
    palClearLine(devp->config->data_ss_b);
    7386:	08 04       	mova	@r4,	r8	;
    7388:	3c 08 08 00 	mova	8(r8),	r12	;
    738c:	c6 0c       	mova	r12,	r6	;
    738e:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    7392:	ff 0f 
    7394:	17 46 02 00 	mov	2(r6),	r7	;
    7398:	0c 14       	pushm.a	#1,	r12	;20-bit words
    739a:	40 18 3c 41 	popx.w	r12		;
    739e:	40 18 3d 41 	popx.w	r13		;
    73a2:	b0 13 8a d2 	calla	#53898		;0x0d28a
    73a6:	0d 12       	push	r13		;
    73a8:	0c 12       	push	r12		;
    73aa:	0c 16       	popm.a	#1,	r12	;20-bit words
    73ac:	40 18 0d 4c 	movx.w	r12,	r13	;
    73b0:	0c 4a       	mov	r10,	r12	;
    73b2:	b0 13 6a d1 	calla	#53610		;0x0d16a
    73b6:	07 cc       	bic	r12,	r7	;
    73b8:	86 47 02 00 	mov	r7,	2(r6)	;

000073bc <.Loc.1096.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    73bc:	4d 49       	mov.b	r9,	r13	;
    73be:	0c 08       	mova	@r8,	r12	;
    73c0:	b0 13 62 5d 	calla	#23906		;0x05d62

000073c4 <.LVL195>:
    73c4:	c5 4c 00 00 	mov.b	r12,	0(r5)	;

000073c8 <.Loc.1097.1>:
    palSetLine(devp->config->data_ss_b);
    73c8:	0c 04       	mova	@r4,	r12	;
    73ca:	3c 0c 08 00 	mova	8(r12),	r12	;
    73ce:	c6 0c       	mova	r12,	r6	;
    73d0:	00 18 76 f0 	andx.a	#4095,	r6	;0x00fff
    73d4:	ff 0f 
    73d6:	18 46 02 00 	mov	2(r6),	r8	;
    73da:	0c 14       	pushm.a	#1,	r12	;20-bit words
    73dc:	40 18 3c 41 	popx.w	r12		;
    73e0:	40 18 3d 41 	popx.w	r13		;
    73e4:	b0 13 8a d2 	calla	#53898		;0x0d28a
    73e8:	0d 12       	push	r13		;
    73ea:	0c 12       	push	r12		;
    73ec:	0c 16       	popm.a	#1,	r12	;20-bit words
    73ee:	40 18 0d 4c 	movx.w	r12,	r13	;
    73f2:	0c 4a       	mov	r10,	r12	;
    73f4:	b0 13 6a d1 	calla	#53610		;0x0d16a
    73f8:	0c d8       	bis	r8,	r12	;
    73fa:	86 4c 02 00 	mov	r12,	2(r6)	;

000073fe <.LVL198>:
    73fe:	a5 00 01 00 	adda	#1,	r5	;

00007402 <.LVL199>:
    7402:	80 00 76 73 	mova	#29558,	r0	;0x07376

00007406 <sx1212StopReceive>:
 * @post    NSS_CONFIG and NSS_DATA busses are both released (if enabled).
 *          SX1212 is in Sleep mode.
 *          
 * @param[in] devp    pointer to the SX1212 driver
 */
void sx1212StopReceive(SX1212Driver *devp) {
    7406:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007408 <.LCFI32>:
    7408:	ca 0c       	mova	r12,	r10	;

0000740a <.Loc.1150.1>:
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* Reset for next packet reception */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    740a:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    740e:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7412:	b0 13 02 6b 	calla	#27394		;0x06b02

00007416 <.LVL201>:
  /* Go to Sleep */
  sx1212SetMode(devp, SX1212Sleep);
    7416:	4d 43       	clr.b	r13		;
    7418:	cc 0a       	mova	r10,	r12	;
    741a:	b0 13 38 6b 	calla	#27448		;0x06b38

0000741e <.LVL202>:
  
  /* Release SPI bus */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
}
    741e:	0a 16       	popm.a	#1,	r10	;20-bit words
    7420:	10 01       	reta			;

00007422 <serial_callback>:
/* Using UARTDA1 */
SerialConfig __attribute__((section(".persistent"))) A1_cfg = {
  UART_BAUD, /* Baud rate */
};

static void serial_callback(event_source_t *p) {
    7422:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007424 <.LCFI0>:
    7424:	ca 0c       	mova	r12,	r10	;

00007426 <.Loc.71.1>:
  chEvtSignalI(uart_thd, p->flags);
    7426:	2d 4c       	mov	@r12,	r13	;
    7428:	1e 4c 02 00 	mov	2(r12),	r14	;
    742c:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2

00007430 <.LVL1>:
    7430:	b0 13 ec 47 	calla	#18412		;0x047ec

00007434 <.LVL2>:
  p->flags = 0;
    7434:	8a 43 00 00 	mov	#0,	0(r10)	;r3 As==00
    7438:	8a 43 02 00 	mov	#0,	2(r10)	;r3 As==00

0000743c <.Loc.73.1>:
}
    743c:	0a 16       	popm.a	#1,	r10	;20-bit words
    743e:	10 01       	reta			;

00007440 <elyUARTCfgMarkDirty>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    7440:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    7444:	4e 43       	clr.b	r14		;
    7446:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2
    744a:	b0 13 c0 47 	calla	#18368		;0x047c0

0000744e <.LVL4>:
}
    744e:	10 01       	reta			;

00007450 <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    7450:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007452 <.LCFI1>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    7452:	cd 0c       	mova	r12,	r13	;
    7454:	8c 01 de 01 	mova	#66014,	r12	;0x101de

00007458 <.LVL6>:
    7458:	b0 13 ea 48 	calla	#18666		;0x048ea

0000745c <.LVL7>:
    745c:	ca 0c       	mova	r12,	r10	;

0000745e <.Loc.29.1>:
  if (MSG_OK == msg) {
    745e:	9c 00 00 00 	cmpa	#0,	r12	;
    7462:	0a 20       	jnz	$+22     	;abs 0x7478

00007464 <.Loc.30.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    7464:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    7468:	4e 43       	clr.b	r14		;
    746a:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2
    746e:	b0 13 ec 47 	calla	#18412		;0x047ec

00007472 <.L4>:
}
    7472:	cc 0a       	mova	r10,	r12	;
    7474:	0a 16       	popm.a	#1,	r10	;20-bit words
    7476:	10 01       	reta			;

00007478 <.L5>:
    chSysHalt("an error");
    7478:	8c 00 d0 d4 	mova	#54480,	r12	;0x0d4d0
    747c:	b0 13 7a 45 	calla	#17786		;0x0457a

00007480 <.LVL10>:
  return msg;
    7480:	80 00 72 74 	mova	#29810,	r0	;0x07472

00007484 <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    7484:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007486 <.LBB16>:
  _disable_interrupts();
    7486:	32 c2       	dint			
    7488:	03 43       	nop			

0000748a <.Loc.348.2>:
  asm volatile("nop");
    748a:	03 43       	nop			

0000748c <.LBE16>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    748c:	0e 4d       	mov	r13,	r14	;
    748e:	cd 0c       	mova	r12,	r13	;

00007490 <.LVL12>:
    7490:	8c 01 de 01 	mova	#66014,	r12	;0x101de

00007494 <.LVL13>:
    7494:	b0 13 82 48 	calla	#18562		;0x04882

00007498 <.LVL14>:
    7498:	ca 0c       	mova	r12,	r10	;

0000749a <.Loc.45.1>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    749a:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    749e:	4e 43       	clr.b	r14		;
    74a0:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2
    74a4:	b0 13 ec 47 	calla	#18412		;0x047ec

000074a8 <.LBB18>:
  asm volatile("nop");
    74a8:	03 43       	nop			

000074aa <.Loc.356.2>:
  _enable_interrupts();
    74aa:	03 43       	nop			
    74ac:	32 d2       	eint			
    74ae:	03 43       	nop			

000074b0 <.LBE18>:
}
    74b0:	cc 0a       	mova	r10,	r12	;
    74b2:	0a 16       	popm.a	#1,	r10	;20-bit words
    74b4:	10 01       	reta			;

000074b6 <UARTThd>:
static bool is_byte(msg_t c) {
  return (c >= 0 && c < 256);
}

THD_WORKING_AREA(waUARTThd, 512);
THD_FUNCTION(UARTThd, arg) {
    74b6:	4a 14       	pushm.a	#5,	r10	;20-bit words

000074b8 <.LCFI3>:
    74b8:	04 14       	pushm.a	#1,	r4	;20-bit words

000074ba <.LCFI4>:
    74ba:	b1 00 04 00 	suba	#4,	r1	;

000074be <.LCFI5>:
  (void)arg;
  static msg_t tx_char;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    74be:	81 18 d2 42 	movx.a	&0x112ec,&0x117d2;
    74c2:	ec 12 d2 17 

000074c6 <.Loc.87.1>:
  
  events = UARTConfigUpdated;
    74c6:	41 18 b2 40 	movx.w	#2048,	&0x117da;0x00800
    74ca:	00 08 da 17 
    74ce:	41 18 82 43 	movx.w	#0,	&0x117dc;r3 As==00
    74d2:	dc 17 

000074d4 <.LBB46>:
  esp->cb    = cb;
    74d4:	84 01 38 13 	mova	#70456,	r4	;0x11338
    74d8:	01 18 f2 40 	movx.a	#29730,	&0x11340;0x07422
    74dc:	22 74 40 13 

000074e0 <.Loc.873.3>:
  esp->param = param;
    74e0:	cc 04       	mova	r4,	r12	;

000074e2 <.LVL19>:
    74e2:	ac 00 04 00 	adda	#4,	r12	;
    74e6:	74 0c 0c 00 	mova	r12,	12(r4)	; 0x0000c

000074ea <.LBE46>:
  
  /* Initialize the timeout timer */
  /*gptStart(&uart_gpt, &uart_timer_cfg);*/
  
  /* Initialize the SCC uart last valid packet received timer */
  gptStart(&fault_timer_gpt, &fault_timer_cfg); //ASA
    74ea:	88 00 40 50 	mova	#20544,	r8	;0x05040
    74ee:	8d 01 56 00 	mova	#65622,	r13	;0x10056
    74f2:	8c 01 10 15 	mova	#70928,	r12	;0x11510
    74f6:	48 13       	calla	r8		;

000074f8 <.LVL21>:

  TA3CCR1 = 5;
    74f8:	40 18 b2 40 	movx.w	#5,	&0x00454;
    74fc:	05 00 54 04 

00007500 <.Loc.99.1>:
  TA3CCTL1 = 0b0000000001100000; //ASA
    7500:	40 18 b2 40 	movx.w	#96,	&0x00444;0x00060
    7504:	60 00 44 04 

00007508 <.Loc.102.1>:

  /* Start the SCC uart last valid packet received timer in continuous mode */
  gptStartContinuous(&fault_timer_gpt, 1000);//ASA
    7508:	8a 00 70 50 	mova	#20592,	r10	;0x05070
    750c:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    7510:	8c 01 10 15 	mova	#70928,	r12	;0x11510
    7514:	4a 13       	calla	r10		;

00007516 <.LVL22>:

  /* start the general purpose timer (used for OC fault handling)*/
  gptStart(&gp_timer_gpt, &gp_timer_cfg);
    7516:	8d 01 4e 00 	mova	#65614,	r13	;0x1004e
    751a:	8c 01 fc 14 	mova	#70908,	r12	;0x114fc
    751e:	48 13       	calla	r8		;

00007520 <.LVL23>:

  /* Start the OC fault handler timer */
  gptStartContinuous(&gp_timer_gpt, 10);//ASA
    7520:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    7524:	8c 01 fc 14 	mova	#70908,	r12	;0x114fc
    7528:	4a 13       	calla	r10		;

0000752a <.LVL24>:

  elyUARTDLLRxInit();
    752a:	b0 13 2a a8 	calla	#43050		;0x0a82a

0000752e <.LVL25>:
    752e:	26 01 2a 01 	mova	&65834,	r6	;0x1012a

00007532 <.LBB48>:
      ELY_UART.event.flags |= CHN_OUTPUT_EMPTY;
      events &= ~UARTConfigUpdated;
    }
    if (events & CHN_INPUT_AVAILABLE) {
      msg_t c;
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    7532:	c7 04       	mova	r4,	r7	;
    7534:	a7 00 12 00 	adda	#18,	r7	;0x00012

00007538 <.LBE48>:
      events &= ~UARTBufferPosted;
    }
    if (events & CHN_OUTPUT_EMPTY) {
      /* Take characters from the TX state machine until the buffer ends or
       * the queue is full */
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    7538:	c9 04       	mova	r4,	r9	;
    753a:	a9 00 30 00 	adda	#48,	r9	;0x00030

0000753e <.L26>:
    events = SCC_Fault_Handler(events); //Must be executed BEFORE UART is started in order to influence fallback baudrate.
    753e:	c0 18 1c 42 	movx.w	&0x117da,r12	;
    7542:	da 17 
    7544:	c0 18 1d 42 	movx.w	&0x117dc,r13	;
    7548:	dc 17 
    754a:	b0 13 ba c6 	calla	#50874		;0x0c6ba

0000754e <.LVL26>:
    events &= ~UARTCheckFaults;
    754e:	0e 4c       	mov	r12,	r14	;
    7550:	3e f0 ff bf 	and	#-16385,r14	;#0xbfff
    7554:	41 18 82 4e 	movx.w	r14,	&0x117da;
    7558:	da 17 
    755a:	41 18 82 4d 	movx.w	r13,	&0x117dc;
    755e:	dc 17 

00007560 <.Loc.117.1>:
    if (events & UARTConfigUpdated) {
    7560:	40 18 3c b0 	bitx.w	#2048,	r12	;0x00800
    7564:	00 08 
    7566:	3f 24       	jz	$+128    	;abs 0x75e6

00007568 <.LBB49>:
  _disable_interrupts();
    7568:	32 c2       	dint			
    756a:	03 43       	nop			

0000756c <.Loc.348.2>:
  asm volatile("nop");
    756c:	03 43       	nop			

0000756e <.LBE49>:
      if(events & UARTUseFallbackBaudrate)
    756e:	40 18 3c b0 	bitx.w	#8192,	r12	;0x02000
    7572:	00 20 
    7574:	b1 24       	jz	$+356    	;abs 0x76d8

00007576 <.Loc.131.1>:
                       ((uint32_t)(bank0p[RegSCCommBaudHmb]) << 16) |
    7576:	5d 46 39 00 	mov.b	57(r6),	r13	;0x00039
    757a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    757e:	5c 46 3b 00 	mov.b	59(r6),	r12	;0x0003b
    7582:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7586:	5f 46 3a 00 	mov.b	58(r6),	r15	;0x0003a
    758a:	0c df       	bis	r15,	r12	;

0000758c <.Loc.129.1>:
          A1_cfg.sc_bitrate = ( ((uint32_t)(bank0p[RegSCCommBaudLsb])) |
    758c:	5e 46 38 00 	mov.b	56(r6),	r14	;0x00038

00007590 <.L39>:
          A1_cfg.sc_bitrate = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    7590:	0e dd       	bis	r13,	r14	;
    7592:	40 18 82 4e 	movx.w	r14,	&0xfd550;
    7596:	50 d5 
    7598:	40 18 82 4c 	movx.w	r12,	&0xfd552;
    759c:	52 d5 

0000759e <.LBB51>:
  asm volatile("nop");
    759e:	03 43       	nop			

000075a0 <.Loc.356.2>:
  _enable_interrupts();
    75a0:	03 43       	nop			
    75a2:	32 d2       	eint			
    75a4:	03 43       	nop			

000075a6 <.LBE51>:
      sdStop(&ELY_UART);
    75a6:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    75aa:	b0 13 da 51 	calla	#20954		;0x051da

000075ae <.LVL27>:
      sdStart(&ELY_UART, &A1_cfg);
    75ae:	8d 00 50 d5 	mova	#54608,	r13	;0x0d550
    75b2:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    75b6:	b0 13 bc 51 	calla	#20924		;0x051bc

000075ba <.LVL28>:
      ELY_UART.event.flags |= CHN_OUTPUT_EMPTY;
    75ba:	1c 44 04 00 	mov	4(r4),	r12	;
    75be:	1d 44 06 00 	mov	6(r4),	r13	;
    75c2:	0f 4c       	mov	r12,	r15	;
    75c4:	3f d2       	bis	#8,	r15	;r2 As==11
    75c6:	81 4f 00 00 	mov	r15,	0(r1)	;
    75ca:	81 4d 02 00 	mov	r13,	2(r1)	;
    75ce:	a4 41 04 00 	mov	@r1,	4(r4)	;
    75d2:	94 41 02 00 	mov	2(r1),	6(r4)	;
    75d6:	06 00 

000075d8 <.Loc.146.1>:
      events &= ~UARTConfigUpdated;
    75d8:	c1 1f b2 f0 	andx.w	#-2049,	&0x117da;0xff7ff
    75dc:	ff f7 da 17 
    75e0:	41 18 82 c3 	bicx.w	#0,	&0x117dc;r3 As==00
    75e4:	dc 17 

000075e6 <.L9>:
    if (events & CHN_INPUT_AVAILABLE) {
    75e6:	41 18 e2 b2 	bitx.b	#4,	&0x117da;r2 As==10
    75ea:	da 17 
    75ec:	94 20       	jnz	$+298    	;abs 0x7716

000075ee <.L15>:
    if (events & UARTBufferPosted) {
    75ee:	41 18 f2 b0 	bitx.b	#16,	&0x117db;0x00010
    75f2:	10 00 db 17 
    75f6:	26 24       	jz	$+78     	;abs 0x7644

000075f8 <.LBB53>:
  _disable_interrupts();
    75f8:	32 c2       	dint			
    75fa:	03 43       	nop			

000075fc <.Loc.348.2>:
  asm volatile("nop");
    75fc:	03 43       	nop			

000075fe <.LBE54>:
      msg_t result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    75fe:	3e 43       	mov	#-1,	r14	;r3 As==11
    7600:	8d 01 d6 17 	mova	#71638,	r13	;0x117d6
    7604:	8c 01 de 01 	mova	#66014,	r12	;0x101de
    7608:	b0 13 30 49 	calla	#18736		;0x04930

0000760c <.LBB56>:
  asm volatile("nop");
    760c:	03 43       	nop			

0000760e <.Loc.356.2>:
  _enable_interrupts();
    760e:	03 43       	nop			
    7610:	32 d2       	eint			
    7612:	03 43       	nop			

00007614 <.LBE56>:
      elyUARTDLLTxSetBuffer(tx_active_buffer);
    7614:	2c 01 d6 17 	mova	&71638,	r12	;0x117d6
    7618:	b0 13 18 a8 	calla	#43032		;0x0a818

0000761c <.LVL30>:
      tx_char = elyUARTDLLTxStateMachine();
    761c:	b0 13 68 a7 	calla	#42856		;0x0a768

00007620 <.LVL31>:
    7620:	61 0c 8e 15 	mova	r12,	&71054	; 0x1158e

00007624 <.Loc.163.1>:
      UARTEvtMask &= ~UARTBufferPosted;
    7624:	c0 18 1c 42 	movx.w	&0x101dc,r12	;
    7628:	dc 01 
    762a:	3c f0 ff ef 	and	#-4097,	r12	;#0xefff

0000762e <.Loc.164.1>:
      UARTEvtMask |= CHN_OUTPUT_EMPTY;
    762e:	3c d2       	bis	#8,	r12	;r2 As==11
    7630:	41 18 82 4c 	movx.w	r12,	&0x101dc;
    7634:	dc 01 

00007636 <.Loc.165.1>:
      events &= ~UARTBufferPosted;
    7636:	c1 1f b2 f0 	andx.w	#-4097,	&0x117da;0xfefff
    763a:	ff ef da 17 
    763e:	41 18 82 c3 	bicx.w	#0,	&0x117dc;r3 As==00
    7642:	dc 17 

00007644 <.L17>:
    if (events & CHN_OUTPUT_EMPTY) {
    7644:	41 18 f2 b2 	bitx.b	#8,	&0x117da;r2 As==11
    7648:	da 17 
    764a:	6b 20       	jnz	$+216    	;abs 0x7722

0000764c <.L20>:
          break;
        }
      }
      events &= ~CHN_OUTPUT_EMPTY;
    }
    if (events & CHN_TRANSMISSION_END) {
    764c:	41 18 f2 b0 	bitx.b	#16,	&0x117da;0x00010
    7650:	10 00 da 17 
    7654:	2a 24       	jz	$+86     	;abs 0x76aa

00007656 <.Loc.182.1>:
      chDbgAssert(NULL != tx_active_buffer, "Transmission ended but we weren't sending");
      elyNLFreeBufferChecked(tx_active_buffer);
    7656:	2c 01 d6 17 	mova	&71638,	r12	;0x117d6
    765a:	b0 13 72 c3 	calla	#50034		;0x0c372

0000765e <.LVL32>:
      tx_active_buffer = NULL;
    765e:	01 18 c2 43 	movx.a	#0,	&0x117d6;r3 As==00
    7662:	d6 17 

00007664 <.Loc.184.1>:
      UARTEvtMask |= UARTBufferPosted;
    7664:	41 18 b2 d0 	bisx.w	#4096,	&0x101dc;0x01000
    7668:	00 10 dc 01 

0000766c <.LBB58>:
  _disable_interrupts();
    766c:	32 c2       	dint			
    766e:	03 43       	nop			

00007670 <.Loc.348.2>:
  asm volatile("nop");
    7670:	03 43       	nop			

00007672 <.LBB60>:
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->fullsem);
    7672:	c0 18 1c 42 	movx.w	&0x101ee,r12	;
    7676:	ee 01 

00007678 <.LBE60>:
      /* are there more buffers to be sent? */
      chSysLock();
      if (chMBGetUsedCountI(&uart_mbox) > 0) {
    7678:	4f 43       	clr.b	r15		;
    767a:	0f 9c       	cmp	r12,	r15	;
    767c:	07 34       	jge	$+16     	;abs 0x768c

0000767e <.Loc.188.1>:
        chEvtSignalI(uart_thd, UARTBufferPosted);
    767e:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    7682:	4e 43       	clr.b	r14		;
    7684:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2
    7688:	b0 13 ec 47 	calla	#18412		;0x047ec

0000768c <.L25>:
  asm volatile("nop");
    768c:	03 43       	nop			

0000768e <.Loc.356.2>:
  _enable_interrupts();
    768e:	03 43       	nop			
    7690:	32 d2       	eint			
    7692:	03 43       	nop			

00007694 <.LBE62>:
      }
      chSysUnlock();
      UARTEvtMask &= ~CHN_TRANSMISSION_END;
    7694:	c1 1f b2 f0 	andx.w	#-17,	&0x101dc;0xfffef
    7698:	ef ff dc 01 

0000769c <.Loc.192.1>:
      events &= ~CHN_TRANSMISSION_END;
    769c:	c1 1f b2 f0 	andx.w	#-17,	&0x117da;0xfffef
    76a0:	ef ff da 17 
    76a4:	41 18 82 c3 	bicx.w	#0,	&0x117dc;r3 As==00
    76a8:	dc 17 

000076aa <.L23>:
  _disable_interrupts();
    76aa:	32 c2       	dint			
    76ac:	03 43       	nop			

000076ae <.Loc.348.2>:
  asm volatile("nop");
    76ae:	03 43       	nop			

000076b0 <.LBE64>:
    }
    
    chSysLock();
    events |= chEvtWaitAnyTimeoutS(UARTEvtMask, TIME_INFINITE);
    76b0:	4e 43       	clr.b	r14		;
    76b2:	c0 18 1f 42 	movx.w	&0x101dc,r15	;
    76b6:	dc 01 
    76b8:	0c 4f       	mov	r15,	r12	;
    76ba:	0d 43       	clr	r13		;
    76bc:	b0 13 f2 77 	calla	#30706		;0x077f2

000076c0 <.LVL36>:
    76c0:	41 18 82 dc 	bisx.w	r12,	&0x117da;
    76c4:	da 17 
    76c6:	41 18 82 dd 	bisx.w	r13,	&0x117dc;
    76ca:	dc 17 

000076cc <.LBB66>:
  asm volatile("nop");
    76cc:	03 43       	nop			

000076ce <.Loc.356.2>:
  _enable_interrupts();
    76ce:	03 43       	nop			
    76d0:	32 d2       	eint			
    76d2:	03 43       	nop			
    76d4:	80 00 3e 75 	mova	#30014,	r0	;0x0753e

000076d8 <.L11>:
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    76d8:	5d 46 23 00 	mov.b	35(r6),	r13	;0x00023
    76dc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    76e0:	5c 46 25 00 	mov.b	37(r6),	r12	;0x00025
    76e4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    76e8:	5f 46 24 00 	mov.b	36(r6),	r15	;0x00024
    76ec:	0c df       	bis	r15,	r12	;

000076ee <.Loc.136.1>:
          A1_cfg.sc_bitrate = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    76ee:	5e 46 22 00 	mov.b	34(r6),	r14	;0x00022
    76f2:	80 00 90 75 	mova	#30096,	r0	;0x07590

000076f6 <.L16>:
        elyUARTDLLRxStateMachine(c);
    76f6:	48 13       	calla	r8		;

000076f8 <.L38>:
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    76f8:	3d 43       	mov	#-1,	r13	;r3 As==11
    76fa:	cc 07       	mova	r7,	r12	;
    76fc:	4a 13       	calla	r10		;

000076fe <.LVL39>:
    76fe:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    7702:	dd 0c       	cmpa	r12,	r13	;
    7704:	f8 2f       	jc	$-14     	;abs 0x76f6

00007706 <.Loc.153.1>:
      events &= ~CHN_INPUT_AVAILABLE;
    7706:	41 18 a2 c2 	bicx.w	#4,	&0x117da;r2 As==10
    770a:	da 17 
    770c:	41 18 82 c3 	bicx.w	#0,	&0x117dc;r3 As==00
    7710:	dc 17 
    7712:	80 00 ee 75 	mova	#30190,	r0	;0x075ee

00007716 <.L14>:
      while (is_byte(c = sdGetTimeout(&ELY_UART, TIME_IMMEDIATE))) {
    7716:	8a 00 dc 4b 	mova	#19420,	r10	;0x04bdc

0000771a <.Loc.151.1>:
        elyUARTDLLRxStateMachine(c);
    771a:	88 00 2c a8 	mova	#43052,	r8	;0x0a82c
    771e:	80 00 f8 76 	mova	#30456,	r0	;0x076f8

00007722 <.L19>:
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    7722:	8a 00 f4 4d 	mova	#19956,	r10	;0x04df4

00007726 <.Loc.171.1>:
        tx_char = elyUARTDLLTxStateMachine();
    7726:	88 00 68 a7 	mova	#42856,	r8	;0x0a768

0000772a <.L33>:
      while (sdPutTimeout(&ELY_UART, tx_char, TIME_IMMEDIATE) == MSG_OK) {
    772a:	3e 43       	mov	#-1,	r14	;r3 As==11
    772c:	c0 18 5d 42 	movx.b	&0x1158e,r13	;
    7730:	8e 15 
    7732:	cc 09       	mova	r9,	r12	;
    7734:	4a 13       	calla	r10		;

00007736 <.LVL41>:
    7736:	9c 00 00 00 	cmpa	#0,	r12	;
    773a:	10 20       	jnz	$+34     	;abs 0x775c

0000773c <.Loc.171.1>:
        tx_char = elyUARTDLLTxStateMachine();
    773c:	48 13       	calla	r8		;

0000773e <.LVL42>:
    773e:	61 0c 8e 15 	mova	r12,	&71054	; 0x1158e

00007742 <.Loc.172.1>:
        if (!(is_byte(tx_char))) {
    7742:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    7746:	de 0c       	cmpa	r12,	r14	;
    7748:	f0 2f       	jc	$-30     	;abs 0x772a

0000774a <.Loc.173.1>:
          UARTEvtMask &= ~CHN_OUTPUT_EMPTY;
    774a:	c0 18 1c 42 	movx.w	&0x101dc,r12	;
    774e:	dc 01 
    7750:	3c c2       	bic	#8,	r12	;r2 As==11

00007752 <.Loc.174.1>:
          UARTEvtMask |= CHN_TRANSMISSION_END;
    7752:	3c d0 10 00 	bis	#16,	r12	;#0x0010
    7756:	41 18 82 4c 	movx.w	r12,	&0x101dc;
    775a:	dc 01 

0000775c <.L21>:
      events &= ~CHN_OUTPUT_EMPTY;
    775c:	41 18 b2 c2 	bicx.w	#8,	&0x117da;r2 As==11
    7760:	da 17 
    7762:	41 18 82 c3 	bicx.w	#0,	&0x117dc;r3 As==00
    7766:	dc 17 
    7768:	80 00 4c 76 	mova	#30284,	r0	;0x0764c

0000776c <fw_allocator>:

#include "main.h"

static uint8_t fw_storage[elyFWTotalBuffer];

void * fw_allocator(size_t size, unsigned align) {
    776c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000776e <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t curr_index = 0;
  
  if (curr_index + size > elyFWTotalBuffer) {
    776e:	2e 01 fa 17 	mova	&71674,	r14	;0x117fa
    7772:	ca 0e       	mova	r14,	r10	;
    7774:	ea 0c       	adda	r12,	r10	;
    7776:	3c 40 24 04 	mov	#1060,	r12	;#0x0424

0000777a <.LVL1>:
    777a:	dc 0a       	cmpa	r10,	r12	;
    777c:	07 28       	jnc	$+16     	;abs 0x778c

0000777e <.Loc.15.1>:
    return NULL;
  }

  void * result = fw_storage + curr_index;
    777e:	cc 0e       	mova	r14,	r12	;
    7780:	ac 01 fe 17 	adda	#71678,	r12	;0x117fe

00007784 <.LVL2>:
  
  curr_index += size;
    7784:	61 0a fa 17 	mova	r10,	&71674	; 0x117fa

00007788 <.L1>:
  return result;
}
    7788:	0a 16       	popm.a	#1,	r10	;20-bit words
    778a:	10 01       	reta			;

0000778c <.L3>:
    return NULL;
    778c:	4c 43       	clr.b	r12		;
    778e:	80 00 88 77 	mova	#30600,	r0	;0x07788

00007792 <elyFWGetBufferI>:

static MEMORYPOOL_DECL(fw_mpool, elyFWBufferMaxSize, fw_allocator);
static SEMAPHORE_DECL(fw_sem, (cnt_t)(elyFWMaxSlots));

uint8_t * elyFWGetBufferI() {
  uint8_t * result =  chPoolAllocI(&fw_mpool);
    7792:	8c 01 f4 01 	mova	#66036,	r12	;0x101f4
    7796:	b0 13 ce 49 	calla	#18894		;0x049ce

0000779a <.LVL4>:
    779a:	ce 0c       	mova	r12,	r14	;

0000779c <.LVL5>:
  
  if (result == NULL) {
    779c:	9c 00 00 00 	cmpa	#0,	r12	;
    77a0:	06 24       	jz	$+14     	;abs 0x77ae

000077a2 <.Loc.32.1>:
    return NULL;
  }
  
  /* semaphore must be >0 if we got a non-null result */
  chSemFastWaitI(&fw_sem);
    77a2:	41 18 b2 53 	addx.w	#-1,	&0x101f2;r3 As==11
    77a6:	f2 01 

000077a8 <.Loc.33.1>:
  return elyNLToFW(result);
    77a8:	b0 13 0a c5 	calla	#50442		;0x0c50a

000077ac <.LVL6>:
    77ac:	ce 0c       	mova	r12,	r14	;

000077ae <.L4>:
}
    77ae:	cc 0e       	mova	r14,	r12	;
    77b0:	10 01       	reta			;

000077b2 <elyFWGetBuffer>:
  _disable_interrupts();
    77b2:	32 c2       	dint			
    77b4:	03 43       	nop			

000077b6 <.Loc.348.2>:
  asm volatile("nop");
    77b6:	03 43       	nop			

000077b8 <.LBE6>:

uint8_t * elyFWGetBuffer() {
  chSysLock();
  uint8_t * result = elyFWGetBufferI();
    77b8:	b0 13 92 77 	calla	#30610		;0x07792

000077bc <.LBB8>:
  asm volatile("nop");
    77bc:	03 43       	nop			

000077be <.Loc.356.2>:
  _enable_interrupts();
    77be:	03 43       	nop			
    77c0:	32 d2       	eint			
    77c2:	03 43       	nop			

000077c4 <.LBE8>:
  chSysUnlock();
  
  return result;
}
    77c4:	10 01       	reta			;

000077c6 <elyFWFreeBufferI>:
  chDbgAssert(NULL != result, "Guarded pool failure");
  return elyNLToFW(result);
}

void elyFWFreeBufferI(uint8_t * buffer) {
  chPoolFreeI(&fw_mpool, buffer);
    77c6:	cd 0c       	mova	r12,	r13	;
    77c8:	8c 01 f4 01 	mova	#66036,	r12	;0x101f4

000077cc <.LVL17>:
    77cc:	b0 13 0e 4a 	calla	#18958		;0x04a0e

000077d0 <.LVL18>:
  chSemSignalI(&fw_sem);
    77d0:	8c 01 f2 01 	mova	#66034,	r12	;0x101f2
    77d4:	b0 13 8e 47 	calla	#18318		;0x0478e

000077d8 <.LVL19>:
}
    77d8:	10 01       	reta			;

000077da <elyFWFreeBuffer>:
  _disable_interrupts();
    77da:	32 c2       	dint			
    77dc:	03 43       	nop			

000077de <.Loc.348.2>:
  asm volatile("nop");
    77de:	03 43       	nop			

000077e0 <.LBE14>:

void elyFWFreeBuffer(uint8_t * buffer) {
  chSysLock();
  elyFWFreeBufferI(buffer);
    77e0:	b0 13 c6 77 	calla	#30662		;0x077c6

000077e4 <.LVL21>:
  chSchRescheduleS();
    77e4:	b0 13 90 46 	calla	#18064		;0x04690

000077e8 <.LBB16>:
  asm volatile("nop");
    77e8:	03 43       	nop			

000077ea <.Loc.356.2>:
  _enable_interrupts();
    77ea:	03 43       	nop			
    77ec:	32 d2       	eint			
    77ee:	03 43       	nop			

000077f0 <.LBE16>:
  chSysUnlock();
}
    77f0:	10 01       	reta			;

000077f2 <chEvtWaitAnyTimeoutS>:
#include "mych.h"

#if CH_CFG_USE_EVENTS == TRUE
eventmask_t chEvtWaitAnyTimeoutS(eventmask_t mask, systime_t timeout) {
    77f2:	4a 14       	pushm.a	#5,	r10	;20-bit words

000077f4 <.LCFI0>:
    77f4:	06 4c       	mov	r12,	r6	;
    77f6:	07 4d       	mov	r13,	r7	;
    77f8:	0d 4e       	mov	r14,	r13	;

000077fa <.Loc.6.1>:
  chDbgCheckClassS();
  thread_t *ctp = nil.current;
    77fa:	2a 01 ec 12 	mova	&70380,	r10	;0x112ec

000077fe <.Loc.9.1>:
  eventmask_t m;

  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    77fe:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c
    7802:	08 fc       	and	r12,	r8	;
    7804:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    7808:	09 f7       	and	r7,	r9	;

0000780a <.LVL2>:
    780a:	0c 48       	mov	r8,	r12	;

0000780c <.LVL3>:
    780c:	0c d9       	bis	r9,	r12	;
    780e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7810:	12 20       	jnz	$+38     	;abs 0x7836

00007812 <.Loc.10.1>:
    if (TIME_IMMEDIATE == timeout) {
    7812:	3e 93       	cmp	#-1,	r14	;r3 As==11
    7814:	14 24       	jz	$+42     	;abs 0x783e

00007816 <.Loc.14.1>:

      return (eventmask_t)0;
    }
    ctp->u1.ewmask = mask;
    7816:	8a 46 06 00 	mov	r6,	6(r10)	;
    781a:	8a 47 08 00 	mov	r7,	8(r10)	;

0000781e <.Loc.15.1>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    781e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7820:	b0 13 a0 46 	calla	#18080		;0x046a0

00007824 <.LVL4>:
    7824:	9c 00 00 00 	cmpa	#0,	r12	;
    7828:	0a 38       	jl	$+22     	;abs 0x783e

0000782a <.Loc.19.1>:

      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
    782a:	18 4a 0c 00 	mov	12(r10),r8	;0x0000c

0000782e <.LVL5>:
    782e:	08 f6       	and	r6,	r8	;
    7830:	19 4a 0e 00 	mov	14(r10),r9	;0x0000e
    7834:	09 f7       	and	r7,	r9	;

00007836 <.L2>:
  }
  ctp->epmask &= ~m;
    7836:	8a c8 0c 00 	bic	r8,	12(r10)	; 0x000c
    783a:	8a c9 0e 00 	bic	r9,	14(r10)	; 0x000e

0000783e <.L1>:

  return m;
}
    783e:	0c 48       	mov	r8,	r12	;
    7840:	0d 49       	mov	r9,	r13	;
    7842:	46 16       	popm.a	#5,	r10	;20-bit words
    7844:	10 01       	reta			;

00007846 <port_lock>:
  _disable_interrupts();
    7846:	32 c2       	dint			
    7848:	03 43       	nop			

0000784a <.Loc.348.1>:
  asm volatile("nop");
    784a:	03 43       	nop			

0000784c <.Loc.349.1>:
}
    784c:	10 01       	reta			;

0000784e <port_unlock>:
  asm volatile("nop");
    784e:	03 43       	nop			

00007850 <.Loc.356.1>:
  _enable_interrupts();
    7850:	03 43       	nop			
    7852:	32 d2       	eint			
    7854:	03 43       	nop			

00007856 <.Loc.357.1>:
}
    7856:	10 01       	reta			;

00007858 <reset>:
  
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7858:	b0 13 16 c5 	calla	#50454		;0x0c516

0000785c <.LVL1>:
    785c:	b0 13 80 c2 	calla	#49792		;0x0c280

00007860 <.LVL2>:
  active_buffer = NULL; /* have to null before reset */
    7860:	01 18 c2 43 	movx.a	#0,	&0x11e74;r3 As==00
    7864:	74 1e 

00007866 <.Loc.168.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7866:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    786a:	48 a5 20 01 

0000786e <.Loc.169.2>:
}
    786e:	10 01       	reta			;

00007870 <write_failure>:
static void write_failure(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    7870:	2d 4d       	mov	@r13,	r13	;

00007872 <.LVL4>:
    7872:	0e 4d       	mov	r13,	r14	;
    7874:	5e 07       	rrum	#2,	r14	;
    7876:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f

0000787a <.Loc.61.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    787a:	cc 4e 00 00 	mov.b	r14,	0(r12)	;

0000787e <.Loc.62.2>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    787e:	5d f3       	and.b	#1,	r13	;r3 As==01
    7880:	0d 93       	cmp	#0,	r13	;r3 As==00
    7882:	12 20       	jnz	$+38     	;abs 0x78a8
    7884:	0e 4d       	mov	r13,	r14	;

00007886 <.L5>:
    7886:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

0000788a <.Loc.63.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    788a:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    788e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    7892:	02 00 

00007894 <.Loc.64.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    7894:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    7898:	03 00 

0000789a <.Loc.65.2>:
  if (hdr.crc) {
    789a:	0d 93       	cmp	#0,	r13	;r3 As==00
    789c:	04 24       	jz	$+10     	;abs 0x78a6

0000789e <.Loc.66.2>:
    crcGenX25(reply_buff, 6);
    789e:	7d 40 06 00 	mov.b	#6,	r13	;
    78a2:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

000078a6 <.L4>:
}
    78a6:	10 01       	reta			;

000078a8 <.L7>:
  reply_buff[1] = (hdr.crc ? 2 : 0);
    78a8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    78aa:	80 00 86 78 	mova	#30854,	r0	;0x07886

000078ae <store_telem>:
  elyFWFreeBufferI(elyNLFromFW(buff));
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    78ae:	6a 14       	pushm.a	#7,	r10	;20-bit words

000078b0 <.LCFI0>:
    78b0:	b1 00 06 00 	suba	#6,	r1	;

000078b4 <.LCFI1>:
    78b4:	c8 0c       	mova	r12,	r8	;
    78b6:	2a 4d       	mov	@r13,	r10	;

000078b8 <.LVL11>:
    78b8:	91 4d 02 00 	mov	2(r13),	4(r1)	;
    78bc:	04 00 
    78be:	09 4a       	mov	r10,	r9	;
    78c0:	59 0f       	rrum	#4,	r9	;
    78c2:	59 0f       	rrum	#4,	r9	;

000078c4 <.Loc.1472.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    78c4:	4c 4a       	mov.b	r10,	r12	;

000078c6 <.LVL13>:
    78c6:	4f 4c       	mov.b	r12,	r15	;
    78c8:	6f f3       	and.b	#2,	r15	;r3 As==10
    78ca:	47 4f       	mov.b	r15,	r7	;
    78cc:	07 93       	cmp	#0,	r7	;r3 As==00
    78ce:	1f 20       	jnz	$+64     	;abs 0x790e
    78d0:	6d 43       	mov.b	#2,	r13	;r3 As==10

000078d2 <.L12>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    78d2:	1c b3       	bit	#1,	r12	;r3 As==01
    78d4:	1f 20       	jnz	$+64     	;abs 0x7914

000078d6 <.Loc.1473.2>:
    78d6:	4c 43       	clr.b	r12		;

000078d8 <.L13>:
    78d8:	40 18 4e 49 	movx.b	r9,	r14	;
    78dc:	40 18 4e 8f 	subx.b	r15,	r14	;
    78e0:	40 18 46 4e 	movx.b	r14,	r6	;
    78e4:	40 18 46 8c 	subx.b	r12,	r6	;
    78e8:	45 46       	mov.b	r6,	r5	;

000078ea <.LVL15>:
  
  uint8_t * reply_buff = elyFWGetBuffer();
    78ea:	71 0d 00 00 	mova	r13,	0(r1)	;
    78ee:	b0 13 b2 77 	calla	#30642		;0x077b2

000078f2 <.LVL16>:
    78f2:	c4 0c       	mova	r12,	r4	;

000078f4 <.LVL17>:
  if (reply_buff == NULL) {
    78f4:	0d 01       	mova	@r1,	r13	;
    78f6:	9c 00 00 00 	cmpa	#0,	r12	;
    78fa:	0f 20       	jnz	$+32     	;abs 0x791a

000078fc <.Loc.1478.2>:
    /* TODO signal a buffer overflow here */
    elyNLFreeBuffer(elyNLFromFW(buffer));
    78fc:	cc 08       	mova	r8,	r12	;
    78fe:	b0 13 16 c5 	calla	#50454		;0x0c516

00007902 <.LVL18>:
    7902:	b0 13 80 c2 	calla	#49792		;0x0c280

00007906 <.L11>:
  elyTelemPostBufferS(reply_buff, 
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
  
  /* Reply is posted from callback if needed */
}
    7906:	a1 00 06 00 	adda	#6,	r1	;
    790a:	64 16       	popm.a	#7,	r10	;20-bit words
    790c:	10 01       	reta			;

0000790e <.L17>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    790e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    7910:	80 00 d2 78 	mova	#30930,	r0	;0x078d2

00007914 <.L18>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7914:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7916:	80 00 d8 78 	mova	#30936,	r0	;0x078d8

0000791a <.L14>:
  memcpy(reply_buff + 5, buffer + hdr_ext, payload_len);
    791a:	40 18 06 46 	movx.w	r6,	r6	;

0000791e <.LVL23>:
    791e:	40 18 0d 4d 	movx.w	r13,	r13	;
    7922:	ce 06       	mova	r6,	r14	;
    7924:	ed 08       	adda	r8,	r13	;
    7926:	ac 00 05 00 	adda	#5,	r12	;
    792a:	b0 13 42 d3 	calla	#54082		;0x0d342

0000792e <.LVL24>:
  memset(reply_buff + 5 + payload_len, 0, 251 - payload_len);
    792e:	40 18 3e 40 	movx.w	#251,	r14	;0x000fb
    7932:	fb 00 
    7934:	40 18 0e 85 	subx.w	r5,	r14	;
    7938:	4e 0e       	rlam.a	#4,	r14	;
    793a:	4e 0d       	rram.a	#4,	r14	;
    793c:	cc 06       	mova	r6,	r12	;
    793e:	ac 00 05 00 	adda	#5,	r12	;
    7942:	4d 43       	clr.b	r13		;
    7944:	ec 04       	adda	r4,	r12	;
    7946:	b0 13 60 d3 	calla	#54112		;0x0d360

0000794a <.LVL25>:
  telem_stored_hdr = hdr;
    794a:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    794e:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00007952 <.LVL27>:
    7952:	0a d9       	bis	r9,	r10	;
    7954:	41 18 82 4a 	movx.w	r10,	&0x11e68;
    7958:	68 1e 
    795a:	41 18 92 41 	movx.w	4(r1),	&0x11e6a;
    795e:	04 00 6a 1e 

00007962 <.Loc.1486.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7962:	cc 08       	mova	r8,	r12	;
    7964:	b0 13 16 c5 	calla	#50454		;0x0c516

00007968 <.LVL28>:
    7968:	b0 13 80 c2 	calla	#49792		;0x0c280

0000796c <.LVL29>:
  chSysLock();
    796c:	b0 13 46 78 	calla	#30790		;0x07846

00007970 <.LVL30>:
  elyTelemPostBufferS(reply_buff, 
    7970:	07 93       	cmp	#0,	r7	;r3 As==00
    7972:	09 20       	jnz	$+20     	;abs 0x7986
    7974:	8d 00 8e 79 	mova	#31118,	r13	;0x0798e

00007978 <.L16>:
    7978:	cc 04       	mova	r4,	r12	;
    797a:	b0 13 4c a7 	calla	#42828		;0x0a74c

0000797e <.LVL31>:
  chSysUnlock();
    797e:	b0 13 4e 78 	calla	#30798		;0x0784e

00007982 <.LVL32>:
    7982:	80 00 06 79 	mova	#30982,	r0	;0x07906

00007986 <.L19>:
  elyTelemPostBufferS(reply_buff, 
    7986:	8d 00 14 7e 	mova	#32276,	r13	;0x07e14
    798a:	80 00 78 79 	mova	#31096,	r0	;0x07978

0000798e <store_telem_noreply_cb>:
  elyFWFreeBufferI(elyNLFromFW(buff));
    798e:	b0 13 16 c5 	calla	#50454		;0x0c516

00007992 <.LVL34>:
    7992:	b0 13 c6 77 	calla	#30662		;0x077c6

00007996 <.LVL35>:
}
    7996:	10 01       	reta			;

00007998 <upload_fw_noreply_cb>:
    7998:	b0 13 8e 79 	calla	#31118		;0x0798e
    799c:	10 01       	reta			;

0000799e <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    799e:	2a 14       	pushm.a	#3,	r10	;20-bit words

000079a0 <.LCFI2>:
    79a0:	06 14       	pushm.a	#1,	r6	;20-bit words

000079a2 <.LCFI3>:
    79a2:	b1 00 04 00 	suba	#4,	r1	;

000079a6 <.LCFI4>:
    79a6:	c6 0c       	mova	r12,	r6	;
    79a8:	29 4d       	mov	@r13,	r9	;

000079aa <.LVL37>:
    79aa:	1a 4d 02 00 	mov	2(r13),	r10	;

000079ae <.LVL38>:
    79ae:	8e 00 16 c5 	mova	#50454,	r14	;0x0c516
    79b2:	88 00 80 c2 	mova	#49792,	r8	;0x0c280

000079b6 <.Loc.1307.2>:
  if (hdr.reply) {
    79b6:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    79ba:	47 24       	jz	$+144    	;abs 0x7a4a

000079bc <.LBB26>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    79bc:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    79c0:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    79c4:	56 4c 05 00 	mov.b	5(r12),	r6	;
    79c8:	06 dd       	bis	r13,	r6	;
    79ca:	41 18 82 46 	movx.w	r6,	&0x11e66;
    79ce:	66 1e 

000079d0 <.Loc.1311.2>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    79d0:	4e 13       	calla	r14		;

000079d2 <.LVL40>:
    79d2:	48 13       	calla	r8		;

000079d4 <.LVL41>:
    volatile uint8_t * crc_addr = crcStart();
    79d4:	b0 13 96 aa 	calla	#43670		;0x0aa96

000079d8 <.LVL42>:
    79d8:	c8 0c       	mova	r12,	r8	;

000079da <.LVL43>:
    verify_stored_hdr = hdr;
    79da:	41 18 82 49 	movx.w	r9,	&0x11e6c;
    79de:	6c 1e 
    79e0:	41 18 82 4a 	movx.w	r10,	&0x11e6e;
    79e4:	6e 1e 

000079e6 <.Loc.1321.2>:
    chSysLock();
    79e6:	8a 00 46 78 	mova	#30790,	r10	;0x07846

000079ea <.LVL45>:
    79ea:	4a 13       	calla	r10		;

000079ec <.LVL46>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    79ec:	4d 43       	clr.b	r13		;
    79ee:	cc 01       	mova	r1,	r12	;
    79f0:	b0 13 ee b4 	calla	#46318		;0x0b4ee

000079f4 <.LVL47>:
    chSysUnlock();
    79f4:	86 00 4e 78 	mova	#30798,	r6	;0x0784e
    79f8:	46 13       	calla	r6		;

000079fa <.LVL48>:
    req->address = FRAM_FW_BASE; 
    79fa:	0c 01       	mova	@r1,	r12	;
    79fc:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    7a00:	00 00 
    7a02:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

00007a06 <.Loc.1328.2>:
    req->special = 1; /* read to a constant register address */
    7a06:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    7a0a:	04 00 

00007a0c <.Loc.1329.2>:
    req->size = FRAM_FW_SIZE;
    7a0c:	1d 4c 04 00 	mov	4(r12),	r13	;
    7a10:	7d f0 03 00 	and.b	#3,	r13	;
    7a14:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    7a18:	8c 4d 04 00 	mov	r13,	4(r12)	;
    7a1c:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    7a20:	7d d0 03 00 	bis.b	#3,	r13	;
    7a24:	6d c2       	bic.b	#4,	r13	;r2 As==10
    7a26:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

00007a2a <.Loc.1330.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    7a2a:	7c 08 08 00 	mova	r8,	8(r12)	;

00007a2e <.Loc.1331.2>:
    req->callback = verify_fw_cb;
    7a2e:	00 18 fc 40 	movx.a	#32308,	12(r12)	;0x07e34, 0x0000c
    7a32:	34 7e 0c 00 

00007a36 <.Loc.1334.2>:
    chSysLock();
    7a36:	4a 13       	calla	r10		;

00007a38 <.LVL49>:
    elyFramPostRequestS(req);
    7a38:	0c 01       	mova	@r1,	r12	;
    7a3a:	b0 13 ca b4 	calla	#46282		;0x0b4ca

00007a3e <.LVL50>:
    chSysUnlock();
    7a3e:	46 13       	calla	r6		;

00007a40 <.L22>:
}
    7a40:	a1 00 04 00 	adda	#4,	r1	;
    7a44:	06 16       	popm.a	#1,	r6	;20-bit words
    7a46:	28 16       	popm.a	#3,	r10	;20-bit words
    7a48:	10 01       	reta			;

00007a4a <.L23>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    7a4a:	4e 13       	calla	r14		;

00007a4c <.LVL53>:
    7a4c:	48 13       	calla	r8		;

00007a4e <.LVL54>:
}
    7a4e:	80 00 40 7a 	mova	#31296,	r0	;0x07a40

00007a52 <write_success>:
static void write_success(uint8_t * reply_buff, elysium_cmd_hdr_t hdr) {
    7a52:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007a54 <.LCFI5>:
    7a54:	2f 4d       	mov	@r13,	r15	;

00007a56 <.LVL56>:
    7a56:	0d 4f       	mov	r15,	r13	;
    7a58:	5d 07       	rrum	#2,	r13	;
    7a5a:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

00007a5e <.Loc.35.2>:
  reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    7a5e:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00007a62 <.Loc.36.2>:
  reply_buff[2] = bank0p[RegSrcAddrMsb];
    7a62:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    7a66:	dc 4a 51 00 	mov.b	81(r10),2(r12)	;0x00051
    7a6a:	02 00 

00007a6c <.Loc.37.2>:
  reply_buff[3] = bank0p[RegSrcAddrLsb];
    7a6c:	dc 4a 50 00 	mov.b	80(r10),3(r12)	;0x00050
    7a70:	03 00 

00007a72 <.Loc.38.2>:
  reply_buff[4] = 1;
    7a72:	dc 43 04 00 	mov.b	#1,	4(r12)	;r3 As==01

00007a76 <.Loc.39.2>:
  if (hdr.crc) {
    7a76:	40 18 1f b3 	bitx.w	#1,	r15	;r3 As==01
    7a7a:	09 24       	jz	$+20     	;abs 0x7a8e

00007a7c <.LBB29>:
    reply_buff[1] = 3;
    7a7c:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    7a80:	01 00 

00007a82 <.Loc.41.2>:
    crcGenX25(reply_buff, 7);
    7a82:	7d 40 07 00 	mov.b	#7,	r13	;
    7a86:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00007a8a <.L25>:
}
    7a8a:	0a 16       	popm.a	#1,	r10	;20-bit words
    7a8c:	10 01       	reta			;

00007a8e <.L26>:
    reply_buff[1] = 1;
    7a8e:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01

00007a92 <.Loc.46.2>:
}
    7a92:	80 00 8a 7a 	mova	#31370,	r0	;0x07a8a

00007a96 <cancel_fw_eeprom_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    7a96:	c0 18 1c 42 	movx.w	&0x11e64,r12	;
    7a9a:	64 1e 

00007a9c <.LVL64>:
    7a9c:	4d 43       	clr.b	r13		;
    7a9e:	0d 9c       	cmp	r12,	r13	;
    7aa0:	04 38       	jl	$+10     	;abs 0x7aaa

00007aa2 <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    7aa2:	8c 01 64 1e 	mova	#73316,	r12	;0x11e64
    7aa6:	b0 13 8e 47 	calla	#18318		;0x0478e

00007aaa <.L28>:
}
    7aaa:	10 01       	reta			;

00007aac <elyMainMBPost>:
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    7aac:	0e 4d       	mov	r13,	r14	;
    7aae:	cd 0c       	mova	r12,	r13	;

00007ab0 <.LVL67>:
    7ab0:	8c 01 00 02 	mova	#66048,	r12	;0x10200

00007ab4 <.LVL68>:
    7ab4:	b0 13 d6 48 	calla	#18646		;0x048d6

00007ab8 <.LVL69>:
}
    7ab8:	10 01       	reta			;

00007aba <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * fw_buffer) {
    7aba:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007abc <.LCFI6>:
    7abc:	ca 0d       	mova	r13,	r10	;

00007abe <.Loc.1594.2>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (fw_buffer[0] >> 7);
    7abe:	6d 4d       	mov.b	@r13,	r13	;

00007ac0 <.LVL78>:
    7ac0:	09 4d       	mov	r13,	r9	;
    7ac2:	59 0f       	rrum	#4,	r9	;
    7ac4:	59 0b       	rrum	#3,	r9	;

00007ac6 <.LVL79>:
  hdr.reply = ((fw_buffer[0] >> 6) & 0x01);
    7ac6:	0e 4d       	mov	r13,	r14	;
    7ac8:	5e 0f       	rrum	#4,	r14	;
    7aca:	5e 07       	rrum	#2,	r14	;
    7acc:	5e f3       	and.b	#1,	r14	;r3 As==01

00007ace <.LVL80>:
  hdr.opcode = (fw_buffer[0] & 0x3F);
    7ace:	08 4d       	mov	r13,	r8	;
    7ad0:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f

00007ad4 <.LVL81>:
  hdr.length = fw_buffer[1];
    7ad4:	5b 4a 01 00 	mov.b	1(r10),	r11	;

00007ad8 <.LVL82>:
  if (hdr.reply) {
    7ad8:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    7ada:	07 24       	jz	$+16     	;abs 0x7aea

00007adc <.Loc.1599.2>:
    hdr.reply_addr = (((uint16_t)(fw_buffer[2]) << 8) | (fw_buffer[3]));
    7adc:	5f 4a 02 00 	mov.b	2(r10),	r15	;
    7ae0:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    7ae4:	5a 4a 03 00 	mov.b	3(r10),	r10	;

00007ae8 <.LVL83>:
    7ae8:	0f da       	bis	r10,	r15	;

00007aea <.L34>:
  }
  return hdr;
    7aea:	4d 4e       	mov.b	r14,	r13	;

00007aec <.LVL85>:
    7aec:	5d f3       	and.b	#1,	r13	;r3 As==01
    7aee:	4d 5d       	rla.b	r13		;
    7af0:	7d f0 03 00 	and.b	#3,	r13	;
    7af4:	0e 48       	mov	r8,	r14	;

00007af6 <.LVL86>:
    7af6:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    7afa:	4d d9       	bis.b	r9,	r13	;
    7afc:	4d de       	bis.b	r14,	r13	;
    7afe:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    7b02:	cc 4b 01 00 	mov.b	r11,	1(r12)	;
    7b06:	8c 4f 02 00 	mov	r15,	2(r12)	;

00007b0a <.LVL87>:
}
    7b0a:	28 16       	popm.a	#3,	r10	;20-bit words
    7b0c:	10 01       	reta			;

00007b0e <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7b0e:	1a 14       	pushm.a	#2,	r10	;20-bit words

00007b10 <.LCFI7>:
    7b10:	2f 4c       	mov	@r12,	r15	;

00007b12 <.LVL89>:
    7b12:	cc 0d       	mova	r13,	r12	;
    7b14:	0e 4f       	mov	r15,	r14	;
    7b16:	5e 07       	rrum	#2,	r14	;
    7b18:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    7b1c:	4b 4e       	mov.b	r14,	r11	;
    7b1e:	0d 4f       	mov	r15,	r13	;

00007b20 <.LVL90>:
    7b20:	5d 0f       	rrum	#4,	r13	;
    7b22:	5d 0f       	rrum	#4,	r13	;

00007b24 <.Loc.1607.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    7b24:	79 40 2f 00 	mov.b	#47,	r9	;#0x002f
    7b28:	09 9b       	cmp	r11,	r9	;
    7b2a:	07 34       	jge	$+16     	;abs 0x7b3a

00007b2c <.Loc.1608.2>:
    elyErrorSignal(ErrInvalidOpcode);
    7b2c:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

00007b30 <.L181>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    7b30:	b0 13 28 a7 	calla	#42792		;0x0a728

00007b34 <.L69>:
      return false;
    7b34:	4a 43       	clr.b	r10		;
    7b36:	80 00 d0 7b 	mova	#31696,	r0	;0x07bd0

00007b3a <.L39>:
  if (hdr.reply) {
    7b3a:	0a 4b       	mov	r11,	r10	;
    7b3c:	41 18 0a 5a 	rpt #2 { rlax.w	r10		;
    7b40:	0b 4f       	mov	r15,	r11	;
    7b42:	7b f0 03 00 	and.b	#3,	r11	;
    7b46:	0b da       	bis	r10,	r11	;
    7b48:	49 4b       	mov.b	r11,	r9	;
    7b4a:	69 f3       	and.b	#2,	r9	;r3 As==10
    7b4c:	49 93       	cmp.b	#0,	r9	;r3 As==00
    7b4e:	0a 24       	jz	$+22     	;abs 0x7b64

00007b50 <.Loc.1614.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    7b50:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    7b54:	dc 9a 51 00 	cmp.b	81(r10),2(r12)	;0x00051
    7b58:	02 00 
    7b5a:	04 20       	jnz	$+10     	;abs 0x7b64

00007b5c <.Loc.1614.2>:
    7b5c:	dc 9a 50 00 	cmp.b	80(r10),3(r12)	;0x00050
    7b60:	03 00 
    7b62:	e8 27       	jz	$-46     	;abs 0x7b34

00007b64 <.L41>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7b64:	5b f3       	and.b	#1,	r11	;r3 As==01
    7b66:	0b 93       	cmp	#0,	r11	;r3 As==00
    7b68:	20 24       	jz	$+66     	;abs 0x7baa
    7b6a:	6a 43       	mov.b	#2,	r10	;r3 As==10

00007b6c <.L42>:
    7b6c:	40 18 4f 4d 	movx.b	r13,	r15	;
    7b70:	40 18 4f 89 	subx.b	r9,	r15	;
    7b74:	4f 8a       	sub.b	r10,	r15	;
    7b76:	4a 4f       	mov.b	r15,	r10	;

00007b78 <.LVL95>:
  switch(hdr.opcode) {
    7b78:	7e 90 16 00 	cmp.b	#22,	r14	;#0x0016
    7b7c:	49 24       	jz	$+148    	;abs 0x7c10
    7b7e:	79 40 16 00 	mov.b	#22,	r9	;#0x0016
    7b82:	49 9e       	cmp.b	r14,	r9	;
    7b84:	6a 28       	jnc	$+214    	;abs 0x7c5a
    7b86:	7e 90 0a 00 	cmp.b	#10,	r14	;#0x000a
    7b8a:	42 24       	jz	$+134    	;abs 0x7c10
    7b8c:	79 40 0a 00 	mov.b	#10,	r9	;#0x000a
    7b90:	49 9e       	cmp.b	r14,	r9	;
    7b92:	2a 28       	jnc	$+86     	;abs 0x7be8
    7b94:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    7b96:	cb 24       	jz	$+408    	;abs 0x7d2e
    7b98:	69 42       	mov.b	#4,	r9	;r2 As==10
    7b9a:	49 9e       	cmp.b	r14,	r9	;
    7b9c:	09 28       	jnc	$+20     	;abs 0x7bb0
    7b9e:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    7ba0:	37 20       	jnz	$+112    	;abs 0x7c10

00007ba2 <.L49>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    7ba2:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    7ba4:	12 24       	jz	$+38     	;abs 0x7bca
    7ba6:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007baa <.L70>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7baa:	0a 4b       	mov	r11,	r10	;
    7bac:	80 00 6c 7b 	mova	#31596,	r0	;0x07b6c

00007bb0 <.L48>:
  switch(hdr.opcode) {
    7bb0:	7e 90 07 00 	cmp.b	#7,	r14	;
    7bb4:	cc 24       	jz	$+410    	;abs 0x7d4e
    7bb6:	79 40 07 00 	mov.b	#7,	r9	;
    7bba:	49 9e       	cmp.b	r14,	r9	;
    7bbc:	0c 28       	jnc	$+26     	;abs 0x7bd6
    7bbe:	7e 90 05 00 	cmp.b	#5,	r14	;
    7bc2:	bb 24       	jz	$+376    	;abs 0x7d3a
    7bc4:	7e 90 06 00 	cmp.b	#6,	r14	;
    7bc8:	ad 24       	jz	$+348    	;abs 0x7d24

00007bca <.L43>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    7bca:	0b 93       	cmp	#0,	r11	;r3 As==00
    7bcc:	c6 20       	jnz	$+398    	;abs 0x7d5a

00007bce <.L68>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    7bce:	5a 43       	mov.b	#1,	r10	;r3 As==01

00007bd0 <.L40>:
  
}
    7bd0:	4c 4a       	mov.b	r10,	r12	;
    7bd2:	19 16       	popm.a	#2,	r10	;20-bit words
    7bd4:	10 01       	reta			;

00007bd6 <.L51>:
  switch(hdr.opcode) {
    7bd6:	7e 92       	cmp.b	#8,	r14	;r2 As==11
    7bd8:	1b 24       	jz	$+56     	;abs 0x7c10
    7bda:	7e 90 09 00 	cmp.b	#9,	r14	;
    7bde:	f5 23       	jnz	$-20     	;abs 0x7bca

00007be0 <.L178>:
      if (payload_len != 2 && payload_len != 4 && 
    7be0:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    7be2:	18 20       	jnz	$+50     	;abs 0x7c14
    7be4:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007be8 <.L46>:
  switch(hdr.opcode) {
    7be8:	7e 90 10 00 	cmp.b	#16,	r14	;#0x0010
    7bec:	11 24       	jz	$+36     	;abs 0x7c10
    7bee:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    7bf2:	49 9e       	cmp.b	r14,	r9	;
    7bf4:	1b 28       	jnc	$+56     	;abs 0x7c2c
    7bf6:	7e 90 0d 00 	cmp.b	#13,	r14	;#0x000d
    7bfa:	f2 27       	jz	$-26     	;abs 0x7be0
    7bfc:	79 40 0d 00 	mov.b	#13,	r9	;#0x000d
    7c00:	49 9e       	cmp.b	r14,	r9	;
    7c02:	0c 28       	jnc	$+26     	;abs 0x7c1c
    7c04:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    7c08:	eb 27       	jz	$-40     	;abs 0x7be0
    7c0a:	7e 90 0c 00 	cmp.b	#12,	r14	;#0x000c
    7c0e:	dd 23       	jnz	$-68     	;abs 0x7bca

00007c10 <.L44>:
      if (payload_len != 0) {
    7c10:	0a 93       	cmp	#0,	r10	;r3 As==00
    7c12:	db 27       	jz	$-72     	;abs 0x7bca

00007c14 <.L66>:
        elyErrorSignal(ErrInvalidLength);
    7c14:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a

00007c18 <.LVL104>:
    7c18:	80 00 30 7b 	mova	#31536,	r0	;0x07b30

00007c1c <.L56>:
  switch(hdr.opcode) {
    7c1c:	7e 90 0e 00 	cmp.b	#14,	r14	;#0x000e
    7c20:	f7 27       	jz	$-16     	;abs 0x7c10
    7c22:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    7c26:	dc 27       	jz	$-70     	;abs 0x7be0
    7c28:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007c2c <.L55>:
    7c2c:	7e 90 13 00 	cmp.b	#19,	r14	;#0x0013
    7c30:	d7 27       	jz	$-80     	;abs 0x7be0
    7c32:	79 40 13 00 	mov.b	#19,	r9	;#0x0013
    7c36:	49 9e       	cmp.b	r14,	r9	;
    7c38:	08 28       	jnc	$+18     	;abs 0x7c4a
    7c3a:	7e 90 11 00 	cmp.b	#17,	r14	;#0x0011
    7c3e:	d0 27       	jz	$-94     	;abs 0x7be0
    7c40:	7e 90 12 00 	cmp.b	#18,	r14	;#0x0012
    7c44:	e5 27       	jz	$-52     	;abs 0x7c10
    7c46:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007c4a <.L57>:
    7c4a:	7e 90 14 00 	cmp.b	#20,	r14	;#0x0014
    7c4e:	e0 27       	jz	$-62     	;abs 0x7c10
    7c50:	7e 90 15 00 	cmp.b	#21,	r14	;#0x0015
    7c54:	a6 27       	jz	$-178    	;abs 0x7ba2
    7c56:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007c5a <.L45>:
    7c5a:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    7c5e:	c0 27       	jz	$-126    	;abs 0x7be0
    7c60:	79 40 24 00 	mov.b	#36,	r9	;#0x0024
    7c64:	49 9e       	cmp.b	r14,	r9	;
    7c66:	33 28       	jnc	$+104    	;abs 0x7cce
    7c68:	7e 90 1c 00 	cmp.b	#28,	r14	;#0x001c
    7c6c:	60 24       	jz	$+194    	;abs 0x7d2e
    7c6e:	79 40 1c 00 	mov.b	#28,	r9	;#0x001c
    7c72:	49 9e       	cmp.b	r14,	r9	;
    7c74:	1d 28       	jnc	$+60     	;abs 0x7cb0
    7c76:	7e 90 19 00 	cmp.b	#25,	r14	;#0x0019
    7c7a:	12 24       	jz	$+38     	;abs 0x7ca0
    7c7c:	7a 40 19 00 	mov.b	#25,	r10	;#0x0019
    7c80:	4a 9e       	cmp.b	r14,	r10	;
    7c82:	08 28       	jnc	$+18     	;abs 0x7c94
    7c84:	7e 90 17 00 	cmp.b	#23,	r14	;#0x0017
    7c88:	ab 27       	jz	$-168    	;abs 0x7be0
    7c8a:	7e 90 18 00 	cmp.b	#24,	r14	;#0x0018
    7c8e:	89 27       	jz	$-236    	;abs 0x7ba2
    7c90:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007c94 <.L61>:
    7c94:	7e 90 1a 00 	cmp.b	#26,	r14	;#0x001a
    7c98:	4a 24       	jz	$+150    	;abs 0x7d2e
    7c9a:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    7c9e:	95 23       	jnz	$-212    	;abs 0x7bca

00007ca0 <.L60>:
      if (payload_len < 4 || payload_len > 251) {
    7ca0:	7f 50 fc ff 	add.b	#-4,	r15	;#0xfffc

00007ca4 <.LVL106>:
    7ca4:	7e 40 f7 ff 	mov.b	#-9,	r14	;#0xfff7
    7ca8:	4e 9f       	cmp.b	r15,	r14	;
    7caa:	8f 2f       	jc	$-224    	;abs 0x7bca
    7cac:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007cb0 <.L59>:
  switch(hdr.opcode) {
    7cb0:	79 40 22 00 	mov.b	#34,	r9	;#0x0022
    7cb4:	49 9e       	cmp.b	r14,	r9	;
    7cb6:	ac 2b       	jnc	$-166    	;abs 0x7c10
    7cb8:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    7cbc:	38 2c       	jc	$+114    	;abs 0x7d2e
    7cbe:	7e 90 1d 00 	cmp.b	#29,	r14	;#0x001d
    7cc2:	6f 27       	jz	$-288    	;abs 0x7ba2
    7cc4:	7e 90 1e 00 	cmp.b	#30,	r14	;#0x001e
    7cc8:	80 23       	jnz	$-254    	;abs 0x7bca
    7cca:	80 00 10 7c 	mova	#31760,	r0	;0x07c10

00007cce <.L58>:
    7cce:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    7cd2:	e6 27       	jz	$-50     	;abs 0x7ca0
    7cd4:	79 40 2a 00 	mov.b	#42,	r9	;#0x002a
    7cd8:	49 9e       	cmp.b	r14,	r9	;
    7cda:	0e 28       	jnc	$+30     	;abs 0x7cf8
    7cdc:	7e 90 27 00 	cmp.b	#39,	r14	;#0x0027
    7ce0:	60 27       	jz	$-318    	;abs 0x7ba2
    7ce2:	7e 90 27 00 	cmp.b	#39,	r14	;#0x0027
    7ce6:	94 2b       	jnc	$-214    	;abs 0x7c10
    7ce8:	7e 90 28 00 	cmp.b	#40,	r14	;#0x0028
    7cec:	91 27       	jz	$-220    	;abs 0x7c10
    7cee:	7e 90 29 00 	cmp.b	#41,	r14	;#0x0029
    7cf2:	57 27       	jz	$-336    	;abs 0x7ba2
    7cf4:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007cf8 <.L62>:
    7cf8:	79 40 2d 00 	mov.b	#45,	r9	;#0x002d
    7cfc:	49 9e       	cmp.b	r14,	r9	;
    7cfe:	07 28       	jnc	$+16     	;abs 0x7d0e
    7d00:	7e 90 2c 00 	cmp.b	#44,	r14	;#0x002c
    7d04:	85 2f       	jc	$-244    	;abs 0x7c10

00007d06 <.Loc.1660.2>:
      if (payload_len != 2) {
    7d06:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7d08:	60 27       	jz	$-318    	;abs 0x7bca
    7d0a:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007d0e <.L63>:
  switch(hdr.opcode) {
    7d0e:	7e 90 2e 00 	cmp.b	#46,	r14	;#0x002e
    7d12:	0d 24       	jz	$+28     	;abs 0x7d2e
    7d14:	7e 90 2f 00 	cmp.b	#47,	r14	;#0x002f
    7d18:	58 23       	jnz	$-334    	;abs 0x7bca

00007d1a <.Loc.1688.2>:
      if (payload_len != 2 && payload_len != 4 && 
    7d1a:	7f c2       	bic.b	#8,	r15	;r2 As==11

00007d1c <.LVL109>:
    7d1c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7d1e:	60 23       	jnz	$-318    	;abs 0x7be0
    7d20:	80 00 ca 7b 	mova	#31690,	r0	;0x07bca

00007d24 <.L53>:
      if (payload_len != 3) {
    7d24:	7f 90 03 00 	cmp.b	#3,	r15	;
    7d28:	50 27       	jz	$-350    	;abs 0x7bca
    7d2a:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007d2e <.L47>:
      if (payload_len > 251) {
    7d2e:	7a 40 fb ff 	mov.b	#-5,	r10	;#0xfffb

00007d32 <.L180>:
      if (payload_len < 2 || payload_len > 251) {
    7d32:	4a 9f       	cmp.b	r15,	r10	;
    7d34:	4a 2f       	jc	$-362    	;abs 0x7bca
    7d36:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007d3a <.L52>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    7d3a:	4e 4f       	mov.b	r15,	r14	;
    7d3c:	7e 53       	add.b	#-1,	r14	;r3 As==11
    7d3e:	79 40 fa ff 	mov.b	#-6,	r9	;#0xfffa
    7d42:	49 9e       	cmp.b	r14,	r9	;
    7d44:	67 2b       	jnc	$-304    	;abs 0x7c14

00007d46 <.Loc.1710.2>:
    7d46:	1f b3       	bit	#1,	r15	;r3 As==01
    7d48:	40 23       	jnz	$-382    	;abs 0x7bca
    7d4a:	80 00 14 7c 	mova	#31764,	r0	;0x07c14

00007d4e <.L50>:
      if (payload_len < 2 || payload_len > 251) {
    7d4e:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

00007d52 <.LVL115>:
    7d52:	7a 40 f9 ff 	mov.b	#-7,	r10	;#0xfff9
    7d56:	80 00 32 7d 	mova	#32050,	r0	;0x07d32

00007d5a <.L67>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    7d5a:	2d 53       	incd	r13		;
    7d5c:	4d 0e       	rlam.a	#4,	r13	;
    7d5e:	4d 0d       	rram.a	#4,	r13	;
    7d60:	b0 13 44 aa 	calla	#43588		;0x0aa44

00007d64 <.LVL119>:
    7d64:	4a 4c       	mov.b	r12,	r10	;
    7d66:	0a 93       	cmp	#0,	r10	;r3 As==00
    7d68:	32 23       	jnz	$-410    	;abs 0x7bce

00007d6a <.Loc.1740.2>:
      elyErrorSignal(ErrFCSError);
    7d6a:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    7d6e:	b0 13 28 a7 	calla	#42792		;0x0a728

00007d72 <.LVL120>:
      return false;
    7d72:	80 00 d0 7b 	mova	#31696,	r0	;0x07bd0

00007d76 <elyCmdDispatch>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7d76:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007d78 <.LCFI8>:
    7d78:	b1 00 08 00 	suba	#8,	r1	;

00007d7c <.LCFI9>:
    7d7c:	2f 4c       	mov	@r12,	r15	;

00007d7e <.LVL122>:
    7d7e:	91 4c 02 00 	mov	2(r12),	6(r1)	;
    7d82:	06 00 
    7d84:	cc 0d       	mova	r13,	r12	;
    7d86:	0d 4f       	mov	r15,	r13	;

00007d88 <.LVL123>:
    7d88:	5d 07       	rrum	#2,	r13	;
    7d8a:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

00007d8e <.Loc.1751.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    7d8e:	0a 4d       	mov	r13,	r10	;
    7d90:	0b 43       	clr	r11		;
    7d92:	08 4a       	mov	r10,	r8	;
    7d94:	09 4b       	mov	r11,	r9	;
    7d96:	08 58       	rla	r8		;
    7d98:	09 69       	rlc	r9		;
    7d9a:	08 58       	rla	r8		;
    7d9c:	09 69       	rlc	r9		;
    7d9e:	81 48 00 00 	mov	r8,	0(r1)	;
    7da2:	81 49 02 00 	mov	r9,	2(r1)	;
    7da6:	09 01       	mova	@r1,	r9	;
    7da8:	80 18 5e 49 	movx.a	65630(r9),r14	;0x1005e
    7dac:	5e 00 
    7dae:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    7db2:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

00007db6 <.LVL125>:
    7db6:	0f dd       	bis	r13,	r15	;
    7db8:	81 4f 04 00 	mov	r15,	4(r1)	;
    7dbc:	cd 01       	mova	r1,	r13	;
    7dbe:	ad 00 04 00 	adda	#4,	r13	;
    7dc2:	4e 13       	calla	r14		;

00007dc4 <.LVL126>:
}
    7dc4:	a1 00 08 00 	adda	#8,	r1	;
    7dc8:	28 16       	popm.a	#3,	r10	;20-bit words
    7dca:	10 01       	reta			;

00007dcc <elyCmdSendReplyI>:
  chSysLock();
  elyCmdSendReplyI(buff, dest_addr);
  chSysUnlock();
}

void elyCmdSendReplyI(uint8_t * buff, uint16_t dest_addr) {
    7dcc:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007dce <.LCFI10>:
    7dce:	09 4d       	mov	r13,	r9	;

00007dd0 <.Loc.1761.2>:
  uint8_t length = buff[1];
    7dd0:	58 4c 01 00 	mov.b	1(r12),	r8	;

00007dd4 <.LVL128>:
  uint8_t * buffer = elyNLFromFW(buff);
    7dd4:	b0 13 16 c5 	calla	#50454		;0x0c516

00007dd8 <.LVL129>:
    7dd8:	ca 0c       	mova	r12,	r10	;

00007dda <.Loc.1764.2>:
  
  elyNLSetHeader(buffer, length+4, dest_addr);
    7dda:	0e 49       	mov	r9,	r14	;
    7ddc:	0d 48       	mov	r8,	r13	;
    7dde:	2d 52       	add	#4,	r13	;r2 As==10
    7de0:	b0 13 aa c3 	calla	#50090		;0x0c3aa

00007de4 <.LVL131>:
  switch (elyNLGetDest(buffer, dest_addr)) {
    7de4:	0d 49       	mov	r9,	r13	;
    7de6:	cc 0a       	mova	r10,	r12	;
    7de8:	b0 13 1a c3 	calla	#49946		;0x0c31a

00007dec <.LVL132>:
    7dec:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    7dee:	0d 24       	jz	$+28     	;abs 0x7e0a
    7df0:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7df2:	09 20       	jnz	$+20     	;abs 0x7e06

00007df4 <.Loc.1767.2>:
    case ELY_DEST_RF:
      if (MSG_OK != elyRFPostI(buffer)) {
    7df4:	cc 0a       	mova	r10,	r12	;
    7df6:	b0 13 3c b5 	calla	#46396		;0x0b53c

00007dfa <.L194>:
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
      }
      break;
    case ELY_DEST_UART:
      if (MSG_OK != elyUARTPostI(buffer)) {
    7dfa:	9c 00 00 00 	cmpa	#0,	r12	;
    7dfe:	03 24       	jz	$+8      	;abs 0x7e06

00007e00 <.Loc.1779.2>:
        /* We should never hit this because everyone allocates the same amount */
        chDbgAssert(false, "internal buffer overflows should be impossible");
        /* If we hit it anyway, free the buffer and weep */
        elyFWFreeBuffer(buffer);
    7e00:	cc 0a       	mova	r10,	r12	;
    7e02:	b0 13 da 77 	calla	#30682		;0x077da

00007e06 <.L183>:
      break;
    default:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
}
    7e06:	28 16       	popm.a	#3,	r10	;20-bit words
    7e08:	10 01       	reta			;

00007e0a <.L185>:
      if (MSG_OK != elyUARTPostI(buffer)) {
    7e0a:	cc 0a       	mova	r10,	r12	;
    7e0c:	b0 13 50 74 	calla	#29776		;0x07450

00007e10 <.LVL135>:
    7e10:	80 00 fa 7d 	mova	#32250,	r0	;0x07dfa

00007e14 <store_telem_reply_cb>:
static void store_telem_reply_cb(uint8_t * buff) {
    7e14:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007e16 <.LCFI11>:
    7e16:	08 14       	pushm.a	#1,	r8	;20-bit words

00007e18 <.LCFI12>:
    7e18:	c8 0c       	mova	r12,	r8	;

00007e1a <.Loc.1456.2>:
  write_success(buff, telem_stored_hdr); /* crc */
    7e1a:	8a 01 68 1e 	mova	#73320,	r10	;0x11e68
    7e1e:	cd 0a       	mova	r10,	r13	;
    7e20:	b0 13 52 7a 	calla	#31314		;0x07a52

00007e24 <.LVL137>:
  elyCmdSendReplyI(buff, telem_stored_hdr.reply_addr);
    7e24:	1d 4a 02 00 	mov	2(r10),	r13	;
    7e28:	cc 08       	mova	r8,	r12	;
    7e2a:	b0 13 cc 7d 	calla	#32204		;0x07dcc

00007e2e <.LVL138>:
}
    7e2e:	08 16       	popm.a	#1,	r8	;20-bit words
    7e30:	0a 16       	popm.a	#1,	r10	;20-bit words
    7e32:	10 01       	reta			;

00007e34 <verify_fw_cb>:
static void verify_fw_cb(uint8_t * buffer) {
    7e34:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007e36 <.LCFI13>:
    7e36:	06 14       	pushm.a	#1,	r6	;20-bit words

00007e38 <.LCFI14>:
  uint16_t result = crcStop();
    7e38:	b0 13 a2 aa 	calla	#43682		;0x0aaa2

00007e3c <.LVL140>:
    7e3c:	09 4c       	mov	r12,	r9	;

00007e3e <.Loc.1288.2>:
  uint8_t * reply_buff = elyFWGetBufferI();
    7e3e:	b0 13 92 77 	calla	#30610		;0x07792

00007e42 <.LVL142>:
    7e42:	c6 0c       	mova	r12,	r6	;

00007e44 <.Loc.1289.2>:
  if (reply_buff == NULL) {
    7e44:	9c 00 00 00 	cmpa	#0,	r12	;
    7e48:	10 24       	jz	$+34     	;abs 0x7e6a
    7e4a:	88 01 70 1e 	mova	#73328,	r8	;0x11e70
    7e4e:	8a 00 cc 7d 	mova	#32204,	r10	;0x07dcc

00007e52 <.Loc.1295.2>:
    write_success(reply_buff, verify_stored_hdr);
    7e52:	8d 01 6c 1e 	mova	#73324,	r13	;0x11e6c

00007e56 <.Loc.1294.2>:
  if (result == verify_crc) {
    7e56:	c0 18 19 92 	cmpx.w	&0x11e66,r9	;
    7e5a:	66 1e 
    7e5c:	09 20       	jnz	$+20     	;abs 0x7e70

00007e5e <.Loc.1295.2>:
    write_success(reply_buff, verify_stored_hdr);
    7e5e:	b0 13 52 7a 	calla	#31314		;0x07a52

00007e62 <.L202>:
    elyCmdSendReplyI(reply_buff, stored_hdr.reply_addr);
    7e62:	1d 48 02 00 	mov	2(r8),	r13	;
    7e66:	cc 06       	mova	r6,	r12	;
    7e68:	4a 13       	calla	r10		;

00007e6a <.L196>:
}
    7e6a:	06 16       	popm.a	#1,	r6	;20-bit words
    7e6c:	28 16       	popm.a	#3,	r10	;20-bit words
    7e6e:	10 01       	reta			;

00007e70 <.L198>:
    write_failure(reply_buff, verify_stored_hdr);
    7e70:	b0 13 70 78 	calla	#30832		;0x07870

00007e74 <.LVL146>:
    7e74:	80 00 62 7e 	mova	#32354,	r0	;0x07e62

00007e78 <upload_fw_reply_cb>:
static void upload_fw_reply_cb(uint8_t * buff) {
    7e78:	0a 14       	pushm.a	#1,	r10	;20-bit words

00007e7a <.LCFI15>:
    7e7a:	08 14       	pushm.a	#1,	r8	;20-bit words

00007e7c <.LCFI16>:
    7e7c:	c8 0c       	mova	r12,	r8	;

00007e7e <.Loc.1217.2>:
    write_success(buff, stored_hdr);
    7e7e:	8a 01 70 1e 	mova	#73328,	r10	;0x11e70
    7e82:	cd 0a       	mova	r10,	r13	;
    7e84:	b0 13 52 7a 	calla	#31314		;0x07a52

00007e88 <.LVL148>:
    elyCmdSendReplyI(buff, stored_hdr.reply_addr);
    7e88:	1d 4a 02 00 	mov	2(r10),	r13	;
    7e8c:	cc 08       	mova	r8,	r12	;
    7e8e:	b0 13 cc 7d 	calla	#32204		;0x07dcc

00007e92 <.LVL149>:
}
    7e92:	08 16       	popm.a	#1,	r8	;20-bit words
    7e94:	0a 16       	popm.a	#1,	r10	;20-bit words
    7e96:	10 01       	reta			;

00007e98 <elyCmdSendReply>:
void elyCmdSendReply(uint8_t * buff, uint16_t dest_addr) {
    7e98:	b1 00 08 00 	suba	#8,	r1	;

00007e9c <.LCFI17>:
  chSysLock();
    7e9c:	71 0c 04 00 	mova	r12,	4(r1)	;
    7ea0:	71 0d 00 00 	mova	r13,	0(r1)	;
    7ea4:	b0 13 46 78 	calla	#30790		;0x07846

00007ea8 <.LVL151>:
  elyCmdSendReplyI(buff, dest_addr);
    7ea8:	0d 01       	mova	@r1,	r13	;
    7eaa:	3c 01 04 00 	mova	4(r1),	r12	;
    7eae:	b0 13 cc 7d 	calla	#32204		;0x07dcc

00007eb2 <.LVL152>:
  chSysUnlock();
    7eb2:	b0 13 4e 78 	calla	#30798		;0x0784e

00007eb6 <.LVL153>:
}
    7eb6:	a1 00 08 00 	adda	#8,	r1	;
    7eba:	10 01       	reta			;

00007ebc <gen_success>:
static void gen_success(elysium_cmd_hdr_t hdr) {
    7ebc:	2a 14       	pushm.a	#3,	r10	;20-bit words

00007ebe <.LCFI18>:
    7ebe:	b1 00 04 00 	suba	#4,	r1	;

00007ec2 <.LCFI19>:
    7ec2:	28 4c       	mov	@r12,	r8	;

00007ec4 <.LVL155>:
    7ec4:	19 4c 02 00 	mov	2(r12),	r9	;

00007ec8 <.LVL156>:
  uint8_t * reply_buff = elyFWGetBuffer();
    7ec8:	b0 13 b2 77 	calla	#30642		;0x077b2

00007ecc <.LVL157>:
    7ecc:	ca 0c       	mova	r12,	r10	;

00007ece <.Loc.50.2>:
  if (reply_buff == NULL) {
    7ece:	9c 00 00 00 	cmpa	#0,	r12	;
    7ed2:	0b 24       	jz	$+24     	;abs 0x7eea

00007ed4 <.Loc.54.2>:
  write_success(reply_buff, hdr);
    7ed4:	81 48 00 00 	mov	r8,	0(r1)	;
    7ed8:	81 49 02 00 	mov	r9,	2(r1)	;
    7edc:	cd 01       	mova	r1,	r13	;
    7ede:	b0 13 52 7a 	calla	#31314		;0x07a52

00007ee2 <.LVL160>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    7ee2:	0d 49       	mov	r9,	r13	;
    7ee4:	cc 0a       	mova	r10,	r12	;
    7ee6:	b0 13 98 7e 	calla	#32408		;0x07e98

00007eea <.L205>:
}
    7eea:	a1 00 04 00 	adda	#4,	r1	;
    7eee:	28 16       	popm.a	#3,	r10	;20-bit words
    7ef0:	10 01       	reta			;

00007ef2 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7ef2:	6a 14       	pushm.a	#7,	r10	;20-bit words

00007ef4 <.LCFI20>:
    7ef4:	b1 00 1c 00 	suba	#28,	r1	;0x0001c

00007ef8 <.LCFI21>:
    7ef8:	c8 0c       	mova	r12,	r8	;
    7efa:	2a 4d       	mov	@r13,	r10	;

00007efc <.LVL164>:
    7efc:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    7f00:	0a 00 
    7f02:	0c 4a       	mov	r10,	r12	;

00007f04 <.LVL165>:
    7f04:	5c 0f       	rrum	#4,	r12	;
    7f06:	5c 0f       	rrum	#4,	r12	;
    7f08:	81 4c 08 00 	mov	r12,	8(r1)	;

00007f0c <.Loc.1497.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7f0c:	4c 4a       	mov.b	r10,	r12	;
    7f0e:	4e 4c       	mov.b	r12,	r14	;
    7f10:	6e f3       	and.b	#2,	r14	;r3 As==10
    7f12:	4d 4e       	mov.b	r14,	r13	;
    7f14:	81 4d 06 00 	mov	r13,	6(r1)	;
    7f18:	0d 93       	cmp	#0,	r13	;r3 As==00
    7f1a:	49 20       	jnz	$+148    	;abs 0x7fae
    7f1c:	6f 43       	mov.b	#2,	r15	;r3 As==10

00007f1e <.L211>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7f1e:	1c b3       	bit	#1,	r12	;r3 As==01
    7f20:	49 20       	jnz	$+148    	;abs 0x7fb4

00007f22 <.Loc.1498.2>:
    7f22:	4c 43       	clr.b	r12		;

00007f24 <.L212>:
    7f24:	1d 41 08 00 	mov	8(r1),	r13	;
    7f28:	4d 8e       	sub.b	r14,	r13	;
    7f2a:	4d 8c       	sub.b	r12,	r13	;

00007f2c <.LVL168>:
  if (payload_len == 4 || payload_len == 12) {
    7f2c:	4c 4d       	mov.b	r13,	r12	;
    7f2e:	7c c2       	bic.b	#8,	r12	;r2 As==11
    7f30:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7f32:	74 20       	jnz	$+234    	;abs 0x801c

00007f34 <.LVL169>:
    config.index_start = buffer[hdr_ext+2];
    7f34:	40 18 0c 4f 	movx.w	r15,	r12	;
    7f38:	ce 08       	mova	r8,	r14	;
    7f3a:	ee 0c       	adda	r12,	r14	;
    7f3c:	d1 4e 02 00 	mov.b	2(r14),	24(r1)	; 0x0018
    7f40:	18 00 

00007f42 <.Loc.1506.2>:
    config.index_end = buffer[hdr_ext+3];
    7f42:	d1 4e 03 00 	mov.b	3(r14),	25(r1)	; 0x0019
    7f46:	19 00 

00007f48 <.Loc.1512.2>:
  if (payload_len > 4) {
    7f48:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    7f4a:	37 20       	jnz	$+112    	;abs 0x7fba

00007f4c <.L227>:
    config.use_index = true;
    7f4c:	54 43       	mov.b	#1,	r4	;r3 As==01

00007f4e <.L215>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    7f4e:	cc 08       	mova	r8,	r12	;
    7f50:	b0 13 16 c5 	calla	#50454		;0x0c516

00007f54 <.LVL172>:
    7f54:	b0 13 80 c2 	calla	#49792		;0x0c280

00007f58 <.LVL173>:
  chSysLock();
    7f58:	b0 13 46 78 	calla	#30790		;0x07846

00007f5c <.LVL174>:
  elyTelemUpdateConfigS(config);
    7f5c:	81 49 10 00 	mov	r9,	16(r1)	; 0x0010
    7f60:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    7f64:	81 46 14 00 	mov	r6,	20(r1)	; 0x0014
    7f68:	81 45 16 00 	mov	r5,	22(r1)	; 0x0016
    7f6c:	c1 44 1a 00 	mov.b	r4,	26(r1)	; 0x001a
    7f70:	cc 01       	mova	r1,	r12	;
    7f72:	ac 00 10 00 	adda	#16,	r12	;0x00010
    7f76:	b0 13 4a a7 	calla	#42826		;0x0a74a

00007f7a <.LVL175>:
  chSysUnlock();
    7f7a:	b0 13 4e 78 	calla	#30798		;0x0784e

00007f7e <.LVL176>:
  if (hdr.reply) {
    7f7e:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    7f82:	11 24       	jz	$+36     	;abs 0x7fa6

00007f84 <.Loc.1536.2>:
    gen_success(hdr);
    7f84:	19 41 08 00 	mov	8(r1),	r9	;

00007f88 <.LVL177>:
    7f88:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    7f8c:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00007f90 <.LVL178>:
    7f90:	0a d9       	bis	r9,	r10	;
    7f92:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    7f96:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    7f9a:	0e 00 
    7f9c:	cc 01       	mova	r1,	r12	;
    7f9e:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    7fa2:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00007fa6 <.L210>:
}
    7fa6:	a1 00 1c 00 	adda	#28,	r1	;0x0001c
    7faa:	64 16       	popm.a	#7,	r10	;20-bit words
    7fac:	10 01       	reta			;

00007fae <.L220>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7fae:	6f 42       	mov.b	#4,	r15	;r2 As==10
    7fb0:	80 00 1e 7f 	mova	#32542,	r0	;0x07f1e

00007fb4 <.L221>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7fb4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7fb6:	80 00 24 7f 	mova	#32548,	r0	;0x07f24

00007fba <.L214>:
    config.use_timestamp = true;
    7fba:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00007fbe <.LBB35>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    7fbe:	0e 4f       	mov	r15,	r14	;
    7fc0:	3e 50 0b 00 	add	#11,	r14	;#0x000b
    7fc4:	4e 0e       	rlam.a	#4,	r14	;
    7fc6:	4e 0d       	rram.a	#4,	r14	;
    7fc8:	ee 08       	adda	r8,	r14	;
    7fca:	5e 4e ff ff 	mov.b	-1(r14),r14	;
    7fce:	81 4e 04 00 	mov	r14,	4(r1)	;
    7fd2:	ac 00 07 00 	adda	#7,	r12	;
    7fd6:	ce 08       	mova	r8,	r14	;
    7fd8:	ee 0c       	adda	r12,	r14	;
    7fda:	44 43       	clr.b	r4		;

00007fdc <.L216>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    7fdc:	6c 4e       	mov.b	@r14,	r12	;
    7fde:	0d 44       	mov	r4,	r13	;
    7fe0:	71 0e 00 00 	mova	r14,	0(r1)	;
    7fe4:	b0 13 6a d1 	calla	#53610		;0x0d16a
    7fe8:	0d 4c       	mov	r12,	r13	;
    7fea:	0b 4c       	mov	r12,	r11	;
    7fec:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    7ff0:	09 dd       	bis	r13,	r9	;

00007ff2 <.LVL184>:
    7ff2:	07 dc       	bis	r12,	r7	;

00007ff4 <.Loc.1517.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    7ff4:	1c 41 04 00 	mov	4(r1),	r12	;
    7ff8:	0d 44       	mov	r4,	r13	;
    7ffa:	b0 13 6a d1 	calla	#53610		;0x0d16a
    7ffe:	0d 4c       	mov	r12,	r13	;
    8000:	0b 4c       	mov	r12,	r11	;
    8002:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8006:	06 dd       	bis	r13,	r6	;

00008008 <.LVL186>:
    8008:	05 dc       	bis	r12,	r5	;
    800a:	0e 01       	mova	@r1,	r14	;
    800c:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    8010:	34 52       	add	#8,	r4	;r2 As==11

00008012 <.Loc.1515.2>:
      for (int i = 0; i < 4; i++) {
    8012:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    8016:	e2 23       	jnz	$-58     	;abs 0x7fdc
    8018:	80 00 4c 7f 	mova	#32588,	r0	;0x07f4c

0000801c <.L213>:
  if (payload_len > 4) {
    801c:	6c 42       	mov.b	#4,	r12	;r2 As==10
    801e:	4c 9d       	cmp.b	r13,	r12	;
    8020:	30 2c       	jc	$+98     	;abs 0x8082

00008022 <.Loc.1513.2>:
    config.use_timestamp = true;
    8022:	d1 43 1b 00 	mov.b	#1,	27(r1)	;r3 As==01, 0x001b

00008026 <.LBB36>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    8026:	0c 4f       	mov	r15,	r12	;
    8028:	3c 50 09 00 	add	#9,	r12	;
    802c:	4c 0e       	rlam.a	#4,	r12	;
    802e:	4c 0d       	rram.a	#4,	r12	;
    8030:	ec 08       	adda	r8,	r12	;
    8032:	5c 4c ff ff 	mov.b	-1(r12),r12	;
    8036:	81 4c 04 00 	mov	r12,	4(r1)	;
    803a:	40 18 0e 4f 	movx.w	r15,	r14	;
    803e:	ae 00 05 00 	adda	#5,	r14	;
    8042:	ee 08       	adda	r8,	r14	;
    8044:	44 43       	clr.b	r4		;

00008046 <.L217>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    8046:	6c 4e       	mov.b	@r14,	r12	;
    8048:	0d 44       	mov	r4,	r13	;
    804a:	71 0e 00 00 	mova	r14,	0(r1)	;
    804e:	b0 13 6a d1 	calla	#53610		;0x0d16a
    8052:	0d 4c       	mov	r12,	r13	;
    8054:	0b 4c       	mov	r12,	r11	;
    8056:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    805a:	09 dd       	bis	r13,	r9	;

0000805c <.LVL191>:
    805c:	07 dc       	bis	r12,	r7	;

0000805e <.Loc.1523.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    805e:	1c 41 04 00 	mov	4(r1),	r12	;
    8062:	0d 44       	mov	r4,	r13	;
    8064:	b0 13 6a d1 	calla	#53610		;0x0d16a
    8068:	0d 4c       	mov	r12,	r13	;
    806a:	0b 4c       	mov	r12,	r11	;
    806c:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8070:	06 dd       	bis	r13,	r6	;

00008072 <.LVL193>:
    8072:	05 dc       	bis	r12,	r5	;
    8074:	0e 01       	mova	@r1,	r14	;
    8076:	ae 0f ff ff 	adda	#1048575,r14	;0xfffff
    807a:	34 52       	add	#8,	r4	;r2 As==11

0000807c <.Loc.1521.2>:
      for (int i = 0; i < 4; i++) {
    807c:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    8080:	e2 23       	jnz	$-58     	;abs 0x8046

00008082 <.L228>:
    config.use_index = false;
    8082:	44 43       	clr.b	r4		;
    8084:	80 00 4e 7f 	mova	#32590,	r0	;0x07f4e

00008088 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    8088:	4a 14       	pushm.a	#5,	r10	;20-bit words

0000808a <.LCFI22>:
    808a:	04 14       	pushm.a	#1,	r4	;20-bit words

0000808c <.LCFI23>:
    808c:	b1 00 04 00 	suba	#4,	r1	;

00008090 <.LCFI24>:
    8090:	c6 0c       	mova	r12,	r6	;
    8092:	27 4d       	mov	@r13,	r7	;

00008094 <.LVL196>:
    8094:	1a 4d 02 00 	mov	2(r13),	r10	;

00008098 <.LVL197>:
    8098:	09 47       	mov	r7,	r9	;

0000809a <.Loc.1438.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    809a:	84 00 16 c5 	mova	#50454,	r4	;0x0c516
    809e:	44 13       	calla	r4		;

000080a0 <.LVL199>:
    80a0:	88 00 80 c2 	mova	#49792,	r8	;0x0c280
    80a4:	48 13       	calla	r8		;

000080a6 <.LVL200>:
  if (hdr.reply) {
    80a6:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    80aa:	13 24       	jz	$+40     	;abs 0x80d2

000080ac <.Loc.1442.2>:
    gen_success(hdr);
    80ac:	81 47 00 00 	mov	r7,	0(r1)	;
    80b0:	81 4a 02 00 	mov	r10,	2(r1)	;
    80b4:	cc 01       	mova	r1,	r12	;
    80b6:	b0 13 bc 7e 	calla	#32444		;0x07ebc

000080ba <.L231>:
  bootloader = 1;
    80ba:	40 18 d2 43 	movx.b	#1,	&0x019fc;r3 As==01
    80be:	fc 19 

000080c0 <.Loc.1450.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    80c0:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    80c4:	48 a5 20 01 

000080c8 <.Loc.1452.2>:
}
    80c8:	a1 00 04 00 	adda	#4,	r1	;
    80cc:	04 16       	popm.a	#1,	r4	;20-bit words
    80ce:	46 16       	popm.a	#5,	r10	;20-bit words
    80d0:	10 01       	reta			;

000080d2 <.L230>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    80d2:	cc 06       	mova	r6,	r12	;
    80d4:	44 13       	calla	r4		;

000080d6 <.LVL204>:
    80d6:	48 13       	calla	r8		;

000080d8 <.LVL205>:
    80d8:	80 00 ba 80 	mova	#32954,	r0	;0x080ba

000080dc <cancel_fw>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    80dc:	6a 14       	pushm.a	#7,	r10	;20-bit words

000080de <.LCFI25>:
    80de:	b1 00 08 00 	suba	#8,	r1	;

000080e2 <.LCFI26>:
    80e2:	2a 4d       	mov	@r13,	r10	;

000080e4 <.LVL207>:
    80e4:	17 4d 02 00 	mov	2(r13),	r7	;

000080e8 <.LVL208>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    80e8:	b0 13 16 c5 	calla	#50454		;0x0c516

000080ec <.LVL209>:
    80ec:	b0 13 80 c2 	calla	#49792		;0x0c280

000080f0 <.LVL210>:
    80f0:	38 40 00 04 	mov	#1024,	r8	;#0x0400
    80f4:	59 43       	mov.b	#1,	r9	;r3 As==01

000080f6 <.LBB40>:
    chSysLock();
    80f6:	84 00 46 78 	mova	#30790,	r4	;0x07846

000080fa <.Loc.1404.2>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    80fa:	85 00 ee b4 	mova	#46318,	r5	;0x0b4ee

000080fe <.L237>:
    chSysLock();
    80fe:	44 13       	calla	r4		;

00008100 <.LVL212>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8100:	4d 43       	clr.b	r13		;
    8102:	cc 01       	mova	r1,	r12	;
    8104:	ac 00 04 00 	adda	#4,	r12	;
    8108:	45 13       	calla	r5		;

0000810a <.LVL213>:
    chSysUnlock();
    810a:	86 00 4e 78 	mova	#30798,	r6	;0x0784e
    810e:	46 13       	calla	r6		;

00008110 <.LVL214>:
    req->address = FRAM_FW_BASE + (i * 128); 
    8110:	3c 01 04 00 	mova	4(r1),	r12	;
    8114:	8c 48 00 00 	mov	r8,	0(r12)	;
    8118:	8c 49 02 00 	mov	r9,	2(r12)	;

0000811c <.Loc.1409.2>:
    req->read = 0;
    811c:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    8120:	6d c3       	bic.b	#2,	r13	;r3 As==10

00008122 <.Loc.1410.2>:
    req->special = 1; /* write a constant value */
    8122:	5d d3       	bis.b	#1,	r13	;r3 As==01
    8124:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008128 <.Loc.1411.2>:
    req->size = 128;
    8128:	1d 4c 04 00 	mov	4(r12),	r13	;
    812c:	7d f0 03 00 	and.b	#3,	r13	;
    8130:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    8134:	8c 4d 04 00 	mov	r13,	4(r12)	;
    8138:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    813c:	06 00 

0000813e <.Loc.1412.2>:
    req->buffer = &fill_value; 
    813e:	80 18 fc 40 	movx.a	#72738,	8(r12)	;0x11c22
    8142:	22 1c 08 00 

00008146 <.Loc.1413.2>:
    req->callback = cancel_fw_eeprom_cb;
    8146:	00 18 fc 40 	movx.a	#31382,	12(r12)	;0x07a96, 0x0000c
    814a:	96 7a 0c 00 

0000814e <.Loc.1417.2>:
    chSysLock();
    814e:	44 13       	calla	r4		;

00008150 <.LVL215>:
    elyFramPostRequestS(req);
    8150:	3c 01 04 00 	mova	4(r1),	r12	;
    8154:	b0 13 ca b4 	calla	#46282		;0x0b4ca

00008158 <.LVL216>:
    chSysUnlock();
    8158:	46 13       	calla	r6		;

0000815a <.LBB41>:
  return chSemWaitTimeout(&bsp->sem, time);
    815a:	4d 43       	clr.b	r13		;
    815c:	8c 01 64 1e 	mova	#73316,	r12	;0x11e64
    8160:	b0 13 28 47 	calla	#18216		;0x04728

00008164 <.LVL218>:
    8164:	38 50 80 00 	add	#128,	r8	;#0x0080
    8168:	09 63       	adc	r9		;

0000816a <.LBE41>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    816a:	08 93       	cmp	#0,	r8	;r3 As==00
    816c:	c8 23       	jnz	$-110    	;abs 0x80fe
    816e:	29 93       	cmp	#2,	r9	;r3 As==10
    8170:	c6 23       	jnz	$-114    	;abs 0x80fe

00008172 <.LBE40>:
  if (hdr.reply) {
    8172:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    8176:	07 24       	jz	$+16     	;abs 0x8186

00008178 <.Loc.1427.2>:
    gen_success(hdr);
    8178:	81 4a 00 00 	mov	r10,	0(r1)	;
    817c:	81 47 02 00 	mov	r7,	2(r1)	;
    8180:	cc 01       	mova	r1,	r12	;
    8182:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008186 <.L232>:
}
    8186:	a1 00 08 00 	adda	#8,	r1	;
    818a:	64 16       	popm.a	#7,	r10	;20-bit words
    818c:	10 01       	reta			;

0000818e <reset_event>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    818e:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008190 <.LCFI27>:
    8190:	b1 00 04 00 	suba	#4,	r1	;

00008194 <.LCFI28>:
    8194:	c8 0c       	mova	r12,	r8	;
    8196:	29 4d       	mov	@r13,	r9	;

00008198 <.LVL223>:
    8198:	1a 4d 02 00 	mov	2(r13),	r10	;

0000819c <.LVL224>:
    819c:	07 49       	mov	r9,	r7	;

0000819e <.Loc.1024.2>:
  elyEventReset();
    819e:	b0 13 3a a7 	calla	#42810		;0x0a73a

000081a2 <.LVL226>:
  if (hdr.reply) {
    81a2:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    81a6:	07 24       	jz	$+16     	;abs 0x81b6

000081a8 <.Loc.1028.2>:
    gen_success(hdr);
    81a8:	81 49 00 00 	mov	r9,	0(r1)	;
    81ac:	81 4a 02 00 	mov	r10,	2(r1)	;
    81b0:	cc 01       	mova	r1,	r12	;
    81b2:	b0 13 bc 7e 	calla	#32444		;0x07ebc

000081b6 <.L240>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    81b6:	cc 08       	mova	r8,	r12	;
    81b8:	b0 13 16 c5 	calla	#50454		;0x0c516

000081bc <.LVL229>:
    81bc:	b0 13 80 c2 	calla	#49792		;0x0c280

000081c0 <.LVL230>:
}
    81c0:	a1 00 04 00 	adda	#4,	r1	;
    81c4:	37 16       	popm.a	#4,	r10	;20-bit words
    81c6:	10 01       	reta			;

000081c8 <reset_chan>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    81c8:	3a 14       	pushm.a	#4,	r10	;20-bit words

000081ca <.LCFI29>:
    81ca:	b1 00 04 00 	suba	#4,	r1	;

000081ce <.LCFI30>:
    81ce:	c8 0c       	mova	r12,	r8	;
    81d0:	29 4d       	mov	@r13,	r9	;

000081d2 <.LVL232>:
    81d2:	1a 4d 02 00 	mov	2(r13),	r10	;

000081d6 <.LVL233>:
    81d6:	07 49       	mov	r9,	r7	;

000081d8 <.Loc.871.2>:
  elyChanReset();
    81d8:	b0 13 48 a7 	calla	#42824		;0x0a748

000081dc <.LVL235>:
  if (hdr.reply) {
    81dc:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    81e0:	07 24       	jz	$+16     	;abs 0x81f0

000081e2 <.Loc.875.2>:
    gen_success(hdr);
    81e2:	81 49 00 00 	mov	r9,	0(r1)	;
    81e6:	81 4a 02 00 	mov	r10,	2(r1)	;
    81ea:	cc 01       	mova	r1,	r12	;
    81ec:	b0 13 bc 7e 	calla	#32444		;0x07ebc

000081f0 <.L245>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    81f0:	cc 08       	mova	r8,	r12	;
    81f2:	b0 13 16 c5 	calla	#50454		;0x0c516

000081f6 <.LVL238>:
    81f6:	b0 13 80 c2 	calla	#49792		;0x0c280

000081fa <.LVL239>:
}
    81fa:	a1 00 04 00 	adda	#4,	r1	;
    81fe:	37 16       	popm.a	#4,	r10	;20-bit words
    8200:	10 01       	reta			;

00008202 <gen_failure>:
static void gen_failure(elysium_cmd_hdr_t hdr) {
    8202:	2a 14       	pushm.a	#3,	r10	;20-bit words

00008204 <.LCFI31>:
    8204:	b1 00 04 00 	suba	#4,	r1	;

00008208 <.LCFI32>:
    8208:	28 4c       	mov	@r12,	r8	;

0000820a <.LVL241>:
    820a:	19 4c 02 00 	mov	2(r12),	r9	;

0000820e <.LVL242>:
  uint8_t * reply_buff = elyFWGetBuffer();
    820e:	b0 13 b2 77 	calla	#30642		;0x077b2

00008212 <.LVL243>:
    8212:	ca 0c       	mova	r12,	r10	;

00008214 <.Loc.72.2>:
  if (reply_buff == NULL) {
    8214:	9c 00 00 00 	cmpa	#0,	r12	;
    8218:	0b 24       	jz	$+24     	;abs 0x8230

0000821a <.Loc.77.2>:
  write_failure(reply_buff, hdr);
    821a:	81 48 00 00 	mov	r8,	0(r1)	;
    821e:	81 49 02 00 	mov	r9,	2(r1)	;
    8222:	cd 01       	mova	r1,	r13	;
    8224:	b0 13 70 78 	calla	#30832		;0x07870

00008228 <.LVL246>:
  elyCmdSendReply(reply_buff, hdr.reply_addr);
    8228:	0d 49       	mov	r9,	r13	;
    822a:	cc 0a       	mova	r10,	r12	;
    822c:	b0 13 98 7e 	calla	#32408		;0x07e98

00008230 <.L249>:
}
    8230:	a1 00 04 00 	adda	#4,	r1	;
    8234:	28 16       	popm.a	#3,	r10	;20-bit words
    8236:	10 01       	reta			;

00008238 <upload_fw>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    8238:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000823a <.LCFI33>:
    823a:	b1 00 14 00 	suba	#20,	r1	;0x00014

0000823e <.LCFI34>:
    823e:	c6 0c       	mova	r12,	r6	;
    8240:	2a 4d       	mov	@r13,	r10	;

00008242 <.LVL250>:
    8242:	91 4d 02 00 	mov	2(r13),	10(r1)	; 0x000a
    8246:	0a 00 
    8248:	09 4a       	mov	r10,	r9	;
    824a:	59 0f       	rrum	#4,	r9	;
    824c:	59 0f       	rrum	#4,	r9	;
    824e:	81 49 04 00 	mov	r9,	4(r1)	;

00008252 <.Loc.1229.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8252:	49 4a       	mov.b	r10,	r9	;
    8254:	81 49 00 00 	mov	r9,	0(r1)	;
    8258:	0c 49       	mov	r9,	r12	;

0000825a <.LVL252>:
    825a:	6c f3       	and.b	#2,	r12	;r3 As==10
    825c:	47 4c       	mov.b	r12,	r7	;
    825e:	07 93       	cmp	#0,	r7	;r3 As==00
    8260:	42 20       	jnz	$+134    	;abs 0x82e6
    8262:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008264 <.L255>:
    8264:	00 18 c1 4d 	movx.a	r13,	6(r1)	;
    8268:	06 00 
    826a:	38 01 06 00 	mova	6(r1),	r8	;
    826e:	e8 06       	adda	r6,	r8	;

00008270 <.Loc.1229.2>:
    8270:	79 40 18 00 	mov.b	#24,	r9	;#0x0018

00008274 <.Loc.1230.2>:
  uint32_t address = 0;
    8274:	44 43       	clr.b	r4		;
    8276:	05 44       	mov	r4,	r5	;

00008278 <.L256>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    8278:	6c 48       	mov.b	@r8,	r12	;
    827a:	0d 43       	clr	r13		;
    827c:	0e 49       	mov	r9,	r14	;
    827e:	0f 43       	clr	r15		;
    8280:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    8284:	0c d4       	bis	r4,	r12	;
    8286:	0d d5       	bis	r5,	r13	;
    8288:	04 4c       	mov	r12,	r4	;

0000828a <.LVL256>:
    828a:	05 4d       	mov	r13,	r5	;

0000828c <.LVL257>:
    828c:	a8 00 01 00 	adda	#1,	r8	;
    8290:	39 50 f8 ff 	add	#-8,	r9	;#0xfff8

00008294 <.Loc.1233.2>:
  for (int i = 0; i < 4; i++) {
    8294:	39 90 f8 ff 	cmp	#-8,	r9	;#0xfff8
    8298:	ef 23       	jnz	$-32     	;abs 0x8278

0000829a <.LBE43>:
  if (address < 0x4400 || address > 0x13FFF) {
    829a:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    829e:	09 4d       	mov	r13,	r9	;
    82a0:	39 63       	addc	#-1,	r9	;r3 As==11
    82a2:	09 93       	cmp	#0,	r9	;r3 As==00
    82a4:	04 20       	jnz	$+10     	;abs 0x82ae
    82a6:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    82aa:	0d 9c       	cmp	r12,	r13	;
    82ac:	25 2c       	jc	$+76     	;abs 0x82f8

000082ae <.L269>:
    if (hdr.reply) {
    82ae:	07 93       	cmp	#0,	r7	;r3 As==00
    82b0:	1d 24       	jz	$+60     	;abs 0x82ec

000082b2 <.Loc.1240.2>:
      gen_failure(hdr);
    82b2:	1c 41 04 00 	mov	4(r1),	r12	;
    82b6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    82ba:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000082be <.LVL258>:
    82be:	0a dc       	bis	r12,	r10	;
    82c0:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    82c4:	91 41 0a 00 	mov	10(r1),	14(r1)	;0x0000a, 0x000e
    82c8:	0e 00 
    82ca:	cc 01       	mova	r1,	r12	;
    82cc:	ac 00 0c 00 	adda	#12,	r12	;0x0000c
    82d0:	b0 13 02 82 	calla	#33282		;0x08202

000082d4 <.L272>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    82d4:	cc 06       	mova	r6,	r12	;
    82d6:	b0 13 16 c5 	calla	#50454		;0x0c516

000082da <.LVL260>:
    82da:	b0 13 80 c2 	calla	#49792		;0x0c280

000082de <.L254>:
}
    82de:	a1 00 14 00 	adda	#20,	r1	;0x00014
    82e2:	64 16       	popm.a	#7,	r10	;20-bit words
    82e4:	10 01       	reta			;

000082e6 <.L266>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    82e6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    82e8:	80 00 64 82 	mova	#33380,	r0	;0x08264

000082ec <.L259>:
      elyErrorSignal(ErrCmdFailure);
    82ec:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    82f0:	b0 13 28 a7 	calla	#42792		;0x0a728

000082f4 <.LVL264>:
    82f4:	80 00 d4 82 	mova	#33492,	r0	;0x082d4

000082f8 <.L271>:
  uint8_t * reply_buff = elyFWGetBuffer();
    82f8:	b0 13 b2 77 	calla	#30642		;0x077b2

000082fc <.LVL265>:
    82fc:	c8 0c       	mova	r12,	r8	;

000082fe <.Loc.1250.2>:
  if (reply_buff == NULL) {
    82fe:	9c 00 00 00 	cmpa	#0,	r12	;
    8302:	e8 27       	jz	$-46     	;abs 0x82d4

00008304 <.Loc.1259.2>:
  chSysLock();
    8304:	b0 13 46 78 	calla	#30790		;0x07846

00008308 <.LVL267>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8308:	0d 49       	mov	r9,	r13	;
    830a:	cc 01       	mova	r1,	r12	;
    830c:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8310:	b0 13 ee b4 	calla	#46318		;0x0b4ee

00008314 <.LVL268>:
  chSysUnlock();
    8314:	b0 13 4e 78 	calla	#30798		;0x0784e

00008318 <.LVL269>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    8318:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    831c:	1d 41 04 00 	mov	4(r1),	r13	;
    8320:	0d 87       	sub	r7,	r13	;
    8322:	40 18 91 b3 	bitx.w	#1,	0(r1)	;r3 As==01
    8326:	00 00 
    8328:	01 24       	jz	$+4      	;abs 0x832c
    832a:	69 43       	mov.b	#2,	r9	;r3 As==10

0000832c <.L263>:
    832c:	0d 89       	sub	r9,	r13	;
    832e:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc
    8332:	0e 4d       	mov	r13,	r14	;
    8334:	4e 0e       	rlam.a	#4,	r14	;
    8336:	4e 0d       	rram.a	#4,	r14	;
    8338:	80 18 7e f0 	andx.a	#131071,r14	;0x1ffff
    833c:	ff ff 
    833e:	71 0e 00 00 	mova	r14,	0(r1)	;
    8342:	0d 4e       	mov	r14,	r13	;
    8344:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8348:	1e 4c 04 00 	mov	4(r12),	r14	;
    834c:	7e f0 03 00 	and.b	#3,	r14	;
    8350:	0e dd       	bis	r13,	r14	;
    8352:	8c 4e 04 00 	mov	r14,	4(r12)	;
    8356:	2e 41       	mov	@r1,	r14	;
    8358:	0f 4e       	mov	r14,	r15	;
    835a:	5f 03       	rrum	#1,	r15	;
    835c:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    8360:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    8364:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    8368:	09 01       	mova	@r1,	r9	;
    836a:	09 14       	pushm.a	#1,	r9	;20-bit words
    836c:	0d 17       	popm	#1,	r13	;16-bit words
    836e:	0d 17       	popm	#1,	r13	;16-bit words
    8370:	5d f3       	and.b	#1,	r13	;r3 As==01
    8372:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    8376:	4e df       	bis.b	r15,	r14	;
    8378:	4e dd       	bis.b	r13,	r14	;
    837a:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000837e <.Loc.1264.2>:
  memcpy(reply_buff, buffer + hdr_ext + 4, req->size);
    837e:	3d 01 06 00 	mova	6(r1),	r13	;
    8382:	ad 00 04 00 	adda	#4,	r13	;
    8386:	ce 09       	mova	r9,	r14	;
    8388:	ed 06       	adda	r6,	r13	;
    838a:	cc 08       	mova	r8,	r12	;
    838c:	b0 13 42 d3 	calla	#54082		;0x0d342

00008390 <.LVL271>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8390:	cc 06       	mova	r6,	r12	;
    8392:	b0 13 16 c5 	calla	#50454		;0x0c516

00008396 <.LVL272>:
    8396:	b0 13 80 c2 	calla	#49792		;0x0c280

0000839a <.LVL273>:
  stored_hdr = hdr;
    839a:	1c 41 04 00 	mov	4(r1),	r12	;
    839e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    83a2:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

000083a6 <.LVL274>:
    83a6:	0a dc       	bis	r12,	r10	;
    83a8:	41 18 82 4a 	movx.w	r10,	&0x11e70;
    83ac:	70 1e 
    83ae:	41 18 92 41 	movx.w	10(r1),	&0x11e72;0x0000a
    83b2:	0a 00 72 1e 

000083b6 <.Loc.1271.2>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    83b6:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    83ba:	34 50 00 c0 	add	#-16384,r4	;#0xc000

000083be <.LVL275>:
    83be:	8c 44 00 00 	mov	r4,	0(r12)	;
    83c2:	05 63       	adc	r5		;
    83c4:	8c 45 02 00 	mov	r5,	2(r12)	;

000083c8 <.Loc.1272.2>:
  req->read = 0;
    83c8:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

000083cc <.Loc.1273.2>:
  req->buffer = reply_buff;
    83cc:	7c 08 08 00 	mova	r8,	8(r12)	;

000083d0 <.Loc.1274.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    83d0:	07 93       	cmp	#0,	r7	;r3 As==00
    83d2:	0e 20       	jnz	$+30     	;abs 0x83f0

000083d4 <.Loc.1274.2>:
    83d4:	8e 00 98 79 	mova	#31128,	r14	;0x07998

000083d8 <.L264>:
    83d8:	7c 0e 0c 00 	mova	r14,	12(r12)	; 0x0000c

000083dc <.Loc.1277.2>:
  chSysLock();
    83dc:	b0 13 46 78 	calla	#30790		;0x07846

000083e0 <.LVL277>:
  elyFramPostRequestS(req);
    83e0:	3c 01 10 00 	mova	16(r1),	r12	;0x00010
    83e4:	b0 13 ca b4 	calla	#46282		;0x0b4ca

000083e8 <.LVL278>:
  chSysUnlock();
    83e8:	b0 13 4e 78 	calla	#30798		;0x0784e

000083ec <.LVL279>:
    83ec:	80 00 de 82 	mova	#33502,	r0	;0x082de

000083f0 <.L268>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    83f0:	8e 00 78 7e 	mova	#32376,	r14	;0x07e78
    83f4:	80 00 d8 83 	mova	#33752,	r0	;0x083d8

000083f8 <set_log>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83f8:	3a 14       	pushm.a	#4,	r10	;20-bit words

000083fa <.LCFI35>:
    83fa:	b1 00 04 00 	suba	#4,	r1	;

000083fe <.LCFI36>:
    83fe:	2a 4d       	mov	@r13,	r10	;

00008400 <.LVL281>:
    8400:	18 4d 02 00 	mov	2(r13),	r8	;

00008404 <.LVL282>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8404:	49 4a       	mov.b	r10,	r9	;
    8406:	69 f3       	and.b	#2,	r9	;r3 As==10
    8408:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    840c:	09 93       	cmp	#0,	r9	;r3 As==00
    840e:	1a 20       	jnz	$+54     	;abs 0x8444
    8410:	6e 43       	mov.b	#2,	r14	;r3 As==10

00008412 <.L274>:
  uint8_t err = buffer[hdr_ext];
    8412:	40 18 0e 4e 	movx.w	r14,	r14	;
    8416:	ee 0c       	adda	r12,	r14	;

00008418 <.LVL284>:
    8418:	67 4e       	mov.b	@r14,	r7	;

0000841a <.LVL285>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    841a:	b0 13 16 c5 	calla	#50454		;0x0c516

0000841e <.LVL286>:
    841e:	b0 13 80 c2 	calla	#49792		;0x0c280

00008422 <.LVL287>:
  if (err > ELY_ALL_ERRORS) {
    8422:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    8426:	4c 97       	cmp.b	r7,	r12	;
    8428:	16 2c       	jc	$+46     	;abs 0x8456

0000842a <.Loc.1191.2>:
    if (hdr.reply) {
    842a:	09 93       	cmp	#0,	r9	;r3 As==00
    842c:	0e 24       	jz	$+30     	;abs 0x844a

0000842e <.Loc.1193.2>:
      gen_failure(hdr);
    842e:	81 4a 00 00 	mov	r10,	0(r1)	;
    8432:	81 48 02 00 	mov	r8,	2(r1)	;
    8436:	cc 01       	mova	r1,	r12	;
    8438:	b0 13 02 82 	calla	#33282		;0x08202

0000843c <.L273>:
}
    843c:	a1 00 04 00 	adda	#4,	r1	;
    8440:	37 16       	popm.a	#4,	r10	;20-bit words
    8442:	10 01       	reta			;

00008444 <.L278>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8444:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8446:	80 00 12 84 	mova	#33810,	r0	;0x08412

0000844a <.L276>:
      elyErrorSignal(ErrCmdFailure);
    844a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    844e:	b0 13 28 a7 	calla	#42792		;0x0a728

00008452 <.LVL293>:
    8452:	80 00 3c 84 	mova	#33852,	r0	;0x0843c

00008456 <.L275>:
  bank0w[RegErrLogLvl] = err;
    8456:	2c 01 26 01 	mova	&65830,	r12	;0x10126
    845a:	cc 47 4d 00 	mov.b	r7,	77(r12)	; 0x004d

0000845e <.Loc.1203.2>:
  chSysLock();
    845e:	b0 13 46 78 	calla	#30790		;0x07846

00008462 <.LVL294>:
  elyErrorSetLogLvlS(err);
    8462:	4c 47       	mov.b	r7,	r12	;
    8464:	b0 13 2e a7 	calla	#42798		;0x0a72e

00008468 <.LVL295>:
  chSysUnlock();
    8468:	b0 13 4e 78 	calla	#30798		;0x0784e

0000846c <.LVL296>:
  if (hdr.reply) {
    846c:	09 93       	cmp	#0,	r9	;r3 As==00
    846e:	e6 27       	jz	$-50     	;abs 0x843c

00008470 <.Loc.1209.2>:
    gen_success(hdr);
    8470:	81 4a 00 00 	mov	r10,	0(r1)	;
    8474:	81 48 02 00 	mov	r8,	2(r1)	;
    8478:	cc 01       	mova	r1,	r12	;
    847a:	b0 13 bc 7e 	calla	#32444		;0x07ebc

0000847e <.LVL298>:
    847e:	80 00 3c 84 	mova	#33852,	r0	;0x0843c

00008482 <set_err>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8482:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008484 <.LCFI37>:
    8484:	b1 00 04 00 	suba	#4,	r1	;

00008488 <.LCFI38>:
    8488:	2a 4d       	mov	@r13,	r10	;

0000848a <.LVL300>:
    848a:	18 4d 02 00 	mov	2(r13),	r8	;

0000848e <.LVL301>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    848e:	49 4a       	mov.b	r10,	r9	;
    8490:	69 f3       	and.b	#2,	r9	;r3 As==10
    8492:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8496:	09 93       	cmp	#0,	r9	;r3 As==00
    8498:	1a 20       	jnz	$+54     	;abs 0x84ce
    849a:	6e 43       	mov.b	#2,	r14	;r3 As==10

0000849c <.L283>:
  uint8_t err = buffer[hdr_ext];
    849c:	40 18 0e 4e 	movx.w	r14,	r14	;
    84a0:	ee 0c       	adda	r12,	r14	;

000084a2 <.LVL303>:
    84a2:	67 4e       	mov.b	@r14,	r7	;

000084a4 <.LVL304>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    84a4:	b0 13 16 c5 	calla	#50454		;0x0c516

000084a8 <.LVL305>:
    84a8:	b0 13 80 c2 	calla	#49792		;0x0c280

000084ac <.LVL306>:
  if (err > ELY_ALL_ERRORS) {
    84ac:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f
    84b0:	4c 97       	cmp.b	r7,	r12	;
    84b2:	16 2c       	jc	$+46     	;abs 0x84e0

000084b4 <.Loc.1132.2>:
    if (hdr.reply) {
    84b4:	09 93       	cmp	#0,	r9	;r3 As==00
    84b6:	0e 24       	jz	$+30     	;abs 0x84d4

000084b8 <.Loc.1134.2>:
      gen_failure(hdr);
    84b8:	81 4a 00 00 	mov	r10,	0(r1)	;
    84bc:	81 48 02 00 	mov	r8,	2(r1)	;
    84c0:	cc 01       	mova	r1,	r12	;
    84c2:	b0 13 02 82 	calla	#33282		;0x08202

000084c6 <.L282>:
}
    84c6:	a1 00 04 00 	adda	#4,	r1	;
    84ca:	37 16       	popm.a	#4,	r10	;20-bit words
    84cc:	10 01       	reta			;

000084ce <.L287>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    84ce:	6e 42       	mov.b	#4,	r14	;r2 As==10
    84d0:	80 00 9c 84 	mova	#33948,	r0	;0x0849c

000084d4 <.L285>:
      elyErrorSignal(ErrCmdFailure);
    84d4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    84d8:	b0 13 28 a7 	calla	#42792		;0x0a728

000084dc <.LVL312>:
    84dc:	80 00 c6 84 	mova	#33990,	r0	;0x084c6

000084e0 <.L284>:
  bank0w[RegErrRptLvl] = err;
    84e0:	2c 01 26 01 	mova	&65830,	r12	;0x10126
    84e4:	cc 47 4c 00 	mov.b	r7,	76(r12)	; 0x004c

000084e8 <.Loc.1144.2>:
  chSysLock();
    84e8:	b0 13 46 78 	calla	#30790		;0x07846

000084ec <.LVL313>:
  elyErrorSetRptLvlS(err);
    84ec:	4c 47       	mov.b	r7,	r12	;
    84ee:	b0 13 2c a7 	calla	#42796		;0x0a72c

000084f2 <.LVL314>:
  chSysUnlock();
    84f2:	b0 13 4e 78 	calla	#30798		;0x0784e

000084f6 <.LVL315>:
  if (hdr.reply) {
    84f6:	09 93       	cmp	#0,	r9	;r3 As==00
    84f8:	e6 27       	jz	$-50     	;abs 0x84c6

000084fa <.Loc.1150.2>:
    gen_success(hdr);
    84fa:	81 4a 00 00 	mov	r10,	0(r1)	;
    84fe:	81 48 02 00 	mov	r8,	2(r1)	;
    8502:	cc 01       	mova	r1,	r12	;
    8504:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008508 <.LVL317>:
    8508:	80 00 c6 84 	mova	#33990,	r0	;0x084c6

0000850c <unlog_event>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    850c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000850e <.LCFI39>:
    850e:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00008512 <.LCFI40>:
    8512:	c8 0c       	mova	r12,	r8	;
    8514:	29 4d       	mov	@r13,	r9	;

00008516 <.LVL319>:
    8516:	14 4d 02 00 	mov	2(r13),	r4	;

0000851a <.LVL320>:
    851a:	07 49       	mov	r9,	r7	;
    851c:	57 0f       	rrum	#4,	r7	;
    851e:	57 0f       	rrum	#4,	r7	;

00008520 <.Loc.991.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8520:	4c 49       	mov.b	r9,	r12	;

00008522 <.LVL322>:
    8522:	1c b3       	bit	#1,	r12	;r3 As==01
    8524:	2b 20       	jnz	$+88     	;abs 0x857c
    8526:	4e 43       	clr.b	r14		;

00008528 <.L292>:
    8528:	6c f3       	and.b	#2,	r12	;r3 As==10
    852a:	45 4c       	mov.b	r12,	r5	;
    852c:	40 18 4d 47 	movx.b	r7,	r13	;
    8530:	40 18 4d 8c 	subx.b	r12,	r13	;
    8534:	4d 8e       	sub.b	r14,	r13	;
    8536:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000853a <.LVL323>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    853a:	05 93       	cmp	#0,	r5	;r3 As==00
    853c:	22 20       	jnz	$+70     	;abs 0x8582

0000853e <.Loc.992.2>:
    853e:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008540 <.L293>:
    8540:	40 18 0e 4a 	movx.w	r10,	r14	;
    8544:	ee 08       	adda	r8,	r14	;

00008546 <.LBB44>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8546:	c6 0e       	mova	r14,	r6	;
    8548:	0c 4a       	mov	r10,	r12	;
    854a:	0d 5a       	add	r10,	r13	;

0000854c <.L294>:
    854c:	0c 9d       	cmp	r13,	r12	;
    854e:	1c 38       	jl	$+58     	;abs 0x8588

00008550 <.LBB45>:
    elyEventUnlog(buffer[i]);
    8550:	86 00 38 a7 	mova	#42808,	r6	;0x0a738

00008554 <.L300>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8554:	0a 9d       	cmp	r13,	r10	;
    8556:	41 38       	jl	$+132    	;abs 0x85da

00008558 <.LBE45>:
  if (hdr.reply) {
    8558:	05 93       	cmp	#0,	r5	;r3 As==00
    855a:	2d 24       	jz	$+92     	;abs 0x85b6

0000855c <.Loc.1015.2>:
    gen_success(hdr);
    855c:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    8560:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00008564 <.LVL328>:
    8564:	09 d7       	bis	r7,	r9	;
    8566:	81 49 08 00 	mov	r9,	8(r1)	;
    856a:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    856e:	cc 01       	mova	r1,	r12	;
    8570:	ac 00 08 00 	adda	#8,	r12	;
    8574:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008578 <.LVL329>:
    8578:	80 00 b6 85 	mova	#34230,	r0	;0x085b6

0000857c <.L303>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    857c:	6e 43       	mov.b	#2,	r14	;r3 As==10
    857e:	80 00 28 85 	mova	#34088,	r0	;0x08528

00008582 <.L304>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8582:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8584:	80 00 40 85 	mova	#34112,	r0	;0x08540

00008588 <.L299>:
    8588:	a6 00 01 00 	adda	#1,	r6	;

0000858c <.LBB46>:
    if (buffer[i] < 0xC0) {
    858c:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    8590:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    8594:	1f 28       	jnc	$+64     	;abs 0x85d4

00008596 <.Loc.997.2>:
      if (hdr.reply) {
    8596:	05 93       	cmp	#0,	r5	;r3 As==00
    8598:	17 24       	jz	$+48     	;abs 0x85c8

0000859a <.Loc.999.2>:
        gen_failure(hdr);
    859a:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    859e:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

000085a2 <.LVL334>:
    85a2:	09 d7       	bis	r7,	r9	;
    85a4:	81 49 08 00 	mov	r9,	8(r1)	;
    85a8:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    85ac:	cc 01       	mova	r1,	r12	;

000085ae <.LVL335>:
    85ae:	ac 00 08 00 	adda	#8,	r12	;
    85b2:	b0 13 02 82 	calla	#33282		;0x08202

000085b6 <.L302>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    85b6:	cc 08       	mova	r8,	r12	;
    85b8:	b0 13 16 c5 	calla	#50454		;0x0c516

000085bc <.LVL337>:
    85bc:	b0 13 80 c2 	calla	#49792		;0x0c280

000085c0 <.LVL338>:
}
    85c0:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    85c4:	64 16       	popm.a	#7,	r10	;20-bit words
    85c6:	10 01       	reta			;

000085c8 <.L296>:
        elyErrorSignal(ErrCmdFailure);
    85c8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

000085cc <.LVL340>:
    85cc:	b0 13 28 a7 	calla	#42792		;0x0a728

000085d0 <.LVL341>:
    85d0:	80 00 b6 85 	mova	#34230,	r0	;0x085b6

000085d4 <.L295>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    85d4:	1c 53       	inc	r12		;
    85d6:	80 00 4c 85 	mova	#34124,	r0	;0x0854c

000085da <.L301>:
    elyEventUnlog(buffer[i]);
    85da:	6c 4e       	mov.b	@r14,	r12	;
    85dc:	71 0d 00 00 	mova	r13,	0(r1)	;
    85e0:	71 0e 04 00 	mova	r14,	4(r1)	;
    85e4:	46 13       	calla	r6		;

000085e6 <.LVL345>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    85e6:	1a 53       	inc	r10		;
    85e8:	3e 01 04 00 	mova	4(r1),	r14	;
    85ec:	ae 00 01 00 	adda	#1,	r14	;
    85f0:	0d 01       	mova	@r1,	r13	;
    85f2:	80 00 54 85 	mova	#34132,	r0	;0x08554

000085f6 <log_event>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    85f6:	6a 14       	pushm.a	#7,	r10	;20-bit words

000085f8 <.LCFI41>:
    85f8:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000085fc <.LCFI42>:
    85fc:	c8 0c       	mova	r12,	r8	;
    85fe:	29 4d       	mov	@r13,	r9	;

00008600 <.LVL348>:
    8600:	1b 4d 02 00 	mov	2(r13),	r11	;

00008604 <.LVL349>:
    8604:	07 49       	mov	r9,	r7	;
    8606:	57 0f       	rrum	#4,	r7	;
    8608:	57 0f       	rrum	#4,	r7	;

0000860a <.Loc.957.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    860a:	4c 49       	mov.b	r9,	r12	;

0000860c <.LVL351>:
    860c:	1c b3       	bit	#1,	r12	;r3 As==01
    860e:	2b 20       	jnz	$+88     	;abs 0x8666
    8610:	4e 43       	clr.b	r14		;

00008612 <.L309>:
    8612:	6c f3       	and.b	#2,	r12	;r3 As==10
    8614:	45 4c       	mov.b	r12,	r5	;
    8616:	40 18 4d 47 	movx.b	r7,	r13	;
    861a:	40 18 4d 8c 	subx.b	r12,	r13	;
    861e:	4d 8e       	sub.b	r14,	r13	;
    8620:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00008624 <.LVL352>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8624:	05 93       	cmp	#0,	r5	;r3 As==00
    8626:	22 20       	jnz	$+70     	;abs 0x866c

00008628 <.Loc.958.2>:
    8628:	6a 43       	mov.b	#2,	r10	;r3 As==10

0000862a <.L310>:
    862a:	40 18 04 4a 	movx.w	r10,	r4	;
    862e:	e4 08       	adda	r8,	r4	;

00008630 <.LBB49>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8630:	c6 04       	mova	r4,	r6	;
    8632:	0e 4a       	mov	r10,	r14	;
    8634:	0d 5a       	add	r10,	r13	;

00008636 <.L311>:
    8636:	0e 9d       	cmp	r13,	r14	;
    8638:	1c 38       	jl	$+58     	;abs 0x8672

0000863a <.LBB50>:
    elyEventLog(buffer[i]);
    863a:	86 00 36 a7 	mova	#42806,	r6	;0x0a736

0000863e <.L318>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    863e:	0a 9d       	cmp	r13,	r10	;
    8640:	55 38       	jl	$+172    	;abs 0x86ec

00008642 <.LBE50>:
  if (hdr.reply) {
    8642:	05 93       	cmp	#0,	r5	;r3 As==00
    8644:	41 24       	jz	$+132    	;abs 0x86c8

00008646 <.Loc.983.2>:
    gen_success(hdr);
    8646:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    864a:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

0000864e <.LVL357>:
    864e:	09 d7       	bis	r7,	r9	;
    8650:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    8654:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    8658:	cc 01       	mova	r1,	r12	;
    865a:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    865e:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008662 <.LVL358>:
    8662:	80 00 c8 86 	mova	#34504,	r0	;0x086c8

00008666 <.L321>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8666:	6e 43       	mov.b	#2,	r14	;r3 As==10
    8668:	80 00 12 86 	mova	#34322,	r0	;0x08612

0000866c <.L322>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    866c:	6a 42       	mov.b	#4,	r10	;r2 As==10
    866e:	80 00 2a 86 	mova	#34346,	r0	;0x0862a

00008672 <.L317>:
    if ((buffer[i] < 0xC0) || 
    8672:	6c 46       	mov.b	@r6,	r12	;
    8674:	4f 4c       	mov.b	r12,	r15	;
    8676:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    867a:	c1 4f 01 00 	mov.b	r15,	1(r1)	;
    867e:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    8682:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    8686:	10 28       	jnc	$+34     	;abs 0x86a8

00008688 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    8688:	4f 4c       	mov.b	r12,	r15	;
    868a:	7f 50 2d 00 	add.b	#45,	r15	;#0x002d
    868e:	c1 4f 01 00 	mov.b	r15,	1(r1)	;

00008692 <.Loc.961.2>:
    if ((buffer[i] < 0xC0) || 
    8692:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    8696:	5f 91 01 00 	cmp.b	1(r1),	r15	;
    869a:	06 2c       	jc	$+14     	;abs 0x86a8
    869c:	a6 00 01 00 	adda	#1,	r6	;

000086a0 <.Loc.963.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    86a0:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

000086a4 <.Loc.962.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    86a4:	4f 9c       	cmp.b	r12,	r15	;
    86a6:	1f 28       	jnc	$+64     	;abs 0x86e6

000086a8 <.L312>:
      if (hdr.reply) {
    86a8:	05 93       	cmp	#0,	r5	;r3 As==00
    86aa:	17 24       	jz	$+48     	;abs 0x86da

000086ac <.Loc.967.2>:
        gen_failure(hdr);
    86ac:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    86b0:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

000086b4 <.LVL363>:
    86b4:	09 d7       	bis	r7,	r9	;
    86b6:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    86ba:	81 4b 0c 00 	mov	r11,	12(r1)	; 0x000c
    86be:	cc 01       	mova	r1,	r12	;
    86c0:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    86c4:	b0 13 02 82 	calla	#33282		;0x08202

000086c8 <.L320>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    86c8:	cc 08       	mova	r8,	r12	;
    86ca:	b0 13 16 c5 	calla	#50454		;0x0c516

000086ce <.LVL365>:
    86ce:	b0 13 80 c2 	calla	#49792		;0x0c280

000086d2 <.LVL366>:
}
    86d2:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    86d6:	64 16       	popm.a	#7,	r10	;20-bit words
    86d8:	10 01       	reta			;

000086da <.L314>:
        elyErrorSignal(ErrCmdFailure);
    86da:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    86de:	b0 13 28 a7 	calla	#42792		;0x0a728

000086e2 <.LVL368>:
    86e2:	80 00 c8 86 	mova	#34504,	r0	;0x086c8

000086e6 <.L313>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    86e6:	1e 53       	inc	r14		;
    86e8:	80 00 36 86 	mova	#34358,	r0	;0x08636

000086ec <.L319>:
    elyEventLog(buffer[i]);
    86ec:	6c 44       	mov.b	@r4,	r12	;
    86ee:	71 0b 02 00 	mova	r11,	2(r1)	;
    86f2:	71 0d 06 00 	mova	r13,	6(r1)	;
    86f6:	46 13       	calla	r6		;

000086f8 <.LVL372>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    86f8:	1a 53       	inc	r10		;
    86fa:	a4 00 01 00 	adda	#1,	r4	;
    86fe:	3d 01 06 00 	mova	6(r1),	r13	;
    8702:	3b 01 02 00 	mova	2(r1),	r11	;
    8706:	80 00 3e 86 	mova	#34366,	r0	;0x0863e

0000870a <event_unsub>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    870a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000870c <.LCFI43>:
    870c:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00008710 <.LCFI44>:
    8710:	c8 0c       	mova	r12,	r8	;
    8712:	29 4d       	mov	@r13,	r9	;

00008714 <.LVL375>:
    8714:	14 4d 02 00 	mov	2(r13),	r4	;

00008718 <.LVL376>:
    8718:	07 49       	mov	r9,	r7	;
    871a:	57 0f       	rrum	#4,	r7	;
    871c:	57 0f       	rrum	#4,	r7	;

0000871e <.Loc.926.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    871e:	4c 49       	mov.b	r9,	r12	;

00008720 <.LVL378>:
    8720:	1c b3       	bit	#1,	r12	;r3 As==01
    8722:	2b 20       	jnz	$+88     	;abs 0x877a
    8724:	4e 43       	clr.b	r14		;

00008726 <.L327>:
    8726:	6c f3       	and.b	#2,	r12	;r3 As==10
    8728:	45 4c       	mov.b	r12,	r5	;
    872a:	40 18 4d 47 	movx.b	r7,	r13	;
    872e:	40 18 4d 8c 	subx.b	r12,	r13	;
    8732:	4d 8e       	sub.b	r14,	r13	;
    8734:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00008738 <.LVL379>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8738:	05 93       	cmp	#0,	r5	;r3 As==00
    873a:	22 20       	jnz	$+70     	;abs 0x8780

0000873c <.Loc.927.2>:
    873c:	6a 43       	mov.b	#2,	r10	;r3 As==10

0000873e <.L328>:
    873e:	40 18 0e 4a 	movx.w	r10,	r14	;
    8742:	ee 08       	adda	r8,	r14	;

00008744 <.LBB54>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8744:	c6 0e       	mova	r14,	r6	;
    8746:	0c 4a       	mov	r10,	r12	;
    8748:	0d 5a       	add	r10,	r13	;

0000874a <.L329>:
    874a:	0c 9d       	cmp	r13,	r12	;
    874c:	1c 38       	jl	$+58     	;abs 0x8786

0000874e <.LBB55>:
    elyEventUnsubscribe(buffer[i]);
    874e:	86 00 34 a7 	mova	#42804,	r6	;0x0a734

00008752 <.L335>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8752:	0a 9d       	cmp	r13,	r10	;
    8754:	41 38       	jl	$+132    	;abs 0x87d8

00008756 <.LBE55>:
  if (hdr.reply) {
    8756:	05 93       	cmp	#0,	r5	;r3 As==00
    8758:	2d 24       	jz	$+92     	;abs 0x87b4

0000875a <.Loc.949.2>:
    gen_success(hdr);
    875a:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    875e:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00008762 <.LVL384>:
    8762:	09 d7       	bis	r7,	r9	;
    8764:	81 49 08 00 	mov	r9,	8(r1)	;
    8768:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    876c:	cc 01       	mova	r1,	r12	;
    876e:	ac 00 08 00 	adda	#8,	r12	;
    8772:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008776 <.LVL385>:
    8776:	80 00 b4 87 	mova	#34740,	r0	;0x087b4

0000877a <.L338>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    877a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    877c:	80 00 26 87 	mova	#34598,	r0	;0x08726

00008780 <.L339>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8780:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8782:	80 00 3e 87 	mova	#34622,	r0	;0x0873e

00008786 <.L334>:
    8786:	a6 00 01 00 	adda	#1,	r6	;

0000878a <.LBB56>:
    if (buffer[i] < 0xC0) {
    878a:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    878e:	5f 96 ff ff 	cmp.b	-1(r6),	r15	;
    8792:	1f 28       	jnc	$+64     	;abs 0x87d2

00008794 <.Loc.931.2>:
      if (hdr.reply) {
    8794:	05 93       	cmp	#0,	r5	;r3 As==00
    8796:	17 24       	jz	$+48     	;abs 0x87c6

00008798 <.Loc.933.2>:
        gen_failure(hdr);
    8798:	47 18 07 57 	rpt #8 { rlax.w	r7		;
    879c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

000087a0 <.LVL390>:
    87a0:	09 d7       	bis	r7,	r9	;
    87a2:	81 49 08 00 	mov	r9,	8(r1)	;
    87a6:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
    87aa:	cc 01       	mova	r1,	r12	;

000087ac <.LVL391>:
    87ac:	ac 00 08 00 	adda	#8,	r12	;
    87b0:	b0 13 02 82 	calla	#33282		;0x08202

000087b4 <.L337>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    87b4:	cc 08       	mova	r8,	r12	;
    87b6:	b0 13 16 c5 	calla	#50454		;0x0c516

000087ba <.LVL393>:
    87ba:	b0 13 80 c2 	calla	#49792		;0x0c280

000087be <.LVL394>:
}
    87be:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    87c2:	64 16       	popm.a	#7,	r10	;20-bit words
    87c4:	10 01       	reta			;

000087c6 <.L331>:
        elyErrorSignal(ErrCmdFailure);
    87c6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

000087ca <.LVL396>:
    87ca:	b0 13 28 a7 	calla	#42792		;0x0a728

000087ce <.LVL397>:
    87ce:	80 00 b4 87 	mova	#34740,	r0	;0x087b4

000087d2 <.L330>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    87d2:	1c 53       	inc	r12		;
    87d4:	80 00 4a 87 	mova	#34634,	r0	;0x0874a

000087d8 <.L336>:
    elyEventUnsubscribe(buffer[i]);
    87d8:	6c 4e       	mov.b	@r14,	r12	;
    87da:	71 0d 00 00 	mova	r13,	0(r1)	;
    87de:	71 0e 04 00 	mova	r14,	4(r1)	;
    87e2:	46 13       	calla	r6		;

000087e4 <.LVL401>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    87e4:	1a 53       	inc	r10		;
    87e6:	3e 01 04 00 	mova	4(r1),	r14	;
    87ea:	ae 00 01 00 	adda	#1,	r14	;
    87ee:	0d 01       	mova	@r1,	r13	;
    87f0:	80 00 52 87 	mova	#34642,	r0	;0x08752

000087f4 <event_sub>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    87f4:	6a 14       	pushm.a	#7,	r10	;20-bit words

000087f6 <.LCFI45>:
    87f6:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

000087fa <.LCFI46>:
    87fa:	c4 0c       	mova	r12,	r4	;
    87fc:	29 4d       	mov	@r13,	r9	;

000087fe <.LVL404>:
    87fe:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    8802:	08 00 
    8804:	06 49       	mov	r9,	r6	;
    8806:	56 0f       	rrum	#4,	r6	;
    8808:	56 0f       	rrum	#4,	r6	;

0000880a <.Loc.883.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    880a:	4c 49       	mov.b	r9,	r12	;

0000880c <.LVL406>:
    880c:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    8810:	36 24       	jz	$+110    	;abs 0x887e
    8812:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008814 <.L344>:
    8814:	6c f3       	and.b	#2,	r12	;r3 As==10
    8816:	4e 4c       	mov.b	r12,	r14	;
    8818:	40 18 47 46 	movx.b	r6,	r7	;
    881c:	40 18 47 8c 	subx.b	r12,	r7	;
    8820:	47 8d       	sub.b	r13,	r7	;
    8822:	37 f0 ff 00 	and	#255,	r7	;#0x00ff

00008826 <.LVL407>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8826:	0e 93       	cmp	#0,	r14	;r3 As==00
    8828:	2d 24       	jz	$+92     	;abs 0x8884

0000882a <.Loc.884.2>:
    882a:	6a 42       	mov.b	#4,	r10	;r2 As==10

0000882c <.L345>:
    882c:	40 18 0c 4a 	movx.w	r10,	r12	;
    8830:	cb 04       	mova	r4,	r11	;
    8832:	eb 0c       	adda	r12,	r11	;

00008834 <.LBB59>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8834:	c8 0b       	mova	r11,	r8	;
    8836:	0d 4a       	mov	r10,	r13	;
    8838:	07 5a       	add	r10,	r7	;

0000883a <.L346>:
    883a:	0d 97       	cmp	r7,	r13	;
    883c:	26 38       	jl	$+78     	;abs 0x888a

0000883e <.LBE59>:
  if (hdr.reply) {
    883e:	0e 93       	cmp	#0,	r14	;r3 As==00
    8840:	5b 24       	jz	$+184    	;abs 0x88f8

00008842 <.Loc.905.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    8842:	55 44 02 00 	mov.b	2(r4),	r5	;
    8846:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    884a:	5c 44 03 00 	mov.b	3(r4),	r12	;

0000884e <.L363>:
    884e:	05 dc       	bis	r12,	r5	;

00008850 <.LBB60>:
      elyEventSubscribe(buffer[i], addr);
    8850:	88 00 32 a7 	mova	#42802,	r8	;0x0a732

00008854 <.L355>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8854:	0a 97       	cmp	r7,	r10	;
    8856:	5a 38       	jl	$+182    	;abs 0x890c

00008858 <.LBE60>:
  if (hdr.reply) {
    8858:	0e 93       	cmp	#0,	r14	;r3 As==00
    885a:	3c 24       	jz	$+122    	;abs 0x88d4

0000885c <.Loc.918.2>:
    gen_success(hdr);
    885c:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    8860:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00008864 <.LVL413>:
    8864:	09 d6       	bis	r6,	r9	;
    8866:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    886a:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    886e:	0c 00 
    8870:	cc 01       	mova	r1,	r12	;
    8872:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    8876:	b0 13 bc 7e 	calla	#32444		;0x07ebc

0000887a <.LVL414>:
    887a:	80 00 d4 88 	mova	#35028,	r0	;0x088d4

0000887e <.L358>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    887e:	4d 43       	clr.b	r13		;
    8880:	80 00 14 88 	mova	#34836,	r0	;0x08814

00008884 <.L359>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8884:	6a 43       	mov.b	#2,	r10	;r3 As==10
    8886:	80 00 2c 88 	mova	#34860,	r0	;0x0882c

0000888a <.L352>:
    if ((buffer[i] < 0xC0) || 
    888a:	6c 48       	mov.b	@r8,	r12	;
    888c:	4f 4c       	mov.b	r12,	r15	;
    888e:	7f 50 40 00 	add.b	#64,	r15	;#0x0040
    8892:	75 40 32 00 	mov.b	#50,	r5	;#0x0032
    8896:	45 9f       	cmp.b	r15,	r5	;
    8898:	0c 28       	jnc	$+26     	;abs 0x88b2

0000889a <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    889a:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

0000889e <.Loc.887.2>:
    if ((buffer[i] < 0xC0) || 
    889e:	75 40 0c 00 	mov.b	#12,	r5	;#0x000c
    88a2:	45 9f       	cmp.b	r15,	r5	;
    88a4:	06 2c       	jc	$+14     	;abs 0x88b2
    88a6:	a8 00 01 00 	adda	#1,	r8	;

000088aa <.Loc.889.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    88aa:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

000088ae <.Loc.888.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    88ae:	45 9c       	cmp.b	r12,	r5	;
    88b0:	20 28       	jnc	$+66     	;abs 0x88f2

000088b2 <.L347>:
      if (hdr.reply) {
    88b2:	0e 93       	cmp	#0,	r14	;r3 As==00
    88b4:	18 24       	jz	$+50     	;abs 0x88e6

000088b6 <.Loc.893.2>:
        gen_failure(hdr);
    88b6:	47 18 06 56 	rpt #8 { rlax.w	r6		;
    88ba:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

000088be <.LVL419>:
    88be:	09 d6       	bis	r6,	r9	;
    88c0:	81 49 0a 00 	mov	r9,	10(r1)	; 0x000a
    88c4:	91 41 08 00 	mov	8(r1),	12(r1)	; 0x000c
    88c8:	0c 00 
    88ca:	cc 01       	mova	r1,	r12	;
    88cc:	ac 00 0a 00 	adda	#10,	r12	;0x0000a
    88d0:	b0 13 02 82 	calla	#33282		;0x08202

000088d4 <.L357>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    88d4:	cc 04       	mova	r4,	r12	;
    88d6:	b0 13 16 c5 	calla	#50454		;0x0c516

000088da <.LVL421>:
    88da:	b0 13 80 c2 	calla	#49792		;0x0c280

000088de <.LVL422>:
}
    88de:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    88e2:	64 16       	popm.a	#7,	r10	;20-bit words
    88e4:	10 01       	reta			;

000088e6 <.L349>:
        elyErrorSignal(ErrCmdFailure);
    88e6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    88ea:	b0 13 28 a7 	calla	#42792		;0x0a728

000088ee <.LVL424>:
    88ee:	80 00 d4 88 	mova	#35028,	r0	;0x088d4

000088f2 <.L348>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    88f2:	1d 53       	inc	r13		;
    88f4:	80 00 3a 88 	mova	#34874,	r0	;0x0883a

000088f8 <.L353>:
    88f8:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    88fc:	55 4c 55 00 	mov.b	85(r12),r5	;0x00055
    8900:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    8904:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    8908:	80 00 4e 88 	mova	#34894,	r0	;0x0884e

0000890c <.L356>:
      elyEventSubscribe(buffer[i], addr);
    890c:	0d 45       	mov	r5,	r13	;
    890e:	6c 4b       	mov.b	@r11,	r12	;
    8910:	71 0b 00 00 	mova	r11,	0(r1)	;
    8914:	71 0e 04 00 	mova	r14,	4(r1)	;
    8918:	48 13       	calla	r8		;

0000891a <.LVL428>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    891a:	1a 53       	inc	r10		;
    891c:	0b 01       	mova	@r1,	r11	;
    891e:	ab 00 01 00 	adda	#1,	r11	;
    8922:	3e 01 04 00 	mova	4(r1),	r14	;
    8926:	80 00 54 88 	mova	#34900,	r0	;0x08854

0000892a <unlog_chan>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    892a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000892c <.LCFI47>:
    892c:	b1 00 06 00 	suba	#6,	r1	;

00008930 <.LCFI48>:
    8930:	c6 0c       	mova	r12,	r6	;
    8932:	29 4d       	mov	@r13,	r9	;

00008934 <.LVL431>:
    8934:	17 4d 02 00 	mov	2(r13),	r7	;

00008938 <.LVL432>:
    8938:	0a 49       	mov	r9,	r10	;
    893a:	5a 0f       	rrum	#4,	r10	;
    893c:	5a 0f       	rrum	#4,	r10	;

0000893e <.Loc.796.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    893e:	4e 49       	mov.b	r9,	r14	;
    8940:	04 4e       	mov	r14,	r4	;
    8942:	54 f3       	and.b	#1,	r4	;r3 As==01
    8944:	04 93       	cmp	#0,	r4	;r3 As==00
    8946:	30 20       	jnz	$+98     	;abs 0x89a8
    8948:	0d 44       	mov	r4,	r13	;

0000894a <.L365>:
    894a:	6e f3       	and.b	#2,	r14	;r3 As==10
    894c:	48 4e       	mov.b	r14,	r8	;

0000894e <.LVL434>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    894e:	08 93       	cmp	#0,	r8	;r3 As==00
    8950:	2e 20       	jnz	$+94     	;abs 0x89ae

00008952 <.Loc.797.2>:
    8952:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008954 <.L366>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8954:	0f 4c       	mov	r12,	r15	;

00008956 <.LVL436>:
    8956:	05 4a       	mov	r10,	r5	;
    8958:	05 5c       	add	r12,	r5	;
    895a:	04 93       	cmp	#0,	r4	;r3 As==00
    895c:	01 24       	jz	$+4      	;abs 0x8960
    895e:	64 43       	mov.b	#2,	r4	;r3 As==10

00008960 <.L368>:
    8960:	05 84       	sub	r4,	r5	;
    8962:	81 45 00 00 	mov	r5,	0(r1)	;
    8966:	40 18 04 4c 	movx.w	r12,	r4	;
    896a:	e4 06       	adda	r6,	r4	;
    896c:	cc 04       	mova	r4,	r12	;

0000896e <.L369>:
    896e:	2f 91       	cmp	@r1,	r15	;
    8970:	21 38       	jl	$+68     	;abs 0x89b4

00008972 <.LBE64>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8972:	40 18 4c 4a 	movx.b	r10,	r12	;
    8976:	40 18 4c 8e 	subx.b	r14,	r12	;

0000897a <.Loc.813.2>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    897a:	4c 8d       	sub.b	r13,	r12	;
    897c:	4d 4c       	mov.b	r12,	r13	;

0000897e <.LVL438>:
    897e:	cc 04       	mova	r4,	r12	;
    8980:	b0 13 42 a7 	calla	#42818		;0x0a742

00008984 <.LVL439>:
  if (hdr.reply) {
    8984:	08 93       	cmp	#0,	r8	;r3 As==00
    8986:	2f 24       	jz	$+96     	;abs 0x89e6

00008988 <.Loc.817.2>:
    gen_success(hdr);
    8988:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;
    898c:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

00008990 <.LVL441>:
    8990:	09 da       	bis	r10,	r9	;
    8992:	81 49 02 00 	mov	r9,	2(r1)	;
    8996:	81 47 04 00 	mov	r7,	4(r1)	;
    899a:	cc 01       	mova	r1,	r12	;
    899c:	ac 00 02 00 	adda	#2,	r12	;
    89a0:	b0 13 bc 7e 	calla	#32444		;0x07ebc

000089a4 <.LVL442>:
    89a4:	80 00 e6 89 	mova	#35302,	r0	;0x089e6

000089a8 <.L376>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    89a8:	6d 43       	mov.b	#2,	r13	;r3 As==10
    89aa:	80 00 4a 89 	mova	#35146,	r0	;0x0894a

000089ae <.L377>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    89ae:	6c 42       	mov.b	#4,	r12	;r2 As==10
    89b0:	80 00 54 89 	mova	#35156,	r0	;0x08954

000089b4 <.L374>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    89b4:	6b 4c       	mov.b	@r12,	r11	;
    89b6:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    89ba:	ac 00 01 00 	adda	#1,	r12	;
    89be:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    89c2:	45 9b       	cmp.b	r11,	r5	;
    89c4:	1f 2c       	jc	$+64     	;abs 0x8a04

000089c6 <.Loc.801.2>:
      if (hdr.reply) {
    89c6:	08 93       	cmp	#0,	r8	;r3 As==00
    89c8:	17 24       	jz	$+48     	;abs 0x89f8

000089ca <.Loc.803.2>:
        gen_failure(hdr);
    89ca:	47 18 0a 5a 	rpt #8 { rlax.w	r10		;

000089ce <.LVL446>:
    89ce:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff

000089d2 <.LVL447>:
    89d2:	09 da       	bis	r10,	r9	;
    89d4:	81 49 02 00 	mov	r9,	2(r1)	;
    89d8:	81 47 04 00 	mov	r7,	4(r1)	;
    89dc:	cc 01       	mova	r1,	r12	;
    89de:	ac 00 02 00 	adda	#2,	r12	;
    89e2:	b0 13 02 82 	calla	#33282		;0x08202

000089e6 <.L375>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    89e6:	cc 06       	mova	r6,	r12	;
    89e8:	b0 13 16 c5 	calla	#50454		;0x0c516

000089ec <.LVL449>:
    89ec:	b0 13 80 c2 	calla	#49792		;0x0c280

000089f0 <.LVL450>:
}
    89f0:	a1 00 06 00 	adda	#6,	r1	;
    89f4:	64 16       	popm.a	#7,	r10	;20-bit words
    89f6:	10 01       	reta			;

000089f8 <.L371>:
        elyErrorSignal(ErrCmdFailure);
    89f8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    89fc:	b0 13 28 a7 	calla	#42792		;0x0a728

00008a00 <.LVL452>:
    8a00:	80 00 e6 89 	mova	#35302,	r0	;0x089e6

00008a04 <.L370>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    8a04:	1f 53       	inc	r15		;
    8a06:	80 00 6e 89 	mova	#35182,	r0	;0x0896e

00008a0a <log_chan>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a0a:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008a0c <.LCFI49>:
    8a0c:	b1 00 14 00 	suba	#20,	r1	;0x00014

00008a10 <.LCFI50>:
    8a10:	c8 0c       	mova	r12,	r8	;
    8a12:	27 4d       	mov	@r13,	r7	;

00008a14 <.LVL456>:
    8a14:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    8a18:	08 00 
    8a1a:	09 47       	mov	r7,	r9	;
    8a1c:	59 0f       	rrum	#4,	r9	;
    8a1e:	59 0f       	rrum	#4,	r9	;

00008a20 <.Loc.755.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8a20:	4c 47       	mov.b	r7,	r12	;

00008a22 <.LVL458>:
    8a22:	1c b3       	bit	#1,	r12	;r3 As==01
    8a24:	66 20       	jnz	$+206    	;abs 0x8af2
    8a26:	4d 43       	clr.b	r13		;

00008a28 <.L382>:
    8a28:	6c f3       	and.b	#2,	r12	;r3 As==10
    8a2a:	45 4c       	mov.b	r12,	r5	;
    8a2c:	81 45 04 00 	mov	r5,	4(r1)	;
    8a30:	40 18 4e 49 	movx.b	r9,	r14	;
    8a34:	40 18 4e 8c 	subx.b	r12,	r14	;
    8a38:	4e 8d       	sub.b	r13,	r14	;
    8a3a:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    8a3e:	4f 4e       	mov.b	r14,	r15	;

00008a40 <.LVL459>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a40:	05 93       	cmp	#0,	r5	;r3 As==00
    8a42:	5a 20       	jnz	$+182    	;abs 0x8af8

00008a44 <.Loc.756.2>:
    8a44:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008a46 <.L383>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8a46:	0e 4a       	mov	r10,	r14	;

00008a48 <.LVL461>:
    8a48:	2e 52       	add	#4,	r14	;r2 As==10

00008a4a <.LVL462>:
    8a4a:	06 4e       	mov	r14,	r6	;
    8a4c:	46 0e       	rlam.a	#4,	r6	;
    8a4e:	46 0d       	rram.a	#4,	r6	;
    8a50:	cc 06       	mova	r6,	r12	;
    8a52:	ec 08       	adda	r8,	r12	;
    8a54:	0f 5a       	add	r10,	r15	;

00008a56 <.L384>:
    8a56:	0e 9f       	cmp	r15,	r14	;
    8a58:	52 38       	jl	$+166    	;abs 0x8afe
    8a5a:	04 4a       	mov	r10,	r4	;
    8a5c:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    8a60:	04 8a       	sub	r10,	r4	;
    8a62:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00008a66 <.Loc.759.2>:
    8a66:	65 42       	mov.b	#4,	r5	;r2 As==10
    8a68:	46 43       	clr.b	r6		;
    8a6a:	04 46       	mov	r6,	r4	;

00008a6c <.LBB68>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8a6c:	40 18 0c 4a 	movx.w	r10,	r12	;
    8a70:	ec 08       	adda	r8,	r12	;
    8a72:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

00008a76 <.L391>:
    8a76:	35 53       	add	#-1,	r5	;r3 As==11

00008a78 <.LVL464>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    8a78:	35 93       	cmp	#-1,	r5	;r3 As==11
    8a7a:	7b 20       	jnz	$+248    	;abs 0x8b72

00008a7c <.LBE68>:
  interval = (interval / 100) * 100;
    8a7c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8a80:	4f 43       	clr.b	r15		;
    8a82:	0c 46       	mov	r6,	r12	;
    8a84:	0d 44       	mov	r4,	r13	;
    8a86:	b0 13 34 d1 	calla	#53556		;0x0d134
    8a8a:	05 4c       	mov	r12,	r5	;

00008a8c <.LVL466>:
    8a8c:	06 4d       	mov	r13,	r6	;

00008a8e <.LVL467>:
    8a8e:	0c 5c       	rla	r12		;
    8a90:	0d 6d       	rlc	r13		;
    8a92:	0e 4c       	mov	r12,	r14	;
    8a94:	0e 55       	add	r5,	r14	;
    8a96:	04 4d       	mov	r13,	r4	;
    8a98:	04 66       	addc	r6,	r4	;
    8a9a:	0c 4e       	mov	r14,	r12	;
    8a9c:	0d 44       	mov	r4,	r13	;
    8a9e:	71 0e 00 00 	mova	r14,	0(r1)	;
    8aa2:	b0 13 98 d1 	calla	#53656		;0x0d198
    8aa6:	0e 01       	mova	@r1,	r14	;
    8aa8:	0e 5c       	add	r12,	r14	;
    8aaa:	0d 64       	addc	r4,	r13	;

00008aac <.Loc.783.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    8aac:	40 18 0a 4a 	movx.w	r10,	r10	;
    8ab0:	aa 00 04 00 	adda	#4,	r10	;

00008ab4 <.LVL469>:
    8ab4:	0e 55       	add	r5,	r14	;
    8ab6:	0f 4d       	mov	r13,	r15	;
    8ab8:	0f 66       	addc	r6,	r15	;
    8aba:	5d 41 07 00 	mov.b	7(r1),	r13	;
    8abe:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    8ac2:	cc 08       	mova	r8,	r12	;
    8ac4:	ec 0a       	adda	r10,	r12	;
    8ac6:	b0 13 40 a7 	calla	#42816		;0x0a740

00008aca <.LVL470>:
  if (hdr.reply) {
    8aca:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    8ace:	3f 24       	jz	$+128    	;abs 0x8b4e

00008ad0 <.Loc.787.2>:
    gen_success(hdr);
    8ad0:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8ad4:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00008ad8 <.LVL472>:
    8ad8:	07 d9       	bis	r9,	r7	;
    8ada:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    8ade:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8ae2:	12 00 
    8ae4:	cc 01       	mova	r1,	r12	;
    8ae6:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8aea:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008aee <.LVL473>:
    8aee:	80 00 4e 8b 	mova	#35662,	r0	;0x08b4e

00008af2 <.L394>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8af2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8af4:	80 00 28 8a 	mova	#35368,	r0	;0x08a28

00008af8 <.L395>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8af8:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8afa:	80 00 46 8a 	mova	#35398,	r0	;0x08a46

00008afe <.L390>:
    if ((buffer[i] < 0x40) || 
    8afe:	6d 4c       	mov.b	@r12,	r13	;
    8b00:	46 4d       	mov.b	r13,	r6	;
    8b02:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    8b06:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    8b0a:	45 96       	cmp.b	r6,	r5	;
    8b0c:	0e 28       	jnc	$+30     	;abs 0x8b2a

00008b0e <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8b0e:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

00008b12 <.Loc.760.2>:
    if ((buffer[i] < 0x40) || 
    8b12:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    8b16:	45 96       	cmp.b	r6,	r5	;
    8b18:	08 2c       	jc	$+18     	;abs 0x8b2a
    8b1a:	ac 00 01 00 	adda	#1,	r12	;

00008b1e <.Loc.762.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    8b1e:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00008b22 <.Loc.761.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8b22:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    8b26:	46 9d       	cmp.b	r13,	r6	;
    8b28:	21 28       	jnc	$+68     	;abs 0x8b6c

00008b2a <.L385>:
      if (hdr.reply) {
    8b2a:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    8b2e:	18 24       	jz	$+50     	;abs 0x8b60

00008b30 <.Loc.766.2>:
        gen_failure(hdr);
    8b30:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8b34:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00008b38 <.LVL478>:
    8b38:	07 d9       	bis	r9,	r7	;
    8b3a:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    8b3e:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8b42:	12 00 
    8b44:	cc 01       	mova	r1,	r12	;
    8b46:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8b4a:	b0 13 02 82 	calla	#33282		;0x08202

00008b4e <.L393>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8b4e:	cc 08       	mova	r8,	r12	;
    8b50:	b0 13 16 c5 	calla	#50454		;0x0c516

00008b54 <.LVL480>:
    8b54:	b0 13 80 c2 	calla	#49792		;0x0c280

00008b58 <.LVL481>:
}
    8b58:	a1 00 14 00 	adda	#20,	r1	;0x00014
    8b5c:	64 16       	popm.a	#7,	r10	;20-bit words
    8b5e:	10 01       	reta			;

00008b60 <.L387>:
        elyErrorSignal(ErrCmdFailure);
    8b60:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8b64:	b0 13 28 a7 	calla	#42792		;0x0a728

00008b68 <.LVL483>:
    8b68:	80 00 4e 8b 	mova	#35662,	r0	;0x08b4e

00008b6c <.L386>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8b6c:	1e 53       	inc	r14		;
    8b6e:	80 00 56 8a 	mova	#35414,	r0	;0x08a56

00008b72 <.L392>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8b72:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    8b76:	0e 55       	add	r5,	r14	;
    8b78:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8b7c:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    8b80:	6c 4f       	mov.b	@r15,	r12	;
    8b82:	0d 43       	clr	r13		;
    8b84:	0f 43       	clr	r15		;
    8b86:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    8b8a:	06 dc       	bis	r12,	r6	;

00008b8c <.LVL488>:
    8b8c:	04 dd       	bis	r13,	r4	;

00008b8e <.LVL489>:
    8b8e:	80 00 76 8a 	mova	#35446,	r0	;0x08a76

00008b92 <channel_unsub>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8b92:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008b94 <.LCFI51>:
    8b94:	b1 00 04 00 	suba	#4,	r1	;

00008b98 <.LCFI52>:
    8b98:	c8 0c       	mova	r12,	r8	;
    8b9a:	2a 4d       	mov	@r13,	r10	;

00008b9c <.LVL491>:
    8b9c:	16 4d 02 00 	mov	2(r13),	r6	;

00008ba0 <.LVL492>:
    8ba0:	09 4a       	mov	r10,	r9	;
    8ba2:	59 0f       	rrum	#4,	r9	;
    8ba4:	59 0f       	rrum	#4,	r9	;

00008ba6 <.Loc.727.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8ba6:	4c 4a       	mov.b	r10,	r12	;

00008ba8 <.LVL494>:
    8ba8:	1c b3       	bit	#1,	r12	;r3 As==01
    8baa:	26 20       	jnz	$+78     	;abs 0x8bf8
    8bac:	4e 43       	clr.b	r14		;

00008bae <.L400>:
    8bae:	6c f3       	and.b	#2,	r12	;r3 As==10
    8bb0:	47 4c       	mov.b	r12,	r7	;
    8bb2:	40 18 4d 49 	movx.b	r9,	r13	;
    8bb6:	40 18 4d 8c 	subx.b	r12,	r13	;
    8bba:	4d 8e       	sub.b	r14,	r13	;
    8bbc:	4f 4d       	mov.b	r13,	r15	;

00008bbe <.LVL495>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8bbe:	07 93       	cmp	#0,	r7	;r3 As==00
    8bc0:	1e 20       	jnz	$+62     	;abs 0x8bfe

00008bc2 <.Loc.728.2>:
    8bc2:	6e 43       	mov.b	#2,	r14	;r3 As==10

00008bc4 <.L401>:
    8bc4:	40 18 04 4e 	movx.w	r14,	r4	;
    8bc8:	e4 08       	adda	r8,	r4	;
    8bca:	cc 04       	mova	r4,	r12	;

00008bcc <.LBB72>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8bcc:	0f 5e       	add	r14,	r15	;

00008bce <.L402>:
    8bce:	0e 9f       	cmp	r15,	r14	;
    8bd0:	19 38       	jl	$+52     	;abs 0x8c04

00008bd2 <.LBE72>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    8bd2:	cc 04       	mova	r4,	r12	;
    8bd4:	b0 13 3e a7 	calla	#42814		;0x0a73e

00008bd8 <.LVL498>:
  if (hdr.reply) {
    8bd8:	07 93       	cmp	#0,	r7	;r3 As==00
    8bda:	2b 24       	jz	$+88     	;abs 0x8c32

00008bdc <.Loc.748.2>:
    gen_success(hdr);
    8bdc:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8be0:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00008be4 <.LVL500>:
    8be4:	0a d9       	bis	r9,	r10	;
    8be6:	81 4a 00 00 	mov	r10,	0(r1)	;
    8bea:	81 46 02 00 	mov	r6,	2(r1)	;
    8bee:	cc 01       	mova	r1,	r12	;
    8bf0:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008bf4 <.LVL501>:
    8bf4:	80 00 32 8c 	mova	#35890,	r0	;0x08c32

00008bf8 <.L409>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8bf8:	6e 43       	mov.b	#2,	r14	;r3 As==10
    8bfa:	80 00 ae 8b 	mova	#35758,	r0	;0x08bae

00008bfe <.L410>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8bfe:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8c00:	80 00 c4 8b 	mova	#35780,	r0	;0x08bc4

00008c04 <.L407>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    8c04:	6b 4c       	mov.b	@r12,	r11	;
    8c06:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    8c0a:	ac 00 01 00 	adda	#1,	r12	;
    8c0e:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    8c12:	45 9b       	cmp.b	r11,	r5	;
    8c14:	1d 2c       	jc	$+60     	;abs 0x8c50

00008c16 <.Loc.732.2>:
      if (hdr.reply) {
    8c16:	07 93       	cmp	#0,	r7	;r3 As==00
    8c18:	15 24       	jz	$+44     	;abs 0x8c44

00008c1a <.Loc.734.2>:
        gen_failure(hdr);
    8c1a:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8c1e:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00008c22 <.LVL506>:
    8c22:	0a d9       	bis	r9,	r10	;
    8c24:	81 4a 00 00 	mov	r10,	0(r1)	;
    8c28:	81 46 02 00 	mov	r6,	2(r1)	;
    8c2c:	cc 01       	mova	r1,	r12	;
    8c2e:	b0 13 02 82 	calla	#33282		;0x08202

00008c32 <.L408>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8c32:	cc 08       	mova	r8,	r12	;
    8c34:	b0 13 16 c5 	calla	#50454		;0x0c516

00008c38 <.LVL508>:
    8c38:	b0 13 80 c2 	calla	#49792		;0x0c280

00008c3c <.LVL509>:
}
    8c3c:	a1 00 04 00 	adda	#4,	r1	;
    8c40:	64 16       	popm.a	#7,	r10	;20-bit words
    8c42:	10 01       	reta			;

00008c44 <.L404>:
        elyErrorSignal(ErrCmdFailure);
    8c44:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8c48:	b0 13 28 a7 	calla	#42792		;0x0a728

00008c4c <.LVL511>:
    8c4c:	80 00 32 8c 	mova	#35890,	r0	;0x08c32

00008c50 <.L403>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8c50:	1e 53       	inc	r14		;
    8c52:	80 00 ce 8b 	mova	#35790,	r0	;0x08bce

00008c56 <channel_sub>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8c56:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008c58 <.LCFI53>:
    8c58:	b1 00 14 00 	suba	#20,	r1	;0x00014

00008c5c <.LCFI54>:
    8c5c:	c8 0c       	mova	r12,	r8	;
    8c5e:	27 4d       	mov	@r13,	r7	;

00008c60 <.LVL515>:
    8c60:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    8c64:	08 00 
    8c66:	09 47       	mov	r7,	r9	;
    8c68:	59 0f       	rrum	#4,	r9	;
    8c6a:	59 0f       	rrum	#4,	r9	;

00008c6c <.Loc.686.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8c6c:	4c 47       	mov.b	r7,	r12	;

00008c6e <.LVL517>:
    8c6e:	1c b3       	bit	#1,	r12	;r3 As==01
    8c70:	66 20       	jnz	$+206    	;abs 0x8d3e
    8c72:	4d 43       	clr.b	r13		;

00008c74 <.L415>:
    8c74:	6c f3       	and.b	#2,	r12	;r3 As==10
    8c76:	45 4c       	mov.b	r12,	r5	;
    8c78:	81 45 04 00 	mov	r5,	4(r1)	;
    8c7c:	40 18 4e 49 	movx.b	r9,	r14	;
    8c80:	40 18 4e 8c 	subx.b	r12,	r14	;
    8c84:	4e 8d       	sub.b	r13,	r14	;
    8c86:	c1 4e 07 00 	mov.b	r14,	7(r1)	;
    8c8a:	4f 4e       	mov.b	r14,	r15	;

00008c8c <.LVL518>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8c8c:	05 93       	cmp	#0,	r5	;r3 As==00
    8c8e:	5a 20       	jnz	$+182    	;abs 0x8d44

00008c90 <.Loc.687.2>:
    8c90:	6a 43       	mov.b	#2,	r10	;r3 As==10

00008c92 <.L416>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8c92:	0e 4a       	mov	r10,	r14	;

00008c94 <.LVL520>:
    8c94:	2e 52       	add	#4,	r14	;r2 As==10

00008c96 <.LVL521>:
    8c96:	06 4e       	mov	r14,	r6	;
    8c98:	46 0e       	rlam.a	#4,	r6	;
    8c9a:	46 0d       	rram.a	#4,	r6	;
    8c9c:	cc 06       	mova	r6,	r12	;
    8c9e:	ec 08       	adda	r8,	r12	;
    8ca0:	0f 5a       	add	r10,	r15	;

00008ca2 <.L417>:
    8ca2:	0e 9f       	cmp	r15,	r14	;
    8ca4:	52 38       	jl	$+166    	;abs 0x8d4a
    8ca6:	04 4a       	mov	r10,	r4	;
    8ca8:	4c 18 04 54 	rpt #13 { rlax.w	r4		;
    8cac:	04 8a       	sub	r10,	r4	;
    8cae:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00008cb2 <.Loc.690.2>:
    8cb2:	65 42       	mov.b	#4,	r5	;r2 As==10
    8cb4:	46 43       	clr.b	r6		;
    8cb6:	04 46       	mov	r6,	r4	;

00008cb8 <.LBB76>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8cb8:	40 18 0c 4a 	movx.w	r10,	r12	;
    8cbc:	ec 08       	adda	r8,	r12	;
    8cbe:	71 0c 0c 00 	mova	r12,	12(r1)	; 0x0000c

00008cc2 <.L424>:
    8cc2:	35 53       	add	#-1,	r5	;r3 As==11

00008cc4 <.LVL523>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    8cc4:	35 93       	cmp	#-1,	r5	;r3 As==11
    8cc6:	7b 20       	jnz	$+248    	;abs 0x8dbe

00008cc8 <.LBE76>:
  interval = (interval / 100) * 100;
    8cc8:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8ccc:	4f 43       	clr.b	r15		;
    8cce:	0c 46       	mov	r6,	r12	;
    8cd0:	0d 44       	mov	r4,	r13	;
    8cd2:	b0 13 34 d1 	calla	#53556		;0x0d134
    8cd6:	05 4c       	mov	r12,	r5	;

00008cd8 <.LVL525>:
    8cd8:	06 4d       	mov	r13,	r6	;

00008cda <.LVL526>:
    8cda:	0c 5c       	rla	r12		;
    8cdc:	0d 6d       	rlc	r13		;
    8cde:	0e 4c       	mov	r12,	r14	;
    8ce0:	0e 55       	add	r5,	r14	;
    8ce2:	04 4d       	mov	r13,	r4	;
    8ce4:	04 66       	addc	r6,	r4	;
    8ce6:	0c 4e       	mov	r14,	r12	;
    8ce8:	0d 44       	mov	r4,	r13	;
    8cea:	71 0e 00 00 	mova	r14,	0(r1)	;
    8cee:	b0 13 98 d1 	calla	#53656		;0x0d198
    8cf2:	0e 01       	mova	@r1,	r14	;
    8cf4:	0e 5c       	add	r12,	r14	;
    8cf6:	0d 64       	addc	r4,	r13	;

00008cf8 <.Loc.715.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    8cf8:	40 18 0a 4a 	movx.w	r10,	r10	;
    8cfc:	aa 00 04 00 	adda	#4,	r10	;

00008d00 <.LVL528>:
    8d00:	0e 55       	add	r5,	r14	;
    8d02:	0f 4d       	mov	r13,	r15	;
    8d04:	0f 66       	addc	r6,	r15	;
    8d06:	5d 41 07 00 	mov.b	7(r1),	r13	;
    8d0a:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    8d0e:	cc 08       	mova	r8,	r12	;
    8d10:	ec 0a       	adda	r10,	r12	;
    8d12:	b0 13 3c a7 	calla	#42812		;0x0a73c

00008d16 <.LVL529>:
  if (hdr.reply) {
    8d16:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    8d1a:	3f 24       	jz	$+128    	;abs 0x8d9a

00008d1c <.Loc.719.2>:
    gen_success(hdr);
    8d1c:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8d20:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00008d24 <.LVL531>:
    8d24:	07 d9       	bis	r9,	r7	;
    8d26:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    8d2a:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8d2e:	12 00 
    8d30:	cc 01       	mova	r1,	r12	;
    8d32:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8d36:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008d3a <.LVL532>:
    8d3a:	80 00 9a 8d 	mova	#36250,	r0	;0x08d9a

00008d3e <.L427>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8d3e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8d40:	80 00 74 8c 	mova	#35956,	r0	;0x08c74

00008d44 <.L428>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8d44:	6a 42       	mov.b	#4,	r10	;r2 As==10
    8d46:	80 00 92 8c 	mova	#35986,	r0	;0x08c92

00008d4a <.L423>:
    if ((buffer[i] < 0x40) || 
    8d4a:	6d 4c       	mov.b	@r12,	r13	;
    8d4c:	46 4d       	mov.b	r13,	r6	;
    8d4e:	76 50 c0 ff 	add.b	#-64,	r6	;#0xffc0
    8d52:	75 40 36 00 	mov.b	#54,	r5	;#0x0036
    8d56:	45 96       	cmp.b	r6,	r5	;
    8d58:	0e 28       	jnc	$+30     	;abs 0x8d76

00008d5a <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8d5a:	76 50 ef ff 	add.b	#-17,	r6	;#0xffef

00008d5e <.Loc.691.2>:
    if ((buffer[i] < 0x40) || 
    8d5e:	75 40 0e 00 	mov.b	#14,	r5	;#0x000e
    8d62:	45 96       	cmp.b	r6,	r5	;
    8d64:	08 2c       	jc	$+18     	;abs 0x8d76
    8d66:	ac 00 01 00 	adda	#1,	r12	;

00008d6a <.Loc.693.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    8d6a:	7d 50 9d ff 	add.b	#-99,	r13	;#0xff9d

00008d6e <.Loc.692.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    8d6e:	76 40 0c 00 	mov.b	#12,	r6	;#0x000c
    8d72:	46 9d       	cmp.b	r13,	r6	;
    8d74:	21 28       	jnc	$+68     	;abs 0x8db8

00008d76 <.L418>:
      if (hdr.reply) {
    8d76:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    8d7a:	18 24       	jz	$+50     	;abs 0x8dac

00008d7c <.Loc.697.2>:
        gen_failure(hdr);
    8d7c:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    8d80:	77 f0 ff 00 	and.b	#255,	r7	;#0x00ff

00008d84 <.LVL537>:
    8d84:	07 d9       	bis	r9,	r7	;
    8d86:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    8d8a:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8d8e:	12 00 
    8d90:	cc 01       	mova	r1,	r12	;
    8d92:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8d96:	b0 13 02 82 	calla	#33282		;0x08202

00008d9a <.L426>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8d9a:	cc 08       	mova	r8,	r12	;
    8d9c:	b0 13 16 c5 	calla	#50454		;0x0c516

00008da0 <.LVL539>:
    8da0:	b0 13 80 c2 	calla	#49792		;0x0c280

00008da4 <.LVL540>:
}
    8da4:	a1 00 14 00 	adda	#20,	r1	;0x00014
    8da8:	64 16       	popm.a	#7,	r10	;20-bit words
    8daa:	10 01       	reta			;

00008dac <.L420>:
        elyErrorSignal(ErrCmdFailure);
    8dac:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8db0:	b0 13 28 a7 	calla	#42792		;0x0a728

00008db4 <.LVL542>:
    8db4:	80 00 9a 8d 	mova	#36250,	r0	;0x08d9a

00008db8 <.L419>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8db8:	1e 53       	inc	r14		;
    8dba:	80 00 a2 8c 	mova	#36002,	r0	;0x08ca2

00008dbe <.L425>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8dbe:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    8dc2:	0e 55       	add	r5,	r14	;
    8dc4:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8dc8:	3f 01 0c 00 	mova	12(r1),	r15	;0x0000c
    8dcc:	6c 4f       	mov.b	@r15,	r12	;
    8dce:	0d 43       	clr	r13		;
    8dd0:	0f 43       	clr	r15		;
    8dd2:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    8dd6:	06 dc       	bis	r12,	r6	;

00008dd8 <.LVL547>:
    8dd8:	04 dd       	bis	r13,	r4	;

00008dda <.LVL548>:
    8dda:	80 00 c2 8c 	mova	#36034,	r0	;0x08cc2

00008dde <reload_config>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    8dde:	3a 14       	pushm.a	#4,	r10	;20-bit words

00008de0 <.LCFI55>:
    8de0:	b1 00 04 00 	suba	#4,	r1	;

00008de4 <.LCFI56>:
    8de4:	28 4d       	mov	@r13,	r8	;

00008de6 <.LVL550>:
    8de6:	1a 4d 02 00 	mov	2(r13),	r10	;

00008dea <.LVL551>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8dea:	47 48       	mov.b	r8,	r7	;
    8dec:	67 f3       	and.b	#2,	r7	;r3 As==10
    8dee:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    8df2:	07 93       	cmp	#0,	r7	;r3 As==00
    8df4:	1c 20       	jnz	$+58     	;abs 0x8e2e
    8df6:	6e 43       	mov.b	#2,	r14	;r3 As==10

00008df8 <.L433>:
  uint8_t bank = buffer[hdr_ext];
    8df8:	40 18 0e 4e 	movx.w	r14,	r14	;
    8dfc:	ee 0c       	adda	r12,	r14	;

00008dfe <.LVL553>:
    8dfe:	69 4e       	mov.b	@r14,	r9	;

00008e00 <.LVL554>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8e00:	b0 13 16 c5 	calla	#50454		;0x0c516

00008e04 <.LVL555>:
    8e04:	b0 13 80 c2 	calla	#49792		;0x0c280

00008e08 <.LVL556>:
  if (bank == 0 || bank > 4) {
    8e08:	4c 49       	mov.b	r9,	r12	;
    8e0a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8e0c:	7d 40 03 00 	mov.b	#3,	r13	;
    8e10:	4d 9c       	cmp.b	r12,	r13	;
    8e12:	16 2c       	jc	$+46     	;abs 0x8e40

00008e14 <.Loc.660.2>:
    if (hdr.reply) {
    8e14:	07 93       	cmp	#0,	r7	;r3 As==00
    8e16:	0e 24       	jz	$+30     	;abs 0x8e34

00008e18 <.Loc.662.2>:
      gen_failure(hdr);
    8e18:	81 48 00 00 	mov	r8,	0(r1)	;
    8e1c:	81 4a 02 00 	mov	r10,	2(r1)	;
    8e20:	cc 01       	mova	r1,	r12	;
    8e22:	b0 13 02 82 	calla	#33282		;0x08202

00008e26 <.L432>:
}
    8e26:	a1 00 04 00 	adda	#4,	r1	;
    8e2a:	37 16       	popm.a	#4,	r10	;20-bit words
    8e2c:	10 01       	reta			;

00008e2e <.L437>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8e2e:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8e30:	80 00 f8 8d 	mova	#36344,	r0	;0x08df8

00008e34 <.L435>:
      elyErrorSignal(ErrCmdFailure);
    8e34:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8e38:	b0 13 28 a7 	calla	#42792		;0x0a728

00008e3c <.LVL562>:
    8e3c:	80 00 26 8e 	mova	#36390,	r0	;0x08e26

00008e40 <.L434>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    8e40:	2a 01 26 01 	mova	&65830,	r10	;0x10126

00008e44 <.LVL563>:
    8e44:	88 00 72 a6 	mova	#42610,	r8	;0x0a672
    8e48:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    8e4c:	4e 43       	clr.b	r14		;
    8e4e:	cd 0a       	mova	r10,	r13	;
    8e50:	4c 49       	mov.b	r9,	r12	;
    8e52:	48 13       	calla	r8		;

00008e54 <.LVL564>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    8e54:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    8e58:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    8e5c:	cd 0a       	mova	r10,	r13	;
    8e5e:	ad 00 80 00 	adda	#128,	r13	;0x00080
    8e62:	4c 49       	mov.b	r9,	r12	;
    8e64:	48 13       	calla	r8		;

00008e66 <.LVL565>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    8e66:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    8e6a:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    8e6e:	cd 0a       	mova	r10,	r13	;
    8e70:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    8e74:	4c 49       	mov.b	r9,	r12	;
    8e76:	48 13       	calla	r8		;

00008e78 <.LVL566>:
  bank0w[RegActiveBank] = bank;
    8e78:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

00008e7c <.Loc.678.2>:
  active_buffer = NULL; /* have to null before reset */
    8e7c:	01 18 c2 43 	movx.a	#0,	&0x11e74;r3 As==00
    8e80:	74 1e 

00008e82 <.Loc.682.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    8e82:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    8e86:	48 a5 20 01 
    8e8a:	80 00 26 8e 	mova	#36390,	r0	;0x08e26

00008e8e <set_u32>:
    const uint32_t max, const uint32_t min) {
    8e8e:	b1 00 02 00 	suba	#2,	r1	;
    8e92:	00 18 d1 41 	movx.a	2(r1),	0(r1)	;
    8e96:	02 00 00 00 

00008e9a <.LCFI57>:
    8e9a:	6a 14       	pushm.a	#7,	r10	;20-bit words

00008e9c <.LCFI58>:
    8e9c:	b1 00 14 00 	suba	#20,	r1	;0x00014

00008ea0 <.LCFI59>:
    8ea0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ea4:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    8ea8:	2a 4e       	mov	@r14,	r10	;

00008eaa <.LVL568>:
    8eaa:	1c 4e 02 00 	mov	2(r14),	r12	;

00008eae <.LVL569>:
    8eae:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034
    8eb2:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c
    8eb6:	1b 41 36 00 	mov	54(r1),	r11	;0x00036
    8eba:	91 41 38 00 	mov	56(r1),	14(r1)	;0x00038, 0x000e
    8ebe:	0e 00 
    8ec0:	15 41 3a 00 	mov	58(r1),	r5	;0x0003a

00008ec4 <.Loc.130.2>:
static void set_u32(const uint8_t addr, const uint8_t * buffer, elysium_cmd_hdr_t hdr,
    8ec4:	81 4c 08 00 	mov	r12,	8(r1)	;

00008ec8 <.Loc.132.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8ec8:	49 4a       	mov.b	r10,	r9	;
    8eca:	69 f3       	and.b	#2,	r9	;r3 As==10
    8ecc:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8ed0:	09 93       	cmp	#0,	r9	;r3 As==00
    8ed2:	44 20       	jnz	$+138    	;abs 0x8f5c
    8ed4:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008ed6 <.L439>:
    8ed6:	40 18 04 4c 	movx.w	r12,	r4	;
    8eda:	e4 0d       	adda	r13,	r4	;
    8edc:	71 04 04 00 	mova	r4,	4(r1)	;

00008ee0 <.Loc.132.2>:
    8ee0:	76 40 18 00 	mov.b	#24,	r6	;#0x0018

00008ee4 <.Loc.133.2>:
  uint32_t val = 0;
    8ee4:	48 43       	clr.b	r8		;
    8ee6:	07 48       	mov	r8,	r7	;

00008ee8 <.L440>:
    val |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8ee8:	3e 01 04 00 	mova	4(r1),	r14	;
    8eec:	6c 4e       	mov.b	@r14,	r12	;
    8eee:	0d 43       	clr	r13		;
    8ef0:	0e 46       	mov	r6,	r14	;
    8ef2:	0f 43       	clr	r15		;
    8ef4:	71 0b 00 00 	mova	r11,	0(r1)	;
    8ef8:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    8efc:	0c d8       	bis	r8,	r12	;
    8efe:	0d d7       	bis	r7,	r13	;
    8f00:	08 4c       	mov	r12,	r8	;

00008f02 <.LVL573>:
    8f02:	07 4d       	mov	r13,	r7	;

00008f04 <.LVL574>:
    8f04:	00 18 d1 53 	incx.a	4(r1)		;
    8f08:	04 00 
    8f0a:	36 50 f8 ff 	add	#-8,	r6	;#0xfff8

00008f0e <.Loc.136.2>:
  for (int i = 0; i < 4; i++) {
    8f0e:	0b 01       	mova	@r1,	r11	;
    8f10:	36 90 f8 ff 	cmp	#-8,	r6	;#0xfff8
    8f14:	e9 23       	jnz	$-44     	;abs 0x8ee8

00008f16 <.LBE80>:
  if (val > max || 
    8f16:	0b 9d       	cmp	r13,	r11	;
    8f18:	0c 28       	jnc	$+26     	;abs 0x8f32
    8f1a:	0d 9b       	cmp	r11,	r13	;
    8f1c:	03 20       	jnz	$+8      	;abs 0x8f24
    8f1e:	81 9c 0c 00 	cmp	r12,	12(r1)	; 0x000c
    8f22:	07 28       	jnc	$+16     	;abs 0x8f32

00008f24 <.L448>:
    8f24:	0d 95       	cmp	r5,	r13	;
    8f26:	05 28       	jnc	$+12     	;abs 0x8f32
    8f28:	05 9d       	cmp	r13,	r5	;
    8f2a:	21 20       	jnz	$+68     	;abs 0x8f6e
    8f2c:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    8f30:	1e 2c       	jc	$+62     	;abs 0x8f6e

00008f32 <.L441>:
    if (hdr.reply) {
    8f32:	09 93       	cmp	#0,	r9	;r3 As==00
    8f34:	16 24       	jz	$+46     	;abs 0x8f62

00008f36 <.Loc.144.2>:
      gen_failure(hdr);
    8f36:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    8f3a:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8f3e:	12 00 
    8f40:	cc 01       	mova	r1,	r12	;
    8f42:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8f46:	b0 13 02 82 	calla	#33282		;0x08202

00008f4a <.L438>:
}
    8f4a:	a1 00 14 00 	adda	#20,	r1	;0x00014
    8f4e:	64 16       	popm.a	#7,	r10	;20-bit words
    8f50:	00 18 e1 41 	movx.a	@r1,	2(r1)	;
    8f54:	02 00 
    8f56:	a1 00 02 00 	adda	#2,	r1	;
    8f5a:	10 01       	reta			;

00008f5c <.L447>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8f5c:	6c 42       	mov.b	#4,	r12	;r2 As==10

00008f5e <.LVL578>:
    8f5e:	80 00 d6 8e 	mova	#36566,	r0	;0x08ed6

00008f62 <.L445>:
      elyErrorSignal(ErrCmdFailure);
    8f62:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8f66:	b0 13 28 a7 	calla	#42792		;0x0a728

00008f6a <.LVL580>:
    8f6a:	80 00 4a 8f 	mova	#36682,	r0	;0x08f4a

00008f6e <.L443>:
  bank0w[addr+3] = buffer[hdr_ext];
    8f6e:	40 18 1c 41 	movx.w	10(r1),	r12	;0x0000a
    8f72:	0a 00 
    8f74:	80 18 5c 52 	addx.a	&0x10126,r12	;
    8f78:	26 01 
    8f7a:	ec 44 03 00 	mov.b	@r4,	3(r12)	;

00008f7e <.Loc.153.2>:
  bank0w[addr+2] = buffer[hdr_ext+1];
    8f7e:	dc 44 01 00 	mov.b	1(r4),	2(r12)	;
    8f82:	02 00 

00008f84 <.Loc.154.2>:
  bank0w[addr+1] = buffer[hdr_ext+2];
    8f84:	dc 44 02 00 	mov.b	2(r4),	1(r12)	;
    8f88:	01 00 

00008f8a <.Loc.155.2>:
  bank0w[addr] = buffer[hdr_ext+3];
    8f8a:	dc 44 03 00 	mov.b	3(r4),	0(r12)	;
    8f8e:	00 00 

00008f90 <.Loc.157.2>:
  if (hdr.reply) {
    8f90:	09 93       	cmp	#0,	r9	;r3 As==00
    8f92:	db 27       	jz	$-72     	;abs 0x8f4a

00008f94 <.Loc.159.2>:
    gen_success(hdr);
    8f94:	81 4a 10 00 	mov	r10,	16(r1)	; 0x0010
    8f98:	91 41 08 00 	mov	8(r1),	18(r1)	; 0x0012
    8f9c:	12 00 
    8f9e:	cc 01       	mova	r1,	r12	;
    8fa0:	ac 00 10 00 	adda	#16,	r12	;0x00010
    8fa4:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00008fa8 <.LVL581>:
    8fa8:	80 00 4a 8f 	mova	#36682,	r0	;0x08f4a

00008fac <set_baud>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8fac:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008fae <.LCFI60>:
    8fae:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00008fb2 <.LCFI61>:
    8fb2:	ca 0c       	mova	r12,	r10	;

00008fb4 <.Loc.643.2>:
  set_u32(RegUARTBaudLsb, buffer, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    8fb4:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    8fb8:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    8fbc:	08 00 
    8fbe:	91 43 02 00 	mov	#1,	2(r1)	;r3 As==01
    8fc2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    8fc6:	b1 40 0f 00 	mov	#15,	0(r1)	;#0x000f
    8fca:	00 00 
    8fcc:	3f 40 40 42 	mov	#16960,	r15	;#0x4240
    8fd0:	ce 01       	mova	r1,	r14	;
    8fd2:	ae 00 06 00 	adda	#6,	r14	;
    8fd6:	cd 0c       	mova	r12,	r13	;
    8fd8:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00008fdc <.LVL583>:
    8fdc:	b0 13 8e 8e 	calla	#36494		;0x08e8e

00008fe0 <.LVL584>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    8fe0:	cc 0a       	mova	r10,	r12	;
    8fe2:	b0 13 16 c5 	calla	#50454		;0x0c516

00008fe6 <.LVL585>:
    8fe6:	b0 13 80 c2 	calla	#49792		;0x0c280

00008fea <.LVL586>:
  elyUARTCfgMarkDirty();
    8fea:	b0 13 40 74 	calla	#29760		;0x07440

00008fee <.LVL587>:
}
    8fee:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    8ff2:	0a 16       	popm.a	#1,	r10	;20-bit words
    8ff4:	10 01       	reta			;

00008ff6 <set_rx_dev>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ff6:	0a 14       	pushm.a	#1,	r10	;20-bit words

00008ff8 <.LCFI62>:
    8ff8:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00008ffc <.LCFI63>:
    8ffc:	ca 0c       	mova	r12,	r10	;

00008ffe <.Loc.565.2>:
  set_u32(RegRXDevLsb, buffer, hdr, RX_DEV_MAX, RX_DEV_MIN);
    8ffe:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    9002:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    9006:	08 00 
    9008:	b1 40 e8 80 	mov	#-32536,2(r1)	;#0x80e8
    900c:	02 00 
    900e:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    9012:	b1 40 03 00 	mov	#3,	0(r1)	;
    9016:	00 00 
    9018:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    901c:	ce 01       	mova	r1,	r14	;
    901e:	ae 00 06 00 	adda	#6,	r14	;
    9022:	cd 0c       	mova	r12,	r13	;
    9024:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c

00009028 <.LVL589>:
    9028:	b0 13 8e 8e 	calla	#36494		;0x08e8e

0000902c <.LVL590>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    902c:	cc 0a       	mova	r10,	r12	;
    902e:	b0 13 16 c5 	calla	#50454		;0x0c516

00009032 <.LVL591>:
    9032:	b0 13 80 c2 	calla	#49792		;0x0c280

00009036 <.LVL592>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    9036:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    903a:	4d 43       	clr.b	r13		;
    903c:	b0 13 9a b5 	calla	#46490		;0x0b59a

00009040 <.LVL593>:
  elyEventSignal(EvtRXDevChange);
    9040:	7c 40 ca ff 	mov.b	#-54,	r12	;#0xffca
    9044:	b0 13 30 a7 	calla	#42800		;0x0a730

00009048 <.LVL594>:
}
    9048:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    904c:	0a 16       	popm.a	#1,	r10	;20-bit words
    904e:	10 01       	reta			;

00009050 <set_tx_dev>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9050:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009052 <.LCFI64>:
    9052:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00009056 <.LCFI65>:
    9056:	ca 0c       	mova	r12,	r10	;

00009058 <.Loc.543.2>:
  set_u32(RegTXDevLsb, buffer, hdr, TX_DEV_MAX, TX_DEV_MIN);
    9058:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    905c:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    9060:	08 00 
    9062:	b1 40 58 02 	mov	#600,	2(r1)	;#0x0258
    9066:	02 00 
    9068:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    906c:	b1 40 03 00 	mov	#3,	0(r1)	;
    9070:	00 00 
    9072:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    9076:	ce 01       	mova	r1,	r14	;
    9078:	ae 00 06 00 	adda	#6,	r14	;
    907c:	cd 0c       	mova	r12,	r13	;
    907e:	7c 42       	mov.b	#8,	r12	;r2 As==11

00009080 <.LVL596>:
    9080:	b0 13 8e 8e 	calla	#36494		;0x08e8e

00009084 <.LVL597>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9084:	cc 0a       	mova	r10,	r12	;
    9086:	b0 13 16 c5 	calla	#50454		;0x0c516

0000908a <.LVL598>:
    908a:	b0 13 80 c2 	calla	#49792		;0x0c280

0000908e <.LVL599>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    908e:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    9092:	4d 43       	clr.b	r13		;
    9094:	b0 13 9a b5 	calla	#46490		;0x0b59a

00009098 <.LVL600>:
  elyEventSignal(EvtTXDevChange);
    9098:	7c 40 c9 ff 	mov.b	#-55,	r12	;#0xffc9
    909c:	b0 13 30 a7 	calla	#42800		;0x0a730

000090a0 <.LVL601>:
}
    90a0:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    90a4:	0a 16       	popm.a	#1,	r10	;20-bit words
    90a6:	10 01       	reta			;

000090a8 <set_rx_br>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    90a8:	0a 14       	pushm.a	#1,	r10	;20-bit words

000090aa <.LCFI66>:
    90aa:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

000090ae <.LCFI67>:
    90ae:	ca 0c       	mova	r12,	r10	;

000090b0 <.Loc.521.2>:
  set_u32(RegRXBRLsb, buffer, hdr, RX_BR_MAX, RX_BR_MIN);
    90b0:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    90b4:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    90b8:	08 00 
    90ba:	b1 40 0c 03 	mov	#780,	2(r1)	;#0x030c
    90be:	02 00 
    90c0:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    90c4:	a1 43 00 00 	mov	#2,	0(r1)	;r3 As==10
    90c8:	3f 40 f0 49 	mov	#18928,	r15	;#0x49f0
    90cc:	ce 01       	mova	r1,	r14	;
    90ce:	ae 00 06 00 	adda	#6,	r14	;
    90d2:	cd 0c       	mova	r12,	r13	;
    90d4:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c

000090d8 <.LVL603>:
    90d8:	b0 13 8e 8e 	calla	#36494		;0x08e8e

000090dc <.LVL604>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    90dc:	cc 0a       	mova	r10,	r12	;
    90de:	b0 13 16 c5 	calla	#50454		;0x0c516

000090e2 <.LVL605>:
    90e2:	b0 13 80 c2 	calla	#49792		;0x0c280

000090e6 <.LVL606>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    90e6:	7c 42       	mov.b	#8,	r12	;r2 As==11
    90e8:	4d 43       	clr.b	r13		;
    90ea:	b0 13 9a b5 	calla	#46490		;0x0b59a

000090ee <.LVL607>:
  elyEventSignal(EvtRXBRChange);
    90ee:	7c 40 c8 ff 	mov.b	#-56,	r12	;#0xffc8
    90f2:	b0 13 30 a7 	calla	#42800		;0x0a730

000090f6 <.LVL608>:
}
    90f6:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    90fa:	0a 16       	popm.a	#1,	r10	;20-bit words
    90fc:	10 01       	reta			;

000090fe <set_tx_br>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    90fe:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009100 <.LCFI68>:
    9100:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

00009104 <.LCFI69>:
    9104:	ca 0c       	mova	r12,	r10	;

00009106 <.Loc.499.2>:
  set_u32(RegTXBRLsb, buffer, hdr, TX_BR_MAX, TX_BR_MIN);
    9106:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    910a:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    910e:	08 00 
    9110:	b1 40 b0 04 	mov	#1200,	2(r1)	;#0x04b0
    9114:	02 00 
    9116:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    911a:	a1 42 00 00 	mov	#4,	0(r1)	;r2 As==10
    911e:	3f 40 e0 93 	mov	#-27680,r15	;#0x93e0
    9122:	ce 01       	mova	r1,	r14	;
    9124:	ae 00 06 00 	adda	#6,	r14	;
    9128:	cd 0c       	mova	r12,	r13	;
    912a:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018

0000912e <.LVL610>:
    912e:	b0 13 8e 8e 	calla	#36494		;0x08e8e

00009132 <.LVL611>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9132:	cc 0a       	mova	r10,	r12	;
    9134:	b0 13 16 c5 	calla	#50454		;0x0c516

00009138 <.LVL612>:
    9138:	b0 13 80 c2 	calla	#49792		;0x0c280

0000913c <.LVL613>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    913c:	6c 42       	mov.b	#4,	r12	;r2 As==10
    913e:	4d 43       	clr.b	r13		;
    9140:	b0 13 9a b5 	calla	#46490		;0x0b59a

00009144 <.LVL614>:
  elyEventSignal(EvtTXBRChange);
    9144:	7c 40 c7 ff 	mov.b	#-57,	r12	;#0xffc7
    9148:	b0 13 30 a7 	calla	#42800		;0x0a730

0000914c <.LVL615>:
}
    914c:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    9150:	0a 16       	popm.a	#1,	r10	;20-bit words
    9152:	10 01       	reta			;

00009154 <set_rx_freq>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9154:	0a 14       	pushm.a	#1,	r10	;20-bit words

00009156 <.LCFI70>:
    9156:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

0000915a <.LCFI71>:
    915a:	ca 0c       	mova	r12,	r10	;

0000915c <.Loc.477.2>:
  set_u32(RegRXFreqLsb, buffer, hdr, RX_BAND_MAX, RX_BAND_MIN);
    915c:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    9160:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    9164:	08 00 
    9166:	b1 40 40 44 	mov	#17472,	2(r1)	;#0x4440
    916a:	02 00 
    916c:	b1 40 3d 1b 	mov	#6973,	4(r1)	;#0x1b3d
    9170:	04 00 
    9172:	b1 40 12 1c 	mov	#7186,	0(r1)	;#0x1c12
    9176:	00 00 
    9178:	3f 40 c0 e3 	mov	#-7232,	r15	;#0xe3c0
    917c:	ce 01       	mova	r1,	r14	;
    917e:	ae 00 06 00 	adda	#6,	r14	;
    9182:	cd 0c       	mova	r12,	r13	;
    9184:	6c 42       	mov.b	#4,	r12	;r2 As==10

00009186 <.LVL617>:
    9186:	b0 13 8e 8e 	calla	#36494		;0x08e8e

0000918a <.LVL618>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    918a:	cc 0a       	mova	r10,	r12	;
    918c:	b0 13 16 c5 	calla	#50454		;0x0c516

00009190 <.LVL619>:
    9190:	b0 13 80 c2 	calla	#49792		;0x0c280

00009194 <.LVL620>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    9194:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9196:	4d 43       	clr.b	r13		;
    9198:	b0 13 9a b5 	calla	#46490		;0x0b59a

0000919c <.LVL621>:
  elyEventSignal(EvtRXFreqChange);
    919c:	7c 40 c6 ff 	mov.b	#-58,	r12	;#0xffc6
    91a0:	b0 13 30 a7 	calla	#42800		;0x0a730

000091a4 <.LVL622>:
}
    91a4:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    91a8:	0a 16       	popm.a	#1,	r10	;20-bit words
    91aa:	10 01       	reta			;

000091ac <set_tx_freq>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    91ac:	0a 14       	pushm.a	#1,	r10	;20-bit words

000091ae <.LCFI72>:
    91ae:	b1 00 0a 00 	suba	#10,	r1	;0x0000a

000091b2 <.LCFI73>:
    91b2:	ca 0c       	mova	r12,	r10	;

000091b4 <.Loc.455.2>:
  set_u32(RegTXFreqLsb, buffer, hdr, TX_BAND_MAX, TX_BAND_MIN);
    91b4:	a1 4d 06 00 	mov	@r13,	6(r1)	;
    91b8:	91 4d 02 00 	mov	2(r13),	8(r1)	;
    91bc:	08 00 
    91be:	b1 40 40 da 	mov	#-9664,	2(r1)	;#0xda40
    91c2:	02 00 
    91c4:	b1 40 8e 33 	mov	#13198,	4(r1)	;#0x338e
    91c8:	04 00 
    91ca:	b1 40 ec 38 	mov	#14572,	0(r1)	;#0x38ec
    91ce:	00 00 
    91d0:	3f 40 c0 24 	mov	#9408,	r15	;#0x24c0
    91d4:	ce 01       	mova	r1,	r14	;
    91d6:	ae 00 06 00 	adda	#6,	r14	;
    91da:	cd 0c       	mova	r12,	r13	;
    91dc:	4c 43       	clr.b	r12		;

000091de <.LVL624>:
    91de:	b0 13 8e 8e 	calla	#36494		;0x08e8e

000091e2 <.LVL625>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    91e2:	cc 0a       	mova	r10,	r12	;
    91e4:	b0 13 16 c5 	calla	#50454		;0x0c516

000091e8 <.LVL626>:
    91e8:	b0 13 80 c2 	calla	#49792		;0x0c280

000091ec <.LVL627>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    91ec:	5c 43       	mov.b	#1,	r12	;r3 As==01
    91ee:	4d 43       	clr.b	r13		;
    91f0:	b0 13 9a b5 	calla	#46490		;0x0b59a

000091f4 <.LVL628>:
  elyEventSignal(EvtTXFreqChange);
    91f4:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    91f8:	b0 13 30 a7 	calla	#42800		;0x0a730

000091fc <.LVL629>:
}
    91fc:	a1 00 0a 00 	adda	#10,	r1	;0x0000a
    9200:	0a 16       	popm.a	#1,	r10	;20-bit words
    9202:	10 01       	reta			;

00009204 <set_tx_pow>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9204:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009206 <.LCFI74>:
    9206:	b1 00 04 00 	suba	#4,	r1	;

0000920a <.LCFI75>:
    920a:	ca 0c       	mova	r12,	r10	;
    920c:	29 4d       	mov	@r13,	r9	;

0000920e <.LVL631>:
    920e:	15 4d 02 00 	mov	2(r13),	r5	;

00009212 <.LVL632>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9212:	47 49       	mov.b	r9,	r7	;
    9214:	67 f3       	and.b	#2,	r7	;r3 As==10
    9216:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    921a:	07 93       	cmp	#0,	r7	;r3 As==00
    921c:	1d 20       	jnz	$+60     	;abs 0x9258
    921e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009220 <.L461>:
  if (buffer[hdr_ext] > TX_POW_MAX) {
    9220:	40 18 0c 4c 	movx.w	r12,	r12	;
    9224:	ec 0a       	adda	r10,	r12	;

00009226 <.LVL634>:
    9226:	6d 4c       	mov.b	@r12,	r13	;
    9228:	88 00 16 c5 	mova	#50454,	r8	;0x0c516
    922c:	86 00 80 c2 	mova	#49792,	r6	;0x0c280
    9230:	7c 40 82 ff 	mov.b	#-126,	r12	;#0xff82
    9234:	4c 9d       	cmp.b	r13,	r12	;
    9236:	19 2c       	jc	$+52     	;abs 0x926a

00009238 <.Loc.608.2>:
    if (hdr.reply) {
    9238:	07 93       	cmp	#0,	r7	;r3 As==00
    923a:	11 24       	jz	$+36     	;abs 0x925e

0000923c <.Loc.610.2>:
      gen_failure(hdr);
    923c:	81 49 00 00 	mov	r9,	0(r1)	;
    9240:	81 45 02 00 	mov	r5,	2(r1)	;
    9244:	cc 01       	mova	r1,	r12	;
    9246:	b0 13 02 82 	calla	#33282		;0x08202

0000924a <.L466>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    924a:	cc 0a       	mova	r10,	r12	;
    924c:	48 13       	calla	r8		;

0000924e <.LVL638>:
    924e:	46 13       	calla	r6		;

00009250 <.LBE83>:
}
    9250:	a1 00 04 00 	adda	#4,	r1	;
    9254:	55 16       	popm.a	#6,	r10	;20-bit words
    9256:	10 01       	reta			;

00009258 <.L467>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9258:	6c 42       	mov.b	#4,	r12	;r2 As==10
    925a:	80 00 20 92 	mova	#37408,	r0	;0x09220

0000925e <.L463>:
      elyErrorSignal(ErrCmdFailure);
    925e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    9262:	b0 13 28 a7 	calla	#42792		;0x0a728

00009266 <.LVL641>:
    9266:	80 00 4a 92 	mova	#37450,	r0	;0x0924a

0000926a <.L462>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    926a:	2c 01 26 01 	mova	&65830,	r12	;0x10126
    926e:	cc 4d 21 00 	mov.b	r13,	33(r12)	; 0x0021

00009272 <.Loc.622.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    9272:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    9276:	4d 43       	clr.b	r13		;
    9278:	b0 13 9a b5 	calla	#46490		;0x0b59a

0000927c <.LVL642>:
  if (hdr.reply) {
    927c:	07 93       	cmp	#0,	r7	;r3 As==00
    927e:	e5 27       	jz	$-52     	;abs 0x924a

00009280 <.Loc.626.2>:
    gen_success(hdr);
    9280:	81 49 00 00 	mov	r9,	0(r1)	;
    9284:	81 45 02 00 	mov	r5,	2(r1)	;
    9288:	cc 01       	mova	r1,	r12	;
    928a:	b0 13 bc 7e 	calla	#32444		;0x07ebc

0000928e <.LVL644>:
    928e:	80 00 4a 92 	mova	#37450,	r0	;0x0924a

00009292 <set_gpo>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9292:	3a 14       	pushm.a	#4,	r10	;20-bit words

00009294 <.LCFI76>:
    9294:	b1 00 04 00 	suba	#4,	r1	;

00009298 <.LCFI77>:
    9298:	2a 4d       	mov	@r13,	r10	;

0000929a <.LVL646>:
    929a:	18 4d 02 00 	mov	2(r13),	r8	;

0000929e <.LVL647>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    929e:	49 4a       	mov.b	r10,	r9	;
    92a0:	69 f3       	and.b	#2,	r9	;r3 As==10
    92a2:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    92a6:	09 93       	cmp	#0,	r9	;r3 As==00
    92a8:	17 20       	jnz	$+48     	;abs 0x92d8
    92aa:	6e 43       	mov.b	#2,	r14	;r3 As==10

000092ac <.L472>:
    92ac:	ee 0c       	adda	r12,	r14	;
    92ae:	67 4e       	mov.b	@r14,	r7	;

000092b0 <.LVL648>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    92b0:	b0 13 16 c5 	calla	#50454		;0x0c516

000092b4 <.LVL649>:
    92b4:	b0 13 80 c2 	calla	#49792		;0x0c280

000092b8 <.LVL650>:
  if (arg > 1) {
    92b8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    92ba:	4c 97       	cmp.b	r7,	r12	;
    92bc:	16 2c       	jc	$+46     	;abs 0x92ea

000092be <.Loc.201.2>:
    if (hdr.reply) {
    92be:	09 93       	cmp	#0,	r9	;r3 As==00
    92c0:	0e 24       	jz	$+30     	;abs 0x92de

000092c2 <.Loc.203.2>:
      gen_failure(hdr);
    92c2:	81 4a 00 00 	mov	r10,	0(r1)	;
    92c6:	81 48 02 00 	mov	r8,	2(r1)	;
    92ca:	cc 01       	mova	r1,	r12	;
    92cc:	b0 13 02 82 	calla	#33282		;0x08202

000092d0 <.L471>:
}
    92d0:	a1 00 04 00 	adda	#4,	r1	;
    92d4:	37 16       	popm.a	#4,	r10	;20-bit words
    92d6:	10 01       	reta			;

000092d8 <.L477>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    92d8:	6e 42       	mov.b	#4,	r14	;r2 As==10
    92da:	80 00 ac 92 	mova	#37548,	r0	;0x092ac

000092de <.L474>:
      elyErrorSignal(ErrCmdFailure);
    92de:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    92e2:	b0 13 28 a7 	calla	#42792		;0x0a728

000092e6 <.LVL656>:
    92e6:	80 00 d0 92 	mova	#37584,	r0	;0x092d0

000092ea <.L473>:
  if (bank0p[RegGPOState] != arg) {
    92ea:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    92ee:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    92f2:	16 24       	jz	$+46     	;abs 0x9320

000092f4 <.Loc.214.2>:
    palWriteLine(LINE_GPO, arg);
    92f4:	0c 47       	mov	r7,	r12	;
    92f6:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    92fa:	3c f0 00 20 	and	#8192,	r12	;#0x2000
    92fe:	40 18 1d 42 	movx.w	&0x00222,r13	;
    9302:	22 02 
    9304:	3d f0 ff df 	and	#-8193,	r13	;#0xdfff
    9308:	0c dd       	bis	r13,	r12	;
    930a:	40 18 82 4c 	movx.w	r12,	&0x00222;
    930e:	22 02 

00009310 <.Loc.216.2>:
    elyEventSignal(EvtGPOChange);
    9310:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    9314:	b0 13 30 a7 	calla	#42800		;0x0a730

00009318 <.LVL657>:
    bank0w[RegGPOState] = arg;
    9318:	2c 01 26 01 	mova	&65830,	r12	;0x10126
    931c:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

00009320 <.L476>:
  if (hdr.reply) {
    9320:	09 93       	cmp	#0,	r9	;r3 As==00
    9322:	d6 27       	jz	$-82     	;abs 0x92d0

00009324 <.Loc.222.2>:
    gen_success(hdr);
    9324:	81 4a 00 00 	mov	r10,	0(r1)	;
    9328:	81 48 02 00 	mov	r8,	2(r1)	;
    932c:	cc 01       	mova	r1,	r12	;
    932e:	b0 13 bc 7e 	calla	#32444		;0x07ebc

00009332 <.LVL659>:
    9332:	80 00 d0 92 	mova	#37584,	r0	;0x092d0

00009336 <get_log>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9336:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009338 <.LCFI78>:
    9338:	c8 0c       	mova	r12,	r8	;
    933a:	24 4d       	mov	@r13,	r4	;

0000933c <.LVL661>:
    933c:	19 4d 02 00 	mov	2(r13),	r9	;

00009340 <.LVL662>:
    9340:	07 44       	mov	r4,	r7	;
    9342:	57 07       	rrum	#2,	r7	;
    9344:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    9348:	45 47       	mov.b	r7,	r5	;

0000934a <.Loc.1157.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    934a:	8a 00 16 c5 	mova	#50454,	r10	;0x0c516
    934e:	4a 13       	calla	r10		;

00009350 <.LVL664>:
    9350:	86 00 80 c2 	mova	#49792,	r6	;0x0c280
    9354:	46 13       	calla	r6		;

00009356 <.LVL665>:
  if (hdr.reply) {
    9356:	41 18 05 55 	rpt #2 { rlax.w	r5		;
    935a:	74 f0 03 00 	and.b	#3,	r4	;

0000935e <.LVL666>:
    935e:	05 d4       	bis	r4,	r5	;
    9360:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    9364:	09 24       	jz	$+20     	;abs 0x9378

00009366 <.LBB85>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9366:	b0 13 b2 77 	calla	#30642		;0x077b2

0000936a <.LVL667>:
    936a:	c4 0c       	mova	r12,	r4	;

0000936c <.LVL668>:
    if (reply_buff == NULL) {
    936c:	9c 00 00 00 	cmpa	#0,	r12	;
    9370:	05 20       	jnz	$+12     	;abs 0x937c

00009372 <.Loc.1163.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    9372:	cc 08       	mova	r8,	r12	;
    9374:	4a 13       	calla	r10		;

00009376 <.LVL669>:
    9376:	46 13       	calla	r6		;

00009378 <.L481>:
}
    9378:	64 16       	popm.a	#7,	r10	;20-bit words
    937a:	10 01       	reta			;

0000937c <.L483>:
    reply_buff[0] = hdr.opcode;
    937c:	cc 47 00 00 	mov.b	r7,	0(r12)	;

00009380 <.Loc.1168.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9380:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    9384:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    9388:	02 00 

0000938a <.Loc.1169.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    938a:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    938e:	03 00 

00009390 <.Loc.1170.2>:
    reply_buff[4] = bank0p[RegErrLogLvl];
    9390:	dc 4e 4d 00 	mov.b	77(r14),4(r12)	;0x0004d
    9394:	04 00 

00009396 <.Loc.1171.2>:
    if (hdr.crc) {
    9396:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    939a:	0d 24       	jz	$+28     	;abs 0x93b6

0000939c <.Loc.1172.2>:
      reply_buff[1] = 3;
    939c:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    93a0:	01 00 

000093a2 <.Loc.1173.2>:
      crcGenX25(reply_buff, 7);
    93a2:	7d 40 07 00 	mov.b	#7,	r13	;
    93a6:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

000093aa <.L485>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    93aa:	0d 49       	mov	r9,	r13	;
    93ac:	cc 04       	mova	r4,	r12	;
    93ae:	b0 13 98 7e 	calla	#32408		;0x07e98

000093b2 <.LVL673>:
    93b2:	80 00 78 93 	mova	#37752,	r0	;0x09378

000093b6 <.L484>:
      reply_buff[1] = 1;
    93b6:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    93ba:	80 00 aa 93 	mova	#37802,	r0	;0x093aa

000093be <get_err>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    93be:	5a 14       	pushm.a	#6,	r10	;20-bit words

000093c0 <.LCFI79>:
    93c0:	c8 0c       	mova	r12,	r8	;
    93c2:	2c 4d       	mov	@r13,	r12	;

000093c4 <.LVL675>:
    93c4:	19 4d 02 00 	mov	2(r13),	r9	;

000093c8 <.LVL676>:
    93c8:	05 4c       	mov	r12,	r5	;
    93ca:	55 07       	rrum	#2,	r5	;
    93cc:	75 f0 3f 00 	and.b	#63,	r5	;#0x003f

000093d0 <.Loc.1098.2>:
  if (hdr.reply) {
    93d0:	07 45       	mov	r5,	r7	;
    93d2:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    93d6:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    93da:	7c f0 03 00 	and.b	#3,	r12	;

000093de <.LVL678>:
    93de:	07 dc       	bis	r12,	r7	;
    93e0:	8a 00 16 c5 	mova	#50454,	r10	;0x0c516
    93e4:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    93e8:	06 24       	jz	$+14     	;abs 0x93f6

000093ea <.LBB87>:
    uint8_t * reply_buff = elyFWGetBuffer();
    93ea:	b0 13 b2 77 	calla	#30642		;0x077b2

000093ee <.LVL679>:
    93ee:	c6 0c       	mova	r12,	r6	;

000093f0 <.LVL680>:
    if (reply_buff == NULL) {
    93f0:	9c 00 00 00 	cmpa	#0,	r12	;
    93f4:	06 20       	jnz	$+14     	;abs 0x9402

000093f6 <.L490>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    93f6:	cc 08       	mova	r8,	r12	;
    93f8:	4a 13       	calla	r10		;

000093fa <.LVL682>:
    93fa:	b0 13 80 c2 	calla	#49792		;0x0c280

000093fe <.LVL683>:
}
    93fe:	55 16       	popm.a	#6,	r10	;20-bit words
    9400:	10 01       	reta			;

00009402 <.L491>:
    reply_buff[0] = hdr.opcode;
    9402:	cc 45 00 00 	mov.b	r5,	0(r12)	;

00009406 <.Loc.1107.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9406:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    940a:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    940e:	02 00 

00009410 <.Loc.1108.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9410:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    9414:	03 00 

00009416 <.Loc.1109.2>:
    reply_buff[4] = bank0p[RegErrRptLvl];
    9416:	dc 4e 4c 00 	mov.b	76(r14),4(r12)	;0x0004c
    941a:	04 00 

0000941c <.Loc.1110.2>:
    if (hdr.crc) {
    941c:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    9420:	0d 24       	jz	$+28     	;abs 0x943c

00009422 <.Loc.1111.2>:
      reply_buff[1] = 3;
    9422:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    9426:	01 00 

00009428 <.Loc.1112.2>:
      crcGenX25(reply_buff, 7);
    9428:	7d 40 07 00 	mov.b	#7,	r13	;
    942c:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00009430 <.L494>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9430:	0d 49       	mov	r9,	r13	;
    9432:	cc 06       	mova	r6,	r12	;
    9434:	b0 13 98 7e 	calla	#32408		;0x07e98

00009438 <.LVL686>:
    9438:	80 00 f6 93 	mova	#37878,	r0	;0x093f6

0000943c <.L493>:
      reply_buff[1] = 1;
    943c:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    9440:	80 00 30 94 	mova	#37936,	r0	;0x09430

00009444 <get_time>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9444:	4a 14       	pushm.a	#5,	r10	;20-bit words

00009446 <.LCFI80>:
    9446:	2a 4d       	mov	@r13,	r10	;

00009448 <.LVL688>:
    9448:	19 4d 02 00 	mov	2(r13),	r9	;

0000944c <.LVL689>:
    944c:	08 4a       	mov	r10,	r8	;
    944e:	58 07       	rrum	#2,	r8	;
    9450:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    9454:	47 48       	mov.b	r8,	r7	;
    9456:	06 4a       	mov	r10,	r6	;
    9458:	56 0f       	rrum	#4,	r6	;
    945a:	56 0f       	rrum	#4,	r6	;

0000945c <.Loc.1071.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    945c:	b0 13 16 c5 	calla	#50454		;0x0c516

00009460 <.LVL691>:
    9460:	b0 13 80 c2 	calla	#49792		;0x0c280

00009464 <.LVL692>:
  if (hdr.reply) {
    9464:	41 18 07 57 	rpt #2 { rlax.w	r7		;
    9468:	7a f0 03 00 	and.b	#3,	r10	;

0000946c <.LVL693>:
    946c:	07 da       	bis	r10,	r7	;
    946e:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    9472:	32 24       	jz	$+102    	;abs 0x94d8

00009474 <.LBB89>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9474:	b0 13 b2 77 	calla	#30642		;0x077b2

00009478 <.LVL694>:
    9478:	ca 0c       	mova	r12,	r10	;

0000947a <.LVL695>:
    if (reply_buff == NULL) {
    947a:	9c 00 00 00 	cmpa	#0,	r12	;
    947e:	2c 24       	jz	$+90     	;abs 0x94d8

00009480 <.Loc.1080.2>:
    reply_buff[0] = hdr.opcode;
    9480:	cc 48 00 00 	mov.b	r8,	0(r12)	;

00009484 <.Loc.1081.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9484:	28 01 2a 01 	mova	&65834,	r8	;0x1012a
    9488:	dc 48 51 00 	mov.b	81(r8),	2(r12)	;0x00051
    948c:	02 00 

0000948e <.Loc.1082.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    948e:	dc 48 50 00 	mov.b	80(r8),	3(r12)	;0x00050
    9492:	03 00 

00009494 <.Loc.1083.2>:
    reply_buff[1] = hdr.length + 2;
    9494:	66 53       	incd.b	r6		;
    9496:	cc 46 01 00 	mov.b	r6,	1(r12)	;

0000949a <.LVL698>:
    949a:	cc 08       	mova	r8,	r12	;
    949c:	ac 00 76 00 	adda	#118,	r12	;0x00076
    94a0:	ce 0a       	mova	r10,	r14	;
    94a2:	ae 00 04 00 	adda	#4,	r14	;
    94a6:	a8 00 72 00 	adda	#114,	r8	;0x00072

000094aa <.L502>:
      reply_buff[i + 4] = bank0p[RegMissionTimeMsb - i];
    94aa:	ee 4c 00 00 	mov.b	@r12,	0(r14)	;

000094ae <.LVL700>:
    94ae:	ac 0f ff ff 	adda	#1048575,r12	;0xfffff
    94b2:	ae 00 01 00 	adda	#1,	r14	;

000094b6 <.LVL701>:
    for (int i = 0; i < 4; i++) {
    94b6:	dc 08       	cmpa	r8,	r12	;
    94b8:	f8 23       	jnz	$-14     	;abs 0x94aa

000094ba <.LBE90>:
    if (hdr.crc) {
    94ba:	40 18 17 b3 	bitx.w	#1,	r7	;r3 As==01
    94be:	08 24       	jz	$+18     	;abs 0x94d0

000094c0 <.Loc.1089.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    94c0:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    94c4:	2d 52       	add	#4,	r13	;r2 As==10
    94c6:	40 18 0d 4d 	movx.w	r13,	r13	;
    94ca:	cc 0a       	mova	r10,	r12	;
    94cc:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

000094d0 <.L503>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    94d0:	0d 49       	mov	r9,	r13	;
    94d2:	cc 0a       	mova	r10,	r12	;
    94d4:	b0 13 98 7e 	calla	#32408		;0x07e98

000094d8 <.L498>:
}
    94d8:	46 16       	popm.a	#5,	r10	;20-bit words
    94da:	10 01       	reta			;

000094dc <set_time>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    94dc:	5a 14       	pushm.a	#6,	r10	;20-bit words

000094de <.LCFI81>:
    94de:	2e 4d       	mov	@r13,	r14	;

000094e0 <.LVL705>:
    94e0:	17 4d 02 00 	mov	2(r13),	r7	;

000094e4 <.LVL706>:
    94e4:	09 4e       	mov	r14,	r9	;
    94e6:	59 07       	rrum	#2,	r9	;
    94e8:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
    94ec:	05 4e       	mov	r14,	r5	;
    94ee:	55 0f       	rrum	#4,	r5	;
    94f0:	55 0f       	rrum	#4,	r5	;

000094f2 <.Loc.1035.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    94f2:	06 49       	mov	r9,	r6	;
    94f4:	76 f0 3f 00 	and.b	#63,	r6	;#0x003f
    94f8:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    94fc:	7e f0 03 00 	and.b	#3,	r14	;

00009500 <.LVL708>:
    9500:	06 de       	bis	r14,	r6	;
    9502:	4a 46       	mov.b	r6,	r10	;
    9504:	6a f3       	and.b	#2,	r10	;r3 As==10
    9506:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    950a:	0a 93       	cmp	#0,	r10	;r3 As==00
    950c:	46 20       	jnz	$+142    	;abs 0x959a
    950e:	6e 43       	mov.b	#2,	r14	;r3 As==10

00009510 <.L512>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    9510:	28 01 26 01 	mova	&65830,	r8	;0x10126
    9514:	40 18 0e 4e 	movx.w	r14,	r14	;
    9518:	ee 0c       	adda	r12,	r14	;

0000951a <.LVL710>:
    951a:	e8 4e 76 00 	mov.b	@r14,	118(r8)	; 0x0076

0000951e <.Loc.1039.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    951e:	d8 4e 01 00 	mov.b	1(r14),	117(r8)	; 0x0075
    9522:	75 00 

00009524 <.Loc.1040.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    9524:	d8 4e 02 00 	mov.b	2(r14),	116(r8)	; 0x0074
    9528:	74 00 

0000952a <.Loc.1041.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    952a:	d8 4e 03 00 	mov.b	3(r14),	115(r8)	; 0x0073
    952e:	73 00 

00009530 <.Loc.1043.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9530:	b0 13 16 c5 	calla	#50454		;0x0c516

00009534 <.LVL711>:
    9534:	b0 13 80 c2 	calla	#49792		;0x0c280

00009538 <.LVL712>:
  if (hdr.reply) {
    9538:	0a 93       	cmp	#0,	r10	;r3 As==00
    953a:	2d 24       	jz	$+92     	;abs 0x9596

0000953c <.LBB91>:
    uint8_t * reply_buff = elyFWGetBuffer();
    953c:	b0 13 b2 77 	calla	#30642		;0x077b2

00009540 <.LVL713>:
    9540:	ca 0c       	mova	r12,	r10	;

00009542 <.LVL714>:
    if (reply_buff == NULL) {
    9542:	9c 00 00 00 	cmpa	#0,	r12	;
    9546:	27 24       	jz	$+80     	;abs 0x9596

00009548 <.Loc.1052.2>:
    reply_buff[0] = hdr.opcode;
    9548:	cc 49 00 00 	mov.b	r9,	0(r12)	;

0000954c <.Loc.1053.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    954c:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    9550:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    9554:	02 00 

00009556 <.Loc.1054.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9556:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    955a:	03 00 

0000955c <.Loc.1055.2>:
    reply_buff[1] = hdr.length - 2;
    955c:	75 50 fe ff 	add.b	#-2,	r5	;#0xfffe
    9560:	4d 45       	mov.b	r5,	r13	;
    9562:	cc 45 01 00 	mov.b	r5,	1(r12)	;

00009566 <.Loc.1056.2>:
    reply_buff[4] = bank0w[RegMissionTimeMsb];
    9566:	dc 48 76 00 	mov.b	118(r8),4(r12)	;0x00076
    956a:	04 00 

0000956c <.Loc.1057.2>:
    reply_buff[5] = bank0w[RegMissionTimeHmb];
    956c:	dc 48 75 00 	mov.b	117(r8),5(r12)	;0x00075
    9570:	05 00 

00009572 <.Loc.1058.2>:
    reply_buff[6] = bank0w[RegMissionTimeLmb];
    9572:	dc 48 74 00 	mov.b	116(r8),6(r12)	;0x00074
    9576:	06 00 

00009578 <.Loc.1059.2>:
    reply_buff[7] = bank0w[RegMissionTimeLsb];
    9578:	dc 48 73 00 	mov.b	115(r8),7(r12)	;0x00073
    957c:	07 00 

0000957e <.Loc.1060.2>:
    if (hdr.crc) {
    957e:	40 18 16 b3 	bitx.w	#1,	r6	;r3 As==01
    9582:	05 24       	jz	$+12     	;abs 0x958e

00009584 <.Loc.1061.2>:
      crcGenX25(reply_buff, reply_buff[1]+4);
    9584:	2d 52       	add	#4,	r13	;r2 As==10
    9586:	4d 0e       	rlam.a	#4,	r13	;
    9588:	4d 0d       	rram.a	#4,	r13	;
    958a:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

0000958e <.L516>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    958e:	0d 47       	mov	r7,	r13	;
    9590:	cc 0a       	mova	r10,	r12	;
    9592:	b0 13 98 7e 	calla	#32408		;0x07e98

00009596 <.L511>:
}
    9596:	55 16       	popm.a	#6,	r10	;20-bit words
    9598:	10 01       	reta			;

0000959a <.L517>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    959a:	6e 42       	mov.b	#4,	r14	;r2 As==10
    959c:	80 00 10 95 	mova	#38160,	r0	;0x09510

000095a0 <get_chan>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    95a0:	6a 14       	pushm.a	#7,	r10	;20-bit words

000095a2 <.LCFI82>:
    95a2:	b1 00 04 00 	suba	#4,	r1	;

000095a6 <.LCFI83>:
    95a6:	ca 0c       	mova	r12,	r10	;
    95a8:	2e 4d       	mov	@r13,	r14	;

000095aa <.LVL720>:
    95aa:	17 4d 02 00 	mov	2(r13),	r7	;

000095ae <.LVL721>:
    95ae:	09 4e       	mov	r14,	r9	;
    95b0:	59 07       	rrum	#2,	r9	;
    95b2:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

000095b6 <.Loc.826.2>:
  if (hdr.reply) {
    95b6:	0d 49       	mov	r9,	r13	;
    95b8:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    95bc:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    95c0:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

000095c4 <.LVL724>:
    95c4:	0d de       	bis	r14,	r13	;
    95c6:	45 4d       	mov.b	r13,	r5	;
    95c8:	88 00 16 c5 	mova	#50454,	r8	;0x0c516
    95cc:	86 00 80 c2 	mova	#49792,	r6	;0x0c280
    95d0:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    95d4:	1d 24       	jz	$+60     	;abs 0x9610

000095d6 <.LBB92>:
    if ((buffer[4] < 0x40) || 
    95d6:	5c 4c 04 00 	mov.b	4(r12),	r12	;

000095da <.LVL725>:
    95da:	4e 4c       	mov.b	r12,	r14	;
    95dc:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    95e0:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    95e4:	4f 9e       	cmp.b	r14,	r15	;
    95e6:	0c 28       	jnc	$+26     	;abs 0x9600

000095e8 <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    95e8:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

000095ec <.Loc.827.2>:
    if ((buffer[4] < 0x40) || 
    95ec:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    95f0:	4f 9e       	cmp.b	r14,	r15	;
    95f2:	06 2c       	jc	$+14     	;abs 0x9600

000095f4 <.Loc.829.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    95f4:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

000095f8 <.Loc.828.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    95f8:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    95fc:	4e 9c       	cmp.b	r12,	r14	;
    95fe:	0c 28       	jnc	$+26     	;abs 0x9618

00009600 <.L526>:
        gen_failure(hdr);
    9600:	81 4d 00 00 	mov	r13,	0(r1)	;
    9604:	81 47 02 00 	mov	r7,	2(r1)	;
    9608:	cc 01       	mova	r1,	r12	;
    960a:	b0 13 02 82 	calla	#33282		;0x08202

0000960e <.L532>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    960e:	cc 0a       	mova	r10,	r12	;

00009610 <.L525>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9610:	48 13       	calla	r8		;

00009612 <.LVL728>:
    9612:	46 13       	calla	r6		;

00009614 <.LVL729>:
    9614:	80 00 7a 96 	mova	#38522,	r0	;0x0967a

00009618 <.L527>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9618:	b0 13 b2 77 	calla	#30642		;0x077b2

0000961c <.LVL730>:
    961c:	c4 0c       	mova	r12,	r4	;

0000961e <.LVL731>:
    if (reply_buff == NULL) {
    961e:	9c 00 00 00 	cmpa	#0,	r12	;
    9622:	f5 27       	jz	$-20     	;abs 0x960e

00009624 <.Loc.844.2>:
    reply_buff[0] = hdr.opcode;
    9624:	cc 49 00 00 	mov.b	r9,	0(r12)	;

00009628 <.Loc.845.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9628:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    962c:	d4 4c 51 00 	mov.b	81(r12),2(r4)	;0x00051
    9630:	02 00 

00009632 <.Loc.846.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9632:	d4 4c 50 00 	mov.b	80(r12),3(r4)	;0x00050
    9636:	03 00 

00009638 <.Loc.849.2>:
    size_t n = elyChanGetValue(&reply_buff[4], buffer[4]);
    9638:	5d 4a 04 00 	mov.b	4(r10),	r13	;
    963c:	cc 04       	mova	r4,	r12	;
    963e:	ac 00 04 00 	adda	#4,	r12	;
    9642:	b0 13 44 a7 	calla	#42820		;0x0a744

00009646 <.LVL732>:
    9646:	c9 0c       	mova	r12,	r9	;

00009648 <.LVL733>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9648:	cc 0a       	mova	r10,	r12	;
    964a:	48 13       	calla	r8		;

0000964c <.LVL734>:
    964c:	46 13       	calla	r6		;

0000964e <.LVL735>:
    964e:	09 14       	pushm.a	#1,	r9	;20-bit words
    9650:	40 18 3c 41 	popx.w	r12		;
    9654:	40 18 3d 41 	popx.w	r13		;

00009658 <.Loc.853.2>:
    if (hdr.crc) {
    9658:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    965c:	12 24       	jz	$+38     	;abs 0x9682

0000965e <.Loc.854.2>:
      reply_buff[1] = n + 3;
    965e:	7c 50 03 00 	add.b	#3,	r12	;
    9662:	c4 4c 01 00 	mov.b	r12,	1(r4)	;

00009666 <.Loc.855.2>:
      crcGenX25(reply_buff, 7+n);
    9666:	cd 09       	mova	r9,	r13	;
    9668:	ad 00 07 00 	adda	#7,	r13	;
    966c:	cc 04       	mova	r4,	r12	;
    966e:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00009672 <.L531>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9672:	0d 47       	mov	r7,	r13	;
    9674:	cc 04       	mova	r4,	r12	;
    9676:	b0 13 98 7e 	calla	#32408		;0x07e98

0000967a <.L524>:
}
    967a:	a1 00 04 00 	adda	#4,	r1	;
    967e:	64 16       	popm.a	#7,	r10	;20-bit words
    9680:	10 01       	reta			;

00009682 <.L530>:
      reply_buff[1] = n + 1;
    9682:	5c 53       	inc.b	r12		;
    9684:	c4 4c 01 00 	mov.b	r12,	1(r4)	;
    9688:	80 00 72 96 	mova	#38514,	r0	;0x09672

0000968c <get_u32>:
    const uint32_t max, const uint32_t min) {
    968c:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000968e <.LCFI84>:
    968e:	b1 00 0e 00 	suba	#14,	r1	;0x0000e

00009692 <.LCFI85>:
    9692:	46 4c       	mov.b	r12,	r6	;
    9694:	2c 4d       	mov	@r13,	r12	;

00009696 <.LVL740>:
    9696:	91 4d 02 00 	mov	2(r13),	12(r1)	; 0x000c
    969a:	0c 00 
    969c:	07 4e       	mov	r14,	r7	;
    969e:	08 4f       	mov	r15,	r8	;
    96a0:	91 41 2e 00 	mov	46(r1),	8(r1)	;0x0002e
    96a4:	08 00 
    96a6:	15 41 30 00 	mov	48(r1),	r5	;0x00030
    96aa:	09 4c       	mov	r12,	r9	;
    96ac:	59 07       	rrum	#2,	r9	;
    96ae:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f

000096b2 <.Loc.85.2>:
  if (hdr.reply) {
    96b2:	0d 49       	mov	r9,	r13	;
    96b4:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    96b8:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    96bc:	7c f0 03 00 	and.b	#3,	r12	;

000096c0 <.LVL743>:
    96c0:	0c dd       	bis	r13,	r12	;
    96c2:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    96c6:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    96ca:	71 24       	jz	$+228    	;abs 0x97ae

000096cc <.LBB95>:
    uint8_t * reply_buff = elyFWGetBuffer();
    96cc:	b0 13 b2 77 	calla	#30642		;0x077b2

000096d0 <.LVL744>:
    96d0:	ca 0c       	mova	r12,	r10	;

000096d2 <.LVL745>:
    if (reply_buff == NULL) {
    96d2:	9c 00 00 00 	cmpa	#0,	r12	;
    96d6:	6b 24       	jz	$+216    	;abs 0x97ae

000096d8 <.Loc.92.2>:
    reply_buff[0] = hdr.opcode;
    96d8:	cc 49 00 00 	mov.b	r9,	0(r12)	;

000096dc <.Loc.93.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    96dc:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    96e0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    96e4:	02 00 

000096e6 <.Loc.94.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    96e6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    96ea:	03 00 

000096ec <.LVL746>:
    96ec:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    96f0:	04 00 
    96f2:	3b 01 04 00 	mova	4(r1),	r11	;
    96f6:	eb 0c       	adda	r12,	r11	;
    96f8:	44 43       	clr.b	r4		;

000096fa <.Loc.96.2>:
    uint32_t val = 0;
    96fa:	09 44       	mov	r4,	r9	;
    96fc:	06 44       	mov	r4,	r6	;

000096fe <.L537>:
      val |= ((uint32_t)(bank0p[addr + i]) << (8 * i));
    96fe:	6c 4b       	mov.b	@r11,	r12	;
    9700:	0d 43       	clr	r13		;
    9702:	0e 44       	mov	r4,	r14	;
    9704:	0f 43       	clr	r15		;
    9706:	71 0b 00 00 	mova	r11,	0(r1)	;
    970a:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    970e:	0c d9       	bis	r9,	r12	;
    9710:	0d d6       	bis	r6,	r13	;
    9712:	09 4c       	mov	r12,	r9	;

00009714 <.LVL750>:
    9714:	06 4d       	mov	r13,	r6	;

00009716 <.LVL751>:
    9716:	0b 01       	mova	@r1,	r11	;
    9718:	ab 00 01 00 	adda	#1,	r11	;
    971c:	34 52       	add	#8,	r4	;r2 As==11

0000971e <.Loc.97.2>:
    for (int i = 0; i < 4; i++) {
    971e:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    9722:	ed 23       	jnz	$-36     	;abs 0x96fe

00009724 <.LBE96>:
    if (val > max) {
    9724:	08 9d       	cmp	r13,	r8	;
    9726:	04 28       	jnc	$+10     	;abs 0x9730
    9728:	0d 98       	cmp	r8,	r13	;
    972a:	45 20       	jnz	$+140    	;abs 0x97b6
    972c:	07 9c       	cmp	r12,	r7	;
    972e:	43 2c       	jc	$+136    	;abs 0x97b6

00009730 <.L546>:
    9730:	36 01 04 00 	mova	4(r1),	r6	;

00009734 <.LVL752>:
    9734:	80 18 56 52 	addx.a	&0x10126,r6	;
    9738:	26 01 

0000973a <.LBB97>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    973a:	49 43       	clr.b	r9		;

0000973c <.L540>:
    973c:	0c 47       	mov	r7,	r12	;
    973e:	0d 48       	mov	r8,	r13	;
    9740:	0e 49       	mov	r9,	r14	;
    9742:	0f 43       	clr	r15		;
    9744:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    9748:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    974c:	39 52       	add	#8,	r9	;r2 As==11
    974e:	a6 00 01 00 	adda	#1,	r6	;

00009752 <.Loc.103.2>:
      for (int i = 0; i < 4; i++) {
    9752:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    9756:	f2 23       	jnz	$-26     	;abs 0x973c
    9758:	09 47       	mov	r7,	r9	;
    975a:	06 48       	mov	r8,	r6	;

0000975c <.L541>:
      reply_buff[i + 4] = ((val >> (8 * (3 - i))) & 0xFF);
    975c:	0c 49       	mov	r9,	r12	;
    975e:	0d 46       	mov	r6,	r13	;
    9760:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    9764:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    9768:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

0000976c <.LVL759>:
    976c:	0c 49       	mov	r9,	r12	;
    976e:	0d 46       	mov	r6,	r13	;
    9770:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9774:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    9778:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

0000977c <.LVL761>:
    977c:	0c 49       	mov	r9,	r12	;
    977e:	0d 46       	mov	r6,	r13	;
    9780:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    9784:	ca 4c 06 00 	mov.b	r12,	6(r10)	;

00009788 <.LVL763>:
    9788:	ca 49 07 00 	mov.b	r9,	7(r10)	;

0000978c <.LBE98>:
    if (hdr.crc) {
    978c:	40 18 91 b3 	bitx.w	#1,	10(r1)	;r3 As==01, 0x0000a
    9790:	0a 00 
    9792:	32 24       	jz	$+102    	;abs 0x97f8

00009794 <.Loc.119.2>:
      reply_buff[1] = 6;
    9794:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    9798:	01 00 

0000979a <.Loc.120.2>:
      crcGenX25(reply_buff, 10);
    979a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    979e:	cc 0a       	mova	r10,	r12	;
    97a0:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

000097a4 <.L545>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    97a4:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    97a8:	cc 0a       	mova	r10,	r12	;
    97aa:	b0 13 98 7e 	calla	#32408		;0x07e98

000097ae <.L533>:
}
    97ae:	a1 00 0e 00 	adda	#14,	r1	;0x0000e
    97b2:	64 16       	popm.a	#7,	r10	;20-bit words
    97b4:	10 01       	reta			;

000097b6 <.L538>:
    else if (val < min) {
    97b6:	0d 95       	cmp	r5,	r13	;
    97b8:	05 28       	jnc	$+12     	;abs 0x97c4
    97ba:	05 9d       	cmp	r13,	r5	;
    97bc:	cf 23       	jnz	$-96     	;abs 0x975c
    97be:	1c 91 08 00 	cmp	8(r1),	r12	;
    97c2:	cc 2f       	jc	$-102    	;abs 0x975c

000097c4 <.L547>:
    97c4:	36 01 04 00 	mova	4(r1),	r6	;

000097c8 <.LVL768>:
    97c8:	80 18 56 52 	addx.a	&0x10126,r6	;
    97cc:	26 01 

000097ce <.LBB99>:
        bank0w[addr + i] = ((val >> (8 * i)) & 0xFF);
    97ce:	49 43       	clr.b	r9		;

000097d0 <.L543>:
    97d0:	1c 41 08 00 	mov	8(r1),	r12	;
    97d4:	0d 45       	mov	r5,	r13	;
    97d6:	0e 49       	mov	r9,	r14	;
    97d8:	0f 43       	clr	r15		;
    97da:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    97de:	c6 4c 00 00 	mov.b	r12,	0(r6)	;
    97e2:	39 52       	add	#8,	r9	;r2 As==11
    97e4:	a6 00 01 00 	adda	#1,	r6	;

000097e8 <.Loc.109.2>:
      for (int i = 0; i < 4; i++) {
    97e8:	39 90 20 00 	cmp	#32,	r9	;#0x0020
    97ec:	f1 23       	jnz	$-28     	;abs 0x97d0
    97ee:	19 41 08 00 	mov	8(r1),	r9	;
    97f2:	06 45       	mov	r5,	r6	;
    97f4:	80 00 5c 97 	mova	#38748,	r0	;0x0975c

000097f8 <.L544>:
      reply_buff[1] = 4;
    97f8:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    97fc:	80 00 a4 97 	mova	#38820,	r0	;0x097a4

00009800 <get_baud>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9800:	19 14       	pushm.a	#2,	r9	;20-bit words

00009802 <.LCFI86>:
    9802:	b1 00 08 00 	suba	#8,	r1	;

00009806 <.LCFI87>:
    9806:	28 4d       	mov	@r13,	r8	;

00009808 <.LVL776>:
    9808:	19 4d 02 00 	mov	2(r13),	r9	;

0000980c <.LVL777>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    980c:	b0 13 16 c5 	calla	#50454		;0x0c516

00009810 <.LVL778>:
    9810:	b0 13 80 c2 	calla	#49792		;0x0c280

00009814 <.LVL779>:
  get_u32(RegUARTBaudLsb, hdr, UART_BAUD_MAX, UART_BAUD_MIN);
    9814:	81 48 04 00 	mov	r8,	4(r1)	;
    9818:	81 49 06 00 	mov	r9,	6(r1)	;
    981c:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    9820:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9824:	3e 40 40 42 	mov	#16960,	r14	;#0x4240
    9828:	7f 40 0f 00 	mov.b	#15,	r15	;#0x000f
    982c:	cd 01       	mova	r1,	r13	;
    982e:	ad 00 04 00 	adda	#4,	r13	;
    9832:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    9836:	b0 13 8c 96 	calla	#38540		;0x0968c

0000983a <.LVL780>:
}
    983a:	a1 00 08 00 	adda	#8,	r1	;
    983e:	18 16       	popm.a	#2,	r9	;20-bit words
    9840:	10 01       	reta			;

00009842 <get_rx_dev>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9842:	19 14       	pushm.a	#2,	r9	;20-bit words

00009844 <.LCFI88>:
    9844:	b1 00 08 00 	suba	#8,	r1	;

00009848 <.LCFI89>:
    9848:	28 4d       	mov	@r13,	r8	;

0000984a <.LVL782>:
    984a:	19 4d 02 00 	mov	2(r13),	r9	;

0000984e <.LVL783>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    984e:	b0 13 16 c5 	calla	#50454		;0x0c516

00009852 <.LVL784>:
    9852:	b0 13 80 c2 	calla	#49792		;0x0c280

00009856 <.LVL785>:
  get_u32(RegRXDevLsb, hdr, RX_DEV_MAX, RX_DEV_MIN);
    9856:	81 48 04 00 	mov	r8,	4(r1)	;
    985a:	81 49 06 00 	mov	r9,	6(r1)	;
    985e:	b1 40 e8 80 	mov	#-32536,0(r1)	;#0x80e8
    9862:	00 00 
    9864:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9868:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    986c:	7f 40 03 00 	mov.b	#3,	r15	;
    9870:	cd 01       	mova	r1,	r13	;
    9872:	ad 00 04 00 	adda	#4,	r13	;
    9876:	7c 40 0c 00 	mov.b	#12,	r12	;#0x000c
    987a:	b0 13 8c 96 	calla	#38540		;0x0968c

0000987e <.LVL786>:
}
    987e:	a1 00 08 00 	adda	#8,	r1	;
    9882:	18 16       	popm.a	#2,	r9	;20-bit words
    9884:	10 01       	reta			;

00009886 <get_tx_dev>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9886:	19 14       	pushm.a	#2,	r9	;20-bit words

00009888 <.LCFI90>:
    9888:	b1 00 08 00 	suba	#8,	r1	;

0000988c <.LCFI91>:
    988c:	28 4d       	mov	@r13,	r8	;

0000988e <.LVL788>:
    988e:	19 4d 02 00 	mov	2(r13),	r9	;

00009892 <.LVL789>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9892:	b0 13 16 c5 	calla	#50454		;0x0c516

00009896 <.LVL790>:
    9896:	b0 13 80 c2 	calla	#49792		;0x0c280

0000989a <.LVL791>:
  get_u32(RegTXDevLsb, hdr, TX_DEV_MAX, TX_DEV_MIN);
    989a:	81 48 04 00 	mov	r8,	4(r1)	;
    989e:	81 49 06 00 	mov	r9,	6(r1)	;
    98a2:	b1 40 58 02 	mov	#600,	0(r1)	;#0x0258
    98a6:	00 00 
    98a8:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    98ac:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    98b0:	7f 40 03 00 	mov.b	#3,	r15	;
    98b4:	cd 01       	mova	r1,	r13	;
    98b6:	ad 00 04 00 	adda	#4,	r13	;
    98ba:	7c 42       	mov.b	#8,	r12	;r2 As==11
    98bc:	b0 13 8c 96 	calla	#38540		;0x0968c

000098c0 <.LVL792>:
}
    98c0:	a1 00 08 00 	adda	#8,	r1	;
    98c4:	18 16       	popm.a	#2,	r9	;20-bit words
    98c6:	10 01       	reta			;

000098c8 <get_rx_br>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    98c8:	19 14       	pushm.a	#2,	r9	;20-bit words

000098ca <.LCFI92>:
    98ca:	b1 00 08 00 	suba	#8,	r1	;

000098ce <.LCFI93>:
    98ce:	28 4d       	mov	@r13,	r8	;

000098d0 <.LVL794>:
    98d0:	19 4d 02 00 	mov	2(r13),	r9	;

000098d4 <.LVL795>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    98d4:	b0 13 16 c5 	calla	#50454		;0x0c516

000098d8 <.LVL796>:
    98d8:	b0 13 80 c2 	calla	#49792		;0x0c280

000098dc <.LVL797>:
  get_u32(RegRXBRLsb, hdr, RX_BR_MAX, RX_BR_MIN);
    98dc:	81 48 04 00 	mov	r8,	4(r1)	;
    98e0:	81 49 06 00 	mov	r9,	6(r1)	;
    98e4:	b1 40 0c 03 	mov	#780,	0(r1)	;#0x030c
    98e8:	00 00 
    98ea:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    98ee:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    98f2:	6f 43       	mov.b	#2,	r15	;r3 As==10
    98f4:	cd 01       	mova	r1,	r13	;
    98f6:	ad 00 04 00 	adda	#4,	r13	;
    98fa:	7c 40 1c 00 	mov.b	#28,	r12	;#0x001c
    98fe:	b0 13 8c 96 	calla	#38540		;0x0968c

00009902 <.LVL798>:
}
    9902:	a1 00 08 00 	adda	#8,	r1	;
    9906:	18 16       	popm.a	#2,	r9	;20-bit words
    9908:	10 01       	reta			;

0000990a <get_tx_br>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    990a:	19 14       	pushm.a	#2,	r9	;20-bit words

0000990c <.LCFI94>:
    990c:	b1 00 08 00 	suba	#8,	r1	;

00009910 <.LCFI95>:
    9910:	28 4d       	mov	@r13,	r8	;

00009912 <.LVL800>:
    9912:	19 4d 02 00 	mov	2(r13),	r9	;

00009916 <.LVL801>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9916:	b0 13 16 c5 	calla	#50454		;0x0c516

0000991a <.LVL802>:
    991a:	b0 13 80 c2 	calla	#49792		;0x0c280

0000991e <.LVL803>:
  get_u32(RegTXBRLsb, hdr, TX_BR_MAX, TX_BR_MIN);
    991e:	81 48 04 00 	mov	r8,	4(r1)	;
    9922:	81 49 06 00 	mov	r9,	6(r1)	;
    9926:	b1 40 b0 04 	mov	#1200,	0(r1)	;#0x04b0
    992a:	00 00 
    992c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9930:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    9934:	6f 42       	mov.b	#4,	r15	;r2 As==10
    9936:	cd 01       	mova	r1,	r13	;
    9938:	ad 00 04 00 	adda	#4,	r13	;
    993c:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    9940:	b0 13 8c 96 	calla	#38540		;0x0968c

00009944 <.LVL804>:
}
    9944:	a1 00 08 00 	adda	#8,	r1	;
    9948:	18 16       	popm.a	#2,	r9	;20-bit words
    994a:	10 01       	reta			;

0000994c <get_rx_freq>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    994c:	19 14       	pushm.a	#2,	r9	;20-bit words

0000994e <.LCFI96>:
    994e:	b1 00 08 00 	suba	#8,	r1	;

00009952 <.LCFI97>:
    9952:	28 4d       	mov	@r13,	r8	;

00009954 <.LVL806>:
    9954:	19 4d 02 00 	mov	2(r13),	r9	;

00009958 <.LVL807>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9958:	b0 13 16 c5 	calla	#50454		;0x0c516

0000995c <.LVL808>:
    995c:	b0 13 80 c2 	calla	#49792		;0x0c280

00009960 <.LVL809>:
  get_u32(RegRXFreqLsb, hdr, RX_BAND_MAX, RX_BAND_MIN);
    9960:	81 48 04 00 	mov	r8,	4(r1)	;
    9964:	81 49 06 00 	mov	r9,	6(r1)	;
    9968:	b1 40 40 44 	mov	#17472,	0(r1)	;#0x4440
    996c:	00 00 
    996e:	b1 40 3d 1b 	mov	#6973,	2(r1)	;#0x1b3d
    9972:	02 00 
    9974:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    9978:	3f 40 12 1c 	mov	#7186,	r15	;#0x1c12
    997c:	cd 01       	mova	r1,	r13	;
    997e:	ad 00 04 00 	adda	#4,	r13	;
    9982:	6c 42       	mov.b	#4,	r12	;r2 As==10
    9984:	b0 13 8c 96 	calla	#38540		;0x0968c

00009988 <.LVL810>:
}
    9988:	a1 00 08 00 	adda	#8,	r1	;
    998c:	18 16       	popm.a	#2,	r9	;20-bit words
    998e:	10 01       	reta			;

00009990 <get_tx_freq>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9990:	19 14       	pushm.a	#2,	r9	;20-bit words

00009992 <.LCFI98>:
    9992:	b1 00 08 00 	suba	#8,	r1	;

00009996 <.LCFI99>:
    9996:	28 4d       	mov	@r13,	r8	;

00009998 <.LVL812>:
    9998:	19 4d 02 00 	mov	2(r13),	r9	;

0000999c <.LVL813>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    999c:	b0 13 16 c5 	calla	#50454		;0x0c516

000099a0 <.LVL814>:
    99a0:	b0 13 80 c2 	calla	#49792		;0x0c280

000099a4 <.LVL815>:
  get_u32(RegTXFreqLsb, hdr, TX_BAND_MAX, TX_BAND_MIN);
    99a4:	81 48 04 00 	mov	r8,	4(r1)	;
    99a8:	81 49 06 00 	mov	r9,	6(r1)	;
    99ac:	b1 40 40 da 	mov	#-9664,	0(r1)	;#0xda40
    99b0:	00 00 
    99b2:	b1 40 8e 33 	mov	#13198,	2(r1)	;#0x338e
    99b6:	02 00 
    99b8:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    99bc:	3f 40 ec 38 	mov	#14572,	r15	;#0x38ec
    99c0:	cd 01       	mova	r1,	r13	;
    99c2:	ad 00 04 00 	adda	#4,	r13	;
    99c6:	4c 43       	clr.b	r12		;
    99c8:	b0 13 8c 96 	calla	#38540		;0x0968c

000099cc <.LVL816>:
}
    99cc:	a1 00 08 00 	adda	#8,	r1	;
    99d0:	18 16       	popm.a	#2,	r9	;20-bit words
    99d2:	10 01       	reta			;

000099d4 <get_tx_pow>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    99d4:	4a 14       	pushm.a	#5,	r10	;20-bit words

000099d6 <.LCFI100>:
    99d6:	c8 0c       	mova	r12,	r8	;
    99d8:	2a 4d       	mov	@r13,	r10	;

000099da <.LVL818>:
    99da:	16 4d 02 00 	mov	2(r13),	r6	;

000099de <.LVL819>:
    99de:	07 4a       	mov	r10,	r7	;
    99e0:	57 07       	rrum	#2,	r7	;
    99e2:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f
    99e6:	49 47       	mov.b	r7,	r9	;

000099e8 <.Loc.579.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    99e8:	b0 13 16 c5 	calla	#50454		;0x0c516

000099ec <.LVL821>:
    99ec:	b0 13 80 c2 	calla	#49792		;0x0c280

000099f0 <.LVL822>:
  if (hdr.reply) {
    99f0:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    99f4:	7a f0 03 00 	and.b	#3,	r10	;

000099f8 <.LVL823>:
    99f8:	09 da       	bis	r10,	r9	;
    99fa:	40 18 29 b3 	bitx.w	#2,	r9	;r3 As==10
    99fe:	22 24       	jz	$+70     	;abs 0x9a44

00009a00 <.LBB101>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9a00:	b0 13 b2 77 	calla	#30642		;0x077b2

00009a04 <.LVL824>:
    9a04:	ca 0c       	mova	r12,	r10	;

00009a06 <.LVL825>:
    if (reply_buff == NULL) {
    9a06:	9c 00 00 00 	cmpa	#0,	r12	;
    9a0a:	1c 24       	jz	$+58     	;abs 0x9a44

00009a0c <.Loc.588.2>:
    reply_buff[0] = hdr.opcode;
    9a0c:	cc 47 00 00 	mov.b	r7,	0(r12)	;

00009a10 <.Loc.589.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9a10:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    9a14:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9a18:	02 00 

00009a1a <.Loc.590.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9a1a:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9a1e:	03 00 

00009a20 <.Loc.591.2>:
    reply_buff[4] = bank0p[RegOutputPower];
    9a20:	da 4c 21 00 	mov.b	33(r12),4(r10)	;0x00021
    9a24:	04 00 

00009a26 <.Loc.592.2>:
    if (hdr.crc) {
    9a26:	40 18 19 b3 	bitx.w	#1,	r9	;r3 As==01
    9a2a:	0e 24       	jz	$+30     	;abs 0x9a48

00009a2c <.Loc.593.2>:
      reply_buff[1] = 3;
    9a2c:	fa 40 03 00 	mov.b	#3,	1(r10)	;
    9a30:	01 00 

00009a32 <.Loc.594.2>:
      crcGenX25(buffer, 7);
    9a32:	7d 40 07 00 	mov.b	#7,	r13	;
    9a36:	cc 08       	mova	r8,	r12	;
    9a38:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00009a3c <.L566>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9a3c:	0d 46       	mov	r6,	r13	;
    9a3e:	cc 0a       	mova	r10,	r12	;
    9a40:	b0 13 98 7e 	calla	#32408		;0x07e98

00009a44 <.L561>:
}
    9a44:	46 16       	popm.a	#5,	r10	;20-bit words
    9a46:	10 01       	reta			;

00009a48 <.L565>:
      reply_buff[1] = 1;
    9a48:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01
    9a4c:	80 00 3c 9a 	mova	#39484,	r0	;0x09a3c

00009a50 <set_block>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9a50:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009a52 <.LCFI101>:
    9a52:	b1 00 16 00 	suba	#22,	r1	;0x00016

00009a56 <.LCFI102>:
    9a56:	71 0c 08 00 	mova	r12,	8(r1)	;
    9a5a:	2a 4d       	mov	@r13,	r10	;

00009a5c <.LVL830>:
    9a5c:	15 4d 02 00 	mov	2(r13),	r5	;

00009a60 <.LVL831>:
    9a60:	09 4a       	mov	r10,	r9	;
    9a62:	59 0f       	rrum	#4,	r9	;
    9a64:	59 0f       	rrum	#4,	r9	;

00009a66 <.Loc.405.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9a66:	4f 4a       	mov.b	r10,	r15	;
    9a68:	4b 4f       	mov.b	r15,	r11	;
    9a6a:	6b f3       	and.b	#2,	r11	;r3 As==10
    9a6c:	47 4b       	mov.b	r11,	r7	;
    9a6e:	07 93       	cmp	#0,	r7	;r3 As==00
    9a70:	26 20       	jnz	$+78     	;abs 0x9abe
    9a72:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009a74 <.L571>:
  uint8_t bank = buffer[hdr_ext];
    9a74:	40 18 06 4d 	movx.w	r13,	r6	;
    9a78:	3c 01 08 00 	mova	8(r1),	r12	;

00009a7c <.LVL834>:
    9a7c:	ec 06       	adda	r6,	r12	;
    9a7e:	64 4c       	mov.b	@r12,	r4	;
    9a80:	81 44 10 00 	mov	r4,	16(r1)	; 0x0010

00009a84 <.LVL835>:
  uint8_t addr = buffer[hdr_ext+1];
    9a84:	54 4c 01 00 	mov.b	1(r12),	r4	;

00009a88 <.LVL836>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9a88:	1f b3       	bit	#1,	r15	;r3 As==01
    9a8a:	1c 20       	jnz	$+58     	;abs 0x9ac4

00009a8c <.Loc.408.2>:
    9a8c:	4d 43       	clr.b	r13		;

00009a8e <.L572>:
  uint8_t * reply_buff = elyFWGetBuffer();
    9a8e:	71 0b 00 00 	mova	r11,	0(r1)	;

00009a92 <.LVL838>:
    9a92:	71 0d 04 00 	mova	r13,	4(r1)	;
    9a96:	b0 13 b2 77 	calla	#30642		;0x077b2

00009a9a <.LVL839>:
    9a9a:	c8 0c       	mova	r12,	r8	;

00009a9c <.LVL840>:
    9a9c:	8e 00 16 c5 	mova	#50454,	r14	;0x0c516

00009aa0 <.Loc.410.2>:
  if (reply_buff == NULL) {
    9aa0:	0b 01       	mova	@r1,	r11	;
    9aa2:	3d 01 04 00 	mova	4(r1),	r13	;
    9aa6:	9c 00 00 00 	cmpa	#0,	r12	;
    9aaa:	0f 20       	jnz	$+32     	;abs 0x9aca

00009aac <.L579>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9aac:	3c 01 08 00 	mova	8(r1),	r12	;
    9ab0:	4e 13       	calla	r14		;

00009ab2 <.LVL842>:
    9ab2:	b0 13 80 c2 	calla	#49792		;0x0c280

00009ab6 <.L570>:
}
    9ab6:	a1 00 16 00 	adda	#22,	r1	;0x00016
    9aba:	64 16       	popm.a	#7,	r10	;20-bit words
    9abc:	10 01       	reta			;

00009abe <.L581>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    9abe:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9ac0:	80 00 74 9a 	mova	#39540,	r0	;0x09a74

00009ac4 <.L582>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9ac4:	6d 43       	mov.b	#2,	r13	;r3 As==10

00009ac6 <.LVL847>:
    9ac6:	80 00 8e 9a 	mova	#39566,	r0	;0x09a8e

00009aca <.L573>:
  if (bank == 0 || bank > 4 || 
    9aca:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    9ace:	7c 53       	add.b	#-1,	r12	;r3 As==11
    9ad0:	7f 40 03 00 	mov.b	#3,	r15	;
    9ad4:	4f 9c       	cmp.b	r12,	r15	;
    9ad6:	21 28       	jnc	$+68     	;abs 0x9b1a

00009ad8 <.Loc.408.2>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    9ad8:	4f 49       	mov.b	r9,	r15	;
    9ada:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe
    9ade:	4f 8b       	sub.b	r11,	r15	;
    9ae0:	4f 8d       	sub.b	r13,	r15	;
    9ae2:	4c 4f       	mov.b	r15,	r12	;

00009ae4 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    9ae4:	40 18 3d 40 	movx.w	#87,	r13	;0x00057
    9ae8:	57 00 
    9aea:	40 18 0d 8c 	subx.w	r12,	r13	;

00009aee <.Loc.417.2>:
  if (bank == 0 || bank > 4 || 
    9aee:	04 9d       	cmp	r13,	r4	;
    9af0:	02 38       	jl	$+6      	;abs 0x9af6

00009af2 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    9af2:	44 93       	cmp.b	#0,	r4	;r3 As==00
    9af4:	12 34       	jge	$+38     	;abs 0x9b1a

00009af6 <.L576>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9af6:	40 18 3d 40 	movx.w	#139,	r13	;0x0008b
    9afa:	8b 00 
    9afc:	40 18 0d 8c 	subx.w	r12,	r13	;

00009b00 <.Loc.418.2>:
      (addr >= RegCoreMAX - count + 1 && addr < 0x80) ||
    9b00:	04 9d       	cmp	r13,	r4	;
    9b02:	04 38       	jl	$+10     	;abs 0x9b0c

00009b04 <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9b04:	7b 40 bf ff 	mov.b	#-65,	r11	;#0xffbf
    9b08:	4b 94       	cmp.b	r4,	r11	;
    9b0a:	07 2c       	jc	$+16     	;abs 0x9b1a

00009b0c <.L577>:
      (addr >= RegDLLMAX - count + 1)) {
    9b0c:	40 18 3d 40 	movx.w	#214,	r13	;0x000d6
    9b10:	d6 00 
    9b12:	40 18 0d 8c 	subx.w	r12,	r13	;

00009b16 <.Loc.419.2>:
      (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9b16:	04 9d       	cmp	r13,	r4	;
    9b18:	1b 38       	jl	$+56     	;abs 0x9b50

00009b1a <.L575>:
    if (hdr.reply) {
    9b1a:	07 93       	cmp	#0,	r7	;r3 As==00
    9b1c:	c7 27       	jz	$-112    	;abs 0x9aac

00009b1e <.Loc.422.2>:
      write_failure(reply_buff, hdr);
    9b1e:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    9b22:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00009b26 <.LVL851>:
    9b26:	0a d9       	bis	r9,	r10	;
    9b28:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    9b2c:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    9b30:	cd 01       	mova	r1,	r13	;
    9b32:	ad 00 12 00 	adda	#18,	r13	;0x00012
    9b36:	cc 08       	mova	r8,	r12	;
    9b38:	71 0e 04 00 	mova	r14,	4(r1)	;
    9b3c:	b0 13 70 78 	calla	#30832		;0x07870

00009b40 <.LVL852>:
      elyCmdSendReply(reply_buff, hdr.reply_addr);
    9b40:	0d 45       	mov	r5,	r13	;
    9b42:	cc 08       	mova	r8,	r12	;
    9b44:	b0 13 98 7e 	calla	#32408		;0x07e98

00009b48 <.LVL853>:
    9b48:	3e 01 04 00 	mova	4(r1),	r14	;
    9b4c:	80 00 ac 9a 	mova	#39596,	r0	;0x09aac

00009b50 <.L578>:
  memcpy(reply_buff + 4, buffer + hdr_ext + 2, count);
    9b50:	cd 06       	mova	r6,	r13	;
    9b52:	ad 00 02 00 	adda	#2,	r13	;
    9b56:	40 18 0e 4f 	movx.w	r15,	r14	;
    9b5a:	00 18 5d 51 	addx.a	8(r1),	r13	;
    9b5e:	08 00 
    9b60:	cb 08       	mova	r8,	r11	;
    9b62:	ab 00 04 00 	adda	#4,	r11	;
    9b66:	71 0b 0c 00 	mova	r11,	12(r1)	; 0x0000c
    9b6a:	cc 0b       	mova	r11,	r12	;
    9b6c:	71 0f 04 00 	mova	r15,	4(r1)	;
    9b70:	b0 13 42 d3 	calla	#54082		;0x0d342

00009b74 <.LVL855>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9b74:	86 00 16 c5 	mova	#50454,	r6	;0x0c516

00009b78 <.LVL856>:
    9b78:	3c 01 08 00 	mova	8(r1),	r12	;
    9b7c:	46 13       	calla	r6		;

00009b7e <.LVL857>:
    9b7e:	b0 13 80 c2 	calla	#49792		;0x0c280

00009b82 <.LVL858>:
  elyRegSetBlock(bank, reply_buff + 4, addr, count);
    9b82:	3f 01 04 00 	mova	4(r1),	r15	;
    9b86:	4e 44       	mov.b	r4,	r14	;
    9b88:	3d 01 0c 00 	mova	12(r1),	r13	;0x0000c
    9b8c:	14 41 10 00 	mov	16(r1),	r4	;0x00010

00009b90 <.LVL859>:
    9b90:	4c 44       	mov.b	r4,	r12	;
    9b92:	b0 13 b8 a6 	calla	#42680		;0x0a6b8

00009b96 <.LVL860>:
  if (hdr.reply) {
    9b96:	07 93       	cmp	#0,	r7	;r3 As==00
    9b98:	15 24       	jz	$+44     	;abs 0x9bc4

00009b9a <.Loc.437.2>:
    write_success(reply_buff, hdr);
    9b9a:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    9b9e:	7a f0 ff 00 	and.b	#255,	r10	;#0x00ff

00009ba2 <.LVL863>:
    9ba2:	0a d9       	bis	r9,	r10	;
    9ba4:	81 4a 12 00 	mov	r10,	18(r1)	; 0x0012
    9ba8:	81 45 14 00 	mov	r5,	20(r1)	; 0x0014
    9bac:	cd 01       	mova	r1,	r13	;
    9bae:	ad 00 12 00 	adda	#18,	r13	;0x00012
    9bb2:	cc 08       	mova	r8,	r12	;
    9bb4:	b0 13 52 7a 	calla	#31314		;0x07a52

00009bb8 <.LVL864>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9bb8:	0d 45       	mov	r5,	r13	;
    9bba:	cc 08       	mova	r8,	r12	;
    9bbc:	b0 13 98 7e 	calla	#32408		;0x07e98

00009bc0 <.LVL865>:
    9bc0:	80 00 b6 9a 	mova	#39606,	r0	;0x09ab6

00009bc4 <.L580>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    9bc4:	cc 08       	mova	r8,	r12	;
    9bc6:	46 13       	calla	r6		;

00009bc8 <.LVL867>:
    9bc8:	b0 13 da 77 	calla	#30682		;0x077da

00009bcc <.LVL868>:
    9bcc:	80 00 b6 9a 	mova	#39606,	r0	;0x09ab6

00009bd0 <get_block>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9bd0:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009bd2 <.LCFI103>:
    9bd2:	b1 00 0c 00 	suba	#12,	r1	;0x0000c

00009bd6 <.LCFI104>:
    9bd6:	2f 4d       	mov	@r13,	r15	;

00009bd8 <.LVL870>:
    9bd8:	16 4d 02 00 	mov	2(r13),	r6	;

00009bdc <.LVL871>:
    9bdc:	07 4f       	mov	r15,	r7	;
    9bde:	57 07       	rrum	#2,	r7	;
    9be0:	77 f0 3f 00 	and.b	#63,	r7	;#0x003f

00009be4 <.Loc.358.2>:
  if (hdr.reply) { /* reply requested */
    9be4:	08 47       	mov	r7,	r8	;
    9be6:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    9bea:	41 18 08 58 	rpt #2 { rlax.w	r8		;
    9bee:	3f f0 03 ff 	and	#-253,	r15	;#0xff03

00009bf2 <.LVL873>:
    9bf2:	08 df       	bis	r15,	r8	;
    9bf4:	45 48       	mov.b	r8,	r5	;
    9bf6:	8f 00 16 c5 	mova	#50454,	r15	;0x0c516
    9bfa:	84 00 80 c2 	mova	#49792,	r4	;0x0c280
    9bfe:	40 18 25 b3 	bitx.w	#2,	r5	;r3 As==10
    9c02:	0e 24       	jz	$+30     	;abs 0x9c20

00009c04 <.LBB103>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9c04:	71 0c 04 00 	mova	r12,	4(r1)	;
    9c08:	71 0f 00 00 	mova	r15,	0(r1)	;
    9c0c:	b0 13 b2 77 	calla	#30642		;0x077b2

00009c10 <.LVL875>:
    9c10:	ca 0c       	mova	r12,	r10	;

00009c12 <.LVL876>:
    if (reply_buff == NULL) {
    9c12:	3e 01 04 00 	mova	4(r1),	r14	;
    9c16:	0f 01       	mova	@r1,	r15	;
    9c18:	9c 00 00 00 	cmpa	#0,	r12	;
    9c1c:	05 20       	jnz	$+12     	;abs 0x9c28

00009c1e <.Loc.362.2>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    9c1e:	cc 0e       	mova	r14,	r12	;

00009c20 <.L587>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9c20:	4f 13       	calla	r15		;

00009c22 <.LVL878>:
    9c22:	44 13       	calla	r4		;

00009c24 <.LVL879>:
    9c24:	80 00 b0 9c 	mova	#40112,	r0	;0x09cb0

00009c28 <.L588>:
    uint8_t bank = buffer[4];
    9c28:	5b 4e 04 00 	mov.b	4(r14),	r11	;

00009c2c <.LVL881>:
    uint8_t addr = buffer[5];
    9c2c:	5d 4e 05 00 	mov.b	5(r14),	r13	;

00009c30 <.LVL882>:
    uint8_t count = buffer[6];
    9c30:	59 4e 06 00 	mov.b	6(r14),	r9	;

00009c34 <.LVL883>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9c34:	cc 0e       	mova	r14,	r12	;
    9c36:	71 0b 04 00 	mova	r11,	4(r1)	;

00009c3a <.LVL884>:
    9c3a:	71 0d 00 00 	mova	r13,	0(r1)	;
    9c3e:	4f 13       	calla	r15		;

00009c40 <.LVL885>:
    9c40:	44 13       	calla	r4		;

00009c42 <.LVL886>:
    if (bank > 4 || 
    9c42:	3b 01 04 00 	mova	4(r1),	r11	;
    9c46:	0d 01       	mova	@r1,	r13	;
    9c48:	6c 42       	mov.b	#4,	r12	;r2 As==10
    9c4a:	4c 9b       	cmp.b	r11,	r12	;
    9c4c:	23 28       	jnc	$+72     	;abs 0x9c94

00009c4e <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    9c4e:	40 18 3c 40 	movx.w	#87,	r12	;0x00057
    9c52:	57 00 
    9c54:	40 18 0c 89 	subx.w	r9,	r12	;

00009c58 <.Loc.373.2>:
    if (bank > 4 || 
    9c58:	0d 9c       	cmp	r12,	r13	;
    9c5a:	04 38       	jl	$+10     	;abs 0x9c64

00009c5c <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    9c5c:	7e 40 5f 00 	mov.b	#95,	r14	;#0x005f
    9c60:	4e 9d       	cmp.b	r13,	r14	;
    9c62:	18 2c       	jc	$+50     	;abs 0x9c94

00009c64 <.L591>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9c64:	4c 4d       	mov.b	r13,	r12	;
    9c66:	7c 50 89 ff 	add.b	#-119,	r12	;#0xff89

00009c6a <.Loc.374.2>:
        (addr >= RegCoreMAX - count + 1 && addr < 0x60) ||
    9c6a:	7e 42       	mov.b	#8,	r14	;r2 As==11
    9c6c:	4e 9c       	cmp.b	r12,	r14	;
    9c6e:	12 2c       	jc	$+38     	;abs 0x9c94

00009c70 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9c70:	40 18 3c 40 	movx.w	#139,	r12	;0x0008b
    9c74:	8b 00 
    9c76:	40 18 0c 89 	subx.w	r9,	r12	;

00009c7a <.Loc.375.2>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9c7a:	0d 9c       	cmp	r12,	r13	;
    9c7c:	04 38       	jl	$+10     	;abs 0x9c86

00009c7e <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9c7e:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    9c82:	4c 9d       	cmp.b	r13,	r12	;
    9c84:	07 2c       	jc	$+16     	;abs 0x9c94

00009c86 <.L592>:
        (addr >= RegDLLMAX - count + 1)) {
    9c86:	40 18 3c 40 	movx.w	#214,	r12	;0x000d6
    9c8a:	d6 00 
    9c8c:	40 18 0c 89 	subx.w	r9,	r12	;

00009c90 <.Loc.376.2>:
        (addr >= RegNLMAX - count + 1 && addr < 0xC0) ||
    9c90:	0d 9c       	cmp	r12,	r13	;
    9c92:	12 38       	jl	$+38     	;abs 0x9cb8

00009c94 <.L590>:
      write_failure(reply_buff, hdr);
    9c94:	81 48 08 00 	mov	r8,	8(r1)	;
    9c98:	81 46 0a 00 	mov	r6,	10(r1)	; 0x000a
    9c9c:	cd 01       	mova	r1,	r13	;
    9c9e:	ad 00 08 00 	adda	#8,	r13	;
    9ca2:	cc 0a       	mova	r10,	r12	;
    9ca4:	b0 13 70 78 	calla	#30832		;0x07870

00009ca8 <.L595>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9ca8:	0d 46       	mov	r6,	r13	;
    9caa:	cc 0a       	mova	r10,	r12	;
    9cac:	b0 13 98 7e 	calla	#32408		;0x07e98

00009cb0 <.L586>:
}
    9cb0:	a1 00 0c 00 	adda	#12,	r1	;0x0000c
    9cb4:	64 16       	popm.a	#7,	r10	;20-bit words
    9cb6:	10 01       	reta			;

00009cb8 <.L593>:
    elyRegGetBlock(bank, reply_buff + 4, addr, count);
    9cb8:	4f 49       	mov.b	r9,	r15	;
    9cba:	4e 4d       	mov.b	r13,	r14	;
    9cbc:	cd 0a       	mova	r10,	r13	;
    9cbe:	ad 00 04 00 	adda	#4,	r13	;
    9cc2:	4c 4b       	mov.b	r11,	r12	;
    9cc4:	b0 13 72 a6 	calla	#42610		;0x0a672

00009cc8 <.LVL891>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    9cc8:	ca 47 00 00 	mov.b	r7,	0(r10)	;

00009ccc <.Loc.386.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9ccc:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    9cd0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9cd4:	02 00 

00009cd6 <.Loc.387.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9cd6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9cda:	03 00 

00009cdc <.Loc.389.2>:
    if (hdr.crc) {
    9cdc:	40 18 15 b3 	bitx.w	#1,	r5	;r3 As==01
    9ce0:	0e 24       	jz	$+30     	;abs 0x9cfe

00009ce2 <.Loc.390.2>:
      reply_buff[1] = count + 2; 
    9ce2:	4e 49       	mov.b	r9,	r14	;
    9ce4:	6e 53       	incd.b	r14		;
    9ce6:	ca 4e 01 00 	mov.b	r14,	1(r10)	;

00009cea <.Loc.391.2>:
      crcGenX25(reply_buff, count + 6);
    9cea:	0d 49       	mov	r9,	r13	;
    9cec:	3d 50 06 00 	add	#6,	r13	;
    9cf0:	4d 0e       	rlam.a	#4,	r13	;
    9cf2:	4d 0d       	rram.a	#4,	r13	;
    9cf4:	cc 0a       	mova	r10,	r12	;
    9cf6:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00009cfa <.LVL892>:
    9cfa:	80 00 a8 9c 	mova	#40104,	r0	;0x09ca8

00009cfe <.L594>:
      reply_buff[1] = count; 
    9cfe:	ca 49 01 00 	mov.b	r9,	1(r10)	;
    9d02:	80 00 a8 9c 	mova	#40104,	r0	;0x09ca8

00009d06 <set_regs>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9d06:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009d08 <.LCFI105>:
    9d08:	b1 00 10 00 	suba	#16,	r1	;0x00010

00009d0c <.LCFI106>:
    9d0c:	c8 0c       	mova	r12,	r8	;
    9d0e:	25 4d       	mov	@r13,	r5	;

00009d10 <.LVL894>:
    9d10:	91 4d 02 00 	mov	2(r13),	2(r1)	;
    9d14:	02 00 
    9d16:	09 45       	mov	r5,	r9	;
    9d18:	59 0f       	rrum	#4,	r9	;
    9d1a:	59 0f       	rrum	#4,	r9	;

00009d1c <.Loc.309.2>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    9d1c:	4c 45       	mov.b	r5,	r12	;

00009d1e <.LVL896>:
    9d1e:	44 4c       	mov.b	r12,	r4	;
    9d20:	64 f3       	and.b	#2,	r4	;r3 As==10
    9d22:	34 f0 ff 00 	and	#255,	r4	;#0x00ff
    9d26:	04 93       	cmp	#0,	r4	;r3 As==00
    9d28:	5b 24       	jz	$+184    	;abs 0x9de0

00009d2a <.Loc.309.2>:
    9d2a:	57 48 04 00 	mov.b	4(r8),	r7	;

00009d2e <.LVL897>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    9d2e:	76 40 05 00 	mov.b	#5,	r6	;

00009d32 <.L598>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    9d32:	1c b3       	bit	#1,	r12	;r3 As==01
    9d34:	5b 20       	jnz	$+184    	;abs 0x9dec

00009d36 <.Loc.311.2>:
    9d36:	4d 43       	clr.b	r13		;

00009d38 <.L599>:
    9d38:	40 18 0c 49 	movx.w	r9,	r12	;
    9d3c:	40 18 0c 8d 	subx.w	r13,	r12	;
    9d40:	0c 84       	sub	r4,	r12	;
    9d42:	0d 4c       	mov	r12,	r13	;
    9d44:	5d 03       	rrum	#1,	r13	;
    9d46:	4d 18 0d 11 	rpt #14 { rrax.w	r13		;
    9d4a:	0c 5d       	add	r13,	r12	;
    9d4c:	0c 11       	rra	r12		;
    9d4e:	81 4c 08 00 	mov	r12,	8(r1)	;

00009d52 <.LVL900>:
  uint8_t * reply_buff = elyFWGetBuffer();
    9d52:	b0 13 b2 77 	calla	#30642		;0x077b2

00009d56 <.LVL901>:
    9d56:	ca 0c       	mova	r12,	r10	;

00009d58 <.LVL902>:
  if (reply_buff == NULL) {
    9d58:	9c 00 00 00 	cmpa	#0,	r12	;
    9d5c:	7a 24       	jz	$+246    	;abs 0x9e52

00009d5e <.LBB106>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    9d5e:	1b 41 08 00 	mov	8(r1),	r11	;
    9d62:	7b f0 ff 00 	and.b	#255,	r11	;#0x00ff
    9d66:	0b 5b       	rla	r11		;
    9d68:	81 4b 00 00 	mov	r11,	0(r1)	;
    9d6c:	00 18 c1 46 	movx.a	r6,	4(r1)	;
    9d70:	04 00 
    9d72:	36 01 04 00 	mova	4(r1),	r6	;

00009d76 <.LVL903>:
    9d76:	e6 0c       	adda	r12,	r6	;
    9d78:	3e 01 04 00 	mova	4(r1),	r14	;
    9d7c:	ee 08       	adda	r8,	r14	;
    9d7e:	4d 43       	clr.b	r13		;

00009d80 <.LBB107>:
    if ((bank == 0) || (bank > 4) ||
    9d80:	4b 47       	mov.b	r7,	r11	;
    9d82:	7b 53       	add.b	#-1,	r11	;r3 As==11
    9d84:	c1 4b 0b 00 	mov.b	r11,	11(r1)	; 0x000b

00009d88 <.L601>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    9d88:	2d 91       	cmp	@r1,	r13	;
    9d8a:	33 38       	jl	$+104    	;abs 0x9df2

00009d8c <.LBE106>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    9d8c:	86 00 16 c5 	mova	#50454,	r6	;0x0c516
    9d90:	cc 08       	mova	r8,	r12	;
    9d92:	46 13       	calla	r6		;

00009d94 <.LVL905>:
    9d94:	b0 13 80 c2 	calla	#49792		;0x0c280

00009d98 <.LVL906>:
  elyRegSet(bank, reply_buff + regs_offset-1, num_regs);
    9d98:	3d 01 04 00 	mova	4(r1),	r13	;
    9d9c:	ad 0f ff ff 	adda	#1048575,r13	;0xfffff
    9da0:	1b 41 08 00 	mov	8(r1),	r11	;
    9da4:	4e 4b       	mov.b	r11,	r14	;
    9da6:	ed 0a       	adda	r10,	r13	;
    9da8:	4c 47       	mov.b	r7,	r12	;
    9daa:	b0 13 06 a6 	calla	#42502		;0x0a606

00009dae <.LVL907>:
  if (hdr.reply) {
    9dae:	04 93       	cmp	#0,	r4	;r3 As==00
    9db0:	63 24       	jz	$+200    	;abs 0x9e78

00009db2 <.Loc.347.2>:
    write_success(reply_buff, hdr);
    9db2:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    9db6:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

00009dba <.LVL909>:
    9dba:	05 d9       	bis	r9,	r5	;
    9dbc:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    9dc0:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    9dc4:	0e 00 
    9dc6:	cd 01       	mova	r1,	r13	;
    9dc8:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    9dcc:	cc 0a       	mova	r10,	r12	;
    9dce:	b0 13 52 7a 	calla	#31314		;0x07a52

00009dd2 <.LVL910>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9dd2:	1d 41 02 00 	mov	2(r1),	r13	;
    9dd6:	cc 0a       	mova	r10,	r12	;
    9dd8:	b0 13 98 7e 	calla	#32408		;0x07e98

00009ddc <.LVL911>:
    9ddc:	80 00 5c 9e 	mova	#40540,	r0	;0x09e5c

00009de0 <.L597>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    9de0:	57 48 02 00 	mov.b	2(r8),	r7	;

00009de4 <.LVL913>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    9de4:	76 40 03 00 	mov.b	#3,	r6	;
    9de8:	80 00 32 9d 	mova	#40242,	r0	;0x09d32

00009dec <.L608>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    9dec:	6d 43       	mov.b	#2,	r13	;r3 As==10
    9dee:	80 00 38 9d 	mova	#40248,	r0	;0x09d38

00009df2 <.L606>:
    uint8_t addr = buffer[i + regs_offset];
    9df2:	6c 4e       	mov.b	@r14,	r12	;

00009df4 <.LVL917>:
    if ((bank == 0) || (bank > 4) ||
    9df4:	7f 40 03 00 	mov.b	#3,	r15	;
    9df8:	5f 91 0b 00 	cmp.b	11(r1),	r15	;0x0000b
    9dfc:	13 28       	jnc	$+40     	;abs 0x9e24

00009dfe <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    9dfe:	4f 4c       	mov.b	r12,	r15	;
    9e00:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00009e04 <.Loc.323.2>:
    if ((bank == 0) || (bank > 4) ||
    9e04:	7b 40 29 00 	mov.b	#41,	r11	;#0x0029
    9e08:	4b 9f       	cmp.b	r15,	r11	;
    9e0a:	0c 2c       	jc	$+26     	;abs 0x9e24

00009e0c <.Loc.325.2>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    9e0c:	7f 50 cc ff 	add.b	#-52,	r15	;#0xffcc

00009e10 <.Loc.324.2>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    9e10:	7b 40 35 00 	mov.b	#53,	r11	;#0x0035
    9e14:	4b 9f       	cmp.b	r15,	r11	;
    9e16:	06 2c       	jc	$+14     	;abs 0x9e24
    9e18:	ae 00 02 00 	adda	#2,	r14	;

00009e1c <.LVL918>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    9e1c:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    9e20:	4f 9c       	cmp.b	r12,	r15	;
    9e22:	20 2c       	jc	$+66     	;abs 0x9e64

00009e24 <.L603>:
      if (hdr.reply) {
    9e24:	04 93       	cmp	#0,	r4	;r3 As==00
    9e26:	15 24       	jz	$+44     	;abs 0x9e52

00009e28 <.Loc.328.2>:
        write_failure(reply_buff, hdr);
    9e28:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    9e2c:	75 f0 ff 00 	and.b	#255,	r5	;#0x00ff

00009e30 <.LVL921>:
    9e30:	05 d9       	bis	r9,	r5	;
    9e32:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    9e36:	91 41 02 00 	mov	2(r1),	14(r1)	; 0x000e
    9e3a:	0e 00 
    9e3c:	cd 01       	mova	r1,	r13	;

00009e3e <.LVL922>:
    9e3e:	ad 00 0c 00 	adda	#12,	r13	;0x0000c
    9e42:	cc 0a       	mova	r10,	r12	;

00009e44 <.LVL923>:
    9e44:	b0 13 70 78 	calla	#30832		;0x07870

00009e48 <.LVL924>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    9e48:	1d 41 02 00 	mov	2(r1),	r13	;
    9e4c:	cc 0a       	mova	r10,	r12	;
    9e4e:	b0 13 98 7e 	calla	#32408		;0x07e98

00009e52 <.L605>:
      elyNLFreeBuffer(elyNLFromFW(buffer));
    9e52:	cc 08       	mova	r8,	r12	;
    9e54:	b0 13 16 c5 	calla	#50454		;0x0c516

00009e58 <.LVL926>:
    9e58:	b0 13 80 c2 	calla	#49792		;0x0c280

00009e5c <.L596>:
}
    9e5c:	a1 00 10 00 	adda	#16,	r1	;0x00010
    9e60:	64 16       	popm.a	#7,	r10	;20-bit words
    9e62:	10 01       	reta			;

00009e64 <.L604>:
    reply_buff[i+regs_offset-1] = addr;
    9e64:	c6 4c ff ff 	mov.b	r12,	-1(r6)	; 0xffff

00009e68 <.LVL929>:
    reply_buff[i+regs_offset] = buffer[i+regs_offset+1];
    9e68:	d6 4e ff ff 	mov.b	-1(r14),0(r6)	;
    9e6c:	00 00 

00009e6e <.LBE109>:
  for (int i = 0; i < num_regs * 2; i += 2) {
    9e6e:	2d 53       	incd	r13		;
    9e70:	a6 00 02 00 	adda	#2,	r6	;
    9e74:	80 00 88 9d 	mova	#40328,	r0	;0x09d88

00009e78 <.L607>:
    elyFWFreeBuffer(elyNLFromFW(reply_buff));
    9e78:	cc 0a       	mova	r10,	r12	;
    9e7a:	46 13       	calla	r6		;

00009e7c <.LVL932>:
    9e7c:	b0 13 da 77 	calla	#30682		;0x077da

00009e80 <.LVL933>:
    9e80:	80 00 5c 9e 	mova	#40540,	r0	;0x09e5c

00009e84 <get_regs>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9e84:	6a 14       	pushm.a	#7,	r10	;20-bit words

00009e86 <.LCFI107>:
    9e86:	b1 00 12 00 	suba	#18,	r1	;0x00012

00009e8a <.LCFI108>:
    9e8a:	c8 0c       	mova	r12,	r8	;
    9e8c:	2e 4d       	mov	@r13,	r14	;

00009e8e <.LVL935>:
    9e8e:	16 4d 02 00 	mov	2(r13),	r6	;

00009e92 <.LVL936>:
    9e92:	0d 4e       	mov	r14,	r13	;
    9e94:	5d 07       	rrum	#2,	r13	;
    9e96:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    9e9a:	c1 4d 0a 00 	mov.b	r13,	10(r1)	; 0x000a
    9e9e:	09 4e       	mov	r14,	r9	;
    9ea0:	59 0f       	rrum	#4,	r9	;
    9ea2:	59 0f       	rrum	#4,	r9	;
    9ea4:	81 49 08 00 	mov	r9,	8(r1)	;

00009ea8 <.Loc.252.2>:
  if (hdr.reply) {
    9ea8:	49 4d       	mov.b	r13,	r9	;
    9eaa:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
    9eae:	41 18 09 59 	rpt #2 { rlax.w	r9		;
    9eb2:	3e f0 03 ff 	and	#-253,	r14	;#0xff03

00009eb6 <.LVL938>:
    9eb6:	09 de       	bis	r14,	r9	;
    9eb8:	81 49 00 00 	mov	r9,	0(r1)	;
    9ebc:	07 49       	mov	r9,	r7	;
    9ebe:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9ec2:	40 18 27 b3 	bitx.w	#2,	r7	;r3 As==10
    9ec6:	07 24       	jz	$+16     	;abs 0x9ed6

00009ec8 <.LBB112>:
    uint8_t * reply_buff = elyFWGetBuffer();
    9ec8:	b0 13 b2 77 	calla	#30642		;0x077b2

00009ecc <.LVL939>:
    9ecc:	ca 0c       	mova	r12,	r10	;

00009ece <.LVL940>:
    if (reply_buff == NULL) {
    9ece:	9c 00 00 00 	cmpa	#0,	r12	;
    9ed2:	07 20       	jnz	$+16     	;abs 0x9ee2

00009ed4 <.L624>:
        elyNLFreeBuffer(elyNLFromFW(buffer));
    9ed4:	cc 08       	mova	r8,	r12	;

00009ed6 <.L613>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9ed6:	b0 13 16 c5 	calla	#50454		;0x0c516

00009eda <.LVL942>:
    9eda:	b0 13 80 c2 	calla	#49792		;0x0c280

00009ede <.LVL943>:
    9ede:	80 00 70 9f 	mova	#40816,	r0	;0x09f70

00009ee2 <.L614>:
    uint8_t bank = buffer[4];
    9ee2:	54 48 04 00 	mov.b	4(r8),	r4	;

00009ee6 <.LVL945>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    9ee6:	57 f3       	and.b	#1,	r7	;r3 As==01
    9ee8:	07 93       	cmp	#0,	r7	;r3 As==00
    9eea:	46 20       	jnz	$+142    	;abs 0x9f78
    9eec:	0c 47       	mov	r7,	r12	;

00009eee <.L616>:
    9eee:	1f 41 08 00 	mov	8(r1),	r15	;
    9ef2:	4f 8c       	sub.b	r12,	r15	;
    9ef4:	c1 4f 0d 00 	mov.b	r15,	13(r1)	; 0x000d
    9ef8:	45 4f       	mov.b	r15,	r5	;
    9efa:	75 50 fd ff 	add.b	#-3,	r5	;#0xfffd
    9efe:	49 45       	mov.b	r5,	r9	;
    9f00:	81 49 02 00 	mov	r9,	2(r1)	;

00009f04 <.LVL946>:
    9f04:	cd 0a       	mova	r10,	r13	;
    9f06:	ad 00 04 00 	adda	#4,	r13	;
    9f0a:	71 0d 04 00 	mova	r13,	4(r1)	;
    9f0e:	cb 08       	mova	r8,	r11	;
    9f10:	ab 00 05 00 	adda	#5,	r11	;

00009f14 <.LBB116>:
    for (int i = 0; i < num_regs; i++) {
    9f14:	4e 43       	clr.b	r14		;

00009f16 <.L617>:
    9f16:	1e 91 02 00 	cmp	2(r1),	r14	;
    9f1a:	31 38       	jl	$+100    	;abs 0x9f7e

00009f1c <.LBE116>:
    elyNLFreeBuffer(elyNLFromFW(buffer));
    9f1c:	cc 08       	mova	r8,	r12	;
    9f1e:	b0 13 16 c5 	calla	#50454		;0x0c516

00009f22 <.LVL948>:
    9f22:	b0 13 80 c2 	calla	#49792		;0x0c280

00009f26 <.LVL949>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    9f26:	da 41 0a 00 	mov.b	10(r1),	0(r10)	;0x0000a
    9f2a:	00 00 

00009f2c <.Loc.287.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    9f2c:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    9f30:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    9f34:	02 00 

00009f36 <.Loc.288.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    9f36:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    9f3a:	03 00 

00009f3c <.Loc.291.2>:
    elyRegGet(bank, reply_buff + 4, num_regs);
    9f3c:	4e 45       	mov.b	r5,	r14	;
    9f3e:	3d 01 04 00 	mova	4(r1),	r13	;
    9f42:	4c 44       	mov.b	r4,	r12	;
    9f44:	b0 13 aa a5 	calla	#42410		;0x0a5aa

00009f48 <.LVL950>:
    if (hdr.crc) {
    9f48:	07 93       	cmp	#0,	r7	;r3 As==00
    9f4a:	54 24       	jz	$+170    	;abs 0x9ff4

00009f4c <.Loc.294.2>:
      reply_buff[1] = num_regs + 2;
    9f4c:	59 41 0d 00 	mov.b	13(r1),	r9	;0x0000d
    9f50:	79 53       	add.b	#-1,	r9	;r3 As==11
    9f52:	ca 49 01 00 	mov.b	r9,	1(r10)	;

00009f56 <.Loc.295.2>:
      crcGenX25(reply_buff, num_regs + 6);
    9f56:	1d 41 02 00 	mov	2(r1),	r13	;
    9f5a:	3d 50 06 00 	add	#6,	r13	;
    9f5e:	4d 0e       	rlam.a	#4,	r13	;
    9f60:	4d 0d       	rram.a	#4,	r13	;
    9f62:	cc 0a       	mova	r10,	r12	;
    9f64:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

00009f68 <.L622>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    9f68:	0d 46       	mov	r6,	r13	;
    9f6a:	cc 0a       	mova	r10,	r12	;
    9f6c:	b0 13 98 7e 	calla	#32408		;0x07e98

00009f70 <.L612>:
}
    9f70:	a1 00 12 00 	adda	#18,	r1	;0x00012
    9f74:	64 16       	popm.a	#7,	r10	;20-bit words
    9f76:	10 01       	reta			;

00009f78 <.L623>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    9f78:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9f7a:	80 00 ee 9e 	mova	#40686,	r0	;0x09eee

00009f7e <.L620>:
      uint8_t addr = buffer[i + regs_offset];
    9f7e:	6c 4b       	mov.b	@r11,	r12	;

00009f80 <.LVL955>:
      if ((bank > 4) ||
    9f80:	69 42       	mov.b	#4,	r9	;r2 As==10
    9f82:	49 94       	cmp.b	r4,	r9	;
    9f84:	18 28       	jnc	$+50     	;abs 0x9fb6

00009f86 <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    9f86:	4f 4c       	mov.b	r12,	r15	;
    9f88:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00009f8c <.Loc.269.2>:
      if ((bank > 4) ||
    9f8c:	79 40 09 00 	mov.b	#9,	r9	;
    9f90:	49 9f       	cmp.b	r15,	r9	;
    9f92:	11 2c       	jc	$+36     	;abs 0x9fb6

00009f94 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    9f94:	7f 50 df ff 	add.b	#-33,	r15	;#0xffdf

00009f98 <.Loc.270.2>:
          (addr >= RegCoreMAX && addr < 0x60) ||
    9f98:	79 42       	mov.b	#8,	r9	;r2 As==11
    9f9a:	49 9f       	cmp.b	r15,	r9	;
    9f9c:	0c 2c       	jc	$+26     	;abs 0x9fb6

00009f9e <.Loc.272.2>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    9f9e:	7f 50 ed ff 	add.b	#-19,	r15	;#0xffed

00009fa2 <.Loc.271.2>:
          (addr >= RegSpecialMAX && addr < 0x80) ||
    9fa2:	79 40 35 00 	mov.b	#53,	r9	;#0x0035
    9fa6:	49 9f       	cmp.b	r15,	r9	;
    9fa8:	06 2c       	jc	$+14     	;abs 0x9fb6
    9faa:	ab 00 01 00 	adda	#1,	r11	;

00009fae <.LVL956>:
          (addr >= RegNLMAX && addr < 0xC0) ||
    9fae:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    9fb2:	4f 9c       	cmp.b	r12,	r15	;
    9fb4:	18 2c       	jc	$+50     	;abs 0x9fe6

00009fb6 <.L618>:
        write_failure(reply_buff, hdr);
    9fb6:	1d 41 08 00 	mov	8(r1),	r13	;
    9fba:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9fbe:	29 41       	mov	@r1,	r9	;
    9fc0:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    9fc4:	09 dd       	bis	r13,	r9	;
    9fc6:	81 49 0e 00 	mov	r9,	14(r1)	; 0x000e
    9fca:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    9fce:	cd 01       	mova	r1,	r13	;
    9fd0:	ad 00 0e 00 	adda	#14,	r13	;0x0000e
    9fd4:	cc 0a       	mova	r10,	r12	;

00009fd6 <.LVL958>:
    9fd6:	b0 13 70 78 	calla	#30832		;0x07870

00009fda <.LVL959>:
        elyCmdSendReply(reply_buff, hdr.reply_addr);
    9fda:	0d 46       	mov	r6,	r13	;
    9fdc:	cc 0a       	mova	r10,	r12	;
    9fde:	b0 13 98 7e 	calla	#32408		;0x07e98

00009fe2 <.LVL960>:
    9fe2:	80 00 d4 9e 	mova	#40660,	r0	;0x09ed4

00009fe6 <.L619>:
      reply_buff[i+4] = addr;
    9fe6:	cd 4c 00 00 	mov.b	r12,	0(r13)	;

00009fea <.LBE115>:
    for (int i = 0; i < num_regs; i++) {
    9fea:	1e 53       	inc	r14		;
    9fec:	ad 00 01 00 	adda	#1,	r13	;
    9ff0:	80 00 16 9f 	mova	#40726,	r0	;0x09f16

00009ff4 <.L621>:
      reply_buff[1] = num_regs;
    9ff4:	ca 45 01 00 	mov.b	r5,	1(r10)	;
    9ff8:	80 00 68 9f 	mova	#40808,	r0	;0x09f68

00009ffc <get_active_bank>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    9ffc:	5a 14       	pushm.a	#6,	r10	;20-bit words

00009ffe <.LCFI109>:
    9ffe:	2a 4d       	mov	@r13,	r10	;

0000a000 <.LVL966>:
    a000:	17 4d 02 00 	mov	2(r13),	r7	;

0000a004 <.LVL967>:
    a004:	49 4a       	mov.b	r10,	r9	;
    a006:	59 f3       	and.b	#1,	r9	;r3 As==01
    a008:	45 49       	mov.b	r9,	r5	;
    a00a:	08 4a       	mov	r10,	r8	;
    a00c:	58 07       	rrum	#2,	r8	;
    a00e:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    a012:	46 48       	mov.b	r8,	r6	;

0000a014 <.Loc.229.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    a014:	b0 13 16 c5 	calla	#50454		;0x0c516

0000a018 <.LVL969>:
    a018:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a01c <.LVL970>:
  if (hdr.reply) { /* reply requested */
    a01c:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

0000a020 <.LVL971>:
    a020:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    a024:	0a d5       	bis	r5,	r10	;
    a026:	0a d6       	bis	r6,	r10	;
    a028:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    a02c:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    a030:	22 24       	jz	$+70     	;abs 0xa076

0000a032 <.LBB120>:
    uint8_t * reply_buff = elyFWGetBuffer();
    a032:	b0 13 b2 77 	calla	#30642		;0x077b2

0000a036 <.LVL972>:
    a036:	c6 0c       	mova	r12,	r6	;

0000a038 <.LVL973>:
    if (reply_buff == NULL) {
    a038:	9c 00 00 00 	cmpa	#0,	r12	;
    a03c:	1c 24       	jz	$+58     	;abs 0xa076

0000a03e <.Loc.238.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    a03e:	cc 48 00 00 	mov.b	r8,	0(r12)	;

0000a042 <.Loc.239.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    a042:	49 59       	rla.b	r9		;
    a044:	59 53       	inc.b	r9		;
    a046:	cc 49 01 00 	mov.b	r9,	1(r12)	;

0000a04a <.Loc.240.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    a04a:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    a04e:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    a052:	02 00 

0000a054 <.Loc.241.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    a054:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    a058:	03 00 

0000a05a <.Loc.242.2>:
    reply_buff[4] = bank0p[RegActiveBank];
    a05a:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    a05e:	04 00 

0000a060 <.Loc.243.2>:
    if (hdr.crc) {
    a060:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    a064:	04 24       	jz	$+10     	;abs 0xa06e

0000a066 <.Loc.244.2>:
      crcGenX25(reply_buff, 7);
    a066:	7d 40 07 00 	mov.b	#7,	r13	;
    a06a:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

0000a06e <.L629>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    a06e:	0d 47       	mov	r7,	r13	;
    a070:	cc 06       	mova	r6,	r12	;
    a072:	b0 13 98 7e 	calla	#32408		;0x07e98

0000a076 <.L625>:
}
    a076:	55 16       	popm.a	#6,	r10	;20-bit words
    a078:	10 01       	reta			;

0000a07a <get_gpo>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    a07a:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a07c <.LCFI110>:
    a07c:	2a 4d       	mov	@r13,	r10	;

0000a07e <.LVL978>:
    a07e:	17 4d 02 00 	mov	2(r13),	r7	;

0000a082 <.LVL979>:
    a082:	49 4a       	mov.b	r10,	r9	;
    a084:	59 f3       	and.b	#1,	r9	;r3 As==01
    a086:	45 49       	mov.b	r9,	r5	;
    a088:	08 4a       	mov	r10,	r8	;
    a08a:	58 07       	rrum	#2,	r8	;
    a08c:	78 f0 3f 00 	and.b	#63,	r8	;#0x003f
    a090:	46 48       	mov.b	r8,	r6	;

0000a092 <.Loc.173.2>:
  elyNLFreeBuffer(elyNLFromFW(buffer));
    a092:	b0 13 16 c5 	calla	#50454		;0x0c516

0000a096 <.LVL981>:
    a096:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a09a <.LVL982>:
  if (hdr.reply) { /* reply requested */
    a09a:	3a f0 02 ff 	and	#-254,	r10	;#0xff02

0000a09e <.LVL983>:
    a09e:	41 18 06 56 	rpt #2 { rlax.w	r6		;
    a0a2:	0a d5       	bis	r5,	r10	;
    a0a4:	0a d6       	bis	r6,	r10	;
    a0a6:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    a0aa:	40 18 2a b3 	bitx.w	#2,	r10	;r3 As==10
    a0ae:	22 24       	jz	$+70     	;abs 0xa0f4

0000a0b0 <.LBB121>:
    uint8_t * reply_buff = elyFWGetBuffer();
    a0b0:	b0 13 b2 77 	calla	#30642		;0x077b2

0000a0b4 <.LVL984>:
    a0b4:	c6 0c       	mova	r12,	r6	;

0000a0b6 <.LVL985>:
    if (reply_buff == NULL) {
    a0b6:	9c 00 00 00 	cmpa	#0,	r12	;
    a0ba:	1c 24       	jz	$+58     	;abs 0xa0f4

0000a0bc <.Loc.182.2>:
    reply_buff[0] = hdr.opcode; /* opcode w/o CRC or Reply */
    a0bc:	cc 48 00 00 	mov.b	r8,	0(r12)	;

0000a0c0 <.Loc.183.2>:
    reply_buff[1] = 1 + (hdr.crc << 1);
    a0c0:	49 59       	rla.b	r9		;
    a0c2:	59 53       	inc.b	r9		;
    a0c4:	cc 49 01 00 	mov.b	r9,	1(r12)	;

0000a0c8 <.Loc.184.2>:
    reply_buff[2] = bank0p[RegSrcAddrMsb];
    a0c8:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    a0cc:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    a0d0:	02 00 

0000a0d2 <.Loc.185.2>:
    reply_buff[3] = bank0p[RegSrcAddrLsb];
    a0d2:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    a0d6:	03 00 

0000a0d8 <.Loc.186.2>:
    reply_buff[4] = bank0p[RegGPOState];
    a0d8:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    a0dc:	04 00 

0000a0de <.Loc.187.2>:
    if (hdr.crc) {
    a0de:	40 18 1a b3 	bitx.w	#1,	r10	;r3 As==01
    a0e2:	04 24       	jz	$+10     	;abs 0xa0ec

0000a0e4 <.Loc.188.2>:
      crcGenX25(reply_buff, 7);
    a0e4:	7d 40 07 00 	mov.b	#7,	r13	;
    a0e8:	b0 13 f6 a9 	calla	#43510		;0x0a9f6

0000a0ec <.L640>:
    elyCmdSendReply(reply_buff, hdr.reply_addr);
    a0ec:	0d 47       	mov	r7,	r13	;
    a0ee:	cc 06       	mova	r6,	r12	;
    a0f0:	b0 13 98 7e 	calla	#32408		;0x07e98

0000a0f4 <.L636>:
}
    a0f4:	55 16       	popm.a	#6,	r10	;20-bit words
    a0f6:	10 01       	reta			;

0000a0f8 <CmdThd>:

THD_WORKING_AREA(waCmdThd, 512);
THD_FUNCTION(CmdThd, arg) {
    a0f8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a0fa <.LCFI111>:
    a0fa:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a0fc <.LCFI112>:
    a0fc:	26 14       	pushm.a	#3,	r6	;20-bit words

0000a0fe <.LCFI113>:
    a0fe:	b1 00 04 00 	suba	#4,	r1	;

0000a102 <.LBB122>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    a102:	88 00 86 49 	mova	#18822,	r8	;0x04986

0000a106 <.Loc.1797.2>:
    }
    
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    a106:	8a 00 0a c5 	mova	#50442,	r10	;0x0c50a

0000a10a <.L651>:
    if (NULL == active_buffer) {
    a10a:	01 18 c2 93 	cmpx.a	#0,	&0x11e74;r3 As==00
    a10e:	74 1e 
    a110:	06 20       	jnz	$+14     	;abs 0xa11e

0000a112 <.Loc.1794.2>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    a112:	4e 43       	clr.b	r14		;
    a114:	8d 01 74 1e 	mova	#73332,	r13	;0x11e74
    a118:	8c 01 00 02 	mova	#66048,	r12	;0x10200
    a11c:	48 13       	calla	r8		;

0000a11e <.L648>:
    uint8_t * cmd_buffer = elyNLToFW(active_buffer);
    a11e:	2c 01 74 1e 	mova	&73332,	r12	;0x11e74
    a122:	4a 13       	calla	r10		;

0000a124 <.LVL992>:
    a124:	c6 0c       	mova	r12,	r6	;

0000a126 <.Loc.1800.2>:
    elysium_cmd_hdr_t hdr;
    
    hdr = elyCmdParse(cmd_buffer);
    a126:	cd 0c       	mova	r12,	r13	;
    a128:	cc 01       	mova	r1,	r12	;
    a12a:	b0 13 ba 7a 	calla	#31418		;0x07aba

0000a12e <.LVL994>:
    a12e:	24 41       	mov	@r1,	r4	;

0000a130 <.LVL995>:
    a130:	15 41 02 00 	mov	2(r1),	r5	;

0000a134 <.Loc.1801.2>:
    if (elyCmdValidate(hdr, cmd_buffer)) {
    a134:	cd 06       	mova	r6,	r13	;
    a136:	cc 01       	mova	r1,	r12	;
    a138:	b0 13 0e 7b 	calla	#31502		;0x07b0e

0000a13c <.LVL996>:
    a13c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a13e:	0d 24       	jz	$+28     	;abs 0xa15a

0000a140 <.Loc.1802.2>:
      elyCmdDispatch(hdr, cmd_buffer);
    a140:	81 44 00 00 	mov	r4,	0(r1)	;

0000a144 <.LVL997>:
    a144:	81 45 02 00 	mov	r5,	2(r1)	;
    a148:	cd 06       	mova	r6,	r13	;
    a14a:	cc 01       	mova	r1,	r12	;
    a14c:	b0 13 76 7d 	calla	#32118		;0x07d76

0000a150 <.L650>:
      /* Invalid command - free the buffer (guaranteed to be NL) */
      elyNLFreeBuffer(active_buffer);
    }
    
    /* null the buffer so we get a new one */
    active_buffer = NULL; 
    a150:	01 18 c2 43 	movx.a	#0,	&0x11e74;r3 As==00
    a154:	74 1e 

0000a156 <.LBE122>:
  while (true) {
    a156:	80 00 0a a1 	mova	#41226,	r0	;0x0a10a

0000a15a <.L649>:
      elyNLFreeBuffer(active_buffer);
    a15a:	2c 01 74 1e 	mova	&73332,	r12	;0x11e74
    a15e:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a162 <.LVL1000>:
    a162:	80 00 50 a1 	mova	#41296,	r0	;0x0a150

0000a166 <time_timer_cb>:
  
}

void time_timer_cb(GPTDriver * gptp) {
  int32_t * uptime = &bank0w[RegUptimeLsb];
  (*uptime)++;
    a166:	8c 00 54 d5 	mova	#54612,	r12	;0x0d554

0000a16a <.LVL2>:
    a16a:	5d 4c 6c 00 	mov.b	108(r12),r13	;0x0006c
    a16e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a172:	5e 4c 6b 00 	mov.b	107(r12),r14	;0x0006b
    a176:	0d de       	bis	r14,	r13	;
    a178:	5e 4c 6e 00 	mov.b	110(r12),r14	;0x0006e
    a17c:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a180:	5f 4c 6d 00 	mov.b	109(r12),r15	;0x0006d
    a184:	0e df       	bis	r15,	r14	;
    a186:	1d 53       	inc	r13		;
    a188:	0e 63       	adc	r14		;
    a18a:	cc 4d 6b 00 	mov.b	r13,	107(r12); 0x006b
    a18e:	5d 0f       	rrum	#4,	r13	;
    a190:	5d 0f       	rrum	#4,	r13	;
    a192:	cc 4d 6c 00 	mov.b	r13,	108(r12); 0x006c
    a196:	cc 4e 6d 00 	mov.b	r14,	109(r12); 0x006d
    a19a:	5e 0f       	rrum	#4,	r14	;
    a19c:	5e 0f       	rrum	#4,	r14	;
    a19e:	cc 4e 6e 00 	mov.b	r14,	110(r12); 0x006e

0000a1a2 <.Loc.414.1>:
  int32_t * mission_time = &bank0w[RegMissionTimeLsb];
  (*mission_time)++;
    a1a2:	5d 4c 74 00 	mov.b	116(r12),r13	;0x00074
    a1a6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a1aa:	5e 4c 73 00 	mov.b	115(r12),r14	;0x00073
    a1ae:	0d de       	bis	r14,	r13	;
    a1b0:	5e 4c 76 00 	mov.b	118(r12),r14	;0x00076
    a1b4:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a1b8:	5f 4c 75 00 	mov.b	117(r12),r15	;0x00075
    a1bc:	0e df       	bis	r15,	r14	;
    a1be:	1d 53       	inc	r13		;
    a1c0:	0e 63       	adc	r14		;
    a1c2:	cc 4d 73 00 	mov.b	r13,	115(r12); 0x0073
    a1c6:	5d 0f       	rrum	#4,	r13	;
    a1c8:	5d 0f       	rrum	#4,	r13	;
    a1ca:	cc 4d 74 00 	mov.b	r13,	116(r12); 0x0074
    a1ce:	cc 4e 75 00 	mov.b	r14,	117(r12); 0x0075
    a1d2:	5e 0f       	rrum	#4,	r14	;
    a1d4:	5e 0f       	rrum	#4,	r14	;
    a1d6:	cc 4e 76 00 	mov.b	r14,	118(r12); 0x0076

0000a1da <.Loc.415.1>:
}
    a1da:	10 01       	reta			;

0000a1dc <clamp>:
static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a1dc:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000a1de <.LCFI0>:
    a1de:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a1e2:	49 4d       	mov.b	r13,	r9	;
    a1e4:	4a 4e       	mov.b	r14,	r10	;

0000a1e6 <.Loc.152.1>:
  if (value < min) {
    a1e6:	4c 99       	cmp.b	r9,	r12	;
    a1e8:	07 2c       	jc	$+16     	;abs 0xa1f8

0000a1ea <.LVL5>:
    elyErrorSignal(ErrRegClip);
    a1ea:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a1ee:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a1f2 <.LVL6>:
    a1f2:	0c 49       	mov	r9,	r12	;

0000a1f4 <.L4>:
}
    a1f4:	19 16       	popm.a	#2,	r10	;20-bit words
    a1f6:	10 01       	reta			;

0000a1f8 <.L3>:
  else if (value > max) {
    a1f8:	4a 9c       	cmp.b	r12,	r10	;
    a1fa:	fc 2f       	jc	$-6      	;abs 0xa1f4

0000a1fc <.LVL9>:
    elyErrorSignal(ErrRegClip);
    a1fc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a200:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a204 <.LVL10>:
    a204:	0c 4a       	mov	r10,	r12	;
    a206:	80 00 f4 a1 	mova	#41460,	r0	;0x0a1f4

0000a20a <fram_reg_cb>:
  regs_in_progress--;
    a20a:	c0 18 5c 42 	movx.b	&0x11e94,r12	;
    a20e:	94 1e 

0000a210 <.LVL12>:
    a210:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a212:	41 18 c2 4c 	movx.b	r12,	&0x11e94;
    a216:	94 1e 

0000a218 <.Loc.207.1>:
  if (regs_in_progress == 0) {
    a218:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a21a:	0a 20       	jnz	$+22     	;abs 0xa230

0000a21c <.LBB12>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a21c:	c0 18 1c 42 	movx.w	&0x11e96,r12	;
    a220:	96 1e 
    a222:	4d 43       	clr.b	r13		;
    a224:	0d 9c       	cmp	r12,	r13	;
    a226:	04 38       	jl	$+10     	;abs 0xa230

0000a228 <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a228:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a22c:	b0 13 8e 47 	calla	#18318		;0x0478e

0000a230 <.L5>:
}
    a230:	10 01       	reta			;

0000a232 <fram_block_cb>:
  if (bsp->sem.cnt < (cnt_t)1) {
    a232:	c0 18 1c 42 	movx.w	&0x11e96,r12	;
    a236:	96 1e 

0000a238 <.LVL17>:
    a238:	4d 43       	clr.b	r13		;
    a23a:	0d 9c       	cmp	r12,	r13	;
    a23c:	04 38       	jl	$+10     	;abs 0xa246

0000a23e <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    a23e:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a242:	b0 13 8e 47 	calla	#18318		;0x0478e

0000a246 <.L7>:
}
    a246:	10 01       	reta			;

0000a248 <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    a248:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a24a <.LCFI1>:
    a24a:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a24c <.LCFI2>:
    a24c:	b1 00 04 00 	suba	#4,	r1	;

0000a250 <.LCFI3>:
    a250:	4a 4c       	mov.b	r12,	r10	;
    a252:	49 4d       	mov.b	r13,	r9	;
    a254:	48 4e       	mov.b	r14,	r8	;
    a256:	c6 0f       	mova	r15,	r6	;

0000a258 <.LBB26>:
  _disable_interrupts();
    a258:	32 c2       	dint			
    a25a:	03 43       	nop			

0000a25c <.Loc.348.3>:
  asm volatile("nop");
    a25c:	03 43       	nop			

0000a25e <.LBE26>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a25e:	4d 43       	clr.b	r13		;

0000a260 <.LVL20>:
    a260:	cc 01       	mova	r1,	r12	;

0000a262 <.LVL21>:
    a262:	b0 13 ee b4 	calla	#46318		;0x0b4ee

0000a266 <.LBB28>:
  asm volatile("nop");
    a266:	03 43       	nop			

0000a268 <.Loc.356.3>:
  _enable_interrupts();
    a268:	03 43       	nop			
    a26a:	32 d2       	eint			
    a26c:	03 43       	nop			

0000a26e <.LBE28>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a26e:	0c 01       	mova	@r1,	r12	;
    a270:	39 53       	add	#-1,	r9	;r3 As==11

0000a272 <.LVL23>:
    a272:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a276 <.LVL24>:
    a276:	0e 49       	mov	r9,	r14	;
    a278:	0f 49       	mov	r9,	r15	;
    a27a:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a27e:	48 48       	mov.b	r8,	r8	;
    a280:	09 43       	clr	r9		;

0000a282 <.LVL25>:
    a282:	0d 48       	mov	r8,	r13	;
    a284:	0d 53       	add	#0,	r13	;r3 As==00
    a286:	19 63       	addc	#1,	r9	;r3 As==01
    a288:	0d 5e       	add	r14,	r13	;
    a28a:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a28e:	09 6f       	addc	r15,	r9	;
    a290:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a294 <.Loc.224.1>:
  req->read = read;
    a294:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a296 <.LVL26>:
    a296:	4a 5a       	rla.b	r10		;
    a298:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a29c:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a29e:	4d da       	bis.b	r10,	r13	;
    a2a0:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a2a4 <.Loc.225.1>:
  req->size = 1;
    a2a4:	1d 4c 04 00 	mov	4(r12),	r13	;
    a2a8:	7d f0 03 00 	and.b	#3,	r13	;
    a2ac:	2d d2       	bis	#4,	r13	;r2 As==10
    a2ae:	8c 4d 04 00 	mov	r13,	4(r12)	;
    a2b2:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    a2b6:	06 00 

0000a2b8 <.Loc.226.1>:
  req->buffer = valuep;
    a2b8:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a2bc <.Loc.227.1>:
  req->callback = fram_reg_cb;
    a2bc:	00 18 fc 40 	movx.a	#41482,	12(r12)	;0x0a20a, 0x0000c
    a2c0:	0a a2 0c 00 

0000a2c4 <.LBB30>:
  _disable_interrupts();
    a2c4:	32 c2       	dint			
    a2c6:	03 43       	nop			

0000a2c8 <.Loc.348.3>:
  asm volatile("nop");
    a2c8:	03 43       	nop			

0000a2ca <.LBE30>:
  elyFramPostRequestS(req);
    a2ca:	b0 13 ca b4 	calla	#46282		;0x0b4ca

0000a2ce <.LBB32>:
  asm volatile("nop");
    a2ce:	03 43       	nop			

0000a2d0 <.Loc.356.3>:
  _enable_interrupts();
    a2d0:	03 43       	nop			
    a2d2:	32 d2       	eint			
    a2d4:	03 43       	nop			

0000a2d6 <.LBE32>:
}
    a2d6:	a1 00 04 00 	adda	#4,	r1	;
    a2da:	06 16       	popm.a	#1,	r6	;20-bit words
    a2dc:	28 16       	popm.a	#3,	r10	;20-bit words
    a2de:	10 01       	reta			;

0000a2e0 <fram_block>:
void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    a2e0:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a2e2 <.LCFI4>:
    a2e2:	06 14       	pushm.a	#1,	r6	;20-bit words

0000a2e4 <.LCFI5>:
    a2e4:	b1 00 08 00 	suba	#8,	r1	;

0000a2e8 <.LCFI6>:
    a2e8:	4a 4c       	mov.b	r12,	r10	;
    a2ea:	49 4d       	mov.b	r13,	r9	;
    a2ec:	48 4e       	mov.b	r14,	r8	;
    a2ee:	c6 0f       	mova	r15,	r6	;

0000a2f0 <.LBB42>:
  _disable_interrupts();
    a2f0:	32 c2       	dint			
    a2f2:	03 43       	nop			

0000a2f4 <.Loc.348.3>:
  asm volatile("nop");
    a2f4:	03 43       	nop			

0000a2f6 <.LBE42>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    a2f6:	4d 43       	clr.b	r13		;

0000a2f8 <.LVL29>:
    a2f8:	cc 01       	mova	r1,	r12	;

0000a2fa <.LVL30>:
    a2fa:	ac 00 04 00 	adda	#4,	r12	;
    a2fe:	b0 13 ee b4 	calla	#46318		;0x0b4ee

0000a302 <.LBB44>:
  asm volatile("nop");
    a302:	03 43       	nop			

0000a304 <.Loc.356.3>:
  _enable_interrupts();
    a304:	03 43       	nop			
    a306:	32 d2       	eint			
    a308:	03 43       	nop			

0000a30a <.LBE44>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    a30a:	3c 01 04 00 	mova	4(r1),	r12	;
    a30e:	39 53       	add	#-1,	r9	;r3 As==11

0000a310 <.LVL32>:
    a310:	47 18 09 59 	rpt #8 { rlax.w	r9		;

0000a314 <.LVL33>:
    a314:	0e 49       	mov	r9,	r14	;
    a316:	0f 49       	mov	r9,	r15	;
    a318:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    a31c:	48 48       	mov.b	r8,	r8	;
    a31e:	09 43       	clr	r9		;

0000a320 <.LVL34>:
    a320:	0d 48       	mov	r8,	r13	;
    a322:	0d 53       	add	#0,	r13	;r3 As==00
    a324:	19 63       	addc	#1,	r9	;r3 As==01
    a326:	0d 5e       	add	r14,	r13	;
    a328:	8c 4d 00 00 	mov	r13,	0(r12)	;
    a32c:	09 6f       	addc	r15,	r9	;
    a32e:	8c 49 02 00 	mov	r9,	2(r12)	;

0000a332 <.Loc.252.1>:
  req->read = read;
    a332:	5a f3       	and.b	#1,	r10	;r3 As==01

0000a334 <.LVL35>:
    a334:	4a 5a       	rla.b	r10		;
    a336:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    a33a:	6d c3       	bic.b	#2,	r13	;r3 As==10
    a33c:	4d da       	bis.b	r10,	r13	;
    a33e:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a342 <.Loc.253.1>:
  req->size = n;
    a342:	5d 41 1c 00 	mov.b	28(r1),	r13	;0x0001c
    a346:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    a34a:	00 00 
    a34c:	2d 41       	mov	@r1,	r13	;
    a34e:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a352:	1e 4c 04 00 	mov	4(r12),	r14	;
    a356:	7e f0 03 00 	and.b	#3,	r14	;
    a35a:	0e dd       	bis	r13,	r14	;
    a35c:	8c 4e 04 00 	mov	r14,	4(r12)	;

0000a360 <.LVL36>:
    a360:	2e 41       	mov	@r1,	r14	;
    a362:	0f 4e       	mov	r14,	r15	;
    a364:	5f 03       	rrum	#1,	r15	;
    a366:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    a36a:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    a36e:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    a372:	0a 01       	mova	@r1,	r10	;
    a374:	0a 14       	pushm.a	#1,	r10	;20-bit words
    a376:	0d 17       	popm	#1,	r13	;16-bit words
    a378:	0d 17       	popm	#1,	r13	;16-bit words
    a37a:	5d f3       	and.b	#1,	r13	;r3 As==01
    a37c:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    a380:	4e df       	bis.b	r15,	r14	;
    a382:	4e dd       	bis.b	r13,	r14	;
    a384:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000a388 <.Loc.254.1>:
  req->buffer = buffer;
    a388:	7c 06 08 00 	mova	r6,	8(r12)	;

0000a38c <.Loc.255.1>:
  req->callback = fram_block_cb;
    a38c:	00 18 fc 40 	movx.a	#41522,	12(r12)	;0x0a232, 0x0000c
    a390:	32 a2 0c 00 

0000a394 <.LBB46>:
  _disable_interrupts();
    a394:	32 c2       	dint			
    a396:	03 43       	nop			

0000a398 <.Loc.348.3>:
  asm volatile("nop");
    a398:	03 43       	nop			

0000a39a <.LBE46>:
  elyFramPostRequestS(req);
    a39a:	b0 13 ca b4 	calla	#46282		;0x0b4ca

0000a39e <.LBB48>:
  asm volatile("nop");
    a39e:	03 43       	nop			

0000a3a0 <.Loc.356.3>:
  _enable_interrupts();
    a3a0:	03 43       	nop			
    a3a2:	32 d2       	eint			
    a3a4:	03 43       	nop			

0000a3a6 <.LBE48>:
}
    a3a6:	a1 00 08 00 	adda	#8,	r1	;
    a3aa:	06 16       	popm.a	#1,	r6	;20-bit words
    a3ac:	28 16       	popm.a	#3,	r10	;20-bit words
    a3ae:	10 01       	reta			;

0000a3b0 <elyClampReg>:
uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    a3b0:	4e 4c       	mov.b	r12,	r14	;
    a3b2:	4c 4d       	mov.b	r13,	r12	;

0000a3b4 <.LVL39>:
  switch(addr) {
    a3b4:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    a3b8:	9e 24       	jz	$+318    	;abs 0xa4f6
    a3ba:	7f 40 22 00 	mov.b	#34,	r15	;#0x0022
    a3be:	4f 9e       	cmp.b	r14,	r15	;
    a3c0:	33 28       	jnc	$+104    	;abs 0xa428
    a3c2:	7f 40 17 00 	mov.b	#23,	r15	;#0x0017
    a3c6:	4f 9e       	cmp.b	r14,	r15	;
    a3c8:	24 28       	jnc	$+74     	;abs 0xa412
    a3ca:	7e 90 10 00 	cmp.b	#16,	r14	;#0x0010
    a3ce:	df 2c       	jc	$+448    	;abs 0xa58e
    a3d0:	7e 90 07 00 	cmp.b	#7,	r14	;
    a3d4:	82 24       	jz	$+262    	;abs 0xa4da
    a3d6:	7f 40 07 00 	mov.b	#7,	r15	;
    a3da:	4f 9e       	cmp.b	r14,	r15	;
    a3dc:	10 28       	jnc	$+34     	;abs 0xa3fe
    a3de:	7e 90 03 00 	cmp.b	#3,	r14	;
    a3e2:	71 24       	jz	$+228    	;abs 0xa4c6

0000a3e4 <.L12>:
      if (addr > 0x80 && addr < 0xBF) {
    a3e4:	4d 4e       	mov.b	r14,	r13	;
    a3e6:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    a3ea:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    a3ee:	4f 9d       	cmp.b	r13,	r15	;
    a3f0:	d2 28       	jnc	$+422    	;abs 0xa596

0000a3f2 <.Loc.331.1>:
        value = elyNLClampReg(addr, value);
    a3f2:	4d 4c       	mov.b	r12,	r13	;
    a3f4:	4c 4e       	mov.b	r14,	r12	;

0000a3f6 <.LVL41>:
    a3f6:	b0 13 82 c1 	calla	#49538		;0x0c182

0000a3fa <.LVL42>:
    a3fa:	80 00 d2 a4 	mova	#42194,	r0	;0x0a4d2

0000a3fe <.L18>:
  switch(addr) {
    a3fe:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    a402:	03 24       	jz	$+8      	;abs 0xa40a
    a404:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    a408:	ed 23       	jnz	$-36     	;abs 0xa3e4

0000a40a <.L22>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    a40a:	4e 43       	clr.b	r14		;

0000a40c <.L97>:
      value = clamp(value, 0, 4);
    a40c:	4d 43       	clr.b	r13		;

0000a40e <.LVL44>:
    a40e:	80 00 ce a4 	mova	#42190,	r0	;0x0a4ce

0000a412 <.L15>:
  switch(addr) {
    a412:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    a416:	f9 27       	jz	$-12     	;abs 0xa40a
    a418:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    a41c:	64 24       	jz	$+202    	;abs 0xa4e6
    a41e:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    a422:	e0 23       	jnz	$-62     	;abs 0xa3e4
    a424:	80 00 0a a4 	mova	#41994,	r0	;0x0a40a

0000a428 <.L14>:
    a428:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    a42c:	64 24       	jz	$+202    	;abs 0xa4f6
    a42e:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    a432:	4f 9e       	cmp.b	r14,	r15	;
    a434:	23 28       	jnc	$+72     	;abs 0xa47c
    a436:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    a43a:	2d 24       	jz	$+92     	;abs 0xa496
    a43c:	7f 40 25 00 	mov.b	#37,	r15	;#0x0025
    a440:	4f 9e       	cmp.b	r14,	r15	;
    a442:	07 28       	jnc	$+16     	;abs 0xa452
    a444:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    a448:	cd 23       	jnz	$-100    	;abs 0xa3e4

0000a44a <.L28>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    a44a:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    a44e:	80 00 0c a4 	mova	#41996,	r0	;0x0a40c

0000a452 <.L27>:
  switch(addr) {
    a452:	4d 4e       	mov.b	r14,	r13	;

0000a454 <.LVL46>:
    a454:	7d 50 d6 ff 	add.b	#-42,	r13	;#0xffd6
    a458:	7f 40 09 00 	mov.b	#9,	r15	;
    a45c:	4f 9d       	cmp.b	r13,	r15	;
    a45e:	c2 2b       	jnc	$-122    	;abs 0xa3e4

0000a460 <.LBB54>:
  if ((value & 0x10) && value != 0x10) {
    a460:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    a464:	10 00 
    a466:	4b 24       	jz	$+152    	;abs 0xa4fe
    a468:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a46c:	48 24       	jz	$+146    	;abs 0xa4fe

0000a46e <.Loc.165.1>:
    elyErrorSignal(ErrRegClip);
    a46e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a472 <.LVL48>:
    a472:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a476 <.LVL49>:
    return 0x10;
    a476:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

0000a47a <.L26>:
}
    a47a:	10 01       	reta			;

0000a47c <.L25>:
  switch(addr) {
    a47c:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    a480:	77 24       	jz	$+240    	;abs 0xa570
    a482:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    a486:	4f 9e       	cmp.b	r14,	r15	;
    a488:	09 28       	jnc	$+20     	;abs 0xa49c
    a48a:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    a48e:	dd 27       	jz	$-68     	;abs 0xa44a
    a490:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    a494:	a7 23       	jnz	$-176    	;abs 0xa3e4

0000a496 <.L40>:
      return 0; /* this is purely efficiency */
    a496:	4c 43       	clr.b	r12		;
    a498:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a49c <.L31>:
  switch(addr) {
    a49c:	4d 4e       	mov.b	r14,	r13	;

0000a49e <.LVL54>:
    a49e:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    a4a2:	7f 40 05 00 	mov.b	#5,	r15	;
    a4a6:	4f 9d       	cmp.b	r13,	r15	;
    a4a8:	9d 2b       	jnc	$-196    	;abs 0xa3e4

0000a4aa <.LBB58>:
  if ((int8_t)(value) < min) {
    a4aa:	4d 4c       	mov.b	r12,	r13	;
    a4ac:	40 18 8d 11 	sxtx.w	r13		;
    a4b0:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    a4b4:	60 34       	jge	$+194    	;abs 0xa576

0000a4b6 <.Loc.194.1>:
    elyErrorSignal(ErrRegClip);
    a4b6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a4ba <.LVL56>:
    a4ba:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a4be <.LVL57>:
    value = (uint8_t)(min);
    a4be:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    a4c2:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a4c6 <.L19>:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    a4c6:	7e 40 38 00 	mov.b	#56,	r14	;#0x0038
    a4ca:	7d 40 33 00 	mov.b	#51,	r13	;#0x0033

0000a4ce <.L96>:
      value = clamp(value, 1, 0xFF);
    a4ce:	b0 13 dc a1 	calla	#41436		;0x0a1dc

0000a4d2 <.L95>:
        value = elyRFDLLClampReg(addr, value);
    a4d2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a4d6 <.LVL61>:
    a4d6:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a4da <.L17>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    a4da:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c
    a4de:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b

0000a4e2 <.LVL63>:
    a4e2:	80 00 ce a4 	mova	#42190,	r0	;0x0a4ce

0000a4e6 <.L23>:
      value = clamp(value, TX_POW_MIN, TX_POW_MAX);
    a4e6:	7e 40 82 ff 	mov.b	#-126,	r14	;#0xff82
    a4ea:	7d 40 3b 00 	mov.b	#59,	r13	;#0x003b

0000a4ee <.LVL65>:
    a4ee:	b0 13 dc a1 	calla	#41436		;0x0a1dc

0000a4f2 <.LVL66>:
    a4f2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a4f6 <.L13>:
      value = clamp(value, 1, 0xFF);
    a4f6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    a4f8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a4fa:	80 00 ce a4 	mova	#42190,	r0	;0x0a4ce

0000a4fe <.L33>:
  if ((value & 0x08) && value != 0x08) {
    a4fe:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    a502:	09 24       	jz	$+20     	;abs 0xa516
    a504:	3c 92       	cmp	#8,	r12	;r2 As==11
    a506:	07 24       	jz	$+16     	;abs 0xa516

0000a508 <.Loc.169.1>:
    elyErrorSignal(ErrRegClip);
    a508:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a50c <.LVL69>:
    a50c:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a510 <.LVL70>:
    return 0x08;
    a510:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a512:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a516 <.L34>:
  if ((value & 0x04) && value != 0x04) {
    a516:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    a51a:	09 24       	jz	$+20     	;abs 0xa52e
    a51c:	2c 92       	cmp	#4,	r12	;r2 As==10
    a51e:	07 24       	jz	$+16     	;abs 0xa52e

0000a520 <.Loc.173.1>:
    elyErrorSignal(ErrRegClip);
    a520:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a524 <.LVL72>:
    a524:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a528 <.LVL73>:
    return 0x04;
    a528:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a52a:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a52e <.L35>:
  if ((value & 0x02) && value != 0x02) {
    a52e:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    a532:	09 24       	jz	$+20     	;abs 0xa546
    a534:	2c 93       	cmp	#2,	r12	;r3 As==10
    a536:	07 24       	jz	$+16     	;abs 0xa546

0000a538 <.Loc.177.1>:
    elyErrorSignal(ErrRegClip);
    a538:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a53c <.LVL75>:
    a53c:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a540 <.LVL76>:
    return 0x02;
    a540:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a542:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a546 <.L36>:
  if ((value & 0x01) && value != 0x01) {
    a546:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    a54a:	09 24       	jz	$+20     	;abs 0xa55e
    a54c:	1c 93       	cmp	#1,	r12	;r3 As==01
    a54e:	07 24       	jz	$+16     	;abs 0xa55e

0000a550 <.Loc.181.1>:
    elyErrorSignal(ErrRegClip);
    a550:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a554 <.LVL78>:
    a554:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a558 <.L41>:
      value = (value == 0x00 ? 0x01 : value);
    a558:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a55a:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a55e <.L37>:
  if (value & 0xD0) {
    a55e:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a562:	8b 27       	jz	$-232    	;abs 0xa47a

0000a564 <.Loc.185.1>:
    elyErrorSignal(ErrRegClip);
    a564:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a568 <.LVL81>:
    a568:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a56c <.LVL82>:
    a56c:	80 00 96 a4 	mova	#42134,	r0	;0x0a496

0000a570 <.L30>:
      value = clamp(value, 0, 4);
    a570:	6e 42       	mov.b	#4,	r14	;r2 As==10
    a572:	80 00 0c a4 	mova	#41996,	r0	;0x0a40c

0000a576 <.L38>:
  else if ((int8_t)(value) > max) {
    a576:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    a57a:	4e 9d       	cmp.b	r13,	r14	;
    a57c:	7e 37       	jge	$-258    	;abs 0xa47a

0000a57e <.Loc.198.1>:
    elyErrorSignal(ErrRegClip);
    a57e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a582 <.LVL85>:
    a582:	b0 13 28 a7 	calla	#42792		;0x0a728

0000a586 <.LVL86>:
    value = (uint8_t)(max);
    a586:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    a58a:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a58e <.L16>:
      value = (value == 0x00 ? 0x01 : value);
    a58e:	0c 93       	cmp	#0,	r12	;r3 As==00
    a590:	e3 27       	jz	$-56     	;abs 0xa558
    a592:	80 00 7a a4 	mova	#42106,	r0	;0x0a47a

0000a596 <.L39>:
      else if (addr > 0xC0) {
    a596:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    a59a:	4d 9e       	cmp.b	r14,	r13	;
    a59c:	6e 2f       	jc	$-290    	;abs 0xa47a

0000a59e <.Loc.334.1>:
        value = elyRFDLLClampReg(addr, value);
    a59e:	4d 4c       	mov.b	r12,	r13	;
    a5a0:	4c 4e       	mov.b	r14,	r12	;

0000a5a2 <.LVL89>:
    a5a2:	b0 13 ce ab 	calla	#43982		;0x0abce

0000a5a6 <.LVL90>:
    a5a6:	80 00 d2 a4 	mova	#42194,	r0	;0x0a4d2

0000a5aa <elyRegGet>:
void elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a5aa:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000a5ac <.LCFI7>:
    a5ac:	49 4c       	mov.b	r12,	r9	;
    a5ae:	ca 0d       	mova	r13,	r10	;
    a5b0:	47 4e       	mov.b	r14,	r7	;

0000a5b2 <.Loc.342.1>:
  regs_in_progress = n;
    a5b2:	41 18 c2 47 	movx.b	r7,	&0x11e94;
    a5b6:	94 1e 

0000a5b8 <.Loc.344.1>:
  if (bank == 0) {
    a5b8:	09 93       	cmp	#0,	r9	;r3 As==00
    a5ba:	17 24       	jz	$+48     	;abs 0xa5ea
    a5bc:	45 43       	clr.b	r5		;

0000a5be <.LBB70>:
      fram_reg(1, bank, addr, (buffer+i));
    a5be:	88 00 48 a2 	mova	#41544,	r8	;0x0a248
    a5c2:	56 43       	mov.b	#1,	r6	;r3 As==01

0000a5c4 <.L100>:
    for (int i = 0; i < n; i++) {
    a5c4:	05 97       	cmp	r7,	r5	;
    a5c6:	15 38       	jl	$+44     	;abs 0xa5f2

0000a5c8 <.LBB73>:
  return chSemWaitTimeout(&bsp->sem, time);
    a5c8:	4d 43       	clr.b	r13		;
    a5ca:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a5ce:	b0 13 28 47 	calla	#18216		;0x04728

0000a5d2 <.LBE73>:
}
    a5d2:	80 00 ee a5 	mova	#42478,	r0	;0x0a5ee

0000a5d6 <.L102>:
      *(buffer+i) = bank0p[addr];
    a5d6:	6d 4a       	mov.b	@r10,	r13	;
    a5d8:	40 18 0c 4d 	movx.w	r13,	r12	;
    a5dc:	40 18 da 4c 	movx.b	54612(r12),0(r10)	;0x0d554
    a5e0:	54 d5 00 00 

0000a5e4 <.LBE76>:
    for (int i = 0; i < n; i++) {
    a5e4:	19 53       	inc	r9		;
    a5e6:	aa 00 01 00 	adda	#1,	r10	;

0000a5ea <.L101>:
    a5ea:	09 97       	cmp	r7,	r9	;
    a5ec:	f4 3b       	jl	$-22     	;abs 0xa5d6

0000a5ee <.L98>:
}
    a5ee:	55 16       	popm.a	#6,	r10	;20-bit words
    a5f0:	10 01       	reta			;

0000a5f2 <.L104>:
      fram_reg(1, bank, addr, (buffer+i));
    a5f2:	cf 0a       	mova	r10,	r15	;
    a5f4:	6e 4a       	mov.b	@r10,	r14	;
    a5f6:	4d 49       	mov.b	r9,	r13	;
    a5f8:	4c 46       	mov.b	r6,	r12	;
    a5fa:	48 13       	calla	r8		;

0000a5fc <.LBE72>:
    for (int i = 0; i < n; i++) {
    a5fc:	15 53       	inc	r5		;
    a5fe:	aa 00 01 00 	adda	#1,	r10	;
    a602:	80 00 c4 a5 	mova	#42436,	r0	;0x0a5c4

0000a606 <elyRegSet>:
void elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    a606:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a608 <.LCFI8>:
    a608:	b1 00 06 00 	suba	#6,	r1	;

0000a60c <.LCFI9>:
    a60c:	47 4c       	mov.b	r12,	r7	;
    a60e:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

0000a612 <.Loc.364.1>:
  regs_in_progress = n;
    a612:	41 18 c2 4e 	movx.b	r14,	&0x11e94;
    a616:	94 1e 

0000a618 <.LBB82>:
  for (int i = 0; i < n * 2; i += 2) {
    a618:	0e 5e       	rla	r14		;

0000a61a <.LVL105>:
    a61a:	81 4e 04 00 	mov	r14,	4(r1)	;
    a61e:	c6 0d       	mova	r13,	r6	;
    a620:	ca 0d       	mova	r13,	r10	;
    a622:	aa 00 01 00 	adda	#1,	r10	;
    a626:	49 43       	clr.b	r9		;

0000a628 <.LBB83>:
    (*valuep) = elyClampReg(addr, (*valuep));
    a628:	84 00 b0 a3 	mova	#41904,	r4	;0x0a3b0

0000a62c <.Loc.372.1>:
    fram_reg(0, bank, addr, valuep);
    a62c:	88 00 48 a2 	mova	#41544,	r8	;0x0a248
    a630:	45 49       	mov.b	r9,	r5	;

0000a632 <.L106>:
  for (int i = 0; i < n * 2; i += 2) {
    a632:	19 91 04 00 	cmp	4(r1),	r9	;
    a636:	09 38       	jl	$+20     	;abs 0xa64a

0000a638 <.LBB85>:
    a638:	4d 43       	clr.b	r13		;
    a63a:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a63e:	b0 13 28 47 	calla	#18216		;0x04728

0000a642 <.LBE85>:
}
    a642:	a1 00 06 00 	adda	#6,	r1	;
    a646:	64 16       	popm.a	#7,	r10	;20-bit words
    a648:	10 01       	reta			;

0000a64a <.L107>:
    uint8_t addr = buffer[i];
    a64a:	6e 46       	mov.b	@r6,	r14	;

0000a64c <.LVL109>:
    (*valuep) = elyClampReg(addr, (*valuep));
    a64c:	6d 4a       	mov.b	@r10,	r13	;
    a64e:	4c 4e       	mov.b	r14,	r12	;
    a650:	71 0e 00 00 	mova	r14,	0(r1)	;

0000a654 <.LVL110>:
    a654:	44 13       	calla	r4		;

0000a656 <.LVL111>:
    a656:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

0000a65a <.Loc.372.1>:
    fram_reg(0, bank, addr, valuep);
    a65a:	cf 0a       	mova	r10,	r15	;
    a65c:	0e 01       	mova	@r1,	r14	;
    a65e:	4d 47       	mov.b	r7,	r13	;
    a660:	4c 45       	mov.b	r5,	r12	;
    a662:	48 13       	calla	r8		;

0000a664 <.LBE84>:
  for (int i = 0; i < n * 2; i += 2) {
    a664:	29 53       	incd	r9		;
    a666:	a6 00 02 00 	adda	#2,	r6	;
    a66a:	aa 00 02 00 	adda	#2,	r10	;

0000a66e <.LVL114>:
    a66e:	80 00 32 a6 	mova	#42546,	r0	;0x0a632

0000a672 <elyRegGetBlock>:
void elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a672:	b1 00 02 00 	suba	#2,	r1	;

0000a676 <.LCFI10>:
    a676:	4b 4c       	mov.b	r12,	r11	;
    a678:	cc 0d       	mova	r13,	r12	;

0000a67a <.LVL116>:
    a67a:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    a67e:	3f f0 ff 00 	and	#255,	r15	;#0x00ff

0000a682 <.Loc.382.1>:
  if (bank == 0) {
    a682:	0b 93       	cmp	#0,	r11	;r3 As==00
    a684:	0b 20       	jnz	$+24     	;abs 0xa69c

0000a686 <.Loc.383.1>:
    memcpy(buffer, bank0p + addr, n);
    a686:	40 18 0d 4e 	movx.w	r14,	r13	;

0000a68a <.LVL117>:
    a68a:	40 18 0e 4f 	movx.w	r15,	r14	;

0000a68e <.LVL118>:
    a68e:	ad 00 54 d5 	adda	#54612,	r13	;0x0d554

0000a692 <.LVL119>:
    a692:	b0 13 42 d3 	calla	#54082		;0x0d342

0000a696 <.L108>:
}
    a696:	a1 00 02 00 	adda	#2,	r1	;
    a69a:	10 01       	reta			;

0000a69c <.L109>:
    fram_block(1, bank, addr, buffer, n);
    a69c:	c1 4f 00 00 	mov.b	r15,	0(r1)	;
    a6a0:	cf 0d       	mova	r13,	r15	;
    a6a2:	4d 4b       	mov.b	r11,	r13	;
    a6a4:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000a6a6 <.LVL122>:
    a6a6:	b0 13 e0 a2 	calla	#41696		;0x0a2e0

0000a6aa <.LBB90>:
    a6aa:	4d 43       	clr.b	r13		;
    a6ac:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a6b0:	b0 13 28 47 	calla	#18216		;0x04728

0000a6b4 <.LBE90>:
}
    a6b4:	80 00 96 a6 	mova	#42646,	r0	;0x0a696

0000a6b8 <elyRegSetBlock>:
void elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    a6b8:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000a6ba <.LCFI11>:
    a6ba:	b1 00 02 00 	suba	#2,	r1	;

0000a6be <.LCFI12>:
    a6be:	49 4c       	mov.b	r12,	r9	;
    a6c0:	ca 0d       	mova	r13,	r10	;
    a6c2:	45 4e       	mov.b	r14,	r5	;
    a6c4:	44 4f       	mov.b	r15,	r4	;

0000a6c6 <.LVL126>:
    a6c6:	c6 0d       	mova	r13,	r6	;

0000a6c8 <.LBB95>:
  for (int i = 0; i < n; i++) {
    a6c8:	47 43       	clr.b	r7		;

0000a6ca <.Loc.398.1>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a6ca:	88 00 b0 a3 	mova	#41904,	r8	;0x0a3b0

0000a6ce <.L112>:
  for (int i = 0; i < n; i++) {
    a6ce:	07 94       	cmp	r4,	r7	;
    a6d0:	11 38       	jl	$+36     	;abs 0xa6f4

0000a6d2 <.LBE95>:
  fram_block(0, bank, addr, buffer, n);
    a6d2:	c1 44 00 00 	mov.b	r4,	0(r1)	;
    a6d6:	cf 0a       	mova	r10,	r15	;
    a6d8:	4e 45       	mov.b	r5,	r14	;
    a6da:	4d 49       	mov.b	r9,	r13	;
    a6dc:	4c 43       	clr.b	r12		;
    a6de:	b0 13 e0 a2 	calla	#41696		;0x0a2e0

0000a6e2 <.LBB96>:
    a6e2:	4d 43       	clr.b	r13		;
    a6e4:	8c 01 96 1e 	mova	#73366,	r12	;0x11e96
    a6e8:	b0 13 28 47 	calla	#18216		;0x04728

0000a6ec <.LBE96>:
}
    a6ec:	a1 00 02 00 	adda	#2,	r1	;
    a6f0:	64 16       	popm.a	#7,	r10	;20-bit words
    a6f2:	10 01       	reta			;

0000a6f4 <.L113>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    a6f4:	6d 46       	mov.b	@r6,	r13	;
    a6f6:	4c 47       	mov.b	r7,	r12	;
    a6f8:	4c 55       	add.b	r5,	r12	;
    a6fa:	48 13       	calla	r8		;

0000a6fc <.LVL130>:
    a6fc:	c6 4c 00 00 	mov.b	r12,	0(r6)	;

0000a700 <.Loc.397.1>:
  for (int i = 0; i < n; i++) {
    a700:	17 53       	inc	r7		;
    a702:	a6 00 01 00 	adda	#1,	r6	;
    a706:	80 00 ce a6 	mova	#42702,	r0	;0x0a6ce

0000a70a <elyRegInit>:
static const GPTConfig time_timer_cfg = {
  1000, /* 1 kHz - milliseconds */
  time_timer_cb
};

void elyRegInit() {
    a70a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a70c <.LCFI13>:
  gptStart(&time_timer_gpt, &time_timer_cfg);
    a70c:	8a 01 06 15 	mova	#70918,	r10	;0x11506
    a710:	8d 01 1e 01 	mova	#65822,	r13	;0x1011e
    a714:	cc 0a       	mova	r10,	r12	;
    a716:	b0 13 40 50 	calla	#20544		;0x05040

0000a71a <.LVL132>:
  gptStartContinuous(&time_timer_gpt, 1000); /* once per second */
    a71a:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    a71e:	cc 0a       	mova	r10,	r12	;
    a720:	b0 13 70 50 	calla	#20592		;0x05070

0000a724 <.LVL133>:
}
    a724:	0a 16       	popm.a	#1,	r10	;20-bit words
    a726:	10 01       	reta			;

0000a728 <elyErrorSignal>:
    a728:	10 01       	reta			;

0000a72a <elyErrorSignalI>:
    a72a:	10 01       	reta			;

0000a72c <elyErrorSetRptLvlS>:
    a72c:	10 01       	reta			;

0000a72e <elyErrorSetLogLvlS>:
  (void)(lvl);
}

void elyErrorSetLogLvlS(uint8_t lvl) {
  (void)(lvl);
}
    a72e:	10 01       	reta			;

0000a730 <elyEventSignal>:
    a730:	10 01       	reta			;

0000a732 <elyEventSubscribe>:
}

void elyEventSubscribe(uint8_t event, uint16_t addr) {
  (void)(event);
  (void)(addr);
}
    a732:	10 01       	reta			;

0000a734 <elyEventUnsubscribe>:
    a734:	10 01       	reta			;

0000a736 <elyEventLog>:
    a736:	10 01       	reta			;

0000a738 <elyEventUnlog>:
  (void)(event);
}

void elyEventUnlog(uint8_t event) {
  (void)(event);
}
    a738:	10 01       	reta			;

0000a73a <elyEventReset>:

void elyEventReset() {
}
    a73a:	10 01       	reta			;

0000a73c <elyChanSubscribe>:
    a73c:	10 01       	reta			;

0000a73e <elyChanUnsubscribe>:
    a73e:	10 01       	reta			;

0000a740 <elyChanLog>:

void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
  (void)(buffer);
  (void)(length);
  (void)(interval);
}
    a740:	10 01       	reta			;

0000a742 <elyChanUnlog>:

void elyChanUnlog(uint8_t * buffer, uint8_t length) {
  (void)(buffer);
  (void)(length);
}
    a742:	10 01       	reta			;

0000a744 <elyChanGetValue>:

size_t elyChanGetValue(uint8_t * buffer, uint8_t id) {
  (void)(buffer);
  (void)(id);
  return 4;
}
    a744:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000a746 <.LVL3>:
    a746:	10 01       	reta			;

0000a748 <elyChanReset>:

void elyChanReset() {
}
    a748:	10 01       	reta			;

0000a74a <elyTelemUpdateConfigS>:

#include "telem.h"

void elyTelemUpdateConfigS(telem_cfg_t config) {
  (void)(config);
}
    a74a:	10 01       	reta			;

0000a74c <elyTelemPostBufferS>:

void elyTelemPostBufferS(uint8_t * buffer, telemcallback_t cb) {
  /* WARNING this is an abominable hack! */
  OSAL_IRQ_PROLOGUE();
    a74c:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    a750:	36 13 

0000a752 <.Loc.12.1>:
  chSysLockFromISR();
  cb(buffer);
    a752:	4d 13       	calla	r13		;

0000a754 <.LVL1>:
  chSysUnlockFromISR();
  OSAL_IRQ_EPILOGUE();
    a754:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    a758:	36 13 
    a75a:	b0 13 6c 46 	calla	#18028		;0x0466c

0000a75e <.LVL2>:
    a75e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    a760:	02 24       	jz	$+6      	;abs 0xa766

0000a762 <.Loc.14.1>:
    a762:	b0 13 7c 46 	calla	#18044		;0x0467c

0000a766 <.L2>:
}
    a766:	10 01       	reta			;

0000a768 <elyUARTDLLTxStateMachine>:
static size_t tx_n;

extern uint32_t UARTLastValidPacketTimer; //ASA
extern uint8_t UARTValidPacketFlag; //ASA

msg_t elyUARTDLLTxStateMachine() {
    a768:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a76a <.LCFI0>:
  static slip_uart_states_t tx_state = ELY_SLIP_NOT_ESCAPED;
  static msg_t escaped_char;
  
  if (NULL == tx_active_buffer) {
    a76a:	2c 01 a8 1e 	mova	&73384,	r12	;0x11ea8
    a76e:	9c 00 00 00 	cmpa	#0,	r12	;
    a772:	46 24       	jz	$+142    	;abs 0xa800

0000a774 <.Loc.23.1>:
    return MSG_RESET; /* state machine parked until next buffer posted */
  }
  
  chDbgAssert((tx_read_ptr - tx_active_buffer) >= 0, "Somehow read backwards");
  if ((size_t)(tx_read_ptr - tx_active_buffer) == tx_n) {
    a774:	2e 01 a4 1e 	mova	&73380,	r14	;0x11ea4
    a778:	00 18 4a 4e 	movx.a	r14,	r10	;
    a77c:	00 18 4a 8c 	subx.a	r12,	r10	;
    a780:	80 18 5a 92 	cmpx.a	&0x11ea0,r10	;
    a784:	a0 1e 
    a786:	0a 20       	jnz	$+22     	;abs 0xa79c

0000a788 <.Loc.24.1>:
    tx_state = ELY_SLIP_NOT_ESCAPED;
    a788:	41 18 e2 43 	movx.b	#2,	&0x10219;r3 As==10
    a78c:	19 02 

0000a78e <.Loc.25.1>:
    tx_active_buffer = NULL;
    a78e:	01 18 c2 43 	movx.a	#0,	&0x11ea8;r3 As==00
    a792:	a8 1e 

0000a794 <.Loc.26.1>:
    return SLIP_END;
    a794:	7c 40 c0 00 	mov.b	#192,	r12	;#0x00c0

0000a798 <.L1>:
    default:
      chSysHalt("unreachable");
  }
  
  return MSG_RESET; /* unreachable */
}
    a798:	0a 16       	popm.a	#1,	r10	;20-bit words
    a79a:	10 01       	reta			;

0000a79c <.L3>:
  switch (tx_state) {
    a79c:	c0 18 5c 42 	movx.b	&0x10219,r12	;
    a7a0:	19 02 
    a7a2:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a7a4:	1a 24       	jz	$+54     	;abs 0xa7da
    a7a6:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a7a8:	27 20       	jnz	$+80     	;abs 0xa7f8

0000a7aa <.Loc.29.1>:
  msg_t c = *tx_read_ptr;
    a7aa:	6d 4e       	mov.b	@r14,	r13	;
    a7ac:	40 18 0c 4d 	movx.w	r13,	r12	;

0000a7b0 <.Loc.33.1>:
      if (c == SLIP_ESC || c == SLIP_END) {
    a7b0:	9c 00 db 00 	cmpa	#219,	r12	;0x000db
    a7b4:	03 24       	jz	$+8      	;abs 0xa7bc

0000a7b6 <.Loc.33.1>:
    a7b6:	9c 00 c0 00 	cmpa	#192,	r12	;0x000c0
    a7ba:	09 20       	jnz	$+20     	;abs 0xa7ce

0000a7bc <.L7>:
        tx_state = ELY_SLIP_ESCAPED;
    a7bc:	41 18 d2 43 	movx.b	#1,	&0x10219;r3 As==01
    a7c0:	19 02 

0000a7c2 <.Loc.35.1>:
        escaped_char = c;
    a7c2:	61 0c 9c 1e 	mova	r12,	&73372	; 0x11e9c

0000a7c6 <.Loc.36.1>:
        return SLIP_ESC;
    a7c6:	7c 40 db 00 	mov.b	#219,	r12	;#0x00db
    a7ca:	80 00 98 a7 	mova	#42904,	r0	;0x0a798

0000a7ce <.L8>:
        tx_read_ptr++;
    a7ce:	ae 00 01 00 	adda	#1,	r14	;
    a7d2:	61 0e a4 1e 	mova	r14,	&73380	; 0x11ea4

0000a7d6 <.Loc.40.1>:
        return c;
    a7d6:	80 00 98 a7 	mova	#42904,	r0	;0x0a798

0000a7da <.L5>:
      tx_read_ptr++;
    a7da:	ae 00 01 00 	adda	#1,	r14	;
    a7de:	61 0e a4 1e 	mova	r14,	&73380	; 0x11ea4

0000a7e2 <.Loc.45.1>:
      tx_state = ELY_SLIP_NOT_ESCAPED;
    a7e2:	41 18 e2 43 	movx.b	#2,	&0x10219;r3 As==10
    a7e6:	19 02 

0000a7e8 <.Loc.46.1>:
      if (escaped_char == SLIP_ESC) {
    a7e8:	2c 01 9c 1e 	mova	&73372,	r12	;0x11e9c
    a7ec:	9c 00 db 00 	cmpa	#219,	r12	;0x000db
    a7f0:	0b 24       	jz	$+24     	;abs 0xa808

0000a7f2 <.Loc.49.1>:
      else if (escaped_char == SLIP_END) {
    a7f2:	9c 00 c0 00 	cmpa	#192,	r12	;0x000c0
    a7f6:	0c 24       	jz	$+26     	;abs 0xa810

0000a7f8 <.L15>:
      chSysHalt("unreachable");
    a7f8:	8c 00 d9 d4 	mova	#54489,	r12	;0x0d4d9
    a7fc:	b0 13 7a 45 	calla	#17786		;0x0457a

0000a800 <.L9>:
    return MSG_RESET; /* state machine parked until next buffer posted */
    a800:	8c 0f fe ff 	mova	#-2,	r12	;0xfffffffe
    a804:	80 00 98 a7 	mova	#42904,	r0	;0x0a798

0000a808 <.L10>:
        return SLIP_ESC_ESC;
    a808:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    a80c:	80 00 98 a7 	mova	#42904,	r0	;0x0a798

0000a810 <.L11>:
        return SLIP_ESC_END;
    a810:	7c 40 dc 00 	mov.b	#220,	r12	;#0x00dc
    a814:	80 00 98 a7 	mova	#42904,	r0	;0x0a798

0000a818 <elyUARTDLLTxSetBuffer>:

void elyUARTDLLTxSetBuffer(uint8_t * buffer) {
  chDbgAssert(NULL == tx_active_buffer, "Incorrect event on buffer posting");
  tx_active_buffer = buffer;
    a818:	61 0c a8 1e 	mova	r12,	&73384	; 0x11ea8

0000a81c <.Loc.66.1>:
  tx_read_ptr = tx_active_buffer;
    a81c:	61 0c a4 1e 	mova	r12,	&73380	; 0x11ea4

0000a820 <.Loc.67.1>:
  tx_n = elyNLGetLength(tx_active_buffer);
    a820:	b0 13 98 c4 	calla	#50328		;0x0c498

0000a824 <.LVL12>:
    a824:	61 0c a0 1e 	mova	r12,	&73376	; 0x11ea0

0000a828 <.Loc.68.1>:
}
    a828:	10 01       	reta			;

0000a82a <elyUARTDLLRxInit>:

void elyUARTDLLRxInit() {
  
}
    a82a:	10 01       	reta			;

0000a82c <elyUARTDLLRxStateMachine>:
  
  chSysUnlockFromISR();

}

void elyUARTDLLRxStateMachine(msg_t c) {
    a82c:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000a82e <.LCFI1>:
    a82e:	ca 0c       	mova	r12,	r10	;

0000a830 <.Loc.93.1>:
  static uint8_t * rx_write_ptr = NULL;
  static size_t rx_n = elyNLHeaderLen;
  static bool header = true;
  
  size_t pkt_len = (size_t)(rx_write_ptr - rx_active_buffer);
    a830:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae

0000a834 <.LVL17>:
    a834:	28 01 98 1e 	mova	&73368,	r8	;0x11e98
    a838:	f8 0c       	suba	r12,	r8	;

0000a83a <.Loc.95.1>:
  
  if (header && pkt_len == rx_n) {
    a83a:	41 18 c2 93 	cmpx.b	#0,	&0x10218;r3 As==00
    a83e:	18 02 
    a840:	1e 24       	jz	$+62     	;abs 0xa87e

0000a842 <.Loc.95.1>:
    a842:	80 18 58 92 	cmpx.a	&0x10214,r8	;
    a846:	14 02 
    a848:	16 20       	jnz	$+46     	;abs 0xa876

0000a84a <.Loc.96.1>:
    if (elyNLValidate(rx_active_buffer)) {
    a84a:	b0 13 b0 c4 	calla	#50352		;0x0c4b0

0000a84e <.LVL19>:
    a84e:	49 4c       	mov.b	r12,	r9	;
    a850:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae
    a854:	49 93       	cmp.b	#0,	r9	;r3 As==00
    a856:	61 24       	jz	$+196    	;abs 0xa91a

0000a858 <.Loc.97.1>:
        rx_n = elyNLGetLength(rx_active_buffer);
    a858:	b0 13 98 c4 	calla	#50328		;0x0c498

0000a85c <.LVL20>:
    a85c:	61 0c 14 02 	mova	r12,	&66068	; 0x10214

0000a860 <.Loc.98.1>:
        if (rx_n <= elyNLMaxLen && rx_n > elyNLHeaderLen) {
    a860:	00 18 c2 9c 	cmpx.a	r12,	&0xfd762;
    a864:	62 d7 
    a866:	4d 28       	jnc	$+156    	;abs 0xa902

0000a868 <.Loc.98.1>:
    a868:	7d 40 06 00 	mov.b	#6,	r13	;
    a86c:	dd 0c       	cmpa	r12,	r13	;
    a86e:	49 2c       	jc	$+148    	;abs 0xa902

0000a870 <.Loc.99.1>:
          header = false;
    a870:	41 18 c2 43 	movx.b	#0,	&0x10218;r3 As==00
    a874:	18 02 

0000a876 <.L20>:
      rx_active_buffer = NULL;
      rx_state = ELY_SLIP_RESET;
    }
  }
  
  if (!header && pkt_len == rx_n && (c != SLIP_END || rx_state != ELY_SLIP_NOT_ESCAPED)) {
    a876:	41 18 c2 93 	cmpx.b	#0,	&0x10218;r3 As==00
    a87a:	18 02 
    a87c:	15 20       	jnz	$+44     	;abs 0xa8a8

0000a87e <.L40>:
    a87e:	80 18 58 92 	cmpx.a	&0x10214,r8	;
    a882:	14 02 
    a884:	11 20       	jnz	$+36     	;abs 0xa8a8

0000a886 <.Loc.116.1>:
    a886:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    a88a:	04 20       	jnz	$+10     	;abs 0xa894

0000a88c <.Loc.116.1>:
    a88c:	41 18 e2 93 	cmpx.b	#2,	&0x11eac;r3 As==10
    a890:	ac 1e 
    a892:	0a 24       	jz	$+22     	;abs 0xa8a8

0000a894 <.L24>:
    /* Packet too long or invalid */
    elyNLFreeBuffer(rx_active_buffer);
    a894:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae
    a898:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a89c <.LVL21>:
    rx_active_buffer = NULL;
    a89c:	01 18 c2 43 	movx.a	#0,	&0x11eae;r3 As==00
    a8a0:	ae 1e 

0000a8a2 <.Loc.120.1>:
    rx_state = ELY_SLIP_RESET;
    a8a2:	41 18 c2 43 	movx.b	#0,	&0x11eac;r3 As==00
    a8a6:	ac 1e 

0000a8a8 <.L23>:
  }
  
  if (rx_state == ELY_SLIP_RESET) {
    a8a8:	c0 18 5c 42 	movx.b	&0x11eac,r12	;
    a8ac:	ac 1e 
    a8ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    a8b0:	3e 20       	jnz	$+126    	;abs 0xa92e

0000a8b2 <.Loc.125.1>:
    chDbgAssert(NULL == rx_active_buffer, "Reset without freeing buffer");
    rx_active_buffer = elyNLGetBuffer();
    a8b2:	b0 13 76 c2 	calla	#49782		;0x0c276

0000a8b6 <.LVL22>:
    a8b6:	61 0c ae 1e 	mova	r12,	&73390	; 0x11eae

0000a8ba <.Loc.126.1>:
    if (NULL == rx_active_buffer) {
    a8ba:	9c 00 00 00 	cmpa	#0,	r12	;
    a8be:	81 24       	jz	$+260    	;abs 0xa9c2

0000a8c0 <.Loc.130.1>:
      /* TODO signal a buffer overflow here */
      return;
    }
    rx_write_ptr = rx_active_buffer;
    a8c0:	61 0c 98 1e 	mova	r12,	&73368	; 0x11e98

0000a8c4 <.Loc.131.1>:
    rx_n = elyNLHeaderLen;
    a8c4:	01 18 f2 40 	movx.a	#6,	&0x10214;
    a8c8:	06 00 14 02 

0000a8cc <.Loc.132.1>:
    header = true;
    a8cc:	41 18 d2 43 	movx.b	#1,	&0x10218;r3 As==01
    a8d0:	18 02 

0000a8d2 <.Loc.133.1>:
    rx_state = ELY_SLIP_NOT_ESCAPED;
    a8d2:	41 18 e2 43 	movx.b	#2,	&0x11eac;r3 As==10
    a8d6:	ac 1e 

0000a8d8 <.Loc.139.1>:
  }
  
  /*gptStopTimerI(&uart_gpt);*/
  /*gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);*/
  
  switch (c) {
    a8d8:	9a 00 db 00 	cmpa	#219,	r10	;0x000db
    a8dc:	6a 24       	jz	$+214    	;abs 0xa9b2
    a8de:	7c 40 db 00 	mov.b	#219,	r12	;#0x00db
    a8e2:	dc 0a       	cmpa	r10,	r12	;
    a8e4:	4d 38       	jl	$+156    	;abs 0xa980
    a8e6:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    a8ea:	2d 24       	jz	$+92     	;abs 0xa946

0000a8ec <.L28>:
        rx_state = ELY_SLIP_NOT_ESCAPED;
        return;
      }
      /* intentional fallthrough */
    default:
      *rx_write_ptr++ = (uint8_t)(c);
    a8ec:	2c 01 98 1e 	mova	&73368,	r12	;0x11e98
    a8f0:	cd 0c       	mova	r12,	r13	;
    a8f2:	ad 00 01 00 	adda	#1,	r13	;
    a8f6:	61 0d 98 1e 	mova	r13,	&73368	; 0x11e98
    a8fa:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

0000a8fe <.Loc.182.1>:
      return;
    a8fe:	80 00 c2 a9 	mova	#43458,	r0	;0x0a9c2

0000a902 <.L22>:
          elyNLFreeBuffer(rx_active_buffer);
    a902:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae
    a906:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a90a <.LVL23>:
          rx_active_buffer = NULL;
    a90a:	01 18 c2 43 	movx.a	#0,	&0x11eae;r3 As==00
    a90e:	ae 1e 

0000a910 <.Loc.105.1>:
          rx_state = ELY_SLIP_RESET;
    a910:	41 18 c2 43 	movx.b	#0,	&0x11eac;r3 As==00
    a914:	ac 1e 
    a916:	80 00 76 a8 	mova	#43126,	r0	;0x0a876

0000a91a <.L21>:
      elyNLFreeBuffer(rx_active_buffer);
    a91a:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a91e <.LVL24>:
      rx_active_buffer = NULL;
    a91e:	01 18 c2 43 	movx.a	#0,	&0x11eae;r3 As==00
    a922:	ae 1e 

0000a924 <.Loc.112.1>:
      rx_state = ELY_SLIP_RESET;
    a924:	41 18 c2 49 	movx.b	r9,	&0x11eac;
    a928:	ac 1e 
    a92a:	80 00 76 a8 	mova	#43126,	r0	;0x0a876

0000a92e <.L25>:
  switch (c) {
    a92e:	9a 00 db 00 	cmpa	#219,	r10	;0x000db
    a932:	3f 24       	jz	$+128    	;abs 0xa9b2
    a934:	7d 40 db 00 	mov.b	#219,	r13	;#0x00db
    a938:	dd 0a       	cmpa	r10,	r13	;
    a93a:	22 38       	jl	$+70     	;abs 0xa980
    a93c:	9a 00 c0 00 	cmpa	#192,	r10	;0x000c0
    a940:	d5 23       	jnz	$-84     	;abs 0xa8ec

0000a942 <.Loc.153.1>:
      if (rx_state == ELY_SLIP_NOT_ESCAPED && pkt_len == rx_n && !header) {
    a942:	2c 93       	cmp	#2,	r12	;r3 As==10
    a944:	42 20       	jnz	$+134    	;abs 0xa9ca

0000a946 <.L31>:
    a946:	80 18 58 92 	cmpx.a	&0x10214,r8	;
    a94a:	14 02 
    a94c:	3e 20       	jnz	$+126    	;abs 0xa9ca

0000a94e <.Loc.153.1>:
    a94e:	41 18 c2 93 	cmpx.b	#0,	&0x10218;r3 As==00
    a952:	18 02 
    a954:	3a 20       	jnz	$+118    	;abs 0xa9ca

0000a956 <.Loc.154.1>:
        elyNLRouteUART(rx_active_buffer);
    a956:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae
    a95a:	b0 13 f6 c2 	calla	#49910		;0x0c2f6

0000a95e <.LVL25>:
        UARTLastValidPacketTimer = 0; //ASA
    a95e:	41 18 82 43 	movx.w	#0,	&0x13968;r3 As==00
    a962:	68 39 
    a964:	41 18 82 43 	movx.w	#0,	&0x1396a;r3 As==00
    a968:	6a 39 

0000a96a <.Loc.156.1>:
        UARTValidPacketFlag = TRUE; //ASA
    a96a:	40 18 d2 43 	movx.b	#1,	&0xfd76a;r3 As==01
    a96e:	6a d7 

0000a970 <.L39>:
      rx_active_buffer = NULL;
    a970:	01 18 c2 43 	movx.a	#0,	&0x11eae;r3 As==00
    a974:	ae 1e 

0000a976 <.Loc.163.1>:
      rx_state = ELY_SLIP_RESET;
    a976:	41 18 c2 43 	movx.b	#0,	&0x11eac;r3 As==00
    a97a:	ac 1e 

0000a97c <.Loc.165.1>:
      return;
    a97c:	80 00 c2 a9 	mova	#43458,	r0	;0x0a9c2

0000a980 <.L34>:
  switch (c) {
    a980:	9a 00 dc 00 	cmpa	#220,	r10	;0x000dc
    a984:	28 24       	jz	$+82     	;abs 0xa9d6
    a986:	9a 00 dd 00 	cmpa	#221,	r10	;0x000dd
    a98a:	b0 23       	jnz	$-158    	;abs 0xa8ec

0000a98c <.Loc.167.1>:
      if (rx_state == ELY_SLIP_ESCAPED) {
    a98c:	41 18 d2 93 	cmpx.b	#1,	&0x11eac;r3 As==01
    a990:	ac 1e 
    a992:	ac 23       	jnz	$-166    	;abs 0xa8ec

0000a994 <.Loc.168.1>:
        *rx_write_ptr++ = SLIP_ESC;
    a994:	2c 01 98 1e 	mova	&73368,	r12	;0x11e98
    a998:	cd 0c       	mova	r12,	r13	;
    a99a:	ad 00 01 00 	adda	#1,	r13	;
    a99e:	61 0d 98 1e 	mova	r13,	&73368	; 0x11e98
    a9a2:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    a9a6:	00 00 

0000a9a8 <.L63>:
        rx_state = ELY_SLIP_NOT_ESCAPED;
    a9a8:	41 18 e2 43 	movx.b	#2,	&0x11eac;r3 As==10
    a9ac:	ac 1e 

0000a9ae <.Loc.177.1>:
        return;
    a9ae:	80 00 c2 a9 	mova	#43458,	r0	;0x0a9c2

0000a9b2 <.L29>:
      if (rx_state == ELY_SLIP_NOT_ESCAPED) {
    a9b2:	c0 18 5c 42 	movx.b	&0x11eac,r12	;
    a9b6:	ac 1e 
    a9b8:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a9ba:	05 20       	jnz	$+12     	;abs 0xa9c6

0000a9bc <.Loc.142.1>:
        rx_state = ELY_SLIP_ESCAPED;
    a9bc:	41 18 d2 43 	movx.b	#1,	&0x11eac;r3 As==01
    a9c0:	ac 1e 

0000a9c2 <.L19>:
  }
}
    a9c2:	28 16       	popm.a	#3,	r10	;20-bit words
    a9c4:	10 01       	reta			;

0000a9c6 <.L36>:
      else if (rx_state == ELY_SLIP_ESCAPED) {
    a9c6:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a9c8:	fc 23       	jnz	$-6      	;abs 0xa9c2

0000a9ca <.L38>:
        elyNLFreeBuffer(rx_active_buffer);
    a9ca:	2c 01 ae 1e 	mova	&73390,	r12	;0x11eae
    a9ce:	b0 13 80 c2 	calla	#49792		;0x0c280

0000a9d2 <.LVL26>:
    a9d2:	80 00 70 a9 	mova	#43376,	r0	;0x0a970

0000a9d6 <.L32>:
      if (rx_state == ELY_SLIP_ESCAPED) {
    a9d6:	41 18 d2 93 	cmpx.b	#1,	&0x11eac;r3 As==01
    a9da:	ac 1e 
    a9dc:	87 23       	jnz	$-240    	;abs 0xa8ec

0000a9de <.Loc.175.1>:
        *rx_write_ptr++ = SLIP_END;
    a9de:	2c 01 98 1e 	mova	&73368,	r12	;0x11e98
    a9e2:	cd 0c       	mova	r12,	r13	;
    a9e4:	ad 00 01 00 	adda	#1,	r13	;
    a9e8:	61 0d 98 1e 	mova	r13,	&73368	; 0x11e98
    a9ec:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    a9f0:	00 00 
    a9f2:	80 00 a8 a9 	mova	#43432,	r0	;0x0a9a8

0000a9f6 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    a9f6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000a9f8 <.LCFI0>:
    a9f8:	08 14       	pushm.a	#1,	r8	;20-bit words

0000a9fa <.LCFI1>:
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    a9fa:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    a9fe:	54 01 

0000aa00 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    aa00:	ca 0c       	mova	r12,	r10	;
    aa02:	ce 0d       	mova	r13,	r14	;
    aa04:	ae 0f fe ff 	adda	#1048574,r14	;0xffffe

0000aa08 <.L2>:
    aa08:	00 18 48 4a 	movx.a	r10,	r8	;
    aa0c:	00 18 48 8c 	subx.a	r12,	r8	;

0000aa10 <.LVL3>:
    aa10:	d8 0e       	cmpa	r14,	r8	;
    aa12:	11 28       	jnc	$+36     	;abs 0xaa36

0000aa14 <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    aa14:	ee 0c       	adda	r12,	r14	;
    aa16:	40 18 5f 42 	movx.b	&0x00157,r15	;
    aa1a:	57 01 
    aa1c:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    aa1e:	ce 4f 00 00 	mov.b	r15,	0(r14)	;

0000aa22 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    aa22:	ec 0d       	adda	r13,	r12	;

0000aa24 <.LVL4>:
    aa24:	40 18 5d 42 	movx.b	&0x00156,r13	;
    aa28:	56 01 

0000aa2a <.LVL5>:
    aa2a:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    aa2c:	cc 4d ff ff 	mov.b	r13,	-1(r12)	; 0xffff

0000aa30 <.Loc.63.1>:
}
    aa30:	08 16       	popm.a	#1,	r8	;20-bit words
    aa32:	0a 16       	popm.a	#1,	r10	;20-bit words
    aa34:	10 01       	reta			;

0000aa36 <.L3>:
      CRCDI_L = message[i];
    aa36:	40 18 e2 4a 	movx.b	@r10,	&0x00150;
    aa3a:	50 01 

0000aa3c <.LVL7>:
    aa3c:	aa 00 01 00 	adda	#1,	r10	;

0000aa40 <.LVL8>:
    aa40:	80 00 08 aa 	mova	#43528,	r0	;0x0aa08

0000aa44 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    aa44:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aa46 <.LCFI2>:
    aa46:	08 14       	pushm.a	#1,	r8	;20-bit words

0000aa48 <.LCFI3>:
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    aa48:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    aa4c:	54 01 

0000aa4e <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    aa4e:	ca 0c       	mova	r12,	r10	;
    aa50:	ce 0d       	mova	r13,	r14	;
    aa52:	ae 0f fe ff 	adda	#1048574,r14	;0xffffe

0000aa56 <.L5>:
    aa56:	00 18 48 4a 	movx.a	r10,	r8	;
    aa5a:	00 18 48 8c 	subx.a	r12,	r8	;

0000aa5e <.LVL12>:
    aa5e:	d8 0e       	cmpa	r14,	r8	;
    aa60:	13 28       	jnc	$+40     	;abs 0xaa88

0000aa62 <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    aa62:	ee 0c       	adda	r12,	r14	;
    aa64:	6e 4e       	mov.b	@r14,	r14	;
    aa66:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    aa6a:	ec 0d       	adda	r13,	r12	;

0000aa6c <.LVL13>:
    aa6c:	5d 4c ff ff 	mov.b	-1(r12),r13	;

0000aa70 <.LVL14>:
    aa70:	0d de       	bis	r14,	r13	;
    aa72:	40 18 1e 42 	movx.w	&0x00156,r14	;
    aa76:	56 01 
    aa78:	3e e3       	inv	r14		;
    aa7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    aa7c:	0d 9e       	cmp	r14,	r13	;
    aa7e:	01 24       	jz	$+4      	;abs 0xaa82
    aa80:	4c 43       	clr.b	r12		;

0000aa82 <.L7>:
}
    aa82:	08 16       	popm.a	#1,	r8	;20-bit words
    aa84:	0a 16       	popm.a	#1,	r10	;20-bit words
    aa86:	10 01       	reta			;

0000aa88 <.L6>:
      CRCDI_L = message[i];
    aa88:	40 18 e2 4a 	movx.b	@r10,	&0x00150;
    aa8c:	50 01 

0000aa8e <.LVL16>:
    aa8e:	aa 00 01 00 	adda	#1,	r10	;

0000aa92 <.LVL17>:
    aa92:	80 00 56 aa 	mova	#43606,	r0	;0x0aa56

0000aa96 <crcStart>:
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    aa96:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    aa9a:	54 01 

0000aa9c <.Loc.112.1>:
  /* Change state */
  crc_state = CRC_RUNNING;
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    aa9c:	8c 00 50 01 	mova	#336,	r12	;0x00150
    aaa0:	10 01       	reta			;

0000aaa2 <crcStop>:
  /* Change state */
  crc_state = CRC_STOPPED;
  
  /* Return the result */
  return ~CRCRESR;
}
    aaa2:	40 18 1c 42 	movx.w	&0x00156,r12	;
    aaa6:	56 01 
    aaa8:	3c e3       	inv	r12		;
    aaaa:	10 01       	reta			;

0000aaac <crcGenSDLP>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenSDLP(uint8_t * message, size_t n) {
    aaac:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000aaae <.LCFI0>:
    aaae:	08 14       	pushm.a	#1,	r8	;20-bit words

0000aab0 <.LCFI1>:
   * of 0xFFFF and no inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    aab0:	40 18 b2 43 	movx.w	#-1,	&0x00154;r3 As==11
    aab4:	54 01 

0000aab6 <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    aab6:	ca 0c       	mova	r12,	r10	;
    aab8:	ce 0d       	mova	r13,	r14	;
    aaba:	ae 0f fe ff 	adda	#1048574,r14	;0xffffe

0000aabe <.L2>:
    aabe:	00 18 48 4a 	movx.a	r10,	r8	;
    aac2:	00 18 48 8c 	subx.a	r12,	r8	;

0000aac6 <.LVL3>:
    aac6:	d8 0e       	cmpa	r14,	r8	;
    aac8:	0d 28       	jnc	$+28     	;abs 0xaae4

0000aaca <.LBE2>:
#endif
  
   
  /* Write result to final 2 bytes */
  /* MSB comes first because of how things are transmitted */
  *(message+n-2) = (CRCINIRES_H);
    aaca:	ee 0c       	adda	r12,	r14	;
    aacc:	40 18 de 42 	movx.b	&0x00155,0(r14)	;
    aad0:	55 01 00 00 

0000aad4 <.Loc.55.1>:
  *(message+n-1) = (CRCINIRES_L);
    aad4:	ec 0d       	adda	r13,	r12	;

0000aad6 <.LVL4>:
    aad6:	4f 18 dc 42 	movx.b	&0x00154,-1(r12)	; 0xfffff
    aada:	54 01 ff ff 

0000aade <.Loc.56.1>:
}
    aade:	08 16       	popm.a	#1,	r8	;20-bit words
    aae0:	0a 16       	popm.a	#1,	r10	;20-bit words
    aae2:	10 01       	reta			;

0000aae4 <.L3>:
      CRCDIRB_L = message[i];
    aae4:	40 18 e2 4a 	movx.b	@r10,	&0x00152;
    aae8:	52 01 

0000aaea <.LVL6>:
    aaea:	aa 00 01 00 	adda	#1,	r10	;

0000aaee <.LVL7>:
    aaee:	80 00 be aa 	mova	#43710,	r0	;0x0aabe

0000aaf2 <rxfifothresh_callback>:
  }
}

void rxfifothresh_callback(void) {
  chSysLockFromISR();
  chEvtSignalI(rf_thd, RFRxFifoThresh);
    aaf2:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    aaf6:	4e 43       	clr.b	r14		;
    aaf8:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    aafc:	b0 13 ec 47 	calla	#18412		;0x047ec

0000ab00 <.LVL0>:
  chSysUnlockFromISR();
}
    ab00:	10 01       	reta			;

0000ab02 <txlvl_callback>:
  
}

void txlvl_callback(void) {
  chSysLockFromISR();
  chEvtSignalI(rf_thd, RFTxFifoLevel);
    ab02:	3d 40 00 80 	mov	#-32768,r13	;#0x8000
    ab06:	4e 43       	clr.b	r14		;
    ab08:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    ab0c:	b0 13 ec 47 	calla	#18412		;0x047ec

0000ab10 <.LVL1>:
  chSysUnlockFromISR();
}
    ab10:	10 01       	reta			;

0000ab12 <write_cb>:

void write_cb(SPIDriver * spip) {
    ab12:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000ab14 <.LCFI0>:
  (void)(spip);
  chSysLockFromISR();
  palSetLine(SX1278D1.config->ss_line);
    ab14:	2c 01 5e 15 	mova	&71006,	r12	;0x1155e

0000ab18 <.LVL3>:
    ab18:	3c 0c 22 00 	mova	34(r12),r12	;0x00022
    ab1c:	ca 0c       	mova	r12,	r10	;
    ab1e:	00 18 7a f0 	andx.a	#4095,	r10	;0x00fff
    ab22:	ff 0f 
    ab24:	19 4a 02 00 	mov	2(r10),	r9	;
    ab28:	0c 14       	pushm.a	#1,	r12	;20-bit words
    ab2a:	40 18 3c 41 	popx.w	r12		;
    ab2e:	40 18 3d 41 	popx.w	r13		;
    ab32:	b0 13 8a d2 	calla	#53898		;0x0d28a
    ab36:	0d 12       	push	r13		;
    ab38:	0c 12       	push	r12		;
    ab3a:	0c 16       	popm.a	#1,	r12	;20-bit words
    ab3c:	40 18 0d 4c 	movx.w	r12,	r13	;
    ab40:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ab42:	b0 13 6a d1 	calla	#53610		;0x0d16a
    ab46:	0c d9       	bis	r9,	r12	;
    ab48:	8a 4c 02 00 	mov	r12,	2(r10)	;
    ab4c:	8a 00 ec 47 	mova	#18412,	r10	;0x047ec

0000ab50 <.Loc.467.1>:
  if (transmit_tf_idx == tf_len) {
    ab50:	41 18 92 92 	cmpx.w	&0x0d66c,&0x11ed6;
    ab54:	6c d6 d6 1e 
    ab58:	14 20       	jnz	$+42     	;abs 0xab82

0000ab5a <.LBB24>:
    /* TODO in this function, check for another available packet or frame and
     * if none exists, go to sleep mode */
    /* Done transmitting. Do the stuff */
#if ELY_DISCRETE_PA_CTL
    palClearLine(LINE_PA_PC_EN);
    ab5a:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    ab5e:	ff ef 22 02 

0000ab62 <.Loc.474.1>:
#endif
    palLineDisableEventI(LINE_SX1278_DIO1);
    ab62:	6d 43       	mov.b	#2,	r13	;r3 As==10
    ab64:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    ab68:	b0 13 34 59 	calla	#22836		;0x05934

0000ab6c <.LVL7>:
    
    chEvtSignalI(rf_thd, RFSpiAvailable | RFTxIdle);
    ab6c:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    ab70:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ab72:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    ab76:	4a 13       	calla	r10		;

0000ab78 <.LVL8>:
    transmit_tf_idx = 0;
    ab78:	41 18 82 43 	movx.w	#0,	&0x11ed6;r3 As==00
    ab7c:	d6 1e 

0000ab7e <.L3>:
  }
  else {
    chEvtSignalI(rf_thd, RFSpiAvailable);
  }
  chSysUnlockFromISR();
}
    ab7e:	19 16       	popm.a	#2,	r10	;20-bit words
    ab80:	10 01       	reta			;

0000ab82 <.L4>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    ab82:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    ab86:	4e 43       	clr.b	r14		;
    ab88:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    ab8c:	4a 13       	calla	r10		;

0000ab8e <.LVL10>:
}
    ab8e:	80 00 7e ab 	mova	#43902,	r0	;0x0ab7e

0000ab92 <elyRFChangeTxSyncS>:
void elyRFChangeTxSyncS(SX1278Config * cfg) {
    ab92:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000ab94 <.LCFI1>:
  if (!(bank0p[RegDLLOptions] & BIT2)) { /* Compliant ASM */
    ab94:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    ab98:	ea b2 c4 00 	bit.b	#4,	196(r10);r2 As==10, 0x00c4
    ab9c:	16 20       	jnz	$+46     	;abs 0xabca

0000ab9e <.Loc.79.1>:
                  ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    ab9e:	5d 4a 11 00 	mov.b	17(r10),r13	;0x00011
    aba2:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    aba6:	5e 4a 10 00 	mov.b	16(r10),r14	;0x00010
    abaa:	0d de       	bis	r14,	r13	;
    abac:	5e 4a 13 00 	mov.b	19(r10),r14	;0x00013
    abb0:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    abb4:	5a 4a 12 00 	mov.b	18(r10),r10	;0x00012
    abb8:	0e da       	bis	r10,	r14	;

0000abba <.Loc.77.1>:
    cfg->sync_word = ( (bank0p[RegTXSyncLsb]) |
    abba:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018
    abbe:	8c 4e 1a 00 	mov	r14,	26(r12)	; 0x001a

0000abc2 <.Loc.82.1>:
    sx1278SetSync(&SX1278D1, cfg->sync_word);
    abc2:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e

0000abc6 <.LVL12>:
    abc6:	b0 13 46 67 	calla	#26438		;0x06746

0000abca <.L6>:
}
    abca:	0a 16       	popm.a	#1,	r10	;20-bit words
    abcc:	10 01       	reta			;

0000abce <elyRFDLLClampReg>:
uint8_t elyRFDLLClampReg(uint8_t addr, uint8_t value) {
    abce:	4e 4c       	mov.b	r12,	r14	;
    abd0:	4c 4d       	mov.b	r13,	r12	;

0000abd2 <.LVL15>:
  switch (addr) {
    abd2:	7e 90 c3 ff 	cmp.b	#-61,	r14	;#0xffc3
    abd6:	55 24       	jz	$+172    	;abs 0xac82
    abd8:	7f 40 c3 ff 	mov.b	#-61,	r15	;#0xffc3
    abdc:	4f 9e       	cmp.b	r14,	r15	;
    abde:	0b 28       	jnc	$+24     	;abs 0xabf6
    abe0:	7e 90 c1 ff 	cmp.b	#-63,	r14	;#0xffc1
    abe4:	2e 24       	jz	$+94     	;abs 0xac42
    abe6:	7f 40 c1 ff 	mov.b	#-63,	r15	;#0xffc1
    abea:	4f 9e       	cmp.b	r14,	r15	;
    abec:	36 28       	jnc	$+110    	;abs 0xac5a
    abee:	7e 90 c0 ff 	cmp.b	#-64,	r14	;#0xffc0
    abf2:	1b 24       	jz	$+56     	;abs 0xac2a

0000abf4 <.L9>:
}
    abf4:	10 01       	reta			;

0000abf6 <.L11>:
  switch (addr) {
    abf6:	7e 90 c7 ff 	cmp.b	#-57,	r14	;#0xffc7
    abfa:	49 24       	jz	$+148    	;abs 0xac8e
    abfc:	7e 90 c7 ff 	cmp.b	#-57,	r14	;#0xffc7
    ac00:	f9 2b       	jnc	$-12     	;abs 0xabf4
    ac02:	7e 50 35 00 	add.b	#53,	r14	;#0x0035
    ac06:	7d 42       	mov.b	#8,	r13	;r2 As==11

0000ac08 <.LVL18>:
    ac08:	4d 9e       	cmp.b	r14,	r13	;
    ac0a:	f4 2b       	jnc	$-22     	;abs 0xabf4

0000ac0c <.LBB32>:
  if ((value & 0x10) && value != 0x10) {
    ac0c:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    ac10:	10 00 
    ac12:	41 24       	jz	$+132    	;abs 0xac96
    ac14:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    ac18:	3e 24       	jz	$+126    	;abs 0xac96

0000ac1a <.Loc.91.1>:
    elyErrorSignal(ErrRegClip);
    ac1a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000ac1e <.LVL20>:
    ac1e:	b0 13 28 a7 	calla	#42792		;0x0a728

0000ac22 <.LVL21>:
    return 0x10;
    ac22:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    ac26:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ac2a <.L14>:
  if (value < min) {
    ac2a:	7e 40 06 00 	mov.b	#6,	r14	;
    ac2e:	4e 9c       	cmp.b	r12,	r14	;
    ac30:	e1 2b       	jnc	$-60     	;abs 0xabf4

0000ac32 <.LVL23>:
    elyErrorSignal(ErrRegClip);
    ac32:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    ac36:	b0 13 28 a7 	calla	#42792		;0x0a728

0000ac3a <.LVL24>:
    value = min;
    ac3a:	7c 40 07 00 	mov.b	#7,	r12	;
    ac3e:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ac42 <.L12>:
  else if (value > max) {
    ac42:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    ac46:	4f 9c       	cmp.b	r12,	r15	;
    ac48:	d5 2f       	jc	$-84     	;abs 0xabf4

0000ac4a <.LVL26>:
    elyErrorSignal(ErrRegClip);
    ac4a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    ac4e:	b0 13 28 a7 	calla	#42792		;0x0a728

0000ac52 <.LVL27>:
    value = max;
    ac52:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    ac56:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ac5a <.L13>:
      if ((value & 0x38) == 0x38) {
    ac5a:	4d 4c       	mov.b	r12,	r13	;

0000ac5c <.LVL29>:
    ac5c:	7d f0 38 00 	and.b	#56,	r13	;#0x0038
    ac60:	7d 90 38 00 	cmp.b	#56,	r13	;#0x0038
    ac64:	02 20       	jnz	$+6      	;abs 0xac6a

0000ac66 <.Loc.128.1>:
        value &= ~BIT3;
    ac66:	7c f0 f7 00 	and.b	#247,	r12	;#0x00f7

0000ac6a <.L17>:
      if ((value & 0x07) > 5) {
    ac6a:	4d 4c       	mov.b	r12,	r13	;
    ac6c:	7d f0 07 00 	and.b	#7,	r13	;
    ac70:	7e 40 05 00 	mov.b	#5,	r14	;
    ac74:	4e 9d       	cmp.b	r13,	r14	;
    ac76:	be 2f       	jc	$-130    	;abs 0xabf4

0000ac78 <.LVL31>:
        value |= BIT0;
    ac78:	7c f0 fc 00 	and.b	#252,	r12	;#0x00fc

0000ac7c <.LVL32>:
    ac7c:	1c d3       	bis	#1,	r12	;r3 As==01

0000ac7e <.LVL33>:
    ac7e:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ac82 <.L10>:
      if ((value & 0x03) == 0x03) {
    ac82:	4d 4c       	mov.b	r12,	r13	;

0000ac84 <.LVL35>:
    ac84:	7d f0 03 00 	and.b	#3,	r13	;
    ac88:	7d 90 03 00 	cmp.b	#3,	r13	;
    ac8c:	b3 23       	jnz	$-152    	;abs 0xabf4

0000ac8e <.L15>:
      value &= ~BIT0;
    ac8e:	7c f0 fe 00 	and.b	#254,	r12	;#0x00fe

0000ac92 <.LVL36>:
      break;
    ac92:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ac96 <.L18>:
  if ((value & 0x08) && value != 0x08) {
    ac96:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    ac9a:	09 24       	jz	$+20     	;abs 0xacae
    ac9c:	3c 92       	cmp	#8,	r12	;r2 As==11
    ac9e:	07 24       	jz	$+16     	;abs 0xacae

0000aca0 <.Loc.95.1>:
    elyErrorSignal(ErrRegClip);
    aca0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000aca4 <.LVL38>:
    aca4:	b0 13 28 a7 	calla	#42792		;0x0a728

0000aca8 <.LVL39>:
    return 0x08;
    aca8:	7c 42       	mov.b	#8,	r12	;r2 As==11
    acaa:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000acae <.L19>:
  if ((value & 0x04) && value != 0x04) {
    acae:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    acb2:	09 24       	jz	$+20     	;abs 0xacc6
    acb4:	2c 92       	cmp	#4,	r12	;r2 As==10
    acb6:	07 24       	jz	$+16     	;abs 0xacc6

0000acb8 <.Loc.99.1>:
    elyErrorSignal(ErrRegClip);
    acb8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000acbc <.LVL41>:
    acbc:	b0 13 28 a7 	calla	#42792		;0x0a728

0000acc0 <.LVL42>:
    return 0x04;
    acc0:	6c 42       	mov.b	#4,	r12	;r2 As==10
    acc2:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000acc6 <.L20>:
  if ((value & 0x02) && value != 0x02) {
    acc6:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    acca:	09 24       	jz	$+20     	;abs 0xacde
    accc:	2c 93       	cmp	#2,	r12	;r3 As==10
    acce:	07 24       	jz	$+16     	;abs 0xacde

0000acd0 <.Loc.103.1>:
    elyErrorSignal(ErrRegClip);
    acd0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000acd4 <.LVL44>:
    acd4:	b0 13 28 a7 	calla	#42792		;0x0a728

0000acd8 <.LVL45>:
    return 0x02;
    acd8:	6c 43       	mov.b	#2,	r12	;r3 As==10
    acda:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000acde <.L21>:
  if ((value & 0x01) && value != 0x01) {
    acde:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    ace2:	09 24       	jz	$+20     	;abs 0xacf6
    ace4:	1c 93       	cmp	#1,	r12	;r3 As==01
    ace6:	07 24       	jz	$+16     	;abs 0xacf6

0000ace8 <.Loc.107.1>:
    elyErrorSignal(ErrRegClip);
    ace8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000acec <.LVL47>:
    acec:	b0 13 28 a7 	calla	#42792		;0x0a728

0000acf0 <.LVL48>:
    return 0x01;
    acf0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    acf2:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000acf6 <.L22>:
  if (value & 0xD0) {
    acf6:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    acfa:	7c 27       	jz	$-262    	;abs 0xabf4

0000acfc <.Loc.111.1>:
    elyErrorSignal(ErrRegClip);
    acfc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000ad00 <.LVL50>:
    ad00:	b0 13 28 a7 	calla	#42792		;0x0a728

0000ad04 <.LVL51>:
    return 0x00;
    ad04:	4c 43       	clr.b	r12		;
    ad06:	80 00 f4 ab 	mova	#44020,	r0	;0x0abf4

0000ad0a <elyRFDLLBuildFrame>:
void elyRFDLLBuildFrame(void) {
    ad0a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000ad0c <.LCFI2>:
  chEvtSignal(rf_thd, RFPktAvailable);
    ad0c:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    ad10:	4e 43       	clr.b	r14		;
    ad12:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    ad16:	b0 13 c0 47 	calla	#18368		;0x047c0

0000ad1a <.LVL53>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    ad1a:	24 01 2a 01 	mova	&65834,	r4	;0x1012a
    ad1e:	5c 44 ca 00 	mov.b	202(r4),r12	;0x000ca

0000ad22 <.Loc.179.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    ad22:	5d 44 c9 00 	mov.b	201(r4),r13	;0x000c9

0000ad26 <.Loc.178.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    ad26:	88 01 1a 02 	mova	#66074,	r8	;0x1021a

0000ad2a <.Loc.179.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    ad2a:	0f 4d       	mov	r13,	r15	;
    ad2c:	5f 0f       	rrum	#4,	r15	;

0000ad2e <.Loc.178.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    ad2e:	6f d8       	bis.b	@r8,	r15	;
    ad30:	0e 4c       	mov	r12,	r14	;
    ad32:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    ad36:	7e f0 30 00 	and.b	#48,	r14	;#0x0030
    ad3a:	4f de       	bis.b	r14,	r15	;
    ad3c:	c8 4f 00 00 	mov.b	r15,	0(r8)	;

0000ad40 <.Loc.181.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    ad40:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    ad44:	5d d8 01 00 	bis.b	1(r8),	r13	;

0000ad48 <.Loc.182.1>:
      ((bank0p[RegDLLIDsMSB] & 0x1C) >> 1));
    ad48:	0c 11       	rra	r12		;
    ad4a:	7c f0 0e 00 	and.b	#14,	r12	;#0x000e

0000ad4e <.Loc.181.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    ad4e:	4d dc       	bis.b	r12,	r13	;
    ad50:	c8 4d 01 00 	mov.b	r13,	1(r8)	;

0000ad54 <.Loc.184.1>:
  tf_buffer[2] = mcfc;
    ad54:	40 18 5e 42 	movx.b	&0x0d666,r14	;
    ad58:	66 d6 
    ad5a:	c8 4e 02 00 	mov.b	r14,	2(r8)	;

0000ad5e <.Loc.186.1>:
  tf_buffer[3] = vcfc[0];
    ad5e:	8c 00 64 d6 	mova	#54884,	r12	;0x0d664
    ad62:	6d 4c       	mov.b	@r12,	r13	;
    ad64:	c8 4d 03 00 	mov.b	r13,	3(r8)	;

0000ad68 <.Loc.188.1>:
  mcfc++;
    ad68:	5e 53       	inc.b	r14		;
    ad6a:	40 18 c2 4e 	movx.b	r14,	&0xfd666;
    ad6e:	66 d6 

0000ad70 <.Loc.189.1>:
  vcfc[0]++;
    ad70:	5d 53       	inc.b	r13		;
    ad72:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000ad76 <.Loc.191.1>:
  tf_buffer[4] &= ~BIT6;
    ad76:	5c 48 04 00 	mov.b	4(r8),	r12	;
    ad7a:	7c f0 bf ff 	and.b	#-65,	r12	;#0xffbf

0000ad7e <.Loc.193.1>:
  tf_buffer[4] |= 0x07;
    ad7e:	7c d0 07 00 	bis.b	#7,	r12	;
    ad82:	c8 4c 04 00 	mov.b	r12,	4(r8)	;

0000ad86 <.Loc.194.1>:
  tf_buffer[5] = 0xFF;
    ad86:	41 18 f2 43 	movx.b	#-1,	&0x1021f;r3 As==11
    ad8a:	1f 02 

0000ad8c <.Loc.197.1>:
  if (state == FB_STATE_UNINIT) {
    ad8c:	41 18 c2 93 	cmpx.b	#0,	&0x11ec6;r3 As==00
    ad90:	c6 1e 
    ad92:	39 20       	jnz	$+116    	;abs 0xae06

0000ad94 <.Loc.200.1>:
    if (MSG_OK != chMBFetch(&rf_mbox, (msg_t *)(&active_packet), 
    ad94:	3e 43       	mov	#-1,	r14	;r3 As==11
    ad96:	8d 01 c2 1e 	mova	#73410,	r13	;0x11ec2
    ad9a:	8c 01 1e 0a 	mova	#68126,	r12	;0x10a1e
    ad9e:	b0 13 86 49 	calla	#18822		;0x04986

0000ada2 <.LVL54>:
    pkt_len = elyNLGetLength(active_packet);
    ada2:	2c 01 c2 1e 	mova	&73410,	r12	;0x11ec2
    ada6:	b0 13 98 c4 	calla	#50328		;0x0c498

0000adaa <.LVL55>:
    adaa:	61 0c be 1e 	mova	r12,	&73406	; 0x11ebe

0000adae <.Loc.207.1>:
    tf_buffer[4] &= ~0x07;
    adae:	f8 f0 f8 ff 	and.b	#-8,	4(r8)	;#0xfff8
    adb2:	04 00 

0000adb4 <.Loc.208.1>:
    tf_buffer[5] = 0;
    adb4:	41 18 c2 43 	movx.b	#0,	&0x1021f;r3 As==00
    adb8:	1f 02 

0000adba <.LVL56>:
    idle_len = 0;
    adba:	01 18 c2 43 	movx.a	#0,	&0x11eba;r3 As==00
    adbe:	ba 1e 

0000adc0 <.Loc.211.1>:
    idle_idx = 0;
    adc0:	01 18 c2 43 	movx.a	#0,	&0x11eb6;r3 As==00
    adc4:	b6 1e 

0000adc6 <.Loc.212.1>:
    pkt_idx = 0;
    adc6:	01 18 c2 43 	movx.a	#0,	&0x11eb2;r3 As==00
    adca:	b2 1e 

0000adcc <.Loc.209.1>:
    fhp = true;
    adcc:	59 43       	mov.b	#1,	r9	;r3 As==01

0000adce <.L58>:
  state = FB_STATE_HEADER;
    adce:	41 18 d2 43 	movx.b	#1,	&0x11ec6;r3 As==01
    add2:	c6 1e 

0000add4 <.Loc.167.1>:
  size_t tf_idx = SDLP_TM_PH_LEN;
    add4:	7a 40 06 00 	mov.b	#6,	r10	;

0000add8 <.LBB40>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    add8:	85 00 86 49 	mova	#18822,	r5	;0x04986

0000addc <.Loc.249.1>:
            pkt_len = elyNLGetLength(active_packet);
    addc:	87 00 98 c4 	mova	#50328,	r7	;0x0c498

0000ade0 <.L59>:
  while (tf_idx != tf_data_len) {
    ade0:	2e 00 68 d6 	mova	&54888,	r14	;0x0d668

0000ade4 <.Loc.218.1>:
    switch(state) {
    ade4:	c0 18 5c 42 	movx.b	&0x11ec6,r12	;
    ade8:	c6 1e 

0000adea <.L60>:
  while (tf_idx != tf_data_len) {
    adea:	da 0e       	cmpa	r14,	r10	;
    adec:	0f 20       	jnz	$+32     	;abs 0xae0c

0000adee <.Loc.280.1>:
  if (bank0p[RegDLLTMFEC] & BIT7) {
    adee:	c4 93 c2 00 	cmp.b	#0,	194(r4)	;r3 As==00, 0x00c2
    adf2:	07 34       	jge	$+16     	;abs 0xae02

0000adf4 <.Loc.282.1>:
    crcGenSDLP(tf_buffer, tf_len);
    adf4:	40 18 1d 42 	movx.w	&0x0d66c,r13	;
    adf8:	6c d6 
    adfa:	8c 01 1a 02 	mova	#66074,	r12	;0x1021a
    adfe:	b0 13 ac aa 	calla	#43692		;0x0aaac

0000ae02 <.L57>:
}
    ae02:	64 16       	popm.a	#7,	r10	;20-bit words
    ae04:	10 01       	reta			;

0000ae06 <.L75>:
  bool fhp = false;
    ae06:	49 43       	clr.b	r9		;
    ae08:	80 00 ce ad 	mova	#44494,	r0	;0x0adce

0000ae0c <.L73>:
    switch(state) {
    ae0c:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    ae0e:	14 24       	jz	$+42     	;abs 0xae38
    ae10:	7c 90 03 00 	cmp.b	#3,	r12	;
    ae14:	86 24       	jz	$+270    	;abs 0xaf22
    ae16:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    ae18:	e8 23       	jnz	$-46     	;abs 0xadea

0000ae1a <.Loc.220.1>:
        if (idle_len > 0) {
    ae1a:	01 18 c2 93 	cmpx.a	#0,	&0x11eba;r3 As==00
    ae1e:	ba 1e 
    ae20:	06 24       	jz	$+14     	;abs 0xae2e

0000ae22 <.Loc.221.1>:
          state = FB_STATE_IDLE;
    ae22:	41 18 f2 40 	movx.b	#3,	&0x11ec6;
    ae26:	03 00 c6 1e 
    ae2a:	80 00 e0 ad 	mova	#44512,	r0	;0x0ade0

0000ae2e <.L64>:
          state = FB_STATE_PAYLOAD;
    ae2e:	41 18 e2 43 	movx.b	#2,	&0x11ec6;r3 As==10
    ae32:	c6 1e 
    ae34:	80 00 e0 ad 	mova	#44512,	r0	;0x0ade0

0000ae38 <.L61>:
        if (pkt_idx == pkt_len) {
    ae38:	81 18 d2 92 	cmpx.a	&0x11ebe,&0x11eb2;
    ae3c:	be 1e b2 1e 
    ae40:	5f 20       	jnz	$+192    	;abs 0xaf00

0000ae42 <.LBB41>:
          pkt_idx = 0; /* either way - needs to be 0 when we come back around */
    ae42:	01 18 c2 43 	movx.a	#0,	&0x11eb2;r3 As==00
    ae46:	b2 1e 

0000ae48 <.Loc.230.1>:
          elyNLFreeBufferChecked(active_packet);
    ae48:	2c 01 c2 1e 	mova	&73410,	r12	;0x11ec2
    ae4c:	b0 13 72 c3 	calla	#50034		;0x0c372

0000ae50 <.LVL63>:
          if (!fhp) {
    ae50:	09 93       	cmp	#0,	r9	;r3 As==00
    ae52:	14 20       	jnz	$+42     	;abs 0xae7c

0000ae54 <.Loc.232.1>:
            tf_buffer[4] |= (tf_idx-SDLP_TM_PH_LEN) >> 8;
    ae54:	cc 0a       	mova	r10,	r12	;
    ae56:	ac 0f fa ff 	adda	#1048570,r12	;0xffffa
    ae5a:	0c 14       	pushm.a	#1,	r12	;20-bit words
    ae5c:	40 18 3c 41 	popx.w	r12		;
    ae60:	40 18 3d 41 	popx.w	r13		;
    ae64:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    ae68:	0d 12       	push	r13		;
    ae6a:	0c 12       	push	r12		;
    ae6c:	0c 16       	popm.a	#1,	r12	;20-bit words
    ae6e:	c8 dc 04 00 	bis.b	r12,	4(r8)	;

0000ae72 <.Loc.233.1>:
            tf_buffer[5] = (tf_idx-SDLP_TM_PH_LEN) & 0xFF;
    ae72:	4c 4a       	mov.b	r10,	r12	;
    ae74:	7c 50 fa ff 	add.b	#-6,	r12	;#0xfffa
    ae78:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000ae7c <.L67>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    ae7c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    ae80:	8d 01 c2 1e 	mova	#73410,	r13	;0x11ec2
    ae84:	8c 01 1e 0a 	mova	#68126,	r12	;0x10a1e
    ae88:	45 13       	calla	r5		;

0000ae8a <.LVL66>:
          if (MSG_OK != r) {
    ae8a:	9c 00 00 00 	cmpa	#0,	r12	;
    ae8e:	32 24       	jz	$+102    	;abs 0xaef4

0000ae90 <.Loc.238.1>:
            idle_len = tf_data_len - tf_idx;
    ae90:	2e 00 68 d6 	mova	&54888,	r14	;0x0d668
    ae94:	00 18 4c 4e 	movx.a	r14,	r12	;
    ae98:	00 18 4c 8a 	subx.a	r10,	r12	;

0000ae9c <.LVL67>:
            if (idle_len < 7) {
    ae9c:	7d 40 06 00 	mov.b	#6,	r13	;
    aea0:	dd 0c       	cmpa	r12,	r13	;
    aea2:	23 2c       	jc	$+72     	;abs 0xaeea

0000aea4 <.Loc.238.1>:
            idle_len = tf_data_len - tf_idx;
    aea4:	61 0c ba 1e 	mova	r12,	&73402	; 0x11eba

0000aea8 <.L70>:
            idle_header[4] = (idle_len - 7) >> 8;
    aea8:	26 01 ba 1e 	mova	&73402,	r6	;0x11eba
    aeac:	89 00 56 d6 	mova	#54870,	r9	;0x0d656
    aeb0:	cc 06       	mova	r6,	r12	;
    aeb2:	ac 0f f9 ff 	adda	#1048569,r12	;0xffff9
    aeb6:	0c 14       	pushm.a	#1,	r12	;20-bit words
    aeb8:	40 18 3c 41 	popx.w	r12		;
    aebc:	40 18 3d 41 	popx.w	r13		;
    aec0:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    aec4:	0d 12       	push	r13		;
    aec6:	0c 12       	push	r12		;
    aec8:	0c 16       	popm.a	#1,	r12	;20-bit words
    aeca:	c9 4c 04 00 	mov.b	r12,	4(r9)	;

0000aece <.Loc.243.1>:
            idle_header[5] = (idle_len - 7) & 0xFF;
    aece:	76 50 f9 ff 	add.b	#-7,	r6	;#0xfff9
    aed2:	c9 46 05 00 	mov.b	r6,	5(r9)	;

0000aed6 <.Loc.244.1>:
            idle_idx = 0;
    aed6:	01 18 c2 43 	movx.a	#0,	&0x11eb6;r3 As==00
    aeda:	b6 1e 

0000aedc <.Loc.245.1>:
            state = FB_STATE_IDLE;
    aedc:	41 18 f2 40 	movx.b	#3,	&0x11ec6;
    aee0:	03 00 c6 1e 

0000aee4 <.Loc.246.1>:
            continue;
    aee4:	59 43       	mov.b	#1,	r9	;r3 As==01
    aee6:	80 00 e0 ad 	mova	#44512,	r0	;0x0ade0

0000aeea <.L69>:
              idle_len += tf_data_len;
    aeea:	ee 0c       	adda	r12,	r14	;
    aeec:	61 0e ba 1e 	mova	r14,	&73402	; 0x11eba
    aef0:	80 00 a8 ae 	mova	#44712,	r0	;0x0aea8

0000aef4 <.L68>:
            pkt_len = elyNLGetLength(active_packet);
    aef4:	2c 01 c2 1e 	mova	&73410,	r12	;0x11ec2

0000aef8 <.LVL70>:
    aef8:	47 13       	calla	r7		;

0000aefa <.LVL71>:
    aefa:	61 0c be 1e 	mova	r12,	&73406	; 0x11ebe
    aefe:	59 43       	mov.b	#1,	r9	;r3 As==01

0000af00 <.L66>:
        tf_buffer[tf_idx++] = active_packet[pkt_idx++];
    af00:	2c 01 b2 1e 	mova	&73394,	r12	;0x11eb2
    af04:	cd 0c       	mova	r12,	r13	;
    af06:	ad 00 01 00 	adda	#1,	r13	;
    af0a:	61 0d b2 1e 	mova	r13,	&73394	; 0x11eb2
    af0e:	80 18 5c 52 	addx.a	&0x11ec2,r12	;
    af12:	c2 1e 
    af14:	41 18 ea 4c 	movx.b	@r12,	66074(r10); 0x1021a
    af18:	1a 02 
    af1a:	aa 00 01 00 	adda	#1,	r10	;

0000af1e <.LVL73>:
        break;
    af1e:	80 00 e0 ad 	mova	#44512,	r0	;0x0ade0

0000af22 <.L62>:
        if (idle_idx < 6) {
    af22:	2c 01 b6 1e 	mova	&73398,	r12	;0x11eb6
    af26:	ce 0a       	mova	r10,	r14	;
    af28:	ae 00 01 00 	adda	#1,	r14	;
    af2c:	aa 01 1a 02 	adda	#66074,	r10	;0x1021a

0000af30 <.LVL74>:
    af30:	7d 40 05 00 	mov.b	#5,	r13	;
    af34:	dd 0c       	cmpa	r12,	r13	;
    af36:	1d 28       	jnc	$+60     	;abs 0xaf72

0000af38 <.LVL75>:
          tf_buffer[tf_idx++] = idle_header[idle_idx++];
    af38:	cd 0c       	mova	r12,	r13	;
    af3a:	ad 00 01 00 	adda	#1,	r13	;
    af3e:	61 0d b6 1e 	mova	r13,	&73398	; 0x11eb6
    af42:	40 18 da 4c 	movx.b	54870(r12),0(r10)	;0x0d656
    af46:	56 d6 00 00 

0000af4a <.L76>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    af4a:	ca 0e       	mova	r14,	r10	;

0000af4c <.LVL76>:
        if (idle_idx == idle_len) {
    af4c:	81 18 d2 92 	cmpx.a	&0x11eba,&0x11eb6;
    af50:	ba 1e b6 1e 
    af54:	45 23       	jnz	$-372    	;abs 0xade0

0000af56 <.Loc.264.1>:
          idle_len = 0;
    af56:	01 18 c2 43 	movx.a	#0,	&0x11eba;r3 As==00
    af5a:	ba 1e 

0000af5c <.Loc.265.1>:
          chEvtWaitAnyTimeout(RFPktAvailable, TIME_IMMEDIATE);
    af5c:	3e 43       	mov	#-1,	r14	;r3 As==11
    af5e:	3c 40 00 04 	mov	#1024,	r12	;#0x0400
    af62:	4d 43       	clr.b	r13		;
    af64:	b0 13 1e 48 	calla	#18462		;0x0481e

0000af68 <.LVL77>:
          state = FB_STATE_UNINIT;
    af68:	41 18 c2 43 	movx.b	#0,	&0x11ec6;r3 As==00
    af6c:	c6 1e 

0000af6e <.Loc.267.1>:
          continue;
    af6e:	80 00 e0 ad 	mova	#44512,	r0	;0x0ade0

0000af72 <.L71>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    af72:	fa 40 aa ff 	mov.b	#-86,	0(r10)	;#0xffaa
    af76:	00 00 

0000af78 <.Loc.260.1>:
          idle_idx++;
    af78:	ac 00 01 00 	adda	#1,	r12	;
    af7c:	61 0c b6 1e 	mova	r12,	&73398	; 0x11eb6
    af80:	80 00 4a af 	mova	#44874,	r0	;0x0af4a

0000af84 <elyRFDLLRxInit>:
void elyRFDLLRxInit(SX1212Driver * devp) {
    af84:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000af86 <.LCFI5>:
    af86:	ca 0c       	mova	r12,	r10	;

0000af88 <.Loc.352.1>:
  sx1212StopReceive(devp);
    af88:	b0 13 06 74 	calla	#29702		;0x07406

0000af8c <.LVL98>:
  sx1212StartReceive(devp, SDLP_TC_PH_LEN, rxfifothresh_callback);
    af8c:	8e 00 f2 aa 	mova	#43762,	r14	;0x0aaf2
    af90:	7d 40 05 00 	mov.b	#5,	r13	;
    af94:	cc 0a       	mova	r10,	r12	;
    af96:	b0 13 cc 72 	calla	#29388		;0x072cc

0000af9a <.LVL99>:
  dll_state = DLL_STATE_HDR;
    af9a:	41 18 c2 43 	movx.b	#0,	&0x11ed5;r3 As==00
    af9e:	d5 1e 

0000afa0 <.Loc.360.1>:
  chEvtSignal(rf_thd, RFSpiAvailable | RFRxIdle);
    afa0:	3d 40 00 60 	mov	#24576,	r13	;#0x6000
    afa4:	4e 43       	clr.b	r14		;
    afa6:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    afaa:	b0 13 c0 47 	calla	#18368		;0x047c0

0000afae <.LVL100>:
}
    afae:	0a 16       	popm.a	#1,	r10	;20-bit words
    afb0:	10 01       	reta			;

0000afb2 <elyRFDLLHandleRxFifo>:
void elyRFDLLHandleRxFifo(SX1212Driver * devp) {
    afb2:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000afb4 <.LCFI6>:
    afb4:	08 14       	pushm.a	#1,	r8	;20-bit words

0000afb6 <.LCFI7>:
    afb6:	06 14       	pushm.a	#1,	r6	;20-bit words

0000afb8 <.LCFI8>:
    afb8:	ca 0c       	mova	r12,	r10	;
    afba:	86 00 62 73 	mova	#29538,	r6	;0x07362

0000afbe <.Loc.365.1>:
  if (dll_state == DLL_STATE_HDR) {
    afbe:	41 18 c2 93 	cmpx.b	#0,	&0x11ed5;r3 As==00
    afc2:	d5 1e 
    afc4:	60 20       	jnz	$+194    	;abs 0xb086

0000afc6 <.Loc.369.1>:
    sx1212FifoRead(devp, SDLP_TC_PH_LEN, tc_hdr_buff);
    afc6:	88 01 d0 1e 	mova	#73424,	r8	;0x11ed0
    afca:	ce 08       	mova	r8,	r14	;
    afcc:	7d 40 05 00 	mov.b	#5,	r13	;
    afd0:	46 13       	calla	r6		;

0000afd2 <.LVL102>:
    if (tc_hdr_buff[0] & 0xCC) {
    afd2:	6c 48       	mov.b	@r8,	r12	;
    afd4:	7c b0 cc ff 	bit.b	#-52,	r12	;#0xffcc
    afd8:	07 24       	jz	$+16     	;abs 0xafe8

0000afda <.L90>:
      elyRFDLLRxInit(devp);
    afda:	cc 0a       	mova	r10,	r12	;
    afdc:	b0 13 84 af 	calla	#44932		;0x0af84

0000afe0 <.L86>:
}
    afe0:	06 16       	popm.a	#1,	r6	;20-bit words
    afe2:	08 16       	popm.a	#1,	r8	;20-bit words
    afe4:	0a 16       	popm.a	#1,	r10	;20-bit words
    afe6:	10 01       	reta			;

0000afe8 <.L88>:
    if (((tc_hdr_buff[0] & 0x03) != (bank0p[RegDLLIDsMSB] & 0x03)) ||
    afe8:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    afec:	5d 4e ca 00 	mov.b	202(r14),r13	;0x000ca
    aff0:	4c ed       	xor.b	r13,	r12	;
    aff2:	3c b0 03 00 	bit	#3,	r12	;
    aff6:	f1 23       	jnz	$-28     	;abs 0xafda

0000aff8 <.Loc.379.1>:
    aff8:	41 18 d2 9e 	cmpx.b	201(r14),&0x11ed1;0x000c9
    affc:	c9 00 d1 1e 
    b000:	ec 23       	jnz	$-38     	;abs 0xafda

0000b002 <.Loc.386.1>:
    if ((tc_hdr_buff[2] & 0xFC) != (bank0p[RegDLLIDsMSB] & 0xFC)) {
    b002:	5c 48 02 00 	mov.b	2(r8),	r12	;
    b006:	4d ec       	xor.b	r12,	r13	;
    b008:	7d b0 fc ff 	bit.b	#-4,	r13	;#0xfffc
    b00c:	e6 23       	jnz	$-50     	;abs 0xafda

0000b00e <.Loc.393.1>:
    rx_pkt_len = (((tc_hdr_buff[2] & 0x03) << 8) | (tc_hdr_buff[3]))+1;
    b00e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b012:	3c f0 00 03 	and	#768,	r12	;#0x0300
    b016:	58 48 03 00 	mov.b	3(r8),	r8	;
    b01a:	0c d8       	bis	r8,	r12	;

0000b01c <.Loc.399.1>:
    rx_pkt_len -= SDLP_TC_PH_LEN;
    b01c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc
    b020:	41 18 82 4c 	movx.w	r12,	&0x11ec8;
    b024:	c8 1e 

0000b026 <.LBB50>:
  _disable_interrupts();
    b026:	32 c2       	dint			
    b028:	03 43       	nop			

0000b02a <.Loc.348.2>:
  asm volatile("nop");
    b02a:	03 43       	nop			

0000b02c <.LBE50>:
    rx_active_buffer = elyNLGetBufferI();
    b02c:	b0 13 ec c2 	calla	#49900		;0x0c2ec

0000b030 <.LVL104>:
    b030:	61 0c cc 1e 	mova	r12,	&73420	; 0x11ecc

0000b034 <.Loc.403.1>:
    if (rx_active_buffer == NULL) {
    b034:	9c 00 00 00 	cmpa	#0,	r12	;
    b038:	d0 27       	jz	$-94     	;abs 0xafda

0000b03a <.Loc.409.1>:
    curr_threshold = (rx_pkt_len < 64 ? rx_pkt_len : 32);
    b03a:	c0 18 1d 42 	movx.w	&0x11ec8,r13	;
    b03e:	c8 1e 
    b040:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    b044:	0c 9d       	cmp	r13,	r12	;
    b046:	02 2c       	jc	$+6      	;abs 0xb04c
    b048:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020

0000b04c <.L91>:
    b04c:	41 18 c2 4d 	movx.b	r13,	&0x11ec7;
    b050:	c7 1e 

0000b052 <.Loc.410.1>:
    rx_idx = 0;
    b052:	41 18 82 43 	movx.w	#0,	&0x11eca;r3 As==00
    b056:	ca 1e 

0000b058 <.Loc.412.1>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    b058:	8e 00 f2 aa 	mova	#43762,	r14	;0x0aaf2
    b05c:	40 18 0d 4d 	movx.w	r13,	r13	;
    b060:	cc 0a       	mova	r10,	r12	;
    b062:	b0 13 9a 72 	calla	#29338		;0x0729a

0000b066 <.LVL105>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    b066:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    b06a:	4e 43       	clr.b	r14		;
    b06c:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    b070:	b0 13 ec 47 	calla	#18412		;0x047ec

0000b074 <.LVL106>:
    dll_state = DLL_STATE_PKT;
    b074:	41 18 d2 43 	movx.b	#1,	&0x11ed5;r3 As==01
    b078:	d5 1e 

0000b07a <.L98>:
  asm volatile("nop");
    b07a:	03 43       	nop			

0000b07c <.Loc.356.2>:
  _enable_interrupts();
    b07c:	03 43       	nop			
    b07e:	32 d2       	eint			
    b080:	03 43       	nop			
    b082:	80 00 e0 af 	mova	#45024,	r0	;0x0afe0

0000b086 <.L87>:
    sx1212FifoRead(devp, curr_threshold, rx_active_buffer + rx_idx);
    b086:	c0 18 1e 42 	movx.w	&0x11eca,r14	;
    b08a:	ca 1e 
    b08c:	80 18 5e 52 	addx.a	&0x11ecc,r14	;
    b090:	cc 1e 
    b092:	c0 18 5f 42 	movx.b	&0x11ec7,r15	;
    b096:	c7 1e 
    b098:	40 18 0d 4f 	movx.w	r15,	r13	;
    b09c:	46 13       	calla	r6		;

0000b09e <.LVL107>:
    rx_idx += curr_threshold;
    b09e:	c0 18 5c 42 	movx.b	&0x11ec7,r12	;
    b0a2:	c7 1e 
    b0a4:	c0 18 1c 52 	addx.w	&0x11eca,r12	;
    b0a8:	ca 1e 
    b0aa:	41 18 82 4c 	movx.w	r12,	&0x11eca;
    b0ae:	ca 1e 

0000b0b0 <.Loc.429.1>:
    if (rx_idx < rx_pkt_len) {
    b0b0:	c0 18 1d 42 	movx.w	&0x11ec8,r13	;
    b0b4:	c8 1e 
    b0b6:	0c 9d       	cmp	r13,	r12	;
    b0b8:	1c 2c       	jc	$+58     	;abs 0xb0f2

0000b0ba <.LBB54>:
  _disable_interrupts();
    b0ba:	32 c2       	dint			
    b0bc:	03 43       	nop			

0000b0be <.Loc.348.2>:
  asm volatile("nop");
    b0be:	03 43       	nop			

0000b0c0 <.LBE54>:
      curr_threshold = (rx_pkt_len < 64 ? rx_pkt_len : 48);
    b0c0:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    b0c4:	0c 9d       	cmp	r13,	r12	;
    b0c6:	02 2c       	jc	$+6      	;abs 0xb0cc
    b0c8:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

0000b0cc <.L93>:
    b0cc:	41 18 c2 4d 	movx.b	r13,	&0x11ec7;
    b0d0:	c7 1e 

0000b0d2 <.Loc.433.1>:
      sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    b0d2:	8e 00 f2 aa 	mova	#43762,	r14	;0x0aaf2
    b0d6:	40 18 0d 4d 	movx.w	r13,	r13	;
    b0da:	cc 0a       	mova	r10,	r12	;
    b0dc:	b0 13 9a 72 	calla	#29338		;0x0729a

0000b0e0 <.LVL108>:
      chEvtSignalI(rf_thd, RFSpiAvailable);
    b0e0:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    b0e4:	4e 43       	clr.b	r14		;
    b0e6:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    b0ea:	b0 13 ec 47 	calla	#18412		;0x047ec

0000b0ee <.LVL109>:
    b0ee:	80 00 7a b0 	mova	#45178,	r0	;0x0b07a

0000b0f2 <.L92>:
      if (!elyNLValidate(rx_active_buffer)) {
    b0f2:	2c 01 cc 1e 	mova	&73420,	r12	;0x11ecc
    b0f6:	b0 13 b0 c4 	calla	#50352		;0x0c4b0

0000b0fa <.LVL110>:
    b0fa:	2e 01 cc 1e 	mova	&73420,	r14	;0x11ecc
    b0fe:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    b100:	05 20       	jnz	$+12     	;abs 0xb10c

0000b102 <.Loc.441.1>:
        elyNLFreeBuffer(rx_active_buffer);
    b102:	cc 0e       	mova	r14,	r12	;
    b104:	b0 13 80 c2 	calla	#49792		;0x0c280

0000b108 <.LVL111>:
        return;
    b108:	80 00 e0 af 	mova	#45024,	r0	;0x0afe0

0000b10c <.L94>:
      RFLastValidPacketTimer = 0;
    b10c:	41 18 82 43 	movx.w	#0,	&0x13964;r3 As==00
    b110:	64 39 
    b112:	41 18 82 43 	movx.w	#0,	&0x13966;r3 As==00
    b116:	66 39 

0000b118 <.Loc.445.1>:
      RFValidPacketFlag = TRUE;
    b118:	40 18 d2 43 	movx.b	#1,	&0xfd769;r3 As==01
    b11c:	69 d7 

0000b11e <.Loc.447.1>:
      elyNLRouteRF(rx_active_buffer);
    b11e:	cc 0e       	mova	r14,	r12	;
    b120:	b0 13 08 c3 	calla	#49928		;0x0c308

0000b124 <.LVL112>:
      elyRFDLLRxInit(devp);
    b124:	cc 0a       	mova	r10,	r12	;
    b126:	b0 13 84 af 	calla	#44932		;0x0af84

0000b12a <.LVL113>:
      chEvtSignal(rf_thd, RFSpiAvailable);
    b12a:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    b12e:	4e 43       	clr.b	r14		;
    b130:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    b134:	b0 13 c0 47 	calla	#18368		;0x047c0

0000b138 <.LVL114>:
    b138:	80 00 e0 af 	mova	#45024,	r0	;0x0afe0

0000b13c <elyRFDLLTxInit>:
  _disable_interrupts();
    b13c:	32 c2       	dint			
    b13e:	03 43       	nop			

0000b140 <.Loc.348.2>:
  asm volatile("nop");
    b140:	03 43       	nop			

0000b142 <.LBE60>:

void elyRFDLLTxInit(SX1278Driver * devp) {
  chSysLock();
  tf_len = ((uint16_t)(bank0p[RegDLLTFLengthMSB] << 8)) | ((uint16_t)(bank0p[RegDLLTFLengthLSB]));
    b142:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b146:	5d 4e c1 00 	mov.b	193(r14),r13	;0x000c1
    b14a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b14e:	5f 4e c0 00 	mov.b	192(r14),r15	;0x000c0
    b152:	0d df       	bis	r15,	r13	;
    b154:	40 18 82 4d 	movx.w	r13,	&0xfd66c;
    b158:	6c d6 

0000b15a <.Loc.488.1>:
  if (bank0p[RegDLLOptions] & BIT5) {
    b15a:	5e 4e c4 00 	mov.b	196(r14),r14	;0x000c4
    b15e:	40 18 3e b0 	bitx.w	#32,	r14	;0x00020
    b162:	20 00 
    b164:	02 24       	jz	$+6      	;abs 0xb16a

0000b166 <.Loc.489.1>:
    tf_data_len = tf_len - 4;
    b166:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc

0000b16a <.L100>:
  }
  else {
    tf_data_len = tf_len;
    b16a:	00 18 c2 4d 	movx.a	r13,	&0xfd668;
    b16e:	68 d6 

0000b170 <.Loc.494.1>:
  }
  if (bank0p[RegDLLOptions] & BIT2) {
    b170:	40 18 2e b2 	bitx.w	#4,	r14	;r2 As==10
    b174:	06 24       	jz	$+14     	;abs 0xb182

0000b176 <.Loc.496.1>:
    /* TODO this depends on the FEC */
    sx1278SetSync(devp, 0x1ACFFC1D);
    b176:	3d 40 1d fc 	mov	#-995,	r13	;#0xfc1d
    b17a:	3e 40 cf 1a 	mov	#6863,	r14	;#0x1acf
    b17e:	b0 13 46 67 	calla	#26438		;0x06746

0000b182 <.L102>:
  asm volatile("nop");
    b182:	03 43       	nop			

0000b184 <.Loc.356.2>:
  _enable_interrupts();
    b184:	03 43       	nop			
    b186:	32 d2       	eint			
    b188:	03 43       	nop			

0000b18a <.LBE62>:
  }
  /* TODO data whitening, FARM */
  chSysUnlock();
}
    b18a:	10 01       	reta			;

0000b18c <elyRFDLLInitiateTransmit>:

void elyRFDLLInitiateTransmit(SX1278Driver * devp) {
    b18c:	b1 00 04 00 	suba	#4,	r1	;

0000b190 <.LCFI9>:
  
#if ELY_DISCRETE_PA_CTL
  palSetLine(LINE_PA_PC_EN);
    b190:	40 18 b2 d0 	bisx.w	#4096,	&0x00222;0x01000
    b194:	00 10 22 02 

0000b198 <.Loc.508.1>:
#endif
  
  transmit_tf_idx = sx1278StartTransmit(devp, tf_len, tf_buffer, txlvl_callback, write_cb);
    b198:	40 18 1d 42 	movx.w	&0x0d66c,r13	;
    b19c:	6c d6 
    b19e:	00 18 f1 40 	movx.a	#43794,	0(r1)	;0x0ab12
    b1a2:	12 ab 00 00 
    b1a6:	8f 00 02 ab 	mova	#43778,	r15	;0x0ab02
    b1aa:	8e 01 1a 02 	mova	#66074,	r14	;0x1021a
    b1ae:	b0 13 12 6a 	calla	#27154		;0x06a12

0000b1b2 <.LVL118>:
    b1b2:	41 18 82 4c 	movx.w	r12,	&0x11ed6;
    b1b6:	d6 1e 

0000b1b8 <.Loc.509.1>:
}
    b1b8:	a1 00 04 00 	adda	#4,	r1	;
    b1bc:	10 01       	reta			;

0000b1be <elyRFDLLHandleTxFifo>:

void elyRFDLLHandleTxFifo(SX1278Driver * devp) {
    b1be:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b1c0 <.LCFI10>:
  /* FIFO is sufficiently empty */
  uint8_t to_transmit = (tf_len - transmit_tf_idx <= 31 ? tf_len - transmit_tf_idx : 31);
    b1c0:	c0 18 1e 42 	movx.w	&0x11ed6,r14	;
    b1c4:	d6 1e 
    b1c6:	40 18 1a 42 	movx.w	&0x0d66c,r10	;
    b1ca:	6c d6 
    b1cc:	0a 8e       	sub	r14,	r10	;
    b1ce:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f
    b1d2:	0d 9a       	cmp	r10,	r13	;
    b1d4:	01 2c       	jc	$+4      	;abs 0xb1d8
    b1d6:	0a 4d       	mov	r13,	r10	;

0000b1d8 <.L108>:
  _disable_interrupts();
    b1d8:	32 c2       	dint			
    b1da:	03 43       	nop			

0000b1dc <.Loc.348.2>:
  asm volatile("nop");
    b1dc:	03 43       	nop			

0000b1de <.LBE68>:
  chSysLock();
  sx1278FifoWriteAsyncS(devp, to_transmit, tf_buffer + transmit_tf_idx, write_cb);
    b1de:	40 18 0e 4e 	movx.w	r14,	r14	;
    b1e2:	8f 00 12 ab 	mova	#43794,	r15	;0x0ab12
    b1e6:	ae 01 1a 02 	adda	#66074,	r14	;0x1021a
    b1ea:	40 18 0d 4a 	movx.w	r10,	r13	;
    b1ee:	b0 13 92 69 	calla	#27026		;0x06992

0000b1f2 <.LVL121>:
  transmit_tf_idx += to_transmit;
    b1f2:	41 18 82 5a 	addx.w	r10,	&0x11ed6;
    b1f6:	d6 1e 

0000b1f8 <.LBB70>:
  asm volatile("nop");
    b1f8:	03 43       	nop			

0000b1fa <.Loc.356.2>:
  _enable_interrupts();
    b1fa:	03 43       	nop			
    b1fc:	32 d2       	eint			
    b1fe:	03 43       	nop			

0000b200 <.LBE70>:
  chSysUnlock();
}
    b200:	0a 16       	popm.a	#1,	r10	;20-bit words
    b202:	10 01       	reta			;

0000b204 <elyRFDLLBuildBeacon>:

void elyRFDLLBuildBeacon(void) {
    b204:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b206 <.LCFI11>:
  size_t tf_idx = SDLP_TM_PH_LEN;

  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) |
    b206:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b20a:	5d 4e ca 00 	mov.b	202(r14),r13	;0x000ca

0000b20e <.Loc.524.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    b20e:	5f 4e c9 00 	mov.b	201(r14),r15	;0x000c9

0000b212 <.Loc.523.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) |
    b212:	8c 01 1a 02 	mova	#66074,	r12	;0x1021a

0000b216 <.Loc.524.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    b216:	0a 4f       	mov	r15,	r10	;
    b218:	5a 0f       	rrum	#4,	r10	;

0000b21a <.Loc.523.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) |
    b21a:	6a dc       	bis.b	@r12,	r10	;
    b21c:	0b 4d       	mov	r13,	r11	;
    b21e:	43 18 0b 5b 	rpt #4 { rlax.w	r11		;
    b222:	7b f0 30 00 	and.b	#48,	r11	;#0x0030
    b226:	4a db       	bis.b	r11,	r10	;
    b228:	cc 4a 00 00 	mov.b	r10,	0(r12)	;

0000b22c <.Loc.525.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    b22c:	43 18 0f 5f 	rpt #4 { rlax.w	r15		;
    b230:	5f dc 01 00 	bis.b	1(r12),	r15	;

0000b234 <.Loc.526.1>:
      ((bank0p[RegDLLIDsMSB] & 0x1C) >> 1));
    b234:	0d 11       	rra	r13		;
    b236:	7d f0 0e 00 	and.b	#14,	r13	;#0x000e

0000b23a <.Loc.525.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    b23a:	4f dd       	bis.b	r13,	r15	;
    b23c:	cc 4f 01 00 	mov.b	r15,	1(r12)	;

0000b240 <.Loc.527.1>:
  tf_buffer[2] = mcfc;
    b240:	40 18 5f 42 	movx.b	&0x0d666,r15	;
    b244:	66 d6 
    b246:	cc 4f 02 00 	mov.b	r15,	2(r12)	;

0000b24a <.Loc.528.1>:
  tf_buffer[3] = vcfc[0];
    b24a:	8a 00 64 d6 	mova	#54884,	r10	;0x0d664
    b24e:	6d 4a       	mov.b	@r10,	r13	;
    b250:	cc 4d 03 00 	mov.b	r13,	3(r12)	;

0000b254 <.Loc.529.1>:
  mcfc++;
    b254:	5f 53       	inc.b	r15		;
    b256:	40 18 c2 4f 	movx.b	r15,	&0xfd666;
    b25a:	66 d6 

0000b25c <.Loc.530.1>:
  vcfc[0]++;
    b25c:	5d 53       	inc.b	r13		;
    b25e:	ca 4d 00 00 	mov.b	r13,	0(r10)	;

0000b262 <.Loc.531.1>:
  tf_buffer[4] &= ~BIT6;
    b262:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    b266:	7d f0 bf ff 	and.b	#-65,	r13	;#0xffbf

0000b26a <.Loc.532.1>:
  tf_buffer[4] |= 0x07;
    b26a:	7d d0 07 00 	bis.b	#7,	r13	;
    b26e:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000b272 <.Loc.533.1>:
  tf_buffer[5] = 0xFE; //FHP should be 11 bits long, all high except bit 0 which should be 0, for idle only frames
    b272:	c1 1f f2 40 	movx.b	#-2,	&0x1021f;0xffffe
    b276:	fe ff 1f 02 

0000b27a <.Loc.535.1>:

  while(tf_idx != tf_data_len)
    b27a:	2a 00 68 d6 	mova	&54888,	r10	;0x0d668

0000b27e <.Loc.521.1>:
  size_t tf_idx = SDLP_TM_PH_LEN;
    b27e:	7c 40 06 00 	mov.b	#6,	r12	;

0000b282 <.L110>:
  while(tf_idx != tf_data_len)
    b282:	dc 0a       	cmpa	r10,	r12	;
    b284:	0c 20       	jnz	$+26     	;abs 0xb29e

0000b286 <.Loc.545.1>:

  /* Finished copying - add the footers */
  if (bank0p[RegDLLOptions] & BIT4) {
    /* TODO add CLCW to OCF */
  }
  if (bank0p[RegDLLTMFEC] & BIT7) {
    b286:	ce 93 c2 00 	cmp.b	#0,	194(r14);r3 As==00, 0x00c2
    b28a:	07 34       	jge	$+16     	;abs 0xb29a

0000b28c <.Loc.547.1>:
    /* add CRC */
    crcGenSDLP(tf_buffer, tf_len); //this may be incorrect, as far as where the crc should be inserted into the frame
    b28c:	40 18 1d 42 	movx.w	&0x0d66c,r13	;
    b290:	6c d6 
    b292:	8c 01 1a 02 	mova	#66074,	r12	;0x1021a

0000b296 <.LVL124>:
    b296:	b0 13 ac aa 	calla	#43692		;0x0aaac

0000b29a <.L109>:
  }
}
    b29a:	0a 16       	popm.a	#1,	r10	;20-bit words
    b29c:	10 01       	reta			;

0000b29e <.L111>:
      tf_buffer[tf_idx] = SDLP_IDLE_DATA;
    b29e:	41 18 fc 40 	movx.b	#85,	66074(r12);0x00055, 0x1021a
    b2a2:	55 00 1a 02 

0000b2a6 <.Loc.538.1>:
      tf_idx++;
    b2a6:	ac 00 01 00 	adda	#1,	r12	;
    b2aa:	80 00 82 b2 	mova	#45698,	r0	;0x0b282

0000b2ae <fram_mpool_alloc>:
static const uint8_t slave_id = 0x50;
static const uint8_t device_select = 0x00;

static PERSIST uint8_t fram_storage[FRAM_REQ_STORAGE];

void * fram_mpool_alloc(size_t size, unsigned align) {
    b2ae:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b2b0 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t PERSIST curr_index = 0;
  
  if (curr_index + size > FRAM_REQ_STORAGE) {
    b2b0:	2e 00 8e d6 	mova	&54926,	r14	;0x0d68e
    b2b4:	ca 0e       	mova	r14,	r10	;
    b2b6:	ea 0c       	adda	r12,	r10	;
    b2b8:	7c 40 48 00 	mov.b	#72,	r12	;#0x0048

0000b2bc <.LVL1>:
    b2bc:	dc 0a       	cmpa	r10,	r12	;
    b2be:	07 28       	jnc	$+16     	;abs 0xb2ce

0000b2c0 <.Loc.18.1>:
    return NULL;
  }

  void * result = fram_storage + curr_index;
    b2c0:	cc 0e       	mova	r14,	r12	;
    b2c2:	ac 00 92 d6 	adda	#54930,	r12	;0x0d692

0000b2c6 <.LVL2>:
  
  curr_index += size;
    b2c6:	60 0a 8e d6 	mova	r10,	&54926	; 0x0d68e

0000b2ca <.L1>:
  return result;
}
    b2ca:	0a 16       	popm.a	#1,	r10	;20-bit words
    b2cc:	10 01       	reta			;

0000b2ce <.L3>:
    return NULL;
    b2ce:	4c 43       	clr.b	r12		;
    b2d0:	80 00 ca b2 	mova	#45770,	r0	;0x0b2ca

0000b2d4 <addr_cb>:
    /* Process next request */
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
  }
}

void addr_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    b2d4:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000b2d6 <.LCFI1>:
    b2d6:	06 14       	pushm.a	#1,	r6	;20-bit words

0000b2d8 <.LCFI2>:
    b2d8:	b1 00 08 00 	suba	#8,	r1	;

0000b2dc <.LCFI3>:
    b2dc:	c8 0c       	mova	r12,	r8	;

0000b2de <.Loc.64.1>:
  (void)(n);
  (void)(buffer);
  fram_req_t * req = active_req;
    b2de:	2c 01 d8 1e 	mova	&73432,	r12	;0x11ed8

0000b2e2 <.LVL5>:
  
  chSysLockFromISR();
  /* TODO put in an assert in here for the Rev A crossing bank boundaries */
  if (req->read) {
    b2e2:	5e 4c 04 00 	mov.b	4(r12),	r14	;

0000b2e6 <.LVL6>:
    b2e6:	4d 4e       	mov.b	r14,	r13	;

0000b2e8 <.LVL7>:
    b2e8:	5d f3       	and.b	#1,	r13	;r3 As==01
    b2ea:	36 0c 08 00 	mova	8(r12),	r6	;
    b2ee:	5a 4c 06 00 	mov.b	6(r12),	r10	;
    b2f2:	59 4c 10 00 	mov.b	16(r12),r9	;0x00010

0000b2f6 <.Loc.71.1>:
    if (req->special) {
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
          req->size, req->buffer, end_cb);
    b2f6:	1c 4c 04 00 	mov	4(r12),	r12	;

0000b2fa <.LVL8>:
  if (req->read) {
    b2fa:	40 18 2e b3 	bitx.w	#2,	r14	;r3 As==10
    b2fe:	37 24       	jz	$+112    	;abs 0xb36e

0000b300 <.Loc.69.1>:
    if (req->special) {
    b300:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    b302:	1c 24       	jz	$+58     	;abs 0xb33c

0000b304 <.Loc.71.1>:
          req->size, req->buffer, end_cb);
    b304:	b0 13 62 d2 	calla	#53858		;0x0d262

0000b308 <.LVL9>:
    b308:	0d 4a       	mov	r10,	r13	;
    b30a:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b30e:	0d dc       	bis	r12,	r13	;
    b310:	81 4d 04 00 	mov	r13,	4(r1)	;
    b314:	5a 07       	rrum	#2,	r10	;
    b316:	5a f3       	and.b	#1,	r10	;r3 As==01
    b318:	81 4a 06 00 	mov	r10,	6(r1)	;

0000b31c <.Loc.70.1>:
      i2cMSP430XStartReceiveToRegI(i2cp, req->device_id,
    b31c:	00 18 f1 40 	movx.a	#46102,	0(r1)	;0x0b416
    b320:	16 b4 00 00 
    b324:	cf 06       	mova	r6,	r15	;
    b326:	3e 01 04 00 	mova	4(r1),	r14	;
    b32a:	4d 49       	mov.b	r9,	r13	;
    b32c:	cc 08       	mova	r8,	r12	;
    b32e:	b0 13 7a 5e 	calla	#24186		;0x05e7a

0000b332 <.L4>:
          req->buffer, end_cb);
    }
  }
  current_callback = req->callback;
  chSysUnlockFromISR();
}
    b332:	a1 00 08 00 	adda	#8,	r1	;
    b336:	06 16       	popm.a	#1,	r6	;20-bit words
    b338:	28 16       	popm.a	#3,	r10	;20-bit words
    b33a:	10 01       	reta			;

0000b33c <.L6>:
      i2cMSP430XStartReceiveI(i2cp, req->device_id, req->size, 
    b33c:	b0 13 62 d2 	calla	#53858		;0x0d262

0000b340 <.LVL12>:
    b340:	0d 4a       	mov	r10,	r13	;
    b342:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b346:	0d dc       	bis	r12,	r13	;
    b348:	81 4d 04 00 	mov	r13,	4(r1)	;
    b34c:	5a 07       	rrum	#2,	r10	;
    b34e:	5a f3       	and.b	#1,	r10	;r3 As==01
    b350:	81 4a 06 00 	mov	r10,	6(r1)	;
    b354:	00 18 f1 40 	movx.a	#46102,	0(r1)	;0x0b416
    b358:	16 b4 00 00 
    b35c:	cf 06       	mova	r6,	r15	;
    b35e:	3e 01 04 00 	mova	4(r1),	r14	;
    b362:	4d 49       	mov.b	r9,	r13	;
    b364:	cc 08       	mova	r8,	r12	;
    b366:	b0 13 3c 5f 	calla	#24380		;0x05f3c

0000b36a <.LVL13>:
    b36a:	80 00 32 b3 	mova	#45874,	r0	;0x0b332

0000b36e <.L5>:
    if (req->special) {
    b36e:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    b370:	19 24       	jz	$+52     	;abs 0xb3a4

0000b372 <.Loc.84.1>:
          req->size, req->buffer, end_cb);
    b372:	b0 13 62 d2 	calla	#53858		;0x0d262

0000b376 <.LVL15>:
    b376:	0d 4a       	mov	r10,	r13	;
    b378:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b37c:	0d dc       	bis	r12,	r13	;
    b37e:	81 4d 04 00 	mov	r13,	4(r1)	;
    b382:	5a 07       	rrum	#2,	r10	;
    b384:	5a f3       	and.b	#1,	r10	;r3 As==01
    b386:	81 4a 06 00 	mov	r10,	6(r1)	;

0000b38a <.Loc.83.1>:
      i2cMSP430XContinueTransmitMemsetI(i2cp, req->device_id,
    b38a:	00 18 f1 40 	movx.a	#46102,	0(r1)	;0x0b416
    b38e:	16 b4 00 00 
    b392:	cf 06       	mova	r6,	r15	;
    b394:	3e 01 04 00 	mova	4(r1),	r14	;
    b398:	4d 49       	mov.b	r9,	r13	;
    b39a:	cc 08       	mova	r8,	r12	;
    b39c:	b0 13 94 60 	calla	#24724		;0x06094

0000b3a0 <.LVL16>:
    b3a0:	80 00 32 b3 	mova	#45874,	r0	;0x0b332

0000b3a4 <.L8>:
      i2cMSP430XContinueTransmitI(i2cp, req->device_id, req->size, 
    b3a4:	b0 13 62 d2 	calla	#53858		;0x0d262

0000b3a8 <.LVL18>:
    b3a8:	0d 4a       	mov	r10,	r13	;
    b3aa:	4d 18 0d 5d 	rpt #14 { rlax.w	r13		;
    b3ae:	0d dc       	bis	r12,	r13	;
    b3b0:	81 4d 04 00 	mov	r13,	4(r1)	;
    b3b4:	5a 07       	rrum	#2,	r10	;
    b3b6:	5a f3       	and.b	#1,	r10	;r3 As==01
    b3b8:	81 4a 06 00 	mov	r10,	6(r1)	;
    b3bc:	00 18 f1 40 	movx.a	#46102,	0(r1)	;0x0b416
    b3c0:	16 b4 00 00 
    b3c4:	cf 06       	mova	r6,	r15	;
    b3c6:	3e 01 04 00 	mova	4(r1),	r14	;
    b3ca:	4d 49       	mov.b	r9,	r13	;
    b3cc:	cc 08       	mova	r8,	r12	;
    b3ce:	b0 13 e8 60 	calla	#24808		;0x060e8

0000b3d2 <.LVL19>:
}
    b3d2:	80 00 32 b3 	mova	#45874,	r0	;0x0b332

0000b3d6 <fram_handle_request>:

/* called from i-class */
void fram_handle_request(fram_req_t * req) {
    b3d6:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b3d8 <.LCFI4>:
    b3d8:	b1 00 04 00 	suba	#4,	r1	;

0000b3dc <.LCFI5>:
    b3dc:	ca 0c       	mova	r12,	r10	;

0000b3de <.Loc.99.1>:
  chDbgAssert(req->address < 0x00020000, "Invalid FRAM address");
  
  active_req = req;
    b3de:	61 0c d8 1e 	mova	r12,	&73432	; 0x11ed8

0000b3e2 <.Loc.102.1>:
  /* Build the 7-bit device address */
  req->device_id = (slave_id | device_select | 
    (req->address >> 16));
    b3e2:	2c 4c       	mov	@r12,	r12	;

0000b3e4 <.LVL21>:
    b3e4:	1d 4a 02 00 	mov	2(r10),	r13	;
    b3e8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b3ec:	b0 13 dc d2 	calla	#53980		;0x0d2dc

0000b3f0 <.Loc.101.1>:
  req->device_id = (slave_id | device_select | 
    b3f0:	4d 4c       	mov.b	r12,	r13	;
    b3f2:	7d d0 50 00 	bis.b	#80,	r13	;#0x0050
    b3f6:	ca 4d 10 00 	mov.b	r13,	16(r10)	; 0x0010

0000b3fa <.Loc.105.1>:
  
  /* Issue a write to set the address */
  i2cMSP430XStartTransmitMSBI(&I2CDB0, req->device_id, 2, 
    b3fa:	00 18 f1 40 	movx.a	#45780,	0(r1)	;0x0b2d4
    b3fe:	d4 b2 00 00 
    b402:	cf 0a       	mova	r10,	r15	;
    b404:	6e 43       	mov.b	#2,	r14	;r3 As==10
    b406:	8c 01 be 14 	mova	#70846,	r12	;0x114be
    b40a:	b0 13 00 60 	calla	#24576		;0x06000

0000b40e <.LVL23>:
      (uint8_t *)(&(req->address)), 
      addr_cb);
}
    b40e:	a1 00 04 00 	adda	#4,	r1	;
    b412:	0a 16       	popm.a	#1,	r10	;20-bit words
    b414:	10 01       	reta			;

0000b416 <end_cb>:
void end_cb(I2CDriver * i2cp, uint8_t * buffer, uint16_t n) {
    b416:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b418 <.LCFI6>:
    b418:	b1 00 04 00 	suba	#4,	r1	;

0000b41c <.LCFI7>:
    b41c:	ca 0d       	mova	r13,	r10	;

0000b41e <.Loc.43.1>:
  i2cMSP430XEndTransferI(i2cp);
    b41e:	b0 13 3e 61 	calla	#24894		;0x0613e

0000b422 <.LVL25>:
  fram_read_idx++;
    b422:	40 18 d2 53 	incx.b	&0xd67c		;
    b426:	7c d6 

0000b428 <.Loc.47.1>:
  chPoolFreeI(&fram_mpool, active_req);
    b428:	2d 01 d8 1e 	mova	&73432,	r13	;0x11ed8
    b42c:	8c 00 70 d6 	mova	#54896,	r12	;0x0d670
    b430:	b0 13 0e 4a 	calla	#18958		;0x04a0e

0000b434 <.LVL26>:
  chSemSignalI(&fram_pool_sem);
    b434:	8c 00 6e d6 	mova	#54894,	r12	;0x0d66e
    b438:	b0 13 8e 47 	calla	#18318		;0x0478e

0000b43c <.LVL27>:
  if (active_req->callback) {
    b43c:	2c 01 d8 1e 	mova	&73432,	r12	;0x11ed8
    b440:	3e 0c 0c 00 	mova	12(r12),r14	;0x0000c
    b444:	9e 00 00 00 	cmpa	#0,	r14	;
    b448:	02 24       	jz	$+6      	;abs 0xb44e

0000b44a <.Loc.52.1>:
    active_req->callback(buffer);
    b44a:	cc 0a       	mova	r10,	r12	;
    b44c:	4e 13       	calla	r14		;

0000b44e <.L11>:
  if (!QUEUE_EMPTY()) {
    b44e:	40 18 5c 42 	movx.b	&0x0d67c,r12	;
    b452:	7c d6 
    b454:	40 18 c2 9c 	cmpx.b	r12,	&0xfd67d;
    b458:	7d d6 
    b45a:	13 24       	jz	$+40     	;abs 0xb482

0000b45c <.Loc.57.1>:
    fram_handle_request(fram_mbox_buffer[QUEUE_MASK(fram_read_idx)]);
    b45c:	7c f0 03 00 	and.b	#3,	r12	;
    b460:	0d 43       	clr	r13		;
    b462:	0e 4c       	mov	r12,	r14	;
    b464:	0f 4d       	mov	r13,	r15	;
    b466:	0e 5e       	rla	r14		;
    b468:	0f 6f       	rlc	r15		;
    b46a:	0e 5e       	rla	r14		;
    b46c:	0f 6f       	rlc	r15		;
    b46e:	81 4e 00 00 	mov	r14,	0(r1)	;
    b472:	81 4f 02 00 	mov	r15,	2(r1)	;
    b476:	0d 01       	mova	@r1,	r13	;
    b478:	00 18 5c 4d 	movx.a	54910(r13),r12	;0x0d67e
    b47c:	7e d6 
    b47e:	b0 13 d6 b3 	calla	#46038		;0x0b3d6

0000b482 <.L10>:
}
    b482:	a1 00 04 00 	adda	#4,	r1	;
    b486:	0a 16       	popm.a	#1,	r10	;20-bit words
    b488:	10 01       	reta			;

0000b48a <elyFramPostRequestI>:

void elyFramPostRequestI(fram_req_t * req) {
    b48a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b48c <.LCFI8>:
    b48c:	b1 00 04 00 	suba	#4,	r1	;

0000b490 <.LCFI9>:
  chDbgCheckClassI();
  
  /* We should never hit this if we've managed to get a request in the first place */
  chDbgAssert(!QUEUE_FULL(), "internal buffer overflows should be impossible");
  
  fram_mbox_buffer[QUEUE_MASK(fram_write_idx++)] = req;
    b490:	40 18 5e 42 	movx.b	&0x0d67d,r14	;
    b494:	7d d6 
    b496:	4a 4e       	mov.b	r14,	r10	;
    b498:	5a 53       	inc.b	r10		;
    b49a:	40 18 c2 4a 	movx.b	r10,	&0xfd67d;
    b49e:	7d d6 
    b4a0:	7e f0 03 00 	and.b	#3,	r14	;
    b4a4:	0f 43       	clr	r15		;
    b4a6:	0a 4e       	mov	r14,	r10	;
    b4a8:	0b 4f       	mov	r15,	r11	;
    b4aa:	0a 5a       	rla	r10		;
    b4ac:	0b 6b       	rlc	r11		;
    b4ae:	0a 5a       	rla	r10		;
    b4b0:	0b 6b       	rlc	r11		;
    b4b2:	81 4a 00 00 	mov	r10,	0(r1)	;
    b4b6:	81 4b 02 00 	mov	r11,	2(r1)	;
    b4ba:	0a 01       	mova	@r1,	r10	;
    b4bc:	00 18 ca 4c 	movx.a	r12,	-10626(r10); 0xfd67e
    b4c0:	7e d6 

0000b4c2 <.Loc.117.1>:
}
    b4c2:	a1 00 04 00 	adda	#4,	r1	;
    b4c6:	0a 16       	popm.a	#1,	r10	;20-bit words
    b4c8:	10 01       	reta			;

0000b4ca <elyFramPostRequestS>:

void elyFramPostRequestS(fram_req_t * req) {
    b4ca:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b4cc <.LCFI10>:
    b4cc:	ca 0c       	mova	r12,	r10	;
    b4ce:	8e 00 8a b4 	mova	#46218,	r14	;0x0b48a

0000b4d2 <.Loc.122.1>:
  chDbgCheckClassS();
  
  if (QUEUE_EMPTY()) {
    b4d2:	40 18 d2 92 	cmpx.b	&0x0d67c,&0xfd67d;
    b4d6:	7c d6 7d d6 
    b4da:	06 20       	jnz	$+14     	;abs 0xb4e8

0000b4dc <.Loc.123.1>:
    elyFramPostRequestI(req);
    b4dc:	4e 13       	calla	r14		;

0000b4de <.LVL32>:
    fram_handle_request(req);
    b4de:	cc 0a       	mova	r10,	r12	;
    b4e0:	b0 13 d6 b3 	calla	#46038		;0x0b3d6

0000b4e4 <.L17>:
  }
  else {
    elyFramPostRequestI(req);
  }
}
    b4e4:	0a 16       	popm.a	#1,	r10	;20-bit words
    b4e6:	10 01       	reta			;

0000b4e8 <.L18>:
    elyFramPostRequestI(req);
    b4e8:	4e 13       	calla	r14		;

0000b4ea <.LVL34>:
}
    b4ea:	80 00 e4 b4 	mova	#46308,	r0	;0x0b4e4

0000b4ee <elyFramGetRequestTimeoutS>:
  (*reqp)->special = 0;
  
  return MSG_OK;
}

msg_t elyFramGetRequestTimeoutS(fram_req_t ** reqp, systime_t timeout) {
    b4ee:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b4f0 <.LCFI12>:
    b4f0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b4f2 <.LCFI13>:
    b4f2:	ca 0c       	mova	r12,	r10	;

0000b4f4 <.Loc.152.1>:
  chDbgCheckClassS();
  
  msg_t r = chSemWaitTimeoutS(&fram_pool_sem, timeout);
    b4f4:	8c 00 6e d6 	mova	#54894,	r12	;0x0d66e

0000b4f8 <.LVL42>:
    b4f8:	b0 13 52 47 	calla	#18258		;0x04752

0000b4fc <.LVL43>:
    b4fc:	c8 0c       	mova	r12,	r8	;

0000b4fe <.Loc.153.1>:
  if (MSG_OK != r) {
    b4fe:	9c 00 00 00 	cmpa	#0,	r12	;
    b502:	08 20       	jnz	$+18     	;abs 0xb514

0000b504 <.Loc.157.1>:
    return r;
  }
  
  (*reqp) = (fram_req_t *)(chPoolAllocI(&fram_mpool));
    b504:	8c 00 70 d6 	mova	#54896,	r12	;0x0d670
    b508:	b0 13 ce 49 	calla	#18894		;0x049ce

0000b50c <.LVL45>:
    b50c:	7a 0c 00 00 	mova	r12,	0(r10)	;

0000b510 <.Loc.159.1>:
  chDbgAssert( (*reqp) != NULL, "internal pool overflow should be impossible");
  (*reqp)->special = 0;
    b510:	dc c3 04 00 	bic.b	#1,	4(r12)	;r3 As==01

0000b514 <.L23>:
  return r;
}
    b514:	cc 08       	mova	r8,	r12	;
    b516:	08 16       	popm.a	#1,	r8	;20-bit words
    b518:	0a 16       	popm.a	#1,	r10	;20-bit words
    b51a:	10 01       	reta			;

0000b51c <elyFramInit>:

  
void elyFramInit() {
  chDbgAssert((FRAM_QUEUE_LEN & (FRAM_QUEUE_LEN -1)) == 0, 
      "queue length must be power of 2");
  i2cStart(&I2CDB0, &cfg);
    b51c:	8d 01 1a 0a 	mova	#68122,	r13	;0x10a1a
    b520:	8c 01 be 14 	mova	#70846,	r12	;0x114be
    b524:	b0 13 a6 50 	calla	#20646		;0x050a6

0000b528 <.LVL46>:
}
    b528:	10 01       	reta			;

0000b52a <port_lock>:
  _disable_interrupts();
    b52a:	32 c2       	dint			
    b52c:	03 43       	nop			

0000b52e <.Loc.348.1>:
  asm volatile("nop");
    b52e:	03 43       	nop			

0000b530 <.Loc.349.1>:
}
    b530:	10 01       	reta			;

0000b532 <port_unlock>:
  asm volatile("nop");
    b532:	03 43       	nop			

0000b534 <.Loc.356.1>:
  _enable_interrupts();
    b534:	03 43       	nop			
    b536:	32 d2       	eint			
    b538:	03 43       	nop			

0000b53a <.Loc.357.1>:
}
    b53a:	10 01       	reta			;

0000b53c <elyRFPostI>:
static const rf_events_t AllRfEvents = 0x2FFFF;
static const rf_events_t RFTxCfgMask = 0x155;
static const rf_events_t RFRxCfgMask = 0xAA;
static eventmask_t events;

msg_t elyRFPostI(uint8_t * buffer) {
    b53c:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b53e <.LCFI0>:
  msg_t msg;
  msg = chMBPostI(&rf_mbox, (msg_t)(buffer));
    b53e:	cd 0c       	mova	r12,	r13	;
    b540:	8c 01 1e 0a 	mova	#68126,	r12	;0x10a1e

0000b544 <.LVL1>:
    b544:	b0 13 ea 48 	calla	#18666		;0x048ea

0000b548 <.LVL2>:
    b548:	ca 0c       	mova	r12,	r10	;

0000b54a <.Loc.21.2>:
  if (MSG_OK == msg) {
    b54a:	9c 00 00 00 	cmpa	#0,	r12	;
    b54e:	07 20       	jnz	$+16     	;abs 0xb55e

0000b550 <.Loc.22.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    b550:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    b554:	4e 43       	clr.b	r14		;
    b556:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    b55a:	b0 13 ec 47 	calla	#18412		;0x047ec

0000b55e <.L3>:
  }
  return msg;
}
    b55e:	cc 0a       	mova	r10,	r12	;
    b560:	0a 16       	popm.a	#1,	r10	;20-bit words
    b562:	10 01       	reta			;

0000b564 <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
    b564:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000b566 <.LCFI1>:
    b566:	ca 0c       	mova	r12,	r10	;
    b568:	09 4d       	mov	r13,	r9	;

0000b56a <.Loc.29.2>:
  msg_t msg;
  chSysLock();
    b56a:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b56e <.LVL6>:
  msg = chMBPostS(&rf_mbox, (msg_t)(buffer), timeout);
    b56e:	0e 49       	mov	r9,	r14	;
    b570:	cd 0a       	mova	r10,	r13	;
    b572:	8c 01 1e 0a 	mova	#68126,	r12	;0x10a1e
    b576:	b0 13 82 48 	calla	#18562		;0x04882

0000b57a <.LVL7>:
    b57a:	ca 0c       	mova	r12,	r10	;

0000b57c <.LVL8>:
  if (MSG_OK == msg) {
    b57c:	9c 00 00 00 	cmpa	#0,	r12	;
    b580:	07 20       	jnz	$+16     	;abs 0xb590

0000b582 <.Loc.32.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    b582:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    b586:	4e 43       	clr.b	r14		;
    b588:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    b58c:	b0 13 ec 47 	calla	#18412		;0x047ec

0000b590 <.L6>:
  }
  chSysUnlock();
    b590:	b0 13 32 b5 	calla	#46386		;0x0b532

0000b594 <.LVL10>:
  return msg;
}
    b594:	cc 0a       	mova	r10,	r12	;
    b596:	19 16       	popm.a	#2,	r10	;20-bit words
    b598:	10 01       	reta			;

0000b59a <elyRFCfgMarkDirty>:

void elyRFCfgMarkDirty(rf_events_t event) {
  chDbgAssert(chThdGetSelfX() != rf_thd, "can't set your own config dirty");
  chDbgAssert(event & RFCfgMask, "invalid event");
  
  chEvtSignal(rf_thd, event);
    b59a:	0e 4d       	mov	r13,	r14	;
    b59c:	0d 4c       	mov	r12,	r13	;
    b59e:	2c 01 24 21 	mova	&74020,	r12	;0x12124

0000b5a2 <.LVL15>:
    b5a2:	b0 13 c0 47 	calla	#18368		;0x047c0

0000b5a6 <.LVL16>:
}
    b5a6:	10 01       	reta			;

0000b5a8 <elyRFChangeTxFreqS>:
static eventmask_t get_next_event(eventmask_t mask) {
  mask ^= mask & (mask - (eventmask_t)1);
  return mask;
}

void __attribute__((weak)) elyRFChangeTxFreqS(SX1278Config * cfg) {
    b5a8:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b5aa <.LCFI2>:
    b5aa:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b5ac <.LCFI3>:
    b5ac:	ca 0c       	mova	r12,	r10	;

0000b5ae <.Loc.58.2>:
  chSysLock();
    b5ae:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b5b2 <.LVL18>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    b5b2:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b5b6:	5d 4e 01 00 	mov.b	1(r14),	r13	;
    b5ba:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b5be:	6c 4e       	mov.b	@r14,	r12	;
    b5c0:	0d dc       	bis	r12,	r13	;
    b5c2:	5c 4e 03 00 	mov.b	3(r14),	r12	;
    b5c6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b5ca:	5e 4e 02 00 	mov.b	2(r14),	r14	;
    b5ce:	0c de       	bis	r14,	r12	;

0000b5d0 <.Loc.63.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  if (cfg->freq > TX_BAND_MAX) {
    b5d0:	3e 40 ec 38 	mov	#14572,	r14	;#0x38ec
    b5d4:	0e 9c       	cmp	r12,	r14	;
    b5d6:	4b 28       	jnc	$+152    	;abs 0xb66e
    b5d8:	0c 9e       	cmp	r14,	r12	;
    b5da:	04 20       	jnz	$+10     	;abs 0xb5e4
    b5dc:	3e 40 c0 24 	mov	#9408,	r14	;#0x24c0
    b5e0:	0e 9d       	cmp	r13,	r14	;
    b5e2:	45 28       	jnc	$+140    	;abs 0xb66e

0000b5e4 <.L15>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    b5e4:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    b5e8:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000b5ec <.L12>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < TX_BAND_MIN) {
    b5ec:	3c 40 8e 33 	mov	#13198,	r12	;#0x338e
    b5f0:	1c 9a 0e 00 	cmp	14(r10),r12	;0x0000e
    b5f4:	2f 28       	jnc	$+96     	;abs 0xb654
    b5f6:	8a 9c 0e 00 	cmp	r12,	14(r10)	; 0x000e
    b5fa:	05 20       	jnz	$+12     	;abs 0xb606
    b5fc:	3e 40 3f da 	mov	#-9665,	r14	;#0xda3f
    b600:	1e 9a 0c 00 	cmp	12(r10),r14	;0x0000c
    b604:	27 28       	jnc	$+80     	;abs 0xb654

0000b606 <.L16>:
    cfg->freq = TX_BAND_MIN;
    b606:	ba 40 40 da 	mov	#-9664,	12(r10)	;#0xda40, 0x000c
    b60a:	0c 00 
    b60c:	ba 40 8e 33 	mov	#13198,	14(r10)	;#0x338e, 0x000e
    b610:	0e 00 

0000b612 <.Loc.72.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    b612:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b616:	f8 40 40 00 	mov.b	#64,	0(r8)	;#0x0040
    b61a:	00 00 

0000b61c <.Loc.73.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b61c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b620:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b624:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b628:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000b62c <.Loc.74.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b62c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b630:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b634:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b638:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b63c:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000b640 <.Loc.75.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    b640:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b644:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b648:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b64c:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b650:	c8 4c 03 00 	mov.b	r12,	3(r8)	;

0000b654 <.L13>:
  }
  chSysUnlock();
    b654:	b0 13 32 b5 	calla	#46386		;0x0b532

0000b658 <.LVL22>:
  
  /* This is pretty fast */
  sx1278SetFrequency(&SX1278D1, cfg->freq);
    b658:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    b65c:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    b660:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    b664:	b0 13 72 66 	calla	#26226		;0x06672

0000b668 <.LVL23>:
}
    b668:	08 16       	popm.a	#1,	r8	;20-bit words
    b66a:	0a 16       	popm.a	#1,	r10	;20-bit words
    b66c:	10 01       	reta			;

0000b66e <.L10>:
    cfg->freq = TX_BAND_MAX;
    b66e:	ba 40 c0 24 	mov	#9408,	12(r10)	;#0x24c0, 0x000c
    b672:	0c 00 
    b674:	ba 40 ec 38 	mov	#14572,	14(r10)	;#0x38ec, 0x000e
    b678:	0e 00 

0000b67a <.Loc.65.2>:
    bank0w[RegTXFreqLsb] = (cfg->freq & 0xFF);
    b67a:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b67e:	f8 40 c0 ff 	mov.b	#-64,	0(r8)	;#0xffc0
    b682:	00 00 

0000b684 <.Loc.66.2>:
    bank0w[RegTXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b684:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b688:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b68c:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b690:	c8 4c 01 00 	mov.b	r12,	1(r8)	;

0000b694 <.Loc.67.2>:
    bank0w[RegTXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b694:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b698:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b69c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b6a0:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b6a4:	c8 4c 02 00 	mov.b	r12,	2(r8)	;

0000b6a8 <.Loc.68.2>:
    bank0w[RegTXFreqMsb] = (cfg->freq >> 24);
    b6a8:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b6ac:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b6b0:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b6b4:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b6b8:	c8 4c 03 00 	mov.b	r12,	3(r8)	;
    b6bc:	80 00 ec b5 	mova	#46572,	r0	;0x0b5ec

0000b6c0 <elyRFChangeRxFreqS>:

void __attribute__((weak)) elyRFChangeRxFreqS(SX1212Config * cfg) {
    b6c0:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b6c2 <.LCFI4>:
    b6c2:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b6c4 <.LCFI5>:
    b6c4:	ca 0c       	mova	r12,	r10	;

0000b6c6 <.Loc.84.2>:
  chSysLock();
    b6c6:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b6ca <.LVL28>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    b6ca:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b6ce:	5d 4e 05 00 	mov.b	5(r14),	r13	;
    b6d2:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b6d6:	5c 4e 04 00 	mov.b	4(r14),	r12	;
    b6da:	0d dc       	bis	r12,	r13	;
    b6dc:	5c 4e 07 00 	mov.b	7(r14),	r12	;
    b6e0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b6e4:	5e 4e 06 00 	mov.b	6(r14),	r14	;
    b6e8:	0c de       	bis	r14,	r12	;

0000b6ea <.Loc.89.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  if (cfg->freq > RX_BAND_MAX) {
    b6ea:	3e 40 12 1c 	mov	#7186,	r14	;#0x1c12
    b6ee:	0e 9c       	cmp	r12,	r14	;
    b6f0:	4b 28       	jnc	$+152    	;abs 0xb788
    b6f2:	0c 9e       	cmp	r14,	r12	;
    b6f4:	04 20       	jnz	$+10     	;abs 0xb6fe
    b6f6:	3e 40 c0 e3 	mov	#-7232,	r14	;#0xe3c0
    b6fa:	0e 9d       	cmp	r13,	r14	;
    b6fc:	45 28       	jnc	$+140    	;abs 0xb788

0000b6fe <.L23>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    b6fe:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    b702:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000b706 <.L20>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
  }
  if (cfg->freq < RX_BAND_MIN) {
    b706:	3c 40 3d 1b 	mov	#6973,	r12	;#0x1b3d
    b70a:	1c 9a 12 00 	cmp	18(r10),r12	;0x00012
    b70e:	2f 28       	jnc	$+96     	;abs 0xb76e
    b710:	8a 9c 12 00 	cmp	r12,	18(r10)	; 0x0012
    b714:	05 20       	jnz	$+12     	;abs 0xb720
    b716:	3e 40 3f 44 	mov	#17471,	r14	;#0x443f
    b71a:	1e 9a 10 00 	cmp	16(r10),r14	;0x00010
    b71e:	27 28       	jnc	$+80     	;abs 0xb76e

0000b720 <.L24>:
    cfg->freq = RX_BAND_MIN;
    b720:	ba 40 40 44 	mov	#17472,	16(r10)	;#0x4440, 0x0010
    b724:	10 00 
    b726:	ba 40 3d 1b 	mov	#6973,	18(r10)	;#0x1b3d, 0x0012
    b72a:	12 00 

0000b72c <.Loc.98.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    b72c:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b730:	f8 40 40 00 	mov.b	#64,	4(r8)	;#0x0040
    b734:	04 00 

0000b736 <.Loc.99.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b736:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b73a:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b73e:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b742:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000b746 <.Loc.100.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b746:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b74a:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b74e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b752:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b756:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000b75a <.Loc.101.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    b75a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b75e:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b762:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b766:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b76a:	c8 4c 07 00 	mov.b	r12,	7(r8)	;

0000b76e <.L21>:
  }
  chSysUnlock();
    b76e:	b0 13 32 b5 	calla	#46386		;0x0b532

0000b772 <.LVL32>:
  
  /* This is INCREDIBLY slow */
  sx1212SetFrequency(&SX1212D1, cfg->freq);
    b772:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    b776:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    b77a:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    b77e:	b0 13 da 6d 	calla	#28122		;0x06dda

0000b782 <.LVL33>:
}
    b782:	08 16       	popm.a	#1,	r8	;20-bit words
    b784:	0a 16       	popm.a	#1,	r10	;20-bit words
    b786:	10 01       	reta			;

0000b788 <.L18>:
    cfg->freq = RX_BAND_MAX;
    b788:	ba 40 c0 e3 	mov	#-7232,	16(r10)	;#0xe3c0, 0x0010
    b78c:	10 00 
    b78e:	ba 40 12 1c 	mov	#7186,	18(r10)	;#0x1c12, 0x0012
    b792:	12 00 

0000b794 <.Loc.91.2>:
    bank0w[RegRXFreqLsb] = (cfg->freq & 0xFF);
    b794:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b798:	f8 40 c0 ff 	mov.b	#-64,	4(r8)	;#0xffc0
    b79c:	04 00 

0000b79e <.Loc.92.2>:
    bank0w[RegRXFreqLmb] = ((cfg->freq >> 8) & 0xFF);
    b79e:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b7a2:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b7a6:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b7aa:	c8 4c 05 00 	mov.b	r12,	5(r8)	;

0000b7ae <.Loc.93.2>:
    bank0w[RegRXFreqHmb] = ((cfg->freq >> 16) & 0xFF);
    b7ae:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b7b2:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b7b6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b7ba:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b7be:	c8 4c 06 00 	mov.b	r12,	6(r8)	;

0000b7c2 <.Loc.94.2>:
    bank0w[RegRXFreqMsb] = (cfg->freq >> 24);
    b7c2:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    b7c6:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    b7ca:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b7ce:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b7d2:	c8 4c 07 00 	mov.b	r12,	7(r8)	;
    b7d6:	80 00 06 b7 	mova	#46854,	r0	;0x0b706

0000b7da <elyRFChangeTxBRS>:

void __attribute__((weak)) elyRFChangeTxBRS(SX1278Config * cfg) {
    b7da:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b7dc <.LCFI6>:
    b7dc:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b7de <.LCFI7>:
    b7de:	ca 0c       	mova	r12,	r10	;

0000b7e0 <.Loc.110.2>:
  chSysLock();
    b7e0:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b7e4 <.LVL38>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    b7e4:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b7e8:	5d 4e 19 00 	mov.b	25(r14),r13	;0x00019
    b7ec:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b7f0:	5c 4e 18 00 	mov.b	24(r14),r12	;0x00018
    b7f4:	0d dc       	bis	r12,	r13	;
    b7f6:	5c 4e 1b 00 	mov.b	27(r14),r12	;0x0001b
    b7fa:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b7fe:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x0001a
    b802:	0c de       	bis	r14,	r12	;

0000b804 <.Loc.115.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  if (cfg->bitrate > TX_BR_MAX) {
    b804:	6e 42       	mov.b	#4,	r14	;r2 As==10
    b806:	0e 9c       	cmp	r12,	r14	;
    b808:	45 28       	jnc	$+140    	;abs 0xb894
    b80a:	0c 9e       	cmp	r14,	r12	;
    b80c:	04 20       	jnz	$+10     	;abs 0xb816
    b80e:	3e 40 e0 93 	mov	#-27680,r14	;#0x93e0
    b812:	0e 9d       	cmp	r13,	r14	;
    b814:	3f 28       	jnc	$+128    	;abs 0xb894

0000b816 <.L31>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    b816:	8a 4d 08 00 	mov	r13,	8(r10)	;
    b81a:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000b81e <.L28>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < TX_BR_MIN) {
    b81e:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    b822:	2b 20       	jnz	$+88     	;abs 0xb87a
    b824:	3c 40 af 04 	mov	#1199,	r12	;#0x04af
    b828:	1c 9a 08 00 	cmp	8(r10),	r12	;
    b82c:	26 28       	jnc	$+78     	;abs 0xb87a

0000b82e <.Loc.123.2>:
    cfg->bitrate = TX_BR_MIN;
    b82e:	ba 40 b0 04 	mov	#1200,	8(r10)	;#0x04b0
    b832:	08 00 
    b834:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000b838 <.Loc.124.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b838:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b83c:	f8 40 b0 ff 	mov.b	#-80,	24(r8)	;#0xffb0, 0x0018
    b840:	18 00 

0000b842 <.Loc.125.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b842:	1c 4a 08 00 	mov	8(r10),	r12	;
    b846:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b84a:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b84e:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b852 <.Loc.126.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b852:	1c 4a 08 00 	mov	8(r10),	r12	;
    b856:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b85a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b85e:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b862:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b866 <.Loc.127.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b866:	1c 4a 08 00 	mov	8(r10),	r12	;
    b86a:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b86e:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b872:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b876:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b

0000b87a <.L29>:
  }
  chSysUnlock();
    b87a:	b0 13 32 b5 	calla	#46386		;0x0b532

0000b87e <.LVL42>:
  
  /* This is fast */
  sx1278SetBitrate(&SX1278D1, cfg->bitrate);
    b87e:	1d 4a 08 00 	mov	8(r10),	r13	;
    b882:	1e 4a 0a 00 	mov	10(r10),r14	;0x0000a
    b886:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    b88a:	b0 13 ee 65 	calla	#26094		;0x065ee

0000b88e <.LVL43>:
}
    b88e:	08 16       	popm.a	#1,	r8	;20-bit words
    b890:	0a 16       	popm.a	#1,	r10	;20-bit words
    b892:	10 01       	reta			;

0000b894 <.L26>:
    cfg->bitrate = TX_BR_MAX;
    b894:	ba 40 e0 93 	mov	#-27680,8(r10)	;#0x93e0
    b898:	08 00 
    b89a:	aa 42 0a 00 	mov	#4,	10(r10)	;r2 As==10, 0x000a

0000b89e <.Loc.117.2>:
    bank0w[RegTXBRLsb] = (cfg->bitrate & 0xFF);
    b89e:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b8a2:	f8 40 e0 ff 	mov.b	#-32,	24(r8)	;#0xffe0, 0x0018
    b8a6:	18 00 

0000b8a8 <.Loc.118.2>:
    bank0w[RegTXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b8a8:	1c 4a 08 00 	mov	8(r10),	r12	;
    b8ac:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b8b0:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b8b4:	c8 4c 19 00 	mov.b	r12,	25(r8)	; 0x0019

0000b8b8 <.Loc.119.2>:
    bank0w[RegTXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b8b8:	1c 4a 08 00 	mov	8(r10),	r12	;
    b8bc:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b8c0:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b8c4:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b8c8:	c8 4c 1a 00 	mov.b	r12,	26(r8)	; 0x001a

0000b8cc <.Loc.120.2>:
    bank0w[RegTXBRMsb] = (cfg->bitrate >> 24);
    b8cc:	1c 4a 08 00 	mov	8(r10),	r12	;
    b8d0:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    b8d4:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b8d8:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b8dc:	c8 4c 1b 00 	mov.b	r12,	27(r8)	; 0x001b
    b8e0:	80 00 1e b8 	mova	#47134,	r0	;0x0b81e

0000b8e4 <elyRFChangeRxBRS>:

void __attribute__((weak)) elyRFChangeRxBRS(SX1212Config * cfg) {
    b8e4:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b8e6 <.LCFI8>:
    b8e6:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b8e8 <.LCFI9>:
    b8e8:	ca 0c       	mova	r12,	r10	;

0000b8ea <.Loc.136.2>:
  chSysLock();
    b8ea:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b8ee <.LVL48>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    b8ee:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b8f2:	5d 4e 1d 00 	mov.b	29(r14),r13	;0x0001d
    b8f6:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    b8fa:	5c 4e 1c 00 	mov.b	28(r14),r12	;0x0001c
    b8fe:	0d dc       	bis	r12,	r13	;
    b900:	5c 4e 1f 00 	mov.b	31(r14),r12	;0x0001f
    b904:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    b908:	5e 4e 1e 00 	mov.b	30(r14),r14	;0x0001e
    b90c:	0c de       	bis	r14,	r12	;

0000b90e <.Loc.141.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  if (cfg->bitrate > RX_BR_MAX) {
    b90e:	6e 43       	mov.b	#2,	r14	;r3 As==10
    b910:	0e 9c       	cmp	r12,	r14	;
    b912:	45 28       	jnc	$+140    	;abs 0xb99e
    b914:	0c 9e       	cmp	r14,	r12	;
    b916:	04 20       	jnz	$+10     	;abs 0xb920
    b918:	3e 40 f0 49 	mov	#18928,	r14	;#0x49f0
    b91c:	0e 9d       	cmp	r13,	r14	;
    b91e:	3f 28       	jnc	$+128    	;abs 0xb99e

0000b920 <.L39>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
    b920:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    b924:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000b928 <.L36>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
  }
  if (cfg->bitrate < RX_BR_MIN) {
    b928:	8a 93 0e 00 	cmp	#0,	14(r10)	;r3 As==00, 0x000e
    b92c:	2b 20       	jnz	$+88     	;abs 0xb984
    b92e:	3c 40 0b 03 	mov	#779,	r12	;#0x030b
    b932:	1c 9a 0c 00 	cmp	12(r10),r12	;0x0000c
    b936:	26 28       	jnc	$+78     	;abs 0xb984

0000b938 <.Loc.149.2>:
    cfg->bitrate = RX_BR_MIN;
    b938:	ba 40 0c 03 	mov	#780,	12(r10)	;#0x030c, 0x000c
    b93c:	0c 00 
    b93e:	8a 43 0e 00 	mov	#0,	14(r10)	;r3 As==00, 0x000e

0000b942 <.Loc.150.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b942:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b946:	f8 40 0c 00 	mov.b	#12,	28(r8)	;#0x000c, 0x001c
    b94a:	1c 00 

0000b94c <.Loc.151.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b94c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b950:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b954:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b958:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b95c <.Loc.152.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b95c:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b960:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b964:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b968:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b96c:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b970 <.Loc.153.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b970:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b974:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b978:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b97c:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b980:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f

0000b984 <.L37>:
  }
  chSysUnlock();
    b984:	b0 13 32 b5 	calla	#46386		;0x0b532

0000b988 <.LVL52>:
  
  /* This is only moderately slow */
  sx1212SetBitrate(&SX1212D1, cfg->bitrate);
    b988:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    b98c:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    b990:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    b994:	b0 13 c2 6c 	calla	#27842		;0x06cc2

0000b998 <.LVL53>:
}
    b998:	08 16       	popm.a	#1,	r8	;20-bit words
    b99a:	0a 16       	popm.a	#1,	r10	;20-bit words
    b99c:	10 01       	reta			;

0000b99e <.L34>:
    cfg->bitrate = RX_BR_MAX;
    b99e:	ba 40 f0 49 	mov	#18928,	12(r10)	;#0x49f0, 0x000c
    b9a2:	0c 00 
    b9a4:	aa 43 0e 00 	mov	#2,	14(r10)	;r3 As==10, 0x000e

0000b9a8 <.Loc.143.2>:
    bank0w[RegRXBRLsb] = (cfg->bitrate & 0xFF);
    b9a8:	28 01 26 01 	mova	&65830,	r8	;0x10126
    b9ac:	f8 40 f0 ff 	mov.b	#-16,	28(r8)	;#0xfff0, 0x001c
    b9b0:	1c 00 

0000b9b2 <.Loc.144.2>:
    bank0w[RegRXBRLmb] = ((cfg->bitrate >> 8) & 0xFF);
    b9b2:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b9b6:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b9ba:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    b9be:	c8 4c 1d 00 	mov.b	r12,	29(r8)	; 0x001d

0000b9c2 <.Loc.145.2>:
    bank0w[RegRXBRHmb] = ((cfg->bitrate >> 16) & 0xFF);
    b9c2:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b9c6:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b9ca:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    b9ce:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b9d2:	c8 4c 1e 00 	mov.b	r12,	30(r8)	; 0x001e

0000b9d6 <.Loc.146.2>:
    bank0w[RegRXBRMsb] = (cfg->bitrate >> 24);
    b9d6:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    b9da:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    b9de:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    b9e2:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    b9e6:	c8 4c 1f 00 	mov.b	r12,	31(r8)	; 0x001f
    b9ea:	80 00 28 b9 	mova	#47400,	r0	;0x0b928

0000b9ee <elyRFChangeTxDevS>:

void __attribute__((weak)) elyRFChangeTxDevS(SX1278Config * cfg) {
    b9ee:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000b9f0 <.LCFI10>:
    b9f0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000b9f2 <.LCFI11>:
    b9f2:	ca 0c       	mova	r12,	r10	;

0000b9f4 <.Loc.162.2>:
  chSysLock();
    b9f4:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000b9f8 <.LVL58>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    b9f8:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    b9fc:	5d 4e 09 00 	mov.b	9(r14),	r13	;
    ba00:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    ba04:	5c 4e 08 00 	mov.b	8(r14),	r12	;
    ba08:	0d dc       	bis	r12,	r13	;
    ba0a:	5c 4e 0b 00 	mov.b	11(r14),r12	;0x0000b
    ba0e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    ba12:	5e 4e 0a 00 	mov.b	10(r14),r14	;0x0000a
    ba16:	0c de       	bis	r14,	r12	;

0000ba18 <.Loc.167.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  if (cfg->fdev > TX_DEV_MAX) {
    ba18:	7e 40 03 00 	mov.b	#3,	r14	;
    ba1c:	0e 9c       	cmp	r12,	r14	;
    ba1e:	45 28       	jnc	$+140    	;abs 0xbaaa
    ba20:	0c 9e       	cmp	r14,	r12	;
    ba22:	04 20       	jnz	$+10     	;abs 0xba2c
    ba24:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    ba28:	0e 9d       	cmp	r13,	r14	;
    ba2a:	3f 28       	jnc	$+128    	;abs 0xbaaa

0000ba2c <.L47>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    ba2c:	8a 4d 10 00 	mov	r13,	16(r10)	; 0x0010
    ba30:	8a 4c 12 00 	mov	r12,	18(r10)	; 0x0012

0000ba34 <.L44>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < TX_DEV_MIN) {
    ba34:	8a 93 12 00 	cmp	#0,	18(r10)	;r3 As==00, 0x0012
    ba38:	2b 20       	jnz	$+88     	;abs 0xba90
    ba3a:	3c 40 57 02 	mov	#599,	r12	;#0x0257
    ba3e:	1c 9a 10 00 	cmp	16(r10),r12	;0x00010
    ba42:	26 28       	jnc	$+78     	;abs 0xba90

0000ba44 <.Loc.175.2>:
    cfg->fdev = TX_DEV_MIN;
    ba44:	ba 40 58 02 	mov	#600,	16(r10)	;#0x0258, 0x0010
    ba48:	10 00 
    ba4a:	8a 43 12 00 	mov	#0,	18(r10)	;r3 As==00, 0x0012

0000ba4e <.Loc.176.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    ba4e:	28 01 26 01 	mova	&65830,	r8	;0x10126
    ba52:	f8 40 58 00 	mov.b	#88,	8(r8)	;#0x0058
    ba56:	08 00 

0000ba58 <.Loc.177.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    ba58:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    ba5c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    ba60:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    ba64:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000ba68 <.Loc.178.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    ba68:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    ba6c:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    ba70:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ba74:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    ba78:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000ba7c <.Loc.179.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    ba7c:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    ba80:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    ba84:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    ba88:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    ba8c:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b

0000ba90 <.L45>:
  }
  chSysUnlock();
    ba90:	b0 13 32 b5 	calla	#46386		;0x0b532

0000ba94 <.LVL62>:
  
  /* This is fast */
  sx1278SetDeviation(&SX1278D1, cfg->fdev);
    ba94:	1d 4a 10 00 	mov	16(r10),r13	;0x00010
    ba98:	1e 4a 12 00 	mov	18(r10),r14	;0x00012
    ba9c:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    baa0:	b0 13 36 66 	calla	#26166		;0x06636

0000baa4 <.LVL63>:
}
    baa4:	08 16       	popm.a	#1,	r8	;20-bit words
    baa6:	0a 16       	popm.a	#1,	r10	;20-bit words
    baa8:	10 01       	reta			;

0000baaa <.L42>:
    cfg->fdev = TX_DEV_MAX;
    baaa:	ba 40 40 0d 	mov	#3392,	16(r10)	;#0x0d40, 0x0010
    baae:	10 00 
    bab0:	ba 40 03 00 	mov	#3,	18(r10)	; 0x0012
    bab4:	12 00 

0000bab6 <.Loc.169.2>:
    bank0w[RegTXDevLsb] = (cfg->fdev & 0xFF);
    bab6:	28 01 26 01 	mova	&65830,	r8	;0x10126
    baba:	f8 40 40 00 	mov.b	#64,	8(r8)	;#0x0040
    babe:	08 00 

0000bac0 <.Loc.170.2>:
    bank0w[RegTXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bac0:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    bac4:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    bac8:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    bacc:	c8 4c 09 00 	mov.b	r12,	9(r8)	;

0000bad0 <.Loc.171.2>:
    bank0w[RegTXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bad0:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    bad4:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    bad8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    badc:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    bae0:	c8 4c 0a 00 	mov.b	r12,	10(r8)	; 0x000a

0000bae4 <.Loc.172.2>:
    bank0w[RegTXDevMsb] = (cfg->fdev >> 24);
    bae4:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    bae8:	1d 4a 12 00 	mov	18(r10),r13	;0x00012
    baec:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    baf0:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    baf4:	c8 4c 0b 00 	mov.b	r12,	11(r8)	; 0x000b
    baf8:	80 00 34 ba 	mova	#47668,	r0	;0x0ba34

0000bafc <elyRFChangeRxDevS>:

void __attribute__((weak)) elyRFChangeRxDevS(SX1212Config * cfg) {
    bafc:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bafe <.LCFI12>:
    bafe:	08 14       	pushm.a	#1,	r8	;20-bit words

0000bb00 <.LCFI13>:
    bb00:	ca 0c       	mova	r12,	r10	;

0000bb02 <.Loc.188.2>:
  chSysLock();
    bb02:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000bb06 <.LVL68>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    bb06:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    bb0a:	5d 4e 0d 00 	mov.b	13(r14),r13	;0x0000d
    bb0e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bb12:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    bb16:	0d dc       	bis	r12,	r13	;
    bb18:	5c 4e 0f 00 	mov.b	15(r14),r12	;0x0000f
    bb1c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bb20:	5e 4e 0e 00 	mov.b	14(r14),r14	;0x0000e
    bb24:	0c de       	bis	r14,	r12	;

0000bb26 <.Loc.193.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  if (cfg->fdev > RX_DEV_MAX) {
    bb26:	7e 40 03 00 	mov.b	#3,	r14	;
    bb2a:	0e 9c       	cmp	r12,	r14	;
    bb2c:	45 28       	jnc	$+140    	;abs 0xbbb8
    bb2e:	0c 9e       	cmp	r14,	r12	;
    bb30:	04 20       	jnz	$+10     	;abs 0xbb3a
    bb32:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    bb36:	0e 9d       	cmp	r13,	r14	;
    bb38:	3f 28       	jnc	$+128    	;abs 0xbbb8

0000bb3a <.L55>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    bb3a:	8a 4d 14 00 	mov	r13,	20(r10)	; 0x0014
    bb3e:	8a 4c 16 00 	mov	r12,	22(r10)	; 0x0016

0000bb42 <.L52>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
  }
  if (cfg->fdev < RX_DEV_MIN) {
    bb42:	8a 93 16 00 	cmp	#0,	22(r10)	;r3 As==00, 0x0016
    bb46:	2b 20       	jnz	$+88     	;abs 0xbb9e
    bb48:	3c 40 e7 80 	mov	#-32537,r12	;#0x80e7
    bb4c:	1c 9a 14 00 	cmp	20(r10),r12	;0x00014
    bb50:	26 28       	jnc	$+78     	;abs 0xbb9e

0000bb52 <.Loc.201.2>:
    cfg->fdev = RX_DEV_MIN;
    bb52:	ba 40 e8 80 	mov	#-32536,20(r10)	;#0x80e8, 0x0014
    bb56:	14 00 
    bb58:	8a 43 16 00 	mov	#0,	22(r10)	;r3 As==00, 0x0016

0000bb5c <.Loc.202.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    bb5c:	28 01 26 01 	mova	&65830,	r8	;0x10126
    bb60:	f8 40 e8 ff 	mov.b	#-24,	12(r8)	;#0xffe8, 0x000c
    bb64:	0c 00 

0000bb66 <.Loc.203.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bb66:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bb6a:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bb6e:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    bb72:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000bb76 <.Loc.204.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bb76:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bb7a:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bb7e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    bb82:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    bb86:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000bb8a <.Loc.205.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    bb8a:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bb8e:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bb92:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    bb96:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    bb9a:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f

0000bb9e <.L53>:
  }
  chSysUnlock();
    bb9e:	b0 13 32 b5 	calla	#46386		;0x0b532

0000bba2 <.LVL72>:
  
  /* This is super fast */
  sx1212SetDeviation(&SX1212D1, cfg->fdev);
    bba2:	1d 4a 14 00 	mov	20(r10),r13	;0x00014
    bba6:	1e 4a 16 00 	mov	22(r10),r14	;0x00016
    bbaa:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    bbae:	b0 13 a4 6d 	calla	#28068		;0x06da4

0000bbb2 <.LVL73>:
}
    bbb2:	08 16       	popm.a	#1,	r8	;20-bit words
    bbb4:	0a 16       	popm.a	#1,	r10	;20-bit words
    bbb6:	10 01       	reta			;

0000bbb8 <.L50>:
    cfg->fdev = RX_DEV_MAX;
    bbb8:	ba 40 40 0d 	mov	#3392,	20(r10)	;#0x0d40, 0x0014
    bbbc:	14 00 
    bbbe:	ba 40 03 00 	mov	#3,	22(r10)	; 0x0016
    bbc2:	16 00 

0000bbc4 <.Loc.195.2>:
    bank0w[RegRXDevLsb] = (cfg->fdev & 0xFF);
    bbc4:	28 01 26 01 	mova	&65830,	r8	;0x10126
    bbc8:	f8 40 40 00 	mov.b	#64,	12(r8)	;#0x0040, 0x000c
    bbcc:	0c 00 

0000bbce <.Loc.196.2>:
    bank0w[RegRXDevLmb] = ((cfg->fdev >> 8) & 0xFF);
    bbce:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bbd2:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bbd6:	b0 13 a2 d2 	calla	#53922		;0x0d2a2
    bbda:	c8 4c 0d 00 	mov.b	r12,	13(r8)	; 0x000d

0000bbde <.Loc.197.2>:
    bank0w[RegRXDevHmb] = ((cfg->fdev >> 16) & 0xFF);
    bbde:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bbe2:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bbe6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    bbea:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    bbee:	c8 4c 0e 00 	mov.b	r12,	14(r8)	; 0x000e

0000bbf2 <.Loc.198.2>:
    bank0w[RegRXDevMsb] = (cfg->fdev >> 24);
    bbf2:	1c 4a 14 00 	mov	20(r10),r12	;0x00014
    bbf6:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    bbfa:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    bbfe:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    bc02:	c8 4c 0f 00 	mov.b	r12,	15(r8)	; 0x000f
    bc06:	80 00 42 bb 	mova	#47938,	r0	;0x0bb42

0000bc0a <elyRFChangeRxSyncS>:
  
  /* This is reasonably fast */
  sx1278SetSync(&SX1278D1, cfg->sync_word);
}

void __attribute__((weak)) elyRFChangeRxSyncS(SX1212Config * cfg) {
    bc0a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000bc0c <.LCFI15>:
    bc0c:	ca 0c       	mova	r12,	r10	;

0000bc0e <.Loc.226.2>:
  chSysLock();
    bc0e:	b0 13 2a b5 	calla	#46378		;0x0b52a

0000bc12 <.LVL82>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    bc12:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    bc16:	5d 4e 15 00 	mov.b	21(r14),r13	;0x00015
    bc1a:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bc1e:	5c 4e 17 00 	mov.b	23(r14),r12	;0x00017
    bc22:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bc26:	5f 4e 16 00 	mov.b	22(r14),r15	;0x00016
    bc2a:	0c df       	bis	r15,	r12	;

0000bc2c <.Loc.227.2>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    bc2c:	5e 4e 14 00 	mov.b	20(r14),r14	;0x00014
    bc30:	0e dd       	bis	r13,	r14	;
    bc32:	8a 4e 1c 00 	mov	r14,	28(r10)	; 0x001c
    bc36:	8a 4c 1e 00 	mov	r12,	30(r10)	; 0x001e

0000bc3a <.Loc.231.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    bc3a:	b0 13 32 b5 	calla	#46386		;0x0b532

0000bc3e <.LVL83>:
  
  /* This is reasonably fast */
  sx1212SetSync(&SX1212D1, cfg->sync_word);
    bc3e:	1d 4a 1c 00 	mov	28(r10),r13	;0x0001c
    bc42:	1e 4a 1e 00 	mov	30(r10),r14	;0x0001e
    bc46:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    bc4a:	b0 13 ca 70 	calla	#28874		;0x070ca

0000bc4e <.LVL84>:
}
    bc4e:	0a 16       	popm.a	#1,	r10	;20-bit words
    bc50:	10 01       	reta			;

0000bc52 <elyRFChangeTxPowerS>:
  return lut[(pow / 2) + 21];
}

void __attribute__((weak)) elyRFChangeTxPowerS(SX1278Config * cfg) {
  
  int16_t prog_pow = 100 + 2 * bank0p[RegOutputPower];
    bc52:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    bc56:	5e 4e 21 00 	mov.b	33(r14),r14	;0x00021
    bc5a:	0e 5e       	rla	r14		;

0000bc5c <.Loc.254.2>:
  int16_t rfic_pow = prog_pow - 300 + (FIXED_ATTEN*10);
    bc5c:	3e 50 60 ff 	add	#-160,	r14	;#0xff60

0000bc60 <.LBB24>:
  return lut[(pow / 2) + 21];
    bc60:	0e 11       	rra	r14		;
    bc62:	3e 50 15 00 	add	#21,	r14	;#0x0015
    bc66:	4e 0e       	rlam.a	#4,	r14	;
    bc68:	4e 0d       	rram.a	#4,	r14	;
    bc6a:	c0 18 5d 4e 	movx.b	65838(r14),r13	;0x1012e
    bc6e:	2e 01 

0000bc70 <.LBE24>:
  cfg->pow = rfic_pow_to_reg(rfic_pow);
    bc70:	cc 4d 15 00 	mov.b	r13,	21(r12)	; 0x0015

0000bc74 <.Loc.258.2>:
  
  /* This is reasonably fast because I made it kind of sloppy */
  sx1278SetPower(&SX1278D1, cfg->pow);
    bc74:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e

0000bc78 <.LVL91>:
    bc78:	b0 13 3a 67 	calla	#26426		;0x0673a

0000bc7c <.LVL92>:
}
    bc7c:	10 01       	reta			;

0000bc7e <elyRFChangeRxFilterParamsS>:
  sx1278SetFilterParams(&SX1278D1, tx_cfg->filter);
}

void __attribute__((weak)) elyRFChangeRxFilterParamsS(SX1212Config * rx_cfg) {
  
  rx_cfg->rx_bw = (bank0p[RegFilterParams] & 0x0F);
    bc7e:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a
    bc82:	5d 4e 20 00 	mov.b	32(r14),r13	;0x00020
    bc86:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    bc8a:	4e 4d       	mov.b	r13,	r14	;
    bc8c:	0f 43       	clr	r15		;
    bc8e:	8c 4e 18 00 	mov	r14,	24(r12)	; 0x0018
    bc92:	8c 4f 1a 00 	mov	r15,	26(r12)	; 0x001a

0000bc96 <.Loc.272.2>:
  /* This is fast and I made it kind of sloppy anyway */
  sx1212SetRxBw(&SX1212D1, rx_cfg->rx_bw);
    bc96:	8c 01 72 15 	mova	#71026,	r12	;0x11572

0000bc9a <.LVL97>:
    bc9a:	b0 13 06 71 	calla	#28934		;0x07106

0000bc9e <.LVL98>:
}
    bc9e:	10 01       	reta			;

0000bca0 <RFThd>:
static bool bits_set(eventmask_t events, eventmask_t bits) {
  return ((events & bits) == bits);
}

THD_WORKING_AREA(waRFThd, 512);
THD_FUNCTION(RFThd, arg) {
    bca0:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000bca2 <.LCFI16>:
    bca2:	26 14       	pushm.a	#3,	r6	;20-bit words

0000bca4 <.LCFI17>:
    bca4:	b1 00 08 00 	suba	#8,	r1	;

0000bca8 <.LCFI18>:
  (void)arg;
  
  chThdSleep(1); //a guess at a prudent delay before arming the PA GOOD interrupt
    bca8:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000bcaa <.LVL100>:
    bcaa:	b0 13 10 47 	calla	#18192		;0x04710

0000bcae <.LVL101>:
  palLineEnableEventI(LINE_PA_PGOOD, PAL_EVENT_MODE_FALLING_EDGE,  elyPA_OC_fault_CB);
    bcae:	8f 00 24 c5 	mova	#50468,	r15	;0x0c524
    bcb2:	6e 43       	mov.b	#2,	r14	;r3 As==10
    bcb4:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    bcb8:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    bcbc:	b0 13 46 58 	calla	#22598		;0x05846

0000bcc0 <.LVL102>:
  
  /* Store a thread pointer for later use */
  rf_thd = chThdGetSelfX();
    bcc0:	81 18 d2 42 	movx.a	&0x112ec,&0x12124;
    bcc4:	ec 12 24 21 

0000bcc8 <.Loc.347.2>:
  
  /* Build the TX config out of the registers */
  chSysLock();
    bcc8:	86 00 2a b5 	mova	#46378,	r6	;0x0b52a
    bccc:	46 13       	calla	r6		;

0000bcce <.LVL103>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    bcce:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    bcd2:	84 00 06 d7 	mova	#55046,	r4	;0x0d706

0000bcd6 <.Loc.350.2>:
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    bcd6:	5d 4a 19 00 	mov.b	25(r10),r13	;0x00019
    bcda:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bcde:	5c 4a 1b 00 	mov.b	27(r10),r12	;0x0001b
    bce2:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bce6:	5e 4a 1a 00 	mov.b	26(r10),r14	;0x0001a
    bcea:	0c de       	bis	r14,	r12	;

0000bcec <.Loc.348.2>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    bcec:	5e 4a 18 00 	mov.b	24(r10),r14	;0x00018
    bcf0:	0e dd       	bis	r13,	r14	;
    bcf2:	84 4e 08 00 	mov	r14,	8(r4)	;
    bcf6:	84 4c 0a 00 	mov	r12,	10(r4)	; 0x000a

0000bcfa <.Loc.354.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    bcfa:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    bcfe:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bd02:	5c 4a 03 00 	mov.b	3(r10),	r12	;
    bd06:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bd0a:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    bd0e:	0c de       	bis	r14,	r12	;

0000bd10 <.Loc.352.2>:
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    bd10:	6e 4a       	mov.b	@r10,	r14	;
    bd12:	0e dd       	bis	r13,	r14	;
    bd14:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    bd18:	84 4c 0e 00 	mov	r12,	14(r4)	; 0x000e

0000bd1c <.Loc.358.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    bd1c:	5d 4a 09 00 	mov.b	9(r10),	r13	;
    bd20:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bd24:	5c 4a 0b 00 	mov.b	11(r10),r12	;0x0000b
    bd28:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bd2c:	5e 4a 0a 00 	mov.b	10(r10),r14	;0x0000a
    bd30:	0c de       	bis	r14,	r12	;

0000bd32 <.Loc.356.2>:
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    bd32:	5e 4a 08 00 	mov.b	8(r10),	r14	;
    bd36:	0e dd       	bis	r13,	r14	;
    bd38:	84 4e 10 00 	mov	r14,	16(r4)	; 0x0010
    bd3c:	84 4c 12 00 	mov	r12,	18(r4)	; 0x0012

0000bd40 <.Loc.360.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  tx_cfg.filter = ((bank0p[RegFilterParams] >> 4) & 0x03);
    bd40:	5c 4a 20 00 	mov.b	32(r10),r12	;0x00020
    bd44:	5c 0f       	rrum	#4,	r12	;
    bd46:	7c f0 03 00 	and.b	#3,	r12	;
    bd4a:	c4 4c 14 00 	mov.b	r12,	20(r4)	; 0x0014

0000bd4e <.LVL104>:
  int16_t prog_pow = 100 + 2 * bank0p[RegOutputPower];
    bd4e:	5c 4a 21 00 	mov.b	33(r10),r12	;0x00021
    bd52:	0c 5c       	rla	r12		;

0000bd54 <.Loc.362.2>:
  int16_t rfic_pow = prog_pow - 300 + (FIXED_ATTEN*10);
    bd54:	3c 50 60 ff 	add	#-160,	r12	;#0xff60

0000bd58 <.LBB26>:
  return lut[(pow / 2) + 21];
    bd58:	0c 11       	rra	r12		;
    bd5a:	3c 50 15 00 	add	#21,	r12	;#0x0015
    bd5e:	4c 0e       	rlam.a	#4,	r12	;
    bd60:	4c 0d       	rram.a	#4,	r12	;

0000bd62 <.LBE26>:
  tx_cfg.pow = rfic_pow_to_reg(rfic_pow);
    bd62:	c0 18 d4 4c 	movx.b	65838(r12),21(r4)	;0x1012e, 0x00015
    bd66:	2e 01 15 00 

0000bd6a <.Loc.366.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
                ((uint32_t)(bank0p[RegTXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    bd6a:	5d 4a 11 00 	mov.b	17(r10),r13	;0x00011
    bd6e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bd72:	5c 4a 13 00 	mov.b	19(r10),r12	;0x00013
    bd76:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bd7a:	5e 4a 12 00 	mov.b	18(r10),r14	;0x00012
    bd7e:	0c de       	bis	r14,	r12	;

0000bd80 <.Loc.364.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
    bd80:	5e 4a 10 00 	mov.b	16(r10),r14	;0x00010
    bd84:	0e dd       	bis	r13,	r14	;
    bd86:	84 4e 18 00 	mov	r14,	24(r4)	; 0x0018
    bd8a:	84 4c 1a 00 	mov	r12,	26(r4)	; 0x001a

0000bd8e <.Loc.368.2>:
                ((uint32_t)(bank0p[RegTXSyncMsb]) << 24) );
  chSysUnlock();
    bd8e:	88 00 32 b5 	mova	#46386,	r8	;0x0b532
    bd92:	48 13       	calla	r8		;

0000bd94 <.LVL105>:
  
  /* Start the transmitter driver and initiate the transmit loop */
  sx1278ObjectInit(&SX1278D1);
    bd94:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    bd98:	b0 13 9e 67 	calla	#26526		;0x0679e

0000bd9c <.LVL106>:
  sx1278Start(&SX1278D1, &tx_cfg);
    bd9c:	cd 04       	mova	r4,	r13	;
    bd9e:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    bda2:	b0 13 ae 67 	calla	#26542		;0x067ae

0000bda6 <.LVL107>:
  
  elyRFDLLTxInit(&SX1278D1);
    bda6:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    bdaa:	b0 13 3c b1 	calla	#45372		;0x0b13c

0000bdae <.LVL108>:
  
  /* Build the RX config out of the registers */
  chSysLock();
    bdae:	46 13       	calla	r6		;

0000bdb0 <.LVL109>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    bdb0:	86 00 da d6 	mova	#55002,	r6	;0x0d6da

0000bdb4 <.Loc.380.2>:
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    bdb4:	5d 4a 1d 00 	mov.b	29(r10),r13	;0x0001d
    bdb8:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bdbc:	5c 4a 1f 00 	mov.b	31(r10),r12	;0x0001f
    bdc0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bdc4:	5e 4a 1e 00 	mov.b	30(r10),r14	;0x0001e
    bdc8:	0c de       	bis	r14,	r12	;

0000bdca <.Loc.378.2>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    bdca:	5e 4a 1c 00 	mov.b	28(r10),r14	;0x0001c
    bdce:	0e dd       	bis	r13,	r14	;
    bdd0:	86 4e 0c 00 	mov	r14,	12(r6)	; 0x000c
    bdd4:	86 4c 0e 00 	mov	r12,	14(r6)	; 0x000e

0000bdd8 <.Loc.384.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    bdd8:	5d 4a 05 00 	mov.b	5(r10),	r13	;
    bddc:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    bde0:	5c 4a 07 00 	mov.b	7(r10),	r12	;
    bde4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    bde8:	5e 4a 06 00 	mov.b	6(r10),	r14	;
    bdec:	0c de       	bis	r14,	r12	;

0000bdee <.Loc.382.2>:
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    bdee:	5e 4a 04 00 	mov.b	4(r10),	r14	;
    bdf2:	0e dd       	bis	r13,	r14	;
    bdf4:	86 4e 10 00 	mov	r14,	16(r6)	; 0x0010
    bdf8:	86 4c 12 00 	mov	r12,	18(r6)	; 0x0012

0000bdfc <.Loc.388.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    bdfc:	5d 4a 0d 00 	mov.b	13(r10),r13	;0x0000d
    be00:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    be04:	5c 4a 0f 00 	mov.b	15(r10),r12	;0x0000f
    be08:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    be0c:	5e 4a 0e 00 	mov.b	14(r10),r14	;0x0000e
    be10:	0c de       	bis	r14,	r12	;

0000be12 <.Loc.386.2>:
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    be12:	5e 4a 0c 00 	mov.b	12(r10),r14	;0x0000c
    be16:	0e dd       	bis	r13,	r14	;
    be18:	86 4e 14 00 	mov	r14,	20(r6)	; 0x0014
    be1c:	86 4c 16 00 	mov	r12,	22(r6)	; 0x0016

0000be20 <.Loc.390.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  rx_cfg.rx_bw = (bank0p[RegFilterParams] & 0x0F);
    be20:	5c 4a 20 00 	mov.b	32(r10),r12	;0x00020
    be24:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    be28:	4d 4c       	mov.b	r12,	r13	;
    be2a:	0e 43       	clr	r14		;
    be2c:	86 4d 18 00 	mov	r13,	24(r6)	; 0x0018
    be30:	86 4e 1a 00 	mov	r14,	26(r6)	; 0x001a

0000be34 <.Loc.393.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    be34:	5d 4a 15 00 	mov.b	21(r10),r13	;0x00015
    be38:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    be3c:	5c 4a 17 00 	mov.b	23(r10),r12	;0x00017
    be40:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    be44:	5e 4a 16 00 	mov.b	22(r10),r14	;0x00016
    be48:	0c de       	bis	r14,	r12	;

0000be4a <.Loc.391.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    be4a:	5a 4a 14 00 	mov.b	20(r10),r10	;0x00014
    be4e:	0a dd       	bis	r13,	r10	;
    be50:	86 4a 1c 00 	mov	r10,	28(r6)	; 0x001c
    be54:	86 4c 1e 00 	mov	r12,	30(r6)	; 0x001e

0000be58 <.Loc.395.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    be58:	48 13       	calla	r8		;

0000be5a <.LVL110>:


  /* Start the receiver driver and initiate the receive loop */
  sx1212Start(&SX1212D1, &rx_cfg);
    be5a:	cd 06       	mova	r6,	r13	;
    be5c:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    be60:	b0 13 2c 71 	calla	#28972		;0x0712c

0000be64 <.LVL111>:
  
#if ELY_HAS_LNA
  palSetLine(LINE_LNA_PC_EN);
    be64:	40 18 a2 d2 	bisx.w	#4,	&0x00322;r2 As==10
    be68:	22 03 

0000be6a <.Loc.405.2>:
#endif
  
  elyRFDLLRxInit(&SX1212D1);
    be6a:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    be6e:	b0 13 84 af 	calla	#44932		;0x0af84

0000be72 <.LVL112>:
  
  events = (RFSpiAvailable | RFTxIdle);
    be72:	41 18 b2 40 	movx.w	#8192,	&0x12120;0x02000
    be76:	00 20 20 21 
    be7a:	41 18 92 43 	movx.w	#1,	&0x12122;r3 As==01
    be7e:	22 21 

0000be80 <.Loc.411.2>:
  
  while (true) {

    GC_Fault_Handler(events);
    be80:	89 00 42 c8 	mova	#51266,	r9	;0x0c842

0000be84 <.LBB28>:
  mask ^= mask & (mask - (eventmask_t)1);
    be84:	44 43       	clr.b	r4		;
    be86:	45 43       	clr.b	r5		;

0000be88 <.L88>:
    GC_Fault_Handler(events);
    be88:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    be8c:	20 21 
    be8e:	c0 18 1d 42 	movx.w	&0x12122,r13	;
    be92:	22 21 
    be94:	49 13       	calla	r9		;

0000be96 <.LVL113>:
    tx_cfg_ptr = &tx_cfg; //needed for sd1278Start() in OT_Fault_Handler
    be96:	01 18 f2 40 	movx.a	#55046,	&0x1211c;0x0d706
    be9a:	06 d7 1c 21 

0000be9e <.Loc.413.2>:
    events = OT_Fault_Handler(events);
    be9e:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bea2:	20 21 
    bea4:	c0 18 1d 42 	movx.w	&0x12122,r13	;
    bea8:	22 21 
    beaa:	b0 13 5a ca 	calla	#51802		;0x0ca5a

0000beae <.LVL114>:
    beae:	41 18 82 4c 	movx.w	r12,	&0x12120;
    beb2:	20 21 
    beb4:	41 18 82 4d 	movx.w	r13,	&0x12122;
    beb8:	22 21 

0000beba <.Loc.414.2>:
    events = PA_OC_Fault_Handler(events);
    beba:	b0 13 08 c6 	calla	#50696		;0x0c608

0000bebe <.LVL115>:
    bebe:	41 18 82 4c 	movx.w	r12,	&0x12120;
    bec2:	20 21 
    bec4:	41 18 82 4d 	movx.w	r13,	&0x12122;
    bec8:	22 21 

0000beca <.Loc.415.2>:
    events = LNA_OC_Fault_Handler(events);
    beca:	b0 13 62 c5 	calla	#50530		;0x0c562

0000bece <.LVL116>:
    events &= ~RFCheckFaults;
    bece:	41 18 82 4c 	movx.w	r12,	&0x12120;
    bed2:	20 21 
    bed4:	2d c3       	bic	#2,	r13	;r3 As==10
    bed6:	41 18 82 4d 	movx.w	r13,	&0x12122;
    beda:	22 21 

0000bedc <.LBB33>:
  return ((events & bits) == bits);
    bedc:	3c f0 00 30 	and	#12288,	r12	;#0x3000

0000bee0 <.LBE33>:

    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    bee0:	3c 90 00 30 	cmp	#12288,	r12	;#0x3000
    bee4:	0b 20       	jnz	$+24     	;abs 0xbefc

0000bee6 <.Loc.424.2>:
      /* 
       * Read FifoThresh bytes from the Fifo using spiStartReceive
       *  In the callback - signal SpiAvailable, and post buffer and signal RxIdle if applicable
       * Clear RxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleRxFifo(&SX1212D1);
    bee6:	8c 01 72 15 	mova	#71026,	r12	;0x11572
    beea:	b0 13 b2 af 	calla	#44978		;0x0afb2

0000beee <.LVL117>:
      events &= ~(RFSpiAvailable | RFRxFifoThresh);
    beee:	c1 1f b2 f0 	andx.w	#-12289,&0x12120;0xfcfff
    bef2:	ff cf 20 21 
    bef6:	41 18 82 c3 	bicx.w	#0,	&0x12122;r3 As==00
    befa:	22 21 

0000befc <.L64>:
  return ((events & bits) == bits);
    befc:	c0 18 1d 42 	movx.w	&0x12120,r13	;
    bf00:	20 21 
    bf02:	3d f0 00 28 	and	#10240,	r13	;#0x2800
    bf06:	c0 18 1c 42 	movx.w	&0x12122,r12	;
    bf0a:	22 21 
    bf0c:	5c f3       	and.b	#1,	r12	;r3 As==01

0000bf0e <.LBE35>:
    }
    if (bits_set(events, (RFSpiAvailable | RFTxFrameReady | RFTxIdle))) {
    bf0e:	3d 90 00 28 	cmp	#10240,	r13	;#0x2800
    bf12:	0d 20       	jnz	$+28     	;abs 0xbf2e
    bf14:	1c 93       	cmp	#1,	r12	;r3 As==01
    bf16:	0b 20       	jnz	$+24     	;abs 0xbf2e

0000bf18 <.Loc.428.2>:
      elyRFDLLInitiateTransmit(&SX1278D1);
    bf18:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    bf1c:	b0 13 8c b1 	calla	#45452		;0x0b18c

0000bf20 <.LVL118>:
      events &= ~(RFSpiAvailable | RFTxFrameReady | RFTxIdle);
    bf20:	c1 1f b2 f0 	andx.w	#-10241,&0x12120;0xfd7ff
    bf24:	ff d7 20 21 
    bf28:	41 18 92 c3 	bicx.w	#1,	&0x12122;r3 As==01
    bf2c:	22 21 

0000bf2e <.L65>:
  return ((events & bits) == bits);
    bf2e:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bf32:	20 21 
    bf34:	3c f0 00 a0 	and	#-24576,r12	;#0xa000

0000bf38 <.LBE37>:
    }
    if (bits_set(events, (RFTxFifoLevel | RFSpiAvailable))) {
    bf38:	3c 90 00 a0 	cmp	#-24576,r12	;#0xa000
    bf3c:	0b 20       	jnz	$+24     	;abs 0xbf54

0000bf3e <.Loc.438.2>:
       * Write FifoSize or BytesRemaining bytes to the Fifo using spiStartSend
       *  In the callback - signal SpiAvailable, and TxIdle if applicable
       *  TxFifoThresh signaled by PAL callback
       * Clear TxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleTxFifo(&SX1278D1);
    bf3e:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    bf42:	b0 13 be b1 	calla	#45502		;0x0b1be

0000bf46 <.LVL119>:
      events &= ~(RFSpiAvailable | RFTxFifoLevel);
    bf46:	41 18 b2 f0 	andx.w	#24575,	&0x12120;0x05fff
    bf4a:	ff 5f 20 21 
    bf4e:	41 18 82 c3 	bicx.w	#0,	&0x12122;r3 As==00
    bf52:	22 21 

0000bf54 <.L66>:
    }
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    bf54:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bf58:	20 21 

0000bf5a <.LBB39>:
  return ((events & bits) == bits);
    bf5a:	c0 18 1d 42 	movx.w	&0x12122,r13	;
    bf5e:	22 21 
    bf60:	5d f3       	and.b	#1,	r13	;r3 As==01

0000bf62 <.LBE39>:
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    bf62:	40 18 3c b0 	bitx.w	#1024,	r12	;0x00400
    bf66:	00 04 
    bf68:	11 24       	jz	$+36     	;abs 0xbf8c
    bf6a:	1d 93       	cmp	#1,	r13	;r3 As==01
    bf6c:	0f 20       	jnz	$+32     	;abs 0xbf8c

0000bf6e <.Loc.441.2>:
    bf6e:	3c b0 00 08 	bit	#2048,	r12	;#0x0800
    bf72:	0c 20       	jnz	$+26     	;abs 0xbf8c

0000bf74 <.Loc.447.2>:
      /*
       * Turn the NL packet into a DLL frame. Do it outside a lock zone.
       * Once the frame is ready, signal TxFrameReady to start transmission
       * Clear RFPktAvailable from Events variable
       */
      elyRFDLLBuildFrame();
    bf74:	b0 13 0a ad 	calla	#44298		;0x0ad0a

0000bf78 <.LVL120>:
      events &= ~RFPktAvailable;
    bf78:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bf7c:	20 21 
    bf7e:	3c f0 ff fb 	and	#-1025,	r12	;#0xfbff

0000bf82 <.Loc.449.2>:
      events |= (RFTxFrameReady);
    bf82:	3c d0 00 08 	bis	#2048,	r12	;#0x0800
    bf86:	41 18 82 4c 	movx.w	r12,	&0x12120;
    bf8a:	20 21 

0000bf8c <.L67>:
    }
    if (bits_set(events, (RFTxIdle | RFSpiAvailable)) && (events & RFTxCfgMask)) {
    bf8c:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bf90:	20 21 

0000bf92 <.LBB41>:
  return ((events & bits) == bits);
    bf92:	c0 18 1d 42 	movx.w	&0x12122,r13	;
    bf96:	22 21 
    bf98:	5d f3       	and.b	#1,	r13	;r3 As==01

0000bf9a <.LBE41>:
    if (bits_set(events, (RFTxIdle | RFSpiAvailable)) && (events & RFTxCfgMask)) {
    bf9a:	40 18 3c b0 	bitx.w	#8192,	r12	;0x02000
    bf9e:	00 20 
    bfa0:	02 24       	jz	$+6      	;abs 0xbfa6
    bfa2:	1d 93       	cmp	#1,	r13	;r3 As==01
    bfa4:	19 24       	jz	$+52     	;abs 0xbfd8

0000bfa6 <.L74>:
        
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    if (bits_set(events, (RFRxIdle | RFSpiAvailable)) && (events & RFRxCfgMask)) {
    bfa6:	c0 18 1c 42 	movx.w	&0x12120,r12	;
    bfaa:	20 21 

0000bfac <.LBB43>:
  return ((events & bits) == bits);
    bfac:	0d 4c       	mov	r12,	r13	;
    bfae:	3d f0 00 60 	and	#24576,	r13	;#0x6000

0000bfb2 <.LBE43>:
    if (bits_set(events, (RFRxIdle | RFSpiAvailable)) && (events & RFRxCfgMask)) {
    bfb2:	3d 90 00 60 	cmp	#24576,	r13	;#0x6000
    bfb6:	03 20       	jnz	$+8      	;abs 0xbfbe
    bfb8:	3c b0 aa 00 	bit	#170,	r12	;#0x00aa
    bfbc:	a6 20       	jnz	$+334    	;abs 0xc10a

0000bfbe <.L72>:
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    
    events |= chEvtWaitAnyTimeout(AllRfEvents, TIME_INFINITE);
    bfbe:	4e 43       	clr.b	r14		;
    bfc0:	3c 43       	mov	#-1,	r12	;r3 As==11
    bfc2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    bfc4:	b0 13 1e 48 	calla	#18462		;0x0481e

0000bfc8 <.LVL121>:
    bfc8:	41 18 82 dc 	bisx.w	r12,	&0x12120;
    bfcc:	20 21 
    bfce:	41 18 82 dd 	bisx.w	r13,	&0x12122;
    bfd2:	22 21 

0000bfd4 <.Loc.411.2>:
    GC_Fault_Handler(events);
    bfd4:	80 00 88 be 	mova	#48776,	r0	;0x0be88

0000bfd8 <.L101>:
    if (bits_set(events, (RFTxIdle | RFSpiAvailable)) && (events & RFTxCfgMask)) {
    bfd8:	3c b0 55 01 	bit	#341,	r12	;#0x0155
    bfdc:	e4 27       	jz	$-54     	;abs 0xbfa6

0000bfde <.LBB45>:
        switch (evt) {
    bfde:	86 00 fa d2 	mova	#54010,	r6	;0x0d2fa

0000bfe2 <.Loc.468.2>:
            elyRFChangeTxPowerS(&tx_cfg);
    bfe2:	8a 00 52 bc 	mova	#48210,	r10	;0x0bc52
    bfe6:	80 00 14 c0 	mova	#49172,	r0	;0x0c014

0000bfea <.L87>:
  mask ^= mask & (mask - (eventmask_t)1);
    bfea:	0c 44       	mov	r4,	r12	;
    bfec:	0d 45       	mov	r5,	r13	;
    bfee:	40 18 1c 81 	subx.w	4(r1),	r12	;
    bff2:	04 00 
    bff4:	40 18 1d 71 	subcx.w	6(r1),	r13	;
    bff8:	06 00 
    bffa:	08 4c       	mov	r12,	r8	;
    bffc:	18 f1 04 00 	and	4(r1),	r8	;

0000c000 <.LBE32>:
        switch (evt) {
    c000:	38 90 10 00 	cmp	#16,	r8	;#0x0010
    c004:	14 20       	jnz	$+42     	;abs 0xc02e

0000c006 <.Loc.463.2>:
            elyRFChangeTxDevS(&tx_cfg);
    c006:	8c 00 06 d7 	mova	#55046,	r12	;0x0d706
    c00a:	b0 13 ee b9 	calla	#47598		;0x0b9ee

0000c00e <.L75>:
        events &= ~evt;
    c00e:	41 18 82 c8 	bicx.w	r8,	&0x12120;
    c012:	20 21 

0000c014 <.L105>:
      while (events & RFTxCfgMask) {
    c014:	c0 18 1e 42 	movx.w	&0x12120,r14	;
    c018:	20 21 
    c01a:	3e f0 55 01 	and	#341,	r14	;#0x0155
    c01e:	81 4e 04 00 	mov	r14,	4(r1)	;
    c022:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    c026:	0e 93       	cmp	#0,	r14	;r3 As==00
    c028:	e0 23       	jnz	$-62     	;abs 0xbfea
    c02a:	80 00 a6 bf 	mova	#49062,	r0	;0x0bfa6

0000c02e <.L77>:
        switch (evt) {
    c02e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    c032:	4f 43       	clr.b	r15		;
    c034:	0c 48       	mov	r8,	r12	;
    c036:	4d 43       	clr.b	r13		;
    c038:	46 13       	calla	r6		;
    c03a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    c03c:	0d 9c       	cmp	r12,	r13	;
    c03e:	0a 28       	jnc	$+22     	;abs 0xc054
    c040:	08 9d       	cmp	r13,	r8	;
    c042:	13 24       	jz	$+40     	;abs 0xc06a
    c044:	28 92       	cmp	#4,	r8	;r2 As==10
    c046:	e3 23       	jnz	$-56     	;abs 0xc00e

0000c048 <.Loc.460.2>:
            elyRFChangeTxBRS(&tx_cfg);
    c048:	8c 00 06 d7 	mova	#55046,	r12	;0x0d706
    c04c:	b0 13 da b7 	calla	#47066		;0x0b7da

0000c050 <.LVL126>:
            break;
    c050:	80 00 0e c0 	mova	#49166,	r0	;0x0c00e

0000c054 <.L78>:
        switch (evt) {
    c054:	38 90 40 00 	cmp	#64,	r8	;#0x0040
    c058:	0e 24       	jz	$+30     	;abs 0xc076
    c05a:	38 90 00 01 	cmp	#256,	r8	;#0x0100
    c05e:	d7 23       	jnz	$-80     	;abs 0xc00e

0000c060 <.L85>:
            elyRFChangeTxPowerS(&tx_cfg);
    c060:	8c 00 06 d7 	mova	#55046,	r12	;0x0d706
    c064:	4a 13       	calla	r10		;

0000c066 <.LVL127>:
            break;
    c066:	80 00 0e c0 	mova	#49166,	r0	;0x0c00e

0000c06a <.L102>:
            elyRFChangeTxFreqS(&tx_cfg);
    c06a:	8c 00 06 d7 	mova	#55046,	r12	;0x0d706
    c06e:	b0 13 a8 b5 	calla	#46504		;0x0b5a8

0000c072 <.LVL128>:
            break;
    c072:	80 00 0e c0 	mova	#49166,	r0	;0x0c00e

0000c076 <.L104>:
            elyRFChangeTxSyncS(&tx_cfg);
    c076:	8c 00 06 d7 	mova	#55046,	r12	;0x0d706
    c07a:	b0 13 92 ab 	calla	#43922		;0x0ab92

0000c07e <.LVL129>:
    c07e:	80 00 60 c0 	mova	#49248,	r0	;0x0c060

0000c082 <.L100>:
  mask ^= mask & (mask - (eventmask_t)1);
    c082:	0c 44       	mov	r4,	r12	;
    c084:	0d 45       	mov	r5,	r13	;
    c086:	40 18 2c 81 	subx.w	@r1,	r12	;
    c08a:	40 18 1d 71 	subcx.w	2(r1),	r13	;
    c08e:	02 00 
    c090:	08 4c       	mov	r12,	r8	;
    c092:	28 f1       	and	@r1,	r8	;

0000c094 <.LBE48>:
        switch (evt) {
    c094:	38 92       	cmp	#8,	r8	;r2 As==11
    c096:	14 20       	jnz	$+42     	;abs 0xc0c0

0000c098 <.Loc.490.2>:
            elyRFChangeRxBRS(&rx_cfg);
    c098:	8c 00 da d6 	mova	#55002,	r12	;0x0d6da
    c09c:	b0 13 e4 b8 	calla	#47332		;0x0b8e4

0000c0a0 <.L90>:
        events &= ~evt;
    c0a0:	41 18 82 c8 	bicx.w	r8,	&0x12120;
    c0a4:	20 21 

0000c0a6 <.L109>:
      while (events & RFRxCfgMask) {
    c0a6:	c0 18 1e 42 	movx.w	&0x12120,r14	;
    c0aa:	20 21 
    c0ac:	7e f0 aa 00 	and.b	#170,	r14	;#0x00aa
    c0b0:	81 4e 00 00 	mov	r14,	0(r1)	;
    c0b4:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    c0b8:	0e 93       	cmp	#0,	r14	;r3 As==00
    c0ba:	e3 23       	jnz	$-56     	;abs 0xc082
    c0bc:	80 00 be bf 	mova	#49086,	r0	;0x0bfbe

0000c0c0 <.L92>:
        switch (evt) {
    c0c0:	7e 42       	mov.b	#8,	r14	;r2 As==11
    c0c2:	4f 43       	clr.b	r15		;
    c0c4:	0c 48       	mov	r8,	r12	;
    c0c6:	4d 43       	clr.b	r13		;
    c0c8:	46 13       	calla	r6		;
    c0ca:	5d 43       	mov.b	#1,	r13	;r3 As==01
    c0cc:	0d 9c       	cmp	r12,	r13	;
    c0ce:	08 28       	jnc	$+18     	;abs 0xc0e0
    c0d0:	28 93       	cmp	#2,	r8	;r3 As==10
    c0d2:	e6 23       	jnz	$-50     	;abs 0xc0a0

0000c0d4 <.Loc.487.2>:
            elyRFChangeRxFreqS(&rx_cfg);
    c0d4:	8c 00 da d6 	mova	#55002,	r12	;0x0d6da
    c0d8:	b0 13 c0 b6 	calla	#46784		;0x0b6c0

0000c0dc <.LVL134>:
            break;
    c0dc:	80 00 a0 c0 	mova	#49312,	r0	;0x0c0a0

0000c0e0 <.L93>:
        switch (evt) {
    c0e0:	38 90 20 00 	cmp	#32,	r8	;#0x0020
    c0e4:	0d 24       	jz	$+28     	;abs 0xc100
    c0e6:	38 90 80 00 	cmp	#128,	r8	;#0x0080
    c0ea:	da 23       	jnz	$-74     	;abs 0xc0a0

0000c0ec <.Loc.496.2>:
            elyRFChangeRxSyncS(&rx_cfg);
    c0ec:	8c 00 da d6 	mova	#55002,	r12	;0x0d6da
    c0f0:	b0 13 0a bc 	calla	#48138		;0x0bc0a

0000c0f4 <.LVL135>:
            elyRFChangeRxFilterParamsS(&rx_cfg);
    c0f4:	8c 00 da d6 	mova	#55002,	r12	;0x0d6da
    c0f8:	b0 13 7e bc 	calla	#48254		;0x0bc7e

0000c0fc <.LVL136>:
            break;
    c0fc:	80 00 a0 c0 	mova	#49312,	r0	;0x0c0a0

0000c100 <.L107>:
            elyRFChangeRxDevS(&rx_cfg);
    c100:	8c 00 da d6 	mova	#55002,	r12	;0x0d6da
    c104:	4a 13       	calla	r10		;

0000c106 <.LVL137>:
            break;
    c106:	80 00 a0 c0 	mova	#49312,	r0	;0x0c0a0

0000c10a <.L89>:
        switch (evt) {
    c10a:	86 00 fa d2 	mova	#54010,	r6	;0x0d2fa

0000c10e <.Loc.493.2>:
            elyRFChangeRxDevS(&rx_cfg);
    c10e:	8a 00 fc ba 	mova	#47868,	r10	;0x0bafc
    c112:	80 00 a6 c0 	mova	#49318,	r0	;0x0c0a6

0000c116 <nl_allocator>:
uint8_t PERSIST packets_received;
uint16_t PERSIST packets_sent = 1;
uint8_t PERSIST packets_relayed;
static size_t sh_len;

void * nl_allocator(size_t size, unsigned align) {
    c116:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c118 <.LCFI0>:
  (void)(align);
  /* Provides memory blocks for the pool */
  static size_t curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    c118:	2e 01 44 21 	mova	&74052,	r14	;0x12144
    c11c:	ca 0e       	mova	r14,	r10	;
    c11e:	ea 0c       	adda	r12,	r10	;
    c120:	3c 40 00 18 	mov	#6144,	r12	;#0x1800

0000c124 <.LVL1>:
    c124:	dc 0a       	cmpa	r10,	r12	;
    c126:	07 28       	jnc	$+16     	;abs 0xc136

0000c128 <.Loc.26.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    c128:	cc 0e       	mova	r14,	r12	;
    c12a:	ac 01 58 21 	adda	#74072,	r12	;0x12158

0000c12e <.LVL2>:
  
  curr_index += size;
    c12e:	61 0a 44 21 	mova	r10,	&74052	; 0x12144

0000c132 <.L1>:
  return result;
}
    c132:	0a 16       	popm.a	#1,	r10	;20-bit words
    c134:	10 01       	reta			;

0000c136 <.L3>:
    return NULL;
    c136:	4c 43       	clr.b	r12		;
    c138:	80 00 32 c1 	mova	#49458,	r0	;0x0c132

0000c13c <clamp>:

static memory_pool_t main_mpool;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    c13c:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c13e <.LCFI1>:
    c13e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    c142:	49 4d       	mov.b	r13,	r9	;
    c144:	4a 4e       	mov.b	r14,	r10	;

0000c146 <.Loc.35.1>:
  if (value < min) {
    c146:	4c 99       	cmp.b	r9,	r12	;
    c148:	07 2c       	jc	$+16     	;abs 0xc158

0000c14a <.LVL5>:
    value = min;
    elyErrorSignal(ErrRegClip);
    c14a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c14e:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c152 <.LVL6>:
    c152:	0c 49       	mov	r9,	r12	;

0000c154 <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    c154:	19 16       	popm.a	#2,	r10	;20-bit words
    c156:	10 01       	reta			;

0000c158 <.L5>:
  else if (value > max) {
    c158:	4a 9c       	cmp.b	r12,	r10	;
    c15a:	fc 2f       	jc	$-6      	;abs 0xc154

0000c15c <.LVL9>:
    elyErrorSignal(ErrRegClip);
    c15c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    c160:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c164 <.LVL10>:
    c164:	0c 4a       	mov	r10,	r12	;
    c166:	80 00 54 c1 	mova	#49492,	r0	;0x0c154

0000c16a <uart_pass>:
  
  return;
}

static inline msg_t uart_pass(uint8_t * buffer) {
  return elyUARTPost(buffer, TIME_INFINITE);
    c16a:	4d 43       	clr.b	r13		;
    c16c:	b0 13 84 74 	calla	#29828		;0x07484

0000c170 <.LVL12>:
}
    c170:	10 01       	reta			;

0000c172 <fw>:
static inline msg_t uart_pass_i(uint8_t * buffer) {
  return elyUARTPostI(buffer);
}

static inline msg_t fw(uint8_t * buffer) {
  return elyMainMBPost(buffer, TIME_INFINITE);
    c172:	4d 43       	clr.b	r13		;
    c174:	b0 13 ac 7a 	calla	#31404		;0x07aac

0000c178 <.LVL14>:
}
    c178:	10 01       	reta			;

0000c17a <rf_pass>:
  return elyRFPost(buffer, TIME_INFINITE);
    c17a:	4d 43       	clr.b	r13		;
    c17c:	b0 13 64 b5 	calla	#46436		;0x0b564

0000c180 <.LVL16>:
}
    c180:	10 01       	reta			;

0000c182 <elyNLClampReg>:
uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    c182:	4e 4c       	mov.b	r12,	r14	;
    c184:	4c 4d       	mov.b	r13,	r12	;

0000c186 <.LVL24>:
  switch(addr) {
    c186:	7e 90 83 ff 	cmp.b	#-125,	r14	;#0xff83
    c18a:	33 24       	jz	$+104    	;abs 0xc1f2
    c18c:	7f 40 83 ff 	mov.b	#-125,	r15	;#0xff83
    c190:	4f 9e       	cmp.b	r14,	r15	;
    c192:	07 28       	jnc	$+16     	;abs 0xc1a2
    c194:	7e 90 80 ff 	cmp.b	#-128,	r14	;#0xff80
    c198:	1e 24       	jz	$+62     	;abs 0xc1d6
    c19a:	7e 90 81 ff 	cmp.b	#-127,	r14	;#0xff81
    c19e:	24 24       	jz	$+74     	;abs 0xc1e8

0000c1a0 <.L14>:
}
    c1a0:	10 01       	reta			;

0000c1a2 <.L16>:
  switch(addr) {
    c1a2:	7e 90 85 ff 	cmp.b	#-123,	r14	;#0xff85
    c1a6:	29 24       	jz	$+84     	;abs 0xc1fa
    c1a8:	7e 90 85 ff 	cmp.b	#-123,	r14	;#0xff85
    c1ac:	f9 2b       	jnc	$-12     	;abs 0xc1a0
    c1ae:	7e 50 79 00 	add.b	#121,	r14	;#0x0079
    c1b2:	5d 43       	mov.b	#1,	r13	;r3 As==01

0000c1b4 <.LVL27>:
    c1b4:	4d 9e       	cmp.b	r14,	r13	;
    c1b6:	f4 2b       	jnc	$-22     	;abs 0xc1a0

0000c1b8 <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    c1b8:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    c1bc:	10 00 
    c1be:	21 24       	jz	$+68     	;abs 0xc202
    c1c0:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    c1c4:	1e 24       	jz	$+62     	;abs 0xc202

0000c1c6 <.Loc.48.1>:
    elyErrorSignal(ErrRegClip);
    c1c6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c1ca <.LVL29>:
    c1ca:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c1ce <.LVL30>:
    return 0x10;
    c1ce:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    c1d2:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c1d6 <.L17>:
      value = clamp(value, 7, 0xFF);
    c1d6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    c1d8:	7d 40 07 00 	mov.b	#7,	r13	;

0000c1dc <.L60>:
      value = clamp(value, 0, 0x10);
    c1dc:	b0 13 3c c1 	calla	#49468		;0x0c13c

0000c1e0 <.LVL33>:
    c1e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c1e4 <.LVL34>:
      break;
    c1e4:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c1e8 <.L18>:
      value = clamp(value, 0, 0x10);
    c1e8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

0000c1ec <.L61>:
    c1ec:	4d 43       	clr.b	r13		;

0000c1ee <.LVL36>:
    c1ee:	80 00 dc c1 	mova	#49628,	r0	;0x0c1dc

0000c1f2 <.L15>:
      value = clamp(value, 0, 0x07);
    c1f2:	7e 40 07 00 	mov.b	#7,	r14	;
    c1f6:	80 00 ec c1 	mova	#49644,	r0	;0x0c1ec

0000c1fa <.L19>:
      value = clamp(value, 0, 0x3F);
    c1fa:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    c1fe:	80 00 ec c1 	mova	#49644,	r0	;0x0c1ec

0000c202 <.L21>:
  if ((value & 0x08) && value != 0x08) {
    c202:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    c206:	09 24       	jz	$+20     	;abs 0xc21a
    c208:	3c 92       	cmp	#8,	r12	;r2 As==11
    c20a:	07 24       	jz	$+16     	;abs 0xc21a

0000c20c <.Loc.52.1>:
    elyErrorSignal(ErrRegClip);
    c20c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c210 <.LVL39>:
    c210:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c214 <.LVL40>:
    return 0x08;
    c214:	7c 42       	mov.b	#8,	r12	;r2 As==11
    c216:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c21a <.L22>:
  if ((value & 0x04) && value != 0x04) {
    c21a:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    c21e:	09 24       	jz	$+20     	;abs 0xc232
    c220:	2c 92       	cmp	#4,	r12	;r2 As==10
    c222:	07 24       	jz	$+16     	;abs 0xc232

0000c224 <.Loc.56.1>:
    elyErrorSignal(ErrRegClip);
    c224:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c228 <.LVL42>:
    c228:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c22c <.LVL43>:
    return 0x04;
    c22c:	6c 42       	mov.b	#4,	r12	;r2 As==10
    c22e:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c232 <.L23>:
  if ((value & 0x02) && value != 0x02) {
    c232:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    c236:	09 24       	jz	$+20     	;abs 0xc24a
    c238:	2c 93       	cmp	#2,	r12	;r3 As==10
    c23a:	07 24       	jz	$+16     	;abs 0xc24a

0000c23c <.Loc.60.1>:
    elyErrorSignal(ErrRegClip);
    c23c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c240 <.LVL45>:
    c240:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c244 <.LVL46>:
    return 0x02;
    c244:	6c 43       	mov.b	#2,	r12	;r3 As==10
    c246:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c24a <.L24>:
  if ((value & 0x01) && value != 0x01) {
    c24a:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    c24e:	09 24       	jz	$+20     	;abs 0xc262
    c250:	1c 93       	cmp	#1,	r12	;r3 As==01
    c252:	07 24       	jz	$+16     	;abs 0xc262

0000c254 <.Loc.64.1>:
    elyErrorSignal(ErrRegClip);
    c254:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c258 <.LVL48>:
    c258:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c25c <.LVL49>:
    return 0x01;
    c25c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c25e:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c262 <.L25>:
  if (value & 0xD0) {
    c262:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    c266:	9c 27       	jz	$-198    	;abs 0xc1a0

0000c268 <.Loc.68.1>:
    elyErrorSignal(ErrRegClip);
    c268:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000c26c <.LVL51>:
    c26c:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c270 <.LVL52>:
    return 0x00;
    c270:	4c 43       	clr.b	r12		;
    c272:	80 00 a0 c1 	mova	#49568,	r0	;0x0c1a0

0000c276 <elyNLGetBuffer>:
  return chPoolAlloc(&main_mpool);
    c276:	8c 01 48 21 	mova	#74056,	r12	;0x12148
    c27a:	b0 13 fa 49 	calla	#18938		;0x049fa

0000c27e <.LVL60>:
}
    c27e:	10 01       	reta			;

0000c280 <elyNLFreeBuffer>:
  chPoolFree(&main_mpool, buffer);
    c280:	cd 0c       	mova	r12,	r13	;
    c282:	8c 01 48 21 	mova	#74056,	r12	;0x12148

0000c286 <.LVL62>:
    c286:	b0 13 1a 4a 	calla	#18970		;0x04a1a

0000c28a <.LVL63>:
}
    c28a:	10 01       	reta			;

0000c28c <nl_route>:
    msg_t (*loop_func)(uint8_t *)) {
    c28c:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000c28e <.LCFI6>:
    c28e:	06 14       	pushm.a	#1,	r6	;20-bit words

0000c290 <.LCFI7>:
    c290:	ca 0c       	mova	r12,	r10	;
    c292:	c6 0d       	mova	r13,	r6	;

0000c294 <.Loc.166.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    c294:	6b 4c       	mov.b	@r12,	r11	;

0000c296 <.LVL65>:
    c296:	0d 4b       	mov	r11,	r13	;

0000c298 <.LVL66>:
    c298:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c29c:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    c2a0:	59 4c 01 00 	mov.b	1(r12),	r9	;
    c2a4:	0d d9       	bis	r9,	r13	;

0000c2a6 <.Loc.167.1>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    c2a6:	28 01 2a 01 	mova	&65834,	r8	;0x1012a
    c2aa:	59 48 51 00 	mov.b	81(r8),	r9	;0x00051
    c2ae:	47 18 09 59 	rpt #8 { rlax.w	r9		;
    c2b2:	58 48 50 00 	mov.b	80(r8),	r8	;0x00050
    c2b6:	09 d8       	bis	r8,	r9	;

0000c2b8 <.Loc.171.1>:
  if (apid == elysium_apid) {
    c2b8:	0d 99       	cmp	r9,	r13	;
    c2ba:	15 20       	jnz	$+44     	;abs 0xc2e6

0000c2bc <.Loc.172.1>:
    if (tc) {
    c2bc:	40 18 3b b0 	bitx.w	#16,	r11	;0x00010
    c2c0:	10 00 
    c2c2:	0a 24       	jz	$+22     	;abs 0xc2d8

0000c2c4 <.Loc.173.1>:
      if (MSG_OK != fw_func(buffer)) {
    c2c4:	4e 13       	calla	r14		;

0000c2c6 <.L75>:
    c2c6:	9c 00 00 00 	cmpa	#0,	r12	;
    c2ca:	03 24       	jz	$+8      	;abs 0xc2d2

0000c2cc <.Loc.177.1>:
        elyNLFreeBuffer(buffer);
    c2cc:	cc 0a       	mova	r10,	r12	;
    c2ce:	b0 13 80 c2 	calla	#49792		;0x0c280

0000c2d2 <.L69>:
}
    c2d2:	06 16       	popm.a	#1,	r6	;20-bit words
    c2d4:	28 16       	popm.a	#3,	r10	;20-bit words
    c2d6:	10 01       	reta			;

0000c2d8 <.L71>:
      buffer[0] |= 0x10; /* set apid to free properly */
    c2d8:	7b d0 10 00 	bis.b	#16,	r11	;#0x0010

0000c2dc <.LVL70>:
    c2dc:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

0000c2e0 <.LVL71>:
      if (MSG_OK != loop_func(buffer)) {
    c2e0:	4f 13       	calla	r15		;

0000c2e2 <.LVL72>:
    c2e2:	80 00 c6 c2 	mova	#49862,	r0	;0x0c2c6

0000c2e6 <.L70>:
  if (MSG_OK != pass_func(buffer)) {
    c2e6:	46 13       	calla	r6		;

0000c2e8 <.LVL74>:
    c2e8:	80 00 c6 c2 	mova	#49862,	r0	;0x0c2c6

0000c2ec <elyNLGetBufferI>:
  return chPoolAllocI(&main_mpool);
    c2ec:	8c 01 48 21 	mova	#74056,	r12	;0x12148
    c2f0:	b0 13 ce 49 	calla	#18894		;0x049ce

0000c2f4 <.LVL75>:
}
    c2f4:	10 01       	reta			;

0000c2f6 <elyNLRouteUART>:
static inline msg_t fw_i(uint8_t * buffer) {
  return elyMainMBPostI(buffer);
}

void elyNLRouteUART(uint8_t * buffer) {
  nl_route(buffer, rf_pass, fw, uart_pass);
    c2f6:	8f 00 6a c1 	mova	#49514,	r15	;0x0c16a
    c2fa:	8e 00 72 c1 	mova	#49522,	r14	;0x0c172
    c2fe:	8d 00 7a c1 	mova	#49530,	r13	;0x0c17a
    c302:	b0 13 8c c2 	calla	#49804		;0x0c28c

0000c306 <.LVL80>:
}
    c306:	10 01       	reta			;

0000c308 <elyNLRouteRF>:

void elyNLRouteRF(uint8_t * buffer) {
  nl_route(buffer, uart_pass, fw, rf_pass);
    c308:	8f 00 7a c1 	mova	#49530,	r15	;0x0c17a
    c30c:	8e 00 72 c1 	mova	#49522,	r14	;0x0c172
    c310:	8d 00 6a c1 	mova	#49514,	r13	;0x0c16a
    c314:	b0 13 8c c2 	calla	#49804		;0x0c28c

0000c318 <.LVL82>:
}
    c318:	10 01       	reta			;

0000c31a <elyNLGetDest>:
  (void)(buffer);
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (dest_addr == ground_apid) {
    c31a:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a

0000c31e <.LVL87>:
    c31e:	5e 4c 83 00 	mov.b	131(r12),r14	;0x00083
    c322:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c326:	5c 4c 82 00 	mov.b	130(r12),r12	;0x00082
    c32a:	0e dc       	bis	r12,	r14	;
    c32c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c32e:	0e 9d       	cmp	r13,	r14	;
    c330:	01 24       	jz	$+4      	;abs 0xc334
    c332:	4c 43       	clr.b	r12		;

0000c334 <.L83>:
    return ELY_DEST_RF;
  }
  
  return ELY_DEST_UART;
}
    c334:	10 01       	reta			;

0000c336 <is_fw_buf>:

bool is_fw_buf(uint8_t * buffer) {
    c336:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c338 <.LCFI8>:
   * If (TM AND APID == Elysium) FW Reply
   * If (TC AND APID == Elysium) Coding error
   * Else NL packet */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    c338:	6d 4c       	mov.b	@r12,	r13	;

0000c33a <.LVL89>:
    c33a:	0e 4d       	mov	r13,	r14	;
    c33c:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c340:	3e f0 00 07 	and	#1792,	r14	;#0x0700
    c344:	5c 4c 01 00 	mov.b	1(r12),	r12	;

0000c348 <.LVL90>:
    c348:	0c de       	bis	r14,	r12	;

0000c34a <.LVL91>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    c34a:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    c34e:	5e 4a 51 00 	mov.b	81(r10),r14	;0x00051
    c352:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c356:	5a 4a 50 00 	mov.b	80(r10),r10	;0x00050
    c35a:	0e da       	bis	r10,	r14	;

0000c35c <.Loc.271.1>:
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (apid == elysium_apid) {
    c35c:	0c 9e       	cmp	r14,	r12	;
    c35e:	06 20       	jnz	$+14     	;abs 0xc36c

0000c360 <.Loc.272.1>:
    if (!tc) {
    c360:	0c 4d       	mov	r13,	r12	;
    c362:	5c 0f       	rrum	#4,	r12	;
    c364:	5c e3       	xor.b	#1,	r12	;r3 As==01
    c366:	5c f3       	and.b	#1,	r12	;r3 As==01

0000c368 <.L85>:
      /* Fall through to NL to allow loopback */
    }
  }
  
  return false;
}
    c368:	0a 16       	popm.a	#1,	r10	;20-bit words
    c36a:	10 01       	reta			;

0000c36c <.L86>:
  return false;
    c36c:	4c 43       	clr.b	r12		;
    c36e:	80 00 68 c3 	mova	#50024,	r0	;0x0c368

0000c372 <elyNLFreeBufferChecked>:
  
void elyNLFreeBufferChecked(uint8_t * buffer) {
    c372:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c374 <.LCFI9>:
    c374:	ca 0c       	mova	r12,	r10	;

0000c376 <.Loc.284.1>:
  if (is_fw_buf(buffer)) {
    c376:	b0 13 36 c3 	calla	#49974		;0x0c336

0000c37a <.LVL93>:
    c37a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    c37c:	05 24       	jz	$+12     	;abs 0xc388

0000c37e <.Loc.285.1>:
      elyFWFreeBuffer(buffer);
    c37e:	cc 0a       	mova	r10,	r12	;
    c380:	b0 13 da 77 	calla	#30682		;0x077da

0000c384 <.L87>:
  }
  else {
    elyNLFreeBuffer(buffer);
  }
}
    c384:	0a 16       	popm.a	#1,	r10	;20-bit words
    c386:	10 01       	reta			;

0000c388 <.L88>:
    elyNLFreeBuffer(buffer);
    c388:	cc 0a       	mova	r10,	r12	;
    c38a:	b0 13 80 c2 	calla	#49792		;0x0c280

0000c38e <.LVL95>:
}
    c38e:	80 00 84 c3 	mova	#50052,	r0	;0x0c384

0000c392 <elyNLInit>:
}

void elyNLInit(void) {
  uint8_t options = bank0p[RegNLOptions];
  
  chPoolObjectInit(&main_mpool, elyNLMaxLen, nl_allocator);
    c392:	8e 00 16 c1 	mova	#49430,	r14	;0x0c116
    c396:	2d 00 62 d7 	mova	&55138,	r13	;0x0d762
    c39a:	8c 01 48 21 	mova	#74056,	r12	;0x12148
    c39e:	b0 13 9a 49 	calla	#18842		;0x0499a

0000c3a2 <.LVL101>:
      /* 4-byte Secondary Header + 6-byte Primary Header */
      sh_len = 4;
    }
  }
  
  sh_len = 0;
    c3a2:	01 18 c2 43 	movx.a	#0,	&0x12154;r3 As==00
    c3a6:	54 21 

0000c3a8 <.Loc.318.1>:
}
    c3a8:	10 01       	reta			;

0000c3aa <elyNLSetHeader>:

void elyNLSetHeader(uint8_t * buffer, uint16_t length, uint16_t dest_addr) {
    c3aa:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c3ac <.LCFI11>:
  /* dest_addr not used for SPP */
  (void)(dest_addr);
  
  /* Set APID */
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
    c3ac:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a

0000c3b0 <.LVL103>:
    c3b0:	5f 4e 51 00 	mov.b	81(r14),r15	;0x00051
    c3b4:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    c3b8:	5a 4e 50 00 	mov.b	80(r14),r10	;0x00050
    c3bc:	0f da       	bis	r10,	r15	;

0000c3be <.LVL104>:
        (bank0p[RegSrcAddrLsb])) );
  buffer[0] = (elysium_apid >> 8);
    c3be:	0b 4f       	mov	r15,	r11	;
    c3c0:	5b 0f       	rrum	#4,	r11	;
    c3c2:	5b 0f       	rrum	#4,	r11	;
    c3c4:	cc 4b 00 00 	mov.b	r11,	0(r12)	;

0000c3c8 <.Loc.328.1>:
  buffer[1] = (elysium_apid & 0xFF);
    c3c8:	cc 4f 01 00 	mov.b	r15,	1(r12)	;

0000c3cc <.Loc.330.1>:
  
  length = (length + sh_len - 1);
    c3cc:	c0 18 1f 42 	movx.w	&0x12154,r15	;
    c3d0:	54 21 

0000c3d2 <.LVL105>:
    c3d2:	3f 53       	add	#-1,	r15	;r3 As==11
    c3d4:	0d 5f       	add	r15,	r13	;

0000c3d6 <.LVL106>:
  buffer[4] = (length >> 8);
    c3d6:	0f 4d       	mov	r13,	r15	;
    c3d8:	5f 0f       	rrum	#4,	r15	;
    c3da:	5f 0f       	rrum	#4,	r15	;
    c3dc:	cc 4f 04 00 	mov.b	r15,	4(r12)	;

0000c3e0 <.Loc.332.1>:
  buffer[5] = (length & 0xFF);
    c3e0:	cc 4d 05 00 	mov.b	r13,	5(r12)	;

0000c3e4 <.Loc.334.1>:
  
  uint8_t options = bank0p[RegNLOptions];
    c3e4:	5d 4e 86 00 	mov.b	134(r14),r13	;0x00086

0000c3e8 <.LVL107>:
  
  if (options & 0x04) {
    c3e8:	40 18 2d b2 	bitx.w	#4,	r13	;r2 As==10
    c3ec:	36 24       	jz	$+110    	;abs 0xc45a

0000c3ee <.LBB21>:
  _disable_interrupts();
    c3ee:	32 c2       	dint			
    c3f0:	03 43       	nop			

0000c3f2 <.Loc.348.2>:
  asm volatile("nop");
    c3f2:	03 43       	nop			

0000c3f4 <.LBE21>:
    chSysLock();
    buffer[2] = bank0p[RegNLPktNameMsb];
    c3f4:	dc 4e 85 00 	mov.b	133(r14),2(r12)	;0x00085
    c3f8:	02 00 

0000c3fa <.LVL108>:
    buffer[3] = bank0p[RegNLPktNameLsb];
    c3fa:	dc 4e 84 00 	mov.b	132(r14),3(r12)	;0x00084
    c3fe:	03 00 

0000c400 <.LBB23>:
  asm volatile("nop");
    c400:	03 43       	nop			

0000c402 <.Loc.356.2>:
  _enable_interrupts();
    c402:	03 43       	nop			
    c404:	32 d2       	eint			
    c406:	03 43       	nop			

0000c408 <.L96>:
  else {
    buffer[2] = (packets_sent >> 8) | 0xC0;
    buffer[3] = (packets_sent & 0xFF);
  }
  
  packets_sent = (packets_sent + 1) & 0x3FFF;
    c408:	40 18 1f 42 	movx.w	&0x0d75e,r15	;
    c40c:	5e d7 
    c40e:	1f 53       	inc	r15		;
    c410:	3f f0 ff 3f 	and	#16383,	r15	;#0x3fff
    c414:	40 18 82 4f 	movx.w	r15,	&0xfd75e;
    c418:	5e d7 

0000c41a <.Loc.350.1>:
  
  /* insert timestamps here too if required */
  if (options & 0x02) { /* Timestamp */
    c41a:	40 18 2d b3 	bitx.w	#2,	r13	;r3 As==10
    c41e:	1b 24       	jz	$+56     	;abs 0xc456

0000c420 <.Loc.351.1>:
    buffer[0] |= 0x08; /* Sec Hdr Flag */
    c420:	fc d2 00 00 	bis.b	#8,	0(r12)	;r2 As==11

0000c424 <.Loc.352.1>:
    if (options & 0x01) { /* P-field */
    c424:	40 18 1d b3 	bitx.w	#1,	r13	;r3 As==01
    c428:	26 24       	jz	$+78     	;abs 0xc476

0000c42a <.Loc.353.1>:
      buffer[6] = SPP_PFIELD;
    c42a:	fc 40 2c 00 	mov.b	#44,	6(r12)	;#0x002c
    c42e:	06 00 

0000c430 <.LBB25>:
  _disable_interrupts();
    c430:	32 c2       	dint			
    c432:	03 43       	nop			

0000c434 <.Loc.348.2>:
  asm volatile("nop");
    c434:	03 43       	nop			

0000c436 <.LBE25>:
      chSysLock();
      buffer[7] = bank0p[RegMissionTimeMsb];
    c436:	dc 4e 76 00 	mov.b	118(r14),7(r12)	;0x00076
    c43a:	07 00 

0000c43c <.Loc.356.1>:
      buffer[8] = bank0p[RegMissionTimeHmb];
    c43c:	dc 4e 75 00 	mov.b	117(r14),8(r12)	;0x00075
    c440:	08 00 

0000c442 <.Loc.357.1>:
      buffer[9] = bank0p[RegMissionTimeLmb];
    c442:	dc 4e 74 00 	mov.b	116(r14),9(r12)	;0x00074
    c446:	09 00 

0000c448 <.Loc.358.1>:
      buffer[10] = bank0p[RegMissionTimeLsb];
    c448:	dc 4e 73 00 	mov.b	115(r14),10(r12)	;0x00073, 0x000a
    c44c:	0a 00 

0000c44e <.L102>:
  asm volatile("nop");
    c44e:	03 43       	nop			

0000c450 <.Loc.356.2>:
  _enable_interrupts();
    c450:	03 43       	nop			
    c452:	32 d2       	eint			
    c454:	03 43       	nop			

0000c456 <.L94>:
      chSysUnlock();
    }
  }
  
  return;
}
    c456:	0a 16       	popm.a	#1,	r10	;20-bit words
    c458:	10 01       	reta			;

0000c45a <.L95>:
    buffer[2] = (packets_sent >> 8) | 0xC0;
    c45a:	40 18 1f 42 	movx.w	&0x0d75e,r15	;
    c45e:	5e d7 
    c460:	0b 4f       	mov	r15,	r11	;
    c462:	5b 0f       	rrum	#4,	r11	;
    c464:	5b 0f       	rrum	#4,	r11	;
    c466:	7b d0 c0 ff 	bis.b	#-64,	r11	;#0xffc0
    c46a:	cc 4b 02 00 	mov.b	r11,	2(r12)	;

0000c46e <.LVL110>:
    buffer[3] = (packets_sent & 0xFF);
    c46e:	cc 4f 03 00 	mov.b	r15,	3(r12)	;
    c472:	80 00 08 c4 	mova	#50184,	r0	;0x0c408

0000c476 <.L98>:
  _disable_interrupts();
    c476:	32 c2       	dint			
    c478:	03 43       	nop			

0000c47a <.Loc.348.2>:
  asm volatile("nop");
    c47a:	03 43       	nop			

0000c47c <.LBE29>:
      buffer[6] = bank0p[RegMissionTimeMsb];
    c47c:	dc 4e 76 00 	mov.b	118(r14),6(r12)	;0x00076
    c480:	06 00 

0000c482 <.Loc.366.1>:
      buffer[7] = bank0p[RegMissionTimeHmb];
    c482:	dc 4e 75 00 	mov.b	117(r14),7(r12)	;0x00075
    c486:	07 00 

0000c488 <.Loc.367.1>:
      buffer[8] = bank0p[RegMissionTimeLmb];
    c488:	dc 4e 74 00 	mov.b	116(r14),8(r12)	;0x00074
    c48c:	08 00 

0000c48e <.Loc.368.1>:
      buffer[9] = bank0p[RegMissionTimeLsb];
    c48e:	dc 4e 73 00 	mov.b	115(r14),9(r12)	;0x00073
    c492:	09 00 
    c494:	80 00 4e c4 	mova	#50254,	r0	;0x0c44e

0000c498 <elyNLGetLength>:

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    c498:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    c49c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c4a0:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000c4a4 <.LVL112>:
    c4a4:	0c dd       	bis	r13,	r12	;
    c4a6:	3c 50 07 00 	add	#7,	r12	;
    c4aa:	4c 0e       	rlam.a	#4,	r12	;
    c4ac:	4c 0d       	rram.a	#4,	r12	;

0000c4ae <.Loc.378.1>:
}
    c4ae:	10 01       	reta			;

0000c4b0 <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    c4b0:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000c4b2 <.LCFI12>:
  if (buffer[0] & 0xE0) {
    c4b2:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    c4b6:	00 00 
    c4b8:	07 24       	jz	$+16     	;abs 0xc4c8

0000c4ba <.Loc.139.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    c4ba:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000c4be <.L108>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    c4be:	b0 13 28 a7 	calla	#42792		;0x0a728

0000c4c2 <.LVL115>:
    return false;
    c4c2:	4c 43       	clr.b	r12		;

0000c4c4 <.L106>:
}
    c4c4:	0a 16       	popm.a	#1,	r10	;20-bit words
    c4c6:	10 01       	reta			;

0000c4c8 <.L105>:
  _disable_interrupts();
    c4c8:	32 c2       	dint			
    c4ca:	03 43       	nop			

0000c4cc <.Loc.348.2>:
  asm volatile("nop");
    c4cc:	03 43       	nop			

0000c4ce <.LBE37>:
  if ( elyNLGetLength(buffer) > 
    c4ce:	b0 13 98 c4 	calla	#50328		;0x0c498

0000c4d2 <.LVL117>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    c4d2:	2a 01 2a 01 	mova	&65834,	r10	;0x1012a
    c4d6:	5e 4a 81 00 	mov.b	129(r10),r14	;0x00081
    c4da:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    c4de:	5a 4a 80 00 	mov.b	128(r10),r10	;0x00080
    c4e2:	0e da       	bis	r10,	r14	;
    c4e4:	40 18 0e 4e 	movx.w	r14,	r14	;

0000c4e8 <.Loc.145.1>:
  if ( elyNLGetLength(buffer) > 
    c4e8:	de 0c       	cmpa	r12,	r14	;
    c4ea:	08 2c       	jc	$+18     	;abs 0xc4fc

0000c4ec <.LBB39>:
  asm volatile("nop");
    c4ec:	03 43       	nop			

0000c4ee <.Loc.356.2>:
  _enable_interrupts();
    c4ee:	03 43       	nop			
    c4f0:	32 d2       	eint			
    c4f2:	03 43       	nop			

0000c4f4 <.LBE39>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    c4f4:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    c4f8:	80 00 be c4 	mova	#50366,	r0	;0x0c4be

0000c4fc <.L107>:
  asm volatile("nop");
    c4fc:	03 43       	nop			

0000c4fe <.Loc.356.2>:
  _enable_interrupts();
    c4fe:	03 43       	nop			
    c500:	32 d2       	eint			
    c502:	03 43       	nop			

0000c504 <.LBE41>:
  return true;
    c504:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c506:	80 00 c4 c4 	mova	#50372,	r0	;0x0c4c4

0000c50a <elyNLToFW>:
size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - sh_len + 1;
}

uint8_t * elyNLToFW(uint8_t * buffer) {
  return buffer + sh_len + 6;
    c50a:	2e 01 54 21 	mova	&74068,	r14	;0x12154
    c50e:	ae 00 06 00 	adda	#6,	r14	;

0000c512 <.Loc.386.1>:
}
    c512:	ec 0e       	adda	r14,	r12	;

0000c514 <.LVL121>:
    c514:	10 01       	reta			;

0000c516 <elyNLFromFW>:

uint8_t * elyNLFromFW(uint8_t * buffer) {
  return buffer - sh_len - 6;
    c516:	8e 0f fa ff 	mova	#-6,	r14	;0xfffffffa
    c51a:	80 18 5e 82 	subx.a	&0x12154,r14	;
    c51e:	54 21 

0000c520 <.Loc.390.1>:
}
    c520:	ec 0e       	adda	r14,	r12	;

0000c522 <.LVL123>:
    c522:	10 01       	reta			;

0000c524 <elyPA_OC_fault_CB>:
}

void elyPA_OC_fault_CB(void)
{

  palClearLine(LINE_PA_PC_EN);
    c524:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    c528:	ff ef 22 02 

0000c52c <.Loc.502.1>:
  palLineDisableEventI(LINE_PA_PGOOD);
    c52c:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    c530:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    c534:	b0 13 34 59 	calla	#22836		;0x05934

0000c538 <.LVL0>:
  elyErrorSignalI(ErrPAOvercurrent);
    c538:	7c 40 86 ff 	mov.b	#-122,	r12	;#0xff86
    c53c:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000c540 <.LVL1>:

  switch(PA_OC_fault_state)
    c540:	41 18 c2 93 	cmpx.b	#0,	&0x13962;r3 As==00
    c544:	62 39 
    c546:	0c 20       	jnz	$+26     	;abs 0xc560

0000c548 <.Loc.508.1>:
  {
      case PA_OC_NO_FAULT:
          PA_OC_faults++;
    c548:	41 18 d2 53 	incx.b	&0x13960		;
    c54c:	60 39 

0000c54e <.Loc.510.1>:
          chSysLockFromISR();
          chEvtSignalI(rf_thd,RFCheckFaults); //Wakeup fault routine to check for/respond to faults
    c54e:	4d 43       	clr.b	r13		;
    c550:	6e 43       	mov.b	#2,	r14	;r3 As==10
    c552:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    c556:	b0 13 ec 47 	calla	#18412		;0x047ec

0000c55a <.LVL2>:
          chSysUnlockFromISR();
          PA_OC_fault_state =  PA_OC_IMMEDIATE_FAULT_TEST;
    c55a:	41 18 d2 43 	movx.b	#1,	&0x13962;r3 As==01
    c55e:	62 39 

0000c560 <.L1>:
      break;
  }

}
    c560:	10 01       	reta			;

0000c562 <LNA_OC_Fault_Handler>:
{
    c562:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000c564 <.LCFI0>:
    c564:	09 4c       	mov	r12,	r9	;
    c566:	0a 4d       	mov	r13,	r10	;

0000c568 <.Loc.80.1>:
    switch(LNA_OC_fault_state)
    c568:	c0 18 5c 42 	movx.b	&0x13961,r12	;
    c56c:	61 39 

0000c56e <.LVL4>:
    c56e:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    c570:	06 24       	jz	$+14     	;abs 0xc57e
    c572:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    c574:	46 24       	jz	$+142    	;abs 0xc602

0000c576 <.L5>:
}
    c576:	0c 49       	mov	r9,	r12	;
    c578:	0d 4a       	mov	r10,	r13	;
    c57a:	64 16       	popm.a	#7,	r10	;20-bit words
    c57c:	10 01       	reta			;

0000c57e <.L6>:
            sx1278Stop(&SX1278D1);
    c57e:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    c582:	b0 13 f0 68 	calla	#26864		;0x068f0

0000c586 <.LVL7>:
            chThdSleep(5);
    c586:	88 00 10 47 	mova	#18192,	r8	;0x04710
    c58a:	7c 40 05 00 	mov.b	#5,	r12	;
    c58e:	48 13       	calla	r8		;

0000c590 <.LVL8>:
                chThdSleep(1);
    c590:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c592 <.Loc.93.1>:
                    elyErrorSignalI(ErrLNAOvercurrent);
    c592:	86 00 2a a7 	mova	#42794,	r6	;0x0a72a
    c596:	77 40 85 ff 	mov.b	#-123,	r7	;#0xff85

0000c59a <.L8>:
            while(LNA_OC_faults < MAX_LNA_OC_FAULTS)
    c59a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    c59c:	c0 18 5c 92 	cmpx.b	&0x1395f,r12	;
    c5a0:	5f 39 
    c5a2:	06 2c       	jc	$+14     	;abs 0xc5b0

0000c5a4 <.Loc.106.1>:
            events &= ~(RFTxIdle);
    c5a4:	1a c3       	bic	#1,	r10	;r3 As==01

0000c5a6 <.LVL9>:
            LNA_OC_fault_state = LNA_OC_PERMANENT_OFF;
    c5a6:	41 18 e2 43 	movx.b	#2,	&0x13961;r3 As==10
    c5aa:	61 39 

0000c5ac <.Loc.108.1>:
            return(events);
    c5ac:	80 00 76 c5 	mova	#50550,	r0	;0x0c576

0000c5b0 <.L10>:
                palSetLine(LINE_LNA_PC_EN);
    c5b0:	40 18 a2 d2 	bisx.w	#4,	&0x00322;r2 As==10
    c5b4:	22 03 

0000c5b6 <.Loc.88.1>:
                chThdSleep(1);
    c5b6:	0c 45       	mov	r5,	r12	;
    c5b8:	48 13       	calla	r8		;

0000c5ba <.LVL11>:
                if(ADC12IFGR2 & ADC12LOIFG)
    c5ba:	40 18 14 42 	movx.w	&0x00810,r4	;
    c5be:	10 08 
    c5c0:	64 f2       	and.b	#4,	r4	;r2 As==10
    c5c2:	04 93       	cmp	#0,	r4	;r3 As==00
    c5c4:	0d 24       	jz	$+28     	;abs 0xc5e0

0000c5c6 <.Loc.91.1>:
                    palClearLine(LINE_LNA_PC_EN);
    c5c6:	40 18 a2 c2 	bicx.w	#4,	&0x00322;r2 As==10
    c5ca:	22 03 

0000c5cc <.Loc.92.1>:
                    LNA_OC_faults++;
    c5cc:	41 18 d2 53 	incx.b	&0x1395f		;
    c5d0:	5f 39 

0000c5d2 <.Loc.93.1>:
                    elyErrorSignalI(ErrLNAOvercurrent);
    c5d2:	4c 47       	mov.b	r7,	r12	;
    c5d4:	46 13       	calla	r6		;

0000c5d6 <.LVL12>:
                    chThdSleep(5);
    c5d6:	7c 40 05 00 	mov.b	#5,	r12	;
    c5da:	48 13       	calla	r8		;

0000c5dc <.LVL13>:
    c5dc:	80 00 9a c5 	mova	#50586,	r0	;0x0c59a

0000c5e0 <.L9>:
                    sx1278Start(&SX1278D1, tx_cfg_ptr);
    c5e0:	2d 01 1c 21 	mova	&74012,	r13	;0x1211c
    c5e4:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    c5e8:	b0 13 ae 67 	calla	#26542		;0x067ae

0000c5ec <.LVL14>:
                    ADC12IER2 &= ~ADC12LOIE;
    c5ec:	40 18 a2 c2 	bicx.w	#4,	&0x00816;r2 As==10
    c5f0:	16 08 

0000c5f2 <.Loc.101.1>:
                    LNA_OC_faults = 0;
    c5f2:	41 18 c2 44 	movx.b	r4,	&0x1395f;
    c5f6:	5f 39 

0000c5f8 <.Loc.102.1>:
                    LNA_OC_fault_state = LNA_OC_NO_FAULT;
    c5f8:	41 18 c2 44 	movx.b	r4,	&0x13961;
    c5fc:	61 39 

0000c5fe <.Loc.103.1>:
                    return(events);
    c5fe:	80 00 76 c5 	mova	#50550,	r0	;0x0c576

0000c602 <.L7>:
            events &= ~(RFTxIdle);
    c602:	1a c3       	bic	#1,	r10	;r3 As==01

0000c604 <.LVL15>:
        break;
    c604:	80 00 76 c5 	mova	#50550,	r0	;0x0c576

0000c608 <PA_OC_Fault_Handler>:
{
    c608:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c60a <.LCFI1>:
    c60a:	07 4c       	mov	r12,	r7	;
    c60c:	09 4d       	mov	r13,	r9	;

0000c60e <.Loc.119.1>:
    switch(PA_OC_fault_state)
    c60e:	c0 18 5c 42 	movx.b	&0x13962,r12	;
    c612:	62 39 

0000c614 <.LVL17>:
    c614:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    c616:	06 24       	jz	$+14     	;abs 0xc624
    c618:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    c61a:	4c 24       	jz	$+154    	;abs 0xc6b4

0000c61c <.L12>:
}
    c61c:	0c 47       	mov	r7,	r12	;
    c61e:	0d 49       	mov	r9,	r13	;
    c620:	55 16       	popm.a	#6,	r10	;20-bit words
    c622:	10 01       	reta			;

0000c624 <.L13>:
            sx1278Stop(&SX1278D1);
    c624:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    c628:	b0 13 f0 68 	calla	#26864		;0x068f0

0000c62c <.LVL20>:
            chThdSleep(5);
    c62c:	8a 00 10 47 	mova	#18192,	r10	;0x04710
    c630:	7c 40 05 00 	mov.b	#5,	r12	;
    c634:	4a 13       	calla	r10		;

0000c636 <.LVL21>:
                chThdSleep(1);
    c636:	55 43       	mov.b	#1,	r5	;r3 As==01

0000c638 <.Loc.128.1>:
                if(palReadLine(LINE_PA_PGOOD))
    c638:	36 40 00 02 	mov	#512,	r6	;#0x0200

0000c63c <.Loc.141.1>:
                    elyErrorSignalI(ErrPAOvercurrent);
    c63c:	88 00 2a a7 	mova	#42794,	r8	;0x0a72a

0000c640 <.L15>:
            while(PA_OC_faults < MAX_PA_OC_FAULTS)
    c640:	6c 42       	mov.b	#4,	r12	;r2 As==10
    c642:	c0 18 5c 92 	cmpx.b	&0x13960,r12	;
    c646:	60 39 
    c648:	06 2c       	jc	$+14     	;abs 0xc656

0000c64a <.Loc.145.1>:
            events &= ~(RFTxIdle);
    c64a:	19 c3       	bic	#1,	r9	;r3 As==01

0000c64c <.LVL22>:
            PA_OC_fault_state = PA_OC_PERMANENT_OFF;
    c64c:	41 18 e2 43 	movx.b	#2,	&0x13962;r3 As==10
    c650:	62 39 

0000c652 <.Loc.147.1>:
            return(events);
    c652:	80 00 1c c6 	mova	#50716,	r0	;0x0c61c

0000c656 <.L17>:
                palSetLine(LINE_PA_PC_EN);
    c656:	40 18 b2 d0 	bisx.w	#4096,	&0x00222;0x01000
    c65a:	00 10 22 02 

0000c65e <.Loc.127.1>:
                chThdSleep(1);
    c65e:	0c 45       	mov	r5,	r12	;
    c660:	4a 13       	calla	r10		;

0000c662 <.LVL24>:
                if(palReadLine(LINE_PA_PGOOD))
    c662:	2c 46       	mov	@r6,	r12	;
    c664:	0c 93       	cmp	#0,	r12	;r3 As==00
    c666:	17 34       	jge	$+48     	;abs 0xc696

0000c668 <.Loc.130.1>:
                    sx1278Start(&SX1278D1, tx_cfg_ptr);
    c668:	2d 01 1c 21 	mova	&74012,	r13	;0x1211c
    c66c:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    c670:	b0 13 ae 67 	calla	#26542		;0x067ae

0000c674 <.LVL25>:
                    palLineEnableEventI(LINE_PA_PGOOD, PAL_EVENT_MODE_FALLING_EDGE,  elyPA_OC_fault_CB);
    c674:	8f 00 24 c5 	mova	#50468,	r15	;0x0c524
    c678:	6e 43       	mov.b	#2,	r14	;r3 As==10
    c67a:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    c67e:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    c682:	b0 13 46 58 	calla	#22598		;0x05846

0000c686 <.LVL26>:
                    PA_OC_faults = 0;
    c686:	41 18 c2 43 	movx.b	#0,	&0x13960;r3 As==00
    c68a:	60 39 

0000c68c <.Loc.134.1>:
                    PA_OC_fault_state = PA_OC_NO_FAULT;
    c68c:	41 18 c2 43 	movx.b	#0,	&0x13962;r3 As==00
    c690:	62 39 

0000c692 <.Loc.135.1>:
                    return(events);
    c692:	80 00 1c c6 	mova	#50716,	r0	;0x0c61c

0000c696 <.L16>:
                    palClearLine(LINE_PA_PC_EN);
    c696:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    c69a:	ff ef 22 02 

0000c69e <.Loc.140.1>:
                    PA_OC_faults++;
    c69e:	41 18 d2 53 	incx.b	&0x13960		;
    c6a2:	60 39 

0000c6a4 <.Loc.141.1>:
                    elyErrorSignalI(ErrPAOvercurrent);
    c6a4:	7c 40 86 ff 	mov.b	#-122,	r12	;#0xff86
    c6a8:	48 13       	calla	r8		;

0000c6aa <.LVL27>:
                    chThdSleep(5);
    c6aa:	7c 40 05 00 	mov.b	#5,	r12	;
    c6ae:	4a 13       	calla	r10		;

0000c6b0 <.LVL28>:
    c6b0:	80 00 40 c6 	mova	#50752,	r0	;0x0c640

0000c6b4 <.L14>:
            events &= ~(RFTxIdle);
    c6b4:	19 c3       	bic	#1,	r9	;r3 As==01

0000c6b6 <.LVL29>:
        break;
    c6b6:	80 00 1c c6 	mova	#50716,	r0	;0x0c61c

0000c6ba <SCC_Fault_Handler>:
{
    c6ba:	1a 14       	pushm.a	#2,	r10	;20-bit words

0000c6bc <.LCFI2>:
    c6bc:	0a 4c       	mov	r12,	r10	;
    c6be:	09 4d       	mov	r13,	r9	;

0000c6c0 <.Loc.370.1>:
    RegSCCommTime = ( ((uint32_t)(bank0p[RegSCCommTimeLsb])) |
    c6c0:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a

0000c6c4 <.LVL31>:
    switch(state)
    c6c4:	40 18 5c 42 	movx.b	&0x0d766,r12	;
    c6c8:	66 d7 

0000c6ca <.LVL32>:
    c6ca:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    c6cc:	67 24       	jz	$+208    	;abs 0xc79c
    c6ce:	6d 43       	mov.b	#2,	r13	;r3 As==10
    c6d0:	4d 9c       	cmp.b	r12,	r13	;
    c6d2:	08 28       	jnc	$+18     	;abs 0xc6e4
    c6d4:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    c6d6:	18 24       	jz	$+50     	;abs 0xc708
    c6d8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    c6da:	39 24       	jz	$+116    	;abs 0xc74e

0000c6dc <.L19>:
}
    c6dc:	0c 4a       	mov	r10,	r12	;
    c6de:	0d 49       	mov	r9,	r13	;
    c6e0:	19 16       	popm.a	#2,	r10	;20-bit words
    c6e2:	10 01       	reta			;

0000c6e4 <.L21>:
    switch(state)
    c6e4:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    c6e6:	6b 24       	jz	$+216    	;abs 0xc7be
    c6e8:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    c6ea:	74 28       	jnc	$+234    	;abs 0xc7d4
    c6ec:	7c 90 05 00 	cmp.b	#5,	r12	;
    c6f0:	f5 23       	jnz	$-20     	;abs 0xc6dc

0000c6f2 <.Loc.424.1>:
            if(UARTValidPacketFlag == TRUE)
    c6f2:	40 18 d2 93 	cmpx.b	#1,	&0xfd76a;r3 As==01
    c6f6:	6a d7 
    c6f8:	77 20       	jnz	$+240    	;abs 0xc7e8

0000c6fa <.Loc.426.1>:
                events &= ~UARTUseFallbackBaudrate; //stop enforcing fallback baudrate
    c6fa:	3a f0 ff df 	and	#-8193,	r10	;#0xdfff

0000c6fe <.LVL35>:
                state = SCCF_CHECK_FOR_FAULT;
    c6fe:	40 18 c2 43 	movx.b	#0,	&0xfd766;r3 As==00
    c702:	66 d7 
    c704:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c708 <.L22>:
    RegSCCommTime = ( ((uint32_t)(bank0p[RegSCCommTimeLsb])) |
    c708:	5d 4e 35 00 	mov.b	53(r14),r13	;0x00035
    c70c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c710:	5c 4e 34 00 	mov.b	52(r14),r12	;0x00034
    c714:	0d dc       	bis	r12,	r13	;
    c716:	5c 4e 37 00 	mov.b	55(r14),r12	;0x00037
    c71a:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    c71e:	5e 4e 36 00 	mov.b	54(r14),r14	;0x00036

0000c722 <.LVL37>:
    c722:	0c de       	bis	r14,	r12	;

0000c724 <.Loc.378.1>:
            if(UARTLastValidPacketTimer > RegSCCommTime)
    c724:	c0 18 1c 92 	cmpx.w	&0x1396a,r12	;
    c728:	6a 39 
    c72a:	08 28       	jnc	$+18     	;abs 0xc73c
    c72c:	41 18 82 9c 	cmpx.w	r12,	&0x1396a;
    c730:	6a 39 
    c732:	d4 23       	jnz	$-86     	;abs 0xc6dc
    c734:	c0 18 1d 92 	cmpx.w	&0x13968,r13	;
    c738:	68 39 
    c73a:	d0 2f       	jc	$-94     	;abs 0xc6dc

0000c73c <.L32>:
                state = SCCF_FAULT_DETECTED;
    c73c:	40 18 d2 43 	movx.b	#1,	&0xfd766;r3 As==01
    c740:	66 d7 

0000c742 <.Loc.381.1>:
                elyErrorSignalI(ErrSCCommFault);
    c742:	7c 40 84 ff 	mov.b	#-124,	r12	;#0xff84
    c746:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000c74a <.LVL38>:
    c74a:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c74e <.L23>:
            UARTValidPacketFlag = FALSE;
    c74e:	40 18 c2 43 	movx.b	#0,	&0xfd76a;r3 As==00
    c752:	6a d7 

0000c754 <.Loc.386.1>:
            if(!(bank0p[RegFaultResponse] & (SCCommFaultGPO | SCCommFaultRst)))
    c754:	5c 4e 29 00 	mov.b	41(r14),r12	;0x00029
    c758:	4d 4c       	mov.b	r12,	r13	;
    c75a:	7d f0 03 00 	and.b	#3,	r13	;
    c75e:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    c760:	05 20       	jnz	$+12     	;abs 0xc76c

0000c762 <.Loc.388.1>:
                state = SCCF_CHECK_FOR_FAULT;
    c762:	40 18 c2 4d 	movx.b	r13,	&0xfd766;
    c766:	66 d7 
    c768:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c76c <.L28>:
                events |= (UARTUseFallbackBaudrate | UARTConfigUpdated);
    c76c:	3a d0 00 28 	bis	#10240,	r10	;#0x2800

0000c770 <.LVL40>:
                if(bank0p[RegFaultResponse] & SCCommFaultGPO)
    c770:	40 18 1c b3 	bitx.w	#1,	r12	;r3 As==01
    c774:	0d 24       	jz	$+28     	;abs 0xc790

0000c776 <.Loc.395.1>:
                    if(bank0p[RegFaultResponse] & SCCommFaultRst)
    c776:	40 18 2c b3 	bitx.w	#2,	r12	;r3 As==10
    c77a:	05 24       	jz	$+12     	;abs 0xc786

0000c77c <.Loc.396.1>:
                            state = SCCF_TOGGLE_GPIO_AND_RESET;
    c77c:	40 18 e2 42 	movx.b	#4,	&0xfd766;r2 As==10
    c780:	66 d7 
    c782:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c786 <.L30>:
                            state = SCCF_TOGGLE_GPIO;
    c786:	40 18 e2 43 	movx.b	#2,	&0xfd766;r3 As==10
    c78a:	66 d7 
    c78c:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c790 <.L29>:
                    state = SCCF_RESET;
    c790:	40 18 f2 40 	movx.b	#3,	&0xfd766;
    c794:	03 00 66 d7 
    c798:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c79c <.L20>:
            palToggleLine(LINE_GPO);
    c79c:	40 18 b2 e0 	xorx.w	#8192,	&0x00222;0x02000
    c7a0:	00 20 22 02 

0000c7a4 <.Loc.408.1>:
            chThdSleep(1);
    c7a4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c7a6:	b0 13 10 47 	calla	#18192		;0x04710

0000c7aa <.LVL42>:
            palToggleLine(LINE_GPO);
    c7aa:	40 18 b2 e0 	xorx.w	#8192,	&0x00222;0x02000
    c7ae:	00 20 22 02 

0000c7b2 <.Loc.410.1>:
            state = SCCF_FAULT_STILL_PRESENT;
    c7b2:	40 18 f2 40 	movx.b	#5,	&0xfd766;
    c7b6:	05 00 66 d7 

0000c7ba <.Loc.411.1>:
        break;
    c7ba:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c7be <.L24>:
            palToggleLine(LINE_GPO);
    c7be:	40 18 b2 e0 	xorx.w	#8192,	&0x00222;0x02000
    c7c2:	00 20 22 02 

0000c7c6 <.Loc.418.1>:
            chThdSleep(1);
    c7c6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c7c8:	b0 13 10 47 	calla	#18192		;0x04710

0000c7cc <.LVL44>:
            palToggleLine(LINE_GPO);
    c7cc:	40 18 b2 e0 	xorx.w	#8192,	&0x00222;0x02000
    c7d0:	00 20 22 02 

0000c7d4 <.L33>:
            state = SCCF_FAULT_STILL_PRESENT;
    c7d4:	40 18 f2 40 	movx.b	#5,	&0xfd766;
    c7d8:	05 00 66 d7 

0000c7dc <.Loc.421.1>:
            PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; //Reset Elysium
    c7dc:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    c7e0:	48 a5 20 01 

0000c7e4 <.Loc.422.1>:
        break;
    c7e4:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c7e8 <.L31>:
                events |= UARTUseFallbackBaudrate; //enforce fallback baudrate
    c7e8:	3a d0 00 20 	bis	#8192,	r10	;#0x2000

0000c7ec <.LVL46>:
    c7ec:	80 00 dc c6 	mova	#50908,	r0	;0x0c6dc

0000c7f0 <reload_config_GF>:
void reload_config_GF(void) {
    c7f0:	2a 14       	pushm.a	#3,	r10	;20-bit words

0000c7f2 <.LCFI3>:
  uint8_t bank = bank0p[RegGFBank];
    c7f2:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    c7f6:	59 4c 40 00 	mov.b	64(r12),r9	;0x00040

0000c7fa <.LVL47>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    c7fa:	2a 01 26 01 	mova	&65830,	r10	;0x10126
    c7fe:	88 00 72 a6 	mova	#42610,	r8	;0x0a672
    c802:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    c806:	4e 43       	clr.b	r14		;
    c808:	cd 0a       	mova	r10,	r13	;
    c80a:	4c 49       	mov.b	r9,	r12	;

0000c80c <.LVL48>:
    c80c:	48 13       	calla	r8		;

0000c80e <.LVL49>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    c80e:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    c812:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    c816:	cd 0a       	mova	r10,	r13	;
    c818:	ad 00 80 00 	adda	#128,	r13	;0x00080
    c81c:	4c 49       	mov.b	r9,	r12	;
    c81e:	48 13       	calla	r8		;

0000c820 <.LVL50>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    c820:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    c824:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    c828:	cd 0a       	mova	r10,	r13	;
    c82a:	ad 00 c0 00 	adda	#192,	r13	;0x000c0
    c82e:	4c 49       	mov.b	r9,	r12	;
    c830:	48 13       	calla	r8		;

0000c832 <.LVL51>:
  bank0w[RegActiveBank] = bank;
    c832:	ca 49 69 00 	mov.b	r9,	105(r10); 0x0069

0000c836 <.Loc.452.1>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    c836:	c0 1f b2 40 	movx.w	#-23224,&0x00120;0xfa548
    c83a:	48 a5 20 01 

0000c83e <.Loc.453.1>:
}
    c83e:	28 16       	popm.a	#3,	r10	;20-bit words
    c840:	10 01       	reta			;

0000c842 <GC_Fault_Handler>:
    RegGFTime = ( ((uint32_t)(bank0p[RegGFTimeLsb])) |
    c842:	2e 01 2a 01 	mova	&65834,	r14	;0x1012a

0000c846 <.LVL53>:
    switch(state)
    c846:	40 18 5d 42 	movx.b	&0x0d767,r13	;
    c84a:	67 d7 
    c84c:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    c84e:	65 24       	jz	$+204    	;abs 0xc91a
    c850:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c852:	4f 9d       	cmp.b	r13,	r15	;
    c854:	05 28       	jnc	$+12     	;abs 0xc860
    c856:	4d 93       	cmp.b	#0,	r13	;r3 As==00
    c858:	1a 24       	jz	$+54     	;abs 0xc88e
    c85a:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    c85c:	3b 24       	jz	$+120    	;abs 0xc8d4

0000c85e <.L35>:
}
    c85e:	10 01       	reta			;

0000c860 <.L38>:
    switch(state)
    c860:	7d 90 03 00 	cmp.b	#3,	r13	;
    c864:	61 24       	jz	$+196    	;abs 0xc928
    c866:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    c868:	fa 23       	jnz	$-10     	;abs 0xc85e

0000c86a <.Loc.348.1>:
            if(RFValidPacketFlag == TRUE)
    c86a:	40 18 d2 93 	cmpx.b	#1,	&0xfd769;r3 As==01
    c86e:	69 d7 
    c870:	39 24       	jz	$+116    	;abs 0xc8e4

0000c872 <.Loc.354.1>:
                  if (!(events & RFTxFrameReady))  //Make sure no frames are in progress before transmitting beacon
    c872:	3c b0 00 08 	bit	#2048,	r12	;#0x0800
    c876:	f3 23       	jnz	$-24     	;abs 0xc85e

0000c878 <.Loc.356.1>:
                        elyRFDLLBuildBeacon();
    c878:	b0 13 04 b2 	calla	#45572		;0x0b204

0000c87c <.LVL56>:
                        chEvtSignal(rf_thd, RFTxFrameReady);
    c87c:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    c880:	4e 43       	clr.b	r14		;
    c882:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    c886:	b0 13 c0 47 	calla	#18368		;0x047c0

0000c88a <.LVL57>:
}
    c88a:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c88e <.L39>:
    RegGFTime = ( ((uint32_t)(bank0p[RegGFTimeLsb])) |
    c88e:	5d 4e 3d 00 	mov.b	61(r14),r13	;0x0003d
    c892:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    c896:	5c 4e 3c 00 	mov.b	60(r14),r12	;0x0003c

0000c89a <.LVL59>:
    c89a:	0d dc       	bis	r12,	r13	;
    c89c:	5c 4e 3f 00 	mov.b	63(r14),r12	;0x0003f
    c8a0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    c8a4:	5e 4e 3e 00 	mov.b	62(r14),r14	;0x0003e

0000c8a8 <.LVL60>:
    c8a8:	0c de       	bis	r14,	r12	;

0000c8aa <.Loc.312.1>:
            if(RFLastValidPacketTimer > RegGFTime)
    c8aa:	c0 18 1c 92 	cmpx.w	&0x13966,r12	;
    c8ae:	66 39 
    c8b0:	08 28       	jnc	$+18     	;abs 0xc8c2
    c8b2:	41 18 82 9c 	cmpx.w	r12,	&0x13966;
    c8b6:	66 39 
    c8b8:	d2 23       	jnz	$-90     	;abs 0xc85e
    c8ba:	c0 18 1d 92 	cmpx.w	&0x13964,r13	;
    c8be:	64 39 
    c8c0:	ce 2f       	jc	$-98     	;abs 0xc85e

0000c8c2 <.L48>:
                state = RFGF_FAULT_DETECTED;
    c8c2:	40 18 d2 43 	movx.b	#1,	&0xfd767;r3 As==01
    c8c6:	67 d7 

0000c8c8 <.Loc.315.1>:
                elyErrorSignalI(ErrGroundCommFault);
    c8c8:	7c 40 83 ff 	mov.b	#-125,	r12	;#0xff83
    c8cc:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000c8d0 <.LVL61>:
    c8d0:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c8d4 <.L40>:
            RFValidPacketFlag = FALSE;
    c8d4:	40 18 c2 43 	movx.b	#0,	&0xfd769;r3 As==00
    c8d8:	69 d7 

0000c8da <.Loc.320.1>:
            if(!(bank0p[RegFaultResponse] & (GroundFaultFallback | GroundFaultBeacon)))
    c8da:	5c 4e 29 00 	mov.b	41(r14),r12	;0x00029

0000c8de <.LVL63>:
    c8de:	3c b0 0c 00 	bit	#12,	r12	;#0x000c
    c8e2:	05 20       	jnz	$+12     	;abs 0xc8ee

0000c8e4 <.L47>:
                state = RFGF_CHECK_FOR_FAULT;
    c8e4:	40 18 c2 43 	movx.b	#0,	&0xfd767;r3 As==00
    c8e8:	67 d7 
    c8ea:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c8ee <.L44>:
                if(bank0p[RegFaultResponse] & GroundFaultFallback)
    c8ee:	40 18 2c b2 	bitx.w	#4,	r12	;r2 As==10
    c8f2:	0e 24       	jz	$+30     	;abs 0xc910

0000c8f4 <.Loc.328.1>:
                    if(bank0p[RegFaultResponse] & GroundFaultBeacon)
    c8f4:	40 18 3c b2 	bitx.w	#8,	r12	;r2 As==11
    c8f8:	05 24       	jz	$+12     	;abs 0xc904

0000c8fa <.Loc.329.1>:
                            state = RFGF_FALLBACK_CFG_AND_TX_BEACONS;
    c8fa:	40 18 e2 43 	movx.b	#2,	&0xfd767;r3 As==10
    c8fe:	67 d7 
    c900:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c904 <.L46>:
                            state = RFGF_FALLBACK_CFG;
    c904:	40 18 f2 40 	movx.b	#3,	&0xfd767;
    c908:	03 00 67 d7 
    c90c:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c910 <.L45>:
                    state = RFGF_TX_BEACONS;
    c910:	40 18 e2 42 	movx.b	#4,	&0xfd767;r2 As==10
    c914:	67 d7 
    c916:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c91a <.L37>:
            state = RFGF_TX_BEACONS;
    c91a:	40 18 e2 42 	movx.b	#4,	&0xfd767;r2 As==10
    c91e:	67 d7 

0000c920 <.L49>:
            reload_config_GF();
    c920:	b0 13 f0 c7 	calla	#51184		;0x0c7f0

0000c924 <.LVL65>:
        break;
    c924:	80 00 5e c8 	mova	#51294,	r0	;0x0c85e

0000c928 <.L41>:
            state = RFGF_CHECK_FOR_FAULT;
    c928:	40 18 c2 43 	movx.b	#0,	&0xfd767;r3 As==00
    c92c:	67 d7 
    c92e:	80 00 20 c9 	mova	#51488,	r0	;0x0c920

0000c932 <convert_ntc>:
fixed_q36_8 convert_ntc(ADCConversionGroup *grpp, adcsample_t sample) {
    c932:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000c934 <.LCFI4>:
    c934:	b1 00 02 00 	suba	#2,	r1	;

0000c938 <.LCFI5>:
  sample = adcMSP430XAdjustResult(grpp, sample);
    c938:	b0 13 5c 63 	calla	#25436		;0x0635c

0000c93c <.LVL69>:
    c93c:	07 4c       	mov	r12,	r7	;

0000c93e <.LVL70>:
  y = c3 * sample; /* Q0.31 * Q12.0 => Q12.31 */
    c93e:	0d 43       	clr	r13		;
    c940:	0e 4c       	mov	r12,	r14	;
    c942:	0f 4d       	mov	r13,	r15	;
    c944:	0e 5e       	rla	r14		;
    c946:	0f 6f       	rlc	r15		;
    c948:	0e 5e       	rla	r14		;
    c94a:	0f 6f       	rlc	r15		;
    c94c:	0c 5e       	add	r14,	r12	;
    c94e:	0d 6f       	addc	r15,	r13	;
    c950:	08 4c       	mov	r12,	r8	;
    c952:	08 5c       	add	r12,	r8	;
    c954:	09 4d       	mov	r13,	r9	;
    c956:	09 6d       	addc	r13,	r9	;
    c958:	4c 43       	clr.b	r12		;
    c95a:	4d 43       	clr.b	r13		;
    c95c:	40 18 0c 88 	subx.w	r8,	r12	;
    c960:	40 18 0d 79 	subcx.w	r9,	r13	;
    c964:	0e 4c       	mov	r12,	r14	;
    c966:	05 4d       	mov	r13,	r5	;
    c968:	4e 18 05 11 	rpt #15 { rrax.w	r5		;

0000c96c <.LVL71>:
  y += c2; /* Q12.31 + Q0.31 => OK */
    c96c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c96e <.LVL72>:
    c96e:	08 4e       	mov	r14,	r8	;
    c970:	38 50 d3 03 	add	#979,	r8	;#0x03d3
    c974:	09 4c       	mov	r12,	r9	;
    c976:	08 9e       	cmp	r14,	r8	;
    c978:	01 28       	jnc	$+4      	;abs 0xc97c
    c97a:	49 43       	clr.b	r9		;

0000c97c <.L51>:
    c97c:	0c 5d       	add	r13,	r12	;
    c97e:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c980:	0c 9d       	cmp	r13,	r12	;
    c982:	01 28       	jnc	$+4      	;abs 0xc986
    c984:	4a 43       	clr.b	r10		;

0000c986 <.L52>:
    c986:	09 5c       	add	r12,	r9	;
    c988:	5d 43       	mov.b	#1,	r13	;r3 As==01

0000c98a <.LVL73>:
    c98a:	09 9c       	cmp	r12,	r9	;
    c98c:	01 28       	jnc	$+4      	;abs 0xc990
    c98e:	4d 43       	clr.b	r13		;

0000c990 <.L53>:
    c990:	0a dd       	bis	r13,	r10	;
    c992:	4b 43       	clr.b	r11		;
    c994:	0a 55       	add	r5,	r10	;
    c996:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c998:	0a 95       	cmp	r5,	r10	;
    c99a:	01 28       	jnc	$+4      	;abs 0xc99e
    c99c:	0c 4b       	mov	r11,	r12	;

0000c99e <.L55>:
    c99e:	0b dc       	bis	r12,	r11	;

0000c9a0 <.LVL75>:
  y *= sample; /* Q12.31 * Q12.0 => Q24.31 */
    c9a0:	86 00 34 ce 	mova	#52788,	r6	;0x0ce34
    c9a4:	0c 47       	mov	r7,	r12	;
    c9a6:	4d 43       	clr.b	r13		;
    c9a8:	0e 4d       	mov	r13,	r14	;
    c9aa:	0f 4d       	mov	r13,	r15	;
    c9ac:	0b 55       	add	r5,	r11	;
    c9ae:	46 13       	calla	r6		;

0000c9b0 <.LVL77>:
  y = (y >> 16); /* Q24.31 >> 16 => Q24.15 */
    c9b0:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    c9b4:	00 00 
    c9b6:	b0 13 76 cf 	calla	#53110		;0x0cf76

0000c9ba <.LVL78>:
  y += c1; /* Q24.15 + Q0.15 => OK */
    c9ba:	39 43       	mov	#-1,	r9	;r3 As==11
    c9bc:	08 4c       	mov	r12,	r8	;
    c9be:	38 50 e7 f4 	add	#-2841,	r8	;#0xf4e7
    c9c2:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c9c4:	35 40 18 0b 	mov	#2840,	r5	;#0x0b18
    c9c8:	05 9c       	cmp	r12,	r5	;
    c9ca:	01 28       	jnc	$+4      	;abs 0xc9ce
    c9cc:	4a 43       	clr.b	r10		;

0000c9ce <.L56>:
    c9ce:	05 4d       	mov	r13,	r5	;
    c9d0:	05 59       	add	r9,	r5	;
    c9d2:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000c9d4 <.LVL79>:
    c9d4:	05 9d       	cmp	r13,	r5	;
    c9d6:	01 28       	jnc	$+4      	;abs 0xc9da
    c9d8:	4c 43       	clr.b	r12		;

0000c9da <.L57>:
    c9da:	0d 4a       	mov	r10,	r13	;
    c9dc:	0d 55       	add	r5,	r13	;
    c9de:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c9e0:	0d 95       	cmp	r5,	r13	;
    c9e2:	01 28       	jnc	$+4      	;abs 0xc9e6
    c9e4:	4a 43       	clr.b	r10		;

0000c9e6 <.L58>:
    c9e6:	0c da       	bis	r10,	r12	;
    c9e8:	05 4e       	mov	r14,	r5	;
    c9ea:	05 59       	add	r9,	r5	;
    c9ec:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c9ee:	05 9e       	cmp	r14,	r5	;
    c9f0:	01 28       	jnc	$+4      	;abs 0xc9f4
    c9f2:	4a 43       	clr.b	r10		;

0000c9f4 <.L59>:
    c9f4:	0e 4c       	mov	r12,	r14	;
    c9f6:	0e 55       	add	r5,	r14	;
    c9f8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c9fa:	0e 95       	cmp	r5,	r14	;
    c9fc:	01 28       	jnc	$+4      	;abs 0xca00
    c9fe:	4c 43       	clr.b	r12		;

0000ca00 <.L60>:
    ca00:	0a dc       	bis	r12,	r10	;
    ca02:	0f 59       	add	r9,	r15	;

0000ca04 <.Loc.475.1>:
  y *= sample; /* Q24.15 * Q12.0 => Q36.15 */
    ca04:	0c 48       	mov	r8,	r12	;
    ca06:	0f 5a       	add	r10,	r15	;
    ca08:	08 47       	mov	r7,	r8	;
    ca0a:	49 43       	clr.b	r9		;
    ca0c:	0a 49       	mov	r9,	r10	;
    ca0e:	0b 49       	mov	r9,	r11	;
    ca10:	46 13       	calla	r6		;

0000ca12 <.LVL83>:
  y = (y >> 7); /* Q36.15 >> 7 => Q36.8 */
    ca12:	b1 40 07 00 	mov	#7,	0(r1)	;
    ca16:	00 00 
    ca18:	b0 13 76 cf 	calla	#53110		;0x0cf76

0000ca1c <.LVL84>:
    ca1c:	08 4e       	mov	r14,	r8	;

0000ca1e <.Loc.477.1>:
  y += c0; /* Q36.8 + Q7.8 => OK */
    ca1e:	07 4c       	mov	r12,	r7	;

0000ca20 <.LVL86>:
    ca20:	37 50 4e 70 	add	#28750,	r7	;#0x704e
    ca24:	5a 43       	mov.b	#1,	r10	;r3 As==01
    ca26:	3c 90 b2 8f 	cmp	#-28750,r12	;#0x8fb2
    ca2a:	01 2c       	jc	$+4      	;abs 0xca2e
    ca2c:	0a 49       	mov	r9,	r10	;

0000ca2e <.L61>:
    ca2e:	4c 43       	clr.b	r12		;
    ca30:	0a 5d       	add	r13,	r10	;
    ca32:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ca34:	0a 9d       	cmp	r13,	r10	;
    ca36:	01 28       	jnc	$+4      	;abs 0xca3a
    ca38:	0e 4c       	mov	r12,	r14	;

0000ca3a <.L63>:
    ca3a:	0c de       	bis	r14,	r12	;
    ca3c:	49 43       	clr.b	r9		;
    ca3e:	0e 4c       	mov	r12,	r14	;
    ca40:	0e 58       	add	r8,	r14	;
    ca42:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ca44:	0e 98       	cmp	r8,	r14	;
    ca46:	01 28       	jnc	$+4      	;abs 0xca4a
    ca48:	0c 49       	mov	r9,	r12	;

0000ca4a <.L65>:
    ca4a:	09 dc       	bis	r12,	r9	;

0000ca4c <.Loc.482.1>:
}
    ca4c:	0c 47       	mov	r7,	r12	;
    ca4e:	0d 4a       	mov	r10,	r13	;
    ca50:	0f 59       	add	r9,	r15	;
    ca52:	a1 00 02 00 	adda	#2,	r1	;
    ca56:	55 16       	popm.a	#6,	r10	;20-bit words
    ca58:	10 01       	reta			;

0000ca5a <OT_Fault_Handler>:
{
    ca5a:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000ca5c <.LCFI6>:
    ca5c:	b1 00 12 00 	suba	#18,	r1	;0x00012

0000ca60 <.LCFI7>:
    ca60:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    ca64:	0a 4d       	mov	r13,	r10	;

0000ca66 <.Loc.171.1>:
    temps[0] = convert_ntc(&adc_group, ADC12MEM0); //PA thermistor
    ca66:	88 00 32 c9 	mova	#51506,	r8	;0x0c932
    ca6a:	40 18 1d 42 	movx.w	&0x00860,r13	;
    ca6e:	60 08 
    ca70:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32

0000ca74 <.LVL90>:
    ca74:	48 13       	calla	r8		;

0000ca76 <.LVL91>:
    ca76:	05 4c       	mov	r12,	r5	;
    ca78:	06 4d       	mov	r13,	r6	;
    ca7a:	07 4e       	mov	r14,	r7	;
    ca7c:	09 4f       	mov	r15,	r9	;

0000ca7e <.LVL92>:
    temps[1] = convert_ntc(&adc_group, ADC12MEM1); //heatsink thermistor
    ca7e:	40 18 1d 42 	movx.w	&0x00862,r13	;
    ca82:	62 08 
    ca84:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    ca88:	48 13       	calla	r8		;

0000ca8a <.LVL93>:
    ca8a:	04 4c       	mov	r12,	r4	;
    ca8c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    ca90:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    ca94:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

0000ca98 <.LVL94>:
    MCUtemp = adcMSP430XAdjustTemp(&adc_group, ADC12MEM2); //MCU temperature
    ca98:	40 18 1d 42 	movx.w	&0x00864,r13	;
    ca9c:	64 08 

0000ca9e <.LVL95>:
    ca9e:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    caa2:	b0 13 d6 63 	calla	#25558		;0x063d6

0000caa6 <.LVL96>:
    caa6:	41 18 82 4c 	movx.w	r12,	&0x1396c;
    caaa:	6c 39 

0000caac <.Loc.174.1>:
    LNAVSENSE = adcMSP430XAdjustResult(&adc_group, ADC12MEM3);
    caac:	40 18 1d 42 	movx.w	&0x00866,r13	;
    cab0:	66 08 
    cab2:	8c 01 32 0a 	mova	#68146,	r12	;0x10a32
    cab6:	b0 13 5c 63 	calla	#25436		;0x0635c

0000caba <.LVL97>:
    caba:	41 18 82 4c 	movx.w	r12,	&0x1396e;
    cabe:	6e 39 

0000cac0 <.Loc.176.1>:
    debug_pa_temp = temps[0] >> 8; //allows debug watch
    cac0:	88 00 76 cf 	mova	#53110,	r8	;0x0cf76
    cac4:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    cac8:	0c 45       	mov	r5,	r12	;
    caca:	0d 46       	mov	r6,	r13	;
    cacc:	0e 47       	mov	r7,	r14	;
    cace:	0f 49       	mov	r9,	r15	;
    cad0:	48 13       	calla	r8		;

0000cad2 <.LVL98>:
    cad2:	06 4c       	mov	r12,	r6	;

0000cad4 <.LVL99>:
    cad4:	05 4d       	mov	r13,	r5	;
    cad6:	09 4e       	mov	r14,	r9	;
    cad8:	07 4f       	mov	r15,	r7	;
    cada:	41 18 82 4c 	movx.w	r12,	&0x13972;
    cade:	72 39 

0000cae0 <.Loc.177.1>:
    debug_hs_temp = temps[1] >> 8; //allows debug watch
    cae0:	0c 44       	mov	r4,	r12	;
    cae2:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    cae6:	1e 41 0c 00 	mov	12(r1),	r14	;0x0000c
    caea:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    caee:	48 13       	calla	r8		;

0000caf0 <.LVL100>:
    caf0:	04 4c       	mov	r12,	r4	;

0000caf2 <.LVL101>:
    caf2:	08 4f       	mov	r15,	r8	;
    caf4:	41 18 82 4c 	movx.w	r12,	&0x13970;
    caf8:	70 39 

0000cafa <.Loc.181.1>:
        if((temps[0] >> 8) < POWERAMP_FAULT_TEMPERATURE)
    cafa:	4c 43       	clr.b	r12		;

0000cafc <.Loc.179.1>:
    if(paovertemp)
    cafc:	41 18 c2 93 	cmpx.b	#0,	&0x1395e;r3 As==00
    cb00:	5e 39 
    cb02:	64 24       	jz	$+202    	;abs 0xcbcc

0000cb04 <.Loc.181.1>:
        if((temps[0] >> 8) < POWERAMP_FAULT_TEMPERATURE)
    cb04:	0c 97       	cmp	r7,	r12	;
    cb06:	5d 38       	jl	$+188    	;abs 0xcbc2
    cb08:	07 9c       	cmp	r12,	r7	;
    cb0a:	08 20       	jnz	$+18     	;abs 0xcb1c
    cb0c:	09 9c       	cmp	r12,	r9	;
    cb0e:	59 20       	jnz	$+180    	;abs 0xcbc2
    cb10:	05 9c       	cmp	r12,	r5	;
    cb12:	57 20       	jnz	$+176    	;abs 0xcbc2
    cb14:	7c 40 3b 00 	mov.b	#59,	r12	;#0x003b
    cb18:	0c 96       	cmp	r6,	r12	;
    cb1a:	53 28       	jnc	$+168    	;abs 0xcbc2

0000cb1c <.L104>:
            debounce_paovertemp++;
    cb1c:	41 18 d2 53 	incx.b	&0x1395d		;
    cb20:	5d 39 

0000cb22 <.L70>:
        if(debounce_paovertemp == OT_DEBOUNCE)
    cb22:	41 18 f2 90 	cmpx.b	#5,	&0x1395d;
    cb26:	05 00 5d 39 
    cb2a:	06 20       	jnz	$+14     	;abs 0xcb38

0000cb2c <.Loc.187.1>:
            paovertemp = FALSE;
    cb2c:	41 18 c2 43 	movx.b	#0,	&0x1395e;r3 As==00
    cb30:	5e 39 

0000cb32 <.Loc.188.1>:
            debounce_paovertemp = 0;
    cb32:	41 18 c2 43 	movx.b	#0,	&0x1395d;r3 As==00
    cb36:	5d 39 

0000cb38 <.L72>:
        if((temps[1] >> 8) < HEATSINK_FAULT_TEMPERATURE)
    cb38:	4c 43       	clr.b	r12		;

0000cb3a <.Loc.205.1>:
    if(hsovertemp)
    cb3a:	41 18 c2 93 	cmpx.b	#0,	&0x1395c;r3 As==00
    cb3e:	5c 39 
    cb40:	77 24       	jz	$+240    	;abs 0xcc30

0000cb42 <.Loc.207.1>:
        if((temps[1] >> 8) < HEATSINK_FAULT_TEMPERATURE)
    cb42:	0c 98       	cmp	r8,	r12	;
    cb44:	70 38       	jl	$+226    	;abs 0xcc26
    cb46:	08 9c       	cmp	r12,	r8	;
    cb48:	08 20       	jnz	$+18     	;abs 0xcb5a
    cb4a:	0e 9c       	cmp	r12,	r14	;
    cb4c:	6c 20       	jnz	$+218    	;abs 0xcc26
    cb4e:	0d 9c       	cmp	r12,	r13	;
    cb50:	6a 20       	jnz	$+214    	;abs 0xcc26
    cb52:	7c 40 3b 00 	mov.b	#59,	r12	;#0x003b
    cb56:	0c 94       	cmp	r4,	r12	;
    cb58:	66 28       	jnc	$+206    	;abs 0xcc26

0000cb5a <.L106>:
            debounce_hsovertemp++;
    cb5a:	41 18 d2 53 	incx.b	&0x1395b		;
    cb5e:	5b 39 

0000cb60 <.L80>:
        if(debounce_hsovertemp == OT_DEBOUNCE)
    cb60:	41 18 f2 90 	cmpx.b	#5,	&0x1395b;
    cb64:	05 00 5b 39 
    cb68:	06 20       	jnz	$+14     	;abs 0xcb76

0000cb6a <.Loc.213.1>:
            hsovertemp = FALSE;
    cb6a:	41 18 c2 43 	movx.b	#0,	&0x1395c;r3 As==00
    cb6e:	5c 39 

0000cb70 <.Loc.214.1>:
            debounce_hsovertemp = 0;
    cb70:	41 18 c2 43 	movx.b	#0,	&0x1395b;r3 As==00
    cb74:	5b 39 

0000cb76 <.L82>:
    if(mcuovertemp)
    cb76:	41 18 c2 93 	cmpx.b	#0,	&0x1395a;r3 As==00
    cb7a:	5a 39 
    cb7c:	83 24       	jz	$+264    	;abs 0xcc84

0000cb7e <.Loc.233.1>:
        if(MCUtemp < MCU_FAULT_TEMPERATURE)
    cb7e:	7c 40 3b 00 	mov.b	#59,	r12	;#0x003b
    cb82:	c0 18 1c 92 	cmpx.w	&0x1396c,r12	;
    cb86:	6c 39 
    cb88:	78 28       	jnc	$+242    	;abs 0xcc7a

0000cb8a <.Loc.234.1>:
            debounce_mcuovertemp++;
    cb8a:	41 18 d2 53 	incx.b	&0x13959		;
    cb8e:	59 39 

0000cb90 <.L89>:
        if(debounce_mcuovertemp == OT_DEBOUNCE)
    cb90:	41 18 f2 90 	cmpx.b	#5,	&0x13959;
    cb94:	05 00 59 39 
    cb98:	06 20       	jnz	$+14     	;abs 0xcba6

0000cb9a <.Loc.239.1>:
            hsovertemp = FALSE;
    cb9a:	41 18 c2 43 	movx.b	#0,	&0x1395c;r3 As==00
    cb9e:	5c 39 

0000cba0 <.Loc.240.1>:
            debounce_mcuovertemp = 0;
    cba0:	41 18 c2 43 	movx.b	#0,	&0x13959;r3 As==00
    cba4:	59 39 

0000cba6 <.L91>:
    switch(state)
    cba6:	40 18 5c 42 	movx.b	&0x0d768,r12	;
    cbaa:	68 d7 
    cbac:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    cbae:	89 24       	jz	$+276    	;abs 0xccc2
    cbb0:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    cbb2:	ba 24       	jz	$+374    	;abs 0xcd28

0000cbb4 <.L95>:
}
    cbb4:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    cbb8:	0d 4a       	mov	r10,	r13	;
    cbba:	a1 00 12 00 	adda	#18,	r1	;0x00012
    cbbe:	64 16       	popm.a	#7,	r10	;20-bit words
    cbc0:	10 01       	reta			;

0000cbc2 <.L68>:
            debounce_paovertemp = 0;
    cbc2:	41 18 c2 43 	movx.b	#0,	&0x1395d;r3 As==00
    cbc6:	5d 39 
    cbc8:	80 00 22 cb 	mova	#52002,	r0	;0x0cb22

0000cbcc <.L67>:
        if((temps[0] >> 8) > POWERAMP_FAULT_TEMPERATURE)
    cbcc:	0c 97       	cmp	r7,	r12	;
    cbce:	0a 38       	jl	$+22     	;abs 0xcbe4
    cbd0:	07 9c       	cmp	r12,	r7	;
    cbd2:	24 20       	jnz	$+74     	;abs 0xcc1c
    cbd4:	09 9c       	cmp	r12,	r9	;
    cbd6:	06 20       	jnz	$+14     	;abs 0xcbe4
    cbd8:	05 9c       	cmp	r12,	r5	;
    cbda:	04 20       	jnz	$+10     	;abs 0xcbe4
    cbdc:	7c 40 3c 00 	mov.b	#60,	r12	;#0x003c
    cbe0:	0c 96       	cmp	r6,	r12	;
    cbe2:	1c 2c       	jc	$+58     	;abs 0xcc1c

0000cbe4 <.L105>:
            debounce_paovertemp++;
    cbe4:	41 18 d2 53 	incx.b	&0x1395d		;
    cbe8:	5d 39 

0000cbea <.L75>:
        if(debounce_paovertemp == OT_DEBOUNCE)
    cbea:	41 18 f2 90 	cmpx.b	#5,	&0x1395d;
    cbee:	05 00 5d 39 
    cbf2:	a2 23       	jnz	$-186    	;abs 0xcb38

0000cbf4 <.Loc.199.1>:
            paovertemp = TRUE;
    cbf4:	41 18 d2 43 	movx.b	#1,	&0x1395e;r3 As==01
    cbf8:	5e 39 

0000cbfa <.Loc.200.1>:
            debounce_paovertemp = 0;
    cbfa:	41 18 c2 43 	movx.b	#0,	&0x1395d;r3 As==00
    cbfe:	5d 39 

0000cc00 <.Loc.201.1>:
            elyErrorSignalI(ErrPAOvertemp);
    cc00:	7c 40 80 ff 	mov.b	#-128,	r12	;#0xff80
    cc04:	71 0d 06 00 	mova	r13,	6(r1)	;
    cc08:	71 0e 02 00 	mova	r14,	2(r1)	;
    cc0c:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000cc10 <.LVL104>:
    cc10:	3e 01 02 00 	mova	2(r1),	r14	;
    cc14:	3d 01 06 00 	mova	6(r1),	r13	;
    cc18:	80 00 38 cb 	mova	#52024,	r0	;0x0cb38

0000cc1c <.L73>:
            debounce_paovertemp = 0;
    cc1c:	41 18 c2 43 	movx.b	#0,	&0x1395d;r3 As==00
    cc20:	5d 39 
    cc22:	80 00 ea cb 	mova	#52202,	r0	;0x0cbea

0000cc26 <.L78>:
            debounce_hsovertemp = 0;
    cc26:	41 18 c2 43 	movx.b	#0,	&0x1395b;r3 As==00
    cc2a:	5b 39 
    cc2c:	80 00 60 cb 	mova	#52064,	r0	;0x0cb60

0000cc30 <.L77>:
        if((temps[1] >> 8) > HEATSINK_FAULT_TEMPERATURE)
    cc30:	0c 98       	cmp	r8,	r12	;
    cc32:	0a 38       	jl	$+22     	;abs 0xcc48
    cc34:	08 9c       	cmp	r12,	r8	;
    cc36:	1c 20       	jnz	$+58     	;abs 0xcc70
    cc38:	0e 9c       	cmp	r12,	r14	;
    cc3a:	06 20       	jnz	$+14     	;abs 0xcc48
    cc3c:	0d 9c       	cmp	r12,	r13	;
    cc3e:	04 20       	jnz	$+10     	;abs 0xcc48
    cc40:	7c 40 3c 00 	mov.b	#60,	r12	;#0x003c
    cc44:	0c 94       	cmp	r4,	r12	;
    cc46:	14 2c       	jc	$+42     	;abs 0xcc70

0000cc48 <.L107>:
            debounce_hsovertemp++;
    cc48:	41 18 d2 53 	incx.b	&0x1395b		;
    cc4c:	5b 39 

0000cc4e <.L85>:
        if(debounce_hsovertemp == OT_DEBOUNCE)
    cc4e:	41 18 f2 90 	cmpx.b	#5,	&0x1395b;
    cc52:	05 00 5b 39 
    cc56:	8f 23       	jnz	$-224    	;abs 0xcb76

0000cc58 <.Loc.225.1>:
            hsovertemp = TRUE;
    cc58:	41 18 d2 43 	movx.b	#1,	&0x1395c;r3 As==01
    cc5c:	5c 39 

0000cc5e <.Loc.226.1>:
            debounce_hsovertemp = 0;
    cc5e:	41 18 c2 43 	movx.b	#0,	&0x1395b;r3 As==00
    cc62:	5b 39 

0000cc64 <.Loc.227.1>:
            elyErrorSignalI(ErrHSOvertemp);
    cc64:	7c 40 81 ff 	mov.b	#-127,	r12	;#0xff81
    cc68:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000cc6c <.LVL105>:
    cc6c:	80 00 76 cb 	mova	#52086,	r0	;0x0cb76

0000cc70 <.L83>:
            debounce_hsovertemp = 0;
    cc70:	41 18 c2 43 	movx.b	#0,	&0x1395b;r3 As==00
    cc74:	5b 39 
    cc76:	80 00 4e cc 	mova	#52302,	r0	;0x0cc4e

0000cc7a <.L88>:
            debounce_mcuovertemp = 0;
    cc7a:	41 18 c2 43 	movx.b	#0,	&0x13959;r3 As==00
    cc7e:	59 39 
    cc80:	80 00 90 cb 	mova	#52112,	r0	;0x0cb90

0000cc84 <.L87>:
        if(MCUtemp > MCU_FAULT_TEMPERATURE)
    cc84:	7c 40 3c 00 	mov.b	#60,	r12	;#0x003c
    cc88:	c0 18 1c 92 	cmpx.w	&0x1396c,r12	;
    cc8c:	6c 39 
    cc8e:	14 2c       	jc	$+42     	;abs 0xccb8

0000cc90 <.Loc.246.1>:
            debounce_mcuovertemp++;
    cc90:	41 18 d2 53 	incx.b	&0x13959		;
    cc94:	59 39 

0000cc96 <.L93>:
        if(debounce_mcuovertemp == OT_DEBOUNCE)
    cc96:	41 18 f2 90 	cmpx.b	#5,	&0x13959;
    cc9a:	05 00 59 39 
    cc9e:	83 23       	jnz	$-248    	;abs 0xcba6

0000cca0 <.Loc.251.1>:
            mcuovertemp = TRUE;
    cca0:	41 18 d2 43 	movx.b	#1,	&0x1395a;r3 As==01
    cca4:	5a 39 

0000cca6 <.Loc.252.1>:
            debounce_mcuovertemp = 0;
    cca6:	41 18 c2 43 	movx.b	#0,	&0x13959;r3 As==00
    ccaa:	59 39 

0000ccac <.Loc.253.1>:
            elyErrorSignalI(ErrMCUOvertemp);
    ccac:	7c 40 82 ff 	mov.b	#-126,	r12	;#0xff82
    ccb0:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000ccb4 <.LVL106>:
    ccb4:	80 00 a6 cb 	mova	#52134,	r0	;0x0cba6

0000ccb8 <.L92>:
            debounce_mcuovertemp = 0;
    ccb8:	41 18 c2 43 	movx.b	#0,	&0x13959;r3 As==00
    ccbc:	59 39 
    ccbe:	80 00 96 cc 	mova	#52374,	r0	;0x0cc96

0000ccc2 <.L96>:
            if (\
    ccc2:	41 18 c2 93 	cmpx.b	#0,	&0x1395e;r3 As==00
    ccc6:	5e 39 
    ccc8:	06 24       	jz	$+14     	;abs 0xccd6

0000ccca <.Loc.261.1>:
                    (paovertemp && (bank0p[RegFaultResponse] & PATempFault)) || \
    ccca:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    ccce:	fc b0 40 00 	bit.b	#64,	41(r12)	;#0x0040, 0x0029
    ccd2:	29 00 
    ccd4:	15 20       	jnz	$+44     	;abs 0xcd00

0000ccd6 <.L98>:
    ccd6:	41 18 c2 93 	cmpx.b	#0,	&0x1395c;r3 As==00
    ccda:	5c 39 
    ccdc:	06 24       	jz	$+14     	;abs 0xccea

0000ccde <.Loc.262.1>:
                    (hsovertemp && (bank0p[RegFaultResponse] & HSTempFault)) || \
    ccde:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    cce2:	fc b0 20 00 	bit.b	#32,	41(r12)	;#0x0020, 0x0029
    cce6:	29 00 
    cce8:	0b 20       	jnz	$+24     	;abs 0xcd00

0000ccea <.L100>:
    ccea:	41 18 c2 93 	cmpx.b	#0,	&0x1395a;r3 As==00
    ccee:	5a 39 
    ccf0:	61 27       	jz	$-316    	;abs 0xcbb4

0000ccf2 <.Loc.263.1>:
                    (mcuovertemp && (bank0p[RegFaultResponse] & BoardTempFault)) \
    ccf2:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    ccf6:	40 18 fc b0 	bitx.b	#16,	41(r12)	;0x00010, 0x00029
    ccfa:	10 00 29 00 
    ccfe:	5a 27       	jz	$-330    	;abs 0xcbb4

0000cd00 <.L99>:
                sx1278Stop(&SX1278D1);
    cd00:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    cd04:	b0 13 f0 68 	calla	#26864		;0x068f0

0000cd08 <.LVL107>:
                events &= ~(RFTxIdle);
    cd08:	1a c3       	bic	#1,	r10	;r3 As==01

0000cd0a <.LVL108>:
                palClearLine(LINE_PA_PC_EN);
    cd0a:	c0 1f b2 f0 	andx.w	#-4097,	&0x00222;0xfefff
    cd0e:	ff ef 22 02 

0000cd12 <.Loc.269.1>:
                state = OTF_COOLDOWN;
    cd12:	40 18 d2 43 	movx.b	#1,	&0xfd768;r3 As==01
    cd16:	68 d7 

0000cd18 <.L102>:
                    cooldown = bank0p[RegOTFaultTime];
    cd18:	2c 01 2a 01 	mova	&65834,	r12	;0x1012a
    cd1c:	41 18 d2 4c 	movx.b	69(r12),&0x13958;0x00045
    cd20:	45 00 58 39 
    cd24:	80 00 b4 cb 	mova	#52148,	r0	;0x0cbb4

0000cd28 <.L97>:
            cooldown--;
    cd28:	c0 18 58 42 	movx.b	&0x13958,r8	;
    cd2c:	58 39 
    cd2e:	78 53       	add.b	#-1,	r8	;r3 As==11
    cd30:	41 18 c2 48 	movx.b	r8,	&0x13958;
    cd34:	58 39 

0000cd36 <.Loc.276.1>:
            if( cooldown == 0)
    cd36:	48 93       	cmp.b	#0,	r8	;r3 As==00
    cd38:	1b 20       	jnz	$+56     	;abs 0xcd70

0000cd3a <.Loc.278.1>:
                if (paovertemp || hsovertemp || mcuovertemp)
    cd3a:	41 18 c2 93 	cmpx.b	#0,	&0x1395e;r3 As==00
    cd3e:	5e 39 
    cd40:	eb 23       	jnz	$-40     	;abs 0xcd18

0000cd42 <.Loc.278.1>:
    cd42:	41 18 c2 93 	cmpx.b	#0,	&0x1395c;r3 As==00
    cd46:	5c 39 
    cd48:	e7 23       	jnz	$-48     	;abs 0xcd18

0000cd4a <.Loc.278.1>:
    cd4a:	41 18 c2 93 	cmpx.b	#0,	&0x1395a;r3 As==00
    cd4e:	5a 39 
    cd50:	e3 23       	jnz	$-56     	;abs 0xcd18

0000cd52 <.Loc.284.1>:
                    palSetLine(LINE_PA_PC_EN);
    cd52:	40 18 b2 d0 	bisx.w	#4096,	&0x00222;0x01000
    cd56:	00 10 22 02 

0000cd5a <.Loc.285.1>:
                    sx1278Start(&SX1278D1, tx_cfg_ptr);
    cd5a:	2d 01 1c 21 	mova	&74012,	r13	;0x1211c
    cd5e:	8c 01 5e 15 	mova	#71006,	r12	;0x1155e
    cd62:	b0 13 ae 67 	calla	#26542		;0x067ae

0000cd66 <.LVL111>:
                    state = OTF_CHECK_FOR_FAULT;
    cd66:	40 18 c2 48 	movx.b	r8,	&0xfd768;
    cd6a:	68 d7 
    cd6c:	80 00 b4 cb 	mova	#52148,	r0	;0x0cbb4

0000cd70 <.L101>:
                events &= ~(RFTxIdle);
    cd70:	1a c3       	bic	#1,	r10	;r3 As==01

0000cd72 <.LVL112>:
    cd72:	80 00 b4 cb 	mova	#52148,	r0	;0x0cbb4

0000cd76 <elyonesecondtimerCB>:
void elyonesecondtimerCB(GPTDriver * gptp) { //ASA
    cd76:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cd78 <.LCFI8>:
  UARTLastValidPacketTimer++;  //This counts seconds
    cd78:	41 18 92 53 	incx.w	&0x13968		;
    cd7c:	68 39 
    cd7e:	41 18 82 63 	adcx.w	&0x1396a		;
    cd82:	6a 39 

0000cd84 <.Loc.491.1>:
  RFLastValidPacketTimer++;
    cd84:	41 18 92 53 	incx.w	&0x13964		;
    cd88:	64 39 
    cd8a:	41 18 82 63 	adcx.w	&0x13966		;
    cd8e:	66 39 

0000cd90 <.Loc.492.1>:
  chEvtSignalI(uart_thd,UARTCheckFaults); //Wakeup fault routine to check for/respond to faults
    cd90:	8a 00 ec 47 	mova	#18412,	r10	;0x047ec
    cd94:	3d 40 00 40 	mov	#16384,	r13	;#0x4000
    cd98:	4e 43       	clr.b	r14		;
    cd9a:	2c 01 d2 17 	mova	&71634,	r12	;0x117d2

0000cd9e <.LVL114>:
    cd9e:	4a 13       	calla	r10		;

0000cda0 <.LVL115>:
  chEvtSignalI(rf_thd,RFCheckFaults); //Wakeup fault routine to check for/respond to faults
    cda0:	4d 43       	clr.b	r13		;
    cda2:	6e 43       	mov.b	#2,	r14	;r3 As==10
    cda4:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    cda8:	4a 13       	calla	r10		;

0000cdaa <.LVL116>:
}
    cdaa:	0a 16       	popm.a	#1,	r10	;20-bit words
    cdac:	10 01       	reta			;

0000cdae <main>:
THD_TABLE_END

/*
 * Application entry point.
 */
int main(void) {
    cdae:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000cdb0 <.LCFI0>:
    cdb0:	08 14       	pushm.a	#1,	r8	;20-bit words

0000cdb2 <.LCFI1>:
  static PERSIST volatile unsigned count = 0;
  static volatile uint16_t cause[24];

  count++;
    cdb2:	40 18 92 53 	incx.w	&0xd76c		;
    cdb6:	6c d7 

0000cdb8 <.LVL0>:
  int i = -1;
    cdb8:	3c 43       	mov	#-1,	r12	;r3 As==11

0000cdba <.Loc.49.1>:
  do {
    i++;
    cause[i] = SYSRSTIV;
    cdba:	88 01 74 39 	mova	#80244,	r8	;0x13974
    cdbe:	ca 08       	mova	r8,	r10	;

0000cdc0 <.L3>:
    i++;
    cdc0:	1c 53       	inc	r12		;

0000cdc2 <.Loc.49.1>:
    cause[i] = SYSRSTIV;
    cdc2:	0d 4c       	mov	r12,	r13	;
    cdc4:	4d 0e       	rlam.a	#4,	r13	;
    cdc6:	4d 0d       	rram.a	#4,	r13	;
    cdc8:	ce 0d       	mova	r13,	r14	;
    cdca:	ee 0d       	adda	r13,	r14	;
    cdcc:	ee 08       	adda	r8,	r14	;
    cdce:	40 18 9e 42 	movx.w	&0x0019e,0(r14)	;
    cdd2:	9e 01 00 00 

0000cdd6 <.Loc.50.1>:
  } while (cause[i]);
    cdd6:	2d 4e       	mov	@r14,	r13	;
    cdd8:	0d 93       	cmp	#0,	r13	;r3 As==00
    cdda:	f2 23       	jnz	$-26     	;abs 0xcdc0

0000cddc <.L4>:
  do {
    i++;
    cddc:	1c 53       	inc	r12		;

0000cdde <.Loc.53.1>:
    cause[i] = SYSSNIV;
    cdde:	0d 4c       	mov	r12,	r13	;
    cde0:	4d 0e       	rlam.a	#4,	r13	;
    cde2:	4d 0d       	rram.a	#4,	r13	;
    cde4:	ce 0d       	mova	r13,	r14	;
    cde6:	ee 0d       	adda	r13,	r14	;
    cde8:	ee 0a       	adda	r10,	r14	;
    cdea:	40 18 9e 42 	movx.w	&0x0019c,0(r14)	;
    cdee:	9c 01 00 00 

0000cdf2 <.Loc.54.1>:
  } while (cause[i]);
    cdf2:	2d 4e       	mov	@r14,	r13	;
    cdf4:	0d 93       	cmp	#0,	r13	;r3 As==00
    cdf6:	f2 23       	jnz	$-26     	;abs 0xcddc

0000cdf8 <.L5>:
  do {
    i++;
    cdf8:	1c 53       	inc	r12		;

0000cdfa <.Loc.57.1>:
    cause[i] = SYSUNIV;
    cdfa:	0d 4c       	mov	r12,	r13	;
    cdfc:	4d 0e       	rlam.a	#4,	r13	;
    cdfe:	4d 0d       	rram.a	#4,	r13	;
    ce00:	ce 0d       	mova	r13,	r14	;
    ce02:	ee 0d       	adda	r13,	r14	;
    ce04:	ee 0a       	adda	r10,	r14	;
    ce06:	40 18 9e 42 	movx.w	&0x0019a,0(r14)	;
    ce0a:	9a 01 00 00 

0000ce0e <.Loc.58.1>:
  } while (cause[i]);
    ce0e:	2d 4e       	mov	@r14,	r13	;
    ce10:	0d 93       	cmp	#0,	r13	;r3 As==00
    ce12:	f2 23       	jnz	$-26     	;abs 0xcdf8

0000ce14 <.Loc.66.1>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    ce14:	40 18 b2 40 	movx.w	#23168,	&0x0015c;0x05a80
    ce18:	80 5a 5c 01 

0000ce1c <.Loc.68.1>:

  halInit();
    ce1c:	b0 13 c4 4a 	calla	#19140		;0x04ac4

0000ce20 <.LVL5>:
  elyNLInit();
    ce20:	b0 13 92 c3 	calla	#50066		;0x0c392

0000ce24 <.LVL6>:
  elyFramInit();
    ce24:	b0 13 1c b5 	calla	#46364		;0x0b51c

0000ce28 <.LVL7>:
  elyRegInit();
    ce28:	b0 13 0a a7 	calla	#42762		;0x0a70a

0000ce2c <.LVL8>:
  chSysInit();
    ce2c:	b0 13 6e 44 	calla	#17518		;0x0446e

0000ce30 <.L6>:
    ce30:	80 00 30 ce 	mova	#52784,	r0	;0x0ce30

0000ce34 <__mspabi_mpyll>:
    ce34:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000ce36 <.LCFI0>:
    ce36:	b1 00 1c 00 	suba	#28,	r1	;0x0001c

0000ce3a <.LCFI1>:
    ce3a:	81 49 08 00 	mov	r9,	8(r1)	;
    ce3e:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    ce42:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    ce46:	07 4c       	mov	r12,	r7	;
    ce48:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    ce4c:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    ce50:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

0000ce54 <.LBB2>:
    ce54:	09 48       	mov	r8,	r9	;
    ce56:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c
    ce5a:	0c 48       	mov	r8,	r12	;

0000ce5c <.LVL3>:
    ce5c:	1d 41 08 00 	mov	8(r1),	r13	;
    ce60:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ce64:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    ce68:	04 4c       	mov	r12,	r4	;
    ce6a:	05 4d       	mov	r13,	r5	;

0000ce6c <.LVL5>:
    ce6c:	81 47 0e 00 	mov	r7,	14(r1)	; 0x000e
    ce70:	0c 47       	mov	r7,	r12	;
    ce72:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    ce76:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ce7a:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    ce7e:	81 4c 00 00 	mov	r12,	0(r1)	;
    ce82:	81 4d 02 00 	mov	r13,	2(r1)	;

0000ce86 <.LVL8>:
    ce86:	88 00 20 d3 	mova	#54048,	r8	;0x0d320

0000ce8a <.LVL9>:
    ce8a:	0e 47       	mov	r7,	r14	;
    ce8c:	4f 43       	clr.b	r15		;
    ce8e:	0c 49       	mov	r9,	r12	;
    ce90:	0d 4f       	mov	r15,	r13	;
    ce92:	48 13       	calla	r8		;

0000ce94 <.LVL10>:
    ce94:	06 4c       	mov	r12,	r6	;
    ce96:	81 4c 10 00 	mov	r12,	16(r1)	; 0x0010
    ce9a:	81 4d 12 00 	mov	r13,	18(r1)	; 0x0012

0000ce9e <.LVL11>:
    ce9e:	0e 47       	mov	r7,	r14	;
    cea0:	4f 43       	clr.b	r15		;
    cea2:	0c 44       	mov	r4,	r12	;
    cea4:	0d 45       	mov	r5,	r13	;

0000cea6 <.LVL12>:
    cea6:	48 13       	calla	r8		;

0000cea8 <.LVL13>:
    cea8:	07 4c       	mov	r12,	r7	;
    ceaa:	0a 4d       	mov	r13,	r10	;

0000ceac <.LVL15>:
    ceac:	2e 41       	mov	@r1,	r14	;
    ceae:	1f 41 02 00 	mov	2(r1),	r15	;
    ceb2:	0c 44       	mov	r4,	r12	;
    ceb4:	0d 45       	mov	r5,	r13	;
    ceb6:	48 13       	calla	r8		;

0000ceb8 <.LVL16>:
    ceb8:	04 4c       	mov	r12,	r4	;

0000ceba <.LVL17>:
    ceba:	05 4d       	mov	r13,	r5	;

0000cebc <.LVL18>:
    cebc:	2e 41       	mov	@r1,	r14	;
    cebe:	1f 41 02 00 	mov	2(r1),	r15	;
    cec2:	0c 49       	mov	r9,	r12	;
    cec4:	4d 43       	clr.b	r13		;
    cec6:	48 13       	calla	r8		;

0000cec8 <.LVL19>:
    cec8:	09 4c       	mov	r12,	r9	;
    ceca:	09 57       	add	r7,	r9	;
    cecc:	08 4d       	mov	r13,	r8	;
    cece:	08 6a       	addc	r10,	r8	;
    ced0:	0c 46       	mov	r6,	r12	;
    ced2:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    ced6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ceda:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    cede:	09 5c       	add	r12,	r9	;
    cee0:	0d 68       	addc	r8,	r13	;

0000cee2 <.LVL23>:
    cee2:	0d 9a       	cmp	r10,	r13	;
    cee4:	04 28       	jnc	$+10     	;abs 0xceee
    cee6:	0a 9d       	cmp	r13,	r10	;
    cee8:	04 20       	jnz	$+10     	;abs 0xcef2
    ceea:	09 97       	cmp	r7,	r9	;
    ceec:	02 2c       	jc	$+6      	;abs 0xcef2

0000ceee <.L4>:
    ceee:	04 53       	add	#0,	r4	;r3 As==00

0000cef0 <.LVL24>:
    cef0:	15 63       	addc	#1,	r5	;r3 As==01

0000cef2 <.L2>:
    cef2:	0c 49       	mov	r9,	r12	;
    cef4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    cef8:	b0 13 dc d2 	calla	#53980		;0x0d2dc

0000cefc <.LVL26>:
    cefc:	08 44       	mov	r4,	r8	;
    cefe:	08 5c       	add	r12,	r8	;
    cf00:	0d 65       	addc	r5,	r13	;
    cf02:	0a 4d       	mov	r13,	r10	;

0000cf04 <.LVL27>:
    cf04:	47 43       	clr.b	r7		;
    cf06:	0c 49       	mov	r9,	r12	;
    cf08:	0d 47       	mov	r7,	r13	;
    cf0a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    cf0e:	b0 13 b4 d1 	calla	#53684		;0x0d1b4
    cf12:	1f 41 10 00 	mov	16(r1),	r15	;0x00010
    cf16:	0c 5f       	add	r15,	r12	;
    cf18:	0d 67       	addc	r7,	r13	;

0000cf1a <.LBE2>:
    cf1a:	04 4c       	mov	r12,	r4	;

0000cf1c <.LVL29>:
    cf1c:	05 4d       	mov	r13,	r5	;
    cf1e:	06 48       	mov	r8,	r6	;

0000cf20 <.LVL30>:
    cf20:	07 4a       	mov	r10,	r7	;

0000cf22 <.Loc.553.1>:
    cf22:	88 00 20 d3 	mova	#54048,	r8	;0x0d320
    cf26:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    cf2a:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    cf2e:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    cf32:	1d 41 08 00 	mov	8(r1),	r13	;
    cf36:	48 13       	calla	r8		;

0000cf38 <.LVL31>:
    cf38:	0a 4c       	mov	r12,	r10	;
    cf3a:	09 4d       	mov	r13,	r9	;

0000cf3c <.Loc.554.1>:
    cf3c:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    cf40:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    cf44:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    cf48:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    cf4c:	48 13       	calla	r8		;

0000cf4e <.LVL32>:
    cf4e:	0a 5c       	add	r12,	r10	;
    cf50:	81 4a 04 00 	mov	r10,	4(r1)	;
    cf54:	09 6d       	addc	r13,	r9	;
    cf56:	81 49 06 00 	mov	r9,	6(r1)	;

0000cf5a <.Loc.553.1>:
    cf5a:	40 18 16 51 	addx.w	4(r1),	r6	;
    cf5e:	04 00 
    cf60:	40 18 17 61 	addcx.w	6(r1),	r7	;
    cf64:	06 00 

0000cf66 <.Loc.557.1>:
    cf66:	0c 44       	mov	r4,	r12	;
    cf68:	0d 45       	mov	r5,	r13	;
    cf6a:	0e 46       	mov	r6,	r14	;
    cf6c:	0f 47       	mov	r7,	r15	;
    cf6e:	a1 00 1c 00 	adda	#28,	r1	;0x0001c

0000cf72 <.LVL33>:
    cf72:	64 16       	popm.a	#7,	r10	;20-bit words
    cf74:	10 01       	reta			;

0000cf76 <__ashrdi3>:
    cf76:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000cf78 <.LCFI0>:
    cf78:	b1 00 04 00 	suba	#4,	r1	;

0000cf7c <.LCFI1>:
    cf7c:	05 4c       	mov	r12,	r5	;
    cf7e:	0a 4d       	mov	r13,	r10	;
    cf80:	1b 41 24 00 	mov	36(r1),	r11	;0x00024

0000cf84 <.Loc.461.1>:
    cf84:	0b 93       	cmp	#0,	r11	;r3 As==00
    cf86:	22 24       	jz	$+70     	;abs 0xcfcc

0000cf88 <.Loc.465.1>:
    cf88:	40 18 37 40 	movx.w	#32,	r7	;0x00020
    cf8c:	20 00 
    cf8e:	40 18 07 8b 	subx.w	r11,	r7	;

0000cf92 <.LVL1>:
    cf92:	4c 43       	clr.b	r12		;

0000cf94 <.LVL2>:
    cf94:	0c 97       	cmp	r7,	r12	;
    cf96:	20 38       	jl	$+66     	;abs 0xcfd8

0000cf98 <.Loc.471.1>:
    cf98:	06 4e       	mov	r14,	r6	;
    cf9a:	0a 4f       	mov	r15,	r10	;
    cf9c:	0c 4e       	mov	r14,	r12	;
    cf9e:	0d 4f       	mov	r15,	r13	;
    cfa0:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    cfa4:	b0 13 28 d2 	calla	#53800		;0x0d228
    cfa8:	08 4c       	mov	r12,	r8	;
    cfaa:	09 4d       	mov	r13,	r9	;

0000cfac <.Loc.472.1>:
    cfac:	40 18 0e 43 	clrx.w	r14		;
    cfb0:	40 18 0e 87 	subx.w	r7,	r14	;
    cfb4:	0c 46       	mov	r6,	r12	;
    cfb6:	0d 4a       	mov	r10,	r13	;
    cfb8:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    cfbc:	0f 7f       	subc	r15,	r15	;
    cfbe:	3f e3       	inv	r15		;
    cfc0:	b0 13 28 d2 	calla	#53800		;0x0d228
    cfc4:	05 4c       	mov	r12,	r5	;
    cfc6:	0a 4d       	mov	r13,	r10	;

0000cfc8 <.L4>:
    cfc8:	0e 48       	mov	r8,	r14	;
    cfca:	0f 49       	mov	r9,	r15	;

0000cfcc <.L2>:
    cfcc:	0c 45       	mov	r5,	r12	;
    cfce:	0d 4a       	mov	r10,	r13	;
    cfd0:	a1 00 04 00 	adda	#4,	r1	;
    cfd4:	64 16       	popm.a	#7,	r10	;20-bit words
    cfd6:	10 01       	reta			;

0000cfd8 <.L3>:
    cfd8:	04 4e       	mov	r14,	r4	;
    cfda:	06 4f       	mov	r15,	r6	;

0000cfdc <.Loc.478.1>:
    cfdc:	0c 4e       	mov	r14,	r12	;
    cfde:	0d 4f       	mov	r15,	r13	;
    cfe0:	0e 4b       	mov	r11,	r14	;
    cfe2:	0f 4b       	mov	r11,	r15	;
    cfe4:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    cfe8:	71 0b 00 00 	mova	r11,	0(r1)	;
    cfec:	b0 13 28 d2 	calla	#53800		;0x0d228

0000cff0 <.LVL9>:
    cff0:	08 4c       	mov	r12,	r8	;
    cff2:	09 4d       	mov	r13,	r9	;

0000cff4 <.Loc.479.1>:
    cff4:	0c 45       	mov	r5,	r12	;
    cff6:	0d 4a       	mov	r10,	r13	;
    cff8:	0b 01       	mova	@r1,	r11	;
    cffa:	0e 4b       	mov	r11,	r14	;
    cffc:	0f 43       	clr	r15		;
    cffe:	b0 13 dc d2 	calla	#53980		;0x0d2dc
    d002:	05 4c       	mov	r12,	r5	;
    d004:	0a 4d       	mov	r13,	r10	;

0000d006 <.Loc.476.1>:
    d006:	0c 44       	mov	r4,	r12	;
    d008:	0d 46       	mov	r6,	r13	;
    d00a:	0e 47       	mov	r7,	r14	;
    d00c:	0f 43       	clr	r15		;
    d00e:	b0 13 b4 d1 	calla	#53684		;0x0d1b4

0000d012 <.Loc.479.1>:
    d012:	0a dd       	bis	r13,	r10	;
    d014:	0d 45       	mov	r5,	r13	;
    d016:	0d dc       	bis	r12,	r13	;
    d018:	05 4d       	mov	r13,	r5	;
    d01a:	80 00 c8 cf 	mova	#53192,	r0	;0x0cfc8

0000d01e <udivmodsi4>:
    d01e:	5a 14       	pushm.a	#6,	r10	;20-bit words

0000d020 <.LCFI0>:
    d020:	0a 4c       	mov	r12,	r10	;
    d022:	0b 4d       	mov	r13,	r11	;

0000d024 <.LVL1>:
    d024:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000d028 <.Loc.35.1>:
    d028:	58 43       	mov.b	#1,	r8	;r3 As==01
    d02a:	49 43       	clr.b	r9		;

0000d02c <.Loc.38.1>:
    d02c:	07 4b       	mov	r11,	r7	;

0000d02e <.L2>:
    d02e:	0f 9b       	cmp	r11,	r15	;
    d030:	11 28       	jnc	$+36     	;abs 0xd054
    d032:	07 9f       	cmp	r15,	r7	;
    d034:	02 20       	jnz	$+6      	;abs 0xd03a
    d036:	0e 9a       	cmp	r10,	r14	;
    d038:	0d 28       	jnc	$+28     	;abs 0xd054

0000d03a <.L20>:
    d03a:	4c 43       	clr.b	r12		;

0000d03c <.LVL3>:
    d03c:	0d 4c       	mov	r12,	r13	;

0000d03e <.L5>:
    d03e:	07 48       	mov	r8,	r7	;
    d040:	07 d9       	bis	r9,	r7	;
    d042:	07 93       	cmp	#0,	r7	;r3 As==00
    d044:	1a 20       	jnz	$+54     	;abs 0xd07a

0000d046 <.L6>:
    d046:	81 93 1c 00 	cmp	#0,	28(r1)	;r3 As==00, 0x001c
    d04a:	02 24       	jz	$+6      	;abs 0xd050
    d04c:	0c 4a       	mov	r10,	r12	;
    d04e:	0d 4b       	mov	r11,	r13	;

0000d050 <.L1>:
    d050:	55 16       	popm.a	#6,	r10	;20-bit words
    d052:	10 01       	reta			;

0000d054 <.L3>:
    d054:	3d 53       	add	#-1,	r13	;r3 As==11

0000d056 <.Loc.38.1>:
    d056:	0d 93       	cmp	#0,	r13	;r3 As==00
    d058:	24 24       	jz	$+74     	;abs 0xd0a2

0000d05a <.Loc.38.1>:
    d05a:	0f 93       	cmp	#0,	r15	;r3 As==00
    d05c:	ee 3b       	jl	$-34     	;abs 0xd03a

0000d05e <.Loc.40.1>:
    d05e:	05 4e       	mov	r14,	r5	;
    d060:	06 4f       	mov	r15,	r6	;
    d062:	05 5e       	add	r14,	r5	;
    d064:	06 6f       	addc	r15,	r6	;
    d066:	0e 45       	mov	r5,	r14	;

0000d068 <.LVL7>:
    d068:	0f 46       	mov	r6,	r15	;

0000d06a <.LVL8>:
    d06a:	05 48       	mov	r8,	r5	;
    d06c:	06 49       	mov	r9,	r6	;
    d06e:	05 58       	add	r8,	r5	;
    d070:	06 69       	addc	r9,	r6	;
    d072:	08 45       	mov	r5,	r8	;

0000d074 <.LVL9>:
    d074:	09 46       	mov	r6,	r9	;

0000d076 <.LVL10>:
    d076:	80 00 2e d0 	mova	#53294,	r0	;0x0d02e

0000d07a <.L12>:
    d07a:	0b 9f       	cmp	r15,	r11	;
    d07c:	0a 28       	jnc	$+22     	;abs 0xd092
    d07e:	0f 9b       	cmp	r11,	r15	;
    d080:	02 20       	jnz	$+6      	;abs 0xd086
    d082:	0a 9e       	cmp	r14,	r10	;
    d084:	06 28       	jnc	$+14     	;abs 0xd092

0000d086 <.L16>:
    d086:	40 18 0a 8e 	subx.w	r14,	r10	;
    d08a:	40 18 0b 7f 	subcx.w	r15,	r11	;

0000d08e <.Loc.48.1>:
    d08e:	0c d8       	bis	r8,	r12	;

0000d090 <.LVL13>:
    d090:	0d d9       	bis	r9,	r13	;

0000d092 <.L10>:
    d092:	12 c3       	clrc			
    d094:	09 10       	rrc	r9		;
    d096:	08 10       	rrc	r8		;

0000d098 <.Loc.51.1>:
    d098:	12 c3       	clrc			
    d09a:	0f 10       	rrc	r15		;
    d09c:	0e 10       	rrc	r14		;
    d09e:	80 00 3e d0 	mova	#53310,	r0	;0x0d03e

0000d0a2 <.L14>:
    d0a2:	0c 4d       	mov	r13,	r12	;

0000d0a4 <.LVL18>:
    d0a4:	80 00 46 d0 	mova	#53318,	r0	;0x0d046

0000d0a8 <__mspabi_divli>:
    d0a8:	6a 14       	pushm.a	#7,	r10	;20-bit words

0000d0aa <.LCFI1>:
    d0aa:	b1 00 02 00 	suba	#2,	r1	;

0000d0ae <.LCFI2>:
    d0ae:	0a 4c       	mov	r12,	r10	;
    d0b0:	0b 4d       	mov	r13,	r11	;
    d0b2:	08 4e       	mov	r14,	r8	;
    d0b4:	09 4f       	mov	r15,	r9	;

0000d0b6 <.LVL20>:
    d0b6:	07 4d       	mov	r13,	r7	;
    d0b8:	86 00 1e d0 	mova	#53278,	r6	;0x0d01e
    d0bc:	0d 93       	cmp	#0,	r13	;r3 As==00
    d0be:	34 34       	jge	$+106    	;abs 0xd128

0000d0c0 <.Loc.66.1>:
    d0c0:	4c 43       	clr.b	r12		;

0000d0c2 <.LVL21>:
    d0c2:	4d 43       	clr.b	r13		;
    d0c4:	04 4c       	mov	r12,	r4	;
    d0c6:	05 4d       	mov	r13,	r5	;
    d0c8:	40 18 04 8a 	subx.w	r10,	r4	;
    d0cc:	40 18 05 7b 	subcx.w	r11,	r5	;
    d0d0:	0a 44       	mov	r4,	r10	;
    d0d2:	0b 45       	mov	r5,	r11	;

0000d0d4 <.LVL22>:
    d0d4:	0f 93       	cmp	#0,	r15	;r3 As==00
    d0d6:	1c 34       	jge	$+58     	;abs 0xd110

0000d0d8 <.Loc.67.1>:
    d0d8:	57 43       	mov.b	#1,	r7	;r3 As==01

0000d0da <.L28>:
    d0da:	4e 43       	clr.b	r14		;
    d0dc:	4f 43       	clr.b	r15		;
    d0de:	40 18 0e 88 	subx.w	r8,	r14	;
    d0e2:	40 18 0f 79 	subcx.w	r9,	r15	;

0000d0e6 <.Loc.76.1>:
    d0e6:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d0ea:	0c 4a       	mov	r10,	r12	;
    d0ec:	0d 4b       	mov	r11,	r13	;
    d0ee:	46 13       	calla	r6		;

0000d0f0 <.LVL24>:
    d0f0:	17 93       	cmp	#1,	r7	;r3 As==01
    d0f2:	0a 24       	jz	$+22     	;abs 0xd108

0000d0f4 <.L27>:
    d0f4:	4e 43       	clr.b	r14		;
    d0f6:	4f 43       	clr.b	r15		;
    d0f8:	0a 4e       	mov	r14,	r10	;

0000d0fa <.LVL26>:
    d0fa:	0b 4f       	mov	r15,	r11	;
    d0fc:	40 18 0a 8c 	subx.w	r12,	r10	;
    d100:	40 18 0b 7d 	subcx.w	r13,	r11	;
    d104:	0c 4a       	mov	r10,	r12	;

0000d106 <.LVL27>:
    d106:	0d 4b       	mov	r11,	r13	;

0000d108 <.L21>:
    d108:	a1 00 02 00 	adda	#2,	r1	;
    d10c:	64 16       	popm.a	#7,	r10	;20-bit words
    d10e:	10 01       	reta			;

0000d110 <.L24>:
    d110:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d114:	0c 44       	mov	r4,	r12	;
    d116:	0d 45       	mov	r5,	r13	;
    d118:	46 13       	calla	r6		;

0000d11a <.LVL30>:
    d11a:	80 00 f4 d0 	mova	#53492,	r0	;0x0d0f4

0000d11e <.L35>:
    d11e:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d122:	46 13       	calla	r6		;

0000d124 <.LVL32>:
    d124:	80 00 08 d1 	mova	#53512,	r0	;0x0d108

0000d128 <.L22>:
    d128:	07 4f       	mov	r15,	r7	;
    d12a:	0f 93       	cmp	#0,	r15	;r3 As==00
    d12c:	f8 37       	jge	$-14     	;abs 0xd11e

0000d12e <.Loc.61.1>:
    d12e:	47 43       	clr.b	r7		;
    d130:	80 00 da d0 	mova	#53466,	r0	;0x0d0da

0000d134 <__mspabi_divlu>:
    d134:	b1 00 02 00 	suba	#2,	r1	;

0000d138 <.LCFI5>:
    d138:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d13c:	b0 13 1e d0 	calla	#53278		;0x0d01e

0000d140 <.LVL46>:
    d140:	a1 00 02 00 	adda	#2,	r1	;
    d144:	10 01       	reta			;

0000d146 <__mspabi_slli_15>:
    d146:	0c 5c       	rla	r12		;

0000d148 <__mspabi_slli_14>:
    d148:	0c 5c       	rla	r12		;

0000d14a <__mspabi_slli_13>:
    d14a:	0c 5c       	rla	r12		;

0000d14c <__mspabi_slli_12>:
    d14c:	0c 5c       	rla	r12		;

0000d14e <__mspabi_slli_11>:
    d14e:	0c 5c       	rla	r12		;

0000d150 <__mspabi_slli_10>:
    d150:	0c 5c       	rla	r12		;

0000d152 <__mspabi_slli_9>:
    d152:	0c 5c       	rla	r12		;

0000d154 <__mspabi_slli_8>:
    d154:	0c 5c       	rla	r12		;

0000d156 <__mspabi_slli_7>:
    d156:	0c 5c       	rla	r12		;

0000d158 <__mspabi_slli_6>:
    d158:	0c 5c       	rla	r12		;

0000d15a <__mspabi_slli_5>:
    d15a:	0c 5c       	rla	r12		;

0000d15c <__mspabi_slli_4>:
    d15c:	0c 5c       	rla	r12		;

0000d15e <__mspabi_slli_3>:
    d15e:	0c 5c       	rla	r12		;

0000d160 <__mspabi_slli_2>:
    d160:	0c 5c       	rla	r12		;

0000d162 <__mspabi_slli_1>:
    d162:	0c 5c       	rla	r12		;
    d164:	10 01       	reta			;

0000d166 <.L11>:
    d166:	3d 53       	add	#-1,	r13	;r3 As==11
    d168:	0c 5c       	rla	r12		;

0000d16a <__mspabi_slli>:
    d16a:	0d 93       	cmp	#0,	r13	;r3 As==00
    d16c:	fc 23       	jnz	$-6      	;abs 0xd166
    d16e:	10 01       	reta			;

0000d170 <__mspabi_slll_15>:
    d170:	0c 5c       	rla	r12		;
    d172:	0d 6d       	rlc	r13		;

0000d174 <__mspabi_slll_14>:
    d174:	0c 5c       	rla	r12		;
    d176:	0d 6d       	rlc	r13		;

0000d178 <__mspabi_slll_13>:
    d178:	0c 5c       	rla	r12		;
    d17a:	0d 6d       	rlc	r13		;

0000d17c <__mspabi_slll_12>:
    d17c:	0c 5c       	rla	r12		;
    d17e:	0d 6d       	rlc	r13		;

0000d180 <__mspabi_slll_11>:
    d180:	0c 5c       	rla	r12		;
    d182:	0d 6d       	rlc	r13		;

0000d184 <__mspabi_slll_10>:
    d184:	0c 5c       	rla	r12		;
    d186:	0d 6d       	rlc	r13		;

0000d188 <__mspabi_slll_9>:
    d188:	0c 5c       	rla	r12		;
    d18a:	0d 6d       	rlc	r13		;

0000d18c <__mspabi_slll_8>:
    d18c:	0c 5c       	rla	r12		;
    d18e:	0d 6d       	rlc	r13		;

0000d190 <__mspabi_slll_7>:
    d190:	0c 5c       	rla	r12		;
    d192:	0d 6d       	rlc	r13		;

0000d194 <__mspabi_slll_6>:
    d194:	0c 5c       	rla	r12		;
    d196:	0d 6d       	rlc	r13		;

0000d198 <__mspabi_slll_5>:
    d198:	0c 5c       	rla	r12		;
    d19a:	0d 6d       	rlc	r13		;

0000d19c <__mspabi_slll_4>:
    d19c:	0c 5c       	rla	r12		;
    d19e:	0d 6d       	rlc	r13		;

0000d1a0 <__mspabi_slll_3>:
    d1a0:	0c 5c       	rla	r12		;
    d1a2:	0d 6d       	rlc	r13		;

0000d1a4 <__mspabi_slll_2>:
    d1a4:	0c 5c       	rla	r12		;
    d1a6:	0d 6d       	rlc	r13		;

0000d1a8 <__mspabi_slll_1>:
    d1a8:	0c 5c       	rla	r12		;
    d1aa:	0d 6d       	rlc	r13		;
    d1ac:	10 01       	reta			;

0000d1ae <.L12>:
    d1ae:	3e 53       	add	#-1,	r14	;r3 As==11
    d1b0:	0c 5c       	rla	r12		;
    d1b2:	0d 6d       	rlc	r13		;

0000d1b4 <__mspabi_slll>:
    d1b4:	0e 93       	cmp	#0,	r14	;r3 As==00
    d1b6:	fb 23       	jnz	$-8      	;abs 0xd1ae
    d1b8:	10 01       	reta			;

0000d1ba <__mspabi_srai_15>:
    d1ba:	0c 11       	rra	r12		;

0000d1bc <__mspabi_srai_14>:
    d1bc:	0c 11       	rra	r12		;

0000d1be <__mspabi_srai_13>:
    d1be:	0c 11       	rra	r12		;

0000d1c0 <__mspabi_srai_12>:
    d1c0:	0c 11       	rra	r12		;

0000d1c2 <__mspabi_srai_11>:
    d1c2:	0c 11       	rra	r12		;

0000d1c4 <__mspabi_srai_10>:
    d1c4:	0c 11       	rra	r12		;

0000d1c6 <__mspabi_srai_9>:
    d1c6:	0c 11       	rra	r12		;

0000d1c8 <__mspabi_srai_8>:
    d1c8:	0c 11       	rra	r12		;

0000d1ca <__mspabi_srai_7>:
    d1ca:	0c 11       	rra	r12		;

0000d1cc <__mspabi_srai_6>:
    d1cc:	0c 11       	rra	r12		;

0000d1ce <__mspabi_srai_5>:
    d1ce:	0c 11       	rra	r12		;

0000d1d0 <__mspabi_srai_4>:
    d1d0:	0c 11       	rra	r12		;

0000d1d2 <__mspabi_srai_3>:
    d1d2:	0c 11       	rra	r12		;

0000d1d4 <__mspabi_srai_2>:
    d1d4:	0c 11       	rra	r12		;

0000d1d6 <__mspabi_srai_1>:
    d1d6:	0c 11       	rra	r12		;
    d1d8:	10 01       	reta			;

0000d1da <.L11>:
    d1da:	3d 53       	add	#-1,	r13	;r3 As==11
    d1dc:	0c 11       	rra	r12		;

0000d1de <__mspabi_srai>:
    d1de:	0d 93       	cmp	#0,	r13	;r3 As==00
    d1e0:	fc 23       	jnz	$-6      	;abs 0xd1da
    d1e2:	10 01       	reta			;

0000d1e4 <__mspabi_sral_15>:
    d1e4:	0d 11       	rra	r13		;
    d1e6:	0c 10       	rrc	r12		;

0000d1e8 <__mspabi_sral_14>:
    d1e8:	0d 11       	rra	r13		;
    d1ea:	0c 10       	rrc	r12		;

0000d1ec <__mspabi_sral_13>:
    d1ec:	0d 11       	rra	r13		;
    d1ee:	0c 10       	rrc	r12		;

0000d1f0 <__mspabi_sral_12>:
    d1f0:	0d 11       	rra	r13		;
    d1f2:	0c 10       	rrc	r12		;

0000d1f4 <__mspabi_sral_11>:
    d1f4:	0d 11       	rra	r13		;
    d1f6:	0c 10       	rrc	r12		;

0000d1f8 <__mspabi_sral_10>:
    d1f8:	0d 11       	rra	r13		;
    d1fa:	0c 10       	rrc	r12		;

0000d1fc <__mspabi_sral_9>:
    d1fc:	0d 11       	rra	r13		;
    d1fe:	0c 10       	rrc	r12		;

0000d200 <__mspabi_sral_8>:
    d200:	0d 11       	rra	r13		;
    d202:	0c 10       	rrc	r12		;

0000d204 <__mspabi_sral_7>:
    d204:	0d 11       	rra	r13		;
    d206:	0c 10       	rrc	r12		;

0000d208 <__mspabi_sral_6>:
    d208:	0d 11       	rra	r13		;
    d20a:	0c 10       	rrc	r12		;

0000d20c <__mspabi_sral_5>:
    d20c:	0d 11       	rra	r13		;
    d20e:	0c 10       	rrc	r12		;

0000d210 <__mspabi_sral_4>:
    d210:	0d 11       	rra	r13		;
    d212:	0c 10       	rrc	r12		;

0000d214 <__mspabi_sral_3>:
    d214:	0d 11       	rra	r13		;
    d216:	0c 10       	rrc	r12		;

0000d218 <__mspabi_sral_2>:
    d218:	0d 11       	rra	r13		;
    d21a:	0c 10       	rrc	r12		;

0000d21c <__mspabi_sral_1>:
    d21c:	0d 11       	rra	r13		;
    d21e:	0c 10       	rrc	r12		;
    d220:	10 01       	reta			;

0000d222 <.L12>:
    d222:	3e 53       	add	#-1,	r14	;r3 As==11
    d224:	0d 11       	rra	r13		;
    d226:	0c 10       	rrc	r12		;

0000d228 <__mspabi_sral>:
    d228:	0e 93       	cmp	#0,	r14	;r3 As==00
    d22a:	fb 23       	jnz	$-8      	;abs 0xd222
    d22c:	10 01       	reta			;

0000d22e <__mspabi_srli_15>:
    d22e:	12 c3       	clrc			
    d230:	0c 10       	rrc	r12		;

0000d232 <__mspabi_srli_14>:
    d232:	12 c3       	clrc			
    d234:	0c 10       	rrc	r12		;

0000d236 <__mspabi_srli_13>:
    d236:	12 c3       	clrc			
    d238:	0c 10       	rrc	r12		;

0000d23a <__mspabi_srli_12>:
    d23a:	12 c3       	clrc			
    d23c:	0c 10       	rrc	r12		;

0000d23e <__mspabi_srli_11>:
    d23e:	12 c3       	clrc			
    d240:	0c 10       	rrc	r12		;

0000d242 <__mspabi_srli_10>:
    d242:	12 c3       	clrc			
    d244:	0c 10       	rrc	r12		;

0000d246 <__mspabi_srli_9>:
    d246:	12 c3       	clrc			
    d248:	0c 10       	rrc	r12		;

0000d24a <__mspabi_srli_8>:
    d24a:	12 c3       	clrc			
    d24c:	0c 10       	rrc	r12		;

0000d24e <__mspabi_srli_7>:
    d24e:	12 c3       	clrc			
    d250:	0c 10       	rrc	r12		;

0000d252 <__mspabi_srli_6>:
    d252:	12 c3       	clrc			
    d254:	0c 10       	rrc	r12		;

0000d256 <__mspabi_srli_5>:
    d256:	12 c3       	clrc			
    d258:	0c 10       	rrc	r12		;

0000d25a <__mspabi_srli_4>:
    d25a:	12 c3       	clrc			
    d25c:	0c 10       	rrc	r12		;

0000d25e <__mspabi_srli_3>:
    d25e:	12 c3       	clrc			
    d260:	0c 10       	rrc	r12		;

0000d262 <__mspabi_srli_2>:
    d262:	12 c3       	clrc			
    d264:	0c 10       	rrc	r12		;

0000d266 <__mspabi_srli_1>:
    d266:	12 c3       	clrc			
    d268:	0c 10       	rrc	r12		;
    d26a:	10 01       	reta			;

0000d26c <.L11>:
    d26c:	3d 53       	add	#-1,	r13	;r3 As==11
    d26e:	12 c3       	clrc			
    d270:	0c 10       	rrc	r12		;

0000d272 <__mspabi_srli>:
    d272:	0d 93       	cmp	#0,	r13	;r3 As==00
    d274:	fb 23       	jnz	$-8      	;abs 0xd26c
    d276:	10 01       	reta			;

0000d278 <__mspabi_srll_15>:
    d278:	12 c3       	clrc			
    d27a:	0d 10       	rrc	r13		;
    d27c:	0c 10       	rrc	r12		;

0000d27e <__mspabi_srll_14>:
    d27e:	12 c3       	clrc			
    d280:	0d 10       	rrc	r13		;
    d282:	0c 10       	rrc	r12		;

0000d284 <__mspabi_srll_13>:
    d284:	12 c3       	clrc			
    d286:	0d 10       	rrc	r13		;
    d288:	0c 10       	rrc	r12		;

0000d28a <__mspabi_srll_12>:
    d28a:	12 c3       	clrc			
    d28c:	0d 10       	rrc	r13		;
    d28e:	0c 10       	rrc	r12		;

0000d290 <__mspabi_srll_11>:
    d290:	12 c3       	clrc			
    d292:	0d 10       	rrc	r13		;
    d294:	0c 10       	rrc	r12		;

0000d296 <__mspabi_srll_10>:
    d296:	12 c3       	clrc			
    d298:	0d 10       	rrc	r13		;
    d29a:	0c 10       	rrc	r12		;

0000d29c <__mspabi_srll_9>:
    d29c:	12 c3       	clrc			
    d29e:	0d 10       	rrc	r13		;
    d2a0:	0c 10       	rrc	r12		;

0000d2a2 <__mspabi_srll_8>:
    d2a2:	12 c3       	clrc			
    d2a4:	0d 10       	rrc	r13		;
    d2a6:	0c 10       	rrc	r12		;

0000d2a8 <__mspabi_srll_7>:
    d2a8:	12 c3       	clrc			
    d2aa:	0d 10       	rrc	r13		;
    d2ac:	0c 10       	rrc	r12		;

0000d2ae <__mspabi_srll_6>:
    d2ae:	12 c3       	clrc			
    d2b0:	0d 10       	rrc	r13		;
    d2b2:	0c 10       	rrc	r12		;

0000d2b4 <__mspabi_srll_5>:
    d2b4:	12 c3       	clrc			
    d2b6:	0d 10       	rrc	r13		;
    d2b8:	0c 10       	rrc	r12		;

0000d2ba <__mspabi_srll_4>:
    d2ba:	12 c3       	clrc			
    d2bc:	0d 10       	rrc	r13		;
    d2be:	0c 10       	rrc	r12		;

0000d2c0 <__mspabi_srll_3>:
    d2c0:	12 c3       	clrc			
    d2c2:	0d 10       	rrc	r13		;
    d2c4:	0c 10       	rrc	r12		;

0000d2c6 <__mspabi_srll_2>:
    d2c6:	12 c3       	clrc			
    d2c8:	0d 10       	rrc	r13		;
    d2ca:	0c 10       	rrc	r12		;

0000d2cc <__mspabi_srll_1>:
    d2cc:	12 c3       	clrc			
    d2ce:	0d 10       	rrc	r13		;
    d2d0:	0c 10       	rrc	r12		;
    d2d2:	10 01       	reta			;

0000d2d4 <.L12>:
    d2d4:	3e 53       	add	#-1,	r14	;r3 As==11
    d2d6:	12 c3       	clrc			
    d2d8:	0d 10       	rrc	r13		;
    d2da:	0c 10       	rrc	r12		;

0000d2dc <__mspabi_srll>:
    d2dc:	0e 93       	cmp	#0,	r14	;r3 As==00
    d2de:	fa 23       	jnz	$-10     	;abs 0xd2d4
    d2e0:	10 01       	reta			;

0000d2e2 <__cmpsi2>:
    d2e2:	0f 9d       	cmp	r13,	r15	;
    d2e4:	05 24       	jz	$+12     	;abs 0xd2f0
    d2e6:	02 34       	jge	$+6      	;abs 0xd2ec

0000d2e8 <.L_greater_than>:
    d2e8:	2c 43       	mov	#2,	r12	;r3 As==10
    d2ea:	10 01       	reta			;

0000d2ec <.L_less_than>:
    d2ec:	0c 43       	clr	r12		;
    d2ee:	10 01       	reta			;

0000d2f0 <.L_compare_low>:
    d2f0:	0e 9c       	cmp	r12,	r14	;
    d2f2:	fa 3b       	jl	$-10     	;abs 0xd2e8
    d2f4:	fb 23       	jnz	$-8      	;abs 0xd2ec
    d2f6:	1c 43       	mov	#1,	r12	;r3 As==01
    d2f8:	10 01       	reta			;

0000d2fa <__ucmpsi2>:
    d2fa:	0d 93       	cmp	#0,	r13	;r3 As==00
    d2fc:	03 30       	jn	$+8      	;abs 0xd304
    d2fe:	0f 93       	cmp	#0,	r15	;r3 As==00
    d300:	f5 33       	jn	$-20     	;abs 0xd2ec
    d302:	ef 2f       	jc	$-32     	;abs 0xd2e2

0000d304 <.L_top_bit_set_in_A>:
    d304:	0f 93       	cmp	#0,	r15	;r3 As==00
    d306:	ed 33       	jn	$-36     	;abs 0xd2e2
    d308:	ef 2f       	jc	$-32     	;abs 0xd2e8

0000d30a <__mspabi_mpyi>:
    d30a:	02 12       	push	r2		;
    d30c:	32 c2       	dint			
    d30e:	03 43       	nop			
    d310:	82 4c c0 04 	mov	r12,	&0x04c0	;
    d314:	82 4d c8 04 	mov	r13,	&0x04c8	;
    d318:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    d31c:	32 41       	pop	r2		;
    d31e:	10 01       	reta			;

0000d320 <__mspabi_mpyl>:
    d320:	02 12       	push	r2		;
    d322:	32 c2       	dint			
    d324:	03 43       	nop			
    d326:	82 4c d0 04 	mov	r12,	&0x04d0	;
    d32a:	82 4d d2 04 	mov	r13,	&0x04d2	;
    d32e:	82 4e e0 04 	mov	r14,	&0x04e0	;
    d332:	82 4f e2 04 	mov	r15,	&0x04e2	;
    d336:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    d33a:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    d33e:	32 41       	pop	r2		;
    d340:	10 01       	reta			;

0000d342 <memcpy>:
    d342:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000d344 <.LCFI0>:
    d344:	ca 0c       	mova	r12,	r10	;
    d346:	ee 0c       	adda	r12,	r14	;

0000d348 <.L2>:
    d348:	da 0e       	cmpa	r14,	r10	;
    d34a:	08 24       	jz	$+18     	;abs 0xd35c

0000d34c <.LVL3>:
    d34c:	ea 4d 00 00 	mov.b	@r13,	0(r10)	;
    d350:	aa 00 01 00 	adda	#1,	r10	;

0000d354 <.LVL4>:
    d354:	ad 00 01 00 	adda	#1,	r13	;
    d358:	80 00 48 d3 	mova	#54088,	r0	;0x0d348

0000d35c <.L5>:
    d35c:	0a 16       	popm.a	#1,	r10	;20-bit words
    d35e:	10 01       	reta			;

0000d360 <memset>:
    d360:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000d362 <.LCFI0>:
    d362:	ca 0c       	mova	r12,	r10	;
    d364:	ee 0c       	adda	r12,	r14	;

0000d366 <.L2>:
    d366:	da 0e       	cmpa	r14,	r10	;
    d368:	06 24       	jz	$+14     	;abs 0xd376

0000d36a <.LVL3>:
    d36a:	ca 4d 00 00 	mov.b	r13,	0(r10)	;
    d36e:	aa 00 01 00 	adda	#1,	r10	;

0000d372 <.LVL4>:
    d372:	80 00 66 d3 	mova	#54118,	r0	;0x0d366

0000d376 <.L5>:
    d376:	0a 16       	popm.a	#1,	r10	;20-bit words
    d378:	10 01       	reta			;

0000d37a <memmove>:
    d37a:	0a 14       	pushm.a	#1,	r10	;20-bit words

0000d37c <.LCFI0>:
    d37c:	08 14       	pushm.a	#1,	r8	;20-bit words

0000d37e <.LCFI1>:
    d37e:	06 14       	pushm.a	#1,	r6	;20-bit words

0000d380 <.LCFI2>:
    d380:	c8 0c       	mova	r12,	r8	;
    d382:	e8 0e       	adda	r14,	r8	;

0000d384 <.Loc.69.1>:
    d384:	dd 0c       	cmpa	r12,	r13	;
    d386:	04 28       	jnc	$+10     	;abs 0xd390

0000d388 <.L4>:
    d388:	ce 0c       	mova	r12,	r14	;

0000d38a <.LVL2>:
    d38a:	ca 0d       	mova	r13,	r10	;
    d38c:	80 00 b4 d3 	mova	#54196,	r0	;0x0d3b4

0000d390 <.L2>:
    d390:	ca 0d       	mova	r13,	r10	;
    d392:	ea 0e       	adda	r14,	r10	;
    d394:	dc 0a       	cmpa	r10,	r12	;
    d396:	f8 2f       	jc	$-14     	;abs 0xd388

0000d398 <.LVL4>:
    d398:	fe 0a       	suba	r10,	r14	;

0000d39a <.L5>:
    d39a:	c6 0a       	mova	r10,	r6	;
    d39c:	e6 0e       	adda	r14,	r6	;

0000d39e <.Loc.74.1>:
    d39e:	96 00 00 00 	cmpa	#0,	r6	;
    d3a2:	12 24       	jz	$+38     	;abs 0xd3c8

0000d3a4 <.Loc.76.1>:
    d3a4:	a8 0f ff ff 	adda	#1048575,r8	;0xfffff
    d3a8:	aa 0f ff ff 	adda	#1048575,r10	;0xfffff

0000d3ac <.LVL7>:
    d3ac:	e8 4a 00 00 	mov.b	@r10,	0(r8)	;
    d3b0:	80 00 9a d3 	mova	#54170,	r0	;0x0d39a

0000d3b4 <.L3>:
    d3b4:	d8 0e       	cmpa	r14,	r8	;
    d3b6:	08 24       	jz	$+18     	;abs 0xd3c8

0000d3b8 <.LVL9>:
    d3b8:	ee 4a 00 00 	mov.b	@r10,	0(r14)	;
    d3bc:	ae 00 01 00 	adda	#1,	r14	;

0000d3c0 <.LVL10>:
    d3c0:	aa 00 01 00 	adda	#1,	r10	;
    d3c4:	80 00 b4 d3 	mova	#54196,	r0	;0x0d3b4

0000d3c8 <.L9>:
    d3c8:	06 16       	popm.a	#1,	r6	;20-bit words
    d3ca:	08 16       	popm.a	#1,	r8	;20-bit words
    d3cc:	0a 16       	popm.a	#1,	r10	;20-bit words
    d3ce:	10 01       	reta			;

Disassembly of section .lower.lowtext:

0000d770 <ISR_MSP430X_ST_ISR>:
PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    d770:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d772 <.LCFI0>:
  OSAL_IRQ_PROLOGUE();
    d772:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d776:	36 13 

0000d778 <.LBB12>:
  chSysTimerHandlerI();
    d778:	b0 13 82 45 	calla	#17794		;0x04582

0000d77c <.LBE12>:
  OSAL_IRQ_EPILOGUE();
    d77c:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    d780:	36 13 
    d782:	b0 13 6c 46 	calla	#18028		;0x0466c

0000d786 <.LVL1>:
    d786:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d788:	02 24       	jz	$+6      	;abs 0xd78e

0000d78a <.Loc.174.1>:
    d78a:	b0 13 7c 46 	calla	#18044		;0x0467c

0000d78e <.L1>:
}
    d78e:	b4 16       	popm.a	#12,	r15	;20-bit words
    d790:	00 13       	reti			

0000d792 <ISR_USCI_A1_VECTOR>:
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    d792:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d794 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    d794:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d798:	36 13 

0000d79a <.Loc.400.2>:
  switch (__even_in_range(UCA1IV, USCI_UART_UCTXCPTIFG)) {
    d79a:	40 18 1c 42 	movx.w	&0x005fe,r12	;
    d79e:	fe 05 
    d7a0:	2c 92       	cmp	#4,	r12	;r2 As==10
    d7a2:	38 24       	jz	$+114    	;abs 0xd814
    d7a4:	3c 92       	cmp	#8,	r12	;r2 As==11
    d7a6:	58 24       	jz	$+178    	;abs 0xd858
    d7a8:	2c 93       	cmp	#2,	r12	;r3 As==10
    d7aa:	25 20       	jnz	$+76     	;abs 0xd7f6

0000d7ac <.Loc.404.2>:
    if (UCA1STATW & UCRXERR)
    d7ac:	40 18 e2 b2 	bitx.b	#4,	&0x005ea;r2 As==10
    d7b0:	ea 05 
    d7b2:	1a 24       	jz	$+54     	;abs 0xd7e8

0000d7b4 <.Loc.405.2>:
      set_error(UCA1STATW, &SD1);
    d7b4:	40 18 5c 42 	movx.b	&0x005ea,r12	;
    d7b8:	ea 05 

0000d7ba <.LBB32>:
  if (sra & UCOE)
    d7ba:	40 18 3c b0 	bitx.w	#32,	r12	;0x00020
    d7be:	20 00 
    d7c0:	25 24       	jz	$+76     	;abs 0xd80c

0000d7c2 <.Loc.317.2>:
    sts |= SD_OVERRUN_ERROR;
    d7c2:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    d7c6:	4e 43       	clr.b	r14		;

0000d7c8 <.L50>:
  if (sra & UCPE)
    d7c8:	40 18 3c b0 	bitx.w	#16,	r12	;0x00010
    d7cc:	10 00 
    d7ce:	02 24       	jz	$+6      	;abs 0xd7d4

0000d7d0 <.Loc.319.2>:
    sts |= SD_PARITY_ERROR;
    d7d0:	3d d0 20 00 	bis	#32,	r13	;#0x0020

0000d7d4 <.L51>:
  if (sra & UCFE)
    d7d4:	40 18 3c b0 	bitx.w	#64,	r12	;0x00040
    d7d8:	40 00 
    d7da:	02 24       	jz	$+6      	;abs 0xd7e0

0000d7dc <.Loc.321.2>:
    sts |= SD_FRAMING_ERROR;
    d7dc:	3d d0 40 00 	bis	#64,	r13	;#0x0040

0000d7e0 <.L52>:
  chnAddFlagsI(sdp, sts);
    d7e0:	8c 01 3c 13 	mova	#70460,	r12	;0x1133c

0000d7e4 <.LVL80>:
    d7e4:	b0 13 74 53 	calla	#21364		;0x05374

0000d7e8 <.L49>:
    sdIncomingDataI(&SD1, UCA1RXBUF);
    d7e8:	40 18 1d 42 	movx.w	&0x005ec,r13	;
    d7ec:	ec 05 
    d7ee:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    d7f2:	b0 13 10 52 	calla	#21008		;0x05210

0000d7f6 <.L45>:
  OSAL_IRQ_EPILOGUE();
    d7f6:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    d7fa:	36 13 
    d7fc:	b0 13 6c 46 	calla	#18028		;0x0466c

0000d800 <.LVL83>:
    d800:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d802:	02 24       	jz	$+6      	;abs 0xd808

0000d804 <.Loc.443.2>:
    d804:	b0 13 7c 46 	calla	#18044		;0x0467c

0000d808 <.L44>:
}
    d808:	b4 16       	popm.a	#12,	r15	;20-bit words
    d80a:	00 13       	reti			

0000d80c <.L57>:
  eventflags_t sts = 0;
    d80c:	4d 43       	clr.b	r13		;
    d80e:	0e 4d       	mov	r13,	r14	;
    d810:	80 00 c8 d7 	mova	#55240,	r0	;0x0d7c8

0000d814 <.L46>:
    b = sdRequestDataI(&SD1);
    d814:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    d818:	b0 13 54 52 	calla	#21076		;0x05254

0000d81c <.LVL87>:
    if (b < Q_OK) {
    d81c:	9c 00 00 00 	cmpa	#0,	r12	;
    d820:	14 34       	jge	$+42     	;abs 0xd84a

0000d822 <.Loc.419.2>:
      chnAddFlagsI(&SD1, CHN_OUTPUT_EMPTY);
    d822:	7d 42       	mov.b	#8,	r13	;r2 As==11
    d824:	4e 43       	clr.b	r14		;
    d826:	8c 01 3c 13 	mova	#70460,	r12	;0x1133c

0000d82a <.LVL88>:
    d82a:	b0 13 74 53 	calla	#21364		;0x05374

0000d82e <.LVL89>:
      UCA1IE = (UCA1IE & ~UCTXIE) | UCTXCPTIE;
    d82e:	40 18 1c 42 	movx.w	&0x005fa,r12	;
    d832:	fa 05 
    d834:	3c f0 f5 ff 	and	#-11,	r12	;#0xfff5
    d838:	3c d2       	bis	#8,	r12	;r2 As==11
    d83a:	40 18 82 4c 	movx.w	r12,	&0x005fa;
    d83e:	fa 05 

0000d840 <.Loc.421.2>:
      UCA1IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    d840:	40 18 a2 d3 	bisx.w	#2,	&0x005fc;r3 As==10
    d844:	fc 05 
    d846:	80 00 f6 d7 	mova	#55286,	r0	;0x0d7f6

0000d84a <.L53>:
      UCA1TXBUF = b;
    d84a:	40 18 0c 4c 	movx.w	r12,	r12	;

0000d84e <.LVL91>:
    d84e:	40 18 82 4c 	movx.w	r12,	&0x005ee;
    d852:	ee 05 
    d854:	80 00 f6 d7 	mova	#55286,	r0	;0x0d7f6

0000d858 <.L47>:
    if (oqIsEmptyI(&SD1.oqueue))
    d858:	8c 01 38 13 	mova	#70456,	r12	;0x11338
    d85c:	81 18 d2 92 	cmpx.a	&0x1137a,&0x11376;
    d860:	7a 13 76 13 
    d864:	05 20       	jnz	$+12     	;abs 0xd870

0000d866 <.Loc.432.2>:
    d866:	3e 0c 32 00 	mova	50(r12),r14	;0x00032
    d86a:	9e 00 00 00 	cmpa	#0,	r14	;
    d86e:	05 20       	jnz	$+12     	;abs 0xd87a

0000d870 <.L54>:
    UCA1IE &= ~UCTXCPTIE;
    d870:	40 18 b2 c2 	bicx.w	#8,	&0x005fa;r2 As==11
    d874:	fa 05 
    d876:	80 00 f6 d7 	mova	#55286,	r0	;0x0d7f6

0000d87a <.L55>:
      chnAddFlagsI(&SD1, CHN_TRANSMISSION_END);
    d87a:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    d87e:	4e 43       	clr.b	r14		;
    d880:	ac 00 04 00 	adda	#4,	r12	;
    d884:	b0 13 74 53 	calla	#21364		;0x05374

0000d888 <.LVL92>:
    d888:	80 00 70 d8 	mova	#55408,	r0	;0x0d870

0000d88c <ISR_PORT1_VECTOR>:
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    d88c:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d88e <.LCFI0>:
    d88e:	b1 00 04 00 	suba	#4,	r1	;

0000d892 <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    d892:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d896:	36 13 

0000d898 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    d898:	40 18 1c 42 	movx.w	&0x0020e,r12	;
    d89c:	0e 02 

0000d89e <.LVL0>:
    d89e:	12 c3       	clrc			
    d8a0:	0c 10       	rrc	r12		;

0000d8a2 <.LVL1>:
    d8a2:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000d8a4 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    d8a4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    d8a8:	0d 43       	clr	r13		;
    d8aa:	0e 4c       	mov	r12,	r14	;
    d8ac:	0f 4d       	mov	r13,	r15	;
    d8ae:	0e 5e       	rla	r14		;
    d8b0:	0f 6f       	rlc	r15		;
    d8b2:	0e 5e       	rla	r14		;
    d8b4:	0f 6f       	rlc	r15		;
    d8b6:	81 4e 00 00 	mov	r14,	0(r1)	;
    d8ba:	81 4f 02 00 	mov	r15,	2(r1)	;
    d8be:	0d 01       	mova	@r1,	r13	;
    d8c0:	80 18 5c 4d 	movx.a	70598(r13),r12	;0x113c6
    d8c4:	c6 13 

0000d8c6 <.LVL2>:
  if (cb != NULL) {
    d8c6:	9c 00 00 00 	cmpa	#0,	r12	;
    d8ca:	01 24       	jz	$+4      	;abs 0xd8ce

0000d8cc <.Loc.81.1>:
    (*cb)();
    d8cc:	4c 13       	calla	r12		;

0000d8ce <.L2>:
  OSAL_IRQ_EPILOGUE();
    d8ce:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    d8d2:	36 13 
    d8d4:	b0 13 6c 46 	calla	#18028		;0x0466c

0000d8d8 <.LVL4>:
    d8d8:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d8da:	02 24       	jz	$+6      	;abs 0xd8e0

0000d8dc <.Loc.84.1>:
    d8dc:	b0 13 7c 46 	calla	#18044		;0x0467c

0000d8e0 <.L1>:
}
    d8e0:	a1 00 04 00 	adda	#4,	r1	;
    d8e4:	b4 16       	popm.a	#12,	r15	;20-bit words
    d8e6:	00 13       	reti			

0000d8e8 <ISR_PORT2_VECTOR>:
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    d8e8:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d8ea <.LCFI2>:
    d8ea:	b1 00 04 00 	suba	#4,	r1	;

0000d8ee <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    d8ee:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d8f2:	36 13 

0000d8f4 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    d8f4:	40 18 1c 42 	movx.w	&0x0021e,r12	;
    d8f8:	1e 02 

0000d8fa <.LVL6>:
    d8fa:	12 c3       	clrc			
    d8fc:	0c 10       	rrc	r12		;

0000d8fe <.LVL7>:
    d8fe:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000d900 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    d900:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    d904:	4c 0e       	rlam.a	#4,	r12	;
    d906:	4c 0d       	rram.a	#4,	r12	;
    d908:	ac 00 08 00 	adda	#8,	r12	;
    d90c:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d90e:	40 18 3c 41 	popx.w	r12		;
    d912:	40 18 3d 41 	popx.w	r13		;
    d916:	0e 4c       	mov	r12,	r14	;
    d918:	0f 4d       	mov	r13,	r15	;
    d91a:	0e 5e       	rla	r14		;
    d91c:	0f 6f       	rlc	r15		;
    d91e:	0e 5e       	rla	r14		;
    d920:	0f 6f       	rlc	r15		;
    d922:	81 4e 00 00 	mov	r14,	0(r1)	;
    d926:	81 4f 02 00 	mov	r15,	2(r1)	;
    d92a:	0d 01       	mova	@r1,	r13	;
    d92c:	80 18 5c 4d 	movx.a	70598(r13),r12	;0x113c6
    d930:	c6 13 

0000d932 <.LVL8>:
  if (cb != NULL) {
    d932:	9c 00 00 00 	cmpa	#0,	r12	;
    d936:	01 24       	jz	$+4      	;abs 0xd93a

0000d938 <.Loc.99.1>:
    (*cb)();
    d938:	4c 13       	calla	r12		;

0000d93a <.L11>:
  OSAL_IRQ_EPILOGUE();
    d93a:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    d93e:	36 13 
    d940:	b0 13 6c 46 	calla	#18028		;0x0466c

0000d944 <.LVL10>:
    d944:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d946:	02 24       	jz	$+6      	;abs 0xd94c

0000d948 <.Loc.102.1>:
    d948:	b0 13 7c 46 	calla	#18044		;0x0467c

0000d94c <.L10>:
}
    d94c:	a1 00 04 00 	adda	#4,	r1	;
    d950:	b4 16       	popm.a	#12,	r15	;20-bit words
    d952:	00 13       	reti			

0000d954 <ISR_PORT3_VECTOR>:
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    d954:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d956 <.LCFI4>:
    d956:	b1 00 04 00 	suba	#4,	r1	;

0000d95a <.LCFI5>:
  OSAL_IRQ_PROLOGUE();
    d95a:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d95e:	36 13 

0000d960 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    d960:	40 18 1c 42 	movx.w	&0x0022e,r12	;
    d964:	2e 02 

0000d966 <.LVL12>:
    d966:	12 c3       	clrc			
    d968:	0c 10       	rrc	r12		;

0000d96a <.LVL13>:
    d96a:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000d96c <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    d96c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    d970:	4c 0e       	rlam.a	#4,	r12	;
    d972:	4c 0d       	rram.a	#4,	r12	;
    d974:	ac 00 10 00 	adda	#16,	r12	;0x00010
    d978:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d97a:	40 18 3c 41 	popx.w	r12		;
    d97e:	40 18 3d 41 	popx.w	r13		;
    d982:	0e 4c       	mov	r12,	r14	;
    d984:	0f 4d       	mov	r13,	r15	;
    d986:	0e 5e       	rla	r14		;
    d988:	0f 6f       	rlc	r15		;
    d98a:	0e 5e       	rla	r14		;
    d98c:	0f 6f       	rlc	r15		;
    d98e:	81 4e 00 00 	mov	r14,	0(r1)	;
    d992:	81 4f 02 00 	mov	r15,	2(r1)	;
    d996:	0d 01       	mova	@r1,	r13	;
    d998:	80 18 5c 4d 	movx.a	70598(r13),r12	;0x113c6
    d99c:	c6 13 

0000d99e <.LVL14>:
  if (cb != NULL) {
    d99e:	9c 00 00 00 	cmpa	#0,	r12	;
    d9a2:	01 24       	jz	$+4      	;abs 0xd9a6

0000d9a4 <.Loc.118.1>:
    (*cb)();
    d9a4:	4c 13       	calla	r12		;

0000d9a6 <.L20>:
  OSAL_IRQ_EPILOGUE();
    d9a6:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    d9aa:	36 13 
    d9ac:	b0 13 6c 46 	calla	#18028		;0x0466c

0000d9b0 <.LVL16>:
    d9b0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    d9b2:	02 24       	jz	$+6      	;abs 0xd9b8

0000d9b4 <.Loc.121.1>:
    d9b4:	b0 13 7c 46 	calla	#18044		;0x0467c

0000d9b8 <.L19>:
}
    d9b8:	a1 00 04 00 	adda	#4,	r1	;
    d9bc:	b4 16       	popm.a	#12,	r15	;20-bit words
    d9be:	00 13       	reti			

0000d9c0 <ISR_PORT4_VECTOR>:
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    d9c0:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000d9c2 <.LCFI6>:
    d9c2:	b1 00 04 00 	suba	#4,	r1	;

0000d9c6 <.LCFI7>:
  OSAL_IRQ_PROLOGUE();
    d9c6:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    d9ca:	36 13 

0000d9cc <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    d9cc:	40 18 1c 42 	movx.w	&0x0023e,r12	;
    d9d0:	3e 02 

0000d9d2 <.LVL18>:
    d9d2:	12 c3       	clrc			
    d9d4:	0c 10       	rrc	r12		;

0000d9d6 <.LVL19>:
    d9d6:	7c 53       	add.b	#-1,	r12	;r3 As==11

0000d9d8 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    d9d8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    d9dc:	4c 0e       	rlam.a	#4,	r12	;
    d9de:	4c 0d       	rram.a	#4,	r12	;
    d9e0:	ac 00 18 00 	adda	#24,	r12	;0x00018
    d9e4:	0c 14       	pushm.a	#1,	r12	;20-bit words
    d9e6:	40 18 3c 41 	popx.w	r12		;
    d9ea:	40 18 3d 41 	popx.w	r13		;
    d9ee:	0e 4c       	mov	r12,	r14	;
    d9f0:	0f 4d       	mov	r13,	r15	;
    d9f2:	0e 5e       	rla	r14		;
    d9f4:	0f 6f       	rlc	r15		;
    d9f6:	0e 5e       	rla	r14		;
    d9f8:	0f 6f       	rlc	r15		;
    d9fa:	81 4e 00 00 	mov	r14,	0(r1)	;
    d9fe:	81 4f 02 00 	mov	r15,	2(r1)	;
    da02:	0d 01       	mova	@r1,	r13	;
    da04:	80 18 5c 4d 	movx.a	70598(r13),r12	;0x113c6
    da08:	c6 13 

0000da0a <.LVL20>:
  if (cb != NULL) {
    da0a:	9c 00 00 00 	cmpa	#0,	r12	;
    da0e:	01 24       	jz	$+4      	;abs 0xda12

0000da10 <.Loc.136.1>:
    (*cb)();
    da10:	4c 13       	calla	r12		;

0000da12 <.L29>:
  OSAL_IRQ_EPILOGUE();
    da12:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    da16:	36 13 
    da18:	b0 13 6c 46 	calla	#18028		;0x0466c

0000da1c <.LVL22>:
    da1c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    da1e:	02 24       	jz	$+6      	;abs 0xda24

0000da20 <.Loc.139.1>:
    da20:	b0 13 7c 46 	calla	#18044		;0x0467c

0000da24 <.L28>:
}
    da24:	a1 00 04 00 	adda	#4,	r1	;
    da28:	b4 16       	popm.a	#12,	r15	;20-bit words
    da2a:	00 13       	reti			

0000da2c <ISR_DMA_VECTOR>:
PORT_IRQ_HANDLER(DMA_VECTOR) {
    da2c:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000da2e <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    da2e:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    da32:	36 13 

0000da34 <.Loc.75.1>:
  index = (DMAIV >> 1) - 1;
    da34:	40 18 18 42 	movx.w	&0x0050e,r8	;
    da38:	0e 05 
    da3a:	12 c3       	clrc			
    da3c:	08 10       	rrc	r8		;
    da3e:	78 53       	add.b	#-1,	r8	;r3 As==11
    da40:	49 48       	mov.b	r8,	r9	;

0000da42 <.LVL6>:
  if (index < MSP430X_DMA_CHANNELS) {
    da42:	6c 43       	mov.b	#2,	r12	;r3 As==10
    da44:	4c 98       	cmp.b	r8,	r12	;
    da46:	30 28       	jnc	$+98     	;abs 0xdaa8

0000da48 <.LBB14>:
    dma_regs[index].ctl &= ~DMAEN;
    da48:	4c 48       	mov.b	r8,	r12	;
    da4a:	0d 43       	clr	r13		;
    da4c:	b0 13 9c d1 	calla	#53660		;0x0d19c
    da50:	0d 12       	push	r13		;
    da52:	0c 12       	push	r12		;
    da54:	0a 16       	popm.a	#1,	r10	;20-bit words
    da56:	aa 00 10 05 	adda	#1296,	r10	;0x00510
    da5a:	ba f0 ef ff 	and	#-17,	0(r10)	;#0xffef
    da5e:	00 00 

0000da60 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    da60:	4d 43       	clr.b	r13		;
    da62:	4c 48       	mov.b	r8,	r12	;
    da64:	b0 13 50 59 	calla	#22864		;0x05950

0000da68 <.LVL8>:
    dma_regs[index].sz  = 0;
    da68:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

0000da6c <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    da6c:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    da70:	00 00 

0000da72 <.Loc.87.1>:
    if (cb->callback != NULL) {
    da72:	8a 01 48 14 	mova	#70728,	r10	;0x11448
    da76:	08 49       	mov	r9,	r8	;
    da78:	09 43       	clr	r9		;

0000da7a <.LVL10>:
    da7a:	0c 48       	mov	r8,	r12	;
    da7c:	0d 49       	mov	r9,	r13	;
    da7e:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    da82:	0d 12       	push	r13		;
    da84:	0c 12       	push	r12		;
    da86:	0c 16       	popm.a	#1,	r12	;20-bit words
    da88:	ec 0a       	adda	r10,	r12	;
    da8a:	06 0c       	mova	@r12,	r6	;
    da8c:	96 00 00 00 	cmpa	#0,	r6	;
    da90:	0b 24       	jz	$+24     	;abs 0xdaa8

0000da92 <.Loc.88.1>:
      cb->callback(cb->args);
    da92:	0c 48       	mov	r8,	r12	;
    da94:	0d 49       	mov	r9,	r13	;
    da96:	b0 13 a0 d1 	calla	#53664		;0x0d1a0
    da9a:	0d 12       	push	r13		;
    da9c:	0c 12       	push	r12		;
    da9e:	0c 16       	popm.a	#1,	r12	;20-bit words
    daa0:	ea 0c       	adda	r12,	r10	;
    daa2:	3c 0a 04 00 	mova	4(r10),	r12	;
    daa6:	46 13       	calla	r6		;

0000daa8 <.L4>:
  OSAL_IRQ_EPILOGUE();
    daa8:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    daac:	36 13 
    daae:	b0 13 6c 46 	calla	#18028		;0x0466c

0000dab2 <.LVL14>:
    dab2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    dab4:	02 24       	jz	$+6      	;abs 0xdaba

0000dab6 <.Loc.92.1>:
    dab6:	b0 13 7c 46 	calla	#18044		;0x0467c

0000daba <.L2>:
}
    daba:	b4 16       	popm.a	#12,	r15	;20-bit words
    dabc:	00 13       	reti			

0000dabe <ISR_USCI_B0_VECTOR>:
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    dabe:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000dac0 <.LCFI13>:
  OSAL_IRQ_PROLOGUE();
    dac0:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    dac4:	36 13 

0000dac6 <.Loc.110.1>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    dac6:	40 18 1c 42 	movx.w	&0x0066e,r12	;
    daca:	6e 06 
    dacc:	8a 01 be 14 	mova	#70846,	r10	;0x114be
    dad0:	3c 92       	cmp	#8,	r12	;r2 As==11
    dad2:	62 24       	jz	$+198    	;abs 0xdb98
    dad4:	7d 42       	mov.b	#8,	r13	;r2 As==11
    dad6:	0d 9c       	cmp	r12,	r13	;
    dad8:	3e 28       	jnc	$+126    	;abs 0xdb56
    dada:	2c 93       	cmp	#2,	r12	;r3 As==10
    dadc:	55 24       	jz	$+172    	;abs 0xdb88
    dade:	2c 92       	cmp	#4,	r12	;r2 As==10
    dae0:	57 24       	jz	$+176    	;abs 0xdb90

0000dae2 <.L75>:
  if (I2CDB0.errors != I2C_NO_ERROR) {
    dae2:	41 18 82 93 	cmpx.w	#0,	&0x114c4;r3 As==00
    dae6:	c4 14 
    dae8:	2b 24       	jz	$+88     	;abs 0xdb40

0000daea <.LBB69>:
    uint16_t transferred = I2CDB0.req.size - I2CDB0.dma.registers->sz;
    daea:	17 4a 1c 00 	mov	28(r10),r7	;0x0001c
    daee:	3c 0a 34 00 	mova	52(r10),r12	;0x00034
    daf2:	19 4c 0a 00 	mov	10(r12),r9	;0x0000a

0000daf6 <.LVL69>:
    dmaCancelI(&I2CDB0.dma);
    daf6:	8c 01 f2 14 	mova	#70898,	r12	;0x114f2
    dafa:	b0 13 b8 5a 	calla	#23224		;0x05ab8

0000dafe <.LVL70>:
    if (I2CDB0.errors & I2C_TIMEOUT) {
    dafe:	40 18 fa b0 	bitx.b	#32,	6(r10)	;0x00020
    db02:	20 00 06 00 
    db06:	04 24       	jz	$+10     	;abs 0xdb10

0000db08 <.Loc.195.1>:
      I2CDB0.state = I2C_LOCKED;
    db08:	41 18 f2 40 	movx.b	#5,	&0x114be;
    db0c:	05 00 be 14 

0000db10 <.L88>:
    if (NULL != I2CDB0.callback) {
    db10:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    db14:	98 00 00 00 	cmpa	#0,	r8	;
    db18:	09 24       	jz	$+20     	;abs 0xdb2c

0000db1a <.Loc.199.1>:
      I2CDB0.callback(&I2CDB0, I2CDB0.buffer, transferred);
    db1a:	40 18 0e 47 	movx.w	r7,	r14	;
    db1e:	40 18 0e 89 	subx.w	r9,	r14	;
    db22:	3d 0a 08 00 	mova	8(r10),	r13	;
    db26:	8c 01 be 14 	mova	#70846,	r12	;0x114be
    db2a:	48 13       	calla	r8		;

0000db2c <.L89>:
    if (I2CDB0.thread != NULL) {
    db2c:	01 18 c2 93 	cmpx.a	#0,	&0x114ec;r3 As==00
    db30:	ec 14 
    db32:	06 24       	jz	$+14     	;abs 0xdb40

0000db34 <.LBB70>:
  chThdResumeI(trp, msg);
    db34:	8d 0f fe ff 	mova	#-2,	r13	;0xfffffffe
    db38:	8c 01 ec 14 	mova	#70892,	r12	;0x114ec

0000db3c <.LVL73>:
    db3c:	b0 13 fa 46 	calla	#18170		;0x046fa

0000db40 <.L87>:
  OSAL_IRQ_EPILOGUE();
    db40:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    db44:	36 13 
    db46:	b0 13 6c 46 	calla	#18028		;0x0466c

0000db4a <.LVL75>:
    db4a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    db4c:	02 24       	jz	$+6      	;abs 0xdb52

0000db4e <.Loc.211.1>:
    db4e:	b0 13 7c 46 	calla	#18044		;0x0467c

0000db52 <.L74>:
}
    db52:	b4 16       	popm.a	#12,	r15	;20-bit words
    db54:	00 13       	reti			

0000db56 <.L77>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    db56:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    db5a:	31 24       	jz	$+100    	;abs 0xdbbe
    db5c:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    db60:	4f 24       	jz	$+160    	;abs 0xdc00
    db62:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    db66:	bd 23       	jnz	$-132    	;abs 0xdae2

0000db68 <.Loc.152.1>:
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    db68:	40 18 1d 42 	movx.w	&0x0064c,r13	;
    db6c:	4c 06 
    db6e:	40 18 1c 4a 	movx.w	28(r10),r12	;0x0001c
    db72:	1c 00 
    db74:	00 18 5c 5a 	addx.a	24(r10),r12	;0x00018
    db78:	18 00 
    db7a:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000db7e <.Loc.154.1>:
      UCB0IE &= ~(UCRXIE);
    db7e:	40 18 92 c3 	bicx.w	#1,	&0x0066a;r3 As==01
    db82:	6a 06 

0000db84 <.Loc.155.1>:
      break;
    db84:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000db88 <.L78>:
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    db88:	aa d3 06 00 	bis	#2,	6(r10)	;r3 As==10

0000db8c <.Loc.116.1>:
      break;
    db8c:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000db90 <.L79>:
      I2CDB0.errors |= I2C_ACK_FAILURE;
    db90:	aa d2 06 00 	bis	#4,	6(r10)	;r2 As==10

0000db94 <.Loc.120.1>:
      break;
    db94:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000db98 <.L76>:
      I2CDB0.state = I2C_READY;
    db98:	41 18 e2 43 	movx.b	#2,	&0x114be;r3 As==10
    db9c:	be 14 

0000db9e <.Loc.128.1>:
      if (I2CDB0.thread != NULL) {
    db9e:	01 18 c2 93 	cmpx.a	#0,	&0x114ec;r3 As==00
    dba2:	ec 14 
    dba4:	06 24       	jz	$+14     	;abs 0xdbb2

0000dba6 <.LBB72>:
    dba6:	4d 43       	clr.b	r13		;
    dba8:	cc 0a       	mova	r10,	r12	;
    dbaa:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    dbae:	b0 13 fa 46 	calla	#18170		;0x046fa

0000dbb2 <.L83>:
        dmaReleaseX(&(I2CDB0.dma));
    dbb2:	8c 01 f2 14 	mova	#70898,	r12	;0x114f2
    dbb6:	b0 13 7e 5a 	calla	#23166		;0x05a7e

0000dbba <.LVL79>:
      break;
    dbba:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000dbbe <.L80>:
      UCB0IE &= ~(UCTXIE);
    dbbe:	40 18 a2 c3 	bicx.w	#2,	&0x0066a;r3 As==10
    dbc2:	6a 06 

0000dbc4 <.Loc.160.1>:
      if (I2CDB0.thread == NULL) {
    dbc4:	01 18 c2 93 	cmpx.a	#0,	&0x114ec;r3 As==00
    dbc8:	ec 14 
    dbca:	12 20       	jnz	$+38     	;abs 0xdbf0

0000dbcc <.Loc.162.1>:
        if (NULL != I2CDB0.callback) {
    dbcc:	38 0a 0c 00 	mova	12(r10),r8	;0x0000c
    dbd0:	98 00 00 00 	cmpa	#0,	r8	;
    dbd4:	08 24       	jz	$+18     	;abs 0xdbe6

0000dbd6 <.Loc.163.1>:
          I2CDB0.callback(&I2CDB0, I2CDB0.buffer, I2CDB0.req.size);
    dbd6:	1e 4a 1c 00 	mov	28(r10),r14	;0x0001c
    dbda:	3d 0a 08 00 	mova	8(r10),	r13	;
    dbde:	cc 0a       	mova	r10,	r12	;
    dbe0:	48 13       	calla	r8		;

0000dbe2 <.LVL80>:
    dbe2:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000dbe6 <.L85>:
          i2cMSP430XEndTransferI(&I2CDB0);
    dbe6:	cc 0a       	mova	r10,	r12	;
    dbe8:	b0 13 3e 61 	calla	#24894		;0x0613e

0000dbec <.LVL81>:
    dbec:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000dbf0 <.L84>:
    dbf0:	4d 43       	clr.b	r13		;
    dbf2:	cc 0a       	mova	r10,	r12	;
    dbf4:	ac 00 2e 00 	adda	#46,	r12	;0x0002e
    dbf8:	b0 13 fa 46 	calla	#18170		;0x046fa

0000dbfc <.LVL83>:
    dbfc:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000dc00 <.L81>:
      I2CDB0.errors |= I2C_TIMEOUT;
    dc00:	ba d0 20 00 	bis	#32,	6(r10)	;#0x0020
    dc04:	06 00 

0000dc06 <.Loc.185.1>:
      break;
    dc06:	80 00 e2 da 	mova	#56034,	r0	;0x0dae2

0000dc0a <ISR_TIMER0_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER0_A1_VECTOR) {
    dc0a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000dc0c <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    dc0c:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    dc10:	36 13 

0000dc12 <.Loc.95.1>:
  switch(__even_in_range(TA0IV, TA0IV_TAIFG)) {
    dc12:	40 18 1c 42 	movx.w	&0x0036e,r12	;
    dc16:	6e 03 
    dc18:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    dc1c:	1b 20       	jnz	$+56     	;abs 0xdc54

0000dc1e <.Loc.98.1>:
      if ((GPTDA0.state == GPT_ONESHOT || 
    dc1e:	8c 01 10 15 	mova	#70928,	r12	;0x11510
    dc22:	6d 4c       	mov.b	@r12,	r13	;
    dc24:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    dc28:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dc2a:	4e 9d       	cmp.b	r13,	r14	;
    dc2c:	08 28       	jnc	$+18     	;abs 0xdc3e

0000dc2e <.Loc.100.1>:
          NULL != GPTDA0.config->callback) {
    dc2e:	3e 0c 02 00 	mova	2(r12),	r14	;
    dc32:	3e 0e 04 00 	mova	4(r14),	r14	;

0000dc36 <.Loc.99.1>:
            GPTDA0.state == GPT_CONTINUOUS) &&
    dc36:	9e 00 00 00 	cmpa	#0,	r14	;
    dc3a:	01 24       	jz	$+4      	;abs 0xdc3e

0000dc3c <.Loc.101.1>:
        GPTDA0.config->callback(&GPTDA0);
    dc3c:	4e 13       	calla	r14		;

0000dc3e <.L24>:
      if (GPTDA0.state == GPT_ONESHOT) {
    dc3e:	41 18 e2 92 	cmpx.b	#4,	&0x11510;r2 As==10
    dc42:	10 15 
    dc44:	07 20       	jnz	$+16     	;abs 0xdc54

0000dc46 <.Loc.105.1>:
        GPTDA0.state = GPT_READY;
    dc46:	41 18 e2 43 	movx.b	#2,	&0x11510;r3 As==10
    dc4a:	10 15 

0000dc4c <.Loc.106.1>:
        gpt_lld_stop_timer(&GPTDA0);
    dc4c:	8c 01 10 15 	mova	#70928,	r12	;0x11510
    dc50:	b0 13 e2 62 	calla	#25314		;0x062e2

0000dc54 <.L22>:
  OSAL_IRQ_EPILOGUE();
    dc54:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    dc58:	36 13 
    dc5a:	b0 13 6c 46 	calla	#18028		;0x0466c

0000dc5e <.LVL26>:
    dc5e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    dc60:	02 24       	jz	$+6      	;abs 0xdc66

0000dc62 <.Loc.111.1>:
    dc62:	b0 13 7c 46 	calla	#18044		;0x0467c

0000dc66 <.L21>:
}
    dc66:	b4 16       	popm.a	#12,	r15	;20-bit words
    dc68:	00 13       	reti			

0000dc6a <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    dc6a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000dc6c <.LCFI3>:
  OSAL_IRQ_PROLOGUE();
    dc6c:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    dc70:	36 13 

0000dc72 <.Loc.119.1>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    dc72:	40 18 1c 42 	movx.w	&0x003ae,r12	;
    dc76:	ae 03 
    dc78:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    dc7c:	1b 20       	jnz	$+56     	;abs 0xdcb4

0000dc7e <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    dc7e:	8c 01 06 15 	mova	#70918,	r12	;0x11506
    dc82:	6d 4c       	mov.b	@r12,	r13	;
    dc84:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    dc88:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dc8a:	4e 9d       	cmp.b	r13,	r14	;
    dc8c:	08 28       	jnc	$+18     	;abs 0xdc9e

0000dc8e <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    dc8e:	3e 0c 02 00 	mova	2(r12),	r14	;
    dc92:	3e 0e 04 00 	mova	4(r14),	r14	;

0000dc96 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    dc96:	9e 00 00 00 	cmpa	#0,	r14	;
    dc9a:	01 24       	jz	$+4      	;abs 0xdc9e

0000dc9c <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    dc9c:	4e 13       	calla	r14		;

0000dc9e <.L35>:
      if (GPTDA1.state == GPT_ONESHOT) {
    dc9e:	41 18 e2 92 	cmpx.b	#4,	&0x11506;r2 As==10
    dca2:	06 15 
    dca4:	07 20       	jnz	$+16     	;abs 0xdcb4

0000dca6 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    dca6:	41 18 e2 43 	movx.b	#2,	&0x11506;r3 As==10
    dcaa:	06 15 

0000dcac <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    dcac:	8c 01 06 15 	mova	#70918,	r12	;0x11506
    dcb0:	b0 13 e2 62 	calla	#25314		;0x062e2

0000dcb4 <.L33>:
  OSAL_IRQ_EPILOGUE();
    dcb4:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    dcb8:	36 13 
    dcba:	b0 13 6c 46 	calla	#18028		;0x0466c

0000dcbe <.LVL30>:
    dcbe:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    dcc0:	02 24       	jz	$+6      	;abs 0xdcc6

0000dcc2 <.Loc.135.1>:
    dcc2:	b0 13 7c 46 	calla	#18044		;0x0467c

0000dcc6 <.L32>:
}
    dcc6:	b4 16       	popm.a	#12,	r15	;20-bit words
    dcc8:	00 13       	reti			

0000dcca <ISR_TIMER3_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER3_A1_VECTOR) {
    dcca:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000dccc <.LCFI4>:
  OSAL_IRQ_PROLOGUE();
    dccc:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    dcd0:	36 13 

0000dcd2 <.Loc.167.1>:
  switch(__even_in_range(TA3IV, TA3IV_TAIFG)) {
    dcd2:	40 18 1c 42 	movx.w	&0x0046e,r12	;
    dcd6:	6e 04 
    dcd8:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    dcdc:	1b 20       	jnz	$+56     	;abs 0xdd14

0000dcde <.Loc.170.1>:
      if ((GPTDA3.state == GPT_ONESHOT || 
    dcde:	8c 01 fc 14 	mova	#70908,	r12	;0x114fc
    dce2:	6d 4c       	mov.b	@r12,	r13	;
    dce4:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    dce8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dcea:	4e 9d       	cmp.b	r13,	r14	;
    dcec:	08 28       	jnc	$+18     	;abs 0xdcfe

0000dcee <.Loc.172.1>:
          NULL != GPTDA3.config->callback) {
    dcee:	3e 0c 02 00 	mova	2(r12),	r14	;
    dcf2:	3e 0e 04 00 	mova	4(r14),	r14	;

0000dcf6 <.Loc.171.1>:
            GPTDA3.state == GPT_CONTINUOUS) &&
    dcf6:	9e 00 00 00 	cmpa	#0,	r14	;
    dcfa:	01 24       	jz	$+4      	;abs 0xdcfe

0000dcfc <.Loc.173.1>:
        GPTDA3.config->callback(&GPTDA3);
    dcfc:	4e 13       	calla	r14		;

0000dcfe <.L46>:
      if (GPTDA3.state == GPT_ONESHOT) {
    dcfe:	41 18 e2 92 	cmpx.b	#4,	&0x114fc;r2 As==10
    dd02:	fc 14 
    dd04:	07 20       	jnz	$+16     	;abs 0xdd14

0000dd06 <.Loc.177.1>:
        GPTDA3.state = GPT_READY;
    dd06:	41 18 e2 43 	movx.b	#2,	&0x114fc;r3 As==10
    dd0a:	fc 14 

0000dd0c <.Loc.178.1>:
        gpt_lld_stop_timer(&GPTDA3);
    dd0c:	8c 01 fc 14 	mova	#70908,	r12	;0x114fc
    dd10:	b0 13 e2 62 	calla	#25314		;0x062e2

0000dd14 <.L44>:
  OSAL_IRQ_EPILOGUE();
    dd14:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    dd18:	36 13 
    dd1a:	b0 13 6c 46 	calla	#18028		;0x0466c

0000dd1e <.LVL34>:
    dd1e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    dd20:	02 24       	jz	$+6      	;abs 0xdd26

0000dd22 <.Loc.183.1>:
    dd22:	b0 13 7c 46 	calla	#18044		;0x0467c

0000dd26 <.L43>:
}
    dd26:	b4 16       	popm.a	#12,	r15	;20-bit words
    dd28:	00 13       	reti			

0000dd2a <ISR_ADC12_VECTOR>:
PORT_IRQ_HANDLER(ADC12_VECTOR) {
    dd2a:	bf 14       	pushm.a	#12,	r15	;20-bit words

0000dd2c <.LCFI4>:
  OSAL_IRQ_PROLOGUE();
    dd2c:	41 18 d2 43 	movx.b	#1,	&0x11336;r3 As==01
    dd30:	36 13 

0000dd32 <.Loc.77.1>:
  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    dd32:	40 18 1c 42 	movx.w	&0x00818,r12	;
    dd36:	18 08 
    dd38:	2c 92       	cmp	#4,	r12	;r2 As==10
    dd3a:	31 24       	jz	$+100    	;abs 0xdd9e
    dd3c:	3c 92       	cmp	#8,	r12	;r2 As==11
    dd3e:	46 24       	jz	$+142    	;abs 0xddcc
    dd40:	8a 01 1a 15 	mova	#70938,	r10	;0x1151a
    dd44:	2c 93       	cmp	#2,	r12	;r3 As==10
    dd46:	65 20       	jnz	$+204    	;abs 0xde12

0000dd48 <.Loc.80.1>:
    if (ADCD1.grpp == NULL)
    dd48:	01 18 c2 93 	cmpx.a	#0,	&0x11528;r3 As==00
    dd4c:	28 15 
    dd4e:	1c 24       	jz	$+58     	;abs 0xdd88

0000dd50 <.Loc.82.1>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    dd50:	cc 0a       	mova	r10,	r12	;
    dd52:	b0 13 50 63 	calla	#25424		;0x06350

0000dd56 <.LVL15>:
    dd56:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    dd5a:	3e 0c 06 00 	mova	6(r12),	r14	;
    dd5e:	9e 00 00 00 	cmpa	#0,	r14	;
    dd62:	0c 24       	jz	$+26     	;abs 0xdd7c

0000dd64 <.Loc.82.1>:
    dd64:	41 18 f2 40 	movx.b	#5,	&0x1151a;
    dd68:	05 00 1a 15 
    dd6c:	5d 43       	mov.b	#1,	r13	;r3 As==01

0000dd6e <.L44>:
    dd6e:	cc 0a       	mova	r10,	r12	;
    dd70:	4e 13       	calla	r14		;

0000dd72 <.LVL16>:
    dd72:	41 18 f2 90 	cmpx.b	#5,	&0x1151a;
    dd76:	05 00 1a 15 
    dd7a:	03 20       	jnz	$+8      	;abs 0xdd82

0000dd7c <.L27>:
    dd7c:	41 18 e2 43 	movx.b	#2,	&0x1151a;r3 As==10
    dd80:	1a 15 

0000dd82 <.L28>:
    dd82:	01 18 c2 43 	movx.a	#0,	&0x11528;r3 As==00
    dd86:	28 15 

0000dd88 <.L25>:
  OSAL_IRQ_EPILOGUE();
    dd88:	41 18 c2 43 	movx.b	#0,	&0x11336;r3 As==00
    dd8c:	36 13 
    dd8e:	b0 13 6c 46 	calla	#18028		;0x0466c

0000dd92 <.LVL17>:
    dd92:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    dd94:	02 24       	jz	$+6      	;abs 0xdd9a

0000dd96 <.Loc.117.1>:
    dd96:	b0 13 7c 46 	calla	#18044		;0x0467c

0000dd9a <.L20>:
}
    dd9a:	b4 16       	popm.a	#12,	r15	;20-bit words
    dd9c:	00 13       	reti			

0000dd9e <.L22>:
    if (ADCD1.grpp == NULL)
    dd9e:	8a 01 1a 15 	mova	#70938,	r10	;0x1151a
    dda2:	01 18 c2 93 	cmpx.a	#0,	&0x11528;r3 As==00
    dda6:	28 15 
    dda8:	ef 27       	jz	$-32     	;abs 0xdd88

0000ddaa <.Loc.88.1>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    ddaa:	cc 0a       	mova	r10,	r12	;
    ddac:	b0 13 50 63 	calla	#25424		;0x06350

0000ddb0 <.LVL19>:
    ddb0:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    ddb4:	3e 0c 06 00 	mova	6(r12),	r14	;
    ddb8:	9e 00 00 00 	cmpa	#0,	r14	;
    ddbc:	df 27       	jz	$-64     	;abs 0xdd7c

0000ddbe <.Loc.88.1>:
    ddbe:	41 18 f2 40 	movx.b	#5,	&0x1151a;
    ddc2:	05 00 1a 15 
    ddc6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    ddc8:	80 00 6e dd 	mova	#56686,	r0	;0x0dd6e

0000ddcc <.L23>:
      if (ADCD1.grpp == NULL) 
    ddcc:	01 18 c2 93 	cmpx.a	#0,	&0x11528;r3 As==00
    ddd0:	28 15 
    ddd2:	da 27       	jz	$-74     	;abs 0xdd88

0000ddd4 <.Loc.94.1>:
      palClearLine(LINE_LNA_PC_EN);
    ddd4:	40 18 a2 c2 	bicx.w	#4,	&0x00322;r2 As==10
    ddd8:	22 03 

0000ddda <.Loc.95.1>:
      ADC12IER2 &= ~ADC12LOIE;
    ddda:	40 18 a2 c2 	bicx.w	#4,	&0x00816;r2 As==10
    ddde:	16 08 

0000dde0 <.Loc.96.1>:
      ADC12IFGR2 &= ~ADC12LOIFG;
    dde0:	40 18 a2 c2 	bicx.w	#4,	&0x00810;r2 As==10
    dde4:	10 08 

0000dde6 <.Loc.97.1>:
      elyErrorSignalI(ErrLNAOvercurrent);
    dde6:	7c 40 85 ff 	mov.b	#-123,	r12	;#0xff85
    ddea:	b0 13 2a a7 	calla	#42794		;0x0a72a

0000ddee <.LVL20>:
      switch(LNA_OC_fault_state)
    ddee:	41 18 c2 93 	cmpx.b	#0,	&0x13961;r3 As==00
    ddf2:	61 39 
    ddf4:	c9 23       	jnz	$-108    	;abs 0xdd88

0000ddf6 <.Loc.102.1>:
              LNA_OC_faults++;
    ddf6:	41 18 d2 53 	incx.b	&0x1395f		;
    ddfa:	5f 39 

0000ddfc <.Loc.104.1>:
              chEvtSignalI(rf_thd,RFCheckFaults); //Wakeup fault routine to check for/respond to faults
    ddfc:	4d 43       	clr.b	r13		;
    ddfe:	6e 43       	mov.b	#2,	r14	;r3 As==10
    de00:	2c 01 24 21 	mova	&74020,	r12	;0x12124
    de04:	b0 13 ec 47 	calla	#18412		;0x047ec

0000de08 <.LVL21>:
              LNA_OC_fault_state =  LNA_OC_IMMEDIATE_FAULT_TEST;
    de08:	41 18 d2 43 	movx.b	#1,	&0x13961;r3 As==01
    de0c:	61 39 

0000de0e <.Loc.107.1>:
          break;
    de0e:	80 00 88 dd 	mova	#56712,	r0	;0x0dd88

0000de12 <.L42>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    de12:	cc 0a       	mova	r10,	r12	;
    de14:	b0 13 50 63 	calla	#25424		;0x06350

0000de18 <.LVL22>:
    de18:	3c 0a 0e 00 	mova	14(r10),r12	;0x0000e
    de1c:	3e 0c 06 00 	mova	6(r12),	r14	;
    de20:	9e 00 00 00 	cmpa	#0,	r14	;
    de24:	ab 27       	jz	$-168    	;abs 0xdd7c

0000de26 <.Loc.114.1>:
    de26:	41 18 f2 40 	movx.b	#5,	&0x1151a;
    de2a:	05 00 1a 15 
    de2e:	4d 43       	clr.b	r13		;
    de30:	80 00 6e dd 	mova	#56686,	r0	;0x0dd6e

0000de34 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    de34:	80 00 34 de 	mova	#56884,	r0	;0x0de34

0000de38 <Vector2>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    de38:	80 00 38 de 	mova	#56888,	r0	;0x0de38

0000de3c <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    de3c:	80 00 3c de 	mova	#56892,	r0	;0x0de3c

0000de40 <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    de40:	80 00 40 de 	mova	#56896,	r0	;0x0de40

0000de44 <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    de44:	80 00 44 de 	mova	#56900,	r0	;0x0de44

0000de48 <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    de48:	80 00 48 de 	mova	#56904,	r0	;0x0de48

0000de4c <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    de4c:	80 00 4c de 	mova	#56908,	r0	;0x0de4c

0000de50 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    de50:	80 00 50 de 	mova	#56912,	r0	;0x0de50

0000de54 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    de54:	80 00 54 de 	mova	#56916,	r0	;0x0de54

0000de58 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    de58:	80 00 58 de 	mova	#56920,	r0	;0x0de58

0000de5c <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    de5c:	80 00 5c de 	mova	#56924,	r0	;0x0de5c

0000de60 <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    de60:	80 00 60 de 	mova	#56928,	r0	;0x0de60

0000de64 <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    de64:	80 00 64 de 	mova	#56932,	r0	;0x0de64

0000de68 <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    de68:	80 00 68 de 	mova	#56936,	r0	;0x0de68

0000de6c <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    de6c:	80 00 6c de 	mova	#56940,	r0	;0x0de6c

0000de70 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    de70:	80 00 70 de 	mova	#56944,	r0	;0x0de70

0000de74 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    de74:	80 00 74 de 	mova	#56948,	r0	;0x0de74

0000de78 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    de78:	80 00 78 de 	mova	#56952,	r0	;0x0de78

0000de7c <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    de7c:	80 00 7c de 	mova	#56956,	r0	;0x0de7c

0000de80 <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    de80:	80 00 80 de 	mova	#56960,	r0	;0x0de80

0000de84 <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    de84:	80 00 84 de 	mova	#56964,	r0	;0x0de84

0000de88 <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    de88:	80 00 88 de 	mova	#56968,	r0	;0x0de88

0000de8c <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    de8c:	80 00 8c de 	mova	#56972,	r0	;0x0de8c

0000de90 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    de90:	80 00 90 de 	mova	#56976,	r0	;0x0de90

0000de94 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    de94:	80 00 94 de 	mova	#56980,	r0	;0x0de94

0000de98 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    de98:	80 00 98 de 	mova	#56984,	r0	;0x0de98

0000de9c <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    de9c:	80 00 9c de 	mova	#56988,	r0	;0x0de9c

0000dea0 <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    dea0:	80 00 a0 de 	mova	#56992,	r0	;0x0dea0

0000dea4 <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    dea4:	80 00 a4 de 	mova	#56996,	r0	;0x0dea4

0000dea8 <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    dea8:	80 00 a8 de 	mova	#57000,	r0	;0x0dea8

0000deac <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    deac:	80 00 ac de 	mova	#57004,	r0	;0x0deac

0000deb0 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    deb0:	80 00 b0 de 	mova	#57008,	r0	;0x0deb0

0000deb4 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    deb4:	80 00 b4 de 	mova	#57012,	r0	;0x0deb4

0000deb8 <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    deb8:	80 00 b8 de 	mova	#57016,	r0	;0x0deb8

0000debc <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    debc:	80 00 bc de 	mova	#57020,	r0	;0x0debc

0000dec0 <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    dec0:	80 00 c0 de 	mova	#57024,	r0	;0x0dec0

0000dec4 <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    dec4:	80 00 c4 de 	mova	#57028,	r0	;0x0dec4

0000dec8 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    dec8:	80 00 c8 de 	mova	#57032,	r0	;0x0dec8

0000decc <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    decc:	80 00 cc de 	mova	#57036,	r0	;0x0decc

0000ded0 <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    ded0:	80 00 d0 de 	mova	#57040,	r0	;0x0ded0

0000ded4 <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    ded4:	80 00 d4 de 	mova	#57044,	r0	;0x0ded4

0000ded8 <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    ded8:	80 00 d8 de 	mova	#57048,	r0	;0x0ded8
