
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	a8 8e bc 8a 	Address 0x000000000000ff92 is out of bounds.
sub	@r14,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	aa 8e 00 00 	Address 0x000000000000ff94 is out of bounds.
sub	@r14,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	ac 8e 00 00 	Address 0x000000000000ff96 is out of bounds.
sub	@r14,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	ae 8e 00 00 	Address 0x000000000000ff98 is out of bounds.
sub	@r14,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	b0 8e 00 00 	Address 0x000000000000ff9a is out of bounds.
sub	@r14+,	0xffff	; PC rel. 0xff99

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	b2 8e 00 00 	Address 0x000000000000ff9c is out of bounds.
sub	@r14+,	&0xffff	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	b4 8e 00 00 	Address 0x000000000000ff9e is out of bounds.
sub	@r14+,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	b6 8e 00 00 	Address 0x000000000000ffa0 is out of bounds.
sub	@r14+,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	b8 8e 00 00 	Address 0x000000000000ffa2 is out of bounds.
sub	@r14+,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	ba 8e 00 00 	Address 0x000000000000ffa4 is out of bounds.
sub	@r14+,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	bc 8e 00 00 	Address 0x000000000000ffa6 is out of bounds.
sub	@r14+,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	be 8e 00 00 	Address 0x000000000000ffa8 is out of bounds.
sub	@r14+,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	c0 8e 00 00 	Address 0x000000000000ffaa is out of bounds.
sub.b	r14,	0xffff	; PC rel. 0xffa9

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	c2 8e 00 00 	Address 0x000000000000ffac is out of bounds.
sub.b	r14,	&0xffff	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	c4 8e 00 00 	Address 0x000000000000ffae is out of bounds.
sub.b	r14,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	c6 8e 00 00 	Address 0x000000000000ffb0 is out of bounds.
sub.b	r14,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	c8 8e 00 00 	Address 0x000000000000ffb2 is out of bounds.
sub.b	r14,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	ca 8e 00 00 	Address 0x000000000000ffb4 is out of bounds.
sub.b	r14,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	cc 8e 00 00 	Address 0x000000000000ffb6 is out of bounds.
sub.b	r14,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	ce 8e 00 00 	Address 0x000000000000ffb8 is out of bounds.
sub.b	r14,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	d0 8e 00 00 	Address 0x000000000000ffba is out of bounds.
Address 0x000000000000ffbc is out of bounds.
sub.b	-1(r14),0xffff	; PC rel. 0xffbb
    ffbc:	00 00 

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	d2 8e 00 00 	Address 0x000000000000ffbc is out of bounds.
Address 0x000000000000ffbe is out of bounds.
sub.b	-1(r14),&0xffff	;
    ffbe:	00 00 

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	d4 8e 00 00 	Address 0x000000000000ffbe is out of bounds.
Address 0x000000000000ffc0 is out of bounds.
sub.b	-1(r14),-1(r4)	; 0xffff
    ffc0:	00 00 

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	d6 8e 00 00 	Address 0x000000000000ffc0 is out of bounds.
Address 0x000000000000ffc2 is out of bounds.
sub.b	-1(r14),-1(r6)	; 0xffff
    ffc2:	00 00 

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	d8 8e 00 00 	Address 0x000000000000ffc2 is out of bounds.
Address 0x000000000000ffc4 is out of bounds.
sub.b	-1(r14),-1(r8)	; 0xffff
    ffc4:	00 00 

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	da 8e 00 00 	Address 0x000000000000ffc4 is out of bounds.
Address 0x000000000000ffc6 is out of bounds.
sub.b	-1(r14),-1(r10)	; 0xffff
    ffc6:	00 00 

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	dc 8e 00 00 	Address 0x000000000000ffc6 is out of bounds.
Address 0x000000000000ffc8 is out of bounds.
sub.b	-1(r14),-1(r12)	; 0xffff
    ffc8:	00 00 

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	de 8e 00 00 	Address 0x000000000000ffc8 is out of bounds.
Address 0x000000000000ffca is out of bounds.
sub.b	-1(r14),-1(r14)	; 0xffff
    ffca:	00 00 

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	e0 8e 00 00 	Address 0x000000000000ffca is out of bounds.
sub.b	@r14,	0xffff	; PC rel. 0xffc9

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	e2 8e 00 00 	Address 0x000000000000ffcc is out of bounds.
sub.b	@r14,	&0xffff	;

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	e4 8e 00 00 	Address 0x000000000000ffce is out of bounds.
sub.b	@r14,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	e6 8e 00 00 	Address 0x000000000000ffd0 is out of bounds.
sub.b	@r14,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	be 73 00 00 	Address 0x000000000000ffd2 is out of bounds.
subc	#-1,	-1(r14)	;r3 As==11, 0xffff

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	5a 73       	subc.b	#1,	r10	;r3 As==01

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	e8 8e 00 00 	Address 0x000000000000ffd6 is out of bounds.
sub.b	@r14,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	ea 8e 00 00 	Address 0x000000000000ffd8 is out of bounds.
sub.b	@r14,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	f8 72 00 00 	Address 0x000000000000ffda is out of bounds.
subc.b	#8,	-1(r8)	;r2 As==11, 0xffff

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ec 8e 00 00 	Address 0x000000000000ffdc is out of bounds.
sub.b	@r14,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	ee 8e 00 00 	Address 0x000000000000ffde is out of bounds.
sub.b	@r14,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	98 72 00 00 	Address 0x000000000000ffe0 is out of bounds.
Address 0x000000000000ffe2 is out of bounds.
subc	&0xffff,-1(r8)	;0xffff, 0xffff
    ffe2:	00 00 

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	f0 8e       	interrupt service routine at 0x8ef0

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	f2 8e       	interrupt service routine at 0x8ef2

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	3c 79       	interrupt service routine at 0x793c

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	f4 8e       	interrupt service routine at 0x8ef4

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	f6 8e       	interrupt service routine at 0x8ef6

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	f8 8e       	interrupt service routine at 0x8ef8

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	52 82       	interrupt service routine at 0x8252

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	fa 8e       	interrupt service routine at 0x8efa

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	4a 71       	interrupt service routine at 0x714a

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	fc 8e       	interrupt service routine at 0x8efc

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	fe 8e       	interrupt service routine at 0x8efe

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	b2 6c       	interrupt service routine at 0x6cb2

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	00 8f       	interrupt service routine at 0x8f00

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	02 8f       	interrupt service routine at 0x8f02

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	04 8f       	interrupt service routine at 0x8f04

Disassembly of section .text:

00005ace <__crt0_start>:
    5ace:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00005ad2 <__crt0_init_bss>:
    5ad2:	3c 40 40 51 	mov	#20800,	r12	;#0x5140

00005ad6 <.Loc.74.1>:
    5ad6:	0d 43       	clr	r13		;

00005ad8 <.Loc.75.1>:
    5ad8:	3e 40 8e 09 	mov	#2446,	r14	;#0x098e

00005adc <.Loc.79.1>:
    5adc:	b0 12 c2 ad 	call	#44482		;#0xadc2

00005ae0 <__crt0_movedata>:
    5ae0:	3c 40 00 51 	mov	#20736,	r12	;#0x5100

00005ae4 <.Loc.116.1>:
    5ae4:	3d 40 00 51 	mov	#20736,	r13	;#0x5100

00005ae8 <.Loc.119.1>:
    5ae8:	0d 9c       	cmp	r12,	r13	;

00005aea <.Loc.120.1>:
    5aea:	04 24       	jz	$+10     	;abs 0x5af4

00005aec <.Loc.122.1>:
    5aec:	3e 40 40 00 	mov	#64,	r14	;#0x0040

00005af0 <.Loc.124.1>:
    5af0:	b0 12 88 ad 	call	#44424		;#0xad88

00005af4 <__crt0_call_just_main>:
    5af4:	0c 43       	clr	r12		;

00005af6 <.Loc.181.1>:
    5af6:	b0 12 5a 8f 	call	#36698		;#0x8f5a

00005afa <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    5afa:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00

00005afe <.Loc.305.1>:
}
    5afe:	03 43       	nop			
    5b00:	30 41       	ret			

00005b02 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
    5b02:	21 83       	decd	r1		;

00005b04 <.LBB2>:

  return __get_SR_register();
    5b04:	0c 42       	mov	r2,	r12	;
    5b06:	81 4c 00 00 	mov	r12,	0(r1)	;
    5b0a:	2c 41       	mov	@r1,	r12	;

00005b0c <.LBE2>:
}
    5b0c:	21 53       	incd	r1		;
    5b0e:	30 41       	ret			

00005b10 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
    5b10:	21 83       	decd	r1		;

00005b12 <.LCFI1>:
    5b12:	81 4c 00 00 	mov	r12,	0(r1)	;

00005b16 <.Loc.328.1>:

  return sts & GIE;
    5b16:	2c 41       	mov	@r1,	r12	;
    5b18:	7c f2       	and.b	#8,	r12	;r2 As==11
    5b1a:	0d 43       	clr	r13		;
    5b1c:	0d 8c       	sub	r12,	r13	;
    5b1e:	0c dd       	bis	r13,	r12	;
    5b20:	5c 03       	rrum	#1,	r12	;
    5b22:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    5b26:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00005b2a <.Loc.329.1>:
}
    5b2a:	21 53       	incd	r1		;
    5b2c:	30 41       	ret			

00005b2e <port_is_isr_context>:
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
  return __msp430x_in_isr;
    5b2e:	5c 42 70 51 	mov.b	&0x5170,r12	;0x5170

00005b32 <.Loc.340.1>:
}
    5b32:	30 41       	ret			

00005b34 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    5b34:	32 c2       	dint			

00005b36 <.Loc.348.1>:
  asm volatile("nop");
    5b36:	03 43       	nop			

00005b38 <.Loc.349.1>:
}
    5b38:	03 43       	nop			
    5b3a:	30 41       	ret			

00005b3c <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    5b3c:	03 43       	nop			

00005b3e <.Loc.356.1>:
  _enable_interrupts();
    5b3e:	32 d2       	eint			
    5b40:	03 43       	nop			

00005b42 <.Loc.357.1>:
}
    5b42:	03 43       	nop			
    5b44:	30 41       	ret			

00005b46 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    5b46:	03 43       	nop			
    5b48:	30 41       	ret			

00005b4a <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    5b4a:	03 43       	nop			
    5b4c:	30 41       	ret			

00005b4e <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    5b4e:	32 c2       	dint			

00005b50 <.Loc.381.1>:
  asm volatile("nop");
    5b50:	03 43       	nop			

00005b52 <.Loc.382.1>:
}
    5b52:	03 43       	nop			
    5b54:	30 41       	ret			

00005b56 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    5b56:	32 c2       	dint			

00005b58 <.Loc.390.1>:
  asm volatile("nop");
    5b58:	03 43       	nop			

00005b5a <.Loc.391.1>:
}
    5b5a:	03 43       	nop			
    5b5c:	30 41       	ret			

00005b5e <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5b5e:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5b62:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b64:	04 20       	jnz	$+10     	;abs 0x5b6e

00005b66 <.Loc.79.2>:
    5b66:	1c 42 48 51 	mov	&0x5148,r12	;0x5148
    5b6a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b6c:	04 24       	jz	$+10     	;abs 0x5b76

00005b6e <.L19>:
    chSysHalt("SV#2");
    5b6e:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    5b72:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005b76 <.L21>:
  }
}
    5b76:	03 43       	nop			
    5b78:	30 41       	ret			

00005b7a <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5b7a:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5b7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b80:	04 20       	jnz	$+10     	;abs 0x5b8a

00005b82 <.Loc.103.2>:
    5b82:	1c 42 48 51 	mov	&0x5148,r12	;0x5148
    5b86:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b88:	04 24       	jz	$+10     	;abs 0x5b92

00005b8a <.L27>:
    chSysHalt("SV#4");
    5b8a:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    5b8e:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005b92 <.L28>:
  }
  _dbg_enter_lock();
    5b92:	92 43 48 51 	mov	#1,	&0x5148	;r3 As==01

00005b96 <.Loc.107.2>:
}
    5b96:	03 43       	nop			
    5b98:	30 41       	ret			

00005b9a <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5b9a:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5b9e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ba0:	05 20       	jnz	$+12     	;abs 0x5bac

00005ba2 <.Loc.116.2>:
    5ba2:	1d 42 48 51 	mov	&0x5148,r13	;0x5148
    5ba6:	4c 43       	clr.b	r12		;
    5ba8:	0c 9d       	cmp	r13,	r12	;
    5baa:	04 38       	jl	$+10     	;abs 0x5bb4

00005bac <.L30>:
    chSysHalt("SV#5");
    5bac:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    5bb0:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005bb4 <.L31>:
  }
  _dbg_leave_lock();
    5bb4:	82 43 48 51 	mov	#0,	&0x5148	;r3 As==00

00005bb8 <.Loc.120.2>:
}
    5bb8:	03 43       	nop			
    5bba:	30 41       	ret			

00005bbc <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5bbc:	1d 42 46 51 	mov	&0x5146,r13	;0x5146
    5bc0:	4c 43       	clr.b	r12		;
    5bc2:	0c 9d       	cmp	r13,	r12	;
    5bc4:	04 34       	jge	$+10     	;abs 0x5bce

00005bc6 <.Loc.129.2>:
    5bc6:	1c 42 48 51 	mov	&0x5148,r12	;0x5148
    5bca:	0c 93       	cmp	#0,	r12	;r3 As==00
    5bcc:	04 24       	jz	$+10     	;abs 0x5bd6

00005bce <.L33>:
    chSysHalt("SV#6");
    5bce:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    5bd2:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005bd6 <.L34>:
  }
  _dbg_enter_lock();
    5bd6:	92 43 48 51 	mov	#1,	&0x5148	;r3 As==01

00005bda <.Loc.133.2>:
}
    5bda:	03 43       	nop			
    5bdc:	30 41       	ret			

00005bde <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5bde:	1d 42 46 51 	mov	&0x5146,r13	;0x5146
    5be2:	4c 43       	clr.b	r12		;
    5be4:	0c 9d       	cmp	r13,	r12	;
    5be6:	05 34       	jge	$+12     	;abs 0x5bf2

00005be8 <.Loc.142.2>:
    5be8:	1d 42 48 51 	mov	&0x5148,r13	;0x5148
    5bec:	4c 43       	clr.b	r12		;
    5bee:	0c 9d       	cmp	r13,	r12	;
    5bf0:	04 38       	jl	$+10     	;abs 0x5bfa

00005bf2 <.L36>:
    chSysHalt("SV#7");
    5bf2:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    5bf6:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005bfa <.L37>:
  }
  _dbg_leave_lock();
    5bfa:	82 43 48 51 	mov	#0,	&0x5148	;r3 As==00

00005bfe <.Loc.146.2>:
}
    5bfe:	03 43       	nop			
    5c00:	30 41       	ret			

00005c02 <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    5c02:	b0 12 46 5b 	call	#23366		;#0x5b46

00005c06 <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5c06:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5c0a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c0c:	04 38       	jl	$+10     	;abs 0x5c16

00005c0e <.Loc.156.2>:
    5c0e:	1c 42 48 51 	mov	&0x5148,r12	;0x5148
    5c12:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c14:	04 24       	jz	$+10     	;abs 0x5c1e

00005c16 <.L39>:
    chSysHalt("SV#8");
    5c16:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    5c1a:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005c1e <.L40>:
  }
  nil.isr_cnt++;
    5c1e:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5c22:	1c 53       	inc	r12		;
    5c24:	82 4c 46 51 	mov	r12,	&0x5146	;

00005c28 <.Loc.160.2>:
  port_unlock_from_isr();
    5c28:	b0 12 4a 5b 	call	#23370		;#0x5b4a

00005c2c <.Loc.161.2>:
}
    5c2c:	03 43       	nop			
    5c2e:	30 41       	ret			

00005c30 <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    5c30:	b0 12 46 5b 	call	#23366		;#0x5b46

00005c34 <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5c34:	1d 42 46 51 	mov	&0x5146,r13	;0x5146
    5c38:	4c 43       	clr.b	r12		;
    5c3a:	0c 9d       	cmp	r13,	r12	;
    5c3c:	04 34       	jge	$+10     	;abs 0x5c46

00005c3e <.Loc.171.2>:
    5c3e:	1c 42 48 51 	mov	&0x5148,r12	;0x5148
    5c42:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c44:	04 24       	jz	$+10     	;abs 0x5c4e

00005c46 <.L42>:
    chSysHalt("SV#9");
    5c46:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    5c4a:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005c4e <.L43>:
  }
  nil.isr_cnt--;
    5c4e:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5c52:	3c 53       	add	#-1,	r12	;r3 As==11
    5c54:	82 4c 46 51 	mov	r12,	&0x5146	;

00005c58 <.Loc.175.2>:
  port_unlock_from_isr();
    5c58:	b0 12 4a 5b 	call	#23370		;#0x5b4a

00005c5c <.Loc.176.2>:
}
    5c5c:	03 43       	nop			
    5c5e:	30 41       	ret			

00005c60 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5c60:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5c64:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c66:	05 38       	jl	$+12     	;abs 0x5c72

00005c68 <.Loc.188.2>:
    5c68:	1d 42 48 51 	mov	&0x5148,r13	;0x5148
    5c6c:	4c 43       	clr.b	r12		;
    5c6e:	0c 9d       	cmp	r13,	r12	;
    5c70:	04 38       	jl	$+10     	;abs 0x5c7a

00005c72 <.L45>:
    chSysHalt("SV#10");
    5c72:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    5c76:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005c7a <.L47>:
  }
}
    5c7a:	03 43       	nop			
    5c7c:	30 41       	ret			

00005c7e <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5c7e:	1c 42 46 51 	mov	&0x5146,r12	;0x5146
    5c82:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c84:	05 20       	jnz	$+12     	;abs 0x5c90

00005c86 <.Loc.203.2>:
    5c86:	1d 42 48 51 	mov	&0x5148,r13	;0x5148
    5c8a:	4c 43       	clr.b	r12		;
    5c8c:	0c 9d       	cmp	r13,	r12	;
    5c8e:	04 38       	jl	$+10     	;abs 0x5c98

00005c90 <.L49>:
    chSysHalt("SV#11");
    5c90:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    5c94:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00005c98 <.L51>:
  }
}
    5c98:	03 43       	nop			
    5c9a:	30 41       	ret			

00005c9c <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    5c9c:	21 82       	sub	#4,	r1	;r2 As==10

00005c9e <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    5c9e:	82 43 46 51 	mov	#0,	&0x5146	;r3 As==00

00005ca2 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    5ca2:	82 43 48 51 	mov	#0,	&0x5148	;r3 As==00

00005ca6 <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    5ca6:	b1 40 4c 51 	mov	#20812,	2(r1)	;#0x514c
    5caa:	02 00 

00005cac <.Loc.234.2>:
  tcp = nil_thd_configs;
    5cac:	b1 40 8c 50 	mov	#20620,	0(r1)	;#0x508c
    5cb0:	00 00 

00005cb2 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5cb2:	2d 3c       	jmp	$+92     	;abs 0x5d0e

00005cb4 <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    5cb4:	2c 41       	mov	@r1,	r12	;
    5cb6:	2d 4c       	mov	@r12,	r13	;
    5cb8:	1c 41 02 00 	mov	2(r1),	r12	;
    5cbc:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00005cc0 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    5cc0:	2c 41       	mov	@r1,	r12	;
    5cc2:	1c 4c 02 00 	mov	2(r12),	r12	;
    5cc6:	0d 4c       	mov	r12,	r13	;
    5cc8:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    5ccc:	1c 41 02 00 	mov	2(r1),	r12	;
    5cd0:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5cd4:	1c 41 02 00 	mov	2(r1),	r12	;
    5cd8:	2c 4c       	mov	@r12,	r12	;
    5cda:	2d 41       	mov	@r1,	r13	;
    5cdc:	1d 4d 06 00 	mov	6(r13),	r13	;
    5ce0:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5ce4:	1c 41 02 00 	mov	2(r1),	r12	;
    5ce8:	2c 4c       	mov	@r12,	r12	;
    5cea:	2d 41       	mov	@r1,	r13	;
    5cec:	1d 4d 08 00 	mov	8(r13),	r13	;
    5cf0:	8c 4d 02 00 	mov	r13,	2(r12)	;
    5cf4:	1c 41 02 00 	mov	2(r1),	r12	;
    5cf8:	2c 4c       	mov	@r12,	r12	;
    5cfa:	3d 40 04 61 	mov	#24836,	r13	;#0x6104
    5cfe:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00005d02 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    5d02:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    5d06:	02 00 

00005d08 <.Loc.247.2>:
    tcp++;
    5d08:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    5d0c:	00 00 

00005d0e <.L53>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5d0e:	b1 90 58 51 	cmp	#20824,	2(r1)	;#0x5158
    5d12:	02 00 
    5d14:	cf 2b       	jnc	$-96     	;abs 0x5cb4

00005d16 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    5d16:	1c 41 02 00 	mov	2(r1),	r12	;
    5d1a:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    5d1e:	0a 00 

00005d20 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    5d20:	b0 12 56 5b 	call	#23382		;#0x5b56
    5d24:	b0 12 5e 5b 	call	#23390		;#0x5b5e

00005d28 <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    5d28:	92 43 48 51 	mov	#1,	&0x5148	;r3 As==01

00005d2c <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    5d2c:	b0 12 d6 60 	call	#24790		;#0x60d6

00005d30 <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    5d30:	b0 12 fa 5a 	call	#23290		;#0x5afa

00005d34 <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    5d34:	b2 40 4c 51 	mov	#20812,	&0x5142	;#0x514c
    5d38:	42 51 
    5d3a:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5d3e:	82 4c 40 51 	mov	r12,	&0x5140	;

00005d42 <.Loc.275.2>:
  port_switch(nil.current, tp);
    5d42:	1c 42 40 51 	mov	&0x5140,r12	;0x5140
    5d46:	1d 41 02 00 	mov	2(r1),	r13	;
    5d4a:	b0 12 f6 60 	call	#24822		;#0x60f6

00005d4e <.Loc.276.2>:
  chSysUnlock();
    5d4e:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    5d52:	b0 12 3c 5b 	call	#23356		;#0x5b3c

00005d56 <.Loc.277.2>:
}
    5d56:	03 43       	nop			
    5d58:	21 52       	add	#4,	r1	;r2 As==10
    5d5a:	30 41       	ret			

00005d5c <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    5d5c:	21 83       	decd	r1		;

00005d5e <L0>:
    5d5e:	81 4c 00 00 	mov	r12,	0(r1)	;

00005d62 <.Loc.293.2>:

  port_disable();
    5d62:	b0 12 4e 5b 	call	#23374		;#0x5b4e

00005d66 <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    5d66:	a2 41 4a 51 	mov	@r1,	&0x514a	;

00005d6a <.L56>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    5d6a:	ff 3f       	jmp	$+0      	;abs 0x5d6a

00005d6c <chSysTimerHandlerI>:
    5d6c:	21 83       	decd	r1		;

00005d6e <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    5d6e:	b0 12 60 5c 	call	#23648		;#0x5c60

00005d72 <.Loc.320.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    5d72:	b1 40 4c 51 	mov	#20812,	0(r1)	;#0x514c
    5d76:	00 00 

00005d78 <.Loc.321.2>:
  nil.systime++;
    5d78:	1c 42 44 51 	mov	&0x5144,r12	;0x5144
    5d7c:	1c 53       	inc	r12		;
    5d7e:	82 4c 44 51 	mov	r12,	&0x5144	;

00005d82 <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    5d82:	2c 41       	mov	@r1,	r12	;
    5d84:	1c 4c 06 00 	mov	6(r12),	r12	;
    5d88:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d8a:	25 24       	jz	$+76     	;abs 0x5dd6

00005d8c <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    5d8c:	2c 41       	mov	@r1,	r12	;
    5d8e:	1c 4c 06 00 	mov	6(r12),	r12	;
    5d92:	3c 53       	add	#-1,	r12	;r3 As==11
    5d94:	2d 41       	mov	@r1,	r13	;
    5d96:	8d 4c 06 00 	mov	r12,	6(r13)	;
    5d9a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d9c:	1c 20       	jnz	$+58     	;abs 0x5dd6

00005d9e <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    5d9e:	2c 41       	mov	@r1,	r12	;
    5da0:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5da4:	7c 90 03 00 	cmp.b	#3,	r12	;
    5da8:	08 20       	jnz	$+18     	;abs 0x5dba

00005daa <.Loc.334.2>:
          tp->u1.semp->cnt++;
    5daa:	2c 41       	mov	@r1,	r12	;
    5dac:	1c 4c 04 00 	mov	4(r12),	r12	;
    5db0:	2d 4c       	mov	@r12,	r13	;
    5db2:	1d 53       	inc	r13		;
    5db4:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5db8:	0a 3c       	jmp	$+22     	;abs 0x5dce

00005dba <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    5dba:	2c 41       	mov	@r1,	r12	;
    5dbc:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5dc0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    5dc2:	05 20       	jnz	$+12     	;abs 0x5dce

00005dc4 <.Loc.337.2>:
          *tp->u1.trp = NULL;
    5dc4:	2c 41       	mov	@r1,	r12	;
    5dc6:	1c 4c 04 00 	mov	4(r12),	r12	;
    5dca:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005dce <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    5dce:	3d 43       	mov	#-1,	r13	;r3 As==11
    5dd0:	2c 41       	mov	@r1,	r12	;
    5dd2:	b0 12 72 5e 	call	#24178		;#0x5e72

00005dd6 <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    5dd6:	b0 12 de 5b 	call	#23518		;#0x5bde
    5dda:	b0 12 4a 5b 	call	#23370		;#0x5b4a

00005dde <.Loc.346.2>:
    tp++;
    5dde:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    5de2:	00 00 

00005de4 <.Loc.347.2>:
    chSysLockFromISR();
    5de4:	b0 12 46 5b 	call	#23366		;#0x5b46
    5de8:	b0 12 bc 5b 	call	#23484		;#0x5bbc

00005dec <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    5dec:	b1 90 58 51 	cmp	#20824,	0(r1)	;#0x5158
    5df0:	00 00 
    5df2:	c7 2b       	jnc	$-112    	;abs 0x5d82

00005df4 <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    5df4:	03 43       	nop			
    5df6:	21 53       	incd	r1		;
    5df8:	30 41       	ret			

00005dfa <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    5dfa:	21 83       	decd	r1		;

00005dfc <L0>:

  syssts_t sts = port_get_irq_status();
    5dfc:	b0 12 02 5b 	call	#23298		;#0x5b02
    5e00:	81 4c 00 00 	mov	r12,	0(r1)	;

00005e04 <.Loc.448.2>:
  if (port_irq_enabled(sts)) {
    5e04:	2c 41       	mov	@r1,	r12	;
    5e06:	b0 12 10 5b 	call	#23312		;#0x5b10
    5e0a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e0e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e10:	0f 24       	jz	$+32     	;abs 0x5e30

00005e12 <.Loc.449.2>:
    if (port_is_isr_context()) {
    5e12:	b0 12 2e 5b 	call	#23342		;#0x5b2e
    5e16:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e1c:	05 24       	jz	$+12     	;abs 0x5e28

00005e1e <.Loc.450.2>:
      chSysLockFromISR();
    5e1e:	b0 12 46 5b 	call	#23366		;#0x5b46
    5e22:	b0 12 bc 5b 	call	#23484		;#0x5bbc
    5e26:	04 3c       	jmp	$+10     	;abs 0x5e30

00005e28 <.L70>:
    }
    else {
      chSysLock();
    5e28:	b0 12 34 5b 	call	#23348		;#0x5b34
    5e2c:	b0 12 7a 5b 	call	#23418		;#0x5b7a

00005e30 <.L69>:
    }
  }
  return sts;
    5e30:	2c 41       	mov	@r1,	r12	;

00005e32 <.Loc.457.2>:
}
    5e32:	21 53       	incd	r1		;
    5e34:	30 41       	ret			

00005e36 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
    5e36:	21 83       	decd	r1		;

00005e38 <L0>:
    5e38:	81 4c 00 00 	mov	r12,	0(r1)	;

00005e3c <.Loc.470.2>:

  if (port_irq_enabled(sts)) {
    5e3c:	2c 41       	mov	@r1,	r12	;
    5e3e:	b0 12 10 5b 	call	#23312		;#0x5b10
    5e42:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e46:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e48:	11 24       	jz	$+36     	;abs 0x5e6c

00005e4a <.Loc.471.2>:
    if (port_is_isr_context()) {
    5e4a:	b0 12 2e 5b 	call	#23342		;#0x5b2e
    5e4e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e52:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e54:	05 24       	jz	$+12     	;abs 0x5e60

00005e56 <.Loc.472.2>:
      chSysUnlockFromISR();
    5e56:	b0 12 de 5b 	call	#23518		;#0x5bde
    5e5a:	b0 12 4a 5b 	call	#23370		;#0x5b4a

00005e5e <.Loc.479.2>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    5e5e:	06 3c       	jmp	$+14     	;abs 0x5e6c

00005e60 <.L74>:
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    5e60:	b0 12 ec 5e 	call	#24300		;#0x5eec

00005e64 <.Loc.476.2>:
      chSysUnlock();
    5e64:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    5e68:	b0 12 3c 5b 	call	#23356		;#0x5b3c

00005e6c <.L75>:
    }
  }
}
    5e6c:	03 43       	nop			
    5e6e:	21 53       	incd	r1		;
    5e70:	30 41       	ret			

00005e72 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    5e72:	21 82       	sub	#4,	r1	;r2 As==10

00005e74 <L0>:
    5e74:	81 4c 02 00 	mov	r12,	2(r1)	;
    5e78:	81 4d 00 00 	mov	r13,	0(r1)	;

00005e7c <.Loc.535.2>:

  chDbgCheckClassI();
    5e7c:	b0 12 60 5c 	call	#23648		;#0x5c60

00005e80 <.Loc.540.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    5e80:	1c 41 02 00 	mov	2(r1),	r12	;
    5e84:	ac 41 04 00 	mov	@r1,	4(r12)	;

00005e88 <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    5e88:	1c 41 02 00 	mov	2(r1),	r12	;
    5e8c:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00005e90 <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    5e90:	1c 41 02 00 	mov	2(r1),	r12	;
    5e94:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00005e98 <.Loc.543.2>:
  if (tp < nil.next) {
    5e98:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5e9c:	81 9c 02 00 	cmp	r12,	2(r1)	;
    5ea0:	03 2c       	jc	$+8      	;abs 0x5ea8

00005ea2 <.Loc.544.2>:
    nil.next = tp;
    5ea2:	92 41 02 00 	mov	2(r1),	&0x5142	;
    5ea6:	42 51 

00005ea8 <.L77>:
  }
  return tp;
    5ea8:	1c 41 02 00 	mov	2(r1),	r12	;

00005eac <.Loc.547.2>:
}
    5eac:	21 52       	add	#4,	r1	;r2 As==10
    5eae:	30 41       	ret			

00005eb0 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    5eb0:	1d 42 40 51 	mov	&0x5140,r13	;0x5140
    5eb4:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5eb8:	0c ed       	xor	r13,	r12	;
    5eba:	0d 43       	clr	r13		;
    5ebc:	0d 8c       	sub	r12,	r13	;
    5ebe:	0c dd       	bis	r13,	r12	;
    5ec0:	5c 03       	rrum	#1,	r12	;
    5ec2:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    5ec6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00005eca <.Loc.565.2>:
}
    5eca:	30 41       	ret			

00005ecc <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    5ecc:	21 83       	decd	r1		;

00005ece <.LCFI8>:
  thread_t *otp = nil.current;
    5ece:	91 42 40 51 	mov	&0x5140,0(r1)	;0x5140
    5ed2:	00 00 

00005ed4 <.Loc.577.2>:

  nil.current = nil.next;
    5ed4:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5ed8:	82 4c 40 51 	mov	r12,	&0x5140	;

00005edc <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    5edc:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5ee0:	2d 41       	mov	@r1,	r13	;
    5ee2:	b0 12 f6 60 	call	#24822		;#0x60f6

00005ee6 <.Loc.582.2>:
}
    5ee6:	03 43       	nop			
    5ee8:	21 53       	incd	r1		;
    5eea:	30 41       	ret			

00005eec <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    5eec:	b0 12 7e 5c 	call	#23678		;#0x5c7e

00005ef0 <.Loc.593.2>:

  if (chSchIsRescRequiredI()) {
    5ef0:	1d 42 40 51 	mov	&0x5140,r13	;0x5140
    5ef4:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5ef8:	0d 9c       	cmp	r12,	r13	;
    5efa:	02 24       	jz	$+6      	;abs 0x5f00

00005efc <.Loc.594.2>:
    chSchDoReschedule();
    5efc:	b0 12 cc 5e 	call	#24268		;#0x5ecc

00005f00 <.L84>:
  }
}
    5f00:	03 43       	nop			
    5f02:	30 41       	ret			

00005f04 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    5f04:	31 82       	sub	#8,	r1	;r2 As==11

00005f06 <.LCFI9>:
    5f06:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    5f0a:	81 4d 00 00 	mov	r13,	0(r1)	;

00005f0e <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    5f0e:	91 42 40 51 	mov	&0x5140,4(r1)	;0x5140
    5f12:	04 00 

00005f14 <.Loc.618.2>:

  chDbgCheckClassS();
    5f14:	b0 12 7e 5c 	call	#23678		;#0x5c7e

00005f18 <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    5f18:	1c 41 04 00 	mov	4(r1),	r12	;
    5f1c:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    5f20:	02 00 

00005f22 <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    5f22:	1c 41 04 00 	mov	4(r1),	r12	;
    5f26:	ac 41 06 00 	mov	@r1,	6(r12)	;

00005f2a <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    5f2a:	b1 40 4c 51 	mov	#20812,	6(r1)	;#0x514c
    5f2e:	06 00 

00005f30 <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    5f30:	1c 41 06 00 	mov	6(r1),	r12	;
    5f34:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5f38:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f3a:	12 20       	jnz	$+38     	;abs 0x5f60

00005f3c <.Loc.667.2>:
      nil.current = nil.next = ntp;
    5f3c:	92 41 06 00 	mov	6(r1),	&0x5142	;
    5f40:	42 51 
    5f42:	1c 42 42 51 	mov	&0x5142,r12	;0x5142
    5f46:	82 4c 40 51 	mov	r12,	&0x5140	;

00005f4a <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    5f4a:	1d 41 04 00 	mov	4(r1),	r13	;
    5f4e:	1c 41 06 00 	mov	6(r1),	r12	;
    5f52:	b0 12 f6 60 	call	#24822		;#0x60f6

00005f56 <.Loc.672.2>:
      return nil.current->u1.msg;
    5f56:	1c 42 40 51 	mov	&0x5140,r12	;0x5140
    5f5a:	1c 4c 04 00 	mov	4(r12),	r12	;
    5f5e:	04 3c       	jmp	$+10     	;abs 0x5f68

00005f60 <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    5f60:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    5f64:	06 00 

00005f66 <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    5f66:	e4 3f       	jmp	$-54     	;abs 0x5f30

00005f68 <.L89>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    5f68:	31 52       	add	#8,	r1	;r2 As==11
    5f6a:	30 41       	ret			

00005f6c <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    5f6c:	31 80 06 00 	sub	#6,	r1	;

00005f70 <L0>:
    5f70:	81 4c 02 00 	mov	r12,	2(r1)	;
    5f74:	81 4d 00 00 	mov	r13,	0(r1)	;

00005f78 <.Loc.717.2>:

  if (*trp != NULL) {
    5f78:	1c 41 02 00 	mov	2(r1),	r12	;
    5f7c:	2c 4c       	mov	@r12,	r12	;
    5f7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f80:	0d 24       	jz	$+28     	;abs 0x5f9c

00005f82 <.LBB3>:
    thread_reference_t tr = *trp;
    5f82:	1c 41 02 00 	mov	2(r1),	r12	;
    5f86:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00005f8a <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    5f8a:	1c 41 02 00 	mov	2(r1),	r12	;
    5f8e:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005f92 <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    5f92:	2d 41       	mov	@r1,	r13	;
    5f94:	1c 41 04 00 	mov	4(r1),	r12	;
    5f98:	b0 12 72 5e 	call	#24178		;#0x5e72

00005f9c <.L94>:
  }
}
    5f9c:	03 43       	nop			
    5f9e:	31 50 06 00 	add	#6,	r1	;
    5fa2:	30 41       	ret			

00005fa4 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    5fa4:	21 83       	decd	r1		;

00005fa6 <.LCFI12>:
    5fa6:	81 4c 00 00 	mov	r12,	0(r1)	;

00005faa <.Loc.736.2>:

  chSysLock();
    5faa:	b0 12 34 5b 	call	#23348		;#0x5b34
    5fae:	b0 12 7a 5b 	call	#23418		;#0x5b7a

00005fb2 <.Loc.737.2>:
  chThdSleepS(timeout);
    5fb2:	2d 41       	mov	@r1,	r13	;
    5fb4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5fb6:	b0 12 04 5f 	call	#24324		;#0x5f04

00005fba <.Loc.738.2>:
  chSysUnlock();
    5fba:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    5fbe:	b0 12 3c 5b 	call	#23356		;#0x5b3c

00005fc2 <.Loc.739.2>:
}
    5fc2:	03 43       	nop			
    5fc4:	21 53       	incd	r1		;
    5fc6:	30 41       	ret			

00005fc8 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    5fc8:	31 80 06 00 	sub	#6,	r1	;

00005fcc <.LCFI15>:
    5fcc:	81 4c 02 00 	mov	r12,	2(r1)	;
    5fd0:	81 4d 00 00 	mov	r13,	0(r1)	;

00005fd4 <.Loc.807.2>:

  chDbgCheckClassS();
    5fd4:	b0 12 7e 5c 	call	#23678		;#0x5c7e

00005fd8 <.Loc.812.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    5fd8:	1c 41 02 00 	mov	2(r1),	r12	;
    5fdc:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00005fe0 <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    5fe0:	4c 43       	clr.b	r12		;
    5fe2:	1c 91 04 00 	cmp	4(r1),	r12	;
    5fe6:	17 38       	jl	$+48     	;abs 0x6016

00005fe8 <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    5fe8:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    5fec:	02 20       	jnz	$+6      	;abs 0x5ff2

00005fee <.Loc.815.2>:
      return MSG_TIMEOUT;
    5fee:	3c 43       	mov	#-1,	r12	;r3 As==11
    5ff0:	1a 3c       	jmp	$+54     	;abs 0x6026

00005ff2 <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    5ff2:	1d 41 04 00 	mov	4(r1),	r13	;
    5ff6:	3d 53       	add	#-1,	r13	;r3 As==11
    5ff8:	1c 41 02 00 	mov	2(r1),	r12	;
    5ffc:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006000 <.Loc.818.2>:
    nil.current->u1.semp = sp;
    6000:	1c 42 40 51 	mov	&0x5140,r12	;0x5140
    6004:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6008:	04 00 

0000600a <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    600a:	2d 41       	mov	@r1,	r13	;
    600c:	7c 40 03 00 	mov.b	#3,	r12	;
    6010:	b0 12 04 5f 	call	#24324		;#0x5f04
    6014:	08 3c       	jmp	$+18     	;abs 0x6026

00006016 <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    6016:	1d 41 04 00 	mov	4(r1),	r13	;
    601a:	3d 53       	add	#-1,	r13	;r3 As==11
    601c:	1c 41 02 00 	mov	2(r1),	r12	;
    6020:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006024 <.Loc.822.2>:
  return MSG_OK;
    6024:	4c 43       	clr.b	r12		;

00006026 <.L102>:
}
    6026:	31 50 06 00 	add	#6,	r1	;
    602a:	30 41       	ret			

0000602c <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    602c:	32 c2       	dint			

0000602e <.Loc.348.1>:
  asm volatile("nop");
    602e:	03 43       	nop			

00006030 <L0>:
}
    6030:	03 43       	nop			
    6032:	30 41       	ret			

00006034 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6034:	03 43       	nop			

00006036 <.Loc.356.1>:
  _enable_interrupts();
    6036:	32 d2       	eint			
    6038:	03 43       	nop			

0000603a <.Loc.357.1>:
}
    603a:	03 43       	nop			
    603c:	30 41       	ret			

0000603e <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    603e:	31 80 06 00 	sub	#6,	r1	;

00006042 <.LCFI0>:
    6042:	81 4c 02 00 	mov	r12,	2(r1)	;
    6046:	81 4d 00 00 	mov	r13,	0(r1)	;

0000604a <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    604a:	b0 12 60 5c 	call	#23648		;#0x5c60

0000604e <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    604e:	2c 41       	mov	@r1,	r12	;
    6050:	1c 51 02 00 	add	2(r1),	r12	;
    6054:	0d 4c       	mov	r12,	r13	;
    6056:	3d 53       	add	#-1,	r13	;r3 As==11
    6058:	4c 43       	clr.b	r12		;
    605a:	2c 81       	sub	@r1,	r12	;
    605c:	0e 4d       	mov	r13,	r14	;
    605e:	0e fc       	and	r12,	r14	;
    6060:	81 4e 02 00 	mov	r14,	2(r1)	;

00006064 <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    6064:	1c 42 64 51 	mov	&0x5164,r12	;0x5164
    6068:	2c 51       	add	@r1,	r12	;
    606a:	0d 4c       	mov	r12,	r13	;
    606c:	3d 53       	add	#-1,	r13	;r3 As==11
    606e:	4c 43       	clr.b	r12		;
    6070:	2c 81       	sub	@r1,	r12	;
    6072:	0c fd       	and	r13,	r12	;
    6074:	81 4c 04 00 	mov	r12,	4(r1)	;

00006078 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    6078:	1c 42 66 51 	mov	&0x5166,r12	;0x5166
    607c:	1d 41 04 00 	mov	4(r1),	r13	;
    6080:	0c 8d       	sub	r13,	r12	;
    6082:	1c 91 02 00 	cmp	2(r1),	r12	;
    6086:	02 2c       	jc	$+6      	;abs 0x608c

00006088 <.Loc.118.2>:
    return NULL;
    6088:	4c 43       	clr.b	r12		;
    608a:	08 3c       	jmp	$+18     	;abs 0x609c

0000608c <.L5>:
  }
  nextmem = p + size;
    608c:	1c 41 04 00 	mov	4(r1),	r12	;
    6090:	1c 51 02 00 	add	2(r1),	r12	;
    6094:	82 4c 64 51 	mov	r12,	&0x5164	;

00006098 <.Loc.122.2>:

  return p;
    6098:	1c 41 04 00 	mov	4(r1),	r12	;

0000609c <.L6>:
}
    609c:	31 50 06 00 	add	#6,	r1	;
    60a0:	30 41       	ret			

000060a2 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    60a2:	31 80 06 00 	Address 0x00000000000060a4 is out of bounds.
sub	#65535,	r1	;#0xffff

000060a4 <L0>:
    60a4:	06 00       	mova	@r0,	r6	;

000060a6 <.LCFI1>:
    60a6:	81 4c 02 00 	mov	r12,	2(r1)	;
    60aa:	81 4d 00 00 	mov	r13,	0(r1)	;

000060ae <.Loc.140.2>:
  void *p;

  chSysLock();
    60ae:	b0 12 2c 60 	call	#24620		;#0x602c
    60b2:	b0 12 7a 5b 	call	#23418		;#0x5b7a

000060b6 <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    60b6:	2d 41       	mov	@r1,	r13	;
    60b8:	1c 41 02 00 	mov	2(r1),	r12	;
    60bc:	b0 12 3e 60 	call	#24638		;#0x603e
    60c0:	81 4c 04 00 	mov	r12,	4(r1)	;

000060c4 <.Loc.142.2>:
  chSysUnlock();
    60c4:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    60c8:	b0 12 34 60 	call	#24628		;#0x6034

000060cc <.Loc.144.2>:

  return p;
    60cc:	1c 41 04 00 	mov	4(r1),	r12	;

000060d0 <.Loc.145.2>:
}
    60d0:	31 50 06 00 	add	#6,	r1	;
    60d4:	30 41       	ret			

000060d6 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    60d6:	b2 40 a2 60 	mov	#24738,	&0x5168	;#0x60a2
    60da:	68 51 

000060dc <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    60dc:	82 43 6a 51 	mov	#0,	&0x516a	;r3 As==00

000060e0 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    60e0:	82 43 6c 51 	mov	#0,	&0x516c	;r3 As==00

000060e4 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    60e4:	92 43 6e 51 	mov	#1,	&0x516e	;r3 As==01

000060e8 <.Loc.117.1>:
#endif
}
    60e8:	03 43       	nop			
    60ea:	30 41       	ret			

000060ec <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    60ec:	03 43       	nop			

000060ee <.Loc.356.1>:
  _enable_interrupts();
    60ee:	32 d2       	eint			
    60f0:	03 43       	nop			

000060f2 <.Loc.357.1>:
}
    60f2:	03 43       	nop			
    60f4:	30 41       	ret			

000060f6 <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    60f6:	6a 15       	pushm	#7,	r10	;16-bit words

000060f8 <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    60f8:	8d 41 00 00 	mov	r1,	0(r13)	;

000060fc <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    60fc:	21 4c       	mov	@r12,	r1	;

000060fe <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    60fe:	64 17       	popm	#7,	r10	;16-bit words

00006100 <.Loc.83.2>:
  asm volatile ("ret");
    6100:	30 41       	ret			

00006102 <.Loc.85.2>:
#endif
}
    6102:	03 43       	nop			

00006104 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    6104:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    6108:	b0 12 ec 60 	call	#24812		;#0x60ec

0000610c <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    610c:	0c 45       	mov	r5,	r12	;

0000610e <.Loc.101.2>:
  asm volatile ("call R4");
    610e:	84 12       	call	r4		;

00006110 <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    6110:	4c 43       	clr.b	r12		;
    6112:	b0 12 5c 5d 	call	#23900		;#0x5d5c

00006116 <.Loc.109.2>:
#endif
}
    6116:	03 43       	nop			
    6118:	30 41       	ret			

0000611a <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    611a:	31 82       	sub	#8,	r1	;r2 As==11

0000611c <.LCFI0>:
    611c:	81 4c 02 00 	mov	r12,	2(r1)	;
    6120:	81 4d 00 00 	mov	r13,	0(r1)	;

00006124 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    6124:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6128:	04 00 

0000612a <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    612a:	1c 41 02 00 	mov	2(r1),	r12	;
    612e:	2c 4c       	mov	@r12,	r12	;
    6130:	0c 93       	cmp	#0,	r12	;r3 As==00
    6132:	1d 34       	jge	$+60     	;abs 0x616e

00006134 <.LBB2>:
    thread_t *tp = nil.threads;
    6134:	b1 40 4c 51 	mov	#20812,	6(r1)	;#0x514c
    6138:	06 00 

0000613a <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    613a:	1c 41 06 00 	mov	6(r1),	r12	;
    613e:	1c 4c 04 00 	mov	4(r12),	r12	;
    6142:	1c 91 04 00 	cmp	4(r1),	r12	;
    6146:	0f 20       	jnz	$+32     	;abs 0x6166

00006148 <.Loc.67.1>:
        sp->cnt++;
    6148:	1c 41 04 00 	mov	4(r1),	r12	;
    614c:	2c 4c       	mov	@r12,	r12	;
    614e:	1c 53       	inc	r12		;
    6150:	0d 4c       	mov	r12,	r13	;
    6152:	1c 41 04 00 	mov	4(r1),	r12	;
    6156:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000615a <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    615a:	2d 41       	mov	@r1,	r13	;
    615c:	1c 41 06 00 	mov	6(r1),	r12	;
    6160:	b0 12 72 5e 	call	#24178		;#0x5e72

00006164 <.Loc.72.1>:
        return;
    6164:	04 3c       	jmp	$+10     	;abs 0x616e

00006166 <.L3>:
      }
      tp++;
    6166:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    616a:	06 00 

0000616c <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    616c:	e6 3f       	jmp	$-50     	;abs 0x613a

0000616e <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    616e:	31 52       	add	#8,	r1	;r2 As==11
    6170:	30 41       	ret			

00006172 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
    6172:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00006176 <L0>:
    6176:	81 4c 02 00 	mov	r12,	2(r1)	;
    617a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000617e <.Loc.91.1>:
  semaphore_t *sp = &tqp->sem;
    617e:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6182:	04 00 

00006184 <.Loc.95.1>:
  thread_t *tp;
  cnt_t cnt;

  cnt = sp->cnt;
    6184:	1c 41 04 00 	mov	4(r1),	r12	;
    6188:	a1 4c 06 00 	mov	@r12,	6(r1)	;

0000618c <.Loc.96.1>:
  sp->cnt = (cnt_t)0;
    618c:	1c 41 04 00 	mov	4(r1),	r12	;
    6190:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006194 <.Loc.97.1>:
  tp = nil.threads;
    6194:	b1 40 4c 51 	mov	#20812,	8(r1)	;#0x514c
    6198:	08 00 

0000619a <.Loc.98.1>:
  while (cnt < (cnt_t)0) {
    619a:	14 3c       	jmp	$+42     	;abs 0x61c4

0000619c <.L8>:

    chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");

    /* Is this thread waiting on this semaphore?*/
    if (tp->u1.semp == sp) {
    619c:	1c 41 08 00 	mov	8(r1),	r12	;
    61a0:	1c 4c 04 00 	mov	4(r12),	r12	;
    61a4:	1c 91 04 00 	cmp	4(r1),	r12	;
    61a8:	0a 20       	jnz	$+22     	;abs 0x61be

000061aa <.Loc.108.1>:

      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
    61aa:	1c 41 06 00 	mov	6(r1),	r12	;
    61ae:	1c 53       	inc	r12		;
    61b0:	81 4c 06 00 	mov	r12,	6(r1)	;

000061b4 <.Loc.109.1>:
      (void) chSchReadyI(tp, msg);
    61b4:	2d 41       	mov	@r1,	r13	;
    61b6:	1c 41 08 00 	mov	8(r1),	r12	;
    61ba:	b0 12 72 5e 	call	#24178		;#0x5e72

000061be <.L7>:
    }
    tp++;
    61be:	b1 50 0c 00 	add	#12,	8(r1)	;#0x000c
    61c2:	08 00 

000061c4 <.L6>:
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = (cnt_t)0;
  tp = nil.threads;
  while (cnt < (cnt_t)0) {
    61c4:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    61c8:	e9 3b       	jl	$-44     	;abs 0x619c

000061ca <.Loc.113.1>:
      cnt++;
      (void) chSchReadyI(tp, msg);
    }
    tp++;
  }
}
    61ca:	03 43       	nop			
    61cc:	31 50 0a 00 	add	#10,	r1	;#0x000a
    61d0:	30 41       	ret			

000061d2 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    61d2:	03 43       	nop			

000061d4 <L0>:
    61d4:	30 41       	ret			

000061d6 <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    61d6:	b0 12 d2 61 	call	#25042		;#0x61d2

000061da <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    61da:	b0 12 56 6c 	call	#27734		;#0x6c56

000061de <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    61de:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    61e2:	b0 12 22 74 	call	#29730		;#0x7422

000061e6 <.Loc.68.2>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    61e6:	b0 12 48 68 	call	#26696		;#0x6848

000061ea <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    61ea:	b0 12 78 6a 	call	#27256		;#0x6a78

000061ee <.Loc.107.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    61ee:	b0 12 cc 6b 	call	#27596		;#0x6bcc

000061f2 <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    61f2:	b0 12 b2 84 	call	#33970		;#0x84b2

000061f6 <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    61f6:	b0 12 fe 61 	call	#25086		;#0x61fe

000061fa <.Loc.145.2>:
#endif
}
    61fa:	03 43       	nop			
    61fc:	30 41       	ret			

000061fe <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    61fe:	b0 12 ee 6c 	call	#27886		;#0x6cee

00006202 <.Loc.63.2>:
}
    6202:	03 43       	nop			
    6204:	30 41       	ret			

00006206 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6206:	32 c2       	dint			

00006208 <.Loc.348.1>:
  asm volatile("nop");
    6208:	03 43       	nop			

0000620a <.Loc.349.1>:
}
    620a:	03 43       	nop			
    620c:	30 41       	ret			

0000620e <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    620e:	03 43       	nop			

00006210 <.Loc.356.1>:
  _enable_interrupts();
    6210:	32 d2       	eint			
    6212:	03 43       	nop			

00006214 <.Loc.357.1>:
}
    6214:	03 43       	nop			
    6216:	30 41       	ret			

00006218 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6218:	b0 12 06 62 	call	#25094		;#0x6206
    621c:	b0 12 7a 5b 	call	#23418		;#0x5b7a

00006220 <.Loc.505.2>:
}
    6220:	03 43       	nop			
    6222:	30 41       	ret			

00006224 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6224:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    6228:	b0 12 0e 62 	call	#25102		;#0x620e

0000622c <.Loc.516.2>:
}
    622c:	03 43       	nop			
    622e:	30 41       	ret			

00006230 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6230:	1c 42 44 51 	mov	&0x5144,r12	;0x5144

00006234 <.Loc.630.2>:
}
    6234:	30 41       	ret			

00006236 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6236:	21 83       	decd	r1		;

00006238 <.LCFI0>:
    6238:	81 4c 00 00 	mov	r12,	0(r1)	;

0000623c <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    623c:	2c 41       	mov	@r1,	r12	;
    623e:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006242 <.Loc.768.2>:
}
    6242:	03 43       	nop			
    6244:	21 53       	incd	r1		;
    6246:	30 41       	ret			

00006248 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6248:	21 82       	sub	#4,	r1	;r2 As==10

0000624a <.LCFI1>:
    624a:	81 4c 02 00 	mov	r12,	2(r1)	;
    624e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006252 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6252:	1c 41 02 00 	mov	2(r1),	r12	;
    6256:	2d 41       	mov	@r1,	r13	;
    6258:	b0 12 c8 5f 	call	#24520		;#0x5fc8

0000625c <.Loc.797.2>:
}
    625c:	21 52       	add	#4,	r1	;r2 As==10
    625e:	30 41       	ret			

00006260 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6260:	31 82       	sub	#8,	r1	;r2 As==11

00006262 <.LCFI2>:
    6262:	81 4c 06 00 	mov	r12,	6(r1)	;
    6266:	81 4d 04 00 	mov	r13,	4(r1)	;
    626a:	81 4e 02 00 	mov	r14,	2(r1)	;
    626e:	81 4f 00 00 	mov	r15,	0(r1)	;

00006272 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6272:	1c 41 06 00 	mov	6(r1),	r12	;
    6276:	b0 12 36 62 	call	#25142		;#0x6236

0000627a <.Loc.59.3>:
  iqp->q_counter = 0;
    627a:	1c 41 06 00 	mov	6(r1),	r12	;
    627e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006282 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6282:	1c 41 06 00 	mov	6(r1),	r12	;
    6286:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    628a:	04 00 

0000628c <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    628c:	1c 41 06 00 	mov	6(r1),	r12	;
    6290:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6294:	0a 00 

00006296 <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6296:	1c 41 06 00 	mov	6(r1),	r12	;
    629a:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    629e:	08 00 

000062a0 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    62a0:	1d 41 04 00 	mov	4(r1),	r13	;
    62a4:	1d 51 02 00 	add	2(r1),	r13	;
    62a8:	1c 41 06 00 	mov	6(r1),	r12	;
    62ac:	8c 4d 06 00 	mov	r13,	6(r12)	;

000062b0 <.Loc.64.3>:
  iqp->q_notify  = infy;
    62b0:	1c 41 06 00 	mov	6(r1),	r12	;
    62b4:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000062b8 <.Loc.65.3>:
  iqp->q_link    = link;
    62b8:	1c 41 06 00 	mov	6(r1),	r12	;
    62bc:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    62c0:	0e 00 

000062c2 <.Loc.66.3>:
}
    62c2:	03 43       	nop			
    62c4:	31 52       	add	#8,	r1	;r2 As==11
    62c6:	30 41       	ret			

000062c8 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    62c8:	21 82       	sub	#4,	r1	;r2 As==10

000062ca <.LCFI4>:
    62ca:	81 4c 02 00 	mov	r12,	2(r1)	;
    62ce:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000062d2 <.Loc.104.3>:

  osalDbgCheckClassI();
    62d2:	b0 12 60 5c 	call	#23648		;#0x5c60

000062d6 <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    62d6:	1c 41 02 00 	mov	2(r1),	r12	;
    62da:	1d 4c 08 00 	mov	8(r12),	r13	;
    62de:	1c 41 02 00 	mov	2(r1),	r12	;
    62e2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    62e6:	0d 9c       	cmp	r12,	r13	;
    62e8:	08 20       	jnz	$+18     	;abs 0x62fa

000062ea <.Loc.106.3>:
    62ea:	1c 41 02 00 	mov	2(r1),	r12	;
    62ee:	1c 4c 02 00 	mov	2(r12),	r12	;
    62f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    62f4:	02 24       	jz	$+6      	;abs 0x62fa

000062f6 <.Loc.106.3>:
    62f6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    62f8:	01 3c       	jmp	$+4      	;abs 0x62fc

000062fa <.L13>:
    62fa:	4c 43       	clr.b	r12		;

000062fc <.L14>:
    62fc:	5c f3       	and.b	#1,	r12	;r3 As==01
    62fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6302:	0c 93       	cmp	#0,	r12	;r3 As==00
    6304:	02 24       	jz	$+6      	;abs 0x630a

00006306 <.Loc.107.3>:
    return MSG_TIMEOUT;
    6306:	3c 43       	mov	#-1,	r12	;r3 As==11
    6308:	2f 3c       	jmp	$+96     	;abs 0x6368

0000630a <.L15>:
  }

  iqp->q_counter++;
    630a:	1c 41 02 00 	mov	2(r1),	r12	;
    630e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6312:	0d 4c       	mov	r12,	r13	;
    6314:	1d 53       	inc	r13		;
    6316:	1c 41 02 00 	mov	2(r1),	r12	;
    631a:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000631e <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    631e:	1c 41 02 00 	mov	2(r1),	r12	;
    6322:	1c 4c 08 00 	mov	8(r12),	r12	;
    6326:	0e 4c       	mov	r12,	r14	;
    6328:	1e 53       	inc	r14		;
    632a:	1d 41 02 00 	mov	2(r1),	r13	;
    632e:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6332:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6336:	00 00 

00006338 <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6338:	1c 41 02 00 	mov	2(r1),	r12	;
    633c:	1d 4c 08 00 	mov	8(r12),	r13	;
    6340:	1c 41 02 00 	mov	2(r1),	r12	;
    6344:	1c 4c 06 00 	mov	6(r12),	r12	;
    6348:	0d 9c       	cmp	r12,	r13	;
    634a:	08 28       	jnc	$+18     	;abs 0x635c

0000634c <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    634c:	1c 41 02 00 	mov	2(r1),	r12	;
    6350:	1d 4c 04 00 	mov	4(r12),	r13	;
    6354:	1c 41 02 00 	mov	2(r1),	r12	;
    6358:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000635c <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    635c:	1c 41 02 00 	mov	2(r1),	r12	;
    6360:	4d 43       	clr.b	r13		;
    6362:	b0 12 1a 61 	call	#24858		;#0x611a

00006366 <.Loc.118.3>:

  return MSG_OK;
    6366:	4c 43       	clr.b	r12		;

00006368 <.L16>:
}
    6368:	21 52       	add	#4,	r1	;r2 As==10
    636a:	30 41       	ret			

0000636c <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    636c:	31 82       	sub	#8,	r1	;r2 As==11

0000636e <.LCFI5>:
    636e:	81 4c 02 00 	Address 0x0000000000006370 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006370 <L0>:
    6370:	02 00       	mova	@r0,	r2	;
    6372:	81 4d 00 00 	mov	r13,	0(r1)	;

00006376 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6376:	b0 12 18 62 	call	#25112		;#0x6218

0000637a <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    637a:	0f 3c       	jmp	$+32     	;abs 0x639a

0000637c <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    637c:	1c 41 02 00 	mov	2(r1),	r12	;
    6380:	2d 41       	mov	@r1,	r13	;
    6382:	b0 12 48 62 	call	#25160		;#0x6248
    6386:	81 4c 06 00 	mov	r12,	6(r1)	;

0000638a <.Loc.149.3>:
    if (msg < MSG_OK) {
    638a:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    638e:	05 34       	jge	$+12     	;abs 0x639a

00006390 <.Loc.150.3>:
      osalSysUnlock();
    6390:	b0 12 24 62 	call	#25124		;#0x6224

00006394 <.Loc.151.3>:
      return msg;
    6394:	1c 41 06 00 	mov	6(r1),	r12	;
    6398:	3f 3c       	jmp	$+128    	;abs 0x6418

0000639a <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    639a:	1c 41 02 00 	mov	2(r1),	r12	;
    639e:	1c 4c 02 00 	mov	2(r12),	r12	;
    63a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    63a4:	eb 27       	jz	$-40     	;abs 0x637c

000063a6 <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    63a6:	1c 41 02 00 	mov	2(r1),	r12	;
    63aa:	1c 4c 02 00 	mov	2(r12),	r12	;
    63ae:	0d 4c       	mov	r12,	r13	;
    63b0:	3d 53       	add	#-1,	r13	;r3 As==11
    63b2:	1c 41 02 00 	mov	2(r1),	r12	;
    63b6:	8c 4d 02 00 	mov	r13,	2(r12)	;

000063ba <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    63ba:	1c 41 02 00 	mov	2(r1),	r12	;
    63be:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    63c2:	0e 4c       	mov	r12,	r14	;
    63c4:	1e 53       	inc	r14		;
    63c6:	1d 41 02 00 	mov	2(r1),	r13	;
    63ca:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    63ce:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

000063d2 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    63d2:	1c 41 02 00 	mov	2(r1),	r12	;
    63d6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    63da:	1c 41 02 00 	mov	2(r1),	r12	;
    63de:	1c 4c 06 00 	mov	6(r12),	r12	;
    63e2:	0d 9c       	cmp	r12,	r13	;
    63e4:	08 28       	jnc	$+18     	;abs 0x63f6

000063e6 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    63e6:	1c 41 02 00 	mov	2(r1),	r12	;
    63ea:	1d 4c 04 00 	mov	4(r12),	r13	;
    63ee:	1c 41 02 00 	mov	2(r1),	r12	;
    63f2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000063f6 <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    63f6:	1c 41 02 00 	mov	2(r1),	r12	;
    63fa:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    63fe:	0c 93       	cmp	#0,	r12	;r3 As==00
    6400:	07 24       	jz	$+16     	;abs 0x6410

00006402 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6402:	1c 41 02 00 	mov	2(r1),	r12	;
    6406:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    640a:	1c 41 02 00 	mov	2(r1),	r12	;
    640e:	8d 12       	call	r13		;

00006410 <.L23>:
  }

  osalSysUnlock();
    6410:	b0 12 24 62 	call	#25124		;#0x6224

00006414 <.Loc.169.3>:

  return (msg_t)b;
    6414:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006418 <.L20>:
}
    6418:	31 52       	add	#8,	r1	;r2 As==11
    641a:	30 41       	ret			

0000641c <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    641c:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006420 <L0>:
    6420:	81 4c 06 00 	mov	r12,	6(r1)	;
    6424:	81 4d 04 00 	mov	r13,	4(r1)	;
    6428:	81 4e 02 00 	mov	r14,	2(r1)	;
    642c:	81 4f 00 00 	mov	r15,	0(r1)	;

00006430 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6430:	1c 41 06 00 	mov	6(r1),	r12	;
    6434:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6438:	0c 00 

0000643a <.Loc.200.3>:
  size_t r = 0;
    643a:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

0000643e <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    643e:	b0 12 18 62 	call	#25112		;#0x6218

00006442 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6442:	b0 12 30 62 	call	#25136		;#0x6230
    6446:	0d 4c       	mov	r12,	r13	;
    6448:	2d 51       	add	@r1,	r13	;
    644a:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

0000644e <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    644e:	2e 3c       	jmp	$+94     	;abs 0x64ac

00006450 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6450:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6454:	03 24       	jz	$+8      	;abs 0x645c

00006456 <.Loc.218.3>:
    6456:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    645a:	08 20       	jnz	$+18     	;abs 0x646c

0000645c <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    645c:	1c 41 06 00 	mov	6(r1),	r12	;
    6460:	2d 41       	mov	@r1,	r13	;
    6462:	b0 12 48 62 	call	#25160		;#0x6248
    6466:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    646a:	18 3c       	jmp	$+50     	;abs 0x649c

0000646c <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    646c:	b0 12 30 62 	call	#25136		;#0x6230
    6470:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6474:	0d 8c       	sub	r12,	r13	;
    6476:	81 4d 08 00 	mov	r13,	8(r1)	;

0000647a <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    647a:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    647e:	00 00 
    6480:	05 2c       	jc	$+12     	;abs 0x648c

00006482 <.Loc.228.3>:
          osalSysUnlock();
    6482:	b0 12 24 62 	call	#25124		;#0x6224

00006486 <.Loc.229.3>:
          return r;
    6486:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    648a:	5c 3c       	jmp	$+186    	;abs 0x6544

0000648c <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    648c:	1c 41 06 00 	mov	6(r1),	r12	;
    6490:	1d 41 08 00 	mov	8(r1),	r13	;
    6494:	b0 12 48 62 	call	#25160		;#0x6248
    6498:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

0000649c <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    649c:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    64a0:	05 24       	jz	$+12     	;abs 0x64ac

000064a2 <.Loc.237.3>:
        osalSysUnlock();
    64a2:	b0 12 24 62 	call	#25124		;#0x6224

000064a6 <.Loc.238.3>:
        return r;
    64a6:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    64aa:	4c 3c       	jmp	$+154    	;abs 0x6544

000064ac <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    64ac:	1c 41 06 00 	mov	6(r1),	r12	;
    64b0:	1c 4c 02 00 	mov	2(r12),	r12	;
    64b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    64b6:	cc 27       	jz	$-102    	;abs 0x6450

000064b8 <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    64b8:	1c 41 06 00 	mov	6(r1),	r12	;
    64bc:	1c 4c 02 00 	mov	2(r12),	r12	;
    64c0:	0d 4c       	mov	r12,	r13	;
    64c2:	3d 53       	add	#-1,	r13	;r3 As==11
    64c4:	1c 41 06 00 	mov	6(r1),	r12	;
    64c8:	8c 4d 02 00 	mov	r13,	2(r12)	;

000064cc <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    64cc:	1c 41 04 00 	mov	4(r1),	r12	;
    64d0:	0d 4c       	mov	r12,	r13	;
    64d2:	1d 53       	inc	r13		;
    64d4:	81 4d 04 00 	mov	r13,	4(r1)	;
    64d8:	1d 41 06 00 	mov	6(r1),	r13	;
    64dc:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    64e0:	0f 4d       	mov	r13,	r15	;
    64e2:	1f 53       	inc	r15		;
    64e4:	1e 41 06 00 	mov	6(r1),	r14	;
    64e8:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    64ec:	6d 4d       	mov.b	@r13,	r13	;
    64ee:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000064f2 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    64f2:	1c 41 06 00 	mov	6(r1),	r12	;
    64f6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    64fa:	1c 41 06 00 	mov	6(r1),	r12	;
    64fe:	1c 4c 06 00 	mov	6(r12),	r12	;
    6502:	0d 9c       	cmp	r12,	r13	;
    6504:	08 28       	jnc	$+18     	;abs 0x6516

00006506 <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6506:	1c 41 06 00 	mov	6(r1),	r12	;
    650a:	1d 4c 04 00 	mov	4(r12),	r13	;
    650e:	1c 41 06 00 	mov	6(r1),	r12	;
    6512:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006516 <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6516:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    651a:	05 24       	jz	$+12     	;abs 0x6526

0000651c <.Loc.251.3>:
      nfy(iqp);
    651c:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6520:	1c 41 06 00 	mov	6(r1),	r12	;
    6524:	8d 12       	call	r13		;

00006526 <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6526:	b0 12 24 62 	call	#25124		;#0x6224

0000652a <.Loc.257.3>:

    r++;
    652a:	91 53 10 00 	inc	16(r1)		;

0000652e <.Loc.258.3>:
    if (--n == 0U) {
    652e:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6532:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6536:	03 20       	jnz	$+8      	;abs 0x653e

00006538 <.Loc.259.3>:
      return r;
    6538:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    653c:	03 3c       	jmp	$+8      	;abs 0x6544

0000653e <.L34>:
    }

    osalSysLock();
    653e:	b0 12 18 62 	call	#25112		;#0x6218

00006542 <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6542:	b4 3f       	jmp	$-150    	;abs 0x64ac

00006544 <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    6544:	31 50 12 00 	add	#18,	r1	;#0x0012
    6548:	30 41       	ret			

0000654a <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    654a:	31 82       	sub	#8,	r1	;r2 As==11

0000654c <.LCFI7>:
    654c:	81 4c 06 00 	mov	r12,	6(r1)	;
    6550:	81 4d 04 00 	mov	r13,	4(r1)	;
    6554:	81 4e 02 00 	Address 0x0000000000006556 is out of bounds.
mov	r14,	-1(r1)	; 0xffff

00006556 <L0>:
    6556:	02 00       	mova	@r0,	r2	;
    6558:	81 4f 00 00 	mov	r15,	0(r1)	;

0000655c <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    655c:	1c 41 06 00 	mov	6(r1),	r12	;
    6560:	b0 12 36 62 	call	#25142		;#0x6236

00006564 <.Loc.285.3>:
  oqp->q_counter = size;
    6564:	1c 41 06 00 	mov	6(r1),	r12	;
    6568:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    656c:	02 00 

0000656e <.Loc.286.3>:
  oqp->q_buffer  = bp;
    656e:	1c 41 06 00 	mov	6(r1),	r12	;
    6572:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6576:	04 00 

00006578 <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6578:	1c 41 06 00 	mov	6(r1),	r12	;
    657c:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6580:	0a 00 

00006582 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6582:	1c 41 06 00 	mov	6(r1),	r12	;
    6586:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    658a:	08 00 

0000658c <.Loc.289.3>:
  oqp->q_top     = bp + size;
    658c:	1d 41 04 00 	mov	4(r1),	r13	;
    6590:	1d 51 02 00 	add	2(r1),	r13	;
    6594:	1c 41 06 00 	mov	6(r1),	r12	;
    6598:	8c 4d 06 00 	mov	r13,	6(r12)	;

0000659c <.Loc.290.3>:
  oqp->q_notify  = onfy;
    659c:	1c 41 06 00 	mov	6(r1),	r12	;
    65a0:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000065a4 <.Loc.291.3>:
  oqp->q_link    = link;
    65a4:	1c 41 06 00 	mov	6(r1),	r12	;
    65a8:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    65ac:	0e 00 

000065ae <.Loc.292.3>:
}
    65ae:	03 43       	nop			
    65b0:	31 52       	add	#8,	r1	;r2 As==11
    65b2:	30 41       	ret			

000065b4 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    65b4:	31 82       	sub	#8,	r1	;r2 As==11

000065b6 <.LCFI9>:
    65b6:	81 4c 04 00 	mov	r12,	4(r1)	;
    65ba:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    65be:	81 4e 00 00 	mov	r14,	0(r1)	;

000065c2 <.Loc.339.3>:

  osalSysLock();
    65c2:	b0 12 18 62 	call	#25112		;#0x6218

000065c6 <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    65c6:	0f 3c       	jmp	$+32     	;abs 0x65e6

000065c8 <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    65c8:	1c 41 04 00 	mov	4(r1),	r12	;
    65cc:	2d 41       	mov	@r1,	r13	;
    65ce:	b0 12 48 62 	call	#25160		;#0x6248
    65d2:	81 4c 06 00 	mov	r12,	6(r1)	;

000065d6 <.Loc.344.3>:
    if (msg < MSG_OK) {
    65d6:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    65da:	05 34       	jge	$+12     	;abs 0x65e6

000065dc <.Loc.345.3>:
      osalSysUnlock();
    65dc:	b0 12 24 62 	call	#25124		;#0x6224

000065e0 <.Loc.346.3>:
      return msg;
    65e0:	1c 41 06 00 	mov	6(r1),	r12	;
    65e4:	3f 3c       	jmp	$+128    	;abs 0x6664

000065e6 <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    65e6:	1c 41 04 00 	mov	4(r1),	r12	;
    65ea:	1c 4c 02 00 	mov	2(r12),	r12	;
    65ee:	0c 93       	cmp	#0,	r12	;r3 As==00
    65f0:	eb 27       	jz	$-40     	;abs 0x65c8

000065f2 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    65f2:	1c 41 04 00 	mov	4(r1),	r12	;
    65f6:	1c 4c 02 00 	mov	2(r12),	r12	;
    65fa:	0d 4c       	mov	r12,	r13	;
    65fc:	3d 53       	add	#-1,	r13	;r3 As==11
    65fe:	1c 41 04 00 	mov	4(r1),	r12	;
    6602:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006606 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6606:	1c 41 04 00 	mov	4(r1),	r12	;
    660a:	1c 4c 08 00 	mov	8(r12),	r12	;
    660e:	0e 4c       	mov	r12,	r14	;
    6610:	1e 53       	inc	r14		;
    6612:	1d 41 04 00 	mov	4(r1),	r13	;
    6616:	8d 4e 08 00 	mov	r14,	8(r13)	;
    661a:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    661e:	00 00 

00006620 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6620:	1c 41 04 00 	mov	4(r1),	r12	;
    6624:	1d 4c 08 00 	mov	8(r12),	r13	;
    6628:	1c 41 04 00 	mov	4(r1),	r12	;
    662c:	1c 4c 06 00 	mov	6(r12),	r12	;
    6630:	0d 9c       	cmp	r12,	r13	;
    6632:	08 28       	jnc	$+18     	;abs 0x6644

00006634 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    6634:	1c 41 04 00 	mov	4(r1),	r12	;
    6638:	1d 4c 04 00 	mov	4(r12),	r13	;
    663c:	1c 41 04 00 	mov	4(r1),	r12	;
    6640:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006644 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6644:	1c 41 04 00 	mov	4(r1),	r12	;
    6648:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    664c:	0c 93       	cmp	#0,	r12	;r3 As==00
    664e:	07 24       	jz	$+16     	;abs 0x665e

00006650 <.Loc.359.3>:
    oqp->q_notify(oqp);
    6650:	1c 41 04 00 	mov	4(r1),	r12	;
    6654:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6658:	1c 41 04 00 	mov	4(r1),	r12	;
    665c:	8d 12       	call	r13		;

0000665e <.L43>:
  }

  osalSysUnlock();
    665e:	b0 12 24 62 	call	#25124		;#0x6224

00006662 <.Loc.364.3>:

  return MSG_OK;
    6662:	4c 43       	clr.b	r12		;

00006664 <.L40>:
}
    6664:	31 52       	add	#8,	r1	;r2 As==11
    6666:	30 41       	ret			

00006668 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6668:	21 82       	sub	#4,	r1	;r2 As==10

0000666a <.LCFI10>:
    666a:	81 4c 00 00 	Address 0x000000000000666c is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000666c <L0>:
	...

0000666e <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    666e:	b0 12 60 5c 	call	#23648		;#0x5c60

00006672 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    6672:	2c 41       	mov	@r1,	r12	;
    6674:	1d 4c 08 00 	mov	8(r12),	r13	;
    6678:	2c 41       	mov	@r1,	r12	;
    667a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    667e:	0d 9c       	cmp	r12,	r13	;
    6680:	07 20       	jnz	$+16     	;abs 0x6690

00006682 <.Loc.382.3>:
    6682:	2c 41       	mov	@r1,	r12	;
    6684:	1c 4c 02 00 	mov	2(r12),	r12	;
    6688:	0c 93       	cmp	#0,	r12	;r3 As==00
    668a:	02 24       	jz	$+6      	;abs 0x6690

0000668c <.Loc.382.3>:
    668c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    668e:	01 3c       	jmp	$+4      	;abs 0x6692

00006690 <.L45>:
    6690:	4c 43       	clr.b	r12		;

00006692 <.L46>:
    6692:	5c f3       	and.b	#1,	r12	;r3 As==01
    6694:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6698:	0c 93       	cmp	#0,	r12	;r3 As==00
    669a:	02 24       	jz	$+6      	;abs 0x66a0

0000669c <.Loc.383.3>:
    return MSG_TIMEOUT;
    669c:	3c 43       	mov	#-1,	r12	;r3 As==11
    669e:	26 3c       	jmp	$+78     	;abs 0x66ec

000066a0 <.L47>:
  }

  oqp->q_counter++;
    66a0:	2c 41       	mov	@r1,	r12	;
    66a2:	1c 4c 02 00 	mov	2(r12),	r12	;
    66a6:	0d 4c       	mov	r12,	r13	;
    66a8:	1d 53       	inc	r13		;
    66aa:	2c 41       	mov	@r1,	r12	;
    66ac:	8c 4d 02 00 	mov	r13,	2(r12)	;

000066b0 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    66b0:	2c 41       	mov	@r1,	r12	;
    66b2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    66b6:	0e 4c       	mov	r12,	r14	;
    66b8:	1e 53       	inc	r14		;
    66ba:	2d 41       	mov	@r1,	r13	;
    66bc:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    66c0:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

000066c4 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    66c4:	2c 41       	mov	@r1,	r12	;
    66c6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    66ca:	2c 41       	mov	@r1,	r12	;
    66cc:	1c 4c 06 00 	mov	6(r12),	r12	;
    66d0:	0d 9c       	cmp	r12,	r13	;
    66d2:	06 28       	jnc	$+14     	;abs 0x66e0

000066d4 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    66d4:	2c 41       	mov	@r1,	r12	;
    66d6:	1d 4c 04 00 	mov	4(r12),	r13	;
    66da:	2c 41       	mov	@r1,	r12	;
    66dc:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000066e0 <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    66e0:	2c 41       	mov	@r1,	r12	;
    66e2:	4d 43       	clr.b	r13		;
    66e4:	b0 12 1a 61 	call	#24858		;#0x611a

000066e8 <.Loc.394.3>:

  return (msg_t)b;
    66e8:	5c 41 03 00 	mov.b	3(r1),	r12	;

000066ec <.L48>:
}
    66ec:	21 52       	add	#4,	r1	;r2 As==10
    66ee:	30 41       	ret			

000066f0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    66f0:	31 80 12 00 	sub	#18,	r1	;#0x0012

000066f4 <L0>:
    66f4:	81 4c 06 00 	mov	r12,	6(r1)	;
    66f8:	81 4d 04 00 	mov	r13,	4(r1)	;
    66fc:	81 4e 02 00 	mov	r14,	2(r1)	;
    6700:	81 4f 00 00 	mov	r15,	0(r1)	;

00006704 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    6704:	1c 41 06 00 	mov	6(r1),	r12	;
    6708:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    670c:	0c 00 

0000670e <.Loc.425.3>:
  size_t w = 0;
    670e:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006712 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6712:	b0 12 18 62 	call	#25112		;#0x6218

00006716 <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6716:	b0 12 30 62 	call	#25136		;#0x6230
    671a:	0d 4c       	mov	r12,	r13	;
    671c:	2d 51       	add	@r1,	r13	;
    671e:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006722 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6722:	2e 3c       	jmp	$+94     	;abs 0x6780

00006724 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6724:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6728:	03 24       	jz	$+8      	;abs 0x6730

0000672a <.Loc.442.3>:
    672a:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    672e:	08 20       	jnz	$+18     	;abs 0x6740

00006730 <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6730:	1c 41 06 00 	mov	6(r1),	r12	;
    6734:	2d 41       	mov	@r1,	r13	;
    6736:	b0 12 48 62 	call	#25160		;#0x6248
    673a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    673e:	18 3c       	jmp	$+50     	;abs 0x6770

00006740 <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6740:	b0 12 30 62 	call	#25136		;#0x6230
    6744:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6748:	0e 8c       	sub	r12,	r14	;
    674a:	81 4e 08 00 	mov	r14,	8(r1)	;

0000674e <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    674e:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6752:	00 00 
    6754:	05 2c       	jc	$+12     	;abs 0x6760

00006756 <.Loc.452.3>:
          osalSysUnlock();
    6756:	b0 12 24 62 	call	#25124		;#0x6224

0000675a <.Loc.453.3>:
          return w;
    675a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    675e:	5c 3c       	jmp	$+186    	;abs 0x6818

00006760 <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    6760:	1c 41 06 00 	mov	6(r1),	r12	;
    6764:	1d 41 08 00 	mov	8(r1),	r13	;
    6768:	b0 12 48 62 	call	#25160		;#0x6248
    676c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006770 <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6770:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6774:	05 24       	jz	$+12     	;abs 0x6780

00006776 <.Loc.461.3>:
        osalSysUnlock();
    6776:	b0 12 24 62 	call	#25124		;#0x6224

0000677a <.Loc.462.3>:
        return w;
    677a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    677e:	4c 3c       	jmp	$+154    	;abs 0x6818

00006780 <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6780:	1c 41 06 00 	mov	6(r1),	r12	;
    6784:	1c 4c 02 00 	mov	2(r12),	r12	;
    6788:	0c 93       	cmp	#0,	r12	;r3 As==00
    678a:	cc 27       	jz	$-102    	;abs 0x6724

0000678c <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    678c:	1c 41 06 00 	mov	6(r1),	r12	;
    6790:	1c 4c 02 00 	mov	2(r12),	r12	;
    6794:	0d 4c       	mov	r12,	r13	;
    6796:	3d 53       	add	#-1,	r13	;r3 As==11
    6798:	1c 41 06 00 	mov	6(r1),	r12	;
    679c:	8c 4d 02 00 	mov	r13,	2(r12)	;

000067a0 <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    67a0:	1c 41 06 00 	mov	6(r1),	r12	;
    67a4:	1c 4c 08 00 	mov	8(r12),	r12	;
    67a8:	0e 4c       	mov	r12,	r14	;
    67aa:	1e 53       	inc	r14		;
    67ac:	1d 41 06 00 	mov	6(r1),	r13	;
    67b0:	8d 4e 08 00 	mov	r14,	8(r13)	;
    67b4:	1d 41 04 00 	mov	4(r1),	r13	;
    67b8:	0e 4d       	mov	r13,	r14	;
    67ba:	1e 53       	inc	r14		;
    67bc:	81 4e 04 00 	mov	r14,	4(r1)	;
    67c0:	6d 4d       	mov.b	@r13,	r13	;
    67c2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000067c6 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    67c6:	1c 41 06 00 	mov	6(r1),	r12	;
    67ca:	1d 4c 08 00 	mov	8(r12),	r13	;
    67ce:	1c 41 06 00 	mov	6(r1),	r12	;
    67d2:	1c 4c 06 00 	mov	6(r12),	r12	;
    67d6:	0d 9c       	cmp	r12,	r13	;
    67d8:	08 28       	jnc	$+18     	;abs 0x67ea

000067da <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    67da:	1c 41 06 00 	mov	6(r1),	r12	;
    67de:	1d 4c 04 00 	mov	4(r12),	r13	;
    67e2:	1c 41 06 00 	mov	6(r1),	r12	;
    67e6:	8c 4d 08 00 	mov	r13,	8(r12)	;

000067ea <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    67ea:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    67ee:	05 24       	jz	$+12     	;abs 0x67fa

000067f0 <.Loc.475.3>:
      nfy(oqp);
    67f0:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    67f4:	1c 41 06 00 	mov	6(r1),	r12	;
    67f8:	8d 12       	call	r13		;

000067fa <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    67fa:	b0 12 24 62 	call	#25124		;#0x6224

000067fe <.Loc.481.3>:

    w++;
    67fe:	91 53 10 00 	inc	16(r1)		;

00006802 <.Loc.482.3>:
    if (--n == 0U) {
    6802:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6806:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    680a:	03 20       	jnz	$+8      	;abs 0x6812

0000680c <.Loc.483.3>:
      return w;
    680c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6810:	03 3c       	jmp	$+8      	;abs 0x6818

00006812 <.L60>:
    }

    osalSysLock();
    6812:	b0 12 18 62 	call	#25112		;#0x6218

00006816 <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    6816:	85 3f       	jmp	$-244    	;abs 0x6722

00006818 <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    6818:	31 50 12 00 	add	#18,	r1	;#0x0012
    681c:	30 41       	ret			

0000681e <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    681e:	32 c2       	dint			

00006820 <.Loc.348.1>:
  asm volatile("nop");
    6820:	03 43       	nop			

00006822 <.Loc.349.1>:
}
    6822:	03 43       	nop			
    6824:	30 41       	ret			

00006826 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6826:	03 43       	nop			

00006828 <.Loc.356.1>:
  _enable_interrupts();
    6828:	32 d2       	eint			

0000682a <L0>:
    682a:	03 43       	nop			

0000682c <.Loc.357.1>:
}
    682c:	03 43       	nop			
    682e:	30 41       	ret			

00006830 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6830:	b0 12 1e 68 	call	#26654		;#0x681e
    6834:	b0 12 7a 5b 	call	#23418		;#0x5b7a

00006838 <.Loc.505.2>:
}
    6838:	03 43       	nop			
    683a:	30 41       	ret			

0000683c <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    683c:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    6840:	b0 12 26 68 	call	#26662		;#0x6826

00006844 <.Loc.516.2>:
}
    6844:	03 43       	nop			
    6846:	30 41       	ret			

00006848 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    6848:	b0 12 b4 83 	call	#33716		;#0x83b4

0000684c <.Loc.59.3>:
}
    684c:	03 43       	nop			
    684e:	30 41       	ret			

00006850 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    6850:	21 83       	decd	r1		;

00006852 <.LCFI3>:
    6852:	81 4c 00 00 	mov	r12,	0(r1)	;

00006856 <.Loc.70.3>:

  adcp->state    = ADC_STOP;
    6856:	2c 41       	mov	@r1,	r12	;
    6858:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000685c <.Loc.71.3>:
  adcp->config   = NULL;
    685c:	2c 41       	mov	@r1,	r12	;
    685e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006862 <.Loc.72.3>:
  adcp->samples  = NULL;
    6862:	2c 41       	mov	@r1,	r12	;
    6864:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006868 <.Loc.73.3>:
  adcp->depth    = 0;
    6868:	2c 41       	mov	@r1,	r12	;
    686a:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

0000686e <.Loc.74.3>:
  adcp->grpp     = NULL;
    686e:	2c 41       	mov	@r1,	r12	;
    6870:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00006874 <.Loc.76.3>:
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    6874:	2c 41       	mov	@r1,	r12	;
    6876:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000687a <.Loc.84.3>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    687a:	03 43       	nop			
    687c:	21 53       	incd	r1		;
    687e:	30 41       	ret			

00006880 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    6880:	21 82       	sub	#4,	r1	;r2 As==10

00006882 <.LCFI4>:
    6882:	81 4c 02 00 	mov	r12,	2(r1)	;
    6886:	81 4d 00 00 	mov	r13,	0(r1)	;

0000688a <.Loc.99.3>:

  osalDbgCheck(adcp != NULL);

  osalSysLock();
    688a:	b0 12 30 68 	call	#26672		;#0x6830

0000688e <.Loc.102.3>:
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    688e:	1c 41 02 00 	mov	2(r1),	r12	;
    6892:	ac 41 02 00 	mov	@r1,	2(r12)	;

00006896 <.Loc.103.3>:
  adc_lld_start(adcp);
    6896:	1c 41 02 00 	mov	2(r1),	r12	;
    689a:	b0 12 ce 83 	call	#33742		;#0x83ce

0000689e <.Loc.104.3>:
  adcp->state = ADC_READY;
    689e:	1c 41 02 00 	mov	2(r1),	r12	;
    68a2:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

000068a6 <.Loc.105.3>:
  osalSysUnlock();
    68a6:	b0 12 3c 68 	call	#26684		;#0x683c

000068aa <.Loc.106.3>:
}
    68aa:	03 43       	nop			
    68ac:	21 52       	add	#4,	r1	;r2 As==10
    68ae:	30 41       	ret			

000068b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    68b0:	32 c2       	dint			

000068b2 <.Loc.348.1>:
  asm volatile("nop");
    68b2:	03 43       	nop			

000068b4 <.Loc.349.1>:
}
    68b4:	03 43       	nop			
    68b6:	30 41       	ret			

000068b8 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    68b8:	03 43       	nop			

000068ba <.Loc.356.1>:
  _enable_interrupts();
    68ba:	32 d2       	eint			
    68bc:	03 43       	nop			

000068be <.Loc.357.1>:
}
    68be:	03 43       	nop			
    68c0:	30 41       	ret			

000068c2 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    68c2:	b0 12 b0 68 	call	#26800		;#0x68b0
    68c6:	b0 12 7a 5b 	call	#23418		;#0x5b7a

000068ca <.Loc.505.2>:
}
    68ca:	03 43       	nop			
    68cc:	30 41       	ret			

000068ce <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    68ce:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    68d2:	b0 12 b8 68 	call	#26808		;#0x68b8

000068d6 <.Loc.516.2>:
}
    68d6:	03 43       	nop			
    68d8:	30 41       	ret			

000068da <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    68da:	21 83       	decd	r1		;

000068dc <.LCFI0>:
    68dc:	81 4c 00 00 	mov	r12,	0(r1)	;

000068e0 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    68e0:	2c 41       	mov	@r1,	r12	;
    68e2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    68e6:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

000068ea <.Loc.811.2>:
  esp->cb    = NULL;
    68ea:	2c 41       	mov	@r1,	r12	;
    68ec:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000068f0 <.Loc.812.2>:
  esp->param = NULL;
    68f0:	2c 41       	mov	@r1,	r12	;
    68f2:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

000068f6 <.Loc.813.2>:
}
    68f6:	03 43       	nop			
    68f8:	21 53       	incd	r1		;
    68fa:	30 41       	ret			

000068fc <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    68fc:	0a 15       	pushm	#1,	r10	;16-bit words

000068fe <.LCFI1>:
    68fe:	31 80 06 00 	sub	#6,	r1	;

00006902 <.LCFI2>:
    6902:	81 4c 04 00 	mov	r12,	4(r1)	;
    6906:	81 4d 00 00 	mov	r13,	0(r1)	;
    690a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000690e <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    690e:	1c 41 04 00 	mov	4(r1),	r12	;
    6912:	1d 4c 02 00 	mov	2(r12),	r13	;
    6916:	2c 4c       	mov	@r12,	r12	;
    6918:	2a 41       	mov	@r1,	r10	;
    691a:	0a dc       	bis	r12,	r10	;
    691c:	1b 41 02 00 	mov	2(r1),	r11	;
    6920:	0b dd       	bis	r13,	r11	;
    6922:	1c 41 04 00 	mov	4(r1),	r12	;
    6926:	8c 4a 00 00 	mov	r10,	0(r12)	;
    692a:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000692e <.Loc.829.2>:
  if (esp->cb != NULL) {
    692e:	1c 41 04 00 	mov	4(r1),	r12	;
    6932:	1c 4c 04 00 	mov	4(r12),	r12	;
    6936:	0c 93       	cmp	#0,	r12	;r3 As==00
    6938:	07 24       	jz	$+16     	;abs 0x6948

0000693a <.Loc.830.2>:
    esp->cb(esp);
    693a:	1c 41 04 00 	mov	4(r1),	r12	;
    693e:	1d 4c 04 00 	mov	4(r12),	r13	;
    6942:	1c 41 04 00 	mov	4(r1),	r12	;
    6946:	8d 12       	call	r13		;

00006948 <.L9>:
  }
}
    6948:	03 43       	nop			
    694a:	31 50 06 00 	add	#6,	r1	;
    694e:	0a 17       	popm	#1,	r10	;16-bit words
    6950:	30 41       	ret			

00006952 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    6952:	31 80 06 00 	sub	#6,	r1	;

00006956 <.LCFI3>:
    6956:	81 4c 04 00 	mov	r12,	4(r1)	;
    695a:	81 4d 02 00 	mov	r13,	2(r1)	;
    695e:	81 4e 00 00 	mov	r14,	0(r1)	;

00006962 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    6962:	1c 41 04 00 	mov	4(r1),	r12	;
    6966:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    696a:	4f 43       	clr.b	r15		;
    696c:	2e 41       	mov	@r1,	r14	;
    696e:	1d 41 02 00 	mov	2(r1),	r13	;
    6972:	b0 12 f0 66 	call	#26352		;#0x66f0

00006976 <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    6976:	31 50 06 00 	add	#6,	r1	;
    697a:	30 41       	ret			

0000697c <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    697c:	31 80 06 00 	sub	#6,	r1	;

00006980 <.LCFI4>:
    6980:	81 4c 04 00 	mov	r12,	4(r1)	;
    6984:	81 4d 02 00 	mov	r13,	2(r1)	;
    6988:	81 4e 00 00 	mov	r14,	0(r1)	;

0000698c <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    698c:	1c 41 04 00 	mov	4(r1),	r12	;
    6990:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6994:	4f 43       	clr.b	r15		;
    6996:	2e 41       	mov	@r1,	r14	;
    6998:	1d 41 02 00 	mov	2(r1),	r13	;
    699c:	b0 12 1c 64 	call	#25628		;#0x641c

000069a0 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    69a0:	31 50 06 00 	add	#6,	r1	;
    69a4:	30 41       	ret			

000069a6 <put>:

static msg_t put(void *ip, uint8_t b) {
    69a6:	21 82       	sub	#4,	r1	;r2 As==10

000069a8 <.LCFI5>:
    69a8:	81 4c 02 00 	mov	r12,	2(r1)	;
    69ac:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000069b0 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    69b0:	1c 41 02 00 	mov	2(r1),	r12	;
    69b4:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    69b8:	4e 43       	clr.b	r14		;
    69ba:	5d 41 01 00 	mov.b	1(r1),	r13	;
    69be:	b0 12 b4 65 	call	#26036		;#0x65b4

000069c2 <.Loc.65.3>:
}
    69c2:	21 52       	add	#4,	r1	;r2 As==10
    69c4:	30 41       	ret			

000069c6 <get>:

static msg_t get(void *ip) {
    69c6:	21 83       	decd	r1		;

000069c8 <.LCFI6>:
    69c8:	81 4c 00 00 	mov	r12,	0(r1)	;

000069cc <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    69cc:	2c 41       	mov	@r1,	r12	;
    69ce:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    69d2:	4d 43       	clr.b	r13		;
    69d4:	b0 12 6c 63 	call	#25452		;#0x636c

000069d8 <.Loc.70.3>:
}
    69d8:	21 53       	incd	r1		;
    69da:	30 41       	ret			

000069dc <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    69dc:	31 80 06 00 	sub	#6,	r1	;

000069e0 <.LCFI7>:
    69e0:	81 4c 04 00 	mov	r12,	4(r1)	;
    69e4:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    69e8:	81 4e 00 00 	mov	r14,	0(r1)	;

000069ec <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    69ec:	1c 41 04 00 	mov	4(r1),	r12	;
    69f0:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    69f4:	2e 41       	mov	@r1,	r14	;
    69f6:	5d 41 03 00 	mov.b	3(r1),	r13	;
    69fa:	b0 12 b4 65 	call	#26036		;#0x65b4

000069fe <.Loc.75.3>:
}
    69fe:	31 50 06 00 	add	#6,	r1	;
    6a02:	30 41       	ret			

00006a04 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    6a04:	21 82       	sub	#4,	r1	;r2 As==10

00006a06 <.LCFI8>:
    6a06:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a0a:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a0e <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    6a0e:	1c 41 02 00 	mov	2(r1),	r12	;
    6a12:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6a16:	2d 41       	mov	@r1,	r13	;
    6a18:	b0 12 6c 63 	call	#25452		;#0x636c

00006a1c <.Loc.80.3>:
}
    6a1c:	21 52       	add	#4,	r1	;r2 As==10
    6a1e:	30 41       	ret			

00006a20 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    6a20:	31 82       	sub	#8,	r1	;r2 As==11

00006a22 <.LCFI9>:
    6a22:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a26:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a2a:	81 4e 02 00 	mov	r14,	2(r1)	;
    6a2e:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a32 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    6a32:	1c 41 06 00 	mov	6(r1),	r12	;
    6a36:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6a3a:	2f 41       	mov	@r1,	r15	;
    6a3c:	1e 41 02 00 	mov	2(r1),	r14	;
    6a40:	1d 41 04 00 	mov	4(r1),	r13	;
    6a44:	b0 12 f0 66 	call	#26352		;#0x66f0

00006a48 <.Loc.85.3>:
}
    6a48:	31 52       	add	#8,	r1	;r2 As==11
    6a4a:	30 41       	ret			

00006a4c <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    6a4c:	31 82       	sub	#8,	r1	;r2 As==11

00006a4e <.LCFI10>:
    6a4e:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a52:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a56:	81 4e 02 00 	mov	r14,	2(r1)	;
    6a5a:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a5e <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    6a5e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a62:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6a66:	2f 41       	mov	@r1,	r15	;
    6a68:	1e 41 02 00 	mov	2(r1),	r14	;
    6a6c:	1d 41 04 00 	mov	4(r1),	r13	;
    6a70:	b0 12 1c 64 	call	#25628		;#0x641c

00006a74 <.Loc.90.3>:
}
    6a74:	31 52       	add	#8,	r1	;r2 As==11
    6a76:	30 41       	ret			

00006a78 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    6a78:	b0 12 50 72 	call	#29264		;#0x7250

00006a7c <.Loc.111.3>:
}
    6a7c:	03 43       	nop			
    6a7e:	30 41       	ret			

00006a80 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    6a80:	31 82       	sub	#8,	r1	;r2 As==11

00006a82 <.LCFI11>:
    6a82:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a86:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a8a:	81 4e 02 00 	mov	r14,	2(r1)	;

00006a8e <.Loc.130.3>:

  sdp->vmt = &vmt;
    6a8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a92:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    6a96:	00 00 

00006a98 <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    6a98:	1c 41 06 00 	mov	6(r1),	r12	;
    6a9c:	2c 53       	incd	r12		;
    6a9e:	b0 12 da 68 	call	#26842		;#0x68da

00006aa2 <.Loc.132.3>:
  sdp->state = SD_STOP;
    6aa2:	1c 41 06 00 	mov	6(r1),	r12	;
    6aa6:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

00006aaa <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    6aaa:	1c 41 06 00 	mov	6(r1),	r12	;
    6aae:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6ab2:	1d 41 06 00 	mov	6(r1),	r13	;
    6ab6:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    6aba:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6abe:	00 00 
    6ac0:	1f 41 04 00 	mov	4(r1),	r15	;
    6ac4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6ac8:	b0 12 60 62 	call	#25184		;#0x6260

00006acc <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    6acc:	1c 41 06 00 	mov	6(r1),	r12	;
    6ad0:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6ad4:	1d 41 06 00 	mov	6(r1),	r13	;
    6ad8:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    6adc:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6ae0:	00 00 
    6ae2:	1f 41 02 00 	mov	2(r1),	r15	;
    6ae6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6aea:	b0 12 4a 65 	call	#25930		;#0x654a

00006aee <.Loc.135.3>:
}
    6aee:	03 43       	nop			
    6af0:	31 52       	add	#8,	r1	;r2 As==11
    6af2:	30 41       	ret			

00006af4 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    6af4:	21 82       	sub	#4,	r1	;r2 As==10

00006af6 <.LCFI12>:
    6af6:	81 4c 02 00 	mov	r12,	2(r1)	;
    6afa:	81 4d 00 00 	mov	r13,	0(r1)	;

00006afe <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    6afe:	b0 12 c2 68 	call	#26818		;#0x68c2

00006b02 <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    6b02:	2d 41       	mov	@r1,	r13	;
    6b04:	1c 41 02 00 	mov	2(r1),	r12	;
    6b08:	b0 12 62 72 	call	#29282		;#0x7262

00006b0c <.Loc.155.3>:
  sdp->state = SD_READY;
    6b0c:	1c 41 02 00 	mov	2(r1),	r12	;
    6b10:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00006b14 <.Loc.156.3>:
  osalSysUnlock();
    6b14:	b0 12 ce 68 	call	#26830		;#0x68ce

00006b18 <.Loc.157.3>:
}
    6b18:	03 43       	nop			
    6b1a:	21 52       	add	#4,	r1	;r2 As==10
    6b1c:	30 41       	ret			

00006b1e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    6b1e:	21 82       	sub	#4,	r1	;r2 As==10

00006b20 <.LCFI14>:
    6b20:	81 4c 02 00 	mov	r12,	2(r1)	;
    6b24:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006b28 <.Loc.204.3>:

  osalDbgCheckClassI();
    6b28:	b0 12 60 5c 	call	#23648		;#0x5c60

00006b2c <.Loc.207.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    6b2c:	1c 41 02 00 	mov	2(r1),	r12	;
    6b30:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    6b34:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b36:	07 20       	jnz	$+16     	;abs 0x6b46

00006b38 <.Loc.208.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    6b38:	1c 41 02 00 	mov	2(r1),	r12	;
    6b3c:	2c 53       	incd	r12		;
    6b3e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6b40:	4e 43       	clr.b	r14		;
    6b42:	b0 12 fc 68 	call	#26876		;#0x68fc

00006b46 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    6b46:	1c 41 02 00 	mov	2(r1),	r12	;
    6b4a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6b4e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6b52:	b0 12 c8 62 	call	#25288		;#0x62c8
    6b56:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b58:	08 34       	jge	$+18     	;abs 0x6b6a

00006b5a <.Loc.210.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    6b5a:	1c 41 02 00 	mov	2(r1),	r12	;
    6b5e:	2c 53       	incd	r12		;
    6b60:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    6b64:	4e 43       	clr.b	r14		;
    6b66:	b0 12 fc 68 	call	#26876		;#0x68fc

00006b6a <.L33>:
}
    6b6a:	03 43       	nop			
    6b6c:	21 52       	add	#4,	r1	;r2 As==10
    6b6e:	30 41       	ret			

00006b70 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    6b70:	21 82       	sub	#4,	r1	;r2 As==10

00006b72 <.LCFI15>:
    6b72:	81 4c 00 00 	mov	r12,	0(r1)	;

00006b76 <.Loc.231.3>:
  msg_t  b;

  osalDbgCheckClassI();
    6b76:	b0 12 60 5c 	call	#23648		;#0x5c60

00006b7a <.Loc.234.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    6b7a:	2c 41       	mov	@r1,	r12	;
    6b7c:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6b80:	b0 12 68 66 	call	#26216		;#0x6668
    6b84:	81 4c 02 00 	mov	r12,	2(r1)	;

00006b88 <.Loc.235.3>:
  if (b < MSG_OK)
    6b88:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6b8c:	06 34       	jge	$+14     	;abs 0x6b9a

00006b8e <.Loc.236.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    6b8e:	2c 41       	mov	@r1,	r12	;
    6b90:	2c 53       	incd	r12		;
    6b92:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6b94:	4e 43       	clr.b	r14		;
    6b96:	b0 12 fc 68 	call	#26876		;#0x68fc

00006b9a <.L35>:
  return b;
    6b9a:	1c 41 02 00 	mov	2(r1),	r12	;

00006b9e <.Loc.238.3>:
}
    6b9e:	21 52       	add	#4,	r1	;r2 As==10
    6ba0:	30 41       	ret			

00006ba2 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6ba2:	32 c2       	dint			

00006ba4 <.Loc.348.1>:
  asm volatile("nop");
    6ba4:	03 43       	nop			

00006ba6 <.Loc.349.1>:
}
    6ba6:	03 43       	nop			
    6ba8:	30 41       	ret			

00006baa <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6baa:	03 43       	nop			

00006bac <.Loc.356.1>:
  _enable_interrupts();
    6bac:	32 d2       	eint			
    6bae:	03 43       	nop			

00006bb0 <.Loc.357.1>:
}
    6bb0:	03 43       	nop			
    6bb2:	30 41       	ret			

00006bb4 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6bb4:	b0 12 a2 6b 	call	#27554		;#0x6ba2
    6bb8:	b0 12 7a 5b 	call	#23418		;#0x5b7a

00006bbc <.Loc.505.2>:
}
    6bbc:	03 43       	nop			
    6bbe:	30 41       	ret			

00006bc0 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6bc0:	b0 12 9a 5b 	call	#23450		;#0x5b9a
    6bc4:	b0 12 aa 6b 	call	#27562		;#0x6baa

00006bc8 <.Loc.516.2>:
}
    6bc8:	03 43       	nop			
    6bca:	30 41       	ret			

00006bcc <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    6bcc:	b0 12 1c 7c 	call	#31772		;#0x7c1c

00006bd0 <.Loc.59.3>:
}
    6bd0:	03 43       	nop			
    6bd2:	30 41       	ret			

00006bd4 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    6bd4:	21 83       	decd	r1		;

00006bd6 <.LCFI1>:
    6bd6:	81 4c 00 00 	mov	r12,	0(r1)	;

00006bda <.Loc.70.3>:

  spip->state = SPI_STOP;
    6bda:	2c 41       	mov	@r1,	r12	;
    6bdc:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00006be0 <.Loc.71.3>:
  spip->config = NULL;
    6be0:	2c 41       	mov	@r1,	r12	;
    6be2:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006be6 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    6be6:	2c 41       	mov	@r1,	r12	;
    6be8:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006bec <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    6bec:	03 43       	nop			
    6bee:	21 53       	incd	r1		;
    6bf0:	30 41       	ret			

00006bf2 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    6bf2:	21 82       	sub	#4,	r1	;r2 As==10

00006bf4 <.LCFI2>:
    6bf4:	81 4c 02 00 	mov	r12,	2(r1)	;
    6bf8:	81 4d 00 00 	mov	r13,	0(r1)	;

00006bfc <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    6bfc:	b0 12 b4 6b 	call	#27572		;#0x6bb4

00006c00 <.Loc.98.3>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    6c00:	1c 41 02 00 	mov	2(r1),	r12	;
    6c04:	ac 41 02 00 	mov	@r1,	2(r12)	;

00006c08 <.Loc.99.3>:
  spi_lld_start(spip);
    6c08:	1c 41 02 00 	mov	2(r1),	r12	;
    6c0c:	b0 12 e0 7c 	call	#31968		;#0x7ce0

00006c10 <.Loc.100.3>:
  spip->state = SPI_READY;
    6c10:	1c 41 02 00 	mov	2(r1),	r12	;
    6c14:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00006c18 <.Loc.101.3>:
  osalSysUnlock();
    6c18:	b0 12 c0 6b 	call	#27584		;#0x6bc0

00006c1c <.Loc.102.3>:
}
    6c1c:	03 43       	nop			
    6c1e:	21 52       	add	#4,	r1	;r2 As==10
    6c20:	30 41       	ret			

00006c22 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
    6c22:	21 83       	decd	r1		;

00006c24 <.LCFI4>:
    6c24:	81 4c 00 00 	mov	r12,	0(r1)	;

00006c28 <.Loc.140.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    6c28:	b0 12 b4 6b 	call	#27572		;#0x6bb4

00006c2c <.Loc.142.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
    6c2c:	2c 41       	mov	@r1,	r12	;
    6c2e:	b0 12 ea 7d 	call	#32234		;#0x7dea

00006c32 <.Loc.143.3>:
  osalSysUnlock();
    6c32:	b0 12 c0 6b 	call	#27584		;#0x6bc0

00006c36 <.Loc.144.3>:
}
    6c36:	03 43       	nop			
    6c38:	21 53       	incd	r1		;
    6c3a:	30 41       	ret			

00006c3c <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
    6c3c:	21 83       	decd	r1		;

00006c3e <.LCFI5>:
    6c3e:	81 4c 00 00 	mov	r12,	0(r1)	;

00006c42 <.Loc.158.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    6c42:	b0 12 b4 6b 	call	#27572		;#0x6bb4

00006c46 <.Loc.160.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
    6c46:	2c 41       	mov	@r1,	r12	;
    6c48:	b0 12 4a 7e 	call	#32330		;#0x7e4a

00006c4c <.Loc.161.3>:
  osalSysUnlock();
    6c4c:	b0 12 c0 6b 	call	#27584		;#0x6bc0

00006c50 <.Loc.162.3>:
}
    6c50:	03 43       	nop			
    6c52:	21 53       	incd	r1		;
    6c54:	30 41       	ret			

00006c56 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    6c56:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6c5a:	5c 01 

00006c5c <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    6c5c:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    6c60:	60 01 

00006c62 <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    6c62:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    6c66:	62 01 

00006c68 <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    6c68:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    6c6c:	64 01 

00006c6e <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    6c6e:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00006c72 <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    6c72:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    6c76:	68 01 

00006c78 <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    6c78:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    6c7c:	6c 01 

00006c7e <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    6c7e:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00006c82 <.Loc.87.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    6c82:	b0 12 c4 79 	call	#31172		;#0x79c4

00006c86 <.Loc.89.1>:
#endif
}
    6c86:	03 43       	nop			
    6c88:	30 41       	ret			

00006c8a <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6c8a:	03 43       	nop			
    6c8c:	30 41       	ret			

00006c8e <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6c8e:	03 43       	nop			
    6c90:	30 41       	ret			

00006c92 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6c92:	b0 12 8a 6c 	call	#27786		;#0x6c8a
    6c96:	b0 12 bc 5b 	call	#23484		;#0x5bbc

00006c9a <.Loc.527.2>:
}
    6c9a:	03 43       	nop			
    6c9c:	30 41       	ret			

00006c9e <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6c9e:	b0 12 de 5b 	call	#23518		;#0x5bde
    6ca2:	b0 12 8e 6c 	call	#27790		;#0x6c8e

00006ca6 <.Loc.538.2>:
}
    6ca6:	03 43       	nop			
    6ca8:	30 41       	ret			

00006caa <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    6caa:	b0 12 6c 5d 	call	#23916		;#0x5d6c

00006cae <.Loc.597.2>:
}
    6cae:	03 43       	nop			
    6cb0:	30 41       	ret			

00006cb2 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    6cb2:	bf 15       	pushm	#12,	r15	;16-bit words

00006cb4 <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    6cb4:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    6cb8:	b0 12 02 5c 	call	#23554		;#0x5c02

00006cbc <.Loc.170.3>:
  
  osalSysLockFromISR();
    6cbc:	b0 12 92 6c 	call	#27794		;#0x6c92

00006cc0 <.Loc.171.3>:
  osalOsTimerHandlerI();
    6cc0:	b0 12 aa 6c 	call	#27818		;#0x6caa

00006cc4 <.Loc.172.3>:
  osalSysUnlockFromISR();
    6cc4:	b0 12 9e 6c 	call	#27806		;#0x6c9e

00006cc8 <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    6cc8:	b0 12 30 5c 	call	#23600		;#0x5c30
    6ccc:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    6cd0:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    6cd4:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    6cd8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6cdc:	0c 93       	cmp	#0,	r12	;r3 As==00
    6cde:	02 24       	jz	$+6      	;abs 0x6ce4

00006ce0 <.Loc.174.3>:
    6ce0:	b0 12 cc 5e 	call	#24268		;#0x5ecc

00006ce4 <.L7>:
    6ce4:	b0 12 9a 5b 	call	#23450		;#0x5b9a

00006ce8 <.Loc.175.3>:
}
    6ce8:	03 43       	nop			
    6cea:	b4 17       	popm	#12,	r15	;16-bit words
    6cec:	00 13       	reti			

00006cee <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    6cee:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    6cf2:	d2 03 

00006cf4 <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    6cf4:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    6cf8:	c2 03 

00006cfa <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    6cfa:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00006cfe <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    6cfe:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    6d02:	c0 03 

00006d04 <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    6d04:	03 43       	nop			
    6d06:	30 41       	ret			

00006d08 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6d08:	03 43       	nop			
    6d0a:	30 41       	ret			

00006d0c <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6d0c:	03 43       	nop			
    6d0e:	30 41       	ret			

00006d10 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6d10:	b0 12 08 6d 	call	#27912		;#0x6d08
    6d14:	b0 12 bc 5b 	call	#23484		;#0x5bbc

00006d18 <.Loc.527.2>:
}
    6d18:	03 43       	nop			
    6d1a:	30 41       	ret			

00006d1c <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6d1c:	b0 12 de 5b 	call	#23518		;#0x5bde
    6d20:	b0 12 0c 6d 	call	#27916		;#0x6d0c

00006d24 <.Loc.538.2>:
}
    6d24:	03 43       	nop			
    6d26:	30 41       	ret			

00006d28 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6d28:	0a 15       	pushm	#1,	r10	;16-bit words

00006d2a <.LCFI0>:
    6d2a:	31 80 06 00 	sub	#6,	r1	;

00006d2e <.LCFI1>:
    6d2e:	81 4c 04 00 	mov	r12,	4(r1)	;
    6d32:	81 4d 00 00 	mov	r13,	0(r1)	;
    6d36:	81 4e 02 00 	mov	r14,	2(r1)	;

00006d3a <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6d3a:	1c 41 04 00 	mov	4(r1),	r12	;
    6d3e:	1d 4c 02 00 	mov	2(r12),	r13	;
    6d42:	2c 4c       	mov	@r12,	r12	;
    6d44:	2a 41       	mov	@r1,	r10	;
    6d46:	0a dc       	bis	r12,	r10	;
    6d48:	1b 41 02 00 	mov	2(r1),	r11	;
    6d4c:	0b dd       	bis	r13,	r11	;
    6d4e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d52:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6d56:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006d5a <.Loc.829.2>:
  if (esp->cb != NULL) {
    6d5a:	1c 41 04 00 	mov	4(r1),	r12	;
    6d5e:	1c 4c 04 00 	mov	4(r12),	r12	;
    6d62:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d64:	07 24       	jz	$+16     	;abs 0x6d74

00006d66 <.Loc.830.2>:
    esp->cb(esp);
    6d66:	1c 41 04 00 	mov	4(r1),	r12	;
    6d6a:	1d 4c 04 00 	mov	4(r12),	r13	;
    6d6e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d72:	8d 12       	call	r13		;

00006d74 <.L7>:
  }
}
    6d74:	03 43       	nop			
    6d76:	31 50 06 00 	add	#6,	r1	;
    6d7a:	0a 17       	popm	#1,	r10	;16-bit words
    6d7c:	30 41       	ret			

00006d7e <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    6d7e:	21 83       	decd	r1		;

00006d80 <.LCFI2>:
    6d80:	81 4c 00 00 	mov	r12,	0(r1)	;

00006d84 <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    6d84:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    6d88:	2c 91       	cmp	@r1,	r12	;
    6d8a:	02 28       	jnc	$+6      	;abs 0x6d90

00006d8c <.Loc.108.3>:
    return 0x00;
    6d8c:	4c 43       	clr.b	r12		;
    6d8e:	ec 3c       	jmp	$+474    	;abs 0x6f68

00006d90 <.L9>:
  else if (frac < 715)
    6d90:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    6d94:	2c 91       	cmp	@r1,	r12	;
    6d96:	02 28       	jnc	$+6      	;abs 0x6d9c

00006d98 <.Loc.110.3>:
    return 0x01;
    6d98:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d9a:	e6 3c       	jmp	$+462    	;abs 0x6f68

00006d9c <.L11>:
  else if (frac < 835)
    6d9c:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    6da0:	2c 91       	cmp	@r1,	r12	;
    6da2:	02 28       	jnc	$+6      	;abs 0x6da8

00006da4 <.Loc.112.3>:
    return 0x02;
    6da4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6da6:	e0 3c       	jmp	$+450    	;abs 0x6f68

00006da8 <.L12>:
  else if (frac < 1001)
    6da8:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    6dac:	2c 91       	cmp	@r1,	r12	;
    6dae:	02 28       	jnc	$+6      	;abs 0x6db4

00006db0 <.Loc.114.3>:
    return 0x04;
    6db0:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6db2:	da 3c       	jmp	$+438    	;abs 0x6f68

00006db4 <.L13>:
  else if (frac < 1252)
    6db4:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    6db8:	2c 91       	cmp	@r1,	r12	;
    6dba:	02 28       	jnc	$+6      	;abs 0x6dc0

00006dbc <.Loc.116.3>:
    return 0x08;
    6dbc:	7c 42       	mov.b	#8,	r12	;r2 As==11
    6dbe:	d4 3c       	jmp	$+426    	;abs 0x6f68

00006dc0 <.L14>:
  else if (frac < 1430)
    6dc0:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    6dc4:	2c 91       	cmp	@r1,	r12	;
    6dc6:	03 28       	jnc	$+8      	;abs 0x6dce

00006dc8 <.Loc.118.3>:
    return 0x10;
    6dc8:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6dcc:	cd 3c       	jmp	$+412    	;abs 0x6f68

00006dce <.L15>:
  else if (frac < 1670)
    6dce:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    6dd2:	2c 91       	cmp	@r1,	r12	;
    6dd4:	03 28       	jnc	$+8      	;abs 0x6ddc

00006dd6 <.Loc.120.3>:
    return 0x20;
    6dd6:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    6dda:	c6 3c       	jmp	$+398    	;abs 0x6f68

00006ddc <.L16>:
  else if (frac < 2147)
    6ddc:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    6de0:	2c 91       	cmp	@r1,	r12	;
    6de2:	03 28       	jnc	$+8      	;abs 0x6dea

00006de4 <.Loc.122.3>:
    return 0x11;
    6de4:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    6de8:	bf 3c       	jmp	$+384    	;abs 0x6f68

00006dea <.L17>:
  else if (frac < 2224)
    6dea:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    6dee:	2c 91       	cmp	@r1,	r12	;
    6df0:	03 28       	jnc	$+8      	;abs 0x6df8

00006df2 <.Loc.124.3>:
    return 0x21;
    6df2:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    6df6:	b8 3c       	jmp	$+370    	;abs 0x6f68

00006df8 <.L18>:
  else if (frac < 2503)
    6df8:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    6dfc:	2c 91       	cmp	@r1,	r12	;
    6dfe:	03 28       	jnc	$+8      	;abs 0x6e06

00006e00 <.Loc.126.3>:
    return 0x22;
    6e00:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    6e04:	b1 3c       	jmp	$+356    	;abs 0x6f68

00006e06 <.L19>:
  else if (frac < 3000)
    6e06:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    6e0a:	2c 91       	cmp	@r1,	r12	;
    6e0c:	03 28       	jnc	$+8      	;abs 0x6e14

00006e0e <.Loc.128.3>:
    return 0x44;
    6e0e:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    6e12:	aa 3c       	jmp	$+342    	;abs 0x6f68

00006e14 <.L20>:
  else if (frac < 3335)
    6e14:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    6e18:	2c 91       	cmp	@r1,	r12	;
    6e1a:	03 28       	jnc	$+8      	;abs 0x6e22

00006e1c <.Loc.130.3>:
    return 0x25;
    6e1c:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    6e20:	a3 3c       	jmp	$+328    	;abs 0x6f68

00006e22 <.L21>:
  else if (frac < 3575)
    6e22:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    6e26:	2c 91       	cmp	@r1,	r12	;
    6e28:	03 28       	jnc	$+8      	;abs 0x6e30

00006e2a <.Loc.132.3>:
    return 0x49;
    6e2a:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    6e2e:	9c 3c       	jmp	$+314    	;abs 0x6f68

00006e30 <.L22>:
  else if (frac < 3753)
    6e30:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    6e34:	2c 91       	cmp	@r1,	r12	;
    6e36:	03 28       	jnc	$+8      	;abs 0x6e3e

00006e38 <.Loc.134.3>:
    return 0x4A;
    6e38:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    6e3c:	95 3c       	jmp	$+300    	;abs 0x6f68

00006e3e <.L23>:
  else if (frac < 4003)
    6e3e:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    6e42:	2c 91       	cmp	@r1,	r12	;
    6e44:	03 28       	jnc	$+8      	;abs 0x6e4c

00006e46 <.Loc.136.3>:
    return 0x52;
    6e46:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    6e4a:	8e 3c       	jmp	$+286    	;abs 0x6f68

00006e4c <.L24>:
  else if (frac < 4286)
    6e4c:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    6e50:	2c 91       	cmp	@r1,	r12	;
    6e52:	03 28       	jnc	$+8      	;abs 0x6e5a

00006e54 <.Loc.138.3>:
    return 0x92;
    6e54:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    6e58:	87 3c       	jmp	$+272    	;abs 0x6f68

00006e5a <.L25>:
  else if (frac < 4378)
    6e5a:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    6e5e:	2c 91       	cmp	@r1,	r12	;
    6e60:	03 28       	jnc	$+8      	;abs 0x6e68

00006e62 <.Loc.140.3>:
    return 0x53;
    6e62:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    6e66:	80 3c       	jmp	$+258    	;abs 0x6f68

00006e68 <.L26>:
  else if (frac < 5002)
    6e68:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    6e6c:	2c 91       	cmp	@r1,	r12	;
    6e6e:	03 28       	jnc	$+8      	;abs 0x6e76

00006e70 <.Loc.142.3>:
    return 0x55;
    6e70:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    6e74:	79 3c       	jmp	$+244    	;abs 0x6f68

00006e76 <.L27>:
  else if (frac < 5715)
    6e76:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    6e7a:	2c 91       	cmp	@r1,	r12	;
    6e7c:	03 28       	jnc	$+8      	;abs 0x6e84

00006e7e <.Loc.144.3>:
    return 0xAA;
    6e7e:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    6e82:	72 3c       	jmp	$+230    	;abs 0x6f68

00006e84 <.L28>:
  else if (frac < 6003)
    6e84:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    6e88:	2c 91       	cmp	@r1,	r12	;
    6e8a:	03 28       	jnc	$+8      	;abs 0x6e92

00006e8c <.Loc.146.3>:
    return 0x6B;
    6e8c:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    6e90:	6b 3c       	jmp	$+216    	;abs 0x6f68

00006e92 <.L29>:
  else if (frac < 6254)
    6e92:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    6e96:	2c 91       	cmp	@r1,	r12	;
    6e98:	03 28       	jnc	$+8      	;abs 0x6ea0

00006e9a <.Loc.148.3>:
    return 0xAD;
    6e9a:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    6e9e:	64 3c       	jmp	$+202    	;abs 0x6f68

00006ea0 <.L30>:
  else if (frac < 6432)
    6ea0:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    6ea4:	2c 91       	cmp	@r1,	r12	;
    6ea6:	03 28       	jnc	$+8      	;abs 0x6eae

00006ea8 <.Loc.150.3>:
    return 0xB5;
    6ea8:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    6eac:	5d 3c       	jmp	$+188    	;abs 0x6f68

00006eae <.L31>:
  else if (frac < 6667)
    6eae:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    6eb2:	2c 91       	cmp	@r1,	r12	;
    6eb4:	03 28       	jnc	$+8      	;abs 0x6ebc

00006eb6 <.Loc.152.3>:
    return 0xB6;
    6eb6:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    6eba:	56 3c       	jmp	$+174    	;abs 0x6f68

00006ebc <.L32>:
  else if (frac < 7001)
    6ebc:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    6ec0:	2c 91       	cmp	@r1,	r12	;
    6ec2:	03 28       	jnc	$+8      	;abs 0x6eca

00006ec4 <.Loc.154.3>:
    return 0xD6;
    6ec4:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    6ec8:	4f 3c       	jmp	$+160    	;abs 0x6f68

00006eca <.L33>:
  else if (frac < 7147)
    6eca:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    6ece:	2c 91       	cmp	@r1,	r12	;
    6ed0:	03 28       	jnc	$+8      	;abs 0x6ed8

00006ed2 <.Loc.156.3>:
    return 0xB7;
    6ed2:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    6ed6:	48 3c       	jmp	$+146    	;abs 0x6f68

00006ed8 <.L34>:
  else if (frac < 7503)
    6ed8:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    6edc:	2c 91       	cmp	@r1,	r12	;
    6ede:	03 28       	jnc	$+8      	;abs 0x6ee6

00006ee0 <.Loc.158.3>:
    return 0xBB;
    6ee0:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    6ee4:	41 3c       	jmp	$+132    	;abs 0x6f68

00006ee6 <.L35>:
  else if (frac < 7861)
    6ee6:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    6eea:	2c 91       	cmp	@r1,	r12	;
    6eec:	03 28       	jnc	$+8      	;abs 0x6ef4

00006eee <.Loc.160.3>:
    return 0xDD;
    6eee:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    6ef2:	3a 3c       	jmp	$+118    	;abs 0x6f68

00006ef4 <.L36>:
  else if (frac < 8004)
    6ef4:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    6ef8:	2c 91       	cmp	@r1,	r12	;
    6efa:	03 28       	jnc	$+8      	;abs 0x6f02

00006efc <.Loc.162.3>:
    return 0xED;
    6efc:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    6f00:	33 3c       	jmp	$+104    	;abs 0x6f68

00006f02 <.L37>:
  else if (frac < 8333)
    6f02:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    6f06:	2c 91       	cmp	@r1,	r12	;
    6f08:	03 28       	jnc	$+8      	;abs 0x6f10

00006f0a <.Loc.164.3>:
    return 0xEE;
    6f0a:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    6f0e:	2c 3c       	jmp	$+90     	;abs 0x6f68

00006f10 <.L38>:
  else if (frac < 8464)
    6f10:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    6f14:	2c 91       	cmp	@r1,	r12	;
    6f16:	03 28       	jnc	$+8      	;abs 0x6f1e

00006f18 <.Loc.166.3>:
    return 0xBF;
    6f18:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    6f1c:	25 3c       	jmp	$+76     	;abs 0x6f68

00006f1e <.L39>:
  else if (frac < 8572)
    6f1e:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    6f22:	2c 91       	cmp	@r1,	r12	;
    6f24:	03 28       	jnc	$+8      	;abs 0x6f2c

00006f26 <.Loc.168.3>:
    return 0xDF;
    6f26:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    6f2a:	1e 3c       	jmp	$+62     	;abs 0x6f68

00006f2c <.L40>:
  else if (frac < 8751)
    6f2c:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    6f30:	2c 91       	cmp	@r1,	r12	;
    6f32:	03 28       	jnc	$+8      	;abs 0x6f3a

00006f34 <.Loc.170.3>:
    return 0xEF;
    6f34:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    6f38:	17 3c       	jmp	$+48     	;abs 0x6f68

00006f3a <.L41>:
  else if (frac < 9004)
    6f3a:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    6f3e:	2c 91       	cmp	@r1,	r12	;
    6f40:	03 28       	jnc	$+8      	;abs 0x6f48

00006f42 <.Loc.172.3>:
    return 0xF7;
    6f42:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    6f46:	10 3c       	jmp	$+34     	;abs 0x6f68

00006f48 <.L42>:
  else if (frac < 9170)
    6f48:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    6f4c:	2c 91       	cmp	@r1,	r12	;
    6f4e:	03 28       	jnc	$+8      	;abs 0x6f56

00006f50 <.Loc.174.3>:
    return 0xFB;
    6f50:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    6f54:	09 3c       	jmp	$+20     	;abs 0x6f68

00006f56 <.L43>:
  else if (frac < 9288)
    6f56:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    6f5a:	2c 91       	cmp	@r1,	r12	;
    6f5c:	03 28       	jnc	$+8      	;abs 0x6f64

00006f5e <.Loc.176.3>:
    return 0xFD;
    6f5e:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    6f62:	02 3c       	jmp	$+6      	;abs 0x6f68

00006f64 <.L44>:
  else
    return 0xFE;
    6f64:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00006f68 <.L10>:
}
    6f68:	21 53       	incd	r1		;
    6f6a:	30 41       	ret			

00006f6c <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    6f6c:	0a 15       	pushm	#1,	r10	;16-bit words

00006f6e <.LCFI3>:
    6f6e:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00006f72 <.LCFI4>:
    6f72:	81 4c 04 00 	mov	r12,	4(r1)	;
    6f76:	81 4d 06 00 	mov	r13,	6(r1)	;
    6f7a:	81 4e 00 00 	mov	r14,	0(r1)	;
    6f7e:	81 4f 02 00 	mov	r15,	2(r1)	;

00006f82 <.Loc.191.3>:

  uint16_t n = freq / baud;
    6f82:	1e 41 04 00 	mov	4(r1),	r14	;
    6f86:	1f 41 06 00 	mov	6(r1),	r15	;
    6f8a:	2c 41       	mov	@r1,	r12	;
    6f8c:	1d 41 02 00 	mov	2(r1),	r13	;
    6f90:	b0 12 1e a3 	call	#41758		;#0xa31e
    6f94:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00006f98 <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    6f98:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6f9c:	0c 4e       	mov	r14,	r12	;
    6f9e:	0d 43       	clr	r13		;
    6fa0:	1e 41 04 00 	mov	4(r1),	r14	;
    6fa4:	1f 41 06 00 	mov	6(r1),	r15	;
    6fa8:	b0 12 54 ad 	call	#44372		;#0xad54
    6fac:	0e 4c       	mov	r12,	r14	;
    6fae:	0f 4d       	mov	r13,	r15	;
    6fb0:	2c 41       	mov	@r1,	r12	;

00006fb2 <L0>:
    6fb2:	1d 41 02 00 	mov	2(r1),	r13	;
    6fb6:	0c 8e       	sub	r14,	r12	;
    6fb8:	0d 7f       	subc	r15,	r13	;
    6fba:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    6fbe:	4f 43       	clr.b	r15		;
    6fc0:	b0 12 54 ad 	call	#44372		;#0xad54
    6fc4:	1e 41 04 00 	mov	4(r1),	r14	;
    6fc8:	1f 41 06 00 	mov	6(r1),	r15	;
    6fcc:	b0 12 1e a3 	call	#41758		;#0xa31e
    6fd0:	81 4c 08 00 	mov	r12,	8(r1)	;

00006fd4 <.Loc.194.3>:
  if (n > 16) {
    6fd4:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6fd8:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    6fdc:	19 2c       	jc	$+52     	;abs 0x7010

00006fde <.Loc.195.3>:
    while (n > 16) {
    6fde:	03 3c       	jmp	$+8      	;abs 0x6fe6

00006fe0 <.L48>:
      n -= 16;
    6fe0:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    6fe4:	0a 00 

00006fe6 <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    6fe6:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6fea:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    6fee:	f8 2b       	jnc	$-14     	;abs 0x6fe0

00006ff0 <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    6ff0:	1c 41 08 00 	mov	8(r1),	r12	;
    6ff4:	b0 12 7e 6d 	call	#28030		;#0x6d7e
    6ff8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6ffc:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7000:	0a 4c       	mov	r12,	r10	;
    7002:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7006:	b0 12 42 a3 	call	#41794		;#0xa342
    700a:	0c da       	bis	r10,	r12	;
    700c:	1c d3       	bis	#1,	r12	;r3 As==01
    700e:	08 3c       	jmp	$+18     	;abs 0x7020

00007010 <.L46>:
  }
  return UCBRS(frac) << 8;
    7010:	1c 41 08 00 	mov	8(r1),	r12	;
    7014:	b0 12 7e 6d 	call	#28030		;#0x6d7e
    7018:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    701c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

00007020 <.L49>:
}
    7020:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7024:	0a 17       	popm	#1,	r10	;16-bit words
    7026:	30 41       	ret			

00007028 <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    7028:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000702c <L0>:
    702c:	81 4c 04 00 	mov	r12,	4(r1)	;
    7030:	81 4d 06 00 	mov	r13,	6(r1)	;
    7034:	81 4e 00 00 	mov	r14,	0(r1)	;
    7038:	81 4f 02 00 	mov	r15,	2(r1)	;

0000703c <.Loc.212.3>:
  uint16_t n = freq / baud;
    703c:	1e 41 04 00 	mov	4(r1),	r14	;
    7040:	1f 41 06 00 	mov	6(r1),	r15	;
    7044:	2c 41       	mov	@r1,	r12	;
    7046:	1d 41 02 00 	mov	2(r1),	r13	;
    704a:	b0 12 1e a3 	call	#41758		;#0xa31e
    704e:	81 4c 08 00 	mov	r12,	8(r1)	;

00007052 <.Loc.213.3>:
  if (n > 16) {
    7052:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7056:	1c 91 08 00 	cmp	8(r1),	r12	;
    705a:	05 2c       	jc	$+12     	;abs 0x7066

0000705c <.Loc.214.3>:
    return n >> 4;
    705c:	1c 41 08 00 	mov	8(r1),	r12	;
    7060:	b0 12 cc a3 	call	#41932		;#0xa3cc
    7064:	02 3c       	jmp	$+6      	;abs 0x706a

00007066 <.L51>:
  }
  return n;
    7066:	1c 41 08 00 	mov	8(r1),	r12	;

0000706a <.L52>:
}
    706a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    706e:	30 41       	ret			

00007070 <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    7070:	21 83       	decd	r1		;

00007072 <L0>:
    7072:	81 4c 00 00 	mov	r12,	0(r1)	;

00007076 <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7076:	2c 41       	mov	@r1,	r12	;
    7078:	1d 4c 02 00 	mov	2(r12),	r13	;
    707c:	2c 4c       	mov	@r12,	r12	;
    707e:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    7082:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7086:	b0 12 28 70 	call	#28712		;#0x7028
    708a:	82 4c c6 05 	mov	r12,	&0x05c6	;

0000708e <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    708e:	2c 41       	mov	@r1,	r12	;
    7090:	1d 4c 02 00 	mov	2(r12),	r13	;
    7094:	2c 4c       	mov	@r12,	r12	;
    7096:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    709a:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    709e:	b0 12 6c 6f 	call	#28524		;#0x6f6c
    70a2:	82 4c c8 05 	mov	r12,	&0x05c8	;

000070a6 <.Loc.223.3>:
  UCA0STATW = 0;
    70a6:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

000070aa <.Loc.224.3>:
  UCA0ABCTL = 0;
    70aa:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

000070ae <.Loc.225.3>:
  UCA0IRCTL = 0;
    70ae:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

000070b2 <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    70b2:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    70b6:	c0 05 

000070b8 <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    70b8:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

000070bc <.Loc.230.3>:
}
    70bc:	03 43       	nop			
    70be:	21 53       	incd	r1		;
    70c0:	30 41       	ret			

000070c2 <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    70c2:	21 83       	decd	r1		;

000070c4 <.LCFI7>:
    70c4:	81 4c 00 00 	mov	r12,	0(r1)	;

000070c8 <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    70c8:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    70cc:	2c d3       	bis	#2,	r12	;r3 As==10
    70ce:	82 4c da 05 	mov	r12,	&0x05da	;

000070d2 <.Loc.280.3>:
}
    70d2:	03 43       	nop			
    70d4:	21 53       	incd	r1		;
    70d6:	30 41       	ret			

000070d8 <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    70d8:	31 82       	sub	#8,	r1	;r2 As==11

000070da <.LCFI8>:
    70da:	81 4c 02 00 	mov	r12,	2(r1)	;
    70de:	81 4d 00 00 	mov	r13,	0(r1)	;

000070e2 <.Loc.314.3>:
  eventflags_t sts = 0;
    70e2:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    70e6:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000070ea <.Loc.316.3>:

  if (sra & UCOE)
    70ea:	1c 41 02 00 	mov	2(r1),	r12	;
    70ee:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    70f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    70f4:	05 24       	jz	$+12     	;abs 0x7100

000070f6 <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    70f6:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    70fa:	04 00 
    70fc:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007100 <.L56>:
  if (sra & UCPE)
    7100:	1c 41 02 00 	mov	2(r1),	r12	;
    7104:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7108:	0c 93       	cmp	#0,	r12	;r3 As==00
    710a:	05 24       	jz	$+12     	;abs 0x7116

0000710c <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    710c:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    7110:	04 00 
    7112:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007116 <.L57>:
  if (sra & UCFE)
    7116:	1c 41 02 00 	mov	2(r1),	r12	;
    711a:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    711e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7120:	05 24       	jz	$+12     	;abs 0x712c

00007122 <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    7122:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    7126:	04 00 
    7128:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

0000712c <.L58>:
  osalSysLockFromISR();
    712c:	b0 12 10 6d 	call	#27920		;#0x6d10

00007130 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    7130:	2c 41       	mov	@r1,	r12	;
    7132:	2c 53       	incd	r12		;
    7134:	1d 41 04 00 	mov	4(r1),	r13	;
    7138:	1e 41 06 00 	mov	6(r1),	r14	;
    713c:	b0 12 28 6d 	call	#27944		;#0x6d28

00007140 <.Loc.324.3>:
  osalSysUnlockFromISR();
    7140:	b0 12 1c 6d 	call	#27932		;#0x6d1c

00007144 <.Loc.325.3>:
}
    7144:	03 43       	nop			
    7146:	31 52       	add	#8,	r1	;r2 As==11
    7148:	30 41       	ret			

0000714a <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    714a:	bf 15       	pushm	#12,	r15	;16-bit words

0000714c <.LCFI9>:
    714c:	21 83       	decd	r1		;

0000714e <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    714e:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    7152:	b0 12 02 5c 	call	#23554		;#0x5c02

00007156 <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    7156:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    715a:	2c 92       	cmp	#4,	r12	;r2 As==10
    715c:	1e 24       	jz	$+62     	;abs 0x719a
    715e:	3c 92       	cmp	#8,	r12	;r2 As==11
    7160:	40 24       	jz	$+130    	;abs 0x71e2
    7162:	2c 93       	cmp	#2,	r12	;r3 As==10
    7164:	01 24       	jz	$+4      	;abs 0x7168

00007166 <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    7166:	60 3c       	jmp	$+194    	;abs 0x7228

00007168 <.L63>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    7168:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    716c:	6c f2       	and.b	#4,	r12	;r2 As==10
    716e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7170:	06 24       	jz	$+14     	;abs 0x717e

00007172 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    7172:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7176:	3d 40 72 51 	mov	#20850,	r13	;#0x5172
    717a:	b0 12 d8 70 	call	#28888		;#0x70d8

0000717e <.L64>:

    /* Data available */
    osalSysLockFromISR();
    717e:	b0 12 10 6d 	call	#27920		;#0x6d10

00007182 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    7182:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    7186:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    718a:	4d 4c       	mov.b	r12,	r13	;
    718c:	3c 40 72 51 	mov	#20850,	r12	;#0x5172
    7190:	b0 12 1e 6b 	call	#27422		;#0x6b1e

00007194 <.Loc.352.3>:
    osalSysUnlockFromISR();
    7194:	b0 12 1c 6d 	call	#27932		;#0x6d1c

00007198 <.Loc.353.3>:
    break;
    7198:	47 3c       	jmp	$+144    	;abs 0x7228

0000719a <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    719a:	b0 12 10 6d 	call	#27920		;#0x6d10

0000719e <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    719e:	3c 40 72 51 	mov	#20850,	r12	;#0x5172
    71a2:	b0 12 70 6b 	call	#27504		;#0x6b70
    71a6:	81 4c 00 00 	mov	r12,	0(r1)	;

000071aa <.Loc.360.3>:
    if (b < Q_OK) {
    71aa:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    71ae:	13 34       	jge	$+40     	;abs 0x71d6

000071b0 <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    71b0:	7d 42       	mov.b	#8,	r13	;r2 As==11
    71b2:	4e 43       	clr.b	r14		;
    71b4:	3c 40 74 51 	mov	#20852,	r12	;#0x5174
    71b8:	b0 12 28 6d 	call	#27944		;#0x6d28

000071bc <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    71bc:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    71c0:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    71c4:	3c d2       	bis	#8,	r12	;r2 As==11
    71c6:	82 4c da 05 	mov	r12,	&0x05da	;

000071ca <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    71ca:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    71ce:	2c d3       	bis	#2,	r12	;r3 As==10
    71d0:	82 4c dc 05 	mov	r12,	&0x05dc	;
    71d4:	03 3c       	jmp	$+8      	;abs 0x71dc

000071d6 <.L66>:
    }
    else
      UCA0TXBUF = b;
    71d6:	2c 41       	mov	@r1,	r12	;
    71d8:	82 4c ce 05 	mov	r12,	&0x05ce	;

000071dc <.L67>:
    osalSysUnlockFromISR();
    71dc:	b0 12 1c 6d 	call	#27932		;#0x6d1c

000071e0 <.Loc.368.3>:
    break;
    71e0:	23 3c       	jmp	$+72     	;abs 0x7228

000071e2 <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    71e2:	b0 12 10 6d 	call	#27920		;#0x6d10

000071e6 <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    71e6:	1d 42 96 51 	mov	&0x5196,r13	;0x5196
    71ea:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    71ee:	0d 9c       	cmp	r12,	r13	;
    71f0:	06 20       	jnz	$+14     	;abs 0x71fe

000071f2 <.Loc.374.3>:
    71f2:	1c 42 90 51 	mov	&0x5190,r12	;0x5190
    71f6:	0c 93       	cmp	#0,	r12	;r3 As==00
    71f8:	02 24       	jz	$+6      	;abs 0x71fe

000071fa <.Loc.374.3>:
    71fa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    71fc:	01 3c       	jmp	$+4      	;abs 0x7200

000071fe <.L68>:
    71fe:	4c 43       	clr.b	r12		;

00007200 <.L69>:
    7200:	5c f3       	and.b	#1,	r12	;r3 As==01
    7202:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7206:	0c 93       	cmp	#0,	r12	;r3 As==00
    7208:	07 24       	jz	$+16     	;abs 0x7218

0000720a <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    720a:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    720e:	4e 43       	clr.b	r14		;
    7210:	3c 40 74 51 	mov	#20852,	r12	;#0x5174
    7214:	b0 12 28 6d 	call	#27944		;#0x6d28

00007218 <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    7218:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    721c:	3c c2       	bic	#8,	r12	;r2 As==11
    721e:	82 4c da 05 	mov	r12,	&0x05da	;

00007222 <.Loc.377.3>:
    osalSysUnlockFromISR();
    7222:	b0 12 1c 6d 	call	#27932		;#0x6d1c

00007226 <.Loc.378.3>:
    break;
    7226:	03 43       	nop			

00007228 <.L65>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    7228:	b0 12 30 5c 	call	#23600		;#0x5c30
    722c:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    7230:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    7234:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    7238:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    723c:	0c 93       	cmp	#0,	r12	;r3 As==00
    723e:	02 24       	jz	$+6      	;abs 0x7244

00007240 <.Loc.385.3>:
    7240:	b0 12 cc 5e 	call	#24268		;#0x5ecc

00007244 <.L71>:
    7244:	b0 12 9a 5b 	call	#23450		;#0x5b9a

00007248 <.Loc.386.3>:
}
    7248:	03 43       	nop			
    724a:	21 53       	incd	r1		;
    724c:	b4 17       	popm	#12,	r15	;16-bit words
    724e:	00 13       	reti			

00007250 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    7250:	3e 40 c2 70 	mov	#28866,	r14	;#0x70c2
    7254:	4d 43       	clr.b	r13		;
    7256:	3c 40 72 51 	mov	#20850,	r12	;#0x5172

0000725a <L0>:
    725a:	b0 12 80 6a 	call	#27264		;#0x6a80

0000725e <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    725e:	03 43       	nop			
    7260:	30 41       	ret			

00007262 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7262:	21 82       	sub	#4,	r1	;r2 As==10

00007264 <.LCFI11>:
    7264:	81 4c 02 00 	mov	r12,	2(r1)	;
    7268:	81 4d 00 00 	mov	r13,	0(r1)	;

0000726c <.Loc.603.3>:

  if (config == NULL) {
    726c:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7270:	03 20       	jnz	$+8      	;abs 0x7278

00007272 <.Loc.604.3>:
    config = &default_config;
    7272:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7276:	00 00 

00007278 <.L74>:
  }

  if (sdp->state == SD_STOP) {
    7278:	1c 41 02 00 	mov	2(r1),	r12	;
    727c:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7280:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7282:	07 20       	jnz	$+16     	;abs 0x7292

00007284 <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    7284:	b1 90 72 51 	cmp	#20850,	2(r1)	;#0x5172
    7288:	02 00 
    728a:	03 20       	jnz	$+8      	;abs 0x7292

0000728c <.Loc.610.3>:
      usart0_init(config);
    728c:	2c 41       	mov	@r1,	r12	;
    728e:	b0 12 70 70 	call	#28784		;#0x7070

00007292 <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    7292:	03 43       	nop			
    7294:	21 52       	add	#4,	r1	;r2 As==10
    7296:	30 41       	ret			

00007298 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    7298:	bf 15       	pushm	#12,	r15	;16-bit words

0000729a <.LCFI0>:
    729a:	21 82       	sub	#4,	r1	;r2 As==10

0000729c <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    729c:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    72a0:	b0 12 02 5c 	call	#23554		;#0x5c02

000072a4 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    72a4:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    72a8:	12 c3       	clrc			
    72aa:	0c 10       	rrc	r12		;
    72ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    72b0:	4d 4c       	mov.b	r12,	r13	;
    72b2:	7d 53       	add.b	#-1,	r13	;r3 As==11
    72b4:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000072b8 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    72b8:	5c 41 03 00 	mov.b	3(r1),	r12	;
    72bc:	0c 5c       	rla	r12		;
    72be:	3c 50 be 51 	add	#20926,	r12	;#0x51be
    72c2:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000072c6 <.Loc.80.1>:
  if (cb != NULL) {
    72c6:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    72ca:	02 24       	jz	$+6      	;abs 0x72d0

000072cc <.Loc.81.1>:
    (*cb)();
    72cc:	2c 41       	mov	@r1,	r12	;
    72ce:	8c 12       	call	r12		;

000072d0 <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    72d0:	b0 12 30 5c 	call	#23600		;#0x5c30
    72d4:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    72d8:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    72dc:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    72e0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    72e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    72e6:	02 24       	jz	$+6      	;abs 0x72ec

000072e8 <.Loc.84.1>:
    72e8:	b0 12 cc 5e 	call	#24268		;#0x5ecc

000072ec <.L3>:
    72ec:	b0 12 9a 5b 	call	#23450		;#0x5b9a

000072f0 <.Loc.85.1>:
}
    72f0:	03 43       	nop			
    72f2:	21 52       	add	#4,	r1	;r2 As==10
    72f4:	b4 17       	popm	#12,	r15	;16-bit words
    72f6:	00 13       	reti			

000072f8 <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    72f8:	bf 15       	pushm	#12,	r15	;16-bit words

000072fa <.LCFI2>:
    72fa:	21 82       	sub	#4,	r1	;r2 As==10

000072fc <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    72fc:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    7300:	b0 12 02 5c 	call	#23554		;#0x5c02

00007304 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    7304:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    7308:	12 c3       	clrc			
    730a:	0c 10       	rrc	r12		;
    730c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7310:	4d 4c       	mov.b	r12,	r13	;
    7312:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7314:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007318 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    7318:	5c 41 03 00 	mov.b	3(r1),	r12	;
    731c:	3c 52       	add	#8,	r12	;r2 As==11
    731e:	0c 5c       	rla	r12		;
    7320:	3c 50 be 51 	add	#20926,	r12	;#0x51be
    7324:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007328 <.Loc.98.1>:
  if (cb != NULL) {
    7328:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    732c:	02 24       	jz	$+6      	;abs 0x7332

0000732e <.Loc.99.1>:
    (*cb)();
    732e:	2c 41       	mov	@r1,	r12	;
    7330:	8c 12       	call	r12		;

00007332 <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7332:	b0 12 30 5c 	call	#23600		;#0x5c30
    7336:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    733a:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    733e:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    7342:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7346:	0c 93       	cmp	#0,	r12	;r3 As==00
    7348:	02 24       	jz	$+6      	;abs 0x734e

0000734a <.Loc.102.1>:
    734a:	b0 12 cc 5e 	call	#24268		;#0x5ecc

0000734e <.L6>:
    734e:	b0 12 9a 5b 	call	#23450		;#0x5b9a

00007352 <.Loc.103.1>:
}
    7352:	03 43       	nop			
    7354:	21 52       	add	#4,	r1	;r2 As==10
    7356:	b4 17       	popm	#12,	r15	;16-bit words
    7358:	00 13       	reti			

0000735a <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    735a:	bf 15       	pushm	#12,	r15	;16-bit words

0000735c <.LCFI4>:
    735c:	21 82       	sub	#4,	r1	;r2 As==10

0000735e <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    735e:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    7362:	b0 12 02 5c 	call	#23554		;#0x5c02

00007366 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    7366:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    736a:	12 c3       	clrc			
    736c:	0c 10       	rrc	r12		;
    736e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7372:	4d 4c       	mov.b	r12,	r13	;
    7374:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7376:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

0000737a <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    737a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    737e:	3c 50 10 00 	add	#16,	r12	;#0x0010
    7382:	0c 5c       	rla	r12		;
    7384:	3c 50 be 51 	add	#20926,	r12	;#0x51be
    7388:	a1 4c 00 00 	mov	@r12,	0(r1)	;

0000738c <.Loc.117.1>:
  if (cb != NULL) {
    738c:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7390:	02 24       	jz	$+6      	;abs 0x7396

00007392 <.Loc.118.1>:
    (*cb)();
    7392:	2c 41       	mov	@r1,	r12	;
    7394:	8c 12       	call	r12		;

00007396 <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7396:	b0 12 30 5c 	call	#23600		;#0x5c30
    739a:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    739e:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    73a2:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    73a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    73aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    73ac:	02 24       	jz	$+6      	;abs 0x73b2

000073ae <.Loc.121.1>:
    73ae:	b0 12 cc 5e 	call	#24268		;#0x5ecc

000073b2 <.L9>:
    73b2:	b0 12 9a 5b 	call	#23450		;#0x5b9a

000073b6 <.Loc.122.1>:
}
    73b6:	03 43       	nop			
    73b8:	21 52       	add	#4,	r1	;r2 As==10
    73ba:	b4 17       	popm	#12,	r15	;16-bit words
    73bc:	00 13       	reti			

000073be <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    73be:	bf 15       	pushm	#12,	r15	;16-bit words

000073c0 <.LCFI6>:
    73c0:	21 82       	sub	#4,	r1	;r2 As==10

000073c2 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    73c2:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    73c6:	b0 12 02 5c 	call	#23554		;#0x5c02

000073ca <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    73ca:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    73ce:	12 c3       	clrc			
    73d0:	0c 10       	rrc	r12		;
    73d2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    73d6:	4d 4c       	mov.b	r12,	r13	;
    73d8:	7d 53       	add.b	#-1,	r13	;r3 As==11
    73da:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000073de <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    73de:	5c 41 03 00 	mov.b	3(r1),	r12	;
    73e2:	3c 50 18 00 	add	#24,	r12	;#0x0018
    73e6:	0c 5c       	rla	r12		;
    73e8:	3c 50 be 51 	add	#20926,	r12	;#0x51be
    73ec:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000073f0 <.Loc.135.1>:
  if (cb != NULL) {
    73f0:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    73f4:	02 24       	jz	$+6      	;abs 0x73fa

000073f6 <.Loc.136.1>:
    (*cb)();
    73f6:	2c 41       	mov	@r1,	r12	;
    73f8:	8c 12       	call	r12		;

000073fa <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    73fa:	b0 12 30 5c 	call	#23600		;#0x5c30
    73fe:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    7402:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    7406:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    740a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    740e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7410:	02 24       	jz	$+6      	;abs 0x7416

00007412 <.Loc.139.1>:
    7412:	b0 12 cc 5e 	call	#24268		;#0x5ecc

00007416 <.L12>:
    7416:	b0 12 9a 5b 	call	#23450		;#0x5b9a

0000741a <.Loc.140.1>:
}
    741a:	03 43       	nop			
    741c:	21 52       	add	#4,	r1	;r2 As==10
    741e:	b4 17       	popm	#12,	r15	;16-bit words
    7420:	00 13       	reti			

00007422 <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    7422:	21 83       	decd	r1		;

00007424 <.LCFI8>:
    7424:	81 4c 00 00 	mov	r12,	0(r1)	;

00007428 <.Loc.309.1>:

  PAOUT = config->porta.out;
    7428:	2c 41       	mov	@r1,	r12	;
    742a:	2c 4c       	mov	@r12,	r12	;
    742c:	82 4c 02 02 	mov	r12,	&0x0202	;

00007430 <.Loc.310.1>:
  PADIR = config->porta.dir;
    7430:	2c 41       	mov	@r1,	r12	;
    7432:	1c 4c 02 00 	mov	2(r12),	r12	;
    7436:	82 4c 04 02 	mov	r12,	&0x0204	;

0000743a <.Loc.311.1>:
  PAREN = config->porta.ren;
    743a:	2c 41       	mov	@r1,	r12	;
    743c:	1c 4c 04 00 	mov	4(r12),	r12	;
    7440:	82 4c 06 02 	mov	r12,	&0x0206	;

00007444 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7444:	2c 41       	mov	@r1,	r12	;
    7446:	1c 4c 06 00 	mov	6(r12),	r12	;
    744a:	82 4c 0a 02 	mov	r12,	&0x020a	;

0000744e <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    744e:	2c 41       	mov	@r1,	r12	;
    7450:	1c 4c 08 00 	mov	8(r12),	r12	;
    7454:	82 4c 0c 02 	mov	r12,	&0x020c	;

00007458 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    7458:	2c 41       	mov	@r1,	r12	;
    745a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    745e:	82 4c 22 02 	mov	r12,	&0x0222	;

00007462 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    7462:	2c 41       	mov	@r1,	r12	;
    7464:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7468:	82 4c 24 02 	mov	r12,	&0x0224	;

0000746c <.Loc.317.1>:
  PBREN = config->portb.ren;
    746c:	2c 41       	mov	@r1,	r12	;
    746e:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    7472:	82 4c 26 02 	mov	r12,	&0x0226	;

00007476 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7476:	2c 41       	mov	@r1,	r12	;
    7478:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    747c:	82 4c 2a 02 	mov	r12,	&0x022a	;

00007480 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    7480:	2c 41       	mov	@r1,	r12	;
    7482:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7486:	82 4c 2c 02 	mov	r12,	&0x022c	;

0000748a <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    748a:	2c 41       	mov	@r1,	r12	;
    748c:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    7490:	82 4c 22 03 	mov	r12,	&0x0322	;

00007494 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    7494:	2c 41       	mov	@r1,	r12	;
    7496:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    749a:	82 4c 24 03 	mov	r12,	&0x0324	;

0000749e <.Loc.351.1>:
  PJREN = config->portj.ren;
    749e:	2c 41       	mov	@r1,	r12	;
    74a0:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    74a4:	82 4c 26 03 	mov	r12,	&0x0326	;

000074a8 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    74a8:	2c 41       	mov	@r1,	r12	;
    74aa:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    74ae:	82 4c 2a 03 	mov	r12,	&0x032a	;

000074b2 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    74b2:	2c 41       	mov	@r1,	r12	;
    74b4:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    74b8:	82 4c 2c 03 	mov	r12,	&0x032c	;

000074bc <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    74bc:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    74c0:	1c c3       	bic	#1,	r12	;r3 As==01
    74c2:	82 4c 30 01 	mov	r12,	&0x0130	;

000074c6 <.Loc.356.1>:
}
    74c6:	03 43       	nop			
    74c8:	21 53       	incd	r1		;
    74ca:	30 41       	ret			

000074cc <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    74cc:	31 80 06 00 	sub	#6,	r1	;

000074d0 <.LCFI9>:
    74d0:	81 4c 04 00 	mov	r12,	4(r1)	;
    74d4:	81 4d 02 00 	mov	r13,	2(r1)	;
    74d8:	81 4e 00 00 	mov	r14,	0(r1)	;

000074dc <.Loc.374.1>:
  
  switch (mode) {
    74dc:	2c 41       	mov	@r1,	r12	;
    74de:	2c 92       	cmp	#4,	r12	;r2 As==10
    74e0:	b5 24       	jz	$+364    	;abs 0x764c
    74e2:	6d 42       	mov.b	#4,	r13	;r2 As==10
    74e4:	0d 9c       	cmp	r12,	r13	;
    74e6:	0a 28       	jnc	$+22     	;abs 0x74fc
    74e8:	1c 93       	cmp	#1,	r12	;r3 As==01
    74ea:	5f 24       	jz	$+192    	;abs 0x75aa
    74ec:	1c 93       	cmp	#1,	r12	;r3 As==01
    74ee:	16 28       	jnc	$+46     	;abs 0x751c
    74f0:	2c 93       	cmp	#2,	r12	;r3 As==10
    74f2:	14 24       	jz	$+42     	;abs 0x751c
    74f4:	3c 90 03 00 	cmp	#3,	r12	;
    74f8:	58 24       	jz	$+178    	;abs 0x75aa

000074fa <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    74fa:	bd 3d       	jmp	$+892    	;abs 0x7876

000074fc <.L17>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    74fc:	3c 92       	cmp	#8,	r12	;r2 As==11
    74fe:	32 25       	jz	$+614    	;abs 0x7764
    7500:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7502:	0d 9c       	cmp	r12,	r13	;
    7504:	04 28       	jnc	$+10     	;abs 0x750e
    7506:	3c 90 06 00 	cmp	#6,	r12	;
    750a:	f2 24       	jz	$+486    	;abs 0x76f0

0000750c <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    750c:	b4 3d       	jmp	$+874    	;abs 0x7876

0000750e <.L21>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    750e:	3c 90 09 00 	cmp	#9,	r12	;
    7512:	56 25       	jz	$+686    	;abs 0x77c0
    7514:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    7518:	81 25       	jz	$+772    	;abs 0x781c

0000751a <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    751a:	ad 3d       	jmp	$+860    	;abs 0x7876

0000751c <.L19>:
                           iomode_t mode) {
  
  switch (mode) {
    case PAL_MODE_RESET:
    case PAL_MODE_INPUT:
      port->dir &= ~mask;
    751c:	1c 41 04 00 	mov	4(r1),	r12	;
    7520:	1d 4c 04 00 	mov	4(r12),	r13	;
    7524:	1c 41 02 00 	mov	2(r1),	r12	;
    7528:	3c e3       	inv	r12		;
    752a:	0d fc       	and	r12,	r13	;
    752c:	1c 41 04 00 	mov	4(r1),	r12	;
    7530:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007534 <.Loc.378.1>:
      port->ren &= ~mask;
    7534:	1c 41 04 00 	mov	4(r1),	r12	;
    7538:	1d 4c 08 00 	mov	8(r12),	r13	;
    753c:	1c 41 02 00 	mov	2(r1),	r12	;
    7540:	3c e3       	inv	r12		;
    7542:	0d fc       	and	r12,	r13	;
    7544:	1c 41 04 00 	mov	4(r1),	r12	;
    7548:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000754c <.Loc.379.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    754c:	1c 41 04 00 	mov	4(r1),	r12	;
    7550:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7554:	1c f1 02 00 	and	2(r1),	r12	;
    7558:	0c 93       	cmp	#0,	r12	;r3 As==00
    755a:	0e 24       	jz	$+30     	;abs 0x7578

0000755c <.Loc.379.1>:
    755c:	1c 41 04 00 	mov	4(r1),	r12	;
    7560:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7564:	1c f1 02 00 	and	2(r1),	r12	;
    7568:	0c 93       	cmp	#0,	r12	;r3 As==00
    756a:	06 24       	jz	$+14     	;abs 0x7578

0000756c <.Loc.380.1>:
        port->selc = mask;
    756c:	1c 41 04 00 	mov	4(r1),	r12	;
    7570:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7574:	16 00 

00007576 <.Loc.385.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7576:	7f 3d       	jmp	$+768    	;abs 0x7876

00007578 <.L25>:
      port->dir &= ~mask;
      port->ren &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7578:	1c 41 04 00 	mov	4(r1),	r12	;
    757c:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7580:	1c 41 02 00 	mov	2(r1),	r12	;
    7584:	3c e3       	inv	r12		;
    7586:	0d fc       	and	r12,	r13	;
    7588:	1c 41 04 00 	mov	4(r1),	r12	;
    758c:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007590 <.Loc.383.1>:
        port->sel1 &= ~mask;
    7590:	1c 41 04 00 	mov	4(r1),	r12	;
    7594:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7598:	1c 41 02 00 	mov	2(r1),	r12	;
    759c:	3c e3       	inv	r12		;
    759e:	0d fc       	and	r12,	r13	;
    75a0:	1c 41 04 00 	mov	4(r1),	r12	;
    75a4:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000075a8 <.Loc.385.1>:
      }
      break;
    75a8:	66 3d       	jmp	$+718    	;abs 0x7876

000075aa <.L18>:
    case PAL_MODE_UNCONNECTED:
    case PAL_MODE_INPUT_PULLUP:
      port->dir &= ~mask;
    75aa:	1c 41 04 00 	mov	4(r1),	r12	;
    75ae:	1d 4c 04 00 	mov	4(r12),	r13	;
    75b2:	1c 41 02 00 	mov	2(r1),	r12	;
    75b6:	3c e3       	inv	r12		;
    75b8:	0d fc       	and	r12,	r13	;
    75ba:	1c 41 04 00 	mov	4(r1),	r12	;
    75be:	8c 4d 04 00 	mov	r13,	4(r12)	;

000075c2 <.Loc.389.1>:
      port->ren |= mask;
    75c2:	1c 41 04 00 	mov	4(r1),	r12	;
    75c6:	1c 4c 08 00 	mov	8(r12),	r12	;
    75ca:	0d 4c       	mov	r12,	r13	;
    75cc:	1d d1 02 00 	bis	2(r1),	r13	;
    75d0:	1c 41 04 00 	mov	4(r1),	r12	;
    75d4:	8c 4d 08 00 	mov	r13,	8(r12)	;

000075d8 <.Loc.390.1>:
      port->out |= mask;
    75d8:	1c 41 04 00 	mov	4(r1),	r12	;
    75dc:	1c 4c 02 00 	mov	2(r12),	r12	;
    75e0:	0d 4c       	mov	r12,	r13	;
    75e2:	1d d1 02 00 	bis	2(r1),	r13	;
    75e6:	1c 41 04 00 	mov	4(r1),	r12	;
    75ea:	8c 4d 02 00 	mov	r13,	2(r12)	;

000075ee <.Loc.391.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    75ee:	1c 41 04 00 	mov	4(r1),	r12	;
    75f2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    75f6:	1c f1 02 00 	and	2(r1),	r12	;
    75fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    75fc:	0e 24       	jz	$+30     	;abs 0x761a

000075fe <.Loc.391.1>:
    75fe:	1c 41 04 00 	mov	4(r1),	r12	;
    7602:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7606:	1c f1 02 00 	and	2(r1),	r12	;
    760a:	0c 93       	cmp	#0,	r12	;r3 As==00
    760c:	06 24       	jz	$+14     	;abs 0x761a

0000760e <.Loc.392.1>:
        port->selc = mask;
    760e:	1c 41 04 00 	mov	4(r1),	r12	;
    7612:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7616:	16 00 

00007618 <.Loc.397.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7618:	2e 3d       	jmp	$+606    	;abs 0x7876

0000761a <.L27>:
      port->ren |= mask;
      port->out |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    761a:	1c 41 04 00 	mov	4(r1),	r12	;
    761e:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7622:	1c 41 02 00 	mov	2(r1),	r12	;
    7626:	3c e3       	inv	r12		;
    7628:	0d fc       	and	r12,	r13	;
    762a:	1c 41 04 00 	mov	4(r1),	r12	;
    762e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007632 <.Loc.395.1>:
        port->sel1 &= ~mask;
    7632:	1c 41 04 00 	mov	4(r1),	r12	;
    7636:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    763a:	1c 41 02 00 	mov	2(r1),	r12	;
    763e:	3c e3       	inv	r12		;
    7640:	0d fc       	and	r12,	r13	;
    7642:	1c 41 04 00 	mov	4(r1),	r12	;
    7646:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000764a <.Loc.397.1>:
      }
      break;
    764a:	15 3d       	jmp	$+556    	;abs 0x7876

0000764c <.L16>:
    case PAL_MODE_INPUT_PULLDOWN:
      port->dir &= ~mask;
    764c:	1c 41 04 00 	mov	4(r1),	r12	;
    7650:	1d 4c 04 00 	mov	4(r12),	r13	;
    7654:	1c 41 02 00 	mov	2(r1),	r12	;
    7658:	3c e3       	inv	r12		;
    765a:	0d fc       	and	r12,	r13	;
    765c:	1c 41 04 00 	mov	4(r1),	r12	;
    7660:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007664 <.Loc.400.1>:
      port->ren |= mask;
    7664:	1c 41 04 00 	mov	4(r1),	r12	;
    7668:	1c 4c 08 00 	mov	8(r12),	r12	;
    766c:	0d 4c       	mov	r12,	r13	;
    766e:	1d d1 02 00 	bis	2(r1),	r13	;
    7672:	1c 41 04 00 	mov	4(r1),	r12	;
    7676:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000767a <.Loc.401.1>:
      port->out &= ~mask;
    767a:	1c 41 04 00 	mov	4(r1),	r12	;
    767e:	1d 4c 02 00 	mov	2(r12),	r13	;
    7682:	1c 41 02 00 	mov	2(r1),	r12	;
    7686:	3c e3       	inv	r12		;
    7688:	0d fc       	and	r12,	r13	;
    768a:	1c 41 04 00 	mov	4(r1),	r12	;
    768e:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007692 <.Loc.402.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    7692:	1c 41 04 00 	mov	4(r1),	r12	;
    7696:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    769a:	1c f1 02 00 	and	2(r1),	r12	;
    769e:	0c 93       	cmp	#0,	r12	;r3 As==00
    76a0:	0e 24       	jz	$+30     	;abs 0x76be

000076a2 <.Loc.402.1>:
    76a2:	1c 41 04 00 	mov	4(r1),	r12	;
    76a6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    76aa:	1c f1 02 00 	and	2(r1),	r12	;
    76ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    76b0:	06 24       	jz	$+14     	;abs 0x76be

000076b2 <.Loc.403.1>:
        port->selc = mask;
    76b2:	1c 41 04 00 	mov	4(r1),	r12	;
    76b6:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    76ba:	16 00 

000076bc <.Loc.408.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    76bc:	dc 3c       	jmp	$+442    	;abs 0x7876

000076be <.L29>:
      port->ren |= mask;
      port->out &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    76be:	1c 41 04 00 	mov	4(r1),	r12	;
    76c2:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    76c6:	1c 41 02 00 	mov	2(r1),	r12	;
    76ca:	3c e3       	inv	r12		;
    76cc:	0d fc       	and	r12,	r13	;
    76ce:	1c 41 04 00 	mov	4(r1),	r12	;
    76d2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000076d6 <.Loc.406.1>:
        port->sel1 &= ~mask;
    76d6:	1c 41 04 00 	mov	4(r1),	r12	;
    76da:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    76de:	1c 41 02 00 	mov	2(r1),	r12	;
    76e2:	3c e3       	inv	r12		;
    76e4:	0d fc       	and	r12,	r13	;
    76e6:	1c 41 04 00 	mov	4(r1),	r12	;
    76ea:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000076ee <.Loc.408.1>:
      }
      break;
    76ee:	c3 3c       	jmp	$+392    	;abs 0x7876

000076f0 <.L22>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
    76f0:	1c 41 04 00 	mov	4(r1),	r12	;
    76f4:	1c 4c 04 00 	mov	4(r12),	r12	;
    76f8:	0d 4c       	mov	r12,	r13	;
    76fa:	1d d1 02 00 	bis	2(r1),	r13	;
    76fe:	1c 41 04 00 	mov	4(r1),	r12	;
    7702:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007706 <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    7706:	1c 41 04 00 	mov	4(r1),	r12	;
    770a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    770e:	1c f1 02 00 	and	2(r1),	r12	;
    7712:	0c 93       	cmp	#0,	r12	;r3 As==00
    7714:	0e 24       	jz	$+30     	;abs 0x7732

00007716 <.Loc.411.1>:
    7716:	1c 41 04 00 	mov	4(r1),	r12	;
    771a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    771e:	1c f1 02 00 	and	2(r1),	r12	;
    7722:	0c 93       	cmp	#0,	r12	;r3 As==00
    7724:	06 24       	jz	$+14     	;abs 0x7732

00007726 <.Loc.412.1>:
        port->selc = mask;
    7726:	1c 41 04 00 	mov	4(r1),	r12	;
    772a:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    772e:	16 00 

00007730 <.Loc.417.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7730:	a2 3c       	jmp	$+326    	;abs 0x7876

00007732 <.L31>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7732:	1c 41 04 00 	mov	4(r1),	r12	;
    7736:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    773a:	1c 41 02 00 	mov	2(r1),	r12	;
    773e:	3c e3       	inv	r12		;
    7740:	0d fc       	and	r12,	r13	;
    7742:	1c 41 04 00 	mov	4(r1),	r12	;
    7746:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000774a <.Loc.415.1>:
        port->sel1 &= ~mask;
    774a:	1c 41 04 00 	mov	4(r1),	r12	;
    774e:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7752:	1c 41 02 00 	mov	2(r1),	r12	;
    7756:	3c e3       	inv	r12		;
    7758:	0d fc       	and	r12,	r13	;
    775a:	1c 41 04 00 	mov	4(r1),	r12	;
    775e:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007762 <.Loc.417.1>:
      }
      break;
    7762:	89 3c       	jmp	$+276    	;abs 0x7876

00007764 <.L20>:
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    7764:	1c 41 04 00 	mov	4(r1),	r12	;
    7768:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    776c:	1c f1 02 00 	and	2(r1),	r12	;
    7770:	0c 93       	cmp	#0,	r12	;r3 As==00
    7772:	0e 20       	jnz	$+30     	;abs 0x7790

00007774 <.Loc.419.1>:
    7774:	1c 41 04 00 	mov	4(r1),	r12	;
    7778:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    777c:	1c f1 02 00 	and	2(r1),	r12	;
    7780:	0c 93       	cmp	#0,	r12	;r3 As==00
    7782:	06 24       	jz	$+14     	;abs 0x7790

00007784 <.Loc.420.1>:
        port->selc = mask;
    7784:	1c 41 04 00 	mov	4(r1),	r12	;
    7788:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    778c:	16 00 

0000778e <.Loc.425.1>:
      else {
        port->sel0 |= mask;
        port->sel1 &= ~mask;
      }
      break;
    778e:	73 3c       	jmp	$+232    	;abs 0x7876

00007790 <.L33>:
      break;
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
        port->selc = mask;
      else {
        port->sel0 |= mask;
    7790:	1c 41 04 00 	mov	4(r1),	r12	;
    7794:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7798:	0d 4c       	mov	r12,	r13	;
    779a:	1d d1 02 00 	bis	2(r1),	r13	;
    779e:	1c 41 04 00 	mov	4(r1),	r12	;
    77a2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000077a6 <.Loc.423.1>:
        port->sel1 &= ~mask;
    77a6:	1c 41 04 00 	mov	4(r1),	r12	;
    77aa:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    77ae:	1c 41 02 00 	mov	2(r1),	r12	;
    77b2:	3c e3       	inv	r12		;
    77b4:	0d fc       	and	r12,	r13	;
    77b6:	1c 41 04 00 	mov	4(r1),	r12	;
    77ba:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000077be <.Loc.425.1>:
      }
      break;
    77be:	5b 3c       	jmp	$+184    	;abs 0x7876

000077c0 <.L23>:
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    77c0:	1c 41 04 00 	mov	4(r1),	r12	;
    77c4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    77c8:	1c f1 02 00 	and	2(r1),	r12	;
    77cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    77ce:	0e 24       	jz	$+30     	;abs 0x77ec

000077d0 <.Loc.427.1>:
    77d0:	1c 41 04 00 	mov	4(r1),	r12	;
    77d4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    77d8:	1c f1 02 00 	and	2(r1),	r12	;
    77dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    77de:	06 20       	jnz	$+14     	;abs 0x77ec

000077e0 <.Loc.428.1>:
        port->selc = mask;
    77e0:	1c 41 04 00 	mov	4(r1),	r12	;
    77e4:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    77e8:	16 00 

000077ea <.Loc.433.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 |= mask;
      }
      break;
    77ea:	45 3c       	jmp	$+140    	;abs 0x7876

000077ec <.L35>:
      break;
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    77ec:	1c 41 04 00 	mov	4(r1),	r12	;
    77f0:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    77f4:	1c 41 02 00 	mov	2(r1),	r12	;
    77f8:	3c e3       	inv	r12		;
    77fa:	0d fc       	and	r12,	r13	;
    77fc:	1c 41 04 00 	mov	4(r1),	r12	;
    7800:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007804 <.Loc.431.1>:
        port->sel1 |= mask;
    7804:	1c 41 04 00 	mov	4(r1),	r12	;
    7808:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    780c:	0d 4c       	mov	r12,	r13	;
    780e:	1d d1 02 00 	bis	2(r1),	r13	;
    7812:	1c 41 04 00 	mov	4(r1),	r12	;
    7816:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000781a <.Loc.433.1>:
      }
      break;
    781a:	2d 3c       	jmp	$+92     	;abs 0x7876

0000781c <.L24>:
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    781c:	1c 41 04 00 	mov	4(r1),	r12	;
    7820:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7824:	1c f1 02 00 	and	2(r1),	r12	;
    7828:	0c 93       	cmp	#0,	r12	;r3 As==00
    782a:	0e 20       	jnz	$+30     	;abs 0x7848

0000782c <.Loc.435.1>:
    782c:	1c 41 04 00 	mov	4(r1),	r12	;
    7830:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7834:	1c f1 02 00 	and	2(r1),	r12	;
    7838:	0c 93       	cmp	#0,	r12	;r3 As==00
    783a:	06 20       	jnz	$+14     	;abs 0x7848

0000783c <.Loc.436.1>:
        port->selc = mask;
    783c:	1c 41 04 00 	mov	4(r1),	r12	;
    7840:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7844:	16 00 

00007846 <.Loc.441.1>:
      else {
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
    7846:	16 3c       	jmp	$+46     	;abs 0x7874

00007848 <.L37>:
      break;
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 |= mask;
    7848:	1c 41 04 00 	mov	4(r1),	r12	;
    784c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7850:	0d 4c       	mov	r12,	r13	;
    7852:	1d d1 02 00 	bis	2(r1),	r13	;
    7856:	1c 41 04 00 	mov	4(r1),	r12	;
    785a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000785e <.Loc.439.1>:
        port->sel1 |= mask;
    785e:	1c 41 04 00 	mov	4(r1),	r12	;
    7862:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7866:	0d 4c       	mov	r12,	r13	;
    7868:	1d d1 02 00 	bis	2(r1),	r13	;
    786c:	1c 41 04 00 	mov	4(r1),	r12	;
    7870:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007874 <.L39>:
      }
      break;
    7874:	03 43       	nop			

00007876 <.L15>:
  }
}
    7876:	03 43       	nop			
    7878:	31 50 06 00 	add	#6,	r1	;
    787c:	30 41       	ret			

0000787e <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    787e:	03 43       	nop			
    7880:	30 41       	ret			

00007882 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7882:	03 43       	nop			
    7884:	30 41       	ret			

00007886 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7886:	b0 12 7e 78 	call	#30846		;#0x787e
    788a:	b0 12 bc 5b 	call	#23484		;#0x5bbc

0000788e <.Loc.527.2>:
}
    788e:	03 43       	nop			
    7890:	30 41       	ret			

00007892 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7892:	b0 12 de 5b 	call	#23518		;#0x5bde
    7896:	b0 12 82 78 	call	#30850		;#0x7882

0000789a <.Loc.538.2>:
}
    789a:	03 43       	nop			
    789c:	30 41       	ret			

0000789e <osalSysGetStatusAndLockX>:
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
    789e:	b0 12 fa 5d 	call	#24058		;#0x5dfa

000078a2 <.Loc.556.2>:
}
    78a2:	30 41       	ret			

000078a4 <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
    78a4:	21 83       	decd	r1		;

000078a6 <.LCFI0>:
    78a6:	81 4c 00 00 	mov	r12,	0(r1)	;

000078aa <.Loc.569.2>:

  chSysRestoreStatusX(sts);
    78aa:	2c 41       	mov	@r1,	r12	;
    78ac:	b0 12 36 5e 	call	#24118		;#0x5e36

000078b0 <.Loc.570.2>:
}
    78b0:	03 43       	nop			
    78b2:	21 53       	incd	r1		;
    78b4:	30 41       	ret			

000078b6 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    78b6:	21 83       	decd	r1		;

000078b8 <.LCFI1>:
    78b8:	81 4c 00 00 	mov	r12,	0(r1)	;

000078bc <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    78bc:	2c 41       	mov	@r1,	r12	;
    78be:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000078c2 <.Loc.768.2>:
}
    78c2:	03 43       	nop			
    78c4:	21 53       	incd	r1		;
    78c6:	30 41       	ret			

000078c8 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    78c8:	0a 15       	pushm	#1,	r10	;16-bit words

000078ca <.LCFI3>:
    78ca:	21 82       	sub	#4,	r1	;r2 As==10

000078cc <.LCFI4>:
    78cc:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    78d0:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

000078d4 <.Loc.63.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    78d4:	5c 41 01 00 	mov.b	1(r1),	r12	;
    78d8:	12 c3       	clrc			
    78da:	0c 10       	rrc	r12		;
    78dc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    78e0:	0c 5c       	rla	r12		;
    78e2:	0d 4c       	mov	r12,	r13	;
    78e4:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    78e8:	81 4d 02 00 	mov	r13,	2(r1)	;

000078ec <.Loc.64.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    78ec:	1c 41 02 00 	mov	2(r1),	r12	;
    78f0:	2a 4c       	mov	@r12,	r10	;
    78f2:	5c 41 01 00 	mov.b	1(r1),	r12	;
    78f6:	5c f3       	and.b	#1,	r12	;r3 As==01
    78f8:	0d 4c       	mov	r12,	r13	;
    78fa:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    78fe:	3c 40 00 ff 	mov	#65280,	r12	;#0xff00
    7902:	b0 12 e4 a3 	call	#41956		;#0xa3e4
    7906:	0d 4a       	mov	r10,	r13	;
    7908:	0d fc       	and	r12,	r13	;
    790a:	1c 41 02 00 	mov	2(r1),	r12	;
    790e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007912 <.Loc.65.3>:
  *ctl |= trigger << (8 * (index % 2));
    7912:	1c 41 02 00 	mov	2(r1),	r12	;
    7916:	2a 4c       	mov	@r12,	r10	;
    7918:	6c 41       	mov.b	@r1,	r12	;
    791a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    791e:	5d f3       	and.b	#1,	r13	;r3 As==01
    7920:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7924:	b0 12 50 a3 	call	#41808		;#0xa350
    7928:	0d 4a       	mov	r10,	r13	;
    792a:	0d dc       	bis	r12,	r13	;
    792c:	1c 41 02 00 	mov	2(r1),	r12	;
    7930:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007934 <.Loc.66.3>:
}
    7934:	03 43       	nop			
    7936:	21 52       	add	#4,	r1	;r2 As==10
    7938:	0a 17       	popm	#1,	r10	;16-bit words
    793a:	30 41       	ret			

0000793c <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    793c:	bf 15       	pushm	#12,	r15	;16-bit words

0000793e <.LCFI6>:
    793e:	21 82       	sub	#4,	r1	;r2 As==10

00007940 <.LCFI7>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    7940:	d2 43 70 51 	mov.b	#1,	&0x5170	;r3 As==01
    7944:	b0 12 02 5c 	call	#23554		;#0x5c02

00007948 <.Loc.87.3>:

  index = (DMAIV >> 1) - 1;
    7948:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    794c:	12 c3       	clrc			
    794e:	0c 10       	rrc	r12		;
    7950:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7954:	4d 4c       	mov.b	r12,	r13	;
    7956:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7958:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

0000795c <.Loc.89.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    795c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    795e:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7962:	1c 28       	jnc	$+58     	;abs 0x799c

00007964 <.LBB2>:
    osalSysLockFromISR();
    7964:	b0 12 86 78 	call	#30854		;#0x7886

00007968 <.Loc.91.3>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7968:	4d 43       	clr.b	r13		;
    796a:	3c 40 0a 52 	mov	#21002,	r12	;#0x520a
    796e:	b0 12 1a 61 	call	#24858		;#0x611a

00007972 <.Loc.92.3>:
    osalSysUnlockFromISR();
    7972:	b0 12 92 78 	call	#30866		;#0x7892

00007976 <.Loc.94.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    7976:	5c 41 03 00 	mov.b	3(r1),	r12	;
    797a:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    797e:	0d 4c       	mov	r12,	r13	;
    7980:	3d 50 fe 51 	add	#20990,	r13	;#0x51fe
    7984:	81 4d 00 00 	mov	r13,	0(r1)	;

00007988 <.Loc.97.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    7988:	2c 41       	mov	@r1,	r12	;
    798a:	2c 4c       	mov	@r12,	r12	;
    798c:	0c 93       	cmp	#0,	r12	;r3 As==00
    798e:	06 24       	jz	$+14     	;abs 0x799c

00007990 <.Loc.98.3>:
      cb->callback(cb->args);
    7990:	2c 41       	mov	@r1,	r12	;
    7992:	2d 4c       	mov	@r12,	r13	;
    7994:	2c 41       	mov	@r1,	r12	;
    7996:	1c 4c 02 00 	mov	2(r12),	r12	;
    799a:	8d 12       	call	r13		;

0000799c <.L14>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    799c:	b0 12 30 5c 	call	#23600		;#0x5c30
    79a0:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    79a4:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    79a8:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    79ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    79b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    79b2:	02 24       	jz	$+6      	;abs 0x79b8

000079b4 <.Loc.102.3>:
    79b4:	b0 12 cc 5e 	call	#24268		;#0x5ecc

000079b8 <.L15>:
    79b8:	b0 12 9a 5b 	call	#23450		;#0x5b9a

000079bc <.Loc.103.3>:
}
    79bc:	03 43       	nop			
    79be:	21 52       	add	#4,	r1	;r2 As==10
    79c0:	b4 17       	popm	#12,	r15	;16-bit words
    79c2:	00 13       	reti			

000079c4 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    79c4:	3c 40 0a 52 	mov	#21002,	r12	;#0x520a
    79c8:	b0 12 b6 78 	call	#30902		;#0x78b6

000079cc <.Loc.116.3>:
}
    79cc:	03 43       	nop			
    79ce:	30 41       	ret			

000079d0 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
bool dmaAcquireI(msp430x_dma_ch_t * channel, uint8_t index) {
    79d0:	21 82       	sub	#4,	r1	;r2 As==10

000079d2 <.LCFI9>:
    79d2:	81 4c 02 00 	mov	r12,	2(r1)	;
    79d6:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000079da <.Loc.170.3>:
  
  osalDbgCheckClassI();
    79da:	b0 12 60 5c 	call	#23648		;#0x5c60

000079de <.Loc.174.3>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_channels[index].ctl & DMADT_4) {
    79de:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    79e2:	5c 41 01 00 	mov.b	1(r1),	r12	;
    79e6:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    79ea:	0c 5d       	add	r13,	r12	;
    79ec:	2c 4c       	mov	@r12,	r12	;
    79ee:	3c f0 00 40 	and	#16384,	r12	;#0x4000
    79f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    79f4:	02 24       	jz	$+6      	;abs 0x79fa

000079f6 <.Loc.175.3>:
    return true;
    79f6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    79f8:	46 3c       	jmp	$+142    	;abs 0x7a86

000079fa <.L26>:
  }

  /* Increment the DMA counter */
  queue_length++;
    79fa:	1c 42 0c 52 	mov	&0x520c,r12	;0x520c
    79fe:	1c 53       	inc	r12		;
    7a00:	82 4c 0c 52 	mov	r12,	&0x520c	;

00007a04 <.Loc.181.3>:

  while (dma_channels[index].ctl & DMAEN)
    7a04:	03 43       	nop			

00007a06 <.L28>:
    7a06:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7a0a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a0e:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7a12:	0c 5d       	add	r13,	r12	;
    7a14:	2c 4c       	mov	@r12,	r12	;
    7a16:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7a1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a1c:	f4 23       	jnz	$-22     	;abs 0x7a06

00007a1e <.Loc.185.3>:
    ;

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    7a1e:	4d 43       	clr.b	r13		;
    7a20:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a24:	b0 12 c8 78 	call	#30920		;#0x78c8

00007a28 <.Loc.186.3>:
  dma_channels[index].sz  = 0;
    7a28:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7a2c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a30:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7a34:	0c 5d       	add	r13,	r12	;
    7a36:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007a3a <.Loc.187.3>:
  dma_channels[index].ctl = DMAEN | DMAABORT | DMADT_4;
    7a3a:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7a3e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a42:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7a46:	0c 5d       	add	r13,	r12	;
    7a48:	bc 40 12 40 	mov	#16402,	0(r12)	;#0x4012
    7a4c:	00 00 

00007a4e <.Loc.189.3>:

  channel->registers = dma_channels + index;
    7a4e:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7a52:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a56:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7a5a:	0d 5c       	add	r12,	r13	;
    7a5c:	1c 41 02 00 	mov	2(r1),	r12	;
    7a60:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007a64 <.Loc.190.3>:
  channel->index     = index;
    7a64:	1c 41 02 00 	mov	2(r1),	r12	;
    7a68:	dc 41 01 00 	mov.b	1(r1),	2(r12)	;
    7a6c:	02 00 

00007a6e <.Loc.191.3>:
  channel->cb        = callbacks + index;
    7a6e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a72:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7a76:	0d 4c       	mov	r12,	r13	;
    7a78:	3d 50 fe 51 	add	#20990,	r13	;#0x51fe
    7a7c:	1c 41 02 00 	mov	2(r1),	r12	;
    7a80:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007a84 <.Loc.193.3>:
  
  return false;
    7a84:	4c 43       	clr.b	r12		;

00007a86 <.L27>:
}
    7a86:	21 52       	add	#4,	r1	;r2 As==10
    7a88:	30 41       	ret			

00007a8a <dmaTransfer>:
 * @pre     The channel must have been acquired using @p dmaAcquire().
 *
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 */
void dmaTransfer(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    7a8a:	21 82       	sub	#4,	r1	;r2 As==10

00007a8c <L0>:
    7a8c:	81 4c 02 00 	mov	r12,	2(r1)	;
    7a90:	81 4d 00 00 	mov	r13,	0(r1)	;

00007a94 <.Loc.205.3>:

  dma_trigger_set(channel->index, request->trigger);
    7a94:	1c 41 02 00 	mov	2(r1),	r12	;
    7a98:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    7a9c:	2d 41       	mov	@r1,	r13	;
    7a9e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    7aa2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    7aa6:	b0 12 c8 78 	call	#30920		;#0x78c8

00007aaa <.Loc.208.3>:
  /**(channel->ctl) = request->trigger;*/

  channel->cb->callback = request->callback.callback;
    7aaa:	1c 41 02 00 	mov	2(r1),	r12	;
    7aae:	1c 4c 04 00 	mov	4(r12),	r12	;
    7ab2:	2d 41       	mov	@r1,	r13	;
    7ab4:	1d 4d 0e 00 	mov	14(r13),r13	;0x0000e
    7ab8:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007abc <.Loc.209.3>:
  channel->cb->args     = request->callback.args;
    7abc:	1c 41 02 00 	mov	2(r1),	r12	;
    7ac0:	1c 4c 04 00 	mov	4(r12),	r12	;
    7ac4:	2d 41       	mov	@r1,	r13	;
    7ac6:	1d 4d 10 00 	mov	16(r13),r13	;0x00010
    7aca:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007ace <.Loc.211.3>:

  channel->registers->ctl &= (~DMAEN);
    7ace:	1c 41 02 00 	mov	2(r1),	r12	;
    7ad2:	2c 4c       	mov	@r12,	r12	;
    7ad4:	1d 41 02 00 	mov	2(r1),	r13	;
    7ad8:	2d 4d       	mov	@r13,	r13	;
    7ada:	2d 4d       	mov	@r13,	r13	;
    7adc:	3d f0 ef ff 	and	#65519,	r13	;#0xffef
    7ae0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007ae4 <.Loc.212.3>:
  channel->registers->sa  = (uintptr_t)request->source_addr;
    7ae4:	1c 41 02 00 	mov	2(r1),	r12	;
    7ae8:	2e 4c       	mov	@r12,	r14	;
    7aea:	2c 41       	mov	@r1,	r12	;
    7aec:	2c 4c       	mov	@r12,	r12	;
    7aee:	0d 43       	clr	r13		;
    7af0:	8e 4c 02 00 	mov	r12,	2(r14)	;
    7af4:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007af8 <.Loc.213.3>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    7af8:	1c 41 02 00 	mov	2(r1),	r12	;
    7afc:	2e 4c       	mov	@r12,	r14	;
    7afe:	2c 41       	mov	@r1,	r12	;
    7b00:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b04:	0d 43       	clr	r13		;
    7b06:	8e 4c 06 00 	mov	r12,	6(r14)	;
    7b0a:	8e 4d 08 00 	mov	r13,	8(r14)	;

00007b0e <.Loc.214.3>:
  channel->registers->sz  = request->size;
    7b0e:	1c 41 02 00 	mov	2(r1),	r12	;
    7b12:	2c 4c       	mov	@r12,	r12	;
    7b14:	2d 41       	mov	@r1,	r13	;
    7b16:	1d 4d 04 00 	mov	4(r13),	r13	;
    7b1a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007b1e <.Loc.215.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7b1e:	1c 41 02 00 	mov	2(r1),	r12	;
    7b22:	2c 4c       	mov	@r12,	r12	;
    7b24:	2d 41       	mov	@r1,	r13	;
    7b26:	1e 4d 08 00 	mov	8(r13),	r14	;
    7b2a:	2d 41       	mov	@r1,	r13	;
    7b2c:	1d 4d 06 00 	mov	6(r13),	r13	;
    7b30:	0e dd       	bis	r13,	r14	;

00007b32 <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    7b32:	2d 41       	mov	@r1,	r13	;
    7b34:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a

00007b38 <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7b38:	0d de       	bis	r14,	r13	;

00007b3a <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    7b3a:	3d d0 15 40 	bis	#16405,	r13	;#0x4015

00007b3e <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7b3e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007b42 <.Loc.218.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
                            DMAREQ; /* repeated transfers */
}
    7b42:	03 43       	nop			
    7b44:	21 52       	add	#4,	r1	;r2 As==10
    7b46:	30 41       	ret			

00007b48 <dmaRelease>:
 *          pool. Trying to release an unallocated channel is an illegal
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquire().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaRelease(msp430x_dma_ch_t * channel) {
    7b48:	21 82       	sub	#4,	r1	;r2 As==10

00007b4a <.LCFI11>:
    7b4a:	81 4c 00 00 	mov	r12,	0(r1)	;

00007b4e <.Loc.232.3>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
    7b4e:	b0 12 9e 78 	call	#30878		;#0x789e
    7b52:	81 4c 02 00 	mov	r12,	2(r1)	;

00007b56 <.Loc.236.3>:
  osalDbgCheck(channel != NULL);

  /* Release the channel in an idle mode */
  channel->registers->ctl = DMAABORT;
    7b56:	2c 41       	mov	@r1,	r12	;
    7b58:	2c 4c       	mov	@r12,	r12	;
    7b5a:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00007b5e <.Loc.239.3>:

  /* release the DMA counter */
  osalThreadDequeueAllI(&dma_queue, MSG_RESET);
    7b5e:	3d 40 fe ff 	mov	#65534,	r13	;#0xfffe
    7b62:	3c 40 0a 52 	mov	#21002,	r12	;#0x520a
    7b66:	b0 12 72 61 	call	#24946		;#0x6172

00007b6a <.Loc.240.3>:
  queue_length = 0;
    7b6a:	82 43 0c 52 	mov	#0,	&0x520c	;r3 As==00

00007b6e <.Loc.241.3>:
  osalSysRestoreStatusX(sts);
    7b6e:	1c 41 02 00 	mov	2(r1),	r12	;
    7b72:	b0 12 a4 78 	call	#30884		;#0x78a4

00007b76 <.Loc.242.3>:
}
    7b76:	03 43       	nop			
    7b78:	21 52       	add	#4,	r1	;r2 As==10
    7b7a:	30 41       	ret			

00007b7c <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7b7c:	03 43       	nop			
    7b7e:	30 41       	ret			

00007b80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7b80:	03 43       	nop			
    7b82:	30 41       	ret			

00007b84 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7b84:	b0 12 7c 7b 	call	#31612		;#0x7b7c
    7b88:	b0 12 bc 5b 	call	#23484		;#0x5bbc

00007b8c <.Loc.527.2>:
}
    7b8c:	03 43       	nop			
    7b8e:	30 41       	ret			

00007b90 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7b90:	b0 12 de 5b 	call	#23518		;#0x5bde
    7b94:	b0 12 80 7b 	call	#31616		;#0x7b80

00007b98 <.Loc.538.2>:
}
    7b98:	03 43       	nop			
    7b9a:	30 41       	ret			

00007b9c <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7b9c:	21 82       	sub	#4,	r1	;r2 As==10

00007b9e <.LCFI0>:
    7b9e:	81 4c 02 00 	mov	r12,	2(r1)	;
    7ba2:	81 4d 00 00 	mov	r13,	0(r1)	;

00007ba6 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7ba6:	2d 41       	mov	@r1,	r13	;
    7ba8:	1c 41 02 00 	mov	2(r1),	r12	;
    7bac:	b0 12 6c 5f 	call	#24428		;#0x5f6c

00007bb0 <.Loc.740.2>:
}
    7bb0:	03 43       	nop			
    7bb2:	21 52       	add	#4,	r1	;r2 As==10
    7bb4:	30 41       	ret			

00007bb6 <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * spip) {
    7bb6:	21 83       	decd	r1		;

00007bb8 <.LCFI2>:
    7bb8:	81 4c 00 00 	mov	r12,	0(r1)	;

00007bbc <.Loc.136.3>:

  /* So that future transfers will actually work */
  *(((SPIDriver *)spip)->ifg) &= ~(UCTXIFG);
    7bbc:	2c 41       	mov	@r1,	r12	;
    7bbe:	1c 4c 08 00 	mov	8(r12),	r12	;
    7bc2:	2d 41       	mov	@r1,	r13	;
    7bc4:	1d 4d 08 00 	mov	8(r13),	r13	;
    7bc8:	2d 4d       	mov	@r13,	r13	;
    7bca:	2d c3       	bic	#2,	r13	;r3 As==10
    7bcc:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007bd0 <.Loc.140.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code((SPIDriver *)spip);
    7bd0:	2c 41       	mov	@r1,	r12	;
    7bd2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7bd6:	2c 4c       	mov	@r12,	r12	;
    7bd8:	0c 93       	cmp	#0,	r12	;r3 As==00
    7bda:	11 24       	jz	$+36     	;abs 0x7bfe

00007bdc <.Loc.140.3>:
    7bdc:	2c 41       	mov	@r1,	r12	;
    7bde:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7be2:	2c 41       	mov	@r1,	r12	;
    7be4:	1c 4c 02 00 	mov	2(r12),	r12	;
    7be8:	2d 4c       	mov	@r12,	r13	;
    7bea:	2c 41       	mov	@r1,	r12	;
    7bec:	8d 12       	call	r13		;
    7bee:	2c 41       	mov	@r1,	r12	;
    7bf0:	6c 4c       	mov.b	@r12,	r12	;
    7bf2:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7bf4:	07 20       	jnz	$+16     	;abs 0x7c04

00007bf6 <.Loc.140.3>:
    7bf6:	2c 41       	mov	@r1,	r12	;
    7bf8:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7bfc:	03 3c       	jmp	$+8      	;abs 0x7c04

00007bfe <.L8>:
    7bfe:	2c 41       	mov	@r1,	r12	;
    7c00:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007c04 <.L10>:
    7c04:	b0 12 84 7b 	call	#31620		;#0x7b84
    7c08:	2c 41       	mov	@r1,	r12	;
    7c0a:	2c 52       	add	#4,	r12	;r2 As==10
    7c0c:	4d 43       	clr.b	r13		;
    7c0e:	b0 12 9c 7b 	call	#31644		;#0x7b9c
    7c12:	b0 12 90 7b 	call	#31632		;#0x7b90

00007c16 <.Loc.141.3>:
}
    7c16:	03 43       	nop			
    7c18:	21 53       	incd	r1		;
    7c1a:	30 41       	ret			

00007c1c <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    7c1c:	3c 40 0e 52 	Address 0x0000000000007c1e is out of bounds.
mov	#65535,	r12	;#0xffff

00007c1e <L0>:
    7c1e:	0e 52       	add	r2,	r14	;
    7c20:	b0 12 d4 6b 	call	#27604		;#0x6bd4

00007c24 <.Loc.182.3>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    7c24:	b2 40 e0 05 	mov	#1504,	&0x5214	;#0x05e0
    7c28:	14 52 

00007c2a <.Loc.183.3>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    7c2a:	b2 40 fc 05 	mov	#1532,	&0x5216	;#0x05fc
    7c2e:	16 52 

00007c30 <.Loc.184.3>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    7c30:	b2 40 11 00 	mov	#17,	&0x5224	;#0x0011
    7c34:	24 52 

00007c36 <.Loc.185.3>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    7c36:	b2 40 10 00 	mov	#16,	&0x5236	;#0x0010
    7c3a:	36 52 

00007c3c <.Loc.186.3>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    7c3c:	1c 42 14 52 	mov	&0x5214,r12	;0x5214
    7c40:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7c44:	82 4c 1a 52 	mov	r12,	&0x521a	;

00007c48 <.Loc.187.3>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    7c48:	1c 42 14 52 	mov	&0x5214,r12	;0x5214
    7c4c:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7c50:	82 4c 2a 52 	mov	r12,	&0x522a	;

00007c54 <.Loc.188.3>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7c54:	b2 40 c0 00 	mov	#192,	&0x5220	;#0x00c0
    7c58:	20 52 

00007c5a <.Loc.189.3>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7c5a:	b2 40 c0 00 	mov	#192,	&0x5232	;#0x00c0
    7c5e:	32 52 

00007c60 <.Loc.190.3>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7c60:	82 43 22 52 	mov	#0,	&0x5222	;r3 As==00

00007c64 <.Loc.191.3>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7c64:	82 43 34 52 	mov	#0,	&0x5234	;r3 As==00

00007c68 <.Loc.192.3>:
  SPIDA1.tx_req.callback.callback = NULL;
    7c68:	82 43 26 52 	mov	#0,	&0x5226	;r3 As==00

00007c6c <.Loc.193.3>:
  SPIDA1.tx_req.callback.args     = NULL;
    7c6c:	82 43 28 52 	mov	#0,	&0x5228	;r3 As==00

00007c70 <.Loc.194.3>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    7c70:	b2 40 b6 7b 	mov	#31670,	&0x5238	;#0x7bb6
    7c74:	38 52 

00007c76 <.Loc.195.3>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    7c76:	b2 40 0e 52 	mov	#21006,	&0x523a	;#0x520e
    7c7a:	3a 52 

00007c7c <.Loc.238.3>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    7c7c:	3c 40 3c 52 	mov	#21052,	r12	;#0x523c
    7c80:	b0 12 d4 6b 	call	#27604		;#0x6bd4

00007c84 <.Loc.239.3>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    7c84:	b2 40 40 06 	mov	#1600,	&0x5242	;#0x0640
    7c88:	42 52 

00007c8a <.Loc.240.3>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    7c8a:	b2 40 6c 06 	mov	#1644,	&0x5244	;#0x066c
    7c8e:	44 52 

00007c90 <.Loc.241.3>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    7c90:	b2 40 13 00 	mov	#19,	&0x5252	;#0x0013
    7c94:	52 52 

00007c96 <.Loc.242.3>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    7c96:	b2 40 12 00 	mov	#18,	&0x5264	;#0x0012
    7c9a:	64 52 

00007c9c <.Loc.243.3>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    7c9c:	1c 42 42 52 	mov	&0x5242,r12	;0x5242
    7ca0:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7ca4:	82 4c 48 52 	mov	r12,	&0x5248	;

00007ca8 <.Loc.244.3>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    7ca8:	1c 42 42 52 	mov	&0x5242,r12	;0x5242
    7cac:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7cb0:	82 4c 58 52 	mov	r12,	&0x5258	;

00007cb4 <.Loc.245.3>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7cb4:	b2 40 c0 00 	mov	#192,	&0x524e	;#0x00c0
    7cb8:	4e 52 

00007cba <.Loc.246.3>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7cba:	b2 40 c0 00 	mov	#192,	&0x5260	;#0x00c0
    7cbe:	60 52 

00007cc0 <.Loc.247.3>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7cc0:	82 43 50 52 	mov	#0,	&0x5250	;r3 As==00

00007cc4 <.Loc.248.3>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7cc4:	82 43 62 52 	mov	#0,	&0x5262	;r3 As==00

00007cc8 <.Loc.249.3>:
  SPIDB0.tx_req.callback.callback = NULL;
    7cc8:	82 43 54 52 	mov	#0,	&0x5254	;r3 As==00

00007ccc <.Loc.250.3>:
  SPIDB0.tx_req.callback.args     = NULL;
    7ccc:	82 43 56 52 	mov	#0,	&0x5256	;r3 As==00

00007cd0 <.Loc.251.3>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    7cd0:	b2 40 b6 7b 	mov	#31670,	&0x5266	;#0x7bb6
    7cd4:	66 52 

00007cd6 <.Loc.252.3>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    7cd6:	b2 40 3c 52 	mov	#21052,	&0x5268	;#0x523c
    7cda:	68 52 

00007cdc <.Loc.311.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    7cdc:	03 43       	nop			
    7cde:	30 41       	ret			

00007ce0 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver * spip) {
    7ce0:	31 80 06 00 	sub	#6,	r1	;

00007ce4 <.LCFI3>:
    7ce4:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ce8 <.Loc.337.3>:
      b = dmaAcquireI(&(spip->dmarx), spip->config->dmarx_index);
      osalDbgAssert(!b, "stream already allocated");
    }
#endif /* MSP430X_SPI_EXCLUSIVE_DMA */
  }
  uint16_t brw = 0;
    7ce8:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00007cec <.Loc.338.3>:
  uint8_t ssel = 0;
    7cec:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00007cf0 <.Loc.346.3>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA0_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIA1
  if (spip == &SPIDA1) {
    7cf0:	b1 90 0e 52 	cmp	#21006,	0(r1)	;#0x520e
    7cf4:	00 00 
    7cf6:	14 20       	jnz	$+42     	;abs 0x7d20

00007cf8 <.Loc.347.3>:
    brw  = MSP430X_SPIA1_CLK_FREQ / spip->config->bit_rate;
    7cf8:	2c 41       	mov	@r1,	r12	;
    7cfa:	1c 4c 02 00 	mov	2(r12),	r12	;
    7cfe:	1d 4c 06 00 	mov	6(r12),	r13	;
    7d02:	1c 4c 04 00 	mov	4(r12),	r12	;
    7d06:	0e 4c       	mov	r12,	r14	;
    7d08:	0f 4d       	mov	r13,	r15	;
    7d0a:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    7d0e:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    7d12:	b0 12 1e a3 	call	#41758		;#0xa31e
    7d16:	81 4c 04 00 	mov	r12,	4(r1)	;

00007d1a <.Loc.348.3>:
    ssel = MSP430X_SPIA1_UCSSEL;
    7d1a:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    7d1e:	03 00 

00007d20 <.L13>:
    brw  = MSP430X_SPIA3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA3_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIB0
  if (spip == &SPIDB0) {
    7d20:	b1 90 3c 52 	cmp	#21052,	0(r1)	;#0x523c
    7d24:	00 00 
    7d26:	14 20       	jnz	$+42     	;abs 0x7d50

00007d28 <.Loc.365.3>:
    brw  = MSP430X_SPIB0_CLK_FREQ / spip->config->bit_rate;
    7d28:	2c 41       	mov	@r1,	r12	;
    7d2a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7d2e:	1d 4c 06 00 	mov	6(r12),	r13	;
    7d32:	1c 4c 04 00 	mov	4(r12),	r12	;
    7d36:	0e 4c       	mov	r12,	r14	;
    7d38:	0f 4d       	mov	r13,	r15	;
    7d3a:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    7d3e:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    7d42:	b0 12 1e a3 	call	#41758		;#0xa31e
    7d46:	81 4c 04 00 	mov	r12,	4(r1)	;

00007d4a <.Loc.366.3>:
    ssel = MSP430X_SPIB0_UCSSEL;
    7d4a:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    7d4e:	03 00 

00007d50 <.L14>:
    brw  = MSP430X_SPIB3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIB3_UCSSEL;
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
    7d50:	2c 41       	mov	@r1,	r12	;
    7d52:	1c 4c 06 00 	mov	6(r12),	r12	;
    7d56:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00007d5a <.Loc.389.3>:
  spip->regs->brw   = brw;
    7d5a:	2c 41       	mov	@r1,	r12	;
    7d5c:	1c 4c 06 00 	mov	6(r12),	r12	;
    7d60:	9c 41 04 00 	mov	4(r1),	6(r12)	;
    7d64:	06 00 

00007d66 <.Loc.390.3>:
  spip->regs->ctlw0 =
    7d66:	2c 41       	mov	@r1,	r12	;
    7d68:	1d 4c 06 00 	mov	6(r12),	r13	;

00007d6c <.Loc.391.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7d6c:	2c 41       	mov	@r1,	r12	;
    7d6e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7d72:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7d76:	6c e3       	xor.b	#2,	r12	;r3 As==10
    7d78:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7d7c:	0e 4c       	mov	r12,	r14	;
    7d7e:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    7d82:	2c 41       	mov	@r1,	r12	;
    7d84:	1c 4c 02 00 	mov	2(r12),	r12	;
    7d88:	5c 4c 08 00 	mov.b	8(r12),	r12	;
    7d8c:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    7d90:	0e dc       	bis	r12,	r14	;

00007d92 <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7d92:	2c 41       	mov	@r1,	r12	;
    7d94:	1c 4c 02 00 	mov	2(r12),	r12	;
    7d98:	5c 4c 09 00 	mov.b	9(r12),	r12	;
    7d9c:	4b 18 0c 5c 	rpt #12 { rlax.w	r12		;

00007da0 <.Loc.391.3>:
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7da0:	0c de       	bis	r14,	r12	;

00007da2 <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7da2:	0e 4c       	mov	r12,	r14	;
    7da4:	3e d0 00 08 	bis	#2048,	r14	;#0x0800

00007da8 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    7da8:	2c 41       	mov	@r1,	r12	;
    7daa:	1c 4c 02 00 	mov	2(r12),	r12	;
    7dae:	1c 4c 02 00 	mov	2(r12),	r12	;
    7db2:	0c 93       	cmp	#0,	r12	;r3 As==00
    7db4:	02 24       	jz	$+6      	;abs 0x7dba

00007db6 <.Loc.393.3>:
    7db6:	4c 43       	clr.b	r12		;
    7db8:	02 3c       	jmp	$+6      	;abs 0x7dbe

00007dba <.L15>:
    7dba:	3c 40 00 04 	mov	#1024,	r12	;#0x0400

00007dbe <.L16>:
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
    7dbe:	0c de       	bis	r14,	r12	;

00007dc0 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    7dc0:	0e 4c       	mov	r12,	r14	;
    7dc2:	3e d0 00 01 	bis	#256,	r14	;#0x0100
    7dc6:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7dca:	0c de       	bis	r14,	r12	;
    7dcc:	2c d3       	bis	#2,	r12	;r3 As==10

00007dce <.Loc.390.3>:
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
    7dce:	8d 4c 00 00 	mov	r12,	0(r13)	;

00007dd2 <.Loc.394.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
  *(spip->ifg) = 0;
    7dd2:	2c 41       	mov	@r1,	r12	;
    7dd4:	1c 4c 08 00 	mov	8(r12),	r12	;
    7dd8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00007ddc <.Loc.395.3>:
  spi_lld_unselect(spip);
    7ddc:	2c 41       	mov	@r1,	r12	;
    7dde:	b0 12 4a 7e 	call	#32330		;#0x7e4a

00007de2 <.Loc.396.3>:
}
    7de2:	03 43       	nop			
    7de4:	31 50 06 00 	add	#6,	r1	;
    7de8:	30 41       	ret			

00007dea <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    7dea:	1a 15       	pushm	#2,	r10	;16-bit words

00007dec <L0>:
    7dec:	21 83       	decd	r1		;

00007dee <.LCFI6>:
    7dee:	81 4c 00 00 	mov	r12,	0(r1)	;

00007df2 <.Loc.430.3>:

  if (spip->config->ss_line) {
    7df2:	2c 41       	mov	@r1,	r12	;
    7df4:	1c 4c 02 00 	mov	2(r12),	r12	;
    7df8:	1c 4c 02 00 	mov	2(r12),	r12	;
    7dfc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7dfe:	21 24       	jz	$+68     	;abs 0x7e42

00007e00 <.Loc.431.3>:
    palClearLine(spip->config->ss_line);
    7e00:	2c 41       	mov	@r1,	r12	;
    7e02:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e06:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e0a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7e0e:	0a 4c       	mov	r12,	r10	;
    7e10:	2c 41       	mov	@r1,	r12	;
    7e12:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e16:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e1a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7e1e:	19 4c 02 00 	mov	2(r12),	r9	;
    7e22:	2c 41       	mov	@r1,	r12	;
    7e24:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e28:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e2c:	0d 4c       	mov	r12,	r13	;
    7e2e:	5d 03       	rrum	#1,	r13	;
    7e30:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    7e34:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7e36:	b0 12 50 a3 	call	#41808		;#0xa350
    7e3a:	3c e3       	inv	r12		;
    7e3c:	0c f9       	and	r9,	r12	;
    7e3e:	8a 4c 02 00 	mov	r12,	2(r10)	;

00007e42 <.L22>:
  }
}
    7e42:	03 43       	nop			
    7e44:	21 53       	incd	r1		;
    7e46:	19 17       	popm	#2,	r10	;16-bit words
    7e48:	30 41       	ret			

00007e4a <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    7e4a:	1a 15       	pushm	#2,	r10	;16-bit words

00007e4c <.LCFI7>:
    7e4c:	21 83       	decd	r1		;

00007e4e <.LCFI8>:
    7e4e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007e52 <.Loc.445.3>:

  if (spip->config->ss_line) {
    7e52:	2c 41       	mov	@r1,	r12	;
    7e54:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e58:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e5c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e5e:	20 24       	jz	$+66     	;abs 0x7ea0

00007e60 <.Loc.446.3>:
    palSetLine(spip->config->ss_line);
    7e60:	2c 41       	mov	@r1,	r12	;
    7e62:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e66:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e6a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7e6e:	0a 4c       	mov	r12,	r10	;
    7e70:	2c 41       	mov	@r1,	r12	;
    7e72:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e76:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e7a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7e7e:	19 4c 02 00 	mov	2(r12),	r9	;
    7e82:	2c 41       	mov	@r1,	r12	;
    7e84:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e88:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e8c:	0d 4c       	mov	r12,	r13	;
    7e8e:	5d 03       	rrum	#1,	r13	;
    7e90:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    7e94:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7e96:	b0 12 50 a3 	call	#41808		;#0xa350
    7e9a:	0c d9       	bis	r9,	r12	;
    7e9c:	8a 4c 02 00 	mov	r12,	2(r10)	;

00007ea0 <.L25>:
  }
}
    7ea0:	03 43       	nop			
    7ea2:	21 53       	incd	r1		;
    7ea4:	19 17       	popm	#2,	r10	;16-bit words
    7ea6:	30 41       	ret			

00007ea8 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {
    7ea8:	21 82       	sub	#4,	r1	;r2 As==10

00007eaa <.LCFI13>:
    7eaa:	81 4c 02 00 	mov	r12,	2(r1)	;
    7eae:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007eb2 <.Loc.571.3>:

  spip->regs->txbuf = frame;
    7eb2:	1c 41 02 00 	mov	2(r1),	r12	;
    7eb6:	1c 4c 06 00 	mov	6(r12),	r12	;
    7eba:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7ebe:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00007ec2 <.Loc.572.3>:
  while (!(*(spip->ifg) & UCRXIFG))
    7ec2:	03 43       	nop			

00007ec4 <.L31>:
    7ec4:	1c 41 02 00 	mov	2(r1),	r12	;
    7ec8:	1c 4c 08 00 	mov	8(r12),	r12	;
    7ecc:	2c 4c       	mov	@r12,	r12	;
    7ece:	5c f3       	and.b	#1,	r12	;r3 As==01
    7ed0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ed2:	f8 27       	jz	$-14     	;abs 0x7ec4

00007ed4 <.Loc.574.3>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    7ed4:	1c 41 02 00 	mov	2(r1),	r12	;
    7ed8:	1c 4c 08 00 	mov	8(r12),	r12	;
    7edc:	1d 41 02 00 	mov	2(r1),	r13	;
    7ee0:	1d 4d 08 00 	mov	8(r13),	r13	;
    7ee4:	2d 4d       	mov	@r13,	r13	;
    7ee6:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    7eea:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007eee <.Loc.575.3>:
  return spip->regs->rxbuf;
    7eee:	1c 41 02 00 	mov	2(r1),	r12	;
    7ef2:	1c 4c 06 00 	mov	6(r12),	r12	;
    7ef6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7efa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00007efe <.Loc.576.3>:
}
    7efe:	21 52       	add	#4,	r1	;r2 As==10
    7f00:	30 41       	ret			

00007f02 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7f02:	03 43       	nop			
    7f04:	30 41       	ret			

00007f06 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7f06:	03 43       	nop			
    7f08:	30 41       	ret			

00007f0a <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7f0a:	b0 12 02 7f 	call	#32514		;#0x7f02
    7f0e:	b0 12 bc 5b 	call	#23484		;#0x5bbc

00007f12 <.Loc.527.2>:
}
    7f12:	03 43       	nop			
    7f14:	30 41       	ret			

00007f16 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7f16:	b0 12 de 5b 	call	#23518		;#0x5bde
    7f1a:	b0 12 06 7f 	call	#32518		;#0x7f06

00007f1e <.Loc.538.2>:
}
    7f1e:	03 43       	nop			
    7f20:	30 41       	ret			

00007f22 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7f22:	21 82       	sub	#4,	r1	;r2 As==10

00007f24 <.LCFI0>:
    7f24:	81 4c 02 00 	mov	r12,	2(r1)	;
    7f28:	81 4d 00 00 	mov	r13,	0(r1)	;

00007f2c <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7f2c:	2d 41       	mov	@r1,	r13	;
    7f2e:	1c 41 02 00 	mov	2(r1),	r12	;
    7f32:	b0 12 6c 5f 	call	#24428		;#0x5f6c

00007f36 <.Loc.740.2>:
}
    7f36:	03 43       	nop			
    7f38:	21 52       	add	#4,	r1	;r2 As==10
    7f3a:	30 41       	ret			

00007f3c <restart_dma>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void restart_dma(ADCDriver * adcp) {
    7f3c:	21 83       	decd	r1		;

00007f3e <.LCFI1>:
    7f3e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f42 <.Loc.55.3>:
  /* TODO timeouts? */
  /* Restart DMA transfer */
  if (adcp->dma.registers == NULL) {
    7f42:	2c 41       	mov	@r1,	r12	;
    7f44:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    7f48:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f4a:	15 20       	jnz	$+44     	;abs 0x7f76

00007f4c <.Loc.57.3>:
    /* Acquire a DMA stream because dmaTransfer can be called from ISRs */
    osalSysLockFromISR();
    7f4c:	b0 12 0a 7f 	call	#32522		;#0x7f0a

00007f50 <.Loc.58.3>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    7f50:	2c 41       	mov	@r1,	r12	;
    7f52:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7f56:	2d 41       	mov	@r1,	r13	;
    7f58:	5d 4d 28 00 	mov.b	40(r13),r13	;0x00028
    7f5c:	b0 12 d0 79 	call	#31184		;#0x79d0

00007f60 <.Loc.59.3>:
    osalSysUnlockFromISR();
    7f60:	b0 12 16 7f 	call	#32534		;#0x7f16

00007f64 <.Loc.60.3>:
    dmaTransfer(&(adcp->dma), &(adcp->req));
    7f64:	2c 41       	mov	@r1,	r12	;
    7f66:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7f6a:	2d 41       	mov	@r1,	r13	;
    7f6c:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7f70:	b0 12 8a 7a 	call	#31370		;#0x7a8a

00007f74 <.Loc.65.3>:
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
}
    7f74:	08 3c       	jmp	$+18     	;abs 0x7f86

00007f76 <.L7>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    osalSysUnlockFromISR();
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
    7f76:	2c 41       	mov	@r1,	r12	;
    7f78:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7f7c:	2d 41       	mov	@r1,	r13	;
    7f7e:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7f82:	b0 12 8a 7a 	call	#31370		;#0x7a8a

00007f86 <.L9>:
  }
}
    7f86:	03 43       	nop			
    7f88:	21 53       	incd	r1		;
    7f8a:	30 41       	ret			

00007f8c <dma_callback>:

static void dma_callback(void * args) {
    7f8c:	0a 15       	pushm	#1,	r10	;16-bit words

00007f8e <L0>:
    7f8e:	31 82       	sub	#8,	r1	;r2 As==11

00007f90 <.LCFI3>:
    7f90:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f94 <.Loc.68.3>:
  ADCDriver * adcp = (ADCDriver *)args;
    7f94:	a1 41 06 00 	mov	@r1,	6(r1)	;

00007f98 <.Loc.70.3>:

  if (adcp->grpp == NULL)
    7f98:	1c 41 06 00 	mov	6(r1),	r12	;
    7f9c:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fa0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fa2:	1f 25       	jz	$+576    	;abs 0x81e2

00007fa4 <.Loc.73.3>:
    return;

  adcp->count++;
    7fa4:	1c 41 06 00 	mov	6(r1),	r12	;
    7fa8:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7fac:	5c 53       	inc.b	r12		;
    7fae:	4d 4c       	mov.b	r12,	r13	;
    7fb0:	1c 41 06 00 	mov	6(r1),	r12	;
    7fb4:	cc 4d 24 00 	mov.b	r13,	36(r12)	; 0x0024

00007fb8 <.Loc.75.3>:

  if (adcp->count == adcp->depth / 2) {
    7fb8:	1c 41 06 00 	mov	6(r1),	r12	;
    7fbc:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7fc0:	0d 4c       	mov	r12,	r13	;
    7fc2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fc6:	1c 4c 06 00 	mov	6(r12),	r12	;
    7fca:	12 c3       	clrc			
    7fcc:	0c 10       	rrc	r12		;
    7fce:	0d 9c       	cmp	r12,	r13	;
    7fd0:	1d 20       	jnz	$+60     	;abs 0x800c

00007fd2 <.Loc.77.3>:
    /* half-full interrupt */
    _adc_isr_half_code(adcp);
    7fd2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fd6:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fda:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fde:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fe0:	15 24       	jz	$+44     	;abs 0x800c

00007fe2 <.Loc.77.3>:
    7fe2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fe6:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fea:	1f 4c 02 00 	mov	2(r12),	r15	;
    7fee:	1c 41 06 00 	mov	6(r1),	r12	;
    7ff2:	1c 4c 04 00 	mov	4(r12),	r12	;
    7ff6:	1d 41 06 00 	mov	6(r1),	r13	;
    7ffa:	1d 4d 06 00 	mov	6(r13),	r13	;
    7ffe:	12 c3       	clrc			
    8000:	0d 10       	rrc	r13		;
    8002:	0e 4d       	mov	r13,	r14	;
    8004:	0d 4c       	mov	r12,	r13	;
    8006:	1c 41 06 00 	mov	6(r1),	r12	;
    800a:	8f 12       	call	r15		;

0000800c <.L13>:
  }

  if (adcp->count == adcp->depth) {
    800c:	1c 41 06 00 	mov	6(r1),	r12	;
    8010:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    8014:	0d 4c       	mov	r12,	r13	;
    8016:	1c 41 06 00 	mov	6(r1),	r12	;
    801a:	1c 4c 06 00 	mov	6(r12),	r12	;
    801e:	0d 9c       	cmp	r12,	r13	;
    8020:	ba 20       	jnz	$+374    	;abs 0x8196

00008022 <.Loc.84.3>:
    /* full interrupt */

    /* adc_lld_stop_conversion is called automatically here if needed */
    _adc_isr_full_code(adcp);
    8022:	1c 41 06 00 	mov	6(r1),	r12	;
    8026:	1c 4c 08 00 	mov	8(r12),	r12	;
    802a:	6c 4c       	mov.b	@r12,	r12	;
    802c:	0c 93       	cmp	#0,	r12	;r3 As==00
    802e:	4c 24       	jz	$+154    	;abs 0x80c8

00008030 <.Loc.84.3>:
    8030:	1c 41 06 00 	mov	6(r1),	r12	;
    8034:	1c 4c 08 00 	mov	8(r12),	r12	;
    8038:	1c 4c 02 00 	mov	2(r12),	r12	;
    803c:	0c 93       	cmp	#0,	r12	;r3 As==00
    803e:	88 24       	jz	$+274    	;abs 0x8150

00008040 <.Loc.84.3>:
    8040:	1c 41 06 00 	mov	6(r1),	r12	;
    8044:	1d 4c 06 00 	mov	6(r12),	r13	;
    8048:	5c 43       	mov.b	#1,	r12	;r3 As==01
    804a:	0c 9d       	cmp	r13,	r12	;
    804c:	29 2c       	jc	$+84     	;abs 0x80a0

0000804e <.LBB2>:
    804e:	1c 41 06 00 	mov	6(r1),	r12	;
    8052:	1c 4c 06 00 	mov	6(r12),	r12	;
    8056:	b0 12 d8 a3 	call	#41944		;#0xa3d8
    805a:	81 4c 04 00 	mov	r12,	4(r1)	;
    805e:	1c 41 06 00 	mov	6(r1),	r12	;
    8062:	1c 4c 08 00 	mov	8(r12),	r12	;
    8066:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    806a:	1d 41 04 00 	mov	4(r1),	r13	;
    806e:	b0 12 40 ad 	call	#44352		;#0xad40
    8072:	81 4c 02 00 	mov	r12,	2(r1)	;
    8076:	1c 41 06 00 	mov	6(r1),	r12	;
    807a:	1c 4c 08 00 	mov	8(r12),	r12	;
    807e:	1f 4c 02 00 	mov	2(r12),	r15	;
    8082:	1c 41 06 00 	mov	6(r1),	r12	;
    8086:	1d 4c 04 00 	mov	4(r12),	r13	;
    808a:	1c 41 02 00 	mov	2(r1),	r12	;
    808e:	0c 5c       	rla	r12		;
    8090:	0c 5d       	add	r13,	r12	;
    8092:	1e 41 04 00 	mov	4(r1),	r14	;
    8096:	0d 4c       	mov	r12,	r13	;
    8098:	1c 41 06 00 	mov	6(r1),	r12	;
    809c:	8f 12       	call	r15		;

0000809e <.LBE2>:
    809e:	58 3c       	jmp	$+178    	;abs 0x8150

000080a0 <.L17>:
    80a0:	1c 41 06 00 	mov	6(r1),	r12	;
    80a4:	1c 4c 08 00 	mov	8(r12),	r12	;
    80a8:	1f 4c 02 00 	mov	2(r12),	r15	;
    80ac:	1c 41 06 00 	mov	6(r1),	r12	;
    80b0:	1c 4c 04 00 	mov	4(r12),	r12	;
    80b4:	1d 41 06 00 	mov	6(r1),	r13	;
    80b8:	1d 4d 06 00 	mov	6(r13),	r13	;
    80bc:	0e 4d       	mov	r13,	r14	;
    80be:	0d 4c       	mov	r12,	r13	;
    80c0:	1c 41 06 00 	mov	6(r1),	r12	;
    80c4:	8f 12       	call	r15		;
    80c6:	44 3c       	jmp	$+138    	;abs 0x8150

000080c8 <.L15>:
    80c8:	1c 41 06 00 	mov	6(r1),	r12	;
    80cc:	b0 12 68 84 	call	#33896		;#0x8468
    80d0:	1c 41 06 00 	mov	6(r1),	r12	;
    80d4:	1c 4c 08 00 	mov	8(r12),	r12	;
    80d8:	1c 4c 02 00 	mov	2(r12),	r12	;
    80dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    80de:	25 24       	jz	$+76     	;abs 0x812a

000080e0 <.Loc.84.3>:
    80e0:	1c 41 06 00 	mov	6(r1),	r12	;
    80e4:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    80e8:	1c 41 06 00 	mov	6(r1),	r12	;
    80ec:	1c 4c 08 00 	mov	8(r12),	r12	;
    80f0:	1f 4c 02 00 	mov	2(r12),	r15	;
    80f4:	1c 41 06 00 	mov	6(r1),	r12	;
    80f8:	1c 4c 04 00 	mov	4(r12),	r12	;
    80fc:	1d 41 06 00 	mov	6(r1),	r13	;
    8100:	1d 4d 06 00 	mov	6(r13),	r13	;
    8104:	0e 4d       	mov	r13,	r14	;
    8106:	0d 4c       	mov	r12,	r13	;
    8108:	1c 41 06 00 	mov	6(r1),	r12	;
    810c:	8f 12       	call	r15		;
    810e:	1c 41 06 00 	mov	6(r1),	r12	;
    8112:	6c 4c       	mov.b	@r12,	r12	;
    8114:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8116:	11 20       	jnz	$+36     	;abs 0x813a

00008118 <.Loc.84.3>:
    8118:	1c 41 06 00 	mov	6(r1),	r12	;
    811c:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    8120:	1c 41 06 00 	mov	6(r1),	r12	;
    8124:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    8128:	08 3c       	jmp	$+18     	;abs 0x813a

0000812a <.L19>:
    812a:	1c 41 06 00 	mov	6(r1),	r12	;
    812e:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    8132:	1c 41 06 00 	mov	6(r1),	r12	;
    8136:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

0000813a <.L21>:
    813a:	b0 12 0a 7f 	call	#32522		;#0x7f0a
    813e:	1c 41 06 00 	mov	6(r1),	r12	;
    8142:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    8146:	4d 43       	clr.b	r13		;
    8148:	b0 12 22 7f 	call	#32546		;#0x7f22
    814c:	b0 12 16 7f 	call	#32534		;#0x7f16

00008150 <.L18>:
    /* after isr_full, adcp->grpp is only non-NULL if it's a circular group */
    if (adcp->grpp) {
    8150:	1c 41 06 00 	mov	6(r1),	r12	;
    8154:	1c 4c 08 00 	mov	8(r12),	r12	;
    8158:	0c 93       	cmp	#0,	r12	;r3 As==00
    815a:	44 24       	jz	$+138    	;abs 0x81e4

0000815c <.Loc.88.3>:
      /* Reset the buffer pointer */
      adcp->req.dest_addr = adcp->samples;
    815c:	1c 41 06 00 	mov	6(r1),	r12	;
    8160:	1d 4c 04 00 	mov	4(r12),	r13	;
    8164:	1c 41 06 00 	mov	6(r1),	r12	;
    8168:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

0000816c <.Loc.90.3>:

      restart_dma(adcp);
    816c:	1c 41 06 00 	mov	6(r1),	r12	;
    8170:	b0 12 3c 7f 	call	#32572		;#0x7f3c

00008174 <.Loc.93.3>:

      /* Reset the count */
      adcp->count = 0;
    8174:	1c 41 06 00 	mov	6(r1),	r12	;
    8178:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

0000817c <.Loc.96.3>:

      /* Start next sequence */
      adcp->regs->ctl[0] |= ADC12SC;
    817c:	1c 41 06 00 	mov	6(r1),	r12	;
    8180:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8184:	1d 41 06 00 	mov	6(r1),	r13	;
    8188:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    818c:	2d 4d       	mov	@r13,	r13	;
    818e:	1d d3       	bis	#1,	r13	;r3 As==01
    8190:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8194:	27 3c       	jmp	$+80     	;abs 0x81e4

00008196 <.L14>:
    }
  }
  else {
    /* Advance the buffer pointer */
    adcp->req.dest_addr = adcp->samples + (adcp->req.size * adcp->count);
    8196:	1c 41 06 00 	mov	6(r1),	r12	;
    819a:	1a 4c 04 00 	mov	4(r12),	r10	;
    819e:	1c 41 06 00 	mov	6(r1),	r12	;
    81a2:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    81a6:	1d 41 06 00 	mov	6(r1),	r13	;
    81aa:	5d 4d 24 00 	mov.b	36(r13),r13	;0x00024
    81ae:	b0 12 40 ad 	call	#44352		;#0xad40
    81b2:	0c 5c       	rla	r12		;
    81b4:	0d 4a       	mov	r10,	r13	;
    81b6:	0d 5c       	add	r12,	r13	;
    81b8:	1c 41 06 00 	mov	6(r1),	r12	;
    81bc:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

000081c0 <.Loc.103.3>:

    restart_dma(adcp);
    81c0:	1c 41 06 00 	mov	6(r1),	r12	;
    81c4:	b0 12 3c 7f 	call	#32572		;#0x7f3c

000081c8 <.Loc.106.3>:

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
    81c8:	1c 41 06 00 	mov	6(r1),	r12	;
    81cc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    81d0:	1d 41 06 00 	mov	6(r1),	r13	;
    81d4:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    81d8:	2d 4d       	mov	@r13,	r13	;
    81da:	1d d3       	bis	#1,	r13	;r3 As==01
    81dc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    81e0:	01 3c       	jmp	$+4      	;abs 0x81e4

000081e2 <.L23>:

static void dma_callback(void * args) {
  ADCDriver * adcp = (ADCDriver *)args;

  if (adcp->grpp == NULL)
    return;
    81e2:	03 43       	nop			

000081e4 <.L10>:
    restart_dma(adcp);

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
  }
}
    81e4:	31 52       	add	#8,	r1	;r2 As==11
    81e6:	0a 17       	popm	#1,	r10	;16-bit words
    81e8:	30 41       	ret			

000081ea <populate_tlv>:

static void populate_tlv(ADCDriver * adcp) {
    81ea:	21 82       	sub	#4,	r1	;r2 As==10

000081ec <.LCFI4>:
    81ec:	81 4c 00 00 	mov	r12,	0(r1)	;

000081f0 <.Loc.111.3>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    81f0:	b1 40 08 1a 	Address 0x00000000000081f4 is out of bounds.
mov	#6664,	-1(r1)	;#0x1a08, 0xffff
    81f4:	02 00 

000081f4 <L0>:
    81f4:	02 00       	mova	@r0,	r2	;

000081f6 <.Loc.113.3>:

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    81f6:	20 3c       	jmp	$+66     	;abs 0x8238

000081f8 <.L29>:
    if (*tlv_addr == TLV_ADC12CAL) {
    81f8:	1c 41 02 00 	mov	2(r1),	r12	;
    81fc:	6c 4c       	mov.b	@r12,	r12	;
    81fe:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    8202:	07 20       	jnz	$+16     	;abs 0x8212

00008204 <.Loc.115.3>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    8204:	1d 41 02 00 	mov	2(r1),	r13	;
    8208:	2d 53       	incd	r13		;
    820a:	2c 41       	mov	@r1,	r12	;
    820c:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020
    8210:	0c 3c       	jmp	$+26     	;abs 0x822a

00008212 <.L26>:
    }
    else if (*tlv_addr == TLV_REFCAL) {
    8212:	1c 41 02 00 	mov	2(r1),	r12	;
    8216:	6c 4c       	mov.b	@r12,	r12	;
    8218:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    821c:	06 20       	jnz	$+14     	;abs 0x822a

0000821e <.Loc.118.3>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    821e:	1d 41 02 00 	mov	2(r1),	r13	;
    8222:	2d 53       	incd	r13		;
    8224:	2c 41       	mov	@r1,	r12	;
    8226:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

0000822a <.L27>:
    }
    tlv_addr += (tlv_addr[1] + 2);
    822a:	1c 41 02 00 	mov	2(r1),	r12	;
    822e:	1c 53       	inc	r12		;
    8230:	6c 4c       	mov.b	@r12,	r12	;
    8232:	2c 53       	incd	r12		;
    8234:	81 5c 02 00 	add	r12,	2(r1)	;

00008238 <.L25>:
}

static void populate_tlv(ADCDriver * adcp) {
  uint8_t * tlv_addr = (uint8_t *)TLV_START;

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    8238:	1c 41 02 00 	mov	2(r1),	r12	;
    823c:	6c 4c       	mov.b	@r12,	r12	;
    823e:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    8240:	05 24       	jz	$+12     	;abs 0x824c

00008242 <.Loc.113.3>:
    8242:	3c 40 fe 1a 	mov	#6910,	r12	;#0x1afe
    8246:	1c 91 02 00 	cmp	2(r1),	r12	;
    824a:	d6 2f       	jc	$-82     	;abs 0x81f8

0000824c <.L30>:
    else if (*tlv_addr == TLV_REFCAL) {
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    }
    tlv_addr += (tlv_addr[1] + 2);
  }
}
    824c:	03 43       	nop			
    824e:	21 52       	add	#4,	r1	;r2 As==10
    8250:	30 41       	ret			

00008252 <ISR_ADC12_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(ADC12_VECTOR) {
    8252:	bf 15       	pushm	#12,	r15	;16-bit words

00008254 <.LCFI5>:

  OSAL_IRQ_PROLOGUE();
    8254:	d2 43 70 51 	Address 0x0000000000008256 is out of bounds.
mov.b	#1,	&0xffff	;r3 As==01

00008256 <L0>:
    8256:	70 51       	add.b	@r1+,	r0	;
    8258:	b0 12 02 5c 	call	#23554		;#0x5c02

0000825c <.Loc.132.3>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    825c:	1c 42 18 08 	mov	&0x0818,r12	;0x0818
    8260:	2c 93       	cmp	#2,	r12	;r3 As==10
    8262:	03 24       	jz	$+8      	;abs 0x826a
    8264:	2c 92       	cmp	#4,	r12	;r2 As==10
    8266:	32 24       	jz	$+102    	;abs 0x82cc
    8268:	62 3c       	jmp	$+198    	;abs 0x832e

0000826a <.L33>:

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
    826a:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    826e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8270:	8b 24       	jz	$+280    	;abs 0x8388

00008272 <.Loc.137.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    8272:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    8276:	b0 12 68 84 	call	#33896		;#0x8468
    827a:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    827e:	1c 4c 04 00 	mov	4(r12),	r12	;
    8282:	0c 93       	cmp	#0,	r12	;r3 As==00
    8284:	15 24       	jz	$+44     	;abs 0x82b0

00008286 <.Loc.137.3>:
    8286:	f2 40 05 00 	mov.b	#5,	&0x526a	;
    828a:	6a 52 
    828c:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    8290:	1e 4c 04 00 	mov	4(r12),	r14	;
    8294:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8296:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    829a:	8e 12       	call	r14		;
    829c:	5c 42 6a 52 	mov.b	&0x526a,r12	;0x526a
    82a0:	7c 90 05 00 	cmp.b	#5,	r12	;
    82a4:	02 20       	jnz	$+6      	;abs 0x82aa

000082a6 <.Loc.137.3>:
    82a6:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10

000082aa <.L38>:
    82aa:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00
    82ae:	04 3c       	jmp	$+10     	;abs 0x82b8

000082b0 <.L37>:
    82b0:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10
    82b4:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00

000082b8 <.L39>:
    82b8:	b0 12 0a 7f 	call	#32522		;#0x7f0a
    82bc:	3d 43       	mov	#-1,	r13	;r3 As==11
    82be:	3c 40 74 52 	mov	#21108,	r12	;#0x5274
    82c2:	b0 12 22 7f 	call	#32546		;#0x7f22
    82c6:	b0 12 16 7f 	call	#32534		;#0x7f16

000082ca <.Loc.138.3>:
    break;
    82ca:	61 3c       	jmp	$+196    	;abs 0x838e

000082cc <.L34>:
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
    82cc:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    82d0:	0c 93       	cmp	#0,	r12	;r3 As==00
    82d2:	5c 24       	jz	$+186    	;abs 0x838c

000082d4 <.Loc.143.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    82d4:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    82d8:	b0 12 68 84 	call	#33896		;#0x8468
    82dc:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    82e0:	1c 4c 04 00 	mov	4(r12),	r12	;
    82e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    82e6:	15 24       	jz	$+44     	;abs 0x8312

000082e8 <.Loc.143.3>:
    82e8:	f2 40 05 00 	mov.b	#5,	&0x526a	;
    82ec:	6a 52 
    82ee:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    82f2:	1e 4c 04 00 	mov	4(r12),	r14	;
    82f6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    82f8:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    82fc:	8e 12       	call	r14		;
    82fe:	5c 42 6a 52 	mov.b	&0x526a,r12	;0x526a
    8302:	7c 90 05 00 	cmp.b	#5,	r12	;
    8306:	02 20       	jnz	$+6      	;abs 0x830c

00008308 <.Loc.143.3>:
    8308:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10

0000830c <.L42>:
    830c:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00
    8310:	04 3c       	jmp	$+10     	;abs 0x831a

00008312 <.L41>:
    8312:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10
    8316:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00

0000831a <.L43>:
    831a:	b0 12 0a 7f 	call	#32522		;#0x7f0a
    831e:	3d 43       	mov	#-1,	r13	;r3 As==11
    8320:	3c 40 74 52 	mov	#21108,	r12	;#0x5274
    8324:	b0 12 22 7f 	call	#32546		;#0x7f22
    8328:	b0 12 16 7f 	call	#32534		;#0x7f16

0000832c <.Loc.144.3>:
    break;
    832c:	30 3c       	jmp	$+98     	;abs 0x838e

0000832e <.L48>:
  }
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    832e:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    8332:	b0 12 68 84 	call	#33896		;#0x8468
    8336:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    833a:	1c 4c 04 00 	mov	4(r12),	r12	;
    833e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8340:	15 24       	jz	$+44     	;abs 0x836c

00008342 <.Loc.148.3>:
    8342:	f2 40 05 00 	mov.b	#5,	&0x526a	;
    8346:	6a 52 
    8348:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    834c:	1e 4c 04 00 	mov	4(r12),	r14	;
    8350:	4d 43       	clr.b	r13		;
    8352:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    8356:	8e 12       	call	r14		;
    8358:	5c 42 6a 52 	mov.b	&0x526a,r12	;0x526a
    835c:	7c 90 05 00 	cmp.b	#5,	r12	;
    8360:	02 20       	jnz	$+6      	;abs 0x8366

00008362 <.Loc.148.3>:
    8362:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10

00008366 <.L45>:
    8366:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00
    836a:	04 3c       	jmp	$+10     	;abs 0x8374

0000836c <.L44>:
    836c:	e2 43 6a 52 	mov.b	#2,	&0x526a	;r3 As==10
    8370:	82 43 72 52 	mov	#0,	&0x5272	;r3 As==00

00008374 <.L46>:
    8374:	b0 12 0a 7f 	call	#32522		;#0x7f0a
    8378:	3d 43       	mov	#-1,	r13	;r3 As==11
    837a:	3c 40 74 52 	mov	#21108,	r12	;#0x5274
    837e:	b0 12 22 7f 	call	#32546		;#0x7f22
    8382:	b0 12 16 7f 	call	#32534		;#0x7f16
    8386:	03 3c       	jmp	$+8      	;abs 0x838e

00008388 <.L49>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    8388:	03 43       	nop			
    838a:	01 3c       	jmp	$+4      	;abs 0x838e

0000838c <.L50>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    break;
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    838c:	03 43       	nop			

0000838e <.L36>:
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
  }

  OSAL_IRQ_EPILOGUE();
    838e:	b0 12 30 5c 	call	#23600		;#0x5c30
    8392:	c2 43 70 51 	mov.b	#0,	&0x5170	;r3 As==00
    8396:	b0 12 7a 5b 	call	#23418		;#0x5b7a
    839a:	b0 12 b0 5e 	call	#24240		;#0x5eb0
    839e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    83a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    83a4:	02 24       	jz	$+6      	;abs 0x83aa

000083a6 <.Loc.151.3>:
    83a6:	b0 12 cc 5e 	call	#24268		;#0x5ecc

000083aa <.L47>:
    83aa:	b0 12 9a 5b 	call	#23450		;#0x5b9a

000083ae <.Loc.152.3>:
}
    83ae:	03 43       	nop			
    83b0:	b4 17       	popm	#12,	r15	;16-bit words
    83b2:	00 13       	reti			

000083b4 <adc_lld_init>:
 */
void adc_lld_init(void) {

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    83b4:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    83b8:	b0 12 50 68 	call	#26704		;#0x6850

000083bc <.Loc.168.3>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    83bc:	b2 40 00 08 	mov	#2048,	&0x5276	;#0x0800
    83c0:	76 52 

000083c2 <.Loc.169.3>:
  populate_tlv(&ADCD1);
    83c2:	3c 40 6a 52 	Address 0x00000000000083c4 is out of bounds.
mov	#65535,	r12	;#0xffff

000083c4 <L0>:
    83c4:	6a 52       	add.b	#4,	r10	;r2 As==10
    83c6:	b0 12 ea 81 	call	#33258		;#0x81ea

000083ca <.Loc.171.3>:
#endif
}
    83ca:	03 43       	nop			
    83cc:	30 41       	ret			

000083ce <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver * adcp) {
    83ce:	21 82       	sub	#4,	r1	;r2 As==10

000083d0 <.LCFI6>:
    83d0:	81 4c 00 00 	mov	r12,	0(r1)	;

000083d4 <.Loc.182.3>:

  if (adcp->state == ADC_STOP) {
    83d4:	2c 41       	mov	@r1,	r12	;
    83d6:	6c 4c       	mov.b	@r12,	r12	;
    83d8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    83da:	43 20       	jnz	$+136    	;abs 0x8462

000083dc <.LBB3>:
    /* Enables the peripheral.*/
    adcp->regs->ctl[0] = ADC12ON | ADC12MSC;
    83dc:	2c 41       	mov	@r1,	r12	;
    83de:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    83e2:	bc 40 90 00 	mov	#144,	0(r12)	;#0x0090
    83e6:	00 00 

000083e8 <.Loc.185.3>:
    adcp->regs->ctl[1] =
    83e8:	2c 41       	mov	@r1,	r12	;
    83ea:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    83ee:	bc 40 60 62 	mov	#25184,	2(r12)	;#0x6260
    83f2:	02 00 

000083f4 <.Loc.187.3>:
        MSP430X_ADC1_PDIV | MSP430X_ADC1_DIV | MSP430X_ADC1_SSEL | ADC12SHP;
    adcp->regs->ctl[3] = ADC12ICH3MAP | ADC12ICH2MAP | ADC12ICH1MAP |
    83f4:	2c 41       	mov	@r1,	r12	;
    83f6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    83fa:	bc 40 c0 0f 	mov	#4032,	6(r12)	;#0x0fc0
    83fe:	06 00 

00008400 <.Loc.189.3>:
                         ADC12ICH0MAP | ADC12TCMAP | ADC12BATMAP;
    adcp->regs->ier[2] = ADC12TOVIE | ADC12OVIE;
    8400:	2c 41       	mov	@r1,	r12	;
    8402:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8406:	bc 40 30 00 	mov	#48,	22(r12)	;#0x0030, 0x0016
    840a:	16 00 

0000840c <.Loc.190.3>:
    adcp->req.trigger  = DMA_TRIGGER_MNEM(ADC12IFG);
    840c:	2c 41       	mov	@r1,	r12	;
    840e:	bc 40 1a 00 	mov	#26,	26(r12)	;#0x001a, 0x001a
    8412:	1a 00 

00008414 <.Loc.194.3>:
#if MSP430X_ADC_COMPACT_SAMPLES == TRUE
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTBYTE;
#else
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTWORD;
    8414:	2c 41       	mov	@r1,	r12	;
    8416:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016

0000841a <.Loc.196.3>:
#endif
    adcp->req.addr_mode         = MSP430X_DMA_SRCINCR | MSP430X_DMA_DSTINCR;
    841a:	2c 41       	mov	@r1,	r12	;
    841c:	bc 40 00 0f 	mov	#3840,	20(r12)	;#0x0f00, 0x0014
    8420:	14 00 

00008422 <.Loc.197.3>:
    adcp->req.transfer_mode     = MSP430X_DMA_SINGLE;
    8422:	2c 41       	mov	@r1,	r12	;
    8424:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

00008428 <.Loc.198.3>:
    adcp->req.callback.callback = dma_callback;
    8428:	2c 41       	mov	@r1,	r12	;
    842a:	bc 40 8c 7f 	mov	#32652,	28(r12)	;#0x7f8c, 0x001c
    842e:	1c 00 

00008430 <.Loc.199.3>:
    adcp->req.callback.args     = adcp;
    8430:	2c 41       	mov	@r1,	r12	;
    8432:	ac 41 1e 00 	mov	@r1,	30(r12)	; 0x001e

00008436 <.Loc.203.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    bool b;
    if (adcp->config->dma_index < MSP430X_DMA_CHANNELS) {
    8436:	2c 41       	mov	@r1,	r12	;
    8438:	1c 4c 02 00 	mov	2(r12),	r12	;
    843c:	6c 4c       	mov.b	@r12,	r12	;
    843e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8440:	4d 9c       	cmp.b	r12,	r13	;
    8442:	0c 28       	jnc	$+26     	;abs 0x845c

00008444 <.Loc.204.3>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
    8444:	2c 41       	mov	@r1,	r12	;
    8446:	3c 50 26 00 	add	#38,	r12	;#0x0026
    844a:	2d 41       	mov	@r1,	r13	;
    844c:	1d 4d 02 00 	mov	2(r13),	r13	;
    8450:	6d 4d       	mov.b	@r13,	r13	;
    8452:	b0 12 d0 79 	call	#31184		;#0x79d0
    8456:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

0000845a <.LBE3>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    845a:	03 3c       	jmp	$+8      	;abs 0x8462

0000845c <.L54>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
      osalDbgAssert(!b, "stream already allocated");
    }
    else {
#endif
      adcp->dma.registers = NULL;
    845c:	2c 41       	mov	@r1,	r12	;
    845e:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

00008462 <.L55>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    8462:	03 43       	nop			
    8464:	21 52       	add	#4,	r1	;r2 As==10
    8466:	30 41       	ret			

00008468 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {
    8468:	21 83       	decd	r1		;

0000846a <L0>:
    846a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000846e <.Loc.298.3>:

  /* TODO stop DMA transfers here */
  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    846e:	2c 41       	mov	@r1,	r12	;
    8470:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8474:	2d 41       	mov	@r1,	r13	;
    8476:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    847a:	2d 4d       	mov	@r13,	r13	;
    847c:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    8480:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008484 <.Loc.301.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    8484:	2c 41       	mov	@r1,	r12	;
    8486:	1c 4c 02 00 	mov	2(r12),	r12	;
    848a:	6c 4c       	mov.b	@r12,	r12	;
    848c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    848e:	4d 9c       	cmp.b	r12,	r13	;
    8490:	0d 2c       	jc	$+28     	;abs 0x84ac

00008492 <.Loc.303.3>:
#endif
    if (adcp->dma.registers != NULL) {
    8492:	2c 41       	mov	@r1,	r12	;
    8494:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    8498:	0c 93       	cmp	#0,	r12	;r3 As==00
    849a:	08 24       	jz	$+18     	;abs 0x84ac

0000849c <.Loc.304.3>:
      dmaRelease(&(adcp->dma));
    849c:	2c 41       	mov	@r1,	r12	;
    849e:	3c 50 26 00 	add	#38,	r12	;#0x0026
    84a2:	b0 12 48 7b 	call	#31560		;#0x7b48

000084a6 <.Loc.305.3>:
      adcp->dma.registers = NULL;
    84a6:	2c 41       	mov	@r1,	r12	;
    84a8:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

000084ac <.L68>:
    }
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
}
    84ac:	03 43       	nop			
    84ae:	21 53       	incd	r1		;
    84b0:	30 41       	ret			

000084b2 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    84b2:	32 c2       	dint			

000084b4 <.Loc.46.1>:

}
    84b4:	03 43       	nop			
    84b6:	30 41       	ret			

000084b8 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
    84b8:	21 83       	decd	r1		;

000084ba <.LCFI1>:
    84ba:	81 4c 00 00 	mov	r12,	0(r1)	;

000084be <.Loc.684.2>:

  chThdSleep(time);
    84be:	2c 41       	mov	@r1,	r12	;
    84c0:	b0 12 a4 5f 	call	#24484		;#0x5fa4

000084c4 <.Loc.685.2>:
}
    84c4:	03 43       	nop			
    84c6:	21 53       	incd	r1		;
    84c8:	30 41       	ret			

000084ca <sx1278SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1278SetRegister(SX1278Driver *devp, uint8_t reg, 
    uint8_t value) {
    84ca:	21 82       	sub	#4,	r1	;r2 As==10

000084cc <.LCFI5>:
    84cc:	81 4c 02 00 	mov	r12,	2(r1)	;
    84d0:	c1 4d 01 00 	mov.b	r13,	1(r1)	;
    84d4:	c1 4e 00 00 	mov.b	r14,	0(r1)	;

000084d8 <.Loc.106.3>:
  osalDbgAssert(!(reg & 0x7FU), "register address out of bounds");
  
  osalDbgAssert(reg != 0x11U && reg != 0x3CU && reg != 0x42U, 
      "setting read-only registers");
  
  spiSelect(devp->config->spip);
    84d8:	1c 41 02 00 	mov	2(r1),	r12	;
    84dc:	2c 4c       	mov	@r12,	r12	;
    84de:	2c 4c       	mov	@r12,	r12	;
    84e0:	b0 12 22 6c 	call	#27682		;#0x6c22

000084e4 <.Loc.107.3>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    84e4:	1c 41 02 00 	mov	2(r1),	r12	;
    84e8:	2c 4c       	mov	@r12,	r12	;
    84ea:	2c 4c       	mov	@r12,	r12	;
    84ec:	5d 41 01 00 	mov.b	1(r1),	r13	;
    84f0:	7d d0 80 ff 	bis.b	#65408,	r13	;#0xff80
    84f4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    84f8:	b0 12 a8 7e 	call	#32424		;#0x7ea8

000084fc <.Loc.108.3>:
  reg = spiPolledExchange(devp->config->spip, value);
    84fc:	1c 41 02 00 	mov	2(r1),	r12	;
    8500:	2c 4c       	mov	@r12,	r12	;
    8502:	2c 4c       	mov	@r12,	r12	;
    8504:	6d 41       	mov.b	@r1,	r13	;
    8506:	b0 12 a8 7e 	call	#32424		;#0x7ea8
    850a:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

0000850e <.Loc.109.3>:
  spiUnselect(devp->config->spip);
    850e:	1c 41 02 00 	mov	2(r1),	r12	;
    8512:	2c 4c       	mov	@r12,	r12	;
    8514:	2c 4c       	mov	@r12,	r12	;
    8516:	b0 12 3c 6c 	call	#27708		;#0x6c3c

0000851a <.Loc.111.3>:
  
  return reg;
    851a:	5c 41 01 00 	mov.b	1(r1),	r12	;

0000851e <.Loc.112.3>:
}
    851e:	21 52       	add	#4,	r1	;r2 As==10
    8520:	30 41       	ret			

00008522 <sx1278SetBitrate>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] rate bit rate in bits per second to be used
*/
static void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    8522:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00008526 <.LCFI8>:
    8526:	81 4c 04 00 	mov	r12,	4(r1)	;
    852a:	81 4d 00 00 	mov	r13,	0(r1)	;
    852e:	81 4e 02 00 	mov	r14,	2(r1)	;

00008532 <.Loc.162.3>:
  uint16_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    8532:	2e 41       	mov	@r1,	r14	;
    8534:	1f 41 02 00 	mov	2(r1),	r15	;
    8538:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    853c:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84
    8540:	b0 12 1e a3 	call	#41758		;#0xa31e
    8544:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008548 <.Loc.163.3>:
  uint16_t regs = tmp >> 4;
    8548:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    854c:	b0 12 cc a3 	call	#41932		;#0xa3cc
    8550:	81 4c 08 00 	mov	r12,	8(r1)	;

00008554 <.Loc.164.3>:
  uint8_t frac = tmp & 0x000F;
    8554:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    8558:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    855c:	4d 4c       	mov.b	r12,	r13	;
    855e:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    8562:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

00008566 <.Loc.168.3>:
  
  osalDbgAssert(rate < 300000, "bit rate too high");
  
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    8566:	1c 41 08 00 	mov	8(r1),	r12	;
    856a:	b0 12 bc a3 	call	#41916		;#0xa3bc
    856e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8572:	4e 4c       	mov.b	r12,	r14	;
    8574:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8576:	1c 41 04 00 	mov	4(r1),	r12	;
    857a:	b0 12 ca 84 	call	#33994		;#0x84ca

0000857e <.Loc.169.3>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    857e:	1c 41 08 00 	mov	8(r1),	r12	;
    8582:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8586:	4e 4c       	mov.b	r12,	r14	;
    8588:	7d 40 03 00 	mov.b	#3,	r13	;
    858c:	1c 41 04 00 	mov	4(r1),	r12	;
    8590:	b0 12 ca 84 	call	#33994		;#0x84ca

00008594 <.Loc.170.3>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    8594:	5e 41 07 00 	mov.b	7(r1),	r14	;
    8598:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    859c:	1c 41 04 00 	mov	4(r1),	r12	;
    85a0:	b0 12 ca 84 	call	#33994		;#0x84ca

000085a4 <.Loc.171.3>:
}
    85a4:	03 43       	nop			
    85a6:	31 50 0c 00 	add	#12,	r1	;#0x000c
    85aa:	30 41       	ret			

000085ac <sx1278SetDeviation>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
static void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    85ac:	31 82       	sub	#8,	r1	;r2 As==11

000085ae <.LCFI9>:
    85ae:	81 4c 04 00 	mov	r12,	4(r1)	;
    85b2:	81 4d 00 00 	mov	r13,	0(r1)	;
    85b6:	81 4e 02 00 	mov	r14,	2(r1)	;

000085ba <.Loc.182.3>:
  /* Fancy math for freq / FSTEP to correct for roundings */
  uint16_t regs = (fdev << 11) / (SX1278_CLK_FREQ >> 8);
    85ba:	2c 41       	mov	@r1,	r12	;
    85bc:	1d 41 02 00 	mov	2(r1),	r13	;
    85c0:	b0 12 66 a3 	call	#41830		;#0xa366
    85c4:	3e 40 48 e8 	mov	#59464,	r14	;#0xe848
    85c8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    85ca:	b0 12 1e a3 	call	#41758		;#0xa31e
    85ce:	81 4c 06 00 	mov	r12,	6(r1)	;

000085d2 <.Loc.186.3>:
  
  osalDbgAssert(fdev < 200000, "deviation too high");
  
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    85d2:	1c 41 06 00 	mov	6(r1),	r12	;
    85d6:	b0 12 bc a3 	call	#41916		;#0xa3bc
    85da:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85de:	4e 4c       	mov.b	r12,	r14	;
    85e0:	6d 42       	mov.b	#4,	r13	;r2 As==10
    85e2:	1c 41 04 00 	mov	4(r1),	r12	;
    85e6:	b0 12 ca 84 	call	#33994		;#0x84ca

000085ea <.Loc.187.3>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    85ea:	1c 41 06 00 	mov	6(r1),	r12	;
    85ee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85f2:	4e 4c       	mov.b	r12,	r14	;
    85f4:	7d 40 05 00 	mov.b	#5,	r13	;
    85f8:	1c 41 04 00 	mov	4(r1),	r12	;
    85fc:	b0 12 ca 84 	call	#33994		;#0x84ca

00008600 <.Loc.188.3>:
}
    8600:	03 43       	nop			
    8602:	31 52       	add	#8,	r1	;r2 As==11
    8604:	30 41       	ret			

00008606 <sx1278SetFrequency>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
static void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    8606:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000860a <.LCFI10>:
    860a:	81 4c 04 00 	mov	r12,	4(r1)	;
    860e:	81 4d 00 00 	mov	r13,	0(r1)	;
    8612:	81 4e 02 00 	mov	r14,	2(r1)	;

00008616 <.Loc.199.3>:
  /* Fancy math for freq / FSTEP to keep everything from rounding */
  uint32_t regs = ((freq / (SX1278_CLK_FREQ >> 11)) << 8);
    8616:	2c 41       	mov	@r1,	r12	;
    8618:	1d 41 02 00 	mov	2(r1),	r13	;
    861c:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    8620:	4f 43       	clr.b	r15		;
    8622:	b0 12 1e a3 	call	#41758		;#0xa31e
    8626:	b0 12 72 a3 	call	#41842		;#0xa372
    862a:	81 4c 06 00 	mov	r12,	6(r1)	;
    862e:	81 4d 08 00 	mov	r13,	8(r1)	;

00008632 <.Loc.201.3>:
  
  if ((freq >= 137000000 && freq <= 175000000) || 
    8632:	3c 40 2a 08 	mov	#2090,	r12	;#0x082a
    8636:	1c 91 02 00 	cmp	2(r1),	r12	;
    863a:	08 28       	jnc	$+18     	;abs 0x864c
    863c:	b1 90 2a 08 	cmp	#2090,	2(r1)	;#0x082a
    8640:	02 00 
    8642:	11 20       	jnz	$+36     	;abs 0x8666
    8644:	3c 40 3f 74 	mov	#29759,	r12	;#0x743f
    8648:	2c 91       	cmp	@r1,	r12	;
    864a:	0d 2c       	jc	$+28     	;abs 0x8666

0000864c <.L38>:
    864c:	3c 40 6e 0a 	mov	#2670,	r12	;#0x0a6e
    8650:	1c 91 02 00 	cmp	2(r1),	r12	;
    8654:	08 28       	jnc	$+18     	;abs 0x8666
    8656:	b1 90 6e 0a 	cmp	#2670,	2(r1)	;#0x0a6e
    865a:	02 00 
    865c:	1e 20       	jnz	$+62     	;abs 0x869a
    865e:	3c 40 c0 49 	mov	#18880,	r12	;#0x49c0
    8662:	2c 91       	cmp	@r1,	r12	;
    8664:	1a 2c       	jc	$+54     	;abs 0x869a

00008666 <.L28>:
    8666:	3c 40 70 18 	mov	#6256,	r12	;#0x1870
    866a:	1c 91 02 00 	cmp	2(r1),	r12	;
    866e:	08 28       	jnc	$+18     	;abs 0x8680
    8670:	b1 90 70 18 	cmp	#6256,	2(r1)	;#0x1870
    8674:	02 00 
    8676:	1c 20       	jnz	$+58     	;abs 0x86b0
    8678:	3c 40 7f 1a 	mov	#6783,	r12	;#0x1a7f
    867c:	2c 91       	cmp	@r1,	r12	;
    867e:	18 2c       	jc	$+50     	;abs 0x86b0

00008680 <.L39>:
      (freq >= 410000000 && freq <= 525000000)) {
    8680:	3c 40 4a 1f 	mov	#8010,	r12	;#0x1f4a
    8684:	1c 91 02 00 	cmp	2(r1),	r12	;
    8688:	13 28       	jnc	$+40     	;abs 0x86b0
    868a:	b1 90 4a 1f 	cmp	#8010,	2(r1)	;#0x1f4a
    868e:	02 00 
    8690:	04 20       	jnz	$+10     	;abs 0x869a
    8692:	3c 40 40 dd 	mov	#56640,	r12	;#0xdd40
    8696:	2c 91       	cmp	@r1,	r12	;
    8698:	0b 28       	jnc	$+24     	;abs 0x86b0

0000869a <.L30>:
    /* Bands 2 + 3 */
    devp->regs.opmode |= (1 << 3);
    869a:	1c 41 04 00 	mov	4(r1),	r12	;
    869e:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    86a2:	7c d2       	bis.b	#8,	r12	;r2 As==11
    86a4:	4d 4c       	mov.b	r12,	r13	;
    86a6:	1c 41 04 00 	mov	4(r1),	r12	;
    86aa:	cc 4d 03 00 	mov.b	r13,	3(r12)	;
    86ae:	24 3c       	jmp	$+74     	;abs 0x86f8

000086b0 <.L32>:
  }
  else if (freq >= 862000000 && freq <= 1020000000) {
    86b0:	3c 40 61 33 	mov	#13153,	r12	;#0x3361
    86b4:	1c 91 02 00 	cmp	2(r1),	r12	;
    86b8:	08 28       	jnc	$+18     	;abs 0x86ca
    86ba:	b1 90 61 33 	cmp	#13153,	2(r1)	;#0x3361
    86be:	02 00 
    86c0:	1b 20       	jnz	$+56     	;abs 0x86f8
    86c2:	3c 40 7f 13 	mov	#4991,	r12	;#0x137f
    86c6:	2c 91       	cmp	@r1,	r12	;
    86c8:	17 2c       	jc	$+48     	;abs 0x86f8

000086ca <.L41>:
    86ca:	3c 40 cb 3c 	mov	#15563,	r12	;#0x3ccb
    86ce:	1c 91 02 00 	cmp	2(r1),	r12	;
    86d2:	12 28       	jnc	$+38     	;abs 0x86f8
    86d4:	b1 90 cb 3c 	cmp	#15563,	2(r1)	;#0x3ccb
    86d8:	02 00 
    86da:	04 20       	jnz	$+10     	;abs 0x86e4
    86dc:	3c 40 00 f7 	mov	#63232,	r12	;#0xf700
    86e0:	2c 91       	cmp	@r1,	r12	;
    86e2:	0a 28       	jnc	$+22     	;abs 0x86f8

000086e4 <.L42>:
    /* Band 1 */
    devp->regs.opmode &= ~(1 << 3);
    86e4:	1c 41 04 00 	mov	4(r1),	r12	;
    86e8:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    86ec:	7c c2       	bic.b	#8,	r12	;r2 As==11
    86ee:	4d 4c       	mov.b	r12,	r13	;
    86f0:	1c 41 04 00 	mov	4(r1),	r12	;
    86f4:	cc 4d 03 00 	mov.b	r13,	3(r12)	;

000086f8 <.L40>:
    osalDbgAssert(false, "frequency out of range");
  }
  
  osalDbgAssert(!(regs & 0xFF000000), "incorrect register value calculated");
  
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    86f8:	1c 41 04 00 	mov	4(r1),	r12	;
    86fc:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    8700:	4e 4c       	mov.b	r12,	r14	;
    8702:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8704:	1c 41 04 00 	mov	4(r1),	r12	;
    8708:	b0 12 ca 84 	call	#33994		;#0x84ca

0000870c <.Loc.217.3>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    870c:	1c 41 06 00 	mov	6(r1),	r12	;
    8710:	1d 41 08 00 	mov	8(r1),	r13	;
    8714:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8718:	4f 43       	clr.b	r15		;
    871a:	b0 12 4e a4 	call	#42062		;#0xa44e
    871e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8722:	4e 4c       	mov.b	r12,	r14	;
    8724:	7d 40 06 00 	mov.b	#6,	r13	;
    8728:	1c 41 04 00 	mov	4(r1),	r12	;
    872c:	b0 12 ca 84 	call	#33994		;#0x84ca

00008730 <.Loc.218.3>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    8730:	1c 41 06 00 	mov	6(r1),	r12	;
    8734:	1d 41 08 00 	mov	8(r1),	r13	;
    8738:	b0 12 14 a4 	call	#42004		;#0xa414
    873c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8740:	4e 4c       	mov.b	r12,	r14	;
    8742:	7d 40 07 00 	mov.b	#7,	r13	;
    8746:	1c 41 04 00 	mov	4(r1),	r12	;
    874a:	b0 12 ca 84 	call	#33994		;#0x84ca

0000874e <.Loc.219.3>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    874e:	5c 41 06 00 	mov.b	6(r1),	r12	;
    8752:	4e 4c       	mov.b	r12,	r14	;
    8754:	7d 42       	mov.b	#8,	r13	;r2 As==11
    8756:	1c 41 04 00 	mov	4(r1),	r12	;
    875a:	b0 12 ca 84 	call	#33994		;#0x84ca

0000875e <.Loc.220.3>:
}
    875e:	03 43       	nop			
    8760:	31 50 0a 00 	add	#10,	r1	;#0x000a
    8764:	30 41       	ret			

00008766 <sx1278SetPower>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] pow  output power to be programmed, in dBm
*/
static void sx1278SetPower(SX1278Driver *devp, float pow) {
    8766:	6a 15       	pushm	#7,	r10	;16-bit words

00008768 <L0>:
    8768:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000876c <.LCFI12>:
    876c:	81 4c 04 00 	mov	r12,	4(r1)	;
    8770:	81 4d 00 00 	mov	r13,	0(r1)	;
    8774:	81 4e 02 00 	mov	r14,	2(r1)	;

00008778 <.Loc.230.3>:
  uint16_t power = ((uint16_t)(((pow + 4.2) * 10) + 0.5)) & 0xFFFE;
    8778:	2c 41       	mov	@r1,	r12	;
    877a:	1d 41 02 00 	mov	2(r1),	r13	;
    877e:	b0 12 a6 94 	call	#38054		;#0x94a6
    8782:	04 4c       	mov	r12,	r4	;
    8784:	05 4d       	mov	r13,	r5	;
    8786:	06 4e       	mov	r14,	r6	;
    8788:	07 4f       	mov	r15,	r7	;
    878a:	3c 40 cd cc 	mov	#52429,	r12	;#0xcccd
    878e:	3d 40 cc cc 	mov	#52428,	r13	;#0xcccc
    8792:	3e 40 cc cc 	mov	#52428,	r14	;#0xcccc
    8796:	3f 40 10 40 	mov	#16400,	r15	;#0x4010
    879a:	08 44       	mov	r4,	r8	;
    879c:	09 45       	mov	r5,	r9	;
    879e:	0a 46       	mov	r6,	r10	;
    87a0:	0b 47       	mov	r7,	r11	;
    87a2:	b0 12 10 9b 	call	#39696		;#0x9b10
    87a6:	08 4c       	mov	r12,	r8	;
    87a8:	09 4d       	mov	r13,	r9	;
    87aa:	0a 4e       	mov	r14,	r10	;
    87ac:	0b 4f       	mov	r15,	r11	;
    87ae:	0c 48       	mov	r8,	r12	;
    87b0:	04 4c       	mov	r12,	r4	;
    87b2:	0d 49       	mov	r9,	r13	;
    87b4:	05 4d       	mov	r13,	r5	;
    87b6:	0c 4a       	mov	r10,	r12	;
    87b8:	06 4c       	mov	r12,	r6	;
    87ba:	0d 4b       	mov	r11,	r13	;
    87bc:	07 4d       	mov	r13,	r7	;
    87be:	4c 43       	clr.b	r12		;
    87c0:	4d 43       	clr.b	r13		;
    87c2:	4e 43       	clr.b	r14		;
    87c4:	3f 40 24 40 	mov	#16420,	r15	;#0x4024
    87c8:	08 44       	mov	r4,	r8	;
    87ca:	09 45       	mov	r5,	r9	;
    87cc:	0a 46       	mov	r6,	r10	;
    87ce:	0b 47       	mov	r7,	r11	;
    87d0:	b0 12 d8 9b 	call	#39896		;#0x9bd8
    87d4:	08 4c       	mov	r12,	r8	;
    87d6:	09 4d       	mov	r13,	r9	;
    87d8:	0a 4e       	mov	r14,	r10	;
    87da:	0b 4f       	mov	r15,	r11	;
    87dc:	0c 48       	mov	r8,	r12	;
    87de:	04 4c       	mov	r12,	r4	;
    87e0:	0d 49       	mov	r9,	r13	;
    87e2:	05 4d       	mov	r13,	r5	;
    87e4:	0c 4a       	mov	r10,	r12	;
    87e6:	06 4c       	mov	r12,	r6	;
    87e8:	0d 4b       	mov	r11,	r13	;
    87ea:	07 4d       	mov	r13,	r7	;
    87ec:	4c 43       	clr.b	r12		;
    87ee:	4d 43       	clr.b	r13		;
    87f0:	4e 43       	clr.b	r14		;
    87f2:	3f 40 e0 3f 	mov	#16352,	r15	;#0x3fe0
    87f6:	08 44       	mov	r4,	r8	;
    87f8:	09 45       	mov	r5,	r9	;
    87fa:	0a 46       	mov	r6,	r10	;
    87fc:	0b 47       	mov	r7,	r11	;
    87fe:	b0 12 10 9b 	call	#39696		;#0x9b10
    8802:	04 4c       	mov	r12,	r4	;
    8804:	05 4d       	mov	r13,	r5	;
    8806:	06 4e       	mov	r14,	r6	;
    8808:	07 4f       	mov	r15,	r7	;
    880a:	0c 44       	mov	r4,	r12	;
    880c:	08 4c       	mov	r12,	r8	;
    880e:	0d 45       	mov	r5,	r13	;
    8810:	09 4d       	mov	r13,	r9	;
    8812:	0c 46       	mov	r6,	r12	;
    8814:	0a 4c       	mov	r12,	r10	;
    8816:	0d 47       	mov	r7,	r13	;
    8818:	0b 4d       	mov	r13,	r11	;
    881a:	0c 48       	mov	r8,	r12	;
    881c:	0d 49       	mov	r9,	r13	;
    881e:	0e 4a       	mov	r10,	r14	;
    8820:	0f 4b       	mov	r11,	r15	;
    8822:	b0 12 f2 90 	call	#37106		;#0x90f2
    8826:	0d 4c       	mov	r12,	r13	;
    8828:	1d c3       	bic	#1,	r13	;r3 As==01
    882a:	81 4d 08 00 	mov	r13,	8(r1)	;

0000882e <.Loc.231.3>:
  uint8_t pa_config = 0x00;
    882e:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00

00008832 <.Loc.236.3>:
  
  osalDbgAssert(pow == 20.0 || (pow <= 17.0 && pow >= -4.2), 
      "requested output power out of range");
  
  if (power == 242) { /* 20 dBm */
    8832:	b1 90 f2 00 	cmp	#242,	8(r1)	;#0x00f2
    8836:	08 00 
    8838:	13 20       	jnz	$+40     	;abs 0x8860

0000883a <.Loc.237.3>:
    pa_config = (0xFF); /* Absolute max power - DANGEROUS */
    883a:	f1 43 07 00 	mov.b	#-1,	7(r1)	;r3 As==11

0000883e <.Loc.238.3>:
    sx1278SetRegister(devp, RegPaConfig, pa_config);
    883e:	5e 41 07 00 	mov.b	7(r1),	r14	;
    8842:	7d 40 09 00 	mov.b	#9,	r13	;
    8846:	1c 41 04 00 	mov	4(r1),	r12	;
    884a:	b0 12 ca 84 	call	#33994		;#0x84ca

0000884e <.Loc.239.3>:
    sx1278SetRegister(devp, RegPaDac, 0x87); /* Special bit for +20 dBm */
    884e:	7e 40 87 ff 	mov.b	#65415,	r14	;#0xff87
    8852:	7d 40 4d 00 	mov.b	#77,	r13	;#0x004d
    8856:	1c 41 04 00 	mov	4(r1),	r12	;
    885a:	b0 12 ca 84 	call	#33994		;#0x84ca

0000885e <.Loc.240.3>:
    return;
    885e:	90 3c       	jmp	$+290    	;abs 0x8980

00008860 <.L44>:
  }
  
  sx1278SetRegister(devp, RegPaDac, 0x84);
    8860:	7e 40 84 ff 	mov.b	#65412,	r14	;#0xff84
    8864:	7d 40 4d 00 	mov.b	#77,	r13	;#0x004d
    8868:	1c 41 04 00 	mov	4(r1),	r12	;
    886c:	b0 12 ca 84 	call	#33994		;#0x84ca

00008870 <.Loc.245.3>:
  
  if (power > 182) { /* >14 dBm */
    8870:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    8874:	1c 91 08 00 	cmp	8(r1),	r12	;
    8878:	1a 2c       	jc	$+54     	;abs 0x88ae

0000887a <.Loc.246.3>:
    pa_config = (0x80 | ((uint8_t)(pow) - 2)); /* must enable PA_HP */
    887a:	2c 41       	mov	@r1,	r12	;
    887c:	1d 41 02 00 	mov	2(r1),	r13	;
    8880:	b0 12 b8 90 	call	#37048		;#0x90b8
    8884:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8888:	7c 50 fe ff 	add.b	#65534,	r12	;#0xfffe
    888c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8890:	8c 11       	sxt	r12		;
    8892:	7c d0 80 ff 	bis.b	#65408,	r12	;#0xff80
    8896:	8c 11       	sxt	r12		;
    8898:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

0000889c <.Loc.247.3>:
    sx1278SetRegister(devp, RegPaConfig, pa_config);
    889c:	5e 41 07 00 	mov.b	7(r1),	r14	;
    88a0:	7d 40 09 00 	mov.b	#9,	r13	;
    88a4:	1c 41 04 00 	mov	4(r1),	r12	;
    88a8:	b0 12 ca 84 	call	#33994		;#0x84ca

000088ac <.Loc.248.3>:
    return;
    88ac:	69 3c       	jmp	$+212    	;abs 0x8980

000088ae <.L46>:
  }
  
  switch (power % 10) { /* switch for max */
    88ae:	1c 41 08 00 	mov	8(r1),	r12	;
    88b2:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    88b6:	b0 12 96 a2 	call	#41622		;#0xa296
    88ba:	2c 92       	cmp	#4,	r12	;r2 As==10
    88bc:	2d 24       	jz	$+92     	;abs 0x8918
    88be:	6d 42       	mov.b	#4,	r13	;r2 As==10
    88c0:	0d 9c       	cmp	r12,	r13	;
    88c2:	05 28       	jnc	$+12     	;abs 0x88ce
    88c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    88c6:	09 24       	jz	$+20     	;abs 0x88da
    88c8:	2c 93       	cmp	#2,	r12	;r3 As==10
    88ca:	13 24       	jz	$+40     	;abs 0x88f2
    88cc:	47 3c       	jmp	$+144    	;abs 0x895c

000088ce <.L49>:
    88ce:	3c 90 06 00 	cmp	#6,	r12	;
    88d2:	29 24       	jz	$+84     	;abs 0x8926
    88d4:	3c 92       	cmp	#8,	r12	;r2 As==11
    88d6:	3a 24       	jz	$+118    	;abs 0x894c
    88d8:	41 3c       	jmp	$+132    	;abs 0x895c

000088da <.L50>:
    case 0:
      if (power > 150) {
    88da:	7c 40 96 00 	mov.b	#150,	r12	;#0x0096
    88de:	1c 91 08 00 	cmp	8(r1),	r12	;
    88e2:	3b 2c       	jc	$+120    	;abs 0x895a

000088e4 <.Loc.254.3>:
        pa_config |= (5 << 4);
    88e4:	f1 d0 50 00 	bis.b	#80,	7(r1)	;#0x0050
    88e8:	07 00 

000088ea <.Loc.255.3>:
        power -= (5*6);
    88ea:	b1 50 e2 ff 	add	#65506,	8(r1)	;#0xffe2
    88ee:	08 00 

000088f0 <.Loc.257.3>:
      }
      break;
    88f0:	34 3c       	jmp	$+106    	;abs 0x895a

000088f2 <.L51>:
    case 2:
      if (power > 162) {
    88f2:	7c 40 a2 00 	mov.b	#162,	r12	;#0x00a2
    88f6:	1c 91 08 00 	cmp	8(r1),	r12	;
    88fa:	07 2c       	jc	$+16     	;abs 0x890a

000088fc <.Loc.260.3>:
        pa_config |= (7 << 4);
    88fc:	f1 d0 70 00 	bis.b	#112,	7(r1)	;#0x0070
    8900:	07 00 

00008902 <.Loc.261.3>:
        power -= (7*6);
    8902:	b1 50 d6 ff 	add	#65494,	8(r1)	;#0xffd6
    8906:	08 00 

00008908 <.Loc.267.3>:
      }
      else {
        pa_config |= (2 << 4);
        power -= (2*6);
      }
      break;
    8908:	29 3c       	jmp	$+84     	;abs 0x895c

0000890a <.L55>:
      if (power > 162) {
        pa_config |= (7 << 4);
        power -= (7*6);
      }
      else {
        pa_config |= (2 << 4);
    890a:	f1 d0 20 00 	bis.b	#32,	7(r1)	;#0x0020
    890e:	07 00 

00008910 <.Loc.265.3>:
        power -= (2*6);
    8910:	b1 50 f4 ff 	add	#65524,	8(r1)	;#0xfff4
    8914:	08 00 

00008916 <.Loc.267.3>:
      }
      break;
    8916:	22 3c       	jmp	$+70     	;abs 0x895c

00008918 <.L48>:
    case 4:
      pa_config |= (4 << 4);
    8918:	f1 d0 40 00 	bis.b	#64,	7(r1)	;#0x0040
    891c:	07 00 

0000891e <.Loc.270.3>:
      power -= (4*6);
    891e:	b1 50 e8 ff 	add	#65512,	8(r1)	;#0xffe8
    8922:	08 00 

00008924 <.Loc.271.3>:
      break;
    8924:	1b 3c       	jmp	$+56     	;abs 0x895c

00008926 <.L52>:
    case 6:
      if (power > 156) {
    8926:	7c 40 9c 00 	mov.b	#156,	r12	;#0x009c
    892a:	1c 91 08 00 	cmp	8(r1),	r12	;
    892e:	07 2c       	jc	$+16     	;abs 0x893e

00008930 <.Loc.274.3>:
        pa_config |= (1 << 4);
    8930:	f1 d0 10 00 	bis.b	#16,	7(r1)	;#0x0010
    8934:	07 00 

00008936 <.Loc.275.3>:
        power -= (1*6);
    8936:	b1 50 fa ff 	add	#65530,	8(r1)	;#0xfffa
    893a:	08 00 

0000893c <.Loc.281.3>:
      }
      else {
        pa_config |= (6 << 4);
        power -= (6*6);
      }
      break;
    893c:	0f 3c       	jmp	$+32     	;abs 0x895c

0000893e <.L57>:
      if (power > 156) {
        pa_config |= (1 << 4);
        power -= (1*6);
      }
      else {
        pa_config |= (6 << 4);
    893e:	f1 d0 60 00 	bis.b	#96,	7(r1)	;#0x0060
    8942:	07 00 

00008944 <.Loc.279.3>:
        power -= (6*6);
    8944:	b1 50 dc ff 	add	#65500,	8(r1)	;#0xffdc
    8948:	08 00 

0000894a <.Loc.281.3>:
      }
      break;
    894a:	08 3c       	jmp	$+18     	;abs 0x895c

0000894c <.L53>:
    case 8:
      pa_config |= (3 << 4);
    894c:	f1 d0 30 00 	bis.b	#48,	7(r1)	;#0x0030
    8950:	07 00 

00008952 <.Loc.284.3>:
      power -= (3*6);
    8952:	b1 50 ee ff 	add	#65518,	8(r1)	;#0xffee
    8956:	08 00 

00008958 <.Loc.285.3>:
      break;
    8958:	01 3c       	jmp	$+4      	;abs 0x895c

0000895a <.L59>:
    case 0:
      if (power > 150) {
        pa_config |= (5 << 4);
        power -= (5*6);
      }
      break;
    895a:	03 43       	nop			

0000895c <.L47>:
      pa_config |= (3 << 4);
      power -= (3*6);
      break;
  }
  
  pa_config |= (power / 10); /* set out */
    895c:	1c 41 08 00 	mov	8(r1),	r12	;
    8960:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8964:	b0 12 8e a2 	call	#41614		;#0xa28e
    8968:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    896c:	c1 dc 07 00 	bis.b	r12,	7(r1)	;

00008970 <.Loc.290.3>:
  
  sx1278SetRegister(devp, RegPaConfig, pa_config);
    8970:	5e 41 07 00 	mov.b	7(r1),	r14	;
    8974:	7d 40 09 00 	mov.b	#9,	r13	;
    8978:	1c 41 04 00 	mov	4(r1),	r12	;
    897c:	b0 12 ca 84 	call	#33994		;#0x84ca

00008980 <.L43>:
}
    8980:	31 50 0a 00 	add	#10,	r1	;#0x000a
    8984:	64 17       	popm	#7,	r10	;16-bit words
    8986:	30 41       	ret			

00008988 <sx1278SetPreambleLength>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp   pointer to the SX1278 driver
 * @param[in] length length of the preamble
*/
static void sx1278SetPreambleLength(SX1278Driver *devp, uint16_t length) {
    8988:	21 82       	sub	#4,	r1	;r2 As==10

0000898a <.LCFI13>:
    898a:	81 4c 02 00 	mov	r12,	2(r1)	;
    898e:	81 4d 00 00 	mov	r13,	0(r1)	;

00008992 <.Loc.302.3>:
  
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    8992:	2c 41       	mov	@r1,	r12	;
    8994:	b0 12 bc a3 	call	#41916		;#0xa3bc
    8998:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    899c:	4e 4c       	mov.b	r12,	r14	;

0000899e <L0>:
    899e:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    89a2:	1c 41 02 00 	mov	2(r1),	r12	;
    89a6:	b0 12 ca 84 	call	#33994		;#0x84ca

000089aa <.Loc.303.3>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    89aa:	2c 41       	mov	@r1,	r12	;
    89ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    89b0:	4e 4c       	mov.b	r12,	r14	;
    89b2:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    89b6:	1c 41 02 00 	mov	2(r1),	r12	;
    89ba:	b0 12 ca 84 	call	#33994		;#0x84ca

000089be <.Loc.304.3>:
}
    89be:	03 43       	nop			
    89c0:	21 52       	add	#4,	r1	;r2 As==10
    89c2:	30 41       	ret			

000089c4 <sx1278SetSync>:
 * 
 * @param[in] devp  pointer to the SX1278 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
static void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    89c4:	0a 15       	pushm	#1,	r10	;16-bit words

000089c6 <.LCFI14>:
    89c6:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000089ca <.LCFI15>:
    89ca:	81 4c 04 00 	mov	r12,	4(r1)	;
    89ce:	81 4d 00 00 	mov	r13,	0(r1)	;
    89d2:	81 4e 02 00 	mov	r14,	2(r1)	;

000089d6 <.Loc.315.3>:
  uint8_t reg = 0x00;
    89d6:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00

000089da <.Loc.319.3>:
  
  osalDbgAssert(sizeof(sync) <= 8, "requested sync length too large");

  reg |= devp->config->packet_config->preamble_polarity << 5;
    89da:	1c 41 04 00 	mov	4(r1),	r12	;
    89de:	2c 4c       	mov	@r12,	r12	;
    89e0:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    89e4:	6c 4c       	mov.b	@r12,	r12	;
    89e6:	5c 0f       	rrum	#4,	r12	;
    89e8:	5c 03       	rrum	#1,	r12	;
    89ea:	5c f3       	and.b	#1,	r12	;r3 As==01
    89ec:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    89f0:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    89f4:	4d 4c       	mov.b	r12,	r13	;
    89f6:	8d 11       	sxt	r13		;
    89f8:	5c 41 07 00 	mov.b	7(r1),	r12	;
    89fc:	8c 11       	sxt	r12		;
    89fe:	4c dd       	bis.b	r13,	r12	;
    8a00:	8c 11       	sxt	r12		;
    8a02:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

00008a06 <.Loc.321.3>:
  
  if (sync == 0) {
    8a06:	2c 41       	mov	@r1,	r12	;
    8a08:	1c d1 02 00 	bis	2(r1),	r12	;
    8a0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a0e:	04 20       	jnz	$+10     	;abs 0x8a18

00008a10 <.Loc.322.3>:
    reg |= 0x80;
    8a10:	f1 d0 80 ff 	bis.b	#65408,	7(r1)	;#0xff80
    8a14:	07 00 

00008a16 <.Loc.323.3>:
    return;
    8a16:	34 3c       	jmp	$+106    	;abs 0x8a80

00008a18 <.L62>:
  }
  else {
    reg |= 0x90 | (sizeof(sync) - 1);
    8a18:	f1 d0 93 ff 	bis.b	#65427,	7(r1)	;#0xff93
    8a1c:	07 00 

00008a1e <.Loc.329.3>:
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
    8a1e:	5e 41 07 00 	mov.b	7(r1),	r14	;
    8a22:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027
    8a26:	1c 41 04 00 	mov	4(r1),	r12	;
    8a2a:	b0 12 ca 84 	call	#33994		;#0x84ca

00008a2e <.LBB2>:
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    8a2e:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    8a32:	21 3c       	jmp	$+68     	;abs 0x8a76

00008a34 <.L65>:
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    8a34:	1c 41 08 00 	mov	8(r1),	r12	;
    8a38:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a3c:	7c 50 28 00 	add.b	#40,	r12	;#0x0028
    8a40:	4a 4c       	mov.b	r12,	r10	;

00008a42 <.Loc.335.3>:
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
    8a42:	1c 41 08 00 	mov	8(r1),	r12	;
    8a46:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    8a4a:	0d 43       	clr	r13		;
    8a4c:	0d 8c       	sub	r12,	r13	;
    8a4e:	0c 4d       	mov	r13,	r12	;
    8a50:	3c 50 18 00 	add	#24,	r12	;#0x0018
    8a54:	0e 4c       	mov	r12,	r14	;
    8a56:	0f 43       	clr	r15		;
    8a58:	2c 41       	mov	@r1,	r12	;
    8a5a:	1d 41 02 00 	mov	2(r1),	r13	;
    8a5e:	b0 12 4e a4 	call	#42062		;#0xa44e

00008a62 <.Loc.334.3>:
  sx1278SetRegister(devp, RegSyncConfig, reg);
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    8a62:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a66:	4e 4c       	mov.b	r12,	r14	;
    8a68:	4d 4a       	mov.b	r10,	r13	;
    8a6a:	1c 41 04 00 	mov	4(r1),	r12	;
    8a6e:	b0 12 ca 84 	call	#33994		;#0x84ca

00008a72 <.Loc.331.3>:
    reg |= 0x90 | (sizeof(sync) - 1);
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    8a72:	91 53 08 00 	inc	8(r1)		;

00008a76 <.L64>:
    8a76:	7c 40 03 00 	mov.b	#3,	r12	;
    8a7a:	1c 91 08 00 	cmp	8(r1),	r12	;
    8a7e:	da 2f       	jc	$-74     	;abs 0x8a34

00008a80 <.L61>:
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
  }
}
    8a80:	31 50 0a 00 	add	#10,	r1	;#0x000a
    8a84:	0a 17       	popm	#1,	r10	;16-bit words
    8a86:	30 41       	ret			

00008a88 <sx1278Reset>:
/**
 * @brief   Resets the transceiver
 * 
 * @param[in] devp pointer to the SX1278 driver
 */
static void sx1278Reset(SX1278Driver *devp) {
    8a88:	1a 15       	pushm	#2,	r10	;16-bit words

00008a8a <.LCFI16>:
    8a8a:	21 83       	decd	r1		;

00008a8c <L0>:
    8a8c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008a90 <.Loc.348.3>:
  
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
  
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    8a90:	2c 41       	mov	@r1,	r12	;
    8a92:	2c 4c       	mov	@r12,	r12	;
    8a94:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8a98:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8a9c:	0a 4c       	mov	r12,	r10	;
    8a9e:	2c 41       	mov	@r1,	r12	;
    8aa0:	2c 4c       	mov	@r12,	r12	;
    8aa2:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8aa6:	0d 4c       	mov	r12,	r13	;
    8aa8:	5d 03       	rrum	#1,	r13	;
    8aaa:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8aae:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8ab0:	b0 12 50 a3 	call	#41808		;#0xa350
    8ab4:	7e 40 06 00 	mov.b	#6,	r14	;
    8ab8:	0d 4c       	mov	r12,	r13	;
    8aba:	0c 4a       	mov	r10,	r12	;
    8abc:	b0 12 cc 74 	call	#29900		;#0x74cc

00008ac0 <.Loc.349.3>:
  palClearLine(devp->config->reset_line);
    8ac0:	2c 41       	mov	@r1,	r12	;
    8ac2:	2c 4c       	mov	@r12,	r12	;
    8ac4:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8ac8:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8acc:	0a 4c       	mov	r12,	r10	;
    8ace:	2c 41       	mov	@r1,	r12	;
    8ad0:	2c 4c       	mov	@r12,	r12	;
    8ad2:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8ad6:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8ada:	19 4c 02 00 	mov	2(r12),	r9	;
    8ade:	2c 41       	mov	@r1,	r12	;
    8ae0:	2c 4c       	mov	@r12,	r12	;
    8ae2:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8ae6:	0d 4c       	mov	r12,	r13	;
    8ae8:	5d 03       	rrum	#1,	r13	;
    8aea:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8aee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8af0:	b0 12 50 a3 	call	#41808		;#0xa350
    8af4:	3c e3       	inv	r12		;
    8af6:	0c f9       	and	r9,	r12	;
    8af8:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008afc <.Loc.350.3>:
  osalThreadSleepMicroseconds(100);
    8afc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8afe:	b0 12 b8 84 	call	#33976		;#0x84b8

00008b02 <.Loc.351.3>:
  palSetLine(devp->config->reset_line);
    8b02:	2c 41       	mov	@r1,	r12	;
    8b04:	2c 4c       	mov	@r12,	r12	;
    8b06:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8b0a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8b0e:	0a 4c       	mov	r12,	r10	;
    8b10:	2c 41       	mov	@r1,	r12	;
    8b12:	2c 4c       	mov	@r12,	r12	;
    8b14:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8b18:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8b1c:	19 4c 02 00 	mov	2(r12),	r9	;
    8b20:	2c 41       	mov	@r1,	r12	;
    8b22:	2c 4c       	mov	@r12,	r12	;
    8b24:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8b28:	0d 4c       	mov	r12,	r13	;
    8b2a:	5d 03       	rrum	#1,	r13	;
    8b2c:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8b30:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8b32:	b0 12 50 a3 	call	#41808		;#0xa350
    8b36:	0c d9       	bis	r9,	r12	;
    8b38:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008b3c <.Loc.352.3>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLUP);
    8b3c:	2c 41       	mov	@r1,	r12	;
    8b3e:	2c 4c       	mov	@r12,	r12	;
    8b40:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8b44:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8b48:	0a 4c       	mov	r12,	r10	;
    8b4a:	2c 41       	mov	@r1,	r12	;
    8b4c:	2c 4c       	mov	@r12,	r12	;
    8b4e:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    8b52:	0d 4c       	mov	r12,	r13	;
    8b54:	5d 03       	rrum	#1,	r13	;
    8b56:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8b5a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8b5c:	b0 12 50 a3 	call	#41808		;#0xa350
    8b60:	7e 40 03 00 	mov.b	#3,	r14	;
    8b64:	0d 4c       	mov	r12,	r13	;
    8b66:	0c 4a       	mov	r10,	r12	;
    8b68:	b0 12 cc 74 	call	#29900		;#0x74cc

00008b6c <.Loc.353.3>:
  osalThreadSleepMilliseconds(5);
    8b6c:	7c 40 05 00 	mov.b	#5,	r12	;
    8b70:	b0 12 b8 84 	call	#33976		;#0x84b8

00008b74 <.Loc.354.3>:
}
    8b74:	03 43       	nop			
    8b76:	21 53       	incd	r1		;
    8b78:	19 17       	popm	#2,	r10	;16-bit words
    8b7a:	30 41       	ret			

00008b7c <sx1278SetMode>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1278SetMode(SX1278Driver *devp, SX1278ModeConstants mode) {
    8b7c:	21 82       	sub	#4,	r1	;r2 As==10

00008b7e <.LCFI18>:
    8b7e:	81 4c 02 00 	mov	r12,	2(r1)	;
    8b82:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008b86 <.Loc.367.3>:
  
  osalDbgAssert(mode < 0x06U, "requested invalid transceiver mode");
  
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    8b86:	1c 41 02 00 	mov	2(r1),	r12	;
    8b8a:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    8b8e:	8c 11       	sxt	r12		;
    8b90:	7c f0 f8 ff 	and.b	#65528,	r12	;#0xfff8
    8b94:	4d 4c       	mov.b	r12,	r13	;
    8b96:	8d 11       	sxt	r13		;
    8b98:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8b9c:	8c 11       	sxt	r12		;
    8b9e:	4c dd       	bis.b	r13,	r12	;
    8ba0:	8c 11       	sxt	r12		;
    8ba2:	4d 4c       	mov.b	r12,	r13	;
    8ba4:	1c 41 02 00 	mov	2(r1),	r12	;
    8ba8:	cc 4d 03 00 	mov.b	r13,	3(r12)	;

00008bac <.Loc.368.3>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    8bac:	1c 41 02 00 	mov	2(r1),	r12	;
    8bb0:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    8bb4:	4e 4c       	mov.b	r12,	r14	;
    8bb6:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8bb8:	1c 41 02 00 	mov	2(r1),	r12	;
    8bbc:	b0 12 ca 84 	call	#33994		;#0x84ca

00008bc0 <.Loc.369.3>:
}
    8bc0:	03 43       	nop			
    8bc2:	21 52       	add	#4,	r1	;r2 As==10
    8bc4:	30 41       	ret			

00008bc6 <sx1278MapIRQs>:
 * 
 * @param[in] devp    pointer to the SX1278 driver
 * @param[in] dio_map the mapping of SX127 IRQ signals to DIO pins
 */
static void sx1278MapIRQs(SX1278Driver *devp, 
    const uint8_t irq_map[IRQMax]) {
    8bc6:	31 82       	sub	#8,	r1	;r2 As==11

00008bc8 <.LCFI19>:
    8bc8:	81 4c 02 00 	mov	r12,	2(r1)	;
    8bcc:	81 4d 00 00 	mov	r13,	0(r1)	;

00008bd0 <.Loc.380.3>:
  uint16_t dio_reg = 0x0000;
    8bd0:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008bd4 <.LBB3>:
  /* Configure IRQ mapping. Mapping PacketSent to DIO0 and FifoLevel to DIO1 
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    8bd4:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00
    8bd8:	1a 3c       	jmp	$+54     	;abs 0x8c0e

00008bda <.L75>:
    if (irq_map[i] > 5) continue;
    8bda:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8bde:	2c 51       	add	@r1,	r12	;
    8be0:	6c 4c       	mov.b	@r12,	r12	;
    8be2:	7d 40 05 00 	mov.b	#5,	r13	;
    8be6:	4d 9c       	cmp.b	r12,	r13	;
    8be8:	07 28       	jnc	$+16     	;abs 0x8bf8

00008bea <.Loc.388.3>:
    switch (i) {
    8bea:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8bee:	0c 93       	cmp	#0,	r12	;r3 As==00
    8bf0:	05 24       	jz	$+12     	;abs 0x8bfc
    8bf2:	1c 93       	cmp	#1,	r12	;r3 As==01
    8bf4:	05 24       	jz	$+12     	;abs 0x8c00

00008bf6 <.Loc.401.3>:
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 4);*/
        break;
      default:
        osalDbgAssert(false, "Invalid IRQ mapping requested");
        break;
    8bf6:	05 3c       	jmp	$+12     	;abs 0x8c02

00008bf8 <.L76>:
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    if (irq_map[i] > 5) continue;
    8bf8:	03 43       	nop			
    8bfa:	03 3c       	jmp	$+8      	;abs 0x8c02

00008bfc <.L77>:
    switch (i) {
      case PacketSent:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 6);*/
        break;
    8bfc:	03 43       	nop			
    8bfe:	01 3c       	jmp	$+4      	;abs 0x8c02

00008c00 <.L78>:
      case FifoLevel:
        osalDbgAssert(irq_map[i] == 1, "IRQ mapping invalid");
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 4);*/
        break;
    8c00:	03 43       	nop			

00008c02 <.L71>:
  /* Configure IRQ mapping. Mapping PacketSent to DIO0 and FifoLevel to DIO1 
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    8c02:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8c06:	4d 4c       	mov.b	r12,	r13	;
    8c08:	5d 53       	inc.b	r13		;
    8c0a:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

00008c0e <.L69>:
    8c0e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c10:	5c 91 07 00 	cmp.b	7(r1),	r12	;
    8c14:	e2 2f       	jc	$-58     	;abs 0x8bda

00008c16 <.LBE3>:
        osalDbgAssert(false, "Invalid IRQ mapping requested");
        break;
    }
  }
  
  sx1278SetRegister(devp, RegDioMapping1, ((uint8_t *)(&dio_reg))[0]);
    8c16:	0c 41       	mov	r1,	r12	;
    8c18:	2c 52       	add	#4,	r12	;r2 As==10
    8c1a:	6c 4c       	mov.b	@r12,	r12	;
    8c1c:	4e 4c       	mov.b	r12,	r14	;
    8c1e:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    8c22:	1c 41 02 00 	mov	2(r1),	r12	;
    8c26:	b0 12 ca 84 	call	#33994		;#0x84ca

00008c2a <.Loc.406.3>:
  sx1278SetRegister(devp, RegDioMapping2, ((uint8_t *)(&dio_reg))[1]);
    8c2a:	0c 41       	mov	r1,	r12	;
    8c2c:	2c 52       	add	#4,	r12	;r2 As==10
    8c2e:	1c 53       	inc	r12		;
    8c30:	6c 4c       	mov.b	@r12,	r12	;
    8c32:	4e 4c       	mov.b	r12,	r14	;
    8c34:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    8c38:	1c 41 02 00 	mov	2(r1),	r12	;
    8c3c:	b0 12 ca 84 	call	#33994		;#0x84ca

00008c40 <.Loc.407.3>:
}
    8c40:	03 43       	nop			
    8c42:	31 52       	add	#8,	r1	;r2 As==11
    8c44:	30 41       	ret			

00008c46 <sx1278ConfigurePackets>:
 * 
 * @param[in] devp          pointer to the SX1278 driver
 * @param[in] packet_config the packet configuration to apply
 */
static void sx1278ConfigurePackets(SX1278Driver* devp, 
    sx1278_packet_config_t *packet_config) {
    8c46:	31 80 06 00 	sub	#6,	r1	;

00008c4a <.LCFI20>:
    8c4a:	81 4c 02 00 	mov	r12,	2(r1)	;

00008c4e <L0>:
    8c4e:	81 4d 00 00 	mov	r13,	0(r1)	;

00008c52 <.Loc.419.3>:
  /* Configure packet mode */
  uint8_t reg = 0x00;
    8c52:	c1 43 05 00 	mov.b	#0,	5(r1)	;r3 As==00

00008c56 <.Loc.422.3>:
  
  /* Unlimited - PacketFormat == 0, PayloadLength == 0 */
  if (packet_config->format == Variable) {
    8c56:	2c 41       	mov	@r1,	r12	;
    8c58:	6c 4c       	mov.b	@r12,	r12	;
    8c5a:	7c f0 03 00 	and.b	#3,	r12	;
    8c5e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c62:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    8c64:	03 20       	jnz	$+8      	;abs 0x8c6c

00008c66 <.Loc.423.3>:
    reg |= 1 << 7;
    8c66:	f1 d0 80 ff 	bis.b	#65408,	5(r1)	;#0xff80
    8c6a:	05 00 

00008c6c <.L83>:
   *  regs |= 0 << 7;
   * }*/
  
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
      "Whitening and Manchester encoding are mutually exclusive");
  reg |= packet_config->whitening << 6;
    8c6c:	2c 41       	mov	@r1,	r12	;
    8c6e:	6c 4c       	mov.b	@r12,	r12	;
    8c70:	5c 07       	rrum	#2,	r12	;
    8c72:	5c f3       	and.b	#1,	r12	;r3 As==01
    8c74:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c78:	45 18 0c 5c 	rpt #6 { rlax.w	r12		;
    8c7c:	4d 4c       	mov.b	r12,	r13	;
    8c7e:	8d 11       	sxt	r13		;
    8c80:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8c84:	8c 11       	sxt	r12		;
    8c86:	4c dd       	bis.b	r13,	r12	;
    8c88:	8c 11       	sxt	r12		;
    8c8a:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00008c8e <.Loc.432.3>:
  reg |= packet_config->manchester << 5;
    8c8e:	2c 41       	mov	@r1,	r12	;
    8c90:	6c 4c       	mov.b	@r12,	r12	;
    8c92:	5c 0b       	rrum	#3,	r12	;
    8c94:	5c f3       	and.b	#1,	r12	;r3 As==01
    8c96:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c9a:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    8c9e:	4d 4c       	mov.b	r12,	r13	;
    8ca0:	8d 11       	sxt	r13		;
    8ca2:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8ca6:	8c 11       	sxt	r12		;
    8ca8:	4c dd       	bis.b	r13,	r12	;
    8caa:	8c 11       	sxt	r12		;
    8cac:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00008cb0 <.Loc.434.3>:
  
  reg |= packet_config->crc << 4;
    8cb0:	2c 41       	mov	@r1,	r12	;
    8cb2:	6c 4c       	mov.b	@r12,	r12	;
    8cb4:	5c 0f       	rrum	#4,	r12	;
    8cb6:	5c f3       	and.b	#1,	r12	;r3 As==01
    8cb8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8cbc:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8cc0:	4d 4c       	mov.b	r12,	r13	;
    8cc2:	8d 11       	sxt	r13		;
    8cc4:	5c 41 05 00 	mov.b	5(r1),	r12	;
    8cc8:	8c 11       	sxt	r12		;
    8cca:	4c dd       	bis.b	r13,	r12	;
    8ccc:	8c 11       	sxt	r12		;
    8cce:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00008cd2 <.Loc.436.3>:
  
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    8cd2:	5e 41 05 00 	mov.b	5(r1),	r14	;
    8cd6:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030
    8cda:	1c 41 02 00 	mov	2(r1),	r12	;
    8cde:	b0 12 ca 84 	call	#33994		;#0x84ca

00008ce2 <.Loc.438.3>:
  
  if (packet_config->format == Fixed) {
    8ce2:	2c 41       	mov	@r1,	r12	;
    8ce4:	6c 4c       	mov.b	@r12,	r12	;
    8ce6:	7c f0 03 00 	and.b	#3,	r12	;
    8cea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8cee:	0c 93       	cmp	#0,	r12	;r3 As==00
    8cf0:	23 20       	jnz	$+72     	;abs 0x8d38

00008cf2 <.Loc.440.3>:
    sx1278SetRegister(devp, RegPacketConfig2, 
        0x40 | (devp->config->length >> 8));
    8cf2:	1c 41 02 00 	mov	2(r1),	r12	;
    8cf6:	2c 4c       	mov	@r12,	r12	;
    8cf8:	1c 4c 2e 00 	mov	46(r12),r12	;0x0002e
    8cfc:	5c 0f       	rrum	#4,	r12	;
    8cfe:	5c 0f       	rrum	#4,	r12	;

00008d00 <.Loc.439.3>:
  reg |= packet_config->crc << 4;
  
  sx1278SetRegister(devp, RegPacketConfig1, reg);
  
  if (packet_config->format == Fixed) {
    sx1278SetRegister(devp, RegPacketConfig2, 
    8d00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d04:	7c d0 40 00 	bis.b	#64,	r12	;#0x0040
    8d08:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d0c:	4e 4c       	mov.b	r12,	r14	;
    8d0e:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    8d12:	1c 41 02 00 	mov	2(r1),	r12	;
    8d16:	b0 12 ca 84 	call	#33994		;#0x84ca

00008d1a <.Loc.441.3>:
        0x40 | (devp->config->length >> 8));
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    8d1a:	1c 41 02 00 	mov	2(r1),	r12	;
    8d1e:	2c 4c       	mov	@r12,	r12	;
    8d20:	1c 4c 2e 00 	mov	46(r12),r12	;0x0002e
    8d24:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d28:	4e 4c       	mov.b	r12,	r14	;
    8d2a:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    8d2e:	1c 41 02 00 	mov	2(r1),	r12	;
    8d32:	b0 12 ca 84 	call	#33994		;#0x84ca

00008d36 <.Loc.447.3>:
  }
  else {
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
  }
}
    8d36:	0f 3c       	jmp	$+32     	;abs 0x8d56

00008d38 <.L81>:
    sx1278SetRegister(devp, RegPacketConfig2, 
        0x40 | (devp->config->length >> 8));
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
  }
  else {
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    8d38:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    8d3c:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    8d40:	1c 41 02 00 	mov	2(r1),	r12	;
    8d44:	b0 12 ca 84 	call	#33994		;#0x84ca

00008d48 <.Loc.445.3>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    8d48:	4e 43       	clr.b	r14		;
    8d4a:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    8d4e:	1c 41 02 00 	mov	2(r1),	r12	;
    8d52:	b0 12 ca 84 	call	#33994		;#0x84ca

00008d56 <.L84>:
  }
}
    8d56:	03 43       	nop			
    8d58:	31 50 06 00 	add	#6,	r1	;
    8d5c:	30 41       	ret			

00008d5e <sx1278ObjectInit>:
 *
 * @param[out] devp     pointer to the @p SX1278Driver object
 *
 * @init
 */
void sx1278ObjectInit(SX1278Driver *devp) {
    8d5e:	21 83       	decd	r1		;

00008d60 <L0>:
    8d60:	81 4c 00 00 	mov	r12,	0(r1)	;

00008d64 <.Loc.548.3>:
  
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    8d64:	2c 41       	mov	@r1,	r12	;
    8d66:	fc 40 09 00 	mov.b	#9,	3(r12)	;
    8d6a:	03 00 

00008d6c <.Loc.549.3>:
  devp->regs.seq_config = 0x00;
    8d6c:	2c 41       	mov	@r1,	r12	;
    8d6e:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

00008d72 <.Loc.551.3>:
  
  devp->state = SX1278_STOP;
    8d72:	2c 41       	mov	@r1,	r12	;
    8d74:	dc 43 02 00 	mov.b	#1,	2(r12)	;r3 As==01

00008d78 <.Loc.552.3>:
}
    8d78:	03 43       	nop			
    8d7a:	21 53       	incd	r1		;
    8d7c:	30 41       	ret			

00008d7e <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    8d7e:	21 82       	sub	#4,	r1	;r2 As==10

00008d80 <.LCFI25>:
    8d80:	81 4c 02 00 	mov	r12,	2(r1)	;
    8d84:	81 4d 00 00 	mov	r13,	0(r1)	;

00008d88 <.Loc.564.3>:
  
  devp->config = config;
    8d88:	1c 41 02 00 	mov	2(r1),	r12	;
    8d8c:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008d90 <.Loc.566.3>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    8d90:	1c 41 02 00 	mov	2(r1),	r12	;
    8d94:	b0 12 88 8a 	call	#35464		;#0x8a88

00008d98 <.Loc.571.3>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    8d98:	2c 41       	mov	@r1,	r12	;
    8d9a:	2c 4c       	mov	@r12,	r12	;
    8d9c:	2d 41       	mov	@r1,	r13	;
    8d9e:	1d 4d 02 00 	mov	2(r13),	r13	;
    8da2:	b0 12 f2 6b 	call	#27634		;#0x6bf2

00008da6 <.Loc.573.3>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, Sleep);
    8da6:	4d 43       	clr.b	r13		;
    8da8:	1c 41 02 00 	mov	2(r1),	r12	;
    8dac:	b0 12 7c 8b 	call	#35708		;#0x8b7c

00008db0 <.Loc.575.3>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    8db0:	2c 41       	mov	@r1,	r12	;
    8db2:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    8db6:	1c 4c 08 00 	mov	8(r12),	r12	;
    8dba:	0e 4d       	mov	r13,	r14	;
    8dbc:	0d 4c       	mov	r12,	r13	;
    8dbe:	1c 41 02 00 	mov	2(r1),	r12	;
    8dc2:	b0 12 06 86 	call	#34310		;#0x8606

00008dc6 <.Loc.576.3>:
  sx1278SetDeviation(devp, config->fdev);
    8dc6:	2c 41       	mov	@r1,	r12	;
    8dc8:	1d 4c 0e 00 	mov	14(r12),r13	;0x0000e
    8dcc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8dd0:	0e 4d       	mov	r13,	r14	;
    8dd2:	0d 4c       	mov	r12,	r13	;
    8dd4:	1c 41 02 00 	mov	2(r1),	r12	;
    8dd8:	b0 12 ac 85 	call	#34220		;#0x85ac

00008ddc <.Loc.577.3>:
  sx1278SetBitrate(devp, config->bitrate);
    8ddc:	2c 41       	mov	@r1,	r12	;
    8dde:	1d 4c 06 00 	mov	6(r12),	r13	;
    8de2:	1c 4c 04 00 	mov	4(r12),	r12	;
    8de6:	0e 4d       	mov	r13,	r14	;
    8de8:	0d 4c       	mov	r12,	r13	;
    8dea:	1c 41 02 00 	mov	2(r1),	r12	;
    8dee:	b0 12 22 85 	call	#34082		;#0x8522

00008df2 <.Loc.578.3>:
  sx1278SetPower(devp, config->pow);
    8df2:	2c 41       	mov	@r1,	r12	;
    8df4:	1e 4c 10 00 	mov	16(r12),r14	;0x00010
    8df8:	1f 4c 12 00 	mov	18(r12),r15	;0x00012
    8dfc:	0d 4e       	mov	r14,	r13	;
    8dfe:	0e 4f       	mov	r15,	r14	;
    8e00:	1c 41 02 00 	mov	2(r1),	r12	;
    8e04:	b0 12 66 87 	call	#34662		;#0x8766

00008e08 <.Loc.579.3>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    8e08:	2c 41       	mov	@r1,	r12	;
    8e0a:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    8e0e:	0d 4c       	mov	r12,	r13	;
    8e10:	1c 41 02 00 	mov	2(r1),	r12	;
    8e14:	b0 12 88 89 	call	#35208		;#0x8988

00008e18 <.Loc.580.3>:
  sx1278SetSync(devp, config->sync_word);
    8e18:	2c 41       	mov	@r1,	r12	;
    8e1a:	1d 4c 18 00 	mov	24(r12),r13	;0x00018
    8e1e:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    8e22:	0e 4d       	mov	r13,	r14	;
    8e24:	0d 4c       	mov	r12,	r13	;
    8e26:	1c 41 02 00 	mov	2(r1),	r12	;
    8e2a:	b0 12 c4 89 	call	#35268		;#0x89c4

00008e2e <.Loc.586.3>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 and LowPowerSelection
  Don't set SequencerStart, SequencerStop, FromTransmit
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x1C;
    8e2e:	1c 41 02 00 	mov	2(r1),	r12	;
    8e32:	fc 40 1c 00 	mov.b	#28,	4(r12)	;#0x001c
    8e36:	04 00 

00008e38 <.Loc.591.3>:
  
  osalDbgAssert(devp->config->idle_mode == Sleep ||
      devp->config->idle_mode == Stdby, "Unsupported Idle Mode requested");
  
  if (devp->config->idle_mode == Sleep) {
    8e38:	1c 41 02 00 	mov	2(r1),	r12	;
    8e3c:	2c 4c       	mov	@r12,	r12	;
    8e3e:	5c 4c 30 00 	mov.b	48(r12),r12	;0x00030
    8e42:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e44:	0b 20       	jnz	$+24     	;abs 0x8e5c

00008e46 <.Loc.592.3>:
    devp->regs.seq_config |= 0x20;
    8e46:	1c 41 02 00 	mov	2(r1),	r12	;
    8e4a:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    8e4e:	7c d0 20 00 	bis.b	#32,	r12	;#0x0020
    8e52:	4d 4c       	mov.b	r12,	r13	;
    8e54:	1c 41 02 00 	mov	2(r1),	r12	;
    8e58:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

00008e5c <.L105>:
  }
  /* else Stdby is assumed */
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    8e5c:	1c 41 02 00 	mov	2(r1),	r12	;
    8e60:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    8e64:	4e 4c       	mov.b	r12,	r14	;
    8e66:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    8e6a:	1c 41 02 00 	mov	2(r1),	r12	;
    8e6e:	b0 12 ca 84 	call	#33994		;#0x84ca

00008e72 <.Loc.598.3>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    8e72:	1c 41 02 00 	mov	2(r1),	r12	;
    8e76:	2c 4c       	mov	@r12,	r12	;
    8e78:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    8e7c:	0d 4c       	mov	r12,	r13	;
    8e7e:	1c 41 02 00 	mov	2(r1),	r12	;
    8e82:	b0 12 46 8c 	call	#35910		;#0x8c46

00008e86 <.Loc.600.3>:
  
  sx1278MapIRQs(devp, devp->config->irq_map);
    8e86:	1c 41 02 00 	mov	2(r1),	r12	;
    8e8a:	2c 4c       	mov	@r12,	r12	;
    8e8c:	3c 50 1a 00 	add	#26,	r12	;#0x001a
    8e90:	0d 4c       	mov	r12,	r13	;
    8e92:	1c 41 02 00 	mov	2(r1),	r12	;
    8e96:	b0 12 c6 8b 	call	#35782		;#0x8bc6

00008e9a <.Loc.606.3>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    8e9a:	1c 41 02 00 	mov	2(r1),	r12	;
    8e9e:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10

00008ea2 <.Loc.607.3>:
}
    8ea2:	03 43       	nop			
    8ea4:	21 52       	add	#4,	r1	;r2 As==10
    8ea6:	30 41       	ret			

00008ea8 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    8ea8:	ff 3f       	jmp	$+0      	;abs 0x8ea8

00008eaa <Vector2>:
    8eaa:	ff 3f       	jmp	$+0      	;abs 0x8eaa

00008eac <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    8eac:	ff 3f       	jmp	$+0      	;abs 0x8eac

00008eae <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    8eae:	ff 3f       	jmp	$+0      	;abs 0x8eae

00008eb0 <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    8eb0:	ff 3f       	jmp	$+0      	;abs 0x8eb0

00008eb2 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    8eb2:	ff 3f       	jmp	$+0      	;abs 0x8eb2

00008eb4 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    8eb4:	ff 3f       	jmp	$+0      	;abs 0x8eb4

00008eb6 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    8eb6:	ff 3f       	jmp	$+0      	;abs 0x8eb6

00008eb8 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    8eb8:	ff 3f       	jmp	$+0      	;abs 0x8eb8

00008eba <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    8eba:	ff 3f       	jmp	$+0      	;abs 0x8eba

00008ebc <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    8ebc:	ff 3f       	jmp	$+0      	;abs 0x8ebc

00008ebe <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    8ebe:	ff 3f       	jmp	$+0      	;abs 0x8ebe

00008ec0 <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    8ec0:	ff 3f       	jmp	$+0      	;abs 0x8ec0

00008ec2 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    8ec2:	ff 3f       	jmp	$+0      	;abs 0x8ec2

00008ec4 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    8ec4:	ff 3f       	jmp	$+0      	;abs 0x8ec4

00008ec6 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    8ec6:	ff 3f       	jmp	$+0      	;abs 0x8ec6

00008ec8 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    8ec8:	ff 3f       	jmp	$+0      	;abs 0x8ec8

00008eca <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    8eca:	ff 3f       	jmp	$+0      	;abs 0x8eca

00008ecc <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    8ecc:	ff 3f       	jmp	$+0      	;abs 0x8ecc

00008ece <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    8ece:	ff 3f       	jmp	$+0      	;abs 0x8ece

00008ed0 <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    8ed0:	ff 3f       	jmp	$+0      	;abs 0x8ed0

00008ed2 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    8ed2:	ff 3f       	jmp	$+0      	;abs 0x8ed2

00008ed4 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    8ed4:	ff 3f       	jmp	$+0      	;abs 0x8ed4

00008ed6 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    8ed6:	ff 3f       	jmp	$+0      	;abs 0x8ed6

00008ed8 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    8ed8:	ff 3f       	jmp	$+0      	;abs 0x8ed8

00008eda <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    8eda:	ff 3f       	jmp	$+0      	;abs 0x8eda

00008edc <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    8edc:	ff 3f       	jmp	$+0      	;abs 0x8edc

00008ede <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    8ede:	ff 3f       	jmp	$+0      	;abs 0x8ede

00008ee0 <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    8ee0:	ff 3f       	jmp	$+0      	;abs 0x8ee0

00008ee2 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    8ee2:	ff 3f       	jmp	$+0      	;abs 0x8ee2

00008ee4 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    8ee4:	ff 3f       	jmp	$+0      	;abs 0x8ee4

00008ee6 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    8ee6:	ff 3f       	jmp	$+0      	;abs 0x8ee6

00008ee8 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    8ee8:	ff 3f       	jmp	$+0      	;abs 0x8ee8

00008eea <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    8eea:	ff 3f       	jmp	$+0      	;abs 0x8eea

00008eec <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    8eec:	ff 3f       	jmp	$+0      	;abs 0x8eec

00008eee <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    8eee:	ff 3f       	jmp	$+0      	;abs 0x8eee

00008ef0 <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    8ef0:	ff 3f       	jmp	$+0      	;abs 0x8ef0

00008ef2 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    8ef2:	ff 3f       	jmp	$+0      	;abs 0x8ef2

00008ef4 <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    8ef4:	ff 3f       	jmp	$+0      	;abs 0x8ef4

00008ef6 <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    8ef6:	ff 3f       	jmp	$+0      	;abs 0x8ef6

00008ef8 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    8ef8:	ff 3f       	jmp	$+0      	;abs 0x8ef8

00008efa <Vector48>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    8efa:	ff 3f       	jmp	$+0      	;abs 0x8efa

00008efc <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    8efc:	ff 3f       	jmp	$+0      	;abs 0x8efc

00008efe <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    8efe:	ff 3f       	jmp	$+0      	;abs 0x8efe

00008f00 <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    8f00:	ff 3f       	jmp	$+0      	;abs 0x8f00

00008f02 <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    8f02:	ff 3f       	jmp	$+0      	;abs 0x8f02

00008f04 <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    8f04:	ff 3f       	jmp	$+0      	;abs 0x8f04

00008f06 <Thread2>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    8f06:	21 83       	decd	r1		;

00008f08 <L0>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    8f08:	81 4c 00 00 	mov	r12,	0(r1)	;

00008f0c <.Loc.142.1>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    8f0c:	4d 43       	clr.b	r13		;
    8f0e:	3c 40 72 51 	mov	#20850,	r12	;#0x5172
    8f12:	b0 12 f4 6a 	call	#27380		;#0x6af4

00008f16 <.Loc.145.1>:
  
  /* Activate the ADC driver 1 using its config */
  adcStart(&ADCD1, &adc_config);
    8f16:	3d 40 00 51 	mov	#20736,	r13	;#0x5100
    8f1a:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    8f1e:	b0 12 80 68 	call	#26752		;#0x6880

00008f22 <.Loc.148.1>:

  /* Initialize the SX1212 driver */
  sx1278ObjectInit(&SX1278D1);
    8f22:	3c 40 98 52 	mov	#21144,	r12	;#0x5298
    8f26:	b0 12 5e 8d 	call	#36190		;#0x8d5e

00008f2a <.Loc.151.1>:
  
  /* Start the SX1212 driver */
  sx1278Start(&SX1278D1, &config);
    8f2a:	3d 40 0e 51 	mov	#20750,	r13	;#0x510e
    8f2e:	3c 40 98 52 	mov	#21144,	r12	;#0x5298
    8f32:	b0 12 7e 8d 	call	#36222		;#0x8d7e

00008f36 <.Loc.155.1>:

  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    8f36:	04 3c       	jmp	$+10     	;abs 0x8f40

00008f38 <.L20>:
    
    chThdSleepMilliseconds(2000);
    8f38:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    8f3c:	b0 12 a4 5f 	call	#24484		;#0x5fa4

00008f40 <.L19>:
  /* Start the SX1212 driver */
  sx1278Start(&SX1278D1, &config);

  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    8f40:	1c 42 72 51 	mov	&0x5172,r12	;0x5172
    8f44:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    8f48:	4d 43       	clr.b	r13		;
    8f4a:	3c 40 72 51 	mov	#20850,	r12	;#0x5172
    8f4e:	8e 12       	call	r14		;
    8f50:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f52:	f2 23       	jnz	$-26     	;abs 0x8f38

00008f54 <.Loc.159.1>:
    
    chThdSleepMilliseconds(2000);
  }
}
    8f54:	03 43       	nop			
    8f56:	21 53       	incd	r1		;
    8f58:	30 41       	ret			

00008f5a <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    8f5a:	b2 40 80 5a 	Address 0x0000000000008f5c is out of bounds.
Address 0x0000000000008f5e is out of bounds.
mov	#65535,	&0xffff	;#0xffff
    8f5e:	5c 01 

00008f5c <L0>:
    8f5c:	80 5a 5c 01 	add	r10,	0x015c	; PC rel. 0x90ba

00008f60 <.Loc.184.1>:
  

  halInit();
    8f60:	b0 12 d6 61 	call	#25046		;#0x61d6

00008f64 <.Loc.185.1>:
  chSysInit();
    8f64:	b0 12 9c 5c 	call	#23708		;#0x5c9c

00008f68 <.Loc.186.1>:
  dmaInit();
    8f68:	b0 12 c4 79 	call	#31172		;#0x79c4

00008f6c <.L22>:
  
  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    8f6c:	ff 3f       	jmp	$+0      	;abs 0x8f6c

00008f6e <__mspabi_mpyll>:
    8f6e:	6a 15       	pushm	#7,	r10	;16-bit words

00008f70 <L0>:
    8f70:	31 80 1c 00 	sub	#28,	r1	;#0x001c

00008f74 <.LCFI1>:
    8f74:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    8f78:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    8f7c:	06 4c       	mov	r12,	r6	;
    8f7e:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    8f82:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    8f86:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

00008f8a <.LBB2>:
    8f8a:	0a 48       	mov	r8,	r10	;
    8f8c:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    8f90:	0c 48       	mov	r8,	r12	;

00008f92 <.LVL3>:
    8f92:	0d 49       	mov	r9,	r13	;
    8f94:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8f98:	b0 12 4e a4 	call	#42062		;#0xa44e
    8f9c:	81 4c 00 00 	mov	r12,	0(r1)	;
    8fa0:	81 4d 02 00 	mov	r13,	2(r1)	;

00008fa4 <.LVL5>:
    8fa4:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    8fa8:	0c 46       	mov	r6,	r12	;
    8faa:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8fae:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8fb2:	b0 12 4e a4 	call	#42062		;#0xa44e
    8fb6:	81 4c 04 00 	mov	r12,	4(r1)	;
    8fba:	81 4d 06 00 	mov	r13,	6(r1)	;
    8fbe:	38 40 54 ad 	mov	#44372,	r8	;#0xad54

00008fc2 <.LVL9>:
    8fc2:	0e 46       	mov	r6,	r14	;
    8fc4:	4f 43       	clr.b	r15		;
    8fc6:	0c 4a       	mov	r10,	r12	;
    8fc8:	0d 4f       	mov	r15,	r13	;
    8fca:	88 12       	call	r8		;

00008fcc <.LVL10>:
    8fcc:	04 4c       	mov	r12,	r4	;
    8fce:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    8fd2:	05 4d       	mov	r13,	r5	;

00008fd4 <.LVL11>:
    8fd4:	0e 46       	mov	r6,	r14	;
    8fd6:	4f 43       	clr.b	r15		;
    8fd8:	2c 41       	mov	@r1,	r12	;
    8fda:	1d 41 02 00 	mov	2(r1),	r13	;
    8fde:	88 12       	call	r8		;

00008fe0 <.LVL12>:
    8fe0:	06 4c       	mov	r12,	r6	;
    8fe2:	07 4d       	mov	r13,	r7	;

00008fe4 <.LVL14>:
    8fe4:	1e 41 04 00 	mov	4(r1),	r14	;
    8fe8:	1f 41 06 00 	mov	6(r1),	r15	;
    8fec:	2c 41       	mov	@r1,	r12	;
    8fee:	1d 41 02 00 	mov	2(r1),	r13	;
    8ff2:	88 12       	call	r8		;

00008ff4 <.LVL15>:
    8ff4:	81 4c 00 00 	mov	r12,	0(r1)	;

00008ff8 <.LVL16>:
    8ff8:	81 4d 02 00 	mov	r13,	2(r1)	;

00008ffc <.LVL17>:
    8ffc:	1e 41 04 00 	mov	4(r1),	r14	;
    9000:	1f 41 06 00 	mov	6(r1),	r15	;
    9004:	0c 4a       	mov	r10,	r12	;
    9006:	4d 43       	clr.b	r13		;
    9008:	88 12       	call	r8		;

0000900a <.LVL18>:
    900a:	0a 4c       	mov	r12,	r10	;
    900c:	0a 56       	add	r6,	r10	;
    900e:	08 4d       	mov	r13,	r8	;
    9010:	08 67       	addc	r7,	r8	;
    9012:	0c 44       	mov	r4,	r12	;
    9014:	0d 45       	mov	r5,	r13	;
    9016:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    901a:	b0 12 4e a4 	call	#42062		;#0xa44e
    901e:	05 4c       	mov	r12,	r5	;

00009020 <.LVL22>:
    9020:	05 5a       	add	r10,	r5	;
    9022:	0d 68       	addc	r8,	r13	;

00009024 <.LVL23>:
    9024:	0d 97       	cmp	r7,	r13	;
    9026:	04 28       	jnc	$+10     	;abs 0x9030
    9028:	07 9d       	cmp	r13,	r7	;
    902a:	06 20       	jnz	$+14     	;abs 0x9038
    902c:	05 96       	cmp	r6,	r5	;
    902e:	04 2c       	jc	$+10     	;abs 0x9038

00009030 <.L4>:
    9030:	81 53 00 00 	add	#0,	0(r1)	;r3 As==00
    9034:	91 63 02 00 	addc	#1,	2(r1)	;r3 As==01

00009038 <.L2>:
    9038:	0c 45       	mov	r5,	r12	;
    903a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    903e:	b0 12 4e a4 	call	#42062		;#0xa44e

00009042 <.LVL25>:
    9042:	28 41       	mov	@r1,	r8	;
    9044:	08 5c       	add	r12,	r8	;
    9046:	1d 61 02 00 	addc	2(r1),	r13	;
    904a:	0a 4d       	mov	r13,	r10	;
    904c:	47 43       	clr.b	r7		;

0000904e <.LVL27>:
    904e:	0c 45       	mov	r5,	r12	;
    9050:	0d 47       	mov	r7,	r13	;
    9052:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9056:	b0 12 9a a3 	call	#41882		;#0xa39a
    905a:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    905e:	0c 5f       	add	r15,	r12	;
    9060:	0d 67       	addc	r7,	r13	;

00009062 <.LBE2>:
    9062:	04 4c       	mov	r12,	r4	;
    9064:	05 4d       	mov	r13,	r5	;
    9066:	06 48       	mov	r8,	r6	;
    9068:	07 4a       	mov	r10,	r7	;

0000906a <.Loc.553.1>:
    906a:	3a 40 54 ad 	mov	#44372,	r10	;#0xad54
    906e:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    9072:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    9076:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    907a:	0d 49       	mov	r9,	r13	;
    907c:	8a 12       	call	r10		;

0000907e <.LVL29>:
    907e:	09 4c       	mov	r12,	r9	;
    9080:	08 4d       	mov	r13,	r8	;

00009082 <.Loc.554.1>:
    9082:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    9086:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    908a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    908e:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    9092:	8a 12       	call	r10		;

00009094 <.LVL30>:
    9094:	09 5c       	add	r12,	r9	;
    9096:	81 49 08 00 	mov	r9,	8(r1)	;
    909a:	08 6d       	addc	r13,	r8	;
    909c:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a

000090a0 <.Loc.553.1>:
    90a0:	16 51 08 00 	add	8(r1),	r6	;
    90a4:	17 61 0a 00 	addc	10(r1),	r7	;0x0000a

000090a8 <.Loc.557.1>:
    90a8:	0c 44       	mov	r4,	r12	;
    90aa:	0d 45       	mov	r5,	r13	;
    90ac:	0e 46       	mov	r6,	r14	;
    90ae:	0f 47       	mov	r7,	r15	;
    90b0:	31 50 1c 00 	add	#28,	r1	;#0x001c

000090b4 <.LVL31>:
    90b4:	64 17       	popm	#7,	r10	;16-bit words
    90b6:	30 41       	ret			

000090b8 <__fixunssfsi>:
    90b8:	2a 15       	pushm	#3,	r10	;16-bit words

000090ba <.LCFI0>:
    90ba:	08 4c       	mov	r12,	r8	;
    90bc:	09 4d       	mov	r13,	r9	;

000090be <.Loc.1810.1>:
    90be:	4e 43       	clr.b	r14		;
    90c0:	3f 40 00 4f 	mov	#20224,	r15	;#0x4f00
    90c4:	b0 12 cc 93 	call	#37836		;#0x93cc

000090c8 <.LVL1>:
    90c8:	3a 40 22 94 	mov	#37922,	r10	;#0x9422
    90cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    90ce:	0d 38       	jl	$+28     	;abs 0x90ea

000090d0 <.Loc.1811.1>:
    90d0:	4e 43       	clr.b	r14		;
    90d2:	3f 40 00 4f 	mov	#20224,	r15	;#0x4f00
    90d6:	0c 48       	mov	r8,	r12	;
    90d8:	0d 49       	mov	r9,	r13	;
    90da:	b0 12 7a 93 	call	#37754		;#0x937a
    90de:	8a 12       	call	r10		;

000090e0 <.LVL3>:
    90e0:	0c 53       	add	#0,	r12	;r3 As==00
    90e2:	3d 60 00 80 	addc	#32768,	r13	;#0x8000

000090e6 <.L1>:
    90e6:	28 17       	popm	#3,	r10	;16-bit words
    90e8:	30 41       	ret			

000090ea <.L6>:
    90ea:	0c 48       	mov	r8,	r12	;
    90ec:	0d 49       	mov	r9,	r13	;
    90ee:	8a 12       	call	r10		;
    90f0:	fa 3f       	jmp	$-10     	;abs 0x90e6

000090f2 <__mspabi_fixdul>:
    90f2:	6a 15       	pushm	#7,	r10	;16-bit words

000090f4 <L0>:
    90f4:	31 82       	sub	#8,	r1	;r2 As==11

000090f6 <.LCFI1>:
    90f6:	08 4c       	mov	r12,	r8	;
    90f8:	09 4d       	mov	r13,	r9	;
    90fa:	0a 4e       	mov	r14,	r10	;
    90fc:	05 4f       	mov	r15,	r5	;

000090fe <.Loc.1800.1>:
    90fe:	47 43       	clr.b	r7		;
    9100:	34 40 e0 41 	mov	#16864,	r4	;#0x41e0
    9104:	81 47 00 00 	mov	r7,	0(r1)	;
    9108:	81 47 02 00 	mov	r7,	2(r1)	;
    910c:	81 47 04 00 	mov	r7,	4(r1)	;
    9110:	81 44 06 00 	mov	r4,	6(r1)	;
    9114:	b0 12 12 a1 	call	#41234		;#0xa112

00009118 <.LVL1>:
    9118:	36 40 84 a1 	mov	#41348,	r6	;#0xa184
    911c:	0c 97       	cmp	r7,	r12	;
    911e:	0e 38       	jl	$+30     	;abs 0x913c

00009120 <.Loc.1801.1>:
    9120:	0c 47       	mov	r7,	r12	;
    9122:	0d 47       	mov	r7,	r13	;
    9124:	0e 47       	mov	r7,	r14	;
    9126:	0f 44       	mov	r4,	r15	;
    9128:	0b 45       	mov	r5,	r11	;
    912a:	b0 12 72 9b 	call	#39794		;#0x9b72
    912e:	86 12       	call	r6		;

00009130 <.LVL3>:
    9130:	0c 53       	add	#0,	r12	;r3 As==00
    9132:	3d 60 00 80 	addc	#32768,	r13	;#0x8000

00009136 <.L1>:
    9136:	31 52       	add	#8,	r1	;r2 As==11
    9138:	64 17       	popm	#7,	r10	;16-bit words
    913a:	30 41       	ret			

0000913c <.L6>:
    913c:	0c 48       	mov	r8,	r12	;
    913e:	0d 49       	mov	r9,	r13	;
    9140:	0e 4a       	mov	r10,	r14	;
    9142:	0f 45       	mov	r5,	r15	;
    9144:	86 12       	call	r6		;
    9146:	f7 3f       	jmp	$-16     	;abs 0x9136

00009148 <_fpadd_parts>:
    9148:	6a 15       	pushm	#7,	r10	;16-bit words

0000914a <L0>:
    914a:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000914e <.LCFI1>:
    914e:	08 4c       	mov	r12,	r8	;
    9150:	09 4d       	mov	r13,	r9	;
    9152:	0a 4e       	mov	r14,	r10	;
    9154:	2c 4c       	mov	@r12,	r12	;

00009156 <.LVL1>:
    9156:	5d 43       	mov.b	#1,	r13	;r3 As==01

00009158 <.LVL2>:
    9158:	0d 9c       	cmp	r12,	r13	;
    915a:	0b 2d       	jc	$+536    	;abs 0x9372
    915c:	2d 49       	mov	@r9,	r13	;

0000915e <.Loc.597.1>:
    915e:	5e 43       	mov.b	#1,	r14	;r3 As==01

00009160 <.LVL4>:
    9160:	0e 9d       	cmp	r13,	r14	;
    9162:	09 2d       	jc	$+532    	;abs 0x9376

00009164 <.Loc.601.1>:
    9164:	2c 92       	cmp	#4,	r12	;r2 As==10
    9166:	0e 20       	jnz	$+30     	;abs 0x9184
    9168:	0a 48       	mov	r8,	r10	;

0000916a <.LVL7>:
    916a:	2d 92       	cmp	#4,	r13	;r2 As==10
    916c:	06 20       	jnz	$+14     	;abs 0x917a

0000916e <.Loc.604.1>:
    916e:	98 99 02 00 	cmp	2(r9),	2(r8)	;
    9172:	02 00 
    9174:	02 24       	jz	$+6      	;abs 0x917a

00009176 <.Loc.605.1>:
    9176:	3a 40 a0 50 	mov	#20640,	r10	;#0x50a0

0000917a <.L1>:
    917a:	0c 4a       	mov	r10,	r12	;
    917c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    9180:	64 17       	popm	#7,	r10	;16-bit words
    9182:	30 41       	ret			

00009184 <.L3>:
    9184:	2d 92       	cmp	#4,	r13	;r2 As==10
    9186:	f7 24       	jz	$+496    	;abs 0x9376

00009188 <.Loc.612.1>:
    9188:	2d 93       	cmp	#2,	r13	;r3 As==10
    918a:	0f 20       	jnz	$+32     	;abs 0x91aa

0000918c <.Loc.614.1>:
    918c:	2c 93       	cmp	#2,	r12	;r3 As==10
    918e:	f1 20       	jnz	$+484    	;abs 0x9372

00009190 <.Loc.616.1>:
    9190:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    9194:	0d 48       	mov	r8,	r13	;
    9196:	0c 4a       	mov	r10,	r12	;
    9198:	b0 12 74 ad 	call	#44404		;#0xad74

0000919c <.LVL12>:
    919c:	18 48 02 00 	mov	2(r8),	r8	;

000091a0 <.LVL13>:
    91a0:	18 f9 02 00 	and	2(r9),	r8	;
    91a4:	8a 48 02 00 	mov	r8,	2(r10)	;

000091a8 <.Loc.618.1>:
    91a8:	e8 3f       	jmp	$-46     	;abs 0x917a

000091aa <.L4>:
    91aa:	2c 93       	cmp	#2,	r12	;r3 As==10
    91ac:	e4 24       	jz	$+458    	;abs 0x9376

000091ae <.LBB21>:
    91ae:	17 48 04 00 	mov	4(r8),	r7	;

000091b2 <.LVL15>:
    91b2:	1d 49 04 00 	mov	4(r9),	r13	;

000091b6 <.LVL16>:
    91b6:	91 48 06 00 	mov	6(r8),	0(r1)	;
    91ba:	00 00 
    91bc:	91 48 08 00 	mov	8(r8),	2(r1)	;
    91c0:	02 00 

000091c2 <.LVL17>:
    91c2:	14 49 06 00 	mov	6(r9),	r4	;
    91c6:	15 49 08 00 	mov	8(r9),	r5	;

000091ca <.LVL18>:
    91ca:	0c 47       	mov	r7,	r12	;
    91cc:	0c 8d       	sub	r13,	r12	;

000091ce <.LVL19>:
    91ce:	06 4c       	mov	r12,	r6	;
    91d0:	0c 93       	cmp	#0,	r12	;r3 As==00
    91d2:	02 34       	jge	$+6      	;abs 0x91d8
    91d4:	06 43       	clr	r6		;
    91d6:	06 8c       	sub	r12,	r6	;

000091d8 <.L5>:
    91d8:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    91dc:	0e 96       	cmp	r6,	r14	;
    91de:	92 38       	jl	$+294    	;abs 0x9304

000091e0 <.Loc.645.1>:
    91e0:	4d 43       	clr.b	r13		;

000091e2 <.LVL21>:
    91e2:	0d 9c       	cmp	r12,	r13	;
    91e4:	63 34       	jge	$+200    	;abs 0x92ac

000091e6 <.LVL22>:
    91e6:	0c 46       	mov	r6,	r12	;
    91e8:	0d 43       	clr	r13		;

000091ea <.LVL23>:
    91ea:	81 4c 04 00 	mov	r12,	4(r1)	;
    91ee:	81 4d 06 00 	mov	r13,	6(r1)	;
    91f2:	0c 44       	mov	r4,	r12	;
    91f4:	0d 45       	mov	r5,	r13	;
    91f6:	1e 41 04 00 	mov	4(r1),	r14	;
    91fa:	b0 12 4e a4 	call	#42062		;#0xa44e

000091fe <.LVL24>:
    91fe:	81 4c 08 00 	mov	r12,	8(r1)	;
    9202:	06 4d       	mov	r13,	r6	;

00009204 <.LVL25>:
    9204:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9206:	4d 43       	clr.b	r13		;
    9208:	1e 41 04 00 	mov	4(r1),	r14	;
    920c:	b0 12 9a a3 	call	#41882		;#0xa39a
    9210:	3c 53       	add	#-1,	r12	;r3 As==11
    9212:	3d 63       	addc	#-1,	r13	;r3 As==11
    9214:	0c f4       	and	r4,	r12	;
    9216:	0d f5       	and	r5,	r13	;
    9218:	0c dd       	bis	r13,	r12	;
    921a:	0d 43       	clr	r13		;
    921c:	0d 8c       	sub	r12,	r13	;
    921e:	0c dd       	bis	r13,	r12	;
    9220:	5c 03       	rrum	#1,	r12	;
    9222:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    9226:	14 41 08 00 	mov	8(r1),	r4	;

0000922a <.LVL27>:
    922a:	04 dc       	bis	r12,	r4	;
    922c:	05 46       	mov	r6,	r5	;

0000922e <.L8>:
    922e:	1c 48 02 00 	mov	2(r8),	r12	;
    9232:	1c 99 02 00 	cmp	2(r9),	r12	;
    9236:	8f 24       	jz	$+288    	;abs 0x9356

00009238 <.Loc.674.1>:
    9238:	0c 93       	cmp	#0,	r12	;r3 As==00
    923a:	6f 24       	jz	$+224    	;abs 0x931a

0000923c <.Loc.676.1>:
    923c:	0c 44       	mov	r4,	r12	;
    923e:	0d 45       	mov	r5,	r13	;
    9240:	2c 81       	sub	@r1,	r12	;
    9242:	1d 71 02 00 	subc	2(r1),	r13	;

00009246 <.L11>:
    9246:	0d 93       	cmp	#0,	r13	;r3 As==00
    9248:	6e 38       	jl	$+222    	;abs 0x9326

0000924a <.Loc.684.1>:
    924a:	8a 43 02 00 	mov	#0,	2(r10)	;r3 As==00

0000924e <.Loc.685.1>:
    924e:	8a 47 04 00 	mov	r7,	4(r10)	;

00009252 <.Loc.686.1>:
    9252:	8a 4c 06 00 	mov	r12,	6(r10)	;
    9256:	8a 4d 08 00 	mov	r13,	8(r10)	;

0000925a <.L14>:
    925a:	1c 4a 06 00 	mov	6(r10),	r12	;
    925e:	1d 4a 08 00 	mov	8(r10),	r13	;
    9262:	0f 4c       	mov	r12,	r15	;
    9264:	3f 53       	add	#-1,	r15	;r3 As==11
    9266:	0e 4d       	mov	r13,	r14	;
    9268:	3e 63       	addc	#-1,	r14	;r3 As==11
    926a:	39 40 ff 3f 	mov	#16383,	r9	;#0x3fff
    926e:	09 9e       	cmp	r14,	r9	;
    9270:	06 28       	jnc	$+14     	;abs 0x927e
    9272:	0e 99       	cmp	r9,	r14	;
    9274:	67 20       	jnz	$+208    	;abs 0x9344
    9276:	3e 40 fe ff 	mov	#65534,	r14	;#0xfffe
    927a:	0e 9f       	cmp	r15,	r14	;
    927c:	63 2c       	jc	$+200    	;abs 0x9344

0000927e <.L18>:
    927e:	ba 40 03 00 	mov	#3,	0(r10)	;
    9282:	00 00 

00009284 <.Loc.712.1>:
    9284:	1c 4a 06 00 	mov	6(r10),	r12	;
    9288:	1d 4a 08 00 	mov	8(r10),	r13	;
    928c:	0d 93       	cmp	#0,	r13	;r3 As==00
    928e:	75 37       	jge	$-276    	;abs 0x917a

00009290 <.Loc.714.1>:
    9290:	0e 4c       	mov	r12,	r14	;
    9292:	0f 4d       	mov	r13,	r15	;
    9294:	12 c3       	clrc			
    9296:	0f 10       	rrc	r15		;
    9298:	0e 10       	rrc	r14		;
    929a:	5c f3       	and.b	#1,	r12	;r3 As==01
    929c:	0c de       	bis	r14,	r12	;
    929e:	8a 4c 06 00 	mov	r12,	6(r10)	;
    92a2:	8a 4f 08 00 	mov	r15,	8(r10)	;

000092a6 <.Loc.715.1>:
    92a6:	9a 53 04 00 	inc	4(r10)		;
    92aa:	67 3f       	jmp	$-304    	;abs 0x917a

000092ac <.L7>:
    92ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    92ae:	bf 27       	jz	$-128    	;abs 0x922e

000092b0 <.Loc.652.1>:
    92b0:	07 56       	add	r6,	r7	;

000092b2 <.Loc.653.1>:
    92b2:	0c 46       	mov	r6,	r12	;
    92b4:	0d 43       	clr	r13		;

000092b6 <.LVL33>:
    92b6:	81 4c 04 00 	mov	r12,	4(r1)	;
    92ba:	81 4d 06 00 	mov	r13,	6(r1)	;
    92be:	2c 41       	mov	@r1,	r12	;
    92c0:	1d 41 02 00 	mov	2(r1),	r13	;
    92c4:	1e 41 04 00 	mov	4(r1),	r14	;
    92c8:	b0 12 4e a4 	call	#42062		;#0xa44e

000092cc <.LVL34>:
    92cc:	06 4c       	mov	r12,	r6	;

000092ce <.LVL35>:
    92ce:	81 4d 08 00 	mov	r13,	8(r1)	;
    92d2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    92d4:	4d 43       	clr.b	r13		;
    92d6:	1e 41 04 00 	mov	4(r1),	r14	;
    92da:	b0 12 9a a3 	call	#41882		;#0xa39a
    92de:	3c 53       	add	#-1,	r12	;r3 As==11
    92e0:	3d 63       	addc	#-1,	r13	;r3 As==11
    92e2:	2c f1       	and	@r1,	r12	;
    92e4:	1d f1 02 00 	and	2(r1),	r13	;
    92e8:	0c dd       	bis	r13,	r12	;
    92ea:	0d 43       	clr	r13		;
    92ec:	0d 8c       	sub	r12,	r13	;
    92ee:	0c dd       	bis	r13,	r12	;
    92f0:	5c 03       	rrum	#1,	r12	;
    92f2:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    92f6:	06 dc       	bis	r12,	r6	;
    92f8:	81 46 00 00 	mov	r6,	0(r1)	;

000092fc <.LVL37>:
    92fc:	91 41 08 00 	mov	8(r1),	2(r1)	;
    9300:	02 00 

00009302 <.LVL38>:
    9302:	95 3f       	jmp	$-212    	;abs 0x922e

00009304 <.L6>:
    9304:	0d 97       	cmp	r7,	r13	;
    9306:	06 38       	jl	$+14     	;abs 0x9314
    9308:	07 4d       	mov	r13,	r7	;

0000930a <.LVL40>:
    930a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000930e <.LVL41>:
    930e:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9312:	8d 3f       	jmp	$-228    	;abs 0x922e

00009314 <.L27>:
    9314:	44 43       	clr.b	r4		;

00009316 <.LVL43>:
    9316:	45 43       	clr.b	r5		;
    9318:	8a 3f       	jmp	$-234    	;abs 0x922e

0000931a <.L10>:
    931a:	2c 41       	mov	@r1,	r12	;
    931c:	1d 41 02 00 	mov	2(r1),	r13	;
    9320:	0c 84       	sub	r4,	r12	;
    9322:	0d 75       	subc	r5,	r13	;

00009324 <.LVL45>:
    9324:	90 3f       	jmp	$-222    	;abs 0x9246

00009326 <.L12>:
    9326:	9a 43 02 00 	mov	#1,	2(r10)	;r3 As==01

0000932a <.Loc.691.1>:
    932a:	8a 47 04 00 	mov	r7,	4(r10)	;

0000932e <.Loc.692.1>:
    932e:	4e 43       	clr.b	r14		;
    9330:	4f 43       	clr.b	r15		;
    9332:	08 4e       	mov	r14,	r8	;

00009334 <.LVL46>:
    9334:	09 4f       	mov	r15,	r9	;

00009336 <.LVL47>:
    9336:	08 8c       	sub	r12,	r8	;
    9338:	09 7d       	subc	r13,	r9	;
    933a:	8a 48 06 00 	mov	r8,	6(r10)	;
    933e:	8a 49 08 00 	mov	r9,	8(r10)	;
    9342:	8b 3f       	jmp	$-232    	;abs 0x925a

00009344 <.L16>:
    9344:	0c 5c       	rla	r12		;
    9346:	0d 6d       	rlc	r13		;
    9348:	8a 4c 06 00 	mov	r12,	6(r10)	;
    934c:	8a 4d 08 00 	mov	r13,	8(r10)	;

00009350 <.Loc.699.1>:
    9350:	ba 53 04 00 	add	#-1,	4(r10)	;r3 As==11
    9354:	82 3f       	jmp	$-250    	;abs 0x925a

00009356 <.L9>:
    9356:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000935a <.Loc.705.1>:
    935a:	8a 47 04 00 	mov	r7,	4(r10)	;

0000935e <.Loc.706.1>:
    935e:	08 44       	mov	r4,	r8	;

00009360 <.LVL50>:
    9360:	28 51       	add	@r1,	r8	;
    9362:	8a 48 06 00 	mov	r8,	6(r10)	;
    9366:	09 45       	mov	r5,	r9	;

00009368 <.LVL51>:
    9368:	19 61 02 00 	addc	2(r1),	r9	;
    936c:	8a 49 08 00 	mov	r9,	8(r10)	;
    9370:	86 3f       	jmp	$-242    	;abs 0x927e

00009372 <.L25>:
    9372:	0a 48       	mov	r8,	r10	;

00009374 <.LVL53>:
    9374:	02 3f       	jmp	$-506    	;abs 0x917a

00009376 <.L26>:
    9376:	0a 49       	mov	r9,	r10	;

00009378 <.LVL55>:
    9378:	00 3f       	jmp	$-510    	;abs 0x917a

0000937a <__mspabi_subf>:
    937a:	0a 15       	pushm	#1,	r10	;16-bit words

0000937c <.LCFI4>:
    937c:	31 80 26 00 	sub	#38,	r1	;#0x0026

00009380 <.LCFI5>:
    9380:	81 4c 00 00 	mov	r12,	0(r1)	;
    9384:	81 4d 02 00 	mov	r13,	2(r1)	;

00009388 <.Loc.750.1>:
    9388:	81 4e 04 00 	mov	r14,	4(r1)	;
    938c:	81 4f 06 00 	mov	r15,	6(r1)	;

00009390 <L0>:
    9390:	3a 40 a0 a6 	mov	#42656,	r10	;#0xa6a0
    9394:	0d 41       	mov	r1,	r13	;
    9396:	3d 52       	add	#8,	r13	;r2 As==11
    9398:	0c 41       	mov	r1,	r12	;

0000939a <.LVL63>:
    939a:	8a 12       	call	r10		;

0000939c <.LVL64>:
    939c:	0d 41       	mov	r1,	r13	;
    939e:	3d 50 12 00 	add	#18,	r13	;#0x0012
    93a2:	0c 41       	mov	r1,	r12	;
    93a4:	2c 52       	add	#4,	r12	;r2 As==10
    93a6:	8a 12       	call	r10		;

000093a8 <.LVL65>:
    93a8:	91 e3 14 00 	xor	#1,	20(r1)	;r3 As==01, 0x0014

000093ac <.Loc.757.1>:
    93ac:	0e 41       	mov	r1,	r14	;
    93ae:	3e 50 1c 00 	add	#28,	r14	;#0x001c
    93b2:	0d 41       	mov	r1,	r13	;
    93b4:	3d 50 12 00 	add	#18,	r13	;#0x0012
    93b8:	0c 41       	mov	r1,	r12	;
    93ba:	3c 52       	add	#8,	r12	;r2 As==11
    93bc:	b0 12 48 91 	call	#37192		;#0x9148

000093c0 <.LVL66>:
    93c0:	b0 12 64 a5 	call	#42340		;#0xa564

000093c4 <.LVL67>:
    93c4:	31 50 26 00 	add	#38,	r1	;#0x0026
    93c8:	0a 17       	popm	#1,	r10	;16-bit words
    93ca:	30 41       	ret			

000093cc <__gesf2>:
    93cc:	0a 15       	pushm	#1,	r10	;16-bit words

000093ce <.LCFI0>:
    93ce:	31 80 1c 00 	sub	#28,	r1	;#0x001c

000093d2 <.LCFI1>:
    93d2:	81 4c 00 00 	mov	r12,	0(r1)	;
    93d6:	81 4d 02 00 	mov	r13,	2(r1)	;

000093da <.Loc.1243.1>:
    93da:	81 4e 04 00 	mov	r14,	4(r1)	;
    93de:	81 4f 06 00 	mov	r15,	6(r1)	;

000093e2 <.Loc.1245.1>:
    93e2:	3a 40 a0 a6 	mov	#42656,	r10	;#0xa6a0
    93e6:	0d 41       	mov	r1,	r13	;
    93e8:	3d 52       	add	#8,	r13	;r2 As==11
    93ea:	0c 41       	mov	r1,	r12	;

000093ec <.LVL1>:
    93ec:	8a 12       	call	r10		;

000093ee <.LVL2>:
    93ee:	0d 41       	mov	r1,	r13	;
    93f0:	3d 50 12 00 	add	#18,	r13	;#0x0012
    93f4:	0c 41       	mov	r1,	r12	;
    93f6:	2c 52       	add	#4,	r12	;r2 As==10
    93f8:	8a 12       	call	r10		;

000093fa <.LVL3>:
    93fa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    93fc:	1c 91 08 00 	cmp	8(r1),	r12	;
    9400:	0e 2c       	jc	$+30     	;abs 0x941e

00009402 <.Loc.1248.1>:
    9402:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    9406:	0b 2c       	jc	$+24     	;abs 0x941e

00009408 <.Loc.1250.1>:
    9408:	0d 41       	mov	r1,	r13	;
    940a:	3d 50 12 00 	add	#18,	r13	;#0x0012
    940e:	0c 41       	mov	r1,	r12	;
    9410:	3c 52       	add	#8,	r12	;r2 As==11
    9412:	b0 12 7a a7 	call	#42874		;#0xa77a

00009416 <.L1>:
    9416:	31 50 1c 00 	add	#28,	r1	;#0x001c
    941a:	0a 17       	popm	#1,	r10	;16-bit words
    941c:	30 41       	ret			

0000941e <.L4>:
    941e:	3c 43       	mov	#-1,	r12	;r3 As==11
    9420:	fa 3f       	jmp	$-10     	;abs 0x9416

00009422 <__mspabi_fixfli>:
    9422:	0a 15       	pushm	#1,	r10	;16-bit words

00009424 <L0>:
    9424:	31 80 0e 00 	sub	#14,	r1	;#0x000e

00009428 <.LCFI1>:
    9428:	81 4c 00 00 	mov	r12,	0(r1)	;
    942c:	81 4d 02 00 	mov	r13,	2(r1)	;

00009430 <.Loc.1401.1>:
    9430:	0d 41       	mov	r1,	r13	;
    9432:	2d 52       	add	#4,	r13	;r2 As==10
    9434:	0c 41       	mov	r1,	r12	;

00009436 <.LVL1>:
    9436:	b0 12 a0 a6 	call	#42656		;#0xa6a0

0000943a <.LVL2>:
    943a:	1c 41 04 00 	mov	4(r1),	r12	;

0000943e <.Loc.1405.1>:
    943e:	6a 43       	mov.b	#2,	r10	;r3 As==10
    9440:	0a 9c       	cmp	r12,	r10	;
    9442:	2e 2c       	jc	$+94     	;abs 0x94a0

00009444 <.Loc.1408.1>:
    9444:	2c 92       	cmp	#4,	r12	;r2 As==10
    9446:	0a 20       	jnz	$+22     	;abs 0x945c

00009448 <.L4>:
    9448:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    944c:	25 20       	jnz	$+76     	;abs 0x9498
    944e:	3c 43       	mov	#-1,	r12	;r3 As==11
    9450:	3d 40 ff 7f 	mov	#32767,	r13	;#0x7fff

00009454 <.L1>:
    9454:	31 50 0e 00 	add	#14,	r1	;#0x000e
    9458:	0a 17       	popm	#1,	r10	;16-bit words
    945a:	30 41       	ret			

0000945c <.L3>:
    945c:	1c 41 08 00 	mov	8(r1),	r12	;
    9460:	0c 93       	cmp	#0,	r12	;r3 As==00
    9462:	1e 38       	jl	$+62     	;abs 0x94a0

00009464 <.Loc.1413.1>:
    9464:	7b 40 1e 00 	mov.b	#30,	r11	;#0x001e
    9468:	0b 9c       	cmp	r12,	r11	;
    946a:	ee 3b       	jl	$-34     	;abs 0x9448

0000946c <.Loc.1415.1>:
    946c:	3e 40 1e 00 	mov	#30,	r14	;#0x001e
    9470:	0e 8c       	sub	r12,	r14	;
    9472:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    9476:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    947a:	0f 43       	clr	r15		;
    947c:	b0 12 4e a4 	call	#42062		;#0xa44e

00009480 <.LVL7>:
    9480:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    9484:	e7 27       	jz	$-48     	;abs 0x9454

00009486 <.Loc.1416.1>:
    9486:	4e 43       	clr.b	r14		;
    9488:	4f 43       	clr.b	r15		;
    948a:	0a 4e       	mov	r14,	r10	;
    948c:	0b 4f       	mov	r15,	r11	;
    948e:	0a 8c       	sub	r12,	r10	;
    9490:	0b 7d       	subc	r13,	r11	;
    9492:	0c 4a       	mov	r10,	r12	;

00009494 <.LVL8>:
    9494:	0d 4b       	mov	r11,	r13	;
    9496:	de 3f       	jmp	$-66     	;abs 0x9454

00009498 <.L6>:
    9498:	4c 43       	clr.b	r12		;
    949a:	3d 40 00 80 	mov	#32768,	r13	;#0x8000
    949e:	da 3f       	jmp	$-74     	;abs 0x9454

000094a0 <.L7>:
    94a0:	4c 43       	clr.b	r12		;
    94a2:	4d 43       	clr.b	r13		;
    94a4:	d7 3f       	jmp	$-80     	;abs 0x9454

000094a6 <__mspabi_cvtfd>:
    94a6:	2a 15       	pushm	#3,	r10	;16-bit words

000094a8 <.LCFI0>:
    94a8:	31 80 16 00 	sub	#22,	r1	;#0x0016

000094ac <L0>:
    94ac:	81 4c 08 00 	mov	r12,	8(r1)	;
    94b0:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

000094b4 <.Loc.1501.1>:
    94b4:	0d 41       	mov	r1,	r13	;
    94b6:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    94ba:	0c 41       	mov	r1,	r12	;

000094bc <.LVL1>:
    94bc:	3c 52       	add	#8,	r12	;r2 As==11
    94be:	b0 12 a0 a6 	call	#42656		;#0xa6a0

000094c2 <.LVL2>:
    94c2:	18 41 10 00 	mov	16(r1),	r8	;0x00010
    94c6:	19 41 0e 00 	mov	14(r1),	r9	;0x0000e
    94ca:	1a 41 0c 00 	mov	12(r1),	r10	;0x0000c

000094ce <.Loc.1504.1>:
    94ce:	1d 41 14 00 	mov	20(r1),	r13	;0x00014

000094d2 <.Loc.1503.1>:
    94d2:	b1 40 1e 00 	mov	#30,	0(r1)	;#0x001e
    94d6:	00 00 
    94d8:	1c 41 12 00 	mov	18(r1),	r12	;0x00012
    94dc:	4e 43       	clr.b	r14		;
    94de:	0f 4e       	mov	r14,	r15	;
    94e0:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    94e4:	81 4c 00 00 	mov	r12,	0(r1)	;
    94e8:	81 4d 02 00 	mov	r13,	2(r1)	;
    94ec:	81 4e 04 00 	mov	r14,	4(r1)	;
    94f0:	81 4f 06 00 	mov	r15,	6(r1)	;
    94f4:	0e 48       	mov	r8,	r14	;
    94f6:	0d 49       	mov	r9,	r13	;
    94f8:	0c 4a       	mov	r10,	r12	;
    94fa:	b0 12 1e a2 	call	#41502		;#0xa21e

000094fe <.LVL4>:
    94fe:	31 50 16 00 	add	#22,	r1	;#0x0016
    9502:	28 17       	popm	#3,	r10	;16-bit words
    9504:	30 41       	ret			

00009506 <_fpadd_parts>:
    9506:	6a 15       	pushm	#7,	r10	;16-bit words

00009508 <.LCFI0>:
    9508:	31 80 1c 00 	sub	#28,	r1	;#0x001c

0000950c <.LCFI1>:
    950c:	0a 4c       	mov	r12,	r10	;
    950e:	09 4d       	mov	r13,	r9	;
    9510:	04 4e       	mov	r14,	r4	;
    9512:	2c 4c       	mov	@r12,	r12	;

00009514 <.LVL1>:
    9514:	55 43       	mov.b	#1,	r5	;r3 As==01
    9516:	05 9c       	cmp	r12,	r5	;
    9518:	0f 2c       	jc	$+32     	;abs 0x9538
    951a:	2d 4d       	mov	@r13,	r13	;

0000951c <.LVL2>:
    951c:	05 9d       	cmp	r13,	r5	;
    951e:	02 28       	jnc	$+6      	;abs 0x9524
    9520:	80 00 0a 9b 	mova	#39690,	r0	;0x09b0a

00009524 <.Loc.601.1>:
    9524:	2c 92       	cmp	#4,	r12	;r2 As==10
    9526:	0d 20       	jnz	$+28     	;abs 0x9542

00009528 <.Loc.604.1>:
    9528:	2d 92       	cmp	#4,	r13	;r2 As==10
    952a:	06 20       	jnz	$+14     	;abs 0x9538

0000952c <.Loc.604.1>:
    952c:	9a 99 02 00 	cmp	2(r9),	2(r10)	;
    9530:	02 00 
    9532:	02 24       	jz	$+6      	;abs 0x9538

00009534 <.Loc.605.1>:
    9534:	3a 40 aa 50 	mov	#20650,	r10	;#0x50aa

00009538 <.L1>:
    9538:	0c 4a       	mov	r10,	r12	;
    953a:	31 50 1c 00 	add	#28,	r1	;#0x001c
    953e:	64 17       	popm	#7,	r10	;16-bit words
    9540:	30 41       	ret			

00009542 <.L3>:
    9542:	2d 92       	cmp	#4,	r13	;r2 As==10
    9544:	02 20       	jnz	$+6      	;abs 0x954a
    9546:	80 00 0a 9b 	mova	#39690,	r0	;0x09b0a

0000954a <.Loc.612.1>:
    954a:	2d 93       	cmp	#2,	r13	;r3 As==10
    954c:	10 20       	jnz	$+34     	;abs 0x956e

0000954e <.Loc.614.1>:
    954e:	2c 93       	cmp	#2,	r12	;r3 As==10
    9550:	f3 23       	jnz	$-24     	;abs 0x9538

00009552 <.Loc.616.1>:
    9552:	7e 40 0e 00 	mov.b	#14,	r14	;#0x000e
    9556:	0d 4a       	mov	r10,	r13	;
    9558:	0c 44       	mov	r4,	r12	;
    955a:	b0 12 74 ad 	call	#44404		;#0xad74

0000955e <.LVL9>:
    955e:	1a 4a 02 00 	mov	2(r10),	r10	;

00009562 <.LVL10>:
    9562:	1a f9 02 00 	and	2(r9),	r10	;
    9566:	84 4a 02 00 	mov	r10,	2(r4)	;

0000956a <.L84>:
    956a:	0a 44       	mov	r4,	r10	;
    956c:	e5 3f       	jmp	$-52     	;abs 0x9538

0000956e <.L4>:
    956e:	2c 93       	cmp	#2,	r12	;r3 As==10
    9570:	02 20       	jnz	$+6      	;abs 0x9576
    9572:	80 00 0a 9b 	mova	#39690,	r0	;0x09b0a

00009576 <.LBB21>:
    9576:	91 4a 04 00 	mov	4(r10),	16(r1)	; 0x0010
    957a:	10 00 

0000957c <.LVL13>:
    957c:	1d 49 04 00 	mov	4(r9),	r13	;

00009580 <.LVL14>:
    9580:	18 4a 06 00 	mov	6(r10),	r8	;
    9584:	91 4a 08 00 	mov	8(r10),	4(r1)	;
    9588:	04 00 
    958a:	91 4a 0a 00 	mov	10(r10),6(r1)	;0x0000a
    958e:	06 00 
    9590:	91 4a 0c 00 	mov	12(r10),12(r1)	;0x0000c, 0x000c
    9594:	0c 00 

00009596 <.LVL15>:
    9596:	1b 49 06 00 	mov	6(r9),	r11	;
    959a:	91 49 08 00 	mov	8(r9),	8(r1)	;
    959e:	08 00 
    95a0:	91 49 0a 00 	mov	10(r9),	10(r1)	;0x0000a, 0x000a
    95a4:	0a 00 
    95a6:	91 49 0c 00 	mov	12(r9),	14(r1)	;0x0000c, 0x000e
    95aa:	0e 00 

000095ac <.LVL16>:
    95ac:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    95b0:	0c 8d       	sub	r13,	r12	;

000095b2 <.LVL17>:
    95b2:	07 4c       	mov	r12,	r7	;
    95b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    95b6:	02 34       	jge	$+6      	;abs 0x95bc
    95b8:	07 43       	clr	r7		;
    95ba:	07 8c       	sub	r12,	r7	;

000095bc <.L5>:
    95bc:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    95c0:	0e 97       	cmp	r7,	r14	;
    95c2:	cd 39       	jl	$+924    	;abs 0x995e

000095c4 <.Loc.645.1>:
    95c4:	45 43       	clr.b	r5		;
    95c6:	05 9c       	cmp	r12,	r5	;
    95c8:	32 35       	jge	$+614    	;abs 0x982e

000095ca <.LVL19>:
    95ca:	81 47 00 00 	mov	r7,	0(r1)	;

000095ce <.LVL20>:
    95ce:	0c 4b       	mov	r11,	r12	;

000095d0 <.LVL21>:
    95d0:	1d 41 08 00 	mov	8(r1),	r13	;

000095d4 <.LVL22>:
    95d4:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    95d8:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    95dc:	81 4b 02 00 	mov	r11,	2(r1)	;
    95e0:	b0 12 54 a4 	call	#42068		;#0xa454

000095e4 <.LVL23>:
    95e4:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    95e8:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014
    95ec:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    95f0:	81 4f 18 00 	mov	r15,	24(r1)	; 0x0018
    95f4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    95f6:	0d 45       	mov	r5,	r13	;
    95f8:	0e 45       	mov	r5,	r14	;
    95fa:	0f 45       	mov	r5,	r15	;
    95fc:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    9600:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a
    9604:	3f 43       	mov	#-1,	r15	;r3 As==11
    9606:	06 4c       	mov	r12,	r6	;
    9608:	06 5f       	add	r15,	r6	;
    960a:	55 43       	mov.b	#1,	r5	;r3 As==01
    960c:	1b 41 02 00 	mov	2(r1),	r11	;

00009610 <.LVL25>:
    9610:	06 9c       	cmp	r12,	r6	;
    9612:	01 28       	jnc	$+4      	;abs 0x9616
    9614:	45 43       	clr.b	r5		;

00009616 <.L8>:
    9616:	0c 4d       	mov	r13,	r12	;
    9618:	0c 5f       	add	r15,	r12	;
    961a:	57 43       	mov.b	#1,	r7	;r3 As==01

0000961c <.LVL26>:
    961c:	0c 9d       	cmp	r13,	r12	;
    961e:	01 28       	jnc	$+4      	;abs 0x9622
    9620:	47 43       	clr.b	r7		;

00009622 <.L9>:
    9622:	05 5c       	add	r12,	r5	;
    9624:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9626:	05 9c       	cmp	r12,	r5	;
    9628:	01 28       	jnc	$+4      	;abs 0x962c
    962a:	4d 43       	clr.b	r13		;

0000962c <.L10>:
    962c:	07 dd       	bis	r13,	r7	;
    962e:	0d 4e       	mov	r14,	r13	;
    9630:	0d 5f       	add	r15,	r13	;
    9632:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9634:	0d 9e       	cmp	r14,	r13	;
    9636:	01 28       	jnc	$+4      	;abs 0x963a
    9638:	4c 43       	clr.b	r12		;

0000963a <.L11>:
    963a:	07 5d       	add	r13,	r7	;
    963c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    963e:	07 9d       	cmp	r13,	r7	;
    9640:	01 28       	jnc	$+4      	;abs 0x9644
    9642:	4e 43       	clr.b	r14		;

00009644 <.L12>:
    9644:	0c de       	bis	r14,	r12	;
    9646:	1f 51 1a 00 	add	26(r1),	r15	;0x0001a
    964a:	0c 5f       	add	r15,	r12	;
    964c:	06 fb       	and	r11,	r6	;
    964e:	15 f1 08 00 	and	8(r1),	r5	;
    9652:	81 45 08 00 	mov	r5,	8(r1)	;

00009656 <.LVL27>:
    9656:	17 f1 0a 00 	and	10(r1),	r7	;0x0000a
    965a:	81 47 0a 00 	mov	r7,	10(r1)	; 0x000a
    965e:	1c f1 0e 00 	and	14(r1),	r12	;0x0000e
    9662:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    9666:	4f 43       	clr.b	r15		;
    9668:	0c 4f       	mov	r15,	r12	;
    966a:	0c 86       	sub	r6,	r12	;
    966c:	57 43       	mov.b	#1,	r7	;r3 As==01
    966e:	0c 9f       	cmp	r15,	r12	;
    9670:	01 20       	jnz	$+4      	;abs 0x9674
    9672:	07 4c       	mov	r12,	r7	;

00009674 <.L13>:
    9674:	0e 4f       	mov	r15,	r14	;
    9676:	1e 81 08 00 	sub	8(r1),	r14	;
    967a:	5b 43       	mov.b	#1,	r11	;r3 As==01
    967c:	0e 93       	cmp	#0,	r14	;r3 As==00
    967e:	01 20       	jnz	$+4      	;abs 0x9682
    9680:	0b 4e       	mov	r14,	r11	;

00009682 <.L14>:
    9682:	0d 4e       	mov	r14,	r13	;
    9684:	0d 87       	sub	r7,	r13	;
    9686:	57 43       	mov.b	#1,	r7	;r3 As==01
    9688:	0e 9d       	cmp	r13,	r14	;
    968a:	01 28       	jnc	$+4      	;abs 0x968e
    968c:	47 43       	clr.b	r7		;

0000968e <.L15>:
    968e:	0b d7       	bis	r7,	r11	;
    9690:	05 4f       	mov	r15,	r5	;
    9692:	15 81 0a 00 	sub	10(r1),	r5	;0x0000a
    9696:	57 43       	mov.b	#1,	r7	;r3 As==01
    9698:	05 93       	cmp	#0,	r5	;r3 As==00
    969a:	01 20       	jnz	$+4      	;abs 0x969e
    969c:	07 45       	mov	r5,	r7	;

0000969e <.L16>:
    969e:	0e 45       	mov	r5,	r14	;
    96a0:	0e 8b       	sub	r11,	r14	;
    96a2:	5b 43       	mov.b	#1,	r11	;r3 As==01
    96a4:	05 9e       	cmp	r14,	r5	;
    96a6:	01 28       	jnc	$+4      	;abs 0x96aa
    96a8:	4b 43       	clr.b	r11		;

000096aa <.L17>:
    96aa:	07 db       	bis	r11,	r7	;
    96ac:	1f 81 0e 00 	sub	14(r1),	r15	;0x0000e
    96b0:	0f 87       	sub	r7,	r15	;
    96b2:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    96b6:	00 00 
    96b8:	0c d6       	bis	r6,	r12	;
    96ba:	1d d1 08 00 	bis	8(r1),	r13	;
    96be:	1e d1 0a 00 	bis	10(r1),	r14	;0x0000a
    96c2:	1f d1 0e 00 	bis	14(r1),	r15	;0x0000e
    96c6:	b0 12 54 a4 	call	#42068		;#0xa454
    96ca:	1b 41 12 00 	mov	18(r1),	r11	;0x00012
    96ce:	0b dc       	bis	r12,	r11	;
    96d0:	1d d1 14 00 	bis	20(r1),	r13	;0x00014
    96d4:	81 4d 08 00 	mov	r13,	8(r1)	;
    96d8:	1e d1 16 00 	bis	22(r1),	r14	;0x00016
    96dc:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a
    96e0:	1f d1 18 00 	bis	24(r1),	r15	;0x00018
    96e4:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

000096e8 <.L18>:
    96e8:	1c 4a 02 00 	mov	2(r10),	r12	;
    96ec:	1c 99 02 00 	cmp	2(r9),	r12	;
    96f0:	d4 25       	jz	$+938    	;abs 0x9a9a

000096f2 <.Loc.674.1>:
    96f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    96f4:	49 25       	jz	$+660    	;abs 0x9988

000096f6 <.Loc.676.1>:
    96f6:	09 4b       	mov	r11,	r9	;
    96f8:	09 88       	sub	r8,	r9	;

000096fa <.LVL30>:
    96fa:	5d 43       	mov.b	#1,	r13	;r3 As==01
    96fc:	0b 99       	cmp	r9,	r11	;
    96fe:	01 28       	jnc	$+4      	;abs 0x9702
    9700:	4d 43       	clr.b	r13		;

00009702 <.L31>:
    9702:	1c 41 08 00 	mov	8(r1),	r12	;
    9706:	1c 81 04 00 	sub	4(r1),	r12	;
    970a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    970c:	81 9c 08 00 	cmp	r12,	8(r1)	;
    9710:	01 28       	jnc	$+4      	;abs 0x9714
    9712:	4e 43       	clr.b	r14		;

00009714 <.L32>:
    9714:	0a 4c       	mov	r12,	r10	;
    9716:	0a 8d       	sub	r13,	r10	;

00009718 <.LVL31>:
    9718:	5d 43       	mov.b	#1,	r13	;r3 As==01
    971a:	0c 9a       	cmp	r10,	r12	;
    971c:	01 28       	jnc	$+4      	;abs 0x9720
    971e:	4d 43       	clr.b	r13		;

00009720 <.L33>:
    9720:	0e dd       	bis	r13,	r14	;
    9722:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    9726:	1c 81 06 00 	sub	6(r1),	r12	;
    972a:	58 43       	mov.b	#1,	r8	;r3 As==01

0000972c <.LVL32>:
    972c:	81 9c 0a 00 	cmp	r12,	10(r1)	; 0x000a
    9730:	01 28       	jnc	$+4      	;abs 0x9734
    9732:	48 43       	clr.b	r8		;

00009734 <.L34>:
    9734:	0d 4c       	mov	r12,	r13	;
    9736:	0d 8e       	sub	r14,	r13	;
    9738:	5e 43       	mov.b	#1,	r14	;r3 As==01
    973a:	0c 9d       	cmp	r13,	r12	;
    973c:	01 28       	jnc	$+4      	;abs 0x9740
    973e:	4e 43       	clr.b	r14		;

00009740 <.L35>:
    9740:	08 de       	bis	r14,	r8	;
    9742:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    9746:	1c 81 0c 00 	sub	12(r1),	r12	;0x0000c
    974a:	07 49       	mov	r9,	r7	;
    974c:	0c 88       	sub	r8,	r12	;

0000974e <.L36>:
    974e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9750:	48 39       	jl	$+658    	;abs 0x99e2

00009752 <.Loc.684.1>:
    9752:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00

00009756 <.Loc.685.1>:
    9756:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    975a:	04 00 

0000975c <.Loc.686.1>:
    975c:	84 47 06 00 	mov	r7,	6(r4)	;
    9760:	84 4a 08 00 	mov	r10,	8(r4)	;
    9764:	84 4d 0a 00 	mov	r13,	10(r4)	; 0x000a
    9768:	84 4c 0c 00 	mov	r12,	12(r4)	; 0x000c

0000976c <.L50>:
    976c:	36 43       	mov	#-1,	r6	;r3 As==11
    976e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9770:	4f 43       	clr.b	r15		;

00009772 <.L44>:
    9772:	1b 44 06 00 	mov	6(r4),	r11	;
    9776:	1a 44 08 00 	mov	8(r4),	r10	;
    977a:	19 44 0a 00 	mov	10(r4),	r9	;0x0000a
    977e:	18 44 0c 00 	mov	12(r4),	r8	;0x0000c
    9782:	0c 4b       	mov	r11,	r12	;
    9784:	0c 56       	add	r6,	r12	;
    9786:	81 4c 06 00 	mov	r12,	6(r1)	;
    978a:	07 4e       	mov	r14,	r7	;
    978c:	0c 9b       	cmp	r11,	r12	;
    978e:	01 28       	jnc	$+4      	;abs 0x9792
    9790:	07 4f       	mov	r15,	r7	;

00009792 <.L57>:
    9792:	0d 4a       	mov	r10,	r13	;
    9794:	0d 56       	add	r6,	r13	;
    9796:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9798:	0d 9a       	cmp	r10,	r13	;
    979a:	01 28       	jnc	$+4      	;abs 0x979e
    979c:	4c 43       	clr.b	r12		;

0000979e <.L58>:
    979e:	07 5d       	add	r13,	r7	;
    97a0:	05 4e       	mov	r14,	r5	;
    97a2:	07 9d       	cmp	r13,	r7	;
    97a4:	01 28       	jnc	$+4      	;abs 0x97a8
    97a6:	05 4f       	mov	r15,	r5	;

000097a8 <.L59>:
    97a8:	0c d5       	bis	r5,	r12	;
    97aa:	05 49       	mov	r9,	r5	;
    97ac:	05 56       	add	r6,	r5	;
    97ae:	5d 43       	mov.b	#1,	r13	;r3 As==01
    97b0:	05 99       	cmp	r9,	r5	;
    97b2:	01 28       	jnc	$+4      	;abs 0x97b6
    97b4:	4d 43       	clr.b	r13		;

000097b6 <.L60>:
    97b6:	0c 55       	add	r5,	r12	;
    97b8:	81 4e 04 00 	mov	r14,	4(r1)	;
    97bc:	0c 95       	cmp	r5,	r12	;
    97be:	02 28       	jnc	$+6      	;abs 0x97c4
    97c0:	81 4f 04 00 	mov	r15,	4(r1)	;

000097c4 <.L61>:
    97c4:	1d d1 04 00 	bis	4(r1),	r13	;
    97c8:	05 48       	mov	r8,	r5	;
    97ca:	05 56       	add	r6,	r5	;
    97cc:	0d 55       	add	r5,	r13	;
    97ce:	35 40 ff 0f 	mov	#4095,	r5	;#0x0fff
    97d2:	05 9d       	cmp	r13,	r5	;
    97d4:	0b 28       	jnc	$+24     	;abs 0x97ec
    97d6:	0d 95       	cmp	r5,	r13	;
    97d8:	35 21       	jnz	$+620    	;abs 0x9a44
    97da:	3c 93       	cmp	#-1,	r12	;r3 As==11
    97dc:	33 21       	jnz	$+616    	;abs 0x9a44
    97de:	37 93       	cmp	#-1,	r7	;r3 As==11
    97e0:	31 21       	jnz	$+612    	;abs 0x9a44
    97e2:	37 40 fe ff 	mov	#65534,	r7	;#0xfffe
    97e6:	17 91 06 00 	cmp	6(r1),	r7	;
    97ea:	2c 2d       	jc	$+602    	;abs 0x9a44

000097ec <.L63>:
    97ec:	b4 40 03 00 	mov	#3,	0(r4)	;
    97f0:	00 00 

000097f2 <.Loc.712.1>:
    97f2:	1a 44 06 00 	mov	6(r4),	r10	;
    97f6:	1d 44 08 00 	mov	8(r4),	r13	;
    97fa:	1e 44 0a 00 	mov	10(r4),	r14	;0x0000a
    97fe:	1f 44 0c 00 	mov	12(r4),	r15	;0x0000c
    9802:	3c 40 ff 1f 	mov	#8191,	r12	;#0x1fff
    9806:	0c 9f       	cmp	r15,	r12	;
    9808:	b0 2e       	jc	$-670    	;abs 0x956a

0000980a <.Loc.714.1>:
    980a:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    980e:	0c 4a       	mov	r10,	r12	;
    9810:	b0 12 54 a4 	call	#42068		;#0xa454
    9814:	5a f3       	and.b	#1,	r10	;r3 As==01
    9816:	0c da       	bis	r10,	r12	;
    9818:	84 4c 06 00 	mov	r12,	6(r4)	;
    981c:	84 4d 08 00 	mov	r13,	8(r4)	;
    9820:	84 4e 0a 00 	mov	r14,	10(r4)	; 0x000a
    9824:	84 4f 0c 00 	mov	r15,	12(r4)	; 0x000c

00009828 <.Loc.715.1>:
    9828:	94 53 04 00 	inc	4(r4)		;
    982c:	9e 3e       	jmp	$-706    	;abs 0x956a

0000982e <.L7>:
    982e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9830:	5b 27       	jz	$-328    	;abs 0x96e8

00009832 <.Loc.652.1>:
    9832:	81 57 10 00 	add	r7,	16(r1)	; 0x0010

00009836 <.LVL38>:
    9836:	81 47 00 00 	mov	r7,	0(r1)	;
    983a:	0c 48       	mov	r8,	r12	;

0000983c <.LVL39>:
    983c:	1d 41 04 00 	mov	4(r1),	r13	;

00009840 <.LVL40>:
    9840:	1e 41 06 00 	mov	6(r1),	r14	;
    9844:	1f 41 0c 00 	mov	12(r1),	r15	;0x0000c
    9848:	81 4b 02 00 	mov	r11,	2(r1)	;
    984c:	b0 12 54 a4 	call	#42068		;#0xa454

00009850 <.LVL41>:
    9850:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    9854:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016
    9858:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    985c:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a
    9860:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9862:	4d 43       	clr.b	r13		;
    9864:	0e 4d       	mov	r13,	r14	;
    9866:	0f 4d       	mov	r13,	r15	;
    9868:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    986c:	36 43       	mov	#-1,	r6	;r3 As==11
    986e:	07 4c       	mov	r12,	r7	;

00009870 <.LVL43>:
    9870:	07 56       	add	r6,	r7	;
    9872:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    9876:	55 43       	mov.b	#1,	r5	;r3 As==01
    9878:	1b 41 02 00 	mov	2(r1),	r11	;

0000987c <.LVL44>:
    987c:	07 9c       	cmp	r12,	r7	;
    987e:	01 28       	jnc	$+4      	;abs 0x9882
    9880:	45 43       	clr.b	r5		;

00009882 <.L19>:
    9882:	0c 4d       	mov	r13,	r12	;
    9884:	0c 56       	add	r6,	r12	;
    9886:	57 43       	mov.b	#1,	r7	;r3 As==01
    9888:	0c 9d       	cmp	r13,	r12	;
    988a:	01 28       	jnc	$+4      	;abs 0x988e
    988c:	47 43       	clr.b	r7		;

0000988e <.L20>:
    988e:	05 5c       	add	r12,	r5	;
    9890:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9892:	05 9c       	cmp	r12,	r5	;
    9894:	01 28       	jnc	$+4      	;abs 0x9898
    9896:	4d 43       	clr.b	r13		;

00009898 <.L21>:
    9898:	07 dd       	bis	r13,	r7	;
    989a:	0d 4e       	mov	r14,	r13	;
    989c:	0d 56       	add	r6,	r13	;
    989e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    98a0:	0d 9e       	cmp	r14,	r13	;
    98a2:	01 28       	jnc	$+4      	;abs 0x98a6
    98a4:	4c 43       	clr.b	r12		;

000098a6 <.L22>:
    98a6:	07 5d       	add	r13,	r7	;
    98a8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    98aa:	07 9d       	cmp	r13,	r7	;
    98ac:	01 28       	jnc	$+4      	;abs 0x98b0
    98ae:	4e 43       	clr.b	r14		;

000098b0 <.L23>:
    98b0:	0c de       	bis	r14,	r12	;
    98b2:	0f 56       	add	r6,	r15	;
    98b4:	0c 5f       	add	r15,	r12	;
    98b6:	18 f1 12 00 	and	18(r1),	r8	;0x00012

000098ba <.LVL45>:
    98ba:	15 f1 04 00 	and	4(r1),	r5	;
    98be:	81 45 04 00 	mov	r5,	4(r1)	;
    98c2:	17 f1 06 00 	and	6(r1),	r7	;
    98c6:	81 47 06 00 	mov	r7,	6(r1)	;
    98ca:	1c f1 0c 00 	and	12(r1),	r12	;0x0000c
    98ce:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    98d2:	4f 43       	clr.b	r15		;
    98d4:	0c 4f       	mov	r15,	r12	;
    98d6:	0c 88       	sub	r8,	r12	;
    98d8:	57 43       	mov.b	#1,	r7	;r3 As==01
    98da:	0c 9f       	cmp	r15,	r12	;
    98dc:	01 20       	jnz	$+4      	;abs 0x98e0
    98de:	07 4c       	mov	r12,	r7	;

000098e0 <.L24>:
    98e0:	0e 4f       	mov	r15,	r14	;
    98e2:	1e 81 04 00 	sub	4(r1),	r14	;
    98e6:	56 43       	mov.b	#1,	r6	;r3 As==01
    98e8:	0e 93       	cmp	#0,	r14	;r3 As==00
    98ea:	01 20       	jnz	$+4      	;abs 0x98ee
    98ec:	06 4e       	mov	r14,	r6	;

000098ee <.L25>:
    98ee:	0d 4e       	mov	r14,	r13	;
    98f0:	0d 87       	sub	r7,	r13	;
    98f2:	57 43       	mov.b	#1,	r7	;r3 As==01
    98f4:	0e 9d       	cmp	r13,	r14	;
    98f6:	01 28       	jnc	$+4      	;abs 0x98fa
    98f8:	47 43       	clr.b	r7		;

000098fa <.L26>:
    98fa:	06 d7       	bis	r7,	r6	;
    98fc:	05 4f       	mov	r15,	r5	;
    98fe:	15 81 06 00 	sub	6(r1),	r5	;
    9902:	57 43       	mov.b	#1,	r7	;r3 As==01
    9904:	05 93       	cmp	#0,	r5	;r3 As==00
    9906:	01 20       	jnz	$+4      	;abs 0x990a
    9908:	07 45       	mov	r5,	r7	;

0000990a <.L27>:
    990a:	0e 45       	mov	r5,	r14	;
    990c:	0e 86       	sub	r6,	r14	;
    990e:	56 43       	mov.b	#1,	r6	;r3 As==01
    9910:	05 9e       	cmp	r14,	r5	;
    9912:	01 28       	jnc	$+4      	;abs 0x9916
    9914:	46 43       	clr.b	r6		;

00009916 <.L28>:
    9916:	07 d6       	bis	r6,	r7	;
    9918:	1f 81 0c 00 	sub	12(r1),	r15	;0x0000c
    991c:	0f 87       	sub	r7,	r15	;
    991e:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    9922:	00 00 
    9924:	0c d8       	bis	r8,	r12	;
    9926:	1d d1 04 00 	bis	4(r1),	r13	;
    992a:	1e d1 06 00 	bis	6(r1),	r14	;
    992e:	1f d1 0c 00 	bis	12(r1),	r15	;0x0000c
    9932:	81 4b 02 00 	mov	r11,	2(r1)	;
    9936:	b0 12 54 a4 	call	#42068		;#0xa454

0000993a <.LVL46>:
    993a:	18 41 14 00 	mov	20(r1),	r8	;0x00014
    993e:	08 dc       	bis	r12,	r8	;
    9940:	1d d1 16 00 	bis	22(r1),	r13	;0x00016
    9944:	81 4d 04 00 	mov	r13,	4(r1)	;
    9948:	1e d1 18 00 	bis	24(r1),	r14	;0x00018
    994c:	81 4e 06 00 	mov	r14,	6(r1)	;
    9950:	1f d1 1a 00 	bis	26(r1),	r15	;0x0001a
    9954:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c

00009958 <.LVL47>:
    9958:	1b 41 02 00 	mov	2(r1),	r11	;

0000995c <.LVL48>:
    995c:	c5 3e       	jmp	$-628    	;abs 0x96e8

0000995e <.L6>:
    995e:	1d 91 10 00 	cmp	16(r1),	r13	;0x00010
    9962:	0a 38       	jl	$+22     	;abs 0x9978
    9964:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010

00009968 <.Loc.667.1>:
    9968:	48 43       	clr.b	r8		;

0000996a <.LVL50>:
    996a:	81 48 04 00 	mov	r8,	4(r1)	;
    996e:	81 48 06 00 	mov	r8,	6(r1)	;
    9972:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c
    9976:	b8 3e       	jmp	$-654    	;abs 0x96e8

00009978 <.L77>:
    9978:	4b 43       	clr.b	r11		;

0000997a <.LVL52>:
    997a:	81 4b 08 00 	mov	r11,	8(r1)	;
    997e:	81 4b 0a 00 	mov	r11,	10(r1)	; 0x000a
    9982:	81 4b 0e 00 	mov	r11,	14(r1)	; 0x000e
    9986:	b0 3e       	jmp	$-670    	;abs 0x96e8

00009988 <.L30>:
    9988:	09 48       	mov	r8,	r9	;
    998a:	09 8b       	sub	r11,	r9	;

0000998c <.LVL54>:
    998c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    998e:	08 99       	cmp	r9,	r8	;
    9990:	01 28       	jnc	$+4      	;abs 0x9994
    9992:	0d 4c       	mov	r12,	r13	;

00009994 <.L37>:
    9994:	1e 41 04 00 	mov	4(r1),	r14	;
    9998:	1e 81 08 00 	sub	8(r1),	r14	;
    999c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    999e:	81 9e 04 00 	cmp	r14,	4(r1)	;
    99a2:	01 28       	jnc	$+4      	;abs 0x99a6
    99a4:	4c 43       	clr.b	r12		;

000099a6 <.L38>:
    99a6:	0a 4e       	mov	r14,	r10	;
    99a8:	0a 8d       	sub	r13,	r10	;

000099aa <.LVL55>:
    99aa:	5d 43       	mov.b	#1,	r13	;r3 As==01
    99ac:	0e 9a       	cmp	r10,	r14	;
    99ae:	01 28       	jnc	$+4      	;abs 0x99b2
    99b0:	4d 43       	clr.b	r13		;

000099b2 <.L39>:
    99b2:	0c dd       	bis	r13,	r12	;
    99b4:	1f 41 06 00 	mov	6(r1),	r15	;
    99b8:	1f 81 0a 00 	sub	10(r1),	r15	;0x0000a
    99bc:	5e 43       	mov.b	#1,	r14	;r3 As==01
    99be:	81 9f 06 00 	cmp	r15,	6(r1)	;
    99c2:	01 28       	jnc	$+4      	;abs 0x99c6
    99c4:	4e 43       	clr.b	r14		;

000099c6 <.L40>:
    99c6:	0d 4f       	mov	r15,	r13	;
    99c8:	0d 8c       	sub	r12,	r13	;
    99ca:	5c 43       	mov.b	#1,	r12	;r3 As==01
    99cc:	0f 9d       	cmp	r13,	r15	;
    99ce:	01 28       	jnc	$+4      	;abs 0x99d2
    99d0:	4c 43       	clr.b	r12		;

000099d2 <.L41>:
    99d2:	0e dc       	bis	r12,	r14	;
    99d4:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    99d8:	1c 81 0e 00 	sub	14(r1),	r12	;0x0000e
    99dc:	07 49       	mov	r9,	r7	;
    99de:	0c 8e       	sub	r14,	r12	;

000099e0 <.LVL56>:
    99e0:	b6 3e       	jmp	$-658    	;abs 0x974e

000099e2 <.L42>:
    99e2:	94 43 02 00 	mov	#1,	2(r4)	;r3 As==01

000099e6 <.Loc.691.1>:
    99e6:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    99ea:	04 00 

000099ec <.Loc.692.1>:
    99ec:	4e 43       	clr.b	r14		;
    99ee:	09 4e       	mov	r14,	r9	;
    99f0:	09 87       	sub	r7,	r9	;
    99f2:	58 43       	mov.b	#1,	r8	;r3 As==01
    99f4:	09 9e       	cmp	r14,	r9	;
    99f6:	01 20       	jnz	$+4      	;abs 0x99fa
    99f8:	08 49       	mov	r9,	r8	;

000099fa <.L45>:
    99fa:	0f 4e       	mov	r14,	r15	;
    99fc:	0f 8a       	sub	r10,	r15	;
    99fe:	5a 43       	mov.b	#1,	r10	;r3 As==01

00009a00 <.LVL58>:
    9a00:	0f 93       	cmp	#0,	r15	;r3 As==00
    9a02:	01 20       	jnz	$+4      	;abs 0x9a06
    9a04:	0a 4f       	mov	r15,	r10	;

00009a06 <.L46>:
    9a06:	07 4f       	mov	r15,	r7	;
    9a08:	07 88       	sub	r8,	r7	;
    9a0a:	58 43       	mov.b	#1,	r8	;r3 As==01
    9a0c:	0f 97       	cmp	r7,	r15	;
    9a0e:	01 28       	jnc	$+4      	;abs 0x9a12
    9a10:	48 43       	clr.b	r8		;

00009a12 <.L47>:
    9a12:	0a d8       	bis	r8,	r10	;
    9a14:	0f 4e       	mov	r14,	r15	;
    9a16:	0f 8d       	sub	r13,	r15	;
    9a18:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9a1a:	0f 93       	cmp	#0,	r15	;r3 As==00
    9a1c:	01 20       	jnz	$+4      	;abs 0x9a20
    9a1e:	0d 4f       	mov	r15,	r13	;

00009a20 <.L48>:
    9a20:	08 4f       	mov	r15,	r8	;
    9a22:	08 8a       	sub	r10,	r8	;
    9a24:	5a 43       	mov.b	#1,	r10	;r3 As==01
    9a26:	0f 98       	cmp	r8,	r15	;
    9a28:	01 28       	jnc	$+4      	;abs 0x9a2c
    9a2a:	4a 43       	clr.b	r10		;

00009a2c <.L49>:
    9a2c:	0d da       	bis	r10,	r13	;
    9a2e:	0e 8c       	sub	r12,	r14	;
    9a30:	84 49 06 00 	mov	r9,	6(r4)	;
    9a34:	84 47 08 00 	mov	r7,	8(r4)	;
    9a38:	84 48 0a 00 	mov	r8,	10(r4)	; 0x000a
    9a3c:	0e 8d       	sub	r13,	r14	;
    9a3e:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    9a42:	94 3e       	jmp	$-726    	;abs 0x976c

00009a44 <.L56>:
    9a44:	07 4b       	mov	r11,	r7	;
    9a46:	07 5b       	add	r11,	r7	;
    9a48:	0d 4e       	mov	r14,	r13	;
    9a4a:	07 9b       	cmp	r11,	r7	;
    9a4c:	01 28       	jnc	$+4      	;abs 0x9a50
    9a4e:	0d 4f       	mov	r15,	r13	;

00009a50 <.L51>:
    9a50:	05 4a       	mov	r10,	r5	;
    9a52:	05 5a       	add	r10,	r5	;
    9a54:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9a56:	05 9a       	cmp	r10,	r5	;
    9a58:	01 28       	jnc	$+4      	;abs 0x9a5c
    9a5a:	4c 43       	clr.b	r12		;

00009a5c <.L52>:
    9a5c:	0d 55       	add	r5,	r13	;
    9a5e:	0a 4e       	mov	r14,	r10	;
    9a60:	0d 95       	cmp	r5,	r13	;
    9a62:	01 28       	jnc	$+4      	;abs 0x9a66
    9a64:	0a 4f       	mov	r15,	r10	;

00009a66 <.L53>:
    9a66:	0c da       	bis	r10,	r12	;
    9a68:	05 49       	mov	r9,	r5	;
    9a6a:	05 59       	add	r9,	r5	;
    9a6c:	5a 43       	mov.b	#1,	r10	;r3 As==01
    9a6e:	05 99       	cmp	r9,	r5	;
    9a70:	01 28       	jnc	$+4      	;abs 0x9a74
    9a72:	4a 43       	clr.b	r10		;

00009a74 <.L54>:
    9a74:	0c 55       	add	r5,	r12	;
    9a76:	09 4e       	mov	r14,	r9	;
    9a78:	0c 95       	cmp	r5,	r12	;
    9a7a:	01 28       	jnc	$+4      	;abs 0x9a7e
    9a7c:	09 4f       	mov	r15,	r9	;

00009a7e <.L55>:
    9a7e:	0a d9       	bis	r9,	r10	;
    9a80:	08 58       	rla	r8		;
    9a82:	84 47 06 00 	mov	r7,	6(r4)	;
    9a86:	84 4d 08 00 	mov	r13,	8(r4)	;
    9a8a:	84 4c 0a 00 	mov	r12,	10(r4)	; 0x000a
    9a8e:	0a 58       	add	r8,	r10	;
    9a90:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

00009a94 <.Loc.699.1>:
    9a94:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11
    9a98:	6c 3e       	jmp	$-806    	;abs 0x9772

00009a9a <.L29>:
    9a9a:	84 4c 02 00 	mov	r12,	2(r4)	;

00009a9e <.Loc.705.1>:
    9a9e:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    9aa2:	04 00 

00009aa4 <.Loc.706.1>:
    9aa4:	06 48       	mov	r8,	r6	;
    9aa6:	06 5b       	add	r11,	r6	;
    9aa8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9aaa:	06 98       	cmp	r8,	r6	;
    9aac:	01 28       	jnc	$+4      	;abs 0x9ab0
    9aae:	4e 43       	clr.b	r14		;

00009ab0 <.L64>:
    9ab0:	1b 41 04 00 	mov	4(r1),	r11	;

00009ab4 <.LVL61>:
    9ab4:	1b 51 08 00 	add	8(r1),	r11	;
    9ab8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9aba:	1b 91 04 00 	cmp	4(r1),	r11	;
    9abe:	01 28       	jnc	$+4      	;abs 0x9ac2
    9ac0:	4c 43       	clr.b	r12		;

00009ac2 <.L65>:
    9ac2:	0e 5b       	add	r11,	r14	;
    9ac4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9ac6:	0e 9b       	cmp	r11,	r14	;
    9ac8:	01 28       	jnc	$+4      	;abs 0x9acc
    9aca:	4d 43       	clr.b	r13		;

00009acc <.L66>:
    9acc:	0c dd       	bis	r13,	r12	;
    9ace:	17 41 06 00 	mov	6(r1),	r7	;
    9ad2:	17 51 0a 00 	add	10(r1),	r7	;0x0000a
    9ad6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    9ad8:	17 91 06 00 	cmp	6(r1),	r7	;
    9adc:	01 28       	jnc	$+4      	;abs 0x9ae0
    9ade:	4f 43       	clr.b	r15		;

00009ae0 <.L67>:
    9ae0:	0d 4c       	mov	r12,	r13	;
    9ae2:	0d 57       	add	r7,	r13	;
    9ae4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9ae6:	0d 97       	cmp	r7,	r13	;
    9ae8:	01 28       	jnc	$+4      	;abs 0x9aec
    9aea:	4c 43       	clr.b	r12		;

00009aec <.L68>:
    9aec:	0f dc       	bis	r12,	r15	;
    9aee:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    9af2:	1c 51 0e 00 	add	14(r1),	r12	;0x0000e
    9af6:	84 46 06 00 	mov	r6,	6(r4)	;
    9afa:	84 4e 08 00 	mov	r14,	8(r4)	;
    9afe:	84 4d 0a 00 	mov	r13,	10(r4)	; 0x000a
    9b02:	0f 5c       	add	r12,	r15	;
    9b04:	84 4f 0c 00 	mov	r15,	12(r4)	; 0x000c
    9b08:	71 3e       	jmp	$-796    	;abs 0x97ec

00009b0a <.L76>:
    9b0a:	0a 49       	mov	r9,	r10	;

00009b0c <L0>:
    9b0c:	30 40 38 95 	br	#0x9538		;

00009b10 <__mspabi_addd>:
    9b10:	2a 15       	pushm	#3,	r10	;16-bit words

00009b12 <.LCFI2>:
    9b12:	31 80 3a 00 	sub	#58,	r1	;#0x003a

00009b16 <.LCFI3>:
    9b16:	81 48 00 00 	mov	r8,	0(r1)	;
    9b1a:	81 49 02 00 	mov	r9,	2(r1)	;
    9b1e:	81 4a 04 00 	mov	r10,	4(r1)	;
    9b22:	81 4b 06 00 	mov	r11,	6(r1)	;

00009b26 <.Loc.730.1>:
    9b26:	81 4c 08 00 	mov	r12,	8(r1)	;
    9b2a:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    9b2e:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    9b32:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

00009b36 <.Loc.732.1>:
    9b36:	3a 40 06 ab 	mov	#43782,	r10	;#0xab06
    9b3a:	0d 41       	mov	r1,	r13	;
    9b3c:	3d 50 10 00 	add	#16,	r13	;#0x0010
    9b40:	0c 41       	mov	r1,	r12	;

00009b42 <.LVL65>:
    9b42:	8a 12       	call	r10		;

00009b44 <.LVL66>:
    9b44:	0d 41       	mov	r1,	r13	;
    9b46:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    9b4a:	0c 41       	mov	r1,	r12	;
    9b4c:	3c 52       	add	#8,	r12	;r2 As==11
    9b4e:	8a 12       	call	r10		;

00009b50 <.LVL67>:
    9b50:	0e 41       	mov	r1,	r14	;
    9b52:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    9b56:	0d 41       	mov	r1,	r13	;
    9b58:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    9b5c:	0c 41       	mov	r1,	r12	;
    9b5e:	3c 50 10 00 	add	#16,	r12	;#0x0010
    9b62:	b0 12 06 95 	call	#38150		;#0x9506

00009b66 <.LVL68>:
    9b66:	b0 12 1e a8 	call	#43038		;#0xa81e

00009b6a <.LVL69>:
    9b6a:	31 50 3a 00 	add	#58,	r1	;#0x003a
    9b6e:	28 17       	popm	#3,	r10	;16-bit words
    9b70:	30 41       	ret			

00009b72 <__mspabi_subd>:
    9b72:	2a 15       	pushm	#3,	r10	;16-bit words

00009b74 <.LCFI4>:
    9b74:	31 80 3a 00 	sub	#58,	r1	;#0x003a

00009b78 <.LCFI5>:
    9b78:	81 48 00 00 	mov	r8,	0(r1)	;
    9b7c:	81 49 02 00 	mov	r9,	2(r1)	;
    9b80:	81 4a 04 00 	mov	r10,	4(r1)	;
    9b84:	81 4b 06 00 	mov	r11,	6(r1)	;

00009b88 <.Loc.750.1>:
    9b88:	81 4c 08 00 	mov	r12,	8(r1)	;
    9b8c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    9b90:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    9b94:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

00009b98 <.Loc.752.1>:
    9b98:	3a 40 06 ab 	mov	#43782,	r10	;#0xab06
    9b9c:	0d 41       	mov	r1,	r13	;
    9b9e:	3d 50 10 00 	add	#16,	r13	;#0x0010
    9ba2:	0c 41       	mov	r1,	r12	;

00009ba4 <.LVL71>:
    9ba4:	8a 12       	call	r10		;

00009ba6 <.LVL72>:
    9ba6:	0d 41       	mov	r1,	r13	;
    9ba8:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    9bac:	0c 41       	mov	r1,	r12	;
    9bae:	3c 52       	add	#8,	r12	;r2 As==11
    9bb0:	8a 12       	call	r10		;

00009bb2 <.LVL73>:
    9bb2:	91 e3 20 00 	xor	#1,	32(r1)	;r3 As==01, 0x0020

00009bb6 <.Loc.757.1>:
    9bb6:	0e 41       	mov	r1,	r14	;
    9bb8:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    9bbc:	0d 41       	mov	r1,	r13	;
    9bbe:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    9bc2:	0c 41       	mov	r1,	r12	;
    9bc4:	3c 50 10 00 	add	#16,	r12	;#0x0010
    9bc8:	b0 12 06 95 	call	#38150		;#0x9506

00009bcc <.LVL74>:
    9bcc:	b0 12 1e a8 	call	#43038		;#0xa81e

00009bd0 <.LVL75>:
    9bd0:	31 50 3a 00 	add	#58,	r1	;#0x003a
    9bd4:	28 17       	popm	#3,	r10	;16-bit words
    9bd6:	30 41       	ret			

00009bd8 <__mspabi_mpyd>:
    9bd8:	6a 15       	pushm	#7,	r10	;16-bit words

00009bda <.LCFI0>:
    9bda:	31 80 5a 00 	sub	#90,	r1	;#0x005a

00009bde <.LCFI1>:
    9bde:	81 48 20 00 	mov	r8,	32(r1)	; 0x0020
    9be2:	81 49 22 00 	mov	r9,	34(r1)	; 0x0022
    9be6:	81 4a 24 00 	mov	r10,	36(r1)	; 0x0024
    9bea:	81 4b 26 00 	mov	r11,	38(r1)	; 0x0026

00009bee <.Loc.936.1>:
    9bee:	81 4c 28 00 	mov	r12,	40(r1)	; 0x0028
    9bf2:	81 4d 2a 00 	mov	r13,	42(r1)	; 0x002a
    9bf6:	81 4e 2c 00 	mov	r14,	44(r1)	; 0x002c
    9bfa:	81 4f 2e 00 	mov	r15,	46(r1)	; 0x002e

00009bfe <.Loc.938.1>:
    9bfe:	3a 40 06 ab 	mov	#43782,	r10	;#0xab06
    9c02:	0d 41       	mov	r1,	r13	;
    9c04:	3d 50 30 00 	add	#48,	r13	;#0x0030
    9c08:	0c 41       	mov	r1,	r12	;

00009c0a <.LVL1>:
    9c0a:	3c 50 20 00 	add	#32,	r12	;#0x0020
    9c0e:	8a 12       	call	r10		;

00009c10 <.LVL2>:
    9c10:	0d 41       	mov	r1,	r13	;
    9c12:	3d 50 3e 00 	add	#62,	r13	;#0x003e
    9c16:	0c 41       	mov	r1,	r12	;
    9c18:	3c 50 28 00 	add	#40,	r12	;#0x0028
    9c1c:	8a 12       	call	r10		;

00009c1e <.LVL3>:
    9c1e:	1d 41 30 00 	mov	48(r1),	r13	;0x00030

00009c22 <.LBB28>:
    9c22:	5a 43       	mov.b	#1,	r10	;r3 As==01
    9c24:	0a 9d       	cmp	r13,	r10	;
    9c26:	15 28       	jnc	$+44     	;abs 0x9c52

00009c28 <.L6>:
    9c28:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    9c2c:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    9c30:	0c 43       	clr	r12		;
    9c32:	0c 8d       	sub	r13,	r12	;
    9c34:	0c dd       	bis	r13,	r12	;
    9c36:	5c 03       	rrum	#1,	r12	;
    9c38:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    9c3c:	81 4c 32 00 	mov	r12,	50(r1)	; 0x0032

00009c40 <.Loc.775.1>:
    9c40:	0c 41       	mov	r1,	r12	;
    9c42:	3c 50 30 00 	add	#48,	r12	;#0x0030

00009c46 <.L3>:
    9c46:	b0 12 1e a8 	call	#43038		;#0xa81e

00009c4a <.LVL7>:
    9c4a:	31 50 5a 00 	add	#90,	r1	;#0x005a
    9c4e:	64 17       	popm	#7,	r10	;16-bit words
    9c50:	30 41       	ret			

00009c52 <.L2>:
    9c52:	1c 41 3e 00 	mov	62(r1),	r12	;0x0003e

00009c56 <.LBB33>:
    9c56:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9c58:	0e 9c       	cmp	r12,	r14	;
    9c5a:	10 28       	jnc	$+34     	;abs 0x9c7c

00009c5c <.L8>:
    9c5c:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    9c60:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    9c64:	0c 43       	clr	r12		;
    9c66:	0c 8d       	sub	r13,	r12	;
    9c68:	0c dd       	bis	r13,	r12	;
    9c6a:	5c 03       	rrum	#1,	r12	;
    9c6c:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    9c70:	81 4c 40 00 	mov	r12,	64(r1)	; 0x0040

00009c74 <.Loc.780.1>:
    9c74:	0c 41       	mov	r1,	r12	;
    9c76:	3c 50 3e 00 	add	#62,	r12	;#0x003e
    9c7a:	e5 3f       	jmp	$-52     	;abs 0x9c46

00009c7c <.L4>:
    9c7c:	2d 92       	cmp	#4,	r13	;r2 As==10
    9c7e:	05 20       	jnz	$+12     	;abs 0x9c8a

00009c80 <.Loc.784.1>:
    9c80:	2c 93       	cmp	#2,	r12	;r3 As==10
    9c82:	d2 23       	jnz	$-90     	;abs 0x9c28

00009c84 <.L68>:
    9c84:	3c 40 aa 50 	mov	#20650,	r12	;#0x50aa
    9c88:	de 3f       	jmp	$-66     	;abs 0x9c46

00009c8a <.L5>:
    9c8a:	2c 92       	cmp	#4,	r12	;r2 As==10
    9c8c:	03 20       	jnz	$+8      	;abs 0x9c94

00009c8e <.Loc.791.1>:
    9c8e:	2d 93       	cmp	#2,	r13	;r3 As==10
    9c90:	e5 23       	jnz	$-52     	;abs 0x9c5c
    9c92:	f8 3f       	jmp	$-14     	;abs 0x9c84

00009c94 <.L7>:
    9c94:	2d 93       	cmp	#2,	r13	;r3 As==10
    9c96:	c8 27       	jz	$-110    	;abs 0x9c28

00009c98 <.Loc.803.1>:
    9c98:	2c 93       	cmp	#2,	r12	;r3 As==10
    9c9a:	e0 27       	jz	$-62     	;abs 0x9c5c

00009c9c <.LBB30>:
    9c9c:	16 41 36 00 	mov	54(r1),	r6	;0x00036
    9ca0:	17 41 38 00 	mov	56(r1),	r7	;0x00038

00009ca4 <.Loc.852.1>:
    9ca4:	3a 40 54 a4 	mov	#42068,	r10	;#0xa454
    9ca8:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9cac:	00 00 
    9cae:	0c 46       	mov	r6,	r12	;
    9cb0:	0d 47       	mov	r7,	r13	;
    9cb2:	1e 41 3a 00 	mov	58(r1),	r14	;0x0003a
    9cb6:	1f 41 3c 00 	mov	60(r1),	r15	;0x0003c
    9cba:	8a 12       	call	r10		;

00009cbc <.LVL18>:
    9cbc:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    9cc0:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016
    9cc4:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    9cc8:	81 4f 08 00 	mov	r15,	8(r1)	;

00009ccc <.Loc.853.1>:
    9ccc:	91 41 44 00 	mov	68(r1),	4(r1)	;0x00044
    9cd0:	04 00 
    9cd2:	91 41 46 00 	mov	70(r1),	6(r1)	;0x00046
    9cd6:	06 00 

00009cd8 <.Loc.854.1>:
    9cd8:	1c 41 04 00 	mov	4(r1),	r12	;
    9cdc:	1d 41 06 00 	mov	6(r1),	r13	;
    9ce0:	1e 41 48 00 	mov	72(r1),	r14	;0x00048
    9ce4:	1f 41 4a 00 	mov	74(r1),	r15	;0x0004a
    9ce8:	8a 12       	call	r10		;

00009cea <.LVL25>:
    9cea:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    9cee:	05 4d       	mov	r13,	r5	;
    9cf0:	81 4e 1a 00 	mov	r14,	26(r1)	; 0x001a
    9cf4:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c

00009cf8 <.Loc.855.1>:
    9cf8:	34 40 6e 8f 	mov	#36718,	r4	;#0x8f6e
    9cfc:	0c 46       	mov	r6,	r12	;
    9cfe:	0d 47       	mov	r7,	r13	;
    9d00:	4e 43       	clr.b	r14		;
    9d02:	0f 4e       	mov	r14,	r15	;
    9d04:	18 41 04 00 	mov	4(r1),	r8	;

00009d08 <.LVL30>:
    9d08:	19 41 06 00 	mov	6(r1),	r9	;
    9d0c:	0a 4e       	mov	r14,	r10	;
    9d0e:	0b 4e       	mov	r14,	r11	;
    9d10:	84 12       	call	r4		;

00009d12 <.LVL31>:
    9d12:	81 4c 1c 00 	mov	r12,	28(r1)	; 0x001c
    9d16:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010
    9d1a:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012
    9d1e:	81 4f 14 00 	mov	r15,	20(r1)	; 0x0014

00009d22 <.LVL32>:
    9d22:	0c 46       	mov	r6,	r12	;

00009d24 <.LVL33>:
    9d24:	0d 47       	mov	r7,	r13	;

00009d26 <.LVL34>:
    9d26:	0e 4a       	mov	r10,	r14	;

00009d28 <.LVL35>:
    9d28:	0f 4a       	mov	r10,	r15	;

00009d2a <.LVL36>:
    9d2a:	18 41 0a 00 	mov	10(r1),	r8	;0x0000a
    9d2e:	09 45       	mov	r5,	r9	;
    9d30:	1a 41 1a 00 	mov	26(r1),	r10	;0x0001a
    9d34:	1b 41 0c 00 	mov	12(r1),	r11	;0x0000c
    9d38:	84 12       	call	r4		;

00009d3a <.LVL37>:
    9d3a:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    9d3e:	05 4d       	mov	r13,	r5	;
    9d40:	06 4e       	mov	r14,	r6	;
    9d42:	07 4f       	mov	r15,	r7	;

00009d44 <.LVL40>:
    9d44:	0c 48       	mov	r8,	r12	;

00009d46 <.LVL41>:
    9d46:	0d 49       	mov	r9,	r13	;
    9d48:	0e 4a       	mov	r10,	r14	;
    9d4a:	1f 41 0c 00 	mov	12(r1),	r15	;0x0000c
    9d4e:	18 41 0e 00 	mov	14(r1),	r8	;0x0000e
    9d52:	19 41 16 00 	mov	22(r1),	r9	;0x00016
    9d56:	1a 41 18 00 	mov	24(r1),	r10	;0x00018
    9d5a:	1b 41 08 00 	mov	8(r1),	r11	;
    9d5e:	84 12       	call	r4		;

00009d60 <.LVL44>:
    9d60:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9d64:	81 4d 18 00 	mov	r13,	24(r1)	; 0x0018
    9d68:	81 4e 1a 00 	mov	r14,	26(r1)	; 0x001a
    9d6c:	81 4f 1e 00 	mov	r15,	30(r1)	; 0x001e

00009d70 <.LVL47>:
    9d70:	1c 41 04 00 	mov	4(r1),	r12	;

00009d74 <.LVL48>:
    9d74:	1d 41 06 00 	mov	6(r1),	r13	;

00009d78 <.LVL49>:
    9d78:	4e 43       	clr.b	r14		;

00009d7a <.LVL50>:
    9d7a:	0f 4e       	mov	r14,	r15	;

00009d7c <.LVL51>:
    9d7c:	1b 41 08 00 	mov	8(r1),	r11	;
    9d80:	84 12       	call	r4		;

00009d82 <.LVL52>:
    9d82:	1a 41 0a 00 	mov	10(r1),	r10	;0x0000a
    9d86:	0a 5c       	add	r12,	r10	;
    9d88:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    9d8c:	58 43       	mov.b	#1,	r8	;r3 As==01
    9d8e:	0a 9c       	cmp	r12,	r10	;
    9d90:	01 28       	jnc	$+4      	;abs 0x9d94
    9d92:	48 43       	clr.b	r8		;

00009d94 <.L9>:
    9d94:	0c 4d       	mov	r13,	r12	;
    9d96:	0c 55       	add	r5,	r12	;
    9d98:	5a 43       	mov.b	#1,	r10	;r3 As==01
    9d9a:	0c 9d       	cmp	r13,	r12	;
    9d9c:	01 28       	jnc	$+4      	;abs 0x9da0
    9d9e:	4a 43       	clr.b	r10		;

00009da0 <.L10>:
    9da0:	08 5c       	add	r12,	r8	;
    9da2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9da4:	08 9c       	cmp	r12,	r8	;
    9da6:	01 28       	jnc	$+4      	;abs 0x9daa
    9da8:	4d 43       	clr.b	r13		;

00009daa <.L11>:
    9daa:	0a dd       	bis	r13,	r10	;
    9dac:	0c 4e       	mov	r14,	r12	;
    9dae:	0c 56       	add	r6,	r12	;
    9db0:	59 43       	mov.b	#1,	r9	;r3 As==01
    9db2:	0c 9e       	cmp	r14,	r12	;
    9db4:	01 28       	jnc	$+4      	;abs 0x9db8
    9db6:	49 43       	clr.b	r9		;

00009db8 <.L12>:
    9db8:	0a 5c       	add	r12,	r10	;
    9dba:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9dbc:	0a 9c       	cmp	r12,	r10	;
    9dbe:	01 28       	jnc	$+4      	;abs 0x9dc2
    9dc0:	4d 43       	clr.b	r13		;

00009dc2 <.L13>:
    9dc2:	09 dd       	bis	r13,	r9	;
    9dc4:	0f 57       	add	r7,	r15	;
    9dc6:	09 5f       	add	r15,	r9	;

00009dc8 <.LVL54>:
    9dc8:	09 97       	cmp	r7,	r9	;
    9dca:	0e 28       	jnc	$+30     	;abs 0x9de8
    9dcc:	07 99       	cmp	r9,	r7	;
    9dce:	35 21       	jnz	$+620    	;abs 0xa03a
    9dd0:	0a 96       	cmp	r6,	r10	;
    9dd2:	0a 28       	jnc	$+22     	;abs 0x9de8
    9dd4:	06 9a       	cmp	r10,	r6	;
    9dd6:	31 21       	jnz	$+612    	;abs 0xa03a
    9dd8:	08 95       	cmp	r5,	r8	;
    9dda:	06 28       	jnc	$+14     	;abs 0x9de8
    9ddc:	05 98       	cmp	r8,	r5	;
    9dde:	2d 21       	jnz	$+604    	;abs 0xa03a
    9de0:	91 91 0a 00 	cmp	10(r1),	12(r1)	;0x0000a, 0x000c
    9de4:	0c 00 
    9de6:	29 2d       	jc	$+596    	;abs 0xa03a

00009de8 <.L70>:
    9de8:	47 43       	clr.b	r7		;

00009dea <.LVL55>:
    9dea:	05 47       	mov	r7,	r5	;
    9dec:	91 43 0e 00 	mov	#1,	14(r1)	;r3 As==01, 0x000e

00009df0 <.L93>:
    9df0:	81 47 0a 00 	mov	r7,	10(r1)	; 0x000a

00009df4 <.LVL56>:
    9df4:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9df8:	00 00 
    9dfa:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    9dfe:	0d 48       	mov	r8,	r13	;
    9e00:	0e 4a       	mov	r10,	r14	;
    9e02:	0f 49       	mov	r9,	r15	;
    9e04:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    9e08:	14 41 1c 00 	mov	28(r1),	r4	;0x0001c
    9e0c:	04 5c       	add	r12,	r4	;
    9e0e:	5b 43       	mov.b	#1,	r11	;r3 As==01
    9e10:	04 9c       	cmp	r12,	r4	;
    9e12:	01 28       	jnc	$+4      	;abs 0x9e16
    9e14:	4b 43       	clr.b	r11		;

00009e16 <.L16>:
    9e16:	16 41 10 00 	mov	16(r1),	r6	;0x00010
    9e1a:	06 5d       	add	r13,	r6	;
    9e1c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e1e:	06 9d       	cmp	r13,	r6	;
    9e20:	01 28       	jnc	$+4      	;abs 0x9e24
    9e22:	4c 43       	clr.b	r12		;

00009e24 <.L17>:
    9e24:	0b 56       	add	r6,	r11	;
    9e26:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9e28:	0b 96       	cmp	r6,	r11	;
    9e2a:	01 28       	jnc	$+4      	;abs 0x9e2e
    9e2c:	4d 43       	clr.b	r13		;

00009e2e <.L18>:
    9e2e:	0c dd       	bis	r13,	r12	;
    9e30:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    9e34:	0d 5e       	add	r14,	r13	;
    9e36:	56 43       	mov.b	#1,	r6	;r3 As==01
    9e38:	0d 9e       	cmp	r14,	r13	;
    9e3a:	01 28       	jnc	$+4      	;abs 0x9e3e
    9e3c:	46 43       	clr.b	r6		;

00009e3e <.L19>:
    9e3e:	0e 4c       	mov	r12,	r14	;
    9e40:	0e 5d       	add	r13,	r14	;
    9e42:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e44:	0e 9d       	cmp	r13,	r14	;
    9e46:	01 28       	jnc	$+4      	;abs 0x9e4a
    9e48:	4c 43       	clr.b	r12		;

00009e4a <.L20>:
    9e4a:	06 dc       	bis	r12,	r6	;
    9e4c:	1f 51 14 00 	add	20(r1),	r15	;0x00014
    9e50:	81 44 08 00 	mov	r4,	8(r1)	;
    9e54:	81 4e 04 00 	mov	r14,	4(r1)	;
    9e58:	06 5f       	add	r15,	r6	;
    9e5a:	81 46 06 00 	mov	r6,	6(r1)	;

00009e5e <.LVL59>:
    9e5e:	16 91 14 00 	cmp	20(r1),	r6	;0x00014
    9e62:	12 28       	jnc	$+38     	;abs 0x9e88
    9e64:	81 96 14 00 	cmp	r6,	20(r1)	; 0x0014
    9e68:	13 20       	jnz	$+40     	;abs 0x9e90
    9e6a:	1e 91 12 00 	cmp	18(r1),	r14	;0x00012
    9e6e:	0c 28       	jnc	$+26     	;abs 0x9e88
    9e70:	81 9e 12 00 	cmp	r14,	18(r1)	; 0x0012
    9e74:	0d 20       	jnz	$+28     	;abs 0x9e90
    9e76:	1b 91 10 00 	cmp	16(r1),	r11	;0x00010
    9e7a:	06 28       	jnc	$+14     	;abs 0x9e88
    9e7c:	81 9b 10 00 	cmp	r11,	16(r1)	; 0x0010
    9e80:	07 20       	jnz	$+16     	;abs 0x9e90
    9e82:	14 91 1c 00 	cmp	28(r1),	r4	;0x0001c
    9e86:	04 2c       	jc	$+10     	;abs 0x9e90

00009e88 <.L71>:
    9e88:	57 43       	mov.b	#1,	r7	;r3 As==01
    9e8a:	45 43       	clr.b	r5		;
    9e8c:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a

00009e90 <.L21>:
    9e90:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9e94:	00 00 
    9e96:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    9e9a:	0d 48       	mov	r8,	r13	;
    9e9c:	0e 4a       	mov	r10,	r14	;

00009e9e <.LVL62>:
    9e9e:	0f 49       	mov	r9,	r15	;
    9ea0:	81 4b 02 00 	mov	r11,	2(r1)	;
    9ea4:	b0 12 54 a4 	call	#42068		;#0xa454

00009ea8 <.LVL63>:
    9ea8:	19 41 16 00 	mov	22(r1),	r9	;0x00016

00009eac <.LVL64>:
    9eac:	09 5c       	add	r12,	r9	;
    9eae:	5a 43       	mov.b	#1,	r10	;r3 As==01
    9eb0:	1b 41 02 00 	mov	2(r1),	r11	;

00009eb4 <.LVL65>:
    9eb4:	09 9c       	cmp	r12,	r9	;
    9eb6:	01 28       	jnc	$+4      	;abs 0x9eba
    9eb8:	4a 43       	clr.b	r10		;

00009eba <.L28>:
    9eba:	18 41 18 00 	mov	24(r1),	r8	;0x00018
    9ebe:	08 5d       	add	r13,	r8	;
    9ec0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9ec2:	08 9d       	cmp	r13,	r8	;
    9ec4:	01 28       	jnc	$+4      	;abs 0x9ec8
    9ec6:	4c 43       	clr.b	r12		;

00009ec8 <.L29>:
    9ec8:	0a 58       	add	r8,	r10	;
    9eca:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9ecc:	0a 98       	cmp	r8,	r10	;
    9ece:	01 28       	jnc	$+4      	;abs 0x9ed2
    9ed0:	4d 43       	clr.b	r13		;

00009ed2 <.L30>:
    9ed2:	0c dd       	bis	r13,	r12	;
    9ed4:	18 41 1a 00 	mov	26(r1),	r8	;0x0001a
    9ed8:	08 5e       	add	r14,	r8	;
    9eda:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9edc:	08 9e       	cmp	r14,	r8	;
    9ede:	01 28       	jnc	$+4      	;abs 0x9ee2
    9ee0:	4d 43       	clr.b	r13		;

00009ee2 <.L31>:
    9ee2:	0c 58       	add	r8,	r12	;
    9ee4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9ee6:	0c 98       	cmp	r8,	r12	;
    9ee8:	01 28       	jnc	$+4      	;abs 0x9eec
    9eea:	4e 43       	clr.b	r14		;

00009eec <.L32>:
    9eec:	0d de       	bis	r14,	r13	;
    9eee:	1f 51 1e 00 	add	30(r1),	r15	;0x0001e
    9ef2:	0f 5d       	add	r13,	r15	;
    9ef4:	07 59       	add	r9,	r7	;
    9ef6:	54 43       	mov.b	#1,	r4	;r3 As==01

00009ef8 <.LVL66>:
    9ef8:	07 99       	cmp	r9,	r7	;
    9efa:	01 28       	jnc	$+4      	;abs 0x9efe
    9efc:	44 43       	clr.b	r4		;

00009efe <.L33>:
    9efe:	0d 4a       	mov	r10,	r13	;
    9f00:	0d 55       	add	r5,	r13	;
    9f02:	56 43       	mov.b	#1,	r6	;r3 As==01

00009f04 <.LVL67>:
    9f04:	0d 9a       	cmp	r10,	r13	;
    9f06:	01 28       	jnc	$+4      	;abs 0x9f0a
    9f08:	46 43       	clr.b	r6		;

00009f0a <.L34>:
    9f0a:	04 5d       	add	r13,	r4	;
    9f0c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9f0e:	04 9d       	cmp	r13,	r4	;
    9f10:	01 28       	jnc	$+4      	;abs 0x9f14
    9f12:	4e 43       	clr.b	r14		;

00009f14 <.L35>:
    9f14:	06 de       	bis	r14,	r6	;
    9f16:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    9f1a:	0d 5c       	add	r12,	r13	;
    9f1c:	55 43       	mov.b	#1,	r5	;r3 As==01
    9f1e:	0d 9c       	cmp	r12,	r13	;
    9f20:	01 28       	jnc	$+4      	;abs 0x9f24
    9f22:	45 43       	clr.b	r5		;

00009f24 <.L36>:
    9f24:	06 5d       	add	r13,	r6	;
    9f26:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9f28:	06 9d       	cmp	r13,	r6	;
    9f2a:	01 28       	jnc	$+4      	;abs 0x9f2e
    9f2c:	4c 43       	clr.b	r12		;

00009f2e <.L37>:
    9f2e:	05 dc       	bis	r12,	r5	;
    9f30:	1f 51 0a 00 	add	10(r1),	r15	;0x0000a
    9f34:	05 5f       	add	r15,	r5	;

00009f36 <.LBE30>:
    9f36:	1a 41 34 00 	mov	52(r1),	r10	;0x00034
    9f3a:	1a 51 42 00 	add	66(r1),	r10	;0x00042

00009f3e <.Loc.876.1>:
    9f3e:	2a 52       	add	#4,	r10	;r2 As==10

00009f40 <.Loc.875.1>:
    9f40:	81 4a 50 00 	mov	r10,	80(r1)	; 0x0050

00009f44 <.Loc.877.1>:
    9f44:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    9f48:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    9f4c:	0c 43       	clr	r12		;
    9f4e:	0c 8d       	sub	r13,	r12	;
    9f50:	0c dd       	bis	r13,	r12	;
    9f52:	5c 03       	rrum	#1,	r12	;
    9f54:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    9f58:	81 4c 4e 00 	mov	r12,	78(r1)	; 0x004e
    9f5c:	4c 43       	clr.b	r12		;
    9f5e:	38 40 54 a4 	mov	#42068,	r8	;#0xa454

00009f62 <.Loc.883.1>:
    9f62:	59 43       	mov.b	#1,	r9	;r3 As==01

00009f64 <.L38>:
    9f64:	3d 40 ff 1f 	mov	#8191,	r13	;#0x1fff
    9f68:	0d 95       	cmp	r5,	r13	;
    9f6a:	6c 28       	jnc	$+218    	;abs 0xa044
    9f6c:	0c 93       	cmp	#0,	r12	;r3 As==00
    9f6e:	02 24       	jz	$+6      	;abs 0x9f74
    9f70:	81 4a 50 00 	mov	r10,	80(r1)	; 0x0050

00009f74 <.L43>:
    9f74:	18 41 50 00 	mov	80(r1),	r8	;0x00050

00009f78 <.Loc.877.1>:
    9f78:	4d 43       	clr.b	r13		;

00009f7a <.Loc.892.1>:
    9f7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9f7c:	0e 4d       	mov	r13,	r14	;

00009f7e <.L44>:
    9f7e:	3f 40 ff 0f 	mov	#4095,	r15	;#0x0fff
    9f82:	0f 95       	cmp	r5,	r15	;
    9f84:	86 28       	jnc	$+270    	;abs 0xa092

00009f86 <.Loc.892.1>:
    9f86:	0a 47       	mov	r7,	r10	;
    9f88:	0a 57       	add	r7,	r10	;
    9f8a:	0f 4c       	mov	r12,	r15	;
    9f8c:	0a 97       	cmp	r7,	r10	;
    9f8e:	01 28       	jnc	$+4      	;abs 0x9f92
    9f90:	0f 4e       	mov	r14,	r15	;

00009f92 <.L45>:
    9f92:	09 44       	mov	r4,	r9	;
    9f94:	09 54       	add	r4,	r9	;
    9f96:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9f98:	09 94       	cmp	r4,	r9	;
    9f9a:	01 28       	jnc	$+4      	;abs 0x9f9e
    9f9c:	4d 43       	clr.b	r13		;

00009f9e <.L46>:
    9f9e:	04 4f       	mov	r15,	r4	;

00009fa0 <.LVL71>:
    9fa0:	04 59       	add	r9,	r4	;
    9fa2:	0f 4c       	mov	r12,	r15	;
    9fa4:	04 99       	cmp	r9,	r4	;
    9fa6:	01 28       	jnc	$+4      	;abs 0x9faa
    9fa8:	0f 4e       	mov	r14,	r15	;

00009faa <.L47>:
    9faa:	0d df       	bis	r15,	r13	;
    9fac:	0f 46       	mov	r6,	r15	;
    9fae:	0f 56       	add	r6,	r15	;
    9fb0:	59 43       	mov.b	#1,	r9	;r3 As==01
    9fb2:	0f 96       	cmp	r6,	r15	;
    9fb4:	01 28       	jnc	$+4      	;abs 0x9fb8
    9fb6:	49 43       	clr.b	r9		;

00009fb8 <.L48>:
    9fb8:	06 4d       	mov	r13,	r6	;
    9fba:	06 5f       	add	r15,	r6	;
    9fbc:	0d 4c       	mov	r12,	r13	;
    9fbe:	06 9f       	cmp	r15,	r6	;
    9fc0:	01 28       	jnc	$+4      	;abs 0x9fc4
    9fc2:	0d 4e       	mov	r14,	r13	;

00009fc4 <.L49>:
    9fc4:	09 dd       	bis	r13,	r9	;
    9fc6:	05 55       	rla	r5		;
    9fc8:	07 4a       	mov	r10,	r7	;
    9fca:	05 59       	add	r9,	r5	;

00009fcc <.LVL72>:
    9fcc:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    9fd0:	01 34       	jge	$+4      	;abs 0x9fd4

00009fd2 <.Loc.894.1>:
    9fd2:	17 d3       	bis	#1,	r7	;r3 As==01

00009fd4 <.L50>:
    9fd4:	19 41 08 00 	mov	8(r1),	r9	;
    9fd8:	09 59       	rla	r9		;
    9fda:	0a 4c       	mov	r12,	r10	;
    9fdc:	19 91 08 00 	cmp	8(r1),	r9	;
    9fe0:	01 28       	jnc	$+4      	;abs 0x9fe4
    9fe2:	0a 4e       	mov	r14,	r10	;

00009fe4 <.L52>:
    9fe4:	0f 4b       	mov	r11,	r15	;
    9fe6:	0f 5b       	add	r11,	r15	;
    9fe8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9fea:	0f 9b       	cmp	r11,	r15	;
    9fec:	01 28       	jnc	$+4      	;abs 0x9ff0
    9fee:	4d 43       	clr.b	r13		;

00009ff0 <.L53>:
    9ff0:	0b 4a       	mov	r10,	r11	;

00009ff2 <.LVL74>:
    9ff2:	0b 5f       	add	r15,	r11	;
    9ff4:	0a 4c       	mov	r12,	r10	;
    9ff6:	0b 9f       	cmp	r15,	r11	;
    9ff8:	01 28       	jnc	$+4      	;abs 0x9ffc
    9ffa:	0a 4e       	mov	r14,	r10	;

00009ffc <.L54>:
    9ffc:	0d da       	bis	r10,	r13	;
    9ffe:	1f 41 04 00 	mov	4(r1),	r15	;
    a002:	0f 5f       	rla	r15		;
    a004:	5a 43       	mov.b	#1,	r10	;r3 As==01
    a006:	1f 91 04 00 	cmp	4(r1),	r15	;
    a00a:	01 28       	jnc	$+4      	;abs 0xa00e
    a00c:	4a 43       	clr.b	r10		;

0000a00e <.L55>:
    a00e:	0d 5f       	add	r15,	r13	;
    a010:	81 4c 04 00 	mov	r12,	4(r1)	;
    a014:	0d 9f       	cmp	r15,	r13	;
    a016:	02 28       	jnc	$+6      	;abs 0xa01c
    a018:	81 4e 04 00 	mov	r14,	4(r1)	;

0000a01c <.L56>:
    a01c:	1a d1 04 00 	bis	4(r1),	r10	;
    a020:	1f 41 06 00 	mov	6(r1),	r15	;
    a024:	0f 5f       	rla	r15		;
    a026:	81 49 08 00 	mov	r9,	8(r1)	;
    a02a:	81 4d 04 00 	mov	r13,	4(r1)	;
    a02e:	0a 5f       	add	r15,	r10	;
    a030:	81 4a 06 00 	mov	r10,	6(r1)	;
    a034:	38 53       	add	#-1,	r8	;r3 As==11
    a036:	0d 4c       	mov	r12,	r13	;
    a038:	a2 3f       	jmp	$-186    	;abs 0x9f7e

0000a03a <.L69>:
    a03a:	47 43       	clr.b	r7		;

0000a03c <.LVL76>:
    a03c:	05 47       	mov	r7,	r5	;
    a03e:	81 47 0e 00 	mov	r7,	14(r1)	; 0x000e
    a042:	d6 3e       	jmp	$-594    	;abs 0x9df0

0000a044 <.L41>:
    a044:	17 b3       	bit	#1,	r7	;r3 As==01
    a046:	13 24       	jz	$+40     	;abs 0xa06e

0000a048 <.Loc.883.1>:
    a048:	81 49 00 00 	mov	r9,	0(r1)	;
    a04c:	1c 41 08 00 	mov	8(r1),	r12	;
    a050:	0d 4b       	mov	r11,	r13	;
    a052:	1e 41 04 00 	mov	4(r1),	r14	;
    a056:	1f 41 06 00 	mov	6(r1),	r15	;
    a05a:	88 12       	call	r8		;

0000a05c <.LVL78>:
    a05c:	81 4c 08 00 	mov	r12,	8(r1)	;
    a060:	0b 4d       	mov	r13,	r11	;
    a062:	81 4e 04 00 	mov	r14,	4(r1)	;
    a066:	3f d0 00 80 	bis	#32768,	r15	;#0x8000

0000a06a <.LVL79>:
    a06a:	81 4f 06 00 	mov	r15,	6(r1)	;

0000a06e <.L39>:
    a06e:	81 49 00 00 	mov	r9,	0(r1)	;
    a072:	0c 47       	mov	r7,	r12	;
    a074:	0d 44       	mov	r4,	r13	;
    a076:	0e 46       	mov	r6,	r14	;
    a078:	0f 45       	mov	r5,	r15	;
    a07a:	81 4b 02 00 	mov	r11,	2(r1)	;
    a07e:	88 12       	call	r8		;

0000a080 <.LVL81>:
    a080:	07 4c       	mov	r12,	r7	;

0000a082 <.LVL82>:
    a082:	04 4d       	mov	r13,	r4	;
    a084:	06 4e       	mov	r14,	r6	;
    a086:	05 4f       	mov	r15,	r5	;

0000a088 <.LVL83>:
    a088:	1a 53       	inc	r10		;
    a08a:	0c 49       	mov	r9,	r12	;
    a08c:	1b 41 02 00 	mov	2(r1),	r11	;

0000a090 <.LVL84>:
    a090:	69 3f       	jmp	$-300    	;abs 0x9f64

0000a092 <.L73>:
    a092:	0d 93       	cmp	#0,	r13	;r3 As==00
    a094:	02 24       	jz	$+6      	;abs 0xa09a
    a096:	81 48 50 00 	mov	r8,	80(r1)	; 0x0050

0000a09a <.L59>:
    a09a:	0e 47       	mov	r7,	r14	;
    a09c:	7e f0 ff 00 	and.b	#255,	r14	;#0x00ff
    a0a0:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    a0a4:	26 20       	jnz	$+78     	;abs 0xa0f2

0000a0a6 <.Loc.900.1>:
    a0a6:	0c 47       	mov	r7,	r12	;
    a0a8:	3c f0 00 01 	and	#256,	r12	;#0x0100
    a0ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    a0ae:	21 20       	jnz	$+68     	;abs 0xa0f2

0000a0b0 <.Loc.909.1>:
    a0b0:	1b d1 08 00 	bis	8(r1),	r11	;

0000a0b4 <.LVL85>:
    a0b4:	1b d1 04 00 	bis	4(r1),	r11	;
    a0b8:	1b d1 06 00 	bis	6(r1),	r11	;
    a0bc:	0b 93       	cmp	#0,	r11	;r3 As==00
    a0be:	19 24       	jz	$+52     	;abs 0xa0f2

0000a0c0 <.Loc.915.1>:
    a0c0:	0e 57       	add	r7,	r14	;
    a0c2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a0c4:	0e 97       	cmp	r7,	r14	;
    a0c6:	01 28       	jnc	$+4      	;abs 0xa0ca
    a0c8:	0d 4c       	mov	r12,	r13	;

0000a0ca <.L62>:
    a0ca:	4c 43       	clr.b	r12		;
    a0cc:	0d 54       	add	r4,	r13	;
    a0ce:	5f 43       	mov.b	#1,	r15	;r3 As==01
    a0d0:	0d 94       	cmp	r4,	r13	;
    a0d2:	01 28       	jnc	$+4      	;abs 0xa0d6
    a0d4:	0f 4c       	mov	r12,	r15	;

0000a0d6 <.L64>:
    a0d6:	0c df       	bis	r15,	r12	;
    a0d8:	4f 43       	clr.b	r15		;
    a0da:	0c 56       	add	r6,	r12	;
    a0dc:	5a 43       	mov.b	#1,	r10	;r3 As==01
    a0de:	0c 96       	cmp	r6,	r12	;
    a0e0:	01 28       	jnc	$+4      	;abs 0xa0e4
    a0e2:	0a 4f       	mov	r15,	r10	;

0000a0e4 <.L66>:
    a0e4:	0f da       	bis	r10,	r15	;

0000a0e6 <.LVL86>:
    a0e6:	07 4e       	mov	r14,	r7	;
    a0e8:	37 f0 00 ff 	and	#65280,	r7	;#0xff00
    a0ec:	04 4d       	mov	r13,	r4	;
    a0ee:	06 4c       	mov	r12,	r6	;
    a0f0:	05 5f       	add	r15,	r5	;

0000a0f2 <.L60>:
    a0f2:	81 47 52 00 	mov	r7,	82(r1)	; 0x0052
    a0f6:	81 44 54 00 	mov	r4,	84(r1)	; 0x0054
    a0fa:	81 46 56 00 	mov	r6,	86(r1)	; 0x0056
    a0fe:	81 45 58 00 	mov	r5,	88(r1)	; 0x0058

0000a102 <.Loc.922.1>:
    a102:	b1 40 03 00 	mov	#3,	76(r1)	; 0x004c
    a106:	4c 00 

0000a108 <.Loc.923.1>:
    a108:	0c 41       	mov	r1,	r12	;
    a10a:	3c 50 4c 00 	add	#76,	r12	;#0x004c
    a10e:	30 40 46 9c 	br	#0x9c46		;

0000a112 <__gedf2>:
    a112:	0a 15       	pushm	#1,	r10	;16-bit words

0000a114 <.LCFI0>:
    a114:	31 80 2c 00 	sub	#44,	r1	;#0x002c

0000a118 <.LCFI1>:
    a118:	81 4c 00 00 	mov	r12,	0(r1)	;
    a11c:	81 4d 02 00 	Address 0x000000000000a11e is out of bounds.
mov	r13,	-1(r1)	; 0xffff

0000a11e <L0>:
    a11e:	02 00       	mova	@r0,	r2	;
    a120:	81 4e 04 00 	mov	r14,	4(r1)	;
    a124:	81 4f 06 00 	mov	r15,	6(r1)	;

0000a128 <.Loc.1243.1>:
    a128:	91 41 30 00 	mov	48(r1),	8(r1)	;0x00030
    a12c:	08 00 
    a12e:	91 41 32 00 	mov	50(r1),	10(r1)	;0x00032, 0x000a
    a132:	0a 00 
    a134:	91 41 34 00 	mov	52(r1),	12(r1)	;0x00034, 0x000c
    a138:	0c 00 
    a13a:	91 41 36 00 	mov	54(r1),	14(r1)	;0x00036, 0x000e
    a13e:	0e 00 

0000a140 <.Loc.1245.1>:
    a140:	3a 40 06 ab 	mov	#43782,	r10	;#0xab06
    a144:	0d 41       	mov	r1,	r13	;
    a146:	3d 50 10 00 	add	#16,	r13	;#0x0010
    a14a:	0c 41       	mov	r1,	r12	;

0000a14c <.LVL1>:
    a14c:	8a 12       	call	r10		;

0000a14e <.LVL2>:
    a14e:	0d 41       	mov	r1,	r13	;
    a150:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    a154:	0c 41       	mov	r1,	r12	;
    a156:	3c 52       	add	#8,	r12	;r2 As==11
    a158:	8a 12       	call	r10		;

0000a15a <.LVL3>:
    a15a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a15c:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    a160:	0f 2c       	jc	$+32     	;abs 0xa180

0000a162 <.Loc.1248.1>:
    a162:	1c 91 1e 00 	cmp	30(r1),	r12	;0x0001e
    a166:	0c 2c       	jc	$+26     	;abs 0xa180

0000a168 <.Loc.1250.1>:
    a168:	0d 41       	mov	r1,	r13	;
    a16a:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    a16e:	0c 41       	mov	r1,	r12	;
    a170:	3c 50 10 00 	add	#16,	r12	;#0x0010
    a174:	b0 12 6c ac 	call	#44140		;#0xac6c

0000a178 <.L1>:
    a178:	31 50 2c 00 	add	#44,	r1	;#0x002c
    a17c:	0a 17       	popm	#1,	r10	;16-bit words
    a17e:	30 41       	ret			

0000a180 <.L4>:
    a180:	3c 43       	mov	#-1,	r12	;r3 As==11
    a182:	fa 3f       	jmp	$-10     	;abs 0xa178

0000a184 <__mspabi_fixdli>:
    a184:	0a 15       	pushm	#1,	r10	;16-bit words

0000a186 <L0>:
    a186:	31 80 18 00 	sub	#24,	r1	;#0x0018

0000a18a <.LCFI1>:
    a18a:	81 4c 02 00 	mov	r12,	2(r1)	;
    a18e:	81 4d 04 00 	mov	r13,	4(r1)	;
    a192:	81 4e 06 00 	mov	r14,	6(r1)	;
    a196:	81 4f 08 00 	mov	r15,	8(r1)	;

0000a19a <.Loc.1401.1>:
    a19a:	0d 41       	mov	r1,	r13	;
    a19c:	3d 50 0a 00 	add	#10,	r13	;#0x000a
    a1a0:	0c 41       	mov	r1,	r12	;

0000a1a2 <.LVL1>:
    a1a2:	2c 53       	incd	r12		;
    a1a4:	b0 12 06 ab 	call	#43782		;#0xab06

0000a1a8 <.LVL2>:
    a1a8:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a

0000a1ac <.Loc.1405.1>:
    a1ac:	6a 43       	mov.b	#2,	r10	;r3 As==10
    a1ae:	0a 9c       	cmp	r12,	r10	;
    a1b0:	33 2c       	jc	$+104    	;abs 0xa218

0000a1b2 <.Loc.1408.1>:
    a1b2:	2c 92       	cmp	#4,	r12	;r2 As==10
    a1b4:	0a 20       	jnz	$+22     	;abs 0xa1ca

0000a1b6 <.L4>:
    a1b6:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    a1ba:	2a 20       	jnz	$+86     	;abs 0xa210
    a1bc:	3c 43       	mov	#-1,	r12	;r3 As==11
    a1be:	3d 40 ff 7f 	mov	#32767,	r13	;#0x7fff

0000a1c2 <.L1>:
    a1c2:	31 50 18 00 	add	#24,	r1	;#0x0018
    a1c6:	0a 17       	popm	#1,	r10	;16-bit words
    a1c8:	30 41       	ret			

0000a1ca <.L3>:
    a1ca:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    a1ce:	0c 93       	cmp	#0,	r12	;r3 As==00
    a1d0:	23 38       	jl	$+72     	;abs 0xa218

0000a1d2 <.Loc.1413.1>:
    a1d2:	7b 40 1e 00 	mov.b	#30,	r11	;#0x001e
    a1d6:	0b 9c       	cmp	r12,	r11	;
    a1d8:	ee 3b       	jl	$-34     	;abs 0xa1b6

0000a1da <.Loc.1415.1>:
    a1da:	7d 40 3c 00 	mov.b	#60,	r13	;#0x003c
    a1de:	0d 8c       	sub	r12,	r13	;
    a1e0:	81 4d 00 00 	mov	r13,	0(r1)	;
    a1e4:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    a1e8:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    a1ec:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    a1f0:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    a1f4:	b0 12 54 a4 	call	#42068		;#0xa454

0000a1f8 <.LVL7>:
    a1f8:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    a1fc:	e2 27       	jz	$-58     	;abs 0xa1c2

0000a1fe <.Loc.1416.1>:
    a1fe:	4e 43       	clr.b	r14		;
    a200:	4f 43       	clr.b	r15		;
    a202:	0a 4e       	mov	r14,	r10	;
    a204:	0b 4f       	mov	r15,	r11	;
    a206:	0a 8c       	sub	r12,	r10	;
    a208:	0b 7d       	subc	r13,	r11	;
    a20a:	0c 4a       	mov	r10,	r12	;

0000a20c <.LVL8>:
    a20c:	0d 4b       	mov	r11,	r13	;
    a20e:	d9 3f       	jmp	$-76     	;abs 0xa1c2

0000a210 <.L6>:
    a210:	4c 43       	clr.b	r12		;
    a212:	3d 40 00 80 	mov	#32768,	r13	;#0x8000
    a216:	d5 3f       	jmp	$-84     	;abs 0xa1c2

0000a218 <.L7>:
    a218:	4c 43       	clr.b	r12		;
    a21a:	4d 43       	clr.b	r13		;
    a21c:	d2 3f       	jmp	$-90     	;abs 0xa1c2

0000a21e <__make_dp>:
    a21e:	31 80 0e 00 	sub	#14,	r1	;#0x000e

0000a222 <.LCFI0>:
    a222:	81 4c 00 00 	Address 0x000000000000a224 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000a224 <L0>:
	...

0000a226 <.Loc.1537.1>:
    a226:	81 4d 02 00 	mov	r13,	2(r1)	;

0000a22a <.Loc.1538.1>:
    a22a:	81 4e 04 00 	mov	r14,	4(r1)	;

0000a22e <.Loc.1539.1>:
    a22e:	91 41 10 00 	mov	16(r1),	6(r1)	;0x00010
    a232:	06 00 
    a234:	91 41 12 00 	mov	18(r1),	8(r1)	;0x00012
    a238:	08 00 
    a23a:	91 41 14 00 	mov	20(r1),	10(r1)	;0x00014, 0x000a
    a23e:	0a 00 
    a240:	91 41 16 00 	mov	22(r1),	12(r1)	;0x00016, 0x000c
    a244:	0c 00 

0000a246 <.Loc.1540.1>:
    a246:	0c 41       	mov	r1,	r12	;

0000a248 <.LVL1>:
    a248:	b0 12 1e a8 	call	#43038		;#0xa81e

0000a24c <.LVL2>:
    a24c:	31 50 0e 00 	add	#14,	r1	;#0x000e
    a250:	30 41       	ret			

0000a252 <udivmodhi4>:
    a252:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

0000a256 <.Loc.35.1>:
    a256:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000a258 <.L2>:
    a258:	0d 9c       	cmp	r12,	r13	;
    a25a:	08 28       	jnc	$+18     	;abs 0xa26c

0000a25c <.L15>:
    a25c:	4f 43       	clr.b	r15		;

0000a25e <.L4>:
    a25e:	0b 93       	cmp	#0,	r11	;r3 As==00
    a260:	0d 20       	jnz	$+28     	;abs 0xa27c

0000a262 <.L5>:
    a262:	0e 93       	cmp	#0,	r14	;r3 As==00
    a264:	01 24       	jz	$+4      	;abs 0xa268
    a266:	0f 4c       	mov	r12,	r15	;

0000a268 <.L1>:
    a268:	0c 4f       	mov	r15,	r12	;
    a26a:	30 41       	ret			

0000a26c <.L3>:
    a26c:	3f 53       	add	#-1,	r15	;r3 As==11

0000a26e <.Loc.38.1>:
    a26e:	0f 93       	cmp	#0,	r15	;r3 As==00
    a270:	f8 27       	jz	$-14     	;abs 0xa262

0000a272 <.Loc.38.1>:
    a272:	0d 93       	cmp	#0,	r13	;r3 As==00
    a274:	f3 3b       	jl	$-24     	;abs 0xa25c

0000a276 <.Loc.40.1>:
    a276:	0d 5d       	rla	r13		;

0000a278 <.Loc.41.1>:
    a278:	0b 5b       	rla	r11		;
    a27a:	ee 3f       	jmp	$-34     	;abs 0xa258

0000a27c <.L9>:
    a27c:	0c 9d       	cmp	r13,	r12	;
    a27e:	02 28       	jnc	$+6      	;abs 0xa284

0000a280 <.Loc.47.1>:
    a280:	0c 8d       	sub	r13,	r12	;

0000a282 <.Loc.48.1>:
    a282:	0f db       	bis	r11,	r15	;

0000a284 <.L8>:
    a284:	12 c3       	clrc			
    a286:	0b 10       	rrc	r11		;

0000a288 <.Loc.51.1>:
    a288:	12 c3       	clrc			
    a28a:	0d 10       	rrc	r13		;
    a28c:	e8 3f       	jmp	$-46     	;abs 0xa25e

0000a28e <__mspabi_divu>:
    a28e:	4e 43       	clr.b	r14		;
    a290:	b0 12 52 a2 	Address 0x000000000000a292 is out of bounds.
call	#65535		;#0xffff

0000a292 <L0>:
    a292:	52 a2 30 41 	Address 0x000000000000a294 is out of bounds.
dadd.b	&0xffff,r2	;0xffff

0000a294 <.LVL39>:
    a294:	30 41       	ret			

0000a296 <__mspabi_remu>:
    a296:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a298:	b0 12 52 a2 	call	#41554		;#0xa252

0000a29c <.LVL41>:
    a29c:	30 41       	ret			

0000a29e <udivmodsi4>:
    a29e:	5a 15       	pushm	#6,	r10	;16-bit words

0000a2a0 <.LCFI0>:
    a2a0:	0a 4c       	mov	r12,	r10	;
    a2a2:	0b 4d       	mov	r13,	r11	;

0000a2a4 <.LVL1>:
    a2a4:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000a2a8 <.Loc.35.1>:
    a2a8:	58 43       	mov.b	#1,	r8	;r3 As==01
    a2aa:	49 43       	clr.b	r9		;

0000a2ac <.Loc.38.1>:
    a2ac:	07 4b       	mov	r11,	r7	;

0000a2ae <.L2>:
    a2ae:	0f 9b       	cmp	r11,	r15	;
    a2b0:	11 28       	jnc	$+36     	;abs 0xa2d4
    a2b2:	07 9f       	cmp	r15,	r7	;
    a2b4:	02 20       	jnz	$+6      	;abs 0xa2ba
    a2b6:	0e 9a       	cmp	r10,	r14	;
    a2b8:	0d 28       	jnc	$+28     	;abs 0xa2d4

0000a2ba <.L20>:
    a2ba:	4c 43       	clr.b	r12		;

0000a2bc <.LVL3>:
    a2bc:	0d 4c       	mov	r12,	r13	;

0000a2be <.L5>:
    a2be:	07 48       	mov	r8,	r7	;
    a2c0:	07 d9       	bis	r9,	r7	;
    a2c2:	07 93       	cmp	#0,	r7	;r3 As==00
    a2c4:	19 20       	jnz	$+52     	;abs 0xa2f8

0000a2c6 <.L6>:
    a2c6:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    a2ca:	02 24       	jz	$+6      	;abs 0xa2d0
    a2cc:	0c 4a       	mov	r10,	r12	;
    a2ce:	0d 4b       	mov	r11,	r13	;

0000a2d0 <.L1>:
    a2d0:	55 17       	popm	#6,	r10	;16-bit words
    a2d2:	30 41       	ret			

0000a2d4 <.L3>:
    a2d4:	3d 53       	add	#-1,	r13	;r3 As==11

0000a2d6 <.Loc.38.1>:
    a2d6:	0d 93       	cmp	#0,	r13	;r3 As==00
    a2d8:	20 24       	jz	$+66     	;abs 0xa31a

0000a2da <.Loc.38.1>:
    a2da:	0f 93       	cmp	#0,	r15	;r3 As==00
    a2dc:	ee 3b       	jl	$-34     	;abs 0xa2ba

0000a2de <.Loc.40.1>:
    a2de:	05 4e       	mov	r14,	r5	;
    a2e0:	06 4f       	mov	r15,	r6	;
    a2e2:	05 5e       	add	r14,	r5	;
    a2e4:	06 6f       	addc	r15,	r6	;
    a2e6:	0e 45       	mov	r5,	r14	;

0000a2e8 <.LVL7>:
    a2e8:	0f 46       	mov	r6,	r15	;

0000a2ea <.LVL8>:
    a2ea:	05 48       	mov	r8,	r5	;
    a2ec:	06 49       	mov	r9,	r6	;
    a2ee:	05 58       	add	r8,	r5	;
    a2f0:	06 69       	addc	r9,	r6	;
    a2f2:	08 45       	mov	r5,	r8	;

0000a2f4 <.LVL9>:
    a2f4:	09 46       	mov	r6,	r9	;

0000a2f6 <.LVL10>:
    a2f6:	db 3f       	jmp	$-72     	;abs 0xa2ae

0000a2f8 <.L12>:
    a2f8:	0b 9f       	cmp	r15,	r11	;
    a2fa:	08 28       	jnc	$+18     	;abs 0xa30c
    a2fc:	0f 9b       	cmp	r11,	r15	;
    a2fe:	02 20       	jnz	$+6      	;abs 0xa304
    a300:	0a 9e       	cmp	r14,	r10	;
    a302:	04 28       	jnc	$+10     	;abs 0xa30c

0000a304 <.L16>:
    a304:	0a 8e       	sub	r14,	r10	;
    a306:	0b 7f       	subc	r15,	r11	;

0000a308 <.Loc.48.1>:
    a308:	0c d8       	bis	r8,	r12	;

0000a30a <.LVL13>:
    a30a:	0d d9       	bis	r9,	r13	;

0000a30c <.L10>:
    a30c:	12 c3       	clrc			
    a30e:	09 10       	rrc	r9		;
    a310:	08 10       	rrc	r8		;

0000a312 <.Loc.51.1>:
    a312:	12 c3       	clrc			
    a314:	0f 10       	rrc	r15		;
    a316:	0e 10       	rrc	r14		;
    a318:	d2 3f       	jmp	$-90     	;abs 0xa2be

0000a31a <.L14>:
    a31a:	0c 4d       	mov	r13,	r12	;

0000a31c <.LVL18>:
    a31c:	d4 3f       	jmp	$-86     	;abs 0xa2c6

0000a31e <__mspabi_divlu>:
    a31e:	21 83       	decd	r1		;

0000a320 <.LCFI5>:
    a320:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000a324 <L0>:
    a324:	b0 12 9e a2 	call	#41630		;#0xa29e

0000a328 <.LVL46>:
    a328:	21 53       	incd	r1		;
    a32a:	30 41       	ret			

0000a32c <__mspabi_slli_15>:
    a32c:	0c 5c       	rla	r12		;

0000a32e <__mspabi_slli_14>:
    a32e:	0c 5c       	rla	r12		;

0000a330 <__mspabi_slli_13>:
    a330:	0c 5c       	rla	r12		;

0000a332 <__mspabi_slli_12>:
    a332:	0c 5c       	rla	r12		;

0000a334 <__mspabi_slli_11>:
    a334:	0c 5c       	rla	r12		;

0000a336 <__mspabi_slli_10>:
    a336:	0c 5c       	rla	r12		;

0000a338 <__mspabi_slli_9>:
    a338:	0c 5c       	rla	r12		;

0000a33a <__mspabi_slli_8>:
    a33a:	0c 5c       	rla	r12		;

0000a33c <__mspabi_slli_7>:
    a33c:	0c 5c       	rla	r12		;

0000a33e <__mspabi_slli_6>:
    a33e:	0c 5c       	rla	r12		;

0000a340 <__mspabi_slli_5>:
    a340:	0c 5c       	rla	r12		;

0000a342 <__mspabi_slli_4>:
    a342:	0c 5c       	rla	r12		;

0000a344 <__mspabi_slli_3>:
    a344:	0c 5c       	rla	r12		;

0000a346 <__mspabi_slli_2>:
    a346:	0c 5c       	rla	r12		;

0000a348 <__mspabi_slli_1>:
    a348:	0c 5c       	rla	r12		;
    a34a:	30 41       	ret			

0000a34c <.L11>:
    a34c:	3d 53       	add	#-1,	r13	;r3 As==11
    a34e:	0c 5c       	rla	r12		;

0000a350 <__mspabi_slli>:
    a350:	0d 93       	cmp	#0,	r13	;r3 As==00
    a352:	fc 23       	jnz	$-6      	;abs 0xa34c
    a354:	30 41       	ret			

0000a356 <__mspabi_slll_15>:
    a356:	0c 5c       	rla	r12		;
    a358:	0d 6d       	rlc	r13		;

0000a35a <__mspabi_slll_14>:
    a35a:	0c 5c       	rla	r12		;
    a35c:	0d 6d       	rlc	r13		;

0000a35e <__mspabi_slll_13>:
    a35e:	0c 5c       	rla	r12		;
    a360:	0d 6d       	rlc	r13		;

0000a362 <__mspabi_slll_12>:
    a362:	0c 5c       	rla	r12		;
    a364:	0d 6d       	rlc	r13		;

0000a366 <__mspabi_slll_11>:
    a366:	0c 5c       	rla	r12		;
    a368:	0d 6d       	rlc	r13		;

0000a36a <__mspabi_slll_10>:
    a36a:	0c 5c       	rla	r12		;
    a36c:	0d 6d       	rlc	r13		;

0000a36e <__mspabi_slll_9>:
    a36e:	0c 5c       	rla	r12		;
    a370:	0d 6d       	rlc	r13		;

0000a372 <__mspabi_slll_8>:
    a372:	0c 5c       	rla	r12		;
    a374:	0d 6d       	rlc	r13		;

0000a376 <__mspabi_slll_7>:
    a376:	0c 5c       	rla	r12		;
    a378:	0d 6d       	rlc	r13		;

0000a37a <__mspabi_slll_6>:
    a37a:	0c 5c       	rla	r12		;
    a37c:	0d 6d       	rlc	r13		;

0000a37e <__mspabi_slll_5>:
    a37e:	0c 5c       	rla	r12		;
    a380:	0d 6d       	rlc	r13		;

0000a382 <__mspabi_slll_4>:
    a382:	0c 5c       	rla	r12		;
    a384:	0d 6d       	rlc	r13		;

0000a386 <__mspabi_slll_3>:
    a386:	0c 5c       	rla	r12		;
    a388:	0d 6d       	rlc	r13		;

0000a38a <__mspabi_slll_2>:
    a38a:	0c 5c       	rla	r12		;
    a38c:	0d 6d       	rlc	r13		;

0000a38e <__mspabi_slll_1>:
    a38e:	0c 5c       	rla	r12		;
    a390:	0d 6d       	rlc	r13		;
    a392:	30 41       	ret			

0000a394 <.L12>:
    a394:	3e 53       	add	#-1,	r14	;r3 As==11
    a396:	0c 5c       	rla	r12		;
    a398:	0d 6d       	rlc	r13		;

0000a39a <__mspabi_slll>:
    a39a:	0e 93       	cmp	#0,	r14	;r3 As==00
    a39c:	fb 23       	jnz	$-8      	;abs 0xa394
    a39e:	30 41       	ret			

0000a3a0 <__mspabi_srli_15>:
    a3a0:	12 c3       	clrc			
    a3a2:	0c 10       	rrc	r12		;

0000a3a4 <__mspabi_srli_14>:
    a3a4:	12 c3       	clrc			
    a3a6:	0c 10       	rrc	r12		;

0000a3a8 <__mspabi_srli_13>:
    a3a8:	12 c3       	clrc			
    a3aa:	0c 10       	rrc	r12		;

0000a3ac <__mspabi_srli_12>:
    a3ac:	12 c3       	clrc			
    a3ae:	0c 10       	rrc	r12		;

0000a3b0 <__mspabi_srli_11>:
    a3b0:	12 c3       	clrc			
    a3b2:	0c 10       	rrc	r12		;

0000a3b4 <__mspabi_srli_10>:
    a3b4:	12 c3       	clrc			
    a3b6:	0c 10       	rrc	r12		;

0000a3b8 <__mspabi_srli_9>:
    a3b8:	12 c3       	clrc			
    a3ba:	0c 10       	rrc	r12		;

0000a3bc <__mspabi_srli_8>:
    a3bc:	12 c3       	clrc			
    a3be:	0c 10       	rrc	r12		;

0000a3c0 <__mspabi_srli_7>:
    a3c0:	12 c3       	clrc			
    a3c2:	0c 10       	rrc	r12		;

0000a3c4 <__mspabi_srli_6>:
    a3c4:	12 c3       	clrc			
    a3c6:	0c 10       	rrc	r12		;

0000a3c8 <__mspabi_srli_5>:
    a3c8:	12 c3       	clrc			
    a3ca:	0c 10       	rrc	r12		;

0000a3cc <__mspabi_srli_4>:
    a3cc:	12 c3       	clrc			
    a3ce:	0c 10       	rrc	r12		;

0000a3d0 <__mspabi_srli_3>:
    a3d0:	12 c3       	clrc			
    a3d2:	0c 10       	rrc	r12		;

0000a3d4 <__mspabi_srli_2>:
    a3d4:	12 c3       	clrc			
    a3d6:	0c 10       	rrc	r12		;

0000a3d8 <__mspabi_srli_1>:
    a3d8:	12 c3       	clrc			
    a3da:	0c 10       	rrc	r12		;
    a3dc:	30 41       	ret			

0000a3de <.L11>:
    a3de:	3d 53       	add	#-1,	r13	;r3 As==11
    a3e0:	12 c3       	clrc			
    a3e2:	0c 10       	rrc	r12		;

0000a3e4 <__mspabi_srli>:
    a3e4:	0d 93       	cmp	#0,	r13	;r3 As==00
    a3e6:	fb 23       	jnz	$-8      	;abs 0xa3de
    a3e8:	30 41       	ret			

0000a3ea <__mspabi_srll_15>:
    a3ea:	12 c3       	clrc			
    a3ec:	0d 10       	rrc	r13		;
    a3ee:	0c 10       	rrc	r12		;

0000a3f0 <__mspabi_srll_14>:
    a3f0:	12 c3       	clrc			
    a3f2:	0d 10       	rrc	r13		;
    a3f4:	0c 10       	rrc	r12		;

0000a3f6 <__mspabi_srll_13>:
    a3f6:	12 c3       	clrc			
    a3f8:	0d 10       	rrc	r13		;
    a3fa:	0c 10       	rrc	r12		;

0000a3fc <__mspabi_srll_12>:
    a3fc:	12 c3       	clrc			
    a3fe:	0d 10       	rrc	r13		;
    a400:	0c 10       	rrc	r12		;

0000a402 <__mspabi_srll_11>:
    a402:	12 c3       	clrc			
    a404:	0d 10       	rrc	r13		;
    a406:	0c 10       	rrc	r12		;

0000a408 <__mspabi_srll_10>:
    a408:	12 c3       	clrc			
    a40a:	0d 10       	rrc	r13		;
    a40c:	0c 10       	rrc	r12		;

0000a40e <__mspabi_srll_9>:
    a40e:	12 c3       	clrc			
    a410:	0d 10       	rrc	r13		;
    a412:	0c 10       	rrc	r12		;

0000a414 <__mspabi_srll_8>:
    a414:	12 c3       	clrc			
    a416:	0d 10       	rrc	r13		;
    a418:	0c 10       	rrc	r12		;

0000a41a <__mspabi_srll_7>:
    a41a:	12 c3       	clrc			
    a41c:	0d 10       	rrc	r13		;
    a41e:	0c 10       	rrc	r12		;

0000a420 <__mspabi_srll_6>:
    a420:	12 c3       	clrc			
    a422:	0d 10       	rrc	r13		;
    a424:	0c 10       	rrc	r12		;

0000a426 <__mspabi_srll_5>:
    a426:	12 c3       	clrc			
    a428:	0d 10       	rrc	r13		;
    a42a:	0c 10       	rrc	r12		;

0000a42c <__mspabi_srll_4>:
    a42c:	12 c3       	clrc			
    a42e:	0d 10       	rrc	r13		;
    a430:	0c 10       	rrc	r12		;

0000a432 <__mspabi_srll_3>:
    a432:	12 c3       	clrc			
    a434:	0d 10       	rrc	r13		;
    a436:	0c 10       	rrc	r12		;

0000a438 <__mspabi_srll_2>:
    a438:	12 c3       	clrc			
    a43a:	0d 10       	rrc	r13		;
    a43c:	0c 10       	rrc	r12		;

0000a43e <__mspabi_srll_1>:
    a43e:	12 c3       	clrc			
    a440:	0d 10       	rrc	r13		;
    a442:	0c 10       	rrc	r12		;
    a444:	30 41       	ret			

0000a446 <.L12>:
    a446:	3e 53       	add	#-1,	r14	;r3 As==11
    a448:	12 c3       	clrc			
    a44a:	0d 10       	rrc	r13		;
    a44c:	0c 10       	rrc	r12		;

0000a44e <__mspabi_srll>:
    a44e:	0e 93       	cmp	#0,	r14	;r3 As==00
    a450:	fa 23       	jnz	$-10     	;abs 0xa446
    a452:	30 41       	ret			

0000a454 <__lshrdi3>:
    a454:	6a 15       	pushm	#7,	r10	;16-bit words

0000a456 <.LCFI0>:
    a456:	21 82       	sub	#4,	r1	;r2 As==10

0000a458 <.LCFI1>:
    a458:	09 4c       	mov	r12,	r9	;
    a45a:	0a 4d       	mov	r13,	r10	;
    a45c:	16 41 14 00 	mov	20(r1),	r6	;0x00014

0000a460 <.Loc.405.1>:
    a460:	06 93       	cmp	#0,	r6	;r3 As==00
    a462:	16 24       	jz	$+46     	;abs 0xa490

0000a464 <.Loc.409.1>:
    a464:	35 40 20 00 	mov	#32,	r5	;#0x0020
    a468:	05 86       	sub	r6,	r5	;

0000a46a <.LVL1>:
    a46a:	4c 43       	clr.b	r12		;

0000a46c <.LVL2>:
    a46c:	0c 95       	cmp	r5,	r12	;
    a46e:	15 38       	jl	$+44     	;abs 0xa49a

0000a470 <.Loc.414.1>:
    a470:	08 4c       	mov	r12,	r8	;
    a472:	81 4c 02 00 	mov	r12,	2(r1)	;

0000a476 <.Loc.415.1>:
    a476:	0a 43       	clr	r10		;
    a478:	0a 85       	sub	r5,	r10	;
    a47a:	0c 4e       	mov	r14,	r12	;
    a47c:	0d 4f       	mov	r15,	r13	;
    a47e:	0e 4a       	mov	r10,	r14	;
    a480:	0f 43       	clr	r15		;
    a482:	b0 12 4e a4 	call	#42062		;#0xa44e
    a486:	09 4c       	mov	r12,	r9	;

0000a488 <.L4>:
    a488:	0a 4d       	mov	r13,	r10	;
    a48a:	0e 48       	mov	r8,	r14	;
    a48c:	1f 41 02 00 	mov	2(r1),	r15	;

0000a490 <.L2>:
    a490:	0c 49       	mov	r9,	r12	;
    a492:	0d 4a       	mov	r10,	r13	;
    a494:	21 52       	add	#4,	r1	;r2 As==10
    a496:	64 17       	popm	#7,	r10	;16-bit words
    a498:	30 41       	ret			

0000a49a <.L3>:
    a49a:	0b 4e       	mov	r14,	r11	;
    a49c:	04 4f       	mov	r15,	r4	;

0000a49e <.Loc.421.1>:
    a49e:	07 43       	clr	r7		;

0000a4a0 <.LVL9>:
    a4a0:	0c 4e       	mov	r14,	r12	;
    a4a2:	0d 4f       	mov	r15,	r13	;
    a4a4:	0e 46       	mov	r6,	r14	;
    a4a6:	81 4b 00 00 	mov	r11,	0(r1)	;
    a4aa:	b0 12 4e a4 	call	#42062		;#0xa44e
    a4ae:	08 4c       	mov	r12,	r8	;
    a4b0:	81 4d 02 00 	mov	r13,	2(r1)	;

0000a4b4 <.Loc.422.1>:
    a4b4:	0c 49       	mov	r9,	r12	;
    a4b6:	0d 4a       	mov	r10,	r13	;
    a4b8:	0e 46       	mov	r6,	r14	;
    a4ba:	b0 12 4e a4 	call	#42062		;#0xa44e
    a4be:	07 4c       	mov	r12,	r7	;
    a4c0:	0a 4d       	mov	r13,	r10	;

0000a4c2 <.Loc.419.1>:
    a4c2:	2b 41       	mov	@r1,	r11	;
    a4c4:	0c 4b       	mov	r11,	r12	;
    a4c6:	0d 44       	mov	r4,	r13	;
    a4c8:	0e 45       	mov	r5,	r14	;
    a4ca:	0f 43       	clr	r15		;
    a4cc:	b0 12 9a a3 	call	#41882		;#0xa39a

0000a4d0 <.Loc.422.1>:
    a4d0:	0d da       	bis	r10,	r13	;
    a4d2:	09 47       	mov	r7,	r9	;
    a4d4:	09 dc       	bis	r12,	r9	;
    a4d6:	d8 3f       	jmp	$-78     	;abs 0xa488

0000a4d8 <__ashldi3>:
    a4d8:	6a 15       	pushm	#7,	r10	;16-bit words

0000a4da <L0>:
    a4da:	21 82       	sub	#4,	r1	;r2 As==10

0000a4dc <.LCFI1>:
    a4dc:	06 4c       	mov	r12,	r6	;
    a4de:	07 4d       	mov	r13,	r7	;
    a4e0:	09 4e       	mov	r14,	r9	;
    a4e2:	0a 4f       	mov	r15,	r10	;
    a4e4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014

0000a4e8 <.LVL1>:
    a4e8:	0c 93       	cmp	#0,	r12	;r3 As==00
    a4ea:	15 24       	jz	$+44     	;abs 0xa516

0000a4ec <.Loc.437.1>:
    a4ec:	35 40 20 00 	mov	#32,	r5	;#0x0020
    a4f0:	05 8c       	sub	r12,	r5	;

0000a4f2 <.LVL2>:
    a4f2:	4d 43       	clr.b	r13		;
    a4f4:	0d 95       	cmp	r5,	r13	;
    a4f6:	16 38       	jl	$+46     	;abs 0xa524

0000a4f8 <.Loc.442.1>:
    a4f8:	08 4d       	mov	r13,	r8	;
    a4fa:	81 4d 02 00 	mov	r13,	2(r1)	;

0000a4fe <.Loc.443.1>:
    a4fe:	0e 43       	clr	r14		;
    a500:	0e 85       	sub	r5,	r14	;
    a502:	0c 46       	mov	r6,	r12	;
    a504:	0d 47       	mov	r7,	r13	;
    a506:	0f 43       	clr	r15		;
    a508:	b0 12 9a a3 	call	#41882		;#0xa39a
    a50c:	09 4c       	mov	r12,	r9	;

0000a50e <.L4>:
    a50e:	06 48       	mov	r8,	r6	;
    a510:	17 41 02 00 	mov	2(r1),	r7	;
    a514:	0a 4d       	mov	r13,	r10	;

0000a516 <.L2>:
    a516:	0c 46       	mov	r6,	r12	;
    a518:	0d 47       	mov	r7,	r13	;
    a51a:	0e 49       	mov	r9,	r14	;
    a51c:	0f 4a       	mov	r10,	r15	;
    a51e:	21 52       	add	#4,	r1	;r2 As==10
    a520:	64 17       	popm	#7,	r10	;16-bit words
    a522:	30 41       	ret			

0000a524 <.L3>:
    a524:	0b 46       	mov	r6,	r11	;
    a526:	04 47       	mov	r7,	r4	;

0000a528 <.Loc.449.1>:
    a528:	06 4c       	mov	r12,	r6	;
    a52a:	07 43       	clr	r7		;
    a52c:	0c 4b       	mov	r11,	r12	;

0000a52e <.LVL9>:
    a52e:	0d 44       	mov	r4,	r13	;
    a530:	0e 46       	mov	r6,	r14	;
    a532:	81 4b 00 00 	mov	r11,	0(r1)	;
    a536:	b0 12 9a a3 	call	#41882		;#0xa39a
    a53a:	08 4c       	mov	r12,	r8	;
    a53c:	81 4d 02 00 	mov	r13,	2(r1)	;

0000a540 <.Loc.450.1>:
    a540:	0c 49       	mov	r9,	r12	;
    a542:	0d 4a       	mov	r10,	r13	;
    a544:	0e 46       	mov	r6,	r14	;
    a546:	b0 12 9a a3 	call	#41882		;#0xa39a
    a54a:	07 4c       	mov	r12,	r7	;
    a54c:	0a 4d       	mov	r13,	r10	;

0000a54e <.Loc.447.1>:
    a54e:	2b 41       	mov	@r1,	r11	;
    a550:	0c 4b       	mov	r11,	r12	;
    a552:	0d 44       	mov	r4,	r13	;
    a554:	0e 45       	mov	r5,	r14	;
    a556:	0f 43       	clr	r15		;
    a558:	b0 12 4e a4 	call	#42062		;#0xa44e

0000a55c <.Loc.450.1>:
    a55c:	0d da       	bis	r10,	r13	;
    a55e:	09 47       	mov	r7,	r9	;
    a560:	09 dc       	bis	r12,	r9	;
    a562:	d5 3f       	jmp	$-84     	;abs 0xa50e

0000a564 <__pack_f>:
    a564:	6a 15       	pushm	#7,	r10	;16-bit words

0000a566 <L0>:
    a566:	18 4c 06 00 	mov	6(r12),	r8	;
    a56a:	19 4c 08 00 	mov	8(r12),	r9	;

0000a56e <.LVL1>:
    a56e:	17 4c 02 00 	mov	2(r12),	r7	;

0000a572 <.LVL2>:
    a572:	2d 4c       	mov	@r12,	r13	;

0000a574 <.Loc.205.1>:
    a574:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a576:	0e 9d       	cmp	r13,	r14	;
    a578:	1a 28       	jnc	$+54     	;abs 0xa5ae

0000a57a <.LVL4>:
    a57a:	0c 48       	mov	r8,	r12	;

0000a57c <.LVL5>:
    a57c:	0d 49       	mov	r9,	r13	;
    a57e:	b0 12 1a a4 	call	#42010		;#0xa41a

0000a582 <.LVL6>:
    a582:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

0000a586 <.Loc.220.1>:
    a586:	08 4c       	mov	r12,	r8	;
    a588:	09 4d       	mov	r13,	r9	;
    a58a:	39 d0 40 00 	bis	#64,	r9	;#0x0040

0000a58e <.LVL8>:
    a58e:	7a 40 ff 00 	mov.b	#255,	r10	;#0x00ff

0000a592 <.L3>:
    a592:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

0000a596 <.LVL10>:
    a596:	46 18 0a 5a 	rpt #7 { rlax.w	r10		;
    a59a:	0d 49       	mov	r9,	r13	;
    a59c:	7d f0 7f 00 	and.b	#127,	r13	;#0x007f

0000a5a0 <.Loc.322.1>:
    a5a0:	4e 18 07 57 	rpt #15 { rlax.w	r7		;

0000a5a4 <.LVL11>:
    a5a4:	0d da       	bis	r10,	r13	;

0000a5a6 <.Loc.424.1>:
    a5a6:	0c 48       	mov	r8,	r12	;
    a5a8:	0d d7       	bis	r7,	r13	;
    a5aa:	64 17       	popm	#7,	r10	;16-bit words
    a5ac:	30 41       	ret			

0000a5ae <.L2>:
    a5ae:	2d 92       	cmp	#4,	r13	;r2 As==10
    a5b0:	74 24       	jz	$+234    	;abs 0xa69a

0000a5b2 <.Loc.229.1>:
    a5b2:	2d 93       	cmp	#2,	r13	;r3 As==10
    a5b4:	6e 24       	jz	$+222    	;abs 0xa692

0000a5b6 <.Loc.234.1>:
    a5b6:	0a 48       	mov	r8,	r10	;
    a5b8:	0a d9       	bis	r9,	r10	;
    a5ba:	0a 93       	cmp	#0,	r10	;r3 As==00
    a5bc:	ea 27       	jz	$-42     	;abs 0xa592

0000a5be <.Loc.240.1>:
    a5be:	1a 4c 04 00 	mov	4(r12),	r10	;
    a5c2:	3a 90 82 ff 	cmp	#65410,	r10	;#0xff82
    a5c6:	41 34       	jge	$+132    	;abs 0xa64a

0000a5c8 <.LBB10>:
    a5c8:	34 40 82 ff 	mov	#65410,	r4	;#0xff82
    a5cc:	04 8a       	sub	r10,	r4	;

0000a5ce <.LVL14>:
    a5ce:	7c 40 19 00 	mov.b	#25,	r12	;#0x0019

0000a5d2 <.LVL15>:
    a5d2:	0c 94       	cmp	r4,	r12	;
    a5d4:	35 38       	jl	$+108    	;abs 0xa640

0000a5d6 <.LBB11>:
    a5d6:	05 43       	clr	r5		;
    a5d8:	0c 48       	mov	r8,	r12	;
    a5da:	0d 49       	mov	r9,	r13	;
    a5dc:	0e 44       	mov	r4,	r14	;
    a5de:	b0 12 4e a4 	call	#42062		;#0xa44e
    a5e2:	06 4c       	mov	r12,	r6	;
    a5e4:	0a 4d       	mov	r13,	r10	;

0000a5e6 <.Loc.264.1>:
    a5e6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a5e8:	4d 43       	clr.b	r13		;
    a5ea:	0e 44       	mov	r4,	r14	;
    a5ec:	b0 12 9a a3 	call	#41882		;#0xa39a
    a5f0:	3c 53       	add	#-1,	r12	;r3 As==11
    a5f2:	3d 63       	addc	#-1,	r13	;r3 As==11
    a5f4:	0c f8       	and	r8,	r12	;
    a5f6:	0d f9       	and	r9,	r13	;
    a5f8:	0c dd       	bis	r13,	r12	;
    a5fa:	0e 43       	clr	r14		;
    a5fc:	0e 8c       	sub	r12,	r14	;
    a5fe:	0c de       	bis	r14,	r12	;
    a600:	0e 4c       	mov	r12,	r14	;
    a602:	5e 03       	rrum	#1,	r14	;
    a604:	4d 18 0e 11 	rpt #14 { rrax.w	r14		;

0000a608 <.Loc.265.1>:
    a608:	0c 46       	mov	r6,	r12	;
    a60a:	0c de       	bis	r14,	r12	;
    a60c:	0d 4a       	mov	r10,	r13	;

0000a60e <.LBE11>:
    a60e:	0e 4c       	mov	r12,	r14	;
    a610:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    a614:	3e 90 40 00 	cmp	#64,	r14	;#0x0040
    a618:	15 20       	jnz	$+44     	;abs 0xa644

0000a61a <.Loc.269.1>:
    a61a:	0e 4c       	mov	r12,	r14	;
    a61c:	7e f0 80 00 	and.b	#128,	r14	;#0x0080
    a620:	0e 93       	cmp	#0,	r14	;r3 As==00
    a622:	03 24       	jz	$+8      	;abs 0xa62a

0000a624 <.Loc.270.1>:
    a624:	3c 50 40 00 	add	#64,	r12	;#0x0040

0000a628 <.L30>:
    a628:	0d 63       	adc	r13		;

0000a62a <.L8>:
    a62a:	5a 43       	mov.b	#1,	r10	;r3 As==01
    a62c:	3e 40 ff 3f 	mov	#16383,	r14	;#0x3fff
    a630:	0e 9d       	cmp	r13,	r14	;
    a632:	01 28       	jnc	$+4      	;abs 0xa636
    a634:	4a 43       	clr.b	r10		;

0000a636 <.L10>:
    a636:	b0 12 1a a4 	call	#42010		;#0xa41a

0000a63a <.L33>:
    a63a:	08 4c       	mov	r12,	r8	;
    a63c:	09 4d       	mov	r13,	r9	;

0000a63e <.LVL24>:
    a63e:	a9 3f       	jmp	$-172    	;abs 0xa592

0000a640 <.L21>:
    a640:	4c 43       	clr.b	r12		;
    a642:	4d 43       	clr.b	r13		;

0000a644 <.L7>:
    a644:	3c 50 3f 00 	add	#63,	r12	;#0x003f

0000a648 <.LVL27>:
    a648:	ef 3f       	jmp	$-32     	;abs 0xa628

0000a64a <.L5>:
    a64a:	7c 40 7f 00 	mov.b	#127,	r12	;#0x007f

0000a64e <.LVL29>:
    a64e:	0c 9a       	cmp	r10,	r12	;
    a650:	24 38       	jl	$+74     	;abs 0xa69a

0000a652 <.LVL30>:
    a652:	0c 48       	mov	r8,	r12	;
    a654:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    a658:	3c 90 40 00 	cmp	#64,	r12	;#0x0040
    a65c:	11 20       	jnz	$+36     	;abs 0xa680

0000a65e <.Loc.299.1>:
    a65e:	0c 48       	mov	r8,	r12	;
    a660:	7c f0 80 00 	and.b	#128,	r12	;#0x0080
    a664:	0c 93       	cmp	#0,	r12	;r3 As==00
    a666:	03 24       	jz	$+8      	;abs 0xa66e

0000a668 <.Loc.300.1>:
    a668:	38 50 40 00 	add	#64,	r8	;#0x0040

0000a66c <.L31>:
    a66c:	09 63       	adc	r9		;

0000a66e <.L13>:
    a66e:	09 93       	cmp	#0,	r9	;r3 As==00
    a670:	0a 38       	jl	$+22     	;abs 0xa686

0000a672 <.Loc.293.1>:
    a672:	3a 50 7f 00 	add	#127,	r10	;#0x007f

0000a676 <.L17>:
    a676:	0c 48       	mov	r8,	r12	;
    a678:	0d 49       	mov	r9,	r13	;
    a67a:	b0 12 1a a4 	call	#42010		;#0xa41a
    a67e:	dd 3f       	jmp	$-68     	;abs 0xa63a

0000a680 <.L12>:
    a680:	38 50 3f 00 	add	#63,	r8	;#0x003f

0000a684 <.LVL36>:
    a684:	f3 3f       	jmp	$-24     	;abs 0xa66c

0000a686 <.L15>:
    a686:	12 c3       	clrc			
    a688:	09 10       	rrc	r9		;
    a68a:	08 10       	rrc	r8		;

0000a68c <.Loc.310.1>:
    a68c:	3a 50 80 00 	add	#128,	r10	;#0x0080

0000a690 <.LVL39>:
    a690:	f2 3f       	jmp	$-26     	;abs 0xa676

0000a692 <.L19>:
    a692:	4a 43       	clr.b	r10		;

0000a694 <.L32>:
    a694:	48 43       	clr.b	r8		;

0000a696 <.LVL42>:
    a696:	49 43       	clr.b	r9		;
    a698:	7c 3f       	jmp	$-262    	;abs 0xa592

0000a69a <.L22>:
    a69a:	7a 40 ff 00 	mov.b	#255,	r10	;#0x00ff
    a69e:	fa 3f       	jmp	$-10     	;abs 0xa694

0000a6a0 <__unpack_f>:
    a6a0:	3a 15       	pushm	#4,	r10	;16-bit words

0000a6a2 <.LCFI0>:
    a6a2:	21 83       	decd	r1		;

0000a6a4 <.LCFI1>:
    a6a4:	07 4c       	mov	r12,	r7	;
    a6a6:	0a 4d       	mov	r13,	r10	;

0000a6a8 <.Loc.454.1>:
    a6a8:	29 4c       	mov	@r12,	r9	;
    a6aa:	58 4c 02 00 	mov.b	2(r12),	r8	;

0000a6ae <L0>:
    a6ae:	0d 48       	mov	r8,	r13	;

0000a6b0 <.LVL1>:
    a6b0:	7d f0 7f 00 	and.b	#127,	r13	;#0x007f

0000a6b4 <.LVL2>:
    a6b4:	1c 4c 02 00 	mov	2(r12),	r12	;

0000a6b8 <.LVL3>:
    a6b8:	81 4d 00 00 	mov	r13,	0(r1)	;
    a6bc:	b0 12 c0 a3 	call	#41920		;#0xa3c0

0000a6c0 <.LVL4>:
    a6c0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a6c4 <.LVL5>:
    a6c4:	5e 47 03 00 	mov.b	3(r7),	r14	;
    a6c8:	5e 0f       	rrum	#4,	r14	;
    a6ca:	5e 0b       	rrum	#3,	r14	;

0000a6cc <.Loc.508.1>:
    a6cc:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    a6d0:	8a 4e 02 00 	mov	r14,	2(r10)	;

0000a6d4 <.LVL6>:
    a6d4:	2d 41       	mov	@r1,	r13	;

0000a6d6 <.LVL7>:
    a6d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    a6d8:	24 20       	jnz	$+74     	;abs 0xa722

0000a6da <.Loc.512.1>:
    a6da:	0c 49       	mov	r9,	r12	;

0000a6dc <.LVL8>:
    a6dc:	0c dd       	bis	r13,	r12	;
    a6de:	0c 93       	cmp	#0,	r12	;r3 As==00
    a6e0:	05 20       	jnz	$+12     	;abs 0xa6ec

0000a6e2 <.Loc.519.1>:
    a6e2:	aa 43 00 00 	mov	#2,	0(r10)	;r3 As==10

0000a6e6 <.L1>:
    a6e6:	21 53       	incd	r1		;
    a6e8:	37 17       	popm	#4,	r10	;16-bit words
    a6ea:	30 41       	ret			

0000a6ec <.L3>:
    a6ec:	0c 49       	mov	r9,	r12	;
    a6ee:	b0 12 76 a3 	call	#41846		;#0xa376

0000a6f2 <.LVL11>:
    a6f2:	ba 40 03 00 	mov	#3,	0(r10)	;
    a6f6:	00 00 
    a6f8:	3e 40 81 ff 	mov	#65409,	r14	;#0xff81

0000a6fc <.L13>:
    a6fc:	08 4c       	mov	r12,	r8	;
    a6fe:	09 4d       	mov	r13,	r9	;
    a700:	08 5c       	add	r12,	r8	;
    a702:	09 6d       	addc	r13,	r9	;
    a704:	0c 48       	mov	r8,	r12	;

0000a706 <.LVL12>:
    a706:	0d 49       	mov	r9,	r13	;

0000a708 <.LVL13>:
    a708:	0f 4e       	mov	r14,	r15	;
    a70a:	3e 53       	add	#-1,	r14	;r3 As==11

0000a70c <.Loc.531.1>:
    a70c:	39 40 ff 3f 	mov	#16383,	r9	;#0x3fff
    a710:	09 9d       	cmp	r13,	r9	;
    a712:	f4 2f       	jc	$-22     	;abs 0xa6fc
    a714:	8a 4f 04 00 	mov	r15,	4(r10)	;

0000a718 <.Loc.537.1>:
    a718:	8a 48 06 00 	mov	r8,	6(r10)	;

0000a71c <.L14>:
    a71c:	8a 4d 08 00 	mov	r13,	8(r10)	;

0000a720 <.Loc.576.1>:
    a720:	e2 3f       	jmp	$-58     	;abs 0xa6e6

0000a722 <.L2>:
    a722:	3c 90 ff 00 	cmp	#255,	r12	;#0x00ff
    a726:	1a 20       	jnz	$+54     	;abs 0xa75c

0000a728 <.Loc.543.1>:
    a728:	0c 49       	mov	r9,	r12	;

0000a72a <.LVL16>:
    a72a:	0c dd       	bis	r13,	r12	;
    a72c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a72e:	03 20       	jnz	$+8      	;abs 0xa736

0000a730 <.Loc.546.1>:
    a730:	aa 42 00 00 	mov	#4,	0(r10)	;r2 As==10
    a734:	d8 3f       	jmp	$-78     	;abs 0xa6e6

0000a736 <.L8>:
    a736:	78 f0 40 00 	and.b	#64,	r8	;#0x0040
    a73a:	08 93       	cmp	#0,	r8	;r3 As==00
    a73c:	0c 24       	jz	$+26     	;abs 0xa756

0000a73e <.Loc.557.1>:
    a73e:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01

0000a742 <.L11>:
    a742:	0c 49       	mov	r9,	r12	;
    a744:	b0 12 76 a3 	call	#41846		;#0xa376
    a748:	3c f0 80 ff 	and	#65408,	r12	;#0xff80
    a74c:	8a 4c 06 00 	mov	r12,	6(r10)	;
    a750:	3d f0 ff df 	and	#57343,	r13	;#0xdfff
    a754:	e3 3f       	jmp	$-56     	;abs 0xa71c

0000a756 <.L9>:
    a756:	8a 48 00 00 	mov	r8,	0(r10)	;
    a75a:	f3 3f       	jmp	$-24     	;abs 0xa742

0000a75c <.L7>:
    a75c:	3c 50 81 ff 	add	#65409,	r12	;#0xff81

0000a760 <.LVL21>:
    a760:	8a 4c 04 00 	mov	r12,	4(r10)	;

0000a764 <.Loc.573.1>:
    a764:	ba 40 03 00 	mov	#3,	0(r10)	;
    a768:	00 00 

0000a76a <.Loc.574.1>:
    a76a:	0c 49       	mov	r9,	r12	;

0000a76c <.LVL22>:
    a76c:	b0 12 76 a3 	call	#41846		;#0xa376

0000a770 <.LVL23>:
    a770:	8a 4c 06 00 	mov	r12,	6(r10)	;
    a774:	3d d0 00 40 	bis	#16384,	r13	;#0x4000
    a778:	d1 3f       	jmp	$-92     	;abs 0xa71c

0000a77a <__fpcmp_parts_f>:
    a77a:	0a 15       	pushm	#1,	r10	;16-bit words

0000a77c <.LCFI0>:
    a77c:	2f 4c       	mov	@r12,	r15	;

0000a77e <.Loc.1084.1>:
    a77e:	5a 43       	mov.b	#1,	r10	;r3 As==01
    a780:	0a 9f       	cmp	r15,	r10	;
    a782:	1a 2c       	jc	$+54     	;abs 0xa7b8

0000a784 <L0>:
    a784:	2e 4d       	mov	@r13,	r14	;

0000a786 <.Loc.1084.1>:
    a786:	0a 9e       	cmp	r14,	r10	;
    a788:	17 2c       	jc	$+48     	;abs 0xa7b8

0000a78a <.Loc.1088.1>:
    a78a:	2f 92       	cmp	#4,	r15	;r2 As==10
    a78c:	0f 20       	jnz	$+32     	;abs 0xa7ac

0000a78e <.Loc.1088.1>:
    a78e:	2e 92       	cmp	#4,	r14	;r2 As==10
    a790:	07 20       	jnz	$+16     	;abs 0xa7a0

0000a792 <.Loc.1099.1>:
    a792:	1e 4d 02 00 	mov	2(r13),	r14	;
    a796:	1e 8c 02 00 	sub	2(r12),	r14	;

0000a79a <.L1>:
    a79a:	0c 4e       	mov	r14,	r12	;
    a79c:	0a 17       	popm	#1,	r10	;16-bit words
    a79e:	30 41       	ret			

0000a7a0 <.L4>:
    a7a0:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a7a2:	8c 93 02 00 	cmp	#0,	2(r12)	;r3 As==00
    a7a6:	f9 27       	jz	$-12     	;abs 0xa79a

0000a7a8 <.L24>:
    a7a8:	3e 43       	mov	#-1,	r14	;r3 As==11
    a7aa:	f7 3f       	jmp	$-16     	;abs 0xa79a

0000a7ac <.L3>:
    a7ac:	2e 92       	cmp	#4,	r14	;r2 As==10
    a7ae:	06 20       	jnz	$+14     	;abs 0xa7bc

0000a7b0 <.L7>:
    a7b0:	3e 43       	mov	#-1,	r14	;r3 As==11
    a7b2:	8d 93 02 00 	cmp	#0,	2(r13)	;r3 As==00
    a7b6:	f1 27       	jz	$-28     	;abs 0xa79a

0000a7b8 <.L15>:
    a7b8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a7ba:	ef 3f       	jmp	$-32     	;abs 0xa79a

0000a7bc <.L5>:
    a7bc:	2f 93       	cmp	#2,	r15	;r3 As==10
    a7be:	04 20       	jnz	$+10     	;abs 0xa7c8

0000a7c0 <.Loc.1110.1>:
    a7c0:	2e 93       	cmp	#2,	r14	;r3 As==10
    a7c2:	f6 23       	jnz	$-18     	;abs 0xa7b0

0000a7c4 <.L23>:
    a7c4:	4e 43       	clr.b	r14		;
    a7c6:	e9 3f       	jmp	$-44     	;abs 0xa79a

0000a7c8 <.L6>:
    a7c8:	2e 93       	cmp	#2,	r14	;r3 As==10
    a7ca:	ea 27       	jz	$-42     	;abs 0xa7a0

0000a7cc <.Loc.1123.1>:
    a7cc:	1f 4c 02 00 	mov	2(r12),	r15	;
    a7d0:	1f 9d 02 00 	cmp	2(r13),	r15	;
    a7d4:	04 24       	jz	$+10     	;abs 0xa7de

0000a7d6 <.L25>:
    a7d6:	5e 43       	mov.b	#1,	r14	;r3 As==01

0000a7d8 <.Loc.1140.1>:
    a7d8:	0f 93       	cmp	#0,	r15	;r3 As==00
    a7da:	df 27       	jz	$-64     	;abs 0xa79a
    a7dc:	e5 3f       	jmp	$-52     	;abs 0xa7a8

0000a7de <.L8>:
    a7de:	1b 4c 04 00 	mov	4(r12),	r11	;
    a7e2:	1e 4d 04 00 	mov	4(r13),	r14	;
    a7e6:	0e 9b       	cmp	r11,	r14	;
    a7e8:	f6 3b       	jl	$-18     	;abs 0xa7d6

0000a7ea <.Loc.1133.1>:
    a7ea:	0b 9e       	cmp	r14,	r11	;
    a7ec:	03 34       	jge	$+8      	;abs 0xa7f4

0000a7ee <.L26>:
    a7ee:	0f 93       	cmp	#0,	r15	;r3 As==00
    a7f0:	e3 23       	jnz	$-56     	;abs 0xa7b8
    a7f2:	da 3f       	jmp	$-74     	;abs 0xa7a8

0000a7f4 <.L10>:
    a7f4:	1e 4c 06 00 	mov	6(r12),	r14	;
    a7f8:	1c 4c 08 00 	mov	8(r12),	r12	;

0000a7fc <.LVL18>:
    a7fc:	1b 4d 06 00 	mov	6(r13),	r11	;
    a800:	1d 4d 08 00 	mov	8(r13),	r13	;

0000a804 <.LVL19>:
    a804:	0d 9c       	cmp	r12,	r13	;
    a806:	e7 2b       	jnc	$-48     	;abs 0xa7d6
    a808:	0c 9d       	cmp	r13,	r12	;
    a80a:	02 20       	jnz	$+6      	;abs 0xa810
    a80c:	0b 9e       	cmp	r14,	r11	;
    a80e:	e3 2b       	jnc	$-56     	;abs 0xa7d6

0000a810 <.L11>:
    a810:	0c 9d       	cmp	r13,	r12	;
    a812:	ed 2b       	jnc	$-36     	;abs 0xa7ee
    a814:	0d 9c       	cmp	r12,	r13	;
    a816:	d6 23       	jnz	$-82     	;abs 0xa7c4
    a818:	0e 9b       	cmp	r11,	r14	;
    a81a:	e9 2b       	jnc	$-44     	;abs 0xa7ee
    a81c:	d3 3f       	jmp	$-88     	;abs 0xa7c4

0000a81e <__pack_d>:
    a81e:	6a 15       	pushm	#7,	r10	;16-bit words

0000a820 <.LCFI0>:
    a820:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000a824 <.LCFI1>:
    a824:	1a 4c 06 00 	mov	6(r12),	r10	;
    a828:	16 4c 08 00 	Address 0x000000000000a82a is out of bounds.
mov	-1(r12),r6	;

0000a82a <L0>:
    a82a:	08 00       	mova	@r0,	r8	;
    a82c:	17 4c 0a 00 	mov	10(r12),r7	;0x0000a
    a830:	18 4c 0c 00 	mov	12(r12),r8	;0x0000c

0000a834 <.LVL1>:
    a834:	91 4c 02 00 	mov	2(r12),	2(r1)	;
    a838:	02 00 

0000a83a <.LVL2>:
    a83a:	2d 4c       	mov	@r12,	r13	;

0000a83c <.Loc.205.1>:
    a83c:	59 43       	mov.b	#1,	r9	;r3 As==01
    a83e:	09 9d       	cmp	r13,	r9	;
    a840:	24 28       	jnc	$+74     	;abs 0xa88a

0000a842 <.LVL4>:
    a842:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11

0000a846 <.LVL5>:
    a846:	0c 4a       	mov	r10,	r12	;

0000a848 <.LVL6>:
    a848:	0d 46       	mov	r6,	r13	;
    a84a:	0e 47       	mov	r7,	r14	;
    a84c:	0f 48       	mov	r8,	r15	;
    a84e:	b0 12 54 a4 	call	#42068		;#0xa454

0000a852 <.LVL7>:
    a852:	7f f0 07 00 	and.b	#7,	r15	;

0000a856 <.Loc.220.1>:
    a856:	0a 4c       	mov	r12,	r10	;
    a858:	06 4d       	mov	r13,	r6	;
    a85a:	07 4e       	mov	r14,	r7	;
    a85c:	08 4f       	mov	r15,	r8	;
    a85e:	38 d2       	bis	#8,	r8	;r2 As==11

0000a860 <.LVL9>:
    a860:	39 40 ff 07 	mov	#2047,	r9	;#0x07ff

0000a864 <.L3>:
    a864:	39 f0 ff 07 	and	#2047,	r9	;#0x07ff

0000a868 <.LVL11>:
    a868:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    a86c:	78 f0 0f 00 	and.b	#15,	r8	;#0x000f

0000a870 <.LVL12>:
    a870:	1f 41 02 00 	mov	2(r1),	r15	;
    a874:	4e 18 0f 5f 	rpt #15 { rlax.w	r15		;
    a878:	08 d9       	bis	r9,	r8	;

0000a87a <.Loc.424.1>:
    a87a:	0c 4a       	mov	r10,	r12	;
    a87c:	0d 46       	mov	r6,	r13	;
    a87e:	0e 47       	mov	r7,	r14	;
    a880:	0f d8       	bis	r8,	r15	;
    a882:	31 50 0c 00 	add	#12,	r1	;#0x000c
    a886:	64 17       	popm	#7,	r10	;16-bit words
    a888:	30 41       	ret			

0000a88a <.L2>:
    a88a:	2d 92       	cmp	#4,	r13	;r2 As==10
    a88c:	35 25       	jz	$+620    	;abs 0xaaf8

0000a88e <.Loc.229.1>:
    a88e:	2d 93       	cmp	#2,	r13	;r3 As==10
    a890:	2b 25       	jz	$+600    	;abs 0xaae8

0000a892 <.Loc.234.1>:
    a892:	0f 4a       	mov	r10,	r15	;
    a894:	0f d6       	bis	r6,	r15	;
    a896:	0f d7       	bis	r7,	r15	;
    a898:	0f d8       	bis	r8,	r15	;
    a89a:	0f 93       	cmp	#0,	r15	;r3 As==00
    a89c:	2b 25       	jz	$+600    	;abs 0xaaf4

0000a89e <.Loc.240.1>:
    a89e:	14 4c 04 00 	mov	4(r12),	r4	;
    a8a2:	34 90 02 fc 	cmp	#64514,	r4	;#0xfc02
    a8a6:	c4 34       	jge	$+394    	;abs 0xaa30

0000a8a8 <.LBB10>:
    a8a8:	35 40 02 fc 	mov	#64514,	r5	;#0xfc02
    a8ac:	05 84       	sub	r4,	r5	;

0000a8ae <.LVL15>:
    a8ae:	7c 40 38 00 	mov.b	#56,	r12	;#0x0038

0000a8b2 <.LVL16>:
    a8b2:	0c 95       	cmp	r5,	r12	;
    a8b4:	9e 38       	jl	$+318    	;abs 0xa9f2

0000a8b6 <.LBB11>:
    a8b6:	81 45 00 00 	mov	r5,	0(r1)	;
    a8ba:	0c 4a       	mov	r10,	r12	;
    a8bc:	0d 46       	mov	r6,	r13	;
    a8be:	0e 47       	mov	r7,	r14	;
    a8c0:	0f 48       	mov	r8,	r15	;
    a8c2:	b0 12 54 a4 	call	#42068		;#0xa454
    a8c6:	81 4c 04 00 	mov	r12,	4(r1)	;
    a8ca:	81 4d 06 00 	mov	r13,	6(r1)	;
    a8ce:	81 4e 08 00 	mov	r14,	8(r1)	;
    a8d2:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a

0000a8d6 <.Loc.264.1>:
    a8d6:	0c 49       	mov	r9,	r12	;
    a8d8:	4d 43       	clr.b	r13		;
    a8da:	0e 4d       	mov	r13,	r14	;
    a8dc:	0f 4d       	mov	r13,	r15	;
    a8de:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    a8e2:	34 43       	mov	#-1,	r4	;r3 As==11
    a8e4:	05 4c       	mov	r12,	r5	;
    a8e6:	05 89       	sub	r9,	r5	;

0000a8e8 <.LVL20>:
    a8e8:	05 9c       	cmp	r12,	r5	;
    a8ea:	01 28       	jnc	$+4      	;abs 0xa8ee
    a8ec:	49 43       	clr.b	r9		;

0000a8ee <.L7>:
    a8ee:	0c 4d       	mov	r13,	r12	;
    a8f0:	0c 54       	add	r4,	r12	;
    a8f2:	5b 43       	mov.b	#1,	r11	;r3 As==01
    a8f4:	0c 9d       	cmp	r13,	r12	;
    a8f6:	01 28       	jnc	$+4      	;abs 0xa8fa
    a8f8:	4b 43       	clr.b	r11		;

0000a8fa <.L8>:
    a8fa:	09 5c       	add	r12,	r9	;
    a8fc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a8fe:	09 9c       	cmp	r12,	r9	;
    a900:	01 28       	jnc	$+4      	;abs 0xa904
    a902:	4d 43       	clr.b	r13		;

0000a904 <.L9>:
    a904:	0b dd       	bis	r13,	r11	;
    a906:	0d 4e       	mov	r14,	r13	;
    a908:	0d 54       	add	r4,	r13	;
    a90a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a90c:	0d 9e       	cmp	r14,	r13	;
    a90e:	01 28       	jnc	$+4      	;abs 0xa912
    a910:	4c 43       	clr.b	r12		;

0000a912 <.L10>:
    a912:	0b 5d       	add	r13,	r11	;
    a914:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a916:	0b 9d       	cmp	r13,	r11	;
    a918:	01 28       	jnc	$+4      	;abs 0xa91c
    a91a:	4e 43       	clr.b	r14		;

0000a91c <.L11>:
    a91c:	0c de       	bis	r14,	r12	;
    a91e:	0f 54       	add	r4,	r15	;
    a920:	0f 5c       	add	r12,	r15	;
    a922:	0a f5       	and	r5,	r10	;

0000a924 <.LVL21>:
    a924:	09 f6       	and	r6,	r9	;
    a926:	0b f7       	and	r7,	r11	;
    a928:	08 ff       	and	r15,	r8	;
    a92a:	4f 43       	clr.b	r15		;
    a92c:	0c 4f       	mov	r15,	r12	;
    a92e:	0c 8a       	sub	r10,	r12	;
    a930:	57 43       	mov.b	#1,	r7	;r3 As==01
    a932:	0c 9f       	cmp	r15,	r12	;
    a934:	01 20       	jnz	$+4      	;abs 0xa938
    a936:	07 4c       	mov	r12,	r7	;

0000a938 <.L12>:
    a938:	0e 4f       	mov	r15,	r14	;
    a93a:	0e 89       	sub	r9,	r14	;
    a93c:	56 43       	mov.b	#1,	r6	;r3 As==01
    a93e:	0e 93       	cmp	#0,	r14	;r3 As==00
    a940:	01 20       	jnz	$+4      	;abs 0xa944
    a942:	06 4e       	mov	r14,	r6	;

0000a944 <.L13>:
    a944:	0d 4e       	mov	r14,	r13	;
    a946:	0d 87       	sub	r7,	r13	;
    a948:	57 43       	mov.b	#1,	r7	;r3 As==01
    a94a:	0e 9d       	cmp	r13,	r14	;
    a94c:	01 28       	jnc	$+4      	;abs 0xa950
    a94e:	47 43       	clr.b	r7		;

0000a950 <.L14>:
    a950:	06 d7       	bis	r7,	r6	;
    a952:	07 4f       	mov	r15,	r7	;
    a954:	07 8b       	sub	r11,	r7	;
    a956:	54 43       	mov.b	#1,	r4	;r3 As==01
    a958:	07 93       	cmp	#0,	r7	;r3 As==00
    a95a:	01 20       	jnz	$+4      	;abs 0xa95e
    a95c:	04 47       	mov	r7,	r4	;

0000a95e <.L15>:
    a95e:	0e 47       	mov	r7,	r14	;
    a960:	0e 86       	sub	r6,	r14	;
    a962:	56 43       	mov.b	#1,	r6	;r3 As==01
    a964:	07 9e       	cmp	r14,	r7	;
    a966:	01 28       	jnc	$+4      	;abs 0xa96a
    a968:	46 43       	clr.b	r6		;

0000a96a <.L16>:
    a96a:	04 d6       	bis	r6,	r4	;
    a96c:	0f 88       	sub	r8,	r15	;
    a96e:	0f 84       	sub	r4,	r15	;
    a970:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    a974:	00 00 
    a976:	0c da       	bis	r10,	r12	;
    a978:	0d d9       	bis	r9,	r13	;
    a97a:	0e db       	bis	r11,	r14	;
    a97c:	0f d8       	bis	r8,	r15	;
    a97e:	b0 12 54 a4 	call	#42068		;#0xa454

0000a982 <.Loc.265.1>:
    a982:	1c d1 04 00 	bis	4(r1),	r12	;
    a986:	1d d1 06 00 	bis	6(r1),	r13	;
    a98a:	1e d1 08 00 	bis	8(r1),	r14	;
    a98e:	1f d1 0a 00 	bis	10(r1),	r15	;0x0000a

0000a992 <.LBE11>:
    a992:	08 4c       	mov	r12,	r8	;
    a994:	78 f0 ff 00 	and.b	#255,	r8	;#0x00ff
    a998:	38 90 80 00 	cmp	#128,	r8	;#0x0080
    a99c:	2e 20       	jnz	$+94     	;abs 0xa9fa

0000a99e <.Loc.269.1>:
    a99e:	3c b0 00 01 	bit	#256,	r12	;#0x0100
    a9a2:	18 24       	jz	$+50     	;abs 0xa9d4

0000a9a4 <.Loc.270.1>:
    a9a4:	08 5c       	add	r12,	r8	;
    a9a6:	59 43       	mov.b	#1,	r9	;r3 As==01
    a9a8:	08 9c       	cmp	r12,	r8	;
    a9aa:	01 28       	jnc	$+4      	;abs 0xa9ae
    a9ac:	49 43       	clr.b	r9		;

0000a9ae <.L20>:
    a9ae:	4c 43       	clr.b	r12		;

0000a9b0 <.LVL24>:
    a9b0:	09 5d       	add	r13,	r9	;
    a9b2:	5a 43       	mov.b	#1,	r10	;r3 As==01
    a9b4:	09 9d       	cmp	r13,	r9	;
    a9b6:	01 28       	jnc	$+4      	;abs 0xa9ba
    a9b8:	0a 4c       	mov	r12,	r10	;

0000a9ba <.L22>:
    a9ba:	0c da       	bis	r10,	r12	;
    a9bc:	47 43       	clr.b	r7		;
    a9be:	0a 4c       	mov	r12,	r10	;
    a9c0:	0a 5e       	add	r14,	r10	;
    a9c2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a9c4:	0a 9e       	cmp	r14,	r10	;
    a9c6:	01 28       	jnc	$+4      	;abs 0xa9ca
    a9c8:	0c 47       	mov	r7,	r12	;

0000a9ca <.L24>:
    a9ca:	07 dc       	bis	r12,	r7	;
    a9cc:	0c 48       	mov	r8,	r12	;
    a9ce:	0d 49       	mov	r9,	r13	;
    a9d0:	0e 4a       	mov	r10,	r14	;
    a9d2:	0f 57       	add	r7,	r15	;

0000a9d4 <.L18>:
    a9d4:	59 43       	mov.b	#1,	r9	;r3 As==01
    a9d6:	3a 40 ff 0f 	mov	#4095,	r10	;#0x0fff
    a9da:	0a 9f       	cmp	r15,	r10	;
    a9dc:	01 28       	jnc	$+4      	;abs 0xa9e0
    a9de:	49 43       	clr.b	r9		;

0000a9e0 <.L30>:
    a9e0:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    a9e4:	b0 12 54 a4 	call	#42068		;#0xa454

0000a9e8 <.L61>:
    a9e8:	0a 4c       	mov	r12,	r10	;
    a9ea:	06 4d       	mov	r13,	r6	;
    a9ec:	07 4e       	mov	r14,	r7	;
    a9ee:	08 4f       	mov	r15,	r8	;

0000a9f0 <.LVL28>:
    a9f0:	39 3f       	jmp	$-396    	;abs 0xa864

0000a9f2 <.L51>:
    a9f2:	4c 43       	clr.b	r12		;
    a9f4:	0d 4c       	mov	r12,	r13	;
    a9f6:	0e 4c       	mov	r12,	r14	;
    a9f8:	0f 4c       	mov	r12,	r15	;

0000a9fa <.L17>:
    a9fa:	07 4c       	mov	r12,	r7	;
    a9fc:	37 50 7f 00 	add	#127,	r7	;#0x007f
    aa00:	59 43       	mov.b	#1,	r9	;r3 As==01
    aa02:	07 9c       	cmp	r12,	r7	;
    aa04:	01 28       	jnc	$+4      	;abs 0xaa08
    aa06:	49 43       	clr.b	r9		;

0000aa08 <.L25>:
    aa08:	4c 43       	clr.b	r12		;

0000aa0a <.LVL31>:
    aa0a:	09 5d       	add	r13,	r9	;
    aa0c:	5a 43       	mov.b	#1,	r10	;r3 As==01
    aa0e:	09 9d       	cmp	r13,	r9	;
    aa10:	01 28       	jnc	$+4      	;abs 0xaa14
    aa12:	0a 4c       	mov	r12,	r10	;

0000aa14 <.L27>:
    aa14:	0c da       	bis	r10,	r12	;
    aa16:	48 43       	clr.b	r8		;
    aa18:	0a 4c       	mov	r12,	r10	;
    aa1a:	0a 5e       	add	r14,	r10	;
    aa1c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    aa1e:	0a 9e       	cmp	r14,	r10	;
    aa20:	01 28       	jnc	$+4      	;abs 0xaa24
    aa22:	0c 48       	mov	r8,	r12	;

0000aa24 <.L29>:
    aa24:	08 dc       	bis	r12,	r8	;
    aa26:	0c 47       	mov	r7,	r12	;
    aa28:	0d 49       	mov	r9,	r13	;
    aa2a:	0e 4a       	mov	r10,	r14	;
    aa2c:	0f 58       	add	r8,	r15	;

0000aa2e <.LVL33>:
    aa2e:	d2 3f       	jmp	$-90     	;abs 0xa9d4

0000aa30 <.L5>:
    aa30:	3c 40 ff 03 	mov	#1023,	r12	;#0x03ff

0000aa34 <.LVL35>:
    aa34:	0c 94       	cmp	r4,	r12	;
    aa36:	60 38       	jl	$+194    	;abs 0xaaf8

0000aa38 <.LVL36>:
    aa38:	0e 4a       	mov	r10,	r14	;
    aa3a:	7e f0 ff 00 	and.b	#255,	r14	;#0x00ff
    aa3e:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    aa42:	2a 20       	jnz	$+86     	;abs 0xaa98

0000aa44 <.Loc.299.1>:
    aa44:	3a b0 00 01 	bit	#256,	r10	;#0x0100
    aa48:	16 24       	jz	$+46     	;abs 0xaa76

0000aa4a <.Loc.300.1>:
    aa4a:	0e 5a       	add	r10,	r14	;
    aa4c:	0e 9a       	cmp	r10,	r14	;
    aa4e:	01 28       	jnc	$+4      	;abs 0xaa52
    aa50:	49 43       	clr.b	r9		;

0000aa52 <.L35>:
    aa52:	4c 43       	clr.b	r12		;
    aa54:	09 56       	add	r6,	r9	;
    aa56:	5d 43       	mov.b	#1,	r13	;r3 As==01
    aa58:	09 96       	cmp	r6,	r9	;
    aa5a:	01 28       	jnc	$+4      	;abs 0xaa5e
    aa5c:	0d 4c       	mov	r12,	r13	;

0000aa5e <.L37>:
    aa5e:	0c dd       	bis	r13,	r12	;
    aa60:	4d 43       	clr.b	r13		;
    aa62:	0c 57       	add	r7,	r12	;
    aa64:	5f 43       	mov.b	#1,	r15	;r3 As==01
    aa66:	0c 97       	cmp	r7,	r12	;
    aa68:	01 28       	jnc	$+4      	;abs 0xaa6c
    aa6a:	0f 4d       	mov	r13,	r15	;

0000aa6c <.L39>:
    aa6c:	0d df       	bis	r15,	r13	;
    aa6e:	0a 4e       	mov	r14,	r10	;

0000aa70 <.LVL37>:
    aa70:	06 49       	mov	r9,	r6	;
    aa72:	07 4c       	mov	r12,	r7	;
    aa74:	08 5d       	add	r13,	r8	;

0000aa76 <.L33>:
    aa76:	35 40 54 a4 	mov	#42068,	r5	;#0xa454

0000aa7a <.Loc.307.1>:
    aa7a:	3e 40 ff 1f 	mov	#8191,	r14	;#0x1fff
    aa7e:	0e 98       	cmp	r8,	r14	;
    aa80:	24 28       	jnc	$+74     	;abs 0xaaca

0000aa82 <.Loc.293.1>:
    aa82:	09 44       	mov	r4,	r9	;
    aa84:	39 50 ff 03 	add	#1023,	r9	;#0x03ff

0000aa88 <.L47>:
    aa88:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    aa8c:	0c 4a       	mov	r10,	r12	;
    aa8e:	0d 46       	mov	r6,	r13	;
    aa90:	0e 47       	mov	r7,	r14	;
    aa92:	0f 48       	mov	r8,	r15	;
    aa94:	85 12       	call	r5		;
    aa96:	a8 3f       	jmp	$-174    	;abs 0xa9e8

0000aa98 <.L32>:
    aa98:	0d 4a       	mov	r10,	r13	;
    aa9a:	3d 50 7f 00 	add	#127,	r13	;#0x007f
    aa9e:	0d 9a       	cmp	r10,	r13	;
    aaa0:	01 28       	jnc	$+4      	;abs 0xaaa4
    aaa2:	49 43       	clr.b	r9		;

0000aaa4 <.L40>:
    aaa4:	4c 43       	clr.b	r12		;
    aaa6:	09 56       	add	r6,	r9	;
    aaa8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    aaaa:	09 96       	cmp	r6,	r9	;
    aaac:	01 28       	jnc	$+4      	;abs 0xaab0
    aaae:	0e 4c       	mov	r12,	r14	;

0000aab0 <.L42>:
    aab0:	0c de       	bis	r14,	r12	;
    aab2:	4e 43       	clr.b	r14		;
    aab4:	0c 57       	add	r7,	r12	;
    aab6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    aab8:	0c 97       	cmp	r7,	r12	;
    aaba:	01 28       	jnc	$+4      	;abs 0xaabe
    aabc:	0f 4e       	mov	r14,	r15	;

0000aabe <.L44>:
    aabe:	0e df       	bis	r15,	r14	;
    aac0:	0a 4d       	mov	r13,	r10	;

0000aac2 <.LVL42>:
    aac2:	06 49       	mov	r9,	r6	;
    aac4:	07 4c       	mov	r12,	r7	;
    aac6:	08 5e       	add	r14,	r8	;

0000aac8 <.LVL44>:
    aac8:	d6 3f       	jmp	$-82     	;abs 0xaa76

0000aaca <.L45>:
    aaca:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    aace:	0c 4a       	mov	r10,	r12	;
    aad0:	0d 46       	mov	r6,	r13	;
    aad2:	0e 47       	mov	r7,	r14	;
    aad4:	0f 48       	mov	r8,	r15	;
    aad6:	85 12       	call	r5		;
    aad8:	0a 4c       	mov	r12,	r10	;

0000aada <.LVL47>:
    aada:	06 4d       	mov	r13,	r6	;
    aadc:	07 4e       	mov	r14,	r7	;
    aade:	08 4f       	mov	r15,	r8	;

0000aae0 <.LVL48>:
    aae0:	09 44       	mov	r4,	r9	;
    aae2:	39 50 00 04 	add	#1024,	r9	;#0x0400

0000aae6 <.LVL49>:
    aae6:	d0 3f       	jmp	$-94     	;abs 0xaa88

0000aae8 <.L49>:
    aae8:	49 43       	clr.b	r9		;

0000aaea <.Loc.232.1>:
    aaea:	0a 49       	mov	r9,	r10	;

0000aaec <.LVL51>:
    aaec:	06 49       	mov	r9,	r6	;
    aaee:	07 49       	mov	r9,	r7	;
    aaf0:	08 49       	mov	r9,	r8	;
    aaf2:	b8 3e       	jmp	$-654    	;abs 0xa864

0000aaf4 <.L50>:
    aaf4:	09 4f       	mov	r15,	r9	;
    aaf6:	b6 3e       	jmp	$-658    	;abs 0xa864

0000aaf8 <.L52>:
    aaf8:	39 40 ff 07 	mov	#2047,	r9	;#0x07ff

0000aafc <.Loc.227.1>:
    aafc:	4a 43       	clr.b	r10		;

0000aafe <.LVL54>:
    aafe:	06 4a       	mov	r10,	r6	;
    ab00:	07 4a       	mov	r10,	r7	;
    ab02:	08 4a       	mov	r10,	r8	;
    ab04:	af 3e       	jmp	$-672    	;abs 0xa864

0000ab06 <__unpack_d>:
    ab06:	6a 15       	pushm	#7,	r10	;16-bit words

0000ab08 <.LCFI0>:
    ab08:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000ab0c <.LCFI1>:
    ab0c:	08 4c       	mov	r12,	r8	;
    ab0e:	0a 4d       	mov	r13,	r10	;

0000ab10 <.Loc.454.1>:
    ab10:	27 4c       	mov	@r12,	r7	;
    ab12:	1d 4c 02 00 	mov	2(r12),	r13	;

0000ab16 <L0>:
    ab16:	1e 4c 04 00 	mov	4(r12),	r14	;
    ab1a:	56 4c 06 00 	mov.b	6(r12),	r6	;
    ab1e:	0f 46       	mov	r6,	r15	;
    ab20:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f

0000ab24 <.LVL2>:
    ab24:	1c 4c 06 00 	mov	6(r12),	r12	;

0000ab28 <.LVL3>:
    ab28:	81 4d 08 00 	mov	r13,	8(r1)	;
    ab2c:	81 4e 06 00 	mov	r14,	6(r1)	;
    ab30:	81 4f 04 00 	mov	r15,	4(r1)	;
    ab34:	b0 12 cc a3 	call	#41932		;#0xa3cc

0000ab38 <.LVL4>:
    ab38:	09 4c       	mov	r12,	r9	;
    ab3a:	39 f0 ff 07 	and	#2047,	r9	;#0x07ff

0000ab3e <.LVL5>:
    ab3e:	5c 48 07 00 	mov.b	7(r8),	r12	;
    ab42:	5c 0f       	rrum	#4,	r12	;
    ab44:	5c 0b       	rrum	#3,	r12	;

0000ab46 <.Loc.508.1>:
    ab46:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ab4a:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000ab4e <.LVL6>:
    ab4e:	1d 41 08 00 	mov	8(r1),	r13	;
    ab52:	1e 41 06 00 	mov	6(r1),	r14	;
    ab56:	1f 41 04 00 	mov	4(r1),	r15	;

0000ab5a <.LVL8>:
    ab5a:	09 93       	cmp	#0,	r9	;r3 As==00
    ab5c:	4e 20       	jnz	$+158    	;abs 0xabfa

0000ab5e <.Loc.512.1>:
    ab5e:	0c 47       	mov	r7,	r12	;
    ab60:	0c dd       	bis	r13,	r12	;
    ab62:	0c de       	bis	r14,	r12	;
    ab64:	0c df       	bis	r15,	r12	;
    ab66:	0c 93       	cmp	#0,	r12	;r3 As==00
    ab68:	06 20       	jnz	$+14     	;abs 0xab76

0000ab6a <.Loc.519.1>:
    ab6a:	aa 43 00 00 	mov	#2,	0(r10)	;r3 As==10

0000ab6e <.L1>:
    ab6e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    ab72:	64 17       	popm	#7,	r10	;16-bit words
    ab74:	30 41       	ret			

0000ab76 <.L3>:
    ab76:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    ab7a:	0c 47       	mov	r7,	r12	;
    ab7c:	b0 12 d8 a4 	call	#42200		;#0xa4d8

0000ab80 <.LVL11>:
    ab80:	ba 40 03 00 	mov	#3,	0(r10)	;
    ab84:	00 00 
    ab86:	3b 40 01 fc 	mov	#64513,	r11	;#0xfc01

0000ab8a <.Loc.533.1>:
    ab8a:	55 43       	mov.b	#1,	r5	;r3 As==01

0000ab8c <.L18>:
    ab8c:	06 4c       	mov	r12,	r6	;
    ab8e:	06 5c       	add	r12,	r6	;
    ab90:	08 45       	mov	r5,	r8	;
    ab92:	06 9c       	cmp	r12,	r6	;
    ab94:	01 28       	jnc	$+4      	;abs 0xab98
    ab96:	08 49       	mov	r9,	r8	;

0000ab98 <.L5>:
    ab98:	07 4d       	mov	r13,	r7	;
    ab9a:	07 5d       	add	r13,	r7	;
    ab9c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ab9e <.LVL13>:
    ab9e:	07 9d       	cmp	r13,	r7	;
    aba0:	01 28       	jnc	$+4      	;abs 0xaba4
    aba2:	4c 43       	clr.b	r12		;

0000aba4 <.L6>:
    aba4:	08 57       	add	r7,	r8	;
    aba6:	0d 45       	mov	r5,	r13	;
    aba8:	08 97       	cmp	r7,	r8	;
    abaa:	01 28       	jnc	$+4      	;abs 0xabae
    abac:	0d 49       	mov	r9,	r13	;

0000abae <.L7>:
    abae:	0c dd       	bis	r13,	r12	;
    abb0:	0d 4e       	mov	r14,	r13	;
    abb2:	0d 5e       	add	r14,	r13	;
    abb4:	57 43       	mov.b	#1,	r7	;r3 As==01
    abb6:	0d 9e       	cmp	r14,	r13	;
    abb8:	01 28       	jnc	$+4      	;abs 0xabbc
    abba:	47 43       	clr.b	r7		;

0000abbc <.L8>:
    abbc:	04 4c       	mov	r12,	r4	;
    abbe:	04 5d       	add	r13,	r4	;
    abc0:	0c 45       	mov	r5,	r12	;
    abc2:	04 9d       	cmp	r13,	r4	;
    abc4:	01 28       	jnc	$+4      	;abs 0xabc8
    abc6:	0c 49       	mov	r9,	r12	;

0000abc8 <.L9>:
    abc8:	07 dc       	bis	r12,	r7	;
    abca:	0f 5f       	rla	r15		;
    abcc:	0c 46       	mov	r6,	r12	;
    abce:	0d 48       	mov	r8,	r13	;
    abd0:	0e 44       	mov	r4,	r14	;
    abd2:	0f 57       	add	r7,	r15	;

0000abd4 <.LVL14>:
    abd4:	81 4b 02 00 	mov	r11,	2(r1)	;
    abd8:	3b 53       	add	#-1,	r11	;r3 As==11

0000abda <.Loc.531.1>:
    abda:	37 40 ff 0f 	mov	#4095,	r7	;#0x0fff
    abde:	07 9f       	cmp	r15,	r7	;
    abe0:	d5 2f       	jc	$-84     	;abs 0xab8c

0000abe2 <.LVL15>:
    abe2:	9a 41 02 00 	mov	2(r1),	4(r10)	;
    abe6:	04 00 

0000abe8 <.Loc.537.1>:
    abe8:	8a 46 06 00 	mov	r6,	6(r10)	;
    abec:	8a 48 08 00 	mov	r8,	8(r10)	;
    abf0:	8a 44 0a 00 	mov	r4,	10(r10)	; 0x000a

0000abf4 <.L19>:
    abf4:	8a 4f 0c 00 	mov	r15,	12(r10)	; 0x000c

0000abf8 <.Loc.576.1>:
    abf8:	ba 3f       	jmp	$-138    	;abs 0xab6e

0000abfa <.L2>:
    abfa:	39 90 ff 07 	cmp	#2047,	r9	;#0x07ff
    abfe:	21 20       	jnz	$+68     	;abs 0xac42

0000ac00 <.Loc.543.1>:
    ac00:	0c 47       	mov	r7,	r12	;
    ac02:	0c dd       	bis	r13,	r12	;
    ac04:	0c de       	bis	r14,	r12	;
    ac06:	0c df       	bis	r15,	r12	;
    ac08:	0c 93       	cmp	#0,	r12	;r3 As==00
    ac0a:	03 20       	jnz	$+8      	;abs 0xac12

0000ac0c <.Loc.546.1>:
    ac0c:	aa 42 00 00 	mov	#4,	0(r10)	;r2 As==10
    ac10:	ae 3f       	jmp	$-162    	;abs 0xab6e

0000ac12 <.L13>:
    ac12:	76 f2       	and.b	#8,	r6	;r2 As==11
    ac14:	06 93       	cmp	#0,	r6	;r3 As==00
    ac16:	12 24       	jz	$+38     	;abs 0xac3c

0000ac18 <.Loc.557.1>:
    ac18:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01

0000ac1c <.L16>:
    ac1c:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    ac20:	0c 47       	mov	r7,	r12	;
    ac22:	b0 12 d8 a4 	call	#42200		;#0xa4d8
    ac26:	3c f0 00 ff 	and	#65280,	r12	;#0xff00
    ac2a:	8a 4c 06 00 	mov	r12,	6(r10)	;
    ac2e:	8a 4d 08 00 	mov	r13,	8(r10)	;
    ac32:	8a 4e 0a 00 	mov	r14,	10(r10)	; 0x000a
    ac36:	3f f0 ff f7 	and	#63487,	r15	;#0xf7ff
    ac3a:	dc 3f       	jmp	$-70     	;abs 0xabf4

0000ac3c <.L14>:
    ac3c:	8a 46 00 00 	mov	r6,	0(r10)	;
    ac40:	ed 3f       	jmp	$-36     	;abs 0xac1c

0000ac42 <.L12>:
    ac42:	39 50 01 fc 	add	#64513,	r9	;#0xfc01

0000ac46 <.LVL21>:
    ac46:	8a 49 04 00 	mov	r9,	4(r10)	;

0000ac4a <.Loc.573.1>:
    ac4a:	ba 40 03 00 	mov	#3,	0(r10)	;
    ac4e:	00 00 

0000ac50 <.Loc.574.1>:
    ac50:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    ac54:	0c 47       	mov	r7,	r12	;
    ac56:	b0 12 d8 a4 	call	#42200		;#0xa4d8

0000ac5a <.LVL22>:
    ac5a:	8a 4c 06 00 	mov	r12,	6(r10)	;
    ac5e:	8a 4d 08 00 	mov	r13,	8(r10)	;
    ac62:	8a 4e 0a 00 	mov	r14,	10(r10)	; 0x000a
    ac66:	3f d0 00 10 	bis	#4096,	r15	;#0x1000
    ac6a:	c4 3f       	jmp	$-118    	;abs 0xabf4

0000ac6c <__fpcmp_parts_d>:
    ac6c:	3a 15       	pushm	#4,	r10	;16-bit words

0000ac6e <.LCFI0>:
    ac6e:	2f 4c       	mov	@r12,	r15	;

0000ac70 <.Loc.1084.1>:
    ac70:	5a 43       	mov.b	#1,	r10	;r3 As==01
    ac72:	0a 9f       	cmp	r15,	r10	;
    ac74:	1a 2c       	jc	$+54     	;abs 0xacaa

0000ac76 <L0>:
    ac76:	2e 4d       	mov	@r13,	r14	;

0000ac78 <.Loc.1084.1>:
    ac78:	0a 9e       	cmp	r14,	r10	;
    ac7a:	17 2c       	jc	$+48     	;abs 0xacaa

0000ac7c <.Loc.1088.1>:
    ac7c:	2f 92       	cmp	#4,	r15	;r2 As==10
    ac7e:	0f 20       	jnz	$+32     	;abs 0xac9e

0000ac80 <.Loc.1088.1>:
    ac80:	2e 92       	cmp	#4,	r14	;r2 As==10
    ac82:	07 20       	jnz	$+16     	;abs 0xac92

0000ac84 <.Loc.1099.1>:
    ac84:	1e 4d 02 00 	mov	2(r13),	r14	;
    ac88:	1e 8c 02 00 	sub	2(r12),	r14	;

0000ac8c <.L1>:
    ac8c:	0c 4e       	mov	r14,	r12	;
    ac8e:	37 17       	popm	#4,	r10	;16-bit words
    ac90:	30 41       	ret			

0000ac92 <.L4>:
    ac92:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ac94:	8c 93 02 00 	cmp	#0,	2(r12)	;r3 As==00
    ac98:	f9 27       	jz	$-12     	;abs 0xac8c

0000ac9a <.L24>:
    ac9a:	3e 43       	mov	#-1,	r14	;r3 As==11
    ac9c:	f7 3f       	jmp	$-16     	;abs 0xac8c

0000ac9e <.L3>:
    ac9e:	2e 92       	cmp	#4,	r14	;r2 As==10
    aca0:	06 20       	jnz	$+14     	;abs 0xacae

0000aca2 <.L7>:
    aca2:	3e 43       	mov	#-1,	r14	;r3 As==11
    aca4:	8d 93 02 00 	cmp	#0,	2(r13)	;r3 As==00
    aca8:	f1 27       	jz	$-28     	;abs 0xac8c

0000acaa <.L15>:
    acaa:	5e 43       	mov.b	#1,	r14	;r3 As==01
    acac:	ef 3f       	jmp	$-32     	;abs 0xac8c

0000acae <.L5>:
    acae:	2f 93       	cmp	#2,	r15	;r3 As==10
    acb0:	04 20       	jnz	$+10     	;abs 0xacba

0000acb2 <.Loc.1110.1>:
    acb2:	2e 93       	cmp	#2,	r14	;r3 As==10
    acb4:	f6 23       	jnz	$-18     	;abs 0xaca2

0000acb6 <.L23>:
    acb6:	4e 43       	clr.b	r14		;
    acb8:	e9 3f       	jmp	$-44     	;abs 0xac8c

0000acba <.L6>:
    acba:	2e 93       	cmp	#2,	r14	;r3 As==10
    acbc:	ea 27       	jz	$-42     	;abs 0xac92

0000acbe <.Loc.1123.1>:
    acbe:	1f 4c 02 00 	mov	2(r12),	r15	;
    acc2:	1f 9d 02 00 	cmp	2(r13),	r15	;
    acc6:	04 24       	jz	$+10     	;abs 0xacd0

0000acc8 <.L25>:
    acc8:	5e 43       	mov.b	#1,	r14	;r3 As==01

0000acca <.Loc.1140.1>:
    acca:	0f 93       	cmp	#0,	r15	;r3 As==00
    accc:	df 27       	jz	$-64     	;abs 0xac8c
    acce:	e5 3f       	jmp	$-52     	;abs 0xac9a

0000acd0 <.L8>:
    acd0:	1a 4c 04 00 	mov	4(r12),	r10	;
    acd4:	1e 4d 04 00 	mov	4(r13),	r14	;
    acd8:	0e 9a       	cmp	r10,	r14	;
    acda:	f6 3b       	jl	$-18     	;abs 0xacc8

0000acdc <.Loc.1133.1>:
    acdc:	0a 9e       	cmp	r14,	r10	;
    acde:	03 34       	jge	$+8      	;abs 0xace6

0000ace0 <.L26>:
    ace0:	0f 93       	cmp	#0,	r15	;r3 As==00
    ace2:	e3 23       	jnz	$-56     	;abs 0xacaa
    ace4:	da 3f       	jmp	$-74     	;abs 0xac9a

0000ace6 <.L10>:
    ace6:	18 4c 06 00 	mov	6(r12),	r8	;
    acea:	1e 4c 08 00 	mov	8(r12),	r14	;
    acee:	1b 4c 0a 00 	mov	10(r12),r11	;0x0000a
    acf2:	19 4c 0c 00 	mov	12(r12),r9	;0x0000c
    acf6:	17 4d 06 00 	mov	6(r13),	r7	;
    acfa:	1c 4d 08 00 	mov	8(r13),	r12	;

0000acfe <.LVL18>:
    acfe:	1a 4d 0a 00 	mov	10(r13),r10	;0x0000a
    ad02:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c

0000ad06 <.LVL19>:
    ad06:	0d 99       	cmp	r9,	r13	;
    ad08:	df 2b       	jnc	$-64     	;abs 0xacc8
    ad0a:	09 9d       	cmp	r13,	r9	;
    ad0c:	0a 20       	jnz	$+22     	;abs 0xad22
    ad0e:	0a 9b       	cmp	r11,	r10	;
    ad10:	db 2b       	jnc	$-72     	;abs 0xacc8
    ad12:	0b 9a       	cmp	r10,	r11	;
    ad14:	06 20       	jnz	$+14     	;abs 0xad22
    ad16:	0c 9e       	cmp	r14,	r12	;
    ad18:	d7 2b       	jnc	$-80     	;abs 0xacc8
    ad1a:	0e 9c       	cmp	r12,	r14	;
    ad1c:	02 20       	jnz	$+6      	;abs 0xad22
    ad1e:	07 98       	cmp	r8,	r7	;
    ad20:	d3 2b       	jnc	$-88     	;abs 0xacc8

0000ad22 <.L11>:
    ad22:	09 9d       	cmp	r13,	r9	;
    ad24:	dd 2b       	jnc	$-68     	;abs 0xace0
    ad26:	0d 99       	cmp	r9,	r13	;
    ad28:	c6 23       	jnz	$-114    	;abs 0xacb6
    ad2a:	0b 9a       	cmp	r10,	r11	;
    ad2c:	d9 2b       	jnc	$-76     	;abs 0xace0
    ad2e:	0a 9b       	cmp	r11,	r10	;
    ad30:	c2 23       	jnz	$-122    	;abs 0xacb6
    ad32:	0e 9c       	cmp	r12,	r14	;
    ad34:	d5 2b       	jnc	$-84     	;abs 0xace0
    ad36:	0c 9e       	cmp	r14,	r12	;
    ad38:	be 23       	jnz	$-130    	;abs 0xacb6
    ad3a:	08 97       	cmp	r7,	r8	;
    ad3c:	d1 2b       	jnc	$-92     	;abs 0xace0
    ad3e:	bb 3f       	jmp	$-136    	;abs 0xacb6

0000ad40 <__mspabi_mpyi>:
    ad40:	02 12       	push	r2		;
    ad42:	32 c2       	dint			
    ad44:	03 43       	nop			
    ad46:	82 4c c0 04 	mov	r12,	&0x04c0	;
    ad4a:	82 4d c8 04 	Address 0x000000000000ad4c is out of bounds.
mov	r13,	&0xffff	;

0000ad4c <L0>:
    ad4c:	c8 04       	mova	r4,	r8	;
    ad4e:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    ad52:	00 13       	reti			

0000ad54 <__mspabi_mpyl>:
    ad54:	02 12       	push	r2		;
    ad56:	32 c2       	dint			
    ad58:	03 43       	nop			
    ad5a:	82 4c d0 04 	mov	r12,	&0x04d0	;
    ad5e:	82 4d d2 04 	mov	r13,	&0x04d2	;
    ad62:	82 4e e0 04 	mov	r14,	&0x04e0	;
    ad66:	82 4f e2 04 	mov	r15,	&0x04e2	;
    ad6a:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    ad6e:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    ad72:	00 13       	reti			

0000ad74 <memcpy>:
    ad74:	0f 4c       	mov	r12,	r15	;
    ad76:	0e 5c       	add	r12,	r14	;

0000ad78 <.L2>:
    ad78:	0f 9e       	cmp	r14,	r15	;
    ad7a:	05 24       	jz	$+12     	;abs 0xad86

0000ad7c <.LVL3>:
    ad7c:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    ad80:	1f 53       	inc	r15		;

0000ad82 <.LVL4>:
    ad82:	1d 53       	inc	r13		;
    ad84:	f9 3f       	jmp	$-12     	;abs 0xad78

0000ad86 <.L5>:
    ad86:	30 41       	ret			

0000ad88 <memmove>:
    ad88:	0b 4c       	mov	r12,	r11	;

0000ad8a <L0>:
    ad8a:	0b 5e       	add	r14,	r11	;

0000ad8c <.Loc.69.1>:
    ad8c:	0d 9c       	cmp	r12,	r13	;
    ad8e:	02 28       	jnc	$+6      	;abs 0xad94

0000ad90 <.L4>:
    ad90:	0e 4c       	mov	r12,	r14	;

0000ad92 <.LVL2>:
    ad92:	0f 3c       	jmp	$+32     	;abs 0xadb2

0000ad94 <.L2>:
    ad94:	0f 4d       	mov	r13,	r15	;
    ad96:	0f 5e       	add	r14,	r15	;
    ad98:	0c 9f       	cmp	r15,	r12	;
    ad9a:	fa 2f       	jc	$-10     	;abs 0xad90

0000ad9c <.LVL4>:
    ad9c:	0d 4f       	mov	r15,	r13	;

0000ad9e <.LVL5>:
    ad9e:	0e 8f       	sub	r15,	r14	;

0000ada0 <.L5>:
    ada0:	0f 4d       	mov	r13,	r15	;
    ada2:	0f 5e       	add	r14,	r15	;
    ada4:	0f 93       	cmp	#0,	r15	;r3 As==00
    ada6:	0c 24       	jz	$+26     	;abs 0xadc0

0000ada8 <.Loc.76.1>:
    ada8:	3b 53       	add	#-1,	r11	;r3 As==11
    adaa:	3d 53       	add	#-1,	r13	;r3 As==11

0000adac <.LVL8>:
    adac:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    adb0:	f7 3f       	jmp	$-16     	;abs 0xada0

0000adb2 <.L3>:
    adb2:	0b 9e       	cmp	r14,	r11	;
    adb4:	05 24       	jz	$+12     	;abs 0xadc0

0000adb6 <.LVL10>:
    adb6:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    adba:	1e 53       	inc	r14		;

0000adbc <.LVL11>:
    adbc:	1d 53       	inc	r13		;
    adbe:	f9 3f       	jmp	$-12     	;abs 0xadb2

0000adc0 <.L9>:
    adc0:	30 41       	ret			

0000adc2 <memset>:
    adc2:	0f 4c       	mov	r12,	r15	;
    adc4:	0e 5c       	add	r12,	r14	;

0000adc6 <.L2>:
    adc6:	0f 9e       	cmp	r14,	r15	;

0000adc8 <L0>:
    adc8:	04 24       	jz	$+10     	;abs 0xadd2

0000adca <.LVL3>:
    adca:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    adce:	1f 53       	inc	r15		;

0000add0 <.LVL4>:
    add0:	fa 3f       	jmp	$-10     	;abs 0xadc6

0000add2 <.L5>:
    add2:	30 41       	ret			
