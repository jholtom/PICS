
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	86 a6 ec 7f 	Address 0x000000000000ff92 is out of bounds.
dadd	r6,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	88 a6 ec 7f 	Address 0x000000000000ff94 is out of bounds.
dadd	r6,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	8a a6 00 00 	Address 0x000000000000ff96 is out of bounds.
dadd	r6,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	8c a6 00 00 	Address 0x000000000000ff98 is out of bounds.
dadd	r6,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	8e a6 00 00 	Address 0x000000000000ff9a is out of bounds.
dadd	r6,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	90 a6 00 00 	Address 0x000000000000ff9c is out of bounds.
Address 0x000000000000ff9e is out of bounds.
dadd	-1(r6),	0xffff	; PC rel. 0xff9d
    ff9e:	00 00 

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	92 a6 00 00 	Address 0x000000000000ff9e is out of bounds.
Address 0x000000000000ffa0 is out of bounds.
dadd	-1(r6),	&0xffff	;
    ffa0:	00 00 

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	94 a6 00 00 	Address 0x000000000000ffa0 is out of bounds.
Address 0x000000000000ffa2 is out of bounds.
dadd	-1(r6),	-1(r4)	; 0xffff
    ffa2:	00 00 

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	96 a6 00 00 	Address 0x000000000000ffa2 is out of bounds.
Address 0x000000000000ffa4 is out of bounds.
dadd	-1(r6),	-1(r6)	; 0xffff
    ffa4:	00 00 

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	98 a6 00 00 	Address 0x000000000000ffa4 is out of bounds.
Address 0x000000000000ffa6 is out of bounds.
dadd	-1(r6),	-1(r8)	; 0xffff
    ffa6:	00 00 

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	9a a6 00 00 	Address 0x000000000000ffa6 is out of bounds.
Address 0x000000000000ffa8 is out of bounds.
dadd	-1(r6),	-1(r10)	; 0xffff
    ffa8:	00 00 

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	9c a6 00 00 	Address 0x000000000000ffa8 is out of bounds.
Address 0x000000000000ffaa is out of bounds.
dadd	-1(r6),	-1(r12)	; 0xffff
    ffaa:	00 00 

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	9e a6 00 00 	Address 0x000000000000ffaa is out of bounds.
Address 0x000000000000ffac is out of bounds.
dadd	-1(r6),	-1(r14)	; 0xffff
    ffac:	00 00 

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	a0 a6 00 00 	Address 0x000000000000ffac is out of bounds.
dadd	@r6,	0xffff	; PC rel. 0xffab

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	a2 a6 00 00 	Address 0x000000000000ffae is out of bounds.
dadd	@r6,	&0xffff	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	a4 a6 00 00 	Address 0x000000000000ffb0 is out of bounds.
dadd	@r6,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	a6 a6 00 00 	Address 0x000000000000ffb2 is out of bounds.
dadd	@r6,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	a8 a6 00 00 	Address 0x000000000000ffb4 is out of bounds.
dadd	@r6,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	aa a6 00 00 	Address 0x000000000000ffb6 is out of bounds.
dadd	@r6,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	ac a6 00 00 	Address 0x000000000000ffb8 is out of bounds.
dadd	@r6,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	ae a6 00 00 	Address 0x000000000000ffba is out of bounds.
dadd	@r6,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	b0 a6 00 00 	Address 0x000000000000ffbc is out of bounds.
dadd	@r6+,	0xffff	; PC rel. 0xffbb

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	b2 a6 00 00 	Address 0x000000000000ffbe is out of bounds.
dadd	@r6+,	&0xffff	;

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	b4 a6 00 00 	Address 0x000000000000ffc0 is out of bounds.
dadd	@r6+,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	b6 a6 00 00 	Address 0x000000000000ffc2 is out of bounds.
dadd	@r6+,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	b8 a6 00 00 	Address 0x000000000000ffc4 is out of bounds.
dadd	@r6+,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	ba a6 00 00 	Address 0x000000000000ffc6 is out of bounds.
dadd	@r6+,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	bc a6 00 00 	Address 0x000000000000ffc8 is out of bounds.
dadd	@r6+,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	be a6 00 00 	Address 0x000000000000ffca is out of bounds.
dadd	@r6+,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	c0 a6 00 00 	Address 0x000000000000ffcc is out of bounds.
dadd.b	r6,	0xffff	; PC rel. 0xffcb

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	c2 a6 00 00 	Address 0x000000000000ffce is out of bounds.
dadd.b	r6,	&0xffff	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	c4 a6 00 00 	Address 0x000000000000ffd0 is out of bounds.
dadd.b	r6,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	72 7f       	subc.b	@r15+,	r2	;

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	0e 7f       	subc	r15,	r14	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	c6 a6 00 00 	Address 0x000000000000ffd6 is out of bounds.
dadd.b	r6,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	c8 a6 00 00 	Address 0x000000000000ffd8 is out of bounds.
dadd.b	r6,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	ac 7e 00 00 	Address 0x000000000000ffda is out of bounds.
subc	@r14,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	ca a6 00 00 	Address 0x000000000000ffdc is out of bounds.
dadd.b	r6,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	cc a6 00 00 	Address 0x000000000000ffde is out of bounds.
dadd.b	r6,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	4c 7e       	subc.b	r14,	r12	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	ce a6       	interrupt service routine at 0xa6ce

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	d0 a6       	interrupt service routine at 0xa6d0

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	10 87       	interrupt service routine at 0x8710

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	d2 a6       	interrupt service routine at 0xa6d2

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	d4 a6       	interrupt service routine at 0xa6d4

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	d6 a6       	interrupt service routine at 0xa6d6

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	32 91       	interrupt service routine at 0x9132

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	d8 a6       	interrupt service routine at 0xa6d8

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	fe 7c       	interrupt service routine at 0x7cfe

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	da a6       	interrupt service routine at 0xa6da

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	dc a6       	interrupt service routine at 0xa6dc

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	66 78       	interrupt service routine at 0x7866

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	de a6       	interrupt service routine at 0xa6de

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	e0 a6       	interrupt service routine at 0xa6e0

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	e2 a6       	interrupt service routine at 0xa6e2

Disassembly of section .text:

00006586 <__crt0_start>:
    6586:	31 40 00 50 	mov	#20480,	r1	;#0x5000

0000658a <__crt0_init_bss>:
    658a:	3c 40 56 5b 	mov	#23382,	r12	;#0x5b56

0000658e <.Loc.74.1>:
    658e:	0d 43       	clr	r13		;

00006590 <.Loc.75.1>:
    6590:	3e 40 30 0a 	mov	#2608,	r14	;#0x0a30

00006594 <.Loc.79.1>:
    6594:	b0 12 a4 db 	call	#56228		;#0xdba4

00006598 <__crt0_movedata>:
    6598:	3c 40 14 52 	mov	#21012,	r12	;#0x5214

0000659c <.Loc.116.1>:
    659c:	3d 40 14 52 	mov	#21012,	r13	;#0x5214

000065a0 <.Loc.119.1>:
    65a0:	0d 9c       	cmp	r12,	r13	;

000065a2 <.Loc.120.1>:
    65a2:	04 24       	jz	$+10     	;abs 0x65ac

000065a4 <.Loc.122.1>:
    65a4:	3e 40 42 09 	mov	#2370,	r14	;#0x0942

000065a8 <.Loc.124.1>:
    65a8:	b0 12 3e d8 	call	#55358		;#0xd83e

000065ac <__crt0_call_just_main>:
    65ac:	0c 43       	clr	r12		;

000065ae <.Loc.181.1>:
    65ae:	b0 12 a0 ad 	call	#44448		;#0xada0

000065b2 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    65b2:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00

000065b6 <.Loc.305.1>:
}
    65b6:	03 43       	nop			
    65b8:	30 41       	ret			

000065ba <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
    65ba:	21 83       	decd	r1		;

000065bc <.LBB2>:

  return __get_SR_register();
    65bc:	0c 42       	mov	r2,	r12	;
    65be:	81 4c 00 00 	mov	r12,	0(r1)	;
    65c2:	2c 41       	mov	@r1,	r12	;

000065c4 <.LBE2>:
}
    65c4:	21 53       	incd	r1		;
    65c6:	30 41       	ret			

000065c8 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
    65c8:	21 83       	decd	r1		;

000065ca <.LCFI1>:
    65ca:	81 4c 00 00 	mov	r12,	0(r1)	;

000065ce <.Loc.328.1>:

  return sts & GIE;
    65ce:	2c 41       	mov	@r1,	r12	;
    65d0:	7c f2       	and.b	#8,	r12	;r2 As==11
    65d2:	0d 43       	clr	r13		;
    65d4:	0d 8c       	sub	r12,	r13	;
    65d6:	0c dd       	bis	r13,	r12	;
    65d8:	5c 03       	rrum	#1,	r12	;
    65da:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    65de:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

000065e2 <.Loc.329.1>:
}
    65e2:	21 53       	incd	r1		;
    65e4:	30 41       	ret			

000065e6 <port_is_isr_context>:
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
  return __msp430x_in_isr;
    65e6:	5c 42 86 5b 	mov.b	&0x5b86,r12	;0x5b86

000065ea <.Loc.340.1>:
}
    65ea:	30 41       	ret			

000065ec <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    65ec:	32 c2       	dint			

000065ee <.Loc.348.1>:
  asm volatile("nop");
    65ee:	03 43       	nop			

000065f0 <.Loc.349.1>:
}
    65f0:	03 43       	nop			
    65f2:	30 41       	ret			

000065f4 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    65f4:	03 43       	nop			

000065f6 <.Loc.356.1>:
  _enable_interrupts();
    65f6:	32 d2       	eint			
    65f8:	03 43       	nop			

000065fa <.Loc.357.1>:
}
    65fa:	03 43       	nop			
    65fc:	30 41       	ret			

000065fe <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    65fe:	03 43       	nop			
    6600:	30 41       	ret			

00006602 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6602:	03 43       	nop			
    6604:	30 41       	ret			

00006606 <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    6606:	32 c2       	dint			

00006608 <.Loc.381.1>:
  asm volatile("nop");
    6608:	03 43       	nop			

0000660a <.Loc.382.1>:
}
    660a:	03 43       	nop			
    660c:	30 41       	ret			

0000660e <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    660e:	32 c2       	dint			

00006610 <.Loc.390.1>:
  asm volatile("nop");
    6610:	03 43       	nop			

00006612 <.Loc.391.1>:
}
    6612:	03 43       	nop			
    6614:	30 41       	ret			

00006616 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6616:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    661a:	0c 93       	cmp	#0,	r12	;r3 As==00
    661c:	04 20       	jnz	$+10     	;abs 0x6626

0000661e <.Loc.79.2>:
    661e:	1c 42 5e 5b 	mov	&0x5b5e,r12	;0x5b5e
    6622:	0c 93       	cmp	#0,	r12	;r3 As==00
    6624:	04 24       	jz	$+10     	;abs 0x662e

00006626 <.L19>:
    chSysHalt("SV#2");
    6626:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    662a:	b0 12 14 68 	call	#26644		;#0x6814

0000662e <.L21>:
  }
}
    662e:	03 43       	nop			
    6630:	30 41       	ret			

00006632 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6632:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    6636:	0c 93       	cmp	#0,	r12	;r3 As==00
    6638:	04 20       	jnz	$+10     	;abs 0x6642

0000663a <.Loc.103.2>:
    663a:	1c 42 5e 5b 	mov	&0x5b5e,r12	;0x5b5e
    663e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6640:	04 24       	jz	$+10     	;abs 0x664a

00006642 <.L27>:
    chSysHalt("SV#4");
    6642:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    6646:	b0 12 14 68 	call	#26644		;#0x6814

0000664a <.L28>:
  }
  _dbg_enter_lock();
    664a:	92 43 5e 5b 	mov	#1,	&0x5b5e	;r3 As==01

0000664e <.Loc.107.2>:
}
    664e:	03 43       	nop			
    6650:	30 41       	ret			

00006652 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6652:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    6656:	0c 93       	cmp	#0,	r12	;r3 As==00
    6658:	05 20       	jnz	$+12     	;abs 0x6664

0000665a <.Loc.116.2>:
    665a:	1d 42 5e 5b 	mov	&0x5b5e,r13	;0x5b5e
    665e:	4c 43       	clr.b	r12		;
    6660:	0c 9d       	cmp	r13,	r12	;
    6662:	04 38       	jl	$+10     	;abs 0x666c

00006664 <.L30>:
    chSysHalt("SV#5");
    6664:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    6668:	b0 12 14 68 	call	#26644		;#0x6814

0000666c <.L31>:
  }
  _dbg_leave_lock();
    666c:	82 43 5e 5b 	mov	#0,	&0x5b5e	;r3 As==00

00006670 <.Loc.120.2>:
}
    6670:	03 43       	nop			
    6672:	30 41       	ret			

00006674 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6674:	1d 42 5c 5b 	mov	&0x5b5c,r13	;0x5b5c
    6678:	4c 43       	clr.b	r12		;
    667a:	0c 9d       	cmp	r13,	r12	;
    667c:	04 34       	jge	$+10     	;abs 0x6686

0000667e <.Loc.129.2>:
    667e:	1c 42 5e 5b 	mov	&0x5b5e,r12	;0x5b5e
    6682:	0c 93       	cmp	#0,	r12	;r3 As==00
    6684:	04 24       	jz	$+10     	;abs 0x668e

00006686 <.L33>:
    chSysHalt("SV#6");
    6686:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    668a:	b0 12 14 68 	call	#26644		;#0x6814

0000668e <.L34>:
  }
  _dbg_enter_lock();
    668e:	92 43 5e 5b 	mov	#1,	&0x5b5e	;r3 As==01

00006692 <.Loc.133.2>:
}
    6692:	03 43       	nop			
    6694:	30 41       	ret			

00006696 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6696:	1d 42 5c 5b 	mov	&0x5b5c,r13	;0x5b5c
    669a:	4c 43       	clr.b	r12		;
    669c:	0c 9d       	cmp	r13,	r12	;
    669e:	05 34       	jge	$+12     	;abs 0x66aa

000066a0 <.Loc.142.2>:
    66a0:	1d 42 5e 5b 	mov	&0x5b5e,r13	;0x5b5e
    66a4:	4c 43       	clr.b	r12		;
    66a6:	0c 9d       	cmp	r13,	r12	;
    66a8:	04 38       	jl	$+10     	;abs 0x66b2

000066aa <.L36>:
    chSysHalt("SV#7");
    66aa:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    66ae:	b0 12 14 68 	call	#26644		;#0x6814

000066b2 <.L37>:
  }
  _dbg_leave_lock();
    66b2:	82 43 5e 5b 	mov	#0,	&0x5b5e	;r3 As==00

000066b6 <.Loc.146.2>:
}
    66b6:	03 43       	nop			
    66b8:	30 41       	ret			

000066ba <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    66ba:	b0 12 fe 65 	call	#26110		;#0x65fe

000066be <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    66be:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    66c2:	0c 93       	cmp	#0,	r12	;r3 As==00
    66c4:	04 38       	jl	$+10     	;abs 0x66ce

000066c6 <.Loc.156.2>:
    66c6:	1c 42 5e 5b 	mov	&0x5b5e,r12	;0x5b5e
    66ca:	0c 93       	cmp	#0,	r12	;r3 As==00
    66cc:	04 24       	jz	$+10     	;abs 0x66d6

000066ce <.L39>:
    chSysHalt("SV#8");
    66ce:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    66d2:	b0 12 14 68 	call	#26644		;#0x6814

000066d6 <.L40>:
  }
  nil.isr_cnt++;
    66d6:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    66da:	1c 53       	inc	r12		;
    66dc:	82 4c 5c 5b 	mov	r12,	&0x5b5c	;

000066e0 <.Loc.160.2>:
  port_unlock_from_isr();
    66e0:	b0 12 02 66 	call	#26114		;#0x6602

000066e4 <.Loc.161.2>:
}
    66e4:	03 43       	nop			
    66e6:	30 41       	ret			

000066e8 <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    66e8:	b0 12 fe 65 	call	#26110		;#0x65fe

000066ec <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    66ec:	1d 42 5c 5b 	mov	&0x5b5c,r13	;0x5b5c
    66f0:	4c 43       	clr.b	r12		;
    66f2:	0c 9d       	cmp	r13,	r12	;
    66f4:	04 34       	jge	$+10     	;abs 0x66fe

000066f6 <.Loc.171.2>:
    66f6:	1c 42 5e 5b 	mov	&0x5b5e,r12	;0x5b5e
    66fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    66fc:	04 24       	jz	$+10     	;abs 0x6706

000066fe <.L42>:
    chSysHalt("SV#9");
    66fe:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    6702:	b0 12 14 68 	call	#26644		;#0x6814

00006706 <.L43>:
  }
  nil.isr_cnt--;
    6706:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    670a:	3c 53       	add	#-1,	r12	;r3 As==11
    670c:	82 4c 5c 5b 	mov	r12,	&0x5b5c	;

00006710 <.Loc.175.2>:
  port_unlock_from_isr();
    6710:	b0 12 02 66 	call	#26114		;#0x6602

00006714 <.Loc.176.2>:
}
    6714:	03 43       	nop			
    6716:	30 41       	ret			

00006718 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6718:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    671c:	0c 93       	cmp	#0,	r12	;r3 As==00
    671e:	05 38       	jl	$+12     	;abs 0x672a

00006720 <.Loc.188.2>:
    6720:	1d 42 5e 5b 	mov	&0x5b5e,r13	;0x5b5e
    6724:	4c 43       	clr.b	r12		;
    6726:	0c 9d       	cmp	r13,	r12	;
    6728:	04 38       	jl	$+10     	;abs 0x6732

0000672a <.L45>:
    chSysHalt("SV#10");
    672a:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    672e:	b0 12 14 68 	call	#26644		;#0x6814

00006732 <.L47>:
  }
}
    6732:	03 43       	nop			
    6734:	30 41       	ret			

00006736 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6736:	1c 42 5c 5b 	mov	&0x5b5c,r12	;0x5b5c
    673a:	0c 93       	cmp	#0,	r12	;r3 As==00
    673c:	05 20       	jnz	$+12     	;abs 0x6748

0000673e <.Loc.203.2>:
    673e:	1d 42 5e 5b 	mov	&0x5b5e,r13	;0x5b5e
    6742:	4c 43       	clr.b	r12		;
    6744:	0c 9d       	cmp	r13,	r12	;
    6746:	04 38       	jl	$+10     	;abs 0x6750

00006748 <.L49>:
    chSysHalt("SV#11");
    6748:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    674c:	b0 12 14 68 	call	#26644		;#0x6814

00006750 <.L51>:
  }
}
    6750:	03 43       	nop			
    6752:	30 41       	ret			

00006754 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    6754:	21 82       	sub	#4,	r1	;r2 As==10

00006756 <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    6756:	82 43 5c 5b 	mov	#0,	&0x5b5c	;r3 As==00

0000675a <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    675a:	82 43 5e 5b 	mov	#0,	&0x5b5e	;r3 As==00

0000675e <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    675e:	b1 40 62 5b 	mov	#23394,	2(r1)	;#0x5b62
    6762:	02 00 

00006764 <.Loc.234.2>:
  tcp = nil_thd_configs;
    6764:	b1 40 42 51 	mov	#20802,	0(r1)	;#0x5142
    6768:	00 00 

0000676a <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    676a:	2d 3c       	jmp	$+92     	;abs 0x67c6

0000676c <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    676c:	2c 41       	mov	@r1,	r12	;
    676e:	2d 4c       	mov	@r12,	r13	;
    6770:	1c 41 02 00 	mov	2(r1),	r12	;
    6774:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006778 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    6778:	2c 41       	mov	@r1,	r12	;
    677a:	1c 4c 02 00 	mov	2(r12),	r12	;
    677e:	0d 4c       	mov	r12,	r13	;
    6780:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    6784:	1c 41 02 00 	mov	2(r1),	r12	;
    6788:	8c 4d 00 00 	mov	r13,	0(r12)	;
    678c:	1c 41 02 00 	mov	2(r1),	r12	;
    6790:	2c 4c       	mov	@r12,	r12	;
    6792:	2d 41       	mov	@r1,	r13	;
    6794:	1d 4d 06 00 	mov	6(r13),	r13	;
    6798:	8c 4d 00 00 	mov	r13,	0(r12)	;
    679c:	1c 41 02 00 	mov	2(r1),	r12	;
    67a0:	2c 4c       	mov	@r12,	r12	;
    67a2:	2d 41       	mov	@r1,	r13	;
    67a4:	1d 4d 08 00 	mov	8(r13),	r13	;
    67a8:	8c 4d 02 00 	mov	r13,	2(r12)	;
    67ac:	1c 41 02 00 	mov	2(r1),	r12	;
    67b0:	2c 4c       	mov	@r12,	r12	;
    67b2:	3d 40 e8 6b 	mov	#27624,	r13	;#0x6be8
    67b6:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

000067ba <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    67ba:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    67be:	02 00 

000067c0 <.Loc.247.2>:
    tcp++;
    67c0:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    67c4:	00 00 

000067c6 <.L53>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    67c6:	b1 90 6e 5b 	cmp	#23406,	2(r1)	;#0x5b6e
    67ca:	02 00 
    67cc:	cf 2b       	jnc	$-96     	;abs 0x676c

000067ce <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    67ce:	1c 41 02 00 	mov	2(r1),	r12	;
    67d2:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    67d6:	0a 00 

000067d8 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    67d8:	b0 12 0e 66 	call	#26126		;#0x660e
    67dc:	b0 12 16 66 	call	#26134		;#0x6616

000067e0 <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    67e0:	92 43 5e 5b 	mov	#1,	&0x5b5e	;r3 As==01

000067e4 <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    67e4:	b0 12 ba 6b 	call	#27578		;#0x6bba

000067e8 <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    67e8:	b0 12 b2 65 	call	#26034		;#0x65b2

000067ec <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    67ec:	b2 40 62 5b 	mov	#23394,	&0x5b58	;#0x5b62
    67f0:	58 5b 
    67f2:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    67f6:	82 4c 56 5b 	mov	r12,	&0x5b56	;

000067fa <.Loc.275.2>:
  port_switch(nil.current, tp);
    67fa:	1c 42 56 5b 	mov	&0x5b56,r12	;0x5b56
    67fe:	1d 41 02 00 	mov	2(r1),	r13	;
    6802:	b0 12 da 6b 	call	#27610		;#0x6bda

00006806 <.Loc.276.2>:
  chSysUnlock();
    6806:	b0 12 52 66 	call	#26194		;#0x6652
    680a:	b0 12 f4 65 	call	#26100		;#0x65f4

0000680e <.Loc.277.2>:
}
    680e:	03 43       	nop			
    6810:	21 52       	add	#4,	r1	;r2 As==10
    6812:	30 41       	ret			

00006814 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    6814:	21 83       	decd	r1		;

00006816 <L0>:
    6816:	81 4c 00 00 	mov	r12,	0(r1)	;

0000681a <.Loc.293.2>:

  port_disable();
    681a:	b0 12 06 66 	call	#26118		;#0x6606

0000681e <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    681e:	a2 41 60 5b 	mov	@r1,	&0x5b60	;

00006822 <.L56>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    6822:	ff 3f       	jmp	$+0      	;abs 0x6822

00006824 <chSysTimerHandlerI>:
    6824:	21 83       	decd	r1		;

00006826 <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    6826:	b0 12 18 67 	call	#26392		;#0x6718

0000682a <.Loc.320.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    682a:	b1 40 62 5b 	mov	#23394,	0(r1)	;#0x5b62
    682e:	00 00 

00006830 <.Loc.321.2>:
  nil.systime++;
    6830:	1c 42 5a 5b 	mov	&0x5b5a,r12	;0x5b5a
    6834:	1c 53       	inc	r12		;
    6836:	82 4c 5a 5b 	mov	r12,	&0x5b5a	;

0000683a <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    683a:	2c 41       	mov	@r1,	r12	;
    683c:	1c 4c 06 00 	mov	6(r12),	r12	;
    6840:	0c 93       	cmp	#0,	r12	;r3 As==00
    6842:	25 24       	jz	$+76     	;abs 0x688e

00006844 <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    6844:	2c 41       	mov	@r1,	r12	;
    6846:	1c 4c 06 00 	mov	6(r12),	r12	;
    684a:	3c 53       	add	#-1,	r12	;r3 As==11
    684c:	2d 41       	mov	@r1,	r13	;
    684e:	8d 4c 06 00 	mov	r12,	6(r13)	;
    6852:	0c 93       	cmp	#0,	r12	;r3 As==00
    6854:	1c 20       	jnz	$+58     	;abs 0x688e

00006856 <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    6856:	2c 41       	mov	@r1,	r12	;
    6858:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    685c:	7c 90 03 00 	cmp.b	#3,	r12	;
    6860:	08 20       	jnz	$+18     	;abs 0x6872

00006862 <.Loc.334.2>:
          tp->u1.semp->cnt++;
    6862:	2c 41       	mov	@r1,	r12	;
    6864:	1c 4c 04 00 	mov	4(r12),	r12	;
    6868:	2d 4c       	mov	@r12,	r13	;
    686a:	1d 53       	inc	r13		;
    686c:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6870:	0a 3c       	jmp	$+22     	;abs 0x6886

00006872 <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    6872:	2c 41       	mov	@r1,	r12	;
    6874:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    6878:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    687a:	05 20       	jnz	$+12     	;abs 0x6886

0000687c <.Loc.337.2>:
          *tp->u1.trp = NULL;
    687c:	2c 41       	mov	@r1,	r12	;
    687e:	1c 4c 04 00 	mov	4(r12),	r12	;
    6882:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006886 <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    6886:	3d 43       	mov	#-1,	r13	;r3 As==11
    6888:	2c 41       	mov	@r1,	r12	;
    688a:	b0 12 2a 69 	call	#26922		;#0x692a

0000688e <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    688e:	b0 12 96 66 	call	#26262		;#0x6696
    6892:	b0 12 02 66 	call	#26114		;#0x6602

00006896 <.Loc.346.2>:
    tp++;
    6896:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    689a:	00 00 

0000689c <.Loc.347.2>:
    chSysLockFromISR();
    689c:	b0 12 fe 65 	call	#26110		;#0x65fe
    68a0:	b0 12 74 66 	call	#26228		;#0x6674

000068a4 <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    68a4:	b1 90 6e 5b 	cmp	#23406,	0(r1)	;#0x5b6e
    68a8:	00 00 
    68aa:	c7 2b       	jnc	$-112    	;abs 0x683a

000068ac <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    68ac:	03 43       	nop			
    68ae:	21 53       	incd	r1		;
    68b0:	30 41       	ret			

000068b2 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    68b2:	21 83       	decd	r1		;

000068b4 <L0>:

  syssts_t sts = port_get_irq_status();
    68b4:	b0 12 ba 65 	call	#26042		;#0x65ba
    68b8:	81 4c 00 00 	mov	r12,	0(r1)	;

000068bc <.Loc.448.2>:
  if (port_irq_enabled(sts)) {
    68bc:	2c 41       	mov	@r1,	r12	;
    68be:	b0 12 c8 65 	call	#26056		;#0x65c8
    68c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    68c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    68c8:	0f 24       	jz	$+32     	;abs 0x68e8

000068ca <.Loc.449.2>:
    if (port_is_isr_context()) {
    68ca:	b0 12 e6 65 	call	#26086		;#0x65e6
    68ce:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    68d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    68d4:	05 24       	jz	$+12     	;abs 0x68e0

000068d6 <.Loc.450.2>:
      chSysLockFromISR();
    68d6:	b0 12 fe 65 	call	#26110		;#0x65fe
    68da:	b0 12 74 66 	call	#26228		;#0x6674
    68de:	04 3c       	jmp	$+10     	;abs 0x68e8

000068e0 <.L70>:
    }
    else {
      chSysLock();
    68e0:	b0 12 ec 65 	call	#26092		;#0x65ec
    68e4:	b0 12 32 66 	call	#26162		;#0x6632

000068e8 <.L69>:
    }
  }
  return sts;
    68e8:	2c 41       	mov	@r1,	r12	;

000068ea <.Loc.457.2>:
}
    68ea:	21 53       	incd	r1		;
    68ec:	30 41       	ret			

000068ee <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
    68ee:	21 83       	decd	r1		;

000068f0 <L0>:
    68f0:	81 4c 00 00 	mov	r12,	0(r1)	;

000068f4 <.Loc.470.2>:

  if (port_irq_enabled(sts)) {
    68f4:	2c 41       	mov	@r1,	r12	;
    68f6:	b0 12 c8 65 	call	#26056		;#0x65c8
    68fa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    68fe:	0c 93       	cmp	#0,	r12	;r3 As==00
    6900:	11 24       	jz	$+36     	;abs 0x6924

00006902 <.Loc.471.2>:
    if (port_is_isr_context()) {
    6902:	b0 12 e6 65 	call	#26086		;#0x65e6
    6906:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    690a:	0c 93       	cmp	#0,	r12	;r3 As==00
    690c:	05 24       	jz	$+12     	;abs 0x6918

0000690e <.Loc.472.2>:
      chSysUnlockFromISR();
    690e:	b0 12 96 66 	call	#26262		;#0x6696
    6912:	b0 12 02 66 	call	#26114		;#0x6602

00006916 <.Loc.479.2>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    6916:	06 3c       	jmp	$+14     	;abs 0x6924

00006918 <.L74>:
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    6918:	b0 12 a4 69 	call	#27044		;#0x69a4

0000691c <.Loc.476.2>:
      chSysUnlock();
    691c:	b0 12 52 66 	call	#26194		;#0x6652
    6920:	b0 12 f4 65 	call	#26100		;#0x65f4

00006924 <.L75>:
    }
  }
}
    6924:	03 43       	nop			
    6926:	21 53       	incd	r1		;
    6928:	30 41       	ret			

0000692a <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    692a:	21 82       	sub	#4,	r1	;r2 As==10

0000692c <L0>:
    692c:	81 4c 02 00 	mov	r12,	2(r1)	;
    6930:	81 4d 00 00 	mov	r13,	0(r1)	;

00006934 <.Loc.535.2>:

  chDbgCheckClassI();
    6934:	b0 12 18 67 	call	#26392		;#0x6718

00006938 <.Loc.540.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    6938:	1c 41 02 00 	mov	2(r1),	r12	;
    693c:	ac 41 04 00 	mov	@r1,	4(r12)	;

00006940 <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    6940:	1c 41 02 00 	mov	2(r1),	r12	;
    6944:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00006948 <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    6948:	1c 41 02 00 	mov	2(r1),	r12	;
    694c:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006950 <.Loc.543.2>:
  if (tp < nil.next) {
    6950:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    6954:	81 9c 02 00 	cmp	r12,	2(r1)	;
    6958:	03 2c       	jc	$+8      	;abs 0x6960

0000695a <.Loc.544.2>:
    nil.next = tp;
    695a:	92 41 02 00 	mov	2(r1),	&0x5b58	;
    695e:	58 5b 

00006960 <.L77>:
  }
  return tp;
    6960:	1c 41 02 00 	mov	2(r1),	r12	;

00006964 <.Loc.547.2>:
}
    6964:	21 52       	add	#4,	r1	;r2 As==10
    6966:	30 41       	ret			

00006968 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    6968:	1d 42 56 5b 	mov	&0x5b56,r13	;0x5b56
    696c:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    6970:	0c ed       	xor	r13,	r12	;
    6972:	0d 43       	clr	r13		;
    6974:	0d 8c       	sub	r12,	r13	;
    6976:	0c dd       	bis	r13,	r12	;
    6978:	5c 03       	rrum	#1,	r12	;
    697a:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    697e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006982 <.Loc.565.2>:
}
    6982:	30 41       	ret			

00006984 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    6984:	21 83       	decd	r1		;

00006986 <.LCFI8>:
  thread_t *otp = nil.current;
    6986:	91 42 56 5b 	mov	&0x5b56,0(r1)	;0x5b56
    698a:	00 00 

0000698c <.Loc.577.2>:

  nil.current = nil.next;
    698c:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    6990:	82 4c 56 5b 	mov	r12,	&0x5b56	;

00006994 <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    6994:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    6998:	2d 41       	mov	@r1,	r13	;
    699a:	b0 12 da 6b 	call	#27610		;#0x6bda

0000699e <.Loc.582.2>:
}
    699e:	03 43       	nop			
    69a0:	21 53       	incd	r1		;
    69a2:	30 41       	ret			

000069a4 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    69a4:	b0 12 36 67 	call	#26422		;#0x6736

000069a8 <.Loc.593.2>:

  if (chSchIsRescRequiredI()) {
    69a8:	1d 42 56 5b 	mov	&0x5b56,r13	;0x5b56
    69ac:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    69b0:	0d 9c       	cmp	r12,	r13	;
    69b2:	02 24       	jz	$+6      	;abs 0x69b8

000069b4 <.Loc.594.2>:
    chSchDoReschedule();
    69b4:	b0 12 84 69 	call	#27012		;#0x6984

000069b8 <.L84>:
  }
}
    69b8:	03 43       	nop			
    69ba:	30 41       	ret			

000069bc <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    69bc:	31 82       	sub	#8,	r1	;r2 As==11

000069be <.LCFI9>:
    69be:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    69c2:	81 4d 00 00 	mov	r13,	0(r1)	;

000069c6 <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    69c6:	91 42 56 5b 	mov	&0x5b56,4(r1)	;0x5b56
    69ca:	04 00 

000069cc <.Loc.618.2>:

  chDbgCheckClassS();
    69cc:	b0 12 36 67 	call	#26422		;#0x6736

000069d0 <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    69d0:	1c 41 04 00 	mov	4(r1),	r12	;
    69d4:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    69d8:	02 00 

000069da <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    69da:	1c 41 04 00 	mov	4(r1),	r12	;
    69de:	ac 41 06 00 	mov	@r1,	6(r12)	;

000069e2 <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    69e2:	b1 40 62 5b 	mov	#23394,	6(r1)	;#0x5b62
    69e6:	06 00 

000069e8 <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    69e8:	1c 41 06 00 	mov	6(r1),	r12	;
    69ec:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    69f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    69f2:	12 20       	jnz	$+38     	;abs 0x6a18

000069f4 <.Loc.667.2>:
      nil.current = nil.next = ntp;
    69f4:	92 41 06 00 	mov	6(r1),	&0x5b58	;
    69f8:	58 5b 
    69fa:	1c 42 58 5b 	mov	&0x5b58,r12	;0x5b58
    69fe:	82 4c 56 5b 	mov	r12,	&0x5b56	;

00006a02 <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    6a02:	1d 41 04 00 	mov	4(r1),	r13	;
    6a06:	1c 41 06 00 	mov	6(r1),	r12	;
    6a0a:	b0 12 da 6b 	call	#27610		;#0x6bda

00006a0e <.Loc.672.2>:
      return nil.current->u1.msg;
    6a0e:	1c 42 56 5b 	mov	&0x5b56,r12	;0x5b56
    6a12:	1c 4c 04 00 	mov	4(r12),	r12	;
    6a16:	04 3c       	jmp	$+10     	;abs 0x6a20

00006a18 <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    6a18:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    6a1c:	06 00 

00006a1e <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    6a1e:	e4 3f       	jmp	$-54     	;abs 0x69e8

00006a20 <.L89>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    6a20:	31 52       	add	#8,	r1	;r2 As==11
    6a22:	30 41       	ret			

00006a24 <chThdSuspendTimeoutS>:
 *                      .
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    6a24:	21 82       	sub	#4,	r1	;r2 As==10

00006a26 <.LCFI10>:
    6a26:	81 4c 02 00 	Address 0x0000000000006a28 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006a28 <L0>:
    6a28:	02 00       	mova	@r0,	r2	;
    6a2a:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a2e <.Loc.700.2>:

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    6a2e:	1d 42 56 5b 	mov	&0x5b56,r13	;0x5b56
    6a32:	1c 41 02 00 	mov	2(r1),	r12	;
    6a36:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006a3a <.Loc.701.2>:
  nil.current->u1.trp = trp;
    6a3a:	1c 42 56 5b 	mov	&0x5b56,r12	;0x5b56
    6a3e:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6a42:	04 00 

00006a44 <.Loc.702.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    6a44:	2d 41       	mov	@r1,	r13	;
    6a46:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6a48:	b0 12 bc 69 	call	#27068		;#0x69bc

00006a4c <.Loc.703.2>:
}
    6a4c:	21 52       	add	#4,	r1	;r2 As==10
    6a4e:	30 41       	ret			

00006a50 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    6a50:	31 80 06 00 	sub	#6,	r1	;

00006a54 <.LCFI11>:
    6a54:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a58:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a5c <.Loc.717.2>:

  if (*trp != NULL) {
    6a5c:	1c 41 02 00 	mov	2(r1),	r12	;
    6a60:	2c 4c       	mov	@r12,	r12	;
    6a62:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a64:	0d 24       	jz	$+28     	;abs 0x6a80

00006a66 <.LBB3>:
    thread_reference_t tr = *trp;
    6a66:	1c 41 02 00 	mov	2(r1),	r12	;
    6a6a:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006a6e <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    6a6e:	1c 41 02 00 	mov	2(r1),	r12	;
    6a72:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006a76 <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    6a76:	2d 41       	mov	@r1,	r13	;
    6a78:	1c 41 04 00 	mov	4(r1),	r12	;
    6a7c:	b0 12 2a 69 	call	#26922		;#0x692a

00006a80 <.L94>:
  }
}
    6a80:	03 43       	nop			
    6a82:	31 50 06 00 	add	#6,	r1	;
    6a86:	30 41       	ret			

00006a88 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    6a88:	21 83       	decd	r1		;

00006a8a <.LCFI12>:
    6a8a:	81 4c 00 00 	mov	r12,	0(r1)	;

00006a8e <.Loc.736.2>:

  chSysLock();
    6a8e:	b0 12 ec 65 	call	#26092		;#0x65ec
    6a92:	b0 12 32 66 	call	#26162		;#0x6632

00006a96 <.Loc.737.2>:
  chThdSleepS(timeout);
    6a96:	2d 41       	mov	@r1,	r13	;
    6a98:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6a9a:	b0 12 bc 69 	call	#27068		;#0x69bc

00006a9e <.Loc.738.2>:
  chSysUnlock();
    6a9e:	b0 12 52 66 	call	#26194		;#0x6652
    6aa2:	b0 12 f4 65 	call	#26100		;#0x65f4

00006aa6 <.Loc.739.2>:
}
    6aa6:	03 43       	nop			
    6aa8:	21 53       	incd	r1		;
    6aaa:	30 41       	ret			

00006aac <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    6aac:	31 80 06 00 	sub	#6,	r1	;

00006ab0 <.LCFI15>:
    6ab0:	81 4c 02 00 	mov	r12,	2(r1)	;
    6ab4:	81 4d 00 00 	mov	r13,	0(r1)	;

00006ab8 <.Loc.807.2>:

  chDbgCheckClassS();
    6ab8:	b0 12 36 67 	call	#26422		;#0x6736

00006abc <.Loc.812.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    6abc:	1c 41 02 00 	mov	2(r1),	r12	;
    6ac0:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006ac4 <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    6ac4:	4c 43       	clr.b	r12		;
    6ac6:	1c 91 04 00 	cmp	4(r1),	r12	;
    6aca:	17 38       	jl	$+48     	;abs 0x6afa

00006acc <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    6acc:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6ad0:	02 20       	jnz	$+6      	;abs 0x6ad6

00006ad2 <.Loc.815.2>:
      return MSG_TIMEOUT;
    6ad2:	3c 43       	mov	#-1,	r12	;r3 As==11
    6ad4:	1a 3c       	jmp	$+54     	;abs 0x6b0a

00006ad6 <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    6ad6:	1d 41 04 00 	mov	4(r1),	r13	;
    6ada:	3d 53       	add	#-1,	r13	;r3 As==11
    6adc:	1c 41 02 00 	mov	2(r1),	r12	;
    6ae0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006ae4 <.Loc.818.2>:
    nil.current->u1.semp = sp;
    6ae4:	1c 42 56 5b 	mov	&0x5b56,r12	;0x5b56
    6ae8:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6aec:	04 00 

00006aee <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    6aee:	2d 41       	mov	@r1,	r13	;
    6af0:	7c 40 03 00 	mov.b	#3,	r12	;
    6af4:	b0 12 bc 69 	call	#27068		;#0x69bc
    6af8:	08 3c       	jmp	$+18     	;abs 0x6b0a

00006afa <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    6afa:	1d 41 04 00 	mov	4(r1),	r13	;
    6afe:	3d 53       	add	#-1,	r13	;r3 As==11
    6b00:	1c 41 02 00 	mov	2(r1),	r12	;
    6b04:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006b08 <.Loc.822.2>:
  return MSG_OK;
    6b08:	4c 43       	clr.b	r12		;

00006b0a <.L102>:
}
    6b0a:	31 50 06 00 	add	#6,	r1	;
    6b0e:	30 41       	ret			

00006b10 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6b10:	32 c2       	dint			

00006b12 <.Loc.348.1>:
  asm volatile("nop");
    6b12:	03 43       	nop			

00006b14 <L0>:
}
    6b14:	03 43       	nop			
    6b16:	30 41       	ret			

00006b18 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6b18:	03 43       	nop			

00006b1a <.Loc.356.1>:
  _enable_interrupts();
    6b1a:	32 d2       	eint			
    6b1c:	03 43       	nop			

00006b1e <.Loc.357.1>:
}
    6b1e:	03 43       	nop			
    6b20:	30 41       	ret			

00006b22 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    6b22:	31 80 06 00 	sub	#6,	r1	;

00006b26 <.LCFI0>:
    6b26:	81 4c 02 00 	mov	r12,	2(r1)	;
    6b2a:	81 4d 00 00 	mov	r13,	0(r1)	;

00006b2e <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    6b2e:	b0 12 18 67 	call	#26392		;#0x6718

00006b32 <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    6b32:	2c 41       	mov	@r1,	r12	;
    6b34:	1c 51 02 00 	add	2(r1),	r12	;
    6b38:	0d 4c       	mov	r12,	r13	;
    6b3a:	3d 53       	add	#-1,	r13	;r3 As==11
    6b3c:	4c 43       	clr.b	r12		;
    6b3e:	2c 81       	sub	@r1,	r12	;
    6b40:	0e 4d       	mov	r13,	r14	;
    6b42:	0e fc       	and	r12,	r14	;
    6b44:	81 4e 02 00 	mov	r14,	2(r1)	;

00006b48 <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    6b48:	1c 42 7a 5b 	mov	&0x5b7a,r12	;0x5b7a
    6b4c:	2c 51       	add	@r1,	r12	;
    6b4e:	0d 4c       	mov	r12,	r13	;
    6b50:	3d 53       	add	#-1,	r13	;r3 As==11
    6b52:	4c 43       	clr.b	r12		;
    6b54:	2c 81       	sub	@r1,	r12	;
    6b56:	0c fd       	and	r13,	r12	;
    6b58:	81 4c 04 00 	mov	r12,	4(r1)	;

00006b5c <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    6b5c:	1c 42 7c 5b 	mov	&0x5b7c,r12	;0x5b7c
    6b60:	1d 41 04 00 	mov	4(r1),	r13	;
    6b64:	0c 8d       	sub	r13,	r12	;
    6b66:	1c 91 02 00 	cmp	2(r1),	r12	;
    6b6a:	02 2c       	jc	$+6      	;abs 0x6b70

00006b6c <.Loc.118.2>:
    return NULL;
    6b6c:	4c 43       	clr.b	r12		;
    6b6e:	08 3c       	jmp	$+18     	;abs 0x6b80

00006b70 <.L5>:
  }
  nextmem = p + size;
    6b70:	1c 41 04 00 	mov	4(r1),	r12	;
    6b74:	1c 51 02 00 	add	2(r1),	r12	;
    6b78:	82 4c 7a 5b 	mov	r12,	&0x5b7a	;

00006b7c <.Loc.122.2>:

  return p;
    6b7c:	1c 41 04 00 	mov	4(r1),	r12	;

00006b80 <.L6>:
}
    6b80:	31 50 06 00 	add	#6,	r1	;
    6b84:	30 41       	ret			

00006b86 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    6b86:	31 80 06 00 	Address 0x0000000000006b88 is out of bounds.
sub	#65535,	r1	;#0xffff

00006b88 <L0>:
    6b88:	06 00       	mova	@r0,	r6	;

00006b8a <.LCFI1>:
    6b8a:	81 4c 02 00 	mov	r12,	2(r1)	;
    6b8e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006b92 <.Loc.140.2>:
  void *p;

  chSysLock();
    6b92:	b0 12 10 6b 	call	#27408		;#0x6b10
    6b96:	b0 12 32 66 	call	#26162		;#0x6632

00006b9a <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    6b9a:	2d 41       	mov	@r1,	r13	;
    6b9c:	1c 41 02 00 	mov	2(r1),	r12	;
    6ba0:	b0 12 22 6b 	call	#27426		;#0x6b22
    6ba4:	81 4c 04 00 	mov	r12,	4(r1)	;

00006ba8 <.Loc.142.2>:
  chSysUnlock();
    6ba8:	b0 12 52 66 	call	#26194		;#0x6652
    6bac:	b0 12 18 6b 	call	#27416		;#0x6b18

00006bb0 <.Loc.144.2>:

  return p;
    6bb0:	1c 41 04 00 	mov	4(r1),	r12	;

00006bb4 <.Loc.145.2>:
}
    6bb4:	31 50 06 00 	add	#6,	r1	;
    6bb8:	30 41       	ret			

00006bba <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    6bba:	b2 40 86 6b 	mov	#27526,	&0x5b7e	;#0x6b86
    6bbe:	7e 5b 

00006bc0 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6bc0:	82 43 80 5b 	mov	#0,	&0x5b80	;r3 As==00

00006bc4 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    6bc4:	82 43 82 5b 	mov	#0,	&0x5b82	;r3 As==00

00006bc8 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    6bc8:	92 43 84 5b 	mov	#1,	&0x5b84	;r3 As==01

00006bcc <.Loc.117.1>:
#endif
}
    6bcc:	03 43       	nop			
    6bce:	30 41       	ret			

00006bd0 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6bd0:	03 43       	nop			

00006bd2 <.Loc.356.1>:
  _enable_interrupts();
    6bd2:	32 d2       	eint			
    6bd4:	03 43       	nop			

00006bd6 <.Loc.357.1>:
}
    6bd6:	03 43       	nop			
    6bd8:	30 41       	ret			

00006bda <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6bda:	6a 15       	pushm	#7,	r10	;16-bit words

00006bdc <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    6bdc:	8d 41 00 00 	mov	r1,	0(r13)	;

00006be0 <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    6be0:	21 4c       	mov	@r12,	r1	;

00006be2 <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    6be2:	64 17       	popm	#7,	r10	;16-bit words

00006be4 <.Loc.83.2>:
  asm volatile ("ret");
    6be4:	30 41       	ret			

00006be6 <.Loc.85.2>:
#endif
}
    6be6:	03 43       	nop			

00006be8 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    6be8:	b0 12 52 66 	call	#26194		;#0x6652
    6bec:	b0 12 d0 6b 	call	#27600		;#0x6bd0

00006bf0 <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    6bf0:	0c 45       	mov	r5,	r12	;

00006bf2 <.Loc.101.2>:
  asm volatile ("call R4");
    6bf2:	84 12       	call	r4		;

00006bf4 <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    6bf4:	4c 43       	clr.b	r12		;
    6bf6:	b0 12 14 68 	call	#26644		;#0x6814

00006bfa <.Loc.109.2>:
#endif
}
    6bfa:	03 43       	nop			
    6bfc:	30 41       	ret			

00006bfe <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    6bfe:	31 82       	sub	#8,	r1	;r2 As==11

00006c00 <.LCFI0>:
    6c00:	81 4c 02 00 	mov	r12,	2(r1)	;
    6c04:	81 4d 00 00 	mov	r13,	0(r1)	;

00006c08 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    6c08:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6c0c:	04 00 

00006c0e <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    6c0e:	1c 41 02 00 	mov	2(r1),	r12	;
    6c12:	2c 4c       	mov	@r12,	r12	;
    6c14:	0c 93       	cmp	#0,	r12	;r3 As==00
    6c16:	1d 34       	jge	$+60     	;abs 0x6c52

00006c18 <.LBB2>:
    thread_t *tp = nil.threads;
    6c18:	b1 40 62 5b 	mov	#23394,	6(r1)	;#0x5b62
    6c1c:	06 00 

00006c1e <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6c1e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c22:	1c 4c 04 00 	mov	4(r12),	r12	;
    6c26:	1c 91 04 00 	cmp	4(r1),	r12	;
    6c2a:	0f 20       	jnz	$+32     	;abs 0x6c4a

00006c2c <.Loc.67.1>:
        sp->cnt++;
    6c2c:	1c 41 04 00 	mov	4(r1),	r12	;
    6c30:	2c 4c       	mov	@r12,	r12	;
    6c32:	1c 53       	inc	r12		;
    6c34:	0d 4c       	mov	r12,	r13	;
    6c36:	1c 41 04 00 	mov	4(r1),	r12	;
    6c3a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006c3e <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    6c3e:	2d 41       	mov	@r1,	r13	;
    6c40:	1c 41 06 00 	mov	6(r1),	r12	;
    6c44:	b0 12 2a 69 	call	#26922		;#0x692a

00006c48 <.Loc.72.1>:
        return;
    6c48:	04 3c       	jmp	$+10     	;abs 0x6c52

00006c4a <.L3>:
      }
      tp++;
    6c4a:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    6c4e:	06 00 

00006c50 <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6c50:	e6 3f       	jmp	$-50     	;abs 0x6c1e

00006c52 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    6c52:	31 52       	add	#8,	r1	;r2 As==11
    6c54:	30 41       	ret			

00006c56 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
    6c56:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00006c5a <L0>:
    6c5a:	81 4c 02 00 	mov	r12,	2(r1)	;
    6c5e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006c62 <.Loc.91.1>:
  semaphore_t *sp = &tqp->sem;
    6c62:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6c66:	04 00 

00006c68 <.Loc.95.1>:
  thread_t *tp;
  cnt_t cnt;

  cnt = sp->cnt;
    6c68:	1c 41 04 00 	mov	4(r1),	r12	;
    6c6c:	a1 4c 06 00 	mov	@r12,	6(r1)	;

00006c70 <.Loc.96.1>:
  sp->cnt = (cnt_t)0;
    6c70:	1c 41 04 00 	mov	4(r1),	r12	;
    6c74:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006c78 <.Loc.97.1>:
  tp = nil.threads;
    6c78:	b1 40 62 5b 	mov	#23394,	8(r1)	;#0x5b62
    6c7c:	08 00 

00006c7e <.Loc.98.1>:
  while (cnt < (cnt_t)0) {
    6c7e:	14 3c       	jmp	$+42     	;abs 0x6ca8

00006c80 <.L8>:

    chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");

    /* Is this thread waiting on this semaphore?*/
    if (tp->u1.semp == sp) {
    6c80:	1c 41 08 00 	mov	8(r1),	r12	;
    6c84:	1c 4c 04 00 	mov	4(r12),	r12	;
    6c88:	1c 91 04 00 	cmp	4(r1),	r12	;
    6c8c:	0a 20       	jnz	$+22     	;abs 0x6ca2

00006c8e <.Loc.108.1>:

      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
    6c8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c92:	1c 53       	inc	r12		;
    6c94:	81 4c 06 00 	mov	r12,	6(r1)	;

00006c98 <.Loc.109.1>:
      (void) chSchReadyI(tp, msg);
    6c98:	2d 41       	mov	@r1,	r13	;
    6c9a:	1c 41 08 00 	mov	8(r1),	r12	;
    6c9e:	b0 12 2a 69 	call	#26922		;#0x692a

00006ca2 <.L7>:
    }
    tp++;
    6ca2:	b1 50 0c 00 	add	#12,	8(r1)	;#0x000c
    6ca6:	08 00 

00006ca8 <.L6>:
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = (cnt_t)0;
  tp = nil.threads;
  while (cnt < (cnt_t)0) {
    6ca8:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6cac:	e9 3b       	jl	$-44     	;abs 0x6c80

00006cae <.Loc.113.1>:
      cnt++;
      (void) chSchReadyI(tp, msg);
    }
    tp++;
  }
}
    6cae:	03 43       	nop			
    6cb0:	31 50 0a 00 	add	#10,	r1	;#0x000a
    6cb4:	30 41       	ret			

00006cb6 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    6cb6:	03 43       	nop			

00006cb8 <L0>:
    6cb8:	30 41       	ret			

00006cba <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    6cba:	b0 12 b6 6c 	call	#27830		;#0x6cb6

00006cbe <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    6cbe:	b0 12 0a 78 	call	#30730		;#0x780a

00006cc2 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    6cc2:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    6cc6:	b0 12 d6 7f 	call	#32726		;#0x7fd6

00006cca <.Loc.68.2>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    6cca:	b0 12 2c 73 	call	#29484		;#0x732c

00006cce <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    6cce:	b0 12 d8 75 	call	#30168		;#0x75d8

00006cd2 <.Loc.107.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    6cd2:	b0 12 3e 77 	call	#30526		;#0x773e

00006cd6 <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    6cd6:	b0 12 12 96 	call	#38418		;#0x9612

00006cda <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    6cda:	b0 12 e2 6c 	call	#27874		;#0x6ce2

00006cde <.Loc.145.2>:
#endif
}
    6cde:	03 43       	nop			
    6ce0:	30 41       	ret			

00006ce2 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    6ce2:	b0 12 a2 78 	call	#30882		;#0x78a2

00006ce6 <.Loc.63.2>:
}
    6ce6:	03 43       	nop			
    6ce8:	30 41       	ret			

00006cea <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6cea:	32 c2       	dint			

00006cec <.Loc.348.1>:
  asm volatile("nop");
    6cec:	03 43       	nop			

00006cee <.Loc.349.1>:
}
    6cee:	03 43       	nop			
    6cf0:	30 41       	ret			

00006cf2 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6cf2:	03 43       	nop			

00006cf4 <.Loc.356.1>:
  _enable_interrupts();
    6cf4:	32 d2       	eint			
    6cf6:	03 43       	nop			

00006cf8 <.Loc.357.1>:
}
    6cf8:	03 43       	nop			
    6cfa:	30 41       	ret			

00006cfc <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6cfc:	b0 12 ea 6c 	call	#27882		;#0x6cea
    6d00:	b0 12 32 66 	call	#26162		;#0x6632

00006d04 <.Loc.505.2>:
}
    6d04:	03 43       	nop			
    6d06:	30 41       	ret			

00006d08 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6d08:	b0 12 52 66 	call	#26194		;#0x6652
    6d0c:	b0 12 f2 6c 	call	#27890		;#0x6cf2

00006d10 <.Loc.516.2>:
}
    6d10:	03 43       	nop			
    6d12:	30 41       	ret			

00006d14 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6d14:	1c 42 5a 5b 	mov	&0x5b5a,r12	;0x5b5a

00006d18 <.Loc.630.2>:
}
    6d18:	30 41       	ret			

00006d1a <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6d1a:	21 83       	decd	r1		;

00006d1c <.LCFI0>:
    6d1c:	81 4c 00 00 	mov	r12,	0(r1)	;

00006d20 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6d20:	2c 41       	mov	@r1,	r12	;
    6d22:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006d26 <.Loc.768.2>:
}
    6d26:	03 43       	nop			
    6d28:	21 53       	incd	r1		;
    6d2a:	30 41       	ret			

00006d2c <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6d2c:	21 82       	sub	#4,	r1	;r2 As==10

00006d2e <.LCFI1>:
    6d2e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6d32:	81 4d 00 00 	mov	r13,	0(r1)	;

00006d36 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6d36:	1c 41 02 00 	mov	2(r1),	r12	;
    6d3a:	2d 41       	mov	@r1,	r13	;
    6d3c:	b0 12 ac 6a 	call	#27308		;#0x6aac

00006d40 <.Loc.797.2>:
}
    6d40:	21 52       	add	#4,	r1	;r2 As==10
    6d42:	30 41       	ret			

00006d44 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6d44:	31 82       	sub	#8,	r1	;r2 As==11

00006d46 <.LCFI2>:
    6d46:	81 4c 06 00 	mov	r12,	6(r1)	;
    6d4a:	81 4d 04 00 	mov	r13,	4(r1)	;
    6d4e:	81 4e 02 00 	mov	r14,	2(r1)	;
    6d52:	81 4f 00 00 	mov	r15,	0(r1)	;

00006d56 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6d56:	1c 41 06 00 	mov	6(r1),	r12	;
    6d5a:	b0 12 1a 6d 	call	#27930		;#0x6d1a

00006d5e <.Loc.59.3>:
  iqp->q_counter = 0;
    6d5e:	1c 41 06 00 	mov	6(r1),	r12	;
    6d62:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006d66 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6d66:	1c 41 06 00 	mov	6(r1),	r12	;
    6d6a:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6d6e:	04 00 

00006d70 <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    6d70:	1c 41 06 00 	mov	6(r1),	r12	;
    6d74:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6d78:	0a 00 

00006d7a <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6d7a:	1c 41 06 00 	mov	6(r1),	r12	;
    6d7e:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6d82:	08 00 

00006d84 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    6d84:	1d 41 04 00 	mov	4(r1),	r13	;
    6d88:	1d 51 02 00 	add	2(r1),	r13	;
    6d8c:	1c 41 06 00 	mov	6(r1),	r12	;
    6d90:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006d94 <.Loc.64.3>:
  iqp->q_notify  = infy;
    6d94:	1c 41 06 00 	mov	6(r1),	r12	;
    6d98:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006d9c <.Loc.65.3>:
  iqp->q_link    = link;
    6d9c:	1c 41 06 00 	mov	6(r1),	r12	;
    6da0:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6da4:	0e 00 

00006da6 <.Loc.66.3>:
}
    6da6:	03 43       	nop			
    6da8:	31 52       	add	#8,	r1	;r2 As==11
    6daa:	30 41       	ret			

00006dac <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    6dac:	21 82       	sub	#4,	r1	;r2 As==10

00006dae <.LCFI4>:
    6dae:	81 4c 02 00 	mov	r12,	2(r1)	;
    6db2:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006db6 <.Loc.104.3>:

  osalDbgCheckClassI();
    6db6:	b0 12 18 67 	call	#26392		;#0x6718

00006dba <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    6dba:	1c 41 02 00 	mov	2(r1),	r12	;
    6dbe:	1d 4c 08 00 	mov	8(r12),	r13	;
    6dc2:	1c 41 02 00 	mov	2(r1),	r12	;
    6dc6:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6dca:	0d 9c       	cmp	r12,	r13	;
    6dcc:	08 20       	jnz	$+18     	;abs 0x6dde

00006dce <.Loc.106.3>:
    6dce:	1c 41 02 00 	mov	2(r1),	r12	;
    6dd2:	1c 4c 02 00 	mov	2(r12),	r12	;
    6dd6:	0c 93       	cmp	#0,	r12	;r3 As==00
    6dd8:	02 24       	jz	$+6      	;abs 0x6dde

00006dda <.Loc.106.3>:
    6dda:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ddc:	01 3c       	jmp	$+4      	;abs 0x6de0

00006dde <.L13>:
    6dde:	4c 43       	clr.b	r12		;

00006de0 <.L14>:
    6de0:	5c f3       	and.b	#1,	r12	;r3 As==01
    6de2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6de6:	0c 93       	cmp	#0,	r12	;r3 As==00
    6de8:	02 24       	jz	$+6      	;abs 0x6dee

00006dea <.Loc.107.3>:
    return MSG_TIMEOUT;
    6dea:	3c 43       	mov	#-1,	r12	;r3 As==11
    6dec:	2f 3c       	jmp	$+96     	;abs 0x6e4c

00006dee <.L15>:
  }

  iqp->q_counter++;
    6dee:	1c 41 02 00 	mov	2(r1),	r12	;
    6df2:	1c 4c 02 00 	mov	2(r12),	r12	;
    6df6:	0d 4c       	mov	r12,	r13	;
    6df8:	1d 53       	inc	r13		;
    6dfa:	1c 41 02 00 	mov	2(r1),	r12	;
    6dfe:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006e02 <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    6e02:	1c 41 02 00 	mov	2(r1),	r12	;
    6e06:	1c 4c 08 00 	mov	8(r12),	r12	;
    6e0a:	0e 4c       	mov	r12,	r14	;
    6e0c:	1e 53       	inc	r14		;
    6e0e:	1d 41 02 00 	mov	2(r1),	r13	;
    6e12:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6e16:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6e1a:	00 00 

00006e1c <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6e1c:	1c 41 02 00 	mov	2(r1),	r12	;
    6e20:	1d 4c 08 00 	mov	8(r12),	r13	;
    6e24:	1c 41 02 00 	mov	2(r1),	r12	;
    6e28:	1c 4c 06 00 	mov	6(r12),	r12	;
    6e2c:	0d 9c       	cmp	r12,	r13	;
    6e2e:	08 28       	jnc	$+18     	;abs 0x6e40

00006e30 <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    6e30:	1c 41 02 00 	mov	2(r1),	r12	;
    6e34:	1d 4c 04 00 	mov	4(r12),	r13	;
    6e38:	1c 41 02 00 	mov	2(r1),	r12	;
    6e3c:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006e40 <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    6e40:	1c 41 02 00 	mov	2(r1),	r12	;
    6e44:	4d 43       	clr.b	r13		;
    6e46:	b0 12 fe 6b 	call	#27646		;#0x6bfe

00006e4a <.Loc.118.3>:

  return MSG_OK;
    6e4a:	4c 43       	clr.b	r12		;

00006e4c <.L16>:
}
    6e4c:	21 52       	add	#4,	r1	;r2 As==10
    6e4e:	30 41       	ret			

00006e50 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    6e50:	31 82       	sub	#8,	r1	;r2 As==11

00006e52 <.LCFI5>:
    6e52:	81 4c 02 00 	Address 0x0000000000006e54 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006e54 <L0>:
    6e54:	02 00       	mova	@r0,	r2	;
    6e56:	81 4d 00 00 	mov	r13,	0(r1)	;

00006e5a <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6e5a:	b0 12 fc 6c 	call	#27900		;#0x6cfc

00006e5e <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6e5e:	0f 3c       	jmp	$+32     	;abs 0x6e7e

00006e60 <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6e60:	1c 41 02 00 	mov	2(r1),	r12	;
    6e64:	2d 41       	mov	@r1,	r13	;
    6e66:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    6e6a:	81 4c 06 00 	mov	r12,	6(r1)	;

00006e6e <.Loc.149.3>:
    if (msg < MSG_OK) {
    6e6e:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6e72:	05 34       	jge	$+12     	;abs 0x6e7e

00006e74 <.Loc.150.3>:
      osalSysUnlock();
    6e74:	b0 12 08 6d 	call	#27912		;#0x6d08

00006e78 <.Loc.151.3>:
      return msg;
    6e78:	1c 41 06 00 	mov	6(r1),	r12	;
    6e7c:	3f 3c       	jmp	$+128    	;abs 0x6efc

00006e7e <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6e7e:	1c 41 02 00 	mov	2(r1),	r12	;
    6e82:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e86:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e88:	eb 27       	jz	$-40     	;abs 0x6e60

00006e8a <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6e8a:	1c 41 02 00 	mov	2(r1),	r12	;
    6e8e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e92:	0d 4c       	mov	r12,	r13	;
    6e94:	3d 53       	add	#-1,	r13	;r3 As==11
    6e96:	1c 41 02 00 	mov	2(r1),	r12	;
    6e9a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006e9e <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6e9e:	1c 41 02 00 	mov	2(r1),	r12	;
    6ea2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6ea6:	0e 4c       	mov	r12,	r14	;
    6ea8:	1e 53       	inc	r14		;
    6eaa:	1d 41 02 00 	mov	2(r1),	r13	;
    6eae:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6eb2:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

00006eb6 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    6eb6:	1c 41 02 00 	mov	2(r1),	r12	;
    6eba:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6ebe:	1c 41 02 00 	mov	2(r1),	r12	;
    6ec2:	1c 4c 06 00 	mov	6(r12),	r12	;
    6ec6:	0d 9c       	cmp	r12,	r13	;
    6ec8:	08 28       	jnc	$+18     	;abs 0x6eda

00006eca <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6eca:	1c 41 02 00 	mov	2(r1),	r12	;
    6ece:	1d 4c 04 00 	mov	4(r12),	r13	;
    6ed2:	1c 41 02 00 	mov	2(r1),	r12	;
    6ed6:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006eda <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6eda:	1c 41 02 00 	mov	2(r1),	r12	;
    6ede:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6ee2:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ee4:	07 24       	jz	$+16     	;abs 0x6ef4

00006ee6 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6ee6:	1c 41 02 00 	mov	2(r1),	r12	;
    6eea:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6eee:	1c 41 02 00 	mov	2(r1),	r12	;
    6ef2:	8d 12       	call	r13		;

00006ef4 <.L23>:
  }

  osalSysUnlock();
    6ef4:	b0 12 08 6d 	call	#27912		;#0x6d08

00006ef8 <.Loc.169.3>:

  return (msg_t)b;
    6ef8:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006efc <.L20>:
}
    6efc:	31 52       	add	#8,	r1	;r2 As==11
    6efe:	30 41       	ret			

00006f00 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    6f00:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006f04 <L0>:
    6f04:	81 4c 06 00 	mov	r12,	6(r1)	;
    6f08:	81 4d 04 00 	mov	r13,	4(r1)	;
    6f0c:	81 4e 02 00 	mov	r14,	2(r1)	;
    6f10:	81 4f 00 00 	mov	r15,	0(r1)	;

00006f14 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6f14:	1c 41 06 00 	mov	6(r1),	r12	;
    6f18:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6f1c:	0c 00 

00006f1e <.Loc.200.3>:
  size_t r = 0;
    6f1e:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006f22 <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6f22:	b0 12 fc 6c 	call	#27900		;#0x6cfc

00006f26 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6f26:	b0 12 14 6d 	call	#27924		;#0x6d14
    6f2a:	0d 4c       	mov	r12,	r13	;
    6f2c:	2d 51       	add	@r1,	r13	;
    6f2e:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006f32 <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6f32:	2e 3c       	jmp	$+94     	;abs 0x6f90

00006f34 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6f34:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6f38:	03 24       	jz	$+8      	;abs 0x6f40

00006f3a <.Loc.218.3>:
    6f3a:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6f3e:	08 20       	jnz	$+18     	;abs 0x6f50

00006f40 <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6f40:	1c 41 06 00 	mov	6(r1),	r12	;
    6f44:	2d 41       	mov	@r1,	r13	;
    6f46:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    6f4a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6f4e:	18 3c       	jmp	$+50     	;abs 0x6f80

00006f50 <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6f50:	b0 12 14 6d 	call	#27924		;#0x6d14
    6f54:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6f58:	0d 8c       	sub	r12,	r13	;
    6f5a:	81 4d 08 00 	mov	r13,	8(r1)	;

00006f5e <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6f5e:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6f62:	00 00 
    6f64:	05 2c       	jc	$+12     	;abs 0x6f70

00006f66 <.Loc.228.3>:
          osalSysUnlock();
    6f66:	b0 12 08 6d 	call	#27912		;#0x6d08

00006f6a <.Loc.229.3>:
          return r;
    6f6a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f6e:	5c 3c       	jmp	$+186    	;abs 0x7028

00006f70 <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    6f70:	1c 41 06 00 	mov	6(r1),	r12	;
    6f74:	1d 41 08 00 	mov	8(r1),	r13	;
    6f78:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    6f7c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006f80 <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6f80:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6f84:	05 24       	jz	$+12     	;abs 0x6f90

00006f86 <.Loc.237.3>:
        osalSysUnlock();
    6f86:	b0 12 08 6d 	call	#27912		;#0x6d08

00006f8a <.Loc.238.3>:
        return r;
    6f8a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f8e:	4c 3c       	jmp	$+154    	;abs 0x7028

00006f90 <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6f90:	1c 41 06 00 	mov	6(r1),	r12	;
    6f94:	1c 4c 02 00 	mov	2(r12),	r12	;
    6f98:	0c 93       	cmp	#0,	r12	;r3 As==00
    6f9a:	cc 27       	jz	$-102    	;abs 0x6f34

00006f9c <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    6f9c:	1c 41 06 00 	mov	6(r1),	r12	;
    6fa0:	1c 4c 02 00 	mov	2(r12),	r12	;
    6fa4:	0d 4c       	mov	r12,	r13	;
    6fa6:	3d 53       	add	#-1,	r13	;r3 As==11
    6fa8:	1c 41 06 00 	mov	6(r1),	r12	;
    6fac:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006fb0 <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    6fb0:	1c 41 04 00 	mov	4(r1),	r12	;
    6fb4:	0d 4c       	mov	r12,	r13	;
    6fb6:	1d 53       	inc	r13		;
    6fb8:	81 4d 04 00 	mov	r13,	4(r1)	;
    6fbc:	1d 41 06 00 	mov	6(r1),	r13	;
    6fc0:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    6fc4:	0f 4d       	mov	r13,	r15	;
    6fc6:	1f 53       	inc	r15		;
    6fc8:	1e 41 06 00 	mov	6(r1),	r14	;
    6fcc:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    6fd0:	6d 4d       	mov.b	@r13,	r13	;
    6fd2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006fd6 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    6fd6:	1c 41 06 00 	mov	6(r1),	r12	;
    6fda:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6fde:	1c 41 06 00 	mov	6(r1),	r12	;
    6fe2:	1c 4c 06 00 	mov	6(r12),	r12	;
    6fe6:	0d 9c       	cmp	r12,	r13	;
    6fe8:	08 28       	jnc	$+18     	;abs 0x6ffa

00006fea <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6fea:	1c 41 06 00 	mov	6(r1),	r12	;
    6fee:	1d 4c 04 00 	mov	4(r12),	r13	;
    6ff2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ff6:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006ffa <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6ffa:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6ffe:	05 24       	jz	$+12     	;abs 0x700a

00007000 <.Loc.251.3>:
      nfy(iqp);
    7000:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    7004:	1c 41 06 00 	mov	6(r1),	r12	;
    7008:	8d 12       	call	r13		;

0000700a <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    700a:	b0 12 08 6d 	call	#27912		;#0x6d08

0000700e <.Loc.257.3>:

    r++;
    700e:	91 53 10 00 	inc	16(r1)		;

00007012 <.Loc.258.3>:
    if (--n == 0U) {
    7012:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    7016:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    701a:	03 20       	jnz	$+8      	;abs 0x7022

0000701c <.Loc.259.3>:
      return r;
    701c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7020:	03 3c       	jmp	$+8      	;abs 0x7028

00007022 <.L34>:
    }

    osalSysLock();
    7022:	b0 12 fc 6c 	call	#27900		;#0x6cfc

00007026 <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    7026:	b4 3f       	jmp	$-150    	;abs 0x6f90

00007028 <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    7028:	31 50 12 00 	add	#18,	r1	;#0x0012
    702c:	30 41       	ret			

0000702e <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    702e:	31 82       	sub	#8,	r1	;r2 As==11

00007030 <.LCFI7>:
    7030:	81 4c 06 00 	mov	r12,	6(r1)	;
    7034:	81 4d 04 00 	mov	r13,	4(r1)	;
    7038:	81 4e 02 00 	Address 0x000000000000703a is out of bounds.
mov	r14,	-1(r1)	; 0xffff

0000703a <L0>:
    703a:	02 00       	mova	@r0,	r2	;
    703c:	81 4f 00 00 	mov	r15,	0(r1)	;

00007040 <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    7040:	1c 41 06 00 	mov	6(r1),	r12	;
    7044:	b0 12 1a 6d 	call	#27930		;#0x6d1a

00007048 <.Loc.285.3>:
  oqp->q_counter = size;
    7048:	1c 41 06 00 	mov	6(r1),	r12	;
    704c:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    7050:	02 00 

00007052 <.Loc.286.3>:
  oqp->q_buffer  = bp;
    7052:	1c 41 06 00 	mov	6(r1),	r12	;
    7056:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    705a:	04 00 

0000705c <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    705c:	1c 41 06 00 	mov	6(r1),	r12	;
    7060:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    7064:	0a 00 

00007066 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    7066:	1c 41 06 00 	mov	6(r1),	r12	;
    706a:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    706e:	08 00 

00007070 <.Loc.289.3>:
  oqp->q_top     = bp + size;
    7070:	1d 41 04 00 	mov	4(r1),	r13	;
    7074:	1d 51 02 00 	add	2(r1),	r13	;
    7078:	1c 41 06 00 	mov	6(r1),	r12	;
    707c:	8c 4d 06 00 	mov	r13,	6(r12)	;

00007080 <.Loc.290.3>:
  oqp->q_notify  = onfy;
    7080:	1c 41 06 00 	mov	6(r1),	r12	;
    7084:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00007088 <.Loc.291.3>:
  oqp->q_link    = link;
    7088:	1c 41 06 00 	mov	6(r1),	r12	;
    708c:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    7090:	0e 00 

00007092 <.Loc.292.3>:
}
    7092:	03 43       	nop			
    7094:	31 52       	add	#8,	r1	;r2 As==11
    7096:	30 41       	ret			

00007098 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    7098:	31 82       	sub	#8,	r1	;r2 As==11

0000709a <.LCFI9>:
    709a:	81 4c 04 00 	mov	r12,	4(r1)	;
    709e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    70a2:	81 4e 00 00 	mov	r14,	0(r1)	;

000070a6 <.Loc.339.3>:

  osalSysLock();
    70a6:	b0 12 fc 6c 	call	#27900		;#0x6cfc

000070aa <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    70aa:	0f 3c       	jmp	$+32     	;abs 0x70ca

000070ac <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    70ac:	1c 41 04 00 	mov	4(r1),	r12	;
    70b0:	2d 41       	mov	@r1,	r13	;
    70b2:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    70b6:	81 4c 06 00 	mov	r12,	6(r1)	;

000070ba <.Loc.344.3>:
    if (msg < MSG_OK) {
    70ba:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    70be:	05 34       	jge	$+12     	;abs 0x70ca

000070c0 <.Loc.345.3>:
      osalSysUnlock();
    70c0:	b0 12 08 6d 	call	#27912		;#0x6d08

000070c4 <.Loc.346.3>:
      return msg;
    70c4:	1c 41 06 00 	mov	6(r1),	r12	;
    70c8:	3f 3c       	jmp	$+128    	;abs 0x7148

000070ca <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    70ca:	1c 41 04 00 	mov	4(r1),	r12	;
    70ce:	1c 4c 02 00 	mov	2(r12),	r12	;
    70d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    70d4:	eb 27       	jz	$-40     	;abs 0x70ac

000070d6 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    70d6:	1c 41 04 00 	mov	4(r1),	r12	;
    70da:	1c 4c 02 00 	mov	2(r12),	r12	;
    70de:	0d 4c       	mov	r12,	r13	;
    70e0:	3d 53       	add	#-1,	r13	;r3 As==11
    70e2:	1c 41 04 00 	mov	4(r1),	r12	;
    70e6:	8c 4d 02 00 	mov	r13,	2(r12)	;

000070ea <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    70ea:	1c 41 04 00 	mov	4(r1),	r12	;
    70ee:	1c 4c 08 00 	mov	8(r12),	r12	;
    70f2:	0e 4c       	mov	r12,	r14	;
    70f4:	1e 53       	inc	r14		;
    70f6:	1d 41 04 00 	mov	4(r1),	r13	;
    70fa:	8d 4e 08 00 	mov	r14,	8(r13)	;
    70fe:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    7102:	00 00 

00007104 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    7104:	1c 41 04 00 	mov	4(r1),	r12	;
    7108:	1d 4c 08 00 	mov	8(r12),	r13	;
    710c:	1c 41 04 00 	mov	4(r1),	r12	;
    7110:	1c 4c 06 00 	mov	6(r12),	r12	;
    7114:	0d 9c       	cmp	r12,	r13	;
    7116:	08 28       	jnc	$+18     	;abs 0x7128

00007118 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    7118:	1c 41 04 00 	mov	4(r1),	r12	;
    711c:	1d 4c 04 00 	mov	4(r12),	r13	;
    7120:	1c 41 04 00 	mov	4(r1),	r12	;
    7124:	8c 4d 08 00 	mov	r13,	8(r12)	;

00007128 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    7128:	1c 41 04 00 	mov	4(r1),	r12	;
    712c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7130:	0c 93       	cmp	#0,	r12	;r3 As==00
    7132:	07 24       	jz	$+16     	;abs 0x7142

00007134 <.Loc.359.3>:
    oqp->q_notify(oqp);
    7134:	1c 41 04 00 	mov	4(r1),	r12	;
    7138:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    713c:	1c 41 04 00 	mov	4(r1),	r12	;
    7140:	8d 12       	call	r13		;

00007142 <.L43>:
  }

  osalSysUnlock();
    7142:	b0 12 08 6d 	call	#27912		;#0x6d08

00007146 <.Loc.364.3>:

  return MSG_OK;
    7146:	4c 43       	clr.b	r12		;

00007148 <.L40>:
}
    7148:	31 52       	add	#8,	r1	;r2 As==11
    714a:	30 41       	ret			

0000714c <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    714c:	21 82       	sub	#4,	r1	;r2 As==10

0000714e <.LCFI10>:
    714e:	81 4c 00 00 	Address 0x0000000000007150 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00007150 <L0>:
	...

00007152 <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    7152:	b0 12 18 67 	call	#26392		;#0x6718

00007156 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    7156:	2c 41       	mov	@r1,	r12	;
    7158:	1d 4c 08 00 	mov	8(r12),	r13	;
    715c:	2c 41       	mov	@r1,	r12	;
    715e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7162:	0d 9c       	cmp	r12,	r13	;
    7164:	07 20       	jnz	$+16     	;abs 0x7174

00007166 <.Loc.382.3>:
    7166:	2c 41       	mov	@r1,	r12	;
    7168:	1c 4c 02 00 	mov	2(r12),	r12	;
    716c:	0c 93       	cmp	#0,	r12	;r3 As==00
    716e:	02 24       	jz	$+6      	;abs 0x7174

00007170 <.Loc.382.3>:
    7170:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7172:	01 3c       	jmp	$+4      	;abs 0x7176

00007174 <.L45>:
    7174:	4c 43       	clr.b	r12		;

00007176 <.L46>:
    7176:	5c f3       	and.b	#1,	r12	;r3 As==01
    7178:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    717c:	0c 93       	cmp	#0,	r12	;r3 As==00
    717e:	02 24       	jz	$+6      	;abs 0x7184

00007180 <.Loc.383.3>:
    return MSG_TIMEOUT;
    7180:	3c 43       	mov	#-1,	r12	;r3 As==11
    7182:	26 3c       	jmp	$+78     	;abs 0x71d0

00007184 <.L47>:
  }

  oqp->q_counter++;
    7184:	2c 41       	mov	@r1,	r12	;
    7186:	1c 4c 02 00 	mov	2(r12),	r12	;
    718a:	0d 4c       	mov	r12,	r13	;
    718c:	1d 53       	inc	r13		;
    718e:	2c 41       	mov	@r1,	r12	;
    7190:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007194 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    7194:	2c 41       	mov	@r1,	r12	;
    7196:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    719a:	0e 4c       	mov	r12,	r14	;
    719c:	1e 53       	inc	r14		;
    719e:	2d 41       	mov	@r1,	r13	;
    71a0:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    71a4:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

000071a8 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    71a8:	2c 41       	mov	@r1,	r12	;
    71aa:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    71ae:	2c 41       	mov	@r1,	r12	;
    71b0:	1c 4c 06 00 	mov	6(r12),	r12	;
    71b4:	0d 9c       	cmp	r12,	r13	;
    71b6:	06 28       	jnc	$+14     	;abs 0x71c4

000071b8 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    71b8:	2c 41       	mov	@r1,	r12	;
    71ba:	1d 4c 04 00 	mov	4(r12),	r13	;
    71be:	2c 41       	mov	@r1,	r12	;
    71c0:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000071c4 <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    71c4:	2c 41       	mov	@r1,	r12	;
    71c6:	4d 43       	clr.b	r13		;
    71c8:	b0 12 fe 6b 	call	#27646		;#0x6bfe

000071cc <.Loc.394.3>:

  return (msg_t)b;
    71cc:	5c 41 03 00 	mov.b	3(r1),	r12	;

000071d0 <.L48>:
}
    71d0:	21 52       	add	#4,	r1	;r2 As==10
    71d2:	30 41       	ret			

000071d4 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    71d4:	31 80 12 00 	sub	#18,	r1	;#0x0012

000071d8 <L0>:
    71d8:	81 4c 06 00 	mov	r12,	6(r1)	;
    71dc:	81 4d 04 00 	mov	r13,	4(r1)	;
    71e0:	81 4e 02 00 	mov	r14,	2(r1)	;
    71e4:	81 4f 00 00 	mov	r15,	0(r1)	;

000071e8 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    71e8:	1c 41 06 00 	mov	6(r1),	r12	;
    71ec:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    71f0:	0c 00 

000071f2 <.Loc.425.3>:
  size_t w = 0;
    71f2:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

000071f6 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    71f6:	b0 12 fc 6c 	call	#27900		;#0x6cfc

000071fa <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    71fa:	b0 12 14 6d 	call	#27924		;#0x6d14
    71fe:	0d 4c       	mov	r12,	r13	;
    7200:	2d 51       	add	@r1,	r13	;
    7202:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00007206 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    7206:	2e 3c       	jmp	$+94     	;abs 0x7264

00007208 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    7208:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    720c:	03 24       	jz	$+8      	;abs 0x7214

0000720e <.Loc.442.3>:
    720e:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    7212:	08 20       	jnz	$+18     	;abs 0x7224

00007214 <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    7214:	1c 41 06 00 	mov	6(r1),	r12	;
    7218:	2d 41       	mov	@r1,	r13	;
    721a:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    721e:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    7222:	18 3c       	jmp	$+50     	;abs 0x7254

00007224 <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    7224:	b0 12 14 6d 	call	#27924		;#0x6d14
    7228:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    722c:	0e 8c       	sub	r12,	r14	;
    722e:	81 4e 08 00 	mov	r14,	8(r1)	;

00007232 <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    7232:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    7236:	00 00 
    7238:	05 2c       	jc	$+12     	;abs 0x7244

0000723a <.Loc.452.3>:
          osalSysUnlock();
    723a:	b0 12 08 6d 	call	#27912		;#0x6d08

0000723e <.Loc.453.3>:
          return w;
    723e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7242:	5c 3c       	jmp	$+186    	;abs 0x72fc

00007244 <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    7244:	1c 41 06 00 	mov	6(r1),	r12	;
    7248:	1d 41 08 00 	mov	8(r1),	r13	;
    724c:	b0 12 2c 6d 	call	#27948		;#0x6d2c
    7250:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00007254 <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    7254:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    7258:	05 24       	jz	$+12     	;abs 0x7264

0000725a <.Loc.461.3>:
        osalSysUnlock();
    725a:	b0 12 08 6d 	call	#27912		;#0x6d08

0000725e <.Loc.462.3>:
        return w;
    725e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7262:	4c 3c       	jmp	$+154    	;abs 0x72fc

00007264 <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    7264:	1c 41 06 00 	mov	6(r1),	r12	;
    7268:	1c 4c 02 00 	mov	2(r12),	r12	;
    726c:	0c 93       	cmp	#0,	r12	;r3 As==00
    726e:	cc 27       	jz	$-102    	;abs 0x7208

00007270 <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    7270:	1c 41 06 00 	mov	6(r1),	r12	;
    7274:	1c 4c 02 00 	mov	2(r12),	r12	;
    7278:	0d 4c       	mov	r12,	r13	;
    727a:	3d 53       	add	#-1,	r13	;r3 As==11
    727c:	1c 41 06 00 	mov	6(r1),	r12	;
    7280:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007284 <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    7284:	1c 41 06 00 	mov	6(r1),	r12	;
    7288:	1c 4c 08 00 	mov	8(r12),	r12	;
    728c:	0e 4c       	mov	r12,	r14	;
    728e:	1e 53       	inc	r14		;
    7290:	1d 41 06 00 	mov	6(r1),	r13	;
    7294:	8d 4e 08 00 	mov	r14,	8(r13)	;
    7298:	1d 41 04 00 	mov	4(r1),	r13	;
    729c:	0e 4d       	mov	r13,	r14	;
    729e:	1e 53       	inc	r14		;
    72a0:	81 4e 04 00 	mov	r14,	4(r1)	;
    72a4:	6d 4d       	mov.b	@r13,	r13	;
    72a6:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000072aa <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    72aa:	1c 41 06 00 	mov	6(r1),	r12	;
    72ae:	1d 4c 08 00 	mov	8(r12),	r13	;
    72b2:	1c 41 06 00 	mov	6(r1),	r12	;
    72b6:	1c 4c 06 00 	mov	6(r12),	r12	;
    72ba:	0d 9c       	cmp	r12,	r13	;
    72bc:	08 28       	jnc	$+18     	;abs 0x72ce

000072be <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    72be:	1c 41 06 00 	mov	6(r1),	r12	;
    72c2:	1d 4c 04 00 	mov	4(r12),	r13	;
    72c6:	1c 41 06 00 	mov	6(r1),	r12	;
    72ca:	8c 4d 08 00 	mov	r13,	8(r12)	;

000072ce <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    72ce:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    72d2:	05 24       	jz	$+12     	;abs 0x72de

000072d4 <.Loc.475.3>:
      nfy(oqp);
    72d4:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    72d8:	1c 41 06 00 	mov	6(r1),	r12	;
    72dc:	8d 12       	call	r13		;

000072de <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    72de:	b0 12 08 6d 	call	#27912		;#0x6d08

000072e2 <.Loc.481.3>:

    w++;
    72e2:	91 53 10 00 	inc	16(r1)		;

000072e6 <.Loc.482.3>:
    if (--n == 0U) {
    72e6:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    72ea:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    72ee:	03 20       	jnz	$+8      	;abs 0x72f6

000072f0 <.Loc.483.3>:
      return w;
    72f0:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    72f4:	03 3c       	jmp	$+8      	;abs 0x72fc

000072f6 <.L60>:
    }

    osalSysLock();
    72f6:	b0 12 fc 6c 	call	#27900		;#0x6cfc

000072fa <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    72fa:	85 3f       	jmp	$-244    	;abs 0x7206

000072fc <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    72fc:	31 50 12 00 	add	#18,	r1	;#0x0012
    7300:	30 41       	ret			

00007302 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    7302:	32 c2       	dint			

00007304 <.Loc.348.1>:
  asm volatile("nop");
    7304:	03 43       	nop			

00007306 <.Loc.349.1>:
}
    7306:	03 43       	nop			
    7308:	30 41       	ret			

0000730a <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    730a:	03 43       	nop			

0000730c <.Loc.356.1>:
  _enable_interrupts();
    730c:	32 d2       	eint			

0000730e <L0>:
    730e:	03 43       	nop			

00007310 <.Loc.357.1>:
}
    7310:	03 43       	nop			
    7312:	30 41       	ret			

00007314 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    7314:	b0 12 02 73 	call	#29442		;#0x7302
    7318:	b0 12 32 66 	call	#26162		;#0x6632

0000731c <.Loc.505.2>:
}
    731c:	03 43       	nop			
    731e:	30 41       	ret			

00007320 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    7320:	b0 12 52 66 	call	#26194		;#0x6652
    7324:	b0 12 0a 73 	call	#29450		;#0x730a

00007328 <.Loc.516.2>:
}
    7328:	03 43       	nop			
    732a:	30 41       	ret			

0000732c <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    732c:	b0 12 94 92 	call	#37524		;#0x9294

00007330 <.Loc.59.3>:
}
    7330:	03 43       	nop			
    7332:	30 41       	ret			

00007334 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    7334:	21 83       	decd	r1		;

00007336 <.LCFI3>:
    7336:	81 4c 00 00 	mov	r12,	0(r1)	;

0000733a <.Loc.70.3>:

  adcp->state    = ADC_STOP;
    733a:	2c 41       	mov	@r1,	r12	;
    733c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00007340 <.Loc.71.3>:
  adcp->config   = NULL;
    7340:	2c 41       	mov	@r1,	r12	;
    7342:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00007346 <.Loc.72.3>:
  adcp->samples  = NULL;
    7346:	2c 41       	mov	@r1,	r12	;
    7348:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

0000734c <.Loc.73.3>:
  adcp->depth    = 0;
    734c:	2c 41       	mov	@r1,	r12	;
    734e:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00007352 <.Loc.74.3>:
  adcp->grpp     = NULL;
    7352:	2c 41       	mov	@r1,	r12	;
    7354:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00007358 <.Loc.76.3>:
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    7358:	2c 41       	mov	@r1,	r12	;
    735a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000735e <.Loc.84.3>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    735e:	03 43       	nop			
    7360:	21 53       	incd	r1		;
    7362:	30 41       	ret			

00007364 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    7364:	21 82       	sub	#4,	r1	;r2 As==10

00007366 <.LCFI4>:
    7366:	81 4c 02 00 	mov	r12,	2(r1)	;
    736a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000736e <.Loc.99.3>:

  osalDbgCheck(adcp != NULL);

  osalSysLock();
    736e:	b0 12 14 73 	call	#29460		;#0x7314

00007372 <.Loc.102.3>:
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    7372:	1c 41 02 00 	mov	2(r1),	r12	;
    7376:	ac 41 02 00 	mov	@r1,	2(r12)	;

0000737a <.Loc.103.3>:
  adc_lld_start(adcp);
    737a:	1c 41 02 00 	mov	2(r1),	r12	;
    737e:	b0 12 ae 92 	call	#37550		;#0x92ae

00007382 <.Loc.104.3>:
  adcp->state = ADC_READY;
    7382:	1c 41 02 00 	mov	2(r1),	r12	;
    7386:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000738a <.Loc.105.3>:
  osalSysUnlock();
    738a:	b0 12 20 73 	call	#29472		;#0x7320

0000738e <.Loc.106.3>:
}
    738e:	03 43       	nop			
    7390:	21 52       	add	#4,	r1	;r2 As==10
    7392:	30 41       	ret			

00007394 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
    7394:	31 82       	sub	#8,	r1	;r2 As==11

00007396 <.LCFI6>:
    7396:	81 4c 06 00 	mov	r12,	6(r1)	;
    739a:	81 4d 04 00 	mov	r13,	4(r1)	;
    739e:	81 4e 02 00 	mov	r14,	2(r1)	;
    73a2:	81 4f 00 00 	mov	r15,	0(r1)	;

000073a6 <.Loc.152.3>:

  osalSysLock();
    73a6:	b0 12 14 73 	call	#29460		;#0x7314

000073aa <.Loc.153.3>:
  adcStartConversionI(adcp, grpp, samples, depth);
    73aa:	2f 41       	mov	@r1,	r15	;
    73ac:	1e 41 02 00 	mov	2(r1),	r14	;
    73b0:	1d 41 04 00 	mov	4(r1),	r13	;
    73b4:	1c 41 06 00 	mov	6(r1),	r12	;
    73b8:	b0 12 c6 73 	call	#29638		;#0x73c6

000073bc <.Loc.154.3>:
  osalSysUnlock();
    73bc:	b0 12 20 73 	call	#29472		;#0x7320

000073c0 <.Loc.155.3>:
}
    73c0:	03 43       	nop			
    73c2:	31 52       	add	#8,	r1	;r2 As==11
    73c4:	30 41       	ret			

000073c6 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
    73c6:	31 82       	sub	#8,	r1	;r2 As==11

000073c8 <.LCFI7>:
    73c8:	81 4c 06 00 	mov	r12,	6(r1)	;
    73cc:	81 4d 04 00 	mov	r13,	4(r1)	;
    73d0:	81 4e 02 00 	mov	r14,	2(r1)	;
    73d4:	81 4f 00 00 	mov	r15,	0(r1)	;

000073d8 <.Loc.180.3>:

  osalDbgCheckClassI();
    73d8:	b0 12 18 67 	call	#26392		;#0x6718

000073dc <.Loc.188.3>:
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
    73dc:	1c 41 06 00 	mov	6(r1),	r12	;
    73e0:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    73e4:	04 00 

000073e6 <.Loc.189.3>:
  adcp->depth    = depth;
    73e6:	1c 41 06 00 	mov	6(r1),	r12	;
    73ea:	ac 41 06 00 	mov	@r1,	6(r12)	;

000073ee <.Loc.190.3>:
  adcp->grpp     = grpp;
    73ee:	1c 41 06 00 	mov	6(r1),	r12	;
    73f2:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    73f6:	08 00 

000073f8 <.Loc.191.3>:
  adcp->state    = ADC_ACTIVE;
    73f8:	1c 41 06 00 	mov	6(r1),	r12	;
    73fc:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    7400:	00 00 

00007402 <.Loc.192.3>:
  adc_lld_start_conversion(adcp);
    7402:	1c 41 06 00 	mov	6(r1),	r12	;
    7406:	b0 12 48 93 	call	#37704		;#0x9348

0000740a <.Loc.193.3>:
}
    740a:	03 43       	nop			
    740c:	31 52       	add	#8,	r1	;r2 As==11
    740e:	30 41       	ret			

00007410 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    7410:	32 c2       	dint			

00007412 <.Loc.348.1>:
  asm volatile("nop");
    7412:	03 43       	nop			

00007414 <.Loc.349.1>:
}
    7414:	03 43       	nop			
    7416:	30 41       	ret			

00007418 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    7418:	03 43       	nop			

0000741a <.Loc.356.1>:
  _enable_interrupts();
    741a:	32 d2       	eint			
    741c:	03 43       	nop			

0000741e <.Loc.357.1>:
}
    741e:	03 43       	nop			
    7420:	30 41       	ret			

00007422 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    7422:	b0 12 10 74 	call	#29712		;#0x7410
    7426:	b0 12 32 66 	call	#26162		;#0x6632

0000742a <.Loc.505.2>:
}
    742a:	03 43       	nop			
    742c:	30 41       	ret			

0000742e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    742e:	b0 12 52 66 	call	#26194		;#0x6652
    7432:	b0 12 18 74 	call	#29720		;#0x7418

00007436 <.Loc.516.2>:
}
    7436:	03 43       	nop			
    7438:	30 41       	ret			

0000743a <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    743a:	21 83       	decd	r1		;

0000743c <.LCFI0>:
    743c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007440 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    7440:	2c 41       	mov	@r1,	r12	;
    7442:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    7446:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000744a <.Loc.811.2>:
  esp->cb    = NULL;
    744a:	2c 41       	mov	@r1,	r12	;
    744c:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00007450 <.Loc.812.2>:
  esp->param = NULL;
    7450:	2c 41       	mov	@r1,	r12	;
    7452:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00007456 <.Loc.813.2>:
}
    7456:	03 43       	nop			
    7458:	21 53       	incd	r1		;
    745a:	30 41       	ret			

0000745c <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    745c:	0a 15       	pushm	#1,	r10	;16-bit words

0000745e <.LCFI1>:
    745e:	31 80 06 00 	sub	#6,	r1	;

00007462 <.LCFI2>:
    7462:	81 4c 04 00 	mov	r12,	4(r1)	;
    7466:	81 4d 00 00 	mov	r13,	0(r1)	;
    746a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000746e <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    746e:	1c 41 04 00 	mov	4(r1),	r12	;
    7472:	1d 4c 02 00 	mov	2(r12),	r13	;
    7476:	2c 4c       	mov	@r12,	r12	;
    7478:	2a 41       	mov	@r1,	r10	;
    747a:	0a dc       	bis	r12,	r10	;
    747c:	1b 41 02 00 	mov	2(r1),	r11	;
    7480:	0b dd       	bis	r13,	r11	;
    7482:	1c 41 04 00 	mov	4(r1),	r12	;
    7486:	8c 4a 00 00 	mov	r10,	0(r12)	;
    748a:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000748e <.Loc.829.2>:
  if (esp->cb != NULL) {
    748e:	1c 41 04 00 	mov	4(r1),	r12	;
    7492:	1c 4c 04 00 	mov	4(r12),	r12	;
    7496:	0c 93       	cmp	#0,	r12	;r3 As==00
    7498:	07 24       	jz	$+16     	;abs 0x74a8

0000749a <.Loc.830.2>:
    esp->cb(esp);
    749a:	1c 41 04 00 	mov	4(r1),	r12	;
    749e:	1d 4c 04 00 	mov	4(r12),	r13	;
    74a2:	1c 41 04 00 	mov	4(r1),	r12	;
    74a6:	8d 12       	call	r13		;

000074a8 <.L9>:
  }
}
    74a8:	03 43       	nop			
    74aa:	31 50 06 00 	add	#6,	r1	;
    74ae:	0a 17       	popm	#1,	r10	;16-bit words
    74b0:	30 41       	ret			

000074b2 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    74b2:	31 80 06 00 	sub	#6,	r1	;

000074b6 <.LCFI3>:
    74b6:	81 4c 04 00 	mov	r12,	4(r1)	;
    74ba:	81 4d 02 00 	mov	r13,	2(r1)	;
    74be:	81 4e 00 00 	mov	r14,	0(r1)	;

000074c2 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    74c2:	1c 41 04 00 	mov	4(r1),	r12	;
    74c6:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    74ca:	4f 43       	clr.b	r15		;
    74cc:	2e 41       	mov	@r1,	r14	;
    74ce:	1d 41 02 00 	mov	2(r1),	r13	;
    74d2:	b0 12 d4 71 	call	#29140		;#0x71d4

000074d6 <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    74d6:	31 50 06 00 	add	#6,	r1	;
    74da:	30 41       	ret			

000074dc <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    74dc:	31 80 06 00 	sub	#6,	r1	;

000074e0 <.LCFI4>:
    74e0:	81 4c 04 00 	mov	r12,	4(r1)	;
    74e4:	81 4d 02 00 	mov	r13,	2(r1)	;
    74e8:	81 4e 00 00 	mov	r14,	0(r1)	;

000074ec <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    74ec:	1c 41 04 00 	mov	4(r1),	r12	;
    74f0:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    74f4:	4f 43       	clr.b	r15		;
    74f6:	2e 41       	mov	@r1,	r14	;
    74f8:	1d 41 02 00 	mov	2(r1),	r13	;
    74fc:	b0 12 00 6f 	call	#28416		;#0x6f00

00007500 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    7500:	31 50 06 00 	add	#6,	r1	;
    7504:	30 41       	ret			

00007506 <put>:

static msg_t put(void *ip, uint8_t b) {
    7506:	21 82       	sub	#4,	r1	;r2 As==10

00007508 <.LCFI5>:
    7508:	81 4c 02 00 	mov	r12,	2(r1)	;
    750c:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007510 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    7510:	1c 41 02 00 	mov	2(r1),	r12	;
    7514:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7518:	4e 43       	clr.b	r14		;
    751a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    751e:	b0 12 98 70 	call	#28824		;#0x7098

00007522 <.Loc.65.3>:
}
    7522:	21 52       	add	#4,	r1	;r2 As==10
    7524:	30 41       	ret			

00007526 <get>:

static msg_t get(void *ip) {
    7526:	21 83       	decd	r1		;

00007528 <.LCFI6>:
    7528:	81 4c 00 00 	mov	r12,	0(r1)	;

0000752c <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    752c:	2c 41       	mov	@r1,	r12	;
    752e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7532:	4d 43       	clr.b	r13		;
    7534:	b0 12 50 6e 	call	#28240		;#0x6e50

00007538 <.Loc.70.3>:
}
    7538:	21 53       	incd	r1		;
    753a:	30 41       	ret			

0000753c <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    753c:	31 80 06 00 	sub	#6,	r1	;

00007540 <.LCFI7>:
    7540:	81 4c 04 00 	mov	r12,	4(r1)	;
    7544:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    7548:	81 4e 00 00 	mov	r14,	0(r1)	;

0000754c <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    754c:	1c 41 04 00 	mov	4(r1),	r12	;
    7550:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7554:	2e 41       	mov	@r1,	r14	;
    7556:	5d 41 03 00 	mov.b	3(r1),	r13	;
    755a:	b0 12 98 70 	call	#28824		;#0x7098

0000755e <.Loc.75.3>:
}
    755e:	31 50 06 00 	add	#6,	r1	;
    7562:	30 41       	ret			

00007564 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    7564:	21 82       	sub	#4,	r1	;r2 As==10

00007566 <.LCFI8>:
    7566:	81 4c 02 00 	mov	r12,	2(r1)	;
    756a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000756e <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    756e:	1c 41 02 00 	mov	2(r1),	r12	;
    7572:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7576:	2d 41       	mov	@r1,	r13	;
    7578:	b0 12 50 6e 	call	#28240		;#0x6e50

0000757c <.Loc.80.3>:
}
    757c:	21 52       	add	#4,	r1	;r2 As==10
    757e:	30 41       	ret			

00007580 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    7580:	31 82       	sub	#8,	r1	;r2 As==11

00007582 <.LCFI9>:
    7582:	81 4c 06 00 	mov	r12,	6(r1)	;
    7586:	81 4d 04 00 	mov	r13,	4(r1)	;
    758a:	81 4e 02 00 	mov	r14,	2(r1)	;
    758e:	81 4f 00 00 	mov	r15,	0(r1)	;

00007592 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    7592:	1c 41 06 00 	mov	6(r1),	r12	;
    7596:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    759a:	2f 41       	mov	@r1,	r15	;
    759c:	1e 41 02 00 	mov	2(r1),	r14	;
    75a0:	1d 41 04 00 	mov	4(r1),	r13	;
    75a4:	b0 12 d4 71 	call	#29140		;#0x71d4

000075a8 <.Loc.85.3>:
}
    75a8:	31 52       	add	#8,	r1	;r2 As==11
    75aa:	30 41       	ret			

000075ac <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    75ac:	31 82       	sub	#8,	r1	;r2 As==11

000075ae <.LCFI10>:
    75ae:	81 4c 06 00 	mov	r12,	6(r1)	;
    75b2:	81 4d 04 00 	mov	r13,	4(r1)	;
    75b6:	81 4e 02 00 	mov	r14,	2(r1)	;
    75ba:	81 4f 00 00 	mov	r15,	0(r1)	;

000075be <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    75be:	1c 41 06 00 	mov	6(r1),	r12	;
    75c2:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    75c6:	2f 41       	mov	@r1,	r15	;
    75c8:	1e 41 02 00 	mov	2(r1),	r14	;
    75cc:	1d 41 04 00 	mov	4(r1),	r13	;
    75d0:	b0 12 00 6f 	call	#28416		;#0x6f00

000075d4 <.Loc.90.3>:
}
    75d4:	31 52       	add	#8,	r1	;r2 As==11
    75d6:	30 41       	ret			

000075d8 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    75d8:	b0 12 04 7e 	call	#32260		;#0x7e04

000075dc <.Loc.111.3>:
}
    75dc:	03 43       	nop			
    75de:	30 41       	ret			

000075e0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    75e0:	31 82       	sub	#8,	r1	;r2 As==11

000075e2 <.LCFI11>:
    75e2:	81 4c 06 00 	mov	r12,	6(r1)	;
    75e6:	81 4d 04 00 	mov	r13,	4(r1)	;
    75ea:	81 4e 02 00 	mov	r14,	2(r1)	;

000075ee <.Loc.130.3>:

  sdp->vmt = &vmt;
    75ee:	1c 41 06 00 	mov	6(r1),	r12	;
    75f2:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    75f6:	00 00 

000075f8 <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    75f8:	1c 41 06 00 	mov	6(r1),	r12	;
    75fc:	2c 53       	incd	r12		;
    75fe:	b0 12 3a 74 	call	#29754		;#0x743a

00007602 <.Loc.132.3>:
  sdp->state = SD_STOP;
    7602:	1c 41 06 00 	mov	6(r1),	r12	;
    7606:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

0000760a <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    760a:	1c 41 06 00 	mov	6(r1),	r12	;
    760e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7612:	1d 41 06 00 	mov	6(r1),	r13	;
    7616:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    761a:	91 41 06 00 	mov	6(r1),	0(r1)	;
    761e:	00 00 
    7620:	1f 41 04 00 	mov	4(r1),	r15	;
    7624:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7628:	b0 12 44 6d 	call	#27972		;#0x6d44

0000762c <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    762c:	1c 41 06 00 	mov	6(r1),	r12	;
    7630:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7634:	1d 41 06 00 	mov	6(r1),	r13	;
    7638:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    763c:	91 41 06 00 	mov	6(r1),	0(r1)	;
    7640:	00 00 
    7642:	1f 41 02 00 	mov	2(r1),	r15	;
    7646:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    764a:	b0 12 2e 70 	call	#28718		;#0x702e

0000764e <.Loc.135.3>:
}
    764e:	03 43       	nop			
    7650:	31 52       	add	#8,	r1	;r2 As==11
    7652:	30 41       	ret			

00007654 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    7654:	21 82       	sub	#4,	r1	;r2 As==10

00007656 <.LCFI12>:
    7656:	81 4c 02 00 	mov	r12,	2(r1)	;
    765a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000765e <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    765e:	b0 12 22 74 	call	#29730		;#0x7422

00007662 <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    7662:	2d 41       	mov	@r1,	r13	;
    7664:	1c 41 02 00 	mov	2(r1),	r12	;
    7668:	b0 12 16 7e 	call	#32278		;#0x7e16

0000766c <.Loc.155.3>:
  sdp->state = SD_READY;
    766c:	1c 41 02 00 	mov	2(r1),	r12	;
    7670:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00007674 <.Loc.156.3>:
  osalSysUnlock();
    7674:	b0 12 2e 74 	call	#29742		;#0x742e

00007678 <.Loc.157.3>:
}
    7678:	03 43       	nop			
    767a:	21 52       	add	#4,	r1	;r2 As==10
    767c:	30 41       	ret			

0000767e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    767e:	21 82       	sub	#4,	r1	;r2 As==10

00007680 <.LCFI14>:
    7680:	81 4c 02 00 	mov	r12,	2(r1)	;
    7684:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007688 <.Loc.204.3>:

  osalDbgCheckClassI();
    7688:	b0 12 18 67 	call	#26392		;#0x6718

0000768c <.Loc.207.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    768c:	1c 41 02 00 	mov	2(r1),	r12	;
    7690:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    7694:	0c 93       	cmp	#0,	r12	;r3 As==00
    7696:	07 20       	jnz	$+16     	;abs 0x76a6

00007698 <.Loc.208.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    7698:	1c 41 02 00 	mov	2(r1),	r12	;
    769c:	2c 53       	incd	r12		;
    769e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    76a0:	4e 43       	clr.b	r14		;
    76a2:	b0 12 5c 74 	call	#29788		;#0x745c

000076a6 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    76a6:	1c 41 02 00 	mov	2(r1),	r12	;
    76aa:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    76ae:	5d 41 01 00 	mov.b	1(r1),	r13	;
    76b2:	b0 12 ac 6d 	call	#28076		;#0x6dac
    76b6:	0c 93       	cmp	#0,	r12	;r3 As==00
    76b8:	08 34       	jge	$+18     	;abs 0x76ca

000076ba <.Loc.210.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    76ba:	1c 41 02 00 	mov	2(r1),	r12	;
    76be:	2c 53       	incd	r12		;
    76c0:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    76c4:	4e 43       	clr.b	r14		;
    76c6:	b0 12 5c 74 	call	#29788		;#0x745c

000076ca <.L33>:
}
    76ca:	03 43       	nop			
    76cc:	21 52       	add	#4,	r1	;r2 As==10
    76ce:	30 41       	ret			

000076d0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    76d0:	21 82       	sub	#4,	r1	;r2 As==10

000076d2 <.LCFI15>:
    76d2:	81 4c 00 00 	mov	r12,	0(r1)	;

000076d6 <.Loc.231.3>:
  msg_t  b;

  osalDbgCheckClassI();
    76d6:	b0 12 18 67 	call	#26392		;#0x6718

000076da <.Loc.234.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    76da:	2c 41       	mov	@r1,	r12	;
    76dc:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    76e0:	b0 12 4c 71 	call	#29004		;#0x714c
    76e4:	81 4c 02 00 	mov	r12,	2(r1)	;

000076e8 <.Loc.235.3>:
  if (b < MSG_OK)
    76e8:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    76ec:	06 34       	jge	$+14     	;abs 0x76fa

000076ee <.Loc.236.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    76ee:	2c 41       	mov	@r1,	r12	;
    76f0:	2c 53       	incd	r12		;
    76f2:	7d 42       	mov.b	#8,	r13	;r2 As==11
    76f4:	4e 43       	clr.b	r14		;
    76f6:	b0 12 5c 74 	call	#29788		;#0x745c

000076fa <.L35>:
  return b;
    76fa:	1c 41 02 00 	mov	2(r1),	r12	;

000076fe <.Loc.238.3>:
}
    76fe:	21 52       	add	#4,	r1	;r2 As==10
    7700:	30 41       	ret			

00007702 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    7702:	32 c2       	dint			

00007704 <.Loc.348.1>:
  asm volatile("nop");
    7704:	03 43       	nop			

00007706 <.Loc.349.1>:
}
    7706:	03 43       	nop			
    7708:	30 41       	ret			

0000770a <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    770a:	03 43       	nop			

0000770c <.Loc.356.1>:
  _enable_interrupts();
    770c:	32 d2       	eint			
    770e:	03 43       	nop			

00007710 <.Loc.357.1>:
}
    7710:	03 43       	nop			
    7712:	30 41       	ret			

00007714 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    7714:	b0 12 02 77 	call	#30466		;#0x7702
    7718:	b0 12 32 66 	call	#26162		;#0x6632

0000771c <.Loc.505.2>:
}
    771c:	03 43       	nop			
    771e:	30 41       	ret			

00007720 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    7720:	b0 12 52 66 	call	#26194		;#0x6652
    7724:	b0 12 0a 77 	call	#30474		;#0x770a

00007728 <.Loc.516.2>:
}
    7728:	03 43       	nop			
    772a:	30 41       	ret			

0000772c <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
    772c:	21 83       	decd	r1		;

0000772e <.LCFI0>:
    772e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007732 <.Loc.699.2>:

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
    7732:	4d 43       	clr.b	r13		;
    7734:	2c 41       	mov	@r1,	r12	;
    7736:	b0 12 24 6a 	call	#27172		;#0x6a24

0000773a <.Loc.700.2>:
}
    773a:	21 53       	incd	r1		;
    773c:	30 41       	ret			

0000773e <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    773e:	b0 12 a4 8a 	call	#35492		;#0x8aa4

00007742 <.Loc.59.3>:
}
    7742:	03 43       	nop			
    7744:	30 41       	ret			

00007746 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    7746:	21 83       	decd	r1		;

00007748 <.LCFI1>:
    7748:	81 4c 00 00 	mov	r12,	0(r1)	;

0000774c <.Loc.70.3>:

  spip->state = SPI_STOP;
    774c:	2c 41       	mov	@r1,	r12	;
    774e:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00007752 <.Loc.71.3>:
  spip->config = NULL;
    7752:	2c 41       	mov	@r1,	r12	;
    7754:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00007758 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    7758:	2c 41       	mov	@r1,	r12	;
    775a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

0000775e <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    775e:	03 43       	nop			
    7760:	21 53       	incd	r1		;
    7762:	30 41       	ret			

00007764 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    7764:	21 82       	sub	#4,	r1	;r2 As==10

00007766 <.LCFI2>:
    7766:	81 4c 02 00 	mov	r12,	2(r1)	;
    776a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000776e <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    776e:	b0 12 14 77 	call	#30484		;#0x7714

00007772 <.Loc.98.3>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    7772:	1c 41 02 00 	mov	2(r1),	r12	;
    7776:	ac 41 02 00 	mov	@r1,	2(r12)	;

0000777a <.Loc.99.3>:
  spi_lld_start(spip);
    777a:	1c 41 02 00 	mov	2(r1),	r12	;
    777e:	b0 12 68 8b 	call	#35688		;#0x8b68

00007782 <.Loc.100.3>:
  spip->state = SPI_READY;
    7782:	1c 41 02 00 	mov	2(r1),	r12	;
    7786:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000778a <.Loc.101.3>:
  osalSysUnlock();
    778a:	b0 12 20 77 	call	#30496		;#0x7720

0000778e <.Loc.102.3>:
}
    778e:	03 43       	nop			
    7790:	21 52       	add	#4,	r1	;r2 As==10
    7792:	30 41       	ret			

00007794 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
    7794:	21 83       	decd	r1		;

00007796 <.LCFI4>:
    7796:	81 4c 00 00 	mov	r12,	0(r1)	;

0000779a <.Loc.140.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    779a:	b0 12 14 77 	call	#30484		;#0x7714

0000779e <.Loc.142.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
    779e:	2c 41       	mov	@r1,	r12	;
    77a0:	b0 12 72 8c 	call	#35954		;#0x8c72

000077a4 <.Loc.143.3>:
  osalSysUnlock();
    77a4:	b0 12 20 77 	call	#30496		;#0x7720

000077a8 <.Loc.144.3>:
}
    77a8:	03 43       	nop			
    77aa:	21 53       	incd	r1		;
    77ac:	30 41       	ret			

000077ae <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
    77ae:	21 83       	decd	r1		;

000077b0 <.LCFI5>:
    77b0:	81 4c 00 00 	mov	r12,	0(r1)	;

000077b4 <.Loc.158.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    77b4:	b0 12 14 77 	call	#30484		;#0x7714

000077b8 <.Loc.160.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
    77b8:	2c 41       	mov	@r1,	r12	;
    77ba:	b0 12 d2 8c 	call	#36050		;#0x8cd2

000077be <.Loc.161.3>:
  osalSysUnlock();
    77be:	b0 12 20 77 	call	#30496		;#0x7720

000077c2 <.Loc.162.3>:
}
    77c2:	03 43       	nop			
    77c4:	21 53       	incd	r1		;
    77c6:	30 41       	ret			

000077c8 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
    77c8:	31 80 06 00 	sub	#6,	r1	;

000077cc <.LCFI12>:
    77cc:	81 4c 04 00 	mov	r12,	4(r1)	;
    77d0:	81 4d 02 00 	mov	r13,	2(r1)	;
    77d4:	81 4e 00 00 	mov	r14,	0(r1)	;

000077d8 <.Loc.345.3>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
    77d8:	b0 12 14 77 	call	#30484		;#0x7714

000077dc <.Loc.348.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
    77dc:	1c 41 04 00 	mov	4(r1),	r12	;
    77e0:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    77e4:	00 00 
    77e6:	2e 41       	mov	@r1,	r14	;
    77e8:	1d 41 02 00 	mov	2(r1),	r13	;
    77ec:	1c 41 04 00 	mov	4(r1),	r12	;
    77f0:	b0 12 30 8d 	call	#36144		;#0x8d30

000077f4 <.Loc.349.3>:
  (void) osalThreadSuspendS(&spip->thread);
    77f4:	1c 41 04 00 	mov	4(r1),	r12	;
    77f8:	2c 52       	add	#4,	r12	;r2 As==10
    77fa:	b0 12 2c 77 	call	#30508		;#0x772c

000077fe <.Loc.350.3>:
  osalSysUnlock();
    77fe:	b0 12 20 77 	call	#30496		;#0x7720

00007802 <.Loc.351.3>:
}
    7802:	03 43       	nop			
    7804:	31 50 06 00 	add	#6,	r1	;
    7808:	30 41       	ret			

0000780a <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    780a:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    780e:	5c 01 

00007810 <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    7810:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    7814:	60 01 

00007816 <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    7816:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    781a:	62 01 

0000781c <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    781c:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    7820:	64 01 

00007822 <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    7822:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00007826 <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    7826:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    782a:	68 01 

0000782c <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    782c:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    7830:	6c 01 

00007832 <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    7832:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00007836 <.Loc.87.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    7836:	b0 12 98 87 	call	#34712		;#0x8798

0000783a <.Loc.89.1>:
#endif
}
    783a:	03 43       	nop			
    783c:	30 41       	ret			

0000783e <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    783e:	03 43       	nop			
    7840:	30 41       	ret			

00007842 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7842:	03 43       	nop			
    7844:	30 41       	ret			

00007846 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7846:	b0 12 3e 78 	call	#30782		;#0x783e
    784a:	b0 12 74 66 	call	#26228		;#0x6674

0000784e <.Loc.527.2>:
}
    784e:	03 43       	nop			
    7850:	30 41       	ret			

00007852 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7852:	b0 12 96 66 	call	#26262		;#0x6696
    7856:	b0 12 42 78 	call	#30786		;#0x7842

0000785a <.Loc.538.2>:
}
    785a:	03 43       	nop			
    785c:	30 41       	ret			

0000785e <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    785e:	b0 12 24 68 	call	#26660		;#0x6824

00007862 <.Loc.597.2>:
}
    7862:	03 43       	nop			
    7864:	30 41       	ret			

00007866 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    7866:	bf 15       	pushm	#12,	r15	;16-bit words

00007868 <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    7868:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    786c:	b0 12 ba 66 	call	#26298		;#0x66ba

00007870 <.Loc.170.3>:
  
  osalSysLockFromISR();
    7870:	b0 12 46 78 	call	#30790		;#0x7846

00007874 <.Loc.171.3>:
  osalOsTimerHandlerI();
    7874:	b0 12 5e 78 	call	#30814		;#0x785e

00007878 <.Loc.172.3>:
  osalSysUnlockFromISR();
    7878:	b0 12 52 78 	call	#30802		;#0x7852

0000787c <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    787c:	b0 12 e8 66 	call	#26344		;#0x66e8
    7880:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7884:	b0 12 32 66 	call	#26162		;#0x6632
    7888:	b0 12 68 69 	call	#26984		;#0x6968
    788c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7890:	0c 93       	cmp	#0,	r12	;r3 As==00
    7892:	02 24       	jz	$+6      	;abs 0x7898

00007894 <.Loc.174.3>:
    7894:	b0 12 84 69 	call	#27012		;#0x6984

00007898 <.L7>:
    7898:	b0 12 52 66 	call	#26194		;#0x6652

0000789c <.Loc.175.3>:
}
    789c:	03 43       	nop			
    789e:	b4 17       	popm	#12,	r15	;16-bit words
    78a0:	00 13       	reti			

000078a2 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    78a2:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    78a6:	d2 03 

000078a8 <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    78a8:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    78ac:	c2 03 

000078ae <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    78ae:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

000078b2 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    78b2:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    78b6:	c0 03 

000078b8 <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    78b8:	03 43       	nop			
    78ba:	30 41       	ret			

000078bc <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    78bc:	03 43       	nop			
    78be:	30 41       	ret			

000078c0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    78c0:	03 43       	nop			
    78c2:	30 41       	ret			

000078c4 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    78c4:	b0 12 bc 78 	call	#30908		;#0x78bc
    78c8:	b0 12 74 66 	call	#26228		;#0x6674

000078cc <.Loc.527.2>:
}
    78cc:	03 43       	nop			
    78ce:	30 41       	ret			

000078d0 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    78d0:	b0 12 96 66 	call	#26262		;#0x6696
    78d4:	b0 12 c0 78 	call	#30912		;#0x78c0

000078d8 <.Loc.538.2>:
}
    78d8:	03 43       	nop			
    78da:	30 41       	ret			

000078dc <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    78dc:	0a 15       	pushm	#1,	r10	;16-bit words

000078de <.LCFI0>:
    78de:	31 80 06 00 	sub	#6,	r1	;

000078e2 <.LCFI1>:
    78e2:	81 4c 04 00 	mov	r12,	4(r1)	;
    78e6:	81 4d 00 00 	mov	r13,	0(r1)	;
    78ea:	81 4e 02 00 	mov	r14,	2(r1)	;

000078ee <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    78ee:	1c 41 04 00 	mov	4(r1),	r12	;
    78f2:	1d 4c 02 00 	mov	2(r12),	r13	;
    78f6:	2c 4c       	mov	@r12,	r12	;
    78f8:	2a 41       	mov	@r1,	r10	;
    78fa:	0a dc       	bis	r12,	r10	;
    78fc:	1b 41 02 00 	mov	2(r1),	r11	;
    7900:	0b dd       	bis	r13,	r11	;
    7902:	1c 41 04 00 	mov	4(r1),	r12	;
    7906:	8c 4a 00 00 	mov	r10,	0(r12)	;
    790a:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000790e <.Loc.829.2>:
  if (esp->cb != NULL) {
    790e:	1c 41 04 00 	mov	4(r1),	r12	;
    7912:	1c 4c 04 00 	mov	4(r12),	r12	;
    7916:	0c 93       	cmp	#0,	r12	;r3 As==00
    7918:	07 24       	jz	$+16     	;abs 0x7928

0000791a <.Loc.830.2>:
    esp->cb(esp);
    791a:	1c 41 04 00 	mov	4(r1),	r12	;
    791e:	1d 4c 04 00 	mov	4(r12),	r13	;
    7922:	1c 41 04 00 	mov	4(r1),	r12	;
    7926:	8d 12       	call	r13		;

00007928 <.L7>:
  }
}
    7928:	03 43       	nop			
    792a:	31 50 06 00 	add	#6,	r1	;
    792e:	0a 17       	popm	#1,	r10	;16-bit words
    7930:	30 41       	ret			

00007932 <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    7932:	21 83       	decd	r1		;

00007934 <.LCFI2>:
    7934:	81 4c 00 00 	mov	r12,	0(r1)	;

00007938 <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    7938:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    793c:	2c 91       	cmp	@r1,	r12	;
    793e:	02 28       	jnc	$+6      	;abs 0x7944

00007940 <.Loc.108.3>:
    return 0x00;
    7940:	4c 43       	clr.b	r12		;
    7942:	ec 3c       	jmp	$+474    	;abs 0x7b1c

00007944 <.L9>:
  else if (frac < 715)
    7944:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    7948:	2c 91       	cmp	@r1,	r12	;
    794a:	02 28       	jnc	$+6      	;abs 0x7950

0000794c <.Loc.110.3>:
    return 0x01;
    794c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    794e:	e6 3c       	jmp	$+462    	;abs 0x7b1c

00007950 <.L11>:
  else if (frac < 835)
    7950:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    7954:	2c 91       	cmp	@r1,	r12	;
    7956:	02 28       	jnc	$+6      	;abs 0x795c

00007958 <.Loc.112.3>:
    return 0x02;
    7958:	6c 43       	mov.b	#2,	r12	;r3 As==10
    795a:	e0 3c       	jmp	$+450    	;abs 0x7b1c

0000795c <.L12>:
  else if (frac < 1001)
    795c:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    7960:	2c 91       	cmp	@r1,	r12	;
    7962:	02 28       	jnc	$+6      	;abs 0x7968

00007964 <.Loc.114.3>:
    return 0x04;
    7964:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7966:	da 3c       	jmp	$+438    	;abs 0x7b1c

00007968 <.L13>:
  else if (frac < 1252)
    7968:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    796c:	2c 91       	cmp	@r1,	r12	;
    796e:	02 28       	jnc	$+6      	;abs 0x7974

00007970 <.Loc.116.3>:
    return 0x08;
    7970:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7972:	d4 3c       	jmp	$+426    	;abs 0x7b1c

00007974 <.L14>:
  else if (frac < 1430)
    7974:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    7978:	2c 91       	cmp	@r1,	r12	;
    797a:	03 28       	jnc	$+8      	;abs 0x7982

0000797c <.Loc.118.3>:
    return 0x10;
    797c:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7980:	cd 3c       	jmp	$+412    	;abs 0x7b1c

00007982 <.L15>:
  else if (frac < 1670)
    7982:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    7986:	2c 91       	cmp	@r1,	r12	;
    7988:	03 28       	jnc	$+8      	;abs 0x7990

0000798a <.Loc.120.3>:
    return 0x20;
    798a:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    798e:	c6 3c       	jmp	$+398    	;abs 0x7b1c

00007990 <.L16>:
  else if (frac < 2147)
    7990:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    7994:	2c 91       	cmp	@r1,	r12	;
    7996:	03 28       	jnc	$+8      	;abs 0x799e

00007998 <.Loc.122.3>:
    return 0x11;
    7998:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    799c:	bf 3c       	jmp	$+384    	;abs 0x7b1c

0000799e <.L17>:
  else if (frac < 2224)
    799e:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    79a2:	2c 91       	cmp	@r1,	r12	;
    79a4:	03 28       	jnc	$+8      	;abs 0x79ac

000079a6 <.Loc.124.3>:
    return 0x21;
    79a6:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    79aa:	b8 3c       	jmp	$+370    	;abs 0x7b1c

000079ac <.L18>:
  else if (frac < 2503)
    79ac:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    79b0:	2c 91       	cmp	@r1,	r12	;
    79b2:	03 28       	jnc	$+8      	;abs 0x79ba

000079b4 <.Loc.126.3>:
    return 0x22;
    79b4:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    79b8:	b1 3c       	jmp	$+356    	;abs 0x7b1c

000079ba <.L19>:
  else if (frac < 3000)
    79ba:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    79be:	2c 91       	cmp	@r1,	r12	;
    79c0:	03 28       	jnc	$+8      	;abs 0x79c8

000079c2 <.Loc.128.3>:
    return 0x44;
    79c2:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    79c6:	aa 3c       	jmp	$+342    	;abs 0x7b1c

000079c8 <.L20>:
  else if (frac < 3335)
    79c8:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    79cc:	2c 91       	cmp	@r1,	r12	;
    79ce:	03 28       	jnc	$+8      	;abs 0x79d6

000079d0 <.Loc.130.3>:
    return 0x25;
    79d0:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    79d4:	a3 3c       	jmp	$+328    	;abs 0x7b1c

000079d6 <.L21>:
  else if (frac < 3575)
    79d6:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    79da:	2c 91       	cmp	@r1,	r12	;
    79dc:	03 28       	jnc	$+8      	;abs 0x79e4

000079de <.Loc.132.3>:
    return 0x49;
    79de:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    79e2:	9c 3c       	jmp	$+314    	;abs 0x7b1c

000079e4 <.L22>:
  else if (frac < 3753)
    79e4:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    79e8:	2c 91       	cmp	@r1,	r12	;
    79ea:	03 28       	jnc	$+8      	;abs 0x79f2

000079ec <.Loc.134.3>:
    return 0x4A;
    79ec:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    79f0:	95 3c       	jmp	$+300    	;abs 0x7b1c

000079f2 <.L23>:
  else if (frac < 4003)
    79f2:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    79f6:	2c 91       	cmp	@r1,	r12	;
    79f8:	03 28       	jnc	$+8      	;abs 0x7a00

000079fa <.Loc.136.3>:
    return 0x52;
    79fa:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    79fe:	8e 3c       	jmp	$+286    	;abs 0x7b1c

00007a00 <.L24>:
  else if (frac < 4286)
    7a00:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    7a04:	2c 91       	cmp	@r1,	r12	;
    7a06:	03 28       	jnc	$+8      	;abs 0x7a0e

00007a08 <.Loc.138.3>:
    return 0x92;
    7a08:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    7a0c:	87 3c       	jmp	$+272    	;abs 0x7b1c

00007a0e <.L25>:
  else if (frac < 4378)
    7a0e:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    7a12:	2c 91       	cmp	@r1,	r12	;
    7a14:	03 28       	jnc	$+8      	;abs 0x7a1c

00007a16 <.Loc.140.3>:
    return 0x53;
    7a16:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    7a1a:	80 3c       	jmp	$+258    	;abs 0x7b1c

00007a1c <.L26>:
  else if (frac < 5002)
    7a1c:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    7a20:	2c 91       	cmp	@r1,	r12	;
    7a22:	03 28       	jnc	$+8      	;abs 0x7a2a

00007a24 <.Loc.142.3>:
    return 0x55;
    7a24:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    7a28:	79 3c       	jmp	$+244    	;abs 0x7b1c

00007a2a <.L27>:
  else if (frac < 5715)
    7a2a:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    7a2e:	2c 91       	cmp	@r1,	r12	;
    7a30:	03 28       	jnc	$+8      	;abs 0x7a38

00007a32 <.Loc.144.3>:
    return 0xAA;
    7a32:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    7a36:	72 3c       	jmp	$+230    	;abs 0x7b1c

00007a38 <.L28>:
  else if (frac < 6003)
    7a38:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    7a3c:	2c 91       	cmp	@r1,	r12	;
    7a3e:	03 28       	jnc	$+8      	;abs 0x7a46

00007a40 <.Loc.146.3>:
    return 0x6B;
    7a40:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    7a44:	6b 3c       	jmp	$+216    	;abs 0x7b1c

00007a46 <.L29>:
  else if (frac < 6254)
    7a46:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    7a4a:	2c 91       	cmp	@r1,	r12	;
    7a4c:	03 28       	jnc	$+8      	;abs 0x7a54

00007a4e <.Loc.148.3>:
    return 0xAD;
    7a4e:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    7a52:	64 3c       	jmp	$+202    	;abs 0x7b1c

00007a54 <.L30>:
  else if (frac < 6432)
    7a54:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    7a58:	2c 91       	cmp	@r1,	r12	;
    7a5a:	03 28       	jnc	$+8      	;abs 0x7a62

00007a5c <.Loc.150.3>:
    return 0xB5;
    7a5c:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    7a60:	5d 3c       	jmp	$+188    	;abs 0x7b1c

00007a62 <.L31>:
  else if (frac < 6667)
    7a62:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    7a66:	2c 91       	cmp	@r1,	r12	;
    7a68:	03 28       	jnc	$+8      	;abs 0x7a70

00007a6a <.Loc.152.3>:
    return 0xB6;
    7a6a:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    7a6e:	56 3c       	jmp	$+174    	;abs 0x7b1c

00007a70 <.L32>:
  else if (frac < 7001)
    7a70:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    7a74:	2c 91       	cmp	@r1,	r12	;
    7a76:	03 28       	jnc	$+8      	;abs 0x7a7e

00007a78 <.Loc.154.3>:
    return 0xD6;
    7a78:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    7a7c:	4f 3c       	jmp	$+160    	;abs 0x7b1c

00007a7e <.L33>:
  else if (frac < 7147)
    7a7e:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    7a82:	2c 91       	cmp	@r1,	r12	;
    7a84:	03 28       	jnc	$+8      	;abs 0x7a8c

00007a86 <.Loc.156.3>:
    return 0xB7;
    7a86:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    7a8a:	48 3c       	jmp	$+146    	;abs 0x7b1c

00007a8c <.L34>:
  else if (frac < 7503)
    7a8c:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    7a90:	2c 91       	cmp	@r1,	r12	;
    7a92:	03 28       	jnc	$+8      	;abs 0x7a9a

00007a94 <.Loc.158.3>:
    return 0xBB;
    7a94:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    7a98:	41 3c       	jmp	$+132    	;abs 0x7b1c

00007a9a <.L35>:
  else if (frac < 7861)
    7a9a:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    7a9e:	2c 91       	cmp	@r1,	r12	;
    7aa0:	03 28       	jnc	$+8      	;abs 0x7aa8

00007aa2 <.Loc.160.3>:
    return 0xDD;
    7aa2:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    7aa6:	3a 3c       	jmp	$+118    	;abs 0x7b1c

00007aa8 <.L36>:
  else if (frac < 8004)
    7aa8:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    7aac:	2c 91       	cmp	@r1,	r12	;
    7aae:	03 28       	jnc	$+8      	;abs 0x7ab6

00007ab0 <.Loc.162.3>:
    return 0xED;
    7ab0:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    7ab4:	33 3c       	jmp	$+104    	;abs 0x7b1c

00007ab6 <.L37>:
  else if (frac < 8333)
    7ab6:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    7aba:	2c 91       	cmp	@r1,	r12	;
    7abc:	03 28       	jnc	$+8      	;abs 0x7ac4

00007abe <.Loc.164.3>:
    return 0xEE;
    7abe:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    7ac2:	2c 3c       	jmp	$+90     	;abs 0x7b1c

00007ac4 <.L38>:
  else if (frac < 8464)
    7ac4:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    7ac8:	2c 91       	cmp	@r1,	r12	;
    7aca:	03 28       	jnc	$+8      	;abs 0x7ad2

00007acc <.Loc.166.3>:
    return 0xBF;
    7acc:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    7ad0:	25 3c       	jmp	$+76     	;abs 0x7b1c

00007ad2 <.L39>:
  else if (frac < 8572)
    7ad2:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    7ad6:	2c 91       	cmp	@r1,	r12	;
    7ad8:	03 28       	jnc	$+8      	;abs 0x7ae0

00007ada <.Loc.168.3>:
    return 0xDF;
    7ada:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    7ade:	1e 3c       	jmp	$+62     	;abs 0x7b1c

00007ae0 <.L40>:
  else if (frac < 8751)
    7ae0:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    7ae4:	2c 91       	cmp	@r1,	r12	;
    7ae6:	03 28       	jnc	$+8      	;abs 0x7aee

00007ae8 <.Loc.170.3>:
    return 0xEF;
    7ae8:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    7aec:	17 3c       	jmp	$+48     	;abs 0x7b1c

00007aee <.L41>:
  else if (frac < 9004)
    7aee:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    7af2:	2c 91       	cmp	@r1,	r12	;
    7af4:	03 28       	jnc	$+8      	;abs 0x7afc

00007af6 <.Loc.172.3>:
    return 0xF7;
    7af6:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    7afa:	10 3c       	jmp	$+34     	;abs 0x7b1c

00007afc <.L42>:
  else if (frac < 9170)
    7afc:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    7b00:	2c 91       	cmp	@r1,	r12	;
    7b02:	03 28       	jnc	$+8      	;abs 0x7b0a

00007b04 <.Loc.174.3>:
    return 0xFB;
    7b04:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    7b08:	09 3c       	jmp	$+20     	;abs 0x7b1c

00007b0a <.L43>:
  else if (frac < 9288)
    7b0a:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    7b0e:	2c 91       	cmp	@r1,	r12	;
    7b10:	03 28       	jnc	$+8      	;abs 0x7b18

00007b12 <.Loc.176.3>:
    return 0xFD;
    7b12:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    7b16:	02 3c       	jmp	$+6      	;abs 0x7b1c

00007b18 <.L44>:
  else
    return 0xFE;
    7b18:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00007b1c <.L10>:
}
    7b1c:	21 53       	incd	r1		;
    7b1e:	30 41       	ret			

00007b20 <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    7b20:	0a 15       	pushm	#1,	r10	;16-bit words

00007b22 <.LCFI3>:
    7b22:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00007b26 <.LCFI4>:
    7b26:	81 4c 04 00 	mov	r12,	4(r1)	;
    7b2a:	81 4d 06 00 	mov	r13,	6(r1)	;
    7b2e:	81 4e 00 00 	mov	r14,	0(r1)	;
    7b32:	81 4f 02 00 	mov	r15,	2(r1)	;

00007b36 <.Loc.191.3>:

  uint16_t n = freq / baud;
    7b36:	1e 41 04 00 	mov	4(r1),	r14	;
    7b3a:	1f 41 06 00 	mov	6(r1),	r15	;
    7b3e:	2c 41       	mov	@r1,	r12	;
    7b40:	1d 41 02 00 	mov	2(r1),	r13	;
    7b44:	b0 12 fe c1 	call	#49662		;#0xc1fe
    7b48:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007b4c <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    7b4c:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7b50:	0c 4e       	mov	r14,	r12	;
    7b52:	0d 43       	clr	r13		;
    7b54:	1e 41 04 00 	mov	4(r1),	r14	;
    7b58:	1f 41 06 00 	mov	6(r1),	r15	;
    7b5c:	b0 12 b6 cc 	call	#52406		;#0xccb6
    7b60:	0e 4c       	mov	r12,	r14	;
    7b62:	0f 4d       	mov	r13,	r15	;
    7b64:	2c 41       	mov	@r1,	r12	;

00007b66 <L0>:
    7b66:	1d 41 02 00 	mov	2(r1),	r13	;
    7b6a:	0c 8e       	sub	r14,	r12	;
    7b6c:	0d 7f       	subc	r15,	r13	;
    7b6e:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    7b72:	4f 43       	clr.b	r15		;
    7b74:	b0 12 b6 cc 	call	#52406		;#0xccb6
    7b78:	1e 41 04 00 	mov	4(r1),	r14	;
    7b7c:	1f 41 06 00 	mov	6(r1),	r15	;
    7b80:	b0 12 fe c1 	call	#49662		;#0xc1fe
    7b84:	81 4c 08 00 	mov	r12,	8(r1)	;

00007b88 <.Loc.194.3>:
  if (n > 16) {
    7b88:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7b8c:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7b90:	19 2c       	jc	$+52     	;abs 0x7bc4

00007b92 <.Loc.195.3>:
    while (n > 16) {
    7b92:	03 3c       	jmp	$+8      	;abs 0x7b9a

00007b94 <.L48>:
      n -= 16;
    7b94:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    7b98:	0a 00 

00007b9a <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    7b9a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7b9e:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7ba2:	f8 2b       	jnc	$-14     	;abs 0x7b94

00007ba4 <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    7ba4:	1c 41 08 00 	mov	8(r1),	r12	;
    7ba8:	b0 12 32 79 	call	#31026		;#0x7932
    7bac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7bb0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7bb4:	0a 4c       	mov	r12,	r10	;
    7bb6:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7bba:	b0 12 30 c2 	call	#49712		;#0xc230
    7bbe:	0c da       	bis	r10,	r12	;
    7bc0:	1c d3       	bis	#1,	r12	;r3 As==01
    7bc2:	08 3c       	jmp	$+18     	;abs 0x7bd4

00007bc4 <.L46>:
  }
  return UCBRS(frac) << 8;
    7bc4:	1c 41 08 00 	mov	8(r1),	r12	;
    7bc8:	b0 12 32 79 	call	#31026		;#0x7932
    7bcc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7bd0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

00007bd4 <.L49>:
}
    7bd4:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7bd8:	0a 17       	popm	#1,	r10	;16-bit words
    7bda:	30 41       	ret			

00007bdc <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    7bdc:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00007be0 <L0>:
    7be0:	81 4c 04 00 	mov	r12,	4(r1)	;
    7be4:	81 4d 06 00 	mov	r13,	6(r1)	;
    7be8:	81 4e 00 00 	mov	r14,	0(r1)	;
    7bec:	81 4f 02 00 	mov	r15,	2(r1)	;

00007bf0 <.Loc.212.3>:
  uint16_t n = freq / baud;
    7bf0:	1e 41 04 00 	mov	4(r1),	r14	;
    7bf4:	1f 41 06 00 	mov	6(r1),	r15	;
    7bf8:	2c 41       	mov	@r1,	r12	;
    7bfa:	1d 41 02 00 	mov	2(r1),	r13	;
    7bfe:	b0 12 fe c1 	call	#49662		;#0xc1fe
    7c02:	81 4c 08 00 	mov	r12,	8(r1)	;

00007c06 <.Loc.213.3>:
  if (n > 16) {
    7c06:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7c0a:	1c 91 08 00 	cmp	8(r1),	r12	;
    7c0e:	05 2c       	jc	$+12     	;abs 0x7c1a

00007c10 <.Loc.214.3>:
    return n >> 4;
    7c10:	1c 41 08 00 	mov	8(r1),	r12	;
    7c14:	b0 12 2e c3 	call	#49966		;#0xc32e
    7c18:	02 3c       	jmp	$+6      	;abs 0x7c1e

00007c1a <.L51>:
  }
  return n;
    7c1a:	1c 41 08 00 	mov	8(r1),	r12	;

00007c1e <.L52>:
}
    7c1e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    7c22:	30 41       	ret			

00007c24 <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    7c24:	21 83       	decd	r1		;

00007c26 <L0>:
    7c26:	81 4c 00 00 	mov	r12,	0(r1)	;

00007c2a <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7c2a:	2c 41       	mov	@r1,	r12	;
    7c2c:	1d 4c 02 00 	mov	2(r12),	r13	;
    7c30:	2c 4c       	mov	@r12,	r12	;
    7c32:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    7c36:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7c3a:	b0 12 dc 7b 	call	#31708		;#0x7bdc
    7c3e:	82 4c c6 05 	mov	r12,	&0x05c6	;

00007c42 <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7c42:	2c 41       	mov	@r1,	r12	;
    7c44:	1d 4c 02 00 	mov	2(r12),	r13	;
    7c48:	2c 4c       	mov	@r12,	r12	;
    7c4a:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    7c4e:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7c52:	b0 12 20 7b 	call	#31520		;#0x7b20
    7c56:	82 4c c8 05 	mov	r12,	&0x05c8	;

00007c5a <.Loc.223.3>:
  UCA0STATW = 0;
    7c5a:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

00007c5e <.Loc.224.3>:
  UCA0ABCTL = 0;
    7c5e:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

00007c62 <.Loc.225.3>:
  UCA0IRCTL = 0;
    7c62:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

00007c66 <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    7c66:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    7c6a:	c0 05 

00007c6c <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    7c6c:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

00007c70 <.Loc.230.3>:
}
    7c70:	03 43       	nop			
    7c72:	21 53       	incd	r1		;
    7c74:	30 41       	ret			

00007c76 <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    7c76:	21 83       	decd	r1		;

00007c78 <.LCFI7>:
    7c78:	81 4c 00 00 	mov	r12,	0(r1)	;

00007c7c <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    7c7c:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7c80:	2c d3       	bis	#2,	r12	;r3 As==10
    7c82:	82 4c da 05 	mov	r12,	&0x05da	;

00007c86 <.Loc.280.3>:
}
    7c86:	03 43       	nop			
    7c88:	21 53       	incd	r1		;
    7c8a:	30 41       	ret			

00007c8c <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    7c8c:	31 82       	sub	#8,	r1	;r2 As==11

00007c8e <.LCFI8>:
    7c8e:	81 4c 02 00 	mov	r12,	2(r1)	;
    7c92:	81 4d 00 00 	mov	r13,	0(r1)	;

00007c96 <.Loc.314.3>:
  eventflags_t sts = 0;
    7c96:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7c9a:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00007c9e <.Loc.316.3>:

  if (sra & UCOE)
    7c9e:	1c 41 02 00 	mov	2(r1),	r12	;
    7ca2:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    7ca6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ca8:	05 24       	jz	$+12     	;abs 0x7cb4

00007caa <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    7caa:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    7cae:	04 00 
    7cb0:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007cb4 <.L56>:
  if (sra & UCPE)
    7cb4:	1c 41 02 00 	mov	2(r1),	r12	;
    7cb8:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7cbc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7cbe:	05 24       	jz	$+12     	;abs 0x7cca

00007cc0 <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    7cc0:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    7cc4:	04 00 
    7cc6:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007cca <.L57>:
  if (sra & UCFE)
    7cca:	1c 41 02 00 	mov	2(r1),	r12	;
    7cce:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    7cd2:	0c 93       	cmp	#0,	r12	;r3 As==00
    7cd4:	05 24       	jz	$+12     	;abs 0x7ce0

00007cd6 <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    7cd6:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    7cda:	04 00 
    7cdc:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007ce0 <.L58>:
  osalSysLockFromISR();
    7ce0:	b0 12 c4 78 	call	#30916		;#0x78c4

00007ce4 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    7ce4:	2c 41       	mov	@r1,	r12	;
    7ce6:	2c 53       	incd	r12		;
    7ce8:	1d 41 04 00 	mov	4(r1),	r13	;
    7cec:	1e 41 06 00 	mov	6(r1),	r14	;
    7cf0:	b0 12 dc 78 	call	#30940		;#0x78dc

00007cf4 <.Loc.324.3>:
  osalSysUnlockFromISR();
    7cf4:	b0 12 d0 78 	call	#30928		;#0x78d0

00007cf8 <.Loc.325.3>:
}
    7cf8:	03 43       	nop			
    7cfa:	31 52       	add	#8,	r1	;r2 As==11
    7cfc:	30 41       	ret			

00007cfe <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    7cfe:	bf 15       	pushm	#12,	r15	;16-bit words

00007d00 <.LCFI9>:
    7d00:	21 83       	decd	r1		;

00007d02 <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    7d02:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    7d06:	b0 12 ba 66 	call	#26298		;#0x66ba

00007d0a <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    7d0a:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    7d0e:	2c 92       	cmp	#4,	r12	;r2 As==10
    7d10:	1e 24       	jz	$+62     	;abs 0x7d4e
    7d12:	3c 92       	cmp	#8,	r12	;r2 As==11
    7d14:	40 24       	jz	$+130    	;abs 0x7d96
    7d16:	2c 93       	cmp	#2,	r12	;r3 As==10
    7d18:	01 24       	jz	$+4      	;abs 0x7d1c

00007d1a <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    7d1a:	60 3c       	jmp	$+194    	;abs 0x7ddc

00007d1c <.L63>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    7d1c:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7d20:	6c f2       	and.b	#4,	r12	;r2 As==10
    7d22:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d24:	06 24       	jz	$+14     	;abs 0x7d32

00007d26 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    7d26:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7d2a:	3d 40 88 5b 	mov	#23432,	r13	;#0x5b88
    7d2e:	b0 12 8c 7c 	call	#31884		;#0x7c8c

00007d32 <.L64>:

    /* Data available */
    osalSysLockFromISR();
    7d32:	b0 12 c4 78 	call	#30916		;#0x78c4

00007d36 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    7d36:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    7d3a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7d3e:	4d 4c       	mov.b	r12,	r13	;
    7d40:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    7d44:	b0 12 7e 76 	call	#30334		;#0x767e

00007d48 <.Loc.352.3>:
    osalSysUnlockFromISR();
    7d48:	b0 12 d0 78 	call	#30928		;#0x78d0

00007d4c <.Loc.353.3>:
    break;
    7d4c:	47 3c       	jmp	$+144    	;abs 0x7ddc

00007d4e <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    7d4e:	b0 12 c4 78 	call	#30916		;#0x78c4

00007d52 <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    7d52:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    7d56:	b0 12 d0 76 	call	#30416		;#0x76d0
    7d5a:	81 4c 00 00 	mov	r12,	0(r1)	;

00007d5e <.Loc.360.3>:
    if (b < Q_OK) {
    7d5e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7d62:	13 34       	jge	$+40     	;abs 0x7d8a

00007d64 <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    7d64:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7d66:	4e 43       	clr.b	r14		;
    7d68:	3c 40 8a 5b 	mov	#23434,	r12	;#0x5b8a
    7d6c:	b0 12 dc 78 	call	#30940		;#0x78dc

00007d70 <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    7d70:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7d74:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    7d78:	3c d2       	bis	#8,	r12	;r2 As==11
    7d7a:	82 4c da 05 	mov	r12,	&0x05da	;

00007d7e <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    7d7e:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    7d82:	2c d3       	bis	#2,	r12	;r3 As==10
    7d84:	82 4c dc 05 	mov	r12,	&0x05dc	;
    7d88:	03 3c       	jmp	$+8      	;abs 0x7d90

00007d8a <.L66>:
    }
    else
      UCA0TXBUF = b;
    7d8a:	2c 41       	mov	@r1,	r12	;
    7d8c:	82 4c ce 05 	mov	r12,	&0x05ce	;

00007d90 <.L67>:
    osalSysUnlockFromISR();
    7d90:	b0 12 d0 78 	call	#30928		;#0x78d0

00007d94 <.Loc.368.3>:
    break;
    7d94:	23 3c       	jmp	$+72     	;abs 0x7ddc

00007d96 <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    7d96:	b0 12 c4 78 	call	#30916		;#0x78c4

00007d9a <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    7d9a:	1d 42 ac 5b 	mov	&0x5bac,r13	;0x5bac
    7d9e:	1c 42 ae 5b 	mov	&0x5bae,r12	;0x5bae
    7da2:	0d 9c       	cmp	r12,	r13	;
    7da4:	06 20       	jnz	$+14     	;abs 0x7db2

00007da6 <.Loc.374.3>:
    7da6:	1c 42 a6 5b 	mov	&0x5ba6,r12	;0x5ba6
    7daa:	0c 93       	cmp	#0,	r12	;r3 As==00
    7dac:	02 24       	jz	$+6      	;abs 0x7db2

00007dae <.Loc.374.3>:
    7dae:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7db0:	01 3c       	jmp	$+4      	;abs 0x7db4

00007db2 <.L68>:
    7db2:	4c 43       	clr.b	r12		;

00007db4 <.L69>:
    7db4:	5c f3       	and.b	#1,	r12	;r3 As==01
    7db6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7dba:	0c 93       	cmp	#0,	r12	;r3 As==00
    7dbc:	07 24       	jz	$+16     	;abs 0x7dcc

00007dbe <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    7dbe:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    7dc2:	4e 43       	clr.b	r14		;
    7dc4:	3c 40 8a 5b 	mov	#23434,	r12	;#0x5b8a
    7dc8:	b0 12 dc 78 	call	#30940		;#0x78dc

00007dcc <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    7dcc:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7dd0:	3c c2       	bic	#8,	r12	;r2 As==11
    7dd2:	82 4c da 05 	mov	r12,	&0x05da	;

00007dd6 <.Loc.377.3>:
    osalSysUnlockFromISR();
    7dd6:	b0 12 d0 78 	call	#30928		;#0x78d0

00007dda <.Loc.378.3>:
    break;
    7dda:	03 43       	nop			

00007ddc <.L65>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    7ddc:	b0 12 e8 66 	call	#26344		;#0x66e8
    7de0:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7de4:	b0 12 32 66 	call	#26162		;#0x6632
    7de8:	b0 12 68 69 	call	#26984		;#0x6968
    7dec:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7df0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7df2:	02 24       	jz	$+6      	;abs 0x7df8

00007df4 <.Loc.385.3>:
    7df4:	b0 12 84 69 	call	#27012		;#0x6984

00007df8 <.L71>:
    7df8:	b0 12 52 66 	call	#26194		;#0x6652

00007dfc <.Loc.386.3>:
}
    7dfc:	03 43       	nop			
    7dfe:	21 53       	incd	r1		;
    7e00:	b4 17       	popm	#12,	r15	;16-bit words
    7e02:	00 13       	reti			

00007e04 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    7e04:	3e 40 76 7c 	mov	#31862,	r14	;#0x7c76
    7e08:	4d 43       	clr.b	r13		;
    7e0a:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88

00007e0e <L0>:
    7e0e:	b0 12 e0 75 	call	#30176		;#0x75e0

00007e12 <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    7e12:	03 43       	nop			
    7e14:	30 41       	ret			

00007e16 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7e16:	21 82       	sub	#4,	r1	;r2 As==10

00007e18 <.LCFI11>:
    7e18:	81 4c 02 00 	mov	r12,	2(r1)	;
    7e1c:	81 4d 00 00 	mov	r13,	0(r1)	;

00007e20 <.Loc.603.3>:

  if (config == NULL) {
    7e20:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7e24:	03 20       	jnz	$+8      	;abs 0x7e2c

00007e26 <.Loc.604.3>:
    config = &default_config;
    7e26:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7e2a:	00 00 

00007e2c <.L74>:
  }

  if (sdp->state == SD_STOP) {
    7e2c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e30:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7e34:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7e36:	07 20       	jnz	$+16     	;abs 0x7e46

00007e38 <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    7e38:	b1 90 88 5b 	cmp	#23432,	2(r1)	;#0x5b88
    7e3c:	02 00 
    7e3e:	03 20       	jnz	$+8      	;abs 0x7e46

00007e40 <.Loc.610.3>:
      usart0_init(config);
    7e40:	2c 41       	mov	@r1,	r12	;
    7e42:	b0 12 24 7c 	call	#31780		;#0x7c24

00007e46 <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    7e46:	03 43       	nop			
    7e48:	21 52       	add	#4,	r1	;r2 As==10
    7e4a:	30 41       	ret			

00007e4c <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    7e4c:	bf 15       	pushm	#12,	r15	;16-bit words

00007e4e <.LCFI0>:
    7e4e:	21 82       	sub	#4,	r1	;r2 As==10

00007e50 <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7e50:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    7e54:	b0 12 ba 66 	call	#26298		;#0x66ba

00007e58 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    7e58:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    7e5c:	12 c3       	clrc			
    7e5e:	0c 10       	rrc	r12		;
    7e60:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e64:	4d 4c       	mov.b	r12,	r13	;
    7e66:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7e68:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007e6c <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    7e6c:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7e70:	0c 5c       	rla	r12		;
    7e72:	3c 50 d4 5b 	add	#23508,	r12	;#0x5bd4
    7e76:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007e7a <.Loc.80.1>:
  if (cb != NULL) {
    7e7a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7e7e:	02 24       	jz	$+6      	;abs 0x7e84

00007e80 <.Loc.81.1>:
    (*cb)();
    7e80:	2c 41       	mov	@r1,	r12	;
    7e82:	8c 12       	call	r12		;

00007e84 <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7e84:	b0 12 e8 66 	call	#26344		;#0x66e8
    7e88:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7e8c:	b0 12 32 66 	call	#26162		;#0x6632
    7e90:	b0 12 68 69 	call	#26984		;#0x6968
    7e94:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e98:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e9a:	02 24       	jz	$+6      	;abs 0x7ea0

00007e9c <.Loc.84.1>:
    7e9c:	b0 12 84 69 	call	#27012		;#0x6984

00007ea0 <.L3>:
    7ea0:	b0 12 52 66 	call	#26194		;#0x6652

00007ea4 <.Loc.85.1>:
}
    7ea4:	03 43       	nop			
    7ea6:	21 52       	add	#4,	r1	;r2 As==10
    7ea8:	b4 17       	popm	#12,	r15	;16-bit words
    7eaa:	00 13       	reti			

00007eac <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    7eac:	bf 15       	pushm	#12,	r15	;16-bit words

00007eae <.LCFI2>:
    7eae:	21 82       	sub	#4,	r1	;r2 As==10

00007eb0 <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7eb0:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    7eb4:	b0 12 ba 66 	call	#26298		;#0x66ba

00007eb8 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    7eb8:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    7ebc:	12 c3       	clrc			
    7ebe:	0c 10       	rrc	r12		;
    7ec0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7ec4:	4d 4c       	mov.b	r12,	r13	;
    7ec6:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7ec8:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007ecc <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    7ecc:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7ed0:	3c 52       	add	#8,	r12	;r2 As==11
    7ed2:	0c 5c       	rla	r12		;
    7ed4:	3c 50 d4 5b 	add	#23508,	r12	;#0x5bd4
    7ed8:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007edc <.Loc.98.1>:
  if (cb != NULL) {
    7edc:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7ee0:	02 24       	jz	$+6      	;abs 0x7ee6

00007ee2 <.Loc.99.1>:
    (*cb)();
    7ee2:	2c 41       	mov	@r1,	r12	;
    7ee4:	8c 12       	call	r12		;

00007ee6 <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7ee6:	b0 12 e8 66 	call	#26344		;#0x66e8
    7eea:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7eee:	b0 12 32 66 	call	#26162		;#0x6632
    7ef2:	b0 12 68 69 	call	#26984		;#0x6968
    7ef6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7efa:	0c 93       	cmp	#0,	r12	;r3 As==00
    7efc:	02 24       	jz	$+6      	;abs 0x7f02

00007efe <.Loc.102.1>:
    7efe:	b0 12 84 69 	call	#27012		;#0x6984

00007f02 <.L6>:
    7f02:	b0 12 52 66 	call	#26194		;#0x6652

00007f06 <.Loc.103.1>:
}
    7f06:	03 43       	nop			
    7f08:	21 52       	add	#4,	r1	;r2 As==10
    7f0a:	b4 17       	popm	#12,	r15	;16-bit words
    7f0c:	00 13       	reti			

00007f0e <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    7f0e:	bf 15       	pushm	#12,	r15	;16-bit words

00007f10 <.LCFI4>:
    7f10:	21 82       	sub	#4,	r1	;r2 As==10

00007f12 <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7f12:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    7f16:	b0 12 ba 66 	call	#26298		;#0x66ba

00007f1a <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    7f1a:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    7f1e:	12 c3       	clrc			
    7f20:	0c 10       	rrc	r12		;
    7f22:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7f26:	4d 4c       	mov.b	r12,	r13	;
    7f28:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7f2a:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007f2e <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    7f2e:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7f32:	3c 50 10 00 	add	#16,	r12	;#0x0010
    7f36:	0c 5c       	rla	r12		;
    7f38:	3c 50 d4 5b 	add	#23508,	r12	;#0x5bd4
    7f3c:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007f40 <.Loc.117.1>:
  if (cb != NULL) {
    7f40:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7f44:	02 24       	jz	$+6      	;abs 0x7f4a

00007f46 <.Loc.118.1>:
    (*cb)();
    7f46:	2c 41       	mov	@r1,	r12	;
    7f48:	8c 12       	call	r12		;

00007f4a <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7f4a:	b0 12 e8 66 	call	#26344		;#0x66e8
    7f4e:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7f52:	b0 12 32 66 	call	#26162		;#0x6632
    7f56:	b0 12 68 69 	call	#26984		;#0x6968
    7f5a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7f5e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f60:	02 24       	jz	$+6      	;abs 0x7f66

00007f62 <.Loc.121.1>:
    7f62:	b0 12 84 69 	call	#27012		;#0x6984

00007f66 <.L9>:
    7f66:	b0 12 52 66 	call	#26194		;#0x6652

00007f6a <.Loc.122.1>:
}
    7f6a:	03 43       	nop			
    7f6c:	21 52       	add	#4,	r1	;r2 As==10
    7f6e:	b4 17       	popm	#12,	r15	;16-bit words
    7f70:	00 13       	reti			

00007f72 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    7f72:	bf 15       	pushm	#12,	r15	;16-bit words

00007f74 <.LCFI6>:
    7f74:	21 82       	sub	#4,	r1	;r2 As==10

00007f76 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7f76:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    7f7a:	b0 12 ba 66 	call	#26298		;#0x66ba

00007f7e <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    7f7e:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    7f82:	12 c3       	clrc			
    7f84:	0c 10       	rrc	r12		;
    7f86:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7f8a:	4d 4c       	mov.b	r12,	r13	;
    7f8c:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7f8e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007f92 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    7f92:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7f96:	3c 50 18 00 	add	#24,	r12	;#0x0018
    7f9a:	0c 5c       	rla	r12		;
    7f9c:	3c 50 d4 5b 	add	#23508,	r12	;#0x5bd4
    7fa0:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007fa4 <.Loc.135.1>:
  if (cb != NULL) {
    7fa4:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7fa8:	02 24       	jz	$+6      	;abs 0x7fae

00007faa <.Loc.136.1>:
    (*cb)();
    7faa:	2c 41       	mov	@r1,	r12	;
    7fac:	8c 12       	call	r12		;

00007fae <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7fae:	b0 12 e8 66 	call	#26344		;#0x66e8
    7fb2:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    7fb6:	b0 12 32 66 	call	#26162		;#0x6632
    7fba:	b0 12 68 69 	call	#26984		;#0x6968
    7fbe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7fc2:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fc4:	02 24       	jz	$+6      	;abs 0x7fca

00007fc6 <.Loc.139.1>:
    7fc6:	b0 12 84 69 	call	#27012		;#0x6984

00007fca <.L12>:
    7fca:	b0 12 52 66 	call	#26194		;#0x6652

00007fce <.Loc.140.1>:
}
    7fce:	03 43       	nop			
    7fd0:	21 52       	add	#4,	r1	;r2 As==10
    7fd2:	b4 17       	popm	#12,	r15	;16-bit words
    7fd4:	00 13       	reti			

00007fd6 <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    7fd6:	21 83       	decd	r1		;

00007fd8 <.LCFI8>:
    7fd8:	81 4c 00 00 	mov	r12,	0(r1)	;

00007fdc <.Loc.309.1>:

  PAOUT = config->porta.out;
    7fdc:	2c 41       	mov	@r1,	r12	;
    7fde:	2c 4c       	mov	@r12,	r12	;
    7fe0:	82 4c 02 02 	mov	r12,	&0x0202	;

00007fe4 <.Loc.310.1>:
  PADIR = config->porta.dir;
    7fe4:	2c 41       	mov	@r1,	r12	;
    7fe6:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fea:	82 4c 04 02 	mov	r12,	&0x0204	;

00007fee <.Loc.311.1>:
  PAREN = config->porta.ren;
    7fee:	2c 41       	mov	@r1,	r12	;
    7ff0:	1c 4c 04 00 	mov	4(r12),	r12	;
    7ff4:	82 4c 06 02 	mov	r12,	&0x0206	;

00007ff8 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7ff8:	2c 41       	mov	@r1,	r12	;
    7ffa:	1c 4c 06 00 	mov	6(r12),	r12	;
    7ffe:	82 4c 0a 02 	mov	r12,	&0x020a	;

00008002 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    8002:	2c 41       	mov	@r1,	r12	;
    8004:	1c 4c 08 00 	mov	8(r12),	r12	;
    8008:	82 4c 0c 02 	mov	r12,	&0x020c	;

0000800c <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    800c:	2c 41       	mov	@r1,	r12	;
    800e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8012:	82 4c 22 02 	mov	r12,	&0x0222	;

00008016 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    8016:	2c 41       	mov	@r1,	r12	;
    8018:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    801c:	82 4c 24 02 	mov	r12,	&0x0224	;

00008020 <.Loc.317.1>:
  PBREN = config->portb.ren;
    8020:	2c 41       	mov	@r1,	r12	;
    8022:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    8026:	82 4c 26 02 	mov	r12,	&0x0226	;

0000802a <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    802a:	2c 41       	mov	@r1,	r12	;
    802c:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    8030:	82 4c 2a 02 	mov	r12,	&0x022a	;

00008034 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    8034:	2c 41       	mov	@r1,	r12	;
    8036:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    803a:	82 4c 2c 02 	mov	r12,	&0x022c	;

0000803e <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    803e:	2c 41       	mov	@r1,	r12	;
    8040:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    8044:	82 4c 22 03 	mov	r12,	&0x0322	;

00008048 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    8048:	2c 41       	mov	@r1,	r12	;
    804a:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    804e:	82 4c 24 03 	mov	r12,	&0x0324	;

00008052 <.Loc.351.1>:
  PJREN = config->portj.ren;
    8052:	2c 41       	mov	@r1,	r12	;
    8054:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    8058:	82 4c 26 03 	mov	r12,	&0x0326	;

0000805c <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    805c:	2c 41       	mov	@r1,	r12	;
    805e:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    8062:	82 4c 2a 03 	mov	r12,	&0x032a	;

00008066 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    8066:	2c 41       	mov	@r1,	r12	;
    8068:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    806c:	82 4c 2c 03 	mov	r12,	&0x032c	;

00008070 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    8070:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    8074:	1c c3       	bic	#1,	r12	;r3 As==01
    8076:	82 4c 30 01 	mov	r12,	&0x0130	;

0000807a <.Loc.356.1>:
}
    807a:	03 43       	nop			
    807c:	21 53       	incd	r1		;
    807e:	30 41       	ret			

00008080 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    8080:	31 80 06 00 	sub	#6,	r1	;

00008084 <.LCFI9>:
    8084:	81 4c 04 00 	mov	r12,	4(r1)	;
    8088:	81 4d 02 00 	mov	r13,	2(r1)	;
    808c:	81 4e 00 00 	mov	r14,	0(r1)	;

00008090 <.Loc.374.1>:
  
  switch (mode) {
    8090:	2c 41       	mov	@r1,	r12	;
    8092:	2c 92       	cmp	#4,	r12	;r2 As==10
    8094:	b5 24       	jz	$+364    	;abs 0x8200
    8096:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8098:	0d 9c       	cmp	r12,	r13	;
    809a:	0a 28       	jnc	$+22     	;abs 0x80b0
    809c:	1c 93       	cmp	#1,	r12	;r3 As==01
    809e:	5f 24       	jz	$+192    	;abs 0x815e
    80a0:	1c 93       	cmp	#1,	r12	;r3 As==01
    80a2:	16 28       	jnc	$+46     	;abs 0x80d0
    80a4:	2c 93       	cmp	#2,	r12	;r3 As==10
    80a6:	14 24       	jz	$+42     	;abs 0x80d0
    80a8:	3c 90 03 00 	cmp	#3,	r12	;
    80ac:	58 24       	jz	$+178    	;abs 0x815e

000080ae <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    80ae:	bd 3d       	jmp	$+892    	;abs 0x842a

000080b0 <.L17>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    80b0:	3c 92       	cmp	#8,	r12	;r2 As==11
    80b2:	32 25       	jz	$+614    	;abs 0x8318
    80b4:	7d 42       	mov.b	#8,	r13	;r2 As==11
    80b6:	0d 9c       	cmp	r12,	r13	;
    80b8:	04 28       	jnc	$+10     	;abs 0x80c2
    80ba:	3c 90 06 00 	cmp	#6,	r12	;
    80be:	f2 24       	jz	$+486    	;abs 0x82a4

000080c0 <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    80c0:	b4 3d       	jmp	$+874    	;abs 0x842a

000080c2 <.L21>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    80c2:	3c 90 09 00 	cmp	#9,	r12	;
    80c6:	56 25       	jz	$+686    	;abs 0x8374
    80c8:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    80cc:	81 25       	jz	$+772    	;abs 0x83d0

000080ce <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    80ce:	ad 3d       	jmp	$+860    	;abs 0x842a

000080d0 <.L19>:
                           iomode_t mode) {
  
  switch (mode) {
    case PAL_MODE_RESET:
    case PAL_MODE_INPUT:
      port->dir &= ~mask;
    80d0:	1c 41 04 00 	mov	4(r1),	r12	;
    80d4:	1d 4c 04 00 	mov	4(r12),	r13	;
    80d8:	1c 41 02 00 	mov	2(r1),	r12	;
    80dc:	3c e3       	inv	r12		;
    80de:	0d fc       	and	r12,	r13	;
    80e0:	1c 41 04 00 	mov	4(r1),	r12	;
    80e4:	8c 4d 04 00 	mov	r13,	4(r12)	;

000080e8 <.Loc.378.1>:
      port->ren &= ~mask;
    80e8:	1c 41 04 00 	mov	4(r1),	r12	;
    80ec:	1d 4c 08 00 	mov	8(r12),	r13	;
    80f0:	1c 41 02 00 	mov	2(r1),	r12	;
    80f4:	3c e3       	inv	r12		;
    80f6:	0d fc       	and	r12,	r13	;
    80f8:	1c 41 04 00 	mov	4(r1),	r12	;
    80fc:	8c 4d 08 00 	mov	r13,	8(r12)	;

00008100 <.Loc.379.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    8100:	1c 41 04 00 	mov	4(r1),	r12	;
    8104:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8108:	1c f1 02 00 	and	2(r1),	r12	;
    810c:	0c 93       	cmp	#0,	r12	;r3 As==00
    810e:	0e 24       	jz	$+30     	;abs 0x812c

00008110 <.Loc.379.1>:
    8110:	1c 41 04 00 	mov	4(r1),	r12	;
    8114:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8118:	1c f1 02 00 	and	2(r1),	r12	;
    811c:	0c 93       	cmp	#0,	r12	;r3 As==00
    811e:	06 24       	jz	$+14     	;abs 0x812c

00008120 <.Loc.380.1>:
        port->selc = mask;
    8120:	1c 41 04 00 	mov	4(r1),	r12	;
    8124:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    8128:	16 00 

0000812a <.Loc.385.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    812a:	7f 3d       	jmp	$+768    	;abs 0x842a

0000812c <.L25>:
      port->dir &= ~mask;
      port->ren &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    812c:	1c 41 04 00 	mov	4(r1),	r12	;
    8130:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    8134:	1c 41 02 00 	mov	2(r1),	r12	;
    8138:	3c e3       	inv	r12		;
    813a:	0d fc       	and	r12,	r13	;
    813c:	1c 41 04 00 	mov	4(r1),	r12	;
    8140:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00008144 <.Loc.383.1>:
        port->sel1 &= ~mask;
    8144:	1c 41 04 00 	mov	4(r1),	r12	;
    8148:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    814c:	1c 41 02 00 	mov	2(r1),	r12	;
    8150:	3c e3       	inv	r12		;
    8152:	0d fc       	and	r12,	r13	;
    8154:	1c 41 04 00 	mov	4(r1),	r12	;
    8158:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000815c <.Loc.385.1>:
      }
      break;
    815c:	66 3d       	jmp	$+718    	;abs 0x842a

0000815e <.L18>:
    case PAL_MODE_UNCONNECTED:
    case PAL_MODE_INPUT_PULLUP:
      port->dir &= ~mask;
    815e:	1c 41 04 00 	mov	4(r1),	r12	;
    8162:	1d 4c 04 00 	mov	4(r12),	r13	;
    8166:	1c 41 02 00 	mov	2(r1),	r12	;
    816a:	3c e3       	inv	r12		;
    816c:	0d fc       	and	r12,	r13	;
    816e:	1c 41 04 00 	mov	4(r1),	r12	;
    8172:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008176 <.Loc.389.1>:
      port->ren |= mask;
    8176:	1c 41 04 00 	mov	4(r1),	r12	;
    817a:	1c 4c 08 00 	mov	8(r12),	r12	;
    817e:	0d 4c       	mov	r12,	r13	;
    8180:	1d d1 02 00 	bis	2(r1),	r13	;
    8184:	1c 41 04 00 	mov	4(r1),	r12	;
    8188:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000818c <.Loc.390.1>:
      port->out |= mask;
    818c:	1c 41 04 00 	mov	4(r1),	r12	;
    8190:	1c 4c 02 00 	mov	2(r12),	r12	;
    8194:	0d 4c       	mov	r12,	r13	;
    8196:	1d d1 02 00 	bis	2(r1),	r13	;
    819a:	1c 41 04 00 	mov	4(r1),	r12	;
    819e:	8c 4d 02 00 	mov	r13,	2(r12)	;

000081a2 <.Loc.391.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    81a2:	1c 41 04 00 	mov	4(r1),	r12	;
    81a6:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    81aa:	1c f1 02 00 	and	2(r1),	r12	;
    81ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    81b0:	0e 24       	jz	$+30     	;abs 0x81ce

000081b2 <.Loc.391.1>:
    81b2:	1c 41 04 00 	mov	4(r1),	r12	;
    81b6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    81ba:	1c f1 02 00 	and	2(r1),	r12	;
    81be:	0c 93       	cmp	#0,	r12	;r3 As==00
    81c0:	06 24       	jz	$+14     	;abs 0x81ce

000081c2 <.Loc.392.1>:
        port->selc = mask;
    81c2:	1c 41 04 00 	mov	4(r1),	r12	;
    81c6:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    81ca:	16 00 

000081cc <.Loc.397.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    81cc:	2e 3d       	jmp	$+606    	;abs 0x842a

000081ce <.L27>:
      port->ren |= mask;
      port->out |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    81ce:	1c 41 04 00 	mov	4(r1),	r12	;
    81d2:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    81d6:	1c 41 02 00 	mov	2(r1),	r12	;
    81da:	3c e3       	inv	r12		;
    81dc:	0d fc       	and	r12,	r13	;
    81de:	1c 41 04 00 	mov	4(r1),	r12	;
    81e2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000081e6 <.Loc.395.1>:
        port->sel1 &= ~mask;
    81e6:	1c 41 04 00 	mov	4(r1),	r12	;
    81ea:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    81ee:	1c 41 02 00 	mov	2(r1),	r12	;
    81f2:	3c e3       	inv	r12		;
    81f4:	0d fc       	and	r12,	r13	;
    81f6:	1c 41 04 00 	mov	4(r1),	r12	;
    81fa:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000081fe <.Loc.397.1>:
      }
      break;
    81fe:	15 3d       	jmp	$+556    	;abs 0x842a

00008200 <.L16>:
    case PAL_MODE_INPUT_PULLDOWN:
      port->dir &= ~mask;
    8200:	1c 41 04 00 	mov	4(r1),	r12	;
    8204:	1d 4c 04 00 	mov	4(r12),	r13	;
    8208:	1c 41 02 00 	mov	2(r1),	r12	;
    820c:	3c e3       	inv	r12		;
    820e:	0d fc       	and	r12,	r13	;
    8210:	1c 41 04 00 	mov	4(r1),	r12	;
    8214:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008218 <.Loc.400.1>:
      port->ren |= mask;
    8218:	1c 41 04 00 	mov	4(r1),	r12	;
    821c:	1c 4c 08 00 	mov	8(r12),	r12	;
    8220:	0d 4c       	mov	r12,	r13	;
    8222:	1d d1 02 00 	bis	2(r1),	r13	;
    8226:	1c 41 04 00 	mov	4(r1),	r12	;
    822a:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000822e <.Loc.401.1>:
      port->out &= ~mask;
    822e:	1c 41 04 00 	mov	4(r1),	r12	;
    8232:	1d 4c 02 00 	mov	2(r12),	r13	;
    8236:	1c 41 02 00 	mov	2(r1),	r12	;
    823a:	3c e3       	inv	r12		;
    823c:	0d fc       	and	r12,	r13	;
    823e:	1c 41 04 00 	mov	4(r1),	r12	;
    8242:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008246 <.Loc.402.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    8246:	1c 41 04 00 	mov	4(r1),	r12	;
    824a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    824e:	1c f1 02 00 	and	2(r1),	r12	;
    8252:	0c 93       	cmp	#0,	r12	;r3 As==00
    8254:	0e 24       	jz	$+30     	;abs 0x8272

00008256 <.Loc.402.1>:
    8256:	1c 41 04 00 	mov	4(r1),	r12	;
    825a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    825e:	1c f1 02 00 	and	2(r1),	r12	;
    8262:	0c 93       	cmp	#0,	r12	;r3 As==00
    8264:	06 24       	jz	$+14     	;abs 0x8272

00008266 <.Loc.403.1>:
        port->selc = mask;
    8266:	1c 41 04 00 	mov	4(r1),	r12	;
    826a:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    826e:	16 00 

00008270 <.Loc.408.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    8270:	dc 3c       	jmp	$+442    	;abs 0x842a

00008272 <.L29>:
      port->ren |= mask;
      port->out &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    8272:	1c 41 04 00 	mov	4(r1),	r12	;
    8276:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    827a:	1c 41 02 00 	mov	2(r1),	r12	;
    827e:	3c e3       	inv	r12		;
    8280:	0d fc       	and	r12,	r13	;
    8282:	1c 41 04 00 	mov	4(r1),	r12	;
    8286:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000828a <.Loc.406.1>:
        port->sel1 &= ~mask;
    828a:	1c 41 04 00 	mov	4(r1),	r12	;
    828e:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    8292:	1c 41 02 00 	mov	2(r1),	r12	;
    8296:	3c e3       	inv	r12		;
    8298:	0d fc       	and	r12,	r13	;
    829a:	1c 41 04 00 	mov	4(r1),	r12	;
    829e:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000082a2 <.Loc.408.1>:
      }
      break;
    82a2:	c3 3c       	jmp	$+392    	;abs 0x842a

000082a4 <.L22>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
    82a4:	1c 41 04 00 	mov	4(r1),	r12	;
    82a8:	1c 4c 04 00 	mov	4(r12),	r12	;
    82ac:	0d 4c       	mov	r12,	r13	;
    82ae:	1d d1 02 00 	bis	2(r1),	r13	;
    82b2:	1c 41 04 00 	mov	4(r1),	r12	;
    82b6:	8c 4d 04 00 	mov	r13,	4(r12)	;

000082ba <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    82ba:	1c 41 04 00 	mov	4(r1),	r12	;
    82be:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    82c2:	1c f1 02 00 	and	2(r1),	r12	;
    82c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    82c8:	0e 24       	jz	$+30     	;abs 0x82e6

000082ca <.Loc.411.1>:
    82ca:	1c 41 04 00 	mov	4(r1),	r12	;
    82ce:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    82d2:	1c f1 02 00 	and	2(r1),	r12	;
    82d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    82d8:	06 24       	jz	$+14     	;abs 0x82e6

000082da <.Loc.412.1>:
        port->selc = mask;
    82da:	1c 41 04 00 	mov	4(r1),	r12	;
    82de:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    82e2:	16 00 

000082e4 <.Loc.417.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    82e4:	a2 3c       	jmp	$+326    	;abs 0x842a

000082e6 <.L31>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    82e6:	1c 41 04 00 	mov	4(r1),	r12	;
    82ea:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    82ee:	1c 41 02 00 	mov	2(r1),	r12	;
    82f2:	3c e3       	inv	r12		;
    82f4:	0d fc       	and	r12,	r13	;
    82f6:	1c 41 04 00 	mov	4(r1),	r12	;
    82fa:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000082fe <.Loc.415.1>:
        port->sel1 &= ~mask;
    82fe:	1c 41 04 00 	mov	4(r1),	r12	;
    8302:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    8306:	1c 41 02 00 	mov	2(r1),	r12	;
    830a:	3c e3       	inv	r12		;
    830c:	0d fc       	and	r12,	r13	;
    830e:	1c 41 04 00 	mov	4(r1),	r12	;
    8312:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00008316 <.Loc.417.1>:
      }
      break;
    8316:	89 3c       	jmp	$+276    	;abs 0x842a

00008318 <.L20>:
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    8318:	1c 41 04 00 	mov	4(r1),	r12	;
    831c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8320:	1c f1 02 00 	and	2(r1),	r12	;
    8324:	0c 93       	cmp	#0,	r12	;r3 As==00
    8326:	0e 20       	jnz	$+30     	;abs 0x8344

00008328 <.Loc.419.1>:
    8328:	1c 41 04 00 	mov	4(r1),	r12	;
    832c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8330:	1c f1 02 00 	and	2(r1),	r12	;
    8334:	0c 93       	cmp	#0,	r12	;r3 As==00
    8336:	06 24       	jz	$+14     	;abs 0x8344

00008338 <.Loc.420.1>:
        port->selc = mask;
    8338:	1c 41 04 00 	mov	4(r1),	r12	;
    833c:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    8340:	16 00 

00008342 <.Loc.425.1>:
      else {
        port->sel0 |= mask;
        port->sel1 &= ~mask;
      }
      break;
    8342:	73 3c       	jmp	$+232    	;abs 0x842a

00008344 <.L33>:
      break;
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
        port->selc = mask;
      else {
        port->sel0 |= mask;
    8344:	1c 41 04 00 	mov	4(r1),	r12	;
    8348:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    834c:	0d 4c       	mov	r12,	r13	;
    834e:	1d d1 02 00 	bis	2(r1),	r13	;
    8352:	1c 41 04 00 	mov	4(r1),	r12	;
    8356:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000835a <.Loc.423.1>:
        port->sel1 &= ~mask;
    835a:	1c 41 04 00 	mov	4(r1),	r12	;
    835e:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    8362:	1c 41 02 00 	mov	2(r1),	r12	;
    8366:	3c e3       	inv	r12		;
    8368:	0d fc       	and	r12,	r13	;
    836a:	1c 41 04 00 	mov	4(r1),	r12	;
    836e:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00008372 <.Loc.425.1>:
      }
      break;
    8372:	5b 3c       	jmp	$+184    	;abs 0x842a

00008374 <.L23>:
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    8374:	1c 41 04 00 	mov	4(r1),	r12	;
    8378:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    837c:	1c f1 02 00 	and	2(r1),	r12	;
    8380:	0c 93       	cmp	#0,	r12	;r3 As==00
    8382:	0e 24       	jz	$+30     	;abs 0x83a0

00008384 <.Loc.427.1>:
    8384:	1c 41 04 00 	mov	4(r1),	r12	;
    8388:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    838c:	1c f1 02 00 	and	2(r1),	r12	;
    8390:	0c 93       	cmp	#0,	r12	;r3 As==00
    8392:	06 20       	jnz	$+14     	;abs 0x83a0

00008394 <.Loc.428.1>:
        port->selc = mask;
    8394:	1c 41 04 00 	mov	4(r1),	r12	;
    8398:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    839c:	16 00 

0000839e <.Loc.433.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 |= mask;
      }
      break;
    839e:	45 3c       	jmp	$+140    	;abs 0x842a

000083a0 <.L35>:
      break;
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    83a0:	1c 41 04 00 	mov	4(r1),	r12	;
    83a4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    83a8:	1c 41 02 00 	mov	2(r1),	r12	;
    83ac:	3c e3       	inv	r12		;
    83ae:	0d fc       	and	r12,	r13	;
    83b0:	1c 41 04 00 	mov	4(r1),	r12	;
    83b4:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000083b8 <.Loc.431.1>:
        port->sel1 |= mask;
    83b8:	1c 41 04 00 	mov	4(r1),	r12	;
    83bc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    83c0:	0d 4c       	mov	r12,	r13	;
    83c2:	1d d1 02 00 	bis	2(r1),	r13	;
    83c6:	1c 41 04 00 	mov	4(r1),	r12	;
    83ca:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000083ce <.Loc.433.1>:
      }
      break;
    83ce:	2d 3c       	jmp	$+92     	;abs 0x842a

000083d0 <.L24>:
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    83d0:	1c 41 04 00 	mov	4(r1),	r12	;
    83d4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    83d8:	1c f1 02 00 	and	2(r1),	r12	;
    83dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    83de:	0e 20       	jnz	$+30     	;abs 0x83fc

000083e0 <.Loc.435.1>:
    83e0:	1c 41 04 00 	mov	4(r1),	r12	;
    83e4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    83e8:	1c f1 02 00 	and	2(r1),	r12	;
    83ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    83ee:	06 20       	jnz	$+14     	;abs 0x83fc

000083f0 <.Loc.436.1>:
        port->selc = mask;
    83f0:	1c 41 04 00 	mov	4(r1),	r12	;
    83f4:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    83f8:	16 00 

000083fa <.Loc.441.1>:
      else {
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
    83fa:	16 3c       	jmp	$+46     	;abs 0x8428

000083fc <.L37>:
      break;
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 |= mask;
    83fc:	1c 41 04 00 	mov	4(r1),	r12	;
    8400:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8404:	0d 4c       	mov	r12,	r13	;
    8406:	1d d1 02 00 	bis	2(r1),	r13	;
    840a:	1c 41 04 00 	mov	4(r1),	r12	;
    840e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00008412 <.Loc.439.1>:
        port->sel1 |= mask;
    8412:	1c 41 04 00 	mov	4(r1),	r12	;
    8416:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    841a:	0d 4c       	mov	r12,	r13	;
    841c:	1d d1 02 00 	bis	2(r1),	r13	;
    8420:	1c 41 04 00 	mov	4(r1),	r12	;
    8424:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00008428 <.L39>:
      }
      break;
    8428:	03 43       	nop			

0000842a <.L15>:
  }
}
    842a:	03 43       	nop			
    842c:	31 50 06 00 	add	#6,	r1	;
    8430:	30 41       	ret			

00008432 <_pal_lld_enablepadevent>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    8432:	0a 15       	pushm	#1,	r10	;16-bit words

00008434 <.LCFI10>:
    8434:	31 82       	sub	#8,	r1	;r2 As==11

00008436 <.LCFI11>:
    8436:	81 4c 04 00 	mov	r12,	4(r1)	;
    843a:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    843e:	c1 4e 02 00 	mov.b	r14,	2(r1)	;
    8442:	81 4f 00 00 	mov	r15,	0(r1)	;

00008446 <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    8446:	1c 41 04 00 	mov	4(r1),	r12	;
    844a:	43 18 0c 11 	rpt #4 { rrax.w	r12		;
    844e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008452 <L0>:
    8452:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    8456:	4d 4c       	mov.b	r12,	r13	;
    8458:	7c 40 07 00 	mov.b	#7,	r12	;
    845c:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    8460:	02 2c       	jc	$+6      	;abs 0x8466

00008462 <.Loc.448.1>:
    8462:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8464:	01 3c       	jmp	$+4      	;abs 0x8468

00008466 <.L42>:
    8466:	5c 43       	mov.b	#1,	r12	;r3 As==01

00008468 <.L43>:
    8468:	4e 4d       	mov.b	r13,	r14	;
    846a:	4e 5c       	add.b	r12,	r14	;
    846c:	c1 4e 07 00 	mov.b	r14,	7(r1)	;

00008470 <.Loc.450.1>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    8470:	5c 41 07 00 	mov.b	7(r1),	r12	;
    8474:	3c 53       	add	#-1,	r12	;r3 As==11
    8476:	5d 41 03 00 	mov.b	3(r1),	r13	;
    847a:	7d f0 07 00 	and.b	#7,	r13	;
    847e:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    8482:	0c 5d       	add	r13,	r12	;
    8484:	0c 5c       	rla	r12		;
    8486:	3c 50 d4 5b 	add	#23508,	r12	;#0x5bd4
    848a:	ac 41 00 00 	mov	@r1,	0(r12)	;

0000848e <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    848e:	d1 93 02 00 	cmp.b	#1,	2(r1)	;r3 As==01
    8492:	11 20       	jnz	$+36     	;abs 0x84b6

00008494 <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    8494:	1c 41 04 00 	mov	4(r1),	r12	;
    8498:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    849c:	5d 41 03 00 	mov.b	3(r1),	r13	;
    84a0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    84a2:	b0 12 3e c2 	call	#49726		;#0xc23e
    84a6:	3c e3       	inv	r12		;
    84a8:	0d 4a       	mov	r10,	r13	;
    84aa:	0d fc       	and	r12,	r13	;
    84ac:	1c 41 04 00 	mov	4(r1),	r12	;
    84b0:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018
    84b4:	12 3c       	jmp	$+38     	;abs 0x84da

000084b6 <.L44>:
  }
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    84b6:	e1 93 02 00 	cmp.b	#2,	2(r1)	;r3 As==10
    84ba:	0f 20       	jnz	$+32     	;abs 0x84da

000084bc <.Loc.456.1>:
    port->ies |= (1 << pad);
    84bc:	1c 41 04 00 	mov	4(r1),	r12	;
    84c0:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    84c4:	5d 41 03 00 	mov.b	3(r1),	r13	;
    84c8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    84ca:	b0 12 3e c2 	call	#49726		;#0xc23e
    84ce:	0d 4a       	mov	r10,	r13	;
    84d0:	0d dc       	bis	r12,	r13	;
    84d2:	1c 41 04 00 	mov	4(r1),	r12	;
    84d6:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018

000084da <.L45>:
  }
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    84da:	c1 93 02 00 	cmp.b	#0,	2(r1)	;r3 As==00
    84de:	11 20       	jnz	$+36     	;abs 0x8502

000084e0 <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    84e0:	1c 41 04 00 	mov	4(r1),	r12	;
    84e4:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    84e8:	5d 41 03 00 	mov.b	3(r1),	r13	;
    84ec:	5c 43       	mov.b	#1,	r12	;r3 As==01
    84ee:	b0 12 3e c2 	call	#49726		;#0xc23e
    84f2:	3c e3       	inv	r12		;
    84f4:	0d 4a       	mov	r10,	r13	;
    84f6:	0d fc       	and	r12,	r13	;
    84f8:	1c 41 04 00 	mov	4(r1),	r12	;
    84fc:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008500 <.Loc.466.1>:
  }
  else {
    port->ifg &= ~(1 << pad);
    port->ie |= (1 << pad);
  }
}
    8500:	1f 3c       	jmp	$+64     	;abs 0x8540

00008502 <.L46>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    8502:	1c 41 04 00 	mov	4(r1),	r12	;
    8506:	1a 4c 1c 00 	mov	28(r12),r10	;0x0001c
    850a:	5d 41 03 00 	mov.b	3(r1),	r13	;
    850e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8510:	b0 12 3e c2 	call	#49726		;#0xc23e
    8514:	3c e3       	inv	r12		;
    8516:	0d 4a       	mov	r10,	r13	;
    8518:	0d fc       	and	r12,	r13	;
    851a:	1c 41 04 00 	mov	4(r1),	r12	;
    851e:	8c 4d 1c 00 	mov	r13,	28(r12)	; 0x001c

00008522 <.Loc.464.1>:
    port->ie |= (1 << pad);
    8522:	1c 41 04 00 	mov	4(r1),	r12	;
    8526:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    852a:	5d 41 03 00 	mov.b	3(r1),	r13	;
    852e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8530:	b0 12 3e c2 	call	#49726		;#0xc23e
    8534:	0d 4a       	mov	r10,	r13	;
    8536:	0d dc       	bis	r12,	r13	;
    8538:	1c 41 04 00 	mov	4(r1),	r12	;
    853c:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008540 <.L48>:
  }
}
    8540:	03 43       	nop			
    8542:	31 52       	add	#8,	r1	;r2 As==11
    8544:	0a 17       	popm	#1,	r10	;16-bit words
    8546:	30 41       	ret			

00008548 <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    8548:	0a 15       	pushm	#1,	r10	;16-bit words

0000854a <.LCFI12>:
    854a:	21 82       	sub	#4,	r1	;r2 As==10

0000854c <.LCFI13>:
    854c:	81 4c 02 00 	Address 0x000000000000854e is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000854e <L0>:
    854e:	02 00       	mova	@r0,	r2	;
    8550:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008554 <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    8554:	1c 41 02 00 	mov	2(r1),	r12	;
    8558:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    855c:	5d 41 01 00 	mov.b	1(r1),	r13	;
    8560:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8562:	b0 12 3e c2 	call	#49726		;#0xc23e
    8566:	3c e3       	inv	r12		;
    8568:	0d 4a       	mov	r10,	r13	;
    856a:	0d fc       	and	r12,	r13	;
    856c:	1c 41 02 00 	mov	2(r1),	r12	;
    8570:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00008574 <.Loc.471.1>:
}
    8574:	03 43       	nop			
    8576:	21 52       	add	#4,	r1	;r2 As==10
    8578:	0a 17       	popm	#1,	r10	;16-bit words
    857a:	30 41       	ret			

0000857c <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    857c:	03 43       	nop			
    857e:	30 41       	ret			

00008580 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    8580:	03 43       	nop			
    8582:	30 41       	ret			

00008584 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    8584:	b0 12 7c 85 	call	#34172		;#0x857c
    8588:	b0 12 74 66 	call	#26228		;#0x6674

0000858c <.Loc.527.2>:
}
    858c:	03 43       	nop			
    858e:	30 41       	ret			

00008590 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    8590:	b0 12 96 66 	call	#26262		;#0x6696
    8594:	b0 12 80 85 	call	#34176		;#0x8580

00008598 <.Loc.538.2>:
}
    8598:	03 43       	nop			
    859a:	30 41       	ret			

0000859c <osalSysGetStatusAndLockX>:
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
    859c:	b0 12 b2 68 	call	#26802		;#0x68b2

000085a0 <.Loc.556.2>:
}
    85a0:	30 41       	ret			

000085a2 <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
    85a2:	21 83       	decd	r1		;

000085a4 <.LCFI0>:
    85a4:	81 4c 00 00 	mov	r12,	0(r1)	;

000085a8 <.Loc.569.2>:

  chSysRestoreStatusX(sts);
    85a8:	2c 41       	mov	@r1,	r12	;
    85aa:	b0 12 ee 68 	call	#26862		;#0x68ee

000085ae <.Loc.570.2>:
}
    85ae:	03 43       	nop			
    85b0:	21 53       	incd	r1		;
    85b2:	30 41       	ret			

000085b4 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    85b4:	21 83       	decd	r1		;

000085b6 <.LCFI1>:
    85b6:	81 4c 00 00 	mov	r12,	0(r1)	;

000085ba <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    85ba:	2c 41       	mov	@r1,	r12	;
    85bc:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000085c0 <.Loc.768.2>:
}
    85c0:	03 43       	nop			
    85c2:	21 53       	incd	r1		;
    85c4:	30 41       	ret			

000085c6 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    85c6:	21 82       	sub	#4,	r1	;r2 As==10

000085c8 <.LCFI2>:
    85c8:	81 4c 02 00 	mov	r12,	2(r1)	;
    85cc:	81 4d 00 00 	mov	r13,	0(r1)	;

000085d0 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    85d0:	1c 41 02 00 	mov	2(r1),	r12	;
    85d4:	2d 41       	mov	@r1,	r13	;
    85d6:	b0 12 ac 6a 	call	#27308		;#0x6aac

000085da <.Loc.797.2>:
}
    85da:	21 52       	add	#4,	r1	;r2 As==10
    85dc:	30 41       	ret			

000085de <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    85de:	0a 15       	pushm	#1,	r10	;16-bit words

000085e0 <.LCFI3>:
    85e0:	21 82       	sub	#4,	r1	;r2 As==10

000085e2 <.LCFI4>:
    85e2:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    85e6:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

000085ea <.Loc.63.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    85ea:	5c 41 01 00 	mov.b	1(r1),	r12	;
    85ee:	12 c3       	clrc			
    85f0:	0c 10       	rrc	r12		;
    85f2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85f6:	0c 5c       	rla	r12		;
    85f8:	0d 4c       	mov	r12,	r13	;
    85fa:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    85fe:	81 4d 02 00 	mov	r13,	2(r1)	;

00008602 <.Loc.64.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    8602:	1c 41 02 00 	mov	2(r1),	r12	;
    8606:	2a 4c       	mov	@r12,	r10	;
    8608:	5c 41 01 00 	mov.b	1(r1),	r12	;
    860c:	5c f3       	and.b	#1,	r12	;r3 As==01
    860e:	0d 4c       	mov	r12,	r13	;
    8610:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    8614:	3c 40 00 ff 	mov	#65280,	r12	;#0xff00
    8618:	b0 12 46 c3 	call	#49990		;#0xc346
    861c:	0d 4a       	mov	r10,	r13	;
    861e:	0d fc       	and	r12,	r13	;
    8620:	1c 41 02 00 	mov	2(r1),	r12	;
    8624:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008628 <.Loc.65.3>:
  *ctl |= trigger << (8 * (index % 2));
    8628:	1c 41 02 00 	mov	2(r1),	r12	;
    862c:	2a 4c       	mov	@r12,	r10	;
    862e:	6c 41       	mov.b	@r1,	r12	;
    8630:	5d 41 01 00 	mov.b	1(r1),	r13	;
    8634:	5d f3       	and.b	#1,	r13	;r3 As==01
    8636:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    863a:	b0 12 3e c2 	call	#49726		;#0xc23e
    863e:	0d 4a       	mov	r10,	r13	;
    8640:	0d dc       	bis	r12,	r13	;
    8642:	1c 41 02 00 	mov	2(r1),	r12	;
    8646:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000864a <.Loc.66.3>:
}
    864a:	03 43       	nop			
    864c:	21 52       	add	#4,	r1	;r2 As==10
    864e:	0a 17       	popm	#1,	r10	;16-bit words
    8650:	30 41       	ret			

00008652 <init_request>:
static void init_request(const msp430x_dma_req_t * request, uint8_t index) {
    8652:	31 80 06 00 	sub	#6,	r1	;

00008656 <.LCFI5>:
    8656:	81 4c 02 00 	mov	r12,	2(r1)	;
    865a:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

0000865e <.Loc.69.3>:

  dma_trigger_set(index, request->trigger);
    865e:	1c 41 02 00 	mov	2(r1),	r12	;
    8662:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8666:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    866a:	4d 4c       	mov.b	r12,	r13	;
    866c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8670:	b0 12 de 85 	call	#34270		;#0x85de

00008674 <.Loc.70.3>:
  callbacks[index]          = request->callback;
    8674:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8678:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    867c:	3c 50 14 5c 	add	#23572,	r12	;#0x5c14
    8680:	1d 41 02 00 	mov	2(r1),	r13	;
    8684:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    8688:	00 00 
    868a:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    868e:	02 00 

00008690 <.Loc.71.3>:
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
    8690:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    8694:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8698:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    869c:	0e 4d       	mov	r13,	r14	;
    869e:	0e 5c       	add	r12,	r14	;
    86a0:	81 4e 04 00 	mov	r14,	4(r1)	;

000086a4 <.Loc.72.3>:
  ch->sa                    = (uintptr_t)request->source_addr;
    86a4:	1c 41 02 00 	mov	2(r1),	r12	;
    86a8:	2c 4c       	mov	@r12,	r12	;
    86aa:	0d 43       	clr	r13		;
    86ac:	1e 41 04 00 	mov	4(r1),	r14	;
    86b0:	8e 4c 02 00 	mov	r12,	2(r14)	;
    86b4:	8e 4d 04 00 	mov	r13,	4(r14)	;

000086b8 <.Loc.73.3>:
  ch->da                    = (uintptr_t)request->dest_addr;
    86b8:	1c 41 02 00 	mov	2(r1),	r12	;
    86bc:	1c 4c 02 00 	mov	2(r12),	r12	;
    86c0:	0d 43       	clr	r13		;
    86c2:	1e 41 04 00 	mov	4(r1),	r14	;
    86c6:	8e 4c 06 00 	mov	r12,	6(r14)	;
    86ca:	8e 4d 08 00 	mov	r13,	8(r14)	;

000086ce <.Loc.74.3>:
  ch->sz                    = request->size;
    86ce:	1c 41 02 00 	mov	2(r1),	r12	;
    86d2:	1d 4c 04 00 	mov	4(r12),	r13	;
    86d6:	1c 41 04 00 	mov	4(r1),	r12	;
    86da:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000086de <.Loc.75.3>:
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    86de:	1c 41 02 00 	mov	2(r1),	r12	;
    86e2:	1d 4c 08 00 	mov	8(r12),	r13	;
    86e6:	1c 41 02 00 	mov	2(r1),	r12	;
    86ea:	1c 4c 06 00 	mov	6(r12),	r12	;
    86ee:	0d dc       	bis	r12,	r13	;

000086f0 <.Loc.76.3>:
            request->transfer_mode;
    86f0:	1c 41 02 00 	mov	2(r1),	r12	;
    86f4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a

000086f8 <.Loc.75.3>:
  callbacks[index]          = request->callback;
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
  ch->sa                    = (uintptr_t)request->source_addr;
  ch->da                    = (uintptr_t)request->dest_addr;
  ch->sz                    = request->size;
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    86f8:	0c dd       	bis	r13,	r12	;
    86fa:	0d 4c       	mov	r12,	r13	;
    86fc:	3d d0 15 00 	bis	#21,	r13	;#0x0015
    8700:	1c 41 04 00 	mov	4(r1),	r12	;
    8704:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008708 <.Loc.77.3>:
            request->transfer_mode;
}
    8708:	03 43       	nop			
    870a:	31 50 06 00 	add	#6,	r1	;
    870e:	30 41       	ret			

00008710 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    8710:	bf 15       	pushm	#12,	r15	;16-bit words

00008712 <.LCFI6>:
    8712:	21 82       	sub	#4,	r1	;r2 As==10

00008714 <.LCFI7>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    8714:	d2 43 86 5b 	mov.b	#1,	&0x5b86	;r3 As==01
    8718:	b0 12 ba 66 	call	#26298		;#0x66ba

0000871c <.Loc.87.3>:

  index = (DMAIV >> 1) - 1;
    871c:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    8720:	12 c3       	clrc			
    8722:	0c 10       	rrc	r12		;
    8724:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8728:	4d 4c       	mov.b	r12,	r13	;
    872a:	7d 53       	add.b	#-1,	r13	;r3 As==11
    872c:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00008730 <.Loc.89.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    8730:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8732:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    8736:	1c 28       	jnc	$+58     	;abs 0x8770

00008738 <.LBB2>:
    osalSysLockFromISR();
    8738:	b0 12 84 85 	call	#34180		;#0x8584

0000873c <.Loc.91.3>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    873c:	4d 43       	clr.b	r13		;
    873e:	3c 40 20 5c 	mov	#23584,	r12	;#0x5c20
    8742:	b0 12 fe 6b 	call	#27646		;#0x6bfe

00008746 <.Loc.92.3>:
    osalSysUnlockFromISR();
    8746:	b0 12 90 85 	call	#34192		;#0x8590

0000874a <.Loc.94.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    874a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    874e:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    8752:	0d 4c       	mov	r12,	r13	;
    8754:	3d 50 14 5c 	add	#23572,	r13	;#0x5c14
    8758:	81 4d 00 00 	mov	r13,	0(r1)	;

0000875c <.Loc.97.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    875c:	2c 41       	mov	@r1,	r12	;
    875e:	2c 4c       	mov	@r12,	r12	;
    8760:	0c 93       	cmp	#0,	r12	;r3 As==00
    8762:	06 24       	jz	$+14     	;abs 0x8770

00008764 <.Loc.98.3>:
      cb->callback(cb->args);
    8764:	2c 41       	mov	@r1,	r12	;
    8766:	2d 4c       	mov	@r12,	r13	;
    8768:	2c 41       	mov	@r1,	r12	;
    876a:	1c 4c 02 00 	mov	2(r12),	r12	;
    876e:	8d 12       	call	r13		;

00008770 <.L14>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    8770:	b0 12 e8 66 	call	#26344		;#0x66e8
    8774:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    8778:	b0 12 32 66 	call	#26162		;#0x6632
    877c:	b0 12 68 69 	call	#26984		;#0x6968
    8780:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8784:	0c 93       	cmp	#0,	r12	;r3 As==00
    8786:	02 24       	jz	$+6      	;abs 0x878c

00008788 <.Loc.102.3>:
    8788:	b0 12 84 69 	call	#27012		;#0x6984

0000878c <.L15>:
    878c:	b0 12 52 66 	call	#26194		;#0x6652

00008790 <.Loc.103.3>:
}
    8790:	03 43       	nop			
    8792:	21 52       	add	#4,	r1	;r2 As==10
    8794:	b4 17       	popm	#12,	r15	;16-bit words
    8796:	00 13       	reti			

00008798 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    8798:	3c 40 20 5c 	mov	#23584,	r12	;#0x5c20
    879c:	b0 12 b4 85 	call	#34228		;#0x85b4

000087a0 <.Loc.116.3>:
}
    87a0:	03 43       	nop			
    87a2:	30 41       	ret			

000087a4 <dmaRequestS>:
 *          channel is available or the request times out. If semaphores are
 *          disabled, the calling thread will busy-wait instead of sleeping.
 *          
 *  @sclass
 */
int dmaRequestS(msp430x_dma_req_t * request, systime_t timeout) {
    87a4:	31 82       	sub	#8,	r1	;r2 As==11

000087a6 <.LCFI8>:
    87a6:	81 4c 02 00 	mov	r12,	2(r1)	;
    87aa:	81 4d 00 00 	mov	r13,	0(r1)	;

000087ae <.Loc.130.3>:
  
  osalDbgCheckClassS();
    87ae:	b0 12 36 67 	call	#26422		;#0x6736

000087b2 <.Loc.133.3>:
  
  /* Check if a DMA channel is available */
  if (queue_length >= MSP430X_DMA_CHANNELS) {
    87b2:	1d 42 22 5c 	mov	&0x5c22,r13	;0x5c22
    87b6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    87b8:	0c 9d       	cmp	r13,	r12	;
    87ba:	0c 2c       	jc	$+26     	;abs 0x87d4

000087bc <.LBB3>:
    msg_t queueresult = osalThreadEnqueueTimeoutS(&dma_queue, timeout);
    87bc:	2d 41       	mov	@r1,	r13	;
    87be:	3c 40 20 5c 	mov	#23584,	r12	;#0x5c20
    87c2:	b0 12 c6 85 	call	#34246		;#0x85c6
    87c6:	81 4c 04 00 	mov	r12,	4(r1)	;

000087ca <.Loc.135.3>:
    if (queueresult != MSG_OK)
    87ca:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    87ce:	02 24       	jz	$+6      	;abs 0x87d4

000087d0 <.Loc.136.3>:
      return -1;
    87d0:	3c 43       	mov	#-1,	r12	;r3 As==11
    87d2:	24 3c       	jmp	$+74     	;abs 0x881c

000087d4 <.L18>:
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
    87d4:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000087d8 <.Loc.141.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    87d8:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    87dc:	0e 3c       	jmp	$+30     	;abs 0x87fa

000087de <.L23>:
    if (!(dma_channels[i].ctl & DMAEN)) {
    87de:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    87e2:	1c 41 06 00 	mov	6(r1),	r12	;
    87e6:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    87ea:	0c 5d       	add	r13,	r12	;
    87ec:	2c 4c       	mov	@r12,	r12	;
    87ee:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    87f2:	0c 93       	cmp	#0,	r12	;r3 As==00
    87f4:	07 24       	jz	$+16     	;abs 0x8804

000087f6 <.Loc.141.3>:
      return -1;
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    87f6:	91 53 06 00 	inc	6(r1)		;

000087fa <.L20>:
    87fa:	6c 43       	mov.b	#2,	r12	;r3 As==10
    87fc:	1c 91 06 00 	cmp	6(r1),	r12	;
    8800:	ee 37       	jge	$-34     	;abs 0x87de
    8802:	01 3c       	jmp	$+4      	;abs 0x8806

00008804 <.L24>:
    if (!(dma_channels[i].ctl & DMAEN)) {
      break;
    8804:	03 43       	nop			

00008806 <.L22>:
    }
  }

  /* Make the request */
  init_request(request, i);
    8806:	1c 41 06 00 	mov	6(r1),	r12	;
    880a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    880e:	4d 4c       	mov.b	r12,	r13	;
    8810:	1c 41 02 00 	mov	2(r1),	r12	;
    8814:	b0 12 52 86 	call	#34386		;#0x8652

00008818 <.Loc.150.3>:
  
  return i;
    8818:	1c 41 06 00 	mov	6(r1),	r12	;

0000881c <.L19>:
}
    881c:	31 52       	add	#8,	r1	;r2 As==11
    881e:	30 41       	ret			

00008820 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
bool dmaAcquireI(msp430x_dma_ch_t * channel, uint8_t index) {
    8820:	21 82       	sub	#4,	r1	;r2 As==10

00008822 <.LCFI9>:
    8822:	81 4c 02 00 	mov	r12,	2(r1)	;

00008826 <L0>:
    8826:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

0000882a <.Loc.170.3>:
  
  osalDbgCheckClassI();
    882a:	b0 12 18 67 	call	#26392		;#0x6718

0000882e <.Loc.174.3>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_channels[index].ctl & DMADT_4) {
    882e:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    8832:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8836:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    883a:	0c 5d       	add	r13,	r12	;
    883c:	2c 4c       	mov	@r12,	r12	;
    883e:	3c f0 00 40 	and	#16384,	r12	;#0x4000
    8842:	0c 93       	cmp	#0,	r12	;r3 As==00
    8844:	02 24       	jz	$+6      	;abs 0x884a

00008846 <.Loc.175.3>:
    return true;
    8846:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8848:	46 3c       	jmp	$+142    	;abs 0x88d6

0000884a <.L26>:
  }

  /* Increment the DMA counter */
  queue_length++;
    884a:	1c 42 22 5c 	mov	&0x5c22,r12	;0x5c22
    884e:	1c 53       	inc	r12		;
    8850:	82 4c 22 5c 	mov	r12,	&0x5c22	;

00008854 <.Loc.181.3>:

  while (dma_channels[index].ctl & DMAEN)
    8854:	03 43       	nop			

00008856 <.L28>:
    8856:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    885a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    885e:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8862:	0c 5d       	add	r13,	r12	;
    8864:	2c 4c       	mov	@r12,	r12	;
    8866:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    886a:	0c 93       	cmp	#0,	r12	;r3 As==00
    886c:	f4 23       	jnz	$-22     	;abs 0x8856

0000886e <.Loc.185.3>:
    ;

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    886e:	4d 43       	clr.b	r13		;
    8870:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8874:	b0 12 de 85 	call	#34270		;#0x85de

00008878 <.Loc.186.3>:
  dma_channels[index].sz  = 0;
    8878:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    887c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8880:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8884:	0c 5d       	add	r13,	r12	;
    8886:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

0000888a <.Loc.187.3>:
  dma_channels[index].ctl = DMAEN | DMAABORT | DMADT_4;
    888a:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    888e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8892:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8896:	0c 5d       	add	r13,	r12	;
    8898:	bc 40 12 40 	mov	#16402,	0(r12)	;#0x4012
    889c:	00 00 

0000889e <.Loc.189.3>:

  channel->registers = dma_channels + index;
    889e:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    88a2:	5c 41 01 00 	mov.b	1(r1),	r12	;
    88a6:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    88aa:	0d 5c       	add	r12,	r13	;
    88ac:	1c 41 02 00 	mov	2(r1),	r12	;
    88b0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000088b4 <.Loc.190.3>:
  channel->index     = index;
    88b4:	1c 41 02 00 	mov	2(r1),	r12	;
    88b8:	dc 41 01 00 	mov.b	1(r1),	2(r12)	;
    88bc:	02 00 

000088be <.Loc.191.3>:
  channel->cb        = callbacks + index;
    88be:	5c 41 01 00 	mov.b	1(r1),	r12	;
    88c2:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    88c6:	0d 4c       	mov	r12,	r13	;
    88c8:	3d 50 14 5c 	add	#23572,	r13	;#0x5c14
    88cc:	1c 41 02 00 	mov	2(r1),	r12	;
    88d0:	8c 4d 04 00 	mov	r13,	4(r12)	;

000088d4 <.Loc.193.3>:
  
  return false;
    88d4:	4c 43       	clr.b	r12		;

000088d6 <.L27>:
}
    88d6:	21 52       	add	#4,	r1	;r2 As==10
    88d8:	30 41       	ret			

000088da <dmaTransfer>:
 * @pre     The channel must have been acquired using @p dmaAcquire().
 *
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 */
void dmaTransfer(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    88da:	21 82       	sub	#4,	r1	;r2 As==10

000088dc <L0>:
    88dc:	81 4c 02 00 	mov	r12,	2(r1)	;
    88e0:	81 4d 00 00 	mov	r13,	0(r1)	;

000088e4 <.Loc.205.3>:

  dma_trigger_set(channel->index, request->trigger);
    88e4:	1c 41 02 00 	mov	2(r1),	r12	;
    88e8:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    88ec:	2d 41       	mov	@r1,	r13	;
    88ee:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    88f2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    88f6:	b0 12 de 85 	call	#34270		;#0x85de

000088fa <.Loc.208.3>:
  /**(channel->ctl) = request->trigger;*/

  channel->cb->callback = request->callback.callback;
    88fa:	1c 41 02 00 	mov	2(r1),	r12	;
    88fe:	1c 4c 04 00 	mov	4(r12),	r12	;
    8902:	2d 41       	mov	@r1,	r13	;
    8904:	1d 4d 0e 00 	mov	14(r13),r13	;0x0000e
    8908:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000890c <.Loc.209.3>:
  channel->cb->args     = request->callback.args;
    890c:	1c 41 02 00 	mov	2(r1),	r12	;
    8910:	1c 4c 04 00 	mov	4(r12),	r12	;
    8914:	2d 41       	mov	@r1,	r13	;
    8916:	1d 4d 10 00 	mov	16(r13),r13	;0x00010
    891a:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000891e <.Loc.211.3>:

  channel->registers->ctl &= (~DMAEN);
    891e:	1c 41 02 00 	mov	2(r1),	r12	;
    8922:	2c 4c       	mov	@r12,	r12	;
    8924:	1d 41 02 00 	mov	2(r1),	r13	;
    8928:	2d 4d       	mov	@r13,	r13	;
    892a:	2d 4d       	mov	@r13,	r13	;
    892c:	3d f0 ef ff 	and	#65519,	r13	;#0xffef
    8930:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008934 <.Loc.212.3>:
  channel->registers->sa  = (uintptr_t)request->source_addr;
    8934:	1c 41 02 00 	mov	2(r1),	r12	;
    8938:	2e 4c       	mov	@r12,	r14	;
    893a:	2c 41       	mov	@r1,	r12	;
    893c:	2c 4c       	mov	@r12,	r12	;
    893e:	0d 43       	clr	r13		;
    8940:	8e 4c 02 00 	mov	r12,	2(r14)	;
    8944:	8e 4d 04 00 	mov	r13,	4(r14)	;

00008948 <.Loc.213.3>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    8948:	1c 41 02 00 	mov	2(r1),	r12	;
    894c:	2e 4c       	mov	@r12,	r14	;
    894e:	2c 41       	mov	@r1,	r12	;
    8950:	1c 4c 02 00 	mov	2(r12),	r12	;
    8954:	0d 43       	clr	r13		;
    8956:	8e 4c 06 00 	mov	r12,	6(r14)	;
    895a:	8e 4d 08 00 	mov	r13,	8(r14)	;

0000895e <.Loc.214.3>:
  channel->registers->sz  = request->size;
    895e:	1c 41 02 00 	mov	2(r1),	r12	;
    8962:	2c 4c       	mov	@r12,	r12	;
    8964:	2d 41       	mov	@r1,	r13	;
    8966:	1d 4d 04 00 	mov	4(r13),	r13	;
    896a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000896e <.Loc.215.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    896e:	1c 41 02 00 	mov	2(r1),	r12	;
    8972:	2c 4c       	mov	@r12,	r12	;
    8974:	2d 41       	mov	@r1,	r13	;
    8976:	1e 4d 08 00 	mov	8(r13),	r14	;
    897a:	2d 41       	mov	@r1,	r13	;
    897c:	1d 4d 06 00 	mov	6(r13),	r13	;
    8980:	0e dd       	bis	r13,	r14	;

00008982 <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    8982:	2d 41       	mov	@r1,	r13	;
    8984:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a

00008988 <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    8988:	0d de       	bis	r14,	r13	;

0000898a <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    898a:	3d d0 15 40 	bis	#16405,	r13	;#0x4015

0000898e <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    898e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008992 <.Loc.218.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
                            DMAREQ; /* repeated transfers */
}
    8992:	03 43       	nop			
    8994:	21 52       	add	#4,	r1	;r2 As==10
    8996:	30 41       	ret			

00008998 <dmaRelease>:
 *          pool. Trying to release an unallocated channel is an illegal
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquire().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaRelease(msp430x_dma_ch_t * channel) {
    8998:	21 82       	sub	#4,	r1	;r2 As==10

0000899a <.LCFI11>:
    899a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000899e <.Loc.232.3>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
    899e:	b0 12 9c 85 	call	#34204		;#0x859c
    89a2:	81 4c 02 00 	mov	r12,	2(r1)	;

000089a6 <.Loc.236.3>:
  osalDbgCheck(channel != NULL);

  /* Release the channel in an idle mode */
  channel->registers->ctl = DMAABORT;
    89a6:	2c 41       	mov	@r1,	r12	;
    89a8:	2c 4c       	mov	@r12,	r12	;
    89aa:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

000089ae <.Loc.239.3>:

  /* release the DMA counter */
  osalThreadDequeueAllI(&dma_queue, MSG_RESET);
    89ae:	3d 40 fe ff 	mov	#65534,	r13	;#0xfffe
    89b2:	3c 40 20 5c 	mov	#23584,	r12	;#0x5c20
    89b6:	b0 12 56 6c 	call	#27734		;#0x6c56

000089ba <.Loc.240.3>:
  queue_length = 0;
    89ba:	82 43 22 5c 	mov	#0,	&0x5c22	;r3 As==00

000089be <.Loc.241.3>:
  osalSysRestoreStatusX(sts);
    89be:	1c 41 02 00 	mov	2(r1),	r12	;
    89c2:	b0 12 a2 85 	call	#34210		;#0x85a2

000089c6 <.Loc.242.3>:
}
    89c6:	03 43       	nop			
    89c8:	21 52       	add	#4,	r1	;r2 As==10
    89ca:	30 41       	ret			

000089cc <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    89cc:	03 43       	nop			
    89ce:	30 41       	ret			

000089d0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    89d0:	03 43       	nop			
    89d2:	30 41       	ret			

000089d4 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    89d4:	b0 12 cc 89 	call	#35276		;#0x89cc
    89d8:	b0 12 74 66 	call	#26228		;#0x6674

000089dc <.Loc.527.2>:
}
    89dc:	03 43       	nop			
    89de:	30 41       	ret			

000089e0 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    89e0:	b0 12 96 66 	call	#26262		;#0x6696
    89e4:	b0 12 d0 89 	call	#35280		;#0x89d0

000089e8 <.Loc.538.2>:
}
    89e8:	03 43       	nop			
    89ea:	30 41       	ret			

000089ec <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    89ec:	21 82       	sub	#4,	r1	;r2 As==10

000089ee <.LCFI0>:
    89ee:	81 4c 02 00 	mov	r12,	2(r1)	;
    89f2:	81 4d 00 00 	mov	r13,	0(r1)	;

000089f6 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    89f6:	2d 41       	mov	@r1,	r13	;
    89f8:	1c 41 02 00 	mov	2(r1),	r12	;
    89fc:	b0 12 50 6a 	call	#27216		;#0x6a50

00008a00 <.Loc.740.2>:
}
    8a00:	03 43       	nop			
    8a02:	21 52       	add	#4,	r1	;r2 As==10
    8a04:	30 41       	ret			

00008a06 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    8a06:	21 83       	decd	r1		;

00008a08 <.LCFI1>:
    8a08:	81 4c 00 00 	mov	r12,	0(r1)	;

00008a0c <.Loc.120.3>:
  }
  else {
    dmaTransfer(&(spip->dmatx), &(spip->tx_req));
  }
#else
  dmaRequestS(&(spip->rx_req), TIME_INFINITE);
    8a0c:	2c 41       	mov	@r1,	r12	;
    8a0e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    8a12:	4d 43       	clr.b	r13		;
    8a14:	b0 12 a4 87 	call	#34724		;#0x87a4

00008a18 <.Loc.121.3>:
  dmaRequestS(&(spip->tx_req), TIME_INFINITE);
    8a18:	2c 41       	mov	@r1,	r12	;
    8a1a:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    8a1e:	4d 43       	clr.b	r13		;
    8a20:	b0 12 a4 87 	call	#34724		;#0x87a4

00008a24 <.Loc.124.3>:
#endif

  *(spip->ifg) |= UCTXIFG;
    8a24:	2c 41       	mov	@r1,	r12	;
    8a26:	1c 4c 08 00 	mov	8(r12),	r12	;
    8a2a:	2d 41       	mov	@r1,	r13	;
    8a2c:	1d 4d 08 00 	mov	8(r13),	r13	;
    8a30:	2d 4d       	mov	@r13,	r13	;
    8a32:	2d d3       	bis	#2,	r13	;r3 As==10
    8a34:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008a38 <.Loc.125.3>:
}
    8a38:	03 43       	nop			
    8a3a:	21 53       	incd	r1		;
    8a3c:	30 41       	ret			

00008a3e <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * spip) {
    8a3e:	21 83       	decd	r1		;

00008a40 <.LCFI2>:
    8a40:	81 4c 00 00 	mov	r12,	0(r1)	;

00008a44 <.Loc.136.3>:

  /* So that future transfers will actually work */
  *(((SPIDriver *)spip)->ifg) &= ~(UCTXIFG);
    8a44:	2c 41       	mov	@r1,	r12	;
    8a46:	1c 4c 08 00 	mov	8(r12),	r12	;
    8a4a:	2d 41       	mov	@r1,	r13	;
    8a4c:	1d 4d 08 00 	mov	8(r13),	r13	;
    8a50:	2d 4d       	mov	@r13,	r13	;
    8a52:	2d c3       	bic	#2,	r13	;r3 As==10
    8a54:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008a58 <.Loc.140.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code((SPIDriver *)spip);
    8a58:	2c 41       	mov	@r1,	r12	;
    8a5a:	1c 4c 02 00 	mov	2(r12),	r12	;
    8a5e:	2c 4c       	mov	@r12,	r12	;
    8a60:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a62:	11 24       	jz	$+36     	;abs 0x8a86

00008a64 <.Loc.140.3>:
    8a64:	2c 41       	mov	@r1,	r12	;
    8a66:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    8a6a:	2c 41       	mov	@r1,	r12	;
    8a6c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8a70:	2d 4c       	mov	@r12,	r13	;
    8a72:	2c 41       	mov	@r1,	r12	;
    8a74:	8d 12       	call	r13		;
    8a76:	2c 41       	mov	@r1,	r12	;
    8a78:	6c 4c       	mov.b	@r12,	r12	;
    8a7a:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8a7c:	07 20       	jnz	$+16     	;abs 0x8a8c

00008a7e <.Loc.140.3>:
    8a7e:	2c 41       	mov	@r1,	r12	;
    8a80:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    8a84:	03 3c       	jmp	$+8      	;abs 0x8a8c

00008a86 <.L8>:
    8a86:	2c 41       	mov	@r1,	r12	;
    8a88:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00008a8c <.L10>:
    8a8c:	b0 12 d4 89 	call	#35284		;#0x89d4
    8a90:	2c 41       	mov	@r1,	r12	;
    8a92:	2c 52       	add	#4,	r12	;r2 As==10
    8a94:	4d 43       	clr.b	r13		;
    8a96:	b0 12 ec 89 	call	#35308		;#0x89ec
    8a9a:	b0 12 e0 89 	call	#35296		;#0x89e0

00008a9e <.Loc.141.3>:
}
    8a9e:	03 43       	nop			
    8aa0:	21 53       	incd	r1		;
    8aa2:	30 41       	ret			

00008aa4 <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    8aa4:	3c 40 24 5c 	Address 0x0000000000008aa6 is out of bounds.
mov	#65535,	r12	;#0xffff

00008aa6 <L0>:
    8aa6:	24 5c       	add	@r12,	r4	;
    8aa8:	b0 12 46 77 	call	#30534		;#0x7746

00008aac <.Loc.182.3>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    8aac:	b2 40 e0 05 	mov	#1504,	&0x5c2a	;#0x05e0
    8ab0:	2a 5c 

00008ab2 <.Loc.183.3>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    8ab2:	b2 40 fc 05 	mov	#1532,	&0x5c2c	;#0x05fc
    8ab6:	2c 5c 

00008ab8 <.Loc.184.3>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    8ab8:	b2 40 11 00 	mov	#17,	&0x5c3a	;#0x0011
    8abc:	3a 5c 

00008abe <.Loc.185.3>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    8abe:	b2 40 10 00 	mov	#16,	&0x5c4c	;#0x0010
    8ac2:	4c 5c 

00008ac4 <.Loc.186.3>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    8ac4:	1c 42 2a 5c 	mov	&0x5c2a,r12	;0x5c2a
    8ac8:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    8acc:	82 4c 30 5c 	mov	r12,	&0x5c30	;

00008ad0 <.Loc.187.3>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    8ad0:	1c 42 2a 5c 	mov	&0x5c2a,r12	;0x5c2a
    8ad4:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    8ad8:	82 4c 40 5c 	mov	r12,	&0x5c40	;

00008adc <.Loc.188.3>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    8adc:	b2 40 c0 00 	mov	#192,	&0x5c36	;#0x00c0
    8ae0:	36 5c 

00008ae2 <.Loc.189.3>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    8ae2:	b2 40 c0 00 	mov	#192,	&0x5c48	;#0x00c0
    8ae6:	48 5c 

00008ae8 <.Loc.190.3>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    8ae8:	82 43 38 5c 	mov	#0,	&0x5c38	;r3 As==00

00008aec <.Loc.191.3>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    8aec:	82 43 4a 5c 	mov	#0,	&0x5c4a	;r3 As==00

00008af0 <.Loc.192.3>:
  SPIDA1.tx_req.callback.callback = NULL;
    8af0:	82 43 3c 5c 	mov	#0,	&0x5c3c	;r3 As==00

00008af4 <.Loc.193.3>:
  SPIDA1.tx_req.callback.args     = NULL;
    8af4:	82 43 3e 5c 	mov	#0,	&0x5c3e	;r3 As==00

00008af8 <.Loc.194.3>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    8af8:	b2 40 3e 8a 	mov	#35390,	&0x5c4e	;#0x8a3e
    8afc:	4e 5c 

00008afe <.Loc.195.3>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    8afe:	b2 40 24 5c 	mov	#23588,	&0x5c50	;#0x5c24
    8b02:	50 5c 

00008b04 <.Loc.238.3>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    8b04:	3c 40 52 5c 	mov	#23634,	r12	;#0x5c52
    8b08:	b0 12 46 77 	call	#30534		;#0x7746

00008b0c <.Loc.239.3>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    8b0c:	b2 40 40 06 	mov	#1600,	&0x5c58	;#0x0640
    8b10:	58 5c 

00008b12 <.Loc.240.3>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    8b12:	b2 40 6c 06 	mov	#1644,	&0x5c5a	;#0x066c
    8b16:	5a 5c 

00008b18 <.Loc.241.3>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    8b18:	b2 40 13 00 	mov	#19,	&0x5c68	;#0x0013
    8b1c:	68 5c 

00008b1e <.Loc.242.3>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    8b1e:	b2 40 12 00 	mov	#18,	&0x5c7a	;#0x0012
    8b22:	7a 5c 

00008b24 <.Loc.243.3>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    8b24:	1c 42 58 5c 	mov	&0x5c58,r12	;0x5c58
    8b28:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    8b2c:	82 4c 5e 5c 	mov	r12,	&0x5c5e	;

00008b30 <.Loc.244.3>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    8b30:	1c 42 58 5c 	mov	&0x5c58,r12	;0x5c58
    8b34:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    8b38:	82 4c 6e 5c 	mov	r12,	&0x5c6e	;

00008b3c <.Loc.245.3>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    8b3c:	b2 40 c0 00 	mov	#192,	&0x5c64	;#0x00c0
    8b40:	64 5c 

00008b42 <.Loc.246.3>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    8b42:	b2 40 c0 00 	mov	#192,	&0x5c76	;#0x00c0
    8b46:	76 5c 

00008b48 <.Loc.247.3>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    8b48:	82 43 66 5c 	mov	#0,	&0x5c66	;r3 As==00

00008b4c <.Loc.248.3>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    8b4c:	82 43 78 5c 	mov	#0,	&0x5c78	;r3 As==00

00008b50 <.Loc.249.3>:
  SPIDB0.tx_req.callback.callback = NULL;
    8b50:	82 43 6a 5c 	mov	#0,	&0x5c6a	;r3 As==00

00008b54 <.Loc.250.3>:
  SPIDB0.tx_req.callback.args     = NULL;
    8b54:	82 43 6c 5c 	mov	#0,	&0x5c6c	;r3 As==00

00008b58 <.Loc.251.3>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    8b58:	b2 40 3e 8a 	mov	#35390,	&0x5c7c	;#0x8a3e
    8b5c:	7c 5c 

00008b5e <.Loc.252.3>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    8b5e:	b2 40 52 5c 	mov	#23634,	&0x5c7e	;#0x5c52
    8b62:	7e 5c 

00008b64 <.Loc.311.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    8b64:	03 43       	nop			
    8b66:	30 41       	ret			

00008b68 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver * spip) {
    8b68:	31 80 06 00 	sub	#6,	r1	;

00008b6c <.LCFI3>:
    8b6c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008b70 <.Loc.337.3>:
      b = dmaAcquireI(&(spip->dmarx), spip->config->dmarx_index);
      osalDbgAssert(!b, "stream already allocated");
    }
#endif /* MSP430X_SPI_EXCLUSIVE_DMA */
  }
  uint16_t brw = 0;
    8b70:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00008b74 <.Loc.338.3>:
  uint8_t ssel = 0;
    8b74:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00008b78 <.Loc.346.3>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA0_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIA1
  if (spip == &SPIDA1) {
    8b78:	b1 90 24 5c 	cmp	#23588,	0(r1)	;#0x5c24
    8b7c:	00 00 
    8b7e:	14 20       	jnz	$+42     	;abs 0x8ba8

00008b80 <.Loc.347.3>:
    brw  = MSP430X_SPIA1_CLK_FREQ / spip->config->bit_rate;
    8b80:	2c 41       	mov	@r1,	r12	;
    8b82:	1c 4c 02 00 	mov	2(r12),	r12	;
    8b86:	1d 4c 06 00 	mov	6(r12),	r13	;
    8b8a:	1c 4c 04 00 	mov	4(r12),	r12	;
    8b8e:	0e 4c       	mov	r12,	r14	;
    8b90:	0f 4d       	mov	r13,	r15	;
    8b92:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    8b96:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    8b9a:	b0 12 fe c1 	call	#49662		;#0xc1fe
    8b9e:	81 4c 04 00 	mov	r12,	4(r1)	;

00008ba2 <.Loc.348.3>:
    ssel = MSP430X_SPIA1_UCSSEL;
    8ba2:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    8ba6:	03 00 

00008ba8 <.L13>:
    brw  = MSP430X_SPIA3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA3_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIB0
  if (spip == &SPIDB0) {
    8ba8:	b1 90 52 5c 	cmp	#23634,	0(r1)	;#0x5c52
    8bac:	00 00 
    8bae:	14 20       	jnz	$+42     	;abs 0x8bd8

00008bb0 <.Loc.365.3>:
    brw  = MSP430X_SPIB0_CLK_FREQ / spip->config->bit_rate;
    8bb0:	2c 41       	mov	@r1,	r12	;
    8bb2:	1c 4c 02 00 	mov	2(r12),	r12	;
    8bb6:	1d 4c 06 00 	mov	6(r12),	r13	;
    8bba:	1c 4c 04 00 	mov	4(r12),	r12	;
    8bbe:	0e 4c       	mov	r12,	r14	;
    8bc0:	0f 4d       	mov	r13,	r15	;
    8bc2:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    8bc6:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    8bca:	b0 12 fe c1 	call	#49662		;#0xc1fe
    8bce:	81 4c 04 00 	mov	r12,	4(r1)	;

00008bd2 <.Loc.366.3>:
    ssel = MSP430X_SPIB0_UCSSEL;
    8bd2:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    8bd6:	03 00 

00008bd8 <.L14>:
    brw  = MSP430X_SPIB3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIB3_UCSSEL;
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
    8bd8:	2c 41       	mov	@r1,	r12	;
    8bda:	1c 4c 06 00 	mov	6(r12),	r12	;
    8bde:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00008be2 <.Loc.389.3>:
  spip->regs->brw   = brw;
    8be2:	2c 41       	mov	@r1,	r12	;
    8be4:	1c 4c 06 00 	mov	6(r12),	r12	;
    8be8:	9c 41 04 00 	mov	4(r1),	6(r12)	;
    8bec:	06 00 

00008bee <.Loc.390.3>:
  spip->regs->ctlw0 =
    8bee:	2c 41       	mov	@r1,	r12	;
    8bf0:	1d 4c 06 00 	mov	6(r12),	r13	;

00008bf4 <.Loc.391.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    8bf4:	2c 41       	mov	@r1,	r12	;
    8bf6:	1c 4c 02 00 	mov	2(r12),	r12	;
    8bfa:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    8bfe:	6c e3       	xor.b	#2,	r12	;r3 As==10
    8c00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c04:	0e 4c       	mov	r12,	r14	;
    8c06:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    8c0a:	2c 41       	mov	@r1,	r12	;
    8c0c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c10:	5c 4c 08 00 	mov.b	8(r12),	r12	;
    8c14:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    8c18:	0e dc       	bis	r12,	r14	;

00008c1a <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    8c1a:	2c 41       	mov	@r1,	r12	;
    8c1c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c20:	5c 4c 09 00 	mov.b	9(r12),	r12	;
    8c24:	4b 18 0c 5c 	rpt #12 { rlax.w	r12		;

00008c28 <.Loc.391.3>:
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    8c28:	0c de       	bis	r14,	r12	;

00008c2a <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    8c2a:	0e 4c       	mov	r12,	r14	;
    8c2c:	3e d0 00 08 	bis	#2048,	r14	;#0x0800

00008c30 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    8c30:	2c 41       	mov	@r1,	r12	;
    8c32:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c36:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c3c:	02 24       	jz	$+6      	;abs 0x8c42

00008c3e <.Loc.393.3>:
    8c3e:	4c 43       	clr.b	r12		;
    8c40:	02 3c       	jmp	$+6      	;abs 0x8c46

00008c42 <.L15>:
    8c42:	3c 40 00 04 	mov	#1024,	r12	;#0x0400

00008c46 <.L16>:
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
    8c46:	0c de       	bis	r14,	r12	;

00008c48 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    8c48:	0e 4c       	mov	r12,	r14	;
    8c4a:	3e d0 00 01 	bis	#256,	r14	;#0x0100
    8c4e:	5c 41 03 00 	mov.b	3(r1),	r12	;
    8c52:	0c de       	bis	r14,	r12	;
    8c54:	2c d3       	bis	#2,	r12	;r3 As==10

00008c56 <.Loc.390.3>:
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
    8c56:	8d 4c 00 00 	mov	r12,	0(r13)	;

00008c5a <.Loc.394.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
  *(spip->ifg) = 0;
    8c5a:	2c 41       	mov	@r1,	r12	;
    8c5c:	1c 4c 08 00 	mov	8(r12),	r12	;
    8c60:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00008c64 <.Loc.395.3>:
  spi_lld_unselect(spip);
    8c64:	2c 41       	mov	@r1,	r12	;
    8c66:	b0 12 d2 8c 	call	#36050		;#0x8cd2

00008c6a <.Loc.396.3>:
}
    8c6a:	03 43       	nop			
    8c6c:	31 50 06 00 	add	#6,	r1	;
    8c70:	30 41       	ret			

00008c72 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    8c72:	1a 15       	pushm	#2,	r10	;16-bit words

00008c74 <L0>:
    8c74:	21 83       	decd	r1		;

00008c76 <.LCFI6>:
    8c76:	81 4c 00 00 	mov	r12,	0(r1)	;

00008c7a <.Loc.430.3>:

  if (spip->config->ss_line) {
    8c7a:	2c 41       	mov	@r1,	r12	;
    8c7c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c80:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c84:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c86:	21 24       	jz	$+68     	;abs 0x8cca

00008c88 <.Loc.431.3>:
    palClearLine(spip->config->ss_line);
    8c88:	2c 41       	mov	@r1,	r12	;
    8c8a:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c8e:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c92:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c96:	0a 4c       	mov	r12,	r10	;
    8c98:	2c 41       	mov	@r1,	r12	;
    8c9a:	1c 4c 02 00 	mov	2(r12),	r12	;
    8c9e:	1c 4c 02 00 	mov	2(r12),	r12	;
    8ca2:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8ca6:	19 4c 02 00 	mov	2(r12),	r9	;
    8caa:	2c 41       	mov	@r1,	r12	;
    8cac:	1c 4c 02 00 	mov	2(r12),	r12	;
    8cb0:	1c 4c 02 00 	mov	2(r12),	r12	;
    8cb4:	0d 4c       	mov	r12,	r13	;
    8cb6:	5d 03       	rrum	#1,	r13	;
    8cb8:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8cbc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8cbe:	b0 12 3e c2 	call	#49726		;#0xc23e
    8cc2:	3c e3       	inv	r12		;
    8cc4:	0c f9       	and	r9,	r12	;
    8cc6:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008cca <.L22>:
  }
}
    8cca:	03 43       	nop			
    8ccc:	21 53       	incd	r1		;
    8cce:	19 17       	popm	#2,	r10	;16-bit words
    8cd0:	30 41       	ret			

00008cd2 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    8cd2:	1a 15       	pushm	#2,	r10	;16-bit words

00008cd4 <.LCFI7>:
    8cd4:	21 83       	decd	r1		;

00008cd6 <.LCFI8>:
    8cd6:	81 4c 00 00 	mov	r12,	0(r1)	;

00008cda <.Loc.445.3>:

  if (spip->config->ss_line) {
    8cda:	2c 41       	mov	@r1,	r12	;
    8cdc:	1c 4c 02 00 	mov	2(r12),	r12	;
    8ce0:	1c 4c 02 00 	mov	2(r12),	r12	;
    8ce4:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ce6:	20 24       	jz	$+66     	;abs 0x8d28

00008ce8 <.Loc.446.3>:
    palSetLine(spip->config->ss_line);
    8ce8:	2c 41       	mov	@r1,	r12	;
    8cea:	1c 4c 02 00 	mov	2(r12),	r12	;
    8cee:	1c 4c 02 00 	mov	2(r12),	r12	;
    8cf2:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8cf6:	0a 4c       	mov	r12,	r10	;
    8cf8:	2c 41       	mov	@r1,	r12	;
    8cfa:	1c 4c 02 00 	mov	2(r12),	r12	;
    8cfe:	1c 4c 02 00 	mov	2(r12),	r12	;
    8d02:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8d06:	19 4c 02 00 	mov	2(r12),	r9	;
    8d0a:	2c 41       	mov	@r1,	r12	;
    8d0c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8d10:	1c 4c 02 00 	mov	2(r12),	r12	;
    8d14:	0d 4c       	mov	r12,	r13	;
    8d16:	5d 03       	rrum	#1,	r13	;
    8d18:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8d1c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8d1e:	b0 12 3e c2 	call	#49726		;#0xc23e
    8d22:	0c d9       	bis	r9,	r12	;
    8d24:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008d28 <.L25>:
  }
}
    8d28:	03 43       	nop			
    8d2a:	21 53       	incd	r1		;
    8d2c:	19 17       	popm	#2,	r10	;16-bit words
    8d2e:	30 41       	ret			

00008d30 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {
    8d30:	31 80 06 00 	sub	#6,	r1	;

00008d34 <.LCFI11>:
    8d34:	81 4c 04 00 	mov	r12,	4(r1)	;
    8d38:	81 4d 02 00 	mov	r13,	2(r1)	;
    8d3c:	81 4e 00 00 	mov	r14,	0(r1)	;

00008d40 <.Loc.520.3>:

  spip->tx_req.source_addr = txbuf;
    8d40:	1c 41 04 00 	mov	4(r1),	r12	;
    8d44:	ac 41 0a 00 	mov	@r1,	10(r12)	; 0x000a

00008d48 <.Loc.521.3>:
  spip->tx_req.size        = n;
    8d48:	1c 41 04 00 	mov	4(r1),	r12	;
    8d4c:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    8d50:	0e 00 

00008d52 <.Loc.522.3>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    8d52:	1c 41 04 00 	mov	4(r1),	r12	;
    8d56:	bc 40 00 03 	mov	#768,	16(r12)	;#0x0300, 0x0010
    8d5a:	10 00 

00008d5c <.Loc.524.3>:

  spip->rx_req.dest_addr = &dummyrx;
    8d5c:	1c 41 04 00 	mov	4(r1),	r12	;
    8d60:	bc 40 80 5c 	mov	#23680,	30(r12)	;#0x5c80, 0x001e
    8d64:	1e 00 

00008d66 <.Loc.525.3>:
  spip->rx_req.size      = n;
    8d66:	1c 41 04 00 	mov	4(r1),	r12	;
    8d6a:	9c 41 02 00 	mov	2(r1),	32(r12)	; 0x0020
    8d6e:	20 00 

00008d70 <.Loc.526.3>:
  spip->rx_req.addr_mode = 0;
    8d70:	1c 41 04 00 	mov	4(r1),	r12	;
    8d74:	8c 43 22 00 	mov	#0,	34(r12)	;r3 As==00, 0x0022

00008d78 <.Loc.528.3>:

  init_transfer(spip);
    8d78:	1c 41 04 00 	mov	4(r1),	r12	;
    8d7c:	b0 12 06 8a 	call	#35334		;#0x8a06

00008d80 <.Loc.529.3>:
}
    8d80:	03 43       	nop			
    8d82:	31 50 06 00 	add	#6,	r1	;
    8d86:	30 41       	ret			

00008d88 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {
    8d88:	21 82       	sub	#4,	r1	;r2 As==10

00008d8a <.LCFI13>:
    8d8a:	81 4c 02 00 	mov	r12,	2(r1)	;
    8d8e:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008d92 <.Loc.571.3>:

  spip->regs->txbuf = frame;
    8d92:	1c 41 02 00 	mov	2(r1),	r12	;
    8d96:	1c 4c 06 00 	mov	6(r12),	r12	;
    8d9a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    8d9e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008da2 <.Loc.572.3>:
  while (!(*(spip->ifg) & UCRXIFG))
    8da2:	03 43       	nop			

00008da4 <.L31>:
    8da4:	1c 41 02 00 	mov	2(r1),	r12	;
    8da8:	1c 4c 08 00 	mov	8(r12),	r12	;
    8dac:	2c 4c       	mov	@r12,	r12	;
    8dae:	5c f3       	and.b	#1,	r12	;r3 As==01
    8db0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8db2:	f8 27       	jz	$-14     	;abs 0x8da4

00008db4 <.Loc.574.3>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    8db4:	1c 41 02 00 	mov	2(r1),	r12	;
    8db8:	1c 4c 08 00 	mov	8(r12),	r12	;
    8dbc:	1d 41 02 00 	mov	2(r1),	r13	;
    8dc0:	1d 4d 08 00 	mov	8(r13),	r13	;
    8dc4:	2d 4d       	mov	@r13,	r13	;
    8dc6:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    8dca:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008dce <.Loc.575.3>:
  return spip->regs->rxbuf;
    8dce:	1c 41 02 00 	mov	2(r1),	r12	;
    8dd2:	1c 4c 06 00 	mov	6(r12),	r12	;
    8dd6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8dda:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008dde <.Loc.576.3>:
}
    8dde:	21 52       	add	#4,	r1	;r2 As==10
    8de0:	30 41       	ret			

00008de2 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    8de2:	03 43       	nop			
    8de4:	30 41       	ret			

00008de6 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    8de6:	03 43       	nop			
    8de8:	30 41       	ret			

00008dea <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    8dea:	b0 12 e2 8d 	call	#36322		;#0x8de2
    8dee:	b0 12 74 66 	call	#26228		;#0x6674

00008df2 <.Loc.527.2>:
}
    8df2:	03 43       	nop			
    8df4:	30 41       	ret			

00008df6 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    8df6:	b0 12 96 66 	call	#26262		;#0x6696
    8dfa:	b0 12 e6 8d 	call	#36326		;#0x8de6

00008dfe <.Loc.538.2>:
}
    8dfe:	03 43       	nop			
    8e00:	30 41       	ret			

00008e02 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    8e02:	21 82       	sub	#4,	r1	;r2 As==10

00008e04 <.LCFI0>:
    8e04:	81 4c 02 00 	mov	r12,	2(r1)	;
    8e08:	81 4d 00 00 	mov	r13,	0(r1)	;

00008e0c <.Loc.739.2>:

  chThdResumeI(trp, msg);
    8e0c:	2d 41       	mov	@r1,	r13	;
    8e0e:	1c 41 02 00 	mov	2(r1),	r12	;
    8e12:	b0 12 50 6a 	call	#27216		;#0x6a50

00008e16 <.Loc.740.2>:
}
    8e16:	03 43       	nop			
    8e18:	21 52       	add	#4,	r1	;r2 As==10
    8e1a:	30 41       	ret			

00008e1c <restart_dma>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void restart_dma(ADCDriver * adcp) {
    8e1c:	21 83       	decd	r1		;

00008e1e <.LCFI1>:
    8e1e:	81 4c 00 00 	mov	r12,	0(r1)	;

00008e22 <.Loc.55.3>:
  /* TODO timeouts? */
  /* Restart DMA transfer */
  if (adcp->dma.registers == NULL) {
    8e22:	2c 41       	mov	@r1,	r12	;
    8e24:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    8e28:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e2a:	15 20       	jnz	$+44     	;abs 0x8e56

00008e2c <.Loc.57.3>:
    /* Acquire a DMA stream because dmaTransfer can be called from ISRs */
    osalSysLockFromISR();
    8e2c:	b0 12 ea 8d 	call	#36330		;#0x8dea

00008e30 <.Loc.58.3>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    8e30:	2c 41       	mov	@r1,	r12	;
    8e32:	3c 50 26 00 	add	#38,	r12	;#0x0026
    8e36:	2d 41       	mov	@r1,	r13	;
    8e38:	5d 4d 28 00 	mov.b	40(r13),r13	;0x00028
    8e3c:	b0 12 20 88 	call	#34848		;#0x8820

00008e40 <.Loc.59.3>:
    osalSysUnlockFromISR();
    8e40:	b0 12 f6 8d 	call	#36342		;#0x8df6

00008e44 <.Loc.60.3>:
    dmaTransfer(&(adcp->dma), &(adcp->req));
    8e44:	2c 41       	mov	@r1,	r12	;
    8e46:	3c 50 26 00 	add	#38,	r12	;#0x0026
    8e4a:	2d 41       	mov	@r1,	r13	;
    8e4c:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8e50:	b0 12 da 88 	call	#35034		;#0x88da

00008e54 <.Loc.65.3>:
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
}
    8e54:	08 3c       	jmp	$+18     	;abs 0x8e66

00008e56 <.L7>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    osalSysUnlockFromISR();
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
    8e56:	2c 41       	mov	@r1,	r12	;
    8e58:	3c 50 26 00 	add	#38,	r12	;#0x0026
    8e5c:	2d 41       	mov	@r1,	r13	;
    8e5e:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8e62:	b0 12 da 88 	call	#35034		;#0x88da

00008e66 <.L9>:
  }
}
    8e66:	03 43       	nop			
    8e68:	21 53       	incd	r1		;
    8e6a:	30 41       	ret			

00008e6c <dma_callback>:

static void dma_callback(void * args) {
    8e6c:	0a 15       	pushm	#1,	r10	;16-bit words

00008e6e <L0>:
    8e6e:	31 82       	sub	#8,	r1	;r2 As==11

00008e70 <.LCFI3>:
    8e70:	81 4c 00 00 	mov	r12,	0(r1)	;

00008e74 <.Loc.68.3>:
  ADCDriver * adcp = (ADCDriver *)args;
    8e74:	a1 41 06 00 	mov	@r1,	6(r1)	;

00008e78 <.Loc.70.3>:

  if (adcp->grpp == NULL)
    8e78:	1c 41 06 00 	mov	6(r1),	r12	;
    8e7c:	1c 4c 08 00 	mov	8(r12),	r12	;
    8e80:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e82:	1f 25       	jz	$+576    	;abs 0x90c2

00008e84 <.Loc.73.3>:
    return;

  adcp->count++;
    8e84:	1c 41 06 00 	mov	6(r1),	r12	;
    8e88:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    8e8c:	5c 53       	inc.b	r12		;
    8e8e:	4d 4c       	mov.b	r12,	r13	;
    8e90:	1c 41 06 00 	mov	6(r1),	r12	;
    8e94:	cc 4d 24 00 	mov.b	r13,	36(r12)	; 0x0024

00008e98 <.Loc.75.3>:

  if (adcp->count == adcp->depth / 2) {
    8e98:	1c 41 06 00 	mov	6(r1),	r12	;
    8e9c:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    8ea0:	0d 4c       	mov	r12,	r13	;
    8ea2:	1c 41 06 00 	mov	6(r1),	r12	;
    8ea6:	1c 4c 06 00 	mov	6(r12),	r12	;
    8eaa:	12 c3       	clrc			
    8eac:	0c 10       	rrc	r12		;
    8eae:	0d 9c       	cmp	r12,	r13	;
    8eb0:	1d 20       	jnz	$+60     	;abs 0x8eec

00008eb2 <.Loc.77.3>:
    /* half-full interrupt */
    _adc_isr_half_code(adcp);
    8eb2:	1c 41 06 00 	mov	6(r1),	r12	;
    8eb6:	1c 4c 08 00 	mov	8(r12),	r12	;
    8eba:	1c 4c 02 00 	mov	2(r12),	r12	;
    8ebe:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ec0:	15 24       	jz	$+44     	;abs 0x8eec

00008ec2 <.Loc.77.3>:
    8ec2:	1c 41 06 00 	mov	6(r1),	r12	;
    8ec6:	1c 4c 08 00 	mov	8(r12),	r12	;
    8eca:	1f 4c 02 00 	mov	2(r12),	r15	;
    8ece:	1c 41 06 00 	mov	6(r1),	r12	;
    8ed2:	1c 4c 04 00 	mov	4(r12),	r12	;
    8ed6:	1d 41 06 00 	mov	6(r1),	r13	;
    8eda:	1d 4d 06 00 	mov	6(r13),	r13	;
    8ede:	12 c3       	clrc			
    8ee0:	0d 10       	rrc	r13		;
    8ee2:	0e 4d       	mov	r13,	r14	;
    8ee4:	0d 4c       	mov	r12,	r13	;
    8ee6:	1c 41 06 00 	mov	6(r1),	r12	;
    8eea:	8f 12       	call	r15		;

00008eec <.L13>:
  }

  if (adcp->count == adcp->depth) {
    8eec:	1c 41 06 00 	mov	6(r1),	r12	;
    8ef0:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    8ef4:	0d 4c       	mov	r12,	r13	;
    8ef6:	1c 41 06 00 	mov	6(r1),	r12	;
    8efa:	1c 4c 06 00 	mov	6(r12),	r12	;
    8efe:	0d 9c       	cmp	r12,	r13	;
    8f00:	ba 20       	jnz	$+374    	;abs 0x9076

00008f02 <.Loc.84.3>:
    /* full interrupt */

    /* adc_lld_stop_conversion is called automatically here if needed */
    _adc_isr_full_code(adcp);
    8f02:	1c 41 06 00 	mov	6(r1),	r12	;
    8f06:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f0a:	6c 4c       	mov.b	@r12,	r12	;
    8f0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f0e:	4c 24       	jz	$+154    	;abs 0x8fa8

00008f10 <.Loc.84.3>:
    8f10:	1c 41 06 00 	mov	6(r1),	r12	;
    8f14:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f18:	1c 4c 02 00 	mov	2(r12),	r12	;
    8f1c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f1e:	88 24       	jz	$+274    	;abs 0x9030

00008f20 <.Loc.84.3>:
    8f20:	1c 41 06 00 	mov	6(r1),	r12	;
    8f24:	1d 4c 06 00 	mov	6(r12),	r13	;
    8f28:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8f2a:	0c 9d       	cmp	r13,	r12	;
    8f2c:	29 2c       	jc	$+84     	;abs 0x8f80

00008f2e <.LBB2>:
    8f2e:	1c 41 06 00 	mov	6(r1),	r12	;
    8f32:	1c 4c 06 00 	mov	6(r12),	r12	;
    8f36:	b0 12 3a c3 	call	#49978		;#0xc33a
    8f3a:	81 4c 04 00 	mov	r12,	4(r1)	;
    8f3e:	1c 41 06 00 	mov	6(r1),	r12	;
    8f42:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f46:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8f4a:	1d 41 04 00 	mov	4(r1),	r13	;
    8f4e:	b0 12 a2 cc 	call	#52386		;#0xcca2
    8f52:	81 4c 02 00 	mov	r12,	2(r1)	;
    8f56:	1c 41 06 00 	mov	6(r1),	r12	;
    8f5a:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f5e:	1f 4c 02 00 	mov	2(r12),	r15	;
    8f62:	1c 41 06 00 	mov	6(r1),	r12	;
    8f66:	1d 4c 04 00 	mov	4(r12),	r13	;
    8f6a:	1c 41 02 00 	mov	2(r1),	r12	;
    8f6e:	0c 5c       	rla	r12		;
    8f70:	0c 5d       	add	r13,	r12	;
    8f72:	1e 41 04 00 	mov	4(r1),	r14	;
    8f76:	0d 4c       	mov	r12,	r13	;
    8f78:	1c 41 06 00 	mov	6(r1),	r12	;
    8f7c:	8f 12       	call	r15		;

00008f7e <.LBE2>:
    8f7e:	58 3c       	jmp	$+178    	;abs 0x9030

00008f80 <.L17>:
    8f80:	1c 41 06 00 	mov	6(r1),	r12	;
    8f84:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f88:	1f 4c 02 00 	mov	2(r12),	r15	;
    8f8c:	1c 41 06 00 	mov	6(r1),	r12	;
    8f90:	1c 4c 04 00 	mov	4(r12),	r12	;
    8f94:	1d 41 06 00 	mov	6(r1),	r13	;
    8f98:	1d 4d 06 00 	mov	6(r13),	r13	;
    8f9c:	0e 4d       	mov	r13,	r14	;
    8f9e:	0d 4c       	mov	r12,	r13	;
    8fa0:	1c 41 06 00 	mov	6(r1),	r12	;
    8fa4:	8f 12       	call	r15		;
    8fa6:	44 3c       	jmp	$+138    	;abs 0x9030

00008fa8 <.L15>:
    8fa8:	1c 41 06 00 	mov	6(r1),	r12	;
    8fac:	b0 12 da 94 	call	#38106		;#0x94da
    8fb0:	1c 41 06 00 	mov	6(r1),	r12	;
    8fb4:	1c 4c 08 00 	mov	8(r12),	r12	;
    8fb8:	1c 4c 02 00 	mov	2(r12),	r12	;
    8fbc:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fbe:	25 24       	jz	$+76     	;abs 0x900a

00008fc0 <.Loc.84.3>:
    8fc0:	1c 41 06 00 	mov	6(r1),	r12	;
    8fc4:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    8fc8:	1c 41 06 00 	mov	6(r1),	r12	;
    8fcc:	1c 4c 08 00 	mov	8(r12),	r12	;
    8fd0:	1f 4c 02 00 	mov	2(r12),	r15	;
    8fd4:	1c 41 06 00 	mov	6(r1),	r12	;
    8fd8:	1c 4c 04 00 	mov	4(r12),	r12	;
    8fdc:	1d 41 06 00 	mov	6(r1),	r13	;
    8fe0:	1d 4d 06 00 	mov	6(r13),	r13	;
    8fe4:	0e 4d       	mov	r13,	r14	;
    8fe6:	0d 4c       	mov	r12,	r13	;
    8fe8:	1c 41 06 00 	mov	6(r1),	r12	;
    8fec:	8f 12       	call	r15		;
    8fee:	1c 41 06 00 	mov	6(r1),	r12	;
    8ff2:	6c 4c       	mov.b	@r12,	r12	;
    8ff4:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8ff6:	11 20       	jnz	$+36     	;abs 0x901a

00008ff8 <.Loc.84.3>:
    8ff8:	1c 41 06 00 	mov	6(r1),	r12	;
    8ffc:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    9000:	1c 41 06 00 	mov	6(r1),	r12	;
    9004:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    9008:	08 3c       	jmp	$+18     	;abs 0x901a

0000900a <.L19>:
    900a:	1c 41 06 00 	mov	6(r1),	r12	;
    900e:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    9012:	1c 41 06 00 	mov	6(r1),	r12	;
    9016:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

0000901a <.L21>:
    901a:	b0 12 ea 8d 	call	#36330		;#0x8dea
    901e:	1c 41 06 00 	mov	6(r1),	r12	;
    9022:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    9026:	4d 43       	clr.b	r13		;
    9028:	b0 12 02 8e 	call	#36354		;#0x8e02
    902c:	b0 12 f6 8d 	call	#36342		;#0x8df6

00009030 <.L18>:
    /* after isr_full, adcp->grpp is only non-NULL if it's a circular group */
    if (adcp->grpp) {
    9030:	1c 41 06 00 	mov	6(r1),	r12	;
    9034:	1c 4c 08 00 	mov	8(r12),	r12	;
    9038:	0c 93       	cmp	#0,	r12	;r3 As==00
    903a:	44 24       	jz	$+138    	;abs 0x90c4

0000903c <.Loc.88.3>:
      /* Reset the buffer pointer */
      adcp->req.dest_addr = adcp->samples;
    903c:	1c 41 06 00 	mov	6(r1),	r12	;
    9040:	1d 4c 04 00 	mov	4(r12),	r13	;
    9044:	1c 41 06 00 	mov	6(r1),	r12	;
    9048:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

0000904c <.Loc.90.3>:

      restart_dma(adcp);
    904c:	1c 41 06 00 	mov	6(r1),	r12	;
    9050:	b0 12 1c 8e 	call	#36380		;#0x8e1c

00009054 <.Loc.93.3>:

      /* Reset the count */
      adcp->count = 0;
    9054:	1c 41 06 00 	mov	6(r1),	r12	;
    9058:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

0000905c <.Loc.96.3>:

      /* Start next sequence */
      adcp->regs->ctl[0] |= ADC12SC;
    905c:	1c 41 06 00 	mov	6(r1),	r12	;
    9060:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    9064:	1d 41 06 00 	mov	6(r1),	r13	;
    9068:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    906c:	2d 4d       	mov	@r13,	r13	;
    906e:	1d d3       	bis	#1,	r13	;r3 As==01
    9070:	8c 4d 00 00 	mov	r13,	0(r12)	;
    9074:	27 3c       	jmp	$+80     	;abs 0x90c4

00009076 <.L14>:
    }
  }
  else {
    /* Advance the buffer pointer */
    adcp->req.dest_addr = adcp->samples + (adcp->req.size * adcp->count);
    9076:	1c 41 06 00 	mov	6(r1),	r12	;
    907a:	1a 4c 04 00 	mov	4(r12),	r10	;
    907e:	1c 41 06 00 	mov	6(r1),	r12	;
    9082:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    9086:	1d 41 06 00 	mov	6(r1),	r13	;
    908a:	5d 4d 24 00 	mov.b	36(r13),r13	;0x00024
    908e:	b0 12 a2 cc 	call	#52386		;#0xcca2
    9092:	0c 5c       	rla	r12		;
    9094:	0d 4a       	mov	r10,	r13	;
    9096:	0d 5c       	add	r12,	r13	;
    9098:	1c 41 06 00 	mov	6(r1),	r12	;
    909c:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

000090a0 <.Loc.103.3>:

    restart_dma(adcp);
    90a0:	1c 41 06 00 	mov	6(r1),	r12	;
    90a4:	b0 12 1c 8e 	call	#36380		;#0x8e1c

000090a8 <.Loc.106.3>:

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
    90a8:	1c 41 06 00 	mov	6(r1),	r12	;
    90ac:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    90b0:	1d 41 06 00 	mov	6(r1),	r13	;
    90b4:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    90b8:	2d 4d       	mov	@r13,	r13	;
    90ba:	1d d3       	bis	#1,	r13	;r3 As==01
    90bc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    90c0:	01 3c       	jmp	$+4      	;abs 0x90c4

000090c2 <.L23>:

static void dma_callback(void * args) {
  ADCDriver * adcp = (ADCDriver *)args;

  if (adcp->grpp == NULL)
    return;
    90c2:	03 43       	nop			

000090c4 <.L10>:
    restart_dma(adcp);

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
  }
}
    90c4:	31 52       	add	#8,	r1	;r2 As==11
    90c6:	0a 17       	popm	#1,	r10	;16-bit words
    90c8:	30 41       	ret			

000090ca <populate_tlv>:

static void populate_tlv(ADCDriver * adcp) {
    90ca:	21 82       	sub	#4,	r1	;r2 As==10

000090cc <.LCFI4>:
    90cc:	81 4c 00 00 	mov	r12,	0(r1)	;

000090d0 <.Loc.111.3>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    90d0:	b1 40 08 1a 	Address 0x00000000000090d4 is out of bounds.
mov	#6664,	-1(r1)	;#0x1a08, 0xffff
    90d4:	02 00 

000090d4 <L0>:
    90d4:	02 00       	mova	@r0,	r2	;

000090d6 <.Loc.113.3>:

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    90d6:	20 3c       	jmp	$+66     	;abs 0x9118

000090d8 <.L29>:
    if (*tlv_addr == TLV_ADC12CAL) {
    90d8:	1c 41 02 00 	mov	2(r1),	r12	;
    90dc:	6c 4c       	mov.b	@r12,	r12	;
    90de:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    90e2:	07 20       	jnz	$+16     	;abs 0x90f2

000090e4 <.Loc.115.3>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    90e4:	1d 41 02 00 	mov	2(r1),	r13	;
    90e8:	2d 53       	incd	r13		;
    90ea:	2c 41       	mov	@r1,	r12	;
    90ec:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020
    90f0:	0c 3c       	jmp	$+26     	;abs 0x910a

000090f2 <.L26>:
    }
    else if (*tlv_addr == TLV_REFCAL) {
    90f2:	1c 41 02 00 	mov	2(r1),	r12	;
    90f6:	6c 4c       	mov.b	@r12,	r12	;
    90f8:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    90fc:	06 20       	jnz	$+14     	;abs 0x910a

000090fe <.Loc.118.3>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    90fe:	1d 41 02 00 	mov	2(r1),	r13	;
    9102:	2d 53       	incd	r13		;
    9104:	2c 41       	mov	@r1,	r12	;
    9106:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

0000910a <.L27>:
    }
    tlv_addr += (tlv_addr[1] + 2);
    910a:	1c 41 02 00 	mov	2(r1),	r12	;
    910e:	1c 53       	inc	r12		;
    9110:	6c 4c       	mov.b	@r12,	r12	;
    9112:	2c 53       	incd	r12		;
    9114:	81 5c 02 00 	add	r12,	2(r1)	;

00009118 <.L25>:
}

static void populate_tlv(ADCDriver * adcp) {
  uint8_t * tlv_addr = (uint8_t *)TLV_START;

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    9118:	1c 41 02 00 	mov	2(r1),	r12	;
    911c:	6c 4c       	mov.b	@r12,	r12	;
    911e:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    9120:	05 24       	jz	$+12     	;abs 0x912c

00009122 <.Loc.113.3>:
    9122:	3c 40 fe 1a 	mov	#6910,	r12	;#0x1afe
    9126:	1c 91 02 00 	cmp	2(r1),	r12	;
    912a:	d6 2f       	jc	$-82     	;abs 0x90d8

0000912c <.L30>:
    else if (*tlv_addr == TLV_REFCAL) {
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    }
    tlv_addr += (tlv_addr[1] + 2);
  }
}
    912c:	03 43       	nop			
    912e:	21 52       	add	#4,	r1	;r2 As==10
    9130:	30 41       	ret			

00009132 <ISR_ADC12_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(ADC12_VECTOR) {
    9132:	bf 15       	pushm	#12,	r15	;16-bit words

00009134 <.LCFI5>:

  OSAL_IRQ_PROLOGUE();
    9134:	d2 43 86 5b 	Address 0x0000000000009136 is out of bounds.
mov.b	#1,	&0xffff	;r3 As==01

00009136 <L0>:
    9136:	86 5b b0 12 	add	r11,	4784(r6); 0x12b0
    913a:	ba 66 1c 42 	Address 0x000000000000913c is out of bounds.
addc	@r6+,	-1(r10)	; 0xffff

0000913c <.Loc.132.3>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    913c:	1c 42 18 08 	mov	&0x0818,r12	;0x0818
    9140:	2c 93       	cmp	#2,	r12	;r3 As==10
    9142:	03 24       	jz	$+8      	;abs 0x914a
    9144:	2c 92       	cmp	#4,	r12	;r2 As==10
    9146:	32 24       	jz	$+102    	;abs 0x91ac
    9148:	62 3c       	jmp	$+198    	;abs 0x920e

0000914a <.L33>:

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
    914a:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    914e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9150:	8b 24       	jz	$+280    	;abs 0x9268

00009152 <.Loc.137.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    9152:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    9156:	b0 12 da 94 	call	#38106		;#0x94da
    915a:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    915e:	1c 4c 04 00 	mov	4(r12),	r12	;
    9162:	0c 93       	cmp	#0,	r12	;r3 As==00
    9164:	15 24       	jz	$+44     	;abs 0x9190

00009166 <.Loc.137.3>:
    9166:	f2 40 05 00 	mov.b	#5,	&0x5c82	;
    916a:	82 5c 
    916c:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    9170:	1e 4c 04 00 	mov	4(r12),	r14	;
    9174:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9176:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    917a:	8e 12       	call	r14		;
    917c:	5c 42 82 5c 	mov.b	&0x5c82,r12	;0x5c82
    9180:	7c 90 05 00 	cmp.b	#5,	r12	;
    9184:	02 20       	jnz	$+6      	;abs 0x918a

00009186 <.Loc.137.3>:
    9186:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10

0000918a <.L38>:
    918a:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00
    918e:	04 3c       	jmp	$+10     	;abs 0x9198

00009190 <.L37>:
    9190:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10
    9194:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00

00009198 <.L39>:
    9198:	b0 12 ea 8d 	call	#36330		;#0x8dea
    919c:	3d 43       	mov	#-1,	r13	;r3 As==11
    919e:	3c 40 8c 5c 	mov	#23692,	r12	;#0x5c8c
    91a2:	b0 12 02 8e 	call	#36354		;#0x8e02
    91a6:	b0 12 f6 8d 	call	#36342		;#0x8df6

000091aa <.Loc.138.3>:
    break;
    91aa:	61 3c       	jmp	$+196    	;abs 0x926e

000091ac <.L34>:
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
    91ac:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    91b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    91b2:	5c 24       	jz	$+186    	;abs 0x926c

000091b4 <.Loc.143.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    91b4:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    91b8:	b0 12 da 94 	call	#38106		;#0x94da
    91bc:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    91c0:	1c 4c 04 00 	mov	4(r12),	r12	;
    91c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    91c6:	15 24       	jz	$+44     	;abs 0x91f2

000091c8 <.Loc.143.3>:
    91c8:	f2 40 05 00 	mov.b	#5,	&0x5c82	;
    91cc:	82 5c 
    91ce:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    91d2:	1e 4c 04 00 	mov	4(r12),	r14	;
    91d6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    91d8:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    91dc:	8e 12       	call	r14		;
    91de:	5c 42 82 5c 	mov.b	&0x5c82,r12	;0x5c82
    91e2:	7c 90 05 00 	cmp.b	#5,	r12	;
    91e6:	02 20       	jnz	$+6      	;abs 0x91ec

000091e8 <.Loc.143.3>:
    91e8:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10

000091ec <.L42>:
    91ec:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00
    91f0:	04 3c       	jmp	$+10     	;abs 0x91fa

000091f2 <.L41>:
    91f2:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10
    91f6:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00

000091fa <.L43>:
    91fa:	b0 12 ea 8d 	call	#36330		;#0x8dea
    91fe:	3d 43       	mov	#-1,	r13	;r3 As==11
    9200:	3c 40 8c 5c 	mov	#23692,	r12	;#0x5c8c
    9204:	b0 12 02 8e 	call	#36354		;#0x8e02
    9208:	b0 12 f6 8d 	call	#36342		;#0x8df6

0000920c <.Loc.144.3>:
    break;
    920c:	30 3c       	jmp	$+98     	;abs 0x926e

0000920e <.L48>:
  }
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    920e:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    9212:	b0 12 da 94 	call	#38106		;#0x94da
    9216:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    921a:	1c 4c 04 00 	mov	4(r12),	r12	;
    921e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9220:	15 24       	jz	$+44     	;abs 0x924c

00009222 <.Loc.148.3>:
    9222:	f2 40 05 00 	mov.b	#5,	&0x5c82	;
    9226:	82 5c 
    9228:	1c 42 8a 5c 	mov	&0x5c8a,r12	;0x5c8a
    922c:	1e 4c 04 00 	mov	4(r12),	r14	;
    9230:	4d 43       	clr.b	r13		;
    9232:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    9236:	8e 12       	call	r14		;
    9238:	5c 42 82 5c 	mov.b	&0x5c82,r12	;0x5c82
    923c:	7c 90 05 00 	cmp.b	#5,	r12	;
    9240:	02 20       	jnz	$+6      	;abs 0x9246

00009242 <.Loc.148.3>:
    9242:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10

00009246 <.L45>:
    9246:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00
    924a:	04 3c       	jmp	$+10     	;abs 0x9254

0000924c <.L44>:
    924c:	e2 43 82 5c 	mov.b	#2,	&0x5c82	;r3 As==10
    9250:	82 43 8a 5c 	mov	#0,	&0x5c8a	;r3 As==00

00009254 <.L46>:
    9254:	b0 12 ea 8d 	call	#36330		;#0x8dea
    9258:	3d 43       	mov	#-1,	r13	;r3 As==11
    925a:	3c 40 8c 5c 	mov	#23692,	r12	;#0x5c8c
    925e:	b0 12 02 8e 	call	#36354		;#0x8e02
    9262:	b0 12 f6 8d 	call	#36342		;#0x8df6
    9266:	03 3c       	jmp	$+8      	;abs 0x926e

00009268 <.L49>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    9268:	03 43       	nop			
    926a:	01 3c       	jmp	$+4      	;abs 0x926e

0000926c <.L50>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    break;
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    926c:	03 43       	nop			

0000926e <.L36>:
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
  }

  OSAL_IRQ_EPILOGUE();
    926e:	b0 12 e8 66 	call	#26344		;#0x66e8
    9272:	c2 43 86 5b 	mov.b	#0,	&0x5b86	;r3 As==00
    9276:	b0 12 32 66 	call	#26162		;#0x6632
    927a:	b0 12 68 69 	call	#26984		;#0x6968
    927e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9282:	0c 93       	cmp	#0,	r12	;r3 As==00
    9284:	02 24       	jz	$+6      	;abs 0x928a

00009286 <.Loc.151.3>:
    9286:	b0 12 84 69 	call	#27012		;#0x6984

0000928a <.L47>:
    928a:	b0 12 52 66 	call	#26194		;#0x6652

0000928e <.Loc.152.3>:
}
    928e:	03 43       	nop			
    9290:	b4 17       	popm	#12,	r15	;16-bit words
    9292:	00 13       	reti			

00009294 <adc_lld_init>:
 */
void adc_lld_init(void) {

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    9294:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    9298:	b0 12 34 73 	call	#29492		;#0x7334

0000929c <.Loc.168.3>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    929c:	b2 40 00 08 	mov	#2048,	&0x5c8e	;#0x0800
    92a0:	8e 5c 

000092a2 <.Loc.169.3>:
  populate_tlv(&ADCD1);
    92a2:	3c 40 82 5c 	Address 0x00000000000092a4 is out of bounds.
mov	#65535,	r12	;#0xffff

000092a4 <L0>:
    92a4:	82 5c b0 12 	add	r12,	&0x12b0	;
    92a8:	ca 90 03 43 	Address 0x00000000000092aa is out of bounds.
cmp.b	r0,	-1(r10)	; 0xffff

000092aa <.Loc.171.3>:
#endif
}
    92aa:	03 43       	nop			
    92ac:	30 41       	ret			

000092ae <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver * adcp) {
    92ae:	21 82       	sub	#4,	r1	;r2 As==10

000092b0 <.LCFI6>:
    92b0:	81 4c 00 00 	mov	r12,	0(r1)	;

000092b4 <.Loc.182.3>:

  if (adcp->state == ADC_STOP) {
    92b4:	2c 41       	mov	@r1,	r12	;
    92b6:	6c 4c       	mov.b	@r12,	r12	;
    92b8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    92ba:	43 20       	jnz	$+136    	;abs 0x9342

000092bc <.LBB3>:
    /* Enables the peripheral.*/
    adcp->regs->ctl[0] = ADC12ON | ADC12MSC;
    92bc:	2c 41       	mov	@r1,	r12	;
    92be:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    92c2:	bc 40 90 00 	mov	#144,	0(r12)	;#0x0090
    92c6:	00 00 

000092c8 <.Loc.185.3>:
    adcp->regs->ctl[1] =
    92c8:	2c 41       	mov	@r1,	r12	;
    92ca:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    92ce:	bc 40 60 62 	mov	#25184,	2(r12)	;#0x6260
    92d2:	02 00 

000092d4 <.Loc.187.3>:
        MSP430X_ADC1_PDIV | MSP430X_ADC1_DIV | MSP430X_ADC1_SSEL | ADC12SHP;
    adcp->regs->ctl[3] = ADC12ICH3MAP | ADC12ICH2MAP | ADC12ICH1MAP |
    92d4:	2c 41       	mov	@r1,	r12	;
    92d6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    92da:	bc 40 c0 0f 	mov	#4032,	6(r12)	;#0x0fc0
    92de:	06 00 

000092e0 <.Loc.189.3>:
                         ADC12ICH0MAP | ADC12TCMAP | ADC12BATMAP;
    adcp->regs->ier[2] = ADC12TOVIE | ADC12OVIE;
    92e0:	2c 41       	mov	@r1,	r12	;
    92e2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    92e6:	bc 40 30 00 	mov	#48,	22(r12)	;#0x0030, 0x0016
    92ea:	16 00 

000092ec <.Loc.190.3>:
    adcp->req.trigger  = DMA_TRIGGER_MNEM(ADC12IFG);
    92ec:	2c 41       	mov	@r1,	r12	;
    92ee:	bc 40 1a 00 	mov	#26,	26(r12)	;#0x001a, 0x001a
    92f2:	1a 00 

000092f4 <.Loc.194.3>:
#if MSP430X_ADC_COMPACT_SAMPLES == TRUE
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTBYTE;
#else
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTWORD;
    92f4:	2c 41       	mov	@r1,	r12	;
    92f6:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016

000092fa <.Loc.196.3>:
#endif
    adcp->req.addr_mode         = MSP430X_DMA_SRCINCR | MSP430X_DMA_DSTINCR;
    92fa:	2c 41       	mov	@r1,	r12	;
    92fc:	bc 40 00 0f 	mov	#3840,	20(r12)	;#0x0f00, 0x0014
    9300:	14 00 

00009302 <.Loc.197.3>:
    adcp->req.transfer_mode     = MSP430X_DMA_SINGLE;
    9302:	2c 41       	mov	@r1,	r12	;
    9304:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

00009308 <.Loc.198.3>:
    adcp->req.callback.callback = dma_callback;
    9308:	2c 41       	mov	@r1,	r12	;
    930a:	bc 40 6c 8e 	mov	#36460,	28(r12)	;#0x8e6c, 0x001c
    930e:	1c 00 

00009310 <.Loc.199.3>:
    adcp->req.callback.args     = adcp;
    9310:	2c 41       	mov	@r1,	r12	;
    9312:	ac 41 1e 00 	mov	@r1,	30(r12)	; 0x001e

00009316 <.Loc.203.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    bool b;
    if (adcp->config->dma_index < MSP430X_DMA_CHANNELS) {
    9316:	2c 41       	mov	@r1,	r12	;
    9318:	1c 4c 02 00 	mov	2(r12),	r12	;
    931c:	6c 4c       	mov.b	@r12,	r12	;
    931e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    9320:	4d 9c       	cmp.b	r12,	r13	;
    9322:	0c 28       	jnc	$+26     	;abs 0x933c

00009324 <.Loc.204.3>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
    9324:	2c 41       	mov	@r1,	r12	;
    9326:	3c 50 26 00 	add	#38,	r12	;#0x0026
    932a:	2d 41       	mov	@r1,	r13	;
    932c:	1d 4d 02 00 	mov	2(r13),	r13	;
    9330:	6d 4d       	mov.b	@r13,	r13	;
    9332:	b0 12 20 88 	call	#34848		;#0x8820
    9336:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

0000933a <.LBE3>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    933a:	03 3c       	jmp	$+8      	;abs 0x9342

0000933c <.L54>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
      osalDbgAssert(!b, "stream already allocated");
    }
    else {
#endif
      adcp->dma.registers = NULL;
    933c:	2c 41       	mov	@r1,	r12	;
    933e:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

00009342 <.L55>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    9342:	03 43       	nop			
    9344:	21 52       	add	#4,	r1	;r2 As==10
    9346:	30 41       	ret			

00009348 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver * adcp) {
    9348:	21 82       	sub	#4,	r1	;r2 As==10

0000934a <L0>:
    934a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000934e <.Loc.249.3>:

  /* always use sequential transfer mode - this is fine */
  adcp->regs->ctl[1] |= ADC12CONSEQ0;
    934e:	2c 41       	mov	@r1,	r12	;
    9350:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    9354:	2d 41       	mov	@r1,	r13	;
    9356:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    935a:	1d 4d 02 00 	mov	2(r13),	r13	;
    935e:	2d d3       	bis	#2,	r13	;r3 As==10
    9360:	8c 4d 02 00 	mov	r13,	2(r12)	;

00009364 <.Loc.252.3>:

  /* set resolution */
  adcp->regs->ctl[2] |= adcp->grpp->res;
    9364:	2c 41       	mov	@r1,	r12	;
    9366:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    936a:	2d 41       	mov	@r1,	r13	;
    936c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    9370:	1e 4d 04 00 	mov	4(r13),	r14	;
    9374:	2d 41       	mov	@r1,	r13	;
    9376:	1d 4d 08 00 	mov	8(r13),	r13	;
    937a:	5d 4d 26 00 	mov.b	38(r13),r13	;0x00026
    937e:	0d de       	bis	r14,	r13	;
    9380:	8c 4d 04 00 	mov	r13,	4(r12)	;

00009384 <.Loc.254.3>:
  /* start from MEM0 */
  adcp->regs->ctl[3] &= ~(ADC12CSTARTADD_31);
    9384:	2c 41       	mov	@r1,	r12	;
    9386:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    938a:	2d 41       	mov	@r1,	r13	;
    938c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    9390:	1d 4d 06 00 	mov	6(r13),	r13	;
    9394:	3d f0 e0 ff 	and	#65504,	r13	;#0xffe0
    9398:	8c 4d 06 00 	mov	r13,	6(r12)	;

0000939c <.Loc.257.3>:

  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    939c:	03 43       	nop			

0000939e <.L61>:
    939e:	1c 42 b0 01 	mov	&0x01b0,r12	;0x01b0
    93a2:	3c f0 00 04 	and	#1024,	r12	;#0x0400
    93a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    93a8:	fa 23       	jnz	$-10     	;abs 0x939e

000093aa <.Loc.259.3>:
    ;
  REFCTL0 = adcp->grpp->vref_src;
    93aa:	2c 41       	mov	@r1,	r12	;
    93ac:	1c 4c 08 00 	mov	8(r12),	r12	;
    93b0:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    93b4:	82 4c b0 01 	mov	r12,	&0x01b0	;

000093b8 <.LBB5>:

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    93b8:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    93bc:	1b 3c       	jmp	$+56     	;abs 0x93f4

000093be <.L63>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
    93be:	2c 41       	mov	@r1,	r12	;
    93c0:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    93c4:	2c 41       	mov	@r1,	r12	;
    93c6:	1c 4c 08 00 	mov	8(r12),	r12	;
    93ca:	1d 4c 2a 00 	mov	42(r12),r13	;0x0002a
    93ce:	2c 41       	mov	@r1,	r12	;
    93d0:	1c 4c 08 00 	mov	8(r12),	r12	;
    93d4:	1c 51 02 00 	add	2(r1),	r12	;
    93d8:	3c 50 06 00 	add	#6,	r12	;
    93dc:	6c 4c       	mov.b	@r12,	r12	;
    93de:	0d dc       	bis	r12,	r13	;
    93e0:	1c 41 02 00 	mov	2(r1),	r12	;
    93e4:	3c 50 10 00 	add	#16,	r12	;#0x0010
    93e8:	0c 5c       	rla	r12		;
    93ea:	0c 5e       	add	r14,	r12	;
    93ec:	8c 4d 00 00 	mov	r13,	0(r12)	;

000093f0 <.Loc.261.3>:
  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    ;
  REFCTL0 = adcp->grpp->vref_src;

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    93f0:	91 53 02 00 	inc	2(r1)		;

000093f4 <.L62>:
    93f4:	2c 41       	mov	@r1,	r12	;
    93f6:	1c 4c 08 00 	mov	8(r12),	r12	;
    93fa:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    93fe:	81 9c 02 00 	cmp	r12,	2(r1)	;
    9402:	dd 3b       	jl	$-68     	;abs 0x93be

00009404 <.LBE5>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
  }

  adcp->regs->mctl[adcp->grpp->num_channels - 1] |= ADC12EOS;
    9404:	2c 41       	mov	@r1,	r12	;
    9406:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    940a:	2c 41       	mov	@r1,	r12	;
    940c:	1c 4c 08 00 	mov	8(r12),	r12	;
    9410:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    9414:	0f 4c       	mov	r12,	r15	;
    9416:	3f 53       	add	#-1,	r15	;r3 As==11
    9418:	2c 41       	mov	@r1,	r12	;
    941a:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    941e:	2c 41       	mov	@r1,	r12	;
    9420:	1c 4c 08 00 	mov	8(r12),	r12	;
    9424:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    9428:	3c 53       	add	#-1,	r12	;r3 As==11
    942a:	3c 50 10 00 	add	#16,	r12	;#0x0010
    942e:	0c 5c       	rla	r12		;
    9430:	0c 5d       	add	r13,	r12	;
    9432:	2c 4c       	mov	@r12,	r12	;
    9434:	0d 4c       	mov	r12,	r13	;
    9436:	3d d0 80 00 	bis	#128,	r13	;#0x0080
    943a:	0c 4f       	mov	r15,	r12	;
    943c:	3c 50 10 00 	add	#16,	r12	;#0x0010
    9440:	0c 5c       	rla	r12		;
    9442:	0c 5e       	add	r14,	r12	;
    9444:	8c 4d 00 00 	mov	r13,	0(r12)	;

00009448 <.Loc.268.3>:

  adcp->req.source_addr = adcp->regs->mem;
    9448:	2c 41       	mov	@r1,	r12	;
    944a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    944e:	0d 4c       	mov	r12,	r13	;
    9450:	3d 50 60 00 	add	#96,	r13	;#0x0060
    9454:	2c 41       	mov	@r1,	r12	;
    9456:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

0000945a <.Loc.269.3>:
  adcp->req.dest_addr   = adcp->samples;
    945a:	2c 41       	mov	@r1,	r12	;
    945c:	1d 4c 04 00 	mov	4(r12),	r13	;
    9460:	2c 41       	mov	@r1,	r12	;
    9462:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00009466 <.Loc.270.3>:
  adcp->req.size        = adcp->grpp->num_channels;
    9466:	2c 41       	mov	@r1,	r12	;
    9468:	1c 4c 08 00 	mov	8(r12),	r12	;
    946c:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    9470:	0d 4c       	mov	r12,	r13	;
    9472:	2c 41       	mov	@r1,	r12	;
    9474:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00009478 <.Loc.271.3>:
  adcp->count           = 0;
    9478:	2c 41       	mov	@r1,	r12	;
    947a:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

0000947e <.Loc.275.3>:

/* TODO timeouts? */
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    947e:	2c 41       	mov	@r1,	r12	;
    9480:	1c 4c 02 00 	mov	2(r12),	r12	;
    9484:	6c 4c       	mov.b	@r12,	r12	;
    9486:	6d 43       	mov.b	#2,	r13	;r3 As==10
    9488:	4d 9c       	cmp.b	r12,	r13	;
    948a:	0b 2c       	jc	$+24     	;abs 0x94a2

0000948c <.Loc.276.3>:
    adcp->dma.index = dmaRequestS(&(adcp->req), TIME_INFINITE);
    948c:	2c 41       	mov	@r1,	r12	;
    948e:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    9492:	4d 43       	clr.b	r13		;
    9494:	b0 12 a4 87 	call	#34724		;#0x87a4
    9498:	4d 4c       	mov.b	r12,	r13	;
    949a:	2c 41       	mov	@r1,	r12	;
    949c:	cc 4d 28 00 	mov.b	r13,	40(r12)	; 0x0028
    94a0:	08 3c       	jmp	$+18     	;abs 0x94b2

000094a2 <.L64>:
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
    94a2:	2c 41       	mov	@r1,	r12	;
    94a4:	3c 50 26 00 	add	#38,	r12	;#0x0026
    94a8:	2d 41       	mov	@r1,	r13	;
    94aa:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    94ae:	b0 12 da 88 	call	#35034		;#0x88da

000094b2 <.L65>:
  }
#else
  adcp->dma.index       = dmaRequestS(&(adcp->req), TIME_INFINITE);
#endif

  adcp->regs->ctl[0] |= adcp->grpp->rate | ADC12MSC | ADC12ENC | ADC12SC;
    94b2:	2c 41       	mov	@r1,	r12	;
    94b4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    94b8:	2d 41       	mov	@r1,	r13	;
    94ba:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    94be:	2e 4d       	mov	@r13,	r14	;
    94c0:	2d 41       	mov	@r1,	r13	;
    94c2:	1d 4d 08 00 	mov	8(r13),	r13	;
    94c6:	1d 4d 28 00 	mov	40(r13),r13	;0x00028
    94ca:	0d de       	bis	r14,	r13	;
    94cc:	3d d0 83 00 	bis	#131,	r13	;#0x0083
    94d0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000094d4 <.Loc.286.3>:
}
    94d4:	03 43       	nop			
    94d6:	21 52       	add	#4,	r1	;r2 As==10
    94d8:	30 41       	ret			

000094da <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {
    94da:	21 83       	decd	r1		;

000094dc <.LCFI9>:
    94dc:	81 4c 00 00 	Address 0x00000000000094de is out of bounds.
mov	r12,	-1(r1)	; 0xffff

000094de <L0>:
	...

000094e0 <.Loc.298.3>:

  /* TODO stop DMA transfers here */
  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    94e0:	2c 41       	mov	@r1,	r12	;
    94e2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    94e6:	2d 41       	mov	@r1,	r13	;
    94e8:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    94ec:	2d 4d       	mov	@r13,	r13	;
    94ee:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    94f2:	8c 4d 00 00 	mov	r13,	0(r12)	;

000094f6 <.Loc.301.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    94f6:	2c 41       	mov	@r1,	r12	;
    94f8:	1c 4c 02 00 	mov	2(r12),	r12	;
    94fc:	6c 4c       	mov.b	@r12,	r12	;
    94fe:	6d 43       	mov.b	#2,	r13	;r3 As==10
    9500:	4d 9c       	cmp.b	r12,	r13	;
    9502:	0d 2c       	jc	$+28     	;abs 0x951e

00009504 <.Loc.303.3>:
#endif
    if (adcp->dma.registers != NULL) {
    9504:	2c 41       	mov	@r1,	r12	;
    9506:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    950a:	0c 93       	cmp	#0,	r12	;r3 As==00
    950c:	08 24       	jz	$+18     	;abs 0x951e

0000950e <.Loc.304.3>:
      dmaRelease(&(adcp->dma));
    950e:	2c 41       	mov	@r1,	r12	;
    9510:	3c 50 26 00 	add	#38,	r12	;#0x0026
    9514:	b0 12 98 89 	call	#35224		;#0x8998

00009518 <.Loc.305.3>:
      adcp->dma.registers = NULL;
    9518:	2c 41       	mov	@r1,	r12	;
    951a:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

0000951e <.L68>:
    }
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
}
    951e:	03 43       	nop			
    9520:	21 53       	incd	r1		;
    9522:	30 41       	ret			

00009524 <adcMSP430XAdjustResult>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
    9524:	0a 15       	pushm	#1,	r10	;16-bit words

00009526 <.LCFI10>:
    9526:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000952a <.LCFI11>:
    952a:	81 4c 02 00 	mov	r12,	2(r1)	;
    952e:	81 4d 00 00 	mov	r13,	0(r1)	;

00009532 <.Loc.316.3>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    9532:	1c 41 02 00 	mov	2(r1),	r12	;
    9536:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    953a:	3c 90 00 01 	cmp	#256,	r12	;#0x0100
    953e:	1c 24       	jz	$+58     	;abs 0x9578

00009540 <.Loc.317.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    9540:	1c 41 02 00 	mov	2(r1),	r12	;
    9544:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00009548 <.Loc.316.3>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    9548:	3c 90 00 07 	cmp	#1792,	r12	;#0x0700
    954c:	15 24       	jz	$+44     	;abs 0x9578

0000954e <.Loc.318.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    954e:	1c 41 02 00 	mov	2(r1),	r12	;
    9552:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00009556 <.Loc.317.3>:
adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    9556:	3c 90 00 09 	cmp	#2304,	r12	;#0x0900
    955a:	0e 24       	jz	$+30     	;abs 0x9578

0000955c <.Loc.319.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    955c:	1c 41 02 00 	mov	2(r1),	r12	;
    9560:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00009564 <.Loc.318.3>:
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    9564:	3c 90 00 0b 	cmp	#2816,	r12	;#0x0b00
    9568:	07 24       	jz	$+16     	;abs 0x9578

0000956a <.Loc.320.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    956a:	1c 41 02 00 	mov	2(r1),	r12	;
    956e:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00009572 <.Loc.319.3>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    9572:	3c 90 00 0d 	cmp	#3328,	r12	;#0x0d00
    9576:	26 20       	jnz	$+78     	;abs 0x95c4

00009578 <.L70>:
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    /* Retrieve proper reference correction factor from TLV */
    fact = (&(ADCD1.ref_cal->CAL_ADC_12VREF_FACTOR))[grpp->vref_src >> 4];
    9578:	1c 42 a4 5c 	mov	&0x5ca4,r12	;0x5ca4
    957c:	0d 4c       	mov	r12,	r13	;
    957e:	1c 41 02 00 	mov	2(r1),	r12	;
    9582:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    9586:	5c 0f       	rrum	#4,	r12	;
    9588:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    958c:	0c 5c       	rla	r12		;
    958e:	0c 5d       	add	r13,	r12	;
    9590:	a1 4c 08 00 	mov	@r12,	8(r1)	;

00009594 <.Loc.324.3>:
    /* Calculate corrected value */
    tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    9594:	2c 41       	mov	@r1,	r12	;
    9596:	0c 5c       	rla	r12		;
    9598:	0d 43       	clr	r13		;
    959a:	1a 41 08 00 	mov	8(r1),	r10	;
    959e:	0e 4a       	mov	r10,	r14	;
    95a0:	0f 43       	clr	r15		;
    95a2:	b0 12 b6 cc 	call	#52406		;#0xccb6
    95a6:	81 4c 04 00 	mov	r12,	4(r1)	;
    95aa:	81 4d 06 00 	mov	r13,	6(r1)	;

000095ae <.Loc.325.3>:
    sample = tmp >> 16;
    95ae:	1c 41 04 00 	mov	4(r1),	r12	;
    95b2:	1d 41 06 00 	mov	6(r1),	r13	;
    95b6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    95ba:	4f 43       	clr.b	r15		;
    95bc:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    95c0:	81 4c 00 00 	mov	r12,	0(r1)	;

000095c4 <.L71>:
  }

  /* Gain correction */
  fact   = ADCD1.adc_cal->CAL_ADC_GAIN_FACTOR;
    95c4:	1c 42 a2 5c 	mov	&0x5ca2,r12	;0x5ca2
    95c8:	a1 4c 08 00 	mov	@r12,	8(r1)	;

000095cc <.Loc.330.3>:
  tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    95cc:	2c 41       	mov	@r1,	r12	;
    95ce:	0c 5c       	rla	r12		;
    95d0:	0d 43       	clr	r13		;
    95d2:	1a 41 08 00 	mov	8(r1),	r10	;
    95d6:	0e 4a       	mov	r10,	r14	;
    95d8:	0f 43       	clr	r15		;
    95da:	b0 12 b6 cc 	call	#52406		;#0xccb6
    95de:	81 4c 04 00 	mov	r12,	4(r1)	;
    95e2:	81 4d 06 00 	mov	r13,	6(r1)	;

000095e6 <.Loc.331.3>:
  sample = tmp >> 16;
    95e6:	1c 41 04 00 	mov	4(r1),	r12	;
    95ea:	1d 41 06 00 	mov	6(r1),	r13	;
    95ee:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    95f2:	4f 43       	clr.b	r15		;
    95f4:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    95f8:	81 4c 00 00 	mov	r12,	0(r1)	;

000095fc <.Loc.334.3>:

  /* Offset correction */
  sample += ADCD1.adc_cal->CAL_ADC_OFFSET;
    95fc:	1c 42 a2 5c 	mov	&0x5ca2,r12	;0x5ca2
    9600:	1c 4c 02 00 	mov	2(r12),	r12	;
    9604:	81 5c 00 00 	add	r12,	0(r1)	;

00009608 <.Loc.336.3>:

  return sample;
    9608:	2c 41       	mov	@r1,	r12	;

0000960a <.Loc.337.3>:
}
    960a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    960e:	0a 17       	popm	#1,	r10	;16-bit words
    9610:	30 41       	ret			

00009612 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    9612:	32 c2       	dint			

00009614 <.Loc.46.1>:

}
    9614:	03 43       	nop			
    9616:	30 41       	ret			

00009618 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    9618:	32 c2       	dint			

0000961a <.Loc.348.1>:
  asm volatile("nop");
    961a:	03 43       	nop			

0000961c <.Loc.349.1>:
}
    961c:	03 43       	nop			
    961e:	30 41       	ret			

00009620 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    9620:	03 43       	nop			

00009622 <.Loc.356.1>:
  _enable_interrupts();
    9622:	32 d2       	eint			
    9624:	03 43       	nop			

00009626 <.Loc.357.1>:
}
    9626:	03 43       	nop			
    9628:	30 41       	ret			

0000962a <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    962a:	03 43       	nop			
    962c:	30 41       	ret			

0000962e <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    962e:	03 43       	nop			
    9630:	30 41       	ret			

00009632 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    9632:	b0 12 18 96 	call	#38424		;#0x9618
    9636:	b0 12 32 66 	call	#26162		;#0x6632

0000963a <.Loc.505.2>:
}
    963a:	03 43       	nop			
    963c:	30 41       	ret			

0000963e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    963e:	b0 12 52 66 	call	#26194		;#0x6652
    9642:	b0 12 20 96 	call	#38432		;#0x9620

00009646 <.Loc.516.2>:
}
    9646:	03 43       	nop			
    9648:	30 41       	ret			

0000964a <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    964a:	b0 12 2a 96 	call	#38442		;#0x962a
    964e:	b0 12 74 66 	call	#26228		;#0x6674

00009652 <.Loc.527.2>:
}
    9652:	03 43       	nop			
    9654:	30 41       	ret			

00009656 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    9656:	b0 12 96 66 	call	#26262		;#0x6696
    965a:	b0 12 2e 96 	call	#38446		;#0x962e

0000965e <.Loc.538.2>:
}
    965e:	03 43       	nop			
    9660:	30 41       	ret			

00009662 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    9662:	1c 42 5a 5b 	mov	&0x5b5a,r12	;0x5b5a

00009666 <.Loc.630.2>:
}
    9666:	30 41       	ret			

00009668 <osalOsIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool osalOsIsTimeWithinX(systime_t time,
                                       systime_t start,
                                       systime_t end) {
    9668:	31 80 06 00 	sub	#6,	r1	;

0000966c <.LCFI0>:
    966c:	81 4c 04 00 	mov	r12,	4(r1)	;
    9670:	81 4d 02 00 	mov	r13,	2(r1)	;
    9674:	81 4e 00 00 	mov	r14,	0(r1)	;

00009678 <.Loc.650.2>:

  return chVTIsTimeWithinX(time, start, end);
    9678:	1e 41 04 00 	mov	4(r1),	r14	;
    967c:	1e 81 02 00 	sub	2(r1),	r14	;
    9680:	2d 41       	mov	@r1,	r13	;
    9682:	1d 81 02 00 	sub	2(r1),	r13	;
    9686:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9688:	0e 9d       	cmp	r13,	r14	;
    968a:	01 28       	jnc	$+4      	;abs 0x968e
    968c:	4c 43       	clr.b	r12		;

0000968e <.L12>:
    968e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009692 <.Loc.651.2>:
}
    9692:	31 50 06 00 	add	#6,	r1	;
    9696:	30 41       	ret			

00009698 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
    9698:	21 83       	decd	r1		;

0000969a <.LCFI1>:
    969a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000969e <.Loc.684.2>:

  chThdSleep(time);
    969e:	2c 41       	mov	@r1,	r12	;
    96a0:	b0 12 88 6a 	call	#27272		;#0x6a88

000096a4 <.Loc.685.2>:
}
    96a4:	03 43       	nop			
    96a6:	21 53       	incd	r1		;
    96a8:	30 41       	ret			

000096aa <osalThreadSuspendTimeoutS>:
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {
    96aa:	21 82       	sub	#4,	r1	;r2 As==10

000096ac <.LCFI2>:
    96ac:	81 4c 02 00 	mov	r12,	2(r1)	;
    96b0:	81 4d 00 00 	mov	r13,	0(r1)	;

000096b4 <.Loc.724.2>:

  return chThdSuspendTimeoutS(trp, timeout);
    96b4:	2d 41       	mov	@r1,	r13	;
    96b6:	1c 41 02 00 	mov	2(r1),	r12	;
    96ba:	b0 12 24 6a 	call	#27172		;#0x6a24

000096be <.Loc.725.2>:
}
    96be:	21 52       	add	#4,	r1	;r2 As==10
    96c0:	30 41       	ret			

000096c2 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    96c2:	21 82       	sub	#4,	r1	;r2 As==10

000096c4 <.LCFI3>:
    96c4:	81 4c 02 00 	mov	r12,	2(r1)	;
    96c8:	81 4d 00 00 	mov	r13,	0(r1)	;

000096cc <.Loc.739.2>:

  chThdResumeI(trp, msg);
    96cc:	2d 41       	mov	@r1,	r13	;
    96ce:	1c 41 02 00 	mov	2(r1),	r12	;
    96d2:	b0 12 50 6a 	call	#27216		;#0x6a50

000096d6 <.Loc.740.2>:
}
    96d6:	03 43       	nop			
    96d8:	21 52       	add	#4,	r1	;r2 As==10
    96da:	30 41       	ret			

000096dc <blocking_callback>:
/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

static void blocking_callback(void) {
  osalSysLockFromISR();
    96dc:	b0 12 4a 96 	call	#38474		;#0x964a

000096e0 <.Loc.61.3>:
  osalThreadResumeI(&tr, MSG_OK);
    96e0:	4d 43       	clr.b	r13		;
    96e2:	3c 40 ae 5c 	mov	#23726,	r12	;#0x5cae
    96e6:	b0 12 c2 96 	call	#38594		;#0x96c2

000096ea <.Loc.62.3>:
  osalSysUnlockFromISR();
    96ea:	b0 12 56 96 	call	#38486		;#0x9656

000096ee <.Loc.63.3>:
}
    96ee:	03 43       	nop			
    96f0:	30 41       	ret			

000096f2 <sx1278ReadRegister>:
 * 
 * @param[in] devp    pointer to the SX1278 driver
 * @param[in] reg     register address
 * @return            the read value
 */
static uint8_t sx1278ReadRegister(SX1278Driver *devp, uint8_t reg) {
    96f2:	21 82       	sub	#4,	r1	;r2 As==10

000096f4 <.LCFI4>:
    96f4:	81 4c 02 00 	mov	r12,	2(r1)	;
    96f8:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000096fc <.Loc.81.3>:
  
  osalDbgAssert(!(reg & 0x7FU), "register address out of bounds");
  
  spiSelect(devp->config->spip);
    96fc:	1c 41 02 00 	mov	2(r1),	r12	;
    9700:	2c 4c       	mov	@r12,	r12	;
    9702:	2c 4c       	mov	@r12,	r12	;
    9704:	b0 12 94 77 	call	#30612		;#0x7794

00009708 <.Loc.82.3>:
  spiPolledExchange(devp->config->spip, reg);
    9708:	1c 41 02 00 	mov	2(r1),	r12	;
    970c:	2c 4c       	mov	@r12,	r12	;
    970e:	2c 4c       	mov	@r12,	r12	;
    9710:	5d 41 01 00 	mov.b	1(r1),	r13	;
    9714:	b0 12 88 8d 	call	#36232		;#0x8d88

00009718 <.Loc.83.3>:
  reg = spiPolledExchange(devp->config->spip, 0xFFU);
    9718:	1c 41 02 00 	mov	2(r1),	r12	;
    971c:	2c 4c       	mov	@r12,	r12	;
    971e:	2c 4c       	mov	@r12,	r12	;
    9720:	7d 43       	mov.b	#-1,	r13	;r3 As==11
    9722:	b0 12 88 8d 	call	#36232		;#0x8d88
    9726:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

0000972a <.Loc.84.3>:
  spiUnselect(devp->config->spip);
    972a:	1c 41 02 00 	mov	2(r1),	r12	;
    972e:	2c 4c       	mov	@r12,	r12	;
    9730:	2c 4c       	mov	@r12,	r12	;
    9732:	b0 12 ae 77 	call	#30638		;#0x77ae

00009736 <.Loc.86.3>:
  
  return reg;
    9736:	5c 41 01 00 	mov.b	1(r1),	r12	;

0000973a <.Loc.87.3>:
}
    973a:	21 52       	add	#4,	r1	;r2 As==10
    973c:	30 41       	ret			

0000973e <sx1278SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1278SetRegister(SX1278Driver *devp, uint8_t reg, 
    uint8_t value) {
    973e:	21 82       	sub	#4,	r1	;r2 As==10

00009740 <.LCFI5>:
    9740:	81 4c 02 00 	mov	r12,	2(r1)	;
    9744:	c1 4d 01 00 	mov.b	r13,	1(r1)	;
    9748:	c1 4e 00 00 	mov.b	r14,	0(r1)	;

0000974c <.Loc.106.3>:
  osalDbgAssert(!(reg & 0x7FU), "register address out of bounds");
  
  osalDbgAssert(reg != 0x11U && reg != 0x3CU && reg != 0x42U, 
      "setting read-only registers");
  
  spiSelect(devp->config->spip);
    974c:	1c 41 02 00 	mov	2(r1),	r12	;
    9750:	2c 4c       	mov	@r12,	r12	;
    9752:	2c 4c       	mov	@r12,	r12	;
    9754:	b0 12 94 77 	call	#30612		;#0x7794

00009758 <.Loc.107.3>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    9758:	1c 41 02 00 	mov	2(r1),	r12	;
    975c:	2c 4c       	mov	@r12,	r12	;
    975e:	2c 4c       	mov	@r12,	r12	;
    9760:	5d 41 01 00 	mov.b	1(r1),	r13	;
    9764:	7d d0 80 ff 	bis.b	#65408,	r13	;#0xff80
    9768:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    976c:	b0 12 88 8d 	call	#36232		;#0x8d88

00009770 <.Loc.108.3>:
  reg = spiPolledExchange(devp->config->spip, value);
    9770:	1c 41 02 00 	mov	2(r1),	r12	;
    9774:	2c 4c       	mov	@r12,	r12	;
    9776:	2c 4c       	mov	@r12,	r12	;
    9778:	6d 41       	mov.b	@r1,	r13	;
    977a:	b0 12 88 8d 	call	#36232		;#0x8d88
    977e:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00009782 <.Loc.109.3>:
  spiUnselect(devp->config->spip);
    9782:	1c 41 02 00 	mov	2(r1),	r12	;
    9786:	2c 4c       	mov	@r12,	r12	;
    9788:	2c 4c       	mov	@r12,	r12	;
    978a:	b0 12 ae 77 	call	#30638		;#0x77ae

0000978e <.Loc.111.3>:
  
  return reg;
    978e:	5c 41 01 00 	mov.b	1(r1),	r12	;

00009792 <.Loc.112.3>:
}
    9792:	21 52       	add	#4,	r1	;r2 As==10
    9794:	30 41       	ret			

00009796 <sx1278SetRegisters>:
 * @param[in]  start  first register address to be written to
 * @param[in]  count  number of sequential registers to write to
 * @param[out] values buffer of values to be written
 */
static void sx1278SetRegisters(SX1278Driver *devp, uint8_t start, 
    uint8_t *values, uint8_t count) {
    9796:	31 80 06 00 	sub	#6,	r1	;

0000979a <.LCFI7>:
    979a:	81 4c 04 00 	mov	r12,	4(r1)	;
    979e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    97a2:	81 4e 00 00 	mov	r14,	0(r1)	;
    97a6:	c1 4f 02 00 	mov.b	r15,	2(r1)	;

000097aa <.Loc.148.3>:
  
  osalDbgAssert(!(start & 0x7FU), "register address out of bounds");
  
  spiSelect(devp->config->spip);
    97aa:	1c 41 04 00 	mov	4(r1),	r12	;
    97ae:	2c 4c       	mov	@r12,	r12	;
    97b0:	2c 4c       	mov	@r12,	r12	;
    97b2:	b0 12 94 77 	call	#30612		;#0x7794

000097b6 <.Loc.149.3>:
  spiPolledExchange(devp->config->spip, (start | 0x80));
    97b6:	1c 41 04 00 	mov	4(r1),	r12	;
    97ba:	2c 4c       	mov	@r12,	r12	;
    97bc:	2c 4c       	mov	@r12,	r12	;
    97be:	5d 41 03 00 	mov.b	3(r1),	r13	;
    97c2:	7d d0 80 ff 	bis.b	#65408,	r13	;#0xff80
    97c6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    97ca:	b0 12 88 8d 	call	#36232		;#0x8d88

000097ce <.Loc.150.3>:
  spiSend(devp->config->spip, count, values);
    97ce:	1c 41 04 00 	mov	4(r1),	r12	;
    97d2:	2c 4c       	mov	@r12,	r12	;
    97d4:	2f 4c       	mov	@r12,	r15	;
    97d6:	5c 41 02 00 	mov.b	2(r1),	r12	;
    97da:	2e 41       	mov	@r1,	r14	;
    97dc:	0d 4c       	mov	r12,	r13	;
    97de:	0c 4f       	mov	r15,	r12	;
    97e0:	b0 12 c8 77 	call	#30664		;#0x77c8

000097e4 <.Loc.151.3>:
  spiUnselect(devp->config->spip);
    97e4:	1c 41 04 00 	mov	4(r1),	r12	;
    97e8:	2c 4c       	mov	@r12,	r12	;
    97ea:	2c 4c       	mov	@r12,	r12	;
    97ec:	b0 12 ae 77 	call	#30638		;#0x77ae

000097f0 <.Loc.152.3>:
}
    97f0:	03 43       	nop			
    97f2:	31 50 06 00 	add	#6,	r1	;
    97f6:	30 41       	ret			

000097f8 <sx1278SetBitrate>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] rate bit rate in bits per second to be used
*/
static void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    97f8:	31 80 0c 00 	sub	#12,	r1	;#0x000c

000097fc <.LCFI8>:
    97fc:	81 4c 04 00 	mov	r12,	4(r1)	;
    9800:	81 4d 00 00 	mov	r13,	0(r1)	;
    9804:	81 4e 02 00 	mov	r14,	2(r1)	;

00009808 <.Loc.162.3>:
  uint16_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    9808:	2e 41       	mov	@r1,	r14	;
    980a:	1f 41 02 00 	mov	2(r1),	r15	;
    980e:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    9812:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84
    9816:	b0 12 fe c1 	call	#49662		;#0xc1fe
    981a:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

0000981e <.Loc.163.3>:
  uint16_t regs = tmp >> 4;
    981e:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    9822:	b0 12 2e c3 	call	#49966		;#0xc32e
    9826:	81 4c 08 00 	mov	r12,	8(r1)	;

0000982a <.Loc.164.3>:
  uint8_t frac = tmp & 0x000F;
    982a:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    982e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9832:	4d 4c       	mov.b	r12,	r13	;
    9834:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    9838:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

0000983c <.Loc.168.3>:
  
  osalDbgAssert(rate < 300000, "bit rate too high");
  
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    983c:	1c 41 08 00 	mov	8(r1),	r12	;
    9840:	b0 12 1e c3 	call	#49950		;#0xc31e
    9844:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9848:	4e 4c       	mov.b	r12,	r14	;
    984a:	6d 43       	mov.b	#2,	r13	;r3 As==10
    984c:	1c 41 04 00 	mov	4(r1),	r12	;
    9850:	b0 12 3e 97 	call	#38718		;#0x973e

00009854 <.Loc.169.3>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    9854:	1c 41 08 00 	mov	8(r1),	r12	;
    9858:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    985c:	4e 4c       	mov.b	r12,	r14	;
    985e:	7d 40 03 00 	mov.b	#3,	r13	;
    9862:	1c 41 04 00 	mov	4(r1),	r12	;
    9866:	b0 12 3e 97 	call	#38718		;#0x973e

0000986a <.Loc.170.3>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    986a:	5e 41 07 00 	mov.b	7(r1),	r14	;
    986e:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    9872:	1c 41 04 00 	mov	4(r1),	r12	;
    9876:	b0 12 3e 97 	call	#38718		;#0x973e

0000987a <.Loc.171.3>:
}
    987a:	03 43       	nop			
    987c:	31 50 0c 00 	add	#12,	r1	;#0x000c
    9880:	30 41       	ret			

00009882 <sx1278SetDeviation>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
static void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    9882:	31 82       	sub	#8,	r1	;r2 As==11

00009884 <.LCFI9>:
    9884:	81 4c 04 00 	mov	r12,	4(r1)	;
    9888:	81 4d 00 00 	mov	r13,	0(r1)	;
    988c:	81 4e 02 00 	mov	r14,	2(r1)	;

00009890 <.Loc.182.3>:
  /* Fancy math for freq / FSTEP to correct for roundings */
  uint16_t regs = (fdev << 11) / (SX1278_CLK_FREQ >> 8);
    9890:	2c 41       	mov	@r1,	r12	;
    9892:	1d 41 02 00 	mov	2(r1),	r13	;
    9896:	b0 12 54 c2 	call	#49748		;#0xc254
    989a:	3e 40 48 e8 	mov	#59464,	r14	;#0xe848
    989e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    98a0:	b0 12 fe c1 	call	#49662		;#0xc1fe
    98a4:	81 4c 06 00 	mov	r12,	6(r1)	;

000098a8 <.Loc.186.3>:
  
  osalDbgAssert(fdev < 200000, "deviation too high");
  
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    98a8:	1c 41 06 00 	mov	6(r1),	r12	;
    98ac:	b0 12 1e c3 	call	#49950		;#0xc31e
    98b0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    98b4:	4e 4c       	mov.b	r12,	r14	;
    98b6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    98b8:	1c 41 04 00 	mov	4(r1),	r12	;
    98bc:	b0 12 3e 97 	call	#38718		;#0x973e

000098c0 <.Loc.187.3>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    98c0:	1c 41 06 00 	mov	6(r1),	r12	;
    98c4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    98c8:	4e 4c       	mov.b	r12,	r14	;
    98ca:	7d 40 05 00 	mov.b	#5,	r13	;
    98ce:	1c 41 04 00 	mov	4(r1),	r12	;
    98d2:	b0 12 3e 97 	call	#38718		;#0x973e

000098d6 <.Loc.188.3>:
}
    98d6:	03 43       	nop			
    98d8:	31 52       	add	#8,	r1	;r2 As==11
    98da:	30 41       	ret			

000098dc <sx1278SetFrequency>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
static void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    98dc:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000098e0 <.LCFI10>:
    98e0:	81 4c 04 00 	mov	r12,	4(r1)	;
    98e4:	81 4d 00 00 	mov	r13,	0(r1)	;
    98e8:	81 4e 02 00 	mov	r14,	2(r1)	;

000098ec <.Loc.199.3>:
  /* Fancy math for freq / FSTEP to keep everything from rounding */
  uint32_t regs = ((freq / (SX1278_CLK_FREQ >> 11)) << 8);
    98ec:	2c 41       	mov	@r1,	r12	;
    98ee:	1d 41 02 00 	mov	2(r1),	r13	;
    98f2:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    98f6:	4f 43       	clr.b	r15		;
    98f8:	b0 12 fe c1 	call	#49662		;#0xc1fe
    98fc:	b0 12 60 c2 	call	#49760		;#0xc260
    9900:	81 4c 06 00 	mov	r12,	6(r1)	;
    9904:	81 4d 08 00 	mov	r13,	8(r1)	;

00009908 <.Loc.201.3>:
  
  if ((freq >= 137000000 && freq <= 175000000) || 
    9908:	3c 40 2a 08 	mov	#2090,	r12	;#0x082a
    990c:	1c 91 02 00 	cmp	2(r1),	r12	;
    9910:	08 28       	jnc	$+18     	;abs 0x9922
    9912:	b1 90 2a 08 	cmp	#2090,	2(r1)	;#0x082a
    9916:	02 00 
    9918:	11 20       	jnz	$+36     	;abs 0x993c
    991a:	3c 40 3f 74 	mov	#29759,	r12	;#0x743f
    991e:	2c 91       	cmp	@r1,	r12	;
    9920:	0d 2c       	jc	$+28     	;abs 0x993c

00009922 <.L38>:
    9922:	3c 40 6e 0a 	mov	#2670,	r12	;#0x0a6e
    9926:	1c 91 02 00 	cmp	2(r1),	r12	;
    992a:	08 28       	jnc	$+18     	;abs 0x993c
    992c:	b1 90 6e 0a 	cmp	#2670,	2(r1)	;#0x0a6e
    9930:	02 00 
    9932:	1e 20       	jnz	$+62     	;abs 0x9970
    9934:	3c 40 c0 49 	mov	#18880,	r12	;#0x49c0
    9938:	2c 91       	cmp	@r1,	r12	;
    993a:	1a 2c       	jc	$+54     	;abs 0x9970

0000993c <.L28>:
    993c:	3c 40 70 18 	mov	#6256,	r12	;#0x1870
    9940:	1c 91 02 00 	cmp	2(r1),	r12	;
    9944:	08 28       	jnc	$+18     	;abs 0x9956
    9946:	b1 90 70 18 	cmp	#6256,	2(r1)	;#0x1870
    994a:	02 00 
    994c:	1c 20       	jnz	$+58     	;abs 0x9986
    994e:	3c 40 7f 1a 	mov	#6783,	r12	;#0x1a7f
    9952:	2c 91       	cmp	@r1,	r12	;
    9954:	18 2c       	jc	$+50     	;abs 0x9986

00009956 <.L39>:
      (freq >= 410000000 && freq <= 525000000)) {
    9956:	3c 40 4a 1f 	mov	#8010,	r12	;#0x1f4a
    995a:	1c 91 02 00 	cmp	2(r1),	r12	;
    995e:	13 28       	jnc	$+40     	;abs 0x9986
    9960:	b1 90 4a 1f 	cmp	#8010,	2(r1)	;#0x1f4a
    9964:	02 00 
    9966:	04 20       	jnz	$+10     	;abs 0x9970
    9968:	3c 40 40 dd 	mov	#56640,	r12	;#0xdd40
    996c:	2c 91       	cmp	@r1,	r12	;
    996e:	0b 28       	jnc	$+24     	;abs 0x9986

00009970 <.L30>:
    /* Bands 2 + 3 */
    devp->regs.opmode |= (1 << 3);
    9970:	1c 41 04 00 	mov	4(r1),	r12	;
    9974:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    9978:	7c d2       	bis.b	#8,	r12	;r2 As==11
    997a:	4d 4c       	mov.b	r12,	r13	;
    997c:	1c 41 04 00 	mov	4(r1),	r12	;
    9980:	cc 4d 03 00 	mov.b	r13,	3(r12)	;
    9984:	24 3c       	jmp	$+74     	;abs 0x99ce

00009986 <.L32>:
  }
  else if (freq >= 862000000 && freq <= 1020000000) {
    9986:	3c 40 61 33 	mov	#13153,	r12	;#0x3361
    998a:	1c 91 02 00 	cmp	2(r1),	r12	;
    998e:	08 28       	jnc	$+18     	;abs 0x99a0
    9990:	b1 90 61 33 	cmp	#13153,	2(r1)	;#0x3361
    9994:	02 00 
    9996:	1b 20       	jnz	$+56     	;abs 0x99ce
    9998:	3c 40 7f 13 	mov	#4991,	r12	;#0x137f
    999c:	2c 91       	cmp	@r1,	r12	;
    999e:	17 2c       	jc	$+48     	;abs 0x99ce

000099a0 <.L41>:
    99a0:	3c 40 cb 3c 	mov	#15563,	r12	;#0x3ccb
    99a4:	1c 91 02 00 	cmp	2(r1),	r12	;
    99a8:	12 28       	jnc	$+38     	;abs 0x99ce
    99aa:	b1 90 cb 3c 	cmp	#15563,	2(r1)	;#0x3ccb
    99ae:	02 00 
    99b0:	04 20       	jnz	$+10     	;abs 0x99ba
    99b2:	3c 40 00 f7 	mov	#63232,	r12	;#0xf700
    99b6:	2c 91       	cmp	@r1,	r12	;
    99b8:	0a 28       	jnc	$+22     	;abs 0x99ce

000099ba <.L42>:
    /* Band 1 */
    devp->regs.opmode &= ~(1 << 3);
    99ba:	1c 41 04 00 	mov	4(r1),	r12	;
    99be:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    99c2:	7c c2       	bic.b	#8,	r12	;r2 As==11
    99c4:	4d 4c       	mov.b	r12,	r13	;
    99c6:	1c 41 04 00 	mov	4(r1),	r12	;
    99ca:	cc 4d 03 00 	mov.b	r13,	3(r12)	;

000099ce <.L40>:
    osalDbgAssert(false, "frequency out of range");
  }
  
  osalDbgAssert(!(regs & 0xFF000000), "incorrect register value calculated");
  
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    99ce:	1c 41 04 00 	mov	4(r1),	r12	;
    99d2:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    99d6:	4e 4c       	mov.b	r12,	r14	;
    99d8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    99da:	1c 41 04 00 	mov	4(r1),	r12	;
    99de:	b0 12 3e 97 	call	#38718		;#0x973e

000099e2 <.Loc.217.3>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    99e2:	1c 41 06 00 	mov	6(r1),	r12	;
    99e6:	1d 41 08 00 	mov	8(r1),	r13	;
    99ea:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    99ee:	4f 43       	clr.b	r15		;
    99f0:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    99f4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    99f8:	4e 4c       	mov.b	r12,	r14	;
    99fa:	7d 40 06 00 	mov.b	#6,	r13	;
    99fe:	1c 41 04 00 	mov	4(r1),	r12	;
    9a02:	b0 12 3e 97 	call	#38718		;#0x973e

00009a06 <.Loc.218.3>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    9a06:	1c 41 06 00 	mov	6(r1),	r12	;
    9a0a:	1d 41 08 00 	mov	8(r1),	r13	;
    9a0e:	b0 12 76 c3 	call	#50038		;#0xc376
    9a12:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9a16:	4e 4c       	mov.b	r12,	r14	;
    9a18:	7d 40 07 00 	mov.b	#7,	r13	;
    9a1c:	1c 41 04 00 	mov	4(r1),	r12	;
    9a20:	b0 12 3e 97 	call	#38718		;#0x973e

00009a24 <.Loc.219.3>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    9a24:	5c 41 06 00 	mov.b	6(r1),	r12	;
    9a28:	4e 4c       	mov.b	r12,	r14	;
    9a2a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    9a2c:	1c 41 04 00 	mov	4(r1),	r12	;
    9a30:	b0 12 3e 97 	call	#38718		;#0x973e

00009a34 <.Loc.220.3>:
}
    9a34:	03 43       	nop			
    9a36:	31 50 0a 00 	add	#10,	r1	;#0x000a
    9a3a:	30 41       	ret			

00009a3c <sx1278SetPower>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] pow  output power to be programmed, in dBm
*/
static void sx1278SetPower(SX1278Driver *devp, float pow) {
    9a3c:	6a 15       	pushm	#7,	r10	;16-bit words

00009a3e <L0>:
    9a3e:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00009a42 <.LCFI12>:
    9a42:	81 4c 04 00 	mov	r12,	4(r1)	;
    9a46:	81 4d 00 00 	mov	r13,	0(r1)	;
    9a4a:	81 4e 02 00 	mov	r14,	2(r1)	;

00009a4e <.Loc.230.3>:
  uint16_t power = ((uint16_t)(((pow + 4.2) * 10) + 0.5)) & 0xFFFE;
    9a4e:	2c 41       	mov	@r1,	r12	;
    9a50:	1d 41 02 00 	mov	2(r1),	r13	;
    9a54:	b0 12 86 b3 	call	#45958		;#0xb386
    9a58:	04 4c       	mov	r12,	r4	;
    9a5a:	05 4d       	mov	r13,	r5	;
    9a5c:	06 4e       	mov	r14,	r6	;
    9a5e:	07 4f       	mov	r15,	r7	;
    9a60:	3c 40 cd cc 	mov	#52429,	r12	;#0xcccd
    9a64:	3d 40 cc cc 	mov	#52428,	r13	;#0xcccc
    9a68:	3e 40 cc cc 	mov	#52428,	r14	;#0xcccc
    9a6c:	3f 40 10 40 	mov	#16400,	r15	;#0x4010
    9a70:	08 44       	mov	r4,	r8	;
    9a72:	09 45       	mov	r5,	r9	;
    9a74:	0a 46       	mov	r6,	r10	;
    9a76:	0b 47       	mov	r7,	r11	;
    9a78:	b0 12 f0 b9 	call	#47600		;#0xb9f0
    9a7c:	08 4c       	mov	r12,	r8	;
    9a7e:	09 4d       	mov	r13,	r9	;
    9a80:	0a 4e       	mov	r14,	r10	;
    9a82:	0b 4f       	mov	r15,	r11	;
    9a84:	0c 48       	mov	r8,	r12	;
    9a86:	04 4c       	mov	r12,	r4	;
    9a88:	0d 49       	mov	r9,	r13	;
    9a8a:	05 4d       	mov	r13,	r5	;
    9a8c:	0c 4a       	mov	r10,	r12	;
    9a8e:	06 4c       	mov	r12,	r6	;
    9a90:	0d 4b       	mov	r11,	r13	;
    9a92:	07 4d       	mov	r13,	r7	;
    9a94:	4c 43       	clr.b	r12		;
    9a96:	4d 43       	clr.b	r13		;
    9a98:	4e 43       	clr.b	r14		;
    9a9a:	3f 40 24 40 	mov	#16420,	r15	;#0x4024
    9a9e:	08 44       	mov	r4,	r8	;
    9aa0:	09 45       	mov	r5,	r9	;
    9aa2:	0a 46       	mov	r6,	r10	;
    9aa4:	0b 47       	mov	r7,	r11	;
    9aa6:	b0 12 b8 ba 	call	#47800		;#0xbab8
    9aaa:	08 4c       	mov	r12,	r8	;
    9aac:	09 4d       	mov	r13,	r9	;
    9aae:	0a 4e       	mov	r14,	r10	;
    9ab0:	0b 4f       	mov	r15,	r11	;
    9ab2:	0c 48       	mov	r8,	r12	;
    9ab4:	04 4c       	mov	r12,	r4	;
    9ab6:	0d 49       	mov	r9,	r13	;
    9ab8:	05 4d       	mov	r13,	r5	;
    9aba:	0c 4a       	mov	r10,	r12	;
    9abc:	06 4c       	mov	r12,	r6	;
    9abe:	0d 4b       	mov	r11,	r13	;
    9ac0:	07 4d       	mov	r13,	r7	;
    9ac2:	4c 43       	clr.b	r12		;
    9ac4:	4d 43       	clr.b	r13		;
    9ac6:	4e 43       	clr.b	r14		;
    9ac8:	3f 40 e0 3f 	mov	#16352,	r15	;#0x3fe0
    9acc:	08 44       	mov	r4,	r8	;
    9ace:	09 45       	mov	r5,	r9	;
    9ad0:	0a 46       	mov	r6,	r10	;
    9ad2:	0b 47       	mov	r7,	r11	;
    9ad4:	b0 12 f0 b9 	call	#47600		;#0xb9f0
    9ad8:	04 4c       	mov	r12,	r4	;
    9ada:	05 4d       	mov	r13,	r5	;
    9adc:	06 4e       	mov	r14,	r6	;
    9ade:	07 4f       	mov	r15,	r7	;
    9ae0:	0c 44       	mov	r4,	r12	;
    9ae2:	08 4c       	mov	r12,	r8	;
    9ae4:	0d 45       	mov	r5,	r13	;
    9ae6:	09 4d       	mov	r13,	r9	;
    9ae8:	0c 46       	mov	r6,	r12	;
    9aea:	0a 4c       	mov	r12,	r10	;
    9aec:	0d 47       	mov	r7,	r13	;
    9aee:	0b 4d       	mov	r13,	r11	;
    9af0:	0c 48       	mov	r8,	r12	;
    9af2:	0d 49       	mov	r9,	r13	;
    9af4:	0e 4a       	mov	r10,	r14	;
    9af6:	0f 4b       	mov	r11,	r15	;
    9af8:	b0 12 d2 af 	call	#45010		;#0xafd2
    9afc:	0d 4c       	mov	r12,	r13	;
    9afe:	1d c3       	bic	#1,	r13	;r3 As==01
    9b00:	81 4d 08 00 	mov	r13,	8(r1)	;

00009b04 <.Loc.231.3>:
  uint8_t pa_config = 0x00;
    9b04:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00

00009b08 <.Loc.236.3>:
  
  osalDbgAssert(pow == 20.0 || (pow <= 17.0 && pow >= -4.2), 
      "requested output power out of range");
  
  if (power == 242) { /* 20 dBm */
    9b08:	b1 90 f2 00 	cmp	#242,	8(r1)	;#0x00f2
    9b0c:	08 00 
    9b0e:	13 20       	jnz	$+40     	;abs 0x9b36

00009b10 <.Loc.237.3>:
    pa_config = (0xFF); /* Absolute max power - DANGEROUS */
    9b10:	f1 43 07 00 	mov.b	#-1,	7(r1)	;r3 As==11

00009b14 <.Loc.238.3>:
    sx1278SetRegister(devp, RegPaConfig, pa_config);
    9b14:	5e 41 07 00 	mov.b	7(r1),	r14	;
    9b18:	7d 40 09 00 	mov.b	#9,	r13	;
    9b1c:	1c 41 04 00 	mov	4(r1),	r12	;
    9b20:	b0 12 3e 97 	call	#38718		;#0x973e

00009b24 <.Loc.239.3>:
    sx1278SetRegister(devp, RegPaDac, 0x87); /* Special bit for +20 dBm */
    9b24:	7e 40 87 ff 	mov.b	#65415,	r14	;#0xff87
    9b28:	7d 40 4d 00 	mov.b	#77,	r13	;#0x004d
    9b2c:	1c 41 04 00 	mov	4(r1),	r12	;
    9b30:	b0 12 3e 97 	call	#38718		;#0x973e

00009b34 <.Loc.240.3>:
    return;
    9b34:	90 3c       	jmp	$+290    	;abs 0x9c56

00009b36 <.L44>:
  }
  
  sx1278SetRegister(devp, RegPaDac, 0x84);
    9b36:	7e 40 84 ff 	mov.b	#65412,	r14	;#0xff84
    9b3a:	7d 40 4d 00 	mov.b	#77,	r13	;#0x004d
    9b3e:	1c 41 04 00 	mov	4(r1),	r12	;
    9b42:	b0 12 3e 97 	call	#38718		;#0x973e

00009b46 <.Loc.245.3>:
  
  if (power > 182) { /* >14 dBm */
    9b46:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    9b4a:	1c 91 08 00 	cmp	8(r1),	r12	;
    9b4e:	1a 2c       	jc	$+54     	;abs 0x9b84

00009b50 <.Loc.246.3>:
    pa_config = (0x80 | ((uint8_t)(pow) - 2)); /* must enable PA_HP */
    9b50:	2c 41       	mov	@r1,	r12	;
    9b52:	1d 41 02 00 	mov	2(r1),	r13	;
    9b56:	b0 12 98 af 	call	#44952		;#0xaf98
    9b5a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9b5e:	7c 50 fe ff 	add.b	#65534,	r12	;#0xfffe
    9b62:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9b66:	8c 11       	sxt	r12		;
    9b68:	7c d0 80 ff 	bis.b	#65408,	r12	;#0xff80
    9b6c:	8c 11       	sxt	r12		;
    9b6e:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

00009b72 <.Loc.247.3>:
    sx1278SetRegister(devp, RegPaConfig, pa_config);
    9b72:	5e 41 07 00 	mov.b	7(r1),	r14	;
    9b76:	7d 40 09 00 	mov.b	#9,	r13	;
    9b7a:	1c 41 04 00 	mov	4(r1),	r12	;
    9b7e:	b0 12 3e 97 	call	#38718		;#0x973e

00009b82 <.Loc.248.3>:
    return;
    9b82:	69 3c       	jmp	$+212    	;abs 0x9c56

00009b84 <.L46>:
  }
  
  switch (power % 10) { /* switch for max */
    9b84:	1c 41 08 00 	mov	8(r1),	r12	;
    9b88:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9b8c:	b0 12 76 c1 	call	#49526		;#0xc176
    9b90:	2c 92       	cmp	#4,	r12	;r2 As==10
    9b92:	2d 24       	jz	$+92     	;abs 0x9bee
    9b94:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9b96:	0d 9c       	cmp	r12,	r13	;
    9b98:	05 28       	jnc	$+12     	;abs 0x9ba4
    9b9a:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b9c:	09 24       	jz	$+20     	;abs 0x9bb0
    9b9e:	2c 93       	cmp	#2,	r12	;r3 As==10
    9ba0:	13 24       	jz	$+40     	;abs 0x9bc8
    9ba2:	47 3c       	jmp	$+144    	;abs 0x9c32

00009ba4 <.L49>:
    9ba4:	3c 90 06 00 	cmp	#6,	r12	;
    9ba8:	29 24       	jz	$+84     	;abs 0x9bfc
    9baa:	3c 92       	cmp	#8,	r12	;r2 As==11
    9bac:	3a 24       	jz	$+118    	;abs 0x9c22
    9bae:	41 3c       	jmp	$+132    	;abs 0x9c32

00009bb0 <.L50>:
    case 0:
      if (power > 150) {
    9bb0:	7c 40 96 00 	mov.b	#150,	r12	;#0x0096
    9bb4:	1c 91 08 00 	cmp	8(r1),	r12	;
    9bb8:	3b 2c       	jc	$+120    	;abs 0x9c30

00009bba <.Loc.254.3>:
        pa_config |= (5 << 4);
    9bba:	f1 d0 50 00 	bis.b	#80,	7(r1)	;#0x0050
    9bbe:	07 00 

00009bc0 <.Loc.255.3>:
        power -= (5*6);
    9bc0:	b1 50 e2 ff 	add	#65506,	8(r1)	;#0xffe2
    9bc4:	08 00 

00009bc6 <.Loc.257.3>:
      }
      break;
    9bc6:	34 3c       	jmp	$+106    	;abs 0x9c30

00009bc8 <.L51>:
    case 2:
      if (power > 162) {
    9bc8:	7c 40 a2 00 	mov.b	#162,	r12	;#0x00a2
    9bcc:	1c 91 08 00 	cmp	8(r1),	r12	;
    9bd0:	07 2c       	jc	$+16     	;abs 0x9be0

00009bd2 <.Loc.260.3>:
        pa_config |= (7 << 4);
    9bd2:	f1 d0 70 00 	bis.b	#112,	7(r1)	;#0x0070
    9bd6:	07 00 

00009bd8 <.Loc.261.3>:
        power -= (7*6);
    9bd8:	b1 50 d6 ff 	add	#65494,	8(r1)	;#0xffd6
    9bdc:	08 00 

00009bde <.Loc.267.3>:
      }
      else {
        pa_config |= (2 << 4);
        power -= (2*6);
      }
      break;
    9bde:	29 3c       	jmp	$+84     	;abs 0x9c32

00009be0 <.L55>:
      if (power > 162) {
        pa_config |= (7 << 4);
        power -= (7*6);
      }
      else {
        pa_config |= (2 << 4);
    9be0:	f1 d0 20 00 	bis.b	#32,	7(r1)	;#0x0020
    9be4:	07 00 

00009be6 <.Loc.265.3>:
        power -= (2*6);
    9be6:	b1 50 f4 ff 	add	#65524,	8(r1)	;#0xfff4
    9bea:	08 00 

00009bec <.Loc.267.3>:
      }
      break;
    9bec:	22 3c       	jmp	$+70     	;abs 0x9c32

00009bee <.L48>:
    case 4:
      pa_config |= (4 << 4);
    9bee:	f1 d0 40 00 	bis.b	#64,	7(r1)	;#0x0040
    9bf2:	07 00 

00009bf4 <.Loc.270.3>:
      power -= (4*6);
    9bf4:	b1 50 e8 ff 	add	#65512,	8(r1)	;#0xffe8
    9bf8:	08 00 

00009bfa <.Loc.271.3>:
      break;
    9bfa:	1b 3c       	jmp	$+56     	;abs 0x9c32

00009bfc <.L52>:
    case 6:
      if (power > 156) {
    9bfc:	7c 40 9c 00 	mov.b	#156,	r12	;#0x009c
    9c00:	1c 91 08 00 	cmp	8(r1),	r12	;
    9c04:	07 2c       	jc	$+16     	;abs 0x9c14

00009c06 <.Loc.274.3>:
        pa_config |= (1 << 4);
    9c06:	f1 d0 10 00 	bis.b	#16,	7(r1)	;#0x0010
    9c0a:	07 00 

00009c0c <.Loc.275.3>:
        power -= (1*6);
    9c0c:	b1 50 fa ff 	add	#65530,	8(r1)	;#0xfffa
    9c10:	08 00 

00009c12 <.Loc.281.3>:
      }
      else {
        pa_config |= (6 << 4);
        power -= (6*6);
      }
      break;
    9c12:	0f 3c       	jmp	$+32     	;abs 0x9c32

00009c14 <.L57>:
      if (power > 156) {
        pa_config |= (1 << 4);
        power -= (1*6);
      }
      else {
        pa_config |= (6 << 4);
    9c14:	f1 d0 60 00 	bis.b	#96,	7(r1)	;#0x0060
    9c18:	07 00 

00009c1a <.Loc.279.3>:
        power -= (6*6);
    9c1a:	b1 50 dc ff 	add	#65500,	8(r1)	;#0xffdc
    9c1e:	08 00 

00009c20 <.Loc.281.3>:
      }
      break;
    9c20:	08 3c       	jmp	$+18     	;abs 0x9c32

00009c22 <.L53>:
    case 8:
      pa_config |= (3 << 4);
    9c22:	f1 d0 30 00 	bis.b	#48,	7(r1)	;#0x0030
    9c26:	07 00 

00009c28 <.Loc.284.3>:
      power -= (3*6);
    9c28:	b1 50 ee ff 	add	#65518,	8(r1)	;#0xffee
    9c2c:	08 00 

00009c2e <.Loc.285.3>:
      break;
    9c2e:	01 3c       	jmp	$+4      	;abs 0x9c32

00009c30 <.L59>:
    case 0:
      if (power > 150) {
        pa_config |= (5 << 4);
        power -= (5*6);
      }
      break;
    9c30:	03 43       	nop			

00009c32 <.L47>:
      pa_config |= (3 << 4);
      power -= (3*6);
      break;
  }
  
  pa_config |= (power / 10); /* set out */
    9c32:	1c 41 08 00 	mov	8(r1),	r12	;
    9c36:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9c3a:	b0 12 6e c1 	call	#49518		;#0xc16e
    9c3e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9c42:	c1 dc 07 00 	bis.b	r12,	7(r1)	;

00009c46 <.Loc.290.3>:
  
  sx1278SetRegister(devp, RegPaConfig, pa_config);
    9c46:	5e 41 07 00 	mov.b	7(r1),	r14	;
    9c4a:	7d 40 09 00 	mov.b	#9,	r13	;
    9c4e:	1c 41 04 00 	mov	4(r1),	r12	;
    9c52:	b0 12 3e 97 	call	#38718		;#0x973e

00009c56 <.L43>:
}
    9c56:	31 50 0a 00 	add	#10,	r1	;#0x000a
    9c5a:	64 17       	popm	#7,	r10	;16-bit words
    9c5c:	30 41       	ret			

00009c5e <sx1278SetPreambleLength>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp   pointer to the SX1278 driver
 * @param[in] length length of the preamble
*/
static void sx1278SetPreambleLength(SX1278Driver *devp, uint16_t length) {
    9c5e:	21 82       	sub	#4,	r1	;r2 As==10

00009c60 <.LCFI13>:
    9c60:	81 4c 02 00 	mov	r12,	2(r1)	;
    9c64:	81 4d 00 00 	mov	r13,	0(r1)	;

00009c68 <.Loc.302.3>:
  
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    9c68:	2c 41       	mov	@r1,	r12	;
    9c6a:	b0 12 1e c3 	call	#49950		;#0xc31e
    9c6e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9c72:	4e 4c       	mov.b	r12,	r14	;

00009c74 <L0>:
    9c74:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    9c78:	1c 41 02 00 	mov	2(r1),	r12	;
    9c7c:	b0 12 3e 97 	call	#38718		;#0x973e

00009c80 <.Loc.303.3>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    9c80:	2c 41       	mov	@r1,	r12	;
    9c82:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9c86:	4e 4c       	mov.b	r12,	r14	;
    9c88:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    9c8c:	1c 41 02 00 	mov	2(r1),	r12	;
    9c90:	b0 12 3e 97 	call	#38718		;#0x973e

00009c94 <.Loc.304.3>:
}
    9c94:	03 43       	nop			
    9c96:	21 52       	add	#4,	r1	;r2 As==10
    9c98:	30 41       	ret			

00009c9a <sx1278SetSync>:
 * 
 * @param[in] devp  pointer to the SX1278 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
static void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    9c9a:	0a 15       	pushm	#1,	r10	;16-bit words

00009c9c <.LCFI14>:
    9c9c:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00009ca0 <.LCFI15>:
    9ca0:	81 4c 04 00 	mov	r12,	4(r1)	;
    9ca4:	81 4d 00 00 	mov	r13,	0(r1)	;
    9ca8:	81 4e 02 00 	mov	r14,	2(r1)	;

00009cac <.Loc.315.3>:
  uint8_t reg = 0x00;
    9cac:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00

00009cb0 <.Loc.319.3>:
  
  osalDbgAssert(sizeof(sync) <= 8, "requested sync length too large");

  reg |= devp->config->packet_config->preamble_polarity << 5;
    9cb0:	1c 41 04 00 	mov	4(r1),	r12	;
    9cb4:	2c 4c       	mov	@r12,	r12	;
    9cb6:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    9cba:	6c 4c       	mov.b	@r12,	r12	;
    9cbc:	5c 0f       	rrum	#4,	r12	;
    9cbe:	5c 03       	rrum	#1,	r12	;
    9cc0:	5c f3       	and.b	#1,	r12	;r3 As==01
    9cc2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9cc6:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    9cca:	4d 4c       	mov.b	r12,	r13	;
    9ccc:	8d 11       	sxt	r13		;
    9cce:	5c 41 07 00 	mov.b	7(r1),	r12	;
    9cd2:	8c 11       	sxt	r12		;
    9cd4:	4c dd       	bis.b	r13,	r12	;
    9cd6:	8c 11       	sxt	r12		;
    9cd8:	c1 4c 07 00 	mov.b	r12,	7(r1)	;

00009cdc <.Loc.321.3>:
  
  if (sync == 0) {
    9cdc:	2c 41       	mov	@r1,	r12	;
    9cde:	1c d1 02 00 	bis	2(r1),	r12	;
    9ce2:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ce4:	04 20       	jnz	$+10     	;abs 0x9cee

00009ce6 <.Loc.322.3>:
    reg |= 0x80;
    9ce6:	f1 d0 80 ff 	bis.b	#65408,	7(r1)	;#0xff80
    9cea:	07 00 

00009cec <.Loc.323.3>:
    return;
    9cec:	34 3c       	jmp	$+106    	;abs 0x9d56

00009cee <.L62>:
  }
  else {
    reg |= 0x90 | (sizeof(sync) - 1);
    9cee:	f1 d0 93 ff 	bis.b	#65427,	7(r1)	;#0xff93
    9cf2:	07 00 

00009cf4 <.Loc.329.3>:
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
    9cf4:	5e 41 07 00 	mov.b	7(r1),	r14	;
    9cf8:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027
    9cfc:	1c 41 04 00 	mov	4(r1),	r12	;
    9d00:	b0 12 3e 97 	call	#38718		;#0x973e

00009d04 <.LBB2>:
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    9d04:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    9d08:	21 3c       	jmp	$+68     	;abs 0x9d4c

00009d0a <.L65>:
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    9d0a:	1c 41 08 00 	mov	8(r1),	r12	;
    9d0e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9d12:	7c 50 28 00 	add.b	#40,	r12	;#0x0028
    9d16:	4a 4c       	mov.b	r12,	r10	;

00009d18 <.Loc.335.3>:
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
    9d18:	1c 41 08 00 	mov	8(r1),	r12	;
    9d1c:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    9d20:	0d 43       	clr	r13		;
    9d22:	0d 8c       	sub	r12,	r13	;
    9d24:	0c 4d       	mov	r13,	r12	;
    9d26:	3c 50 18 00 	add	#24,	r12	;#0x0018
    9d2a:	0e 4c       	mov	r12,	r14	;
    9d2c:	0f 43       	clr	r15		;
    9d2e:	2c 41       	mov	@r1,	r12	;
    9d30:	1d 41 02 00 	mov	2(r1),	r13	;
    9d34:	b0 12 b0 c3 	call	#50096		;#0xc3b0

00009d38 <.Loc.334.3>:
  sx1278SetRegister(devp, RegSyncConfig, reg);
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    9d38:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9d3c:	4e 4c       	mov.b	r12,	r14	;
    9d3e:	4d 4a       	mov.b	r10,	r13	;
    9d40:	1c 41 04 00 	mov	4(r1),	r12	;
    9d44:	b0 12 3e 97 	call	#38718		;#0x973e

00009d48 <.Loc.331.3>:
    reg |= 0x90 | (sizeof(sync) - 1);
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    9d48:	91 53 08 00 	inc	8(r1)		;

00009d4c <.L64>:
    9d4c:	7c 40 03 00 	mov.b	#3,	r12	;
    9d50:	1c 91 08 00 	cmp	8(r1),	r12	;
    9d54:	da 2f       	jc	$-74     	;abs 0x9d0a

00009d56 <.L61>:
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
  }
}
    9d56:	31 50 0a 00 	add	#10,	r1	;#0x000a
    9d5a:	0a 17       	popm	#1,	r10	;16-bit words
    9d5c:	30 41       	ret			

00009d5e <sx1278Reset>:
/**
 * @brief   Resets the transceiver
 * 
 * @param[in] devp pointer to the SX1278 driver
 */
static void sx1278Reset(SX1278Driver *devp) {
    9d5e:	1a 15       	pushm	#2,	r10	;16-bit words

00009d60 <.LCFI16>:
    9d60:	21 83       	decd	r1		;

00009d62 <L0>:
    9d62:	81 4c 00 00 	mov	r12,	0(r1)	;

00009d66 <.Loc.348.3>:
  
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
  
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    9d66:	2c 41       	mov	@r1,	r12	;
    9d68:	2c 4c       	mov	@r12,	r12	;
    9d6a:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9d6e:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9d72:	0a 4c       	mov	r12,	r10	;
    9d74:	2c 41       	mov	@r1,	r12	;
    9d76:	2c 4c       	mov	@r12,	r12	;
    9d78:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9d7c:	0d 4c       	mov	r12,	r13	;
    9d7e:	5d 03       	rrum	#1,	r13	;
    9d80:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9d84:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9d86:	b0 12 3e c2 	call	#49726		;#0xc23e
    9d8a:	7e 40 06 00 	mov.b	#6,	r14	;
    9d8e:	0d 4c       	mov	r12,	r13	;
    9d90:	0c 4a       	mov	r10,	r12	;
    9d92:	b0 12 80 80 	call	#32896		;#0x8080

00009d96 <.Loc.349.3>:
  palClearLine(devp->config->reset_line);
    9d96:	2c 41       	mov	@r1,	r12	;
    9d98:	2c 4c       	mov	@r12,	r12	;
    9d9a:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9d9e:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9da2:	0a 4c       	mov	r12,	r10	;
    9da4:	2c 41       	mov	@r1,	r12	;
    9da6:	2c 4c       	mov	@r12,	r12	;
    9da8:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9dac:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9db0:	19 4c 02 00 	mov	2(r12),	r9	;
    9db4:	2c 41       	mov	@r1,	r12	;
    9db6:	2c 4c       	mov	@r12,	r12	;
    9db8:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9dbc:	0d 4c       	mov	r12,	r13	;
    9dbe:	5d 03       	rrum	#1,	r13	;
    9dc0:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9dc4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9dc6:	b0 12 3e c2 	call	#49726		;#0xc23e
    9dca:	3c e3       	inv	r12		;
    9dcc:	0c f9       	and	r9,	r12	;
    9dce:	8a 4c 02 00 	mov	r12,	2(r10)	;

00009dd2 <.Loc.350.3>:
  osalThreadSleepMicroseconds(100);
    9dd2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9dd4:	b0 12 98 96 	call	#38552		;#0x9698

00009dd8 <.Loc.351.3>:
  palSetLine(devp->config->reset_line);
    9dd8:	2c 41       	mov	@r1,	r12	;
    9dda:	2c 4c       	mov	@r12,	r12	;
    9ddc:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9de0:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9de4:	0a 4c       	mov	r12,	r10	;
    9de6:	2c 41       	mov	@r1,	r12	;
    9de8:	2c 4c       	mov	@r12,	r12	;
    9dea:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9dee:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9df2:	19 4c 02 00 	mov	2(r12),	r9	;
    9df6:	2c 41       	mov	@r1,	r12	;
    9df8:	2c 4c       	mov	@r12,	r12	;
    9dfa:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9dfe:	0d 4c       	mov	r12,	r13	;
    9e00:	5d 03       	rrum	#1,	r13	;
    9e02:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9e06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e08:	b0 12 3e c2 	call	#49726		;#0xc23e
    9e0c:	0c d9       	bis	r9,	r12	;
    9e0e:	8a 4c 02 00 	mov	r12,	2(r10)	;

00009e12 <.Loc.352.3>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLUP);
    9e12:	2c 41       	mov	@r1,	r12	;
    9e14:	2c 4c       	mov	@r12,	r12	;
    9e16:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9e1a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    9e1e:	0a 4c       	mov	r12,	r10	;
    9e20:	2c 41       	mov	@r1,	r12	;
    9e22:	2c 4c       	mov	@r12,	r12	;
    9e24:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    9e28:	0d 4c       	mov	r12,	r13	;
    9e2a:	5d 03       	rrum	#1,	r13	;
    9e2c:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9e30:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9e32:	b0 12 3e c2 	call	#49726		;#0xc23e
    9e36:	7e 40 03 00 	mov.b	#3,	r14	;
    9e3a:	0d 4c       	mov	r12,	r13	;
    9e3c:	0c 4a       	mov	r10,	r12	;
    9e3e:	b0 12 80 80 	call	#32896		;#0x8080

00009e42 <.Loc.353.3>:
  osalThreadSleepMilliseconds(5);
    9e42:	7c 40 05 00 	mov.b	#5,	r12	;
    9e46:	b0 12 98 96 	call	#38552		;#0x9698

00009e4a <.Loc.354.3>:
}
    9e4a:	03 43       	nop			
    9e4c:	21 53       	incd	r1		;
    9e4e:	19 17       	popm	#2,	r10	;16-bit words
    9e50:	30 41       	ret			

00009e52 <sx1278SetMode>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1278SetMode(SX1278Driver *devp, SX1278ModeConstants mode) {
    9e52:	21 82       	sub	#4,	r1	;r2 As==10

00009e54 <.LCFI18>:
    9e54:	81 4c 02 00 	mov	r12,	2(r1)	;
    9e58:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00009e5c <.Loc.367.3>:
  
  osalDbgAssert(mode < 0x06U, "requested invalid transceiver mode");
  
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    9e5c:	1c 41 02 00 	mov	2(r1),	r12	;
    9e60:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    9e64:	8c 11       	sxt	r12		;
    9e66:	7c f0 f8 ff 	and.b	#65528,	r12	;#0xfff8
    9e6a:	4d 4c       	mov.b	r12,	r13	;
    9e6c:	8d 11       	sxt	r13		;
    9e6e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    9e72:	8c 11       	sxt	r12		;
    9e74:	4c dd       	bis.b	r13,	r12	;
    9e76:	8c 11       	sxt	r12		;
    9e78:	4d 4c       	mov.b	r12,	r13	;
    9e7a:	1c 41 02 00 	mov	2(r1),	r12	;
    9e7e:	cc 4d 03 00 	mov.b	r13,	3(r12)	;

00009e82 <.Loc.368.3>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    9e82:	1c 41 02 00 	mov	2(r1),	r12	;
    9e86:	5c 4c 03 00 	mov.b	3(r12),	r12	;
    9e8a:	4e 4c       	mov.b	r12,	r14	;
    9e8c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    9e8e:	1c 41 02 00 	mov	2(r1),	r12	;
    9e92:	b0 12 3e 97 	call	#38718		;#0x973e

00009e96 <.Loc.369.3>:
}
    9e96:	03 43       	nop			
    9e98:	21 52       	add	#4,	r1	;r2 As==10
    9e9a:	30 41       	ret			

00009e9c <sx1278MapIRQs>:
 * 
 * @param[in] devp    pointer to the SX1278 driver
 * @param[in] dio_map the mapping of SX127 IRQ signals to DIO pins
 */
static void sx1278MapIRQs(SX1278Driver *devp, 
    const uint8_t irq_map[IRQMax]) {
    9e9c:	31 82       	sub	#8,	r1	;r2 As==11

00009e9e <.LCFI19>:
    9e9e:	81 4c 02 00 	mov	r12,	2(r1)	;
    9ea2:	81 4d 00 00 	mov	r13,	0(r1)	;

00009ea6 <.Loc.380.3>:
  uint16_t dio_reg = 0x0000;
    9ea6:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00009eaa <.LBB3>:
  /* Configure IRQ mapping. Mapping PacketSent to DIO0 and FifoLevel to DIO1 
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    9eaa:	c1 43 07 00 	mov.b	#0,	7(r1)	;r3 As==00
    9eae:	1a 3c       	jmp	$+54     	;abs 0x9ee4

00009eb0 <.L75>:
    if (irq_map[i] > 5) continue;
    9eb0:	5c 41 07 00 	mov.b	7(r1),	r12	;
    9eb4:	2c 51       	add	@r1,	r12	;
    9eb6:	6c 4c       	mov.b	@r12,	r12	;
    9eb8:	7d 40 05 00 	mov.b	#5,	r13	;
    9ebc:	4d 9c       	cmp.b	r12,	r13	;
    9ebe:	07 28       	jnc	$+16     	;abs 0x9ece

00009ec0 <.Loc.388.3>:
    switch (i) {
    9ec0:	5c 41 07 00 	mov.b	7(r1),	r12	;
    9ec4:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ec6:	05 24       	jz	$+12     	;abs 0x9ed2
    9ec8:	1c 93       	cmp	#1,	r12	;r3 As==01
    9eca:	05 24       	jz	$+12     	;abs 0x9ed6

00009ecc <.Loc.401.3>:
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 4);*/
        break;
      default:
        osalDbgAssert(false, "Invalid IRQ mapping requested");
        break;
    9ecc:	05 3c       	jmp	$+12     	;abs 0x9ed8

00009ece <.L76>:
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    if (irq_map[i] > 5) continue;
    9ece:	03 43       	nop			
    9ed0:	03 3c       	jmp	$+8      	;abs 0x9ed8

00009ed2 <.L77>:
    switch (i) {
      case PacketSent:
        osalDbgAssert(irq_map[i] == 0, "IRQ mapping invalid");
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 6);*/
        break;
    9ed2:	03 43       	nop			
    9ed4:	01 3c       	jmp	$+4      	;abs 0x9ed8

00009ed6 <.L78>:
      case FifoLevel:
        osalDbgAssert(irq_map[i] == 1, "IRQ mapping invalid");
        /* The below is obviously a no-op - included for clarity */
        /*dio_reg |= (0x00 << 4);*/
        break;
    9ed6:	03 43       	nop			

00009ed8 <.L71>:
  /* Configure IRQ mapping. Mapping PacketSent to DIO0 and FifoLevel to DIO1 
   * is recommended. */
  /* Presently this whole function does nothing but assert the reset state.
   * Someday we might want to use other IRQs and we'd add them here */
  
  for (SX1278IRQConstants i = 0; i < IRQMax; i++) {
    9ed8:	5c 41 07 00 	mov.b	7(r1),	r12	;
    9edc:	4d 4c       	mov.b	r12,	r13	;
    9ede:	5d 53       	inc.b	r13		;
    9ee0:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

00009ee4 <.L69>:
    9ee4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9ee6:	5c 91 07 00 	cmp.b	7(r1),	r12	;
    9eea:	e2 2f       	jc	$-58     	;abs 0x9eb0

00009eec <.LBE3>:
        osalDbgAssert(false, "Invalid IRQ mapping requested");
        break;
    }
  }
  
  sx1278SetRegister(devp, RegDioMapping1, ((uint8_t *)(&dio_reg))[0]);
    9eec:	0c 41       	mov	r1,	r12	;
    9eee:	2c 52       	add	#4,	r12	;r2 As==10
    9ef0:	6c 4c       	mov.b	@r12,	r12	;
    9ef2:	4e 4c       	mov.b	r12,	r14	;
    9ef4:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    9ef8:	1c 41 02 00 	mov	2(r1),	r12	;
    9efc:	b0 12 3e 97 	call	#38718		;#0x973e

00009f00 <.Loc.406.3>:
  sx1278SetRegister(devp, RegDioMapping2, ((uint8_t *)(&dio_reg))[1]);
    9f00:	0c 41       	mov	r1,	r12	;
    9f02:	2c 52       	add	#4,	r12	;r2 As==10
    9f04:	1c 53       	inc	r12		;
    9f06:	6c 4c       	mov.b	@r12,	r12	;
    9f08:	4e 4c       	mov.b	r12,	r14	;
    9f0a:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    9f0e:	1c 41 02 00 	mov	2(r1),	r12	;
    9f12:	b0 12 3e 97 	call	#38718		;#0x973e

00009f16 <.Loc.407.3>:
}
    9f16:	03 43       	nop			
    9f18:	31 52       	add	#8,	r1	;r2 As==11
    9f1a:	30 41       	ret			

00009f1c <sx1278ConfigurePackets>:
 * 
 * @param[in] devp          pointer to the SX1278 driver
 * @param[in] packet_config the packet configuration to apply
 */
static void sx1278ConfigurePackets(SX1278Driver* devp, 
    sx1278_packet_config_t *packet_config) {
    9f1c:	31 80 06 00 	sub	#6,	r1	;

00009f20 <.LCFI20>:
    9f20:	81 4c 02 00 	mov	r12,	2(r1)	;

00009f24 <L0>:
    9f24:	81 4d 00 00 	mov	r13,	0(r1)	;

00009f28 <.Loc.419.3>:
  /* Configure packet mode */
  uint8_t reg = 0x00;
    9f28:	c1 43 05 00 	mov.b	#0,	5(r1)	;r3 As==00

00009f2c <.Loc.422.3>:
  
  /* Unlimited - PacketFormat == 0, PayloadLength == 0 */
  if (packet_config->format == Variable) {
    9f2c:	2c 41       	mov	@r1,	r12	;
    9f2e:	6c 4c       	mov.b	@r12,	r12	;
    9f30:	7c f0 03 00 	and.b	#3,	r12	;
    9f34:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9f38:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9f3a:	03 20       	jnz	$+8      	;abs 0x9f42

00009f3c <.Loc.423.3>:
    reg |= 1 << 7;
    9f3c:	f1 d0 80 ff 	bis.b	#65408,	5(r1)	;#0xff80
    9f40:	05 00 

00009f42 <.L83>:
   *  regs |= 0 << 7;
   * }*/
  
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
      "Whitening and Manchester encoding are mutually exclusive");
  reg |= packet_config->whitening << 6;
    9f42:	2c 41       	mov	@r1,	r12	;
    9f44:	6c 4c       	mov.b	@r12,	r12	;
    9f46:	5c 07       	rrum	#2,	r12	;
    9f48:	5c f3       	and.b	#1,	r12	;r3 As==01
    9f4a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9f4e:	45 18 0c 5c 	rpt #6 { rlax.w	r12		;
    9f52:	4d 4c       	mov.b	r12,	r13	;
    9f54:	8d 11       	sxt	r13		;
    9f56:	5c 41 05 00 	mov.b	5(r1),	r12	;
    9f5a:	8c 11       	sxt	r12		;
    9f5c:	4c dd       	bis.b	r13,	r12	;
    9f5e:	8c 11       	sxt	r12		;
    9f60:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00009f64 <.Loc.432.3>:
  reg |= packet_config->manchester << 5;
    9f64:	2c 41       	mov	@r1,	r12	;
    9f66:	6c 4c       	mov.b	@r12,	r12	;
    9f68:	5c 0b       	rrum	#3,	r12	;
    9f6a:	5c f3       	and.b	#1,	r12	;r3 As==01
    9f6c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9f70:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    9f74:	4d 4c       	mov.b	r12,	r13	;
    9f76:	8d 11       	sxt	r13		;
    9f78:	5c 41 05 00 	mov.b	5(r1),	r12	;
    9f7c:	8c 11       	sxt	r12		;
    9f7e:	4c dd       	bis.b	r13,	r12	;
    9f80:	8c 11       	sxt	r12		;
    9f82:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00009f86 <.Loc.434.3>:
  
  reg |= packet_config->crc << 4;
    9f86:	2c 41       	mov	@r1,	r12	;
    9f88:	6c 4c       	mov.b	@r12,	r12	;
    9f8a:	5c 0f       	rrum	#4,	r12	;
    9f8c:	5c f3       	and.b	#1,	r12	;r3 As==01
    9f8e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9f92:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    9f96:	4d 4c       	mov.b	r12,	r13	;
    9f98:	8d 11       	sxt	r13		;
    9f9a:	5c 41 05 00 	mov.b	5(r1),	r12	;
    9f9e:	8c 11       	sxt	r12		;
    9fa0:	4c dd       	bis.b	r13,	r12	;
    9fa2:	8c 11       	sxt	r12		;
    9fa4:	c1 4c 05 00 	mov.b	r12,	5(r1)	;

00009fa8 <.Loc.436.3>:
  
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    9fa8:	5e 41 05 00 	mov.b	5(r1),	r14	;
    9fac:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030
    9fb0:	1c 41 02 00 	mov	2(r1),	r12	;
    9fb4:	b0 12 3e 97 	call	#38718		;#0x973e

00009fb8 <.Loc.438.3>:
  
  if (packet_config->format == Fixed) {
    9fb8:	2c 41       	mov	@r1,	r12	;
    9fba:	6c 4c       	mov.b	@r12,	r12	;
    9fbc:	7c f0 03 00 	and.b	#3,	r12	;
    9fc0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9fc4:	0c 93       	cmp	#0,	r12	;r3 As==00
    9fc6:	23 20       	jnz	$+72     	;abs 0xa00e

00009fc8 <.Loc.440.3>:
    sx1278SetRegister(devp, RegPacketConfig2, 
        0x40 | (devp->config->length >> 8));
    9fc8:	1c 41 02 00 	mov	2(r1),	r12	;
    9fcc:	2c 4c       	mov	@r12,	r12	;
    9fce:	1c 4c 2e 00 	mov	46(r12),r12	;0x0002e
    9fd2:	5c 0f       	rrum	#4,	r12	;
    9fd4:	5c 0f       	rrum	#4,	r12	;

00009fd6 <.Loc.439.3>:
  reg |= packet_config->crc << 4;
  
  sx1278SetRegister(devp, RegPacketConfig1, reg);
  
  if (packet_config->format == Fixed) {
    sx1278SetRegister(devp, RegPacketConfig2, 
    9fd6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9fda:	7c d0 40 00 	bis.b	#64,	r12	;#0x0040
    9fde:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9fe2:	4e 4c       	mov.b	r12,	r14	;
    9fe4:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    9fe8:	1c 41 02 00 	mov	2(r1),	r12	;
    9fec:	b0 12 3e 97 	call	#38718		;#0x973e

00009ff0 <.Loc.441.3>:
        0x40 | (devp->config->length >> 8));
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    9ff0:	1c 41 02 00 	mov	2(r1),	r12	;
    9ff4:	2c 4c       	mov	@r12,	r12	;
    9ff6:	1c 4c 2e 00 	mov	46(r12),r12	;0x0002e
    9ffa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9ffe:	4e 4c       	mov.b	r12,	r14	;
    a000:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    a004:	1c 41 02 00 	mov	2(r1),	r12	;
    a008:	b0 12 3e 97 	call	#38718		;#0x973e

0000a00c <.Loc.447.3>:
  }
  else {
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
  }
}
    a00c:	0f 3c       	jmp	$+32     	;abs 0xa02c

0000a00e <.L81>:
    sx1278SetRegister(devp, RegPacketConfig2, 
        0x40 | (devp->config->length >> 8));
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
  }
  else {
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    a00e:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    a012:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    a016:	1c 41 02 00 	mov	2(r1),	r12	;
    a01a:	b0 12 3e 97 	call	#38718		;#0x973e

0000a01e <.Loc.445.3>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    a01e:	4e 43       	clr.b	r14		;
    a020:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    a024:	1c 41 02 00 	mov	2(r1),	r12	;
    a028:	b0 12 3e 97 	call	#38718		;#0x973e

0000a02c <.L84>:
  }
}
    a02c:	03 43       	nop			
    a02e:	31 50 06 00 	add	#6,	r1	;
    a032:	30 41       	ret			

0000a034 <sx1278BlockTimeout>:

static msg_t sx1278BlockTimeout(SX1278Driver *devp, SX1278IRQConstants irq, 
    uint8_t edge, systime_t timeout) {
    a034:	0a 15       	pushm	#1,	r10	;16-bit words

0000a036 <L0>:
    a036:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000a03a <.LCFI22>:
    a03a:	81 4c 04 00 	mov	r12,	4(r1)	;
    a03e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    a042:	c1 4e 02 00 	mov.b	r14,	2(r1)	;
    a046:	81 4f 00 00 	mov	r15,	0(r1)	;

0000a04a <.Loc.457.3>:
  uint8_t reg;
  uint8_t bit;
  
  osalDbgAssert (irq < IRQMax, "IRQ source not supported");
  
  dio_index = devp->config->irq_map[irq];
    a04a:	1c 41 04 00 	mov	4(r1),	r12	;
    a04e:	2d 4c       	mov	@r12,	r13	;
    a050:	5c 41 03 00 	mov.b	3(r1),	r12	;
    a054:	0c 5d       	add	r13,	r12	;
    a056:	3c 50 1a 00 	add	#26,	r12	;#0x001a
    a05a:	e1 4c 09 00 	mov.b	@r12,	9(r1)	;

0000a05e <.Loc.459.3>:
  
  if (dio_index > 5 || devp->config->dio_map[dio_index] == PAL_NOLINE) {
    a05e:	7c 40 05 00 	mov.b	#5,	r12	;
    a062:	5c 91 09 00 	cmp.b	9(r1),	r12	;
    a066:	0c 28       	jnc	$+26     	;abs 0xa080

0000a068 <.Loc.459.3>:
    a068:	1c 41 04 00 	mov	4(r1),	r12	;
    a06c:	2d 4c       	mov	@r12,	r13	;
    a06e:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a072:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a076:	0c 5c       	rla	r12		;
    a078:	0c 5d       	add	r13,	r12	;
    a07a:	2c 4c       	mov	@r12,	r12	;
    a07c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a07e:	68 20       	jnz	$+210    	;abs 0xa150

0000a080 <.L86>:
    /* BusyWait on SPI */
    if (irqbits[irq] > 7) {
    a080:	5c 41 03 00 	mov.b	3(r1),	r12	;
    a084:	5c 4c 6c 50 	mov.b	20588(r12),r12	;0x0506c
    a088:	7d 40 07 00 	mov.b	#7,	r13	;
    a08c:	4d 9c       	cmp.b	r12,	r13	;
    a08e:	10 2c       	jc	$+34     	;abs 0xa0b0

0000a090 <.Loc.462.3>:
      reg = RegIrqFlags2;
    a090:	f1 40 3f 00 	mov.b	#63,	11(r1)	;#0x003f, 0x000b
    a094:	0b 00 

0000a096 <.Loc.463.3>:
      bit = (1 << (irqbits[irq] >> 8));
    a096:	5c 41 03 00 	mov.b	3(r1),	r12	;
    a09a:	5c 4c 6c 50 	mov.b	20588(r12),r12	;0x0506c
    a09e:	0d 4c       	mov	r12,	r13	;
    a0a0:	47 18 0d 11 	rpt #8 { rrax.w	r13		;
    a0a4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a0a6:	b0 12 3e c2 	call	#49726		;#0xc23e
    a0aa:	c1 4c 0a 00 	mov.b	r12,	10(r1)	; 0x000a
    a0ae:	0d 3c       	jmp	$+28     	;abs 0xa0ca

0000a0b0 <.L88>:
    }
    else {
      reg = RegIrqFlags1;
    a0b0:	f1 40 3e 00 	mov.b	#62,	11(r1)	;#0x003e, 0x000b
    a0b4:	0b 00 

0000a0b6 <.Loc.467.3>:
      bit = (1 << irqbits[irq]);
    a0b6:	5c 41 03 00 	mov.b	3(r1),	r12	;
    a0ba:	5c 4c 6c 50 	mov.b	20588(r12),r12	;0x0506c
    a0be:	0d 4c       	mov	r12,	r13	;
    a0c0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a0c2:	b0 12 3e c2 	call	#49726		;#0xc23e
    a0c6:	c1 4c 0a 00 	mov.b	r12,	10(r1)	; 0x000a

0000a0ca <.L89>:
    }
    systime_t start = osalOsGetSystemTimeX();
    a0ca:	b0 12 62 96 	call	#38498		;#0x9662
    a0ce:	81 4c 06 00 	mov	r12,	6(r1)	;

0000a0d2 <.Loc.470.3>:
    while ((!(sx1278ReadRegister(devp, reg) & bit)) == 
    a0d2:	1b 3c       	jmp	$+56     	;abs 0xa10a

0000a0d4 <.L93>:
        (edge == PAL_EVENT_MODE_RISING_EDGE)) {
      if (timeout == TIME_IMMEDIATE) return MSG_TIMEOUT;
    a0d4:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    a0d8:	02 20       	jnz	$+6      	;abs 0xa0de

0000a0da <.Loc.472.3>:
    a0da:	3c 43       	mov	#-1,	r12	;r3 As==11
    a0dc:	ae 3c       	jmp	$+350    	;abs 0xa23a

0000a0de <.L91>:
      if (timeout != TIME_INFINITE && 
    a0de:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    a0e2:	13 24       	jz	$+40     	;abs 0xa10a

0000a0e4 <.Loc.474.3>:
          !osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, start+timeout)) {
    a0e4:	b0 12 62 96 	call	#38498		;#0x9662
    a0e8:	1d 41 06 00 	mov	6(r1),	r13	;
    a0ec:	2d 51       	add	@r1,	r13	;
    a0ee:	0e 4d       	mov	r13,	r14	;
    a0f0:	1d 41 06 00 	mov	6(r1),	r13	;
    a0f4:	b0 12 68 96 	call	#38504		;#0x9668
    a0f8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a0fc:	5c e3       	xor.b	#1,	r12	;r3 As==01
    a0fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a102 <.Loc.473.3>:
    }
    systime_t start = osalOsGetSystemTimeX();
    while ((!(sx1278ReadRegister(devp, reg) & bit)) == 
        (edge == PAL_EVENT_MODE_RISING_EDGE)) {
      if (timeout == TIME_IMMEDIATE) return MSG_TIMEOUT;
      if (timeout != TIME_INFINITE && 
    a102:	0c 93       	cmp	#0,	r12	;r3 As==00
    a104:	02 24       	jz	$+6      	;abs 0xa10a

0000a106 <.Loc.475.3>:
          !osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, start+timeout)) {
        return MSG_TIMEOUT;
    a106:	3c 43       	mov	#-1,	r12	;r3 As==11
    a108:	98 3c       	jmp	$+306    	;abs 0xa23a

0000a10a <.L90>:
    else {
      reg = RegIrqFlags1;
      bit = (1 << irqbits[irq]);
    }
    systime_t start = osalOsGetSystemTimeX();
    while ((!(sx1278ReadRegister(devp, reg) & bit)) == 
    a10a:	5d 41 0b 00 	mov.b	11(r1),	r13	;0x0000b
    a10e:	1c 41 04 00 	mov	4(r1),	r12	;
    a112:	b0 12 f2 96 	call	#38642		;#0x96f2
    a116:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a11a:	5c f1 0a 00 	and.b	10(r1),	r12	;0x0000a
    a11e:	4d 4c       	mov.b	r12,	r13	;
    a120:	0c 43       	clr	r12		;
    a122:	0c 8d       	sub	r13,	r12	;
    a124:	5c 03       	rrum	#1,	r12	;
    a126:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    a12a:	4d 4c       	mov.b	r12,	r13	;
    a12c:	5c 41 02 00 	mov.b	2(r1),	r12	;
    a130:	5c e3       	xor.b	#1,	r12	;r3 As==01
    a132:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a136:	3c 53       	add	#-1,	r12	;r3 As==11
    a138:	5c 03       	rrum	#1,	r12	;
    a13a:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    a13e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a142:	4c ed       	xor.b	r13,	r12	;
    a144:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a148:	0c 93       	cmp	#0,	r12	;r3 As==00
    a14a:	c4 23       	jnz	$-118    	;abs 0xa0d4

0000a14c <.Loc.479.3>:
          !osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, start+timeout)) {
        return MSG_TIMEOUT;
      }
    }
    
    return MSG_OK;
    a14c:	4c 43       	clr.b	r12		;
    a14e:	75 3c       	jmp	$+236    	;abs 0xa23a

0000a150 <.L87>:
  else {
    /* Block on interrupt, yield CPU */
#if SX1278_SHARED_SPI
    spiReleaseBus(devp->config->spip);
#endif
    osalSysLock();
    a150:	b0 12 32 96 	call	#38450		;#0x9632

0000a154 <.Loc.487.3>:
    palLineEnableEventI(devp->config->dio_map[dio_index], edge, blocking_callback); 
    a154:	1c 41 04 00 	mov	4(r1),	r12	;
    a158:	2d 4c       	mov	@r12,	r13	;
    a15a:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a15e:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a162:	0c 5c       	rla	r12		;
    a164:	0c 5d       	add	r13,	r12	;
    a166:	2c 4c       	mov	@r12,	r12	;
    a168:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    a16c:	0a 4c       	mov	r12,	r10	;
    a16e:	1c 41 04 00 	mov	4(r1),	r12	;
    a172:	2d 4c       	mov	@r12,	r13	;
    a174:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a178:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a17c:	0c 5c       	rla	r12		;
    a17e:	0c 5d       	add	r13,	r12	;
    a180:	2c 4c       	mov	@r12,	r12	;
    a182:	5c 03       	rrum	#1,	r12	;
    a184:	4a 18 0c 11 	rpt #11 { rrax.w	r12		;
    a188:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a18c:	3f 40 dc 96 	mov	#38620,	r15	;#0x96dc
    a190:	5e 41 02 00 	mov.b	2(r1),	r14	;
    a194:	4d 4c       	mov.b	r12,	r13	;
    a196:	0c 4a       	mov	r10,	r12	;
    a198:	b0 12 32 84 	call	#33842		;#0x8432

0000a19c <.Loc.488.3>:
    if (palReadLine(devp->config->dio_map[dio_index])) {
    a19c:	1c 41 04 00 	mov	4(r1),	r12	;
    a1a0:	2d 4c       	mov	@r12,	r13	;
    a1a2:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a1a6:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a1aa:	0c 5c       	rla	r12		;
    a1ac:	0c 5d       	add	r13,	r12	;
    a1ae:	2c 4c       	mov	@r12,	r12	;
    a1b0:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    a1b4:	2e 4c       	mov	@r12,	r14	;
    a1b6:	1c 41 04 00 	mov	4(r1),	r12	;
    a1ba:	2d 4c       	mov	@r12,	r13	;
    a1bc:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a1c0:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a1c4:	0c 5c       	rla	r12		;
    a1c6:	0c 5d       	add	r13,	r12	;
    a1c8:	2c 4c       	mov	@r12,	r12	;
    a1ca:	0d 4c       	mov	r12,	r13	;
    a1cc:	5d 03       	rrum	#1,	r13	;
    a1ce:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    a1d2:	0c 4e       	mov	r14,	r12	;
    a1d4:	b0 12 46 c3 	call	#49990		;#0xc346
    a1d8:	5c f3       	and.b	#1,	r12	;r3 As==01
    a1da:	0c 93       	cmp	#0,	r12	;r3 As==00
    a1dc:	03 24       	jz	$+8      	;abs 0xa1e4

0000a1de <.Loc.489.3>:
      suspend_result = MSG_OK;
    a1de:	82 43 b0 5c 	mov	#0,	&0x5cb0	;r3 As==00
    a1e2:	07 3c       	jmp	$+16     	;abs 0xa1f2

0000a1e4 <.L94>:
    }
    else {
      suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    a1e4:	2d 41       	mov	@r1,	r13	;
    a1e6:	3c 40 ae 5c 	mov	#23726,	r12	;#0x5cae
    a1ea:	b0 12 aa 96 	call	#38570		;#0x96aa
    a1ee:	82 4c b0 5c 	mov	r12,	&0x5cb0	;

0000a1f2 <.L95>:
    }
    
    /* Disable interrupt */
    palLineDisableEventI(devp->config->dio_map[dio_index]);
    a1f2:	1c 41 04 00 	mov	4(r1),	r12	;
    a1f6:	2d 4c       	mov	@r12,	r13	;
    a1f8:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a1fc:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a200:	0c 5c       	rla	r12		;
    a202:	0c 5d       	add	r13,	r12	;
    a204:	2c 4c       	mov	@r12,	r12	;
    a206:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    a20a:	0e 4c       	mov	r12,	r14	;
    a20c:	1c 41 04 00 	mov	4(r1),	r12	;
    a210:	2d 4c       	mov	@r12,	r13	;
    a212:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a216:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a21a:	0c 5c       	rla	r12		;
    a21c:	0c 5d       	add	r13,	r12	;
    a21e:	2c 4c       	mov	@r12,	r12	;
    a220:	5c 03       	rrum	#1,	r12	;
    a222:	4a 18 0c 11 	rpt #11 { rrax.w	r12		;
    a226:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a22a:	4d 4c       	mov.b	r12,	r13	;
    a22c:	0c 4e       	mov	r14,	r12	;
    a22e:	b0 12 48 85 	call	#34120		;#0x8548

0000a232 <.Loc.497.3>:
    osalSysUnlock();
    a232:	b0 12 3e 96 	call	#38462		;#0x963e

0000a236 <.Loc.504.3>:
#if SX1278_SHARED_SPI
    spiAcquireBus(devp->config->spip);
    spiStart(devp->config->spip);
#endif
    
    return suspend_result;
    a236:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0

0000a23a <.L92>:
  }
}
    a23a:	31 50 0c 00 	add	#12,	r1	;#0x000c
    a23e:	0a 17       	popm	#1,	r10	;16-bit words
    a240:	30 41       	ret			

0000a242 <sx1278SendPacket>:

static msg_t sx1278SendPacket(SX1278Driver *devp, uint8_t *buf, 
    SX1278_LENGTH_TYPE len, systime_t timeout) {
    a242:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000a246 <.LCFI23>:
    a246:	81 4c 06 00 	mov	r12,	6(r1)	;
    a24a:	81 4d 04 00 	mov	r13,	4(r1)	;

0000a24e <L0>:
    a24e:	81 4e 02 00 	mov	r14,	2(r1)	;
    a252:	81 4f 00 00 	mov	r15,	0(r1)	;

0000a256 <.Loc.510.3>:
  SX1278_LENGTH_TYPE index = 0;
    a256:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a

0000a25a <.L101>:
  uint8_t towrite;
  
  do {
    /* Fill the FIFO */
    /* At least 75% is available, so write max(75%, packet size) */
    towrite = (len - index > 64 ? 48 : len - index);
    a25a:	1d 41 02 00 	mov	2(r1),	r13	;
    a25e:	1d 81 0a 00 	sub	10(r1),	r13	;0x0000a
    a262:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    a266:	0c 9d       	cmp	r13,	r12	;
    a268:	0c 28       	jnc	$+26     	;abs 0xa282

0000a26a <.Loc.516.3>:
    a26a:	1c 41 02 00 	mov	2(r1),	r12	;
    a26e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a272:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    a276:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a27a:	4c 8d       	sub.b	r13,	r12	;
    a27c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a280:	02 3c       	jmp	$+6      	;abs 0xa286

0000a282 <.L97>:
    a282:	7c 40 30 00 	mov.b	#48,	r12	;#0x0030

0000a286 <.L98>:
    a286:	c1 4c 09 00 	mov.b	r12,	9(r1)	;

0000a28a <.Loc.517.3>:
    sx1278SetRegisters(devp, RegFifo, buf + index, towrite);
    a28a:	1c 41 04 00 	mov	4(r1),	r12	;
    a28e:	1c 51 0a 00 	add	10(r1),	r12	;0x0000a
    a292:	5f 41 09 00 	mov.b	9(r1),	r15	;
    a296:	0e 4c       	mov	r12,	r14	;
    a298:	4d 43       	clr.b	r13		;
    a29a:	1c 41 06 00 	mov	6(r1),	r12	;
    a29e:	b0 12 96 97 	call	#38806		;#0x9796

0000a2a2 <.Loc.518.3>:
    index += towrite;
    a2a2:	5c 41 09 00 	mov.b	9(r1),	r12	;
    a2a6:	81 5c 0a 00 	add	r12,	10(r1)	; 0x000a

0000a2aa <.Loc.521.3>:
    
    /* Wait until we see a FifoLevel falling edge */
    BLOCK_RETURN_ERROR(
    a2aa:	2f 41       	mov	@r1,	r15	;
    a2ac:	6e 43       	mov.b	#2,	r14	;r3 As==10
    a2ae:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a2b0:	1c 41 06 00 	mov	6(r1),	r12	;
    a2b4:	b0 12 34 a0 	call	#41012		;#0xa034
    a2b8:	82 4c b0 5c 	mov	r12,	&0x5cb0	;
    a2bc:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0
    a2c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    a2c2:	07 24       	jz	$+16     	;abs 0xa2d2

0000a2c4 <.Loc.521.3>:
    a2c4:	1c 41 06 00 	mov	6(r1),	r12	;
    a2c8:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    a2cc:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0
    a2d0:	19 3c       	jmp	$+52     	;abs 0xa304

0000a2d2 <.L99>:
      sx1278BlockTimeout(devp, FifoLevel, PAL_EVENT_MODE_FALLING_EDGE, timeout)
      );
  } while(index < len);
    a2d2:	91 91 02 00 	cmp	2(r1),	10(r1)	; 0x000a
    a2d6:	0a 00 
    a2d8:	c0 2b       	jnc	$-126    	;abs 0xa25a

0000a2da <.Loc.527.3>:
  
  /* Wait until we see a PacketSent rising edge */
  BLOCK_RETURN_ERROR(
    a2da:	2f 41       	mov	@r1,	r15	;
    a2dc:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a2de:	4d 43       	clr.b	r13		;
    a2e0:	1c 41 06 00 	mov	6(r1),	r12	;
    a2e4:	b0 12 34 a0 	call	#41012		;#0xa034
    a2e8:	82 4c b0 5c 	mov	r12,	&0x5cb0	;
    a2ec:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0
    a2f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    a2f2:	07 24       	jz	$+16     	;abs 0xa302

0000a2f4 <.Loc.527.3>:
    a2f4:	1c 41 06 00 	mov	6(r1),	r12	;
    a2f8:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    a2fc:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0
    a300:	01 3c       	jmp	$+4      	;abs 0xa304

0000a302 <.L102>:
    sx1278BlockTimeout(devp, PacketSent, PAL_EVENT_MODE_RISING_EDGE, timeout)
    );
  
  return MSG_OK;
    a302:	4c 43       	clr.b	r12		;

0000a304 <.L100>:
}
    a304:	31 50 0c 00 	add	#12,	r1	;#0x000c
    a308:	30 41       	ret			

0000a30a <sx1278ObjectInit>:
 *
 * @param[out] devp     pointer to the @p SX1278Driver object
 *
 * @init
 */
void sx1278ObjectInit(SX1278Driver *devp) {
    a30a:	21 83       	decd	r1		;

0000a30c <.LCFI24>:
    a30c:	81 4c 00 00 	mov	r12,	0(r1)	;

0000a310 <L0>:
  
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    a310:	2c 41       	mov	@r1,	r12	;
    a312:	fc 40 09 00 	mov.b	#9,	3(r12)	;
    a316:	03 00 

0000a318 <.Loc.549.3>:
  devp->regs.seq_config = 0x00;
    a318:	2c 41       	mov	@r1,	r12	;
    a31a:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

0000a31e <.Loc.551.3>:
  
  devp->state = SX1278_STOP;
    a31e:	2c 41       	mov	@r1,	r12	;
    a320:	dc 43 02 00 	mov.b	#1,	2(r12)	;r3 As==01

0000a324 <.Loc.552.3>:
}
    a324:	03 43       	nop			
    a326:	21 53       	incd	r1		;
    a328:	30 41       	ret			

0000a32a <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    a32a:	21 82       	sub	#4,	r1	;r2 As==10

0000a32c <.LCFI25>:
    a32c:	81 4c 02 00 	mov	r12,	2(r1)	;
    a330:	81 4d 00 00 	mov	r13,	0(r1)	;

0000a334 <.Loc.564.3>:
  
  devp->config = config;
    a334:	1c 41 02 00 	mov	2(r1),	r12	;
    a338:	ac 41 00 00 	mov	@r1,	0(r12)	;

0000a33c <.Loc.566.3>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    a33c:	1c 41 02 00 	mov	2(r1),	r12	;
    a340:	b0 12 5e 9d 	call	#40286		;#0x9d5e

0000a344 <.Loc.571.3>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    a344:	2c 41       	mov	@r1,	r12	;
    a346:	2c 4c       	mov	@r12,	r12	;
    a348:	2d 41       	mov	@r1,	r13	;
    a34a:	1d 4d 02 00 	mov	2(r13),	r13	;
    a34e:	b0 12 64 77 	call	#30564		;#0x7764

0000a352 <.Loc.573.3>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, Sleep);
    a352:	4d 43       	clr.b	r13		;
    a354:	1c 41 02 00 	mov	2(r1),	r12	;
    a358:	b0 12 52 9e 	call	#40530		;#0x9e52

0000a35c <.Loc.575.3>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    a35c:	2c 41       	mov	@r1,	r12	;
    a35e:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    a362:	1c 4c 08 00 	mov	8(r12),	r12	;
    a366:	0e 4d       	mov	r13,	r14	;
    a368:	0d 4c       	mov	r12,	r13	;
    a36a:	1c 41 02 00 	mov	2(r1),	r12	;
    a36e:	b0 12 dc 98 	call	#39132		;#0x98dc

0000a372 <.Loc.576.3>:
  sx1278SetDeviation(devp, config->fdev);
    a372:	2c 41       	mov	@r1,	r12	;
    a374:	1d 4c 0e 00 	mov	14(r12),r13	;0x0000e
    a378:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    a37c:	0e 4d       	mov	r13,	r14	;
    a37e:	0d 4c       	mov	r12,	r13	;
    a380:	1c 41 02 00 	mov	2(r1),	r12	;
    a384:	b0 12 82 98 	call	#39042		;#0x9882

0000a388 <.Loc.577.3>:
  sx1278SetBitrate(devp, config->bitrate);
    a388:	2c 41       	mov	@r1,	r12	;
    a38a:	1d 4c 06 00 	mov	6(r12),	r13	;
    a38e:	1c 4c 04 00 	mov	4(r12),	r12	;
    a392:	0e 4d       	mov	r13,	r14	;
    a394:	0d 4c       	mov	r12,	r13	;
    a396:	1c 41 02 00 	mov	2(r1),	r12	;
    a39a:	b0 12 f8 97 	call	#38904		;#0x97f8

0000a39e <.Loc.578.3>:
  sx1278SetPower(devp, config->pow);
    a39e:	2c 41       	mov	@r1,	r12	;
    a3a0:	1e 4c 10 00 	mov	16(r12),r14	;0x00010
    a3a4:	1f 4c 12 00 	mov	18(r12),r15	;0x00012
    a3a8:	0d 4e       	mov	r14,	r13	;
    a3aa:	0e 4f       	mov	r15,	r14	;
    a3ac:	1c 41 02 00 	mov	2(r1),	r12	;
    a3b0:	b0 12 3c 9a 	call	#39484		;#0x9a3c

0000a3b4 <.Loc.579.3>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    a3b4:	2c 41       	mov	@r1,	r12	;
    a3b6:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    a3ba:	0d 4c       	mov	r12,	r13	;
    a3bc:	1c 41 02 00 	mov	2(r1),	r12	;
    a3c0:	b0 12 5e 9c 	call	#40030		;#0x9c5e

0000a3c4 <.Loc.580.3>:
  sx1278SetSync(devp, config->sync_word);
    a3c4:	2c 41       	mov	@r1,	r12	;
    a3c6:	1d 4c 18 00 	mov	24(r12),r13	;0x00018
    a3ca:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    a3ce:	0e 4d       	mov	r13,	r14	;
    a3d0:	0d 4c       	mov	r12,	r13	;
    a3d2:	1c 41 02 00 	mov	2(r1),	r12	;
    a3d6:	b0 12 9a 9c 	call	#40090		;#0x9c9a

0000a3da <.Loc.586.3>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 and LowPowerSelection
  Don't set SequencerStart, SequencerStop, FromTransmit
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x1C;
    a3da:	1c 41 02 00 	mov	2(r1),	r12	;
    a3de:	fc 40 1c 00 	mov.b	#28,	4(r12)	;#0x001c
    a3e2:	04 00 

0000a3e4 <.Loc.591.3>:
  
  osalDbgAssert(devp->config->idle_mode == Sleep ||
      devp->config->idle_mode == Stdby, "Unsupported Idle Mode requested");
  
  if (devp->config->idle_mode == Sleep) {
    a3e4:	1c 41 02 00 	mov	2(r1),	r12	;
    a3e8:	2c 4c       	mov	@r12,	r12	;
    a3ea:	5c 4c 30 00 	mov.b	48(r12),r12	;0x00030
    a3ee:	0c 93       	cmp	#0,	r12	;r3 As==00
    a3f0:	0b 20       	jnz	$+24     	;abs 0xa408

0000a3f2 <.Loc.592.3>:
    devp->regs.seq_config |= 0x20;
    a3f2:	1c 41 02 00 	mov	2(r1),	r12	;
    a3f6:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a3fa:	7c d0 20 00 	bis.b	#32,	r12	;#0x0020
    a3fe:	4d 4c       	mov.b	r12,	r13	;
    a400:	1c 41 02 00 	mov	2(r1),	r12	;
    a404:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a408 <.L105>:
  }
  /* else Stdby is assumed */
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    a408:	1c 41 02 00 	mov	2(r1),	r12	;
    a40c:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a410:	4e 4c       	mov.b	r12,	r14	;
    a412:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    a416:	1c 41 02 00 	mov	2(r1),	r12	;
    a41a:	b0 12 3e 97 	call	#38718		;#0x973e

0000a41e <.Loc.598.3>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    a41e:	1c 41 02 00 	mov	2(r1),	r12	;
    a422:	2c 4c       	mov	@r12,	r12	;
    a424:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a428:	0d 4c       	mov	r12,	r13	;
    a42a:	1c 41 02 00 	mov	2(r1),	r12	;
    a42e:	b0 12 1c 9f 	call	#40732		;#0x9f1c

0000a432 <.Loc.600.3>:
  
  sx1278MapIRQs(devp, devp->config->irq_map);
    a432:	1c 41 02 00 	mov	2(r1),	r12	;
    a436:	2c 4c       	mov	@r12,	r12	;
    a438:	3c 50 1a 00 	add	#26,	r12	;#0x001a
    a43c:	0d 4c       	mov	r12,	r13	;
    a43e:	1c 41 02 00 	mov	2(r1),	r12	;
    a442:	b0 12 9c 9e 	call	#40604		;#0x9e9c

0000a446 <.Loc.606.3>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    a446:	1c 41 02 00 	mov	2(r1),	r12	;
    a44a:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10

0000a44e <.Loc.607.3>:
}
    a44e:	03 43       	nop			
    a450:	21 52       	add	#4,	r1	;r2 As==10
    a452:	30 41       	ret			

0000a454 <sx1278Send>:
 *                 if used.
 *                 
 * @api
 */
msg_t sx1278Send(SX1278Driver *devp, uint8_t *buf, SX1278_LENGTH_TYPE len, 
    systime_t timeout) {
    a454:	0a 15       	pushm	#1,	r10	;16-bit words

0000a456 <.LCFI28>:
    a456:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000a45a <.LCFI29>:
    a45a:	81 4c 06 00 	mov	r12,	6(r1)	;
    a45e:	81 4d 04 00 	mov	r13,	4(r1)	;
    a462:	81 4e 02 00 	mov	r14,	2(r1)	;
    a466:	81 4f 00 00 	mov	r15,	0(r1)	;

0000a46a <.Loc.677.3>:
  
  osalDbgAssert(devp->state == SX1278_IDLE || devp->state == SX1278_SLEEP, 
      "State machine error!");
  
  devp->state = SX1278_ACTIVE;
    a46a:	1c 41 06 00 	mov	6(r1),	r12	;
    a46e:	fc 40 03 00 	mov.b	#3,	2(r12)	;
    a472:	02 00 

0000a474 <.Loc.679.3>:
  
  if (devp->config->packet_config->format == Fixed) {
    a474:	1c 41 06 00 	mov	6(r1),	r12	;
    a478:	2c 4c       	mov	@r12,	r12	;
    a47a:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a47e:	6c 4c       	mov.b	@r12,	r12	;
    a480:	7c f0 03 00 	and.b	#3,	r12	;
    a484:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a488:	0c 93       	cmp	#0,	r12	;r3 As==00
    a48a:	16 20       	jnz	$+46     	;abs 0xa4b8

0000a48c <.Loc.683.3>:
    osalDbgAssert(len == devp->config->length, "Fixed packet wrong length");
    
    /* Tack on address if used */
    if (devp->config->packet_config->addressing) {
    a48c:	1c 41 06 00 	mov	6(r1),	r12	;
    a490:	2c 4c       	mov	@r12,	r12	;
    a492:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a496:	6c 4c       	mov.b	@r12,	r12	;
    a498:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    a49c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a4a0:	0c 93       	cmp	#0,	r12	;r3 As==00
    a4a2:	84 24       	jz	$+266    	;abs 0xa5ac

0000a4a4 <.Loc.684.3>:
      buf[0] = devp->config->addr;
    a4a4:	1c 41 06 00 	mov	6(r1),	r12	;
    a4a8:	2c 4c       	mov	@r12,	r12	;
    a4aa:	5d 4c 2c 00 	mov.b	44(r12),r13	;0x0002c
    a4ae:	1c 41 04 00 	mov	4(r1),	r12	;
    a4b2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    a4b6:	7a 3c       	jmp	$+246    	;abs 0xa5ac

0000a4b8 <.L109>:
    }
  }
  
  else if (devp->config->packet_config->format == Variable) {
    a4b8:	1c 41 06 00 	mov	6(r1),	r12	;
    a4bc:	2c 4c       	mov	@r12,	r12	;
    a4be:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a4c2:	6c 4c       	mov.b	@r12,	r12	;
    a4c4:	7c f0 03 00 	and.b	#3,	r12	;
    a4c8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a4cc:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    a4ce:	21 20       	jnz	$+68     	;abs 0xa512

0000a4d0 <.Loc.692.3>:
    osalDbgAssert(len <= 256, "Variable length packet too large");
    
    /* Calculate length byte */
    buf[0] = (len-1);
    a4d0:	1c 41 02 00 	mov	2(r1),	r12	;
    a4d4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a4d8:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a4da:	4d 4c       	mov.b	r12,	r13	;
    a4dc:	1c 41 04 00 	mov	4(r1),	r12	;
    a4e0:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000a4e4 <.Loc.695.3>:
    
    /* Tack on address if used */
    if (devp->config->packet_config->addressing) {
    a4e4:	1c 41 06 00 	mov	6(r1),	r12	;
    a4e8:	2c 4c       	mov	@r12,	r12	;
    a4ea:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a4ee:	6c 4c       	mov.b	@r12,	r12	;
    a4f0:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    a4f4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a4f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    a4fa:	58 24       	jz	$+178    	;abs 0xa5ac

0000a4fc <.Loc.696.3>:
      buf[1] = devp->config->addr;
    a4fc:	1c 41 04 00 	mov	4(r1),	r12	;
    a500:	1c 53       	inc	r12		;
    a502:	1d 41 06 00 	mov	6(r1),	r13	;
    a506:	2d 4d       	mov	@r13,	r13	;
    a508:	5d 4d 2c 00 	mov.b	44(r13),r13	;0x0002c
    a50c:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    a510:	4d 3c       	jmp	$+156    	;abs 0xa5ac

0000a512 <.L112>:
    }
  }
  
  else if (devp->config->packet_config->format == Unlimited) {
    a512:	1c 41 06 00 	mov	6(r1),	r12	;
    a516:	2c 4c       	mov	@r12,	r12	;
    a518:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a51c:	6c 4c       	mov.b	@r12,	r12	;
    a51e:	7c f0 03 00 	and.b	#3,	r12	;
    a522:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a526:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    a528:	41 20       	jnz	$+132    	;abs 0xa5ac

0000a52a <.Loc.703.3>:
    /* TODO document that length is the length offset */
      
    if (devp->config->packet_config->length) {
    a52a:	1c 41 06 00 	mov	6(r1),	r12	;
    a52e:	2c 4c       	mov	@r12,	r12	;
    a530:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a534:	6c 4c       	mov.b	@r12,	r12	;
    a536:	7c f0 80 ff 	and.b	#65408,	r12	;#0xff80
    a53a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a53e:	0c 93       	cmp	#0,	r12	;r3 As==00
    a540:	20 24       	jz	$+66     	;abs 0xa582

0000a542 <.LBB5>:
          devp->config->length > 0, "Length offset conflicts with address");
      
      /* Insert length value */
      /* Send length in network byte order - big endian */
      /* This should work regardless of host endianness */
      for (int i = sizeof(len)-1; i >= 0; i--) {
    a542:	91 43 08 00 	mov	#1,	8(r1)	;r3 As==01
    a546:	1a 3c       	jmp	$+54     	;abs 0xa57c

0000a548 <.L116>:
        buf[devp->config->length + i] = (len >> (8 * i)) & 0xFFu;
    a548:	1c 41 06 00 	mov	6(r1),	r12	;
    a54c:	2c 4c       	mov	@r12,	r12	;
    a54e:	1d 4c 2e 00 	mov	46(r12),r13	;0x0002e
    a552:	1c 41 08 00 	mov	8(r1),	r12	;
    a556:	0c 5d       	add	r13,	r12	;
    a558:	1a 41 04 00 	mov	4(r1),	r10	;
    a55c:	0a 5c       	add	r12,	r10	;
    a55e:	1c 41 08 00 	mov	8(r1),	r12	;
    a562:	b0 12 32 c2 	call	#49714		;#0xc232
    a566:	0d 4c       	mov	r12,	r13	;
    a568:	1c 41 02 00 	mov	2(r1),	r12	;
    a56c:	b0 12 46 c3 	call	#49990		;#0xc346
    a570:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a574:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

0000a578 <.Loc.711.3>:
          devp->config->length > 0, "Length offset conflicts with address");
      
      /* Insert length value */
      /* Send length in network byte order - big endian */
      /* This should work regardless of host endianness */
      for (int i = sizeof(len)-1; i >= 0; i--) {
    a578:	b1 53 08 00 	add	#-1,	8(r1)	;r3 As==11

0000a57c <.L115>:
    a57c:	81 93 08 00 	cmp	#0,	8(r1)	;r3 As==00
    a580:	e3 37       	jge	$-56     	;abs 0xa548

0000a582 <.L114>:
        buf[devp->config->length + i] = (len >> (8 * i)) & 0xFFu;
      }
    }
      
    /* Tack on address if used */
    if (devp->config->packet_config->addressing) {
    a582:	1c 41 06 00 	mov	6(r1),	r12	;
    a586:	2c 4c       	mov	@r12,	r12	;
    a588:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    a58c:	6c 4c       	mov.b	@r12,	r12	;
    a58e:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    a592:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a596:	0c 93       	cmp	#0,	r12	;r3 As==00
    a598:	09 24       	jz	$+20     	;abs 0xa5ac

0000a59a <.Loc.718.3>:
      buf[0] = devp->config->addr;
    a59a:	1c 41 06 00 	mov	6(r1),	r12	;
    a59e:	2c 4c       	mov	@r12,	r12	;
    a5a0:	5d 4c 2c 00 	mov.b	44(r12),r13	;0x0002c
    a5a4:	1c 41 04 00 	mov	4(r1),	r12	;
    a5a8:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000a5ac <.L111>:
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* We're in Sleep or Standby, TLS isn't started yet */
  /* Set FifoThreshold to 25% or packet size, whichever's smaller */
  sx1278SetRegister(devp, RegFifoThresh, (len > 16 ? 15 : len-1));
    a5ac:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    a5b0:	1c 91 02 00 	cmp	2(r1),	r12	;
    a5b4:	08 28       	jnc	$+18     	;abs 0xa5c6

0000a5b6 <.Loc.729.3>:
    a5b6:	1c 41 02 00 	mov	2(r1),	r12	;
    a5ba:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a5be:	7c 53       	add.b	#-1,	r12	;r3 As==11
    a5c0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a5c4:	02 3c       	jmp	$+6      	;abs 0xa5ca

0000a5c6 <.L117>:
    a5c6:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

0000a5ca <.L118>:
    a5ca:	4e 4c       	mov.b	r12,	r14	;
    a5cc:	7d 40 35 00 	mov.b	#53,	r13	;#0x0035
    a5d0:	1c 41 06 00 	mov	6(r1),	r12	;
    a5d4:	b0 12 3e 97 	call	#38718		;#0x973e

0000a5d8 <.Loc.731.3>:
  /* Start TLS */
  devp->regs.seq_config &= ~(0x40);
    a5d8:	1c 41 06 00 	mov	6(r1),	r12	;
    a5dc:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a5e0:	7c f0 bf ff 	and.b	#65471,	r12	;#0xffbf
    a5e4:	4d 4c       	mov.b	r12,	r13	;
    a5e6:	1c 41 06 00 	mov	6(r1),	r12	;
    a5ea:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a5ee <.Loc.732.3>:
  devp->regs.seq_config |= 0x80;
    a5ee:	1c 41 06 00 	mov	6(r1),	r12	;
    a5f2:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a5f6:	7c d0 80 ff 	bis.b	#65408,	r12	;#0xff80
    a5fa:	4d 4c       	mov.b	r12,	r13	;
    a5fc:	1c 41 06 00 	mov	6(r1),	r12	;
    a600:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a604 <.Loc.733.3>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    a604:	1c 41 06 00 	mov	6(r1),	r12	;
    a608:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a60c:	4e 4c       	mov.b	r12,	r14	;
    a60e:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    a612:	1c 41 06 00 	mov	6(r1),	r12	;
    a616:	b0 12 3e 97 	call	#38718		;#0x973e

0000a61a <.Loc.736.3>:
  
  /* Send packet */
  suspend_result = sx1278SendPacket(devp, buf, len, timeout);
    a61a:	2f 41       	mov	@r1,	r15	;
    a61c:	1e 41 02 00 	mov	2(r1),	r14	;
    a620:	1d 41 04 00 	mov	4(r1),	r13	;
    a624:	1c 41 06 00 	mov	6(r1),	r12	;
    a628:	b0 12 42 a2 	call	#41538		;#0xa242
    a62c:	82 4c b0 5c 	mov	r12,	&0x5cb0	;

0000a630 <.Loc.739.3>:
  
  /* Stop TLS */
  devp->regs.seq_config &= ~(0x80);
    a630:	1c 41 06 00 	mov	6(r1),	r12	;
    a634:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a638:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    a63c:	4d 4c       	mov.b	r12,	r13	;
    a63e:	1c 41 06 00 	mov	6(r1),	r12	;
    a642:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a646 <.Loc.740.3>:
  devp->regs.seq_config |= 0x40;
    a646:	1c 41 06 00 	mov	6(r1),	r12	;
    a64a:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a64e:	7c d0 40 00 	bis.b	#64,	r12	;#0x0040
    a652:	4d 4c       	mov.b	r12,	r13	;
    a654:	1c 41 06 00 	mov	6(r1),	r12	;
    a658:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000a65c <.Loc.741.3>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    a65c:	1c 41 06 00 	mov	6(r1),	r12	;
    a660:	5c 4c 04 00 	mov.b	4(r12),	r12	;
    a664:	4e 4c       	mov.b	r12,	r14	;
    a666:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    a66a:	1c 41 06 00 	mov	6(r1),	r12	;
    a66e:	b0 12 3e 97 	call	#38718		;#0x973e

0000a672 <.Loc.747.3>:
  
  /* Restore invariants */
#if SX1278_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
  devp->state = SX1278_IDLE;
    a672:	1c 41 06 00 	mov	6(r1),	r12	;
    a676:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10

0000a67a <.Loc.749.3>:
  
  return suspend_result;
    a67a:	1c 42 b0 5c 	mov	&0x5cb0,r12	;0x5cb0

0000a67e <.Loc.750.3>:
}
    a67e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    a682:	0a 17       	popm	#1,	r10	;16-bit words
    a684:	30 41       	ret			

0000a686 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    a686:	ff 3f       	jmp	$+0      	;abs 0xa686

0000a688 <Vector2>:
    a688:	ff 3f       	jmp	$+0      	;abs 0xa688

0000a68a <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    a68a:	ff 3f       	jmp	$+0      	;abs 0xa68a

0000a68c <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    a68c:	ff 3f       	jmp	$+0      	;abs 0xa68c

0000a68e <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    a68e:	ff 3f       	jmp	$+0      	;abs 0xa68e

0000a690 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    a690:	ff 3f       	jmp	$+0      	;abs 0xa690

0000a692 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    a692:	ff 3f       	jmp	$+0      	;abs 0xa692

0000a694 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    a694:	ff 3f       	jmp	$+0      	;abs 0xa694

0000a696 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    a696:	ff 3f       	jmp	$+0      	;abs 0xa696

0000a698 <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    a698:	ff 3f       	jmp	$+0      	;abs 0xa698

0000a69a <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    a69a:	ff 3f       	jmp	$+0      	;abs 0xa69a

0000a69c <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    a69c:	ff 3f       	jmp	$+0      	;abs 0xa69c

0000a69e <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    a69e:	ff 3f       	jmp	$+0      	;abs 0xa69e

0000a6a0 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    a6a0:	ff 3f       	jmp	$+0      	;abs 0xa6a0

0000a6a2 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    a6a2:	ff 3f       	jmp	$+0      	;abs 0xa6a2

0000a6a4 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    a6a4:	ff 3f       	jmp	$+0      	;abs 0xa6a4

0000a6a6 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    a6a6:	ff 3f       	jmp	$+0      	;abs 0xa6a6

0000a6a8 <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    a6a8:	ff 3f       	jmp	$+0      	;abs 0xa6a8

0000a6aa <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    a6aa:	ff 3f       	jmp	$+0      	;abs 0xa6aa

0000a6ac <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    a6ac:	ff 3f       	jmp	$+0      	;abs 0xa6ac

0000a6ae <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    a6ae:	ff 3f       	jmp	$+0      	;abs 0xa6ae

0000a6b0 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    a6b0:	ff 3f       	jmp	$+0      	;abs 0xa6b0

0000a6b2 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    a6b2:	ff 3f       	jmp	$+0      	;abs 0xa6b2

0000a6b4 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    a6b4:	ff 3f       	jmp	$+0      	;abs 0xa6b4

0000a6b6 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    a6b6:	ff 3f       	jmp	$+0      	;abs 0xa6b6

0000a6b8 <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    a6b8:	ff 3f       	jmp	$+0      	;abs 0xa6b8

0000a6ba <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    a6ba:	ff 3f       	jmp	$+0      	;abs 0xa6ba

0000a6bc <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    a6bc:	ff 3f       	jmp	$+0      	;abs 0xa6bc

0000a6be <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    a6be:	ff 3f       	jmp	$+0      	;abs 0xa6be

0000a6c0 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    a6c0:	ff 3f       	jmp	$+0      	;abs 0xa6c0

0000a6c2 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    a6c2:	ff 3f       	jmp	$+0      	;abs 0xa6c2

0000a6c4 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    a6c4:	ff 3f       	jmp	$+0      	;abs 0xa6c4

0000a6c6 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    a6c6:	ff 3f       	jmp	$+0      	;abs 0xa6c6

0000a6c8 <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    a6c8:	ff 3f       	jmp	$+0      	;abs 0xa6c8

0000a6ca <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    a6ca:	ff 3f       	jmp	$+0      	;abs 0xa6ca

0000a6cc <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    a6cc:	ff 3f       	jmp	$+0      	;abs 0xa6cc

0000a6ce <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    a6ce:	ff 3f       	jmp	$+0      	;abs 0xa6ce

0000a6d0 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    a6d0:	ff 3f       	jmp	$+0      	;abs 0xa6d0

0000a6d2 <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    a6d2:	ff 3f       	jmp	$+0      	;abs 0xa6d2

0000a6d4 <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    a6d4:	ff 3f       	jmp	$+0      	;abs 0xa6d4

0000a6d6 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    a6d6:	ff 3f       	jmp	$+0      	;abs 0xa6d6

0000a6d8 <Vector48>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    a6d8:	ff 3f       	jmp	$+0      	;abs 0xa6d8

0000a6da <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    a6da:	ff 3f       	jmp	$+0      	;abs 0xa6da

0000a6dc <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    a6dc:	ff 3f       	jmp	$+0      	;abs 0xa6dc

0000a6de <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    a6de:	ff 3f       	jmp	$+0      	;abs 0xa6de

0000a6e0 <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    a6e0:	ff 3f       	jmp	$+0      	;abs 0xa6e0

0000a6e2 <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    a6e2:	ff 3f       	jmp	$+0      	;abs 0xa6e2

0000a6e4 <port_lock>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    a6e4:	32 c2       	dint			

0000a6e6 <L0>:
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
  asm volatile("nop");
    a6e6:	03 43       	nop			

0000a6e8 <.Loc.349.1>:
}
    a6e8:	03 43       	nop			
    a6ea:	30 41       	ret			

0000a6ec <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    a6ec:	03 43       	nop			

0000a6ee <.Loc.356.1>:
  _enable_interrupts();
    a6ee:	32 d2       	eint			
    a6f0:	03 43       	nop			

0000a6f2 <.Loc.357.1>:
}
    a6f2:	03 43       	nop			
    a6f4:	30 41       	ret			

0000a6f6 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    a6f6:	b0 12 e4 a6 	call	#42724		;#0xa6e4
    a6fa:	b0 12 32 66 	call	#26162		;#0x6632

0000a6fe <.Loc.505.2>:
}
    a6fe:	03 43       	nop			
    a700:	30 41       	ret			

0000a702 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    a702:	b0 12 52 66 	call	#26194		;#0x6652
    a706:	b0 12 ec a6 	call	#42732		;#0xa6ec

0000a70a <.Loc.516.2>:
}
    a70a:	03 43       	nop			
    a70c:	30 41       	ret			

0000a70e <convert_ntc>:
  MSP430X_REF_2V5 /* vref_src */
};

typedef int64_t fixed_q36_8;

fixed_q36_8 convert_ntc(ADCConversionGroup *grpp, adcsample_t sample) {
    a70e:	5a 15       	pushm	#6,	r10	;16-bit words

0000a710 <.LCFI0>:
    a710:	31 80 44 00 	sub	#68,	r1	;#0x0044

0000a714 <.LCFI1>:
    a714:	81 4c 2c 00 	mov	r12,	44(r1)	; 0x002c
    a718:	81 4d 2a 00 	mov	r13,	42(r1)	; 0x002a

0000a71c <.Loc.49.3>:
  const int32_t c3 = -10; /* Q0.31 */
    a71c:	b1 40 f6 ff 	mov	#65526,	64(r1)	;#0xfff6, 0x0040
    a720:	40 00 
    a722:	b1 43 42 00 	mov	#-1,	66(r1)	;r3 As==11, 0x0042

0000a726 <.Loc.50.3>:
  const int32_t c2 = 66515; /* Q0.31 */
    a726:	b1 40 d3 03 	mov	#979,	60(r1)	;#0x03d3, 0x003c
    a72a:	3c 00 
    a72c:	91 43 3e 00 	mov	#1,	62(r1)	;r3 As==01, 0x003e

0000a730 <.Loc.51.3>:
  const int16_t c1 = -2841; /* Q0.15 */
    a730:	b1 40 e7 f4 	mov	#62695,	58(r1)	;#0xf4e7, 0x003a
    a734:	3a 00 

0000a736 <.Loc.52.3>:
  const int32_t c0 = 28750; /* Q7.8 */
    a736:	b1 40 4e 70 	mov	#28750,	54(r1)	;#0x704e, 0x0036
    a73a:	36 00 
    a73c:	81 43 38 00 	mov	#0,	56(r1)	;r3 As==00, 0x0038

0000a740 <.Loc.56.3>:
  int64_t y;
  
  /* Get converted ADC value */
  adcMSP430XAdjustResult(grpp, sample);
    a740:	1d 41 2a 00 	mov	42(r1),	r13	;0x0002a
    a744:	1c 41 2c 00 	mov	44(r1),	r12	;0x0002c
    a748:	b0 12 24 95 	call	#38180		;#0x9524

0000a74c <.Loc.63.3>:
  /* Convert value */
  /* NOTE: This is a lot of fixed point math. The regression line I'm using 
   * comes from LibreOffice, plotting Temperature vs. DN over the -40..+85 C
   * range. The equation is -4.6411...x^3+3.0974...x^2-0.0867...x+112.3073
   * We solve it using Horner's rule in fixed point math as follows */
  y = c3 * sample; /* Q0.31 * Q12.0 => Q12.31 */
    a74c:	1e 41 2a 00 	mov	42(r1),	r14	;0x0002a
    a750:	0c 4e       	mov	r14,	r12	;
    a752:	0d 43       	clr	r13		;
    a754:	1e 41 40 00 	mov	64(r1),	r14	;0x00040
    a758:	1f 41 42 00 	mov	66(r1),	r15	;0x00042
    a75c:	b0 12 b6 cc 	call	#52406		;#0xccb6
    a760:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    a764:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    a768:	0c 4d       	mov	r13,	r12	;
    a76a:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    a76e:	81 4c 32 00 	mov	r12,	50(r1)	; 0x0032
    a772:	81 4c 34 00 	mov	r12,	52(r1)	; 0x0034

0000a776 <.Loc.64.3>:
  y += c2; /* Q12.31 + Q0.31 => OK */
    a776:	1c 41 3c 00 	mov	60(r1),	r12	;0x0003c
    a77a:	1d 41 3e 00 	mov	62(r1),	r13	;0x0003e
    a77e:	81 4c 22 00 	mov	r12,	34(r1)	; 0x0022
    a782:	81 4d 24 00 	mov	r13,	36(r1)	; 0x0024
    a786:	0c 4d       	mov	r13,	r12	;
    a788:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    a78c:	81 4c 26 00 	mov	r12,	38(r1)	; 0x0026
    a790:	81 4c 28 00 	mov	r12,	40(r1)	; 0x0028
    a794:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    a798:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    a79c:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    a7a0:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    a7a4:	0c 48       	mov	r8,	r12	;
    a7a6:	1c 51 22 00 	add	34(r1),	r12	;0x00022
    a7aa:	56 43       	mov.b	#1,	r6	;r3 As==01
    a7ac:	07 4c       	mov	r12,	r7	;
    a7ae:	07 98       	cmp	r8,	r7	;
    a7b0:	01 28       	jnc	$+4      	;abs 0xa7b4
    a7b2:	46 43       	clr.b	r6		;

0000a7b4 <.L6>:
    a7b4:	0d 49       	mov	r9,	r13	;
    a7b6:	1d 51 24 00 	add	36(r1),	r13	;0x00024
    a7ba:	55 43       	mov.b	#1,	r5	;r3 As==01
    a7bc:	07 4d       	mov	r13,	r7	;
    a7be:	07 99       	cmp	r9,	r7	;
    a7c0:	01 28       	jnc	$+4      	;abs 0xa7c4
    a7c2:	45 43       	clr.b	r5		;

0000a7c4 <.L7>:
    a7c4:	06 5d       	add	r13,	r6	;
    a7c6:	57 43       	mov.b	#1,	r7	;r3 As==01
    a7c8:	06 9d       	cmp	r13,	r6	;
    a7ca:	01 28       	jnc	$+4      	;abs 0xa7ce
    a7cc:	47 43       	clr.b	r7		;

0000a7ce <.L8>:
    a7ce:	05 d7       	bis	r7,	r5	;
    a7d0:	0d 46       	mov	r6,	r13	;
    a7d2:	0e 4a       	mov	r10,	r14	;
    a7d4:	1e 51 26 00 	add	38(r1),	r14	;0x00026
    a7d8:	56 43       	mov.b	#1,	r6	;r3 As==01
    a7da:	07 4e       	mov	r14,	r7	;
    a7dc:	07 9a       	cmp	r10,	r7	;
    a7de:	01 28       	jnc	$+4      	;abs 0xa7e2
    a7e0:	46 43       	clr.b	r6		;

0000a7e2 <.L9>:
    a7e2:	05 5e       	add	r14,	r5	;
    a7e4:	57 43       	mov.b	#1,	r7	;r3 As==01
    a7e6:	05 9e       	cmp	r14,	r5	;
    a7e8:	01 28       	jnc	$+4      	;abs 0xa7ec
    a7ea:	47 43       	clr.b	r7		;

0000a7ec <.L10>:
    a7ec:	06 d7       	bis	r7,	r6	;
    a7ee:	0e 45       	mov	r5,	r14	;
    a7f0:	0f 4b       	mov	r11,	r15	;
    a7f2:	1f 51 28 00 	add	40(r1),	r15	;0x00028
    a7f6:	0a 46       	mov	r6,	r10	;
    a7f8:	0a 5f       	add	r15,	r10	;
    a7fa:	0f 4a       	mov	r10,	r15	;
    a7fc:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    a800:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    a804:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    a808:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

0000a80c <.Loc.65.3>:
  y *= sample; /* Q12.31 * Q12.0 => Q24.31 */
    a80c:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    a810:	81 4c 1a 00 	mov	r12,	26(r1)	; 0x001a
    a814:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c
    a818:	81 43 1e 00 	mov	#0,	30(r1)	;r3 As==00, 0x001e
    a81c:	81 43 20 00 	mov	#0,	32(r1)	;r3 As==00, 0x0020
    a820:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    a824:	1d 41 1c 00 	mov	28(r1),	r13	;0x0001c
    a828:	1e 41 1e 00 	mov	30(r1),	r14	;0x0001e
    a82c:	1f 41 20 00 	mov	32(r1),	r15	;0x00020
    a830:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    a834:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    a838:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    a83c:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    a840:	b0 12 b4 ad 	call	#44468		;#0xadb4
    a844:	08 4c       	mov	r12,	r8	;
    a846:	09 4d       	mov	r13,	r9	;
    a848:	0a 4e       	mov	r14,	r10	;
    a84a:	0b 4f       	mov	r15,	r11	;
    a84c:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    a850:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    a854:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    a858:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

0000a85c <.Loc.66.3>:
  y = (y >> 16); /* Q24.31 >> 16 => Q24.15 */
    a85c:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    a860:	00 00 
    a862:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    a866:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    a86a:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    a86e:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    a872:	b0 12 fe ae 	call	#44798		;#0xaefe
    a876:	08 4c       	mov	r12,	r8	;
    a878:	09 4d       	mov	r13,	r9	;
    a87a:	0a 4e       	mov	r14,	r10	;
    a87c:	0b 4f       	mov	r15,	r11	;
    a87e:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    a882:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    a886:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    a88a:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

0000a88e <.Loc.67.3>:
  y += c1; /* Q24.15 + Q0.15 => OK */
    a88e:	1c 41 3a 00 	mov	58(r1),	r12	;0x0003a
    a892:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    a896:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    a89a:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    a89e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    a8a2:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018
    a8a6:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    a8aa:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    a8ae:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    a8b2:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    a8b6:	0c 48       	mov	r8,	r12	;
    a8b8:	1c 51 12 00 	add	18(r1),	r12	;0x00012
    a8bc:	56 43       	mov.b	#1,	r6	;r3 As==01
    a8be:	07 4c       	mov	r12,	r7	;
    a8c0:	07 98       	cmp	r8,	r7	;
    a8c2:	01 28       	jnc	$+4      	;abs 0xa8c6
    a8c4:	46 43       	clr.b	r6		;

0000a8c6 <.L11>:
    a8c6:	0d 49       	mov	r9,	r13	;
    a8c8:	1d 51 14 00 	add	20(r1),	r13	;0x00014
    a8cc:	55 43       	mov.b	#1,	r5	;r3 As==01
    a8ce:	07 4d       	mov	r13,	r7	;
    a8d0:	07 99       	cmp	r9,	r7	;
    a8d2:	01 28       	jnc	$+4      	;abs 0xa8d6
    a8d4:	45 43       	clr.b	r5		;

0000a8d6 <.L12>:
    a8d6:	06 5d       	add	r13,	r6	;
    a8d8:	57 43       	mov.b	#1,	r7	;r3 As==01
    a8da:	06 9d       	cmp	r13,	r6	;
    a8dc:	01 28       	jnc	$+4      	;abs 0xa8e0
    a8de:	47 43       	clr.b	r7		;

0000a8e0 <.L13>:
    a8e0:	05 d7       	bis	r7,	r5	;
    a8e2:	0d 46       	mov	r6,	r13	;
    a8e4:	0e 4a       	mov	r10,	r14	;
    a8e6:	1e 51 16 00 	add	22(r1),	r14	;0x00016
    a8ea:	56 43       	mov.b	#1,	r6	;r3 As==01
    a8ec:	07 4e       	mov	r14,	r7	;
    a8ee:	07 9a       	cmp	r10,	r7	;
    a8f0:	01 28       	jnc	$+4      	;abs 0xa8f4
    a8f2:	46 43       	clr.b	r6		;

0000a8f4 <.L14>:
    a8f4:	05 5e       	add	r14,	r5	;
    a8f6:	57 43       	mov.b	#1,	r7	;r3 As==01
    a8f8:	05 9e       	cmp	r14,	r5	;
    a8fa:	01 28       	jnc	$+4      	;abs 0xa8fe
    a8fc:	47 43       	clr.b	r7		;

0000a8fe <.L15>:
    a8fe:	06 d7       	bis	r7,	r6	;
    a900:	0e 45       	mov	r5,	r14	;
    a902:	0f 4b       	mov	r11,	r15	;
    a904:	1f 51 18 00 	add	24(r1),	r15	;0x00018
    a908:	0a 46       	mov	r6,	r10	;
    a90a:	0a 5f       	add	r15,	r10	;
    a90c:	0f 4a       	mov	r10,	r15	;
    a90e:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    a912:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    a916:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    a91a:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

0000a91e <.Loc.68.3>:
  y *= sample; /* Q24.15 * Q12.0 => Q36.15 */
    a91e:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    a922:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    a926:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c
    a92a:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    a92e:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    a932:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    a936:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    a93a:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    a93e:	1f 41 10 00 	mov	16(r1),	r15	;0x00010
    a942:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    a946:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    a94a:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    a94e:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    a952:	b0 12 b4 ad 	call	#44468		;#0xadb4
    a956:	08 4c       	mov	r12,	r8	;
    a958:	09 4d       	mov	r13,	r9	;
    a95a:	0a 4e       	mov	r14,	r10	;
    a95c:	0b 4f       	mov	r15,	r11	;
    a95e:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    a962:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    a966:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    a96a:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

0000a96e <.Loc.69.3>:
  y = (y >> 7); /* Q36.15 >> 7 => Q36.8 */
    a96e:	b1 40 07 00 	mov	#7,	0(r1)	;
    a972:	00 00 
    a974:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    a978:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    a97c:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    a980:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    a984:	b0 12 fe ae 	call	#44798		;#0xaefe
    a988:	08 4c       	mov	r12,	r8	;
    a98a:	09 4d       	mov	r13,	r9	;
    a98c:	0a 4e       	mov	r14,	r10	;
    a98e:	0b 4f       	mov	r15,	r11	;
    a990:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    a994:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    a998:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    a99c:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

0000a9a0 <.Loc.70.3>:
  y += c0; /* Q36.8 + Q7.8 => OK */
    a9a0:	1c 41 36 00 	mov	54(r1),	r12	;0x00036
    a9a4:	1d 41 38 00 	mov	56(r1),	r13	;0x00038
    a9a8:	81 4c 02 00 	mov	r12,	2(r1)	;
    a9ac:	81 4d 04 00 	mov	r13,	4(r1)	;
    a9b0:	0c 4d       	mov	r13,	r12	;
    a9b2:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    a9b6:	81 4c 06 00 	mov	r12,	6(r1)	;
    a9ba:	81 4c 08 00 	mov	r12,	8(r1)	;
    a9be:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    a9c2:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    a9c6:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    a9ca:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    a9ce:	0c 48       	mov	r8,	r12	;
    a9d0:	1c 51 02 00 	add	2(r1),	r12	;
    a9d4:	56 43       	mov.b	#1,	r6	;r3 As==01
    a9d6:	07 4c       	mov	r12,	r7	;
    a9d8:	07 98       	cmp	r8,	r7	;
    a9da:	01 28       	jnc	$+4      	;abs 0xa9de
    a9dc:	46 43       	clr.b	r6		;

0000a9de <.L16>:
    a9de:	0d 49       	mov	r9,	r13	;
    a9e0:	1d 51 04 00 	add	4(r1),	r13	;
    a9e4:	55 43       	mov.b	#1,	r5	;r3 As==01
    a9e6:	07 4d       	mov	r13,	r7	;
    a9e8:	07 99       	cmp	r9,	r7	;
    a9ea:	01 28       	jnc	$+4      	;abs 0xa9ee
    a9ec:	45 43       	clr.b	r5		;

0000a9ee <.L17>:
    a9ee:	06 5d       	add	r13,	r6	;
    a9f0:	57 43       	mov.b	#1,	r7	;r3 As==01
    a9f2:	06 9d       	cmp	r13,	r6	;
    a9f4:	01 28       	jnc	$+4      	;abs 0xa9f8
    a9f6:	47 43       	clr.b	r7		;

0000a9f8 <.L18>:
    a9f8:	05 d7       	bis	r7,	r5	;
    a9fa:	0d 46       	mov	r6,	r13	;
    a9fc:	0e 4a       	mov	r10,	r14	;
    a9fe:	1e 51 06 00 	add	6(r1),	r14	;
    aa02:	56 43       	mov.b	#1,	r6	;r3 As==01
    aa04:	07 4e       	mov	r14,	r7	;
    aa06:	07 9a       	cmp	r10,	r7	;
    aa08:	01 28       	jnc	$+4      	;abs 0xaa0c
    aa0a:	46 43       	clr.b	r6		;

0000aa0c <.L19>:
    aa0c:	05 5e       	add	r14,	r5	;
    aa0e:	57 43       	mov.b	#1,	r7	;r3 As==01
    aa10:	05 9e       	cmp	r14,	r5	;
    aa12:	01 28       	jnc	$+4      	;abs 0xaa16
    aa14:	47 43       	clr.b	r7		;

0000aa16 <.L20>:
    aa16:	06 d7       	bis	r7,	r6	;
    aa18:	0e 45       	mov	r5,	r14	;
    aa1a:	0f 4b       	mov	r11,	r15	;
    aa1c:	1f 51 08 00 	add	8(r1),	r15	;
    aa20:	0a 46       	mov	r6,	r10	;
    aa22:	0a 5f       	add	r15,	r10	;
    aa24:	0f 4a       	mov	r10,	r15	;
    aa26:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    aa2a:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    aa2e:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    aa32:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

0000aa36 <.Loc.74.3>:
  
  /* Now y is our result in Q36.8 format. We return it using a typedef to
   * make that clear. */
  return y;
    aa36:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    aa3a:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    aa3e:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    aa42:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    aa46:	08 4c       	mov	r12,	r8	;
    aa48:	09 4d       	mov	r13,	r9	;
    aa4a:	0a 4e       	mov	r14,	r10	;
    aa4c:	0b 4f       	mov	r15,	r11	;

0000aa4e <.Loc.75.3>:
}
    aa4e:	0c 48       	mov	r8,	r12	;
    aa50:	0d 49       	mov	r9,	r13	;
    aa52:	0e 4a       	mov	r10,	r14	;
    aa54:	0f 4b       	mov	r11,	r15	;
    aa56:	31 50 44 00 	add	#68,	r1	;#0x0044
    aa5a:	55 17       	popm	#6,	r10	;16-bit words
    aa5c:	30 41       	ret			

0000aa5e <save_bacon>:
const char * err_string = "\r\nERROR! A timeout or reset occurred - packet not sent";
const char * therm_string = "\r\nWARNING! PA overheating!\r\n";
const char * sending_string = "\r\nSending packet...\r\n";
const char * sent_string = "\r\nPacket sent!\r\n";

static void save_bacon(void) {
    aa5e:	1a 15       	pushm	#2,	r10	;16-bit words

0000aa60 <.LCFI2>:
  palClearLine(LINE_PA_PC_EN);
    aa60:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    aa64:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    aa68:	1d 4d 02 00 	mov	2(r13),	r13	;
    aa6c:	3d f0 ef ff 	and	#65519,	r13	;#0xffef
    aa70:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000aa74 <.Loc.91.3>:
  
  chnWrite(&SD0, (const uint8_t *)unpow_string, strlen(unpow_string));
    aa74:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    aa78:	2a 4c       	mov	@r12,	r10	;
    aa7a:	19 42 46 52 	mov	&0x5246,r9	;0x5246
    aa7e:	1c 42 46 52 	mov	&0x5246,r12	;0x5246
    aa82:	b0 12 54 cd 	call	#52564		;#0xcd54
    aa86:	0e 4c       	mov	r12,	r14	;
    aa88:	0d 49       	mov	r9,	r13	;
    aa8a:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    aa8e:	8a 12       	call	r10		;

0000aa90 <.Loc.93.3>:

}
    aa90:	03 43       	nop			
    aa92:	19 17       	popm	#2,	r10	;16-bit words
    aa94:	30 41       	ret			

0000aa96 <Thread2>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    aa96:	3a 15       	pushm	#4,	r10	;16-bit words

0000aa98 <.LCFI3>:
    aa98:	31 80 12 00 	sub	#18,	r1	;#0x0012

0000aa9c <.LCFI4>:
    aa9c:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

0000aaa0 <.Loc.157.3>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    aaa0:	4d 43       	clr.b	r13		;
    aaa2:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    aaa6:	b0 12 54 76 	call	#30292		;#0x7654

0000aaaa <.Loc.160.3>:
  
  /* Activate the ADC driver 1 using its config */
  adcStart(&ADCD1, &adc_config);
    aaaa:	3d 40 14 52 	mov	#21012,	r13	;#0x5214
    aaae:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    aab2:	b0 12 64 73 	call	#29540		;#0x7364

0000aab6 <.Loc.163.3>:

  /* Initialize the SX1212 driver */
  sx1278ObjectInit(&SX1278D1);
    aab6:	3c 40 48 5d 	mov	#23880,	r12	;#0x5d48
    aaba:	b0 12 0a a3 	call	#41738		;#0xa30a

0000aabe <.Loc.166.3>:
  
  /* Start the SX1212 driver */
  sx1278Start(&SX1278D1, &config);
    aabe:	3d 40 5c 52 	mov	#21084,	r13	;#0x525c
    aac2:	3c 40 48 5d 	mov	#23880,	r12	;#0x5d48
    aac6:	b0 12 2a a3 	call	#41770		;#0xa32a

0000aaca <.L32>:
  
  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  uint8_t in;
  while (true) {
    
    in = sdGetTimeout(&SD0, TIME_IMMEDIATE);
    aaca:	3d 43       	mov	#-1,	r13	;r3 As==11
    aacc:	3c 40 94 5b 	mov	#23444,	r12	;#0x5b94
    aad0:	b0 12 50 6e 	call	#28240		;#0x6e50
    aad4:	c1 4c 0f 00 	mov.b	r12,	15(r1)	; 0x000f

0000aad8 <.Loc.174.3>:
    
    if (in == 'p') {
    aad8:	f1 90 70 00 	cmp.b	#112,	15(r1)	;#0x0070, 0x000f
    aadc:	0f 00 
    aade:	71 20       	jnz	$+228    	;abs 0xabc2

0000aae0 <.Loc.175.3>:
      chnWrite(&SD0, (const uint8_t *)sending_string, strlen(sending_string));
    aae0:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    aae4:	2a 4c       	mov	@r12,	r10	;
    aae6:	19 42 4c 52 	mov	&0x524c,r9	;0x524c
    aaea:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    aaee:	b0 12 54 cd 	call	#52564		;#0xcd54
    aaf2:	0e 4c       	mov	r12,	r14	;
    aaf4:	0d 49       	mov	r9,	r13	;
    aaf6:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    aafa:	8a 12       	call	r10		;

0000aafc <.Loc.178.3>:
      
      /* Set up "save my bacon" PGOOD falling edge interrupt */
      osalSysLock();
    aafc:	b0 12 f6 a6 	call	#42742		;#0xa6f6

0000ab00 <.Loc.179.3>:
      palLineEnableEventI(LINE_PA_PGOOD, PAL_EVENT_MODE_FALLING_EDGE, save_bacon);
    ab00:	3f 40 5e aa 	mov	#43614,	r15	;#0xaa5e
    ab04:	6e 43       	mov.b	#2,	r14	;r3 As==10
    ab06:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    ab0a:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    ab0e:	b0 12 32 84 	call	#33842		;#0x8432

0000ab12 <.Loc.180.3>:
      osalSysUnlock();
    ab12:	b0 12 02 a7 	call	#42754		;#0xa702

0000ab16 <.Loc.182.3>:
      /* Power on */
      palSetLine(LINE_PA_PC_EN);
    ab16:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    ab1a:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    ab1e:	1d 4d 02 00 	mov	2(r13),	r13	;
    ab22:	3d d0 10 00 	bis	#16,	r13	;#0x0010
    ab26:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000ab2a <.Loc.184.3>:
      /* Wait for PGOOD to rise */
      chThdSleepMilliseconds(5);
    ab2a:	7c 40 05 00 	mov.b	#5,	r12	;
    ab2e:	b0 12 88 6a 	call	#27272		;#0x6a88

0000ab32 <.Loc.185.3>:
      while ( !palReadLine(LINE_PA_PGOOD) ) ;
    ab32:	03 43       	nop			

0000ab34 <.L25>:
    ab34:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    ab38:	2c 4c       	mov	@r12,	r12	;
    ab3a:	3c f0 00 04 	and	#1024,	r12	;#0x0400
    ab3e:	0c 93       	cmp	#0,	r12	;r3 As==00
    ab40:	f9 27       	jz	$-12     	;abs 0xab34

0000ab42 <.Loc.187.3>:
      /* Transmit */
      err_val = sx1278Send(&SX1278D1, packet, sizeof(packet), TIME_IMMEDIATE);
    ab42:	3f 43       	mov	#-1,	r15	;r3 As==11
    ab44:	3e 40 ff 07 	mov	#2047,	r14	;#0x07ff
    ab48:	3d 40 8e 52 	mov	#21134,	r13	;#0x528e
    ab4c:	3c 40 48 5d 	mov	#23880,	r12	;#0x5d48
    ab50:	b0 12 54 a4 	call	#42068		;#0xa454
    ab54:	82 4c 4e 5d 	mov	r12,	&0x5d4e	;

0000ab58 <.Loc.189.3>:
      /* Disable "save my bacon" PGOOD falling edge interrupt */
      osalSysLock();
    ab58:	b0 12 f6 a6 	call	#42742		;#0xa6f6

0000ab5c <.Loc.190.3>:
      palLineDisableEventI(LINE_PA_PGOOD);
    ab5c:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    ab60:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    ab64:	b0 12 48 85 	call	#34120		;#0x8548

0000ab68 <.Loc.191.3>:
      osalSysUnlock();
    ab68:	b0 12 02 a7 	call	#42754		;#0xa702

0000ab6c <.Loc.193.3>:
      /* Power off */
      palClearLine(LINE_PA_PC_EN);
    ab6c:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    ab70:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    ab74:	1d 4d 02 00 	mov	2(r13),	r13	;
    ab78:	3d f0 ef ff 	and	#65519,	r13	;#0xffef
    ab7c:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000ab80 <.Loc.195.3>:

      if (err_val == MSG_OK) {
    ab80:	1c 42 4e 5d 	mov	&0x5d4e,r12	;0x5d4e
    ab84:	0c 93       	cmp	#0,	r12	;r3 As==00
    ab86:	0f 20       	jnz	$+32     	;abs 0xaba6

0000ab88 <.Loc.196.3>:
        chnWrite(&SD0, (const uint8_t *)sent_string, strlen(sent_string));
    ab88:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    ab8c:	2a 4c       	mov	@r12,	r10	;
    ab8e:	19 42 4e 52 	mov	&0x524e,r9	;0x524e
    ab92:	1c 42 4e 52 	mov	&0x524e,r12	;0x524e
    ab96:	b0 12 54 cd 	call	#52564		;#0xcd54
    ab9a:	0e 4c       	mov	r12,	r14	;
    ab9c:	0d 49       	mov	r9,	r13	;
    ab9e:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    aba2:	8a 12       	call	r10		;
    aba4:	0e 3c       	jmp	$+30     	;abs 0xabc2

0000aba6 <.L26>:
      }
      else {
        chnWrite(&SD0, (const uint8_t *)err_string, strlen(err_string));
    aba6:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    abaa:	2a 4c       	mov	@r12,	r10	;
    abac:	19 42 48 52 	mov	&0x5248,r9	;0x5248
    abb0:	1c 42 48 52 	mov	&0x5248,r12	;0x5248
    abb4:	b0 12 54 cd 	call	#52564		;#0xcd54
    abb8:	0e 4c       	mov	r12,	r14	;
    abba:	0d 49       	mov	r9,	r13	;
    abbc:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    abc0:	8a 12       	call	r10		;

0000abc2 <.L24>:
      
    }
      
    /* Read the NTC thermistor value */
    /*chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));*/
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    abc2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    abc4:	3e 40 c2 5c 	mov	#23746,	r14	;#0x5cc2
    abc8:	3d 40 16 52 	mov	#21014,	r13	;#0x5216
    abcc:	3c 40 82 5c 	mov	#23682,	r12	;#0x5c82
    abd0:	b0 12 94 73 	call	#29588		;#0x7394

0000abd4 <.Loc.207.3>:
    while (ADCD1.state == ADC_ACTIVE) ;
    abd4:	03 43       	nop			

0000abd6 <.L27>:
    abd6:	5c 42 82 5c 	mov.b	&0x5c82,r12	;0x5c82
    abda:	7c 90 03 00 	cmp.b	#3,	r12	;
    abde:	fb 27       	jz	$-8      	;abs 0xabd6

0000abe0 <.LBB2>:
    
    for (int i = 0; i < 2; i++) {
    abe0:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    abe4:	60 3c       	jmp	$+194    	;abs 0xaca6

0000abe6 <.L31>:
      temps[i] = convert_ntc(&adc_group, samples[i]);
    abe6:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    abea:	0c 5c       	rla	r12		;
    abec:	3c 50 c2 5c 	add	#23746,	r12	;#0x5cc2
    abf0:	2c 4c       	mov	@r12,	r12	;
    abf2:	0d 4c       	mov	r12,	r13	;
    abf4:	3c 40 16 52 	mov	#21014,	r12	;#0x5216
    abf8:	b0 12 0e a7 	call	#42766		;#0xa70e
    abfc:	08 4c       	mov	r12,	r8	;
    abfe:	09 4d       	mov	r13,	r9	;
    ac00:	0a 4e       	mov	r14,	r10	;
    ac02:	0b 4f       	mov	r15,	r11	;
    ac04:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    ac08:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    ac0c:	3c 50 b2 5c 	add	#23730,	r12	;#0x5cb2
    ac10:	8c 48 00 00 	mov	r8,	0(r12)	;
    ac14:	8c 49 02 00 	mov	r9,	2(r12)	;
    ac18:	8c 4a 04 00 	mov	r10,	4(r12)	;
    ac1c:	8c 4b 06 00 	mov	r11,	6(r12)	;

0000ac20 <.Loc.211.3>:
      if ((temps[i] >> 8) > 60) {
    ac20:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    ac24:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    ac28:	3c 50 b2 5c 	add	#23730,	r12	;#0x5cb2
    ac2c:	28 4c       	mov	@r12,	r8	;
    ac2e:	19 4c 02 00 	mov	2(r12),	r9	;
    ac32:	1a 4c 04 00 	mov	4(r12),	r10	;
    ac36:	1b 4c 06 00 	mov	6(r12),	r11	;
    ac3a:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    ac3e:	0c 48       	mov	r8,	r12	;
    ac40:	0d 49       	mov	r9,	r13	;
    ac42:	0e 4a       	mov	r10,	r14	;
    ac44:	0f 4b       	mov	r11,	r15	;
    ac46:	b0 12 fe ae 	call	#44798		;#0xaefe
    ac4a:	08 4c       	mov	r12,	r8	;
    ac4c:	09 4d       	mov	r13,	r9	;
    ac4e:	0a 4e       	mov	r14,	r10	;
    ac50:	0b 4f       	mov	r15,	r11	;
    ac52:	0c 48       	mov	r8,	r12	;
    ac54:	0d 49       	mov	r9,	r13	;
    ac56:	0e 4a       	mov	r10,	r14	;
    ac58:	0f 4b       	mov	r11,	r15	;
    ac5a:	4a 43       	clr.b	r10		;
    ac5c:	0a 9f       	cmp	r15,	r10	;
    ac5e:	13 38       	jl	$+40     	;abs 0xac86
    ac60:	0a 4f       	mov	r15,	r10	;
    ac62:	0a 93       	cmp	#0,	r10	;r3 As==00
    ac64:	1e 20       	jnz	$+62     	;abs 0xaca2
    ac66:	0a 4e       	mov	r14,	r10	;
    ac68:	0a 93       	cmp	#0,	r10	;r3 As==00
    ac6a:	0d 20       	jnz	$+28     	;abs 0xac86
    ac6c:	0a 4e       	mov	r14,	r10	;
    ac6e:	0a 93       	cmp	#0,	r10	;r3 As==00
    ac70:	18 20       	jnz	$+50     	;abs 0xaca2
    ac72:	0a 4d       	mov	r13,	r10	;
    ac74:	0a 93       	cmp	#0,	r10	;r3 As==00
    ac76:	07 20       	jnz	$+16     	;abs 0xac86
    ac78:	0a 4d       	mov	r13,	r10	;
    ac7a:	0a 93       	cmp	#0,	r10	;r3 As==00
    ac7c:	12 20       	jnz	$+38     	;abs 0xaca2
    ac7e:	7a 40 3c 00 	mov.b	#60,	r10	;#0x003c
    ac82:	0a 9c       	cmp	r12,	r10	;
    ac84:	0e 2c       	jc	$+30     	;abs 0xaca2

0000ac86 <.L33>:
        /* Report alarming result */
        chnWrite(&SD0, (const uint8_t *)therm_string, strlen(therm_string));
    ac86:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    ac8a:	2a 4c       	mov	@r12,	r10	;
    ac8c:	19 42 4a 52 	mov	&0x524a,r9	;0x524a
    ac90:	1c 42 4a 52 	mov	&0x524a,r12	;0x524a
    ac94:	b0 12 54 cd 	call	#52564		;#0xcd54
    ac98:	0e 4c       	mov	r12,	r14	;
    ac9a:	0d 49       	mov	r9,	r13	;
    ac9c:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    aca0:	8a 12       	call	r10		;

0000aca2 <.L29>:
    /* Read the NTC thermistor value */
    /*chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));*/
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    while (ADCD1.state == ADC_ACTIVE) ;
    
    for (int i = 0; i < 2; i++) {
    aca2:	91 53 10 00 	inc	16(r1)		;

0000aca6 <.L28>:
    aca6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    aca8:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    acac:	9c 37       	jge	$-198    	;abs 0xabe6

0000acae <.LBE2>:
        /* Report alarming result */
        chnWrite(&SD0, (const uint8_t *)therm_string, strlen(therm_string));
      }
    }
    
    sniprintf(out_string, 128, fmt_string, "Bottom", temps[0] >> 8);
    acae:	17 42 44 52 	mov	&0x5244,r7	;0x5244
    acb2:	18 42 b2 5c 	mov	&0x5cb2,r8	;0x5cb2
    acb6:	19 42 b4 5c 	mov	&0x5cb4,r9	;0x5cb4
    acba:	1a 42 b6 5c 	mov	&0x5cb6,r10	;0x5cb6
    acbe:	1b 42 b8 5c 	mov	&0x5cb8,r11	;0x5cb8
    acc2:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    acc6:	0c 48       	mov	r8,	r12	;
    acc8:	0d 49       	mov	r9,	r13	;
    acca:	0e 4a       	mov	r10,	r14	;
    accc:	0f 4b       	mov	r11,	r15	;
    acce:	b0 12 fe ae 	call	#44798		;#0xaefe
    acd2:	08 4c       	mov	r12,	r8	;
    acd4:	09 4d       	mov	r13,	r9	;
    acd6:	0a 4e       	mov	r14,	r10	;
    acd8:	0b 4f       	mov	r15,	r11	;
    acda:	0c 48       	mov	r8,	r12	;
    acdc:	0d 49       	mov	r9,	r13	;
    acde:	0e 4a       	mov	r10,	r14	;
    ace0:	0f 4b       	mov	r11,	r15	;
    ace2:	81 4c 04 00 	mov	r12,	4(r1)	;
    ace6:	81 4d 06 00 	mov	r13,	6(r1)	;
    acea:	81 4e 08 00 	mov	r14,	8(r1)	;
    acee:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    acf2:	b1 40 2b 51 	mov	#20779,	2(r1)	;#0x512b
    acf6:	02 00 
    acf8:	81 47 00 00 	mov	r7,	0(r1)	;
    acfc:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    ad00:	3c 40 c6 5c 	mov	#23750,	r12	;#0x5cc6
    ad04:	b0 12 ea cc 	call	#52458		;#0xccea

0000ad08 <.Loc.218.3>:
    chnWrite(&SD0, (const uint8_t *)out_string, strlen(out_string));
    ad08:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    ad0c:	2a 4c       	mov	@r12,	r10	;
    ad0e:	3c 40 c6 5c 	mov	#23750,	r12	;#0x5cc6
    ad12:	b0 12 54 cd 	call	#52564		;#0xcd54
    ad16:	0e 4c       	mov	r12,	r14	;
    ad18:	3d 40 c6 5c 	mov	#23750,	r13	;#0x5cc6
    ad1c:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    ad20:	8a 12       	call	r10		;

0000ad22 <.Loc.219.3>:
    sniprintf(out_string, 128, fmt_string, "Top", temps[1] >> 8);
    ad22:	17 42 44 52 	mov	&0x5244,r7	;0x5244
    ad26:	18 42 ba 5c 	mov	&0x5cba,r8	;0x5cba
    ad2a:	19 42 bc 5c 	mov	&0x5cbc,r9	;0x5cbc
    ad2e:	1a 42 be 5c 	mov	&0x5cbe,r10	;0x5cbe
    ad32:	1b 42 c0 5c 	mov	&0x5cc0,r11	;0x5cc0
    ad36:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    ad3a:	0c 48       	mov	r8,	r12	;
    ad3c:	0d 49       	mov	r9,	r13	;
    ad3e:	0e 4a       	mov	r10,	r14	;
    ad40:	0f 4b       	mov	r11,	r15	;
    ad42:	b0 12 fe ae 	call	#44798		;#0xaefe
    ad46:	08 4c       	mov	r12,	r8	;
    ad48:	09 4d       	mov	r13,	r9	;
    ad4a:	0a 4e       	mov	r14,	r10	;
    ad4c:	0b 4f       	mov	r15,	r11	;
    ad4e:	0c 48       	mov	r8,	r12	;
    ad50:	0d 49       	mov	r9,	r13	;
    ad52:	0e 4a       	mov	r10,	r14	;
    ad54:	0f 4b       	mov	r11,	r15	;
    ad56:	81 4c 04 00 	mov	r12,	4(r1)	;
    ad5a:	81 4d 06 00 	mov	r13,	6(r1)	;
    ad5e:	81 4e 08 00 	mov	r14,	8(r1)	;
    ad62:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    ad66:	b1 40 32 51 	mov	#20786,	2(r1)	;#0x5132
    ad6a:	02 00 
    ad6c:	81 47 00 00 	mov	r7,	0(r1)	;
    ad70:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    ad74:	3c 40 c6 5c 	mov	#23750,	r12	;#0x5cc6
    ad78:	b0 12 ea cc 	call	#52458		;#0xccea

0000ad7c <.Loc.220.3>:
    chnWrite(&SD0, (const uint8_t *)out_string, strlen(out_string));
    ad7c:	1c 42 88 5b 	mov	&0x5b88,r12	;0x5b88
    ad80:	2a 4c       	mov	@r12,	r10	;
    ad82:	3c 40 c6 5c 	mov	#23750,	r12	;#0x5cc6
    ad86:	b0 12 54 cd 	call	#52564		;#0xcd54
    ad8a:	0e 4c       	mov	r12,	r14	;
    ad8c:	3d 40 c6 5c 	mov	#23750,	r13	;#0x5cc6
    ad90:	3c 40 88 5b 	mov	#23432,	r12	;#0x5b88
    ad94:	8a 12       	call	r10		;

0000ad96 <.Loc.222.3>:
    
    chThdSleepMilliseconds(500);
    ad96:	3c 40 f4 01 	mov	#500,	r12	;#0x01f4
    ad9a:	b0 12 88 6a 	call	#27272		;#0x6a88

0000ad9e <.Loc.172.3>:
  
  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  uint8_t in;
  while (true) {
    
    in = sdGetTimeout(&SD0, TIME_IMMEDIATE);
    ad9e:	95 3e       	jmp	$-724    	;abs 0xaaca

0000ada0 <main>:
    ada0:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    ada4:	5c 01 

0000ada6 <L0>:
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
  

  halInit();
    ada6:	b0 12 ba 6c 	call	#27834		;#0x6cba

0000adaa <.Loc.250.3>:
  chSysInit();
    adaa:	b0 12 54 67 	call	#26452		;#0x6754

0000adae <.Loc.251.3>:
  dmaInit();
    adae:	b0 12 98 87 	call	#34712		;#0x8798

0000adb2 <.L35>:
  
  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    adb2:	ff 3f       	jmp	$+0      	;abs 0xadb2

0000adb4 <__mspabi_mpyll>:
    adb4:	6a 15       	pushm	#7,	r10	;16-bit words

0000adb6 <L0>:
    adb6:	31 80 1c 00 	sub	#28,	r1	;#0x001c

0000adba <.LCFI1>:
    adba:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    adbe:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    adc2:	06 4c       	mov	r12,	r6	;
    adc4:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    adc8:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    adcc:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

0000add0 <.LBB2>:
    add0:	0a 48       	mov	r8,	r10	;
    add2:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    add6:	0c 48       	mov	r8,	r12	;

0000add8 <.LVL3>:
    add8:	0d 49       	mov	r9,	r13	;
    adda:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    adde:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    ade2:	81 4c 00 00 	mov	r12,	0(r1)	;
    ade6:	81 4d 02 00 	mov	r13,	2(r1)	;

0000adea <.LVL5>:
    adea:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    adee:	0c 46       	mov	r6,	r12	;
    adf0:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    adf4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    adf8:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    adfc:	81 4c 04 00 	mov	r12,	4(r1)	;
    ae00:	81 4d 06 00 	mov	r13,	6(r1)	;
    ae04:	38 40 b6 cc 	mov	#52406,	r8	;#0xccb6

0000ae08 <.LVL9>:
    ae08:	0e 46       	mov	r6,	r14	;
    ae0a:	4f 43       	clr.b	r15		;
    ae0c:	0c 4a       	mov	r10,	r12	;
    ae0e:	0d 4f       	mov	r15,	r13	;
    ae10:	88 12       	call	r8		;

0000ae12 <.LVL10>:
    ae12:	04 4c       	mov	r12,	r4	;
    ae14:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    ae18:	05 4d       	mov	r13,	r5	;

0000ae1a <.LVL11>:
    ae1a:	0e 46       	mov	r6,	r14	;
    ae1c:	4f 43       	clr.b	r15		;
    ae1e:	2c 41       	mov	@r1,	r12	;
    ae20:	1d 41 02 00 	mov	2(r1),	r13	;
    ae24:	88 12       	call	r8		;

0000ae26 <.LVL12>:
    ae26:	06 4c       	mov	r12,	r6	;
    ae28:	07 4d       	mov	r13,	r7	;

0000ae2a <.LVL14>:
    ae2a:	1e 41 04 00 	mov	4(r1),	r14	;
    ae2e:	1f 41 06 00 	mov	6(r1),	r15	;
    ae32:	2c 41       	mov	@r1,	r12	;
    ae34:	1d 41 02 00 	mov	2(r1),	r13	;
    ae38:	88 12       	call	r8		;

0000ae3a <.LVL15>:
    ae3a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000ae3e <.LVL16>:
    ae3e:	81 4d 02 00 	mov	r13,	2(r1)	;

0000ae42 <.LVL17>:
    ae42:	1e 41 04 00 	mov	4(r1),	r14	;
    ae46:	1f 41 06 00 	mov	6(r1),	r15	;
    ae4a:	0c 4a       	mov	r10,	r12	;
    ae4c:	4d 43       	clr.b	r13		;
    ae4e:	88 12       	call	r8		;

0000ae50 <.LVL18>:
    ae50:	0a 4c       	mov	r12,	r10	;
    ae52:	0a 56       	add	r6,	r10	;
    ae54:	08 4d       	mov	r13,	r8	;
    ae56:	08 67       	addc	r7,	r8	;
    ae58:	0c 44       	mov	r4,	r12	;
    ae5a:	0d 45       	mov	r5,	r13	;
    ae5c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ae60:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    ae64:	05 4c       	mov	r12,	r5	;

0000ae66 <.LVL22>:
    ae66:	05 5a       	add	r10,	r5	;
    ae68:	0d 68       	addc	r8,	r13	;

0000ae6a <.LVL23>:
    ae6a:	0d 97       	cmp	r7,	r13	;
    ae6c:	04 28       	jnc	$+10     	;abs 0xae76
    ae6e:	07 9d       	cmp	r13,	r7	;
    ae70:	06 20       	jnz	$+14     	;abs 0xae7e
    ae72:	05 96       	cmp	r6,	r5	;
    ae74:	04 2c       	jc	$+10     	;abs 0xae7e

0000ae76 <.L4>:
    ae76:	81 53 00 00 	add	#0,	0(r1)	;r3 As==00
    ae7a:	91 63 02 00 	addc	#1,	2(r1)	;r3 As==01

0000ae7e <.L2>:
    ae7e:	0c 45       	mov	r5,	r12	;
    ae80:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ae84:	b0 12 b0 c3 	call	#50096		;#0xc3b0

0000ae88 <.LVL25>:
    ae88:	28 41       	mov	@r1,	r8	;
    ae8a:	08 5c       	add	r12,	r8	;
    ae8c:	1d 61 02 00 	addc	2(r1),	r13	;
    ae90:	0a 4d       	mov	r13,	r10	;
    ae92:	47 43       	clr.b	r7		;

0000ae94 <.LVL27>:
    ae94:	0c 45       	mov	r5,	r12	;
    ae96:	0d 47       	mov	r7,	r13	;
    ae98:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    ae9c:	b0 12 88 c2 	call	#49800		;#0xc288
    aea0:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    aea4:	0c 5f       	add	r15,	r12	;
    aea6:	0d 67       	addc	r7,	r13	;

0000aea8 <.LBE2>:
    aea8:	04 4c       	mov	r12,	r4	;
    aeaa:	05 4d       	mov	r13,	r5	;
    aeac:	06 48       	mov	r8,	r6	;
    aeae:	07 4a       	mov	r10,	r7	;

0000aeb0 <.Loc.553.1>:
    aeb0:	3a 40 b6 cc 	mov	#52406,	r10	;#0xccb6
    aeb4:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    aeb8:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    aebc:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    aec0:	0d 49       	mov	r9,	r13	;
    aec2:	8a 12       	call	r10		;

0000aec4 <.LVL29>:
    aec4:	09 4c       	mov	r12,	r9	;
    aec6:	08 4d       	mov	r13,	r8	;

0000aec8 <.Loc.554.1>:
    aec8:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    aecc:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    aed0:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    aed4:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    aed8:	8a 12       	call	r10		;

0000aeda <.LVL30>:
    aeda:	09 5c       	add	r12,	r9	;
    aedc:	81 49 08 00 	mov	r9,	8(r1)	;
    aee0:	08 6d       	addc	r13,	r8	;
    aee2:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a

0000aee6 <.Loc.553.1>:
    aee6:	16 51 08 00 	add	8(r1),	r6	;
    aeea:	17 61 0a 00 	addc	10(r1),	r7	;0x0000a

0000aeee <.Loc.557.1>:
    aeee:	0c 44       	mov	r4,	r12	;
    aef0:	0d 45       	mov	r5,	r13	;
    aef2:	0e 46       	mov	r6,	r14	;
    aef4:	0f 47       	mov	r7,	r15	;
    aef6:	31 50 1c 00 	add	#28,	r1	;#0x001c

0000aefa <.LVL31>:
    aefa:	64 17       	popm	#7,	r10	;16-bit words
    aefc:	30 41       	ret			

0000aefe <__ashrdi3>:
    aefe:	6a 15       	pushm	#7,	r10	;16-bit words

0000af00 <.LCFI0>:
    af00:	21 83       	decd	r1		;

0000af02 <.LCFI1>:
    af02:	05 4c       	mov	r12,	r5	;
    af04:	0a 4d       	mov	r13,	r10	;
    af06:	1b 41 12 00 	mov	18(r1),	r11	;0x00012

0000af0a <.Loc.461.1>:
    af0a:	0b 93       	cmp	#0,	r11	;r3 As==00
    af0c:	1e 24       	jz	$+62     	;abs 0xaf4a

0000af0e <.Loc.465.1>:
    af0e:	37 40 20 00 	mov	#32,	r7	;#0x0020
    af12:	07 8b       	sub	r11,	r7	;

0000af14 <.LVL1>:
    af14:	4c 43       	clr.b	r12		;

0000af16 <.LVL2>:
    af16:	0c 97       	cmp	r7,	r12	;
    af18:	1d 38       	jl	$+60     	;abs 0xaf54

0000af1a <.Loc.471.1>:
    af1a:	06 4e       	mov	r14,	r6	;
    af1c:	0a 4f       	mov	r15,	r10	;
    af1e:	0c 4e       	mov	r14,	r12	;
    af20:	0d 4f       	mov	r15,	r13	;
    af22:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    af26:	b0 12 fc c2 	call	#49916		;#0xc2fc
    af2a:	08 4c       	mov	r12,	r8	;
    af2c:	09 4d       	mov	r13,	r9	;

0000af2e <.Loc.472.1>:
    af2e:	0e 43       	clr	r14		;
    af30:	0e 87       	sub	r7,	r14	;
    af32:	0c 46       	mov	r6,	r12	;
    af34:	0d 4a       	mov	r10,	r13	;
    af36:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    af3a:	0f 7f       	subc	r15,	r15	;
    af3c:	3f e3       	inv	r15		;
    af3e:	b0 12 fc c2 	call	#49916		;#0xc2fc
    af42:	05 4c       	mov	r12,	r5	;
    af44:	0a 4d       	mov	r13,	r10	;

0000af46 <.L4>:
    af46:	0e 48       	mov	r8,	r14	;
    af48:	0f 49       	mov	r9,	r15	;

0000af4a <.L2>:
    af4a:	0c 45       	mov	r5,	r12	;
    af4c:	0d 4a       	mov	r10,	r13	;
    af4e:	21 53       	incd	r1		;
    af50:	64 17       	popm	#7,	r10	;16-bit words
    af52:	30 41       	ret			

0000af54 <.L3>:
    af54:	04 4e       	mov	r14,	r4	;
    af56:	06 4f       	mov	r15,	r6	;

0000af58 <.Loc.478.1>:
    af58:	0c 4e       	mov	r14,	r12	;
    af5a:	0d 4f       	mov	r15,	r13	;
    af5c:	0e 4b       	mov	r11,	r14	;
    af5e:	0f 4b       	mov	r11,	r15	;
    af60:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    af64:	81 4b 00 00 	mov	r11,	0(r1)	;
    af68:	b0 12 fc c2 	call	#49916		;#0xc2fc

0000af6c <.LVL9>:
    af6c:	08 4c       	mov	r12,	r8	;
    af6e:	09 4d       	mov	r13,	r9	;

0000af70 <.Loc.479.1>:
    af70:	0c 45       	mov	r5,	r12	;
    af72:	0d 4a       	mov	r10,	r13	;
    af74:	2b 41       	mov	@r1,	r11	;
    af76:	0e 4b       	mov	r11,	r14	;
    af78:	0f 43       	clr	r15		;
    af7a:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    af7e:	05 4c       	mov	r12,	r5	;
    af80:	0a 4d       	mov	r13,	r10	;

0000af82 <.Loc.476.1>:
    af82:	0c 44       	mov	r4,	r12	;
    af84:	0d 46       	mov	r6,	r13	;
    af86:	0e 47       	mov	r7,	r14	;
    af88:	0f 43       	clr	r15		;
    af8a:	b0 12 88 c2 	call	#49800		;#0xc288

0000af8e <.Loc.479.1>:
    af8e:	0a dd       	bis	r13,	r10	;
    af90:	0d 45       	mov	r5,	r13	;
    af92:	0d dc       	bis	r12,	r13	;
    af94:	05 4d       	mov	r13,	r5	;
    af96:	d7 3f       	jmp	$-80     	;abs 0xaf46

0000af98 <__fixunssfsi>:
    af98:	2a 15       	pushm	#3,	r10	;16-bit words

0000af9a <L0>:
    af9a:	08 4c       	mov	r12,	r8	;
    af9c:	09 4d       	mov	r13,	r9	;

0000af9e <.Loc.1810.1>:
    af9e:	4e 43       	clr.b	r14		;
    afa0:	3f 40 00 4f 	mov	#20224,	r15	;#0x4f00
    afa4:	b0 12 ac b2 	call	#45740		;#0xb2ac

0000afa8 <.LVL1>:
    afa8:	3a 40 02 b3 	mov	#45826,	r10	;#0xb302
    afac:	0c 93       	cmp	#0,	r12	;r3 As==00
    afae:	0d 38       	jl	$+28     	;abs 0xafca

0000afb0 <.Loc.1811.1>:
    afb0:	4e 43       	clr.b	r14		;
    afb2:	3f 40 00 4f 	mov	#20224,	r15	;#0x4f00
    afb6:	0c 48       	mov	r8,	r12	;
    afb8:	0d 49       	mov	r9,	r13	;
    afba:	b0 12 5a b2 	call	#45658		;#0xb25a
    afbe:	8a 12       	call	r10		;

0000afc0 <.LVL3>:
    afc0:	0c 53       	add	#0,	r12	;r3 As==00
    afc2:	3d 60 00 80 	addc	#32768,	r13	;#0x8000

0000afc6 <.L1>:
    afc6:	28 17       	popm	#3,	r10	;16-bit words
    afc8:	30 41       	ret			

0000afca <.L6>:
    afca:	0c 48       	mov	r8,	r12	;
    afcc:	0d 49       	mov	r9,	r13	;
    afce:	8a 12       	call	r10		;
    afd0:	fa 3f       	jmp	$-10     	;abs 0xafc6

0000afd2 <__mspabi_fixdul>:
    afd2:	6a 15       	pushm	#7,	r10	;16-bit words

0000afd4 <L0>:
    afd4:	31 82       	sub	#8,	r1	;r2 As==11

0000afd6 <.LCFI1>:
    afd6:	08 4c       	mov	r12,	r8	;
    afd8:	09 4d       	mov	r13,	r9	;
    afda:	0a 4e       	mov	r14,	r10	;
    afdc:	05 4f       	mov	r15,	r5	;

0000afde <.Loc.1800.1>:
    afde:	47 43       	clr.b	r7		;
    afe0:	34 40 e0 41 	mov	#16864,	r4	;#0x41e0
    afe4:	81 47 00 00 	mov	r7,	0(r1)	;
    afe8:	81 47 02 00 	mov	r7,	2(r1)	;
    afec:	81 47 04 00 	mov	r7,	4(r1)	;
    aff0:	81 44 06 00 	mov	r4,	6(r1)	;
    aff4:	b0 12 f2 bf 	call	#49138		;#0xbff2

0000aff8 <.LVL1>:
    aff8:	36 40 64 c0 	mov	#49252,	r6	;#0xc064
    affc:	0c 97       	cmp	r7,	r12	;
    affe:	0e 38       	jl	$+30     	;abs 0xb01c

0000b000 <.Loc.1801.1>:
    b000:	0c 47       	mov	r7,	r12	;
    b002:	0d 47       	mov	r7,	r13	;
    b004:	0e 47       	mov	r7,	r14	;
    b006:	0f 44       	mov	r4,	r15	;
    b008:	0b 45       	mov	r5,	r11	;
    b00a:	b0 12 52 ba 	call	#47698		;#0xba52
    b00e:	86 12       	call	r6		;

0000b010 <.LVL3>:
    b010:	0c 53       	add	#0,	r12	;r3 As==00
    b012:	3d 60 00 80 	addc	#32768,	r13	;#0x8000

0000b016 <.L1>:
    b016:	31 52       	add	#8,	r1	;r2 As==11
    b018:	64 17       	popm	#7,	r10	;16-bit words
    b01a:	30 41       	ret			

0000b01c <.L6>:
    b01c:	0c 48       	mov	r8,	r12	;
    b01e:	0d 49       	mov	r9,	r13	;
    b020:	0e 4a       	mov	r10,	r14	;
    b022:	0f 45       	mov	r5,	r15	;
    b024:	86 12       	call	r6		;
    b026:	f7 3f       	jmp	$-16     	;abs 0xb016

0000b028 <_fpadd_parts>:
    b028:	6a 15       	pushm	#7,	r10	;16-bit words

0000b02a <L0>:
    b02a:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000b02e <.LCFI1>:
    b02e:	08 4c       	mov	r12,	r8	;
    b030:	09 4d       	mov	r13,	r9	;
    b032:	0a 4e       	mov	r14,	r10	;
    b034:	2c 4c       	mov	@r12,	r12	;

0000b036 <.LVL1>:
    b036:	5d 43       	mov.b	#1,	r13	;r3 As==01

0000b038 <.LVL2>:
    b038:	0d 9c       	cmp	r12,	r13	;
    b03a:	0b 2d       	jc	$+536    	;abs 0xb252
    b03c:	2d 49       	mov	@r9,	r13	;

0000b03e <.Loc.597.1>:
    b03e:	5e 43       	mov.b	#1,	r14	;r3 As==01

0000b040 <.LVL4>:
    b040:	0e 9d       	cmp	r13,	r14	;
    b042:	09 2d       	jc	$+532    	;abs 0xb256

0000b044 <.Loc.601.1>:
    b044:	2c 92       	cmp	#4,	r12	;r2 As==10
    b046:	0e 20       	jnz	$+30     	;abs 0xb064
    b048:	0a 48       	mov	r8,	r10	;

0000b04a <.LVL7>:
    b04a:	2d 92       	cmp	#4,	r13	;r2 As==10
    b04c:	06 20       	jnz	$+14     	;abs 0xb05a

0000b04e <.Loc.604.1>:
    b04e:	98 99 02 00 	cmp	2(r9),	2(r8)	;
    b052:	02 00 
    b054:	02 24       	jz	$+6      	;abs 0xb05a

0000b056 <.Loc.605.1>:
    b056:	3a 40 56 51 	mov	#20822,	r10	;#0x5156

0000b05a <.L1>:
    b05a:	0c 4a       	mov	r10,	r12	;
    b05c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    b060:	64 17       	popm	#7,	r10	;16-bit words
    b062:	30 41       	ret			

0000b064 <.L3>:
    b064:	2d 92       	cmp	#4,	r13	;r2 As==10
    b066:	f7 24       	jz	$+496    	;abs 0xb256

0000b068 <.Loc.612.1>:
    b068:	2d 93       	cmp	#2,	r13	;r3 As==10
    b06a:	0f 20       	jnz	$+32     	;abs 0xb08a

0000b06c <.Loc.614.1>:
    b06c:	2c 93       	cmp	#2,	r12	;r3 As==10
    b06e:	f1 20       	jnz	$+484    	;abs 0xb252

0000b070 <.Loc.616.1>:
    b070:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    b074:	0d 48       	mov	r8,	r13	;
    b076:	0c 4a       	mov	r10,	r12	;
    b078:	b0 12 d6 cc 	call	#52438		;#0xccd6

0000b07c <.LVL12>:
    b07c:	18 48 02 00 	mov	2(r8),	r8	;

0000b080 <.LVL13>:
    b080:	18 f9 02 00 	and	2(r9),	r8	;
    b084:	8a 48 02 00 	mov	r8,	2(r10)	;

0000b088 <.Loc.618.1>:
    b088:	e8 3f       	jmp	$-46     	;abs 0xb05a

0000b08a <.L4>:
    b08a:	2c 93       	cmp	#2,	r12	;r3 As==10
    b08c:	e4 24       	jz	$+458    	;abs 0xb256

0000b08e <.LBB21>:
    b08e:	17 48 04 00 	mov	4(r8),	r7	;

0000b092 <.LVL15>:
    b092:	1d 49 04 00 	mov	4(r9),	r13	;

0000b096 <.LVL16>:
    b096:	91 48 06 00 	mov	6(r8),	0(r1)	;
    b09a:	00 00 
    b09c:	91 48 08 00 	mov	8(r8),	2(r1)	;
    b0a0:	02 00 

0000b0a2 <.LVL17>:
    b0a2:	14 49 06 00 	mov	6(r9),	r4	;
    b0a6:	15 49 08 00 	mov	8(r9),	r5	;

0000b0aa <.LVL18>:
    b0aa:	0c 47       	mov	r7,	r12	;
    b0ac:	0c 8d       	sub	r13,	r12	;

0000b0ae <.LVL19>:
    b0ae:	06 4c       	mov	r12,	r6	;
    b0b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    b0b2:	02 34       	jge	$+6      	;abs 0xb0b8
    b0b4:	06 43       	clr	r6		;
    b0b6:	06 8c       	sub	r12,	r6	;

0000b0b8 <.L5>:
    b0b8:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    b0bc:	0e 96       	cmp	r6,	r14	;
    b0be:	92 38       	jl	$+294    	;abs 0xb1e4

0000b0c0 <.Loc.645.1>:
    b0c0:	4d 43       	clr.b	r13		;

0000b0c2 <.LVL21>:
    b0c2:	0d 9c       	cmp	r12,	r13	;
    b0c4:	63 34       	jge	$+200    	;abs 0xb18c

0000b0c6 <.LVL22>:
    b0c6:	0c 46       	mov	r6,	r12	;
    b0c8:	0d 43       	clr	r13		;

0000b0ca <.LVL23>:
    b0ca:	81 4c 04 00 	mov	r12,	4(r1)	;
    b0ce:	81 4d 06 00 	mov	r13,	6(r1)	;
    b0d2:	0c 44       	mov	r4,	r12	;
    b0d4:	0d 45       	mov	r5,	r13	;
    b0d6:	1e 41 04 00 	mov	4(r1),	r14	;
    b0da:	b0 12 b0 c3 	call	#50096		;#0xc3b0

0000b0de <.LVL24>:
    b0de:	81 4c 08 00 	mov	r12,	8(r1)	;
    b0e2:	06 4d       	mov	r13,	r6	;

0000b0e4 <.LVL25>:
    b0e4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b0e6:	4d 43       	clr.b	r13		;
    b0e8:	1e 41 04 00 	mov	4(r1),	r14	;
    b0ec:	b0 12 88 c2 	call	#49800		;#0xc288
    b0f0:	3c 53       	add	#-1,	r12	;r3 As==11
    b0f2:	3d 63       	addc	#-1,	r13	;r3 As==11
    b0f4:	0c f4       	and	r4,	r12	;
    b0f6:	0d f5       	and	r5,	r13	;
    b0f8:	0c dd       	bis	r13,	r12	;
    b0fa:	0d 43       	clr	r13		;
    b0fc:	0d 8c       	sub	r12,	r13	;
    b0fe:	0c dd       	bis	r13,	r12	;
    b100:	5c 03       	rrum	#1,	r12	;
    b102:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    b106:	14 41 08 00 	mov	8(r1),	r4	;

0000b10a <.LVL27>:
    b10a:	04 dc       	bis	r12,	r4	;
    b10c:	05 46       	mov	r6,	r5	;

0000b10e <.L8>:
    b10e:	1c 48 02 00 	mov	2(r8),	r12	;
    b112:	1c 99 02 00 	cmp	2(r9),	r12	;
    b116:	8f 24       	jz	$+288    	;abs 0xb236

0000b118 <.Loc.674.1>:
    b118:	0c 93       	cmp	#0,	r12	;r3 As==00
    b11a:	6f 24       	jz	$+224    	;abs 0xb1fa

0000b11c <.Loc.676.1>:
    b11c:	0c 44       	mov	r4,	r12	;
    b11e:	0d 45       	mov	r5,	r13	;
    b120:	2c 81       	sub	@r1,	r12	;
    b122:	1d 71 02 00 	subc	2(r1),	r13	;

0000b126 <.L11>:
    b126:	0d 93       	cmp	#0,	r13	;r3 As==00
    b128:	6e 38       	jl	$+222    	;abs 0xb206

0000b12a <.Loc.684.1>:
    b12a:	8a 43 02 00 	mov	#0,	2(r10)	;r3 As==00

0000b12e <.Loc.685.1>:
    b12e:	8a 47 04 00 	mov	r7,	4(r10)	;

0000b132 <.Loc.686.1>:
    b132:	8a 4c 06 00 	mov	r12,	6(r10)	;
    b136:	8a 4d 08 00 	mov	r13,	8(r10)	;

0000b13a <.L14>:
    b13a:	1c 4a 06 00 	mov	6(r10),	r12	;
    b13e:	1d 4a 08 00 	mov	8(r10),	r13	;
    b142:	0f 4c       	mov	r12,	r15	;
    b144:	3f 53       	add	#-1,	r15	;r3 As==11
    b146:	0e 4d       	mov	r13,	r14	;
    b148:	3e 63       	addc	#-1,	r14	;r3 As==11
    b14a:	39 40 ff 3f 	mov	#16383,	r9	;#0x3fff
    b14e:	09 9e       	cmp	r14,	r9	;
    b150:	06 28       	jnc	$+14     	;abs 0xb15e
    b152:	0e 99       	cmp	r9,	r14	;
    b154:	67 20       	jnz	$+208    	;abs 0xb224
    b156:	3e 40 fe ff 	mov	#65534,	r14	;#0xfffe
    b15a:	0e 9f       	cmp	r15,	r14	;
    b15c:	63 2c       	jc	$+200    	;abs 0xb224

0000b15e <.L18>:
    b15e:	ba 40 03 00 	mov	#3,	0(r10)	;
    b162:	00 00 

0000b164 <.Loc.712.1>:
    b164:	1c 4a 06 00 	mov	6(r10),	r12	;
    b168:	1d 4a 08 00 	mov	8(r10),	r13	;
    b16c:	0d 93       	cmp	#0,	r13	;r3 As==00
    b16e:	75 37       	jge	$-276    	;abs 0xb05a

0000b170 <.Loc.714.1>:
    b170:	0e 4c       	mov	r12,	r14	;
    b172:	0f 4d       	mov	r13,	r15	;
    b174:	12 c3       	clrc			
    b176:	0f 10       	rrc	r15		;
    b178:	0e 10       	rrc	r14		;
    b17a:	5c f3       	and.b	#1,	r12	;r3 As==01
    b17c:	0c de       	bis	r14,	r12	;
    b17e:	8a 4c 06 00 	mov	r12,	6(r10)	;
    b182:	8a 4f 08 00 	mov	r15,	8(r10)	;

0000b186 <.Loc.715.1>:
    b186:	9a 53 04 00 	inc	4(r10)		;
    b18a:	67 3f       	jmp	$-304    	;abs 0xb05a

0000b18c <.L7>:
    b18c:	0c 93       	cmp	#0,	r12	;r3 As==00
    b18e:	bf 27       	jz	$-128    	;abs 0xb10e

0000b190 <.Loc.652.1>:
    b190:	07 56       	add	r6,	r7	;

0000b192 <.Loc.653.1>:
    b192:	0c 46       	mov	r6,	r12	;
    b194:	0d 43       	clr	r13		;

0000b196 <.LVL33>:
    b196:	81 4c 04 00 	mov	r12,	4(r1)	;
    b19a:	81 4d 06 00 	mov	r13,	6(r1)	;
    b19e:	2c 41       	mov	@r1,	r12	;
    b1a0:	1d 41 02 00 	mov	2(r1),	r13	;
    b1a4:	1e 41 04 00 	mov	4(r1),	r14	;
    b1a8:	b0 12 b0 c3 	call	#50096		;#0xc3b0

0000b1ac <.LVL34>:
    b1ac:	06 4c       	mov	r12,	r6	;

0000b1ae <.LVL35>:
    b1ae:	81 4d 08 00 	mov	r13,	8(r1)	;
    b1b2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b1b4:	4d 43       	clr.b	r13		;
    b1b6:	1e 41 04 00 	mov	4(r1),	r14	;
    b1ba:	b0 12 88 c2 	call	#49800		;#0xc288
    b1be:	3c 53       	add	#-1,	r12	;r3 As==11
    b1c0:	3d 63       	addc	#-1,	r13	;r3 As==11
    b1c2:	2c f1       	and	@r1,	r12	;
    b1c4:	1d f1 02 00 	and	2(r1),	r13	;
    b1c8:	0c dd       	bis	r13,	r12	;
    b1ca:	0d 43       	clr	r13		;
    b1cc:	0d 8c       	sub	r12,	r13	;
    b1ce:	0c dd       	bis	r13,	r12	;
    b1d0:	5c 03       	rrum	#1,	r12	;
    b1d2:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    b1d6:	06 dc       	bis	r12,	r6	;
    b1d8:	81 46 00 00 	mov	r6,	0(r1)	;

0000b1dc <.LVL37>:
    b1dc:	91 41 08 00 	mov	8(r1),	2(r1)	;
    b1e0:	02 00 

0000b1e2 <.LVL38>:
    b1e2:	95 3f       	jmp	$-212    	;abs 0xb10e

0000b1e4 <.L6>:
    b1e4:	0d 97       	cmp	r7,	r13	;
    b1e6:	06 38       	jl	$+14     	;abs 0xb1f4
    b1e8:	07 4d       	mov	r13,	r7	;

0000b1ea <.LVL40>:
    b1ea:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000b1ee <.LVL41>:
    b1ee:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    b1f2:	8d 3f       	jmp	$-228    	;abs 0xb10e

0000b1f4 <.L27>:
    b1f4:	44 43       	clr.b	r4		;

0000b1f6 <.LVL43>:
    b1f6:	45 43       	clr.b	r5		;
    b1f8:	8a 3f       	jmp	$-234    	;abs 0xb10e

0000b1fa <.L10>:
    b1fa:	2c 41       	mov	@r1,	r12	;
    b1fc:	1d 41 02 00 	mov	2(r1),	r13	;
    b200:	0c 84       	sub	r4,	r12	;
    b202:	0d 75       	subc	r5,	r13	;

0000b204 <.LVL45>:
    b204:	90 3f       	jmp	$-222    	;abs 0xb126

0000b206 <.L12>:
    b206:	9a 43 02 00 	mov	#1,	2(r10)	;r3 As==01

0000b20a <.Loc.691.1>:
    b20a:	8a 47 04 00 	mov	r7,	4(r10)	;

0000b20e <.Loc.692.1>:
    b20e:	4e 43       	clr.b	r14		;
    b210:	4f 43       	clr.b	r15		;
    b212:	08 4e       	mov	r14,	r8	;

0000b214 <.LVL46>:
    b214:	09 4f       	mov	r15,	r9	;

0000b216 <.LVL47>:
    b216:	08 8c       	sub	r12,	r8	;
    b218:	09 7d       	subc	r13,	r9	;
    b21a:	8a 48 06 00 	mov	r8,	6(r10)	;
    b21e:	8a 49 08 00 	mov	r9,	8(r10)	;
    b222:	8b 3f       	jmp	$-232    	;abs 0xb13a

0000b224 <.L16>:
    b224:	0c 5c       	rla	r12		;
    b226:	0d 6d       	rlc	r13		;
    b228:	8a 4c 06 00 	mov	r12,	6(r10)	;
    b22c:	8a 4d 08 00 	mov	r13,	8(r10)	;

0000b230 <.Loc.699.1>:
    b230:	ba 53 04 00 	add	#-1,	4(r10)	;r3 As==11
    b234:	82 3f       	jmp	$-250    	;abs 0xb13a

0000b236 <.L9>:
    b236:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000b23a <.Loc.705.1>:
    b23a:	8a 47 04 00 	mov	r7,	4(r10)	;

0000b23e <.Loc.706.1>:
    b23e:	08 44       	mov	r4,	r8	;

0000b240 <.LVL50>:
    b240:	28 51       	add	@r1,	r8	;
    b242:	8a 48 06 00 	mov	r8,	6(r10)	;
    b246:	09 45       	mov	r5,	r9	;

0000b248 <.LVL51>:
    b248:	19 61 02 00 	addc	2(r1),	r9	;
    b24c:	8a 49 08 00 	mov	r9,	8(r10)	;
    b250:	86 3f       	jmp	$-242    	;abs 0xb15e

0000b252 <.L25>:
    b252:	0a 48       	mov	r8,	r10	;

0000b254 <.LVL53>:
    b254:	02 3f       	jmp	$-506    	;abs 0xb05a

0000b256 <.L26>:
    b256:	0a 49       	mov	r9,	r10	;

0000b258 <.LVL55>:
    b258:	00 3f       	jmp	$-510    	;abs 0xb05a

0000b25a <__mspabi_subf>:
    b25a:	0a 15       	pushm	#1,	r10	;16-bit words

0000b25c <.LCFI4>:
    b25c:	31 80 26 00 	sub	#38,	r1	;#0x0026

0000b260 <.LCFI5>:
    b260:	81 4c 00 00 	mov	r12,	0(r1)	;
    b264:	81 4d 02 00 	mov	r13,	2(r1)	;

0000b268 <.Loc.750.1>:
    b268:	81 4e 04 00 	mov	r14,	4(r1)	;
    b26c:	81 4f 06 00 	mov	r15,	6(r1)	;

0000b270 <L0>:
    b270:	3a 40 02 c6 	mov	#50690,	r10	;#0xc602
    b274:	0d 41       	mov	r1,	r13	;
    b276:	3d 52       	add	#8,	r13	;r2 As==11
    b278:	0c 41       	mov	r1,	r12	;

0000b27a <.LVL63>:
    b27a:	8a 12       	call	r10		;

0000b27c <.LVL64>:
    b27c:	0d 41       	mov	r1,	r13	;
    b27e:	3d 50 12 00 	add	#18,	r13	;#0x0012
    b282:	0c 41       	mov	r1,	r12	;
    b284:	2c 52       	add	#4,	r12	;r2 As==10
    b286:	8a 12       	call	r10		;

0000b288 <.LVL65>:
    b288:	91 e3 14 00 	xor	#1,	20(r1)	;r3 As==01, 0x0014

0000b28c <.Loc.757.1>:
    b28c:	0e 41       	mov	r1,	r14	;
    b28e:	3e 50 1c 00 	add	#28,	r14	;#0x001c
    b292:	0d 41       	mov	r1,	r13	;
    b294:	3d 50 12 00 	add	#18,	r13	;#0x0012
    b298:	0c 41       	mov	r1,	r12	;
    b29a:	3c 52       	add	#8,	r12	;r2 As==11
    b29c:	b0 12 28 b0 	call	#45096		;#0xb028

0000b2a0 <.LVL66>:
    b2a0:	b0 12 c6 c4 	call	#50374		;#0xc4c6

0000b2a4 <.LVL67>:
    b2a4:	31 50 26 00 	add	#38,	r1	;#0x0026
    b2a8:	0a 17       	popm	#1,	r10	;16-bit words
    b2aa:	30 41       	ret			

0000b2ac <__gesf2>:
    b2ac:	0a 15       	pushm	#1,	r10	;16-bit words

0000b2ae <.LCFI0>:
    b2ae:	31 80 1c 00 	sub	#28,	r1	;#0x001c

0000b2b2 <.LCFI1>:
    b2b2:	81 4c 00 00 	mov	r12,	0(r1)	;
    b2b6:	81 4d 02 00 	mov	r13,	2(r1)	;

0000b2ba <.Loc.1243.1>:
    b2ba:	81 4e 04 00 	mov	r14,	4(r1)	;
    b2be:	81 4f 06 00 	mov	r15,	6(r1)	;

0000b2c2 <.Loc.1245.1>:
    b2c2:	3a 40 02 c6 	mov	#50690,	r10	;#0xc602
    b2c6:	0d 41       	mov	r1,	r13	;
    b2c8:	3d 52       	add	#8,	r13	;r2 As==11
    b2ca:	0c 41       	mov	r1,	r12	;

0000b2cc <.LVL1>:
    b2cc:	8a 12       	call	r10		;

0000b2ce <.LVL2>:
    b2ce:	0d 41       	mov	r1,	r13	;
    b2d0:	3d 50 12 00 	add	#18,	r13	;#0x0012
    b2d4:	0c 41       	mov	r1,	r12	;
    b2d6:	2c 52       	add	#4,	r12	;r2 As==10
    b2d8:	8a 12       	call	r10		;

0000b2da <.LVL3>:
    b2da:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b2dc:	1c 91 08 00 	cmp	8(r1),	r12	;
    b2e0:	0e 2c       	jc	$+30     	;abs 0xb2fe

0000b2e2 <.Loc.1248.1>:
    b2e2:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    b2e6:	0b 2c       	jc	$+24     	;abs 0xb2fe

0000b2e8 <.Loc.1250.1>:
    b2e8:	0d 41       	mov	r1,	r13	;
    b2ea:	3d 50 12 00 	add	#18,	r13	;#0x0012
    b2ee:	0c 41       	mov	r1,	r12	;
    b2f0:	3c 52       	add	#8,	r12	;r2 As==11
    b2f2:	b0 12 dc c6 	call	#50908		;#0xc6dc

0000b2f6 <.L1>:
    b2f6:	31 50 1c 00 	add	#28,	r1	;#0x001c
    b2fa:	0a 17       	popm	#1,	r10	;16-bit words
    b2fc:	30 41       	ret			

0000b2fe <.L4>:
    b2fe:	3c 43       	mov	#-1,	r12	;r3 As==11
    b300:	fa 3f       	jmp	$-10     	;abs 0xb2f6

0000b302 <__mspabi_fixfli>:
    b302:	0a 15       	pushm	#1,	r10	;16-bit words

0000b304 <L0>:
    b304:	31 80 0e 00 	sub	#14,	r1	;#0x000e

0000b308 <.LCFI1>:
    b308:	81 4c 00 00 	mov	r12,	0(r1)	;
    b30c:	81 4d 02 00 	mov	r13,	2(r1)	;

0000b310 <.Loc.1401.1>:
    b310:	0d 41       	mov	r1,	r13	;
    b312:	2d 52       	add	#4,	r13	;r2 As==10
    b314:	0c 41       	mov	r1,	r12	;

0000b316 <.LVL1>:
    b316:	b0 12 02 c6 	call	#50690		;#0xc602

0000b31a <.LVL2>:
    b31a:	1c 41 04 00 	mov	4(r1),	r12	;

0000b31e <.Loc.1405.1>:
    b31e:	6a 43       	mov.b	#2,	r10	;r3 As==10
    b320:	0a 9c       	cmp	r12,	r10	;
    b322:	2e 2c       	jc	$+94     	;abs 0xb380

0000b324 <.Loc.1408.1>:
    b324:	2c 92       	cmp	#4,	r12	;r2 As==10
    b326:	0a 20       	jnz	$+22     	;abs 0xb33c

0000b328 <.L4>:
    b328:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    b32c:	25 20       	jnz	$+76     	;abs 0xb378
    b32e:	3c 43       	mov	#-1,	r12	;r3 As==11
    b330:	3d 40 ff 7f 	mov	#32767,	r13	;#0x7fff

0000b334 <.L1>:
    b334:	31 50 0e 00 	add	#14,	r1	;#0x000e
    b338:	0a 17       	popm	#1,	r10	;16-bit words
    b33a:	30 41       	ret			

0000b33c <.L3>:
    b33c:	1c 41 08 00 	mov	8(r1),	r12	;
    b340:	0c 93       	cmp	#0,	r12	;r3 As==00
    b342:	1e 38       	jl	$+62     	;abs 0xb380

0000b344 <.Loc.1413.1>:
    b344:	7b 40 1e 00 	mov.b	#30,	r11	;#0x001e
    b348:	0b 9c       	cmp	r12,	r11	;
    b34a:	ee 3b       	jl	$-34     	;abs 0xb328

0000b34c <.Loc.1415.1>:
    b34c:	3e 40 1e 00 	mov	#30,	r14	;#0x001e
    b350:	0e 8c       	sub	r12,	r14	;
    b352:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    b356:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    b35a:	0f 43       	clr	r15		;
    b35c:	b0 12 b0 c3 	call	#50096		;#0xc3b0

0000b360 <.LVL7>:
    b360:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    b364:	e7 27       	jz	$-48     	;abs 0xb334

0000b366 <.Loc.1416.1>:
    b366:	4e 43       	clr.b	r14		;
    b368:	4f 43       	clr.b	r15		;
    b36a:	0a 4e       	mov	r14,	r10	;
    b36c:	0b 4f       	mov	r15,	r11	;
    b36e:	0a 8c       	sub	r12,	r10	;
    b370:	0b 7d       	subc	r13,	r11	;
    b372:	0c 4a       	mov	r10,	r12	;

0000b374 <.LVL8>:
    b374:	0d 4b       	mov	r11,	r13	;
    b376:	de 3f       	jmp	$-66     	;abs 0xb334

0000b378 <.L6>:
    b378:	4c 43       	clr.b	r12		;
    b37a:	3d 40 00 80 	mov	#32768,	r13	;#0x8000
    b37e:	da 3f       	jmp	$-74     	;abs 0xb334

0000b380 <.L7>:
    b380:	4c 43       	clr.b	r12		;
    b382:	4d 43       	clr.b	r13		;
    b384:	d7 3f       	jmp	$-80     	;abs 0xb334

0000b386 <__mspabi_cvtfd>:
    b386:	2a 15       	pushm	#3,	r10	;16-bit words

0000b388 <.LCFI0>:
    b388:	31 80 16 00 	sub	#22,	r1	;#0x0016

0000b38c <L0>:
    b38c:	81 4c 08 00 	mov	r12,	8(r1)	;
    b390:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

0000b394 <.Loc.1501.1>:
    b394:	0d 41       	mov	r1,	r13	;
    b396:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    b39a:	0c 41       	mov	r1,	r12	;

0000b39c <.LVL1>:
    b39c:	3c 52       	add	#8,	r12	;r2 As==11
    b39e:	b0 12 02 c6 	call	#50690		;#0xc602

0000b3a2 <.LVL2>:
    b3a2:	18 41 10 00 	mov	16(r1),	r8	;0x00010
    b3a6:	19 41 0e 00 	mov	14(r1),	r9	;0x0000e
    b3aa:	1a 41 0c 00 	mov	12(r1),	r10	;0x0000c

0000b3ae <.Loc.1504.1>:
    b3ae:	1d 41 14 00 	mov	20(r1),	r13	;0x00014

0000b3b2 <.Loc.1503.1>:
    b3b2:	b1 40 1e 00 	mov	#30,	0(r1)	;#0x001e
    b3b6:	00 00 
    b3b8:	1c 41 12 00 	mov	18(r1),	r12	;0x00012
    b3bc:	4e 43       	clr.b	r14		;
    b3be:	0f 4e       	mov	r14,	r15	;
    b3c0:	b0 12 3a c4 	call	#50234		;#0xc43a
    b3c4:	81 4c 00 00 	mov	r12,	0(r1)	;
    b3c8:	81 4d 02 00 	mov	r13,	2(r1)	;
    b3cc:	81 4e 04 00 	mov	r14,	4(r1)	;
    b3d0:	81 4f 06 00 	mov	r15,	6(r1)	;
    b3d4:	0e 48       	mov	r8,	r14	;
    b3d6:	0d 49       	mov	r9,	r13	;
    b3d8:	0c 4a       	mov	r10,	r12	;
    b3da:	b0 12 fe c0 	call	#49406		;#0xc0fe

0000b3de <.LVL4>:
    b3de:	31 50 16 00 	add	#22,	r1	;#0x0016
    b3e2:	28 17       	popm	#3,	r10	;16-bit words
    b3e4:	30 41       	ret			

0000b3e6 <_fpadd_parts>:
    b3e6:	6a 15       	pushm	#7,	r10	;16-bit words

0000b3e8 <.LCFI0>:
    b3e8:	31 80 1c 00 	sub	#28,	r1	;#0x001c

0000b3ec <.LCFI1>:
    b3ec:	0a 4c       	mov	r12,	r10	;
    b3ee:	09 4d       	mov	r13,	r9	;
    b3f0:	04 4e       	mov	r14,	r4	;
    b3f2:	2c 4c       	mov	@r12,	r12	;

0000b3f4 <.LVL1>:
    b3f4:	55 43       	mov.b	#1,	r5	;r3 As==01
    b3f6:	05 9c       	cmp	r12,	r5	;
    b3f8:	0f 2c       	jc	$+32     	;abs 0xb418
    b3fa:	2d 4d       	mov	@r13,	r13	;

0000b3fc <.LVL2>:
    b3fc:	05 9d       	cmp	r13,	r5	;
    b3fe:	02 28       	jnc	$+6      	;abs 0xb404
    b400:	80 00 ea b9 	mova	#47594,	r0	;0x0b9ea

0000b404 <.Loc.601.1>:
    b404:	2c 92       	cmp	#4,	r12	;r2 As==10
    b406:	0d 20       	jnz	$+28     	;abs 0xb422

0000b408 <.Loc.604.1>:
    b408:	2d 92       	cmp	#4,	r13	;r2 As==10
    b40a:	06 20       	jnz	$+14     	;abs 0xb418

0000b40c <.Loc.604.1>:
    b40c:	9a 99 02 00 	cmp	2(r9),	2(r10)	;
    b410:	02 00 
    b412:	02 24       	jz	$+6      	;abs 0xb418

0000b414 <.Loc.605.1>:
    b414:	3a 40 60 51 	mov	#20832,	r10	;#0x5160

0000b418 <.L1>:
    b418:	0c 4a       	mov	r10,	r12	;
    b41a:	31 50 1c 00 	add	#28,	r1	;#0x001c
    b41e:	64 17       	popm	#7,	r10	;16-bit words
    b420:	30 41       	ret			

0000b422 <.L3>:
    b422:	2d 92       	cmp	#4,	r13	;r2 As==10
    b424:	02 20       	jnz	$+6      	;abs 0xb42a
    b426:	80 00 ea b9 	mova	#47594,	r0	;0x0b9ea

0000b42a <.Loc.612.1>:
    b42a:	2d 93       	cmp	#2,	r13	;r3 As==10
    b42c:	10 20       	jnz	$+34     	;abs 0xb44e

0000b42e <.Loc.614.1>:
    b42e:	2c 93       	cmp	#2,	r12	;r3 As==10
    b430:	f3 23       	jnz	$-24     	;abs 0xb418

0000b432 <.Loc.616.1>:
    b432:	7e 40 0e 00 	mov.b	#14,	r14	;#0x000e
    b436:	0d 4a       	mov	r10,	r13	;
    b438:	0c 44       	mov	r4,	r12	;
    b43a:	b0 12 d6 cc 	call	#52438		;#0xccd6

0000b43e <.LVL9>:
    b43e:	1a 4a 02 00 	mov	2(r10),	r10	;

0000b442 <.LVL10>:
    b442:	1a f9 02 00 	and	2(r9),	r10	;
    b446:	84 4a 02 00 	mov	r10,	2(r4)	;

0000b44a <.L84>:
    b44a:	0a 44       	mov	r4,	r10	;
    b44c:	e5 3f       	jmp	$-52     	;abs 0xb418

0000b44e <.L4>:
    b44e:	2c 93       	cmp	#2,	r12	;r3 As==10
    b450:	02 20       	jnz	$+6      	;abs 0xb456
    b452:	80 00 ea b9 	mova	#47594,	r0	;0x0b9ea

0000b456 <.LBB21>:
    b456:	91 4a 04 00 	mov	4(r10),	16(r1)	; 0x0010
    b45a:	10 00 

0000b45c <.LVL13>:
    b45c:	1d 49 04 00 	mov	4(r9),	r13	;

0000b460 <.LVL14>:
    b460:	18 4a 06 00 	mov	6(r10),	r8	;
    b464:	91 4a 08 00 	mov	8(r10),	4(r1)	;
    b468:	04 00 
    b46a:	91 4a 0a 00 	mov	10(r10),6(r1)	;0x0000a
    b46e:	06 00 
    b470:	91 4a 0c 00 	mov	12(r10),12(r1)	;0x0000c, 0x000c
    b474:	0c 00 

0000b476 <.LVL15>:
    b476:	1b 49 06 00 	mov	6(r9),	r11	;
    b47a:	91 49 08 00 	mov	8(r9),	8(r1)	;
    b47e:	08 00 
    b480:	91 49 0a 00 	mov	10(r9),	10(r1)	;0x0000a, 0x000a
    b484:	0a 00 
    b486:	91 49 0c 00 	mov	12(r9),	14(r1)	;0x0000c, 0x000e
    b48a:	0e 00 

0000b48c <.LVL16>:
    b48c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    b490:	0c 8d       	sub	r13,	r12	;

0000b492 <.LVL17>:
    b492:	07 4c       	mov	r12,	r7	;
    b494:	0c 93       	cmp	#0,	r12	;r3 As==00
    b496:	02 34       	jge	$+6      	;abs 0xb49c
    b498:	07 43       	clr	r7		;
    b49a:	07 8c       	sub	r12,	r7	;

0000b49c <.L5>:
    b49c:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    b4a0:	0e 97       	cmp	r7,	r14	;
    b4a2:	cd 39       	jl	$+924    	;abs 0xb83e

0000b4a4 <.Loc.645.1>:
    b4a4:	45 43       	clr.b	r5		;
    b4a6:	05 9c       	cmp	r12,	r5	;
    b4a8:	32 35       	jge	$+614    	;abs 0xb70e

0000b4aa <.LVL19>:
    b4aa:	81 47 00 00 	mov	r7,	0(r1)	;

0000b4ae <.LVL20>:
    b4ae:	0c 4b       	mov	r11,	r12	;

0000b4b0 <.LVL21>:
    b4b0:	1d 41 08 00 	mov	8(r1),	r13	;

0000b4b4 <.LVL22>:
    b4b4:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    b4b8:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    b4bc:	81 4b 02 00 	mov	r11,	2(r1)	;
    b4c0:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000b4c4 <.LVL23>:
    b4c4:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    b4c8:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014
    b4cc:	81 4e 16 00 	mov	r14,	22(r1)	; 0x0016
    b4d0:	81 4f 18 00 	mov	r15,	24(r1)	; 0x0018
    b4d4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b4d6:	0d 45       	mov	r5,	r13	;
    b4d8:	0e 45       	mov	r5,	r14	;
    b4da:	0f 45       	mov	r5,	r15	;
    b4dc:	b0 12 3a c4 	call	#50234		;#0xc43a
    b4e0:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a
    b4e4:	3f 43       	mov	#-1,	r15	;r3 As==11
    b4e6:	06 4c       	mov	r12,	r6	;
    b4e8:	06 5f       	add	r15,	r6	;
    b4ea:	55 43       	mov.b	#1,	r5	;r3 As==01
    b4ec:	1b 41 02 00 	mov	2(r1),	r11	;

0000b4f0 <.LVL25>:
    b4f0:	06 9c       	cmp	r12,	r6	;
    b4f2:	01 28       	jnc	$+4      	;abs 0xb4f6
    b4f4:	45 43       	clr.b	r5		;

0000b4f6 <.L8>:
    b4f6:	0c 4d       	mov	r13,	r12	;
    b4f8:	0c 5f       	add	r15,	r12	;
    b4fa:	57 43       	mov.b	#1,	r7	;r3 As==01

0000b4fc <.LVL26>:
    b4fc:	0c 9d       	cmp	r13,	r12	;
    b4fe:	01 28       	jnc	$+4      	;abs 0xb502
    b500:	47 43       	clr.b	r7		;

0000b502 <.L9>:
    b502:	05 5c       	add	r12,	r5	;
    b504:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b506:	05 9c       	cmp	r12,	r5	;
    b508:	01 28       	jnc	$+4      	;abs 0xb50c
    b50a:	4d 43       	clr.b	r13		;

0000b50c <.L10>:
    b50c:	07 dd       	bis	r13,	r7	;
    b50e:	0d 4e       	mov	r14,	r13	;
    b510:	0d 5f       	add	r15,	r13	;
    b512:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b514:	0d 9e       	cmp	r14,	r13	;
    b516:	01 28       	jnc	$+4      	;abs 0xb51a
    b518:	4c 43       	clr.b	r12		;

0000b51a <.L11>:
    b51a:	07 5d       	add	r13,	r7	;
    b51c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b51e:	07 9d       	cmp	r13,	r7	;
    b520:	01 28       	jnc	$+4      	;abs 0xb524
    b522:	4e 43       	clr.b	r14		;

0000b524 <.L12>:
    b524:	0c de       	bis	r14,	r12	;
    b526:	1f 51 1a 00 	add	26(r1),	r15	;0x0001a
    b52a:	0c 5f       	add	r15,	r12	;
    b52c:	06 fb       	and	r11,	r6	;
    b52e:	15 f1 08 00 	and	8(r1),	r5	;
    b532:	81 45 08 00 	mov	r5,	8(r1)	;

0000b536 <.LVL27>:
    b536:	17 f1 0a 00 	and	10(r1),	r7	;0x0000a
    b53a:	81 47 0a 00 	mov	r7,	10(r1)	; 0x000a
    b53e:	1c f1 0e 00 	and	14(r1),	r12	;0x0000e
    b542:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    b546:	4f 43       	clr.b	r15		;
    b548:	0c 4f       	mov	r15,	r12	;
    b54a:	0c 86       	sub	r6,	r12	;
    b54c:	57 43       	mov.b	#1,	r7	;r3 As==01
    b54e:	0c 9f       	cmp	r15,	r12	;
    b550:	01 20       	jnz	$+4      	;abs 0xb554
    b552:	07 4c       	mov	r12,	r7	;

0000b554 <.L13>:
    b554:	0e 4f       	mov	r15,	r14	;
    b556:	1e 81 08 00 	sub	8(r1),	r14	;
    b55a:	5b 43       	mov.b	#1,	r11	;r3 As==01
    b55c:	0e 93       	cmp	#0,	r14	;r3 As==00
    b55e:	01 20       	jnz	$+4      	;abs 0xb562
    b560:	0b 4e       	mov	r14,	r11	;

0000b562 <.L14>:
    b562:	0d 4e       	mov	r14,	r13	;
    b564:	0d 87       	sub	r7,	r13	;
    b566:	57 43       	mov.b	#1,	r7	;r3 As==01
    b568:	0e 9d       	cmp	r13,	r14	;
    b56a:	01 28       	jnc	$+4      	;abs 0xb56e
    b56c:	47 43       	clr.b	r7		;

0000b56e <.L15>:
    b56e:	0b d7       	bis	r7,	r11	;
    b570:	05 4f       	mov	r15,	r5	;
    b572:	15 81 0a 00 	sub	10(r1),	r5	;0x0000a
    b576:	57 43       	mov.b	#1,	r7	;r3 As==01
    b578:	05 93       	cmp	#0,	r5	;r3 As==00
    b57a:	01 20       	jnz	$+4      	;abs 0xb57e
    b57c:	07 45       	mov	r5,	r7	;

0000b57e <.L16>:
    b57e:	0e 45       	mov	r5,	r14	;
    b580:	0e 8b       	sub	r11,	r14	;
    b582:	5b 43       	mov.b	#1,	r11	;r3 As==01
    b584:	05 9e       	cmp	r14,	r5	;
    b586:	01 28       	jnc	$+4      	;abs 0xb58a
    b588:	4b 43       	clr.b	r11		;

0000b58a <.L17>:
    b58a:	07 db       	bis	r11,	r7	;
    b58c:	1f 81 0e 00 	sub	14(r1),	r15	;0x0000e
    b590:	0f 87       	sub	r7,	r15	;
    b592:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    b596:	00 00 
    b598:	0c d6       	bis	r6,	r12	;
    b59a:	1d d1 08 00 	bis	8(r1),	r13	;
    b59e:	1e d1 0a 00 	bis	10(r1),	r14	;0x0000a
    b5a2:	1f d1 0e 00 	bis	14(r1),	r15	;0x0000e
    b5a6:	b0 12 b6 c3 	call	#50102		;#0xc3b6
    b5aa:	1b 41 12 00 	mov	18(r1),	r11	;0x00012
    b5ae:	0b dc       	bis	r12,	r11	;
    b5b0:	1d d1 14 00 	bis	20(r1),	r13	;0x00014
    b5b4:	81 4d 08 00 	mov	r13,	8(r1)	;
    b5b8:	1e d1 16 00 	bis	22(r1),	r14	;0x00016
    b5bc:	81 4e 0a 00 	mov	r14,	10(r1)	; 0x000a
    b5c0:	1f d1 18 00 	bis	24(r1),	r15	;0x00018
    b5c4:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

0000b5c8 <.L18>:
    b5c8:	1c 4a 02 00 	mov	2(r10),	r12	;
    b5cc:	1c 99 02 00 	cmp	2(r9),	r12	;
    b5d0:	d4 25       	jz	$+938    	;abs 0xb97a

0000b5d2 <.Loc.674.1>:
    b5d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    b5d4:	49 25       	jz	$+660    	;abs 0xb868

0000b5d6 <.Loc.676.1>:
    b5d6:	09 4b       	mov	r11,	r9	;
    b5d8:	09 88       	sub	r8,	r9	;

0000b5da <.LVL30>:
    b5da:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b5dc:	0b 99       	cmp	r9,	r11	;
    b5de:	01 28       	jnc	$+4      	;abs 0xb5e2
    b5e0:	4d 43       	clr.b	r13		;

0000b5e2 <.L31>:
    b5e2:	1c 41 08 00 	mov	8(r1),	r12	;
    b5e6:	1c 81 04 00 	sub	4(r1),	r12	;
    b5ea:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b5ec:	81 9c 08 00 	cmp	r12,	8(r1)	;
    b5f0:	01 28       	jnc	$+4      	;abs 0xb5f4
    b5f2:	4e 43       	clr.b	r14		;

0000b5f4 <.L32>:
    b5f4:	0a 4c       	mov	r12,	r10	;
    b5f6:	0a 8d       	sub	r13,	r10	;

0000b5f8 <.LVL31>:
    b5f8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b5fa:	0c 9a       	cmp	r10,	r12	;
    b5fc:	01 28       	jnc	$+4      	;abs 0xb600
    b5fe:	4d 43       	clr.b	r13		;

0000b600 <.L33>:
    b600:	0e dd       	bis	r13,	r14	;
    b602:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    b606:	1c 81 06 00 	sub	6(r1),	r12	;
    b60a:	58 43       	mov.b	#1,	r8	;r3 As==01

0000b60c <.LVL32>:
    b60c:	81 9c 0a 00 	cmp	r12,	10(r1)	; 0x000a
    b610:	01 28       	jnc	$+4      	;abs 0xb614
    b612:	48 43       	clr.b	r8		;

0000b614 <.L34>:
    b614:	0d 4c       	mov	r12,	r13	;
    b616:	0d 8e       	sub	r14,	r13	;
    b618:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b61a:	0c 9d       	cmp	r13,	r12	;
    b61c:	01 28       	jnc	$+4      	;abs 0xb620
    b61e:	4e 43       	clr.b	r14		;

0000b620 <.L35>:
    b620:	08 de       	bis	r14,	r8	;
    b622:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    b626:	1c 81 0c 00 	sub	12(r1),	r12	;0x0000c
    b62a:	07 49       	mov	r9,	r7	;
    b62c:	0c 88       	sub	r8,	r12	;

0000b62e <.L36>:
    b62e:	0c 93       	cmp	#0,	r12	;r3 As==00
    b630:	48 39       	jl	$+658    	;abs 0xb8c2

0000b632 <.Loc.684.1>:
    b632:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00

0000b636 <.Loc.685.1>:
    b636:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    b63a:	04 00 

0000b63c <.Loc.686.1>:
    b63c:	84 47 06 00 	mov	r7,	6(r4)	;
    b640:	84 4a 08 00 	mov	r10,	8(r4)	;
    b644:	84 4d 0a 00 	mov	r13,	10(r4)	; 0x000a
    b648:	84 4c 0c 00 	mov	r12,	12(r4)	; 0x000c

0000b64c <.L50>:
    b64c:	36 43       	mov	#-1,	r6	;r3 As==11
    b64e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b650:	4f 43       	clr.b	r15		;

0000b652 <.L44>:
    b652:	1b 44 06 00 	mov	6(r4),	r11	;
    b656:	1a 44 08 00 	mov	8(r4),	r10	;
    b65a:	19 44 0a 00 	mov	10(r4),	r9	;0x0000a
    b65e:	18 44 0c 00 	mov	12(r4),	r8	;0x0000c
    b662:	0c 4b       	mov	r11,	r12	;
    b664:	0c 56       	add	r6,	r12	;
    b666:	81 4c 06 00 	mov	r12,	6(r1)	;
    b66a:	07 4e       	mov	r14,	r7	;
    b66c:	0c 9b       	cmp	r11,	r12	;
    b66e:	01 28       	jnc	$+4      	;abs 0xb672
    b670:	07 4f       	mov	r15,	r7	;

0000b672 <.L57>:
    b672:	0d 4a       	mov	r10,	r13	;
    b674:	0d 56       	add	r6,	r13	;
    b676:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b678:	0d 9a       	cmp	r10,	r13	;
    b67a:	01 28       	jnc	$+4      	;abs 0xb67e
    b67c:	4c 43       	clr.b	r12		;

0000b67e <.L58>:
    b67e:	07 5d       	add	r13,	r7	;
    b680:	05 4e       	mov	r14,	r5	;
    b682:	07 9d       	cmp	r13,	r7	;
    b684:	01 28       	jnc	$+4      	;abs 0xb688
    b686:	05 4f       	mov	r15,	r5	;

0000b688 <.L59>:
    b688:	0c d5       	bis	r5,	r12	;
    b68a:	05 49       	mov	r9,	r5	;
    b68c:	05 56       	add	r6,	r5	;
    b68e:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b690:	05 99       	cmp	r9,	r5	;
    b692:	01 28       	jnc	$+4      	;abs 0xb696
    b694:	4d 43       	clr.b	r13		;

0000b696 <.L60>:
    b696:	0c 55       	add	r5,	r12	;
    b698:	81 4e 04 00 	mov	r14,	4(r1)	;
    b69c:	0c 95       	cmp	r5,	r12	;
    b69e:	02 28       	jnc	$+6      	;abs 0xb6a4
    b6a0:	81 4f 04 00 	mov	r15,	4(r1)	;

0000b6a4 <.L61>:
    b6a4:	1d d1 04 00 	bis	4(r1),	r13	;
    b6a8:	05 48       	mov	r8,	r5	;
    b6aa:	05 56       	add	r6,	r5	;
    b6ac:	0d 55       	add	r5,	r13	;
    b6ae:	35 40 ff 0f 	mov	#4095,	r5	;#0x0fff
    b6b2:	05 9d       	cmp	r13,	r5	;
    b6b4:	0b 28       	jnc	$+24     	;abs 0xb6cc
    b6b6:	0d 95       	cmp	r5,	r13	;
    b6b8:	35 21       	jnz	$+620    	;abs 0xb924
    b6ba:	3c 93       	cmp	#-1,	r12	;r3 As==11
    b6bc:	33 21       	jnz	$+616    	;abs 0xb924
    b6be:	37 93       	cmp	#-1,	r7	;r3 As==11
    b6c0:	31 21       	jnz	$+612    	;abs 0xb924
    b6c2:	37 40 fe ff 	mov	#65534,	r7	;#0xfffe
    b6c6:	17 91 06 00 	cmp	6(r1),	r7	;
    b6ca:	2c 2d       	jc	$+602    	;abs 0xb924

0000b6cc <.L63>:
    b6cc:	b4 40 03 00 	mov	#3,	0(r4)	;
    b6d0:	00 00 

0000b6d2 <.Loc.712.1>:
    b6d2:	1a 44 06 00 	mov	6(r4),	r10	;
    b6d6:	1d 44 08 00 	mov	8(r4),	r13	;
    b6da:	1e 44 0a 00 	mov	10(r4),	r14	;0x0000a
    b6de:	1f 44 0c 00 	mov	12(r4),	r15	;0x0000c
    b6e2:	3c 40 ff 1f 	mov	#8191,	r12	;#0x1fff
    b6e6:	0c 9f       	cmp	r15,	r12	;
    b6e8:	b0 2e       	jc	$-670    	;abs 0xb44a

0000b6ea <.Loc.714.1>:
    b6ea:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    b6ee:	0c 4a       	mov	r10,	r12	;
    b6f0:	b0 12 b6 c3 	call	#50102		;#0xc3b6
    b6f4:	5a f3       	and.b	#1,	r10	;r3 As==01
    b6f6:	0c da       	bis	r10,	r12	;
    b6f8:	84 4c 06 00 	mov	r12,	6(r4)	;
    b6fc:	84 4d 08 00 	mov	r13,	8(r4)	;
    b700:	84 4e 0a 00 	mov	r14,	10(r4)	; 0x000a
    b704:	84 4f 0c 00 	mov	r15,	12(r4)	; 0x000c

0000b708 <.Loc.715.1>:
    b708:	94 53 04 00 	inc	4(r4)		;
    b70c:	9e 3e       	jmp	$-706    	;abs 0xb44a

0000b70e <.L7>:
    b70e:	0c 93       	cmp	#0,	r12	;r3 As==00
    b710:	5b 27       	jz	$-328    	;abs 0xb5c8

0000b712 <.Loc.652.1>:
    b712:	81 57 10 00 	add	r7,	16(r1)	; 0x0010

0000b716 <.LVL38>:
    b716:	81 47 00 00 	mov	r7,	0(r1)	;
    b71a:	0c 48       	mov	r8,	r12	;

0000b71c <.LVL39>:
    b71c:	1d 41 04 00 	mov	4(r1),	r13	;

0000b720 <.LVL40>:
    b720:	1e 41 06 00 	mov	6(r1),	r14	;
    b724:	1f 41 0c 00 	mov	12(r1),	r15	;0x0000c
    b728:	81 4b 02 00 	mov	r11,	2(r1)	;
    b72c:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000b730 <.LVL41>:
    b730:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    b734:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016
    b738:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    b73c:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a
    b740:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b742:	4d 43       	clr.b	r13		;
    b744:	0e 4d       	mov	r13,	r14	;
    b746:	0f 4d       	mov	r13,	r15	;
    b748:	b0 12 3a c4 	call	#50234		;#0xc43a
    b74c:	36 43       	mov	#-1,	r6	;r3 As==11
    b74e:	07 4c       	mov	r12,	r7	;

0000b750 <.LVL43>:
    b750:	07 56       	add	r6,	r7	;
    b752:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    b756:	55 43       	mov.b	#1,	r5	;r3 As==01
    b758:	1b 41 02 00 	mov	2(r1),	r11	;

0000b75c <.LVL44>:
    b75c:	07 9c       	cmp	r12,	r7	;
    b75e:	01 28       	jnc	$+4      	;abs 0xb762
    b760:	45 43       	clr.b	r5		;

0000b762 <.L19>:
    b762:	0c 4d       	mov	r13,	r12	;
    b764:	0c 56       	add	r6,	r12	;
    b766:	57 43       	mov.b	#1,	r7	;r3 As==01
    b768:	0c 9d       	cmp	r13,	r12	;
    b76a:	01 28       	jnc	$+4      	;abs 0xb76e
    b76c:	47 43       	clr.b	r7		;

0000b76e <.L20>:
    b76e:	05 5c       	add	r12,	r5	;
    b770:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b772:	05 9c       	cmp	r12,	r5	;
    b774:	01 28       	jnc	$+4      	;abs 0xb778
    b776:	4d 43       	clr.b	r13		;

0000b778 <.L21>:
    b778:	07 dd       	bis	r13,	r7	;
    b77a:	0d 4e       	mov	r14,	r13	;
    b77c:	0d 56       	add	r6,	r13	;
    b77e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b780:	0d 9e       	cmp	r14,	r13	;
    b782:	01 28       	jnc	$+4      	;abs 0xb786
    b784:	4c 43       	clr.b	r12		;

0000b786 <.L22>:
    b786:	07 5d       	add	r13,	r7	;
    b788:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b78a:	07 9d       	cmp	r13,	r7	;
    b78c:	01 28       	jnc	$+4      	;abs 0xb790
    b78e:	4e 43       	clr.b	r14		;

0000b790 <.L23>:
    b790:	0c de       	bis	r14,	r12	;
    b792:	0f 56       	add	r6,	r15	;
    b794:	0c 5f       	add	r15,	r12	;
    b796:	18 f1 12 00 	and	18(r1),	r8	;0x00012

0000b79a <.LVL45>:
    b79a:	15 f1 04 00 	and	4(r1),	r5	;
    b79e:	81 45 04 00 	mov	r5,	4(r1)	;
    b7a2:	17 f1 06 00 	and	6(r1),	r7	;
    b7a6:	81 47 06 00 	mov	r7,	6(r1)	;
    b7aa:	1c f1 0c 00 	and	12(r1),	r12	;0x0000c
    b7ae:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    b7b2:	4f 43       	clr.b	r15		;
    b7b4:	0c 4f       	mov	r15,	r12	;
    b7b6:	0c 88       	sub	r8,	r12	;
    b7b8:	57 43       	mov.b	#1,	r7	;r3 As==01
    b7ba:	0c 9f       	cmp	r15,	r12	;
    b7bc:	01 20       	jnz	$+4      	;abs 0xb7c0
    b7be:	07 4c       	mov	r12,	r7	;

0000b7c0 <.L24>:
    b7c0:	0e 4f       	mov	r15,	r14	;
    b7c2:	1e 81 04 00 	sub	4(r1),	r14	;
    b7c6:	56 43       	mov.b	#1,	r6	;r3 As==01
    b7c8:	0e 93       	cmp	#0,	r14	;r3 As==00
    b7ca:	01 20       	jnz	$+4      	;abs 0xb7ce
    b7cc:	06 4e       	mov	r14,	r6	;

0000b7ce <.L25>:
    b7ce:	0d 4e       	mov	r14,	r13	;
    b7d0:	0d 87       	sub	r7,	r13	;
    b7d2:	57 43       	mov.b	#1,	r7	;r3 As==01
    b7d4:	0e 9d       	cmp	r13,	r14	;
    b7d6:	01 28       	jnc	$+4      	;abs 0xb7da
    b7d8:	47 43       	clr.b	r7		;

0000b7da <.L26>:
    b7da:	06 d7       	bis	r7,	r6	;
    b7dc:	05 4f       	mov	r15,	r5	;
    b7de:	15 81 06 00 	sub	6(r1),	r5	;
    b7e2:	57 43       	mov.b	#1,	r7	;r3 As==01
    b7e4:	05 93       	cmp	#0,	r5	;r3 As==00
    b7e6:	01 20       	jnz	$+4      	;abs 0xb7ea
    b7e8:	07 45       	mov	r5,	r7	;

0000b7ea <.L27>:
    b7ea:	0e 45       	mov	r5,	r14	;
    b7ec:	0e 86       	sub	r6,	r14	;
    b7ee:	56 43       	mov.b	#1,	r6	;r3 As==01
    b7f0:	05 9e       	cmp	r14,	r5	;
    b7f2:	01 28       	jnc	$+4      	;abs 0xb7f6
    b7f4:	46 43       	clr.b	r6		;

0000b7f6 <.L28>:
    b7f6:	07 d6       	bis	r6,	r7	;
    b7f8:	1f 81 0c 00 	sub	12(r1),	r15	;0x0000c
    b7fc:	0f 87       	sub	r7,	r15	;
    b7fe:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    b802:	00 00 
    b804:	0c d8       	bis	r8,	r12	;
    b806:	1d d1 04 00 	bis	4(r1),	r13	;
    b80a:	1e d1 06 00 	bis	6(r1),	r14	;
    b80e:	1f d1 0c 00 	bis	12(r1),	r15	;0x0000c
    b812:	81 4b 02 00 	mov	r11,	2(r1)	;
    b816:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000b81a <.LVL46>:
    b81a:	18 41 14 00 	mov	20(r1),	r8	;0x00014
    b81e:	08 dc       	bis	r12,	r8	;
    b820:	1d d1 16 00 	bis	22(r1),	r13	;0x00016
    b824:	81 4d 04 00 	mov	r13,	4(r1)	;
    b828:	1e d1 18 00 	bis	24(r1),	r14	;0x00018
    b82c:	81 4e 06 00 	mov	r14,	6(r1)	;
    b830:	1f d1 1a 00 	bis	26(r1),	r15	;0x0001a
    b834:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c

0000b838 <.LVL47>:
    b838:	1b 41 02 00 	mov	2(r1),	r11	;

0000b83c <.LVL48>:
    b83c:	c5 3e       	jmp	$-628    	;abs 0xb5c8

0000b83e <.L6>:
    b83e:	1d 91 10 00 	cmp	16(r1),	r13	;0x00010
    b842:	0a 38       	jl	$+22     	;abs 0xb858
    b844:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010

0000b848 <.Loc.667.1>:
    b848:	48 43       	clr.b	r8		;

0000b84a <.LVL50>:
    b84a:	81 48 04 00 	mov	r8,	4(r1)	;
    b84e:	81 48 06 00 	mov	r8,	6(r1)	;
    b852:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c
    b856:	b8 3e       	jmp	$-654    	;abs 0xb5c8

0000b858 <.L77>:
    b858:	4b 43       	clr.b	r11		;

0000b85a <.LVL52>:
    b85a:	81 4b 08 00 	mov	r11,	8(r1)	;
    b85e:	81 4b 0a 00 	mov	r11,	10(r1)	; 0x000a
    b862:	81 4b 0e 00 	mov	r11,	14(r1)	; 0x000e
    b866:	b0 3e       	jmp	$-670    	;abs 0xb5c8

0000b868 <.L30>:
    b868:	09 48       	mov	r8,	r9	;
    b86a:	09 8b       	sub	r11,	r9	;

0000b86c <.LVL54>:
    b86c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b86e:	08 99       	cmp	r9,	r8	;
    b870:	01 28       	jnc	$+4      	;abs 0xb874
    b872:	0d 4c       	mov	r12,	r13	;

0000b874 <.L37>:
    b874:	1e 41 04 00 	mov	4(r1),	r14	;
    b878:	1e 81 08 00 	sub	8(r1),	r14	;
    b87c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b87e:	81 9e 04 00 	cmp	r14,	4(r1)	;
    b882:	01 28       	jnc	$+4      	;abs 0xb886
    b884:	4c 43       	clr.b	r12		;

0000b886 <.L38>:
    b886:	0a 4e       	mov	r14,	r10	;
    b888:	0a 8d       	sub	r13,	r10	;

0000b88a <.LVL55>:
    b88a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b88c:	0e 9a       	cmp	r10,	r14	;
    b88e:	01 28       	jnc	$+4      	;abs 0xb892
    b890:	4d 43       	clr.b	r13		;

0000b892 <.L39>:
    b892:	0c dd       	bis	r13,	r12	;
    b894:	1f 41 06 00 	mov	6(r1),	r15	;
    b898:	1f 81 0a 00 	sub	10(r1),	r15	;0x0000a
    b89c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b89e:	81 9f 06 00 	cmp	r15,	6(r1)	;
    b8a2:	01 28       	jnc	$+4      	;abs 0xb8a6
    b8a4:	4e 43       	clr.b	r14		;

0000b8a6 <.L40>:
    b8a6:	0d 4f       	mov	r15,	r13	;
    b8a8:	0d 8c       	sub	r12,	r13	;
    b8aa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b8ac:	0f 9d       	cmp	r13,	r15	;
    b8ae:	01 28       	jnc	$+4      	;abs 0xb8b2
    b8b0:	4c 43       	clr.b	r12		;

0000b8b2 <.L41>:
    b8b2:	0e dc       	bis	r12,	r14	;
    b8b4:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    b8b8:	1c 81 0e 00 	sub	14(r1),	r12	;0x0000e
    b8bc:	07 49       	mov	r9,	r7	;
    b8be:	0c 8e       	sub	r14,	r12	;

0000b8c0 <.LVL56>:
    b8c0:	b6 3e       	jmp	$-658    	;abs 0xb62e

0000b8c2 <.L42>:
    b8c2:	94 43 02 00 	mov	#1,	2(r4)	;r3 As==01

0000b8c6 <.Loc.691.1>:
    b8c6:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    b8ca:	04 00 

0000b8cc <.Loc.692.1>:
    b8cc:	4e 43       	clr.b	r14		;
    b8ce:	09 4e       	mov	r14,	r9	;
    b8d0:	09 87       	sub	r7,	r9	;
    b8d2:	58 43       	mov.b	#1,	r8	;r3 As==01
    b8d4:	09 9e       	cmp	r14,	r9	;
    b8d6:	01 20       	jnz	$+4      	;abs 0xb8da
    b8d8:	08 49       	mov	r9,	r8	;

0000b8da <.L45>:
    b8da:	0f 4e       	mov	r14,	r15	;
    b8dc:	0f 8a       	sub	r10,	r15	;
    b8de:	5a 43       	mov.b	#1,	r10	;r3 As==01

0000b8e0 <.LVL58>:
    b8e0:	0f 93       	cmp	#0,	r15	;r3 As==00
    b8e2:	01 20       	jnz	$+4      	;abs 0xb8e6
    b8e4:	0a 4f       	mov	r15,	r10	;

0000b8e6 <.L46>:
    b8e6:	07 4f       	mov	r15,	r7	;
    b8e8:	07 88       	sub	r8,	r7	;
    b8ea:	58 43       	mov.b	#1,	r8	;r3 As==01
    b8ec:	0f 97       	cmp	r7,	r15	;
    b8ee:	01 28       	jnc	$+4      	;abs 0xb8f2
    b8f0:	48 43       	clr.b	r8		;

0000b8f2 <.L47>:
    b8f2:	0a d8       	bis	r8,	r10	;
    b8f4:	0f 4e       	mov	r14,	r15	;
    b8f6:	0f 8d       	sub	r13,	r15	;
    b8f8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b8fa:	0f 93       	cmp	#0,	r15	;r3 As==00
    b8fc:	01 20       	jnz	$+4      	;abs 0xb900
    b8fe:	0d 4f       	mov	r15,	r13	;

0000b900 <.L48>:
    b900:	08 4f       	mov	r15,	r8	;
    b902:	08 8a       	sub	r10,	r8	;
    b904:	5a 43       	mov.b	#1,	r10	;r3 As==01
    b906:	0f 98       	cmp	r8,	r15	;
    b908:	01 28       	jnc	$+4      	;abs 0xb90c
    b90a:	4a 43       	clr.b	r10		;

0000b90c <.L49>:
    b90c:	0d da       	bis	r10,	r13	;
    b90e:	0e 8c       	sub	r12,	r14	;
    b910:	84 49 06 00 	mov	r9,	6(r4)	;
    b914:	84 47 08 00 	mov	r7,	8(r4)	;
    b918:	84 48 0a 00 	mov	r8,	10(r4)	; 0x000a
    b91c:	0e 8d       	sub	r13,	r14	;
    b91e:	84 4e 0c 00 	mov	r14,	12(r4)	; 0x000c
    b922:	94 3e       	jmp	$-726    	;abs 0xb64c

0000b924 <.L56>:
    b924:	07 4b       	mov	r11,	r7	;
    b926:	07 5b       	add	r11,	r7	;
    b928:	0d 4e       	mov	r14,	r13	;
    b92a:	07 9b       	cmp	r11,	r7	;
    b92c:	01 28       	jnc	$+4      	;abs 0xb930
    b92e:	0d 4f       	mov	r15,	r13	;

0000b930 <.L51>:
    b930:	05 4a       	mov	r10,	r5	;
    b932:	05 5a       	add	r10,	r5	;
    b934:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b936:	05 9a       	cmp	r10,	r5	;
    b938:	01 28       	jnc	$+4      	;abs 0xb93c
    b93a:	4c 43       	clr.b	r12		;

0000b93c <.L52>:
    b93c:	0d 55       	add	r5,	r13	;
    b93e:	0a 4e       	mov	r14,	r10	;
    b940:	0d 95       	cmp	r5,	r13	;
    b942:	01 28       	jnc	$+4      	;abs 0xb946
    b944:	0a 4f       	mov	r15,	r10	;

0000b946 <.L53>:
    b946:	0c da       	bis	r10,	r12	;
    b948:	05 49       	mov	r9,	r5	;
    b94a:	05 59       	add	r9,	r5	;
    b94c:	5a 43       	mov.b	#1,	r10	;r3 As==01
    b94e:	05 99       	cmp	r9,	r5	;
    b950:	01 28       	jnc	$+4      	;abs 0xb954
    b952:	4a 43       	clr.b	r10		;

0000b954 <.L54>:
    b954:	0c 55       	add	r5,	r12	;
    b956:	09 4e       	mov	r14,	r9	;
    b958:	0c 95       	cmp	r5,	r12	;
    b95a:	01 28       	jnc	$+4      	;abs 0xb95e
    b95c:	09 4f       	mov	r15,	r9	;

0000b95e <.L55>:
    b95e:	0a d9       	bis	r9,	r10	;
    b960:	08 58       	rla	r8		;
    b962:	84 47 06 00 	mov	r7,	6(r4)	;
    b966:	84 4d 08 00 	mov	r13,	8(r4)	;
    b96a:	84 4c 0a 00 	mov	r12,	10(r4)	; 0x000a
    b96e:	0a 58       	add	r8,	r10	;
    b970:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

0000b974 <.Loc.699.1>:
    b974:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11
    b978:	6c 3e       	jmp	$-806    	;abs 0xb652

0000b97a <.L29>:
    b97a:	84 4c 02 00 	mov	r12,	2(r4)	;

0000b97e <.Loc.705.1>:
    b97e:	94 41 10 00 	mov	16(r1),	4(r4)	;0x00010
    b982:	04 00 

0000b984 <.Loc.706.1>:
    b984:	06 48       	mov	r8,	r6	;
    b986:	06 5b       	add	r11,	r6	;
    b988:	5e 43       	mov.b	#1,	r14	;r3 As==01
    b98a:	06 98       	cmp	r8,	r6	;
    b98c:	01 28       	jnc	$+4      	;abs 0xb990
    b98e:	4e 43       	clr.b	r14		;

0000b990 <.L64>:
    b990:	1b 41 04 00 	mov	4(r1),	r11	;

0000b994 <.LVL61>:
    b994:	1b 51 08 00 	add	8(r1),	r11	;
    b998:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b99a:	1b 91 04 00 	cmp	4(r1),	r11	;
    b99e:	01 28       	jnc	$+4      	;abs 0xb9a2
    b9a0:	4c 43       	clr.b	r12		;

0000b9a2 <.L65>:
    b9a2:	0e 5b       	add	r11,	r14	;
    b9a4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b9a6:	0e 9b       	cmp	r11,	r14	;
    b9a8:	01 28       	jnc	$+4      	;abs 0xb9ac
    b9aa:	4d 43       	clr.b	r13		;

0000b9ac <.L66>:
    b9ac:	0c dd       	bis	r13,	r12	;
    b9ae:	17 41 06 00 	mov	6(r1),	r7	;
    b9b2:	17 51 0a 00 	add	10(r1),	r7	;0x0000a
    b9b6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    b9b8:	17 91 06 00 	cmp	6(r1),	r7	;
    b9bc:	01 28       	jnc	$+4      	;abs 0xb9c0
    b9be:	4f 43       	clr.b	r15		;

0000b9c0 <.L67>:
    b9c0:	0d 4c       	mov	r12,	r13	;
    b9c2:	0d 57       	add	r7,	r13	;
    b9c4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b9c6:	0d 97       	cmp	r7,	r13	;
    b9c8:	01 28       	jnc	$+4      	;abs 0xb9cc
    b9ca:	4c 43       	clr.b	r12		;

0000b9cc <.L68>:
    b9cc:	0f dc       	bis	r12,	r15	;
    b9ce:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    b9d2:	1c 51 0e 00 	add	14(r1),	r12	;0x0000e
    b9d6:	84 46 06 00 	mov	r6,	6(r4)	;
    b9da:	84 4e 08 00 	mov	r14,	8(r4)	;
    b9de:	84 4d 0a 00 	mov	r13,	10(r4)	; 0x000a
    b9e2:	0f 5c       	add	r12,	r15	;
    b9e4:	84 4f 0c 00 	mov	r15,	12(r4)	; 0x000c
    b9e8:	71 3e       	jmp	$-796    	;abs 0xb6cc

0000b9ea <.L76>:
    b9ea:	0a 49       	mov	r9,	r10	;

0000b9ec <L0>:
    b9ec:	30 40 18 b4 	br	#0xb418		;

0000b9f0 <__mspabi_addd>:
    b9f0:	2a 15       	pushm	#3,	r10	;16-bit words

0000b9f2 <.LCFI2>:
    b9f2:	31 80 3a 00 	sub	#58,	r1	;#0x003a

0000b9f6 <.LCFI3>:
    b9f6:	81 48 00 00 	mov	r8,	0(r1)	;
    b9fa:	81 49 02 00 	mov	r9,	2(r1)	;
    b9fe:	81 4a 04 00 	mov	r10,	4(r1)	;
    ba02:	81 4b 06 00 	mov	r11,	6(r1)	;

0000ba06 <.Loc.730.1>:
    ba06:	81 4c 08 00 	mov	r12,	8(r1)	;
    ba0a:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    ba0e:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    ba12:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

0000ba16 <.Loc.732.1>:
    ba16:	3a 40 68 ca 	mov	#51816,	r10	;#0xca68
    ba1a:	0d 41       	mov	r1,	r13	;
    ba1c:	3d 50 10 00 	add	#16,	r13	;#0x0010
    ba20:	0c 41       	mov	r1,	r12	;

0000ba22 <.LVL65>:
    ba22:	8a 12       	call	r10		;

0000ba24 <.LVL66>:
    ba24:	0d 41       	mov	r1,	r13	;
    ba26:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    ba2a:	0c 41       	mov	r1,	r12	;
    ba2c:	3c 52       	add	#8,	r12	;r2 As==11
    ba2e:	8a 12       	call	r10		;

0000ba30 <.LVL67>:
    ba30:	0e 41       	mov	r1,	r14	;
    ba32:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    ba36:	0d 41       	mov	r1,	r13	;
    ba38:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    ba3c:	0c 41       	mov	r1,	r12	;
    ba3e:	3c 50 10 00 	add	#16,	r12	;#0x0010
    ba42:	b0 12 e6 b3 	call	#46054		;#0xb3e6

0000ba46 <.LVL68>:
    ba46:	b0 12 80 c7 	call	#51072		;#0xc780

0000ba4a <.LVL69>:
    ba4a:	31 50 3a 00 	add	#58,	r1	;#0x003a
    ba4e:	28 17       	popm	#3,	r10	;16-bit words
    ba50:	30 41       	ret			

0000ba52 <__mspabi_subd>:
    ba52:	2a 15       	pushm	#3,	r10	;16-bit words

0000ba54 <.LCFI4>:
    ba54:	31 80 3a 00 	sub	#58,	r1	;#0x003a

0000ba58 <.LCFI5>:
    ba58:	81 48 00 00 	mov	r8,	0(r1)	;
    ba5c:	81 49 02 00 	mov	r9,	2(r1)	;
    ba60:	81 4a 04 00 	mov	r10,	4(r1)	;
    ba64:	81 4b 06 00 	mov	r11,	6(r1)	;

0000ba68 <.Loc.750.1>:
    ba68:	81 4c 08 00 	mov	r12,	8(r1)	;
    ba6c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    ba70:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    ba74:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e

0000ba78 <.Loc.752.1>:
    ba78:	3a 40 68 ca 	mov	#51816,	r10	;#0xca68
    ba7c:	0d 41       	mov	r1,	r13	;
    ba7e:	3d 50 10 00 	add	#16,	r13	;#0x0010
    ba82:	0c 41       	mov	r1,	r12	;

0000ba84 <.LVL71>:
    ba84:	8a 12       	call	r10		;

0000ba86 <.LVL72>:
    ba86:	0d 41       	mov	r1,	r13	;
    ba88:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    ba8c:	0c 41       	mov	r1,	r12	;
    ba8e:	3c 52       	add	#8,	r12	;r2 As==11
    ba90:	8a 12       	call	r10		;

0000ba92 <.LVL73>:
    ba92:	91 e3 20 00 	xor	#1,	32(r1)	;r3 As==01, 0x0020

0000ba96 <.Loc.757.1>:
    ba96:	0e 41       	mov	r1,	r14	;
    ba98:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    ba9c:	0d 41       	mov	r1,	r13	;
    ba9e:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    baa2:	0c 41       	mov	r1,	r12	;
    baa4:	3c 50 10 00 	add	#16,	r12	;#0x0010
    baa8:	b0 12 e6 b3 	call	#46054		;#0xb3e6

0000baac <.LVL74>:
    baac:	b0 12 80 c7 	call	#51072		;#0xc780

0000bab0 <.LVL75>:
    bab0:	31 50 3a 00 	add	#58,	r1	;#0x003a
    bab4:	28 17       	popm	#3,	r10	;16-bit words
    bab6:	30 41       	ret			

0000bab8 <__mspabi_mpyd>:
    bab8:	6a 15       	pushm	#7,	r10	;16-bit words

0000baba <.LCFI0>:
    baba:	31 80 5a 00 	sub	#90,	r1	;#0x005a

0000babe <.LCFI1>:
    babe:	81 48 20 00 	mov	r8,	32(r1)	; 0x0020
    bac2:	81 49 22 00 	mov	r9,	34(r1)	; 0x0022
    bac6:	81 4a 24 00 	mov	r10,	36(r1)	; 0x0024
    baca:	81 4b 26 00 	mov	r11,	38(r1)	; 0x0026

0000bace <.Loc.936.1>:
    bace:	81 4c 28 00 	mov	r12,	40(r1)	; 0x0028
    bad2:	81 4d 2a 00 	mov	r13,	42(r1)	; 0x002a
    bad6:	81 4e 2c 00 	mov	r14,	44(r1)	; 0x002c
    bada:	81 4f 2e 00 	mov	r15,	46(r1)	; 0x002e

0000bade <.Loc.938.1>:
    bade:	3a 40 68 ca 	mov	#51816,	r10	;#0xca68
    bae2:	0d 41       	mov	r1,	r13	;
    bae4:	3d 50 30 00 	add	#48,	r13	;#0x0030
    bae8:	0c 41       	mov	r1,	r12	;

0000baea <.LVL1>:
    baea:	3c 50 20 00 	add	#32,	r12	;#0x0020
    baee:	8a 12       	call	r10		;

0000baf0 <.LVL2>:
    baf0:	0d 41       	mov	r1,	r13	;
    baf2:	3d 50 3e 00 	add	#62,	r13	;#0x003e
    baf6:	0c 41       	mov	r1,	r12	;
    baf8:	3c 50 28 00 	add	#40,	r12	;#0x0028
    bafc:	8a 12       	call	r10		;

0000bafe <.LVL3>:
    bafe:	1d 41 30 00 	mov	48(r1),	r13	;0x00030

0000bb02 <.LBB28>:
    bb02:	5a 43       	mov.b	#1,	r10	;r3 As==01
    bb04:	0a 9d       	cmp	r13,	r10	;
    bb06:	15 28       	jnc	$+44     	;abs 0xbb32

0000bb08 <.L6>:
    bb08:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    bb0c:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    bb10:	0c 43       	clr	r12		;
    bb12:	0c 8d       	sub	r13,	r12	;
    bb14:	0c dd       	bis	r13,	r12	;
    bb16:	5c 03       	rrum	#1,	r12	;
    bb18:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    bb1c:	81 4c 32 00 	mov	r12,	50(r1)	; 0x0032

0000bb20 <.Loc.775.1>:
    bb20:	0c 41       	mov	r1,	r12	;
    bb22:	3c 50 30 00 	add	#48,	r12	;#0x0030

0000bb26 <.L3>:
    bb26:	b0 12 80 c7 	call	#51072		;#0xc780

0000bb2a <.LVL7>:
    bb2a:	31 50 5a 00 	add	#90,	r1	;#0x005a
    bb2e:	64 17       	popm	#7,	r10	;16-bit words
    bb30:	30 41       	ret			

0000bb32 <.L2>:
    bb32:	1c 41 3e 00 	mov	62(r1),	r12	;0x0003e

0000bb36 <.LBB33>:
    bb36:	5e 43       	mov.b	#1,	r14	;r3 As==01
    bb38:	0e 9c       	cmp	r12,	r14	;
    bb3a:	10 28       	jnc	$+34     	;abs 0xbb5c

0000bb3c <.L8>:
    bb3c:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    bb40:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    bb44:	0c 43       	clr	r12		;
    bb46:	0c 8d       	sub	r13,	r12	;
    bb48:	0c dd       	bis	r13,	r12	;
    bb4a:	5c 03       	rrum	#1,	r12	;
    bb4c:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    bb50:	81 4c 40 00 	mov	r12,	64(r1)	; 0x0040

0000bb54 <.Loc.780.1>:
    bb54:	0c 41       	mov	r1,	r12	;
    bb56:	3c 50 3e 00 	add	#62,	r12	;#0x003e
    bb5a:	e5 3f       	jmp	$-52     	;abs 0xbb26

0000bb5c <.L4>:
    bb5c:	2d 92       	cmp	#4,	r13	;r2 As==10
    bb5e:	05 20       	jnz	$+12     	;abs 0xbb6a

0000bb60 <.Loc.784.1>:
    bb60:	2c 93       	cmp	#2,	r12	;r3 As==10
    bb62:	d2 23       	jnz	$-90     	;abs 0xbb08

0000bb64 <.L68>:
    bb64:	3c 40 60 51 	mov	#20832,	r12	;#0x5160
    bb68:	de 3f       	jmp	$-66     	;abs 0xbb26

0000bb6a <.L5>:
    bb6a:	2c 92       	cmp	#4,	r12	;r2 As==10
    bb6c:	03 20       	jnz	$+8      	;abs 0xbb74

0000bb6e <.Loc.791.1>:
    bb6e:	2d 93       	cmp	#2,	r13	;r3 As==10
    bb70:	e5 23       	jnz	$-52     	;abs 0xbb3c
    bb72:	f8 3f       	jmp	$-14     	;abs 0xbb64

0000bb74 <.L7>:
    bb74:	2d 93       	cmp	#2,	r13	;r3 As==10
    bb76:	c8 27       	jz	$-110    	;abs 0xbb08

0000bb78 <.Loc.803.1>:
    bb78:	2c 93       	cmp	#2,	r12	;r3 As==10
    bb7a:	e0 27       	jz	$-62     	;abs 0xbb3c

0000bb7c <.LBB30>:
    bb7c:	16 41 36 00 	mov	54(r1),	r6	;0x00036
    bb80:	17 41 38 00 	mov	56(r1),	r7	;0x00038

0000bb84 <.Loc.852.1>:
    bb84:	3a 40 b6 c3 	mov	#50102,	r10	;#0xc3b6
    bb88:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    bb8c:	00 00 
    bb8e:	0c 46       	mov	r6,	r12	;
    bb90:	0d 47       	mov	r7,	r13	;
    bb92:	1e 41 3a 00 	mov	58(r1),	r14	;0x0003a
    bb96:	1f 41 3c 00 	mov	60(r1),	r15	;0x0003c
    bb9a:	8a 12       	call	r10		;

0000bb9c <.LVL18>:
    bb9c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    bba0:	81 4d 16 00 	mov	r13,	22(r1)	; 0x0016
    bba4:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    bba8:	81 4f 08 00 	mov	r15,	8(r1)	;

0000bbac <.Loc.853.1>:
    bbac:	91 41 44 00 	mov	68(r1),	4(r1)	;0x00044
    bbb0:	04 00 
    bbb2:	91 41 46 00 	mov	70(r1),	6(r1)	;0x00046
    bbb6:	06 00 

0000bbb8 <.Loc.854.1>:
    bbb8:	1c 41 04 00 	mov	4(r1),	r12	;
    bbbc:	1d 41 06 00 	mov	6(r1),	r13	;
    bbc0:	1e 41 48 00 	mov	72(r1),	r14	;0x00048
    bbc4:	1f 41 4a 00 	mov	74(r1),	r15	;0x0004a
    bbc8:	8a 12       	call	r10		;

0000bbca <.LVL25>:
    bbca:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    bbce:	05 4d       	mov	r13,	r5	;
    bbd0:	81 4e 1a 00 	mov	r14,	26(r1)	; 0x001a
    bbd4:	81 4f 0c 00 	mov	r15,	12(r1)	; 0x000c

0000bbd8 <.Loc.855.1>:
    bbd8:	34 40 b4 ad 	mov	#44468,	r4	;#0xadb4
    bbdc:	0c 46       	mov	r6,	r12	;
    bbde:	0d 47       	mov	r7,	r13	;
    bbe0:	4e 43       	clr.b	r14		;
    bbe2:	0f 4e       	mov	r14,	r15	;
    bbe4:	18 41 04 00 	mov	4(r1),	r8	;

0000bbe8 <.LVL30>:
    bbe8:	19 41 06 00 	mov	6(r1),	r9	;
    bbec:	0a 4e       	mov	r14,	r10	;
    bbee:	0b 4e       	mov	r14,	r11	;
    bbf0:	84 12       	call	r4		;

0000bbf2 <.LVL31>:
    bbf2:	81 4c 1c 00 	mov	r12,	28(r1)	; 0x001c
    bbf6:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010
    bbfa:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012
    bbfe:	81 4f 14 00 	mov	r15,	20(r1)	; 0x0014

0000bc02 <.LVL32>:
    bc02:	0c 46       	mov	r6,	r12	;

0000bc04 <.LVL33>:
    bc04:	0d 47       	mov	r7,	r13	;

0000bc06 <.LVL34>:
    bc06:	0e 4a       	mov	r10,	r14	;

0000bc08 <.LVL35>:
    bc08:	0f 4a       	mov	r10,	r15	;

0000bc0a <.LVL36>:
    bc0a:	18 41 0a 00 	mov	10(r1),	r8	;0x0000a
    bc0e:	09 45       	mov	r5,	r9	;
    bc10:	1a 41 1a 00 	mov	26(r1),	r10	;0x0001a
    bc14:	1b 41 0c 00 	mov	12(r1),	r11	;0x0000c
    bc18:	84 12       	call	r4		;

0000bc1a <.LVL37>:
    bc1a:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    bc1e:	05 4d       	mov	r13,	r5	;
    bc20:	06 4e       	mov	r14,	r6	;
    bc22:	07 4f       	mov	r15,	r7	;

0000bc24 <.LVL40>:
    bc24:	0c 48       	mov	r8,	r12	;

0000bc26 <.LVL41>:
    bc26:	0d 49       	mov	r9,	r13	;
    bc28:	0e 4a       	mov	r10,	r14	;
    bc2a:	1f 41 0c 00 	mov	12(r1),	r15	;0x0000c
    bc2e:	18 41 0e 00 	mov	14(r1),	r8	;0x0000e
    bc32:	19 41 16 00 	mov	22(r1),	r9	;0x00016
    bc36:	1a 41 18 00 	mov	24(r1),	r10	;0x00018
    bc3a:	1b 41 08 00 	mov	8(r1),	r11	;
    bc3e:	84 12       	call	r4		;

0000bc40 <.LVL44>:
    bc40:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    bc44:	81 4d 18 00 	mov	r13,	24(r1)	; 0x0018
    bc48:	81 4e 1a 00 	mov	r14,	26(r1)	; 0x001a
    bc4c:	81 4f 1e 00 	mov	r15,	30(r1)	; 0x001e

0000bc50 <.LVL47>:
    bc50:	1c 41 04 00 	mov	4(r1),	r12	;

0000bc54 <.LVL48>:
    bc54:	1d 41 06 00 	mov	6(r1),	r13	;

0000bc58 <.LVL49>:
    bc58:	4e 43       	clr.b	r14		;

0000bc5a <.LVL50>:
    bc5a:	0f 4e       	mov	r14,	r15	;

0000bc5c <.LVL51>:
    bc5c:	1b 41 08 00 	mov	8(r1),	r11	;
    bc60:	84 12       	call	r4		;

0000bc62 <.LVL52>:
    bc62:	1a 41 0a 00 	mov	10(r1),	r10	;0x0000a
    bc66:	0a 5c       	add	r12,	r10	;
    bc68:	81 4a 0c 00 	mov	r10,	12(r1)	; 0x000c
    bc6c:	58 43       	mov.b	#1,	r8	;r3 As==01
    bc6e:	0a 9c       	cmp	r12,	r10	;
    bc70:	01 28       	jnc	$+4      	;abs 0xbc74
    bc72:	48 43       	clr.b	r8		;

0000bc74 <.L9>:
    bc74:	0c 4d       	mov	r13,	r12	;
    bc76:	0c 55       	add	r5,	r12	;
    bc78:	5a 43       	mov.b	#1,	r10	;r3 As==01
    bc7a:	0c 9d       	cmp	r13,	r12	;
    bc7c:	01 28       	jnc	$+4      	;abs 0xbc80
    bc7e:	4a 43       	clr.b	r10		;

0000bc80 <.L10>:
    bc80:	08 5c       	add	r12,	r8	;
    bc82:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bc84:	08 9c       	cmp	r12,	r8	;
    bc86:	01 28       	jnc	$+4      	;abs 0xbc8a
    bc88:	4d 43       	clr.b	r13		;

0000bc8a <.L11>:
    bc8a:	0a dd       	bis	r13,	r10	;
    bc8c:	0c 4e       	mov	r14,	r12	;
    bc8e:	0c 56       	add	r6,	r12	;
    bc90:	59 43       	mov.b	#1,	r9	;r3 As==01
    bc92:	0c 9e       	cmp	r14,	r12	;
    bc94:	01 28       	jnc	$+4      	;abs 0xbc98
    bc96:	49 43       	clr.b	r9		;

0000bc98 <.L12>:
    bc98:	0a 5c       	add	r12,	r10	;
    bc9a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bc9c:	0a 9c       	cmp	r12,	r10	;
    bc9e:	01 28       	jnc	$+4      	;abs 0xbca2
    bca0:	4d 43       	clr.b	r13		;

0000bca2 <.L13>:
    bca2:	09 dd       	bis	r13,	r9	;
    bca4:	0f 57       	add	r7,	r15	;
    bca6:	09 5f       	add	r15,	r9	;

0000bca8 <.LVL54>:
    bca8:	09 97       	cmp	r7,	r9	;
    bcaa:	0e 28       	jnc	$+30     	;abs 0xbcc8
    bcac:	07 99       	cmp	r9,	r7	;
    bcae:	35 21       	jnz	$+620    	;abs 0xbf1a
    bcb0:	0a 96       	cmp	r6,	r10	;
    bcb2:	0a 28       	jnc	$+22     	;abs 0xbcc8
    bcb4:	06 9a       	cmp	r10,	r6	;
    bcb6:	31 21       	jnz	$+612    	;abs 0xbf1a
    bcb8:	08 95       	cmp	r5,	r8	;
    bcba:	06 28       	jnc	$+14     	;abs 0xbcc8
    bcbc:	05 98       	cmp	r8,	r5	;
    bcbe:	2d 21       	jnz	$+604    	;abs 0xbf1a
    bcc0:	91 91 0a 00 	cmp	10(r1),	12(r1)	;0x0000a, 0x000c
    bcc4:	0c 00 
    bcc6:	29 2d       	jc	$+596    	;abs 0xbf1a

0000bcc8 <.L70>:
    bcc8:	47 43       	clr.b	r7		;

0000bcca <.LVL55>:
    bcca:	05 47       	mov	r7,	r5	;
    bccc:	91 43 0e 00 	mov	#1,	14(r1)	;r3 As==01, 0x000e

0000bcd0 <.L93>:
    bcd0:	81 47 0a 00 	mov	r7,	10(r1)	; 0x000a

0000bcd4 <.LVL56>:
    bcd4:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    bcd8:	00 00 
    bcda:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    bcde:	0d 48       	mov	r8,	r13	;
    bce0:	0e 4a       	mov	r10,	r14	;
    bce2:	0f 49       	mov	r9,	r15	;
    bce4:	b0 12 3a c4 	call	#50234		;#0xc43a
    bce8:	14 41 1c 00 	mov	28(r1),	r4	;0x0001c
    bcec:	04 5c       	add	r12,	r4	;
    bcee:	5b 43       	mov.b	#1,	r11	;r3 As==01
    bcf0:	04 9c       	cmp	r12,	r4	;
    bcf2:	01 28       	jnc	$+4      	;abs 0xbcf6
    bcf4:	4b 43       	clr.b	r11		;

0000bcf6 <.L16>:
    bcf6:	16 41 10 00 	mov	16(r1),	r6	;0x00010
    bcfa:	06 5d       	add	r13,	r6	;
    bcfc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    bcfe:	06 9d       	cmp	r13,	r6	;
    bd00:	01 28       	jnc	$+4      	;abs 0xbd04
    bd02:	4c 43       	clr.b	r12		;

0000bd04 <.L17>:
    bd04:	0b 56       	add	r6,	r11	;
    bd06:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bd08:	0b 96       	cmp	r6,	r11	;
    bd0a:	01 28       	jnc	$+4      	;abs 0xbd0e
    bd0c:	4d 43       	clr.b	r13		;

0000bd0e <.L18>:
    bd0e:	0c dd       	bis	r13,	r12	;
    bd10:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    bd14:	0d 5e       	add	r14,	r13	;
    bd16:	56 43       	mov.b	#1,	r6	;r3 As==01
    bd18:	0d 9e       	cmp	r14,	r13	;
    bd1a:	01 28       	jnc	$+4      	;abs 0xbd1e
    bd1c:	46 43       	clr.b	r6		;

0000bd1e <.L19>:
    bd1e:	0e 4c       	mov	r12,	r14	;
    bd20:	0e 5d       	add	r13,	r14	;
    bd22:	5c 43       	mov.b	#1,	r12	;r3 As==01
    bd24:	0e 9d       	cmp	r13,	r14	;
    bd26:	01 28       	jnc	$+4      	;abs 0xbd2a
    bd28:	4c 43       	clr.b	r12		;

0000bd2a <.L20>:
    bd2a:	06 dc       	bis	r12,	r6	;
    bd2c:	1f 51 14 00 	add	20(r1),	r15	;0x00014
    bd30:	81 44 08 00 	mov	r4,	8(r1)	;
    bd34:	81 4e 04 00 	mov	r14,	4(r1)	;
    bd38:	06 5f       	add	r15,	r6	;
    bd3a:	81 46 06 00 	mov	r6,	6(r1)	;

0000bd3e <.LVL59>:
    bd3e:	16 91 14 00 	cmp	20(r1),	r6	;0x00014
    bd42:	12 28       	jnc	$+38     	;abs 0xbd68
    bd44:	81 96 14 00 	cmp	r6,	20(r1)	; 0x0014
    bd48:	13 20       	jnz	$+40     	;abs 0xbd70
    bd4a:	1e 91 12 00 	cmp	18(r1),	r14	;0x00012
    bd4e:	0c 28       	jnc	$+26     	;abs 0xbd68
    bd50:	81 9e 12 00 	cmp	r14,	18(r1)	; 0x0012
    bd54:	0d 20       	jnz	$+28     	;abs 0xbd70
    bd56:	1b 91 10 00 	cmp	16(r1),	r11	;0x00010
    bd5a:	06 28       	jnc	$+14     	;abs 0xbd68
    bd5c:	81 9b 10 00 	cmp	r11,	16(r1)	; 0x0010
    bd60:	07 20       	jnz	$+16     	;abs 0xbd70
    bd62:	14 91 1c 00 	cmp	28(r1),	r4	;0x0001c
    bd66:	04 2c       	jc	$+10     	;abs 0xbd70

0000bd68 <.L71>:
    bd68:	57 43       	mov.b	#1,	r7	;r3 As==01
    bd6a:	45 43       	clr.b	r5		;
    bd6c:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a

0000bd70 <.L21>:
    bd70:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    bd74:	00 00 
    bd76:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    bd7a:	0d 48       	mov	r8,	r13	;
    bd7c:	0e 4a       	mov	r10,	r14	;

0000bd7e <.LVL62>:
    bd7e:	0f 49       	mov	r9,	r15	;
    bd80:	81 4b 02 00 	mov	r11,	2(r1)	;
    bd84:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000bd88 <.LVL63>:
    bd88:	19 41 16 00 	mov	22(r1),	r9	;0x00016

0000bd8c <.LVL64>:
    bd8c:	09 5c       	add	r12,	r9	;
    bd8e:	5a 43       	mov.b	#1,	r10	;r3 As==01
    bd90:	1b 41 02 00 	mov	2(r1),	r11	;

0000bd94 <.LVL65>:
    bd94:	09 9c       	cmp	r12,	r9	;
    bd96:	01 28       	jnc	$+4      	;abs 0xbd9a
    bd98:	4a 43       	clr.b	r10		;

0000bd9a <.L28>:
    bd9a:	18 41 18 00 	mov	24(r1),	r8	;0x00018
    bd9e:	08 5d       	add	r13,	r8	;
    bda0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    bda2:	08 9d       	cmp	r13,	r8	;
    bda4:	01 28       	jnc	$+4      	;abs 0xbda8
    bda6:	4c 43       	clr.b	r12		;

0000bda8 <.L29>:
    bda8:	0a 58       	add	r8,	r10	;
    bdaa:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bdac:	0a 98       	cmp	r8,	r10	;
    bdae:	01 28       	jnc	$+4      	;abs 0xbdb2
    bdb0:	4d 43       	clr.b	r13		;

0000bdb2 <.L30>:
    bdb2:	0c dd       	bis	r13,	r12	;
    bdb4:	18 41 1a 00 	mov	26(r1),	r8	;0x0001a
    bdb8:	08 5e       	add	r14,	r8	;
    bdba:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bdbc:	08 9e       	cmp	r14,	r8	;
    bdbe:	01 28       	jnc	$+4      	;abs 0xbdc2
    bdc0:	4d 43       	clr.b	r13		;

0000bdc2 <.L31>:
    bdc2:	0c 58       	add	r8,	r12	;
    bdc4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    bdc6:	0c 98       	cmp	r8,	r12	;
    bdc8:	01 28       	jnc	$+4      	;abs 0xbdcc
    bdca:	4e 43       	clr.b	r14		;

0000bdcc <.L32>:
    bdcc:	0d de       	bis	r14,	r13	;
    bdce:	1f 51 1e 00 	add	30(r1),	r15	;0x0001e
    bdd2:	0f 5d       	add	r13,	r15	;
    bdd4:	07 59       	add	r9,	r7	;
    bdd6:	54 43       	mov.b	#1,	r4	;r3 As==01

0000bdd8 <.LVL66>:
    bdd8:	07 99       	cmp	r9,	r7	;
    bdda:	01 28       	jnc	$+4      	;abs 0xbdde
    bddc:	44 43       	clr.b	r4		;

0000bdde <.L33>:
    bdde:	0d 4a       	mov	r10,	r13	;
    bde0:	0d 55       	add	r5,	r13	;
    bde2:	56 43       	mov.b	#1,	r6	;r3 As==01

0000bde4 <.LVL67>:
    bde4:	0d 9a       	cmp	r10,	r13	;
    bde6:	01 28       	jnc	$+4      	;abs 0xbdea
    bde8:	46 43       	clr.b	r6		;

0000bdea <.L34>:
    bdea:	04 5d       	add	r13,	r4	;
    bdec:	5e 43       	mov.b	#1,	r14	;r3 As==01
    bdee:	04 9d       	cmp	r13,	r4	;
    bdf0:	01 28       	jnc	$+4      	;abs 0xbdf4
    bdf2:	4e 43       	clr.b	r14		;

0000bdf4 <.L35>:
    bdf4:	06 de       	bis	r14,	r6	;
    bdf6:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    bdfa:	0d 5c       	add	r12,	r13	;
    bdfc:	55 43       	mov.b	#1,	r5	;r3 As==01
    bdfe:	0d 9c       	cmp	r12,	r13	;
    be00:	01 28       	jnc	$+4      	;abs 0xbe04
    be02:	45 43       	clr.b	r5		;

0000be04 <.L36>:
    be04:	06 5d       	add	r13,	r6	;
    be06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    be08:	06 9d       	cmp	r13,	r6	;
    be0a:	01 28       	jnc	$+4      	;abs 0xbe0e
    be0c:	4c 43       	clr.b	r12		;

0000be0e <.L37>:
    be0e:	05 dc       	bis	r12,	r5	;
    be10:	1f 51 0a 00 	add	10(r1),	r15	;0x0000a
    be14:	05 5f       	add	r15,	r5	;

0000be16 <.LBE30>:
    be16:	1a 41 34 00 	mov	52(r1),	r10	;0x00034
    be1a:	1a 51 42 00 	add	66(r1),	r10	;0x00042

0000be1e <.Loc.876.1>:
    be1e:	2a 52       	add	#4,	r10	;r2 As==10

0000be20 <.Loc.875.1>:
    be20:	81 4a 50 00 	mov	r10,	80(r1)	; 0x0050

0000be24 <.Loc.877.1>:
    be24:	1d 41 32 00 	mov	50(r1),	r13	;0x00032
    be28:	1d e1 40 00 	xor	64(r1),	r13	;0x00040
    be2c:	0c 43       	clr	r12		;
    be2e:	0c 8d       	sub	r13,	r12	;
    be30:	0c dd       	bis	r13,	r12	;
    be32:	5c 03       	rrum	#1,	r12	;
    be34:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    be38:	81 4c 4e 00 	mov	r12,	78(r1)	; 0x004e
    be3c:	4c 43       	clr.b	r12		;
    be3e:	38 40 b6 c3 	mov	#50102,	r8	;#0xc3b6

0000be42 <.Loc.883.1>:
    be42:	59 43       	mov.b	#1,	r9	;r3 As==01

0000be44 <.L38>:
    be44:	3d 40 ff 1f 	mov	#8191,	r13	;#0x1fff
    be48:	0d 95       	cmp	r5,	r13	;
    be4a:	6c 28       	jnc	$+218    	;abs 0xbf24
    be4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    be4e:	02 24       	jz	$+6      	;abs 0xbe54
    be50:	81 4a 50 00 	mov	r10,	80(r1)	; 0x0050

0000be54 <.L43>:
    be54:	18 41 50 00 	mov	80(r1),	r8	;0x00050

0000be58 <.Loc.877.1>:
    be58:	4d 43       	clr.b	r13		;

0000be5a <.Loc.892.1>:
    be5a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    be5c:	0e 4d       	mov	r13,	r14	;

0000be5e <.L44>:
    be5e:	3f 40 ff 0f 	mov	#4095,	r15	;#0x0fff
    be62:	0f 95       	cmp	r5,	r15	;
    be64:	86 28       	jnc	$+270    	;abs 0xbf72

0000be66 <.Loc.892.1>:
    be66:	0a 47       	mov	r7,	r10	;
    be68:	0a 57       	add	r7,	r10	;
    be6a:	0f 4c       	mov	r12,	r15	;
    be6c:	0a 97       	cmp	r7,	r10	;
    be6e:	01 28       	jnc	$+4      	;abs 0xbe72
    be70:	0f 4e       	mov	r14,	r15	;

0000be72 <.L45>:
    be72:	09 44       	mov	r4,	r9	;
    be74:	09 54       	add	r4,	r9	;
    be76:	5d 43       	mov.b	#1,	r13	;r3 As==01
    be78:	09 94       	cmp	r4,	r9	;
    be7a:	01 28       	jnc	$+4      	;abs 0xbe7e
    be7c:	4d 43       	clr.b	r13		;

0000be7e <.L46>:
    be7e:	04 4f       	mov	r15,	r4	;

0000be80 <.LVL71>:
    be80:	04 59       	add	r9,	r4	;
    be82:	0f 4c       	mov	r12,	r15	;
    be84:	04 99       	cmp	r9,	r4	;
    be86:	01 28       	jnc	$+4      	;abs 0xbe8a
    be88:	0f 4e       	mov	r14,	r15	;

0000be8a <.L47>:
    be8a:	0d df       	bis	r15,	r13	;
    be8c:	0f 46       	mov	r6,	r15	;
    be8e:	0f 56       	add	r6,	r15	;
    be90:	59 43       	mov.b	#1,	r9	;r3 As==01
    be92:	0f 96       	cmp	r6,	r15	;
    be94:	01 28       	jnc	$+4      	;abs 0xbe98
    be96:	49 43       	clr.b	r9		;

0000be98 <.L48>:
    be98:	06 4d       	mov	r13,	r6	;
    be9a:	06 5f       	add	r15,	r6	;
    be9c:	0d 4c       	mov	r12,	r13	;
    be9e:	06 9f       	cmp	r15,	r6	;
    bea0:	01 28       	jnc	$+4      	;abs 0xbea4
    bea2:	0d 4e       	mov	r14,	r13	;

0000bea4 <.L49>:
    bea4:	09 dd       	bis	r13,	r9	;
    bea6:	05 55       	rla	r5		;
    bea8:	07 4a       	mov	r10,	r7	;
    beaa:	05 59       	add	r9,	r5	;

0000beac <.LVL72>:
    beac:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    beb0:	01 34       	jge	$+4      	;abs 0xbeb4

0000beb2 <.Loc.894.1>:
    beb2:	17 d3       	bis	#1,	r7	;r3 As==01

0000beb4 <.L50>:
    beb4:	19 41 08 00 	mov	8(r1),	r9	;
    beb8:	09 59       	rla	r9		;
    beba:	0a 4c       	mov	r12,	r10	;
    bebc:	19 91 08 00 	cmp	8(r1),	r9	;
    bec0:	01 28       	jnc	$+4      	;abs 0xbec4
    bec2:	0a 4e       	mov	r14,	r10	;

0000bec4 <.L52>:
    bec4:	0f 4b       	mov	r11,	r15	;
    bec6:	0f 5b       	add	r11,	r15	;
    bec8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    beca:	0f 9b       	cmp	r11,	r15	;
    becc:	01 28       	jnc	$+4      	;abs 0xbed0
    bece:	4d 43       	clr.b	r13		;

0000bed0 <.L53>:
    bed0:	0b 4a       	mov	r10,	r11	;

0000bed2 <.LVL74>:
    bed2:	0b 5f       	add	r15,	r11	;
    bed4:	0a 4c       	mov	r12,	r10	;
    bed6:	0b 9f       	cmp	r15,	r11	;
    bed8:	01 28       	jnc	$+4      	;abs 0xbedc
    beda:	0a 4e       	mov	r14,	r10	;

0000bedc <.L54>:
    bedc:	0d da       	bis	r10,	r13	;
    bede:	1f 41 04 00 	mov	4(r1),	r15	;
    bee2:	0f 5f       	rla	r15		;
    bee4:	5a 43       	mov.b	#1,	r10	;r3 As==01
    bee6:	1f 91 04 00 	cmp	4(r1),	r15	;
    beea:	01 28       	jnc	$+4      	;abs 0xbeee
    beec:	4a 43       	clr.b	r10		;

0000beee <.L55>:
    beee:	0d 5f       	add	r15,	r13	;
    bef0:	81 4c 04 00 	mov	r12,	4(r1)	;
    bef4:	0d 9f       	cmp	r15,	r13	;
    bef6:	02 28       	jnc	$+6      	;abs 0xbefc
    bef8:	81 4e 04 00 	mov	r14,	4(r1)	;

0000befc <.L56>:
    befc:	1a d1 04 00 	bis	4(r1),	r10	;
    bf00:	1f 41 06 00 	mov	6(r1),	r15	;
    bf04:	0f 5f       	rla	r15		;
    bf06:	81 49 08 00 	mov	r9,	8(r1)	;
    bf0a:	81 4d 04 00 	mov	r13,	4(r1)	;
    bf0e:	0a 5f       	add	r15,	r10	;
    bf10:	81 4a 06 00 	mov	r10,	6(r1)	;
    bf14:	38 53       	add	#-1,	r8	;r3 As==11
    bf16:	0d 4c       	mov	r12,	r13	;
    bf18:	a2 3f       	jmp	$-186    	;abs 0xbe5e

0000bf1a <.L69>:
    bf1a:	47 43       	clr.b	r7		;

0000bf1c <.LVL76>:
    bf1c:	05 47       	mov	r7,	r5	;
    bf1e:	81 47 0e 00 	mov	r7,	14(r1)	; 0x000e
    bf22:	d6 3e       	jmp	$-594    	;abs 0xbcd0

0000bf24 <.L41>:
    bf24:	17 b3       	bit	#1,	r7	;r3 As==01
    bf26:	13 24       	jz	$+40     	;abs 0xbf4e

0000bf28 <.Loc.883.1>:
    bf28:	81 49 00 00 	mov	r9,	0(r1)	;
    bf2c:	1c 41 08 00 	mov	8(r1),	r12	;
    bf30:	0d 4b       	mov	r11,	r13	;
    bf32:	1e 41 04 00 	mov	4(r1),	r14	;
    bf36:	1f 41 06 00 	mov	6(r1),	r15	;
    bf3a:	88 12       	call	r8		;

0000bf3c <.LVL78>:
    bf3c:	81 4c 08 00 	mov	r12,	8(r1)	;
    bf40:	0b 4d       	mov	r13,	r11	;
    bf42:	81 4e 04 00 	mov	r14,	4(r1)	;
    bf46:	3f d0 00 80 	bis	#32768,	r15	;#0x8000

0000bf4a <.LVL79>:
    bf4a:	81 4f 06 00 	mov	r15,	6(r1)	;

0000bf4e <.L39>:
    bf4e:	81 49 00 00 	mov	r9,	0(r1)	;
    bf52:	0c 47       	mov	r7,	r12	;
    bf54:	0d 44       	mov	r4,	r13	;
    bf56:	0e 46       	mov	r6,	r14	;
    bf58:	0f 45       	mov	r5,	r15	;
    bf5a:	81 4b 02 00 	mov	r11,	2(r1)	;
    bf5e:	88 12       	call	r8		;

0000bf60 <.LVL81>:
    bf60:	07 4c       	mov	r12,	r7	;

0000bf62 <.LVL82>:
    bf62:	04 4d       	mov	r13,	r4	;
    bf64:	06 4e       	mov	r14,	r6	;
    bf66:	05 4f       	mov	r15,	r5	;

0000bf68 <.LVL83>:
    bf68:	1a 53       	inc	r10		;
    bf6a:	0c 49       	mov	r9,	r12	;
    bf6c:	1b 41 02 00 	mov	2(r1),	r11	;

0000bf70 <.LVL84>:
    bf70:	69 3f       	jmp	$-300    	;abs 0xbe44

0000bf72 <.L73>:
    bf72:	0d 93       	cmp	#0,	r13	;r3 As==00
    bf74:	02 24       	jz	$+6      	;abs 0xbf7a
    bf76:	81 48 50 00 	mov	r8,	80(r1)	; 0x0050

0000bf7a <.L59>:
    bf7a:	0e 47       	mov	r7,	r14	;
    bf7c:	7e f0 ff 00 	and.b	#255,	r14	;#0x00ff
    bf80:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    bf84:	26 20       	jnz	$+78     	;abs 0xbfd2

0000bf86 <.Loc.900.1>:
    bf86:	0c 47       	mov	r7,	r12	;
    bf88:	3c f0 00 01 	and	#256,	r12	;#0x0100
    bf8c:	0c 93       	cmp	#0,	r12	;r3 As==00
    bf8e:	21 20       	jnz	$+68     	;abs 0xbfd2

0000bf90 <.Loc.909.1>:
    bf90:	1b d1 08 00 	bis	8(r1),	r11	;

0000bf94 <.LVL85>:
    bf94:	1b d1 04 00 	bis	4(r1),	r11	;
    bf98:	1b d1 06 00 	bis	6(r1),	r11	;
    bf9c:	0b 93       	cmp	#0,	r11	;r3 As==00
    bf9e:	19 24       	jz	$+52     	;abs 0xbfd2

0000bfa0 <.Loc.915.1>:
    bfa0:	0e 57       	add	r7,	r14	;
    bfa2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    bfa4:	0e 97       	cmp	r7,	r14	;
    bfa6:	01 28       	jnc	$+4      	;abs 0xbfaa
    bfa8:	0d 4c       	mov	r12,	r13	;

0000bfaa <.L62>:
    bfaa:	4c 43       	clr.b	r12		;
    bfac:	0d 54       	add	r4,	r13	;
    bfae:	5f 43       	mov.b	#1,	r15	;r3 As==01
    bfb0:	0d 94       	cmp	r4,	r13	;
    bfb2:	01 28       	jnc	$+4      	;abs 0xbfb6
    bfb4:	0f 4c       	mov	r12,	r15	;

0000bfb6 <.L64>:
    bfb6:	0c df       	bis	r15,	r12	;
    bfb8:	4f 43       	clr.b	r15		;
    bfba:	0c 56       	add	r6,	r12	;
    bfbc:	5a 43       	mov.b	#1,	r10	;r3 As==01
    bfbe:	0c 96       	cmp	r6,	r12	;
    bfc0:	01 28       	jnc	$+4      	;abs 0xbfc4
    bfc2:	0a 4f       	mov	r15,	r10	;

0000bfc4 <.L66>:
    bfc4:	0f da       	bis	r10,	r15	;

0000bfc6 <.LVL86>:
    bfc6:	07 4e       	mov	r14,	r7	;
    bfc8:	37 f0 00 ff 	and	#65280,	r7	;#0xff00
    bfcc:	04 4d       	mov	r13,	r4	;
    bfce:	06 4c       	mov	r12,	r6	;
    bfd0:	05 5f       	add	r15,	r5	;

0000bfd2 <.L60>:
    bfd2:	81 47 52 00 	mov	r7,	82(r1)	; 0x0052
    bfd6:	81 44 54 00 	mov	r4,	84(r1)	; 0x0054
    bfda:	81 46 56 00 	mov	r6,	86(r1)	; 0x0056
    bfde:	81 45 58 00 	mov	r5,	88(r1)	; 0x0058

0000bfe2 <.Loc.922.1>:
    bfe2:	b1 40 03 00 	mov	#3,	76(r1)	; 0x004c
    bfe6:	4c 00 

0000bfe8 <.Loc.923.1>:
    bfe8:	0c 41       	mov	r1,	r12	;
    bfea:	3c 50 4c 00 	add	#76,	r12	;#0x004c
    bfee:	30 40 26 bb 	br	#0xbb26		;

0000bff2 <__gedf2>:
    bff2:	0a 15       	pushm	#1,	r10	;16-bit words

0000bff4 <.LCFI0>:
    bff4:	31 80 2c 00 	sub	#44,	r1	;#0x002c

0000bff8 <.LCFI1>:
    bff8:	81 4c 00 00 	mov	r12,	0(r1)	;
    bffc:	81 4d 02 00 	Address 0x000000000000bffe is out of bounds.
mov	r13,	-1(r1)	; 0xffff

0000bffe <L0>:
    bffe:	02 00       	mova	@r0,	r2	;
    c000:	81 4e 04 00 	mov	r14,	4(r1)	;
    c004:	81 4f 06 00 	mov	r15,	6(r1)	;

0000c008 <.Loc.1243.1>:
    c008:	91 41 30 00 	mov	48(r1),	8(r1)	;0x00030
    c00c:	08 00 
    c00e:	91 41 32 00 	mov	50(r1),	10(r1)	;0x00032, 0x000a
    c012:	0a 00 
    c014:	91 41 34 00 	mov	52(r1),	12(r1)	;0x00034, 0x000c
    c018:	0c 00 
    c01a:	91 41 36 00 	mov	54(r1),	14(r1)	;0x00036, 0x000e
    c01e:	0e 00 

0000c020 <.Loc.1245.1>:
    c020:	3a 40 68 ca 	mov	#51816,	r10	;#0xca68
    c024:	0d 41       	mov	r1,	r13	;
    c026:	3d 50 10 00 	add	#16,	r13	;#0x0010
    c02a:	0c 41       	mov	r1,	r12	;

0000c02c <.LVL1>:
    c02c:	8a 12       	call	r10		;

0000c02e <.LVL2>:
    c02e:	0d 41       	mov	r1,	r13	;
    c030:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    c034:	0c 41       	mov	r1,	r12	;
    c036:	3c 52       	add	#8,	r12	;r2 As==11
    c038:	8a 12       	call	r10		;

0000c03a <.LVL3>:
    c03a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c03c:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    c040:	0f 2c       	jc	$+32     	;abs 0xc060

0000c042 <.Loc.1248.1>:
    c042:	1c 91 1e 00 	cmp	30(r1),	r12	;0x0001e
    c046:	0c 2c       	jc	$+26     	;abs 0xc060

0000c048 <.Loc.1250.1>:
    c048:	0d 41       	mov	r1,	r13	;
    c04a:	3d 50 1e 00 	add	#30,	r13	;#0x001e
    c04e:	0c 41       	mov	r1,	r12	;
    c050:	3c 50 10 00 	add	#16,	r12	;#0x0010
    c054:	b0 12 ce cb 	call	#52174		;#0xcbce

0000c058 <.L1>:
    c058:	31 50 2c 00 	add	#44,	r1	;#0x002c
    c05c:	0a 17       	popm	#1,	r10	;16-bit words
    c05e:	30 41       	ret			

0000c060 <.L4>:
    c060:	3c 43       	mov	#-1,	r12	;r3 As==11
    c062:	fa 3f       	jmp	$-10     	;abs 0xc058

0000c064 <__mspabi_fixdli>:
    c064:	0a 15       	pushm	#1,	r10	;16-bit words

0000c066 <L0>:
    c066:	31 80 18 00 	sub	#24,	r1	;#0x0018

0000c06a <.LCFI1>:
    c06a:	81 4c 02 00 	mov	r12,	2(r1)	;
    c06e:	81 4d 04 00 	mov	r13,	4(r1)	;
    c072:	81 4e 06 00 	mov	r14,	6(r1)	;
    c076:	81 4f 08 00 	mov	r15,	8(r1)	;

0000c07a <.Loc.1401.1>:
    c07a:	0d 41       	mov	r1,	r13	;
    c07c:	3d 50 0a 00 	add	#10,	r13	;#0x000a
    c080:	0c 41       	mov	r1,	r12	;

0000c082 <.LVL1>:
    c082:	2c 53       	incd	r12		;
    c084:	b0 12 68 ca 	call	#51816		;#0xca68

0000c088 <.LVL2>:
    c088:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a

0000c08c <.Loc.1405.1>:
    c08c:	6a 43       	mov.b	#2,	r10	;r3 As==10
    c08e:	0a 9c       	cmp	r12,	r10	;
    c090:	33 2c       	jc	$+104    	;abs 0xc0f8

0000c092 <.Loc.1408.1>:
    c092:	2c 92       	cmp	#4,	r12	;r2 As==10
    c094:	0a 20       	jnz	$+22     	;abs 0xc0aa

0000c096 <.L4>:
    c096:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    c09a:	2a 20       	jnz	$+86     	;abs 0xc0f0
    c09c:	3c 43       	mov	#-1,	r12	;r3 As==11
    c09e:	3d 40 ff 7f 	mov	#32767,	r13	;#0x7fff

0000c0a2 <.L1>:
    c0a2:	31 50 18 00 	add	#24,	r1	;#0x0018
    c0a6:	0a 17       	popm	#1,	r10	;16-bit words
    c0a8:	30 41       	ret			

0000c0aa <.L3>:
    c0aa:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    c0ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    c0b0:	23 38       	jl	$+72     	;abs 0xc0f8

0000c0b2 <.Loc.1413.1>:
    c0b2:	7b 40 1e 00 	mov.b	#30,	r11	;#0x001e
    c0b6:	0b 9c       	cmp	r12,	r11	;
    c0b8:	ee 3b       	jl	$-34     	;abs 0xc096

0000c0ba <.Loc.1415.1>:
    c0ba:	7d 40 3c 00 	mov.b	#60,	r13	;#0x003c
    c0be:	0d 8c       	sub	r12,	r13	;
    c0c0:	81 4d 00 00 	mov	r13,	0(r1)	;
    c0c4:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    c0c8:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    c0cc:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    c0d0:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    c0d4:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000c0d8 <.LVL7>:
    c0d8:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    c0dc:	e2 27       	jz	$-58     	;abs 0xc0a2

0000c0de <.Loc.1416.1>:
    c0de:	4e 43       	clr.b	r14		;
    c0e0:	4f 43       	clr.b	r15		;
    c0e2:	0a 4e       	mov	r14,	r10	;
    c0e4:	0b 4f       	mov	r15,	r11	;
    c0e6:	0a 8c       	sub	r12,	r10	;
    c0e8:	0b 7d       	subc	r13,	r11	;
    c0ea:	0c 4a       	mov	r10,	r12	;

0000c0ec <.LVL8>:
    c0ec:	0d 4b       	mov	r11,	r13	;
    c0ee:	d9 3f       	jmp	$-76     	;abs 0xc0a2

0000c0f0 <.L6>:
    c0f0:	4c 43       	clr.b	r12		;
    c0f2:	3d 40 00 80 	mov	#32768,	r13	;#0x8000
    c0f6:	d5 3f       	jmp	$-84     	;abs 0xc0a2

0000c0f8 <.L7>:
    c0f8:	4c 43       	clr.b	r12		;
    c0fa:	4d 43       	clr.b	r13		;
    c0fc:	d2 3f       	jmp	$-90     	;abs 0xc0a2

0000c0fe <__make_dp>:
    c0fe:	31 80 0e 00 	sub	#14,	r1	;#0x000e

0000c102 <.LCFI0>:
    c102:	81 4c 00 00 	Address 0x000000000000c104 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000c104 <L0>:
	...

0000c106 <.Loc.1537.1>:
    c106:	81 4d 02 00 	mov	r13,	2(r1)	;

0000c10a <.Loc.1538.1>:
    c10a:	81 4e 04 00 	mov	r14,	4(r1)	;

0000c10e <.Loc.1539.1>:
    c10e:	91 41 10 00 	mov	16(r1),	6(r1)	;0x00010
    c112:	06 00 
    c114:	91 41 12 00 	mov	18(r1),	8(r1)	;0x00012
    c118:	08 00 
    c11a:	91 41 14 00 	mov	20(r1),	10(r1)	;0x00014, 0x000a
    c11e:	0a 00 
    c120:	91 41 16 00 	mov	22(r1),	12(r1)	;0x00016, 0x000c
    c124:	0c 00 

0000c126 <.Loc.1540.1>:
    c126:	0c 41       	mov	r1,	r12	;

0000c128 <.LVL1>:
    c128:	b0 12 80 c7 	call	#51072		;#0xc780

0000c12c <.LVL2>:
    c12c:	31 50 0e 00 	add	#14,	r1	;#0x000e
    c130:	30 41       	ret			

0000c132 <udivmodhi4>:
    c132:	7f 40 11 00 	mov.b	#17,	r15	;#0x0011

0000c136 <.Loc.35.1>:
    c136:	5b 43       	mov.b	#1,	r11	;r3 As==01

0000c138 <.L2>:
    c138:	0d 9c       	cmp	r12,	r13	;
    c13a:	08 28       	jnc	$+18     	;abs 0xc14c

0000c13c <.L15>:
    c13c:	4f 43       	clr.b	r15		;

0000c13e <.L4>:
    c13e:	0b 93       	cmp	#0,	r11	;r3 As==00
    c140:	0d 20       	jnz	$+28     	;abs 0xc15c

0000c142 <.L5>:
    c142:	0e 93       	cmp	#0,	r14	;r3 As==00
    c144:	01 24       	jz	$+4      	;abs 0xc148
    c146:	0f 4c       	mov	r12,	r15	;

0000c148 <.L1>:
    c148:	0c 4f       	mov	r15,	r12	;
    c14a:	30 41       	ret			

0000c14c <.L3>:
    c14c:	3f 53       	add	#-1,	r15	;r3 As==11

0000c14e <.Loc.38.1>:
    c14e:	0f 93       	cmp	#0,	r15	;r3 As==00
    c150:	f8 27       	jz	$-14     	;abs 0xc142

0000c152 <.Loc.38.1>:
    c152:	0d 93       	cmp	#0,	r13	;r3 As==00
    c154:	f3 3b       	jl	$-24     	;abs 0xc13c

0000c156 <.Loc.40.1>:
    c156:	0d 5d       	rla	r13		;

0000c158 <.Loc.41.1>:
    c158:	0b 5b       	rla	r11		;
    c15a:	ee 3f       	jmp	$-34     	;abs 0xc138

0000c15c <.L9>:
    c15c:	0c 9d       	cmp	r13,	r12	;
    c15e:	02 28       	jnc	$+6      	;abs 0xc164

0000c160 <.Loc.47.1>:
    c160:	0c 8d       	sub	r13,	r12	;

0000c162 <.Loc.48.1>:
    c162:	0f db       	bis	r11,	r15	;

0000c164 <.L8>:
    c164:	12 c3       	clrc			
    c166:	0b 10       	rrc	r11		;

0000c168 <.Loc.51.1>:
    c168:	12 c3       	clrc			
    c16a:	0d 10       	rrc	r13		;
    c16c:	e8 3f       	jmp	$-46     	;abs 0xc13e

0000c16e <__mspabi_divu>:
    c16e:	4e 43       	clr.b	r14		;
    c170:	b0 12 32 c1 	Address 0x000000000000c172 is out of bounds.
call	#65535		;#0xffff

0000c172 <L0>:
    c172:	32 c1       	bic	@r1+,	r2	;

0000c174 <.LVL39>:
    c174:	30 41       	ret			

0000c176 <__mspabi_remu>:
    c176:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c178:	b0 12 32 c1 	call	#49458		;#0xc132

0000c17c <.LVL41>:
    c17c:	30 41       	ret			

0000c17e <udivmodsi4>:
    c17e:	5a 15       	pushm	#6,	r10	;16-bit words

0000c180 <.LCFI0>:
    c180:	0a 4c       	mov	r12,	r10	;
    c182:	0b 4d       	mov	r13,	r11	;

0000c184 <.LVL1>:
    c184:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000c188 <.Loc.35.1>:
    c188:	58 43       	mov.b	#1,	r8	;r3 As==01
    c18a:	49 43       	clr.b	r9		;

0000c18c <.Loc.38.1>:
    c18c:	07 4b       	mov	r11,	r7	;

0000c18e <.L2>:
    c18e:	0f 9b       	cmp	r11,	r15	;
    c190:	11 28       	jnc	$+36     	;abs 0xc1b4
    c192:	07 9f       	cmp	r15,	r7	;
    c194:	02 20       	jnz	$+6      	;abs 0xc19a
    c196:	0e 9a       	cmp	r10,	r14	;
    c198:	0d 28       	jnc	$+28     	;abs 0xc1b4

0000c19a <.L20>:
    c19a:	4c 43       	clr.b	r12		;

0000c19c <.LVL3>:
    c19c:	0d 4c       	mov	r12,	r13	;

0000c19e <.L5>:
    c19e:	07 48       	mov	r8,	r7	;
    c1a0:	07 d9       	bis	r9,	r7	;
    c1a2:	07 93       	cmp	#0,	r7	;r3 As==00
    c1a4:	19 20       	jnz	$+52     	;abs 0xc1d8

0000c1a6 <.L6>:
    c1a6:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    c1aa:	02 24       	jz	$+6      	;abs 0xc1b0
    c1ac:	0c 4a       	mov	r10,	r12	;
    c1ae:	0d 4b       	mov	r11,	r13	;

0000c1b0 <.L1>:
    c1b0:	55 17       	popm	#6,	r10	;16-bit words
    c1b2:	30 41       	ret			

0000c1b4 <.L3>:
    c1b4:	3d 53       	add	#-1,	r13	;r3 As==11

0000c1b6 <.Loc.38.1>:
    c1b6:	0d 93       	cmp	#0,	r13	;r3 As==00
    c1b8:	20 24       	jz	$+66     	;abs 0xc1fa

0000c1ba <.Loc.38.1>:
    c1ba:	0f 93       	cmp	#0,	r15	;r3 As==00
    c1bc:	ee 3b       	jl	$-34     	;abs 0xc19a

0000c1be <.Loc.40.1>:
    c1be:	05 4e       	mov	r14,	r5	;
    c1c0:	06 4f       	mov	r15,	r6	;
    c1c2:	05 5e       	add	r14,	r5	;
    c1c4:	06 6f       	addc	r15,	r6	;
    c1c6:	0e 45       	mov	r5,	r14	;

0000c1c8 <.LVL7>:
    c1c8:	0f 46       	mov	r6,	r15	;

0000c1ca <.LVL8>:
    c1ca:	05 48       	mov	r8,	r5	;
    c1cc:	06 49       	mov	r9,	r6	;
    c1ce:	05 58       	add	r8,	r5	;
    c1d0:	06 69       	addc	r9,	r6	;
    c1d2:	08 45       	mov	r5,	r8	;

0000c1d4 <.LVL9>:
    c1d4:	09 46       	mov	r6,	r9	;

0000c1d6 <.LVL10>:
    c1d6:	db 3f       	jmp	$-72     	;abs 0xc18e

0000c1d8 <.L12>:
    c1d8:	0b 9f       	cmp	r15,	r11	;
    c1da:	08 28       	jnc	$+18     	;abs 0xc1ec
    c1dc:	0f 9b       	cmp	r11,	r15	;
    c1de:	02 20       	jnz	$+6      	;abs 0xc1e4
    c1e0:	0a 9e       	cmp	r14,	r10	;
    c1e2:	04 28       	jnc	$+10     	;abs 0xc1ec

0000c1e4 <.L16>:
    c1e4:	0a 8e       	sub	r14,	r10	;
    c1e6:	0b 7f       	subc	r15,	r11	;

0000c1e8 <.Loc.48.1>:
    c1e8:	0c d8       	bis	r8,	r12	;

0000c1ea <.LVL13>:
    c1ea:	0d d9       	bis	r9,	r13	;

0000c1ec <.L10>:
    c1ec:	12 c3       	clrc			
    c1ee:	09 10       	rrc	r9		;
    c1f0:	08 10       	rrc	r8		;

0000c1f2 <.Loc.51.1>:
    c1f2:	12 c3       	clrc			
    c1f4:	0f 10       	rrc	r15		;
    c1f6:	0e 10       	rrc	r14		;
    c1f8:	d2 3f       	jmp	$-90     	;abs 0xc19e

0000c1fa <.L14>:
    c1fa:	0c 4d       	mov	r13,	r12	;

0000c1fc <.LVL18>:
    c1fc:	d4 3f       	jmp	$-86     	;abs 0xc1a6

0000c1fe <__mspabi_divlu>:
    c1fe:	21 83       	decd	r1		;

0000c200 <.LCFI5>:
    c200:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000c204 <L0>:
    c204:	b0 12 7e c1 	call	#49534		;#0xc17e

0000c208 <.LVL46>:
    c208:	21 53       	incd	r1		;
    c20a:	30 41       	ret			

0000c20c <__mspabi_remul>:
    c20c:	21 83       	decd	r1		;

0000c20e <.LCFI6>:
    c20e:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    c212:	b0 12 7e c1 	call	#49534		;#0xc17e

0000c216 <.LVL48>:
    c216:	21 53       	incd	r1		;
    c218:	30 41       	ret			

0000c21a <__mspabi_slli_15>:
    c21a:	0c 5c       	rla	r12		;

0000c21c <__mspabi_slli_14>:
    c21c:	0c 5c       	rla	r12		;

0000c21e <__mspabi_slli_13>:
    c21e:	0c 5c       	rla	r12		;

0000c220 <__mspabi_slli_12>:
    c220:	0c 5c       	rla	r12		;

0000c222 <__mspabi_slli_11>:
    c222:	0c 5c       	rla	r12		;

0000c224 <__mspabi_slli_10>:
    c224:	0c 5c       	rla	r12		;

0000c226 <__mspabi_slli_9>:
    c226:	0c 5c       	rla	r12		;

0000c228 <__mspabi_slli_8>:
    c228:	0c 5c       	rla	r12		;

0000c22a <__mspabi_slli_7>:
    c22a:	0c 5c       	rla	r12		;

0000c22c <__mspabi_slli_6>:
    c22c:	0c 5c       	rla	r12		;

0000c22e <__mspabi_slli_5>:
    c22e:	0c 5c       	rla	r12		;

0000c230 <__mspabi_slli_4>:
    c230:	0c 5c       	rla	r12		;

0000c232 <__mspabi_slli_3>:
    c232:	0c 5c       	rla	r12		;

0000c234 <__mspabi_slli_2>:
    c234:	0c 5c       	rla	r12		;

0000c236 <__mspabi_slli_1>:
    c236:	0c 5c       	rla	r12		;
    c238:	30 41       	ret			

0000c23a <.L11>:
    c23a:	3d 53       	add	#-1,	r13	;r3 As==11
    c23c:	0c 5c       	rla	r12		;

0000c23e <__mspabi_slli>:
    c23e:	0d 93       	cmp	#0,	r13	;r3 As==00
    c240:	fc 23       	jnz	$-6      	;abs 0xc23a
    c242:	30 41       	ret			

0000c244 <__mspabi_slll_15>:
    c244:	0c 5c       	rla	r12		;
    c246:	0d 6d       	rlc	r13		;

0000c248 <__mspabi_slll_14>:
    c248:	0c 5c       	rla	r12		;
    c24a:	0d 6d       	rlc	r13		;

0000c24c <__mspabi_slll_13>:
    c24c:	0c 5c       	rla	r12		;
    c24e:	0d 6d       	rlc	r13		;

0000c250 <__mspabi_slll_12>:
    c250:	0c 5c       	rla	r12		;
    c252:	0d 6d       	rlc	r13		;

0000c254 <__mspabi_slll_11>:
    c254:	0c 5c       	rla	r12		;
    c256:	0d 6d       	rlc	r13		;

0000c258 <__mspabi_slll_10>:
    c258:	0c 5c       	rla	r12		;
    c25a:	0d 6d       	rlc	r13		;

0000c25c <__mspabi_slll_9>:
    c25c:	0c 5c       	rla	r12		;
    c25e:	0d 6d       	rlc	r13		;

0000c260 <__mspabi_slll_8>:
    c260:	0c 5c       	rla	r12		;
    c262:	0d 6d       	rlc	r13		;

0000c264 <__mspabi_slll_7>:
    c264:	0c 5c       	rla	r12		;
    c266:	0d 6d       	rlc	r13		;

0000c268 <__mspabi_slll_6>:
    c268:	0c 5c       	rla	r12		;
    c26a:	0d 6d       	rlc	r13		;

0000c26c <__mspabi_slll_5>:
    c26c:	0c 5c       	rla	r12		;
    c26e:	0d 6d       	rlc	r13		;

0000c270 <__mspabi_slll_4>:
    c270:	0c 5c       	rla	r12		;
    c272:	0d 6d       	rlc	r13		;

0000c274 <__mspabi_slll_3>:
    c274:	0c 5c       	rla	r12		;
    c276:	0d 6d       	rlc	r13		;

0000c278 <__mspabi_slll_2>:
    c278:	0c 5c       	rla	r12		;
    c27a:	0d 6d       	rlc	r13		;

0000c27c <__mspabi_slll_1>:
    c27c:	0c 5c       	rla	r12		;
    c27e:	0d 6d       	rlc	r13		;
    c280:	30 41       	ret			

0000c282 <.L12>:
    c282:	3e 53       	add	#-1,	r14	;r3 As==11
    c284:	0c 5c       	rla	r12		;
    c286:	0d 6d       	rlc	r13		;

0000c288 <__mspabi_slll>:
    c288:	0e 93       	cmp	#0,	r14	;r3 As==00
    c28a:	fb 23       	jnz	$-8      	;abs 0xc282
    c28c:	30 41       	ret			

0000c28e <__mspabi_srai_15>:
    c28e:	0c 11       	rra	r12		;

0000c290 <__mspabi_srai_14>:
    c290:	0c 11       	rra	r12		;

0000c292 <__mspabi_srai_13>:
    c292:	0c 11       	rra	r12		;

0000c294 <__mspabi_srai_12>:
    c294:	0c 11       	rra	r12		;

0000c296 <__mspabi_srai_11>:
    c296:	0c 11       	rra	r12		;

0000c298 <__mspabi_srai_10>:
    c298:	0c 11       	rra	r12		;

0000c29a <__mspabi_srai_9>:
    c29a:	0c 11       	rra	r12		;

0000c29c <__mspabi_srai_8>:
    c29c:	0c 11       	rra	r12		;

0000c29e <__mspabi_srai_7>:
    c29e:	0c 11       	rra	r12		;

0000c2a0 <__mspabi_srai_6>:
    c2a0:	0c 11       	rra	r12		;

0000c2a2 <__mspabi_srai_5>:
    c2a2:	0c 11       	rra	r12		;

0000c2a4 <__mspabi_srai_4>:
    c2a4:	0c 11       	rra	r12		;

0000c2a6 <__mspabi_srai_3>:
    c2a6:	0c 11       	rra	r12		;

0000c2a8 <__mspabi_srai_2>:
    c2a8:	0c 11       	rra	r12		;

0000c2aa <__mspabi_srai_1>:
    c2aa:	0c 11       	rra	r12		;
    c2ac:	30 41       	ret			

0000c2ae <.L11>:
    c2ae:	3d 53       	add	#-1,	r13	;r3 As==11
    c2b0:	0c 11       	rra	r12		;

0000c2b2 <__mspabi_srai>:
    c2b2:	0d 93       	cmp	#0,	r13	;r3 As==00
    c2b4:	fc 23       	jnz	$-6      	;abs 0xc2ae
    c2b6:	30 41       	ret			

0000c2b8 <__mspabi_sral_15>:
    c2b8:	0d 11       	rra	r13		;
    c2ba:	0c 10       	rrc	r12		;

0000c2bc <__mspabi_sral_14>:
    c2bc:	0d 11       	rra	r13		;
    c2be:	0c 10       	rrc	r12		;

0000c2c0 <__mspabi_sral_13>:
    c2c0:	0d 11       	rra	r13		;
    c2c2:	0c 10       	rrc	r12		;

0000c2c4 <__mspabi_sral_12>:
    c2c4:	0d 11       	rra	r13		;
    c2c6:	0c 10       	rrc	r12		;

0000c2c8 <__mspabi_sral_11>:
    c2c8:	0d 11       	rra	r13		;
    c2ca:	0c 10       	rrc	r12		;

0000c2cc <__mspabi_sral_10>:
    c2cc:	0d 11       	rra	r13		;
    c2ce:	0c 10       	rrc	r12		;

0000c2d0 <__mspabi_sral_9>:
    c2d0:	0d 11       	rra	r13		;
    c2d2:	0c 10       	rrc	r12		;

0000c2d4 <__mspabi_sral_8>:
    c2d4:	0d 11       	rra	r13		;
    c2d6:	0c 10       	rrc	r12		;

0000c2d8 <__mspabi_sral_7>:
    c2d8:	0d 11       	rra	r13		;
    c2da:	0c 10       	rrc	r12		;

0000c2dc <__mspabi_sral_6>:
    c2dc:	0d 11       	rra	r13		;
    c2de:	0c 10       	rrc	r12		;

0000c2e0 <__mspabi_sral_5>:
    c2e0:	0d 11       	rra	r13		;
    c2e2:	0c 10       	rrc	r12		;

0000c2e4 <__mspabi_sral_4>:
    c2e4:	0d 11       	rra	r13		;
    c2e6:	0c 10       	rrc	r12		;

0000c2e8 <__mspabi_sral_3>:
    c2e8:	0d 11       	rra	r13		;
    c2ea:	0c 10       	rrc	r12		;

0000c2ec <__mspabi_sral_2>:
    c2ec:	0d 11       	rra	r13		;
    c2ee:	0c 10       	rrc	r12		;

0000c2f0 <__mspabi_sral_1>:
    c2f0:	0d 11       	rra	r13		;
    c2f2:	0c 10       	rrc	r12		;
    c2f4:	30 41       	ret			

0000c2f6 <.L12>:
    c2f6:	3e 53       	add	#-1,	r14	;r3 As==11
    c2f8:	0d 11       	rra	r13		;
    c2fa:	0c 10       	rrc	r12		;

0000c2fc <__mspabi_sral>:
    c2fc:	0e 93       	cmp	#0,	r14	;r3 As==00
    c2fe:	fb 23       	jnz	$-8      	;abs 0xc2f6
    c300:	30 41       	ret			

0000c302 <__mspabi_srli_15>:
    c302:	12 c3       	clrc			
    c304:	0c 10       	rrc	r12		;

0000c306 <__mspabi_srli_14>:
    c306:	12 c3       	clrc			
    c308:	0c 10       	rrc	r12		;

0000c30a <__mspabi_srli_13>:
    c30a:	12 c3       	clrc			
    c30c:	0c 10       	rrc	r12		;

0000c30e <__mspabi_srli_12>:
    c30e:	12 c3       	clrc			
    c310:	0c 10       	rrc	r12		;

0000c312 <__mspabi_srli_11>:
    c312:	12 c3       	clrc			
    c314:	0c 10       	rrc	r12		;

0000c316 <__mspabi_srli_10>:
    c316:	12 c3       	clrc			
    c318:	0c 10       	rrc	r12		;

0000c31a <__mspabi_srli_9>:
    c31a:	12 c3       	clrc			
    c31c:	0c 10       	rrc	r12		;

0000c31e <__mspabi_srli_8>:
    c31e:	12 c3       	clrc			
    c320:	0c 10       	rrc	r12		;

0000c322 <__mspabi_srli_7>:
    c322:	12 c3       	clrc			
    c324:	0c 10       	rrc	r12		;

0000c326 <__mspabi_srli_6>:
    c326:	12 c3       	clrc			
    c328:	0c 10       	rrc	r12		;

0000c32a <__mspabi_srli_5>:
    c32a:	12 c3       	clrc			
    c32c:	0c 10       	rrc	r12		;

0000c32e <__mspabi_srli_4>:
    c32e:	12 c3       	clrc			
    c330:	0c 10       	rrc	r12		;

0000c332 <__mspabi_srli_3>:
    c332:	12 c3       	clrc			
    c334:	0c 10       	rrc	r12		;

0000c336 <__mspabi_srli_2>:
    c336:	12 c3       	clrc			
    c338:	0c 10       	rrc	r12		;

0000c33a <__mspabi_srli_1>:
    c33a:	12 c3       	clrc			
    c33c:	0c 10       	rrc	r12		;
    c33e:	30 41       	ret			

0000c340 <.L11>:
    c340:	3d 53       	add	#-1,	r13	;r3 As==11
    c342:	12 c3       	clrc			
    c344:	0c 10       	rrc	r12		;

0000c346 <__mspabi_srli>:
    c346:	0d 93       	cmp	#0,	r13	;r3 As==00
    c348:	fb 23       	jnz	$-8      	;abs 0xc340
    c34a:	30 41       	ret			

0000c34c <__mspabi_srll_15>:
    c34c:	12 c3       	clrc			
    c34e:	0d 10       	rrc	r13		;
    c350:	0c 10       	rrc	r12		;

0000c352 <__mspabi_srll_14>:
    c352:	12 c3       	clrc			
    c354:	0d 10       	rrc	r13		;
    c356:	0c 10       	rrc	r12		;

0000c358 <__mspabi_srll_13>:
    c358:	12 c3       	clrc			
    c35a:	0d 10       	rrc	r13		;
    c35c:	0c 10       	rrc	r12		;

0000c35e <__mspabi_srll_12>:
    c35e:	12 c3       	clrc			
    c360:	0d 10       	rrc	r13		;
    c362:	0c 10       	rrc	r12		;

0000c364 <__mspabi_srll_11>:
    c364:	12 c3       	clrc			
    c366:	0d 10       	rrc	r13		;
    c368:	0c 10       	rrc	r12		;

0000c36a <__mspabi_srll_10>:
    c36a:	12 c3       	clrc			
    c36c:	0d 10       	rrc	r13		;
    c36e:	0c 10       	rrc	r12		;

0000c370 <__mspabi_srll_9>:
    c370:	12 c3       	clrc			
    c372:	0d 10       	rrc	r13		;
    c374:	0c 10       	rrc	r12		;

0000c376 <__mspabi_srll_8>:
    c376:	12 c3       	clrc			
    c378:	0d 10       	rrc	r13		;
    c37a:	0c 10       	rrc	r12		;

0000c37c <__mspabi_srll_7>:
    c37c:	12 c3       	clrc			
    c37e:	0d 10       	rrc	r13		;
    c380:	0c 10       	rrc	r12		;

0000c382 <__mspabi_srll_6>:
    c382:	12 c3       	clrc			
    c384:	0d 10       	rrc	r13		;
    c386:	0c 10       	rrc	r12		;

0000c388 <__mspabi_srll_5>:
    c388:	12 c3       	clrc			
    c38a:	0d 10       	rrc	r13		;
    c38c:	0c 10       	rrc	r12		;

0000c38e <__mspabi_srll_4>:
    c38e:	12 c3       	clrc			
    c390:	0d 10       	rrc	r13		;
    c392:	0c 10       	rrc	r12		;

0000c394 <__mspabi_srll_3>:
    c394:	12 c3       	clrc			
    c396:	0d 10       	rrc	r13		;
    c398:	0c 10       	rrc	r12		;

0000c39a <__mspabi_srll_2>:
    c39a:	12 c3       	clrc			
    c39c:	0d 10       	rrc	r13		;
    c39e:	0c 10       	rrc	r12		;

0000c3a0 <__mspabi_srll_1>:
    c3a0:	12 c3       	clrc			
    c3a2:	0d 10       	rrc	r13		;
    c3a4:	0c 10       	rrc	r12		;
    c3a6:	30 41       	ret			

0000c3a8 <.L12>:
    c3a8:	3e 53       	add	#-1,	r14	;r3 As==11
    c3aa:	12 c3       	clrc			
    c3ac:	0d 10       	rrc	r13		;
    c3ae:	0c 10       	rrc	r12		;

0000c3b0 <__mspabi_srll>:
    c3b0:	0e 93       	cmp	#0,	r14	;r3 As==00
    c3b2:	fa 23       	jnz	$-10     	;abs 0xc3a8
    c3b4:	30 41       	ret			

0000c3b6 <__lshrdi3>:
    c3b6:	6a 15       	pushm	#7,	r10	;16-bit words

0000c3b8 <.LCFI0>:
    c3b8:	21 82       	sub	#4,	r1	;r2 As==10

0000c3ba <.LCFI1>:
    c3ba:	09 4c       	mov	r12,	r9	;
    c3bc:	0a 4d       	mov	r13,	r10	;
    c3be:	16 41 14 00 	mov	20(r1),	r6	;0x00014

0000c3c2 <.Loc.405.1>:
    c3c2:	06 93       	cmp	#0,	r6	;r3 As==00
    c3c4:	16 24       	jz	$+46     	;abs 0xc3f2

0000c3c6 <.Loc.409.1>:
    c3c6:	35 40 20 00 	mov	#32,	r5	;#0x0020
    c3ca:	05 86       	sub	r6,	r5	;

0000c3cc <.LVL1>:
    c3cc:	4c 43       	clr.b	r12		;

0000c3ce <.LVL2>:
    c3ce:	0c 95       	cmp	r5,	r12	;
    c3d0:	15 38       	jl	$+44     	;abs 0xc3fc

0000c3d2 <.Loc.414.1>:
    c3d2:	08 4c       	mov	r12,	r8	;
    c3d4:	81 4c 02 00 	mov	r12,	2(r1)	;

0000c3d8 <.Loc.415.1>:
    c3d8:	0a 43       	clr	r10		;
    c3da:	0a 85       	sub	r5,	r10	;
    c3dc:	0c 4e       	mov	r14,	r12	;
    c3de:	0d 4f       	mov	r15,	r13	;
    c3e0:	0e 4a       	mov	r10,	r14	;
    c3e2:	0f 43       	clr	r15		;
    c3e4:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    c3e8:	09 4c       	mov	r12,	r9	;

0000c3ea <.L4>:
    c3ea:	0a 4d       	mov	r13,	r10	;
    c3ec:	0e 48       	mov	r8,	r14	;
    c3ee:	1f 41 02 00 	mov	2(r1),	r15	;

0000c3f2 <.L2>:
    c3f2:	0c 49       	mov	r9,	r12	;
    c3f4:	0d 4a       	mov	r10,	r13	;
    c3f6:	21 52       	add	#4,	r1	;r2 As==10
    c3f8:	64 17       	popm	#7,	r10	;16-bit words
    c3fa:	30 41       	ret			

0000c3fc <.L3>:
    c3fc:	0b 4e       	mov	r14,	r11	;
    c3fe:	04 4f       	mov	r15,	r4	;

0000c400 <.Loc.421.1>:
    c400:	07 43       	clr	r7		;

0000c402 <.LVL9>:
    c402:	0c 4e       	mov	r14,	r12	;
    c404:	0d 4f       	mov	r15,	r13	;
    c406:	0e 46       	mov	r6,	r14	;
    c408:	81 4b 00 00 	mov	r11,	0(r1)	;
    c40c:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    c410:	08 4c       	mov	r12,	r8	;
    c412:	81 4d 02 00 	mov	r13,	2(r1)	;

0000c416 <.Loc.422.1>:
    c416:	0c 49       	mov	r9,	r12	;
    c418:	0d 4a       	mov	r10,	r13	;
    c41a:	0e 46       	mov	r6,	r14	;
    c41c:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    c420:	07 4c       	mov	r12,	r7	;
    c422:	0a 4d       	mov	r13,	r10	;

0000c424 <.Loc.419.1>:
    c424:	2b 41       	mov	@r1,	r11	;
    c426:	0c 4b       	mov	r11,	r12	;
    c428:	0d 44       	mov	r4,	r13	;
    c42a:	0e 45       	mov	r5,	r14	;
    c42c:	0f 43       	clr	r15		;
    c42e:	b0 12 88 c2 	call	#49800		;#0xc288

0000c432 <.Loc.422.1>:
    c432:	0d da       	bis	r10,	r13	;
    c434:	09 47       	mov	r7,	r9	;
    c436:	09 dc       	bis	r12,	r9	;
    c438:	d8 3f       	jmp	$-78     	;abs 0xc3ea

0000c43a <__ashldi3>:
    c43a:	6a 15       	pushm	#7,	r10	;16-bit words

0000c43c <L0>:
    c43c:	21 82       	sub	#4,	r1	;r2 As==10

0000c43e <.LCFI1>:
    c43e:	06 4c       	mov	r12,	r6	;
    c440:	07 4d       	mov	r13,	r7	;
    c442:	09 4e       	mov	r14,	r9	;
    c444:	0a 4f       	mov	r15,	r10	;
    c446:	1c 41 14 00 	mov	20(r1),	r12	;0x00014

0000c44a <.LVL1>:
    c44a:	0c 93       	cmp	#0,	r12	;r3 As==00
    c44c:	15 24       	jz	$+44     	;abs 0xc478

0000c44e <.Loc.437.1>:
    c44e:	35 40 20 00 	mov	#32,	r5	;#0x0020
    c452:	05 8c       	sub	r12,	r5	;

0000c454 <.LVL2>:
    c454:	4d 43       	clr.b	r13		;
    c456:	0d 95       	cmp	r5,	r13	;
    c458:	16 38       	jl	$+46     	;abs 0xc486

0000c45a <.Loc.442.1>:
    c45a:	08 4d       	mov	r13,	r8	;
    c45c:	81 4d 02 00 	mov	r13,	2(r1)	;

0000c460 <.Loc.443.1>:
    c460:	0e 43       	clr	r14		;
    c462:	0e 85       	sub	r5,	r14	;
    c464:	0c 46       	mov	r6,	r12	;
    c466:	0d 47       	mov	r7,	r13	;
    c468:	0f 43       	clr	r15		;
    c46a:	b0 12 88 c2 	call	#49800		;#0xc288
    c46e:	09 4c       	mov	r12,	r9	;

0000c470 <.L4>:
    c470:	06 48       	mov	r8,	r6	;
    c472:	17 41 02 00 	mov	2(r1),	r7	;
    c476:	0a 4d       	mov	r13,	r10	;

0000c478 <.L2>:
    c478:	0c 46       	mov	r6,	r12	;
    c47a:	0d 47       	mov	r7,	r13	;
    c47c:	0e 49       	mov	r9,	r14	;
    c47e:	0f 4a       	mov	r10,	r15	;
    c480:	21 52       	add	#4,	r1	;r2 As==10
    c482:	64 17       	popm	#7,	r10	;16-bit words
    c484:	30 41       	ret			

0000c486 <.L3>:
    c486:	0b 46       	mov	r6,	r11	;
    c488:	04 47       	mov	r7,	r4	;

0000c48a <.Loc.449.1>:
    c48a:	06 4c       	mov	r12,	r6	;
    c48c:	07 43       	clr	r7		;
    c48e:	0c 4b       	mov	r11,	r12	;

0000c490 <.LVL9>:
    c490:	0d 44       	mov	r4,	r13	;
    c492:	0e 46       	mov	r6,	r14	;
    c494:	81 4b 00 00 	mov	r11,	0(r1)	;
    c498:	b0 12 88 c2 	call	#49800		;#0xc288
    c49c:	08 4c       	mov	r12,	r8	;
    c49e:	81 4d 02 00 	mov	r13,	2(r1)	;

0000c4a2 <.Loc.450.1>:
    c4a2:	0c 49       	mov	r9,	r12	;
    c4a4:	0d 4a       	mov	r10,	r13	;
    c4a6:	0e 46       	mov	r6,	r14	;
    c4a8:	b0 12 88 c2 	call	#49800		;#0xc288
    c4ac:	07 4c       	mov	r12,	r7	;
    c4ae:	0a 4d       	mov	r13,	r10	;

0000c4b0 <.Loc.447.1>:
    c4b0:	2b 41       	mov	@r1,	r11	;
    c4b2:	0c 4b       	mov	r11,	r12	;
    c4b4:	0d 44       	mov	r4,	r13	;
    c4b6:	0e 45       	mov	r5,	r14	;
    c4b8:	0f 43       	clr	r15		;
    c4ba:	b0 12 b0 c3 	call	#50096		;#0xc3b0

0000c4be <.Loc.450.1>:
    c4be:	0d da       	bis	r10,	r13	;
    c4c0:	09 47       	mov	r7,	r9	;
    c4c2:	09 dc       	bis	r12,	r9	;
    c4c4:	d5 3f       	jmp	$-84     	;abs 0xc470

0000c4c6 <__pack_f>:
    c4c6:	6a 15       	pushm	#7,	r10	;16-bit words

0000c4c8 <L0>:
    c4c8:	18 4c 06 00 	mov	6(r12),	r8	;
    c4cc:	19 4c 08 00 	mov	8(r12),	r9	;

0000c4d0 <.LVL1>:
    c4d0:	17 4c 02 00 	mov	2(r12),	r7	;

0000c4d4 <.LVL2>:
    c4d4:	2d 4c       	mov	@r12,	r13	;

0000c4d6 <.Loc.205.1>:
    c4d6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c4d8:	0e 9d       	cmp	r13,	r14	;
    c4da:	1a 28       	jnc	$+54     	;abs 0xc510

0000c4dc <.LVL4>:
    c4dc:	0c 48       	mov	r8,	r12	;

0000c4de <.LVL5>:
    c4de:	0d 49       	mov	r9,	r13	;
    c4e0:	b0 12 7c c3 	call	#50044		;#0xc37c

0000c4e4 <.LVL6>:
    c4e4:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f

0000c4e8 <.Loc.220.1>:
    c4e8:	08 4c       	mov	r12,	r8	;
    c4ea:	09 4d       	mov	r13,	r9	;
    c4ec:	39 d0 40 00 	bis	#64,	r9	;#0x0040

0000c4f0 <.LVL8>:
    c4f0:	7a 40 ff 00 	mov.b	#255,	r10	;#0x00ff

0000c4f4 <.L3>:
    c4f4:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

0000c4f8 <.LVL10>:
    c4f8:	46 18 0a 5a 	rpt #7 { rlax.w	r10		;
    c4fc:	0d 49       	mov	r9,	r13	;
    c4fe:	7d f0 7f 00 	and.b	#127,	r13	;#0x007f

0000c502 <.Loc.322.1>:
    c502:	4e 18 07 57 	rpt #15 { rlax.w	r7		;

0000c506 <.LVL11>:
    c506:	0d da       	bis	r10,	r13	;

0000c508 <.Loc.424.1>:
    c508:	0c 48       	mov	r8,	r12	;
    c50a:	0d d7       	bis	r7,	r13	;
    c50c:	64 17       	popm	#7,	r10	;16-bit words
    c50e:	30 41       	ret			

0000c510 <.L2>:
    c510:	2d 92       	cmp	#4,	r13	;r2 As==10
    c512:	74 24       	jz	$+234    	;abs 0xc5fc

0000c514 <.Loc.229.1>:
    c514:	2d 93       	cmp	#2,	r13	;r3 As==10
    c516:	6e 24       	jz	$+222    	;abs 0xc5f4

0000c518 <.Loc.234.1>:
    c518:	0a 48       	mov	r8,	r10	;
    c51a:	0a d9       	bis	r9,	r10	;
    c51c:	0a 93       	cmp	#0,	r10	;r3 As==00
    c51e:	ea 27       	jz	$-42     	;abs 0xc4f4

0000c520 <.Loc.240.1>:
    c520:	1a 4c 04 00 	mov	4(r12),	r10	;
    c524:	3a 90 82 ff 	cmp	#65410,	r10	;#0xff82
    c528:	41 34       	jge	$+132    	;abs 0xc5ac

0000c52a <.LBB10>:
    c52a:	34 40 82 ff 	mov	#65410,	r4	;#0xff82
    c52e:	04 8a       	sub	r10,	r4	;

0000c530 <.LVL14>:
    c530:	7c 40 19 00 	mov.b	#25,	r12	;#0x0019

0000c534 <.LVL15>:
    c534:	0c 94       	cmp	r4,	r12	;
    c536:	35 38       	jl	$+108    	;abs 0xc5a2

0000c538 <.LBB11>:
    c538:	05 43       	clr	r5		;
    c53a:	0c 48       	mov	r8,	r12	;
    c53c:	0d 49       	mov	r9,	r13	;
    c53e:	0e 44       	mov	r4,	r14	;
    c540:	b0 12 b0 c3 	call	#50096		;#0xc3b0
    c544:	06 4c       	mov	r12,	r6	;
    c546:	0a 4d       	mov	r13,	r10	;

0000c548 <.Loc.264.1>:
    c548:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c54a:	4d 43       	clr.b	r13		;
    c54c:	0e 44       	mov	r4,	r14	;
    c54e:	b0 12 88 c2 	call	#49800		;#0xc288
    c552:	3c 53       	add	#-1,	r12	;r3 As==11
    c554:	3d 63       	addc	#-1,	r13	;r3 As==11
    c556:	0c f8       	and	r8,	r12	;
    c558:	0d f9       	and	r9,	r13	;
    c55a:	0c dd       	bis	r13,	r12	;
    c55c:	0e 43       	clr	r14		;
    c55e:	0e 8c       	sub	r12,	r14	;
    c560:	0c de       	bis	r14,	r12	;
    c562:	0e 4c       	mov	r12,	r14	;
    c564:	5e 03       	rrum	#1,	r14	;
    c566:	4d 18 0e 11 	rpt #14 { rrax.w	r14		;

0000c56a <.Loc.265.1>:
    c56a:	0c 46       	mov	r6,	r12	;
    c56c:	0c de       	bis	r14,	r12	;
    c56e:	0d 4a       	mov	r10,	r13	;

0000c570 <.LBE11>:
    c570:	0e 4c       	mov	r12,	r14	;
    c572:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    c576:	3e 90 40 00 	cmp	#64,	r14	;#0x0040
    c57a:	15 20       	jnz	$+44     	;abs 0xc5a6

0000c57c <.Loc.269.1>:
    c57c:	0e 4c       	mov	r12,	r14	;
    c57e:	7e f0 80 00 	and.b	#128,	r14	;#0x0080
    c582:	0e 93       	cmp	#0,	r14	;r3 As==00
    c584:	03 24       	jz	$+8      	;abs 0xc58c

0000c586 <.Loc.270.1>:
    c586:	3c 50 40 00 	add	#64,	r12	;#0x0040

0000c58a <.L30>:
    c58a:	0d 63       	adc	r13		;

0000c58c <.L8>:
    c58c:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c58e:	3e 40 ff 3f 	mov	#16383,	r14	;#0x3fff
    c592:	0e 9d       	cmp	r13,	r14	;
    c594:	01 28       	jnc	$+4      	;abs 0xc598
    c596:	4a 43       	clr.b	r10		;

0000c598 <.L10>:
    c598:	b0 12 7c c3 	call	#50044		;#0xc37c

0000c59c <.L33>:
    c59c:	08 4c       	mov	r12,	r8	;
    c59e:	09 4d       	mov	r13,	r9	;

0000c5a0 <.LVL24>:
    c5a0:	a9 3f       	jmp	$-172    	;abs 0xc4f4

0000c5a2 <.L21>:
    c5a2:	4c 43       	clr.b	r12		;
    c5a4:	4d 43       	clr.b	r13		;

0000c5a6 <.L7>:
    c5a6:	3c 50 3f 00 	add	#63,	r12	;#0x003f

0000c5aa <.LVL27>:
    c5aa:	ef 3f       	jmp	$-32     	;abs 0xc58a

0000c5ac <.L5>:
    c5ac:	7c 40 7f 00 	mov.b	#127,	r12	;#0x007f

0000c5b0 <.LVL29>:
    c5b0:	0c 9a       	cmp	r10,	r12	;
    c5b2:	24 38       	jl	$+74     	;abs 0xc5fc

0000c5b4 <.LVL30>:
    c5b4:	0c 48       	mov	r8,	r12	;
    c5b6:	7c f0 7f 00 	and.b	#127,	r12	;#0x007f
    c5ba:	3c 90 40 00 	cmp	#64,	r12	;#0x0040
    c5be:	11 20       	jnz	$+36     	;abs 0xc5e2

0000c5c0 <.Loc.299.1>:
    c5c0:	0c 48       	mov	r8,	r12	;
    c5c2:	7c f0 80 00 	and.b	#128,	r12	;#0x0080
    c5c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    c5c8:	03 24       	jz	$+8      	;abs 0xc5d0

0000c5ca <.Loc.300.1>:
    c5ca:	38 50 40 00 	add	#64,	r8	;#0x0040

0000c5ce <.L31>:
    c5ce:	09 63       	adc	r9		;

0000c5d0 <.L13>:
    c5d0:	09 93       	cmp	#0,	r9	;r3 As==00
    c5d2:	0a 38       	jl	$+22     	;abs 0xc5e8

0000c5d4 <.Loc.293.1>:
    c5d4:	3a 50 7f 00 	add	#127,	r10	;#0x007f

0000c5d8 <.L17>:
    c5d8:	0c 48       	mov	r8,	r12	;
    c5da:	0d 49       	mov	r9,	r13	;
    c5dc:	b0 12 7c c3 	call	#50044		;#0xc37c
    c5e0:	dd 3f       	jmp	$-68     	;abs 0xc59c

0000c5e2 <.L12>:
    c5e2:	38 50 3f 00 	add	#63,	r8	;#0x003f

0000c5e6 <.LVL36>:
    c5e6:	f3 3f       	jmp	$-24     	;abs 0xc5ce

0000c5e8 <.L15>:
    c5e8:	12 c3       	clrc			
    c5ea:	09 10       	rrc	r9		;
    c5ec:	08 10       	rrc	r8		;

0000c5ee <.Loc.310.1>:
    c5ee:	3a 50 80 00 	add	#128,	r10	;#0x0080

0000c5f2 <.LVL39>:
    c5f2:	f2 3f       	jmp	$-26     	;abs 0xc5d8

0000c5f4 <.L19>:
    c5f4:	4a 43       	clr.b	r10		;

0000c5f6 <.L32>:
    c5f6:	48 43       	clr.b	r8		;

0000c5f8 <.LVL42>:
    c5f8:	49 43       	clr.b	r9		;
    c5fa:	7c 3f       	jmp	$-262    	;abs 0xc4f4

0000c5fc <.L22>:
    c5fc:	7a 40 ff 00 	mov.b	#255,	r10	;#0x00ff
    c600:	fa 3f       	jmp	$-10     	;abs 0xc5f6

0000c602 <__unpack_f>:
    c602:	3a 15       	pushm	#4,	r10	;16-bit words

0000c604 <.LCFI0>:
    c604:	21 83       	decd	r1		;

0000c606 <.LCFI1>:
    c606:	07 4c       	mov	r12,	r7	;
    c608:	0a 4d       	mov	r13,	r10	;

0000c60a <.Loc.454.1>:
    c60a:	29 4c       	mov	@r12,	r9	;
    c60c:	58 4c 02 00 	mov.b	2(r12),	r8	;

0000c610 <L0>:
    c610:	0d 48       	mov	r8,	r13	;

0000c612 <.LVL1>:
    c612:	7d f0 7f 00 	and.b	#127,	r13	;#0x007f

0000c616 <.LVL2>:
    c616:	1c 4c 02 00 	mov	2(r12),	r12	;

0000c61a <.LVL3>:
    c61a:	81 4d 00 00 	mov	r13,	0(r1)	;
    c61e:	b0 12 22 c3 	call	#49954		;#0xc322

0000c622 <.LVL4>:
    c622:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000c626 <.LVL5>:
    c626:	5e 47 03 00 	mov.b	3(r7),	r14	;
    c62a:	5e 0f       	rrum	#4,	r14	;
    c62c:	5e 0b       	rrum	#3,	r14	;

0000c62e <.Loc.508.1>:
    c62e:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    c632:	8a 4e 02 00 	mov	r14,	2(r10)	;

0000c636 <.LVL6>:
    c636:	2d 41       	mov	@r1,	r13	;

0000c638 <.LVL7>:
    c638:	0c 93       	cmp	#0,	r12	;r3 As==00
    c63a:	24 20       	jnz	$+74     	;abs 0xc684

0000c63c <.Loc.512.1>:
    c63c:	0c 49       	mov	r9,	r12	;

0000c63e <.LVL8>:
    c63e:	0c dd       	bis	r13,	r12	;
    c640:	0c 93       	cmp	#0,	r12	;r3 As==00
    c642:	05 20       	jnz	$+12     	;abs 0xc64e

0000c644 <.Loc.519.1>:
    c644:	aa 43 00 00 	mov	#2,	0(r10)	;r3 As==10

0000c648 <.L1>:
    c648:	21 53       	incd	r1		;
    c64a:	37 17       	popm	#4,	r10	;16-bit words
    c64c:	30 41       	ret			

0000c64e <.L3>:
    c64e:	0c 49       	mov	r9,	r12	;
    c650:	b0 12 64 c2 	call	#49764		;#0xc264

0000c654 <.LVL11>:
    c654:	ba 40 03 00 	mov	#3,	0(r10)	;
    c658:	00 00 
    c65a:	3e 40 81 ff 	mov	#65409,	r14	;#0xff81

0000c65e <.L13>:
    c65e:	08 4c       	mov	r12,	r8	;
    c660:	09 4d       	mov	r13,	r9	;
    c662:	08 5c       	add	r12,	r8	;
    c664:	09 6d       	addc	r13,	r9	;
    c666:	0c 48       	mov	r8,	r12	;

0000c668 <.LVL12>:
    c668:	0d 49       	mov	r9,	r13	;

0000c66a <.LVL13>:
    c66a:	0f 4e       	mov	r14,	r15	;
    c66c:	3e 53       	add	#-1,	r14	;r3 As==11

0000c66e <.Loc.531.1>:
    c66e:	39 40 ff 3f 	mov	#16383,	r9	;#0x3fff
    c672:	09 9d       	cmp	r13,	r9	;
    c674:	f4 2f       	jc	$-22     	;abs 0xc65e
    c676:	8a 4f 04 00 	mov	r15,	4(r10)	;

0000c67a <.Loc.537.1>:
    c67a:	8a 48 06 00 	mov	r8,	6(r10)	;

0000c67e <.L14>:
    c67e:	8a 4d 08 00 	mov	r13,	8(r10)	;

0000c682 <.Loc.576.1>:
    c682:	e2 3f       	jmp	$-58     	;abs 0xc648

0000c684 <.L2>:
    c684:	3c 90 ff 00 	cmp	#255,	r12	;#0x00ff
    c688:	1a 20       	jnz	$+54     	;abs 0xc6be

0000c68a <.Loc.543.1>:
    c68a:	0c 49       	mov	r9,	r12	;

0000c68c <.LVL16>:
    c68c:	0c dd       	bis	r13,	r12	;
    c68e:	0c 93       	cmp	#0,	r12	;r3 As==00
    c690:	03 20       	jnz	$+8      	;abs 0xc698

0000c692 <.Loc.546.1>:
    c692:	aa 42 00 00 	mov	#4,	0(r10)	;r2 As==10
    c696:	d8 3f       	jmp	$-78     	;abs 0xc648

0000c698 <.L8>:
    c698:	78 f0 40 00 	and.b	#64,	r8	;#0x0040
    c69c:	08 93       	cmp	#0,	r8	;r3 As==00
    c69e:	0c 24       	jz	$+26     	;abs 0xc6b8

0000c6a0 <.Loc.557.1>:
    c6a0:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01

0000c6a4 <.L11>:
    c6a4:	0c 49       	mov	r9,	r12	;
    c6a6:	b0 12 64 c2 	call	#49764		;#0xc264
    c6aa:	3c f0 80 ff 	and	#65408,	r12	;#0xff80
    c6ae:	8a 4c 06 00 	mov	r12,	6(r10)	;
    c6b2:	3d f0 ff df 	and	#57343,	r13	;#0xdfff
    c6b6:	e3 3f       	jmp	$-56     	;abs 0xc67e

0000c6b8 <.L9>:
    c6b8:	8a 48 00 00 	mov	r8,	0(r10)	;
    c6bc:	f3 3f       	jmp	$-24     	;abs 0xc6a4

0000c6be <.L7>:
    c6be:	3c 50 81 ff 	add	#65409,	r12	;#0xff81

0000c6c2 <.LVL21>:
    c6c2:	8a 4c 04 00 	mov	r12,	4(r10)	;

0000c6c6 <.Loc.573.1>:
    c6c6:	ba 40 03 00 	mov	#3,	0(r10)	;
    c6ca:	00 00 

0000c6cc <.Loc.574.1>:
    c6cc:	0c 49       	mov	r9,	r12	;

0000c6ce <.LVL22>:
    c6ce:	b0 12 64 c2 	call	#49764		;#0xc264

0000c6d2 <.LVL23>:
    c6d2:	8a 4c 06 00 	mov	r12,	6(r10)	;
    c6d6:	3d d0 00 40 	bis	#16384,	r13	;#0x4000
    c6da:	d1 3f       	jmp	$-92     	;abs 0xc67e

0000c6dc <__fpcmp_parts_f>:
    c6dc:	0a 15       	pushm	#1,	r10	;16-bit words

0000c6de <.LCFI0>:
    c6de:	2f 4c       	mov	@r12,	r15	;

0000c6e0 <.Loc.1084.1>:
    c6e0:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c6e2:	0a 9f       	cmp	r15,	r10	;
    c6e4:	1a 2c       	jc	$+54     	;abs 0xc71a

0000c6e6 <L0>:
    c6e6:	2e 4d       	mov	@r13,	r14	;

0000c6e8 <.Loc.1084.1>:
    c6e8:	0a 9e       	cmp	r14,	r10	;
    c6ea:	17 2c       	jc	$+48     	;abs 0xc71a

0000c6ec <.Loc.1088.1>:
    c6ec:	2f 92       	cmp	#4,	r15	;r2 As==10
    c6ee:	0f 20       	jnz	$+32     	;abs 0xc70e

0000c6f0 <.Loc.1088.1>:
    c6f0:	2e 92       	cmp	#4,	r14	;r2 As==10
    c6f2:	07 20       	jnz	$+16     	;abs 0xc702

0000c6f4 <.Loc.1099.1>:
    c6f4:	1e 4d 02 00 	mov	2(r13),	r14	;
    c6f8:	1e 8c 02 00 	sub	2(r12),	r14	;

0000c6fc <.L1>:
    c6fc:	0c 4e       	mov	r14,	r12	;
    c6fe:	0a 17       	popm	#1,	r10	;16-bit words
    c700:	30 41       	ret			

0000c702 <.L4>:
    c702:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c704:	8c 93 02 00 	cmp	#0,	2(r12)	;r3 As==00
    c708:	f9 27       	jz	$-12     	;abs 0xc6fc

0000c70a <.L24>:
    c70a:	3e 43       	mov	#-1,	r14	;r3 As==11
    c70c:	f7 3f       	jmp	$-16     	;abs 0xc6fc

0000c70e <.L3>:
    c70e:	2e 92       	cmp	#4,	r14	;r2 As==10
    c710:	06 20       	jnz	$+14     	;abs 0xc71e

0000c712 <.L7>:
    c712:	3e 43       	mov	#-1,	r14	;r3 As==11
    c714:	8d 93 02 00 	cmp	#0,	2(r13)	;r3 As==00
    c718:	f1 27       	jz	$-28     	;abs 0xc6fc

0000c71a <.L15>:
    c71a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c71c:	ef 3f       	jmp	$-32     	;abs 0xc6fc

0000c71e <.L5>:
    c71e:	2f 93       	cmp	#2,	r15	;r3 As==10
    c720:	04 20       	jnz	$+10     	;abs 0xc72a

0000c722 <.Loc.1110.1>:
    c722:	2e 93       	cmp	#2,	r14	;r3 As==10
    c724:	f6 23       	jnz	$-18     	;abs 0xc712

0000c726 <.L23>:
    c726:	4e 43       	clr.b	r14		;
    c728:	e9 3f       	jmp	$-44     	;abs 0xc6fc

0000c72a <.L6>:
    c72a:	2e 93       	cmp	#2,	r14	;r3 As==10
    c72c:	ea 27       	jz	$-42     	;abs 0xc702

0000c72e <.Loc.1123.1>:
    c72e:	1f 4c 02 00 	mov	2(r12),	r15	;
    c732:	1f 9d 02 00 	cmp	2(r13),	r15	;
    c736:	04 24       	jz	$+10     	;abs 0xc740

0000c738 <.L25>:
    c738:	5e 43       	mov.b	#1,	r14	;r3 As==01

0000c73a <.Loc.1140.1>:
    c73a:	0f 93       	cmp	#0,	r15	;r3 As==00
    c73c:	df 27       	jz	$-64     	;abs 0xc6fc
    c73e:	e5 3f       	jmp	$-52     	;abs 0xc70a

0000c740 <.L8>:
    c740:	1b 4c 04 00 	mov	4(r12),	r11	;
    c744:	1e 4d 04 00 	mov	4(r13),	r14	;
    c748:	0e 9b       	cmp	r11,	r14	;
    c74a:	f6 3b       	jl	$-18     	;abs 0xc738

0000c74c <.Loc.1133.1>:
    c74c:	0b 9e       	cmp	r14,	r11	;
    c74e:	03 34       	jge	$+8      	;abs 0xc756

0000c750 <.L26>:
    c750:	0f 93       	cmp	#0,	r15	;r3 As==00
    c752:	e3 23       	jnz	$-56     	;abs 0xc71a
    c754:	da 3f       	jmp	$-74     	;abs 0xc70a

0000c756 <.L10>:
    c756:	1e 4c 06 00 	mov	6(r12),	r14	;
    c75a:	1c 4c 08 00 	mov	8(r12),	r12	;

0000c75e <.LVL18>:
    c75e:	1b 4d 06 00 	mov	6(r13),	r11	;
    c762:	1d 4d 08 00 	mov	8(r13),	r13	;

0000c766 <.LVL19>:
    c766:	0d 9c       	cmp	r12,	r13	;
    c768:	e7 2b       	jnc	$-48     	;abs 0xc738
    c76a:	0c 9d       	cmp	r13,	r12	;
    c76c:	02 20       	jnz	$+6      	;abs 0xc772
    c76e:	0b 9e       	cmp	r14,	r11	;
    c770:	e3 2b       	jnc	$-56     	;abs 0xc738

0000c772 <.L11>:
    c772:	0c 9d       	cmp	r13,	r12	;
    c774:	ed 2b       	jnc	$-36     	;abs 0xc750
    c776:	0d 9c       	cmp	r12,	r13	;
    c778:	d6 23       	jnz	$-82     	;abs 0xc726
    c77a:	0e 9b       	cmp	r11,	r14	;
    c77c:	e9 2b       	jnc	$-44     	;abs 0xc750
    c77e:	d3 3f       	jmp	$-88     	;abs 0xc726

0000c780 <__pack_d>:
    c780:	6a 15       	pushm	#7,	r10	;16-bit words

0000c782 <.LCFI0>:
    c782:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000c786 <.LCFI1>:
    c786:	1a 4c 06 00 	mov	6(r12),	r10	;
    c78a:	16 4c 08 00 	Address 0x000000000000c78c is out of bounds.
mov	-1(r12),r6	;

0000c78c <L0>:
    c78c:	08 00       	mova	@r0,	r8	;
    c78e:	17 4c 0a 00 	mov	10(r12),r7	;0x0000a
    c792:	18 4c 0c 00 	mov	12(r12),r8	;0x0000c

0000c796 <.LVL1>:
    c796:	91 4c 02 00 	mov	2(r12),	2(r1)	;
    c79a:	02 00 

0000c79c <.LVL2>:
    c79c:	2d 4c       	mov	@r12,	r13	;

0000c79e <.Loc.205.1>:
    c79e:	59 43       	mov.b	#1,	r9	;r3 As==01
    c7a0:	09 9d       	cmp	r13,	r9	;
    c7a2:	24 28       	jnc	$+74     	;abs 0xc7ec

0000c7a4 <.LVL4>:
    c7a4:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11

0000c7a8 <.LVL5>:
    c7a8:	0c 4a       	mov	r10,	r12	;

0000c7aa <.LVL6>:
    c7aa:	0d 46       	mov	r6,	r13	;
    c7ac:	0e 47       	mov	r7,	r14	;
    c7ae:	0f 48       	mov	r8,	r15	;
    c7b0:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000c7b4 <.LVL7>:
    c7b4:	7f f0 07 00 	and.b	#7,	r15	;

0000c7b8 <.Loc.220.1>:
    c7b8:	0a 4c       	mov	r12,	r10	;
    c7ba:	06 4d       	mov	r13,	r6	;
    c7bc:	07 4e       	mov	r14,	r7	;
    c7be:	08 4f       	mov	r15,	r8	;
    c7c0:	38 d2       	bis	#8,	r8	;r2 As==11

0000c7c2 <.LVL9>:
    c7c2:	39 40 ff 07 	mov	#2047,	r9	;#0x07ff

0000c7c6 <.L3>:
    c7c6:	39 f0 ff 07 	and	#2047,	r9	;#0x07ff

0000c7ca <.LVL11>:
    c7ca:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    c7ce:	78 f0 0f 00 	and.b	#15,	r8	;#0x000f

0000c7d2 <.LVL12>:
    c7d2:	1f 41 02 00 	mov	2(r1),	r15	;
    c7d6:	4e 18 0f 5f 	rpt #15 { rlax.w	r15		;
    c7da:	08 d9       	bis	r9,	r8	;

0000c7dc <.Loc.424.1>:
    c7dc:	0c 4a       	mov	r10,	r12	;
    c7de:	0d 46       	mov	r6,	r13	;
    c7e0:	0e 47       	mov	r7,	r14	;
    c7e2:	0f d8       	bis	r8,	r15	;
    c7e4:	31 50 0c 00 	add	#12,	r1	;#0x000c
    c7e8:	64 17       	popm	#7,	r10	;16-bit words
    c7ea:	30 41       	ret			

0000c7ec <.L2>:
    c7ec:	2d 92       	cmp	#4,	r13	;r2 As==10
    c7ee:	35 25       	jz	$+620    	;abs 0xca5a

0000c7f0 <.Loc.229.1>:
    c7f0:	2d 93       	cmp	#2,	r13	;r3 As==10
    c7f2:	2b 25       	jz	$+600    	;abs 0xca4a

0000c7f4 <.Loc.234.1>:
    c7f4:	0f 4a       	mov	r10,	r15	;
    c7f6:	0f d6       	bis	r6,	r15	;
    c7f8:	0f d7       	bis	r7,	r15	;
    c7fa:	0f d8       	bis	r8,	r15	;
    c7fc:	0f 93       	cmp	#0,	r15	;r3 As==00
    c7fe:	2b 25       	jz	$+600    	;abs 0xca56

0000c800 <.Loc.240.1>:
    c800:	14 4c 04 00 	mov	4(r12),	r4	;
    c804:	34 90 02 fc 	cmp	#64514,	r4	;#0xfc02
    c808:	c4 34       	jge	$+394    	;abs 0xc992

0000c80a <.LBB10>:
    c80a:	35 40 02 fc 	mov	#64514,	r5	;#0xfc02
    c80e:	05 84       	sub	r4,	r5	;

0000c810 <.LVL15>:
    c810:	7c 40 38 00 	mov.b	#56,	r12	;#0x0038

0000c814 <.LVL16>:
    c814:	0c 95       	cmp	r5,	r12	;
    c816:	9e 38       	jl	$+318    	;abs 0xc954

0000c818 <.LBB11>:
    c818:	81 45 00 00 	mov	r5,	0(r1)	;
    c81c:	0c 4a       	mov	r10,	r12	;
    c81e:	0d 46       	mov	r6,	r13	;
    c820:	0e 47       	mov	r7,	r14	;
    c822:	0f 48       	mov	r8,	r15	;
    c824:	b0 12 b6 c3 	call	#50102		;#0xc3b6
    c828:	81 4c 04 00 	mov	r12,	4(r1)	;
    c82c:	81 4d 06 00 	mov	r13,	6(r1)	;
    c830:	81 4e 08 00 	mov	r14,	8(r1)	;
    c834:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a

0000c838 <.Loc.264.1>:
    c838:	0c 49       	mov	r9,	r12	;
    c83a:	4d 43       	clr.b	r13		;
    c83c:	0e 4d       	mov	r13,	r14	;
    c83e:	0f 4d       	mov	r13,	r15	;
    c840:	b0 12 3a c4 	call	#50234		;#0xc43a
    c844:	34 43       	mov	#-1,	r4	;r3 As==11
    c846:	05 4c       	mov	r12,	r5	;
    c848:	05 89       	sub	r9,	r5	;

0000c84a <.LVL20>:
    c84a:	05 9c       	cmp	r12,	r5	;
    c84c:	01 28       	jnc	$+4      	;abs 0xc850
    c84e:	49 43       	clr.b	r9		;

0000c850 <.L7>:
    c850:	0c 4d       	mov	r13,	r12	;
    c852:	0c 54       	add	r4,	r12	;
    c854:	5b 43       	mov.b	#1,	r11	;r3 As==01
    c856:	0c 9d       	cmp	r13,	r12	;
    c858:	01 28       	jnc	$+4      	;abs 0xc85c
    c85a:	4b 43       	clr.b	r11		;

0000c85c <.L8>:
    c85c:	09 5c       	add	r12,	r9	;
    c85e:	5d 43       	mov.b	#1,	r13	;r3 As==01
    c860:	09 9c       	cmp	r12,	r9	;
    c862:	01 28       	jnc	$+4      	;abs 0xc866
    c864:	4d 43       	clr.b	r13		;

0000c866 <.L9>:
    c866:	0b dd       	bis	r13,	r11	;
    c868:	0d 4e       	mov	r14,	r13	;
    c86a:	0d 54       	add	r4,	r13	;
    c86c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c86e:	0d 9e       	cmp	r14,	r13	;
    c870:	01 28       	jnc	$+4      	;abs 0xc874
    c872:	4c 43       	clr.b	r12		;

0000c874 <.L10>:
    c874:	0b 5d       	add	r13,	r11	;
    c876:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c878:	0b 9d       	cmp	r13,	r11	;
    c87a:	01 28       	jnc	$+4      	;abs 0xc87e
    c87c:	4e 43       	clr.b	r14		;

0000c87e <.L11>:
    c87e:	0c de       	bis	r14,	r12	;
    c880:	0f 54       	add	r4,	r15	;
    c882:	0f 5c       	add	r12,	r15	;
    c884:	0a f5       	and	r5,	r10	;

0000c886 <.LVL21>:
    c886:	09 f6       	and	r6,	r9	;
    c888:	0b f7       	and	r7,	r11	;
    c88a:	08 ff       	and	r15,	r8	;
    c88c:	4f 43       	clr.b	r15		;
    c88e:	0c 4f       	mov	r15,	r12	;
    c890:	0c 8a       	sub	r10,	r12	;
    c892:	57 43       	mov.b	#1,	r7	;r3 As==01
    c894:	0c 9f       	cmp	r15,	r12	;
    c896:	01 20       	jnz	$+4      	;abs 0xc89a
    c898:	07 4c       	mov	r12,	r7	;

0000c89a <.L12>:
    c89a:	0e 4f       	mov	r15,	r14	;
    c89c:	0e 89       	sub	r9,	r14	;
    c89e:	56 43       	mov.b	#1,	r6	;r3 As==01
    c8a0:	0e 93       	cmp	#0,	r14	;r3 As==00
    c8a2:	01 20       	jnz	$+4      	;abs 0xc8a6
    c8a4:	06 4e       	mov	r14,	r6	;

0000c8a6 <.L13>:
    c8a6:	0d 4e       	mov	r14,	r13	;
    c8a8:	0d 87       	sub	r7,	r13	;
    c8aa:	57 43       	mov.b	#1,	r7	;r3 As==01
    c8ac:	0e 9d       	cmp	r13,	r14	;
    c8ae:	01 28       	jnc	$+4      	;abs 0xc8b2
    c8b0:	47 43       	clr.b	r7		;

0000c8b2 <.L14>:
    c8b2:	06 d7       	bis	r7,	r6	;
    c8b4:	07 4f       	mov	r15,	r7	;
    c8b6:	07 8b       	sub	r11,	r7	;
    c8b8:	54 43       	mov.b	#1,	r4	;r3 As==01
    c8ba:	07 93       	cmp	#0,	r7	;r3 As==00
    c8bc:	01 20       	jnz	$+4      	;abs 0xc8c0
    c8be:	04 47       	mov	r7,	r4	;

0000c8c0 <.L15>:
    c8c0:	0e 47       	mov	r7,	r14	;
    c8c2:	0e 86       	sub	r6,	r14	;
    c8c4:	56 43       	mov.b	#1,	r6	;r3 As==01
    c8c6:	07 9e       	cmp	r14,	r7	;
    c8c8:	01 28       	jnc	$+4      	;abs 0xc8cc
    c8ca:	46 43       	clr.b	r6		;

0000c8cc <.L16>:
    c8cc:	04 d6       	bis	r6,	r4	;
    c8ce:	0f 88       	sub	r8,	r15	;
    c8d0:	0f 84       	sub	r4,	r15	;
    c8d2:	b1 40 3f 00 	mov	#63,	0(r1)	;#0x003f
    c8d6:	00 00 
    c8d8:	0c da       	bis	r10,	r12	;
    c8da:	0d d9       	bis	r9,	r13	;
    c8dc:	0e db       	bis	r11,	r14	;
    c8de:	0f d8       	bis	r8,	r15	;
    c8e0:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000c8e4 <.Loc.265.1>:
    c8e4:	1c d1 04 00 	bis	4(r1),	r12	;
    c8e8:	1d d1 06 00 	bis	6(r1),	r13	;
    c8ec:	1e d1 08 00 	bis	8(r1),	r14	;
    c8f0:	1f d1 0a 00 	bis	10(r1),	r15	;0x0000a

0000c8f4 <.LBE11>:
    c8f4:	08 4c       	mov	r12,	r8	;
    c8f6:	78 f0 ff 00 	and.b	#255,	r8	;#0x00ff
    c8fa:	38 90 80 00 	cmp	#128,	r8	;#0x0080
    c8fe:	2e 20       	jnz	$+94     	;abs 0xc95c

0000c900 <.Loc.269.1>:
    c900:	3c b0 00 01 	bit	#256,	r12	;#0x0100
    c904:	18 24       	jz	$+50     	;abs 0xc936

0000c906 <.Loc.270.1>:
    c906:	08 5c       	add	r12,	r8	;
    c908:	59 43       	mov.b	#1,	r9	;r3 As==01
    c90a:	08 9c       	cmp	r12,	r8	;
    c90c:	01 28       	jnc	$+4      	;abs 0xc910
    c90e:	49 43       	clr.b	r9		;

0000c910 <.L20>:
    c910:	4c 43       	clr.b	r12		;

0000c912 <.LVL24>:
    c912:	09 5d       	add	r13,	r9	;
    c914:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c916:	09 9d       	cmp	r13,	r9	;
    c918:	01 28       	jnc	$+4      	;abs 0xc91c
    c91a:	0a 4c       	mov	r12,	r10	;

0000c91c <.L22>:
    c91c:	0c da       	bis	r10,	r12	;
    c91e:	47 43       	clr.b	r7		;
    c920:	0a 4c       	mov	r12,	r10	;
    c922:	0a 5e       	add	r14,	r10	;
    c924:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c926:	0a 9e       	cmp	r14,	r10	;
    c928:	01 28       	jnc	$+4      	;abs 0xc92c
    c92a:	0c 47       	mov	r7,	r12	;

0000c92c <.L24>:
    c92c:	07 dc       	bis	r12,	r7	;
    c92e:	0c 48       	mov	r8,	r12	;
    c930:	0d 49       	mov	r9,	r13	;
    c932:	0e 4a       	mov	r10,	r14	;
    c934:	0f 57       	add	r7,	r15	;

0000c936 <.L18>:
    c936:	59 43       	mov.b	#1,	r9	;r3 As==01
    c938:	3a 40 ff 0f 	mov	#4095,	r10	;#0x0fff
    c93c:	0a 9f       	cmp	r15,	r10	;
    c93e:	01 28       	jnc	$+4      	;abs 0xc942
    c940:	49 43       	clr.b	r9		;

0000c942 <.L30>:
    c942:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    c946:	b0 12 b6 c3 	call	#50102		;#0xc3b6

0000c94a <.L61>:
    c94a:	0a 4c       	mov	r12,	r10	;
    c94c:	06 4d       	mov	r13,	r6	;
    c94e:	07 4e       	mov	r14,	r7	;
    c950:	08 4f       	mov	r15,	r8	;

0000c952 <.LVL28>:
    c952:	39 3f       	jmp	$-396    	;abs 0xc7c6

0000c954 <.L51>:
    c954:	4c 43       	clr.b	r12		;
    c956:	0d 4c       	mov	r12,	r13	;
    c958:	0e 4c       	mov	r12,	r14	;
    c95a:	0f 4c       	mov	r12,	r15	;

0000c95c <.L17>:
    c95c:	07 4c       	mov	r12,	r7	;
    c95e:	37 50 7f 00 	add	#127,	r7	;#0x007f
    c962:	59 43       	mov.b	#1,	r9	;r3 As==01
    c964:	07 9c       	cmp	r12,	r7	;
    c966:	01 28       	jnc	$+4      	;abs 0xc96a
    c968:	49 43       	clr.b	r9		;

0000c96a <.L25>:
    c96a:	4c 43       	clr.b	r12		;

0000c96c <.LVL31>:
    c96c:	09 5d       	add	r13,	r9	;
    c96e:	5a 43       	mov.b	#1,	r10	;r3 As==01
    c970:	09 9d       	cmp	r13,	r9	;
    c972:	01 28       	jnc	$+4      	;abs 0xc976
    c974:	0a 4c       	mov	r12,	r10	;

0000c976 <.L27>:
    c976:	0c da       	bis	r10,	r12	;
    c978:	48 43       	clr.b	r8		;
    c97a:	0a 4c       	mov	r12,	r10	;
    c97c:	0a 5e       	add	r14,	r10	;
    c97e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    c980:	0a 9e       	cmp	r14,	r10	;
    c982:	01 28       	jnc	$+4      	;abs 0xc986
    c984:	0c 48       	mov	r8,	r12	;

0000c986 <.L29>:
    c986:	08 dc       	bis	r12,	r8	;
    c988:	0c 47       	mov	r7,	r12	;
    c98a:	0d 49       	mov	r9,	r13	;
    c98c:	0e 4a       	mov	r10,	r14	;
    c98e:	0f 58       	add	r8,	r15	;

0000c990 <.LVL33>:
    c990:	d2 3f       	jmp	$-90     	;abs 0xc936

0000c992 <.L5>:
    c992:	3c 40 ff 03 	mov	#1023,	r12	;#0x03ff

0000c996 <.LVL35>:
    c996:	0c 94       	cmp	r4,	r12	;
    c998:	60 38       	jl	$+194    	;abs 0xca5a

0000c99a <.LVL36>:
    c99a:	0e 4a       	mov	r10,	r14	;
    c99c:	7e f0 ff 00 	and.b	#255,	r14	;#0x00ff
    c9a0:	3e 90 80 00 	cmp	#128,	r14	;#0x0080
    c9a4:	2a 20       	jnz	$+86     	;abs 0xc9fa

0000c9a6 <.Loc.299.1>:
    c9a6:	3a b0 00 01 	bit	#256,	r10	;#0x0100
    c9aa:	16 24       	jz	$+46     	;abs 0xc9d8

0000c9ac <.Loc.300.1>:
    c9ac:	0e 5a       	add	r10,	r14	;
    c9ae:	0e 9a       	cmp	r10,	r14	;
    c9b0:	01 28       	jnc	$+4      	;abs 0xc9b4
    c9b2:	49 43       	clr.b	r9		;

0000c9b4 <.L35>:
    c9b4:	4c 43       	clr.b	r12		;
    c9b6:	09 56       	add	r6,	r9	;
    c9b8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    c9ba:	09 96       	cmp	r6,	r9	;
    c9bc:	01 28       	jnc	$+4      	;abs 0xc9c0
    c9be:	0d 4c       	mov	r12,	r13	;

0000c9c0 <.L37>:
    c9c0:	0c dd       	bis	r13,	r12	;
    c9c2:	4d 43       	clr.b	r13		;
    c9c4:	0c 57       	add	r7,	r12	;
    c9c6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c9c8:	0c 97       	cmp	r7,	r12	;
    c9ca:	01 28       	jnc	$+4      	;abs 0xc9ce
    c9cc:	0f 4d       	mov	r13,	r15	;

0000c9ce <.L39>:
    c9ce:	0d df       	bis	r15,	r13	;
    c9d0:	0a 4e       	mov	r14,	r10	;

0000c9d2 <.LVL37>:
    c9d2:	06 49       	mov	r9,	r6	;
    c9d4:	07 4c       	mov	r12,	r7	;
    c9d6:	08 5d       	add	r13,	r8	;

0000c9d8 <.L33>:
    c9d8:	35 40 b6 c3 	mov	#50102,	r5	;#0xc3b6

0000c9dc <.Loc.307.1>:
    c9dc:	3e 40 ff 1f 	mov	#8191,	r14	;#0x1fff
    c9e0:	0e 98       	cmp	r8,	r14	;
    c9e2:	24 28       	jnc	$+74     	;abs 0xca2c

0000c9e4 <.Loc.293.1>:
    c9e4:	09 44       	mov	r4,	r9	;
    c9e6:	39 50 ff 03 	add	#1023,	r9	;#0x03ff

0000c9ea <.L47>:
    c9ea:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    c9ee:	0c 4a       	mov	r10,	r12	;
    c9f0:	0d 46       	mov	r6,	r13	;
    c9f2:	0e 47       	mov	r7,	r14	;
    c9f4:	0f 48       	mov	r8,	r15	;
    c9f6:	85 12       	call	r5		;
    c9f8:	a8 3f       	jmp	$-174    	;abs 0xc94a

0000c9fa <.L32>:
    c9fa:	0d 4a       	mov	r10,	r13	;
    c9fc:	3d 50 7f 00 	add	#127,	r13	;#0x007f
    ca00:	0d 9a       	cmp	r10,	r13	;
    ca02:	01 28       	jnc	$+4      	;abs 0xca06
    ca04:	49 43       	clr.b	r9		;

0000ca06 <.L40>:
    ca06:	4c 43       	clr.b	r12		;
    ca08:	09 56       	add	r6,	r9	;
    ca0a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ca0c:	09 96       	cmp	r6,	r9	;
    ca0e:	01 28       	jnc	$+4      	;abs 0xca12
    ca10:	0e 4c       	mov	r12,	r14	;

0000ca12 <.L42>:
    ca12:	0c de       	bis	r14,	r12	;
    ca14:	4e 43       	clr.b	r14		;
    ca16:	0c 57       	add	r7,	r12	;
    ca18:	5f 43       	mov.b	#1,	r15	;r3 As==01
    ca1a:	0c 97       	cmp	r7,	r12	;
    ca1c:	01 28       	jnc	$+4      	;abs 0xca20
    ca1e:	0f 4e       	mov	r14,	r15	;

0000ca20 <.L44>:
    ca20:	0e df       	bis	r15,	r14	;
    ca22:	0a 4d       	mov	r13,	r10	;

0000ca24 <.LVL42>:
    ca24:	06 49       	mov	r9,	r6	;
    ca26:	07 4c       	mov	r12,	r7	;
    ca28:	08 5e       	add	r14,	r8	;

0000ca2a <.LVL44>:
    ca2a:	d6 3f       	jmp	$-82     	;abs 0xc9d8

0000ca2c <.L45>:
    ca2c:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    ca30:	0c 4a       	mov	r10,	r12	;
    ca32:	0d 46       	mov	r6,	r13	;
    ca34:	0e 47       	mov	r7,	r14	;
    ca36:	0f 48       	mov	r8,	r15	;
    ca38:	85 12       	call	r5		;
    ca3a:	0a 4c       	mov	r12,	r10	;

0000ca3c <.LVL47>:
    ca3c:	06 4d       	mov	r13,	r6	;
    ca3e:	07 4e       	mov	r14,	r7	;
    ca40:	08 4f       	mov	r15,	r8	;

0000ca42 <.LVL48>:
    ca42:	09 44       	mov	r4,	r9	;
    ca44:	39 50 00 04 	add	#1024,	r9	;#0x0400

0000ca48 <.LVL49>:
    ca48:	d0 3f       	jmp	$-94     	;abs 0xc9ea

0000ca4a <.L49>:
    ca4a:	49 43       	clr.b	r9		;

0000ca4c <.Loc.232.1>:
    ca4c:	0a 49       	mov	r9,	r10	;

0000ca4e <.LVL51>:
    ca4e:	06 49       	mov	r9,	r6	;
    ca50:	07 49       	mov	r9,	r7	;
    ca52:	08 49       	mov	r9,	r8	;
    ca54:	b8 3e       	jmp	$-654    	;abs 0xc7c6

0000ca56 <.L50>:
    ca56:	09 4f       	mov	r15,	r9	;
    ca58:	b6 3e       	jmp	$-658    	;abs 0xc7c6

0000ca5a <.L52>:
    ca5a:	39 40 ff 07 	mov	#2047,	r9	;#0x07ff

0000ca5e <.Loc.227.1>:
    ca5e:	4a 43       	clr.b	r10		;

0000ca60 <.LVL54>:
    ca60:	06 4a       	mov	r10,	r6	;
    ca62:	07 4a       	mov	r10,	r7	;
    ca64:	08 4a       	mov	r10,	r8	;
    ca66:	af 3e       	jmp	$-672    	;abs 0xc7c6

0000ca68 <__unpack_d>:
    ca68:	6a 15       	pushm	#7,	r10	;16-bit words

0000ca6a <.LCFI0>:
    ca6a:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000ca6e <.LCFI1>:
    ca6e:	08 4c       	mov	r12,	r8	;
    ca70:	0a 4d       	mov	r13,	r10	;

0000ca72 <.Loc.454.1>:
    ca72:	27 4c       	mov	@r12,	r7	;
    ca74:	1d 4c 02 00 	mov	2(r12),	r13	;

0000ca78 <L0>:
    ca78:	1e 4c 04 00 	mov	4(r12),	r14	;
    ca7c:	56 4c 06 00 	mov.b	6(r12),	r6	;
    ca80:	0f 46       	mov	r6,	r15	;
    ca82:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f

0000ca86 <.LVL2>:
    ca86:	1c 4c 06 00 	mov	6(r12),	r12	;

0000ca8a <.LVL3>:
    ca8a:	81 4d 08 00 	mov	r13,	8(r1)	;
    ca8e:	81 4e 06 00 	mov	r14,	6(r1)	;
    ca92:	81 4f 04 00 	mov	r15,	4(r1)	;
    ca96:	b0 12 2e c3 	call	#49966		;#0xc32e

0000ca9a <.LVL4>:
    ca9a:	09 4c       	mov	r12,	r9	;
    ca9c:	39 f0 ff 07 	and	#2047,	r9	;#0x07ff

0000caa0 <.LVL5>:
    caa0:	5c 48 07 00 	mov.b	7(r8),	r12	;
    caa4:	5c 0f       	rrum	#4,	r12	;
    caa6:	5c 0b       	rrum	#3,	r12	;

0000caa8 <.Loc.508.1>:
    caa8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    caac:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000cab0 <.LVL6>:
    cab0:	1d 41 08 00 	mov	8(r1),	r13	;
    cab4:	1e 41 06 00 	mov	6(r1),	r14	;
    cab8:	1f 41 04 00 	mov	4(r1),	r15	;

0000cabc <.LVL8>:
    cabc:	09 93       	cmp	#0,	r9	;r3 As==00
    cabe:	4e 20       	jnz	$+158    	;abs 0xcb5c

0000cac0 <.Loc.512.1>:
    cac0:	0c 47       	mov	r7,	r12	;
    cac2:	0c dd       	bis	r13,	r12	;
    cac4:	0c de       	bis	r14,	r12	;
    cac6:	0c df       	bis	r15,	r12	;
    cac8:	0c 93       	cmp	#0,	r12	;r3 As==00
    caca:	06 20       	jnz	$+14     	;abs 0xcad8

0000cacc <.Loc.519.1>:
    cacc:	aa 43 00 00 	mov	#2,	0(r10)	;r3 As==10

0000cad0 <.L1>:
    cad0:	31 50 0a 00 	add	#10,	r1	;#0x000a
    cad4:	64 17       	popm	#7,	r10	;16-bit words
    cad6:	30 41       	ret			

0000cad8 <.L3>:
    cad8:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    cadc:	0c 47       	mov	r7,	r12	;
    cade:	b0 12 3a c4 	call	#50234		;#0xc43a

0000cae2 <.LVL11>:
    cae2:	ba 40 03 00 	mov	#3,	0(r10)	;
    cae6:	00 00 
    cae8:	3b 40 01 fc 	mov	#64513,	r11	;#0xfc01

0000caec <.Loc.533.1>:
    caec:	55 43       	mov.b	#1,	r5	;r3 As==01

0000caee <.L18>:
    caee:	06 4c       	mov	r12,	r6	;
    caf0:	06 5c       	add	r12,	r6	;
    caf2:	08 45       	mov	r5,	r8	;
    caf4:	06 9c       	cmp	r12,	r6	;
    caf6:	01 28       	jnc	$+4      	;abs 0xcafa
    caf8:	08 49       	mov	r9,	r8	;

0000cafa <.L5>:
    cafa:	07 4d       	mov	r13,	r7	;
    cafc:	07 5d       	add	r13,	r7	;
    cafe:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000cb00 <.LVL13>:
    cb00:	07 9d       	cmp	r13,	r7	;
    cb02:	01 28       	jnc	$+4      	;abs 0xcb06
    cb04:	4c 43       	clr.b	r12		;

0000cb06 <.L6>:
    cb06:	08 57       	add	r7,	r8	;
    cb08:	0d 45       	mov	r5,	r13	;
    cb0a:	08 97       	cmp	r7,	r8	;
    cb0c:	01 28       	jnc	$+4      	;abs 0xcb10
    cb0e:	0d 49       	mov	r9,	r13	;

0000cb10 <.L7>:
    cb10:	0c dd       	bis	r13,	r12	;
    cb12:	0d 4e       	mov	r14,	r13	;
    cb14:	0d 5e       	add	r14,	r13	;
    cb16:	57 43       	mov.b	#1,	r7	;r3 As==01
    cb18:	0d 9e       	cmp	r14,	r13	;
    cb1a:	01 28       	jnc	$+4      	;abs 0xcb1e
    cb1c:	47 43       	clr.b	r7		;

0000cb1e <.L8>:
    cb1e:	04 4c       	mov	r12,	r4	;
    cb20:	04 5d       	add	r13,	r4	;
    cb22:	0c 45       	mov	r5,	r12	;
    cb24:	04 9d       	cmp	r13,	r4	;
    cb26:	01 28       	jnc	$+4      	;abs 0xcb2a
    cb28:	0c 49       	mov	r9,	r12	;

0000cb2a <.L9>:
    cb2a:	07 dc       	bis	r12,	r7	;
    cb2c:	0f 5f       	rla	r15		;
    cb2e:	0c 46       	mov	r6,	r12	;
    cb30:	0d 48       	mov	r8,	r13	;
    cb32:	0e 44       	mov	r4,	r14	;
    cb34:	0f 57       	add	r7,	r15	;

0000cb36 <.LVL14>:
    cb36:	81 4b 02 00 	mov	r11,	2(r1)	;
    cb3a:	3b 53       	add	#-1,	r11	;r3 As==11

0000cb3c <.Loc.531.1>:
    cb3c:	37 40 ff 0f 	mov	#4095,	r7	;#0x0fff
    cb40:	07 9f       	cmp	r15,	r7	;
    cb42:	d5 2f       	jc	$-84     	;abs 0xcaee

0000cb44 <.LVL15>:
    cb44:	9a 41 02 00 	mov	2(r1),	4(r10)	;
    cb48:	04 00 

0000cb4a <.Loc.537.1>:
    cb4a:	8a 46 06 00 	mov	r6,	6(r10)	;
    cb4e:	8a 48 08 00 	mov	r8,	8(r10)	;
    cb52:	8a 44 0a 00 	mov	r4,	10(r10)	; 0x000a

0000cb56 <.L19>:
    cb56:	8a 4f 0c 00 	mov	r15,	12(r10)	; 0x000c

0000cb5a <.Loc.576.1>:
    cb5a:	ba 3f       	jmp	$-138    	;abs 0xcad0

0000cb5c <.L2>:
    cb5c:	39 90 ff 07 	cmp	#2047,	r9	;#0x07ff
    cb60:	21 20       	jnz	$+68     	;abs 0xcba4

0000cb62 <.Loc.543.1>:
    cb62:	0c 47       	mov	r7,	r12	;
    cb64:	0c dd       	bis	r13,	r12	;
    cb66:	0c de       	bis	r14,	r12	;
    cb68:	0c df       	bis	r15,	r12	;
    cb6a:	0c 93       	cmp	#0,	r12	;r3 As==00
    cb6c:	03 20       	jnz	$+8      	;abs 0xcb74

0000cb6e <.Loc.546.1>:
    cb6e:	aa 42 00 00 	mov	#4,	0(r10)	;r2 As==10
    cb72:	ae 3f       	jmp	$-162    	;abs 0xcad0

0000cb74 <.L13>:
    cb74:	76 f2       	and.b	#8,	r6	;r2 As==11
    cb76:	06 93       	cmp	#0,	r6	;r3 As==00
    cb78:	12 24       	jz	$+38     	;abs 0xcb9e

0000cb7a <.Loc.557.1>:
    cb7a:	9a 43 00 00 	mov	#1,	0(r10)	;r3 As==01

0000cb7e <.L16>:
    cb7e:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    cb82:	0c 47       	mov	r7,	r12	;
    cb84:	b0 12 3a c4 	call	#50234		;#0xc43a
    cb88:	3c f0 00 ff 	and	#65280,	r12	;#0xff00
    cb8c:	8a 4c 06 00 	mov	r12,	6(r10)	;
    cb90:	8a 4d 08 00 	mov	r13,	8(r10)	;
    cb94:	8a 4e 0a 00 	mov	r14,	10(r10)	; 0x000a
    cb98:	3f f0 ff f7 	and	#63487,	r15	;#0xf7ff
    cb9c:	dc 3f       	jmp	$-70     	;abs 0xcb56

0000cb9e <.L14>:
    cb9e:	8a 46 00 00 	mov	r6,	0(r10)	;
    cba2:	ed 3f       	jmp	$-36     	;abs 0xcb7e

0000cba4 <.L12>:
    cba4:	39 50 01 fc 	add	#64513,	r9	;#0xfc01

0000cba8 <.LVL21>:
    cba8:	8a 49 04 00 	mov	r9,	4(r10)	;

0000cbac <.Loc.573.1>:
    cbac:	ba 40 03 00 	mov	#3,	0(r10)	;
    cbb0:	00 00 

0000cbb2 <.Loc.574.1>:
    cbb2:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    cbb6:	0c 47       	mov	r7,	r12	;
    cbb8:	b0 12 3a c4 	call	#50234		;#0xc43a

0000cbbc <.LVL22>:
    cbbc:	8a 4c 06 00 	mov	r12,	6(r10)	;
    cbc0:	8a 4d 08 00 	mov	r13,	8(r10)	;
    cbc4:	8a 4e 0a 00 	mov	r14,	10(r10)	; 0x000a
    cbc8:	3f d0 00 10 	bis	#4096,	r15	;#0x1000
    cbcc:	c4 3f       	jmp	$-118    	;abs 0xcb56

0000cbce <__fpcmp_parts_d>:
    cbce:	3a 15       	pushm	#4,	r10	;16-bit words

0000cbd0 <.LCFI0>:
    cbd0:	2f 4c       	mov	@r12,	r15	;

0000cbd2 <.Loc.1084.1>:
    cbd2:	5a 43       	mov.b	#1,	r10	;r3 As==01
    cbd4:	0a 9f       	cmp	r15,	r10	;
    cbd6:	1a 2c       	jc	$+54     	;abs 0xcc0c

0000cbd8 <L0>:
    cbd8:	2e 4d       	mov	@r13,	r14	;

0000cbda <.Loc.1084.1>:
    cbda:	0a 9e       	cmp	r14,	r10	;
    cbdc:	17 2c       	jc	$+48     	;abs 0xcc0c

0000cbde <.Loc.1088.1>:
    cbde:	2f 92       	cmp	#4,	r15	;r2 As==10
    cbe0:	0f 20       	jnz	$+32     	;abs 0xcc00

0000cbe2 <.Loc.1088.1>:
    cbe2:	2e 92       	cmp	#4,	r14	;r2 As==10
    cbe4:	07 20       	jnz	$+16     	;abs 0xcbf4

0000cbe6 <.Loc.1099.1>:
    cbe6:	1e 4d 02 00 	mov	2(r13),	r14	;
    cbea:	1e 8c 02 00 	sub	2(r12),	r14	;

0000cbee <.L1>:
    cbee:	0c 4e       	mov	r14,	r12	;
    cbf0:	37 17       	popm	#4,	r10	;16-bit words
    cbf2:	30 41       	ret			

0000cbf4 <.L4>:
    cbf4:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cbf6:	8c 93 02 00 	cmp	#0,	2(r12)	;r3 As==00
    cbfa:	f9 27       	jz	$-12     	;abs 0xcbee

0000cbfc <.L24>:
    cbfc:	3e 43       	mov	#-1,	r14	;r3 As==11
    cbfe:	f7 3f       	jmp	$-16     	;abs 0xcbee

0000cc00 <.L3>:
    cc00:	2e 92       	cmp	#4,	r14	;r2 As==10
    cc02:	06 20       	jnz	$+14     	;abs 0xcc10

0000cc04 <.L7>:
    cc04:	3e 43       	mov	#-1,	r14	;r3 As==11
    cc06:	8d 93 02 00 	cmp	#0,	2(r13)	;r3 As==00
    cc0a:	f1 27       	jz	$-28     	;abs 0xcbee

0000cc0c <.L15>:
    cc0c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cc0e:	ef 3f       	jmp	$-32     	;abs 0xcbee

0000cc10 <.L5>:
    cc10:	2f 93       	cmp	#2,	r15	;r3 As==10
    cc12:	04 20       	jnz	$+10     	;abs 0xcc1c

0000cc14 <.Loc.1110.1>:
    cc14:	2e 93       	cmp	#2,	r14	;r3 As==10
    cc16:	f6 23       	jnz	$-18     	;abs 0xcc04

0000cc18 <.L23>:
    cc18:	4e 43       	clr.b	r14		;
    cc1a:	e9 3f       	jmp	$-44     	;abs 0xcbee

0000cc1c <.L6>:
    cc1c:	2e 93       	cmp	#2,	r14	;r3 As==10
    cc1e:	ea 27       	jz	$-42     	;abs 0xcbf4

0000cc20 <.Loc.1123.1>:
    cc20:	1f 4c 02 00 	mov	2(r12),	r15	;
    cc24:	1f 9d 02 00 	cmp	2(r13),	r15	;
    cc28:	04 24       	jz	$+10     	;abs 0xcc32

0000cc2a <.L25>:
    cc2a:	5e 43       	mov.b	#1,	r14	;r3 As==01

0000cc2c <.Loc.1140.1>:
    cc2c:	0f 93       	cmp	#0,	r15	;r3 As==00
    cc2e:	df 27       	jz	$-64     	;abs 0xcbee
    cc30:	e5 3f       	jmp	$-52     	;abs 0xcbfc

0000cc32 <.L8>:
    cc32:	1a 4c 04 00 	mov	4(r12),	r10	;
    cc36:	1e 4d 04 00 	mov	4(r13),	r14	;
    cc3a:	0e 9a       	cmp	r10,	r14	;
    cc3c:	f6 3b       	jl	$-18     	;abs 0xcc2a

0000cc3e <.Loc.1133.1>:
    cc3e:	0a 9e       	cmp	r14,	r10	;
    cc40:	03 34       	jge	$+8      	;abs 0xcc48

0000cc42 <.L26>:
    cc42:	0f 93       	cmp	#0,	r15	;r3 As==00
    cc44:	e3 23       	jnz	$-56     	;abs 0xcc0c
    cc46:	da 3f       	jmp	$-74     	;abs 0xcbfc

0000cc48 <.L10>:
    cc48:	18 4c 06 00 	mov	6(r12),	r8	;
    cc4c:	1e 4c 08 00 	mov	8(r12),	r14	;
    cc50:	1b 4c 0a 00 	mov	10(r12),r11	;0x0000a
    cc54:	19 4c 0c 00 	mov	12(r12),r9	;0x0000c
    cc58:	17 4d 06 00 	mov	6(r13),	r7	;
    cc5c:	1c 4d 08 00 	mov	8(r13),	r12	;

0000cc60 <.LVL18>:
    cc60:	1a 4d 0a 00 	mov	10(r13),r10	;0x0000a
    cc64:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c

0000cc68 <.LVL19>:
    cc68:	0d 99       	cmp	r9,	r13	;
    cc6a:	df 2b       	jnc	$-64     	;abs 0xcc2a
    cc6c:	09 9d       	cmp	r13,	r9	;
    cc6e:	0a 20       	jnz	$+22     	;abs 0xcc84
    cc70:	0a 9b       	cmp	r11,	r10	;
    cc72:	db 2b       	jnc	$-72     	;abs 0xcc2a
    cc74:	0b 9a       	cmp	r10,	r11	;
    cc76:	06 20       	jnz	$+14     	;abs 0xcc84
    cc78:	0c 9e       	cmp	r14,	r12	;
    cc7a:	d7 2b       	jnc	$-80     	;abs 0xcc2a
    cc7c:	0e 9c       	cmp	r12,	r14	;
    cc7e:	02 20       	jnz	$+6      	;abs 0xcc84
    cc80:	07 98       	cmp	r8,	r7	;
    cc82:	d3 2b       	jnc	$-88     	;abs 0xcc2a

0000cc84 <.L11>:
    cc84:	09 9d       	cmp	r13,	r9	;
    cc86:	dd 2b       	jnc	$-68     	;abs 0xcc42
    cc88:	0d 99       	cmp	r9,	r13	;
    cc8a:	c6 23       	jnz	$-114    	;abs 0xcc18
    cc8c:	0b 9a       	cmp	r10,	r11	;
    cc8e:	d9 2b       	jnc	$-76     	;abs 0xcc42
    cc90:	0a 9b       	cmp	r11,	r10	;
    cc92:	c2 23       	jnz	$-122    	;abs 0xcc18
    cc94:	0e 9c       	cmp	r12,	r14	;
    cc96:	d5 2b       	jnc	$-84     	;abs 0xcc42
    cc98:	0c 9e       	cmp	r14,	r12	;
    cc9a:	be 23       	jnz	$-130    	;abs 0xcc18
    cc9c:	08 97       	cmp	r7,	r8	;
    cc9e:	d1 2b       	jnc	$-92     	;abs 0xcc42
    cca0:	bb 3f       	jmp	$-136    	;abs 0xcc18

0000cca2 <__mspabi_mpyi>:
    cca2:	02 12       	push	r2		;
    cca4:	32 c2       	dint			
    cca6:	03 43       	nop			
    cca8:	82 4c c0 04 	mov	r12,	&0x04c0	;
    ccac:	82 4d c8 04 	Address 0x000000000000ccae is out of bounds.
mov	r13,	&0xffff	;

0000ccae <L0>:
    ccae:	c8 04       	mova	r4,	r8	;
    ccb0:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    ccb4:	00 13       	reti			

0000ccb6 <__mspabi_mpyl>:
    ccb6:	02 12       	push	r2		;
    ccb8:	32 c2       	dint			
    ccba:	03 43       	nop			
    ccbc:	82 4c d0 04 	mov	r12,	&0x04d0	;
    ccc0:	82 4d d2 04 	mov	r13,	&0x04d2	;
    ccc4:	82 4e e0 04 	mov	r14,	&0x04e0	;
    ccc8:	82 4f e2 04 	mov	r15,	&0x04e2	;
    cccc:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    ccd0:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    ccd4:	00 13       	reti			

0000ccd6 <memcpy>:
    ccd6:	0f 4c       	mov	r12,	r15	;
    ccd8:	0e 5c       	add	r12,	r14	;

0000ccda <.L2>:
    ccda:	0f 9e       	cmp	r14,	r15	;
    ccdc:	05 24       	jz	$+12     	;abs 0xcce8

0000ccde <.LVL3>:
    ccde:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    cce2:	1f 53       	inc	r15		;

0000cce4 <.LVL4>:
    cce4:	1d 53       	inc	r13		;
    cce6:	f9 3f       	jmp	$-12     	;abs 0xccda

0000cce8 <.L5>:
    cce8:	30 41       	ret			

0000ccea <sniprintf>:
    ccea:	1a 15       	pushm	#2,	r10	;16-bit words

0000ccec <L0>:
    ccec:	31 80 3c 00 	sub	#60,	r1	;#0x003c

0000ccf0 <.LCFI3>:
    ccf0:	0a 4d       	mov	r13,	r10	;

0000ccf2 <.Loc.95.1>:
    ccf2:	19 42 8e 5a 	mov	&0x5a8e,r9	;0x5a8e

0000ccf6 <.Loc.97.1>:
    ccf6:	0d 93       	cmp	#0,	r13	;r3 As==00
    ccf8:	05 34       	jge	$+12     	;abs 0xcd04

0000ccfa <.Loc.99.1>:
    ccfa:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    ccfe:	00 00 

0000cd00 <.Loc.100.1>:
    cd00:	3c 43       	mov	#-1,	r12	;r3 As==11

0000cd02 <.LVL9>:
    cd02:	24 3c       	jmp	$+74     	;abs 0xcd4c

0000cd04 <.L12>:
    cd04:	b1 40 08 02 	mov	#520,	6(r1)	;#0x0208
    cd08:	06 00 

0000cd0a <.Loc.103.1>:
    cd0a:	81 4c 00 00 	mov	r12,	0(r1)	;
    cd0e:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

0000cd12 <.Loc.104.1>:
    cd12:	0c 4d       	mov	r13,	r12	;

0000cd14 <.LVL11>:
    cd14:	0d 93       	cmp	#0,	r13	;r3 As==00
    cd16:	01 24       	jz	$+4      	;abs 0xcd1a

0000cd18 <.LVL12>:
    cd18:	3c 53       	add	#-1,	r12	;r3 As==11

0000cd1a <.L14>:
    cd1a:	81 4c 04 00 	mov	r12,	4(r1)	;
    cd1e:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

0000cd22 <.Loc.105.1>:
    cd22:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

0000cd26 <.LVL13>:
    cd26:	0f 41       	mov	r1,	r15	;
    cd28:	3f 50 44 00 	add	#68,	r15	;#0x0044
    cd2c:	1e 41 42 00 	mov	66(r1),	r14	;0x00042
    cd30:	0d 41       	mov	r1,	r13	;
    cd32:	0c 49       	mov	r9,	r12	;
    cd34:	b0 12 86 ce 	call	#52870		;#0xce86

0000cd38 <.LVL14>:
    cd38:	3c 93       	cmp	#-1,	r12	;r3 As==11
    cd3a:	03 34       	jge	$+8      	;abs 0xcd42

0000cd3c <.Loc.114.1>:
    cd3c:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    cd40:	00 00 

0000cd42 <.L15>:
    cd42:	0a 93       	cmp	#0,	r10	;r3 As==00
    cd44:	03 24       	jz	$+8      	;abs 0xcd4c

0000cd46 <.Loc.116.1>:
    cd46:	2d 41       	mov	@r1,	r13	;
    cd48:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00

0000cd4c <.L11>:
    cd4c:	31 50 3c 00 	add	#60,	r1	;#0x003c
    cd50:	19 17       	popm	#2,	r10	;16-bit words
    cd52:	30 41       	ret			

0000cd54 <strlen>:
    cd54:	0d 4c       	mov	r12,	r13	;

0000cd56 <L0>:
    cd56:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    cd5a:	02 24       	jz	$+6      	;abs 0xcd60

0000cd5c <.Loc.86.1>:
    cd5c:	1d 53       	inc	r13		;
    cd5e:	fb 3f       	jmp	$-8      	;abs 0xcd56

0000cd60 <.L5>:
    cd60:	0d 8c       	sub	r12,	r13	;

0000cd62 <.LVL4>:
    cd62:	0c 4d       	mov	r13,	r12	;

0000cd64 <.LVL5>:
    cd64:	30 41       	ret			

0000cd66 <__ssprint_r>:
    cd66:	6a 15       	pushm	#7,	r10	;16-bit words

0000cd68 <L0>:
    cd68:	21 82       	sub	#4,	r1	;r2 As==10

0000cd6a <.LCFI1>:
    cd6a:	07 4c       	mov	r12,	r7	;
    cd6c:	04 4d       	mov	r13,	r4	;
    cd6e:	08 4e       	mov	r14,	r8	;

0000cd70 <.LVL1>:
    cd70:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00
    cd74:	2c 24       	jz	$+90     	;abs 0xcdce

0000cd76 <.Loc.280.1>:
    cd76:	26 4e       	mov	@r14,	r6	;
    cd78:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    cd7c:	19 41 02 00 	mov	2(r1),	r9	;
    cd80:	05 3c       	jmp	$+12     	;abs 0xcd8c

0000cd82 <.L5>:
    cd82:	a1 46 02 00 	mov	@r6,	2(r1)	;

0000cd86 <.Loc.291.1>:
    cd86:	19 46 02 00 	mov	2(r6),	r9	;

0000cd8a <.LVL3>:
    cd8a:	26 52       	add	#4,	r6	;r2 As==10

0000cd8c <.L3>:
    cd8c:	09 93       	cmp	#0,	r9	;r3 As==00
    cd8e:	f9 27       	jz	$-12     	;abs 0xcd82

0000cd90 <.Loc.294.1>:
    cd90:	1b 44 04 00 	mov	4(r4),	r11	;

0000cd94 <.LVL5>:
    cd94:	09 9b       	cmp	r11,	r9	;
    cd96:	72 28       	jnc	$+230    	;abs 0xce7c

0000cd98 <.Loc.295.1>:
    cd98:	1e 44 06 00 	mov	6(r4),	r14	;
    cd9c:	3e b0 80 04 	bit	#1152,	r14	;#0x0480
    cda0:	1a 20       	jnz	$+54     	;abs 0xcdd6

0000cda2 <.L6>:
    cda2:	09 9b       	cmp	r11,	r9	;
    cda4:	6b 28       	jnc	$+216    	;abs 0xce7c

0000cda6 <.L12>:
    cda6:	0e 4b       	mov	r11,	r14	;
    cda8:	1d 41 02 00 	mov	2(r1),	r13	;
    cdac:	2c 44       	mov	@r4,	r12	;
    cdae:	81 4b 00 00 	mov	r11,	0(r1)	;
    cdb2:	b0 12 3e d8 	call	#55358		;#0xd83e

0000cdb6 <.LVL6>:
    cdb6:	2b 41       	mov	@r1,	r11	;
    cdb8:	84 8b 04 00 	sub	r11,	4(r4)	;

0000cdbc <.Loc.344.1>:
    cdbc:	84 5b 00 00 	add	r11,	0(r4)	;

0000cdc0 <.LVL7>:
    cdc0:	1c 48 04 00 	mov	4(r8),	r12	;
    cdc4:	0c 89       	sub	r9,	r12	;
    cdc6:	88 4c 04 00 	mov	r12,	4(r8)	;
    cdca:	0c 93       	cmp	#0,	r12	;r3 As==00
    cdcc:	da 23       	jnz	$-74     	;abs 0xcd82

0000cdce <.L2>:
    cdce:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

0000cdd2 <.Loc.285.1>:
    cdd2:	4c 43       	clr.b	r12		;
    cdd4:	55 3c       	jmp	$+172    	;abs 0xce80

0000cdd6 <.L21>:
    cdd6:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    cdda:	25 44       	mov	@r4,	r5	;
    cddc:	05 8d       	sub	r13,	r5	;

0000cdde <.LVL10>:
    cdde:	1c 44 0c 00 	mov	12(r4),	r12	;0x0000c
    cde2:	0a 4c       	mov	r12,	r10	;
    cde4:	0a 5c       	add	r12,	r10	;
    cde6:	0a 5c       	add	r12,	r10	;
    cde8:	0c 4a       	mov	r10,	r12	;
    cdea:	5c 03       	rrum	#1,	r12	;
    cdec:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    cdf0:	0a 5c       	add	r12,	r10	;
    cdf2:	0a 11       	rra	r10		;

0000cdf4 <.LVL11>:
    cdf4:	0c 45       	mov	r5,	r12	;
    cdf6:	1c 53       	inc	r12		;
    cdf8:	0c 59       	add	r9,	r12	;
    cdfa:	0a 9c       	cmp	r12,	r10	;
    cdfc:	01 2c       	jc	$+4      	;abs 0xce00

0000cdfe <.Loc.308.1>:
    cdfe:	0a 4c       	mov	r12,	r10	;

0000ce00 <.L7>:
    ce00:	3e b0 00 04 	bit	#1024,	r14	;#0x0400
    ce04:	17 24       	jz	$+48     	;abs 0xce34

0000ce06 <.Loc.312.1>:
    ce06:	0d 4a       	mov	r10,	r13	;
    ce08:	0c 47       	mov	r7,	r12	;
    ce0a:	b0 12 62 d9 	call	#55650		;#0xd962

0000ce0e <.LVL13>:
    ce0e:	0c 93       	cmp	#0,	r12	;r3 As==00
    ce10:	1d 24       	jz	$+60     	;abs 0xce4c

0000ce12 <.Loc.318.1>:
    ce12:	0e 45       	mov	r5,	r14	;
    ce14:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    ce18:	81 4c 00 00 	mov	r12,	0(r1)	;
    ce1c:	b0 12 d6 cc 	call	#52438		;#0xccd6

0000ce20 <.LVL14>:
    ce20:	1c 44 06 00 	mov	6(r4),	r12	;
    ce24:	3c f0 7f fb 	and	#64383,	r12	;#0xfb7f
    ce28:	3c d0 80 00 	bis	#128,	r12	;#0x0080
    ce2c:	84 4c 06 00 	mov	r12,	6(r4)	;
    ce30:	2b 41       	mov	@r1,	r11	;
    ce32:	18 3c       	jmp	$+50     	;abs 0xce64

0000ce34 <.L8>:
    ce34:	0e 4a       	mov	r10,	r14	;
    ce36:	0c 47       	mov	r7,	r12	;
    ce38:	b0 12 4c da 	call	#55884		;#0xda4c

0000ce3c <.LVL16>:
    ce3c:	0b 4c       	mov	r12,	r11	;

0000ce3e <.LVL17>:
    ce3e:	0c 93       	cmp	#0,	r12	;r3 As==00
    ce40:	11 20       	jnz	$+36     	;abs 0xce64

0000ce42 <.Loc.327.1>:
    ce42:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    ce46:	0c 47       	mov	r7,	r12	;
    ce48:	b0 12 78 d8 	call	#55416		;#0xd878

0000ce4c <.L19>:
    ce4c:	b7 40 0c 00 	mov	#12,	0(r7)	;#0x000c
    ce50:	00 00 

0000ce52 <.L10>:
    ce52:	b4 d0 40 00 	bis	#64,	6(r4)	;#0x0040
    ce56:	06 00 

0000ce58 <.Loc.356.1>:
    ce58:	88 43 04 00 	mov	#0,	4(r8)	;r3 As==00

0000ce5c <.Loc.357.1>:
    ce5c:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

0000ce60 <.Loc.358.1>:
    ce60:	3c 43       	mov	#-1,	r12	;r3 As==11
    ce62:	0e 3c       	jmp	$+30     	;abs 0xce80

0000ce64 <.L11>:
    ce64:	84 4b 0a 00 	mov	r11,	10(r4)	; 0x000a

0000ce68 <.Loc.335.1>:
    ce68:	0b 55       	add	r5,	r11	;

0000ce6a <.LVL20>:
    ce6a:	84 4b 00 00 	mov	r11,	0(r4)	;

0000ce6e <.Loc.336.1>:
    ce6e:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

0000ce72 <.LVL21>:
    ce72:	0b 49       	mov	r9,	r11	;

0000ce74 <.Loc.338.1>:
    ce74:	0a 85       	sub	r5,	r10	;

0000ce76 <.LVL22>:
    ce76:	84 4a 04 00 	mov	r10,	4(r4)	;
    ce7a:	93 3f       	jmp	$-216    	;abs 0xcda2

0000ce7c <.L15>:
    ce7c:	0b 49       	mov	r9,	r11	;
    ce7e:	93 3f       	jmp	$-216    	;abs 0xcda6

0000ce80 <.L1>:
    ce80:	21 52       	add	#4,	r1	;r2 As==10
    ce82:	64 17       	popm	#7,	r10	;16-bit words
    ce84:	30 41       	ret			

0000ce86 <_svfiprintf_r>:
    ce86:	6a 15       	pushm	#7,	r10	;16-bit words

0000ce88 <.LCFI2>:
    ce88:	31 80 62 00 	sub	#98,	r1	;#0x0062

0000ce8c <.LCFI3>:
    ce8c:	81 4c 02 00 	mov	r12,	2(r1)	;
    ce90:	0a 4d       	mov	r13,	r10	;

0000ce92 <L0>:
    ce92:	08 4e       	mov	r14,	r8	;
    ce94:	09 4f       	mov	r15,	r9	;

0000ce96 <.LVL26>:
    ce96:	1d 4d 06 00 	mov	6(r13),	r13	;

0000ce9a <.LVL27>:
    ce9a:	7d f0 80 00 	and.b	#128,	r13	;#0x0080
    ce9e:	0d 93       	cmp	#0,	r13	;r3 As==00
    cea0:	19 24       	jz	$+52     	;abs 0xced4

0000cea2 <.Loc.880.1>:
    cea2:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    cea6:	16 20       	jnz	$+46     	;abs 0xced4

0000cea8 <.Loc.882.1>:
    cea8:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    ceac:	b0 12 62 d9 	call	#55650		;#0xd962

0000ceb0 <.LVL28>:
    ceb0:	8a 4c 00 00 	mov	r12,	0(r10)	;
    ceb4:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000ceb8 <.Loc.883.1>:
    ceb8:	0c 93       	cmp	#0,	r12	;r3 As==00
    ceba:	09 20       	jnz	$+20     	;abs 0xcece

0000cebc <.Loc.885.1>:
    cebc:	1c 41 02 00 	mov	2(r1),	r12	;
    cec0:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    cec4:	00 00 

0000cec6 <.Loc.886.1>:
    cec6:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11
    ceca:	30 40 1a d8 	br	#0xd81a		;

0000cece <.L24>:
    cece:	ba 40 40 00 	mov	#64,	12(r10)	;#0x0040, 0x000c
    ced2:	0c 00 

0000ced4 <.L23>:
    ced4:	7d 40 1a 00 	mov.b	#26,	r13	;#0x001a
    ced8:	0d 51       	add	r1,	r13	;
    ceda:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

0000cede <.Loc.895.1>:
    cede:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018

0000cee2 <.Loc.896.1>:
    cee2:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

0000cee6 <.LVL30>:
    cee6:	81 48 04 00 	mov	r8,	4(r1)	;

0000ceea <.Loc.894.1>:
    ceea:	0b 4d       	mov	r13,	r11	;

0000ceec <.Loc.718.1>:
    ceec:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c

0000cef0 <.Loc.898.1>:
    cef0:	91 41 0c 00 	mov	12(r1),	8(r1)	;0x0000c
    cef4:	08 00 

0000cef6 <.L26>:
    cef6:	18 41 04 00 	mov	4(r1),	r8	;

0000cefa <.L27>:
    cefa:	6c 48       	mov.b	@r8,	r12	;
    cefc:	0c 93       	cmp	#0,	r12	;r3 As==00
    cefe:	05 24       	jz	$+12     	;abs 0xcf0a

0000cf00 <.Loc.925.1>:
    cf00:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    cf04:	02 24       	jz	$+6      	;abs 0xcf0a

0000cf06 <.Loc.926.1>:
    cf06:	18 53       	inc	r8		;
    cf08:	f8 3f       	jmp	$-14     	;abs 0xcefa

0000cf0a <.L28>:
    cf0a:	07 48       	mov	r8,	r7	;
    cf0c:	17 81 04 00 	sub	4(r1),	r7	;

0000cf10 <.LVL34>:
    cf10:	07 93       	cmp	#0,	r7	;r3 As==00
    cf12:	23 24       	jz	$+72     	;abs 0xcf5a

0000cf14 <.Loc.929.1>:
    cf14:	9b 41 04 00 	mov	4(r1),	0(r11)	;
    cf18:	00 00 
    cf1a:	8b 47 02 00 	mov	r7,	2(r11)	;
    cf1e:	81 57 18 00 	add	r7,	24(r1)	; 0x0018

0000cf22 <.LVL35>:
    cf22:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    cf26:	1c 53       	inc	r12		;
    cf28:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    cf2c:	7e 40 07 00 	mov.b	#7,	r14	;
    cf30:	0e 9c       	cmp	r12,	r14	;
    cf32:	02 38       	jl	$+6      	;abs 0xcf38
    cf34:	2b 52       	add	#4,	r11	;r2 As==10

0000cf36 <.LVL36>:
    cf36:	0f 3c       	jmp	$+32     	;abs 0xcf56

0000cf38 <.L31>:
    cf38:	0e 41       	mov	r1,	r14	;
    cf3a:	3e 50 14 00 	add	#20,	r14	;#0x0014
    cf3e:	0d 4a       	mov	r10,	r13	;
    cf40:	1c 41 02 00 	mov	2(r1),	r12	;
    cf44:	b0 12 66 cd 	call	#52582		;#0xcd66

0000cf48 <.LVL38>:
    cf48:	0c 93       	cmp	#0,	r12	;r3 As==00
    cf4a:	02 24       	jz	$+6      	;abs 0xcf50
    cf4c:	80 00 0e d8 	mova	#55310,	r0	;0x0d80e

0000cf50 <.Loc.929.1>:
    cf50:	0b 41       	mov	r1,	r11	;
    cf52:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000cf56 <.L32>:
    cf56:	81 57 08 00 	add	r7,	8(r1)	;

0000cf5a <.L30>:
    cf5a:	c8 93 00 00 	cmp.b	#0,	0(r8)	;r3 As==00
    cf5e:	02 20       	jnz	$+6      	;abs 0xcf64
    cf60:	80 00 f8 d7 	mova	#55288,	r0	;0x0d7f8

0000cf64 <.LVL41>:
    cf64:	0c 48       	mov	r8,	r12	;
    cf66:	1c 53       	inc	r12		;

0000cf68 <.LVL42>:
    cf68:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    cf6c:	4d 43       	clr.b	r13		;
    cf6e:	0e 4d       	mov	r13,	r14	;

0000cf70 <.Loc.945.1>:
    cf70:	36 43       	mov	#-1,	r6	;r3 As==11

0000cf72 <.Loc.944.1>:
    cf72:	81 4d 06 00 	mov	r13,	6(r1)	;

0000cf76 <.Loc.942.1>:
    cf76:	05 4d       	mov	r13,	r5	;

0000cf78 <.Loc.959.1>:
    cf78:	58 43       	mov.b	#1,	r8	;r3 As==01

0000cf7a <.L35>:
    cf7a:	04 4c       	mov	r12,	r4	;
    cf7c:	14 53       	inc	r4		;
    cf7e:	81 44 04 00 	mov	r4,	4(r1)	;

0000cf82 <.LVL44>:
    cf82:	6c 4c       	mov.b	@r12,	r12	;

0000cf84 <.L37>:
    cf84:	3c 90 58 00 	cmp	#88,	r12	;#0x0058
    cf88:	92 24       	jz	$+294    	;abs 0xd0ae
    cf8a:	77 40 58 00 	mov.b	#88,	r7	;#0x0058
    cf8e:	07 9c       	cmp	r12,	r7	;
    cf90:	41 38       	jl	$+132    	;abs 0xd014
    cf92:	3c 90 2e 00 	cmp	#46,	r12	;#0x002e
    cf96:	aa 24       	jz	$+342    	;abs 0xd0ec
    cf98:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    cf9c:	0f 9c       	cmp	r12,	r15	;
    cf9e:	1f 38       	jl	$+64     	;abs 0xcfde
    cfa0:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    cfa4:	92 24       	jz	$+294    	;abs 0xd0ca
    cfa6:	74 40 2a 00 	mov.b	#42,	r4	;#0x002a
    cfaa:	04 9c       	cmp	r12,	r4	;
    cfac:	0c 38       	jl	$+26     	;abs 0xcfc6
    cfae:	3c 90 20 00 	cmp	#32,	r12	;#0x0020
    cfb2:	85 24       	jz	$+268    	;abs 0xd0be
    cfb4:	3c 90 23 00 	cmp	#35,	r12	;#0x0023
    cfb8:	02 24       	jz	$+6      	;abs 0xcfbe
    cfba:	80 00 5a d4 	mova	#54362,	r0	;0x0d45a

0000cfbe <.Loc.979.1>:
    cfbe:	15 d3       	bis	#1,	r5	;r3 As==01

0000cfc0 <.L36>:
    cfc0:	1c 41 04 00 	mov	4(r1),	r12	;
    cfc4:	da 3f       	jmp	$-74     	;abs 0xcf7a

0000cfc6 <.L44>:
    cfc6:	3c 90 2b 00 	cmp	#43,	r12	;#0x002b
    cfca:	04 20       	jnz	$+10     	;abs 0xcfd4
    cfcc:	0d 48       	mov	r8,	r13	;

0000cfce <.Loc.1030.1>:
    cfce:	7e 40 2b 00 	mov.b	#43,	r14	;#0x002b
    cfd2:	f6 3f       	jmp	$-18     	;abs 0xcfc0

0000cfd4 <.L234>:
    cfd4:	3c 90 2d 00 	cmp	#45,	r12	;#0x002d
    cfd8:	87 24       	jz	$+272    	;abs 0xd0e8
    cfda:	30 40 5a d4 	br	#0xd45a		;

0000cfde <.L42>:
    cfde:	77 40 39 00 	mov.b	#57,	r7	;#0x0039
    cfe2:	07 9c       	cmp	r12,	r7	;
    cfe4:	0b 38       	jl	$+24     	;abs 0xcffc
    cfe6:	3c 90 31 00 	cmp	#49,	r12	;#0x0031
    cfea:	aa 34       	jge	$+342    	;abs 0xd140
    cfec:	3c 90 30 00 	cmp	#48,	r12	;#0x0030
    cff0:	02 24       	jz	$+6      	;abs 0xcff6
    cff2:	80 00 5a d4 	mova	#54362,	r0	;0x0d45a

0000cff6 <.Loc.1084.1>:
    cff6:	35 d0 80 00 	bis	#128,	r5	;#0x0080

0000cffa <.Loc.1085.1>:
    cffa:	e2 3f       	jmp	$-58     	;abs 0xcfc0

0000cffc <.L48>:
    cffc:	3c 90 4f 00 	cmp	#79,	r12	;#0x004f
    d000:	0e 25       	jz	$+542    	;abs 0xd21e
    d002:	3c 90 55 00 	cmp	#85,	r12	;#0x0055
    d006:	45 25       	jz	$+652    	;abs 0xd292
    d008:	3c 90 44 00 	cmp	#68,	r12	;#0x0044
    d00c:	02 24       	jz	$+6      	;abs 0xd012
    d00e:	80 00 5a d4 	mova	#54362,	r0	;0x0d45a
    d012:	c7 3c       	jmp	$+400    	;abs 0xd1a2

0000d014 <.L40>:
    d014:	3c 90 6e 00 	cmp	#110,	r12	;#0x006e
    d018:	e8 24       	jz	$+466    	;abs 0xd1ea
    d01a:	7f 40 6e 00 	mov.b	#110,	r15	;#0x006e
    d01e:	0f 9c       	cmp	r12,	r15	;
    d020:	17 38       	jl	$+48     	;abs 0xd050
    d022:	3c 90 68 00 	cmp	#104,	r12	;#0x0068
    d026:	a9 24       	jz	$+340    	;abs 0xd17a
    d028:	74 40 68 00 	mov.b	#104,	r4	;#0x0068
    d02c:	04 9c       	cmp	r12,	r4	;
    d02e:	08 38       	jl	$+18     	;abs 0xd040
    d030:	3c 90 63 00 	cmp	#99,	r12	;#0x0063
    d034:	a8 24       	jz	$+338    	;abs 0xd186
    d036:	3c 90 64 00 	cmp	#100,	r12	;#0x0064
    d03a:	34 24       	jz	$+106    	;abs 0xd0a4
    d03c:	30 40 5a d4 	br	#0xd45a		;

0000d040 <.L57>:
    d040:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    d044:	2f 24       	jz	$+96     	;abs 0xd0a4
    d046:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    d04a:	9a 24       	jz	$+310    	;abs 0xd180
    d04c:	30 40 5a d4 	br	#0xd45a		;

0000d050 <.L55>:
    d050:	3c 90 71 00 	cmp	#113,	r12	;#0x0071
    d054:	95 24       	jz	$+300    	;abs 0xd180
    d056:	77 40 71 00 	mov.b	#113,	r7	;#0x0071
    d05a:	07 9c       	cmp	r12,	r7	;
    d05c:	19 38       	jl	$+52     	;abs 0xd090
    d05e:	3c 90 6f 00 	cmp	#111,	r12	;#0x006f
    d062:	df 24       	jz	$+448    	;abs 0xd222
    d064:	3c 90 70 00 	cmp	#112,	r12	;#0x0070
    d068:	02 24       	jz	$+6      	;abs 0xd06e
    d06a:	80 00 5a d4 	mova	#54362,	r0	;0x0d45a

0000d06e <.Loc.1428.1>:
    d06e:	07 49       	mov	r9,	r7	;
    d070:	27 53       	incd	r7		;

0000d072 <.LVL49>:
    d072:	29 49       	mov	@r9,	r9	;
    d074:	08 49       	mov	r9,	r8	;
    d076:	09 43       	clr	r9		;

0000d078 <.LVL50>:
    d078:	25 d3       	bis	#2,	r5	;r3 As==10

0000d07a <.Loc.1432.1>:
    d07a:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    d07e:	12 00 

0000d080 <.LVL52>:
    d080:	f1 40 78 00 	mov.b	#120,	19(r1)	;#0x0078, 0x0013
    d084:	13 00 

0000d086 <.Loc.1430.1>:
    d086:	b1 40 7f 51 	mov	#20863,	12(r1)	;#0x517f, 0x000c
    d08a:	0c 00 

0000d08c <.Loc.1429.1>:
    d08c:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000d08e <.Loc.1434.1>:
    d08e:	3a 3d       	jmp	$+630    	;abs 0xd304

0000d090 <.L62>:
    d090:	3c 90 75 00 	cmp	#117,	r12	;#0x0075
    d094:	00 25       	jz	$+514    	;abs 0xd296
    d096:	3c 90 78 00 	cmp	#120,	r12	;#0x0078
    d09a:	0f 25       	jz	$+544    	;abs 0xd2ba
    d09c:	3c 90 73 00 	cmp	#115,	r12	;#0x0073
    d0a0:	dc 21       	jnz	$+954    	;abs 0xd45a
    d0a2:	d9 3c       	jmp	$+436    	;abs 0xd256

0000d0a4 <.L59>:
    d0a4:	0d 93       	cmp	#0,	r13	;r3 As==00
    d0a6:	83 24       	jz	$+264    	;abs 0xd1ae
    d0a8:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011
    d0ac:	80 3c       	jmp	$+258    	;abs 0xd1ae

0000d0ae <.L39>:
    d0ae:	0d 93       	cmp	#0,	r13	;r3 As==00
    d0b0:	02 24       	jz	$+6      	;abs 0xd0b6
    d0b2:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000d0b6 <.L70>:
    d0b6:	b1 40 6e 51 	mov	#20846,	12(r1)	;#0x516e, 0x000c
    d0ba:	0c 00 

0000d0bc <.LVL54>:
    d0bc:	05 3d       	jmp	$+524    	;abs 0xd2c8

0000d0be <.L45>:
    d0be:	0e 93       	cmp	#0,	r14	;r3 As==00
    d0c0:	7f 23       	jnz	$-256    	;abs 0xcfc0
    d0c2:	0d 48       	mov	r8,	r13	;

0000d0c4 <.Loc.976.1>:
    d0c4:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    d0c8:	7b 3f       	jmp	$-264    	;abs 0xcfc0

0000d0ca <.L43>:
    d0ca:	0f 49       	mov	r9,	r15	;
    d0cc:	1f 53       	inc	r15		;
    d0ce:	1f c3       	bic	#1,	r15	;r3 As==01
    d0d0:	09 4f       	mov	r15,	r9	;

0000d0d2 <.LVL56>:
    d0d2:	29 53       	incd	r9		;

0000d0d4 <.LVL57>:
    d0d4:	a1 4f 06 00 	mov	@r15,	6(r1)	;

0000d0d8 <.LVL58>:
    d0d8:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    d0dc:	71 37       	jge	$-284    	;abs 0xcfc0

0000d0de <.Loc.1024.1>:
    d0de:	44 43       	clr.b	r4		;
    d0e0:	14 81 06 00 	sub	6(r1),	r4	;
    d0e4:	81 44 06 00 	mov	r4,	6(r1)	;

0000d0e8 <.L47>:
    d0e8:	25 d2       	bis	#4,	r5	;r2 As==10

0000d0ea <.Loc.1028.1>:
    d0ea:	6a 3f       	jmp	$-298    	;abs 0xcfc0

0000d0ec <.L41>:
    d0ec:	1f 41 04 00 	mov	4(r1),	r15	;
    d0f0:	1f 53       	inc	r15		;

0000d0f2 <.LVL61>:
    d0f2:	17 41 04 00 	mov	4(r1),	r7	;
    d0f6:	6c 47       	mov.b	@r7,	r12	;
    d0f8:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    d0fc:	02 24       	jz	$+6      	;abs 0xd102
    d0fe:	46 43       	clr.b	r6		;

0000d100 <.LVL63>:
    d100:	0c 3c       	jmp	$+26     	;abs 0xd11a

0000d102 <.L72>:
    d102:	19 53       	inc	r9		;

0000d104 <.LVL65>:
    d104:	0c 49       	mov	r9,	r12	;

0000d106 <.LVL66>:
    d106:	1c c3       	bic	#1,	r12	;r3 As==01
    d108:	09 4c       	mov	r12,	r9	;

0000d10a <.LVL67>:
    d10a:	29 53       	incd	r9		;

0000d10c <.LVL68>:
    d10c:	26 4c       	mov	@r12,	r6	;
    d10e:	06 93       	cmp	#0,	r6	;r3 As==00
    d110:	01 34       	jge	$+4      	;abs 0xd114
    d112:	36 43       	mov	#-1,	r6	;r3 As==11

0000d114 <.L74>:
    d114:	81 4f 04 00 	mov	r15,	4(r1)	;
    d118:	53 3f       	jmp	$-344    	;abs 0xcfc0

0000d11a <.L73>:
    d11a:	81 4f 04 00 	mov	r15,	4(r1)	;

0000d11e <.LVL70>:
    d11e:	07 4c       	mov	r12,	r7	;
    d120:	37 50 d0 ff 	add	#65488,	r7	;#0xffd0
    d124:	74 40 09 00 	mov.b	#9,	r4	;
    d128:	04 97       	cmp	r7,	r4	;
    d12a:	2c 2b       	jnc	$-422    	;abs 0xcf84

0000d12c <.LVL71>:
    d12c:	0c 46       	mov	r6,	r12	;

0000d12e <.LVL72>:
    d12e:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    d132:	0c 56       	add	r6,	r12	;
    d134:	0c 5c       	rla	r12		;
    d136:	06 47       	mov	r7,	r6	;

0000d138 <.LVL73>:
    d138:	06 5c       	add	r12,	r6	;

0000d13a <.LVL74>:
    d13a:	6c 4f       	mov.b	@r15,	r12	;

0000d13c <.LVL75>:
    d13c:	1f 53       	inc	r15		;

0000d13e <.LVL76>:
    d13e:	ed 3f       	jmp	$-36     	;abs 0xd11a

0000d140 <.L49>:
    d140:	17 41 04 00 	mov	4(r1),	r7	;

0000d144 <.Loc.959.1>:
    d144:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

0000d148 <.L77>:
    d148:	1f 41 06 00 	mov	6(r1),	r15	;
    d14c:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    d150:	1f 51 06 00 	add	6(r1),	r15	;
    d154:	0f 5f       	rla	r15		;
    d156:	3c 50 d0 ff 	add	#65488,	r12	;#0xffd0

0000d15a <.LVL79>:
    d15a:	0c 5f       	add	r15,	r12	;

0000d15c <.LVL80>:
    d15c:	81 4c 06 00 	mov	r12,	6(r1)	;

0000d160 <.LVL81>:
    d160:	91 53 04 00 	inc	4(r1)		;

0000d164 <.Loc.1091.1>:
    d164:	6c 47       	mov.b	@r7,	r12	;

0000d166 <.LVL83>:
    d166:	17 41 04 00 	mov	4(r1),	r7	;

0000d16a <.Loc.1092.1>:
    d16a:	0f 4c       	mov	r12,	r15	;
    d16c:	3f 50 d0 ff 	add	#65488,	r15	;#0xffd0
    d170:	74 40 09 00 	mov.b	#9,	r4	;
    d174:	04 9f       	cmp	r15,	r4	;
    d176:	e8 2f       	jc	$-46     	;abs 0xd148
    d178:	05 3f       	jmp	$-500    	;abs 0xcf84

0000d17a <.L56>:
    d17a:	35 d0 40 00 	bis	#64,	r5	;#0x0040

0000d17e <.Loc.1119.1>:
    d17e:	20 3f       	jmp	$-446    	;abs 0xcfc0

0000d180 <.L61>:
    d180:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000d184 <.Loc.1131.1>:
    d184:	1d 3f       	jmp	$-452    	;abs 0xcfc0

0000d186 <.L58>:
    d186:	19 53       	inc	r9		;

0000d188 <.LVL88>:
    d188:	19 c3       	bic	#1,	r9	;r3 As==01

0000d18a <.LVL89>:
    d18a:	07 49       	mov	r9,	r7	;
    d18c:	27 53       	incd	r7		;

0000d18e <.LVL90>:
    d18e:	e1 49 3a 00 	mov.b	@r9,	58(r1)	; 0x003a

0000d192 <.LVL91>:
    d192:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

0000d196 <.Loc.1190.1>:
    d196:	56 43       	mov.b	#1,	r6	;r3 As==01

0000d198 <.LVL92>:
    d198:	49 43       	clr.b	r9		;

0000d19a <.Loc.1173.1>:
    d19a:	04 41       	mov	r1,	r4	;
    d19c:	34 50 3a 00 	add	#58,	r4	;#0x003a

0000d1a0 <.Loc.1193.1>:
    d1a0:	6e 3d       	jmp	$+734    	;abs 0xd47e

0000d1a2 <.L235>:
    d1a2:	0d 93       	cmp	#0,	r13	;r3 As==00
    d1a4:	02 24       	jz	$+6      	;abs 0xd1aa
    d1a6:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000d1aa <.L79>:
    d1aa:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000d1ae <.L69>:
    d1ae:	19 53       	inc	r9		;

0000d1b0 <.LVL95>:
    d1b0:	19 c3       	bic	#1,	r9	;r3 As==01

0000d1b2 <.LVL96>:
    d1b2:	07 49       	mov	r9,	r7	;
    d1b4:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    d1b8:	05 24       	jz	$+12     	;abs 0xd1c4
    d1ba:	27 52       	add	#4,	r7	;r2 As==10

0000d1bc <.LVL97>:
    d1bc:	28 49       	mov	@r9,	r8	;
    d1be:	19 49 02 00 	mov	2(r9),	r9	;
    d1c2:	06 3c       	jmp	$+14     	;abs 0xd1d0

0000d1c4 <.L80>:
    d1c4:	27 53       	incd	r7		;

0000d1c6 <.LVL99>:
    d1c6:	28 49       	mov	@r9,	r8	;
    d1c8:	38 b0 00 80 	bit	#32768,	r8	;#0x8000
    d1cc:	09 79       	subc	r9,	r9	;
    d1ce:	39 e3       	inv	r9		;

0000d1d0 <.L81>:
    d1d0:	09 93       	cmp	#0,	r9	;r3 As==00
    d1d2:	9b 34       	jge	$+312    	;abs 0xd30a

0000d1d4 <.Loc.1207.1>:
    d1d4:	4c 43       	clr.b	r12		;

0000d1d6 <.LVL101>:
    d1d6:	4d 43       	clr.b	r13		;
    d1d8:	0c 88       	sub	r8,	r12	;
    d1da:	0d 79       	subc	r9,	r13	;
    d1dc:	08 4c       	mov	r12,	r8	;

0000d1de <.LVL102>:
    d1de:	09 4d       	mov	r13,	r9	;

0000d1e0 <.LVL103>:
    d1e0:	f1 40 2d 00 	mov.b	#45,	17(r1)	;#0x002d, 0x0011
    d1e4:	11 00 

0000d1e6 <.Loc.1210.1>:
    d1e6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d1e8:	91 3c       	jmp	$+292    	;abs 0xd30c

0000d1ea <.L54>:
    d1ea:	0d 93       	cmp	#0,	r13	;r3 As==00
    d1ec:	02 24       	jz	$+6      	;abs 0xd1f2
    d1ee:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000d1f2 <.L86>:
    d1f2:	0c 49       	mov	r9,	r12	;

0000d1f4 <.LVL105>:
    d1f4:	2c 53       	incd	r12		;

0000d1f6 <.Loc.1399.1>:
    d1f6:	2d 49       	mov	@r9,	r13	;

0000d1f8 <.Loc.1398.1>:
    d1f8:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    d1fc:	0b 24       	jz	$+24     	;abs 0xd214

0000d1fe <.LVL106>:
    d1fe:	1f 41 08 00 	mov	8(r1),	r15	;
    d202:	0e 4f       	mov	r15,	r14	;
    d204:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    d208:	8d 4e 00 00 	mov	r14,	0(r13)	;
    d20c:	8d 4f 02 00 	mov	r15,	2(r13)	;
    d210:	09 4c       	mov	r12,	r9	;
    d212:	71 3e       	jmp	$-796    	;abs 0xcef6

0000d214 <.L87>:
    d214:	9d 41 08 00 	mov	8(r1),	0(r13)	;
    d218:	00 00 

0000d21a <.LVL108>:
    d21a:	09 4c       	mov	r12,	r9	;
    d21c:	6c 3e       	jmp	$-806    	;abs 0xcef6

0000d21e <.L51>:
    d21e:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000d222 <.L63>:
    d222:	0d 45       	mov	r5,	r13	;
    d224:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    d228:	19 53       	inc	r9		;

0000d22a <.LVL111>:
    d22a:	0d 93       	cmp	#0,	r13	;r3 As==00
    d22c:	08 24       	jz	$+18     	;abs 0xd23e
    d22e:	19 c3       	bic	#1,	r9	;r3 As==01

0000d230 <.LVL112>:
    d230:	07 49       	mov	r9,	r7	;
    d232:	27 52       	add	#4,	r7	;r2 As==10

0000d234 <.LVL113>:
    d234:	28 49       	mov	@r9,	r8	;
    d236:	19 49 02 00 	mov	2(r9),	r9	;

0000d23a <.L233>:
    d23a:	4c 43       	clr.b	r12		;
    d23c:	63 3c       	jmp	$+200    	;abs 0xd304

0000d23e <.L90>:
    d23e:	0c 45       	mov	r5,	r12	;

0000d240 <.LVL116>:
    d240:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    d244:	19 c3       	bic	#1,	r9	;r3 As==01

0000d246 <.LVL117>:
    d246:	07 49       	mov	r9,	r7	;
    d248:	27 53       	incd	r7		;

0000d24a <.LVL118>:
    d24a:	29 49       	mov	@r9,	r9	;
    d24c:	08 49       	mov	r9,	r8	;
    d24e:	09 43       	clr	r9		;
    d250:	0c 93       	cmp	#0,	r12	;r3 As==00
    d252:	58 24       	jz	$+178    	;abs 0xd304
    d254:	f2 3f       	jmp	$-26     	;abs 0xd23a

0000d256 <.L236>:
    d256:	07 49       	mov	r9,	r7	;
    d258:	27 53       	incd	r7		;

0000d25a <.LVL120>:
    d25a:	24 49       	mov	@r9,	r4	;

0000d25c <.Loc.1443.1>:
    d25c:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

0000d260 <.Loc.1518.1>:
    d260:	36 93       	cmp	#-1,	r6	;r3 As==11
    d262:	0e 24       	jz	$+30     	;abs 0xd280

0000d264 <.LBB4>:
    d264:	0e 46       	mov	r6,	r14	;
    d266:	4d 43       	clr.b	r13		;
    d268:	0c 44       	mov	r4,	r12	;

0000d26a <.LVL121>:
    d26a:	81 4b 00 00 	mov	r11,	0(r1)	;
    d26e:	b0 12 26 d8 	call	#55334		;#0xd826

0000d272 <.LVL122>:
    d272:	2b 41       	mov	@r1,	r11	;
    d274:	0c 93       	cmp	#0,	r12	;r3 As==00
    d276:	02 25       	jz	$+518    	;abs 0xd47c

0000d278 <.Loc.1527.1>:
    d278:	06 4c       	mov	r12,	r6	;
    d27a:	06 84       	sub	r4,	r6	;

0000d27c <.LBE4>:
    d27c:	49 43       	clr.b	r9		;

0000d27e <.LBB5>:
    d27e:	ff 3c       	jmp	$+512    	;abs 0xd47e

0000d280 <.L93>:
    d280:	0c 44       	mov	r4,	r12	;

0000d282 <.LVL125>:
    d282:	81 4b 00 00 	mov	r11,	0(r1)	;
    d286:	b0 12 54 cd 	call	#52564		;#0xcd54

0000d28a <.LVL126>:
    d28a:	06 4c       	mov	r12,	r6	;

0000d28c <.LVL127>:
    d28c:	49 43       	clr.b	r9		;
    d28e:	2b 41       	mov	@r1,	r11	;
    d290:	f6 3c       	jmp	$+494    	;abs 0xd47e

0000d292 <.L52>:
    d292:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000d296 <.L65>:
    d296:	19 53       	inc	r9		;

0000d298 <.LVL130>:
    d298:	19 c3       	bic	#1,	r9	;r3 As==01

0000d29a <.LVL131>:
    d29a:	07 49       	mov	r9,	r7	;
    d29c:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    d2a0:	06 24       	jz	$+14     	;abs 0xd2ae
    d2a2:	27 52       	add	#4,	r7	;r2 As==10

0000d2a4 <.LVL132>:
    d2a4:	28 49       	mov	@r9,	r8	;
    d2a6:	19 49 02 00 	mov	2(r9),	r9	;

0000d2aa <.Loc.1539.1>:
    d2aa:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000d2ac <.LVL133>:
    d2ac:	2b 3c       	jmp	$+88     	;abs 0xd304

0000d2ae <.L94>:
    d2ae:	27 53       	incd	r7		;

0000d2b0 <.LVL135>:
    d2b0:	29 49       	mov	@r9,	r9	;

0000d2b2 <.LVL136>:
    d2b2:	08 49       	mov	r9,	r8	;
    d2b4:	09 43       	clr	r9		;

0000d2b6 <.Loc.1539.1>:
    d2b6:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000d2b8 <.LVL137>:
    d2b8:	25 3c       	jmp	$+76     	;abs 0xd304

0000d2ba <.L66>:
    d2ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    d2bc:	02 24       	jz	$+6      	;abs 0xd2c2
    d2be:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000d2c2 <.L96>:
    d2c2:	b1 40 7f 51 	mov	#20863,	12(r1)	;#0x517f, 0x000c
    d2c6:	0c 00 

0000d2c8 <.L71>:
    d2c8:	19 53       	inc	r9		;

0000d2ca <.LVL140>:
    d2ca:	19 c3       	bic	#1,	r9	;r3 As==01

0000d2cc <.LVL141>:
    d2cc:	07 49       	mov	r9,	r7	;
    d2ce:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    d2d2:	05 24       	jz	$+12     	;abs 0xd2de
    d2d4:	27 52       	add	#4,	r7	;r2 As==10

0000d2d6 <.LVL142>:
    d2d6:	28 49       	mov	@r9,	r8	;
    d2d8:	19 49 02 00 	mov	2(r9),	r9	;
    d2dc:	04 3c       	jmp	$+10     	;abs 0xd2e6

0000d2de <.L97>:
    d2de:	27 53       	incd	r7		;

0000d2e0 <.LVL144>:
    d2e0:	29 49       	mov	@r9,	r9	;

0000d2e2 <.LVL145>:
    d2e2:	08 49       	mov	r9,	r8	;
    d2e4:	09 43       	clr	r9		;

0000d2e6 <.L98>:
    d2e6:	15 b3       	bit	#1,	r5	;r3 As==01
    d2e8:	0c 24       	jz	$+26     	;abs 0xd302

0000d2ea <.Loc.1549.1>:
    d2ea:	0d 48       	mov	r8,	r13	;
    d2ec:	0d d9       	bis	r9,	r13	;
    d2ee:	0d 93       	cmp	#0,	r13	;r3 As==00
    d2f0:	08 24       	jz	$+18     	;abs 0xd302

0000d2f2 <.Loc.1550.1>:
    d2f2:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    d2f6:	12 00 

0000d2f8 <.Loc.1551.1>:
    d2f8:	c1 4c 13 00 	mov.b	r12,	19(r1)	; 0x0013

0000d2fc <.Loc.1552.1>:
    d2fc:	25 d3       	bis	#2,	r5	;r3 As==10

0000d2fe <.Loc.1547.1>:
    d2fe:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000d300 <.LVL148>:
    d300:	01 3c       	jmp	$+4      	;abs 0xd304

0000d302 <.L157>:
    d302:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000d304 <.L91>:
    d304:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    d308:	01 3c       	jmp	$+4      	;abs 0xd30c

0000d30a <.L154>:
    d30a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000d30c <.L84>:
    d30c:	36 93       	cmp	#-1,	r6	;r3 As==11
    d30e:	0c 24       	jz	$+26     	;abs 0xd328

0000d310 <.Loc.1566.1>:
    d310:	04 45       	mov	r5,	r4	;
    d312:	34 f0 7f ff 	and	#65407,	r4	;#0xff7f
    d316:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

0000d31a <.LVL153>:
    d31a:	0d 48       	mov	r8,	r13	;
    d31c:	0d d9       	bis	r9,	r13	;
    d31e:	0d 93       	cmp	#0,	r13	;r3 As==00
    d320:	09 20       	jnz	$+20     	;abs 0xd334

0000d322 <.Loc.1574.1>:
    d322:	06 93       	cmp	#0,	r6	;r3 As==00
    d324:	84 24       	jz	$+266    	;abs 0xd42e
    d326:	0b 3c       	jmp	$+24     	;abs 0xd33e

0000d328 <.L101>:
    d328:	0d 48       	mov	r8,	r13	;
    d32a:	0d d9       	bis	r9,	r13	;
    d32c:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a
    d330:	0d 93       	cmp	#0,	r13	;r3 As==00
    d332:	05 24       	jz	$+12     	;abs 0xd33e

0000d334 <.L102>:
    d334:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    d336:	32 24       	jz	$+102    	;abs 0xd39c
    d338:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    d33a:	61 24       	jz	$+196    	;abs 0xd3fe
    d33c:	06 3c       	jmp	$+14     	;abs 0xd34a

0000d33e <.L103>:
    d33e:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    d340:	33 24       	jz	$+104    	;abs 0xd3a8
    d342:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    d344:	5a 24       	jz	$+182    	;abs 0xd3fa
    d346:	48 43       	clr.b	r8		;

0000d348 <.LVL156>:
    d348:	49 43       	clr.b	r9		;

0000d34a <.L105>:
    d34a:	05 41       	mov	r1,	r5	;
    d34c:	35 50 62 00 	add	#98,	r5	;#0x0062

0000d350 <.L108>:
    d350:	04 45       	mov	r5,	r4	;
    d352:	34 53       	add	#-1,	r4	;r3 As==11

0000d354 <.LVL158>:
    d354:	4c 48       	mov.b	r8,	r12	;
    d356:	7c f0 07 00 	and.b	#7,	r12	;
    d35a:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    d35e:	4e 4c       	mov.b	r12,	r14	;
    d360:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    d364:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000d368 <.Loc.1584.1>:
    d368:	0c 48       	mov	r8,	r12	;
    d36a:	0d 49       	mov	r9,	r13	;
    d36c:	81 4b 00 00 	mov	r11,	0(r1)	;
    d370:	b0 12 94 c3 	call	#50068		;#0xc394

0000d374 <.LVL159>:
    d374:	08 4c       	mov	r12,	r8	;

0000d376 <.LVL160>:
    d376:	09 4d       	mov	r13,	r9	;

0000d378 <.LVL161>:
    d378:	0c dd       	bis	r13,	r12	;
    d37a:	2b 41       	mov	@r1,	r11	;

0000d37c <.LVL162>:
    d37c:	0c 93       	cmp	#0,	r12	;r3 As==00
    d37e:	02 24       	jz	$+6      	;abs 0xd384
    d380:	05 44       	mov	r4,	r5	;
    d382:	e6 3f       	jmp	$-50     	;abs 0xd350

0000d384 <.L237>:
    d384:	91 b3 0a 00 	bit	#1,	10(r1)	;r3 As==01, 0x000a
    d388:	60 24       	jz	$+194    	;abs 0xd44a

0000d38a <.Loc.1587.1>:
    d38a:	b1 90 30 00 	cmp	#48,	14(r1)	;#0x0030, 0x000e
    d38e:	0e 00 
    d390:	5c 24       	jz	$+186    	;abs 0xd44a

0000d392 <.LVL163>:
    d392:	f4 40 30 00 	mov.b	#48,	-1(r4)	;#0x0030, 0xffff
    d396:	ff ff 
    d398:	34 53       	add	#-1,	r4	;r3 As==11
    d39a:	57 3c       	jmp	$+176    	;abs 0xd44a

0000d39c <.L106>:
    d39c:	09 93       	cmp	#0,	r9	;r3 As==00
    d39e:	0d 20       	jnz	$+28     	;abs 0xd3ba
    d3a0:	7f 40 09 00 	mov.b	#9,	r15	;
    d3a4:	0f 98       	cmp	r8,	r15	;
    d3a6:	09 28       	jnc	$+20     	;abs 0xd3ba

0000d3a8 <.L112>:
    d3a8:	4c 48       	mov.b	r8,	r12	;

0000d3aa <.LVL166>:
    d3aa:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    d3ae:	c1 4c 61 00 	mov.b	r12,	97(r1)	; 0x0061
    d3b2:	04 41       	mov	r1,	r4	;
    d3b4:	34 50 61 00 	add	#97,	r4	;#0x0061

0000d3b8 <.Loc.1595.1>:
    d3b8:	48 3c       	jmp	$+146    	;abs 0xd44a

0000d3ba <.L110>:
    d3ba:	04 41       	mov	r1,	r4	;
    d3bc:	34 50 62 00 	add	#98,	r4	;#0x0062

0000d3c0 <.Loc.1601.1>:
    d3c0:	35 40 0c c2 	mov	#49676,	r5	;#0xc20c

0000d3c4 <.L113>:
    d3c4:	34 53       	add	#-1,	r4	;r3 As==11
    d3c6:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    d3ca:	4f 43       	clr.b	r15		;
    d3cc:	0c 48       	mov	r8,	r12	;
    d3ce:	0d 49       	mov	r9,	r13	;
    d3d0:	81 4b 00 00 	mov	r11,	0(r1)	;
    d3d4:	85 12       	call	r5		;
    d3d6:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    d3da:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000d3de <.Loc.1622.1>:
    d3de:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    d3e2:	4f 43       	clr.b	r15		;
    d3e4:	0c 48       	mov	r8,	r12	;
    d3e6:	0d 49       	mov	r9,	r13	;
    d3e8:	b0 12 fe c1 	call	#49662		;#0xc1fe
    d3ec:	08 4c       	mov	r12,	r8	;

0000d3ee <.LVL172>:
    d3ee:	09 4d       	mov	r13,	r9	;

0000d3f0 <.LVL173>:
    d3f0:	0c dd       	bis	r13,	r12	;
    d3f2:	2b 41       	mov	@r1,	r11	;
    d3f4:	0c 93       	cmp	#0,	r12	;r3 As==00
    d3f6:	e6 23       	jnz	$-50     	;abs 0xd3c4
    d3f8:	28 3c       	jmp	$+82     	;abs 0xd44a

0000d3fa <.L162>:
    d3fa:	48 43       	clr.b	r8		;

0000d3fc <.LVL175>:
    d3fc:	49 43       	clr.b	r9		;

0000d3fe <.L107>:
    d3fe:	04 41       	mov	r1,	r4	;
    d400:	34 50 62 00 	add	#98,	r4	;#0x0062

0000d404 <.L114>:
    d404:	34 53       	add	#-1,	r4	;r3 As==11
    d406:	0c 48       	mov	r8,	r12	;
    d408:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    d40c:	1c 51 0c 00 	add	12(r1),	r12	;0x0000c
    d410:	e4 4c 00 00 	mov.b	@r12,	0(r4)	;

0000d414 <.Loc.1629.1>:
    d414:	0c 48       	mov	r8,	r12	;
    d416:	0d 49       	mov	r9,	r13	;
    d418:	81 4b 00 00 	mov	r11,	0(r1)	;
    d41c:	b0 12 8e c3 	call	#50062		;#0xc38e

0000d420 <.LVL178>:
    d420:	08 4c       	mov	r12,	r8	;

0000d422 <.LVL179>:
    d422:	09 4d       	mov	r13,	r9	;

0000d424 <.LVL180>:
    d424:	0c dd       	bis	r13,	r12	;
    d426:	2b 41       	mov	@r1,	r11	;

0000d428 <.LVL181>:
    d428:	0c 93       	cmp	#0,	r12	;r3 As==00
    d42a:	ec 23       	jnz	$-38     	;abs 0xd404
    d42c:	0e 3c       	jmp	$+30     	;abs 0xd44a

0000d42e <.L231>:
    d42e:	0c 93       	cmp	#0,	r12	;r3 As==00
    d430:	09 20       	jnz	$+20     	;abs 0xd444

0000d432 <.Loc.1648.1>:
    d432:	15 b3       	bit	#1,	r5	;r3 As==01
    d434:	07 24       	jz	$+16     	;abs 0xd444

0000d436 <.LVL183>:
    d436:	f1 40 30 00 	mov.b	#48,	97(r1)	;#0x0030, 0x0061
    d43a:	61 00 
    d43c:	04 41       	mov	r1,	r4	;

0000d43e <.LVL184>:
    d43e:	34 50 61 00 	add	#97,	r4	;#0x0061
    d442:	03 3c       	jmp	$+8      	;abs 0xd44a

0000d444 <.L160>:
    d444:	04 41       	mov	r1,	r4	;

0000d446 <.LVL186>:
    d446:	34 50 62 00 	add	#98,	r4	;#0x0062

0000d44a <.L109>:
    d44a:	09 46       	mov	r6,	r9	;
    d44c:	76 40 62 00 	mov.b	#98,	r6	;#0x0062

0000d450 <.LVL188>:
    d450:	06 51       	add	r1,	r6	;
    d452:	06 84       	sub	r4,	r6	;
    d454:	15 41 0a 00 	mov	10(r1),	r5	;0x0000a
    d458:	12 3c       	jmp	$+38     	;abs 0xd47e

0000d45a <.L38>:
    d45a:	0d 93       	cmp	#0,	r13	;r3 As==00
    d45c:	02 24       	jz	$+6      	;abs 0xd462
    d45e:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000d462 <.L115>:
    d462:	0c 93       	cmp	#0,	r12	;r3 As==00
    d464:	c9 25       	jz	$+916    	;abs 0xd7f8

0000d466 <.LVL190>:
    d466:	c1 4c 3a 00 	mov.b	r12,	58(r1)	; 0x003a

0000d46a <.LVL191>:
    d46a:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

0000d46e <.Loc.1662.1>:
    d46e:	07 49       	mov	r9,	r7	;

0000d470 <.Loc.1660.1>:
    d470:	56 43       	mov.b	#1,	r6	;r3 As==01

0000d472 <.LVL192>:
    d472:	49 43       	clr.b	r9		;

0000d474 <.LVL193>:
    d474:	04 41       	mov	r1,	r4	;
    d476:	34 50 3a 00 	add	#58,	r4	;#0x003a

0000d47a <.Loc.1662.1>:
    d47a:	01 3c       	jmp	$+4      	;abs 0xd47e

0000d47c <.L155>:
    d47c:	09 4c       	mov	r12,	r9	;

0000d47e <.L78>:
    d47e:	08 49       	mov	r9,	r8	;
    d480:	09 96       	cmp	r6,	r9	;
    d482:	01 34       	jge	$+4      	;abs 0xd486
    d484:	08 46       	mov	r6,	r8	;

0000d486 <.L116>:
    d486:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    d48a:	01 24       	jz	$+4      	;abs 0xd48e

0000d48c <.Loc.1682.1>:
    d48c:	18 53       	inc	r8		;

0000d48e <.L117>:
    d48e:	0f 45       	mov	r5,	r15	;
    d490:	6f f3       	and.b	#2,	r15	;r3 As==10
    d492:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    d496:	0f 93       	cmp	#0,	r15	;r3 As==00
    d498:	01 24       	jz	$+4      	;abs 0xd49c

0000d49a <.Loc.1684.1>:
    d49a:	28 53       	incd	r8		;

0000d49c <.L118>:
    d49c:	0f 45       	mov	r5,	r15	;
    d49e:	7f f0 84 00 	and.b	#132,	r15	;#0x0084
    d4a2:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    d4a6:	0f 93       	cmp	#0,	r15	;r3 As==00
    d4a8:	4a 20       	jnz	$+150    	;abs 0xd53e

0000d4aa <.Loc.1688.1>:
    d4aa:	1f 41 06 00 	mov	6(r1),	r15	;
    d4ae:	0f 88       	sub	r8,	r15	;

0000d4b0 <.LVL199>:
    d4b0:	4c 43       	clr.b	r12		;
    d4b2:	0c 9f       	cmp	r15,	r12	;
    d4b4:	44 34       	jge	$+138    	;abs 0xd53e

0000d4b6 <.L120>:
    d4b6:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d4ba:	1c 53       	inc	r12		;

0000d4bc <.Loc.1688.1>:
    d4bc:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    d4c0:	bb 40 a0 51 	mov	#20896,	0(r11)	;#0x51a0
    d4c4:	00 00 
    d4c6:	0e 9f       	cmp	r15,	r14	;
    d4c8:	21 34       	jge	$+68     	;abs 0xd50c

0000d4ca <.Loc.1688.1>:
    d4ca:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    d4ce:	02 00 
    d4d0:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    d4d4:	18 00 

0000d4d6 <.LVL201>:
    d4d6:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d4da:	7d 40 07 00 	mov.b	#7,	r13	;
    d4de:	0d 9c       	cmp	r12,	r13	;
    d4e0:	02 38       	jl	$+6      	;abs 0xd4e6

0000d4e2 <.Loc.1688.1>:
    d4e2:	2b 52       	add	#4,	r11	;r2 As==10

0000d4e4 <.LVL202>:
    d4e4:	10 3c       	jmp	$+34     	;abs 0xd506

0000d4e6 <.L121>:
    d4e6:	0e 41       	mov	r1,	r14	;
    d4e8:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d4ec:	0d 4a       	mov	r10,	r13	;
    d4ee:	1c 41 02 00 	mov	2(r1),	r12	;
    d4f2:	81 4f 00 00 	mov	r15,	0(r1)	;
    d4f6:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d4fa <.LVL204>:
    d4fa:	2f 41       	mov	@r1,	r15	;
    d4fc:	0c 93       	cmp	#0,	r12	;r3 As==00
    d4fe:	87 21       	jnz	$+784    	;abs 0xd80e

0000d500 <.Loc.1688.1>:
    d500:	0b 41       	mov	r1,	r11	;
    d502:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d506 <.L122>:
    d506:	3f 50 f0 ff 	add	#65520,	r15	;#0xfff0

0000d50a <.LVL206>:
    d50a:	d5 3f       	jmp	$-84     	;abs 0xd4b6

0000d50c <.L238>:
    d50c:	8b 4f 02 00 	mov	r15,	2(r11)	;
    d510:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

0000d514 <.LVL207>:
    d514:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d518:	7f 40 07 00 	mov.b	#7,	r15	;

0000d51c <.LVL208>:
    d51c:	0f 9c       	cmp	r12,	r15	;
    d51e:	02 38       	jl	$+6      	;abs 0xd524

0000d520 <.Loc.1688.1>:
    d520:	2b 52       	add	#4,	r11	;r2 As==10

0000d522 <.LVL209>:
    d522:	0d 3c       	jmp	$+28     	;abs 0xd53e

0000d524 <.L124>:
    d524:	0e 41       	mov	r1,	r14	;
    d526:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d52a:	0d 4a       	mov	r10,	r13	;
    d52c:	1c 41 02 00 	mov	2(r1),	r12	;
    d530:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d534 <.LVL211>:
    d534:	0c 93       	cmp	#0,	r12	;r3 As==00
    d536:	6b 21       	jnz	$+728    	;abs 0xd80e

0000d538 <.Loc.1688.1>:
    d538:	0b 41       	mov	r1,	r11	;
    d53a:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d53e <.L119>:
    d53e:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    d542:	21 24       	jz	$+68     	;abs 0xd586

0000d544 <.Loc.1692.1>:
    d544:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    d548:	0c 51       	add	r1,	r12	;
    d54a:	8b 4c 00 00 	mov	r12,	0(r11)	;
    d54e:	9b 43 02 00 	mov	#1,	2(r11)	;r3 As==01
    d552:	91 53 18 00 	inc	24(r1)		;

0000d556 <.LVL213>:
    d556:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d55a:	1c 53       	inc	r12		;
    d55c:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d560:	7d 40 07 00 	mov.b	#7,	r13	;
    d564:	0d 9c       	cmp	r12,	r13	;
    d566:	02 38       	jl	$+6      	;abs 0xd56c
    d568:	2b 52       	add	#4,	r11	;r2 As==10

0000d56a <.LVL214>:
    d56a:	0d 3c       	jmp	$+28     	;abs 0xd586

0000d56c <.L126>:
    d56c:	0e 41       	mov	r1,	r14	;
    d56e:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d572:	0d 4a       	mov	r10,	r13	;
    d574:	1c 41 02 00 	mov	2(r1),	r12	;
    d578:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d57c <.LVL216>:
    d57c:	0c 93       	cmp	#0,	r12	;r3 As==00
    d57e:	47 21       	jnz	$+656    	;abs 0xd80e

0000d580 <.Loc.1692.1>:
    d580:	0b 41       	mov	r1,	r11	;
    d582:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d586 <.L125>:
    d586:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    d58a:	21 24       	jz	$+68     	;abs 0xd5ce

0000d58c <.Loc.1694.1>:
    d58c:	7e 40 12 00 	mov.b	#18,	r14	;#0x0012
    d590:	0e 51       	add	r1,	r14	;
    d592:	8b 4e 00 00 	mov	r14,	0(r11)	;
    d596:	ab 43 02 00 	mov	#2,	2(r11)	;r3 As==10
    d59a:	a1 53 18 00 	incd	24(r1)		;

0000d59e <.LVL218>:
    d59e:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d5a2:	1c 53       	inc	r12		;
    d5a4:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d5a8:	7f 40 07 00 	mov.b	#7,	r15	;
    d5ac:	0f 9c       	cmp	r12,	r15	;
    d5ae:	02 38       	jl	$+6      	;abs 0xd5b4
    d5b0:	2b 52       	add	#4,	r11	;r2 As==10

0000d5b2 <.LVL219>:
    d5b2:	0d 3c       	jmp	$+28     	;abs 0xd5ce

0000d5b4 <.L128>:
    d5b4:	0e 41       	mov	r1,	r14	;
    d5b6:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d5ba:	0d 4a       	mov	r10,	r13	;
    d5bc:	1c 41 02 00 	mov	2(r1),	r12	;
    d5c0:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d5c4 <.LVL221>:
    d5c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    d5c6:	23 21       	jnz	$+584    	;abs 0xd80e

0000d5c8 <.Loc.1694.1>:
    d5c8:	0b 41       	mov	r1,	r11	;
    d5ca:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d5ce <.L127>:
    d5ce:	b1 90 80 00 	cmp	#128,	14(r1)	;#0x0080, 0x000e
    d5d2:	0e 00 
    d5d4:	4a 20       	jnz	$+150    	;abs 0xd66a

0000d5d6 <.Loc.1698.1>:
    d5d6:	1f 41 06 00 	mov	6(r1),	r15	;
    d5da:	0f 88       	sub	r8,	r15	;

0000d5dc <.LVL223>:
    d5dc:	4c 43       	clr.b	r12		;
    d5de:	0c 9f       	cmp	r15,	r12	;
    d5e0:	44 34       	jge	$+138    	;abs 0xd66a

0000d5e2 <.L130>:
    d5e2:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d5e6:	1c 53       	inc	r12		;

0000d5e8 <.Loc.1698.1>:
    d5e8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    d5ec:	bb 40 90 51 	mov	#20880,	0(r11)	;#0x5190
    d5f0:	00 00 
    d5f2:	0e 9f       	cmp	r15,	r14	;
    d5f4:	21 34       	jge	$+68     	;abs 0xd638

0000d5f6 <.Loc.1698.1>:
    d5f6:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    d5fa:	02 00 
    d5fc:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    d600:	18 00 

0000d602 <.LVL224>:
    d602:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d606:	7d 40 07 00 	mov.b	#7,	r13	;
    d60a:	0d 9c       	cmp	r12,	r13	;
    d60c:	02 38       	jl	$+6      	;abs 0xd612

0000d60e <.Loc.1698.1>:
    d60e:	2b 52       	add	#4,	r11	;r2 As==10

0000d610 <.LVL225>:
    d610:	10 3c       	jmp	$+34     	;abs 0xd632

0000d612 <.L131>:
    d612:	0e 41       	mov	r1,	r14	;
    d614:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d618:	0d 4a       	mov	r10,	r13	;
    d61a:	1c 41 02 00 	mov	2(r1),	r12	;
    d61e:	81 4f 00 00 	mov	r15,	0(r1)	;
    d622:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d626 <.LVL227>:
    d626:	2f 41       	mov	@r1,	r15	;
    d628:	0c 93       	cmp	#0,	r12	;r3 As==00
    d62a:	f1 20       	jnz	$+484    	;abs 0xd80e

0000d62c <.Loc.1698.1>:
    d62c:	0b 41       	mov	r1,	r11	;
    d62e:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d632 <.L132>:
    d632:	3f 50 f0 ff 	add	#65520,	r15	;#0xfff0

0000d636 <.LVL229>:
    d636:	d5 3f       	jmp	$-84     	;abs 0xd5e2

0000d638 <.L239>:
    d638:	8b 4f 02 00 	mov	r15,	2(r11)	;
    d63c:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

0000d640 <.LVL230>:
    d640:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d644:	7f 40 07 00 	mov.b	#7,	r15	;

0000d648 <.LVL231>:
    d648:	0f 9c       	cmp	r12,	r15	;
    d64a:	02 38       	jl	$+6      	;abs 0xd650

0000d64c <.Loc.1698.1>:
    d64c:	2b 52       	add	#4,	r11	;r2 As==10

0000d64e <.LVL232>:
    d64e:	0d 3c       	jmp	$+28     	;abs 0xd66a

0000d650 <.L134>:
    d650:	0e 41       	mov	r1,	r14	;
    d652:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d656:	0d 4a       	mov	r10,	r13	;
    d658:	1c 41 02 00 	mov	2(r1),	r12	;
    d65c:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d660 <.LVL234>:
    d660:	0c 93       	cmp	#0,	r12	;r3 As==00
    d662:	d5 20       	jnz	$+428    	;abs 0xd80e

0000d664 <.Loc.1698.1>:
    d664:	0b 41       	mov	r1,	r11	;
    d666:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d66a <.L129>:
    d66a:	09 86       	sub	r6,	r9	;

0000d66c <.LVL236>:
    d66c:	4c 43       	clr.b	r12		;
    d66e:	0c 99       	cmp	r9,	r12	;
    d670:	41 34       	jge	$+132    	;abs 0xd6f4

0000d672 <.L136>:
    d672:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d676:	1c 53       	inc	r12		;

0000d678 <.Loc.1701.1>:
    d678:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    d67c:	bb 40 90 51 	mov	#20880,	0(r11)	;#0x5190
    d680:	00 00 
    d682:	0e 99       	cmp	r9,	r14	;
    d684:	1e 34       	jge	$+62     	;abs 0xd6c2

0000d686 <.Loc.1701.1>:
    d686:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    d68a:	02 00 
    d68c:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    d690:	18 00 

0000d692 <.LVL237>:
    d692:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d696:	7d 40 07 00 	mov.b	#7,	r13	;
    d69a:	0d 9c       	cmp	r12,	r13	;
    d69c:	02 38       	jl	$+6      	;abs 0xd6a2

0000d69e <.Loc.1701.1>:
    d69e:	2b 52       	add	#4,	r11	;r2 As==10

0000d6a0 <.LVL238>:
    d6a0:	0d 3c       	jmp	$+28     	;abs 0xd6bc

0000d6a2 <.L137>:
    d6a2:	0e 41       	mov	r1,	r14	;
    d6a4:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d6a8:	0d 4a       	mov	r10,	r13	;
    d6aa:	1c 41 02 00 	mov	2(r1),	r12	;
    d6ae:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d6b2 <.LVL240>:
    d6b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    d6b4:	ac 20       	jnz	$+346    	;abs 0xd80e

0000d6b6 <.Loc.1701.1>:
    d6b6:	0b 41       	mov	r1,	r11	;
    d6b8:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d6bc <.L138>:
    d6bc:	39 50 f0 ff 	add	#65520,	r9	;#0xfff0
    d6c0:	d8 3f       	jmp	$-78     	;abs 0xd672

0000d6c2 <.L240>:
    d6c2:	8b 49 02 00 	mov	r9,	2(r11)	;
    d6c6:	81 59 18 00 	add	r9,	24(r1)	; 0x0018

0000d6ca <.LVL243>:
    d6ca:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d6ce:	7f 40 07 00 	mov.b	#7,	r15	;
    d6d2:	0f 9c       	cmp	r12,	r15	;
    d6d4:	02 38       	jl	$+6      	;abs 0xd6da

0000d6d6 <.Loc.1701.1>:
    d6d6:	2b 52       	add	#4,	r11	;r2 As==10

0000d6d8 <.LVL244>:
    d6d8:	0d 3c       	jmp	$+28     	;abs 0xd6f4

0000d6da <.L140>:
    d6da:	0e 41       	mov	r1,	r14	;
    d6dc:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d6e0:	0d 4a       	mov	r10,	r13	;
    d6e2:	1c 41 02 00 	mov	2(r1),	r12	;
    d6e6:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d6ea <.LVL246>:
    d6ea:	0c 93       	cmp	#0,	r12	;r3 As==00
    d6ec:	90 20       	jnz	$+290    	;abs 0xd80e

0000d6ee <.Loc.1701.1>:
    d6ee:	0b 41       	mov	r1,	r11	;
    d6f0:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d6f4 <.L135>:
    d6f4:	8b 44 00 00 	mov	r4,	0(r11)	;
    d6f8:	8b 46 02 00 	mov	r6,	2(r11)	;
    d6fc:	81 56 18 00 	add	r6,	24(r1)	; 0x0018

0000d700 <.LVL248>:
    d700:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d704:	1c 53       	inc	r12		;
    d706:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d70a:	74 40 07 00 	mov.b	#7,	r4	;

0000d70e <.LVL249>:
    d70e:	04 9c       	cmp	r12,	r4	;
    d710:	02 38       	jl	$+6      	;abs 0xd716
    d712:	2b 52       	add	#4,	r11	;r2 As==10

0000d714 <.LVL250>:
    d714:	0d 3c       	jmp	$+28     	;abs 0xd730

0000d716 <.L141>:
    d716:	0e 41       	mov	r1,	r14	;
    d718:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d71c:	0d 4a       	mov	r10,	r13	;
    d71e:	1c 41 02 00 	mov	2(r1),	r12	;
    d722:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d726 <.LVL252>:
    d726:	0c 93       	cmp	#0,	r12	;r3 As==00
    d728:	72 20       	jnz	$+230    	;abs 0xd80e

0000d72a <.Loc.1767.1>:
    d72a:	0b 41       	mov	r1,	r11	;
    d72c:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d730 <.L142>:
    d730:	25 b2       	bit	#4,	r5	;r2 As==10
    d732:	0b 20       	jnz	$+24     	;abs 0xd74a

0000d734 <.L147>:
    d734:	1f 41 06 00 	mov	6(r1),	r15	;
    d738:	0f 98       	cmp	r8,	r15	;
    d73a:	01 34       	jge	$+4      	;abs 0xd73e
    d73c:	0f 48       	mov	r8,	r15	;

0000d73e <.L144>:
    d73e:	81 5f 08 00 	add	r15,	8(r1)	;

0000d742 <.Loc.1776.1>:
    d742:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    d746:	50 24       	jz	$+162    	;abs 0xd7e8
    d748:	45 3c       	jmp	$+140    	;abs 0xd7d4

0000d74a <.L143>:
    d74a:	16 41 06 00 	mov	6(r1),	r6	;

0000d74e <.LVL256>:
    d74e:	06 88       	sub	r8,	r6	;

0000d750 <.LVL257>:
    d750:	4c 43       	clr.b	r12		;
    d752:	0c 96       	cmp	r6,	r12	;
    d754:	ef 37       	jge	$-32     	;abs 0xd734

0000d756 <.Loc.1771.1>:
    d756:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    d75a:	35 40 66 cd 	mov	#52582,	r5	;#0xcd66

0000d75e <.L148>:
    d75e:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    d762:	1c 53       	inc	r12		;
    d764:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    d768:	bb 40 a0 51 	mov	#20896,	0(r11)	;#0x51a0
    d76c:	00 00 
    d76e:	0e 96       	cmp	r6,	r14	;
    d770:	1c 34       	jge	$+58     	;abs 0xd7aa

0000d772 <.Loc.1771.1>:
    d772:	8b 49 02 00 	mov	r9,	2(r11)	;
    d776:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    d77a:	18 00 
    d77c:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d780:	7d 40 07 00 	mov.b	#7,	r13	;
    d784:	0d 9c       	cmp	r12,	r13	;
    d786:	02 38       	jl	$+6      	;abs 0xd78c

0000d788 <.LVL259>:
    d788:	2b 52       	add	#4,	r11	;r2 As==10

0000d78a <.LVL260>:
    d78a:	0c 3c       	jmp	$+26     	;abs 0xd7a4

0000d78c <.L149>:
    d78c:	0e 41       	mov	r1,	r14	;
    d78e:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d792:	0d 4a       	mov	r10,	r13	;
    d794:	1c 41 02 00 	mov	2(r1),	r12	;
    d798:	85 12       	call	r5		;

0000d79a <.LVL262>:
    d79a:	0c 93       	cmp	#0,	r12	;r3 As==00
    d79c:	38 20       	jnz	$+114    	;abs 0xd80e

0000d79e <.LVL263>:
    d79e:	0b 41       	mov	r1,	r11	;
    d7a0:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000d7a4 <.L150>:
    d7a4:	36 50 f0 ff 	add	#65520,	r6	;#0xfff0
    d7a8:	da 3f       	jmp	$-74     	;abs 0xd75e

0000d7aa <.L242>:
    d7aa:	8b 46 02 00 	mov	r6,	2(r11)	;
    d7ae:	81 56 18 00 	add	r6,	24(r1)	; 0x0018
    d7b2:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    d7b6:	7f 40 07 00 	mov.b	#7,	r15	;
    d7ba:	0f 9c       	cmp	r12,	r15	;
    d7bc:	bb 37       	jge	$-136    	;abs 0xd734

0000d7be <.Loc.1771.1>:
    d7be:	0e 41       	mov	r1,	r14	;
    d7c0:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d7c4:	0d 4a       	mov	r10,	r13	;
    d7c6:	1c 41 02 00 	mov	2(r1),	r12	;
    d7ca:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d7ce <.LVL266>:
    d7ce:	0c 93       	cmp	#0,	r12	;r3 As==00
    d7d0:	b1 27       	jz	$-156    	;abs 0xd734
    d7d2:	1d 3c       	jmp	$+60     	;abs 0xd80e

0000d7d4 <.L241>:
    d7d4:	0e 41       	mov	r1,	r14	;
    d7d6:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d7da:	0d 4a       	mov	r10,	r13	;
    d7dc:	1c 41 02 00 	mov	2(r1),	r12	;
    d7e0:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d7e4 <.LVL268>:
    d7e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    d7e6:	13 20       	jnz	$+40     	;abs 0xd80e

0000d7e8 <.L146>:
    d7e8:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

0000d7ec <.LVL269>:
    d7ec:	09 47       	mov	r7,	r9	;
    d7ee:	0b 41       	mov	r1,	r11	;
    d7f0:	3b 50 1a 00 	add	#26,	r11	;#0x001a
    d7f4:	30 40 f6 ce 	br	#0xcef6		;

0000d7f8 <.L34>:
    d7f8:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    d7fc:	08 24       	jz	$+18     	;abs 0xd80e

0000d7fe <.Loc.1784.1>:
    d7fe:	0e 41       	mov	r1,	r14	;
    d800:	3e 50 14 00 	add	#20,	r14	;#0x0014
    d804:	0d 4a       	mov	r10,	r13	;
    d806:	1c 41 02 00 	mov	2(r1),	r12	;
    d80a:	b0 12 66 cd 	call	#52582		;#0xcd66

0000d80e <.L33>:
    d80e:	fa b0 40 00 	bit.b	#64,	6(r10)	;#0x0040
    d812:	06 00 
    d814:	02 24       	jz	$+6      	;abs 0xd81a
    d816:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

0000d81a <.L22>:
    d81a:	1c 41 08 00 	mov	8(r1),	r12	;
    d81e:	31 50 62 00 	add	#98,	r1	;#0x0062

0000d822 <L0>:
    d822:	64 17       	popm	#7,	r10	;16-bit words
    d824:	30 41       	ret			

0000d826 <memchr>:
    d826:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

0000d82a <.LVL2>:
    d82a:	0e 5c       	add	r12,	r14	;

0000d82c <.L2>:
    d82c:	0c 9e       	cmp	r14,	r12	;
    d82e:	05 24       	jz	$+12     	;abs 0xd83a

0000d830 <.Loc.128.1>:
    d830:	cc 9d 00 00 	cmp.b	r13,	0(r12)	;
    d834:	03 24       	jz	$+8      	;abs 0xd83c

0000d836 <.Loc.130.1>:
    d836:	1c 53       	inc	r12		;

0000d838 <.LVL4>:
    d838:	f9 3f       	jmp	$-12     	;abs 0xd82c

0000d83a <.L7>:
    d83a:	4c 43       	clr.b	r12		;

0000d83c <.L1>:
    d83c:	30 41       	ret			

0000d83e <memmove>:
    d83e:	0b 4c       	mov	r12,	r11	;

0000d840 <L0>:
    d840:	0b 5e       	add	r14,	r11	;

0000d842 <.Loc.69.1>:
    d842:	0d 9c       	cmp	r12,	r13	;
    d844:	02 28       	jnc	$+6      	;abs 0xd84a

0000d846 <.L4>:
    d846:	0e 4c       	mov	r12,	r14	;

0000d848 <.LVL2>:
    d848:	0f 3c       	jmp	$+32     	;abs 0xd868

0000d84a <.L2>:
    d84a:	0f 4d       	mov	r13,	r15	;
    d84c:	0f 5e       	add	r14,	r15	;
    d84e:	0c 9f       	cmp	r15,	r12	;
    d850:	fa 2f       	jc	$-10     	;abs 0xd846

0000d852 <.LVL4>:
    d852:	0d 4f       	mov	r15,	r13	;

0000d854 <.LVL5>:
    d854:	0e 8f       	sub	r15,	r14	;

0000d856 <.L5>:
    d856:	0f 4d       	mov	r13,	r15	;
    d858:	0f 5e       	add	r14,	r15	;
    d85a:	0f 93       	cmp	#0,	r15	;r3 As==00
    d85c:	0c 24       	jz	$+26     	;abs 0xd876

0000d85e <.Loc.76.1>:
    d85e:	3b 53       	add	#-1,	r11	;r3 As==11
    d860:	3d 53       	add	#-1,	r13	;r3 As==11

0000d862 <.LVL8>:
    d862:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    d866:	f7 3f       	jmp	$-16     	;abs 0xd856

0000d868 <.L3>:
    d868:	0b 9e       	cmp	r14,	r11	;
    d86a:	05 24       	jz	$+12     	;abs 0xd876

0000d86c <.LVL10>:
    d86c:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    d870:	1e 53       	inc	r14		;

0000d872 <.LVL11>:
    d872:	1d 53       	inc	r13		;
    d874:	f9 3f       	jmp	$-12     	;abs 0xd868

0000d876 <.L9>:
    d876:	30 41       	ret			

0000d878 <_free_r>:
    d878:	3a 15       	pushm	#4,	r10	;16-bit words

0000d87a <.LCFI0>:
    d87a:	0d 93       	cmp	#0,	r13	;r3 As==00
    d87c:	70 24       	jz	$+226    	;abs 0xd95e

0000d87e <L0>:
    d87e:	0e 4d       	mov	r13,	r14	;
    d880:	3e 50 fc ff 	add	#65532,	r14	;#0xfffc

0000d884 <.LVL2>:
    d884:	1f 4d fc ff 	mov	-4(r13),r15	;
    d888:	8d 93 fe ff 	cmp	#0,	-2(r13)	;r3 As==00, 0xfffe
    d88c:	01 34       	jge	$+4      	;abs 0xd890
    d88e:	0e 5f       	add	r15,	r14	;

0000d890 <.L4>:
    d890:	1d 42 82 65 	mov	&0x6582,r13	;0x6582

0000d894 <.LVL4>:
    d894:	0d 93       	cmp	#0,	r13	;r3 As==00
    d896:	16 24       	jz	$+46     	;abs 0xd8c4

0000d898 <.Loc.357.1>:
    d898:	0e 9d       	cmp	r13,	r14	;
    d89a:	1c 2c       	jc	$+58     	;abs 0xd8d4

0000d89c <.Loc.359.1>:
    d89c:	2a 4e       	mov	@r14,	r10	;
    d89e:	1b 4e 02 00 	mov	2(r14),	r11	;
    d8a2:	0c 4e       	mov	r14,	r12	;

0000d8a4 <.LVL5>:
    d8a4:	0c 5a       	add	r10,	r12	;
    d8a6:	0d 9c       	cmp	r12,	r13	;
    d8a8:	0d 20       	jnz	$+28     	;abs 0xd8c4

0000d8aa <.Loc.363.1>:
    d8aa:	08 4a       	mov	r10,	r8	;
    d8ac:	09 4b       	mov	r11,	r9	;
    d8ae:	28 5d       	add	@r13,	r8	;
    d8b0:	19 6d 02 00 	addc	2(r13),	r9	;
    d8b4:	8e 48 00 00 	mov	r8,	0(r14)	;
    d8b8:	8e 49 02 00 	mov	r9,	2(r14)	;

0000d8bc <.Loc.364.1>:
    d8bc:	9e 4d 04 00 	mov	4(r13),	4(r14)	;
    d8c0:	04 00 
    d8c2:	02 3c       	jmp	$+6      	;abs 0xd8c8

0000d8c4 <.L8>:
    d8c4:	8e 4d 04 00 	mov	r13,	4(r14)	;

0000d8c8 <.L9>:
    d8c8:	82 4e 82 65 	mov	r14,	&0x6582	;

0000d8cc <.Loc.373.1>:
    d8cc:	48 3c       	jmp	$+146    	;abs 0xd95e

0000d8ce <.L21>:
    d8ce:	0e 9f       	cmp	r15,	r14	;
    d8d0:	05 28       	jnc	$+12     	;abs 0xd8dc
    d8d2:	0d 4f       	mov	r15,	r13	;

0000d8d4 <.L11>:
    d8d4:	1f 4d 04 00 	mov	4(r13),	r15	;

0000d8d8 <.LVL8>:
    d8d8:	0f 93       	cmp	#0,	r15	;r3 As==00
    d8da:	f9 23       	jnz	$-12     	;abs 0xd8ce

0000d8dc <.L10>:
    d8dc:	29 4d       	mov	@r13,	r9	;
    d8de:	17 4d 02 00 	mov	2(r13),	r7	;
    d8e2:	08 4d       	mov	r13,	r8	;
    d8e4:	08 59       	add	r9,	r8	;
    d8e6:	08 9e       	cmp	r14,	r8	;
    d8e8:	1a 20       	jnz	$+54     	;abs 0xd91e

0000d8ea <.Loc.391.1>:
    d8ea:	2a 4e       	mov	@r14,	r10	;
    d8ec:	0a 59       	add	r9,	r10	;
    d8ee:	1b 4e 02 00 	mov	2(r14),	r11	;
    d8f2:	0b 67       	addc	r7,	r11	;
    d8f4:	8d 4a 00 00 	mov	r10,	0(r13)	;
    d8f8:	8d 4b 02 00 	mov	r11,	2(r13)	;

0000d8fc <.Loc.394.1>:
    d8fc:	0c 4d       	mov	r13,	r12	;

0000d8fe <.LVL9>:
    d8fe:	0c 5a       	add	r10,	r12	;
    d900:	0f 9c       	cmp	r12,	r15	;
    d902:	2d 20       	jnz	$+92     	;abs 0xd95e

0000d904 <.Loc.396.1>:
    d904:	08 4a       	mov	r10,	r8	;
    d906:	09 4b       	mov	r11,	r9	;
    d908:	28 5f       	add	@r15,	r8	;
    d90a:	19 6f 02 00 	addc	2(r15),	r9	;
    d90e:	8d 48 00 00 	mov	r8,	0(r13)	;
    d912:	8d 49 02 00 	mov	r9,	2(r13)	;

0000d916 <.Loc.397.1>:
    d916:	9d 4f 04 00 	mov	4(r15),	4(r13)	;
    d91a:	04 00 
    d91c:	20 3c       	jmp	$+66     	;abs 0xd95e

0000d91e <.L12>:
    d91e:	0e 98       	cmp	r8,	r14	;
    d920:	04 2c       	jc	$+10     	;abs 0xd92a

0000d922 <.Loc.404.1>:
    d922:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    d926:	00 00 

0000d928 <.Loc.406.1>:
    d928:	1a 3c       	jmp	$+54     	;abs 0xd95e

0000d92a <.L14>:
    d92a:	2a 4e       	mov	@r14,	r10	;
    d92c:	1b 4e 02 00 	mov	2(r14),	r11	;
    d930:	0c 4e       	mov	r14,	r12	;

0000d932 <.LVL11>:
    d932:	0c 5a       	add	r10,	r12	;
    d934:	0f 9c       	cmp	r12,	r15	;
    d936:	0f 20       	jnz	$+32     	;abs 0xd956

0000d938 <.Loc.413.1>:
    d938:	08 4a       	mov	r10,	r8	;
    d93a:	09 4b       	mov	r11,	r9	;
    d93c:	28 5f       	add	@r15,	r8	;
    d93e:	19 6f 02 00 	addc	2(r15),	r9	;
    d942:	8e 48 00 00 	mov	r8,	0(r14)	;
    d946:	8e 49 02 00 	mov	r9,	2(r14)	;

0000d94a <.Loc.414.1>:
    d94a:	9e 4f 04 00 	mov	4(r15),	4(r14)	;
    d94e:	04 00 

0000d950 <.Loc.415.1>:
    d950:	8d 4e 04 00 	mov	r14,	4(r13)	;
    d954:	04 3c       	jmp	$+10     	;abs 0xd95e

0000d956 <.L15>:
    d956:	8e 4f 04 00 	mov	r15,	4(r14)	;

0000d95a <.Loc.422.1>:
    d95a:	8d 4e 04 00 	mov	r14,	4(r13)	;

0000d95e <.L1>:
    d95e:	37 17       	popm	#4,	r10	;16-bit words
    d960:	30 41       	ret			

0000d962 <_malloc_r>:
    d962:	3a 15       	pushm	#4,	r10	;16-bit words

0000d964 <.LCFI0>:
    d964:	08 4c       	mov	r12,	r8	;

0000d966 <.Loc.247.1>:
    d966:	09 4d       	mov	r13,	r9	;
    d968:	19 53       	inc	r9		;
    d96a:	19 c3       	bic	#1,	r9	;r3 As==01

0000d96c <L0>:
    d96c:	39 50 0a 00 	add	#10,	r9	;#0x000a

0000d970 <.LVL2>:
    d970:	39 90 0c 00 	cmp	#12,	r9	;#0x000c
    d974:	02 2c       	jc	$+6      	;abs 0xd97a
    d976:	79 40 0c 00 	mov.b	#12,	r9	;#0x000c

0000d97a <.L2>:
    d97a:	09 9d       	cmp	r13,	r9	;
    d97c:	05 2c       	jc	$+12     	;abs 0xd988

0000d97e <.L13>:
    d97e:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    d982:	00 00 

0000d984 <.Loc.255.1>:
    d984:	4c 43       	clr.b	r12		;
    d986:	60 3c       	jmp	$+194    	;abs 0xda48

0000d988 <.L3>:
    d988:	1e 42 82 65 	mov	&0x6582,r14	;0x6582

0000d98c <.LVL6>:
    d98c:	0d 4e       	mov	r14,	r13	;

0000d98e <.L5>:
    d98e:	0d 93       	cmp	#0,	r13	;r3 As==00
    d990:	28 24       	jz	$+82     	;abs 0xd9e2

0000d992 <.LBB5>:
    d992:	2c 4d       	mov	@r13,	r12	;
    d994:	0c 89       	sub	r9,	r12	;

0000d996 <.LVL8>:
    d996:	0c 93       	cmp	#0,	r12	;r3 As==00
    d998:	20 38       	jl	$+66     	;abs 0xd9da

0000d99a <.Loc.268.1>:
    d99a:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    d99e:	0f 9c       	cmp	r12,	r15	;
    d9a0:	11 2c       	jc	$+36     	;abs 0xd9c4

0000d9a2 <.Loc.272.1>:
    d9a2:	0e 4c       	mov	r12,	r14	;
    d9a4:	0f 4c       	mov	r12,	r15	;
    d9a6:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000d9aa <.LVL9>:
    d9aa:	8d 4e 00 00 	mov	r14,	0(r13)	;
    d9ae:	8d 4f 02 00 	mov	r15,	2(r13)	;

0000d9b2 <.Loc.273.1>:
    d9b2:	0e 4d       	mov	r13,	r14	;
    d9b4:	0e 5c       	add	r12,	r14	;

0000d9b6 <.LVL10>:
    d9b6:	0c 49       	mov	r9,	r12	;
    d9b8:	0d 43       	clr	r13		;

0000d9ba <.LVL11>:
    d9ba:	8e 4c 00 00 	mov	r12,	0(r14)	;
    d9be:	8e 4d 02 00 	mov	r13,	2(r14)	;
    d9c2:	2a 3c       	jmp	$+86     	;abs 0xda18

0000d9c4 <.L7>:
    d9c4:	0e 9d       	cmp	r13,	r14	;
    d9c6:	04 20       	jnz	$+10     	;abs 0xd9d0

0000d9c8 <.Loc.282.1>:
    d9c8:	92 4e 04 00 	mov	4(r14),	&0x6582	;
    d9cc:	82 65 
    d9ce:	24 3c       	jmp	$+74     	;abs 0xda18

0000d9d0 <.L9>:
    d9d0:	9e 4d 04 00 	mov	4(r13),	4(r14)	;
    d9d4:	04 00 
    d9d6:	0e 4d       	mov	r13,	r14	;

0000d9d8 <.LVL13>:
    d9d8:	1f 3c       	jmp	$+64     	;abs 0xda18

0000d9da <.L6>:
    d9da:	0e 4d       	mov	r13,	r14	;
    d9dc:	1d 4d 04 00 	mov	4(r13),	r13	;

0000d9e0 <.LVL15>:
    d9e0:	d6 3f       	jmp	$-82     	;abs 0xd98e

0000d9e2 <.L24>:
    d9e2:	37 40 9e da 	mov	#55966,	r7	;#0xda9e

0000d9e6 <.LBB6>:
    d9e6:	82 93 80 65 	cmp	#0,	&0x6580	;r3 As==00
    d9ea:	04 20       	jnz	$+10     	;abs 0xd9f4
    d9ec:	0c 48       	mov	r8,	r12	;
    d9ee:	87 12       	call	r7		;

0000d9f0 <.LVL17>:
    d9f0:	82 4c 80 65 	mov	r12,	&0x6580	;

0000d9f4 <.L17>:
    d9f4:	0d 49       	mov	r9,	r13	;
    d9f6:	0c 48       	mov	r8,	r12	;
    d9f8:	87 12       	call	r7		;

0000d9fa <.LVL18>:
    d9fa:	3c 93       	cmp	#-1,	r12	;r3 As==11
    d9fc:	c0 27       	jz	$-126    	;abs 0xd97e

0000d9fe <.Loc.222.1>:
    d9fe:	0e 4c       	mov	r12,	r14	;
    da00:	1e 53       	inc	r14		;
    da02:	0a 4e       	mov	r14,	r10	;
    da04:	1a c3       	bic	#1,	r10	;r3 As==01

0000da06 <.LVL19>:
    da06:	0c 9a       	cmp	r10,	r12	;
    da08:	18 20       	jnz	$+50     	;abs 0xda3a

0000da0a <.L14>:
    da0a:	0d 49       	mov	r9,	r13	;
    da0c:	0e 43       	clr	r14		;
    da0e:	8a 4d 00 00 	mov	r13,	0(r10)	;
    da12:	8a 4e 02 00 	mov	r14,	2(r10)	;
    da16:	0e 4a       	mov	r10,	r14	;

0000da18 <.L8>:
    da18:	0f 4e       	mov	r14,	r15	;
    da1a:	2f 52       	add	#4,	r15	;r2 As==10

0000da1c <.LVL22>:
    da1c:	0c 4f       	mov	r15,	r12	;
    da1e:	3c 50 07 00 	add	#7,	r12	;
    da22:	3c f0 f8 ff 	and	#65528,	r12	;#0xfff8

0000da26 <.LVL23>:
    da26:	0d 4c       	mov	r12,	r13	;
    da28:	0d 8f       	sub	r15,	r13	;

0000da2a <.LVL24>:
    da2a:	0d 93       	cmp	#0,	r13	;r3 As==00
    da2c:	0d 24       	jz	$+28     	;abs 0xda48

0000da2e <.Loc.318.1>:
    da2e:	0e 5d       	add	r13,	r14	;

0000da30 <.LVL25>:
    da30:	4f 43       	clr.b	r15		;

0000da32 <.LVL26>:
    da32:	0f 8d       	sub	r13,	r15	;
    da34:	8e 4f 00 00 	mov	r15,	0(r14)	;
    da38:	07 3c       	jmp	$+16     	;abs 0xda48

0000da3a <.L25>:
    da3a:	0d 4a       	mov	r10,	r13	;
    da3c:	0d 8c       	sub	r12,	r13	;
    da3e:	0c 48       	mov	r8,	r12	;

0000da40 <.LVL28>:
    da40:	87 12       	call	r7		;

0000da42 <.LVL29>:
    da42:	3c 93       	cmp	#-1,	r12	;r3 As==11
    da44:	e2 23       	jnz	$-58     	;abs 0xda0a
    da46:	9b 3f       	jmp	$-200    	;abs 0xd97e

0000da48 <.L1>:
    da48:	37 17       	popm	#4,	r10	;16-bit words
    da4a:	30 41       	ret			

0000da4c <_realloc_r>:
    da4c:	3a 15       	pushm	#4,	r10	;16-bit words

0000da4e <.LCFI0>:
    da4e:	07 4c       	mov	r12,	r7	;
    da50:	08 4d       	mov	r13,	r8	;
    da52:	0a 4e       	mov	r14,	r10	;

0000da54 <.Loc.454.1>:
    da54:	0d 93       	cmp	#0,	r13	;r3 As==00
    da56:	05 20       	jnz	$+12     	;abs 0xda62

0000da58 <.Loc.454.1>:
    da58:	0d 4e       	mov	r14,	r13	;

0000da5a <L0>:
    da5a:	b0 12 62 d9 	call	#55650		;#0xd962

0000da5e <.LVL2>:
    da5e:	09 4c       	mov	r12,	r9	;
    da60:	1b 3c       	jmp	$+56     	;abs 0xda98

0000da62 <.L2>:
    da62:	0e 93       	cmp	#0,	r14	;r3 As==00
    da64:	04 20       	jnz	$+10     	;abs 0xda6e

0000da66 <.Loc.458.1>:
    da66:	b0 12 78 d8 	call	#55416		;#0xd878

0000da6a <.LVL3>:
    da6a:	09 4a       	mov	r10,	r9	;
    da6c:	15 3c       	jmp	$+44     	;abs 0xda98

0000da6e <.L4>:
    da6e:	b0 12 c0 da 	call	#56000		;#0xdac0

0000da72 <.LVL4>:
    da72:	0c 9a       	cmp	r10,	r12	;
    da74:	10 2c       	jc	$+34     	;abs 0xda96

0000da76 <.Loc.467.1>:
    da76:	0d 4a       	mov	r10,	r13	;
    da78:	0c 47       	mov	r7,	r12	;
    da7a:	b0 12 62 d9 	call	#55650		;#0xd962

0000da7e <.LVL5>:
    da7e:	09 4c       	mov	r12,	r9	;

0000da80 <.LVL6>:
    da80:	0c 93       	cmp	#0,	r12	;r3 As==00
    da82:	0a 24       	jz	$+22     	;abs 0xda98

0000da84 <.Loc.470.1>:
    da84:	0e 4a       	mov	r10,	r14	;
    da86:	0d 48       	mov	r8,	r13	;
    da88:	b0 12 d6 cc 	call	#52438		;#0xccd6

0000da8c <.LVL7>:
    da8c:	0d 48       	mov	r8,	r13	;
    da8e:	0c 47       	mov	r7,	r12	;
    da90:	b0 12 78 d8 	call	#55416		;#0xd878

0000da94 <.LVL8>:
    da94:	01 3c       	jmp	$+4      	;abs 0xda98

0000da96 <.L5>:
    da96:	09 48       	mov	r8,	r9	;

0000da98 <.L1>:
    da98:	0c 49       	mov	r9,	r12	;
    da9a:	37 17       	popm	#4,	r10	;16-bit words
    da9c:	30 41       	ret			

0000da9e <_sbrk_r>:
    da9e:	0a 15       	pushm	#1,	r10	;16-bit words

0000daa0 <.LCFI0>:
    daa0:	0a 4c       	mov	r12,	r10	;

0000daa2 <.Loc.57.1>:
    daa2:	82 43 84 65 	Address 0x000000000000daa4 is out of bounds.
mov	#0,	&0xffff	;r3 As==00

0000daa4 <L0>:
    daa4:	84 65 0c 4d 	Address 0x000000000000daa6 is out of bounds.
addc	r5,	-1(r4)	; 0xffff

0000daa6 <.Loc.58.1>:
    daa6:	0c 4d       	mov	r13,	r12	;

0000daa8 <.LVL1>:
    daa8:	b0 12 d4 da 	call	#56020		;#0xdad4

0000daac <.LVL2>:
    daac:	3c 93       	cmp	#-1,	r12	;r3 As==11
    daae:	06 20       	jnz	$+14     	;abs 0xdabc

0000dab0 <.Loc.58.1>:
    dab0:	1d 42 84 65 	mov	&0x6584,r13	;0x6584
    dab4:	0d 93       	cmp	#0,	r13	;r3 As==00
    dab6:	02 24       	jz	$+6      	;abs 0xdabc

0000dab8 <.Loc.59.1>:
    dab8:	8a 4d 00 00 	mov	r13,	0(r10)	;

0000dabc <.L2>:
    dabc:	0a 17       	popm	#1,	r10	;16-bit words
    dabe:	30 41       	ret			

0000dac0 <_malloc_usable_size_r>:
    dac0:	1e 4d fc ff 	mov	-4(r13),r14	;
    dac4:	0c 4e       	mov	r14,	r12	;

0000dac6 <.LVL3>:
    dac6:	3c 50 fc ff 	add	#65532,	r12	;#0xfffc

0000daca <.Loc.530.1>:
    daca:	0e 93       	cmp	#0,	r14	;r3 As==00
    dacc:	02 34       	jge	$+6      	;abs 0xdad2

0000dace <.LVL4>:
    dace:	0d 5c       	add	r12,	r13	;

0000dad0 <.LVL5>:
    dad0:	2c 5d       	add	@r13,	r12	;

0000dad2 <.L1>:
    dad2:	30 41       	ret			

0000dad4 <_sbrk>:
    dad4:	21 83       	decd	r1		;

0000dad6 <.LCFI0>:
    dad6:	1d 42 08 5b 	mov	&0x5b08,r13	;0x5b08

0000dada <.LVL1>:
    dada:	4e 43       	clr.b	r14		;
    dadc:	0e 51       	add	r1,	r14	;
    dade:	81 4e 00 00 	mov	r14,	0(r1)	;

0000dae2 <.Loc.22.1>:
    dae2:	0c 5d       	add	r13,	r12	;

0000dae4 <.LVL2>:
    dae4:	01 9c       	cmp	r12,	r1	;
    dae6:	05 28       	jnc	$+12     	;abs 0xdaf2

0000dae8 <.Loc.29.1>:
    dae8:	82 4c 08 5b 	mov	r12,	&0x5b08	;

0000daec <.Loc.31.1>:
    daec:	0c 4d       	mov	r13,	r12	;
    daee:	21 53       	incd	r1		;
    daf0:	30 41       	ret			

0000daf2 <.L4>:
    daf2:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    daf6:	3d 40 b2 51 	mov	#20914,	r13	;#0x51b2

0000dafa <.LVL4>:
    dafa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    dafc:	b0 12 04 db 	call	#56068		;#0xdb04

0000db00 <.LVL5>:
    db00:	b0 12 96 db 	call	#56214		;#0xdb96

0000db04 <write>:
    db04:	6a 15       	pushm	#7,	r10	;16-bit words

0000db06 <.LCFI0>:
    db06:	21 82       	sub	#4,	r1	;r2 As==10

0000db08 <.LCFI1>:
    db08:	07 4d       	mov	r13,	r7	;
    db0a:	09 4e       	mov	r14,	r9	;

0000db0c <.Loc.48.1>:
    db0c:	4d 43       	clr.b	r13		;

0000db0e <.LVL2>:
    db0e:	0d 9e       	cmp	r14,	r13	;
    db10:	3e 34       	jge	$+126    	;abs 0xdb8e
    db12:	4d 4c       	mov.b	r12,	r13	;
    db14:	81 4d 02 00 	mov	r13,	2(r1)	;
    db18:	5c 0f       	rrum	#4,	r12	;
    db1a:	5c 0f       	rrum	#4,	r12	;

0000db1c <.LVL3>:
    db1c:	81 4c 00 00 	mov	r12,	0(r1)	;
    db20:	34 40 0a 5b 	mov	#23306,	r4	;#0x5b0a
    db24:	35 40 d6 cc 	mov	#52438,	r5	;#0xccd6
    db28:	36 40 92 db 	mov	#56210,	r6	;#0xdb92

0000db2c <.LBB5>:
    db2c:	48 43       	clr.b	r8		;

0000db2e <.Loc.28.1>:
    db2e:	09 47       	mov	r7,	r9	;
    db30:	07 4e       	mov	r14,	r7	;

0000db32 <.L4>:
    db32:	0a 47       	mov	r7,	r10	;
    db34:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    db38:	0c 97       	cmp	r7,	r12	;
    db3a:	01 34       	jge	$+4      	;abs 0xdb3e
    db3c:	0a 4c       	mov	r12,	r10	;

0000db3e <.L3>:
    db3e:	4c 4a       	mov.b	r10,	r12	;
    db40:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000db44 <.Loc.22.1>:
    db44:	c2 48 0b 5b 	mov.b	r8,	&0x5b0b	;

0000db48 <.Loc.23.1>:
    db48:	f2 40 f3 ff 	mov.b	#65523,	&0x5b0c	;#0xfff3
    db4c:	0c 5b 

0000db4e <.Loc.24.1>:
    db4e:	1d 41 02 00 	mov	2(r1),	r13	;
    db52:	c4 4d 03 00 	mov.b	r13,	3(r4)	;

0000db56 <.Loc.25.1>:
    db56:	2d 41       	mov	@r1,	r13	;
    db58:	c4 4d 04 00 	mov.b	r13,	4(r4)	;

0000db5c <.Loc.26.1>:
    db5c:	c4 4c 05 00 	mov.b	r12,	5(r4)	;

0000db60 <.Loc.27.1>:
    db60:	c2 48 10 5b 	mov.b	r8,	&0x5b10	;

0000db64 <.Loc.28.1>:
    db64:	0e 4a       	mov	r10,	r14	;
    db66:	0d 49       	mov	r9,	r13	;
    db68:	3c 40 15 5b 	mov	#23317,	r12	;#0x5b15
    db6c:	85 12       	call	r5		;

0000db6e <.LVL6>:
    db6e:	86 12       	call	r6		;

0000db70 <.LBE10>:
    db70:	07 8a       	sub	r10,	r7	;

0000db72 <.Loc.56.1>:
    db72:	09 5a       	add	r10,	r9	;

0000db74 <.LBE5>:
    db74:	4c 43       	clr.b	r12		;
    db76:	0c 97       	cmp	r7,	r12	;
    db78:	dc 3b       	jl	$-70     	;abs 0xdb32

0000db7a <.LBB11>:
    db7a:	5c 44 03 00 	mov.b	3(r4),	r12	;
    db7e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    db82:	54 44 02 00 	mov.b	2(r4),	r4	;
    db86:	0c 54       	add	r4,	r12	;

0000db88 <.L1>:
    db88:	21 52       	add	#4,	r1	;r2 As==10
    db8a:	64 17       	popm	#7,	r10	;16-bit words
    db8c:	30 41       	ret			

0000db8e <.L5>:
    db8e:	4c 43       	clr.b	r12		;

0000db90 <.LVL12>:
    db90:	fb 3f       	jmp	$-8      	;abs 0xdb88

0000db92 <C$$IO$$>:
    db92:	03 43       	nop			

0000db94 <L0>:
    db94:	30 41       	ret			

0000db96 <abort>:
    db96:	7c 40 06 00 	mov.b	#6,	r12	;
    db9a:	b0 12 16 dc 	call	#56342		;#0xdc16

0000db9e <.LVL0>:
    db9e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    dba0:	b0 12 4c dc 	call	#56396		;#0xdc4c

0000dba4 <memset>:
    dba4:	0f 4c       	mov	r12,	r15	;
    dba6:	0e 5c       	add	r12,	r14	;

0000dba8 <.L2>:
    dba8:	0f 9e       	cmp	r14,	r15	;
    dbaa:	04 24       	jz	$+10     	;abs 0xdbb4

0000dbac <.LVL3>:
    dbac:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    dbb0:	1f 53       	inc	r15		;

0000dbb2 <.LVL4>:
    dbb2:	fa 3f       	jmp	$-10     	;abs 0xdba8

0000dbb4 <.L5>:
    dbb4:	30 41       	ret			

0000dbb6 <_raise_r>:
    dbb6:	1a 15       	pushm	#2,	r10	;16-bit words

0000dbb8 <L0>:
    dbb8:	09 4c       	mov	r12,	r9	;
    dbba:	0a 4d       	mov	r13,	r10	;

0000dbbc <.Loc.151.1>:
    dbbc:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

0000dbc0 <.LVL16>:
    dbc0:	0c 9d       	cmp	r13,	r12	;
    dbc2:	05 2c       	jc	$+12     	;abs 0xdbce

0000dbc4 <.Loc.153.1>:
    dbc4:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    dbc8:	00 00 

0000dbca <.Loc.154.1>:
    dbca:	3c 43       	mov	#-1,	r12	;r3 As==11
    dbcc:	22 3c       	jmp	$+70     	;abs 0xdc12

0000dbce <.L18>:
    dbce:	1c 49 22 00 	mov	34(r9),	r12	;0x00022
    dbd2:	0c 93       	cmp	#0,	r12	;r3 As==00
    dbd4:	05 24       	jz	$+12     	;abs 0xdbe0

0000dbd6 <.Loc.160.1>:
    dbd6:	0d 5d       	rla	r13		;

0000dbd8 <.LVL17>:
    dbd8:	0c 5d       	add	r13,	r12	;
    dbda:	2d 4c       	mov	@r12,	r13	;

0000dbdc <.LVL18>:
    dbdc:	0d 93       	cmp	#0,	r13	;r3 As==00
    dbde:	09 20       	jnz	$+20     	;abs 0xdbf2

0000dbe0 <.L20>:
    dbe0:	0c 49       	mov	r9,	r12	;
    dbe2:	b0 12 46 dc 	call	#56390		;#0xdc46

0000dbe6 <.LVL20>:
    dbe6:	0e 4a       	mov	r10,	r14	;
    dbe8:	0d 4c       	mov	r12,	r13	;
    dbea:	0c 49       	mov	r9,	r12	;
    dbec:	b0 12 22 dc 	call	#56354		;#0xdc22

0000dbf0 <.LVL21>:
    dbf0:	10 3c       	jmp	$+34     	;abs 0xdc12

0000dbf2 <.L21>:
    dbf2:	1d 93       	cmp	#1,	r13	;r3 As==01
    dbf4:	0d 24       	jz	$+28     	;abs 0xdc10

0000dbf6 <.Loc.166.1>:
    dbf6:	3d 93       	cmp	#-1,	r13	;r3 As==11
    dbf8:	05 20       	jnz	$+12     	;abs 0xdc04

0000dbfa <.Loc.168.1>:
    dbfa:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    dbfe:	00 00 

0000dc00 <.Loc.169.1>:
    dc00:	5c 43       	mov.b	#1,	r12	;r3 As==01
    dc02:	07 3c       	jmp	$+16     	;abs 0xdc12

0000dc04 <.L22>:
    dc04:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

0000dc08 <.Loc.174.1>:
    dc08:	0c 4a       	mov	r10,	r12	;
    dc0a:	8d 12       	call	r13		;

0000dc0c <.LVL23>:
    dc0c:	4c 43       	clr.b	r12		;
    dc0e:	01 3c       	jmp	$+4      	;abs 0xdc12

0000dc10 <.L23>:
    dc10:	4c 43       	clr.b	r12		;

0000dc12 <.L17>:
    dc12:	19 17       	popm	#2,	r10	;16-bit words
    dc14:	30 41       	ret			

0000dc16 <raise>:
    dc16:	0d 4c       	mov	r12,	r13	;
    dc18:	1c 42 8e 5a 	mov	&0x5a8e,r12	;0x5a8e

0000dc1c <.LVL37>:
    dc1c:	b0 12 b6 db 	Address 0x000000000000dc1e is out of bounds.
call	#65535		;#0xffff

0000dc1e <L0>:
    dc1e:	b6 db 30 41 	Address 0x000000000000dc20 is out of bounds.
bis	@r11+,	-1(r6)	; 0xffff

0000dc20 <.LVL38>:
    dc20:	30 41       	ret			

0000dc22 <_kill_r>:
    dc22:	0a 15       	pushm	#1,	r10	;16-bit words

0000dc24 <.LCFI0>:
    dc24:	0a 4c       	mov	r12,	r10	;
    dc26:	0c 4d       	mov	r13,	r12	;

0000dc28 <.LVL1>:
    dc28:	82 43 84 65 	mov	#0,	&0x6584	;r3 As==00

0000dc2c <.Loc.61.1>:
    dc2c:	0d 4e       	mov	r14,	r13	;

0000dc2e <.LVL2>:
    dc2e:	b0 12 54 dc 	call	#56404		;#0xdc54

0000dc32 <.LVL3>:
    dc32:	3c 93       	cmp	#-1,	r12	;r3 As==11
    dc34:	06 20       	jnz	$+14     	;abs 0xdc42

0000dc36 <.Loc.61.1>:
    dc36:	1d 42 84 65 	mov	&0x6584,r13	;0x6584
    dc3a:	0d 93       	cmp	#0,	r13	;r3 As==00
    dc3c:	02 24       	jz	$+6      	;abs 0xdc42

0000dc3e <.Loc.62.1>:
    dc3e:	8a 4d 00 00 	mov	r13,	0(r10)	;

0000dc42 <.L1>:
    dc42:	0a 17       	popm	#1,	r10	;16-bit words
    dc44:	30 41       	ret			

0000dc46 <_getpid_r>:
    dc46:	b0 12 4e dc 	call	#56398		;#0xdc4e

0000dc4a <.LVL5>:
    dc4a:	30 41       	ret			

0000dc4c <_exit>:
    dc4c:	ff 3f       	jmp	$+0      	;abs 0xdc4c

0000dc4e <getpid>:
    dc4e:	3c 40 2a 00 	Address 0x000000000000dc50 is out of bounds.
mov	#65535,	r12	;#0xffff

0000dc50 <L0>:
    dc50:	2a 00 30 41 	Address 0x000000000000dc52 is out of bounds.
mova	&65535,	r10	;0x0ffff

0000dc52 <.Loc.65.1>:
    dc52:	30 41       	ret			

0000dc54 <kill>:
    dc54:	b0 12 62 dc 	call	#56418		;#0xdc62
    dc58:	bc 40 58 00 	mov	#88,	0(r12)	;#0x0058
    dc5c:	00 00 
    dc5e:	3c 43       	mov	#-1,	r12	;r3 As==11
    dc60:	30 41       	ret			

0000dc62 <__errno>:
    dc62:	1c 42 8e 5a 	mov	&0x5a8e,r12	;0x5a8e
    dc66:	30 41       	ret			
