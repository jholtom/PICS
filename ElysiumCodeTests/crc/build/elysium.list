
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	4a 83       	sub.b	#0,	r10	;r3 As==00

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	4c 83       	sub.b	#0,	r12	;r3 As==00

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	4e 83       	sub.b	#0,	r14	;r3 As==00

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	50 83       	dec.b	r0		;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	52 83       	dec.b	r2		;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	54 83       	dec.b	r4		;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	56 83       	dec.b	r6		;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	58 83       	dec.b	r8		;

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	5a 83       	dec.b	r10		;

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	5c 83       	dec.b	r12		;

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	5e 83       	dec.b	r14		;

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	60 83       	decd.b	r0		;

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	62 83       	decd.b	r2		;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	64 83       	decd.b	r4		;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	66 83       	decd.b	r6		;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	68 83       	decd.b	r8		;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	6a 83       	decd.b	r10		;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	6c 83       	decd.b	r12		;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	6e 83       	decd.b	r14		;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	70 83       	sub.b	#-1,	r0	;r3 As==11

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	72 83       	sub.b	#-1,	r2	;r3 As==11

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	74 83       	sub.b	#-1,	r4	;r3 As==11

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	76 83       	sub.b	#-1,	r6	;r3 As==11

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	78 83       	sub.b	#-1,	r8	;r3 As==11

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	7a 83       	sub.b	#-1,	r10	;r3 As==11

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	7c 83       	sub.b	#-1,	r12	;r3 As==11

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	7e 83       	sub.b	#-1,	r14	;r3 As==11

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	80 83 00 00 	Address 0x000000000000ffc8 is out of bounds.
sub	#0,	0xffff	;r3 As==00, PC rel. 0xffc7

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	82 83 00 00 	Address 0x000000000000ffca is out of bounds.
sub	#0,	&0xffff	;r3 As==00

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	84 83 00 00 	Address 0x000000000000ffcc is out of bounds.
sub	#0,	-1(r4)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	86 83 00 00 	Address 0x000000000000ffce is out of bounds.
sub	#0,	-1(r6)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	88 83 00 00 	Address 0x000000000000ffd0 is out of bounds.
sub	#0,	-1(r8)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	8c 7a 00 00 	Address 0x000000000000ffd2 is out of bounds.
subc	r10,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	28 7a       	subc	@r10,	r8	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	8a 83 00 00 	Address 0x000000000000ffd6 is out of bounds.
sub	#0,	-1(r10)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	8c 83 00 00 	Address 0x000000000000ffd8 is out of bounds.
sub	#0,	-1(r12)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	c6 79 00 00 	Address 0x000000000000ffda is out of bounds.
subc.b	r9,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	8e 83 00 00 	Address 0x000000000000ffdc is out of bounds.
sub	#0,	-1(r14)	;r3 As==00, 0xffff

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	90 83 00 00 	Address 0x000000000000ffde is out of bounds.
dec	0xffff		;PC rel. abs addr 0xffdd

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	66 79       	subc.b	@r9,	r6	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	92 83       	interrupt service routine at 0x8392

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	94 83       	interrupt service routine at 0x8394

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	16 7d       	interrupt service routine at 0x7d16

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	96 83       	interrupt service routine at 0x8396

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	98 83       	interrupt service routine at 0x8398

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	9a 83       	interrupt service routine at 0x839a

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	9c 83       	interrupt service routine at 0x839c

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	76 7f       	interrupt service routine at 0x7f76

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	18 78       	interrupt service routine at 0x7818

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	9e 83       	interrupt service routine at 0x839e

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	a0 83       	interrupt service routine at 0x83a0

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	80 73       	interrupt service routine at 0x7380

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	a2 83       	interrupt service routine at 0x83a2

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	a4 83       	interrupt service routine at 0x83a4

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	a6 83       	interrupt service routine at 0x83a6

Disassembly of section .text:

000063c2 <__crt0_start>:
    63c2:	31 40 00 50 	mov	#20480,	r1	;#0x5000

000063c6 <disable_watchdog>:
#include "crc_sdlp.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    63c6:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    63ca:	5c 01 

000063cc <.Loc.28.1>:
}
    63cc:	03 43       	nop			

000063ce <__crt0_init_bss>:
    63ce:	3c 40 9c 51 	mov	#20892,	r12	;#0x519c

000063d2 <.Loc.74.1>:
    63d2:	0d 43       	clr	r13		;

000063d4 <.Loc.75.1>:
    63d4:	3e 40 26 12 	mov	#4646,	r14	;#0x1226

000063d8 <.Loc.79.1>:
    63d8:	b0 12 f2 a0 	call	#41202		;#0xa0f2

000063dc <__crt0_movedata>:
    63dc:	3c 40 6a 51 	mov	#20842,	r12	;#0x516a

000063e0 <.Loc.116.1>:
    63e0:	3d 40 6a 51 	mov	#20842,	r13	;#0x516a

000063e4 <.Loc.119.1>:
    63e4:	0d 9c       	cmp	r12,	r13	;

000063e6 <.Loc.120.1>:
    63e6:	04 24       	jz	$+10     	;abs 0x63f0

000063e8 <.Loc.122.1>:
    63e8:	3e 40 32 00 	mov	#50,	r14	;#0x0032

000063ec <.Loc.124.1>:
    63ec:	b0 12 b8 a0 	call	#41144		;#0xa0b8

000063f0 <__crt0_call_just_main>:
    63f0:	0c 43       	clr	r12		;

000063f2 <.Loc.181.1>:
    63f2:	b0 12 bc 9e 	call	#40636		;#0x9ebc

000063f6 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    63f6:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00

000063fa <.Loc.305.1>:
}
    63fa:	03 43       	nop			
    63fc:	30 41       	ret			

000063fe <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    63fe:	32 c2       	dint			

00006400 <.Loc.348.1>:
  asm volatile("nop");
    6400:	03 43       	nop			

00006402 <.Loc.349.1>:
}
    6402:	03 43       	nop			
    6404:	30 41       	ret			

00006406 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6406:	03 43       	nop			

00006408 <.Loc.356.1>:
  _enable_interrupts();
    6408:	32 d2       	eint			
    640a:	03 43       	nop			

0000640c <.Loc.357.1>:
}
    640c:	03 43       	nop			
    640e:	30 41       	ret			

00006410 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6410:	03 43       	nop			
    6412:	30 41       	ret			

00006414 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6414:	03 43       	nop			
    6416:	30 41       	ret			

00006418 <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    6418:	32 c2       	dint			

0000641a <.Loc.381.1>:
  asm volatile("nop");
    641a:	03 43       	nop			

0000641c <.Loc.382.1>:
}
    641c:	03 43       	nop			
    641e:	30 41       	ret			

00006420 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    6420:	32 c2       	dint			

00006422 <.Loc.390.1>:
  asm volatile("nop");
    6422:	03 43       	nop			

00006424 <.Loc.391.1>:
}
    6424:	03 43       	nop			
    6426:	30 41       	ret			

00006428 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6428:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    642c:	0c 93       	cmp	#0,	r12	;r3 As==00
    642e:	04 20       	jnz	$+10     	;abs 0x6438

00006430 <.Loc.79.2>:
    6430:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    6434:	0c 93       	cmp	#0,	r12	;r3 As==00
    6436:	04 24       	jz	$+10     	;abs 0x6440

00006438 <.L19>:
    chSysHalt("SV#2");
    6438:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    643c:	b0 12 26 66 	call	#26150		;#0x6626

00006440 <.L21>:
  }
}
    6440:	03 43       	nop			
    6442:	30 41       	ret			

00006444 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6444:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    6448:	0c 93       	cmp	#0,	r12	;r3 As==00
    644a:	04 20       	jnz	$+10     	;abs 0x6454

0000644c <.Loc.103.2>:
    644c:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    6450:	0c 93       	cmp	#0,	r12	;r3 As==00
    6452:	04 24       	jz	$+10     	;abs 0x645c

00006454 <.L27>:
    chSysHalt("SV#4");
    6454:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    6458:	b0 12 26 66 	call	#26150		;#0x6626

0000645c <.L28>:
  }
  _dbg_enter_lock();
    645c:	92 43 a4 51 	mov	#1,	&0x51a4	;r3 As==01

00006460 <.Loc.107.2>:
}
    6460:	03 43       	nop			
    6462:	30 41       	ret			

00006464 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6464:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    6468:	0c 93       	cmp	#0,	r12	;r3 As==00
    646a:	05 20       	jnz	$+12     	;abs 0x6476

0000646c <.Loc.116.2>:
    646c:	1d 42 a4 51 	mov	&0x51a4,r13	;0x51a4
    6470:	4c 43       	clr.b	r12		;
    6472:	0c 9d       	cmp	r13,	r12	;
    6474:	04 38       	jl	$+10     	;abs 0x647e

00006476 <.L30>:
    chSysHalt("SV#5");
    6476:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    647a:	b0 12 26 66 	call	#26150		;#0x6626

0000647e <.L31>:
  }
  _dbg_leave_lock();
    647e:	82 43 a4 51 	mov	#0,	&0x51a4	;r3 As==00

00006482 <.Loc.120.2>:
}
    6482:	03 43       	nop			
    6484:	30 41       	ret			

00006486 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6486:	1d 42 a2 51 	mov	&0x51a2,r13	;0x51a2
    648a:	4c 43       	clr.b	r12		;
    648c:	0c 9d       	cmp	r13,	r12	;
    648e:	04 34       	jge	$+10     	;abs 0x6498

00006490 <.Loc.129.2>:
    6490:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    6494:	0c 93       	cmp	#0,	r12	;r3 As==00
    6496:	04 24       	jz	$+10     	;abs 0x64a0

00006498 <.L33>:
    chSysHalt("SV#6");
    6498:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    649c:	b0 12 26 66 	call	#26150		;#0x6626

000064a0 <.L34>:
  }
  _dbg_enter_lock();
    64a0:	92 43 a4 51 	mov	#1,	&0x51a4	;r3 As==01

000064a4 <.Loc.133.2>:
}
    64a4:	03 43       	nop			
    64a6:	30 41       	ret			

000064a8 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    64a8:	1d 42 a2 51 	mov	&0x51a2,r13	;0x51a2
    64ac:	4c 43       	clr.b	r12		;
    64ae:	0c 9d       	cmp	r13,	r12	;
    64b0:	05 34       	jge	$+12     	;abs 0x64bc

000064b2 <.Loc.142.2>:
    64b2:	1d 42 a4 51 	mov	&0x51a4,r13	;0x51a4
    64b6:	4c 43       	clr.b	r12		;
    64b8:	0c 9d       	cmp	r13,	r12	;
    64ba:	04 38       	jl	$+10     	;abs 0x64c4

000064bc <.L36>:
    chSysHalt("SV#7");
    64bc:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    64c0:	b0 12 26 66 	call	#26150		;#0x6626

000064c4 <.L37>:
  }
  _dbg_leave_lock();
    64c4:	82 43 a4 51 	mov	#0,	&0x51a4	;r3 As==00

000064c8 <.Loc.146.2>:
}
    64c8:	03 43       	nop			
    64ca:	30 41       	ret			

000064cc <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    64cc:	b0 12 10 64 	call	#25616		;#0x6410

000064d0 <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    64d0:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    64d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    64d6:	04 38       	jl	$+10     	;abs 0x64e0

000064d8 <.Loc.156.2>:
    64d8:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    64dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    64de:	04 24       	jz	$+10     	;abs 0x64e8

000064e0 <.L39>:
    chSysHalt("SV#8");
    64e0:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    64e4:	b0 12 26 66 	call	#26150		;#0x6626

000064e8 <.L40>:
  }
  nil.isr_cnt++;
    64e8:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    64ec:	1c 53       	inc	r12		;
    64ee:	82 4c a2 51 	mov	r12,	&0x51a2	;

000064f2 <.Loc.160.2>:
  port_unlock_from_isr();
    64f2:	b0 12 14 64 	call	#25620		;#0x6414

000064f6 <.Loc.161.2>:
}
    64f6:	03 43       	nop			
    64f8:	30 41       	ret			

000064fa <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    64fa:	b0 12 10 64 	call	#25616		;#0x6410

000064fe <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    64fe:	1d 42 a2 51 	mov	&0x51a2,r13	;0x51a2
    6502:	4c 43       	clr.b	r12		;
    6504:	0c 9d       	cmp	r13,	r12	;
    6506:	04 34       	jge	$+10     	;abs 0x6510

00006508 <.Loc.171.2>:
    6508:	1c 42 a4 51 	mov	&0x51a4,r12	;0x51a4
    650c:	0c 93       	cmp	#0,	r12	;r3 As==00
    650e:	04 24       	jz	$+10     	;abs 0x6518

00006510 <.L42>:
    chSysHalt("SV#9");
    6510:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    6514:	b0 12 26 66 	call	#26150		;#0x6626

00006518 <.L43>:
  }
  nil.isr_cnt--;
    6518:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    651c:	3c 53       	add	#-1,	r12	;r3 As==11
    651e:	82 4c a2 51 	mov	r12,	&0x51a2	;

00006522 <.Loc.175.2>:
  port_unlock_from_isr();
    6522:	b0 12 14 64 	call	#25620		;#0x6414

00006526 <.Loc.176.2>:
}
    6526:	03 43       	nop			
    6528:	30 41       	ret			

0000652a <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    652a:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    652e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6530:	05 38       	jl	$+12     	;abs 0x653c

00006532 <.Loc.188.2>:
    6532:	1d 42 a4 51 	mov	&0x51a4,r13	;0x51a4
    6536:	4c 43       	clr.b	r12		;
    6538:	0c 9d       	cmp	r13,	r12	;
    653a:	04 38       	jl	$+10     	;abs 0x6544

0000653c <.L45>:
    chSysHalt("SV#10");
    653c:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    6540:	b0 12 26 66 	call	#26150		;#0x6626

00006544 <.L47>:
  }
}
    6544:	03 43       	nop			
    6546:	30 41       	ret			

00006548 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6548:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    654c:	0c 93       	cmp	#0,	r12	;r3 As==00
    654e:	05 20       	jnz	$+12     	;abs 0x655a

00006550 <.Loc.203.2>:
    6550:	1d 42 a4 51 	mov	&0x51a4,r13	;0x51a4
    6554:	4c 43       	clr.b	r12		;
    6556:	0c 9d       	cmp	r13,	r12	;
    6558:	04 38       	jl	$+10     	;abs 0x6562

0000655a <.L49>:
    chSysHalt("SV#11");
    655a:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    655e:	b0 12 26 66 	call	#26150		;#0x6626

00006562 <.L51>:
  }
}
    6562:	03 43       	nop			
    6564:	30 41       	ret			

00006566 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    6566:	21 82       	sub	#4,	r1	;r2 As==10

00006568 <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    6568:	82 43 a2 51 	mov	#0,	&0x51a2	;r3 As==00

0000656c <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    656c:	82 43 a4 51 	mov	#0,	&0x51a4	;r3 As==00

00006570 <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    6570:	b1 40 a8 51 	mov	#20904,	2(r1)	;#0x51a8
    6574:	02 00 

00006576 <.Loc.234.2>:
  tcp = nil_thd_configs;
    6576:	b1 40 0e 51 	mov	#20750,	0(r1)	;#0x510e
    657a:	00 00 

0000657c <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    657c:	2d 3c       	jmp	$+92     	;abs 0x65d8

0000657e <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    657e:	2c 41       	mov	@r1,	r12	;
    6580:	2d 4c       	mov	@r12,	r13	;
    6582:	1c 41 02 00 	mov	2(r1),	r12	;
    6586:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000658a <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    658a:	2c 41       	mov	@r1,	r12	;
    658c:	1c 4c 02 00 	mov	2(r12),	r12	;
    6590:	0d 4c       	mov	r12,	r13	;
    6592:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    6596:	1c 41 02 00 	mov	2(r1),	r12	;
    659a:	8c 4d 00 00 	mov	r13,	0(r12)	;
    659e:	1c 41 02 00 	mov	2(r1),	r12	;
    65a2:	2c 4c       	mov	@r12,	r12	;
    65a4:	2d 41       	mov	@r1,	r13	;
    65a6:	1d 4d 06 00 	mov	6(r13),	r13	;
    65aa:	8c 4d 00 00 	mov	r13,	0(r12)	;
    65ae:	1c 41 02 00 	mov	2(r1),	r12	;
    65b2:	2c 4c       	mov	@r12,	r12	;
    65b4:	2d 41       	mov	@r1,	r13	;
    65b6:	1d 4d 08 00 	mov	8(r13),	r13	;
    65ba:	8c 4d 02 00 	mov	r13,	2(r12)	;
    65be:	1c 41 02 00 	mov	2(r1),	r12	;
    65c2:	2c 4c       	mov	@r12,	r12	;
    65c4:	3d 40 3e 69 	mov	#26942,	r13	;#0x693e
    65c8:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

000065cc <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    65cc:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    65d0:	02 00 

000065d2 <.Loc.247.2>:
    tcp++;
    65d2:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    65d6:	00 00 

000065d8 <.L53>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    65d8:	b1 90 b4 51 	cmp	#20916,	2(r1)	;#0x51b4
    65dc:	02 00 
    65de:	cf 2b       	jnc	$-96     	;abs 0x657e

000065e0 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    65e0:	1c 41 02 00 	mov	2(r1),	r12	;
    65e4:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    65e8:	0a 00 

000065ea <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    65ea:	b0 12 20 64 	call	#25632		;#0x6420
    65ee:	b0 12 28 64 	call	#25640		;#0x6428

000065f2 <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    65f2:	92 43 a4 51 	mov	#1,	&0x51a4	;r3 As==01

000065f6 <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    65f6:	b0 12 10 69 	call	#26896		;#0x6910

000065fa <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    65fa:	b0 12 f6 63 	call	#25590		;#0x63f6

000065fe <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    65fe:	b2 40 a8 51 	mov	#20904,	&0x519e	;#0x51a8
    6602:	9e 51 
    6604:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    6608:	82 4c 9c 51 	mov	r12,	&0x519c	;

0000660c <.Loc.275.2>:
  port_switch(nil.current, tp);
    660c:	1c 42 9c 51 	mov	&0x519c,r12	;0x519c
    6610:	1d 41 02 00 	mov	2(r1),	r13	;
    6614:	b0 12 30 69 	call	#26928		;#0x6930

00006618 <.Loc.276.2>:
  chSysUnlock();
    6618:	b0 12 64 64 	call	#25700		;#0x6464
    661c:	b0 12 06 64 	call	#25606		;#0x6406

00006620 <.Loc.277.2>:
}
    6620:	03 43       	nop			
    6622:	21 52       	add	#4,	r1	;r2 As==10
    6624:	30 41       	ret			

00006626 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    6626:	21 83       	decd	r1		;

00006628 <L0>:
    6628:	81 4c 00 00 	mov	r12,	0(r1)	;

0000662c <.Loc.293.2>:

  port_disable();
    662c:	b0 12 18 64 	call	#25624		;#0x6418

00006630 <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    6630:	a2 41 a6 51 	mov	@r1,	&0x51a6	;

00006634 <.L56>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    6634:	ff 3f       	jmp	$+0      	;abs 0x6634

00006636 <chSysTimerHandlerI>:
    6636:	21 83       	decd	r1		;

00006638 <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    6638:	b0 12 2a 65 	call	#25898		;#0x652a

0000663c <.Loc.320.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    663c:	b1 40 a8 51 	mov	#20904,	0(r1)	;#0x51a8
    6640:	00 00 

00006642 <.Loc.321.2>:
  nil.systime++;
    6642:	1c 42 a0 51 	mov	&0x51a0,r12	;0x51a0
    6646:	1c 53       	inc	r12		;
    6648:	82 4c a0 51 	mov	r12,	&0x51a0	;

0000664c <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    664c:	2c 41       	mov	@r1,	r12	;
    664e:	1c 4c 06 00 	mov	6(r12),	r12	;
    6652:	0c 93       	cmp	#0,	r12	;r3 As==00
    6654:	25 24       	jz	$+76     	;abs 0x66a0

00006656 <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    6656:	2c 41       	mov	@r1,	r12	;
    6658:	1c 4c 06 00 	mov	6(r12),	r12	;
    665c:	3c 53       	add	#-1,	r12	;r3 As==11
    665e:	2d 41       	mov	@r1,	r13	;
    6660:	8d 4c 06 00 	mov	r12,	6(r13)	;
    6664:	0c 93       	cmp	#0,	r12	;r3 As==00
    6666:	1c 20       	jnz	$+58     	;abs 0x66a0

00006668 <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    6668:	2c 41       	mov	@r1,	r12	;
    666a:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    666e:	7c 90 03 00 	cmp.b	#3,	r12	;
    6672:	08 20       	jnz	$+18     	;abs 0x6684

00006674 <.Loc.334.2>:
          tp->u1.semp->cnt++;
    6674:	2c 41       	mov	@r1,	r12	;
    6676:	1c 4c 04 00 	mov	4(r12),	r12	;
    667a:	2d 4c       	mov	@r12,	r13	;
    667c:	1d 53       	inc	r13		;
    667e:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6682:	0a 3c       	jmp	$+22     	;abs 0x6698

00006684 <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    6684:	2c 41       	mov	@r1,	r12	;
    6686:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    668a:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    668c:	05 20       	jnz	$+12     	;abs 0x6698

0000668e <.Loc.337.2>:
          *tp->u1.trp = NULL;
    668e:	2c 41       	mov	@r1,	r12	;
    6690:	1c 4c 04 00 	mov	4(r12),	r12	;
    6694:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006698 <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    6698:	3d 43       	mov	#-1,	r13	;r3 As==11
    669a:	2c 41       	mov	@r1,	r12	;
    669c:	b0 12 c4 66 	call	#26308		;#0x66c4

000066a0 <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    66a0:	b0 12 a8 64 	call	#25768		;#0x64a8
    66a4:	b0 12 14 64 	call	#25620		;#0x6414

000066a8 <.Loc.346.2>:
    tp++;
    66a8:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    66ac:	00 00 

000066ae <.Loc.347.2>:
    chSysLockFromISR();
    66ae:	b0 12 10 64 	call	#25616		;#0x6410
    66b2:	b0 12 86 64 	call	#25734		;#0x6486

000066b6 <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    66b6:	b1 90 b4 51 	cmp	#20916,	0(r1)	;#0x51b4
    66ba:	00 00 
    66bc:	c7 2b       	jnc	$-112    	;abs 0x664c

000066be <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    66be:	03 43       	nop			
    66c0:	21 53       	incd	r1		;
    66c2:	30 41       	ret			

000066c4 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    66c4:	21 82       	sub	#4,	r1	;r2 As==10

000066c6 <L0>:
    66c6:	81 4c 02 00 	mov	r12,	2(r1)	;
    66ca:	81 4d 00 00 	mov	r13,	0(r1)	;

000066ce <.Loc.535.2>:

  chDbgCheckClassI();
    66ce:	b0 12 2a 65 	call	#25898		;#0x652a

000066d2 <.Loc.540.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    66d2:	1c 41 02 00 	mov	2(r1),	r12	;
    66d6:	ac 41 04 00 	mov	@r1,	4(r12)	;

000066da <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    66da:	1c 41 02 00 	mov	2(r1),	r12	;
    66de:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000066e2 <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    66e2:	1c 41 02 00 	mov	2(r1),	r12	;
    66e6:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

000066ea <.Loc.543.2>:
  if (tp < nil.next) {
    66ea:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    66ee:	81 9c 02 00 	cmp	r12,	2(r1)	;
    66f2:	03 2c       	jc	$+8      	;abs 0x66fa

000066f4 <.Loc.544.2>:
    nil.next = tp;
    66f4:	92 41 02 00 	mov	2(r1),	&0x519e	;
    66f8:	9e 51 

000066fa <.L77>:
  }
  return tp;
    66fa:	1c 41 02 00 	mov	2(r1),	r12	;

000066fe <.Loc.547.2>:
}
    66fe:	21 52       	add	#4,	r1	;r2 As==10
    6700:	30 41       	ret			

00006702 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    6702:	1d 42 9c 51 	mov	&0x519c,r13	;0x519c
    6706:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    670a:	0c ed       	xor	r13,	r12	;
    670c:	0d 43       	clr	r13		;
    670e:	0d 8c       	sub	r12,	r13	;
    6710:	0c dd       	bis	r13,	r12	;
    6712:	5c 03       	rrum	#1,	r12	;
    6714:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    6718:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000671c <.Loc.565.2>:
}
    671c:	30 41       	ret			

0000671e <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    671e:	21 83       	decd	r1		;

00006720 <.LCFI8>:
  thread_t *otp = nil.current;
    6720:	91 42 9c 51 	mov	&0x519c,0(r1)	;0x519c
    6724:	00 00 

00006726 <.Loc.577.2>:

  nil.current = nil.next;
    6726:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    672a:	82 4c 9c 51 	mov	r12,	&0x519c	;

0000672e <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    672e:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    6732:	2d 41       	mov	@r1,	r13	;
    6734:	b0 12 30 69 	call	#26928		;#0x6930

00006738 <.Loc.582.2>:
}
    6738:	03 43       	nop			
    673a:	21 53       	incd	r1		;
    673c:	30 41       	ret			

0000673e <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    673e:	31 82       	sub	#8,	r1	;r2 As==11

00006740 <.LCFI9>:
    6740:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    6744:	81 4d 00 00 	mov	r13,	0(r1)	;

00006748 <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    6748:	91 42 9c 51 	mov	&0x519c,4(r1)	;0x519c
    674c:	04 00 

0000674e <.Loc.618.2>:

  chDbgCheckClassS();
    674e:	b0 12 48 65 	call	#25928		;#0x6548

00006752 <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    6752:	1c 41 04 00 	mov	4(r1),	r12	;
    6756:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    675a:	02 00 

0000675c <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    675c:	1c 41 04 00 	mov	4(r1),	r12	;
    6760:	ac 41 06 00 	mov	@r1,	6(r12)	;

00006764 <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    6764:	b1 40 a8 51 	mov	#20904,	6(r1)	;#0x51a8
    6768:	06 00 

0000676a <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    676a:	1c 41 06 00 	mov	6(r1),	r12	;
    676e:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    6772:	0c 93       	cmp	#0,	r12	;r3 As==00
    6774:	12 20       	jnz	$+38     	;abs 0x679a

00006776 <.Loc.667.2>:
      nil.current = nil.next = ntp;
    6776:	92 41 06 00 	mov	6(r1),	&0x519e	;
    677a:	9e 51 
    677c:	1c 42 9e 51 	mov	&0x519e,r12	;0x519e
    6780:	82 4c 9c 51 	mov	r12,	&0x519c	;

00006784 <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    6784:	1d 41 04 00 	mov	4(r1),	r13	;
    6788:	1c 41 06 00 	mov	6(r1),	r12	;
    678c:	b0 12 30 69 	call	#26928		;#0x6930

00006790 <.Loc.672.2>:
      return nil.current->u1.msg;
    6790:	1c 42 9c 51 	mov	&0x519c,r12	;0x519c
    6794:	1c 4c 04 00 	mov	4(r12),	r12	;
    6798:	04 3c       	jmp	$+10     	;abs 0x67a2

0000679a <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    679a:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    679e:	06 00 

000067a0 <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    67a0:	e4 3f       	jmp	$-54     	;abs 0x676a

000067a2 <.L89>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    67a2:	31 52       	add	#8,	r1	;r2 As==11
    67a4:	30 41       	ret			

000067a6 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    67a6:	31 80 06 00 	sub	#6,	r1	;

000067aa <L0>:
    67aa:	81 4c 02 00 	mov	r12,	2(r1)	;
    67ae:	81 4d 00 00 	mov	r13,	0(r1)	;

000067b2 <.Loc.717.2>:

  if (*trp != NULL) {
    67b2:	1c 41 02 00 	mov	2(r1),	r12	;
    67b6:	2c 4c       	mov	@r12,	r12	;
    67b8:	0c 93       	cmp	#0,	r12	;r3 As==00
    67ba:	0d 24       	jz	$+28     	;abs 0x67d6

000067bc <.LBB3>:
    thread_reference_t tr = *trp;
    67bc:	1c 41 02 00 	mov	2(r1),	r12	;
    67c0:	a1 4c 04 00 	mov	@r12,	4(r1)	;

000067c4 <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    67c4:	1c 41 02 00 	mov	2(r1),	r12	;
    67c8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000067cc <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    67cc:	2d 41       	mov	@r1,	r13	;
    67ce:	1c 41 04 00 	mov	4(r1),	r12	;
    67d2:	b0 12 c4 66 	call	#26308		;#0x66c4

000067d6 <.L94>:
  }
}
    67d6:	03 43       	nop			
    67d8:	31 50 06 00 	add	#6,	r1	;
    67dc:	30 41       	ret			

000067de <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    67de:	21 83       	decd	r1		;

000067e0 <.LCFI12>:
    67e0:	81 4c 00 00 	mov	r12,	0(r1)	;

000067e4 <.Loc.736.2>:

  chSysLock();
    67e4:	b0 12 fe 63 	call	#25598		;#0x63fe
    67e8:	b0 12 44 64 	call	#25668		;#0x6444

000067ec <.Loc.737.2>:
  chThdSleepS(timeout);
    67ec:	2d 41       	mov	@r1,	r13	;
    67ee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    67f0:	b0 12 3e 67 	call	#26430		;#0x673e

000067f4 <.Loc.738.2>:
  chSysUnlock();
    67f4:	b0 12 64 64 	call	#25700		;#0x6464
    67f8:	b0 12 06 64 	call	#25606		;#0x6406

000067fc <.Loc.739.2>:
}
    67fc:	03 43       	nop			
    67fe:	21 53       	incd	r1		;
    6800:	30 41       	ret			

00006802 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    6802:	31 80 06 00 	sub	#6,	r1	;

00006806 <.LCFI15>:
    6806:	81 4c 02 00 	mov	r12,	2(r1)	;
    680a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000680e <.Loc.807.2>:

  chDbgCheckClassS();
    680e:	b0 12 48 65 	call	#25928		;#0x6548

00006812 <.Loc.812.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    6812:	1c 41 02 00 	mov	2(r1),	r12	;
    6816:	a1 4c 04 00 	mov	@r12,	4(r1)	;

0000681a <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    681a:	4c 43       	clr.b	r12		;
    681c:	1c 91 04 00 	cmp	4(r1),	r12	;
    6820:	17 38       	jl	$+48     	;abs 0x6850

00006822 <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    6822:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6826:	02 20       	jnz	$+6      	;abs 0x682c

00006828 <.Loc.815.2>:
      return MSG_TIMEOUT;
    6828:	3c 43       	mov	#-1,	r12	;r3 As==11
    682a:	1a 3c       	jmp	$+54     	;abs 0x6860

0000682c <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    682c:	1d 41 04 00 	mov	4(r1),	r13	;
    6830:	3d 53       	add	#-1,	r13	;r3 As==11
    6832:	1c 41 02 00 	mov	2(r1),	r12	;
    6836:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000683a <.Loc.818.2>:
    nil.current->u1.semp = sp;
    683a:	1c 42 9c 51 	mov	&0x519c,r12	;0x519c
    683e:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6842:	04 00 

00006844 <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    6844:	2d 41       	mov	@r1,	r13	;
    6846:	7c 40 03 00 	mov.b	#3,	r12	;
    684a:	b0 12 3e 67 	call	#26430		;#0x673e
    684e:	08 3c       	jmp	$+18     	;abs 0x6860

00006850 <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    6850:	1d 41 04 00 	mov	4(r1),	r13	;
    6854:	3d 53       	add	#-1,	r13	;r3 As==11
    6856:	1c 41 02 00 	mov	2(r1),	r12	;
    685a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000685e <.Loc.822.2>:
  return MSG_OK;
    685e:	4c 43       	clr.b	r12		;

00006860 <.L102>:
}
    6860:	31 50 06 00 	add	#6,	r1	;
    6864:	30 41       	ret			

00006866 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6866:	32 c2       	dint			

00006868 <.Loc.348.1>:
  asm volatile("nop");
    6868:	03 43       	nop			

0000686a <L0>:
}
    686a:	03 43       	nop			
    686c:	30 41       	ret			

0000686e <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    686e:	03 43       	nop			

00006870 <.Loc.356.1>:
  _enable_interrupts();
    6870:	32 d2       	eint			
    6872:	03 43       	nop			

00006874 <.Loc.357.1>:
}
    6874:	03 43       	nop			
    6876:	30 41       	ret			

00006878 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    6878:	31 80 06 00 	sub	#6,	r1	;

0000687c <.LCFI0>:
    687c:	81 4c 02 00 	mov	r12,	2(r1)	;
    6880:	81 4d 00 00 	mov	r13,	0(r1)	;

00006884 <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    6884:	b0 12 2a 65 	call	#25898		;#0x652a

00006888 <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    6888:	2c 41       	mov	@r1,	r12	;
    688a:	1c 51 02 00 	add	2(r1),	r12	;
    688e:	0d 4c       	mov	r12,	r13	;
    6890:	3d 53       	add	#-1,	r13	;r3 As==11
    6892:	4c 43       	clr.b	r12		;
    6894:	2c 81       	sub	@r1,	r12	;
    6896:	0e 4d       	mov	r13,	r14	;
    6898:	0e fc       	and	r12,	r14	;
    689a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000689e <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    689e:	1c 42 c0 51 	mov	&0x51c0,r12	;0x51c0
    68a2:	2c 51       	add	@r1,	r12	;
    68a4:	0d 4c       	mov	r12,	r13	;
    68a6:	3d 53       	add	#-1,	r13	;r3 As==11
    68a8:	4c 43       	clr.b	r12		;
    68aa:	2c 81       	sub	@r1,	r12	;
    68ac:	0c fd       	and	r13,	r12	;
    68ae:	81 4c 04 00 	mov	r12,	4(r1)	;

000068b2 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    68b2:	1c 42 c2 51 	mov	&0x51c2,r12	;0x51c2
    68b6:	1d 41 04 00 	mov	4(r1),	r13	;
    68ba:	0c 8d       	sub	r13,	r12	;
    68bc:	1c 91 02 00 	cmp	2(r1),	r12	;
    68c0:	02 2c       	jc	$+6      	;abs 0x68c6

000068c2 <.Loc.118.2>:
    return NULL;
    68c2:	4c 43       	clr.b	r12		;
    68c4:	08 3c       	jmp	$+18     	;abs 0x68d6

000068c6 <.L5>:
  }
  nextmem = p + size;
    68c6:	1c 41 04 00 	mov	4(r1),	r12	;
    68ca:	1c 51 02 00 	add	2(r1),	r12	;
    68ce:	82 4c c0 51 	mov	r12,	&0x51c0	;

000068d2 <.Loc.122.2>:

  return p;
    68d2:	1c 41 04 00 	mov	4(r1),	r12	;

000068d6 <.L6>:
}
    68d6:	31 50 06 00 	add	#6,	r1	;
    68da:	30 41       	ret			

000068dc <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    68dc:	31 80 06 00 	Address 0x00000000000068de is out of bounds.
sub	#65535,	r1	;#0xffff

000068de <L0>:
    68de:	06 00       	mova	@r0,	r6	;

000068e0 <.LCFI1>:
    68e0:	81 4c 02 00 	mov	r12,	2(r1)	;
    68e4:	81 4d 00 00 	mov	r13,	0(r1)	;

000068e8 <.Loc.140.2>:
  void *p;

  chSysLock();
    68e8:	b0 12 66 68 	call	#26726		;#0x6866
    68ec:	b0 12 44 64 	call	#25668		;#0x6444

000068f0 <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    68f0:	2d 41       	mov	@r1,	r13	;
    68f2:	1c 41 02 00 	mov	2(r1),	r12	;
    68f6:	b0 12 78 68 	call	#26744		;#0x6878
    68fa:	81 4c 04 00 	mov	r12,	4(r1)	;

000068fe <.Loc.142.2>:
  chSysUnlock();
    68fe:	b0 12 64 64 	call	#25700		;#0x6464
    6902:	b0 12 6e 68 	call	#26734		;#0x686e

00006906 <.Loc.144.2>:

  return p;
    6906:	1c 41 04 00 	mov	4(r1),	r12	;

0000690a <.Loc.145.2>:
}
    690a:	31 50 06 00 	add	#6,	r1	;
    690e:	30 41       	ret			

00006910 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    6910:	b2 40 dc 68 	mov	#26844,	&0x51c4	;#0x68dc
    6914:	c4 51 

00006916 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6916:	82 43 c6 51 	mov	#0,	&0x51c6	;r3 As==00

0000691a <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    691a:	82 43 c8 51 	mov	#0,	&0x51c8	;r3 As==00

0000691e <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    691e:	92 43 ca 51 	mov	#1,	&0x51ca	;r3 As==01

00006922 <.Loc.117.1>:
#endif
}
    6922:	03 43       	nop			
    6924:	30 41       	ret			

00006926 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6926:	03 43       	nop			

00006928 <.Loc.356.1>:
  _enable_interrupts();
    6928:	32 d2       	eint			
    692a:	03 43       	nop			

0000692c <.Loc.357.1>:
}
    692c:	03 43       	nop			
    692e:	30 41       	ret			

00006930 <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6930:	6a 15       	pushm	#7,	r10	;16-bit words

00006932 <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    6932:	8d 41 00 00 	mov	r1,	0(r13)	;

00006936 <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    6936:	21 4c       	mov	@r12,	r1	;

00006938 <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    6938:	64 17       	popm	#7,	r10	;16-bit words

0000693a <.Loc.83.2>:
  asm volatile ("ret");
    693a:	30 41       	ret			

0000693c <.Loc.85.2>:
#endif
}
    693c:	03 43       	nop			

0000693e <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    693e:	b0 12 64 64 	call	#25700		;#0x6464
    6942:	b0 12 26 69 	call	#26918		;#0x6926

00006946 <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    6946:	0c 45       	mov	r5,	r12	;

00006948 <.Loc.101.2>:
  asm volatile ("call R4");
    6948:	84 12       	call	r4		;

0000694a <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    694a:	4c 43       	clr.b	r12		;
    694c:	b0 12 26 66 	call	#26150		;#0x6626

00006950 <.Loc.109.2>:
#endif
}
    6950:	03 43       	nop			
    6952:	30 41       	ret			

00006954 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    6954:	31 82       	sub	#8,	r1	;r2 As==11

00006956 <.LCFI0>:
    6956:	81 4c 02 00 	mov	r12,	2(r1)	;
    695a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000695e <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    695e:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6962:	04 00 

00006964 <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    6964:	1c 41 02 00 	mov	2(r1),	r12	;
    6968:	2c 4c       	mov	@r12,	r12	;
    696a:	0c 93       	cmp	#0,	r12	;r3 As==00
    696c:	1d 34       	jge	$+60     	;abs 0x69a8

0000696e <.LBB2>:
    thread_t *tp = nil.threads;
    696e:	b1 40 a8 51 	mov	#20904,	6(r1)	;#0x51a8
    6972:	06 00 

00006974 <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6974:	1c 41 06 00 	mov	6(r1),	r12	;
    6978:	1c 4c 04 00 	mov	4(r12),	r12	;
    697c:	1c 91 04 00 	cmp	4(r1),	r12	;
    6980:	0f 20       	jnz	$+32     	;abs 0x69a0

00006982 <.Loc.67.1>:
        sp->cnt++;
    6982:	1c 41 04 00 	mov	4(r1),	r12	;
    6986:	2c 4c       	mov	@r12,	r12	;
    6988:	1c 53       	inc	r12		;
    698a:	0d 4c       	mov	r12,	r13	;
    698c:	1c 41 04 00 	mov	4(r1),	r12	;
    6990:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006994 <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    6994:	2d 41       	mov	@r1,	r13	;
    6996:	1c 41 06 00 	mov	6(r1),	r12	;
    699a:	b0 12 c4 66 	call	#26308		;#0x66c4

0000699e <.Loc.72.1>:
        return;
    699e:	04 3c       	jmp	$+10     	;abs 0x69a8

000069a0 <.L3>:
      }
      tp++;
    69a0:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    69a4:	06 00 

000069a6 <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    69a6:	e6 3f       	jmp	$-50     	;abs 0x6974

000069a8 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    69a8:	31 52       	add	#8,	r1	;r2 As==11
    69aa:	30 41       	ret			

000069ac <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    69ac:	03 43       	nop			
    69ae:	30 41       	ret			

000069b0 <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    69b0:	b0 12 ac 69 	call	#27052		;#0x69ac

000069b4 <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    69b4:	b0 12 22 73 	call	#29474		;#0x7322

000069b8 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    69b8:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    69bc:	b0 12 f0 7a 	call	#31472		;#0x7af0

000069c0 <.Loc.83.2>:
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
    69c0:	b0 12 06 70 	call	#28678		;#0x7006

000069c4 <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    69c4:	b0 12 f8 71 	call	#29176		;#0x71f8

000069c8 <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    69c8:	b0 12 c0 80 	call	#32960		;#0x80c0

000069cc <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    69cc:	b0 12 d4 69 	call	#27092		;#0x69d4

000069d0 <.Loc.145.2>:
#endif
}
    69d0:	03 43       	nop			
    69d2:	30 41       	ret			

000069d4 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    69d4:	b0 12 bc 73 	call	#29628		;#0x73bc

000069d8 <.Loc.63.2>:
}
    69d8:	03 43       	nop			
    69da:	30 41       	ret			

000069dc <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    69dc:	32 c2       	dint			

000069de <.Loc.348.1>:
  asm volatile("nop");
    69de:	03 43       	nop			

000069e0 <.Loc.349.1>:
}
    69e0:	03 43       	nop			
    69e2:	30 41       	ret			

000069e4 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    69e4:	03 43       	nop			

000069e6 <.Loc.356.1>:
  _enable_interrupts();
    69e6:	32 d2       	eint			
    69e8:	03 43       	nop			

000069ea <.Loc.357.1>:
}
    69ea:	03 43       	nop			
    69ec:	30 41       	ret			

000069ee <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    69ee:	b0 12 dc 69 	call	#27100		;#0x69dc
    69f2:	b0 12 44 64 	call	#25668		;#0x6444

000069f6 <.Loc.505.2>:
}
    69f6:	03 43       	nop			
    69f8:	30 41       	ret			

000069fa <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    69fa:	b0 12 64 64 	call	#25700		;#0x6464
    69fe:	b0 12 e4 69 	call	#27108		;#0x69e4

00006a02 <.Loc.516.2>:
}
    6a02:	03 43       	nop			
    6a04:	30 41       	ret			

00006a06 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6a06:	1c 42 a0 51 	mov	&0x51a0,r12	;0x51a0

00006a0a <.Loc.630.2>:
}
    6a0a:	30 41       	ret			

00006a0c <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6a0c:	21 83       	decd	r1		;

00006a0e <.LCFI0>:
    6a0e:	81 4c 00 00 	mov	r12,	0(r1)	;

00006a12 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6a12:	2c 41       	mov	@r1,	r12	;
    6a14:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006a18 <.Loc.768.2>:
}
    6a18:	03 43       	nop			
    6a1a:	21 53       	incd	r1		;
    6a1c:	30 41       	ret			

00006a1e <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6a1e:	21 82       	sub	#4,	r1	;r2 As==10

00006a20 <.LCFI1>:
    6a20:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a24:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a28 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6a28:	1c 41 02 00 	mov	2(r1),	r12	;
    6a2c:	2d 41       	mov	@r1,	r13	;
    6a2e:	b0 12 02 68 	call	#26626		;#0x6802

00006a32 <.Loc.797.2>:
}
    6a32:	21 52       	add	#4,	r1	;r2 As==10
    6a34:	30 41       	ret			

00006a36 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6a36:	31 82       	sub	#8,	r1	;r2 As==11

00006a38 <.LCFI2>:
    6a38:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a3c:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a40:	81 4e 02 00 	mov	r14,	2(r1)	;
    6a44:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a48 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6a48:	1c 41 06 00 	mov	6(r1),	r12	;
    6a4c:	b0 12 0c 6a 	call	#27148		;#0x6a0c

00006a50 <.Loc.59.3>:
  iqp->q_counter = 0;
    6a50:	1c 41 06 00 	mov	6(r1),	r12	;
    6a54:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006a58 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6a58:	1c 41 06 00 	mov	6(r1),	r12	;
    6a5c:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6a60:	04 00 

00006a62 <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    6a62:	1c 41 06 00 	mov	6(r1),	r12	;
    6a66:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6a6a:	0a 00 

00006a6c <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6a6c:	1c 41 06 00 	mov	6(r1),	r12	;
    6a70:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6a74:	08 00 

00006a76 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    6a76:	1d 41 04 00 	mov	4(r1),	r13	;
    6a7a:	1d 51 02 00 	add	2(r1),	r13	;
    6a7e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a82:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006a86 <.Loc.64.3>:
  iqp->q_notify  = infy;
    6a86:	1c 41 06 00 	mov	6(r1),	r12	;
    6a8a:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006a8e <.Loc.65.3>:
  iqp->q_link    = link;
    6a8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a92:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6a96:	0e 00 

00006a98 <.Loc.66.3>:
}
    6a98:	03 43       	nop			
    6a9a:	31 52       	add	#8,	r1	;r2 As==11
    6a9c:	30 41       	ret			

00006a9e <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    6a9e:	21 82       	sub	#4,	r1	;r2 As==10

00006aa0 <.LCFI4>:
    6aa0:	81 4c 02 00 	mov	r12,	2(r1)	;
    6aa4:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006aa8 <.Loc.104.3>:

  osalDbgCheckClassI();
    6aa8:	b0 12 2a 65 	call	#25898		;#0x652a

00006aac <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    6aac:	1c 41 02 00 	mov	2(r1),	r12	;
    6ab0:	1d 4c 08 00 	mov	8(r12),	r13	;
    6ab4:	1c 41 02 00 	mov	2(r1),	r12	;
    6ab8:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6abc:	0d 9c       	cmp	r12,	r13	;
    6abe:	08 20       	jnz	$+18     	;abs 0x6ad0

00006ac0 <.Loc.106.3>:
    6ac0:	1c 41 02 00 	mov	2(r1),	r12	;
    6ac4:	1c 4c 02 00 	mov	2(r12),	r12	;
    6ac8:	0c 93       	cmp	#0,	r12	;r3 As==00
    6aca:	02 24       	jz	$+6      	;abs 0x6ad0

00006acc <.Loc.106.3>:
    6acc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ace:	01 3c       	jmp	$+4      	;abs 0x6ad2

00006ad0 <.L13>:
    6ad0:	4c 43       	clr.b	r12		;

00006ad2 <.L14>:
    6ad2:	5c f3       	and.b	#1,	r12	;r3 As==01
    6ad4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6ad8:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ada:	02 24       	jz	$+6      	;abs 0x6ae0

00006adc <.Loc.107.3>:
    return MSG_TIMEOUT;
    6adc:	3c 43       	mov	#-1,	r12	;r3 As==11
    6ade:	2f 3c       	jmp	$+96     	;abs 0x6b3e

00006ae0 <.L15>:
  }

  iqp->q_counter++;
    6ae0:	1c 41 02 00 	mov	2(r1),	r12	;
    6ae4:	1c 4c 02 00 	mov	2(r12),	r12	;
    6ae8:	0d 4c       	mov	r12,	r13	;
    6aea:	1d 53       	inc	r13		;
    6aec:	1c 41 02 00 	mov	2(r1),	r12	;
    6af0:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006af4 <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    6af4:	1c 41 02 00 	mov	2(r1),	r12	;
    6af8:	1c 4c 08 00 	mov	8(r12),	r12	;
    6afc:	0e 4c       	mov	r12,	r14	;
    6afe:	1e 53       	inc	r14		;
    6b00:	1d 41 02 00 	mov	2(r1),	r13	;
    6b04:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6b08:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6b0c:	00 00 

00006b0e <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6b0e:	1c 41 02 00 	mov	2(r1),	r12	;
    6b12:	1d 4c 08 00 	mov	8(r12),	r13	;
    6b16:	1c 41 02 00 	mov	2(r1),	r12	;
    6b1a:	1c 4c 06 00 	mov	6(r12),	r12	;
    6b1e:	0d 9c       	cmp	r12,	r13	;
    6b20:	08 28       	jnc	$+18     	;abs 0x6b32

00006b22 <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    6b22:	1c 41 02 00 	mov	2(r1),	r12	;
    6b26:	1d 4c 04 00 	mov	4(r12),	r13	;
    6b2a:	1c 41 02 00 	mov	2(r1),	r12	;
    6b2e:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006b32 <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    6b32:	1c 41 02 00 	mov	2(r1),	r12	;
    6b36:	4d 43       	clr.b	r13		;
    6b38:	b0 12 54 69 	call	#26964		;#0x6954

00006b3c <.Loc.118.3>:

  return MSG_OK;
    6b3c:	4c 43       	clr.b	r12		;

00006b3e <.L16>:
}
    6b3e:	21 52       	add	#4,	r1	;r2 As==10
    6b40:	30 41       	ret			

00006b42 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    6b42:	31 82       	sub	#8,	r1	;r2 As==11

00006b44 <.LCFI5>:
    6b44:	81 4c 02 00 	Address 0x0000000000006b46 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006b46 <L0>:
    6b46:	02 00       	mova	@r0,	r2	;
    6b48:	81 4d 00 00 	mov	r13,	0(r1)	;

00006b4c <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6b4c:	b0 12 ee 69 	call	#27118		;#0x69ee

00006b50 <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6b50:	0f 3c       	jmp	$+32     	;abs 0x6b70

00006b52 <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6b52:	1c 41 02 00 	mov	2(r1),	r12	;
    6b56:	2d 41       	mov	@r1,	r13	;
    6b58:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6b5c:	81 4c 06 00 	mov	r12,	6(r1)	;

00006b60 <.Loc.149.3>:
    if (msg < MSG_OK) {
    6b60:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6b64:	05 34       	jge	$+12     	;abs 0x6b70

00006b66 <.Loc.150.3>:
      osalSysUnlock();
    6b66:	b0 12 fa 69 	call	#27130		;#0x69fa

00006b6a <.Loc.151.3>:
      return msg;
    6b6a:	1c 41 06 00 	mov	6(r1),	r12	;
    6b6e:	3f 3c       	jmp	$+128    	;abs 0x6bee

00006b70 <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6b70:	1c 41 02 00 	mov	2(r1),	r12	;
    6b74:	1c 4c 02 00 	mov	2(r12),	r12	;
    6b78:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b7a:	eb 27       	jz	$-40     	;abs 0x6b52

00006b7c <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6b7c:	1c 41 02 00 	mov	2(r1),	r12	;
    6b80:	1c 4c 02 00 	mov	2(r12),	r12	;
    6b84:	0d 4c       	mov	r12,	r13	;
    6b86:	3d 53       	add	#-1,	r13	;r3 As==11
    6b88:	1c 41 02 00 	mov	2(r1),	r12	;
    6b8c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006b90 <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6b90:	1c 41 02 00 	mov	2(r1),	r12	;
    6b94:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6b98:	0e 4c       	mov	r12,	r14	;
    6b9a:	1e 53       	inc	r14		;
    6b9c:	1d 41 02 00 	mov	2(r1),	r13	;
    6ba0:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6ba4:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

00006ba8 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    6ba8:	1c 41 02 00 	mov	2(r1),	r12	;
    6bac:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6bb0:	1c 41 02 00 	mov	2(r1),	r12	;
    6bb4:	1c 4c 06 00 	mov	6(r12),	r12	;
    6bb8:	0d 9c       	cmp	r12,	r13	;
    6bba:	08 28       	jnc	$+18     	;abs 0x6bcc

00006bbc <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6bbc:	1c 41 02 00 	mov	2(r1),	r12	;
    6bc0:	1d 4c 04 00 	mov	4(r12),	r13	;
    6bc4:	1c 41 02 00 	mov	2(r1),	r12	;
    6bc8:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006bcc <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6bcc:	1c 41 02 00 	mov	2(r1),	r12	;
    6bd0:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6bd4:	0c 93       	cmp	#0,	r12	;r3 As==00
    6bd6:	07 24       	jz	$+16     	;abs 0x6be6

00006bd8 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6bd8:	1c 41 02 00 	mov	2(r1),	r12	;
    6bdc:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6be0:	1c 41 02 00 	mov	2(r1),	r12	;
    6be4:	8d 12       	call	r13		;

00006be6 <.L23>:
  }

  osalSysUnlock();
    6be6:	b0 12 fa 69 	call	#27130		;#0x69fa

00006bea <.Loc.169.3>:

  return (msg_t)b;
    6bea:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006bee <.L20>:
}
    6bee:	31 52       	add	#8,	r1	;r2 As==11
    6bf0:	30 41       	ret			

00006bf2 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    6bf2:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006bf6 <L0>:
    6bf6:	81 4c 06 00 	mov	r12,	6(r1)	;
    6bfa:	81 4d 04 00 	mov	r13,	4(r1)	;
    6bfe:	81 4e 02 00 	mov	r14,	2(r1)	;
    6c02:	81 4f 00 00 	mov	r15,	0(r1)	;

00006c06 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6c06:	1c 41 06 00 	mov	6(r1),	r12	;
    6c0a:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6c0e:	0c 00 

00006c10 <.Loc.200.3>:
  size_t r = 0;
    6c10:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006c14 <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6c14:	b0 12 ee 69 	call	#27118		;#0x69ee

00006c18 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6c18:	b0 12 06 6a 	call	#27142		;#0x6a06
    6c1c:	0d 4c       	mov	r12,	r13	;
    6c1e:	2d 51       	add	@r1,	r13	;
    6c20:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006c24 <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6c24:	2e 3c       	jmp	$+94     	;abs 0x6c82

00006c26 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6c26:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6c2a:	03 24       	jz	$+8      	;abs 0x6c32

00006c2c <.Loc.218.3>:
    6c2c:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6c30:	08 20       	jnz	$+18     	;abs 0x6c42

00006c32 <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6c32:	1c 41 06 00 	mov	6(r1),	r12	;
    6c36:	2d 41       	mov	@r1,	r13	;
    6c38:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6c3c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6c40:	18 3c       	jmp	$+50     	;abs 0x6c72

00006c42 <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6c42:	b0 12 06 6a 	call	#27142		;#0x6a06
    6c46:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6c4a:	0d 8c       	sub	r12,	r13	;
    6c4c:	81 4d 08 00 	mov	r13,	8(r1)	;

00006c50 <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6c50:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6c54:	00 00 
    6c56:	05 2c       	jc	$+12     	;abs 0x6c62

00006c58 <.Loc.228.3>:
          osalSysUnlock();
    6c58:	b0 12 fa 69 	call	#27130		;#0x69fa

00006c5c <.Loc.229.3>:
          return r;
    6c5c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6c60:	5c 3c       	jmp	$+186    	;abs 0x6d1a

00006c62 <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    6c62:	1c 41 06 00 	mov	6(r1),	r12	;
    6c66:	1d 41 08 00 	mov	8(r1),	r13	;
    6c6a:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6c6e:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006c72 <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6c72:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6c76:	05 24       	jz	$+12     	;abs 0x6c82

00006c78 <.Loc.237.3>:
        osalSysUnlock();
    6c78:	b0 12 fa 69 	call	#27130		;#0x69fa

00006c7c <.Loc.238.3>:
        return r;
    6c7c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6c80:	4c 3c       	jmp	$+154    	;abs 0x6d1a

00006c82 <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6c82:	1c 41 06 00 	mov	6(r1),	r12	;
    6c86:	1c 4c 02 00 	mov	2(r12),	r12	;
    6c8a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6c8c:	cc 27       	jz	$-102    	;abs 0x6c26

00006c8e <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    6c8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c92:	1c 4c 02 00 	mov	2(r12),	r12	;
    6c96:	0d 4c       	mov	r12,	r13	;
    6c98:	3d 53       	add	#-1,	r13	;r3 As==11
    6c9a:	1c 41 06 00 	mov	6(r1),	r12	;
    6c9e:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006ca2 <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    6ca2:	1c 41 04 00 	mov	4(r1),	r12	;
    6ca6:	0d 4c       	mov	r12,	r13	;
    6ca8:	1d 53       	inc	r13		;
    6caa:	81 4d 04 00 	mov	r13,	4(r1)	;
    6cae:	1d 41 06 00 	mov	6(r1),	r13	;
    6cb2:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    6cb6:	0f 4d       	mov	r13,	r15	;
    6cb8:	1f 53       	inc	r15		;
    6cba:	1e 41 06 00 	mov	6(r1),	r14	;
    6cbe:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    6cc2:	6d 4d       	mov.b	@r13,	r13	;
    6cc4:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006cc8 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    6cc8:	1c 41 06 00 	mov	6(r1),	r12	;
    6ccc:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6cd0:	1c 41 06 00 	mov	6(r1),	r12	;
    6cd4:	1c 4c 06 00 	mov	6(r12),	r12	;
    6cd8:	0d 9c       	cmp	r12,	r13	;
    6cda:	08 28       	jnc	$+18     	;abs 0x6cec

00006cdc <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6cdc:	1c 41 06 00 	mov	6(r1),	r12	;
    6ce0:	1d 4c 04 00 	mov	4(r12),	r13	;
    6ce4:	1c 41 06 00 	mov	6(r1),	r12	;
    6ce8:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006cec <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6cec:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6cf0:	05 24       	jz	$+12     	;abs 0x6cfc

00006cf2 <.Loc.251.3>:
      nfy(iqp);
    6cf2:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6cf6:	1c 41 06 00 	mov	6(r1),	r12	;
    6cfa:	8d 12       	call	r13		;

00006cfc <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6cfc:	b0 12 fa 69 	call	#27130		;#0x69fa

00006d00 <.Loc.257.3>:

    r++;
    6d00:	91 53 10 00 	inc	16(r1)		;

00006d04 <.Loc.258.3>:
    if (--n == 0U) {
    6d04:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6d08:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6d0c:	03 20       	jnz	$+8      	;abs 0x6d14

00006d0e <.Loc.259.3>:
      return r;
    6d0e:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6d12:	03 3c       	jmp	$+8      	;abs 0x6d1a

00006d14 <.L34>:
    }

    osalSysLock();
    6d14:	b0 12 ee 69 	call	#27118		;#0x69ee

00006d18 <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6d18:	b4 3f       	jmp	$-150    	;abs 0x6c82

00006d1a <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    6d1a:	31 50 12 00 	add	#18,	r1	;#0x0012
    6d1e:	30 41       	ret			

00006d20 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    6d20:	31 82       	sub	#8,	r1	;r2 As==11

00006d22 <.LCFI7>:
    6d22:	81 4c 06 00 	mov	r12,	6(r1)	;
    6d26:	81 4d 04 00 	mov	r13,	4(r1)	;
    6d2a:	81 4e 02 00 	Address 0x0000000000006d2c is out of bounds.
mov	r14,	-1(r1)	; 0xffff

00006d2c <L0>:
    6d2c:	02 00       	mova	@r0,	r2	;
    6d2e:	81 4f 00 00 	mov	r15,	0(r1)	;

00006d32 <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    6d32:	1c 41 06 00 	mov	6(r1),	r12	;
    6d36:	b0 12 0c 6a 	call	#27148		;#0x6a0c

00006d3a <.Loc.285.3>:
  oqp->q_counter = size;
    6d3a:	1c 41 06 00 	mov	6(r1),	r12	;
    6d3e:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    6d42:	02 00 

00006d44 <.Loc.286.3>:
  oqp->q_buffer  = bp;
    6d44:	1c 41 06 00 	mov	6(r1),	r12	;
    6d48:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6d4c:	04 00 

00006d4e <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6d4e:	1c 41 06 00 	mov	6(r1),	r12	;
    6d52:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6d56:	0a 00 

00006d58 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6d58:	1c 41 06 00 	mov	6(r1),	r12	;
    6d5c:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6d60:	08 00 

00006d62 <.Loc.289.3>:
  oqp->q_top     = bp + size;
    6d62:	1d 41 04 00 	mov	4(r1),	r13	;
    6d66:	1d 51 02 00 	add	2(r1),	r13	;
    6d6a:	1c 41 06 00 	mov	6(r1),	r12	;
    6d6e:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006d72 <.Loc.290.3>:
  oqp->q_notify  = onfy;
    6d72:	1c 41 06 00 	mov	6(r1),	r12	;
    6d76:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006d7a <.Loc.291.3>:
  oqp->q_link    = link;
    6d7a:	1c 41 06 00 	mov	6(r1),	r12	;
    6d7e:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6d82:	0e 00 

00006d84 <.Loc.292.3>:
}
    6d84:	03 43       	nop			
    6d86:	31 52       	add	#8,	r1	;r2 As==11
    6d88:	30 41       	ret			

00006d8a <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    6d8a:	31 82       	sub	#8,	r1	;r2 As==11

00006d8c <.LCFI9>:
    6d8c:	81 4c 04 00 	mov	r12,	4(r1)	;
    6d90:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6d94:	81 4e 00 00 	mov	r14,	0(r1)	;

00006d98 <.Loc.339.3>:

  osalSysLock();
    6d98:	b0 12 ee 69 	call	#27118		;#0x69ee

00006d9c <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6d9c:	0f 3c       	jmp	$+32     	;abs 0x6dbc

00006d9e <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6d9e:	1c 41 04 00 	mov	4(r1),	r12	;
    6da2:	2d 41       	mov	@r1,	r13	;
    6da4:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6da8:	81 4c 06 00 	mov	r12,	6(r1)	;

00006dac <.Loc.344.3>:
    if (msg < MSG_OK) {
    6dac:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6db0:	05 34       	jge	$+12     	;abs 0x6dbc

00006db2 <.Loc.345.3>:
      osalSysUnlock();
    6db2:	b0 12 fa 69 	call	#27130		;#0x69fa

00006db6 <.Loc.346.3>:
      return msg;
    6db6:	1c 41 06 00 	mov	6(r1),	r12	;
    6dba:	3f 3c       	jmp	$+128    	;abs 0x6e3a

00006dbc <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6dbc:	1c 41 04 00 	mov	4(r1),	r12	;
    6dc0:	1c 4c 02 00 	mov	2(r12),	r12	;
    6dc4:	0c 93       	cmp	#0,	r12	;r3 As==00
    6dc6:	eb 27       	jz	$-40     	;abs 0x6d9e

00006dc8 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    6dc8:	1c 41 04 00 	mov	4(r1),	r12	;
    6dcc:	1c 4c 02 00 	mov	2(r12),	r12	;
    6dd0:	0d 4c       	mov	r12,	r13	;
    6dd2:	3d 53       	add	#-1,	r13	;r3 As==11
    6dd4:	1c 41 04 00 	mov	4(r1),	r12	;
    6dd8:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006ddc <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6ddc:	1c 41 04 00 	mov	4(r1),	r12	;
    6de0:	1c 4c 08 00 	mov	8(r12),	r12	;
    6de4:	0e 4c       	mov	r12,	r14	;
    6de6:	1e 53       	inc	r14		;
    6de8:	1d 41 04 00 	mov	4(r1),	r13	;
    6dec:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6df0:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    6df4:	00 00 

00006df6 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6df6:	1c 41 04 00 	mov	4(r1),	r12	;
    6dfa:	1d 4c 08 00 	mov	8(r12),	r13	;
    6dfe:	1c 41 04 00 	mov	4(r1),	r12	;
    6e02:	1c 4c 06 00 	mov	6(r12),	r12	;
    6e06:	0d 9c       	cmp	r12,	r13	;
    6e08:	08 28       	jnc	$+18     	;abs 0x6e1a

00006e0a <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    6e0a:	1c 41 04 00 	mov	4(r1),	r12	;
    6e0e:	1d 4c 04 00 	mov	4(r12),	r13	;
    6e12:	1c 41 04 00 	mov	4(r1),	r12	;
    6e16:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006e1a <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6e1a:	1c 41 04 00 	mov	4(r1),	r12	;
    6e1e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6e22:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e24:	07 24       	jz	$+16     	;abs 0x6e34

00006e26 <.Loc.359.3>:
    oqp->q_notify(oqp);
    6e26:	1c 41 04 00 	mov	4(r1),	r12	;
    6e2a:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6e2e:	1c 41 04 00 	mov	4(r1),	r12	;
    6e32:	8d 12       	call	r13		;

00006e34 <.L43>:
  }

  osalSysUnlock();
    6e34:	b0 12 fa 69 	call	#27130		;#0x69fa

00006e38 <.Loc.364.3>:

  return MSG_OK;
    6e38:	4c 43       	clr.b	r12		;

00006e3a <.L40>:
}
    6e3a:	31 52       	add	#8,	r1	;r2 As==11
    6e3c:	30 41       	ret			

00006e3e <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6e3e:	21 82       	sub	#4,	r1	;r2 As==10

00006e40 <.LCFI10>:
    6e40:	81 4c 00 00 	Address 0x0000000000006e42 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006e42 <L0>:
	...

00006e44 <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    6e44:	b0 12 2a 65 	call	#25898		;#0x652a

00006e48 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    6e48:	2c 41       	mov	@r1,	r12	;
    6e4a:	1d 4c 08 00 	mov	8(r12),	r13	;
    6e4e:	2c 41       	mov	@r1,	r12	;
    6e50:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6e54:	0d 9c       	cmp	r12,	r13	;
    6e56:	07 20       	jnz	$+16     	;abs 0x6e66

00006e58 <.Loc.382.3>:
    6e58:	2c 41       	mov	@r1,	r12	;
    6e5a:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e5e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e60:	02 24       	jz	$+6      	;abs 0x6e66

00006e62 <.Loc.382.3>:
    6e62:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6e64:	01 3c       	jmp	$+4      	;abs 0x6e68

00006e66 <.L45>:
    6e66:	4c 43       	clr.b	r12		;

00006e68 <.L46>:
    6e68:	5c f3       	and.b	#1,	r12	;r3 As==01
    6e6a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6e6e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e70:	02 24       	jz	$+6      	;abs 0x6e76

00006e72 <.Loc.383.3>:
    return MSG_TIMEOUT;
    6e72:	3c 43       	mov	#-1,	r12	;r3 As==11
    6e74:	26 3c       	jmp	$+78     	;abs 0x6ec2

00006e76 <.L47>:
  }

  oqp->q_counter++;
    6e76:	2c 41       	mov	@r1,	r12	;
    6e78:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e7c:	0d 4c       	mov	r12,	r13	;
    6e7e:	1d 53       	inc	r13		;
    6e80:	2c 41       	mov	@r1,	r12	;
    6e82:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006e86 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    6e86:	2c 41       	mov	@r1,	r12	;
    6e88:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6e8c:	0e 4c       	mov	r12,	r14	;
    6e8e:	1e 53       	inc	r14		;
    6e90:	2d 41       	mov	@r1,	r13	;
    6e92:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6e96:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

00006e9a <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    6e9a:	2c 41       	mov	@r1,	r12	;
    6e9c:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6ea0:	2c 41       	mov	@r1,	r12	;
    6ea2:	1c 4c 06 00 	mov	6(r12),	r12	;
    6ea6:	0d 9c       	cmp	r12,	r13	;
    6ea8:	06 28       	jnc	$+14     	;abs 0x6eb6

00006eaa <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    6eaa:	2c 41       	mov	@r1,	r12	;
    6eac:	1d 4c 04 00 	mov	4(r12),	r13	;
    6eb0:	2c 41       	mov	@r1,	r12	;
    6eb2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006eb6 <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    6eb6:	2c 41       	mov	@r1,	r12	;
    6eb8:	4d 43       	clr.b	r13		;
    6eba:	b0 12 54 69 	call	#26964		;#0x6954

00006ebe <.Loc.394.3>:

  return (msg_t)b;
    6ebe:	5c 41 03 00 	mov.b	3(r1),	r12	;

00006ec2 <.L48>:
}
    6ec2:	21 52       	add	#4,	r1	;r2 As==10
    6ec4:	30 41       	ret			

00006ec6 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    6ec6:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006eca <L0>:
    6eca:	81 4c 06 00 	mov	r12,	6(r1)	;
    6ece:	81 4d 04 00 	mov	r13,	4(r1)	;
    6ed2:	81 4e 02 00 	mov	r14,	2(r1)	;
    6ed6:	81 4f 00 00 	mov	r15,	0(r1)	;

00006eda <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    6eda:	1c 41 06 00 	mov	6(r1),	r12	;
    6ede:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6ee2:	0c 00 

00006ee4 <.Loc.425.3>:
  size_t w = 0;
    6ee4:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006ee8 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6ee8:	b0 12 ee 69 	call	#27118		;#0x69ee

00006eec <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6eec:	b0 12 06 6a 	call	#27142		;#0x6a06
    6ef0:	0d 4c       	mov	r12,	r13	;
    6ef2:	2d 51       	add	@r1,	r13	;
    6ef4:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006ef8 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6ef8:	2e 3c       	jmp	$+94     	;abs 0x6f56

00006efa <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6efa:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6efe:	03 24       	jz	$+8      	;abs 0x6f06

00006f00 <.Loc.442.3>:
    6f00:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6f04:	08 20       	jnz	$+18     	;abs 0x6f16

00006f06 <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6f06:	1c 41 06 00 	mov	6(r1),	r12	;
    6f0a:	2d 41       	mov	@r1,	r13	;
    6f0c:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6f10:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6f14:	18 3c       	jmp	$+50     	;abs 0x6f46

00006f16 <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6f16:	b0 12 06 6a 	call	#27142		;#0x6a06
    6f1a:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6f1e:	0e 8c       	sub	r12,	r14	;
    6f20:	81 4e 08 00 	mov	r14,	8(r1)	;

00006f24 <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6f24:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6f28:	00 00 
    6f2a:	05 2c       	jc	$+12     	;abs 0x6f36

00006f2c <.Loc.452.3>:
          osalSysUnlock();
    6f2c:	b0 12 fa 69 	call	#27130		;#0x69fa

00006f30 <.Loc.453.3>:
          return w;
    6f30:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f34:	5c 3c       	jmp	$+186    	;abs 0x6fee

00006f36 <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    6f36:	1c 41 06 00 	mov	6(r1),	r12	;
    6f3a:	1d 41 08 00 	mov	8(r1),	r13	;
    6f3e:	b0 12 1e 6a 	call	#27166		;#0x6a1e
    6f42:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006f46 <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6f46:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6f4a:	05 24       	jz	$+12     	;abs 0x6f56

00006f4c <.Loc.461.3>:
        osalSysUnlock();
    6f4c:	b0 12 fa 69 	call	#27130		;#0x69fa

00006f50 <.Loc.462.3>:
        return w;
    6f50:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6f54:	4c 3c       	jmp	$+154    	;abs 0x6fee

00006f56 <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6f56:	1c 41 06 00 	mov	6(r1),	r12	;
    6f5a:	1c 4c 02 00 	mov	2(r12),	r12	;
    6f5e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6f60:	cc 27       	jz	$-102    	;abs 0x6efa

00006f62 <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    6f62:	1c 41 06 00 	mov	6(r1),	r12	;
    6f66:	1c 4c 02 00 	mov	2(r12),	r12	;
    6f6a:	0d 4c       	mov	r12,	r13	;
    6f6c:	3d 53       	add	#-1,	r13	;r3 As==11
    6f6e:	1c 41 06 00 	mov	6(r1),	r12	;
    6f72:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006f76 <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    6f76:	1c 41 06 00 	mov	6(r1),	r12	;
    6f7a:	1c 4c 08 00 	mov	8(r12),	r12	;
    6f7e:	0e 4c       	mov	r12,	r14	;
    6f80:	1e 53       	inc	r14		;
    6f82:	1d 41 06 00 	mov	6(r1),	r13	;
    6f86:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6f8a:	1d 41 04 00 	mov	4(r1),	r13	;
    6f8e:	0e 4d       	mov	r13,	r14	;
    6f90:	1e 53       	inc	r14		;
    6f92:	81 4e 04 00 	mov	r14,	4(r1)	;
    6f96:	6d 4d       	mov.b	@r13,	r13	;
    6f98:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006f9c <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    6f9c:	1c 41 06 00 	mov	6(r1),	r12	;
    6fa0:	1d 4c 08 00 	mov	8(r12),	r13	;
    6fa4:	1c 41 06 00 	mov	6(r1),	r12	;
    6fa8:	1c 4c 06 00 	mov	6(r12),	r12	;
    6fac:	0d 9c       	cmp	r12,	r13	;
    6fae:	08 28       	jnc	$+18     	;abs 0x6fc0

00006fb0 <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    6fb0:	1c 41 06 00 	mov	6(r1),	r12	;
    6fb4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6fb8:	1c 41 06 00 	mov	6(r1),	r12	;
    6fbc:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006fc0 <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    6fc0:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6fc4:	05 24       	jz	$+12     	;abs 0x6fd0

00006fc6 <.Loc.475.3>:
      nfy(oqp);
    6fc6:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6fca:	1c 41 06 00 	mov	6(r1),	r12	;
    6fce:	8d 12       	call	r13		;

00006fd0 <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6fd0:	b0 12 fa 69 	call	#27130		;#0x69fa

00006fd4 <.Loc.481.3>:

    w++;
    6fd4:	91 53 10 00 	inc	16(r1)		;

00006fd8 <.Loc.482.3>:
    if (--n == 0U) {
    6fd8:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6fdc:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6fe0:	03 20       	jnz	$+8      	;abs 0x6fe8

00006fe2 <.Loc.483.3>:
      return w;
    6fe2:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6fe6:	03 3c       	jmp	$+8      	;abs 0x6fee

00006fe8 <.L60>:
    }

    osalSysLock();
    6fe8:	b0 12 ee 69 	call	#27118		;#0x69ee

00006fec <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    6fec:	85 3f       	jmp	$-244    	;abs 0x6ef8

00006fee <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    6fee:	31 50 12 00 	add	#18,	r1	;#0x0012
    6ff2:	30 41       	ret			

00006ff4 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    6ff4:	21 83       	decd	r1		;

00006ff6 <.LCFI0>:
    6ff6:	81 4c 00 00 	mov	r12,	0(r1)	;

00006ffa <.Loc.885.2>:

  chSemObjectInit((semaphore_t *)mp, (cnt_t)1);
    6ffa:	2c 41       	mov	@r1,	r12	;
    6ffc:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00007000 <L0>:
}
    7000:	03 43       	nop			
    7002:	21 53       	incd	r1		;
    7004:	30 41       	ret			

00007006 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
    7006:	b0 12 8e 80 	call	#32910		;#0x808e

0000700a <.Loc.62.3>:
}
    700a:	03 43       	nop			
    700c:	30 41       	ret			

0000700e <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
    700e:	21 83       	decd	r1		;

00007010 <.LCFI3>:
    7010:	81 4c 00 00 	mov	r12,	0(r1)	;

00007014 <.Loc.73.3>:

  i2cp->state  = I2C_STOP;
    7014:	2c 41       	mov	@r1,	r12	;
    7016:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

0000701a <.Loc.74.3>:
  i2cp->config = NULL;
    701a:	2c 41       	mov	@r1,	r12	;
    701c:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00007020 <.Loc.77.3>:

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
    7020:	2c 41       	mov	@r1,	r12	;
    7022:	3c 50 06 00 	add	#6,	r12	;
    7026:	b0 12 f4 6f 	call	#28660		;#0x6ff4

0000702a <.Loc.83.3>:
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
    702a:	03 43       	nop			
    702c:	21 53       	incd	r1		;
    702e:	30 41       	ret			

00007030 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    7030:	32 c2       	dint			

00007032 <.Loc.348.1>:
  asm volatile("nop");
    7032:	03 43       	nop			

00007034 <.Loc.349.1>:
}
    7034:	03 43       	nop			
    7036:	30 41       	ret			

00007038 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    7038:	03 43       	nop			

0000703a <.Loc.356.1>:
  _enable_interrupts();
    703a:	32 d2       	eint			
    703c:	03 43       	nop			

0000703e <.Loc.357.1>:
}
    703e:	03 43       	nop			
    7040:	30 41       	ret			

00007042 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    7042:	b0 12 30 70 	call	#28720		;#0x7030
    7046:	b0 12 44 64 	call	#25668		;#0x6444

0000704a <.Loc.505.2>:
}
    704a:	03 43       	nop			
    704c:	30 41       	ret			

0000704e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    704e:	b0 12 64 64 	call	#25700		;#0x6464
    7052:	b0 12 38 70 	call	#28728		;#0x7038

00007056 <.Loc.516.2>:
}
    7056:	03 43       	nop			
    7058:	30 41       	ret			

0000705a <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    705a:	21 83       	decd	r1		;

0000705c <.LCFI0>:
    705c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007060 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    7060:	2c 41       	mov	@r1,	r12	;
    7062:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    7066:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000706a <.Loc.811.2>:
  esp->cb    = NULL;
    706a:	2c 41       	mov	@r1,	r12	;
    706c:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00007070 <.Loc.812.2>:
  esp->param = NULL;
    7070:	2c 41       	mov	@r1,	r12	;
    7072:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00007076 <.Loc.813.2>:
}
    7076:	03 43       	nop			
    7078:	21 53       	incd	r1		;
    707a:	30 41       	ret			

0000707c <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    707c:	0a 15       	pushm	#1,	r10	;16-bit words

0000707e <.LCFI1>:
    707e:	31 80 06 00 	sub	#6,	r1	;

00007082 <.LCFI2>:
    7082:	81 4c 04 00 	mov	r12,	4(r1)	;
    7086:	81 4d 00 00 	mov	r13,	0(r1)	;
    708a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000708e <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    708e:	1c 41 04 00 	mov	4(r1),	r12	;
    7092:	1d 4c 02 00 	mov	2(r12),	r13	;
    7096:	2c 4c       	mov	@r12,	r12	;
    7098:	2a 41       	mov	@r1,	r10	;
    709a:	0a dc       	bis	r12,	r10	;
    709c:	1b 41 02 00 	mov	2(r1),	r11	;
    70a0:	0b dd       	bis	r13,	r11	;
    70a2:	1c 41 04 00 	mov	4(r1),	r12	;
    70a6:	8c 4a 00 00 	mov	r10,	0(r12)	;
    70aa:	8c 4b 02 00 	mov	r11,	2(r12)	;

000070ae <.Loc.829.2>:
  if (esp->cb != NULL) {
    70ae:	1c 41 04 00 	mov	4(r1),	r12	;
    70b2:	1c 4c 04 00 	mov	4(r12),	r12	;
    70b6:	0c 93       	cmp	#0,	r12	;r3 As==00
    70b8:	07 24       	jz	$+16     	;abs 0x70c8

000070ba <.Loc.830.2>:
    esp->cb(esp);
    70ba:	1c 41 04 00 	mov	4(r1),	r12	;
    70be:	1d 4c 04 00 	mov	4(r12),	r13	;
    70c2:	1c 41 04 00 	mov	4(r1),	r12	;
    70c6:	8d 12       	call	r13		;

000070c8 <.L9>:
  }
}
    70c8:	03 43       	nop			
    70ca:	31 50 06 00 	add	#6,	r1	;
    70ce:	0a 17       	popm	#1,	r10	;16-bit words
    70d0:	30 41       	ret			

000070d2 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    70d2:	31 80 06 00 	sub	#6,	r1	;

000070d6 <.LCFI3>:
    70d6:	81 4c 04 00 	mov	r12,	4(r1)	;
    70da:	81 4d 02 00 	mov	r13,	2(r1)	;
    70de:	81 4e 00 00 	mov	r14,	0(r1)	;

000070e2 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    70e2:	1c 41 04 00 	mov	4(r1),	r12	;
    70e6:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    70ea:	4f 43       	clr.b	r15		;
    70ec:	2e 41       	mov	@r1,	r14	;
    70ee:	1d 41 02 00 	mov	2(r1),	r13	;
    70f2:	b0 12 c6 6e 	call	#28358		;#0x6ec6

000070f6 <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    70f6:	31 50 06 00 	add	#6,	r1	;
    70fa:	30 41       	ret			

000070fc <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    70fc:	31 80 06 00 	sub	#6,	r1	;

00007100 <.LCFI4>:
    7100:	81 4c 04 00 	mov	r12,	4(r1)	;
    7104:	81 4d 02 00 	mov	r13,	2(r1)	;
    7108:	81 4e 00 00 	mov	r14,	0(r1)	;

0000710c <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    710c:	1c 41 04 00 	mov	4(r1),	r12	;
    7110:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7114:	4f 43       	clr.b	r15		;
    7116:	2e 41       	mov	@r1,	r14	;
    7118:	1d 41 02 00 	mov	2(r1),	r13	;
    711c:	b0 12 f2 6b 	call	#27634		;#0x6bf2

00007120 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    7120:	31 50 06 00 	add	#6,	r1	;
    7124:	30 41       	ret			

00007126 <put>:

static msg_t put(void *ip, uint8_t b) {
    7126:	21 82       	sub	#4,	r1	;r2 As==10

00007128 <.LCFI5>:
    7128:	81 4c 02 00 	mov	r12,	2(r1)	;
    712c:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007130 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    7130:	1c 41 02 00 	mov	2(r1),	r12	;
    7134:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7138:	4e 43       	clr.b	r14		;
    713a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    713e:	b0 12 8a 6d 	call	#28042		;#0x6d8a

00007142 <.Loc.65.3>:
}
    7142:	21 52       	add	#4,	r1	;r2 As==10
    7144:	30 41       	ret			

00007146 <get>:

static msg_t get(void *ip) {
    7146:	21 83       	decd	r1		;

00007148 <.LCFI6>:
    7148:	81 4c 00 00 	mov	r12,	0(r1)	;

0000714c <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    714c:	2c 41       	mov	@r1,	r12	;
    714e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7152:	4d 43       	clr.b	r13		;
    7154:	b0 12 42 6b 	call	#27458		;#0x6b42

00007158 <.Loc.70.3>:
}
    7158:	21 53       	incd	r1		;
    715a:	30 41       	ret			

0000715c <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    715c:	31 80 06 00 	sub	#6,	r1	;

00007160 <.LCFI7>:
    7160:	81 4c 04 00 	mov	r12,	4(r1)	;
    7164:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    7168:	81 4e 00 00 	mov	r14,	0(r1)	;

0000716c <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    716c:	1c 41 04 00 	mov	4(r1),	r12	;
    7170:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7174:	2e 41       	mov	@r1,	r14	;
    7176:	5d 41 03 00 	mov.b	3(r1),	r13	;
    717a:	b0 12 8a 6d 	call	#28042		;#0x6d8a

0000717e <.Loc.75.3>:
}
    717e:	31 50 06 00 	add	#6,	r1	;
    7182:	30 41       	ret			

00007184 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    7184:	21 82       	sub	#4,	r1	;r2 As==10

00007186 <.LCFI8>:
    7186:	81 4c 02 00 	mov	r12,	2(r1)	;
    718a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000718e <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    718e:	1c 41 02 00 	mov	2(r1),	r12	;
    7192:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7196:	2d 41       	mov	@r1,	r13	;
    7198:	b0 12 42 6b 	call	#27458		;#0x6b42

0000719c <.Loc.80.3>:
}
    719c:	21 52       	add	#4,	r1	;r2 As==10
    719e:	30 41       	ret			

000071a0 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    71a0:	31 82       	sub	#8,	r1	;r2 As==11

000071a2 <.LCFI9>:
    71a2:	81 4c 06 00 	mov	r12,	6(r1)	;
    71a6:	81 4d 04 00 	mov	r13,	4(r1)	;
    71aa:	81 4e 02 00 	mov	r14,	2(r1)	;
    71ae:	81 4f 00 00 	mov	r15,	0(r1)	;

000071b2 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    71b2:	1c 41 06 00 	mov	6(r1),	r12	;
    71b6:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    71ba:	2f 41       	mov	@r1,	r15	;
    71bc:	1e 41 02 00 	mov	2(r1),	r14	;
    71c0:	1d 41 04 00 	mov	4(r1),	r13	;
    71c4:	b0 12 c6 6e 	call	#28358		;#0x6ec6

000071c8 <.Loc.85.3>:
}
    71c8:	31 52       	add	#8,	r1	;r2 As==11
    71ca:	30 41       	ret			

000071cc <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    71cc:	31 82       	sub	#8,	r1	;r2 As==11

000071ce <.LCFI10>:
    71ce:	81 4c 06 00 	mov	r12,	6(r1)	;
    71d2:	81 4d 04 00 	mov	r13,	4(r1)	;
    71d6:	81 4e 02 00 	mov	r14,	2(r1)	;
    71da:	81 4f 00 00 	mov	r15,	0(r1)	;

000071de <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    71de:	1c 41 06 00 	mov	6(r1),	r12	;
    71e2:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    71e6:	2f 41       	mov	@r1,	r15	;
    71e8:	1e 41 02 00 	mov	2(r1),	r14	;
    71ec:	1d 41 04 00 	mov	4(r1),	r13	;
    71f0:	b0 12 f2 6b 	call	#27634		;#0x6bf2

000071f4 <.Loc.90.3>:
}
    71f4:	31 52       	add	#8,	r1	;r2 As==11
    71f6:	30 41       	ret			

000071f8 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    71f8:	b0 12 1e 79 	call	#31006		;#0x791e

000071fc <.Loc.111.3>:
}
    71fc:	03 43       	nop			
    71fe:	30 41       	ret			

00007200 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    7200:	31 82       	sub	#8,	r1	;r2 As==11

00007202 <.LCFI11>:
    7202:	81 4c 06 00 	mov	r12,	6(r1)	;
    7206:	81 4d 04 00 	mov	r13,	4(r1)	;
    720a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000720e <.Loc.130.3>:

  sdp->vmt = &vmt;
    720e:	1c 41 06 00 	mov	6(r1),	r12	;
    7212:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    7216:	00 00 

00007218 <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    7218:	1c 41 06 00 	mov	6(r1),	r12	;
    721c:	2c 53       	incd	r12		;
    721e:	b0 12 5a 70 	call	#28762		;#0x705a

00007222 <.Loc.132.3>:
  sdp->state = SD_STOP;
    7222:	1c 41 06 00 	mov	6(r1),	r12	;
    7226:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

0000722a <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    722a:	1c 41 06 00 	mov	6(r1),	r12	;
    722e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7232:	1d 41 06 00 	mov	6(r1),	r13	;
    7236:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    723a:	91 41 06 00 	mov	6(r1),	0(r1)	;
    723e:	00 00 
    7240:	1f 41 04 00 	mov	4(r1),	r15	;
    7244:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7248:	b0 12 36 6a 	call	#27190		;#0x6a36

0000724c <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    724c:	1c 41 06 00 	mov	6(r1),	r12	;
    7250:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7254:	1d 41 06 00 	mov	6(r1),	r13	;
    7258:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    725c:	91 41 06 00 	mov	6(r1),	0(r1)	;
    7260:	00 00 
    7262:	1f 41 02 00 	mov	2(r1),	r15	;
    7266:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    726a:	b0 12 20 6d 	call	#27936		;#0x6d20

0000726e <.Loc.135.3>:
}
    726e:	03 43       	nop			
    7270:	31 52       	add	#8,	r1	;r2 As==11
    7272:	30 41       	ret			

00007274 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    7274:	21 82       	sub	#4,	r1	;r2 As==10

00007276 <.LCFI12>:
    7276:	81 4c 02 00 	mov	r12,	2(r1)	;
    727a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000727e <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    727e:	b0 12 42 70 	call	#28738		;#0x7042

00007282 <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    7282:	2d 41       	mov	@r1,	r13	;
    7284:	1c 41 02 00 	mov	2(r1),	r12	;
    7288:	b0 12 30 79 	call	#31024		;#0x7930

0000728c <.Loc.155.3>:
  sdp->state = SD_READY;
    728c:	1c 41 02 00 	mov	2(r1),	r12	;
    7290:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00007294 <.Loc.156.3>:
  osalSysUnlock();
    7294:	b0 12 4e 70 	call	#28750		;#0x704e

00007298 <.Loc.157.3>:
}
    7298:	03 43       	nop			
    729a:	21 52       	add	#4,	r1	;r2 As==10
    729c:	30 41       	ret			

0000729e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    729e:	21 82       	sub	#4,	r1	;r2 As==10

000072a0 <.LCFI14>:
    72a0:	81 4c 02 00 	mov	r12,	2(r1)	;
    72a4:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000072a8 <.Loc.204.3>:

  osalDbgCheckClassI();
    72a8:	b0 12 2a 65 	call	#25898		;#0x652a

000072ac <.Loc.207.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    72ac:	1c 41 02 00 	mov	2(r1),	r12	;
    72b0:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    72b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    72b6:	07 20       	jnz	$+16     	;abs 0x72c6

000072b8 <.Loc.208.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    72b8:	1c 41 02 00 	mov	2(r1),	r12	;
    72bc:	2c 53       	incd	r12		;
    72be:	6d 42       	mov.b	#4,	r13	;r2 As==10
    72c0:	4e 43       	clr.b	r14		;
    72c2:	b0 12 7c 70 	call	#28796		;#0x707c

000072c6 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    72c6:	1c 41 02 00 	mov	2(r1),	r12	;
    72ca:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    72ce:	5d 41 01 00 	mov.b	1(r1),	r13	;
    72d2:	b0 12 9e 6a 	call	#27294		;#0x6a9e
    72d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    72d8:	08 34       	jge	$+18     	;abs 0x72ea

000072da <.Loc.210.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    72da:	1c 41 02 00 	mov	2(r1),	r12	;
    72de:	2c 53       	incd	r12		;
    72e0:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    72e4:	4e 43       	clr.b	r14		;
    72e6:	b0 12 7c 70 	call	#28796		;#0x707c

000072ea <.L33>:
}
    72ea:	03 43       	nop			
    72ec:	21 52       	add	#4,	r1	;r2 As==10
    72ee:	30 41       	ret			

000072f0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    72f0:	21 82       	sub	#4,	r1	;r2 As==10

000072f2 <.LCFI15>:
    72f2:	81 4c 00 00 	mov	r12,	0(r1)	;

000072f6 <.Loc.231.3>:
  msg_t  b;

  osalDbgCheckClassI();
    72f6:	b0 12 2a 65 	call	#25898		;#0x652a

000072fa <.Loc.234.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    72fa:	2c 41       	mov	@r1,	r12	;
    72fc:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7300:	b0 12 3e 6e 	call	#28222		;#0x6e3e
    7304:	81 4c 02 00 	mov	r12,	2(r1)	;

00007308 <.Loc.235.3>:
  if (b < MSG_OK)
    7308:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    730c:	06 34       	jge	$+14     	;abs 0x731a

0000730e <.Loc.236.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    730e:	2c 41       	mov	@r1,	r12	;
    7310:	2c 53       	incd	r12		;
    7312:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7314:	4e 43       	clr.b	r14		;
    7316:	b0 12 7c 70 	call	#28796		;#0x707c

0000731a <.L35>:
  return b;
    731a:	1c 41 02 00 	mov	2(r1),	r12	;

0000731e <.Loc.238.3>:
}
    731e:	21 52       	add	#4,	r1	;r2 As==10
    7320:	30 41       	ret			

00007322 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    7322:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    7326:	5c 01 

00007328 <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    7328:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    732c:	60 01 

0000732e <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    732e:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    7332:	62 01 

00007334 <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    7334:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    7338:	64 01 

0000733a <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    733a:	b2 40 50 00 	mov	#80,	&0x0166	;#0x0050
    733e:	66 01 

00007340 <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    7340:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    7344:	68 01 

00007346 <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    7346:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    734a:	6c 01 

0000734c <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    734c:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00007350 <.Loc.87.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    7350:	b0 12 f2 7d 	call	#32242		;#0x7df2

00007354 <.Loc.89.1>:
#endif
}
    7354:	03 43       	nop			
    7356:	30 41       	ret			

00007358 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7358:	03 43       	nop			
    735a:	30 41       	ret			

0000735c <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    735c:	03 43       	nop			
    735e:	30 41       	ret			

00007360 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7360:	b0 12 58 73 	call	#29528		;#0x7358
    7364:	b0 12 86 64 	call	#25734		;#0x6486

00007368 <.Loc.527.2>:
}
    7368:	03 43       	nop			
    736a:	30 41       	ret			

0000736c <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    736c:	b0 12 a8 64 	call	#25768		;#0x64a8
    7370:	b0 12 5c 73 	call	#29532		;#0x735c

00007374 <.Loc.538.2>:
}
    7374:	03 43       	nop			
    7376:	30 41       	ret			

00007378 <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    7378:	b0 12 36 66 	call	#26166		;#0x6636

0000737c <.Loc.597.2>:
}
    737c:	03 43       	nop			
    737e:	30 41       	ret			

00007380 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    7380:	bf 15       	pushm	#12,	r15	;16-bit words

00007382 <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    7382:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7386:	b0 12 cc 64 	call	#25804		;#0x64cc

0000738a <.Loc.170.3>:
  
  osalSysLockFromISR();
    738a:	b0 12 60 73 	call	#29536		;#0x7360

0000738e <.Loc.171.3>:
  osalOsTimerHandlerI();
    738e:	b0 12 78 73 	call	#29560		;#0x7378

00007392 <.Loc.172.3>:
  osalSysUnlockFromISR();
    7392:	b0 12 6c 73 	call	#29548		;#0x736c

00007396 <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    7396:	b0 12 fa 64 	call	#25850		;#0x64fa
    739a:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    739e:	b0 12 44 64 	call	#25668		;#0x6444
    73a2:	b0 12 02 67 	call	#26370		;#0x6702
    73a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    73aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    73ac:	02 24       	jz	$+6      	;abs 0x73b2

000073ae <.Loc.174.3>:
    73ae:	b0 12 1e 67 	call	#26398		;#0x671e

000073b2 <.L7>:
    73b2:	b0 12 64 64 	call	#25700		;#0x6464

000073b6 <.Loc.175.3>:
}
    73b6:	03 43       	nop			
    73b8:	b4 17       	popm	#12,	r15	;16-bit words
    73ba:	00 13       	reti			

000073bc <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    73bc:	b2 40 f9 00 	mov	#249,	&0x03d2	;#0x00f9
    73c0:	d2 03 

000073c2 <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    73c2:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    73c6:	c2 03 

000073c8 <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    73c8:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

000073cc <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    73cc:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    73d0:	c0 03 

000073d2 <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    73d2:	03 43       	nop			
    73d4:	30 41       	ret			

000073d6 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    73d6:	03 43       	nop			
    73d8:	30 41       	ret			

000073da <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    73da:	03 43       	nop			
    73dc:	30 41       	ret			

000073de <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    73de:	b0 12 d6 73 	call	#29654		;#0x73d6
    73e2:	b0 12 86 64 	call	#25734		;#0x6486

000073e6 <.Loc.527.2>:
}
    73e6:	03 43       	nop			
    73e8:	30 41       	ret			

000073ea <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    73ea:	b0 12 a8 64 	call	#25768		;#0x64a8
    73ee:	b0 12 da 73 	call	#29658		;#0x73da

000073f2 <.Loc.538.2>:
}
    73f2:	03 43       	nop			
    73f4:	30 41       	ret			

000073f6 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    73f6:	0a 15       	pushm	#1,	r10	;16-bit words

000073f8 <.LCFI0>:
    73f8:	31 80 06 00 	sub	#6,	r1	;

000073fc <.LCFI1>:
    73fc:	81 4c 04 00 	mov	r12,	4(r1)	;
    7400:	81 4d 00 00 	mov	r13,	0(r1)	;
    7404:	81 4e 02 00 	mov	r14,	2(r1)	;

00007408 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    7408:	1c 41 04 00 	mov	4(r1),	r12	;
    740c:	1d 4c 02 00 	mov	2(r12),	r13	;
    7410:	2c 4c       	mov	@r12,	r12	;
    7412:	2a 41       	mov	@r1,	r10	;
    7414:	0a dc       	bis	r12,	r10	;
    7416:	1b 41 02 00 	mov	2(r1),	r11	;
    741a:	0b dd       	bis	r13,	r11	;
    741c:	1c 41 04 00 	mov	4(r1),	r12	;
    7420:	8c 4a 00 00 	mov	r10,	0(r12)	;
    7424:	8c 4b 02 00 	mov	r11,	2(r12)	;

00007428 <.Loc.829.2>:
  if (esp->cb != NULL) {
    7428:	1c 41 04 00 	mov	4(r1),	r12	;
    742c:	1c 4c 04 00 	mov	4(r12),	r12	;
    7430:	0c 93       	cmp	#0,	r12	;r3 As==00
    7432:	07 24       	jz	$+16     	;abs 0x7442

00007434 <.Loc.830.2>:
    esp->cb(esp);
    7434:	1c 41 04 00 	mov	4(r1),	r12	;
    7438:	1d 4c 04 00 	mov	4(r12),	r13	;
    743c:	1c 41 04 00 	mov	4(r1),	r12	;
    7440:	8d 12       	call	r13		;

00007442 <.L7>:
  }
}
    7442:	03 43       	nop			
    7444:	31 50 06 00 	add	#6,	r1	;
    7448:	0a 17       	popm	#1,	r10	;16-bit words
    744a:	30 41       	ret			

0000744c <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    744c:	21 83       	decd	r1		;

0000744e <.LCFI2>:
    744e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007452 <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    7452:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    7456:	2c 91       	cmp	@r1,	r12	;
    7458:	02 28       	jnc	$+6      	;abs 0x745e

0000745a <.Loc.108.3>:
    return 0x00;
    745a:	4c 43       	clr.b	r12		;
    745c:	ec 3c       	jmp	$+474    	;abs 0x7636

0000745e <.L9>:
  else if (frac < 715)
    745e:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    7462:	2c 91       	cmp	@r1,	r12	;
    7464:	02 28       	jnc	$+6      	;abs 0x746a

00007466 <.Loc.110.3>:
    return 0x01;
    7466:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7468:	e6 3c       	jmp	$+462    	;abs 0x7636

0000746a <.L11>:
  else if (frac < 835)
    746a:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    746e:	2c 91       	cmp	@r1,	r12	;
    7470:	02 28       	jnc	$+6      	;abs 0x7476

00007472 <.Loc.112.3>:
    return 0x02;
    7472:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7474:	e0 3c       	jmp	$+450    	;abs 0x7636

00007476 <.L12>:
  else if (frac < 1001)
    7476:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    747a:	2c 91       	cmp	@r1,	r12	;
    747c:	02 28       	jnc	$+6      	;abs 0x7482

0000747e <.Loc.114.3>:
    return 0x04;
    747e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7480:	da 3c       	jmp	$+438    	;abs 0x7636

00007482 <.L13>:
  else if (frac < 1252)
    7482:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    7486:	2c 91       	cmp	@r1,	r12	;
    7488:	02 28       	jnc	$+6      	;abs 0x748e

0000748a <.Loc.116.3>:
    return 0x08;
    748a:	7c 42       	mov.b	#8,	r12	;r2 As==11
    748c:	d4 3c       	jmp	$+426    	;abs 0x7636

0000748e <.L14>:
  else if (frac < 1430)
    748e:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    7492:	2c 91       	cmp	@r1,	r12	;
    7494:	03 28       	jnc	$+8      	;abs 0x749c

00007496 <.Loc.118.3>:
    return 0x10;
    7496:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    749a:	cd 3c       	jmp	$+412    	;abs 0x7636

0000749c <.L15>:
  else if (frac < 1670)
    749c:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    74a0:	2c 91       	cmp	@r1,	r12	;
    74a2:	03 28       	jnc	$+8      	;abs 0x74aa

000074a4 <.Loc.120.3>:
    return 0x20;
    74a4:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    74a8:	c6 3c       	jmp	$+398    	;abs 0x7636

000074aa <.L16>:
  else if (frac < 2147)
    74aa:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    74ae:	2c 91       	cmp	@r1,	r12	;
    74b0:	03 28       	jnc	$+8      	;abs 0x74b8

000074b2 <.Loc.122.3>:
    return 0x11;
    74b2:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    74b6:	bf 3c       	jmp	$+384    	;abs 0x7636

000074b8 <.L17>:
  else if (frac < 2224)
    74b8:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    74bc:	2c 91       	cmp	@r1,	r12	;
    74be:	03 28       	jnc	$+8      	;abs 0x74c6

000074c0 <.Loc.124.3>:
    return 0x21;
    74c0:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    74c4:	b8 3c       	jmp	$+370    	;abs 0x7636

000074c6 <.L18>:
  else if (frac < 2503)
    74c6:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    74ca:	2c 91       	cmp	@r1,	r12	;
    74cc:	03 28       	jnc	$+8      	;abs 0x74d4

000074ce <.Loc.126.3>:
    return 0x22;
    74ce:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    74d2:	b1 3c       	jmp	$+356    	;abs 0x7636

000074d4 <.L19>:
  else if (frac < 3000)
    74d4:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    74d8:	2c 91       	cmp	@r1,	r12	;
    74da:	03 28       	jnc	$+8      	;abs 0x74e2

000074dc <.Loc.128.3>:
    return 0x44;
    74dc:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    74e0:	aa 3c       	jmp	$+342    	;abs 0x7636

000074e2 <.L20>:
  else if (frac < 3335)
    74e2:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    74e6:	2c 91       	cmp	@r1,	r12	;
    74e8:	03 28       	jnc	$+8      	;abs 0x74f0

000074ea <.Loc.130.3>:
    return 0x25;
    74ea:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    74ee:	a3 3c       	jmp	$+328    	;abs 0x7636

000074f0 <.L21>:
  else if (frac < 3575)
    74f0:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    74f4:	2c 91       	cmp	@r1,	r12	;
    74f6:	03 28       	jnc	$+8      	;abs 0x74fe

000074f8 <.Loc.132.3>:
    return 0x49;
    74f8:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    74fc:	9c 3c       	jmp	$+314    	;abs 0x7636

000074fe <.L22>:
  else if (frac < 3753)
    74fe:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    7502:	2c 91       	cmp	@r1,	r12	;
    7504:	03 28       	jnc	$+8      	;abs 0x750c

00007506 <.Loc.134.3>:
    return 0x4A;
    7506:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    750a:	95 3c       	jmp	$+300    	;abs 0x7636

0000750c <.L23>:
  else if (frac < 4003)
    750c:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    7510:	2c 91       	cmp	@r1,	r12	;
    7512:	03 28       	jnc	$+8      	;abs 0x751a

00007514 <.Loc.136.3>:
    return 0x52;
    7514:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    7518:	8e 3c       	jmp	$+286    	;abs 0x7636

0000751a <.L24>:
  else if (frac < 4286)
    751a:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    751e:	2c 91       	cmp	@r1,	r12	;
    7520:	03 28       	jnc	$+8      	;abs 0x7528

00007522 <.Loc.138.3>:
    return 0x92;
    7522:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    7526:	87 3c       	jmp	$+272    	;abs 0x7636

00007528 <.L25>:
  else if (frac < 4378)
    7528:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    752c:	2c 91       	cmp	@r1,	r12	;
    752e:	03 28       	jnc	$+8      	;abs 0x7536

00007530 <.Loc.140.3>:
    return 0x53;
    7530:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    7534:	80 3c       	jmp	$+258    	;abs 0x7636

00007536 <.L26>:
  else if (frac < 5002)
    7536:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    753a:	2c 91       	cmp	@r1,	r12	;
    753c:	03 28       	jnc	$+8      	;abs 0x7544

0000753e <.Loc.142.3>:
    return 0x55;
    753e:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    7542:	79 3c       	jmp	$+244    	;abs 0x7636

00007544 <.L27>:
  else if (frac < 5715)
    7544:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    7548:	2c 91       	cmp	@r1,	r12	;
    754a:	03 28       	jnc	$+8      	;abs 0x7552

0000754c <.Loc.144.3>:
    return 0xAA;
    754c:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    7550:	72 3c       	jmp	$+230    	;abs 0x7636

00007552 <.L28>:
  else if (frac < 6003)
    7552:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    7556:	2c 91       	cmp	@r1,	r12	;
    7558:	03 28       	jnc	$+8      	;abs 0x7560

0000755a <.Loc.146.3>:
    return 0x6B;
    755a:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    755e:	6b 3c       	jmp	$+216    	;abs 0x7636

00007560 <.L29>:
  else if (frac < 6254)
    7560:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    7564:	2c 91       	cmp	@r1,	r12	;
    7566:	03 28       	jnc	$+8      	;abs 0x756e

00007568 <.Loc.148.3>:
    return 0xAD;
    7568:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    756c:	64 3c       	jmp	$+202    	;abs 0x7636

0000756e <.L30>:
  else if (frac < 6432)
    756e:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    7572:	2c 91       	cmp	@r1,	r12	;
    7574:	03 28       	jnc	$+8      	;abs 0x757c

00007576 <.Loc.150.3>:
    return 0xB5;
    7576:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    757a:	5d 3c       	jmp	$+188    	;abs 0x7636

0000757c <.L31>:
  else if (frac < 6667)
    757c:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    7580:	2c 91       	cmp	@r1,	r12	;
    7582:	03 28       	jnc	$+8      	;abs 0x758a

00007584 <.Loc.152.3>:
    return 0xB6;
    7584:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    7588:	56 3c       	jmp	$+174    	;abs 0x7636

0000758a <.L32>:
  else if (frac < 7001)
    758a:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    758e:	2c 91       	cmp	@r1,	r12	;
    7590:	03 28       	jnc	$+8      	;abs 0x7598

00007592 <.Loc.154.3>:
    return 0xD6;
    7592:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    7596:	4f 3c       	jmp	$+160    	;abs 0x7636

00007598 <.L33>:
  else if (frac < 7147)
    7598:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    759c:	2c 91       	cmp	@r1,	r12	;
    759e:	03 28       	jnc	$+8      	;abs 0x75a6

000075a0 <.Loc.156.3>:
    return 0xB7;
    75a0:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    75a4:	48 3c       	jmp	$+146    	;abs 0x7636

000075a6 <.L34>:
  else if (frac < 7503)
    75a6:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    75aa:	2c 91       	cmp	@r1,	r12	;
    75ac:	03 28       	jnc	$+8      	;abs 0x75b4

000075ae <.Loc.158.3>:
    return 0xBB;
    75ae:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    75b2:	41 3c       	jmp	$+132    	;abs 0x7636

000075b4 <.L35>:
  else if (frac < 7861)
    75b4:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    75b8:	2c 91       	cmp	@r1,	r12	;
    75ba:	03 28       	jnc	$+8      	;abs 0x75c2

000075bc <.Loc.160.3>:
    return 0xDD;
    75bc:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    75c0:	3a 3c       	jmp	$+118    	;abs 0x7636

000075c2 <.L36>:
  else if (frac < 8004)
    75c2:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    75c6:	2c 91       	cmp	@r1,	r12	;
    75c8:	03 28       	jnc	$+8      	;abs 0x75d0

000075ca <.Loc.162.3>:
    return 0xED;
    75ca:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    75ce:	33 3c       	jmp	$+104    	;abs 0x7636

000075d0 <.L37>:
  else if (frac < 8333)
    75d0:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    75d4:	2c 91       	cmp	@r1,	r12	;
    75d6:	03 28       	jnc	$+8      	;abs 0x75de

000075d8 <.Loc.164.3>:
    return 0xEE;
    75d8:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    75dc:	2c 3c       	jmp	$+90     	;abs 0x7636

000075de <.L38>:
  else if (frac < 8464)
    75de:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    75e2:	2c 91       	cmp	@r1,	r12	;
    75e4:	03 28       	jnc	$+8      	;abs 0x75ec

000075e6 <.Loc.166.3>:
    return 0xBF;
    75e6:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    75ea:	25 3c       	jmp	$+76     	;abs 0x7636

000075ec <.L39>:
  else if (frac < 8572)
    75ec:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    75f0:	2c 91       	cmp	@r1,	r12	;
    75f2:	03 28       	jnc	$+8      	;abs 0x75fa

000075f4 <.Loc.168.3>:
    return 0xDF;
    75f4:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    75f8:	1e 3c       	jmp	$+62     	;abs 0x7636

000075fa <.L40>:
  else if (frac < 8751)
    75fa:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    75fe:	2c 91       	cmp	@r1,	r12	;
    7600:	03 28       	jnc	$+8      	;abs 0x7608

00007602 <.Loc.170.3>:
    return 0xEF;
    7602:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    7606:	17 3c       	jmp	$+48     	;abs 0x7636

00007608 <.L41>:
  else if (frac < 9004)
    7608:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    760c:	2c 91       	cmp	@r1,	r12	;
    760e:	03 28       	jnc	$+8      	;abs 0x7616

00007610 <.Loc.172.3>:
    return 0xF7;
    7610:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    7614:	10 3c       	jmp	$+34     	;abs 0x7636

00007616 <.L42>:
  else if (frac < 9170)
    7616:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    761a:	2c 91       	cmp	@r1,	r12	;
    761c:	03 28       	jnc	$+8      	;abs 0x7624

0000761e <.Loc.174.3>:
    return 0xFB;
    761e:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    7622:	09 3c       	jmp	$+20     	;abs 0x7636

00007624 <.L43>:
  else if (frac < 9288)
    7624:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    7628:	2c 91       	cmp	@r1,	r12	;
    762a:	03 28       	jnc	$+8      	;abs 0x7632

0000762c <.Loc.176.3>:
    return 0xFD;
    762c:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    7630:	02 3c       	jmp	$+6      	;abs 0x7636

00007632 <.L44>:
  else
    return 0xFE;
    7632:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00007636 <.L10>:
}
    7636:	21 53       	incd	r1		;
    7638:	30 41       	ret			

0000763a <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    763a:	0a 15       	pushm	#1,	r10	;16-bit words

0000763c <.LCFI3>:
    763c:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00007640 <.LCFI4>:
    7640:	81 4c 04 00 	mov	r12,	4(r1)	;
    7644:	81 4d 06 00 	mov	r13,	6(r1)	;
    7648:	81 4e 00 00 	mov	r14,	0(r1)	;
    764c:	81 4f 02 00 	mov	r15,	2(r1)	;

00007650 <.Loc.191.3>:

  uint16_t n = freq / baud;
    7650:	1e 41 04 00 	mov	4(r1),	r14	;
    7654:	1f 41 06 00 	mov	6(r1),	r15	;
    7658:	2c 41       	mov	@r1,	r12	;
    765a:	1d 41 02 00 	mov	2(r1),	r13	;
    765e:	b0 12 50 9f 	call	#40784		;#0x9f50
    7662:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007666 <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    7666:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    766a:	0c 4e       	mov	r14,	r12	;
    766c:	0d 43       	clr	r13		;
    766e:	1e 41 04 00 	mov	4(r1),	r14	;
    7672:	1f 41 06 00 	mov	6(r1),	r15	;
    7676:	b0 12 86 a0 	call	#41094		;#0xa086
    767a:	0e 4c       	mov	r12,	r14	;
    767c:	0f 4d       	mov	r13,	r15	;
    767e:	2c 41       	mov	@r1,	r12	;

00007680 <L0>:
    7680:	1d 41 02 00 	mov	2(r1),	r13	;
    7684:	0c 8e       	sub	r14,	r12	;
    7686:	0d 7f       	subc	r15,	r13	;
    7688:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    768c:	4f 43       	clr.b	r15		;
    768e:	b0 12 86 a0 	call	#41094		;#0xa086
    7692:	1e 41 04 00 	mov	4(r1),	r14	;
    7696:	1f 41 06 00 	mov	6(r1),	r15	;
    769a:	b0 12 50 9f 	call	#40784		;#0x9f50
    769e:	81 4c 08 00 	mov	r12,	8(r1)	;

000076a2 <.Loc.194.3>:
  if (n > 16) {
    76a2:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    76a6:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    76aa:	19 2c       	jc	$+52     	;abs 0x76de

000076ac <.Loc.195.3>:
    while (n > 16) {
    76ac:	03 3c       	jmp	$+8      	;abs 0x76b4

000076ae <.L48>:
      n -= 16;
    76ae:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    76b2:	0a 00 

000076b4 <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    76b4:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    76b8:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    76bc:	f8 2b       	jnc	$-14     	;abs 0x76ae

000076be <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    76be:	1c 41 08 00 	mov	8(r1),	r12	;
    76c2:	b0 12 4c 74 	call	#29772		;#0x744c
    76c6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76ca:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    76ce:	0a 4c       	mov	r12,	r10	;
    76d0:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    76d4:	b0 12 74 9f 	call	#40820		;#0x9f74
    76d8:	0c da       	bis	r10,	r12	;
    76da:	1c d3       	bis	#1,	r12	;r3 As==01
    76dc:	08 3c       	jmp	$+18     	;abs 0x76ee

000076de <.L46>:
  }
  return UCBRS(frac) << 8;
    76de:	1c 41 08 00 	mov	8(r1),	r12	;
    76e2:	b0 12 4c 74 	call	#29772		;#0x744c
    76e6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76ea:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

000076ee <.L49>:
}
    76ee:	31 50 0c 00 	add	#12,	r1	;#0x000c
    76f2:	0a 17       	popm	#1,	r10	;16-bit words
    76f4:	30 41       	ret			

000076f6 <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    76f6:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000076fa <L0>:
    76fa:	81 4c 04 00 	mov	r12,	4(r1)	;
    76fe:	81 4d 06 00 	mov	r13,	6(r1)	;
    7702:	81 4e 00 00 	mov	r14,	0(r1)	;
    7706:	81 4f 02 00 	mov	r15,	2(r1)	;

0000770a <.Loc.212.3>:
  uint16_t n = freq / baud;
    770a:	1e 41 04 00 	mov	4(r1),	r14	;
    770e:	1f 41 06 00 	mov	6(r1),	r15	;
    7712:	2c 41       	mov	@r1,	r12	;
    7714:	1d 41 02 00 	mov	2(r1),	r13	;
    7718:	b0 12 50 9f 	call	#40784		;#0x9f50
    771c:	81 4c 08 00 	mov	r12,	8(r1)	;

00007720 <.Loc.213.3>:
  if (n > 16) {
    7720:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7724:	1c 91 08 00 	cmp	8(r1),	r12	;
    7728:	05 2c       	jc	$+12     	;abs 0x7734

0000772a <.Loc.214.3>:
    return n >> 4;
    772a:	1c 41 08 00 	mov	8(r1),	r12	;
    772e:	b0 12 fe 9f 	call	#40958		;#0x9ffe
    7732:	02 3c       	jmp	$+6      	;abs 0x7738

00007734 <.L51>:
  }
  return n;
    7734:	1c 41 08 00 	mov	8(r1),	r12	;

00007738 <.L52>:
}
    7738:	31 50 0a 00 	add	#10,	r1	;#0x000a
    773c:	30 41       	ret			

0000773e <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    773e:	21 83       	decd	r1		;

00007740 <L0>:
    7740:	81 4c 00 00 	mov	r12,	0(r1)	;

00007744 <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7744:	2c 41       	mov	@r1,	r12	;
    7746:	1d 4c 02 00 	mov	2(r12),	r13	;
    774a:	2c 4c       	mov	@r12,	r12	;
    774c:	3e 40 90 d0 	mov	#53392,	r14	;#0xd090
    7750:	7f 40 03 00 	mov.b	#3,	r15	;
    7754:	b0 12 f6 76 	call	#30454		;#0x76f6
    7758:	82 4c c6 05 	mov	r12,	&0x05c6	;

0000775c <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    775c:	2c 41       	mov	@r1,	r12	;
    775e:	1d 4c 02 00 	mov	2(r12),	r13	;
    7762:	2c 4c       	mov	@r12,	r12	;
    7764:	3e 40 90 d0 	mov	#53392,	r14	;#0xd090
    7768:	7f 40 03 00 	mov.b	#3,	r15	;
    776c:	b0 12 3a 76 	call	#30266		;#0x763a
    7770:	82 4c c8 05 	mov	r12,	&0x05c8	;

00007774 <.Loc.223.3>:
  UCA0STATW = 0;
    7774:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

00007778 <.Loc.224.3>:
  UCA0ABCTL = 0;
    7778:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

0000777c <.Loc.225.3>:
  UCA0IRCTL = 0;
    777c:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

00007780 <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    7780:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    7784:	c0 05 

00007786 <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    7786:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

0000778a <.Loc.230.3>:
}
    778a:	03 43       	nop			
    778c:	21 53       	incd	r1		;
    778e:	30 41       	ret			

00007790 <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    7790:	21 83       	decd	r1		;

00007792 <.LCFI7>:
    7792:	81 4c 00 00 	mov	r12,	0(r1)	;

00007796 <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    7796:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    779a:	2c d3       	bis	#2,	r12	;r3 As==10
    779c:	82 4c da 05 	mov	r12,	&0x05da	;

000077a0 <.Loc.280.3>:
}
    77a0:	03 43       	nop			
    77a2:	21 53       	incd	r1		;
    77a4:	30 41       	ret			

000077a6 <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    77a6:	31 82       	sub	#8,	r1	;r2 As==11

000077a8 <.LCFI8>:
    77a8:	81 4c 02 00 	mov	r12,	2(r1)	;
    77ac:	81 4d 00 00 	mov	r13,	0(r1)	;

000077b0 <.Loc.314.3>:
  eventflags_t sts = 0;
    77b0:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    77b4:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000077b8 <.Loc.316.3>:

  if (sra & UCOE)
    77b8:	1c 41 02 00 	mov	2(r1),	r12	;
    77bc:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    77c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    77c2:	05 24       	jz	$+12     	;abs 0x77ce

000077c4 <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    77c4:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    77c8:	04 00 
    77ca:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077ce <.L56>:
  if (sra & UCPE)
    77ce:	1c 41 02 00 	mov	2(r1),	r12	;
    77d2:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    77d6:	0c 93       	cmp	#0,	r12	;r3 As==00
    77d8:	05 24       	jz	$+12     	;abs 0x77e4

000077da <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    77da:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    77de:	04 00 
    77e0:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077e4 <.L57>:
  if (sra & UCFE)
    77e4:	1c 41 02 00 	mov	2(r1),	r12	;
    77e8:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    77ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    77ee:	05 24       	jz	$+12     	;abs 0x77fa

000077f0 <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    77f0:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    77f4:	04 00 
    77f6:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077fa <.L58>:
  osalSysLockFromISR();
    77fa:	b0 12 de 73 	call	#29662		;#0x73de

000077fe <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    77fe:	2c 41       	mov	@r1,	r12	;
    7800:	2c 53       	incd	r12		;
    7802:	1d 41 04 00 	mov	4(r1),	r13	;
    7806:	1e 41 06 00 	mov	6(r1),	r14	;
    780a:	b0 12 f6 73 	call	#29686		;#0x73f6

0000780e <.Loc.324.3>:
  osalSysUnlockFromISR();
    780e:	b0 12 ea 73 	call	#29674		;#0x73ea

00007812 <.Loc.325.3>:
}
    7812:	03 43       	nop			
    7814:	31 52       	add	#8,	r1	;r2 As==11
    7816:	30 41       	ret			

00007818 <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    7818:	bf 15       	pushm	#12,	r15	;16-bit words

0000781a <.LCFI9>:
    781a:	21 83       	decd	r1		;

0000781c <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    781c:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7820:	b0 12 cc 64 	call	#25804		;#0x64cc

00007824 <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    7824:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    7828:	2c 92       	cmp	#4,	r12	;r2 As==10
    782a:	1e 24       	jz	$+62     	;abs 0x7868
    782c:	3c 92       	cmp	#8,	r12	;r2 As==11
    782e:	40 24       	jz	$+130    	;abs 0x78b0
    7830:	2c 93       	cmp	#2,	r12	;r3 As==10
    7832:	01 24       	jz	$+4      	;abs 0x7836

00007834 <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    7834:	60 3c       	jmp	$+194    	;abs 0x78f6

00007836 <.L63>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    7836:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    783a:	6c f2       	and.b	#4,	r12	;r2 As==10
    783c:	0c 93       	cmp	#0,	r12	;r3 As==00
    783e:	06 24       	jz	$+14     	;abs 0x784c

00007840 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    7840:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7844:	3d 40 ce 51 	mov	#20942,	r13	;#0x51ce
    7848:	b0 12 a6 77 	call	#30630		;#0x77a6

0000784c <.L64>:

    /* Data available */
    osalSysLockFromISR();
    784c:	b0 12 de 73 	call	#29662		;#0x73de

00007850 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    7850:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    7854:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7858:	4d 4c       	mov.b	r12,	r13	;
    785a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    785e:	b0 12 9e 72 	call	#29342		;#0x729e

00007862 <.Loc.352.3>:
    osalSysUnlockFromISR();
    7862:	b0 12 ea 73 	call	#29674		;#0x73ea

00007866 <.Loc.353.3>:
    break;
    7866:	47 3c       	jmp	$+144    	;abs 0x78f6

00007868 <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    7868:	b0 12 de 73 	call	#29662		;#0x73de

0000786c <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    786c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    7870:	b0 12 f0 72 	call	#29424		;#0x72f0
    7874:	81 4c 00 00 	mov	r12,	0(r1)	;

00007878 <.Loc.360.3>:
    if (b < Q_OK) {
    7878:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    787c:	13 34       	jge	$+40     	;abs 0x78a4

0000787e <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    787e:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7880:	4e 43       	clr.b	r14		;
    7882:	3c 40 d0 51 	mov	#20944,	r12	;#0x51d0
    7886:	b0 12 f6 73 	call	#29686		;#0x73f6

0000788a <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    788a:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    788e:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    7892:	3c d2       	bis	#8,	r12	;r2 As==11
    7894:	82 4c da 05 	mov	r12,	&0x05da	;

00007898 <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    7898:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    789c:	2c d3       	bis	#2,	r12	;r3 As==10
    789e:	82 4c dc 05 	mov	r12,	&0x05dc	;
    78a2:	03 3c       	jmp	$+8      	;abs 0x78aa

000078a4 <.L66>:
    }
    else
      UCA0TXBUF = b;
    78a4:	2c 41       	mov	@r1,	r12	;
    78a6:	82 4c ce 05 	mov	r12,	&0x05ce	;

000078aa <.L67>:
    osalSysUnlockFromISR();
    78aa:	b0 12 ea 73 	call	#29674		;#0x73ea

000078ae <.Loc.368.3>:
    break;
    78ae:	23 3c       	jmp	$+72     	;abs 0x78f6

000078b0 <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    78b0:	b0 12 de 73 	call	#29662		;#0x73de

000078b4 <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    78b4:	1d 42 f2 51 	mov	&0x51f2,r13	;0x51f2
    78b8:	1c 42 f4 51 	mov	&0x51f4,r12	;0x51f4
    78bc:	0d 9c       	cmp	r12,	r13	;
    78be:	06 20       	jnz	$+14     	;abs 0x78cc

000078c0 <.Loc.374.3>:
    78c0:	1c 42 ec 51 	mov	&0x51ec,r12	;0x51ec
    78c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    78c6:	02 24       	jz	$+6      	;abs 0x78cc

000078c8 <.Loc.374.3>:
    78c8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    78ca:	01 3c       	jmp	$+4      	;abs 0x78ce

000078cc <.L68>:
    78cc:	4c 43       	clr.b	r12		;

000078ce <.L69>:
    78ce:	5c f3       	and.b	#1,	r12	;r3 As==01
    78d0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    78d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    78d6:	07 24       	jz	$+16     	;abs 0x78e6

000078d8 <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    78d8:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    78dc:	4e 43       	clr.b	r14		;
    78de:	3c 40 d0 51 	mov	#20944,	r12	;#0x51d0
    78e2:	b0 12 f6 73 	call	#29686		;#0x73f6

000078e6 <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    78e6:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    78ea:	3c c2       	bic	#8,	r12	;r2 As==11
    78ec:	82 4c da 05 	mov	r12,	&0x05da	;

000078f0 <.Loc.377.3>:
    osalSysUnlockFromISR();
    78f0:	b0 12 ea 73 	call	#29674		;#0x73ea

000078f4 <.Loc.378.3>:
    break;
    78f4:	03 43       	nop			

000078f6 <.L65>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    78f6:	b0 12 fa 64 	call	#25850		;#0x64fa
    78fa:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    78fe:	b0 12 44 64 	call	#25668		;#0x6444
    7902:	b0 12 02 67 	call	#26370		;#0x6702
    7906:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    790a:	0c 93       	cmp	#0,	r12	;r3 As==00
    790c:	02 24       	jz	$+6      	;abs 0x7912

0000790e <.Loc.385.3>:
    790e:	b0 12 1e 67 	call	#26398		;#0x671e

00007912 <.L71>:
    7912:	b0 12 64 64 	call	#25700		;#0x6464

00007916 <.Loc.386.3>:
}
    7916:	03 43       	nop			
    7918:	21 53       	incd	r1		;
    791a:	b4 17       	popm	#12,	r15	;16-bit words
    791c:	00 13       	reti			

0000791e <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    791e:	3e 40 90 77 	mov	#30608,	r14	;#0x7790
    7922:	4d 43       	clr.b	r13		;
    7924:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce

00007928 <L0>:
    7928:	b0 12 00 72 	call	#29184		;#0x7200

0000792c <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    792c:	03 43       	nop			
    792e:	30 41       	ret			

00007930 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7930:	21 82       	sub	#4,	r1	;r2 As==10

00007932 <.LCFI11>:
    7932:	81 4c 02 00 	mov	r12,	2(r1)	;
    7936:	81 4d 00 00 	mov	r13,	0(r1)	;

0000793a <.Loc.603.3>:

  if (config == NULL) {
    793a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    793e:	03 20       	jnz	$+8      	;abs 0x7946

00007940 <.Loc.604.3>:
    config = &default_config;
    7940:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7944:	00 00 

00007946 <.L74>:
  }

  if (sdp->state == SD_STOP) {
    7946:	1c 41 02 00 	mov	2(r1),	r12	;
    794a:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    794e:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7950:	07 20       	jnz	$+16     	;abs 0x7960

00007952 <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    7952:	b1 90 ce 51 	cmp	#20942,	2(r1)	;#0x51ce
    7956:	02 00 
    7958:	03 20       	jnz	$+8      	;abs 0x7960

0000795a <.Loc.610.3>:
      usart0_init(config);
    795a:	2c 41       	mov	@r1,	r12	;
    795c:	b0 12 3e 77 	call	#30526		;#0x773e

00007960 <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    7960:	03 43       	nop			
    7962:	21 52       	add	#4,	r1	;r2 As==10
    7964:	30 41       	ret			

00007966 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    7966:	bf 15       	pushm	#12,	r15	;16-bit words

00007968 <.LCFI0>:
    7968:	21 82       	sub	#4,	r1	;r2 As==10

0000796a <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    796a:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    796e:	b0 12 cc 64 	call	#25804		;#0x64cc

00007972 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    7972:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    7976:	12 c3       	clrc			
    7978:	0c 10       	rrc	r12		;
    797a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    797e:	4d 4c       	mov.b	r12,	r13	;
    7980:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7982:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007986 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    7986:	5c 41 03 00 	mov.b	3(r1),	r12	;
    798a:	0c 5c       	rla	r12		;
    798c:	3c 50 1a 52 	add	#21018,	r12	;#0x521a
    7990:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007994 <.Loc.80.1>:
  if (cb != NULL) {
    7994:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7998:	02 24       	jz	$+6      	;abs 0x799e

0000799a <.Loc.81.1>:
    (*cb)();
    799a:	2c 41       	mov	@r1,	r12	;
    799c:	8c 12       	call	r12		;

0000799e <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    799e:	b0 12 fa 64 	call	#25850		;#0x64fa
    79a2:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    79a6:	b0 12 44 64 	call	#25668		;#0x6444
    79aa:	b0 12 02 67 	call	#26370		;#0x6702
    79ae:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    79b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    79b4:	02 24       	jz	$+6      	;abs 0x79ba

000079b6 <.Loc.84.1>:
    79b6:	b0 12 1e 67 	call	#26398		;#0x671e

000079ba <.L3>:
    79ba:	b0 12 64 64 	call	#25700		;#0x6464

000079be <.Loc.85.1>:
}
    79be:	03 43       	nop			
    79c0:	21 52       	add	#4,	r1	;r2 As==10
    79c2:	b4 17       	popm	#12,	r15	;16-bit words
    79c4:	00 13       	reti			

000079c6 <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    79c6:	bf 15       	pushm	#12,	r15	;16-bit words

000079c8 <.LCFI2>:
    79c8:	21 82       	sub	#4,	r1	;r2 As==10

000079ca <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    79ca:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    79ce:	b0 12 cc 64 	call	#25804		;#0x64cc

000079d2 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    79d2:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    79d6:	12 c3       	clrc			
    79d8:	0c 10       	rrc	r12		;
    79da:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    79de:	4d 4c       	mov.b	r12,	r13	;
    79e0:	7d 53       	add.b	#-1,	r13	;r3 As==11
    79e2:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000079e6 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    79e6:	5c 41 03 00 	mov.b	3(r1),	r12	;
    79ea:	3c 52       	add	#8,	r12	;r2 As==11
    79ec:	0c 5c       	rla	r12		;
    79ee:	3c 50 1a 52 	add	#21018,	r12	;#0x521a
    79f2:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000079f6 <.Loc.98.1>:
  if (cb != NULL) {
    79f6:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    79fa:	02 24       	jz	$+6      	;abs 0x7a00

000079fc <.Loc.99.1>:
    (*cb)();
    79fc:	2c 41       	mov	@r1,	r12	;
    79fe:	8c 12       	call	r12		;

00007a00 <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7a00:	b0 12 fa 64 	call	#25850		;#0x64fa
    7a04:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    7a08:	b0 12 44 64 	call	#25668		;#0x6444
    7a0c:	b0 12 02 67 	call	#26370		;#0x6702
    7a10:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7a14:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a16:	02 24       	jz	$+6      	;abs 0x7a1c

00007a18 <.Loc.102.1>:
    7a18:	b0 12 1e 67 	call	#26398		;#0x671e

00007a1c <.L6>:
    7a1c:	b0 12 64 64 	call	#25700		;#0x6464

00007a20 <.Loc.103.1>:
}
    7a20:	03 43       	nop			
    7a22:	21 52       	add	#4,	r1	;r2 As==10
    7a24:	b4 17       	popm	#12,	r15	;16-bit words
    7a26:	00 13       	reti			

00007a28 <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    7a28:	bf 15       	pushm	#12,	r15	;16-bit words

00007a2a <.LCFI4>:
    7a2a:	21 82       	sub	#4,	r1	;r2 As==10

00007a2c <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7a2c:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7a30:	b0 12 cc 64 	call	#25804		;#0x64cc

00007a34 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    7a34:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    7a38:	12 c3       	clrc			
    7a3a:	0c 10       	rrc	r12		;
    7a3c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7a40:	4d 4c       	mov.b	r12,	r13	;
    7a42:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7a44:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007a48 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    7a48:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7a4c:	3c 50 10 00 	add	#16,	r12	;#0x0010
    7a50:	0c 5c       	rla	r12		;
    7a52:	3c 50 1a 52 	add	#21018,	r12	;#0x521a
    7a56:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007a5a <.Loc.117.1>:
  if (cb != NULL) {
    7a5a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7a5e:	02 24       	jz	$+6      	;abs 0x7a64

00007a60 <.Loc.118.1>:
    (*cb)();
    7a60:	2c 41       	mov	@r1,	r12	;
    7a62:	8c 12       	call	r12		;

00007a64 <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7a64:	b0 12 fa 64 	call	#25850		;#0x64fa
    7a68:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    7a6c:	b0 12 44 64 	call	#25668		;#0x6444
    7a70:	b0 12 02 67 	call	#26370		;#0x6702
    7a74:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7a78:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a7a:	02 24       	jz	$+6      	;abs 0x7a80

00007a7c <.Loc.121.1>:
    7a7c:	b0 12 1e 67 	call	#26398		;#0x671e

00007a80 <.L9>:
    7a80:	b0 12 64 64 	call	#25700		;#0x6464

00007a84 <.Loc.122.1>:
}
    7a84:	03 43       	nop			
    7a86:	21 52       	add	#4,	r1	;r2 As==10
    7a88:	b4 17       	popm	#12,	r15	;16-bit words
    7a8a:	00 13       	reti			

00007a8c <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    7a8c:	bf 15       	pushm	#12,	r15	;16-bit words

00007a8e <.LCFI6>:
    7a8e:	21 82       	sub	#4,	r1	;r2 As==10

00007a90 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7a90:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7a94:	b0 12 cc 64 	call	#25804		;#0x64cc

00007a98 <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    7a98:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    7a9c:	12 c3       	clrc			
    7a9e:	0c 10       	rrc	r12		;
    7aa0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7aa4:	4d 4c       	mov.b	r12,	r13	;
    7aa6:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7aa8:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007aac <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    7aac:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7ab0:	3c 50 18 00 	add	#24,	r12	;#0x0018
    7ab4:	0c 5c       	rla	r12		;
    7ab6:	3c 50 1a 52 	add	#21018,	r12	;#0x521a
    7aba:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007abe <.Loc.135.1>:
  if (cb != NULL) {
    7abe:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7ac2:	02 24       	jz	$+6      	;abs 0x7ac8

00007ac4 <.Loc.136.1>:
    (*cb)();
    7ac4:	2c 41       	mov	@r1,	r12	;
    7ac6:	8c 12       	call	r12		;

00007ac8 <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7ac8:	b0 12 fa 64 	call	#25850		;#0x64fa
    7acc:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    7ad0:	b0 12 44 64 	call	#25668		;#0x6444
    7ad4:	b0 12 02 67 	call	#26370		;#0x6702
    7ad8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7adc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ade:	02 24       	jz	$+6      	;abs 0x7ae4

00007ae0 <.Loc.139.1>:
    7ae0:	b0 12 1e 67 	call	#26398		;#0x671e

00007ae4 <.L12>:
    7ae4:	b0 12 64 64 	call	#25700		;#0x6464

00007ae8 <.Loc.140.1>:
}
    7ae8:	03 43       	nop			
    7aea:	21 52       	add	#4,	r1	;r2 As==10
    7aec:	b4 17       	popm	#12,	r15	;16-bit words
    7aee:	00 13       	reti			

00007af0 <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    7af0:	21 83       	decd	r1		;

00007af2 <.LCFI8>:
    7af2:	81 4c 00 00 	mov	r12,	0(r1)	;

00007af6 <.Loc.309.1>:

  PAOUT = config->porta.out;
    7af6:	2c 41       	mov	@r1,	r12	;
    7af8:	2c 4c       	mov	@r12,	r12	;
    7afa:	82 4c 02 02 	mov	r12,	&0x0202	;

00007afe <.Loc.310.1>:
  PADIR = config->porta.dir;
    7afe:	2c 41       	mov	@r1,	r12	;
    7b00:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b04:	82 4c 04 02 	mov	r12,	&0x0204	;

00007b08 <.Loc.311.1>:
  PAREN = config->porta.ren;
    7b08:	2c 41       	mov	@r1,	r12	;
    7b0a:	1c 4c 04 00 	mov	4(r12),	r12	;
    7b0e:	82 4c 06 02 	mov	r12,	&0x0206	;

00007b12 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7b12:	2c 41       	mov	@r1,	r12	;
    7b14:	1c 4c 06 00 	mov	6(r12),	r12	;
    7b18:	82 4c 0a 02 	mov	r12,	&0x020a	;

00007b1c <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    7b1c:	2c 41       	mov	@r1,	r12	;
    7b1e:	1c 4c 08 00 	mov	8(r12),	r12	;
    7b22:	82 4c 0c 02 	mov	r12,	&0x020c	;

00007b26 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    7b26:	2c 41       	mov	@r1,	r12	;
    7b28:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7b2c:	82 4c 22 02 	mov	r12,	&0x0222	;

00007b30 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    7b30:	2c 41       	mov	@r1,	r12	;
    7b32:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7b36:	82 4c 24 02 	mov	r12,	&0x0224	;

00007b3a <.Loc.317.1>:
  PBREN = config->portb.ren;
    7b3a:	2c 41       	mov	@r1,	r12	;
    7b3c:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    7b40:	82 4c 26 02 	mov	r12,	&0x0226	;

00007b44 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7b44:	2c 41       	mov	@r1,	r12	;
    7b46:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    7b4a:	82 4c 2a 02 	mov	r12,	&0x022a	;

00007b4e <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    7b4e:	2c 41       	mov	@r1,	r12	;
    7b50:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7b54:	82 4c 2c 02 	mov	r12,	&0x022c	;

00007b58 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    7b58:	2c 41       	mov	@r1,	r12	;
    7b5a:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    7b5e:	82 4c 22 03 	mov	r12,	&0x0322	;

00007b62 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    7b62:	2c 41       	mov	@r1,	r12	;
    7b64:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    7b68:	82 4c 24 03 	mov	r12,	&0x0324	;

00007b6c <.Loc.351.1>:
  PJREN = config->portj.ren;
    7b6c:	2c 41       	mov	@r1,	r12	;
    7b6e:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    7b72:	82 4c 26 03 	mov	r12,	&0x0326	;

00007b76 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    7b76:	2c 41       	mov	@r1,	r12	;
    7b78:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    7b7c:	82 4c 2a 03 	mov	r12,	&0x032a	;

00007b80 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    7b80:	2c 41       	mov	@r1,	r12	;
    7b82:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    7b86:	82 4c 2c 03 	mov	r12,	&0x032c	;

00007b8a <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    7b8a:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    7b8e:	1c c3       	bic	#1,	r12	;r3 As==01
    7b90:	82 4c 30 01 	mov	r12,	&0x0130	;

00007b94 <.Loc.356.1>:
}
    7b94:	03 43       	nop			
    7b96:	21 53       	incd	r1		;
    7b98:	30 41       	ret			

00007b9a <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7b9a:	03 43       	nop			
    7b9c:	30 41       	ret			

00007b9e <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7b9e:	03 43       	nop			
    7ba0:	30 41       	ret			

00007ba2 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7ba2:	b0 12 9a 7b 	call	#31642		;#0x7b9a
    7ba6:	b0 12 86 64 	call	#25734		;#0x6486

00007baa <.Loc.527.2>:
}
    7baa:	03 43       	nop			
    7bac:	30 41       	ret			

00007bae <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7bae:	b0 12 a8 64 	call	#25768		;#0x64a8
    7bb2:	b0 12 9e 7b 	call	#31646		;#0x7b9e

00007bb6 <.Loc.538.2>:
}
    7bb6:	03 43       	nop			
    7bb8:	30 41       	ret			

00007bba <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    7bba:	21 83       	decd	r1		;

00007bbc <.LCFI1>:
    7bbc:	81 4c 00 00 	mov	r12,	0(r1)	;

00007bc0 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    7bc0:	2c 41       	mov	@r1,	r12	;
    7bc2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00007bc6 <.Loc.768.2>:
}
    7bc6:	03 43       	nop			
    7bc8:	21 53       	incd	r1		;
    7bca:	30 41       	ret			

00007bcc <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    7bcc:	21 82       	sub	#4,	r1	;r2 As==10

00007bce <.LCFI2>:
    7bce:	81 4c 02 00 	mov	r12,	2(r1)	;
    7bd2:	81 4d 00 00 	mov	r13,	0(r1)	;

00007bd6 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    7bd6:	1c 41 02 00 	mov	2(r1),	r12	;
    7bda:	2d 41       	mov	@r1,	r13	;
    7bdc:	b0 12 02 68 	call	#26626		;#0x6802

00007be0 <.Loc.797.2>:
}
    7be0:	21 52       	add	#4,	r1	;r2 As==10
    7be2:	30 41       	ret			

00007be4 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    7be4:	0a 15       	pushm	#1,	r10	;16-bit words

00007be6 <.LCFI3>:
    7be6:	21 82       	sub	#4,	r1	;r2 As==10

00007be8 <.LCFI4>:
    7be8:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    7bec:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

00007bf0 <.Loc.63.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    7bf0:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7bf4:	12 c3       	clrc			
    7bf6:	0c 10       	rrc	r12		;
    7bf8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7bfc:	0c 5c       	rla	r12		;
    7bfe:	0d 4c       	mov	r12,	r13	;
    7c00:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    7c04:	81 4d 02 00 	mov	r13,	2(r1)	;

00007c08 <.Loc.64.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    7c08:	1c 41 02 00 	mov	2(r1),	r12	;
    7c0c:	2a 4c       	mov	@r12,	r10	;
    7c0e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c12:	5c f3       	and.b	#1,	r12	;r3 As==01
    7c14:	0d 4c       	mov	r12,	r13	;
    7c16:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7c1a:	3c 40 00 ff 	mov	#65280,	r12	;#0xff00
    7c1e:	b0 12 16 a0 	call	#40982		;#0xa016
    7c22:	0d 4a       	mov	r10,	r13	;
    7c24:	0d fc       	and	r12,	r13	;
    7c26:	1c 41 02 00 	mov	2(r1),	r12	;
    7c2a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007c2e <.Loc.65.3>:
  *ctl |= trigger << (8 * (index % 2));
    7c2e:	1c 41 02 00 	mov	2(r1),	r12	;
    7c32:	2a 4c       	mov	@r12,	r10	;
    7c34:	6c 41       	mov.b	@r1,	r12	;
    7c36:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7c3a:	5d f3       	and.b	#1,	r13	;r3 As==01
    7c3c:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7c40:	b0 12 82 9f 	call	#40834		;#0x9f82
    7c44:	0d 4a       	mov	r10,	r13	;
    7c46:	0d dc       	bis	r12,	r13	;
    7c48:	1c 41 02 00 	mov	2(r1),	r12	;
    7c4c:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007c50 <.Loc.66.3>:
}
    7c50:	03 43       	nop			
    7c52:	21 52       	add	#4,	r1	;r2 As==10
    7c54:	0a 17       	popm	#1,	r10	;16-bit words
    7c56:	30 41       	ret			

00007c58 <init_request>:
static void init_request(const msp430x_dma_req_t * request, uint8_t index) {
    7c58:	31 80 06 00 	sub	#6,	r1	;

00007c5c <.LCFI5>:
    7c5c:	81 4c 02 00 	mov	r12,	2(r1)	;
    7c60:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007c64 <.Loc.69.3>:

  dma_trigger_set(index, request->trigger);
    7c64:	1c 41 02 00 	mov	2(r1),	r12	;
    7c68:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7c6c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7c70:	4d 4c       	mov.b	r12,	r13	;
    7c72:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c76:	b0 12 e4 7b 	call	#31716		;#0x7be4

00007c7a <.Loc.70.3>:
  callbacks[index]          = request->callback;
    7c7a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c7e:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7c82:	3c 50 5a 52 	add	#21082,	r12	;#0x525a
    7c86:	1d 41 02 00 	mov	2(r1),	r13	;
    7c8a:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    7c8e:	00 00 
    7c90:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    7c94:	02 00 

00007c96 <.Loc.71.3>:
  msp430x_dma_ch_reg_t * ch = &dma_regs[index];
    7c96:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7c9a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c9e:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7ca2:	0e 4d       	mov	r13,	r14	;
    7ca4:	0e 5c       	add	r12,	r14	;
    7ca6:	81 4e 04 00 	mov	r14,	4(r1)	;

00007caa <.Loc.72.3>:
  ch->sa                    = (uintptr_t)request->source_addr;
    7caa:	1c 41 02 00 	mov	2(r1),	r12	;
    7cae:	2c 4c       	mov	@r12,	r12	;
    7cb0:	0d 43       	clr	r13		;
    7cb2:	1e 41 04 00 	mov	4(r1),	r14	;
    7cb6:	8e 4c 02 00 	mov	r12,	2(r14)	;
    7cba:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007cbe <.Loc.73.3>:
  ch->da                    = (uintptr_t)request->dest_addr;
    7cbe:	1c 41 02 00 	mov	2(r1),	r12	;
    7cc2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7cc6:	0d 43       	clr	r13		;
    7cc8:	1e 41 04 00 	mov	4(r1),	r14	;
    7ccc:	8e 4c 06 00 	mov	r12,	6(r14)	;
    7cd0:	8e 4d 08 00 	mov	r13,	8(r14)	;

00007cd4 <.Loc.74.3>:
  ch->sz                    = request->size;
    7cd4:	1c 41 02 00 	mov	2(r1),	r12	;
    7cd8:	1d 4c 04 00 	mov	4(r12),	r13	;
    7cdc:	1c 41 04 00 	mov	4(r1),	r12	;
    7ce0:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007ce4 <.Loc.75.3>:
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    7ce4:	1c 41 02 00 	mov	2(r1),	r12	;
    7ce8:	1d 4c 08 00 	mov	8(r12),	r13	;
    7cec:	1c 41 02 00 	mov	2(r1),	r12	;
    7cf0:	1c 4c 06 00 	mov	6(r12),	r12	;
    7cf4:	0d dc       	bis	r12,	r13	;

00007cf6 <.Loc.76.3>:
            request->transfer_mode;
    7cf6:	1c 41 02 00 	mov	2(r1),	r12	;
    7cfa:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a

00007cfe <.Loc.75.3>:
  callbacks[index]          = request->callback;
  msp430x_dma_ch_reg_t * ch = &dma_regs[index];
  ch->sa                    = (uintptr_t)request->source_addr;
  ch->da                    = (uintptr_t)request->dest_addr;
  ch->sz                    = request->size;
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    7cfe:	0c dd       	bis	r13,	r12	;
    7d00:	0d 4c       	mov	r12,	r13	;
    7d02:	3d d0 15 00 	bis	#21,	r13	;#0x0015
    7d06:	1c 41 04 00 	mov	4(r1),	r12	;
    7d0a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007d0e <.Loc.77.3>:
            request->transfer_mode;
}
    7d0e:	03 43       	nop			
    7d10:	31 50 06 00 	add	#6,	r1	;
    7d14:	30 41       	ret			

00007d16 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    7d16:	bf 15       	pushm	#12,	r15	;16-bit words

00007d18 <.LCFI6>:
    7d18:	21 82       	sub	#4,	r1	;r2 As==10

00007d1a <.LCFI7>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    7d1a:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7d1e:	b0 12 cc 64 	call	#25804		;#0x64cc

00007d22 <.Loc.87.3>:

  index = (DMAIV >> 1) - 1;
    7d22:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    7d26:	12 c3       	clrc			
    7d28:	0c 10       	rrc	r12		;
    7d2a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7d2e:	4d 4c       	mov.b	r12,	r13	;
    7d30:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7d32:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007d36 <.Loc.89.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    7d36:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7d38:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7d3c:	46 28       	jnc	$+142    	;abs 0x7dca

00007d3e <.LBB2>:
    if (dma_regs[index].ctl & DMADT_4) {
    7d3e:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7d42:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7d46:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7d4a:	0c 5d       	add	r13,	r12	;
    7d4c:	2c 4c       	mov	@r12,	r12	;
    7d4e:	3c f0 00 40 	and	#16384,	r12	;#0x4000
    7d52:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d54:	19 24       	jz	$+52     	;abs 0x7d88

00007d56 <.Loc.92.3>:
      /* Set to idle mode (but still claimed) */
      dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    7d56:	4d 43       	clr.b	r13		;
    7d58:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7d5c:	b0 12 e4 7b 	call	#31716		;#0x7be4

00007d60 <.Loc.93.3>:
      dma_regs[index].sz  = 0;
    7d60:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7d64:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7d68:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7d6c:	0c 5d       	add	r13,	r12	;
    7d6e:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007d72 <.Loc.94.3>:
      dma_regs[index].ctl = DMAEN | DMAABORT | DMADT_4;
    7d72:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7d76:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7d7a:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7d7e:	0c 5d       	add	r13,	r12	;
    7d80:	bc 40 12 40 	mov	#16402,	0(r12)	;#0x4012
    7d84:	00 00 
    7d86:	0e 3c       	jmp	$+30     	;abs 0x7da4

00007d88 <.L19>:
    }
    else {
      /* Release the channel back into the pool */
      osalSysLockFromISR();
    7d88:	b0 12 a2 7b 	call	#31650		;#0x7ba2

00007d8c <.Loc.99.3>:
      queue_length--;
    7d8c:	1c 42 68 52 	mov	&0x5268,r12	;0x5268
    7d90:	3c 53       	add	#-1,	r12	;r3 As==11
    7d92:	82 4c 68 52 	mov	r12,	&0x5268	;

00007d96 <.Loc.100.3>:
      osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7d96:	4d 43       	clr.b	r13		;
    7d98:	3c 40 66 52 	mov	#21094,	r12	;#0x5266
    7d9c:	b0 12 54 69 	call	#26964		;#0x6954

00007da0 <.Loc.101.3>:
      osalSysUnlockFromISR();
    7da0:	b0 12 ae 7b 	call	#31662		;#0x7bae

00007da4 <.L20>:
    }

    msp430x_dma_cb_t * cb = &callbacks[index];
    7da4:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7da8:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7dac:	0d 4c       	mov	r12,	r13	;
    7dae:	3d 50 5a 52 	add	#21082,	r13	;#0x525a
    7db2:	81 4d 00 00 	mov	r13,	0(r1)	;

00007db6 <.Loc.107.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    7db6:	2c 41       	mov	@r1,	r12	;
    7db8:	2c 4c       	mov	@r12,	r12	;
    7dba:	0c 93       	cmp	#0,	r12	;r3 As==00
    7dbc:	06 24       	jz	$+14     	;abs 0x7dca

00007dbe <.Loc.108.3>:
      cb->callback(cb->args);
    7dbe:	2c 41       	mov	@r1,	r12	;
    7dc0:	2d 4c       	mov	@r12,	r13	;
    7dc2:	2c 41       	mov	@r1,	r12	;
    7dc4:	1c 4c 02 00 	mov	2(r12),	r12	;
    7dc8:	8d 12       	call	r13		;

00007dca <.L18>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    7dca:	b0 12 fa 64 	call	#25850		;#0x64fa
    7dce:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    7dd2:	b0 12 44 64 	call	#25668		;#0x6444
    7dd6:	b0 12 02 67 	call	#26370		;#0x6702
    7dda:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7dde:	0c 93       	cmp	#0,	r12	;r3 As==00
    7de0:	02 24       	jz	$+6      	;abs 0x7de6

00007de2 <.Loc.112.3>:
    7de2:	b0 12 1e 67 	call	#26398		;#0x671e

00007de6 <.L21>:
    7de6:	b0 12 64 64 	call	#25700		;#0x6464

00007dea <.Loc.113.3>:
}
    7dea:	03 43       	nop			
    7dec:	21 52       	add	#4,	r1	;r2 As==10
    7dee:	b4 17       	popm	#12,	r15	;16-bit words
    7df0:	00 13       	reti			

00007df2 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    7df2:	3c 40 66 52 	Address 0x0000000000007df4 is out of bounds.
mov	#65535,	r12	;#0xffff

00007df4 <L0>:
    7df4:	66 52       	add.b	#4,	r6	;r2 As==10
    7df6:	b0 12 ba 7b 	call	#31674		;#0x7bba

00007dfa <.Loc.126.3>:
}
    7dfa:	03 43       	nop			
    7dfc:	30 41       	ret			

00007dfe <dmaRequestS>:
 *          the request has timed out.
 *         
 * @sclass
 */
msg_t dmaRequestS(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request, 
    systime_t timeout) {
    7dfe:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00007e02 <.LCFI8>:
    7e02:	81 4c 04 00 	mov	r12,	4(r1)	;
    7e06:	81 4d 02 00 	mov	r13,	2(r1)	;
    7e0a:	81 4e 00 00 	mov	r14,	0(r1)	;

00007e0e <.Loc.147.3>:
  
  osalDbgCheckClassS();
    7e0e:	b0 12 48 65 	call	#25928		;#0x6548

00007e12 <.Loc.150.3>:
  
  /* Check if a DMA channel is available */
  if (queue_length >= MSP430X_DMA_CHANNELS) {
    7e12:	1d 42 68 52 	mov	&0x5268,r13	;0x5268
    7e16:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7e18:	0c 9d       	cmp	r13,	r12	;
    7e1a:	0d 2c       	jc	$+28     	;abs 0x7e36

00007e1c <.LBB3>:
    msg_t queueresult = osalThreadEnqueueTimeoutS(&dma_queue, timeout);
    7e1c:	2d 41       	mov	@r1,	r13	;
    7e1e:	3c 40 66 52 	mov	#21094,	r12	;#0x5266
    7e22:	b0 12 cc 7b 	call	#31692		;#0x7bcc
    7e26:	81 4c 06 00 	mov	r12,	6(r1)	;

00007e2a <.Loc.152.3>:
    if (queueresult != MSG_OK)
    7e2a:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    7e2e:	03 24       	jz	$+8      	;abs 0x7e36

00007e30 <.Loc.153.3>:
      return queueresult;
    7e30:	1c 41 06 00 	mov	6(r1),	r12	;
    7e34:	3d 3c       	jmp	$+124    	;abs 0x7eb0

00007e36 <.L24>:
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
    7e36:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00

00007e3a <.Loc.158.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7e3a:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    7e3e:	0e 3c       	jmp	$+30     	;abs 0x7e5c

00007e40 <.L29>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    7e40:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7e44:	1c 41 08 00 	mov	8(r1),	r12	;
    7e48:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7e4c:	0c 5d       	add	r13,	r12	;
    7e4e:	2c 4c       	mov	@r12,	r12	;
    7e50:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7e54:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e56:	07 24       	jz	$+16     	;abs 0x7e66

00007e58 <.Loc.158.3>:
      return queueresult;
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7e58:	91 53 08 00 	inc	8(r1)		;

00007e5c <.L26>:
    7e5c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7e5e:	1c 91 08 00 	cmp	8(r1),	r12	;
    7e62:	ee 37       	jge	$-34     	;abs 0x7e40
    7e64:	01 3c       	jmp	$+4      	;abs 0x7e68

00007e66 <.L31>:
    if (!(dma_regs[i].ctl & DMAEN)) {
      break;
    7e66:	03 43       	nop			

00007e68 <.L28>:
    }
  }
  
  /* Additional channel is in use */
  queue_length++;
    7e68:	1c 42 68 52 	mov	&0x5268,r12	;0x5268
    7e6c:	1c 53       	inc	r12		;
    7e6e:	82 4c 68 52 	mov	r12,	&0x5268	;

00007e72 <.Loc.168.3>:

  /* Make the request */
  init_request(request, i);
    7e72:	1c 41 08 00 	mov	8(r1),	r12	;
    7e76:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e7a:	4d 4c       	mov.b	r12,	r13	;
    7e7c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e80:	b0 12 58 7c 	call	#31832		;#0x7c58

00007e84 <.Loc.170.3>:
  
  if (channel != NULL) {
    7e84:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    7e88:	12 24       	jz	$+38     	;abs 0x7eae

00007e8a <.Loc.171.3>:
    channel->index = i;
    7e8a:	1c 41 08 00 	mov	8(r1),	r12	;
    7e8e:	4d 4c       	mov.b	r12,	r13	;
    7e90:	1c 41 04 00 	mov	4(r1),	r12	;
    7e94:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00007e98 <.Loc.172.3>:
    channel->registers = &dma_regs[i];
    7e98:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7e9c:	1c 41 08 00 	mov	8(r1),	r12	;
    7ea0:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7ea4:	0d 5c       	add	r12,	r13	;
    7ea6:	1c 41 04 00 	mov	4(r1),	r12	;
    7eaa:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007eae <.L30>:
  }
  
  return MSG_OK;
    7eae:	4c 43       	clr.b	r12		;

00007eb0 <.L25>:
}
    7eb0:	31 50 0a 00 	add	#10,	r1	;#0x000a
    7eb4:	30 41       	ret			

00007eb6 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    7eb6:	21 83       	decd	r1		;

00007eb8 <.LCFI13>:
    7eb8:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ebc <L0>:
  
  osalDbgCheckClassI();
    7ebc:	b0 12 2a 65 	call	#25898		;#0x652a

00007ec0 <.Loc.297.3>:
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    7ec0:	2c 41       	mov	@r1,	r12	;
    7ec2:	2c 4c       	mov	@r12,	r12	;
    7ec4:	2c 4c       	mov	@r12,	r12	;
    7ec6:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7eca:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ecc:	34 24       	jz	$+106    	;abs 0x7f36

00007ece <.Loc.302.3>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  if (channel->registers->ctl & DMADT_4) {
    7ece:	2c 41       	mov	@r1,	r12	;
    7ed0:	2c 4c       	mov	@r12,	r12	;
    7ed2:	2c 4c       	mov	@r12,	r12	;
    7ed4:	3c f0 00 40 	and	#16384,	r12	;#0x4000
    7ed8:	0c 93       	cmp	#0,	r12	;r3 As==00
    7eda:	19 24       	jz	$+52     	;abs 0x7f0e

00007edc <.Loc.304.3>:
    /* Cancel */
    channel->registers->ctl &= ~(DMAEN | DMAREQ);
    7edc:	2c 41       	mov	@r1,	r12	;
    7ede:	2c 4c       	mov	@r12,	r12	;
    7ee0:	2d 41       	mov	@r1,	r13	;
    7ee2:	2d 4d       	mov	@r13,	r13	;
    7ee4:	2d 4d       	mov	@r13,	r13	;
    7ee6:	3d f0 ee ff 	and	#65518,	r13	;#0xffee
    7eea:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007eee <.Loc.306.3>:
    /* Set to idle mode (but still claimed */
    dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    7eee:	2c 41       	mov	@r1,	r12	;
    7ef0:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    7ef4:	4d 43       	clr.b	r13		;
    7ef6:	b0 12 e4 7b 	call	#31716		;#0x7be4

00007efa <.Loc.307.3>:
    channel->registers->sz  = 0;
    7efa:	2c 41       	mov	@r1,	r12	;
    7efc:	2c 4c       	mov	@r12,	r12	;
    7efe:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007f02 <.Loc.308.3>:
    channel->registers->ctl = DMAEN | DMAABORT | DMADT_4;
    7f02:	2c 41       	mov	@r1,	r12	;
    7f04:	2c 4c       	mov	@r12,	r12	;
    7f06:	bc 40 12 40 	mov	#16402,	0(r12)	;#0x4012
    7f0a:	00 00 
    7f0c:	15 3c       	jmp	$+44     	;abs 0x7f38

00007f0e <.L42>:
  }
  else {
    /* Cancel */
    channel->registers->ctl &= ~(DMAEN | DMAREQ);
    7f0e:	2c 41       	mov	@r1,	r12	;
    7f10:	2c 4c       	mov	@r12,	r12	;
    7f12:	2d 41       	mov	@r1,	r13	;
    7f14:	2d 4d       	mov	@r13,	r13	;
    7f16:	2d 4d       	mov	@r13,	r13	;
    7f18:	3d f0 ee ff 	and	#65518,	r13	;#0xffee
    7f1c:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007f20 <.Loc.314.3>:
    /* Release the DMA channel back to the pool */
    queue_length--;
    7f20:	1c 42 68 52 	mov	&0x5268,r12	;0x5268
    7f24:	3c 53       	add	#-1,	r12	;r3 As==11
    7f26:	82 4c 68 52 	mov	r12,	&0x5268	;

00007f2a <.Loc.315.3>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7f2a:	4d 43       	clr.b	r13		;
    7f2c:	3c 40 66 52 	mov	#21094,	r12	;#0x5266
    7f30:	b0 12 54 69 	call	#26964		;#0x6954
    7f34:	01 3c       	jmp	$+4      	;abs 0x7f38

00007f36 <.L43>:
  
  osalDbgCheckClassI();
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    return;
    7f36:	03 43       	nop			

00007f38 <.L39>:
    /* Release the DMA channel back to the pool */
    queue_length--;
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
  }
  
}
    7f38:	21 53       	incd	r1		;
    7f3a:	30 41       	ret			

00007f3c <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7f3c:	03 43       	nop			
    7f3e:	30 41       	ret			

00007f40 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7f40:	03 43       	nop			
    7f42:	30 41       	ret			

00007f44 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7f44:	b0 12 3c 7f 	call	#32572		;#0x7f3c
    7f48:	b0 12 86 64 	call	#25734		;#0x6486

00007f4c <.Loc.527.2>:
}
    7f4c:	03 43       	nop			
    7f4e:	30 41       	ret			

00007f50 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7f50:	b0 12 a8 64 	call	#25768		;#0x64a8
    7f54:	b0 12 40 7f 	call	#32576		;#0x7f40

00007f58 <.Loc.538.2>:
}
    7f58:	03 43       	nop			
    7f5a:	30 41       	ret			

00007f5c <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7f5c:	21 82       	sub	#4,	r1	;r2 As==10

00007f5e <.LCFI1>:
    7f5e:	81 4c 02 00 	mov	r12,	2(r1)	;
    7f62:	81 4d 00 00 	mov	r13,	0(r1)	;

00007f66 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7f66:	2d 41       	mov	@r1,	r13	;
    7f68:	1c 41 02 00 	mov	2(r1),	r12	;
    7f6c:	b0 12 a6 67 	call	#26534		;#0x67a6

00007f70 <.Loc.740.2>:
}
    7f70:	03 43       	nop			
    7f72:	21 52       	add	#4,	r1	;r2 As==10
    7f74:	30 41       	ret			

00007f76 <ISR_USCI_B0_VECTOR>:
  /* Enable RX interrupt to handle the last byte */
  i2cp->regs->ie |= UCRXIE0;
}

#if MSP430X_I2C_USE_I2CB0
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
    7f76:	bf 15       	pushm	#12,	r15	;16-bit words

00007f78 <.LCFI4>:
  OSAL_IRQ_PROLOGUE();
    7f78:	d2 43 cc 51 	mov.b	#1,	&0x51cc	;r3 As==01
    7f7c:	b0 12 cc 64 	call	#25804		;#0x64cc

00007f80 <.Loc.97.3>:
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    7f80:	1c 42 6e 06 	mov	&0x066e,r12	;0x066e
    7f84:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    7f88:	4b 24       	jz	$+152    	;abs 0x8020
    7f8a:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    7f8e:	0d 9c       	cmp	r12,	r13	;
    7f90:	0c 28       	jnc	$+26     	;abs 0x7faa
    7f92:	3c 90 06 00 	cmp	#6,	r12	;
    7f96:	44 24       	jz	$+138    	;abs 0x8020
    7f98:	7d 40 06 00 	mov.b	#6,	r13	;
    7f9c:	0d 9c       	cmp	r12,	r13	;
    7f9e:	40 28       	jnc	$+130    	;abs 0x8020
    7fa0:	2c 93       	cmp	#2,	r12	;r3 As==10
    7fa2:	14 24       	jz	$+42     	;abs 0x7fcc
    7fa4:	2c 92       	cmp	#4,	r12	;r2 As==10
    7fa6:	18 24       	jz	$+50     	;abs 0x7fd8

00007fa8 <.Loc.99.3>:
    case USCI_NONE:
      break;
    7fa8:	3e 3c       	jmp	$+126    	;abs 0x8026

00007faa <.L19>:
}

#if MSP430X_I2C_USE_I2CB0
PORT_IRQ_HANDLER(USCI_B0_VECTOR) {
  OSAL_IRQ_PROLOGUE();
  switch(__even_in_range(UCB0IV, USCI_I2C_UCCLTOIFG)) {
    7faa:	3c 90 16 00 	cmp	#22,	r12	;#0x0016
    7fae:	1a 24       	jz	$+54     	;abs 0x7fe4
    7fb0:	7d 40 16 00 	mov.b	#22,	r13	;#0x0016
    7fb4:	0d 9c       	cmp	r12,	r13	;
    7fb6:	34 2c       	jc	$+106    	;abs 0x8020
    7fb8:	3c 90 1a 00 	cmp	#26,	r12	;#0x001a
    7fbc:	33 24       	jz	$+104    	;abs 0x8024
    7fbe:	3c 90 1c 00 	cmp	#28,	r12	;#0x001c
    7fc2:	27 24       	jz	$+80     	;abs 0x8012
    7fc4:	3c 90 18 00 	cmp	#24,	r12	;#0x0018
    7fc8:	1e 24       	jz	$+62     	;abs 0x8006
    7fca:	2d 3c       	jmp	$+92     	;abs 0x8026

00007fcc <.L21>:
    case USCI_NONE:
      break;
    case USCI_I2C_UCALIFG:
      /* Arbitration loss error */
      I2CDB0.errors |= I2C_ARBITRATION_LOST;
    7fcc:	1c 42 6e 52 	mov	&0x526e,r12	;0x526e
    7fd0:	2c d3       	bis	#2,	r12	;r3 As==10
    7fd2:	82 4c 6e 52 	mov	r12,	&0x526e	;

00007fd6 <.Loc.103.3>:
      break;
    7fd6:	27 3c       	jmp	$+80     	;abs 0x8026

00007fd8 <.L22>:
    case USCI_I2C_UCNACKIFG:
      /* NACK received */
      I2CDB0.errors |= I2C_ACK_FAILURE;
    7fd8:	1c 42 6e 52 	mov	&0x526e,r12	;0x526e
    7fdc:	2c d2       	bis	#4,	r12	;r2 As==10
    7fde:	82 4c 6e 52 	mov	r12,	&0x526e	;

00007fe2 <.Loc.107.3>:
      break;
    7fe2:	21 3c       	jmp	$+68     	;abs 0x8026

00007fe4 <.L24>:
    case USCI_I2C_UCTXIFG1:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    case USCI_I2C_UCRXIFG0:
      /* Handle final byte */
      ((uint8_t *)(I2CDB0.req.dest_addr))[I2CDB0.req.size] = UCB0RXBUF;
    7fe4:	1d 42 76 52 	mov	&0x5276,r13	;0x5276
    7fe8:	1c 42 78 52 	mov	&0x5278,r12	;0x5278
    7fec:	0c 5d       	add	r13,	r12	;
    7fee:	1d 42 4c 06 	mov	&0x064c,r13	;0x064c
    7ff2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    7ff6:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00007ffa <.Loc.122.3>:
      /* Disable interrupt */
      UCB0IE &= ~(UCRXIE);
    7ffa:	1c 42 6a 06 	mov	&0x066a,r12	;0x066a
    7ffe:	1c c3       	bic	#1,	r12	;r3 As==01
    8000:	82 4c 6a 06 	mov	r12,	&0x066a	;

00008004 <.Loc.123.3>:
      break;
    8004:	10 3c       	jmp	$+34     	;abs 0x8026

00008006 <.L28>:
    case USCI_I2C_UCTXIFG0:
      /* Disable interrupt */
      UCB0IE &= ~(UCTXIE);
    8006:	1c 42 6a 06 	mov	&0x066a,r12	;0x066a
    800a:	2c c3       	bic	#2,	r12	;r3 As==10
    800c:	82 4c 6a 06 	mov	r12,	&0x066a	;

00008010 <.Loc.127.3>:
      break;
    8010:	0a 3c       	jmp	$+22     	;abs 0x8026

00008012 <.L27>:
    case USCI_I2C_UCBCNTIFG:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    case USCI_I2C_UCCLTOIFG:
      /* Bus low timeout */
      I2CDB0.errors |= I2C_TIMEOUT;
    8012:	1c 42 6e 52 	mov	&0x526e,r12	;0x526e
    8016:	3c d0 20 00 	bis	#32,	r12	;#0x0020
    801a:	82 4c 6e 52 	mov	r12,	&0x526e	;

0000801e <.Loc.134.3>:
      break;
    801e:	03 3c       	jmp	$+8      	;abs 0x8026

00008020 <.L32>:
    case USCI_I2C_UCRXIFG2:
    case USCI_I2C_UCTXIFG2:
    case USCI_I2C_UCRXIFG1:
    case USCI_I2C_UCTXIFG1:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    8020:	03 43       	nop			
    8022:	01 3c       	jmp	$+4      	;abs 0x8026

00008024 <.L33>:
      /* Disable interrupt */
      UCB0IE &= ~(UCTXIE);
      break;
    case USCI_I2C_UCBCNTIFG:
      osalDbgAssert(false, "Spurious interrupt in I2C driver");
      break;
    8024:	03 43       	nop			

00008026 <.L17>:
      /* Bus low timeout */
      I2CDB0.errors |= I2C_TIMEOUT;
      break;
  }
      
  osalSysLockFromISR();
    8026:	b0 12 44 7f 	call	#32580		;#0x7f44

0000802a <.Loc.140.3>:
  
  /* Cancel DMA transaction - either it's complete or there's been an error */
  dmaCancelI(&I2CDB0.dma);
    802a:	3c 40 8a 52 	mov	#21130,	r12	;#0x528a
    802e:	b0 12 b6 7e 	call	#32438		;#0x7eb6

00008032 <.Loc.143.3>:
  
  /* Turn off the TX IFG flag so that we'll start DMA correctly next time */
  I2CDB0.regs->ifg &= ~(UCTXIFG);
    8032:	1c 42 72 52 	mov	&0x5272,r12	;0x5272
    8036:	1d 42 72 52 	mov	&0x5272,r13	;0x5272
    803a:	1d 4d 2c 00 	mov	44(r13),r13	;0x0002c
    803e:	2d c3       	bic	#2,	r13	;r3 As==10
    8040:	8c 4d 2c 00 	mov	r13,	44(r12)	; 0x002c

00008044 <.Loc.146.3>:
  
  /* Wake the thread */
  if (I2CDB0.errors != I2C_NO_ERROR) {
    8044:	1c 42 6e 52 	mov	&0x526e,r12	;0x526e
    8048:	0c 93       	cmp	#0,	r12	;r3 As==00
    804a:	07 24       	jz	$+16     	;abs 0x805a

0000804c <.Loc.147.3>:
    osalThreadResumeI(&I2CDB0.thread, MSG_RESET);
    804c:	3d 40 fe ff 	mov	#65534,	r13	;#0xfffe
    8050:	3c 40 86 52 	mov	#21126,	r12	;#0x5286
    8054:	b0 12 5c 7f 	call	#32604		;#0x7f5c
    8058:	05 3c       	jmp	$+12     	;abs 0x8064

0000805a <.L29>:
  }
  else {
    osalThreadResumeI(&I2CDB0.thread, MSG_OK);
    805a:	4d 43       	clr.b	r13		;
    805c:	3c 40 86 52 	mov	#21126,	r12	;#0x5286
    8060:	b0 12 5c 7f 	call	#32604		;#0x7f5c

00008064 <.L30>:
  }
  
  osalSysUnlockFromISR();
    8064:	b0 12 50 7f 	call	#32592		;#0x7f50

00008068 <.Loc.155.3>:
  
  OSAL_IRQ_EPILOGUE();
    8068:	b0 12 fa 64 	call	#25850		;#0x64fa
    806c:	c2 43 cc 51 	mov.b	#0,	&0x51cc	;r3 As==00
    8070:	b0 12 44 64 	call	#25668		;#0x6444
    8074:	b0 12 02 67 	call	#26370		;#0x6702
    8078:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    807c:	0c 93       	cmp	#0,	r12	;r3 As==00
    807e:	02 24       	jz	$+6      	;abs 0x8084

00008080 <.Loc.155.3>:
    8080:	b0 12 1e 67 	call	#26398		;#0x671e

00008084 <.L31>:
    8084:	b0 12 64 64 	call	#25700		;#0x6464

00008088 <.Loc.156.3>:
}
    8088:	03 43       	nop			
    808a:	b4 17       	popm	#12,	r15	;16-bit words
    808c:	00 13       	reti			

0000808e <i2c_lld_init>:
 * @notapi
 */
void i2c_lld_init(void) {

#if MSP430X_I2C_USE_I2CB0 == TRUE
  i2cObjectInit(&I2CDB0);
    808e:	3c 40 6a 52 	mov	#21098,	r12	;#0x526a
    8092:	b0 12 0e 70 	call	#28686		;#0x700e

00008096 <.Loc.367.3>:
  I2CDB0.regs = (msp430x_i2c_reg_t *)(&UCB0CTLW0);
    8096:	b2 40 40 06 	mov	#1600,	&0x5272	;#0x0640
    809a:	72 52 

0000809c <.Loc.368.3>:
  I2CDB0.req.data_mode = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    809c:	b2 40 c0 00 	Address 0x00000000000080a0 is out of bounds.
mov	#192,	&0xffff	;#0x00c0
    80a0:	7c 52 

000080a0 <L0>:
    80a0:	7c 52       	add.b	#8,	r12	;r2 As==11

000080a2 <.Loc.369.3>:
  I2CDB0.req.transfer_mode = MSP430X_DMA_SINGLE;
    80a2:	82 43 7e 52 	mov	#0,	&0x527e	;r3 As==00

000080a6 <.Loc.370.3>:
  I2CDB0.txtrig = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    80a6:	f2 40 13 00 	mov.b	#19,	&0x5288	;#0x0013
    80aa:	88 52 

000080ac <.Loc.371.3>:
  I2CDB0.rxtrig = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    80ac:	f2 40 12 00 	mov.b	#18,	&0x5289	;#0x0012
    80b0:	89 52 

000080b2 <.Loc.372.3>:
  I2CDB0.req.callback.callback = NULL;
    80b2:	82 43 82 52 	mov	#0,	&0x5282	;r3 As==00

000080b6 <.Loc.373.3>:
  I2CDB0.req.callback.args = (void*)(&I2CDB0);
    80b6:	b2 40 6a 52 	mov	#21098,	&0x5284	;#0x526a
    80ba:	84 52 

000080bc <.Loc.410.3>:
  I2CDB3.rxtrig = DMA_TRIGGER_MNEM(UCB3RXIFG0);
  I2CDB3.req.callback.callback = NULL;
  I2CDB3.req.callback.args = (void*)(&I2CDB3);
#endif
  
}
    80bc:	03 43       	nop			
    80be:	30 41       	ret			

000080c0 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    80c0:	32 c2       	dint			

000080c2 <.Loc.46.1>:

}
    80c2:	03 43       	nop			
    80c4:	30 41       	ret			

000080c6 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    80c6:	32 c2       	dint			

000080c8 <.Loc.348.1>:
  asm volatile("nop");
    80c8:	03 43       	nop			

000080ca <.Loc.349.1>:
}
    80ca:	03 43       	nop			
    80cc:	30 41       	ret			

000080ce <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    80ce:	03 43       	nop			

000080d0 <.Loc.356.1>:
  _enable_interrupts();
    80d0:	32 d2       	eint			
    80d2:	03 43       	nop			

000080d4 <.Loc.357.1>:
}
    80d4:	03 43       	nop			
    80d6:	30 41       	ret			

000080d8 <crcGenX25>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenX25(uint8_t * message, size_t n) {
    80d8:	31 80 06 00 	sub	#6,	r1	;

000080dc <.LCFI0>:
    80dc:	81 4c 02 00 	mov	r12,	2(r1)	;
    80e0:	81 4d 00 00 	mov	r13,	0(r1)	;

000080e4 <.Loc.31.2>:
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    80e4:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

000080e8 <.Loc.35.2>:
   
#if ELYSIUM_CRC_DMA
  /* Use DMA engine to write byte-wise to CRCDI register */
  dmareq.source_addr = (void*)message;
    80e8:	92 41 02 00 	mov	2(r1),	&0x516a	;
    80ec:	6a 51 

000080ee <.Loc.36.2>:
  dmareq.size = (n-2);
    80ee:	2c 41       	mov	@r1,	r12	;
    80f0:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    80f4:	82 4c 6e 51 	mov	r12,	&0x516e	;

000080f8 <.Loc.37.2>:
  chSysLock();
    80f8:	b0 12 c6 80 	call	#32966		;#0x80c6
    80fc:	b0 12 44 64 	call	#25668		;#0x6444

00008100 <.Loc.38.2>:
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    8100:	3e 43       	mov	#-1,	r14	;r3 As==11
    8102:	3d 40 6a 51 	mov	#20842,	r13	;#0x516a
    8106:	4c 43       	clr.b	r12		;
    8108:	b0 12 fe 7d 	call	#32254		;#0x7dfe
    810c:	0c 93       	cmp	#0,	r12	;r3 As==00
    810e:	12 34       	jge	$+38     	;abs 0x8134

00008110 <.LBB2>:
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    8110:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    8114:	09 3c       	jmp	$+20     	;abs 0x8128

00008116 <.L6>:
      CRCDI_L = message[i];
    8116:	1c 41 02 00 	mov	2(r1),	r12	;
    811a:	1c 51 04 00 	add	4(r1),	r12	;
    811e:	6c 4c       	mov.b	@r12,	r12	;
    8120:	c2 4c 50 01 	mov.b	r12,	&0x0150	;

00008124 <.Loc.41.2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    8124:	91 53 04 00 	inc	4(r1)		;

00008128 <.L5>:
    8128:	2c 41       	mov	@r1,	r12	;
    812a:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    812e:	81 9c 04 00 	cmp	r12,	4(r1)	;
    8132:	f1 2b       	jnc	$-28     	;abs 0x8116

00008134 <.L4>:
      CRCDI_L = message[i];
    }
#if ELYSIUM_CRC_DMA
  }
  chSysUnlock();
    8134:	b0 12 64 64 	call	#25700		;#0x6464
    8138:	b0 12 ce 80 	call	#32974		;#0x80ce

0000813c <.Loc.51.2>:
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    813c:	2c 41       	mov	@r1,	r12	;
    813e:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    8142:	1c 51 02 00 	add	2(r1),	r12	;
    8146:	5d 42 57 01 	mov.b	&0x0157,r13	;0x0157
    814a:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    814c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8150:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00008154 <.Loc.52.2>:
  *(message+n-1) = ~(CRCRESR_L);
    8154:	2c 41       	mov	@r1,	r12	;
    8156:	3c 53       	add	#-1,	r12	;r3 As==11
    8158:	1c 51 02 00 	add	2(r1),	r12	;
    815c:	5d 42 56 01 	mov.b	&0x0156,r13	;0x0156
    8160:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    8162:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8166:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000816a <.Loc.53.2>:
}
    816a:	03 43       	nop			
    816c:	31 50 06 00 	add	#6,	r1	;
    8170:	30 41       	ret			

00008172 <crcCheckX25>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckX25(uint8_t * message, size_t n) {
    8172:	31 80 06 00 	Address 0x0000000000008174 is out of bounds.
sub	#65535,	r1	;#0xffff

00008174 <L0>:
    8174:	06 00       	mova	@r0,	r6	;

00008176 <.LCFI1>:
    8176:	81 4c 02 00 	mov	r12,	2(r1)	;
    817a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000817e <.Loc.64.2>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    817e:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00008182 <.Loc.68.2>:

#if ELYSIUM_CRC_DMA
  /* Use DMA engine to write byte-wise to CRCDI register */
  dmareq.source_addr = (void*)message;
    8182:	92 41 02 00 	mov	2(r1),	&0x516a	;
    8186:	6a 51 

00008188 <.Loc.69.2>:
  dmareq.size = n-2;
    8188:	2c 41       	mov	@r1,	r12	;
    818a:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    818e:	82 4c 6e 51 	mov	r12,	&0x516e	;

00008192 <.Loc.70.2>:
  chSysLock();
    8192:	b0 12 c6 80 	call	#32966		;#0x80c6
    8196:	b0 12 44 64 	call	#25668		;#0x6444

0000819a <.Loc.71.2>:
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    819a:	3e 43       	mov	#-1,	r14	;r3 As==11
    819c:	3d 40 6a 51 	mov	#20842,	r13	;#0x516a
    81a0:	4c 43       	clr.b	r12		;
    81a2:	b0 12 fe 7d 	call	#32254		;#0x7dfe
    81a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    81a8:	12 34       	jge	$+38     	;abs 0x81ce

000081aa <.LBB3>:
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    81aa:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    81ae:	09 3c       	jmp	$+20     	;abs 0x81c2

000081b0 <.L10>:
      CRCDI_L = message[i];
    81b0:	1c 41 02 00 	mov	2(r1),	r12	;
    81b4:	1c 51 04 00 	add	4(r1),	r12	;
    81b8:	6c 4c       	mov.b	@r12,	r12	;
    81ba:	c2 4c 50 01 	mov.b	r12,	&0x0150	;

000081be <.Loc.74.2>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    81be:	91 53 04 00 	inc	4(r1)		;

000081c2 <.L9>:
    81c2:	2c 41       	mov	@r1,	r12	;
    81c4:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    81c8:	81 9c 04 00 	cmp	r12,	4(r1)	;
    81cc:	f1 2b       	jnc	$-28     	;abs 0x81b0

000081ce <.L8>:
      CRCDI_L = message[i];
    }
#if ELYSIUM_CRC_DMA
  }
  chSysUnlock();
    81ce:	b0 12 64 64 	call	#25700		;#0x6464
    81d2:	b0 12 ce 80 	call	#32974		;#0x80ce

000081d6 <.Loc.84.2>:
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((message[n-2] << 8) | message[n-1]));
    81d6:	1c 42 56 01 	mov	&0x0156,r12	;0x0156
    81da:	0e 4c       	mov	r12,	r14	;
    81dc:	3e e3       	inv	r14		;
    81de:	2c 41       	mov	@r1,	r12	;
    81e0:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    81e4:	1c 51 02 00 	add	2(r1),	r12	;
    81e8:	6c 4c       	mov.b	@r12,	r12	;
    81ea:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    81ee:	2d 41       	mov	@r1,	r13	;
    81f0:	3d 53       	add	#-1,	r13	;r3 As==11
    81f2:	1d 51 02 00 	add	2(r1),	r13	;
    81f6:	6d 4d       	mov.b	@r13,	r13	;
    81f8:	0c dd       	bis	r13,	r12	;
    81fa:	0d 4c       	mov	r12,	r13	;
    81fc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    81fe:	0e 9d       	cmp	r13,	r14	;
    8200:	01 24       	jz	$+4      	;abs 0x8204
    8202:	4c 43       	clr.b	r12		;

00008204 <.L11>:
    8204:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008208 <.Loc.85.2>:
}
    8208:	31 50 06 00 	add	#6,	r1	;
    820c:	30 41       	ret			

0000820e <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    820e:	32 c2       	dint			

00008210 <L0>:
  asm volatile("nop");
    8210:	03 43       	nop			

00008212 <.Loc.349.1>:
}
    8212:	03 43       	nop			
    8214:	30 41       	ret			

00008216 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    8216:	03 43       	nop			

00008218 <.Loc.356.1>:
  _enable_interrupts();
    8218:	32 d2       	eint			
    821a:	03 43       	nop			

0000821c <.Loc.357.1>:
}
    821c:	03 43       	nop			
    821e:	30 41       	ret			

00008220 <crcGenSDLP>:
 * then stores the result in the last two bytes of the message.
 *
 * @param message     pointer to the message buffer 
 * @param[in] n       size of the message including the CRC field
 */
void crcGenSDLP(uint8_t * message, size_t n) {
    8220:	31 80 06 00 	sub	#6,	r1	;

00008224 <.LCFI0>:
    8224:	81 4c 02 00 	mov	r12,	2(r1)	;
    8228:	81 4d 00 00 	mov	r13,	0(r1)	;

0000822c <.Loc.31.2>:
   * of 0xFFFF and no inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    822c:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00008230 <.Loc.35.2>:
   
#if ELYSIUM_CRC_DMA
  /* Use DMA engine to write byte-wise to CRCDI register */
  dmareq.source_addr = (void*)message;
    8230:	92 41 02 00 	mov	2(r1),	&0x517c	;
    8234:	7c 51 

00008236 <.Loc.36.2>:
  dmareq.size = (n-2);
    8236:	2c 41       	mov	@r1,	r12	;
    8238:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    823c:	82 4c 80 51 	mov	r12,	&0x5180	;

00008240 <.Loc.37.2>:
  chSysLock();
    8240:	b0 12 0e 82 	call	#33294		;#0x820e
    8244:	b0 12 44 64 	call	#25668		;#0x6444

00008248 <.Loc.38.2>:
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    8248:	3e 43       	mov	#-1,	r14	;r3 As==11
    824a:	3d 40 7c 51 	mov	#20860,	r13	;#0x517c
    824e:	4c 43       	clr.b	r12		;
    8250:	b0 12 fe 7d 	call	#32254		;#0x7dfe
    8254:	0c 93       	cmp	#0,	r12	;r3 As==00
    8256:	12 34       	jge	$+38     	;abs 0x827c

00008258 <.LBB2>:
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    8258:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    825c:	09 3c       	jmp	$+20     	;abs 0x8270

0000825e <.L6>:
      CRCDIRB_L = message[i];
    825e:	1c 41 02 00 	mov	2(r1),	r12	;
    8262:	1c 51 04 00 	add	4(r1),	r12	;
    8266:	6c 4c       	mov.b	@r12,	r12	;
    8268:	c2 4c 52 01 	mov.b	r12,	&0x0152	;

0000826c <.Loc.41.2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    826c:	91 53 04 00 	inc	4(r1)		;

00008270 <.L5>:
    8270:	2c 41       	mov	@r1,	r12	;
    8272:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    8276:	81 9c 04 00 	cmp	r12,	4(r1)	;
    827a:	f1 2b       	jnc	$-28     	;abs 0x825e

0000827c <.L4>:
      CRCDIRB_L = message[i];
    }
#if ELYSIUM_CRC_DMA
  }
  chSysUnlock();
    827c:	b0 12 64 64 	call	#25700		;#0x6464
    8280:	b0 12 16 82 	call	#33302		;#0x8216

00008284 <.Loc.52.2>:
#endif
  
   
  /* Write result to final 2 bytes */
  /* MSB comes first because of how things are transmitted */
  *(message+n-2) = (CRCINIRES_H);
    8284:	2c 41       	mov	@r1,	r12	;
    8286:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    828a:	1c 51 02 00 	add	2(r1),	r12	;
    828e:	5d 42 55 01 	mov.b	&0x0155,r13	;0x0155
    8292:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00008296 <.Loc.53.2>:
  *(message+n-1) = (CRCINIRES_L);
    8296:	2c 41       	mov	@r1,	r12	;
    8298:	3c 53       	add	#-1,	r12	;r3 As==11
    829a:	1c 51 02 00 	add	2(r1),	r12	;
    829e:	5d 42 54 01 	mov.b	&0x0154,r13	;0x0154
    82a2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000082a6 <.Loc.54.2>:
}
    82a6:	03 43       	nop			
    82a8:	31 50 06 00 	add	#6,	r1	;
    82ac:	30 41       	ret			

000082ae <crcCheckSDLP>:
 * 
 * @param[in] message   pointer to the message buffer
 * @param[in] n         size of the message including the CRC field
 * @return  @p true if the signature is valid, @p false if not
 */
bool crcCheckSDLP(uint8_t * message, size_t n) {
    82ae:	31 80 06 00 	Address 0x00000000000082b0 is out of bounds.
sub	#65535,	r1	;#0xffff

000082b0 <L0>:
    82b0:	06 00       	mova	@r0,	r6	;

000082b2 <.LCFI1>:
    82b2:	81 4c 02 00 	mov	r12,	2(r1)	;
    82b6:	81 4d 00 00 	mov	r13,	0(r1)	;

000082ba <.Loc.65.2>:
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    82ba:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

000082be <.Loc.69.2>:

#if ELYSIUM_CRC_DMA
  /* Use DMA engine to write byte-wise to CRCDI register */
  dmareq.source_addr = (void*)message;
    82be:	92 41 02 00 	mov	2(r1),	&0x517c	;
    82c2:	7c 51 

000082c4 <.Loc.70.2>:
  dmareq.size = n-2;
    82c4:	2c 41       	mov	@r1,	r12	;
    82c6:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    82ca:	82 4c 80 51 	mov	r12,	&0x5180	;

000082ce <.Loc.71.2>:
  chSysLock();
    82ce:	b0 12 0e 82 	call	#33294		;#0x820e
    82d2:	b0 12 44 64 	call	#25668		;#0x6444

000082d6 <.Loc.72.2>:
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    82d6:	3e 43       	mov	#-1,	r14	;r3 As==11
    82d8:	3d 40 7c 51 	mov	#20860,	r13	;#0x517c
    82dc:	4c 43       	clr.b	r12		;
    82de:	b0 12 fe 7d 	call	#32254		;#0x7dfe
    82e2:	0c 93       	cmp	#0,	r12	;r3 As==00
    82e4:	12 34       	jge	$+38     	;abs 0x830a

000082e6 <.LBB3>:
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    82e6:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    82ea:	09 3c       	jmp	$+20     	;abs 0x82fe

000082ec <.L10>:
      CRCDIRB_L = message[i];
    82ec:	1c 41 02 00 	mov	2(r1),	r12	;
    82f0:	1c 51 04 00 	add	4(r1),	r12	;
    82f4:	6c 4c       	mov.b	@r12,	r12	;
    82f6:	c2 4c 52 01 	mov.b	r12,	&0x0152	;

000082fa <.Loc.75.2>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    82fa:	91 53 04 00 	inc	4(r1)		;

000082fe <.L9>:
    82fe:	2c 41       	mov	@r1,	r12	;
    8300:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    8304:	81 9c 04 00 	cmp	r12,	4(r1)	;
    8308:	f1 2b       	jnc	$-28     	;abs 0x82ec

0000830a <.L8>:
      CRCDIRB_L = message[i];
    }
#if ELYSIUM_CRC_DMA
  }
  chSysUnlock();
    830a:	b0 12 64 64 	call	#25700		;#0x6464
    830e:	b0 12 16 82 	call	#33302		;#0x8216

00008312 <.Loc.85.2>:
#endif
  
   
  /* Final result should equal the saved checksum */
  return ((CRCINIRES_H == message[n-2]) && (CRCINIRES_L == message[n-1])) ;
    8312:	2c 41       	mov	@r1,	r12	;
    8314:	3c 50 fe ff 	add	#65534,	r12	;#0xfffe
    8318:	1c 51 02 00 	add	2(r1),	r12	;
    831c:	6d 4c       	mov.b	@r12,	r13	;
    831e:	5c 42 55 01 	mov.b	&0x0155,r12	;0x0155
    8322:	4d 9c       	cmp.b	r12,	r13	;
    8324:	0b 20       	jnz	$+24     	;abs 0x833c

00008326 <.Loc.85.2>:
    8326:	2c 41       	mov	@r1,	r12	;
    8328:	3c 53       	add	#-1,	r12	;r3 As==11
    832a:	1c 51 02 00 	add	2(r1),	r12	;
    832e:	6d 4c       	mov.b	@r12,	r13	;
    8330:	5c 42 54 01 	mov.b	&0x0154,r12	;0x0154
    8334:	4d 9c       	cmp.b	r12,	r13	;
    8336:	02 20       	jnz	$+6      	;abs 0x833c

00008338 <.Loc.85.2>:
    8338:	5c 43       	mov.b	#1,	r12	;r3 As==01
    833a:	01 3c       	jmp	$+4      	;abs 0x833e

0000833c <.L11>:
    833c:	4c 43       	clr.b	r12		;

0000833e <.L12>:
    833e:	5c f3       	and.b	#1,	r12	;r3 As==01
    8340:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008344 <.Loc.86.2>:
}
    8344:	31 50 06 00 	add	#6,	r1	;
    8348:	30 41       	ret			

0000834a <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    834a:	ff 3f       	jmp	$+0      	;abs 0x834a

0000834c <Vector2>:
    834c:	ff 3f       	jmp	$+0      	;abs 0x834c

0000834e <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    834e:	ff 3f       	jmp	$+0      	;abs 0x834e

00008350 <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    8350:	ff 3f       	jmp	$+0      	;abs 0x8350

00008352 <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    8352:	ff 3f       	jmp	$+0      	;abs 0x8352

00008354 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    8354:	ff 3f       	jmp	$+0      	;abs 0x8354

00008356 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    8356:	ff 3f       	jmp	$+0      	;abs 0x8356

00008358 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    8358:	ff 3f       	jmp	$+0      	;abs 0x8358

0000835a <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    835a:	ff 3f       	jmp	$+0      	;abs 0x835a

0000835c <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    835c:	ff 3f       	jmp	$+0      	;abs 0x835c

0000835e <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    835e:	ff 3f       	jmp	$+0      	;abs 0x835e

00008360 <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    8360:	ff 3f       	jmp	$+0      	;abs 0x8360

00008362 <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    8362:	ff 3f       	jmp	$+0      	;abs 0x8362

00008364 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    8364:	ff 3f       	jmp	$+0      	;abs 0x8364

00008366 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    8366:	ff 3f       	jmp	$+0      	;abs 0x8366

00008368 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    8368:	ff 3f       	jmp	$+0      	;abs 0x8368

0000836a <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    836a:	ff 3f       	jmp	$+0      	;abs 0x836a

0000836c <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    836c:	ff 3f       	jmp	$+0      	;abs 0x836c

0000836e <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    836e:	ff 3f       	jmp	$+0      	;abs 0x836e

00008370 <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    8370:	ff 3f       	jmp	$+0      	;abs 0x8370

00008372 <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    8372:	ff 3f       	jmp	$+0      	;abs 0x8372

00008374 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    8374:	ff 3f       	jmp	$+0      	;abs 0x8374

00008376 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    8376:	ff 3f       	jmp	$+0      	;abs 0x8376

00008378 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    8378:	ff 3f       	jmp	$+0      	;abs 0x8378

0000837a <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    837a:	ff 3f       	jmp	$+0      	;abs 0x837a

0000837c <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    837c:	ff 3f       	jmp	$+0      	;abs 0x837c

0000837e <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    837e:	ff 3f       	jmp	$+0      	;abs 0x837e

00008380 <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    8380:	ff 3f       	jmp	$+0      	;abs 0x8380

00008382 <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    8382:	ff 3f       	jmp	$+0      	;abs 0x8382

00008384 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    8384:	ff 3f       	jmp	$+0      	;abs 0x8384

00008386 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    8386:	ff 3f       	jmp	$+0      	;abs 0x8386

00008388 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    8388:	ff 3f       	jmp	$+0      	;abs 0x8388

0000838a <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    838a:	ff 3f       	jmp	$+0      	;abs 0x838a

0000838c <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    838c:	ff 3f       	jmp	$+0      	;abs 0x838c

0000838e <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    838e:	ff 3f       	jmp	$+0      	;abs 0x838e

00008390 <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    8390:	ff 3f       	jmp	$+0      	;abs 0x8390

00008392 <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    8392:	ff 3f       	jmp	$+0      	;abs 0x8392

00008394 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    8394:	ff 3f       	jmp	$+0      	;abs 0x8394

00008396 <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    8396:	ff 3f       	jmp	$+0      	;abs 0x8396

00008398 <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    8398:	ff 3f       	jmp	$+0      	;abs 0x8398

0000839a <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    839a:	ff 3f       	jmp	$+0      	;abs 0x839a

0000839c <Vector47>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    839c:	ff 3f       	jmp	$+0      	;abs 0x839c

0000839e <Vector50>:
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {

  while (1) {
    839e:	ff 3f       	jmp	$+0      	;abs 0x839e

000083a0 <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    83a0:	ff 3f       	jmp	$+0      	;abs 0x83a0

000083a2 <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    83a2:	ff 3f       	jmp	$+0      	;abs 0x83a2

000083a4 <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    83a4:	ff 3f       	jmp	$+0      	;abs 0x83a4

000083a6 <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    83a6:	ff 3f       	jmp	$+0      	;abs 0x83a6

000083a8 <Thread1>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    83a8:	1a 15       	pushm	#2,	r10	;16-bit words

000083aa <L0>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread1, 4096);
THD_FUNCTION(Thread1, arg) {
    83aa:	21 83       	decd	r1		;

000083ac <.LCFI1>:
    83ac:	81 4c 00 00 	mov	r12,	0(r1)	;

000083b0 <.Loc.52.1>:
  (void)arg;
  
  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    83b0:	4d 43       	clr.b	r13		;
    83b2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    83b6:	b0 12 74 72 	call	#29300		;#0x7274

000083ba <.Loc.54.1>:

  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    83ba:	30 40 9c 9e 	br	#0x9e9c		;

000083be <.L128>:
    chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));
    83be:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    83c2:	2a 4c       	mov	@r12,	r10	;
    83c4:	19 42 8e 51 	mov	&0x518e,r9	;0x518e
    83c8:	1c 42 8e 51 	mov	&0x518e,r12	;0x518e
    83cc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    83d0:	0e 4c       	mov	r12,	r14	;
    83d2:	0d 49       	mov	r9,	r13	;
    83d4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    83d8:	8a 12       	call	r10		;

000083da <.Loc.58.1>:
    
    /* Test 1 - X25 Check */
    chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));
    83da:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    83de:	2a 4c       	mov	@r12,	r10	;
    83e0:	19 42 90 51 	mov	&0x5190,r9	;0x5190
    83e4:	1c 42 90 51 	mov	&0x5190,r12	;0x5190
    83e8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    83ec:	0e 4c       	mov	r12,	r14	;
    83ee:	0d 49       	mov	r9,	r13	;
    83f0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    83f4:	8a 12       	call	r10		;

000083f6 <.Loc.59.1>:
    chThdSleepMilliseconds(2000);
    83f6:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    83fa:	b0 12 de 67 	call	#26590		;#0x67de

000083fe <.Loc.61.1>:
    /* Forwards */
    buf[0] = '1';
    83fe:	f2 40 31 00 	mov.b	#49,	&0x5292	;#0x0031
    8402:	92 52 

00008404 <.Loc.62.1>:
    buf[1] = '2';
    8404:	f2 40 32 00 	mov.b	#50,	&0x5293	;#0x0032
    8408:	93 52 

0000840a <.Loc.63.1>:
    buf[2] = '3';
    840a:	f2 40 33 00 	mov.b	#51,	&0x5294	;#0x0033
    840e:	94 52 

00008410 <.Loc.64.1>:
    buf[3] = '4';
    8410:	f2 40 34 00 	mov.b	#52,	&0x5295	;#0x0034
    8414:	95 52 

00008416 <.Loc.65.1>:
    buf[4] = '5';
    8416:	f2 40 35 00 	mov.b	#53,	&0x5296	;#0x0035
    841a:	96 52 

0000841c <.Loc.66.1>:
    buf[5] = '6';
    841c:	f2 40 36 00 	mov.b	#54,	&0x5297	;#0x0036
    8420:	97 52 

00008422 <.Loc.67.1>:
    buf[6] = '7';
    8422:	f2 40 37 00 	mov.b	#55,	&0x5298	;#0x0037
    8426:	98 52 

00008428 <.Loc.68.1>:
    buf[7] = '8';
    8428:	f2 40 38 00 	mov.b	#56,	&0x5299	;#0x0038
    842c:	99 52 

0000842e <.Loc.69.1>:
    buf[8] = '9';
    842e:	f2 40 39 00 	mov.b	#57,	&0x529a	;#0x0039
    8432:	9a 52 

00008434 <.Loc.70.1>:
    crcGenX25(buf, 11);
    8434:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    8438:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    843c:	b0 12 d8 80 	call	#32984		;#0x80d8

00008440 <.Loc.71.1>:
    if ((buf[9] != 0x90) ||
    8440:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b
    8444:	7c 90 90 ff 	cmp.b	#65424,	r12	;#0xff90
    8448:	05 20       	jnz	$+12     	;abs 0x8454

0000844a <.Loc.72.1>:
        (buf[10] != 0x6E)) {
    844a:	5c 42 9c 52 	mov.b	&0x529c,r12	;0x529c

0000844e <.Loc.71.1>:
    buf[5] = '6';
    buf[6] = '7';
    buf[7] = '8';
    buf[8] = '9';
    crcGenX25(buf, 11);
    if ((buf[9] != 0x90) ||
    844e:	7c 90 6e 00 	cmp.b	#110,	r12	;#0x006e
    8452:	0f 24       	jz	$+32     	;abs 0x8472

00008454 <.L4>:
        (buf[10] != 0x6E)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8454:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8458:	2a 4c       	mov	@r12,	r10	;
    845a:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    845e:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8462:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8466:	0e 4c       	mov	r12,	r14	;
    8468:	0d 49       	mov	r9,	r13	;
    846a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    846e:	8a 12       	call	r10		;
    8470:	0e 3c       	jmp	$+30     	;abs 0x848e

00008472 <.L5>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8472:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8476:	2a 4c       	mov	@r12,	r10	;
    8478:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    847c:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8480:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8484:	0e 4c       	mov	r12,	r14	;
    8486:	0d 49       	mov	r9,	r13	;
    8488:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    848c:	8a 12       	call	r10		;

0000848e <.L6>:
    }
    /* Backwards */
    buf[0] = '1';
    848e:	f2 40 31 00 	mov.b	#49,	&0x5292	;#0x0031
    8492:	92 52 

00008494 <.Loc.80.1>:
    buf[1] = '2';
    8494:	f2 40 32 00 	mov.b	#50,	&0x5293	;#0x0032
    8498:	93 52 

0000849a <.Loc.81.1>:
    buf[2] = '3';
    849a:	f2 40 33 00 	mov.b	#51,	&0x5294	;#0x0033
    849e:	94 52 

000084a0 <.Loc.82.1>:
    buf[3] = '4';
    84a0:	f2 40 34 00 	mov.b	#52,	&0x5295	;#0x0034
    84a4:	95 52 

000084a6 <.Loc.83.1>:
    buf[4] = '5';
    84a6:	f2 40 35 00 	mov.b	#53,	&0x5296	;#0x0035
    84aa:	96 52 

000084ac <.Loc.84.1>:
    buf[5] = '6';
    84ac:	f2 40 36 00 	mov.b	#54,	&0x5297	;#0x0036
    84b0:	97 52 

000084b2 <.Loc.85.1>:
    buf[6] = '7';
    84b2:	f2 40 37 00 	mov.b	#55,	&0x5298	;#0x0037
    84b6:	98 52 

000084b8 <.Loc.86.1>:
    buf[7] = '8';
    84b8:	f2 40 38 00 	mov.b	#56,	&0x5299	;#0x0038
    84bc:	99 52 

000084be <.Loc.87.1>:
    buf[8] = '9';
    84be:	f2 40 39 00 	mov.b	#57,	&0x529a	;#0x0039
    84c2:	9a 52 

000084c4 <.Loc.88.1>:
    buf[9] = 0x90;
    84c4:	f2 40 90 ff 	mov.b	#65424,	&0x529b	;#0xff90
    84c8:	9b 52 

000084ca <.Loc.89.1>:
    buf[10] = 0x6E;
    84ca:	f2 40 6e 00 	mov.b	#110,	&0x529c	;#0x006e
    84ce:	9c 52 

000084d0 <.Loc.90.1>:
    if (!crcCheckX25(buf, 11)) {
    84d0:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    84d4:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    84d8:	b0 12 72 81 	call	#33138		;#0x8172
    84dc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84e0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    84e2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84e6:	0c 93       	cmp	#0,	r12	;r3 As==00
    84e8:	0f 24       	jz	$+32     	;abs 0x8508

000084ea <.Loc.91.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    84ea:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    84ee:	2a 4c       	mov	@r12,	r10	;
    84f0:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    84f4:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    84f8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    84fc:	0e 4c       	mov	r12,	r14	;
    84fe:	0d 49       	mov	r9,	r13	;
    8500:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8504:	8a 12       	call	r10		;
    8506:	0e 3c       	jmp	$+30     	;abs 0x8524

00008508 <.L7>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8508:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    850c:	2a 4c       	mov	@r12,	r10	;
    850e:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8512:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8516:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    851a:	0e 4c       	mov	r12,	r14	;
    851c:	0d 49       	mov	r9,	r13	;
    851e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8522:	8a 12       	call	r10		;

00008524 <.L8>:
    }
    
    /* Test 2 - X25 Examples */
    chThdSleepMilliseconds(2000);
    8524:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    8528:	b0 12 de 67 	call	#26590		;#0x67de

0000852c <.Loc.99.1>:
    chnWrite(&SD0, (const uint8_t *)test_2_msg, strlen(test_2_msg));
    852c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8530:	2a 4c       	mov	@r12,	r10	;
    8532:	19 42 92 51 	mov	&0x5192,r9	;0x5192
    8536:	1c 42 92 51 	mov	&0x5192,r12	;0x5192
    853a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    853e:	0e 4c       	mov	r12,	r14	;
    8540:	0d 49       	mov	r9,	r13	;
    8542:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8546:	8a 12       	call	r10		;

00008548 <.Loc.101.1>:
    /* Forwards */
    buf[0] = 0x03;
    8548:	f2 40 03 00 	mov.b	#3,	&0x5292	;
    854c:	92 52 

0000854e <.Loc.102.1>:
    buf[1] = 0x3F;
    854e:	f2 40 3f 00 	mov.b	#63,	&0x5293	;#0x003f
    8552:	93 52 

00008554 <.Loc.103.1>:
    crcGenX25(buf, 4);
    8554:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8556:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    855a:	b0 12 d8 80 	call	#32984		;#0x80d8

0000855e <.Loc.104.1>:
    if ((buf[3] != 0x5B) ||
    855e:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295
    8562:	7c 90 5b 00 	cmp.b	#91,	r12	;#0x005b
    8566:	05 20       	jnz	$+12     	;abs 0x8572

00008568 <.Loc.105.1>:
        (buf[2] != 0xEC)) {
    8568:	5c 42 94 52 	mov.b	&0x5294,r12	;0x5294

0000856c <.Loc.104.1>:
    chnWrite(&SD0, (const uint8_t *)test_2_msg, strlen(test_2_msg));
    /* Forwards */
    buf[0] = 0x03;
    buf[1] = 0x3F;
    crcGenX25(buf, 4);
    if ((buf[3] != 0x5B) ||
    856c:	7c 90 ec ff 	cmp.b	#65516,	r12	;#0xffec
    8570:	0f 24       	jz	$+32     	;abs 0x8590

00008572 <.L9>:
        (buf[2] != 0xEC)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8572:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8576:	2a 4c       	mov	@r12,	r10	;
    8578:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    857c:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8580:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8584:	0e 4c       	mov	r12,	r14	;
    8586:	0d 49       	mov	r9,	r13	;
    8588:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    858c:	8a 12       	call	r10		;
    858e:	0e 3c       	jmp	$+30     	;abs 0x85ac

00008590 <.L10>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8590:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8594:	2a 4c       	mov	@r12,	r10	;
    8596:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    859a:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    859e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    85a2:	0e 4c       	mov	r12,	r14	;
    85a4:	0d 49       	mov	r9,	r13	;
    85a6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    85aa:	8a 12       	call	r10		;

000085ac <.L11>:
    }
    buf[0] = 0x01;
    85ac:	d2 43 92 52 	mov.b	#1,	&0x5292	;r3 As==01

000085b0 <.Loc.112.1>:
    buf[1] = 0x73;
    85b0:	f2 40 73 00 	mov.b	#115,	&0x5293	;#0x0073
    85b4:	93 52 

000085b6 <.Loc.113.1>:
    crcGenX25(buf, 4);
    85b6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    85b8:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    85bc:	b0 12 d8 80 	call	#32984		;#0x80d8

000085c0 <.Loc.114.1>:
    if ((buf[3] != 0x83) ||
    85c0:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295
    85c4:	7c 90 83 ff 	cmp.b	#65411,	r12	;#0xff83
    85c8:	05 20       	jnz	$+12     	;abs 0x85d4

000085ca <.Loc.115.1>:
        (buf[2] != 0x57)) {
    85ca:	5c 42 94 52 	mov.b	&0x5294,r12	;0x5294

000085ce <.Loc.114.1>:
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    }
    buf[0] = 0x01;
    buf[1] = 0x73;
    crcGenX25(buf, 4);
    if ((buf[3] != 0x83) ||
    85ce:	7c 90 57 00 	cmp.b	#87,	r12	;#0x0057
    85d2:	0f 24       	jz	$+32     	;abs 0x85f2

000085d4 <.L12>:
        (buf[2] != 0x57)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    85d4:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    85d8:	2a 4c       	mov	@r12,	r10	;
    85da:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    85de:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    85e2:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    85e6:	0e 4c       	mov	r12,	r14	;
    85e8:	0d 49       	mov	r9,	r13	;
    85ea:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    85ee:	8a 12       	call	r10		;
    85f0:	0e 3c       	jmp	$+30     	;abs 0x860e

000085f2 <.L13>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    85f2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    85f6:	2a 4c       	mov	@r12,	r10	;
    85f8:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    85fc:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8600:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8604:	0e 4c       	mov	r12,	r14	;
    8606:	0d 49       	mov	r9,	r13	;
    8608:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    860c:	8a 12       	call	r10		;

0000860e <.L14>:
    }
    buf[0] = 0x01;
    860e:	d2 43 92 52 	mov.b	#1,	&0x5292	;r3 As==01

00008612 <.Loc.122.1>:
    buf[1] = 0x3F;
    8612:	f2 40 3f 00 	mov.b	#63,	&0x5293	;#0x003f
    8616:	93 52 

00008618 <.Loc.123.1>:
    crcGenX25(buf, 4);
    8618:	6d 42       	mov.b	#4,	r13	;r2 As==10
    861a:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    861e:	b0 12 d8 80 	call	#32984		;#0x80d8

00008622 <.Loc.124.1>:
    if ((buf[3] != 0xEB) ||
    8622:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295
    8626:	7c 90 eb ff 	cmp.b	#65515,	r12	;#0xffeb
    862a:	05 20       	jnz	$+12     	;abs 0x8636

0000862c <.Loc.125.1>:
        (buf[2] != 0xDF)) {
    862c:	5c 42 94 52 	mov.b	&0x5294,r12	;0x5294

00008630 <.Loc.124.1>:
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    }
    buf[0] = 0x01;
    buf[1] = 0x3F;
    crcGenX25(buf, 4);
    if ((buf[3] != 0xEB) ||
    8630:	7c 90 df ff 	cmp.b	#65503,	r12	;#0xffdf
    8634:	0f 24       	jz	$+32     	;abs 0x8654

00008636 <.L15>:
        (buf[2] != 0xDF)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8636:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    863a:	2a 4c       	mov	@r12,	r10	;
    863c:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8640:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8644:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8648:	0e 4c       	mov	r12,	r14	;
    864a:	0d 49       	mov	r9,	r13	;
    864c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8650:	8a 12       	call	r10		;
    8652:	0e 3c       	jmp	$+30     	;abs 0x8670

00008654 <.L16>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8654:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8658:	2a 4c       	mov	@r12,	r10	;
    865a:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    865e:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8662:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8666:	0e 4c       	mov	r12,	r14	;
    8668:	0d 49       	mov	r9,	r13	;
    866a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    866e:	8a 12       	call	r10		;

00008670 <.L17>:
    }
    buf[0] = 0x03;
    8670:	f2 40 03 00 	mov.b	#3,	&0x5292	;
    8674:	92 52 

00008676 <.Loc.132.1>:
    buf[1] = 0x73;
    8676:	f2 40 73 00 	mov.b	#115,	&0x5293	;#0x0073
    867a:	93 52 

0000867c <.Loc.133.1>:
    crcGenX25(buf, 4);
    867c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    867e:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8682:	b0 12 d8 80 	call	#32984		;#0x80d8

00008686 <.Loc.134.1>:
    if ((buf[3] != 0x33) ||
    8686:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295
    868a:	7c 90 33 00 	cmp.b	#51,	r12	;#0x0033
    868e:	05 20       	jnz	$+12     	;abs 0x869a

00008690 <.Loc.135.1>:
        (buf[2] != 0x64)) {
    8690:	5c 42 94 52 	mov.b	&0x5294,r12	;0x5294

00008694 <.Loc.134.1>:
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    }
    buf[0] = 0x03;
    buf[1] = 0x73;
    crcGenX25(buf, 4);
    if ((buf[3] != 0x33) ||
    8694:	7c 90 64 00 	cmp.b	#100,	r12	;#0x0064
    8698:	0f 24       	jz	$+32     	;abs 0x86b8

0000869a <.L18>:
        (buf[2] != 0x64)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    869a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    869e:	2a 4c       	mov	@r12,	r10	;
    86a0:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    86a4:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    86a8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    86ac:	0e 4c       	mov	r12,	r14	;
    86ae:	0d 49       	mov	r9,	r13	;
    86b0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    86b4:	8a 12       	call	r10		;
    86b6:	0e 3c       	jmp	$+30     	;abs 0x86d4

000086b8 <.L19>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    86b8:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    86bc:	2a 4c       	mov	@r12,	r10	;
    86be:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    86c2:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    86c6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    86ca:	0e 4c       	mov	r12,	r14	;
    86cc:	0d 49       	mov	r9,	r13	;
    86ce:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    86d2:	8a 12       	call	r10		;

000086d4 <.L20>:
    }
    buf[0] = 0x00;
    86d4:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

000086d8 <.Loc.142.1>:
    buf[1] = 0x00;
    86d8:	c2 43 93 52 	mov.b	#0,	&0x5293	;r3 As==00

000086dc <.Loc.143.1>:
    buf[2] = 0x00;
    86dc:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000086e0 <.Loc.144.1>:
    crcGenX25(buf, 5);
    86e0:	7d 40 05 00 	mov.b	#5,	r13	;
    86e4:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    86e8:	b0 12 d8 80 	call	#32984		;#0x80d8

000086ec <.Loc.145.1>:
    if ((buf[4] != 0xCC) ||
    86ec:	5c 42 96 52 	mov.b	&0x5296,r12	;0x5296
    86f0:	7c 90 cc ff 	cmp.b	#65484,	r12	;#0xffcc
    86f4:	05 20       	jnz	$+12     	;abs 0x8700

000086f6 <.Loc.146.1>:
        (buf[3] != 0xC6)) {
    86f6:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295

000086fa <.Loc.145.1>:
    }
    buf[0] = 0x00;
    buf[1] = 0x00;
    buf[2] = 0x00;
    crcGenX25(buf, 5);
    if ((buf[4] != 0xCC) ||
    86fa:	7c 90 c6 ff 	cmp.b	#65478,	r12	;#0xffc6
    86fe:	0f 24       	jz	$+32     	;abs 0x871e

00008700 <.L21>:
        (buf[3] != 0xC6)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8700:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8704:	2a 4c       	mov	@r12,	r10	;
    8706:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    870a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    870e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8712:	0e 4c       	mov	r12,	r14	;
    8714:	0d 49       	mov	r9,	r13	;
    8716:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    871a:	8a 12       	call	r10		;
    871c:	0e 3c       	jmp	$+30     	;abs 0x873a

0000871e <.L22>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    871e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8722:	2a 4c       	mov	@r12,	r10	;
    8724:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8728:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    872c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8730:	0e 4c       	mov	r12,	r14	;
    8732:	0d 49       	mov	r9,	r13	;
    8734:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8738:	8a 12       	call	r10		;

0000873a <.L23>:
    }
    buf[0] = 0x0F;
    873a:	f2 40 0f 00 	mov.b	#15,	&0x5292	;#0x000f
    873e:	92 52 

00008740 <.Loc.153.1>:
    buf[1] = 0xAA;
    8740:	f2 40 aa ff 	mov.b	#65450,	&0x5293	;#0xffaa
    8744:	93 52 

00008746 <.Loc.154.1>:
    buf[2] = 0xFF;
    8746:	f2 43 94 52 	mov.b	#-1,	&0x5294	;r3 As==11

0000874a <.Loc.155.1>:
    crcGenX25(buf, 5);
    874a:	7d 40 05 00 	mov.b	#5,	r13	;
    874e:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8752:	b0 12 d8 80 	call	#32984		;#0x80d8

00008756 <.Loc.156.1>:
    if ((buf[4] != 0xFC) ||
    8756:	5c 42 96 52 	mov.b	&0x5296,r12	;0x5296
    875a:	7c 90 fc ff 	cmp.b	#65532,	r12	;#0xfffc
    875e:	05 20       	jnz	$+12     	;abs 0x876a

00008760 <.Loc.157.1>:
        (buf[3] != 0xD1)) {
    8760:	5c 42 95 52 	mov.b	&0x5295,r12	;0x5295

00008764 <.Loc.156.1>:
    }
    buf[0] = 0x0F;
    buf[1] = 0xAA;
    buf[2] = 0xFF;
    crcGenX25(buf, 5);
    if ((buf[4] != 0xFC) ||
    8764:	7c 90 d1 ff 	cmp.b	#65489,	r12	;#0xffd1
    8768:	0f 24       	jz	$+32     	;abs 0x8788

0000876a <.L24>:
        (buf[3] != 0xD1)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    876a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    876e:	2a 4c       	mov	@r12,	r10	;
    8770:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8774:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8778:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    877c:	0e 4c       	mov	r12,	r14	;
    877e:	0d 49       	mov	r9,	r13	;
    8780:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8784:	8a 12       	call	r10		;
    8786:	0e 3c       	jmp	$+30     	;abs 0x87a4

00008788 <.L25>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8788:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    878c:	2a 4c       	mov	@r12,	r10	;
    878e:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8792:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8796:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    879a:	0e 4c       	mov	r12,	r14	;
    879c:	0d 49       	mov	r9,	r13	;
    879e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    87a2:	8a 12       	call	r10		;

000087a4 <.L26>:
    }
    buf[0] = 0x0A;
    87a4:	f2 40 0a 00 	mov.b	#10,	&0x5292	;#0x000a
    87a8:	92 52 

000087aa <.Loc.164.1>:
    buf[1] = 0x12;
    87aa:	f2 40 12 00 	mov.b	#18,	&0x5293	;#0x0012
    87ae:	93 52 

000087b0 <.Loc.165.1>:
    buf[2] = 0x34;
    87b0:	f2 40 34 00 	mov.b	#52,	&0x5294	;#0x0034
    87b4:	94 52 

000087b6 <.Loc.166.1>:
    buf[3] = 0x56;
    87b6:	f2 40 56 00 	mov.b	#86,	&0x5295	;#0x0056
    87ba:	95 52 

000087bc <.Loc.167.1>:
    crcGenX25(buf, 6);
    87bc:	7d 40 06 00 	mov.b	#6,	r13	;
    87c0:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    87c4:	b0 12 d8 80 	call	#32984		;#0x80d8

000087c8 <.Loc.168.1>:
    if ((buf[5] != 0x2C) ||
    87c8:	5c 42 97 52 	mov.b	&0x5297,r12	;0x5297
    87cc:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    87d0:	05 20       	jnz	$+12     	;abs 0x87dc

000087d2 <.Loc.169.1>:
        (buf[4] != 0xF6)) {
    87d2:	5c 42 96 52 	mov.b	&0x5296,r12	;0x5296

000087d6 <.Loc.168.1>:
    buf[0] = 0x0A;
    buf[1] = 0x12;
    buf[2] = 0x34;
    buf[3] = 0x56;
    crcGenX25(buf, 6);
    if ((buf[5] != 0x2C) ||
    87d6:	7c 90 f6 ff 	cmp.b	#65526,	r12	;#0xfff6
    87da:	0f 24       	jz	$+32     	;abs 0x87fa

000087dc <.L27>:
        (buf[4] != 0xF6)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    87dc:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    87e0:	2a 4c       	mov	@r12,	r10	;
    87e2:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    87e6:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    87ea:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    87ee:	0e 4c       	mov	r12,	r14	;
    87f0:	0d 49       	mov	r9,	r13	;
    87f2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    87f6:	8a 12       	call	r10		;
    87f8:	0e 3c       	jmp	$+30     	;abs 0x8816

000087fa <.L28>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    87fa:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    87fe:	2a 4c       	mov	@r12,	r10	;
    8800:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8804:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8808:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    880c:	0e 4c       	mov	r12,	r14	;
    880e:	0d 49       	mov	r9,	r13	;
    8810:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8814:	8a 12       	call	r10		;

00008816 <.L29>:
    }

    /* Backwards */
    buf[0] = 0x03;
    8816:	f2 40 03 00 	mov.b	#3,	&0x5292	;
    881a:	92 52 

0000881c <.Loc.178.1>:
    buf[1] = 0x3F;
    881c:	f2 40 3f 00 	mov.b	#63,	&0x5293	;#0x003f
    8820:	93 52 

00008822 <.Loc.179.1>:
    buf[3] = 0x5B;
    8822:	f2 40 5b 00 	mov.b	#91,	&0x5295	;#0x005b
    8826:	95 52 

00008828 <.Loc.180.1>:
    buf[2] = 0xEC;
    8828:	f2 40 ec ff 	mov.b	#65516,	&0x5294	;#0xffec
    882c:	94 52 

0000882e <.Loc.181.1>:
    if (!crcCheckX25(buf, 4)) {
    882e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8830:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8834:	b0 12 72 81 	call	#33138		;#0x8172
    8838:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    883c:	5c e3       	xor.b	#1,	r12	;r3 As==01
    883e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8842:	0c 93       	cmp	#0,	r12	;r3 As==00
    8844:	0f 24       	jz	$+32     	;abs 0x8864

00008846 <.Loc.182.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8846:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    884a:	2a 4c       	mov	@r12,	r10	;
    884c:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8850:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8854:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8858:	0e 4c       	mov	r12,	r14	;
    885a:	0d 49       	mov	r9,	r13	;
    885c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8860:	8a 12       	call	r10		;
    8862:	0e 3c       	jmp	$+30     	;abs 0x8880

00008864 <.L30>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8864:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8868:	2a 4c       	mov	@r12,	r10	;
    886a:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    886e:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8872:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8876:	0e 4c       	mov	r12,	r14	;
    8878:	0d 49       	mov	r9,	r13	;
    887a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    887e:	8a 12       	call	r10		;

00008880 <.L31>:
    }
    buf[0] = 0x01;
    8880:	d2 43 92 52 	mov.b	#1,	&0x5292	;r3 As==01

00008884 <.Loc.188.1>:
    buf[1] = 0x73;
    8884:	f2 40 73 00 	mov.b	#115,	&0x5293	;#0x0073
    8888:	93 52 

0000888a <.Loc.189.1>:
    buf[3] = 0x83;
    888a:	f2 40 83 ff 	mov.b	#65411,	&0x5295	;#0xff83
    888e:	95 52 

00008890 <.Loc.190.1>:
    buf[2] = 0x57;
    8890:	f2 40 57 00 	mov.b	#87,	&0x5294	;#0x0057
    8894:	94 52 

00008896 <.Loc.191.1>:
    if (!crcCheckX25(buf, 4)) {
    8896:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8898:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    889c:	b0 12 72 81 	call	#33138		;#0x8172
    88a0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    88a4:	5c e3       	xor.b	#1,	r12	;r3 As==01
    88a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    88aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    88ac:	0f 24       	jz	$+32     	;abs 0x88cc

000088ae <.Loc.192.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    88ae:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    88b2:	2a 4c       	mov	@r12,	r10	;
    88b4:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    88b8:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    88bc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    88c0:	0e 4c       	mov	r12,	r14	;
    88c2:	0d 49       	mov	r9,	r13	;
    88c4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    88c8:	8a 12       	call	r10		;
    88ca:	0e 3c       	jmp	$+30     	;abs 0x88e8

000088cc <.L32>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    88cc:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    88d0:	2a 4c       	mov	@r12,	r10	;
    88d2:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    88d6:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    88da:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    88de:	0e 4c       	mov	r12,	r14	;
    88e0:	0d 49       	mov	r9,	r13	;
    88e2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    88e6:	8a 12       	call	r10		;

000088e8 <.L33>:
    }
    buf[0] = 0x01;
    88e8:	d2 43 92 52 	mov.b	#1,	&0x5292	;r3 As==01

000088ec <.Loc.198.1>:
    buf[1] = 0x3F;
    88ec:	f2 40 3f 00 	mov.b	#63,	&0x5293	;#0x003f
    88f0:	93 52 

000088f2 <.Loc.199.1>:
    buf[3] = 0xEB;
    88f2:	f2 40 eb ff 	mov.b	#65515,	&0x5295	;#0xffeb
    88f6:	95 52 

000088f8 <.Loc.200.1>:
    buf[2] = 0xDF;
    88f8:	f2 40 df ff 	mov.b	#65503,	&0x5294	;#0xffdf
    88fc:	94 52 

000088fe <.Loc.201.1>:
    if (!crcCheckX25(buf, 4)) {
    88fe:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8900:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8904:	b0 12 72 81 	call	#33138		;#0x8172
    8908:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    890c:	5c e3       	xor.b	#1,	r12	;r3 As==01
    890e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8912:	0c 93       	cmp	#0,	r12	;r3 As==00
    8914:	0f 24       	jz	$+32     	;abs 0x8934

00008916 <.Loc.202.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8916:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    891a:	2a 4c       	mov	@r12,	r10	;
    891c:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8920:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8924:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8928:	0e 4c       	mov	r12,	r14	;
    892a:	0d 49       	mov	r9,	r13	;
    892c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8930:	8a 12       	call	r10		;
    8932:	0e 3c       	jmp	$+30     	;abs 0x8950

00008934 <.L34>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8934:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8938:	2a 4c       	mov	@r12,	r10	;
    893a:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    893e:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8942:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8946:	0e 4c       	mov	r12,	r14	;
    8948:	0d 49       	mov	r9,	r13	;
    894a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    894e:	8a 12       	call	r10		;

00008950 <.L35>:
    }
    buf[0] = 0x03;
    8950:	f2 40 03 00 	mov.b	#3,	&0x5292	;
    8954:	92 52 

00008956 <.Loc.208.1>:
    buf[1] = 0x73;
    8956:	f2 40 73 00 	mov.b	#115,	&0x5293	;#0x0073
    895a:	93 52 

0000895c <.Loc.209.1>:
    buf[3] = 0x33;
    895c:	f2 40 33 00 	mov.b	#51,	&0x5295	;#0x0033
    8960:	95 52 

00008962 <.Loc.210.1>:
    buf[2] = 0x64;
    8962:	f2 40 64 00 	mov.b	#100,	&0x5294	;#0x0064
    8966:	94 52 

00008968 <.Loc.211.1>:
    if (!crcCheckX25(buf, 4)) {
    8968:	6d 42       	mov.b	#4,	r13	;r2 As==10
    896a:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    896e:	b0 12 72 81 	call	#33138		;#0x8172
    8972:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8976:	5c e3       	xor.b	#1,	r12	;r3 As==01
    8978:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    897c:	0c 93       	cmp	#0,	r12	;r3 As==00
    897e:	0f 24       	jz	$+32     	;abs 0x899e

00008980 <.Loc.212.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8980:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8984:	2a 4c       	mov	@r12,	r10	;
    8986:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    898a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    898e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8992:	0e 4c       	mov	r12,	r14	;
    8994:	0d 49       	mov	r9,	r13	;
    8996:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    899a:	8a 12       	call	r10		;
    899c:	0e 3c       	jmp	$+30     	;abs 0x89ba

0000899e <.L36>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    899e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    89a2:	2a 4c       	mov	@r12,	r10	;
    89a4:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    89a8:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    89ac:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    89b0:	0e 4c       	mov	r12,	r14	;
    89b2:	0d 49       	mov	r9,	r13	;
    89b4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    89b8:	8a 12       	call	r10		;

000089ba <.L37>:
    }
    buf[0] = 0x00;
    89ba:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

000089be <.Loc.218.1>:
    buf[1] = 0x00;
    89be:	c2 43 93 52 	mov.b	#0,	&0x5293	;r3 As==00

000089c2 <.Loc.219.1>:
    buf[2] = 0x00;
    89c2:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000089c6 <.Loc.220.1>:
    buf[4] = 0xCC;
    89c6:	f2 40 cc ff 	mov.b	#65484,	&0x5296	;#0xffcc
    89ca:	96 52 

000089cc <.Loc.221.1>:
    buf[3] = 0xC6;
    89cc:	f2 40 c6 ff 	mov.b	#65478,	&0x5295	;#0xffc6
    89d0:	95 52 

000089d2 <.Loc.222.1>:
    if (!crcCheckX25(buf, 5)) {
    89d2:	7d 40 05 00 	mov.b	#5,	r13	;
    89d6:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    89da:	b0 12 72 81 	call	#33138		;#0x8172
    89de:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    89e2:	5c e3       	xor.b	#1,	r12	;r3 As==01
    89e4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    89e8:	0c 93       	cmp	#0,	r12	;r3 As==00
    89ea:	0f 24       	jz	$+32     	;abs 0x8a0a

000089ec <.Loc.223.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    89ec:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    89f0:	2a 4c       	mov	@r12,	r10	;
    89f2:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    89f6:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    89fa:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    89fe:	0e 4c       	mov	r12,	r14	;
    8a00:	0d 49       	mov	r9,	r13	;
    8a02:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8a06:	8a 12       	call	r10		;
    8a08:	0e 3c       	jmp	$+30     	;abs 0x8a26

00008a0a <.L38>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8a0a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8a0e:	2a 4c       	mov	@r12,	r10	;
    8a10:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8a14:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8a18:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8a1c:	0e 4c       	mov	r12,	r14	;
    8a1e:	0d 49       	mov	r9,	r13	;
    8a20:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8a24:	8a 12       	call	r10		;

00008a26 <.L39>:
    }
    buf[0] = 0x0F;
    8a26:	f2 40 0f 00 	mov.b	#15,	&0x5292	;#0x000f
    8a2a:	92 52 

00008a2c <.Loc.229.1>:
    buf[1] = 0xAA;
    8a2c:	f2 40 aa ff 	mov.b	#65450,	&0x5293	;#0xffaa
    8a30:	93 52 

00008a32 <.Loc.230.1>:
    buf[2] = 0xFF;
    8a32:	f2 43 94 52 	mov.b	#-1,	&0x5294	;r3 As==11

00008a36 <.Loc.231.1>:
    buf[4] = 0xFC;
    8a36:	f2 40 fc ff 	mov.b	#65532,	&0x5296	;#0xfffc
    8a3a:	96 52 

00008a3c <.Loc.232.1>:
    buf[3] = 0xD1;
    8a3c:	f2 40 d1 ff 	mov.b	#65489,	&0x5295	;#0xffd1
    8a40:	95 52 

00008a42 <.Loc.233.1>:
    if (!crcCheckX25(buf, 5)) {
    8a42:	7d 40 05 00 	mov.b	#5,	r13	;
    8a46:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8a4a:	b0 12 72 81 	call	#33138		;#0x8172
    8a4e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a52:	5c e3       	xor.b	#1,	r12	;r3 As==01
    8a54:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a58:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a5a:	0f 24       	jz	$+32     	;abs 0x8a7a

00008a5c <.Loc.234.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8a5c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8a60:	2a 4c       	mov	@r12,	r10	;
    8a62:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8a66:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8a6a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8a6e:	0e 4c       	mov	r12,	r14	;
    8a70:	0d 49       	mov	r9,	r13	;
    8a72:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8a76:	8a 12       	call	r10		;
    8a78:	0e 3c       	jmp	$+30     	;abs 0x8a96

00008a7a <.L40>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8a7a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8a7e:	2a 4c       	mov	@r12,	r10	;
    8a80:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8a84:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8a88:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8a8c:	0e 4c       	mov	r12,	r14	;
    8a8e:	0d 49       	mov	r9,	r13	;
    8a90:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8a94:	8a 12       	call	r10		;

00008a96 <.L41>:
    }
    buf[0] = 0x0A;
    8a96:	f2 40 0a 00 	mov.b	#10,	&0x5292	;#0x000a
    8a9a:	92 52 

00008a9c <.Loc.240.1>:
    buf[1] = 0x12;
    8a9c:	f2 40 12 00 	mov.b	#18,	&0x5293	;#0x0012
    8aa0:	93 52 

00008aa2 <.Loc.241.1>:
    buf[2] = 0x34;
    8aa2:	f2 40 34 00 	mov.b	#52,	&0x5294	;#0x0034
    8aa6:	94 52 

00008aa8 <.Loc.242.1>:
    buf[3] = 0x56;
    8aa8:	f2 40 56 00 	mov.b	#86,	&0x5295	;#0x0056
    8aac:	95 52 

00008aae <.Loc.243.1>:
    buf[5] = 0x2C;
    8aae:	f2 40 2c 00 	mov.b	#44,	&0x5297	;#0x002c
    8ab2:	97 52 

00008ab4 <.Loc.244.1>:
    buf[4] = 0xF6;
    8ab4:	f2 40 f6 ff 	mov.b	#65526,	&0x5296	;#0xfff6
    8ab8:	96 52 

00008aba <.Loc.245.1>:
    if (!crcCheckX25(buf, 6)) {
    8aba:	7d 40 06 00 	mov.b	#6,	r13	;
    8abe:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8ac2:	b0 12 72 81 	call	#33138		;#0x8172
    8ac6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8aca:	5c e3       	xor.b	#1,	r12	;r3 As==01
    8acc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ad0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ad2:	0f 24       	jz	$+32     	;abs 0x8af2

00008ad4 <.Loc.246.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8ad4:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8ad8:	2a 4c       	mov	@r12,	r10	;
    8ada:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8ade:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8ae2:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8ae6:	0e 4c       	mov	r12,	r14	;
    8ae8:	0d 49       	mov	r9,	r13	;
    8aea:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8aee:	8a 12       	call	r10		;
    8af0:	0e 3c       	jmp	$+30     	;abs 0x8b0e

00008af2 <.L42>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8af2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8af6:	2a 4c       	mov	@r12,	r10	;
    8af8:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8afc:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8b00:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8b04:	0e 4c       	mov	r12,	r14	;
    8b06:	0d 49       	mov	r9,	r13	;
    8b08:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8b0c:	8a 12       	call	r10		;

00008b0e <.L43>:
    }

    /* Test 3 - SDLP Check */
    chThdSleepMilliseconds(2000);
    8b0e:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    8b12:	b0 12 de 67 	call	#26590		;#0x67de

00008b16 <.Loc.254.1>:
    chnWrite(&SD0, (const uint8_t *)test_3_msg, strlen(test_3_msg));
    8b16:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8b1a:	2a 4c       	mov	@r12,	r10	;
    8b1c:	19 42 94 51 	mov	&0x5194,r9	;0x5194
    8b20:	1c 42 94 51 	mov	&0x5194,r12	;0x5194
    8b24:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8b28:	0e 4c       	mov	r12,	r14	;
    8b2a:	0d 49       	mov	r9,	r13	;
    8b2c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8b30:	8a 12       	call	r10		;

00008b32 <.Loc.256.1>:
    /* Forwards */
    buf[0] = '1';
    8b32:	f2 40 31 00 	mov.b	#49,	&0x5292	;#0x0031
    8b36:	92 52 

00008b38 <.Loc.257.1>:
    buf[1] = '2';
    8b38:	f2 40 32 00 	mov.b	#50,	&0x5293	;#0x0032
    8b3c:	93 52 

00008b3e <.Loc.258.1>:
    buf[2] = '3';
    8b3e:	f2 40 33 00 	mov.b	#51,	&0x5294	;#0x0033
    8b42:	94 52 

00008b44 <.Loc.259.1>:
    buf[3] = '4';
    8b44:	f2 40 34 00 	mov.b	#52,	&0x5295	;#0x0034
    8b48:	95 52 

00008b4a <.Loc.260.1>:
    buf[4] = '5';
    8b4a:	f2 40 35 00 	mov.b	#53,	&0x5296	;#0x0035
    8b4e:	96 52 

00008b50 <.Loc.261.1>:
    buf[5] = '6';
    8b50:	f2 40 36 00 	mov.b	#54,	&0x5297	;#0x0036
    8b54:	97 52 

00008b56 <.Loc.262.1>:
    buf[6] = '7';
    8b56:	f2 40 37 00 	mov.b	#55,	&0x5298	;#0x0037
    8b5a:	98 52 

00008b5c <.Loc.263.1>:
    buf[7] = '8';
    8b5c:	f2 40 38 00 	mov.b	#56,	&0x5299	;#0x0038
    8b60:	99 52 

00008b62 <.Loc.264.1>:
    buf[8] = '9';
    8b62:	f2 40 39 00 	mov.b	#57,	&0x529a	;#0x0039
    8b66:	9a 52 

00008b68 <.Loc.265.1>:
    crcGenSDLP(buf, 11);
    8b68:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    8b6c:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8b70:	b0 12 20 82 	call	#33312		;#0x8220

00008b74 <.Loc.266.1>:
    if ((buf[9] != 0x29) ||
    8b74:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b
    8b78:	7c 90 29 00 	cmp.b	#41,	r12	;#0x0029
    8b7c:	05 20       	jnz	$+12     	;abs 0x8b88

00008b7e <.Loc.267.1>:
        (buf[10] != 0xB1)) {
    8b7e:	5c 42 9c 52 	mov.b	&0x529c,r12	;0x529c

00008b82 <.Loc.266.1>:
    buf[5] = '6';
    buf[6] = '7';
    buf[7] = '8';
    buf[8] = '9';
    crcGenSDLP(buf, 11);
    if ((buf[9] != 0x29) ||
    8b82:	7c 90 b1 ff 	cmp.b	#65457,	r12	;#0xffb1
    8b86:	0f 24       	jz	$+32     	;abs 0x8ba6

00008b88 <.L44>:
        (buf[10] != 0xB1)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8b88:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8b8c:	2a 4c       	mov	@r12,	r10	;
    8b8e:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8b92:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8b96:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8b9a:	0e 4c       	mov	r12,	r14	;
    8b9c:	0d 49       	mov	r9,	r13	;
    8b9e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8ba2:	8a 12       	call	r10		;
    8ba4:	0e 3c       	jmp	$+30     	;abs 0x8bc2

00008ba6 <.L45>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8ba6:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8baa:	2a 4c       	mov	@r12,	r10	;
    8bac:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8bb0:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8bb4:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8bb8:	0e 4c       	mov	r12,	r14	;
    8bba:	0d 49       	mov	r9,	r13	;
    8bbc:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8bc0:	8a 12       	call	r10		;

00008bc2 <.L46>:
    }
    /* Backwards */
    buf[0] = '1';
    8bc2:	f2 40 31 00 	mov.b	#49,	&0x5292	;#0x0031
    8bc6:	92 52 

00008bc8 <.Loc.275.1>:
    buf[1] = '2';
    8bc8:	f2 40 32 00 	mov.b	#50,	&0x5293	;#0x0032
    8bcc:	93 52 

00008bce <.Loc.276.1>:
    buf[2] = '3';
    8bce:	f2 40 33 00 	mov.b	#51,	&0x5294	;#0x0033
    8bd2:	94 52 

00008bd4 <.Loc.277.1>:
    buf[3] = '4';
    8bd4:	f2 40 34 00 	mov.b	#52,	&0x5295	;#0x0034
    8bd8:	95 52 

00008bda <.Loc.278.1>:
    buf[4] = '5';
    8bda:	f2 40 35 00 	mov.b	#53,	&0x5296	;#0x0035
    8bde:	96 52 

00008be0 <.Loc.279.1>:
    buf[5] = '6';
    8be0:	f2 40 36 00 	mov.b	#54,	&0x5297	;#0x0036
    8be4:	97 52 

00008be6 <.Loc.280.1>:
    buf[6] = '7';
    8be6:	f2 40 37 00 	mov.b	#55,	&0x5298	;#0x0037
    8bea:	98 52 

00008bec <.Loc.281.1>:
    buf[7] = '8';
    8bec:	f2 40 38 00 	mov.b	#56,	&0x5299	;#0x0038
    8bf0:	99 52 

00008bf2 <.Loc.282.1>:
    buf[8] = '9';
    8bf2:	f2 40 39 00 	mov.b	#57,	&0x529a	;#0x0039
    8bf6:	9a 52 

00008bf8 <.Loc.283.1>:
    buf[9] = 0x29;
    8bf8:	f2 40 29 00 	mov.b	#41,	&0x529b	;#0x0029
    8bfc:	9b 52 

00008bfe <.Loc.284.1>:
    buf[10] = 0xb1;
    8bfe:	f2 40 b1 ff 	mov.b	#65457,	&0x529c	;#0xffb1
    8c02:	9c 52 

00008c04 <.Loc.285.1>:
    if (!crcCheckSDLP(buf, 11)) {
    8c04:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    8c08:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8c0c:	b0 12 ae 82 	call	#33454		;#0x82ae
    8c10:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c14:	5c e3       	xor.b	#1,	r12	;r3 As==01
    8c16:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8c1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c1c:	0f 24       	jz	$+32     	;abs 0x8c3c

00008c1e <.Loc.286.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8c1e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8c22:	2a 4c       	mov	@r12,	r10	;
    8c24:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8c28:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8c2c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8c30:	0e 4c       	mov	r12,	r14	;
    8c32:	0d 49       	mov	r9,	r13	;
    8c34:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8c38:	8a 12       	call	r10		;
    8c3a:	0e 3c       	jmp	$+30     	;abs 0x8c58

00008c3c <.L47>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8c3c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8c40:	2a 4c       	mov	@r12,	r10	;
    8c42:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8c46:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8c4a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8c4e:	0e 4c       	mov	r12,	r14	;
    8c50:	0d 49       	mov	r9,	r13	;
    8c52:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8c56:	8a 12       	call	r10		;

00008c58 <.L48>:
    }
    
    /* Test 4 - SDLP Examples */
    chThdSleepMilliseconds(2000);
    8c58:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    8c5c:	b0 12 de 67 	call	#26590		;#0x67de

00008c60 <.Loc.294.1>:
    chnWrite(&SD0, (const uint8_t *)test_4_msg, strlen(test_4_msg));
    8c60:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8c64:	2a 4c       	mov	@r12,	r10	;
    8c66:	19 42 96 51 	mov	&0x5196,r9	;0x5196
    8c6a:	1c 42 96 51 	mov	&0x5196,r12	;0x5196
    8c6e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8c72:	0e 4c       	mov	r12,	r14	;
    8c74:	0d 49       	mov	r9,	r13	;
    8c76:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8c7a:	8a 12       	call	r10		;

00008c7c <.Loc.296.1>:
    /* Forwards */
    buf[0] = 0x30;
    8c7c:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    8c80:	92 52 

00008c82 <.Loc.297.1>:
    buf[1] = 0x1B;
    8c82:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8c86:	93 52 

00008c88 <.Loc.298.1>:
    buf[2] = 0x00;
    8c88:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008c8c <.Loc.299.1>:
    buf[3] = 0x07;
    8c8c:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    8c90:	95 52 

00008c92 <.Loc.300.1>:
    buf[4] = 0x00;
    8c92:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008c96 <.Loc.301.1>:
    buf[5] = 0x00;
    8c96:	c2 43 97 52 	mov.b	#0,	&0x5297	;r3 As==00

00008c9a <.Loc.302.1>:
    crcGenSDLP(buf, 8);
    8c9a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    8c9c:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8ca0:	b0 12 20 82 	call	#33312		;#0x8220

00008ca4 <.Loc.303.1>:
    if ((buf[6] != 0x4C) ||
    8ca4:	5c 42 98 52 	mov.b	&0x5298,r12	;0x5298
    8ca8:	7c 90 4c 00 	cmp.b	#76,	r12	;#0x004c
    8cac:	05 20       	jnz	$+12     	;abs 0x8cb8

00008cae <.Loc.304.1>:
        (buf[7] != 0xA9)) {
    8cae:	5c 42 99 52 	mov.b	&0x5299,r12	;0x5299

00008cb2 <.Loc.303.1>:
    buf[2] = 0x00;
    buf[3] = 0x07;
    buf[4] = 0x00;
    buf[5] = 0x00;
    crcGenSDLP(buf, 8);
    if ((buf[6] != 0x4C) ||
    8cb2:	7c 90 a9 ff 	cmp.b	#65449,	r12	;#0xffa9
    8cb6:	0f 24       	jz	$+32     	;abs 0x8cd6

00008cb8 <.L49>:
        (buf[7] != 0xA9)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8cb8:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8cbc:	2a 4c       	mov	@r12,	r10	;
    8cbe:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8cc2:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8cc6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8cca:	0e 4c       	mov	r12,	r14	;
    8ccc:	0d 49       	mov	r9,	r13	;
    8cce:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8cd2:	8a 12       	call	r10		;
    8cd4:	0e 3c       	jmp	$+30     	;abs 0x8cf2

00008cd6 <.L50>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8cd6:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8cda:	2a 4c       	mov	@r12,	r10	;
    8cdc:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8ce0:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8ce4:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8ce8:	0e 4c       	mov	r12,	r14	;
    8cea:	0d 49       	mov	r9,	r13	;
    8cec:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8cf0:	8a 12       	call	r10		;

00008cf2 <.L51>:
    }
    buf[0] = 0x30;
    8cf2:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    8cf6:	92 52 

00008cf8 <.Loc.311.1>:
    buf[1] = 0x1B;
    8cf8:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8cfc:	93 52 

00008cfe <.Loc.312.1>:
    buf[2] = 0x00;
    8cfe:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008d02 <.Loc.313.1>:
    buf[3] = 0x09;
    8d02:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    8d06:	95 52 

00008d08 <.Loc.314.1>:
    buf[4] = 0x00;
    8d08:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008d0c <.Loc.315.1>:
    buf[5] = 0x82;
    8d0c:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    8d10:	97 52 

00008d12 <.Loc.316.1>:
    buf[6] = 0x00;
    8d12:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00008d16 <.Loc.317.1>:
    buf[7] = 0x00;
    8d16:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00008d1a <.Loc.318.1>:
    crcGenSDLP(buf, 10);
    8d1a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8d1e:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8d22:	b0 12 20 82 	call	#33312		;#0x8220

00008d26 <.Loc.319.1>:
    if ((buf[8] != 0xF6) ||
    8d26:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a
    8d2a:	7c 90 f6 ff 	cmp.b	#65526,	r12	;#0xfff6
    8d2e:	05 20       	jnz	$+12     	;abs 0x8d3a

00008d30 <.Loc.320.1>:
        (buf[9] != 0xF0)) {
    8d30:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b

00008d34 <.Loc.319.1>:
    buf[4] = 0x00;
    buf[5] = 0x82;
    buf[6] = 0x00;
    buf[7] = 0x00;
    crcGenSDLP(buf, 10);
    if ((buf[8] != 0xF6) ||
    8d34:	7c 90 f0 ff 	cmp.b	#65520,	r12	;#0xfff0
    8d38:	0f 24       	jz	$+32     	;abs 0x8d58

00008d3a <.L52>:
        (buf[9] != 0xF0)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8d3a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8d3e:	2a 4c       	mov	@r12,	r10	;
    8d40:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8d44:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8d48:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8d4c:	0e 4c       	mov	r12,	r14	;
    8d4e:	0d 49       	mov	r9,	r13	;
    8d50:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8d54:	8a 12       	call	r10		;
    8d56:	0e 3c       	jmp	$+30     	;abs 0x8d74

00008d58 <.L53>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8d58:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8d5c:	2a 4c       	mov	@r12,	r10	;
    8d5e:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8d62:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8d66:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8d6a:	0e 4c       	mov	r12,	r14	;
    8d6c:	0d 49       	mov	r9,	r13	;
    8d6e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8d72:	8a 12       	call	r10		;

00008d74 <.L54>:
    }
    buf[0] = 0x30;
    8d74:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    8d78:	92 52 

00008d7a <.Loc.327.1>:
    buf[1] = 0x1B;
    8d7a:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8d7e:	93 52 

00008d80 <.Loc.328.1>:
    buf[2] = 0x00;
    8d80:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008d84 <.Loc.329.1>:
    buf[3] = 0x09;
    8d84:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    8d88:	95 52 

00008d8a <.Loc.330.1>:
    buf[4] = 0x00;
    8d8a:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008d8e <.Loc.331.1>:
    buf[5] = 0x82;
    8d8e:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    8d92:	97 52 

00008d94 <.Loc.332.1>:
    buf[6] = 0x00;
    8d94:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00008d98 <.Loc.333.1>:
    buf[7] = 0x10;
    8d98:	f2 40 10 00 	mov.b	#16,	&0x5299	;#0x0010
    8d9c:	99 52 

00008d9e <.Loc.334.1>:
    crcGenSDLP(buf, 10);
    8d9e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8da2:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8da6:	b0 12 20 82 	call	#33312		;#0x8220

00008daa <.Loc.335.1>:
    if ((buf[8] != 0xE4) ||
    8daa:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a
    8dae:	7c 90 e4 ff 	cmp.b	#65508,	r12	;#0xffe4
    8db2:	05 20       	jnz	$+12     	;abs 0x8dbe

00008db4 <.Loc.336.1>:
        (buf[9] != 0xC1)) {
    8db4:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b

00008db8 <.Loc.335.1>:
    buf[4] = 0x00;
    buf[5] = 0x82;
    buf[6] = 0x00;
    buf[7] = 0x10;
    crcGenSDLP(buf, 10);
    if ((buf[8] != 0xE4) ||
    8db8:	7c 90 c1 ff 	cmp.b	#65473,	r12	;#0xffc1
    8dbc:	0f 24       	jz	$+32     	;abs 0x8ddc

00008dbe <.L55>:
        (buf[9] != 0xC1)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8dbe:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8dc2:	2a 4c       	mov	@r12,	r10	;
    8dc4:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8dc8:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8dcc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8dd0:	0e 4c       	mov	r12,	r14	;
    8dd2:	0d 49       	mov	r9,	r13	;
    8dd4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8dd8:	8a 12       	call	r10		;
    8dda:	0e 3c       	jmp	$+30     	;abs 0x8df8

00008ddc <.L56>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8ddc:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8de0:	2a 4c       	mov	@r12,	r10	;
    8de2:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8de6:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8dea:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8dee:	0e 4c       	mov	r12,	r14	;
    8df0:	0d 49       	mov	r9,	r13	;
    8df2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8df6:	8a 12       	call	r10		;

00008df8 <.L57>:
    }
    buf[0] = 0x30;
    8df8:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    8dfc:	92 52 

00008dfe <.Loc.343.1>:
    buf[1] = 0x1B;
    8dfe:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8e02:	93 52 

00008e04 <.Loc.344.1>:
    buf[2] = 0x04;
    8e04:	e2 42 94 52 	mov.b	#4,	&0x5294	;r2 As==10

00008e08 <.Loc.345.1>:
    buf[3] = 0x09;
    8e08:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    8e0c:	95 52 

00008e0e <.Loc.346.1>:
    buf[4] = 0x00;
    8e0e:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008e12 <.Loc.347.1>:
    buf[5] = 0x82;
    8e12:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    8e16:	97 52 

00008e18 <.Loc.348.1>:
    buf[6] = 0x00;
    8e18:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00008e1c <.Loc.349.1>:
    buf[7] = 0x00;
    8e1c:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00008e20 <.Loc.350.1>:
    crcGenSDLP(buf, 10);
    8e20:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8e24:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8e28:	b0 12 20 82 	call	#33312		;#0x8220

00008e2c <.Loc.351.1>:
    if ((buf[8] != 0xF0) ||
    8e2c:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a
    8e30:	7c 90 f0 ff 	cmp.b	#65520,	r12	;#0xfff0
    8e34:	05 20       	jnz	$+12     	;abs 0x8e40

00008e36 <.Loc.352.1>:
        (buf[9] != 0x51)) {
    8e36:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b

00008e3a <.Loc.351.1>:
    buf[4] = 0x00;
    buf[5] = 0x82;
    buf[6] = 0x00;
    buf[7] = 0x00;
    crcGenSDLP(buf, 10);
    if ((buf[8] != 0xF0) ||
    8e3a:	7c 90 51 00 	cmp.b	#81,	r12	;#0x0051
    8e3e:	0f 24       	jz	$+32     	;abs 0x8e5e

00008e40 <.L58>:
        (buf[9] != 0x51)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8e40:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8e44:	2a 4c       	mov	@r12,	r10	;
    8e46:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8e4a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8e4e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8e52:	0e 4c       	mov	r12,	r14	;
    8e54:	0d 49       	mov	r9,	r13	;
    8e56:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8e5a:	8a 12       	call	r10		;
    8e5c:	0e 3c       	jmp	$+30     	;abs 0x8e7a

00008e5e <.L59>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8e5e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8e62:	2a 4c       	mov	@r12,	r10	;
    8e64:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8e68:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8e6c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8e70:	0e 4c       	mov	r12,	r14	;
    8e72:	0d 49       	mov	r9,	r13	;
    8e74:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8e78:	8a 12       	call	r10		;

00008e7a <.L60>:
    }
    buf[0] = 0x30;
    8e7a:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    8e7e:	92 52 

00008e80 <.Loc.359.1>:
    buf[1] = 0x1B;
    8e80:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8e84:	93 52 

00008e86 <.Loc.360.1>:
    buf[2] = 0x04;
    8e86:	e2 42 94 52 	mov.b	#4,	&0x5294	;r2 As==10

00008e8a <.Loc.361.1>:
    buf[3] = 0x09;
    8e8a:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    8e8e:	95 52 

00008e90 <.Loc.362.1>:
    buf[4] = 0x00;
    8e90:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008e94 <.Loc.363.1>:
    buf[5] = 0x82;
    8e94:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    8e98:	97 52 

00008e9a <.Loc.364.1>:
    buf[6] = 0x00;
    8e9a:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00008e9e <.Loc.365.1>:
    buf[7] = 0x10;
    8e9e:	f2 40 10 00 	mov.b	#16,	&0x5299	;#0x0010
    8ea2:	99 52 

00008ea4 <.Loc.366.1>:
    crcGenSDLP(buf, 10);
    8ea4:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8ea8:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8eac:	b0 12 20 82 	call	#33312		;#0x8220

00008eb0 <.Loc.367.1>:
    if ((buf[8] != 0xE2) ||
    8eb0:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a
    8eb4:	7c 90 e2 ff 	cmp.b	#65506,	r12	;#0xffe2
    8eb8:	05 20       	jnz	$+12     	;abs 0x8ec4

00008eba <.Loc.368.1>:
        (buf[9] != 0x60)) {
    8eba:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b

00008ebe <.Loc.367.1>:
    buf[4] = 0x00;
    buf[5] = 0x82;
    buf[6] = 0x00;
    buf[7] = 0x10;
    crcGenSDLP(buf, 10);
    if ((buf[8] != 0xE2) ||
    8ebe:	7c 90 60 00 	cmp.b	#96,	r12	;#0x0060
    8ec2:	0f 24       	jz	$+32     	;abs 0x8ee2

00008ec4 <.L61>:
        (buf[9] != 0x60)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8ec4:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8ec8:	2a 4c       	mov	@r12,	r10	;
    8eca:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8ece:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8ed2:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8ed6:	0e 4c       	mov	r12,	r14	;
    8ed8:	0d 49       	mov	r9,	r13	;
    8eda:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8ede:	8a 12       	call	r10		;
    8ee0:	0e 3c       	jmp	$+30     	;abs 0x8efe

00008ee2 <.L62>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8ee2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8ee6:	2a 4c       	mov	@r12,	r10	;
    8ee8:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8eec:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8ef0:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8ef4:	0e 4c       	mov	r12,	r14	;
    8ef6:	0d 49       	mov	r9,	r13	;
    8ef8:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8efc:	8a 12       	call	r10		;

00008efe <.L63>:
    }
    buf[0] = 0x00;
    8efe:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00008f02 <.Loc.375.1>:
    buf[1] = 0x1B;
    8f02:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8f06:	93 52 

00008f08 <.Loc.376.1>:
    buf[2] = 0x00;
    8f08:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008f0c <.Loc.377.1>:
    buf[3] = 0x07;
    8f0c:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    8f10:	95 52 

00008f12 <.Loc.378.1>:
    buf[4] = 0xFF;
    8f12:	f2 43 96 52 	mov.b	#-1,	&0x5296	;r3 As==11

00008f16 <.Loc.379.1>:
    buf[5] = 0x01;
    8f16:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00008f1a <.Loc.380.1>:
    crcGenSDLP(buf, 8);
    8f1a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    8f1c:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8f20:	b0 12 20 82 	call	#33312		;#0x8220

00008f24 <.Loc.381.1>:
    if ((buf[6] != 0x70) ||
    8f24:	5c 42 98 52 	mov.b	&0x5298,r12	;0x5298
    8f28:	7c 90 70 00 	cmp.b	#112,	r12	;#0x0070
    8f2c:	05 20       	jnz	$+12     	;abs 0x8f38

00008f2e <.Loc.382.1>:
        (buf[7] != 0xFB)) {
    8f2e:	5c 42 99 52 	mov.b	&0x5299,r12	;0x5299

00008f32 <.Loc.381.1>:
    buf[2] = 0x00;
    buf[3] = 0x07;
    buf[4] = 0xFF;
    buf[5] = 0x01;
    crcGenSDLP(buf, 8);
    if ((buf[6] != 0x70) ||
    8f32:	7c 90 fb ff 	cmp.b	#65531,	r12	;#0xfffb
    8f36:	0f 24       	jz	$+32     	;abs 0x8f56

00008f38 <.L64>:
        (buf[7] != 0xFB)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8f38:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8f3c:	2a 4c       	mov	@r12,	r10	;
    8f3e:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8f42:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8f46:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8f4a:	0e 4c       	mov	r12,	r14	;
    8f4c:	0d 49       	mov	r9,	r13	;
    8f4e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8f52:	8a 12       	call	r10		;
    8f54:	0e 3c       	jmp	$+30     	;abs 0x8f72

00008f56 <.L65>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8f56:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8f5a:	2a 4c       	mov	@r12,	r10	;
    8f5c:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8f60:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8f64:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8f68:	0e 4c       	mov	r12,	r14	;
    8f6a:	0d 49       	mov	r9,	r13	;
    8f6c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8f70:	8a 12       	call	r10		;

00008f72 <.L66>:
    }
    buf[0] = 0x00;
    8f72:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00008f76 <.Loc.389.1>:
    buf[1] = 0x1B;
    8f76:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8f7a:	93 52 

00008f7c <.Loc.390.1>:
    buf[2] = 0x00;
    8f7c:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008f80 <.Loc.391.1>:
    buf[3] = 0x08;
    8f80:	f2 42 95 52 	mov.b	#8,	&0x5295	;r2 As==11

00008f84 <.Loc.392.1>:
    buf[4] = 0x00;
    8f84:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00008f88 <.Loc.393.1>:
    buf[5] = 0x01;
    8f88:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00008f8c <.Loc.394.1>:
    buf[6] = 0x02;
    8f8c:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00008f90 <.Loc.395.1>:
    crcGenSDLP(buf, 9);
    8f90:	7d 40 09 00 	mov.b	#9,	r13	;
    8f94:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    8f98:	b0 12 20 82 	call	#33312		;#0x8220

00008f9c <.Loc.396.1>:
    if ((buf[7] != 0xBE) ||
    8f9c:	5c 42 99 52 	mov.b	&0x5299,r12	;0x5299
    8fa0:	7c 90 be ff 	cmp.b	#65470,	r12	;#0xffbe
    8fa4:	05 20       	jnz	$+12     	;abs 0x8fb0

00008fa6 <.Loc.397.1>:
        (buf[8] != 0x58)) {
    8fa6:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a

00008faa <.Loc.396.1>:
    buf[3] = 0x08;
    buf[4] = 0x00;
    buf[5] = 0x01;
    buf[6] = 0x02;
    crcGenSDLP(buf, 9);
    if ((buf[7] != 0xBE) ||
    8faa:	7c 90 58 00 	cmp.b	#88,	r12	;#0x0058
    8fae:	0f 24       	jz	$+32     	;abs 0x8fce

00008fb0 <.L67>:
        (buf[8] != 0x58)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    8fb0:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8fb4:	2a 4c       	mov	@r12,	r10	;
    8fb6:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    8fba:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    8fbe:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8fc2:	0e 4c       	mov	r12,	r14	;
    8fc4:	0d 49       	mov	r9,	r13	;
    8fc6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8fca:	8a 12       	call	r10		;
    8fcc:	0e 3c       	jmp	$+30     	;abs 0x8fea

00008fce <.L68>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    8fce:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    8fd2:	2a 4c       	mov	@r12,	r10	;
    8fd4:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    8fd8:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    8fdc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    8fe0:	0e 4c       	mov	r12,	r14	;
    8fe2:	0d 49       	mov	r9,	r13	;
    8fe4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    8fe8:	8a 12       	call	r10		;

00008fea <.L69>:
    }
    buf[0] = 0x00;
    8fea:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00008fee <.Loc.404.1>:
    buf[1] = 0x1B;
    8fee:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    8ff2:	93 52 

00008ff4 <.Loc.405.1>:
    buf[2] = 0x00;
    8ff4:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00008ff8 <.Loc.406.1>:
    buf[3] = 0x09;
    8ff8:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    8ffc:	95 52 

00008ffe <.Loc.407.1>:
    buf[4] = 0x01;
    8ffe:	d2 43 96 52 	mov.b	#1,	&0x5296	;r3 As==01

00009002 <.Loc.408.1>:
    buf[5] = 0x01;
    9002:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009006 <.Loc.409.1>:
    buf[6] = 0x02;
    9006:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

0000900a <.Loc.410.1>:
    buf[7] = 0x03;
    900a:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    900e:	99 52 

00009010 <.Loc.411.1>:
    crcGenSDLP(buf, 10);
    9010:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9014:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9018:	b0 12 20 82 	call	#33312		;#0x8220

0000901c <.Loc.412.1>:
    if ((buf[8] != 0xF2) ||
    901c:	5c 42 9a 52 	mov.b	&0x529a,r12	;0x529a
    9020:	7c 90 f2 ff 	cmp.b	#65522,	r12	;#0xfff2
    9024:	05 20       	jnz	$+12     	;abs 0x9030

00009026 <.Loc.413.1>:
        (buf[9] != 0x93)) {
    9026:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b

0000902a <.Loc.412.1>:
    buf[4] = 0x01;
    buf[5] = 0x01;
    buf[6] = 0x02;
    buf[7] = 0x03;
    crcGenSDLP(buf, 10);
    if ((buf[8] != 0xF2) ||
    902a:	7c 90 93 ff 	cmp.b	#65427,	r12	;#0xff93
    902e:	0f 24       	jz	$+32     	;abs 0x904e

00009030 <.L70>:
        (buf[9] != 0x93)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9030:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9034:	2a 4c       	mov	@r12,	r10	;
    9036:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    903a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    903e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9042:	0e 4c       	mov	r12,	r14	;
    9044:	0d 49       	mov	r9,	r13	;
    9046:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    904a:	8a 12       	call	r10		;
    904c:	0e 3c       	jmp	$+30     	;abs 0x906a

0000904e <.L71>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    904e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9052:	2a 4c       	mov	@r12,	r10	;
    9054:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9058:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    905c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9060:	0e 4c       	mov	r12,	r14	;
    9062:	0d 49       	mov	r9,	r13	;
    9064:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9068:	8a 12       	call	r10		;

0000906a <.L72>:
    }
    buf[0] = 0x00;
    906a:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

0000906e <.Loc.420.1>:
    buf[1] = 0x1B;
    906e:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9072:	93 52 

00009074 <.Loc.421.1>:
    buf[2] = 0x00;
    9074:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009078 <.Loc.422.1>:
    buf[3] = 0x0A;
    9078:	f2 40 0a 00 	mov.b	#10,	&0x5295	;#0x000a
    907c:	95 52 

0000907e <.Loc.423.1>:
    buf[4] = 0x02;
    907e:	e2 43 96 52 	mov.b	#2,	&0x5296	;r3 As==10

00009082 <.Loc.424.1>:
    buf[5] = 0x01;
    9082:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009086 <.Loc.425.1>:
    buf[6] = 0x02;
    9086:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

0000908a <.Loc.426.1>:
    buf[7] = 0x03;
    908a:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    908e:	99 52 

00009090 <.Loc.427.1>:
    buf[8] = 0x04;
    9090:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

00009094 <.Loc.428.1>:
    crcGenSDLP(buf, 11);
    9094:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    9098:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    909c:	b0 12 20 82 	call	#33312		;#0x8220

000090a0 <.Loc.429.1>:
    if ((buf[9] != 0x3C) ||
    90a0:	5c 42 9b 52 	mov.b	&0x529b,r12	;0x529b
    90a4:	7c 90 3c 00 	cmp.b	#60,	r12	;#0x003c
    90a8:	05 20       	jnz	$+12     	;abs 0x90b4

000090aa <.Loc.430.1>:
        (buf[10] != 0xEB)) {
    90aa:	5c 42 9c 52 	mov.b	&0x529c,r12	;0x529c

000090ae <.Loc.429.1>:
    buf[5] = 0x01;
    buf[6] = 0x02;
    buf[7] = 0x03;
    buf[8] = 0x04;
    crcGenSDLP(buf, 11);
    if ((buf[9] != 0x3C) ||
    90ae:	7c 90 eb ff 	cmp.b	#65515,	r12	;#0xffeb
    90b2:	0f 24       	jz	$+32     	;abs 0x90d2

000090b4 <.L73>:
        (buf[10] != 0xEB)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    90b4:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    90b8:	2a 4c       	mov	@r12,	r10	;
    90ba:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    90be:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    90c2:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    90c6:	0e 4c       	mov	r12,	r14	;
    90c8:	0d 49       	mov	r9,	r13	;
    90ca:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    90ce:	8a 12       	call	r10		;
    90d0:	0e 3c       	jmp	$+30     	;abs 0x90ee

000090d2 <.L74>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    90d2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    90d6:	2a 4c       	mov	@r12,	r10	;
    90d8:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    90dc:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    90e0:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    90e4:	0e 4c       	mov	r12,	r14	;
    90e6:	0d 49       	mov	r9,	r13	;
    90e8:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    90ec:	8a 12       	call	r10		;

000090ee <.L75>:
    }
    buf[0] = 0x00;
    90ee:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

000090f2 <.Loc.437.1>:
    buf[1] = 0x1B;
    90f2:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    90f6:	93 52 

000090f8 <.Loc.438.1>:
    buf[2] = 0x00;
    90f8:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000090fc <.Loc.439.1>:
    buf[3] = 0x0E;
    90fc:	f2 40 0e 00 	mov.b	#14,	&0x5295	;#0x000e
    9100:	95 52 

00009102 <.Loc.440.1>:
    buf[4] = 0x06;
    9102:	f2 40 06 00 	mov.b	#6,	&0x5296	;
    9106:	96 52 

00009108 <.Loc.441.1>:
    buf[5] = 0x01;
    9108:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

0000910c <.Loc.442.1>:
    buf[6] = 0x02;
    910c:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00009110 <.Loc.443.1>:
    buf[7] = 0x03;
    9110:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    9114:	99 52 

00009116 <.Loc.444.1>:
    buf[8] = 0x04;
    9116:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

0000911a <.Loc.445.1>:
    buf[9] = 0x05;
    911a:	f2 40 05 00 	mov.b	#5,	&0x529b	;
    911e:	9b 52 

00009120 <.Loc.446.1>:
    buf[10] = 0x06;
    9120:	f2 40 06 00 	mov.b	#6,	&0x529c	;
    9124:	9c 52 

00009126 <.Loc.447.1>:
    buf[11] = 0x07;
    9126:	f2 40 07 00 	mov.b	#7,	&0x529d	;
    912a:	9d 52 

0000912c <.Loc.448.1>:
    buf[12] = 0x08;
    912c:	f2 42 9e 52 	mov.b	#8,	&0x529e	;r2 As==11

00009130 <.Loc.449.1>:
    crcGenSDLP(buf, 15);
    9130:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    9134:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9138:	b0 12 20 82 	call	#33312		;#0x8220

0000913c <.Loc.450.1>:
    if ((buf[13] != 0x14) ||
    913c:	5c 42 9f 52 	mov.b	&0x529f,r12	;0x529f
    9140:	7c 90 14 00 	cmp.b	#20,	r12	;#0x0014
    9144:	05 20       	jnz	$+12     	;abs 0x9150

00009146 <.Loc.451.1>:
        (buf[14] != 0xBB)) {
    9146:	5c 42 a0 52 	mov.b	&0x52a0,r12	;0x52a0

0000914a <.Loc.450.1>:
    buf[9] = 0x05;
    buf[10] = 0x06;
    buf[11] = 0x07;
    buf[12] = 0x08;
    crcGenSDLP(buf, 15);
    if ((buf[13] != 0x14) ||
    914a:	7c 90 bb ff 	cmp.b	#65467,	r12	;#0xffbb
    914e:	0f 24       	jz	$+32     	;abs 0x916e

00009150 <.L76>:
        (buf[14] != 0xBB)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9150:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9154:	2a 4c       	mov	@r12,	r10	;
    9156:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    915a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    915e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9162:	0e 4c       	mov	r12,	r14	;
    9164:	0d 49       	mov	r9,	r13	;
    9166:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    916a:	8a 12       	call	r10		;
    916c:	0e 3c       	jmp	$+30     	;abs 0x918a

0000916e <.L77>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    916e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9172:	2a 4c       	mov	@r12,	r10	;
    9174:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9178:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    917c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9180:	0e 4c       	mov	r12,	r14	;
    9182:	0d 49       	mov	r9,	r13	;
    9184:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9188:	8a 12       	call	r10		;

0000918a <.L78>:
    }
    buf[0] = 0x00;
    918a:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

0000918e <.Loc.458.1>:
    buf[1] = 0x1B;
    918e:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9192:	93 52 

00009194 <.Loc.459.1>:
    buf[2] = 0x00;
    9194:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009198 <.Loc.460.1>:
    buf[3] = 0x0F;
    9198:	f2 40 0f 00 	mov.b	#15,	&0x5295	;#0x000f
    919c:	95 52 

0000919e <.Loc.461.1>:
    buf[4] = 0x07;
    919e:	f2 40 07 00 	mov.b	#7,	&0x5296	;
    91a2:	96 52 

000091a4 <.Loc.462.1>:
    buf[5] = 0x01;
    91a4:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

000091a8 <.Loc.463.1>:
    buf[6] = 0x02;
    91a8:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

000091ac <.Loc.464.1>:
    buf[7] = 0x03;
    91ac:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    91b0:	99 52 

000091b2 <.Loc.465.1>:
    buf[8] = 0x04;
    91b2:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

000091b6 <.Loc.466.1>:
    buf[9] = 0x05;
    91b6:	f2 40 05 00 	mov.b	#5,	&0x529b	;
    91ba:	9b 52 

000091bc <.Loc.467.1>:
    buf[10] = 0x06;
    91bc:	f2 40 06 00 	mov.b	#6,	&0x529c	;
    91c0:	9c 52 

000091c2 <.Loc.468.1>:
    buf[11] = 0x07;
    91c2:	f2 40 07 00 	mov.b	#7,	&0x529d	;
    91c6:	9d 52 

000091c8 <.Loc.469.1>:
    buf[12] = 0x08;
    91c8:	f2 42 9e 52 	mov.b	#8,	&0x529e	;r2 As==11

000091cc <.Loc.470.1>:
    buf[13] = 0x09;
    91cc:	f2 40 09 00 	mov.b	#9,	&0x529f	;
    91d0:	9f 52 

000091d2 <.Loc.471.1>:
    crcGenSDLP(buf, 16);
    91d2:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    91d6:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    91da:	b0 12 20 82 	call	#33312		;#0x8220

000091de <.Loc.472.1>:
    if ((buf[14] != 0xCF) ||
    91de:	5c 42 a0 52 	mov.b	&0x52a0,r12	;0x52a0
    91e2:	7c 90 cf ff 	cmp.b	#65487,	r12	;#0xffcf
    91e6:	05 20       	jnz	$+12     	;abs 0x91f2

000091e8 <.Loc.473.1>:
        (buf[15] != 0x90)) {
    91e8:	5c 42 a1 52 	mov.b	&0x52a1,r12	;0x52a1

000091ec <.Loc.472.1>:
    buf[10] = 0x06;
    buf[11] = 0x07;
    buf[12] = 0x08;
    buf[13] = 0x09;
    crcGenSDLP(buf, 16);
    if ((buf[14] != 0xCF) ||
    91ec:	7c 90 90 ff 	cmp.b	#65424,	r12	;#0xff90
    91f0:	0f 24       	jz	$+32     	;abs 0x9210

000091f2 <.L79>:
        (buf[15] != 0x90)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    91f2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    91f6:	2a 4c       	mov	@r12,	r10	;
    91f8:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    91fc:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9200:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9204:	0e 4c       	mov	r12,	r14	;
    9206:	0d 49       	mov	r9,	r13	;
    9208:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    920c:	8a 12       	call	r10		;
    920e:	0e 3c       	jmp	$+30     	;abs 0x922c

00009210 <.L80>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9210:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9214:	2a 4c       	mov	@r12,	r10	;
    9216:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    921a:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    921e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9222:	0e 4c       	mov	r12,	r14	;
    9224:	0d 49       	mov	r9,	r13	;
    9226:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    922a:	8a 12       	call	r10		;

0000922c <.L81>:
    }
    buf[0] = 0x00;
    922c:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009230 <.Loc.480.1>:
    buf[1] = 0x1B;
    9230:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9234:	93 52 

00009236 <.Loc.481.1>:
    buf[2] = 0x00;
    9236:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

0000923a <.Loc.482.1>:
    buf[3] = 0x11;
    923a:	f2 40 11 00 	mov.b	#17,	&0x5295	;#0x0011
    923e:	95 52 

00009240 <.Loc.483.1>:
    buf[4] = 0x00;
    9240:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009244 <.Loc.484.1>:
    buf[5] = 0xC0;
    9244:	f2 40 c0 ff 	mov.b	#65472,	&0x5297	;#0xffc0
    9248:	97 52 

0000924a <.Loc.485.1>:
    buf[6] = 0x10;
    924a:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    924e:	98 52 

00009250 <.Loc.486.1>:
    buf[7] = 0x00;
    9250:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009254 <.Loc.487.1>:
    buf[8] = 0xC0;
    9254:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    9258:	9a 52 

0000925a <.Loc.488.1>:
    buf[9] = 0x00;
    925a:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

0000925e <.Loc.489.1>:
    buf[10] = 0x00;
    925e:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

00009262 <.Loc.490.1>:
    buf[11] = 0x03;
    9262:	f2 40 03 00 	mov.b	#3,	&0x529d	;
    9266:	9d 52 

00009268 <.Loc.491.1>:
    buf[12] = 0x2E;
    9268:	f2 40 2e 00 	mov.b	#46,	&0x529e	;#0x002e
    926c:	9e 52 

0000926e <.Loc.492.1>:
    buf[13] = 0xAF;
    926e:	f2 40 af ff 	mov.b	#65455,	&0x529f	;#0xffaf
    9272:	9f 52 

00009274 <.Loc.493.1>:
    buf[14] = 0x8A;
    9274:	f2 40 8a ff 	mov.b	#65418,	&0x52a0	;#0xff8a
    9278:	a0 52 

0000927a <.Loc.494.1>:
    buf[15] = 0x06;
    927a:	f2 40 06 00 	mov.b	#6,	&0x52a1	;
    927e:	a1 52 

00009280 <.Loc.495.1>:
    crcGenSDLP(buf, 18);
    9280:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    9284:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9288:	b0 12 20 82 	call	#33312		;#0x8220

0000928c <.Loc.496.1>:
    if ((buf[16] != 0x9F) ||
    928c:	5c 42 a2 52 	mov.b	&0x52a2,r12	;0x52a2
    9290:	7c 90 9f ff 	cmp.b	#65439,	r12	;#0xff9f
    9294:	05 20       	jnz	$+12     	;abs 0x92a0

00009296 <.Loc.497.1>:
        (buf[17] != 0x71)) {
    9296:	5c 42 a3 52 	mov.b	&0x52a3,r12	;0x52a3

0000929a <.Loc.496.1>:
    buf[12] = 0x2E;
    buf[13] = 0xAF;
    buf[14] = 0x8A;
    buf[15] = 0x06;
    crcGenSDLP(buf, 18);
    if ((buf[16] != 0x9F) ||
    929a:	7c 90 71 00 	cmp.b	#113,	r12	;#0x0071
    929e:	0f 24       	jz	$+32     	;abs 0x92be

000092a0 <.L82>:
        (buf[17] != 0x71)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    92a0:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    92a4:	2a 4c       	mov	@r12,	r10	;
    92a6:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    92aa:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    92ae:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    92b2:	0e 4c       	mov	r12,	r14	;
    92b4:	0d 49       	mov	r9,	r13	;
    92b6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    92ba:	8a 12       	call	r10		;
    92bc:	0e 3c       	jmp	$+30     	;abs 0x92da

000092be <.L83>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    92be:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    92c2:	2a 4c       	mov	@r12,	r10	;
    92c4:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    92c8:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    92cc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    92d0:	0e 4c       	mov	r12,	r14	;
    92d2:	0d 49       	mov	r9,	r13	;
    92d4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    92d8:	8a 12       	call	r10		;

000092da <.L84>:
    }
    buf[0] = 0x00;
    92da:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

000092de <.Loc.504.1>:
    buf[1] = 0x1B;
    92de:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    92e2:	93 52 

000092e4 <.Loc.505.1>:
    buf[2] = 0x00;
    92e4:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000092e8 <.Loc.506.1>:
    buf[3] = 0x12;
    92e8:	f2 40 12 00 	mov.b	#18,	&0x5295	;#0x0012
    92ec:	95 52 

000092ee <.Loc.507.1>:
    buf[4] = 0x00;
    92ee:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

000092f2 <.Loc.508.1>:
    buf[5] = 0xC1;
    92f2:	f2 40 c1 ff 	mov.b	#65473,	&0x5297	;#0xffc1
    92f6:	97 52 

000092f8 <.Loc.509.1>:
    buf[6] = 0x10;
    92f8:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    92fc:	98 52 

000092fe <.Loc.510.1>:
    buf[7] = 0x00;
    92fe:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009302 <.Loc.511.1>:
    buf[8] = 0xFF;
    9302:	f2 43 9a 52 	mov.b	#-1,	&0x529a	;r3 As==11

00009306 <.Loc.512.1>:
    buf[9] = 0xFF;
    9306:	f2 43 9b 52 	mov.b	#-1,	&0x529b	;r3 As==11

0000930a <.Loc.513.1>:
    buf[10] = 0x00;
    930a:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

0000930e <.Loc.514.1>:
    buf[11] = 0x04;
    930e:	e2 42 9d 52 	mov.b	#4,	&0x529d	;r2 As==10

00009312 <.Loc.515.1>:
    buf[12] = 0x01;
    9312:	d2 43 9e 52 	mov.b	#1,	&0x529e	;r3 As==01

00009316 <.Loc.516.1>:
    buf[13] = 0x02;
    9316:	e2 43 9f 52 	mov.b	#2,	&0x529f	;r3 As==10

0000931a <.Loc.517.1>:
    buf[14] = 0x03;
    931a:	f2 40 03 00 	mov.b	#3,	&0x52a0	;
    931e:	a0 52 

00009320 <.Loc.518.1>:
    buf[15] = 0x11;
    9320:	f2 40 11 00 	mov.b	#17,	&0x52a1	;#0x0011
    9324:	a1 52 

00009326 <.Loc.519.1>:
    buf[16] = 0x82;
    9326:	f2 40 82 ff 	mov.b	#65410,	&0x52a2	;#0xff82
    932a:	a2 52 

0000932c <.Loc.520.1>:
    crcGenSDLP(buf, 19);
    932c:	7d 40 13 00 	mov.b	#19,	r13	;#0x0013
    9330:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9334:	b0 12 20 82 	call	#33312		;#0x8220

00009338 <.Loc.521.1>:
    if ((buf[17] != 0x8D) ||
    9338:	5c 42 a3 52 	mov.b	&0x52a3,r12	;0x52a3
    933c:	7c 90 8d ff 	cmp.b	#65421,	r12	;#0xff8d
    9340:	05 20       	jnz	$+12     	;abs 0x934c

00009342 <.Loc.522.1>:
        (buf[18] != 0x80)) {
    9342:	5c 42 a4 52 	mov.b	&0x52a4,r12	;0x52a4

00009346 <.Loc.521.1>:
    buf[13] = 0x02;
    buf[14] = 0x03;
    buf[15] = 0x11;
    buf[16] = 0x82;
    crcGenSDLP(buf, 19);
    if ((buf[17] != 0x8D) ||
    9346:	7c 90 80 ff 	cmp.b	#65408,	r12	;#0xff80
    934a:	0f 24       	jz	$+32     	;abs 0x936a

0000934c <.L85>:
        (buf[18] != 0x80)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    934c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9350:	2a 4c       	mov	@r12,	r10	;
    9352:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9356:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    935a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    935e:	0e 4c       	mov	r12,	r14	;
    9360:	0d 49       	mov	r9,	r13	;
    9362:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9366:	8a 12       	call	r10		;
    9368:	0e 3c       	jmp	$+30     	;abs 0x9386

0000936a <.L86>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    936a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    936e:	2a 4c       	mov	@r12,	r10	;
    9370:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9374:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9378:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    937c:	0e 4c       	mov	r12,	r14	;
    937e:	0d 49       	mov	r9,	r13	;
    9380:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9384:	8a 12       	call	r10		;

00009386 <.L87>:
    }
    buf[0] = 0x00;
    9386:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

0000938a <.Loc.529.1>:
    buf[1] = 0x1B;
    938a:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    938e:	93 52 

00009390 <.Loc.530.1>:
    buf[2] = 0x00;
    9390:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009394 <.Loc.531.1>:
    buf[3] = 0x12;
    9394:	f2 40 12 00 	mov.b	#18,	&0x5295	;#0x0012
    9398:	95 52 

0000939a <.Loc.532.1>:
    buf[4] = 0x00;
    939a:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

0000939e <.Loc.533.1>:
    buf[5] = 0xC1;
    939e:	f2 40 c1 ff 	mov.b	#65473,	&0x5297	;#0xffc1
    93a2:	97 52 

000093a4 <.Loc.534.1>:
    buf[6] = 0x11;
    93a4:	f2 40 11 00 	mov.b	#17,	&0x5298	;#0x0011
    93a8:	98 52 

000093aa <.Loc.535.1>:
    buf[7] = 0x04;
    93aa:	e2 42 99 52 	mov.b	#4,	&0x5299	;r2 As==10

000093ae <.Loc.536.1>:
    buf[8] = 0xC0;
    93ae:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    93b2:	9a 52 

000093b4 <.Loc.537.1>:
    buf[9] = 0x00;
    93b4:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

000093b8 <.Loc.538.1>:
    buf[10] = 0x00;
    93b8:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

000093bc <.Loc.539.1>:
    buf[11] = 0x04;
    93bc:	e2 42 9d 52 	mov.b	#4,	&0x529d	;r2 As==10

000093c0 <.Loc.540.1>:
    buf[12] = 0x01;
    93c0:	d2 43 9e 52 	mov.b	#1,	&0x529e	;r3 As==01

000093c4 <.Loc.541.1>:
    buf[13] = 0x02;
    93c4:	e2 43 9f 52 	mov.b	#2,	&0x529f	;r3 As==10

000093c8 <.Loc.542.1>:
    buf[14] = 0x03;
    93c8:	f2 40 03 00 	mov.b	#3,	&0x52a0	;
    93cc:	a0 52 

000093ce <.Loc.543.1>:
    buf[15] = 0x72;
    93ce:	f2 40 72 00 	mov.b	#114,	&0x52a1	;#0x0072
    93d2:	a1 52 

000093d4 <.Loc.544.1>:
    buf[16] = 0x17;
    93d4:	f2 40 17 00 	mov.b	#23,	&0x52a2	;#0x0017
    93d8:	a2 52 

000093da <.Loc.545.1>:
    crcGenSDLP(buf, 19);
    93da:	7d 40 13 00 	mov.b	#19,	r13	;#0x0013
    93de:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    93e2:	b0 12 20 82 	call	#33312		;#0x8220

000093e6 <.Loc.546.1>:
    if ((buf[17] != 0x8D) ||
    93e6:	5c 42 a3 52 	mov.b	&0x52a3,r12	;0x52a3
    93ea:	7c 90 8d ff 	cmp.b	#65421,	r12	;#0xff8d
    93ee:	05 20       	jnz	$+12     	;abs 0x93fa

000093f0 <.Loc.547.1>:
        (buf[18] != 0x80)) {
    93f0:	5c 42 a4 52 	mov.b	&0x52a4,r12	;0x52a4

000093f4 <.Loc.546.1>:
    buf[13] = 0x02;
    buf[14] = 0x03;
    buf[15] = 0x72;
    buf[16] = 0x17;
    crcGenSDLP(buf, 19);
    if ((buf[17] != 0x8D) ||
    93f4:	7c 90 80 ff 	cmp.b	#65408,	r12	;#0xff80
    93f8:	0f 24       	jz	$+32     	;abs 0x9418

000093fa <.L88>:
        (buf[18] != 0x80)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    93fa:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    93fe:	2a 4c       	mov	@r12,	r10	;
    9400:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9404:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9408:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    940c:	0e 4c       	mov	r12,	r14	;
    940e:	0d 49       	mov	r9,	r13	;
    9410:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9414:	8a 12       	call	r10		;
    9416:	0e 3c       	jmp	$+30     	;abs 0x9434

00009418 <.L89>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9418:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    941c:	2a 4c       	mov	@r12,	r10	;
    941e:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9422:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9426:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    942a:	0e 4c       	mov	r12,	r14	;
    942c:	0d 49       	mov	r9,	r13	;
    942e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9432:	8a 12       	call	r10		;

00009434 <.L90>:
    }
    buf[0] = 0x20;
    9434:	f2 40 20 00 	mov.b	#32,	&0x5292	;#0x0020
    9438:	92 52 

0000943a <.Loc.554.1>:
    buf[1] = 0x1B;
    943a:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    943e:	93 52 

00009440 <.Loc.555.1>:
    buf[2] = 0x00;
    9440:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009444 <.Loc.556.1>:
    buf[3] = 0x07;
    9444:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    9448:	95 52 

0000944a <.Loc.557.1>:
    buf[4] = 0x00;
    944a:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

0000944e <.Loc.558.1>:
    buf[5] = 0xE1;
    944e:	f2 40 e1 ff 	mov.b	#65505,	&0x5297	;#0xffe1
    9452:	97 52 

00009454 <.Loc.559.1>:
    crcGenSDLP(buf, 8);
    9454:	7d 42       	mov.b	#8,	r13	;r2 As==11
    9456:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    945a:	b0 12 20 82 	call	#33312		;#0x8220

0000945e <.Loc.560.1>:
    if ((buf[6] != 0xBB) ||
    945e:	5c 42 98 52 	mov.b	&0x5298,r12	;0x5298
    9462:	7c 90 bb ff 	cmp.b	#65467,	r12	;#0xffbb
    9466:	05 20       	jnz	$+12     	;abs 0x9472

00009468 <.Loc.561.1>:
        (buf[7] != 0x22)) {
    9468:	5c 42 99 52 	mov.b	&0x5299,r12	;0x5299

0000946c <.Loc.560.1>:
    buf[2] = 0x00;
    buf[3] = 0x07;
    buf[4] = 0x00;
    buf[5] = 0xE1;
    crcGenSDLP(buf, 8);
    if ((buf[6] != 0xBB) ||
    946c:	7c 90 22 00 	cmp.b	#34,	r12	;#0x0022
    9470:	0f 24       	jz	$+32     	;abs 0x9490

00009472 <.L91>:
        (buf[7] != 0x22)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9472:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9476:	2a 4c       	mov	@r12,	r10	;
    9478:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    947c:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9480:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9484:	0e 4c       	mov	r12,	r14	;
    9486:	0d 49       	mov	r9,	r13	;
    9488:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    948c:	8a 12       	call	r10		;
    948e:	0e 3c       	jmp	$+30     	;abs 0x94ac

00009490 <.L92>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9490:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9494:	2a 4c       	mov	@r12,	r10	;
    9496:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    949a:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    949e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    94a2:	0e 4c       	mov	r12,	r14	;
    94a4:	0d 49       	mov	r9,	r13	;
    94a6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    94aa:	8a 12       	call	r10		;

000094ac <.L93>:
    }
    buf[0] = 0x20;
    94ac:	f2 40 20 00 	mov.b	#32,	&0x5292	;#0x0020
    94b0:	92 52 

000094b2 <.Loc.568.1>:
    buf[1] = 0x1B;
    94b2:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    94b6:	93 52 

000094b8 <.Loc.569.1>:
    buf[2] = 0x00;
    94b8:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000094bc <.Loc.570.1>:
    buf[3] = 0x11;
    94bc:	f2 40 11 00 	mov.b	#17,	&0x5295	;#0x0011
    94c0:	95 52 

000094c2 <.Loc.571.1>:
    buf[4] = 0x00;
    94c2:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

000094c6 <.Loc.572.1>:
    buf[5] = 0xC0;
    94c6:	f2 40 c0 ff 	mov.b	#65472,	&0x5297	;#0xffc0
    94ca:	97 52 

000094cc <.Loc.573.1>:
    buf[6] = 0x10;
    94cc:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    94d0:	98 52 

000094d2 <.Loc.574.1>:
    buf[7] = 0x00;
    94d2:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

000094d6 <.Loc.575.1>:
    buf[8] = 0xC0;
    94d6:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    94da:	9a 52 

000094dc <.Loc.576.1>:
    buf[9] = 0x00;
    94dc:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

000094e0 <.Loc.577.1>:
    buf[10] = 0x00;
    94e0:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

000094e4 <.Loc.578.1>:
    buf[11] = 0x03;
    94e4:	f2 40 03 00 	mov.b	#3,	&0x529d	;
    94e8:	9d 52 

000094ea <.Loc.579.1>:
    buf[12] = 0x2E;
    94ea:	f2 40 2e 00 	mov.b	#46,	&0x529e	;#0x002e
    94ee:	9e 52 

000094f0 <.Loc.580.1>:
    buf[13] = 0xAF;
    94f0:	f2 40 af ff 	mov.b	#65455,	&0x529f	;#0xffaf
    94f4:	9f 52 

000094f6 <.Loc.581.1>:
    buf[14] = 0x8A;
    94f6:	f2 40 8a ff 	mov.b	#65418,	&0x52a0	;#0xff8a
    94fa:	a0 52 

000094fc <.Loc.582.1>:
    buf[15] = 0x06;
    94fc:	f2 40 06 00 	mov.b	#6,	&0x52a1	;
    9500:	a1 52 

00009502 <.Loc.583.1>:
    crcGenSDLP(buf, 18);
    9502:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    9506:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    950a:	b0 12 20 82 	call	#33312		;#0x8220

0000950e <.Loc.584.1>:
    if ((buf[16] != 0xD9) ||
    950e:	5c 42 a2 52 	mov.b	&0x52a2,r12	;0x52a2
    9512:	7c 90 d9 ff 	cmp.b	#65497,	r12	;#0xffd9
    9516:	05 20       	jnz	$+12     	;abs 0x9522

00009518 <.Loc.585.1>:
        (buf[17] != 0x65)) {
    9518:	5c 42 a3 52 	mov.b	&0x52a3,r12	;0x52a3

0000951c <.Loc.584.1>:
    buf[12] = 0x2E;
    buf[13] = 0xAF;
    buf[14] = 0x8A;
    buf[15] = 0x06;
    crcGenSDLP(buf, 18);
    if ((buf[16] != 0xD9) ||
    951c:	7c 90 65 00 	cmp.b	#101,	r12	;#0x0065
    9520:	0f 24       	jz	$+32     	;abs 0x9540

00009522 <.L94>:
        (buf[17] != 0x65)) {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9522:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9526:	2a 4c       	mov	@r12,	r10	;
    9528:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    952c:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9530:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9534:	0e 4c       	mov	r12,	r14	;
    9536:	0d 49       	mov	r9,	r13	;
    9538:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    953c:	8a 12       	call	r10		;
    953e:	0e 3c       	jmp	$+30     	;abs 0x955c

00009540 <.L95>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9540:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9544:	2a 4c       	mov	@r12,	r10	;
    9546:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    954a:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    954e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9552:	0e 4c       	mov	r12,	r14	;
    9554:	0d 49       	mov	r9,	r13	;
    9556:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    955a:	8a 12       	call	r10		;

0000955c <.L96>:
    }
    
    /* Backwards */
    buf[0] = 0x30;
    955c:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    9560:	92 52 

00009562 <.Loc.594.1>:
    buf[1] = 0x1B;
    9562:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9566:	93 52 

00009568 <.Loc.595.1>:
    buf[2] = 0x00;
    9568:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

0000956c <.Loc.596.1>:
    buf[3] = 0x07;
    956c:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    9570:	95 52 

00009572 <.Loc.597.1>:
    buf[4] = 0x00;
    9572:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009576 <.Loc.598.1>:
    buf[5] = 0x00;
    9576:	c2 43 97 52 	mov.b	#0,	&0x5297	;r3 As==00

0000957a <.Loc.599.1>:
    buf[6] = 0x4C;
    957a:	f2 40 4c 00 	mov.b	#76,	&0x5298	;#0x004c
    957e:	98 52 

00009580 <.Loc.600.1>:
    buf[7] = 0xA9;
    9580:	f2 40 a9 ff 	mov.b	#65449,	&0x5299	;#0xffa9
    9584:	99 52 

00009586 <.Loc.601.1>:
    if (!crcCheckSDLP(buf, 8)) {
    9586:	7d 42       	mov.b	#8,	r13	;r2 As==11
    9588:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    958c:	b0 12 ae 82 	call	#33454		;#0x82ae
    9590:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9594:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9596:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    959a:	0c 93       	cmp	#0,	r12	;r3 As==00
    959c:	0f 24       	jz	$+32     	;abs 0x95bc

0000959e <.Loc.602.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    959e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    95a2:	2a 4c       	mov	@r12,	r10	;
    95a4:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    95a8:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    95ac:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    95b0:	0e 4c       	mov	r12,	r14	;
    95b2:	0d 49       	mov	r9,	r13	;
    95b4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    95b8:	8a 12       	call	r10		;
    95ba:	0e 3c       	jmp	$+30     	;abs 0x95d8

000095bc <.L97>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    95bc:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    95c0:	2a 4c       	mov	@r12,	r10	;
    95c2:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    95c6:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    95ca:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    95ce:	0e 4c       	mov	r12,	r14	;
    95d0:	0d 49       	mov	r9,	r13	;
    95d2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    95d6:	8a 12       	call	r10		;

000095d8 <.L98>:
    }
    buf[0] = 0x30;
    95d8:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    95dc:	92 52 

000095de <.Loc.608.1>:
    buf[1] = 0x1B;
    95de:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    95e2:	93 52 

000095e4 <.Loc.609.1>:
    buf[2] = 0x00;
    95e4:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

000095e8 <.Loc.610.1>:
    buf[3] = 0x09;
    95e8:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    95ec:	95 52 

000095ee <.Loc.611.1>:
    buf[4] = 0x00;
    95ee:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

000095f2 <.Loc.612.1>:
    buf[5] = 0x82;
    95f2:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    95f6:	97 52 

000095f8 <.Loc.613.1>:
    buf[6] = 0x00;
    95f8:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

000095fc <.Loc.614.1>:
    buf[7] = 0x00;
    95fc:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009600 <.Loc.615.1>:
    buf[8] = 0xF6;
    9600:	f2 40 f6 ff 	mov.b	#65526,	&0x529a	;#0xfff6
    9604:	9a 52 

00009606 <.Loc.616.1>:
    buf[9] = 0xF0;
    9606:	f2 40 f0 ff 	mov.b	#65520,	&0x529b	;#0xfff0
    960a:	9b 52 

0000960c <.Loc.617.1>:
    if (!crcCheckSDLP(buf, 10)) {
    960c:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9610:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9614:	b0 12 ae 82 	call	#33454		;#0x82ae
    9618:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    961c:	5c e3       	xor.b	#1,	r12	;r3 As==01
    961e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9622:	0c 93       	cmp	#0,	r12	;r3 As==00
    9624:	0f 24       	jz	$+32     	;abs 0x9644

00009626 <.Loc.618.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9626:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    962a:	2a 4c       	mov	@r12,	r10	;
    962c:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9630:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9634:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9638:	0e 4c       	mov	r12,	r14	;
    963a:	0d 49       	mov	r9,	r13	;
    963c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9640:	8a 12       	call	r10		;
    9642:	0e 3c       	jmp	$+30     	;abs 0x9660

00009644 <.L99>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9644:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9648:	2a 4c       	mov	@r12,	r10	;
    964a:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    964e:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9652:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9656:	0e 4c       	mov	r12,	r14	;
    9658:	0d 49       	mov	r9,	r13	;
    965a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    965e:	8a 12       	call	r10		;

00009660 <.L100>:
    }
    buf[0] = 0x30;
    9660:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    9664:	92 52 

00009666 <.Loc.624.1>:
    buf[1] = 0x1B;
    9666:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    966a:	93 52 

0000966c <.Loc.625.1>:
    buf[2] = 0x00;
    966c:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009670 <.Loc.626.1>:
    buf[3] = 0x09;
    9670:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    9674:	95 52 

00009676 <.Loc.627.1>:
    buf[4] = 0x00;
    9676:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

0000967a <.Loc.628.1>:
    buf[5] = 0x82;
    967a:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    967e:	97 52 

00009680 <.Loc.629.1>:
    buf[6] = 0x00;
    9680:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00009684 <.Loc.630.1>:
    buf[7] = 0x10;
    9684:	f2 40 10 00 	mov.b	#16,	&0x5299	;#0x0010
    9688:	99 52 

0000968a <.Loc.631.1>:
    buf[8] = 0xE4;
    968a:	f2 40 e4 ff 	mov.b	#65508,	&0x529a	;#0xffe4
    968e:	9a 52 

00009690 <.Loc.632.1>:
    buf[9] = 0xC1;
    9690:	f2 40 c1 ff 	mov.b	#65473,	&0x529b	;#0xffc1
    9694:	9b 52 

00009696 <.Loc.633.1>:
    if (!crcCheckSDLP(buf, 10)) {
    9696:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    969a:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    969e:	b0 12 ae 82 	call	#33454		;#0x82ae
    96a2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    96a6:	5c e3       	xor.b	#1,	r12	;r3 As==01
    96a8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    96ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    96ae:	0f 24       	jz	$+32     	;abs 0x96ce

000096b0 <.Loc.634.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    96b0:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    96b4:	2a 4c       	mov	@r12,	r10	;
    96b6:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    96ba:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    96be:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    96c2:	0e 4c       	mov	r12,	r14	;
    96c4:	0d 49       	mov	r9,	r13	;
    96c6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    96ca:	8a 12       	call	r10		;
    96cc:	0e 3c       	jmp	$+30     	;abs 0x96ea

000096ce <.L101>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    96ce:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    96d2:	2a 4c       	mov	@r12,	r10	;
    96d4:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    96d8:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    96dc:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    96e0:	0e 4c       	mov	r12,	r14	;
    96e2:	0d 49       	mov	r9,	r13	;
    96e4:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    96e8:	8a 12       	call	r10		;

000096ea <.L102>:
    }
    buf[0] = 0x30;
    96ea:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    96ee:	92 52 

000096f0 <.Loc.640.1>:
    buf[1] = 0x1B;
    96f0:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    96f4:	93 52 

000096f6 <.Loc.641.1>:
    buf[2] = 0x04;
    96f6:	e2 42 94 52 	mov.b	#4,	&0x5294	;r2 As==10

000096fa <.Loc.642.1>:
    buf[3] = 0x09;
    96fa:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    96fe:	95 52 

00009700 <.Loc.643.1>:
    buf[4] = 0x00;
    9700:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009704 <.Loc.644.1>:
    buf[5] = 0x82;
    9704:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    9708:	97 52 

0000970a <.Loc.645.1>:
    buf[6] = 0x00;
    970a:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

0000970e <.Loc.646.1>:
    buf[7] = 0x00;
    970e:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009712 <.Loc.647.1>:
    buf[8] = 0xF0;
    9712:	f2 40 f0 ff 	mov.b	#65520,	&0x529a	;#0xfff0
    9716:	9a 52 

00009718 <.Loc.648.1>:
    buf[9] = 0x51;
    9718:	f2 40 51 00 	mov.b	#81,	&0x529b	;#0x0051
    971c:	9b 52 

0000971e <.Loc.649.1>:
    if (!crcCheckSDLP(buf, 10)) {
    971e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    9722:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9726:	b0 12 ae 82 	call	#33454		;#0x82ae
    972a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    972e:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9730:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9734:	0c 93       	cmp	#0,	r12	;r3 As==00
    9736:	0f 24       	jz	$+32     	;abs 0x9756

00009738 <.Loc.650.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9738:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    973c:	2a 4c       	mov	@r12,	r10	;
    973e:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9742:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9746:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    974a:	0e 4c       	mov	r12,	r14	;
    974c:	0d 49       	mov	r9,	r13	;
    974e:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9752:	8a 12       	call	r10		;
    9754:	0e 3c       	jmp	$+30     	;abs 0x9772

00009756 <.L103>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9756:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    975a:	2a 4c       	mov	@r12,	r10	;
    975c:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9760:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9764:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9768:	0e 4c       	mov	r12,	r14	;
    976a:	0d 49       	mov	r9,	r13	;
    976c:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9770:	8a 12       	call	r10		;

00009772 <.L104>:
    }
    buf[0] = 0x30;
    9772:	f2 40 30 00 	mov.b	#48,	&0x5292	;#0x0030
    9776:	92 52 

00009778 <.Loc.656.1>:
    buf[1] = 0x1B;
    9778:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    977c:	93 52 

0000977e <.Loc.657.1>:
    buf[2] = 0x04;
    977e:	e2 42 94 52 	mov.b	#4,	&0x5294	;r2 As==10

00009782 <.Loc.658.1>:
    buf[3] = 0x09;
    9782:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    9786:	95 52 

00009788 <.Loc.659.1>:
    buf[4] = 0x00;
    9788:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

0000978c <.Loc.660.1>:
    buf[5] = 0x82;
    978c:	f2 40 82 ff 	mov.b	#65410,	&0x5297	;#0xff82
    9790:	97 52 

00009792 <.Loc.661.1>:
    buf[6] = 0x00;
    9792:	c2 43 98 52 	mov.b	#0,	&0x5298	;r3 As==00

00009796 <.Loc.662.1>:
    buf[7] = 0x10;
    9796:	f2 40 10 00 	mov.b	#16,	&0x5299	;#0x0010
    979a:	99 52 

0000979c <.Loc.663.1>:
    buf[8] = 0xE2;
    979c:	f2 40 e2 ff 	mov.b	#65506,	&0x529a	;#0xffe2
    97a0:	9a 52 

000097a2 <.Loc.664.1>:
    buf[9] = 0x60;
    97a2:	f2 40 60 00 	mov.b	#96,	&0x529b	;#0x0060
    97a6:	9b 52 

000097a8 <.Loc.665.1>:
    if (!crcCheckSDLP(buf, 10)) {
    97a8:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    97ac:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    97b0:	b0 12 ae 82 	call	#33454		;#0x82ae
    97b4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    97b8:	5c e3       	xor.b	#1,	r12	;r3 As==01
    97ba:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    97be:	0c 93       	cmp	#0,	r12	;r3 As==00
    97c0:	0f 24       	jz	$+32     	;abs 0x97e0

000097c2 <.Loc.666.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    97c2:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    97c6:	2a 4c       	mov	@r12,	r10	;
    97c8:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    97cc:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    97d0:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    97d4:	0e 4c       	mov	r12,	r14	;
    97d6:	0d 49       	mov	r9,	r13	;
    97d8:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    97dc:	8a 12       	call	r10		;
    97de:	0e 3c       	jmp	$+30     	;abs 0x97fc

000097e0 <.L105>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    97e0:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    97e4:	2a 4c       	mov	@r12,	r10	;
    97e6:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    97ea:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    97ee:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    97f2:	0e 4c       	mov	r12,	r14	;
    97f4:	0d 49       	mov	r9,	r13	;
    97f6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    97fa:	8a 12       	call	r10		;

000097fc <.L106>:
    }
    buf[0] = 0x00;
    97fc:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009800 <.Loc.672.1>:
    buf[1] = 0x1B;
    9800:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9804:	93 52 

00009806 <.Loc.673.1>:
    buf[2] = 0x00;
    9806:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

0000980a <.Loc.674.1>:
    buf[3] = 0x07;
    980a:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    980e:	95 52 

00009810 <.Loc.675.1>:
    buf[4] = 0xFF;
    9810:	f2 43 96 52 	mov.b	#-1,	&0x5296	;r3 As==11

00009814 <.Loc.676.1>:
    buf[5] = 0x01;
    9814:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009818 <.Loc.677.1>:
    buf[6] = 0x70;
    9818:	f2 40 70 00 	mov.b	#112,	&0x5298	;#0x0070
    981c:	98 52 

0000981e <.Loc.678.1>:
    buf[7] = 0xFB;
    981e:	f2 40 fb ff 	mov.b	#65531,	&0x5299	;#0xfffb
    9822:	99 52 

00009824 <.Loc.679.1>:
    if (!crcCheckSDLP(buf, 8)) {
    9824:	7d 42       	mov.b	#8,	r13	;r2 As==11
    9826:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    982a:	b0 12 ae 82 	call	#33454		;#0x82ae
    982e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9832:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9834:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9838:	0c 93       	cmp	#0,	r12	;r3 As==00
    983a:	0f 24       	jz	$+32     	;abs 0x985a

0000983c <.Loc.680.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    983c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9840:	2a 4c       	mov	@r12,	r10	;
    9842:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9846:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    984a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    984e:	0e 4c       	mov	r12,	r14	;
    9850:	0d 49       	mov	r9,	r13	;
    9852:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9856:	8a 12       	call	r10		;
    9858:	0e 3c       	jmp	$+30     	;abs 0x9876

0000985a <.L107>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    985a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    985e:	2a 4c       	mov	@r12,	r10	;
    9860:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9864:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9868:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    986c:	0e 4c       	mov	r12,	r14	;
    986e:	0d 49       	mov	r9,	r13	;
    9870:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9874:	8a 12       	call	r10		;

00009876 <.L108>:
    }
    buf[0] = 0x00;
    9876:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

0000987a <.Loc.686.1>:
    buf[1] = 0x1B;
    987a:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    987e:	93 52 

00009880 <.Loc.687.1>:
    buf[2] = 0x00;
    9880:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009884 <.Loc.688.1>:
    buf[3] = 0x08;
    9884:	f2 42 95 52 	mov.b	#8,	&0x5295	;r2 As==11

00009888 <.Loc.689.1>:
    buf[4] = 0x00;
    9888:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

0000988c <.Loc.690.1>:
    buf[5] = 0x01;
    988c:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009890 <.Loc.691.1>:
    buf[6] = 0x02;
    9890:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00009894 <.Loc.692.1>:
    buf[7] = 0xBE;
    9894:	f2 40 be ff 	mov.b	#65470,	&0x5299	;#0xffbe
    9898:	99 52 

0000989a <.Loc.693.1>:
    buf[8] = 0x58;
    989a:	f2 40 58 00 	mov.b	#88,	&0x529a	;#0x0058
    989e:	9a 52 

000098a0 <.Loc.694.1>:
    if (!crcCheckSDLP(buf, 9)) {
    98a0:	7d 40 09 00 	mov.b	#9,	r13	;
    98a4:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    98a8:	b0 12 ae 82 	call	#33454		;#0x82ae
    98ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    98b0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    98b2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    98b6:	0c 93       	cmp	#0,	r12	;r3 As==00
    98b8:	0f 24       	jz	$+32     	;abs 0x98d8

000098ba <.Loc.695.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    98ba:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    98be:	2a 4c       	mov	@r12,	r10	;
    98c0:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    98c4:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    98c8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    98cc:	0e 4c       	mov	r12,	r14	;
    98ce:	0d 49       	mov	r9,	r13	;
    98d0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    98d4:	8a 12       	call	r10		;
    98d6:	0e 3c       	jmp	$+30     	;abs 0x98f4

000098d8 <.L109>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    98d8:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    98dc:	2a 4c       	mov	@r12,	r10	;
    98de:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    98e2:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    98e6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    98ea:	0e 4c       	mov	r12,	r14	;
    98ec:	0d 49       	mov	r9,	r13	;
    98ee:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    98f2:	8a 12       	call	r10		;

000098f4 <.L110>:
    }
    buf[0] = 0x00;
    98f4:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

000098f8 <.Loc.701.1>:
    buf[1] = 0x1B;
    98f8:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    98fc:	93 52 

000098fe <.Loc.702.1>:
    buf[2] = 0x00;
    98fe:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009902 <.Loc.703.1>:
    buf[3] = 0x09;
    9902:	f2 40 09 00 	mov.b	#9,	&0x5295	;
    9906:	95 52 

00009908 <.Loc.704.1>:
    buf[4] = 0x01;
    9908:	d2 43 96 52 	mov.b	#1,	&0x5296	;r3 As==01

0000990c <.Loc.705.1>:
    buf[5] = 0x01;
    990c:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009910 <.Loc.706.1>:
    buf[6] = 0x02;
    9910:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00009914 <.Loc.707.1>:
    buf[7] = 0x03;
    9914:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    9918:	99 52 

0000991a <.Loc.708.1>:
    buf[8] = 0xF2;
    991a:	f2 40 f2 ff 	mov.b	#65522,	&0x529a	;#0xfff2
    991e:	9a 52 

00009920 <.Loc.709.1>:
    buf[9] = 0x93;
    9920:	f2 40 93 ff 	mov.b	#65427,	&0x529b	;#0xff93
    9924:	9b 52 

00009926 <.Loc.710.1>:
    if (!crcCheckSDLP(buf, 10)) {
    9926:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    992a:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    992e:	b0 12 ae 82 	call	#33454		;#0x82ae
    9932:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9936:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9938:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    993c:	0c 93       	cmp	#0,	r12	;r3 As==00
    993e:	0f 24       	jz	$+32     	;abs 0x995e

00009940 <.Loc.711.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9940:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9944:	2a 4c       	mov	@r12,	r10	;
    9946:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    994a:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    994e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9952:	0e 4c       	mov	r12,	r14	;
    9954:	0d 49       	mov	r9,	r13	;
    9956:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    995a:	8a 12       	call	r10		;
    995c:	0e 3c       	jmp	$+30     	;abs 0x997a

0000995e <.L111>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    995e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9962:	2a 4c       	mov	@r12,	r10	;
    9964:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9968:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    996c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9970:	0e 4c       	mov	r12,	r14	;
    9972:	0d 49       	mov	r9,	r13	;
    9974:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9978:	8a 12       	call	r10		;

0000997a <.L112>:
    }
    buf[0] = 0x00;
    997a:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

0000997e <.Loc.717.1>:
    buf[1] = 0x1B;
    997e:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9982:	93 52 

00009984 <.Loc.718.1>:
    buf[2] = 0x00;
    9984:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009988 <.Loc.719.1>:
    buf[3] = 0x0A;
    9988:	f2 40 0a 00 	mov.b	#10,	&0x5295	;#0x000a
    998c:	95 52 

0000998e <.Loc.720.1>:
    buf[4] = 0x02;
    998e:	e2 43 96 52 	mov.b	#2,	&0x5296	;r3 As==10

00009992 <.Loc.721.1>:
    buf[5] = 0x01;
    9992:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009996 <.Loc.722.1>:
    buf[6] = 0x02;
    9996:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

0000999a <.Loc.723.1>:
    buf[7] = 0x03;
    999a:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    999e:	99 52 

000099a0 <.Loc.724.1>:
    buf[8] = 0x04;
    99a0:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

000099a4 <.Loc.725.1>:
    buf[9] = 0x3C;
    99a4:	f2 40 3c 00 	mov.b	#60,	&0x529b	;#0x003c
    99a8:	9b 52 

000099aa <.Loc.726.1>:
    buf[10] = 0xEB;
    99aa:	f2 40 eb ff 	mov.b	#65515,	&0x529c	;#0xffeb
    99ae:	9c 52 

000099b0 <.Loc.727.1>:
    if (!crcCheckSDLP(buf, 11)) {
    99b0:	7d 40 0b 00 	mov.b	#11,	r13	;#0x000b
    99b4:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    99b8:	b0 12 ae 82 	call	#33454		;#0x82ae
    99bc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    99c0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    99c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    99c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    99c8:	0f 24       	jz	$+32     	;abs 0x99e8

000099ca <.Loc.728.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    99ca:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    99ce:	2a 4c       	mov	@r12,	r10	;
    99d0:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    99d4:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    99d8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    99dc:	0e 4c       	mov	r12,	r14	;
    99de:	0d 49       	mov	r9,	r13	;
    99e0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    99e4:	8a 12       	call	r10		;
    99e6:	0e 3c       	jmp	$+30     	;abs 0x9a04

000099e8 <.L113>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    99e8:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    99ec:	2a 4c       	mov	@r12,	r10	;
    99ee:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    99f2:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    99f6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    99fa:	0e 4c       	mov	r12,	r14	;
    99fc:	0d 49       	mov	r9,	r13	;
    99fe:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9a02:	8a 12       	call	r10		;

00009a04 <.L114>:
    }
    buf[0] = 0x00;
    9a04:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009a08 <.Loc.734.1>:
    buf[1] = 0x1B;
    9a08:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9a0c:	93 52 

00009a0e <.Loc.735.1>:
    buf[2] = 0x00;
    9a0e:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009a12 <.Loc.736.1>:
    buf[3] = 0x0E;
    9a12:	f2 40 0e 00 	mov.b	#14,	&0x5295	;#0x000e
    9a16:	95 52 

00009a18 <.Loc.737.1>:
    buf[4] = 0x06;
    9a18:	f2 40 06 00 	mov.b	#6,	&0x5296	;
    9a1c:	96 52 

00009a1e <.Loc.738.1>:
    buf[5] = 0x01;
    9a1e:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009a22 <.Loc.739.1>:
    buf[6] = 0x02;
    9a22:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00009a26 <.Loc.740.1>:
    buf[7] = 0x03;
    9a26:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    9a2a:	99 52 

00009a2c <.Loc.741.1>:
    buf[8] = 0x04;
    9a2c:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

00009a30 <.Loc.742.1>:
    buf[9] = 0x05;
    9a30:	f2 40 05 00 	mov.b	#5,	&0x529b	;
    9a34:	9b 52 

00009a36 <.Loc.743.1>:
    buf[10] = 0x06;
    9a36:	f2 40 06 00 	mov.b	#6,	&0x529c	;
    9a3a:	9c 52 

00009a3c <.Loc.744.1>:
    buf[11] = 0x07;
    9a3c:	f2 40 07 00 	mov.b	#7,	&0x529d	;
    9a40:	9d 52 

00009a42 <.Loc.745.1>:
    buf[12] = 0x08;
    9a42:	f2 42 9e 52 	mov.b	#8,	&0x529e	;r2 As==11

00009a46 <.Loc.746.1>:
    buf[13] = 0x14;
    9a46:	f2 40 14 00 	mov.b	#20,	&0x529f	;#0x0014
    9a4a:	9f 52 

00009a4c <.Loc.747.1>:
    buf[14] = 0xBB;
    9a4c:	f2 40 bb ff 	mov.b	#65467,	&0x52a0	;#0xffbb
    9a50:	a0 52 

00009a52 <.Loc.748.1>:
    if (!crcCheckSDLP(buf, 15)) {
    9a52:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    9a56:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9a5a:	b0 12 ae 82 	call	#33454		;#0x82ae
    9a5e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9a62:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9a64:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9a68:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a6a:	0f 24       	jz	$+32     	;abs 0x9a8a

00009a6c <.Loc.749.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9a6c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9a70:	2a 4c       	mov	@r12,	r10	;
    9a72:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9a76:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9a7a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9a7e:	0e 4c       	mov	r12,	r14	;
    9a80:	0d 49       	mov	r9,	r13	;
    9a82:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9a86:	8a 12       	call	r10		;
    9a88:	0e 3c       	jmp	$+30     	;abs 0x9aa6

00009a8a <.L115>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9a8a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9a8e:	2a 4c       	mov	@r12,	r10	;
    9a90:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9a94:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9a98:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9a9c:	0e 4c       	mov	r12,	r14	;
    9a9e:	0d 49       	mov	r9,	r13	;
    9aa0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9aa4:	8a 12       	call	r10		;

00009aa6 <.L116>:
    }
    buf[0] = 0x00;
    9aa6:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009aaa <.Loc.755.1>:
    buf[1] = 0x1B;
    9aaa:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9aae:	93 52 

00009ab0 <.Loc.756.1>:
    buf[2] = 0x00;
    9ab0:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009ab4 <.Loc.757.1>:
    buf[3] = 0x0F;
    9ab4:	f2 40 0f 00 	mov.b	#15,	&0x5295	;#0x000f
    9ab8:	95 52 

00009aba <.Loc.758.1>:
    buf[4] = 0x07;
    9aba:	f2 40 07 00 	mov.b	#7,	&0x5296	;
    9abe:	96 52 

00009ac0 <.Loc.759.1>:
    buf[5] = 0x01;
    9ac0:	d2 43 97 52 	mov.b	#1,	&0x5297	;r3 As==01

00009ac4 <.Loc.760.1>:
    buf[6] = 0x02;
    9ac4:	e2 43 98 52 	mov.b	#2,	&0x5298	;r3 As==10

00009ac8 <.Loc.761.1>:
    buf[7] = 0x03;
    9ac8:	f2 40 03 00 	mov.b	#3,	&0x5299	;
    9acc:	99 52 

00009ace <.Loc.762.1>:
    buf[8] = 0x04;
    9ace:	e2 42 9a 52 	mov.b	#4,	&0x529a	;r2 As==10

00009ad2 <.Loc.763.1>:
    buf[9] = 0x05;
    9ad2:	f2 40 05 00 	mov.b	#5,	&0x529b	;
    9ad6:	9b 52 

00009ad8 <.Loc.764.1>:
    buf[10] = 0x06;
    9ad8:	f2 40 06 00 	mov.b	#6,	&0x529c	;
    9adc:	9c 52 

00009ade <.Loc.765.1>:
    buf[11] = 0x07;
    9ade:	f2 40 07 00 	mov.b	#7,	&0x529d	;
    9ae2:	9d 52 

00009ae4 <.Loc.766.1>:
    buf[12] = 0x08;
    9ae4:	f2 42 9e 52 	mov.b	#8,	&0x529e	;r2 As==11

00009ae8 <.Loc.767.1>:
    buf[13] = 0x09;
    9ae8:	f2 40 09 00 	mov.b	#9,	&0x529f	;
    9aec:	9f 52 

00009aee <.Loc.768.1>:
    buf[14] = 0xCF;
    9aee:	f2 40 cf ff 	mov.b	#65487,	&0x52a0	;#0xffcf
    9af2:	a0 52 

00009af4 <.Loc.769.1>:
    buf[15] = 0x90;
    9af4:	f2 40 90 ff 	mov.b	#65424,	&0x52a1	;#0xff90
    9af8:	a1 52 

00009afa <.Loc.770.1>:
    if (!crcCheckSDLP(buf, 16)) {
    9afa:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    9afe:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9b02:	b0 12 ae 82 	call	#33454		;#0x82ae
    9b06:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9b0a:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9b0c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9b10:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b12:	0f 24       	jz	$+32     	;abs 0x9b32

00009b14 <.Loc.771.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9b14:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9b18:	2a 4c       	mov	@r12,	r10	;
    9b1a:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9b1e:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9b22:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9b26:	0e 4c       	mov	r12,	r14	;
    9b28:	0d 49       	mov	r9,	r13	;
    9b2a:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9b2e:	8a 12       	call	r10		;
    9b30:	0e 3c       	jmp	$+30     	;abs 0x9b4e

00009b32 <.L117>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9b32:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9b36:	2a 4c       	mov	@r12,	r10	;
    9b38:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9b3c:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9b40:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9b44:	0e 4c       	mov	r12,	r14	;
    9b46:	0d 49       	mov	r9,	r13	;
    9b48:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9b4c:	8a 12       	call	r10		;

00009b4e <.L118>:
    }
    buf[0] = 0x00;
    9b4e:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009b52 <.Loc.777.1>:
    buf[1] = 0x1B;
    9b52:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9b56:	93 52 

00009b58 <.Loc.778.1>:
    buf[2] = 0x00;
    9b58:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009b5c <.Loc.779.1>:
    buf[3] = 0x11;
    9b5c:	f2 40 11 00 	mov.b	#17,	&0x5295	;#0x0011
    9b60:	95 52 

00009b62 <.Loc.780.1>:
    buf[4] = 0x00;
    9b62:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009b66 <.Loc.781.1>:
    buf[5] = 0xC0;
    9b66:	f2 40 c0 ff 	mov.b	#65472,	&0x5297	;#0xffc0
    9b6a:	97 52 

00009b6c <.Loc.782.1>:
    buf[6] = 0x10;
    9b6c:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    9b70:	98 52 

00009b72 <.Loc.783.1>:
    buf[7] = 0x00;
    9b72:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009b76 <.Loc.784.1>:
    buf[8] = 0xC0;
    9b76:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    9b7a:	9a 52 

00009b7c <.Loc.785.1>:
    buf[9] = 0x00;
    9b7c:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

00009b80 <.Loc.786.1>:
    buf[10] = 0x00;
    9b80:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

00009b84 <.Loc.787.1>:
    buf[11] = 0x03;
    9b84:	f2 40 03 00 	mov.b	#3,	&0x529d	;
    9b88:	9d 52 

00009b8a <.Loc.788.1>:
    buf[12] = 0x2E;
    9b8a:	f2 40 2e 00 	mov.b	#46,	&0x529e	;#0x002e
    9b8e:	9e 52 

00009b90 <.Loc.789.1>:
    buf[13] = 0xAF;
    9b90:	f2 40 af ff 	mov.b	#65455,	&0x529f	;#0xffaf
    9b94:	9f 52 

00009b96 <.Loc.790.1>:
    buf[14] = 0x8A;
    9b96:	f2 40 8a ff 	mov.b	#65418,	&0x52a0	;#0xff8a
    9b9a:	a0 52 

00009b9c <.Loc.791.1>:
    buf[15] = 0x06;
    9b9c:	f2 40 06 00 	mov.b	#6,	&0x52a1	;
    9ba0:	a1 52 

00009ba2 <.Loc.792.1>:
    buf[16] = 0x9F;
    9ba2:	f2 40 9f ff 	mov.b	#65439,	&0x52a2	;#0xff9f
    9ba6:	a2 52 

00009ba8 <.Loc.793.1>:
    buf[17] = 0x71;
    9ba8:	f2 40 71 00 	mov.b	#113,	&0x52a3	;#0x0071
    9bac:	a3 52 

00009bae <.Loc.794.1>:
    if (!crcCheckSDLP(buf, 18)) {
    9bae:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    9bb2:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9bb6:	b0 12 ae 82 	call	#33454		;#0x82ae
    9bba:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9bbe:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9bc0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9bc4:	0c 93       	cmp	#0,	r12	;r3 As==00
    9bc6:	0f 24       	jz	$+32     	;abs 0x9be6

00009bc8 <.Loc.795.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9bc8:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9bcc:	2a 4c       	mov	@r12,	r10	;
    9bce:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9bd2:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9bd6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9bda:	0e 4c       	mov	r12,	r14	;
    9bdc:	0d 49       	mov	r9,	r13	;
    9bde:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9be2:	8a 12       	call	r10		;
    9be4:	0e 3c       	jmp	$+30     	;abs 0x9c02

00009be6 <.L119>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9be6:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9bea:	2a 4c       	mov	@r12,	r10	;
    9bec:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9bf0:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9bf4:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9bf8:	0e 4c       	mov	r12,	r14	;
    9bfa:	0d 49       	mov	r9,	r13	;
    9bfc:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9c00:	8a 12       	call	r10		;

00009c02 <.L120>:
    }
    buf[0] = 0x00;
    9c02:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009c06 <.Loc.801.1>:
    buf[1] = 0x1B;
    9c06:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9c0a:	93 52 

00009c0c <.Loc.802.1>:
    buf[2] = 0x00;
    9c0c:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009c10 <.Loc.803.1>:
    buf[3] = 0x12;
    9c10:	f2 40 12 00 	mov.b	#18,	&0x5295	;#0x0012
    9c14:	95 52 

00009c16 <.Loc.804.1>:
    buf[4] = 0x00;
    9c16:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009c1a <.Loc.805.1>:
    buf[5] = 0xC1;
    9c1a:	f2 40 c1 ff 	mov.b	#65473,	&0x5297	;#0xffc1
    9c1e:	97 52 

00009c20 <.Loc.806.1>:
    buf[6] = 0x10;
    9c20:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    9c24:	98 52 

00009c26 <.Loc.807.1>:
    buf[7] = 0x00;
    9c26:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009c2a <.Loc.808.1>:
    buf[8] = 0xFF;
    9c2a:	f2 43 9a 52 	mov.b	#-1,	&0x529a	;r3 As==11

00009c2e <.Loc.809.1>:
    buf[9] = 0xFF;
    9c2e:	f2 43 9b 52 	mov.b	#-1,	&0x529b	;r3 As==11

00009c32 <.Loc.810.1>:
    buf[10] = 0x00;
    9c32:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

00009c36 <.Loc.811.1>:
    buf[11] = 0x04;
    9c36:	e2 42 9d 52 	mov.b	#4,	&0x529d	;r2 As==10

00009c3a <.Loc.812.1>:
    buf[12] = 0x01;
    9c3a:	d2 43 9e 52 	mov.b	#1,	&0x529e	;r3 As==01

00009c3e <.Loc.813.1>:
    buf[13] = 0x02;
    9c3e:	e2 43 9f 52 	mov.b	#2,	&0x529f	;r3 As==10

00009c42 <.Loc.814.1>:
    buf[14] = 0x03;
    9c42:	f2 40 03 00 	mov.b	#3,	&0x52a0	;
    9c46:	a0 52 

00009c48 <.Loc.815.1>:
    buf[15] = 0x11;
    9c48:	f2 40 11 00 	mov.b	#17,	&0x52a1	;#0x0011
    9c4c:	a1 52 

00009c4e <.Loc.816.1>:
    buf[16] = 0x82;
    9c4e:	f2 40 82 ff 	mov.b	#65410,	&0x52a2	;#0xff82
    9c52:	a2 52 

00009c54 <.Loc.817.1>:
    buf[17] = 0x8D;
    9c54:	f2 40 8d ff 	mov.b	#65421,	&0x52a3	;#0xff8d
    9c58:	a3 52 

00009c5a <.Loc.818.1>:
    buf[18] = 0x80;
    9c5a:	f2 40 80 ff 	mov.b	#65408,	&0x52a4	;#0xff80
    9c5e:	a4 52 

00009c60 <.Loc.819.1>:
    if (!crcCheckSDLP(buf, 19)) {
    9c60:	7d 40 13 00 	mov.b	#19,	r13	;#0x0013
    9c64:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9c68:	b0 12 ae 82 	call	#33454		;#0x82ae
    9c6c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9c70:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9c72:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9c76:	0c 93       	cmp	#0,	r12	;r3 As==00
    9c78:	0f 24       	jz	$+32     	;abs 0x9c98

00009c7a <.Loc.820.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9c7a:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9c7e:	2a 4c       	mov	@r12,	r10	;
    9c80:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9c84:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9c88:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9c8c:	0e 4c       	mov	r12,	r14	;
    9c8e:	0d 49       	mov	r9,	r13	;
    9c90:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9c94:	8a 12       	call	r10		;
    9c96:	0e 3c       	jmp	$+30     	;abs 0x9cb4

00009c98 <.L121>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9c98:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9c9c:	2a 4c       	mov	@r12,	r10	;
    9c9e:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9ca2:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9ca6:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9caa:	0e 4c       	mov	r12,	r14	;
    9cac:	0d 49       	mov	r9,	r13	;
    9cae:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9cb2:	8a 12       	call	r10		;

00009cb4 <.L122>:
    }
    buf[0] = 0x00;
    9cb4:	c2 43 92 52 	mov.b	#0,	&0x5292	;r3 As==00

00009cb8 <.Loc.826.1>:
    buf[1] = 0x1B;
    9cb8:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9cbc:	93 52 

00009cbe <.Loc.827.1>:
    buf[2] = 0x00;
    9cbe:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009cc2 <.Loc.828.1>:
    buf[3] = 0x12;
    9cc2:	f2 40 12 00 	mov.b	#18,	&0x5295	;#0x0012
    9cc6:	95 52 

00009cc8 <.Loc.829.1>:
    buf[4] = 0x00;
    9cc8:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009ccc <.Loc.830.1>:
    buf[5] = 0xC1;
    9ccc:	f2 40 c1 ff 	mov.b	#65473,	&0x5297	;#0xffc1
    9cd0:	97 52 

00009cd2 <.Loc.831.1>:
    buf[6] = 0x11;
    9cd2:	f2 40 11 00 	mov.b	#17,	&0x5298	;#0x0011
    9cd6:	98 52 

00009cd8 <.Loc.832.1>:
    buf[7] = 0x04;
    9cd8:	e2 42 99 52 	mov.b	#4,	&0x5299	;r2 As==10

00009cdc <.Loc.833.1>:
    buf[8] = 0xC0;
    9cdc:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    9ce0:	9a 52 

00009ce2 <.Loc.834.1>:
    buf[9] = 0x00;
    9ce2:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

00009ce6 <.Loc.835.1>:
    buf[10] = 0x00;
    9ce6:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

00009cea <.Loc.836.1>:
    buf[11] = 0x04;
    9cea:	e2 42 9d 52 	mov.b	#4,	&0x529d	;r2 As==10

00009cee <.Loc.837.1>:
    buf[12] = 0x01;
    9cee:	d2 43 9e 52 	mov.b	#1,	&0x529e	;r3 As==01

00009cf2 <.Loc.838.1>:
    buf[13] = 0x02;
    9cf2:	e2 43 9f 52 	mov.b	#2,	&0x529f	;r3 As==10

00009cf6 <.Loc.839.1>:
    buf[14] = 0x03;
    9cf6:	f2 40 03 00 	mov.b	#3,	&0x52a0	;
    9cfa:	a0 52 

00009cfc <.Loc.840.1>:
    buf[15] = 0x72;
    9cfc:	f2 40 72 00 	mov.b	#114,	&0x52a1	;#0x0072
    9d00:	a1 52 

00009d02 <.Loc.841.1>:
    buf[16] = 0x17;
    9d02:	f2 40 17 00 	mov.b	#23,	&0x52a2	;#0x0017
    9d06:	a2 52 

00009d08 <.Loc.842.1>:
    buf[17] = 0x8D;
    9d08:	f2 40 8d ff 	mov.b	#65421,	&0x52a3	;#0xff8d
    9d0c:	a3 52 

00009d0e <.Loc.843.1>:
    buf[18] = 0x80;
    9d0e:	f2 40 80 ff 	mov.b	#65408,	&0x52a4	;#0xff80
    9d12:	a4 52 

00009d14 <.Loc.844.1>:
    if (!crcCheckSDLP(buf, 19)) {
    9d14:	7d 40 13 00 	mov.b	#19,	r13	;#0x0013
    9d18:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9d1c:	b0 12 ae 82 	call	#33454		;#0x82ae
    9d20:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9d24:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9d26:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9d2a:	0c 93       	cmp	#0,	r12	;r3 As==00
    9d2c:	0f 24       	jz	$+32     	;abs 0x9d4c

00009d2e <.Loc.845.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9d2e:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9d32:	2a 4c       	mov	@r12,	r10	;
    9d34:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9d38:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9d3c:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9d40:	0e 4c       	mov	r12,	r14	;
    9d42:	0d 49       	mov	r9,	r13	;
    9d44:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9d48:	8a 12       	call	r10		;
    9d4a:	0e 3c       	jmp	$+30     	;abs 0x9d68

00009d4c <.L123>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9d4c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9d50:	2a 4c       	mov	@r12,	r10	;
    9d52:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9d56:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9d5a:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9d5e:	0e 4c       	mov	r12,	r14	;
    9d60:	0d 49       	mov	r9,	r13	;
    9d62:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9d66:	8a 12       	call	r10		;

00009d68 <.L124>:
    }
    buf[0] = 0x20;
    9d68:	f2 40 20 00 	mov.b	#32,	&0x5292	;#0x0020
    9d6c:	92 52 

00009d6e <.Loc.851.1>:
    buf[1] = 0x1B;
    9d6e:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9d72:	93 52 

00009d74 <.Loc.852.1>:
    buf[2] = 0x00;
    9d74:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009d78 <.Loc.853.1>:
    buf[3] = 0x07;
    9d78:	f2 40 07 00 	mov.b	#7,	&0x5295	;
    9d7c:	95 52 

00009d7e <.Loc.854.1>:
    buf[4] = 0x00;
    9d7e:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009d82 <.Loc.855.1>:
    buf[5] = 0xE1;
    9d82:	f2 40 e1 ff 	mov.b	#65505,	&0x5297	;#0xffe1
    9d86:	97 52 

00009d88 <.Loc.856.1>:
    buf[6] = 0xBB;
    9d88:	f2 40 bb ff 	mov.b	#65467,	&0x5298	;#0xffbb
    9d8c:	98 52 

00009d8e <.Loc.857.1>:
    buf[7] = 0x22;
    9d8e:	f2 40 22 00 	mov.b	#34,	&0x5299	;#0x0022
    9d92:	99 52 

00009d94 <.Loc.858.1>:
    if (!crcCheckSDLP(buf, 8)) {
    9d94:	7d 42       	mov.b	#8,	r13	;r2 As==11
    9d96:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9d9a:	b0 12 ae 82 	call	#33454		;#0x82ae
    9d9e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9da2:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9da4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9da8:	0c 93       	cmp	#0,	r12	;r3 As==00
    9daa:	0f 24       	jz	$+32     	;abs 0x9dca

00009dac <.Loc.859.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9dac:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9db0:	2a 4c       	mov	@r12,	r10	;
    9db2:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9db6:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9dba:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9dbe:	0e 4c       	mov	r12,	r14	;
    9dc0:	0d 49       	mov	r9,	r13	;
    9dc2:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9dc6:	8a 12       	call	r10		;
    9dc8:	0e 3c       	jmp	$+30     	;abs 0x9de6

00009dca <.L125>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9dca:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9dce:	2a 4c       	mov	@r12,	r10	;
    9dd0:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9dd4:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9dd8:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9ddc:	0e 4c       	mov	r12,	r14	;
    9dde:	0d 49       	mov	r9,	r13	;
    9de0:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9de4:	8a 12       	call	r10		;

00009de6 <.L126>:
    }
    buf[0] = 0x20;
    9de6:	f2 40 20 00 	mov.b	#32,	&0x5292	;#0x0020
    9dea:	92 52 

00009dec <.Loc.865.1>:
    buf[1] = 0x1B;
    9dec:	f2 40 1b 00 	mov.b	#27,	&0x5293	;#0x001b
    9df0:	93 52 

00009df2 <.Loc.866.1>:
    buf[2] = 0x00;
    9df2:	c2 43 94 52 	mov.b	#0,	&0x5294	;r3 As==00

00009df6 <.Loc.867.1>:
    buf[3] = 0x11;
    9df6:	f2 40 11 00 	mov.b	#17,	&0x5295	;#0x0011
    9dfa:	95 52 

00009dfc <.Loc.868.1>:
    buf[4] = 0x00;
    9dfc:	c2 43 96 52 	mov.b	#0,	&0x5296	;r3 As==00

00009e00 <.Loc.869.1>:
    buf[5] = 0xC0;
    9e00:	f2 40 c0 ff 	mov.b	#65472,	&0x5297	;#0xffc0
    9e04:	97 52 

00009e06 <.Loc.870.1>:
    buf[6] = 0x10;
    9e06:	f2 40 10 00 	mov.b	#16,	&0x5298	;#0x0010
    9e0a:	98 52 

00009e0c <.Loc.871.1>:
    buf[7] = 0x00;
    9e0c:	c2 43 99 52 	mov.b	#0,	&0x5299	;r3 As==00

00009e10 <.Loc.872.1>:
    buf[8] = 0xC0;
    9e10:	f2 40 c0 ff 	mov.b	#65472,	&0x529a	;#0xffc0
    9e14:	9a 52 

00009e16 <.Loc.873.1>:
    buf[9] = 0x00;
    9e16:	c2 43 9b 52 	mov.b	#0,	&0x529b	;r3 As==00

00009e1a <.Loc.874.1>:
    buf[10] = 0x00;
    9e1a:	c2 43 9c 52 	mov.b	#0,	&0x529c	;r3 As==00

00009e1e <.Loc.875.1>:
    buf[11] = 0x03;
    9e1e:	f2 40 03 00 	mov.b	#3,	&0x529d	;
    9e22:	9d 52 

00009e24 <.Loc.876.1>:
    buf[12] = 0x2E;
    9e24:	f2 40 2e 00 	mov.b	#46,	&0x529e	;#0x002e
    9e28:	9e 52 

00009e2a <.Loc.877.1>:
    buf[13] = 0xAF;
    9e2a:	f2 40 af ff 	mov.b	#65455,	&0x529f	;#0xffaf
    9e2e:	9f 52 

00009e30 <.Loc.878.1>:
    buf[14] = 0x8A;
    9e30:	f2 40 8a ff 	mov.b	#65418,	&0x52a0	;#0xff8a
    9e34:	a0 52 

00009e36 <.Loc.879.1>:
    buf[15] = 0x06;
    9e36:	f2 40 06 00 	mov.b	#6,	&0x52a1	;
    9e3a:	a1 52 

00009e3c <.Loc.880.1>:
    buf[16] = 0xD9;
    9e3c:	f2 40 d9 ff 	mov.b	#65497,	&0x52a2	;#0xffd9
    9e40:	a2 52 

00009e42 <.Loc.881.1>:
    buf[17] = 0x65;
    9e42:	f2 40 65 00 	mov.b	#101,	&0x52a3	;#0x0065
    9e46:	a3 52 

00009e48 <.Loc.882.1>:
    if (!crcCheckSDLP(buf, 18)) {
    9e48:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    9e4c:	3c 40 92 52 	mov	#21138,	r12	;#0x5292
    9e50:	b0 12 ae 82 	call	#33454		;#0x82ae
    9e54:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9e58:	5c e3       	xor.b	#1,	r12	;r3 As==01
    9e5a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9e5e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9e60:	0f 24       	jz	$+32     	;abs 0x9e80

00009e62 <.Loc.883.1>:
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    9e62:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9e66:	2a 4c       	mov	@r12,	r10	;
    9e68:	19 42 9a 51 	mov	&0x519a,r9	;0x519a
    9e6c:	1c 42 9a 51 	mov	&0x519a,r12	;0x519a
    9e70:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9e74:	0e 4c       	mov	r12,	r14	;
    9e76:	0d 49       	mov	r9,	r13	;
    9e78:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9e7c:	8a 12       	call	r10		;
    9e7e:	0e 3c       	jmp	$+30     	;abs 0x9e9c

00009e80 <.L127>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    9e80:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9e84:	2a 4c       	mov	@r12,	r10	;
    9e86:	19 42 98 51 	mov	&0x5198,r9	;0x5198
    9e8a:	1c 42 98 51 	mov	&0x5198,r12	;0x5198
    9e8e:	b0 12 a6 a0 	call	#41126		;#0xa0a6
    9e92:	0e 4c       	mov	r12,	r14	;
    9e94:	0d 49       	mov	r9,	r13	;
    9e96:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9e9a:	8a 12       	call	r10		;

00009e9c <.L3>:
  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);

  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    9e9c:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    9ea0:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    9ea4:	4d 43       	clr.b	r13		;
    9ea6:	3c 40 ce 51 	mov	#20942,	r12	;#0x51ce
    9eaa:	8e 12       	call	r14		;
    9eac:	0c 93       	cmp	#0,	r12	;r3 As==00
    9eae:	02 24       	jz	$+6      	;abs 0x9eb4
    9eb0:	80 00 be 83 	mova	#33726,	r0	;0x083be

00009eb4 <.Loc.890.1>:
    else {
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    }
    
  }
}
    9eb4:	03 43       	nop			
    9eb6:	21 53       	incd	r1		;

00009eb8 <L0>:
    9eb8:	19 17       	popm	#2,	r10	;16-bit words
    9eba:	30 41       	ret			

00009ebc <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    9ebc:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    9ec0:	5c 01 

00009ec2 <.Loc.914.1>:

  halInit();
    9ec2:	b0 12 b0 69 	call	#27056		;#0x69b0

00009ec6 <.Loc.915.1>:
  chSysInit();
    9ec6:	b0 12 66 65 	call	#25958		;#0x6566

00009eca <.Loc.916.1>:
  dmaInit();
    9eca:	b0 12 f2 7d 	call	#32242		;#0x7df2

00009ece <.L130>:

  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    9ece:	ff 3f       	jmp	$+0      	;abs 0x9ece

00009ed0 <udivmodsi4>:
    9ed0:	5a 15       	pushm	#6,	r10	;16-bit words

00009ed2 <L0>:
    9ed2:	0a 4c       	mov	r12,	r10	;
    9ed4:	0b 4d       	mov	r13,	r11	;

00009ed6 <.LVL1>:
    9ed6:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00009eda <.Loc.35.1>:
    9eda:	58 43       	mov.b	#1,	r8	;r3 As==01
    9edc:	49 43       	clr.b	r9		;

00009ede <.Loc.38.1>:
    9ede:	07 4b       	mov	r11,	r7	;

00009ee0 <.L2>:
    9ee0:	0f 9b       	cmp	r11,	r15	;
    9ee2:	11 28       	jnc	$+36     	;abs 0x9f06
    9ee4:	07 9f       	cmp	r15,	r7	;
    9ee6:	02 20       	jnz	$+6      	;abs 0x9eec
    9ee8:	0e 9a       	cmp	r10,	r14	;
    9eea:	0d 28       	jnc	$+28     	;abs 0x9f06

00009eec <.L20>:
    9eec:	4c 43       	clr.b	r12		;

00009eee <.LVL3>:
    9eee:	0d 4c       	mov	r12,	r13	;

00009ef0 <.L5>:
    9ef0:	07 48       	mov	r8,	r7	;
    9ef2:	07 d9       	bis	r9,	r7	;
    9ef4:	07 93       	cmp	#0,	r7	;r3 As==00
    9ef6:	19 20       	jnz	$+52     	;abs 0x9f2a

00009ef8 <.L6>:
    9ef8:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    9efc:	02 24       	jz	$+6      	;abs 0x9f02
    9efe:	0c 4a       	mov	r10,	r12	;
    9f00:	0d 4b       	mov	r11,	r13	;

00009f02 <.L1>:
    9f02:	55 17       	popm	#6,	r10	;16-bit words
    9f04:	30 41       	ret			

00009f06 <.L3>:
    9f06:	3d 53       	add	#-1,	r13	;r3 As==11

00009f08 <.Loc.38.1>:
    9f08:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f0a:	20 24       	jz	$+66     	;abs 0x9f4c

00009f0c <.Loc.38.1>:
    9f0c:	0f 93       	cmp	#0,	r15	;r3 As==00
    9f0e:	ee 3b       	jl	$-34     	;abs 0x9eec

00009f10 <.Loc.40.1>:
    9f10:	05 4e       	mov	r14,	r5	;
    9f12:	06 4f       	mov	r15,	r6	;
    9f14:	05 5e       	add	r14,	r5	;
    9f16:	06 6f       	addc	r15,	r6	;
    9f18:	0e 45       	mov	r5,	r14	;

00009f1a <.LVL7>:
    9f1a:	0f 46       	mov	r6,	r15	;

00009f1c <.LVL8>:
    9f1c:	05 48       	mov	r8,	r5	;
    9f1e:	06 49       	mov	r9,	r6	;
    9f20:	05 58       	add	r8,	r5	;
    9f22:	06 69       	addc	r9,	r6	;
    9f24:	08 45       	mov	r5,	r8	;

00009f26 <.LVL9>:
    9f26:	09 46       	mov	r6,	r9	;

00009f28 <.LVL10>:
    9f28:	db 3f       	jmp	$-72     	;abs 0x9ee0

00009f2a <.L12>:
    9f2a:	0b 9f       	cmp	r15,	r11	;
    9f2c:	08 28       	jnc	$+18     	;abs 0x9f3e
    9f2e:	0f 9b       	cmp	r11,	r15	;
    9f30:	02 20       	jnz	$+6      	;abs 0x9f36
    9f32:	0a 9e       	cmp	r14,	r10	;
    9f34:	04 28       	jnc	$+10     	;abs 0x9f3e

00009f36 <.L16>:
    9f36:	0a 8e       	sub	r14,	r10	;
    9f38:	0b 7f       	subc	r15,	r11	;

00009f3a <.Loc.48.1>:
    9f3a:	0c d8       	bis	r8,	r12	;

00009f3c <.LVL13>:
    9f3c:	0d d9       	bis	r9,	r13	;

00009f3e <.L10>:
    9f3e:	12 c3       	clrc			
    9f40:	09 10       	rrc	r9		;
    9f42:	08 10       	rrc	r8		;

00009f44 <.Loc.51.1>:
    9f44:	12 c3       	clrc			
    9f46:	0f 10       	rrc	r15		;
    9f48:	0e 10       	rrc	r14		;
    9f4a:	d2 3f       	jmp	$-90     	;abs 0x9ef0

00009f4c <.L14>:
    9f4c:	0c 4d       	mov	r13,	r12	;

00009f4e <.LVL18>:
    9f4e:	d4 3f       	jmp	$-86     	;abs 0x9ef8

00009f50 <__mspabi_divlu>:
    9f50:	21 83       	decd	r1		;

00009f52 <.LCFI5>:
    9f52:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00009f56 <L0>:
    9f56:	b0 12 d0 9e 	call	#40656		;#0x9ed0

00009f5a <.LVL46>:
    9f5a:	21 53       	incd	r1		;
    9f5c:	30 41       	ret			

00009f5e <__mspabi_slli_15>:
    9f5e:	0c 5c       	rla	r12		;

00009f60 <__mspabi_slli_14>:
    9f60:	0c 5c       	rla	r12		;

00009f62 <__mspabi_slli_13>:
    9f62:	0c 5c       	rla	r12		;

00009f64 <__mspabi_slli_12>:
    9f64:	0c 5c       	rla	r12		;

00009f66 <__mspabi_slli_11>:
    9f66:	0c 5c       	rla	r12		;

00009f68 <__mspabi_slli_10>:
    9f68:	0c 5c       	rla	r12		;

00009f6a <__mspabi_slli_9>:
    9f6a:	0c 5c       	rla	r12		;

00009f6c <__mspabi_slli_8>:
    9f6c:	0c 5c       	rla	r12		;

00009f6e <__mspabi_slli_7>:
    9f6e:	0c 5c       	rla	r12		;

00009f70 <__mspabi_slli_6>:
    9f70:	0c 5c       	rla	r12		;

00009f72 <__mspabi_slli_5>:
    9f72:	0c 5c       	rla	r12		;

00009f74 <__mspabi_slli_4>:
    9f74:	0c 5c       	rla	r12		;

00009f76 <__mspabi_slli_3>:
    9f76:	0c 5c       	rla	r12		;

00009f78 <__mspabi_slli_2>:
    9f78:	0c 5c       	rla	r12		;

00009f7a <__mspabi_slli_1>:
    9f7a:	0c 5c       	rla	r12		;
    9f7c:	30 41       	ret			

00009f7e <.L11>:
    9f7e:	3d 53       	add	#-1,	r13	;r3 As==11
    9f80:	0c 5c       	rla	r12		;

00009f82 <__mspabi_slli>:
    9f82:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f84:	fc 23       	jnz	$-6      	;abs 0x9f7e
    9f86:	30 41       	ret			

00009f88 <__mspabi_slll_15>:
    9f88:	0c 5c       	rla	r12		;
    9f8a:	0d 6d       	rlc	r13		;

00009f8c <__mspabi_slll_14>:
    9f8c:	0c 5c       	rla	r12		;
    9f8e:	0d 6d       	rlc	r13		;

00009f90 <__mspabi_slll_13>:
    9f90:	0c 5c       	rla	r12		;
    9f92:	0d 6d       	rlc	r13		;

00009f94 <__mspabi_slll_12>:
    9f94:	0c 5c       	rla	r12		;
    9f96:	0d 6d       	rlc	r13		;

00009f98 <__mspabi_slll_11>:
    9f98:	0c 5c       	rla	r12		;
    9f9a:	0d 6d       	rlc	r13		;

00009f9c <__mspabi_slll_10>:
    9f9c:	0c 5c       	rla	r12		;
    9f9e:	0d 6d       	rlc	r13		;

00009fa0 <__mspabi_slll_9>:
    9fa0:	0c 5c       	rla	r12		;
    9fa2:	0d 6d       	rlc	r13		;

00009fa4 <__mspabi_slll_8>:
    9fa4:	0c 5c       	rla	r12		;
    9fa6:	0d 6d       	rlc	r13		;

00009fa8 <__mspabi_slll_7>:
    9fa8:	0c 5c       	rla	r12		;
    9faa:	0d 6d       	rlc	r13		;

00009fac <__mspabi_slll_6>:
    9fac:	0c 5c       	rla	r12		;
    9fae:	0d 6d       	rlc	r13		;

00009fb0 <__mspabi_slll_5>:
    9fb0:	0c 5c       	rla	r12		;
    9fb2:	0d 6d       	rlc	r13		;

00009fb4 <__mspabi_slll_4>:
    9fb4:	0c 5c       	rla	r12		;
    9fb6:	0d 6d       	rlc	r13		;

00009fb8 <__mspabi_slll_3>:
    9fb8:	0c 5c       	rla	r12		;
    9fba:	0d 6d       	rlc	r13		;

00009fbc <__mspabi_slll_2>:
    9fbc:	0c 5c       	rla	r12		;
    9fbe:	0d 6d       	rlc	r13		;

00009fc0 <__mspabi_slll_1>:
    9fc0:	0c 5c       	rla	r12		;
    9fc2:	0d 6d       	rlc	r13		;
    9fc4:	30 41       	ret			

00009fc6 <.L12>:
    9fc6:	3e 53       	add	#-1,	r14	;r3 As==11
    9fc8:	0c 5c       	rla	r12		;
    9fca:	0d 6d       	rlc	r13		;

00009fcc <__mspabi_slll>:
    9fcc:	0e 93       	cmp	#0,	r14	;r3 As==00
    9fce:	fb 23       	jnz	$-8      	;abs 0x9fc6
    9fd0:	30 41       	ret			

00009fd2 <__mspabi_srli_15>:
    9fd2:	12 c3       	clrc			
    9fd4:	0c 10       	rrc	r12		;

00009fd6 <__mspabi_srli_14>:
    9fd6:	12 c3       	clrc			
    9fd8:	0c 10       	rrc	r12		;

00009fda <__mspabi_srli_13>:
    9fda:	12 c3       	clrc			
    9fdc:	0c 10       	rrc	r12		;

00009fde <__mspabi_srli_12>:
    9fde:	12 c3       	clrc			
    9fe0:	0c 10       	rrc	r12		;

00009fe2 <__mspabi_srli_11>:
    9fe2:	12 c3       	clrc			
    9fe4:	0c 10       	rrc	r12		;

00009fe6 <__mspabi_srli_10>:
    9fe6:	12 c3       	clrc			
    9fe8:	0c 10       	rrc	r12		;

00009fea <__mspabi_srli_9>:
    9fea:	12 c3       	clrc			
    9fec:	0c 10       	rrc	r12		;

00009fee <__mspabi_srli_8>:
    9fee:	12 c3       	clrc			
    9ff0:	0c 10       	rrc	r12		;

00009ff2 <__mspabi_srli_7>:
    9ff2:	12 c3       	clrc			
    9ff4:	0c 10       	rrc	r12		;

00009ff6 <__mspabi_srli_6>:
    9ff6:	12 c3       	clrc			
    9ff8:	0c 10       	rrc	r12		;

00009ffa <__mspabi_srli_5>:
    9ffa:	12 c3       	clrc			
    9ffc:	0c 10       	rrc	r12		;

00009ffe <__mspabi_srli_4>:
    9ffe:	12 c3       	clrc			
    a000:	0c 10       	rrc	r12		;

0000a002 <__mspabi_srli_3>:
    a002:	12 c3       	clrc			
    a004:	0c 10       	rrc	r12		;

0000a006 <__mspabi_srli_2>:
    a006:	12 c3       	clrc			
    a008:	0c 10       	rrc	r12		;

0000a00a <__mspabi_srli_1>:
    a00a:	12 c3       	clrc			
    a00c:	0c 10       	rrc	r12		;
    a00e:	30 41       	ret			

0000a010 <.L11>:
    a010:	3d 53       	add	#-1,	r13	;r3 As==11
    a012:	12 c3       	clrc			
    a014:	0c 10       	rrc	r12		;

0000a016 <__mspabi_srli>:
    a016:	0d 93       	cmp	#0,	r13	;r3 As==00
    a018:	fb 23       	jnz	$-8      	;abs 0xa010
    a01a:	30 41       	ret			

0000a01c <__mspabi_srll_15>:
    a01c:	12 c3       	clrc			
    a01e:	0d 10       	rrc	r13		;
    a020:	0c 10       	rrc	r12		;

0000a022 <__mspabi_srll_14>:
    a022:	12 c3       	clrc			
    a024:	0d 10       	rrc	r13		;
    a026:	0c 10       	rrc	r12		;

0000a028 <__mspabi_srll_13>:
    a028:	12 c3       	clrc			
    a02a:	0d 10       	rrc	r13		;
    a02c:	0c 10       	rrc	r12		;

0000a02e <__mspabi_srll_12>:
    a02e:	12 c3       	clrc			
    a030:	0d 10       	rrc	r13		;
    a032:	0c 10       	rrc	r12		;

0000a034 <__mspabi_srll_11>:
    a034:	12 c3       	clrc			
    a036:	0d 10       	rrc	r13		;
    a038:	0c 10       	rrc	r12		;

0000a03a <__mspabi_srll_10>:
    a03a:	12 c3       	clrc			
    a03c:	0d 10       	rrc	r13		;
    a03e:	0c 10       	rrc	r12		;

0000a040 <__mspabi_srll_9>:
    a040:	12 c3       	clrc			
    a042:	0d 10       	rrc	r13		;
    a044:	0c 10       	rrc	r12		;

0000a046 <__mspabi_srll_8>:
    a046:	12 c3       	clrc			
    a048:	0d 10       	rrc	r13		;
    a04a:	0c 10       	rrc	r12		;

0000a04c <__mspabi_srll_7>:
    a04c:	12 c3       	clrc			
    a04e:	0d 10       	rrc	r13		;
    a050:	0c 10       	rrc	r12		;

0000a052 <__mspabi_srll_6>:
    a052:	12 c3       	clrc			
    a054:	0d 10       	rrc	r13		;
    a056:	0c 10       	rrc	r12		;

0000a058 <__mspabi_srll_5>:
    a058:	12 c3       	clrc			
    a05a:	0d 10       	rrc	r13		;
    a05c:	0c 10       	rrc	r12		;

0000a05e <__mspabi_srll_4>:
    a05e:	12 c3       	clrc			
    a060:	0d 10       	rrc	r13		;
    a062:	0c 10       	rrc	r12		;

0000a064 <__mspabi_srll_3>:
    a064:	12 c3       	clrc			
    a066:	0d 10       	rrc	r13		;
    a068:	0c 10       	rrc	r12		;

0000a06a <__mspabi_srll_2>:
    a06a:	12 c3       	clrc			
    a06c:	0d 10       	rrc	r13		;
    a06e:	0c 10       	rrc	r12		;

0000a070 <__mspabi_srll_1>:
    a070:	12 c3       	clrc			
    a072:	0d 10       	rrc	r13		;
    a074:	0c 10       	rrc	r12		;
    a076:	30 41       	ret			

0000a078 <.L12>:
    a078:	3e 53       	add	#-1,	r14	;r3 As==11
    a07a:	12 c3       	clrc			
    a07c:	0d 10       	rrc	r13		;
    a07e:	0c 10       	rrc	r12		;

0000a080 <__mspabi_srll>:
    a080:	0e 93       	cmp	#0,	r14	;r3 As==00
    a082:	fa 23       	jnz	$-10     	;abs 0xa078
    a084:	30 41       	ret			

0000a086 <__mspabi_mpyl>:
    a086:	02 12       	push	r2		;
    a088:	32 c2       	dint			
    a08a:	03 43       	nop			
    a08c:	82 4c d0 04 	mov	r12,	&0x04d0	;
    a090:	82 4d d2 04 	mov	r13,	&0x04d2	;
    a094:	82 4e e0 04 	mov	r14,	&0x04e0	;
    a098:	82 4f e2 04 	mov	r15,	&0x04e2	;
    a09c:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    a0a0:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    a0a4:	00 13       	reti			

0000a0a6 <strlen>:
    a0a6:	0d 4c       	mov	r12,	r13	;

0000a0a8 <.L2>:
    a0a8:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    a0ac:	02 24       	jz	$+6      	;abs 0xa0b2

0000a0ae <.Loc.86.1>:
    a0ae:	1d 53       	inc	r13		;
    a0b0:	fb 3f       	jmp	$-8      	;abs 0xa0a8

0000a0b2 <.L5>:
    a0b2:	0d 8c       	sub	r12,	r13	;

0000a0b4 <.LVL4>:
    a0b4:	0c 4d       	mov	r13,	r12	;

0000a0b6 <.LVL5>:
    a0b6:	30 41       	ret			

0000a0b8 <memmove>:
    a0b8:	0b 4c       	mov	r12,	r11	;

0000a0ba <L0>:
    a0ba:	0b 5e       	add	r14,	r11	;

0000a0bc <.Loc.69.1>:
    a0bc:	0d 9c       	cmp	r12,	r13	;
    a0be:	02 28       	jnc	$+6      	;abs 0xa0c4

0000a0c0 <.L4>:
    a0c0:	0e 4c       	mov	r12,	r14	;

0000a0c2 <.LVL2>:
    a0c2:	0f 3c       	jmp	$+32     	;abs 0xa0e2

0000a0c4 <.L2>:
    a0c4:	0f 4d       	mov	r13,	r15	;
    a0c6:	0f 5e       	add	r14,	r15	;
    a0c8:	0c 9f       	cmp	r15,	r12	;
    a0ca:	fa 2f       	jc	$-10     	;abs 0xa0c0

0000a0cc <.LVL4>:
    a0cc:	0d 4f       	mov	r15,	r13	;

0000a0ce <.LVL5>:
    a0ce:	0e 8f       	sub	r15,	r14	;

0000a0d0 <.L5>:
    a0d0:	0f 4d       	mov	r13,	r15	;
    a0d2:	0f 5e       	add	r14,	r15	;
    a0d4:	0f 93       	cmp	#0,	r15	;r3 As==00
    a0d6:	0c 24       	jz	$+26     	;abs 0xa0f0

0000a0d8 <.Loc.76.1>:
    a0d8:	3b 53       	add	#-1,	r11	;r3 As==11
    a0da:	3d 53       	add	#-1,	r13	;r3 As==11

0000a0dc <.LVL8>:
    a0dc:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    a0e0:	f7 3f       	jmp	$-16     	;abs 0xa0d0

0000a0e2 <.L3>:
    a0e2:	0b 9e       	cmp	r14,	r11	;
    a0e4:	05 24       	jz	$+12     	;abs 0xa0f0

0000a0e6 <.LVL10>:
    a0e6:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    a0ea:	1e 53       	inc	r14		;

0000a0ec <.LVL11>:
    a0ec:	1d 53       	inc	r13		;
    a0ee:	f9 3f       	jmp	$-12     	;abs 0xa0e2

0000a0f0 <.L9>:
    a0f0:	30 41       	ret			

0000a0f2 <memset>:
    a0f2:	0f 4c       	mov	r12,	r15	;
    a0f4:	0e 5c       	add	r12,	r14	;

0000a0f6 <.L2>:
    a0f6:	0f 9e       	cmp	r14,	r15	;

0000a0f8 <L0>:
    a0f8:	04 24       	jz	$+10     	;abs 0xa102

0000a0fa <.LVL3>:
    a0fa:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    a0fe:	1f 53       	inc	r15		;

0000a100 <.LVL4>:
    a100:	fa 3f       	jmp	$-10     	;abs 0xa0f6

0000a102 <.L5>:
    a102:	30 41       	ret			
