
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	40 84       	sub.b	r4,	r0	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	42 84       	sub.b	r4,	r2	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	44 84       	sub.b	r4,	r4	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	46 84       	sub.b	r4,	r6	;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	48 84       	sub.b	r4,	r8	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	4a 84       	sub.b	r4,	r10	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	4c 84       	sub.b	r4,	r12	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	4e 84       	sub.b	r4,	r14	;

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	50 84 40 ca 	Address 0x000000000000ffa2 is out of bounds.
sub.b	-1(r4),	r0	;

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	52 84 40 ca 	Address 0x000000000000ffa4 is out of bounds.
sub.b	-1(r4),	r2	;

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	54 84 40 ca 	Address 0x000000000000ffa6 is out of bounds.
sub.b	-1(r4),	r4	;

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	56 84 40 ca 	Address 0x000000000000ffa8 is out of bounds.
sub.b	-1(r4),	r6	;

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	58 84 40 ca 	Address 0x000000000000ffaa is out of bounds.
sub.b	-1(r4),	r8	;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	5a 84 40 ca 	Address 0x000000000000ffac is out of bounds.
sub.b	-1(r4),	r10	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	5c 84 40 ca 	Address 0x000000000000ffae is out of bounds.
sub.b	-1(r4),	r12	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	5e 84 40 ca 	Address 0x000000000000ffb0 is out of bounds.
sub.b	-1(r4),	r14	;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	60 84       	sub.b	@r4,	r0	;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	62 84       	sub.b	@r4,	r2	;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	64 84       	sub.b	@r4,	r4	;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	66 84       	sub.b	@r4,	r6	;

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	68 84       	sub.b	@r4,	r8	;

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	6a 84       	sub.b	@r4,	r10	;

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	6c 84       	sub.b	@r4,	r12	;

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	6e 84       	sub.b	@r4,	r14	;

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	70 84       	sub.b	@r4+,	r0	;

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	72 84       	sub.b	@r4+,	r2	;

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	74 84       	sub.b	@r4+,	r4	;

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	76 84       	sub.b	@r4+,	r6	;

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	78 84       	sub.b	@r4+,	r8	;

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	7a 84       	sub.b	@r4+,	r10	;

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	7c 84       	sub.b	@r4+,	r12	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	7e 84       	sub.b	@r4+,	r14	;

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	48 75       	subc.b	r5,	r8	;

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	e4 74 40 ca 	Address 0x000000000000ffd4 is out of bounds.
subc.b	@r4,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	80 84 40 ca 	Address 0x000000000000ffd6 is out of bounds.
sub	r4,	0xffff	; PC rel. 0xffd5

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	82 84 40 ca 	Address 0x000000000000ffd8 is out of bounds.
sub	r4,	&0xffff	;

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	82 74 40 ca 	Address 0x000000000000ffda is out of bounds.
subc	r4,	&0xffff	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	84 84 40 ca 	Address 0x000000000000ffdc is out of bounds.
sub	r4,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	86 84 40 ca 	Address 0x000000000000ffde is out of bounds.
sub	r4,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	22 74       	subc	@r4,	r2	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	88 84       	interrupt service routine at 0x8488

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	8a 84       	interrupt service routine at 0x848a

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	ea 77       	interrupt service routine at 0x77ea

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	8c 84       	interrupt service routine at 0x848c

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	8e 84       	interrupt service routine at 0x848e

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	90 84       	interrupt service routine at 0x8490

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	5a 7f       	interrupt service routine at 0x7f5a

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	92 84       	interrupt service routine at 0x8492

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	d4 72       	interrupt service routine at 0x72d4

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	94 84       	interrupt service routine at 0x8494

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	96 84       	interrupt service routine at 0x8496

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	3c 6e       	interrupt service routine at 0x6e3c

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	98 84       	interrupt service routine at 0x8498

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	9a 84       	interrupt service routine at 0x849a

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	9c 84       	interrupt service routine at 0x849c

Disassembly of section .text:

00005c6a <__crt0_start>:
    5c6a:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00005c6e <__crt0_init_bss>:
    5c6e:	3c 40 4a 52 	mov	#21066,	r12	;#0x524a

00005c72 <.Loc.74.1>:
    5c72:	0d 43       	clr	r13		;

00005c74 <.Loc.75.1>:
    5c74:	3e 40 20 0a 	mov	#2592,	r14	;#0x0a20

00005c78 <.Loc.79.1>:
    5c78:	b0 12 ba 9c 	call	#40122		;#0x9cba

00005c7c <__crt0_movedata>:
    5c7c:	3c 40 50 51 	mov	#20816,	r12	;#0x5150

00005c80 <.Loc.116.1>:
    5c80:	3d 40 50 51 	mov	#20816,	r13	;#0x5150

00005c84 <.Loc.119.1>:
    5c84:	0d 9c       	cmp	r12,	r13	;

00005c86 <.Loc.120.1>:
    5c86:	04 24       	jz	$+10     	;abs 0x5c90

00005c88 <.Loc.122.1>:
    5c88:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa

00005c8c <.Loc.124.1>:
    5c8c:	b0 12 54 99 	call	#39252		;#0x9954

00005c90 <__crt0_call_just_main>:
    5c90:	0c 43       	clr	r12		;

00005c92 <.Loc.181.1>:
    5c92:	b0 12 88 89 	call	#35208		;#0x8988

00005c96 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    5c96:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00

00005c9a <.Loc.305.1>:
}
    5c9a:	03 43       	nop			
    5c9c:	30 41       	ret			

00005c9e <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
    5c9e:	21 83       	decd	r1		;

00005ca0 <.LBB2>:

  return __get_SR_register();
    5ca0:	0c 42       	mov	r2,	r12	;
    5ca2:	81 4c 00 00 	mov	r12,	0(r1)	;
    5ca6:	2c 41       	mov	@r1,	r12	;

00005ca8 <.LBE2>:
}
    5ca8:	21 53       	incd	r1		;
    5caa:	30 41       	ret			

00005cac <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
    5cac:	21 83       	decd	r1		;

00005cae <.LCFI1>:
    5cae:	81 4c 00 00 	mov	r12,	0(r1)	;

00005cb2 <.Loc.328.1>:

  return sts & GIE;
    5cb2:	2c 41       	mov	@r1,	r12	;
    5cb4:	7c f2       	and.b	#8,	r12	;r2 As==11
    5cb6:	0d 43       	clr	r13		;
    5cb8:	0d 8c       	sub	r12,	r13	;
    5cba:	0c dd       	bis	r13,	r12	;
    5cbc:	5c 03       	rrum	#1,	r12	;
    5cbe:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    5cc2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00005cc6 <.Loc.329.1>:
}
    5cc6:	21 53       	incd	r1		;
    5cc8:	30 41       	ret			

00005cca <port_is_isr_context>:
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
  return __msp430x_in_isr;
    5cca:	5c 42 7a 52 	mov.b	&0x527a,r12	;0x527a

00005cce <.Loc.340.1>:
}
    5cce:	30 41       	ret			

00005cd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    5cd0:	32 c2       	dint			

00005cd2 <.Loc.348.1>:
  asm volatile("nop");
    5cd2:	03 43       	nop			

00005cd4 <.Loc.349.1>:
}
    5cd4:	03 43       	nop			
    5cd6:	30 41       	ret			

00005cd8 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    5cd8:	03 43       	nop			

00005cda <.Loc.356.1>:
  _enable_interrupts();
    5cda:	32 d2       	eint			
    5cdc:	03 43       	nop			

00005cde <.Loc.357.1>:
}
    5cde:	03 43       	nop			
    5ce0:	30 41       	ret			

00005ce2 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    5ce2:	03 43       	nop			
    5ce4:	30 41       	ret			

00005ce6 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    5ce6:	03 43       	nop			
    5ce8:	30 41       	ret			

00005cea <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    5cea:	32 c2       	dint			

00005cec <.Loc.381.1>:
  asm volatile("nop");
    5cec:	03 43       	nop			

00005cee <.Loc.382.1>:
}
    5cee:	03 43       	nop			
    5cf0:	30 41       	ret			

00005cf2 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    5cf2:	32 c2       	dint			

00005cf4 <.Loc.390.1>:
  asm volatile("nop");
    5cf4:	03 43       	nop			

00005cf6 <.Loc.391.1>:
}
    5cf6:	03 43       	nop			
    5cf8:	30 41       	ret			

00005cfa <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5cfa:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5cfe:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d00:	04 20       	jnz	$+10     	;abs 0x5d0a

00005d02 <.Loc.79.2>:
    5d02:	1c 42 52 52 	mov	&0x5252,r12	;0x5252
    5d06:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d08:	04 24       	jz	$+10     	;abs 0x5d12

00005d0a <.L19>:
    chSysHalt("SV#2");
    5d0a:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    5d0e:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005d12 <.L21>:
  }
}
    5d12:	03 43       	nop			
    5d14:	30 41       	ret			

00005d16 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5d16:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5d1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d1c:	04 20       	jnz	$+10     	;abs 0x5d26

00005d1e <.Loc.103.2>:
    5d1e:	1c 42 52 52 	mov	&0x5252,r12	;0x5252
    5d22:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d24:	04 24       	jz	$+10     	;abs 0x5d2e

00005d26 <.L27>:
    chSysHalt("SV#4");
    5d26:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    5d2a:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005d2e <.L28>:
  }
  _dbg_enter_lock();
    5d2e:	92 43 52 52 	mov	#1,	&0x5252	;r3 As==01

00005d32 <.Loc.107.2>:
}
    5d32:	03 43       	nop			
    5d34:	30 41       	ret			

00005d36 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5d36:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5d3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d3c:	05 20       	jnz	$+12     	;abs 0x5d48

00005d3e <.Loc.116.2>:
    5d3e:	1d 42 52 52 	mov	&0x5252,r13	;0x5252
    5d42:	4c 43       	clr.b	r12		;
    5d44:	0c 9d       	cmp	r13,	r12	;
    5d46:	04 38       	jl	$+10     	;abs 0x5d50

00005d48 <.L30>:
    chSysHalt("SV#5");
    5d48:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    5d4c:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005d50 <.L31>:
  }
  _dbg_leave_lock();
    5d50:	82 43 52 52 	mov	#0,	&0x5252	;r3 As==00

00005d54 <.Loc.120.2>:
}
    5d54:	03 43       	nop			
    5d56:	30 41       	ret			

00005d58 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5d58:	1d 42 50 52 	mov	&0x5250,r13	;0x5250
    5d5c:	4c 43       	clr.b	r12		;
    5d5e:	0c 9d       	cmp	r13,	r12	;
    5d60:	04 34       	jge	$+10     	;abs 0x5d6a

00005d62 <.Loc.129.2>:
    5d62:	1c 42 52 52 	mov	&0x5252,r12	;0x5252
    5d66:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d68:	04 24       	jz	$+10     	;abs 0x5d72

00005d6a <.L33>:
    chSysHalt("SV#6");
    5d6a:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    5d6e:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005d72 <.L34>:
  }
  _dbg_enter_lock();
    5d72:	92 43 52 52 	mov	#1,	&0x5252	;r3 As==01

00005d76 <.Loc.133.2>:
}
    5d76:	03 43       	nop			
    5d78:	30 41       	ret			

00005d7a <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5d7a:	1d 42 50 52 	mov	&0x5250,r13	;0x5250
    5d7e:	4c 43       	clr.b	r12		;
    5d80:	0c 9d       	cmp	r13,	r12	;
    5d82:	05 34       	jge	$+12     	;abs 0x5d8e

00005d84 <.Loc.142.2>:
    5d84:	1d 42 52 52 	mov	&0x5252,r13	;0x5252
    5d88:	4c 43       	clr.b	r12		;
    5d8a:	0c 9d       	cmp	r13,	r12	;
    5d8c:	04 38       	jl	$+10     	;abs 0x5d96

00005d8e <.L36>:
    chSysHalt("SV#7");
    5d8e:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    5d92:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005d96 <.L37>:
  }
  _dbg_leave_lock();
    5d96:	82 43 52 52 	mov	#0,	&0x5252	;r3 As==00

00005d9a <.Loc.146.2>:
}
    5d9a:	03 43       	nop			
    5d9c:	30 41       	ret			

00005d9e <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    5d9e:	b0 12 e2 5c 	call	#23778		;#0x5ce2

00005da2 <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5da2:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5da6:	0c 93       	cmp	#0,	r12	;r3 As==00
    5da8:	04 38       	jl	$+10     	;abs 0x5db2

00005daa <.Loc.156.2>:
    5daa:	1c 42 52 52 	mov	&0x5252,r12	;0x5252
    5dae:	0c 93       	cmp	#0,	r12	;r3 As==00
    5db0:	04 24       	jz	$+10     	;abs 0x5dba

00005db2 <.L39>:
    chSysHalt("SV#8");
    5db2:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    5db6:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005dba <.L40>:
  }
  nil.isr_cnt++;
    5dba:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5dbe:	1c 53       	inc	r12		;
    5dc0:	82 4c 50 52 	mov	r12,	&0x5250	;

00005dc4 <.Loc.160.2>:
  port_unlock_from_isr();
    5dc4:	b0 12 e6 5c 	call	#23782		;#0x5ce6

00005dc8 <.Loc.161.2>:
}
    5dc8:	03 43       	nop			
    5dca:	30 41       	ret			

00005dcc <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    5dcc:	b0 12 e2 5c 	call	#23778		;#0x5ce2

00005dd0 <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5dd0:	1d 42 50 52 	mov	&0x5250,r13	;0x5250
    5dd4:	4c 43       	clr.b	r12		;
    5dd6:	0c 9d       	cmp	r13,	r12	;
    5dd8:	04 34       	jge	$+10     	;abs 0x5de2

00005dda <.Loc.171.2>:
    5dda:	1c 42 52 52 	mov	&0x5252,r12	;0x5252
    5dde:	0c 93       	cmp	#0,	r12	;r3 As==00
    5de0:	04 24       	jz	$+10     	;abs 0x5dea

00005de2 <.L42>:
    chSysHalt("SV#9");
    5de2:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    5de6:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005dea <.L43>:
  }
  nil.isr_cnt--;
    5dea:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5dee:	3c 53       	add	#-1,	r12	;r3 As==11
    5df0:	82 4c 50 52 	mov	r12,	&0x5250	;

00005df4 <.Loc.175.2>:
  port_unlock_from_isr();
    5df4:	b0 12 e6 5c 	call	#23782		;#0x5ce6

00005df8 <.Loc.176.2>:
}
    5df8:	03 43       	nop			
    5dfa:	30 41       	ret			

00005dfc <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5dfc:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5e00:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e02:	05 38       	jl	$+12     	;abs 0x5e0e

00005e04 <.Loc.188.2>:
    5e04:	1d 42 52 52 	mov	&0x5252,r13	;0x5252
    5e08:	4c 43       	clr.b	r12		;
    5e0a:	0c 9d       	cmp	r13,	r12	;
    5e0c:	04 38       	jl	$+10     	;abs 0x5e16

00005e0e <.L45>:
    chSysHalt("SV#10");
    5e0e:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    5e12:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005e16 <.L47>:
  }
}
    5e16:	03 43       	nop			
    5e18:	30 41       	ret			

00005e1a <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5e1a:	1c 42 50 52 	mov	&0x5250,r12	;0x5250
    5e1e:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e20:	05 20       	jnz	$+12     	;abs 0x5e2c

00005e22 <.Loc.203.2>:
    5e22:	1d 42 52 52 	mov	&0x5252,r13	;0x5252
    5e26:	4c 43       	clr.b	r12		;
    5e28:	0c 9d       	cmp	r13,	r12	;
    5e2a:	04 38       	jl	$+10     	;abs 0x5e34

00005e2c <.L49>:
    chSysHalt("SV#11");
    5e2c:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    5e30:	b0 12 f8 5e 	call	#24312		;#0x5ef8

00005e34 <.L51>:
  }
}
    5e34:	03 43       	nop			
    5e36:	30 41       	ret			

00005e38 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    5e38:	21 82       	sub	#4,	r1	;r2 As==10

00005e3a <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    5e3a:	82 43 50 52 	mov	#0,	&0x5250	;r3 As==00

00005e3e <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    5e3e:	82 43 52 52 	mov	#0,	&0x5252	;r3 As==00

00005e42 <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    5e42:	b1 40 56 52 	mov	#21078,	2(r1)	;#0x5256
    5e46:	02 00 

00005e48 <.Loc.234.2>:
  tcp = nil_thd_configs;
    5e48:	b1 40 96 50 	mov	#20630,	0(r1)	;#0x5096
    5e4c:	00 00 

00005e4e <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5e4e:	2d 3c       	jmp	$+92     	;abs 0x5eaa

00005e50 <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    5e50:	2c 41       	mov	@r1,	r12	;
    5e52:	2d 4c       	mov	@r12,	r13	;
    5e54:	1c 41 02 00 	mov	2(r1),	r12	;
    5e58:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00005e5c <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    5e5c:	2c 41       	mov	@r1,	r12	;
    5e5e:	1c 4c 02 00 	mov	2(r12),	r12	;
    5e62:	0d 4c       	mov	r12,	r13	;
    5e64:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    5e68:	1c 41 02 00 	mov	2(r1),	r12	;
    5e6c:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5e70:	1c 41 02 00 	mov	2(r1),	r12	;
    5e74:	2c 4c       	mov	@r12,	r12	;
    5e76:	2d 41       	mov	@r1,	r13	;
    5e78:	1d 4d 06 00 	mov	6(r13),	r13	;
    5e7c:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5e80:	1c 41 02 00 	mov	2(r1),	r12	;
    5e84:	2c 4c       	mov	@r12,	r12	;
    5e86:	2d 41       	mov	@r1,	r13	;
    5e88:	1d 4d 08 00 	mov	8(r13),	r13	;
    5e8c:	8c 4d 02 00 	mov	r13,	2(r12)	;
    5e90:	1c 41 02 00 	mov	2(r1),	r12	;
    5e94:	2c 4c       	mov	@r12,	r12	;
    5e96:	3d 40 a0 62 	mov	#25248,	r13	;#0x62a0
    5e9a:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00005e9e <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    5e9e:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    5ea2:	02 00 

00005ea4 <.Loc.247.2>:
    tcp++;
    5ea4:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    5ea8:	00 00 

00005eaa <.L53>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5eaa:	b1 90 62 52 	cmp	#21090,	2(r1)	;#0x5262
    5eae:	02 00 
    5eb0:	cf 2b       	jnc	$-96     	;abs 0x5e50

00005eb2 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    5eb2:	1c 41 02 00 	mov	2(r1),	r12	;
    5eb6:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    5eba:	0a 00 

00005ebc <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    5ebc:	b0 12 f2 5c 	call	#23794		;#0x5cf2
    5ec0:	b0 12 fa 5c 	call	#23802		;#0x5cfa

00005ec4 <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    5ec4:	92 43 52 52 	mov	#1,	&0x5252	;r3 As==01

00005ec8 <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    5ec8:	b0 12 72 62 	call	#25202		;#0x6272

00005ecc <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    5ecc:	b0 12 96 5c 	call	#23702		;#0x5c96

00005ed0 <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    5ed0:	b2 40 56 52 	mov	#21078,	&0x524c	;#0x5256
    5ed4:	4c 52 
    5ed6:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    5eda:	82 4c 4a 52 	mov	r12,	&0x524a	;

00005ede <.Loc.275.2>:
  port_switch(nil.current, tp);
    5ede:	1c 42 4a 52 	mov	&0x524a,r12	;0x524a
    5ee2:	1d 41 02 00 	mov	2(r1),	r13	;
    5ee6:	b0 12 92 62 	call	#25234		;#0x6292

00005eea <.Loc.276.2>:
  chSysUnlock();
    5eea:	b0 12 36 5d 	call	#23862		;#0x5d36
    5eee:	b0 12 d8 5c 	call	#23768		;#0x5cd8

00005ef2 <.Loc.277.2>:
}
    5ef2:	03 43       	nop			
    5ef4:	21 52       	add	#4,	r1	;r2 As==10
    5ef6:	30 41       	ret			

00005ef8 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    5ef8:	21 83       	decd	r1		;

00005efa <L0>:
    5efa:	81 4c 00 00 	mov	r12,	0(r1)	;

00005efe <.Loc.293.2>:

  port_disable();
    5efe:	b0 12 ea 5c 	call	#23786		;#0x5cea

00005f02 <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    5f02:	a2 41 54 52 	mov	@r1,	&0x5254	;

00005f06 <.L56>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    5f06:	ff 3f       	jmp	$+0      	;abs 0x5f06

00005f08 <chSysTimerHandlerI>:
    5f08:	21 83       	decd	r1		;

00005f0a <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    5f0a:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00005f0e <.Loc.320.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    5f0e:	b1 40 56 52 	mov	#21078,	0(r1)	;#0x5256
    5f12:	00 00 

00005f14 <.Loc.321.2>:
  nil.systime++;
    5f14:	1c 42 4e 52 	mov	&0x524e,r12	;0x524e
    5f18:	1c 53       	inc	r12		;
    5f1a:	82 4c 4e 52 	mov	r12,	&0x524e	;

00005f1e <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    5f1e:	2c 41       	mov	@r1,	r12	;
    5f20:	1c 4c 06 00 	mov	6(r12),	r12	;
    5f24:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f26:	25 24       	jz	$+76     	;abs 0x5f72

00005f28 <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    5f28:	2c 41       	mov	@r1,	r12	;
    5f2a:	1c 4c 06 00 	mov	6(r12),	r12	;
    5f2e:	3c 53       	add	#-1,	r12	;r3 As==11
    5f30:	2d 41       	mov	@r1,	r13	;
    5f32:	8d 4c 06 00 	mov	r12,	6(r13)	;
    5f36:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f38:	1c 20       	jnz	$+58     	;abs 0x5f72

00005f3a <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    5f3a:	2c 41       	mov	@r1,	r12	;
    5f3c:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5f40:	7c 90 03 00 	cmp.b	#3,	r12	;
    5f44:	08 20       	jnz	$+18     	;abs 0x5f56

00005f46 <.Loc.334.2>:
          tp->u1.semp->cnt++;
    5f46:	2c 41       	mov	@r1,	r12	;
    5f48:	1c 4c 04 00 	mov	4(r12),	r12	;
    5f4c:	2d 4c       	mov	@r12,	r13	;
    5f4e:	1d 53       	inc	r13		;
    5f50:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5f54:	0a 3c       	jmp	$+22     	;abs 0x5f6a

00005f56 <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    5f56:	2c 41       	mov	@r1,	r12	;
    5f58:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5f5c:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    5f5e:	05 20       	jnz	$+12     	;abs 0x5f6a

00005f60 <.Loc.337.2>:
          *tp->u1.trp = NULL;
    5f60:	2c 41       	mov	@r1,	r12	;
    5f62:	1c 4c 04 00 	mov	4(r12),	r12	;
    5f66:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005f6a <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    5f6a:	3d 43       	mov	#-1,	r13	;r3 As==11
    5f6c:	2c 41       	mov	@r1,	r12	;
    5f6e:	b0 12 0e 60 	call	#24590		;#0x600e

00005f72 <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    5f72:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    5f76:	b0 12 e6 5c 	call	#23782		;#0x5ce6

00005f7a <.Loc.346.2>:
    tp++;
    5f7a:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    5f7e:	00 00 

00005f80 <.Loc.347.2>:
    chSysLockFromISR();
    5f80:	b0 12 e2 5c 	call	#23778		;#0x5ce2
    5f84:	b0 12 58 5d 	call	#23896		;#0x5d58

00005f88 <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    5f88:	b1 90 62 52 	cmp	#21090,	0(r1)	;#0x5262
    5f8c:	00 00 
    5f8e:	c7 2b       	jnc	$-112    	;abs 0x5f1e

00005f90 <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    5f90:	03 43       	nop			
    5f92:	21 53       	incd	r1		;
    5f94:	30 41       	ret			

00005f96 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    5f96:	21 83       	decd	r1		;

00005f98 <L0>:

  syssts_t sts = port_get_irq_status();
    5f98:	b0 12 9e 5c 	call	#23710		;#0x5c9e
    5f9c:	81 4c 00 00 	mov	r12,	0(r1)	;

00005fa0 <.Loc.448.2>:
  if (port_irq_enabled(sts)) {
    5fa0:	2c 41       	mov	@r1,	r12	;
    5fa2:	b0 12 ac 5c 	call	#23724		;#0x5cac
    5fa6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5faa:	0c 93       	cmp	#0,	r12	;r3 As==00
    5fac:	0f 24       	jz	$+32     	;abs 0x5fcc

00005fae <.Loc.449.2>:
    if (port_is_isr_context()) {
    5fae:	b0 12 ca 5c 	call	#23754		;#0x5cca
    5fb2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5fb6:	0c 93       	cmp	#0,	r12	;r3 As==00
    5fb8:	05 24       	jz	$+12     	;abs 0x5fc4

00005fba <.Loc.450.2>:
      chSysLockFromISR();
    5fba:	b0 12 e2 5c 	call	#23778		;#0x5ce2
    5fbe:	b0 12 58 5d 	call	#23896		;#0x5d58
    5fc2:	04 3c       	jmp	$+10     	;abs 0x5fcc

00005fc4 <.L70>:
    }
    else {
      chSysLock();
    5fc4:	b0 12 d0 5c 	call	#23760		;#0x5cd0
    5fc8:	b0 12 16 5d 	call	#23830		;#0x5d16

00005fcc <.L69>:
    }
  }
  return sts;
    5fcc:	2c 41       	mov	@r1,	r12	;

00005fce <.Loc.457.2>:
}
    5fce:	21 53       	incd	r1		;
    5fd0:	30 41       	ret			

00005fd2 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
    5fd2:	21 83       	decd	r1		;

00005fd4 <L0>:
    5fd4:	81 4c 00 00 	mov	r12,	0(r1)	;

00005fd8 <.Loc.470.2>:

  if (port_irq_enabled(sts)) {
    5fd8:	2c 41       	mov	@r1,	r12	;
    5fda:	b0 12 ac 5c 	call	#23724		;#0x5cac
    5fde:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5fe2:	0c 93       	cmp	#0,	r12	;r3 As==00
    5fe4:	11 24       	jz	$+36     	;abs 0x6008

00005fe6 <.Loc.471.2>:
    if (port_is_isr_context()) {
    5fe6:	b0 12 ca 5c 	call	#23754		;#0x5cca
    5fea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5fee:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ff0:	05 24       	jz	$+12     	;abs 0x5ffc

00005ff2 <.Loc.472.2>:
      chSysUnlockFromISR();
    5ff2:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    5ff6:	b0 12 e6 5c 	call	#23782		;#0x5ce6

00005ffa <.Loc.479.2>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    5ffa:	06 3c       	jmp	$+14     	;abs 0x6008

00005ffc <.L74>:
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    5ffc:	b0 12 88 60 	call	#24712		;#0x6088

00006000 <.Loc.476.2>:
      chSysUnlock();
    6000:	b0 12 36 5d 	call	#23862		;#0x5d36
    6004:	b0 12 d8 5c 	call	#23768		;#0x5cd8

00006008 <.L75>:
    }
  }
}
    6008:	03 43       	nop			
    600a:	21 53       	incd	r1		;
    600c:	30 41       	ret			

0000600e <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    600e:	21 82       	sub	#4,	r1	;r2 As==10

00006010 <L0>:
    6010:	81 4c 02 00 	mov	r12,	2(r1)	;
    6014:	81 4d 00 00 	mov	r13,	0(r1)	;

00006018 <.Loc.535.2>:

  chDbgCheckClassI();
    6018:	b0 12 fc 5d 	call	#24060		;#0x5dfc

0000601c <.Loc.540.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    601c:	1c 41 02 00 	mov	2(r1),	r12	;
    6020:	ac 41 04 00 	mov	@r1,	4(r12)	;

00006024 <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    6024:	1c 41 02 00 	mov	2(r1),	r12	;
    6028:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

0000602c <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    602c:	1c 41 02 00 	mov	2(r1),	r12	;
    6030:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006034 <.Loc.543.2>:
  if (tp < nil.next) {
    6034:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    6038:	81 9c 02 00 	cmp	r12,	2(r1)	;
    603c:	03 2c       	jc	$+8      	;abs 0x6044

0000603e <.Loc.544.2>:
    nil.next = tp;
    603e:	92 41 02 00 	mov	2(r1),	&0x524c	;
    6042:	4c 52 

00006044 <.L77>:
  }
  return tp;
    6044:	1c 41 02 00 	mov	2(r1),	r12	;

00006048 <.Loc.547.2>:
}
    6048:	21 52       	add	#4,	r1	;r2 As==10
    604a:	30 41       	ret			

0000604c <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    604c:	1d 42 4a 52 	mov	&0x524a,r13	;0x524a
    6050:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    6054:	0c ed       	xor	r13,	r12	;
    6056:	0d 43       	clr	r13		;
    6058:	0d 8c       	sub	r12,	r13	;
    605a:	0c dd       	bis	r13,	r12	;
    605c:	5c 03       	rrum	#1,	r12	;
    605e:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    6062:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006066 <.Loc.565.2>:
}
    6066:	30 41       	ret			

00006068 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    6068:	21 83       	decd	r1		;

0000606a <.LCFI8>:
  thread_t *otp = nil.current;
    606a:	91 42 4a 52 	mov	&0x524a,0(r1)	;0x524a
    606e:	00 00 

00006070 <.Loc.577.2>:

  nil.current = nil.next;
    6070:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    6074:	82 4c 4a 52 	mov	r12,	&0x524a	;

00006078 <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    6078:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    607c:	2d 41       	mov	@r1,	r13	;
    607e:	b0 12 92 62 	call	#25234		;#0x6292

00006082 <.Loc.582.2>:
}
    6082:	03 43       	nop			
    6084:	21 53       	incd	r1		;
    6086:	30 41       	ret			

00006088 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    6088:	b0 12 1a 5e 	call	#24090		;#0x5e1a

0000608c <.Loc.593.2>:

  if (chSchIsRescRequiredI()) {
    608c:	1d 42 4a 52 	mov	&0x524a,r13	;0x524a
    6090:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    6094:	0d 9c       	cmp	r12,	r13	;
    6096:	02 24       	jz	$+6      	;abs 0x609c

00006098 <.Loc.594.2>:
    chSchDoReschedule();
    6098:	b0 12 68 60 	call	#24680		;#0x6068

0000609c <.L84>:
  }
}
    609c:	03 43       	nop			
    609e:	30 41       	ret			

000060a0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    60a0:	31 82       	sub	#8,	r1	;r2 As==11

000060a2 <.LCFI9>:
    60a2:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    60a6:	81 4d 00 00 	mov	r13,	0(r1)	;

000060aa <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    60aa:	91 42 4a 52 	mov	&0x524a,4(r1)	;0x524a
    60ae:	04 00 

000060b0 <.Loc.618.2>:

  chDbgCheckClassS();
    60b0:	b0 12 1a 5e 	call	#24090		;#0x5e1a

000060b4 <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    60b4:	1c 41 04 00 	mov	4(r1),	r12	;
    60b8:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    60bc:	02 00 

000060be <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    60be:	1c 41 04 00 	mov	4(r1),	r12	;
    60c2:	ac 41 06 00 	mov	@r1,	6(r12)	;

000060c6 <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    60c6:	b1 40 56 52 	mov	#21078,	6(r1)	;#0x5256
    60ca:	06 00 

000060cc <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    60cc:	1c 41 06 00 	mov	6(r1),	r12	;
    60d0:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    60d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    60d6:	12 20       	jnz	$+38     	;abs 0x60fc

000060d8 <.Loc.667.2>:
      nil.current = nil.next = ntp;
    60d8:	92 41 06 00 	mov	6(r1),	&0x524c	;
    60dc:	4c 52 
    60de:	1c 42 4c 52 	mov	&0x524c,r12	;0x524c
    60e2:	82 4c 4a 52 	mov	r12,	&0x524a	;

000060e6 <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    60e6:	1d 41 04 00 	mov	4(r1),	r13	;
    60ea:	1c 41 06 00 	mov	6(r1),	r12	;
    60ee:	b0 12 92 62 	call	#25234		;#0x6292

000060f2 <.Loc.672.2>:
      return nil.current->u1.msg;
    60f2:	1c 42 4a 52 	mov	&0x524a,r12	;0x524a
    60f6:	1c 4c 04 00 	mov	4(r12),	r12	;
    60fa:	04 3c       	jmp	$+10     	;abs 0x6104

000060fc <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    60fc:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    6100:	06 00 

00006102 <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    6102:	e4 3f       	jmp	$-54     	;abs 0x60cc

00006104 <.L89>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    6104:	31 52       	add	#8,	r1	;r2 As==11
    6106:	30 41       	ret			

00006108 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    6108:	31 80 06 00 	sub	#6,	r1	;

0000610c <L0>:
    610c:	81 4c 02 00 	mov	r12,	2(r1)	;
    6110:	81 4d 00 00 	mov	r13,	0(r1)	;

00006114 <.Loc.717.2>:

  if (*trp != NULL) {
    6114:	1c 41 02 00 	mov	2(r1),	r12	;
    6118:	2c 4c       	mov	@r12,	r12	;
    611a:	0c 93       	cmp	#0,	r12	;r3 As==00
    611c:	0d 24       	jz	$+28     	;abs 0x6138

0000611e <.LBB3>:
    thread_reference_t tr = *trp;
    611e:	1c 41 02 00 	mov	2(r1),	r12	;
    6122:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006126 <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    6126:	1c 41 02 00 	mov	2(r1),	r12	;
    612a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

0000612e <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    612e:	2d 41       	mov	@r1,	r13	;
    6130:	1c 41 04 00 	mov	4(r1),	r12	;
    6134:	b0 12 0e 60 	call	#24590		;#0x600e

00006138 <.L94>:
  }
}
    6138:	03 43       	nop			
    613a:	31 50 06 00 	add	#6,	r1	;
    613e:	30 41       	ret			

00006140 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    6140:	21 83       	decd	r1		;

00006142 <.LCFI12>:
    6142:	81 4c 00 00 	mov	r12,	0(r1)	;

00006146 <.Loc.736.2>:

  chSysLock();
    6146:	b0 12 d0 5c 	call	#23760		;#0x5cd0
    614a:	b0 12 16 5d 	call	#23830		;#0x5d16

0000614e <.Loc.737.2>:
  chThdSleepS(timeout);
    614e:	2d 41       	mov	@r1,	r13	;
    6150:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6152:	b0 12 a0 60 	call	#24736		;#0x60a0

00006156 <.Loc.738.2>:
  chSysUnlock();
    6156:	b0 12 36 5d 	call	#23862		;#0x5d36
    615a:	b0 12 d8 5c 	call	#23768		;#0x5cd8

0000615e <.Loc.739.2>:
}
    615e:	03 43       	nop			
    6160:	21 53       	incd	r1		;
    6162:	30 41       	ret			

00006164 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    6164:	31 80 06 00 	sub	#6,	r1	;

00006168 <.LCFI15>:
    6168:	81 4c 02 00 	mov	r12,	2(r1)	;
    616c:	81 4d 00 00 	mov	r13,	0(r1)	;

00006170 <.Loc.807.2>:

  chDbgCheckClassS();
    6170:	b0 12 1a 5e 	call	#24090		;#0x5e1a

00006174 <.Loc.812.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    6174:	1c 41 02 00 	mov	2(r1),	r12	;
    6178:	a1 4c 04 00 	mov	@r12,	4(r1)	;

0000617c <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    617c:	4c 43       	clr.b	r12		;
    617e:	1c 91 04 00 	cmp	4(r1),	r12	;
    6182:	17 38       	jl	$+48     	;abs 0x61b2

00006184 <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    6184:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6188:	02 20       	jnz	$+6      	;abs 0x618e

0000618a <.Loc.815.2>:
      return MSG_TIMEOUT;
    618a:	3c 43       	mov	#-1,	r12	;r3 As==11
    618c:	1a 3c       	jmp	$+54     	;abs 0x61c2

0000618e <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    618e:	1d 41 04 00 	mov	4(r1),	r13	;
    6192:	3d 53       	add	#-1,	r13	;r3 As==11
    6194:	1c 41 02 00 	mov	2(r1),	r12	;
    6198:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000619c <.Loc.818.2>:
    nil.current->u1.semp = sp;
    619c:	1c 42 4a 52 	mov	&0x524a,r12	;0x524a
    61a0:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    61a4:	04 00 

000061a6 <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    61a6:	2d 41       	mov	@r1,	r13	;
    61a8:	7c 40 03 00 	mov.b	#3,	r12	;
    61ac:	b0 12 a0 60 	call	#24736		;#0x60a0
    61b0:	08 3c       	jmp	$+18     	;abs 0x61c2

000061b2 <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    61b2:	1d 41 04 00 	mov	4(r1),	r13	;
    61b6:	3d 53       	add	#-1,	r13	;r3 As==11
    61b8:	1c 41 02 00 	mov	2(r1),	r12	;
    61bc:	8c 4d 00 00 	mov	r13,	0(r12)	;

000061c0 <.Loc.822.2>:
  return MSG_OK;
    61c0:	4c 43       	clr.b	r12		;

000061c2 <.L102>:
}
    61c2:	31 50 06 00 	add	#6,	r1	;
    61c6:	30 41       	ret			

000061c8 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    61c8:	32 c2       	dint			

000061ca <.Loc.348.1>:
  asm volatile("nop");
    61ca:	03 43       	nop			

000061cc <L0>:
}
    61cc:	03 43       	nop			
    61ce:	30 41       	ret			

000061d0 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    61d0:	03 43       	nop			

000061d2 <.Loc.356.1>:
  _enable_interrupts();
    61d2:	32 d2       	eint			
    61d4:	03 43       	nop			

000061d6 <.Loc.357.1>:
}
    61d6:	03 43       	nop			
    61d8:	30 41       	ret			

000061da <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    61da:	31 80 06 00 	sub	#6,	r1	;

000061de <.LCFI0>:
    61de:	81 4c 02 00 	mov	r12,	2(r1)	;
    61e2:	81 4d 00 00 	mov	r13,	0(r1)	;

000061e6 <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    61e6:	b0 12 fc 5d 	call	#24060		;#0x5dfc

000061ea <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    61ea:	2c 41       	mov	@r1,	r12	;
    61ec:	1c 51 02 00 	add	2(r1),	r12	;
    61f0:	0d 4c       	mov	r12,	r13	;
    61f2:	3d 53       	add	#-1,	r13	;r3 As==11
    61f4:	4c 43       	clr.b	r12		;
    61f6:	2c 81       	sub	@r1,	r12	;
    61f8:	0e 4d       	mov	r13,	r14	;
    61fa:	0e fc       	and	r12,	r14	;
    61fc:	81 4e 02 00 	mov	r14,	2(r1)	;

00006200 <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    6200:	1c 42 6e 52 	mov	&0x526e,r12	;0x526e
    6204:	2c 51       	add	@r1,	r12	;
    6206:	0d 4c       	mov	r12,	r13	;
    6208:	3d 53       	add	#-1,	r13	;r3 As==11
    620a:	4c 43       	clr.b	r12		;
    620c:	2c 81       	sub	@r1,	r12	;
    620e:	0c fd       	and	r13,	r12	;
    6210:	81 4c 04 00 	mov	r12,	4(r1)	;

00006214 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    6214:	1c 42 70 52 	mov	&0x5270,r12	;0x5270
    6218:	1d 41 04 00 	mov	4(r1),	r13	;
    621c:	0c 8d       	sub	r13,	r12	;
    621e:	1c 91 02 00 	cmp	2(r1),	r12	;
    6222:	02 2c       	jc	$+6      	;abs 0x6228

00006224 <.Loc.118.2>:
    return NULL;
    6224:	4c 43       	clr.b	r12		;
    6226:	08 3c       	jmp	$+18     	;abs 0x6238

00006228 <.L5>:
  }
  nextmem = p + size;
    6228:	1c 41 04 00 	mov	4(r1),	r12	;
    622c:	1c 51 02 00 	add	2(r1),	r12	;
    6230:	82 4c 6e 52 	mov	r12,	&0x526e	;

00006234 <.Loc.122.2>:

  return p;
    6234:	1c 41 04 00 	mov	4(r1),	r12	;

00006238 <.L6>:
}
    6238:	31 50 06 00 	add	#6,	r1	;
    623c:	30 41       	ret			

0000623e <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    623e:	31 80 06 00 	Address 0x0000000000006240 is out of bounds.
sub	#65535,	r1	;#0xffff

00006240 <L0>:
    6240:	06 00       	mova	@r0,	r6	;

00006242 <.LCFI1>:
    6242:	81 4c 02 00 	mov	r12,	2(r1)	;
    6246:	81 4d 00 00 	mov	r13,	0(r1)	;

0000624a <.Loc.140.2>:
  void *p;

  chSysLock();
    624a:	b0 12 c8 61 	call	#25032		;#0x61c8
    624e:	b0 12 16 5d 	call	#23830		;#0x5d16

00006252 <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    6252:	2d 41       	mov	@r1,	r13	;
    6254:	1c 41 02 00 	mov	2(r1),	r12	;
    6258:	b0 12 da 61 	call	#25050		;#0x61da
    625c:	81 4c 04 00 	mov	r12,	4(r1)	;

00006260 <.Loc.142.2>:
  chSysUnlock();
    6260:	b0 12 36 5d 	call	#23862		;#0x5d36
    6264:	b0 12 d0 61 	call	#25040		;#0x61d0

00006268 <.Loc.144.2>:

  return p;
    6268:	1c 41 04 00 	mov	4(r1),	r12	;

0000626c <.Loc.145.2>:
}
    626c:	31 50 06 00 	add	#6,	r1	;
    6270:	30 41       	ret			

00006272 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    6272:	b2 40 3e 62 	mov	#25150,	&0x5272	;#0x623e
    6276:	72 52 

00006278 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6278:	82 43 74 52 	mov	#0,	&0x5274	;r3 As==00

0000627c <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    627c:	82 43 76 52 	mov	#0,	&0x5276	;r3 As==00

00006280 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    6280:	92 43 78 52 	mov	#1,	&0x5278	;r3 As==01

00006284 <.Loc.117.1>:
#endif
}
    6284:	03 43       	nop			
    6286:	30 41       	ret			

00006288 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6288:	03 43       	nop			

0000628a <.Loc.356.1>:
  _enable_interrupts();
    628a:	32 d2       	eint			
    628c:	03 43       	nop			

0000628e <.Loc.357.1>:
}
    628e:	03 43       	nop			
    6290:	30 41       	ret			

00006292 <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6292:	6a 15       	pushm	#7,	r10	;16-bit words

00006294 <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    6294:	8d 41 00 00 	mov	r1,	0(r13)	;

00006298 <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    6298:	21 4c       	mov	@r12,	r1	;

0000629a <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    629a:	64 17       	popm	#7,	r10	;16-bit words

0000629c <.Loc.83.2>:
  asm volatile ("ret");
    629c:	30 41       	ret			

0000629e <.Loc.85.2>:
#endif
}
    629e:	03 43       	nop			

000062a0 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    62a0:	b0 12 36 5d 	call	#23862		;#0x5d36
    62a4:	b0 12 88 62 	call	#25224		;#0x6288

000062a8 <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    62a8:	0c 45       	mov	r5,	r12	;

000062aa <.Loc.101.2>:
  asm volatile ("call R4");
    62aa:	84 12       	call	r4		;

000062ac <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    62ac:	4c 43       	clr.b	r12		;
    62ae:	b0 12 f8 5e 	call	#24312		;#0x5ef8

000062b2 <.Loc.109.2>:
#endif
}
    62b2:	03 43       	nop			
    62b4:	30 41       	ret			

000062b6 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    62b6:	31 82       	sub	#8,	r1	;r2 As==11

000062b8 <.LCFI0>:
    62b8:	81 4c 02 00 	mov	r12,	2(r1)	;
    62bc:	81 4d 00 00 	mov	r13,	0(r1)	;

000062c0 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    62c0:	91 41 02 00 	mov	2(r1),	4(r1)	;
    62c4:	04 00 

000062c6 <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    62c6:	1c 41 02 00 	mov	2(r1),	r12	;
    62ca:	2c 4c       	mov	@r12,	r12	;
    62cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    62ce:	1d 34       	jge	$+60     	;abs 0x630a

000062d0 <.LBB2>:
    thread_t *tp = nil.threads;
    62d0:	b1 40 56 52 	mov	#21078,	6(r1)	;#0x5256
    62d4:	06 00 

000062d6 <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    62d6:	1c 41 06 00 	mov	6(r1),	r12	;
    62da:	1c 4c 04 00 	mov	4(r12),	r12	;
    62de:	1c 91 04 00 	cmp	4(r1),	r12	;
    62e2:	0f 20       	jnz	$+32     	;abs 0x6302

000062e4 <.Loc.67.1>:
        sp->cnt++;
    62e4:	1c 41 04 00 	mov	4(r1),	r12	;
    62e8:	2c 4c       	mov	@r12,	r12	;
    62ea:	1c 53       	inc	r12		;
    62ec:	0d 4c       	mov	r12,	r13	;
    62ee:	1c 41 04 00 	mov	4(r1),	r12	;
    62f2:	8c 4d 00 00 	mov	r13,	0(r12)	;

000062f6 <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    62f6:	2d 41       	mov	@r1,	r13	;
    62f8:	1c 41 06 00 	mov	6(r1),	r12	;
    62fc:	b0 12 0e 60 	call	#24590		;#0x600e

00006300 <.Loc.72.1>:
        return;
    6300:	04 3c       	jmp	$+10     	;abs 0x630a

00006302 <.L3>:
      }
      tp++;
    6302:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    6306:	06 00 

00006308 <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6308:	e6 3f       	jmp	$-50     	;abs 0x62d6

0000630a <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    630a:	31 52       	add	#8,	r1	;r2 As==11
    630c:	30 41       	ret			

0000630e <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
    630e:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00006312 <L0>:
    6312:	81 4c 02 00 	mov	r12,	2(r1)	;
    6316:	81 4d 00 00 	mov	r13,	0(r1)	;

0000631a <.Loc.91.1>:
  semaphore_t *sp = &tqp->sem;
    631a:	91 41 02 00 	mov	2(r1),	4(r1)	;
    631e:	04 00 

00006320 <.Loc.95.1>:
  thread_t *tp;
  cnt_t cnt;

  cnt = sp->cnt;
    6320:	1c 41 04 00 	mov	4(r1),	r12	;
    6324:	a1 4c 06 00 	mov	@r12,	6(r1)	;

00006328 <.Loc.96.1>:
  sp->cnt = (cnt_t)0;
    6328:	1c 41 04 00 	mov	4(r1),	r12	;
    632c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006330 <.Loc.97.1>:
  tp = nil.threads;
    6330:	b1 40 56 52 	mov	#21078,	8(r1)	;#0x5256
    6334:	08 00 

00006336 <.Loc.98.1>:
  while (cnt < (cnt_t)0) {
    6336:	14 3c       	jmp	$+42     	;abs 0x6360

00006338 <.L8>:

    chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");

    /* Is this thread waiting on this semaphore?*/
    if (tp->u1.semp == sp) {
    6338:	1c 41 08 00 	mov	8(r1),	r12	;
    633c:	1c 4c 04 00 	mov	4(r12),	r12	;
    6340:	1c 91 04 00 	cmp	4(r1),	r12	;
    6344:	0a 20       	jnz	$+22     	;abs 0x635a

00006346 <.Loc.108.1>:

      chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

      cnt++;
    6346:	1c 41 06 00 	mov	6(r1),	r12	;
    634a:	1c 53       	inc	r12		;
    634c:	81 4c 06 00 	mov	r12,	6(r1)	;

00006350 <.Loc.109.1>:
      (void) chSchReadyI(tp, msg);
    6350:	2d 41       	mov	@r1,	r13	;
    6352:	1c 41 08 00 	mov	8(r1),	r12	;
    6356:	b0 12 0e 60 	call	#24590		;#0x600e

0000635a <.L7>:
    }
    tp++;
    635a:	b1 50 0c 00 	add	#12,	8(r1)	;#0x000c
    635e:	08 00 

00006360 <.L6>:
  cnt_t cnt;

  cnt = sp->cnt;
  sp->cnt = (cnt_t)0;
  tp = nil.threads;
  while (cnt < (cnt_t)0) {
    6360:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6364:	e9 3b       	jl	$-44     	;abs 0x6338

00006366 <.Loc.113.1>:
      cnt++;
      (void) chSchReadyI(tp, msg);
    }
    tp++;
  }
}
    6366:	03 43       	nop			
    6368:	31 50 0a 00 	add	#10,	r1	;#0x000a
    636c:	30 41       	ret			

0000636e <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    636e:	03 43       	nop			

00006370 <L0>:
    6370:	30 41       	ret			

00006372 <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    6372:	b0 12 6e 63 	call	#25454		;#0x636e

00006376 <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    6376:	b0 12 e0 6d 	call	#28128		;#0x6de0

0000637a <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    637a:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    637e:	b0 12 ac 75 	call	#30124		;#0x75ac

00006382 <.Loc.68.2>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    6382:	b0 12 e4 69 	call	#27108		;#0x69e4

00006386 <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    6386:	b0 12 90 6c 	call	#27792		;#0x6c90

0000638a <.Loc.107.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    638a:	b0 12 ba 6d 	call	#28090		;#0x6dba

0000638e <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    638e:	b0 12 3a 84 	call	#33850		;#0x843a

00006392 <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    6392:	b0 12 9a 63 	call	#25498		;#0x639a

00006396 <.Loc.145.2>:
#endif
}
    6396:	03 43       	nop			
    6398:	30 41       	ret			

0000639a <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    639a:	b0 12 78 6e 	call	#28280		;#0x6e78

0000639e <.Loc.63.2>:
}
    639e:	03 43       	nop			
    63a0:	30 41       	ret			

000063a2 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    63a2:	32 c2       	dint			

000063a4 <.Loc.348.1>:
  asm volatile("nop");
    63a4:	03 43       	nop			

000063a6 <.Loc.349.1>:
}
    63a6:	03 43       	nop			
    63a8:	30 41       	ret			

000063aa <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    63aa:	03 43       	nop			

000063ac <.Loc.356.1>:
  _enable_interrupts();
    63ac:	32 d2       	eint			
    63ae:	03 43       	nop			

000063b0 <.Loc.357.1>:
}
    63b0:	03 43       	nop			
    63b2:	30 41       	ret			

000063b4 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    63b4:	b0 12 a2 63 	call	#25506		;#0x63a2
    63b8:	b0 12 16 5d 	call	#23830		;#0x5d16

000063bc <.Loc.505.2>:
}
    63bc:	03 43       	nop			
    63be:	30 41       	ret			

000063c0 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    63c0:	b0 12 36 5d 	call	#23862		;#0x5d36
    63c4:	b0 12 aa 63 	call	#25514		;#0x63aa

000063c8 <.Loc.516.2>:
}
    63c8:	03 43       	nop			
    63ca:	30 41       	ret			

000063cc <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    63cc:	1c 42 4e 52 	mov	&0x524e,r12	;0x524e

000063d0 <.Loc.630.2>:
}
    63d0:	30 41       	ret			

000063d2 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    63d2:	21 83       	decd	r1		;

000063d4 <.LCFI0>:
    63d4:	81 4c 00 00 	mov	r12,	0(r1)	;

000063d8 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    63d8:	2c 41       	mov	@r1,	r12	;
    63da:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000063de <.Loc.768.2>:
}
    63de:	03 43       	nop			
    63e0:	21 53       	incd	r1		;
    63e2:	30 41       	ret			

000063e4 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    63e4:	21 82       	sub	#4,	r1	;r2 As==10

000063e6 <.LCFI1>:
    63e6:	81 4c 02 00 	mov	r12,	2(r1)	;
    63ea:	81 4d 00 00 	mov	r13,	0(r1)	;

000063ee <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    63ee:	1c 41 02 00 	mov	2(r1),	r12	;
    63f2:	2d 41       	mov	@r1,	r13	;
    63f4:	b0 12 64 61 	call	#24932		;#0x6164

000063f8 <.Loc.797.2>:
}
    63f8:	21 52       	add	#4,	r1	;r2 As==10
    63fa:	30 41       	ret			

000063fc <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    63fc:	31 82       	sub	#8,	r1	;r2 As==11

000063fe <.LCFI2>:
    63fe:	81 4c 06 00 	mov	r12,	6(r1)	;
    6402:	81 4d 04 00 	mov	r13,	4(r1)	;
    6406:	81 4e 02 00 	mov	r14,	2(r1)	;
    640a:	81 4f 00 00 	mov	r15,	0(r1)	;

0000640e <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    640e:	1c 41 06 00 	mov	6(r1),	r12	;
    6412:	b0 12 d2 63 	call	#25554		;#0x63d2

00006416 <.Loc.59.3>:
  iqp->q_counter = 0;
    6416:	1c 41 06 00 	mov	6(r1),	r12	;
    641a:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000641e <.Loc.60.3>:
  iqp->q_buffer  = bp;
    641e:	1c 41 06 00 	mov	6(r1),	r12	;
    6422:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6426:	04 00 

00006428 <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    6428:	1c 41 06 00 	mov	6(r1),	r12	;
    642c:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6430:	0a 00 

00006432 <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6432:	1c 41 06 00 	mov	6(r1),	r12	;
    6436:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    643a:	08 00 

0000643c <.Loc.63.3>:
  iqp->q_top     = bp + size;
    643c:	1d 41 04 00 	mov	4(r1),	r13	;
    6440:	1d 51 02 00 	add	2(r1),	r13	;
    6444:	1c 41 06 00 	mov	6(r1),	r12	;
    6448:	8c 4d 06 00 	mov	r13,	6(r12)	;

0000644c <.Loc.64.3>:
  iqp->q_notify  = infy;
    644c:	1c 41 06 00 	mov	6(r1),	r12	;
    6450:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006454 <.Loc.65.3>:
  iqp->q_link    = link;
    6454:	1c 41 06 00 	mov	6(r1),	r12	;
    6458:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    645c:	0e 00 

0000645e <.Loc.66.3>:
}
    645e:	03 43       	nop			
    6460:	31 52       	add	#8,	r1	;r2 As==11
    6462:	30 41       	ret			

00006464 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    6464:	21 82       	sub	#4,	r1	;r2 As==10

00006466 <.LCFI4>:
    6466:	81 4c 02 00 	mov	r12,	2(r1)	;
    646a:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

0000646e <.Loc.104.3>:

  osalDbgCheckClassI();
    646e:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00006472 <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    6472:	1c 41 02 00 	mov	2(r1),	r12	;
    6476:	1d 4c 08 00 	mov	8(r12),	r13	;
    647a:	1c 41 02 00 	mov	2(r1),	r12	;
    647e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6482:	0d 9c       	cmp	r12,	r13	;
    6484:	08 20       	jnz	$+18     	;abs 0x6496

00006486 <.Loc.106.3>:
    6486:	1c 41 02 00 	mov	2(r1),	r12	;
    648a:	1c 4c 02 00 	mov	2(r12),	r12	;
    648e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6490:	02 24       	jz	$+6      	;abs 0x6496

00006492 <.Loc.106.3>:
    6492:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6494:	01 3c       	jmp	$+4      	;abs 0x6498

00006496 <.L13>:
    6496:	4c 43       	clr.b	r12		;

00006498 <.L14>:
    6498:	5c f3       	and.b	#1,	r12	;r3 As==01
    649a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    649e:	0c 93       	cmp	#0,	r12	;r3 As==00
    64a0:	02 24       	jz	$+6      	;abs 0x64a6

000064a2 <.Loc.107.3>:
    return MSG_TIMEOUT;
    64a2:	3c 43       	mov	#-1,	r12	;r3 As==11
    64a4:	2f 3c       	jmp	$+96     	;abs 0x6504

000064a6 <.L15>:
  }

  iqp->q_counter++;
    64a6:	1c 41 02 00 	mov	2(r1),	r12	;
    64aa:	1c 4c 02 00 	mov	2(r12),	r12	;
    64ae:	0d 4c       	mov	r12,	r13	;
    64b0:	1d 53       	inc	r13		;
    64b2:	1c 41 02 00 	mov	2(r1),	r12	;
    64b6:	8c 4d 02 00 	mov	r13,	2(r12)	;

000064ba <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    64ba:	1c 41 02 00 	mov	2(r1),	r12	;
    64be:	1c 4c 08 00 	mov	8(r12),	r12	;
    64c2:	0e 4c       	mov	r12,	r14	;
    64c4:	1e 53       	inc	r14		;
    64c6:	1d 41 02 00 	mov	2(r1),	r13	;
    64ca:	8d 4e 08 00 	mov	r14,	8(r13)	;
    64ce:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    64d2:	00 00 

000064d4 <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    64d4:	1c 41 02 00 	mov	2(r1),	r12	;
    64d8:	1d 4c 08 00 	mov	8(r12),	r13	;
    64dc:	1c 41 02 00 	mov	2(r1),	r12	;
    64e0:	1c 4c 06 00 	mov	6(r12),	r12	;
    64e4:	0d 9c       	cmp	r12,	r13	;
    64e6:	08 28       	jnc	$+18     	;abs 0x64f8

000064e8 <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    64e8:	1c 41 02 00 	mov	2(r1),	r12	;
    64ec:	1d 4c 04 00 	mov	4(r12),	r13	;
    64f0:	1c 41 02 00 	mov	2(r1),	r12	;
    64f4:	8c 4d 08 00 	mov	r13,	8(r12)	;

000064f8 <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    64f8:	1c 41 02 00 	mov	2(r1),	r12	;
    64fc:	4d 43       	clr.b	r13		;
    64fe:	b0 12 b6 62 	call	#25270		;#0x62b6

00006502 <.Loc.118.3>:

  return MSG_OK;
    6502:	4c 43       	clr.b	r12		;

00006504 <.L16>:
}
    6504:	21 52       	add	#4,	r1	;r2 As==10
    6506:	30 41       	ret			

00006508 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    6508:	31 82       	sub	#8,	r1	;r2 As==11

0000650a <.LCFI5>:
    650a:	81 4c 02 00 	Address 0x000000000000650c is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000650c <L0>:
    650c:	02 00       	mova	@r0,	r2	;
    650e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006512 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6512:	b0 12 b4 63 	call	#25524		;#0x63b4

00006516 <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6516:	0f 3c       	jmp	$+32     	;abs 0x6536

00006518 <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6518:	1c 41 02 00 	mov	2(r1),	r12	;
    651c:	2d 41       	mov	@r1,	r13	;
    651e:	b0 12 e4 63 	call	#25572		;#0x63e4
    6522:	81 4c 06 00 	mov	r12,	6(r1)	;

00006526 <.Loc.149.3>:
    if (msg < MSG_OK) {
    6526:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    652a:	05 34       	jge	$+12     	;abs 0x6536

0000652c <.Loc.150.3>:
      osalSysUnlock();
    652c:	b0 12 c0 63 	call	#25536		;#0x63c0

00006530 <.Loc.151.3>:
      return msg;
    6530:	1c 41 06 00 	mov	6(r1),	r12	;
    6534:	3f 3c       	jmp	$+128    	;abs 0x65b4

00006536 <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6536:	1c 41 02 00 	mov	2(r1),	r12	;
    653a:	1c 4c 02 00 	mov	2(r12),	r12	;
    653e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6540:	eb 27       	jz	$-40     	;abs 0x6518

00006542 <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6542:	1c 41 02 00 	mov	2(r1),	r12	;
    6546:	1c 4c 02 00 	mov	2(r12),	r12	;
    654a:	0d 4c       	mov	r12,	r13	;
    654c:	3d 53       	add	#-1,	r13	;r3 As==11
    654e:	1c 41 02 00 	mov	2(r1),	r12	;
    6552:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006556 <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6556:	1c 41 02 00 	mov	2(r1),	r12	;
    655a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    655e:	0e 4c       	mov	r12,	r14	;
    6560:	1e 53       	inc	r14		;
    6562:	1d 41 02 00 	mov	2(r1),	r13	;
    6566:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    656a:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

0000656e <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    656e:	1c 41 02 00 	mov	2(r1),	r12	;
    6572:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6576:	1c 41 02 00 	mov	2(r1),	r12	;
    657a:	1c 4c 06 00 	mov	6(r12),	r12	;
    657e:	0d 9c       	cmp	r12,	r13	;
    6580:	08 28       	jnc	$+18     	;abs 0x6592

00006582 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6582:	1c 41 02 00 	mov	2(r1),	r12	;
    6586:	1d 4c 04 00 	mov	4(r12),	r13	;
    658a:	1c 41 02 00 	mov	2(r1),	r12	;
    658e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006592 <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6592:	1c 41 02 00 	mov	2(r1),	r12	;
    6596:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    659a:	0c 93       	cmp	#0,	r12	;r3 As==00
    659c:	07 24       	jz	$+16     	;abs 0x65ac

0000659e <.Loc.164.3>:
    iqp->q_notify(iqp);
    659e:	1c 41 02 00 	mov	2(r1),	r12	;
    65a2:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    65a6:	1c 41 02 00 	mov	2(r1),	r12	;
    65aa:	8d 12       	call	r13		;

000065ac <.L23>:
  }

  osalSysUnlock();
    65ac:	b0 12 c0 63 	call	#25536		;#0x63c0

000065b0 <.Loc.169.3>:

  return (msg_t)b;
    65b0:	5c 41 05 00 	mov.b	5(r1),	r12	;

000065b4 <.L20>:
}
    65b4:	31 52       	add	#8,	r1	;r2 As==11
    65b6:	30 41       	ret			

000065b8 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    65b8:	31 80 12 00 	sub	#18,	r1	;#0x0012

000065bc <L0>:
    65bc:	81 4c 06 00 	mov	r12,	6(r1)	;
    65c0:	81 4d 04 00 	mov	r13,	4(r1)	;
    65c4:	81 4e 02 00 	mov	r14,	2(r1)	;
    65c8:	81 4f 00 00 	mov	r15,	0(r1)	;

000065cc <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    65cc:	1c 41 06 00 	mov	6(r1),	r12	;
    65d0:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    65d4:	0c 00 

000065d6 <.Loc.200.3>:
  size_t r = 0;
    65d6:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

000065da <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    65da:	b0 12 b4 63 	call	#25524		;#0x63b4

000065de <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    65de:	b0 12 cc 63 	call	#25548		;#0x63cc
    65e2:	0d 4c       	mov	r12,	r13	;
    65e4:	2d 51       	add	@r1,	r13	;
    65e6:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

000065ea <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    65ea:	2e 3c       	jmp	$+94     	;abs 0x6648

000065ec <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    65ec:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    65f0:	03 24       	jz	$+8      	;abs 0x65f8

000065f2 <.Loc.218.3>:
    65f2:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    65f6:	08 20       	jnz	$+18     	;abs 0x6608

000065f8 <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    65f8:	1c 41 06 00 	mov	6(r1),	r12	;
    65fc:	2d 41       	mov	@r1,	r13	;
    65fe:	b0 12 e4 63 	call	#25572		;#0x63e4
    6602:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6606:	18 3c       	jmp	$+50     	;abs 0x6638

00006608 <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6608:	b0 12 cc 63 	call	#25548		;#0x63cc
    660c:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6610:	0d 8c       	sub	r12,	r13	;
    6612:	81 4d 08 00 	mov	r13,	8(r1)	;

00006616 <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6616:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    661a:	00 00 
    661c:	05 2c       	jc	$+12     	;abs 0x6628

0000661e <.Loc.228.3>:
          osalSysUnlock();
    661e:	b0 12 c0 63 	call	#25536		;#0x63c0

00006622 <.Loc.229.3>:
          return r;
    6622:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6626:	5c 3c       	jmp	$+186    	;abs 0x66e0

00006628 <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    6628:	1c 41 06 00 	mov	6(r1),	r12	;
    662c:	1d 41 08 00 	mov	8(r1),	r13	;
    6630:	b0 12 e4 63 	call	#25572		;#0x63e4
    6634:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006638 <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6638:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    663c:	05 24       	jz	$+12     	;abs 0x6648

0000663e <.Loc.237.3>:
        osalSysUnlock();
    663e:	b0 12 c0 63 	call	#25536		;#0x63c0

00006642 <.Loc.238.3>:
        return r;
    6642:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6646:	4c 3c       	jmp	$+154    	;abs 0x66e0

00006648 <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6648:	1c 41 06 00 	mov	6(r1),	r12	;
    664c:	1c 4c 02 00 	mov	2(r12),	r12	;
    6650:	0c 93       	cmp	#0,	r12	;r3 As==00
    6652:	cc 27       	jz	$-102    	;abs 0x65ec

00006654 <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    6654:	1c 41 06 00 	mov	6(r1),	r12	;
    6658:	1c 4c 02 00 	mov	2(r12),	r12	;
    665c:	0d 4c       	mov	r12,	r13	;
    665e:	3d 53       	add	#-1,	r13	;r3 As==11
    6660:	1c 41 06 00 	mov	6(r1),	r12	;
    6664:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006668 <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    6668:	1c 41 04 00 	mov	4(r1),	r12	;
    666c:	0d 4c       	mov	r12,	r13	;
    666e:	1d 53       	inc	r13		;
    6670:	81 4d 04 00 	mov	r13,	4(r1)	;
    6674:	1d 41 06 00 	mov	6(r1),	r13	;
    6678:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    667c:	0f 4d       	mov	r13,	r15	;
    667e:	1f 53       	inc	r15		;
    6680:	1e 41 06 00 	mov	6(r1),	r14	;
    6684:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    6688:	6d 4d       	mov.b	@r13,	r13	;
    668a:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

0000668e <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    668e:	1c 41 06 00 	mov	6(r1),	r12	;
    6692:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6696:	1c 41 06 00 	mov	6(r1),	r12	;
    669a:	1c 4c 06 00 	mov	6(r12),	r12	;
    669e:	0d 9c       	cmp	r12,	r13	;
    66a0:	08 28       	jnc	$+18     	;abs 0x66b2

000066a2 <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    66a2:	1c 41 06 00 	mov	6(r1),	r12	;
    66a6:	1d 4c 04 00 	mov	4(r12),	r13	;
    66aa:	1c 41 06 00 	mov	6(r1),	r12	;
    66ae:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000066b2 <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    66b2:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    66b6:	05 24       	jz	$+12     	;abs 0x66c2

000066b8 <.Loc.251.3>:
      nfy(iqp);
    66b8:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    66bc:	1c 41 06 00 	mov	6(r1),	r12	;
    66c0:	8d 12       	call	r13		;

000066c2 <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    66c2:	b0 12 c0 63 	call	#25536		;#0x63c0

000066c6 <.Loc.257.3>:

    r++;
    66c6:	91 53 10 00 	inc	16(r1)		;

000066ca <.Loc.258.3>:
    if (--n == 0U) {
    66ca:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    66ce:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    66d2:	03 20       	jnz	$+8      	;abs 0x66da

000066d4 <.Loc.259.3>:
      return r;
    66d4:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    66d8:	03 3c       	jmp	$+8      	;abs 0x66e0

000066da <.L34>:
    }

    osalSysLock();
    66da:	b0 12 b4 63 	call	#25524		;#0x63b4

000066de <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    66de:	b4 3f       	jmp	$-150    	;abs 0x6648

000066e0 <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    66e0:	31 50 12 00 	add	#18,	r1	;#0x0012
    66e4:	30 41       	ret			

000066e6 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    66e6:	31 82       	sub	#8,	r1	;r2 As==11

000066e8 <.LCFI7>:
    66e8:	81 4c 06 00 	mov	r12,	6(r1)	;
    66ec:	81 4d 04 00 	mov	r13,	4(r1)	;
    66f0:	81 4e 02 00 	Address 0x00000000000066f2 is out of bounds.
mov	r14,	-1(r1)	; 0xffff

000066f2 <L0>:
    66f2:	02 00       	mova	@r0,	r2	;
    66f4:	81 4f 00 00 	mov	r15,	0(r1)	;

000066f8 <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    66f8:	1c 41 06 00 	mov	6(r1),	r12	;
    66fc:	b0 12 d2 63 	call	#25554		;#0x63d2

00006700 <.Loc.285.3>:
  oqp->q_counter = size;
    6700:	1c 41 06 00 	mov	6(r1),	r12	;
    6704:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    6708:	02 00 

0000670a <.Loc.286.3>:
  oqp->q_buffer  = bp;
    670a:	1c 41 06 00 	mov	6(r1),	r12	;
    670e:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6712:	04 00 

00006714 <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6714:	1c 41 06 00 	mov	6(r1),	r12	;
    6718:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    671c:	0a 00 

0000671e <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    671e:	1c 41 06 00 	mov	6(r1),	r12	;
    6722:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6726:	08 00 

00006728 <.Loc.289.3>:
  oqp->q_top     = bp + size;
    6728:	1d 41 04 00 	mov	4(r1),	r13	;
    672c:	1d 51 02 00 	add	2(r1),	r13	;
    6730:	1c 41 06 00 	mov	6(r1),	r12	;
    6734:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006738 <.Loc.290.3>:
  oqp->q_notify  = onfy;
    6738:	1c 41 06 00 	mov	6(r1),	r12	;
    673c:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006740 <.Loc.291.3>:
  oqp->q_link    = link;
    6740:	1c 41 06 00 	mov	6(r1),	r12	;
    6744:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6748:	0e 00 

0000674a <.Loc.292.3>:
}
    674a:	03 43       	nop			
    674c:	31 52       	add	#8,	r1	;r2 As==11
    674e:	30 41       	ret			

00006750 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    6750:	31 82       	sub	#8,	r1	;r2 As==11

00006752 <.LCFI9>:
    6752:	81 4c 04 00 	mov	r12,	4(r1)	;
    6756:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    675a:	81 4e 00 00 	mov	r14,	0(r1)	;

0000675e <.Loc.339.3>:

  osalSysLock();
    675e:	b0 12 b4 63 	call	#25524		;#0x63b4

00006762 <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6762:	0f 3c       	jmp	$+32     	;abs 0x6782

00006764 <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6764:	1c 41 04 00 	mov	4(r1),	r12	;
    6768:	2d 41       	mov	@r1,	r13	;
    676a:	b0 12 e4 63 	call	#25572		;#0x63e4
    676e:	81 4c 06 00 	mov	r12,	6(r1)	;

00006772 <.Loc.344.3>:
    if (msg < MSG_OK) {
    6772:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6776:	05 34       	jge	$+12     	;abs 0x6782

00006778 <.Loc.345.3>:
      osalSysUnlock();
    6778:	b0 12 c0 63 	call	#25536		;#0x63c0

0000677c <.Loc.346.3>:
      return msg;
    677c:	1c 41 06 00 	mov	6(r1),	r12	;
    6780:	3f 3c       	jmp	$+128    	;abs 0x6800

00006782 <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6782:	1c 41 04 00 	mov	4(r1),	r12	;
    6786:	1c 4c 02 00 	mov	2(r12),	r12	;
    678a:	0c 93       	cmp	#0,	r12	;r3 As==00
    678c:	eb 27       	jz	$-40     	;abs 0x6764

0000678e <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    678e:	1c 41 04 00 	mov	4(r1),	r12	;
    6792:	1c 4c 02 00 	mov	2(r12),	r12	;
    6796:	0d 4c       	mov	r12,	r13	;
    6798:	3d 53       	add	#-1,	r13	;r3 As==11
    679a:	1c 41 04 00 	mov	4(r1),	r12	;
    679e:	8c 4d 02 00 	mov	r13,	2(r12)	;

000067a2 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    67a2:	1c 41 04 00 	mov	4(r1),	r12	;
    67a6:	1c 4c 08 00 	mov	8(r12),	r12	;
    67aa:	0e 4c       	mov	r12,	r14	;
    67ac:	1e 53       	inc	r14		;
    67ae:	1d 41 04 00 	mov	4(r1),	r13	;
    67b2:	8d 4e 08 00 	mov	r14,	8(r13)	;
    67b6:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    67ba:	00 00 

000067bc <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    67bc:	1c 41 04 00 	mov	4(r1),	r12	;
    67c0:	1d 4c 08 00 	mov	8(r12),	r13	;
    67c4:	1c 41 04 00 	mov	4(r1),	r12	;
    67c8:	1c 4c 06 00 	mov	6(r12),	r12	;
    67cc:	0d 9c       	cmp	r12,	r13	;
    67ce:	08 28       	jnc	$+18     	;abs 0x67e0

000067d0 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    67d0:	1c 41 04 00 	mov	4(r1),	r12	;
    67d4:	1d 4c 04 00 	mov	4(r12),	r13	;
    67d8:	1c 41 04 00 	mov	4(r1),	r12	;
    67dc:	8c 4d 08 00 	mov	r13,	8(r12)	;

000067e0 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    67e0:	1c 41 04 00 	mov	4(r1),	r12	;
    67e4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    67e8:	0c 93       	cmp	#0,	r12	;r3 As==00
    67ea:	07 24       	jz	$+16     	;abs 0x67fa

000067ec <.Loc.359.3>:
    oqp->q_notify(oqp);
    67ec:	1c 41 04 00 	mov	4(r1),	r12	;
    67f0:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    67f4:	1c 41 04 00 	mov	4(r1),	r12	;
    67f8:	8d 12       	call	r13		;

000067fa <.L43>:
  }

  osalSysUnlock();
    67fa:	b0 12 c0 63 	call	#25536		;#0x63c0

000067fe <.Loc.364.3>:

  return MSG_OK;
    67fe:	4c 43       	clr.b	r12		;

00006800 <.L40>:
}
    6800:	31 52       	add	#8,	r1	;r2 As==11
    6802:	30 41       	ret			

00006804 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6804:	21 82       	sub	#4,	r1	;r2 As==10

00006806 <.LCFI10>:
    6806:	81 4c 00 00 	Address 0x0000000000006808 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006808 <L0>:
	...

0000680a <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    680a:	b0 12 fc 5d 	call	#24060		;#0x5dfc

0000680e <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    680e:	2c 41       	mov	@r1,	r12	;
    6810:	1d 4c 08 00 	mov	8(r12),	r13	;
    6814:	2c 41       	mov	@r1,	r12	;
    6816:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    681a:	0d 9c       	cmp	r12,	r13	;
    681c:	07 20       	jnz	$+16     	;abs 0x682c

0000681e <.Loc.382.3>:
    681e:	2c 41       	mov	@r1,	r12	;
    6820:	1c 4c 02 00 	mov	2(r12),	r12	;
    6824:	0c 93       	cmp	#0,	r12	;r3 As==00
    6826:	02 24       	jz	$+6      	;abs 0x682c

00006828 <.Loc.382.3>:
    6828:	5c 43       	mov.b	#1,	r12	;r3 As==01
    682a:	01 3c       	jmp	$+4      	;abs 0x682e

0000682c <.L45>:
    682c:	4c 43       	clr.b	r12		;

0000682e <.L46>:
    682e:	5c f3       	and.b	#1,	r12	;r3 As==01
    6830:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6834:	0c 93       	cmp	#0,	r12	;r3 As==00
    6836:	02 24       	jz	$+6      	;abs 0x683c

00006838 <.Loc.383.3>:
    return MSG_TIMEOUT;
    6838:	3c 43       	mov	#-1,	r12	;r3 As==11
    683a:	26 3c       	jmp	$+78     	;abs 0x6888

0000683c <.L47>:
  }

  oqp->q_counter++;
    683c:	2c 41       	mov	@r1,	r12	;
    683e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6842:	0d 4c       	mov	r12,	r13	;
    6844:	1d 53       	inc	r13		;
    6846:	2c 41       	mov	@r1,	r12	;
    6848:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000684c <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    684c:	2c 41       	mov	@r1,	r12	;
    684e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6852:	0e 4c       	mov	r12,	r14	;
    6854:	1e 53       	inc	r14		;
    6856:	2d 41       	mov	@r1,	r13	;
    6858:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    685c:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

00006860 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    6860:	2c 41       	mov	@r1,	r12	;
    6862:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6866:	2c 41       	mov	@r1,	r12	;
    6868:	1c 4c 06 00 	mov	6(r12),	r12	;
    686c:	0d 9c       	cmp	r12,	r13	;
    686e:	06 28       	jnc	$+14     	;abs 0x687c

00006870 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    6870:	2c 41       	mov	@r1,	r12	;
    6872:	1d 4c 04 00 	mov	4(r12),	r13	;
    6876:	2c 41       	mov	@r1,	r12	;
    6878:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000687c <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    687c:	2c 41       	mov	@r1,	r12	;
    687e:	4d 43       	clr.b	r13		;
    6880:	b0 12 b6 62 	call	#25270		;#0x62b6

00006884 <.Loc.394.3>:

  return (msg_t)b;
    6884:	5c 41 03 00 	mov.b	3(r1),	r12	;

00006888 <.L48>:
}
    6888:	21 52       	add	#4,	r1	;r2 As==10
    688a:	30 41       	ret			

0000688c <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    688c:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006890 <L0>:
    6890:	81 4c 06 00 	mov	r12,	6(r1)	;
    6894:	81 4d 04 00 	mov	r13,	4(r1)	;
    6898:	81 4e 02 00 	mov	r14,	2(r1)	;
    689c:	81 4f 00 00 	mov	r15,	0(r1)	;

000068a0 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    68a0:	1c 41 06 00 	mov	6(r1),	r12	;
    68a4:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    68a8:	0c 00 

000068aa <.Loc.425.3>:
  size_t w = 0;
    68aa:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

000068ae <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    68ae:	b0 12 b4 63 	call	#25524		;#0x63b4

000068b2 <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    68b2:	b0 12 cc 63 	call	#25548		;#0x63cc
    68b6:	0d 4c       	mov	r12,	r13	;
    68b8:	2d 51       	add	@r1,	r13	;
    68ba:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

000068be <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    68be:	2e 3c       	jmp	$+94     	;abs 0x691c

000068c0 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    68c0:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    68c4:	03 24       	jz	$+8      	;abs 0x68cc

000068c6 <.Loc.442.3>:
    68c6:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    68ca:	08 20       	jnz	$+18     	;abs 0x68dc

000068cc <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    68cc:	1c 41 06 00 	mov	6(r1),	r12	;
    68d0:	2d 41       	mov	@r1,	r13	;
    68d2:	b0 12 e4 63 	call	#25572		;#0x63e4
    68d6:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    68da:	18 3c       	jmp	$+50     	;abs 0x690c

000068dc <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    68dc:	b0 12 cc 63 	call	#25548		;#0x63cc
    68e0:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    68e4:	0e 8c       	sub	r12,	r14	;
    68e6:	81 4e 08 00 	mov	r14,	8(r1)	;

000068ea <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    68ea:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    68ee:	00 00 
    68f0:	05 2c       	jc	$+12     	;abs 0x68fc

000068f2 <.Loc.452.3>:
          osalSysUnlock();
    68f2:	b0 12 c0 63 	call	#25536		;#0x63c0

000068f6 <.Loc.453.3>:
          return w;
    68f6:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    68fa:	5c 3c       	jmp	$+186    	;abs 0x69b4

000068fc <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    68fc:	1c 41 06 00 	mov	6(r1),	r12	;
    6900:	1d 41 08 00 	mov	8(r1),	r13	;
    6904:	b0 12 e4 63 	call	#25572		;#0x63e4
    6908:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

0000690c <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    690c:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6910:	05 24       	jz	$+12     	;abs 0x691c

00006912 <.Loc.461.3>:
        osalSysUnlock();
    6912:	b0 12 c0 63 	call	#25536		;#0x63c0

00006916 <.Loc.462.3>:
        return w;
    6916:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    691a:	4c 3c       	jmp	$+154    	;abs 0x69b4

0000691c <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    691c:	1c 41 06 00 	mov	6(r1),	r12	;
    6920:	1c 4c 02 00 	mov	2(r12),	r12	;
    6924:	0c 93       	cmp	#0,	r12	;r3 As==00
    6926:	cc 27       	jz	$-102    	;abs 0x68c0

00006928 <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    6928:	1c 41 06 00 	mov	6(r1),	r12	;
    692c:	1c 4c 02 00 	mov	2(r12),	r12	;
    6930:	0d 4c       	mov	r12,	r13	;
    6932:	3d 53       	add	#-1,	r13	;r3 As==11
    6934:	1c 41 06 00 	mov	6(r1),	r12	;
    6938:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000693c <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    693c:	1c 41 06 00 	mov	6(r1),	r12	;
    6940:	1c 4c 08 00 	mov	8(r12),	r12	;
    6944:	0e 4c       	mov	r12,	r14	;
    6946:	1e 53       	inc	r14		;
    6948:	1d 41 06 00 	mov	6(r1),	r13	;
    694c:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6950:	1d 41 04 00 	mov	4(r1),	r13	;
    6954:	0e 4d       	mov	r13,	r14	;
    6956:	1e 53       	inc	r14		;
    6958:	81 4e 04 00 	mov	r14,	4(r1)	;
    695c:	6d 4d       	mov.b	@r13,	r13	;
    695e:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006962 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    6962:	1c 41 06 00 	mov	6(r1),	r12	;
    6966:	1d 4c 08 00 	mov	8(r12),	r13	;
    696a:	1c 41 06 00 	mov	6(r1),	r12	;
    696e:	1c 4c 06 00 	mov	6(r12),	r12	;
    6972:	0d 9c       	cmp	r12,	r13	;
    6974:	08 28       	jnc	$+18     	;abs 0x6986

00006976 <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    6976:	1c 41 06 00 	mov	6(r1),	r12	;
    697a:	1d 4c 04 00 	mov	4(r12),	r13	;
    697e:	1c 41 06 00 	mov	6(r1),	r12	;
    6982:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006986 <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    6986:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    698a:	05 24       	jz	$+12     	;abs 0x6996

0000698c <.Loc.475.3>:
      nfy(oqp);
    698c:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6990:	1c 41 06 00 	mov	6(r1),	r12	;
    6994:	8d 12       	call	r13		;

00006996 <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6996:	b0 12 c0 63 	call	#25536		;#0x63c0

0000699a <.Loc.481.3>:

    w++;
    699a:	91 53 10 00 	inc	16(r1)		;

0000699e <.Loc.482.3>:
    if (--n == 0U) {
    699e:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    69a2:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    69a6:	03 20       	jnz	$+8      	;abs 0x69ae

000069a8 <.Loc.483.3>:
      return w;
    69a8:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    69ac:	03 3c       	jmp	$+8      	;abs 0x69b4

000069ae <.L60>:
    }

    osalSysLock();
    69ae:	b0 12 b4 63 	call	#25524		;#0x63b4

000069b2 <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    69b2:	85 3f       	jmp	$-244    	;abs 0x68be

000069b4 <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    69b4:	31 50 12 00 	add	#18,	r1	;#0x0012
    69b8:	30 41       	ret			

000069ba <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    69ba:	32 c2       	dint			

000069bc <.Loc.348.1>:
  asm volatile("nop");
    69bc:	03 43       	nop			

000069be <.Loc.349.1>:
}
    69be:	03 43       	nop			
    69c0:	30 41       	ret			

000069c2 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    69c2:	03 43       	nop			

000069c4 <.Loc.356.1>:
  _enable_interrupts();
    69c4:	32 d2       	eint			

000069c6 <L0>:
    69c6:	03 43       	nop			

000069c8 <.Loc.357.1>:
}
    69c8:	03 43       	nop			
    69ca:	30 41       	ret			

000069cc <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    69cc:	b0 12 ba 69 	call	#27066		;#0x69ba
    69d0:	b0 12 16 5d 	call	#23830		;#0x5d16

000069d4 <.Loc.505.2>:
}
    69d4:	03 43       	nop			
    69d6:	30 41       	ret			

000069d8 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    69d8:	b0 12 36 5d 	call	#23862		;#0x5d36
    69dc:	b0 12 c2 69 	call	#27074		;#0x69c2

000069e0 <.Loc.516.2>:
}
    69e0:	03 43       	nop			
    69e2:	30 41       	ret			

000069e4 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    69e4:	b0 12 bc 80 	call	#32956		;#0x80bc

000069e8 <.Loc.59.3>:
}
    69e8:	03 43       	nop			
    69ea:	30 41       	ret			

000069ec <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    69ec:	21 83       	decd	r1		;

000069ee <.LCFI3>:
    69ee:	81 4c 00 00 	mov	r12,	0(r1)	;

000069f2 <.Loc.70.3>:

  adcp->state    = ADC_STOP;
    69f2:	2c 41       	mov	@r1,	r12	;
    69f4:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000069f8 <.Loc.71.3>:
  adcp->config   = NULL;
    69f8:	2c 41       	mov	@r1,	r12	;
    69fa:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

000069fe <.Loc.72.3>:
  adcp->samples  = NULL;
    69fe:	2c 41       	mov	@r1,	r12	;
    6a00:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006a04 <.Loc.73.3>:
  adcp->depth    = 0;
    6a04:	2c 41       	mov	@r1,	r12	;
    6a06:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006a0a <.Loc.74.3>:
  adcp->grpp     = NULL;
    6a0a:	2c 41       	mov	@r1,	r12	;
    6a0c:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00006a10 <.Loc.76.3>:
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    6a10:	2c 41       	mov	@r1,	r12	;
    6a12:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00006a16 <.Loc.84.3>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    6a16:	03 43       	nop			
    6a18:	21 53       	incd	r1		;
    6a1a:	30 41       	ret			

00006a1c <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    6a1c:	21 82       	sub	#4,	r1	;r2 As==10

00006a1e <.LCFI4>:
    6a1e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a22:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a26 <.Loc.99.3>:

  osalDbgCheck(adcp != NULL);

  osalSysLock();
    6a26:	b0 12 cc 69 	call	#27084		;#0x69cc

00006a2a <.Loc.102.3>:
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    6a2a:	1c 41 02 00 	mov	2(r1),	r12	;
    6a2e:	ac 41 02 00 	mov	@r1,	2(r12)	;

00006a32 <.Loc.103.3>:
  adc_lld_start(adcp);
    6a32:	1c 41 02 00 	mov	2(r1),	r12	;
    6a36:	b0 12 d6 80 	call	#32982		;#0x80d6

00006a3a <.Loc.104.3>:
  adcp->state = ADC_READY;
    6a3a:	1c 41 02 00 	mov	2(r1),	r12	;
    6a3e:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00006a42 <.Loc.105.3>:
  osalSysUnlock();
    6a42:	b0 12 d8 69 	call	#27096		;#0x69d8

00006a46 <.Loc.106.3>:
}
    6a46:	03 43       	nop			
    6a48:	21 52       	add	#4,	r1	;r2 As==10
    6a4a:	30 41       	ret			

00006a4c <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
    6a4c:	31 82       	sub	#8,	r1	;r2 As==11

00006a4e <.LCFI6>:
    6a4e:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a52:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a56:	81 4e 02 00 	mov	r14,	2(r1)	;
    6a5a:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a5e <.Loc.152.3>:

  osalSysLock();
    6a5e:	b0 12 cc 69 	call	#27084		;#0x69cc

00006a62 <.Loc.153.3>:
  adcStartConversionI(adcp, grpp, samples, depth);
    6a62:	2f 41       	mov	@r1,	r15	;
    6a64:	1e 41 02 00 	mov	2(r1),	r14	;
    6a68:	1d 41 04 00 	mov	4(r1),	r13	;
    6a6c:	1c 41 06 00 	mov	6(r1),	r12	;
    6a70:	b0 12 7e 6a 	call	#27262		;#0x6a7e

00006a74 <.Loc.154.3>:
  osalSysUnlock();
    6a74:	b0 12 d8 69 	call	#27096		;#0x69d8

00006a78 <.Loc.155.3>:
}
    6a78:	03 43       	nop			
    6a7a:	31 52       	add	#8,	r1	;r2 As==11
    6a7c:	30 41       	ret			

00006a7e <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
    6a7e:	31 82       	sub	#8,	r1	;r2 As==11

00006a80 <.LCFI7>:
    6a80:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a84:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a88:	81 4e 02 00 	mov	r14,	2(r1)	;
    6a8c:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a90 <.Loc.180.3>:

  osalDbgCheckClassI();
    6a90:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00006a94 <.Loc.188.3>:
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
    6a94:	1c 41 06 00 	mov	6(r1),	r12	;
    6a98:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6a9c:	04 00 

00006a9e <.Loc.189.3>:
  adcp->depth    = depth;
    6a9e:	1c 41 06 00 	mov	6(r1),	r12	;
    6aa2:	ac 41 06 00 	mov	@r1,	6(r12)	;

00006aa6 <.Loc.190.3>:
  adcp->grpp     = grpp;
    6aa6:	1c 41 06 00 	mov	6(r1),	r12	;
    6aaa:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6aae:	08 00 

00006ab0 <.Loc.191.3>:
  adcp->state    = ADC_ACTIVE;
    6ab0:	1c 41 06 00 	mov	6(r1),	r12	;
    6ab4:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6ab8:	00 00 

00006aba <.Loc.192.3>:
  adc_lld_start_conversion(adcp);
    6aba:	1c 41 06 00 	mov	6(r1),	r12	;
    6abe:	b0 12 70 81 	call	#33136		;#0x8170

00006ac2 <.Loc.193.3>:
}
    6ac2:	03 43       	nop			
    6ac4:	31 52       	add	#8,	r1	;r2 As==11
    6ac6:	30 41       	ret			

00006ac8 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6ac8:	32 c2       	dint			

00006aca <.Loc.348.1>:
  asm volatile("nop");
    6aca:	03 43       	nop			

00006acc <.Loc.349.1>:
}
    6acc:	03 43       	nop			
    6ace:	30 41       	ret			

00006ad0 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6ad0:	03 43       	nop			

00006ad2 <.Loc.356.1>:
  _enable_interrupts();
    6ad2:	32 d2       	eint			
    6ad4:	03 43       	nop			

00006ad6 <.Loc.357.1>:
}
    6ad6:	03 43       	nop			
    6ad8:	30 41       	ret			

00006ada <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6ada:	b0 12 c8 6a 	call	#27336		;#0x6ac8
    6ade:	b0 12 16 5d 	call	#23830		;#0x5d16

00006ae2 <.Loc.505.2>:
}
    6ae2:	03 43       	nop			
    6ae4:	30 41       	ret			

00006ae6 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6ae6:	b0 12 36 5d 	call	#23862		;#0x5d36
    6aea:	b0 12 d0 6a 	call	#27344		;#0x6ad0

00006aee <.Loc.516.2>:
}
    6aee:	03 43       	nop			
    6af0:	30 41       	ret			

00006af2 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    6af2:	21 83       	decd	r1		;

00006af4 <.LCFI0>:
    6af4:	81 4c 00 00 	mov	r12,	0(r1)	;

00006af8 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    6af8:	2c 41       	mov	@r1,	r12	;
    6afa:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    6afe:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006b02 <.Loc.811.2>:
  esp->cb    = NULL;
    6b02:	2c 41       	mov	@r1,	r12	;
    6b04:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006b08 <.Loc.812.2>:
  esp->param = NULL;
    6b08:	2c 41       	mov	@r1,	r12	;
    6b0a:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006b0e <.Loc.813.2>:
}
    6b0e:	03 43       	nop			
    6b10:	21 53       	incd	r1		;
    6b12:	30 41       	ret			

00006b14 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6b14:	0a 15       	pushm	#1,	r10	;16-bit words

00006b16 <.LCFI1>:
    6b16:	31 80 06 00 	sub	#6,	r1	;

00006b1a <.LCFI2>:
    6b1a:	81 4c 04 00 	mov	r12,	4(r1)	;
    6b1e:	81 4d 00 00 	mov	r13,	0(r1)	;
    6b22:	81 4e 02 00 	mov	r14,	2(r1)	;

00006b26 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6b26:	1c 41 04 00 	mov	4(r1),	r12	;
    6b2a:	1d 4c 02 00 	mov	2(r12),	r13	;
    6b2e:	2c 4c       	mov	@r12,	r12	;
    6b30:	2a 41       	mov	@r1,	r10	;
    6b32:	0a dc       	bis	r12,	r10	;
    6b34:	1b 41 02 00 	mov	2(r1),	r11	;
    6b38:	0b dd       	bis	r13,	r11	;
    6b3a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b3e:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6b42:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006b46 <.Loc.829.2>:
  if (esp->cb != NULL) {
    6b46:	1c 41 04 00 	mov	4(r1),	r12	;
    6b4a:	1c 4c 04 00 	mov	4(r12),	r12	;
    6b4e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b50:	07 24       	jz	$+16     	;abs 0x6b60

00006b52 <.Loc.830.2>:
    esp->cb(esp);
    6b52:	1c 41 04 00 	mov	4(r1),	r12	;
    6b56:	1d 4c 04 00 	mov	4(r12),	r13	;
    6b5a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b5e:	8d 12       	call	r13		;

00006b60 <.L9>:
  }
}
    6b60:	03 43       	nop			
    6b62:	31 50 06 00 	add	#6,	r1	;
    6b66:	0a 17       	popm	#1,	r10	;16-bit words
    6b68:	30 41       	ret			

00006b6a <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    6b6a:	31 80 06 00 	sub	#6,	r1	;

00006b6e <.LCFI3>:
    6b6e:	81 4c 04 00 	mov	r12,	4(r1)	;
    6b72:	81 4d 02 00 	mov	r13,	2(r1)	;
    6b76:	81 4e 00 00 	mov	r14,	0(r1)	;

00006b7a <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    6b7a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b7e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6b82:	4f 43       	clr.b	r15		;
    6b84:	2e 41       	mov	@r1,	r14	;
    6b86:	1d 41 02 00 	mov	2(r1),	r13	;
    6b8a:	b0 12 8c 68 	call	#26764		;#0x688c

00006b8e <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    6b8e:	31 50 06 00 	add	#6,	r1	;
    6b92:	30 41       	ret			

00006b94 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    6b94:	31 80 06 00 	sub	#6,	r1	;

00006b98 <.LCFI4>:
    6b98:	81 4c 04 00 	mov	r12,	4(r1)	;
    6b9c:	81 4d 02 00 	mov	r13,	2(r1)	;
    6ba0:	81 4e 00 00 	mov	r14,	0(r1)	;

00006ba4 <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    6ba4:	1c 41 04 00 	mov	4(r1),	r12	;
    6ba8:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6bac:	4f 43       	clr.b	r15		;
    6bae:	2e 41       	mov	@r1,	r14	;
    6bb0:	1d 41 02 00 	mov	2(r1),	r13	;
    6bb4:	b0 12 b8 65 	call	#26040		;#0x65b8

00006bb8 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    6bb8:	31 50 06 00 	add	#6,	r1	;
    6bbc:	30 41       	ret			

00006bbe <put>:

static msg_t put(void *ip, uint8_t b) {
    6bbe:	21 82       	sub	#4,	r1	;r2 As==10

00006bc0 <.LCFI5>:
    6bc0:	81 4c 02 00 	mov	r12,	2(r1)	;
    6bc4:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006bc8 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    6bc8:	1c 41 02 00 	mov	2(r1),	r12	;
    6bcc:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6bd0:	4e 43       	clr.b	r14		;
    6bd2:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6bd6:	b0 12 50 67 	call	#26448		;#0x6750

00006bda <.Loc.65.3>:
}
    6bda:	21 52       	add	#4,	r1	;r2 As==10
    6bdc:	30 41       	ret			

00006bde <get>:

static msg_t get(void *ip) {
    6bde:	21 83       	decd	r1		;

00006be0 <.LCFI6>:
    6be0:	81 4c 00 00 	mov	r12,	0(r1)	;

00006be4 <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    6be4:	2c 41       	mov	@r1,	r12	;
    6be6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6bea:	4d 43       	clr.b	r13		;
    6bec:	b0 12 08 65 	call	#25864		;#0x6508

00006bf0 <.Loc.70.3>:
}
    6bf0:	21 53       	incd	r1		;
    6bf2:	30 41       	ret			

00006bf4 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    6bf4:	31 80 06 00 	sub	#6,	r1	;

00006bf8 <.LCFI7>:
    6bf8:	81 4c 04 00 	mov	r12,	4(r1)	;
    6bfc:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6c00:	81 4e 00 00 	mov	r14,	0(r1)	;

00006c04 <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    6c04:	1c 41 04 00 	mov	4(r1),	r12	;
    6c08:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6c0c:	2e 41       	mov	@r1,	r14	;
    6c0e:	5d 41 03 00 	mov.b	3(r1),	r13	;
    6c12:	b0 12 50 67 	call	#26448		;#0x6750

00006c16 <.Loc.75.3>:
}
    6c16:	31 50 06 00 	add	#6,	r1	;
    6c1a:	30 41       	ret			

00006c1c <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    6c1c:	21 82       	sub	#4,	r1	;r2 As==10

00006c1e <.LCFI8>:
    6c1e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6c22:	81 4d 00 00 	mov	r13,	0(r1)	;

00006c26 <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    6c26:	1c 41 02 00 	mov	2(r1),	r12	;
    6c2a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6c2e:	2d 41       	mov	@r1,	r13	;
    6c30:	b0 12 08 65 	call	#25864		;#0x6508

00006c34 <.Loc.80.3>:
}
    6c34:	21 52       	add	#4,	r1	;r2 As==10
    6c36:	30 41       	ret			

00006c38 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    6c38:	31 82       	sub	#8,	r1	;r2 As==11

00006c3a <.LCFI9>:
    6c3a:	81 4c 06 00 	mov	r12,	6(r1)	;
    6c3e:	81 4d 04 00 	mov	r13,	4(r1)	;
    6c42:	81 4e 02 00 	mov	r14,	2(r1)	;
    6c46:	81 4f 00 00 	mov	r15,	0(r1)	;

00006c4a <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    6c4a:	1c 41 06 00 	mov	6(r1),	r12	;
    6c4e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6c52:	2f 41       	mov	@r1,	r15	;
    6c54:	1e 41 02 00 	mov	2(r1),	r14	;
    6c58:	1d 41 04 00 	mov	4(r1),	r13	;
    6c5c:	b0 12 8c 68 	call	#26764		;#0x688c

00006c60 <.Loc.85.3>:
}
    6c60:	31 52       	add	#8,	r1	;r2 As==11
    6c62:	30 41       	ret			

00006c64 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    6c64:	31 82       	sub	#8,	r1	;r2 As==11

00006c66 <.LCFI10>:
    6c66:	81 4c 06 00 	mov	r12,	6(r1)	;
    6c6a:	81 4d 04 00 	mov	r13,	4(r1)	;
    6c6e:	81 4e 02 00 	mov	r14,	2(r1)	;
    6c72:	81 4f 00 00 	mov	r15,	0(r1)	;

00006c76 <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    6c76:	1c 41 06 00 	mov	6(r1),	r12	;
    6c7a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6c7e:	2f 41       	mov	@r1,	r15	;
    6c80:	1e 41 02 00 	mov	2(r1),	r14	;
    6c84:	1d 41 04 00 	mov	4(r1),	r13	;
    6c88:	b0 12 b8 65 	call	#26040		;#0x65b8

00006c8c <.Loc.90.3>:
}
    6c8c:	31 52       	add	#8,	r1	;r2 As==11
    6c8e:	30 41       	ret			

00006c90 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    6c90:	b0 12 da 73 	call	#29658		;#0x73da

00006c94 <.Loc.111.3>:
}
    6c94:	03 43       	nop			
    6c96:	30 41       	ret			

00006c98 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    6c98:	31 82       	sub	#8,	r1	;r2 As==11

00006c9a <.LCFI11>:
    6c9a:	81 4c 06 00 	mov	r12,	6(r1)	;
    6c9e:	81 4d 04 00 	mov	r13,	4(r1)	;
    6ca2:	81 4e 02 00 	mov	r14,	2(r1)	;

00006ca6 <.Loc.130.3>:

  sdp->vmt = &vmt;
    6ca6:	1c 41 06 00 	mov	6(r1),	r12	;
    6caa:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    6cae:	00 00 

00006cb0 <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    6cb0:	1c 41 06 00 	mov	6(r1),	r12	;
    6cb4:	2c 53       	incd	r12		;
    6cb6:	b0 12 f2 6a 	call	#27378		;#0x6af2

00006cba <.Loc.132.3>:
  sdp->state = SD_STOP;
    6cba:	1c 41 06 00 	mov	6(r1),	r12	;
    6cbe:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

00006cc2 <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    6cc2:	1c 41 06 00 	mov	6(r1),	r12	;
    6cc6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6cca:	1d 41 06 00 	mov	6(r1),	r13	;
    6cce:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    6cd2:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6cd6:	00 00 
    6cd8:	1f 41 04 00 	mov	4(r1),	r15	;
    6cdc:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6ce0:	b0 12 fc 63 	call	#25596		;#0x63fc

00006ce4 <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    6ce4:	1c 41 06 00 	mov	6(r1),	r12	;
    6ce8:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6cec:	1d 41 06 00 	mov	6(r1),	r13	;
    6cf0:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    6cf4:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6cf8:	00 00 
    6cfa:	1f 41 02 00 	mov	2(r1),	r15	;
    6cfe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6d02:	b0 12 e6 66 	call	#26342		;#0x66e6

00006d06 <.Loc.135.3>:
}
    6d06:	03 43       	nop			
    6d08:	31 52       	add	#8,	r1	;r2 As==11
    6d0a:	30 41       	ret			

00006d0c <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    6d0c:	21 82       	sub	#4,	r1	;r2 As==10

00006d0e <.LCFI12>:
    6d0e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6d12:	81 4d 00 00 	mov	r13,	0(r1)	;

00006d16 <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    6d16:	b0 12 da 6a 	call	#27354		;#0x6ada

00006d1a <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    6d1a:	2d 41       	mov	@r1,	r13	;
    6d1c:	1c 41 02 00 	mov	2(r1),	r12	;
    6d20:	b0 12 ec 73 	call	#29676		;#0x73ec

00006d24 <.Loc.155.3>:
  sdp->state = SD_READY;
    6d24:	1c 41 02 00 	mov	2(r1),	r12	;
    6d28:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00006d2c <.Loc.156.3>:
  osalSysUnlock();
    6d2c:	b0 12 e6 6a 	call	#27366		;#0x6ae6

00006d30 <.Loc.157.3>:
}
    6d30:	03 43       	nop			
    6d32:	21 52       	add	#4,	r1	;r2 As==10
    6d34:	30 41       	ret			

00006d36 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    6d36:	21 82       	sub	#4,	r1	;r2 As==10

00006d38 <.LCFI14>:
    6d38:	81 4c 02 00 	mov	r12,	2(r1)	;
    6d3c:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006d40 <.Loc.204.3>:

  osalDbgCheckClassI();
    6d40:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00006d44 <.Loc.207.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    6d44:	1c 41 02 00 	mov	2(r1),	r12	;
    6d48:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    6d4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d4e:	07 20       	jnz	$+16     	;abs 0x6d5e

00006d50 <.Loc.208.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    6d50:	1c 41 02 00 	mov	2(r1),	r12	;
    6d54:	2c 53       	incd	r12		;
    6d56:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6d58:	4e 43       	clr.b	r14		;
    6d5a:	b0 12 14 6b 	call	#27412		;#0x6b14

00006d5e <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    6d5e:	1c 41 02 00 	mov	2(r1),	r12	;
    6d62:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6d66:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6d6a:	b0 12 64 64 	call	#25700		;#0x6464
    6d6e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d70:	08 34       	jge	$+18     	;abs 0x6d82

00006d72 <.Loc.210.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    6d72:	1c 41 02 00 	mov	2(r1),	r12	;
    6d76:	2c 53       	incd	r12		;
    6d78:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    6d7c:	4e 43       	clr.b	r14		;
    6d7e:	b0 12 14 6b 	call	#27412		;#0x6b14

00006d82 <.L33>:
}
    6d82:	03 43       	nop			
    6d84:	21 52       	add	#4,	r1	;r2 As==10
    6d86:	30 41       	ret			

00006d88 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    6d88:	21 82       	sub	#4,	r1	;r2 As==10

00006d8a <.LCFI15>:
    6d8a:	81 4c 00 00 	mov	r12,	0(r1)	;

00006d8e <.Loc.231.3>:
  msg_t  b;

  osalDbgCheckClassI();
    6d8e:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00006d92 <.Loc.234.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    6d92:	2c 41       	mov	@r1,	r12	;
    6d94:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6d98:	b0 12 04 68 	call	#26628		;#0x6804
    6d9c:	81 4c 02 00 	mov	r12,	2(r1)	;

00006da0 <.Loc.235.3>:
  if (b < MSG_OK)
    6da0:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6da4:	06 34       	jge	$+14     	;abs 0x6db2

00006da6 <.Loc.236.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    6da6:	2c 41       	mov	@r1,	r12	;
    6da8:	2c 53       	incd	r12		;
    6daa:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6dac:	4e 43       	clr.b	r14		;
    6dae:	b0 12 14 6b 	call	#27412		;#0x6b14

00006db2 <.L35>:
  return b;
    6db2:	1c 41 02 00 	mov	2(r1),	r12	;

00006db6 <.Loc.238.3>:
}
    6db6:	21 52       	add	#4,	r1	;r2 As==10
    6db8:	30 41       	ret			

00006dba <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    6dba:	b0 12 46 7b 	call	#31558		;#0x7b46

00006dbe <.Loc.59.3>:
}
    6dbe:	03 43       	nop			
    6dc0:	30 41       	ret			

00006dc2 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    6dc2:	21 83       	decd	r1		;

00006dc4 <.LCFI1>:
    6dc4:	81 4c 00 00 	mov	r12,	0(r1)	;

00006dc8 <.Loc.70.3>:

  spip->state = SPI_STOP;
    6dc8:	2c 41       	mov	@r1,	r12	;
    6dca:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00006dce <.Loc.71.3>:
  spip->config = NULL;
    6dce:	2c 41       	mov	@r1,	r12	;
    6dd0:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006dd4 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    6dd4:	2c 41       	mov	@r1,	r12	;
    6dd6:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006dda <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    6dda:	03 43       	nop			
    6ddc:	21 53       	incd	r1		;
    6dde:	30 41       	ret			

00006de0 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    6de0:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6de4:	5c 01 

00006de6 <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    6de6:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    6dea:	60 01 

00006dec <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    6dec:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    6df0:	62 01 

00006df2 <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    6df2:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    6df6:	64 01 

00006df8 <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    6df8:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00006dfc <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    6dfc:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    6e00:	68 01 

00006e02 <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    6e02:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    6e06:	6c 01 

00006e08 <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    6e08:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00006e0c <.Loc.87.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    6e0c:	b0 12 72 78 	call	#30834		;#0x7872

00006e10 <.Loc.89.1>:
#endif
}
    6e10:	03 43       	nop			
    6e12:	30 41       	ret			

00006e14 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6e14:	03 43       	nop			
    6e16:	30 41       	ret			

00006e18 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6e18:	03 43       	nop			
    6e1a:	30 41       	ret			

00006e1c <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6e1c:	b0 12 14 6e 	call	#28180		;#0x6e14
    6e20:	b0 12 58 5d 	call	#23896		;#0x5d58

00006e24 <.Loc.527.2>:
}
    6e24:	03 43       	nop			
    6e26:	30 41       	ret			

00006e28 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6e28:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    6e2c:	b0 12 18 6e 	call	#28184		;#0x6e18

00006e30 <.Loc.538.2>:
}
    6e30:	03 43       	nop			
    6e32:	30 41       	ret			

00006e34 <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    6e34:	b0 12 08 5f 	call	#24328		;#0x5f08

00006e38 <.Loc.597.2>:
}
    6e38:	03 43       	nop			
    6e3a:	30 41       	ret			

00006e3c <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    6e3c:	bf 15       	pushm	#12,	r15	;16-bit words

00006e3e <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    6e3e:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    6e42:	b0 12 9e 5d 	call	#23966		;#0x5d9e

00006e46 <.Loc.170.3>:
  
  osalSysLockFromISR();
    6e46:	b0 12 1c 6e 	call	#28188		;#0x6e1c

00006e4a <.Loc.171.3>:
  osalOsTimerHandlerI();
    6e4a:	b0 12 34 6e 	call	#28212		;#0x6e34

00006e4e <.Loc.172.3>:
  osalSysUnlockFromISR();
    6e4e:	b0 12 28 6e 	call	#28200		;#0x6e28

00006e52 <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    6e52:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    6e56:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    6e5a:	b0 12 16 5d 	call	#23830		;#0x5d16
    6e5e:	b0 12 4c 60 	call	#24652		;#0x604c
    6e62:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6e66:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e68:	02 24       	jz	$+6      	;abs 0x6e6e

00006e6a <.Loc.174.3>:
    6e6a:	b0 12 68 60 	call	#24680		;#0x6068

00006e6e <.L7>:
    6e6e:	b0 12 36 5d 	call	#23862		;#0x5d36

00006e72 <.Loc.175.3>:
}
    6e72:	03 43       	nop			
    6e74:	b4 17       	popm	#12,	r15	;16-bit words
    6e76:	00 13       	reti			

00006e78 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    6e78:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    6e7c:	d2 03 

00006e7e <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    6e7e:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    6e82:	c2 03 

00006e84 <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    6e84:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00006e88 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    6e88:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    6e8c:	c0 03 

00006e8e <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    6e8e:	03 43       	nop			
    6e90:	30 41       	ret			

00006e92 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6e92:	03 43       	nop			
    6e94:	30 41       	ret			

00006e96 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6e96:	03 43       	nop			
    6e98:	30 41       	ret			

00006e9a <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6e9a:	b0 12 92 6e 	call	#28306		;#0x6e92
    6e9e:	b0 12 58 5d 	call	#23896		;#0x5d58

00006ea2 <.Loc.527.2>:
}
    6ea2:	03 43       	nop			
    6ea4:	30 41       	ret			

00006ea6 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6ea6:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    6eaa:	b0 12 96 6e 	call	#28310		;#0x6e96

00006eae <.Loc.538.2>:
}
    6eae:	03 43       	nop			
    6eb0:	30 41       	ret			

00006eb2 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6eb2:	0a 15       	pushm	#1,	r10	;16-bit words

00006eb4 <.LCFI0>:
    6eb4:	31 80 06 00 	sub	#6,	r1	;

00006eb8 <.LCFI1>:
    6eb8:	81 4c 04 00 	mov	r12,	4(r1)	;
    6ebc:	81 4d 00 00 	mov	r13,	0(r1)	;
    6ec0:	81 4e 02 00 	mov	r14,	2(r1)	;

00006ec4 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6ec4:	1c 41 04 00 	mov	4(r1),	r12	;
    6ec8:	1d 4c 02 00 	mov	2(r12),	r13	;
    6ecc:	2c 4c       	mov	@r12,	r12	;
    6ece:	2a 41       	mov	@r1,	r10	;
    6ed0:	0a dc       	bis	r12,	r10	;
    6ed2:	1b 41 02 00 	mov	2(r1),	r11	;
    6ed6:	0b dd       	bis	r13,	r11	;
    6ed8:	1c 41 04 00 	mov	4(r1),	r12	;
    6edc:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6ee0:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006ee4 <.Loc.829.2>:
  if (esp->cb != NULL) {
    6ee4:	1c 41 04 00 	mov	4(r1),	r12	;
    6ee8:	1c 4c 04 00 	mov	4(r12),	r12	;
    6eec:	0c 93       	cmp	#0,	r12	;r3 As==00
    6eee:	07 24       	jz	$+16     	;abs 0x6efe

00006ef0 <.Loc.830.2>:
    esp->cb(esp);
    6ef0:	1c 41 04 00 	mov	4(r1),	r12	;
    6ef4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6ef8:	1c 41 04 00 	mov	4(r1),	r12	;
    6efc:	8d 12       	call	r13		;

00006efe <.L7>:
  }
}
    6efe:	03 43       	nop			
    6f00:	31 50 06 00 	add	#6,	r1	;
    6f04:	0a 17       	popm	#1,	r10	;16-bit words
    6f06:	30 41       	ret			

00006f08 <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    6f08:	21 83       	decd	r1		;

00006f0a <.LCFI2>:
    6f0a:	81 4c 00 00 	mov	r12,	0(r1)	;

00006f0e <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    6f0e:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    6f12:	2c 91       	cmp	@r1,	r12	;
    6f14:	02 28       	jnc	$+6      	;abs 0x6f1a

00006f16 <.Loc.108.3>:
    return 0x00;
    6f16:	4c 43       	clr.b	r12		;
    6f18:	ec 3c       	jmp	$+474    	;abs 0x70f2

00006f1a <.L9>:
  else if (frac < 715)
    6f1a:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    6f1e:	2c 91       	cmp	@r1,	r12	;
    6f20:	02 28       	jnc	$+6      	;abs 0x6f26

00006f22 <.Loc.110.3>:
    return 0x01;
    6f22:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6f24:	e6 3c       	jmp	$+462    	;abs 0x70f2

00006f26 <.L11>:
  else if (frac < 835)
    6f26:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    6f2a:	2c 91       	cmp	@r1,	r12	;
    6f2c:	02 28       	jnc	$+6      	;abs 0x6f32

00006f2e <.Loc.112.3>:
    return 0x02;
    6f2e:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6f30:	e0 3c       	jmp	$+450    	;abs 0x70f2

00006f32 <.L12>:
  else if (frac < 1001)
    6f32:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    6f36:	2c 91       	cmp	@r1,	r12	;
    6f38:	02 28       	jnc	$+6      	;abs 0x6f3e

00006f3a <.Loc.114.3>:
    return 0x04;
    6f3a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6f3c:	da 3c       	jmp	$+438    	;abs 0x70f2

00006f3e <.L13>:
  else if (frac < 1252)
    6f3e:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    6f42:	2c 91       	cmp	@r1,	r12	;
    6f44:	02 28       	jnc	$+6      	;abs 0x6f4a

00006f46 <.Loc.116.3>:
    return 0x08;
    6f46:	7c 42       	mov.b	#8,	r12	;r2 As==11
    6f48:	d4 3c       	jmp	$+426    	;abs 0x70f2

00006f4a <.L14>:
  else if (frac < 1430)
    6f4a:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    6f4e:	2c 91       	cmp	@r1,	r12	;
    6f50:	03 28       	jnc	$+8      	;abs 0x6f58

00006f52 <.Loc.118.3>:
    return 0x10;
    6f52:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6f56:	cd 3c       	jmp	$+412    	;abs 0x70f2

00006f58 <.L15>:
  else if (frac < 1670)
    6f58:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    6f5c:	2c 91       	cmp	@r1,	r12	;
    6f5e:	03 28       	jnc	$+8      	;abs 0x6f66

00006f60 <.Loc.120.3>:
    return 0x20;
    6f60:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    6f64:	c6 3c       	jmp	$+398    	;abs 0x70f2

00006f66 <.L16>:
  else if (frac < 2147)
    6f66:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    6f6a:	2c 91       	cmp	@r1,	r12	;
    6f6c:	03 28       	jnc	$+8      	;abs 0x6f74

00006f6e <.Loc.122.3>:
    return 0x11;
    6f6e:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    6f72:	bf 3c       	jmp	$+384    	;abs 0x70f2

00006f74 <.L17>:
  else if (frac < 2224)
    6f74:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    6f78:	2c 91       	cmp	@r1,	r12	;
    6f7a:	03 28       	jnc	$+8      	;abs 0x6f82

00006f7c <.Loc.124.3>:
    return 0x21;
    6f7c:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    6f80:	b8 3c       	jmp	$+370    	;abs 0x70f2

00006f82 <.L18>:
  else if (frac < 2503)
    6f82:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    6f86:	2c 91       	cmp	@r1,	r12	;
    6f88:	03 28       	jnc	$+8      	;abs 0x6f90

00006f8a <.Loc.126.3>:
    return 0x22;
    6f8a:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    6f8e:	b1 3c       	jmp	$+356    	;abs 0x70f2

00006f90 <.L19>:
  else if (frac < 3000)
    6f90:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    6f94:	2c 91       	cmp	@r1,	r12	;
    6f96:	03 28       	jnc	$+8      	;abs 0x6f9e

00006f98 <.Loc.128.3>:
    return 0x44;
    6f98:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    6f9c:	aa 3c       	jmp	$+342    	;abs 0x70f2

00006f9e <.L20>:
  else if (frac < 3335)
    6f9e:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    6fa2:	2c 91       	cmp	@r1,	r12	;
    6fa4:	03 28       	jnc	$+8      	;abs 0x6fac

00006fa6 <.Loc.130.3>:
    return 0x25;
    6fa6:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    6faa:	a3 3c       	jmp	$+328    	;abs 0x70f2

00006fac <.L21>:
  else if (frac < 3575)
    6fac:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    6fb0:	2c 91       	cmp	@r1,	r12	;
    6fb2:	03 28       	jnc	$+8      	;abs 0x6fba

00006fb4 <.Loc.132.3>:
    return 0x49;
    6fb4:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    6fb8:	9c 3c       	jmp	$+314    	;abs 0x70f2

00006fba <.L22>:
  else if (frac < 3753)
    6fba:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    6fbe:	2c 91       	cmp	@r1,	r12	;
    6fc0:	03 28       	jnc	$+8      	;abs 0x6fc8

00006fc2 <.Loc.134.3>:
    return 0x4A;
    6fc2:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    6fc6:	95 3c       	jmp	$+300    	;abs 0x70f2

00006fc8 <.L23>:
  else if (frac < 4003)
    6fc8:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    6fcc:	2c 91       	cmp	@r1,	r12	;
    6fce:	03 28       	jnc	$+8      	;abs 0x6fd6

00006fd0 <.Loc.136.3>:
    return 0x52;
    6fd0:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    6fd4:	8e 3c       	jmp	$+286    	;abs 0x70f2

00006fd6 <.L24>:
  else if (frac < 4286)
    6fd6:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    6fda:	2c 91       	cmp	@r1,	r12	;
    6fdc:	03 28       	jnc	$+8      	;abs 0x6fe4

00006fde <.Loc.138.3>:
    return 0x92;
    6fde:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    6fe2:	87 3c       	jmp	$+272    	;abs 0x70f2

00006fe4 <.L25>:
  else if (frac < 4378)
    6fe4:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    6fe8:	2c 91       	cmp	@r1,	r12	;
    6fea:	03 28       	jnc	$+8      	;abs 0x6ff2

00006fec <.Loc.140.3>:
    return 0x53;
    6fec:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    6ff0:	80 3c       	jmp	$+258    	;abs 0x70f2

00006ff2 <.L26>:
  else if (frac < 5002)
    6ff2:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    6ff6:	2c 91       	cmp	@r1,	r12	;
    6ff8:	03 28       	jnc	$+8      	;abs 0x7000

00006ffa <.Loc.142.3>:
    return 0x55;
    6ffa:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    6ffe:	79 3c       	jmp	$+244    	;abs 0x70f2

00007000 <.L27>:
  else if (frac < 5715)
    7000:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    7004:	2c 91       	cmp	@r1,	r12	;
    7006:	03 28       	jnc	$+8      	;abs 0x700e

00007008 <.Loc.144.3>:
    return 0xAA;
    7008:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    700c:	72 3c       	jmp	$+230    	;abs 0x70f2

0000700e <.L28>:
  else if (frac < 6003)
    700e:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    7012:	2c 91       	cmp	@r1,	r12	;
    7014:	03 28       	jnc	$+8      	;abs 0x701c

00007016 <.Loc.146.3>:
    return 0x6B;
    7016:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    701a:	6b 3c       	jmp	$+216    	;abs 0x70f2

0000701c <.L29>:
  else if (frac < 6254)
    701c:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    7020:	2c 91       	cmp	@r1,	r12	;
    7022:	03 28       	jnc	$+8      	;abs 0x702a

00007024 <.Loc.148.3>:
    return 0xAD;
    7024:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    7028:	64 3c       	jmp	$+202    	;abs 0x70f2

0000702a <.L30>:
  else if (frac < 6432)
    702a:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    702e:	2c 91       	cmp	@r1,	r12	;
    7030:	03 28       	jnc	$+8      	;abs 0x7038

00007032 <.Loc.150.3>:
    return 0xB5;
    7032:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    7036:	5d 3c       	jmp	$+188    	;abs 0x70f2

00007038 <.L31>:
  else if (frac < 6667)
    7038:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    703c:	2c 91       	cmp	@r1,	r12	;
    703e:	03 28       	jnc	$+8      	;abs 0x7046

00007040 <.Loc.152.3>:
    return 0xB6;
    7040:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    7044:	56 3c       	jmp	$+174    	;abs 0x70f2

00007046 <.L32>:
  else if (frac < 7001)
    7046:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    704a:	2c 91       	cmp	@r1,	r12	;
    704c:	03 28       	jnc	$+8      	;abs 0x7054

0000704e <.Loc.154.3>:
    return 0xD6;
    704e:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    7052:	4f 3c       	jmp	$+160    	;abs 0x70f2

00007054 <.L33>:
  else if (frac < 7147)
    7054:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    7058:	2c 91       	cmp	@r1,	r12	;
    705a:	03 28       	jnc	$+8      	;abs 0x7062

0000705c <.Loc.156.3>:
    return 0xB7;
    705c:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    7060:	48 3c       	jmp	$+146    	;abs 0x70f2

00007062 <.L34>:
  else if (frac < 7503)
    7062:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    7066:	2c 91       	cmp	@r1,	r12	;
    7068:	03 28       	jnc	$+8      	;abs 0x7070

0000706a <.Loc.158.3>:
    return 0xBB;
    706a:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    706e:	41 3c       	jmp	$+132    	;abs 0x70f2

00007070 <.L35>:
  else if (frac < 7861)
    7070:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    7074:	2c 91       	cmp	@r1,	r12	;
    7076:	03 28       	jnc	$+8      	;abs 0x707e

00007078 <.Loc.160.3>:
    return 0xDD;
    7078:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    707c:	3a 3c       	jmp	$+118    	;abs 0x70f2

0000707e <.L36>:
  else if (frac < 8004)
    707e:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    7082:	2c 91       	cmp	@r1,	r12	;
    7084:	03 28       	jnc	$+8      	;abs 0x708c

00007086 <.Loc.162.3>:
    return 0xED;
    7086:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    708a:	33 3c       	jmp	$+104    	;abs 0x70f2

0000708c <.L37>:
  else if (frac < 8333)
    708c:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    7090:	2c 91       	cmp	@r1,	r12	;
    7092:	03 28       	jnc	$+8      	;abs 0x709a

00007094 <.Loc.164.3>:
    return 0xEE;
    7094:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    7098:	2c 3c       	jmp	$+90     	;abs 0x70f2

0000709a <.L38>:
  else if (frac < 8464)
    709a:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    709e:	2c 91       	cmp	@r1,	r12	;
    70a0:	03 28       	jnc	$+8      	;abs 0x70a8

000070a2 <.Loc.166.3>:
    return 0xBF;
    70a2:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    70a6:	25 3c       	jmp	$+76     	;abs 0x70f2

000070a8 <.L39>:
  else if (frac < 8572)
    70a8:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    70ac:	2c 91       	cmp	@r1,	r12	;
    70ae:	03 28       	jnc	$+8      	;abs 0x70b6

000070b0 <.Loc.168.3>:
    return 0xDF;
    70b0:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    70b4:	1e 3c       	jmp	$+62     	;abs 0x70f2

000070b6 <.L40>:
  else if (frac < 8751)
    70b6:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    70ba:	2c 91       	cmp	@r1,	r12	;
    70bc:	03 28       	jnc	$+8      	;abs 0x70c4

000070be <.Loc.170.3>:
    return 0xEF;
    70be:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    70c2:	17 3c       	jmp	$+48     	;abs 0x70f2

000070c4 <.L41>:
  else if (frac < 9004)
    70c4:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    70c8:	2c 91       	cmp	@r1,	r12	;
    70ca:	03 28       	jnc	$+8      	;abs 0x70d2

000070cc <.Loc.172.3>:
    return 0xF7;
    70cc:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    70d0:	10 3c       	jmp	$+34     	;abs 0x70f2

000070d2 <.L42>:
  else if (frac < 9170)
    70d2:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    70d6:	2c 91       	cmp	@r1,	r12	;
    70d8:	03 28       	jnc	$+8      	;abs 0x70e0

000070da <.Loc.174.3>:
    return 0xFB;
    70da:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    70de:	09 3c       	jmp	$+20     	;abs 0x70f2

000070e0 <.L43>:
  else if (frac < 9288)
    70e0:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    70e4:	2c 91       	cmp	@r1,	r12	;
    70e6:	03 28       	jnc	$+8      	;abs 0x70ee

000070e8 <.Loc.176.3>:
    return 0xFD;
    70e8:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    70ec:	02 3c       	jmp	$+6      	;abs 0x70f2

000070ee <.L44>:
  else
    return 0xFE;
    70ee:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000070f2 <.L10>:
}
    70f2:	21 53       	incd	r1		;
    70f4:	30 41       	ret			

000070f6 <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    70f6:	0a 15       	pushm	#1,	r10	;16-bit words

000070f8 <.LCFI3>:
    70f8:	31 80 0c 00 	sub	#12,	r1	;#0x000c

000070fc <.LCFI4>:
    70fc:	81 4c 04 00 	mov	r12,	4(r1)	;
    7100:	81 4d 06 00 	mov	r13,	6(r1)	;
    7104:	81 4e 00 00 	mov	r14,	0(r1)	;
    7108:	81 4f 02 00 	mov	r15,	2(r1)	;

0000710c <.Loc.191.3>:

  uint16_t n = freq / baud;
    710c:	1e 41 04 00 	mov	4(r1),	r14	;
    7110:	1f 41 06 00 	mov	6(r1),	r15	;
    7114:	2c 41       	mov	@r1,	r12	;
    7116:	1d 41 02 00 	mov	2(r1),	r13	;
    711a:	b0 12 00 8c 	call	#35840		;#0x8c00
    711e:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007122 <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    7122:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7126:	0c 4e       	mov	r14,	r12	;
    7128:	0d 43       	clr	r13		;
    712a:	1e 41 04 00 	mov	4(r1),	r14	;
    712e:	1f 41 06 00 	mov	6(r1),	r15	;
    7132:	b0 12 cc 8d 	call	#36300		;#0x8dcc
    7136:	0e 4c       	mov	r12,	r14	;
    7138:	0f 4d       	mov	r13,	r15	;
    713a:	2c 41       	mov	@r1,	r12	;

0000713c <L0>:
    713c:	1d 41 02 00 	mov	2(r1),	r13	;
    7140:	0c 8e       	sub	r14,	r12	;
    7142:	0d 7f       	subc	r15,	r13	;
    7144:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    7148:	4f 43       	clr.b	r15		;
    714a:	b0 12 cc 8d 	call	#36300		;#0x8dcc
    714e:	1e 41 04 00 	mov	4(r1),	r14	;
    7152:	1f 41 06 00 	mov	6(r1),	r15	;
    7156:	b0 12 00 8c 	call	#35840		;#0x8c00
    715a:	81 4c 08 00 	mov	r12,	8(r1)	;

0000715e <.Loc.194.3>:
  if (n > 16) {
    715e:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7162:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7166:	19 2c       	jc	$+52     	;abs 0x719a

00007168 <.Loc.195.3>:
    while (n > 16) {
    7168:	03 3c       	jmp	$+8      	;abs 0x7170

0000716a <.L48>:
      n -= 16;
    716a:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    716e:	0a 00 

00007170 <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    7170:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7174:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7178:	f8 2b       	jnc	$-14     	;abs 0x716a

0000717a <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    717a:	1c 41 08 00 	mov	8(r1),	r12	;
    717e:	b0 12 08 6f 	call	#28424		;#0x6f08
    7182:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7186:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    718a:	0a 4c       	mov	r12,	r10	;
    718c:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7190:	b0 12 32 8c 	call	#35890		;#0x8c32
    7194:	0c da       	bis	r10,	r12	;
    7196:	1c d3       	bis	#1,	r12	;r3 As==01
    7198:	08 3c       	jmp	$+18     	;abs 0x71aa

0000719a <.L46>:
  }
  return UCBRS(frac) << 8;
    719a:	1c 41 08 00 	mov	8(r1),	r12	;
    719e:	b0 12 08 6f 	call	#28424		;#0x6f08
    71a2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    71a6:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

000071aa <.L49>:
}
    71aa:	31 50 0c 00 	add	#12,	r1	;#0x000c
    71ae:	0a 17       	popm	#1,	r10	;16-bit words
    71b0:	30 41       	ret			

000071b2 <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    71b2:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000071b6 <L0>:
    71b6:	81 4c 04 00 	mov	r12,	4(r1)	;
    71ba:	81 4d 06 00 	mov	r13,	6(r1)	;
    71be:	81 4e 00 00 	mov	r14,	0(r1)	;
    71c2:	81 4f 02 00 	mov	r15,	2(r1)	;

000071c6 <.Loc.212.3>:
  uint16_t n = freq / baud;
    71c6:	1e 41 04 00 	mov	4(r1),	r14	;
    71ca:	1f 41 06 00 	mov	6(r1),	r15	;
    71ce:	2c 41       	mov	@r1,	r12	;
    71d0:	1d 41 02 00 	mov	2(r1),	r13	;
    71d4:	b0 12 00 8c 	call	#35840		;#0x8c00
    71d8:	81 4c 08 00 	mov	r12,	8(r1)	;

000071dc <.Loc.213.3>:
  if (n > 16) {
    71dc:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    71e0:	1c 91 08 00 	cmp	8(r1),	r12	;
    71e4:	05 2c       	jc	$+12     	;abs 0x71f0

000071e6 <.Loc.214.3>:
    return n >> 4;
    71e6:	1c 41 08 00 	mov	8(r1),	r12	;
    71ea:	b0 12 30 8d 	call	#36144		;#0x8d30
    71ee:	02 3c       	jmp	$+6      	;abs 0x71f4

000071f0 <.L51>:
  }
  return n;
    71f0:	1c 41 08 00 	mov	8(r1),	r12	;

000071f4 <.L52>:
}
    71f4:	31 50 0a 00 	add	#10,	r1	;#0x000a
    71f8:	30 41       	ret			

000071fa <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    71fa:	21 83       	decd	r1		;

000071fc <L0>:
    71fc:	81 4c 00 00 	mov	r12,	0(r1)	;

00007200 <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7200:	2c 41       	mov	@r1,	r12	;
    7202:	1d 4c 02 00 	mov	2(r12),	r13	;
    7206:	2c 4c       	mov	@r12,	r12	;
    7208:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    720c:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7210:	b0 12 b2 71 	call	#29106		;#0x71b2
    7214:	82 4c c6 05 	mov	r12,	&0x05c6	;

00007218 <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    7218:	2c 41       	mov	@r1,	r12	;
    721a:	1d 4c 02 00 	mov	2(r12),	r13	;
    721e:	2c 4c       	mov	@r12,	r12	;
    7220:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    7224:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7228:	b0 12 f6 70 	call	#28918		;#0x70f6
    722c:	82 4c c8 05 	mov	r12,	&0x05c8	;

00007230 <.Loc.223.3>:
  UCA0STATW = 0;
    7230:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

00007234 <.Loc.224.3>:
  UCA0ABCTL = 0;
    7234:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

00007238 <.Loc.225.3>:
  UCA0IRCTL = 0;
    7238:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

0000723c <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    723c:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    7240:	c0 05 

00007242 <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    7242:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

00007246 <.Loc.230.3>:
}
    7246:	03 43       	nop			
    7248:	21 53       	incd	r1		;
    724a:	30 41       	ret			

0000724c <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    724c:	21 83       	decd	r1		;

0000724e <.LCFI7>:
    724e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007252 <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    7252:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7256:	2c d3       	bis	#2,	r12	;r3 As==10
    7258:	82 4c da 05 	mov	r12,	&0x05da	;

0000725c <.Loc.280.3>:
}
    725c:	03 43       	nop			
    725e:	21 53       	incd	r1		;
    7260:	30 41       	ret			

00007262 <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    7262:	31 82       	sub	#8,	r1	;r2 As==11

00007264 <.LCFI8>:
    7264:	81 4c 02 00 	mov	r12,	2(r1)	;
    7268:	81 4d 00 00 	mov	r13,	0(r1)	;

0000726c <.Loc.314.3>:
  eventflags_t sts = 0;
    726c:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7270:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00007274 <.Loc.316.3>:

  if (sra & UCOE)
    7274:	1c 41 02 00 	mov	2(r1),	r12	;
    7278:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    727c:	0c 93       	cmp	#0,	r12	;r3 As==00
    727e:	05 24       	jz	$+12     	;abs 0x728a

00007280 <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    7280:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    7284:	04 00 
    7286:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

0000728a <.L56>:
  if (sra & UCPE)
    728a:	1c 41 02 00 	mov	2(r1),	r12	;
    728e:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7292:	0c 93       	cmp	#0,	r12	;r3 As==00
    7294:	05 24       	jz	$+12     	;abs 0x72a0

00007296 <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    7296:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    729a:	04 00 
    729c:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000072a0 <.L57>:
  if (sra & UCFE)
    72a0:	1c 41 02 00 	mov	2(r1),	r12	;
    72a4:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    72a8:	0c 93       	cmp	#0,	r12	;r3 As==00
    72aa:	05 24       	jz	$+12     	;abs 0x72b6

000072ac <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    72ac:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    72b0:	04 00 
    72b2:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000072b6 <.L58>:
  osalSysLockFromISR();
    72b6:	b0 12 9a 6e 	call	#28314		;#0x6e9a

000072ba <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    72ba:	2c 41       	mov	@r1,	r12	;
    72bc:	2c 53       	incd	r12		;
    72be:	1d 41 04 00 	mov	4(r1),	r13	;
    72c2:	1e 41 06 00 	mov	6(r1),	r14	;
    72c6:	b0 12 b2 6e 	call	#28338		;#0x6eb2

000072ca <.Loc.324.3>:
  osalSysUnlockFromISR();
    72ca:	b0 12 a6 6e 	call	#28326		;#0x6ea6

000072ce <.Loc.325.3>:
}
    72ce:	03 43       	nop			
    72d0:	31 52       	add	#8,	r1	;r2 As==11
    72d2:	30 41       	ret			

000072d4 <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    72d4:	bf 15       	pushm	#12,	r15	;16-bit words

000072d6 <.LCFI9>:
    72d6:	21 83       	decd	r1		;

000072d8 <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    72d8:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    72dc:	b0 12 9e 5d 	call	#23966		;#0x5d9e

000072e0 <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    72e0:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    72e4:	2c 92       	cmp	#4,	r12	;r2 As==10
    72e6:	1e 24       	jz	$+62     	;abs 0x7324
    72e8:	3c 92       	cmp	#8,	r12	;r2 As==11
    72ea:	40 24       	jz	$+130    	;abs 0x736c
    72ec:	2c 93       	cmp	#2,	r12	;r3 As==10
    72ee:	01 24       	jz	$+4      	;abs 0x72f2

000072f0 <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    72f0:	60 3c       	jmp	$+194    	;abs 0x73b2

000072f2 <.L63>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    72f2:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    72f6:	6c f2       	and.b	#4,	r12	;r2 As==10
    72f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    72fa:	06 24       	jz	$+14     	;abs 0x7308

000072fc <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    72fc:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7300:	3d 40 7c 52 	mov	#21116,	r13	;#0x527c
    7304:	b0 12 62 72 	call	#29282		;#0x7262

00007308 <.L64>:

    /* Data available */
    osalSysLockFromISR();
    7308:	b0 12 9a 6e 	call	#28314		;#0x6e9a

0000730c <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    730c:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    7310:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7314:	4d 4c       	mov.b	r12,	r13	;
    7316:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    731a:	b0 12 36 6d 	call	#27958		;#0x6d36

0000731e <.Loc.352.3>:
    osalSysUnlockFromISR();
    731e:	b0 12 a6 6e 	call	#28326		;#0x6ea6

00007322 <.Loc.353.3>:
    break;
    7322:	47 3c       	jmp	$+144    	;abs 0x73b2

00007324 <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    7324:	b0 12 9a 6e 	call	#28314		;#0x6e9a

00007328 <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    7328:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    732c:	b0 12 88 6d 	call	#28040		;#0x6d88
    7330:	81 4c 00 00 	mov	r12,	0(r1)	;

00007334 <.Loc.360.3>:
    if (b < Q_OK) {
    7334:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7338:	13 34       	jge	$+40     	;abs 0x7360

0000733a <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    733a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    733c:	4e 43       	clr.b	r14		;
    733e:	3c 40 7e 52 	mov	#21118,	r12	;#0x527e
    7342:	b0 12 b2 6e 	call	#28338		;#0x6eb2

00007346 <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    7346:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    734a:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    734e:	3c d2       	bis	#8,	r12	;r2 As==11
    7350:	82 4c da 05 	mov	r12,	&0x05da	;

00007354 <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    7354:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    7358:	2c d3       	bis	#2,	r12	;r3 As==10
    735a:	82 4c dc 05 	mov	r12,	&0x05dc	;
    735e:	03 3c       	jmp	$+8      	;abs 0x7366

00007360 <.L66>:
    }
    else
      UCA0TXBUF = b;
    7360:	2c 41       	mov	@r1,	r12	;
    7362:	82 4c ce 05 	mov	r12,	&0x05ce	;

00007366 <.L67>:
    osalSysUnlockFromISR();
    7366:	b0 12 a6 6e 	call	#28326		;#0x6ea6

0000736a <.Loc.368.3>:
    break;
    736a:	23 3c       	jmp	$+72     	;abs 0x73b2

0000736c <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    736c:	b0 12 9a 6e 	call	#28314		;#0x6e9a

00007370 <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    7370:	1d 42 a0 52 	mov	&0x52a0,r13	;0x52a0
    7374:	1c 42 a2 52 	mov	&0x52a2,r12	;0x52a2
    7378:	0d 9c       	cmp	r12,	r13	;
    737a:	06 20       	jnz	$+14     	;abs 0x7388

0000737c <.Loc.374.3>:
    737c:	1c 42 9a 52 	mov	&0x529a,r12	;0x529a
    7380:	0c 93       	cmp	#0,	r12	;r3 As==00
    7382:	02 24       	jz	$+6      	;abs 0x7388

00007384 <.Loc.374.3>:
    7384:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7386:	01 3c       	jmp	$+4      	;abs 0x738a

00007388 <.L68>:
    7388:	4c 43       	clr.b	r12		;

0000738a <.L69>:
    738a:	5c f3       	and.b	#1,	r12	;r3 As==01
    738c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7390:	0c 93       	cmp	#0,	r12	;r3 As==00
    7392:	07 24       	jz	$+16     	;abs 0x73a2

00007394 <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    7394:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    7398:	4e 43       	clr.b	r14		;
    739a:	3c 40 7e 52 	mov	#21118,	r12	;#0x527e
    739e:	b0 12 b2 6e 	call	#28338		;#0x6eb2

000073a2 <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    73a2:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    73a6:	3c c2       	bic	#8,	r12	;r2 As==11
    73a8:	82 4c da 05 	mov	r12,	&0x05da	;

000073ac <.Loc.377.3>:
    osalSysUnlockFromISR();
    73ac:	b0 12 a6 6e 	call	#28326		;#0x6ea6

000073b0 <.Loc.378.3>:
    break;
    73b0:	03 43       	nop			

000073b2 <.L65>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    73b2:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    73b6:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    73ba:	b0 12 16 5d 	call	#23830		;#0x5d16
    73be:	b0 12 4c 60 	call	#24652		;#0x604c
    73c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    73c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    73c8:	02 24       	jz	$+6      	;abs 0x73ce

000073ca <.Loc.385.3>:
    73ca:	b0 12 68 60 	call	#24680		;#0x6068

000073ce <.L71>:
    73ce:	b0 12 36 5d 	call	#23862		;#0x5d36

000073d2 <.Loc.386.3>:
}
    73d2:	03 43       	nop			
    73d4:	21 53       	incd	r1		;
    73d6:	b4 17       	popm	#12,	r15	;16-bit words
    73d8:	00 13       	reti			

000073da <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    73da:	3e 40 4c 72 	mov	#29260,	r14	;#0x724c
    73de:	4d 43       	clr.b	r13		;
    73e0:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c

000073e4 <L0>:
    73e4:	b0 12 98 6c 	call	#27800		;#0x6c98

000073e8 <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    73e8:	03 43       	nop			
    73ea:	30 41       	ret			

000073ec <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    73ec:	21 82       	sub	#4,	r1	;r2 As==10

000073ee <.LCFI11>:
    73ee:	81 4c 02 00 	mov	r12,	2(r1)	;
    73f2:	81 4d 00 00 	mov	r13,	0(r1)	;

000073f6 <.Loc.603.3>:

  if (config == NULL) {
    73f6:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    73fa:	03 20       	jnz	$+8      	;abs 0x7402

000073fc <.Loc.604.3>:
    config = &default_config;
    73fc:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7400:	00 00 

00007402 <.L74>:
  }

  if (sdp->state == SD_STOP) {
    7402:	1c 41 02 00 	mov	2(r1),	r12	;
    7406:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    740a:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    740c:	07 20       	jnz	$+16     	;abs 0x741c

0000740e <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    740e:	b1 90 7c 52 	cmp	#21116,	2(r1)	;#0x527c
    7412:	02 00 
    7414:	03 20       	jnz	$+8      	;abs 0x741c

00007416 <.Loc.610.3>:
      usart0_init(config);
    7416:	2c 41       	mov	@r1,	r12	;
    7418:	b0 12 fa 71 	call	#29178		;#0x71fa

0000741c <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    741c:	03 43       	nop			
    741e:	21 52       	add	#4,	r1	;r2 As==10
    7420:	30 41       	ret			

00007422 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    7422:	bf 15       	pushm	#12,	r15	;16-bit words

00007424 <.LCFI0>:
    7424:	21 82       	sub	#4,	r1	;r2 As==10

00007426 <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7426:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    742a:	b0 12 9e 5d 	call	#23966		;#0x5d9e

0000742e <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    742e:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    7432:	12 c3       	clrc			
    7434:	0c 10       	rrc	r12		;
    7436:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    743a:	4d 4c       	mov.b	r12,	r13	;
    743c:	7d 53       	add.b	#-1,	r13	;r3 As==11
    743e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007442 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    7442:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7446:	0c 5c       	rla	r12		;
    7448:	3c 50 c8 52 	add	#21192,	r12	;#0x52c8
    744c:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007450 <.Loc.80.1>:
  if (cb != NULL) {
    7450:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7454:	02 24       	jz	$+6      	;abs 0x745a

00007456 <.Loc.81.1>:
    (*cb)();
    7456:	2c 41       	mov	@r1,	r12	;
    7458:	8c 12       	call	r12		;

0000745a <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    745a:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    745e:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    7462:	b0 12 16 5d 	call	#23830		;#0x5d16
    7466:	b0 12 4c 60 	call	#24652		;#0x604c
    746a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    746e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7470:	02 24       	jz	$+6      	;abs 0x7476

00007472 <.Loc.84.1>:
    7472:	b0 12 68 60 	call	#24680		;#0x6068

00007476 <.L3>:
    7476:	b0 12 36 5d 	call	#23862		;#0x5d36

0000747a <.Loc.85.1>:
}
    747a:	03 43       	nop			
    747c:	21 52       	add	#4,	r1	;r2 As==10
    747e:	b4 17       	popm	#12,	r15	;16-bit words
    7480:	00 13       	reti			

00007482 <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    7482:	bf 15       	pushm	#12,	r15	;16-bit words

00007484 <.LCFI2>:
    7484:	21 82       	sub	#4,	r1	;r2 As==10

00007486 <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7486:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    748a:	b0 12 9e 5d 	call	#23966		;#0x5d9e

0000748e <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    748e:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    7492:	12 c3       	clrc			
    7494:	0c 10       	rrc	r12		;
    7496:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    749a:	4d 4c       	mov.b	r12,	r13	;
    749c:	7d 53       	add.b	#-1,	r13	;r3 As==11
    749e:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000074a2 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    74a2:	5c 41 03 00 	mov.b	3(r1),	r12	;
    74a6:	3c 52       	add	#8,	r12	;r2 As==11
    74a8:	0c 5c       	rla	r12		;
    74aa:	3c 50 c8 52 	add	#21192,	r12	;#0x52c8
    74ae:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000074b2 <.Loc.98.1>:
  if (cb != NULL) {
    74b2:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    74b6:	02 24       	jz	$+6      	;abs 0x74bc

000074b8 <.Loc.99.1>:
    (*cb)();
    74b8:	2c 41       	mov	@r1,	r12	;
    74ba:	8c 12       	call	r12		;

000074bc <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    74bc:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    74c0:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    74c4:	b0 12 16 5d 	call	#23830		;#0x5d16
    74c8:	b0 12 4c 60 	call	#24652		;#0x604c
    74cc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    74d0:	0c 93       	cmp	#0,	r12	;r3 As==00
    74d2:	02 24       	jz	$+6      	;abs 0x74d8

000074d4 <.Loc.102.1>:
    74d4:	b0 12 68 60 	call	#24680		;#0x6068

000074d8 <.L6>:
    74d8:	b0 12 36 5d 	call	#23862		;#0x5d36

000074dc <.Loc.103.1>:
}
    74dc:	03 43       	nop			
    74de:	21 52       	add	#4,	r1	;r2 As==10
    74e0:	b4 17       	popm	#12,	r15	;16-bit words
    74e2:	00 13       	reti			

000074e4 <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    74e4:	bf 15       	pushm	#12,	r15	;16-bit words

000074e6 <.LCFI4>:
    74e6:	21 82       	sub	#4,	r1	;r2 As==10

000074e8 <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    74e8:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    74ec:	b0 12 9e 5d 	call	#23966		;#0x5d9e

000074f0 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    74f0:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    74f4:	12 c3       	clrc			
    74f6:	0c 10       	rrc	r12		;
    74f8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    74fc:	4d 4c       	mov.b	r12,	r13	;
    74fe:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7500:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007504 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    7504:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7508:	3c 50 10 00 	add	#16,	r12	;#0x0010
    750c:	0c 5c       	rla	r12		;
    750e:	3c 50 c8 52 	add	#21192,	r12	;#0x52c8
    7512:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007516 <.Loc.117.1>:
  if (cb != NULL) {
    7516:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    751a:	02 24       	jz	$+6      	;abs 0x7520

0000751c <.Loc.118.1>:
    (*cb)();
    751c:	2c 41       	mov	@r1,	r12	;
    751e:	8c 12       	call	r12		;

00007520 <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7520:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    7524:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    7528:	b0 12 16 5d 	call	#23830		;#0x5d16
    752c:	b0 12 4c 60 	call	#24652		;#0x604c
    7530:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7534:	0c 93       	cmp	#0,	r12	;r3 As==00
    7536:	02 24       	jz	$+6      	;abs 0x753c

00007538 <.Loc.121.1>:
    7538:	b0 12 68 60 	call	#24680		;#0x6068

0000753c <.L9>:
    753c:	b0 12 36 5d 	call	#23862		;#0x5d36

00007540 <.Loc.122.1>:
}
    7540:	03 43       	nop			
    7542:	21 52       	add	#4,	r1	;r2 As==10
    7544:	b4 17       	popm	#12,	r15	;16-bit words
    7546:	00 13       	reti			

00007548 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    7548:	bf 15       	pushm	#12,	r15	;16-bit words

0000754a <.LCFI6>:
    754a:	21 82       	sub	#4,	r1	;r2 As==10

0000754c <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    754c:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    7550:	b0 12 9e 5d 	call	#23966		;#0x5d9e

00007554 <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    7554:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    7558:	12 c3       	clrc			
    755a:	0c 10       	rrc	r12		;
    755c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7560:	4d 4c       	mov.b	r12,	r13	;
    7562:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7564:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007568 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    7568:	5c 41 03 00 	mov.b	3(r1),	r12	;
    756c:	3c 50 18 00 	add	#24,	r12	;#0x0018
    7570:	0c 5c       	rla	r12		;
    7572:	3c 50 c8 52 	add	#21192,	r12	;#0x52c8
    7576:	a1 4c 00 00 	mov	@r12,	0(r1)	;

0000757a <.Loc.135.1>:
  if (cb != NULL) {
    757a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    757e:	02 24       	jz	$+6      	;abs 0x7584

00007580 <.Loc.136.1>:
    (*cb)();
    7580:	2c 41       	mov	@r1,	r12	;
    7582:	8c 12       	call	r12		;

00007584 <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7584:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    7588:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    758c:	b0 12 16 5d 	call	#23830		;#0x5d16
    7590:	b0 12 4c 60 	call	#24652		;#0x604c
    7594:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7598:	0c 93       	cmp	#0,	r12	;r3 As==00
    759a:	02 24       	jz	$+6      	;abs 0x75a0

0000759c <.Loc.139.1>:
    759c:	b0 12 68 60 	call	#24680		;#0x6068

000075a0 <.L12>:
    75a0:	b0 12 36 5d 	call	#23862		;#0x5d36

000075a4 <.Loc.140.1>:
}
    75a4:	03 43       	nop			
    75a6:	21 52       	add	#4,	r1	;r2 As==10
    75a8:	b4 17       	popm	#12,	r15	;16-bit words
    75aa:	00 13       	reti			

000075ac <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    75ac:	21 83       	decd	r1		;

000075ae <.LCFI8>:
    75ae:	81 4c 00 00 	mov	r12,	0(r1)	;

000075b2 <.Loc.309.1>:

  PAOUT = config->porta.out;
    75b2:	2c 41       	mov	@r1,	r12	;
    75b4:	2c 4c       	mov	@r12,	r12	;
    75b6:	82 4c 02 02 	mov	r12,	&0x0202	;

000075ba <.Loc.310.1>:
  PADIR = config->porta.dir;
    75ba:	2c 41       	mov	@r1,	r12	;
    75bc:	1c 4c 02 00 	mov	2(r12),	r12	;
    75c0:	82 4c 04 02 	mov	r12,	&0x0204	;

000075c4 <.Loc.311.1>:
  PAREN = config->porta.ren;
    75c4:	2c 41       	mov	@r1,	r12	;
    75c6:	1c 4c 04 00 	mov	4(r12),	r12	;
    75ca:	82 4c 06 02 	mov	r12,	&0x0206	;

000075ce <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    75ce:	2c 41       	mov	@r1,	r12	;
    75d0:	1c 4c 06 00 	mov	6(r12),	r12	;
    75d4:	82 4c 0a 02 	mov	r12,	&0x020a	;

000075d8 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    75d8:	2c 41       	mov	@r1,	r12	;
    75da:	1c 4c 08 00 	mov	8(r12),	r12	;
    75de:	82 4c 0c 02 	mov	r12,	&0x020c	;

000075e2 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    75e2:	2c 41       	mov	@r1,	r12	;
    75e4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    75e8:	82 4c 22 02 	mov	r12,	&0x0222	;

000075ec <.Loc.316.1>:
  PBDIR = config->portb.dir;
    75ec:	2c 41       	mov	@r1,	r12	;
    75ee:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    75f2:	82 4c 24 02 	mov	r12,	&0x0224	;

000075f6 <.Loc.317.1>:
  PBREN = config->portb.ren;
    75f6:	2c 41       	mov	@r1,	r12	;
    75f8:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    75fc:	82 4c 26 02 	mov	r12,	&0x0226	;

00007600 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7600:	2c 41       	mov	@r1,	r12	;
    7602:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    7606:	82 4c 2a 02 	mov	r12,	&0x022a	;

0000760a <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    760a:	2c 41       	mov	@r1,	r12	;
    760c:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7610:	82 4c 2c 02 	mov	r12,	&0x022c	;

00007614 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    7614:	2c 41       	mov	@r1,	r12	;
    7616:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    761a:	82 4c 22 03 	mov	r12,	&0x0322	;

0000761e <.Loc.350.1>:
  PJDIR = config->portj.dir;
    761e:	2c 41       	mov	@r1,	r12	;
    7620:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    7624:	82 4c 24 03 	mov	r12,	&0x0324	;

00007628 <.Loc.351.1>:
  PJREN = config->portj.ren;
    7628:	2c 41       	mov	@r1,	r12	;
    762a:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    762e:	82 4c 26 03 	mov	r12,	&0x0326	;

00007632 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    7632:	2c 41       	mov	@r1,	r12	;
    7634:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    7638:	82 4c 2a 03 	mov	r12,	&0x032a	;

0000763c <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    763c:	2c 41       	mov	@r1,	r12	;
    763e:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    7642:	82 4c 2c 03 	mov	r12,	&0x032c	;

00007646 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    7646:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    764a:	1c c3       	bic	#1,	r12	;r3 As==01
    764c:	82 4c 30 01 	mov	r12,	&0x0130	;

00007650 <.Loc.356.1>:
}
    7650:	03 43       	nop			
    7652:	21 53       	incd	r1		;
    7654:	30 41       	ret			

00007656 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7656:	03 43       	nop			
    7658:	30 41       	ret			

0000765a <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    765a:	03 43       	nop			
    765c:	30 41       	ret			

0000765e <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    765e:	b0 12 56 76 	call	#30294		;#0x7656
    7662:	b0 12 58 5d 	call	#23896		;#0x5d58

00007666 <.Loc.527.2>:
}
    7666:	03 43       	nop			
    7668:	30 41       	ret			

0000766a <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    766a:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    766e:	b0 12 5a 76 	call	#30298		;#0x765a

00007672 <.Loc.538.2>:
}
    7672:	03 43       	nop			
    7674:	30 41       	ret			

00007676 <osalSysGetStatusAndLockX>:
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {

  return chSysGetStatusAndLockX();
    7676:	b0 12 96 5f 	call	#24470		;#0x5f96

0000767a <.Loc.556.2>:
}
    767a:	30 41       	ret			

0000767c <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
    767c:	21 83       	decd	r1		;

0000767e <.LCFI0>:
    767e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007682 <.Loc.569.2>:

  chSysRestoreStatusX(sts);
    7682:	2c 41       	mov	@r1,	r12	;
    7684:	b0 12 d2 5f 	call	#24530		;#0x5fd2

00007688 <.Loc.570.2>:
}
    7688:	03 43       	nop			
    768a:	21 53       	incd	r1		;
    768c:	30 41       	ret			

0000768e <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    768e:	21 83       	decd	r1		;

00007690 <.LCFI1>:
    7690:	81 4c 00 00 	mov	r12,	0(r1)	;

00007694 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    7694:	2c 41       	mov	@r1,	r12	;
    7696:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

0000769a <.Loc.768.2>:
}
    769a:	03 43       	nop			
    769c:	21 53       	incd	r1		;
    769e:	30 41       	ret			

000076a0 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    76a0:	21 82       	sub	#4,	r1	;r2 As==10

000076a2 <.LCFI2>:
    76a2:	81 4c 02 00 	mov	r12,	2(r1)	;
    76a6:	81 4d 00 00 	mov	r13,	0(r1)	;

000076aa <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    76aa:	1c 41 02 00 	mov	2(r1),	r12	;
    76ae:	2d 41       	mov	@r1,	r13	;
    76b0:	b0 12 64 61 	call	#24932		;#0x6164

000076b4 <.Loc.797.2>:
}
    76b4:	21 52       	add	#4,	r1	;r2 As==10
    76b6:	30 41       	ret			

000076b8 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    76b8:	0a 15       	pushm	#1,	r10	;16-bit words

000076ba <.LCFI3>:
    76ba:	21 82       	sub	#4,	r1	;r2 As==10

000076bc <.LCFI4>:
    76bc:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    76c0:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

000076c4 <.Loc.63.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    76c4:	5c 41 01 00 	mov.b	1(r1),	r12	;
    76c8:	12 c3       	clrc			
    76ca:	0c 10       	rrc	r12		;
    76cc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76d0:	0c 5c       	rla	r12		;
    76d2:	0d 4c       	mov	r12,	r13	;
    76d4:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    76d8:	81 4d 02 00 	mov	r13,	2(r1)	;

000076dc <.Loc.64.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    76dc:	1c 41 02 00 	mov	2(r1),	r12	;
    76e0:	2a 4c       	mov	@r12,	r10	;
    76e2:	5c 41 01 00 	mov.b	1(r1),	r12	;
    76e6:	5c f3       	and.b	#1,	r12	;r3 As==01
    76e8:	0d 4c       	mov	r12,	r13	;
    76ea:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    76ee:	3c 40 00 ff 	mov	#65280,	r12	;#0xff00
    76f2:	b0 12 48 8d 	call	#36168		;#0x8d48
    76f6:	0d 4a       	mov	r10,	r13	;
    76f8:	0d fc       	and	r12,	r13	;
    76fa:	1c 41 02 00 	mov	2(r1),	r12	;
    76fe:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007702 <.Loc.65.3>:
  *ctl |= trigger << (8 * (index % 2));
    7702:	1c 41 02 00 	mov	2(r1),	r12	;
    7706:	2a 4c       	mov	@r12,	r10	;
    7708:	6c 41       	mov.b	@r1,	r12	;
    770a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    770e:	5d f3       	and.b	#1,	r13	;r3 As==01
    7710:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7714:	b0 12 40 8c 	call	#35904		;#0x8c40
    7718:	0d 4a       	mov	r10,	r13	;
    771a:	0d dc       	bis	r12,	r13	;
    771c:	1c 41 02 00 	mov	2(r1),	r12	;
    7720:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007724 <.Loc.66.3>:
}
    7724:	03 43       	nop			
    7726:	21 52       	add	#4,	r1	;r2 As==10
    7728:	0a 17       	popm	#1,	r10	;16-bit words
    772a:	30 41       	ret			

0000772c <init_request>:
static void init_request(const msp430x_dma_req_t * request, uint8_t index) {
    772c:	31 80 06 00 	sub	#6,	r1	;

00007730 <.LCFI5>:
    7730:	81 4c 02 00 	mov	r12,	2(r1)	;
    7734:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007738 <.Loc.69.3>:

  dma_trigger_set(index, request->trigger);
    7738:	1c 41 02 00 	mov	2(r1),	r12	;
    773c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7740:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7744:	4d 4c       	mov.b	r12,	r13	;
    7746:	5c 41 01 00 	mov.b	1(r1),	r12	;
    774a:	b0 12 b8 76 	call	#30392		;#0x76b8

0000774e <.Loc.70.3>:
  callbacks[index]          = request->callback;
    774e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7752:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7756:	3c 50 08 53 	add	#21256,	r12	;#0x5308
    775a:	1d 41 02 00 	mov	2(r1),	r13	;
    775e:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    7762:	00 00 
    7764:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    7768:	02 00 

0000776a <.Loc.71.3>:
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
    776a:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    776e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7772:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7776:	0e 4d       	mov	r13,	r14	;
    7778:	0e 5c       	add	r12,	r14	;
    777a:	81 4e 04 00 	mov	r14,	4(r1)	;

0000777e <.Loc.72.3>:
  ch->sa                    = (uintptr_t)request->source_addr;
    777e:	1c 41 02 00 	mov	2(r1),	r12	;
    7782:	2c 4c       	mov	@r12,	r12	;
    7784:	0d 43       	clr	r13		;
    7786:	1e 41 04 00 	mov	4(r1),	r14	;
    778a:	8e 4c 02 00 	mov	r12,	2(r14)	;
    778e:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007792 <.Loc.73.3>:
  ch->da                    = (uintptr_t)request->dest_addr;
    7792:	1c 41 02 00 	mov	2(r1),	r12	;
    7796:	1c 4c 02 00 	mov	2(r12),	r12	;
    779a:	0d 43       	clr	r13		;
    779c:	1e 41 04 00 	mov	4(r1),	r14	;
    77a0:	8e 4c 06 00 	mov	r12,	6(r14)	;
    77a4:	8e 4d 08 00 	mov	r13,	8(r14)	;

000077a8 <.Loc.74.3>:
  ch->sz                    = request->size;
    77a8:	1c 41 02 00 	mov	2(r1),	r12	;
    77ac:	1d 4c 04 00 	mov	4(r12),	r13	;
    77b0:	1c 41 04 00 	mov	4(r1),	r12	;
    77b4:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000077b8 <.Loc.75.3>:
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    77b8:	1c 41 02 00 	mov	2(r1),	r12	;
    77bc:	1d 4c 08 00 	mov	8(r12),	r13	;
    77c0:	1c 41 02 00 	mov	2(r1),	r12	;
    77c4:	1c 4c 06 00 	mov	6(r12),	r12	;
    77c8:	0d dc       	bis	r12,	r13	;

000077ca <.Loc.76.3>:
            request->transfer_mode;
    77ca:	1c 41 02 00 	mov	2(r1),	r12	;
    77ce:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a

000077d2 <.Loc.75.3>:
  callbacks[index]          = request->callback;
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
  ch->sa                    = (uintptr_t)request->source_addr;
  ch->da                    = (uintptr_t)request->dest_addr;
  ch->sz                    = request->size;
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    77d2:	0c dd       	bis	r13,	r12	;
    77d4:	0d 4c       	mov	r12,	r13	;
    77d6:	3d d0 15 00 	bis	#21,	r13	;#0x0015
    77da:	1c 41 04 00 	mov	4(r1),	r12	;
    77de:	8c 4d 00 00 	mov	r13,	0(r12)	;

000077e2 <.Loc.77.3>:
            request->transfer_mode;
}
    77e2:	03 43       	nop			
    77e4:	31 50 06 00 	add	#6,	r1	;
    77e8:	30 41       	ret			

000077ea <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    77ea:	bf 15       	pushm	#12,	r15	;16-bit words

000077ec <.LCFI6>:
    77ec:	21 82       	sub	#4,	r1	;r2 As==10

000077ee <.LCFI7>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    77ee:	d2 43 7a 52 	mov.b	#1,	&0x527a	;r3 As==01
    77f2:	b0 12 9e 5d 	call	#23966		;#0x5d9e

000077f6 <.Loc.87.3>:

  index = (DMAIV >> 1) - 1;
    77f6:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    77fa:	12 c3       	clrc			
    77fc:	0c 10       	rrc	r12		;
    77fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7802:	4d 4c       	mov.b	r12,	r13	;
    7804:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7806:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

0000780a <.Loc.89.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    780a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    780c:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7810:	1c 28       	jnc	$+58     	;abs 0x784a

00007812 <.LBB2>:
    osalSysLockFromISR();
    7812:	b0 12 5e 76 	call	#30302		;#0x765e

00007816 <.Loc.91.3>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7816:	4d 43       	clr.b	r13		;
    7818:	3c 40 14 53 	mov	#21268,	r12	;#0x5314
    781c:	b0 12 b6 62 	call	#25270		;#0x62b6

00007820 <.Loc.92.3>:
    osalSysUnlockFromISR();
    7820:	b0 12 6a 76 	call	#30314		;#0x766a

00007824 <.Loc.94.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    7824:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7828:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    782c:	0d 4c       	mov	r12,	r13	;
    782e:	3d 50 08 53 	add	#21256,	r13	;#0x5308
    7832:	81 4d 00 00 	mov	r13,	0(r1)	;

00007836 <.Loc.97.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    7836:	2c 41       	mov	@r1,	r12	;
    7838:	2c 4c       	mov	@r12,	r12	;
    783a:	0c 93       	cmp	#0,	r12	;r3 As==00
    783c:	06 24       	jz	$+14     	;abs 0x784a

0000783e <.Loc.98.3>:
      cb->callback(cb->args);
    783e:	2c 41       	mov	@r1,	r12	;
    7840:	2d 4c       	mov	@r12,	r13	;
    7842:	2c 41       	mov	@r1,	r12	;
    7844:	1c 4c 02 00 	mov	2(r12),	r12	;
    7848:	8d 12       	call	r13		;

0000784a <.L14>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    784a:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    784e:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    7852:	b0 12 16 5d 	call	#23830		;#0x5d16
    7856:	b0 12 4c 60 	call	#24652		;#0x604c
    785a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    785e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7860:	02 24       	jz	$+6      	;abs 0x7866

00007862 <.Loc.102.3>:
    7862:	b0 12 68 60 	call	#24680		;#0x6068

00007866 <.L15>:
    7866:	b0 12 36 5d 	call	#23862		;#0x5d36

0000786a <.Loc.103.3>:
}
    786a:	03 43       	nop			
    786c:	21 52       	add	#4,	r1	;r2 As==10
    786e:	b4 17       	popm	#12,	r15	;16-bit words
    7870:	00 13       	reti			

00007872 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    7872:	3c 40 14 53 	mov	#21268,	r12	;#0x5314
    7876:	b0 12 8e 76 	call	#30350		;#0x768e

0000787a <.Loc.116.3>:
}
    787a:	03 43       	nop			
    787c:	30 41       	ret			

0000787e <dmaRequestS>:
 *          channel is available or the request times out. If semaphores are
 *          disabled, the calling thread will busy-wait instead of sleeping.
 *          
 *  @sclass
 */
int dmaRequestS(msp430x_dma_req_t * request, systime_t timeout) {
    787e:	31 82       	sub	#8,	r1	;r2 As==11

00007880 <.LCFI8>:
    7880:	81 4c 02 00 	mov	r12,	2(r1)	;
    7884:	81 4d 00 00 	mov	r13,	0(r1)	;

00007888 <.Loc.130.3>:
  
  osalDbgCheckClassS();
    7888:	b0 12 1a 5e 	call	#24090		;#0x5e1a

0000788c <.Loc.133.3>:
  
  /* Check if a DMA channel is available */
  if (queue_length >= MSP430X_DMA_CHANNELS) {
    788c:	1d 42 16 53 	mov	&0x5316,r13	;0x5316
    7890:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7892:	0c 9d       	cmp	r13,	r12	;
    7894:	0c 2c       	jc	$+26     	;abs 0x78ae

00007896 <.LBB3>:
    msg_t queueresult = osalThreadEnqueueTimeoutS(&dma_queue, timeout);
    7896:	2d 41       	mov	@r1,	r13	;
    7898:	3c 40 14 53 	mov	#21268,	r12	;#0x5314
    789c:	b0 12 a0 76 	call	#30368		;#0x76a0
    78a0:	81 4c 04 00 	mov	r12,	4(r1)	;

000078a4 <.Loc.135.3>:
    if (queueresult != MSG_OK)
    78a4:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    78a8:	02 24       	jz	$+6      	;abs 0x78ae

000078aa <.Loc.136.3>:
      return -1;
    78aa:	3c 43       	mov	#-1,	r12	;r3 As==11
    78ac:	24 3c       	jmp	$+74     	;abs 0x78f6

000078ae <.L18>:
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
    78ae:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000078b2 <.Loc.141.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    78b2:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    78b6:	0e 3c       	jmp	$+30     	;abs 0x78d4

000078b8 <.L23>:
    if (!(dma_channels[i].ctl & DMAEN)) {
    78b8:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    78bc:	1c 41 06 00 	mov	6(r1),	r12	;
    78c0:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    78c4:	0c 5d       	add	r13,	r12	;
    78c6:	2c 4c       	mov	@r12,	r12	;
    78c8:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    78cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    78ce:	07 24       	jz	$+16     	;abs 0x78de

000078d0 <.Loc.141.3>:
      return -1;
  }

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    78d0:	91 53 06 00 	inc	6(r1)		;

000078d4 <.L20>:
    78d4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    78d6:	1c 91 06 00 	cmp	6(r1),	r12	;
    78da:	ee 37       	jge	$-34     	;abs 0x78b8
    78dc:	01 3c       	jmp	$+4      	;abs 0x78e0

000078de <.L24>:
    if (!(dma_channels[i].ctl & DMAEN)) {
      break;
    78de:	03 43       	nop			

000078e0 <.L22>:
    }
  }

  /* Make the request */
  init_request(request, i);
    78e0:	1c 41 06 00 	mov	6(r1),	r12	;
    78e4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    78e8:	4d 4c       	mov.b	r12,	r13	;
    78ea:	1c 41 02 00 	mov	2(r1),	r12	;
    78ee:	b0 12 2c 77 	call	#30508		;#0x772c

000078f2 <.Loc.150.3>:
  
  return i;
    78f2:	1c 41 06 00 	mov	6(r1),	r12	;

000078f6 <.L19>:
}
    78f6:	31 52       	add	#8,	r1	;r2 As==11
    78f8:	30 41       	ret			

000078fa <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
bool dmaAcquireI(msp430x_dma_ch_t * channel, uint8_t index) {
    78fa:	21 82       	sub	#4,	r1	;r2 As==10

000078fc <.LCFI9>:
    78fc:	81 4c 02 00 	mov	r12,	2(r1)	;

00007900 <L0>:
    7900:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007904 <.Loc.170.3>:
  
  osalDbgCheckClassI();
    7904:	b0 12 fc 5d 	call	#24060		;#0x5dfc

00007908 <.Loc.174.3>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_channels[index].ctl & DMADT_4) {
    7908:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    790c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7910:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7914:	0c 5d       	add	r13,	r12	;
    7916:	2c 4c       	mov	@r12,	r12	;
    7918:	3c f0 00 40 	and	#16384,	r12	;#0x4000
    791c:	0c 93       	cmp	#0,	r12	;r3 As==00
    791e:	02 24       	jz	$+6      	;abs 0x7924

00007920 <.Loc.175.3>:
    return true;
    7920:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7922:	46 3c       	jmp	$+142    	;abs 0x79b0

00007924 <.L26>:
  }

  /* Increment the DMA counter */
  queue_length++;
    7924:	1c 42 16 53 	mov	&0x5316,r12	;0x5316
    7928:	1c 53       	inc	r12		;
    792a:	82 4c 16 53 	mov	r12,	&0x5316	;

0000792e <.Loc.181.3>:

  while (dma_channels[index].ctl & DMAEN)
    792e:	03 43       	nop			

00007930 <.L28>:
    7930:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7934:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7938:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    793c:	0c 5d       	add	r13,	r12	;
    793e:	2c 4c       	mov	@r12,	r12	;
    7940:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7944:	0c 93       	cmp	#0,	r12	;r3 As==00
    7946:	f4 23       	jnz	$-22     	;abs 0x7930

00007948 <.Loc.185.3>:
    ;

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    7948:	4d 43       	clr.b	r13		;
    794a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    794e:	b0 12 b8 76 	call	#30392		;#0x76b8

00007952 <.Loc.186.3>:
  dma_channels[index].sz  = 0;
    7952:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7956:	5c 41 01 00 	mov.b	1(r1),	r12	;
    795a:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    795e:	0c 5d       	add	r13,	r12	;
    7960:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007964 <.Loc.187.3>:
  dma_channels[index].ctl = DMAEN | DMAABORT | DMADT_4;
    7964:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7968:	5c 41 01 00 	mov.b	1(r1),	r12	;
    796c:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7970:	0c 5d       	add	r13,	r12	;
    7972:	bc 40 12 40 	mov	#16402,	0(r12)	;#0x4012
    7976:	00 00 

00007978 <.Loc.189.3>:

  channel->registers = dma_channels + index;
    7978:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    797c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7980:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7984:	0d 5c       	add	r12,	r13	;
    7986:	1c 41 02 00 	mov	2(r1),	r12	;
    798a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000798e <.Loc.190.3>:
  channel->index     = index;
    798e:	1c 41 02 00 	mov	2(r1),	r12	;
    7992:	dc 41 01 00 	mov.b	1(r1),	2(r12)	;
    7996:	02 00 

00007998 <.Loc.191.3>:
  channel->cb        = callbacks + index;
    7998:	5c 41 01 00 	mov.b	1(r1),	r12	;
    799c:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    79a0:	0d 4c       	mov	r12,	r13	;
    79a2:	3d 50 08 53 	add	#21256,	r13	;#0x5308
    79a6:	1c 41 02 00 	mov	2(r1),	r12	;
    79aa:	8c 4d 04 00 	mov	r13,	4(r12)	;

000079ae <.Loc.193.3>:
  
  return false;
    79ae:	4c 43       	clr.b	r12		;

000079b0 <.L27>:
}
    79b0:	21 52       	add	#4,	r1	;r2 As==10
    79b2:	30 41       	ret			

000079b4 <dmaTransfer>:
 * @pre     The channel must have been acquired using @p dmaAcquire().
 *
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 */
void dmaTransfer(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    79b4:	21 82       	sub	#4,	r1	;r2 As==10

000079b6 <L0>:
    79b6:	81 4c 02 00 	mov	r12,	2(r1)	;
    79ba:	81 4d 00 00 	mov	r13,	0(r1)	;

000079be <.Loc.205.3>:

  dma_trigger_set(channel->index, request->trigger);
    79be:	1c 41 02 00 	mov	2(r1),	r12	;
    79c2:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    79c6:	2d 41       	mov	@r1,	r13	;
    79c8:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    79cc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    79d0:	b0 12 b8 76 	call	#30392		;#0x76b8

000079d4 <.Loc.208.3>:
  /**(channel->ctl) = request->trigger;*/

  channel->cb->callback = request->callback.callback;
    79d4:	1c 41 02 00 	mov	2(r1),	r12	;
    79d8:	1c 4c 04 00 	mov	4(r12),	r12	;
    79dc:	2d 41       	mov	@r1,	r13	;
    79de:	1d 4d 0e 00 	mov	14(r13),r13	;0x0000e
    79e2:	8c 4d 00 00 	mov	r13,	0(r12)	;

000079e6 <.Loc.209.3>:
  channel->cb->args     = request->callback.args;
    79e6:	1c 41 02 00 	mov	2(r1),	r12	;
    79ea:	1c 4c 04 00 	mov	4(r12),	r12	;
    79ee:	2d 41       	mov	@r1,	r13	;
    79f0:	1d 4d 10 00 	mov	16(r13),r13	;0x00010
    79f4:	8c 4d 02 00 	mov	r13,	2(r12)	;

000079f8 <.Loc.211.3>:

  channel->registers->ctl &= (~DMAEN);
    79f8:	1c 41 02 00 	mov	2(r1),	r12	;
    79fc:	2c 4c       	mov	@r12,	r12	;
    79fe:	1d 41 02 00 	mov	2(r1),	r13	;
    7a02:	2d 4d       	mov	@r13,	r13	;
    7a04:	2d 4d       	mov	@r13,	r13	;
    7a06:	3d f0 ef ff 	and	#65519,	r13	;#0xffef
    7a0a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007a0e <.Loc.212.3>:
  channel->registers->sa  = (uintptr_t)request->source_addr;
    7a0e:	1c 41 02 00 	mov	2(r1),	r12	;
    7a12:	2e 4c       	mov	@r12,	r14	;
    7a14:	2c 41       	mov	@r1,	r12	;
    7a16:	2c 4c       	mov	@r12,	r12	;
    7a18:	0d 43       	clr	r13		;
    7a1a:	8e 4c 02 00 	mov	r12,	2(r14)	;
    7a1e:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007a22 <.Loc.213.3>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    7a22:	1c 41 02 00 	mov	2(r1),	r12	;
    7a26:	2e 4c       	mov	@r12,	r14	;
    7a28:	2c 41       	mov	@r1,	r12	;
    7a2a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7a2e:	0d 43       	clr	r13		;
    7a30:	8e 4c 06 00 	mov	r12,	6(r14)	;
    7a34:	8e 4d 08 00 	mov	r13,	8(r14)	;

00007a38 <.Loc.214.3>:
  channel->registers->sz  = request->size;
    7a38:	1c 41 02 00 	mov	2(r1),	r12	;
    7a3c:	2c 4c       	mov	@r12,	r12	;
    7a3e:	2d 41       	mov	@r1,	r13	;
    7a40:	1d 4d 04 00 	mov	4(r13),	r13	;
    7a44:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007a48 <.Loc.215.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7a48:	1c 41 02 00 	mov	2(r1),	r12	;
    7a4c:	2c 4c       	mov	@r12,	r12	;
    7a4e:	2d 41       	mov	@r1,	r13	;
    7a50:	1e 4d 08 00 	mov	8(r13),	r14	;
    7a54:	2d 41       	mov	@r1,	r13	;
    7a56:	1d 4d 06 00 	mov	6(r13),	r13	;
    7a5a:	0e dd       	bis	r13,	r14	;

00007a5c <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    7a5c:	2d 41       	mov	@r1,	r13	;
    7a5e:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a

00007a62 <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7a62:	0d de       	bis	r14,	r13	;

00007a64 <.Loc.216.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
    7a64:	3d d0 15 40 	bis	#16405,	r13	;#0x4015

00007a68 <.Loc.215.3>:

  channel->registers->ctl &= (~DMAEN);
  channel->registers->sa  = (uintptr_t)request->source_addr;
  channel->registers->da  = (uintptr_t)request->dest_addr;
  channel->registers->sz  = request->size;
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7a68:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007a6c <.Loc.218.3>:
                            request->transfer_mode | DMADT_4 | DMAEN |
                            DMAREQ; /* repeated transfers */
}
    7a6c:	03 43       	nop			
    7a6e:	21 52       	add	#4,	r1	;r2 As==10
    7a70:	30 41       	ret			

00007a72 <dmaRelease>:
 *          pool. Trying to release an unallocated channel is an illegal
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquire().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaRelease(msp430x_dma_ch_t * channel) {
    7a72:	21 82       	sub	#4,	r1	;r2 As==10

00007a74 <.LCFI11>:
    7a74:	81 4c 00 00 	mov	r12,	0(r1)	;

00007a78 <.Loc.232.3>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
    7a78:	b0 12 76 76 	call	#30326		;#0x7676
    7a7c:	81 4c 02 00 	mov	r12,	2(r1)	;

00007a80 <.Loc.236.3>:
  osalDbgCheck(channel != NULL);

  /* Release the channel in an idle mode */
  channel->registers->ctl = DMAABORT;
    7a80:	2c 41       	mov	@r1,	r12	;
    7a82:	2c 4c       	mov	@r12,	r12	;
    7a84:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00007a88 <.Loc.239.3>:

  /* release the DMA counter */
  osalThreadDequeueAllI(&dma_queue, MSG_RESET);
    7a88:	3d 40 fe ff 	mov	#65534,	r13	;#0xfffe
    7a8c:	3c 40 14 53 	mov	#21268,	r12	;#0x5314
    7a90:	b0 12 0e 63 	call	#25358		;#0x630e

00007a94 <.Loc.240.3>:
  queue_length = 0;
    7a94:	82 43 16 53 	mov	#0,	&0x5316	;r3 As==00

00007a98 <.Loc.241.3>:
  osalSysRestoreStatusX(sts);
    7a98:	1c 41 02 00 	mov	2(r1),	r12	;
    7a9c:	b0 12 7c 76 	call	#30332		;#0x767c

00007aa0 <.Loc.242.3>:
}
    7aa0:	03 43       	nop			
    7aa2:	21 52       	add	#4,	r1	;r2 As==10
    7aa4:	30 41       	ret			

00007aa6 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7aa6:	03 43       	nop			
    7aa8:	30 41       	ret			

00007aaa <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7aaa:	03 43       	nop			
    7aac:	30 41       	ret			

00007aae <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7aae:	b0 12 a6 7a 	call	#31398		;#0x7aa6
    7ab2:	b0 12 58 5d 	call	#23896		;#0x5d58

00007ab6 <.Loc.527.2>:
}
    7ab6:	03 43       	nop			
    7ab8:	30 41       	ret			

00007aba <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7aba:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    7abe:	b0 12 aa 7a 	call	#31402		;#0x7aaa

00007ac2 <.Loc.538.2>:
}
    7ac2:	03 43       	nop			
    7ac4:	30 41       	ret			

00007ac6 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7ac6:	21 82       	sub	#4,	r1	;r2 As==10

00007ac8 <.LCFI0>:
    7ac8:	81 4c 02 00 	mov	r12,	2(r1)	;
    7acc:	81 4d 00 00 	mov	r13,	0(r1)	;

00007ad0 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7ad0:	2d 41       	mov	@r1,	r13	;
    7ad2:	1c 41 02 00 	mov	2(r1),	r12	;
    7ad6:	b0 12 08 61 	call	#24840		;#0x6108

00007ada <.Loc.740.2>:
}
    7ada:	03 43       	nop			
    7adc:	21 52       	add	#4,	r1	;r2 As==10
    7ade:	30 41       	ret			

00007ae0 <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * spip) {
    7ae0:	21 83       	decd	r1		;

00007ae2 <.LCFI2>:
    7ae2:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ae6 <.Loc.136.3>:

  /* So that future transfers will actually work */
  *(((SPIDriver *)spip)->ifg) &= ~(UCTXIFG);
    7ae6:	2c 41       	mov	@r1,	r12	;
    7ae8:	1c 4c 08 00 	mov	8(r12),	r12	;
    7aec:	2d 41       	mov	@r1,	r13	;
    7aee:	1d 4d 08 00 	mov	8(r13),	r13	;
    7af2:	2d 4d       	mov	@r13,	r13	;
    7af4:	2d c3       	bic	#2,	r13	;r3 As==10
    7af6:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007afa <.Loc.140.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code((SPIDriver *)spip);
    7afa:	2c 41       	mov	@r1,	r12	;
    7afc:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b00:	2c 4c       	mov	@r12,	r12	;
    7b02:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b04:	11 24       	jz	$+36     	;abs 0x7b28

00007b06 <.Loc.140.3>:
    7b06:	2c 41       	mov	@r1,	r12	;
    7b08:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7b0c:	2c 41       	mov	@r1,	r12	;
    7b0e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b12:	2d 4c       	mov	@r12,	r13	;
    7b14:	2c 41       	mov	@r1,	r12	;
    7b16:	8d 12       	call	r13		;
    7b18:	2c 41       	mov	@r1,	r12	;
    7b1a:	6c 4c       	mov.b	@r12,	r12	;
    7b1c:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7b1e:	07 20       	jnz	$+16     	;abs 0x7b2e

00007b20 <.Loc.140.3>:
    7b20:	2c 41       	mov	@r1,	r12	;
    7b22:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7b26:	03 3c       	jmp	$+8      	;abs 0x7b2e

00007b28 <.L8>:
    7b28:	2c 41       	mov	@r1,	r12	;
    7b2a:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007b2e <.L10>:
    7b2e:	b0 12 ae 7a 	call	#31406		;#0x7aae
    7b32:	2c 41       	mov	@r1,	r12	;
    7b34:	2c 52       	add	#4,	r12	;r2 As==10
    7b36:	4d 43       	clr.b	r13		;
    7b38:	b0 12 c6 7a 	call	#31430		;#0x7ac6
    7b3c:	b0 12 ba 7a 	call	#31418		;#0x7aba

00007b40 <.Loc.141.3>:
}
    7b40:	03 43       	nop			
    7b42:	21 53       	incd	r1		;
    7b44:	30 41       	ret			

00007b46 <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    7b46:	3c 40 18 53 	Address 0x0000000000007b48 is out of bounds.
mov	#65535,	r12	;#0xffff

00007b48 <L0>:
    7b48:	18 53       	inc	r8		;
    7b4a:	b0 12 c2 6d 	call	#28098		;#0x6dc2

00007b4e <.Loc.182.3>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    7b4e:	b2 40 e0 05 	mov	#1504,	&0x531e	;#0x05e0
    7b52:	1e 53 

00007b54 <.Loc.183.3>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    7b54:	b2 40 fc 05 	mov	#1532,	&0x5320	;#0x05fc
    7b58:	20 53 

00007b5a <.Loc.184.3>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    7b5a:	b2 40 11 00 	mov	#17,	&0x532e	;#0x0011
    7b5e:	2e 53 

00007b60 <.Loc.185.3>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    7b60:	b2 40 10 00 	mov	#16,	&0x5340	;#0x0010
    7b64:	40 53 

00007b66 <.Loc.186.3>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    7b66:	1c 42 1e 53 	mov	&0x531e,r12	;0x531e
    7b6a:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7b6e:	82 4c 24 53 	mov	r12,	&0x5324	;

00007b72 <.Loc.187.3>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    7b72:	1c 42 1e 53 	mov	&0x531e,r12	;0x531e
    7b76:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7b7a:	82 4c 34 53 	mov	r12,	&0x5334	;

00007b7e <.Loc.188.3>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7b7e:	b2 40 c0 00 	mov	#192,	&0x532a	;#0x00c0
    7b82:	2a 53 

00007b84 <.Loc.189.3>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7b84:	b2 40 c0 00 	mov	#192,	&0x533c	;#0x00c0
    7b88:	3c 53 

00007b8a <.Loc.190.3>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7b8a:	82 43 2c 53 	mov	#0,	&0x532c	;r3 As==00

00007b8e <.Loc.191.3>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7b8e:	82 43 3e 53 	mov	#0,	&0x533e	;r3 As==00

00007b92 <.Loc.192.3>:
  SPIDA1.tx_req.callback.callback = NULL;
    7b92:	82 43 30 53 	mov	#0,	&0x5330	;r3 As==00

00007b96 <.Loc.193.3>:
  SPIDA1.tx_req.callback.args     = NULL;
    7b96:	82 43 32 53 	mov	#0,	&0x5332	;r3 As==00

00007b9a <.Loc.194.3>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    7b9a:	b2 40 e0 7a 	mov	#31456,	&0x5342	;#0x7ae0
    7b9e:	42 53 

00007ba0 <.Loc.195.3>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    7ba0:	b2 40 18 53 	mov	#21272,	&0x5344	;#0x5318
    7ba4:	44 53 

00007ba6 <.Loc.238.3>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    7ba6:	3c 40 46 53 	mov	#21318,	r12	;#0x5346
    7baa:	b0 12 c2 6d 	call	#28098		;#0x6dc2

00007bae <.Loc.239.3>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    7bae:	b2 40 40 06 	mov	#1600,	&0x534c	;#0x0640
    7bb2:	4c 53 

00007bb4 <.Loc.240.3>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    7bb4:	b2 40 6c 06 	mov	#1644,	&0x534e	;#0x066c
    7bb8:	4e 53 

00007bba <.Loc.241.3>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    7bba:	b2 40 13 00 	mov	#19,	&0x535c	;#0x0013
    7bbe:	5c 53 

00007bc0 <.Loc.242.3>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    7bc0:	b2 40 12 00 	mov	#18,	&0x536e	;#0x0012
    7bc4:	6e 53 

00007bc6 <.Loc.243.3>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    7bc6:	1c 42 4c 53 	mov	&0x534c,r12	;0x534c
    7bca:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7bce:	82 4c 52 53 	mov	r12,	&0x5352	;

00007bd2 <.Loc.244.3>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    7bd2:	1c 42 4c 53 	mov	&0x534c,r12	;0x534c
    7bd6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7bda:	82 4c 62 53 	mov	r12,	&0x5362	;

00007bde <.Loc.245.3>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7bde:	b2 40 c0 00 	mov	#192,	&0x5358	;#0x00c0
    7be2:	58 53 

00007be4 <.Loc.246.3>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7be4:	b2 40 c0 00 	mov	#192,	&0x536a	;#0x00c0
    7be8:	6a 53 

00007bea <.Loc.247.3>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7bea:	82 43 5a 53 	mov	#0,	&0x535a	;r3 As==00

00007bee <.Loc.248.3>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7bee:	82 43 6c 53 	mov	#0,	&0x536c	;r3 As==00

00007bf2 <.Loc.249.3>:
  SPIDB0.tx_req.callback.callback = NULL;
    7bf2:	82 43 5e 53 	mov	#0,	&0x535e	;r3 As==00

00007bf6 <.Loc.250.3>:
  SPIDB0.tx_req.callback.args     = NULL;
    7bf6:	82 43 60 53 	mov	#0,	&0x5360	;r3 As==00

00007bfa <.Loc.251.3>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    7bfa:	b2 40 e0 7a 	mov	#31456,	&0x5370	;#0x7ae0
    7bfe:	70 53 

00007c00 <.Loc.252.3>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    7c00:	b2 40 46 53 	mov	#21318,	&0x5372	;#0x5346
    7c04:	72 53 

00007c06 <.Loc.311.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    7c06:	03 43       	nop			
    7c08:	30 41       	ret			

00007c0a <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7c0a:	03 43       	nop			
    7c0c:	30 41       	ret			

00007c0e <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7c0e:	03 43       	nop			
    7c10:	30 41       	ret			

00007c12 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7c12:	b0 12 0a 7c 	call	#31754		;#0x7c0a
    7c16:	b0 12 58 5d 	call	#23896		;#0x5d58

00007c1a <.Loc.527.2>:
}
    7c1a:	03 43       	nop			
    7c1c:	30 41       	ret			

00007c1e <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7c1e:	b0 12 7a 5d 	call	#23930		;#0x5d7a
    7c22:	b0 12 0e 7c 	call	#31758		;#0x7c0e

00007c26 <.Loc.538.2>:
}
    7c26:	03 43       	nop			
    7c28:	30 41       	ret			

00007c2a <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7c2a:	21 82       	sub	#4,	r1	;r2 As==10

00007c2c <.LCFI0>:
    7c2c:	81 4c 02 00 	mov	r12,	2(r1)	;
    7c30:	81 4d 00 00 	mov	r13,	0(r1)	;

00007c34 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7c34:	2d 41       	mov	@r1,	r13	;
    7c36:	1c 41 02 00 	mov	2(r1),	r12	;
    7c3a:	b0 12 08 61 	call	#24840		;#0x6108

00007c3e <.Loc.740.2>:
}
    7c3e:	03 43       	nop			
    7c40:	21 52       	add	#4,	r1	;r2 As==10
    7c42:	30 41       	ret			

00007c44 <restart_dma>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void restart_dma(ADCDriver * adcp) {
    7c44:	21 83       	decd	r1		;

00007c46 <.LCFI1>:
    7c46:	81 4c 00 00 	mov	r12,	0(r1)	;

00007c4a <.Loc.55.3>:
  /* TODO timeouts? */
  /* Restart DMA transfer */
  if (adcp->dma.registers == NULL) {
    7c4a:	2c 41       	mov	@r1,	r12	;
    7c4c:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    7c50:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c52:	15 20       	jnz	$+44     	;abs 0x7c7e

00007c54 <.Loc.57.3>:
    /* Acquire a DMA stream because dmaTransfer can be called from ISRs */
    osalSysLockFromISR();
    7c54:	b0 12 12 7c 	call	#31762		;#0x7c12

00007c58 <.Loc.58.3>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    7c58:	2c 41       	mov	@r1,	r12	;
    7c5a:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7c5e:	2d 41       	mov	@r1,	r13	;
    7c60:	5d 4d 28 00 	mov.b	40(r13),r13	;0x00028
    7c64:	b0 12 fa 78 	call	#30970		;#0x78fa

00007c68 <.Loc.59.3>:
    osalSysUnlockFromISR();
    7c68:	b0 12 1e 7c 	call	#31774		;#0x7c1e

00007c6c <.Loc.60.3>:
    dmaTransfer(&(adcp->dma), &(adcp->req));
    7c6c:	2c 41       	mov	@r1,	r12	;
    7c6e:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7c72:	2d 41       	mov	@r1,	r13	;
    7c74:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7c78:	b0 12 b4 79 	call	#31156		;#0x79b4

00007c7c <.Loc.65.3>:
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
}
    7c7c:	08 3c       	jmp	$+18     	;abs 0x7c8e

00007c7e <.L7>:
    dmaAcquireI(&(adcp->dma), adcp->dma.index);
    osalSysUnlockFromISR();
    dmaTransfer(&(adcp->dma), &(adcp->req));
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
    7c7e:	2c 41       	mov	@r1,	r12	;
    7c80:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7c84:	2d 41       	mov	@r1,	r13	;
    7c86:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7c8a:	b0 12 b4 79 	call	#31156		;#0x79b4

00007c8e <.L9>:
  }
}
    7c8e:	03 43       	nop			
    7c90:	21 53       	incd	r1		;
    7c92:	30 41       	ret			

00007c94 <dma_callback>:

static void dma_callback(void * args) {
    7c94:	0a 15       	pushm	#1,	r10	;16-bit words

00007c96 <L0>:
    7c96:	31 82       	sub	#8,	r1	;r2 As==11

00007c98 <.LCFI3>:
    7c98:	81 4c 00 00 	mov	r12,	0(r1)	;

00007c9c <.Loc.68.3>:
  ADCDriver * adcp = (ADCDriver *)args;
    7c9c:	a1 41 06 00 	mov	@r1,	6(r1)	;

00007ca0 <.Loc.70.3>:

  if (adcp->grpp == NULL)
    7ca0:	1c 41 06 00 	mov	6(r1),	r12	;
    7ca4:	1c 4c 08 00 	mov	8(r12),	r12	;
    7ca8:	0c 93       	cmp	#0,	r12	;r3 As==00
    7caa:	1f 25       	jz	$+576    	;abs 0x7eea

00007cac <.Loc.73.3>:
    return;

  adcp->count++;
    7cac:	1c 41 06 00 	mov	6(r1),	r12	;
    7cb0:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7cb4:	5c 53       	inc.b	r12		;
    7cb6:	4d 4c       	mov.b	r12,	r13	;
    7cb8:	1c 41 06 00 	mov	6(r1),	r12	;
    7cbc:	cc 4d 24 00 	mov.b	r13,	36(r12)	; 0x0024

00007cc0 <.Loc.75.3>:

  if (adcp->count == adcp->depth / 2) {
    7cc0:	1c 41 06 00 	mov	6(r1),	r12	;
    7cc4:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7cc8:	0d 4c       	mov	r12,	r13	;
    7cca:	1c 41 06 00 	mov	6(r1),	r12	;
    7cce:	1c 4c 06 00 	mov	6(r12),	r12	;
    7cd2:	12 c3       	clrc			
    7cd4:	0c 10       	rrc	r12		;
    7cd6:	0d 9c       	cmp	r12,	r13	;
    7cd8:	1d 20       	jnz	$+60     	;abs 0x7d14

00007cda <.Loc.77.3>:
    /* half-full interrupt */
    _adc_isr_half_code(adcp);
    7cda:	1c 41 06 00 	mov	6(r1),	r12	;
    7cde:	1c 4c 08 00 	mov	8(r12),	r12	;
    7ce2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ce6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ce8:	15 24       	jz	$+44     	;abs 0x7d14

00007cea <.Loc.77.3>:
    7cea:	1c 41 06 00 	mov	6(r1),	r12	;
    7cee:	1c 4c 08 00 	mov	8(r12),	r12	;
    7cf2:	1f 4c 02 00 	mov	2(r12),	r15	;
    7cf6:	1c 41 06 00 	mov	6(r1),	r12	;
    7cfa:	1c 4c 04 00 	mov	4(r12),	r12	;
    7cfe:	1d 41 06 00 	mov	6(r1),	r13	;
    7d02:	1d 4d 06 00 	mov	6(r13),	r13	;
    7d06:	12 c3       	clrc			
    7d08:	0d 10       	rrc	r13		;
    7d0a:	0e 4d       	mov	r13,	r14	;
    7d0c:	0d 4c       	mov	r12,	r13	;
    7d0e:	1c 41 06 00 	mov	6(r1),	r12	;
    7d12:	8f 12       	call	r15		;

00007d14 <.L13>:
  }

  if (adcp->count == adcp->depth) {
    7d14:	1c 41 06 00 	mov	6(r1),	r12	;
    7d18:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7d1c:	0d 4c       	mov	r12,	r13	;
    7d1e:	1c 41 06 00 	mov	6(r1),	r12	;
    7d22:	1c 4c 06 00 	mov	6(r12),	r12	;
    7d26:	0d 9c       	cmp	r12,	r13	;
    7d28:	ba 20       	jnz	$+374    	;abs 0x7e9e

00007d2a <.Loc.84.3>:
    /* full interrupt */

    /* adc_lld_stop_conversion is called automatically here if needed */
    _adc_isr_full_code(adcp);
    7d2a:	1c 41 06 00 	mov	6(r1),	r12	;
    7d2e:	1c 4c 08 00 	mov	8(r12),	r12	;
    7d32:	6c 4c       	mov.b	@r12,	r12	;
    7d34:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d36:	4c 24       	jz	$+154    	;abs 0x7dd0

00007d38 <.Loc.84.3>:
    7d38:	1c 41 06 00 	mov	6(r1),	r12	;
    7d3c:	1c 4c 08 00 	mov	8(r12),	r12	;
    7d40:	1c 4c 02 00 	mov	2(r12),	r12	;
    7d44:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d46:	88 24       	jz	$+274    	;abs 0x7e58

00007d48 <.Loc.84.3>:
    7d48:	1c 41 06 00 	mov	6(r1),	r12	;
    7d4c:	1d 4c 06 00 	mov	6(r12),	r13	;
    7d50:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d52:	0c 9d       	cmp	r13,	r12	;
    7d54:	29 2c       	jc	$+84     	;abs 0x7da8

00007d56 <.LBB2>:
    7d56:	1c 41 06 00 	mov	6(r1),	r12	;
    7d5a:	1c 4c 06 00 	mov	6(r12),	r12	;
    7d5e:	b0 12 3c 8d 	call	#36156		;#0x8d3c
    7d62:	81 4c 04 00 	mov	r12,	4(r1)	;
    7d66:	1c 41 06 00 	mov	6(r1),	r12	;
    7d6a:	1c 4c 08 00 	mov	8(r12),	r12	;
    7d6e:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    7d72:	1d 41 04 00 	mov	4(r1),	r13	;
    7d76:	b0 12 b8 8d 	call	#36280		;#0x8db8
    7d7a:	81 4c 02 00 	mov	r12,	2(r1)	;
    7d7e:	1c 41 06 00 	mov	6(r1),	r12	;
    7d82:	1c 4c 08 00 	mov	8(r12),	r12	;
    7d86:	1f 4c 02 00 	mov	2(r12),	r15	;
    7d8a:	1c 41 06 00 	mov	6(r1),	r12	;
    7d8e:	1d 4c 04 00 	mov	4(r12),	r13	;
    7d92:	1c 41 02 00 	mov	2(r1),	r12	;
    7d96:	0c 5c       	rla	r12		;
    7d98:	0c 5d       	add	r13,	r12	;
    7d9a:	1e 41 04 00 	mov	4(r1),	r14	;
    7d9e:	0d 4c       	mov	r12,	r13	;
    7da0:	1c 41 06 00 	mov	6(r1),	r12	;
    7da4:	8f 12       	call	r15		;

00007da6 <.LBE2>:
    7da6:	58 3c       	jmp	$+178    	;abs 0x7e58

00007da8 <.L17>:
    7da8:	1c 41 06 00 	mov	6(r1),	r12	;
    7dac:	1c 4c 08 00 	mov	8(r12),	r12	;
    7db0:	1f 4c 02 00 	mov	2(r12),	r15	;
    7db4:	1c 41 06 00 	mov	6(r1),	r12	;
    7db8:	1c 4c 04 00 	mov	4(r12),	r12	;
    7dbc:	1d 41 06 00 	mov	6(r1),	r13	;
    7dc0:	1d 4d 06 00 	mov	6(r13),	r13	;
    7dc4:	0e 4d       	mov	r13,	r14	;
    7dc6:	0d 4c       	mov	r12,	r13	;
    7dc8:	1c 41 06 00 	mov	6(r1),	r12	;
    7dcc:	8f 12       	call	r15		;
    7dce:	44 3c       	jmp	$+138    	;abs 0x7e58

00007dd0 <.L15>:
    7dd0:	1c 41 06 00 	mov	6(r1),	r12	;
    7dd4:	b0 12 02 83 	call	#33538		;#0x8302
    7dd8:	1c 41 06 00 	mov	6(r1),	r12	;
    7ddc:	1c 4c 08 00 	mov	8(r12),	r12	;
    7de0:	1c 4c 02 00 	mov	2(r12),	r12	;
    7de4:	0c 93       	cmp	#0,	r12	;r3 As==00
    7de6:	25 24       	jz	$+76     	;abs 0x7e32

00007de8 <.Loc.84.3>:
    7de8:	1c 41 06 00 	mov	6(r1),	r12	;
    7dec:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7df0:	1c 41 06 00 	mov	6(r1),	r12	;
    7df4:	1c 4c 08 00 	mov	8(r12),	r12	;
    7df8:	1f 4c 02 00 	mov	2(r12),	r15	;
    7dfc:	1c 41 06 00 	mov	6(r1),	r12	;
    7e00:	1c 4c 04 00 	mov	4(r12),	r12	;
    7e04:	1d 41 06 00 	mov	6(r1),	r13	;
    7e08:	1d 4d 06 00 	mov	6(r13),	r13	;
    7e0c:	0e 4d       	mov	r13,	r14	;
    7e0e:	0d 4c       	mov	r12,	r13	;
    7e10:	1c 41 06 00 	mov	6(r1),	r12	;
    7e14:	8f 12       	call	r15		;
    7e16:	1c 41 06 00 	mov	6(r1),	r12	;
    7e1a:	6c 4c       	mov.b	@r12,	r12	;
    7e1c:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7e1e:	11 20       	jnz	$+36     	;abs 0x7e42

00007e20 <.Loc.84.3>:
    7e20:	1c 41 06 00 	mov	6(r1),	r12	;
    7e24:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7e28:	1c 41 06 00 	mov	6(r1),	r12	;
    7e2c:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    7e30:	08 3c       	jmp	$+18     	;abs 0x7e42

00007e32 <.L19>:
    7e32:	1c 41 06 00 	mov	6(r1),	r12	;
    7e36:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7e3a:	1c 41 06 00 	mov	6(r1),	r12	;
    7e3e:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00007e42 <.L21>:
    7e42:	b0 12 12 7c 	call	#31762		;#0x7c12
    7e46:	1c 41 06 00 	mov	6(r1),	r12	;
    7e4a:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    7e4e:	4d 43       	clr.b	r13		;
    7e50:	b0 12 2a 7c 	call	#31786		;#0x7c2a
    7e54:	b0 12 1e 7c 	call	#31774		;#0x7c1e

00007e58 <.L18>:
    /* after isr_full, adcp->grpp is only non-NULL if it's a circular group */
    if (adcp->grpp) {
    7e58:	1c 41 06 00 	mov	6(r1),	r12	;
    7e5c:	1c 4c 08 00 	mov	8(r12),	r12	;
    7e60:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e62:	44 24       	jz	$+138    	;abs 0x7eec

00007e64 <.Loc.88.3>:
      /* Reset the buffer pointer */
      adcp->req.dest_addr = adcp->samples;
    7e64:	1c 41 06 00 	mov	6(r1),	r12	;
    7e68:	1d 4c 04 00 	mov	4(r12),	r13	;
    7e6c:	1c 41 06 00 	mov	6(r1),	r12	;
    7e70:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00007e74 <.Loc.90.3>:

      restart_dma(adcp);
    7e74:	1c 41 06 00 	mov	6(r1),	r12	;
    7e78:	b0 12 44 7c 	call	#31812		;#0x7c44

00007e7c <.Loc.93.3>:

      /* Reset the count */
      adcp->count = 0;
    7e7c:	1c 41 06 00 	mov	6(r1),	r12	;
    7e80:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

00007e84 <.Loc.96.3>:

      /* Start next sequence */
      adcp->regs->ctl[0] |= ADC12SC;
    7e84:	1c 41 06 00 	mov	6(r1),	r12	;
    7e88:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7e8c:	1d 41 06 00 	mov	6(r1),	r13	;
    7e90:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    7e94:	2d 4d       	mov	@r13,	r13	;
    7e96:	1d d3       	bis	#1,	r13	;r3 As==01
    7e98:	8c 4d 00 00 	mov	r13,	0(r12)	;
    7e9c:	27 3c       	jmp	$+80     	;abs 0x7eec

00007e9e <.L14>:
    }
  }
  else {
    /* Advance the buffer pointer */
    adcp->req.dest_addr = adcp->samples + (adcp->req.size * adcp->count);
    7e9e:	1c 41 06 00 	mov	6(r1),	r12	;
    7ea2:	1a 4c 04 00 	mov	4(r12),	r10	;
    7ea6:	1c 41 06 00 	mov	6(r1),	r12	;
    7eaa:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7eae:	1d 41 06 00 	mov	6(r1),	r13	;
    7eb2:	5d 4d 24 00 	mov.b	36(r13),r13	;0x00024
    7eb6:	b0 12 b8 8d 	call	#36280		;#0x8db8
    7eba:	0c 5c       	rla	r12		;
    7ebc:	0d 4a       	mov	r10,	r13	;
    7ebe:	0d 5c       	add	r12,	r13	;
    7ec0:	1c 41 06 00 	mov	6(r1),	r12	;
    7ec4:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00007ec8 <.Loc.103.3>:

    restart_dma(adcp);
    7ec8:	1c 41 06 00 	mov	6(r1),	r12	;
    7ecc:	b0 12 44 7c 	call	#31812		;#0x7c44

00007ed0 <.Loc.106.3>:

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
    7ed0:	1c 41 06 00 	mov	6(r1),	r12	;
    7ed4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7ed8:	1d 41 06 00 	mov	6(r1),	r13	;
    7edc:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    7ee0:	2d 4d       	mov	@r13,	r13	;
    7ee2:	1d d3       	bis	#1,	r13	;r3 As==01
    7ee4:	8c 4d 00 00 	mov	r13,	0(r12)	;
    7ee8:	01 3c       	jmp	$+4      	;abs 0x7eec

00007eea <.L23>:

static void dma_callback(void * args) {
  ADCDriver * adcp = (ADCDriver *)args;

  if (adcp->grpp == NULL)
    return;
    7eea:	03 43       	nop			

00007eec <.L10>:
    restart_dma(adcp);

    /* Start next sequence */
    adcp->regs->ctl[0] |= ADC12SC;
  }
}
    7eec:	31 52       	add	#8,	r1	;r2 As==11
    7eee:	0a 17       	popm	#1,	r10	;16-bit words
    7ef0:	30 41       	ret			

00007ef2 <populate_tlv>:

static void populate_tlv(ADCDriver * adcp) {
    7ef2:	21 82       	sub	#4,	r1	;r2 As==10

00007ef4 <.LCFI4>:
    7ef4:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ef8 <.Loc.111.3>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    7ef8:	b1 40 08 1a 	Address 0x0000000000007efc is out of bounds.
mov	#6664,	-1(r1)	;#0x1a08, 0xffff
    7efc:	02 00 

00007efc <L0>:
    7efc:	02 00       	mova	@r0,	r2	;

00007efe <.Loc.113.3>:

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    7efe:	20 3c       	jmp	$+66     	;abs 0x7f40

00007f00 <.L29>:
    if (*tlv_addr == TLV_ADC12CAL) {
    7f00:	1c 41 02 00 	mov	2(r1),	r12	;
    7f04:	6c 4c       	mov.b	@r12,	r12	;
    7f06:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    7f0a:	07 20       	jnz	$+16     	;abs 0x7f1a

00007f0c <.Loc.115.3>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    7f0c:	1d 41 02 00 	mov	2(r1),	r13	;
    7f10:	2d 53       	incd	r13		;
    7f12:	2c 41       	mov	@r1,	r12	;
    7f14:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020
    7f18:	0c 3c       	jmp	$+26     	;abs 0x7f32

00007f1a <.L26>:
    }
    else if (*tlv_addr == TLV_REFCAL) {
    7f1a:	1c 41 02 00 	mov	2(r1),	r12	;
    7f1e:	6c 4c       	mov.b	@r12,	r12	;
    7f20:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    7f24:	06 20       	jnz	$+14     	;abs 0x7f32

00007f26 <.Loc.118.3>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    7f26:	1d 41 02 00 	mov	2(r1),	r13	;
    7f2a:	2d 53       	incd	r13		;
    7f2c:	2c 41       	mov	@r1,	r12	;
    7f2e:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

00007f32 <.L27>:
    }
    tlv_addr += (tlv_addr[1] + 2);
    7f32:	1c 41 02 00 	mov	2(r1),	r12	;
    7f36:	1c 53       	inc	r12		;
    7f38:	6c 4c       	mov.b	@r12,	r12	;
    7f3a:	2c 53       	incd	r12		;
    7f3c:	81 5c 02 00 	add	r12,	2(r1)	;

00007f40 <.L25>:
}

static void populate_tlv(ADCDriver * adcp) {
  uint8_t * tlv_addr = (uint8_t *)TLV_START;

  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    7f40:	1c 41 02 00 	mov	2(r1),	r12	;
    7f44:	6c 4c       	mov.b	@r12,	r12	;
    7f46:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    7f48:	05 24       	jz	$+12     	;abs 0x7f54

00007f4a <.Loc.113.3>:
    7f4a:	3c 40 fe 1a 	mov	#6910,	r12	;#0x1afe
    7f4e:	1c 91 02 00 	cmp	2(r1),	r12	;
    7f52:	d6 2f       	jc	$-82     	;abs 0x7f00

00007f54 <.L30>:
    else if (*tlv_addr == TLV_REFCAL) {
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    }
    tlv_addr += (tlv_addr[1] + 2);
  }
}
    7f54:	03 43       	nop			
    7f56:	21 52       	add	#4,	r1	;r2 As==10
    7f58:	30 41       	ret			

00007f5a <ISR_ADC12_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(ADC12_VECTOR) {
    7f5a:	bf 15       	pushm	#12,	r15	;16-bit words

00007f5c <.LCFI5>:

  OSAL_IRQ_PROLOGUE();
    7f5c:	d2 43 7a 52 	Address 0x0000000000007f5e is out of bounds.
mov.b	#1,	&0xffff	;r3 As==01

00007f5e <L0>:
    7f5e:	7a 52       	add.b	#8,	r10	;r2 As==11
    7f60:	b0 12 9e 5d 	call	#23966		;#0x5d9e

00007f64 <.Loc.132.3>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    7f64:	1c 42 18 08 	mov	&0x0818,r12	;0x0818
    7f68:	2c 93       	cmp	#2,	r12	;r3 As==10
    7f6a:	03 24       	jz	$+8      	;abs 0x7f72
    7f6c:	2c 92       	cmp	#4,	r12	;r2 As==10
    7f6e:	32 24       	jz	$+102    	;abs 0x7fd4
    7f70:	62 3c       	jmp	$+198    	;abs 0x8036

00007f72 <.L33>:

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
    7f72:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7f76:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f78:	8b 24       	jz	$+280    	;abs 0x8090

00007f7a <.Loc.137.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    7f7a:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    7f7e:	b0 12 02 83 	call	#33538		;#0x8302
    7f82:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7f86:	1c 4c 04 00 	mov	4(r12),	r12	;
    7f8a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f8c:	15 24       	jz	$+44     	;abs 0x7fb8

00007f8e <.Loc.137.3>:
    7f8e:	f2 40 05 00 	mov.b	#5,	&0x5374	;
    7f92:	74 53 
    7f94:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7f98:	1e 4c 04 00 	mov	4(r12),	r14	;
    7f9c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7f9e:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    7fa2:	8e 12       	call	r14		;
    7fa4:	5c 42 74 53 	mov.b	&0x5374,r12	;0x5374
    7fa8:	7c 90 05 00 	cmp.b	#5,	r12	;
    7fac:	02 20       	jnz	$+6      	;abs 0x7fb2

00007fae <.Loc.137.3>:
    7fae:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10

00007fb2 <.L38>:
    7fb2:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00
    7fb6:	04 3c       	jmp	$+10     	;abs 0x7fc0

00007fb8 <.L37>:
    7fb8:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10
    7fbc:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00

00007fc0 <.L39>:
    7fc0:	b0 12 12 7c 	call	#31762		;#0x7c12
    7fc4:	3d 43       	mov	#-1,	r13	;r3 As==11
    7fc6:	3c 40 7e 53 	mov	#21374,	r12	;#0x537e
    7fca:	b0 12 2a 7c 	call	#31786		;#0x7c2a
    7fce:	b0 12 1e 7c 	call	#31774		;#0x7c1e

00007fd2 <.Loc.138.3>:
    break;
    7fd2:	61 3c       	jmp	$+196    	;abs 0x8096

00007fd4 <.L34>:
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
    7fd4:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7fd8:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fda:	5c 24       	jz	$+186    	;abs 0x8094

00007fdc <.Loc.143.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    7fdc:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    7fe0:	b0 12 02 83 	call	#33538		;#0x8302
    7fe4:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7fe8:	1c 4c 04 00 	mov	4(r12),	r12	;
    7fec:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fee:	15 24       	jz	$+44     	;abs 0x801a

00007ff0 <.Loc.143.3>:
    7ff0:	f2 40 05 00 	mov.b	#5,	&0x5374	;
    7ff4:	74 53 
    7ff6:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    7ffa:	1e 4c 04 00 	mov	4(r12),	r14	;
    7ffe:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8000:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    8004:	8e 12       	call	r14		;
    8006:	5c 42 74 53 	mov.b	&0x5374,r12	;0x5374
    800a:	7c 90 05 00 	cmp.b	#5,	r12	;
    800e:	02 20       	jnz	$+6      	;abs 0x8014

00008010 <.Loc.143.3>:
    8010:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10

00008014 <.L42>:
    8014:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00
    8018:	04 3c       	jmp	$+10     	;abs 0x8022

0000801a <.L41>:
    801a:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10
    801e:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00

00008022 <.L43>:
    8022:	b0 12 12 7c 	call	#31762		;#0x7c12
    8026:	3d 43       	mov	#-1,	r13	;r3 As==11
    8028:	3c 40 7e 53 	mov	#21374,	r12	;#0x537e
    802c:	b0 12 2a 7c 	call	#31786		;#0x7c2a
    8030:	b0 12 1e 7c 	call	#31774		;#0x7c1e

00008034 <.Loc.144.3>:
    break;
    8034:	30 3c       	jmp	$+98     	;abs 0x8096

00008036 <.L48>:
  }
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    8036:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    803a:	b0 12 02 83 	call	#33538		;#0x8302
    803e:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    8042:	1c 4c 04 00 	mov	4(r12),	r12	;
    8046:	0c 93       	cmp	#0,	r12	;r3 As==00
    8048:	15 24       	jz	$+44     	;abs 0x8074

0000804a <.Loc.148.3>:
    804a:	f2 40 05 00 	mov.b	#5,	&0x5374	;
    804e:	74 53 
    8050:	1c 42 7c 53 	mov	&0x537c,r12	;0x537c
    8054:	1e 4c 04 00 	mov	4(r12),	r14	;
    8058:	4d 43       	clr.b	r13		;
    805a:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    805e:	8e 12       	call	r14		;
    8060:	5c 42 74 53 	mov.b	&0x5374,r12	;0x5374
    8064:	7c 90 05 00 	cmp.b	#5,	r12	;
    8068:	02 20       	jnz	$+6      	;abs 0x806e

0000806a <.Loc.148.3>:
    806a:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10

0000806e <.L45>:
    806e:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00
    8072:	04 3c       	jmp	$+10     	;abs 0x807c

00008074 <.L44>:
    8074:	e2 43 74 53 	mov.b	#2,	&0x5374	;r3 As==10
    8078:	82 43 7c 53 	mov	#0,	&0x537c	;r3 As==00

0000807c <.L46>:
    807c:	b0 12 12 7c 	call	#31762		;#0x7c12
    8080:	3d 43       	mov	#-1,	r13	;r3 As==11
    8082:	3c 40 7e 53 	mov	#21374,	r12	;#0x537e
    8086:	b0 12 2a 7c 	call	#31786		;#0x7c2a
    808a:	b0 12 1e 7c 	call	#31774		;#0x7c1e
    808e:	03 3c       	jmp	$+8      	;abs 0x8096

00008090 <.L49>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    8090:	03 43       	nop			
    8092:	01 3c       	jmp	$+4      	;abs 0x8096

00008094 <.L50>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    break;
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
      break;
    8094:	03 43       	nop			

00008096 <.L36>:
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
  }

  OSAL_IRQ_EPILOGUE();
    8096:	b0 12 cc 5d 	call	#24012		;#0x5dcc
    809a:	c2 43 7a 52 	mov.b	#0,	&0x527a	;r3 As==00
    809e:	b0 12 16 5d 	call	#23830		;#0x5d16
    80a2:	b0 12 4c 60 	call	#24652		;#0x604c
    80a6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    80aa:	0c 93       	cmp	#0,	r12	;r3 As==00
    80ac:	02 24       	jz	$+6      	;abs 0x80b2

000080ae <.Loc.151.3>:
    80ae:	b0 12 68 60 	call	#24680		;#0x6068

000080b2 <.L47>:
    80b2:	b0 12 36 5d 	call	#23862		;#0x5d36

000080b6 <.Loc.152.3>:
}
    80b6:	03 43       	nop			
    80b8:	b4 17       	popm	#12,	r15	;16-bit words
    80ba:	00 13       	reti			

000080bc <adc_lld_init>:
 */
void adc_lld_init(void) {

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    80bc:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    80c0:	b0 12 ec 69 	call	#27116		;#0x69ec

000080c4 <.Loc.168.3>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    80c4:	b2 40 00 08 	mov	#2048,	&0x5380	;#0x0800
    80c8:	80 53 

000080ca <.Loc.169.3>:
  populate_tlv(&ADCD1);
    80ca:	3c 40 74 53 	Address 0x00000000000080cc is out of bounds.
mov	#65535,	r12	;#0xffff

000080cc <L0>:
    80cc:	74 53       	add.b	#-1,	r4	;r3 As==11
    80ce:	b0 12 f2 7e 	call	#32498		;#0x7ef2

000080d2 <.Loc.171.3>:
#endif
}
    80d2:	03 43       	nop			
    80d4:	30 41       	ret			

000080d6 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver * adcp) {
    80d6:	21 82       	sub	#4,	r1	;r2 As==10

000080d8 <.LCFI6>:
    80d8:	81 4c 00 00 	mov	r12,	0(r1)	;

000080dc <.Loc.182.3>:

  if (adcp->state == ADC_STOP) {
    80dc:	2c 41       	mov	@r1,	r12	;
    80de:	6c 4c       	mov.b	@r12,	r12	;
    80e0:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    80e2:	43 20       	jnz	$+136    	;abs 0x816a

000080e4 <.LBB3>:
    /* Enables the peripheral.*/
    adcp->regs->ctl[0] = ADC12ON | ADC12MSC;
    80e4:	2c 41       	mov	@r1,	r12	;
    80e6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    80ea:	bc 40 90 00 	mov	#144,	0(r12)	;#0x0090
    80ee:	00 00 

000080f0 <.Loc.185.3>:
    adcp->regs->ctl[1] =
    80f0:	2c 41       	mov	@r1,	r12	;
    80f2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    80f6:	bc 40 60 62 	mov	#25184,	2(r12)	;#0x6260
    80fa:	02 00 

000080fc <.Loc.187.3>:
        MSP430X_ADC1_PDIV | MSP430X_ADC1_DIV | MSP430X_ADC1_SSEL | ADC12SHP;
    adcp->regs->ctl[3] = ADC12ICH3MAP | ADC12ICH2MAP | ADC12ICH1MAP |
    80fc:	2c 41       	mov	@r1,	r12	;
    80fe:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8102:	bc 40 c0 0f 	mov	#4032,	6(r12)	;#0x0fc0
    8106:	06 00 

00008108 <.Loc.189.3>:
                         ADC12ICH0MAP | ADC12TCMAP | ADC12BATMAP;
    adcp->regs->ier[2] = ADC12TOVIE | ADC12OVIE;
    8108:	2c 41       	mov	@r1,	r12	;
    810a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    810e:	bc 40 30 00 	mov	#48,	22(r12)	;#0x0030, 0x0016
    8112:	16 00 

00008114 <.Loc.190.3>:
    adcp->req.trigger  = DMA_TRIGGER_MNEM(ADC12IFG);
    8114:	2c 41       	mov	@r1,	r12	;
    8116:	bc 40 1a 00 	mov	#26,	26(r12)	;#0x001a, 0x001a
    811a:	1a 00 

0000811c <.Loc.194.3>:
#if MSP430X_ADC_COMPACT_SAMPLES == TRUE
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTBYTE;
#else
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTWORD;
    811c:	2c 41       	mov	@r1,	r12	;
    811e:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016

00008122 <.Loc.196.3>:
#endif
    adcp->req.addr_mode         = MSP430X_DMA_SRCINCR | MSP430X_DMA_DSTINCR;
    8122:	2c 41       	mov	@r1,	r12	;
    8124:	bc 40 00 0f 	mov	#3840,	20(r12)	;#0x0f00, 0x0014
    8128:	14 00 

0000812a <.Loc.197.3>:
    adcp->req.transfer_mode     = MSP430X_DMA_SINGLE;
    812a:	2c 41       	mov	@r1,	r12	;
    812c:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

00008130 <.Loc.198.3>:
    adcp->req.callback.callback = dma_callback;
    8130:	2c 41       	mov	@r1,	r12	;
    8132:	bc 40 94 7c 	mov	#31892,	28(r12)	;#0x7c94, 0x001c
    8136:	1c 00 

00008138 <.Loc.199.3>:
    adcp->req.callback.args     = adcp;
    8138:	2c 41       	mov	@r1,	r12	;
    813a:	ac 41 1e 00 	mov	@r1,	30(r12)	; 0x001e

0000813e <.Loc.203.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    bool b;
    if (adcp->config->dma_index < MSP430X_DMA_CHANNELS) {
    813e:	2c 41       	mov	@r1,	r12	;
    8140:	1c 4c 02 00 	mov	2(r12),	r12	;
    8144:	6c 4c       	mov.b	@r12,	r12	;
    8146:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8148:	4d 9c       	cmp.b	r12,	r13	;
    814a:	0c 28       	jnc	$+26     	;abs 0x8164

0000814c <.Loc.204.3>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
    814c:	2c 41       	mov	@r1,	r12	;
    814e:	3c 50 26 00 	add	#38,	r12	;#0x0026
    8152:	2d 41       	mov	@r1,	r13	;
    8154:	1d 4d 02 00 	mov	2(r13),	r13	;
    8158:	6d 4d       	mov.b	@r13,	r13	;
    815a:	b0 12 fa 78 	call	#30970		;#0x78fa
    815e:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

00008162 <.LBE3>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    8162:	03 3c       	jmp	$+8      	;abs 0x816a

00008164 <.L54>:
      b = dmaAcquireI(&adcp->dma, adcp->config->dma_index);
      osalDbgAssert(!b, "stream already allocated");
    }
    else {
#endif
      adcp->dma.registers = NULL;
    8164:	2c 41       	mov	@r1,	r12	;
    8166:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

0000816a <.L55>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
    }
#endif
  }
  /* Configures the peripheral.*/
}
    816a:	03 43       	nop			
    816c:	21 52       	add	#4,	r1	;r2 As==10
    816e:	30 41       	ret			

00008170 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver * adcp) {
    8170:	21 82       	sub	#4,	r1	;r2 As==10

00008172 <L0>:
    8172:	81 4c 00 00 	mov	r12,	0(r1)	;

00008176 <.Loc.249.3>:

  /* always use sequential transfer mode - this is fine */
  adcp->regs->ctl[1] |= ADC12CONSEQ0;
    8176:	2c 41       	mov	@r1,	r12	;
    8178:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    817c:	2d 41       	mov	@r1,	r13	;
    817e:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8182:	1d 4d 02 00 	mov	2(r13),	r13	;
    8186:	2d d3       	bis	#2,	r13	;r3 As==10
    8188:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000818c <.Loc.252.3>:

  /* set resolution */
  adcp->regs->ctl[2] |= adcp->grpp->res;
    818c:	2c 41       	mov	@r1,	r12	;
    818e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8192:	2d 41       	mov	@r1,	r13	;
    8194:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8198:	1e 4d 04 00 	mov	4(r13),	r14	;
    819c:	2d 41       	mov	@r1,	r13	;
    819e:	1d 4d 08 00 	mov	8(r13),	r13	;
    81a2:	5d 4d 26 00 	mov.b	38(r13),r13	;0x00026
    81a6:	0d de       	bis	r14,	r13	;
    81a8:	8c 4d 04 00 	mov	r13,	4(r12)	;

000081ac <.Loc.254.3>:
  /* start from MEM0 */
  adcp->regs->ctl[3] &= ~(ADC12CSTARTADD_31);
    81ac:	2c 41       	mov	@r1,	r12	;
    81ae:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    81b2:	2d 41       	mov	@r1,	r13	;
    81b4:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    81b8:	1d 4d 06 00 	mov	6(r13),	r13	;
    81bc:	3d f0 e0 ff 	and	#65504,	r13	;#0xffe0
    81c0:	8c 4d 06 00 	mov	r13,	6(r12)	;

000081c4 <.Loc.257.3>:

  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    81c4:	03 43       	nop			

000081c6 <.L61>:
    81c6:	1c 42 b0 01 	mov	&0x01b0,r12	;0x01b0
    81ca:	3c f0 00 04 	and	#1024,	r12	;#0x0400
    81ce:	0c 93       	cmp	#0,	r12	;r3 As==00
    81d0:	fa 23       	jnz	$-10     	;abs 0x81c6

000081d2 <.Loc.259.3>:
    ;
  REFCTL0 = adcp->grpp->vref_src;
    81d2:	2c 41       	mov	@r1,	r12	;
    81d4:	1c 4c 08 00 	mov	8(r12),	r12	;
    81d8:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    81dc:	82 4c b0 01 	mov	r12,	&0x01b0	;

000081e0 <.LBB5>:

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    81e0:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    81e4:	1b 3c       	jmp	$+56     	;abs 0x821c

000081e6 <.L63>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
    81e6:	2c 41       	mov	@r1,	r12	;
    81e8:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    81ec:	2c 41       	mov	@r1,	r12	;
    81ee:	1c 4c 08 00 	mov	8(r12),	r12	;
    81f2:	1d 4c 2a 00 	mov	42(r12),r13	;0x0002a
    81f6:	2c 41       	mov	@r1,	r12	;
    81f8:	1c 4c 08 00 	mov	8(r12),	r12	;
    81fc:	1c 51 02 00 	add	2(r1),	r12	;
    8200:	3c 50 06 00 	add	#6,	r12	;
    8204:	6c 4c       	mov.b	@r12,	r12	;
    8206:	0d dc       	bis	r12,	r13	;
    8208:	1c 41 02 00 	mov	2(r1),	r12	;
    820c:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8210:	0c 5c       	rla	r12		;
    8212:	0c 5e       	add	r14,	r12	;
    8214:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008218 <.Loc.261.3>:
  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    ;
  REFCTL0 = adcp->grpp->vref_src;

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    8218:	91 53 02 00 	inc	2(r1)		;

0000821c <.L62>:
    821c:	2c 41       	mov	@r1,	r12	;
    821e:	1c 4c 08 00 	mov	8(r12),	r12	;
    8222:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8226:	81 9c 02 00 	cmp	r12,	2(r1)	;
    822a:	dd 3b       	jl	$-68     	;abs 0x81e6

0000822c <.LBE5>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
  }

  adcp->regs->mctl[adcp->grpp->num_channels - 1] |= ADC12EOS;
    822c:	2c 41       	mov	@r1,	r12	;
    822e:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    8232:	2c 41       	mov	@r1,	r12	;
    8234:	1c 4c 08 00 	mov	8(r12),	r12	;
    8238:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    823c:	0f 4c       	mov	r12,	r15	;
    823e:	3f 53       	add	#-1,	r15	;r3 As==11
    8240:	2c 41       	mov	@r1,	r12	;
    8242:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    8246:	2c 41       	mov	@r1,	r12	;
    8248:	1c 4c 08 00 	mov	8(r12),	r12	;
    824c:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8250:	3c 53       	add	#-1,	r12	;r3 As==11
    8252:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8256:	0c 5c       	rla	r12		;
    8258:	0c 5d       	add	r13,	r12	;
    825a:	2c 4c       	mov	@r12,	r12	;
    825c:	0d 4c       	mov	r12,	r13	;
    825e:	3d d0 80 00 	bis	#128,	r13	;#0x0080
    8262:	0c 4f       	mov	r15,	r12	;
    8264:	3c 50 10 00 	add	#16,	r12	;#0x0010
    8268:	0c 5c       	rla	r12		;
    826a:	0c 5e       	add	r14,	r12	;
    826c:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008270 <.Loc.268.3>:

  adcp->req.source_addr = adcp->regs->mem;
    8270:	2c 41       	mov	@r1,	r12	;
    8272:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8276:	0d 4c       	mov	r12,	r13	;
    8278:	3d 50 60 00 	add	#96,	r13	;#0x0060
    827c:	2c 41       	mov	@r1,	r12	;
    827e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008282 <.Loc.269.3>:
  adcp->req.dest_addr   = adcp->samples;
    8282:	2c 41       	mov	@r1,	r12	;
    8284:	1d 4c 04 00 	mov	4(r12),	r13	;
    8288:	2c 41       	mov	@r1,	r12	;
    828a:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

0000828e <.Loc.270.3>:
  adcp->req.size        = adcp->grpp->num_channels;
    828e:	2c 41       	mov	@r1,	r12	;
    8290:	1c 4c 08 00 	mov	8(r12),	r12	;
    8294:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    8298:	0d 4c       	mov	r12,	r13	;
    829a:	2c 41       	mov	@r1,	r12	;
    829c:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

000082a0 <.Loc.271.3>:
  adcp->count           = 0;
    82a0:	2c 41       	mov	@r1,	r12	;
    82a2:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

000082a6 <.Loc.275.3>:

/* TODO timeouts? */
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    82a6:	2c 41       	mov	@r1,	r12	;
    82a8:	1c 4c 02 00 	mov	2(r12),	r12	;
    82ac:	6c 4c       	mov.b	@r12,	r12	;
    82ae:	6d 43       	mov.b	#2,	r13	;r3 As==10
    82b0:	4d 9c       	cmp.b	r12,	r13	;
    82b2:	0b 2c       	jc	$+24     	;abs 0x82ca

000082b4 <.Loc.276.3>:
    adcp->dma.index = dmaRequestS(&(adcp->req), TIME_INFINITE);
    82b4:	2c 41       	mov	@r1,	r12	;
    82b6:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    82ba:	4d 43       	clr.b	r13		;
    82bc:	b0 12 7e 78 	call	#30846		;#0x787e
    82c0:	4d 4c       	mov.b	r12,	r13	;
    82c2:	2c 41       	mov	@r1,	r12	;
    82c4:	cc 4d 28 00 	mov.b	r13,	40(r12)	; 0x0028
    82c8:	08 3c       	jmp	$+18     	;abs 0x82da

000082ca <.L64>:
  }
  else {
    dmaTransfer(&(adcp->dma), &(adcp->req));
    82ca:	2c 41       	mov	@r1,	r12	;
    82cc:	3c 50 26 00 	add	#38,	r12	;#0x0026
    82d0:	2d 41       	mov	@r1,	r13	;
    82d2:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    82d6:	b0 12 b4 79 	call	#31156		;#0x79b4

000082da <.L65>:
  }
#else
  adcp->dma.index       = dmaRequestS(&(adcp->req), TIME_INFINITE);
#endif

  adcp->regs->ctl[0] |= adcp->grpp->rate | ADC12MSC | ADC12ENC | ADC12SC;
    82da:	2c 41       	mov	@r1,	r12	;
    82dc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    82e0:	2d 41       	mov	@r1,	r13	;
    82e2:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    82e6:	2e 4d       	mov	@r13,	r14	;
    82e8:	2d 41       	mov	@r1,	r13	;
    82ea:	1d 4d 08 00 	mov	8(r13),	r13	;
    82ee:	1d 4d 28 00 	mov	40(r13),r13	;0x00028
    82f2:	0d de       	bis	r14,	r13	;
    82f4:	3d d0 83 00 	bis	#131,	r13	;#0x0083
    82f8:	8c 4d 00 00 	mov	r13,	0(r12)	;

000082fc <.Loc.286.3>:
}
    82fc:	03 43       	nop			
    82fe:	21 52       	add	#4,	r1	;r2 As==10
    8300:	30 41       	ret			

00008302 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {
    8302:	21 83       	decd	r1		;

00008304 <.LCFI9>:
    8304:	81 4c 00 00 	Address 0x0000000000008306 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00008306 <L0>:
	...

00008308 <.Loc.298.3>:

  /* TODO stop DMA transfers here */
  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    8308:	2c 41       	mov	@r1,	r12	;
    830a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    830e:	2d 41       	mov	@r1,	r13	;
    8310:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8314:	2d 4d       	mov	@r13,	r13	;
    8316:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    831a:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000831e <.Loc.301.3>:

#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    831e:	2c 41       	mov	@r1,	r12	;
    8320:	1c 4c 02 00 	mov	2(r12),	r12	;
    8324:	6c 4c       	mov.b	@r12,	r12	;
    8326:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8328:	4d 9c       	cmp.b	r12,	r13	;
    832a:	0d 2c       	jc	$+28     	;abs 0x8346

0000832c <.Loc.303.3>:
#endif
    if (adcp->dma.registers != NULL) {
    832c:	2c 41       	mov	@r1,	r12	;
    832e:	1c 4c 26 00 	mov	38(r12),r12	;0x00026
    8332:	0c 93       	cmp	#0,	r12	;r3 As==00
    8334:	08 24       	jz	$+18     	;abs 0x8346

00008336 <.Loc.304.3>:
      dmaRelease(&(adcp->dma));
    8336:	2c 41       	mov	@r1,	r12	;
    8338:	3c 50 26 00 	add	#38,	r12	;#0x0026
    833c:	b0 12 72 7a 	call	#31346		;#0x7a72

00008340 <.Loc.305.3>:
      adcp->dma.registers = NULL;
    8340:	2c 41       	mov	@r1,	r12	;
    8342:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

00008346 <.L68>:
    }
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
}
    8346:	03 43       	nop			
    8348:	21 53       	incd	r1		;
    834a:	30 41       	ret			

0000834c <adcMSP430XAdjustResult>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
    834c:	0a 15       	pushm	#1,	r10	;16-bit words

0000834e <.LCFI10>:
    834e:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00008352 <.LCFI11>:
    8352:	81 4c 02 00 	mov	r12,	2(r1)	;
    8356:	81 4d 00 00 	mov	r13,	0(r1)	;

0000835a <.Loc.316.3>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    835a:	1c 41 02 00 	mov	2(r1),	r12	;
    835e:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    8362:	3c 90 00 01 	cmp	#256,	r12	;#0x0100
    8366:	1c 24       	jz	$+58     	;abs 0x83a0

00008368 <.Loc.317.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    8368:	1c 41 02 00 	mov	2(r1),	r12	;
    836c:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00008370 <.Loc.316.3>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    8370:	3c 90 00 07 	cmp	#1792,	r12	;#0x0700
    8374:	15 24       	jz	$+44     	;abs 0x83a0

00008376 <.Loc.318.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    8376:	1c 41 02 00 	mov	2(r1),	r12	;
    837a:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

0000837e <.Loc.317.3>:
adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    837e:	3c 90 00 09 	cmp	#2304,	r12	;#0x0900
    8382:	0e 24       	jz	$+30     	;abs 0x83a0

00008384 <.Loc.319.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    8384:	1c 41 02 00 	mov	2(r1),	r12	;
    8388:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

0000838c <.Loc.318.3>:
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    838c:	3c 90 00 0b 	cmp	#2816,	r12	;#0x0b00
    8390:	07 24       	jz	$+16     	;abs 0x83a0

00008392 <.Loc.320.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    8392:	1c 41 02 00 	mov	2(r1),	r12	;
    8396:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

0000839a <.Loc.319.3>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    839a:	3c 90 00 0d 	cmp	#3328,	r12	;#0x0d00
    839e:	26 20       	jnz	$+78     	;abs 0x83ec

000083a0 <.L70>:
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    /* Retrieve proper reference correction factor from TLV */
    fact = (&(ADCD1.ref_cal->CAL_ADC_12VREF_FACTOR))[grpp->vref_src >> 4];
    83a0:	1c 42 96 53 	mov	&0x5396,r12	;0x5396
    83a4:	0d 4c       	mov	r12,	r13	;
    83a6:	1c 41 02 00 	mov	2(r1),	r12	;
    83aa:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    83ae:	5c 0f       	rrum	#4,	r12	;
    83b0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    83b4:	0c 5c       	rla	r12		;
    83b6:	0c 5d       	add	r13,	r12	;
    83b8:	a1 4c 08 00 	mov	@r12,	8(r1)	;

000083bc <.Loc.324.3>:
    /* Calculate corrected value */
    tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    83bc:	2c 41       	mov	@r1,	r12	;
    83be:	0c 5c       	rla	r12		;
    83c0:	0d 43       	clr	r13		;
    83c2:	1a 41 08 00 	mov	8(r1),	r10	;
    83c6:	0e 4a       	mov	r10,	r14	;
    83c8:	0f 43       	clr	r15		;
    83ca:	b0 12 cc 8d 	call	#36300		;#0x8dcc
    83ce:	81 4c 04 00 	mov	r12,	4(r1)	;
    83d2:	81 4d 06 00 	mov	r13,	6(r1)	;

000083d6 <.Loc.325.3>:
    sample = tmp >> 16;
    83d6:	1c 41 04 00 	mov	4(r1),	r12	;
    83da:	1d 41 06 00 	mov	6(r1),	r13	;
    83de:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    83e2:	4f 43       	clr.b	r15		;
    83e4:	b0 12 b2 8d 	call	#36274		;#0x8db2
    83e8:	81 4c 00 00 	mov	r12,	0(r1)	;

000083ec <.L71>:
  }

  /* Gain correction */
  fact   = ADCD1.adc_cal->CAL_ADC_GAIN_FACTOR;
    83ec:	1c 42 94 53 	mov	&0x5394,r12	;0x5394
    83f0:	a1 4c 08 00 	mov	@r12,	8(r1)	;

000083f4 <.Loc.330.3>:
  tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    83f4:	2c 41       	mov	@r1,	r12	;
    83f6:	0c 5c       	rla	r12		;
    83f8:	0d 43       	clr	r13		;
    83fa:	1a 41 08 00 	mov	8(r1),	r10	;
    83fe:	0e 4a       	mov	r10,	r14	;
    8400:	0f 43       	clr	r15		;
    8402:	b0 12 cc 8d 	call	#36300		;#0x8dcc
    8406:	81 4c 04 00 	mov	r12,	4(r1)	;
    840a:	81 4d 06 00 	mov	r13,	6(r1)	;

0000840e <.Loc.331.3>:
  sample = tmp >> 16;
    840e:	1c 41 04 00 	mov	4(r1),	r12	;
    8412:	1d 41 06 00 	mov	6(r1),	r13	;
    8416:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    841a:	4f 43       	clr.b	r15		;
    841c:	b0 12 b2 8d 	call	#36274		;#0x8db2
    8420:	81 4c 00 00 	mov	r12,	0(r1)	;

00008424 <.Loc.334.3>:

  /* Offset correction */
  sample += ADCD1.adc_cal->CAL_ADC_OFFSET;
    8424:	1c 42 94 53 	mov	&0x5394,r12	;0x5394
    8428:	1c 4c 02 00 	mov	2(r12),	r12	;
    842c:	81 5c 00 00 	add	r12,	0(r1)	;

00008430 <.Loc.336.3>:

  return sample;
    8430:	2c 41       	mov	@r1,	r12	;

00008432 <.Loc.337.3>:
}
    8432:	31 50 0a 00 	add	#10,	r1	;#0x000a
    8436:	0a 17       	popm	#1,	r10	;16-bit words
    8438:	30 41       	ret			

0000843a <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    843a:	32 c2       	dint			

0000843c <.Loc.46.1>:

}
    843c:	03 43       	nop			
    843e:	30 41       	ret			

00008440 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    8440:	ff 3f       	jmp	$+0      	;abs 0x8440

00008442 <Vector2>:
    8442:	ff 3f       	jmp	$+0      	;abs 0x8442

00008444 <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    8444:	ff 3f       	jmp	$+0      	;abs 0x8444

00008446 <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    8446:	ff 3f       	jmp	$+0      	;abs 0x8446

00008448 <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    8448:	ff 3f       	jmp	$+0      	;abs 0x8448

0000844a <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    844a:	ff 3f       	jmp	$+0      	;abs 0x844a

0000844c <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    844c:	ff 3f       	jmp	$+0      	;abs 0x844c

0000844e <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    844e:	ff 3f       	jmp	$+0      	;abs 0x844e

00008450 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    8450:	ff 3f       	jmp	$+0      	;abs 0x8450

00008452 <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    8452:	ff 3f       	jmp	$+0      	;abs 0x8452

00008454 <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    8454:	ff 3f       	jmp	$+0      	;abs 0x8454

00008456 <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    8456:	ff 3f       	jmp	$+0      	;abs 0x8456

00008458 <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    8458:	ff 3f       	jmp	$+0      	;abs 0x8458

0000845a <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    845a:	ff 3f       	jmp	$+0      	;abs 0x845a

0000845c <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    845c:	ff 3f       	jmp	$+0      	;abs 0x845c

0000845e <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    845e:	ff 3f       	jmp	$+0      	;abs 0x845e

00008460 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    8460:	ff 3f       	jmp	$+0      	;abs 0x8460

00008462 <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    8462:	ff 3f       	jmp	$+0      	;abs 0x8462

00008464 <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    8464:	ff 3f       	jmp	$+0      	;abs 0x8464

00008466 <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    8466:	ff 3f       	jmp	$+0      	;abs 0x8466

00008468 <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    8468:	ff 3f       	jmp	$+0      	;abs 0x8468

0000846a <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    846a:	ff 3f       	jmp	$+0      	;abs 0x846a

0000846c <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    846c:	ff 3f       	jmp	$+0      	;abs 0x846c

0000846e <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    846e:	ff 3f       	jmp	$+0      	;abs 0x846e

00008470 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    8470:	ff 3f       	jmp	$+0      	;abs 0x8470

00008472 <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    8472:	ff 3f       	jmp	$+0      	;abs 0x8472

00008474 <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    8474:	ff 3f       	jmp	$+0      	;abs 0x8474

00008476 <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    8476:	ff 3f       	jmp	$+0      	;abs 0x8476

00008478 <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    8478:	ff 3f       	jmp	$+0      	;abs 0x8478

0000847a <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    847a:	ff 3f       	jmp	$+0      	;abs 0x847a

0000847c <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    847c:	ff 3f       	jmp	$+0      	;abs 0x847c

0000847e <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    847e:	ff 3f       	jmp	$+0      	;abs 0x847e

00008480 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    8480:	ff 3f       	jmp	$+0      	;abs 0x8480

00008482 <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    8482:	ff 3f       	jmp	$+0      	;abs 0x8482

00008484 <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    8484:	ff 3f       	jmp	$+0      	;abs 0x8484

00008486 <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    8486:	ff 3f       	jmp	$+0      	;abs 0x8486

00008488 <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    8488:	ff 3f       	jmp	$+0      	;abs 0x8488

0000848a <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    848a:	ff 3f       	jmp	$+0      	;abs 0x848a

0000848c <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    848c:	ff 3f       	jmp	$+0      	;abs 0x848c

0000848e <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    848e:	ff 3f       	jmp	$+0      	;abs 0x848e

00008490 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    8490:	ff 3f       	jmp	$+0      	;abs 0x8490

00008492 <Vector48>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    8492:	ff 3f       	jmp	$+0      	;abs 0x8492

00008494 <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    8494:	ff 3f       	jmp	$+0      	;abs 0x8494

00008496 <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    8496:	ff 3f       	jmp	$+0      	;abs 0x8496

00008498 <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    8498:	ff 3f       	jmp	$+0      	;abs 0x8498

0000849a <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    849a:	ff 3f       	jmp	$+0      	;abs 0x849a

0000849c <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    849c:	ff 3f       	jmp	$+0      	;abs 0x849c

0000849e <convert_ntc>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    849e:	5a 15       	pushm	#6,	r10	;16-bit words

000084a0 <L0>:

static SX1278Driver SX1278D1;

typedef int64_t fixed_q36_8;

fixed_q36_8 convert_ntc(ADCConversionGroup *grpp, adcsample_t sample) {
    84a0:	31 80 44 00 	sub	#68,	r1	;#0x0044

000084a4 <.LCFI1>:
    84a4:	81 4c 2c 00 	mov	r12,	44(r1)	; 0x002c
    84a8:	81 4d 2a 00 	mov	r13,	42(r1)	; 0x002a

000084ac <.Loc.101.1>:
  const int32_t c3 = -10; /* Q0.31 */
    84ac:	b1 40 f6 ff 	mov	#65526,	64(r1)	;#0xfff6, 0x0040
    84b0:	40 00 
    84b2:	b1 43 42 00 	mov	#-1,	66(r1)	;r3 As==11, 0x0042

000084b6 <.Loc.102.1>:
  const int32_t c2 = 66515; /* Q0.31 */
    84b6:	b1 40 d3 03 	mov	#979,	60(r1)	;#0x03d3, 0x003c
    84ba:	3c 00 
    84bc:	91 43 3e 00 	mov	#1,	62(r1)	;r3 As==01, 0x003e

000084c0 <.Loc.103.1>:
  const int16_t c1 = -2841; /* Q0.15 */
    84c0:	b1 40 e7 f4 	mov	#62695,	58(r1)	;#0xf4e7, 0x003a
    84c4:	3a 00 

000084c6 <.Loc.104.1>:
  const int32_t c0 = 28750; /* Q7.8 */
    84c6:	b1 40 4e 70 	mov	#28750,	54(r1)	;#0x704e, 0x0036
    84ca:	36 00 
    84cc:	81 43 38 00 	mov	#0,	56(r1)	;r3 As==00, 0x0038

000084d0 <.Loc.108.1>:
  int64_t y;
  
  /* Get converted ADC value */
  adcMSP430XAdjustResult(grpp, sample);
    84d0:	1d 41 2a 00 	mov	42(r1),	r13	;0x0002a
    84d4:	1c 41 2c 00 	mov	44(r1),	r12	;0x0002c
    84d8:	b0 12 4c 83 	call	#33612		;#0x834c

000084dc <.Loc.115.1>:
  /* Convert value */
  /* NOTE: This is a lot of fixed point math. The regression line I'm using 
   * comes from LibreOffice, plotting Temperature vs. DN over the -40..+85 C
   * range. The equation is -4.6411...x^3+3.0974...x^2-0.0867...x+112.3073
   * We solve it using Horner's rule in fixed point math as follows */
  y = c3 * sample; /* Q0.31 * Q12.0 => Q12.31 */
    84dc:	1e 41 2a 00 	mov	42(r1),	r14	;0x0002a
    84e0:	0c 4e       	mov	r14,	r12	;
    84e2:	0d 43       	clr	r13		;
    84e4:	1e 41 40 00 	mov	64(r1),	r14	;0x00040
    84e8:	1f 41 42 00 	mov	66(r1),	r15	;0x00042
    84ec:	b0 12 cc 8d 	call	#36300		;#0x8dcc
    84f0:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    84f4:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    84f8:	0c 4d       	mov	r13,	r12	;
    84fa:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    84fe:	81 4c 32 00 	mov	r12,	50(r1)	; 0x0032
    8502:	81 4c 34 00 	mov	r12,	52(r1)	; 0x0034

00008506 <.Loc.116.1>:
  y += c2; /* Q12.31 + Q0.31 => OK */
    8506:	1c 41 3c 00 	mov	60(r1),	r12	;0x0003c
    850a:	1d 41 3e 00 	mov	62(r1),	r13	;0x0003e
    850e:	81 4c 22 00 	mov	r12,	34(r1)	; 0x0022
    8512:	81 4d 24 00 	mov	r13,	36(r1)	; 0x0024
    8516:	0c 4d       	mov	r13,	r12	;
    8518:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    851c:	81 4c 26 00 	mov	r12,	38(r1)	; 0x0026
    8520:	81 4c 28 00 	mov	r12,	40(r1)	; 0x0028
    8524:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    8528:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    852c:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    8530:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    8534:	0c 48       	mov	r8,	r12	;
    8536:	1c 51 22 00 	add	34(r1),	r12	;0x00022
    853a:	56 43       	mov.b	#1,	r6	;r3 As==01
    853c:	07 4c       	mov	r12,	r7	;
    853e:	07 98       	cmp	r8,	r7	;
    8540:	01 28       	jnc	$+4      	;abs 0x8544
    8542:	46 43       	clr.b	r6		;

00008544 <.L2>:
    8544:	0d 49       	mov	r9,	r13	;
    8546:	1d 51 24 00 	add	36(r1),	r13	;0x00024
    854a:	55 43       	mov.b	#1,	r5	;r3 As==01
    854c:	07 4d       	mov	r13,	r7	;
    854e:	07 99       	cmp	r9,	r7	;
    8550:	01 28       	jnc	$+4      	;abs 0x8554
    8552:	45 43       	clr.b	r5		;

00008554 <.L3>:
    8554:	06 5d       	add	r13,	r6	;
    8556:	57 43       	mov.b	#1,	r7	;r3 As==01
    8558:	06 9d       	cmp	r13,	r6	;
    855a:	01 28       	jnc	$+4      	;abs 0x855e
    855c:	47 43       	clr.b	r7		;

0000855e <.L4>:
    855e:	05 d7       	bis	r7,	r5	;
    8560:	0d 46       	mov	r6,	r13	;
    8562:	0e 4a       	mov	r10,	r14	;
    8564:	1e 51 26 00 	add	38(r1),	r14	;0x00026
    8568:	56 43       	mov.b	#1,	r6	;r3 As==01
    856a:	07 4e       	mov	r14,	r7	;
    856c:	07 9a       	cmp	r10,	r7	;
    856e:	01 28       	jnc	$+4      	;abs 0x8572
    8570:	46 43       	clr.b	r6		;

00008572 <.L5>:
    8572:	05 5e       	add	r14,	r5	;
    8574:	57 43       	mov.b	#1,	r7	;r3 As==01
    8576:	05 9e       	cmp	r14,	r5	;
    8578:	01 28       	jnc	$+4      	;abs 0x857c
    857a:	47 43       	clr.b	r7		;

0000857c <.L6>:
    857c:	06 d7       	bis	r7,	r6	;
    857e:	0e 45       	mov	r5,	r14	;
    8580:	0f 4b       	mov	r11,	r15	;
    8582:	1f 51 28 00 	add	40(r1),	r15	;0x00028
    8586:	0a 46       	mov	r6,	r10	;
    8588:	0a 5f       	add	r15,	r10	;
    858a:	0f 4a       	mov	r10,	r15	;
    858c:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    8590:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    8594:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    8598:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

0000859c <.Loc.117.1>:
  y *= sample; /* Q12.31 * Q12.0 => Q24.31 */
    859c:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    85a0:	81 4c 1a 00 	mov	r12,	26(r1)	; 0x001a
    85a4:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c
    85a8:	81 43 1e 00 	mov	#0,	30(r1)	;r3 As==00, 0x001e
    85ac:	81 43 20 00 	mov	#0,	32(r1)	;r3 As==00, 0x0020
    85b0:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    85b4:	1d 41 1c 00 	mov	28(r1),	r13	;0x0001c
    85b8:	1e 41 1e 00 	mov	30(r1),	r14	;0x0001e
    85bc:	1f 41 20 00 	mov	32(r1),	r15	;0x00020
    85c0:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    85c4:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    85c8:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    85cc:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    85d0:	b0 12 9c 89 	call	#35228		;#0x899c
    85d4:	08 4c       	mov	r12,	r8	;
    85d6:	09 4d       	mov	r13,	r9	;
    85d8:	0a 4e       	mov	r14,	r10	;
    85da:	0b 4f       	mov	r15,	r11	;
    85dc:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    85e0:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    85e4:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    85e8:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000085ec <.Loc.118.1>:
  y = (y >> 16); /* Q24.31 >> 16 => Q24.15 */
    85ec:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    85f0:	00 00 
    85f2:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    85f6:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    85fa:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    85fe:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    8602:	b0 12 e6 8a 	call	#35558		;#0x8ae6
    8606:	08 4c       	mov	r12,	r8	;
    8608:	09 4d       	mov	r13,	r9	;
    860a:	0a 4e       	mov	r14,	r10	;
    860c:	0b 4f       	mov	r15,	r11	;
    860e:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    8612:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    8616:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    861a:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

0000861e <.Loc.119.1>:
  y += c1; /* Q24.15 + Q0.15 => OK */
    861e:	1c 41 3a 00 	mov	58(r1),	r12	;0x0003a
    8622:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    8626:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    862a:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    862e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    8632:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018
    8636:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    863a:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    863e:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    8642:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    8646:	0c 48       	mov	r8,	r12	;
    8648:	1c 51 12 00 	add	18(r1),	r12	;0x00012
    864c:	56 43       	mov.b	#1,	r6	;r3 As==01
    864e:	07 4c       	mov	r12,	r7	;
    8650:	07 98       	cmp	r8,	r7	;
    8652:	01 28       	jnc	$+4      	;abs 0x8656
    8654:	46 43       	clr.b	r6		;

00008656 <.L7>:
    8656:	0d 49       	mov	r9,	r13	;
    8658:	1d 51 14 00 	add	20(r1),	r13	;0x00014
    865c:	55 43       	mov.b	#1,	r5	;r3 As==01
    865e:	07 4d       	mov	r13,	r7	;
    8660:	07 99       	cmp	r9,	r7	;
    8662:	01 28       	jnc	$+4      	;abs 0x8666
    8664:	45 43       	clr.b	r5		;

00008666 <.L8>:
    8666:	06 5d       	add	r13,	r6	;
    8668:	57 43       	mov.b	#1,	r7	;r3 As==01
    866a:	06 9d       	cmp	r13,	r6	;
    866c:	01 28       	jnc	$+4      	;abs 0x8670
    866e:	47 43       	clr.b	r7		;

00008670 <.L9>:
    8670:	05 d7       	bis	r7,	r5	;
    8672:	0d 46       	mov	r6,	r13	;
    8674:	0e 4a       	mov	r10,	r14	;
    8676:	1e 51 16 00 	add	22(r1),	r14	;0x00016
    867a:	56 43       	mov.b	#1,	r6	;r3 As==01
    867c:	07 4e       	mov	r14,	r7	;
    867e:	07 9a       	cmp	r10,	r7	;
    8680:	01 28       	jnc	$+4      	;abs 0x8684
    8682:	46 43       	clr.b	r6		;

00008684 <.L10>:
    8684:	05 5e       	add	r14,	r5	;
    8686:	57 43       	mov.b	#1,	r7	;r3 As==01
    8688:	05 9e       	cmp	r14,	r5	;
    868a:	01 28       	jnc	$+4      	;abs 0x868e
    868c:	47 43       	clr.b	r7		;

0000868e <.L11>:
    868e:	06 d7       	bis	r7,	r6	;
    8690:	0e 45       	mov	r5,	r14	;
    8692:	0f 4b       	mov	r11,	r15	;
    8694:	1f 51 18 00 	add	24(r1),	r15	;0x00018
    8698:	0a 46       	mov	r6,	r10	;
    869a:	0a 5f       	add	r15,	r10	;
    869c:	0f 4a       	mov	r10,	r15	;
    869e:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    86a2:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    86a6:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    86aa:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

000086ae <.Loc.120.1>:
  y *= sample; /* Q24.15 * Q12.0 => Q36.15 */
    86ae:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    86b2:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    86b6:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c
    86ba:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    86be:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    86c2:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    86c6:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    86ca:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    86ce:	1f 41 10 00 	mov	16(r1),	r15	;0x00010
    86d2:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    86d6:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    86da:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    86de:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    86e2:	b0 12 9c 89 	call	#35228		;#0x899c
    86e6:	08 4c       	mov	r12,	r8	;
    86e8:	09 4d       	mov	r13,	r9	;
    86ea:	0a 4e       	mov	r14,	r10	;
    86ec:	0b 4f       	mov	r15,	r11	;
    86ee:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    86f2:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    86f6:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    86fa:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000086fe <.Loc.121.1>:
  y = (y >> 7); /* Q36.15 >> 7 => Q36.8 */
    86fe:	b1 40 07 00 	mov	#7,	0(r1)	;
    8702:	00 00 
    8704:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    8708:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    870c:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    8710:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    8714:	b0 12 e6 8a 	call	#35558		;#0x8ae6
    8718:	08 4c       	mov	r12,	r8	;
    871a:	09 4d       	mov	r13,	r9	;
    871c:	0a 4e       	mov	r14,	r10	;
    871e:	0b 4f       	mov	r15,	r11	;
    8720:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    8724:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    8728:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    872c:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

00008730 <.Loc.122.1>:
  y += c0; /* Q36.8 + Q7.8 => OK */
    8730:	1c 41 36 00 	mov	54(r1),	r12	;0x00036
    8734:	1d 41 38 00 	mov	56(r1),	r13	;0x00038
    8738:	81 4c 02 00 	mov	r12,	2(r1)	;
    873c:	81 4d 04 00 	mov	r13,	4(r1)	;
    8740:	0c 4d       	mov	r13,	r12	;
    8742:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8746:	81 4c 06 00 	mov	r12,	6(r1)	;
    874a:	81 4c 08 00 	mov	r12,	8(r1)	;
    874e:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    8752:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    8756:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    875a:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    875e:	0c 48       	mov	r8,	r12	;
    8760:	1c 51 02 00 	add	2(r1),	r12	;
    8764:	56 43       	mov.b	#1,	r6	;r3 As==01
    8766:	07 4c       	mov	r12,	r7	;
    8768:	07 98       	cmp	r8,	r7	;
    876a:	01 28       	jnc	$+4      	;abs 0x876e
    876c:	46 43       	clr.b	r6		;

0000876e <.L12>:
    876e:	0d 49       	mov	r9,	r13	;
    8770:	1d 51 04 00 	add	4(r1),	r13	;
    8774:	55 43       	mov.b	#1,	r5	;r3 As==01
    8776:	07 4d       	mov	r13,	r7	;
    8778:	07 99       	cmp	r9,	r7	;
    877a:	01 28       	jnc	$+4      	;abs 0x877e
    877c:	45 43       	clr.b	r5		;

0000877e <.L13>:
    877e:	06 5d       	add	r13,	r6	;
    8780:	57 43       	mov.b	#1,	r7	;r3 As==01
    8782:	06 9d       	cmp	r13,	r6	;
    8784:	01 28       	jnc	$+4      	;abs 0x8788
    8786:	47 43       	clr.b	r7		;

00008788 <.L14>:
    8788:	05 d7       	bis	r7,	r5	;
    878a:	0d 46       	mov	r6,	r13	;
    878c:	0e 4a       	mov	r10,	r14	;
    878e:	1e 51 06 00 	add	6(r1),	r14	;
    8792:	56 43       	mov.b	#1,	r6	;r3 As==01
    8794:	07 4e       	mov	r14,	r7	;
    8796:	07 9a       	cmp	r10,	r7	;
    8798:	01 28       	jnc	$+4      	;abs 0x879c
    879a:	46 43       	clr.b	r6		;

0000879c <.L15>:
    879c:	05 5e       	add	r14,	r5	;
    879e:	57 43       	mov.b	#1,	r7	;r3 As==01
    87a0:	05 9e       	cmp	r14,	r5	;
    87a2:	01 28       	jnc	$+4      	;abs 0x87a6
    87a4:	47 43       	clr.b	r7		;

000087a6 <.L16>:
    87a6:	06 d7       	bis	r7,	r6	;
    87a8:	0e 45       	mov	r5,	r14	;
    87aa:	0f 4b       	mov	r11,	r15	;
    87ac:	1f 51 08 00 	add	8(r1),	r15	;
    87b0:	0a 46       	mov	r6,	r10	;
    87b2:	0a 5f       	add	r15,	r10	;
    87b4:	0f 4a       	mov	r10,	r15	;
    87b6:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    87ba:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    87be:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    87c2:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

000087c6 <.Loc.126.1>:
  
  /* Now y is our result in Q36.8 format. We return it using a typedef to
   * make that clear. */
  return y;
    87c6:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    87ca:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    87ce:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    87d2:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    87d6:	08 4c       	mov	r12,	r8	;
    87d8:	09 4d       	mov	r13,	r9	;
    87da:	0a 4e       	mov	r14,	r10	;
    87dc:	0b 4f       	mov	r15,	r11	;

000087de <.Loc.127.1>:
}
    87de:	0c 48       	mov	r8,	r12	;
    87e0:	0d 49       	mov	r9,	r13	;
    87e2:	0e 4a       	mov	r10,	r14	;
    87e4:	0f 4b       	mov	r11,	r15	;
    87e6:	31 50 44 00 	add	#68,	r1	;#0x0044
    87ea:	55 17       	popm	#6,	r10	;16-bit words
    87ec:	30 41       	ret			

000087ee <Thread2>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    87ee:	3a 15       	pushm	#4,	r10	;16-bit words

000087f0 <.LCFI2>:
    87f0:	31 80 10 00 	sub	#16,	r1	;#0x0010

000087f4 <.LCFI3>:
    87f4:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

000087f8 <.Loc.145.1>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    87f8:	4d 43       	clr.b	r13		;
    87fa:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    87fe:	b0 12 0c 6d 	call	#27916		;#0x6d0c

00008802 <.Loc.148.1>:
  
  /* Activate the ADC driver 1 using its config */
  adcStart(&ADCD1, &adc_config);
    8802:	3d 40 50 51 	mov	#20816,	r13	;#0x5150
    8806:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    880a:	b0 12 1c 6a 	call	#27164		;#0x6a1c

0000880e <.Loc.158.1>:
  /* Start the SX1212 driver */
  /*sx1278Start(&SX1278D1, &config);*/

  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    880e:	ad 3c       	jmp	$+348    	;abs 0x896a

00008810 <.L23>:
    
    /* Test 1 - Read the NTC thermistor value */
    /*chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));*/
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    8810:	5f 43       	mov.b	#1,	r15	;r3 As==01
    8812:	3e 40 b0 53 	mov	#21424,	r14	;#0x53b0
    8816:	3d 40 52 51 	mov	#20818,	r13	;#0x5152
    881a:	3c 40 74 53 	mov	#21364,	r12	;#0x5374
    881e:	b0 12 4c 6a 	call	#27212		;#0x6a4c

00008822 <.Loc.163.1>:
    while (ADCD1.state == ADC_ACTIVE) ;
    8822:	03 43       	nop			

00008824 <.L20>:
    8824:	5c 42 74 53 	mov.b	&0x5374,r12	;0x5374
    8828:	7c 90 03 00 	cmp.b	#3,	r12	;
    882c:	fb 27       	jz	$-8      	;abs 0x8824

0000882e <.LBB2>:
    
    for (int i = 0; i < 2; i++) {
    882e:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    8832:	1f 3c       	jmp	$+64     	;abs 0x8872

00008834 <.L22>:
      temps[i] = convert_ntc(&adc_group, samples[i]);
    8834:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    8838:	0c 5c       	rla	r12		;
    883a:	3c 50 b0 53 	add	#21424,	r12	;#0x53b0
    883e:	2c 4c       	mov	@r12,	r12	;
    8840:	0d 4c       	mov	r12,	r13	;
    8842:	3c 40 52 51 	mov	#20818,	r12	;#0x5152
    8846:	b0 12 9e 84 	call	#33950		;#0x849e
    884a:	08 4c       	mov	r12,	r8	;
    884c:	09 4d       	mov	r13,	r9	;
    884e:	0a 4e       	mov	r14,	r10	;
    8850:	0b 4f       	mov	r15,	r11	;
    8852:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    8856:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    885a:	3c 50 a0 53 	add	#21408,	r12	;#0x53a0
    885e:	8c 48 00 00 	mov	r8,	0(r12)	;
    8862:	8c 49 02 00 	mov	r9,	2(r12)	;
    8866:	8c 4a 04 00 	mov	r10,	4(r12)	;
    886a:	8c 4b 06 00 	mov	r11,	6(r12)	;

0000886e <.Loc.165.1>:
    /* Test 1 - Read the NTC thermistor value */
    /*chnWrite(&SD0, (const uint8_t *)test_1_msg, strlen(test_1_msg));*/
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    while (ADCD1.state == ADC_ACTIVE) ;
    
    for (int i = 0; i < 2; i++) {
    886e:	91 53 0e 00 	inc	14(r1)		;

00008872 <.L21>:
    8872:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8874:	1c 91 0e 00 	cmp	14(r1),	r12	;0x0000e
    8878:	dd 37       	jge	$-68     	;abs 0x8834

0000887a <.LBE2>:
      temps[i] = convert_ntc(&adc_group, samples[i]);
    }
    
    sniprintf(out_string, 128, fmt_string, "Bottom", temps[0] >> 8);
    887a:	17 42 80 51 	mov	&0x5180,r7	;0x5180
    887e:	18 42 a0 53 	mov	&0x53a0,r8	;0x53a0
    8882:	19 42 a2 53 	mov	&0x53a2,r9	;0x53a2
    8886:	1a 42 a4 53 	mov	&0x53a4,r10	;0x53a4
    888a:	1b 42 a6 53 	mov	&0x53a6,r11	;0x53a6
    888e:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    8892:	0c 48       	mov	r8,	r12	;
    8894:	0d 49       	mov	r9,	r13	;
    8896:	0e 4a       	mov	r10,	r14	;
    8898:	0f 4b       	mov	r11,	r15	;
    889a:	b0 12 e6 8a 	call	#35558		;#0x8ae6
    889e:	08 4c       	mov	r12,	r8	;
    88a0:	09 4d       	mov	r13,	r9	;
    88a2:	0a 4e       	mov	r14,	r10	;
    88a4:	0b 4f       	mov	r15,	r11	;
    88a6:	0c 48       	mov	r8,	r12	;
    88a8:	0d 49       	mov	r9,	r13	;
    88aa:	0e 4a       	mov	r10,	r14	;
    88ac:	0f 4b       	mov	r11,	r15	;
    88ae:	81 4c 04 00 	mov	r12,	4(r1)	;
    88b2:	81 4d 06 00 	mov	r13,	6(r1)	;
    88b6:	81 4e 08 00 	mov	r14,	8(r1)	;
    88ba:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    88be:	b1 40 80 50 	mov	#20608,	2(r1)	;#0x5080
    88c2:	02 00 
    88c4:	81 47 00 00 	mov	r7,	0(r1)	;
    88c8:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    88cc:	3c 40 b4 53 	mov	#21428,	r12	;#0x53b4
    88d0:	b0 12 00 8e 	call	#36352		;#0x8e00

000088d4 <.Loc.170.1>:
    chnWrite(&SD0, (const uint8_t *)out_string, strlen(out_string));
    88d4:	1c 42 7c 52 	mov	&0x527c,r12	;0x527c
    88d8:	2a 4c       	mov	@r12,	r10	;
    88da:	3c 40 b4 53 	mov	#21428,	r12	;#0x53b4
    88de:	b0 12 6a 8e 	call	#36458		;#0x8e6a
    88e2:	0e 4c       	mov	r12,	r14	;
    88e4:	3d 40 b4 53 	mov	#21428,	r13	;#0x53b4
    88e8:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    88ec:	8a 12       	call	r10		;

000088ee <.Loc.171.1>:
    sniprintf(out_string, 128, fmt_string, "Top", temps[1] >> 8);
    88ee:	17 42 80 51 	mov	&0x5180,r7	;0x5180
    88f2:	18 42 a8 53 	mov	&0x53a8,r8	;0x53a8
    88f6:	19 42 aa 53 	mov	&0x53aa,r9	;0x53aa
    88fa:	1a 42 ac 53 	mov	&0x53ac,r10	;0x53ac
    88fe:	1b 42 ae 53 	mov	&0x53ae,r11	;0x53ae
    8902:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    8906:	0c 48       	mov	r8,	r12	;
    8908:	0d 49       	mov	r9,	r13	;
    890a:	0e 4a       	mov	r10,	r14	;
    890c:	0f 4b       	mov	r11,	r15	;
    890e:	b0 12 e6 8a 	call	#35558		;#0x8ae6
    8912:	08 4c       	mov	r12,	r8	;
    8914:	09 4d       	mov	r13,	r9	;
    8916:	0a 4e       	mov	r14,	r10	;
    8918:	0b 4f       	mov	r15,	r11	;
    891a:	0c 48       	mov	r8,	r12	;
    891c:	0d 49       	mov	r9,	r13	;
    891e:	0e 4a       	mov	r10,	r14	;
    8920:	0f 4b       	mov	r11,	r15	;
    8922:	81 4c 04 00 	mov	r12,	4(r1)	;
    8926:	81 4d 06 00 	mov	r13,	6(r1)	;
    892a:	81 4e 08 00 	mov	r14,	8(r1)	;
    892e:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    8932:	b1 40 87 50 	mov	#20615,	2(r1)	;#0x5087
    8936:	02 00 
    8938:	81 47 00 00 	mov	r7,	0(r1)	;
    893c:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    8940:	3c 40 b4 53 	mov	#21428,	r12	;#0x53b4
    8944:	b0 12 00 8e 	call	#36352		;#0x8e00

00008948 <.Loc.172.1>:
    chnWrite(&SD0, (const uint8_t *)out_string, strlen(out_string));
    8948:	1c 42 7c 52 	mov	&0x527c,r12	;0x527c
    894c:	2a 4c       	mov	@r12,	r10	;
    894e:	3c 40 b4 53 	mov	#21428,	r12	;#0x53b4
    8952:	b0 12 6a 8e 	call	#36458		;#0x8e6a
    8956:	0e 4c       	mov	r12,	r14	;
    8958:	3d 40 b4 53 	mov	#21428,	r13	;#0x53b4
    895c:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    8960:	8a 12       	call	r10		;

00008962 <.Loc.174.1>:
    
    chThdSleepMilliseconds(2000);
    8962:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    8966:	b0 12 40 61 	call	#24896		;#0x6140

0000896a <.L19>:
  /* Start the SX1212 driver */
  /*sx1278Start(&SX1278D1, &config);*/

  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    896a:	1c 42 7c 52 	mov	&0x527c,r12	;0x527c
    896e:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    8972:	4d 43       	clr.b	r13		;
    8974:	3c 40 7c 52 	mov	#21116,	r12	;#0x527c
    8978:	8e 12       	call	r14		;
    897a:	0c 93       	cmp	#0,	r12	;r3 As==00
    897c:	49 23       	jnz	$-364    	;abs 0x8810

0000897e <.Loc.176.1>:
    sniprintf(out_string, 128, fmt_string, "Top", temps[1] >> 8);
    chnWrite(&SD0, (const uint8_t *)out_string, strlen(out_string));
    
    chThdSleepMilliseconds(2000);
  }
}
    897e:	03 43       	nop			
    8980:	31 50 10 00 	add	#16,	r1	;#0x0010
    8984:	37 17       	popm	#4,	r10	;16-bit words
    8986:	30 41       	ret			

00008988 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    8988:	b2 40 80 5a 	Address 0x000000000000898c is out of bounds.
mov	#23168,	&0xffff	;#0x5a80
    898c:	5c 01 

0000898c <L0>:
    898c:	5c 01       	rram	#1,	r12	;

0000898e <.Loc.201.1>:
  

  halInit();
    898e:	b0 12 72 63 	call	#25458		;#0x6372

00008992 <.Loc.202.1>:
  chSysInit();
    8992:	b0 12 38 5e 	call	#24120		;#0x5e38

00008996 <.Loc.203.1>:
  dmaInit();
    8996:	b0 12 72 78 	call	#30834		;#0x7872

0000899a <.L25>:
  
  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    899a:	ff 3f       	jmp	$+0      	;abs 0x899a

0000899c <__mspabi_mpyll>:
    899c:	6a 15       	pushm	#7,	r10	;16-bit words

0000899e <L0>:
    899e:	31 80 1c 00 	sub	#28,	r1	;#0x001c

000089a2 <.LCFI1>:
    89a2:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    89a6:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    89aa:	06 4c       	mov	r12,	r6	;
    89ac:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    89b0:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    89b4:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

000089b8 <.LBB2>:
    89b8:	0a 48       	mov	r8,	r10	;
    89ba:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    89be:	0c 48       	mov	r8,	r12	;

000089c0 <.LVL3>:
    89c0:	0d 49       	mov	r9,	r13	;
    89c2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    89c6:	b0 12 b2 8d 	call	#36274		;#0x8db2
    89ca:	81 4c 00 00 	mov	r12,	0(r1)	;
    89ce:	81 4d 02 00 	mov	r13,	2(r1)	;

000089d2 <.LVL5>:
    89d2:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    89d6:	0c 46       	mov	r6,	r12	;
    89d8:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    89dc:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    89e0:	b0 12 b2 8d 	call	#36274		;#0x8db2
    89e4:	81 4c 04 00 	mov	r12,	4(r1)	;
    89e8:	81 4d 06 00 	mov	r13,	6(r1)	;
    89ec:	38 40 cc 8d 	mov	#36300,	r8	;#0x8dcc

000089f0 <.LVL9>:
    89f0:	0e 46       	mov	r6,	r14	;
    89f2:	4f 43       	clr.b	r15		;
    89f4:	0c 4a       	mov	r10,	r12	;
    89f6:	0d 4f       	mov	r15,	r13	;
    89f8:	88 12       	call	r8		;

000089fa <.LVL10>:
    89fa:	04 4c       	mov	r12,	r4	;
    89fc:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    8a00:	05 4d       	mov	r13,	r5	;

00008a02 <.LVL11>:
    8a02:	0e 46       	mov	r6,	r14	;
    8a04:	4f 43       	clr.b	r15		;
    8a06:	2c 41       	mov	@r1,	r12	;
    8a08:	1d 41 02 00 	mov	2(r1),	r13	;
    8a0c:	88 12       	call	r8		;

00008a0e <.LVL12>:
    8a0e:	06 4c       	mov	r12,	r6	;
    8a10:	07 4d       	mov	r13,	r7	;

00008a12 <.LVL14>:
    8a12:	1e 41 04 00 	mov	4(r1),	r14	;
    8a16:	1f 41 06 00 	mov	6(r1),	r15	;
    8a1a:	2c 41       	mov	@r1,	r12	;
    8a1c:	1d 41 02 00 	mov	2(r1),	r13	;
    8a20:	88 12       	call	r8		;

00008a22 <.LVL15>:
    8a22:	81 4c 00 00 	mov	r12,	0(r1)	;

00008a26 <.LVL16>:
    8a26:	81 4d 02 00 	mov	r13,	2(r1)	;

00008a2a <.LVL17>:
    8a2a:	1e 41 04 00 	mov	4(r1),	r14	;
    8a2e:	1f 41 06 00 	mov	6(r1),	r15	;
    8a32:	0c 4a       	mov	r10,	r12	;
    8a34:	4d 43       	clr.b	r13		;
    8a36:	88 12       	call	r8		;

00008a38 <.LVL18>:
    8a38:	0a 4c       	mov	r12,	r10	;
    8a3a:	0a 56       	add	r6,	r10	;
    8a3c:	08 4d       	mov	r13,	r8	;
    8a3e:	08 67       	addc	r7,	r8	;
    8a40:	0c 44       	mov	r4,	r12	;
    8a42:	0d 45       	mov	r5,	r13	;
    8a44:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8a48:	b0 12 b2 8d 	call	#36274		;#0x8db2
    8a4c:	05 4c       	mov	r12,	r5	;

00008a4e <.LVL22>:
    8a4e:	05 5a       	add	r10,	r5	;
    8a50:	0d 68       	addc	r8,	r13	;

00008a52 <.LVL23>:
    8a52:	0d 97       	cmp	r7,	r13	;
    8a54:	04 28       	jnc	$+10     	;abs 0x8a5e
    8a56:	07 9d       	cmp	r13,	r7	;
    8a58:	06 20       	jnz	$+14     	;abs 0x8a66
    8a5a:	05 96       	cmp	r6,	r5	;
    8a5c:	04 2c       	jc	$+10     	;abs 0x8a66

00008a5e <.L4>:
    8a5e:	81 53 00 00 	add	#0,	0(r1)	;r3 As==00
    8a62:	91 63 02 00 	addc	#1,	2(r1)	;r3 As==01

00008a66 <.L2>:
    8a66:	0c 45       	mov	r5,	r12	;
    8a68:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8a6c:	b0 12 b2 8d 	call	#36274		;#0x8db2

00008a70 <.LVL25>:
    8a70:	28 41       	mov	@r1,	r8	;
    8a72:	08 5c       	add	r12,	r8	;
    8a74:	1d 61 02 00 	addc	2(r1),	r13	;
    8a78:	0a 4d       	mov	r13,	r10	;
    8a7a:	47 43       	clr.b	r7		;

00008a7c <.LVL27>:
    8a7c:	0c 45       	mov	r5,	r12	;
    8a7e:	0d 47       	mov	r7,	r13	;
    8a80:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8a84:	b0 12 8a 8c 	call	#35978		;#0x8c8a
    8a88:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    8a8c:	0c 5f       	add	r15,	r12	;
    8a8e:	0d 67       	addc	r7,	r13	;

00008a90 <.LBE2>:
    8a90:	04 4c       	mov	r12,	r4	;
    8a92:	05 4d       	mov	r13,	r5	;
    8a94:	06 48       	mov	r8,	r6	;
    8a96:	07 4a       	mov	r10,	r7	;

00008a98 <.Loc.553.1>:
    8a98:	3a 40 cc 8d 	mov	#36300,	r10	;#0x8dcc
    8a9c:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    8aa0:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    8aa4:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    8aa8:	0d 49       	mov	r9,	r13	;
    8aaa:	8a 12       	call	r10		;

00008aac <.LVL29>:
    8aac:	09 4c       	mov	r12,	r9	;
    8aae:	08 4d       	mov	r13,	r8	;

00008ab0 <.Loc.554.1>:
    8ab0:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    8ab4:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    8ab8:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8abc:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8ac0:	8a 12       	call	r10		;

00008ac2 <.LVL30>:
    8ac2:	09 5c       	add	r12,	r9	;
    8ac4:	81 49 08 00 	mov	r9,	8(r1)	;
    8ac8:	08 6d       	addc	r13,	r8	;
    8aca:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a

00008ace <.Loc.553.1>:
    8ace:	16 51 08 00 	add	8(r1),	r6	;
    8ad2:	17 61 0a 00 	addc	10(r1),	r7	;0x0000a

00008ad6 <.Loc.557.1>:
    8ad6:	0c 44       	mov	r4,	r12	;
    8ad8:	0d 45       	mov	r5,	r13	;
    8ada:	0e 46       	mov	r6,	r14	;
    8adc:	0f 47       	mov	r7,	r15	;
    8ade:	31 50 1c 00 	add	#28,	r1	;#0x001c

00008ae2 <.LVL31>:
    8ae2:	64 17       	popm	#7,	r10	;16-bit words
    8ae4:	30 41       	ret			

00008ae6 <__ashrdi3>:
    8ae6:	6a 15       	pushm	#7,	r10	;16-bit words

00008ae8 <.LCFI0>:
    8ae8:	21 83       	decd	r1		;

00008aea <.LCFI1>:
    8aea:	05 4c       	mov	r12,	r5	;
    8aec:	0a 4d       	mov	r13,	r10	;
    8aee:	1b 41 12 00 	mov	18(r1),	r11	;0x00012

00008af2 <.Loc.461.1>:
    8af2:	0b 93       	cmp	#0,	r11	;r3 As==00
    8af4:	1e 24       	jz	$+62     	;abs 0x8b32

00008af6 <.Loc.465.1>:
    8af6:	37 40 20 00 	mov	#32,	r7	;#0x0020
    8afa:	07 8b       	sub	r11,	r7	;

00008afc <.LVL1>:
    8afc:	4c 43       	clr.b	r12		;

00008afe <.LVL2>:
    8afe:	0c 97       	cmp	r7,	r12	;
    8b00:	1d 38       	jl	$+60     	;abs 0x8b3c

00008b02 <.Loc.471.1>:
    8b02:	06 4e       	mov	r14,	r6	;
    8b04:	0a 4f       	mov	r15,	r10	;
    8b06:	0c 4e       	mov	r14,	r12	;
    8b08:	0d 4f       	mov	r15,	r13	;
    8b0a:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    8b0e:	b0 12 fe 8c 	call	#36094		;#0x8cfe
    8b12:	08 4c       	mov	r12,	r8	;
    8b14:	09 4d       	mov	r13,	r9	;

00008b16 <.Loc.472.1>:
    8b16:	0e 43       	clr	r14		;
    8b18:	0e 87       	sub	r7,	r14	;
    8b1a:	0c 46       	mov	r6,	r12	;
    8b1c:	0d 4a       	mov	r10,	r13	;
    8b1e:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    8b22:	0f 7f       	subc	r15,	r15	;
    8b24:	3f e3       	inv	r15		;
    8b26:	b0 12 fe 8c 	call	#36094		;#0x8cfe
    8b2a:	05 4c       	mov	r12,	r5	;
    8b2c:	0a 4d       	mov	r13,	r10	;

00008b2e <.L4>:
    8b2e:	0e 48       	mov	r8,	r14	;
    8b30:	0f 49       	mov	r9,	r15	;

00008b32 <.L2>:
    8b32:	0c 45       	mov	r5,	r12	;
    8b34:	0d 4a       	mov	r10,	r13	;
    8b36:	21 53       	incd	r1		;
    8b38:	64 17       	popm	#7,	r10	;16-bit words
    8b3a:	30 41       	ret			

00008b3c <.L3>:
    8b3c:	04 4e       	mov	r14,	r4	;
    8b3e:	06 4f       	mov	r15,	r6	;

00008b40 <.Loc.478.1>:
    8b40:	0c 4e       	mov	r14,	r12	;
    8b42:	0d 4f       	mov	r15,	r13	;
    8b44:	0e 4b       	mov	r11,	r14	;
    8b46:	0f 4b       	mov	r11,	r15	;
    8b48:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8b4c:	81 4b 00 00 	mov	r11,	0(r1)	;
    8b50:	b0 12 fe 8c 	call	#36094		;#0x8cfe

00008b54 <.LVL9>:
    8b54:	08 4c       	mov	r12,	r8	;
    8b56:	09 4d       	mov	r13,	r9	;

00008b58 <.Loc.479.1>:
    8b58:	0c 45       	mov	r5,	r12	;
    8b5a:	0d 4a       	mov	r10,	r13	;
    8b5c:	2b 41       	mov	@r1,	r11	;
    8b5e:	0e 4b       	mov	r11,	r14	;
    8b60:	0f 43       	clr	r15		;
    8b62:	b0 12 b2 8d 	call	#36274		;#0x8db2
    8b66:	05 4c       	mov	r12,	r5	;
    8b68:	0a 4d       	mov	r13,	r10	;

00008b6a <.Loc.476.1>:
    8b6a:	0c 44       	mov	r4,	r12	;
    8b6c:	0d 46       	mov	r6,	r13	;
    8b6e:	0e 47       	mov	r7,	r14	;
    8b70:	0f 43       	clr	r15		;
    8b72:	b0 12 8a 8c 	call	#35978		;#0x8c8a

00008b76 <.Loc.479.1>:
    8b76:	0a dd       	bis	r13,	r10	;
    8b78:	0d 45       	mov	r5,	r13	;
    8b7a:	0d dc       	bis	r12,	r13	;
    8b7c:	05 4d       	mov	r13,	r5	;
    8b7e:	d7 3f       	jmp	$-80     	;abs 0x8b2e

00008b80 <udivmodsi4>:
    8b80:	5a 15       	pushm	#6,	r10	;16-bit words

00008b82 <L0>:
    8b82:	0a 4c       	mov	r12,	r10	;
    8b84:	0b 4d       	mov	r13,	r11	;

00008b86 <.LVL1>:
    8b86:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00008b8a <.Loc.35.1>:
    8b8a:	58 43       	mov.b	#1,	r8	;r3 As==01
    8b8c:	49 43       	clr.b	r9		;

00008b8e <.Loc.38.1>:
    8b8e:	07 4b       	mov	r11,	r7	;

00008b90 <.L2>:
    8b90:	0f 9b       	cmp	r11,	r15	;
    8b92:	11 28       	jnc	$+36     	;abs 0x8bb6
    8b94:	07 9f       	cmp	r15,	r7	;
    8b96:	02 20       	jnz	$+6      	;abs 0x8b9c
    8b98:	0e 9a       	cmp	r10,	r14	;
    8b9a:	0d 28       	jnc	$+28     	;abs 0x8bb6

00008b9c <.L20>:
    8b9c:	4c 43       	clr.b	r12		;

00008b9e <.LVL3>:
    8b9e:	0d 4c       	mov	r12,	r13	;

00008ba0 <.L5>:
    8ba0:	07 48       	mov	r8,	r7	;
    8ba2:	07 d9       	bis	r9,	r7	;
    8ba4:	07 93       	cmp	#0,	r7	;r3 As==00
    8ba6:	19 20       	jnz	$+52     	;abs 0x8bda

00008ba8 <.L6>:
    8ba8:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    8bac:	02 24       	jz	$+6      	;abs 0x8bb2
    8bae:	0c 4a       	mov	r10,	r12	;
    8bb0:	0d 4b       	mov	r11,	r13	;

00008bb2 <.L1>:
    8bb2:	55 17       	popm	#6,	r10	;16-bit words
    8bb4:	30 41       	ret			

00008bb6 <.L3>:
    8bb6:	3d 53       	add	#-1,	r13	;r3 As==11

00008bb8 <.Loc.38.1>:
    8bb8:	0d 93       	cmp	#0,	r13	;r3 As==00
    8bba:	20 24       	jz	$+66     	;abs 0x8bfc

00008bbc <.Loc.38.1>:
    8bbc:	0f 93       	cmp	#0,	r15	;r3 As==00
    8bbe:	ee 3b       	jl	$-34     	;abs 0x8b9c

00008bc0 <.Loc.40.1>:
    8bc0:	05 4e       	mov	r14,	r5	;
    8bc2:	06 4f       	mov	r15,	r6	;
    8bc4:	05 5e       	add	r14,	r5	;
    8bc6:	06 6f       	addc	r15,	r6	;
    8bc8:	0e 45       	mov	r5,	r14	;

00008bca <.LVL7>:
    8bca:	0f 46       	mov	r6,	r15	;

00008bcc <.LVL8>:
    8bcc:	05 48       	mov	r8,	r5	;
    8bce:	06 49       	mov	r9,	r6	;
    8bd0:	05 58       	add	r8,	r5	;
    8bd2:	06 69       	addc	r9,	r6	;
    8bd4:	08 45       	mov	r5,	r8	;

00008bd6 <.LVL9>:
    8bd6:	09 46       	mov	r6,	r9	;

00008bd8 <.LVL10>:
    8bd8:	db 3f       	jmp	$-72     	;abs 0x8b90

00008bda <.L12>:
    8bda:	0b 9f       	cmp	r15,	r11	;
    8bdc:	08 28       	jnc	$+18     	;abs 0x8bee
    8bde:	0f 9b       	cmp	r11,	r15	;
    8be0:	02 20       	jnz	$+6      	;abs 0x8be6
    8be2:	0a 9e       	cmp	r14,	r10	;
    8be4:	04 28       	jnc	$+10     	;abs 0x8bee

00008be6 <.L16>:
    8be6:	0a 8e       	sub	r14,	r10	;
    8be8:	0b 7f       	subc	r15,	r11	;

00008bea <.Loc.48.1>:
    8bea:	0c d8       	bis	r8,	r12	;

00008bec <.LVL13>:
    8bec:	0d d9       	bis	r9,	r13	;

00008bee <.L10>:
    8bee:	12 c3       	clrc			
    8bf0:	09 10       	rrc	r9		;
    8bf2:	08 10       	rrc	r8		;

00008bf4 <.Loc.51.1>:
    8bf4:	12 c3       	clrc			
    8bf6:	0f 10       	rrc	r15		;
    8bf8:	0e 10       	rrc	r14		;
    8bfa:	d2 3f       	jmp	$-90     	;abs 0x8ba0

00008bfc <.L14>:
    8bfc:	0c 4d       	mov	r13,	r12	;

00008bfe <.LVL18>:
    8bfe:	d4 3f       	jmp	$-86     	;abs 0x8ba8

00008c00 <__mspabi_divlu>:
    8c00:	21 83       	decd	r1		;

00008c02 <.LCFI5>:
    8c02:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00008c06 <L0>:
    8c06:	b0 12 80 8b 	call	#35712		;#0x8b80

00008c0a <.LVL46>:
    8c0a:	21 53       	incd	r1		;
    8c0c:	30 41       	ret			

00008c0e <__mspabi_remul>:
    8c0e:	21 83       	decd	r1		;

00008c10 <.LCFI6>:
    8c10:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    8c14:	b0 12 80 8b 	call	#35712		;#0x8b80

00008c18 <.LVL48>:
    8c18:	21 53       	incd	r1		;
    8c1a:	30 41       	ret			

00008c1c <__mspabi_slli_15>:
    8c1c:	0c 5c       	rla	r12		;

00008c1e <__mspabi_slli_14>:
    8c1e:	0c 5c       	rla	r12		;

00008c20 <__mspabi_slli_13>:
    8c20:	0c 5c       	rla	r12		;

00008c22 <__mspabi_slli_12>:
    8c22:	0c 5c       	rla	r12		;

00008c24 <__mspabi_slli_11>:
    8c24:	0c 5c       	rla	r12		;

00008c26 <__mspabi_slli_10>:
    8c26:	0c 5c       	rla	r12		;

00008c28 <__mspabi_slli_9>:
    8c28:	0c 5c       	rla	r12		;

00008c2a <__mspabi_slli_8>:
    8c2a:	0c 5c       	rla	r12		;

00008c2c <__mspabi_slli_7>:
    8c2c:	0c 5c       	rla	r12		;

00008c2e <__mspabi_slli_6>:
    8c2e:	0c 5c       	rla	r12		;

00008c30 <__mspabi_slli_5>:
    8c30:	0c 5c       	rla	r12		;

00008c32 <__mspabi_slli_4>:
    8c32:	0c 5c       	rla	r12		;

00008c34 <__mspabi_slli_3>:
    8c34:	0c 5c       	rla	r12		;

00008c36 <__mspabi_slli_2>:
    8c36:	0c 5c       	rla	r12		;

00008c38 <__mspabi_slli_1>:
    8c38:	0c 5c       	rla	r12		;
    8c3a:	30 41       	ret			

00008c3c <.L11>:
    8c3c:	3d 53       	add	#-1,	r13	;r3 As==11
    8c3e:	0c 5c       	rla	r12		;

00008c40 <__mspabi_slli>:
    8c40:	0d 93       	cmp	#0,	r13	;r3 As==00
    8c42:	fc 23       	jnz	$-6      	;abs 0x8c3c
    8c44:	30 41       	ret			

00008c46 <__mspabi_slll_15>:
    8c46:	0c 5c       	rla	r12		;
    8c48:	0d 6d       	rlc	r13		;

00008c4a <__mspabi_slll_14>:
    8c4a:	0c 5c       	rla	r12		;
    8c4c:	0d 6d       	rlc	r13		;

00008c4e <__mspabi_slll_13>:
    8c4e:	0c 5c       	rla	r12		;
    8c50:	0d 6d       	rlc	r13		;

00008c52 <__mspabi_slll_12>:
    8c52:	0c 5c       	rla	r12		;
    8c54:	0d 6d       	rlc	r13		;

00008c56 <__mspabi_slll_11>:
    8c56:	0c 5c       	rla	r12		;
    8c58:	0d 6d       	rlc	r13		;

00008c5a <__mspabi_slll_10>:
    8c5a:	0c 5c       	rla	r12		;
    8c5c:	0d 6d       	rlc	r13		;

00008c5e <__mspabi_slll_9>:
    8c5e:	0c 5c       	rla	r12		;
    8c60:	0d 6d       	rlc	r13		;

00008c62 <__mspabi_slll_8>:
    8c62:	0c 5c       	rla	r12		;
    8c64:	0d 6d       	rlc	r13		;

00008c66 <__mspabi_slll_7>:
    8c66:	0c 5c       	rla	r12		;
    8c68:	0d 6d       	rlc	r13		;

00008c6a <__mspabi_slll_6>:
    8c6a:	0c 5c       	rla	r12		;
    8c6c:	0d 6d       	rlc	r13		;

00008c6e <__mspabi_slll_5>:
    8c6e:	0c 5c       	rla	r12		;
    8c70:	0d 6d       	rlc	r13		;

00008c72 <__mspabi_slll_4>:
    8c72:	0c 5c       	rla	r12		;
    8c74:	0d 6d       	rlc	r13		;

00008c76 <__mspabi_slll_3>:
    8c76:	0c 5c       	rla	r12		;
    8c78:	0d 6d       	rlc	r13		;

00008c7a <__mspabi_slll_2>:
    8c7a:	0c 5c       	rla	r12		;
    8c7c:	0d 6d       	rlc	r13		;

00008c7e <__mspabi_slll_1>:
    8c7e:	0c 5c       	rla	r12		;
    8c80:	0d 6d       	rlc	r13		;
    8c82:	30 41       	ret			

00008c84 <.L12>:
    8c84:	3e 53       	add	#-1,	r14	;r3 As==11
    8c86:	0c 5c       	rla	r12		;
    8c88:	0d 6d       	rlc	r13		;

00008c8a <__mspabi_slll>:
    8c8a:	0e 93       	cmp	#0,	r14	;r3 As==00
    8c8c:	fb 23       	jnz	$-8      	;abs 0x8c84
    8c8e:	30 41       	ret			

00008c90 <__mspabi_srai_15>:
    8c90:	0c 11       	rra	r12		;

00008c92 <__mspabi_srai_14>:
    8c92:	0c 11       	rra	r12		;

00008c94 <__mspabi_srai_13>:
    8c94:	0c 11       	rra	r12		;

00008c96 <__mspabi_srai_12>:
    8c96:	0c 11       	rra	r12		;

00008c98 <__mspabi_srai_11>:
    8c98:	0c 11       	rra	r12		;

00008c9a <__mspabi_srai_10>:
    8c9a:	0c 11       	rra	r12		;

00008c9c <__mspabi_srai_9>:
    8c9c:	0c 11       	rra	r12		;

00008c9e <__mspabi_srai_8>:
    8c9e:	0c 11       	rra	r12		;

00008ca0 <__mspabi_srai_7>:
    8ca0:	0c 11       	rra	r12		;

00008ca2 <__mspabi_srai_6>:
    8ca2:	0c 11       	rra	r12		;

00008ca4 <__mspabi_srai_5>:
    8ca4:	0c 11       	rra	r12		;

00008ca6 <__mspabi_srai_4>:
    8ca6:	0c 11       	rra	r12		;

00008ca8 <__mspabi_srai_3>:
    8ca8:	0c 11       	rra	r12		;

00008caa <__mspabi_srai_2>:
    8caa:	0c 11       	rra	r12		;

00008cac <__mspabi_srai_1>:
    8cac:	0c 11       	rra	r12		;
    8cae:	30 41       	ret			

00008cb0 <.L11>:
    8cb0:	3d 53       	add	#-1,	r13	;r3 As==11
    8cb2:	0c 11       	rra	r12		;

00008cb4 <__mspabi_srai>:
    8cb4:	0d 93       	cmp	#0,	r13	;r3 As==00
    8cb6:	fc 23       	jnz	$-6      	;abs 0x8cb0
    8cb8:	30 41       	ret			

00008cba <__mspabi_sral_15>:
    8cba:	0d 11       	rra	r13		;
    8cbc:	0c 10       	rrc	r12		;

00008cbe <__mspabi_sral_14>:
    8cbe:	0d 11       	rra	r13		;
    8cc0:	0c 10       	rrc	r12		;

00008cc2 <__mspabi_sral_13>:
    8cc2:	0d 11       	rra	r13		;
    8cc4:	0c 10       	rrc	r12		;

00008cc6 <__mspabi_sral_12>:
    8cc6:	0d 11       	rra	r13		;
    8cc8:	0c 10       	rrc	r12		;

00008cca <__mspabi_sral_11>:
    8cca:	0d 11       	rra	r13		;
    8ccc:	0c 10       	rrc	r12		;

00008cce <__mspabi_sral_10>:
    8cce:	0d 11       	rra	r13		;
    8cd0:	0c 10       	rrc	r12		;

00008cd2 <__mspabi_sral_9>:
    8cd2:	0d 11       	rra	r13		;
    8cd4:	0c 10       	rrc	r12		;

00008cd6 <__mspabi_sral_8>:
    8cd6:	0d 11       	rra	r13		;
    8cd8:	0c 10       	rrc	r12		;

00008cda <__mspabi_sral_7>:
    8cda:	0d 11       	rra	r13		;
    8cdc:	0c 10       	rrc	r12		;

00008cde <__mspabi_sral_6>:
    8cde:	0d 11       	rra	r13		;
    8ce0:	0c 10       	rrc	r12		;

00008ce2 <__mspabi_sral_5>:
    8ce2:	0d 11       	rra	r13		;
    8ce4:	0c 10       	rrc	r12		;

00008ce6 <__mspabi_sral_4>:
    8ce6:	0d 11       	rra	r13		;
    8ce8:	0c 10       	rrc	r12		;

00008cea <__mspabi_sral_3>:
    8cea:	0d 11       	rra	r13		;
    8cec:	0c 10       	rrc	r12		;

00008cee <__mspabi_sral_2>:
    8cee:	0d 11       	rra	r13		;
    8cf0:	0c 10       	rrc	r12		;

00008cf2 <__mspabi_sral_1>:
    8cf2:	0d 11       	rra	r13		;
    8cf4:	0c 10       	rrc	r12		;
    8cf6:	30 41       	ret			

00008cf8 <.L12>:
    8cf8:	3e 53       	add	#-1,	r14	;r3 As==11
    8cfa:	0d 11       	rra	r13		;
    8cfc:	0c 10       	rrc	r12		;

00008cfe <__mspabi_sral>:
    8cfe:	0e 93       	cmp	#0,	r14	;r3 As==00
    8d00:	fb 23       	jnz	$-8      	;abs 0x8cf8
    8d02:	30 41       	ret			

00008d04 <__mspabi_srli_15>:
    8d04:	12 c3       	clrc			
    8d06:	0c 10       	rrc	r12		;

00008d08 <__mspabi_srli_14>:
    8d08:	12 c3       	clrc			
    8d0a:	0c 10       	rrc	r12		;

00008d0c <__mspabi_srli_13>:
    8d0c:	12 c3       	clrc			
    8d0e:	0c 10       	rrc	r12		;

00008d10 <__mspabi_srli_12>:
    8d10:	12 c3       	clrc			
    8d12:	0c 10       	rrc	r12		;

00008d14 <__mspabi_srli_11>:
    8d14:	12 c3       	clrc			
    8d16:	0c 10       	rrc	r12		;

00008d18 <__mspabi_srli_10>:
    8d18:	12 c3       	clrc			
    8d1a:	0c 10       	rrc	r12		;

00008d1c <__mspabi_srli_9>:
    8d1c:	12 c3       	clrc			
    8d1e:	0c 10       	rrc	r12		;

00008d20 <__mspabi_srli_8>:
    8d20:	12 c3       	clrc			
    8d22:	0c 10       	rrc	r12		;

00008d24 <__mspabi_srli_7>:
    8d24:	12 c3       	clrc			
    8d26:	0c 10       	rrc	r12		;

00008d28 <__mspabi_srli_6>:
    8d28:	12 c3       	clrc			
    8d2a:	0c 10       	rrc	r12		;

00008d2c <__mspabi_srli_5>:
    8d2c:	12 c3       	clrc			
    8d2e:	0c 10       	rrc	r12		;

00008d30 <__mspabi_srli_4>:
    8d30:	12 c3       	clrc			
    8d32:	0c 10       	rrc	r12		;

00008d34 <__mspabi_srli_3>:
    8d34:	12 c3       	clrc			
    8d36:	0c 10       	rrc	r12		;

00008d38 <__mspabi_srli_2>:
    8d38:	12 c3       	clrc			
    8d3a:	0c 10       	rrc	r12		;

00008d3c <__mspabi_srli_1>:
    8d3c:	12 c3       	clrc			
    8d3e:	0c 10       	rrc	r12		;
    8d40:	30 41       	ret			

00008d42 <.L11>:
    8d42:	3d 53       	add	#-1,	r13	;r3 As==11
    8d44:	12 c3       	clrc			
    8d46:	0c 10       	rrc	r12		;

00008d48 <__mspabi_srli>:
    8d48:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d4a:	fb 23       	jnz	$-8      	;abs 0x8d42
    8d4c:	30 41       	ret			

00008d4e <__mspabi_srll_15>:
    8d4e:	12 c3       	clrc			
    8d50:	0d 10       	rrc	r13		;
    8d52:	0c 10       	rrc	r12		;

00008d54 <__mspabi_srll_14>:
    8d54:	12 c3       	clrc			
    8d56:	0d 10       	rrc	r13		;
    8d58:	0c 10       	rrc	r12		;

00008d5a <__mspabi_srll_13>:
    8d5a:	12 c3       	clrc			
    8d5c:	0d 10       	rrc	r13		;
    8d5e:	0c 10       	rrc	r12		;

00008d60 <__mspabi_srll_12>:
    8d60:	12 c3       	clrc			
    8d62:	0d 10       	rrc	r13		;
    8d64:	0c 10       	rrc	r12		;

00008d66 <__mspabi_srll_11>:
    8d66:	12 c3       	clrc			
    8d68:	0d 10       	rrc	r13		;
    8d6a:	0c 10       	rrc	r12		;

00008d6c <__mspabi_srll_10>:
    8d6c:	12 c3       	clrc			
    8d6e:	0d 10       	rrc	r13		;
    8d70:	0c 10       	rrc	r12		;

00008d72 <__mspabi_srll_9>:
    8d72:	12 c3       	clrc			
    8d74:	0d 10       	rrc	r13		;
    8d76:	0c 10       	rrc	r12		;

00008d78 <__mspabi_srll_8>:
    8d78:	12 c3       	clrc			
    8d7a:	0d 10       	rrc	r13		;
    8d7c:	0c 10       	rrc	r12		;

00008d7e <__mspabi_srll_7>:
    8d7e:	12 c3       	clrc			
    8d80:	0d 10       	rrc	r13		;
    8d82:	0c 10       	rrc	r12		;

00008d84 <__mspabi_srll_6>:
    8d84:	12 c3       	clrc			
    8d86:	0d 10       	rrc	r13		;
    8d88:	0c 10       	rrc	r12		;

00008d8a <__mspabi_srll_5>:
    8d8a:	12 c3       	clrc			
    8d8c:	0d 10       	rrc	r13		;
    8d8e:	0c 10       	rrc	r12		;

00008d90 <__mspabi_srll_4>:
    8d90:	12 c3       	clrc			
    8d92:	0d 10       	rrc	r13		;
    8d94:	0c 10       	rrc	r12		;

00008d96 <__mspabi_srll_3>:
    8d96:	12 c3       	clrc			
    8d98:	0d 10       	rrc	r13		;
    8d9a:	0c 10       	rrc	r12		;

00008d9c <__mspabi_srll_2>:
    8d9c:	12 c3       	clrc			
    8d9e:	0d 10       	rrc	r13		;
    8da0:	0c 10       	rrc	r12		;

00008da2 <__mspabi_srll_1>:
    8da2:	12 c3       	clrc			
    8da4:	0d 10       	rrc	r13		;
    8da6:	0c 10       	rrc	r12		;
    8da8:	30 41       	ret			

00008daa <.L12>:
    8daa:	3e 53       	add	#-1,	r14	;r3 As==11
    8dac:	12 c3       	clrc			
    8dae:	0d 10       	rrc	r13		;
    8db0:	0c 10       	rrc	r12		;

00008db2 <__mspabi_srll>:
    8db2:	0e 93       	cmp	#0,	r14	;r3 As==00
    8db4:	fa 23       	jnz	$-10     	;abs 0x8daa
    8db6:	30 41       	ret			

00008db8 <__mspabi_mpyi>:
    8db8:	02 12       	push	r2		;
    8dba:	32 c2       	dint			
    8dbc:	03 43       	nop			
    8dbe:	82 4c c0 04 	mov	r12,	&0x04c0	;
    8dc2:	82 4d c8 04 	mov	r13,	&0x04c8	;
    8dc6:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    8dca:	00 13       	reti			

00008dcc <__mspabi_mpyl>:
    8dcc:	02 12       	push	r2		;
    8dce:	32 c2       	dint			
    8dd0:	03 43       	nop			
    8dd2:	82 4c d0 04 	mov	r12,	&0x04d0	;
    8dd6:	82 4d d2 04 	mov	r13,	&0x04d2	;
    8dda:	82 4e e0 04 	mov	r14,	&0x04e0	;
    8dde:	82 4f e2 04 	mov	r15,	&0x04e2	;
    8de2:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    8de6:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    8dea:	00 13       	reti			

00008dec <memcpy>:
    8dec:	0f 4c       	mov	r12,	r15	;
    8dee:	0e 5c       	add	r12,	r14	;

00008df0 <.L2>:
    8df0:	0f 9e       	cmp	r14,	r15	;
    8df2:	05 24       	jz	$+12     	;abs 0x8dfe

00008df4 <.LVL3>:
    8df4:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    8df8:	1f 53       	inc	r15		;

00008dfa <.LVL4>:
    8dfa:	1d 53       	inc	r13		;
    8dfc:	f9 3f       	jmp	$-12     	;abs 0x8df0

00008dfe <.L5>:
    8dfe:	30 41       	ret			

00008e00 <sniprintf>:
    8e00:	1a 15       	pushm	#2,	r10	;16-bit words

00008e02 <L0>:
    8e02:	31 80 3c 00 	sub	#60,	r1	;#0x003c

00008e06 <.LCFI3>:
    8e06:	0a 4d       	mov	r13,	r10	;

00008e08 <.Loc.95.1>:
    8e08:	19 42 82 51 	mov	&0x5182,r9	;0x5182

00008e0c <.Loc.97.1>:
    8e0c:	0d 93       	cmp	#0,	r13	;r3 As==00
    8e0e:	05 34       	jge	$+12     	;abs 0x8e1a

00008e10 <.Loc.99.1>:
    8e10:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    8e14:	00 00 

00008e16 <.Loc.100.1>:
    8e16:	3c 43       	mov	#-1,	r12	;r3 As==11

00008e18 <.LVL9>:
    8e18:	24 3c       	jmp	$+74     	;abs 0x8e62

00008e1a <.L12>:
    8e1a:	b1 40 08 02 	mov	#520,	6(r1)	;#0x0208
    8e1e:	06 00 

00008e20 <.Loc.103.1>:
    8e20:	81 4c 00 00 	mov	r12,	0(r1)	;
    8e24:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00008e28 <.Loc.104.1>:
    8e28:	0c 4d       	mov	r13,	r12	;

00008e2a <.LVL11>:
    8e2a:	0d 93       	cmp	#0,	r13	;r3 As==00
    8e2c:	01 24       	jz	$+4      	;abs 0x8e30

00008e2e <.LVL12>:
    8e2e:	3c 53       	add	#-1,	r12	;r3 As==11

00008e30 <.L14>:
    8e30:	81 4c 04 00 	mov	r12,	4(r1)	;
    8e34:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

00008e38 <.Loc.105.1>:
    8e38:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

00008e3c <.LVL13>:
    8e3c:	0f 41       	mov	r1,	r15	;
    8e3e:	3f 50 44 00 	add	#68,	r15	;#0x0044
    8e42:	1e 41 42 00 	mov	66(r1),	r14	;0x00042
    8e46:	0d 41       	mov	r1,	r13	;
    8e48:	0c 49       	mov	r9,	r12	;
    8e4a:	b0 12 9c 8f 	call	#36764		;#0x8f9c

00008e4e <.LVL14>:
    8e4e:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8e50:	03 34       	jge	$+8      	;abs 0x8e58

00008e52 <.Loc.114.1>:
    8e52:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    8e56:	00 00 

00008e58 <.L15>:
    8e58:	0a 93       	cmp	#0,	r10	;r3 As==00
    8e5a:	03 24       	jz	$+8      	;abs 0x8e62

00008e5c <.Loc.116.1>:
    8e5c:	2d 41       	mov	@r1,	r13	;
    8e5e:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00

00008e62 <.L11>:
    8e62:	31 50 3c 00 	add	#60,	r1	;#0x003c
    8e66:	19 17       	popm	#2,	r10	;16-bit words
    8e68:	30 41       	ret			

00008e6a <strlen>:
    8e6a:	0d 4c       	mov	r12,	r13	;

00008e6c <L0>:
    8e6c:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    8e70:	02 24       	jz	$+6      	;abs 0x8e76

00008e72 <.Loc.86.1>:
    8e72:	1d 53       	inc	r13		;
    8e74:	fb 3f       	jmp	$-8      	;abs 0x8e6c

00008e76 <.L5>:
    8e76:	0d 8c       	sub	r12,	r13	;

00008e78 <.LVL4>:
    8e78:	0c 4d       	mov	r13,	r12	;

00008e7a <.LVL5>:
    8e7a:	30 41       	ret			

00008e7c <__ssprint_r>:
    8e7c:	6a 15       	pushm	#7,	r10	;16-bit words

00008e7e <L0>:
    8e7e:	21 82       	sub	#4,	r1	;r2 As==10

00008e80 <.LCFI1>:
    8e80:	07 4c       	mov	r12,	r7	;
    8e82:	04 4d       	mov	r13,	r4	;
    8e84:	08 4e       	mov	r14,	r8	;

00008e86 <.LVL1>:
    8e86:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00
    8e8a:	2c 24       	jz	$+90     	;abs 0x8ee4

00008e8c <.Loc.280.1>:
    8e8c:	26 4e       	mov	@r14,	r6	;
    8e8e:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8e92:	19 41 02 00 	mov	2(r1),	r9	;
    8e96:	05 3c       	jmp	$+12     	;abs 0x8ea2

00008e98 <.L5>:
    8e98:	a1 46 02 00 	mov	@r6,	2(r1)	;

00008e9c <.Loc.291.1>:
    8e9c:	19 46 02 00 	mov	2(r6),	r9	;

00008ea0 <.LVL3>:
    8ea0:	26 52       	add	#4,	r6	;r2 As==10

00008ea2 <.L3>:
    8ea2:	09 93       	cmp	#0,	r9	;r3 As==00
    8ea4:	f9 27       	jz	$-12     	;abs 0x8e98

00008ea6 <.Loc.294.1>:
    8ea6:	1b 44 04 00 	mov	4(r4),	r11	;

00008eaa <.LVL5>:
    8eaa:	09 9b       	cmp	r11,	r9	;
    8eac:	72 28       	jnc	$+230    	;abs 0x8f92

00008eae <.Loc.295.1>:
    8eae:	1e 44 06 00 	mov	6(r4),	r14	;
    8eb2:	3e b0 80 04 	bit	#1152,	r14	;#0x0480
    8eb6:	1a 20       	jnz	$+54     	;abs 0x8eec

00008eb8 <.L6>:
    8eb8:	09 9b       	cmp	r11,	r9	;
    8eba:	6b 28       	jnc	$+216    	;abs 0x8f92

00008ebc <.L12>:
    8ebc:	0e 4b       	mov	r11,	r14	;
    8ebe:	1d 41 02 00 	mov	2(r1),	r13	;
    8ec2:	2c 44       	mov	@r4,	r12	;
    8ec4:	81 4b 00 00 	mov	r11,	0(r1)	;
    8ec8:	b0 12 54 99 	call	#39252		;#0x9954

00008ecc <.LVL6>:
    8ecc:	2b 41       	mov	@r1,	r11	;
    8ece:	84 8b 04 00 	sub	r11,	4(r4)	;

00008ed2 <.Loc.344.1>:
    8ed2:	84 5b 00 00 	add	r11,	0(r4)	;

00008ed6 <.LVL7>:
    8ed6:	1c 48 04 00 	mov	4(r8),	r12	;
    8eda:	0c 89       	sub	r9,	r12	;
    8edc:	88 4c 04 00 	mov	r12,	4(r8)	;
    8ee0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8ee2:	da 23       	jnz	$-74     	;abs 0x8e98

00008ee4 <.L2>:
    8ee4:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

00008ee8 <.Loc.285.1>:
    8ee8:	4c 43       	clr.b	r12		;
    8eea:	55 3c       	jmp	$+172    	;abs 0x8f96

00008eec <.L21>:
    8eec:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    8ef0:	25 44       	mov	@r4,	r5	;
    8ef2:	05 8d       	sub	r13,	r5	;

00008ef4 <.LVL10>:
    8ef4:	1c 44 0c 00 	mov	12(r4),	r12	;0x0000c
    8ef8:	0a 4c       	mov	r12,	r10	;
    8efa:	0a 5c       	add	r12,	r10	;
    8efc:	0a 5c       	add	r12,	r10	;
    8efe:	0c 4a       	mov	r10,	r12	;
    8f00:	5c 03       	rrum	#1,	r12	;
    8f02:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    8f06:	0a 5c       	add	r12,	r10	;
    8f08:	0a 11       	rra	r10		;

00008f0a <.LVL11>:
    8f0a:	0c 45       	mov	r5,	r12	;
    8f0c:	1c 53       	inc	r12		;
    8f0e:	0c 59       	add	r9,	r12	;
    8f10:	0a 9c       	cmp	r12,	r10	;
    8f12:	01 2c       	jc	$+4      	;abs 0x8f16

00008f14 <.Loc.308.1>:
    8f14:	0a 4c       	mov	r12,	r10	;

00008f16 <.L7>:
    8f16:	3e b0 00 04 	bit	#1024,	r14	;#0x0400
    8f1a:	17 24       	jz	$+48     	;abs 0x8f4a

00008f1c <.Loc.312.1>:
    8f1c:	0d 4a       	mov	r10,	r13	;
    8f1e:	0c 47       	mov	r7,	r12	;
    8f20:	b0 12 78 9a 	call	#39544		;#0x9a78

00008f24 <.LVL13>:
    8f24:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f26:	1d 24       	jz	$+60     	;abs 0x8f62

00008f28 <.Loc.318.1>:
    8f28:	0e 45       	mov	r5,	r14	;
    8f2a:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    8f2e:	81 4c 00 00 	mov	r12,	0(r1)	;
    8f32:	b0 12 ec 8d 	call	#36332		;#0x8dec

00008f36 <.LVL14>:
    8f36:	1c 44 06 00 	mov	6(r4),	r12	;
    8f3a:	3c f0 7f fb 	and	#64383,	r12	;#0xfb7f
    8f3e:	3c d0 80 00 	bis	#128,	r12	;#0x0080
    8f42:	84 4c 06 00 	mov	r12,	6(r4)	;
    8f46:	2b 41       	mov	@r1,	r11	;
    8f48:	18 3c       	jmp	$+50     	;abs 0x8f7a

00008f4a <.L8>:
    8f4a:	0e 4a       	mov	r10,	r14	;
    8f4c:	0c 47       	mov	r7,	r12	;
    8f4e:	b0 12 62 9b 	call	#39778		;#0x9b62

00008f52 <.LVL16>:
    8f52:	0b 4c       	mov	r12,	r11	;

00008f54 <.LVL17>:
    8f54:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f56:	11 20       	jnz	$+36     	;abs 0x8f7a

00008f58 <.Loc.327.1>:
    8f58:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    8f5c:	0c 47       	mov	r7,	r12	;
    8f5e:	b0 12 8e 99 	call	#39310		;#0x998e

00008f62 <.L19>:
    8f62:	b7 40 0c 00 	mov	#12,	0(r7)	;#0x000c
    8f66:	00 00 

00008f68 <.L10>:
    8f68:	b4 d0 40 00 	bis	#64,	6(r4)	;#0x0040
    8f6c:	06 00 

00008f6e <.Loc.356.1>:
    8f6e:	88 43 04 00 	mov	#0,	4(r8)	;r3 As==00

00008f72 <.Loc.357.1>:
    8f72:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

00008f76 <.Loc.358.1>:
    8f76:	3c 43       	mov	#-1,	r12	;r3 As==11
    8f78:	0e 3c       	jmp	$+30     	;abs 0x8f96

00008f7a <.L11>:
    8f7a:	84 4b 0a 00 	mov	r11,	10(r4)	; 0x000a

00008f7e <.Loc.335.1>:
    8f7e:	0b 55       	add	r5,	r11	;

00008f80 <.LVL20>:
    8f80:	84 4b 00 00 	mov	r11,	0(r4)	;

00008f84 <.Loc.336.1>:
    8f84:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

00008f88 <.LVL21>:
    8f88:	0b 49       	mov	r9,	r11	;

00008f8a <.Loc.338.1>:
    8f8a:	0a 85       	sub	r5,	r10	;

00008f8c <.LVL22>:
    8f8c:	84 4a 04 00 	mov	r10,	4(r4)	;
    8f90:	93 3f       	jmp	$-216    	;abs 0x8eb8

00008f92 <.L15>:
    8f92:	0b 49       	mov	r9,	r11	;
    8f94:	93 3f       	jmp	$-216    	;abs 0x8ebc

00008f96 <.L1>:
    8f96:	21 52       	add	#4,	r1	;r2 As==10
    8f98:	64 17       	popm	#7,	r10	;16-bit words
    8f9a:	30 41       	ret			

00008f9c <_svfiprintf_r>:
    8f9c:	6a 15       	pushm	#7,	r10	;16-bit words

00008f9e <.LCFI2>:
    8f9e:	31 80 62 00 	sub	#98,	r1	;#0x0062

00008fa2 <.LCFI3>:
    8fa2:	81 4c 02 00 	mov	r12,	2(r1)	;
    8fa6:	0a 4d       	mov	r13,	r10	;

00008fa8 <L0>:
    8fa8:	08 4e       	mov	r14,	r8	;
    8faa:	09 4f       	mov	r15,	r9	;

00008fac <.LVL26>:
    8fac:	1d 4d 06 00 	mov	6(r13),	r13	;

00008fb0 <.LVL27>:
    8fb0:	7d f0 80 00 	and.b	#128,	r13	;#0x0080
    8fb4:	0d 93       	cmp	#0,	r13	;r3 As==00
    8fb6:	19 24       	jz	$+52     	;abs 0x8fea

00008fb8 <.Loc.880.1>:
    8fb8:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    8fbc:	16 20       	jnz	$+46     	;abs 0x8fea

00008fbe <.Loc.882.1>:
    8fbe:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    8fc2:	b0 12 78 9a 	call	#39544		;#0x9a78

00008fc6 <.LVL28>:
    8fc6:	8a 4c 00 00 	mov	r12,	0(r10)	;
    8fca:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

00008fce <.Loc.883.1>:
    8fce:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fd0:	09 20       	jnz	$+20     	;abs 0x8fe4

00008fd2 <.Loc.885.1>:
    8fd2:	1c 41 02 00 	mov	2(r1),	r12	;
    8fd6:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    8fda:	00 00 

00008fdc <.Loc.886.1>:
    8fdc:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11
    8fe0:	30 40 30 99 	br	#0x9930		;

00008fe4 <.L24>:
    8fe4:	ba 40 40 00 	mov	#64,	12(r10)	;#0x0040, 0x000c
    8fe8:	0c 00 

00008fea <.L23>:
    8fea:	7d 40 1a 00 	mov.b	#26,	r13	;#0x001a
    8fee:	0d 51       	add	r1,	r13	;
    8ff0:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

00008ff4 <.Loc.895.1>:
    8ff4:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018

00008ff8 <.Loc.896.1>:
    8ff8:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00008ffc <.LVL30>:
    8ffc:	81 48 04 00 	mov	r8,	4(r1)	;

00009000 <.Loc.894.1>:
    9000:	0b 4d       	mov	r13,	r11	;

00009002 <.Loc.718.1>:
    9002:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c

00009006 <.Loc.898.1>:
    9006:	91 41 0c 00 	mov	12(r1),	8(r1)	;0x0000c
    900a:	08 00 

0000900c <.L26>:
    900c:	18 41 04 00 	mov	4(r1),	r8	;

00009010 <.L27>:
    9010:	6c 48       	mov.b	@r8,	r12	;
    9012:	0c 93       	cmp	#0,	r12	;r3 As==00
    9014:	05 24       	jz	$+12     	;abs 0x9020

00009016 <.Loc.925.1>:
    9016:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    901a:	02 24       	jz	$+6      	;abs 0x9020

0000901c <.Loc.926.1>:
    901c:	18 53       	inc	r8		;
    901e:	f8 3f       	jmp	$-14     	;abs 0x9010

00009020 <.L28>:
    9020:	07 48       	mov	r8,	r7	;
    9022:	17 81 04 00 	sub	4(r1),	r7	;

00009026 <.LVL34>:
    9026:	07 93       	cmp	#0,	r7	;r3 As==00
    9028:	23 24       	jz	$+72     	;abs 0x9070

0000902a <.Loc.929.1>:
    902a:	9b 41 04 00 	mov	4(r1),	0(r11)	;
    902e:	00 00 
    9030:	8b 47 02 00 	mov	r7,	2(r11)	;
    9034:	81 57 18 00 	add	r7,	24(r1)	; 0x0018

00009038 <.LVL35>:
    9038:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    903c:	1c 53       	inc	r12		;
    903e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9042:	7e 40 07 00 	mov.b	#7,	r14	;
    9046:	0e 9c       	cmp	r12,	r14	;
    9048:	02 38       	jl	$+6      	;abs 0x904e
    904a:	2b 52       	add	#4,	r11	;r2 As==10

0000904c <.LVL36>:
    904c:	0f 3c       	jmp	$+32     	;abs 0x906c

0000904e <.L31>:
    904e:	0e 41       	mov	r1,	r14	;
    9050:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9054:	0d 4a       	mov	r10,	r13	;
    9056:	1c 41 02 00 	mov	2(r1),	r12	;
    905a:	b0 12 7c 8e 	call	#36476		;#0x8e7c

0000905e <.LVL38>:
    905e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9060:	02 24       	jz	$+6      	;abs 0x9066
    9062:	80 00 24 99 	mova	#39204,	r0	;0x09924

00009066 <.Loc.929.1>:
    9066:	0b 41       	mov	r1,	r11	;
    9068:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000906c <.L32>:
    906c:	81 57 08 00 	add	r7,	8(r1)	;

00009070 <.L30>:
    9070:	c8 93 00 00 	cmp.b	#0,	0(r8)	;r3 As==00
    9074:	02 20       	jnz	$+6      	;abs 0x907a
    9076:	80 00 0e 99 	mova	#39182,	r0	;0x0990e

0000907a <.LVL41>:
    907a:	0c 48       	mov	r8,	r12	;
    907c:	1c 53       	inc	r12		;

0000907e <.LVL42>:
    907e:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    9082:	4d 43       	clr.b	r13		;
    9084:	0e 4d       	mov	r13,	r14	;

00009086 <.Loc.945.1>:
    9086:	36 43       	mov	#-1,	r6	;r3 As==11

00009088 <.Loc.944.1>:
    9088:	81 4d 06 00 	mov	r13,	6(r1)	;

0000908c <.Loc.942.1>:
    908c:	05 4d       	mov	r13,	r5	;

0000908e <.Loc.959.1>:
    908e:	58 43       	mov.b	#1,	r8	;r3 As==01

00009090 <.L35>:
    9090:	04 4c       	mov	r12,	r4	;
    9092:	14 53       	inc	r4		;
    9094:	81 44 04 00 	mov	r4,	4(r1)	;

00009098 <.LVL44>:
    9098:	6c 4c       	mov.b	@r12,	r12	;

0000909a <.L37>:
    909a:	3c 90 58 00 	cmp	#88,	r12	;#0x0058
    909e:	92 24       	jz	$+294    	;abs 0x91c4
    90a0:	77 40 58 00 	mov.b	#88,	r7	;#0x0058
    90a4:	07 9c       	cmp	r12,	r7	;
    90a6:	41 38       	jl	$+132    	;abs 0x912a
    90a8:	3c 90 2e 00 	cmp	#46,	r12	;#0x002e
    90ac:	aa 24       	jz	$+342    	;abs 0x9202
    90ae:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    90b2:	0f 9c       	cmp	r12,	r15	;
    90b4:	1f 38       	jl	$+64     	;abs 0x90f4
    90b6:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    90ba:	92 24       	jz	$+294    	;abs 0x91e0
    90bc:	74 40 2a 00 	mov.b	#42,	r4	;#0x002a
    90c0:	04 9c       	cmp	r12,	r4	;
    90c2:	0c 38       	jl	$+26     	;abs 0x90dc
    90c4:	3c 90 20 00 	cmp	#32,	r12	;#0x0020
    90c8:	85 24       	jz	$+268    	;abs 0x91d4
    90ca:	3c 90 23 00 	cmp	#35,	r12	;#0x0023
    90ce:	02 24       	jz	$+6      	;abs 0x90d4
    90d0:	80 00 70 95 	mova	#38256,	r0	;0x09570

000090d4 <.Loc.979.1>:
    90d4:	15 d3       	bis	#1,	r5	;r3 As==01

000090d6 <.L36>:
    90d6:	1c 41 04 00 	mov	4(r1),	r12	;
    90da:	da 3f       	jmp	$-74     	;abs 0x9090

000090dc <.L44>:
    90dc:	3c 90 2b 00 	cmp	#43,	r12	;#0x002b
    90e0:	04 20       	jnz	$+10     	;abs 0x90ea
    90e2:	0d 48       	mov	r8,	r13	;

000090e4 <.Loc.1030.1>:
    90e4:	7e 40 2b 00 	mov.b	#43,	r14	;#0x002b
    90e8:	f6 3f       	jmp	$-18     	;abs 0x90d6

000090ea <.L234>:
    90ea:	3c 90 2d 00 	cmp	#45,	r12	;#0x002d
    90ee:	87 24       	jz	$+272    	;abs 0x91fe
    90f0:	30 40 70 95 	br	#0x9570		;

000090f4 <.L42>:
    90f4:	77 40 39 00 	mov.b	#57,	r7	;#0x0039
    90f8:	07 9c       	cmp	r12,	r7	;
    90fa:	0b 38       	jl	$+24     	;abs 0x9112
    90fc:	3c 90 31 00 	cmp	#49,	r12	;#0x0031
    9100:	aa 34       	jge	$+342    	;abs 0x9256
    9102:	3c 90 30 00 	cmp	#48,	r12	;#0x0030
    9106:	02 24       	jz	$+6      	;abs 0x910c
    9108:	80 00 70 95 	mova	#38256,	r0	;0x09570

0000910c <.Loc.1084.1>:
    910c:	35 d0 80 00 	bis	#128,	r5	;#0x0080

00009110 <.Loc.1085.1>:
    9110:	e2 3f       	jmp	$-58     	;abs 0x90d6

00009112 <.L48>:
    9112:	3c 90 4f 00 	cmp	#79,	r12	;#0x004f
    9116:	0e 25       	jz	$+542    	;abs 0x9334
    9118:	3c 90 55 00 	cmp	#85,	r12	;#0x0055
    911c:	45 25       	jz	$+652    	;abs 0x93a8
    911e:	3c 90 44 00 	cmp	#68,	r12	;#0x0044
    9122:	02 24       	jz	$+6      	;abs 0x9128
    9124:	80 00 70 95 	mova	#38256,	r0	;0x09570
    9128:	c7 3c       	jmp	$+400    	;abs 0x92b8

0000912a <.L40>:
    912a:	3c 90 6e 00 	cmp	#110,	r12	;#0x006e
    912e:	e8 24       	jz	$+466    	;abs 0x9300
    9130:	7f 40 6e 00 	mov.b	#110,	r15	;#0x006e
    9134:	0f 9c       	cmp	r12,	r15	;
    9136:	17 38       	jl	$+48     	;abs 0x9166
    9138:	3c 90 68 00 	cmp	#104,	r12	;#0x0068
    913c:	a9 24       	jz	$+340    	;abs 0x9290
    913e:	74 40 68 00 	mov.b	#104,	r4	;#0x0068
    9142:	04 9c       	cmp	r12,	r4	;
    9144:	08 38       	jl	$+18     	;abs 0x9156
    9146:	3c 90 63 00 	cmp	#99,	r12	;#0x0063
    914a:	a8 24       	jz	$+338    	;abs 0x929c
    914c:	3c 90 64 00 	cmp	#100,	r12	;#0x0064
    9150:	34 24       	jz	$+106    	;abs 0x91ba
    9152:	30 40 70 95 	br	#0x9570		;

00009156 <.L57>:
    9156:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    915a:	2f 24       	jz	$+96     	;abs 0x91ba
    915c:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    9160:	9a 24       	jz	$+310    	;abs 0x9296
    9162:	30 40 70 95 	br	#0x9570		;

00009166 <.L55>:
    9166:	3c 90 71 00 	cmp	#113,	r12	;#0x0071
    916a:	95 24       	jz	$+300    	;abs 0x9296
    916c:	77 40 71 00 	mov.b	#113,	r7	;#0x0071
    9170:	07 9c       	cmp	r12,	r7	;
    9172:	19 38       	jl	$+52     	;abs 0x91a6
    9174:	3c 90 6f 00 	cmp	#111,	r12	;#0x006f
    9178:	df 24       	jz	$+448    	;abs 0x9338
    917a:	3c 90 70 00 	cmp	#112,	r12	;#0x0070
    917e:	02 24       	jz	$+6      	;abs 0x9184
    9180:	80 00 70 95 	mova	#38256,	r0	;0x09570

00009184 <.Loc.1428.1>:
    9184:	07 49       	mov	r9,	r7	;
    9186:	27 53       	incd	r7		;

00009188 <.LVL49>:
    9188:	29 49       	mov	@r9,	r9	;
    918a:	08 49       	mov	r9,	r8	;
    918c:	09 43       	clr	r9		;

0000918e <.LVL50>:
    918e:	25 d3       	bis	#2,	r5	;r3 As==10

00009190 <.Loc.1432.1>:
    9190:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    9194:	12 00 

00009196 <.LVL52>:
    9196:	f1 40 78 00 	mov.b	#120,	19(r1)	;#0x0078, 0x0013
    919a:	13 00 

0000919c <.Loc.1430.1>:
    919c:	b1 40 bb 50 	mov	#20667,	12(r1)	;#0x50bb, 0x000c
    91a0:	0c 00 

000091a2 <.Loc.1429.1>:
    91a2:	6c 43       	mov.b	#2,	r12	;r3 As==10

000091a4 <.Loc.1434.1>:
    91a4:	3a 3d       	jmp	$+630    	;abs 0x941a

000091a6 <.L62>:
    91a6:	3c 90 75 00 	cmp	#117,	r12	;#0x0075
    91aa:	00 25       	jz	$+514    	;abs 0x93ac
    91ac:	3c 90 78 00 	cmp	#120,	r12	;#0x0078
    91b0:	0f 25       	jz	$+544    	;abs 0x93d0
    91b2:	3c 90 73 00 	cmp	#115,	r12	;#0x0073
    91b6:	dc 21       	jnz	$+954    	;abs 0x9570
    91b8:	d9 3c       	jmp	$+436    	;abs 0x936c

000091ba <.L59>:
    91ba:	0d 93       	cmp	#0,	r13	;r3 As==00
    91bc:	83 24       	jz	$+264    	;abs 0x92c4
    91be:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011
    91c2:	80 3c       	jmp	$+258    	;abs 0x92c4

000091c4 <.L39>:
    91c4:	0d 93       	cmp	#0,	r13	;r3 As==00
    91c6:	02 24       	jz	$+6      	;abs 0x91cc
    91c8:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

000091cc <.L70>:
    91cc:	b1 40 aa 50 	mov	#20650,	12(r1)	;#0x50aa, 0x000c
    91d0:	0c 00 

000091d2 <.LVL54>:
    91d2:	05 3d       	jmp	$+524    	;abs 0x93de

000091d4 <.L45>:
    91d4:	0e 93       	cmp	#0,	r14	;r3 As==00
    91d6:	7f 23       	jnz	$-256    	;abs 0x90d6
    91d8:	0d 48       	mov	r8,	r13	;

000091da <.Loc.976.1>:
    91da:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    91de:	7b 3f       	jmp	$-264    	;abs 0x90d6

000091e0 <.L43>:
    91e0:	0f 49       	mov	r9,	r15	;
    91e2:	1f 53       	inc	r15		;
    91e4:	1f c3       	bic	#1,	r15	;r3 As==01
    91e6:	09 4f       	mov	r15,	r9	;

000091e8 <.LVL56>:
    91e8:	29 53       	incd	r9		;

000091ea <.LVL57>:
    91ea:	a1 4f 06 00 	mov	@r15,	6(r1)	;

000091ee <.LVL58>:
    91ee:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    91f2:	71 37       	jge	$-284    	;abs 0x90d6

000091f4 <.Loc.1024.1>:
    91f4:	44 43       	clr.b	r4		;
    91f6:	14 81 06 00 	sub	6(r1),	r4	;
    91fa:	81 44 06 00 	mov	r4,	6(r1)	;

000091fe <.L47>:
    91fe:	25 d2       	bis	#4,	r5	;r2 As==10

00009200 <.Loc.1028.1>:
    9200:	6a 3f       	jmp	$-298    	;abs 0x90d6

00009202 <.L41>:
    9202:	1f 41 04 00 	mov	4(r1),	r15	;
    9206:	1f 53       	inc	r15		;

00009208 <.LVL61>:
    9208:	17 41 04 00 	mov	4(r1),	r7	;
    920c:	6c 47       	mov.b	@r7,	r12	;
    920e:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    9212:	02 24       	jz	$+6      	;abs 0x9218
    9214:	46 43       	clr.b	r6		;

00009216 <.LVL63>:
    9216:	0c 3c       	jmp	$+26     	;abs 0x9230

00009218 <.L72>:
    9218:	19 53       	inc	r9		;

0000921a <.LVL65>:
    921a:	0c 49       	mov	r9,	r12	;

0000921c <.LVL66>:
    921c:	1c c3       	bic	#1,	r12	;r3 As==01
    921e:	09 4c       	mov	r12,	r9	;

00009220 <.LVL67>:
    9220:	29 53       	incd	r9		;

00009222 <.LVL68>:
    9222:	26 4c       	mov	@r12,	r6	;
    9224:	06 93       	cmp	#0,	r6	;r3 As==00
    9226:	01 34       	jge	$+4      	;abs 0x922a
    9228:	36 43       	mov	#-1,	r6	;r3 As==11

0000922a <.L74>:
    922a:	81 4f 04 00 	mov	r15,	4(r1)	;
    922e:	53 3f       	jmp	$-344    	;abs 0x90d6

00009230 <.L73>:
    9230:	81 4f 04 00 	mov	r15,	4(r1)	;

00009234 <.LVL70>:
    9234:	07 4c       	mov	r12,	r7	;
    9236:	37 50 d0 ff 	add	#65488,	r7	;#0xffd0
    923a:	74 40 09 00 	mov.b	#9,	r4	;
    923e:	04 97       	cmp	r7,	r4	;
    9240:	2c 2b       	jnc	$-422    	;abs 0x909a

00009242 <.LVL71>:
    9242:	0c 46       	mov	r6,	r12	;

00009244 <.LVL72>:
    9244:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    9248:	0c 56       	add	r6,	r12	;
    924a:	0c 5c       	rla	r12		;
    924c:	06 47       	mov	r7,	r6	;

0000924e <.LVL73>:
    924e:	06 5c       	add	r12,	r6	;

00009250 <.LVL74>:
    9250:	6c 4f       	mov.b	@r15,	r12	;

00009252 <.LVL75>:
    9252:	1f 53       	inc	r15		;

00009254 <.LVL76>:
    9254:	ed 3f       	jmp	$-36     	;abs 0x9230

00009256 <.L49>:
    9256:	17 41 04 00 	mov	4(r1),	r7	;

0000925a <.Loc.959.1>:
    925a:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

0000925e <.L77>:
    925e:	1f 41 06 00 	mov	6(r1),	r15	;
    9262:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    9266:	1f 51 06 00 	add	6(r1),	r15	;
    926a:	0f 5f       	rla	r15		;
    926c:	3c 50 d0 ff 	add	#65488,	r12	;#0xffd0

00009270 <.LVL79>:
    9270:	0c 5f       	add	r15,	r12	;

00009272 <.LVL80>:
    9272:	81 4c 06 00 	mov	r12,	6(r1)	;

00009276 <.LVL81>:
    9276:	91 53 04 00 	inc	4(r1)		;

0000927a <.Loc.1091.1>:
    927a:	6c 47       	mov.b	@r7,	r12	;

0000927c <.LVL83>:
    927c:	17 41 04 00 	mov	4(r1),	r7	;

00009280 <.Loc.1092.1>:
    9280:	0f 4c       	mov	r12,	r15	;
    9282:	3f 50 d0 ff 	add	#65488,	r15	;#0xffd0
    9286:	74 40 09 00 	mov.b	#9,	r4	;
    928a:	04 9f       	cmp	r15,	r4	;
    928c:	e8 2f       	jc	$-46     	;abs 0x925e
    928e:	05 3f       	jmp	$-500    	;abs 0x909a

00009290 <.L56>:
    9290:	35 d0 40 00 	bis	#64,	r5	;#0x0040

00009294 <.Loc.1119.1>:
    9294:	20 3f       	jmp	$-446    	;abs 0x90d6

00009296 <.L61>:
    9296:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000929a <.Loc.1131.1>:
    929a:	1d 3f       	jmp	$-452    	;abs 0x90d6

0000929c <.L58>:
    929c:	19 53       	inc	r9		;

0000929e <.LVL88>:
    929e:	19 c3       	bic	#1,	r9	;r3 As==01

000092a0 <.LVL89>:
    92a0:	07 49       	mov	r9,	r7	;
    92a2:	27 53       	incd	r7		;

000092a4 <.LVL90>:
    92a4:	e1 49 3a 00 	mov.b	@r9,	58(r1)	; 0x003a

000092a8 <.LVL91>:
    92a8:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

000092ac <.Loc.1190.1>:
    92ac:	56 43       	mov.b	#1,	r6	;r3 As==01

000092ae <.LVL92>:
    92ae:	49 43       	clr.b	r9		;

000092b0 <.Loc.1173.1>:
    92b0:	04 41       	mov	r1,	r4	;
    92b2:	34 50 3a 00 	add	#58,	r4	;#0x003a

000092b6 <.Loc.1193.1>:
    92b6:	6e 3d       	jmp	$+734    	;abs 0x9594

000092b8 <.L235>:
    92b8:	0d 93       	cmp	#0,	r13	;r3 As==00
    92ba:	02 24       	jz	$+6      	;abs 0x92c0
    92bc:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

000092c0 <.L79>:
    92c0:	35 d0 10 00 	bis	#16,	r5	;#0x0010

000092c4 <.L69>:
    92c4:	19 53       	inc	r9		;

000092c6 <.LVL95>:
    92c6:	19 c3       	bic	#1,	r9	;r3 As==01

000092c8 <.LVL96>:
    92c8:	07 49       	mov	r9,	r7	;
    92ca:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    92ce:	05 24       	jz	$+12     	;abs 0x92da
    92d0:	27 52       	add	#4,	r7	;r2 As==10

000092d2 <.LVL97>:
    92d2:	28 49       	mov	@r9,	r8	;
    92d4:	19 49 02 00 	mov	2(r9),	r9	;
    92d8:	06 3c       	jmp	$+14     	;abs 0x92e6

000092da <.L80>:
    92da:	27 53       	incd	r7		;

000092dc <.LVL99>:
    92dc:	28 49       	mov	@r9,	r8	;
    92de:	38 b0 00 80 	bit	#32768,	r8	;#0x8000
    92e2:	09 79       	subc	r9,	r9	;
    92e4:	39 e3       	inv	r9		;

000092e6 <.L81>:
    92e6:	09 93       	cmp	#0,	r9	;r3 As==00
    92e8:	9b 34       	jge	$+312    	;abs 0x9420

000092ea <.Loc.1207.1>:
    92ea:	4c 43       	clr.b	r12		;

000092ec <.LVL101>:
    92ec:	4d 43       	clr.b	r13		;
    92ee:	0c 88       	sub	r8,	r12	;
    92f0:	0d 79       	subc	r9,	r13	;
    92f2:	08 4c       	mov	r12,	r8	;

000092f4 <.LVL102>:
    92f4:	09 4d       	mov	r13,	r9	;

000092f6 <.LVL103>:
    92f6:	f1 40 2d 00 	mov.b	#45,	17(r1)	;#0x002d, 0x0011
    92fa:	11 00 

000092fc <.Loc.1210.1>:
    92fc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    92fe:	91 3c       	jmp	$+292    	;abs 0x9422

00009300 <.L54>:
    9300:	0d 93       	cmp	#0,	r13	;r3 As==00
    9302:	02 24       	jz	$+6      	;abs 0x9308
    9304:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

00009308 <.L86>:
    9308:	0c 49       	mov	r9,	r12	;

0000930a <.LVL105>:
    930a:	2c 53       	incd	r12		;

0000930c <.Loc.1399.1>:
    930c:	2d 49       	mov	@r9,	r13	;

0000930e <.Loc.1398.1>:
    930e:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    9312:	0b 24       	jz	$+24     	;abs 0x932a

00009314 <.LVL106>:
    9314:	1f 41 08 00 	mov	8(r1),	r15	;
    9318:	0e 4f       	mov	r15,	r14	;
    931a:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    931e:	8d 4e 00 00 	mov	r14,	0(r13)	;
    9322:	8d 4f 02 00 	mov	r15,	2(r13)	;
    9326:	09 4c       	mov	r12,	r9	;
    9328:	71 3e       	jmp	$-796    	;abs 0x900c

0000932a <.L87>:
    932a:	9d 41 08 00 	mov	8(r1),	0(r13)	;
    932e:	00 00 

00009330 <.LVL108>:
    9330:	09 4c       	mov	r12,	r9	;
    9332:	6c 3e       	jmp	$-806    	;abs 0x900c

00009334 <.L51>:
    9334:	35 d0 10 00 	bis	#16,	r5	;#0x0010

00009338 <.L63>:
    9338:	0d 45       	mov	r5,	r13	;
    933a:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    933e:	19 53       	inc	r9		;

00009340 <.LVL111>:
    9340:	0d 93       	cmp	#0,	r13	;r3 As==00
    9342:	08 24       	jz	$+18     	;abs 0x9354
    9344:	19 c3       	bic	#1,	r9	;r3 As==01

00009346 <.LVL112>:
    9346:	07 49       	mov	r9,	r7	;
    9348:	27 52       	add	#4,	r7	;r2 As==10

0000934a <.LVL113>:
    934a:	28 49       	mov	@r9,	r8	;
    934c:	19 49 02 00 	mov	2(r9),	r9	;

00009350 <.L233>:
    9350:	4c 43       	clr.b	r12		;
    9352:	63 3c       	jmp	$+200    	;abs 0x941a

00009354 <.L90>:
    9354:	0c 45       	mov	r5,	r12	;

00009356 <.LVL116>:
    9356:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    935a:	19 c3       	bic	#1,	r9	;r3 As==01

0000935c <.LVL117>:
    935c:	07 49       	mov	r9,	r7	;
    935e:	27 53       	incd	r7		;

00009360 <.LVL118>:
    9360:	29 49       	mov	@r9,	r9	;
    9362:	08 49       	mov	r9,	r8	;
    9364:	09 43       	clr	r9		;
    9366:	0c 93       	cmp	#0,	r12	;r3 As==00
    9368:	58 24       	jz	$+178    	;abs 0x941a
    936a:	f2 3f       	jmp	$-26     	;abs 0x9350

0000936c <.L236>:
    936c:	07 49       	mov	r9,	r7	;
    936e:	27 53       	incd	r7		;

00009370 <.LVL120>:
    9370:	24 49       	mov	@r9,	r4	;

00009372 <.Loc.1443.1>:
    9372:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

00009376 <.Loc.1518.1>:
    9376:	36 93       	cmp	#-1,	r6	;r3 As==11
    9378:	0e 24       	jz	$+30     	;abs 0x9396

0000937a <.LBB4>:
    937a:	0e 46       	mov	r6,	r14	;
    937c:	4d 43       	clr.b	r13		;
    937e:	0c 44       	mov	r4,	r12	;

00009380 <.LVL121>:
    9380:	81 4b 00 00 	mov	r11,	0(r1)	;
    9384:	b0 12 3c 99 	call	#39228		;#0x993c

00009388 <.LVL122>:
    9388:	2b 41       	mov	@r1,	r11	;
    938a:	0c 93       	cmp	#0,	r12	;r3 As==00
    938c:	02 25       	jz	$+518    	;abs 0x9592

0000938e <.Loc.1527.1>:
    938e:	06 4c       	mov	r12,	r6	;
    9390:	06 84       	sub	r4,	r6	;

00009392 <.LBE4>:
    9392:	49 43       	clr.b	r9		;

00009394 <.LBB5>:
    9394:	ff 3c       	jmp	$+512    	;abs 0x9594

00009396 <.L93>:
    9396:	0c 44       	mov	r4,	r12	;

00009398 <.LVL125>:
    9398:	81 4b 00 00 	mov	r11,	0(r1)	;
    939c:	b0 12 6a 8e 	call	#36458		;#0x8e6a

000093a0 <.LVL126>:
    93a0:	06 4c       	mov	r12,	r6	;

000093a2 <.LVL127>:
    93a2:	49 43       	clr.b	r9		;
    93a4:	2b 41       	mov	@r1,	r11	;
    93a6:	f6 3c       	jmp	$+494    	;abs 0x9594

000093a8 <.L52>:
    93a8:	35 d0 10 00 	bis	#16,	r5	;#0x0010

000093ac <.L65>:
    93ac:	19 53       	inc	r9		;

000093ae <.LVL130>:
    93ae:	19 c3       	bic	#1,	r9	;r3 As==01

000093b0 <.LVL131>:
    93b0:	07 49       	mov	r9,	r7	;
    93b2:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    93b6:	06 24       	jz	$+14     	;abs 0x93c4
    93b8:	27 52       	add	#4,	r7	;r2 As==10

000093ba <.LVL132>:
    93ba:	28 49       	mov	@r9,	r8	;
    93bc:	19 49 02 00 	mov	2(r9),	r9	;

000093c0 <.Loc.1539.1>:
    93c0:	5c 43       	mov.b	#1,	r12	;r3 As==01

000093c2 <.LVL133>:
    93c2:	2b 3c       	jmp	$+88     	;abs 0x941a

000093c4 <.L94>:
    93c4:	27 53       	incd	r7		;

000093c6 <.LVL135>:
    93c6:	29 49       	mov	@r9,	r9	;

000093c8 <.LVL136>:
    93c8:	08 49       	mov	r9,	r8	;
    93ca:	09 43       	clr	r9		;

000093cc <.Loc.1539.1>:
    93cc:	5c 43       	mov.b	#1,	r12	;r3 As==01

000093ce <.LVL137>:
    93ce:	25 3c       	jmp	$+76     	;abs 0x941a

000093d0 <.L66>:
    93d0:	0d 93       	cmp	#0,	r13	;r3 As==00
    93d2:	02 24       	jz	$+6      	;abs 0x93d8
    93d4:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

000093d8 <.L96>:
    93d8:	b1 40 bb 50 	mov	#20667,	12(r1)	;#0x50bb, 0x000c
    93dc:	0c 00 

000093de <.L71>:
    93de:	19 53       	inc	r9		;

000093e0 <.LVL140>:
    93e0:	19 c3       	bic	#1,	r9	;r3 As==01

000093e2 <.LVL141>:
    93e2:	07 49       	mov	r9,	r7	;
    93e4:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    93e8:	05 24       	jz	$+12     	;abs 0x93f4
    93ea:	27 52       	add	#4,	r7	;r2 As==10

000093ec <.LVL142>:
    93ec:	28 49       	mov	@r9,	r8	;
    93ee:	19 49 02 00 	mov	2(r9),	r9	;
    93f2:	04 3c       	jmp	$+10     	;abs 0x93fc

000093f4 <.L97>:
    93f4:	27 53       	incd	r7		;

000093f6 <.LVL144>:
    93f6:	29 49       	mov	@r9,	r9	;

000093f8 <.LVL145>:
    93f8:	08 49       	mov	r9,	r8	;
    93fa:	09 43       	clr	r9		;

000093fc <.L98>:
    93fc:	15 b3       	bit	#1,	r5	;r3 As==01
    93fe:	0c 24       	jz	$+26     	;abs 0x9418

00009400 <.Loc.1549.1>:
    9400:	0d 48       	mov	r8,	r13	;
    9402:	0d d9       	bis	r9,	r13	;
    9404:	0d 93       	cmp	#0,	r13	;r3 As==00
    9406:	08 24       	jz	$+18     	;abs 0x9418

00009408 <.Loc.1550.1>:
    9408:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    940c:	12 00 

0000940e <.Loc.1551.1>:
    940e:	c1 4c 13 00 	mov.b	r12,	19(r1)	; 0x0013

00009412 <.Loc.1552.1>:
    9412:	25 d3       	bis	#2,	r5	;r3 As==10

00009414 <.Loc.1547.1>:
    9414:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009416 <.LVL148>:
    9416:	01 3c       	jmp	$+4      	;abs 0x941a

00009418 <.L157>:
    9418:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000941a <.L91>:
    941a:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    941e:	01 3c       	jmp	$+4      	;abs 0x9422

00009420 <.L154>:
    9420:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009422 <.L84>:
    9422:	36 93       	cmp	#-1,	r6	;r3 As==11
    9424:	0c 24       	jz	$+26     	;abs 0x943e

00009426 <.Loc.1566.1>:
    9426:	04 45       	mov	r5,	r4	;
    9428:	34 f0 7f ff 	and	#65407,	r4	;#0xff7f
    942c:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

00009430 <.LVL153>:
    9430:	0d 48       	mov	r8,	r13	;
    9432:	0d d9       	bis	r9,	r13	;
    9434:	0d 93       	cmp	#0,	r13	;r3 As==00
    9436:	09 20       	jnz	$+20     	;abs 0x944a

00009438 <.Loc.1574.1>:
    9438:	06 93       	cmp	#0,	r6	;r3 As==00
    943a:	84 24       	jz	$+266    	;abs 0x9544
    943c:	0b 3c       	jmp	$+24     	;abs 0x9454

0000943e <.L101>:
    943e:	0d 48       	mov	r8,	r13	;
    9440:	0d d9       	bis	r9,	r13	;
    9442:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a
    9446:	0d 93       	cmp	#0,	r13	;r3 As==00
    9448:	05 24       	jz	$+12     	;abs 0x9454

0000944a <.L102>:
    944a:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    944c:	32 24       	jz	$+102    	;abs 0x94b2
    944e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9450:	61 24       	jz	$+196    	;abs 0x9514
    9452:	06 3c       	jmp	$+14     	;abs 0x9460

00009454 <.L103>:
    9454:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9456:	33 24       	jz	$+104    	;abs 0x94be
    9458:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    945a:	5a 24       	jz	$+182    	;abs 0x9510
    945c:	48 43       	clr.b	r8		;

0000945e <.LVL156>:
    945e:	49 43       	clr.b	r9		;

00009460 <.L105>:
    9460:	05 41       	mov	r1,	r5	;
    9462:	35 50 62 00 	add	#98,	r5	;#0x0062

00009466 <.L108>:
    9466:	04 45       	mov	r5,	r4	;
    9468:	34 53       	add	#-1,	r4	;r3 As==11

0000946a <.LVL158>:
    946a:	4c 48       	mov.b	r8,	r12	;
    946c:	7c f0 07 00 	and.b	#7,	r12	;
    9470:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    9474:	4e 4c       	mov.b	r12,	r14	;
    9476:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    947a:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000947e <.Loc.1584.1>:
    947e:	0c 48       	mov	r8,	r12	;
    9480:	0d 49       	mov	r9,	r13	;
    9482:	81 4b 00 00 	mov	r11,	0(r1)	;
    9486:	b0 12 96 8d 	call	#36246		;#0x8d96

0000948a <.LVL159>:
    948a:	08 4c       	mov	r12,	r8	;

0000948c <.LVL160>:
    948c:	09 4d       	mov	r13,	r9	;

0000948e <.LVL161>:
    948e:	0c dd       	bis	r13,	r12	;
    9490:	2b 41       	mov	@r1,	r11	;

00009492 <.LVL162>:
    9492:	0c 93       	cmp	#0,	r12	;r3 As==00
    9494:	02 24       	jz	$+6      	;abs 0x949a
    9496:	05 44       	mov	r4,	r5	;
    9498:	e6 3f       	jmp	$-50     	;abs 0x9466

0000949a <.L237>:
    949a:	91 b3 0a 00 	bit	#1,	10(r1)	;r3 As==01, 0x000a
    949e:	60 24       	jz	$+194    	;abs 0x9560

000094a0 <.Loc.1587.1>:
    94a0:	b1 90 30 00 	cmp	#48,	14(r1)	;#0x0030, 0x000e
    94a4:	0e 00 
    94a6:	5c 24       	jz	$+186    	;abs 0x9560

000094a8 <.LVL163>:
    94a8:	f4 40 30 00 	mov.b	#48,	-1(r4)	;#0x0030, 0xffff
    94ac:	ff ff 
    94ae:	34 53       	add	#-1,	r4	;r3 As==11
    94b0:	57 3c       	jmp	$+176    	;abs 0x9560

000094b2 <.L106>:
    94b2:	09 93       	cmp	#0,	r9	;r3 As==00
    94b4:	0d 20       	jnz	$+28     	;abs 0x94d0
    94b6:	7f 40 09 00 	mov.b	#9,	r15	;
    94ba:	0f 98       	cmp	r8,	r15	;
    94bc:	09 28       	jnc	$+20     	;abs 0x94d0

000094be <.L112>:
    94be:	4c 48       	mov.b	r8,	r12	;

000094c0 <.LVL166>:
    94c0:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    94c4:	c1 4c 61 00 	mov.b	r12,	97(r1)	; 0x0061
    94c8:	04 41       	mov	r1,	r4	;
    94ca:	34 50 61 00 	add	#97,	r4	;#0x0061

000094ce <.Loc.1595.1>:
    94ce:	48 3c       	jmp	$+146    	;abs 0x9560

000094d0 <.L110>:
    94d0:	04 41       	mov	r1,	r4	;
    94d2:	34 50 62 00 	add	#98,	r4	;#0x0062

000094d6 <.Loc.1601.1>:
    94d6:	35 40 0e 8c 	mov	#35854,	r5	;#0x8c0e

000094da <.L113>:
    94da:	34 53       	add	#-1,	r4	;r3 As==11
    94dc:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    94e0:	4f 43       	clr.b	r15		;
    94e2:	0c 48       	mov	r8,	r12	;
    94e4:	0d 49       	mov	r9,	r13	;
    94e6:	81 4b 00 00 	mov	r11,	0(r1)	;
    94ea:	85 12       	call	r5		;
    94ec:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    94f0:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

000094f4 <.Loc.1622.1>:
    94f4:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    94f8:	4f 43       	clr.b	r15		;
    94fa:	0c 48       	mov	r8,	r12	;
    94fc:	0d 49       	mov	r9,	r13	;
    94fe:	b0 12 00 8c 	call	#35840		;#0x8c00
    9502:	08 4c       	mov	r12,	r8	;

00009504 <.LVL172>:
    9504:	09 4d       	mov	r13,	r9	;

00009506 <.LVL173>:
    9506:	0c dd       	bis	r13,	r12	;
    9508:	2b 41       	mov	@r1,	r11	;
    950a:	0c 93       	cmp	#0,	r12	;r3 As==00
    950c:	e6 23       	jnz	$-50     	;abs 0x94da
    950e:	28 3c       	jmp	$+82     	;abs 0x9560

00009510 <.L162>:
    9510:	48 43       	clr.b	r8		;

00009512 <.LVL175>:
    9512:	49 43       	clr.b	r9		;

00009514 <.L107>:
    9514:	04 41       	mov	r1,	r4	;
    9516:	34 50 62 00 	add	#98,	r4	;#0x0062

0000951a <.L114>:
    951a:	34 53       	add	#-1,	r4	;r3 As==11
    951c:	0c 48       	mov	r8,	r12	;
    951e:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    9522:	1c 51 0c 00 	add	12(r1),	r12	;0x0000c
    9526:	e4 4c 00 00 	mov.b	@r12,	0(r4)	;

0000952a <.Loc.1629.1>:
    952a:	0c 48       	mov	r8,	r12	;
    952c:	0d 49       	mov	r9,	r13	;
    952e:	81 4b 00 00 	mov	r11,	0(r1)	;
    9532:	b0 12 90 8d 	call	#36240		;#0x8d90

00009536 <.LVL178>:
    9536:	08 4c       	mov	r12,	r8	;

00009538 <.LVL179>:
    9538:	09 4d       	mov	r13,	r9	;

0000953a <.LVL180>:
    953a:	0c dd       	bis	r13,	r12	;
    953c:	2b 41       	mov	@r1,	r11	;

0000953e <.LVL181>:
    953e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9540:	ec 23       	jnz	$-38     	;abs 0x951a
    9542:	0e 3c       	jmp	$+30     	;abs 0x9560

00009544 <.L231>:
    9544:	0c 93       	cmp	#0,	r12	;r3 As==00
    9546:	09 20       	jnz	$+20     	;abs 0x955a

00009548 <.Loc.1648.1>:
    9548:	15 b3       	bit	#1,	r5	;r3 As==01
    954a:	07 24       	jz	$+16     	;abs 0x955a

0000954c <.LVL183>:
    954c:	f1 40 30 00 	mov.b	#48,	97(r1)	;#0x0030, 0x0061
    9550:	61 00 
    9552:	04 41       	mov	r1,	r4	;

00009554 <.LVL184>:
    9554:	34 50 61 00 	add	#97,	r4	;#0x0061
    9558:	03 3c       	jmp	$+8      	;abs 0x9560

0000955a <.L160>:
    955a:	04 41       	mov	r1,	r4	;

0000955c <.LVL186>:
    955c:	34 50 62 00 	add	#98,	r4	;#0x0062

00009560 <.L109>:
    9560:	09 46       	mov	r6,	r9	;
    9562:	76 40 62 00 	mov.b	#98,	r6	;#0x0062

00009566 <.LVL188>:
    9566:	06 51       	add	r1,	r6	;
    9568:	06 84       	sub	r4,	r6	;
    956a:	15 41 0a 00 	mov	10(r1),	r5	;0x0000a
    956e:	12 3c       	jmp	$+38     	;abs 0x9594

00009570 <.L38>:
    9570:	0d 93       	cmp	#0,	r13	;r3 As==00
    9572:	02 24       	jz	$+6      	;abs 0x9578
    9574:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

00009578 <.L115>:
    9578:	0c 93       	cmp	#0,	r12	;r3 As==00
    957a:	c9 25       	jz	$+916    	;abs 0x990e

0000957c <.LVL190>:
    957c:	c1 4c 3a 00 	mov.b	r12,	58(r1)	; 0x003a

00009580 <.LVL191>:
    9580:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

00009584 <.Loc.1662.1>:
    9584:	07 49       	mov	r9,	r7	;

00009586 <.Loc.1660.1>:
    9586:	56 43       	mov.b	#1,	r6	;r3 As==01

00009588 <.LVL192>:
    9588:	49 43       	clr.b	r9		;

0000958a <.LVL193>:
    958a:	04 41       	mov	r1,	r4	;
    958c:	34 50 3a 00 	add	#58,	r4	;#0x003a

00009590 <.Loc.1662.1>:
    9590:	01 3c       	jmp	$+4      	;abs 0x9594

00009592 <.L155>:
    9592:	09 4c       	mov	r12,	r9	;

00009594 <.L78>:
    9594:	08 49       	mov	r9,	r8	;
    9596:	09 96       	cmp	r6,	r9	;
    9598:	01 34       	jge	$+4      	;abs 0x959c
    959a:	08 46       	mov	r6,	r8	;

0000959c <.L116>:
    959c:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    95a0:	01 24       	jz	$+4      	;abs 0x95a4

000095a2 <.Loc.1682.1>:
    95a2:	18 53       	inc	r8		;

000095a4 <.L117>:
    95a4:	0f 45       	mov	r5,	r15	;
    95a6:	6f f3       	and.b	#2,	r15	;r3 As==10
    95a8:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    95ac:	0f 93       	cmp	#0,	r15	;r3 As==00
    95ae:	01 24       	jz	$+4      	;abs 0x95b2

000095b0 <.Loc.1684.1>:
    95b0:	28 53       	incd	r8		;

000095b2 <.L118>:
    95b2:	0f 45       	mov	r5,	r15	;
    95b4:	7f f0 84 00 	and.b	#132,	r15	;#0x0084
    95b8:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    95bc:	0f 93       	cmp	#0,	r15	;r3 As==00
    95be:	4a 20       	jnz	$+150    	;abs 0x9654

000095c0 <.Loc.1688.1>:
    95c0:	1f 41 06 00 	mov	6(r1),	r15	;
    95c4:	0f 88       	sub	r8,	r15	;

000095c6 <.LVL199>:
    95c6:	4c 43       	clr.b	r12		;
    95c8:	0c 9f       	cmp	r15,	r12	;
    95ca:	44 34       	jge	$+138    	;abs 0x9654

000095cc <.L120>:
    95cc:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    95d0:	1c 53       	inc	r12		;

000095d2 <.Loc.1688.1>:
    95d2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    95d6:	bb 40 dc 50 	mov	#20700,	0(r11)	;#0x50dc
    95da:	00 00 
    95dc:	0e 9f       	cmp	r15,	r14	;
    95de:	21 34       	jge	$+68     	;abs 0x9622

000095e0 <.Loc.1688.1>:
    95e0:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    95e4:	02 00 
    95e6:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    95ea:	18 00 

000095ec <.LVL201>:
    95ec:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    95f0:	7d 40 07 00 	mov.b	#7,	r13	;
    95f4:	0d 9c       	cmp	r12,	r13	;
    95f6:	02 38       	jl	$+6      	;abs 0x95fc

000095f8 <.Loc.1688.1>:
    95f8:	2b 52       	add	#4,	r11	;r2 As==10

000095fa <.LVL202>:
    95fa:	10 3c       	jmp	$+34     	;abs 0x961c

000095fc <.L121>:
    95fc:	0e 41       	mov	r1,	r14	;
    95fe:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9602:	0d 4a       	mov	r10,	r13	;
    9604:	1c 41 02 00 	mov	2(r1),	r12	;
    9608:	81 4f 00 00 	mov	r15,	0(r1)	;
    960c:	b0 12 7c 8e 	call	#36476		;#0x8e7c

00009610 <.LVL204>:
    9610:	2f 41       	mov	@r1,	r15	;
    9612:	0c 93       	cmp	#0,	r12	;r3 As==00
    9614:	87 21       	jnz	$+784    	;abs 0x9924

00009616 <.Loc.1688.1>:
    9616:	0b 41       	mov	r1,	r11	;
    9618:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000961c <.L122>:
    961c:	3f 50 f0 ff 	add	#65520,	r15	;#0xfff0

00009620 <.LVL206>:
    9620:	d5 3f       	jmp	$-84     	;abs 0x95cc

00009622 <.L238>:
    9622:	8b 4f 02 00 	mov	r15,	2(r11)	;
    9626:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

0000962a <.LVL207>:
    962a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    962e:	7f 40 07 00 	mov.b	#7,	r15	;

00009632 <.LVL208>:
    9632:	0f 9c       	cmp	r12,	r15	;
    9634:	02 38       	jl	$+6      	;abs 0x963a

00009636 <.Loc.1688.1>:
    9636:	2b 52       	add	#4,	r11	;r2 As==10

00009638 <.LVL209>:
    9638:	0d 3c       	jmp	$+28     	;abs 0x9654

0000963a <.L124>:
    963a:	0e 41       	mov	r1,	r14	;
    963c:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9640:	0d 4a       	mov	r10,	r13	;
    9642:	1c 41 02 00 	mov	2(r1),	r12	;
    9646:	b0 12 7c 8e 	call	#36476		;#0x8e7c

0000964a <.LVL211>:
    964a:	0c 93       	cmp	#0,	r12	;r3 As==00
    964c:	6b 21       	jnz	$+728    	;abs 0x9924

0000964e <.Loc.1688.1>:
    964e:	0b 41       	mov	r1,	r11	;
    9650:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009654 <.L119>:
    9654:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    9658:	21 24       	jz	$+68     	;abs 0x969c

0000965a <.Loc.1692.1>:
    965a:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    965e:	0c 51       	add	r1,	r12	;
    9660:	8b 4c 00 00 	mov	r12,	0(r11)	;
    9664:	9b 43 02 00 	mov	#1,	2(r11)	;r3 As==01
    9668:	91 53 18 00 	inc	24(r1)		;

0000966c <.LVL213>:
    966c:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9670:	1c 53       	inc	r12		;
    9672:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9676:	7d 40 07 00 	mov.b	#7,	r13	;
    967a:	0d 9c       	cmp	r12,	r13	;
    967c:	02 38       	jl	$+6      	;abs 0x9682
    967e:	2b 52       	add	#4,	r11	;r2 As==10

00009680 <.LVL214>:
    9680:	0d 3c       	jmp	$+28     	;abs 0x969c

00009682 <.L126>:
    9682:	0e 41       	mov	r1,	r14	;
    9684:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9688:	0d 4a       	mov	r10,	r13	;
    968a:	1c 41 02 00 	mov	2(r1),	r12	;
    968e:	b0 12 7c 8e 	call	#36476		;#0x8e7c

00009692 <.LVL216>:
    9692:	0c 93       	cmp	#0,	r12	;r3 As==00
    9694:	47 21       	jnz	$+656    	;abs 0x9924

00009696 <.Loc.1692.1>:
    9696:	0b 41       	mov	r1,	r11	;
    9698:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000969c <.L125>:
    969c:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    96a0:	21 24       	jz	$+68     	;abs 0x96e4

000096a2 <.Loc.1694.1>:
    96a2:	7e 40 12 00 	mov.b	#18,	r14	;#0x0012
    96a6:	0e 51       	add	r1,	r14	;
    96a8:	8b 4e 00 00 	mov	r14,	0(r11)	;
    96ac:	ab 43 02 00 	mov	#2,	2(r11)	;r3 As==10
    96b0:	a1 53 18 00 	incd	24(r1)		;

000096b4 <.LVL218>:
    96b4:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    96b8:	1c 53       	inc	r12		;
    96ba:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    96be:	7f 40 07 00 	mov.b	#7,	r15	;
    96c2:	0f 9c       	cmp	r12,	r15	;
    96c4:	02 38       	jl	$+6      	;abs 0x96ca
    96c6:	2b 52       	add	#4,	r11	;r2 As==10

000096c8 <.LVL219>:
    96c8:	0d 3c       	jmp	$+28     	;abs 0x96e4

000096ca <.L128>:
    96ca:	0e 41       	mov	r1,	r14	;
    96cc:	3e 50 14 00 	add	#20,	r14	;#0x0014
    96d0:	0d 4a       	mov	r10,	r13	;
    96d2:	1c 41 02 00 	mov	2(r1),	r12	;
    96d6:	b0 12 7c 8e 	call	#36476		;#0x8e7c

000096da <.LVL221>:
    96da:	0c 93       	cmp	#0,	r12	;r3 As==00
    96dc:	23 21       	jnz	$+584    	;abs 0x9924

000096de <.Loc.1694.1>:
    96de:	0b 41       	mov	r1,	r11	;
    96e0:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000096e4 <.L127>:
    96e4:	b1 90 80 00 	cmp	#128,	14(r1)	;#0x0080, 0x000e
    96e8:	0e 00 
    96ea:	4a 20       	jnz	$+150    	;abs 0x9780

000096ec <.Loc.1698.1>:
    96ec:	1f 41 06 00 	mov	6(r1),	r15	;
    96f0:	0f 88       	sub	r8,	r15	;

000096f2 <.LVL223>:
    96f2:	4c 43       	clr.b	r12		;
    96f4:	0c 9f       	cmp	r15,	r12	;
    96f6:	44 34       	jge	$+138    	;abs 0x9780

000096f8 <.L130>:
    96f8:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    96fc:	1c 53       	inc	r12		;

000096fe <.Loc.1698.1>:
    96fe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9702:	bb 40 cc 50 	mov	#20684,	0(r11)	;#0x50cc
    9706:	00 00 
    9708:	0e 9f       	cmp	r15,	r14	;
    970a:	21 34       	jge	$+68     	;abs 0x974e

0000970c <.Loc.1698.1>:
    970c:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    9710:	02 00 
    9712:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9716:	18 00 

00009718 <.LVL224>:
    9718:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    971c:	7d 40 07 00 	mov.b	#7,	r13	;
    9720:	0d 9c       	cmp	r12,	r13	;
    9722:	02 38       	jl	$+6      	;abs 0x9728

00009724 <.Loc.1698.1>:
    9724:	2b 52       	add	#4,	r11	;r2 As==10

00009726 <.LVL225>:
    9726:	10 3c       	jmp	$+34     	;abs 0x9748

00009728 <.L131>:
    9728:	0e 41       	mov	r1,	r14	;
    972a:	3e 50 14 00 	add	#20,	r14	;#0x0014
    972e:	0d 4a       	mov	r10,	r13	;
    9730:	1c 41 02 00 	mov	2(r1),	r12	;
    9734:	81 4f 00 00 	mov	r15,	0(r1)	;
    9738:	b0 12 7c 8e 	call	#36476		;#0x8e7c

0000973c <.LVL227>:
    973c:	2f 41       	mov	@r1,	r15	;
    973e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9740:	f1 20       	jnz	$+484    	;abs 0x9924

00009742 <.Loc.1698.1>:
    9742:	0b 41       	mov	r1,	r11	;
    9744:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009748 <.L132>:
    9748:	3f 50 f0 ff 	add	#65520,	r15	;#0xfff0

0000974c <.LVL229>:
    974c:	d5 3f       	jmp	$-84     	;abs 0x96f8

0000974e <.L239>:
    974e:	8b 4f 02 00 	mov	r15,	2(r11)	;
    9752:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

00009756 <.LVL230>:
    9756:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    975a:	7f 40 07 00 	mov.b	#7,	r15	;

0000975e <.LVL231>:
    975e:	0f 9c       	cmp	r12,	r15	;
    9760:	02 38       	jl	$+6      	;abs 0x9766

00009762 <.Loc.1698.1>:
    9762:	2b 52       	add	#4,	r11	;r2 As==10

00009764 <.LVL232>:
    9764:	0d 3c       	jmp	$+28     	;abs 0x9780

00009766 <.L134>:
    9766:	0e 41       	mov	r1,	r14	;
    9768:	3e 50 14 00 	add	#20,	r14	;#0x0014
    976c:	0d 4a       	mov	r10,	r13	;
    976e:	1c 41 02 00 	mov	2(r1),	r12	;
    9772:	b0 12 7c 8e 	call	#36476		;#0x8e7c

00009776 <.LVL234>:
    9776:	0c 93       	cmp	#0,	r12	;r3 As==00
    9778:	d5 20       	jnz	$+428    	;abs 0x9924

0000977a <.Loc.1698.1>:
    977a:	0b 41       	mov	r1,	r11	;
    977c:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009780 <.L129>:
    9780:	09 86       	sub	r6,	r9	;

00009782 <.LVL236>:
    9782:	4c 43       	clr.b	r12		;
    9784:	0c 99       	cmp	r9,	r12	;
    9786:	41 34       	jge	$+132    	;abs 0x980a

00009788 <.L136>:
    9788:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    978c:	1c 53       	inc	r12		;

0000978e <.Loc.1701.1>:
    978e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9792:	bb 40 cc 50 	mov	#20684,	0(r11)	;#0x50cc
    9796:	00 00 
    9798:	0e 99       	cmp	r9,	r14	;
    979a:	1e 34       	jge	$+62     	;abs 0x97d8

0000979c <.Loc.1701.1>:
    979c:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    97a0:	02 00 
    97a2:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    97a6:	18 00 

000097a8 <.LVL237>:
    97a8:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    97ac:	7d 40 07 00 	mov.b	#7,	r13	;
    97b0:	0d 9c       	cmp	r12,	r13	;
    97b2:	02 38       	jl	$+6      	;abs 0x97b8

000097b4 <.Loc.1701.1>:
    97b4:	2b 52       	add	#4,	r11	;r2 As==10

000097b6 <.LVL238>:
    97b6:	0d 3c       	jmp	$+28     	;abs 0x97d2

000097b8 <.L137>:
    97b8:	0e 41       	mov	r1,	r14	;
    97ba:	3e 50 14 00 	add	#20,	r14	;#0x0014
    97be:	0d 4a       	mov	r10,	r13	;
    97c0:	1c 41 02 00 	mov	2(r1),	r12	;
    97c4:	b0 12 7c 8e 	call	#36476		;#0x8e7c

000097c8 <.LVL240>:
    97c8:	0c 93       	cmp	#0,	r12	;r3 As==00
    97ca:	ac 20       	jnz	$+346    	;abs 0x9924

000097cc <.Loc.1701.1>:
    97cc:	0b 41       	mov	r1,	r11	;
    97ce:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000097d2 <.L138>:
    97d2:	39 50 f0 ff 	add	#65520,	r9	;#0xfff0
    97d6:	d8 3f       	jmp	$-78     	;abs 0x9788

000097d8 <.L240>:
    97d8:	8b 49 02 00 	mov	r9,	2(r11)	;
    97dc:	81 59 18 00 	add	r9,	24(r1)	; 0x0018

000097e0 <.LVL243>:
    97e0:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    97e4:	7f 40 07 00 	mov.b	#7,	r15	;
    97e8:	0f 9c       	cmp	r12,	r15	;
    97ea:	02 38       	jl	$+6      	;abs 0x97f0

000097ec <.Loc.1701.1>:
    97ec:	2b 52       	add	#4,	r11	;r2 As==10

000097ee <.LVL244>:
    97ee:	0d 3c       	jmp	$+28     	;abs 0x980a

000097f0 <.L140>:
    97f0:	0e 41       	mov	r1,	r14	;
    97f2:	3e 50 14 00 	add	#20,	r14	;#0x0014
    97f6:	0d 4a       	mov	r10,	r13	;
    97f8:	1c 41 02 00 	mov	2(r1),	r12	;
    97fc:	b0 12 7c 8e 	call	#36476		;#0x8e7c

00009800 <.LVL246>:
    9800:	0c 93       	cmp	#0,	r12	;r3 As==00
    9802:	90 20       	jnz	$+290    	;abs 0x9924

00009804 <.Loc.1701.1>:
    9804:	0b 41       	mov	r1,	r11	;
    9806:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000980a <.L135>:
    980a:	8b 44 00 00 	mov	r4,	0(r11)	;
    980e:	8b 46 02 00 	mov	r6,	2(r11)	;
    9812:	81 56 18 00 	add	r6,	24(r1)	; 0x0018

00009816 <.LVL248>:
    9816:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    981a:	1c 53       	inc	r12		;
    981c:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9820:	74 40 07 00 	mov.b	#7,	r4	;

00009824 <.LVL249>:
    9824:	04 9c       	cmp	r12,	r4	;
    9826:	02 38       	jl	$+6      	;abs 0x982c
    9828:	2b 52       	add	#4,	r11	;r2 As==10

0000982a <.LVL250>:
    982a:	0d 3c       	jmp	$+28     	;abs 0x9846

0000982c <.L141>:
    982c:	0e 41       	mov	r1,	r14	;
    982e:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9832:	0d 4a       	mov	r10,	r13	;
    9834:	1c 41 02 00 	mov	2(r1),	r12	;
    9838:	b0 12 7c 8e 	call	#36476		;#0x8e7c

0000983c <.LVL252>:
    983c:	0c 93       	cmp	#0,	r12	;r3 As==00
    983e:	72 20       	jnz	$+230    	;abs 0x9924

00009840 <.Loc.1767.1>:
    9840:	0b 41       	mov	r1,	r11	;
    9842:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009846 <.L142>:
    9846:	25 b2       	bit	#4,	r5	;r2 As==10
    9848:	0b 20       	jnz	$+24     	;abs 0x9860

0000984a <.L147>:
    984a:	1f 41 06 00 	mov	6(r1),	r15	;
    984e:	0f 98       	cmp	r8,	r15	;
    9850:	01 34       	jge	$+4      	;abs 0x9854
    9852:	0f 48       	mov	r8,	r15	;

00009854 <.L144>:
    9854:	81 5f 08 00 	add	r15,	8(r1)	;

00009858 <.Loc.1776.1>:
    9858:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    985c:	50 24       	jz	$+162    	;abs 0x98fe
    985e:	45 3c       	jmp	$+140    	;abs 0x98ea

00009860 <.L143>:
    9860:	16 41 06 00 	mov	6(r1),	r6	;

00009864 <.LVL256>:
    9864:	06 88       	sub	r8,	r6	;

00009866 <.LVL257>:
    9866:	4c 43       	clr.b	r12		;
    9868:	0c 96       	cmp	r6,	r12	;
    986a:	ef 37       	jge	$-32     	;abs 0x984a

0000986c <.Loc.1771.1>:
    986c:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    9870:	35 40 7c 8e 	mov	#36476,	r5	;#0x8e7c

00009874 <.L148>:
    9874:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9878:	1c 53       	inc	r12		;
    987a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    987e:	bb 40 dc 50 	mov	#20700,	0(r11)	;#0x50dc
    9882:	00 00 
    9884:	0e 96       	cmp	r6,	r14	;
    9886:	1c 34       	jge	$+58     	;abs 0x98c0

00009888 <.Loc.1771.1>:
    9888:	8b 49 02 00 	mov	r9,	2(r11)	;
    988c:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9890:	18 00 
    9892:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9896:	7d 40 07 00 	mov.b	#7,	r13	;
    989a:	0d 9c       	cmp	r12,	r13	;
    989c:	02 38       	jl	$+6      	;abs 0x98a2

0000989e <.LVL259>:
    989e:	2b 52       	add	#4,	r11	;r2 As==10

000098a0 <.LVL260>:
    98a0:	0c 3c       	jmp	$+26     	;abs 0x98ba

000098a2 <.L149>:
    98a2:	0e 41       	mov	r1,	r14	;
    98a4:	3e 50 14 00 	add	#20,	r14	;#0x0014
    98a8:	0d 4a       	mov	r10,	r13	;
    98aa:	1c 41 02 00 	mov	2(r1),	r12	;
    98ae:	85 12       	call	r5		;

000098b0 <.LVL262>:
    98b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    98b2:	38 20       	jnz	$+114    	;abs 0x9924

000098b4 <.LVL263>:
    98b4:	0b 41       	mov	r1,	r11	;
    98b6:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000098ba <.L150>:
    98ba:	36 50 f0 ff 	add	#65520,	r6	;#0xfff0
    98be:	da 3f       	jmp	$-74     	;abs 0x9874

000098c0 <.L242>:
    98c0:	8b 46 02 00 	mov	r6,	2(r11)	;
    98c4:	81 56 18 00 	add	r6,	24(r1)	; 0x0018
    98c8:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    98cc:	7f 40 07 00 	mov.b	#7,	r15	;
    98d0:	0f 9c       	cmp	r12,	r15	;
    98d2:	bb 37       	jge	$-136    	;abs 0x984a

000098d4 <.Loc.1771.1>:
    98d4:	0e 41       	mov	r1,	r14	;
    98d6:	3e 50 14 00 	add	#20,	r14	;#0x0014
    98da:	0d 4a       	mov	r10,	r13	;
    98dc:	1c 41 02 00 	mov	2(r1),	r12	;
    98e0:	b0 12 7c 8e 	call	#36476		;#0x8e7c

000098e4 <.LVL266>:
    98e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    98e6:	b1 27       	jz	$-156    	;abs 0x984a
    98e8:	1d 3c       	jmp	$+60     	;abs 0x9924

000098ea <.L241>:
    98ea:	0e 41       	mov	r1,	r14	;
    98ec:	3e 50 14 00 	add	#20,	r14	;#0x0014
    98f0:	0d 4a       	mov	r10,	r13	;
    98f2:	1c 41 02 00 	mov	2(r1),	r12	;
    98f6:	b0 12 7c 8e 	call	#36476		;#0x8e7c

000098fa <.LVL268>:
    98fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    98fc:	13 20       	jnz	$+40     	;abs 0x9924

000098fe <.L146>:
    98fe:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00009902 <.LVL269>:
    9902:	09 47       	mov	r7,	r9	;
    9904:	0b 41       	mov	r1,	r11	;
    9906:	3b 50 1a 00 	add	#26,	r11	;#0x001a
    990a:	30 40 0c 90 	br	#0x900c		;

0000990e <.L34>:
    990e:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    9912:	08 24       	jz	$+18     	;abs 0x9924

00009914 <.Loc.1784.1>:
    9914:	0e 41       	mov	r1,	r14	;
    9916:	3e 50 14 00 	add	#20,	r14	;#0x0014
    991a:	0d 4a       	mov	r10,	r13	;
    991c:	1c 41 02 00 	mov	2(r1),	r12	;
    9920:	b0 12 7c 8e 	call	#36476		;#0x8e7c

00009924 <.L33>:
    9924:	fa b0 40 00 	bit.b	#64,	6(r10)	;#0x0040
    9928:	06 00 
    992a:	02 24       	jz	$+6      	;abs 0x9930
    992c:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

00009930 <.L22>:
    9930:	1c 41 08 00 	mov	8(r1),	r12	;
    9934:	31 50 62 00 	add	#98,	r1	;#0x0062

00009938 <L0>:
    9938:	64 17       	popm	#7,	r10	;16-bit words
    993a:	30 41       	ret			

0000993c <memchr>:
    993c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00009940 <.LVL2>:
    9940:	0e 5c       	add	r12,	r14	;

00009942 <.L2>:
    9942:	0c 9e       	cmp	r14,	r12	;
    9944:	05 24       	jz	$+12     	;abs 0x9950

00009946 <.Loc.128.1>:
    9946:	cc 9d 00 00 	cmp.b	r13,	0(r12)	;
    994a:	03 24       	jz	$+8      	;abs 0x9952

0000994c <.Loc.130.1>:
    994c:	1c 53       	inc	r12		;

0000994e <.LVL4>:
    994e:	f9 3f       	jmp	$-12     	;abs 0x9942

00009950 <.L7>:
    9950:	4c 43       	clr.b	r12		;

00009952 <.L1>:
    9952:	30 41       	ret			

00009954 <memmove>:
    9954:	0b 4c       	mov	r12,	r11	;

00009956 <L0>:
    9956:	0b 5e       	add	r14,	r11	;

00009958 <.Loc.69.1>:
    9958:	0d 9c       	cmp	r12,	r13	;
    995a:	02 28       	jnc	$+6      	;abs 0x9960

0000995c <.L4>:
    995c:	0e 4c       	mov	r12,	r14	;

0000995e <.LVL2>:
    995e:	0f 3c       	jmp	$+32     	;abs 0x997e

00009960 <.L2>:
    9960:	0f 4d       	mov	r13,	r15	;
    9962:	0f 5e       	add	r14,	r15	;
    9964:	0c 9f       	cmp	r15,	r12	;
    9966:	fa 2f       	jc	$-10     	;abs 0x995c

00009968 <.LVL4>:
    9968:	0d 4f       	mov	r15,	r13	;

0000996a <.LVL5>:
    996a:	0e 8f       	sub	r15,	r14	;

0000996c <.L5>:
    996c:	0f 4d       	mov	r13,	r15	;
    996e:	0f 5e       	add	r14,	r15	;
    9970:	0f 93       	cmp	#0,	r15	;r3 As==00
    9972:	0c 24       	jz	$+26     	;abs 0x998c

00009974 <.Loc.76.1>:
    9974:	3b 53       	add	#-1,	r11	;r3 As==11
    9976:	3d 53       	add	#-1,	r13	;r3 As==11

00009978 <.LVL8>:
    9978:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    997c:	f7 3f       	jmp	$-16     	;abs 0x996c

0000997e <.L3>:
    997e:	0b 9e       	cmp	r14,	r11	;
    9980:	05 24       	jz	$+12     	;abs 0x998c

00009982 <.LVL10>:
    9982:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    9986:	1e 53       	inc	r14		;

00009988 <.LVL11>:
    9988:	1d 53       	inc	r13		;
    998a:	f9 3f       	jmp	$-12     	;abs 0x997e

0000998c <.L9>:
    998c:	30 41       	ret			

0000998e <_free_r>:
    998e:	3a 15       	pushm	#4,	r10	;16-bit words

00009990 <.LCFI0>:
    9990:	0d 93       	cmp	#0,	r13	;r3 As==00
    9992:	70 24       	jz	$+226    	;abs 0x9a74

00009994 <L0>:
    9994:	0e 4d       	mov	r13,	r14	;
    9996:	3e 50 fc ff 	add	#65532,	r14	;#0xfffc

0000999a <.LVL2>:
    999a:	1f 4d fc ff 	mov	-4(r13),r15	;
    999e:	8d 93 fe ff 	cmp	#0,	-2(r13)	;r3 As==00, 0xfffe
    99a2:	01 34       	jge	$+4      	;abs 0x99a6
    99a4:	0e 5f       	add	r15,	r14	;

000099a6 <.L4>:
    99a6:	1d 42 66 5c 	mov	&0x5c66,r13	;0x5c66

000099aa <.LVL4>:
    99aa:	0d 93       	cmp	#0,	r13	;r3 As==00
    99ac:	16 24       	jz	$+46     	;abs 0x99da

000099ae <.Loc.357.1>:
    99ae:	0e 9d       	cmp	r13,	r14	;
    99b0:	1c 2c       	jc	$+58     	;abs 0x99ea

000099b2 <.Loc.359.1>:
    99b2:	2a 4e       	mov	@r14,	r10	;
    99b4:	1b 4e 02 00 	mov	2(r14),	r11	;
    99b8:	0c 4e       	mov	r14,	r12	;

000099ba <.LVL5>:
    99ba:	0c 5a       	add	r10,	r12	;
    99bc:	0d 9c       	cmp	r12,	r13	;
    99be:	0d 20       	jnz	$+28     	;abs 0x99da

000099c0 <.Loc.363.1>:
    99c0:	08 4a       	mov	r10,	r8	;
    99c2:	09 4b       	mov	r11,	r9	;
    99c4:	28 5d       	add	@r13,	r8	;
    99c6:	19 6d 02 00 	addc	2(r13),	r9	;
    99ca:	8e 48 00 00 	mov	r8,	0(r14)	;
    99ce:	8e 49 02 00 	mov	r9,	2(r14)	;

000099d2 <.Loc.364.1>:
    99d2:	9e 4d 04 00 	mov	4(r13),	4(r14)	;
    99d6:	04 00 
    99d8:	02 3c       	jmp	$+6      	;abs 0x99de

000099da <.L8>:
    99da:	8e 4d 04 00 	mov	r13,	4(r14)	;

000099de <.L9>:
    99de:	82 4e 66 5c 	mov	r14,	&0x5c66	;

000099e2 <.Loc.373.1>:
    99e2:	48 3c       	jmp	$+146    	;abs 0x9a74

000099e4 <.L21>:
    99e4:	0e 9f       	cmp	r15,	r14	;
    99e6:	05 28       	jnc	$+12     	;abs 0x99f2
    99e8:	0d 4f       	mov	r15,	r13	;

000099ea <.L11>:
    99ea:	1f 4d 04 00 	mov	4(r13),	r15	;

000099ee <.LVL8>:
    99ee:	0f 93       	cmp	#0,	r15	;r3 As==00
    99f0:	f9 23       	jnz	$-12     	;abs 0x99e4

000099f2 <.L10>:
    99f2:	29 4d       	mov	@r13,	r9	;
    99f4:	17 4d 02 00 	mov	2(r13),	r7	;
    99f8:	08 4d       	mov	r13,	r8	;
    99fa:	08 59       	add	r9,	r8	;
    99fc:	08 9e       	cmp	r14,	r8	;
    99fe:	1a 20       	jnz	$+54     	;abs 0x9a34

00009a00 <.Loc.391.1>:
    9a00:	2a 4e       	mov	@r14,	r10	;
    9a02:	0a 59       	add	r9,	r10	;
    9a04:	1b 4e 02 00 	mov	2(r14),	r11	;
    9a08:	0b 67       	addc	r7,	r11	;
    9a0a:	8d 4a 00 00 	mov	r10,	0(r13)	;
    9a0e:	8d 4b 02 00 	mov	r11,	2(r13)	;

00009a12 <.Loc.394.1>:
    9a12:	0c 4d       	mov	r13,	r12	;

00009a14 <.LVL9>:
    9a14:	0c 5a       	add	r10,	r12	;
    9a16:	0f 9c       	cmp	r12,	r15	;
    9a18:	2d 20       	jnz	$+92     	;abs 0x9a74

00009a1a <.Loc.396.1>:
    9a1a:	08 4a       	mov	r10,	r8	;
    9a1c:	09 4b       	mov	r11,	r9	;
    9a1e:	28 5f       	add	@r15,	r8	;
    9a20:	19 6f 02 00 	addc	2(r15),	r9	;
    9a24:	8d 48 00 00 	mov	r8,	0(r13)	;
    9a28:	8d 49 02 00 	mov	r9,	2(r13)	;

00009a2c <.Loc.397.1>:
    9a2c:	9d 4f 04 00 	mov	4(r15),	4(r13)	;
    9a30:	04 00 
    9a32:	20 3c       	jmp	$+66     	;abs 0x9a74

00009a34 <.L12>:
    9a34:	0e 98       	cmp	r8,	r14	;
    9a36:	04 2c       	jc	$+10     	;abs 0x9a40

00009a38 <.Loc.404.1>:
    9a38:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    9a3c:	00 00 

00009a3e <.Loc.406.1>:
    9a3e:	1a 3c       	jmp	$+54     	;abs 0x9a74

00009a40 <.L14>:
    9a40:	2a 4e       	mov	@r14,	r10	;
    9a42:	1b 4e 02 00 	mov	2(r14),	r11	;
    9a46:	0c 4e       	mov	r14,	r12	;

00009a48 <.LVL11>:
    9a48:	0c 5a       	add	r10,	r12	;
    9a4a:	0f 9c       	cmp	r12,	r15	;
    9a4c:	0f 20       	jnz	$+32     	;abs 0x9a6c

00009a4e <.Loc.413.1>:
    9a4e:	08 4a       	mov	r10,	r8	;
    9a50:	09 4b       	mov	r11,	r9	;
    9a52:	28 5f       	add	@r15,	r8	;
    9a54:	19 6f 02 00 	addc	2(r15),	r9	;
    9a58:	8e 48 00 00 	mov	r8,	0(r14)	;
    9a5c:	8e 49 02 00 	mov	r9,	2(r14)	;

00009a60 <.Loc.414.1>:
    9a60:	9e 4f 04 00 	mov	4(r15),	4(r14)	;
    9a64:	04 00 

00009a66 <.Loc.415.1>:
    9a66:	8d 4e 04 00 	mov	r14,	4(r13)	;
    9a6a:	04 3c       	jmp	$+10     	;abs 0x9a74

00009a6c <.L15>:
    9a6c:	8e 4f 04 00 	mov	r15,	4(r14)	;

00009a70 <.Loc.422.1>:
    9a70:	8d 4e 04 00 	mov	r14,	4(r13)	;

00009a74 <.L1>:
    9a74:	37 17       	popm	#4,	r10	;16-bit words
    9a76:	30 41       	ret			

00009a78 <_malloc_r>:
    9a78:	3a 15       	pushm	#4,	r10	;16-bit words

00009a7a <.LCFI0>:
    9a7a:	08 4c       	mov	r12,	r8	;

00009a7c <.Loc.247.1>:
    9a7c:	09 4d       	mov	r13,	r9	;
    9a7e:	19 53       	inc	r9		;
    9a80:	19 c3       	bic	#1,	r9	;r3 As==01

00009a82 <L0>:
    9a82:	39 50 0a 00 	add	#10,	r9	;#0x000a

00009a86 <.LVL2>:
    9a86:	39 90 0c 00 	cmp	#12,	r9	;#0x000c
    9a8a:	02 2c       	jc	$+6      	;abs 0x9a90
    9a8c:	79 40 0c 00 	mov.b	#12,	r9	;#0x000c

00009a90 <.L2>:
    9a90:	09 9d       	cmp	r13,	r9	;
    9a92:	05 2c       	jc	$+12     	;abs 0x9a9e

00009a94 <.L13>:
    9a94:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    9a98:	00 00 

00009a9a <.Loc.255.1>:
    9a9a:	4c 43       	clr.b	r12		;
    9a9c:	60 3c       	jmp	$+194    	;abs 0x9b5e

00009a9e <.L3>:
    9a9e:	1e 42 66 5c 	mov	&0x5c66,r14	;0x5c66

00009aa2 <.LVL6>:
    9aa2:	0d 4e       	mov	r14,	r13	;

00009aa4 <.L5>:
    9aa4:	0d 93       	cmp	#0,	r13	;r3 As==00
    9aa6:	28 24       	jz	$+82     	;abs 0x9af8

00009aa8 <.LBB5>:
    9aa8:	2c 4d       	mov	@r13,	r12	;
    9aaa:	0c 89       	sub	r9,	r12	;

00009aac <.LVL8>:
    9aac:	0c 93       	cmp	#0,	r12	;r3 As==00
    9aae:	20 38       	jl	$+66     	;abs 0x9af0

00009ab0 <.Loc.268.1>:
    9ab0:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    9ab4:	0f 9c       	cmp	r12,	r15	;
    9ab6:	11 2c       	jc	$+36     	;abs 0x9ada

00009ab8 <.Loc.272.1>:
    9ab8:	0e 4c       	mov	r12,	r14	;
    9aba:	0f 4c       	mov	r12,	r15	;
    9abc:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

00009ac0 <.LVL9>:
    9ac0:	8d 4e 00 00 	mov	r14,	0(r13)	;
    9ac4:	8d 4f 02 00 	mov	r15,	2(r13)	;

00009ac8 <.Loc.273.1>:
    9ac8:	0e 4d       	mov	r13,	r14	;
    9aca:	0e 5c       	add	r12,	r14	;

00009acc <.LVL10>:
    9acc:	0c 49       	mov	r9,	r12	;
    9ace:	0d 43       	clr	r13		;

00009ad0 <.LVL11>:
    9ad0:	8e 4c 00 00 	mov	r12,	0(r14)	;
    9ad4:	8e 4d 02 00 	mov	r13,	2(r14)	;
    9ad8:	2a 3c       	jmp	$+86     	;abs 0x9b2e

00009ada <.L7>:
    9ada:	0e 9d       	cmp	r13,	r14	;
    9adc:	04 20       	jnz	$+10     	;abs 0x9ae6

00009ade <.Loc.282.1>:
    9ade:	92 4e 04 00 	mov	4(r14),	&0x5c66	;
    9ae2:	66 5c 
    9ae4:	24 3c       	jmp	$+74     	;abs 0x9b2e

00009ae6 <.L9>:
    9ae6:	9e 4d 04 00 	mov	4(r13),	4(r14)	;
    9aea:	04 00 
    9aec:	0e 4d       	mov	r13,	r14	;

00009aee <.LVL13>:
    9aee:	1f 3c       	jmp	$+64     	;abs 0x9b2e

00009af0 <.L6>:
    9af0:	0e 4d       	mov	r13,	r14	;
    9af2:	1d 4d 04 00 	mov	4(r13),	r13	;

00009af6 <.LVL15>:
    9af6:	d6 3f       	jmp	$-82     	;abs 0x9aa4

00009af8 <.L24>:
    9af8:	37 40 b4 9b 	mov	#39860,	r7	;#0x9bb4

00009afc <.LBB6>:
    9afc:	82 93 64 5c 	cmp	#0,	&0x5c64	;r3 As==00
    9b00:	04 20       	jnz	$+10     	;abs 0x9b0a
    9b02:	0c 48       	mov	r8,	r12	;
    9b04:	87 12       	call	r7		;

00009b06 <.LVL17>:
    9b06:	82 4c 64 5c 	mov	r12,	&0x5c64	;

00009b0a <.L17>:
    9b0a:	0d 49       	mov	r9,	r13	;
    9b0c:	0c 48       	mov	r8,	r12	;
    9b0e:	87 12       	call	r7		;

00009b10 <.LVL18>:
    9b10:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9b12:	c0 27       	jz	$-126    	;abs 0x9a94

00009b14 <.Loc.222.1>:
    9b14:	0e 4c       	mov	r12,	r14	;
    9b16:	1e 53       	inc	r14		;
    9b18:	0a 4e       	mov	r14,	r10	;
    9b1a:	1a c3       	bic	#1,	r10	;r3 As==01

00009b1c <.LVL19>:
    9b1c:	0c 9a       	cmp	r10,	r12	;
    9b1e:	18 20       	jnz	$+50     	;abs 0x9b50

00009b20 <.L14>:
    9b20:	0d 49       	mov	r9,	r13	;
    9b22:	0e 43       	clr	r14		;
    9b24:	8a 4d 00 00 	mov	r13,	0(r10)	;
    9b28:	8a 4e 02 00 	mov	r14,	2(r10)	;
    9b2c:	0e 4a       	mov	r10,	r14	;

00009b2e <.L8>:
    9b2e:	0f 4e       	mov	r14,	r15	;
    9b30:	2f 52       	add	#4,	r15	;r2 As==10

00009b32 <.LVL22>:
    9b32:	0c 4f       	mov	r15,	r12	;
    9b34:	3c 50 07 00 	add	#7,	r12	;
    9b38:	3c f0 f8 ff 	and	#65528,	r12	;#0xfff8

00009b3c <.LVL23>:
    9b3c:	0d 4c       	mov	r12,	r13	;
    9b3e:	0d 8f       	sub	r15,	r13	;

00009b40 <.LVL24>:
    9b40:	0d 93       	cmp	#0,	r13	;r3 As==00
    9b42:	0d 24       	jz	$+28     	;abs 0x9b5e

00009b44 <.Loc.318.1>:
    9b44:	0e 5d       	add	r13,	r14	;

00009b46 <.LVL25>:
    9b46:	4f 43       	clr.b	r15		;

00009b48 <.LVL26>:
    9b48:	0f 8d       	sub	r13,	r15	;
    9b4a:	8e 4f 00 00 	mov	r15,	0(r14)	;
    9b4e:	07 3c       	jmp	$+16     	;abs 0x9b5e

00009b50 <.L25>:
    9b50:	0d 4a       	mov	r10,	r13	;
    9b52:	0d 8c       	sub	r12,	r13	;
    9b54:	0c 48       	mov	r8,	r12	;

00009b56 <.LVL28>:
    9b56:	87 12       	call	r7		;

00009b58 <.LVL29>:
    9b58:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9b5a:	e2 23       	jnz	$-58     	;abs 0x9b20
    9b5c:	9b 3f       	jmp	$-200    	;abs 0x9a94

00009b5e <.L1>:
    9b5e:	37 17       	popm	#4,	r10	;16-bit words
    9b60:	30 41       	ret			

00009b62 <_realloc_r>:
    9b62:	3a 15       	pushm	#4,	r10	;16-bit words

00009b64 <.LCFI0>:
    9b64:	07 4c       	mov	r12,	r7	;
    9b66:	08 4d       	mov	r13,	r8	;
    9b68:	0a 4e       	mov	r14,	r10	;

00009b6a <.Loc.454.1>:
    9b6a:	0d 93       	cmp	#0,	r13	;r3 As==00
    9b6c:	05 20       	jnz	$+12     	;abs 0x9b78

00009b6e <.Loc.454.1>:
    9b6e:	0d 4e       	mov	r14,	r13	;

00009b70 <L0>:
    9b70:	b0 12 78 9a 	call	#39544		;#0x9a78

00009b74 <.LVL2>:
    9b74:	09 4c       	mov	r12,	r9	;
    9b76:	1b 3c       	jmp	$+56     	;abs 0x9bae

00009b78 <.L2>:
    9b78:	0e 93       	cmp	#0,	r14	;r3 As==00
    9b7a:	04 20       	jnz	$+10     	;abs 0x9b84

00009b7c <.Loc.458.1>:
    9b7c:	b0 12 8e 99 	call	#39310		;#0x998e

00009b80 <.LVL3>:
    9b80:	09 4a       	mov	r10,	r9	;
    9b82:	15 3c       	jmp	$+44     	;abs 0x9bae

00009b84 <.L4>:
    9b84:	b0 12 d6 9b 	call	#39894		;#0x9bd6

00009b88 <.LVL4>:
    9b88:	0c 9a       	cmp	r10,	r12	;
    9b8a:	10 2c       	jc	$+34     	;abs 0x9bac

00009b8c <.Loc.467.1>:
    9b8c:	0d 4a       	mov	r10,	r13	;
    9b8e:	0c 47       	mov	r7,	r12	;
    9b90:	b0 12 78 9a 	call	#39544		;#0x9a78

00009b94 <.LVL5>:
    9b94:	09 4c       	mov	r12,	r9	;

00009b96 <.LVL6>:
    9b96:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b98:	0a 24       	jz	$+22     	;abs 0x9bae

00009b9a <.Loc.470.1>:
    9b9a:	0e 4a       	mov	r10,	r14	;
    9b9c:	0d 48       	mov	r8,	r13	;
    9b9e:	b0 12 ec 8d 	call	#36332		;#0x8dec

00009ba2 <.LVL7>:
    9ba2:	0d 48       	mov	r8,	r13	;
    9ba4:	0c 47       	mov	r7,	r12	;
    9ba6:	b0 12 8e 99 	call	#39310		;#0x998e

00009baa <.LVL8>:
    9baa:	01 3c       	jmp	$+4      	;abs 0x9bae

00009bac <.L5>:
    9bac:	09 48       	mov	r8,	r9	;

00009bae <.L1>:
    9bae:	0c 49       	mov	r9,	r12	;
    9bb0:	37 17       	popm	#4,	r10	;16-bit words
    9bb2:	30 41       	ret			

00009bb4 <_sbrk_r>:
    9bb4:	0a 15       	pushm	#1,	r10	;16-bit words

00009bb6 <.LCFI0>:
    9bb6:	0a 4c       	mov	r12,	r10	;

00009bb8 <.Loc.57.1>:
    9bb8:	82 43 68 5c 	Address 0x0000000000009bba is out of bounds.
mov	#0,	&0xffff	;r3 As==00

00009bba <L0>:
    9bba:	68 5c       	add.b	@r12,	r8	;

00009bbc <.Loc.58.1>:
    9bbc:	0c 4d       	mov	r13,	r12	;

00009bbe <.LVL1>:
    9bbe:	b0 12 ea 9b 	call	#39914		;#0x9bea

00009bc2 <.LVL2>:
    9bc2:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9bc4:	06 20       	jnz	$+14     	;abs 0x9bd2

00009bc6 <.Loc.58.1>:
    9bc6:	1d 42 68 5c 	mov	&0x5c68,r13	;0x5c68
    9bca:	0d 93       	cmp	#0,	r13	;r3 As==00
    9bcc:	02 24       	jz	$+6      	;abs 0x9bd2

00009bce <.Loc.59.1>:
    9bce:	8a 4d 00 00 	mov	r13,	0(r10)	;

00009bd2 <.L2>:
    9bd2:	0a 17       	popm	#1,	r10	;16-bit words
    9bd4:	30 41       	ret			

00009bd6 <_malloc_usable_size_r>:
    9bd6:	1e 4d fc ff 	mov	-4(r13),r14	;
    9bda:	0c 4e       	mov	r14,	r12	;

00009bdc <.LVL3>:
    9bdc:	3c 50 fc ff 	add	#65532,	r12	;#0xfffc

00009be0 <.Loc.530.1>:
    9be0:	0e 93       	cmp	#0,	r14	;r3 As==00
    9be2:	02 34       	jge	$+6      	;abs 0x9be8

00009be4 <.LVL4>:
    9be4:	0d 5c       	add	r12,	r13	;

00009be6 <.LVL5>:
    9be6:	2c 5d       	add	@r13,	r12	;

00009be8 <.L1>:
    9be8:	30 41       	ret			

00009bea <_sbrk>:
    9bea:	21 83       	decd	r1		;

00009bec <.LCFI0>:
    9bec:	1d 42 fc 51 	mov	&0x51fc,r13	;0x51fc

00009bf0 <.LVL1>:
    9bf0:	4e 43       	clr.b	r14		;
    9bf2:	0e 51       	add	r1,	r14	;
    9bf4:	81 4e 00 00 	mov	r14,	0(r1)	;

00009bf8 <.Loc.22.1>:
    9bf8:	0c 5d       	add	r13,	r12	;

00009bfa <.LVL2>:
    9bfa:	01 9c       	cmp	r12,	r1	;
    9bfc:	05 28       	jnc	$+12     	;abs 0x9c08

00009bfe <.Loc.29.1>:
    9bfe:	82 4c fc 51 	mov	r12,	&0x51fc	;

00009c02 <.Loc.31.1>:
    9c02:	0c 4d       	mov	r13,	r12	;
    9c04:	21 53       	incd	r1		;
    9c06:	30 41       	ret			

00009c08 <.L4>:
    9c08:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    9c0c:	3d 40 ee 50 	mov	#20718,	r13	;#0x50ee

00009c10 <.LVL4>:
    9c10:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9c12:	b0 12 1a 9c 	call	#39962		;#0x9c1a

00009c16 <.LVL5>:
    9c16:	b0 12 ac 9c 	call	#40108		;#0x9cac

00009c1a <write>:
    9c1a:	6a 15       	pushm	#7,	r10	;16-bit words

00009c1c <.LCFI0>:
    9c1c:	21 82       	sub	#4,	r1	;r2 As==10

00009c1e <.LCFI1>:
    9c1e:	07 4d       	mov	r13,	r7	;
    9c20:	09 4e       	mov	r14,	r9	;

00009c22 <.Loc.48.1>:
    9c22:	4d 43       	clr.b	r13		;

00009c24 <.LVL2>:
    9c24:	0d 9e       	cmp	r14,	r13	;
    9c26:	3e 34       	jge	$+126    	;abs 0x9ca4
    9c28:	4d 4c       	mov.b	r12,	r13	;
    9c2a:	81 4d 02 00 	mov	r13,	2(r1)	;
    9c2e:	5c 0f       	rrum	#4,	r12	;
    9c30:	5c 0f       	rrum	#4,	r12	;

00009c32 <.LVL3>:
    9c32:	81 4c 00 00 	mov	r12,	0(r1)	;
    9c36:	34 40 fe 51 	mov	#20990,	r4	;#0x51fe
    9c3a:	35 40 ec 8d 	mov	#36332,	r5	;#0x8dec
    9c3e:	36 40 a8 9c 	mov	#40104,	r6	;#0x9ca8

00009c42 <.LBB5>:
    9c42:	48 43       	clr.b	r8		;

00009c44 <.Loc.28.1>:
    9c44:	09 47       	mov	r7,	r9	;
    9c46:	07 4e       	mov	r14,	r7	;

00009c48 <.L4>:
    9c48:	0a 47       	mov	r7,	r10	;
    9c4a:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    9c4e:	0c 97       	cmp	r7,	r12	;
    9c50:	01 34       	jge	$+4      	;abs 0x9c54
    9c52:	0a 4c       	mov	r12,	r10	;

00009c54 <.L3>:
    9c54:	4c 4a       	mov.b	r10,	r12	;
    9c56:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

00009c5a <.Loc.22.1>:
    9c5a:	c2 48 ff 51 	mov.b	r8,	&0x51ff	;

00009c5e <.Loc.23.1>:
    9c5e:	f2 40 f3 ff 	mov.b	#65523,	&0x5200	;#0xfff3
    9c62:	00 52 

00009c64 <.Loc.24.1>:
    9c64:	1d 41 02 00 	mov	2(r1),	r13	;
    9c68:	c4 4d 03 00 	mov.b	r13,	3(r4)	;

00009c6c <.Loc.25.1>:
    9c6c:	2d 41       	mov	@r1,	r13	;
    9c6e:	c4 4d 04 00 	mov.b	r13,	4(r4)	;

00009c72 <.Loc.26.1>:
    9c72:	c4 4c 05 00 	mov.b	r12,	5(r4)	;

00009c76 <.Loc.27.1>:
    9c76:	c2 48 04 52 	mov.b	r8,	&0x5204	;

00009c7a <.Loc.28.1>:
    9c7a:	0e 4a       	mov	r10,	r14	;
    9c7c:	0d 49       	mov	r9,	r13	;
    9c7e:	3c 40 09 52 	mov	#21001,	r12	;#0x5209
    9c82:	85 12       	call	r5		;

00009c84 <.LVL6>:
    9c84:	86 12       	call	r6		;

00009c86 <.LBE10>:
    9c86:	07 8a       	sub	r10,	r7	;

00009c88 <.Loc.56.1>:
    9c88:	09 5a       	add	r10,	r9	;

00009c8a <.LBE5>:
    9c8a:	4c 43       	clr.b	r12		;
    9c8c:	0c 97       	cmp	r7,	r12	;
    9c8e:	dc 3b       	jl	$-70     	;abs 0x9c48

00009c90 <.LBB11>:
    9c90:	5c 44 03 00 	mov.b	3(r4),	r12	;
    9c94:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    9c98:	54 44 02 00 	mov.b	2(r4),	r4	;
    9c9c:	0c 54       	add	r4,	r12	;

00009c9e <.L1>:
    9c9e:	21 52       	add	#4,	r1	;r2 As==10
    9ca0:	64 17       	popm	#7,	r10	;16-bit words
    9ca2:	30 41       	ret			

00009ca4 <.L5>:
    9ca4:	4c 43       	clr.b	r12		;

00009ca6 <.LVL12>:
    9ca6:	fb 3f       	jmp	$-8      	;abs 0x9c9e

00009ca8 <C$$IO$$>:
    9ca8:	03 43       	nop			

00009caa <L0>:
    9caa:	30 41       	ret			

00009cac <abort>:
    9cac:	7c 40 06 00 	mov.b	#6,	r12	;
    9cb0:	b0 12 2c 9d 	call	#40236		;#0x9d2c

00009cb4 <.LVL0>:
    9cb4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9cb6:	b0 12 62 9d 	call	#40290		;#0x9d62

00009cba <memset>:
    9cba:	0f 4c       	mov	r12,	r15	;
    9cbc:	0e 5c       	add	r12,	r14	;

00009cbe <.L2>:
    9cbe:	0f 9e       	cmp	r14,	r15	;
    9cc0:	04 24       	jz	$+10     	;abs 0x9cca

00009cc2 <.LVL3>:
    9cc2:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    9cc6:	1f 53       	inc	r15		;

00009cc8 <.LVL4>:
    9cc8:	fa 3f       	jmp	$-10     	;abs 0x9cbe

00009cca <.L5>:
    9cca:	30 41       	ret			

00009ccc <_raise_r>:
    9ccc:	1a 15       	pushm	#2,	r10	;16-bit words

00009cce <L0>:
    9cce:	09 4c       	mov	r12,	r9	;
    9cd0:	0a 4d       	mov	r13,	r10	;

00009cd2 <.Loc.151.1>:
    9cd2:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

00009cd6 <.LVL16>:
    9cd6:	0c 9d       	cmp	r13,	r12	;
    9cd8:	05 2c       	jc	$+12     	;abs 0x9ce4

00009cda <.Loc.153.1>:
    9cda:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    9cde:	00 00 

00009ce0 <.Loc.154.1>:
    9ce0:	3c 43       	mov	#-1,	r12	;r3 As==11
    9ce2:	22 3c       	jmp	$+70     	;abs 0x9d28

00009ce4 <.L18>:
    9ce4:	1c 49 22 00 	mov	34(r9),	r12	;0x00022
    9ce8:	0c 93       	cmp	#0,	r12	;r3 As==00
    9cea:	05 24       	jz	$+12     	;abs 0x9cf6

00009cec <.Loc.160.1>:
    9cec:	0d 5d       	rla	r13		;

00009cee <.LVL17>:
    9cee:	0c 5d       	add	r13,	r12	;
    9cf0:	2d 4c       	mov	@r12,	r13	;

00009cf2 <.LVL18>:
    9cf2:	0d 93       	cmp	#0,	r13	;r3 As==00
    9cf4:	09 20       	jnz	$+20     	;abs 0x9d08

00009cf6 <.L20>:
    9cf6:	0c 49       	mov	r9,	r12	;
    9cf8:	b0 12 5c 9d 	call	#40284		;#0x9d5c

00009cfc <.LVL20>:
    9cfc:	0e 4a       	mov	r10,	r14	;
    9cfe:	0d 4c       	mov	r12,	r13	;
    9d00:	0c 49       	mov	r9,	r12	;
    9d02:	b0 12 38 9d 	call	#40248		;#0x9d38

00009d06 <.LVL21>:
    9d06:	10 3c       	jmp	$+34     	;abs 0x9d28

00009d08 <.L21>:
    9d08:	1d 93       	cmp	#1,	r13	;r3 As==01
    9d0a:	0d 24       	jz	$+28     	;abs 0x9d26

00009d0c <.Loc.166.1>:
    9d0c:	3d 93       	cmp	#-1,	r13	;r3 As==11
    9d0e:	05 20       	jnz	$+12     	;abs 0x9d1a

00009d10 <.Loc.168.1>:
    9d10:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    9d14:	00 00 

00009d16 <.Loc.169.1>:
    9d16:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9d18:	07 3c       	jmp	$+16     	;abs 0x9d28

00009d1a <.L22>:
    9d1a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00009d1e <.Loc.174.1>:
    9d1e:	0c 4a       	mov	r10,	r12	;
    9d20:	8d 12       	call	r13		;

00009d22 <.LVL23>:
    9d22:	4c 43       	clr.b	r12		;
    9d24:	01 3c       	jmp	$+4      	;abs 0x9d28

00009d26 <.L23>:
    9d26:	4c 43       	clr.b	r12		;

00009d28 <.L17>:
    9d28:	19 17       	popm	#2,	r10	;16-bit words
    9d2a:	30 41       	ret			

00009d2c <raise>:
    9d2c:	0d 4c       	mov	r12,	r13	;
    9d2e:	1c 42 82 51 	mov	&0x5182,r12	;0x5182

00009d32 <.LVL37>:
    9d32:	b0 12 cc 9c 	Address 0x0000000000009d34 is out of bounds.
call	#65535		;#0xffff

00009d34 <L0>:
    9d34:	cc 9c 30 41 	Address 0x0000000000009d36 is out of bounds.
cmp.b	r12,	-1(r12)	; 0xffff

00009d36 <.LVL38>:
    9d36:	30 41       	ret			

00009d38 <_kill_r>:
    9d38:	0a 15       	pushm	#1,	r10	;16-bit words

00009d3a <.LCFI0>:
    9d3a:	0a 4c       	mov	r12,	r10	;
    9d3c:	0c 4d       	mov	r13,	r12	;

00009d3e <.LVL1>:
    9d3e:	82 43 68 5c 	mov	#0,	&0x5c68	;r3 As==00

00009d42 <.Loc.61.1>:
    9d42:	0d 4e       	mov	r14,	r13	;

00009d44 <.LVL2>:
    9d44:	b0 12 6a 9d 	call	#40298		;#0x9d6a

00009d48 <.LVL3>:
    9d48:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9d4a:	06 20       	jnz	$+14     	;abs 0x9d58

00009d4c <.Loc.61.1>:
    9d4c:	1d 42 68 5c 	mov	&0x5c68,r13	;0x5c68
    9d50:	0d 93       	cmp	#0,	r13	;r3 As==00
    9d52:	02 24       	jz	$+6      	;abs 0x9d58

00009d54 <.Loc.62.1>:
    9d54:	8a 4d 00 00 	mov	r13,	0(r10)	;

00009d58 <.L1>:
    9d58:	0a 17       	popm	#1,	r10	;16-bit words
    9d5a:	30 41       	ret			

00009d5c <_getpid_r>:
    9d5c:	b0 12 64 9d 	call	#40292		;#0x9d64

00009d60 <.LVL5>:
    9d60:	30 41       	ret			

00009d62 <_exit>:
    9d62:	ff 3f       	jmp	$+0      	;abs 0x9d62

00009d64 <getpid>:
    9d64:	3c 40 2a 00 	Address 0x0000000000009d66 is out of bounds.
mov	#65535,	r12	;#0xffff

00009d66 <L0>:
    9d66:	2a 00 30 41 	Address 0x0000000000009d68 is out of bounds.
mova	&65535,	r10	;0x0ffff

00009d68 <.Loc.65.1>:
    9d68:	30 41       	ret			

00009d6a <kill>:
    9d6a:	b0 12 78 9d 	call	#40312		;#0x9d78
    9d6e:	bc 40 58 00 	mov	#88,	0(r12)	;#0x0058
    9d72:	00 00 
    9d74:	3c 43       	mov	#-1,	r12	;r3 As==11
    9d76:	30 41       	ret			

00009d78 <__errno>:
    9d78:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    9d7c:	30 41       	ret			
