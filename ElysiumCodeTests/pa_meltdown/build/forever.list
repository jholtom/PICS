
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	34 75       	subc	@r5+,	r4	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	36 75       	subc	@r5+,	r6	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	38 75       	subc	@r5+,	r8	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	3a 75       	subc	@r5+,	r10	;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	3c 75       	subc	@r5+,	r12	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	3e 75       	subc	@r5+,	r14	;

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	40 75       	subc.b	r5,	r0	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	42 75       	subc.b	r5,	r2	;

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	44 75       	subc.b	r5,	r4	;

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	46 75       	subc.b	r5,	r6	;

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	48 75       	subc.b	r5,	r8	;

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	4a 75       	subc.b	r5,	r10	;

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	4c 75       	subc.b	r5,	r12	;

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	4e 75       	subc.b	r5,	r14	;

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	50 75       	subc.b,		r0	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	52 75       	subc.b,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	54 75       	subc.b,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	56 75       	subc.b,		r6	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	58 75       	subc.b,		r8	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	5a 75       	subc.b,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	5c 75       	subc.b,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	5e 75       	subc.b,		r14	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	60 75       	subc.b	@r5,	r0	;

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	62 75       	subc.b	@r5,	r2	;

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	64 75       	subc.b	@r5,	r4	;

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	66 75       	subc.b	@r5,	r6	;

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	68 75       	subc.b	@r5,	r8	;

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	6a 75       	subc.b	@r5,	r10	;

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	6c 75       	subc.b	@r5,	r12	;

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	6e 75       	subc.b	@r5,	r14	;

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	70 75       	subc.b	@r5+,	r0	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	72 75       	subc.b	@r5+,	r2	;

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	38 5f       	add	@r15+,	r8	;

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	f0 5e 00 00 	add.b	@r14+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	74 75       	subc.b	@r5+,	r4	;

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	76 75       	subc.b	@r5+,	r6	;

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	aa 5e       	add	@r14		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	78 75       	subc.b	@r5+,	r8	;

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	7a 75       	subc.b	@r5+,	r10	;

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	66 5e       	add.b	@r14,	r6	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	7c 75       	interrupt service routine at 0x757c

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	7e 75       	interrupt service routine at 0x757e

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	80 5f       	interrupt service routine at 0x5f80

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	6e 5d       	interrupt service routine at 0x5d6e

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	80 75       	interrupt service routine at 0x7580

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	82 75       	interrupt service routine at 0x7582

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	f0 5f       	interrupt service routine at 0x5ff0

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	84 75       	interrupt service routine at 0x7584

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	86 75       	interrupt service routine at 0x7586

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	88 75       	interrupt service routine at 0x7588

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	38 5d       	interrupt service routine at 0x5d38

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	8a 75       	interrupt service routine at 0x758a

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	8c 75       	interrupt service routine at 0x758c

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	8e 75       	interrupt service routine at 0x758e

Disassembly of section .text:

00005d0c <__crt0_start>:
    5d0c:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00005d10 <__crt0_init_bss>:
    5d10:	3c 40 d8 5c 	mov	#23768,	r12	;#0x5cd8

00005d14 <.Loc.74.1>:
    5d14:	0d 43       	clr	r13		;

00005d16 <.Loc.75.1>:
    5d16:	3e 40 34 00 	mov	#52,	r14	;#0x0034

00005d1a <.Loc.79.1>:
    5d1a:	b0 12 6e 8c 	call	#-29586	;#0x8c6e

00005d1e <__crt0_movedata>:
    5d1e:	3c 40 cc 51 	mov	#20940,	r12	;#0x51cc

00005d22 <.Loc.116.1>:
    5d22:	3d 40 cc 51 	mov	#20940,	r13	;#0x51cc

00005d26 <.Loc.119.1>:
    5d26:	0d 9c       	cmp	r12,	r13	;

00005d28 <.Loc.120.1>:
    5d28:	04 24       	jz	$+10     	;abs 0x5d32

00005d2a <.Loc.122.1>:
    5d2a:	3e 40 0c 0b 	mov	#2828,	r14	;#0x0b0c

00005d2e <.Loc.124.1>:
    5d2e:	b0 12 d6 88 	call	#-30506	;#0x88d6

00005d32 <__crt0_call_just_main>:
    5d32:	0c 43       	clr	r12		;

00005d34 <.Loc.181.1>:
    5d34:	b0 12 0a 79 	call	#30986		;#0x790a

00005d38 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    5d38:	bf 15       	pushm	#12,	r15	;16-bit words

00005d3a <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    5d3a:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5d3e:	b0 12 6e 61 	call	#24942		;#0x616e

00005d42 <.LBB12>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    5d42:	b0 12 2e 61 	call	#24878		;#0x612e

00005d46 <.LBB14>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    5d46:	b0 12 c2 62 	call	#25282		;#0x62c2

00005d4a <.LBB16>:
  chSysUnlockFromISR();
    5d4a:	b0 12 4e 61 	call	#24910		;#0x614e

00005d4e <.LBE16>:
  
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();
  
  OSAL_IRQ_EPILOGUE();
    5d4e:	b0 12 94 61 	call	#24980		;#0x6194

00005d52 <.LVL4>:
    5d52:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5d56:	b0 12 f0 60 	call	#24816		;#0x60f0

00005d5a <.LVL5>:
    5d5a:	b0 12 84 63 	call	#25476		;#0x6384

00005d5e <.LVL6>:
    5d5e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5d60:	02 24       	jz	$+6      	;abs 0x5d66

00005d62 <.Loc.174.1>:
    5d62:	b0 12 9c 63 	call	#25500		;#0x639c

00005d66 <.L2>:
    5d66:	b0 12 0e 61 	call	#24846		;#0x610e

00005d6a <.LVL8>:
}
    5d6a:	b4 17       	popm	#12,	r15	;16-bit words
    5d6c:	00 13       	reti			

00005d6e <ISR_USCI_A1_VECTOR>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    5d6e:	bf 15       	pushm	#12,	r15	;16-bit words

00005d70 <.LCFI1>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    5d70:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5d74:	b0 12 6e 61 	call	#24942		;#0x616e

00005d78 <.LVL77>:

  switch (__even_in_range(UCA1IV, USCI_UART_UCTXCPTIFG)) {
    5d78:	1c 42 fe 05 	mov	&0x05fe,r12	;0x05fe
    5d7c:	2c 92       	cmp	#4,	r12	;r2 As==10
    5d7e:	40 24       	jz	$+130    	;abs 0x5e00
    5d80:	3c 92       	cmp	#8,	r12	;r2 As==11
    5d82:	5b 24       	jz	$+184    	;abs 0x5e3a
    5d84:	2c 93       	cmp	#2,	r12	;r3 As==10
    5d86:	29 20       	jnz	$+84     	;abs 0x5dda
    5d88:	38 40 2e 61 	mov	#24878,	r8	;#0x612e
    5d8c:	39 40 4e 61 	mov	#24910,	r9	;#0x614e

00005d90 <.Loc.404.2>:
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA1STATW & UCRXERR)
    5d90:	e2 b2 ea 05 	bit.b	#4,	&0x05ea	;r2 As==10
    5d94:	1a 24       	jz	$+54     	;abs 0x5dca

00005d96 <.Loc.405.2>:
      set_error(UCA1STATW, &SD1);
    5d96:	5c 42 ea 05 	mov.b	&0x05ea,r12	;0x05ea

00005d9a <.LBB52>:
  if (sra & UCOE)
    5d9a:	3c b0 20 00 	bit	#32,	r12	;#0x0020
    5d9e:	2d 24       	jz	$+92     	;abs 0x5dfa

00005da0 <.Loc.317.2>:
    sts |= SD_OVERRUN_ERROR;
    5da0:	7a 40 80 00 	mov.b	#128,	r10	;#0x0080
    5da4:	47 43       	clr.b	r7		;

00005da6 <.L50>:
  if (sra & UCPE)
    5da6:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    5daa:	02 24       	jz	$+6      	;abs 0x5db0

00005dac <.Loc.319.2>:
    sts |= SD_PARITY_ERROR;
    5dac:	3a d0 20 00 	bis	#32,	r10	;#0x0020

00005db0 <.L51>:
  if (sra & UCFE)
    5db0:	3c b0 40 00 	bit	#64,	r12	;#0x0040
    5db4:	02 24       	jz	$+6      	;abs 0x5dba

00005db6 <.Loc.321.2>:
    sts |= SD_FRAMING_ERROR;
    5db6:	3a d0 40 00 	bis	#64,	r10	;#0x0040

00005dba <.L52>:
  chSysLockFromISR();
    5dba:	88 12       	call	r8		;

00005dbc <.LBE54>:
  chnAddFlagsI(sdp, sts);
    5dbc:	0d 4a       	mov	r10,	r13	;
    5dbe:	0e 47       	mov	r7,	r14	;
    5dc0:	3c 40 fc 51 	mov	#20988,	r12	;#0x51fc
    5dc4:	b0 12 26 6b 	call	#27430		;#0x6b26

00005dc8 <.LBB56>:
  chSysUnlockFromISR();
    5dc8:	89 12       	call	r9		;

00005dca <.L49>:
  chSysLockFromISR();
    5dca:	88 12       	call	r8		;

00005dcc <.LBE59>:

    /* Data available */
    osalSysLockFromISR();
    sdIncomingDataI(&SD1, UCA1RXBUF);
    5dcc:	1d 42 ec 05 	mov	&0x05ec,r13	;0x05ec
    5dd0:	3c 40 fa 51 	mov	#20986,	r12	;#0x51fa
    5dd4:	b0 12 5e 6a 	call	#27230		;#0x6a5e

00005dd8 <.LBB61>:
  chSysUnlockFromISR();
    5dd8:	89 12       	call	r9		;

00005dda <.L45>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    5dda:	b0 12 94 61 	call	#24980		;#0x6194

00005dde <.LVL88>:
    5dde:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5de2:	b0 12 f0 60 	call	#24816		;#0x60f0

00005de6 <.LVL89>:
    5de6:	b0 12 84 63 	call	#25476		;#0x6384

00005dea <.LVL90>:
    5dea:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5dec:	02 24       	jz	$+6      	;abs 0x5df2

00005dee <.Loc.443.2>:
    5dee:	b0 12 9c 63 	call	#25500		;#0x639c

00005df2 <.L57>:
    5df2:	b0 12 0e 61 	call	#24846		;#0x610e

00005df6 <.LVL92>:
}
    5df6:	b4 17       	popm	#12,	r15	;16-bit words
    5df8:	00 13       	reti			

00005dfa <.L58>:
  eventflags_t sts = 0;
    5dfa:	4a 43       	clr.b	r10		;
    5dfc:	07 4a       	mov	r10,	r7	;
    5dfe:	d3 3f       	jmp	$-88     	;abs 0x5da6

00005e00 <.L46>:
  chSysLockFromISR();
    5e00:	b0 12 2e 61 	call	#24878		;#0x612e

00005e04 <.LBE64>:
    b = sdRequestDataI(&SD1);
    5e04:	3c 40 fa 51 	mov	#20986,	r12	;#0x51fa
    5e08:	b0 12 9e 6a 	call	#27294		;#0x6a9e

00005e0c <.LVL96>:
    if (b < Q_OK) {
    5e0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e0e:	12 34       	jge	$+38     	;abs 0x5e34

00005e10 <.Loc.419.2>:
      chnAddFlagsI(&SD1, CHN_OUTPUT_EMPTY);
    5e10:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5e12:	4e 43       	clr.b	r14		;
    5e14:	3c 40 fc 51 	mov	#20988,	r12	;#0x51fc

00005e18 <.LVL97>:
    5e18:	b0 12 26 6b 	call	#27430		;#0x6b26

00005e1c <.LVL98>:
      UCA1IE = (UCA1IE & ~UCTXIE) | UCTXCPTIE;
    5e1c:	1c 42 fa 05 	mov	&0x05fa,r12	;0x05fa
    5e20:	3c f0 f5 ff 	and	#-11,	r12	;#0xfff5
    5e24:	3c d2       	bis	#8,	r12	;r2 As==11
    5e26:	82 4c fa 05 	mov	r12,	&0x05fa	;

00005e2a <.Loc.421.2>:
      UCA1IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    5e2a:	a2 d3 fc 05 	bis	#2,	&0x05fc	;r3 As==10

00005e2e <.L72>:
  chSysUnlockFromISR();
    5e2e:	b0 12 4e 61 	call	#24910		;#0x614e

00005e32 <.LVL99>:
    5e32:	d3 3f       	jmp	$-88     	;abs 0x5dda

00005e34 <.L53>:
      UCA1TXBUF = b;
    5e34:	82 4c ee 05 	mov	r12,	&0x05ee	;
    5e38:	fa 3f       	jmp	$-10     	;abs 0x5e2e

00005e3a <.L47>:
  chSysLockFromISR();
    5e3a:	b0 12 2e 61 	call	#24878		;#0x612e

00005e3e <.LBE68>:
    if (oqIsEmptyI(&SD1.oqueue))
    5e3e:	3c 40 fa 51 	mov	#20986,	r12	;#0x51fa
    5e42:	92 92 20 52 	cmp	&0x5220,&0x521e	;0x5220
    5e46:	1e 52 
    5e48:	04 20       	jnz	$+10     	;abs 0x5e52

00005e4a <.Loc.432.2>:
    5e4a:	1d 4c 1e 00 	mov	30(r12),r13	;0x0001e
    5e4e:	0d 93       	cmp	#0,	r13	;r3 As==00
    5e50:	03 20       	jnz	$+8      	;abs 0x5e58

00005e52 <.L55>:
    UCA1IE &= ~UCTXCPTIE;
    5e52:	b2 c2 fa 05 	bic	#8,	&0x05fa	;r2 As==11
    5e56:	eb 3f       	jmp	$-40     	;abs 0x5e2e

00005e58 <.L56>:
      chnAddFlagsI(&SD1, CHN_TRANSMISSION_END);
    5e58:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    5e5c:	4e 43       	clr.b	r14		;
    5e5e:	2c 53       	incd	r12		;
    5e60:	b0 12 26 6b 	call	#27430		;#0x6b26

00005e64 <.LVL103>:
    5e64:	f6 3f       	jmp	$-18     	;abs 0x5e52

00005e66 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    5e66:	bf 15       	pushm	#12,	r15	;16-bit words

00005e68 <.LCFI0>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5e68:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5e6c:	b0 12 6e 61 	call	#24942		;#0x616e

00005e70 <L0>:
  pad = (P1IV >> 1) - 1;
    5e70:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e

00005e74 <.LVL1>:
    5e74:	12 c3       	clrc			
    5e76:	0c 10       	rrc	r12		;

00005e78 <.LVL2>:
    5e78:	7c 53       	add.b	#-1,	r12	;r3 As==11

00005e7a <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    5e7a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e7e:	0c 5c       	rla	r12		;
    5e80:	1c 4c 46 52 	mov	21062(r12),r12	;0x05246

00005e84 <.LVL3>:
  if (cb != NULL) {
    5e84:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e86:	01 24       	jz	$+4      	;abs 0x5e8a

00005e88 <.Loc.81.1>:
    (*cb)();
    5e88:	8c 12       	call	r12		;

00005e8a <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5e8a:	b0 12 94 61 	call	#24980		;#0x6194

00005e8e <.LVL5>:
    5e8e:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5e92:	b0 12 f0 60 	call	#24816		;#0x60f0

00005e96 <.LVL6>:
    5e96:	b0 12 84 63 	call	#25476		;#0x6384

00005e9a <.LVL7>:
    5e9a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5e9c:	02 24       	jz	$+6      	;abs 0x5ea2

00005e9e <.Loc.84.1>:
    5e9e:	b0 12 9c 63 	call	#25500		;#0x639c

00005ea2 <.L3>:
    5ea2:	b0 12 0e 61 	call	#24846		;#0x610e

00005ea6 <.LVL9>:
}
    5ea6:	b4 17       	popm	#12,	r15	;16-bit words
    5ea8:	00 13       	reti			

00005eaa <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    5eaa:	bf 15       	pushm	#12,	r15	;16-bit words

00005eac <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5eac:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5eb0:	b0 12 6e 61 	call	#24942		;#0x616e

00005eb4 <.LVL10>:
  pad = (P2IV >> 1) - 1;
    5eb4:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e

00005eb8 <.LVL11>:
    5eb8:	12 c3       	clrc			
    5eba:	0c 10       	rrc	r12		;

00005ebc <.LVL12>:
    5ebc:	7c 53       	add.b	#-1,	r12	;r3 As==11

00005ebe <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    5ebe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5ec2:	3c 52       	add	#8,	r12	;r2 As==11
    5ec4:	0c 5c       	rla	r12		;
    5ec6:	1c 4c 46 52 	mov	21062(r12),r12	;0x05246

00005eca <.LVL13>:
  if (cb != NULL) {
    5eca:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ecc:	01 24       	jz	$+4      	;abs 0x5ed0

00005ece <.Loc.99.1>:
    (*cb)();
    5ece:	8c 12       	call	r12		;

00005ed0 <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5ed0:	b0 12 94 61 	call	#24980		;#0x6194

00005ed4 <.LVL15>:
    5ed4:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5ed8:	b0 12 f0 60 	call	#24816		;#0x60f0

00005edc <.LVL16>:
    5edc:	b0 12 84 63 	call	#25476		;#0x6384

00005ee0 <.LVL17>:
    5ee0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5ee2:	02 24       	jz	$+6      	;abs 0x5ee8

00005ee4 <.Loc.102.1>:
    5ee4:	b0 12 9c 63 	call	#25500		;#0x639c

00005ee8 <.L12>:
    5ee8:	b0 12 0e 61 	call	#24846		;#0x610e

00005eec <.LVL19>:
}
    5eec:	b4 17       	popm	#12,	r15	;16-bit words
    5eee:	00 13       	reti			

00005ef0 <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    5ef0:	bf 15       	pushm	#12,	r15	;16-bit words

00005ef2 <.LCFI2>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5ef2:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5ef6:	b0 12 6e 61 	call	#24942		;#0x616e

00005efa <.LVL20>:
  pad = (P3IV >> 1) - 1;
    5efa:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e

00005efe <.LVL21>:
    5efe:	12 c3       	clrc			
    5f00:	0c 10       	rrc	r12		;

00005f02 <.LVL22>:
    5f02:	7c 53       	add.b	#-1,	r12	;r3 As==11

00005f04 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    5f04:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5f08:	3c 50 10 00 	add	#16,	r12	;#0x0010
    5f0c:	0c 5c       	rla	r12		;
    5f0e:	1c 4c 46 52 	mov	21062(r12),r12	;0x05246

00005f12 <.LVL23>:
  if (cb != NULL) {
    5f12:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f14:	01 24       	jz	$+4      	;abs 0x5f18

00005f16 <.Loc.118.1>:
    (*cb)();
    5f16:	8c 12       	call	r12		;

00005f18 <.L20>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5f18:	b0 12 94 61 	call	#24980		;#0x6194

00005f1c <.LVL25>:
    5f1c:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5f20:	b0 12 f0 60 	call	#24816		;#0x60f0

00005f24 <.LVL26>:
    5f24:	b0 12 84 63 	call	#25476		;#0x6384

00005f28 <.LVL27>:
    5f28:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5f2a:	02 24       	jz	$+6      	;abs 0x5f30

00005f2c <.Loc.121.1>:
    5f2c:	b0 12 9c 63 	call	#25500		;#0x639c

00005f30 <.L21>:
    5f30:	b0 12 0e 61 	call	#24846		;#0x610e

00005f34 <.LVL29>:
}
    5f34:	b4 17       	popm	#12,	r15	;16-bit words
    5f36:	00 13       	reti			

00005f38 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    5f38:	bf 15       	pushm	#12,	r15	;16-bit words

00005f3a <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5f3a:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5f3e:	b0 12 6e 61 	call	#24942		;#0x616e

00005f42 <.LVL30>:
  pad = (P4IV >> 1) - 1;
    5f42:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e

00005f46 <.LVL31>:
    5f46:	12 c3       	clrc			
    5f48:	0c 10       	rrc	r12		;

00005f4a <.LVL32>:
    5f4a:	7c 53       	add.b	#-1,	r12	;r3 As==11

00005f4c <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    5f4c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5f50:	3c 50 18 00 	add	#24,	r12	;#0x0018
    5f54:	0c 5c       	rla	r12		;
    5f56:	1c 4c 46 52 	mov	21062(r12),r12	;0x05246

00005f5a <.LVL33>:
  if (cb != NULL) {
    5f5a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f5c:	01 24       	jz	$+4      	;abs 0x5f60

00005f5e <.Loc.136.1>:
    (*cb)();
    5f5e:	8c 12       	call	r12		;

00005f60 <.L29>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5f60:	b0 12 94 61 	call	#24980		;#0x6194

00005f64 <.LVL35>:
    5f64:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5f68:	b0 12 f0 60 	call	#24816		;#0x60f0

00005f6c <.LVL36>:
    5f6c:	b0 12 84 63 	call	#25476		;#0x6384

00005f70 <.LVL37>:
    5f70:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5f72:	02 24       	jz	$+6      	;abs 0x5f78

00005f74 <.Loc.139.1>:
    5f74:	b0 12 9c 63 	call	#25500		;#0x639c

00005f78 <.L30>:
    5f78:	b0 12 0e 61 	call	#24846		;#0x610e

00005f7c <.LVL39>:
}
    5f7c:	b4 17       	popm	#12,	r15	;16-bit words
    5f7e:	00 13       	reti			

00005f80 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    5f80:	bf 15       	pushm	#12,	r15	;16-bit words

00005f82 <.LCFI1>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    5f82:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5f86:	b0 12 6e 61 	call	#24942		;#0x616e

00005f8a <.LVL6>:

  index = (DMAIV >> 1) - 1;
    5f8a:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    5f8e:	12 c3       	clrc			
    5f90:	0c 10       	rrc	r12		;
    5f92:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5f94:	4a 4c       	mov.b	r12,	r10	;

00005f96 <.LVL7>:

  if (index < MSP430X_DMA_CHANNELS) {
    5f96:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5f98:	4d 9c       	cmp.b	r12,	r13	;
    5f9a:	1a 28       	jnc	$+54     	;abs 0x5fd0

00005f9c <.LBB10>:
    /* Set to idle mode (but still claimed) */
    dma_regs[index].ctl &= ~DMAEN;
    5f9c:	09 4a       	mov	r10,	r9	;
    5f9e:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    5fa2:	39 50 10 05 	add	#1296,	r9	;#0x0510
    5fa6:	b9 f0 ef ff 	and	#-17,	0(r9)	;#0xffef
    5faa:	00 00 

00005fac <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5fac:	4d 43       	clr.b	r13		;
    5fae:	b0 12 28 6f 	call	#28456		;#0x6f28

00005fb2 <.LVL8>:
    dma_regs[index].sz  = 0;
    5fb2:	89 43 0a 00 	mov	#0,	10(r9)	;r3 As==00, 0x000a

00005fb6 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    5fb6:	b9 40 12 00 	mov	#18,	0(r9)	;#0x0012
    5fba:	00 00 

00005fbc <.LVL9>:

    msp430x_dma_cb_t * cb = &callbacks[index];

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    5fbc:	41 18 0a 5a 	rpt #2 { rlax.w	r10		;

00005fc0 <.LVL10>:
    5fc0:	3a 50 e6 5c 	add	#23782,	r10	;#0x5ce6

00005fc4 <.LVL11>:
    5fc4:	2d 4a       	mov	@r10,	r13	;
    5fc6:	0d 93       	cmp	#0,	r13	;r3 As==00
    5fc8:	03 24       	jz	$+8      	;abs 0x5fd0

00005fca <.Loc.88.1>:
      cb->callback(cb->args);
    5fca:	1c 4a 02 00 	mov	2(r10),	r12	;
    5fce:	8d 12       	call	r13		;

00005fd0 <.L4>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    5fd0:	b0 12 94 61 	call	#24980		;#0x6194

00005fd4 <.LVL13>:
    5fd4:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    5fd8:	b0 12 f0 60 	call	#24816		;#0x60f0

00005fdc <.LVL14>:
    5fdc:	b0 12 84 63 	call	#25476		;#0x6384

00005fe0 <.LVL15>:
    5fe0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5fe2:	02 24       	jz	$+6      	;abs 0x5fe8

00005fe4 <.Loc.92.1>:
    5fe4:	b0 12 9c 63 	call	#25500		;#0x639c

00005fe8 <.L6>:
    5fe8:	b0 12 0e 61 	call	#24846		;#0x610e

00005fec <.LVL17>:
}
    5fec:	b4 17       	popm	#12,	r15	;16-bit words
    5fee:	00 13       	reti			

00005ff0 <ISR_ADC12_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(ADC12_VECTOR) {
    5ff0:	bf 15       	pushm	#12,	r15	;16-bit words

00005ff2 <.LCFI4>:

  OSAL_IRQ_PROLOGUE();
    5ff2:	d2 43 f8 51 	mov.b	#1,	&0x51f8	;r3 As==01
    5ff6:	b0 12 6e 61 	call	#24942		;#0x616e

00005ffa <.LVL24>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    5ffa:	19 42 18 08 	mov	&0x0818,r9	;0x0818
    5ffe:	3a 40 fa 52 	mov	#21242,	r10	;#0x52fa
    6002:	29 93       	cmp	#2,	r9	;r3 As==10
    6004:	10 24       	jz	$+34     	;abs 0x6026
    6006:	29 92       	cmp	#4,	r9	;r2 As==10
    6008:	41 24       	jz	$+132    	;abs 0x608c

0000600a <.Loc.141.1>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    break;
  }
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    600a:	0c 4a       	mov	r10,	r12	;
    600c:	b0 12 6c 73 	call	#29548		;#0x736c

00006010 <.LVL25>:
    6010:	1c 4a 08 00 	mov	8(r10),	r12	;
    6014:	1e 4c 04 00 	mov	4(r12),	r14	;
    6018:	0e 93       	cmp	#0,	r14	;r3 As==00
    601a:	4e 24       	jz	$+158    	;abs 0x60b8

0000601c <.Loc.141.1>:
    601c:	f2 40 05 00 	mov.b	#5,	&0x52fa	;
    6020:	fa 52 
    6022:	4d 43       	clr.b	r13		;
    6024:	43 3c       	jmp	$+136    	;abs 0x60ac

00006026 <.L25>:
    if (ADCD1.grpp == NULL)
    6026:	82 93 02 53 	cmp	#0,	&0x5302	;r3 As==00
    602a:	20 24       	jz	$+66     	;abs 0x606c

0000602c <.Loc.130.1>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    602c:	0c 4a       	mov	r10,	r12	;
    602e:	b0 12 6c 73 	call	#29548		;#0x736c

00006032 <.LVL26>:
    6032:	1c 4a 08 00 	mov	8(r10),	r12	;
    6036:	1e 4c 04 00 	mov	4(r12),	r14	;
    603a:	0e 93       	cmp	#0,	r14	;r3 As==00
    603c:	3d 24       	jz	$+124    	;abs 0x60b8

0000603e <.Loc.130.1>:
    603e:	f2 40 05 00 	mov.b	#5,	&0x52fa	;
    6042:	fa 52 
    6044:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6046:	0c 4a       	mov	r10,	r12	;
    6048:	8e 12       	call	r14		;

0000604a <.LVL27>:
    604a:	f2 90 05 00 	cmp.b	#5,	&0x52fa	;
    604e:	fa 52 
    6050:	02 20       	jnz	$+6      	;abs 0x6056

00006052 <.Loc.130.1>:
    6052:	ca 49 00 00 	mov.b	r9,	0(r10)	;

00006056 <.L46>:
    6056:	82 43 02 53 	mov	#0,	&0x5302	;r3 As==00

0000605a <.LBB43>:
    605a:	b0 12 2e 61 	call	#24878		;#0x612e

0000605e <.LBB45>:
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
    605e:	3d 43       	mov	#-1,	r13	;r3 As==11
    6060:	3c 40 04 53 	mov	#21252,	r12	;#0x5304

00006064 <.LVL29>:
    6064:	b0 12 08 64 	call	#25608		;#0x6408

00006068 <.LBB47>:
  chSysUnlockFromISR();
    6068:	b0 12 4e 61 	call	#24910		;#0x614e

0000606c <.L27>:
  }

  OSAL_IRQ_EPILOGUE();
    606c:	b0 12 94 61 	call	#24980		;#0x6194

00006070 <.LVL32>:
    6070:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00
    6074:	b0 12 f0 60 	call	#24816		;#0x60f0

00006078 <.LVL33>:
    6078:	b0 12 84 63 	call	#25476		;#0x6384

0000607c <.LVL34>:
    607c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    607e:	02 24       	jz	$+6      	;abs 0x6084

00006080 <.Loc.144.1>:
    6080:	b0 12 9c 63 	call	#25500		;#0x639c

00006084 <.L31>:
    6084:	b0 12 0e 61 	call	#24846		;#0x610e

00006088 <.LVL36>:
}
    6088:	b4 17       	popm	#12,	r15	;16-bit words
    608a:	00 13       	reti			

0000608c <.L26>:
    if (ADCD1.grpp == NULL)
    608c:	82 93 02 53 	cmp	#0,	&0x5302	;r3 As==00
    6090:	ed 27       	jz	$-36     	;abs 0x606c

00006092 <.Loc.136.1>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    6092:	0c 4a       	mov	r10,	r12	;
    6094:	b0 12 6c 73 	call	#29548		;#0x736c

00006098 <.LVL37>:
    6098:	1c 4a 08 00 	mov	8(r10),	r12	;
    609c:	1e 4c 04 00 	mov	4(r12),	r14	;
    60a0:	0e 93       	cmp	#0,	r14	;r3 As==00
    60a2:	0a 24       	jz	$+22     	;abs 0x60b8

000060a4 <.Loc.136.1>:
    60a4:	f2 40 05 00 	mov.b	#5,	&0x52fa	;
    60a8:	fa 52 
    60aa:	6d 43       	mov.b	#2,	r13	;r3 As==10

000060ac <.L48>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    60ac:	0c 4a       	mov	r10,	r12	;
    60ae:	8e 12       	call	r14		;

000060b0 <.LVL38>:
    60b0:	f2 90 05 00 	cmp.b	#5,	&0x52fa	;
    60b4:	fa 52 
    60b6:	cf 23       	jnz	$-96     	;abs 0x6056

000060b8 <.L28>:
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    60b8:	e2 43 fa 52 	mov.b	#2,	&0x52fa	;r3 As==10
    60bc:	cc 3f       	jmp	$-102    	;abs 0x6056

000060be <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    60be:	c2 43 f8 51 	mov.b	#0,	&0x51f8	;r3 As==00

000060c2 <L0>:
}
    60c2:	30 41       	ret			

000060c4 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    60c4:	03 43       	nop			

000060c6 <.Loc.356.1>:
  _enable_interrupts();
    60c6:	03 43       	nop			
    60c8:	32 d2       	eint			
    60ca:	03 43       	nop			

000060cc <.Loc.357.1>:
}
    60cc:	30 41       	ret			

000060ce <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    60ce:	32 c2       	dint			
    60d0:	03 43       	nop			

000060d2 <.Loc.390.1>:
  asm volatile("nop");
    60d2:	03 43       	nop			

000060d4 <.Loc.391.1>:
}
    60d4:	30 41       	ret			

000060d6 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    60d6:	82 93 d2 51 	cmp	#0,	&0x51d2	;r3 As==00
    60da:	03 20       	jnz	$+8      	;abs 0x60e2

000060dc <.Loc.79.2>:
    60dc:	82 93 d4 51 	cmp	#0,	&0x51d4	;r3 As==00
    60e0:	06 24       	jz	$+14     	;abs 0x60ee

000060e2 <.L9>:
 *
 * @special
 */
void chSysHalt(const char *reason) {

  port_disable();
    60e2:	b0 12 ce 60 	call	#24782		;#0x60ce

000060e6 <.LVL4>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    60e6:	b2 40 05 50 	mov	#20485,	&0x51d6	;#0x5005
    60ea:	d6 51 

000060ec <.L11>:
    60ec:	ff 3f       	jmp	$+0      	;abs 0x60ec

000060ee <.L8>:
}
    60ee:	30 41       	ret			

000060f0 <_dbg_check_lock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    60f0:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

000060f2 <L0>:
    60f2:	d2 51 03 20 	add.b	8195(r1)	;0x02003, Warning: disassembly unreliable - not enough bytes available

000060f6 <.Loc.103.2>:
    60f6:	82 93 d4 51 	cmp	#0,	&0x51d4	;r3 As==00
    60fa:	06 24       	jz	$+14     	;abs 0x6108

000060fc <.L17>:
  port_disable();
    60fc:	b0 12 ce 60 	call	#24782		;#0x60ce

00006100 <.LVL10>:
  nil.dbg_panic_msg = reason;
    6100:	b2 40 0f 50 	mov	#20495,	&0x51d6	;#0x500f
    6104:	d6 51 

00006106 <.L19>:
    6106:	ff 3f       	jmp	$+0      	;abs 0x6106

00006108 <.L18>:
  _dbg_enter_lock();
    6108:	92 43 d4 51 	mov	#1,	&0x51d4	;r3 As==01

0000610c <.Loc.107.2>:
}
    610c:	30 41       	ret			

0000610e <_dbg_check_unlock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    610e:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00006110 <L0>:
    6110:	d2 51 04 20 	add.b	8196(r1)	;0x02004, Warning: disassembly unreliable - not enough bytes available

00006114 <.Loc.116.2>:
    6114:	4c 43       	clr.b	r12		;
    6116:	1c 92 d4 51 	cmp	&0x51d4,r12	;0x51d4
    611a:	06 38       	jl	$+14     	;abs 0x6128

0000611c <.L21>:
  port_disable();
    611c:	b0 12 ce 60 	call	#24782		;#0x60ce

00006120 <.LVL13>:
  nil.dbg_panic_msg = reason;
    6120:	b2 40 14 50 	mov	#20500,	&0x51d6	;#0x5014
    6124:	d6 51 

00006126 <.L23>:
    6126:	ff 3f       	jmp	$+0      	;abs 0x6126

00006128 <.L22>:
  _dbg_leave_lock();
    6128:	82 43 d4 51 	mov	#0,	&0x51d4	;r3 As==00

0000612c <.Loc.120.2>:
}
    612c:	30 41       	ret			

0000612e <_dbg_check_lock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    612e:	4c 43       	clr.b	r12		;

00006130 <L0>:
    6130:	1c 92 d2 51 	cmp	&0x51d2,r12	;0x51d2
    6134:	03 34       	jge	$+8      	;abs 0x613c

00006136 <.Loc.129.2>:
    6136:	82 9c d4 51 	cmp	r12,	&0x51d4	;
    613a:	06 24       	jz	$+14     	;abs 0x6148

0000613c <.L25>:
  port_disable();
    613c:	b0 12 ce 60 	call	#24782		;#0x60ce

00006140 <.LVL16>:
  nil.dbg_panic_msg = reason;
    6140:	b2 40 19 50 	mov	#20505,	&0x51d6	;#0x5019
    6144:	d6 51 

00006146 <.L27>:
    6146:	ff 3f       	jmp	$+0      	;abs 0x6146

00006148 <.L26>:
  _dbg_enter_lock();
    6148:	92 43 d4 51 	mov	#1,	&0x51d4	;r3 As==01

0000614c <.Loc.133.2>:
}
    614c:	30 41       	ret			

0000614e <_dbg_check_unlock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    614e:	4c 43       	clr.b	r12		;

00006150 <L0>:
    6150:	1c 92 d2 51 	cmp	&0x51d2,r12	;0x51d2
    6154:	03 34       	jge	$+8      	;abs 0x615c

00006156 <.Loc.142.2>:
    6156:	1c 92 d4 51 	cmp	&0x51d4,r12	;0x51d4
    615a:	06 38       	jl	$+14     	;abs 0x6168

0000615c <.L29>:
  port_disable();
    615c:	b0 12 ce 60 	call	#24782		;#0x60ce

00006160 <.LVL19>:
  nil.dbg_panic_msg = reason;
    6160:	b2 40 1e 50 	mov	#20510,	&0x51d6	;#0x501e
    6164:	d6 51 

00006166 <.L31>:
    6166:	ff 3f       	jmp	$+0      	;abs 0x6166

00006168 <.L30>:
  _dbg_leave_lock();
    6168:	82 43 d4 51 	mov	#0,	&0x51d4	;r3 As==00

0000616c <.Loc.146.2>:
}
    616c:	30 41       	ret			

0000616e <_dbg_check_enter_isr>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    616e:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00006170 <L0>:
    6170:	cc 51 1d 4c 	add.b	r1,	19485(r12); 0x4c1d
    6174:	06 00       	mova	@r0,	r6	;
    6176:	0d 93       	cmp	#0,	r13	;r3 As==00
    6178:	03 38       	jl	$+8      	;abs 0x6180

0000617a <.Loc.156.2>:
    617a:	82 93 d4 51 	cmp	#0,	&0x51d4	;r3 As==00
    617e:	06 24       	jz	$+14     	;abs 0x618c

00006180 <.L33>:
  port_disable();
    6180:	b0 12 ce 60 	call	#24782		;#0x60ce

00006184 <.LVL22>:
  nil.dbg_panic_msg = reason;
    6184:	b2 40 23 50 	mov	#20515,	&0x51d6	;#0x5023
    6188:	d6 51 

0000618a <.L35>:
    618a:	ff 3f       	jmp	$+0      	;abs 0x618a

0000618c <.L34>:
  nil.isr_cnt++;
    618c:	1d 53       	inc	r13		;
    618e:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006192 <.Loc.161.2>:
}
    6192:	30 41       	ret			

00006194 <_dbg_check_leave_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6194:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00006196 <L0>:
    6196:	cc 51 1d 4c 	add.b	r1,	19485(r12); 0x4c1d
    619a:	06 00       	mova	@r0,	r6	;
    619c:	4e 43       	clr.b	r14		;
    619e:	0e 9d       	cmp	r13,	r14	;
    61a0:	03 34       	jge	$+8      	;abs 0x61a8

000061a2 <.Loc.171.2>:
    61a2:	82 9e d4 51 	cmp	r14,	&0x51d4	;
    61a6:	06 24       	jz	$+14     	;abs 0x61b4

000061a8 <.L37>:
  port_disable();
    61a8:	b0 12 ce 60 	call	#24782		;#0x60ce

000061ac <.LVL25>:
  nil.dbg_panic_msg = reason;
    61ac:	b2 40 28 50 	mov	#20520,	&0x51d6	;#0x5028
    61b0:	d6 51 

000061b2 <.L39>:
    61b2:	ff 3f       	jmp	$+0      	;abs 0x61b2

000061b4 <.L38>:
  nil.isr_cnt--;
    61b4:	3d 53       	add	#-1,	r13	;r3 As==11
    61b6:	8c 4d 06 00 	mov	r13,	6(r12)	;

000061ba <.Loc.176.2>:
}
    61ba:	30 41       	ret			

000061bc <chDbgCheckClassI>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    61bc:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

000061be <L0>:
    61be:	d2 51 04 38 	add.b	14340(r1)	;0x03804, Warning: disassembly unreliable - not enough bytes available

000061c2 <.Loc.188.2>:
    61c2:	4c 43       	clr.b	r12		;
    61c4:	1c 92 d4 51 	cmp	&0x51d4,r12	;0x51d4
    61c8:	06 38       	jl	$+14     	;abs 0x61d6

000061ca <.L41>:
  port_disable();
    61ca:	b0 12 ce 60 	call	#24782		;#0x60ce

000061ce <.LVL28>:
  nil.dbg_panic_msg = reason;
    61ce:	b2 40 2d 50 	mov	#20525,	&0x51d6	;#0x502d
    61d2:	d6 51 

000061d4 <.L43>:
    61d4:	ff 3f       	jmp	$+0      	;abs 0x61d4

000061d6 <.L40>:
}
    61d6:	30 41       	ret			

000061d8 <chDbgCheckClassS>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    61d8:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

000061da <L0>:
    61da:	d2 51 04 20 	add.b	8196(r1)	;0x02004, Warning: disassembly unreliable - not enough bytes available

000061de <.Loc.203.2>:
    61de:	4c 43       	clr.b	r12		;
    61e0:	1c 92 d4 51 	cmp	&0x51d4,r12	;0x51d4
    61e4:	06 38       	jl	$+14     	;abs 0x61f2

000061e6 <.L45>:
  port_disable();
    61e6:	b0 12 ce 60 	call	#24782		;#0x60ce

000061ea <.LVL31>:
  nil.dbg_panic_msg = reason;
    61ea:	b2 40 33 50 	mov	#20531,	&0x51d6	;#0x5033
    61ee:	d6 51 

000061f0 <.L47>:
    61f0:	ff 3f       	jmp	$+0      	;abs 0x61f0

000061f2 <.L44>:
}
    61f2:	30 41       	ret			

000061f4 <chSysInit>:
__attribute__((optimize(0))) void chSysInit(void) {
    61f4:	21 82       	sub	#4,	r1	;r2 As==10

000061f6 <L0>:
  nil.isr_cnt  = (cnt_t)0;
    61f6:	82 43 d2 51 	mov	#0,	&0x51d2	;r3 As==00

000061fa <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    61fa:	82 43 d4 51 	mov	#0,	&0x51d4	;r3 As==00

000061fe <.Loc.233.2>:
  tp = &nil.threads[0];
    61fe:	b1 40 d8 51 	mov	#20952,	2(r1)	;#0x51d8
    6202:	02 00 

00006204 <.Loc.234.2>:
  tcp = nil_thd_configs;
    6204:	b1 40 7e 50 	mov	#20606,	0(r1)	;#0x507e
    6208:	00 00 

0000620a <.LVL34>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    620a:	2d 3c       	jmp	$+92     	;abs 0x6266

0000620c <.L50>:
    tp->wabase  = (stkalign_t *)tcp->wbase;
    620c:	2c 41       	mov	@r1,	r12	;
    620e:	2d 4c       	mov	@r12,	r13	;
    6210:	1c 41 02 00 	mov	2(r1),	r12	;
    6214:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00006218 <.Loc.241.2>:
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    6218:	2c 41       	mov	@r1,	r12	;
    621a:	1c 4c 02 00 	mov	2(r12),	r12	;
    621e:	0d 4c       	mov	r12,	r13	;
    6220:	3d 50 f0 ff 	add	#-16,	r13	;#0xfff0
    6224:	1c 41 02 00 	mov	2(r1),	r12	;
    6228:	8c 4d 00 00 	mov	r13,	0(r12)	;
    622c:	1c 41 02 00 	mov	2(r1),	r12	;
    6230:	2c 4c       	mov	@r12,	r12	;
    6232:	2d 41       	mov	@r1,	r13	;
    6234:	1d 4d 06 00 	mov	6(r13),	r13	;
    6238:	8c 4d 00 00 	mov	r13,	0(r12)	;
    623c:	1c 41 02 00 	mov	2(r1),	r12	;
    6240:	2c 4c       	mov	@r12,	r12	;
    6242:	2d 41       	mov	@r1,	r13	;
    6244:	1d 4d 08 00 	mov	8(r13),	r13	;
    6248:	8c 4d 02 00 	mov	r13,	2(r12)	;
    624c:	1c 41 02 00 	mov	2(r1),	r12	;
    6250:	2c 4c       	mov	@r12,	r12	;
    6252:	3d 40 10 65 	mov	#25872,	r13	;#0x6510
    6256:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

0000625a <.Loc.246.2>:
    tp++;
    625a:	b1 50 10 00 	add	#16,	2(r1)	;#0x0010
    625e:	02 00 

00006260 <.Loc.247.2>:
    tcp++;
    6260:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    6264:	00 00 

00006266 <.L49>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    6266:	b1 90 e8 51 	cmp	#20968,	2(r1)	;#0x51e8
    626a:	02 00 
    626c:	cf 2b       	jnc	$-96     	;abs 0x620c

0000626e <.Loc.253.2>:
  tp->wabase  = THD_IDLE_BASE;
    626e:	1c 41 02 00 	mov	2(r1),	r12	;
    6272:	bc 40 00 44 	mov	#17408,	14(r12)	;#0x4400, 0x000e
    6276:	0e 00 

00006278 <.Loc.258.2>:
  chSysSuspend();
    6278:	b0 12 ce 60 	call	#24782		;#0x60ce

0000627c <.LVL37>:
    627c:	b0 12 d6 60 	call	#24790		;#0x60d6

00006280 <.LVL38>:
  nil.lock_cnt = (cnt_t)1;
    6280:	92 43 d4 51 	mov	#1,	&0x51d4	;r3 As==01

00006284 <.Loc.265.2>:
  _heap_init();
    6284:	b0 12 ec 64 	call	#25836		;#0x64ec

00006288 <.LVL39>:
  port_init();
    6288:	b0 12 be 60 	call	#24766		;#0x60be

0000628c <.LVL40>:
  nil.current = nil.next = nil.threads;
    628c:	b2 40 d8 51 	mov	#20952,	&0x51ce	;#0x51d8
    6290:	ce 51 
    6292:	1c 42 ce 51 	mov	&0x51ce,r12	;0x51ce
    6296:	82 4c cc 51 	mov	r12,	&0x51cc	;

0000629a <.Loc.275.2>:
  port_switch(nil.current, tp);
    629a:	1c 42 cc 51 	mov	&0x51cc,r12	;0x51cc
    629e:	1d 41 02 00 	mov	2(r1),	r13	;
    62a2:	b0 12 04 65 	call	#25860		;#0x6504

000062a6 <.LVL41>:
  chSysUnlock();
    62a6:	b0 12 0e 61 	call	#24846		;#0x610e

000062aa <.LVL42>:
    62aa:	b0 12 c4 60 	call	#24772		;#0x60c4

000062ae <.LVL43>:
}
    62ae:	03 43       	nop			
    62b0:	21 52       	add	#4,	r1	;r2 As==10

000062b2 <.LVL44>:
    62b2:	30 41       	ret			

000062b4 <chSysHalt>:
void chSysHalt(const char *reason) {
    62b4:	0a 15       	pushm	#1,	r10	;16-bit words

000062b6 <L0>:
    62b6:	0a 4c       	mov	r12,	r10	;

000062b8 <.Loc.293.2>:
  port_disable();
    62b8:	b0 12 ce 60 	call	#24782		;#0x60ce

000062bc <.LVL46>:
  nil.dbg_panic_msg = reason;
    62bc:	82 4a d6 51 	mov	r10,	&0x51d6	;

000062c0 <.L52>:
    62c0:	ff 3f       	jmp	$+0      	;abs 0x62c0

000062c2 <chSysTimerHandlerI>:
    62c2:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

000062c4 <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    62c4:	bc 61       	addc	@r1+		; Warning: disassembly unreliable - not enough bytes available

000062c6 <.LVL47>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
  nil.systime++;
    62c6:	3c 40 cc 51 	mov	#20940,	r12	;#0x51cc
    62ca:	9c 53 04 00 	inc	4(r12)		;

000062ce <.Loc.325.2>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    62ce:	1d 4c 14 00 	mov	20(r12),r13	;0x00014
    62d2:	0d 93       	cmp	#0,	r13	;r3 As==00
    62d4:	15 24       	jz	$+44     	;abs 0x6300

000062d6 <.Loc.330.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    62d6:	1d 4c 14 00 	mov	20(r12),r13	;0x00014
    62da:	3d 53       	add	#-1,	r13	;r3 As==11
    62dc:	8c 4d 14 00 	mov	r13,	20(r12)	; 0x0014
    62e0:	0d 93       	cmp	#0,	r13	;r3 As==00
    62e2:	0e 20       	jnz	$+30     	;abs 0x6300

000062e4 <.Loc.334.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    62e4:	5e 4c 0e 00 	mov.b	14(r12),r14	;0x0000e
    62e8:	7e 90 03 00 	cmp.b	#3,	r14	;
    62ec:	0e 20       	jnz	$+30     	;abs 0x630a

000062ee <.Loc.335.2>:
          tp->u1.semp->cnt++;
    62ee:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    62f2:	9c 53 00 00 	inc	0(r12)		;

000062f6 <.L58>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
          *tp->u1.trp = NULL;
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    62f6:	3d 43       	mov	#-1,	r13	;r3 As==11
    62f8:	3c 40 d8 51 	mov	#20952,	r12	;#0x51d8

000062fc <.LVL48>:
    62fc:	b0 12 58 63 	call	#25432		;#0x6358

00006300 <.L55>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    6300:	b0 12 4e 61 	call	#24910		;#0x614e

00006304 <.LVL50>:
    tp++;
    chSysLockFromISR();
    6304:	b0 12 2e 61 	call	#24878		;#0x612e

00006308 <.LVL51>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    6308:	30 41       	ret			

0000630a <.L57>:
        else if (NIL_THD_IS_SUSP(tp)) {
    630a:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    630c:	f4 23       	jnz	$-22     	;abs 0x62f6

0000630e <.Loc.338.2>:
          *tp->u1.trp = NULL;
    630e:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    6312:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6316:	ef 3f       	jmp	$-32     	;abs 0x62f6

00006318 <chSysGetStatusAndLockX>:
    6318:	0a 15       	pushm	#1,	r10	;16-bit words

0000631a <L0>:
  return __get_SR_register();
    631a:	0a 42       	mov	r2,	r10	;

0000631c <.LBE88>:
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    631c:	3a b2       	bit	#8,	r10	;r2 As==11
    631e:	05 24       	jz	$+12     	;abs 0x632a

00006320 <.Loc.450.2>:
    if (port_is_isr_context()) {
    6320:	c2 93 f8 51 	cmp.b	#0,	&0x51f8	;r3 As==00
    6324:	05 24       	jz	$+12     	;abs 0x6330

00006326 <.Loc.451.2>:
      chSysLockFromISR();
    6326:	b0 12 2e 61 	call	#24878		;#0x612e

0000632a <.L67>:
    else {
      chSysLock();
    }
  }
  return sts;
}
    632a:	0c 4a       	mov	r10,	r12	;
    632c:	0a 17       	popm	#1,	r10	;16-bit words
    632e:	30 41       	ret			

00006330 <.L68>:
      chSysLock();
    6330:	b0 12 ce 60 	call	#24782		;#0x60ce

00006334 <.LVL58>:
    6334:	b0 12 f0 60 	call	#24816		;#0x60f0

00006338 <.LVL59>:
    6338:	f8 3f       	jmp	$-14     	;abs 0x632a

0000633a <chSysRestoreStatusX>:
    633a:	3c b2       	bit	#8,	r12	;r2 As==11

0000633c <L0>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    633c:	05 24       	jz	$+12     	;abs 0x6348

0000633e <.Loc.472.2>:
    if (port_is_isr_context()) {
    633e:	c2 93 f8 51 	cmp.b	#0,	&0x51f8	;r3 As==00
    6342:	03 24       	jz	$+8      	;abs 0x634a

00006344 <.Loc.473.2>:
      chSysUnlockFromISR();
    6344:	b0 12 4e 61 	call	#24910		;#0x614e

00006348 <.L72>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    6348:	30 41       	ret			

0000634a <.L74>:
      chSchRescheduleS();
    634a:	b0 12 b0 63 	call	#25520		;#0x63b0

0000634e <.LVL63>:
      chSysUnlock();
    634e:	b0 12 0e 61 	call	#24846		;#0x610e

00006352 <.LVL64>:
    6352:	b0 12 c4 60 	call	#24772		;#0x60c4

00006356 <.LVL65>:
}
    6356:	f8 3f       	jmp	$-14     	;abs 0x6348

00006358 <chSchReadyI>:
    6358:	0a 15       	pushm	#1,	r10	;16-bit words

0000635a <L0>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    635a:	21 83       	decd	r1		;

0000635c <.LCFI4>:
    635c:	0a 4d       	mov	r13,	r10	;

0000635e <.Loc.536.2>:

  chDbgCheckClassI();
    635e:	81 4c 00 00 	mov	r12,	0(r1)	;
    6362:	b0 12 bc 61 	call	#25020		;#0x61bc

00006366 <.LVL67>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    6366:	2c 41       	mov	@r1,	r12	;
    6368:	8c 4a 04 00 	mov	r10,	4(r12)	;

0000636c <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    636c:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00006370 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    6370:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00006374 <.Loc.544.2>:
  if (tp < nil.next) {
    6374:	1c 92 ce 51 	cmp	&0x51ce,r12	;0x51ce
    6378:	02 2c       	jc	$+6      	;abs 0x637e

0000637a <.Loc.545.2>:
    nil.next = tp;
    637a:	82 4c ce 51 	mov	r12,	&0x51ce	;

0000637e <.L79>:
  }
  return tp;
}
    637e:	21 53       	incd	r1		;
    6380:	0a 17       	popm	#1,	r10	;16-bit words
    6382:	30 41       	ret			

00006384 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    6384:	3c 40 cc 51 	mov	#20940,	r12	;#0x51cc
    6388:	2d 4c       	mov	@r12,	r13	;
    638a:	1d ec 02 00 	xor	2(r12),	r13	;
    638e:	0c 43       	clr	r12		;
    6390:	0c 8d       	sub	r13,	r12	;
    6392:	0c dd       	bis	r13,	r12	;

00006394 <.Loc.566.2>:
}
    6394:	5c 03       	rrum	#1,	r12	;
    6396:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    639a:	30 41       	ret			

0000639c <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    639c:	3e 40 cc 51 	mov	#20940,	r14	;#0x51cc
    63a0:	2d 4e       	mov	@r14,	r13	;

000063a2 <.LVL68>:

  nil.current = nil.next;
    63a2:	1c 4e 02 00 	mov	2(r14),	r12	;
    63a6:	8e 4c 00 00 	mov	r12,	0(r14)	;

000063aa <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    63aa:	b0 12 04 65 	call	#25860		;#0x6504

000063ae <.LVL69>:
}
    63ae:	30 41       	ret			

000063b0 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    63b0:	b0 12 d8 61 	call	#25048		;#0x61d8

000063b4 <.LVL70>:

  if (chSchIsRescRequiredI()) {
    63b4:	92 92 ce 51 	cmp	&0x51ce,&0x51cc	;0x51ce
    63b8:	cc 51 
    63ba:	02 24       	jz	$+6      	;abs 0x63c0

000063bc <.Loc.595.2>:
    chSchDoReschedule();
    63bc:	b0 12 9c 63 	call	#25500		;#0x639c

000063c0 <.L82>:
  }
}
    63c0:	30 41       	ret			

000063c2 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    63c2:	3a 15       	pushm	#4,	r10	;16-bit words

000063c4 <.LCFI5>:
    63c4:	47 4c       	mov.b	r12,	r7	;
    63c6:	08 4d       	mov	r13,	r8	;

000063c8 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    63c8:	3a 40 cc 51 	mov	#20940,	r10	;#0x51cc
    63cc:	29 4a       	mov	@r10,	r9	;

000063ce <.Loc.619.2>:

  chDbgCheckClassS();
    63ce:	b0 12 d8 61 	call	#25048		;#0x61d8

000063d2 <.LVL74>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    63d2:	c9 47 02 00 	mov.b	r7,	2(r9)	;

000063d6 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    63d6:	89 48 08 00 	mov	r8,	8(r9)	;
    63da:	0e 4a       	mov	r10,	r14	;
    63dc:	3e 50 0e 00 	add	#14,	r14	;#0x000e

000063e0 <.L85>:
    63e0:	0c 4e       	mov	r14,	r12	;
    63e2:	3c 50 fe ff 	add	#-2,	r12	;#0xfffe

000063e6 <.LVL77>:
    63e6:	3e 50 10 00 	add	#16,	r14	;#0x0010

000063ea <.Loc.667.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    63ea:	ce 93 f0 ff 	cmp.b	#0,	-16(r14);r3 As==00, 0xfff0
    63ee:	f8 23       	jnz	$-14     	;abs 0x63e0

000063f0 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    63f0:	8a 4c 02 00 	mov	r12,	2(r10)	;
    63f4:	8a 4c 00 00 	mov	r12,	0(r10)	;

000063f8 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    63f8:	0d 49       	mov	r9,	r13	;
    63fa:	b0 12 04 65 	call	#25860		;#0x6504

000063fe <.LVL78>:
      return nil.current->u1.msg;
    63fe:	2c 4a       	mov	@r10,	r12	;

00006400 <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    6400:	1c 4c 04 00 	mov	4(r12),	r12	;
    6404:	37 17       	popm	#4,	r10	;16-bit words
    6406:	30 41       	ret			

00006408 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    6408:	2e 4c       	mov	@r12,	r14	;
    640a:	0e 93       	cmp	#0,	r14	;r3 As==00
    640c:	05 24       	jz	$+12     	;abs 0x6418

0000640e <.LBB90>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    640e:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006412 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    6412:	0c 4e       	mov	r14,	r12	;

00006414 <.LVL84>:
    6414:	b0 12 58 63 	call	#25432		;#0x6358

00006418 <.L88>:
  }
}
    6418:	30 41       	ret			

0000641a <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    641a:	0a 15       	pushm	#1,	r10	;16-bit words

0000641c <.LCFI6>:
    641c:	0a 4c       	mov	r12,	r10	;

0000641e <.Loc.737.2>:

  chSysLock();
    641e:	b0 12 ce 60 	call	#24782		;#0x60ce

00006422 <.LVL87>:
    6422:	b0 12 f0 60 	call	#24816		;#0x60f0

00006426 <.LVL88>:
  chThdSleepS(timeout);
    6426:	0d 4a       	mov	r10,	r13	;
    6428:	5c 43       	mov.b	#1,	r12	;r3 As==01
    642a:	b0 12 c2 63 	call	#25538		;#0x63c2

0000642e <.LVL89>:
  chSysUnlock();
    642e:	b0 12 0e 61 	call	#24846		;#0x610e

00006432 <.LVL90>:
    6432:	b0 12 c4 60 	call	#24772		;#0x60c4

00006436 <.LVL91>:
}
    6436:	0a 17       	popm	#1,	r10	;16-bit words
    6438:	30 41       	ret			

0000643a <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    643a:	0a 15       	pushm	#1,	r10	;16-bit words

0000643c <.LCFI9>:
    643c:	21 83       	decd	r1		;

0000643e <.LCFI10>:
    643e:	0a 4c       	mov	r12,	r10	;

00006440 <.Loc.808.2>:

  chDbgCheckClassS();
    6440:	81 4d 00 00 	mov	r13,	0(r1)	;
    6444:	b0 12 d8 61 	call	#25048		;#0x61d8

00006448 <.LVL106>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    6448:	2c 4a       	mov	@r10,	r12	;

0000644a <.LVL107>:
  if (cnt <= (cnt_t)0) {
    644a:	2d 41       	mov	@r1,	r13	;
    644c:	4e 43       	clr.b	r14		;
    644e:	0e 9c       	cmp	r12,	r14	;
    6450:	10 38       	jl	$+34     	;abs 0x6472

00006452 <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    6452:	3d 93       	cmp	#-1,	r13	;r3 As==11
    6454:	13 24       	jz	$+40     	;abs 0x647c

00006456 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    6456:	3c 53       	add	#-1,	r12	;r3 As==11

00006458 <.LVL108>:
    6458:	8a 4c 00 00 	mov	r12,	0(r10)	;

0000645c <.Loc.819.2>:
    nil.current->u1.semp = sp;
    645c:	1c 42 cc 51 	mov	&0x51cc,r12	;0x51cc

00006460 <.LVL109>:
    6460:	8c 4a 04 00 	mov	r10,	4(r12)	;

00006464 <.LVL110>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    6464:	7c 40 03 00 	mov.b	#3,	r12	;
    6468:	b0 12 c2 63 	call	#25538		;#0x63c2

0000646c <.L96>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    646c:	21 53       	incd	r1		;
    646e:	0a 17       	popm	#1,	r10	;16-bit words
    6470:	30 41       	ret			

00006472 <.L97>:
  sp->cnt = cnt - (cnt_t)1;
    6472:	3c 53       	add	#-1,	r12	;r3 As==11

00006474 <.LVL113>:
    6474:	8a 4c 00 00 	mov	r12,	0(r10)	;

00006478 <.Loc.823.2>:
  return MSG_OK;
    6478:	4c 43       	clr.b	r12		;

0000647a <.LVL114>:
    647a:	f8 3f       	jmp	$-14     	;abs 0x646c

0000647c <.L99>:
      return MSG_TIMEOUT;
    647c:	0c 4d       	mov	r13,	r12	;

0000647e <.LVL116>:
    647e:	f6 3f       	jmp	$-18     	;abs 0x646c

00006480 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    6480:	1a 15       	pushm	#2,	r10	;16-bit words

00006482 <.LCFI0>:
    6482:	0a 4c       	mov	r12,	r10	;

00006484 <L0>:
    6484:	09 4d       	mov	r13,	r9	;

00006486 <.Loc.111.1>:
  uint8_t *p;

  chDbgCheckClassI();
    6486:	b0 12 bc 61 	call	#25020		;#0x61bc

0000648a <.LVL1>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    648a:	0e 4a       	mov	r10,	r14	;
    648c:	3e 53       	add	#-1,	r14	;r3 As==11
    648e:	0e 59       	add	r9,	r14	;
    6490:	0d 43       	clr	r13		;
    6492:	0d 89       	sub	r9,	r13	;
    6494:	0e fd       	and	r13,	r14	;

00006496 <.LVL2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    6496:	1c 42 da 5c 	mov	&0x5cda,r12	;0x5cda
    649a:	3c 53       	add	#-1,	r12	;r3 As==11
    649c:	0c 59       	add	r9,	r12	;
    649e:	0c fd       	and	r13,	r12	;

000064a0 <.LVL3>:

  if (((size_t)endmem - (size_t)p) < size) {
    64a0:	1d 42 d8 5c 	mov	&0x5cd8,r13	;0x5cd8
    64a4:	0d 8c       	sub	r12,	r13	;
    64a6:	0d 9e       	cmp	r14,	r13	;
    64a8:	05 28       	jnc	$+12     	;abs 0x64b4

000064aa <.Loc.120.1>:
    return NULL;
  }
  nextmem = p + size;
    64aa:	0e 5c       	add	r12,	r14	;

000064ac <.LVL4>:
    64ac:	82 4e da 5c 	mov	r14,	&0x5cda	;

000064b0 <.L2>:

  return p;
}
    64b0:	19 17       	popm	#2,	r10	;16-bit words
    64b2:	30 41       	ret			

000064b4 <.L4>:
    return NULL;
    64b4:	4c 43       	clr.b	r12		;

000064b6 <.LVL7>:
    64b6:	fc 3f       	jmp	$-6      	;abs 0x64b0

000064b8 <chCoreAllocAligned>:
    64b8:	21 82       	sub	#4,	r1	;r2 As==10

000064ba <L0>:
  _disable_interrupts();
    64ba:	32 c2       	dint			
    64bc:	03 43       	nop			

000064be <.Loc.348.2>:
  asm volatile("nop");
    64be:	03 43       	nop			

000064c0 <.LBE6>:
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  void *p;

  chSysLock();
    64c0:	81 4c 00 00 	mov	r12,	0(r1)	;
    64c4:	81 4d 02 00 	mov	r13,	2(r1)	;
    64c8:	b0 12 f0 60 	call	#24816		;#0x60f0

000064cc <.LVL9>:
  p = chCoreAllocAlignedI(size, align);
    64cc:	1d 41 02 00 	mov	2(r1),	r13	;
    64d0:	2c 41       	mov	@r1,	r12	;
    64d2:	b0 12 80 64 	call	#25728		;#0x6480

000064d6 <.LVL10>:
  chSysUnlock();
    64d6:	81 4c 00 00 	mov	r12,	0(r1)	;
    64da:	b0 12 0e 61 	call	#24846		;#0x610e

000064de <.LBB8>:
  asm volatile("nop");
    64de:	03 43       	nop			

000064e0 <.Loc.356.2>:
  _enable_interrupts();
    64e0:	03 43       	nop			
    64e2:	32 d2       	eint			
    64e4:	03 43       	nop			

000064e6 <.LBE8>:

  return p;
}
    64e6:	2c 41       	mov	@r1,	r12	;
    64e8:	21 52       	add	#4,	r1	;r2 As==10
    64ea:	30 41       	ret			

000064ec <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    64ec:	3c 40 dc 5c 	mov	#23772,	r12	;#0x5cdc
    64f0:	bc 40 b8 64 	mov	#25784,	0(r12)	;#0x64b8
    64f4:	00 00 

000064f6 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    64f6:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

000064fa <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    64fa:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000064fe <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    64fe:	9c 43 06 00 	mov	#1,	6(r12)	;r3 As==01

00006502 <.Loc.117.1>:
#endif
}
    6502:	30 41       	ret			

00006504 <_port_switch>:
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #6, R9");
  asm volatile ("popx.a R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6504:	6a 15       	pushm	#7,	r10	;16-bit words

00006506 <.Loc.81.1>:
  asm volatile ("mov r1, @R13");
    6506:	8d 41 00 00 	mov	r1,	0(r13)	;

0000650a <.Loc.82.1>:
  asm volatile ("mov @R12, r1");
    650a:	21 4c       	mov	@r12,	r1	;

0000650c <.Loc.83.1>:
  asm volatile ("popm.w #7, R10");
    650c:	64 17       	popm	#7,	r10	;16-bit words

0000650e <.Loc.84.1>:
  asm volatile ("ret");
    650e:	30 41       	ret			

00006510 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    6510:	b0 12 0e 61 	call	#24846		;#0x610e

00006514 <.LBB4>:
  asm volatile("nop");
    6514:	03 43       	nop			

00006516 <.Loc.356.2>:
  _enable_interrupts();
    6516:	03 43       	nop			
    6518:	32 d2       	eint			
    651a:	03 43       	nop			

0000651c <.LBE4>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    651c:	0c 45       	mov	r5,	r12	;

0000651e <.Loc.102.1>:
  asm volatile ("call R4");
    651e:	84 12       	call	r4		;

00006520 <.Loc.108.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    6520:	4c 43       	clr.b	r12		;
    6522:	b0 12 b4 62 	call	#25268		;#0x62b4

00006526 <.LVL2>:
#endif
}
    6526:	30 41       	ret			

00006528 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    6528:	0e 4c       	mov	r12,	r14	;

0000652a <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    652a:	2c 4c       	mov	@r12,	r12	;

0000652c <.LVL2>:
    652c:	0c 93       	cmp	#0,	r12	;r3 As==00
    652e:	0e 34       	jge	$+30     	;abs 0x654c
    6530:	3f 40 dc 51 	mov	#20956,	r15	;#0x51dc

00006534 <.L3>:
    6534:	0c 4f       	mov	r15,	r12	;
    6536:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

0000653a <.LBB2>:
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    653a:	2b 4f       	mov	@r15,	r11	;
    653c:	3f 50 10 00 	add	#16,	r15	;#0x0010
    6540:	0e 9b       	cmp	r11,	r14	;
    6542:	f8 23       	jnz	$-14     	;abs 0x6534

00006544 <.Loc.67.1>:
        sp->cnt++;
    6544:	9e 53 00 00 	inc	0(r14)		;

00006548 <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    6548:	b0 12 58 63 	call	#25432		;#0x6358

0000654c <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    654c:	30 41       	ret			

0000654e <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    654e:	b0 12 dc 6a 	call	#27356		;#0x6adc

00006552 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    6552:	3c 40 4a 50 	mov	#20554,	r12	;#0x504a
    6556:	b0 12 12 6e 	call	#28178		;#0x6e12

0000655a <.LVL1>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    655a:	b0 12 ca 68 	call	#26826		;#0x68ca

0000655e <.LVL2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    655e:	b0 12 da 69 	call	#27098		;#0x69da

00006562 <.LVL3>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    6562:	b0 12 c8 6a 	call	#27336		;#0x6ac8

00006566 <.LVL4>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    6566:	b0 12 2e 75 	call	#29998		;#0x752e

0000656a <.LVL5>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    656a:	b0 12 70 65 	call	#25968		;#0x6570

0000656e <.LVL6>:
#endif
}
    656e:	30 41       	ret			

00006570 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    6570:	b0 12 0e 6b 	call	#27406		;#0x6b0e

00006574 <.LVL0>:
}
    6574:	30 41       	ret			

00006576 <osalSysLock>:
  _disable_interrupts();
    6576:	32 c2       	dint			
    6578:	03 43       	nop			

0000657a <.Loc.348.2>:
  asm volatile("nop");
    657a:	03 43       	nop			

0000657c <.LBE34>:
  chSysLock();
    657c:	b0 12 f0 60 	call	#24816		;#0x60f0

00006580 <.LVL0>:
}
    6580:	30 41       	ret			

00006582 <osalSysUnlock>:
  chSysUnlock();
    6582:	b0 12 0e 61 	call	#24846		;#0x610e

00006586 <.LBB38>:
  asm volatile("nop");
    6586:	03 43       	nop			

00006588 <.Loc.356.2>:
  _enable_interrupts();
    6588:	03 43       	nop			
    658a:	32 d2       	eint			
    658c:	03 43       	nop			

0000658e <.LBE38>:
}
    658e:	30 41       	ret			

00006590 <iqObjectInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6590:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006594 <.LBE40>:
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
    6594:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006598 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6598:	8c 4d 04 00 	mov	r13,	4(r12)	;

0000659c <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    659c:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000065a0 <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    65a0:	8c 4d 08 00 	mov	r13,	8(r12)	;

000065a4 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    65a4:	0d 5e       	add	r14,	r13	;

000065a6 <.LVL5>:
    65a6:	8c 4d 06 00 	mov	r13,	6(r12)	;

000065aa <.Loc.64.3>:
  iqp->q_notify  = infy;
    65aa:	8c 4f 0c 00 	mov	r15,	12(r12)	; 0x000c

000065ae <.Loc.65.3>:
  iqp->q_link    = link;
    65ae:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    65b2:	0e 00 

000065b4 <.Loc.66.3>:
}
    65b4:	30 41       	ret			

000065b6 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    65b6:	0a 15       	pushm	#1,	r10	;16-bit words

000065b8 <.LCFI1>:
    65b8:	21 83       	decd	r1		;

000065ba <.LCFI2>:
    65ba:	4a 4d       	mov.b	r13,	r10	;

000065bc <.Loc.104.3>:

  osalDbgCheckClassI();
    65bc:	81 4c 00 00 	mov	r12,	0(r1)	;
    65c0:	b0 12 bc 61 	call	#25020		;#0x61bc

000065c4 <.LVL10>:

  if (iqIsFullI(iqp)) {
    65c4:	2c 41       	mov	@r1,	r12	;
    65c6:	1d 4c 08 00 	mov	8(r12),	r13	;
    65ca:	1d 9c 0a 00 	cmp	10(r12),r13	;0x0000a
    65ce:	04 20       	jnz	$+10     	;abs 0x65d8

000065d0 <.Loc.106.3>:
    65d0:	1e 4c 02 00 	mov	2(r12),	r14	;
    65d4:	0e 93       	cmp	#0,	r14	;r3 As==00
    65d6:	16 20       	jnz	$+46     	;abs 0x6604

000065d8 <.L6>:
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
    65d8:	9c 53 02 00 	inc	2(r12)		;

000065dc <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    65dc:	0e 4d       	mov	r13,	r14	;
    65de:	1e 53       	inc	r14		;
    65e0:	8c 4e 08 00 	mov	r14,	8(r12)	;
    65e4:	cd 4a 00 00 	mov.b	r10,	0(r13)	;

000065e8 <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    65e8:	9c 9c 06 00 	cmp	6(r12),	8(r12)	;
    65ec:	08 00 
    65ee:	03 28       	jnc	$+8      	;abs 0x65f6

000065f0 <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    65f0:	9c 4c 04 00 	mov	4(r12),	8(r12)	;
    65f4:	08 00 

000065f6 <.L9>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    65f6:	4d 43       	clr.b	r13		;
    65f8:	b0 12 28 65 	call	#25896		;#0x6528

000065fc <.LVL11>:

  return MSG_OK;
    65fc:	4c 43       	clr.b	r12		;

000065fe <.L5>:
}
    65fe:	21 53       	incd	r1		;
    6600:	0a 17       	popm	#1,	r10	;16-bit words
    6602:	30 41       	ret			

00006604 <.L10>:
    return MSG_TIMEOUT;
    6604:	3c 43       	mov	#-1,	r12	;r3 As==11
    6606:	fb 3f       	jmp	$-8      	;abs 0x65fe

00006608 <iqGetTimeout>:
    6608:	2a 15       	pushm	#3,	r10	;16-bit words

0000660a <L0>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    660a:	21 83       	decd	r1		;

0000660c <.LCFI4>:
    660c:	0a 4c       	mov	r12,	r10	;
    660e:	09 4d       	mov	r13,	r9	;

00006610 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6610:	b0 12 76 65 	call	#25974		;#0x6576

00006614 <.LBB42>:
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chSemWaitTimeoutS(&tqp->sem, time);
    6614:	38 40 3a 64 	mov	#25658,	r8	;#0x643a

00006618 <.L12>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6618:	1c 4a 02 00 	mov	2(r10),	r12	;
    661c:	0c 93       	cmp	#0,	r12	;r3 As==00
    661e:	19 24       	jz	$+52     	;abs 0x6652

00006620 <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6620:	ba 53 02 00 	add	#-1,	2(r10)	;r3 As==11

00006624 <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6624:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    6628:	0c 4d       	mov	r13,	r12	;
    662a:	1c 53       	inc	r12		;
    662c:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a
    6630:	69 4d       	mov.b	@r13,	r9	;

00006632 <.LVL14>:
  if (iqp->q_rdptr >= iqp->q_top) {
    6632:	1c 9a 06 00 	cmp	6(r10),	r12	;
    6636:	03 28       	jnc	$+8      	;abs 0x663e

00006638 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6638:	9a 4a 04 00 	mov	4(r10),	10(r10)	; 0x000a
    663c:	0a 00 

0000663e <.L15>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    663e:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    6642:	0d 93       	cmp	#0,	r13	;r3 As==00
    6644:	02 24       	jz	$+6      	;abs 0x664a

00006646 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6646:	0c 4a       	mov	r10,	r12	;
    6648:	8d 12       	call	r13		;

0000664a <.L16>:
  }

  osalSysUnlock();
    664a:	b0 12 82 65 	call	#25986		;#0x6582

0000664e <.LVL17>:

  return (msg_t)b;
    664e:	0c 49       	mov	r9,	r12	;
    6650:	0a 3c       	jmp	$+22     	;abs 0x6666

00006652 <.L14>:
    6652:	0d 49       	mov	r9,	r13	;
    6654:	0c 4a       	mov	r10,	r12	;
    6656:	88 12       	call	r8		;

00006658 <.LBE46>:
    if (msg < MSG_OK) {
    6658:	0c 93       	cmp	#0,	r12	;r3 As==00
    665a:	de 37       	jge	$-66     	;abs 0x6618

0000665c <.Loc.150.3>:
      osalSysUnlock();
    665c:	81 4c 00 00 	mov	r12,	0(r1)	;
    6660:	b0 12 82 65 	call	#25986		;#0x6582

00006664 <.LVL20>:
      return msg;
    6664:	2c 41       	mov	@r1,	r12	;

00006666 <.L11>:
}
    6666:	21 53       	incd	r1		;
    6668:	28 17       	popm	#3,	r10	;16-bit words
    666a:	30 41       	ret			

0000666c <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    666c:	6a 15       	pushm	#7,	r10	;16-bit words

0000666e <L0>:
    666e:	31 80 06 00 	sub	#6,	r1	;

00006672 <.LCFI6>:
    6672:	04 4c       	mov	r12,	r4	;
    6674:	08 4d       	mov	r13,	r8	;
    6676:	07 4e       	mov	r14,	r7	;
    6678:	0a 4f       	mov	r15,	r10	;

0000667a <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    667a:	16 4c 0c 00 	mov	12(r12),r6	;0x0000c

0000667e <.LVL23>:
  size_t r = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
    667e:	35 40 76 65 	mov	#25974,	r5	;#0x6576
    6682:	85 12       	call	r5		;

00006684 <.LBB48>:
  return chVTGetSystemTimeX();
    6684:	3c 40 cc 51 	mov	#20940,	r12	;#0x51cc

00006688 <.LBE48>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6688:	0d 4a       	mov	r10,	r13	;
    668a:	1d 5c 04 00 	add	4(r12),	r13	;
    668e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006692 <.LVL25>:
  size_t r = 0;
    6692:	49 43       	clr.b	r9		;

00006694 <.LBB50>:
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6694:	0c 4a       	mov	r10,	r12	;
    6696:	3c 53       	add	#-1,	r12	;r3 As==11
    6698:	81 4c 04 00 	mov	r12,	4(r1)	;

0000669c <.LBB51>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    669c:	35 40 3a 64 	mov	#25658,	r5	;#0x643a

000066a0 <.L22>:
    while (iqIsEmptyI(iqp)) {
    66a0:	1c 44 02 00 	mov	2(r4),	r12	;
    66a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    66a6:	24 24       	jz	$+74     	;abs 0x66f0

000066a8 <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    66a8:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11

000066ac <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    66ac:	0d 48       	mov	r8,	r13	;
    66ae:	1d 53       	inc	r13		;
    66b0:	81 4d 02 00 	mov	r13,	2(r1)	;

000066b4 <.LVL27>:
    66b4:	1c 44 0a 00 	mov	10(r4),	r12	;0x0000a
    66b8:	0d 4c       	mov	r12,	r13	;

000066ba <.LVL28>:
    66ba:	1d 53       	inc	r13		;
    66bc:	84 4d 0a 00 	mov	r13,	10(r4)	; 0x000a
    66c0:	e8 4c 00 00 	mov.b	@r12,	0(r8)	;

000066c4 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    66c4:	94 94 06 00 	cmp	6(r4),	10(r4)	; 0x000a
    66c8:	0a 00 
    66ca:	03 28       	jnc	$+8      	;abs 0x66d2

000066cc <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    66cc:	94 44 04 00 	mov	4(r4),	10(r4)	; 0x000a
    66d0:	0a 00 

000066d2 <.L29>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    66d2:	06 93       	cmp	#0,	r6	;r3 As==00
    66d4:	02 24       	jz	$+6      	;abs 0x66da

000066d6 <.Loc.251.3>:
      nfy(iqp);
    66d6:	0c 44       	mov	r4,	r12	;
    66d8:	86 12       	call	r6		;

000066da <.L30>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    66da:	b0 12 82 65 	call	#25986		;#0x6582

000066de <.LVL30>:

    r++;
    66de:	19 53       	inc	r9		;

000066e0 <.Loc.258.3>:
    if (--n == 0U) {
    66e0:	37 53       	add	#-1,	r7	;r3 As==11
    66e2:	07 93       	cmp	#0,	r7	;r3 As==00
    66e4:	18 24       	jz	$+50     	;abs 0x6716

000066e6 <.Loc.262.3>:
      return r;
    }

    osalSysLock();
    66e6:	b0 12 76 65 	call	#25974		;#0x6576

000066ea <.LVL33>:
    *bp++ = *iqp->q_rdptr++;
    66ea:	18 41 02 00 	mov	2(r1),	r8	;

000066ee <.Loc.213.3>:
    while (iqIsEmptyI(iqp)) {
    66ee:	d8 3f       	jmp	$-78     	;abs 0x66a0

000066f0 <.L28>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    66f0:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    66f4:	1d 91 04 00 	cmp	4(r1),	r13	;
    66f8:	06 2c       	jc	$+14     	;abs 0x6706

000066fa <.LBB58>:
    66fa:	0d 4a       	mov	r10,	r13	;

000066fc <.L25>:
    66fc:	0c 44       	mov	r4,	r12	;
    66fe:	85 12       	call	r5		;

00006700 <.LBE55>:
      if (msg != MSG_OK) {
    6700:	0c 93       	cmp	#0,	r12	;r3 As==00
    6702:	ce 27       	jz	$-98     	;abs 0x66a0
    6704:	06 3c       	jmp	$+14     	;abs 0x6712

00006706 <.L23>:
  return chVTGetSystemTimeX();
    6706:	1c 42 d0 51 	mov	&0x51d0,r12	;0x51d0

0000670a <.LBE56>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    670a:	2d 41       	mov	@r1,	r13	;
    670c:	0d 8c       	sub	r12,	r13	;

0000670e <.LVL39>:
        if (next_timeout > timeout) {
    670e:	0a 9d       	cmp	r13,	r10	;
    6710:	f5 2f       	jc	$-20     	;abs 0x66fc

00006712 <.L40>:
        osalSysUnlock();
    6712:	b0 12 82 65 	call	#25986		;#0x6582

00006716 <.L21>:
  }
}
    6716:	0c 49       	mov	r9,	r12	;
    6718:	31 50 06 00 	add	#6,	r1	;

0000671c <.LVL42>:
    671c:	64 17       	popm	#7,	r10	;16-bit words
    671e:	30 41       	ret			

00006720 <oqObjectInit>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6720:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006724 <L0>:
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
    6724:	8c 4e 02 00 	mov	r14,	2(r12)	;

00006728 <.Loc.286.3>:
  oqp->q_buffer  = bp;
    6728:	8c 4d 04 00 	mov	r13,	4(r12)	;

0000672c <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    672c:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006730 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6730:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006734 <.Loc.289.3>:
  oqp->q_top     = bp + size;
    6734:	0d 5e       	add	r14,	r13	;

00006736 <.LVL46>:
    6736:	8c 4d 06 00 	mov	r13,	6(r12)	;

0000673a <.Loc.290.3>:
  oqp->q_notify  = onfy;
    673a:	8c 4f 0c 00 	mov	r15,	12(r12)	; 0x000c

0000673e <.Loc.291.3>:
  oqp->q_link    = link;
    673e:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    6742:	0e 00 

00006744 <.Loc.292.3>:
}
    6744:	30 41       	ret			

00006746 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    6746:	3a 15       	pushm	#4,	r10	;16-bit words

00006748 <.LCFI8>:
    6748:	21 83       	decd	r1		;

0000674a <.LCFI9>:
    674a:	0a 4c       	mov	r12,	r10	;
    674c:	49 4d       	mov.b	r13,	r9	;
    674e:	08 4e       	mov	r14,	r8	;

00006750 <.Loc.339.3>:

  osalSysLock();
    6750:	b0 12 76 65 	call	#25974		;#0x6576

00006754 <.LBB65>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    6754:	37 40 3a 64 	mov	#25658,	r7	;#0x643a

00006758 <.L44>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6758:	1c 4a 02 00 	mov	2(r10),	r12	;
    675c:	0c 93       	cmp	#0,	r12	;r3 As==00
    675e:	1b 24       	jz	$+56     	;abs 0x6796

00006760 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    6760:	ba 53 02 00 	add	#-1,	2(r10)	;r3 As==11

00006764 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6764:	1c 4a 08 00 	mov	8(r10),	r12	;
    6768:	0d 4c       	mov	r12,	r13	;
    676a:	1d 53       	inc	r13		;
    676c:	8a 4d 08 00 	mov	r13,	8(r10)	;
    6770:	cc 49 00 00 	mov.b	r9,	0(r12)	;

00006774 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6774:	9a 9a 06 00 	cmp	6(r10),	8(r10)	;
    6778:	08 00 
    677a:	03 28       	jnc	$+8      	;abs 0x6782

0000677c <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    677c:	9a 4a 04 00 	mov	4(r10),	8(r10)	;
    6780:	08 00 

00006782 <.L47>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6782:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    6786:	0d 93       	cmp	#0,	r13	;r3 As==00
    6788:	02 24       	jz	$+6      	;abs 0x678e

0000678a <.Loc.359.3>:
    oqp->q_notify(oqp);
    678a:	0c 4a       	mov	r10,	r12	;
    678c:	8d 12       	call	r13		;

0000678e <.L48>:
  }

  osalSysUnlock();
    678e:	b0 12 82 65 	call	#25986		;#0x6582

00006792 <.LVL53>:

  return MSG_OK;
    6792:	4c 43       	clr.b	r12		;
    6794:	0a 3c       	jmp	$+22     	;abs 0x67aa

00006796 <.L46>:
    6796:	0d 48       	mov	r8,	r13	;
    6798:	0c 4a       	mov	r10,	r12	;
    679a:	87 12       	call	r7		;

0000679c <.LBE69>:
    if (msg < MSG_OK) {
    679c:	0c 93       	cmp	#0,	r12	;r3 As==00
    679e:	dc 37       	jge	$-70     	;abs 0x6758

000067a0 <.Loc.345.3>:
      osalSysUnlock();
    67a0:	81 4c 00 00 	mov	r12,	0(r1)	;
    67a4:	b0 12 82 65 	call	#25986		;#0x6582

000067a8 <.LVL56>:
      return msg;
    67a8:	2c 41       	mov	@r1,	r12	;

000067aa <.L43>:
}
    67aa:	21 53       	incd	r1		;
    67ac:	37 17       	popm	#4,	r10	;16-bit words
    67ae:	30 41       	ret			

000067b0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    67b0:	0a 15       	pushm	#1,	r10	;16-bit words

000067b2 <L0>:
    67b2:	21 83       	decd	r1		;

000067b4 <.LCFI11>:
  uint8_t b;

  osalDbgCheckClassI();
    67b4:	81 4c 00 00 	mov	r12,	0(r1)	;
    67b8:	b0 12 bc 61 	call	#25020		;#0x61bc

000067bc <.LVL58>:

  if (oqIsEmptyI(oqp)) {
    67bc:	2c 41       	mov	@r1,	r12	;
    67be:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    67c2:	8c 9d 08 00 	cmp	r13,	8(r12)	;
    67c6:	04 20       	jnz	$+10     	;abs 0x67d0

000067c8 <.Loc.382.3>:
    67c8:	1e 4c 02 00 	mov	2(r12),	r14	;
    67cc:	0e 93       	cmp	#0,	r14	;r3 As==00
    67ce:	14 20       	jnz	$+42     	;abs 0x67f8

000067d0 <.L54>:
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
    67d0:	9c 53 02 00 	inc	2(r12)		;

000067d4 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    67d4:	0e 4d       	mov	r13,	r14	;
    67d6:	1e 53       	inc	r14		;
    67d8:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a
    67dc:	6a 4d       	mov.b	@r13,	r10	;

000067de <.LVL59>:
  if (oqp->q_rdptr >= oqp->q_top) {
    67de:	1e 9c 06 00 	cmp	6(r12),	r14	;
    67e2:	03 28       	jnc	$+8      	;abs 0x67ea

000067e4 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    67e4:	9c 4c 04 00 	mov	4(r12),	10(r12)	; 0x000a
    67e8:	0a 00 

000067ea <.L57>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    67ea:	4d 43       	clr.b	r13		;
    67ec:	b0 12 28 65 	call	#25896		;#0x6528

000067f0 <.LVL61>:

  return (msg_t)b;
    67f0:	0c 4a       	mov	r10,	r12	;

000067f2 <.L53>:
}
    67f2:	21 53       	incd	r1		;
    67f4:	0a 17       	popm	#1,	r10	;16-bit words
    67f6:	30 41       	ret			

000067f8 <.L58>:
    return MSG_TIMEOUT;
    67f8:	3c 43       	mov	#-1,	r12	;r3 As==11
    67fa:	fb 3f       	jmp	$-8      	;abs 0x67f2

000067fc <oqWriteTimeout>:
    67fc:	6a 15       	pushm	#7,	r10	;16-bit words

000067fe <L0>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    67fe:	31 80 06 00 	sub	#6,	r1	;

00006802 <.LCFI13>:
    6802:	04 4c       	mov	r12,	r4	;
    6804:	08 4d       	mov	r13,	r8	;
    6806:	07 4e       	mov	r14,	r7	;
    6808:	0a 4f       	mov	r15,	r10	;

0000680a <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    680a:	16 4c 0c 00 	mov	12(r12),r6	;0x0000c

0000680e <.LVL64>:
  size_t w = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
    680e:	35 40 76 65 	mov	#25974,	r5	;#0x6576
    6812:	85 12       	call	r5		;

00006814 <.LBB71>:
  return chVTGetSystemTimeX();
    6814:	3c 40 cc 51 	mov	#20940,	r12	;#0x51cc

00006818 <.LBE71>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6818:	0d 4a       	mov	r10,	r13	;
    681a:	1d 5c 04 00 	add	4(r12),	r13	;
    681e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006822 <.LVL66>:
  size_t w = 0;
    6822:	49 43       	clr.b	r9		;

00006824 <.LBB73>:
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6824:	0c 4a       	mov	r10,	r12	;
    6826:	3c 53       	add	#-1,	r12	;r3 As==11
    6828:	81 4c 04 00 	mov	r12,	4(r1)	;

0000682c <.LBB74>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    682c:	35 40 3a 64 	mov	#25658,	r5	;#0x643a

00006830 <.L60>:
    while (oqIsFullI(oqp)) {
    6830:	1c 44 02 00 	mov	2(r4),	r12	;
    6834:	0c 93       	cmp	#0,	r12	;r3 As==00
    6836:	24 24       	jz	$+74     	;abs 0x6880

00006838 <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    6838:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11

0000683c <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    683c:	1c 44 08 00 	mov	8(r4),	r12	;
    6840:	0d 4c       	mov	r12,	r13	;
    6842:	1d 53       	inc	r13		;
    6844:	84 4d 08 00 	mov	r13,	8(r4)	;
    6848:	0d 48       	mov	r8,	r13	;
    684a:	1d 53       	inc	r13		;
    684c:	81 4d 02 00 	mov	r13,	2(r1)	;

00006850 <.LVL68>:
    6850:	ec 48 00 00 	mov.b	@r8,	0(r12)	;

00006854 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    6854:	94 94 06 00 	cmp	6(r4),	8(r4)	;
    6858:	08 00 
    685a:	03 28       	jnc	$+8      	;abs 0x6862

0000685c <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    685c:	94 44 04 00 	mov	4(r4),	8(r4)	;
    6860:	08 00 

00006862 <.L67>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    6862:	06 93       	cmp	#0,	r6	;r3 As==00
    6864:	02 24       	jz	$+6      	;abs 0x686a

00006866 <.Loc.475.3>:
      nfy(oqp);
    6866:	0c 44       	mov	r4,	r12	;
    6868:	86 12       	call	r6		;

0000686a <.L68>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    686a:	b0 12 82 65 	call	#25986		;#0x6582

0000686e <.LVL70>:

    w++;
    686e:	19 53       	inc	r9		;

00006870 <.Loc.482.3>:
    if (--n == 0U) {
    6870:	37 53       	add	#-1,	r7	;r3 As==11
    6872:	07 93       	cmp	#0,	r7	;r3 As==00
    6874:	18 24       	jz	$+50     	;abs 0x68a6

00006876 <.Loc.486.3>:
      return w;
    }

    osalSysLock();
    6876:	b0 12 76 65 	call	#25974		;#0x6576

0000687a <.LVL73>:
    *oqp->q_wrptr++ = *bp++;
    687a:	18 41 02 00 	mov	2(r1),	r8	;

0000687e <.LBE73>:
  while (true) {
    687e:	d8 3f       	jmp	$-78     	;abs 0x6830

00006880 <.L66>:
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6880:	3d 40 fd ff 	mov	#-3,	r13	;#0xfffd
    6884:	1d 91 04 00 	cmp	4(r1),	r13	;
    6888:	06 2c       	jc	$+14     	;abs 0x6896

0000688a <.LBB81>:
    688a:	0d 4a       	mov	r10,	r13	;

0000688c <.L63>:
    688c:	0c 44       	mov	r4,	r12	;
    688e:	85 12       	call	r5		;

00006890 <.LBE78>:
      if (msg != MSG_OK) {
    6890:	0c 93       	cmp	#0,	r12	;r3 As==00
    6892:	ce 27       	jz	$-98     	;abs 0x6830
    6894:	06 3c       	jmp	$+14     	;abs 0x68a2

00006896 <.L61>:
  return chVTGetSystemTimeX();
    6896:	1c 42 d0 51 	mov	&0x51d0,r12	;0x51d0

0000689a <.LBE79>:
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    689a:	2d 41       	mov	@r1,	r13	;
    689c:	0d 8c       	sub	r12,	r13	;

0000689e <.LVL79>:
        if (next_timeout > timeout) {
    689e:	0a 9d       	cmp	r13,	r10	;
    68a0:	f5 2f       	jc	$-20     	;abs 0x688c

000068a2 <.L78>:
        osalSysUnlock();
    68a2:	b0 12 82 65 	call	#25986		;#0x6582

000068a6 <.L59>:
  }
}
    68a6:	0c 49       	mov	r9,	r12	;
    68a8:	31 50 06 00 	add	#6,	r1	;

000068ac <.LVL82>:
    68ac:	64 17       	popm	#7,	r10	;16-bit words
    68ae:	30 41       	ret			

000068b0 <osalSysLock>:
  _disable_interrupts();
    68b0:	32 c2       	dint			
    68b2:	03 43       	nop			

000068b4 <L0>:
  asm volatile("nop");
    68b4:	03 43       	nop			

000068b6 <.LBE10>:
  chSysLock();
    68b6:	b0 12 f0 60 	call	#24816		;#0x60f0

000068ba <.LVL0>:
}
    68ba:	30 41       	ret			

000068bc <osalSysUnlock>:
  chSysUnlock();
    68bc:	b0 12 0e 61 	call	#24846		;#0x610e

000068c0 <.LBB14>:
  asm volatile("nop");
    68c0:	03 43       	nop			

000068c2 <.Loc.356.2>:
  _enable_interrupts();
    68c2:	03 43       	nop			
    68c4:	32 d2       	eint			
    68c6:	03 43       	nop			

000068c8 <.LBE14>:
}
    68c8:	30 41       	ret			

000068ca <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    68ca:	b0 12 00 72 	call	#29184		;#0x7200

000068ce <.LVL2>:
}
    68ce:	30 41       	ret			

000068d0 <adcObjectInit>:
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
    68d0:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

000068d4 <.Loc.71.3>:
  adcp->config   = NULL;
    68d4:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

000068d8 <.Loc.72.3>:
  adcp->samples  = NULL;
    68d8:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000068dc <.Loc.73.3>:
  adcp->depth    = 0;
    68dc:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

000068e0 <.Loc.74.3>:
  adcp->grpp     = NULL;
    68e0:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

000068e4 <.Loc.76.3>:
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    68e4:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000068e8 <.Loc.84.3>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    68e8:	30 41       	ret			

000068ea <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    68ea:	1a 15       	pushm	#2,	r10	;16-bit words

000068ec <.LCFI0>:
    68ec:	0a 4c       	mov	r12,	r10	;
    68ee:	09 4d       	mov	r13,	r9	;

000068f0 <.Loc.99.3>:

  osalDbgCheck(adcp != NULL);

  osalSysLock();
    68f0:	b0 12 b0 68 	call	#26800		;#0x68b0

000068f4 <.LVL5>:
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    68f4:	8a 49 02 00 	mov	r9,	2(r10)	;

000068f8 <.Loc.103.3>:
  adc_lld_start(adcp);
    68f8:	0c 4a       	mov	r10,	r12	;
    68fa:	b0 12 4e 72 	call	#29262		;#0x724e

000068fe <.LVL6>:
  adcp->state = ADC_READY;
    68fe:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00006902 <.Loc.105.3>:
  osalSysUnlock();
    6902:	b0 12 bc 68 	call	#26812		;#0x68bc

00006906 <.LVL7>:
}
    6906:	19 17       	popm	#2,	r10	;16-bit words
    6908:	30 41       	ret			

0000690a <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
    690a:	2a 15       	pushm	#3,	r10	;16-bit words

0000690c <.LCFI2>:
    690c:	21 83       	decd	r1		;

0000690e <.LCFI3>:
    690e:	0a 4d       	mov	r13,	r10	;
    6910:	08 4e       	mov	r14,	r8	;
    6912:	09 4f       	mov	r15,	r9	;

00006914 <.Loc.152.3>:

  osalSysLock();
    6914:	81 4c 00 00 	mov	r12,	0(r1)	;
    6918:	b0 12 b0 68 	call	#26800		;#0x68b0

0000691c <.LBB16>:
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {

  osalDbgCheckClassI();
    691c:	b0 12 bc 61 	call	#25020		;#0x61bc

00006920 <.LVL14>:
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
    6920:	2c 41       	mov	@r1,	r12	;
    6922:	8c 48 04 00 	mov	r8,	4(r12)	;

00006926 <.Loc.189.3>:
  adcp->depth    = depth;
    6926:	8c 49 06 00 	mov	r9,	6(r12)	;

0000692a <.Loc.190.3>:
  adcp->grpp     = grpp;
    692a:	8c 4a 08 00 	mov	r10,	8(r12)	;

0000692e <.Loc.191.3>:
  adcp->state    = ADC_ACTIVE;
    692e:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6932:	00 00 

00006934 <.Loc.192.3>:
  adc_lld_start_conversion(adcp);
    6934:	b0 12 b4 72 	call	#29364		;#0x72b4

00006938 <.LBE16>:
  osalSysUnlock();
    6938:	b0 12 bc 68 	call	#26812		;#0x68bc

0000693c <.LVL16>:
}
    693c:	21 53       	incd	r1		;
    693e:	28 17       	popm	#3,	r10	;16-bit words
    6940:	30 41       	ret			

00006942 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6942:	2a 15       	pushm	#3,	r10	;16-bit words

00006944 <.LCFI0>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6944:	28 4c       	mov	@r12,	r8	;
    6946:	19 4c 02 00 	mov	2(r12),	r9	;
    694a:	0a 4d       	mov	r13,	r10	;
    694c:	0a d8       	bis	r8,	r10	;
    694e:	0b 4e       	mov	r14,	r11	;
    6950:	0b d9       	bis	r9,	r11	;
    6952:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6956:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000695a <.Loc.829.1>:
  if (esp->cb != NULL) {
    695a:	1d 4c 04 00 	mov	4(r12),	r13	;

0000695e <.LVL1>:
    695e:	0d 93       	cmp	#0,	r13	;r3 As==00
    6960:	01 24       	jz	$+4      	;abs 0x6964

00006962 <.Loc.830.1>:
    esp->cb(esp);
    6962:	8d 12       	call	r13		;

00006964 <.L1>:
  }
}
    6964:	28 17       	popm	#3,	r10	;16-bit words
    6966:	30 41       	ret			

00006968 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    6968:	3c 50 0c 00 	add	#12,	r12	;#0x000c

0000696c <.LVL4>:
    696c:	b0 12 6c 66 	call	#26220		;#0x666c

00006970 <.LVL5>:
}
    6970:	30 41       	ret			

00006972 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    6972:	4f 43       	clr.b	r15		;
    6974:	3c 50 0c 00 	add	#12,	r12	;#0x000c

00006978 <.LVL7>:
    6978:	b0 12 6c 66 	call	#26220		;#0x666c

0000697c <.LVL8>:
}
    697c:	30 41       	ret			

0000697e <writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    697e:	3c 50 1c 00 	add	#28,	r12	;#0x001c

00006982 <.LVL10>:
    6982:	b0 12 fc 67 	call	#26620		;#0x67fc

00006986 <.LVL11>:
}
    6986:	30 41       	ret			

00006988 <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    6988:	4f 43       	clr.b	r15		;
    698a:	3c 50 1c 00 	add	#28,	r12	;#0x001c

0000698e <.LVL13>:
    698e:	b0 12 fc 67 	call	#26620		;#0x67fc

00006992 <.LVL14>:
}
    6992:	30 41       	ret			

00006994 <gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    6994:	3c 50 0c 00 	add	#12,	r12	;#0x000c

00006998 <.LVL16>:
    6998:	b0 12 08 66 	call	#26120		;#0x6608

0000699c <.LVL17>:
}
    699c:	30 41       	ret			

0000699e <get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    699e:	4d 43       	clr.b	r13		;
    69a0:	3c 50 0c 00 	add	#12,	r12	;#0x000c

000069a4 <.LVL19>:
    69a4:	b0 12 08 66 	call	#26120		;#0x6608

000069a8 <.LVL20>:
}
    69a8:	30 41       	ret			

000069aa <putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    69aa:	3c 50 1c 00 	add	#28,	r12	;#0x001c

000069ae <.LVL22>:
    69ae:	b0 12 46 67 	call	#26438		;#0x6746

000069b2 <.LVL23>:
}
    69b2:	30 41       	ret			

000069b4 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    69b4:	4e 43       	clr.b	r14		;
    69b6:	3c 50 1c 00 	add	#28,	r12	;#0x001c

000069ba <.LVL25>:
    69ba:	b0 12 46 67 	call	#26438		;#0x6746

000069be <.LVL26>:
}
    69be:	30 41       	ret			

000069c0 <osalSysLock>:
  _disable_interrupts();
    69c0:	32 c2       	dint			
    69c2:	03 43       	nop			

000069c4 <.Loc.348.3>:
  asm volatile("nop");
    69c4:	03 43       	nop			

000069c6 <.LBE8>:
  chSysLock();
    69c6:	b0 12 f0 60 	call	#24816		;#0x60f0

000069ca <.LVL27>:
}
    69ca:	30 41       	ret			

000069cc <osalSysUnlock>:
  chSysUnlock();
    69cc:	b0 12 0e 61 	call	#24846		;#0x610e

000069d0 <.LBB12>:
  asm volatile("nop");
    69d0:	03 43       	nop			

000069d2 <.Loc.356.3>:
  _enable_interrupts();
    69d2:	03 43       	nop			
    69d4:	32 d2       	eint			
    69d6:	03 43       	nop			

000069d8 <.LBE12>:
}
    69d8:	30 41       	ret			

000069da <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    69da:	b0 12 38 6d 	call	#27960		;#0x6d38

000069de <.LVL29>:
}
    69de:	30 41       	ret			

000069e0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    69e0:	1a 15       	pushm	#2,	r10	;16-bit words

000069e2 <.LCFI1>:
    69e2:	21 83       	decd	r1		;

000069e4 <.LCFI2>:
    69e4:	0a 4c       	mov	r12,	r10	;
    69e6:	09 4e       	mov	r14,	r9	;

000069e8 <.Loc.133.2>:

  sdp->vmt = &vmt;
    69e8:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    69ec:	00 00 

000069ee <.LBB14>:
  esp->flags = 0;
    69ee:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    69f2:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

000069f6 <.Loc.811.1>:
  esp->cb    = NULL;
    69f6:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

000069fa <.Loc.812.1>:
  esp->param = NULL;
    69fa:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

000069fe <.LBE14>:
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    69fe:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

00006a02 <.Loc.136.2>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    6a02:	81 4c 00 00 	mov	r12,	0(r1)	;
    6a06:	0f 4d       	mov	r13,	r15	;
    6a08:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

00006a0c <.LVL33>:
    6a0c:	0d 4c       	mov	r12,	r13	;

00006a0e <.LVL34>:
    6a0e:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    6a12:	3c 50 0c 00 	add	#12,	r12	;#0x000c

00006a16 <.LVL35>:
    6a16:	b0 12 90 65 	call	#26000		;#0x6590

00006a1a <.LVL36>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    6a1a:	81 4a 00 00 	mov	r10,	0(r1)	;
    6a1e:	0f 49       	mov	r9,	r15	;
    6a20:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6a24:	0d 4a       	mov	r10,	r13	;
    6a26:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    6a2a:	0c 4a       	mov	r10,	r12	;
    6a2c:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6a30:	b0 12 20 67 	call	#26400		;#0x6720

00006a34 <.LVL37>:
}
    6a34:	21 53       	incd	r1		;
    6a36:	19 17       	popm	#2,	r10	;16-bit words
    6a38:	30 41       	ret			

00006a3a <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    6a3a:	0a 15       	pushm	#1,	r10	;16-bit words

00006a3c <.LCFI3>:
    6a3c:	21 83       	decd	r1		;

00006a3e <.LCFI4>:
    6a3e:	0a 4c       	mov	r12,	r10	;

00006a40 <.Loc.162.2>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    6a40:	81 4d 00 00 	mov	r13,	0(r1)	;
    6a44:	b0 12 c0 69 	call	#27072		;#0x69c0

00006a48 <.LVL39>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    6a48:	2d 41       	mov	@r1,	r13	;
    6a4a:	0c 4a       	mov	r10,	r12	;
    6a4c:	b0 12 48 6d 	call	#27976		;#0x6d48

00006a50 <.LVL40>:
  sdp->state = SD_READY;
    6a50:	ea 43 0a 00 	mov.b	#2,	10(r10)	;r3 As==10, 0x000a

00006a54 <.Loc.167.2>:
  osalSysUnlock();
    6a54:	b0 12 cc 69 	call	#27084		;#0x69cc

00006a58 <.LVL41>:
}
    6a58:	21 53       	incd	r1		;
    6a5a:	0a 17       	popm	#1,	r10	;16-bit words
    6a5c:	30 41       	ret			

00006a5e <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    6a5e:	1a 15       	pushm	#2,	r10	;16-bit words

00006a60 <.LCFI6>:
    6a60:	0a 4c       	mov	r12,	r10	;
    6a62:	49 4d       	mov.b	r13,	r9	;

00006a64 <.Loc.215.2>:

  osalDbgCheckClassI();
    6a64:	b0 12 bc 61 	call	#25020		;#0x61bc

00006a68 <.LVL50>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    6a68:	1c 4a 0e 00 	mov	14(r10),r12	;0x0000e
    6a6c:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a6e:	06 20       	jnz	$+14     	;abs 0x6a7c

00006a70 <.Loc.219.2>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    6a70:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6a72:	4e 43       	clr.b	r14		;
    6a74:	0c 4a       	mov	r10,	r12	;
    6a76:	2c 53       	incd	r12		;
    6a78:	b0 12 42 69 	call	#26946		;#0x6942

00006a7c <.L21>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    6a7c:	4d 49       	mov.b	r9,	r13	;
    6a7e:	0c 4a       	mov	r10,	r12	;
    6a80:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6a84:	b0 12 b6 65 	call	#26038		;#0x65b6

00006a88 <.LVL52>:
    6a88:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a8a:	07 34       	jge	$+16     	;abs 0x6a9a

00006a8c <.Loc.221.2>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    6a8c:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    6a90:	4e 43       	clr.b	r14		;
    6a92:	0c 4a       	mov	r10,	r12	;
    6a94:	2c 53       	incd	r12		;
    6a96:	b0 12 42 69 	call	#26946		;#0x6942

00006a9a <.L20>:
}
    6a9a:	19 17       	popm	#2,	r10	;16-bit words
    6a9c:	30 41       	ret			

00006a9e <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    6a9e:	1a 15       	pushm	#2,	r10	;16-bit words

00006aa0 <.LCFI7>:
    6aa0:	09 4c       	mov	r12,	r9	;

00006aa2 <.Loc.242.2>:
  msg_t  b;

  osalDbgCheckClassI();
    6aa2:	b0 12 bc 61 	call	#25020		;#0x61bc

00006aa6 <.LVL55>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    6aa6:	0c 49       	mov	r9,	r12	;
    6aa8:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6aac:	b0 12 b0 67 	call	#26544		;#0x67b0

00006ab0 <.LVL56>:
    6ab0:	0a 4c       	mov	r12,	r10	;

00006ab2 <.Loc.246.2>:
  if (b < MSG_OK)
    6ab2:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ab4:	06 34       	jge	$+14     	;abs 0x6ac2

00006ab6 <.Loc.247.2>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    6ab6:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6ab8:	4e 43       	clr.b	r14		;
    6aba:	0c 49       	mov	r9,	r12	;
    6abc:	2c 53       	incd	r12		;
    6abe:	b0 12 42 69 	call	#26946		;#0x6942

00006ac2 <.L23>:
  return b;
}
    6ac2:	0c 4a       	mov	r10,	r12	;
    6ac4:	19 17       	popm	#2,	r10	;16-bit words
    6ac6:	30 41       	ret			

00006ac8 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    6ac8:	b0 12 4e 71 	call	#29006		;#0x714e

00006acc <.LVL4>:
}
    6acc:	30 41       	ret			

00006ace <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    6ace:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00006ad2 <.Loc.71.3>:
  spip->config = NULL;
    6ad2:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006ad6 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    6ad6:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006ada <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    6ada:	30 41       	ret			

00006adc <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    6adc:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6ae0:	5c 01 

00006ae2 <.Loc.68.1>:
  FRCTL0 = FRCTLPW | NWAITS_1;
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    6ae2:	b2 40 00 a5 	mov	#-23296,&0x0160	;#0xa500
    6ae6:	60 01 

00006ae8 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    6ae8:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    6aec:	62 01 

00006aee <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    6aee:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    6af2:	64 01 

00006af4 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    6af4:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00006af8 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    6af8:	b2 40 c9 c1 	mov	#-15927,&0x0168	;#0xc1c9
    6afc:	68 01 

00006afe <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    6afe:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    6b02:	6c 01 

00006b04 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    6b04:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00006b08 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    6b08:	b0 12 5e 6f 	call	#28510		;#0x6f5e

00006b0c <.LVL0>:
#endif
}
    6b0c:	30 41       	ret			

00006b0e <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    6b0e:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    6b12:	d2 03 

00006b14 <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    6b14:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    6b18:	c2 03 

00006b1a <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    6b1a:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00006b1e <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    6b1e:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    6b22:	c0 03 

00006b24 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    6b24:	30 41       	ret			

00006b26 <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    6b26:	2a 15       	pushm	#3,	r10	;16-bit words

00006b28 <.LCFI0>:
  esp->flags |= flags;
    6b28:	28 4c       	mov	@r12,	r8	;
    6b2a:	19 4c 02 00 	mov	2(r12),	r9	;
    6b2e:	0a 4d       	mov	r13,	r10	;
    6b30:	0a d8       	bis	r8,	r10	;
    6b32:	0b 4e       	mov	r14,	r11	;
    6b34:	0b d9       	bis	r9,	r11	;
    6b36:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6b3a:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006b3e <.Loc.829.1>:
  if (esp->cb != NULL) {
    6b3e:	1d 4c 04 00 	mov	4(r12),	r13	;

00006b42 <.LVL1>:
    6b42:	0d 93       	cmp	#0,	r13	;r3 As==00
    6b44:	01 24       	jz	$+4      	;abs 0x6b48

00006b46 <.Loc.830.1>:
    esp->cb(esp);
    6b46:	8d 12       	call	r13		;

00006b48 <.L1>:
}
    6b48:	28 17       	popm	#3,	r10	;16-bit words
    6b4a:	30 41       	ret			

00006b4c <notify1>:
  UCA1IE |= UCTXIE;
    6b4c:	a2 d3 fa 05 	bis	#2,	&0x05fa	;r3 As==10

00006b50 <.Loc.288.2>:
}
    6b50:	30 41       	ret			

00006b52 <UCBRS>:
  if (frac < 529)
    6b52:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    6b56:	0d 9c       	cmp	r12,	r13	;
    6b58:	8b 2c       	jc	$+280    	;abs 0x6c70

00006b5a <.Loc.109.2>:
  else if (frac < 715)
    6b5a:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    6b5e:	0d 9c       	cmp	r12,	r13	;
    6b60:	89 2c       	jc	$+276    	;abs 0x6c74

00006b62 <.Loc.111.2>:
  else if (frac < 835)
    6b62:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    6b66:	0d 9c       	cmp	r12,	r13	;
    6b68:	87 2c       	jc	$+272    	;abs 0x6c78

00006b6a <.Loc.113.2>:
  else if (frac < 1001)
    6b6a:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    6b6e:	0d 9c       	cmp	r12,	r13	;
    6b70:	85 2c       	jc	$+268    	;abs 0x6c7c

00006b72 <.Loc.115.2>:
  else if (frac < 1252)
    6b72:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    6b76:	0d 9c       	cmp	r12,	r13	;
    6b78:	83 2c       	jc	$+264    	;abs 0x6c80

00006b7a <.Loc.117.2>:
  else if (frac < 1430)
    6b7a:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    6b7e:	0d 9c       	cmp	r12,	r13	;
    6b80:	81 2c       	jc	$+260    	;abs 0x6c84

00006b82 <.Loc.119.2>:
  else if (frac < 1670)
    6b82:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    6b86:	0d 9c       	cmp	r12,	r13	;
    6b88:	80 2c       	jc	$+258    	;abs 0x6c8a

00006b8a <.Loc.121.2>:
  else if (frac < 2147)
    6b8a:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    6b8e:	0d 9c       	cmp	r12,	r13	;
    6b90:	7f 2c       	jc	$+256    	;abs 0x6c90

00006b92 <.Loc.123.2>:
  else if (frac < 2224)
    6b92:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    6b96:	0d 9c       	cmp	r12,	r13	;
    6b98:	7e 2c       	jc	$+254    	;abs 0x6c96

00006b9a <.Loc.125.2>:
  else if (frac < 2503)
    6b9a:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    6b9e:	0d 9c       	cmp	r12,	r13	;
    6ba0:	7d 2c       	jc	$+252    	;abs 0x6c9c

00006ba2 <.Loc.127.2>:
  else if (frac < 3000)
    6ba2:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    6ba6:	0d 9c       	cmp	r12,	r13	;
    6ba8:	7c 2c       	jc	$+250    	;abs 0x6ca2

00006baa <.LBB30>:
  else if (frac < 3335)
    6baa:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    6bae:	0d 9c       	cmp	r12,	r13	;
    6bb0:	7b 2c       	jc	$+248    	;abs 0x6ca8

00006bb2 <.Loc.131.2>:
  else if (frac < 3575)
    6bb2:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    6bb6:	0d 9c       	cmp	r12,	r13	;
    6bb8:	7a 2c       	jc	$+246    	;abs 0x6cae

00006bba <.Loc.133.2>:
  else if (frac < 3753)
    6bba:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    6bbe:	0d 9c       	cmp	r12,	r13	;
    6bc0:	79 2c       	jc	$+244    	;abs 0x6cb4

00006bc2 <.Loc.135.2>:
  else if (frac < 4003)
    6bc2:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    6bc6:	0d 9c       	cmp	r12,	r13	;
    6bc8:	78 2c       	jc	$+242    	;abs 0x6cba

00006bca <.Loc.137.2>:
  else if (frac < 4286)
    6bca:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    6bce:	0d 9c       	cmp	r12,	r13	;
    6bd0:	77 2c       	jc	$+240    	;abs 0x6cc0

00006bd2 <.Loc.139.2>:
  else if (frac < 4378)
    6bd2:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    6bd6:	0d 9c       	cmp	r12,	r13	;
    6bd8:	76 2c       	jc	$+238    	;abs 0x6cc6

00006bda <.Loc.141.2>:
  else if (frac < 5002)
    6bda:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    6bde:	0d 9c       	cmp	r12,	r13	;
    6be0:	75 2c       	jc	$+236    	;abs 0x6ccc

00006be2 <.Loc.143.2>:
  else if (frac < 5715)
    6be2:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    6be6:	0d 9c       	cmp	r12,	r13	;
    6be8:	74 2c       	jc	$+234    	;abs 0x6cd2

00006bea <.Loc.145.2>:
  else if (frac < 6003)
    6bea:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    6bee:	0d 9c       	cmp	r12,	r13	;
    6bf0:	73 2c       	jc	$+232    	;abs 0x6cd8

00006bf2 <.Loc.147.2>:
  else if (frac < 6254)
    6bf2:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    6bf6:	0d 9c       	cmp	r12,	r13	;
    6bf8:	72 2c       	jc	$+230    	;abs 0x6cde

00006bfa <.Loc.149.2>:
  else if (frac < 6432)
    6bfa:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    6bfe:	0d 9c       	cmp	r12,	r13	;
    6c00:	71 2c       	jc	$+228    	;abs 0x6ce4

00006c02 <.Loc.151.2>:
  else if (frac < 6667)
    6c02:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    6c06:	0d 9c       	cmp	r12,	r13	;
    6c08:	70 2c       	jc	$+226    	;abs 0x6cea

00006c0a <.Loc.153.2>:
  else if (frac < 7001)
    6c0a:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    6c0e:	0d 9c       	cmp	r12,	r13	;
    6c10:	6f 2c       	jc	$+224    	;abs 0x6cf0

00006c12 <.Loc.155.2>:
  else if (frac < 7147)
    6c12:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    6c16:	0d 9c       	cmp	r12,	r13	;
    6c18:	6e 2c       	jc	$+222    	;abs 0x6cf6

00006c1a <.Loc.157.2>:
  else if (frac < 7503)
    6c1a:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    6c1e:	0d 9c       	cmp	r12,	r13	;
    6c20:	6d 2c       	jc	$+220    	;abs 0x6cfc

00006c22 <.Loc.159.2>:
  else if (frac < 7861)
    6c22:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    6c26:	0d 9c       	cmp	r12,	r13	;
    6c28:	6c 2c       	jc	$+218    	;abs 0x6d02

00006c2a <.Loc.161.2>:
  else if (frac < 8004)
    6c2a:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    6c2e:	0d 9c       	cmp	r12,	r13	;
    6c30:	6b 2c       	jc	$+216    	;abs 0x6d08

00006c32 <.Loc.163.2>:
  else if (frac < 8333)
    6c32:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    6c36:	0d 9c       	cmp	r12,	r13	;
    6c38:	6a 2c       	jc	$+214    	;abs 0x6d0e

00006c3a <.Loc.165.2>:
  else if (frac < 8464)
    6c3a:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    6c3e:	0d 9c       	cmp	r12,	r13	;
    6c40:	69 2c       	jc	$+212    	;abs 0x6d14

00006c42 <.Loc.167.2>:
  else if (frac < 8572)
    6c42:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    6c46:	0d 9c       	cmp	r12,	r13	;
    6c48:	68 2c       	jc	$+210    	;abs 0x6d1a

00006c4a <.Loc.169.2>:
  else if (frac < 8751)
    6c4a:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    6c4e:	0d 9c       	cmp	r12,	r13	;
    6c50:	67 2c       	jc	$+208    	;abs 0x6d20

00006c52 <.Loc.171.2>:
  else if (frac < 9004)
    6c52:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    6c56:	0d 9c       	cmp	r12,	r13	;
    6c58:	66 2c       	jc	$+206    	;abs 0x6d26

00006c5a <.Loc.173.2>:
  else if (frac < 9170)
    6c5a:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    6c5e:	0d 9c       	cmp	r12,	r13	;
    6c60:	65 2c       	jc	$+204    	;abs 0x6d2c

00006c62 <.Loc.175.2>:
  else if (frac < 9288)
    6c62:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    6c66:	0d 9c       	cmp	r12,	r13	;
    6c68:	64 2c       	jc	$+202    	;abs 0x6d32

00006c6a <.Loc.178.2>:
    return 0xFE;
    6c6a:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00006c6e <.L8>:
}
    6c6e:	30 41       	ret			

00006c70 <.L9>:
    return 0x00;
    6c70:	4c 43       	clr.b	r12		;

00006c72 <.LVL8>:
    6c72:	fd 3f       	jmp	$-4      	;abs 0x6c6e

00006c74 <.L10>:
    return 0x01;
    6c74:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006c76 <.LVL10>:
    6c76:	fb 3f       	jmp	$-8      	;abs 0x6c6e

00006c78 <.L11>:
    return 0x02;
    6c78:	6c 43       	mov.b	#2,	r12	;r3 As==10

00006c7a <.LVL12>:
    6c7a:	f9 3f       	jmp	$-12     	;abs 0x6c6e

00006c7c <.L12>:
    return 0x04;
    6c7c:	6c 42       	mov.b	#4,	r12	;r2 As==10

00006c7e <.LVL14>:
    6c7e:	f7 3f       	jmp	$-16     	;abs 0x6c6e

00006c80 <.L13>:
    return 0x08;
    6c80:	7c 42       	mov.b	#8,	r12	;r2 As==11

00006c82 <.LVL16>:
    6c82:	f5 3f       	jmp	$-20     	;abs 0x6c6e

00006c84 <.L14>:
    return 0x10;
    6c84:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

00006c88 <.LVL18>:
    6c88:	f2 3f       	jmp	$-26     	;abs 0x6c6e

00006c8a <.L15>:
    return 0x20;
    6c8a:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

00006c8e <.LVL20>:
    6c8e:	ef 3f       	jmp	$-32     	;abs 0x6c6e

00006c90 <.L16>:
    return 0x11;
    6c90:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

00006c94 <.LVL22>:
    6c94:	ec 3f       	jmp	$-38     	;abs 0x6c6e

00006c96 <.L17>:
    return 0x21;
    6c96:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

00006c9a <.LVL24>:
    6c9a:	e9 3f       	jmp	$-44     	;abs 0x6c6e

00006c9c <.L18>:
    return 0x22;
    6c9c:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

00006ca0 <.LVL26>:
    6ca0:	e6 3f       	jmp	$-50     	;abs 0x6c6e

00006ca2 <.L19>:
    return 0x44;
    6ca2:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

00006ca6 <.LVL28>:
    6ca6:	e3 3f       	jmp	$-56     	;abs 0x6c6e

00006ca8 <.L20>:
    return 0x25;
    6ca8:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

00006cac <.LVL30>:
    6cac:	e0 3f       	jmp	$-62     	;abs 0x6c6e

00006cae <.L21>:
    return 0x49;
    6cae:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

00006cb2 <.LVL32>:
    6cb2:	dd 3f       	jmp	$-68     	;abs 0x6c6e

00006cb4 <.L22>:
    return 0x4A;
    6cb4:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

00006cb8 <.LVL34>:
    6cb8:	da 3f       	jmp	$-74     	;abs 0x6c6e

00006cba <.L23>:
    return 0x52;
    6cba:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

00006cbe <.LVL36>:
    6cbe:	d7 3f       	jmp	$-80     	;abs 0x6c6e

00006cc0 <.L24>:
    return 0x92;
    6cc0:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

00006cc4 <.LVL38>:
    6cc4:	d4 3f       	jmp	$-86     	;abs 0x6c6e

00006cc6 <.L25>:
    return 0x53;
    6cc6:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

00006cca <.LVL40>:
    6cca:	d1 3f       	jmp	$-92     	;abs 0x6c6e

00006ccc <.L26>:
    return 0x55;
    6ccc:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

00006cd0 <.LVL42>:
    6cd0:	ce 3f       	jmp	$-98     	;abs 0x6c6e

00006cd2 <.L27>:
    return 0xAA;
    6cd2:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

00006cd6 <.LVL44>:
    6cd6:	cb 3f       	jmp	$-104    	;abs 0x6c6e

00006cd8 <.L28>:
    return 0x6B;
    6cd8:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

00006cdc <.LVL46>:
    6cdc:	c8 3f       	jmp	$-110    	;abs 0x6c6e

00006cde <.L29>:
    return 0xAD;
    6cde:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

00006ce2 <.LVL48>:
    6ce2:	c5 3f       	jmp	$-116    	;abs 0x6c6e

00006ce4 <.L30>:
    return 0xB5;
    6ce4:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

00006ce8 <.LVL50>:
    6ce8:	c2 3f       	jmp	$-122    	;abs 0x6c6e

00006cea <.L31>:
    return 0xB6;
    6cea:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

00006cee <.LVL52>:
    6cee:	bf 3f       	jmp	$-128    	;abs 0x6c6e

00006cf0 <.L32>:
    return 0xD6;
    6cf0:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00006cf4 <.LVL54>:
    6cf4:	bc 3f       	jmp	$-134    	;abs 0x6c6e

00006cf6 <.L33>:
    return 0xB7;
    6cf6:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00006cfa <.LVL56>:
    6cfa:	b9 3f       	jmp	$-140    	;abs 0x6c6e

00006cfc <.L34>:
    return 0xBB;
    6cfc:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

00006d00 <.LVL58>:
    6d00:	b6 3f       	jmp	$-146    	;abs 0x6c6e

00006d02 <.L35>:
    return 0xDD;
    6d02:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00006d06 <.LVL60>:
    6d06:	b3 3f       	jmp	$-152    	;abs 0x6c6e

00006d08 <.L36>:
    return 0xED;
    6d08:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00006d0c <.LVL62>:
    6d0c:	b0 3f       	jmp	$-158    	;abs 0x6c6e

00006d0e <.L37>:
    return 0xEE;
    6d0e:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

00006d12 <.LVL64>:
    6d12:	ad 3f       	jmp	$-164    	;abs 0x6c6e

00006d14 <.L38>:
    return 0xBF;
    6d14:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

00006d18 <.LVL66>:
    6d18:	aa 3f       	jmp	$-170    	;abs 0x6c6e

00006d1a <.L39>:
    return 0xDF;
    6d1a:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

00006d1e <.LVL68>:
    6d1e:	a7 3f       	jmp	$-176    	;abs 0x6c6e

00006d20 <.L40>:
    return 0xEF;
    6d20:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

00006d24 <.LVL70>:
    6d24:	a4 3f       	jmp	$-182    	;abs 0x6c6e

00006d26 <.L41>:
    return 0xF7;
    6d26:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00006d2a <.LVL72>:
    6d2a:	a1 3f       	jmp	$-188    	;abs 0x6c6e

00006d2c <.L42>:
    return 0xFB;
    6d2c:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

00006d30 <.LVL74>:
    6d30:	9e 3f       	jmp	$-194    	;abs 0x6c6e

00006d32 <.L43>:
    return 0xFD;
    6d32:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

00006d36 <.LVL76>:
    6d36:	9b 3f       	jmp	$-200    	;abs 0x6c6e

00006d38 <sd_lld_init>:
    6d38:	3e 40 4c 6b 	mov	#27468,	r14	;#0x6b4c
#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
#endif

#if MSP430X_SERIAL_USE_USART1 == TRUE
  sdObjectInit(&SD1, NULL, notify1);
    6d3c:	4d 43       	clr.b	r13		;
    6d3e:	3c 40 fa 51 	mov	#20986,	r12	;#0x51fa
    6d42:	b0 12 e0 69 	call	#27104		;#0x69e0

00006d46 <.LVL104>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    6d46:	30 41       	ret			

00006d48 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    6d48:	5a 15       	pushm	#6,	r10	;16-bit words

00006d4a <.LCFI2>:

  if (config == NULL) {
    6d4a:	0d 93       	cmp	#0,	r13	;r3 As==00
    6d4c:	1a 24       	jz	$+54     	;abs 0x6d82

00006d4e <.Loc.613.2>:
  if (&SD0 == sdp) {
    usart0_init(config);
  }
#endif
#if MSP430X_SERIAL_USE_USART1 == TRUE
  if (&SD1 == sdp) {
    6d4e:	3c 90 fa 51 	cmp	#20986,	r12	;#0x51fa
    6d52:	5d 20       	jnz	$+188    	;abs 0x6e0e

00006d54 <.LBB76>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    6d54:	28 4d       	mov	@r13,	r8	;
    6d56:	19 4d 02 00 	mov	2(r13),	r9	;

00006d5a <.LBB78>:
  uint16_t n = freq / baud;
    6d5a:	0e 48       	mov	r8,	r14	;
    6d5c:	0f 49       	mov	r9,	r15	;
    6d5e:	3c 40 00 12 	mov	#4608,	r12	;#0x1200

00006d62 <.LVL108>:
    6d62:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a

00006d66 <.LVL109>:
    6d66:	b0 12 82 7b 	call	#31618		;#0x7b82

00006d6a <.LVL110>:
    6d6a:	0b 4c       	mov	r12,	r11	;
    6d6c:	0d 4c       	mov	r12,	r13	;

00006d6e <.LVL111>:
  if (n > 16) {
    6d6e:	76 40 10 00 	mov.b	#16,	r6	;#0x0010
    6d72:	06 9b       	cmp	r11,	r6	;
    6d74:	0f 28       	jnc	$+32     	;abs 0x6d94
    6d76:	0a 4c       	mov	r12,	r10	;
    6d78:	0f 3c       	jmp	$+32     	;abs 0x6d98

00006d7a <.L78>:
  return UCBRS(frac) << 8;
    6d7a:	8e 12       	call	r14		;

00006d7c <.LVL113>:
    6d7c:	47 18 0c 5c 	.word	0x1847, 0xffff;	????

00006d7e <L0>:
    6d7e:	0c 5c       	rla	r12		;
    6d80:	39 3c       	jmp	$+116    	;abs 0x6df4

00006d82 <.L75>:
  if (&SD1 == sdp) {
    6d82:	3c 90 fa 51 	cmp	#20986,	r12	;#0x51fa
    6d86:	43 20       	jnz	$+136    	;abs 0x6e0e

00006d88 <.LBB85>:
  uint16_t n = freq / baud;
    6d88:	7d 40 d0 00 	mov.b	#208,	r13	;#0x00d0
    6d8c:	0b 4d       	mov	r13,	r11	;

00006d8e <.LBE85>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    6d8e:	38 40 00 96 	mov	#-27136,r8	;#0x9600
    6d92:	49 43       	clr.b	r9		;

00006d94 <.L80>:
    return n >> 4;
    6d94:	0a 4d       	mov	r13,	r10	;
    6d96:	5d 0f       	rrum	#4,	r13	;

00006d98 <.L77>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    6d98:	82 4d e6 05 	mov	r13,	&0x05e6	;

00006d9c <.LBB87>:
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    6d9c:	35 40 4e 7d 	mov	#32078,	r5	;#0x7d4e
    6da0:	0e 48       	mov	r8,	r14	;
    6da2:	0f 49       	mov	r9,	r15	;
    6da4:	0c 4b       	mov	r11,	r12	;
    6da6:	4d 43       	clr.b	r13		;
    6da8:	85 12       	call	r5		;

00006daa <.LVL118>:
    6daa:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    6dae:	4f 43       	clr.b	r15		;
    6db0:	36 40 00 12 	mov	#4608,	r6	;#0x1200
    6db4:	77 40 7a 00 	mov.b	#122,	r7	;#0x007a
    6db8:	06 8c       	sub	r12,	r6	;
    6dba:	07 7d       	subc	r13,	r7	;
    6dbc:	0c 46       	mov	r6,	r12	;
    6dbe:	0d 47       	mov	r7,	r13	;
    6dc0:	85 12       	call	r5		;

00006dc2 <.LVL119>:
    6dc2:	0e 48       	mov	r8,	r14	;
    6dc4:	0f 49       	mov	r9,	r15	;
    6dc6:	b0 12 82 7b 	call	#31618		;#0x7b82

00006dca <.LVL120>:
    6dca:	3e 40 52 6b 	mov	#27474,	r14	;#0x6b52

00006dce <.Loc.194.2>:
  if (n > 16) {
    6dce:	77 40 10 00 	mov.b	#16,	r7	;#0x0010
    6dd2:	07 9a       	cmp	r10,	r7	;
    6dd4:	d2 2f       	jc	$-90     	;abs 0x6d7a

00006dd6 <.LVL121>:
    6dd6:	0d 4a       	mov	r10,	r13	;
    6dd8:	3d 50 ef ff 	add	#-17,	r13	;#0xffef
    6ddc:	3d f0 f0 ff 	and	#-16,	r13	;#0xfff0
    6de0:	3a 50 f0 ff 	add	#-16,	r10	;#0xfff0
    6de4:	0a 8d       	sub	r13,	r10	;

00006de6 <.Loc.198.2>:
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    6de6:	8e 12       	call	r14		;

00006de8 <.LVL122>:
    6de8:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    6dec:	1a d3       	bis	#1,	r10	;r3 As==01
    6dee:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6df2:	0c da       	bis	r10,	r12	;

00006df4 <.L79>:
  UCA1MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    6df4:	82 4c e8 05 	mov	r12,	&0x05e8	;

00006df8 <.Loc.237.2>:
  UCA1STATW = 0;
    6df8:	c2 43 ea 05 	mov.b	#0,	&0x05ea	;r3 As==00

00006dfc <.Loc.238.2>:
  UCA1ABCTL = 0;
    6dfc:	c2 43 f0 05 	mov.b	#0,	&0x05f0	;r3 As==00

00006e00 <.Loc.239.2>:
  UCA1IRCTL = 0;
    6e00:	82 43 f2 05 	mov	#0,	&0x05f2	;r3 As==00

00006e04 <.Loc.240.2>:
  UCA1CTLW0 = (MSP430X_USART1_PARITY << 14) | (MSP430X_USART1_ORDER << 13) |
    6e04:	b2 40 80 00 	mov	#128,	&0x05e0	;#0x0080
    6e08:	e0 05 

00006e0a <.Loc.243.2>:
  UCA1IE = UCRXIE;
    6e0a:	92 43 fa 05 	mov	#1,	&0x05fa	;r3 As==01

00006e0e <.L74>:
#if MSP430X_SERIAL_USE_USART3 == TRUE
  if (&SD3 == sdp) {
    usart3_init(config);
  }
#endif
}
    6e0e:	55 17       	popm	#6,	r10	;16-bit words
    6e10:	30 41       	ret			

00006e12 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    6e12:	a2 4c 02 02 	mov	@r12,	&0x0202	;

00006e16 <L0>:
  PADIR = config->porta.dir;
    6e16:	92 4c 02 00 	mov	2(r12),	&0x0204	;
    6e1a:	04 02 

00006e1c <.Loc.311.1>:
  PAREN = config->porta.ren;
    6e1c:	92 4c 04 00 	mov	4(r12),	&0x0206	;
    6e20:	06 02 

00006e22 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    6e22:	92 4c 06 00 	mov	6(r12),	&0x020a	;
    6e26:	0a 02 

00006e28 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    6e28:	92 4c 08 00 	mov	8(r12),	&0x020c	;
    6e2c:	0c 02 

00006e2e <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    6e2e:	92 4c 0a 00 	mov	10(r12),&0x0222	;0x0000a
    6e32:	22 02 

00006e34 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    6e34:	92 4c 0c 00 	mov	12(r12),&0x0224	;0x0000c
    6e38:	24 02 

00006e3a <.Loc.317.1>:
  PBREN = config->portb.ren;
    6e3a:	92 4c 0e 00 	mov	14(r12),&0x0226	;0x0000e
    6e3e:	26 02 

00006e40 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    6e40:	92 4c 10 00 	mov	16(r12),&0x022a	;0x00010
    6e44:	2a 02 

00006e46 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    6e46:	92 4c 12 00 	mov	18(r12),&0x022c	;0x00012
    6e4a:	2c 02 

00006e4c <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    6e4c:	92 4c 14 00 	mov	20(r12),&0x0322	;0x00014
    6e50:	22 03 

00006e52 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    6e52:	92 4c 16 00 	mov	22(r12),&0x0324	;0x00016
    6e56:	24 03 

00006e58 <.Loc.351.1>:
  PJREN = config->portj.ren;
    6e58:	92 4c 18 00 	mov	24(r12),&0x0326	;0x00018
    6e5c:	26 03 

00006e5e <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    6e5e:	92 4c 1a 00 	mov	26(r12),&0x032a	;0x0001a
    6e62:	2a 03 

00006e64 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    6e64:	92 4c 1c 00 	mov	28(r12),&0x032c	;0x0001c
    6e68:	2c 03 

00006e6a <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    6e6a:	92 c3 30 01 	bic	#1,	&0x0130	;r3 As==01

00006e6e <.Loc.356.1>:
}
    6e6e:	30 41       	ret			

00006e70 <_pal_lld_enablepadevent>:
      break;
  }
}

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    6e70:	2a 15       	pushm	#3,	r10	;16-bit words

00006e72 <.LCFI4>:
    6e72:	0a 4c       	mov	r12,	r10	;
    6e74:	49 4d       	mov.b	r13,	r9	;
    6e76:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00006e7a <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    6e7a:	43 18 0c 11 	rpt #4 { rrax.w	r12		;

00006e7e <.LVL53>:
    6e7e:	4d 4c       	mov.b	r12,	r13	;

00006e80 <.LVL54>:
    6e80:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    6e84:	7c 40 07 00 	mov.b	#7,	r12	;
    6e88:	4c 99       	cmp.b	r9,	r12	;
    6e8a:	25 28       	jnc	$+76     	;abs 0x6ed6
    6e8c:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006e8e <.L108>:
    6e8e:	4c 5d       	add.b	r13,	r12	;

00006e90 <.LVL56>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    6e90:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6e94:	3c 53       	add	#-1,	r12	;r3 As==11
    6e96:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    6e9a:	0d 49       	mov	r9,	r13	;
    6e9c:	7d f0 07 00 	and.b	#7,	r13	;
    6ea0:	0c 5d       	add	r13,	r12	;
    6ea2:	0c 5c       	rla	r12		;
    6ea4:	8c 4f 46 52 	mov	r15,	21062(r12); 0x5246

00006ea8 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    6ea8:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    6eaa:	17 20       	jnz	$+48     	;abs 0x6eda

00006eac <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    6eac:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    6eb0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6eb2:	0d 49       	mov	r9,	r13	;
    6eb4:	b0 12 c2 7b 	call	#31682		;#0x7bc2

00006eb8 <.LVL57>:
    6eb8:	08 cc       	bic	r12,	r8	;
    6eba:	8a 48 18 00 	mov	r8,	24(r10)	; 0x0018

00006ebe <.L110>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    6ebe:	18 4a 1c 00 	mov	28(r10),r8	;0x0001c
    6ec2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ec4:	0d 49       	mov	r9,	r13	;
    6ec6:	b0 12 c2 7b 	call	#31682		;#0x7bc2
    6eca:	08 cc       	bic	r12,	r8	;
    6ecc:	8a 48 1c 00 	mov	r8,	28(r10)	; 0x001c

00006ed0 <.Loc.464.1>:
    port->ie |= (1 << pad);
    6ed0:	8a dc 1a 00 	bis	r12,	26(r10)	; 0x001a

00006ed4 <.Loc.466.1>:
  }
}
    6ed4:	19 3c       	jmp	$+52     	;abs 0x6f08

00006ed6 <.L113>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    6ed6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6ed8:	da 3f       	jmp	$-74     	;abs 0x6e8e

00006eda <.L109>:
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    6eda:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    6edc:	0a 20       	jnz	$+22     	;abs 0x6ef2

00006ede <.Loc.456.1>:
    port->ies |= (1 << pad);
    6ede:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    6ee2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ee4:	0d 49       	mov	r9,	r13	;
    6ee6:	b0 12 c2 7b 	call	#31682		;#0x7bc2

00006eea <.LVL60>:
    6eea:	0c d8       	bis	r8,	r12	;
    6eec:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018
    6ef0:	e6 3f       	jmp	$-50     	;abs 0x6ebe

00006ef2 <.L111>:
  if (mode == PAL_EVENT_MODE_DISABLED) {
    6ef2:	0e 93       	cmp	#0,	r14	;r3 As==00
    6ef4:	e4 23       	jnz	$-54     	;abs 0x6ebe

00006ef6 <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    6ef6:	18 4a 1a 00 	mov	26(r10),r8	;0x0001a
    6efa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6efc:	0d 49       	mov	r9,	r13	;
    6efe:	b0 12 c2 7b 	call	#31682		;#0x7bc2

00006f02 <.LVL62>:
    6f02:	08 cc       	bic	r12,	r8	;
    6f04:	8a 48 1a 00 	mov	r8,	26(r10)	; 0x001a

00006f08 <.L107>:
}
    6f08:	28 17       	popm	#3,	r10	;16-bit words
    6f0a:	30 41       	ret			

00006f0c <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    6f0c:	1a 15       	pushm	#2,	r10	;16-bit words

00006f0e <.LCFI5>:
    6f0e:	0a 4c       	mov	r12,	r10	;

00006f10 <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    6f10:	19 4c       	mov,		r9	;Warning: disassembly unreliable - not enough bytes available

00006f12 <L0>:
    6f12:	1a 00       	mova	@r0+,	r10	;
    6f14:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006f16 <.LVL64>:
    6f16:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    6f1a:	b0 12 c2 7b 	call	#31682		;#0x7bc2

00006f1e <.LVL65>:
    6f1e:	09 cc       	bic	r12,	r9	;
    6f20:	8a 49 1a 00 	mov	r9,	26(r10)	; 0x001a

00006f24 <.Loc.471.1>:
}
    6f24:	19 17       	popm	#2,	r10	;16-bit words
    6f26:	30 41       	ret			

00006f28 <dma_trigger_set>:
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    6f28:	3a 15       	pushm	#4,	r10	;16-bit words

00006f2a <.LCFI0>:
    6f2a:	4a 4c       	mov.b	r12,	r10	;
    6f2c:	47 4d       	mov.b	r13,	r7	;

00006f2e <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    6f2e:	09 4a       	mov	r10,	r9	;
    6f30:	79 f0 fe 00 	and.b	#254,	r9	;#0x00fe
    6f34:	39 50 00 05 	add	#1280,	r9	;#0x0500

00006f38 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    6f38:	5a f3       	and.b	#1,	r10	;r3 As==01
    6f3a:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    6f3e:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

00006f42 <.LVL2>:
    6f42:	0d 4a       	mov	r10,	r13	;

00006f44 <.LVL3>:
    6f44:	b0 12 ca 7c 	call	#31946		;#0x7cca
    6f48:	08 4c       	mov	r12,	r8	;
    6f4a:	28 f9       	and	@r9,	r8	;

00006f4c <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    6f4c:	0c 47       	mov	r7,	r12	;
    6f4e:	0d 4a       	mov	r10,	r13	;
    6f50:	b0 12 c2 7b 	call	#31682		;#0x7bc2
    6f54:	08 dc       	bis	r12,	r8	;
    6f56:	89 48 00 00 	mov	r8,	0(r9)	;

00006f5a <.Loc.65.1>:
}
    6f5a:	37 17       	popm	#4,	r10	;16-bit words
    6f5c:	30 41       	ret			

00006f5e <dmaInit>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6f5e:	82 43 e4 5c 	mov	#0,	&0x5ce4	;r3 As==00

00006f62 <.LBE11>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    6f62:	30 41       	ret			

00006f64 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    6f64:	2a 15       	pushm	#3,	r10	;16-bit words

00006f66 <.LCFI2>:
    6f66:	09 4c       	mov	r12,	r9	;

00006f68 <.LVL21>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    6f68:	1a 42 10 05 	mov	&0x0510,r10	;0x0510
    6f6c:	7a f0 10 00 	and.b	#16,	r10	;#0x0010
    6f70:	0a 93       	cmp	#0,	r10	;r3 As==00
    6f72:	0e 24       	jz	$+30     	;abs 0x6f90

00006f74 <.LVL22>:
    6f74:	3c 40 20 05 	mov	#1312,	r12	;#0x0520

00006f78 <.LVL23>:
    6f78:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    6f7c:	00 00 
    6f7e:	07 24       	jz	$+16     	;abs 0x6f8e

00006f80 <.LVL24>:
    6f80:	bc b0 10 00 	bit	#16,	16(r12)	;#0x0010, 0x0010
    6f84:	10 00 
    6f86:	18 24       	jz	$+50     	;abs 0x6fb8

00006f88 <.Loc.198.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    6f88:	3c 43       	mov	#-1,	r12	;r3 As==11

00006f8a <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    6f8a:	28 17       	popm	#3,	r10	;16-bit words
    6f8c:	30 41       	ret			

00006f8e <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    6f8e:	5a 43       	mov.b	#1,	r10	;r3 As==01

00006f90 <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    6f90:	48 4a       	mov.b	r10,	r8	;
    6f92:	4d 43       	clr.b	r13		;
    6f94:	4c 48       	mov.b	r8,	r12	;
    6f96:	b0 12 28 6f 	call	#28456		;#0x6f28

00006f9a <.LVL28>:
  dma_regs[i].sz  = 0;
    6f9a:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    6f9e:	3a 50 10 05 	add	#1296,	r10	;#0x0510
    6fa2:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

00006fa6 <.Loc.204.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    6fa6:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    6faa:	00 00 

00006fac <.Loc.206.1>:
  channel->registers = dma_regs + i;
    6fac:	89 4a 00 00 	mov	r10,	0(r9)	;

00006fb0 <.Loc.207.1>:
  channel->index     = i;
    6fb0:	c9 48 02 00 	mov.b	r8,	2(r9)	;

00006fb4 <.Loc.209.1>:
  return MSG_OK;
    6fb4:	4c 43       	clr.b	r12		;
    6fb6:	e9 3f       	jmp	$-44     	;abs 0x6f8a

00006fb8 <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    6fb8:	6a 43       	mov.b	#2,	r10	;r3 As==10
    6fba:	ea 3f       	jmp	$-42     	;abs 0x6f90

00006fbc <dmaAcquireTimeoutS>:
    6fbc:	21 82       	sub	#4,	r1	;r2 As==10

00006fbe <.LCFI3>:
  osalDbgCheckClassS();
    6fbe:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

00006fc0 <L0>:
    6fc0:	02 00       	mova	@r0,	r2	;
    6fc2:	81 4d 00 00 	mov	r13,	0(r1)	;
    6fc6:	b0 12 d8 61 	call	#25048		;#0x61d8

00006fca <.LVL31>:
  msg_t result = dmaAcquireI(channel);
    6fca:	1c 41 02 00 	mov	2(r1),	r12	;
    6fce:	b0 12 64 6f 	call	#28516		;#0x6f64

00006fd2 <.LVL32>:
  if (MSG_OK != result) {
    6fd2:	2d 41       	mov	@r1,	r13	;
    6fd4:	0c 93       	cmp	#0,	r12	;r3 As==00
    6fd6:	06 24       	jz	$+14     	;abs 0x6fe4

00006fd8 <.Loc.166.1>:
    if (TIME_IMMEDIATE == timeout) {
    6fd8:	3d 93       	cmp	#-1,	r13	;r3 As==11
    6fda:	06 24       	jz	$+14     	;abs 0x6fe8

00006fdc <.LBB13>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    6fdc:	3c 40 e4 5c 	mov	#23780,	r12	;#0x5ce4

00006fe0 <.LVL34>:
    6fe0:	b0 12 3a 64 	call	#25658		;#0x643a

00006fe4 <.L20>:
}
    6fe4:	21 52       	add	#4,	r1	;r2 As==10
    6fe6:	30 41       	ret			

00006fe8 <.L22>:
      return MSG_TIMEOUT;
    6fe8:	0c 4d       	mov	r13,	r12	;

00006fea <.LVL37>:
    6fea:	fc 3f       	jmp	$-6      	;abs 0x6fe4

00006fec <dmaClaimI>:
    6fec:	3a 15       	pushm	#4,	r10	;16-bit words

00006fee <L0>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    6fee:	07 4c       	mov	r12,	r7	;
    6ff0:	48 4d       	mov.b	r13,	r8	;

00006ff2 <.Loc.230.1>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_regs[index].ctl & DMAEN) {
    6ff2:	09 48       	mov	r8,	r9	;
    6ff4:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    6ff8:	39 50 10 05 	add	#1296,	r9	;#0x0510
    6ffc:	2a 49       	mov	@r9,	r10	;
    6ffe:	7a f0 10 00 	and.b	#16,	r10	;#0x0010
    7002:	0a 93       	cmp	#0,	r10	;r3 As==00
    7004:	10 20       	jnz	$+34     	;abs 0x7026

00007006 <.Loc.235.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    7006:	4d 4a       	mov.b	r10,	r13	;

00007008 <.LVL39>:
    7008:	4c 48       	mov.b	r8,	r12	;

0000700a <.LVL40>:
    700a:	b0 12 28 6f 	call	#28456		;#0x6f28

0000700e <.LVL41>:
  dma_regs[index].sz  = 0;
    700e:	89 4a 0a 00 	mov	r10,	10(r9)	; 0x000a

00007012 <.Loc.237.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    7012:	b9 40 12 00 	mov	#18,	0(r9)	;#0x0012
    7016:	00 00 

00007018 <.Loc.239.1>:

  channel->registers = dma_regs + index;
    7018:	87 49 00 00 	mov	r9,	0(r7)	;

0000701c <.Loc.240.1>:
  channel->index     = index;
    701c:	c7 48 02 00 	mov.b	r8,	2(r7)	;

00007020 <.Loc.242.1>:
  
  return MSG_OK;
    7020:	0c 4a       	mov	r10,	r12	;

00007022 <.L26>:
}
    7022:	37 17       	popm	#4,	r10	;16-bit words
    7024:	30 41       	ret			

00007026 <.L28>:
    return MSG_TIMEOUT;
    7026:	3c 43       	mov	#-1,	r12	;r3 As==11
    7028:	fc 3f       	jmp	$-6      	;abs 0x7022

0000702a <dmaTransferI>:
    702a:	1a 15       	pushm	#2,	r10	;16-bit words

0000702c <L0>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    702c:	09 4c       	mov	r12,	r9	;
    702e:	0a 4d       	mov	r13,	r10	;

00007030 <.Loc.273.1>:


  channel->registers->ctl &= (~DMAEN);
    7030:	2c 4c       	mov	@r12,	r12	;

00007032 <.LVL44>:
    7032:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    7036:	00 00 

00007038 <.Loc.274.1>:
  dma_trigger_set(channel->index, request->trigger);
    7038:	5d 4d 0c 00 	mov.b	12(r13),r13	;0x0000c

0000703c <.LVL45>:
    703c:	5c 49 02 00 	mov.b	2(r9),	r12	;
    7040:	b0 12 28 6f 	call	#28456		;#0x6f28

00007044 <.LVL46>:
  callbacks[channel->index] = request->callback;
    7044:	5c 49 02 00 	mov.b	2(r9),	r12	;
    7048:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    704c:	9c 4a 0e 00 	mov	14(r10),23782(r12);0x0000e, 0x5ce6
    7050:	e6 5c 
    7052:	9c 4a 10 00 	mov	16(r10),23784(r12);0x00010, 0x5ce8
    7056:	e8 5c 

00007058 <.Loc.281.1>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
    7058:	2c 49       	mov	@r9,	r12	;
    705a:	2d 4a       	mov	@r10,	r13	;
    705c:	0e 4d       	mov	r13,	r14	;
    705e:	0f 43       	clr	r15		;
    7060:	8c 4e 02 00 	mov	r14,	2(r12)	;
    7064:	8c 4f 04 00 	mov	r15,	4(r12)	;

00007068 <.Loc.282.1>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    7068:	1d 4a 02 00 	mov	2(r10),	r13	;
    706c:	0e 4d       	mov	r13,	r14	;
    706e:	0f 43       	clr	r15		;
    7070:	8c 4e 06 00 	mov	r14,	6(r12)	;
    7074:	8c 4f 08 00 	mov	r15,	8(r12)	;

00007078 <.Loc.284.1>:
#endif
  channel->registers->sz  = request->size;
    7078:	9c 4a 04 00 	mov	4(r10),	10(r12)	; 0x000a
    707c:	0a 00 

0000707e <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    707e:	1d 4a 08 00 	mov	8(r10),	r13	;
    7082:	1d da 06 00 	bis	6(r10),	r13	;

00007086 <.Loc.286.1>:
                            request->transfer_mode | DMAEN |
    7086:	3d d0 15 00 	bis	#21,	r13	;#0x0015

0000708a <.Loc.285.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    708a:	1d da 0a 00 	bis	10(r10),r13	;0x0000a
    708e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007092 <.Loc.288.1>:
                            DMAREQ;
}
    7092:	19 17       	popm	#2,	r10	;16-bit words
    7094:	30 41       	ret			

00007096 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    7096:	1a 15       	pushm	#2,	r10	;16-bit words

00007098 <.LCFI7>:
    7098:	0a 4c       	mov	r12,	r10	;

0000709a <.LBB31>:
  return chSysGetStatusAndLockX();
    709a:	b0 12 18 63 	call	#25368		;#0x6318

0000709e <.LVL52>:
    709e:	09 4c       	mov	r12,	r9	;

000070a0 <.LBE31>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    70a0:	0a 93       	cmp	#0,	r10	;r3 As==00
    70a2:	0e 24       	jz	$+30     	;abs 0x70c0

000070a4 <.Loc.305.1>:
    70a4:	2c 4a       	mov	@r10,	r12	;
    70a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    70a8:	0b 24       	jz	$+24     	;abs 0x70c0

000070aa <.Loc.305.1>:
    70aa:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    70ae:	00 00 
    70b0:	07 24       	jz	$+16     	;abs 0x70c0

000070b2 <.Loc.308.1>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    70b2:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

000070b6 <.Loc.311.1>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    70b6:	4d 43       	clr.b	r13		;
    70b8:	3c 40 e4 5c 	mov	#23780,	r12	;#0x5ce4
    70bc:	b0 12 28 65 	call	#25896		;#0x6528

000070c0 <.L32>:
  chSysRestoreStatusX(sts);
    70c0:	0c 49       	mov	r9,	r12	;
    70c2:	b0 12 3a 63 	call	#25402		;#0x633a

000070c6 <.LBE33>:
  }
  osalSysRestoreStatusX(sts);
}
    70c6:	19 17       	popm	#2,	r10	;16-bit words
    70c8:	30 41       	ret			

000070ca <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    70ca:	0a 15       	pushm	#1,	r10	;16-bit words

000070cc <.LCFI8>:
    70cc:	0a 4c       	mov	r12,	r10	;

000070ce <.Loc.329.1>:
  
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    70ce:	2c 4c       	mov	@r12,	r12	;

000070d0 <.LVL56>:
    70d0:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    70d4:	00 00 
    70d6:	0e 24       	jz	$+30     	;abs 0x70f4

000070d8 <.Loc.334.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    70d8:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    70dc:	00 00 

000070de <.Loc.336.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    70de:	4d 43       	clr.b	r13		;
    70e0:	5c 4a 02 00 	mov.b	2(r10),	r12	;
    70e4:	b0 12 28 6f 	call	#28456		;#0x6f28

000070e8 <.LVL57>:
  channel->registers->sz  = 0;
    70e8:	2c 4a       	mov	@r10,	r12	;
    70ea:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000070ee <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    70ee:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    70f2:	00 00 

000070f4 <.L42>:
}
    70f4:	0a 17       	popm	#1,	r10	;16-bit words
    70f6:	30 41       	ret			

000070f8 <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    70f8:	1a 15       	pushm	#2,	r10	;16-bit words

000070fa <.LCFI1>:
    70fa:	0a 4c       	mov	r12,	r10	;

000070fc <.LVL7>:
  SPIDriver * spip = (SPIDriver *)(arg);

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    70fc:	1d 4c 08 00 	mov	8(r12),	r13	;
    7100:	ad c3 00 00 	bic	#2,	0(r13)	;r3 As==10

00007104 <.Loc.136.1>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    7104:	1d 4c 02 00 	mov	2(r12),	r13	;
    7108:	2d 4d       	mov	@r13,	r13	;
    710a:	0d 93       	cmp	#0,	r13	;r3 As==00
    710c:	06 24       	jz	$+14     	;abs 0x711a

0000710e <.Loc.136.1>:
    710e:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7112:	8d 12       	call	r13		;

00007114 <.LVL8>:
    7114:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    7118:	02 20       	jnz	$+6      	;abs 0x711e

0000711a <.L19>:
    711a:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

0000711e <.L20>:
  chSysLockFromISR();
    711e:	b0 12 2e 61 	call	#24878		;#0x612e

00007122 <.LBB34>:
  chThdResumeI(trp, msg);
    7122:	4d 43       	clr.b	r13		;
    7124:	0c 4a       	mov	r10,	r12	;
    7126:	2c 52       	add	#4,	r12	;r2 As==10

00007128 <.LVL10>:
    7128:	b0 12 08 64 	call	#25608		;#0x6408

0000712c <.LBB36>:
  chSysUnlockFromISR();
    712c:	b0 12 4e 61 	call	#24910		;#0x614e

00007130 <.LBE36>:
  
  if (spip->state == SPI_READY) {
    7130:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    7134:	0a 20       	jnz	$+22     	;abs 0x714a

00007136 <.LBB38>:
    dmaReleaseX(&(spip->dmarx));
    7136:	39 40 96 70 	mov	#28822,	r9	;#0x7096
    713a:	0c 4a       	mov	r10,	r12	;
    713c:	3c 50 34 00 	add	#52,	r12	;#0x0034
    7140:	89 12       	call	r9		;

00007142 <.LVL14>:
    dmaReleaseX(&(spip->dmatx));
    7142:	0c 4a       	mov	r10,	r12	;
    7144:	3c 50 2e 00 	add	#46,	r12	;#0x002e
    7148:	89 12       	call	r9		;

0000714a <.L18>:
  }
}
    714a:	19 17       	popm	#2,	r10	;16-bit words
    714c:	30 41       	ret			

0000714e <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
    714e:	0a 15       	pushm	#1,	r10	;16-bit words

00007150 <.LCFI2>:

#if MSP430X_SPI_USE_SPIA0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA0);
    7150:	3a 40 ce 6a 	mov	#27342,	r10	;#0x6ace
    7154:	3c 40 c0 52 	mov	#21184,	r12	;#0x52c0
    7158:	8a 12       	call	r10		;

0000715a <.LVL16>:
  SPIDA0.regs                     = (msp430x_spi_reg_t *)(&UCA0CTLW0);
    715a:	3c 40 c0 52 	mov	#21184,	r12	;#0x52c0
    715e:	bc 40 c0 05 	mov	#1472,	6(r12)	;#0x05c0
    7162:	06 00 

00007164 <.Loc.162.1>:
  SPIDA0.ifg                      = (volatile uint16_t *)&UCA0IFG;
    7164:	bc 40 dc 05 	mov	#1500,	8(r12)	;#0x05dc
    7168:	08 00 

0000716a <.Loc.163.1>:
  SPIDA0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA0TXIFG);
    716a:	bc 40 0f 00 	mov	#15,	22(r12)	;#0x000f, 0x0016
    716e:	16 00 

00007170 <.Loc.164.1>:
  SPIDA0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA0RXIFG);
    7170:	bc 40 0e 00 	mov	#14,	40(r12)	;#0x000e, 0x0028
    7174:	28 00 

00007176 <.Loc.165.1>:
  SPIDA0.tx_req.dest_addr         = &(SPIDA0.regs->txbuf);
    7176:	bc 40 ce 05 	mov	#1486,	12(r12)	;#0x05ce, 0x000c
    717a:	0c 00 

0000717c <.Loc.166.1>:
  SPIDA0.rx_req.source_addr       = &(SPIDA0.regs->rxbuf);
    717c:	bc 40 cc 05 	mov	#1484,	28(r12)	;#0x05cc, 0x001c
    7180:	1c 00 

00007182 <.Loc.167.1>:
  SPIDA0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7182:	bc 40 c0 00 	mov	#192,	18(r12)	;#0x00c0, 0x0012
    7186:	12 00 

00007188 <.Loc.168.1>:
  SPIDA0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7188:	bc 40 c0 00 	mov	#192,	36(r12)	;#0x00c0, 0x0024
    718c:	24 00 

0000718e <.Loc.169.1>:
  SPIDA0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    718e:	8c 43 14 00 	mov	#0,	20(r12)	;r3 As==00, 0x0014

00007192 <.Loc.170.1>:
  SPIDA0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7192:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

00007196 <.Loc.171.1>:
  SPIDA0.tx_req.callback.callback = NULL;
    7196:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

0000719a <.Loc.172.1>:
  SPIDA0.tx_req.callback.args     = NULL;
    719a:	8c 43 1a 00 	mov	#0,	26(r12)	;r3 As==00, 0x001a

0000719e <.Loc.173.1>:
  SPIDA0.rx_req.callback.callback = spi_lld_end_of_transfer;
    719e:	bc 40 f8 70 	mov	#28920,	42(r12)	;#0x70f8, 0x002a
    71a2:	2a 00 

000071a4 <.Loc.174.1>:
  SPIDA0.rx_req.callback.args     = &SPIDA0;
    71a4:	8c 4c 2c 00 	mov	r12,	44(r12)	; 0x002c

000071a8 <.Loc.239.1>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    71a8:	3c 40 86 52 	mov	#21126,	r12	;#0x5286
    71ac:	8a 12       	call	r10		;

000071ae <.LVL17>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    71ae:	3c 40 86 52 	mov	#21126,	r12	;#0x5286
    71b2:	bc 40 40 06 	mov	#1600,	6(r12)	;#0x0640
    71b6:	06 00 

000071b8 <.Loc.241.1>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    71b8:	bc 40 6c 06 	mov	#1644,	8(r12)	;#0x066c
    71bc:	08 00 

000071be <.Loc.242.1>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    71be:	bc 40 13 00 	mov	#19,	22(r12)	;#0x0013, 0x0016
    71c2:	16 00 

000071c4 <.Loc.243.1>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    71c4:	bc 40 12 00 	mov	#18,	40(r12)	;#0x0012, 0x0028
    71c8:	28 00 

000071ca <.Loc.244.1>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    71ca:	bc 40 4e 06 	mov	#1614,	12(r12)	;#0x064e, 0x000c
    71ce:	0c 00 

000071d0 <.Loc.245.1>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    71d0:	bc 40 4c 06 	mov	#1612,	28(r12)	;#0x064c, 0x001c
    71d4:	1c 00 

000071d6 <.Loc.246.1>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    71d6:	bc 40 c0 00 	mov	#192,	18(r12)	;#0x00c0, 0x0012
    71da:	12 00 

000071dc <.Loc.247.1>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    71dc:	bc 40 c0 00 	mov	#192,	36(r12)	;#0x00c0, 0x0024
    71e0:	24 00 

000071e2 <.Loc.248.1>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    71e2:	8c 43 14 00 	mov	#0,	20(r12)	;r3 As==00, 0x0014

000071e6 <.Loc.249.1>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    71e6:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

000071ea <.Loc.250.1>:
  SPIDB0.tx_req.callback.callback = NULL;
    71ea:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

000071ee <.Loc.251.1>:
  SPIDB0.tx_req.callback.args     = NULL;
    71ee:	8c 43 1a 00 	mov	#0,	26(r12)	;r3 As==00, 0x001a

000071f2 <.Loc.252.1>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    71f2:	bc 40 f8 70 	mov	#28920,	42(r12)	;#0x70f8, 0x002a
    71f6:	2a 00 

000071f8 <.Loc.253.1>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    71f8:	8c 4c 2c 00 	mov	r12,	44(r12)	; 0x002c

000071fc <.Loc.312.1>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    71fc:	0a 17       	popm	#1,	r10	;16-bit words
    71fe:	30 41       	ret			

00007200 <adc_lld_init>:
 */
void adc_lld_init(void) {

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    7200:	3c 40 fa 52 	mov	#21242,	r12	;#0x52fa
    7204:	b0 12 d0 68 	call	#26832		;#0x68d0

00007208 <.LVL0>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    7208:	b2 40 00 08 	mov	#2048,	&0x5306	;#0x0800
    720c:	06 53 

0000720e <.LBB37>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    720e:	3c 40 08 1a 	mov	#6664,	r12	;#0x1a08

00007212 <.Loc.111.1>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    7212:	3e 40 fa 52 	mov	#21242,	r14	;#0x52fa

00007216 <.L2>:
  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    7216:	6d 4c       	mov.b	@r12,	r13	;
    7218:	7d 93       	cmp.b	#-1,	r13	;r3 As==11
    721a:	04 24       	jz	$+10     	;abs 0x7224
    721c:	3f 40 fe 1a 	mov	#6910,	r15	;#0x1afe
    7220:	0f 9c       	cmp	r12,	r15	;
    7222:	01 2c       	jc	$+4      	;abs 0x7226

00007224 <.L1>:
  populate_tlv(&ADCD1);
#endif
}
    7224:	30 41       	ret			

00007226 <.L6>:
    if (*tlv_addr == TLV_ADC12CAL) {
    7226:	7d 90 11 00 	cmp.b	#17,	r13	;#0x0011
    722a:	09 20       	jnz	$+20     	;abs 0x723e

0000722c <.Loc.108.1>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    722c:	0d 4c       	mov	r12,	r13	;
    722e:	2d 53       	incd	r13		;
    7230:	8e 4d 20 00 	mov	r13,	32(r14)	; 0x0020

00007234 <.L4>:
    tlv_addr += (tlv_addr[1] + 2);
    7234:	5d 4c 01 00 	mov.b	1(r12),	r13	;
    7238:	2d 53       	incd	r13		;
    723a:	0c 5d       	add	r13,	r12	;
    723c:	ec 3f       	jmp	$-38     	;abs 0x7216

0000723e <.L3>:
    else if (*tlv_addr == TLV_REFCAL) {
    723e:	7d 90 12 00 	cmp.b	#18,	r13	;#0x0012
    7242:	f8 23       	jnz	$-14     	;abs 0x7234

00007244 <.Loc.111.1>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    7244:	0f 4c       	mov	r12,	r15	;
    7246:	2f 53       	incd	r15		;
    7248:	8e 4f 22 00 	mov	r15,	34(r14)	; 0x0022
    724c:	f3 3f       	jmp	$-24     	;abs 0x7234

0000724e <adc_lld_start>:
    724e:	1a 15       	pushm	#2,	r10	;16-bit words

00007250 <.LCFI0>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver * adcp) {
    7250:	0a 4c       	mov	r12,	r10	;

00007252 <L0>:

  if (adcp->state == ADC_STOP) {
    7252:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    7256:	1d 20       	jnz	$+60     	;abs 0x7292

00007258 <.Loc.177.1>:
    /* Enables the peripheral.*/
    adcp->regs->ctl[0] = ADC12ON | ADC12MSC;
    7258:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c

0000725c <.LVL5>:
    725c:	bc 40 90 00 	mov	#144,	0(r12)	;#0x0090
    7260:	00 00 

00007262 <.Loc.178.1>:
    adcp->regs->ctl[1] =
    7262:	bc 40 60 62 	mov	#25184,	2(r12)	;#0x6260
    7266:	02 00 

00007268 <.Loc.180.1>:
        MSP430X_ADC1_PDIV | MSP430X_ADC1_DIV | MSP430X_ADC1_SSEL | ADC12SHP;
    adcp->regs->ctl[3] = ADC12ICH3MAP | ADC12ICH2MAP | ADC12ICH1MAP |
    7268:	bc 40 c0 0f 	mov	#4032,	6(r12)	;#0x0fc0
    726c:	06 00 

0000726e <.Loc.182.1>:
                         ADC12ICH0MAP | ADC12TCMAP | ADC12BATMAP;
    adcp->regs->ier[2] = ADC12TOVIE | ADC12OVIE;
    726e:	bc 40 30 00 	mov	#48,	22(r12)	;#0x0030, 0x0016
    7272:	16 00 

00007274 <.Loc.183.1>:
    adcp->req.trigger  = DMA_TRIGGER_MNEM(ADC12IFG);
    7274:	ba 40 1a 00 	mov	#26,	26(r10)	;#0x001a, 0x001a
    7278:	1a 00 

0000727a <.Loc.187.1>:
#if MSP430X_ADC_COMPACT_SAMPLES == TRUE
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTBYTE;
#else
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTWORD;
    727a:	8a 43 16 00 	mov	#0,	22(r10)	;r3 As==00, 0x0016

0000727e <.Loc.189.1>:
#endif
    adcp->req.addr_mode         = MSP430X_DMA_SRCINCR | MSP430X_DMA_DSTINCR;
    727e:	ba 40 00 0f 	mov	#3840,	20(r10)	;#0x0f00, 0x0014
    7282:	14 00 

00007284 <.Loc.190.1>:
    adcp->req.transfer_mode     = MSP430X_DMA_SINGLE;
    7284:	8a 43 18 00 	mov	#0,	24(r10)	;r3 As==00, 0x0018

00007288 <.Loc.191.1>:
    adcp->req.callback.callback = dma_callback;
    7288:	ba 40 9a 73 	mov	#29594,	28(r10)	;#0x739a, 0x001c
    728c:	1c 00 

0000728e <.Loc.192.1>:
    adcp->req.callback.args     = adcp;
    728e:	8a 4a 1e 00 	mov	r10,	30(r10)	; 0x001e

00007292 <.L11>:

  }
  /* Configures the peripheral.*/
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  bool b;
  dmaReleaseX(&(adcp->dma));
    7292:	09 4a       	mov	r10,	r9	;
    7294:	39 50 26 00 	add	#38,	r9	;#0x0026
    7298:	0c 49       	mov	r9,	r12	;
    729a:	b0 12 96 70 	call	#28822		;#0x7096

0000729e <.LVL6>:
  if (adcp->config->dma_index < MSP430X_DMA_CHANNELS) {
    729e:	1c 4a 02 00 	mov	2(r10),	r12	;
    72a2:	6d 4c       	mov.b	@r12,	r13	;
    72a4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    72a6:	4c 9d       	cmp.b	r13,	r12	;
    72a8:	03 28       	jnc	$+8      	;abs 0x72b0

000072aa <.Loc.200.1>:
    b = dmaClaimI(&adcp->dma, adcp->config->dma_index);
    72aa:	0c 49       	mov	r9,	r12	;
    72ac:	b0 12 ec 6f 	call	#28652		;#0x6fec

000072b0 <.L10>:
    osalDbgAssert(!b, "stream already allocated");
  }
#endif
}
    72b0:	19 17       	popm	#2,	r10	;16-bit words
    72b2:	30 41       	ret			

000072b4 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver * adcp) {
    72b4:	2a 15       	pushm	#3,	r10	;16-bit words

000072b6 <.LCFI2>:
    72b6:	0a 4c       	mov	r12,	r10	;

000072b8 <.Loc.234.1>:

  /* always use sequential transfer mode - this is fine */
  adcp->regs->ctl[1] |= ADC12CONSEQ0;
    72b8:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c

000072bc <.LVL12>:
    72bc:	ac d3 02 00 	bis	#2,	2(r12)	;r3 As==10

000072c0 <.Loc.237.1>:

  /* set resolution */
  adcp->regs->ctl[2] |= adcp->grpp->res;
    72c0:	1e 4a 08 00 	mov	8(r10),	r14	;
    72c4:	58 4e 26 00 	mov.b	38(r14),r8	;0x00026
    72c8:	8c d8 04 00 	bis	r8,	4(r12)	;

000072cc <.Loc.239.1>:
  /* start from MEM0 */
  adcp->regs->ctl[3] &= ~(ADC12CSTARTADD_31);
    72cc:	bc f0 e0 ff 	and	#-32,	6(r12)	;#0xffe0
    72d0:	06 00 

000072d2 <.L16>:

  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    72d2:	1d 42 b0 01 	mov	&0x01b0,r13	;0x01b0
    72d6:	3d f0 00 04 	and	#1024,	r13	;#0x0400
    72da:	0d 93       	cmp	#0,	r13	;r3 As==00
    72dc:	fa 23       	jnz	$-10     	;abs 0x72d2

000072de <.Loc.244.1>:
    ;
  REFCTL0 = adcp->grpp->vref_src;
    72de:	5f 4e 2c 00 	mov.b	44(r14),r15	;0x0002c
    72e2:	82 4f b0 01 	mov	r15,	&0x01b0	;

000072e6 <.LBB41>:

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    72e6:	5f 4e 01 00 	mov.b	1(r14),	r15	;
    72ea:	0b 4e       	mov	r14,	r11	;
    72ec:	3b 50 06 00 	add	#6,	r11	;
    72f0:	09 4c       	mov	r12,	r9	;
    72f2:	39 50 20 00 	add	#32,	r9	;#0x0020

000072f6 <.L17>:
    72f6:	0d 9f       	cmp	r15,	r13	;
    72f8:	30 38       	jl	$+98     	;abs 0x735a
    72fa:	0d 4f       	mov	r15,	r13	;

000072fc <.LVL15>:
    72fc:	0d 5f       	add	r15,	r13	;
    72fe:	0d 5c       	add	r12,	r13	;

00007300 <.LBE41>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
  }

  adcp->regs->mctl[adcp->grpp->num_channels - 1] |= ADC12EOS;
    7300:	bd d0 80 00 	bis	#128,	30(r13)	;#0x0080, 0x001e
    7304:	1e 00 

00007306 <.Loc.253.1>:

  adcp->req.source_addr = adcp->regs->mem;
    7306:	3c 50 60 00 	add	#96,	r12	;#0x0060
    730a:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000730e <.Loc.254.1>:
  adcp->req.dest_addr   = adcp->samples;
    730e:	9a 4a 04 00 	mov	4(r10),	16(r10)	; 0x0010
    7312:	10 00 

00007314 <.Loc.255.1>:
  adcp->req.size        = adcp->grpp->num_channels;
    7314:	8a 4f 12 00 	mov	r15,	18(r10)	; 0x0012

00007318 <.Loc.256.1>:
  adcp->count           = 0;
    7318:	ca 43 24 00 	mov.b	#0,	36(r10)	;r3 As==00, 0x0024

0000731c <.Loc.260.1>:

/* TODO timeouts? */
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    731c:	1c 4a 02 00 	mov	2(r10),	r12	;
    7320:	09 4a       	mov	r10,	r9	;
    7322:	39 50 26 00 	add	#38,	r9	;#0x0026
    7326:	6d 43       	mov.b	#2,	r13	;r3 As==10
    7328:	6d 9c       	cmp.b	@r12,	r13	;
    732a:	04 2c       	jc	$+10     	;abs 0x7334

0000732c <.Loc.262.1>:
#endif
    dmaAcquireTimeoutS(&(adcp->dma), TIME_INFINITE);
    732c:	4d 43       	clr.b	r13		;
    732e:	0c 49       	mov	r9,	r12	;
    7330:	b0 12 bc 6f 	call	#28604		;#0x6fbc

00007334 <.L19>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
  dmaTransferI(&(adcp->dma), &(adcp->req));
    7334:	0d 4a       	mov	r10,	r13	;
    7336:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    733a:	0c 49       	mov	r9,	r12	;
    733c:	b0 12 2a 70 	call	#28714		;#0x702a

00007340 <.LVL17>:

  adcp->regs->ctl[0] |= adcp->grpp->rate | ADC12MSC | ADC12ENC | ADC12SC;
    7340:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    7344:	1d 4a 08 00 	mov	8(r10),	r13	;
    7348:	1d 4d 28 00 	mov	40(r13),r13	;0x00028
    734c:	2d dc       	bis	@r12,	r13	;
    734e:	3d d0 83 00 	bis	#131,	r13	;#0x0083
    7352:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007356 <.Loc.269.1>:
}
    7356:	28 17       	popm	#3,	r10	;16-bit words
    7358:	30 41       	ret			

0000735a <.L18>:
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
    735a:	68 4b       	mov.b	@r11,	r8	;
    735c:	18 de 2a 00 	bis	42(r14),r8	;0x0002a
    7360:	89 48 00 00 	mov	r8,	0(r9)	;

00007364 <.Loc.246.1>:
  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    7364:	1d 53       	inc	r13		;
    7366:	1b 53       	inc	r11		;
    7368:	29 53       	incd	r9		;
    736a:	c5 3f       	jmp	$-116    	;abs 0x72f6

0000736c <adc_lld_stop_conversion>:
    736c:	1a 15       	pushm	#2,	r10	;16-bit words

0000736e <L0>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {
    736e:	0a 4c       	mov	r12,	r10	;

00007370 <.Loc.281.1>:

  /* TODO stop DMA transfers here */
  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    7370:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c

00007374 <.LVL21>:
    7374:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    7378:	00 00 

0000737a <.Loc.283.1>:

  dmaCancelI(&(adcp->dma));
    737a:	09 4a       	mov	r10,	r9	;
    737c:	39 50 26 00 	add	#38,	r9	;#0x0026
    7380:	0c 49       	mov	r9,	r12	;
    7382:	b0 12 ca 70 	call	#28874		;#0x70ca

00007386 <.LVL22>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    7386:	1c 4a 02 00 	mov	2(r10),	r12	;
    738a:	6d 43       	mov.b	#2,	r13	;r3 As==10
    738c:	6d 9c       	cmp.b	@r12,	r13	;
    738e:	03 2c       	jc	$+8      	;abs 0x7396

00007390 <.Loc.287.1>:
#endif
    dmaReleaseX(&(adcp->dma));
    7390:	0c 49       	mov	r9,	r12	;
    7392:	b0 12 96 70 	call	#28822		;#0x7096

00007396 <.L21>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
}
    7396:	19 17       	popm	#2,	r10	;16-bit words
    7398:	30 41       	ret			

0000739a <dma_callback>:
static void dma_callback(void * args) {
    739a:	2a 15       	pushm	#3,	r10	;16-bit words

0000739c <.LCFI5>:
    739c:	0a 4c       	mov	r12,	r10	;

0000739e <.LVL40>:
  if (adcp->grpp == NULL)
    739e:	18 4c 08 00 	mov	8(r12),	r8	;
    73a2:	08 93       	cmp	#0,	r8	;r3 As==00
    73a4:	4d 24       	jz	$+156    	;abs 0x7440

000073a6 <.Loc.66.1>:
  adcp->count++;
    73a6:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024

000073aa <.LVL41>:
    73aa:	5c 53       	inc.b	r12		;
    73ac:	49 4c       	mov.b	r12,	r9	;
    73ae:	ca 4c 24 00 	mov.b	r12,	36(r10)	; 0x0024

000073b2 <.Loc.68.1>:
  if (adcp->count == adcp->depth / 2) {
    73b2:	1c 4a 06 00 	mov	6(r10),	r12	;
    73b6:	b0 12 be 7c 	call	#31934		;#0x7cbe
    73ba:	09 9c       	cmp	r12,	r9	;
    73bc:	09 20       	jnz	$+20     	;abs 0x73d0

000073be <.Loc.70.1>:
    _adc_isr_half_code(adcp);
    73be:	1f 48 02 00 	mov	2(r8),	r15	;
    73c2:	0f 93       	cmp	#0,	r15	;r3 As==00
    73c4:	05 24       	jz	$+12     	;abs 0x73d0

000073c6 <.Loc.70.1>:
    73c6:	0e 49       	mov	r9,	r14	;
    73c8:	1d 4a 04 00 	mov	4(r10),	r13	;
    73cc:	0c 4a       	mov	r10,	r12	;
    73ce:	8f 12       	call	r15		;

000073d0 <.L52>:
  if (adcp->count == adcp->depth) {
    73d0:	5d 4a 24 00 	mov.b	36(r10),r13	;0x00024
    73d4:	1d 9a 06 00 	cmp	6(r10),	r13	;
    73d8:	5c 20       	jnz	$+186    	;abs 0x7492

000073da <.Loc.77.1>:
    _adc_isr_full_code(adcp);
    73da:	1c 4a 08 00 	mov	8(r10),	r12	;
    73de:	cc 93 00 00 	cmp.b	#0,	0(r12)	;r3 As==00
    73e2:	34 24       	jz	$+106    	;abs 0x744c

000073e4 <.Loc.77.1>:
    73e4:	18 4c 02 00 	mov	2(r12),	r8	;
    73e8:	08 93       	cmp	#0,	r8	;r3 As==00
    73ea:	12 24       	jz	$+38     	;abs 0x7410

000073ec <.Loc.77.1>:
    73ec:	5e 43       	mov.b	#1,	r14	;r3 As==01
    73ee:	0e 9d       	cmp	r13,	r14	;
    73f0:	29 2c       	jc	$+84     	;abs 0x7444

000073f2 <.LBB68>:
    73f2:	09 4d       	mov	r13,	r9	;
    73f4:	12 c3       	clrc			
    73f6:	09 10       	rrc	r9		;

000073f8 <.LVL44>:
    73f8:	0d 49       	mov	r9,	r13	;
    73fa:	5c 4c 01 00 	mov.b	1(r12),	r12	;

000073fe <.LVL45>:
    73fe:	b0 12 3a 7d 	call	#32058		;#0x7d3a

00007402 <.LVL46>:
    7402:	0c 5c       	rla	r12		;
    7404:	0e 49       	mov	r9,	r14	;
    7406:	1d 4a 04 00 	mov	4(r10),	r13	;
    740a:	0d 5c       	add	r12,	r13	;

0000740c <.L69>:
    740c:	0c 4a       	mov	r10,	r12	;
    740e:	88 12       	call	r8		;

00007410 <.L55>:
    if (adcp->grpp) {
    7410:	8a 93 08 00 	cmp	#0,	8(r10)	;r3 As==00
    7414:	15 24       	jz	$+44     	;abs 0x7440

00007416 <.Loc.81.1>:
      adcp->req.dest_addr = adcp->samples;
    7416:	9a 4a 04 00 	mov	4(r10),	16(r10)	; 0x0010
    741a:	10 00 

0000741c <.LBB69>:
  chSysLockFromISR();
    741c:	b0 12 2e 61 	call	#24878		;#0x612e

00007420 <.LBE71>:
  dmaTransferI(&(adcp->dma), &(adcp->req));
    7420:	0d 4a       	mov	r10,	r13	;
    7422:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7426:	0c 4a       	mov	r10,	r12	;
    7428:	3c 50 26 00 	add	#38,	r12	;#0x0026
    742c:	b0 12 2a 70 	call	#28714		;#0x702a

00007430 <.LBB73>:
  chSysUnlockFromISR();
    7430:	b0 12 4e 61 	call	#24910		;#0x614e

00007434 <.LBE69>:
      adcp->count = 0;
    7434:	ca 43 24 00 	mov.b	#0,	36(r10)	;r3 As==00, 0x0024

00007438 <.L70>:
    adcp->regs->ctl[0] |= ADC12SC;
    7438:	1c 4a 0c 00 	mov	12(r10),r12	;0x0000c
    743c:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

00007440 <.L49>:
}
    7440:	28 17       	popm	#3,	r10	;16-bit words
    7442:	30 41       	ret			

00007444 <.L56>:
    _adc_isr_full_code(adcp);
    7444:	0e 4d       	mov	r13,	r14	;
    7446:	1d 4a 04 00 	mov	4(r10),	r13	;
    744a:	e0 3f       	jmp	$-62     	;abs 0x740c

0000744c <.L54>:
    744c:	0c 4a       	mov	r10,	r12	;
    744e:	b0 12 6c 73 	call	#29548		;#0x736c

00007452 <.LVL53>:
    7452:	1c 4a 08 00 	mov	8(r10),	r12	;
    7456:	1f 4c 02 00 	mov	2(r12),	r15	;
    745a:	0f 93       	cmp	#0,	r15	;r3 As==00
    745c:	0b 24       	jz	$+24     	;abs 0x7474

0000745e <.Loc.77.1>:
    745e:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10
    7462:	1e 4a 06 00 	mov	6(r10),	r14	;
    7466:	1d 4a 04 00 	mov	4(r10),	r13	;
    746a:	0c 4a       	mov	r10,	r12	;
    746c:	8f 12       	call	r15		;

0000746e <.LVL54>:
    746e:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    7472:	04 20       	jnz	$+10     	;abs 0x747c

00007474 <.L57>:
    7474:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10
    7478:	8a 43 08 00 	mov	#0,	8(r10)	;r3 As==00

0000747c <.L58>:
  chSysLockFromISR();
    747c:	b0 12 2e 61 	call	#24878		;#0x612e

00007480 <.LBB77>:
  chThdResumeI(trp, msg);
    7480:	4d 43       	clr.b	r13		;
    7482:	0c 4a       	mov	r10,	r12	;
    7484:	3c 50 0a 00 	add	#10,	r12	;#0x000a

00007488 <.LVL56>:
    7488:	b0 12 08 64 	call	#25608		;#0x6408

0000748c <.LBB79>:
  chSysUnlockFromISR();
    748c:	b0 12 4e 61 	call	#24910		;#0x614e

00007490 <.LVL58>:
    7490:	bf 3f       	jmp	$-128    	;abs 0x7410

00007492 <.L53>:
    adcp->req.dest_addr = adcp->samples + (adcp->req.size * adcp->count);
    7492:	1c 4a 12 00 	mov	18(r10),r12	;0x00012
    7496:	0c 5c       	rla	r12		;
    7498:	b0 12 3a 7d 	call	#32058		;#0x7d3a
    749c:	1c 5a 04 00 	add	4(r10),	r12	;
    74a0:	8a 4c 10 00 	mov	r12,	16(r10)	; 0x0010

000074a4 <.LBB81>:
  chSysLockFromISR();
    74a4:	b0 12 2e 61 	call	#24878		;#0x612e

000074a8 <.LBE83>:
  dmaTransferI(&(adcp->dma), &(adcp->req));
    74a8:	0d 4a       	mov	r10,	r13	;
    74aa:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    74ae:	0c 4a       	mov	r10,	r12	;
    74b0:	3c 50 26 00 	add	#38,	r12	;#0x0026
    74b4:	b0 12 2a 70 	call	#28714		;#0x702a

000074b8 <.LBB85>:
  chSysUnlockFromISR();
    74b8:	b0 12 4e 61 	call	#24910		;#0x614e

000074bc <.LVL63>:
    74bc:	bd 3f       	jmp	$-132    	;abs 0x7438

000074be <adcMSP430XAdjustResult>:
    74be:	1a 15       	pushm	#2,	r10	;16-bit words

000074c0 <.LCFI6>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    74c0:	1e 4c 2a 00 	mov	42(r12),r14	;0x0002a

000074c4 <L0>:
    74c4:	0f 4e       	mov	r14,	r15	;
    74c6:	3f f0 ff f7 	and	#-2049,	r15	;#0xf7ff
    74ca:	39 40 fa 52 	mov	#21242,	r9	;#0x52fa
    74ce:	3a 40 4e 7d 	mov	#32078,	r10	;#0x7d4e
    74d2:	3f 90 00 01 	cmp	#256,	r15	;#0x0100
    74d6:	09 24       	jz	$+20     	;abs 0x74ea

000074d8 <.Loc.297.1>:
    74d8:	3e 90 00 07 	cmp	#1792,	r14	;#0x0700
    74dc:	06 24       	jz	$+14     	;abs 0x74ea

000074de <.Loc.299.1>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    74de:	3e 90 00 0b 	cmp	#2816,	r14	;#0x0b00
    74e2:	03 24       	jz	$+8      	;abs 0x74ea

000074e4 <.Loc.300.1>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    74e4:	3e 90 00 0d 	cmp	#3328,	r14	;#0x0d00
    74e8:	11 20       	jnz	$+36     	;abs 0x750c

000074ea <.L72>:
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    /* Retrieve proper reference correction factor from TLV */
    fact = (&(ADCD1.ref_cal->CAL_ADC_12VREF_FACTOR))[grpp->vref_src >> 4];
    74ea:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c

000074ee <.LVL66>:
    74ee:	5c 0f       	rrum	#4,	r12	;

000074f0 <.LVL67>:
    74f0:	0c 5c       	rla	r12		;
    74f2:	1c 59 22 00 	add	34(r9),	r12	;0x00022

000074f6 <.Loc.305.1>:
    /* Calculate corrected value */
    tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    74f6:	0d 5d       	rla	r13		;

000074f8 <.LVL68>:
    74f8:	0e 4d       	mov	r13,	r14	;
    74fa:	0f 43       	clr	r15		;
    74fc:	2c 4c       	mov	@r12,	r12	;
    74fe:	0d 43       	clr	r13		;
    7500:	8a 12       	call	r10		;

00007502 <.LVL69>:
    sample = tmp >> 16;
    7502:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7506:	b0 12 34 7d 	call	#32052		;#0x7d34
    750a:	0d 4c       	mov	r12,	r13	;

0000750c <.L73>:
  }

  /* Gain correction */
  fact   = ADCD1.adc_cal->CAL_ADC_GAIN_FACTOR;
    750c:	19 49 20 00 	mov	32(r9),	r9	;0x00020

00007510 <.LVL72>:
  tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    7510:	0d 5d       	rla	r13		;

00007512 <.LVL73>:
    7512:	2c 49       	mov	@r9,	r12	;
    7514:	0e 4c       	mov	r12,	r14	;
    7516:	0f 43       	clr	r15		;
    7518:	0c 4d       	mov	r13,	r12	;
    751a:	0d 43       	clr	r13		;
    751c:	8a 12       	call	r10		;

0000751e <.LVL74>:
  sample = tmp >> 16;
    751e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7522:	b0 12 34 7d 	call	#32052		;#0x7d34

00007526 <.LVL75>:

  /* Offset correction */
  sample += ADCD1.adc_cal->CAL_ADC_OFFSET;

  return sample;
}
    7526:	1c 59 02 00 	add	2(r9),	r12	;

0000752a <.LVL76>:
    752a:	19 17       	popm	#2,	r10	;16-bit words
    752c:	30 41       	ret			

0000752e <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    752e:	32 c2       	dint			
    7530:	03 43       	nop			

00007532 <.Loc.46.1>:

}
    7532:	30 41       	ret			

00007534 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    7534:	ff 3f       	jmp	$+0      	;abs 0x7534

00007536 <Vector2>:
    7536:	ff 3f       	jmp	$+0      	;abs 0x7536

00007538 <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    7538:	ff 3f       	jmp	$+0      	;abs 0x7538

0000753a <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    753a:	ff 3f       	jmp	$+0      	;abs 0x753a

0000753c <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    753c:	ff 3f       	jmp	$+0      	;abs 0x753c

0000753e <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    753e:	ff 3f       	jmp	$+0      	;abs 0x753e

00007540 <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    7540:	ff 3f       	jmp	$+0      	;abs 0x7540

00007542 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    7542:	ff 3f       	jmp	$+0      	;abs 0x7542

00007544 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    7544:	ff 3f       	jmp	$+0      	;abs 0x7544

00007546 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    7546:	ff 3f       	jmp	$+0      	;abs 0x7546

00007548 <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    7548:	ff 3f       	jmp	$+0      	;abs 0x7548

0000754a <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    754a:	ff 3f       	jmp	$+0      	;abs 0x754a

0000754c <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    754c:	ff 3f       	jmp	$+0      	;abs 0x754c

0000754e <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    754e:	ff 3f       	jmp	$+0      	;abs 0x754e

00007550 <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    7550:	ff 3f       	jmp	$+0      	;abs 0x7550

00007552 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    7552:	ff 3f       	jmp	$+0      	;abs 0x7552

00007554 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    7554:	ff 3f       	jmp	$+0      	;abs 0x7554

00007556 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    7556:	ff 3f       	jmp	$+0      	;abs 0x7556

00007558 <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    7558:	ff 3f       	jmp	$+0      	;abs 0x7558

0000755a <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    755a:	ff 3f       	jmp	$+0      	;abs 0x755a

0000755c <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    755c:	ff 3f       	jmp	$+0      	;abs 0x755c

0000755e <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    755e:	ff 3f       	jmp	$+0      	;abs 0x755e

00007560 <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    7560:	ff 3f       	jmp	$+0      	;abs 0x7560

00007562 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    7562:	ff 3f       	jmp	$+0      	;abs 0x7562

00007564 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    7564:	ff 3f       	jmp	$+0      	;abs 0x7564

00007566 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    7566:	ff 3f       	jmp	$+0      	;abs 0x7566

00007568 <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    7568:	ff 3f       	jmp	$+0      	;abs 0x7568

0000756a <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    756a:	ff 3f       	jmp	$+0      	;abs 0x756a

0000756c <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    756c:	ff 3f       	jmp	$+0      	;abs 0x756c

0000756e <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    756e:	ff 3f       	jmp	$+0      	;abs 0x756e

00007570 <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    7570:	ff 3f       	jmp	$+0      	;abs 0x7570

00007572 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    7572:	ff 3f       	jmp	$+0      	;abs 0x7572

00007574 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    7574:	ff 3f       	jmp	$+0      	;abs 0x7574

00007576 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    7576:	ff 3f       	jmp	$+0      	;abs 0x7576

00007578 <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    7578:	ff 3f       	jmp	$+0      	;abs 0x7578

0000757a <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    757a:	ff 3f       	jmp	$+0      	;abs 0x757a

0000757c <Vector41>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    757c:	ff 3f       	jmp	$+0      	;abs 0x757c

0000757e <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {
    757e:	ff 3f       	jmp	$+0      	;abs 0x757e

00007580 <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    7580:	ff 3f       	jmp	$+0      	;abs 0x7580

00007582 <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    7582:	ff 3f       	jmp	$+0      	;abs 0x7582

00007584 <Vector48>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    7584:	ff 3f       	jmp	$+0      	;abs 0x7584

00007586 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {
    7586:	ff 3f       	jmp	$+0      	;abs 0x7586

00007588 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    7588:	ff 3f       	jmp	$+0      	;abs 0x7588

0000758a <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    758a:	ff 3f       	jmp	$+0      	;abs 0x758a

0000758c <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    758c:	ff 3f       	jmp	$+0      	;abs 0x758c

0000758e <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    758e:	ff 3f       	jmp	$+0      	;abs 0x758e

00007590 <save_bacon>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    7590:	b2 f0       	and			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00007592 <L0>:
const char * unpow_string = "PA unpowered.\r\n";
const char * err_string = "\r\nERROR! PA in unexpected state - likely PGOOD event\r\n";
const char * therm_string = "\r\nERROR! PA overheating - powering off now\r\n";

static void save_bacon(void) {
  palClearLine(LINE_PA_PC_EN);
    7592:	ff ef 22 02 	xor.b	@r15+,	546(r15); 0x0222

00007596 <.Loc.88.1>:
}
    7596:	30 41       	ret			

00007598 <convert_ntc>:
fixed_q36_8 convert_ntc(ADCConversionGroup *grpp, adcsample_t sample) {
    7598:	5a 15       	pushm	#6,	r10	;16-bit words

0000759a <.LCFI0>:
    759a:	21 83       	decd	r1		;

0000759c <.LCFI1>:
    759c:	05 4d       	mov	r13,	r5	;

0000759e <.Loc.56.1>:
  adcMSP430XAdjustResult(grpp, sample);
    759e:	b0 12 be 74 	call	#29886		;#0x74be

000075a2 <.LVL2>:
  y = c3 * sample; /* Q0.31 * Q12.0 => Q12.31 */
    75a2:	0c 45       	mov	r5,	r12	;
    75a4:	0d 43       	clr	r13		;
    75a6:	0e 4c       	mov	r12,	r14	;
    75a8:	0f 4d       	mov	r13,	r15	;
    75aa:	0e 5e       	rla	r14		;
    75ac:	0f 6f       	rlc	r15		;
    75ae:	0e 5e       	rla	r14		;
    75b0:	0f 6f       	rlc	r15		;
    75b2:	0c 5e       	add	r14,	r12	;
    75b4:	0d 6f       	addc	r15,	r13	;
    75b6:	08 4c       	mov	r12,	r8	;
    75b8:	08 5c       	add	r12,	r8	;
    75ba:	09 4d       	mov	r13,	r9	;
    75bc:	09 6d       	addc	r13,	r9	;
    75be:	4c 43       	clr.b	r12		;
    75c0:	4d 43       	clr.b	r13		;
    75c2:	0c 88       	sub	r8,	r12	;
    75c4:	0d 79       	subc	r9,	r13	;
    75c6:	0e 4c       	mov	r12,	r14	;
    75c8:	07 4d       	mov	r13,	r7	;
    75ca:	4e 18 07 11 	rpt #15 { rrax.w	r7		;

000075ce <.LVL3>:
  y += c2; /* Q12.31 + Q0.31 => OK */
    75ce:	5c 43       	mov.b	#1,	r12	;r3 As==01

000075d0 <.LVL4>:
    75d0:	08 4e       	mov	r14,	r8	;
    75d2:	38 50 d3 03 	add	#979,	r8	;#0x03d3
    75d6:	09 4c       	mov	r12,	r9	;
    75d8:	08 9e       	cmp	r14,	r8	;
    75da:	01 28       	jnc	$+4      	;abs 0x75de
    75dc:	49 43       	clr.b	r9		;

000075de <.L3>:
    75de:	0c 5d       	add	r13,	r12	;
    75e0:	5a 43       	mov.b	#1,	r10	;r3 As==01
    75e2:	0c 9d       	cmp	r13,	r12	;
    75e4:	01 28       	jnc	$+4      	;abs 0x75e8
    75e6:	4a 43       	clr.b	r10		;

000075e8 <.L4>:
    75e8:	09 5c       	add	r12,	r9	;
    75ea:	5d 43       	mov.b	#1,	r13	;r3 As==01

000075ec <.LVL5>:
    75ec:	09 9c       	cmp	r12,	r9	;
    75ee:	01 28       	jnc	$+4      	;abs 0x75f2
    75f0:	4d 43       	clr.b	r13		;

000075f2 <.L5>:
    75f2:	0a dd       	bis	r13,	r10	;
    75f4:	4b 43       	clr.b	r11		;
    75f6:	0a 57       	add	r7,	r10	;
    75f8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    75fa:	0a 97       	cmp	r7,	r10	;
    75fc:	01 28       	jnc	$+4      	;abs 0x7600
    75fe:	0c 4b       	mov	r11,	r12	;

00007600 <.L7>:
    7600:	0b dc       	bis	r12,	r11	;

00007602 <.LVL7>:
  y *= sample; /* Q12.31 * Q12.0 => Q24.31 */
    7602:	36 40 1e 79 	mov	#31006,	r6	;#0x791e
    7606:	0c 45       	mov	r5,	r12	;
    7608:	4d 43       	clr.b	r13		;
    760a:	0e 4d       	mov	r13,	r14	;
    760c:	0f 4d       	mov	r13,	r15	;
    760e:	0b 57       	add	r7,	r11	;
    7610:	86 12       	call	r6		;

00007612 <.LVL9>:
  y = (y >> 16); /* Q24.31 >> 16 => Q24.15 */
    7612:	37 40 68 7a 	mov	#31336,	r7	;#0x7a68
    7616:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    761a:	00 00 
    761c:	87 12       	call	r7		;

0000761e <.LVL10>:
  y += c1; /* Q24.15 + Q0.15 => OK */
    761e:	3a 43       	mov	#-1,	r10	;r3 As==11
    7620:	09 4c       	mov	r12,	r9	;
    7622:	39 50 e7 f4 	add	#-2841,	r9	;#0xf4e7
    7626:	5b 43       	mov.b	#1,	r11	;r3 As==01
    7628:	38 40 18 0b 	mov	#2840,	r8	;#0x0b18
    762c:	08 9c       	cmp	r12,	r8	;
    762e:	01 28       	jnc	$+4      	;abs 0x7632
    7630:	4b 43       	clr.b	r11		;

00007632 <.L8>:
    7632:	08 4d       	mov	r13,	r8	;
    7634:	08 5a       	add	r10,	r8	;
    7636:	5c 43       	mov.b	#1,	r12	;r3 As==01

00007638 <.LVL11>:
    7638:	08 9d       	cmp	r13,	r8	;
    763a:	01 28       	jnc	$+4      	;abs 0x763e
    763c:	4c 43       	clr.b	r12		;

0000763e <.L9>:
    763e:	0d 4b       	mov	r11,	r13	;
    7640:	0d 58       	add	r8,	r13	;
    7642:	5b 43       	mov.b	#1,	r11	;r3 As==01
    7644:	0d 98       	cmp	r8,	r13	;
    7646:	01 28       	jnc	$+4      	;abs 0x764a
    7648:	4b 43       	clr.b	r11		;

0000764a <.L10>:
    764a:	0c db       	bis	r11,	r12	;
    764c:	0b 4e       	mov	r14,	r11	;
    764e:	0b 5a       	add	r10,	r11	;
    7650:	58 43       	mov.b	#1,	r8	;r3 As==01
    7652:	0b 9e       	cmp	r14,	r11	;
    7654:	01 28       	jnc	$+4      	;abs 0x7658
    7656:	48 43       	clr.b	r8		;

00007658 <.L11>:
    7658:	0e 4c       	mov	r12,	r14	;
    765a:	0e 5b       	add	r11,	r14	;
    765c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    765e:	0e 9b       	cmp	r11,	r14	;
    7660:	01 28       	jnc	$+4      	;abs 0x7664
    7662:	4c 43       	clr.b	r12		;

00007664 <.L12>:
    7664:	08 dc       	bis	r12,	r8	;
    7666:	0f 5a       	add	r10,	r15	;

00007668 <.Loc.68.1>:
  y *= sample; /* Q24.15 * Q12.0 => Q36.15 */
    7668:	0c 49       	mov	r9,	r12	;
    766a:	0f 58       	add	r8,	r15	;
    766c:	08 45       	mov	r5,	r8	;
    766e:	49 43       	clr.b	r9		;
    7670:	0a 49       	mov	r9,	r10	;
    7672:	0b 49       	mov	r9,	r11	;
    7674:	86 12       	call	r6		;

00007676 <.LVL15>:
  y = (y >> 7); /* Q36.15 >> 7 => Q36.8 */
    7676:	b1 40 07 00 	mov	#7,	0(r1)	;
    767a:	00 00 
    767c:	87 12       	call	r7		;

0000767e <.LVL16>:
    767e:	08 4e       	mov	r14,	r8	;

00007680 <.Loc.70.1>:
  y += c0; /* Q36.8 + Q7.8 => OK */
    7680:	07 4c       	mov	r12,	r7	;
    7682:	37 50 4e 70 	add	#28750,	r7	;#0x704e
    7686:	5a 43       	mov.b	#1,	r10	;r3 As==01
    7688:	3c 90 b2 8f 	cmp	#-28750,r12	;#0x8fb2
    768c:	01 2c       	jc	$+4      	;abs 0x7690
    768e:	0a 49       	mov	r9,	r10	;

00007690 <.L13>:
    7690:	4c 43       	clr.b	r12		;
    7692:	0a 5d       	add	r13,	r10	;
    7694:	5e 43       	mov.b	#1,	r14	;r3 As==01
    7696:	0a 9d       	cmp	r13,	r10	;
    7698:	01 28       	jnc	$+4      	;abs 0x769c
    769a:	0e 4c       	mov	r12,	r14	;

0000769c <.L15>:
    769c:	0c de       	bis	r14,	r12	;
    769e:	49 43       	clr.b	r9		;
    76a0:	0e 4c       	mov	r12,	r14	;
    76a2:	0e 58       	add	r8,	r14	;
    76a4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    76a6:	0e 98       	cmp	r8,	r14	;
    76a8:	01 28       	jnc	$+4      	;abs 0x76ac
    76aa:	0c 49       	mov	r9,	r12	;

000076ac <.L17>:
    76ac:	09 dc       	bis	r12,	r9	;

000076ae <.Loc.75.1>:
}
    76ae:	0c 47       	mov	r7,	r12	;
    76b0:	0d 4a       	mov	r10,	r13	;
    76b2:	0f 59       	add	r9,	r15	;
    76b4:	21 53       	incd	r1		;
    76b6:	55 17       	popm	#6,	r10	;16-bit words
    76b8:	30 41       	ret			

000076ba <Thread2>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    76ba:	6a 15       	pushm	#7,	r10	;16-bit words

000076bc <.LCFI2>:
    76bc:	31 80 0e 00 	sub	#14,	r1	;#0x000e

000076c0 <.LCFI3>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD1, NULL);
    76c0:	4d 43       	clr.b	r13		;
    76c2:	3c 40 fa 51 	mov	#20986,	r12	;#0x51fa

000076c6 <.LVL21>:
    76c6:	b0 12 3a 6a 	call	#27194		;#0x6a3a

000076ca <.LVL22>:
  
  /* Activate the ADC driver 1 using its config */
  adcStart(&ADCD1, &adc_config);
    76ca:	3d 40 0e 5c 	mov	#23566,	r13	;#0x5c0e
    76ce:	3c 40 fa 52 	mov	#21242,	r12	;#0x52fa
    76d2:	b0 12 ea 68 	call	#26858		;#0x68ea

000076d6 <.LVL23>:

  /*chnWrite(&SD1, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  uint8_t in;
  bool powered = false;
    76d6:	48 43       	clr.b	r8		;
    76d8:	37 40 ec 7d 	mov	#32236,	r7	;#0x7dec

000076dc <.Loc.156.1>:
        powered = false;
        chnWrite(&SD1, (const uint8_t *)therm_string, strlen(therm_string));
      }
    }
    
    sniprintf(out_string, 128, fmt_string, "Bottom", temps[0] >> 8);
    76dc:	36 40 60 5b 	mov	#23392,	r6	;#0x5b60

000076e0 <.L26>:
    in = sdGetTimeout(&SD1, TIME_IMMEDIATE);
    76e0:	3d 43       	mov	#-1,	r13	;r3 As==11
    76e2:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    76e6:	b0 12 08 66 	call	#26120		;#0x6608

000076ea <.LVL25>:
    if (in == 'p') {
    76ea:	7c 90 70 00 	cmp.b	#112,	r12	;#0x0070
    76ee:	25 20       	jnz	$+76     	;abs 0x773a
    76f0:	3c 40 f0 60 	mov	#24816,	r12	;#0x60f0

000076f4 <.LVL26>:
    76f4:	39 40 0e 61 	mov	#24846,	r9	;#0x610e
    76f8:	3a 40 fa 51 	mov	#20986,	r10	;#0x51fa

000076fc <.Loc.115.1>:
      if (powered) {
    76fc:	08 93       	cmp	#0,	r8	;r3 As==00
    76fe:	2b 24       	jz	$+88     	;abs 0x7756

00007700 <.LBB27>:
  _disable_interrupts();
    7700:	32 c2       	dint			
    7702:	03 43       	nop			

00007704 <.Loc.348.2>:
  asm volatile("nop");
    7704:	03 43       	nop			

00007706 <.LBE29>:
  chSysLock();
    7706:	8c 12       	call	r12		;

00007708 <.LBE27>:
        palLineDisableEventI(LINE_PA_PGOOD);
    7708:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    770c:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    7710:	b0 12 0c 6f 	call	#28428		;#0x6f0c

00007714 <.LBB31>:
  chSysUnlock();
    7714:	89 12       	call	r9		;

00007716 <.LBB33>:
  asm volatile("nop");
    7716:	03 43       	nop			

00007718 <.Loc.356.2>:
  _enable_interrupts();
    7718:	03 43       	nop			
    771a:	32 d2       	eint			
    771c:	03 43       	nop			

0000771e <.LBE31>:
        palClearLine(LINE_PA_PC_EN);
    771e:	b2 f0 ff ef 	and	#-4097,	&0x0222	;#0xefff
    7722:	22 02 

00007724 <.LVL30>:
        chnWrite(&SD1, (const uint8_t *)unpow_string, strlen(unpow_string));
    7724:	19 42 5a 5b 	mov	&0x5b5a,r9	;0x5b5a
    7728:	0c 49       	mov	r9,	r12	;
    772a:	87 12       	call	r7		;

0000772c <.LVL31>:
    772c:	2f 4a       	mov	@r10,	r15	;
    772e:	0e 4c       	mov	r12,	r14	;
    7730:	0d 49       	mov	r9,	r13	;
    7732:	0c 4a       	mov	r10,	r12	;
    7734:	2f 4f       	mov	@r15,	r15	;
    7736:	8f 12       	call	r15		;

00007738 <.LVL32>:
        powered = false;
    7738:	48 43       	clr.b	r8		;

0000773a <.L19>:
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    773a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    773c:	3e 40 f2 5c 	mov	#23794,	r14	;#0x5cf2
    7740:	3d 40 e0 5b 	mov	#23520,	r13	;#0x5be0
    7744:	3c 40 fa 52 	mov	#21242,	r12	;#0x52fa
    7748:	b0 12 0a 69 	call	#26890		;#0x690a

0000774c <.LVL34>:
    while (ADCD1.state == ADC_ACTIVE) ;
    774c:	f2 90 03 00 	cmp.b	#3,	&0x52fa	;
    7750:	fa 52 
    7752:	22 20       	jnz	$+70     	;abs 0x7798

00007754 <.L30>:
    7754:	ff 3f       	jmp	$+0      	;abs 0x7754

00007756 <.L20>:
  _disable_interrupts();
    7756:	32 c2       	dint			
    7758:	03 43       	nop			

0000775a <.Loc.348.2>:
  asm volatile("nop");
    775a:	03 43       	nop			

0000775c <.LBE37>:
  chSysLock();
    775c:	8c 12       	call	r12		;

0000775e <.LBE35>:
        palLineEnableEventI(LINE_PA_PGOOD, PAL_EVENT_MODE_FALLING_EDGE, save_bacon);
    775e:	3f 40 90 75 	mov	#30096,	r15	;#0x7590
    7762:	6e 43       	mov.b	#2,	r14	;r3 As==10
    7764:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    7768:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    776c:	b0 12 70 6e 	call	#28272		;#0x6e70

00007770 <.LBB39>:
  chSysUnlock();
    7770:	89 12       	call	r9		;

00007772 <.LBB41>:
  asm volatile("nop");
    7772:	03 43       	nop			

00007774 <.Loc.356.2>:
  _enable_interrupts();
    7774:	03 43       	nop			
    7776:	32 d2       	eint			
    7778:	03 43       	nop			

0000777a <.LBE39>:
        palSetLine(LINE_PA_PC_EN);
    777a:	b2 d0 00 10 	bis	#4096,	&0x0222	;#0x1000
    777e:	22 02 

00007780 <.LVL38>:
        chnWrite(&SD1, (const uint8_t *)pow_string, strlen(pow_string));
    7780:	19 42 5c 5b 	mov	&0x5b5c,r9	;0x5b5c
    7784:	0c 49       	mov	r9,	r12	;
    7786:	87 12       	call	r7		;

00007788 <.LVL39>:
    7788:	2f 4a       	mov	@r10,	r15	;
    778a:	0e 4c       	mov	r12,	r14	;
    778c:	0d 49       	mov	r9,	r13	;
    778e:	0c 4a       	mov	r10,	r12	;
    7790:	2f 4f       	mov	@r15,	r15	;
    7792:	8f 12       	call	r15		;

00007794 <.LVL40>:
        powered = true;
    7794:	58 43       	mov.b	#1,	r8	;r3 As==01
    7796:	d1 3f       	jmp	$-92     	;abs 0x773a

00007798 <.L31>:
    7798:	39 40 f6 5c 	mov	#23798,	r9	;#0x5cf6

0000779c <.Loc.140.1>:
    while (ADCD1.state == ADC_ACTIVE) ;
    779c:	44 43       	clr.b	r4		;
    779e:	0a 49       	mov	r9,	r10	;
    77a0:	35 40 68 7a 	mov	#31336,	r5	;#0x7a68

000077a4 <.L24>:
      temps[i] = convert_ntc(&adc_group, samples[i]);
    77a4:	1d 44 f2 5c 	mov	23794(r4),r13	;0x05cf2
    77a8:	3c 40 e0 5b 	mov	#23520,	r12	;#0x5be0
    77ac:	b0 12 98 75 	call	#30104		;#0x7598

000077b0 <.LVL43>:
    77b0:	89 4c 00 00 	mov	r12,	0(r9)	;
    77b4:	89 4d 02 00 	mov	r13,	2(r9)	;
    77b8:	89 4e 04 00 	mov	r14,	4(r9)	;
    77bc:	89 4f 06 00 	mov	r15,	6(r9)	;

000077c0 <.Loc.144.1>:
      if ((temps[i] >> 8) > 60) {
    77c0:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    77c4:	b0 12 68 7a 	call	#31336		;#0x7a68
    77c8:	4b 43       	clr.b	r11		;
    77ca:	0b 9f       	cmp	r15,	r11	;
    77cc:	0a 38       	jl	$+22     	;abs 0x77e2
    77ce:	0f 9b       	cmp	r11,	r15	;
    77d0:	2c 20       	jnz	$+90     	;abs 0x782a
    77d2:	0e 9b       	cmp	r11,	r14	;
    77d4:	06 20       	jnz	$+14     	;abs 0x77e2
    77d6:	0d 9b       	cmp	r11,	r13	;
    77d8:	04 20       	jnz	$+10     	;abs 0x77e2
    77da:	7d 40 3c 00 	mov.b	#60,	r13	;#0x003c
    77de:	0d 9c       	cmp	r12,	r13	;
    77e0:	24 2c       	jc	$+74     	;abs 0x782a

000077e2 <.L27>:
  _disable_interrupts();
    77e2:	32 c2       	dint			
    77e4:	03 43       	nop			

000077e6 <.Loc.348.2>:
  asm volatile("nop");
    77e6:	03 43       	nop			

000077e8 <.LBE46>:
  chSysLock();
    77e8:	b0 12 f0 60 	call	#24816		;#0x60f0

000077ec <.LBE44>:
        palLineDisableEventI(LINE_PA_PGOOD);
    77ec:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    77f0:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    77f4:	b0 12 0c 6f 	call	#28428		;#0x6f0c

000077f8 <.LBB48>:
  chSysUnlock();
    77f8:	b0 12 0e 61 	call	#24846		;#0x610e

000077fc <.LBB50>:
  asm volatile("nop");
    77fc:	03 43       	nop			

000077fe <.Loc.356.2>:
  _enable_interrupts();
    77fe:	03 43       	nop			
    7800:	32 d2       	eint			
    7802:	03 43       	nop			

00007804 <.LBE48>:
        palClearLine(LINE_PA_PC_EN);
    7804:	b2 f0 ff ef 	and	#-4097,	&0x0222	;#0xefff
    7808:	22 02 

0000780a <.LVL48>:
        chnWrite(&SD1, (const uint8_t *)therm_string, strlen(therm_string));
    780a:	1d 42 56 5b 	mov	&0x5b56,r13	;0x5b56
    780e:	0c 4d       	mov	r13,	r12	;
    7810:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    7814:	87 12       	call	r7		;

00007816 <.LVL49>:
    7816:	3f 40 fa 51 	mov	#20986,	r15	;#0x51fa
    781a:	28 4f       	mov	@r15,	r8	;
    781c:	0e 4c       	mov	r12,	r14	;
    781e:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    7822:	0c 4f       	mov	r15,	r12	;
    7824:	28 48       	mov	@r8,	r8	;
    7826:	88 12       	call	r8		;

00007828 <.LVL50>:
        powered = false;
    7828:	48 43       	clr.b	r8		;

0000782a <.L22>:
    782a:	39 52       	add	#8,	r9	;r2 As==11
    782c:	24 53       	incd	r4		;

0000782e <.Loc.142.1>:
    for (int i = 0; i < 2; i++) {
    782e:	24 92       	cmp	#4,	r4	;r2 As==10
    7830:	b9 23       	jnz	$-140    	;abs 0x77a4

00007832 <.LBE43>:
    sniprintf(out_string, 128, fmt_string, "Bottom", temps[0] >> 8);
    7832:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    7836:	2c 4a       	mov	@r10,	r12	;
    7838:	1d 4a 02 00 	mov	2(r10),	r13	;
    783c:	1e 4a 04 00 	mov	4(r10),	r14	;
    7840:	1f 4a 06 00 	mov	6(r10),	r15	;
    7844:	85 12       	call	r5		;
    7846:	81 4c 04 00 	mov	r12,	4(r1)	;
    784a:	81 4d 06 00 	mov	r13,	6(r1)	;
    784e:	81 4e 08 00 	mov	r14,	8(r1)	;
    7852:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    7856:	b1 40 68 50 	mov	#20584,	2(r1)	;#0x5068
    785a:	02 00 
    785c:	91 42 5e 5b 	mov	&0x5b5e,0(r1)	;0x5b5e
    7860:	00 00 
    7862:	34 40 82 7d 	mov	#32130,	r4	;#0x7d82
    7866:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    786a:	0c 46       	mov	r6,	r12	;
    786c:	84 12       	call	r4		;

0000786e <.LVL53>:
    chnWrite(&SD1, (const uint8_t *)out_string, strlen(out_string));
    786e:	0c 46       	mov	r6,	r12	;
    7870:	87 12       	call	r7		;

00007872 <.LVL54>:
    7872:	39 40 fa 51 	mov	#20986,	r9	;#0x51fa
    7876:	2f 49       	mov	@r9,	r15	;
    7878:	0e 4c       	mov	r12,	r14	;
    787a:	0d 46       	mov	r6,	r13	;
    787c:	0c 49       	mov	r9,	r12	;
    787e:	2f 4f       	mov	@r15,	r15	;
    7880:	8f 12       	call	r15		;

00007882 <.LVL55>:
    sniprintf(out_string, 128, fmt_string, "Top", temps[1] >> 8);
    7882:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    7886:	1c 4a 08 00 	mov	8(r10),	r12	;
    788a:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    788e:	1e 4a 0c 00 	mov	12(r10),r14	;0x0000c
    7892:	1f 4a 0e 00 	mov	14(r10),r15	;0x0000e
    7896:	85 12       	call	r5		;
    7898:	81 4c 04 00 	mov	r12,	4(r1)	;
    789c:	81 4d 06 00 	mov	r13,	6(r1)	;
    78a0:	81 4e 08 00 	mov	r14,	8(r1)	;
    78a4:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    78a8:	b1 40 6f 50 	mov	#20591,	2(r1)	;#0x506f
    78ac:	02 00 
    78ae:	91 42 5e 5b 	mov	&0x5b5e,0(r1)	;0x5b5e
    78b2:	00 00 
    78b4:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    78b8:	0c 46       	mov	r6,	r12	;
    78ba:	84 12       	call	r4		;

000078bc <.LVL57>:
    chnWrite(&SD1, (const uint8_t *)out_string, strlen(out_string));
    78bc:	0c 46       	mov	r6,	r12	;
    78be:	87 12       	call	r7		;

000078c0 <.LVL58>:
    78c0:	2f 49       	mov	@r9,	r15	;
    78c2:	0e 4c       	mov	r12,	r14	;
    78c4:	0d 46       	mov	r6,	r13	;
    78c6:	0c 49       	mov	r9,	r12	;
    78c8:	2f 4f       	mov	@r15,	r15	;
    78ca:	8f 12       	call	r15		;

000078cc <.LVL59>:
    
    if (powered != (palReadLine(LINE_PA_PC_EN) == PAL_HIGH)) {
    78cc:	35 40 20 02 	mov	#544,	r5	;#0x0220
    78d0:	2c 45       	mov	@r5,	r12	;
    78d2:	5c 03       	rrum	#1,	r12	;
    78d4:	4a 18 0c 11 	rpt #11 { rrax.w	r12		;
    78d8:	5c f3       	and.b	#1,	r12	;r3 As==01
    78da:	4a 4c       	mov.b	r12,	r10	;
    78dc:	4c 98       	cmp.b	r8,	r12	;
    78de:	0f 24       	jz	$+32     	;abs 0x78fe

000078e0 <.Loc.162.1>:
      chnWrite(&SD1, (const uint8_t *)err_string, strlen(err_string));
    78e0:	1a 42 58 5b 	mov	&0x5b58,r10	;0x5b58
    78e4:	0c 4a       	mov	r10,	r12	;
    78e6:	87 12       	call	r7		;

000078e8 <.LVL60>:
    78e8:	2f 49       	mov	@r9,	r15	;
    78ea:	0e 4c       	mov	r12,	r14	;
    78ec:	0d 4a       	mov	r10,	r13	;
    78ee:	0c 49       	mov	r9,	r12	;
    78f0:	2f 4f       	mov	@r15,	r15	;
    78f2:	8f 12       	call	r15		;

000078f4 <.LVL61>:
      powered = (palReadLine(LINE_PA_PC_EN) == PAL_HIGH);
    78f4:	2a 45       	mov	@r5,	r10	;
    78f6:	5a 03       	rrum	#1,	r10	;
    78f8:	4a 18 0a 11 	rpt #11 { rrax.w	r10		;
    78fc:	5a f3       	and.b	#1,	r10	;r3 As==01

000078fe <.L25>:
    }
    
    chThdSleepMilliseconds(500);
    78fe:	3c 40 f4 01 	mov	#500,	r12	;#0x01f4
    7902:	b0 12 1a 64 	call	#25626		;#0x641a

00007906 <.LVL63>:
    in = sdGetTimeout(&SD1, TIME_IMMEDIATE);
    7906:	08 4a       	mov	r10,	r8	;
    7908:	eb 3e       	jmp	$-552    	;abs 0x76e0

0000790a <main>:
    790a:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    790e:	5c 01 

00007910 <L0>:
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
  

  halInit();
    7910:	b0 12 4e 65 	call	#25934		;#0x654e

00007914 <.LVL64>:
  chSysInit();
    7914:	b0 12 f4 61 	call	#25076		;#0x61f4

00007918 <.LVL65>:
  dmaInit();
    7918:	b0 12 5e 6f 	call	#28510		;#0x6f5e

0000791c <.L33>:
    791c:	ff 3f       	jmp	$+0      	;abs 0x791c

0000791e <__mspabi_mpyll>:
    791e:	6a 15       	pushm	#7,	r10	;16-bit words

00007920 <L0>:
    7920:	31 80 1c 00 	sub	#28,	r1	;#0x001c

00007924 <.LCFI1>:
    7924:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    7928:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    792c:	06 4c       	mov	r12,	r6	;
    792e:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    7932:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    7936:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

0000793a <.LBB2>:
    793a:	0a 48       	mov	r8,	r10	;
    793c:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    7940:	0c 48       	mov	r8,	r12	;

00007942 <.LVL3>:
    7942:	0d 49       	mov	r9,	r13	;
    7944:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7948:	b0 12 34 7d 	call	#32052		;#0x7d34
    794c:	81 4c 00 00 	mov	r12,	0(r1)	;
    7950:	81 4d 02 00 	mov	r13,	2(r1)	;

00007954 <.LVL5>:
    7954:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    7958:	0c 46       	mov	r6,	r12	;
    795a:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    795e:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7962:	b0 12 34 7d 	call	#32052		;#0x7d34
    7966:	81 4c 04 00 	mov	r12,	4(r1)	;
    796a:	81 4d 06 00 	mov	r13,	6(r1)	;
    796e:	38 40 4e 7d 	mov	#32078,	r8	;#0x7d4e

00007972 <.LVL9>:
    7972:	0e 46       	mov	r6,	r14	;
    7974:	4f 43       	clr.b	r15		;
    7976:	0c 4a       	mov	r10,	r12	;
    7978:	0d 4f       	mov	r15,	r13	;
    797a:	88 12       	call	r8		;

0000797c <.LVL10>:
    797c:	04 4c       	mov	r12,	r4	;
    797e:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    7982:	05 4d       	mov	r13,	r5	;

00007984 <.LVL11>:
    7984:	0e 46       	mov	r6,	r14	;
    7986:	4f 43       	clr.b	r15		;
    7988:	2c 41       	mov	@r1,	r12	;
    798a:	1d 41 02 00 	mov	2(r1),	r13	;
    798e:	88 12       	call	r8		;

00007990 <.LVL12>:
    7990:	06 4c       	mov	r12,	r6	;
    7992:	07 4d       	mov	r13,	r7	;

00007994 <.LVL14>:
    7994:	1e 41 04 00 	mov	4(r1),	r14	;
    7998:	1f 41 06 00 	mov	6(r1),	r15	;
    799c:	2c 41       	mov	@r1,	r12	;
    799e:	1d 41 02 00 	mov	2(r1),	r13	;
    79a2:	88 12       	call	r8		;

000079a4 <.LVL15>:
    79a4:	81 4c 00 00 	mov	r12,	0(r1)	;

000079a8 <.LVL16>:
    79a8:	81 4d 02 00 	mov	r13,	2(r1)	;

000079ac <.LVL17>:
    79ac:	1e 41 04 00 	mov	4(r1),	r14	;
    79b0:	1f 41 06 00 	mov	6(r1),	r15	;
    79b4:	0c 4a       	mov	r10,	r12	;
    79b6:	4d 43       	clr.b	r13		;
    79b8:	88 12       	call	r8		;

000079ba <.LVL18>:
    79ba:	0a 4c       	mov	r12,	r10	;
    79bc:	0a 56       	add	r6,	r10	;
    79be:	08 4d       	mov	r13,	r8	;
    79c0:	08 67       	addc	r7,	r8	;
    79c2:	0c 44       	mov	r4,	r12	;
    79c4:	0d 45       	mov	r5,	r13	;
    79c6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    79ca:	b0 12 34 7d 	call	#32052		;#0x7d34
    79ce:	05 4c       	mov	r12,	r5	;

000079d0 <.LVL22>:
    79d0:	05 5a       	add	r10,	r5	;
    79d2:	0d 68       	addc	r8,	r13	;

000079d4 <.LVL23>:
    79d4:	0d 97       	cmp	r7,	r13	;
    79d6:	04 28       	jnc	$+10     	;abs 0x79e0
    79d8:	07 9d       	cmp	r13,	r7	;
    79da:	06 20       	jnz	$+14     	;abs 0x79e8
    79dc:	05 96       	cmp	r6,	r5	;
    79de:	04 2c       	jc	$+10     	;abs 0x79e8

000079e0 <.L4>:
    79e0:	81 53 00 00 	add	#0,	0(r1)	;r3 As==00
    79e4:	91 63 02 00 	addc	#1,	2(r1)	;r3 As==01

000079e8 <.L2>:
    79e8:	0c 45       	mov	r5,	r12	;
    79ea:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    79ee:	b0 12 34 7d 	call	#32052		;#0x7d34

000079f2 <.LVL25>:
    79f2:	28 41       	mov	@r1,	r8	;
    79f4:	08 5c       	add	r12,	r8	;
    79f6:	1d 61 02 00 	addc	2(r1),	r13	;
    79fa:	0a 4d       	mov	r13,	r10	;
    79fc:	47 43       	clr.b	r7		;

000079fe <.LVL27>:
    79fe:	0c 45       	mov	r5,	r12	;
    7a00:	0d 47       	mov	r7,	r13	;
    7a02:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    7a06:	b0 12 0c 7c 	call	#31756		;#0x7c0c
    7a0a:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    7a0e:	0c 5f       	add	r15,	r12	;
    7a10:	0d 67       	addc	r7,	r13	;

00007a12 <.LBE2>:
    7a12:	04 4c       	mov	r12,	r4	;
    7a14:	05 4d       	mov	r13,	r5	;
    7a16:	06 48       	mov	r8,	r6	;
    7a18:	07 4a       	mov	r10,	r7	;

00007a1a <.Loc.553.1>:
    7a1a:	3a 40 4e 7d 	mov	#32078,	r10	;#0x7d4e
    7a1e:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    7a22:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    7a26:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    7a2a:	0d 49       	mov	r9,	r13	;
    7a2c:	8a 12       	call	r10		;

00007a2e <.LVL29>:
    7a2e:	09 4c       	mov	r12,	r9	;
    7a30:	08 4d       	mov	r13,	r8	;

00007a32 <.Loc.554.1>:
    7a32:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    7a36:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    7a3a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    7a3e:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    7a42:	8a 12       	call	r10		;

00007a44 <.LVL30>:
    7a44:	09 5c       	add	r12,	r9	;
    7a46:	81 49 08 00 	mov	r9,	8(r1)	;
    7a4a:	08 6d       	addc	r13,	r8	;
    7a4c:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a

00007a50 <.Loc.553.1>:
    7a50:	16 51 08 00 	add	8(r1),	r6	;
    7a54:	17 61 0a 00 	addc	10(r1),	r7	;0x0000a

00007a58 <.Loc.557.1>:
    7a58:	0c 44       	mov	r4,	r12	;
    7a5a:	0d 45       	mov	r5,	r13	;
    7a5c:	0e 46       	mov	r6,	r14	;
    7a5e:	0f 47       	mov	r7,	r15	;
    7a60:	31 50 1c 00 	add	#28,	r1	;#0x001c

00007a64 <.LVL31>:
    7a64:	64 17       	popm	#7,	r10	;16-bit words
    7a66:	30 41       	ret			

00007a68 <__ashrdi3>:
    7a68:	6a 15       	pushm	#7,	r10	;16-bit words

00007a6a <.LCFI0>:
    7a6a:	21 83       	decd	r1		;

00007a6c <.LCFI1>:
    7a6c:	05 4c       	mov	r12,	r5	;
    7a6e:	0a 4d       	mov	r13,	r10	;
    7a70:	1b 41 12 00 	mov	18(r1),	r11	;0x00012

00007a74 <.Loc.461.1>:
    7a74:	0b 93       	cmp	#0,	r11	;r3 As==00
    7a76:	1e 24       	jz	$+62     	;abs 0x7ab4

00007a78 <.Loc.465.1>:
    7a78:	37 40 20 00 	mov	#32,	r7	;#0x0020
    7a7c:	07 8b       	sub	r11,	r7	;

00007a7e <.LVL1>:
    7a7e:	4c 43       	clr.b	r12		;

00007a80 <.LVL2>:
    7a80:	0c 97       	cmp	r7,	r12	;
    7a82:	1d 38       	jl	$+60     	;abs 0x7abe

00007a84 <.Loc.471.1>:
    7a84:	06 4e       	mov	r14,	r6	;
    7a86:	0a 4f       	mov	r15,	r10	;
    7a88:	0c 4e       	mov	r14,	r12	;
    7a8a:	0d 4f       	mov	r15,	r13	;
    7a8c:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    7a90:	b0 12 80 7c 	call	#31872		;#0x7c80
    7a94:	08 4c       	mov	r12,	r8	;
    7a96:	09 4d       	mov	r13,	r9	;

00007a98 <.Loc.472.1>:
    7a98:	0e 43       	clr	r14		;
    7a9a:	0e 87       	sub	r7,	r14	;
    7a9c:	0c 46       	mov	r6,	r12	;
    7a9e:	0d 4a       	mov	r10,	r13	;
    7aa0:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    7aa4:	0f 7f       	subc	r15,	r15	;
    7aa6:	3f e3       	inv	r15		;
    7aa8:	b0 12 80 7c 	call	#31872		;#0x7c80
    7aac:	05 4c       	mov	r12,	r5	;
    7aae:	0a 4d       	mov	r13,	r10	;

00007ab0 <.L4>:
    7ab0:	0e 48       	mov	r8,	r14	;
    7ab2:	0f 49       	mov	r9,	r15	;

00007ab4 <.L2>:
    7ab4:	0c 45       	mov	r5,	r12	;
    7ab6:	0d 4a       	mov	r10,	r13	;
    7ab8:	21 53       	incd	r1		;
    7aba:	64 17       	popm	#7,	r10	;16-bit words
    7abc:	30 41       	ret			

00007abe <.L3>:
    7abe:	04 4e       	mov	r14,	r4	;
    7ac0:	06 4f       	mov	r15,	r6	;

00007ac2 <.Loc.478.1>:
    7ac2:	0c 4e       	mov	r14,	r12	;
    7ac4:	0d 4f       	mov	r15,	r13	;
    7ac6:	0e 4b       	mov	r11,	r14	;
    7ac8:	0f 4b       	mov	r11,	r15	;
    7aca:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    7ace:	81 4b 00 00 	mov	r11,	0(r1)	;
    7ad2:	b0 12 80 7c 	call	#31872		;#0x7c80

00007ad6 <.LVL9>:
    7ad6:	08 4c       	mov	r12,	r8	;
    7ad8:	09 4d       	mov	r13,	r9	;

00007ada <.Loc.479.1>:
    7ada:	0c 45       	mov	r5,	r12	;
    7adc:	0d 4a       	mov	r10,	r13	;
    7ade:	2b 41       	mov	@r1,	r11	;
    7ae0:	0e 4b       	mov	r11,	r14	;
    7ae2:	0f 43       	clr	r15		;
    7ae4:	b0 12 34 7d 	call	#32052		;#0x7d34
    7ae8:	05 4c       	mov	r12,	r5	;
    7aea:	0a 4d       	mov	r13,	r10	;

00007aec <.Loc.476.1>:
    7aec:	0c 44       	mov	r4,	r12	;
    7aee:	0d 46       	mov	r6,	r13	;
    7af0:	0e 47       	mov	r7,	r14	;
    7af2:	0f 43       	clr	r15		;
    7af4:	b0 12 0c 7c 	call	#31756		;#0x7c0c

00007af8 <.Loc.479.1>:
    7af8:	0a dd       	bis	r13,	r10	;
    7afa:	0d 45       	mov	r5,	r13	;
    7afc:	0d dc       	bis	r12,	r13	;
    7afe:	05 4d       	mov	r13,	r5	;
    7b00:	d7 3f       	jmp	$-80     	;abs 0x7ab0

00007b02 <udivmodsi4>:
    7b02:	5a 15       	pushm	#6,	r10	;16-bit words

00007b04 <L0>:
    7b04:	0a 4c       	mov	r12,	r10	;
    7b06:	0b 4d       	mov	r13,	r11	;

00007b08 <.LVL1>:
    7b08:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00007b0c <.Loc.35.1>:
    7b0c:	58 43       	mov.b	#1,	r8	;r3 As==01
    7b0e:	49 43       	clr.b	r9		;

00007b10 <.Loc.38.1>:
    7b10:	07 4b       	mov	r11,	r7	;

00007b12 <.L2>:
    7b12:	0f 9b       	cmp	r11,	r15	;
    7b14:	11 28       	jnc	$+36     	;abs 0x7b38
    7b16:	07 9f       	cmp	r15,	r7	;
    7b18:	02 20       	jnz	$+6      	;abs 0x7b1e
    7b1a:	0e 9a       	cmp	r10,	r14	;
    7b1c:	0d 28       	jnc	$+28     	;abs 0x7b38

00007b1e <.L20>:
    7b1e:	4c 43       	clr.b	r12		;

00007b20 <.LVL3>:
    7b20:	0d 4c       	mov	r12,	r13	;

00007b22 <.L5>:
    7b22:	07 48       	mov	r8,	r7	;
    7b24:	07 d9       	bis	r9,	r7	;
    7b26:	07 93       	cmp	#0,	r7	;r3 As==00
    7b28:	19 20       	jnz	$+52     	;abs 0x7b5c

00007b2a <.L6>:
    7b2a:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    7b2e:	02 24       	jz	$+6      	;abs 0x7b34
    7b30:	0c 4a       	mov	r10,	r12	;
    7b32:	0d 4b       	mov	r11,	r13	;

00007b34 <.L1>:
    7b34:	55 17       	popm	#6,	r10	;16-bit words
    7b36:	30 41       	ret			

00007b38 <.L3>:
    7b38:	3d 53       	add	#-1,	r13	;r3 As==11

00007b3a <.Loc.38.1>:
    7b3a:	0d 93       	cmp	#0,	r13	;r3 As==00
    7b3c:	20 24       	jz	$+66     	;abs 0x7b7e

00007b3e <.Loc.38.1>:
    7b3e:	0f 93       	cmp	#0,	r15	;r3 As==00
    7b40:	ee 3b       	jl	$-34     	;abs 0x7b1e

00007b42 <.Loc.40.1>:
    7b42:	05 4e       	mov	r14,	r5	;
    7b44:	06 4f       	mov	r15,	r6	;
    7b46:	05 5e       	add	r14,	r5	;
    7b48:	06 6f       	addc	r15,	r6	;
    7b4a:	0e 45       	mov	r5,	r14	;

00007b4c <.LVL7>:
    7b4c:	0f 46       	mov	r6,	r15	;

00007b4e <.LVL8>:
    7b4e:	05 48       	mov	r8,	r5	;
    7b50:	06 49       	mov	r9,	r6	;
    7b52:	05 58       	add	r8,	r5	;
    7b54:	06 69       	addc	r9,	r6	;
    7b56:	08 45       	mov	r5,	r8	;

00007b58 <.LVL9>:
    7b58:	09 46       	mov	r6,	r9	;

00007b5a <.LVL10>:
    7b5a:	db 3f       	jmp	$-72     	;abs 0x7b12

00007b5c <.L12>:
    7b5c:	0b 9f       	cmp	r15,	r11	;
    7b5e:	08 28       	jnc	$+18     	;abs 0x7b70
    7b60:	0f 9b       	cmp	r11,	r15	;
    7b62:	02 20       	jnz	$+6      	;abs 0x7b68
    7b64:	0a 9e       	cmp	r14,	r10	;
    7b66:	04 28       	jnc	$+10     	;abs 0x7b70

00007b68 <.L16>:
    7b68:	0a 8e       	sub	r14,	r10	;
    7b6a:	0b 7f       	subc	r15,	r11	;

00007b6c <.Loc.48.1>:
    7b6c:	0c d8       	bis	r8,	r12	;

00007b6e <.LVL13>:
    7b6e:	0d d9       	bis	r9,	r13	;

00007b70 <.L10>:
    7b70:	12 c3       	clrc			
    7b72:	09 10       	rrc	r9		;
    7b74:	08 10       	rrc	r8		;

00007b76 <.Loc.51.1>:
    7b76:	12 c3       	clrc			
    7b78:	0f 10       	rrc	r15		;
    7b7a:	0e 10       	rrc	r14		;
    7b7c:	d2 3f       	jmp	$-90     	;abs 0x7b22

00007b7e <.L14>:
    7b7e:	0c 4d       	mov	r13,	r12	;

00007b80 <.LVL18>:
    7b80:	d4 3f       	jmp	$-86     	;abs 0x7b2a

00007b82 <__mspabi_divlu>:
    7b82:	21 83       	decd	r1		;

00007b84 <.LCFI5>:
    7b84:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00007b88 <L0>:
    7b88:	b0 12 02 7b 	call	#31490		;#0x7b02

00007b8c <.LVL46>:
    7b8c:	21 53       	incd	r1		;
    7b8e:	30 41       	ret			

00007b90 <__mspabi_remul>:
    7b90:	21 83       	decd	r1		;

00007b92 <.LCFI6>:
    7b92:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    7b96:	b0 12 02 7b 	call	#31490		;#0x7b02

00007b9a <.LVL48>:
    7b9a:	21 53       	incd	r1		;
    7b9c:	30 41       	ret			

00007b9e <__mspabi_slli_15>:
    7b9e:	0c 5c       	rla	r12		;

00007ba0 <__mspabi_slli_14>:
    7ba0:	0c 5c       	rla	r12		;

00007ba2 <__mspabi_slli_13>:
    7ba2:	0c 5c       	rla	r12		;

00007ba4 <__mspabi_slli_12>:
    7ba4:	0c 5c       	rla	r12		;

00007ba6 <__mspabi_slli_11>:
    7ba6:	0c 5c       	rla	r12		;

00007ba8 <__mspabi_slli_10>:
    7ba8:	0c 5c       	rla	r12		;

00007baa <__mspabi_slli_9>:
    7baa:	0c 5c       	rla	r12		;

00007bac <__mspabi_slli_8>:
    7bac:	0c 5c       	rla	r12		;

00007bae <__mspabi_slli_7>:
    7bae:	0c 5c       	rla	r12		;

00007bb0 <__mspabi_slli_6>:
    7bb0:	0c 5c       	rla	r12		;

00007bb2 <__mspabi_slli_5>:
    7bb2:	0c 5c       	rla	r12		;

00007bb4 <__mspabi_slli_4>:
    7bb4:	0c 5c       	rla	r12		;

00007bb6 <__mspabi_slli_3>:
    7bb6:	0c 5c       	rla	r12		;

00007bb8 <__mspabi_slli_2>:
    7bb8:	0c 5c       	rla	r12		;

00007bba <__mspabi_slli_1>:
    7bba:	0c 5c       	rla	r12		;
    7bbc:	30 41       	ret			

00007bbe <.L11>:
    7bbe:	3d 53       	add	#-1,	r13	;r3 As==11
    7bc0:	0c 5c       	rla	r12		;

00007bc2 <__mspabi_slli>:
    7bc2:	0d 93       	cmp	#0,	r13	;r3 As==00
    7bc4:	fc 23       	jnz	$-6      	;abs 0x7bbe
    7bc6:	30 41       	ret			

00007bc8 <__mspabi_slll_15>:
    7bc8:	0c 5c       	rla	r12		;
    7bca:	0d 6d       	rlc	r13		;

00007bcc <__mspabi_slll_14>:
    7bcc:	0c 5c       	rla	r12		;
    7bce:	0d 6d       	rlc	r13		;

00007bd0 <__mspabi_slll_13>:
    7bd0:	0c 5c       	rla	r12		;
    7bd2:	0d 6d       	rlc	r13		;

00007bd4 <__mspabi_slll_12>:
    7bd4:	0c 5c       	rla	r12		;
    7bd6:	0d 6d       	rlc	r13		;

00007bd8 <__mspabi_slll_11>:
    7bd8:	0c 5c       	rla	r12		;
    7bda:	0d 6d       	rlc	r13		;

00007bdc <__mspabi_slll_10>:
    7bdc:	0c 5c       	rla	r12		;
    7bde:	0d 6d       	rlc	r13		;

00007be0 <__mspabi_slll_9>:
    7be0:	0c 5c       	rla	r12		;
    7be2:	0d 6d       	rlc	r13		;

00007be4 <__mspabi_slll_8>:
    7be4:	0c 5c       	rla	r12		;
    7be6:	0d 6d       	rlc	r13		;

00007be8 <__mspabi_slll_7>:
    7be8:	0c 5c       	rla	r12		;
    7bea:	0d 6d       	rlc	r13		;

00007bec <__mspabi_slll_6>:
    7bec:	0c 5c       	rla	r12		;
    7bee:	0d 6d       	rlc	r13		;

00007bf0 <__mspabi_slll_5>:
    7bf0:	0c 5c       	rla	r12		;
    7bf2:	0d 6d       	rlc	r13		;

00007bf4 <__mspabi_slll_4>:
    7bf4:	0c 5c       	rla	r12		;
    7bf6:	0d 6d       	rlc	r13		;

00007bf8 <__mspabi_slll_3>:
    7bf8:	0c 5c       	rla	r12		;
    7bfa:	0d 6d       	rlc	r13		;

00007bfc <__mspabi_slll_2>:
    7bfc:	0c 5c       	rla	r12		;
    7bfe:	0d 6d       	rlc	r13		;

00007c00 <__mspabi_slll_1>:
    7c00:	0c 5c       	rla	r12		;
    7c02:	0d 6d       	rlc	r13		;
    7c04:	30 41       	ret			

00007c06 <.L12>:
    7c06:	3e 53       	add	#-1,	r14	;r3 As==11
    7c08:	0c 5c       	rla	r12		;
    7c0a:	0d 6d       	rlc	r13		;

00007c0c <__mspabi_slll>:
    7c0c:	0e 93       	cmp	#0,	r14	;r3 As==00
    7c0e:	fb 23       	jnz	$-8      	;abs 0x7c06
    7c10:	30 41       	ret			

00007c12 <__mspabi_srai_15>:
    7c12:	0c 11       	rra	r12		;

00007c14 <__mspabi_srai_14>:
    7c14:	0c 11       	rra	r12		;

00007c16 <__mspabi_srai_13>:
    7c16:	0c 11       	rra	r12		;

00007c18 <__mspabi_srai_12>:
    7c18:	0c 11       	rra	r12		;

00007c1a <__mspabi_srai_11>:
    7c1a:	0c 11       	rra	r12		;

00007c1c <__mspabi_srai_10>:
    7c1c:	0c 11       	rra	r12		;

00007c1e <__mspabi_srai_9>:
    7c1e:	0c 11       	rra	r12		;

00007c20 <__mspabi_srai_8>:
    7c20:	0c 11       	rra	r12		;

00007c22 <__mspabi_srai_7>:
    7c22:	0c 11       	rra	r12		;

00007c24 <__mspabi_srai_6>:
    7c24:	0c 11       	rra	r12		;

00007c26 <__mspabi_srai_5>:
    7c26:	0c 11       	rra	r12		;

00007c28 <__mspabi_srai_4>:
    7c28:	0c 11       	rra	r12		;

00007c2a <__mspabi_srai_3>:
    7c2a:	0c 11       	rra	r12		;

00007c2c <__mspabi_srai_2>:
    7c2c:	0c 11       	rra	r12		;

00007c2e <__mspabi_srai_1>:
    7c2e:	0c 11       	rra	r12		;
    7c30:	30 41       	ret			

00007c32 <.L11>:
    7c32:	3d 53       	add	#-1,	r13	;r3 As==11
    7c34:	0c 11       	rra	r12		;

00007c36 <__mspabi_srai>:
    7c36:	0d 93       	cmp	#0,	r13	;r3 As==00
    7c38:	fc 23       	jnz	$-6      	;abs 0x7c32
    7c3a:	30 41       	ret			

00007c3c <__mspabi_sral_15>:
    7c3c:	0d 11       	rra	r13		;
    7c3e:	0c 10       	rrc	r12		;

00007c40 <__mspabi_sral_14>:
    7c40:	0d 11       	rra	r13		;
    7c42:	0c 10       	rrc	r12		;

00007c44 <__mspabi_sral_13>:
    7c44:	0d 11       	rra	r13		;
    7c46:	0c 10       	rrc	r12		;

00007c48 <__mspabi_sral_12>:
    7c48:	0d 11       	rra	r13		;
    7c4a:	0c 10       	rrc	r12		;

00007c4c <__mspabi_sral_11>:
    7c4c:	0d 11       	rra	r13		;
    7c4e:	0c 10       	rrc	r12		;

00007c50 <__mspabi_sral_10>:
    7c50:	0d 11       	rra	r13		;
    7c52:	0c 10       	rrc	r12		;

00007c54 <__mspabi_sral_9>:
    7c54:	0d 11       	rra	r13		;
    7c56:	0c 10       	rrc	r12		;

00007c58 <__mspabi_sral_8>:
    7c58:	0d 11       	rra	r13		;
    7c5a:	0c 10       	rrc	r12		;

00007c5c <__mspabi_sral_7>:
    7c5c:	0d 11       	rra	r13		;
    7c5e:	0c 10       	rrc	r12		;

00007c60 <__mspabi_sral_6>:
    7c60:	0d 11       	rra	r13		;
    7c62:	0c 10       	rrc	r12		;

00007c64 <__mspabi_sral_5>:
    7c64:	0d 11       	rra	r13		;
    7c66:	0c 10       	rrc	r12		;

00007c68 <__mspabi_sral_4>:
    7c68:	0d 11       	rra	r13		;
    7c6a:	0c 10       	rrc	r12		;

00007c6c <__mspabi_sral_3>:
    7c6c:	0d 11       	rra	r13		;
    7c6e:	0c 10       	rrc	r12		;

00007c70 <__mspabi_sral_2>:
    7c70:	0d 11       	rra	r13		;
    7c72:	0c 10       	rrc	r12		;

00007c74 <__mspabi_sral_1>:
    7c74:	0d 11       	rra	r13		;
    7c76:	0c 10       	rrc	r12		;
    7c78:	30 41       	ret			

00007c7a <.L12>:
    7c7a:	3e 53       	add	#-1,	r14	;r3 As==11
    7c7c:	0d 11       	rra	r13		;
    7c7e:	0c 10       	rrc	r12		;

00007c80 <__mspabi_sral>:
    7c80:	0e 93       	cmp	#0,	r14	;r3 As==00
    7c82:	fb 23       	jnz	$-8      	;abs 0x7c7a
    7c84:	30 41       	ret			

00007c86 <__mspabi_srli_15>:
    7c86:	12 c3       	clrc			
    7c88:	0c 10       	rrc	r12		;

00007c8a <__mspabi_srli_14>:
    7c8a:	12 c3       	clrc			
    7c8c:	0c 10       	rrc	r12		;

00007c8e <__mspabi_srli_13>:
    7c8e:	12 c3       	clrc			
    7c90:	0c 10       	rrc	r12		;

00007c92 <__mspabi_srli_12>:
    7c92:	12 c3       	clrc			
    7c94:	0c 10       	rrc	r12		;

00007c96 <__mspabi_srli_11>:
    7c96:	12 c3       	clrc			
    7c98:	0c 10       	rrc	r12		;

00007c9a <__mspabi_srli_10>:
    7c9a:	12 c3       	clrc			
    7c9c:	0c 10       	rrc	r12		;

00007c9e <__mspabi_srli_9>:
    7c9e:	12 c3       	clrc			
    7ca0:	0c 10       	rrc	r12		;

00007ca2 <__mspabi_srli_8>:
    7ca2:	12 c3       	clrc			
    7ca4:	0c 10       	rrc	r12		;

00007ca6 <__mspabi_srli_7>:
    7ca6:	12 c3       	clrc			
    7ca8:	0c 10       	rrc	r12		;

00007caa <__mspabi_srli_6>:
    7caa:	12 c3       	clrc			
    7cac:	0c 10       	rrc	r12		;

00007cae <__mspabi_srli_5>:
    7cae:	12 c3       	clrc			
    7cb0:	0c 10       	rrc	r12		;

00007cb2 <__mspabi_srli_4>:
    7cb2:	12 c3       	clrc			
    7cb4:	0c 10       	rrc	r12		;

00007cb6 <__mspabi_srli_3>:
    7cb6:	12 c3       	clrc			
    7cb8:	0c 10       	rrc	r12		;

00007cba <__mspabi_srli_2>:
    7cba:	12 c3       	clrc			
    7cbc:	0c 10       	rrc	r12		;

00007cbe <__mspabi_srli_1>:
    7cbe:	12 c3       	clrc			
    7cc0:	0c 10       	rrc	r12		;
    7cc2:	30 41       	ret			

00007cc4 <.L11>:
    7cc4:	3d 53       	add	#-1,	r13	;r3 As==11
    7cc6:	12 c3       	clrc			
    7cc8:	0c 10       	rrc	r12		;

00007cca <__mspabi_srli>:
    7cca:	0d 93       	cmp	#0,	r13	;r3 As==00
    7ccc:	fb 23       	jnz	$-8      	;abs 0x7cc4
    7cce:	30 41       	ret			

00007cd0 <__mspabi_srll_15>:
    7cd0:	12 c3       	clrc			
    7cd2:	0d 10       	rrc	r13		;
    7cd4:	0c 10       	rrc	r12		;

00007cd6 <__mspabi_srll_14>:
    7cd6:	12 c3       	clrc			
    7cd8:	0d 10       	rrc	r13		;
    7cda:	0c 10       	rrc	r12		;

00007cdc <__mspabi_srll_13>:
    7cdc:	12 c3       	clrc			
    7cde:	0d 10       	rrc	r13		;
    7ce0:	0c 10       	rrc	r12		;

00007ce2 <__mspabi_srll_12>:
    7ce2:	12 c3       	clrc			
    7ce4:	0d 10       	rrc	r13		;
    7ce6:	0c 10       	rrc	r12		;

00007ce8 <__mspabi_srll_11>:
    7ce8:	12 c3       	clrc			
    7cea:	0d 10       	rrc	r13		;
    7cec:	0c 10       	rrc	r12		;

00007cee <__mspabi_srll_10>:
    7cee:	12 c3       	clrc			
    7cf0:	0d 10       	rrc	r13		;
    7cf2:	0c 10       	rrc	r12		;

00007cf4 <__mspabi_srll_9>:
    7cf4:	12 c3       	clrc			
    7cf6:	0d 10       	rrc	r13		;
    7cf8:	0c 10       	rrc	r12		;

00007cfa <__mspabi_srll_8>:
    7cfa:	12 c3       	clrc			
    7cfc:	0d 10       	rrc	r13		;
    7cfe:	0c 10       	rrc	r12		;

00007d00 <__mspabi_srll_7>:
    7d00:	12 c3       	clrc			
    7d02:	0d 10       	rrc	r13		;
    7d04:	0c 10       	rrc	r12		;

00007d06 <__mspabi_srll_6>:
    7d06:	12 c3       	clrc			
    7d08:	0d 10       	rrc	r13		;
    7d0a:	0c 10       	rrc	r12		;

00007d0c <__mspabi_srll_5>:
    7d0c:	12 c3       	clrc			
    7d0e:	0d 10       	rrc	r13		;
    7d10:	0c 10       	rrc	r12		;

00007d12 <__mspabi_srll_4>:
    7d12:	12 c3       	clrc			
    7d14:	0d 10       	rrc	r13		;
    7d16:	0c 10       	rrc	r12		;

00007d18 <__mspabi_srll_3>:
    7d18:	12 c3       	clrc			
    7d1a:	0d 10       	rrc	r13		;
    7d1c:	0c 10       	rrc	r12		;

00007d1e <__mspabi_srll_2>:
    7d1e:	12 c3       	clrc			
    7d20:	0d 10       	rrc	r13		;
    7d22:	0c 10       	rrc	r12		;

00007d24 <__mspabi_srll_1>:
    7d24:	12 c3       	clrc			
    7d26:	0d 10       	rrc	r13		;
    7d28:	0c 10       	rrc	r12		;
    7d2a:	30 41       	ret			

00007d2c <.L12>:
    7d2c:	3e 53       	add	#-1,	r14	;r3 As==11
    7d2e:	12 c3       	clrc			
    7d30:	0d 10       	rrc	r13		;
    7d32:	0c 10       	rrc	r12		;

00007d34 <__mspabi_srll>:
    7d34:	0e 93       	cmp	#0,	r14	;r3 As==00
    7d36:	fa 23       	jnz	$-10     	;abs 0x7d2c
    7d38:	30 41       	ret			

00007d3a <__mspabi_mpyi>:
    7d3a:	02 12       	push	r2		;
    7d3c:	32 c2       	dint			
    7d3e:	03 43       	nop			
    7d40:	82 4c c0 04 	mov	r12,	&0x04c0	;
    7d44:	82 4d c8 04 	mov	r13,	&0x04c8	;
    7d48:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    7d4c:	00 13       	reti			

00007d4e <__mspabi_mpyl>:
    7d4e:	02 12       	push	r2		;
    7d50:	32 c2       	dint			
    7d52:	03 43       	nop			
    7d54:	82 4c d0 04 	mov	r12,	&0x04d0	;
    7d58:	82 4d d2 04 	mov	r13,	&0x04d2	;
    7d5c:	82 4e e0 04 	mov	r14,	&0x04e0	;
    7d60:	82 4f e2 04 	mov	r15,	&0x04e2	;
    7d64:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    7d68:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    7d6c:	00 13       	reti			

00007d6e <memcpy>:
    7d6e:	0f 4c       	mov	r12,	r15	;
    7d70:	0e 5c       	add	r12,	r14	;

00007d72 <.L2>:
    7d72:	0f 9e       	cmp	r14,	r15	;
    7d74:	05 24       	jz	$+12     	;abs 0x7d80

00007d76 <.LVL3>:
    7d76:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    7d7a:	1f 53       	inc	r15		;

00007d7c <.LVL4>:
    7d7c:	1d 53       	inc	r13		;
    7d7e:	f9 3f       	jmp	$-12     	;abs 0x7d72

00007d80 <.L5>:
    7d80:	30 41       	ret			

00007d82 <sniprintf>:
    7d82:	1a 15       	pushm	#2,	r10	;16-bit words

00007d84 <L0>:
    7d84:	31 80 3c 00 	sub	#60,	r1	;#0x003c

00007d88 <.LCFI3>:
    7d88:	0a 4d       	mov	r13,	r10	;

00007d8a <.Loc.95.1>:
    7d8a:	19 42 10 5c 	mov	&0x5c10,r9	;0x5c10

00007d8e <.Loc.97.1>:
    7d8e:	0d 93       	cmp	#0,	r13	;r3 As==00
    7d90:	05 34       	jge	$+12     	;abs 0x7d9c

00007d92 <.Loc.99.1>:
    7d92:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    7d96:	00 00 

00007d98 <.Loc.100.1>:
    7d98:	3c 43       	mov	#-1,	r12	;r3 As==11

00007d9a <.LVL9>:
    7d9a:	24 3c       	jmp	$+74     	;abs 0x7de4

00007d9c <.L12>:
    7d9c:	b1 40 08 02 	mov	#520,	6(r1)	;#0x0208
    7da0:	06 00 

00007da2 <.Loc.103.1>:
    7da2:	81 4c 00 00 	mov	r12,	0(r1)	;
    7da6:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007daa <.Loc.104.1>:
    7daa:	0c 4d       	mov	r13,	r12	;

00007dac <.LVL11>:
    7dac:	0d 93       	cmp	#0,	r13	;r3 As==00
    7dae:	01 24       	jz	$+4      	;abs 0x7db2

00007db0 <.LVL12>:
    7db0:	3c 53       	add	#-1,	r12	;r3 As==11

00007db2 <.L14>:
    7db2:	81 4c 04 00 	mov	r12,	4(r1)	;
    7db6:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

00007dba <.Loc.105.1>:
    7dba:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

00007dbe <.LVL13>:
    7dbe:	0f 41       	mov	r1,	r15	;
    7dc0:	3f 50 44 00 	add	#68,	r15	;#0x0044
    7dc4:	1e 41 42 00 	mov	66(r1),	r14	;0x00042
    7dc8:	0d 41       	mov	r1,	r13	;
    7dca:	0c 49       	mov	r9,	r12	;
    7dcc:	b0 12 1e 7f 	call	#32542		;#0x7f1e

00007dd0 <.LVL14>:
    7dd0:	3c 93       	cmp	#-1,	r12	;r3 As==11
    7dd2:	03 34       	jge	$+8      	;abs 0x7dda

00007dd4 <.Loc.114.1>:
    7dd4:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    7dd8:	00 00 

00007dda <.L15>:
    7dda:	0a 93       	cmp	#0,	r10	;r3 As==00
    7ddc:	03 24       	jz	$+8      	;abs 0x7de4

00007dde <.Loc.116.1>:
    7dde:	2d 41       	mov	@r1,	r13	;
    7de0:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00

00007de4 <.L11>:
    7de4:	31 50 3c 00 	add	#60,	r1	;#0x003c
    7de8:	19 17       	popm	#2,	r10	;16-bit words
    7dea:	30 41       	ret			

00007dec <strlen>:
    7dec:	0d 4c       	mov	r12,	r13	;

00007dee <L0>:
    7dee:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    7df2:	02 24       	jz	$+6      	;abs 0x7df8

00007df4 <.Loc.86.1>:
    7df4:	1d 53       	inc	r13		;
    7df6:	fb 3f       	jmp	$-8      	;abs 0x7dee

00007df8 <.L5>:
    7df8:	0d 8c       	sub	r12,	r13	;

00007dfa <.LVL4>:
    7dfa:	0c 4d       	mov	r13,	r12	;

00007dfc <.LVL5>:
    7dfc:	30 41       	ret			

00007dfe <__ssprint_r>:
    7dfe:	6a 15       	pushm	#7,	r10	;16-bit words

00007e00 <L0>:
    7e00:	21 82       	sub	#4,	r1	;r2 As==10

00007e02 <.LCFI1>:
    7e02:	07 4c       	mov	r12,	r7	;
    7e04:	04 4d       	mov	r13,	r4	;
    7e06:	08 4e       	mov	r14,	r8	;

00007e08 <.LVL1>:
    7e08:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00
    7e0c:	2c 24       	jz	$+90     	;abs 0x7e66

00007e0e <.Loc.280.1>:
    7e0e:	26 4e       	mov	@r14,	r6	;
    7e10:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    7e14:	19 41 02 00 	mov	2(r1),	r9	;
    7e18:	05 3c       	jmp	$+12     	;abs 0x7e24

00007e1a <.L5>:
    7e1a:	a1 46 02 00 	mov	@r6,	2(r1)	;

00007e1e <.Loc.291.1>:
    7e1e:	19 46 02 00 	mov	2(r6),	r9	;

00007e22 <.LVL3>:
    7e22:	26 52       	add	#4,	r6	;r2 As==10

00007e24 <.L3>:
    7e24:	09 93       	cmp	#0,	r9	;r3 As==00
    7e26:	f9 27       	jz	$-12     	;abs 0x7e1a

00007e28 <.Loc.294.1>:
    7e28:	1b 44 04 00 	mov	4(r4),	r11	;

00007e2c <.LVL5>:
    7e2c:	09 9b       	cmp	r11,	r9	;
    7e2e:	72 28       	jnc	$+230    	;abs 0x7f14

00007e30 <.Loc.295.1>:
    7e30:	1e 44 06 00 	mov	6(r4),	r14	;
    7e34:	3e b0 80 04 	bit	#1152,	r14	;#0x0480
    7e38:	1a 20       	jnz	$+54     	;abs 0x7e6e

00007e3a <.L6>:
    7e3a:	09 9b       	cmp	r11,	r9	;
    7e3c:	6b 28       	jnc	$+216    	;abs 0x7f14

00007e3e <.L12>:
    7e3e:	0e 4b       	mov	r11,	r14	;
    7e40:	1d 41 02 00 	mov	2(r1),	r13	;
    7e44:	2c 44       	mov	@r4,	r12	;
    7e46:	81 4b 00 00 	mov	r11,	0(r1)	;
    7e4a:	b0 12 d6 88 	call	#-30506	;#0x88d6

00007e4e <.LVL6>:
    7e4e:	2b 41       	mov	@r1,	r11	;
    7e50:	84 8b 04 00 	sub	r11,	4(r4)	;

00007e54 <.Loc.344.1>:
    7e54:	84 5b 00 00 	add	r11,	0(r4)	;

00007e58 <.LVL7>:
    7e58:	1c 48 04 00 	mov	4(r8),	r12	;
    7e5c:	0c 89       	sub	r9,	r12	;
    7e5e:	88 4c 04 00 	mov	r12,	4(r8)	;
    7e62:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e64:	da 23       	jnz	$-74     	;abs 0x7e1a

00007e66 <.L2>:
    7e66:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

00007e6a <.Loc.285.1>:
    7e6a:	4c 43       	clr.b	r12		;
    7e6c:	55 3c       	jmp	$+172    	;abs 0x7f18

00007e6e <.L21>:
    7e6e:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    7e72:	25 44       	mov	@r4,	r5	;
    7e74:	05 8d       	sub	r13,	r5	;

00007e76 <.LVL10>:
    7e76:	1c 44 0c 00 	mov	12(r4),	r12	;0x0000c
    7e7a:	0a 4c       	mov	r12,	r10	;
    7e7c:	0a 5c       	add	r12,	r10	;
    7e7e:	0a 5c       	add	r12,	r10	;
    7e80:	0c 4a       	mov	r10,	r12	;
    7e82:	5c 03       	rrum	#1,	r12	;
    7e84:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    7e88:	0a 5c       	add	r12,	r10	;
    7e8a:	0a 11       	rra	r10		;

00007e8c <.LVL11>:
    7e8c:	0c 45       	mov	r5,	r12	;
    7e8e:	1c 53       	inc	r12		;
    7e90:	0c 59       	add	r9,	r12	;
    7e92:	0a 9c       	cmp	r12,	r10	;
    7e94:	01 2c       	jc	$+4      	;abs 0x7e98

00007e96 <.Loc.308.1>:
    7e96:	0a 4c       	mov	r12,	r10	;

00007e98 <.L7>:
    7e98:	3e b0 00 04 	bit	#1024,	r14	;#0x0400
    7e9c:	17 24       	jz	$+48     	;abs 0x7ecc

00007e9e <.Loc.312.1>:
    7e9e:	0d 4a       	mov	r10,	r13	;
    7ea0:	0c 47       	mov	r7,	r12	;
    7ea2:	b0 12 14 8a 	call	#-30188	;#0x8a14

00007ea6 <.LVL13>:
    7ea6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ea8:	1d 24       	jz	$+60     	;abs 0x7ee4

00007eaa <.Loc.318.1>:
    7eaa:	0e 45       	mov	r5,	r14	;
    7eac:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    7eb0:	81 4c 00 00 	mov	r12,	0(r1)	;
    7eb4:	b0 12 6e 7d 	call	#32110		;#0x7d6e

00007eb8 <.LVL14>:
    7eb8:	1c 44 06 00 	mov	6(r4),	r12	;
    7ebc:	3c f0 7f fb 	and	#-1153,	r12	;#0xfb7f
    7ec0:	3c d0 80 00 	bis	#128,	r12	;#0x0080
    7ec4:	84 4c 06 00 	mov	r12,	6(r4)	;
    7ec8:	2b 41       	mov	@r1,	r11	;
    7eca:	18 3c       	jmp	$+50     	;abs 0x7efc

00007ecc <.L8>:
    7ecc:	0e 4a       	mov	r10,	r14	;
    7ece:	0c 47       	mov	r7,	r12	;
    7ed0:	b0 12 12 8b 	call	#-29934	;#0x8b12

00007ed4 <.LVL16>:
    7ed4:	0b 4c       	mov	r12,	r11	;

00007ed6 <.LVL17>:
    7ed6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ed8:	11 20       	jnz	$+36     	;abs 0x7efc

00007eda <.Loc.327.1>:
    7eda:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    7ede:	0c 47       	mov	r7,	r12	;
    7ee0:	b0 12 10 89 	call	#-30448	;#0x8910

00007ee4 <.L19>:
    7ee4:	b7 40 0c 00 	mov	#12,	0(r7)	;#0x000c
    7ee8:	00 00 

00007eea <.L10>:
    7eea:	b4 d0 40 00 	bis	#64,	6(r4)	;#0x0040
    7eee:	06 00 

00007ef0 <.Loc.356.1>:
    7ef0:	88 43 04 00 	mov	#0,	4(r8)	;r3 As==00

00007ef4 <.Loc.357.1>:
    7ef4:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

00007ef8 <.Loc.358.1>:
    7ef8:	3c 43       	mov	#-1,	r12	;r3 As==11
    7efa:	0e 3c       	jmp	$+30     	;abs 0x7f18

00007efc <.L11>:
    7efc:	84 4b 0a 00 	mov	r11,	10(r4)	; 0x000a

00007f00 <.Loc.335.1>:
    7f00:	0b 55       	add	r5,	r11	;

00007f02 <.LVL20>:
    7f02:	84 4b 00 00 	mov	r11,	0(r4)	;

00007f06 <.Loc.336.1>:
    7f06:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

00007f0a <.LVL21>:
    7f0a:	0b 49       	mov	r9,	r11	;

00007f0c <.Loc.338.1>:
    7f0c:	0a 85       	sub	r5,	r10	;

00007f0e <.LVL22>:
    7f0e:	84 4a 04 00 	mov	r10,	4(r4)	;
    7f12:	93 3f       	jmp	$-216    	;abs 0x7e3a

00007f14 <.L15>:
    7f14:	0b 49       	mov	r9,	r11	;
    7f16:	93 3f       	jmp	$-216    	;abs 0x7e3e

00007f18 <.L1>:
    7f18:	21 52       	add	#4,	r1	;r2 As==10
    7f1a:	64 17       	popm	#7,	r10	;16-bit words
    7f1c:	30 41       	ret			

00007f1e <_svfiprintf_r>:
    7f1e:	6a 15       	pushm	#7,	r10	;16-bit words

00007f20 <.LCFI2>:
    7f20:	31 80 62 00 	sub	#98,	r1	;#0x0062

00007f24 <.LCFI3>:
    7f24:	81 4c 02 00 	mov	r12,	2(r1)	;
    7f28:	0a 4d       	mov	r13,	r10	;

00007f2a <L0>:
    7f2a:	08 4e       	mov	r14,	r8	;
    7f2c:	09 4f       	mov	r15,	r9	;

00007f2e <.LVL26>:
    7f2e:	1d 4d 06 00 	mov	6(r13),	r13	;

00007f32 <.LVL27>:
    7f32:	7d f0 80 00 	and.b	#128,	r13	;#0x0080
    7f36:	0d 93       	cmp	#0,	r13	;r3 As==00
    7f38:	19 24       	jz	$+52     	;abs 0x7f6c

00007f3a <.Loc.880.1>:
    7f3a:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    7f3e:	16 20       	jnz	$+46     	;abs 0x7f6c

00007f40 <.Loc.882.1>:
    7f40:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    7f44:	b0 12 14 8a 	call	#-30188	;#0x8a14

00007f48 <.LVL28>:
    7f48:	8a 4c 00 00 	mov	r12,	0(r10)	;
    7f4c:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

00007f50 <.Loc.883.1>:
    7f50:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f52:	09 20       	jnz	$+20     	;abs 0x7f66

00007f54 <.Loc.885.1>:
    7f54:	1c 41 02 00 	mov	2(r1),	r12	;
    7f58:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    7f5c:	00 00 

00007f5e <.Loc.886.1>:
    7f5e:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11
    7f62:	30 40 b2 88 	br	#0x88b2		;

00007f66 <.L24>:
    7f66:	ba 40 40 00 	mov	#64,	12(r10)	;#0x0040, 0x000c
    7f6a:	0c 00 

00007f6c <.L23>:
    7f6c:	7d 40 1a 00 	mov.b	#26,	r13	;#0x001a
    7f70:	0d 51       	add	r1,	r13	;
    7f72:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

00007f76 <.Loc.895.1>:
    7f76:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018

00007f7a <.Loc.896.1>:
    7f7a:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00007f7e <.LVL30>:
    7f7e:	81 48 04 00 	mov	r8,	4(r1)	;

00007f82 <.Loc.894.1>:
    7f82:	0b 4d       	mov	r13,	r11	;

00007f84 <.Loc.718.1>:
    7f84:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c

00007f88 <.Loc.898.1>:
    7f88:	91 41 0c 00 	mov	12(r1),	8(r1)	;0x0000c
    7f8c:	08 00 

00007f8e <.L26>:
    7f8e:	18 41 04 00 	mov	4(r1),	r8	;

00007f92 <.L27>:
    7f92:	6c 48       	mov.b	@r8,	r12	;
    7f94:	0c 93       	cmp	#0,	r12	;r3 As==00
    7f96:	05 24       	jz	$+12     	;abs 0x7fa2

00007f98 <.Loc.925.1>:
    7f98:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    7f9c:	02 24       	jz	$+6      	;abs 0x7fa2

00007f9e <.Loc.926.1>:
    7f9e:	18 53       	inc	r8		;
    7fa0:	f8 3f       	jmp	$-14     	;abs 0x7f92

00007fa2 <.L28>:
    7fa2:	07 48       	mov	r8,	r7	;
    7fa4:	17 81 04 00 	sub	4(r1),	r7	;

00007fa8 <.LVL34>:
    7fa8:	07 93       	cmp	#0,	r7	;r3 As==00
    7faa:	23 24       	jz	$+72     	;abs 0x7ff2

00007fac <.Loc.929.1>:
    7fac:	9b 41 04 00 	mov	4(r1),	0(r11)	;
    7fb0:	00 00 
    7fb2:	8b 47 02 00 	mov	r7,	2(r11)	;
    7fb6:	81 57 18 00 	add	r7,	24(r1)	; 0x0018

00007fba <.LVL35>:
    7fba:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    7fbe:	1c 53       	inc	r12		;
    7fc0:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    7fc4:	7e 40 07 00 	mov.b	#7,	r14	;
    7fc8:	0e 9c       	cmp	r12,	r14	;
    7fca:	02 38       	jl	$+6      	;abs 0x7fd0
    7fcc:	2b 52       	add	#4,	r11	;r2 As==10

00007fce <.LVL36>:
    7fce:	0f 3c       	jmp	$+32     	;abs 0x7fee

00007fd0 <.L31>:
    7fd0:	0e 41       	mov	r1,	r14	;
    7fd2:	3e 50 14 00 	add	#20,	r14	;#0x0014
    7fd6:	0d 4a       	mov	r10,	r13	;
    7fd8:	1c 41 02 00 	mov	2(r1),	r12	;
    7fdc:	b0 12 fe 7d 	call	#32254		;#0x7dfe

00007fe0 <.LVL38>:
    7fe0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fe2:	02 24       	jz	$+6      	;abs 0x7fe8
    7fe4:	80 00 a6 88 	mova	#34982,	r0	;0x088a6

00007fe8 <.Loc.929.1>:
    7fe8:	0b 41       	mov	r1,	r11	;
    7fea:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00007fee <.L32>:
    7fee:	81 57 08 00 	add	r7,	8(r1)	;

00007ff2 <.L30>:
    7ff2:	c8 93 00 00 	cmp.b	#0,	0(r8)	;r3 As==00
    7ff6:	02 20       	jnz	$+6      	;abs 0x7ffc
    7ff8:	80 00 90 88 	mova	#34960,	r0	;0x08890

00007ffc <.LVL41>:
    7ffc:	0c 48       	mov	r8,	r12	;
    7ffe:	1c 53       	inc	r12		;

00008000 <.LVL42>:
    8000:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    8004:	4d 43       	clr.b	r13		;
    8006:	0e 4d       	mov	r13,	r14	;

00008008 <.Loc.945.1>:
    8008:	36 43       	mov	#-1,	r6	;r3 As==11

0000800a <.Loc.944.1>:
    800a:	81 4d 06 00 	mov	r13,	6(r1)	;

0000800e <.Loc.942.1>:
    800e:	05 4d       	mov	r13,	r5	;

00008010 <.Loc.959.1>:
    8010:	58 43       	mov.b	#1,	r8	;r3 As==01

00008012 <.L35>:
    8012:	04 4c       	mov	r12,	r4	;
    8014:	14 53       	inc	r4		;
    8016:	81 44 04 00 	mov	r4,	4(r1)	;

0000801a <.LVL44>:
    801a:	6c 4c       	mov.b	@r12,	r12	;

0000801c <.L37>:
    801c:	3c 90 58 00 	cmp	#88,	r12	;#0x0058
    8020:	92 24       	jz	$+294    	;abs 0x8146
    8022:	77 40 58 00 	mov.b	#88,	r7	;#0x0058
    8026:	07 9c       	cmp	r12,	r7	;
    8028:	41 38       	jl	$+132    	;abs 0x80ac
    802a:	3c 90 2e 00 	cmp	#46,	r12	;#0x002e
    802e:	aa 24       	jz	$+342    	;abs 0x8184
    8030:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    8034:	0f 9c       	cmp	r12,	r15	;
    8036:	1f 38       	jl	$+64     	;abs 0x8076
    8038:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    803c:	92 24       	jz	$+294    	;abs 0x8162
    803e:	74 40 2a 00 	mov.b	#42,	r4	;#0x002a
    8042:	04 9c       	cmp	r12,	r4	;
    8044:	0c 38       	jl	$+26     	;abs 0x805e
    8046:	3c 90 20 00 	cmp	#32,	r12	;#0x0020
    804a:	85 24       	jz	$+268    	;abs 0x8156
    804c:	3c 90 23 00 	cmp	#35,	r12	;#0x0023
    8050:	02 24       	jz	$+6      	;abs 0x8056
    8052:	80 00 f2 84 	mova	#34034,	r0	;0x084f2

00008056 <.Loc.979.1>:
    8056:	15 d3       	bis	#1,	r5	;r3 As==01

00008058 <.L36>:
    8058:	1c 41 04 00 	mov	4(r1),	r12	;
    805c:	da 3f       	jmp	$-74     	;abs 0x8012

0000805e <.L44>:
    805e:	3c 90 2b 00 	cmp	#43,	r12	;#0x002b
    8062:	04 20       	jnz	$+10     	;abs 0x806c
    8064:	0d 48       	mov	r8,	r13	;

00008066 <.Loc.1030.1>:
    8066:	7e 40 2b 00 	mov.b	#43,	r14	;#0x002b
    806a:	f6 3f       	jmp	$-18     	;abs 0x8058

0000806c <.L234>:
    806c:	3c 90 2d 00 	cmp	#45,	r12	;#0x002d
    8070:	87 24       	jz	$+272    	;abs 0x8180
    8072:	30 40 f2 84 	br	#0x84f2		;

00008076 <.L42>:
    8076:	77 40 39 00 	mov.b	#57,	r7	;#0x0039
    807a:	07 9c       	cmp	r12,	r7	;
    807c:	0b 38       	jl	$+24     	;abs 0x8094
    807e:	3c 90 31 00 	cmp	#49,	r12	;#0x0031
    8082:	aa 34       	jge	$+342    	;abs 0x81d8
    8084:	3c 90 30 00 	cmp	#48,	r12	;#0x0030
    8088:	02 24       	jz	$+6      	;abs 0x808e
    808a:	80 00 f2 84 	mova	#34034,	r0	;0x084f2

0000808e <.Loc.1084.1>:
    808e:	35 d0 80 00 	bis	#128,	r5	;#0x0080

00008092 <.Loc.1085.1>:
    8092:	e2 3f       	jmp	$-58     	;abs 0x8058

00008094 <.L48>:
    8094:	3c 90 4f 00 	cmp	#79,	r12	;#0x004f
    8098:	0e 25       	jz	$+542    	;abs 0x82b6
    809a:	3c 90 55 00 	cmp	#85,	r12	;#0x0055
    809e:	45 25       	jz	$+652    	;abs 0x832a
    80a0:	3c 90 44 00 	cmp	#68,	r12	;#0x0044
    80a4:	02 24       	jz	$+6      	;abs 0x80aa
    80a6:	80 00 f2 84 	mova	#34034,	r0	;0x084f2
    80aa:	c7 3c       	jmp	$+400    	;abs 0x823a

000080ac <.L40>:
    80ac:	3c 90 6e 00 	cmp	#110,	r12	;#0x006e
    80b0:	e8 24       	jz	$+466    	;abs 0x8282
    80b2:	7f 40 6e 00 	mov.b	#110,	r15	;#0x006e
    80b6:	0f 9c       	cmp	r12,	r15	;
    80b8:	17 38       	jl	$+48     	;abs 0x80e8
    80ba:	3c 90 68 00 	cmp	#104,	r12	;#0x0068
    80be:	a9 24       	jz	$+340    	;abs 0x8212
    80c0:	74 40 68 00 	mov.b	#104,	r4	;#0x0068
    80c4:	04 9c       	cmp	r12,	r4	;
    80c6:	08 38       	jl	$+18     	;abs 0x80d8
    80c8:	3c 90 63 00 	cmp	#99,	r12	;#0x0063
    80cc:	a8 24       	jz	$+338    	;abs 0x821e
    80ce:	3c 90 64 00 	cmp	#100,	r12	;#0x0064
    80d2:	34 24       	jz	$+106    	;abs 0x813c
    80d4:	30 40 f2 84 	br	#0x84f2		;

000080d8 <.L57>:
    80d8:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    80dc:	2f 24       	jz	$+96     	;abs 0x813c
    80de:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    80e2:	9a 24       	jz	$+310    	;abs 0x8218
    80e4:	30 40 f2 84 	br	#0x84f2		;

000080e8 <.L55>:
    80e8:	3c 90 71 00 	cmp	#113,	r12	;#0x0071
    80ec:	95 24       	jz	$+300    	;abs 0x8218
    80ee:	77 40 71 00 	mov.b	#113,	r7	;#0x0071
    80f2:	07 9c       	cmp	r12,	r7	;
    80f4:	19 38       	jl	$+52     	;abs 0x8128
    80f6:	3c 90 6f 00 	cmp	#111,	r12	;#0x006f
    80fa:	df 24       	jz	$+448    	;abs 0x82ba
    80fc:	3c 90 70 00 	cmp	#112,	r12	;#0x0070
    8100:	02 24       	jz	$+6      	;abs 0x8106
    8102:	80 00 f2 84 	mova	#34034,	r0	;0x084f2

00008106 <.Loc.1428.1>:
    8106:	07 49       	mov	r9,	r7	;
    8108:	27 53       	incd	r7		;

0000810a <.LVL49>:
    810a:	29 49       	mov	@r9,	r9	;
    810c:	08 49       	mov	r9,	r8	;
    810e:	09 43       	clr	r9		;

00008110 <.LVL50>:
    8110:	25 d3       	bis	#2,	r5	;r3 As==10

00008112 <.Loc.1432.1>:
    8112:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    8116:	12 00 

00008118 <.LVL52>:
    8118:	f1 40 78 00 	mov.b	#120,	19(r1)	;#0x0078, 0x0013
    811c:	13 00 

0000811e <.Loc.1430.1>:
    811e:	b1 40 39 51 	mov	#20793,	12(r1)	;#0x5139, 0x000c
    8122:	0c 00 

00008124 <.Loc.1429.1>:
    8124:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008126 <.Loc.1434.1>:
    8126:	3a 3d       	jmp	$+630    	;abs 0x839c

00008128 <.L62>:
    8128:	3c 90 75 00 	cmp	#117,	r12	;#0x0075
    812c:	00 25       	jz	$+514    	;abs 0x832e
    812e:	3c 90 78 00 	cmp	#120,	r12	;#0x0078
    8132:	0f 25       	jz	$+544    	;abs 0x8352
    8134:	3c 90 73 00 	cmp	#115,	r12	;#0x0073
    8138:	dc 21       	jnz	$+954    	;abs 0x84f2
    813a:	d9 3c       	jmp	$+436    	;abs 0x82ee

0000813c <.L59>:
    813c:	0d 93       	cmp	#0,	r13	;r3 As==00
    813e:	83 24       	jz	$+264    	;abs 0x8246
    8140:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011
    8144:	80 3c       	jmp	$+258    	;abs 0x8246

00008146 <.L39>:
    8146:	0d 93       	cmp	#0,	r13	;r3 As==00
    8148:	02 24       	jz	$+6      	;abs 0x814e
    814a:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000814e <.L70>:
    814e:	b1 40 28 51 	mov	#20776,	12(r1)	;#0x5128, 0x000c
    8152:	0c 00 

00008154 <.LVL54>:
    8154:	05 3d       	jmp	$+524    	;abs 0x8360

00008156 <.L45>:
    8156:	0e 93       	cmp	#0,	r14	;r3 As==00
    8158:	7f 23       	jnz	$-256    	;abs 0x8058
    815a:	0d 48       	mov	r8,	r13	;

0000815c <.Loc.976.1>:
    815c:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    8160:	7b 3f       	jmp	$-264    	;abs 0x8058

00008162 <.L43>:
    8162:	0f 49       	mov	r9,	r15	;
    8164:	1f 53       	inc	r15		;
    8166:	1f c3       	bic	#1,	r15	;r3 As==01
    8168:	09 4f       	mov	r15,	r9	;

0000816a <.LVL56>:
    816a:	29 53       	incd	r9		;

0000816c <.LVL57>:
    816c:	a1 4f 06 00 	mov	@r15,	6(r1)	;

00008170 <.LVL58>:
    8170:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    8174:	71 37       	jge	$-284    	;abs 0x8058

00008176 <.Loc.1024.1>:
    8176:	44 43       	clr.b	r4		;
    8178:	14 81 06 00 	sub	6(r1),	r4	;
    817c:	81 44 06 00 	mov	r4,	6(r1)	;

00008180 <.L47>:
    8180:	25 d2       	bis	#4,	r5	;r2 As==10

00008182 <.Loc.1028.1>:
    8182:	6a 3f       	jmp	$-298    	;abs 0x8058

00008184 <.L41>:
    8184:	1f 41 04 00 	mov	4(r1),	r15	;
    8188:	1f 53       	inc	r15		;

0000818a <.LVL61>:
    818a:	17 41 04 00 	mov	4(r1),	r7	;
    818e:	6c 47       	mov.b	@r7,	r12	;
    8190:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    8194:	02 24       	jz	$+6      	;abs 0x819a
    8196:	46 43       	clr.b	r6		;

00008198 <.LVL63>:
    8198:	0c 3c       	jmp	$+26     	;abs 0x81b2

0000819a <.L72>:
    819a:	19 53       	inc	r9		;

0000819c <.LVL65>:
    819c:	0c 49       	mov	r9,	r12	;

0000819e <.LVL66>:
    819e:	1c c3       	bic	#1,	r12	;r3 As==01
    81a0:	09 4c       	mov	r12,	r9	;

000081a2 <.LVL67>:
    81a2:	29 53       	incd	r9		;

000081a4 <.LVL68>:
    81a4:	26 4c       	mov	@r12,	r6	;
    81a6:	06 93       	cmp	#0,	r6	;r3 As==00
    81a8:	01 34       	jge	$+4      	;abs 0x81ac
    81aa:	36 43       	mov	#-1,	r6	;r3 As==11

000081ac <.L74>:
    81ac:	81 4f 04 00 	mov	r15,	4(r1)	;
    81b0:	53 3f       	jmp	$-344    	;abs 0x8058

000081b2 <.L73>:
    81b2:	81 4f 04 00 	mov	r15,	4(r1)	;

000081b6 <.LVL70>:
    81b6:	07 4c       	mov	r12,	r7	;
    81b8:	37 50 d0 ff 	add	#-48,	r7	;#0xffd0
    81bc:	74 40 09 00 	mov.b	#9,	r4	;
    81c0:	04 97       	cmp	r7,	r4	;
    81c2:	2c 2b       	jnc	$-422    	;abs 0x801c

000081c4 <.LVL71>:
    81c4:	0c 46       	mov	r6,	r12	;

000081c6 <.LVL72>:
    81c6:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    81ca:	0c 56       	add	r6,	r12	;
    81cc:	0c 5c       	rla	r12		;
    81ce:	06 47       	mov	r7,	r6	;

000081d0 <.LVL73>:
    81d0:	06 5c       	add	r12,	r6	;

000081d2 <.LVL74>:
    81d2:	6c 4f       	mov.b	@r15,	r12	;

000081d4 <.LVL75>:
    81d4:	1f 53       	inc	r15		;

000081d6 <.LVL76>:
    81d6:	ed 3f       	jmp	$-36     	;abs 0x81b2

000081d8 <.L49>:
    81d8:	17 41 04 00 	mov	4(r1),	r7	;

000081dc <.Loc.959.1>:
    81dc:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000081e0 <.L77>:
    81e0:	1f 41 06 00 	mov	6(r1),	r15	;
    81e4:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    81e8:	1f 51 06 00 	add	6(r1),	r15	;
    81ec:	0f 5f       	rla	r15		;
    81ee:	3c 50 d0 ff 	add	#-48,	r12	;#0xffd0

000081f2 <.LVL79>:
    81f2:	0c 5f       	add	r15,	r12	;

000081f4 <.LVL80>:
    81f4:	81 4c 06 00 	mov	r12,	6(r1)	;

000081f8 <.LVL81>:
    81f8:	91 53 04 00 	inc	4(r1)		;

000081fc <.Loc.1091.1>:
    81fc:	6c 47       	mov.b	@r7,	r12	;

000081fe <.LVL83>:
    81fe:	17 41 04 00 	mov	4(r1),	r7	;

00008202 <.Loc.1092.1>:
    8202:	0f 4c       	mov	r12,	r15	;
    8204:	3f 50 d0 ff 	add	#-48,	r15	;#0xffd0
    8208:	74 40 09 00 	mov.b	#9,	r4	;
    820c:	04 9f       	cmp	r15,	r4	;
    820e:	e8 2f       	jc	$-46     	;abs 0x81e0
    8210:	05 3f       	jmp	$-500    	;abs 0x801c

00008212 <.L56>:
    8212:	35 d0 40 00 	bis	#64,	r5	;#0x0040

00008216 <.Loc.1119.1>:
    8216:	20 3f       	jmp	$-446    	;abs 0x8058

00008218 <.L61>:
    8218:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000821c <.Loc.1131.1>:
    821c:	1d 3f       	jmp	$-452    	;abs 0x8058

0000821e <.L58>:
    821e:	19 53       	inc	r9		;

00008220 <.LVL88>:
    8220:	19 c3       	bic	#1,	r9	;r3 As==01

00008222 <.LVL89>:
    8222:	07 49       	mov	r9,	r7	;
    8224:	27 53       	incd	r7		;

00008226 <.LVL90>:
    8226:	e1 49 3a 00 	mov.b	@r9,	58(r1)	; 0x003a

0000822a <.LVL91>:
    822a:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

0000822e <.Loc.1190.1>:
    822e:	56 43       	mov.b	#1,	r6	;r3 As==01

00008230 <.LVL92>:
    8230:	49 43       	clr.b	r9		;

00008232 <.Loc.1173.1>:
    8232:	04 41       	mov	r1,	r4	;
    8234:	34 50 3a 00 	add	#58,	r4	;#0x003a

00008238 <.Loc.1193.1>:
    8238:	6e 3d       	jmp	$+734    	;abs 0x8516

0000823a <.L235>:
    823a:	0d 93       	cmp	#0,	r13	;r3 As==00
    823c:	02 24       	jz	$+6      	;abs 0x8242
    823e:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

00008242 <.L79>:
    8242:	35 d0 10 00 	bis	#16,	r5	;#0x0010

00008246 <.L69>:
    8246:	19 53       	inc	r9		;

00008248 <.LVL95>:
    8248:	19 c3       	bic	#1,	r9	;r3 As==01

0000824a <.LVL96>:
    824a:	07 49       	mov	r9,	r7	;
    824c:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    8250:	05 24       	jz	$+12     	;abs 0x825c
    8252:	27 52       	add	#4,	r7	;r2 As==10

00008254 <.LVL97>:
    8254:	28 49       	mov	@r9,	r8	;
    8256:	19 49 02 00 	mov	2(r9),	r9	;
    825a:	06 3c       	jmp	$+14     	;abs 0x8268

0000825c <.L80>:
    825c:	27 53       	incd	r7		;

0000825e <.LVL99>:
    825e:	28 49       	mov	@r9,	r8	;
    8260:	38 b0 00 80 	bit	#-32768,r8	;#0x8000
    8264:	09 79       	subc	r9,	r9	;
    8266:	39 e3       	inv	r9		;

00008268 <.L81>:
    8268:	09 93       	cmp	#0,	r9	;r3 As==00
    826a:	9b 34       	jge	$+312    	;abs 0x83a2

0000826c <.Loc.1207.1>:
    826c:	4c 43       	clr.b	r12		;

0000826e <.LVL101>:
    826e:	4d 43       	clr.b	r13		;
    8270:	0c 88       	sub	r8,	r12	;
    8272:	0d 79       	subc	r9,	r13	;
    8274:	08 4c       	mov	r12,	r8	;

00008276 <.LVL102>:
    8276:	09 4d       	mov	r13,	r9	;

00008278 <.LVL103>:
    8278:	f1 40 2d 00 	mov.b	#45,	17(r1)	;#0x002d, 0x0011
    827c:	11 00 

0000827e <.Loc.1210.1>:
    827e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8280:	91 3c       	jmp	$+292    	;abs 0x83a4

00008282 <.L54>:
    8282:	0d 93       	cmp	#0,	r13	;r3 As==00
    8284:	02 24       	jz	$+6      	;abs 0x828a
    8286:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000828a <.L86>:
    828a:	0c 49       	mov	r9,	r12	;

0000828c <.LVL105>:
    828c:	2c 53       	incd	r12		;

0000828e <.Loc.1399.1>:
    828e:	2d 49       	mov	@r9,	r13	;

00008290 <.Loc.1398.1>:
    8290:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    8294:	0b 24       	jz	$+24     	;abs 0x82ac

00008296 <.LVL106>:
    8296:	1f 41 08 00 	mov	8(r1),	r15	;
    829a:	0e 4f       	mov	r15,	r14	;
    829c:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    82a0:	8d 4e 00 00 	mov	r14,	0(r13)	;
    82a4:	8d 4f 02 00 	mov	r15,	2(r13)	;
    82a8:	09 4c       	mov	r12,	r9	;
    82aa:	71 3e       	jmp	$-796    	;abs 0x7f8e

000082ac <.L87>:
    82ac:	9d 41 08 00 	mov	8(r1),	0(r13)	;
    82b0:	00 00 

000082b2 <.LVL108>:
    82b2:	09 4c       	mov	r12,	r9	;
    82b4:	6c 3e       	jmp	$-806    	;abs 0x7f8e

000082b6 <.L51>:
    82b6:	35 d0 10 00 	bis	#16,	r5	;#0x0010

000082ba <.L63>:
    82ba:	0d 45       	mov	r5,	r13	;
    82bc:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    82c0:	19 53       	inc	r9		;

000082c2 <.LVL111>:
    82c2:	0d 93       	cmp	#0,	r13	;r3 As==00
    82c4:	08 24       	jz	$+18     	;abs 0x82d6
    82c6:	19 c3       	bic	#1,	r9	;r3 As==01

000082c8 <.LVL112>:
    82c8:	07 49       	mov	r9,	r7	;
    82ca:	27 52       	add	#4,	r7	;r2 As==10

000082cc <.LVL113>:
    82cc:	28 49       	mov	@r9,	r8	;
    82ce:	19 49 02 00 	mov	2(r9),	r9	;

000082d2 <.L233>:
    82d2:	4c 43       	clr.b	r12		;
    82d4:	63 3c       	jmp	$+200    	;abs 0x839c

000082d6 <.L90>:
    82d6:	0c 45       	mov	r5,	r12	;

000082d8 <.LVL116>:
    82d8:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    82dc:	19 c3       	bic	#1,	r9	;r3 As==01

000082de <.LVL117>:
    82de:	07 49       	mov	r9,	r7	;
    82e0:	27 53       	incd	r7		;

000082e2 <.LVL118>:
    82e2:	29 49       	mov	@r9,	r9	;
    82e4:	08 49       	mov	r9,	r8	;
    82e6:	09 43       	clr	r9		;
    82e8:	0c 93       	cmp	#0,	r12	;r3 As==00
    82ea:	58 24       	jz	$+178    	;abs 0x839c
    82ec:	f2 3f       	jmp	$-26     	;abs 0x82d2

000082ee <.L236>:
    82ee:	07 49       	mov	r9,	r7	;
    82f0:	27 53       	incd	r7		;

000082f2 <.LVL120>:
    82f2:	24 49       	mov	@r9,	r4	;

000082f4 <.Loc.1443.1>:
    82f4:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

000082f8 <.Loc.1518.1>:
    82f8:	36 93       	cmp	#-1,	r6	;r3 As==11
    82fa:	0e 24       	jz	$+30     	;abs 0x8318

000082fc <.LBB4>:
    82fc:	0e 46       	mov	r6,	r14	;
    82fe:	4d 43       	clr.b	r13		;
    8300:	0c 44       	mov	r4,	r12	;

00008302 <.LVL121>:
    8302:	81 4b 00 00 	mov	r11,	0(r1)	;
    8306:	b0 12 be 88 	call	#-30530	;#0x88be

0000830a <.LVL122>:
    830a:	2b 41       	mov	@r1,	r11	;
    830c:	0c 93       	cmp	#0,	r12	;r3 As==00
    830e:	02 25       	jz	$+518    	;abs 0x8514

00008310 <.Loc.1527.1>:
    8310:	06 4c       	mov	r12,	r6	;
    8312:	06 84       	sub	r4,	r6	;

00008314 <.LBE4>:
    8314:	49 43       	clr.b	r9		;

00008316 <.LBB5>:
    8316:	ff 3c       	jmp	$+512    	;abs 0x8516

00008318 <.L93>:
    8318:	0c 44       	mov	r4,	r12	;

0000831a <.LVL125>:
    831a:	81 4b 00 00 	mov	r11,	0(r1)	;
    831e:	b0 12 ec 7d 	call	#32236		;#0x7dec

00008322 <.LVL126>:
    8322:	06 4c       	mov	r12,	r6	;

00008324 <.LVL127>:
    8324:	49 43       	clr.b	r9		;
    8326:	2b 41       	mov	@r1,	r11	;
    8328:	f6 3c       	jmp	$+494    	;abs 0x8516

0000832a <.L52>:
    832a:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000832e <.L65>:
    832e:	19 53       	inc	r9		;

00008330 <.LVL130>:
    8330:	19 c3       	bic	#1,	r9	;r3 As==01

00008332 <.LVL131>:
    8332:	07 49       	mov	r9,	r7	;
    8334:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    8338:	06 24       	jz	$+14     	;abs 0x8346
    833a:	27 52       	add	#4,	r7	;r2 As==10

0000833c <.LVL132>:
    833c:	28 49       	mov	@r9,	r8	;
    833e:	19 49 02 00 	mov	2(r9),	r9	;

00008342 <.Loc.1539.1>:
    8342:	5c 43       	mov.b	#1,	r12	;r3 As==01

00008344 <.LVL133>:
    8344:	2b 3c       	jmp	$+88     	;abs 0x839c

00008346 <.L94>:
    8346:	27 53       	incd	r7		;

00008348 <.LVL135>:
    8348:	29 49       	mov	@r9,	r9	;

0000834a <.LVL136>:
    834a:	08 49       	mov	r9,	r8	;
    834c:	09 43       	clr	r9		;

0000834e <.Loc.1539.1>:
    834e:	5c 43       	mov.b	#1,	r12	;r3 As==01

00008350 <.LVL137>:
    8350:	25 3c       	jmp	$+76     	;abs 0x839c

00008352 <.L66>:
    8352:	0d 93       	cmp	#0,	r13	;r3 As==00
    8354:	02 24       	jz	$+6      	;abs 0x835a
    8356:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000835a <.L96>:
    835a:	b1 40 39 51 	mov	#20793,	12(r1)	;#0x5139, 0x000c
    835e:	0c 00 

00008360 <.L71>:
    8360:	19 53       	inc	r9		;

00008362 <.LVL140>:
    8362:	19 c3       	bic	#1,	r9	;r3 As==01

00008364 <.LVL141>:
    8364:	07 49       	mov	r9,	r7	;
    8366:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    836a:	05 24       	jz	$+12     	;abs 0x8376
    836c:	27 52       	add	#4,	r7	;r2 As==10

0000836e <.LVL142>:
    836e:	28 49       	mov	@r9,	r8	;
    8370:	19 49 02 00 	mov	2(r9),	r9	;
    8374:	04 3c       	jmp	$+10     	;abs 0x837e

00008376 <.L97>:
    8376:	27 53       	incd	r7		;

00008378 <.LVL144>:
    8378:	29 49       	mov	@r9,	r9	;

0000837a <.LVL145>:
    837a:	08 49       	mov	r9,	r8	;
    837c:	09 43       	clr	r9		;

0000837e <.L98>:
    837e:	15 b3       	bit	#1,	r5	;r3 As==01
    8380:	0c 24       	jz	$+26     	;abs 0x839a

00008382 <.Loc.1549.1>:
    8382:	0d 48       	mov	r8,	r13	;
    8384:	0d d9       	bis	r9,	r13	;
    8386:	0d 93       	cmp	#0,	r13	;r3 As==00
    8388:	08 24       	jz	$+18     	;abs 0x839a

0000838a <.Loc.1550.1>:
    838a:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    838e:	12 00 

00008390 <.Loc.1551.1>:
    8390:	c1 4c 13 00 	mov.b	r12,	19(r1)	; 0x0013

00008394 <.Loc.1552.1>:
    8394:	25 d3       	bis	#2,	r5	;r3 As==10

00008396 <.Loc.1547.1>:
    8396:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008398 <.LVL148>:
    8398:	01 3c       	jmp	$+4      	;abs 0x839c

0000839a <.L157>:
    839a:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000839c <.L91>:
    839c:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    83a0:	01 3c       	jmp	$+4      	;abs 0x83a4

000083a2 <.L154>:
    83a2:	5c 43       	mov.b	#1,	r12	;r3 As==01

000083a4 <.L84>:
    83a4:	36 93       	cmp	#-1,	r6	;r3 As==11
    83a6:	0c 24       	jz	$+26     	;abs 0x83c0

000083a8 <.Loc.1566.1>:
    83a8:	04 45       	mov	r5,	r4	;
    83aa:	34 f0 7f ff 	and	#-129,	r4	;#0xff7f
    83ae:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

000083b2 <.LVL153>:
    83b2:	0d 48       	mov	r8,	r13	;
    83b4:	0d d9       	bis	r9,	r13	;
    83b6:	0d 93       	cmp	#0,	r13	;r3 As==00
    83b8:	09 20       	jnz	$+20     	;abs 0x83cc

000083ba <.Loc.1574.1>:
    83ba:	06 93       	cmp	#0,	r6	;r3 As==00
    83bc:	84 24       	jz	$+266    	;abs 0x84c6
    83be:	0b 3c       	jmp	$+24     	;abs 0x83d6

000083c0 <.L101>:
    83c0:	0d 48       	mov	r8,	r13	;
    83c2:	0d d9       	bis	r9,	r13	;
    83c4:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a
    83c8:	0d 93       	cmp	#0,	r13	;r3 As==00
    83ca:	05 24       	jz	$+12     	;abs 0x83d6

000083cc <.L102>:
    83cc:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    83ce:	32 24       	jz	$+102    	;abs 0x8434
    83d0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    83d2:	61 24       	jz	$+196    	;abs 0x8496
    83d4:	06 3c       	jmp	$+14     	;abs 0x83e2

000083d6 <.L103>:
    83d6:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    83d8:	33 24       	jz	$+104    	;abs 0x8440
    83da:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    83dc:	5a 24       	jz	$+182    	;abs 0x8492
    83de:	48 43       	clr.b	r8		;

000083e0 <.LVL156>:
    83e0:	49 43       	clr.b	r9		;

000083e2 <.L105>:
    83e2:	05 41       	mov	r1,	r5	;
    83e4:	35 50 62 00 	add	#98,	r5	;#0x0062

000083e8 <.L108>:
    83e8:	04 45       	mov	r5,	r4	;
    83ea:	34 53       	add	#-1,	r4	;r3 As==11

000083ec <.LVL158>:
    83ec:	4c 48       	mov.b	r8,	r12	;
    83ee:	7c f0 07 00 	and.b	#7,	r12	;
    83f2:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    83f6:	4e 4c       	mov.b	r12,	r14	;
    83f8:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    83fc:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

00008400 <.Loc.1584.1>:
    8400:	0c 48       	mov	r8,	r12	;
    8402:	0d 49       	mov	r9,	r13	;
    8404:	81 4b 00 00 	mov	r11,	0(r1)	;
    8408:	b0 12 18 7d 	call	#32024		;#0x7d18

0000840c <.LVL159>:
    840c:	08 4c       	mov	r12,	r8	;

0000840e <.LVL160>:
    840e:	09 4d       	mov	r13,	r9	;

00008410 <.LVL161>:
    8410:	0c dd       	bis	r13,	r12	;
    8412:	2b 41       	mov	@r1,	r11	;

00008414 <.LVL162>:
    8414:	0c 93       	cmp	#0,	r12	;r3 As==00
    8416:	02 24       	jz	$+6      	;abs 0x841c
    8418:	05 44       	mov	r4,	r5	;
    841a:	e6 3f       	jmp	$-50     	;abs 0x83e8

0000841c <.L237>:
    841c:	91 b3 0a 00 	bit	#1,	10(r1)	;r3 As==01, 0x000a
    8420:	60 24       	jz	$+194    	;abs 0x84e2

00008422 <.Loc.1587.1>:
    8422:	b1 90 30 00 	cmp	#48,	14(r1)	;#0x0030, 0x000e
    8426:	0e 00 
    8428:	5c 24       	jz	$+186    	;abs 0x84e2

0000842a <.LVL163>:
    842a:	f4 40 30 00 	mov.b	#48,	-1(r4)	;#0x0030, 0xffff
    842e:	ff ff 
    8430:	34 53       	add	#-1,	r4	;r3 As==11
    8432:	57 3c       	jmp	$+176    	;abs 0x84e2

00008434 <.L106>:
    8434:	09 93       	cmp	#0,	r9	;r3 As==00
    8436:	0d 20       	jnz	$+28     	;abs 0x8452
    8438:	7f 40 09 00 	mov.b	#9,	r15	;
    843c:	0f 98       	cmp	r8,	r15	;
    843e:	09 28       	jnc	$+20     	;abs 0x8452

00008440 <.L112>:
    8440:	4c 48       	mov.b	r8,	r12	;

00008442 <.LVL166>:
    8442:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    8446:	c1 4c 61 00 	mov.b	r12,	97(r1)	; 0x0061
    844a:	04 41       	mov	r1,	r4	;
    844c:	34 50 61 00 	add	#97,	r4	;#0x0061

00008450 <.Loc.1595.1>:
    8450:	48 3c       	jmp	$+146    	;abs 0x84e2

00008452 <.L110>:
    8452:	04 41       	mov	r1,	r4	;
    8454:	34 50 62 00 	add	#98,	r4	;#0x0062

00008458 <.Loc.1601.1>:
    8458:	35 40 90 7b 	mov	#31632,	r5	;#0x7b90

0000845c <.L113>:
    845c:	34 53       	add	#-1,	r4	;r3 As==11
    845e:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    8462:	4f 43       	clr.b	r15		;
    8464:	0c 48       	mov	r8,	r12	;
    8466:	0d 49       	mov	r9,	r13	;
    8468:	81 4b 00 00 	mov	r11,	0(r1)	;
    846c:	85 12       	call	r5		;
    846e:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    8472:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

00008476 <.Loc.1622.1>:
    8476:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    847a:	4f 43       	clr.b	r15		;
    847c:	0c 48       	mov	r8,	r12	;
    847e:	0d 49       	mov	r9,	r13	;
    8480:	b0 12 82 7b 	call	#31618		;#0x7b82
    8484:	08 4c       	mov	r12,	r8	;

00008486 <.LVL172>:
    8486:	09 4d       	mov	r13,	r9	;

00008488 <.LVL173>:
    8488:	0c dd       	bis	r13,	r12	;
    848a:	2b 41       	mov	@r1,	r11	;
    848c:	0c 93       	cmp	#0,	r12	;r3 As==00
    848e:	e6 23       	jnz	$-50     	;abs 0x845c
    8490:	28 3c       	jmp	$+82     	;abs 0x84e2

00008492 <.L162>:
    8492:	48 43       	clr.b	r8		;

00008494 <.LVL175>:
    8494:	49 43       	clr.b	r9		;

00008496 <.L107>:
    8496:	04 41       	mov	r1,	r4	;
    8498:	34 50 62 00 	add	#98,	r4	;#0x0062

0000849c <.L114>:
    849c:	34 53       	add	#-1,	r4	;r3 As==11
    849e:	0c 48       	mov	r8,	r12	;
    84a0:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    84a4:	1c 51 0c 00 	add	12(r1),	r12	;0x0000c
    84a8:	e4 4c 00 00 	mov.b	@r12,	0(r4)	;

000084ac <.Loc.1629.1>:
    84ac:	0c 48       	mov	r8,	r12	;
    84ae:	0d 49       	mov	r9,	r13	;
    84b0:	81 4b 00 00 	mov	r11,	0(r1)	;
    84b4:	b0 12 12 7d 	call	#32018		;#0x7d12

000084b8 <.LVL178>:
    84b8:	08 4c       	mov	r12,	r8	;

000084ba <.LVL179>:
    84ba:	09 4d       	mov	r13,	r9	;

000084bc <.LVL180>:
    84bc:	0c dd       	bis	r13,	r12	;
    84be:	2b 41       	mov	@r1,	r11	;

000084c0 <.LVL181>:
    84c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    84c2:	ec 23       	jnz	$-38     	;abs 0x849c
    84c4:	0e 3c       	jmp	$+30     	;abs 0x84e2

000084c6 <.L231>:
    84c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    84c8:	09 20       	jnz	$+20     	;abs 0x84dc

000084ca <.Loc.1648.1>:
    84ca:	15 b3       	bit	#1,	r5	;r3 As==01
    84cc:	07 24       	jz	$+16     	;abs 0x84dc

000084ce <.LVL183>:
    84ce:	f1 40 30 00 	mov.b	#48,	97(r1)	;#0x0030, 0x0061
    84d2:	61 00 
    84d4:	04 41       	mov	r1,	r4	;

000084d6 <.LVL184>:
    84d6:	34 50 61 00 	add	#97,	r4	;#0x0061
    84da:	03 3c       	jmp	$+8      	;abs 0x84e2

000084dc <.L160>:
    84dc:	04 41       	mov	r1,	r4	;

000084de <.LVL186>:
    84de:	34 50 62 00 	add	#98,	r4	;#0x0062

000084e2 <.L109>:
    84e2:	09 46       	mov	r6,	r9	;
    84e4:	76 40 62 00 	mov.b	#98,	r6	;#0x0062

000084e8 <.LVL188>:
    84e8:	06 51       	add	r1,	r6	;
    84ea:	06 84       	sub	r4,	r6	;
    84ec:	15 41 0a 00 	mov	10(r1),	r5	;0x0000a
    84f0:	12 3c       	jmp	$+38     	;abs 0x8516

000084f2 <.L38>:
    84f2:	0d 93       	cmp	#0,	r13	;r3 As==00
    84f4:	02 24       	jz	$+6      	;abs 0x84fa
    84f6:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

000084fa <.L115>:
    84fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    84fc:	c9 25       	jz	$+916    	;abs 0x8890

000084fe <.LVL190>:
    84fe:	c1 4c 3a 00 	mov.b	r12,	58(r1)	; 0x003a

00008502 <.LVL191>:
    8502:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

00008506 <.Loc.1662.1>:
    8506:	07 49       	mov	r9,	r7	;

00008508 <.Loc.1660.1>:
    8508:	56 43       	mov.b	#1,	r6	;r3 As==01

0000850a <.LVL192>:
    850a:	49 43       	clr.b	r9		;

0000850c <.LVL193>:
    850c:	04 41       	mov	r1,	r4	;
    850e:	34 50 3a 00 	add	#58,	r4	;#0x003a

00008512 <.Loc.1662.1>:
    8512:	01 3c       	jmp	$+4      	;abs 0x8516

00008514 <.L155>:
    8514:	09 4c       	mov	r12,	r9	;

00008516 <.L78>:
    8516:	08 49       	mov	r9,	r8	;
    8518:	09 96       	cmp	r6,	r9	;
    851a:	01 34       	jge	$+4      	;abs 0x851e
    851c:	08 46       	mov	r6,	r8	;

0000851e <.L116>:
    851e:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    8522:	01 24       	jz	$+4      	;abs 0x8526

00008524 <.Loc.1682.1>:
    8524:	18 53       	inc	r8		;

00008526 <.L117>:
    8526:	0f 45       	mov	r5,	r15	;
    8528:	6f f3       	and.b	#2,	r15	;r3 As==10
    852a:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    852e:	0f 93       	cmp	#0,	r15	;r3 As==00
    8530:	01 24       	jz	$+4      	;abs 0x8534

00008532 <.Loc.1684.1>:
    8532:	28 53       	incd	r8		;

00008534 <.L118>:
    8534:	0f 45       	mov	r5,	r15	;
    8536:	7f f0 84 00 	and.b	#132,	r15	;#0x0084
    853a:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    853e:	0f 93       	cmp	#0,	r15	;r3 As==00
    8540:	4a 20       	jnz	$+150    	;abs 0x85d6

00008542 <.Loc.1688.1>:
    8542:	1f 41 06 00 	mov	6(r1),	r15	;
    8546:	0f 88       	sub	r8,	r15	;

00008548 <.LVL199>:
    8548:	4c 43       	clr.b	r12		;
    854a:	0c 9f       	cmp	r15,	r12	;
    854c:	44 34       	jge	$+138    	;abs 0x85d6

0000854e <.L120>:
    854e:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    8552:	1c 53       	inc	r12		;

00008554 <.Loc.1688.1>:
    8554:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8558:	bb 40 5a 51 	mov	#20826,	0(r11)	;#0x515a
    855c:	00 00 
    855e:	0e 9f       	cmp	r15,	r14	;
    8560:	21 34       	jge	$+68     	;abs 0x85a4

00008562 <.Loc.1688.1>:
    8562:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    8566:	02 00 
    8568:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    856c:	18 00 

0000856e <.LVL201>:
    856e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    8572:	7d 40 07 00 	mov.b	#7,	r13	;
    8576:	0d 9c       	cmp	r12,	r13	;
    8578:	02 38       	jl	$+6      	;abs 0x857e

0000857a <.Loc.1688.1>:
    857a:	2b 52       	add	#4,	r11	;r2 As==10

0000857c <.LVL202>:
    857c:	10 3c       	jmp	$+34     	;abs 0x859e

0000857e <.L121>:
    857e:	0e 41       	mov	r1,	r14	;
    8580:	3e 50 14 00 	add	#20,	r14	;#0x0014
    8584:	0d 4a       	mov	r10,	r13	;
    8586:	1c 41 02 00 	mov	2(r1),	r12	;
    858a:	81 4f 00 00 	mov	r15,	0(r1)	;
    858e:	b0 12 fe 7d 	call	#32254		;#0x7dfe

00008592 <.LVL204>:
    8592:	2f 41       	mov	@r1,	r15	;
    8594:	0c 93       	cmp	#0,	r12	;r3 As==00
    8596:	87 21       	jnz	$+784    	;abs 0x88a6

00008598 <.Loc.1688.1>:
    8598:	0b 41       	mov	r1,	r11	;
    859a:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000859e <.L122>:
    859e:	3f 50 f0 ff 	add	#-16,	r15	;#0xfff0

000085a2 <.LVL206>:
    85a2:	d5 3f       	jmp	$-84     	;abs 0x854e

000085a4 <.L238>:
    85a4:	8b 4f 02 00 	mov	r15,	2(r11)	;
    85a8:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

000085ac <.LVL207>:
    85ac:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    85b0:	7f 40 07 00 	mov.b	#7,	r15	;

000085b4 <.LVL208>:
    85b4:	0f 9c       	cmp	r12,	r15	;
    85b6:	02 38       	jl	$+6      	;abs 0x85bc

000085b8 <.Loc.1688.1>:
    85b8:	2b 52       	add	#4,	r11	;r2 As==10

000085ba <.LVL209>:
    85ba:	0d 3c       	jmp	$+28     	;abs 0x85d6

000085bc <.L124>:
    85bc:	0e 41       	mov	r1,	r14	;
    85be:	3e 50 14 00 	add	#20,	r14	;#0x0014
    85c2:	0d 4a       	mov	r10,	r13	;
    85c4:	1c 41 02 00 	mov	2(r1),	r12	;
    85c8:	b0 12 fe 7d 	call	#32254		;#0x7dfe

000085cc <.LVL211>:
    85cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    85ce:	6b 21       	jnz	$+728    	;abs 0x88a6

000085d0 <.Loc.1688.1>:
    85d0:	0b 41       	mov	r1,	r11	;
    85d2:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000085d6 <.L119>:
    85d6:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    85da:	21 24       	jz	$+68     	;abs 0x861e

000085dc <.Loc.1692.1>:
    85dc:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    85e0:	0c 51       	add	r1,	r12	;
    85e2:	8b 4c 00 00 	mov	r12,	0(r11)	;
    85e6:	9b 43 02 00 	mov	#1,	2(r11)	;r3 As==01
    85ea:	91 53 18 00 	inc	24(r1)		;

000085ee <.LVL213>:
    85ee:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    85f2:	1c 53       	inc	r12		;
    85f4:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    85f8:	7d 40 07 00 	mov.b	#7,	r13	;
    85fc:	0d 9c       	cmp	r12,	r13	;
    85fe:	02 38       	jl	$+6      	;abs 0x8604
    8600:	2b 52       	add	#4,	r11	;r2 As==10

00008602 <.LVL214>:
    8602:	0d 3c       	jmp	$+28     	;abs 0x861e

00008604 <.L126>:
    8604:	0e 41       	mov	r1,	r14	;
    8606:	3e 50 14 00 	add	#20,	r14	;#0x0014
    860a:	0d 4a       	mov	r10,	r13	;
    860c:	1c 41 02 00 	mov	2(r1),	r12	;
    8610:	b0 12 fe 7d 	call	#32254		;#0x7dfe

00008614 <.LVL216>:
    8614:	0c 93       	cmp	#0,	r12	;r3 As==00
    8616:	47 21       	jnz	$+656    	;abs 0x88a6

00008618 <.Loc.1692.1>:
    8618:	0b 41       	mov	r1,	r11	;
    861a:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000861e <.L125>:
    861e:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    8622:	21 24       	jz	$+68     	;abs 0x8666

00008624 <.Loc.1694.1>:
    8624:	7e 40 12 00 	mov.b	#18,	r14	;#0x0012
    8628:	0e 51       	add	r1,	r14	;
    862a:	8b 4e 00 00 	mov	r14,	0(r11)	;
    862e:	ab 43 02 00 	mov	#2,	2(r11)	;r3 As==10
    8632:	a1 53 18 00 	incd	24(r1)		;

00008636 <.LVL218>:
    8636:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    863a:	1c 53       	inc	r12		;
    863c:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    8640:	7f 40 07 00 	mov.b	#7,	r15	;
    8644:	0f 9c       	cmp	r12,	r15	;
    8646:	02 38       	jl	$+6      	;abs 0x864c
    8648:	2b 52       	add	#4,	r11	;r2 As==10

0000864a <.LVL219>:
    864a:	0d 3c       	jmp	$+28     	;abs 0x8666

0000864c <.L128>:
    864c:	0e 41       	mov	r1,	r14	;
    864e:	3e 50 14 00 	add	#20,	r14	;#0x0014
    8652:	0d 4a       	mov	r10,	r13	;
    8654:	1c 41 02 00 	mov	2(r1),	r12	;
    8658:	b0 12 fe 7d 	call	#32254		;#0x7dfe

0000865c <.LVL221>:
    865c:	0c 93       	cmp	#0,	r12	;r3 As==00
    865e:	23 21       	jnz	$+584    	;abs 0x88a6

00008660 <.Loc.1694.1>:
    8660:	0b 41       	mov	r1,	r11	;
    8662:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00008666 <.L127>:
    8666:	b1 90 80 00 	cmp	#128,	14(r1)	;#0x0080, 0x000e
    866a:	0e 00 
    866c:	4a 20       	jnz	$+150    	;abs 0x8702

0000866e <.Loc.1698.1>:
    866e:	1f 41 06 00 	mov	6(r1),	r15	;
    8672:	0f 88       	sub	r8,	r15	;

00008674 <.LVL223>:
    8674:	4c 43       	clr.b	r12		;
    8676:	0c 9f       	cmp	r15,	r12	;
    8678:	44 34       	jge	$+138    	;abs 0x8702

0000867a <.L130>:
    867a:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    867e:	1c 53       	inc	r12		;

00008680 <.Loc.1698.1>:
    8680:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8684:	bb 40 4a 51 	mov	#20810,	0(r11)	;#0x514a
    8688:	00 00 
    868a:	0e 9f       	cmp	r15,	r14	;
    868c:	21 34       	jge	$+68     	;abs 0x86d0

0000868e <.Loc.1698.1>:
    868e:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    8692:	02 00 
    8694:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    8698:	18 00 

0000869a <.LVL224>:
    869a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    869e:	7d 40 07 00 	mov.b	#7,	r13	;
    86a2:	0d 9c       	cmp	r12,	r13	;
    86a4:	02 38       	jl	$+6      	;abs 0x86aa

000086a6 <.Loc.1698.1>:
    86a6:	2b 52       	add	#4,	r11	;r2 As==10

000086a8 <.LVL225>:
    86a8:	10 3c       	jmp	$+34     	;abs 0x86ca

000086aa <.L131>:
    86aa:	0e 41       	mov	r1,	r14	;
    86ac:	3e 50 14 00 	add	#20,	r14	;#0x0014
    86b0:	0d 4a       	mov	r10,	r13	;
    86b2:	1c 41 02 00 	mov	2(r1),	r12	;
    86b6:	81 4f 00 00 	mov	r15,	0(r1)	;
    86ba:	b0 12 fe 7d 	call	#32254		;#0x7dfe

000086be <.LVL227>:
    86be:	2f 41       	mov	@r1,	r15	;
    86c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    86c2:	f1 20       	jnz	$+484    	;abs 0x88a6

000086c4 <.Loc.1698.1>:
    86c4:	0b 41       	mov	r1,	r11	;
    86c6:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000086ca <.L132>:
    86ca:	3f 50 f0 ff 	add	#-16,	r15	;#0xfff0

000086ce <.LVL229>:
    86ce:	d5 3f       	jmp	$-84     	;abs 0x867a

000086d0 <.L239>:
    86d0:	8b 4f 02 00 	mov	r15,	2(r11)	;
    86d4:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

000086d8 <.LVL230>:
    86d8:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    86dc:	7f 40 07 00 	mov.b	#7,	r15	;

000086e0 <.LVL231>:
    86e0:	0f 9c       	cmp	r12,	r15	;
    86e2:	02 38       	jl	$+6      	;abs 0x86e8

000086e4 <.Loc.1698.1>:
    86e4:	2b 52       	add	#4,	r11	;r2 As==10

000086e6 <.LVL232>:
    86e6:	0d 3c       	jmp	$+28     	;abs 0x8702

000086e8 <.L134>:
    86e8:	0e 41       	mov	r1,	r14	;
    86ea:	3e 50 14 00 	add	#20,	r14	;#0x0014
    86ee:	0d 4a       	mov	r10,	r13	;
    86f0:	1c 41 02 00 	mov	2(r1),	r12	;
    86f4:	b0 12 fe 7d 	call	#32254		;#0x7dfe

000086f8 <.LVL234>:
    86f8:	0c 93       	cmp	#0,	r12	;r3 As==00
    86fa:	d5 20       	jnz	$+428    	;abs 0x88a6

000086fc <.Loc.1698.1>:
    86fc:	0b 41       	mov	r1,	r11	;
    86fe:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00008702 <.L129>:
    8702:	09 86       	sub	r6,	r9	;

00008704 <.LVL236>:
    8704:	4c 43       	clr.b	r12		;
    8706:	0c 99       	cmp	r9,	r12	;
    8708:	41 34       	jge	$+132    	;abs 0x878c

0000870a <.L136>:
    870a:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    870e:	1c 53       	inc	r12		;

00008710 <.Loc.1701.1>:
    8710:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8714:	bb 40 4a 51 	mov	#20810,	0(r11)	;#0x514a
    8718:	00 00 
    871a:	0e 99       	cmp	r9,	r14	;
    871c:	1e 34       	jge	$+62     	;abs 0x875a

0000871e <.Loc.1701.1>:
    871e:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    8722:	02 00 
    8724:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    8728:	18 00 

0000872a <.LVL237>:
    872a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    872e:	7d 40 07 00 	mov.b	#7,	r13	;
    8732:	0d 9c       	cmp	r12,	r13	;
    8734:	02 38       	jl	$+6      	;abs 0x873a

00008736 <.Loc.1701.1>:
    8736:	2b 52       	add	#4,	r11	;r2 As==10

00008738 <.LVL238>:
    8738:	0d 3c       	jmp	$+28     	;abs 0x8754

0000873a <.L137>:
    873a:	0e 41       	mov	r1,	r14	;
    873c:	3e 50 14 00 	add	#20,	r14	;#0x0014
    8740:	0d 4a       	mov	r10,	r13	;
    8742:	1c 41 02 00 	mov	2(r1),	r12	;
    8746:	b0 12 fe 7d 	call	#32254		;#0x7dfe

0000874a <.LVL240>:
    874a:	0c 93       	cmp	#0,	r12	;r3 As==00
    874c:	ac 20       	jnz	$+346    	;abs 0x88a6

0000874e <.Loc.1701.1>:
    874e:	0b 41       	mov	r1,	r11	;
    8750:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00008754 <.L138>:
    8754:	39 50 f0 ff 	add	#-16,	r9	;#0xfff0
    8758:	d8 3f       	jmp	$-78     	;abs 0x870a

0000875a <.L240>:
    875a:	8b 49 02 00 	mov	r9,	2(r11)	;
    875e:	81 59 18 00 	add	r9,	24(r1)	; 0x0018

00008762 <.LVL243>:
    8762:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    8766:	7f 40 07 00 	mov.b	#7,	r15	;
    876a:	0f 9c       	cmp	r12,	r15	;
    876c:	02 38       	jl	$+6      	;abs 0x8772

0000876e <.Loc.1701.1>:
    876e:	2b 52       	add	#4,	r11	;r2 As==10

00008770 <.LVL244>:
    8770:	0d 3c       	jmp	$+28     	;abs 0x878c

00008772 <.L140>:
    8772:	0e 41       	mov	r1,	r14	;
    8774:	3e 50 14 00 	add	#20,	r14	;#0x0014
    8778:	0d 4a       	mov	r10,	r13	;
    877a:	1c 41 02 00 	mov	2(r1),	r12	;
    877e:	b0 12 fe 7d 	call	#32254		;#0x7dfe

00008782 <.LVL246>:
    8782:	0c 93       	cmp	#0,	r12	;r3 As==00
    8784:	90 20       	jnz	$+290    	;abs 0x88a6

00008786 <.Loc.1701.1>:
    8786:	0b 41       	mov	r1,	r11	;
    8788:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000878c <.L135>:
    878c:	8b 44 00 00 	mov	r4,	0(r11)	;
    8790:	8b 46 02 00 	mov	r6,	2(r11)	;
    8794:	81 56 18 00 	add	r6,	24(r1)	; 0x0018

00008798 <.LVL248>:
    8798:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    879c:	1c 53       	inc	r12		;
    879e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    87a2:	74 40 07 00 	mov.b	#7,	r4	;

000087a6 <.LVL249>:
    87a6:	04 9c       	cmp	r12,	r4	;
    87a8:	02 38       	jl	$+6      	;abs 0x87ae
    87aa:	2b 52       	add	#4,	r11	;r2 As==10

000087ac <.LVL250>:
    87ac:	0d 3c       	jmp	$+28     	;abs 0x87c8

000087ae <.L141>:
    87ae:	0e 41       	mov	r1,	r14	;
    87b0:	3e 50 14 00 	add	#20,	r14	;#0x0014
    87b4:	0d 4a       	mov	r10,	r13	;
    87b6:	1c 41 02 00 	mov	2(r1),	r12	;
    87ba:	b0 12 fe 7d 	call	#32254		;#0x7dfe

000087be <.LVL252>:
    87be:	0c 93       	cmp	#0,	r12	;r3 As==00
    87c0:	72 20       	jnz	$+230    	;abs 0x88a6

000087c2 <.Loc.1767.1>:
    87c2:	0b 41       	mov	r1,	r11	;
    87c4:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000087c8 <.L142>:
    87c8:	25 b2       	bit	#4,	r5	;r2 As==10
    87ca:	0b 20       	jnz	$+24     	;abs 0x87e2

000087cc <.L147>:
    87cc:	1f 41 06 00 	mov	6(r1),	r15	;
    87d0:	0f 98       	cmp	r8,	r15	;
    87d2:	01 34       	jge	$+4      	;abs 0x87d6
    87d4:	0f 48       	mov	r8,	r15	;

000087d6 <.L144>:
    87d6:	81 5f 08 00 	add	r15,	8(r1)	;

000087da <.Loc.1776.1>:
    87da:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    87de:	50 24       	jz	$+162    	;abs 0x8880
    87e0:	45 3c       	jmp	$+140    	;abs 0x886c

000087e2 <.L143>:
    87e2:	16 41 06 00 	mov	6(r1),	r6	;

000087e6 <.LVL256>:
    87e6:	06 88       	sub	r8,	r6	;

000087e8 <.LVL257>:
    87e8:	4c 43       	clr.b	r12		;
    87ea:	0c 96       	cmp	r6,	r12	;
    87ec:	ef 37       	jge	$-32     	;abs 0x87cc

000087ee <.Loc.1771.1>:
    87ee:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    87f2:	35 40 fe 7d 	mov	#32254,	r5	;#0x7dfe

000087f6 <.L148>:
    87f6:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    87fa:	1c 53       	inc	r12		;
    87fc:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8800:	bb 40 5a 51 	mov	#20826,	0(r11)	;#0x515a
    8804:	00 00 
    8806:	0e 96       	cmp	r6,	r14	;
    8808:	1c 34       	jge	$+58     	;abs 0x8842

0000880a <.Loc.1771.1>:
    880a:	8b 49 02 00 	mov	r9,	2(r11)	;
    880e:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    8812:	18 00 
    8814:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    8818:	7d 40 07 00 	mov.b	#7,	r13	;
    881c:	0d 9c       	cmp	r12,	r13	;
    881e:	02 38       	jl	$+6      	;abs 0x8824

00008820 <.LVL259>:
    8820:	2b 52       	add	#4,	r11	;r2 As==10

00008822 <.LVL260>:
    8822:	0c 3c       	jmp	$+26     	;abs 0x883c

00008824 <.L149>:
    8824:	0e 41       	mov	r1,	r14	;
    8826:	3e 50 14 00 	add	#20,	r14	;#0x0014
    882a:	0d 4a       	mov	r10,	r13	;
    882c:	1c 41 02 00 	mov	2(r1),	r12	;
    8830:	85 12       	call	r5		;

00008832 <.LVL262>:
    8832:	0c 93       	cmp	#0,	r12	;r3 As==00
    8834:	38 20       	jnz	$+114    	;abs 0x88a6

00008836 <.LVL263>:
    8836:	0b 41       	mov	r1,	r11	;
    8838:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000883c <.L150>:
    883c:	36 50 f0 ff 	add	#-16,	r6	;#0xfff0
    8840:	da 3f       	jmp	$-74     	;abs 0x87f6

00008842 <.L242>:
    8842:	8b 46 02 00 	mov	r6,	2(r11)	;
    8846:	81 56 18 00 	add	r6,	24(r1)	; 0x0018
    884a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    884e:	7f 40 07 00 	mov.b	#7,	r15	;
    8852:	0f 9c       	cmp	r12,	r15	;
    8854:	bb 37       	jge	$-136    	;abs 0x87cc

00008856 <.Loc.1771.1>:
    8856:	0e 41       	mov	r1,	r14	;
    8858:	3e 50 14 00 	add	#20,	r14	;#0x0014
    885c:	0d 4a       	mov	r10,	r13	;
    885e:	1c 41 02 00 	mov	2(r1),	r12	;
    8862:	b0 12 fe 7d 	call	#32254		;#0x7dfe

00008866 <.LVL266>:
    8866:	0c 93       	cmp	#0,	r12	;r3 As==00
    8868:	b1 27       	jz	$-156    	;abs 0x87cc
    886a:	1d 3c       	jmp	$+60     	;abs 0x88a6

0000886c <.L241>:
    886c:	0e 41       	mov	r1,	r14	;
    886e:	3e 50 14 00 	add	#20,	r14	;#0x0014
    8872:	0d 4a       	mov	r10,	r13	;
    8874:	1c 41 02 00 	mov	2(r1),	r12	;
    8878:	b0 12 fe 7d 	call	#32254		;#0x7dfe

0000887c <.LVL268>:
    887c:	0c 93       	cmp	#0,	r12	;r3 As==00
    887e:	13 20       	jnz	$+40     	;abs 0x88a6

00008880 <.L146>:
    8880:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00008884 <.LVL269>:
    8884:	09 47       	mov	r7,	r9	;
    8886:	0b 41       	mov	r1,	r11	;
    8888:	3b 50 1a 00 	add	#26,	r11	;#0x001a
    888c:	30 40 8e 7f 	br	#0x7f8e		;

00008890 <.L34>:
    8890:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    8894:	08 24       	jz	$+18     	;abs 0x88a6

00008896 <.Loc.1784.1>:
    8896:	0e 41       	mov	r1,	r14	;
    8898:	3e 50 14 00 	add	#20,	r14	;#0x0014
    889c:	0d 4a       	mov	r10,	r13	;
    889e:	1c 41 02 00 	mov	2(r1),	r12	;
    88a2:	b0 12 fe 7d 	call	#32254		;#0x7dfe

000088a6 <.L33>:
    88a6:	fa b0 40 00 	bit.b	#64,	6(r10)	;#0x0040
    88aa:	06 00 
    88ac:	02 24       	jz	$+6      	;abs 0x88b2
    88ae:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

000088b2 <.L22>:
    88b2:	1c 41 08 00 	mov	8(r1),	r12	;
    88b6:	31 50 62 00 	add	#98,	r1	;#0x0062

000088ba <L0>:
    88ba:	64 17       	popm	#7,	r10	;16-bit words
    88bc:	30 41       	ret			

000088be <memchr>:
    88be:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

000088c2 <.LVL2>:
    88c2:	0e 5c       	add	r12,	r14	;

000088c4 <.L2>:
    88c4:	0c 9e       	cmp	r14,	r12	;
    88c6:	05 24       	jz	$+12     	;abs 0x88d2

000088c8 <.Loc.128.1>:
    88c8:	cc 9d 00 00 	cmp.b	r13,	0(r12)	;
    88cc:	03 24       	jz	$+8      	;abs 0x88d4

000088ce <.Loc.130.1>:
    88ce:	1c 53       	inc	r12		;

000088d0 <.LVL4>:
    88d0:	f9 3f       	jmp	$-12     	;abs 0x88c4

000088d2 <.L7>:
    88d2:	4c 43       	clr.b	r12		;

000088d4 <.L1>:
    88d4:	30 41       	ret			

000088d6 <memmove>:
    88d6:	0b 4c       	mov	r12,	r11	;

000088d8 <L0>:
    88d8:	0b 5e       	add	r14,	r11	;

000088da <.Loc.69.1>:
    88da:	0d 9c       	cmp	r12,	r13	;
    88dc:	02 28       	jnc	$+6      	;abs 0x88e2

000088de <.L4>:
    88de:	0e 4c       	mov	r12,	r14	;

000088e0 <.LVL2>:
    88e0:	0f 3c       	jmp	$+32     	;abs 0x8900

000088e2 <.L2>:
    88e2:	0f 4d       	mov	r13,	r15	;
    88e4:	0f 5e       	add	r14,	r15	;
    88e6:	0c 9f       	cmp	r15,	r12	;
    88e8:	fa 2f       	jc	$-10     	;abs 0x88de

000088ea <.LVL4>:
    88ea:	0d 4f       	mov	r15,	r13	;

000088ec <.LVL5>:
    88ec:	0e 8f       	sub	r15,	r14	;

000088ee <.L5>:
    88ee:	0f 4d       	mov	r13,	r15	;
    88f0:	0f 5e       	add	r14,	r15	;
    88f2:	0f 93       	cmp	#0,	r15	;r3 As==00
    88f4:	0c 24       	jz	$+26     	;abs 0x890e

000088f6 <.Loc.76.1>:
    88f6:	3b 53       	add	#-1,	r11	;r3 As==11
    88f8:	3d 53       	add	#-1,	r13	;r3 As==11

000088fa <.LVL8>:
    88fa:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    88fe:	f7 3f       	jmp	$-16     	;abs 0x88ee

00008900 <.L3>:
    8900:	0b 9e       	cmp	r14,	r11	;
    8902:	05 24       	jz	$+12     	;abs 0x890e

00008904 <.LVL10>:
    8904:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    8908:	1e 53       	inc	r14		;

0000890a <.LVL11>:
    890a:	1d 53       	inc	r13		;
    890c:	f9 3f       	jmp	$-12     	;abs 0x8900

0000890e <.L9>:
    890e:	30 41       	ret			

00008910 <_free_r>:
    8910:	6a 15       	pushm	#7,	r10	;16-bit words

00008912 <.LCFI0>:
    8912:	09 4c       	mov	r12,	r9	;

00008914 <.Loc.342.1>:
    8914:	0d 93       	cmp	#0,	r13	;r3 As==00

00008916 <L0>:
    8916:	7c 24       	jz	$+250    	;abs 0x8a10

00008918 <.LBB7>:
    8918:	0a 4d       	mov	r13,	r10	;
    891a:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc

0000891e <.LVL2>:
    891e:	1c 4d fc ff 	mov	-4(r13),r12	;

00008922 <.LVL3>:
    8922:	8d 93 fe ff 	cmp	#0,	-2(r13)	;r3 As==00, 0xfffe
    8926:	01 34       	jge	$+4      	;abs 0x892a
    8928:	0a 5c       	add	r12,	r10	;

0000892a <.L3>:
    892a:	0c 49       	mov	r9,	r12	;
    892c:	b0 12 86 8b 	call	#-29818	;#0x8b86

00008930 <.LVL5>:
    8930:	1c 42 08 5d 	mov	&0x5d08,r12	;0x5d08
    8934:	0c 93       	cmp	#0,	r12	;r3 As==00
    8936:	16 24       	jz	$+46     	;abs 0x8964

00008938 <.Loc.356.1>:
    8938:	0a 9c       	cmp	r12,	r10	;
    893a:	1f 2c       	jc	$+64     	;abs 0x897a

0000893c <.LBB9>:
    893c:	2e 4a       	mov	@r10,	r14	;
    893e:	1f 4a 02 00 	mov	2(r10),	r15	;
    8942:	0d 4a       	mov	r10,	r13	;
    8944:	0d 5e       	add	r14,	r13	;
    8946:	0c 9d       	cmp	r13,	r12	;
    8948:	0d 20       	jnz	$+28     	;abs 0x8964

0000894a <.Loc.362.1>:
    894a:	04 4e       	mov	r14,	r4	;
    894c:	05 4f       	mov	r15,	r5	;
    894e:	24 5c       	add	@r12,	r4	;
    8950:	15 6c 02 00 	addc	2(r12),	r5	;
    8954:	8a 44 00 00 	mov	r4,	0(r10)	;
    8958:	8a 45 02 00 	mov	r5,	2(r10)	;

0000895c <.Loc.363.1>:
    895c:	9a 4c 04 00 	mov	4(r12),	4(r10)	;
    8960:	04 00 
    8962:	02 3c       	jmp	$+6      	;abs 0x8968

00008964 <.L7>:
    8964:	8a 4c 04 00 	mov	r12,	4(r10)	;

00008968 <.L8>:
    8968:	82 4a 08 5d 	mov	r10,	&0x5d08	;

0000896c <.Loc.371.1>:
    896c:	0c 49       	mov	r9,	r12	;
    896e:	b0 12 88 8b 	call	#-29816	;#0x8b88

00008972 <.LVL6>:
    8972:	4e 3c       	jmp	$+158    	;abs 0x8a10

00008974 <.L23>:
    8974:	0a 9d       	cmp	r13,	r10	;
    8976:	05 28       	jnc	$+12     	;abs 0x8982
    8978:	0c 4d       	mov	r13,	r12	;

0000897a <.L10>:
    897a:	1d 4c 04 00 	mov	4(r12),	r13	;

0000897e <.LVL9>:
    897e:	0d 93       	cmp	#0,	r13	;r3 As==00
    8980:	f9 23       	jnz	$-12     	;abs 0x8974

00008982 <.L9>:
    8982:	2e 4c       	mov	@r12,	r14	;
    8984:	18 4c 02 00 	mov	2(r12),	r8	;
    8988:	0b 4c       	mov	r12,	r11	;
    898a:	0b 5e       	add	r14,	r11	;
    898c:	3f 40 88 8b 	mov	#-29816,r15	;#0x8b88
    8990:	0b 9a       	cmp	r10,	r11	;
    8992:	1a 20       	jnz	$+54     	;abs 0x89c8

00008994 <.Loc.390.1>:
    8994:	26 4a       	mov	@r10,	r6	;
    8996:	06 5e       	add	r14,	r6	;
    8998:	17 4a 02 00 	mov	2(r10),	r7	;
    899c:	07 68       	addc	r8,	r7	;
    899e:	8c 46 00 00 	mov	r6,	0(r12)	;
    89a2:	8c 47 02 00 	mov	r7,	2(r12)	;

000089a6 <.Loc.393.1>:
    89a6:	0e 4c       	mov	r12,	r14	;
    89a8:	0e 56       	add	r6,	r14	;
    89aa:	0d 9e       	cmp	r14,	r13	;
    89ac:	2f 20       	jnz	$+96     	;abs 0x8a0c

000089ae <.Loc.395.1>:
    89ae:	0a 46       	mov	r6,	r10	;
    89b0:	0b 47       	mov	r7,	r11	;
    89b2:	2a 5d       	add	@r13,	r10	;
    89b4:	1b 6d 02 00 	addc	2(r13),	r11	;
    89b8:	8c 4a 00 00 	mov	r10,	0(r12)	;
    89bc:	8c 4b 02 00 	mov	r11,	2(r12)	;

000089c0 <.Loc.396.1>:
    89c0:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    89c4:	04 00 
    89c6:	22 3c       	jmp	$+70     	;abs 0x8a0c

000089c8 <.L11>:
    89c8:	0a 9b       	cmp	r11,	r10	;
    89ca:	06 2c       	jc	$+14     	;abs 0x89d8

000089cc <.LBB10>:
    89cc:	b9 40 0c 00 	mov	#12,	0(r9)	;#0x000c
    89d0:	00 00 

000089d2 <.Loc.404.1>:
    89d2:	0c 49       	mov	r9,	r12	;

000089d4 <.LVL10>:
    89d4:	8f 12       	call	r15		;

000089d6 <.LVL11>:
    89d6:	1c 3c       	jmp	$+58     	;abs 0x8a10

000089d8 <.L13>:
    89d8:	26 4a       	mov	@r10,	r6	;
    89da:	17 4a 02 00 	mov	2(r10),	r7	;
    89de:	0e 4a       	mov	r10,	r14	;
    89e0:	0e 56       	add	r6,	r14	;
    89e2:	0d 9e       	cmp	r14,	r13	;
    89e4:	0f 20       	jnz	$+32     	;abs 0x8a04

000089e6 <.Loc.412.1>:
    89e6:	04 46       	mov	r6,	r4	;
    89e8:	05 47       	mov	r7,	r5	;
    89ea:	24 5d       	add	@r13,	r4	;
    89ec:	15 6d 02 00 	addc	2(r13),	r5	;
    89f0:	8a 44 00 00 	mov	r4,	0(r10)	;
    89f4:	8a 45 02 00 	mov	r5,	2(r10)	;

000089f8 <.Loc.413.1>:
    89f8:	9a 4d 04 00 	mov	4(r13),	4(r10)	;
    89fc:	04 00 

000089fe <.Loc.414.1>:
    89fe:	8c 4a 04 00 	mov	r10,	4(r12)	;
    8a02:	04 3c       	jmp	$+10     	;abs 0x8a0c

00008a04 <.L14>:
    8a04:	8a 4d 04 00 	mov	r13,	4(r10)	;

00008a08 <.Loc.421.1>:
    8a08:	8c 4a 04 00 	mov	r10,	4(r12)	;

00008a0c <.L12>:
    8a0c:	0c 49       	mov	r9,	r12	;

00008a0e <.LVL13>:
    8a0e:	8f 12       	call	r15		;

00008a10 <.L1>:
    8a10:	64 17       	popm	#7,	r10	;16-bit words
    8a12:	30 41       	ret			

00008a14 <_malloc_r>:
    8a14:	3a 15       	pushm	#4,	r10	;16-bit words

00008a16 <.LCFI0>:
    8a16:	08 4c       	mov	r12,	r8	;

00008a18 <.Loc.246.1>:
    8a18:	09 4d       	mov	r13,	r9	;
    8a1a:	19 53       	inc	r9		;
    8a1c:	19 c3       	bic	#1,	r9	;r3 As==01

00008a1e <L0>:
    8a1e:	39 50 0a 00 	add	#10,	r9	;#0x000a

00008a22 <.LVL2>:
    8a22:	39 90 0c 00 	cmp	#12,	r9	;#0x000c
    8a26:	02 2c       	jc	$+6      	;abs 0x8a2c
    8a28:	79 40 0c 00 	mov.b	#12,	r9	;#0x000c

00008a2c <.L2>:
    8a2c:	09 9d       	cmp	r13,	r9	;
    8a2e:	05 2c       	jc	$+12     	;abs 0x8a3a

00008a30 <.Loc.253.1>:
    8a30:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    8a34:	00 00 

00008a36 <.Loc.254.1>:
    8a36:	4c 43       	clr.b	r12		;

00008a38 <.LVL4>:
    8a38:	6a 3c       	jmp	$+214    	;abs 0x8b0e

00008a3a <.L3>:
    8a3a:	0c 48       	mov	r8,	r12	;
    8a3c:	b0 12 86 8b 	call	#-29818	;#0x8b86

00008a40 <.LVL5>:
    8a40:	1a 42 08 5d 	mov	&0x5d08,r10	;0x5d08

00008a44 <.LVL6>:
    8a44:	0d 4a       	mov	r10,	r13	;

00008a46 <.L5>:
    8a46:	0d 93       	cmp	#0,	r13	;r3 As==00
    8a48:	28 24       	jz	$+82     	;abs 0x8a9a

00008a4a <.LBB6>:
    8a4a:	2c 4d       	mov	@r13,	r12	;
    8a4c:	0c 89       	sub	r9,	r12	;

00008a4e <.LVL8>:
    8a4e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8a50:	20 38       	jl	$+66     	;abs 0x8a92

00008a52 <.Loc.267.1>:
    8a52:	7e 40 0b 00 	mov.b	#11,	r14	;#0x000b
    8a56:	0e 9c       	cmp	r12,	r14	;
    8a58:	11 2c       	jc	$+36     	;abs 0x8a7c

00008a5a <.Loc.271.1>:
    8a5a:	0e 4c       	mov	r12,	r14	;
    8a5c:	0f 4c       	mov	r12,	r15	;
    8a5e:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8a62:	8d 4e 00 00 	mov	r14,	0(r13)	;
    8a66:	8d 4f 02 00 	mov	r15,	2(r13)	;

00008a6a <.Loc.272.1>:
    8a6a:	0a 4d       	mov	r13,	r10	;

00008a6c <.LVL9>:
    8a6c:	0a 5c       	add	r12,	r10	;

00008a6e <.LVL10>:
    8a6e:	0c 49       	mov	r9,	r12	;
    8a70:	0d 43       	clr	r13		;

00008a72 <.LVL11>:
    8a72:	8a 4c 00 00 	mov	r12,	0(r10)	;
    8a76:	8a 4d 02 00 	mov	r13,	2(r10)	;
    8a7a:	28 3c       	jmp	$+82     	;abs 0x8acc

00008a7c <.L7>:
    8a7c:	0a 9d       	cmp	r13,	r10	;
    8a7e:	04 20       	jnz	$+10     	;abs 0x8a88

00008a80 <.Loc.281.1>:
    8a80:	92 4a 04 00 	mov	4(r10),	&0x5d08	;
    8a84:	08 5d 
    8a86:	22 3c       	jmp	$+70     	;abs 0x8acc

00008a88 <.L9>:
    8a88:	9a 4d 04 00 	mov	4(r13),	4(r10)	;
    8a8c:	04 00 
    8a8e:	0a 4d       	mov	r13,	r10	;

00008a90 <.LVL13>:
    8a90:	1d 3c       	jmp	$+60     	;abs 0x8acc

00008a92 <.L6>:
    8a92:	0a 4d       	mov	r13,	r10	;
    8a94:	1d 4d 04 00 	mov	4(r13),	r13	;

00008a98 <.LVL15>:
    8a98:	d6 3f       	jmp	$-82     	;abs 0x8a46

00008a9a <.L23>:
    8a9a:	37 40 64 8b 	mov	#-29852,r7	;#0x8b64

00008a9e <.LBB7>:
    8a9e:	82 93 06 5d 	cmp	#0,	&0x5d06	;r3 As==00
    8aa2:	04 20       	jnz	$+10     	;abs 0x8aac
    8aa4:	0c 48       	mov	r8,	r12	;
    8aa6:	87 12       	call	r7		;

00008aa8 <.LVL17>:
    8aa8:	82 4c 06 5d 	mov	r12,	&0x5d06	;

00008aac <.L16>:
    8aac:	0d 49       	mov	r9,	r13	;
    8aae:	0c 48       	mov	r8,	r12	;
    8ab0:	87 12       	call	r7		;

00008ab2 <.LVL18>:
    8ab2:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8ab4:	25 24       	jz	$+76     	;abs 0x8b00

00008ab6 <.Loc.221.1>:
    8ab6:	0a 4c       	mov	r12,	r10	;

00008ab8 <.LVL19>:
    8ab8:	1a 53       	inc	r10		;
    8aba:	1a c3       	bic	#1,	r10	;r3 As==01

00008abc <.LVL20>:
    8abc:	0c 9a       	cmp	r10,	r12	;
    8abe:	1a 20       	jnz	$+54     	;abs 0x8af4

00008ac0 <.L13>:
    8ac0:	0d 49       	mov	r9,	r13	;
    8ac2:	0e 43       	clr	r14		;
    8ac4:	8a 4d 00 00 	mov	r13,	0(r10)	;
    8ac8:	8a 4e 02 00 	mov	r14,	2(r10)	;

00008acc <.L8>:
    8acc:	0c 48       	mov	r8,	r12	;
    8ace:	b0 12 88 8b 	call	#-29816	;#0x8b88

00008ad2 <.LVL23>:
    8ad2:	0e 4a       	mov	r10,	r14	;
    8ad4:	2e 52       	add	#4,	r14	;r2 As==10

00008ad6 <.LVL24>:
    8ad6:	0c 4e       	mov	r14,	r12	;
    8ad8:	3c 50 07 00 	add	#7,	r12	;
    8adc:	3c f0 f8 ff 	and	#-8,	r12	;#0xfff8

00008ae0 <.LVL25>:
    8ae0:	0d 4c       	mov	r12,	r13	;
    8ae2:	0d 8e       	sub	r14,	r13	;

00008ae4 <.LVL26>:
    8ae4:	0d 93       	cmp	#0,	r13	;r3 As==00
    8ae6:	13 24       	jz	$+40     	;abs 0x8b0e

00008ae8 <.Loc.317.1>:
    8ae8:	0a 5d       	add	r13,	r10	;

00008aea <.LVL27>:
    8aea:	4e 43       	clr.b	r14		;

00008aec <.LVL28>:
    8aec:	0e 8d       	sub	r13,	r14	;
    8aee:	8a 4e 00 00 	mov	r14,	0(r10)	;
    8af2:	0d 3c       	jmp	$+28     	;abs 0x8b0e

00008af4 <.L24>:
    8af4:	0d 4a       	mov	r10,	r13	;
    8af6:	0d 8c       	sub	r12,	r13	;
    8af8:	0c 48       	mov	r8,	r12	;

00008afa <.LVL30>:
    8afa:	87 12       	call	r7		;

00008afc <.LVL31>:
    8afc:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8afe:	e0 23       	jnz	$-62     	;abs 0x8ac0

00008b00 <.L14>:
    8b00:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    8b04:	00 00 

00008b06 <.Loc.303.1>:
    8b06:	0c 48       	mov	r8,	r12	;
    8b08:	b0 12 88 8b 	call	#-29816	;#0x8b88

00008b0c <.LVL33>:
    8b0c:	4c 43       	clr.b	r12		;

00008b0e <.L1>:
    8b0e:	37 17       	popm	#4,	r10	;16-bit words
    8b10:	30 41       	ret			

00008b12 <_realloc_r>:
    8b12:	3a 15       	pushm	#4,	r10	;16-bit words

00008b14 <.LCFI0>:
    8b14:	07 4c       	mov	r12,	r7	;
    8b16:	08 4d       	mov	r13,	r8	;
    8b18:	0a 4e       	mov	r14,	r10	;

00008b1a <.Loc.453.1>:
    8b1a:	0d 93       	cmp	#0,	r13	;r3 As==00
    8b1c:	05 20       	jnz	$+12     	;abs 0x8b28

00008b1e <L0>:
    8b1e:	0d 4e       	mov	r14,	r13	;

00008b20 <.LVL1>:
    8b20:	b0 12 14 8a 	call	#-30188	;#0x8a14

00008b24 <.LVL2>:
    8b24:	09 4c       	mov	r12,	r9	;
    8b26:	1b 3c       	jmp	$+56     	;abs 0x8b5e

00008b28 <.L2>:
    8b28:	0e 93       	cmp	#0,	r14	;r3 As==00
    8b2a:	04 20       	jnz	$+10     	;abs 0x8b34

00008b2c <.Loc.457.1>:
    8b2c:	b0 12 10 89 	call	#-30448	;#0x8910

00008b30 <.LVL3>:
    8b30:	09 4a       	mov	r10,	r9	;
    8b32:	15 3c       	jmp	$+44     	;abs 0x8b5e

00008b34 <.L4>:
    8b34:	b0 12 8a 8b 	call	#-29814	;#0x8b8a

00008b38 <.LVL4>:
    8b38:	0c 9a       	cmp	r10,	r12	;
    8b3a:	10 2c       	jc	$+34     	;abs 0x8b5c

00008b3c <.Loc.466.1>:
    8b3c:	0d 4a       	mov	r10,	r13	;
    8b3e:	0c 47       	mov	r7,	r12	;
    8b40:	b0 12 14 8a 	call	#-30188	;#0x8a14

00008b44 <.LVL5>:
    8b44:	09 4c       	mov	r12,	r9	;

00008b46 <.LVL6>:
    8b46:	0c 93       	cmp	#0,	r12	;r3 As==00
    8b48:	0a 24       	jz	$+22     	;abs 0x8b5e

00008b4a <.Loc.469.1>:
    8b4a:	0e 4a       	mov	r10,	r14	;
    8b4c:	0d 48       	mov	r8,	r13	;
    8b4e:	b0 12 6e 7d 	call	#32110		;#0x7d6e

00008b52 <.LVL7>:
    8b52:	0d 48       	mov	r8,	r13	;
    8b54:	0c 47       	mov	r7,	r12	;
    8b56:	b0 12 10 89 	call	#-30448	;#0x8910

00008b5a <.LVL8>:
    8b5a:	01 3c       	jmp	$+4      	;abs 0x8b5e

00008b5c <.L5>:
    8b5c:	09 48       	mov	r8,	r9	;

00008b5e <.L1>:
    8b5e:	0c 49       	mov	r9,	r12	;
    8b60:	37 17       	popm	#4,	r10	;16-bit words
    8b62:	30 41       	ret			

00008b64 <_sbrk_r>:
    8b64:	0a 15       	pushm	#1,	r10	;16-bit words

00008b66 <.LCFI0>:
    8b66:	0a 4c       	mov	r12,	r10	;

00008b68 <.Loc.57.1>:
    8b68:	82 43       	mov	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00008b6a <L0>:
    8b6a:	0a 5d       	add	r13,	r10	;

00008b6c <.Loc.58.1>:
    8b6c:	0c 4d       	mov	r13,	r12	;

00008b6e <.LVL1>:
    8b6e:	b0 12 9e 8b 	call	#-29794	;#0x8b9e

00008b72 <.LVL2>:
    8b72:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8b74:	06 20       	jnz	$+14     	;abs 0x8b82

00008b76 <.Loc.58.1>:
    8b76:	1d 42 0a 5d 	mov	&0x5d0a,r13	;0x5d0a
    8b7a:	0d 93       	cmp	#0,	r13	;r3 As==00
    8b7c:	02 24       	jz	$+6      	;abs 0x8b82

00008b7e <.Loc.59.1>:
    8b7e:	8a 4d 00 00 	mov	r13,	0(r10)	;

00008b82 <.L2>:
    8b82:	0a 17       	popm	#1,	r10	;16-bit words
    8b84:	30 41       	ret			

00008b86 <__malloc_lock>:
    8b86:	30 41       	ret			

00008b88 <__malloc_unlock>:
    8b88:	30 41       	ret			

00008b8a <_malloc_usable_size_r>:
    8b8a:	1e 4d fc ff 	mov	-4(r13),r14	;
    8b8e:	0c 4e       	mov	r14,	r12	;

00008b90 <.LVL3>:
    8b90:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

00008b94 <.Loc.529.1>:
    8b94:	0e 93       	cmp	#0,	r14	;r3 As==00
    8b96:	02 34       	jge	$+6      	;abs 0x8b9c

00008b98 <.LVL4>:
    8b98:	0d 5c       	add	r12,	r13	;

00008b9a <.LVL5>:
    8b9a:	2c 5d       	add	@r13,	r12	;

00008b9c <.L1>:
    8b9c:	30 41       	ret			

00008b9e <_sbrk>:
    8b9e:	21 83       	decd	r1		;

00008ba0 <.LCFI0>:
    8ba0:	1d 42 8a 5c 	mov	&0x5c8a,r13	;0x5c8a

00008ba4 <.LVL1>:
    8ba4:	4e 43       	clr.b	r14		;
    8ba6:	0e 51       	add	r1,	r14	;
    8ba8:	81 4e 00 00 	mov	r14,	0(r1)	;

00008bac <.Loc.22.1>:
    8bac:	0c 5d       	add	r13,	r12	;

00008bae <.LVL2>:
    8bae:	01 9c       	cmp	r12,	r1	;
    8bb0:	05 28       	jnc	$+12     	;abs 0x8bbc

00008bb2 <.Loc.29.1>:
    8bb2:	82 4c 8a 5c 	mov	r12,	&0x5c8a	;

00008bb6 <.Loc.31.1>:
    8bb6:	0c 4d       	mov	r13,	r12	;
    8bb8:	21 53       	incd	r1		;
    8bba:	30 41       	ret			

00008bbc <.L4>:
    8bbc:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    8bc0:	3d 40 6a 51 	mov	#20842,	r13	;#0x516a

00008bc4 <.LVL4>:
    8bc4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8bc6:	b0 12 ce 8b 	call	#-29746	;#0x8bce

00008bca <.LVL5>:
    8bca:	b0 12 60 8c 	call	#-29600	;#0x8c60

00008bce <write>:
    8bce:	6a 15       	pushm	#7,	r10	;16-bit words

00008bd0 <.LCFI0>:
    8bd0:	21 82       	sub	#4,	r1	;r2 As==10

00008bd2 <.LCFI1>:
    8bd2:	07 4d       	mov	r13,	r7	;
    8bd4:	09 4e       	mov	r14,	r9	;

00008bd6 <.Loc.48.1>:
    8bd6:	4d 43       	clr.b	r13		;

00008bd8 <.LVL2>:
    8bd8:	0d 9e       	cmp	r14,	r13	;
    8bda:	3e 34       	jge	$+126    	;abs 0x8c58
    8bdc:	4d 4c       	mov.b	r12,	r13	;
    8bde:	81 4d 02 00 	mov	r13,	2(r1)	;
    8be2:	5c 0f       	rrum	#4,	r12	;
    8be4:	5c 0f       	rrum	#4,	r12	;

00008be6 <.LVL3>:
    8be6:	81 4c 00 00 	mov	r12,	0(r1)	;
    8bea:	34 40 8c 5c 	mov	#23692,	r4	;#0x5c8c
    8bee:	35 40 6e 7d 	mov	#32110,	r5	;#0x7d6e
    8bf2:	36 40 5c 8c 	mov	#-29604,r6	;#0x8c5c

00008bf6 <.LBB5>:
    8bf6:	48 43       	clr.b	r8		;

00008bf8 <.Loc.28.1>:
    8bf8:	09 47       	mov	r7,	r9	;
    8bfa:	07 4e       	mov	r14,	r7	;

00008bfc <.L4>:
    8bfc:	0a 47       	mov	r7,	r10	;
    8bfe:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    8c02:	0c 97       	cmp	r7,	r12	;
    8c04:	01 34       	jge	$+4      	;abs 0x8c08
    8c06:	0a 4c       	mov	r12,	r10	;

00008c08 <.L3>:
    8c08:	4c 4a       	mov.b	r10,	r12	;
    8c0a:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

00008c0e <.Loc.22.1>:
    8c0e:	c2 48 8d 5c 	mov.b	r8,	&0x5c8d	;

00008c12 <.Loc.23.1>:
    8c12:	f2 40 f3 ff 	mov.b	#-13,	&0x5c8e	;#0xfff3
    8c16:	8e 5c 

00008c18 <.Loc.24.1>:
    8c18:	1d 41 02 00 	mov	2(r1),	r13	;
    8c1c:	c4 4d 03 00 	mov.b	r13,	3(r4)	;

00008c20 <.Loc.25.1>:
    8c20:	2d 41       	mov	@r1,	r13	;
    8c22:	c4 4d 04 00 	mov.b	r13,	4(r4)	;

00008c26 <.Loc.26.1>:
    8c26:	c4 4c 05 00 	mov.b	r12,	5(r4)	;

00008c2a <.Loc.27.1>:
    8c2a:	c2 48 92 5c 	mov.b	r8,	&0x5c92	;

00008c2e <.Loc.28.1>:
    8c2e:	0e 4a       	mov	r10,	r14	;
    8c30:	0d 49       	mov	r9,	r13	;
    8c32:	3c 40 97 5c 	mov	#23703,	r12	;#0x5c97
    8c36:	85 12       	call	r5		;

00008c38 <.LVL6>:
    8c38:	86 12       	call	r6		;

00008c3a <.LBE10>:
    8c3a:	07 8a       	sub	r10,	r7	;

00008c3c <.Loc.56.1>:
    8c3c:	09 5a       	add	r10,	r9	;

00008c3e <.LBE5>:
    8c3e:	4c 43       	clr.b	r12		;
    8c40:	0c 97       	cmp	r7,	r12	;
    8c42:	dc 3b       	jl	$-70     	;abs 0x8bfc

00008c44 <.LBB11>:
    8c44:	5c 44 03 00 	mov.b	3(r4),	r12	;
    8c48:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    8c4c:	54 44 02 00 	mov.b	2(r4),	r4	;
    8c50:	0c 54       	add	r4,	r12	;

00008c52 <.L1>:
    8c52:	21 52       	add	#4,	r1	;r2 As==10
    8c54:	64 17       	popm	#7,	r10	;16-bit words
    8c56:	30 41       	ret			

00008c58 <.L5>:
    8c58:	4c 43       	clr.b	r12		;

00008c5a <.LVL12>:
    8c5a:	fb 3f       	jmp	$-8      	;abs 0x8c52

00008c5c <C$$IO$$>:
    8c5c:	03 43       	nop			

00008c5e <L0>:
    8c5e:	30 41       	ret			

00008c60 <abort>:
    8c60:	7c 40 06 00 	mov.b	#6,	r12	;
    8c64:	b0 12 e0 8c 	call	#-29472	;#0x8ce0

00008c68 <.LVL0>:
    8c68:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c6a:	b0 12 16 8d 	call	#-29418	;#0x8d16

00008c6e <memset>:
    8c6e:	0f 4c       	mov	r12,	r15	;
    8c70:	0e 5c       	add	r12,	r14	;

00008c72 <.L2>:
    8c72:	0f 9e       	cmp	r14,	r15	;
    8c74:	04 24       	jz	$+10     	;abs 0x8c7e

00008c76 <.LVL3>:
    8c76:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    8c7a:	1f 53       	inc	r15		;

00008c7c <.LVL4>:
    8c7c:	fa 3f       	jmp	$-10     	;abs 0x8c72

00008c7e <.L5>:
    8c7e:	30 41       	ret			

00008c80 <_raise_r>:
    8c80:	1a 15       	pushm	#2,	r10	;16-bit words

00008c82 <L0>:
    8c82:	09 4c       	mov	r12,	r9	;
    8c84:	0a 4d       	mov	r13,	r10	;

00008c86 <.Loc.151.1>:
    8c86:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

00008c8a <.LVL16>:
    8c8a:	0c 9d       	cmp	r13,	r12	;
    8c8c:	05 2c       	jc	$+12     	;abs 0x8c98

00008c8e <.Loc.153.1>:
    8c8e:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    8c92:	00 00 

00008c94 <.Loc.154.1>:
    8c94:	3c 43       	mov	#-1,	r12	;r3 As==11
    8c96:	22 3c       	jmp	$+70     	;abs 0x8cdc

00008c98 <.L18>:
    8c98:	1c 49 22 00 	mov	34(r9),	r12	;0x00022
    8c9c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c9e:	05 24       	jz	$+12     	;abs 0x8caa

00008ca0 <.Loc.160.1>:
    8ca0:	0d 5d       	rla	r13		;

00008ca2 <.LVL17>:
    8ca2:	0c 5d       	add	r13,	r12	;
    8ca4:	2d 4c       	mov	@r12,	r13	;

00008ca6 <.LVL18>:
    8ca6:	0d 93       	cmp	#0,	r13	;r3 As==00
    8ca8:	09 20       	jnz	$+20     	;abs 0x8cbc

00008caa <.L20>:
    8caa:	0c 49       	mov	r9,	r12	;
    8cac:	b0 12 10 8d 	call	#-29424	;#0x8d10

00008cb0 <.LVL20>:
    8cb0:	0e 4a       	mov	r10,	r14	;
    8cb2:	0d 4c       	mov	r12,	r13	;
    8cb4:	0c 49       	mov	r9,	r12	;
    8cb6:	b0 12 ec 8c 	call	#-29460	;#0x8cec

00008cba <.LVL21>:
    8cba:	10 3c       	jmp	$+34     	;abs 0x8cdc

00008cbc <.L21>:
    8cbc:	1d 93       	cmp	#1,	r13	;r3 As==01
    8cbe:	0d 24       	jz	$+28     	;abs 0x8cda

00008cc0 <.Loc.166.1>:
    8cc0:	3d 93       	cmp	#-1,	r13	;r3 As==11
    8cc2:	05 20       	jnz	$+12     	;abs 0x8cce

00008cc4 <.Loc.168.1>:
    8cc4:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    8cc8:	00 00 

00008cca <.Loc.169.1>:
    8cca:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8ccc:	07 3c       	jmp	$+16     	;abs 0x8cdc

00008cce <.L22>:
    8cce:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00008cd2 <.Loc.174.1>:
    8cd2:	0c 4a       	mov	r10,	r12	;
    8cd4:	8d 12       	call	r13		;

00008cd6 <.LVL23>:
    8cd6:	4c 43       	clr.b	r12		;
    8cd8:	01 3c       	jmp	$+4      	;abs 0x8cdc

00008cda <.L23>:
    8cda:	4c 43       	clr.b	r12		;

00008cdc <.L17>:
    8cdc:	19 17       	popm	#2,	r10	;16-bit words
    8cde:	30 41       	ret			

00008ce0 <raise>:
    8ce0:	0d 4c       	mov	r12,	r13	;
    8ce2:	1c 42 10 5c 	mov	&0x5c10,r12	;0x5c10

00008ce6 <.LVL37>:
    8ce6:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00008ce8 <L0>:
    8ce8:	80 8c 30 41 	sub	r12		; Warning: disassembly unreliable - not enough bytes available

00008cea <.LVL38>:
    8cea:	30 41       	ret			

00008cec <_kill_r>:
    8cec:	0a 15       	pushm	#1,	r10	;16-bit words

00008cee <.LCFI0>:
    8cee:	0a 4c       	mov	r12,	r10	;
    8cf0:	0c 4d       	mov	r13,	r12	;

00008cf2 <.LVL1>:
    8cf2:	82 43 0a 5d 	mov	#0,	&0x5d0a	;r3 As==00

00008cf6 <.Loc.61.1>:
    8cf6:	0d 4e       	mov	r14,	r13	;

00008cf8 <.LVL2>:
    8cf8:	b0 12 1e 8d 	call	#-29410	;#0x8d1e

00008cfc <.LVL3>:
    8cfc:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8cfe:	06 20       	jnz	$+14     	;abs 0x8d0c

00008d00 <.Loc.61.1>:
    8d00:	1d 42 0a 5d 	mov	&0x5d0a,r13	;0x5d0a
    8d04:	0d 93       	cmp	#0,	r13	;r3 As==00
    8d06:	02 24       	jz	$+6      	;abs 0x8d0c

00008d08 <.Loc.62.1>:
    8d08:	8a 4d 00 00 	mov	r13,	0(r10)	;

00008d0c <.L1>:
    8d0c:	0a 17       	popm	#1,	r10	;16-bit words
    8d0e:	30 41       	ret			

00008d10 <_getpid_r>:
    8d10:	b0 12 18 8d 	call	#-29416	;#0x8d18

00008d14 <.LVL5>:
    8d14:	30 41       	ret			

00008d16 <_exit>:
    8d16:	ff 3f       	jmp	$+0      	;abs 0x8d16

00008d18 <getpid>:
    8d18:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00008d1a <L0>:
    8d1a:	2a 00 30 41 	mova			;Warning: disassembly unreliable - not enough bytes available

00008d1c <.Loc.65.1>:
    8d1c:	30 41       	ret			

00008d1e <kill>:
    8d1e:	b0 12 2c 8d 	call	#-29396	;#0x8d2c
    8d22:	bc 40 58 00 	mov	#88,	0(r12)	;#0x0058
    8d26:	00 00 
    8d28:	3c 43       	mov	#-1,	r12	;r3 As==11
    8d2a:	30 41       	ret			

00008d2c <__errno>:
    8d2c:	1c 42 10 5c 	mov	&0x5c10,r12	;0x5c10
    8d30:	30 41       	ret			
