
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	d6 85       	sub.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	d8 85       	sub.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	da 85       	sub.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	dc 85       	sub.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	de 85       	sub.b			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	e0 85 00 00 	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	e2 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	e4 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	e6 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	e8 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	ea 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	ec 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	ee 85       	sub.b	@r5		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	f0 85 00 00 	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	f2 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	f4 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	f6 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	f8 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	fa 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	fc 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	fe 85       	sub.b	@r5+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	00 86       	sub	r6,	r0	;

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	02 86       	sub	r6,	r2	;

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	04 86       	sub	r6,	r4	;

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	06 86       	sub	r6,	r6	;

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	08 86       	sub	r6,	r8	;

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	0a 86       	sub	r6,	r10	;

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	0c 86       	sub	r6,	r12	;

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	0e 86       	sub	r6,	r14	;

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	10 86       	sub,		r0	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	12 86       	sub,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	14 86       	sub,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	a4 5f       	add	@r15		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	40 5f       	add.b	r15,	r0	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	16 86       	sub,		r6	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	18 86       	sub,		r8	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	de 5e       	rla.b			;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	1a 86       	sub,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	1c 86       	sub,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	7e 5e       	add.b	@r14+,	r14	;

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	1e 86       	interrupt service routine at 0x861e

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	20 86       	interrupt service routine at 0x8620

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	08 60       	interrupt service routine at 0x6008

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	78 5d       	interrupt service routine at 0x5d78

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	22 86       	interrupt service routine at 0x8622

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	24 86       	interrupt service routine at 0x8624

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	d4 60       	interrupt service routine at 0x60d4

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	26 86       	interrupt service routine at 0x8626

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	28 86       	interrupt service routine at 0x8628

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	2a 86       	interrupt service routine at 0x862a

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	3c 5d       	interrupt service routine at 0x5d3c

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	2c 86       	interrupt service routine at 0x862c

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	2e 86       	interrupt service routine at 0x862e

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	30 86       	interrupt service routine at 0x8630

Disassembly of section .text:

00005d10 <__crt0_start>:
    5d10:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00005d14 <__crt0_init_bss>:
    5d14:	3c 40 dc 5c 	mov	#23772,	r12	;#0x5cdc

00005d18 <.Loc.74.1>:
    5d18:	0d 43       	clr	r13		;

00005d1a <.Loc.75.1>:
    5d1a:	3e 40 34 00 	mov	#52,	r14	;#0x0034

00005d1e <.Loc.79.1>:
    5d1e:	b0 12 6a a0 	call	#-24470	;#0xa06a

00005d22 <__crt0_movedata>:
    5d22:	3c 40 d0 51 	mov	#20944,	r12	;#0x51d0

00005d26 <.Loc.116.1>:
    5d26:	3d 40 d0 51 	mov	#20944,	r13	;#0x51d0

00005d2a <.Loc.119.1>:
    5d2a:	0d 9c       	cmp	r12,	r13	;

00005d2c <.Loc.120.1>:
    5d2c:	04 24       	jz	$+10     	;abs 0x5d36

00005d2e <.Loc.122.1>:
    5d2e:	3e 40 0c 0b 	mov	#2828,	r14	;#0x0b0c

00005d32 <.Loc.124.1>:
    5d32:	b0 12 d2 9c 	call	#-25390	;#0x9cd2

00005d36 <__crt0_call_just_main>:
    5d36:	0c 43       	clr	r12		;

00005d38 <.Loc.181.1>:
    5d38:	b0 12 06 8d 	call	#-29434	;#0x8d06

00005d3c <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    5d3c:	bf 15       	pushm	#12,	r15	;16-bit words

00005d3e <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    5d3e:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5d42:	b0 12 46 63 	call	#25414		;#0x6346

00005d46 <.Loc.170.3>:
  
  osalSysLockFromISR();
    5d46:	b0 12 76 73 	call	#29558		;#0x7376

00005d4a <.Loc.171.3>:
  osalOsTimerHandlerI();
    5d4a:	b0 12 8e 73 	call	#29582		;#0x738e

00005d4e <.Loc.172.3>:
  osalSysUnlockFromISR();
    5d4e:	b0 12 82 73 	call	#29570		;#0x7382

00005d52 <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    5d52:	b0 12 74 63 	call	#25460		;#0x6374
    5d56:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5d5a:	b0 12 be 62 	call	#25278		;#0x62be
    5d5e:	b0 12 f4 65 	call	#26100		;#0x65f4
    5d62:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5d66:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d68:	02 24       	jz	$+6      	;abs 0x5d6e

00005d6a <.Loc.174.3>:
    5d6a:	b0 12 10 66 	call	#26128		;#0x6610

00005d6e <.L7>:
    5d6e:	b0 12 de 62 	call	#25310		;#0x62de

00005d72 <.Loc.175.3>:
}
    5d72:	03 43       	nop			
    5d74:	b4 17       	popm	#12,	r15	;16-bit words
    5d76:	00 13       	reti			

00005d78 <ISR_USCI_A1_VECTOR>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A1_VECTOR) {
    5d78:	bf 15       	pushm	#12,	r15	;16-bit words

00005d7a <.LCFI9>:
    5d7a:	21 83       	decd	r1		;

00005d7c <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    5d7c:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5d80:	b0 12 46 63 	call	#25414		;#0x6346

00005d84 <.Loc.400.3>:

  switch (__even_in_range(UCA1IV, USCI_UART_UCTXCPTIFG)) {
    5d84:	1c 42 fe 05 	mov	&0x05fe,r12	;0x05fe
    5d88:	2c 92       	cmp	#4,	r12	;r2 As==10
    5d8a:	1e 24       	jz	$+62     	;abs 0x5dc8
    5d8c:	3c 92       	cmp	#8,	r12	;r2 As==11
    5d8e:	40 24       	jz	$+130    	;abs 0x5e10
    5d90:	2c 93       	cmp	#2,	r12	;r3 As==10
    5d92:	01 24       	jz	$+4      	;abs 0x5d96

00005d94 <.Loc.440.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    5d94:	60 3c       	jmp	$+194    	;abs 0x5e56

00005d96 <.L63>:
    if (UCA1STATW & UCRXERR)
    5d96:	5c 42 ea 05 	mov.b	&0x05ea,r12	;0x05ea
    5d9a:	6c f2       	and.b	#4,	r12	;r2 As==10
    5d9c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d9e:	06 24       	jz	$+14     	;abs 0x5dac

00005da0 <.Loc.405.3>:
      set_error(UCA1STATW, &SD1);
    5da0:	5c 42 ea 05 	mov.b	&0x05ea,r12	;0x05ea
    5da4:	3d 40 fe 51 	mov	#20990,	r13	;#0x51fe
    5da8:	b0 12 80 77 	call	#30592		;#0x7780

00005dac <.L64>:
    osalSysLockFromISR();
    5dac:	b0 12 b8 73 	call	#29624		;#0x73b8

00005db0 <.Loc.409.3>:
    sdIncomingDataI(&SD1, UCA1RXBUF);
    5db0:	1c 42 ec 05 	mov	&0x05ec,r12	;0x05ec
    5db4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5db8:	4d 4c       	mov.b	r12,	r13	;
    5dba:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    5dbe:	b0 12 90 72 	call	#29328		;#0x7290

00005dc2 <.Loc.410.3>:
    osalSysUnlockFromISR();
    5dc2:	b0 12 c4 73 	call	#29636		;#0x73c4

00005dc6 <.Loc.411.3>:
    break;
    5dc6:	47 3c       	jmp	$+144    	;abs 0x5e56

00005dc8 <.L61>:
    osalSysLockFromISR();
    5dc8:	b0 12 b8 73 	call	#29624		;#0x73b8

00005dcc <.Loc.417.3>:
    b = sdRequestDataI(&SD1);
    5dcc:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    5dd0:	b0 12 e2 72 	call	#29410		;#0x72e2
    5dd4:	81 4c 00 00 	mov	r12,	0(r1)	;

00005dd8 <.Loc.418.3>:
    if (b < Q_OK) {
    5dd8:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    5ddc:	13 34       	jge	$+40     	;abs 0x5e04

00005dde <.Loc.419.3>:
      chnAddFlagsI(&SD1, CHN_OUTPUT_EMPTY);
    5dde:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5de0:	4e 43       	clr.b	r14		;
    5de2:	3c 40 00 52 	mov	#20992,	r12	;#0x5200
    5de6:	b0 12 d0 73 	call	#29648		;#0x73d0

00005dea <.Loc.420.3>:
      UCA1IE = (UCA1IE & ~UCTXIE) | UCTXCPTIE;
    5dea:	1c 42 fa 05 	mov	&0x05fa,r12	;0x05fa
    5dee:	3c f0 f5 ff 	and	#-11,	r12	;#0xfff5
    5df2:	3c d2       	bis	#8,	r12	;r2 As==11
    5df4:	82 4c fa 05 	mov	r12,	&0x05fa	;

00005df8 <.Loc.421.3>:
      UCA1IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    5df8:	1c 42 fc 05 	mov	&0x05fc,r12	;0x05fc
    5dfc:	2c d3       	bis	#2,	r12	;r3 As==10
    5dfe:	82 4c fc 05 	mov	r12,	&0x05fc	;
    5e02:	03 3c       	jmp	$+8      	;abs 0x5e0a

00005e04 <.L66>:
      UCA1TXBUF = b;
    5e04:	2c 41       	mov	@r1,	r12	;
    5e06:	82 4c ee 05 	mov	r12,	&0x05ee	;

00005e0a <.L67>:
    osalSysUnlockFromISR();
    5e0a:	b0 12 c4 73 	call	#29636		;#0x73c4

00005e0e <.Loc.426.3>:
    break;
    5e0e:	23 3c       	jmp	$+72     	;abs 0x5e56

00005e10 <.L62>:
    osalSysLockFromISR();
    5e10:	b0 12 b8 73 	call	#29624		;#0x73b8

00005e14 <.Loc.432.3>:
    if (oqIsEmptyI(&SD1.oqueue))
    5e14:	1d 42 22 52 	mov	&0x5222,r13	;0x5222
    5e18:	1c 42 24 52 	mov	&0x5224,r12	;0x5224
    5e1c:	0d 9c       	cmp	r12,	r13	;
    5e1e:	06 20       	jnz	$+14     	;abs 0x5e2c

00005e20 <.Loc.432.3>:
    5e20:	1c 42 1c 52 	mov	&0x521c,r12	;0x521c
    5e24:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e26:	02 24       	jz	$+6      	;abs 0x5e2c

00005e28 <.Loc.432.3>:
    5e28:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5e2a:	01 3c       	jmp	$+4      	;abs 0x5e2e

00005e2c <.L68>:
    5e2c:	4c 43       	clr.b	r12		;

00005e2e <.L69>:
    5e2e:	5c f3       	and.b	#1,	r12	;r3 As==01
    5e30:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e34:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e36:	07 24       	jz	$+16     	;abs 0x5e46

00005e38 <.Loc.433.3>:
      chnAddFlagsI(&SD1, CHN_TRANSMISSION_END);
    5e38:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    5e3c:	4e 43       	clr.b	r14		;
    5e3e:	3c 40 00 52 	mov	#20992,	r12	;#0x5200
    5e42:	b0 12 d0 73 	call	#29648		;#0x73d0

00005e46 <.L70>:
    UCA1IE &= ~UCTXCPTIE;
    5e46:	1c 42 fa 05 	mov	&0x05fa,r12	;0x05fa
    5e4a:	3c c2       	bic	#8,	r12	;r2 As==11
    5e4c:	82 4c fa 05 	mov	r12,	&0x05fa	;

00005e50 <.Loc.435.3>:
    osalSysUnlockFromISR();
    5e50:	b0 12 c4 73 	call	#29636		;#0x73c4

00005e54 <.Loc.436.3>:
    break;
    5e54:	03 43       	nop			

00005e56 <.L65>:
  }

  OSAL_IRQ_EPILOGUE();
    5e56:	b0 12 74 63 	call	#25460		;#0x6374
    5e5a:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5e5e:	b0 12 be 62 	call	#25278		;#0x62be
    5e62:	b0 12 f4 65 	call	#26100		;#0x65f4
    5e66:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e6a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e6c:	02 24       	jz	$+6      	;abs 0x5e72

00005e6e <.Loc.443.3>:
    5e6e:	b0 12 10 66 	call	#26128		;#0x6610

00005e72 <.L71>:
    5e72:	b0 12 de 62 	call	#25310		;#0x62de

00005e76 <.Loc.444.3>:
}
    5e76:	03 43       	nop			
    5e78:	21 53       	incd	r1		;
    5e7a:	b4 17       	popm	#12,	r15	;16-bit words
    5e7c:	00 13       	reti			

00005e7e <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    5e7e:	bf 15       	pushm	#12,	r15	;16-bit words

00005e80 <.LCFI0>:
    5e80:	21 82       	sub	#4,	r1	;r2 As==10

00005e82 <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5e82:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5e86:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00005e88 <L0>:
    5e88:	46 63       	adc.b	r6		;

00005e8a <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    5e8a:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    5e8e:	12 c3       	clrc			
    5e90:	0c 10       	rrc	r12		;
    5e92:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5e96:	4d 4c       	mov.b	r12,	r13	;
    5e98:	7d 53       	add.b	#-1,	r13	;r3 As==11
    5e9a:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00005e9e <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    5e9e:	5c 41 03 00 	mov.b	3(r1),	r12	;
    5ea2:	0c 5c       	rla	r12		;
    5ea4:	3c 50 4a 52 	add	#21066,	r12	;#0x524a
    5ea8:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00005eac <.Loc.80.1>:
  if (cb != NULL) {
    5eac:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    5eb0:	02 24       	jz	$+6      	;abs 0x5eb6

00005eb2 <.Loc.81.1>:
    (*cb)();
    5eb2:	2c 41       	mov	@r1,	r12	;
    5eb4:	8c 12       	call	r12		;

00005eb6 <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5eb6:	b0 12 74 63 	call	#25460		;#0x6374
    5eba:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5ebe:	b0 12 be 62 	call	#25278		;#0x62be
    5ec2:	b0 12 f4 65 	call	#26100		;#0x65f4
    5ec6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5eca:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ecc:	02 24       	jz	$+6      	;abs 0x5ed2

00005ece <.Loc.84.1>:
    5ece:	b0 12 10 66 	call	#26128		;#0x6610

00005ed2 <.L3>:
    5ed2:	b0 12 de 62 	call	#25310		;#0x62de

00005ed6 <.Loc.85.1>:
}
    5ed6:	03 43       	nop			
    5ed8:	21 52       	add	#4,	r1	;r2 As==10
    5eda:	b4 17       	popm	#12,	r15	;16-bit words
    5edc:	00 13       	reti			

00005ede <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    5ede:	bf 15       	pushm	#12,	r15	;16-bit words

00005ee0 <.LCFI2>:
    5ee0:	21 82       	sub	#4,	r1	;r2 As==10

00005ee2 <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5ee2:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5ee6:	b0 12 46 63 	call	#25414		;#0x6346

00005eea <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    5eea:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    5eee:	12 c3       	clrc			
    5ef0:	0c 10       	rrc	r12		;
    5ef2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5ef6:	4d 4c       	mov.b	r12,	r13	;
    5ef8:	7d 53       	add.b	#-1,	r13	;r3 As==11
    5efa:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00005efe <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    5efe:	5c 41 03 00 	mov.b	3(r1),	r12	;
    5f02:	3c 52       	add	#8,	r12	;r2 As==11
    5f04:	0c 5c       	rla	r12		;
    5f06:	3c 50 4a 52 	add	#21066,	r12	;#0x524a
    5f0a:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00005f0e <.Loc.98.1>:
  if (cb != NULL) {
    5f0e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    5f12:	02 24       	jz	$+6      	;abs 0x5f18

00005f14 <.Loc.99.1>:
    (*cb)();
    5f14:	2c 41       	mov	@r1,	r12	;
    5f16:	8c 12       	call	r12		;

00005f18 <.L5>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5f18:	b0 12 74 63 	call	#25460		;#0x6374
    5f1c:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5f20:	b0 12 be 62 	call	#25278		;#0x62be
    5f24:	b0 12 f4 65 	call	#26100		;#0x65f4
    5f28:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5f2c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f2e:	02 24       	jz	$+6      	;abs 0x5f34

00005f30 <.Loc.102.1>:
    5f30:	b0 12 10 66 	call	#26128		;#0x6610

00005f34 <.L6>:
    5f34:	b0 12 de 62 	call	#25310		;#0x62de

00005f38 <.Loc.103.1>:
}
    5f38:	03 43       	nop			
    5f3a:	21 52       	add	#4,	r1	;r2 As==10
    5f3c:	b4 17       	popm	#12,	r15	;16-bit words
    5f3e:	00 13       	reti			

00005f40 <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    5f40:	bf 15       	pushm	#12,	r15	;16-bit words

00005f42 <.LCFI4>:
    5f42:	21 82       	sub	#4,	r1	;r2 As==10

00005f44 <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5f44:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5f48:	b0 12 46 63 	call	#25414		;#0x6346

00005f4c <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    5f4c:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    5f50:	12 c3       	clrc			
    5f52:	0c 10       	rrc	r12		;
    5f54:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5f58:	4d 4c       	mov.b	r12,	r13	;
    5f5a:	7d 53       	add.b	#-1,	r13	;r3 As==11
    5f5c:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00005f60 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    5f60:	5c 41 03 00 	mov.b	3(r1),	r12	;
    5f64:	3c 50 10 00 	add	#16,	r12	;#0x0010
    5f68:	0c 5c       	rla	r12		;
    5f6a:	3c 50 4a 52 	add	#21066,	r12	;#0x524a
    5f6e:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00005f72 <.Loc.117.1>:
  if (cb != NULL) {
    5f72:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    5f76:	02 24       	jz	$+6      	;abs 0x5f7c

00005f78 <.Loc.118.1>:
    (*cb)();
    5f78:	2c 41       	mov	@r1,	r12	;
    5f7a:	8c 12       	call	r12		;

00005f7c <.L8>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5f7c:	b0 12 74 63 	call	#25460		;#0x6374
    5f80:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5f84:	b0 12 be 62 	call	#25278		;#0x62be
    5f88:	b0 12 f4 65 	call	#26100		;#0x65f4
    5f8c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5f90:	0c 93       	cmp	#0,	r12	;r3 As==00
    5f92:	02 24       	jz	$+6      	;abs 0x5f98

00005f94 <.Loc.121.1>:
    5f94:	b0 12 10 66 	call	#26128		;#0x6610

00005f98 <.L9>:
    5f98:	b0 12 de 62 	call	#25310		;#0x62de

00005f9c <.Loc.122.1>:
}
    5f9c:	03 43       	nop			
    5f9e:	21 52       	add	#4,	r1	;r2 As==10
    5fa0:	b4 17       	popm	#12,	r15	;16-bit words
    5fa2:	00 13       	reti			

00005fa4 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    5fa4:	bf 15       	pushm	#12,	r15	;16-bit words

00005fa6 <.LCFI6>:
    5fa6:	21 82       	sub	#4,	r1	;r2 As==10

00005fa8 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    5fa8:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    5fac:	b0 12 46 63 	call	#25414		;#0x6346

00005fb0 <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    5fb0:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    5fb4:	12 c3       	clrc			
    5fb6:	0c 10       	rrc	r12		;
    5fb8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5fbc:	4d 4c       	mov.b	r12,	r13	;
    5fbe:	7d 53       	add.b	#-1,	r13	;r3 As==11
    5fc0:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00005fc4 <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    5fc4:	5c 41 03 00 	mov.b	3(r1),	r12	;
    5fc8:	3c 50 18 00 	add	#24,	r12	;#0x0018
    5fcc:	0c 5c       	rla	r12		;
    5fce:	3c 50 4a 52 	add	#21066,	r12	;#0x524a
    5fd2:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00005fd6 <.Loc.135.1>:
  if (cb != NULL) {
    5fd6:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    5fda:	02 24       	jz	$+6      	;abs 0x5fe0

00005fdc <.Loc.136.1>:
    (*cb)();
    5fdc:	2c 41       	mov	@r1,	r12	;
    5fde:	8c 12       	call	r12		;

00005fe0 <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    5fe0:	b0 12 74 63 	call	#25460		;#0x6374
    5fe4:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    5fe8:	b0 12 be 62 	call	#25278		;#0x62be
    5fec:	b0 12 f4 65 	call	#26100		;#0x65f4
    5ff0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5ff4:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ff6:	02 24       	jz	$+6      	;abs 0x5ffc

00005ff8 <.Loc.139.1>:
    5ff8:	b0 12 10 66 	call	#26128		;#0x6610

00005ffc <.L12>:
    5ffc:	b0 12 de 62 	call	#25310		;#0x62de

00006000 <.Loc.140.1>:
}
    6000:	03 43       	nop			
    6002:	21 52       	add	#4,	r1	;r2 As==10
    6004:	b4 17       	popm	#12,	r15	;16-bit words
    6006:	00 13       	reti			

00006008 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    6008:	bf 15       	pushm	#12,	r15	;16-bit words

0000600a <.LCFI5>:
    600a:	21 82       	sub	#4,	r1	;r2 As==10

0000600c <.LCFI6>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    600c:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    6010:	b0 12 46 63 	call	#25414		;#0x6346

00006014 <.Loc.75.3>:

  index = (DMAIV >> 1) - 1;
    6014:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    6018:	12 c3       	clrc			
    601a:	0c 10       	rrc	r12		;
    601c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6020:	4d 4c       	mov.b	r12,	r13	;
    6022:	7d 53       	add.b	#-1,	r13	;r3 As==11
    6024:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00006028 <.Loc.77.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    6028:	6c 43       	mov.b	#2,	r12	;r3 As==10
    602a:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    602e:	3e 28       	jnc	$+126    	;abs 0x60ac

00006030 <.LBB2>:
    /* Set to idle mode (but still claimed) */
    dma_regs[index].ctl &= ~DMAEN;
    6030:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    6034:	5c 41 03 00 	mov.b	3(r1),	r12	;
    6038:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    603c:	0d 5c       	add	r12,	r13	;
    603e:	3e 40 10 05 	mov	#1296,	r14	;#0x0510
    6042:	5c 41 03 00 	mov.b	3(r1),	r12	;
    6046:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    604a:	0c 5e       	add	r14,	r12	;
    604c:	2c 4c       	mov	@r12,	r12	;
    604e:	3c f0 ef ff 	and	#-17,	r12	;#0xffef
    6052:	8d 4c 00 00 	mov	r12,	0(r13)	;

00006056 <.Loc.80.3>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    6056:	4d 43       	clr.b	r13		;
    6058:	5c 41 03 00 	mov.b	3(r1),	r12	;
    605c:	b0 12 64 7a 	call	#31332		;#0x7a64

00006060 <.Loc.81.3>:
    dma_regs[index].sz  = 0;
    6060:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    6064:	5c 41 03 00 	mov.b	3(r1),	r12	;
    6068:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    606c:	0c 5d       	add	r13,	r12	;
    606e:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00006072 <.Loc.82.3>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    6072:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    6076:	5c 41 03 00 	mov.b	3(r1),	r12	;
    607a:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    607e:	0c 5d       	add	r13,	r12	;
    6080:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    6084:	00 00 

00006086 <.Loc.84.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    6086:	5c 41 03 00 	mov.b	3(r1),	r12	;
    608a:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    608e:	0d 4c       	mov	r12,	r13	;
    6090:	3d 50 e8 5c 	add	#23784,	r13	;#0x5ce8
    6094:	81 4d 00 00 	mov	r13,	0(r1)	;

00006098 <.Loc.87.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    6098:	2c 41       	mov	@r1,	r12	;
    609a:	2c 4c       	mov	@r12,	r12	;
    609c:	0c 93       	cmp	#0,	r12	;r3 As==00
    609e:	06 24       	jz	$+14     	;abs 0x60ac

000060a0 <.Loc.88.3>:
      cb->callback(cb->args);
    60a0:	2c 41       	mov	@r1,	r12	;
    60a2:	2d 4c       	mov	@r12,	r13	;
    60a4:	2c 41       	mov	@r1,	r12	;
    60a6:	1c 4c 02 00 	mov	2(r12),	r12	;
    60aa:	8d 12       	call	r13		;

000060ac <.L13>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    60ac:	b0 12 74 63 	call	#25460		;#0x6374
    60b0:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    60b4:	b0 12 be 62 	call	#25278		;#0x62be
    60b8:	b0 12 f4 65 	call	#26100		;#0x65f4
    60bc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    60c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    60c2:	02 24       	jz	$+6      	;abs 0x60c8

000060c4 <.Loc.92.3>:
    60c4:	b0 12 10 66 	call	#26128		;#0x6610

000060c8 <.L14>:
    60c8:	b0 12 de 62 	call	#25310		;#0x62de

000060cc <.Loc.93.3>:
}
    60cc:	03 43       	nop			
    60ce:	21 52       	add	#4,	r1	;r2 As==10
    60d0:	b4 17       	popm	#12,	r15	;16-bit words
    60d2:	00 13       	reti			

000060d4 <ISR_ADC12_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(ADC12_VECTOR) {
    60d4:	bf 15       	pushm	#12,	r15	;16-bit words

000060d6 <.LCFI5>:

  OSAL_IRQ_PROLOGUE();
    60d6:	d2 43 fc 51 	mov.b	#1,	&0x51fc	;r3 As==01
    60da:	b0 12 46 63 	call	#25414		;#0x6346

000060de <.Loc.125.3>:

  switch (__even_in_range(ADC12IV, ADC12IV_ADC12TOVIFG)) {
    60de:	1c 42 18 08 	mov	&0x0818,r12	;0x0818
    60e2:	2c 93       	cmp	#2,	r12	;r3 As==10
    60e4:	03 24       	jz	$+8      	;abs 0x60ec
    60e6:	2c 92       	cmp	#4,	r12	;r2 As==10
    60e8:	32 24       	jz	$+102    	;abs 0x614e
    60ea:	62 3c       	jmp	$+198    	;abs 0x61b0

000060ec <.L30>:

  case ADC12IV_ADC12OVIFG: {
    if (ADCD1.grpp == NULL)
    60ec:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    60f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    60f2:	8b 24       	jz	$+280    	;abs 0x620a

000060f4 <.Loc.130.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    60f4:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    60f8:	b0 12 9c 84 	call	#-31588	;#0x849c
    60fc:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    6100:	1c 4c 04 00 	mov	4(r12),	r12	;
    6104:	0c 93       	cmp	#0,	r12	;r3 As==00
    6106:	15 24       	jz	$+44     	;abs 0x6132

00006108 <.Loc.130.3>:
    6108:	f2 40 05 00 	mov.b	#5,	&0x52fe	;
    610c:	fe 52 
    610e:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    6112:	1e 4c 04 00 	mov	4(r12),	r14	;
    6116:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6118:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    611c:	8e 12       	call	r14		;
    611e:	5c 42 fe 52 	mov.b	&0x52fe,r12	;0x52fe
    6122:	7c 90 05 00 	cmp.b	#5,	r12	;
    6126:	02 20       	jnz	$+6      	;abs 0x612c

00006128 <.Loc.130.3>:
    6128:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10

0000612c <.L35>:
    612c:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00
    6130:	04 3c       	jmp	$+10     	;abs 0x613a

00006132 <.L34>:
    6132:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10
    6136:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00

0000613a <.L36>:
    613a:	b0 12 36 7f 	call	#32566		;#0x7f36
    613e:	3d 43       	mov	#-1,	r13	;r3 As==11
    6140:	3c 40 08 53 	mov	#21256,	r12	;#0x5308
    6144:	b0 12 4e 7f 	call	#32590		;#0x7f4e
    6148:	b0 12 42 7f 	call	#32578		;#0x7f42

0000614c <.Loc.131.3>:
    break;
    614c:	61 3c       	jmp	$+196    	;abs 0x6210

0000614e <.L31>:
  }
  case ADC12IV_ADC12TOVIFG: {
    if (ADCD1.grpp == NULL)
    614e:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    6152:	0c 93       	cmp	#0,	r12	;r3 As==00
    6154:	5c 24       	jz	$+186    	;abs 0x620e

00006156 <.Loc.136.3>:
      break;
    _adc_isr_error_code(&ADCD1, ADC_ERR_AWD);
    6156:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    615a:	b0 12 9c 84 	call	#-31588	;#0x849c
    615e:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    6162:	1c 4c 04 00 	mov	4(r12),	r12	;
    6166:	0c 93       	cmp	#0,	r12	;r3 As==00
    6168:	15 24       	jz	$+44     	;abs 0x6194

0000616a <.Loc.136.3>:
    616a:	f2 40 05 00 	mov.b	#5,	&0x52fe	;
    616e:	fe 52 
    6170:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    6174:	1e 4c 04 00 	mov	4(r12),	r14	;
    6178:	6d 43       	mov.b	#2,	r13	;r3 As==10
    617a:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    617e:	8e 12       	call	r14		;
    6180:	5c 42 fe 52 	mov.b	&0x52fe,r12	;0x52fe
    6184:	7c 90 05 00 	cmp.b	#5,	r12	;
    6188:	02 20       	jnz	$+6      	;abs 0x618e

0000618a <.Loc.136.3>:
    618a:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10

0000618e <.L39>:
    618e:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00
    6192:	04 3c       	jmp	$+10     	;abs 0x619c

00006194 <.L38>:
    6194:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10
    6198:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00

0000619c <.L40>:
    619c:	b0 12 36 7f 	call	#32566		;#0x7f36
    61a0:	3d 43       	mov	#-1,	r13	;r3 As==11
    61a2:	3c 40 08 53 	mov	#21256,	r12	;#0x5308
    61a6:	b0 12 4e 7f 	call	#32590		;#0x7f4e
    61aa:	b0 12 42 7f 	call	#32578		;#0x7f42

000061ae <.Loc.137.3>:
    break;
    61ae:	30 3c       	jmp	$+98     	;abs 0x6210

000061b0 <.L45>:
  }
  default:
    osalDbgAssert(false, "unhandled ADC exception");
    _adc_isr_error_code(&ADCD1, ADC_ERR_UNKNOWN);
    61b0:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    61b4:	b0 12 9c 84 	call	#-31588	;#0x849c
    61b8:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    61bc:	1c 4c 04 00 	mov	4(r12),	r12	;
    61c0:	0c 93       	cmp	#0,	r12	;r3 As==00
    61c2:	15 24       	jz	$+44     	;abs 0x61ee

000061c4 <.Loc.141.3>:
    61c4:	f2 40 05 00 	mov.b	#5,	&0x52fe	;
    61c8:	fe 52 
    61ca:	1c 42 06 53 	mov	&0x5306,r12	;0x5306
    61ce:	1e 4c 04 00 	mov	4(r12),	r14	;
    61d2:	4d 43       	clr.b	r13		;
    61d4:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    61d8:	8e 12       	call	r14		;
    61da:	5c 42 fe 52 	mov.b	&0x52fe,r12	;0x52fe
    61de:	7c 90 05 00 	cmp.b	#5,	r12	;
    61e2:	02 20       	jnz	$+6      	;abs 0x61e8

000061e4 <.Loc.141.3>:
    61e4:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10

000061e8 <.L42>:
    61e8:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00
    61ec:	04 3c       	jmp	$+10     	;abs 0x61f6

000061ee <.L41>:
    61ee:	e2 43 fe 52 	mov.b	#2,	&0x52fe	;r3 As==10
    61f2:	82 43 06 53 	mov	#0,	&0x5306	;r3 As==00

000061f6 <.L43>:
    61f6:	b0 12 36 7f 	call	#32566		;#0x7f36
    61fa:	3d 43       	mov	#-1,	r13	;r3 As==11
    61fc:	3c 40 08 53 	mov	#21256,	r12	;#0x5308
    6200:	b0 12 4e 7f 	call	#32590		;#0x7f4e
    6204:	b0 12 42 7f 	call	#32578		;#0x7f42
    6208:	03 3c       	jmp	$+8      	;abs 0x6210

0000620a <.L46>:
      break;
    620a:	03 43       	nop			
    620c:	01 3c       	jmp	$+4      	;abs 0x6210

0000620e <.L47>:
      break;
    620e:	03 43       	nop			

00006210 <.L33>:
  }

  OSAL_IRQ_EPILOGUE();
    6210:	b0 12 74 63 	call	#25460		;#0x6374
    6214:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00
    6218:	b0 12 be 62 	call	#25278		;#0x62be
    621c:	b0 12 f4 65 	call	#26100		;#0x65f4
    6220:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6224:	0c 93       	cmp	#0,	r12	;r3 As==00
    6226:	02 24       	jz	$+6      	;abs 0x622c

00006228 <.Loc.144.3>:
    6228:	b0 12 10 66 	call	#26128		;#0x6610

0000622c <.L44>:
    622c:	b0 12 de 62 	call	#25310		;#0x62de

00006230 <.Loc.145.3>:
}
    6230:	03 43       	nop			
    6232:	b4 17       	popm	#12,	r15	;16-bit words
    6234:	00 13       	reti			

00006236 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    6236:	c2 43 fc 51 	mov.b	#0,	&0x51fc	;r3 As==00

0000623a <.Loc.305.1>:
}
    623a:	03 43       	nop			
    623c:	30 41       	ret			

0000623e <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
    623e:	21 83       	decd	r1		;

00006240 <.LBB2>:

  return __get_SR_register();
    6240:	0c 42       	mov	r2,	r12	;
    6242:	81 4c 00 00 	mov	r12,	0(r1)	;

00006246 <L0>:
    6246:	2c 41       	mov	@r1,	r12	;

00006248 <.LBE2>:
}
    6248:	21 53       	incd	r1		;
    624a:	30 41       	ret			

0000624c <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
    624c:	21 83       	decd	r1		;

0000624e <.LCFI1>:
    624e:	81 4c 00 00 	mov	r12,	0(r1)	;

00006252 <.Loc.328.1>:

  return sts & GIE;
    6252:	2c 41       	mov	@r1,	r12	;
    6254:	7c f2       	and.b	#8,	r12	;r2 As==11
    6256:	0d 43       	clr	r13		;
    6258:	0d 8c       	sub	r12,	r13	;
    625a:	0c dd       	bis	r13,	r12	;
    625c:	5c 03       	rrum	#1,	r12	;
    625e:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    6262:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006266 <.Loc.329.1>:
}
    6266:	21 53       	incd	r1		;
    6268:	30 41       	ret			

0000626a <port_is_isr_context>:
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
  return __msp430x_in_isr;
    626a:	5c 42 fc 51 	mov.b	&0x51fc,r12	;0x51fc

0000626e <.Loc.340.1>:
}
    626e:	30 41       	ret			

00006270 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6270:	32 c2       	dint			
    6272:	03 43       	nop			

00006274 <.Loc.348.1>:
  asm volatile("nop");
    6274:	03 43       	nop			

00006276 <.Loc.349.1>:
}
    6276:	03 43       	nop			
    6278:	30 41       	ret			

0000627a <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    627a:	03 43       	nop			

0000627c <.Loc.356.1>:
  _enable_interrupts();
    627c:	03 43       	nop			
    627e:	32 d2       	eint			
    6280:	03 43       	nop			

00006282 <.Loc.357.1>:
}
    6282:	03 43       	nop			
    6284:	30 41       	ret			

00006286 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6286:	03 43       	nop			
    6288:	30 41       	ret			

0000628a <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    628a:	03 43       	nop			
    628c:	30 41       	ret			

0000628e <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    628e:	32 c2       	dint			
    6290:	03 43       	nop			

00006292 <.Loc.381.1>:
  asm volatile("nop");
    6292:	03 43       	nop			

00006294 <.Loc.382.1>:
}
    6294:	03 43       	nop			
    6296:	30 41       	ret			

00006298 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    6298:	32 c2       	dint			
    629a:	03 43       	nop			

0000629c <.Loc.390.1>:
  asm volatile("nop");
    629c:	03 43       	nop			

0000629e <.Loc.391.1>:
}
    629e:	03 43       	nop			
    62a0:	30 41       	ret			

000062a2 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    62a2:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    62a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    62a8:	04 20       	jnz	$+10     	;abs 0x62b2

000062aa <.Loc.79.2>:
    62aa:	1c 42 d8 51 	mov	&0x51d8,r12	;0x51d8
    62ae:	0c 93       	cmp	#0,	r12	;r3 As==00
    62b0:	04 24       	jz	$+10     	;abs 0x62ba

000062b2 <.L19>:
    chSysHalt("SV#2");
    62b2:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    62b6:	b0 12 a0 64 	call	#25760		;#0x64a0

000062ba <.L21>:
  }
}
    62ba:	03 43       	nop			
    62bc:	30 41       	ret			

000062be <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    62be:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    62c2:	0c 93       	cmp	#0,	r12	;r3 As==00
    62c4:	04 20       	jnz	$+10     	;abs 0x62ce

000062c6 <.Loc.103.2>:
    62c6:	1c 42 d8 51 	mov	&0x51d8,r12	;0x51d8
    62ca:	0c 93       	cmp	#0,	r12	;r3 As==00
    62cc:	04 24       	jz	$+10     	;abs 0x62d6

000062ce <.L27>:
    chSysHalt("SV#4");
    62ce:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    62d2:	b0 12 a0 64 	call	#25760		;#0x64a0

000062d6 <.L28>:
  }
  _dbg_enter_lock();
    62d6:	92 43 d8 51 	mov	#1,	&0x51d8	;r3 As==01

000062da <.Loc.107.2>:
}
    62da:	03 43       	nop			
    62dc:	30 41       	ret			

000062de <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    62de:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    62e2:	0c 93       	cmp	#0,	r12	;r3 As==00
    62e4:	05 20       	jnz	$+12     	;abs 0x62f0

000062e6 <.Loc.116.2>:
    62e6:	1d 42 d8 51 	mov	&0x51d8,r13	;0x51d8
    62ea:	4c 43       	clr.b	r12		;
    62ec:	0c 9d       	cmp	r13,	r12	;
    62ee:	04 38       	jl	$+10     	;abs 0x62f8

000062f0 <.L30>:
    chSysHalt("SV#5");
    62f0:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    62f4:	b0 12 a0 64 	call	#25760		;#0x64a0

000062f8 <.L31>:
  }
  _dbg_leave_lock();
    62f8:	82 43 d8 51 	mov	#0,	&0x51d8	;r3 As==00

000062fc <.Loc.120.2>:
}
    62fc:	03 43       	nop			
    62fe:	30 41       	ret			

00006300 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6300:	1d 42 d6 51 	mov	&0x51d6,r13	;0x51d6
    6304:	4c 43       	clr.b	r12		;
    6306:	0c 9d       	cmp	r13,	r12	;
    6308:	04 34       	jge	$+10     	;abs 0x6312

0000630a <.Loc.129.2>:
    630a:	1c 42 d8 51 	mov	&0x51d8,r12	;0x51d8
    630e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6310:	04 24       	jz	$+10     	;abs 0x631a

00006312 <.L33>:
    chSysHalt("SV#6");
    6312:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    6316:	b0 12 a0 64 	call	#25760		;#0x64a0

0000631a <.L34>:
  }
  _dbg_enter_lock();
    631a:	92 43 d8 51 	mov	#1,	&0x51d8	;r3 As==01

0000631e <.Loc.133.2>:
}
    631e:	03 43       	nop			
    6320:	30 41       	ret			

00006322 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    6322:	1d 42 d6 51 	mov	&0x51d6,r13	;0x51d6
    6326:	4c 43       	clr.b	r12		;
    6328:	0c 9d       	cmp	r13,	r12	;
    632a:	05 34       	jge	$+12     	;abs 0x6336

0000632c <.Loc.142.2>:
    632c:	1d 42 d8 51 	mov	&0x51d8,r13	;0x51d8
    6330:	4c 43       	clr.b	r12		;
    6332:	0c 9d       	cmp	r13,	r12	;
    6334:	04 38       	jl	$+10     	;abs 0x633e

00006336 <.L36>:
    chSysHalt("SV#7");
    6336:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    633a:	b0 12 a0 64 	call	#25760		;#0x64a0

0000633e <.L37>:
  }
  _dbg_leave_lock();
    633e:	82 43 d8 51 	mov	#0,	&0x51d8	;r3 As==00

00006342 <.Loc.146.2>:
}
    6342:	03 43       	nop			
    6344:	30 41       	ret			

00006346 <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    6346:	b0 12 86 62 	call	#25222		;#0x6286

0000634a <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    634a:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    634e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6350:	04 38       	jl	$+10     	;abs 0x635a

00006352 <.Loc.156.2>:
    6352:	1c 42 d8 51 	mov	&0x51d8,r12	;0x51d8
    6356:	0c 93       	cmp	#0,	r12	;r3 As==00
    6358:	04 24       	jz	$+10     	;abs 0x6362

0000635a <.L39>:
    chSysHalt("SV#8");
    635a:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    635e:	b0 12 a0 64 	call	#25760		;#0x64a0

00006362 <.L40>:
  }
  nil.isr_cnt++;
    6362:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    6366:	1c 53       	inc	r12		;
    6368:	82 4c d6 51 	mov	r12,	&0x51d6	;

0000636c <.Loc.160.2>:
  port_unlock_from_isr();
    636c:	b0 12 8a 62 	call	#25226		;#0x628a

00006370 <.Loc.161.2>:
}
    6370:	03 43       	nop			
    6372:	30 41       	ret			

00006374 <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    6374:	b0 12 86 62 	call	#25222		;#0x6286

00006378 <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    6378:	1d 42 d6 51 	mov	&0x51d6,r13	;0x51d6
    637c:	4c 43       	clr.b	r12		;
    637e:	0c 9d       	cmp	r13,	r12	;
    6380:	04 34       	jge	$+10     	;abs 0x638a

00006382 <.Loc.171.2>:
    6382:	1c 42 d8 51 	mov	&0x51d8,r12	;0x51d8
    6386:	0c 93       	cmp	#0,	r12	;r3 As==00
    6388:	04 24       	jz	$+10     	;abs 0x6392

0000638a <.L42>:
    chSysHalt("SV#9");
    638a:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    638e:	b0 12 a0 64 	call	#25760		;#0x64a0

00006392 <.L43>:
  }
  nil.isr_cnt--;
    6392:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    6396:	3c 53       	add	#-1,	r12	;r3 As==11
    6398:	82 4c d6 51 	mov	r12,	&0x51d6	;

0000639c <.Loc.175.2>:
  port_unlock_from_isr();
    639c:	b0 12 8a 62 	call	#25226		;#0x628a

000063a0 <.Loc.176.2>:
}
    63a0:	03 43       	nop			
    63a2:	30 41       	ret			

000063a4 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    63a4:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    63a8:	0c 93       	cmp	#0,	r12	;r3 As==00
    63aa:	05 38       	jl	$+12     	;abs 0x63b6

000063ac <.Loc.188.2>:
    63ac:	1d 42 d8 51 	mov	&0x51d8,r13	;0x51d8
    63b0:	4c 43       	clr.b	r12		;
    63b2:	0c 9d       	cmp	r13,	r12	;
    63b4:	04 38       	jl	$+10     	;abs 0x63be

000063b6 <.L45>:
    chSysHalt("SV#10");
    63b6:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    63ba:	b0 12 a0 64 	call	#25760		;#0x64a0

000063be <.L47>:
  }
}
    63be:	03 43       	nop			
    63c0:	30 41       	ret			

000063c2 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    63c2:	1c 42 d6 51 	mov	&0x51d6,r12	;0x51d6
    63c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    63c8:	05 20       	jnz	$+12     	;abs 0x63d4

000063ca <.Loc.203.2>:
    63ca:	1d 42 d8 51 	mov	&0x51d8,r13	;0x51d8
    63ce:	4c 43       	clr.b	r12		;
    63d0:	0c 9d       	cmp	r13,	r12	;
    63d2:	04 38       	jl	$+10     	;abs 0x63dc

000063d4 <.L49>:
    chSysHalt("SV#11");
    63d4:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    63d8:	b0 12 a0 64 	call	#25760		;#0x64a0

000063dc <.L51>:
  }
}
    63dc:	03 43       	nop			
    63de:	30 41       	ret			

000063e0 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
__attribute__((optimize(0))) void chSysInit(void) {
    63e0:	21 82       	sub	#4,	r1	;r2 As==10

000063e2 <.LCFI2>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    63e2:	82 43 d6 51 	mov	#0,	&0x51d6	;r3 As==00

000063e6 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    63e6:	82 43 d8 51 	mov	#0,	&0x51d8	;r3 As==00

000063ea <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    63ea:	b1 40 dc 51 	mov	#20956,	2(r1)	;#0x51dc
    63ee:	02 00 

000063f0 <.Loc.234.2>:
  tcp = nil_thd_configs;
    63f0:	b1 40 18 51 	mov	#20760,	0(r1)	;#0x5118
    63f4:	00 00 

000063f6 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    63f6:	2d 3c       	jmp	$+92     	;abs 0x6452

000063f8 <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    63f8:	2c 41       	mov	@r1,	r12	;
    63fa:	2d 4c       	mov	@r12,	r13	;
    63fc:	1c 41 02 00 	mov	2(r1),	r12	;
    6400:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00006404 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    6404:	2c 41       	mov	@r1,	r12	;
    6406:	1c 4c 02 00 	mov	2(r12),	r12	;
    640a:	0d 4c       	mov	r12,	r13	;
    640c:	3d 50 f0 ff 	add	#-16,	r13	;#0xfff0
    6410:	1c 41 02 00 	mov	2(r1),	r12	;
    6414:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6418:	1c 41 02 00 	mov	2(r1),	r12	;
    641c:	2c 4c       	mov	@r12,	r12	;
    641e:	2d 41       	mov	@r1,	r13	;
    6420:	1d 4d 06 00 	mov	6(r13),	r13	;
    6424:	8c 4d 00 00 	mov	r13,	0(r12)	;
    6428:	1c 41 02 00 	mov	2(r1),	r12	;
    642c:	2c 4c       	mov	@r12,	r12	;
    642e:	2d 41       	mov	@r1,	r13	;
    6430:	1d 4d 08 00 	mov	8(r13),	r13	;
    6434:	8c 4d 02 00 	mov	r13,	2(r12)	;
    6438:	1c 41 02 00 	mov	2(r1),	r12	;
    643c:	2c 4c       	mov	@r12,	r12	;
    643e:	3d 40 4e 68 	mov	#26702,	r13	;#0x684e
    6442:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00006446 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    6446:	b1 50 10 00 	add	#16,	2(r1)	;#0x0010
    644a:	02 00 

0000644c <.Loc.247.2>:
    tcp++;
    644c:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    6450:	00 00 

00006452 <.L53>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    6452:	b1 90 ec 51 	cmp	#20972,	2(r1)	;#0x51ec
    6456:	02 00 
    6458:	cf 2b       	jnc	$-96     	;abs 0x63f8

0000645a <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    645a:	1c 41 02 00 	mov	2(r1),	r12	;
    645e:	bc 40 00 44 	mov	#17408,	14(r12)	;#0x4400, 0x000e
    6462:	0e 00 

00006464 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    6464:	b0 12 98 62 	call	#25240		;#0x6298
    6468:	b0 12 a2 62 	call	#25250		;#0x62a2

0000646c <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    646c:	92 43 d8 51 	mov	#1,	&0x51d8	;r3 As==01

00006470 <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    6470:	b0 12 1e 68 	call	#26654		;#0x681e

00006474 <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    6474:	b0 12 36 62 	call	#25142		;#0x6236

00006478 <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    6478:	b2 40 dc 51 	mov	#20956,	&0x51d2	;#0x51dc
    647c:	d2 51 
    647e:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    6482:	82 4c d0 51 	mov	r12,	&0x51d0	;

00006486 <.Loc.275.2>:
  port_switch(nil.current, tp);
    6486:	1c 42 d0 51 	mov	&0x51d0,r12	;0x51d0
    648a:	1d 41 02 00 	mov	2(r1),	r13	;
    648e:	b0 12 40 68 	call	#26688		;#0x6840

00006492 <.Loc.276.2>:
  chSysUnlock();
    6492:	b0 12 de 62 	call	#25310		;#0x62de
    6496:	b0 12 7a 62 	call	#25210		;#0x627a

0000649a <.Loc.277.2>:
}
    649a:	03 43       	nop			
    649c:	21 52       	add	#4,	r1	;r2 As==10
    649e:	30 41       	ret			

000064a0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    64a0:	21 83       	decd	r1		;

000064a2 <L0>:
    64a2:	81 4c 00 00 	mov	r12,	0(r1)	;

000064a6 <.Loc.293.2>:

  port_disable();
    64a6:	b0 12 8e 62 	call	#25230		;#0x628e

000064aa <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    64aa:	a2 41 da 51 	mov	@r1,	&0x51da	;

000064ae <.L56>:

  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    64ae:	ff 3f       	jmp	$+0      	;abs 0x64ae

000064b0 <chSysTimerHandlerI>:
    64b0:	21 83       	decd	r1		;

000064b2 <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    64b2:	b0 12 a4 63 	call	#25508		;#0x63a4

000064b6 <.Loc.321.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    64b6:	b1 40 dc 51 	mov	#20956,	0(r1)	;#0x51dc
    64ba:	00 00 

000064bc <.Loc.322.2>:
  nil.systime++;
    64bc:	1c 42 d4 51 	mov	&0x51d4,r12	;0x51d4
    64c0:	1c 53       	inc	r12		;
    64c2:	82 4c d4 51 	mov	r12,	&0x51d4	;

000064c6 <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    64c6:	2c 41       	mov	@r1,	r12	;
    64c8:	1c 4c 08 00 	mov	8(r12),	r12	;
    64cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    64ce:	25 24       	jz	$+76     	;abs 0x651a

000064d0 <.Loc.330.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    64d0:	2c 41       	mov	@r1,	r12	;
    64d2:	1c 4c 08 00 	mov	8(r12),	r12	;
    64d6:	3c 53       	add	#-1,	r12	;r3 As==11
    64d8:	2d 41       	mov	@r1,	r13	;
    64da:	8d 4c 08 00 	mov	r12,	8(r13)	;
    64de:	0c 93       	cmp	#0,	r12	;r3 As==00
    64e0:	1c 20       	jnz	$+58     	;abs 0x651a

000064e2 <.Loc.334.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    64e2:	2c 41       	mov	@r1,	r12	;
    64e4:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    64e8:	7c 90 03 00 	cmp.b	#3,	r12	;
    64ec:	08 20       	jnz	$+18     	;abs 0x64fe

000064ee <.Loc.335.2>:
          tp->u1.semp->cnt++;
    64ee:	2c 41       	mov	@r1,	r12	;
    64f0:	1c 4c 04 00 	mov	4(r12),	r12	;
    64f4:	2d 4c       	mov	@r12,	r13	;
    64f6:	1d 53       	inc	r13		;
    64f8:	8c 4d 00 00 	mov	r13,	0(r12)	;
    64fc:	0a 3c       	jmp	$+22     	;abs 0x6512

000064fe <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    64fe:	2c 41       	mov	@r1,	r12	;
    6500:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    6504:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    6506:	05 20       	jnz	$+12     	;abs 0x6512

00006508 <.Loc.338.2>:
          *tp->u1.trp = NULL;
    6508:	2c 41       	mov	@r1,	r12	;
    650a:	1c 4c 04 00 	mov	4(r12),	r12	;
    650e:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006512 <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    6512:	3d 43       	mov	#-1,	r13	;r3 As==11
    6514:	2c 41       	mov	@r1,	r12	;
    6516:	b0 12 b6 65 	call	#26038		;#0x65b6

0000651a <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    651a:	b0 12 22 63 	call	#25378		;#0x6322
    651e:	b0 12 8a 62 	call	#25226		;#0x628a

00006522 <.Loc.347.2>:
    tp++;
    6522:	b1 50 10 00 	add	#16,	0(r1)	;#0x0010
    6526:	00 00 

00006528 <.Loc.348.2>:
    chSysLockFromISR();
    6528:	b0 12 86 62 	call	#25222		;#0x6286
    652c:	b0 12 00 63 	call	#25344		;#0x6300

00006530 <.Loc.349.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    6530:	b1 90 ec 51 	cmp	#20972,	0(r1)	;#0x51ec
    6534:	00 00 
    6536:	c7 2b       	jnc	$-112    	;abs 0x64c6

00006538 <.Loc.403.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    6538:	03 43       	nop			
    653a:	21 53       	incd	r1		;
    653c:	30 41       	ret			

0000653e <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {
    653e:	21 83       	decd	r1		;

00006540 <L0>:

  syssts_t sts = port_get_irq_status();
    6540:	b0 12 3e 62 	call	#25150		;#0x623e
    6544:	81 4c 00 00 	mov	r12,	0(r1)	;

00006548 <.Loc.449.2>:
  if (port_irq_enabled(sts)) {
    6548:	2c 41       	mov	@r1,	r12	;
    654a:	b0 12 4c 62 	call	#25164		;#0x624c
    654e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6552:	0c 93       	cmp	#0,	r12	;r3 As==00
    6554:	0f 24       	jz	$+32     	;abs 0x6574

00006556 <.Loc.450.2>:
    if (port_is_isr_context()) {
    6556:	b0 12 6a 62 	call	#25194		;#0x626a
    655a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    655e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6560:	05 24       	jz	$+12     	;abs 0x656c

00006562 <.Loc.451.2>:
      chSysLockFromISR();
    6562:	b0 12 86 62 	call	#25222		;#0x6286
    6566:	b0 12 00 63 	call	#25344		;#0x6300
    656a:	04 3c       	jmp	$+10     	;abs 0x6574

0000656c <.L70>:
    }
    else {
      chSysLock();
    656c:	b0 12 70 62 	call	#25200		;#0x6270
    6570:	b0 12 be 62 	call	#25278		;#0x62be

00006574 <.L69>:
    }
  }
  return sts;
    6574:	2c 41       	mov	@r1,	r12	;

00006576 <.Loc.458.2>:
}
    6576:	21 53       	incd	r1		;
    6578:	30 41       	ret			

0000657a <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
    657a:	21 83       	decd	r1		;

0000657c <L0>:
    657c:	81 4c 00 00 	mov	r12,	0(r1)	;

00006580 <.Loc.471.2>:

  if (port_irq_enabled(sts)) {
    6580:	2c 41       	mov	@r1,	r12	;
    6582:	b0 12 4c 62 	call	#25164		;#0x624c
    6586:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    658a:	0c 93       	cmp	#0,	r12	;r3 As==00
    658c:	11 24       	jz	$+36     	;abs 0x65b0

0000658e <.Loc.472.2>:
    if (port_is_isr_context()) {
    658e:	b0 12 6a 62 	call	#25194		;#0x626a
    6592:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6596:	0c 93       	cmp	#0,	r12	;r3 As==00
    6598:	05 24       	jz	$+12     	;abs 0x65a4

0000659a <.Loc.473.2>:
      chSysUnlockFromISR();
    659a:	b0 12 22 63 	call	#25378		;#0x6322
    659e:	b0 12 8a 62 	call	#25226		;#0x628a

000065a2 <.Loc.480.2>:
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
    65a2:	06 3c       	jmp	$+14     	;abs 0x65b0

000065a4 <.L74>:
      chSchRescheduleS();
    65a4:	b0 12 30 66 	call	#26160		;#0x6630

000065a8 <.Loc.477.2>:
      chSysUnlock();
    65a8:	b0 12 de 62 	call	#25310		;#0x62de
    65ac:	b0 12 7a 62 	call	#25210		;#0x627a

000065b0 <.L75>:
}
    65b0:	03 43       	nop			
    65b2:	21 53       	incd	r1		;
    65b4:	30 41       	ret			

000065b6 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    65b6:	21 82       	sub	#4,	r1	;r2 As==10

000065b8 <L0>:
    65b8:	81 4c 02 00 	mov	r12,	2(r1)	;
    65bc:	81 4d 00 00 	mov	r13,	0(r1)	;

000065c0 <.Loc.536.2>:

  chDbgCheckClassI();
    65c0:	b0 12 a4 63 	call	#25508		;#0x63a4

000065c4 <.Loc.541.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    65c4:	1c 41 02 00 	mov	2(r1),	r12	;
    65c8:	ac 41 04 00 	mov	@r1,	4(r12)	;

000065cc <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    65cc:	1c 41 02 00 	mov	2(r1),	r12	;
    65d0:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000065d4 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    65d4:	1c 41 02 00 	mov	2(r1),	r12	;
    65d8:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

000065dc <.Loc.544.2>:
  if (tp < nil.next) {
    65dc:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    65e0:	81 9c 02 00 	cmp	r12,	2(r1)	;
    65e4:	03 2c       	jc	$+8      	;abs 0x65ec

000065e6 <.Loc.545.2>:
    nil.next = tp;
    65e6:	92 41 02 00 	mov	2(r1),	&0x51d2	;
    65ea:	d2 51 

000065ec <.L77>:
  }
  return tp;
    65ec:	1c 41 02 00 	mov	2(r1),	r12	;

000065f0 <.Loc.548.2>:
}
    65f0:	21 52       	add	#4,	r1	;r2 As==10
    65f2:	30 41       	ret			

000065f4 <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    65f4:	1d 42 d0 51 	mov	&0x51d0,r13	;0x51d0
    65f8:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    65fc:	0c ed       	xor	r13,	r12	;
    65fe:	0d 43       	clr	r13		;
    6600:	0d 8c       	sub	r12,	r13	;
    6602:	0c dd       	bis	r13,	r12	;
    6604:	5c 03       	rrum	#1,	r12	;
    6606:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    660a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000660e <.Loc.566.2>:
}
    660e:	30 41       	ret			

00006610 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    6610:	21 83       	decd	r1		;

00006612 <.LCFI8>:
  thread_t *otp = nil.current;
    6612:	91 42 d0 51 	mov	&0x51d0,0(r1)	;0x51d0
    6616:	00 00 

00006618 <.Loc.578.2>:

  nil.current = nil.next;
    6618:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    661c:	82 4c d0 51 	mov	r12,	&0x51d0	;

00006620 <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    6620:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    6624:	2d 41       	mov	@r1,	r13	;
    6626:	b0 12 40 68 	call	#26688		;#0x6840

0000662a <.Loc.583.2>:
}
    662a:	03 43       	nop			
    662c:	21 53       	incd	r1		;
    662e:	30 41       	ret			

00006630 <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    6630:	b0 12 c2 63 	call	#25538		;#0x63c2

00006634 <.Loc.594.2>:

  if (chSchIsRescRequiredI()) {
    6634:	1d 42 d0 51 	mov	&0x51d0,r13	;0x51d0
    6638:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    663c:	0d 9c       	cmp	r12,	r13	;
    663e:	02 24       	jz	$+6      	;abs 0x6644

00006640 <.Loc.595.2>:
    chSchDoReschedule();
    6640:	b0 12 10 66 	call	#26128		;#0x6610

00006644 <.L84>:
  }
}
    6644:	03 43       	nop			
    6646:	30 41       	ret			

00006648 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    6648:	31 82       	sub	#8,	r1	;r2 As==11

0000664a <.LCFI9>:
    664a:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    664e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006652 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    6652:	91 42 d0 51 	mov	&0x51d0,4(r1)	;0x51d0
    6656:	04 00 

00006658 <.Loc.619.2>:

  chDbgCheckClassS();
    6658:	b0 12 c2 63 	call	#25538		;#0x63c2

0000665c <.Loc.625.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    665c:	1c 41 04 00 	mov	4(r1),	r12	;
    6660:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    6664:	02 00 

00006666 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    6666:	1c 41 04 00 	mov	4(r1),	r12	;
    666a:	ac 41 08 00 	mov	@r1,	8(r12)	;

0000666e <.Loc.664.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    666e:	b1 40 dc 51 	mov	#20956,	6(r1)	;#0x51dc
    6672:	06 00 

00006674 <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    6674:	1c 41 06 00 	mov	6(r1),	r12	;
    6678:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    667c:	0c 93       	cmp	#0,	r12	;r3 As==00
    667e:	12 20       	jnz	$+38     	;abs 0x66a4

00006680 <.Loc.668.2>:
      nil.current = nil.next = ntp;
    6680:	92 41 06 00 	mov	6(r1),	&0x51d2	;
    6684:	d2 51 
    6686:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    668a:	82 4c d0 51 	mov	r12,	&0x51d0	;

0000668e <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    668e:	1d 41 04 00 	mov	4(r1),	r13	;
    6692:	1c 41 06 00 	mov	6(r1),	r12	;
    6696:	b0 12 40 68 	call	#26688		;#0x6840

0000669a <.Loc.673.2>:
      return nil.current->u1.msg;
    669a:	1c 42 d0 51 	mov	&0x51d0,r12	;0x51d0
    669e:	1c 4c 04 00 	mov	4(r12),	r12	;
    66a2:	04 3c       	jmp	$+10     	;abs 0x66ac

000066a4 <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    66a4:	b1 50 10 00 	add	#16,	6(r1)	;#0x0010
    66a8:	06 00 

000066aa <.Loc.667.2>:
    if (NIL_THD_IS_READY(ntp)) {
    66aa:	e4 3f       	jmp	$-54     	;abs 0x6674

000066ac <.L89>:
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    66ac:	31 52       	add	#8,	r1	;r2 As==11
    66ae:	30 41       	ret			

000066b0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    66b0:	31 80 06 00 	sub	#6,	r1	;

000066b4 <L0>:
    66b4:	81 4c 02 00 	mov	r12,	2(r1)	;
    66b8:	81 4d 00 00 	mov	r13,	0(r1)	;

000066bc <.Loc.718.2>:

  if (*trp != NULL) {
    66bc:	1c 41 02 00 	mov	2(r1),	r12	;
    66c0:	2c 4c       	mov	@r12,	r12	;
    66c2:	0c 93       	cmp	#0,	r12	;r3 As==00
    66c4:	0d 24       	jz	$+28     	;abs 0x66e0

000066c6 <.LBB3>:
    thread_reference_t tr = *trp;
    66c6:	1c 41 02 00 	mov	2(r1),	r12	;
    66ca:	a1 4c 04 00 	mov	@r12,	4(r1)	;

000066ce <.Loc.723.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    66ce:	1c 41 02 00 	mov	2(r1),	r12	;
    66d2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000066d6 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    66d6:	2d 41       	mov	@r1,	r13	;
    66d8:	1c 41 04 00 	mov	4(r1),	r12	;
    66dc:	b0 12 b6 65 	call	#26038		;#0x65b6

000066e0 <.L94>:
  }
}
    66e0:	03 43       	nop			
    66e2:	31 50 06 00 	add	#6,	r1	;
    66e6:	30 41       	ret			

000066e8 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    66e8:	21 83       	decd	r1		;

000066ea <.LCFI12>:
    66ea:	81 4c 00 00 	mov	r12,	0(r1)	;

000066ee <.Loc.737.2>:

  chSysLock();
    66ee:	b0 12 70 62 	call	#25200		;#0x6270
    66f2:	b0 12 be 62 	call	#25278		;#0x62be

000066f6 <.Loc.738.2>:
  chThdSleepS(timeout);
    66f6:	2d 41       	mov	@r1,	r13	;
    66f8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    66fa:	b0 12 48 66 	call	#26184		;#0x6648

000066fe <.Loc.739.2>:
  chSysUnlock();
    66fe:	b0 12 de 62 	call	#25310		;#0x62de
    6702:	b0 12 7a 62 	call	#25210		;#0x627a

00006706 <.Loc.740.2>:
}
    6706:	03 43       	nop			
    6708:	21 53       	incd	r1		;
    670a:	30 41       	ret			

0000670c <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    670c:	31 80 06 00 	sub	#6,	r1	;

00006710 <.LCFI15>:
    6710:	81 4c 02 00 	mov	r12,	2(r1)	;
    6714:	81 4d 00 00 	mov	r13,	0(r1)	;

00006718 <.Loc.808.2>:

  chDbgCheckClassS();
    6718:	b0 12 c2 63 	call	#25538		;#0x63c2

0000671c <.Loc.813.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    671c:	1c 41 02 00 	mov	2(r1),	r12	;
    6720:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006724 <.Loc.814.2>:
  if (cnt <= (cnt_t)0) {
    6724:	4c 43       	clr.b	r12		;
    6726:	1c 91 04 00 	cmp	4(r1),	r12	;
    672a:	17 38       	jl	$+48     	;abs 0x675a

0000672c <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    672c:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6730:	02 20       	jnz	$+6      	;abs 0x6736

00006732 <.Loc.816.2>:
      return MSG_TIMEOUT;
    6732:	3c 43       	mov	#-1,	r12	;r3 As==11
    6734:	1a 3c       	jmp	$+54     	;abs 0x676a

00006736 <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    6736:	1d 41 04 00 	mov	4(r1),	r13	;
    673a:	3d 53       	add	#-1,	r13	;r3 As==11
    673c:	1c 41 02 00 	mov	2(r1),	r12	;
    6740:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006744 <.Loc.819.2>:
    nil.current->u1.semp = sp;
    6744:	1c 42 d0 51 	mov	&0x51d0,r12	;0x51d0
    6748:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    674c:	04 00 

0000674e <.Loc.820.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    674e:	2d 41       	mov	@r1,	r13	;
    6750:	7c 40 03 00 	mov.b	#3,	r12	;
    6754:	b0 12 48 66 	call	#26184		;#0x6648
    6758:	08 3c       	jmp	$+18     	;abs 0x676a

0000675a <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    675a:	1d 41 04 00 	mov	4(r1),	r13	;
    675e:	3d 53       	add	#-1,	r13	;r3 As==11
    6760:	1c 41 02 00 	mov	2(r1),	r12	;
    6764:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006768 <.Loc.823.2>:
  return MSG_OK;
    6768:	4c 43       	clr.b	r12		;

0000676a <.L102>:
}
    676a:	31 50 06 00 	add	#6,	r1	;
    676e:	30 41       	ret			

00006770 <port_lock>:
  _disable_interrupts();
    6770:	32 c2       	dint			
    6772:	03 43       	nop			

00006774 <L0>:
  asm volatile("nop");
    6774:	03 43       	nop			

00006776 <.Loc.349.1>:
}
    6776:	03 43       	nop			
    6778:	30 41       	ret			

0000677a <port_unlock>:
  asm volatile("nop");
    677a:	03 43       	nop			

0000677c <.Loc.356.1>:
  _enable_interrupts();
    677c:	03 43       	nop			
    677e:	32 d2       	eint			
    6780:	03 43       	nop			

00006782 <.Loc.357.1>:
}
    6782:	03 43       	nop			
    6784:	30 41       	ret			

00006786 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    6786:	31 80 06 00 	sub	#6,	r1	;

0000678a <.LCFI0>:
    678a:	81 4c 02 00 	mov	r12,	2(r1)	;
    678e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006792 <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    6792:	b0 12 a4 63 	call	#25508		;#0x63a4

00006796 <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    6796:	2c 41       	mov	@r1,	r12	;
    6798:	1c 51 02 00 	add	2(r1),	r12	;
    679c:	0d 4c       	mov	r12,	r13	;
    679e:	3d 53       	add	#-1,	r13	;r3 As==11
    67a0:	4c 43       	clr.b	r12		;
    67a2:	2c 81       	sub	@r1,	r12	;
    67a4:	0e 4d       	mov	r13,	r14	;
    67a6:	0e fc       	and	r12,	r14	;
    67a8:	81 4e 02 00 	mov	r14,	2(r1)	;

000067ac <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    67ac:	1c 42 dc 5c 	mov	&0x5cdc,r12	;0x5cdc
    67b0:	2c 51       	add	@r1,	r12	;
    67b2:	0d 4c       	mov	r12,	r13	;
    67b4:	3d 53       	add	#-1,	r13	;r3 As==11
    67b6:	4c 43       	clr.b	r12		;
    67b8:	2c 81       	sub	@r1,	r12	;
    67ba:	0c fd       	and	r13,	r12	;
    67bc:	81 4c 04 00 	mov	r12,	4(r1)	;

000067c0 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    67c0:	1c 42 de 5c 	mov	&0x5cde,r12	;0x5cde
    67c4:	1d 41 04 00 	mov	4(r1),	r13	;
    67c8:	0c 8d       	sub	r13,	r12	;
    67ca:	1c 91 02 00 	cmp	2(r1),	r12	;
    67ce:	02 2c       	jc	$+6      	;abs 0x67d4

000067d0 <.Loc.118.2>:
    return NULL;
    67d0:	4c 43       	clr.b	r12		;
    67d2:	08 3c       	jmp	$+18     	;abs 0x67e4

000067d4 <.L5>:
  }
  nextmem = p + size;
    67d4:	1c 41 04 00 	mov	4(r1),	r12	;
    67d8:	1c 51 02 00 	add	2(r1),	r12	;
    67dc:	82 4c dc 5c 	mov	r12,	&0x5cdc	;

000067e0 <.Loc.122.2>:

  return p;
    67e0:	1c 41 04 00 	mov	4(r1),	r12	;

000067e4 <.L6>:
}
    67e4:	31 50 06 00 	add	#6,	r1	;
    67e8:	30 41       	ret			

000067ea <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    67ea:	31 80       	sub,		r1	;Warning: disassembly unreliable - not enough bytes available

000067ec <L0>:
    67ec:	06 00       	mova	@r0,	r6	;

000067ee <.LCFI1>:
    67ee:	81 4c 02 00 	mov	r12,	2(r1)	;
    67f2:	81 4d 00 00 	mov	r13,	0(r1)	;

000067f6 <.Loc.140.2>:
  void *p;

  chSysLock();
    67f6:	b0 12 70 67 	call	#26480		;#0x6770
    67fa:	b0 12 be 62 	call	#25278		;#0x62be

000067fe <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    67fe:	2d 41       	mov	@r1,	r13	;
    6800:	1c 41 02 00 	mov	2(r1),	r12	;
    6804:	b0 12 86 67 	call	#26502		;#0x6786
    6808:	81 4c 04 00 	mov	r12,	4(r1)	;

0000680c <.Loc.142.2>:
  chSysUnlock();
    680c:	b0 12 de 62 	call	#25310		;#0x62de
    6810:	b0 12 7a 67 	call	#26490		;#0x677a

00006814 <.Loc.144.2>:

  return p;
    6814:	1c 41 04 00 	mov	4(r1),	r12	;

00006818 <.Loc.145.2>:
}
    6818:	31 50 06 00 	add	#6,	r1	;
    681c:	30 41       	ret			

0000681e <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    681e:	b2 40 ea 67 	mov	#26602,	&0x5ce0	;#0x67ea
    6822:	e0 5c 

00006824 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6824:	82 43 e2 5c 	mov	#0,	&0x5ce2	;r3 As==00

00006828 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    6828:	82 43 e4 5c 	mov	#0,	&0x5ce4	;r3 As==00

0000682c <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    682c:	92 43 e6 5c 	mov	#1,	&0x5ce6	;r3 As==01

00006830 <.Loc.117.1>:
#endif
}
    6830:	03 43       	nop			
    6832:	30 41       	ret			

00006834 <port_unlock>:
  asm volatile("nop");
    6834:	03 43       	nop			

00006836 <.Loc.356.1>:
  _enable_interrupts();
    6836:	03 43       	nop			
    6838:	32 d2       	eint			
    683a:	03 43       	nop			

0000683c <.Loc.357.1>:
}
    683c:	03 43       	nop			
    683e:	30 41       	ret			

00006840 <_port_switch>:
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #6, R9");
  asm volatile ("popx.a R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    6840:	6a 15       	pushm	#7,	r10	;16-bit words

00006842 <.Loc.81.2>:
  asm volatile ("mov r1, @R13");
    6842:	8d 41 00 00 	mov	r1,	0(r13)	;

00006846 <.Loc.82.2>:
  asm volatile ("mov @R12, r1");
    6846:	21 4c       	mov	@r12,	r1	;

00006848 <.Loc.83.2>:
  asm volatile ("popm.w #7, R10");
    6848:	64 17       	popm	#7,	r10	;16-bit words

0000684a <.Loc.84.2>:
  asm volatile ("ret");
    684a:	30 41       	ret			

0000684c <.Loc.86.2>:
#endif
}
    684c:	03 43       	nop			

0000684e <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    684e:	b0 12 de 62 	call	#25310		;#0x62de
    6852:	b0 12 34 68 	call	#26676		;#0x6834

00006856 <.Loc.101.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    6856:	0c 45       	mov	r5,	r12	;

00006858 <.Loc.102.2>:
  asm volatile ("call R4");
    6858:	84 12       	call	r4		;

0000685a <.Loc.108.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    685a:	4c 43       	clr.b	r12		;
    685c:	b0 12 a0 64 	call	#25760		;#0x64a0

00006860 <.Loc.110.2>:
#endif
}
    6860:	03 43       	nop			
    6862:	30 41       	ret			

00006864 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    6864:	31 82       	sub	#8,	r1	;r2 As==11

00006866 <.LCFI0>:
    6866:	81 4c 02 00 	mov	r12,	2(r1)	;
    686a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000686e <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    686e:	91 41 02 00 	mov	2(r1),	4(r1)	;
    6872:	04 00 

00006874 <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    6874:	1c 41 02 00 	mov	2(r1),	r12	;
    6878:	2c 4c       	mov	@r12,	r12	;
    687a:	0c 93       	cmp	#0,	r12	;r3 As==00
    687c:	1d 34       	jge	$+60     	;abs 0x68b8

0000687e <.LBB2>:
    thread_t *tp = nil.threads;
    687e:	b1 40 dc 51 	mov	#20956,	6(r1)	;#0x51dc
    6882:	06 00 

00006884 <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    6884:	1c 41 06 00 	mov	6(r1),	r12	;
    6888:	1c 4c 04 00 	mov	4(r12),	r12	;
    688c:	1c 91 04 00 	cmp	4(r1),	r12	;
    6890:	0f 20       	jnz	$+32     	;abs 0x68b0

00006892 <.Loc.67.1>:
        sp->cnt++;
    6892:	1c 41 04 00 	mov	4(r1),	r12	;
    6896:	2c 4c       	mov	@r12,	r12	;
    6898:	1c 53       	inc	r12		;
    689a:	0d 4c       	mov	r12,	r13	;
    689c:	1c 41 04 00 	mov	4(r1),	r12	;
    68a0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000068a4 <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    68a4:	2d 41       	mov	@r1,	r13	;
    68a6:	1c 41 06 00 	mov	6(r1),	r12	;
    68aa:	b0 12 b6 65 	call	#26038		;#0x65b6

000068ae <.Loc.72.1>:
        return;
    68ae:	04 3c       	jmp	$+10     	;abs 0x68b8

000068b0 <.L3>:
      }
      tp++;
    68b0:	b1 50 10 00 	add	#16,	6(r1)	;#0x0010
    68b4:	06 00 

000068b6 <.Loc.66.1>:
      if (tp->u1.semp == sp) {
    68b6:	e6 3f       	jmp	$-50     	;abs 0x6884

000068b8 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    68b8:	31 52       	add	#8,	r1	;r2 As==11
    68ba:	30 41       	ret			

000068bc <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    68bc:	03 43       	nop			
    68be:	30 41       	ret			

000068c0 <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    68c0:	b0 12 bc 68 	call	#26812		;#0x68bc

000068c4 <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    68c4:	b0 12 3a 73 	call	#29498		;#0x733a

000068c8 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    68c8:	3c 40 4e 50 	mov	#20558,	r12	;#0x504e
    68cc:	b0 12 2e 78 	call	#30766		;#0x782e

000068d0 <.Loc.68.2>:
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    68d0:	b0 12 3a 6f 	call	#28474		;#0x6f3a

000068d4 <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    68d4:	b0 12 ea 71 	call	#29162		;#0x71ea

000068d8 <.Loc.107.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    68d8:	b0 12 14 73 	call	#29460		;#0x7314

000068dc <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    68dc:	b0 12 ce 85 	call	#-31282	;#0x85ce

000068e0 <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    68e0:	b0 12 e8 68 	call	#26856		;#0x68e8

000068e4 <.Loc.145.2>:
#endif
}
    68e4:	03 43       	nop			
    68e6:	30 41       	ret			

000068e8 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    68e8:	b0 12 96 73 	call	#29590		;#0x7396

000068ec <.Loc.63.2>:
}
    68ec:	03 43       	nop			
    68ee:	30 41       	ret			

000068f0 <port_lock>:
  _disable_interrupts();
    68f0:	32 c2       	dint			
    68f2:	03 43       	nop			

000068f4 <.Loc.348.1>:
  asm volatile("nop");
    68f4:	03 43       	nop			

000068f6 <.Loc.349.1>:
}
    68f6:	03 43       	nop			
    68f8:	30 41       	ret			

000068fa <port_unlock>:
  asm volatile("nop");
    68fa:	03 43       	nop			

000068fc <.Loc.356.1>:
  _enable_interrupts();
    68fc:	03 43       	nop			
    68fe:	32 d2       	eint			
    6900:	03 43       	nop			

00006902 <.Loc.357.1>:
}
    6902:	03 43       	nop			
    6904:	30 41       	ret			

00006906 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6906:	b0 12 f0 68 	call	#26864		;#0x68f0
    690a:	b0 12 be 62 	call	#25278		;#0x62be

0000690e <.Loc.505.2>:
}
    690e:	03 43       	nop			
    6910:	30 41       	ret			

00006912 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6912:	b0 12 de 62 	call	#25310		;#0x62de
    6916:	b0 12 fa 68 	call	#26874		;#0x68fa

0000691a <.Loc.516.2>:
}
    691a:	03 43       	nop			
    691c:	30 41       	ret			

0000691e <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    691e:	1c 42 d4 51 	mov	&0x51d4,r12	;0x51d4

00006922 <.Loc.630.2>:
}
    6922:	30 41       	ret			

00006924 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6924:	21 83       	decd	r1		;

00006926 <.LCFI0>:
    6926:	81 4c 00 00 	mov	r12,	0(r1)	;

0000692a <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    692a:	2c 41       	mov	@r1,	r12	;
    692c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006930 <.Loc.768.2>:
}
    6930:	03 43       	nop			
    6932:	21 53       	incd	r1		;
    6934:	30 41       	ret			

00006936 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6936:	21 82       	sub	#4,	r1	;r2 As==10

00006938 <.LCFI1>:
    6938:	81 4c 02 00 	mov	r12,	2(r1)	;
    693c:	81 4d 00 00 	mov	r13,	0(r1)	;

00006940 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6940:	1c 41 02 00 	mov	2(r1),	r12	;
    6944:	2d 41       	mov	@r1,	r13	;
    6946:	b0 12 0c 67 	call	#26380		;#0x670c

0000694a <.Loc.797.2>:
}
    694a:	21 52       	add	#4,	r1	;r2 As==10
    694c:	30 41       	ret			

0000694e <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    694e:	31 82       	sub	#8,	r1	;r2 As==11

00006950 <.LCFI2>:
    6950:	81 4c 06 00 	mov	r12,	6(r1)	;
    6954:	81 4d 04 00 	mov	r13,	4(r1)	;
    6958:	81 4e 02 00 	mov	r14,	2(r1)	;
    695c:	81 4f 00 00 	mov	r15,	0(r1)	;

00006960 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6960:	1c 41 06 00 	mov	6(r1),	r12	;
    6964:	b0 12 24 69 	call	#26916		;#0x6924

00006968 <.Loc.59.3>:
  iqp->q_counter = 0;
    6968:	1c 41 06 00 	mov	6(r1),	r12	;
    696c:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006970 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6970:	1c 41 06 00 	mov	6(r1),	r12	;
    6974:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6978:	04 00 

0000697a <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    697a:	1c 41 06 00 	mov	6(r1),	r12	;
    697e:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6982:	0a 00 

00006984 <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    6984:	1c 41 06 00 	mov	6(r1),	r12	;
    6988:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    698c:	08 00 

0000698e <.Loc.63.3>:
  iqp->q_top     = bp + size;
    698e:	1d 41 04 00 	mov	4(r1),	r13	;
    6992:	1d 51 02 00 	add	2(r1),	r13	;
    6996:	1c 41 06 00 	mov	6(r1),	r12	;
    699a:	8c 4d 06 00 	mov	r13,	6(r12)	;

0000699e <.Loc.64.3>:
  iqp->q_notify  = infy;
    699e:	1c 41 06 00 	mov	6(r1),	r12	;
    69a2:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000069a6 <.Loc.65.3>:
  iqp->q_link    = link;
    69a6:	1c 41 06 00 	mov	6(r1),	r12	;
    69aa:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    69ae:	0e 00 

000069b0 <.Loc.66.3>:
}
    69b0:	03 43       	nop			
    69b2:	31 52       	add	#8,	r1	;r2 As==11
    69b4:	30 41       	ret			

000069b6 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    69b6:	21 82       	sub	#4,	r1	;r2 As==10

000069b8 <.LCFI4>:
    69b8:	81 4c 02 00 	mov	r12,	2(r1)	;
    69bc:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000069c0 <.Loc.104.3>:

  osalDbgCheckClassI();
    69c0:	b0 12 a4 63 	call	#25508		;#0x63a4

000069c4 <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    69c4:	1c 41 02 00 	mov	2(r1),	r12	;
    69c8:	1d 4c 08 00 	mov	8(r12),	r13	;
    69cc:	1c 41 02 00 	mov	2(r1),	r12	;
    69d0:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    69d4:	0d 9c       	cmp	r12,	r13	;
    69d6:	08 20       	jnz	$+18     	;abs 0x69e8

000069d8 <.Loc.106.3>:
    69d8:	1c 41 02 00 	mov	2(r1),	r12	;
    69dc:	1c 4c 02 00 	mov	2(r12),	r12	;
    69e0:	0c 93       	cmp	#0,	r12	;r3 As==00
    69e2:	02 24       	jz	$+6      	;abs 0x69e8

000069e4 <.Loc.106.3>:
    69e4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    69e6:	01 3c       	jmp	$+4      	;abs 0x69ea

000069e8 <.L13>:
    69e8:	4c 43       	clr.b	r12		;

000069ea <.L14>:
    69ea:	5c f3       	and.b	#1,	r12	;r3 As==01
    69ec:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    69f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    69f2:	02 24       	jz	$+6      	;abs 0x69f8

000069f4 <.Loc.107.3>:
    return MSG_TIMEOUT;
    69f4:	3c 43       	mov	#-1,	r12	;r3 As==11
    69f6:	2f 3c       	jmp	$+96     	;abs 0x6a56

000069f8 <.L15>:
  }

  iqp->q_counter++;
    69f8:	1c 41 02 00 	mov	2(r1),	r12	;
    69fc:	1c 4c 02 00 	mov	2(r12),	r12	;
    6a00:	0d 4c       	mov	r12,	r13	;
    6a02:	1d 53       	inc	r13		;
    6a04:	1c 41 02 00 	mov	2(r1),	r12	;
    6a08:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006a0c <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    6a0c:	1c 41 02 00 	mov	2(r1),	r12	;
    6a10:	1c 4c 08 00 	mov	8(r12),	r12	;
    6a14:	0e 4c       	mov	r12,	r14	;
    6a16:	1e 53       	inc	r14		;
    6a18:	1d 41 02 00 	mov	2(r1),	r13	;
    6a1c:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6a20:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6a24:	00 00 

00006a26 <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6a26:	1c 41 02 00 	mov	2(r1),	r12	;
    6a2a:	1d 4c 08 00 	mov	8(r12),	r13	;
    6a2e:	1c 41 02 00 	mov	2(r1),	r12	;
    6a32:	1c 4c 06 00 	mov	6(r12),	r12	;
    6a36:	0d 9c       	cmp	r12,	r13	;
    6a38:	08 28       	jnc	$+18     	;abs 0x6a4a

00006a3a <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    6a3a:	1c 41 02 00 	mov	2(r1),	r12	;
    6a3e:	1d 4c 04 00 	mov	4(r12),	r13	;
    6a42:	1c 41 02 00 	mov	2(r1),	r12	;
    6a46:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006a4a <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    6a4a:	1c 41 02 00 	mov	2(r1),	r12	;
    6a4e:	4d 43       	clr.b	r13		;
    6a50:	b0 12 64 68 	call	#26724		;#0x6864

00006a54 <.Loc.118.3>:

  return MSG_OK;
    6a54:	4c 43       	clr.b	r12		;

00006a56 <.L16>:
}
    6a56:	21 52       	add	#4,	r1	;r2 As==10
    6a58:	30 41       	ret			

00006a5a <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    6a5a:	31 82       	sub	#8,	r1	;r2 As==11

00006a5c <.LCFI5>:
    6a5c:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

00006a5e <L0>:
    6a5e:	02 00       	mova	@r0,	r2	;
    6a60:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a64 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6a64:	b0 12 06 69 	call	#26886		;#0x6906

00006a68 <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    6a68:	0f 3c       	jmp	$+32     	;abs 0x6a88

00006a6a <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6a6a:	1c 41 02 00 	mov	2(r1),	r12	;
    6a6e:	2d 41       	mov	@r1,	r13	;
    6a70:	b0 12 36 69 	call	#26934		;#0x6936
    6a74:	81 4c 06 00 	mov	r12,	6(r1)	;

00006a78 <.Loc.149.3>:
    if (msg < MSG_OK) {
    6a78:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6a7c:	05 34       	jge	$+12     	;abs 0x6a88

00006a7e <.Loc.150.3>:
      osalSysUnlock();
    6a7e:	b0 12 12 69 	call	#26898		;#0x6912

00006a82 <.Loc.151.3>:
      return msg;
    6a82:	1c 41 06 00 	mov	6(r1),	r12	;
    6a86:	3f 3c       	jmp	$+128    	;abs 0x6b06

00006a88 <.L19>:
  while (iqIsEmptyI(iqp)) {
    6a88:	1c 41 02 00 	mov	2(r1),	r12	;
    6a8c:	1c 4c 02 00 	mov	2(r12),	r12	;
    6a90:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a92:	eb 27       	jz	$-40     	;abs 0x6a6a

00006a94 <.Loc.156.3>:
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6a94:	1c 41 02 00 	mov	2(r1),	r12	;
    6a98:	1c 4c 02 00 	mov	2(r12),	r12	;
    6a9c:	0d 4c       	mov	r12,	r13	;
    6a9e:	3d 53       	add	#-1,	r13	;r3 As==11
    6aa0:	1c 41 02 00 	mov	2(r1),	r12	;
    6aa4:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006aa8 <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    6aa8:	1c 41 02 00 	mov	2(r1),	r12	;
    6aac:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6ab0:	0e 4c       	mov	r12,	r14	;
    6ab2:	1e 53       	inc	r14		;
    6ab4:	1d 41 02 00 	mov	2(r1),	r13	;
    6ab8:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6abc:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

00006ac0 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    6ac0:	1c 41 02 00 	mov	2(r1),	r12	;
    6ac4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6ac8:	1c 41 02 00 	mov	2(r1),	r12	;
    6acc:	1c 4c 06 00 	mov	6(r12),	r12	;
    6ad0:	0d 9c       	cmp	r12,	r13	;
    6ad2:	08 28       	jnc	$+18     	;abs 0x6ae4

00006ad4 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    6ad4:	1c 41 02 00 	mov	2(r1),	r12	;
    6ad8:	1d 4c 04 00 	mov	4(r12),	r13	;
    6adc:	1c 41 02 00 	mov	2(r1),	r12	;
    6ae0:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006ae4 <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6ae4:	1c 41 02 00 	mov	2(r1),	r12	;
    6ae8:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6aec:	0c 93       	cmp	#0,	r12	;r3 As==00
    6aee:	07 24       	jz	$+16     	;abs 0x6afe

00006af0 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6af0:	1c 41 02 00 	mov	2(r1),	r12	;
    6af4:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6af8:	1c 41 02 00 	mov	2(r1),	r12	;
    6afc:	8d 12       	call	r13		;

00006afe <.L23>:
  }

  osalSysUnlock();
    6afe:	b0 12 12 69 	call	#26898		;#0x6912

00006b02 <.Loc.169.3>:

  return (msg_t)b;
    6b02:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006b06 <.L20>:
}
    6b06:	31 52       	add	#8,	r1	;r2 As==11
    6b08:	30 41       	ret			

00006b0a <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    6b0a:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006b0e <L0>:
    6b0e:	81 4c 06 00 	mov	r12,	6(r1)	;
    6b12:	81 4d 04 00 	mov	r13,	4(r1)	;
    6b16:	81 4e 02 00 	mov	r14,	2(r1)	;
    6b1a:	81 4f 00 00 	mov	r15,	0(r1)	;

00006b1e <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6b1e:	1c 41 06 00 	mov	6(r1),	r12	;
    6b22:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6b26:	0c 00 

00006b28 <.Loc.200.3>:
  size_t r = 0;
    6b28:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006b2c <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6b2c:	b0 12 06 69 	call	#26886		;#0x6906

00006b30 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6b30:	b0 12 1e 69 	call	#26910		;#0x691e
    6b34:	0d 4c       	mov	r12,	r13	;
    6b36:	2d 51       	add	@r1,	r13	;
    6b38:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006b3c <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6b3c:	2e 3c       	jmp	$+94     	;abs 0x6b9a

00006b3e <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6b3e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6b42:	03 24       	jz	$+8      	;abs 0x6b4a

00006b44 <.Loc.218.3>:
    6b44:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6b48:	08 20       	jnz	$+18     	;abs 0x6b5a

00006b4a <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    6b4a:	1c 41 06 00 	mov	6(r1),	r12	;
    6b4e:	2d 41       	mov	@r1,	r13	;
    6b50:	b0 12 36 69 	call	#26934		;#0x6936
    6b54:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6b58:	18 3c       	jmp	$+50     	;abs 0x6b8a

00006b5a <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6b5a:	b0 12 1e 69 	call	#26910		;#0x691e
    6b5e:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6b62:	0d 8c       	sub	r12,	r13	;
    6b64:	81 4d 08 00 	mov	r13,	8(r1)	;

00006b68 <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6b68:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6b6c:	00 00 
    6b6e:	05 2c       	jc	$+12     	;abs 0x6b7a

00006b70 <.Loc.228.3>:
          osalSysUnlock();
    6b70:	b0 12 12 69 	call	#26898		;#0x6912

00006b74 <.Loc.229.3>:
          return r;
    6b74:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6b78:	5c 3c       	jmp	$+186    	;abs 0x6c32

00006b7a <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    6b7a:	1c 41 06 00 	mov	6(r1),	r12	;
    6b7e:	1d 41 08 00 	mov	8(r1),	r13	;
    6b82:	b0 12 36 69 	call	#26934		;#0x6936
    6b86:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006b8a <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6b8a:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6b8e:	05 24       	jz	$+12     	;abs 0x6b9a

00006b90 <.Loc.237.3>:
        osalSysUnlock();
    6b90:	b0 12 12 69 	call	#26898		;#0x6912

00006b94 <.Loc.238.3>:
        return r;
    6b94:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6b98:	4c 3c       	jmp	$+154    	;abs 0x6c32

00006b9a <.L25>:
    while (iqIsEmptyI(iqp)) {
    6b9a:	1c 41 06 00 	mov	6(r1),	r12	;
    6b9e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6ba2:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ba4:	cc 27       	jz	$-102    	;abs 0x6b3e

00006ba6 <.Loc.243.3>:
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    6ba6:	1c 41 06 00 	mov	6(r1),	r12	;
    6baa:	1c 4c 02 00 	mov	2(r12),	r12	;
    6bae:	0d 4c       	mov	r12,	r13	;
    6bb0:	3d 53       	add	#-1,	r13	;r3 As==11
    6bb2:	1c 41 06 00 	mov	6(r1),	r12	;
    6bb6:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006bba <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    6bba:	1c 41 04 00 	mov	4(r1),	r12	;
    6bbe:	0d 4c       	mov	r12,	r13	;
    6bc0:	1d 53       	inc	r13		;
    6bc2:	81 4d 04 00 	mov	r13,	4(r1)	;
    6bc6:	1d 41 06 00 	mov	6(r1),	r13	;
    6bca:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    6bce:	0f 4d       	mov	r13,	r15	;
    6bd0:	1f 53       	inc	r15		;
    6bd2:	1e 41 06 00 	mov	6(r1),	r14	;
    6bd6:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    6bda:	6d 4d       	mov.b	@r13,	r13	;
    6bdc:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006be0 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    6be0:	1c 41 06 00 	mov	6(r1),	r12	;
    6be4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6be8:	1c 41 06 00 	mov	6(r1),	r12	;
    6bec:	1c 4c 06 00 	mov	6(r12),	r12	;
    6bf0:	0d 9c       	cmp	r12,	r13	;
    6bf2:	08 28       	jnc	$+18     	;abs 0x6c04

00006bf4 <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6bf4:	1c 41 06 00 	mov	6(r1),	r12	;
    6bf8:	1d 4c 04 00 	mov	4(r12),	r13	;
    6bfc:	1c 41 06 00 	mov	6(r1),	r12	;
    6c00:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006c04 <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6c04:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6c08:	05 24       	jz	$+12     	;abs 0x6c14

00006c0a <.Loc.251.3>:
      nfy(iqp);
    6c0a:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6c0e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c12:	8d 12       	call	r13		;

00006c14 <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6c14:	b0 12 12 69 	call	#26898		;#0x6912

00006c18 <.Loc.257.3>:

    r++;
    6c18:	91 53 10 00 	inc	16(r1)		;

00006c1c <.Loc.258.3>:
    if (--n == 0U) {
    6c1c:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6c20:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6c24:	03 20       	jnz	$+8      	;abs 0x6c2c

00006c26 <.Loc.259.3>:
      return r;
    6c26:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6c2a:	03 3c       	jmp	$+8      	;abs 0x6c32

00006c2c <.L34>:
    }

    osalSysLock();
    6c2c:	b0 12 06 69 	call	#26886		;#0x6906

00006c30 <.Loc.213.3>:
    while (iqIsEmptyI(iqp)) {
    6c30:	b4 3f       	jmp	$-150    	;abs 0x6b9a

00006c32 <.L30>:
  }
}
    6c32:	31 50 12 00 	add	#18,	r1	;#0x0012
    6c36:	30 41       	ret			

00006c38 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    6c38:	31 82       	sub	#8,	r1	;r2 As==11

00006c3a <.LCFI7>:
    6c3a:	81 4c 06 00 	mov	r12,	6(r1)	;
    6c3e:	81 4d 04 00 	mov	r13,	4(r1)	;
    6c42:	81 4e       	mov	r14		; Warning: disassembly unreliable - not enough bytes available

00006c44 <L0>:
    6c44:	02 00       	mova	@r0,	r2	;
    6c46:	81 4f 00 00 	mov	r15,	0(r1)	;

00006c4a <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    6c4a:	1c 41 06 00 	mov	6(r1),	r12	;
    6c4e:	b0 12 24 69 	call	#26916		;#0x6924

00006c52 <.Loc.285.3>:
  oqp->q_counter = size;
    6c52:	1c 41 06 00 	mov	6(r1),	r12	;
    6c56:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    6c5a:	02 00 

00006c5c <.Loc.286.3>:
  oqp->q_buffer  = bp;
    6c5c:	1c 41 06 00 	mov	6(r1),	r12	;
    6c60:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6c64:	04 00 

00006c66 <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6c66:	1c 41 06 00 	mov	6(r1),	r12	;
    6c6a:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6c6e:	0a 00 

00006c70 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6c70:	1c 41 06 00 	mov	6(r1),	r12	;
    6c74:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6c78:	08 00 

00006c7a <.Loc.289.3>:
  oqp->q_top     = bp + size;
    6c7a:	1d 41 04 00 	mov	4(r1),	r13	;
    6c7e:	1d 51 02 00 	add	2(r1),	r13	;
    6c82:	1c 41 06 00 	mov	6(r1),	r12	;
    6c86:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006c8a <.Loc.290.3>:
  oqp->q_notify  = onfy;
    6c8a:	1c 41 06 00 	mov	6(r1),	r12	;
    6c8e:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006c92 <.Loc.291.3>:
  oqp->q_link    = link;
    6c92:	1c 41 06 00 	mov	6(r1),	r12	;
    6c96:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6c9a:	0e 00 

00006c9c <.Loc.292.3>:
}
    6c9c:	03 43       	nop			
    6c9e:	31 52       	add	#8,	r1	;r2 As==11
    6ca0:	30 41       	ret			

00006ca2 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    6ca2:	31 82       	sub	#8,	r1	;r2 As==11

00006ca4 <.LCFI9>:
    6ca4:	81 4c 04 00 	mov	r12,	4(r1)	;
    6ca8:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6cac:	81 4e 00 00 	mov	r14,	0(r1)	;

00006cb0 <.Loc.339.3>:

  osalSysLock();
    6cb0:	b0 12 06 69 	call	#26886		;#0x6906

00006cb4 <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6cb4:	0f 3c       	jmp	$+32     	;abs 0x6cd4

00006cb6 <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6cb6:	1c 41 04 00 	mov	4(r1),	r12	;
    6cba:	2d 41       	mov	@r1,	r13	;
    6cbc:	b0 12 36 69 	call	#26934		;#0x6936
    6cc0:	81 4c 06 00 	mov	r12,	6(r1)	;

00006cc4 <.Loc.344.3>:
    if (msg < MSG_OK) {
    6cc4:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6cc8:	05 34       	jge	$+12     	;abs 0x6cd4

00006cca <.Loc.345.3>:
      osalSysUnlock();
    6cca:	b0 12 12 69 	call	#26898		;#0x6912

00006cce <.Loc.346.3>:
      return msg;
    6cce:	1c 41 06 00 	mov	6(r1),	r12	;
    6cd2:	3f 3c       	jmp	$+128    	;abs 0x6d52

00006cd4 <.L39>:
  while (oqIsFullI(oqp)) {
    6cd4:	1c 41 04 00 	mov	4(r1),	r12	;
    6cd8:	1c 4c 02 00 	mov	2(r12),	r12	;
    6cdc:	0c 93       	cmp	#0,	r12	;r3 As==00
    6cde:	eb 27       	jz	$-40     	;abs 0x6cb6

00006ce0 <.Loc.351.3>:
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    6ce0:	1c 41 04 00 	mov	4(r1),	r12	;
    6ce4:	1c 4c 02 00 	mov	2(r12),	r12	;
    6ce8:	0d 4c       	mov	r12,	r13	;
    6cea:	3d 53       	add	#-1,	r13	;r3 As==11
    6cec:	1c 41 04 00 	mov	4(r1),	r12	;
    6cf0:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006cf4 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6cf4:	1c 41 04 00 	mov	4(r1),	r12	;
    6cf8:	1c 4c 08 00 	mov	8(r12),	r12	;
    6cfc:	0e 4c       	mov	r12,	r14	;
    6cfe:	1e 53       	inc	r14		;
    6d00:	1d 41 04 00 	mov	4(r1),	r13	;
    6d04:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6d08:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    6d0c:	00 00 

00006d0e <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6d0e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d12:	1d 4c 08 00 	mov	8(r12),	r13	;
    6d16:	1c 41 04 00 	mov	4(r1),	r12	;
    6d1a:	1c 4c 06 00 	mov	6(r12),	r12	;
    6d1e:	0d 9c       	cmp	r12,	r13	;
    6d20:	08 28       	jnc	$+18     	;abs 0x6d32

00006d22 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    6d22:	1c 41 04 00 	mov	4(r1),	r12	;
    6d26:	1d 4c 04 00 	mov	4(r12),	r13	;
    6d2a:	1c 41 04 00 	mov	4(r1),	r12	;
    6d2e:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006d32 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6d32:	1c 41 04 00 	mov	4(r1),	r12	;
    6d36:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6d3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d3c:	07 24       	jz	$+16     	;abs 0x6d4c

00006d3e <.Loc.359.3>:
    oqp->q_notify(oqp);
    6d3e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d42:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6d46:	1c 41 04 00 	mov	4(r1),	r12	;
    6d4a:	8d 12       	call	r13		;

00006d4c <.L43>:
  }

  osalSysUnlock();
    6d4c:	b0 12 12 69 	call	#26898		;#0x6912

00006d50 <.Loc.364.3>:

  return MSG_OK;
    6d50:	4c 43       	clr.b	r12		;

00006d52 <.L40>:
}
    6d52:	31 52       	add	#8,	r1	;r2 As==11
    6d54:	30 41       	ret			

00006d56 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6d56:	21 82       	sub	#4,	r1	;r2 As==10

00006d58 <.LCFI10>:
    6d58:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

00006d5a <L0>:
	...

00006d5c <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    6d5c:	b0 12 a4 63 	call	#25508		;#0x63a4

00006d60 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    6d60:	2c 41       	mov	@r1,	r12	;
    6d62:	1d 4c 08 00 	mov	8(r12),	r13	;
    6d66:	2c 41       	mov	@r1,	r12	;
    6d68:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6d6c:	0d 9c       	cmp	r12,	r13	;
    6d6e:	07 20       	jnz	$+16     	;abs 0x6d7e

00006d70 <.Loc.382.3>:
    6d70:	2c 41       	mov	@r1,	r12	;
    6d72:	1c 4c 02 00 	mov	2(r12),	r12	;
    6d76:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d78:	02 24       	jz	$+6      	;abs 0x6d7e

00006d7a <.Loc.382.3>:
    6d7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6d7c:	01 3c       	jmp	$+4      	;abs 0x6d80

00006d7e <.L45>:
    6d7e:	4c 43       	clr.b	r12		;

00006d80 <.L46>:
    6d80:	5c f3       	and.b	#1,	r12	;r3 As==01
    6d82:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6d86:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d88:	02 24       	jz	$+6      	;abs 0x6d8e

00006d8a <.Loc.383.3>:
    return MSG_TIMEOUT;
    6d8a:	3c 43       	mov	#-1,	r12	;r3 As==11
    6d8c:	26 3c       	jmp	$+78     	;abs 0x6dda

00006d8e <.L47>:
  }

  oqp->q_counter++;
    6d8e:	2c 41       	mov	@r1,	r12	;
    6d90:	1c 4c 02 00 	mov	2(r12),	r12	;
    6d94:	0d 4c       	mov	r12,	r13	;
    6d96:	1d 53       	inc	r13		;
    6d98:	2c 41       	mov	@r1,	r12	;
    6d9a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006d9e <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    6d9e:	2c 41       	mov	@r1,	r12	;
    6da0:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6da4:	0e 4c       	mov	r12,	r14	;
    6da6:	1e 53       	inc	r14		;
    6da8:	2d 41       	mov	@r1,	r13	;
    6daa:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6dae:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

00006db2 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    6db2:	2c 41       	mov	@r1,	r12	;
    6db4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6db8:	2c 41       	mov	@r1,	r12	;
    6dba:	1c 4c 06 00 	mov	6(r12),	r12	;
    6dbe:	0d 9c       	cmp	r12,	r13	;
    6dc0:	06 28       	jnc	$+14     	;abs 0x6dce

00006dc2 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    6dc2:	2c 41       	mov	@r1,	r12	;
    6dc4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6dc8:	2c 41       	mov	@r1,	r12	;
    6dca:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006dce <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    6dce:	2c 41       	mov	@r1,	r12	;
    6dd0:	4d 43       	clr.b	r13		;
    6dd2:	b0 12 64 68 	call	#26724		;#0x6864

00006dd6 <.Loc.394.3>:

  return (msg_t)b;
    6dd6:	5c 41 03 00 	mov.b	3(r1),	r12	;

00006dda <.L48>:
}
    6dda:	21 52       	add	#4,	r1	;r2 As==10
    6ddc:	30 41       	ret			

00006dde <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    6dde:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006de2 <L0>:
    6de2:	81 4c 06 00 	mov	r12,	6(r1)	;
    6de6:	81 4d 04 00 	mov	r13,	4(r1)	;
    6dea:	81 4e 02 00 	mov	r14,	2(r1)	;
    6dee:	81 4f 00 00 	mov	r15,	0(r1)	;

00006df2 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    6df2:	1c 41 06 00 	mov	6(r1),	r12	;
    6df6:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6dfa:	0c 00 

00006dfc <.Loc.425.3>:
  size_t w = 0;
    6dfc:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006e00 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6e00:	b0 12 06 69 	call	#26886		;#0x6906

00006e04 <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6e04:	b0 12 1e 69 	call	#26910		;#0x691e
    6e08:	0d 4c       	mov	r12,	r13	;
    6e0a:	2d 51       	add	@r1,	r13	;
    6e0c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006e10 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6e10:	2e 3c       	jmp	$+94     	;abs 0x6e6e

00006e12 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6e12:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6e16:	03 24       	jz	$+8      	;abs 0x6e1e

00006e18 <.Loc.442.3>:
    6e18:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6e1c:	08 20       	jnz	$+18     	;abs 0x6e2e

00006e1e <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6e1e:	1c 41 06 00 	mov	6(r1),	r12	;
    6e22:	2d 41       	mov	@r1,	r13	;
    6e24:	b0 12 36 69 	call	#26934		;#0x6936
    6e28:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6e2c:	18 3c       	jmp	$+50     	;abs 0x6e5e

00006e2e <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6e2e:	b0 12 1e 69 	call	#26910		;#0x691e
    6e32:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6e36:	0e 8c       	sub	r12,	r14	;
    6e38:	81 4e 08 00 	mov	r14,	8(r1)	;

00006e3c <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6e3c:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6e40:	00 00 
    6e42:	05 2c       	jc	$+12     	;abs 0x6e4e

00006e44 <.Loc.452.3>:
          osalSysUnlock();
    6e44:	b0 12 12 69 	call	#26898		;#0x6912

00006e48 <.Loc.453.3>:
          return w;
    6e48:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6e4c:	5c 3c       	jmp	$+186    	;abs 0x6f06

00006e4e <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    6e4e:	1c 41 06 00 	mov	6(r1),	r12	;
    6e52:	1d 41 08 00 	mov	8(r1),	r13	;
    6e56:	b0 12 36 69 	call	#26934		;#0x6936
    6e5a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006e5e <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6e5e:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6e62:	05 24       	jz	$+12     	;abs 0x6e6e

00006e64 <.Loc.461.3>:
        osalSysUnlock();
    6e64:	b0 12 12 69 	call	#26898		;#0x6912

00006e68 <.Loc.462.3>:
        return w;
    6e68:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6e6c:	4c 3c       	jmp	$+154    	;abs 0x6f06

00006e6e <.L51>:
    while (oqIsFullI(oqp)) {
    6e6e:	1c 41 06 00 	mov	6(r1),	r12	;
    6e72:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e76:	0c 93       	cmp	#0,	r12	;r3 As==00
    6e78:	cc 27       	jz	$-102    	;abs 0x6e12

00006e7a <.Loc.467.3>:
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    6e7a:	1c 41 06 00 	mov	6(r1),	r12	;
    6e7e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6e82:	0d 4c       	mov	r12,	r13	;
    6e84:	3d 53       	add	#-1,	r13	;r3 As==11
    6e86:	1c 41 06 00 	mov	6(r1),	r12	;
    6e8a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006e8e <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    6e8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6e92:	1c 4c 08 00 	mov	8(r12),	r12	;
    6e96:	0e 4c       	mov	r12,	r14	;
    6e98:	1e 53       	inc	r14		;
    6e9a:	1d 41 06 00 	mov	6(r1),	r13	;
    6e9e:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6ea2:	1d 41 04 00 	mov	4(r1),	r13	;
    6ea6:	0e 4d       	mov	r13,	r14	;
    6ea8:	1e 53       	inc	r14		;
    6eaa:	81 4e 04 00 	mov	r14,	4(r1)	;
    6eae:	6d 4d       	mov.b	@r13,	r13	;
    6eb0:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006eb4 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    6eb4:	1c 41 06 00 	mov	6(r1),	r12	;
    6eb8:	1d 4c 08 00 	mov	8(r12),	r13	;
    6ebc:	1c 41 06 00 	mov	6(r1),	r12	;
    6ec0:	1c 4c 06 00 	mov	6(r12),	r12	;
    6ec4:	0d 9c       	cmp	r12,	r13	;
    6ec6:	08 28       	jnc	$+18     	;abs 0x6ed8

00006ec8 <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    6ec8:	1c 41 06 00 	mov	6(r1),	r12	;
    6ecc:	1d 4c 04 00 	mov	4(r12),	r13	;
    6ed0:	1c 41 06 00 	mov	6(r1),	r12	;
    6ed4:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006ed8 <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    6ed8:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6edc:	05 24       	jz	$+12     	;abs 0x6ee8

00006ede <.Loc.475.3>:
      nfy(oqp);
    6ede:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6ee2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ee6:	8d 12       	call	r13		;

00006ee8 <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6ee8:	b0 12 12 69 	call	#26898		;#0x6912

00006eec <.Loc.481.3>:

    w++;
    6eec:	91 53 10 00 	inc	16(r1)		;

00006ef0 <.Loc.482.3>:
    if (--n == 0U) {
    6ef0:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6ef4:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6ef8:	03 20       	jnz	$+8      	;abs 0x6f00

00006efa <.Loc.483.3>:
      return w;
    6efa:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6efe:	03 3c       	jmp	$+8      	;abs 0x6f06

00006f00 <.L60>:
    }

    osalSysLock();
    6f00:	b0 12 06 69 	call	#26886		;#0x6906

00006f04 <.LBE6>:
  while (true) {
    6f04:	85 3f       	jmp	$-244    	;abs 0x6e10

00006f06 <.L56>:
  }
}
    6f06:	31 50 12 00 	add	#18,	r1	;#0x0012
    6f0a:	30 41       	ret			

00006f0c <port_lock>:
  _disable_interrupts();
    6f0c:	32 c2       	dint			
    6f0e:	03 43       	nop			

00006f10 <.Loc.348.1>:
  asm volatile("nop");
    6f10:	03 43       	nop			

00006f12 <.Loc.349.1>:
}
    6f12:	03 43       	nop			
    6f14:	30 41       	ret			

00006f16 <port_unlock>:
  asm volatile("nop");
    6f16:	03 43       	nop			

00006f18 <L0>:
  _enable_interrupts();
    6f18:	03 43       	nop			
    6f1a:	32 d2       	eint			
    6f1c:	03 43       	nop			

00006f1e <.Loc.357.1>:
}
    6f1e:	03 43       	nop			
    6f20:	30 41       	ret			

00006f22 <osalSysLock>:
  chSysLock();
    6f22:	b0 12 0c 6f 	call	#28428		;#0x6f0c
    6f26:	b0 12 be 62 	call	#25278		;#0x62be

00006f2a <.Loc.505.2>:
}
    6f2a:	03 43       	nop			
    6f2c:	30 41       	ret			

00006f2e <osalSysUnlock>:
  chSysUnlock();
    6f2e:	b0 12 de 62 	call	#25310		;#0x62de
    6f32:	b0 12 16 6f 	call	#28438		;#0x6f16

00006f36 <.Loc.516.2>:
}
    6f36:	03 43       	nop			
    6f38:	30 41       	ret			

00006f3a <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
    6f3a:	b0 12 52 82 	call	#-32174	;#0x8252

00006f3e <.Loc.59.3>:
}
    6f3e:	03 43       	nop			
    6f40:	30 41       	ret			

00006f42 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    6f42:	21 83       	decd	r1		;

00006f44 <.LCFI3>:
    6f44:	81 4c 00 00 	mov	r12,	0(r1)	;

00006f48 <.Loc.70.3>:

  adcp->state    = ADC_STOP;
    6f48:	2c 41       	mov	@r1,	r12	;
    6f4a:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00006f4e <.Loc.71.3>:
  adcp->config   = NULL;
    6f4e:	2c 41       	mov	@r1,	r12	;
    6f50:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006f54 <.Loc.72.3>:
  adcp->samples  = NULL;
    6f54:	2c 41       	mov	@r1,	r12	;
    6f56:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006f5a <.Loc.73.3>:
  adcp->depth    = 0;
    6f5a:	2c 41       	mov	@r1,	r12	;
    6f5c:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006f60 <.Loc.74.3>:
  adcp->grpp     = NULL;
    6f60:	2c 41       	mov	@r1,	r12	;
    6f62:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00006f66 <.Loc.76.3>:
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    6f66:	2c 41       	mov	@r1,	r12	;
    6f68:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00006f6c <.Loc.84.3>:
  osalMutexObjectInit(&adcp->mutex);
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    6f6c:	03 43       	nop			
    6f6e:	21 53       	incd	r1		;
    6f70:	30 41       	ret			

00006f72 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
    6f72:	21 82       	sub	#4,	r1	;r2 As==10

00006f74 <.LCFI4>:
    6f74:	81 4c 02 00 	mov	r12,	2(r1)	;
    6f78:	81 4d 00 00 	mov	r13,	0(r1)	;

00006f7c <.Loc.99.3>:

  osalDbgCheck(adcp != NULL);

  osalSysLock();
    6f7c:	b0 12 22 6f 	call	#28450		;#0x6f22

00006f80 <.Loc.102.3>:
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    6f80:	1c 41 02 00 	mov	2(r1),	r12	;
    6f84:	ac 41 02 00 	mov	@r1,	2(r12)	;

00006f88 <.Loc.103.3>:
  adc_lld_start(adcp);
    6f88:	1c 41 02 00 	mov	2(r1),	r12	;
    6f8c:	b0 12 6c 82 	call	#-32148	;#0x826c

00006f90 <.Loc.104.3>:
  adcp->state = ADC_READY;
    6f90:	1c 41 02 00 	mov	2(r1),	r12	;
    6f94:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00006f98 <.Loc.105.3>:
  osalSysUnlock();
    6f98:	b0 12 2e 6f 	call	#28462		;#0x6f2e

00006f9c <.Loc.106.3>:
}
    6f9c:	03 43       	nop			
    6f9e:	21 52       	add	#4,	r1	;r2 As==10
    6fa0:	30 41       	ret			

00006fa2 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
    6fa2:	31 82       	sub	#8,	r1	;r2 As==11

00006fa4 <.LCFI6>:
    6fa4:	81 4c 06 00 	mov	r12,	6(r1)	;
    6fa8:	81 4d 04 00 	mov	r13,	4(r1)	;
    6fac:	81 4e 02 00 	mov	r14,	2(r1)	;
    6fb0:	81 4f 00 00 	mov	r15,	0(r1)	;

00006fb4 <.Loc.152.3>:

  osalSysLock();
    6fb4:	b0 12 22 6f 	call	#28450		;#0x6f22

00006fb8 <.Loc.153.3>:
  adcStartConversionI(adcp, grpp, samples, depth);
    6fb8:	2f 41       	mov	@r1,	r15	;
    6fba:	1e 41 02 00 	mov	2(r1),	r14	;
    6fbe:	1d 41 04 00 	mov	4(r1),	r13	;
    6fc2:	1c 41 06 00 	mov	6(r1),	r12	;
    6fc6:	b0 12 d4 6f 	call	#28628		;#0x6fd4

00006fca <.Loc.154.3>:
  osalSysUnlock();
    6fca:	b0 12 2e 6f 	call	#28462		;#0x6f2e

00006fce <.Loc.155.3>:
}
    6fce:	03 43       	nop			
    6fd0:	31 52       	add	#8,	r1	;r2 As==11
    6fd2:	30 41       	ret			

00006fd4 <adcStartConversionI>:
 * @iclass
 */
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {
    6fd4:	31 82       	sub	#8,	r1	;r2 As==11

00006fd6 <.LCFI7>:
    6fd6:	81 4c 06 00 	mov	r12,	6(r1)	;
    6fda:	81 4d 04 00 	mov	r13,	4(r1)	;
    6fde:	81 4e 02 00 	mov	r14,	2(r1)	;
    6fe2:	81 4f 00 00 	mov	r15,	0(r1)	;

00006fe6 <.Loc.180.3>:

  osalDbgCheckClassI();
    6fe6:	b0 12 a4 63 	call	#25508		;#0x63a4

00006fea <.Loc.188.3>:
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
    6fea:	1c 41 06 00 	mov	6(r1),	r12	;
    6fee:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    6ff2:	04 00 

00006ff4 <.Loc.189.3>:
  adcp->depth    = depth;
    6ff4:	1c 41 06 00 	mov	6(r1),	r12	;
    6ff8:	ac 41 06 00 	mov	@r1,	6(r12)	;

00006ffc <.Loc.190.3>:
  adcp->grpp     = grpp;
    6ffc:	1c 41 06 00 	mov	6(r1),	r12	;
    7000:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    7004:	08 00 

00007006 <.Loc.191.3>:
  adcp->state    = ADC_ACTIVE;
    7006:	1c 41 06 00 	mov	6(r1),	r12	;
    700a:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    700e:	00 00 

00007010 <.Loc.192.3>:
  adc_lld_start_conversion(adcp);
    7010:	1c 41 06 00 	mov	6(r1),	r12	;
    7014:	b0 12 14 83 	call	#-31980	;#0x8314

00007018 <.Loc.193.3>:
}
    7018:	03 43       	nop			
    701a:	31 52       	add	#8,	r1	;r2 As==11
    701c:	30 41       	ret			

0000701e <port_lock>:
  _disable_interrupts();
    701e:	32 c2       	dint			
    7020:	03 43       	nop			

00007022 <.Loc.348.1>:
  asm volatile("nop");
    7022:	03 43       	nop			

00007024 <.Loc.349.1>:
}
    7024:	03 43       	nop			
    7026:	30 41       	ret			

00007028 <port_unlock>:
  asm volatile("nop");
    7028:	03 43       	nop			

0000702a <.Loc.356.1>:
  _enable_interrupts();
    702a:	03 43       	nop			
    702c:	32 d2       	eint			
    702e:	03 43       	nop			

00007030 <.Loc.357.1>:
}
    7030:	03 43       	nop			
    7032:	30 41       	ret			

00007034 <osalSysLock>:
  chSysLock();
    7034:	b0 12 1e 70 	call	#28702		;#0x701e
    7038:	b0 12 be 62 	call	#25278		;#0x62be

0000703c <.Loc.505.2>:
}
    703c:	03 43       	nop			
    703e:	30 41       	ret			

00007040 <osalSysUnlock>:
  chSysUnlock();
    7040:	b0 12 de 62 	call	#25310		;#0x62de
    7044:	b0 12 28 70 	call	#28712		;#0x7028

00007048 <.Loc.516.2>:
}
    7048:	03 43       	nop			
    704a:	30 41       	ret			

0000704c <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    704c:	21 83       	decd	r1		;

0000704e <.LCFI0>:
    704e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007052 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    7052:	2c 41       	mov	@r1,	r12	;
    7054:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    7058:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000705c <.Loc.811.2>:
  esp->cb    = NULL;
    705c:	2c 41       	mov	@r1,	r12	;
    705e:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00007062 <.Loc.812.2>:
  esp->param = NULL;
    7062:	2c 41       	mov	@r1,	r12	;
    7064:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00007068 <.Loc.813.2>:
}
    7068:	03 43       	nop			
    706a:	21 53       	incd	r1		;
    706c:	30 41       	ret			

0000706e <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    706e:	0a 15       	pushm	#1,	r10	;16-bit words

00007070 <.LCFI1>:
    7070:	31 80 06 00 	sub	#6,	r1	;

00007074 <.LCFI2>:
    7074:	81 4c 04 00 	mov	r12,	4(r1)	;
    7078:	81 4d 00 00 	mov	r13,	0(r1)	;
    707c:	81 4e 02 00 	mov	r14,	2(r1)	;

00007080 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    7080:	1c 41 04 00 	mov	4(r1),	r12	;
    7084:	1d 4c 02 00 	mov	2(r12),	r13	;
    7088:	2c 4c       	mov	@r12,	r12	;
    708a:	2a 41       	mov	@r1,	r10	;
    708c:	0a dc       	bis	r12,	r10	;
    708e:	1b 41 02 00 	mov	2(r1),	r11	;
    7092:	0b dd       	bis	r13,	r11	;
    7094:	1c 41 04 00 	mov	4(r1),	r12	;
    7098:	8c 4a 00 00 	mov	r10,	0(r12)	;
    709c:	8c 4b 02 00 	mov	r11,	2(r12)	;

000070a0 <.Loc.829.2>:
  if (esp->cb != NULL) {
    70a0:	1c 41 04 00 	mov	4(r1),	r12	;
    70a4:	1c 4c 04 00 	mov	4(r12),	r12	;
    70a8:	0c 93       	cmp	#0,	r12	;r3 As==00
    70aa:	07 24       	jz	$+16     	;abs 0x70ba

000070ac <.Loc.830.2>:
    esp->cb(esp);
    70ac:	1c 41 04 00 	mov	4(r1),	r12	;
    70b0:	1d 4c 04 00 	mov	4(r12),	r13	;
    70b4:	1c 41 04 00 	mov	4(r1),	r12	;
    70b8:	8d 12       	call	r13		;

000070ba <.L9>:
  }
}
    70ba:	03 43       	nop			
    70bc:	31 50 06 00 	add	#6,	r1	;
    70c0:	0a 17       	popm	#1,	r10	;16-bit words
    70c2:	30 41       	ret			

000070c4 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    70c4:	31 80 06 00 	sub	#6,	r1	;

000070c8 <.LCFI3>:
    70c8:	81 4c 04 00 	mov	r12,	4(r1)	;
    70cc:	81 4d 02 00 	mov	r13,	2(r1)	;
    70d0:	81 4e 00 00 	mov	r14,	0(r1)	;

000070d4 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    70d4:	1c 41 04 00 	mov	4(r1),	r12	;
    70d8:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    70dc:	4f 43       	clr.b	r15		;
    70de:	2e 41       	mov	@r1,	r14	;
    70e0:	1d 41 02 00 	mov	2(r1),	r13	;
    70e4:	b0 12 de 6d 	call	#28126		;#0x6dde

000070e8 <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    70e8:	31 50 06 00 	add	#6,	r1	;
    70ec:	30 41       	ret			

000070ee <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    70ee:	31 80 06 00 	sub	#6,	r1	;

000070f2 <.LCFI4>:
    70f2:	81 4c 04 00 	mov	r12,	4(r1)	;
    70f6:	81 4d 02 00 	mov	r13,	2(r1)	;
    70fa:	81 4e 00 00 	mov	r14,	0(r1)	;

000070fe <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    70fe:	1c 41 04 00 	mov	4(r1),	r12	;
    7102:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7106:	4f 43       	clr.b	r15		;
    7108:	2e 41       	mov	@r1,	r14	;
    710a:	1d 41 02 00 	mov	2(r1),	r13	;
    710e:	b0 12 0a 6b 	call	#27402		;#0x6b0a

00007112 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    7112:	31 50 06 00 	add	#6,	r1	;
    7116:	30 41       	ret			

00007118 <put>:

static msg_t put(void *ip, uint8_t b) {
    7118:	21 82       	sub	#4,	r1	;r2 As==10

0000711a <.LCFI5>:
    711a:	81 4c 02 00 	mov	r12,	2(r1)	;
    711e:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007122 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    7122:	1c 41 02 00 	mov	2(r1),	r12	;
    7126:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    712a:	4e 43       	clr.b	r14		;
    712c:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7130:	b0 12 a2 6c 	call	#27810		;#0x6ca2

00007134 <.Loc.65.3>:
}
    7134:	21 52       	add	#4,	r1	;r2 As==10
    7136:	30 41       	ret			

00007138 <get>:

static msg_t get(void *ip) {
    7138:	21 83       	decd	r1		;

0000713a <.LCFI6>:
    713a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000713e <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    713e:	2c 41       	mov	@r1,	r12	;
    7140:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7144:	4d 43       	clr.b	r13		;
    7146:	b0 12 5a 6a 	call	#27226		;#0x6a5a

0000714a <.Loc.70.3>:
}
    714a:	21 53       	incd	r1		;
    714c:	30 41       	ret			

0000714e <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    714e:	31 80 06 00 	sub	#6,	r1	;

00007152 <.LCFI7>:
    7152:	81 4c 04 00 	mov	r12,	4(r1)	;
    7156:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    715a:	81 4e 00 00 	mov	r14,	0(r1)	;

0000715e <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    715e:	1c 41 04 00 	mov	4(r1),	r12	;
    7162:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7166:	2e 41       	mov	@r1,	r14	;
    7168:	5d 41 03 00 	mov.b	3(r1),	r13	;
    716c:	b0 12 a2 6c 	call	#27810		;#0x6ca2

00007170 <.Loc.75.3>:
}
    7170:	31 50 06 00 	add	#6,	r1	;
    7174:	30 41       	ret			

00007176 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    7176:	21 82       	sub	#4,	r1	;r2 As==10

00007178 <.LCFI8>:
    7178:	81 4c 02 00 	mov	r12,	2(r1)	;
    717c:	81 4d 00 00 	mov	r13,	0(r1)	;

00007180 <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    7180:	1c 41 02 00 	mov	2(r1),	r12	;
    7184:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7188:	2d 41       	mov	@r1,	r13	;
    718a:	b0 12 5a 6a 	call	#27226		;#0x6a5a

0000718e <.Loc.80.3>:
}
    718e:	21 52       	add	#4,	r1	;r2 As==10
    7190:	30 41       	ret			

00007192 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    7192:	31 82       	sub	#8,	r1	;r2 As==11

00007194 <.LCFI9>:
    7194:	81 4c 06 00 	mov	r12,	6(r1)	;
    7198:	81 4d 04 00 	mov	r13,	4(r1)	;
    719c:	81 4e 02 00 	mov	r14,	2(r1)	;
    71a0:	81 4f 00 00 	mov	r15,	0(r1)	;

000071a4 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    71a4:	1c 41 06 00 	mov	6(r1),	r12	;
    71a8:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    71ac:	2f 41       	mov	@r1,	r15	;
    71ae:	1e 41 02 00 	mov	2(r1),	r14	;
    71b2:	1d 41 04 00 	mov	4(r1),	r13	;
    71b6:	b0 12 de 6d 	call	#28126		;#0x6dde

000071ba <.Loc.85.3>:
}
    71ba:	31 52       	add	#8,	r1	;r2 As==11
    71bc:	30 41       	ret			

000071be <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    71be:	31 82       	sub	#8,	r1	;r2 As==11

000071c0 <.LCFI10>:
    71c0:	81 4c 06 00 	mov	r12,	6(r1)	;
    71c4:	81 4d 04 00 	mov	r13,	4(r1)	;
    71c8:	81 4e 02 00 	mov	r14,	2(r1)	;
    71cc:	81 4f 00 00 	mov	r15,	0(r1)	;

000071d0 <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    71d0:	1c 41 06 00 	mov	6(r1),	r12	;
    71d4:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    71d8:	2f 41       	mov	@r1,	r15	;
    71da:	1e 41 02 00 	mov	2(r1),	r14	;
    71de:	1d 41 04 00 	mov	4(r1),	r13	;
    71e2:	b0 12 0a 6b 	call	#27402		;#0x6b0a

000071e6 <.Loc.90.3>:
}
    71e6:	31 52       	add	#8,	r1	;r2 As==11
    71e8:	30 41       	ret			

000071ea <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    71ea:	b0 12 f2 77 	call	#30706		;#0x77f2

000071ee <.Loc.111.3>:
}
    71ee:	03 43       	nop			
    71f0:	30 41       	ret			

000071f2 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    71f2:	31 82       	sub	#8,	r1	;r2 As==11

000071f4 <.LCFI11>:
    71f4:	81 4c 06 00 	mov	r12,	6(r1)	;
    71f8:	81 4d 04 00 	mov	r13,	4(r1)	;
    71fc:	81 4e 02 00 	mov	r14,	2(r1)	;

00007200 <.Loc.133.3>:

  sdp->vmt = &vmt;
    7200:	1c 41 06 00 	mov	6(r1),	r12	;
    7204:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    7208:	00 00 

0000720a <.Loc.134.3>:
  osalEventObjectInit(&sdp->event);
    720a:	1c 41 06 00 	mov	6(r1),	r12	;
    720e:	2c 53       	incd	r12		;
    7210:	b0 12 4c 70 	call	#28748		;#0x704c

00007214 <.Loc.135.3>:
  sdp->state = SD_STOP;
    7214:	1c 41 06 00 	mov	6(r1),	r12	;
    7218:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

0000721c <.Loc.136.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    721c:	1c 41 06 00 	mov	6(r1),	r12	;
    7220:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7224:	1d 41 06 00 	mov	6(r1),	r13	;
    7228:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    722c:	91 41 06 00 	mov	6(r1),	0(r1)	;
    7230:	00 00 
    7232:	1f 41 04 00 	mov	4(r1),	r15	;
    7236:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    723a:	b0 12 4e 69 	call	#26958		;#0x694e

0000723e <.Loc.137.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    723e:	1c 41 06 00 	mov	6(r1),	r12	;
    7242:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    7246:	1d 41 06 00 	mov	6(r1),	r13	;
    724a:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    724e:	91 41 06 00 	mov	6(r1),	0(r1)	;
    7252:	00 00 
    7254:	1f 41 02 00 	mov	2(r1),	r15	;
    7258:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    725c:	b0 12 38 6c 	call	#27704		;#0x6c38

00007260 <.Loc.138.3>:
}
    7260:	03 43       	nop			
    7262:	31 52       	add	#8,	r1	;r2 As==11
    7264:	30 41       	ret			

00007266 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    7266:	21 82       	sub	#4,	r1	;r2 As==10

00007268 <.LCFI12>:
    7268:	81 4c 02 00 	mov	r12,	2(r1)	;
    726c:	81 4d 00 00 	mov	r13,	0(r1)	;

00007270 <.Loc.162.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    7270:	b0 12 34 70 	call	#28724		;#0x7034

00007274 <.Loc.165.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    7274:	2d 41       	mov	@r1,	r13	;
    7276:	1c 41 02 00 	mov	2(r1),	r12	;
    727a:	b0 12 04 78 	call	#30724		;#0x7804

0000727e <.Loc.166.3>:
  sdp->state = SD_READY;
    727e:	1c 41 02 00 	mov	2(r1),	r12	;
    7282:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00007286 <.Loc.167.3>:
  osalSysUnlock();
    7286:	b0 12 40 70 	call	#28736		;#0x7040

0000728a <.Loc.168.3>:
}
    728a:	03 43       	nop			
    728c:	21 52       	add	#4,	r1	;r2 As==10
    728e:	30 41       	ret			

00007290 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    7290:	21 82       	sub	#4,	r1	;r2 As==10

00007292 <.LCFI14>:
    7292:	81 4c 02 00 	mov	r12,	2(r1)	;
    7296:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

0000729a <.Loc.215.3>:

  osalDbgCheckClassI();
    729a:	b0 12 a4 63 	call	#25508		;#0x63a4

0000729e <.Loc.218.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    729e:	1c 41 02 00 	mov	2(r1),	r12	;
    72a2:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    72a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    72a8:	07 20       	jnz	$+16     	;abs 0x72b8

000072aa <.Loc.219.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    72aa:	1c 41 02 00 	mov	2(r1),	r12	;
    72ae:	2c 53       	incd	r12		;
    72b0:	6d 42       	mov.b	#4,	r13	;r2 As==10
    72b2:	4e 43       	clr.b	r14		;
    72b4:	b0 12 6e 70 	call	#28782		;#0x706e

000072b8 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    72b8:	1c 41 02 00 	mov	2(r1),	r12	;
    72bc:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    72c0:	5d 41 01 00 	mov.b	1(r1),	r13	;
    72c4:	b0 12 b6 69 	call	#27062		;#0x69b6
    72c8:	0c 93       	cmp	#0,	r12	;r3 As==00
    72ca:	08 34       	jge	$+18     	;abs 0x72dc

000072cc <.Loc.221.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    72cc:	1c 41 02 00 	mov	2(r1),	r12	;
    72d0:	2c 53       	incd	r12		;
    72d2:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    72d6:	4e 43       	clr.b	r14		;
    72d8:	b0 12 6e 70 	call	#28782		;#0x706e

000072dc <.L33>:
}
    72dc:	03 43       	nop			
    72de:	21 52       	add	#4,	r1	;r2 As==10
    72e0:	30 41       	ret			

000072e2 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    72e2:	21 82       	sub	#4,	r1	;r2 As==10

000072e4 <.LCFI15>:
    72e4:	81 4c 00 00 	mov	r12,	0(r1)	;

000072e8 <.Loc.242.3>:
  msg_t  b;

  osalDbgCheckClassI();
    72e8:	b0 12 a4 63 	call	#25508		;#0x63a4

000072ec <.Loc.245.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    72ec:	2c 41       	mov	@r1,	r12	;
    72ee:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    72f2:	b0 12 56 6d 	call	#27990		;#0x6d56
    72f6:	81 4c 02 00 	mov	r12,	2(r1)	;

000072fa <.Loc.246.3>:
  if (b < MSG_OK)
    72fa:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    72fe:	06 34       	jge	$+14     	;abs 0x730c

00007300 <.Loc.247.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    7300:	2c 41       	mov	@r1,	r12	;
    7302:	2c 53       	incd	r12		;
    7304:	7d 42       	mov.b	#8,	r13	;r2 As==11
    7306:	4e 43       	clr.b	r14		;
    7308:	b0 12 6e 70 	call	#28782		;#0x706e

0000730c <.L35>:
  return b;
    730c:	1c 41 02 00 	mov	2(r1),	r12	;

00007310 <.Loc.249.3>:
}
    7310:	21 52       	add	#4,	r1	;r2 As==10
    7312:	30 41       	ret			

00007314 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    7314:	b0 12 6a 7e 	call	#32362		;#0x7e6a

00007318 <.Loc.59.3>:
}
    7318:	03 43       	nop			
    731a:	30 41       	ret			

0000731c <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    731c:	21 83       	decd	r1		;

0000731e <.LCFI1>:
    731e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007322 <.Loc.70.3>:

  spip->state = SPI_STOP;
    7322:	2c 41       	mov	@r1,	r12	;
    7324:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00007328 <.Loc.71.3>:
  spip->config = NULL;
    7328:	2c 41       	mov	@r1,	r12	;
    732a:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000732e <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    732e:	2c 41       	mov	@r1,	r12	;
    7330:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00007334 <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    7334:	03 43       	nop			
    7336:	21 53       	incd	r1		;
    7338:	30 41       	ret			

0000733a <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    733a:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    733e:	5c 01 

00007340 <.Loc.68.1>:
  FRCTL0 = FRCTLPW | NWAITS_1;
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    7340:	b2 40 00 a5 	mov	#-23296,&0x0160	;#0xa500
    7344:	60 01 

00007346 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    7346:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    734a:	62 01 

0000734c <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    734c:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    7350:	64 01 

00007352 <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    7352:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00007356 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    7356:	b2 40 c9 c1 	mov	#-15927,&0x0168	;#0xc1c9
    735a:	68 01 

0000735c <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    735c:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    7360:	6c 01 

00007362 <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    7362:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00007366 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    7366:	b0 12 d8 7a 	call	#31448		;#0x7ad8

0000736a <.Loc.96.1>:
#endif
}
    736a:	03 43       	nop			
    736c:	30 41       	ret			

0000736e <port_lock_from_isr>:
}
    736e:	03 43       	nop			
    7370:	30 41       	ret			

00007372 <port_unlock_from_isr>:
}
    7372:	03 43       	nop			
    7374:	30 41       	ret			

00007376 <osalSysLockFromISR>:
  chSysLockFromISR();
    7376:	b0 12 6e 73 	call	#29550		;#0x736e
    737a:	b0 12 00 63 	call	#25344		;#0x6300

0000737e <.Loc.527.2>:
}
    737e:	03 43       	nop			
    7380:	30 41       	ret			

00007382 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    7382:	b0 12 22 63 	call	#25378		;#0x6322
    7386:	b0 12 72 73 	call	#29554		;#0x7372

0000738a <.Loc.538.2>:
}
    738a:	03 43       	nop			
    738c:	30 41       	ret			

0000738e <osalOsTimerHandlerI>:
  chSysTimerHandlerI();
    738e:	b0 12 b0 64 	call	#25776		;#0x64b0

00007392 <.Loc.597.2>:
}
    7392:	03 43       	nop			
    7394:	30 41       	ret			

00007396 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    7396:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    739a:	d2 03 

0000739c <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    739c:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    73a0:	c2 03 

000073a2 <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    73a2:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

000073a6 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    73a6:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    73aa:	c0 03 

000073ac <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    73ac:	03 43       	nop			
    73ae:	30 41       	ret			

000073b0 <port_lock_from_isr>:
}
    73b0:	03 43       	nop			
    73b2:	30 41       	ret			

000073b4 <port_unlock_from_isr>:
}
    73b4:	03 43       	nop			
    73b6:	30 41       	ret			

000073b8 <osalSysLockFromISR>:
  chSysLockFromISR();
    73b8:	b0 12 b0 73 	call	#29616		;#0x73b0
    73bc:	b0 12 00 63 	call	#25344		;#0x6300

000073c0 <.Loc.527.2>:
}
    73c0:	03 43       	nop			
    73c2:	30 41       	ret			

000073c4 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    73c4:	b0 12 22 63 	call	#25378		;#0x6322
    73c8:	b0 12 b4 73 	call	#29620		;#0x73b4

000073cc <.Loc.538.2>:
}
    73cc:	03 43       	nop			
    73ce:	30 41       	ret			

000073d0 <osalEventBroadcastFlagsI>:
                                            eventflags_t flags) {
    73d0:	0a 15       	pushm	#1,	r10	;16-bit words

000073d2 <.LCFI0>:
    73d2:	31 80 06 00 	sub	#6,	r1	;

000073d6 <.LCFI1>:
    73d6:	81 4c 04 00 	mov	r12,	4(r1)	;
    73da:	81 4d 00 00 	mov	r13,	0(r1)	;
    73de:	81 4e 02 00 	mov	r14,	2(r1)	;

000073e2 <.Loc.828.2>:
  esp->flags |= flags;
    73e2:	1c 41 04 00 	mov	4(r1),	r12	;
    73e6:	1d 4c 02 00 	mov	2(r12),	r13	;
    73ea:	2c 4c       	mov	@r12,	r12	;
    73ec:	2a 41       	mov	@r1,	r10	;
    73ee:	0a dc       	bis	r12,	r10	;
    73f0:	1b 41 02 00 	mov	2(r1),	r11	;
    73f4:	0b dd       	bis	r13,	r11	;
    73f6:	1c 41 04 00 	mov	4(r1),	r12	;
    73fa:	8c 4a 00 00 	mov	r10,	0(r12)	;
    73fe:	8c 4b 02 00 	mov	r11,	2(r12)	;

00007402 <.Loc.829.2>:
  if (esp->cb != NULL) {
    7402:	1c 41 04 00 	mov	4(r1),	r12	;
    7406:	1c 4c 04 00 	mov	4(r12),	r12	;
    740a:	0c 93       	cmp	#0,	r12	;r3 As==00
    740c:	07 24       	jz	$+16     	;abs 0x741c

0000740e <.Loc.830.2>:
    esp->cb(esp);
    740e:	1c 41 04 00 	mov	4(r1),	r12	;
    7412:	1d 4c 04 00 	mov	4(r12),	r13	;
    7416:	1c 41 04 00 	mov	4(r1),	r12	;
    741a:	8d 12       	call	r13		;

0000741c <.L7>:
}
    741c:	03 43       	nop			
    741e:	31 50 06 00 	add	#6,	r1	;
    7422:	0a 17       	popm	#1,	r10	;16-bit words
    7424:	30 41       	ret			

00007426 <UCBRS>:
static uint8_t UCBRS(uint16_t frac) {
    7426:	21 83       	decd	r1		;

00007428 <.LCFI2>:
    7428:	81 4c 00 00 	mov	r12,	0(r1)	;

0000742c <.Loc.107.3>:
  if (frac < 529)
    742c:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    7430:	2c 91       	cmp	@r1,	r12	;
    7432:	02 28       	jnc	$+6      	;abs 0x7438

00007434 <.Loc.108.3>:
    return 0x00;
    7434:	4c 43       	clr.b	r12		;
    7436:	ec 3c       	jmp	$+474    	;abs 0x7610

00007438 <.L9>:
  else if (frac < 715)
    7438:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    743c:	2c 91       	cmp	@r1,	r12	;
    743e:	02 28       	jnc	$+6      	;abs 0x7444

00007440 <.Loc.110.3>:
    return 0x01;
    7440:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7442:	e6 3c       	jmp	$+462    	;abs 0x7610

00007444 <.L11>:
  else if (frac < 835)
    7444:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    7448:	2c 91       	cmp	@r1,	r12	;
    744a:	02 28       	jnc	$+6      	;abs 0x7450

0000744c <.Loc.112.3>:
    return 0x02;
    744c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    744e:	e0 3c       	jmp	$+450    	;abs 0x7610

00007450 <.L12>:
  else if (frac < 1001)
    7450:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    7454:	2c 91       	cmp	@r1,	r12	;
    7456:	02 28       	jnc	$+6      	;abs 0x745c

00007458 <.Loc.114.3>:
    return 0x04;
    7458:	6c 42       	mov.b	#4,	r12	;r2 As==10
    745a:	da 3c       	jmp	$+438    	;abs 0x7610

0000745c <.L13>:
  else if (frac < 1252)
    745c:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    7460:	2c 91       	cmp	@r1,	r12	;
    7462:	02 28       	jnc	$+6      	;abs 0x7468

00007464 <.Loc.116.3>:
    return 0x08;
    7464:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7466:	d4 3c       	jmp	$+426    	;abs 0x7610

00007468 <.L14>:
  else if (frac < 1430)
    7468:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    746c:	2c 91       	cmp	@r1,	r12	;
    746e:	03 28       	jnc	$+8      	;abs 0x7476

00007470 <.Loc.118.3>:
    return 0x10;
    7470:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7474:	cd 3c       	jmp	$+412    	;abs 0x7610

00007476 <.L15>:
  else if (frac < 1670)
    7476:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    747a:	2c 91       	cmp	@r1,	r12	;
    747c:	03 28       	jnc	$+8      	;abs 0x7484

0000747e <.Loc.120.3>:
    return 0x20;
    747e:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    7482:	c6 3c       	jmp	$+398    	;abs 0x7610

00007484 <.L16>:
  else if (frac < 2147)
    7484:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    7488:	2c 91       	cmp	@r1,	r12	;
    748a:	03 28       	jnc	$+8      	;abs 0x7492

0000748c <.Loc.122.3>:
    return 0x11;
    748c:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    7490:	bf 3c       	jmp	$+384    	;abs 0x7610

00007492 <.L17>:
  else if (frac < 2224)
    7492:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    7496:	2c 91       	cmp	@r1,	r12	;
    7498:	03 28       	jnc	$+8      	;abs 0x74a0

0000749a <.Loc.124.3>:
    return 0x21;
    749a:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    749e:	b8 3c       	jmp	$+370    	;abs 0x7610

000074a0 <.L18>:
  else if (frac < 2503)
    74a0:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    74a4:	2c 91       	cmp	@r1,	r12	;
    74a6:	03 28       	jnc	$+8      	;abs 0x74ae

000074a8 <.Loc.126.3>:
    return 0x22;
    74a8:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    74ac:	b1 3c       	jmp	$+356    	;abs 0x7610

000074ae <.L19>:
  else if (frac < 3000)
    74ae:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    74b2:	2c 91       	cmp	@r1,	r12	;
    74b4:	03 28       	jnc	$+8      	;abs 0x74bc

000074b6 <.Loc.128.3>:
    return 0x44;
    74b6:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    74ba:	aa 3c       	jmp	$+342    	;abs 0x7610

000074bc <.L20>:
  else if (frac < 3335)
    74bc:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    74c0:	2c 91       	cmp	@r1,	r12	;
    74c2:	03 28       	jnc	$+8      	;abs 0x74ca

000074c4 <.Loc.130.3>:
    return 0x25;
    74c4:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    74c8:	a3 3c       	jmp	$+328    	;abs 0x7610

000074ca <.L21>:
  else if (frac < 3575)
    74ca:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    74ce:	2c 91       	cmp	@r1,	r12	;
    74d0:	03 28       	jnc	$+8      	;abs 0x74d8

000074d2 <.Loc.132.3>:
    return 0x49;
    74d2:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    74d6:	9c 3c       	jmp	$+314    	;abs 0x7610

000074d8 <.L22>:
  else if (frac < 3753)
    74d8:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    74dc:	2c 91       	cmp	@r1,	r12	;
    74de:	03 28       	jnc	$+8      	;abs 0x74e6

000074e0 <.Loc.134.3>:
    return 0x4A;
    74e0:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    74e4:	95 3c       	jmp	$+300    	;abs 0x7610

000074e6 <.L23>:
  else if (frac < 4003)
    74e6:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    74ea:	2c 91       	cmp	@r1,	r12	;
    74ec:	03 28       	jnc	$+8      	;abs 0x74f4

000074ee <.Loc.136.3>:
    return 0x52;
    74ee:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    74f2:	8e 3c       	jmp	$+286    	;abs 0x7610

000074f4 <.L24>:
  else if (frac < 4286)
    74f4:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    74f8:	2c 91       	cmp	@r1,	r12	;
    74fa:	03 28       	jnc	$+8      	;abs 0x7502

000074fc <.Loc.138.3>:
    return 0x92;
    74fc:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    7500:	87 3c       	jmp	$+272    	;abs 0x7610

00007502 <.L25>:
  else if (frac < 4378)
    7502:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    7506:	2c 91       	cmp	@r1,	r12	;
    7508:	03 28       	jnc	$+8      	;abs 0x7510

0000750a <.Loc.140.3>:
    return 0x53;
    750a:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    750e:	80 3c       	jmp	$+258    	;abs 0x7610

00007510 <.L26>:
  else if (frac < 5002)
    7510:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    7514:	2c 91       	cmp	@r1,	r12	;
    7516:	03 28       	jnc	$+8      	;abs 0x751e

00007518 <.Loc.142.3>:
    return 0x55;
    7518:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    751c:	79 3c       	jmp	$+244    	;abs 0x7610

0000751e <.L27>:
  else if (frac < 5715)
    751e:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    7522:	2c 91       	cmp	@r1,	r12	;
    7524:	03 28       	jnc	$+8      	;abs 0x752c

00007526 <.Loc.144.3>:
    return 0xAA;
    7526:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    752a:	72 3c       	jmp	$+230    	;abs 0x7610

0000752c <.L28>:
  else if (frac < 6003)
    752c:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    7530:	2c 91       	cmp	@r1,	r12	;
    7532:	03 28       	jnc	$+8      	;abs 0x753a

00007534 <.Loc.146.3>:
    return 0x6B;
    7534:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    7538:	6b 3c       	jmp	$+216    	;abs 0x7610

0000753a <.L29>:
  else if (frac < 6254)
    753a:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    753e:	2c 91       	cmp	@r1,	r12	;
    7540:	03 28       	jnc	$+8      	;abs 0x7548

00007542 <.Loc.148.3>:
    return 0xAD;
    7542:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    7546:	64 3c       	jmp	$+202    	;abs 0x7610

00007548 <.L30>:
  else if (frac < 6432)
    7548:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    754c:	2c 91       	cmp	@r1,	r12	;
    754e:	03 28       	jnc	$+8      	;abs 0x7556

00007550 <.Loc.150.3>:
    return 0xB5;
    7550:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    7554:	5d 3c       	jmp	$+188    	;abs 0x7610

00007556 <.L31>:
  else if (frac < 6667)
    7556:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    755a:	2c 91       	cmp	@r1,	r12	;
    755c:	03 28       	jnc	$+8      	;abs 0x7564

0000755e <.Loc.152.3>:
    return 0xB6;
    755e:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    7562:	56 3c       	jmp	$+174    	;abs 0x7610

00007564 <.L32>:
  else if (frac < 7001)
    7564:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    7568:	2c 91       	cmp	@r1,	r12	;
    756a:	03 28       	jnc	$+8      	;abs 0x7572

0000756c <.Loc.154.3>:
    return 0xD6;
    756c:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    7570:	4f 3c       	jmp	$+160    	;abs 0x7610

00007572 <.L33>:
  else if (frac < 7147)
    7572:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    7576:	2c 91       	cmp	@r1,	r12	;
    7578:	03 28       	jnc	$+8      	;abs 0x7580

0000757a <.Loc.156.3>:
    return 0xB7;
    757a:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    757e:	48 3c       	jmp	$+146    	;abs 0x7610

00007580 <.L34>:
  else if (frac < 7503)
    7580:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    7584:	2c 91       	cmp	@r1,	r12	;
    7586:	03 28       	jnc	$+8      	;abs 0x758e

00007588 <.Loc.158.3>:
    return 0xBB;
    7588:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    758c:	41 3c       	jmp	$+132    	;abs 0x7610

0000758e <.L35>:
  else if (frac < 7861)
    758e:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    7592:	2c 91       	cmp	@r1,	r12	;
    7594:	03 28       	jnc	$+8      	;abs 0x759c

00007596 <.Loc.160.3>:
    return 0xDD;
    7596:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    759a:	3a 3c       	jmp	$+118    	;abs 0x7610

0000759c <.L36>:
  else if (frac < 8004)
    759c:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    75a0:	2c 91       	cmp	@r1,	r12	;
    75a2:	03 28       	jnc	$+8      	;abs 0x75aa

000075a4 <.Loc.162.3>:
    return 0xED;
    75a4:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    75a8:	33 3c       	jmp	$+104    	;abs 0x7610

000075aa <.L37>:
  else if (frac < 8333)
    75aa:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    75ae:	2c 91       	cmp	@r1,	r12	;
    75b0:	03 28       	jnc	$+8      	;abs 0x75b8

000075b2 <.Loc.164.3>:
    return 0xEE;
    75b2:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    75b6:	2c 3c       	jmp	$+90     	;abs 0x7610

000075b8 <.L38>:
  else if (frac < 8464)
    75b8:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    75bc:	2c 91       	cmp	@r1,	r12	;
    75be:	03 28       	jnc	$+8      	;abs 0x75c6

000075c0 <.Loc.166.3>:
    return 0xBF;
    75c0:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    75c4:	25 3c       	jmp	$+76     	;abs 0x7610

000075c6 <.L39>:
  else if (frac < 8572)
    75c6:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    75ca:	2c 91       	cmp	@r1,	r12	;
    75cc:	03 28       	jnc	$+8      	;abs 0x75d4

000075ce <.Loc.168.3>:
    return 0xDF;
    75ce:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    75d2:	1e 3c       	jmp	$+62     	;abs 0x7610

000075d4 <.L40>:
  else if (frac < 8751)
    75d4:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    75d8:	2c 91       	cmp	@r1,	r12	;
    75da:	03 28       	jnc	$+8      	;abs 0x75e2

000075dc <.Loc.170.3>:
    return 0xEF;
    75dc:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    75e0:	17 3c       	jmp	$+48     	;abs 0x7610

000075e2 <.L41>:
  else if (frac < 9004)
    75e2:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    75e6:	2c 91       	cmp	@r1,	r12	;
    75e8:	03 28       	jnc	$+8      	;abs 0x75f0

000075ea <.Loc.172.3>:
    return 0xF7;
    75ea:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    75ee:	10 3c       	jmp	$+34     	;abs 0x7610

000075f0 <.L42>:
  else if (frac < 9170)
    75f0:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    75f4:	2c 91       	cmp	@r1,	r12	;
    75f6:	03 28       	jnc	$+8      	;abs 0x75fe

000075f8 <.Loc.174.3>:
    return 0xFB;
    75f8:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    75fc:	09 3c       	jmp	$+20     	;abs 0x7610

000075fe <.L43>:
  else if (frac < 9288)
    75fe:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    7602:	2c 91       	cmp	@r1,	r12	;
    7604:	03 28       	jnc	$+8      	;abs 0x760c

00007606 <.Loc.176.3>:
    return 0xFD;
    7606:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    760a:	02 3c       	jmp	$+6      	;abs 0x7610

0000760c <.L44>:
    return 0xFE;
    760c:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00007610 <.L10>:
}
    7610:	21 53       	incd	r1		;
    7612:	30 41       	ret			

00007614 <UCAxMCTLW>:
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    7614:	0a 15       	pushm	#1,	r10	;16-bit words

00007616 <.LCFI3>:
    7616:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000761a <.LCFI4>:
    761a:	81 4c 04 00 	mov	r12,	4(r1)	;
    761e:	81 4d 06 00 	mov	r13,	6(r1)	;
    7622:	81 4e 00 00 	mov	r14,	0(r1)	;
    7626:	81 4f 02 00 	mov	r15,	2(r1)	;

0000762a <.Loc.191.3>:
  uint16_t n = freq / baud;
    762a:	1e 41 04 00 	mov	4(r1),	r14	;
    762e:	1f 41 06 00 	mov	6(r1),	r15	;
    7632:	2c 41       	mov	@r1,	r12	;
    7634:	1d 41 02 00 	mov	2(r1),	r13	;
    7638:	b0 12 7e 8f 	call	#-28802	;#0x8f7e
    763c:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00007640 <.Loc.193.3>:
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    7640:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    7644:	0c 4e       	mov	r14,	r12	;
    7646:	0d 43       	clr	r13		;
    7648:	1e 41 04 00 	mov	4(r1),	r14	;
    764c:	1f 41 06 00 	mov	6(r1),	r15	;
    7650:	b0 12 4a 91 	call	#-28342	;#0x914a
    7654:	0e 4c       	mov	r12,	r14	;
    7656:	0f 4d       	mov	r13,	r15	;
    7658:	2c 41       	mov	@r1,	r12	;

0000765a <L0>:
    765a:	1d 41 02 00 	mov	2(r1),	r13	;
    765e:	0c 8e       	sub	r14,	r12	;
    7660:	0d 7f       	subc	r15,	r13	;
    7662:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    7666:	4f 43       	clr.b	r15		;
    7668:	b0 12 4a 91 	call	#-28342	;#0x914a
    766c:	1e 41 04 00 	mov	4(r1),	r14	;
    7670:	1f 41 06 00 	mov	6(r1),	r15	;
    7674:	b0 12 7e 8f 	call	#-28802	;#0x8f7e
    7678:	81 4c 08 00 	mov	r12,	8(r1)	;

0000767c <.Loc.194.3>:
  if (n > 16) {
    767c:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7680:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7684:	19 2c       	jc	$+52     	;abs 0x76b8

00007686 <.Loc.195.3>:
    while (n > 16) {
    7686:	03 3c       	jmp	$+8      	;abs 0x768e

00007688 <.L48>:
      n -= 16;
    7688:	b1 50 f0 ff 	add	#-16,	10(r1)	;#0xfff0, 0x000a
    768c:	0a 00 

0000768e <.L47>:
    while (n > 16) {
    768e:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7692:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7696:	f8 2b       	jnc	$-14     	;abs 0x7688

00007698 <.Loc.198.3>:
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    7698:	1c 41 08 00 	mov	8(r1),	r12	;
    769c:	b0 12 26 74 	call	#29734		;#0x7426
    76a0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76a4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    76a8:	0a 4c       	mov	r12,	r10	;
    76aa:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    76ae:	b0 12 b0 8f 	call	#-28752	;#0x8fb0
    76b2:	0c da       	bis	r10,	r12	;
    76b4:	1c d3       	bis	#1,	r12	;r3 As==01
    76b6:	08 3c       	jmp	$+18     	;abs 0x76c8

000076b8 <.L46>:
  return UCBRS(frac) << 8;
    76b8:	1c 41 08 00 	mov	8(r1),	r12	;
    76bc:	b0 12 26 74 	call	#29734		;#0x7426
    76c0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76c4:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

000076c8 <.L49>:
}
    76c8:	31 50 0c 00 	add	#12,	r1	;#0x000c
    76cc:	0a 17       	popm	#1,	r10	;16-bit words
    76ce:	30 41       	ret			

000076d0 <UCAxBRW>:
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    76d0:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000076d4 <L0>:
    76d4:	81 4c 04 00 	mov	r12,	4(r1)	;
    76d8:	81 4d 06 00 	mov	r13,	6(r1)	;
    76dc:	81 4e 00 00 	mov	r14,	0(r1)	;
    76e0:	81 4f 02 00 	mov	r15,	2(r1)	;

000076e4 <.Loc.212.3>:
  uint16_t n = freq / baud;
    76e4:	1e 41 04 00 	mov	4(r1),	r14	;
    76e8:	1f 41 06 00 	mov	6(r1),	r15	;
    76ec:	2c 41       	mov	@r1,	r12	;
    76ee:	1d 41 02 00 	mov	2(r1),	r13	;
    76f2:	b0 12 7e 8f 	call	#-28802	;#0x8f7e
    76f6:	81 4c 08 00 	mov	r12,	8(r1)	;

000076fa <.Loc.213.3>:
  if (n > 16) {
    76fa:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    76fe:	1c 91 08 00 	cmp	8(r1),	r12	;
    7702:	05 2c       	jc	$+12     	;abs 0x770e

00007704 <.Loc.214.3>:
    return n >> 4;
    7704:	1c 41 08 00 	mov	8(r1),	r12	;
    7708:	b0 12 ae 90 	call	#-28498	;#0x90ae
    770c:	02 3c       	jmp	$+6      	;abs 0x7712

0000770e <.L51>:
  return n;
    770e:	1c 41 08 00 	mov	8(r1),	r12	;

00007712 <.L52>:
}
    7712:	31 50 0a 00 	add	#10,	r1	;#0x000a
    7716:	30 41       	ret			

00007718 <usart1_init>:
static void usart1_init(const SerialConfig * config) {
    7718:	21 83       	decd	r1		;

0000771a <L0>:
    771a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000771e <.Loc.235.3>:
  UCA1BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    771e:	2c 41       	mov	@r1,	r12	;
    7720:	1d 4c 02 00 	mov	2(r12),	r13	;
    7724:	2c 4c       	mov	@r12,	r12	;
    7726:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    772a:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    772e:	b0 12 d0 76 	call	#30416		;#0x76d0
    7732:	82 4c e6 05 	mov	r12,	&0x05e6	;

00007736 <.Loc.236.3>:
  UCA1MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART1_CLK_FREQ);
    7736:	2c 41       	mov	@r1,	r12	;
    7738:	1d 4c 02 00 	mov	2(r12),	r13	;
    773c:	2c 4c       	mov	@r12,	r12	;
    773e:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    7742:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    7746:	b0 12 14 76 	call	#30228		;#0x7614
    774a:	82 4c e8 05 	mov	r12,	&0x05e8	;

0000774e <.Loc.237.3>:
  UCA1STATW = 0;
    774e:	c2 43 ea 05 	mov.b	#0,	&0x05ea	;r3 As==00

00007752 <.Loc.238.3>:
  UCA1ABCTL = 0;
    7752:	c2 43 f0 05 	mov.b	#0,	&0x05f0	;r3 As==00

00007756 <.Loc.239.3>:
  UCA1IRCTL = 0;
    7756:	82 43 f2 05 	mov	#0,	&0x05f2	;r3 As==00

0000775a <.Loc.240.3>:
  UCA1CTLW0 = (MSP430X_USART1_PARITY << 14) | (MSP430X_USART1_ORDER << 13) |
    775a:	b2 40 80 00 	mov	#128,	&0x05e0	;#0x0080
    775e:	e0 05 

00007760 <.Loc.243.3>:
  UCA1IE = UCRXIE;
    7760:	92 43 fa 05 	mov	#1,	&0x05fa	;r3 As==01

00007764 <.Loc.244.3>:
}
    7764:	03 43       	nop			
    7766:	21 53       	incd	r1		;
    7768:	30 41       	ret			

0000776a <notify1>:
static void notify1(io_queue_t * qp) {
    776a:	21 83       	decd	r1		;

0000776c <.LCFI7>:
    776c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007770 <.Loc.287.3>:
  UCA1IE |= UCTXIE;
    7770:	1c 42 fa 05 	mov	&0x05fa,r12	;0x05fa
    7774:	2c d3       	bis	#2,	r12	;r3 As==10
    7776:	82 4c fa 05 	mov	r12,	&0x05fa	;

0000777a <.Loc.288.3>:
}
    777a:	03 43       	nop			
    777c:	21 53       	incd	r1		;
    777e:	30 41       	ret			

00007780 <set_error>:
static void set_error(uint16_t sra, SerialDriver * sdp) {
    7780:	31 82       	sub	#8,	r1	;r2 As==11

00007782 <.LCFI8>:
    7782:	81 4c 02 00 	mov	r12,	2(r1)	;
    7786:	81 4d 00 00 	mov	r13,	0(r1)	;

0000778a <.Loc.314.3>:
  eventflags_t sts = 0;
    778a:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    778e:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00007792 <.Loc.316.3>:
  if (sra & UCOE)
    7792:	1c 41 02 00 	mov	2(r1),	r12	;
    7796:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    779a:	0c 93       	cmp	#0,	r12	;r3 As==00
    779c:	05 24       	jz	$+12     	;abs 0x77a8

0000779e <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    779e:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    77a2:	04 00 
    77a4:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077a8 <.L56>:
  if (sra & UCPE)
    77a8:	1c 41 02 00 	mov	2(r1),	r12	;
    77ac:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    77b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    77b2:	05 24       	jz	$+12     	;abs 0x77be

000077b4 <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    77b4:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    77b8:	04 00 
    77ba:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077be <.L57>:
  if (sra & UCFE)
    77be:	1c 41 02 00 	mov	2(r1),	r12	;
    77c2:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    77c6:	0c 93       	cmp	#0,	r12	;r3 As==00
    77c8:	05 24       	jz	$+12     	;abs 0x77d4

000077ca <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    77ca:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    77ce:	04 00 
    77d0:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

000077d4 <.L58>:
  osalSysLockFromISR();
    77d4:	b0 12 b8 73 	call	#29624		;#0x73b8

000077d8 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    77d8:	2c 41       	mov	@r1,	r12	;
    77da:	2c 53       	incd	r12		;
    77dc:	1d 41 04 00 	mov	4(r1),	r13	;
    77e0:	1e 41 06 00 	mov	6(r1),	r14	;
    77e4:	b0 12 d0 73 	call	#29648		;#0x73d0

000077e8 <.Loc.324.3>:
  osalSysUnlockFromISR();
    77e8:	b0 12 c4 73 	call	#29636		;#0x73c4

000077ec <.Loc.325.3>:
}
    77ec:	03 43       	nop			
    77ee:	31 52       	add	#8,	r1	;r2 As==11
    77f0:	30 41       	ret			

000077f2 <sd_lld_init>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
#endif

#if MSP430X_SERIAL_USE_USART1 == TRUE
  sdObjectInit(&SD1, NULL, notify1);
    77f2:	3e 40 6a 77 	mov	#30570,	r14	;#0x776a
    77f6:	4d 43       	clr.b	r13		;
    77f8:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    77fc:	b0 12 f2 71 	call	#29170		;#0x71f2

00007800 <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    7800:	03 43       	nop			
    7802:	30 41       	ret			

00007804 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7804:	21 82       	sub	#4,	r1	;r2 As==10

00007806 <.LCFI11>:
    7806:	81 4c 02 00 	mov	r12,	2(r1)	;
    780a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000780e <.Loc.603.3>:

  if (config == NULL) {
    780e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7812:	03 20       	jnz	$+8      	;abs 0x781a

00007814 <.Loc.604.3>:
    config = &default_config;
    7814:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7818:	00 00 

0000781a <.L74>:
  if (&SD0 == sdp) {
    usart0_init(config);
  }
#endif
#if MSP430X_SERIAL_USE_USART1 == TRUE
  if (&SD1 == sdp) {
    781a:	b1 90 fe 51 	cmp	#20990,	2(r1)	;#0x51fe
    781e:	02 00 
    7820:	03 20       	jnz	$+8      	;abs 0x7828

00007822 <.Loc.614.3>:
    usart1_init(config);
    7822:	2c 41       	mov	@r1,	r12	;
    7824:	b0 12 18 77 	call	#30488		;#0x7718

00007828 <.L76>:
#if MSP430X_SERIAL_USE_USART3 == TRUE
  if (&SD3 == sdp) {
    usart3_init(config);
  }
#endif
}
    7828:	03 43       	nop			
    782a:	21 52       	add	#4,	r1	;r2 As==10
    782c:	30 41       	ret			

0000782e <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    782e:	21 83       	decd	r1		;

00007830 <.LCFI8>:
    7830:	81 4c 00 00 	mov	r12,	0(r1)	;

00007834 <.Loc.309.1>:

  PAOUT = config->porta.out;
    7834:	2c 41       	mov	@r1,	r12	;
    7836:	2c 4c       	mov	@r12,	r12	;
    7838:	82 4c 02 02 	mov	r12,	&0x0202	;

0000783c <.Loc.310.1>:
  PADIR = config->porta.dir;
    783c:	2c 41       	mov	@r1,	r12	;
    783e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7842:	82 4c 04 02 	mov	r12,	&0x0204	;

00007846 <.Loc.311.1>:
  PAREN = config->porta.ren;
    7846:	2c 41       	mov	@r1,	r12	;
    7848:	1c 4c 04 00 	mov	4(r12),	r12	;
    784c:	82 4c 06 02 	mov	r12,	&0x0206	;

00007850 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7850:	2c 41       	mov	@r1,	r12	;
    7852:	1c 4c 06 00 	mov	6(r12),	r12	;
    7856:	82 4c 0a 02 	mov	r12,	&0x020a	;

0000785a <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    785a:	2c 41       	mov	@r1,	r12	;
    785c:	1c 4c 08 00 	mov	8(r12),	r12	;
    7860:	82 4c 0c 02 	mov	r12,	&0x020c	;

00007864 <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    7864:	2c 41       	mov	@r1,	r12	;
    7866:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    786a:	82 4c 22 02 	mov	r12,	&0x0222	;

0000786e <.Loc.316.1>:
  PBDIR = config->portb.dir;
    786e:	2c 41       	mov	@r1,	r12	;
    7870:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7874:	82 4c 24 02 	mov	r12,	&0x0224	;

00007878 <.Loc.317.1>:
  PBREN = config->portb.ren;
    7878:	2c 41       	mov	@r1,	r12	;
    787a:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    787e:	82 4c 26 02 	mov	r12,	&0x0226	;

00007882 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7882:	2c 41       	mov	@r1,	r12	;
    7884:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    7888:	82 4c 2a 02 	mov	r12,	&0x022a	;

0000788c <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    788c:	2c 41       	mov	@r1,	r12	;
    788e:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7892:	82 4c 2c 02 	mov	r12,	&0x022c	;

00007896 <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    7896:	2c 41       	mov	@r1,	r12	;
    7898:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    789c:	82 4c 22 03 	mov	r12,	&0x0322	;

000078a0 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    78a0:	2c 41       	mov	@r1,	r12	;
    78a2:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    78a6:	82 4c 24 03 	mov	r12,	&0x0324	;

000078aa <.Loc.351.1>:
  PJREN = config->portj.ren;
    78aa:	2c 41       	mov	@r1,	r12	;
    78ac:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    78b0:	82 4c 26 03 	mov	r12,	&0x0326	;

000078b4 <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    78b4:	2c 41       	mov	@r1,	r12	;
    78b6:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    78ba:	82 4c 2a 03 	mov	r12,	&0x032a	;

000078be <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    78be:	2c 41       	mov	@r1,	r12	;
    78c0:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    78c4:	82 4c 2c 03 	mov	r12,	&0x032c	;

000078c8 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    78c8:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    78cc:	1c c3       	bic	#1,	r12	;r3 As==01
    78ce:	82 4c 30 01 	mov	r12,	&0x0130	;

000078d2 <.Loc.356.1>:
}
    78d2:	03 43       	nop			
    78d4:	21 53       	incd	r1		;
    78d6:	30 41       	ret			

000078d8 <_pal_lld_enablepadevent>:
      break;
  }
}

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    78d8:	0a 15       	pushm	#1,	r10	;16-bit words

000078da <.LCFI10>:
    78da:	31 82       	sub	#8,	r1	;r2 As==11

000078dc <.LCFI11>:
    78dc:	81 4c 04 00 	mov	r12,	4(r1)	;
    78e0:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    78e4:	c1 4e 02 00 	mov.b	r14,	2(r1)	;
    78e8:	81 4f 00 00 	mov	r15,	0(r1)	;

000078ec <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    78ec:	1c 41 04 00 	mov	4(r1),	r12	;
    78f0:	43 18 0c 11 	rpt #4 { rrax.w	r12		;
    78f4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    78f8:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    78fc:	4d 4c       	mov.b	r12,	r13	;
    78fe:	7c 40 07 00 	mov.b	#7,	r12	;
    7902:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7906:	02 2c       	jc	$+6      	;abs 0x790c

00007908 <.Loc.448.1>:
    7908:	6c 43       	mov.b	#2,	r12	;r3 As==10
    790a:	01 3c       	jmp	$+4      	;abs 0x790e

0000790c <.L42>:
    790c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000790e <.L43>:
    790e:	4e 4d       	mov.b	r13,	r14	;
    7910:	4e 5c       	add.b	r12,	r14	;
    7912:	c1 4e 07 00 	mov.b	r14,	7(r1)	;

00007916 <.Loc.450.1>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    7916:	5c 41 07 00 	mov.b	7(r1),	r12	;
    791a:	3c 53       	add	#-1,	r12	;r3 As==11
    791c:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7920:	7d f0 07 00 	and.b	#7,	r13	;
    7924:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    7928:	0c 5d       	add	r13,	r12	;
    792a:	0c 5c       	rla	r12		;
    792c:	3c 50 4a 52 	add	#21066,	r12	;#0x524a
    7930:	ac 41 00 00 	mov	@r1,	0(r12)	;

00007934 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    7934:	d1 93 02 00 	cmp.b	#1,	2(r1)	;r3 As==01
    7938:	11 20       	jnz	$+36     	;abs 0x795c

0000793a <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    793a:	1c 41 04 00 	mov	4(r1),	r12	;
    793e:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    7942:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7946:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7948:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    794c:	3c e3       	inv	r12		;
    794e:	0d 4a       	mov	r10,	r13	;
    7950:	0d fc       	and	r12,	r13	;
    7952:	1c 41 04 00 	mov	4(r1),	r12	;
    7956:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018
    795a:	12 3c       	jmp	$+38     	;abs 0x7980

0000795c <.L44>:
  }
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    795c:	e1 93 02 00 	cmp.b	#2,	2(r1)	;r3 As==10
    7960:	0f 20       	jnz	$+32     	;abs 0x7980

00007962 <.Loc.456.1>:
    port->ies |= (1 << pad);
    7962:	1c 41 04 00 	mov	4(r1),	r12	;
    7966:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    796a:	5d 41 03 00 	mov.b	3(r1),	r13	;
    796e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7970:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    7974:	0d 4a       	mov	r10,	r13	;
    7976:	0d dc       	bis	r12,	r13	;
    7978:	1c 41 04 00 	mov	4(r1),	r12	;
    797c:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018

00007980 <.L45>:
  }
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    7980:	c1 93 02 00 	cmp.b	#0,	2(r1)	;r3 As==00
    7984:	11 20       	jnz	$+36     	;abs 0x79a8

00007986 <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    7986:	1c 41 04 00 	mov	4(r1),	r12	;
    798a:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    798e:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7992:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7994:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    7998:	3c e3       	inv	r12		;
    799a:	0d 4a       	mov	r10,	r13	;
    799c:	0d fc       	and	r12,	r13	;
    799e:	1c 41 04 00 	mov	4(r1),	r12	;
    79a2:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

000079a6 <.Loc.466.1>:
  }
  else {
    port->ifg &= ~(1 << pad);
    port->ie |= (1 << pad);
  }
}
    79a6:	1f 3c       	jmp	$+64     	;abs 0x79e6

000079a8 <.L46>:
    port->ifg &= ~(1 << pad);
    79a8:	1c 41 04 00 	mov	4(r1),	r12	;
    79ac:	1a 4c 1c 00 	mov	28(r12),r10	;0x0001c
    79b0:	5d 41 03 00 	mov.b	3(r1),	r13	;
    79b4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    79b6:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    79ba:	3c e3       	inv	r12		;
    79bc:	0d 4a       	mov	r10,	r13	;
    79be:	0d fc       	and	r12,	r13	;
    79c0:	1c 41 04 00 	mov	4(r1),	r12	;
    79c4:	8c 4d 1c 00 	mov	r13,	28(r12)	; 0x001c

000079c8 <.Loc.464.1>:
    port->ie |= (1 << pad);
    79c8:	1c 41 04 00 	mov	4(r1),	r12	;
    79cc:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    79d0:	5d 41 03 00 	mov.b	3(r1),	r13	;
    79d4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    79d6:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    79da:	0d 4a       	mov	r10,	r13	;
    79dc:	0d dc       	bis	r12,	r13	;
    79de:	1c 41 04 00 	mov	4(r1),	r12	;
    79e2:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

000079e6 <.L48>:
}
    79e6:	03 43       	nop			
    79e8:	31 52       	add	#8,	r1	;r2 As==11
    79ea:	0a 17       	popm	#1,	r10	;16-bit words
    79ec:	30 41       	ret			

000079ee <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    79ee:	0a 15       	pushm	#1,	r10	;16-bit words

000079f0 <.LCFI12>:
    79f0:	21 82       	sub	#4,	r1	;r2 As==10

000079f2 <.LCFI13>:
    79f2:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

000079f4 <L0>:
    79f4:	02 00       	mova	@r0,	r2	;
    79f6:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000079fa <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    79fa:	1c 41 02 00 	mov	2(r1),	r12	;
    79fe:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    7a02:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7a06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7a08:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    7a0c:	3c e3       	inv	r12		;
    7a0e:	0d 4a       	mov	r10,	r13	;
    7a10:	0d fc       	and	r12,	r13	;
    7a12:	1c 41 02 00 	mov	2(r1),	r12	;
    7a16:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00007a1a <.Loc.471.1>:
}
    7a1a:	03 43       	nop			
    7a1c:	21 52       	add	#4,	r1	;r2 As==10
    7a1e:	0a 17       	popm	#1,	r10	;16-bit words
    7a20:	30 41       	ret			

00007a22 <osalSysGetStatusAndLockX>:
  return chSysGetStatusAndLockX();
    7a22:	b0 12 3e 65 	call	#25918		;#0x653e

00007a26 <.Loc.556.2>:
}
    7a26:	30 41       	ret			

00007a28 <osalSysRestoreStatusX>:
static inline void osalSysRestoreStatusX(syssts_t sts) {
    7a28:	21 83       	decd	r1		;

00007a2a <.LCFI0>:
    7a2a:	81 4c 00 00 	mov	r12,	0(r1)	;

00007a2e <.Loc.569.2>:
  chSysRestoreStatusX(sts);
    7a2e:	2c 41       	mov	@r1,	r12	;
    7a30:	b0 12 7a 65 	call	#25978		;#0x657a

00007a34 <.Loc.570.2>:
}
    7a34:	03 43       	nop			
    7a36:	21 53       	incd	r1		;
    7a38:	30 41       	ret			

00007a3a <osalThreadQueueObjectInit>:
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    7a3a:	21 83       	decd	r1		;

00007a3c <.LCFI1>:
    7a3c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007a40 <.Loc.767.2>:
  chSemObjectInit(&tqp->sem, (cnt_t)0);
    7a40:	2c 41       	mov	@r1,	r12	;
    7a42:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00007a46 <.Loc.768.2>:
}
    7a46:	03 43       	nop			
    7a48:	21 53       	incd	r1		;
    7a4a:	30 41       	ret			

00007a4c <osalThreadEnqueueTimeoutS>:
                                              systime_t time) {
    7a4c:	21 82       	sub	#4,	r1	;r2 As==10

00007a4e <.LCFI2>:
    7a4e:	81 4c 02 00 	mov	r12,	2(r1)	;
    7a52:	81 4d 00 00 	mov	r13,	0(r1)	;

00007a56 <.Loc.796.2>:
  return chSemWaitTimeoutS(&tqp->sem, time);
    7a56:	1c 41 02 00 	mov	2(r1),	r12	;
    7a5a:	2d 41       	mov	@r1,	r13	;
    7a5c:	b0 12 0c 67 	call	#26380		;#0x670c

00007a60 <.Loc.797.2>:
}
    7a60:	21 52       	add	#4,	r1	;r2 As==10
    7a62:	30 41       	ret			

00007a64 <dma_trigger_set>:
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    7a64:	0a 15       	pushm	#1,	r10	;16-bit words

00007a66 <.LCFI3>:
    7a66:	21 82       	sub	#4,	r1	;r2 As==10

00007a68 <.LCFI4>:
    7a68:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    7a6c:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

00007a70 <.Loc.62.3>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    7a70:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a74:	12 c3       	clrc			
    7a76:	0c 10       	rrc	r12		;
    7a78:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7a7c:	0c 5c       	rla	r12		;
    7a7e:	0d 4c       	mov	r12,	r13	;
    7a80:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    7a84:	81 4d 02 00 	mov	r13,	2(r1)	;

00007a88 <.Loc.63.3>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    7a88:	1c 41 02 00 	mov	2(r1),	r12	;
    7a8c:	2a 4c       	mov	@r12,	r10	;
    7a8e:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7a92:	5c f3       	and.b	#1,	r12	;r3 As==01
    7a94:	0d 4c       	mov	r12,	r13	;
    7a96:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7a9a:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00
    7a9e:	b0 12 c6 90 	call	#-28474	;#0x90c6
    7aa2:	0d 4a       	mov	r10,	r13	;
    7aa4:	0d fc       	and	r12,	r13	;
    7aa6:	1c 41 02 00 	mov	2(r1),	r12	;
    7aaa:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007aae <.Loc.64.3>:
  *ctl |= trigger << (8 * (index % 2));
    7aae:	1c 41 02 00 	mov	2(r1),	r12	;
    7ab2:	2a 4c       	mov	@r12,	r10	;
    7ab4:	6c 41       	mov.b	@r1,	r12	;
    7ab6:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7aba:	5d f3       	and.b	#1,	r13	;r3 As==01
    7abc:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7ac0:	b0 12 be 8f 	call	#-28738	;#0x8fbe
    7ac4:	0d 4a       	mov	r10,	r13	;
    7ac6:	0d dc       	bis	r12,	r13	;
    7ac8:	1c 41 02 00 	mov	2(r1),	r12	;
    7acc:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007ad0 <.Loc.65.3>:
}
    7ad0:	03 43       	nop			
    7ad2:	21 52       	add	#4,	r1	;r2 As==10
    7ad4:	0a 17       	popm	#1,	r10	;16-bit words
    7ad6:	30 41       	ret			

00007ad8 <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    7ad8:	3c 40 f4 5c 	mov	#23796,	r12	;#0x5cf4
    7adc:	b0 12 3a 7a 	call	#31290		;#0x7a3a

00007ae0 <.Loc.106.3>:
}
    7ae0:	03 43       	nop			
    7ae2:	30 41       	ret			

00007ae4 <dmaAcquireTimeoutS>:
  
  return MSG_OK;
}
#endif

msg_t dmaAcquireTimeoutS(msp430x_dma_ch_t * channel, systime_t timeout) {
    7ae4:	31 80 06 00 	sub	#6,	r1	;

00007ae8 <.LCFI7>:
    7ae8:	81 4c 02 00 	mov	r12,	2(r1)	;
    7aec:	81 4d 00 00 	mov	r13,	0(r1)	;

00007af0 <.Loc.161.3>:
  osalDbgCheckClassS();
    7af0:	b0 12 c2 63 	call	#25538		;#0x63c2

00007af4 <.Loc.163.3>:
  
  msg_t result = dmaAcquireI(channel);
    7af4:	1c 41 02 00 	mov	2(r1),	r12	;
    7af8:	b0 12 28 7b 	call	#31528		;#0x7b28
    7afc:	81 4c 04 00 	mov	r12,	4(r1)	;

00007b00 <.Loc.165.3>:
  
  if (MSG_OK != result) {
    7b00:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    7b04:	0c 24       	jz	$+26     	;abs 0x7b1e

00007b06 <.Loc.166.3>:
    if (TIME_IMMEDIATE == timeout) {
    7b06:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    7b0a:	02 20       	jnz	$+6      	;abs 0x7b10

00007b0c <.Loc.167.3>:
      return MSG_TIMEOUT;
    7b0c:	3c 43       	mov	#-1,	r12	;r3 As==11
    7b0e:	09 3c       	jmp	$+20     	;abs 0x7b22

00007b10 <.L18>:
    }
    result = osalThreadEnqueueTimeoutS(&dma_queue, timeout);
    7b10:	2d 41       	mov	@r1,	r13	;
    7b12:	3c 40 f4 5c 	mov	#23796,	r12	;#0x5cf4
    7b16:	b0 12 4c 7a 	call	#31308		;#0x7a4c
    7b1a:	81 4c 04 00 	mov	r12,	4(r1)	;

00007b1e <.L17>:
  }
  return result;
    7b1e:	1c 41 04 00 	mov	4(r1),	r12	;

00007b22 <.L19>:
}
    7b22:	31 50 06 00 	add	#6,	r1	;
    7b26:	30 41       	ret			

00007b28 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    7b28:	21 82       	sub	#4,	r1	;r2 As==10

00007b2a <L0>:
    7b2a:	81 4c 00 00 	mov	r12,	0(r1)	;

00007b2e <.Loc.190.3>:
  

  /* Grab the correct DMA channel to use */
  int i = 0;
    7b2e:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00

00007b32 <.Loc.191.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7b32:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    7b36:	0e 3c       	jmp	$+30     	;abs 0x7b54

00007b38 <.L24>:
    if (!(dma_regs[i].ctl & DMAEN)) {
    7b38:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7b3c:	1c 41 02 00 	mov	2(r1),	r12	;
    7b40:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7b44:	0c 5d       	add	r13,	r12	;
    7b46:	2c 4c       	mov	@r12,	r12	;
    7b48:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7b4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b4e:	07 24       	jz	$+16     	;abs 0x7b5e

00007b50 <.Loc.191.3>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7b50:	91 53 02 00 	inc	2(r1)		;

00007b54 <.L21>:
    7b54:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7b56:	1c 91 02 00 	cmp	2(r1),	r12	;
    7b5a:	ee 37       	jge	$-34     	;abs 0x7b38
    7b5c:	01 3c       	jmp	$+4      	;abs 0x7b60

00007b5e <.L27>:
      break;
    7b5e:	03 43       	nop			

00007b60 <.L23>:
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    7b60:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7b62:	1c 91 02 00 	cmp	2(r1),	r12	;
    7b66:	02 34       	jge	$+6      	;abs 0x7b6c

00007b68 <.Loc.198.3>:
    return MSG_TIMEOUT;
    7b68:	3c 43       	mov	#-1,	r12	;r3 As==11
    7b6a:	2b 3c       	jmp	$+88     	;abs 0x7bc2

00007b6c <.L25>:
  }
  
  /* Acquire the channel in an idle mode */
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    7b6c:	1c 41 02 00 	mov	2(r1),	r12	;
    7b70:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7b74:	4d 43       	clr.b	r13		;
    7b76:	b0 12 64 7a 	call	#31332		;#0x7a64

00007b7a <.Loc.203.3>:
  dma_regs[i].sz  = 0;
    7b7a:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7b7e:	1c 41 02 00 	mov	2(r1),	r12	;
    7b82:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7b86:	0c 5d       	add	r13,	r12	;
    7b88:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007b8c <.Loc.204.3>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    7b8c:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7b90:	1c 41 02 00 	mov	2(r1),	r12	;
    7b94:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7b98:	0c 5d       	add	r13,	r12	;
    7b9a:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    7b9e:	00 00 

00007ba0 <.Loc.206.3>:

  channel->registers = dma_regs + i;
    7ba0:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7ba4:	1c 41 02 00 	mov	2(r1),	r12	;
    7ba8:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7bac:	0d 5c       	add	r12,	r13	;
    7bae:	2c 41       	mov	@r1,	r12	;
    7bb0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007bb4 <.Loc.207.3>:
  channel->index     = i;
    7bb4:	1c 41 02 00 	mov	2(r1),	r12	;
    7bb8:	4d 4c       	mov.b	r12,	r13	;
    7bba:	2c 41       	mov	@r1,	r12	;
    7bbc:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00007bc0 <.Loc.209.3>:
  
  return MSG_OK;
    7bc0:	4c 43       	clr.b	r12		;

00007bc2 <.L26>:
}
    7bc2:	21 52       	add	#4,	r1	;r2 As==10
    7bc4:	30 41       	ret			

00007bc6 <dmaClaimI>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    7bc6:	21 82       	sub	#4,	r1	;r2 As==10

00007bc8 <.LCFI9>:
    7bc8:	81 4c 02 00 	mov	r12,	2(r1)	;

00007bcc <L0>:
    7bcc:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007bd0 <.Loc.230.3>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_regs[index].ctl & DMAEN) {
    7bd0:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7bd4:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7bd8:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7bdc:	0c 5d       	add	r13,	r12	;
    7bde:	2c 4c       	mov	@r12,	r12	;
    7be0:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7be4:	0c 93       	cmp	#0,	r12	;r3 As==00
    7be6:	02 24       	jz	$+6      	;abs 0x7bec

00007be8 <.Loc.231.3>:
    return MSG_TIMEOUT;
    7be8:	3c 43       	mov	#-1,	r12	;r3 As==11
    7bea:	29 3c       	jmp	$+84     	;abs 0x7c3e

00007bec <.L29>:
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    7bec:	4d 43       	clr.b	r13		;
    7bee:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7bf2:	b0 12 64 7a 	call	#31332		;#0x7a64

00007bf6 <.Loc.236.3>:
  dma_regs[index].sz  = 0;
    7bf6:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7bfa:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7bfe:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7c02:	0c 5d       	add	r13,	r12	;
    7c04:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007c08 <.Loc.237.3>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    7c08:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7c0c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c10:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7c14:	0c 5d       	add	r13,	r12	;
    7c16:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    7c1a:	00 00 

00007c1c <.Loc.239.3>:

  channel->registers = dma_regs + index;
    7c1c:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7c20:	5c 41 01 00 	mov.b	1(r1),	r12	;
    7c24:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7c28:	0d 5c       	add	r12,	r13	;
    7c2a:	1c 41 02 00 	mov	2(r1),	r12	;
    7c2e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007c32 <.Loc.240.3>:
  channel->index     = index;
    7c32:	1c 41 02 00 	mov	2(r1),	r12	;
    7c36:	dc 41 01 00 	mov.b	1(r1),	2(r12)	;
    7c3a:	02 00 

00007c3c <.Loc.242.3>:
  
  return MSG_OK;
    7c3c:	4c 43       	clr.b	r12		;

00007c3e <.L30>:
}
    7c3e:	21 52       	add	#4,	r1	;r2 As==10
    7c40:	30 41       	ret			

00007c42 <dmaTransferI>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    7c42:	21 82       	sub	#4,	r1	;r2 As==10

00007c44 <L0>:
    7c44:	81 4c 02 00 	mov	r12,	2(r1)	;
    7c48:	81 4d 00 00 	mov	r13,	0(r1)	;

00007c4c <.Loc.273.3>:


  channel->registers->ctl &= (~DMAEN);
    7c4c:	1c 41 02 00 	mov	2(r1),	r12	;
    7c50:	2c 4c       	mov	@r12,	r12	;
    7c52:	1d 41 02 00 	mov	2(r1),	r13	;
    7c56:	2d 4d       	mov	@r13,	r13	;
    7c58:	2d 4d       	mov	@r13,	r13	;
    7c5a:	3d f0 ef ff 	and	#-17,	r13	;#0xffef
    7c5e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007c62 <.Loc.274.3>:
  dma_trigger_set(channel->index, request->trigger);
    7c62:	1c 41 02 00 	mov	2(r1),	r12	;
    7c66:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    7c6a:	2d 41       	mov	@r1,	r13	;
    7c6c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    7c70:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    7c74:	b0 12 64 7a 	call	#31332		;#0x7a64

00007c78 <.Loc.275.3>:
  callbacks[channel->index] = request->callback;
    7c78:	1c 41 02 00 	mov	2(r1),	r12	;
    7c7c:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    7c80:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7c84:	3c 50 e8 5c 	add	#23784,	r12	;#0x5ce8
    7c88:	2d 41       	mov	@r1,	r13	;
    7c8a:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    7c8e:	00 00 
    7c90:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    7c94:	02 00 

00007c96 <.Loc.281.3>:

#if defined(__MSP430X_LARGE__)
  asm ("movx.a %1, %0" : "=m"(channel->registers->sa) : "g"(request->source_addr) : );
  asm ("movx.a %1, %0" : "=m"(channel->registers->da) : "g"(request->dest_addr) : );
#else
  channel->registers->sa  = (uintptr_t)request->source_addr;
    7c96:	1c 41 02 00 	mov	2(r1),	r12	;
    7c9a:	2e 4c       	mov	@r12,	r14	;
    7c9c:	2c 41       	mov	@r1,	r12	;
    7c9e:	2c 4c       	mov	@r12,	r12	;
    7ca0:	0d 43       	clr	r13		;
    7ca2:	8e 4c 02 00 	mov	r12,	2(r14)	;
    7ca6:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007caa <.Loc.282.3>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    7caa:	1c 41 02 00 	mov	2(r1),	r12	;
    7cae:	2e 4c       	mov	@r12,	r14	;
    7cb0:	2c 41       	mov	@r1,	r12	;
    7cb2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7cb6:	0d 43       	clr	r13		;
    7cb8:	8e 4c 06 00 	mov	r12,	6(r14)	;
    7cbc:	8e 4d 08 00 	mov	r13,	8(r14)	;

00007cc0 <.Loc.284.3>:
#endif
  channel->registers->sz  = request->size;
    7cc0:	1c 41 02 00 	mov	2(r1),	r12	;
    7cc4:	2c 4c       	mov	@r12,	r12	;
    7cc6:	2d 41       	mov	@r1,	r13	;
    7cc8:	1d 4d 04 00 	mov	4(r13),	r13	;
    7ccc:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007cd0 <.Loc.285.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7cd0:	1c 41 02 00 	mov	2(r1),	r12	;
    7cd4:	2c 4c       	mov	@r12,	r12	;
    7cd6:	2d 41       	mov	@r1,	r13	;
    7cd8:	1e 4d 08 00 	mov	8(r13),	r14	;
    7cdc:	2d 41       	mov	@r1,	r13	;
    7cde:	1d 4d 06 00 	mov	6(r13),	r13	;
    7ce2:	0e dd       	bis	r13,	r14	;

00007ce4 <.Loc.286.3>:
                            request->transfer_mode | DMAEN |
    7ce4:	2d 41       	mov	@r1,	r13	;
    7ce6:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a

00007cea <.Loc.285.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7cea:	0d de       	bis	r14,	r13	;

00007cec <.Loc.286.3>:
                            request->transfer_mode | DMAEN |
    7cec:	3d d0 15 00 	bis	#21,	r13	;#0x0015

00007cf0 <.Loc.285.3>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    7cf0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007cf4 <.Loc.288.3>:
                            DMAREQ;
}
    7cf4:	03 43       	nop			
    7cf6:	21 52       	add	#4,	r1	;r2 As==10
    7cf8:	30 41       	ret			

00007cfa <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    7cfa:	21 82       	sub	#4,	r1	;r2 As==10

00007cfc <.LCFI12>:
    7cfc:	81 4c 00 00 	mov	r12,	0(r1)	;

00007d00 <.Loc.302.3>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
    7d00:	b0 12 22 7a 	call	#31266		;#0x7a22
    7d04:	81 4c 02 00 	mov	r12,	2(r1)	;

00007d08 <.Loc.305.3>:
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    7d08:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7d0c:	14 24       	jz	$+42     	;abs 0x7d36

00007d0e <.Loc.305.3>:
    7d0e:	2c 41       	mov	@r1,	r12	;
    7d10:	2c 4c       	mov	@r12,	r12	;
    7d12:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d14:	10 24       	jz	$+34     	;abs 0x7d36

00007d16 <.Loc.305.3>:
    7d16:	2c 41       	mov	@r1,	r12	;
    7d18:	2c 4c       	mov	@r12,	r12	;
    7d1a:	2c 4c       	mov	@r12,	r12	;
    7d1c:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7d20:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d22:	09 24       	jz	$+20     	;abs 0x7d36

00007d24 <.Loc.308.3>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    7d24:	2c 41       	mov	@r1,	r12	;
    7d26:	2c 4c       	mov	@r12,	r12	;
    7d28:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

00007d2c <.Loc.311.3>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7d2c:	4d 43       	clr.b	r13		;
    7d2e:	3c 40 f4 5c 	mov	#23796,	r12	;#0x5cf4
    7d32:	b0 12 64 68 	call	#26724		;#0x6864

00007d36 <.L34>:
  }
  osalSysRestoreStatusX(sts);
    7d36:	1c 41 02 00 	mov	2(r1),	r12	;
    7d3a:	b0 12 28 7a 	call	#31272		;#0x7a28

00007d3e <.Loc.314.3>:
}
    7d3e:	03 43       	nop			
    7d40:	21 52       	add	#4,	r1	;r2 As==10
    7d42:	30 41       	ret			

00007d44 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    7d44:	21 83       	decd	r1		;

00007d46 <.LCFI13>:
    7d46:	81 4c 00 00 	mov	r12,	0(r1)	;

00007d4a <.Loc.329.3>:
  
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    7d4a:	2c 41       	mov	@r1,	r12	;
    7d4c:	2c 4c       	mov	@r12,	r12	;
    7d4e:	2c 4c       	mov	@r12,	r12	;
    7d50:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7d54:	0c 93       	cmp	#0,	r12	;r3 As==00
    7d56:	19 24       	jz	$+52     	;abs 0x7d8a

00007d58 <.Loc.334.3>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    7d58:	2c 41       	mov	@r1,	r12	;
    7d5a:	2c 4c       	mov	@r12,	r12	;
    7d5c:	2d 41       	mov	@r1,	r13	;
    7d5e:	2d 4d       	mov	@r13,	r13	;
    7d60:	2d 4d       	mov	@r13,	r13	;
    7d62:	3d f0 ee ff 	and	#-18,	r13	;#0xffee
    7d66:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007d6a <.Loc.336.3>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    7d6a:	2c 41       	mov	@r1,	r12	;
    7d6c:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    7d70:	4d 43       	clr.b	r13		;
    7d72:	b0 12 64 7a 	call	#31332		;#0x7a64

00007d76 <.Loc.337.3>:
  channel->registers->sz  = 0;
    7d76:	2c 41       	mov	@r1,	r12	;
    7d78:	2c 4c       	mov	@r12,	r12	;
    7d7a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00007d7e <.Loc.338.3>:
  channel->registers->ctl = DMAEN | DMAABORT;
    7d7e:	2c 41       	mov	@r1,	r12	;
    7d80:	2c 4c       	mov	@r12,	r12	;
    7d82:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    7d86:	00 00 
    7d88:	01 3c       	jmp	$+4      	;abs 0x7d8c

00007d8a <.L38>:
    return;
    7d8a:	03 43       	nop			

00007d8c <.L35>:
}
    7d8c:	21 53       	incd	r1		;
    7d8e:	30 41       	ret			

00007d90 <port_lock_from_isr>:
}
    7d90:	03 43       	nop			

00007d92 <L0>:
    7d92:	30 41       	ret			

00007d94 <port_unlock_from_isr>:
}
    7d94:	03 43       	nop			
    7d96:	30 41       	ret			

00007d98 <osalSysLockFromISR>:
  chSysLockFromISR();
    7d98:	b0 12 90 7d 	call	#32144		;#0x7d90
    7d9c:	b0 12 00 63 	call	#25344		;#0x6300

00007da0 <.Loc.527.2>:
}
    7da0:	03 43       	nop			
    7da2:	30 41       	ret			

00007da4 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    7da4:	b0 12 22 63 	call	#25378		;#0x6322
    7da8:	b0 12 94 7d 	call	#32148		;#0x7d94

00007dac <.Loc.538.2>:
}
    7dac:	03 43       	nop			
    7dae:	30 41       	ret			

00007db0 <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7db0:	21 82       	sub	#4,	r1	;r2 As==10

00007db2 <.LCFI0>:
    7db2:	81 4c 02 00 	mov	r12,	2(r1)	;
    7db6:	81 4d 00 00 	mov	r13,	0(r1)	;

00007dba <.Loc.739.2>:
  chThdResumeI(trp, msg);
    7dba:	2d 41       	mov	@r1,	r13	;
    7dbc:	1c 41 02 00 	mov	2(r1),	r12	;
    7dc0:	b0 12 b0 66 	call	#26288		;#0x66b0

00007dc4 <.Loc.740.2>:
}
    7dc4:	03 43       	nop			
    7dc6:	21 52       	add	#4,	r1	;r2 As==10
    7dc8:	30 41       	ret			

00007dca <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    7dca:	21 82       	sub	#4,	r1	;r2 As==10

00007dcc <.LCFI2>:
    7dcc:	81 4c 00 00 	mov	r12,	0(r1)	;

00007dd0 <.Loc.129.3>:
  SPIDriver * spip = (SPIDriver *)(arg);
    7dd0:	a1 41 02 00 	mov	@r1,	2(r1)	;

00007dd4 <.Loc.132.3>:

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    7dd4:	1c 41 02 00 	mov	2(r1),	r12	;
    7dd8:	1c 4c 08 00 	mov	8(r12),	r12	;
    7ddc:	1d 41 02 00 	mov	2(r1),	r13	;
    7de0:	1d 4d 08 00 	mov	8(r13),	r13	;
    7de4:	2d 4d       	mov	@r13,	r13	;
    7de6:	2d c3       	bic	#2,	r13	;r3 As==10
    7de8:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007dec <.Loc.136.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    7dec:	1c 41 02 00 	mov	2(r1),	r12	;
    7df0:	1c 4c 02 00 	mov	2(r12),	r12	;
    7df4:	2c 4c       	mov	@r12,	r12	;
    7df6:	0c 93       	cmp	#0,	r12	;r3 As==00
    7df8:	16 24       	jz	$+46     	;abs 0x7e26

00007dfa <.Loc.136.3>:
    7dfa:	1c 41 02 00 	mov	2(r1),	r12	;
    7dfe:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7e02:	1c 41 02 00 	mov	2(r1),	r12	;
    7e06:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e0a:	2d 4c       	mov	@r12,	r13	;
    7e0c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e10:	8d 12       	call	r13		;
    7e12:	1c 41 02 00 	mov	2(r1),	r12	;
    7e16:	6c 4c       	mov.b	@r12,	r12	;
    7e18:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7e1a:	09 20       	jnz	$+20     	;abs 0x7e2e

00007e1c <.Loc.136.3>:
    7e1c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e20:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7e24:	04 3c       	jmp	$+10     	;abs 0x7e2e

00007e26 <.L12>:
    7e26:	1c 41 02 00 	mov	2(r1),	r12	;
    7e2a:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007e2e <.L14>:
    7e2e:	b0 12 98 7d 	call	#32152		;#0x7d98
    7e32:	1c 41 02 00 	mov	2(r1),	r12	;
    7e36:	2c 52       	add	#4,	r12	;r2 As==10
    7e38:	4d 43       	clr.b	r13		;
    7e3a:	b0 12 b0 7d 	call	#32176		;#0x7db0
    7e3e:	b0 12 a4 7d 	call	#32164		;#0x7da4

00007e42 <.Loc.138.3>:
  
  if (spip->state == SPI_READY) {
    7e42:	1c 41 02 00 	mov	2(r1),	r12	;
    7e46:	6c 4c       	mov.b	@r12,	r12	;
    7e48:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    7e4a:	0c 20       	jnz	$+26     	;abs 0x7e64

00007e4c <.Loc.139.3>:
    dmaReleaseX(&(spip->dmarx));
    7e4c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e50:	3c 50 34 00 	add	#52,	r12	;#0x0034
    7e54:	b0 12 fa 7c 	call	#31994		;#0x7cfa

00007e58 <.Loc.140.3>:
    dmaReleaseX(&(spip->dmatx));
    7e58:	1c 41 02 00 	mov	2(r1),	r12	;
    7e5c:	3c 50 2e 00 	add	#46,	r12	;#0x002e
    7e60:	b0 12 fa 7c 	call	#31994		;#0x7cfa

00007e64 <.L16>:
  }
}
    7e64:	03 43       	nop			
    7e66:	21 52       	add	#4,	r1	;r2 As==10
    7e68:	30 41       	ret			

00007e6a <spi_lld_init>:
 */
void spi_lld_init(void) {

#if MSP430X_SPI_USE_SPIA0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA0);
    7e6a:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00007e6c <L0>:
    7e6c:	8a 52 b0 12 	add	r2,	4784(r10); 0x12b0
    7e70:	1c 73       	subc	#1,	r12	;r3 As==01

00007e72 <.Loc.161.3>:
  SPIDA0.regs                     = (msp430x_spi_reg_t *)(&UCA0CTLW0);
    7e72:	b2 40 c0 05 	mov	#1472,	&0x5290	;#0x05c0
    7e76:	90 52 

00007e78 <.Loc.162.3>:
  SPIDA0.ifg                      = (volatile uint16_t *)&UCA0IFG;
    7e78:	b2 40 dc 05 	mov	#1500,	&0x5292	;#0x05dc
    7e7c:	92 52 

00007e7e <.Loc.163.3>:
  SPIDA0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA0TXIFG);
    7e7e:	b2 40 0f 00 	mov	#15,	&0x52a0	;#0x000f
    7e82:	a0 52 

00007e84 <.Loc.164.3>:
  SPIDA0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA0RXIFG);
    7e84:	b2 40 0e 00 	mov	#14,	&0x52b2	;#0x000e
    7e88:	b2 52 

00007e8a <.Loc.165.3>:
  SPIDA0.tx_req.dest_addr         = &(SPIDA0.regs->txbuf);
    7e8a:	1c 42 90 52 	mov	&0x5290,r12	;0x5290
    7e8e:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7e92:	82 4c 96 52 	mov	r12,	&0x5296	;

00007e96 <.Loc.166.3>:
  SPIDA0.rx_req.source_addr       = &(SPIDA0.regs->rxbuf);
    7e96:	1c 42 90 52 	mov	&0x5290,r12	;0x5290
    7e9a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7e9e:	82 4c a6 52 	mov	r12,	&0x52a6	;

00007ea2 <.Loc.167.3>:
  SPIDA0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7ea2:	b2 40 c0 00 	mov	#192,	&0x529c	;#0x00c0
    7ea6:	9c 52 

00007ea8 <.Loc.168.3>:
  SPIDA0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7ea8:	b2 40 c0 00 	mov	#192,	&0x52ae	;#0x00c0
    7eac:	ae 52 

00007eae <.Loc.169.3>:
  SPIDA0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7eae:	82 43 9e 52 	mov	#0,	&0x529e	;r3 As==00

00007eb2 <.Loc.170.3>:
  SPIDA0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7eb2:	82 43 b0 52 	mov	#0,	&0x52b0	;r3 As==00

00007eb6 <.Loc.171.3>:
  SPIDA0.tx_req.callback.callback = NULL;
    7eb6:	82 43 a2 52 	mov	#0,	&0x52a2	;r3 As==00

00007eba <.Loc.172.3>:
  SPIDA0.tx_req.callback.args     = NULL;
    7eba:	82 43 a4 52 	mov	#0,	&0x52a4	;r3 As==00

00007ebe <.Loc.173.3>:
  SPIDA0.rx_req.callback.callback = spi_lld_end_of_transfer;
    7ebe:	b2 40 ca 7d 	mov	#32202,	&0x52b4	;#0x7dca
    7ec2:	b4 52 

00007ec4 <.Loc.174.3>:
  SPIDA0.rx_req.callback.args     = &SPIDA0;
    7ec4:	b2 40 8a 52 	mov	#21130,	&0x52b6	;#0x528a
    7ec8:	b6 52 

00007eca <.Loc.239.3>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    7eca:	3c 40 c4 52 	mov	#21188,	r12	;#0x52c4
    7ece:	b0 12 1c 73 	call	#29468		;#0x731c

00007ed2 <.Loc.240.3>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    7ed2:	b2 40 40 06 	mov	#1600,	&0x52ca	;#0x0640
    7ed6:	ca 52 

00007ed8 <.Loc.241.3>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    7ed8:	b2 40 6c 06 	mov	#1644,	&0x52cc	;#0x066c
    7edc:	cc 52 

00007ede <.Loc.242.3>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    7ede:	b2 40 13 00 	mov	#19,	&0x52da	;#0x0013
    7ee2:	da 52 

00007ee4 <.Loc.243.3>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    7ee4:	b2 40 12 00 	mov	#18,	&0x52ec	;#0x0012
    7ee8:	ec 52 

00007eea <.Loc.244.3>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    7eea:	1c 42 ca 52 	mov	&0x52ca,r12	;0x52ca
    7eee:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7ef2:	82 4c d0 52 	mov	r12,	&0x52d0	;

00007ef6 <.Loc.245.3>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    7ef6:	1c 42 ca 52 	mov	&0x52ca,r12	;0x52ca
    7efa:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7efe:	82 4c e0 52 	mov	r12,	&0x52e0	;

00007f02 <.Loc.246.3>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7f02:	b2 40 c0 00 	mov	#192,	&0x52d6	;#0x00c0
    7f06:	d6 52 

00007f08 <.Loc.247.3>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7f08:	b2 40 c0 00 	mov	#192,	&0x52e8	;#0x00c0
    7f0c:	e8 52 

00007f0e <.Loc.248.3>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7f0e:	82 43 d8 52 	mov	#0,	&0x52d8	;r3 As==00

00007f12 <.Loc.249.3>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7f12:	82 43 ea 52 	mov	#0,	&0x52ea	;r3 As==00

00007f16 <.Loc.250.3>:
  SPIDB0.tx_req.callback.callback = NULL;
    7f16:	82 43 dc 52 	mov	#0,	&0x52dc	;r3 As==00

00007f1a <.Loc.251.3>:
  SPIDB0.tx_req.callback.args     = NULL;
    7f1a:	82 43 de 52 	mov	#0,	&0x52de	;r3 As==00

00007f1e <.Loc.252.3>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    7f1e:	b2 40 ca 7d 	mov	#32202,	&0x52ee	;#0x7dca
    7f22:	ee 52 

00007f24 <.Loc.253.3>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    7f24:	b2 40 c4 52 	mov	#21188,	&0x52f0	;#0x52c4
    7f28:	f0 52 

00007f2a <.Loc.312.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    7f2a:	03 43       	nop			
    7f2c:	30 41       	ret			

00007f2e <port_lock_from_isr>:
}
    7f2e:	03 43       	nop			
    7f30:	30 41       	ret			

00007f32 <port_unlock_from_isr>:
}
    7f32:	03 43       	nop			
    7f34:	30 41       	ret			

00007f36 <osalSysLockFromISR>:
  chSysLockFromISR();
    7f36:	b0 12 2e 7f 	call	#32558		;#0x7f2e
    7f3a:	b0 12 00 63 	call	#25344		;#0x6300

00007f3e <.Loc.527.2>:
}
    7f3e:	03 43       	nop			
    7f40:	30 41       	ret			

00007f42 <osalSysUnlockFromISR>:
  chSysUnlockFromISR();
    7f42:	b0 12 22 63 	call	#25378		;#0x6322
    7f46:	b0 12 32 7f 	call	#32562		;#0x7f32

00007f4a <.Loc.538.2>:
}
    7f4a:	03 43       	nop			
    7f4c:	30 41       	ret			

00007f4e <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7f4e:	21 82       	sub	#4,	r1	;r2 As==10

00007f50 <.LCFI0>:
    7f50:	81 4c 02 00 	mov	r12,	2(r1)	;
    7f54:	81 4d 00 00 	mov	r13,	0(r1)	;

00007f58 <.Loc.739.2>:
  chThdResumeI(trp, msg);
    7f58:	2d 41       	mov	@r1,	r13	;
    7f5a:	1c 41 02 00 	mov	2(r1),	r12	;
    7f5e:	b0 12 b0 66 	call	#26288		;#0x66b0

00007f62 <.Loc.740.2>:
}
    7f62:	03 43       	nop			
    7f64:	21 52       	add	#4,	r1	;r2 As==10
    7f66:	30 41       	ret			

00007f68 <restart_dma>:
static void restart_dma(ADCDriver * adcp) {
    7f68:	21 83       	decd	r1		;

00007f6a <.LCFI1>:
    7f6a:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f6e <.Loc.55.3>:
  osalSysLockFromISR();
    7f6e:	b0 12 36 7f 	call	#32566		;#0x7f36

00007f72 <.Loc.56.3>:
  dmaTransferI(&(adcp->dma), &(adcp->req));
    7f72:	2c 41       	mov	@r1,	r12	;
    7f74:	3c 50 26 00 	add	#38,	r12	;#0x0026
    7f78:	2d 41       	mov	@r1,	r13	;
    7f7a:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    7f7e:	b0 12 42 7c 	call	#31810		;#0x7c42

00007f82 <.Loc.57.3>:
  osalSysUnlockFromISR();
    7f82:	b0 12 42 7f 	call	#32578		;#0x7f42

00007f86 <.Loc.58.3>:
}
    7f86:	03 43       	nop			
    7f88:	21 53       	incd	r1		;
    7f8a:	30 41       	ret			

00007f8c <dma_callback>:
static void dma_callback(void * args) {
    7f8c:	0a 15       	pushm	#1,	r10	;16-bit words

00007f8e <.LCFI2>:
    7f8e:	31 82       	sub	#8,	r1	;r2 As==11

00007f90 <.LCFI3>:
    7f90:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f94 <.Loc.61.3>:
  ADCDriver * adcp = (ADCDriver *)args;
    7f94:	a1 41 06 00 	mov	@r1,	6(r1)	;

00007f98 <.Loc.63.3>:
  if (adcp->grpp == NULL)
    7f98:	1c 41 06 00 	mov	6(r1),	r12	;
    7f9c:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fa0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fa2:	1f 25       	jz	$+576    	;abs 0x81e2

00007fa4 <.Loc.66.3>:
  adcp->count++;
    7fa4:	1c 41 06 00 	mov	6(r1),	r12	;
    7fa8:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7fac:	5c 53       	inc.b	r12		;
    7fae:	4d 4c       	mov.b	r12,	r13	;
    7fb0:	1c 41 06 00 	mov	6(r1),	r12	;
    7fb4:	cc 4d 24 00 	mov.b	r13,	36(r12)	; 0x0024

00007fb8 <.Loc.68.3>:
  if (adcp->count == adcp->depth / 2) {
    7fb8:	1c 41 06 00 	mov	6(r1),	r12	;
    7fbc:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    7fc0:	0d 4c       	mov	r12,	r13	;
    7fc2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fc6:	1c 4c 06 00 	mov	6(r12),	r12	;
    7fca:	12 c3       	clrc			
    7fcc:	0c 10       	rrc	r12		;
    7fce:	0d 9c       	cmp	r12,	r13	;
    7fd0:	1d 20       	jnz	$+60     	;abs 0x800c

00007fd2 <.Loc.70.3>:
    _adc_isr_half_code(adcp);
    7fd2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fd6:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fda:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fde:	0c 93       	cmp	#0,	r12	;r3 As==00
    7fe0:	15 24       	jz	$+44     	;abs 0x800c

00007fe2 <.Loc.70.3>:
    7fe2:	1c 41 06 00 	mov	6(r1),	r12	;
    7fe6:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fea:	1f 4c 02 00 	mov	2(r12),	r15	;
    7fee:	1c 41 06 00 	mov	6(r1),	r12	;
    7ff2:	1c 4c 04 00 	mov	4(r12),	r12	;
    7ff6:	1d 41 06 00 	mov	6(r1),	r13	;
    7ffa:	1d 4d 06 00 	mov	6(r13),	r13	;
    7ffe:	12 c3       	clrc			
    8000:	0d 10       	rrc	r13		;
    8002:	0e 4d       	mov	r13,	r14	;
    8004:	0d 4c       	mov	r12,	r13	;
    8006:	1c 41 06 00 	mov	6(r1),	r12	;
    800a:	8f 12       	call	r15		;

0000800c <.L10>:
  if (adcp->count == adcp->depth) {
    800c:	1c 41 06 00 	mov	6(r1),	r12	;
    8010:	5c 4c 24 00 	mov.b	36(r12),r12	;0x00024
    8014:	0d 4c       	mov	r12,	r13	;
    8016:	1c 41 06 00 	mov	6(r1),	r12	;
    801a:	1c 4c 06 00 	mov	6(r12),	r12	;
    801e:	0d 9c       	cmp	r12,	r13	;
    8020:	ba 20       	jnz	$+374    	;abs 0x8196

00008022 <.Loc.77.3>:
    _adc_isr_full_code(adcp);
    8022:	1c 41 06 00 	mov	6(r1),	r12	;
    8026:	1c 4c 08 00 	mov	8(r12),	r12	;
    802a:	6c 4c       	mov.b	@r12,	r12	;
    802c:	0c 93       	cmp	#0,	r12	;r3 As==00
    802e:	4c 24       	jz	$+154    	;abs 0x80c8

00008030 <.Loc.77.3>:
    8030:	1c 41 06 00 	mov	6(r1),	r12	;
    8034:	1c 4c 08 00 	mov	8(r12),	r12	;
    8038:	1c 4c 02 00 	mov	2(r12),	r12	;
    803c:	0c 93       	cmp	#0,	r12	;r3 As==00
    803e:	88 24       	jz	$+274    	;abs 0x8150

00008040 <.Loc.77.3>:
    8040:	1c 41 06 00 	mov	6(r1),	r12	;
    8044:	1d 4c 06 00 	mov	6(r12),	r13	;
    8048:	5c 43       	mov.b	#1,	r12	;r3 As==01
    804a:	0c 9d       	cmp	r13,	r12	;
    804c:	29 2c       	jc	$+84     	;abs 0x80a0

0000804e <.LBB2>:
    804e:	1c 41 06 00 	mov	6(r1),	r12	;
    8052:	1c 4c 06 00 	mov	6(r12),	r12	;
    8056:	b0 12 ba 90 	call	#-28486	;#0x90ba
    805a:	81 4c 04 00 	mov	r12,	4(r1)	;
    805e:	1c 41 06 00 	mov	6(r1),	r12	;
    8062:	1c 4c 08 00 	mov	8(r12),	r12	;
    8066:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    806a:	1d 41 04 00 	mov	4(r1),	r13	;
    806e:	b0 12 36 91 	call	#-28362	;#0x9136
    8072:	81 4c 02 00 	mov	r12,	2(r1)	;
    8076:	1c 41 06 00 	mov	6(r1),	r12	;
    807a:	1c 4c 08 00 	mov	8(r12),	r12	;
    807e:	1f 4c 02 00 	mov	2(r12),	r15	;
    8082:	1c 41 06 00 	mov	6(r1),	r12	;
    8086:	1d 4c 04 00 	mov	4(r12),	r13	;
    808a:	1c 41 02 00 	mov	2(r1),	r12	;
    808e:	0c 5c       	rla	r12		;
    8090:	0c 5d       	add	r13,	r12	;
    8092:	1e 41 04 00 	mov	4(r1),	r14	;
    8096:	0d 4c       	mov	r12,	r13	;
    8098:	1c 41 06 00 	mov	6(r1),	r12	;
    809c:	8f 12       	call	r15		;

0000809e <.LBE2>:
    809e:	58 3c       	jmp	$+178    	;abs 0x8150

000080a0 <.L14>:
    80a0:	1c 41 06 00 	mov	6(r1),	r12	;
    80a4:	1c 4c 08 00 	mov	8(r12),	r12	;
    80a8:	1f 4c 02 00 	mov	2(r12),	r15	;
    80ac:	1c 41 06 00 	mov	6(r1),	r12	;
    80b0:	1c 4c 04 00 	mov	4(r12),	r12	;
    80b4:	1d 41 06 00 	mov	6(r1),	r13	;
    80b8:	1d 4d 06 00 	mov	6(r13),	r13	;
    80bc:	0e 4d       	mov	r13,	r14	;
    80be:	0d 4c       	mov	r12,	r13	;
    80c0:	1c 41 06 00 	mov	6(r1),	r12	;
    80c4:	8f 12       	call	r15		;
    80c6:	44 3c       	jmp	$+138    	;abs 0x8150

000080c8 <.L12>:
    80c8:	1c 41 06 00 	mov	6(r1),	r12	;
    80cc:	b0 12 9c 84 	call	#-31588	;#0x849c
    80d0:	1c 41 06 00 	mov	6(r1),	r12	;
    80d4:	1c 4c 08 00 	mov	8(r12),	r12	;
    80d8:	1c 4c 02 00 	mov	2(r12),	r12	;
    80dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    80de:	25 24       	jz	$+76     	;abs 0x812a

000080e0 <.Loc.77.3>:
    80e0:	1c 41 06 00 	mov	6(r1),	r12	;
    80e4:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    80e8:	1c 41 06 00 	mov	6(r1),	r12	;
    80ec:	1c 4c 08 00 	mov	8(r12),	r12	;
    80f0:	1f 4c 02 00 	mov	2(r12),	r15	;
    80f4:	1c 41 06 00 	mov	6(r1),	r12	;
    80f8:	1c 4c 04 00 	mov	4(r12),	r12	;
    80fc:	1d 41 06 00 	mov	6(r1),	r13	;
    8100:	1d 4d 06 00 	mov	6(r13),	r13	;
    8104:	0e 4d       	mov	r13,	r14	;
    8106:	0d 4c       	mov	r12,	r13	;
    8108:	1c 41 06 00 	mov	6(r1),	r12	;
    810c:	8f 12       	call	r15		;
    810e:	1c 41 06 00 	mov	6(r1),	r12	;
    8112:	6c 4c       	mov.b	@r12,	r12	;
    8114:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    8116:	11 20       	jnz	$+36     	;abs 0x813a

00008118 <.Loc.77.3>:
    8118:	1c 41 06 00 	mov	6(r1),	r12	;
    811c:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    8120:	1c 41 06 00 	mov	6(r1),	r12	;
    8124:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    8128:	08 3c       	jmp	$+18     	;abs 0x813a

0000812a <.L16>:
    812a:	1c 41 06 00 	mov	6(r1),	r12	;
    812e:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    8132:	1c 41 06 00 	mov	6(r1),	r12	;
    8136:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

0000813a <.L18>:
    813a:	b0 12 36 7f 	call	#32566		;#0x7f36
    813e:	1c 41 06 00 	mov	6(r1),	r12	;
    8142:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    8146:	4d 43       	clr.b	r13		;
    8148:	b0 12 4e 7f 	call	#32590		;#0x7f4e
    814c:	b0 12 42 7f 	call	#32578		;#0x7f42

00008150 <.L15>:
    if (adcp->grpp) {
    8150:	1c 41 06 00 	mov	6(r1),	r12	;
    8154:	1c 4c 08 00 	mov	8(r12),	r12	;
    8158:	0c 93       	cmp	#0,	r12	;r3 As==00
    815a:	44 24       	jz	$+138    	;abs 0x81e4

0000815c <.Loc.81.3>:
      adcp->req.dest_addr = adcp->samples;
    815c:	1c 41 06 00 	mov	6(r1),	r12	;
    8160:	1d 4c 04 00 	mov	4(r12),	r13	;
    8164:	1c 41 06 00 	mov	6(r1),	r12	;
    8168:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

0000816c <.Loc.83.3>:
      restart_dma(adcp);
    816c:	1c 41 06 00 	mov	6(r1),	r12	;
    8170:	b0 12 68 7f 	call	#32616		;#0x7f68

00008174 <.Loc.86.3>:
      adcp->count = 0;
    8174:	1c 41 06 00 	mov	6(r1),	r12	;
    8178:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

0000817c <.Loc.89.3>:
      adcp->regs->ctl[0] |= ADC12SC;
    817c:	1c 41 06 00 	mov	6(r1),	r12	;
    8180:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8184:	1d 41 06 00 	mov	6(r1),	r13	;
    8188:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    818c:	2d 4d       	mov	@r13,	r13	;
    818e:	1d d3       	bis	#1,	r13	;r3 As==01
    8190:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8194:	27 3c       	jmp	$+80     	;abs 0x81e4

00008196 <.L11>:
    adcp->req.dest_addr = adcp->samples + (adcp->req.size * adcp->count);
    8196:	1c 41 06 00 	mov	6(r1),	r12	;
    819a:	1a 4c 04 00 	mov	4(r12),	r10	;
    819e:	1c 41 06 00 	mov	6(r1),	r12	;
    81a2:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    81a6:	1d 41 06 00 	mov	6(r1),	r13	;
    81aa:	5d 4d 24 00 	mov.b	36(r13),r13	;0x00024
    81ae:	b0 12 36 91 	call	#-28362	;#0x9136
    81b2:	0c 5c       	rla	r12		;
    81b4:	0d 4a       	mov	r10,	r13	;
    81b6:	0d 5c       	add	r12,	r13	;
    81b8:	1c 41 06 00 	mov	6(r1),	r12	;
    81bc:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

000081c0 <.Loc.96.3>:
    restart_dma(adcp);
    81c0:	1c 41 06 00 	mov	6(r1),	r12	;
    81c4:	b0 12 68 7f 	call	#32616		;#0x7f68

000081c8 <.Loc.99.3>:
    adcp->regs->ctl[0] |= ADC12SC;
    81c8:	1c 41 06 00 	mov	6(r1),	r12	;
    81cc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    81d0:	1d 41 06 00 	mov	6(r1),	r13	;
    81d4:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    81d8:	2d 4d       	mov	@r13,	r13	;
    81da:	1d d3       	bis	#1,	r13	;r3 As==01
    81dc:	8c 4d 00 00 	mov	r13,	0(r12)	;
    81e0:	01 3c       	jmp	$+4      	;abs 0x81e4

000081e2 <.L20>:
    return;
    81e2:	03 43       	nop			

000081e4 <.L7>:
}
    81e4:	31 52       	add	#8,	r1	;r2 As==11
    81e6:	0a 17       	popm	#1,	r10	;16-bit words
    81e8:	30 41       	ret			

000081ea <populate_tlv>:
static void populate_tlv(ADCDriver * adcp) {
    81ea:	21 82       	sub	#4,	r1	;r2 As==10

000081ec <.LCFI4>:
    81ec:	81 4c 00 00 	mov	r12,	0(r1)	;

000081f0 <.Loc.104.3>:
  uint8_t * tlv_addr = (uint8_t *)TLV_START;
    81f0:	b1 40 08 1a 	mov	#6664		;#0x1a08, Warning: disassembly unreliable - not enough bytes available

000081f4 <L0>:
    81f4:	02 00       	mova	@r0,	r2	;

000081f6 <.Loc.106.3>:
  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    81f6:	20 3c       	jmp	$+66     	;abs 0x8238

000081f8 <.L26>:
    if (*tlv_addr == TLV_ADC12CAL) {
    81f8:	1c 41 02 00 	mov	2(r1),	r12	;
    81fc:	6c 4c       	mov.b	@r12,	r12	;
    81fe:	7c 90 11 00 	cmp.b	#17,	r12	;#0x0011
    8202:	07 20       	jnz	$+16     	;abs 0x8212

00008204 <.Loc.108.3>:
      adcp->adc_cal = (msp430x_adc_cal_t *)(tlv_addr + 2);
    8204:	1d 41 02 00 	mov	2(r1),	r13	;
    8208:	2d 53       	incd	r13		;
    820a:	2c 41       	mov	@r1,	r12	;
    820c:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020
    8210:	0c 3c       	jmp	$+26     	;abs 0x822a

00008212 <.L23>:
    else if (*tlv_addr == TLV_REFCAL) {
    8212:	1c 41 02 00 	mov	2(r1),	r12	;
    8216:	6c 4c       	mov.b	@r12,	r12	;
    8218:	7c 90 12 00 	cmp.b	#18,	r12	;#0x0012
    821c:	06 20       	jnz	$+14     	;abs 0x822a

0000821e <.Loc.111.3>:
      adcp->ref_cal = (msp430x_ref_cal_t *)(tlv_addr + 2);
    821e:	1d 41 02 00 	mov	2(r1),	r13	;
    8222:	2d 53       	incd	r13		;
    8224:	2c 41       	mov	@r1,	r12	;
    8226:	8c 4d 22 00 	mov	r13,	34(r12)	; 0x0022

0000822a <.L24>:
    tlv_addr += (tlv_addr[1] + 2);
    822a:	1c 41 02 00 	mov	2(r1),	r12	;
    822e:	1c 53       	inc	r12		;
    8230:	6c 4c       	mov.b	@r12,	r12	;
    8232:	2c 53       	incd	r12		;
    8234:	81 5c 02 00 	add	r12,	2(r1)	;

00008238 <.L22>:
  while (*tlv_addr != TLV_TAGEND && tlv_addr < (uint8_t *)TLV_END) {
    8238:	1c 41 02 00 	mov	2(r1),	r12	;
    823c:	6c 4c       	mov.b	@r12,	r12	;
    823e:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    8240:	05 24       	jz	$+12     	;abs 0x824c

00008242 <.Loc.106.3>:
    8242:	3c 40 fe 1a 	mov	#6910,	r12	;#0x1afe
    8246:	1c 91 02 00 	cmp	2(r1),	r12	;
    824a:	d6 2f       	jc	$-82     	;abs 0x81f8

0000824c <.L27>:
}
    824c:	03 43       	nop			
    824e:	21 52       	add	#4,	r1	;r2 As==10
    8250:	30 41       	ret			

00008252 <adc_lld_init>:
 */
void adc_lld_init(void) {

#if MSP430X_ADC_USE_ADC1 == TRUE
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    8252:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe

00008256 <L0>:
    8256:	b0 12 42 6f 	call	#28482		;#0x6f42

0000825a <.Loc.161.3>:
  ADCD1.regs = (msp430x_adc_reg_t *)(&ADC12CTL0);
    825a:	b2 40 00 08 	mov	#2048,	&0x530a	;#0x0800
    825e:	0a 53 

00008260 <.Loc.162.3>:
  populate_tlv(&ADCD1);
    8260:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    8264:	b0 12 ea 81 	call	#-32278	;#0x81ea

00008268 <.Loc.164.3>:
#endif
}
    8268:	03 43       	nop			
    826a:	30 41       	ret			

0000826c <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver * adcp) {
    826c:	21 82       	sub	#4,	r1	;r2 As==10

0000826e <.LCFI6>:
    826e:	81 4c 00 00 	mov	r12,	0(r1)	;

00008272 <.Loc.175.3>:

  if (adcp->state == ADC_STOP) {
    8272:	2c 41       	mov	@r1,	r12	;
    8274:	6c 4c       	mov.b	@r12,	r12	;
    8276:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    8278:	2d 20       	jnz	$+92     	;abs 0x82d4

0000827a <.Loc.177.3>:
    /* Enables the peripheral.*/
    adcp->regs->ctl[0] = ADC12ON | ADC12MSC;
    827a:	2c 41       	mov	@r1,	r12	;
    827c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8280:	bc 40 90 00 	mov	#144,	0(r12)	;#0x0090
    8284:	00 00 

00008286 <.Loc.178.3>:
    adcp->regs->ctl[1] =
    8286:	2c 41       	mov	@r1,	r12	;
    8288:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    828c:	bc 40 60 62 	mov	#25184,	2(r12)	;#0x6260
    8290:	02 00 

00008292 <.Loc.180.3>:
        MSP430X_ADC1_PDIV | MSP430X_ADC1_DIV | MSP430X_ADC1_SSEL | ADC12SHP;
    adcp->regs->ctl[3] = ADC12ICH3MAP | ADC12ICH2MAP | ADC12ICH1MAP |
    8292:	2c 41       	mov	@r1,	r12	;
    8294:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8298:	bc 40 c0 0f 	mov	#4032,	6(r12)	;#0x0fc0
    829c:	06 00 

0000829e <.Loc.182.3>:
                         ADC12ICH0MAP | ADC12TCMAP | ADC12BATMAP;
    adcp->regs->ier[2] = ADC12TOVIE | ADC12OVIE;
    829e:	2c 41       	mov	@r1,	r12	;
    82a0:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    82a4:	bc 40 30 00 	mov	#48,	22(r12)	;#0x0030, 0x0016
    82a8:	16 00 

000082aa <.Loc.183.3>:
    adcp->req.trigger  = DMA_TRIGGER_MNEM(ADC12IFG);
    82aa:	2c 41       	mov	@r1,	r12	;
    82ac:	bc 40 1a 00 	mov	#26,	26(r12)	;#0x001a, 0x001a
    82b0:	1a 00 

000082b2 <.Loc.187.3>:
#if MSP430X_ADC_COMPACT_SAMPLES == TRUE
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTBYTE;
#else
    adcp->req.data_mode = MSP430X_DMA_SRCWORD | MSP430X_DMA_DSTWORD;
    82b2:	2c 41       	mov	@r1,	r12	;
    82b4:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016

000082b8 <.Loc.189.3>:
#endif
    adcp->req.addr_mode         = MSP430X_DMA_SRCINCR | MSP430X_DMA_DSTINCR;
    82b8:	2c 41       	mov	@r1,	r12	;
    82ba:	bc 40 00 0f 	mov	#3840,	20(r12)	;#0x0f00, 0x0014
    82be:	14 00 

000082c0 <.Loc.190.3>:
    adcp->req.transfer_mode     = MSP430X_DMA_SINGLE;
    82c0:	2c 41       	mov	@r1,	r12	;
    82c2:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

000082c6 <.Loc.191.3>:
    adcp->req.callback.callback = dma_callback;
    82c6:	2c 41       	mov	@r1,	r12	;
    82c8:	bc 40 8c 7f 	mov	#32652,	28(r12)	;#0x7f8c, 0x001c
    82cc:	1c 00 

000082ce <.Loc.192.3>:
    adcp->req.callback.args     = adcp;
    82ce:	2c 41       	mov	@r1,	r12	;
    82d0:	ac 41 1e 00 	mov	@r1,	30(r12)	; 0x001e

000082d4 <.L50>:

  }
  /* Configures the peripheral.*/
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  bool b;
  dmaReleaseX(&(adcp->dma));
    82d4:	2c 41       	mov	@r1,	r12	;
    82d6:	3c 50 26 00 	add	#38,	r12	;#0x0026
    82da:	b0 12 fa 7c 	call	#31994		;#0x7cfa

000082de <.Loc.199.3>:
  if (adcp->config->dma_index < MSP430X_DMA_CHANNELS) {
    82de:	2c 41       	mov	@r1,	r12	;
    82e0:	1c 4c 02 00 	mov	2(r12),	r12	;
    82e4:	6c 4c       	mov.b	@r12,	r12	;
    82e6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    82e8:	4d 9c       	cmp.b	r12,	r13	;
    82ea:	11 28       	jnc	$+36     	;abs 0x830e

000082ec <.Loc.200.3>:
    b = dmaClaimI(&adcp->dma, adcp->config->dma_index);
    82ec:	2c 41       	mov	@r1,	r12	;
    82ee:	3c 50 26 00 	add	#38,	r12	;#0x0026
    82f2:	2d 41       	mov	@r1,	r13	;
    82f4:	1d 4d 02 00 	mov	2(r13),	r13	;
    82f8:	6d 4d       	mov.b	@r13,	r13	;
    82fa:	b0 12 c6 7b 	call	#31686		;#0x7bc6
    82fe:	0d 43       	clr	r13		;
    8300:	0d 8c       	sub	r12,	r13	;
    8302:	0c dd       	bis	r13,	r12	;
    8304:	5c 03       	rrum	#1,	r12	;
    8306:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    830a:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

0000830e <.L52>:
    osalDbgAssert(!b, "stream already allocated");
  }
#endif
}
    830e:	03 43       	nop			
    8310:	21 52       	add	#4,	r1	;r2 As==10
    8312:	30 41       	ret			

00008314 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver * adcp) {
    8314:	21 82       	sub	#4,	r1	;r2 As==10

00008316 <.LCFI8>:
    8316:	81 4c 00 00 	mov	r12,	0(r1)	;

0000831a <.Loc.234.3>:

  /* always use sequential transfer mode - this is fine */
  adcp->regs->ctl[1] |= ADC12CONSEQ0;
    831a:	2c 41       	mov	@r1,	r12	;
    831c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8320:	2d 41       	mov	@r1,	r13	;
    8322:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8326:	1d 4d 02 00 	mov	2(r13),	r13	;
    832a:	2d d3       	bis	#2,	r13	;r3 As==10
    832c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008330 <.Loc.237.3>:

  /* set resolution */
  adcp->regs->ctl[2] |= adcp->grpp->res;
    8330:	2c 41       	mov	@r1,	r12	;
    8332:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8336:	2d 41       	mov	@r1,	r13	;
    8338:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    833c:	1e 4d 04 00 	mov	4(r13),	r14	;
    8340:	2d 41       	mov	@r1,	r13	;
    8342:	1d 4d 08 00 	mov	8(r13),	r13	;
    8346:	5d 4d 26 00 	mov.b	38(r13),r13	;0x00026
    834a:	0d de       	bis	r14,	r13	;
    834c:	8c 4d 04 00 	mov	r13,	4(r12)	;

00008350 <.Loc.239.3>:
  /* start from MEM0 */
  adcp->regs->ctl[3] &= ~(ADC12CSTARTADD_31);
    8350:	2c 41       	mov	@r1,	r12	;
    8352:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8356:	2d 41       	mov	@r1,	r13	;
    8358:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    835c:	1d 4d 06 00 	mov	6(r13),	r13	;
    8360:	3d f0 e0 ff 	and	#-32,	r13	;#0xffe0
    8364:	8c 4d 06 00 	mov	r13,	6(r12)	;

00008368 <.Loc.242.3>:

  /* Configure voltage reference */
  while (REFCTL0 & REFGENBUSY)
    8368:	03 43       	nop			

0000836a <.L57>:
    836a:	1c 42 b0 01 	mov	&0x01b0,r12	;0x01b0
    836e:	3c f0 00 04 	and	#1024,	r12	;#0x0400
    8372:	0c 93       	cmp	#0,	r12	;r3 As==00
    8374:	fa 23       	jnz	$-10     	;abs 0x836a

00008376 <.Loc.244.3>:
    ;
  REFCTL0 = adcp->grpp->vref_src;
    8376:	2c 41       	mov	@r1,	r12	;
    8378:	1c 4c 08 00 	mov	8(r12),	r12	;
    837c:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    8380:	82 4c b0 01 	mov	r12,	&0x01b0	;

00008384 <.LBB3>:

  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    8384:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    8388:	1b 3c       	jmp	$+56     	;abs 0x83c0

0000838a <.L59>:
    osalDbgAssert(adcp->grpp->channels[i] < 32, "invalid channel number");
    adcp->regs->mctl[i] = adcp->grpp->ref | adcp->grpp->channels[i];
    838a:	2c 41       	mov	@r1,	r12	;
    838c:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    8390:	2c 41       	mov	@r1,	r12	;
    8392:	1c 4c 08 00 	mov	8(r12),	r12	;
    8396:	1d 4c 2a 00 	mov	42(r12),r13	;0x0002a
    839a:	2c 41       	mov	@r1,	r12	;
    839c:	1c 4c 08 00 	mov	8(r12),	r12	;
    83a0:	1c 51 02 00 	add	2(r1),	r12	;
    83a4:	3c 50 06 00 	add	#6,	r12	;
    83a8:	6c 4c       	mov.b	@r12,	r12	;
    83aa:	0d dc       	bis	r12,	r13	;
    83ac:	1c 41 02 00 	mov	2(r1),	r12	;
    83b0:	3c 50 10 00 	add	#16,	r12	;#0x0010
    83b4:	0c 5c       	rla	r12		;
    83b6:	0c 5e       	add	r14,	r12	;
    83b8:	8c 4d 00 00 	mov	r13,	0(r12)	;

000083bc <.Loc.246.3>:
  for (int i = 0; i < adcp->grpp->num_channels; i++) {
    83bc:	91 53 02 00 	inc	2(r1)		;

000083c0 <.L58>:
    83c0:	2c 41       	mov	@r1,	r12	;
    83c2:	1c 4c 08 00 	mov	8(r12),	r12	;
    83c6:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    83ca:	81 9c 02 00 	cmp	r12,	2(r1)	;
    83ce:	dd 3b       	jl	$-68     	;abs 0x838a

000083d0 <.LBE3>:
  }

  adcp->regs->mctl[adcp->grpp->num_channels - 1] |= ADC12EOS;
    83d0:	2c 41       	mov	@r1,	r12	;
    83d2:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    83d6:	2c 41       	mov	@r1,	r12	;
    83d8:	1c 4c 08 00 	mov	8(r12),	r12	;
    83dc:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    83e0:	0f 4c       	mov	r12,	r15	;
    83e2:	3f 53       	add	#-1,	r15	;r3 As==11
    83e4:	2c 41       	mov	@r1,	r12	;
    83e6:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    83ea:	2c 41       	mov	@r1,	r12	;
    83ec:	1c 4c 08 00 	mov	8(r12),	r12	;
    83f0:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    83f4:	3c 53       	add	#-1,	r12	;r3 As==11
    83f6:	3c 50 10 00 	add	#16,	r12	;#0x0010
    83fa:	0c 5c       	rla	r12		;
    83fc:	0c 5d       	add	r13,	r12	;
    83fe:	2c 4c       	mov	@r12,	r12	;
    8400:	0d 4c       	mov	r12,	r13	;
    8402:	3d d0 80 00 	bis	#128,	r13	;#0x0080
    8406:	0c 4f       	mov	r15,	r12	;
    8408:	3c 50 10 00 	add	#16,	r12	;#0x0010
    840c:	0c 5c       	rla	r12		;
    840e:	0c 5e       	add	r14,	r12	;
    8410:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008414 <.Loc.253.3>:

  adcp->req.source_addr = adcp->regs->mem;
    8414:	2c 41       	mov	@r1,	r12	;
    8416:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    841a:	0d 4c       	mov	r12,	r13	;
    841c:	3d 50 60 00 	add	#96,	r13	;#0x0060
    8420:	2c 41       	mov	@r1,	r12	;
    8422:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008426 <.Loc.254.3>:
  adcp->req.dest_addr   = adcp->samples;
    8426:	2c 41       	mov	@r1,	r12	;
    8428:	1d 4c 04 00 	mov	4(r12),	r13	;
    842c:	2c 41       	mov	@r1,	r12	;
    842e:	8c 4d 10 00 	mov	r13,	16(r12)	; 0x0010

00008432 <.Loc.255.3>:
  adcp->req.size        = adcp->grpp->num_channels;
    8432:	2c 41       	mov	@r1,	r12	;
    8434:	1c 4c 08 00 	mov	8(r12),	r12	;
    8438:	5c 4c 01 00 	mov.b	1(r12),	r12	;
    843c:	0d 4c       	mov	r12,	r13	;
    843e:	2c 41       	mov	@r1,	r12	;
    8440:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00008444 <.Loc.256.3>:
  adcp->count           = 0;
    8444:	2c 41       	mov	@r1,	r12	;
    8446:	cc 43 24 00 	mov.b	#0,	36(r12)	;r3 As==00, 0x0024

0000844a <.Loc.260.3>:

/* TODO timeouts? */
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    844a:	2c 41       	mov	@r1,	r12	;
    844c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8450:	6c 4c       	mov.b	@r12,	r12	;
    8452:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8454:	4d 9c       	cmp.b	r12,	r13	;
    8456:	06 2c       	jc	$+14     	;abs 0x8464

00008458 <.Loc.262.3>:
#endif
    dmaAcquireTimeoutS(&(adcp->dma), TIME_INFINITE);
    8458:	2c 41       	mov	@r1,	r12	;
    845a:	3c 50 26 00 	add	#38,	r12	;#0x0026
    845e:	4d 43       	clr.b	r13		;
    8460:	b0 12 e4 7a 	call	#31460		;#0x7ae4

00008464 <.L60>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
  dmaTransferI(&(adcp->dma), &(adcp->req));
    8464:	2c 41       	mov	@r1,	r12	;
    8466:	3c 50 26 00 	add	#38,	r12	;#0x0026
    846a:	2d 41       	mov	@r1,	r13	;
    846c:	3d 50 0e 00 	add	#14,	r13	;#0x000e
    8470:	b0 12 42 7c 	call	#31810		;#0x7c42

00008474 <.Loc.268.3>:

  adcp->regs->ctl[0] |= adcp->grpp->rate | ADC12MSC | ADC12ENC | ADC12SC;
    8474:	2c 41       	mov	@r1,	r12	;
    8476:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    847a:	2d 41       	mov	@r1,	r13	;
    847c:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    8480:	2e 4d       	mov	@r13,	r14	;
    8482:	2d 41       	mov	@r1,	r13	;
    8484:	1d 4d 08 00 	mov	8(r13),	r13	;
    8488:	1d 4d 28 00 	mov	40(r13),r13	;0x00028
    848c:	0d de       	bis	r14,	r13	;
    848e:	3d d0 83 00 	bis	#131,	r13	;#0x0083
    8492:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008496 <.Loc.269.3>:
}
    8496:	03 43       	nop			
    8498:	21 52       	add	#4,	r1	;r2 As==10
    849a:	30 41       	ret			

0000849c <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver * adcp) {
    849c:	21 83       	decd	r1		;

0000849e <L0>:
    849e:	81 4c 00 00 	mov	r12,	0(r1)	;

000084a2 <.Loc.281.3>:

  /* TODO stop DMA transfers here */
  adcp->regs->ctl[0] &= ~(ADC12ENC | ADC12SC);
    84a2:	2c 41       	mov	@r1,	r12	;
    84a4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    84a8:	2d 41       	mov	@r1,	r13	;
    84aa:	1d 4d 0c 00 	mov	12(r13),r13	;0x0000c
    84ae:	2d 4d       	mov	@r13,	r13	;
    84b0:	3d f0 fc ff 	and	#-4,	r13	;#0xfffc
    84b4:	8c 4d 00 00 	mov	r13,	0(r12)	;

000084b8 <.Loc.283.3>:

  dmaCancelI(&(adcp->dma));
    84b8:	2c 41       	mov	@r1,	r12	;
    84ba:	3c 50 26 00 	add	#38,	r12	;#0x0026
    84be:	b0 12 44 7d 	call	#32068		;#0x7d44

000084c2 <.Loc.285.3>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  if (adcp->config->dma_index >= MSP430X_DMA_CHANNELS) {
    84c2:	2c 41       	mov	@r1,	r12	;
    84c4:	1c 4c 02 00 	mov	2(r12),	r12	;
    84c8:	6c 4c       	mov.b	@r12,	r12	;
    84ca:	6d 43       	mov.b	#2,	r13	;r3 As==10
    84cc:	4d 9c       	cmp.b	r12,	r13	;
    84ce:	05 2c       	jc	$+12     	;abs 0x84da

000084d0 <.Loc.287.3>:
#endif
    dmaReleaseX(&(adcp->dma));
    84d0:	2c 41       	mov	@r1,	r12	;
    84d2:	3c 50 26 00 	add	#38,	r12	;#0x0026
    84d6:	b0 12 fa 7c 	call	#31994		;#0x7cfa

000084da <.L63>:
#if MSP430X_ADC_EXCLUSIVE_DMA == TRUE
  }
#endif
}
    84da:	03 43       	nop			
    84dc:	21 53       	incd	r1		;
    84de:	30 41       	ret			

000084e0 <adcMSP430XAdjustResult>:

adcsample_t adcMSP430XAdjustResult(ADCConversionGroup * grpp,
                                   adcsample_t sample) {
    84e0:	0a 15       	pushm	#1,	r10	;16-bit words

000084e2 <.LCFI10>:
    84e2:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000084e6 <.LCFI11>:
    84e6:	81 4c 02 00 	mov	r12,	2(r1)	;
    84ea:	81 4d 00 00 	mov	r13,	0(r1)	;

000084ee <.Loc.297.3>:
  uint32_t tmp;
  uint16_t fact;
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    84ee:	1c 41 02 00 	mov	2(r1),	r12	;
    84f2:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a
    84f6:	3c 90 00 01 	cmp	#256,	r12	;#0x0100
    84fa:	1c 24       	jz	$+58     	;abs 0x8534

000084fc <.Loc.298.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    84fc:	1c 41 02 00 	mov	2(r1),	r12	;
    8500:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00008504 <.Loc.297.3>:
  if (grpp->ref == MSP430X_ADC_VSS_VREF_BUF ||
    8504:	3c 90 00 07 	cmp	#1792,	r12	;#0x0700
    8508:	15 24       	jz	$+44     	;abs 0x8534

0000850a <.Loc.299.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    850a:	1c 41 02 00 	mov	2(r1),	r12	;
    850e:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00008512 <.Loc.298.3>:
      grpp->ref == MSP430X_ADC_VEREF_P_VREF_BUF ||
    8512:	3c 90 00 09 	cmp	#2304,	r12	;#0x0900
    8516:	0e 24       	jz	$+30     	;abs 0x8534

00008518 <.Loc.300.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    8518:	1c 41 02 00 	mov	2(r1),	r12	;
    851c:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

00008520 <.Loc.299.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VCC ||
    8520:	3c 90 00 0b 	cmp	#2816,	r12	;#0x0b00
    8524:	07 24       	jz	$+16     	;abs 0x8534

00008526 <.Loc.301.3>:
      grpp->ref == MSP430X_ADC_VEREF_N_VREF_BUF) {
    8526:	1c 41 02 00 	mov	2(r1),	r12	;
    852a:	1c 4c 2a 00 	mov	42(r12),r12	;0x0002a

0000852e <.Loc.300.3>:
      grpp->ref == MSP430X_ADC_VREF_BUF_VEREF_P ||
    852e:	3c 90 00 0d 	cmp	#3328,	r12	;#0x0d00
    8532:	26 20       	jnz	$+78     	;abs 0x8580

00008534 <.L65>:
    /* Retrieve proper reference correction factor from TLV */
    fact = (&(ADCD1.ref_cal->CAL_ADC_12VREF_FACTOR))[grpp->vref_src >> 4];
    8534:	1c 42 20 53 	mov	&0x5320,r12	;0x5320
    8538:	0d 4c       	mov	r12,	r13	;
    853a:	1c 41 02 00 	mov	2(r1),	r12	;
    853e:	5c 4c 2c 00 	mov.b	44(r12),r12	;0x0002c
    8542:	5c 0f       	rrum	#4,	r12	;
    8544:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8548:	0c 5c       	rla	r12		;
    854a:	0c 5d       	add	r13,	r12	;
    854c:	a1 4c 08 00 	mov	@r12,	8(r1)	;

00008550 <.Loc.305.3>:
    /* Calculate corrected value */
    tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    8550:	2c 41       	mov	@r1,	r12	;
    8552:	0c 5c       	rla	r12		;
    8554:	0d 43       	clr	r13		;
    8556:	1a 41 08 00 	mov	8(r1),	r10	;
    855a:	0e 4a       	mov	r10,	r14	;
    855c:	0f 43       	clr	r15		;
    855e:	b0 12 4a 91 	call	#-28342	;#0x914a
    8562:	81 4c 04 00 	mov	r12,	4(r1)	;
    8566:	81 4d 06 00 	mov	r13,	6(r1)	;

0000856a <.Loc.306.3>:
    sample = tmp >> 16;
    856a:	1c 41 04 00 	mov	4(r1),	r12	;
    856e:	1d 41 06 00 	mov	6(r1),	r13	;
    8572:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8576:	4f 43       	clr.b	r15		;
    8578:	b0 12 30 91 	call	#-28368	;#0x9130
    857c:	81 4c 00 00 	mov	r12,	0(r1)	;

00008580 <.L66>:
  }

  /* Gain correction */
  fact   = ADCD1.adc_cal->CAL_ADC_GAIN_FACTOR;
    8580:	1c 42 1e 53 	mov	&0x531e,r12	;0x531e
    8584:	a1 4c 08 00 	mov	@r12,	8(r1)	;

00008588 <.Loc.311.3>:
  tmp    = (uint32_t)(sample << 1) * (uint32_t)fact;
    8588:	2c 41       	mov	@r1,	r12	;
    858a:	0c 5c       	rla	r12		;
    858c:	0d 43       	clr	r13		;
    858e:	1a 41 08 00 	mov	8(r1),	r10	;
    8592:	0e 4a       	mov	r10,	r14	;
    8594:	0f 43       	clr	r15		;
    8596:	b0 12 4a 91 	call	#-28342	;#0x914a
    859a:	81 4c 04 00 	mov	r12,	4(r1)	;
    859e:	81 4d 06 00 	mov	r13,	6(r1)	;

000085a2 <.Loc.312.3>:
  sample = tmp >> 16;
    85a2:	1c 41 04 00 	mov	4(r1),	r12	;
    85a6:	1d 41 06 00 	mov	6(r1),	r13	;
    85aa:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    85ae:	4f 43       	clr.b	r15		;
    85b0:	b0 12 30 91 	call	#-28368	;#0x9130
    85b4:	81 4c 00 00 	mov	r12,	0(r1)	;

000085b8 <.Loc.315.3>:

  /* Offset correction */
  sample += ADCD1.adc_cal->CAL_ADC_OFFSET;
    85b8:	1c 42 1e 53 	mov	&0x531e,r12	;0x531e
    85bc:	1c 4c 02 00 	mov	2(r12),	r12	;
    85c0:	81 5c 00 00 	add	r12,	0(r1)	;

000085c4 <.Loc.317.3>:

  return sample;
    85c4:	2c 41       	mov	@r1,	r12	;

000085c6 <.Loc.318.3>:
}
    85c6:	31 50 0a 00 	add	#10,	r1	;#0x000a
    85ca:	0a 17       	popm	#1,	r10	;16-bit words
    85cc:	30 41       	ret			

000085ce <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    85ce:	32 c2       	dint			
    85d0:	03 43       	nop			

000085d2 <.Loc.46.1>:

}
    85d2:	03 43       	nop			
    85d4:	30 41       	ret			

000085d6 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    85d6:	ff 3f       	jmp	$+0      	;abs 0x85d6

000085d8 <Vector2>:
    85d8:	ff 3f       	jmp	$+0      	;abs 0x85d8

000085da <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    85da:	ff 3f       	jmp	$+0      	;abs 0x85da

000085dc <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    85dc:	ff 3f       	jmp	$+0      	;abs 0x85dc

000085de <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    85de:	ff 3f       	jmp	$+0      	;abs 0x85de

000085e0 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    85e0:	ff 3f       	jmp	$+0      	;abs 0x85e0

000085e2 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    85e2:	ff 3f       	jmp	$+0      	;abs 0x85e2

000085e4 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    85e4:	ff 3f       	jmp	$+0      	;abs 0x85e4

000085e6 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    85e6:	ff 3f       	jmp	$+0      	;abs 0x85e6

000085e8 <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    85e8:	ff 3f       	jmp	$+0      	;abs 0x85e8

000085ea <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    85ea:	ff 3f       	jmp	$+0      	;abs 0x85ea

000085ec <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    85ec:	ff 3f       	jmp	$+0      	;abs 0x85ec

000085ee <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    85ee:	ff 3f       	jmp	$+0      	;abs 0x85ee

000085f0 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    85f0:	ff 3f       	jmp	$+0      	;abs 0x85f0

000085f2 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    85f2:	ff 3f       	jmp	$+0      	;abs 0x85f2

000085f4 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    85f4:	ff 3f       	jmp	$+0      	;abs 0x85f4

000085f6 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    85f6:	ff 3f       	jmp	$+0      	;abs 0x85f6

000085f8 <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    85f8:	ff 3f       	jmp	$+0      	;abs 0x85f8

000085fa <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    85fa:	ff 3f       	jmp	$+0      	;abs 0x85fa

000085fc <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    85fc:	ff 3f       	jmp	$+0      	;abs 0x85fc

000085fe <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    85fe:	ff 3f       	jmp	$+0      	;abs 0x85fe

00008600 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    8600:	ff 3f       	jmp	$+0      	;abs 0x8600

00008602 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    8602:	ff 3f       	jmp	$+0      	;abs 0x8602

00008604 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    8604:	ff 3f       	jmp	$+0      	;abs 0x8604

00008606 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    8606:	ff 3f       	jmp	$+0      	;abs 0x8606

00008608 <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    8608:	ff 3f       	jmp	$+0      	;abs 0x8608

0000860a <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    860a:	ff 3f       	jmp	$+0      	;abs 0x860a

0000860c <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    860c:	ff 3f       	jmp	$+0      	;abs 0x860c

0000860e <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    860e:	ff 3f       	jmp	$+0      	;abs 0x860e

00008610 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    8610:	ff 3f       	jmp	$+0      	;abs 0x8610

00008612 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    8612:	ff 3f       	jmp	$+0      	;abs 0x8612

00008614 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    8614:	ff 3f       	jmp	$+0      	;abs 0x8614

00008616 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    8616:	ff 3f       	jmp	$+0      	;abs 0x8616

00008618 <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    8618:	ff 3f       	jmp	$+0      	;abs 0x8618

0000861a <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    861a:	ff 3f       	jmp	$+0      	;abs 0x861a

0000861c <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    861c:	ff 3f       	jmp	$+0      	;abs 0x861c

0000861e <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    861e:	ff 3f       	jmp	$+0      	;abs 0x861e

00008620 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    8620:	ff 3f       	jmp	$+0      	;abs 0x8620

00008622 <Vector45>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    8622:	ff 3f       	jmp	$+0      	;abs 0x8622

00008624 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    8624:	ff 3f       	jmp	$+0      	;abs 0x8624

00008626 <Vector48>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    8626:	ff 3f       	jmp	$+0      	;abs 0x8626

00008628 <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    8628:	ff 3f       	jmp	$+0      	;abs 0x8628

0000862a <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    862a:	ff 3f       	jmp	$+0      	;abs 0x862a

0000862c <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    862c:	ff 3f       	jmp	$+0      	;abs 0x862c

0000862e <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    862e:	ff 3f       	jmp	$+0      	;abs 0x862e

00008630 <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    8630:	ff 3f       	jmp	$+0      	;abs 0x8630

00008632 <port_lock>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    8632:	32 c2       	dint			

00008634 <L0>:
  _disable_interrupts();
    8634:	03 43       	nop			

00008636 <.Loc.348.1>:
  asm volatile("nop");
    8636:	03 43       	nop			

00008638 <.Loc.349.1>:
}
    8638:	03 43       	nop			
    863a:	30 41       	ret			

0000863c <port_unlock>:
  asm volatile("nop");
    863c:	03 43       	nop			

0000863e <.Loc.356.1>:
  _enable_interrupts();
    863e:	03 43       	nop			
    8640:	32 d2       	eint			
    8642:	03 43       	nop			

00008644 <.Loc.357.1>:
}
    8644:	03 43       	nop			
    8646:	30 41       	ret			

00008648 <osalSysLock>:
  chSysLock();
    8648:	b0 12 32 86 	call	#-31182	;#0x8632
    864c:	b0 12 be 62 	call	#25278		;#0x62be

00008650 <.Loc.505.2>:
}
    8650:	03 43       	nop			
    8652:	30 41       	ret			

00008654 <osalSysUnlock>:
  chSysUnlock();
    8654:	b0 12 de 62 	call	#25310		;#0x62de
    8658:	b0 12 3c 86 	call	#-31172	;#0x863c

0000865c <.Loc.516.2>:
}
    865c:	03 43       	nop			
    865e:	30 41       	ret			

00008660 <convert_ntc>:
  MSP430X_REF_2V5 /* vref_src */
};

typedef int64_t fixed_q36_8;

fixed_q36_8 convert_ntc(ADCConversionGroup *grpp, adcsample_t sample) {
    8660:	5a 15       	pushm	#6,	r10	;16-bit words

00008662 <.LCFI0>:
    8662:	31 80 44 00 	sub	#68,	r1	;#0x0044

00008666 <.LCFI1>:
    8666:	81 4c 2c 00 	mov	r12,	44(r1)	; 0x002c
    866a:	81 4d 2a 00 	mov	r13,	42(r1)	; 0x002a

0000866e <.Loc.49.3>:
  const int32_t c3 = -10; /* Q0.31 */
    866e:	b1 40 f6 ff 	mov	#-10,	64(r1)	;#0xfff6, 0x0040
    8672:	40 00 
    8674:	b1 43 42 00 	mov	#-1,	66(r1)	;r3 As==11, 0x0042

00008678 <.Loc.50.3>:
  const int32_t c2 = 66515; /* Q0.31 */
    8678:	b1 40 d3 03 	mov	#979,	60(r1)	;#0x03d3, 0x003c
    867c:	3c 00 
    867e:	91 43 3e 00 	mov	#1,	62(r1)	;r3 As==01, 0x003e

00008682 <.Loc.51.3>:
  const int16_t c1 = -2841; /* Q0.15 */
    8682:	b1 40 e7 f4 	mov	#-2841,	58(r1)	;#0xf4e7, 0x003a
    8686:	3a 00 

00008688 <.Loc.52.3>:
  const int32_t c0 = 28750; /* Q7.8 */
    8688:	b1 40 4e 70 	mov	#28750,	54(r1)	;#0x704e, 0x0036
    868c:	36 00 
    868e:	81 43 38 00 	mov	#0,	56(r1)	;r3 As==00, 0x0038

00008692 <.Loc.56.3>:
  int64_t y;
  
  /* Get converted ADC value */
  adcMSP430XAdjustResult(grpp, sample);
    8692:	1d 41 2a 00 	mov	42(r1),	r13	;0x0002a
    8696:	1c 41 2c 00 	mov	44(r1),	r12	;0x0002c
    869a:	b0 12 e0 84 	call	#-31520	;#0x84e0

0000869e <.Loc.63.3>:
  /* Convert value */
  /* NOTE: This is a lot of fixed point math. The regression line I'm using 
   * comes from LibreOffice, plotting Temperature vs. DN over the -40..+85 C
   * range. The equation is -4.6411...x^3+3.0974...x^2-0.0867...x+112.3073
   * We solve it using Horner's rule in fixed point math as follows */
  y = c3 * sample; /* Q0.31 * Q12.0 => Q12.31 */
    869e:	1e 41 2a 00 	mov	42(r1),	r14	;0x0002a
    86a2:	0c 4e       	mov	r14,	r12	;
    86a4:	0d 43       	clr	r13		;
    86a6:	1e 41 40 00 	mov	64(r1),	r14	;0x00040
    86aa:	1f 41 42 00 	mov	66(r1),	r15	;0x00042
    86ae:	b0 12 4a 91 	call	#-28342	;#0x914a
    86b2:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    86b6:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    86ba:	0c 4d       	mov	r13,	r12	;
    86bc:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    86c0:	81 4c 32 00 	mov	r12,	50(r1)	; 0x0032
    86c4:	81 4c 34 00 	mov	r12,	52(r1)	; 0x0034

000086c8 <.Loc.64.3>:
  y += c2; /* Q12.31 + Q0.31 => OK */
    86c8:	1c 41 3c 00 	mov	60(r1),	r12	;0x0003c
    86cc:	1d 41 3e 00 	mov	62(r1),	r13	;0x0003e
    86d0:	81 4c 22 00 	mov	r12,	34(r1)	; 0x0022
    86d4:	81 4d 24 00 	mov	r13,	36(r1)	; 0x0024
    86d8:	0c 4d       	mov	r13,	r12	;
    86da:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    86de:	81 4c 26 00 	mov	r12,	38(r1)	; 0x0026
    86e2:	81 4c 28 00 	mov	r12,	40(r1)	; 0x0028
    86e6:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    86ea:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    86ee:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    86f2:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    86f6:	0c 48       	mov	r8,	r12	;
    86f8:	1c 51 22 00 	add	34(r1),	r12	;0x00022
    86fc:	56 43       	mov.b	#1,	r6	;r3 As==01
    86fe:	07 4c       	mov	r12,	r7	;
    8700:	07 98       	cmp	r8,	r7	;
    8702:	01 28       	jnc	$+4      	;abs 0x8706
    8704:	46 43       	clr.b	r6		;

00008706 <.L6>:
    8706:	0d 49       	mov	r9,	r13	;
    8708:	1d 51 24 00 	add	36(r1),	r13	;0x00024
    870c:	55 43       	mov.b	#1,	r5	;r3 As==01
    870e:	07 4d       	mov	r13,	r7	;
    8710:	07 99       	cmp	r9,	r7	;
    8712:	01 28       	jnc	$+4      	;abs 0x8716
    8714:	45 43       	clr.b	r5		;

00008716 <.L7>:
    8716:	06 5d       	add	r13,	r6	;
    8718:	57 43       	mov.b	#1,	r7	;r3 As==01
    871a:	06 9d       	cmp	r13,	r6	;
    871c:	01 28       	jnc	$+4      	;abs 0x8720
    871e:	47 43       	clr.b	r7		;

00008720 <.L8>:
    8720:	05 d7       	bis	r7,	r5	;
    8722:	0d 46       	mov	r6,	r13	;
    8724:	0e 4a       	mov	r10,	r14	;
    8726:	1e 51 26 00 	add	38(r1),	r14	;0x00026
    872a:	56 43       	mov.b	#1,	r6	;r3 As==01
    872c:	07 4e       	mov	r14,	r7	;
    872e:	07 9a       	cmp	r10,	r7	;
    8730:	01 28       	jnc	$+4      	;abs 0x8734
    8732:	46 43       	clr.b	r6		;

00008734 <.L9>:
    8734:	05 5e       	add	r14,	r5	;
    8736:	57 43       	mov.b	#1,	r7	;r3 As==01
    8738:	05 9e       	cmp	r14,	r5	;
    873a:	01 28       	jnc	$+4      	;abs 0x873e
    873c:	47 43       	clr.b	r7		;

0000873e <.L10>:
    873e:	06 d7       	bis	r7,	r6	;
    8740:	0e 45       	mov	r5,	r14	;
    8742:	0f 4b       	mov	r11,	r15	;
    8744:	1f 51 28 00 	add	40(r1),	r15	;0x00028
    8748:	0a 46       	mov	r6,	r10	;
    874a:	0a 5f       	add	r15,	r10	;
    874c:	0f 4a       	mov	r10,	r15	;
    874e:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    8752:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    8756:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    875a:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

0000875e <.Loc.65.3>:
  y *= sample; /* Q12.31 * Q12.0 => Q24.31 */
    875e:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    8762:	81 4c 1a 00 	mov	r12,	26(r1)	; 0x001a
    8766:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c
    876a:	81 43 1e 00 	mov	#0,	30(r1)	;r3 As==00, 0x001e
    876e:	81 43 20 00 	mov	#0,	32(r1)	;r3 As==00, 0x0020
    8772:	1c 41 1a 00 	mov	26(r1),	r12	;0x0001a
    8776:	1d 41 1c 00 	mov	28(r1),	r13	;0x0001c
    877a:	1e 41 1e 00 	mov	30(r1),	r14	;0x0001e
    877e:	1f 41 20 00 	mov	32(r1),	r15	;0x00020
    8782:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    8786:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    878a:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    878e:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    8792:	b0 12 1a 8d 	call	#-29414	;#0x8d1a
    8796:	08 4c       	mov	r12,	r8	;
    8798:	09 4d       	mov	r13,	r9	;
    879a:	0a 4e       	mov	r14,	r10	;
    879c:	0b 4f       	mov	r15,	r11	;
    879e:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    87a2:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    87a6:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    87aa:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000087ae <.Loc.66.3>:
  y = (y >> 16); /* Q24.31 >> 16 => Q24.15 */
    87ae:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    87b2:	00 00 
    87b4:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    87b8:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    87bc:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    87c0:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    87c4:	b0 12 64 8e 	call	#-29084	;#0x8e64
    87c8:	08 4c       	mov	r12,	r8	;
    87ca:	09 4d       	mov	r13,	r9	;
    87cc:	0a 4e       	mov	r14,	r10	;
    87ce:	0b 4f       	mov	r15,	r11	;
    87d0:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    87d4:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    87d8:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    87dc:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000087e0 <.Loc.67.3>:
  y += c1; /* Q24.15 + Q0.15 => OK */
    87e0:	1c 41 3a 00 	mov	58(r1),	r12	;0x0003a
    87e4:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    87e8:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    87ec:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    87f0:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    87f4:	81 4c 18 00 	mov	r12,	24(r1)	; 0x0018
    87f8:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    87fc:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    8800:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    8804:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    8808:	0c 48       	mov	r8,	r12	;
    880a:	1c 51 12 00 	add	18(r1),	r12	;0x00012
    880e:	56 43       	mov.b	#1,	r6	;r3 As==01
    8810:	07 4c       	mov	r12,	r7	;
    8812:	07 98       	cmp	r8,	r7	;
    8814:	01 28       	jnc	$+4      	;abs 0x8818
    8816:	46 43       	clr.b	r6		;

00008818 <.L11>:
    8818:	0d 49       	mov	r9,	r13	;
    881a:	1d 51 14 00 	add	20(r1),	r13	;0x00014
    881e:	55 43       	mov.b	#1,	r5	;r3 As==01
    8820:	07 4d       	mov	r13,	r7	;
    8822:	07 99       	cmp	r9,	r7	;
    8824:	01 28       	jnc	$+4      	;abs 0x8828
    8826:	45 43       	clr.b	r5		;

00008828 <.L12>:
    8828:	06 5d       	add	r13,	r6	;
    882a:	57 43       	mov.b	#1,	r7	;r3 As==01
    882c:	06 9d       	cmp	r13,	r6	;
    882e:	01 28       	jnc	$+4      	;abs 0x8832
    8830:	47 43       	clr.b	r7		;

00008832 <.L13>:
    8832:	05 d7       	bis	r7,	r5	;
    8834:	0d 46       	mov	r6,	r13	;
    8836:	0e 4a       	mov	r10,	r14	;
    8838:	1e 51 16 00 	add	22(r1),	r14	;0x00016
    883c:	56 43       	mov.b	#1,	r6	;r3 As==01
    883e:	07 4e       	mov	r14,	r7	;
    8840:	07 9a       	cmp	r10,	r7	;
    8842:	01 28       	jnc	$+4      	;abs 0x8846
    8844:	46 43       	clr.b	r6		;

00008846 <.L14>:
    8846:	05 5e       	add	r14,	r5	;
    8848:	57 43       	mov.b	#1,	r7	;r3 As==01
    884a:	05 9e       	cmp	r14,	r5	;
    884c:	01 28       	jnc	$+4      	;abs 0x8850
    884e:	47 43       	clr.b	r7		;

00008850 <.L15>:
    8850:	06 d7       	bis	r7,	r6	;
    8852:	0e 45       	mov	r5,	r14	;
    8854:	0f 4b       	mov	r11,	r15	;
    8856:	1f 51 18 00 	add	24(r1),	r15	;0x00018
    885a:	0a 46       	mov	r6,	r10	;
    885c:	0a 5f       	add	r15,	r10	;
    885e:	0f 4a       	mov	r10,	r15	;
    8860:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    8864:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    8868:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    886c:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

00008870 <.Loc.68.3>:
  y *= sample; /* Q24.15 * Q12.0 => Q36.15 */
    8870:	1c 41 2a 00 	mov	42(r1),	r12	;0x0002a
    8874:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    8878:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c
    887c:	81 43 0e 00 	mov	#0,	14(r1)	;r3 As==00, 0x000e
    8880:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    8884:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    8888:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    888c:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    8890:	1f 41 10 00 	mov	16(r1),	r15	;0x00010
    8894:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    8898:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    889c:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    88a0:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    88a4:	b0 12 1a 8d 	call	#-29414	;#0x8d1a
    88a8:	08 4c       	mov	r12,	r8	;
    88aa:	09 4d       	mov	r13,	r9	;
    88ac:	0a 4e       	mov	r14,	r10	;
    88ae:	0b 4f       	mov	r15,	r11	;
    88b0:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    88b4:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    88b8:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    88bc:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000088c0 <.Loc.69.3>:
  y = (y >> 7); /* Q36.15 >> 7 => Q36.8 */
    88c0:	b1 40 07 00 	mov	#7,	0(r1)	;
    88c4:	00 00 
    88c6:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    88ca:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    88ce:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    88d2:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    88d6:	b0 12 64 8e 	call	#-29084	;#0x8e64
    88da:	08 4c       	mov	r12,	r8	;
    88dc:	09 4d       	mov	r13,	r9	;
    88de:	0a 4e       	mov	r14,	r10	;
    88e0:	0b 4f       	mov	r15,	r11	;
    88e2:	81 48 2e 00 	mov	r8,	46(r1)	; 0x002e
    88e6:	81 49 30 00 	mov	r9,	48(r1)	; 0x0030
    88ea:	81 4a 32 00 	mov	r10,	50(r1)	; 0x0032
    88ee:	81 4b 34 00 	mov	r11,	52(r1)	; 0x0034

000088f2 <.Loc.70.3>:
  y += c0; /* Q36.8 + Q7.8 => OK */
    88f2:	1c 41 36 00 	mov	54(r1),	r12	;0x00036
    88f6:	1d 41 38 00 	mov	56(r1),	r13	;0x00038
    88fa:	81 4c 02 00 	mov	r12,	2(r1)	;
    88fe:	81 4d 04 00 	mov	r13,	4(r1)	;
    8902:	0c 4d       	mov	r13,	r12	;
    8904:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    8908:	81 4c 06 00 	mov	r12,	6(r1)	;
    890c:	81 4c 08 00 	mov	r12,	8(r1)	;
    8910:	18 41 2e 00 	mov	46(r1),	r8	;0x0002e
    8914:	19 41 30 00 	mov	48(r1),	r9	;0x00030
    8918:	1a 41 32 00 	mov	50(r1),	r10	;0x00032
    891c:	1b 41 34 00 	mov	52(r1),	r11	;0x00034
    8920:	0c 48       	mov	r8,	r12	;
    8922:	1c 51 02 00 	add	2(r1),	r12	;
    8926:	56 43       	mov.b	#1,	r6	;r3 As==01
    8928:	07 4c       	mov	r12,	r7	;
    892a:	07 98       	cmp	r8,	r7	;
    892c:	01 28       	jnc	$+4      	;abs 0x8930
    892e:	46 43       	clr.b	r6		;

00008930 <.L16>:
    8930:	0d 49       	mov	r9,	r13	;
    8932:	1d 51 04 00 	add	4(r1),	r13	;
    8936:	55 43       	mov.b	#1,	r5	;r3 As==01
    8938:	07 4d       	mov	r13,	r7	;
    893a:	07 99       	cmp	r9,	r7	;
    893c:	01 28       	jnc	$+4      	;abs 0x8940
    893e:	45 43       	clr.b	r5		;

00008940 <.L17>:
    8940:	06 5d       	add	r13,	r6	;
    8942:	57 43       	mov.b	#1,	r7	;r3 As==01
    8944:	06 9d       	cmp	r13,	r6	;
    8946:	01 28       	jnc	$+4      	;abs 0x894a
    8948:	47 43       	clr.b	r7		;

0000894a <.L18>:
    894a:	05 d7       	bis	r7,	r5	;
    894c:	0d 46       	mov	r6,	r13	;
    894e:	0e 4a       	mov	r10,	r14	;
    8950:	1e 51 06 00 	add	6(r1),	r14	;
    8954:	56 43       	mov.b	#1,	r6	;r3 As==01
    8956:	07 4e       	mov	r14,	r7	;
    8958:	07 9a       	cmp	r10,	r7	;
    895a:	01 28       	jnc	$+4      	;abs 0x895e
    895c:	46 43       	clr.b	r6		;

0000895e <.L19>:
    895e:	05 5e       	add	r14,	r5	;
    8960:	57 43       	mov.b	#1,	r7	;r3 As==01
    8962:	05 9e       	cmp	r14,	r5	;
    8964:	01 28       	jnc	$+4      	;abs 0x8968
    8966:	47 43       	clr.b	r7		;

00008968 <.L20>:
    8968:	06 d7       	bis	r7,	r6	;
    896a:	0e 45       	mov	r5,	r14	;
    896c:	0f 4b       	mov	r11,	r15	;
    896e:	1f 51 08 00 	add	8(r1),	r15	;
    8972:	0a 46       	mov	r6,	r10	;
    8974:	0a 5f       	add	r15,	r10	;
    8976:	0f 4a       	mov	r10,	r15	;
    8978:	81 4c 2e 00 	mov	r12,	46(r1)	; 0x002e
    897c:	81 4d 30 00 	mov	r13,	48(r1)	; 0x0030
    8980:	81 4e 32 00 	mov	r14,	50(r1)	; 0x0032
    8984:	81 4f 34 00 	mov	r15,	52(r1)	; 0x0034

00008988 <.Loc.74.3>:
  
  /* Now y is our result in Q36.8 format. We return it using a typedef to
   * make that clear. */
  return y;
    8988:	1c 41 2e 00 	mov	46(r1),	r12	;0x0002e
    898c:	1d 41 30 00 	mov	48(r1),	r13	;0x00030
    8990:	1e 41 32 00 	mov	50(r1),	r14	;0x00032
    8994:	1f 41 34 00 	mov	52(r1),	r15	;0x00034
    8998:	08 4c       	mov	r12,	r8	;
    899a:	09 4d       	mov	r13,	r9	;
    899c:	0a 4e       	mov	r14,	r10	;
    899e:	0b 4f       	mov	r15,	r11	;

000089a0 <.Loc.75.3>:
}
    89a0:	0c 48       	mov	r8,	r12	;
    89a2:	0d 49       	mov	r9,	r13	;
    89a4:	0e 4a       	mov	r10,	r14	;
    89a6:	0f 4b       	mov	r11,	r15	;
    89a8:	31 50 44 00 	add	#68,	r1	;#0x0044
    89ac:	55 17       	popm	#6,	r10	;16-bit words
    89ae:	30 41       	ret			

000089b0 <save_bacon>:
const char * unpow_string = "PA unpowered.\r\n";
const char * err_string = "\r\nERROR! PA in unexpected state - likely PGOOD event\r\n";
const char * therm_string = "\r\nERROR! PA overheating - powering off now\r\n";

static void save_bacon(void) {
  palClearLine(LINE_PA_PC_EN);
    89b0:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    89b4:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    89b8:	1d 4d 02 00 	mov	2(r13),	r13	;
    89bc:	3d f0 ff ef 	and	#-4097,	r13	;#0xefff
    89c0:	8c 4d 02 00 	mov	r13,	2(r12)	;

000089c4 <.Loc.88.3>:
}
    89c4:	03 43       	nop			
    89c6:	30 41       	ret			

000089c8 <Thread2>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    89c8:	3a 15       	pushm	#4,	r10	;16-bit words

000089ca <.LCFI2>:
    89ca:	31 80 14 00 	sub	#20,	r1	;#0x0014

000089ce <.LCFI3>:
    89ce:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

000089d2 <.Loc.101.3>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD1, NULL);
    89d2:	4d 43       	clr.b	r13		;
    89d4:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    89d8:	b0 12 66 72 	call	#29286		;#0x7266

000089dc <.Loc.104.3>:
  
  /* Activate the ADC driver 1 using its config */
  adcStart(&ADCD1, &adc_config);
    89dc:	3d 40 2a 53 	mov	#21290,	r13	;#0x532a
    89e0:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    89e4:	b0 12 72 6f 	call	#28530		;#0x6f72

000089e8 <.Loc.109.3>:

  /*chnWrite(&SD1, (const uint8_t *)start_msg, strlen(start_msg));*/
  
  uint8_t in;
  bool powered = false;
    89e8:	c1 43 13 00 	mov.b	#0,	19(r1)	;r3 As==00, 0x0013

000089ec <.L34>:
  while (true) {
    
    in = sdGetTimeout(&SD1, TIME_IMMEDIATE);
    89ec:	3d 43       	mov	#-1,	r13	;r3 As==11
    89ee:	3c 40 0a 52 	mov	#21002,	r12	;#0x520a
    89f2:	b0 12 5a 6a 	call	#27226		;#0x6a5a
    89f6:	c1 4c 0f 00 	mov.b	r12,	15(r1)	; 0x000f

000089fa <.Loc.114.3>:
    
    if (in == 'p') {
    89fa:	f1 90 70 00 	cmp.b	#112,	15(r1)	;#0x0070, 0x000f
    89fe:	0f 00 
    8a00:	4f 20       	jnz	$+160    	;abs 0x8aa0

00008a02 <.Loc.115.3>:
      if (powered) {
    8a02:	c1 93 13 00 	cmp.b	#0,	19(r1)	;r3 As==00, 0x0013
    8a06:	25 24       	jz	$+76     	;abs 0x8a52

00008a08 <.Loc.117.3>:
        /* Disable "save my bacon" PGOOD falling edge interrupt */
        osalSysLock();
    8a08:	b0 12 48 86 	call	#-31160	;#0x8648

00008a0c <.Loc.118.3>:
        palLineDisableEventI(LINE_PA_PGOOD);
    8a0c:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    8a10:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    8a14:	b0 12 ee 79 	call	#31214		;#0x79ee

00008a18 <.Loc.119.3>:
        osalSysUnlock();
    8a18:	b0 12 54 86 	call	#-31148	;#0x8654

00008a1c <.Loc.121.3>:
        /* Power off */
        palClearLine(LINE_PA_PC_EN);
    8a1c:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    8a20:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    8a24:	1d 4d 02 00 	mov	2(r13),	r13	;
    8a28:	3d f0 ff ef 	and	#-4097,	r13	;#0xefff
    8a2c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008a30 <.Loc.122.3>:
        powered = false;
    8a30:	c1 43 13 00 	mov.b	#0,	19(r1)	;r3 As==00, 0x0013

00008a34 <.Loc.123.3>:
        chnWrite(&SD1, (const uint8_t *)unpow_string, strlen(unpow_string));
    8a34:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8a38:	2a 4c       	mov	@r12,	r10	;
    8a3a:	19 42 de 53 	mov	&0x53de,r9	;0x53de
    8a3e:	1c 42 de 53 	mov	&0x53de,r12	;0x53de
    8a42:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8a46:	0e 4c       	mov	r12,	r14	;
    8a48:	0d 49       	mov	r9,	r13	;
    8a4a:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8a4e:	8a 12       	call	r10		;
    8a50:	27 3c       	jmp	$+80     	;abs 0x8aa0

00008a52 <.L25>:
      }
      else {
        /* Set up "save my bacon" PGOOD falling edge interrupt */
        osalSysLock();
    8a52:	b0 12 48 86 	call	#-31160	;#0x8648

00008a56 <.Loc.128.3>:
        palLineEnableEventI(LINE_PA_PGOOD, PAL_EVENT_MODE_FALLING_EDGE, save_bacon);
    8a56:	3f 40 b0 89 	mov	#-30288,r15	;#0x89b0
    8a5a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    8a5c:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    8a60:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    8a64:	b0 12 d8 78 	call	#30936		;#0x78d8

00008a68 <.Loc.129.3>:
        osalSysUnlock();
    8a68:	b0 12 54 86 	call	#-31148	;#0x8654

00008a6c <.Loc.131.3>:
        /* Power on */
        palSetLine(LINE_PA_PC_EN);
    8a6c:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    8a70:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    8a74:	1d 4d 02 00 	mov	2(r13),	r13	;
    8a78:	3d d0 00 10 	bis	#4096,	r13	;#0x1000
    8a7c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008a80 <.Loc.132.3>:
        powered = true;
    8a80:	d1 43 13 00 	mov.b	#1,	19(r1)	;r3 As==01, 0x0013

00008a84 <.Loc.133.3>:
        chnWrite(&SD1, (const uint8_t *)pow_string, strlen(pow_string));
    8a84:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8a88:	2a 4c       	mov	@r12,	r10	;
    8a8a:	19 42 dc 53 	mov	&0x53dc,r9	;0x53dc
    8a8e:	1c 42 dc 53 	mov	&0x53dc,r12	;0x53dc
    8a92:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8a96:	0e 4c       	mov	r12,	r14	;
    8a98:	0d 49       	mov	r9,	r13	;
    8a9a:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8a9e:	8a 12       	call	r10		;

00008aa0 <.L24>:
      }
    }
      
    /* Read the NTC thermistor value */
    /*chnWrite(&SD1, (const uint8_t *)test_1_msg, strlen(test_1_msg));*/
    adcStartConversion(&ADCD1, &adc_group, samples, 1);
    8aa0:	5f 43       	mov.b	#1,	r15	;r3 As==01
    8aa2:	3e 40 06 5d 	mov	#23814,	r14	;#0x5d06
    8aa6:	3d 40 2c 53 	mov	#21292,	r13	;#0x532c
    8aaa:	3c 40 fe 52 	mov	#21246,	r12	;#0x52fe
    8aae:	b0 12 a2 6f 	call	#28578		;#0x6fa2

00008ab2 <.Loc.140.3>:
    while (ADCD1.state == ADC_ACTIVE) ;
    8ab2:	03 43       	nop			

00008ab4 <.L26>:
    8ab4:	5c 42 fe 52 	mov.b	&0x52fe,r12	;0x52fe
    8ab8:	7c 90 03 00 	cmp.b	#3,	r12	;
    8abc:	fb 27       	jz	$-8      	;abs 0x8ab4

00008abe <.LBB2>:
    
    for (int i = 0; i < 2; i++) {
    8abe:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010
    8ac2:	76 3c       	jmp	$+238    	;abs 0x8bb0

00008ac4 <.L30>:
      temps[i] = convert_ntc(&adc_group, samples[i]);
    8ac4:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8ac8:	0c 5c       	rla	r12		;
    8aca:	3c 50 06 5d 	add	#23814,	r12	;#0x5d06
    8ace:	2c 4c       	mov	@r12,	r12	;
    8ad0:	0d 4c       	mov	r12,	r13	;
    8ad2:	3c 40 2c 53 	mov	#21292,	r12	;#0x532c
    8ad6:	b0 12 60 86 	call	#-31136	;#0x8660
    8ada:	08 4c       	mov	r12,	r8	;
    8adc:	09 4d       	mov	r13,	r9	;
    8ade:	0a 4e       	mov	r14,	r10	;
    8ae0:	0b 4f       	mov	r15,	r11	;
    8ae2:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8ae6:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    8aea:	3c 50 f6 5c 	add	#23798,	r12	;#0x5cf6
    8aee:	8c 48 00 00 	mov	r8,	0(r12)	;
    8af2:	8c 49 02 00 	mov	r9,	2(r12)	;
    8af6:	8c 4a 04 00 	mov	r10,	4(r12)	;
    8afa:	8c 4b 06 00 	mov	r11,	6(r12)	;

00008afe <.Loc.144.3>:
      if ((temps[i] >> 8) > 60) {
    8afe:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8b02:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    8b06:	3c 50 f6 5c 	add	#23798,	r12	;#0x5cf6
    8b0a:	28 4c       	mov	@r12,	r8	;
    8b0c:	19 4c 02 00 	mov	2(r12),	r9	;
    8b10:	1a 4c 04 00 	mov	4(r12),	r10	;
    8b14:	1b 4c 06 00 	mov	6(r12),	r11	;
    8b18:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    8b1c:	0c 48       	mov	r8,	r12	;
    8b1e:	0d 49       	mov	r9,	r13	;
    8b20:	0e 4a       	mov	r10,	r14	;
    8b22:	0f 4b       	mov	r11,	r15	;
    8b24:	b0 12 64 8e 	call	#-29084	;#0x8e64
    8b28:	08 4c       	mov	r12,	r8	;
    8b2a:	09 4d       	mov	r13,	r9	;
    8b2c:	0a 4e       	mov	r14,	r10	;
    8b2e:	0b 4f       	mov	r15,	r11	;
    8b30:	0c 48       	mov	r8,	r12	;
    8b32:	0d 49       	mov	r9,	r13	;
    8b34:	0e 4a       	mov	r10,	r14	;
    8b36:	0f 4b       	mov	r11,	r15	;
    8b38:	4a 43       	clr.b	r10		;
    8b3a:	0a 9f       	cmp	r15,	r10	;
    8b3c:	13 38       	jl	$+40     	;abs 0x8b64
    8b3e:	0a 4f       	mov	r15,	r10	;
    8b40:	0a 93       	cmp	#0,	r10	;r3 As==00
    8b42:	34 20       	jnz	$+106    	;abs 0x8bac
    8b44:	0a 4e       	mov	r14,	r10	;
    8b46:	0a 93       	cmp	#0,	r10	;r3 As==00
    8b48:	0d 20       	jnz	$+28     	;abs 0x8b64
    8b4a:	0a 4e       	mov	r14,	r10	;
    8b4c:	0a 93       	cmp	#0,	r10	;r3 As==00
    8b4e:	2e 20       	jnz	$+94     	;abs 0x8bac
    8b50:	0a 4d       	mov	r13,	r10	;
    8b52:	0a 93       	cmp	#0,	r10	;r3 As==00
    8b54:	07 20       	jnz	$+16     	;abs 0x8b64
    8b56:	0a 4d       	mov	r13,	r10	;
    8b58:	0a 93       	cmp	#0,	r10	;r3 As==00
    8b5a:	28 20       	jnz	$+82     	;abs 0x8bac
    8b5c:	7a 40 3c 00 	mov.b	#60,	r10	;#0x003c
    8b60:	0a 9c       	cmp	r12,	r10	;
    8b62:	24 2c       	jc	$+74     	;abs 0x8bac

00008b64 <.L35>:
        /* Disable "save my bacon" PGOOD falling edge interrupt */
        osalSysLock();
    8b64:	b0 12 48 86 	call	#-31160	;#0x8648

00008b68 <.Loc.147.3>:
        palLineDisableEventI(LINE_PA_PGOOD);
    8b68:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    8b6c:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    8b70:	b0 12 ee 79 	call	#31214		;#0x79ee

00008b74 <.Loc.148.3>:
        osalSysUnlock();
    8b74:	b0 12 54 86 	call	#-31148	;#0x8654

00008b78 <.Loc.150.3>:
        /* Power off */
        palClearLine(LINE_PA_PC_EN);
    8b78:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    8b7c:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    8b80:	1d 4d 02 00 	mov	2(r13),	r13	;
    8b84:	3d f0 ff ef 	and	#-4097,	r13	;#0xefff
    8b88:	8c 4d 02 00 	mov	r13,	2(r12)	;

00008b8c <.Loc.151.3>:
        powered = false;
    8b8c:	c1 43 13 00 	mov.b	#0,	19(r1)	;r3 As==00, 0x0013

00008b90 <.Loc.152.3>:
        chnWrite(&SD1, (const uint8_t *)therm_string, strlen(therm_string));
    8b90:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8b94:	2a 4c       	mov	@r12,	r10	;
    8b96:	19 42 e2 53 	mov	&0x53e2,r9	;0x53e2
    8b9a:	1c 42 e2 53 	mov	&0x53e2,r12	;0x53e2
    8b9e:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8ba2:	0e 4c       	mov	r12,	r14	;
    8ba4:	0d 49       	mov	r9,	r13	;
    8ba6:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8baa:	8a 12       	call	r10		;

00008bac <.L28>:
    for (int i = 0; i < 2; i++) {
    8bac:	91 53 10 00 	inc	16(r1)		;

00008bb0 <.L27>:
    8bb0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8bb2:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8bb6:	86 37       	jge	$-242    	;abs 0x8ac4

00008bb8 <.LBE2>:
      }
    }
    
    sniprintf(out_string, 128, fmt_string, "Bottom", temps[0] >> 8);
    8bb8:	17 42 da 53 	mov	&0x53da,r7	;0x53da
    8bbc:	18 42 f6 5c 	mov	&0x5cf6,r8	;0x5cf6
    8bc0:	19 42 f8 5c 	mov	&0x5cf8,r9	;0x5cf8
    8bc4:	1a 42 fa 5c 	mov	&0x5cfa,r10	;0x5cfa
    8bc8:	1b 42 fc 5c 	mov	&0x5cfc,r11	;0x5cfc
    8bcc:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    8bd0:	0c 48       	mov	r8,	r12	;
    8bd2:	0d 49       	mov	r9,	r13	;
    8bd4:	0e 4a       	mov	r10,	r14	;
    8bd6:	0f 4b       	mov	r11,	r15	;
    8bd8:	b0 12 64 8e 	call	#-29084	;#0x8e64
    8bdc:	08 4c       	mov	r12,	r8	;
    8bde:	09 4d       	mov	r13,	r9	;
    8be0:	0a 4e       	mov	r14,	r10	;
    8be2:	0b 4f       	mov	r15,	r11	;
    8be4:	0c 48       	mov	r8,	r12	;
    8be6:	0d 49       	mov	r9,	r13	;
    8be8:	0e 4a       	mov	r10,	r14	;
    8bea:	0f 4b       	mov	r11,	r15	;
    8bec:	81 4c 04 00 	mov	r12,	4(r1)	;
    8bf0:	81 4d 06 00 	mov	r13,	6(r1)	;
    8bf4:	81 4e 08 00 	mov	r14,	8(r1)	;
    8bf8:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    8bfc:	b1 40 02 51 	mov	#20738,	2(r1)	;#0x5102
    8c00:	02 00 
    8c02:	81 47 00 00 	mov	r7,	0(r1)	;
    8c06:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    8c0a:	3c 40 5a 53 	mov	#21338,	r12	;#0x535a
    8c0e:	b0 12 7e 91 	call	#-28290	;#0x917e

00008c12 <.Loc.157.3>:
    chnWrite(&SD1, (const uint8_t *)out_string, strlen(out_string));
    8c12:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8c16:	2a 4c       	mov	@r12,	r10	;
    8c18:	3c 40 5a 53 	mov	#21338,	r12	;#0x535a
    8c1c:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8c20:	0e 4c       	mov	r12,	r14	;
    8c22:	3d 40 5a 53 	mov	#21338,	r13	;#0x535a
    8c26:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8c2a:	8a 12       	call	r10		;

00008c2c <.Loc.158.3>:
    sniprintf(out_string, 128, fmt_string, "Top", temps[1] >> 8);
    8c2c:	17 42 da 53 	mov	&0x53da,r7	;0x53da
    8c30:	18 42 fe 5c 	mov	&0x5cfe,r8	;0x5cfe
    8c34:	19 42 00 5d 	mov	&0x5d00,r9	;0x5d00
    8c38:	1a 42 02 5d 	mov	&0x5d02,r10	;0x5d02
    8c3c:	1b 42 04 5d 	mov	&0x5d04,r11	;0x5d04
    8c40:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    8c44:	0c 48       	mov	r8,	r12	;
    8c46:	0d 49       	mov	r9,	r13	;
    8c48:	0e 4a       	mov	r10,	r14	;
    8c4a:	0f 4b       	mov	r11,	r15	;
    8c4c:	b0 12 64 8e 	call	#-29084	;#0x8e64
    8c50:	08 4c       	mov	r12,	r8	;
    8c52:	09 4d       	mov	r13,	r9	;
    8c54:	0a 4e       	mov	r14,	r10	;
    8c56:	0b 4f       	mov	r15,	r11	;
    8c58:	0c 48       	mov	r8,	r12	;
    8c5a:	0d 49       	mov	r9,	r13	;
    8c5c:	0e 4a       	mov	r10,	r14	;
    8c5e:	0f 4b       	mov	r11,	r15	;
    8c60:	81 4c 04 00 	mov	r12,	4(r1)	;
    8c64:	81 4d 06 00 	mov	r13,	6(r1)	;
    8c68:	81 4e 08 00 	mov	r14,	8(r1)	;
    8c6c:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    8c70:	b1 40 09 51 	mov	#20745,	2(r1)	;#0x5109
    8c74:	02 00 
    8c76:	81 47 00 00 	mov	r7,	0(r1)	;
    8c7a:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    8c7e:	3c 40 5a 53 	mov	#21338,	r12	;#0x535a
    8c82:	b0 12 7e 91 	call	#-28290	;#0x917e

00008c86 <.Loc.159.3>:
    chnWrite(&SD1, (const uint8_t *)out_string, strlen(out_string));
    8c86:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8c8a:	2a 4c       	mov	@r12,	r10	;
    8c8c:	3c 40 5a 53 	mov	#21338,	r12	;#0x535a
    8c90:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8c94:	0e 4c       	mov	r12,	r14	;
    8c96:	3d 40 5a 53 	mov	#21338,	r13	;#0x535a
    8c9a:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8c9e:	8a 12       	call	r10		;

00008ca0 <.Loc.161.3>:
    
    if (powered != (palReadLine(LINE_PA_PC_EN) == PAL_HIGH)) {
    8ca0:	5c 41 13 00 	mov.b	19(r1),	r12	;0x00013
    8ca4:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    8ca8:	2d 4d       	mov	@r13,	r13	;
    8caa:	5d 03       	rrum	#1,	r13	;
    8cac:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8cb0:	0e 4d       	mov	r13,	r14	;
    8cb2:	5e f3       	and.b	#1,	r14	;r3 As==01
    8cb4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8cb6:	1e 93       	cmp	#1,	r14	;r3 As==01
    8cb8:	01 24       	jz	$+4      	;abs 0x8cbc
    8cba:	4d 43       	clr.b	r13		;

00008cbc <.L31>:
    8cbc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8cc0:	0c 9d       	cmp	r13,	r12	;
    8cc2:	1c 24       	jz	$+58     	;abs 0x8cfc

00008cc4 <.Loc.162.3>:
      chnWrite(&SD1, (const uint8_t *)err_string, strlen(err_string));
    8cc4:	1c 42 fe 51 	mov	&0x51fe,r12	;0x51fe
    8cc8:	2a 4c       	mov	@r12,	r10	;
    8cca:	19 42 e0 53 	mov	&0x53e0,r9	;0x53e0
    8cce:	1c 42 e0 53 	mov	&0x53e0,r12	;0x53e0
    8cd2:	b0 12 e8 91 	call	#-28184	;#0x91e8
    8cd6:	0e 4c       	mov	r12,	r14	;
    8cd8:	0d 49       	mov	r9,	r13	;
    8cda:	3c 40 fe 51 	mov	#20990,	r12	;#0x51fe
    8cde:	8a 12       	call	r10		;

00008ce0 <.Loc.163.3>:
      powered = (palReadLine(LINE_PA_PC_EN) == PAL_HIGH);
    8ce0:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    8ce4:	2c 4c       	mov	@r12,	r12	;
    8ce6:	5c 03       	rrum	#1,	r12	;
    8ce8:	4a 18 0c 11 	rpt #11 { rrax.w	r12		;
    8cec:	0d 4c       	mov	r12,	r13	;
    8cee:	5d f3       	and.b	#1,	r13	;r3 As==01
    8cf0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8cf2:	1d 93       	cmp	#1,	r13	;r3 As==01
    8cf4:	01 24       	jz	$+4      	;abs 0x8cf8
    8cf6:	4c 43       	clr.b	r12		;

00008cf8 <.L33>:
    8cf8:	c1 4c 13 00 	mov.b	r12,	19(r1)	; 0x0013

00008cfc <.L32>:
    }
    
    chThdSleepMilliseconds(500);
    8cfc:	3c 40 f4 01 	mov	#500,	r12	;#0x01f4
    8d00:	b0 12 e8 66 	call	#26344		;#0x66e8

00008d04 <.Loc.112.3>:
    in = sdGetTimeout(&SD1, TIME_IMMEDIATE);
    8d04:	73 3e       	jmp	$-792    	;abs 0x89ec

00008d06 <main>:
    8d06:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    8d0a:	5c 01 

00008d0c <L0>:
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
  

  halInit();
    8d0c:	b0 12 c0 68 	call	#26816		;#0x68c0

00008d10 <.Loc.194.3>:
  chSysInit();
    8d10:	b0 12 e0 63 	call	#25568		;#0x63e0

00008d14 <.Loc.195.3>:
  dmaInit();
    8d14:	b0 12 d8 7a 	call	#31448		;#0x7ad8

00008d18 <.L37>:
  
  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    8d18:	ff 3f       	jmp	$+0      	;abs 0x8d18

00008d1a <__mspabi_mpyll>:
    8d1a:	6a 15       	pushm	#7,	r10	;16-bit words

00008d1c <L0>:
    8d1c:	31 80 1c 00 	sub	#28,	r1	;#0x001c

00008d20 <.LCFI1>:
    8d20:	81 4a 14 00 	mov	r10,	20(r1)	; 0x0014
    8d24:	81 4b 16 00 	mov	r11,	22(r1)	; 0x0016
    8d28:	06 4c       	mov	r12,	r6	;
    8d2a:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    8d2e:	81 4e 18 00 	mov	r14,	24(r1)	; 0x0018
    8d32:	81 4f 1a 00 	mov	r15,	26(r1)	; 0x001a

00008d36 <.LBB2>:
    8d36:	0a 48       	mov	r8,	r10	;
    8d38:	81 48 0e 00 	mov	r8,	14(r1)	; 0x000e
    8d3c:	0c 48       	mov	r8,	r12	;

00008d3e <.LVL3>:
    8d3e:	0d 49       	mov	r9,	r13	;
    8d40:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8d44:	b0 12 30 91 	call	#-28368	;#0x9130
    8d48:	81 4c 00 00 	mov	r12,	0(r1)	;
    8d4c:	81 4d 02 00 	mov	r13,	2(r1)	;

00008d50 <.LVL5>:
    8d50:	81 46 10 00 	mov	r6,	16(r1)	; 0x0010
    8d54:	0c 46       	mov	r6,	r12	;
    8d56:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8d5a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8d5e:	b0 12 30 91 	call	#-28368	;#0x9130
    8d62:	81 4c 04 00 	mov	r12,	4(r1)	;
    8d66:	81 4d 06 00 	mov	r13,	6(r1)	;
    8d6a:	38 40 4a 91 	mov	#-28342,r8	;#0x914a

00008d6e <.LVL9>:
    8d6e:	0e 46       	mov	r6,	r14	;
    8d70:	4f 43       	clr.b	r15		;
    8d72:	0c 4a       	mov	r10,	r12	;
    8d74:	0d 4f       	mov	r15,	r13	;
    8d76:	88 12       	call	r8		;

00008d78 <.LVL10>:
    8d78:	04 4c       	mov	r12,	r4	;
    8d7a:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
    8d7e:	05 4d       	mov	r13,	r5	;

00008d80 <.LVL11>:
    8d80:	0e 46       	mov	r6,	r14	;
    8d82:	4f 43       	clr.b	r15		;
    8d84:	2c 41       	mov	@r1,	r12	;
    8d86:	1d 41 02 00 	mov	2(r1),	r13	;
    8d8a:	88 12       	call	r8		;

00008d8c <.LVL12>:
    8d8c:	06 4c       	mov	r12,	r6	;
    8d8e:	07 4d       	mov	r13,	r7	;

00008d90 <.LVL14>:
    8d90:	1e 41 04 00 	mov	4(r1),	r14	;
    8d94:	1f 41 06 00 	mov	6(r1),	r15	;
    8d98:	2c 41       	mov	@r1,	r12	;
    8d9a:	1d 41 02 00 	mov	2(r1),	r13	;
    8d9e:	88 12       	call	r8		;

00008da0 <.LVL15>:
    8da0:	81 4c 00 00 	mov	r12,	0(r1)	;

00008da4 <.LVL16>:
    8da4:	81 4d 02 00 	mov	r13,	2(r1)	;

00008da8 <.LVL17>:
    8da8:	1e 41 04 00 	mov	4(r1),	r14	;
    8dac:	1f 41 06 00 	mov	6(r1),	r15	;
    8db0:	0c 4a       	mov	r10,	r12	;
    8db2:	4d 43       	clr.b	r13		;
    8db4:	88 12       	call	r8		;

00008db6 <.LVL18>:
    8db6:	0a 4c       	mov	r12,	r10	;
    8db8:	0a 56       	add	r6,	r10	;
    8dba:	08 4d       	mov	r13,	r8	;
    8dbc:	08 67       	addc	r7,	r8	;
    8dbe:	0c 44       	mov	r4,	r12	;
    8dc0:	0d 45       	mov	r5,	r13	;
    8dc2:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8dc6:	b0 12 30 91 	call	#-28368	;#0x9130
    8dca:	05 4c       	mov	r12,	r5	;

00008dcc <.LVL22>:
    8dcc:	05 5a       	add	r10,	r5	;
    8dce:	0d 68       	addc	r8,	r13	;

00008dd0 <.LVL23>:
    8dd0:	0d 97       	cmp	r7,	r13	;
    8dd2:	04 28       	jnc	$+10     	;abs 0x8ddc
    8dd4:	07 9d       	cmp	r13,	r7	;
    8dd6:	06 20       	jnz	$+14     	;abs 0x8de4
    8dd8:	05 96       	cmp	r6,	r5	;
    8dda:	04 2c       	jc	$+10     	;abs 0x8de4

00008ddc <.L4>:
    8ddc:	81 53 00 00 	add	#0,	0(r1)	;r3 As==00
    8de0:	91 63 02 00 	addc	#1,	2(r1)	;r3 As==01

00008de4 <.L2>:
    8de4:	0c 45       	mov	r5,	r12	;
    8de6:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8dea:	b0 12 30 91 	call	#-28368	;#0x9130

00008dee <.LVL25>:
    8dee:	28 41       	mov	@r1,	r8	;
    8df0:	08 5c       	add	r12,	r8	;
    8df2:	1d 61 02 00 	addc	2(r1),	r13	;
    8df6:	0a 4d       	mov	r13,	r10	;
    8df8:	47 43       	clr.b	r7		;

00008dfa <.LVL27>:
    8dfa:	0c 45       	mov	r5,	r12	;
    8dfc:	0d 47       	mov	r7,	r13	;
    8dfe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    8e02:	b0 12 08 90 	call	#-28664	;#0x9008
    8e06:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    8e0a:	0c 5f       	add	r15,	r12	;
    8e0c:	0d 67       	addc	r7,	r13	;

00008e0e <.LBE2>:
    8e0e:	04 4c       	mov	r12,	r4	;
    8e10:	05 4d       	mov	r13,	r5	;
    8e12:	06 48       	mov	r8,	r6	;
    8e14:	07 4a       	mov	r10,	r7	;

00008e16 <.Loc.553.1>:
    8e16:	3a 40 4a 91 	mov	#-28342,r10	;#0x914a
    8e1a:	1e 41 18 00 	mov	24(r1),	r14	;0x00018
    8e1e:	1f 41 1a 00 	mov	26(r1),	r15	;0x0001a
    8e22:	1c 41 0e 00 	mov	14(r1),	r12	;0x0000e
    8e26:	0d 49       	mov	r9,	r13	;
    8e28:	8a 12       	call	r10		;

00008e2a <.LVL29>:
    8e2a:	09 4c       	mov	r12,	r9	;
    8e2c:	08 4d       	mov	r13,	r8	;

00008e2e <.Loc.554.1>:
    8e2e:	1e 41 14 00 	mov	20(r1),	r14	;0x00014
    8e32:	1f 41 16 00 	mov	22(r1),	r15	;0x00016
    8e36:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8e3a:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8e3e:	8a 12       	call	r10		;

00008e40 <.LVL30>:
    8e40:	09 5c       	add	r12,	r9	;
    8e42:	81 49 08 00 	mov	r9,	8(r1)	;
    8e46:	08 6d       	addc	r13,	r8	;
    8e48:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a

00008e4c <.Loc.553.1>:
    8e4c:	16 51 08 00 	add	8(r1),	r6	;
    8e50:	17 61 0a 00 	addc	10(r1),	r7	;0x0000a

00008e54 <.Loc.557.1>:
    8e54:	0c 44       	mov	r4,	r12	;
    8e56:	0d 45       	mov	r5,	r13	;
    8e58:	0e 46       	mov	r6,	r14	;
    8e5a:	0f 47       	mov	r7,	r15	;
    8e5c:	31 50 1c 00 	add	#28,	r1	;#0x001c

00008e60 <.LVL31>:
    8e60:	64 17       	popm	#7,	r10	;16-bit words
    8e62:	30 41       	ret			

00008e64 <__ashrdi3>:
    8e64:	6a 15       	pushm	#7,	r10	;16-bit words

00008e66 <.LCFI0>:
    8e66:	21 83       	decd	r1		;

00008e68 <.LCFI1>:
    8e68:	05 4c       	mov	r12,	r5	;
    8e6a:	0a 4d       	mov	r13,	r10	;
    8e6c:	1b 41 12 00 	mov	18(r1),	r11	;0x00012

00008e70 <.Loc.461.1>:
    8e70:	0b 93       	cmp	#0,	r11	;r3 As==00
    8e72:	1e 24       	jz	$+62     	;abs 0x8eb0

00008e74 <.Loc.465.1>:
    8e74:	37 40 20 00 	mov	#32,	r7	;#0x0020
    8e78:	07 8b       	sub	r11,	r7	;

00008e7a <.LVL1>:
    8e7a:	4c 43       	clr.b	r12		;

00008e7c <.LVL2>:
    8e7c:	0c 97       	cmp	r7,	r12	;
    8e7e:	1d 38       	jl	$+60     	;abs 0x8eba

00008e80 <.Loc.471.1>:
    8e80:	06 4e       	mov	r14,	r6	;
    8e82:	0a 4f       	mov	r15,	r10	;
    8e84:	0c 4e       	mov	r14,	r12	;
    8e86:	0d 4f       	mov	r15,	r13	;
    8e88:	7e 40 1f 00 	mov.b	#31,	r14	;#0x001f
    8e8c:	b0 12 7c 90 	call	#-28548	;#0x907c
    8e90:	08 4c       	mov	r12,	r8	;
    8e92:	09 4d       	mov	r13,	r9	;

00008e94 <.Loc.472.1>:
    8e94:	0e 43       	clr	r14		;
    8e96:	0e 87       	sub	r7,	r14	;
    8e98:	0c 46       	mov	r6,	r12	;
    8e9a:	0d 4a       	mov	r10,	r13	;
    8e9c:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    8ea0:	0f 7f       	subc	r15,	r15	;
    8ea2:	3f e3       	inv	r15		;
    8ea4:	b0 12 7c 90 	call	#-28548	;#0x907c
    8ea8:	05 4c       	mov	r12,	r5	;
    8eaa:	0a 4d       	mov	r13,	r10	;

00008eac <.L4>:
    8eac:	0e 48       	mov	r8,	r14	;
    8eae:	0f 49       	mov	r9,	r15	;

00008eb0 <.L2>:
    8eb0:	0c 45       	mov	r5,	r12	;
    8eb2:	0d 4a       	mov	r10,	r13	;
    8eb4:	21 53       	incd	r1		;
    8eb6:	64 17       	popm	#7,	r10	;16-bit words
    8eb8:	30 41       	ret			

00008eba <.L3>:
    8eba:	04 4e       	mov	r14,	r4	;
    8ebc:	06 4f       	mov	r15,	r6	;

00008ebe <.Loc.478.1>:
    8ebe:	0c 4e       	mov	r14,	r12	;
    8ec0:	0d 4f       	mov	r15,	r13	;
    8ec2:	0e 4b       	mov	r11,	r14	;
    8ec4:	0f 4b       	mov	r11,	r15	;
    8ec6:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8eca:	81 4b 00 00 	mov	r11,	0(r1)	;
    8ece:	b0 12 7c 90 	call	#-28548	;#0x907c

00008ed2 <.LVL9>:
    8ed2:	08 4c       	mov	r12,	r8	;
    8ed4:	09 4d       	mov	r13,	r9	;

00008ed6 <.Loc.479.1>:
    8ed6:	0c 45       	mov	r5,	r12	;
    8ed8:	0d 4a       	mov	r10,	r13	;
    8eda:	2b 41       	mov	@r1,	r11	;
    8edc:	0e 4b       	mov	r11,	r14	;
    8ede:	0f 43       	clr	r15		;
    8ee0:	b0 12 30 91 	call	#-28368	;#0x9130
    8ee4:	05 4c       	mov	r12,	r5	;
    8ee6:	0a 4d       	mov	r13,	r10	;

00008ee8 <.Loc.476.1>:
    8ee8:	0c 44       	mov	r4,	r12	;
    8eea:	0d 46       	mov	r6,	r13	;
    8eec:	0e 47       	mov	r7,	r14	;
    8eee:	0f 43       	clr	r15		;
    8ef0:	b0 12 08 90 	call	#-28664	;#0x9008

00008ef4 <.Loc.479.1>:
    8ef4:	0a dd       	bis	r13,	r10	;
    8ef6:	0d 45       	mov	r5,	r13	;
    8ef8:	0d dc       	bis	r12,	r13	;
    8efa:	05 4d       	mov	r13,	r5	;
    8efc:	d7 3f       	jmp	$-80     	;abs 0x8eac

00008efe <udivmodsi4>:
    8efe:	5a 15       	pushm	#6,	r10	;16-bit words

00008f00 <L0>:
    8f00:	0a 4c       	mov	r12,	r10	;
    8f02:	0b 4d       	mov	r13,	r11	;

00008f04 <.LVL1>:
    8f04:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00008f08 <.Loc.35.1>:
    8f08:	58 43       	mov.b	#1,	r8	;r3 As==01
    8f0a:	49 43       	clr.b	r9		;

00008f0c <.Loc.38.1>:
    8f0c:	07 4b       	mov	r11,	r7	;

00008f0e <.L2>:
    8f0e:	0f 9b       	cmp	r11,	r15	;
    8f10:	11 28       	jnc	$+36     	;abs 0x8f34
    8f12:	07 9f       	cmp	r15,	r7	;
    8f14:	02 20       	jnz	$+6      	;abs 0x8f1a
    8f16:	0e 9a       	cmp	r10,	r14	;
    8f18:	0d 28       	jnc	$+28     	;abs 0x8f34

00008f1a <.L20>:
    8f1a:	4c 43       	clr.b	r12		;

00008f1c <.LVL3>:
    8f1c:	0d 4c       	mov	r12,	r13	;

00008f1e <.L5>:
    8f1e:	07 48       	mov	r8,	r7	;
    8f20:	07 d9       	bis	r9,	r7	;
    8f22:	07 93       	cmp	#0,	r7	;r3 As==00
    8f24:	19 20       	jnz	$+52     	;abs 0x8f58

00008f26 <.L6>:
    8f26:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    8f2a:	02 24       	jz	$+6      	;abs 0x8f30
    8f2c:	0c 4a       	mov	r10,	r12	;
    8f2e:	0d 4b       	mov	r11,	r13	;

00008f30 <.L1>:
    8f30:	55 17       	popm	#6,	r10	;16-bit words
    8f32:	30 41       	ret			

00008f34 <.L3>:
    8f34:	3d 53       	add	#-1,	r13	;r3 As==11

00008f36 <.Loc.38.1>:
    8f36:	0d 93       	cmp	#0,	r13	;r3 As==00
    8f38:	20 24       	jz	$+66     	;abs 0x8f7a

00008f3a <.Loc.38.1>:
    8f3a:	0f 93       	cmp	#0,	r15	;r3 As==00
    8f3c:	ee 3b       	jl	$-34     	;abs 0x8f1a

00008f3e <.Loc.40.1>:
    8f3e:	05 4e       	mov	r14,	r5	;
    8f40:	06 4f       	mov	r15,	r6	;
    8f42:	05 5e       	add	r14,	r5	;
    8f44:	06 6f       	addc	r15,	r6	;
    8f46:	0e 45       	mov	r5,	r14	;

00008f48 <.LVL7>:
    8f48:	0f 46       	mov	r6,	r15	;

00008f4a <.LVL8>:
    8f4a:	05 48       	mov	r8,	r5	;
    8f4c:	06 49       	mov	r9,	r6	;
    8f4e:	05 58       	add	r8,	r5	;
    8f50:	06 69       	addc	r9,	r6	;
    8f52:	08 45       	mov	r5,	r8	;

00008f54 <.LVL9>:
    8f54:	09 46       	mov	r6,	r9	;

00008f56 <.LVL10>:
    8f56:	db 3f       	jmp	$-72     	;abs 0x8f0e

00008f58 <.L12>:
    8f58:	0b 9f       	cmp	r15,	r11	;
    8f5a:	08 28       	jnc	$+18     	;abs 0x8f6c
    8f5c:	0f 9b       	cmp	r11,	r15	;
    8f5e:	02 20       	jnz	$+6      	;abs 0x8f64
    8f60:	0a 9e       	cmp	r14,	r10	;
    8f62:	04 28       	jnc	$+10     	;abs 0x8f6c

00008f64 <.L16>:
    8f64:	0a 8e       	sub	r14,	r10	;
    8f66:	0b 7f       	subc	r15,	r11	;

00008f68 <.Loc.48.1>:
    8f68:	0c d8       	bis	r8,	r12	;

00008f6a <.LVL13>:
    8f6a:	0d d9       	bis	r9,	r13	;

00008f6c <.L10>:
    8f6c:	12 c3       	clrc			
    8f6e:	09 10       	rrc	r9		;
    8f70:	08 10       	rrc	r8		;

00008f72 <.Loc.51.1>:
    8f72:	12 c3       	clrc			
    8f74:	0f 10       	rrc	r15		;
    8f76:	0e 10       	rrc	r14		;
    8f78:	d2 3f       	jmp	$-90     	;abs 0x8f1e

00008f7a <.L14>:
    8f7a:	0c 4d       	mov	r13,	r12	;

00008f7c <.LVL18>:
    8f7c:	d4 3f       	jmp	$-86     	;abs 0x8f26

00008f7e <__mspabi_divlu>:
    8f7e:	21 83       	decd	r1		;

00008f80 <.LCFI5>:
    8f80:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00008f84 <L0>:
    8f84:	b0 12 fe 8e 	call	#-28930	;#0x8efe

00008f88 <.LVL46>:
    8f88:	21 53       	incd	r1		;
    8f8a:	30 41       	ret			

00008f8c <__mspabi_remul>:
    8f8c:	21 83       	decd	r1		;

00008f8e <.LCFI6>:
    8f8e:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    8f92:	b0 12 fe 8e 	call	#-28930	;#0x8efe

00008f96 <.LVL48>:
    8f96:	21 53       	incd	r1		;
    8f98:	30 41       	ret			

00008f9a <__mspabi_slli_15>:
    8f9a:	0c 5c       	rla	r12		;

00008f9c <__mspabi_slli_14>:
    8f9c:	0c 5c       	rla	r12		;

00008f9e <__mspabi_slli_13>:
    8f9e:	0c 5c       	rla	r12		;

00008fa0 <__mspabi_slli_12>:
    8fa0:	0c 5c       	rla	r12		;

00008fa2 <__mspabi_slli_11>:
    8fa2:	0c 5c       	rla	r12		;

00008fa4 <__mspabi_slli_10>:
    8fa4:	0c 5c       	rla	r12		;

00008fa6 <__mspabi_slli_9>:
    8fa6:	0c 5c       	rla	r12		;

00008fa8 <__mspabi_slli_8>:
    8fa8:	0c 5c       	rla	r12		;

00008faa <__mspabi_slli_7>:
    8faa:	0c 5c       	rla	r12		;

00008fac <__mspabi_slli_6>:
    8fac:	0c 5c       	rla	r12		;

00008fae <__mspabi_slli_5>:
    8fae:	0c 5c       	rla	r12		;

00008fb0 <__mspabi_slli_4>:
    8fb0:	0c 5c       	rla	r12		;

00008fb2 <__mspabi_slli_3>:
    8fb2:	0c 5c       	rla	r12		;

00008fb4 <__mspabi_slli_2>:
    8fb4:	0c 5c       	rla	r12		;

00008fb6 <__mspabi_slli_1>:
    8fb6:	0c 5c       	rla	r12		;
    8fb8:	30 41       	ret			

00008fba <.L11>:
    8fba:	3d 53       	add	#-1,	r13	;r3 As==11
    8fbc:	0c 5c       	rla	r12		;

00008fbe <__mspabi_slli>:
    8fbe:	0d 93       	cmp	#0,	r13	;r3 As==00
    8fc0:	fc 23       	jnz	$-6      	;abs 0x8fba
    8fc2:	30 41       	ret			

00008fc4 <__mspabi_slll_15>:
    8fc4:	0c 5c       	rla	r12		;
    8fc6:	0d 6d       	rlc	r13		;

00008fc8 <__mspabi_slll_14>:
    8fc8:	0c 5c       	rla	r12		;
    8fca:	0d 6d       	rlc	r13		;

00008fcc <__mspabi_slll_13>:
    8fcc:	0c 5c       	rla	r12		;
    8fce:	0d 6d       	rlc	r13		;

00008fd0 <__mspabi_slll_12>:
    8fd0:	0c 5c       	rla	r12		;
    8fd2:	0d 6d       	rlc	r13		;

00008fd4 <__mspabi_slll_11>:
    8fd4:	0c 5c       	rla	r12		;
    8fd6:	0d 6d       	rlc	r13		;

00008fd8 <__mspabi_slll_10>:
    8fd8:	0c 5c       	rla	r12		;
    8fda:	0d 6d       	rlc	r13		;

00008fdc <__mspabi_slll_9>:
    8fdc:	0c 5c       	rla	r12		;
    8fde:	0d 6d       	rlc	r13		;

00008fe0 <__mspabi_slll_8>:
    8fe0:	0c 5c       	rla	r12		;
    8fe2:	0d 6d       	rlc	r13		;

00008fe4 <__mspabi_slll_7>:
    8fe4:	0c 5c       	rla	r12		;
    8fe6:	0d 6d       	rlc	r13		;

00008fe8 <__mspabi_slll_6>:
    8fe8:	0c 5c       	rla	r12		;
    8fea:	0d 6d       	rlc	r13		;

00008fec <__mspabi_slll_5>:
    8fec:	0c 5c       	rla	r12		;
    8fee:	0d 6d       	rlc	r13		;

00008ff0 <__mspabi_slll_4>:
    8ff0:	0c 5c       	rla	r12		;
    8ff2:	0d 6d       	rlc	r13		;

00008ff4 <__mspabi_slll_3>:
    8ff4:	0c 5c       	rla	r12		;
    8ff6:	0d 6d       	rlc	r13		;

00008ff8 <__mspabi_slll_2>:
    8ff8:	0c 5c       	rla	r12		;
    8ffa:	0d 6d       	rlc	r13		;

00008ffc <__mspabi_slll_1>:
    8ffc:	0c 5c       	rla	r12		;
    8ffe:	0d 6d       	rlc	r13		;
    9000:	30 41       	ret			

00009002 <.L12>:
    9002:	3e 53       	add	#-1,	r14	;r3 As==11
    9004:	0c 5c       	rla	r12		;
    9006:	0d 6d       	rlc	r13		;

00009008 <__mspabi_slll>:
    9008:	0e 93       	cmp	#0,	r14	;r3 As==00
    900a:	fb 23       	jnz	$-8      	;abs 0x9002
    900c:	30 41       	ret			

0000900e <__mspabi_srai_15>:
    900e:	0c 11       	rra	r12		;

00009010 <__mspabi_srai_14>:
    9010:	0c 11       	rra	r12		;

00009012 <__mspabi_srai_13>:
    9012:	0c 11       	rra	r12		;

00009014 <__mspabi_srai_12>:
    9014:	0c 11       	rra	r12		;

00009016 <__mspabi_srai_11>:
    9016:	0c 11       	rra	r12		;

00009018 <__mspabi_srai_10>:
    9018:	0c 11       	rra	r12		;

0000901a <__mspabi_srai_9>:
    901a:	0c 11       	rra	r12		;

0000901c <__mspabi_srai_8>:
    901c:	0c 11       	rra	r12		;

0000901e <__mspabi_srai_7>:
    901e:	0c 11       	rra	r12		;

00009020 <__mspabi_srai_6>:
    9020:	0c 11       	rra	r12		;

00009022 <__mspabi_srai_5>:
    9022:	0c 11       	rra	r12		;

00009024 <__mspabi_srai_4>:
    9024:	0c 11       	rra	r12		;

00009026 <__mspabi_srai_3>:
    9026:	0c 11       	rra	r12		;

00009028 <__mspabi_srai_2>:
    9028:	0c 11       	rra	r12		;

0000902a <__mspabi_srai_1>:
    902a:	0c 11       	rra	r12		;
    902c:	30 41       	ret			

0000902e <.L11>:
    902e:	3d 53       	add	#-1,	r13	;r3 As==11
    9030:	0c 11       	rra	r12		;

00009032 <__mspabi_srai>:
    9032:	0d 93       	cmp	#0,	r13	;r3 As==00
    9034:	fc 23       	jnz	$-6      	;abs 0x902e
    9036:	30 41       	ret			

00009038 <__mspabi_sral_15>:
    9038:	0d 11       	rra	r13		;
    903a:	0c 10       	rrc	r12		;

0000903c <__mspabi_sral_14>:
    903c:	0d 11       	rra	r13		;
    903e:	0c 10       	rrc	r12		;

00009040 <__mspabi_sral_13>:
    9040:	0d 11       	rra	r13		;
    9042:	0c 10       	rrc	r12		;

00009044 <__mspabi_sral_12>:
    9044:	0d 11       	rra	r13		;
    9046:	0c 10       	rrc	r12		;

00009048 <__mspabi_sral_11>:
    9048:	0d 11       	rra	r13		;
    904a:	0c 10       	rrc	r12		;

0000904c <__mspabi_sral_10>:
    904c:	0d 11       	rra	r13		;
    904e:	0c 10       	rrc	r12		;

00009050 <__mspabi_sral_9>:
    9050:	0d 11       	rra	r13		;
    9052:	0c 10       	rrc	r12		;

00009054 <__mspabi_sral_8>:
    9054:	0d 11       	rra	r13		;
    9056:	0c 10       	rrc	r12		;

00009058 <__mspabi_sral_7>:
    9058:	0d 11       	rra	r13		;
    905a:	0c 10       	rrc	r12		;

0000905c <__mspabi_sral_6>:
    905c:	0d 11       	rra	r13		;
    905e:	0c 10       	rrc	r12		;

00009060 <__mspabi_sral_5>:
    9060:	0d 11       	rra	r13		;
    9062:	0c 10       	rrc	r12		;

00009064 <__mspabi_sral_4>:
    9064:	0d 11       	rra	r13		;
    9066:	0c 10       	rrc	r12		;

00009068 <__mspabi_sral_3>:
    9068:	0d 11       	rra	r13		;
    906a:	0c 10       	rrc	r12		;

0000906c <__mspabi_sral_2>:
    906c:	0d 11       	rra	r13		;
    906e:	0c 10       	rrc	r12		;

00009070 <__mspabi_sral_1>:
    9070:	0d 11       	rra	r13		;
    9072:	0c 10       	rrc	r12		;
    9074:	30 41       	ret			

00009076 <.L12>:
    9076:	3e 53       	add	#-1,	r14	;r3 As==11
    9078:	0d 11       	rra	r13		;
    907a:	0c 10       	rrc	r12		;

0000907c <__mspabi_sral>:
    907c:	0e 93       	cmp	#0,	r14	;r3 As==00
    907e:	fb 23       	jnz	$-8      	;abs 0x9076
    9080:	30 41       	ret			

00009082 <__mspabi_srli_15>:
    9082:	12 c3       	clrc			
    9084:	0c 10       	rrc	r12		;

00009086 <__mspabi_srli_14>:
    9086:	12 c3       	clrc			
    9088:	0c 10       	rrc	r12		;

0000908a <__mspabi_srli_13>:
    908a:	12 c3       	clrc			
    908c:	0c 10       	rrc	r12		;

0000908e <__mspabi_srli_12>:
    908e:	12 c3       	clrc			
    9090:	0c 10       	rrc	r12		;

00009092 <__mspabi_srli_11>:
    9092:	12 c3       	clrc			
    9094:	0c 10       	rrc	r12		;

00009096 <__mspabi_srli_10>:
    9096:	12 c3       	clrc			
    9098:	0c 10       	rrc	r12		;

0000909a <__mspabi_srli_9>:
    909a:	12 c3       	clrc			
    909c:	0c 10       	rrc	r12		;

0000909e <__mspabi_srli_8>:
    909e:	12 c3       	clrc			
    90a0:	0c 10       	rrc	r12		;

000090a2 <__mspabi_srli_7>:
    90a2:	12 c3       	clrc			
    90a4:	0c 10       	rrc	r12		;

000090a6 <__mspabi_srli_6>:
    90a6:	12 c3       	clrc			
    90a8:	0c 10       	rrc	r12		;

000090aa <__mspabi_srli_5>:
    90aa:	12 c3       	clrc			
    90ac:	0c 10       	rrc	r12		;

000090ae <__mspabi_srli_4>:
    90ae:	12 c3       	clrc			
    90b0:	0c 10       	rrc	r12		;

000090b2 <__mspabi_srli_3>:
    90b2:	12 c3       	clrc			
    90b4:	0c 10       	rrc	r12		;

000090b6 <__mspabi_srli_2>:
    90b6:	12 c3       	clrc			
    90b8:	0c 10       	rrc	r12		;

000090ba <__mspabi_srli_1>:
    90ba:	12 c3       	clrc			
    90bc:	0c 10       	rrc	r12		;
    90be:	30 41       	ret			

000090c0 <.L11>:
    90c0:	3d 53       	add	#-1,	r13	;r3 As==11
    90c2:	12 c3       	clrc			
    90c4:	0c 10       	rrc	r12		;

000090c6 <__mspabi_srli>:
    90c6:	0d 93       	cmp	#0,	r13	;r3 As==00
    90c8:	fb 23       	jnz	$-8      	;abs 0x90c0
    90ca:	30 41       	ret			

000090cc <__mspabi_srll_15>:
    90cc:	12 c3       	clrc			
    90ce:	0d 10       	rrc	r13		;
    90d0:	0c 10       	rrc	r12		;

000090d2 <__mspabi_srll_14>:
    90d2:	12 c3       	clrc			
    90d4:	0d 10       	rrc	r13		;
    90d6:	0c 10       	rrc	r12		;

000090d8 <__mspabi_srll_13>:
    90d8:	12 c3       	clrc			
    90da:	0d 10       	rrc	r13		;
    90dc:	0c 10       	rrc	r12		;

000090de <__mspabi_srll_12>:
    90de:	12 c3       	clrc			
    90e0:	0d 10       	rrc	r13		;
    90e2:	0c 10       	rrc	r12		;

000090e4 <__mspabi_srll_11>:
    90e4:	12 c3       	clrc			
    90e6:	0d 10       	rrc	r13		;
    90e8:	0c 10       	rrc	r12		;

000090ea <__mspabi_srll_10>:
    90ea:	12 c3       	clrc			
    90ec:	0d 10       	rrc	r13		;
    90ee:	0c 10       	rrc	r12		;

000090f0 <__mspabi_srll_9>:
    90f0:	12 c3       	clrc			
    90f2:	0d 10       	rrc	r13		;
    90f4:	0c 10       	rrc	r12		;

000090f6 <__mspabi_srll_8>:
    90f6:	12 c3       	clrc			
    90f8:	0d 10       	rrc	r13		;
    90fa:	0c 10       	rrc	r12		;

000090fc <__mspabi_srll_7>:
    90fc:	12 c3       	clrc			
    90fe:	0d 10       	rrc	r13		;
    9100:	0c 10       	rrc	r12		;

00009102 <__mspabi_srll_6>:
    9102:	12 c3       	clrc			
    9104:	0d 10       	rrc	r13		;
    9106:	0c 10       	rrc	r12		;

00009108 <__mspabi_srll_5>:
    9108:	12 c3       	clrc			
    910a:	0d 10       	rrc	r13		;
    910c:	0c 10       	rrc	r12		;

0000910e <__mspabi_srll_4>:
    910e:	12 c3       	clrc			
    9110:	0d 10       	rrc	r13		;
    9112:	0c 10       	rrc	r12		;

00009114 <__mspabi_srll_3>:
    9114:	12 c3       	clrc			
    9116:	0d 10       	rrc	r13		;
    9118:	0c 10       	rrc	r12		;

0000911a <__mspabi_srll_2>:
    911a:	12 c3       	clrc			
    911c:	0d 10       	rrc	r13		;
    911e:	0c 10       	rrc	r12		;

00009120 <__mspabi_srll_1>:
    9120:	12 c3       	clrc			
    9122:	0d 10       	rrc	r13		;
    9124:	0c 10       	rrc	r12		;
    9126:	30 41       	ret			

00009128 <.L12>:
    9128:	3e 53       	add	#-1,	r14	;r3 As==11
    912a:	12 c3       	clrc			
    912c:	0d 10       	rrc	r13		;
    912e:	0c 10       	rrc	r12		;

00009130 <__mspabi_srll>:
    9130:	0e 93       	cmp	#0,	r14	;r3 As==00
    9132:	fa 23       	jnz	$-10     	;abs 0x9128
    9134:	30 41       	ret			

00009136 <__mspabi_mpyi>:
    9136:	02 12       	push	r2		;
    9138:	32 c2       	dint			
    913a:	03 43       	nop			
    913c:	82 4c c0 04 	mov	r12,	&0x04c0	;
    9140:	82 4d c8 04 	mov	r13,	&0x04c8	;
    9144:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    9148:	00 13       	reti			

0000914a <__mspabi_mpyl>:
    914a:	02 12       	push	r2		;
    914c:	32 c2       	dint			
    914e:	03 43       	nop			
    9150:	82 4c d0 04 	mov	r12,	&0x04d0	;
    9154:	82 4d d2 04 	mov	r13,	&0x04d2	;
    9158:	82 4e e0 04 	mov	r14,	&0x04e0	;
    915c:	82 4f e2 04 	mov	r15,	&0x04e2	;
    9160:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    9164:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    9168:	00 13       	reti			

0000916a <memcpy>:
    916a:	0f 4c       	mov	r12,	r15	;
    916c:	0e 5c       	add	r12,	r14	;

0000916e <.L2>:
    916e:	0f 9e       	cmp	r14,	r15	;
    9170:	05 24       	jz	$+12     	;abs 0x917c

00009172 <.LVL3>:
    9172:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    9176:	1f 53       	inc	r15		;

00009178 <.LVL4>:
    9178:	1d 53       	inc	r13		;
    917a:	f9 3f       	jmp	$-12     	;abs 0x916e

0000917c <.L5>:
    917c:	30 41       	ret			

0000917e <sniprintf>:
    917e:	1a 15       	pushm	#2,	r10	;16-bit words

00009180 <L0>:
    9180:	31 80 3c 00 	sub	#60,	r1	;#0x003c

00009184 <.LCFI3>:
    9184:	0a 4d       	mov	r13,	r10	;

00009186 <.Loc.95.1>:
    9186:	19 42 14 5c 	mov	&0x5c14,r9	;0x5c14

0000918a <.Loc.97.1>:
    918a:	0d 93       	cmp	#0,	r13	;r3 As==00
    918c:	05 34       	jge	$+12     	;abs 0x9198

0000918e <.Loc.99.1>:
    918e:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    9192:	00 00 

00009194 <.Loc.100.1>:
    9194:	3c 43       	mov	#-1,	r12	;r3 As==11

00009196 <.LVL9>:
    9196:	24 3c       	jmp	$+74     	;abs 0x91e0

00009198 <.L12>:
    9198:	b1 40 08 02 	mov	#520,	6(r1)	;#0x0208
    919c:	06 00 

0000919e <.Loc.103.1>:
    919e:	81 4c 00 00 	mov	r12,	0(r1)	;
    91a2:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

000091a6 <.Loc.104.1>:
    91a6:	0c 4d       	mov	r13,	r12	;

000091a8 <.LVL11>:
    91a8:	0d 93       	cmp	#0,	r13	;r3 As==00
    91aa:	01 24       	jz	$+4      	;abs 0x91ae

000091ac <.LVL12>:
    91ac:	3c 53       	add	#-1,	r12	;r3 As==11

000091ae <.L14>:
    91ae:	81 4c 04 00 	mov	r12,	4(r1)	;
    91b2:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c

000091b6 <.Loc.105.1>:
    91b6:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

000091ba <.LVL13>:
    91ba:	0f 41       	mov	r1,	r15	;
    91bc:	3f 50 44 00 	add	#68,	r15	;#0x0044
    91c0:	1e 41 42 00 	mov	66(r1),	r14	;0x00042
    91c4:	0d 41       	mov	r1,	r13	;
    91c6:	0c 49       	mov	r9,	r12	;
    91c8:	b0 12 1a 93 	call	#-27878	;#0x931a

000091cc <.LVL14>:
    91cc:	3c 93       	cmp	#-1,	r12	;r3 As==11
    91ce:	03 34       	jge	$+8      	;abs 0x91d6

000091d0 <.Loc.114.1>:
    91d0:	b9 40 8b 00 	mov	#139,	0(r9)	;#0x008b
    91d4:	00 00 

000091d6 <.L15>:
    91d6:	0a 93       	cmp	#0,	r10	;r3 As==00
    91d8:	03 24       	jz	$+8      	;abs 0x91e0

000091da <.Loc.116.1>:
    91da:	2d 41       	mov	@r1,	r13	;
    91dc:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00

000091e0 <.L11>:
    91e0:	31 50 3c 00 	add	#60,	r1	;#0x003c
    91e4:	19 17       	popm	#2,	r10	;16-bit words
    91e6:	30 41       	ret			

000091e8 <strlen>:
    91e8:	0d 4c       	mov	r12,	r13	;

000091ea <L0>:
    91ea:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    91ee:	02 24       	jz	$+6      	;abs 0x91f4

000091f0 <.Loc.86.1>:
    91f0:	1d 53       	inc	r13		;
    91f2:	fb 3f       	jmp	$-8      	;abs 0x91ea

000091f4 <.L5>:
    91f4:	0d 8c       	sub	r12,	r13	;

000091f6 <.LVL4>:
    91f6:	0c 4d       	mov	r13,	r12	;

000091f8 <.LVL5>:
    91f8:	30 41       	ret			

000091fa <__ssprint_r>:
    91fa:	6a 15       	pushm	#7,	r10	;16-bit words

000091fc <L0>:
    91fc:	21 82       	sub	#4,	r1	;r2 As==10

000091fe <.LCFI1>:
    91fe:	07 4c       	mov	r12,	r7	;
    9200:	04 4d       	mov	r13,	r4	;
    9202:	08 4e       	mov	r14,	r8	;

00009204 <.LVL1>:
    9204:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00
    9208:	2c 24       	jz	$+90     	;abs 0x9262

0000920a <.Loc.280.1>:
    920a:	26 4e       	mov	@r14,	r6	;
    920c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    9210:	19 41 02 00 	mov	2(r1),	r9	;
    9214:	05 3c       	jmp	$+12     	;abs 0x9220

00009216 <.L5>:
    9216:	a1 46 02 00 	mov	@r6,	2(r1)	;

0000921a <.Loc.291.1>:
    921a:	19 46 02 00 	mov	2(r6),	r9	;

0000921e <.LVL3>:
    921e:	26 52       	add	#4,	r6	;r2 As==10

00009220 <.L3>:
    9220:	09 93       	cmp	#0,	r9	;r3 As==00
    9222:	f9 27       	jz	$-12     	;abs 0x9216

00009224 <.Loc.294.1>:
    9224:	1b 44 04 00 	mov	4(r4),	r11	;

00009228 <.LVL5>:
    9228:	09 9b       	cmp	r11,	r9	;
    922a:	72 28       	jnc	$+230    	;abs 0x9310

0000922c <.Loc.295.1>:
    922c:	1e 44 06 00 	mov	6(r4),	r14	;
    9230:	3e b0 80 04 	bit	#1152,	r14	;#0x0480
    9234:	1a 20       	jnz	$+54     	;abs 0x926a

00009236 <.L6>:
    9236:	09 9b       	cmp	r11,	r9	;
    9238:	6b 28       	jnc	$+216    	;abs 0x9310

0000923a <.L12>:
    923a:	0e 4b       	mov	r11,	r14	;
    923c:	1d 41 02 00 	mov	2(r1),	r13	;
    9240:	2c 44       	mov	@r4,	r12	;
    9242:	81 4b 00 00 	mov	r11,	0(r1)	;
    9246:	b0 12 d2 9c 	call	#-25390	;#0x9cd2

0000924a <.LVL6>:
    924a:	2b 41       	mov	@r1,	r11	;
    924c:	84 8b 04 00 	sub	r11,	4(r4)	;

00009250 <.Loc.344.1>:
    9250:	84 5b 00 00 	add	r11,	0(r4)	;

00009254 <.LVL7>:
    9254:	1c 48 04 00 	mov	4(r8),	r12	;
    9258:	0c 89       	sub	r9,	r12	;
    925a:	88 4c 04 00 	mov	r12,	4(r8)	;
    925e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9260:	da 23       	jnz	$-74     	;abs 0x9216

00009262 <.L2>:
    9262:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

00009266 <.Loc.285.1>:
    9266:	4c 43       	clr.b	r12		;
    9268:	55 3c       	jmp	$+172    	;abs 0x9314

0000926a <.L21>:
    926a:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    926e:	25 44       	mov	@r4,	r5	;
    9270:	05 8d       	sub	r13,	r5	;

00009272 <.LVL10>:
    9272:	1c 44 0c 00 	mov	12(r4),	r12	;0x0000c
    9276:	0a 4c       	mov	r12,	r10	;
    9278:	0a 5c       	add	r12,	r10	;
    927a:	0a 5c       	add	r12,	r10	;
    927c:	0c 4a       	mov	r10,	r12	;
    927e:	5c 03       	rrum	#1,	r12	;
    9280:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    9284:	0a 5c       	add	r12,	r10	;
    9286:	0a 11       	rra	r10		;

00009288 <.LVL11>:
    9288:	0c 45       	mov	r5,	r12	;
    928a:	1c 53       	inc	r12		;
    928c:	0c 59       	add	r9,	r12	;
    928e:	0a 9c       	cmp	r12,	r10	;
    9290:	01 2c       	jc	$+4      	;abs 0x9294

00009292 <.Loc.308.1>:
    9292:	0a 4c       	mov	r12,	r10	;

00009294 <.L7>:
    9294:	3e b0 00 04 	bit	#1024,	r14	;#0x0400
    9298:	17 24       	jz	$+48     	;abs 0x92c8

0000929a <.Loc.312.1>:
    929a:	0d 4a       	mov	r10,	r13	;
    929c:	0c 47       	mov	r7,	r12	;
    929e:	b0 12 10 9e 	call	#-25072	;#0x9e10

000092a2 <.LVL13>:
    92a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    92a4:	1d 24       	jz	$+60     	;abs 0x92e0

000092a6 <.Loc.318.1>:
    92a6:	0e 45       	mov	r5,	r14	;
    92a8:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    92ac:	81 4c 00 00 	mov	r12,	0(r1)	;
    92b0:	b0 12 6a 91 	call	#-28310	;#0x916a

000092b4 <.LVL14>:
    92b4:	1c 44 06 00 	mov	6(r4),	r12	;
    92b8:	3c f0 7f fb 	and	#-1153,	r12	;#0xfb7f
    92bc:	3c d0 80 00 	bis	#128,	r12	;#0x0080
    92c0:	84 4c 06 00 	mov	r12,	6(r4)	;
    92c4:	2b 41       	mov	@r1,	r11	;
    92c6:	18 3c       	jmp	$+50     	;abs 0x92f8

000092c8 <.L8>:
    92c8:	0e 4a       	mov	r10,	r14	;
    92ca:	0c 47       	mov	r7,	r12	;
    92cc:	b0 12 0e 9f 	call	#-24818	;#0x9f0e

000092d0 <.LVL16>:
    92d0:	0b 4c       	mov	r12,	r11	;

000092d2 <.LVL17>:
    92d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    92d4:	11 20       	jnz	$+36     	;abs 0x92f8

000092d6 <.Loc.327.1>:
    92d6:	1d 44 0a 00 	mov	10(r4),	r13	;0x0000a
    92da:	0c 47       	mov	r7,	r12	;
    92dc:	b0 12 0c 9d 	call	#-25332	;#0x9d0c

000092e0 <.L19>:
    92e0:	b7 40 0c 00 	mov	#12,	0(r7)	;#0x000c
    92e4:	00 00 

000092e6 <.L10>:
    92e6:	b4 d0 40 00 	bis	#64,	6(r4)	;#0x0040
    92ea:	06 00 

000092ec <.Loc.356.1>:
    92ec:	88 43 04 00 	mov	#0,	4(r8)	;r3 As==00

000092f0 <.Loc.357.1>:
    92f0:	88 43 02 00 	mov	#0,	2(r8)	;r3 As==00

000092f4 <.Loc.358.1>:
    92f4:	3c 43       	mov	#-1,	r12	;r3 As==11
    92f6:	0e 3c       	jmp	$+30     	;abs 0x9314

000092f8 <.L11>:
    92f8:	84 4b 0a 00 	mov	r11,	10(r4)	; 0x000a

000092fc <.Loc.335.1>:
    92fc:	0b 55       	add	r5,	r11	;

000092fe <.LVL20>:
    92fe:	84 4b 00 00 	mov	r11,	0(r4)	;

00009302 <.Loc.336.1>:
    9302:	84 4a 0c 00 	mov	r10,	12(r4)	; 0x000c

00009306 <.LVL21>:
    9306:	0b 49       	mov	r9,	r11	;

00009308 <.Loc.338.1>:
    9308:	0a 85       	sub	r5,	r10	;

0000930a <.LVL22>:
    930a:	84 4a 04 00 	mov	r10,	4(r4)	;
    930e:	93 3f       	jmp	$-216    	;abs 0x9236

00009310 <.L15>:
    9310:	0b 49       	mov	r9,	r11	;
    9312:	93 3f       	jmp	$-216    	;abs 0x923a

00009314 <.L1>:
    9314:	21 52       	add	#4,	r1	;r2 As==10
    9316:	64 17       	popm	#7,	r10	;16-bit words
    9318:	30 41       	ret			

0000931a <_svfiprintf_r>:
    931a:	6a 15       	pushm	#7,	r10	;16-bit words

0000931c <.LCFI2>:
    931c:	31 80 62 00 	sub	#98,	r1	;#0x0062

00009320 <.LCFI3>:
    9320:	81 4c 02 00 	mov	r12,	2(r1)	;
    9324:	0a 4d       	mov	r13,	r10	;

00009326 <L0>:
    9326:	08 4e       	mov	r14,	r8	;
    9328:	09 4f       	mov	r15,	r9	;

0000932a <.LVL26>:
    932a:	1d 4d 06 00 	mov	6(r13),	r13	;

0000932e <.LVL27>:
    932e:	7d f0 80 00 	and.b	#128,	r13	;#0x0080
    9332:	0d 93       	cmp	#0,	r13	;r3 As==00
    9334:	19 24       	jz	$+52     	;abs 0x9368

00009336 <.Loc.880.1>:
    9336:	8a 93 0a 00 	cmp	#0,	10(r10)	;r3 As==00, 0x000a
    933a:	16 20       	jnz	$+46     	;abs 0x9368

0000933c <.Loc.882.1>:
    933c:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    9340:	b0 12 10 9e 	call	#-25072	;#0x9e10

00009344 <.LVL28>:
    9344:	8a 4c 00 00 	mov	r12,	0(r10)	;
    9348:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000934c <.Loc.883.1>:
    934c:	0c 93       	cmp	#0,	r12	;r3 As==00
    934e:	09 20       	jnz	$+20     	;abs 0x9362

00009350 <.Loc.885.1>:
    9350:	1c 41 02 00 	mov	2(r1),	r12	;
    9354:	bc 40 0c 00 	mov	#12,	0(r12)	;#0x000c
    9358:	00 00 

0000935a <.Loc.886.1>:
    935a:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11
    935e:	30 40 ae 9c 	br	#0x9cae		;

00009362 <.L24>:
    9362:	ba 40 40 00 	mov	#64,	12(r10)	;#0x0040, 0x000c
    9366:	0c 00 

00009368 <.L23>:
    9368:	7d 40 1a 00 	mov.b	#26,	r13	;#0x001a
    936c:	0d 51       	add	r1,	r13	;
    936e:	81 4d 14 00 	mov	r13,	20(r1)	; 0x0014

00009372 <.Loc.895.1>:
    9372:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018

00009376 <.Loc.896.1>:
    9376:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

0000937a <.LVL30>:
    937a:	81 48 04 00 	mov	r8,	4(r1)	;

0000937e <.Loc.894.1>:
    937e:	0b 4d       	mov	r13,	r11	;

00009380 <.Loc.718.1>:
    9380:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c

00009384 <.Loc.898.1>:
    9384:	91 41 0c 00 	mov	12(r1),	8(r1)	;0x0000c
    9388:	08 00 

0000938a <.L26>:
    938a:	18 41 04 00 	mov	4(r1),	r8	;

0000938e <.L27>:
    938e:	6c 48       	mov.b	@r8,	r12	;
    9390:	0c 93       	cmp	#0,	r12	;r3 As==00
    9392:	05 24       	jz	$+12     	;abs 0x939e

00009394 <.Loc.925.1>:
    9394:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    9398:	02 24       	jz	$+6      	;abs 0x939e

0000939a <.Loc.926.1>:
    939a:	18 53       	inc	r8		;
    939c:	f8 3f       	jmp	$-14     	;abs 0x938e

0000939e <.L28>:
    939e:	07 48       	mov	r8,	r7	;
    93a0:	17 81 04 00 	sub	4(r1),	r7	;

000093a4 <.LVL34>:
    93a4:	07 93       	cmp	#0,	r7	;r3 As==00
    93a6:	23 24       	jz	$+72     	;abs 0x93ee

000093a8 <.Loc.929.1>:
    93a8:	9b 41 04 00 	mov	4(r1),	0(r11)	;
    93ac:	00 00 
    93ae:	8b 47 02 00 	mov	r7,	2(r11)	;
    93b2:	81 57 18 00 	add	r7,	24(r1)	; 0x0018

000093b6 <.LVL35>:
    93b6:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    93ba:	1c 53       	inc	r12		;
    93bc:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    93c0:	7e 40 07 00 	mov.b	#7,	r14	;
    93c4:	0e 9c       	cmp	r12,	r14	;
    93c6:	02 38       	jl	$+6      	;abs 0x93cc
    93c8:	2b 52       	add	#4,	r11	;r2 As==10

000093ca <.LVL36>:
    93ca:	0f 3c       	jmp	$+32     	;abs 0x93ea

000093cc <.L31>:
    93cc:	0e 41       	mov	r1,	r14	;
    93ce:	3e 50 14 00 	add	#20,	r14	;#0x0014
    93d2:	0d 4a       	mov	r10,	r13	;
    93d4:	1c 41 02 00 	mov	2(r1),	r12	;
    93d8:	b0 12 fa 91 	call	#-28166	;#0x91fa

000093dc <.LVL38>:
    93dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    93de:	02 24       	jz	$+6      	;abs 0x93e4
    93e0:	80 00 a2 9c 	mova	#40098,	r0	;0x09ca2

000093e4 <.Loc.929.1>:
    93e4:	0b 41       	mov	r1,	r11	;
    93e6:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000093ea <.L32>:
    93ea:	81 57 08 00 	add	r7,	8(r1)	;

000093ee <.L30>:
    93ee:	c8 93 00 00 	cmp.b	#0,	0(r8)	;r3 As==00
    93f2:	02 20       	jnz	$+6      	;abs 0x93f8
    93f4:	80 00 8c 9c 	mova	#40076,	r0	;0x09c8c

000093f8 <.LVL41>:
    93f8:	0c 48       	mov	r8,	r12	;
    93fa:	1c 53       	inc	r12		;

000093fc <.LVL42>:
    93fc:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    9400:	4d 43       	clr.b	r13		;
    9402:	0e 4d       	mov	r13,	r14	;

00009404 <.Loc.945.1>:
    9404:	36 43       	mov	#-1,	r6	;r3 As==11

00009406 <.Loc.944.1>:
    9406:	81 4d 06 00 	mov	r13,	6(r1)	;

0000940a <.Loc.942.1>:
    940a:	05 4d       	mov	r13,	r5	;

0000940c <.Loc.959.1>:
    940c:	58 43       	mov.b	#1,	r8	;r3 As==01

0000940e <.L35>:
    940e:	04 4c       	mov	r12,	r4	;
    9410:	14 53       	inc	r4		;
    9412:	81 44 04 00 	mov	r4,	4(r1)	;

00009416 <.LVL44>:
    9416:	6c 4c       	mov.b	@r12,	r12	;

00009418 <.L37>:
    9418:	3c 90 58 00 	cmp	#88,	r12	;#0x0058
    941c:	92 24       	jz	$+294    	;abs 0x9542
    941e:	77 40 58 00 	mov.b	#88,	r7	;#0x0058
    9422:	07 9c       	cmp	r12,	r7	;
    9424:	41 38       	jl	$+132    	;abs 0x94a8
    9426:	3c 90 2e 00 	cmp	#46,	r12	;#0x002e
    942a:	aa 24       	jz	$+342    	;abs 0x9580
    942c:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    9430:	0f 9c       	cmp	r12,	r15	;
    9432:	1f 38       	jl	$+64     	;abs 0x9472
    9434:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    9438:	92 24       	jz	$+294    	;abs 0x955e
    943a:	74 40 2a 00 	mov.b	#42,	r4	;#0x002a
    943e:	04 9c       	cmp	r12,	r4	;
    9440:	0c 38       	jl	$+26     	;abs 0x945a
    9442:	3c 90 20 00 	cmp	#32,	r12	;#0x0020
    9446:	85 24       	jz	$+268    	;abs 0x9552
    9448:	3c 90 23 00 	cmp	#35,	r12	;#0x0023
    944c:	02 24       	jz	$+6      	;abs 0x9452
    944e:	80 00 ee 98 	mova	#39150,	r0	;0x098ee

00009452 <.Loc.979.1>:
    9452:	15 d3       	bis	#1,	r5	;r3 As==01

00009454 <.L36>:
    9454:	1c 41 04 00 	mov	4(r1),	r12	;
    9458:	da 3f       	jmp	$-74     	;abs 0x940e

0000945a <.L44>:
    945a:	3c 90 2b 00 	cmp	#43,	r12	;#0x002b
    945e:	04 20       	jnz	$+10     	;abs 0x9468
    9460:	0d 48       	mov	r8,	r13	;

00009462 <.Loc.1030.1>:
    9462:	7e 40 2b 00 	mov.b	#43,	r14	;#0x002b
    9466:	f6 3f       	jmp	$-18     	;abs 0x9454

00009468 <.L234>:
    9468:	3c 90 2d 00 	cmp	#45,	r12	;#0x002d
    946c:	87 24       	jz	$+272    	;abs 0x957c
    946e:	30 40 ee 98 	br	#0x98ee		;

00009472 <.L42>:
    9472:	77 40 39 00 	mov.b	#57,	r7	;#0x0039
    9476:	07 9c       	cmp	r12,	r7	;
    9478:	0b 38       	jl	$+24     	;abs 0x9490
    947a:	3c 90 31 00 	cmp	#49,	r12	;#0x0031
    947e:	aa 34       	jge	$+342    	;abs 0x95d4
    9480:	3c 90 30 00 	cmp	#48,	r12	;#0x0030
    9484:	02 24       	jz	$+6      	;abs 0x948a
    9486:	80 00 ee 98 	mova	#39150,	r0	;0x098ee

0000948a <.Loc.1084.1>:
    948a:	35 d0 80 00 	bis	#128,	r5	;#0x0080

0000948e <.Loc.1085.1>:
    948e:	e2 3f       	jmp	$-58     	;abs 0x9454

00009490 <.L48>:
    9490:	3c 90 4f 00 	cmp	#79,	r12	;#0x004f
    9494:	0e 25       	jz	$+542    	;abs 0x96b2
    9496:	3c 90 55 00 	cmp	#85,	r12	;#0x0055
    949a:	45 25       	jz	$+652    	;abs 0x9726
    949c:	3c 90 44 00 	cmp	#68,	r12	;#0x0044
    94a0:	02 24       	jz	$+6      	;abs 0x94a6
    94a2:	80 00 ee 98 	mova	#39150,	r0	;0x098ee
    94a6:	c7 3c       	jmp	$+400    	;abs 0x9636

000094a8 <.L40>:
    94a8:	3c 90 6e 00 	cmp	#110,	r12	;#0x006e
    94ac:	e8 24       	jz	$+466    	;abs 0x967e
    94ae:	7f 40 6e 00 	mov.b	#110,	r15	;#0x006e
    94b2:	0f 9c       	cmp	r12,	r15	;
    94b4:	17 38       	jl	$+48     	;abs 0x94e4
    94b6:	3c 90 68 00 	cmp	#104,	r12	;#0x0068
    94ba:	a9 24       	jz	$+340    	;abs 0x960e
    94bc:	74 40 68 00 	mov.b	#104,	r4	;#0x0068
    94c0:	04 9c       	cmp	r12,	r4	;
    94c2:	08 38       	jl	$+18     	;abs 0x94d4
    94c4:	3c 90 63 00 	cmp	#99,	r12	;#0x0063
    94c8:	a8 24       	jz	$+338    	;abs 0x961a
    94ca:	3c 90 64 00 	cmp	#100,	r12	;#0x0064
    94ce:	34 24       	jz	$+106    	;abs 0x9538
    94d0:	30 40 ee 98 	br	#0x98ee		;

000094d4 <.L57>:
    94d4:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    94d8:	2f 24       	jz	$+96     	;abs 0x9538
    94da:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    94de:	9a 24       	jz	$+310    	;abs 0x9614
    94e0:	30 40 ee 98 	br	#0x98ee		;

000094e4 <.L55>:
    94e4:	3c 90 71 00 	cmp	#113,	r12	;#0x0071
    94e8:	95 24       	jz	$+300    	;abs 0x9614
    94ea:	77 40 71 00 	mov.b	#113,	r7	;#0x0071
    94ee:	07 9c       	cmp	r12,	r7	;
    94f0:	19 38       	jl	$+52     	;abs 0x9524
    94f2:	3c 90 6f 00 	cmp	#111,	r12	;#0x006f
    94f6:	df 24       	jz	$+448    	;abs 0x96b6
    94f8:	3c 90 70 00 	cmp	#112,	r12	;#0x0070
    94fc:	02 24       	jz	$+6      	;abs 0x9502
    94fe:	80 00 ee 98 	mova	#39150,	r0	;0x098ee

00009502 <.Loc.1428.1>:
    9502:	07 49       	mov	r9,	r7	;
    9504:	27 53       	incd	r7		;

00009506 <.LVL49>:
    9506:	29 49       	mov	@r9,	r9	;
    9508:	08 49       	mov	r9,	r8	;
    950a:	09 43       	clr	r9		;

0000950c <.LVL50>:
    950c:	25 d3       	bis	#2,	r5	;r3 As==10

0000950e <.Loc.1432.1>:
    950e:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    9512:	12 00 

00009514 <.LVL52>:
    9514:	f1 40 78 00 	mov.b	#120,	19(r1)	;#0x0078, 0x0013
    9518:	13 00 

0000951a <.Loc.1430.1>:
    951a:	b1 40 3d 51 	mov	#20797,	12(r1)	;#0x513d, 0x000c
    951e:	0c 00 

00009520 <.Loc.1429.1>:
    9520:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009522 <.Loc.1434.1>:
    9522:	3a 3d       	jmp	$+630    	;abs 0x9798

00009524 <.L62>:
    9524:	3c 90 75 00 	cmp	#117,	r12	;#0x0075
    9528:	00 25       	jz	$+514    	;abs 0x972a
    952a:	3c 90 78 00 	cmp	#120,	r12	;#0x0078
    952e:	0f 25       	jz	$+544    	;abs 0x974e
    9530:	3c 90 73 00 	cmp	#115,	r12	;#0x0073
    9534:	dc 21       	jnz	$+954    	;abs 0x98ee
    9536:	d9 3c       	jmp	$+436    	;abs 0x96ea

00009538 <.L59>:
    9538:	0d 93       	cmp	#0,	r13	;r3 As==00
    953a:	83 24       	jz	$+264    	;abs 0x9642
    953c:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011
    9540:	80 3c       	jmp	$+258    	;abs 0x9642

00009542 <.L39>:
    9542:	0d 93       	cmp	#0,	r13	;r3 As==00
    9544:	02 24       	jz	$+6      	;abs 0x954a
    9546:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000954a <.L70>:
    954a:	b1 40 2c 51 	mov	#20780,	12(r1)	;#0x512c, 0x000c
    954e:	0c 00 

00009550 <.LVL54>:
    9550:	05 3d       	jmp	$+524    	;abs 0x975c

00009552 <.L45>:
    9552:	0e 93       	cmp	#0,	r14	;r3 As==00
    9554:	7f 23       	jnz	$-256    	;abs 0x9454
    9556:	0d 48       	mov	r8,	r13	;

00009558 <.Loc.976.1>:
    9558:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    955c:	7b 3f       	jmp	$-264    	;abs 0x9454

0000955e <.L43>:
    955e:	0f 49       	mov	r9,	r15	;
    9560:	1f 53       	inc	r15		;
    9562:	1f c3       	bic	#1,	r15	;r3 As==01
    9564:	09 4f       	mov	r15,	r9	;

00009566 <.LVL56>:
    9566:	29 53       	incd	r9		;

00009568 <.LVL57>:
    9568:	a1 4f 06 00 	mov	@r15,	6(r1)	;

0000956c <.LVL58>:
    956c:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    9570:	71 37       	jge	$-284    	;abs 0x9454

00009572 <.Loc.1024.1>:
    9572:	44 43       	clr.b	r4		;
    9574:	14 81 06 00 	sub	6(r1),	r4	;
    9578:	81 44 06 00 	mov	r4,	6(r1)	;

0000957c <.L47>:
    957c:	25 d2       	bis	#4,	r5	;r2 As==10

0000957e <.Loc.1028.1>:
    957e:	6a 3f       	jmp	$-298    	;abs 0x9454

00009580 <.L41>:
    9580:	1f 41 04 00 	mov	4(r1),	r15	;
    9584:	1f 53       	inc	r15		;

00009586 <.LVL61>:
    9586:	17 41 04 00 	mov	4(r1),	r7	;
    958a:	6c 47       	mov.b	@r7,	r12	;
    958c:	3c 90 2a 00 	cmp	#42,	r12	;#0x002a
    9590:	02 24       	jz	$+6      	;abs 0x9596
    9592:	46 43       	clr.b	r6		;

00009594 <.LVL63>:
    9594:	0c 3c       	jmp	$+26     	;abs 0x95ae

00009596 <.L72>:
    9596:	19 53       	inc	r9		;

00009598 <.LVL65>:
    9598:	0c 49       	mov	r9,	r12	;

0000959a <.LVL66>:
    959a:	1c c3       	bic	#1,	r12	;r3 As==01
    959c:	09 4c       	mov	r12,	r9	;

0000959e <.LVL67>:
    959e:	29 53       	incd	r9		;

000095a0 <.LVL68>:
    95a0:	26 4c       	mov	@r12,	r6	;
    95a2:	06 93       	cmp	#0,	r6	;r3 As==00
    95a4:	01 34       	jge	$+4      	;abs 0x95a8
    95a6:	36 43       	mov	#-1,	r6	;r3 As==11

000095a8 <.L74>:
    95a8:	81 4f 04 00 	mov	r15,	4(r1)	;
    95ac:	53 3f       	jmp	$-344    	;abs 0x9454

000095ae <.L73>:
    95ae:	81 4f 04 00 	mov	r15,	4(r1)	;

000095b2 <.LVL70>:
    95b2:	07 4c       	mov	r12,	r7	;
    95b4:	37 50 d0 ff 	add	#-48,	r7	;#0xffd0
    95b8:	74 40 09 00 	mov.b	#9,	r4	;
    95bc:	04 97       	cmp	r7,	r4	;
    95be:	2c 2b       	jnc	$-422    	;abs 0x9418

000095c0 <.LVL71>:
    95c0:	0c 46       	mov	r6,	r12	;

000095c2 <.LVL72>:
    95c2:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    95c6:	0c 56       	add	r6,	r12	;
    95c8:	0c 5c       	rla	r12		;
    95ca:	06 47       	mov	r7,	r6	;

000095cc <.LVL73>:
    95cc:	06 5c       	add	r12,	r6	;

000095ce <.LVL74>:
    95ce:	6c 4f       	mov.b	@r15,	r12	;

000095d0 <.LVL75>:
    95d0:	1f 53       	inc	r15		;

000095d2 <.LVL76>:
    95d2:	ed 3f       	jmp	$-36     	;abs 0x95ae

000095d4 <.L49>:
    95d4:	17 41 04 00 	mov	4(r1),	r7	;

000095d8 <.Loc.959.1>:
    95d8:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

000095dc <.L77>:
    95dc:	1f 41 06 00 	mov	6(r1),	r15	;
    95e0:	41 18 0f 5f 	rpt #2 { rlax.w	r15		;
    95e4:	1f 51 06 00 	add	6(r1),	r15	;
    95e8:	0f 5f       	rla	r15		;
    95ea:	3c 50 d0 ff 	add	#-48,	r12	;#0xffd0

000095ee <.LVL79>:
    95ee:	0c 5f       	add	r15,	r12	;

000095f0 <.LVL80>:
    95f0:	81 4c 06 00 	mov	r12,	6(r1)	;

000095f4 <.LVL81>:
    95f4:	91 53 04 00 	inc	4(r1)		;

000095f8 <.Loc.1091.1>:
    95f8:	6c 47       	mov.b	@r7,	r12	;

000095fa <.LVL83>:
    95fa:	17 41 04 00 	mov	4(r1),	r7	;

000095fe <.Loc.1092.1>:
    95fe:	0f 4c       	mov	r12,	r15	;
    9600:	3f 50 d0 ff 	add	#-48,	r15	;#0xffd0
    9604:	74 40 09 00 	mov.b	#9,	r4	;
    9608:	04 9f       	cmp	r15,	r4	;
    960a:	e8 2f       	jc	$-46     	;abs 0x95dc
    960c:	05 3f       	jmp	$-500    	;abs 0x9418

0000960e <.L56>:
    960e:	35 d0 40 00 	bis	#64,	r5	;#0x0040

00009612 <.Loc.1119.1>:
    9612:	20 3f       	jmp	$-446    	;abs 0x9454

00009614 <.L61>:
    9614:	35 d0 10 00 	bis	#16,	r5	;#0x0010

00009618 <.Loc.1131.1>:
    9618:	1d 3f       	jmp	$-452    	;abs 0x9454

0000961a <.L58>:
    961a:	19 53       	inc	r9		;

0000961c <.LVL88>:
    961c:	19 c3       	bic	#1,	r9	;r3 As==01

0000961e <.LVL89>:
    961e:	07 49       	mov	r9,	r7	;
    9620:	27 53       	incd	r7		;

00009622 <.LVL90>:
    9622:	e1 49 3a 00 	mov.b	@r9,	58(r1)	; 0x003a

00009626 <.LVL91>:
    9626:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

0000962a <.Loc.1190.1>:
    962a:	56 43       	mov.b	#1,	r6	;r3 As==01

0000962c <.LVL92>:
    962c:	49 43       	clr.b	r9		;

0000962e <.Loc.1173.1>:
    962e:	04 41       	mov	r1,	r4	;
    9630:	34 50 3a 00 	add	#58,	r4	;#0x003a

00009634 <.Loc.1193.1>:
    9634:	6e 3d       	jmp	$+734    	;abs 0x9912

00009636 <.L235>:
    9636:	0d 93       	cmp	#0,	r13	;r3 As==00
    9638:	02 24       	jz	$+6      	;abs 0x963e
    963a:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

0000963e <.L79>:
    963e:	35 d0 10 00 	bis	#16,	r5	;#0x0010

00009642 <.L69>:
    9642:	19 53       	inc	r9		;

00009644 <.LVL95>:
    9644:	19 c3       	bic	#1,	r9	;r3 As==01

00009646 <.LVL96>:
    9646:	07 49       	mov	r9,	r7	;
    9648:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    964c:	05 24       	jz	$+12     	;abs 0x9658
    964e:	27 52       	add	#4,	r7	;r2 As==10

00009650 <.LVL97>:
    9650:	28 49       	mov	@r9,	r8	;
    9652:	19 49 02 00 	mov	2(r9),	r9	;
    9656:	06 3c       	jmp	$+14     	;abs 0x9664

00009658 <.L80>:
    9658:	27 53       	incd	r7		;

0000965a <.LVL99>:
    965a:	28 49       	mov	@r9,	r8	;
    965c:	38 b0 00 80 	bit	#-32768,r8	;#0x8000
    9660:	09 79       	subc	r9,	r9	;
    9662:	39 e3       	inv	r9		;

00009664 <.L81>:
    9664:	09 93       	cmp	#0,	r9	;r3 As==00
    9666:	9b 34       	jge	$+312    	;abs 0x979e

00009668 <.Loc.1207.1>:
    9668:	4c 43       	clr.b	r12		;

0000966a <.LVL101>:
    966a:	4d 43       	clr.b	r13		;
    966c:	0c 88       	sub	r8,	r12	;
    966e:	0d 79       	subc	r9,	r13	;
    9670:	08 4c       	mov	r12,	r8	;

00009672 <.LVL102>:
    9672:	09 4d       	mov	r13,	r9	;

00009674 <.LVL103>:
    9674:	f1 40 2d 00 	mov.b	#45,	17(r1)	;#0x002d, 0x0011
    9678:	11 00 

0000967a <.Loc.1210.1>:
    967a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    967c:	91 3c       	jmp	$+292    	;abs 0x97a0

0000967e <.L54>:
    967e:	0d 93       	cmp	#0,	r13	;r3 As==00
    9680:	02 24       	jz	$+6      	;abs 0x9686
    9682:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

00009686 <.L86>:
    9686:	0c 49       	mov	r9,	r12	;

00009688 <.LVL105>:
    9688:	2c 53       	incd	r12		;

0000968a <.Loc.1399.1>:
    968a:	2d 49       	mov	@r9,	r13	;

0000968c <.Loc.1398.1>:
    968c:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    9690:	0b 24       	jz	$+24     	;abs 0x96a8

00009692 <.LVL106>:
    9692:	1f 41 08 00 	mov	8(r1),	r15	;
    9696:	0e 4f       	mov	r15,	r14	;
    9698:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    969c:	8d 4e 00 00 	mov	r14,	0(r13)	;
    96a0:	8d 4f 02 00 	mov	r15,	2(r13)	;
    96a4:	09 4c       	mov	r12,	r9	;
    96a6:	71 3e       	jmp	$-796    	;abs 0x938a

000096a8 <.L87>:
    96a8:	9d 41 08 00 	mov	8(r1),	0(r13)	;
    96ac:	00 00 

000096ae <.LVL108>:
    96ae:	09 4c       	mov	r12,	r9	;
    96b0:	6c 3e       	jmp	$-806    	;abs 0x938a

000096b2 <.L51>:
    96b2:	35 d0 10 00 	bis	#16,	r5	;#0x0010

000096b6 <.L63>:
    96b6:	0d 45       	mov	r5,	r13	;
    96b8:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    96bc:	19 53       	inc	r9		;

000096be <.LVL111>:
    96be:	0d 93       	cmp	#0,	r13	;r3 As==00
    96c0:	08 24       	jz	$+18     	;abs 0x96d2
    96c2:	19 c3       	bic	#1,	r9	;r3 As==01

000096c4 <.LVL112>:
    96c4:	07 49       	mov	r9,	r7	;
    96c6:	27 52       	add	#4,	r7	;r2 As==10

000096c8 <.LVL113>:
    96c8:	28 49       	mov	@r9,	r8	;
    96ca:	19 49 02 00 	mov	2(r9),	r9	;

000096ce <.L233>:
    96ce:	4c 43       	clr.b	r12		;
    96d0:	63 3c       	jmp	$+200    	;abs 0x9798

000096d2 <.L90>:
    96d2:	0c 45       	mov	r5,	r12	;

000096d4 <.LVL116>:
    96d4:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    96d8:	19 c3       	bic	#1,	r9	;r3 As==01

000096da <.LVL117>:
    96da:	07 49       	mov	r9,	r7	;
    96dc:	27 53       	incd	r7		;

000096de <.LVL118>:
    96de:	29 49       	mov	@r9,	r9	;
    96e0:	08 49       	mov	r9,	r8	;
    96e2:	09 43       	clr	r9		;
    96e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    96e6:	58 24       	jz	$+178    	;abs 0x9798
    96e8:	f2 3f       	jmp	$-26     	;abs 0x96ce

000096ea <.L236>:
    96ea:	07 49       	mov	r9,	r7	;
    96ec:	27 53       	incd	r7		;

000096ee <.LVL120>:
    96ee:	24 49       	mov	@r9,	r4	;

000096f0 <.Loc.1443.1>:
    96f0:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

000096f4 <.Loc.1518.1>:
    96f4:	36 93       	cmp	#-1,	r6	;r3 As==11
    96f6:	0e 24       	jz	$+30     	;abs 0x9714

000096f8 <.LBB4>:
    96f8:	0e 46       	mov	r6,	r14	;
    96fa:	4d 43       	clr.b	r13		;
    96fc:	0c 44       	mov	r4,	r12	;

000096fe <.LVL121>:
    96fe:	81 4b 00 00 	mov	r11,	0(r1)	;
    9702:	b0 12 ba 9c 	call	#-25414	;#0x9cba

00009706 <.LVL122>:
    9706:	2b 41       	mov	@r1,	r11	;
    9708:	0c 93       	cmp	#0,	r12	;r3 As==00
    970a:	02 25       	jz	$+518    	;abs 0x9910

0000970c <.Loc.1527.1>:
    970c:	06 4c       	mov	r12,	r6	;
    970e:	06 84       	sub	r4,	r6	;

00009710 <.LBE4>:
    9710:	49 43       	clr.b	r9		;

00009712 <.LBB5>:
    9712:	ff 3c       	jmp	$+512    	;abs 0x9912

00009714 <.L93>:
    9714:	0c 44       	mov	r4,	r12	;

00009716 <.LVL125>:
    9716:	81 4b 00 00 	mov	r11,	0(r1)	;
    971a:	b0 12 e8 91 	call	#-28184	;#0x91e8

0000971e <.LVL126>:
    971e:	06 4c       	mov	r12,	r6	;

00009720 <.LVL127>:
    9720:	49 43       	clr.b	r9		;
    9722:	2b 41       	mov	@r1,	r11	;
    9724:	f6 3c       	jmp	$+494    	;abs 0x9912

00009726 <.L52>:
    9726:	35 d0 10 00 	bis	#16,	r5	;#0x0010

0000972a <.L65>:
    972a:	19 53       	inc	r9		;

0000972c <.LVL130>:
    972c:	19 c3       	bic	#1,	r9	;r3 As==01

0000972e <.LVL131>:
    972e:	07 49       	mov	r9,	r7	;
    9730:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    9734:	06 24       	jz	$+14     	;abs 0x9742
    9736:	27 52       	add	#4,	r7	;r2 As==10

00009738 <.LVL132>:
    9738:	28 49       	mov	@r9,	r8	;
    973a:	19 49 02 00 	mov	2(r9),	r9	;

0000973e <.Loc.1539.1>:
    973e:	5c 43       	mov.b	#1,	r12	;r3 As==01

00009740 <.LVL133>:
    9740:	2b 3c       	jmp	$+88     	;abs 0x9798

00009742 <.L94>:
    9742:	27 53       	incd	r7		;

00009744 <.LVL135>:
    9744:	29 49       	mov	@r9,	r9	;

00009746 <.LVL136>:
    9746:	08 49       	mov	r9,	r8	;
    9748:	09 43       	clr	r9		;

0000974a <.Loc.1539.1>:
    974a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000974c <.LVL137>:
    974c:	25 3c       	jmp	$+76     	;abs 0x9798

0000974e <.L66>:
    974e:	0d 93       	cmp	#0,	r13	;r3 As==00
    9750:	02 24       	jz	$+6      	;abs 0x9756
    9752:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

00009756 <.L96>:
    9756:	b1 40 3d 51 	mov	#20797,	12(r1)	;#0x513d, 0x000c
    975a:	0c 00 

0000975c <.L71>:
    975c:	19 53       	inc	r9		;

0000975e <.LVL140>:
    975e:	19 c3       	bic	#1,	r9	;r3 As==01

00009760 <.LVL141>:
    9760:	07 49       	mov	r9,	r7	;
    9762:	35 b0 10 00 	bit	#16,	r5	;#0x0010
    9766:	05 24       	jz	$+12     	;abs 0x9772
    9768:	27 52       	add	#4,	r7	;r2 As==10

0000976a <.LVL142>:
    976a:	28 49       	mov	@r9,	r8	;
    976c:	19 49 02 00 	mov	2(r9),	r9	;
    9770:	04 3c       	jmp	$+10     	;abs 0x977a

00009772 <.L97>:
    9772:	27 53       	incd	r7		;

00009774 <.LVL144>:
    9774:	29 49       	mov	@r9,	r9	;

00009776 <.LVL145>:
    9776:	08 49       	mov	r9,	r8	;
    9778:	09 43       	clr	r9		;

0000977a <.L98>:
    977a:	15 b3       	bit	#1,	r5	;r3 As==01
    977c:	0c 24       	jz	$+26     	;abs 0x9796

0000977e <.Loc.1549.1>:
    977e:	0d 48       	mov	r8,	r13	;
    9780:	0d d9       	bis	r9,	r13	;
    9782:	0d 93       	cmp	#0,	r13	;r3 As==00
    9784:	08 24       	jz	$+18     	;abs 0x9796

00009786 <.Loc.1550.1>:
    9786:	f1 40 30 00 	mov.b	#48,	18(r1)	;#0x0030, 0x0012
    978a:	12 00 

0000978c <.Loc.1551.1>:
    978c:	c1 4c 13 00 	mov.b	r12,	19(r1)	; 0x0013

00009790 <.Loc.1552.1>:
    9790:	25 d3       	bis	#2,	r5	;r3 As==10

00009792 <.Loc.1547.1>:
    9792:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009794 <.LVL148>:
    9794:	01 3c       	jmp	$+4      	;abs 0x9798

00009796 <.L157>:
    9796:	6c 43       	mov.b	#2,	r12	;r3 As==10

00009798 <.L91>:
    9798:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011
    979c:	01 3c       	jmp	$+4      	;abs 0x97a0

0000979e <.L154>:
    979e:	5c 43       	mov.b	#1,	r12	;r3 As==01

000097a0 <.L84>:
    97a0:	36 93       	cmp	#-1,	r6	;r3 As==11
    97a2:	0c 24       	jz	$+26     	;abs 0x97bc

000097a4 <.Loc.1566.1>:
    97a4:	04 45       	mov	r5,	r4	;
    97a6:	34 f0 7f ff 	and	#-129,	r4	;#0xff7f
    97aa:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a

000097ae <.LVL153>:
    97ae:	0d 48       	mov	r8,	r13	;
    97b0:	0d d9       	bis	r9,	r13	;
    97b2:	0d 93       	cmp	#0,	r13	;r3 As==00
    97b4:	09 20       	jnz	$+20     	;abs 0x97c8

000097b6 <.Loc.1574.1>:
    97b6:	06 93       	cmp	#0,	r6	;r3 As==00
    97b8:	84 24       	jz	$+266    	;abs 0x98c2
    97ba:	0b 3c       	jmp	$+24     	;abs 0x97d2

000097bc <.L101>:
    97bc:	0d 48       	mov	r8,	r13	;
    97be:	0d d9       	bis	r9,	r13	;
    97c0:	81 45 0a 00 	mov	r5,	10(r1)	; 0x000a
    97c4:	0d 93       	cmp	#0,	r13	;r3 As==00
    97c6:	05 24       	jz	$+12     	;abs 0x97d2

000097c8 <.L102>:
    97c8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    97ca:	32 24       	jz	$+102    	;abs 0x9830
    97cc:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    97ce:	61 24       	jz	$+196    	;abs 0x9892
    97d0:	06 3c       	jmp	$+14     	;abs 0x97de

000097d2 <.L103>:
    97d2:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    97d4:	33 24       	jz	$+104    	;abs 0x983c
    97d6:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    97d8:	5a 24       	jz	$+182    	;abs 0x988e
    97da:	48 43       	clr.b	r8		;

000097dc <.LVL156>:
    97dc:	49 43       	clr.b	r9		;

000097de <.L105>:
    97de:	05 41       	mov	r1,	r5	;
    97e0:	35 50 62 00 	add	#98,	r5	;#0x0062

000097e4 <.L108>:
    97e4:	04 45       	mov	r5,	r4	;
    97e6:	34 53       	add	#-1,	r4	;r3 As==11

000097e8 <.LVL158>:
    97e8:	4c 48       	mov.b	r8,	r12	;
    97ea:	7c f0 07 00 	and.b	#7,	r12	;
    97ee:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    97f2:	4e 4c       	mov.b	r12,	r14	;
    97f4:	81 4e 0e 00 	mov	r14,	14(r1)	; 0x000e
    97f8:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

000097fc <.Loc.1584.1>:
    97fc:	0c 48       	mov	r8,	r12	;
    97fe:	0d 49       	mov	r9,	r13	;
    9800:	81 4b 00 00 	mov	r11,	0(r1)	;
    9804:	b0 12 14 91 	call	#-28396	;#0x9114

00009808 <.LVL159>:
    9808:	08 4c       	mov	r12,	r8	;

0000980a <.LVL160>:
    980a:	09 4d       	mov	r13,	r9	;

0000980c <.LVL161>:
    980c:	0c dd       	bis	r13,	r12	;
    980e:	2b 41       	mov	@r1,	r11	;

00009810 <.LVL162>:
    9810:	0c 93       	cmp	#0,	r12	;r3 As==00
    9812:	02 24       	jz	$+6      	;abs 0x9818
    9814:	05 44       	mov	r4,	r5	;
    9816:	e6 3f       	jmp	$-50     	;abs 0x97e4

00009818 <.L237>:
    9818:	91 b3 0a 00 	bit	#1,	10(r1)	;r3 As==01, 0x000a
    981c:	60 24       	jz	$+194    	;abs 0x98de

0000981e <.Loc.1587.1>:
    981e:	b1 90 30 00 	cmp	#48,	14(r1)	;#0x0030, 0x000e
    9822:	0e 00 
    9824:	5c 24       	jz	$+186    	;abs 0x98de

00009826 <.LVL163>:
    9826:	f4 40 30 00 	mov.b	#48,	-1(r4)	;#0x0030, 0xffff
    982a:	ff ff 
    982c:	34 53       	add	#-1,	r4	;r3 As==11
    982e:	57 3c       	jmp	$+176    	;abs 0x98de

00009830 <.L106>:
    9830:	09 93       	cmp	#0,	r9	;r3 As==00
    9832:	0d 20       	jnz	$+28     	;abs 0x984e
    9834:	7f 40 09 00 	mov.b	#9,	r15	;
    9838:	0f 98       	cmp	r8,	r15	;
    983a:	09 28       	jnc	$+20     	;abs 0x984e

0000983c <.L112>:
    983c:	4c 48       	mov.b	r8,	r12	;

0000983e <.LVL166>:
    983e:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    9842:	c1 4c 61 00 	mov.b	r12,	97(r1)	; 0x0061
    9846:	04 41       	mov	r1,	r4	;
    9848:	34 50 61 00 	add	#97,	r4	;#0x0061

0000984c <.Loc.1595.1>:
    984c:	48 3c       	jmp	$+146    	;abs 0x98de

0000984e <.L110>:
    984e:	04 41       	mov	r1,	r4	;
    9850:	34 50 62 00 	add	#98,	r4	;#0x0062

00009854 <.Loc.1601.1>:
    9854:	35 40 8c 8f 	mov	#-28788,r5	;#0x8f8c

00009858 <.L113>:
    9858:	34 53       	add	#-1,	r4	;r3 As==11
    985a:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    985e:	4f 43       	clr.b	r15		;
    9860:	0c 48       	mov	r8,	r12	;
    9862:	0d 49       	mov	r9,	r13	;
    9864:	81 4b 00 00 	mov	r11,	0(r1)	;
    9868:	85 12       	call	r5		;
    986a:	7c 50 30 00 	add.b	#48,	r12	;#0x0030
    986e:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

00009872 <.Loc.1622.1>:
    9872:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    9876:	4f 43       	clr.b	r15		;
    9878:	0c 48       	mov	r8,	r12	;
    987a:	0d 49       	mov	r9,	r13	;
    987c:	b0 12 7e 8f 	call	#-28802	;#0x8f7e
    9880:	08 4c       	mov	r12,	r8	;

00009882 <.LVL172>:
    9882:	09 4d       	mov	r13,	r9	;

00009884 <.LVL173>:
    9884:	0c dd       	bis	r13,	r12	;
    9886:	2b 41       	mov	@r1,	r11	;
    9888:	0c 93       	cmp	#0,	r12	;r3 As==00
    988a:	e6 23       	jnz	$-50     	;abs 0x9858
    988c:	28 3c       	jmp	$+82     	;abs 0x98de

0000988e <.L162>:
    988e:	48 43       	clr.b	r8		;

00009890 <.LVL175>:
    9890:	49 43       	clr.b	r9		;

00009892 <.L107>:
    9892:	04 41       	mov	r1,	r4	;
    9894:	34 50 62 00 	add	#98,	r4	;#0x0062

00009898 <.L114>:
    9898:	34 53       	add	#-1,	r4	;r3 As==11
    989a:	0c 48       	mov	r8,	r12	;
    989c:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    98a0:	1c 51 0c 00 	add	12(r1),	r12	;0x0000c
    98a4:	e4 4c 00 00 	mov.b	@r12,	0(r4)	;

000098a8 <.Loc.1629.1>:
    98a8:	0c 48       	mov	r8,	r12	;
    98aa:	0d 49       	mov	r9,	r13	;
    98ac:	81 4b 00 00 	mov	r11,	0(r1)	;
    98b0:	b0 12 0e 91 	call	#-28402	;#0x910e

000098b4 <.LVL178>:
    98b4:	08 4c       	mov	r12,	r8	;

000098b6 <.LVL179>:
    98b6:	09 4d       	mov	r13,	r9	;

000098b8 <.LVL180>:
    98b8:	0c dd       	bis	r13,	r12	;
    98ba:	2b 41       	mov	@r1,	r11	;

000098bc <.LVL181>:
    98bc:	0c 93       	cmp	#0,	r12	;r3 As==00
    98be:	ec 23       	jnz	$-38     	;abs 0x9898
    98c0:	0e 3c       	jmp	$+30     	;abs 0x98de

000098c2 <.L231>:
    98c2:	0c 93       	cmp	#0,	r12	;r3 As==00
    98c4:	09 20       	jnz	$+20     	;abs 0x98d8

000098c6 <.Loc.1648.1>:
    98c6:	15 b3       	bit	#1,	r5	;r3 As==01
    98c8:	07 24       	jz	$+16     	;abs 0x98d8

000098ca <.LVL183>:
    98ca:	f1 40 30 00 	mov.b	#48,	97(r1)	;#0x0030, 0x0061
    98ce:	61 00 
    98d0:	04 41       	mov	r1,	r4	;

000098d2 <.LVL184>:
    98d2:	34 50 61 00 	add	#97,	r4	;#0x0061
    98d6:	03 3c       	jmp	$+8      	;abs 0x98de

000098d8 <.L160>:
    98d8:	04 41       	mov	r1,	r4	;

000098da <.LVL186>:
    98da:	34 50 62 00 	add	#98,	r4	;#0x0062

000098de <.L109>:
    98de:	09 46       	mov	r6,	r9	;
    98e0:	76 40 62 00 	mov.b	#98,	r6	;#0x0062

000098e4 <.LVL188>:
    98e4:	06 51       	add	r1,	r6	;
    98e6:	06 84       	sub	r4,	r6	;
    98e8:	15 41 0a 00 	mov	10(r1),	r5	;0x0000a
    98ec:	12 3c       	jmp	$+38     	;abs 0x9912

000098ee <.L38>:
    98ee:	0d 93       	cmp	#0,	r13	;r3 As==00
    98f0:	02 24       	jz	$+6      	;abs 0x98f6
    98f2:	c1 4e 11 00 	mov.b	r14,	17(r1)	; 0x0011

000098f6 <.L115>:
    98f6:	0c 93       	cmp	#0,	r12	;r3 As==00
    98f8:	c9 25       	jz	$+916    	;abs 0x9c8c

000098fa <.LVL190>:
    98fa:	c1 4c 3a 00 	mov.b	r12,	58(r1)	; 0x003a

000098fe <.LVL191>:
    98fe:	c1 43 11 00 	mov.b	#0,	17(r1)	;r3 As==00, 0x0011

00009902 <.Loc.1662.1>:
    9902:	07 49       	mov	r9,	r7	;

00009904 <.Loc.1660.1>:
    9904:	56 43       	mov.b	#1,	r6	;r3 As==01

00009906 <.LVL192>:
    9906:	49 43       	clr.b	r9		;

00009908 <.LVL193>:
    9908:	04 41       	mov	r1,	r4	;
    990a:	34 50 3a 00 	add	#58,	r4	;#0x003a

0000990e <.Loc.1662.1>:
    990e:	01 3c       	jmp	$+4      	;abs 0x9912

00009910 <.L155>:
    9910:	09 4c       	mov	r12,	r9	;

00009912 <.L78>:
    9912:	08 49       	mov	r9,	r8	;
    9914:	09 96       	cmp	r6,	r9	;
    9916:	01 34       	jge	$+4      	;abs 0x991a
    9918:	08 46       	mov	r6,	r8	;

0000991a <.L116>:
    991a:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    991e:	01 24       	jz	$+4      	;abs 0x9922

00009920 <.Loc.1682.1>:
    9920:	18 53       	inc	r8		;

00009922 <.L117>:
    9922:	0f 45       	mov	r5,	r15	;
    9924:	6f f3       	and.b	#2,	r15	;r3 As==10
    9926:	81 4f 0a 00 	mov	r15,	10(r1)	; 0x000a
    992a:	0f 93       	cmp	#0,	r15	;r3 As==00
    992c:	01 24       	jz	$+4      	;abs 0x9930

0000992e <.Loc.1684.1>:
    992e:	28 53       	incd	r8		;

00009930 <.L118>:
    9930:	0f 45       	mov	r5,	r15	;
    9932:	7f f0 84 00 	and.b	#132,	r15	;#0x0084
    9936:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    993a:	0f 93       	cmp	#0,	r15	;r3 As==00
    993c:	4a 20       	jnz	$+150    	;abs 0x99d2

0000993e <.Loc.1688.1>:
    993e:	1f 41 06 00 	mov	6(r1),	r15	;
    9942:	0f 88       	sub	r8,	r15	;

00009944 <.LVL199>:
    9944:	4c 43       	clr.b	r12		;
    9946:	0c 9f       	cmp	r15,	r12	;
    9948:	44 34       	jge	$+138    	;abs 0x99d2

0000994a <.L120>:
    994a:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    994e:	1c 53       	inc	r12		;

00009950 <.Loc.1688.1>:
    9950:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9954:	bb 40 5e 51 	mov	#20830,	0(r11)	;#0x515e
    9958:	00 00 
    995a:	0e 9f       	cmp	r15,	r14	;
    995c:	21 34       	jge	$+68     	;abs 0x99a0

0000995e <.Loc.1688.1>:
    995e:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    9962:	02 00 
    9964:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9968:	18 00 

0000996a <.LVL201>:
    996a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    996e:	7d 40 07 00 	mov.b	#7,	r13	;
    9972:	0d 9c       	cmp	r12,	r13	;
    9974:	02 38       	jl	$+6      	;abs 0x997a

00009976 <.Loc.1688.1>:
    9976:	2b 52       	add	#4,	r11	;r2 As==10

00009978 <.LVL202>:
    9978:	10 3c       	jmp	$+34     	;abs 0x999a

0000997a <.L121>:
    997a:	0e 41       	mov	r1,	r14	;
    997c:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9980:	0d 4a       	mov	r10,	r13	;
    9982:	1c 41 02 00 	mov	2(r1),	r12	;
    9986:	81 4f 00 00 	mov	r15,	0(r1)	;
    998a:	b0 12 fa 91 	call	#-28166	;#0x91fa

0000998e <.LVL204>:
    998e:	2f 41       	mov	@r1,	r15	;
    9990:	0c 93       	cmp	#0,	r12	;r3 As==00
    9992:	87 21       	jnz	$+784    	;abs 0x9ca2

00009994 <.Loc.1688.1>:
    9994:	0b 41       	mov	r1,	r11	;
    9996:	3b 50 1a 00 	add	#26,	r11	;#0x001a

0000999a <.L122>:
    999a:	3f 50 f0 ff 	add	#-16,	r15	;#0xfff0

0000999e <.LVL206>:
    999e:	d5 3f       	jmp	$-84     	;abs 0x994a

000099a0 <.L238>:
    99a0:	8b 4f 02 00 	mov	r15,	2(r11)	;
    99a4:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

000099a8 <.LVL207>:
    99a8:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    99ac:	7f 40 07 00 	mov.b	#7,	r15	;

000099b0 <.LVL208>:
    99b0:	0f 9c       	cmp	r12,	r15	;
    99b2:	02 38       	jl	$+6      	;abs 0x99b8

000099b4 <.Loc.1688.1>:
    99b4:	2b 52       	add	#4,	r11	;r2 As==10

000099b6 <.LVL209>:
    99b6:	0d 3c       	jmp	$+28     	;abs 0x99d2

000099b8 <.L124>:
    99b8:	0e 41       	mov	r1,	r14	;
    99ba:	3e 50 14 00 	add	#20,	r14	;#0x0014
    99be:	0d 4a       	mov	r10,	r13	;
    99c0:	1c 41 02 00 	mov	2(r1),	r12	;
    99c4:	b0 12 fa 91 	call	#-28166	;#0x91fa

000099c8 <.LVL211>:
    99c8:	0c 93       	cmp	#0,	r12	;r3 As==00
    99ca:	6b 21       	jnz	$+728    	;abs 0x9ca2

000099cc <.Loc.1688.1>:
    99cc:	0b 41       	mov	r1,	r11	;
    99ce:	3b 50 1a 00 	add	#26,	r11	;#0x001a

000099d2 <.L119>:
    99d2:	c1 93 11 00 	cmp.b	#0,	17(r1)	;r3 As==00, 0x0011
    99d6:	21 24       	jz	$+68     	;abs 0x9a1a

000099d8 <.Loc.1692.1>:
    99d8:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    99dc:	0c 51       	add	r1,	r12	;
    99de:	8b 4c 00 00 	mov	r12,	0(r11)	;
    99e2:	9b 43 02 00 	mov	#1,	2(r11)	;r3 As==01
    99e6:	91 53 18 00 	inc	24(r1)		;

000099ea <.LVL213>:
    99ea:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    99ee:	1c 53       	inc	r12		;
    99f0:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    99f4:	7d 40 07 00 	mov.b	#7,	r13	;
    99f8:	0d 9c       	cmp	r12,	r13	;
    99fa:	02 38       	jl	$+6      	;abs 0x9a00
    99fc:	2b 52       	add	#4,	r11	;r2 As==10

000099fe <.LVL214>:
    99fe:	0d 3c       	jmp	$+28     	;abs 0x9a1a

00009a00 <.L126>:
    9a00:	0e 41       	mov	r1,	r14	;
    9a02:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9a06:	0d 4a       	mov	r10,	r13	;
    9a08:	1c 41 02 00 	mov	2(r1),	r12	;
    9a0c:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009a10 <.LVL216>:
    9a10:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a12:	47 21       	jnz	$+656    	;abs 0x9ca2

00009a14 <.Loc.1692.1>:
    9a14:	0b 41       	mov	r1,	r11	;
    9a16:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009a1a <.L125>:
    9a1a:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    9a1e:	21 24       	jz	$+68     	;abs 0x9a62

00009a20 <.Loc.1694.1>:
    9a20:	7e 40 12 00 	mov.b	#18,	r14	;#0x0012
    9a24:	0e 51       	add	r1,	r14	;
    9a26:	8b 4e 00 00 	mov	r14,	0(r11)	;
    9a2a:	ab 43 02 00 	mov	#2,	2(r11)	;r3 As==10
    9a2e:	a1 53 18 00 	incd	24(r1)		;

00009a32 <.LVL218>:
    9a32:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9a36:	1c 53       	inc	r12		;
    9a38:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9a3c:	7f 40 07 00 	mov.b	#7,	r15	;
    9a40:	0f 9c       	cmp	r12,	r15	;
    9a42:	02 38       	jl	$+6      	;abs 0x9a48
    9a44:	2b 52       	add	#4,	r11	;r2 As==10

00009a46 <.LVL219>:
    9a46:	0d 3c       	jmp	$+28     	;abs 0x9a62

00009a48 <.L128>:
    9a48:	0e 41       	mov	r1,	r14	;
    9a4a:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9a4e:	0d 4a       	mov	r10,	r13	;
    9a50:	1c 41 02 00 	mov	2(r1),	r12	;
    9a54:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009a58 <.LVL221>:
    9a58:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a5a:	23 21       	jnz	$+584    	;abs 0x9ca2

00009a5c <.Loc.1694.1>:
    9a5c:	0b 41       	mov	r1,	r11	;
    9a5e:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009a62 <.L127>:
    9a62:	b1 90 80 00 	cmp	#128,	14(r1)	;#0x0080, 0x000e
    9a66:	0e 00 
    9a68:	4a 20       	jnz	$+150    	;abs 0x9afe

00009a6a <.Loc.1698.1>:
    9a6a:	1f 41 06 00 	mov	6(r1),	r15	;
    9a6e:	0f 88       	sub	r8,	r15	;

00009a70 <.LVL223>:
    9a70:	4c 43       	clr.b	r12		;
    9a72:	0c 9f       	cmp	r15,	r12	;
    9a74:	44 34       	jge	$+138    	;abs 0x9afe

00009a76 <.L130>:
    9a76:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9a7a:	1c 53       	inc	r12		;

00009a7c <.Loc.1698.1>:
    9a7c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9a80:	bb 40 4e 51 	mov	#20814,	0(r11)	;#0x514e
    9a84:	00 00 
    9a86:	0e 9f       	cmp	r15,	r14	;
    9a88:	21 34       	jge	$+68     	;abs 0x9acc

00009a8a <.Loc.1698.1>:
    9a8a:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    9a8e:	02 00 
    9a90:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9a94:	18 00 

00009a96 <.LVL224>:
    9a96:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9a9a:	7d 40 07 00 	mov.b	#7,	r13	;
    9a9e:	0d 9c       	cmp	r12,	r13	;
    9aa0:	02 38       	jl	$+6      	;abs 0x9aa6

00009aa2 <.Loc.1698.1>:
    9aa2:	2b 52       	add	#4,	r11	;r2 As==10

00009aa4 <.LVL225>:
    9aa4:	10 3c       	jmp	$+34     	;abs 0x9ac6

00009aa6 <.L131>:
    9aa6:	0e 41       	mov	r1,	r14	;
    9aa8:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9aac:	0d 4a       	mov	r10,	r13	;
    9aae:	1c 41 02 00 	mov	2(r1),	r12	;
    9ab2:	81 4f 00 00 	mov	r15,	0(r1)	;
    9ab6:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009aba <.LVL227>:
    9aba:	2f 41       	mov	@r1,	r15	;
    9abc:	0c 93       	cmp	#0,	r12	;r3 As==00
    9abe:	f1 20       	jnz	$+484    	;abs 0x9ca2

00009ac0 <.Loc.1698.1>:
    9ac0:	0b 41       	mov	r1,	r11	;
    9ac2:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009ac6 <.L132>:
    9ac6:	3f 50 f0 ff 	add	#-16,	r15	;#0xfff0

00009aca <.LVL229>:
    9aca:	d5 3f       	jmp	$-84     	;abs 0x9a76

00009acc <.L239>:
    9acc:	8b 4f 02 00 	mov	r15,	2(r11)	;
    9ad0:	81 5f 18 00 	add	r15,	24(r1)	; 0x0018

00009ad4 <.LVL230>:
    9ad4:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9ad8:	7f 40 07 00 	mov.b	#7,	r15	;

00009adc <.LVL231>:
    9adc:	0f 9c       	cmp	r12,	r15	;
    9ade:	02 38       	jl	$+6      	;abs 0x9ae4

00009ae0 <.Loc.1698.1>:
    9ae0:	2b 52       	add	#4,	r11	;r2 As==10

00009ae2 <.LVL232>:
    9ae2:	0d 3c       	jmp	$+28     	;abs 0x9afe

00009ae4 <.L134>:
    9ae4:	0e 41       	mov	r1,	r14	;
    9ae6:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9aea:	0d 4a       	mov	r10,	r13	;
    9aec:	1c 41 02 00 	mov	2(r1),	r12	;
    9af0:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009af4 <.LVL234>:
    9af4:	0c 93       	cmp	#0,	r12	;r3 As==00
    9af6:	d5 20       	jnz	$+428    	;abs 0x9ca2

00009af8 <.Loc.1698.1>:
    9af8:	0b 41       	mov	r1,	r11	;
    9afa:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009afe <.L129>:
    9afe:	09 86       	sub	r6,	r9	;

00009b00 <.LVL236>:
    9b00:	4c 43       	clr.b	r12		;
    9b02:	0c 99       	cmp	r9,	r12	;
    9b04:	41 34       	jge	$+132    	;abs 0x9b88

00009b06 <.L136>:
    9b06:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9b0a:	1c 53       	inc	r12		;

00009b0c <.Loc.1701.1>:
    9b0c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9b10:	bb 40 4e 51 	mov	#20814,	0(r11)	;#0x514e
    9b14:	00 00 
    9b16:	0e 99       	cmp	r9,	r14	;
    9b18:	1e 34       	jge	$+62     	;abs 0x9b56

00009b1a <.Loc.1701.1>:
    9b1a:	bb 40 10 00 	mov	#16,	2(r11)	;#0x0010
    9b1e:	02 00 
    9b20:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9b24:	18 00 

00009b26 <.LVL237>:
    9b26:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9b2a:	7d 40 07 00 	mov.b	#7,	r13	;
    9b2e:	0d 9c       	cmp	r12,	r13	;
    9b30:	02 38       	jl	$+6      	;abs 0x9b36

00009b32 <.Loc.1701.1>:
    9b32:	2b 52       	add	#4,	r11	;r2 As==10

00009b34 <.LVL238>:
    9b34:	0d 3c       	jmp	$+28     	;abs 0x9b50

00009b36 <.L137>:
    9b36:	0e 41       	mov	r1,	r14	;
    9b38:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9b3c:	0d 4a       	mov	r10,	r13	;
    9b3e:	1c 41 02 00 	mov	2(r1),	r12	;
    9b42:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009b46 <.LVL240>:
    9b46:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b48:	ac 20       	jnz	$+346    	;abs 0x9ca2

00009b4a <.Loc.1701.1>:
    9b4a:	0b 41       	mov	r1,	r11	;
    9b4c:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009b50 <.L138>:
    9b50:	39 50 f0 ff 	add	#-16,	r9	;#0xfff0
    9b54:	d8 3f       	jmp	$-78     	;abs 0x9b06

00009b56 <.L240>:
    9b56:	8b 49 02 00 	mov	r9,	2(r11)	;
    9b5a:	81 59 18 00 	add	r9,	24(r1)	; 0x0018

00009b5e <.LVL243>:
    9b5e:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9b62:	7f 40 07 00 	mov.b	#7,	r15	;
    9b66:	0f 9c       	cmp	r12,	r15	;
    9b68:	02 38       	jl	$+6      	;abs 0x9b6e

00009b6a <.Loc.1701.1>:
    9b6a:	2b 52       	add	#4,	r11	;r2 As==10

00009b6c <.LVL244>:
    9b6c:	0d 3c       	jmp	$+28     	;abs 0x9b88

00009b6e <.L140>:
    9b6e:	0e 41       	mov	r1,	r14	;
    9b70:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9b74:	0d 4a       	mov	r10,	r13	;
    9b76:	1c 41 02 00 	mov	2(r1),	r12	;
    9b7a:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009b7e <.LVL246>:
    9b7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b80:	90 20       	jnz	$+290    	;abs 0x9ca2

00009b82 <.Loc.1701.1>:
    9b82:	0b 41       	mov	r1,	r11	;
    9b84:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009b88 <.L135>:
    9b88:	8b 44 00 00 	mov	r4,	0(r11)	;
    9b8c:	8b 46 02 00 	mov	r6,	2(r11)	;
    9b90:	81 56 18 00 	add	r6,	24(r1)	; 0x0018

00009b94 <.LVL248>:
    9b94:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9b98:	1c 53       	inc	r12		;
    9b9a:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9b9e:	74 40 07 00 	mov.b	#7,	r4	;

00009ba2 <.LVL249>:
    9ba2:	04 9c       	cmp	r12,	r4	;
    9ba4:	02 38       	jl	$+6      	;abs 0x9baa
    9ba6:	2b 52       	add	#4,	r11	;r2 As==10

00009ba8 <.LVL250>:
    9ba8:	0d 3c       	jmp	$+28     	;abs 0x9bc4

00009baa <.L141>:
    9baa:	0e 41       	mov	r1,	r14	;
    9bac:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9bb0:	0d 4a       	mov	r10,	r13	;
    9bb2:	1c 41 02 00 	mov	2(r1),	r12	;
    9bb6:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009bba <.LVL252>:
    9bba:	0c 93       	cmp	#0,	r12	;r3 As==00
    9bbc:	72 20       	jnz	$+230    	;abs 0x9ca2

00009bbe <.Loc.1767.1>:
    9bbe:	0b 41       	mov	r1,	r11	;
    9bc0:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009bc4 <.L142>:
    9bc4:	25 b2       	bit	#4,	r5	;r2 As==10
    9bc6:	0b 20       	jnz	$+24     	;abs 0x9bde

00009bc8 <.L147>:
    9bc8:	1f 41 06 00 	mov	6(r1),	r15	;
    9bcc:	0f 98       	cmp	r8,	r15	;
    9bce:	01 34       	jge	$+4      	;abs 0x9bd2
    9bd0:	0f 48       	mov	r8,	r15	;

00009bd2 <.L144>:
    9bd2:	81 5f 08 00 	add	r15,	8(r1)	;

00009bd6 <.Loc.1776.1>:
    9bd6:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    9bda:	50 24       	jz	$+162    	;abs 0x9c7c
    9bdc:	45 3c       	jmp	$+140    	;abs 0x9c68

00009bde <.L143>:
    9bde:	16 41 06 00 	mov	6(r1),	r6	;

00009be2 <.LVL256>:
    9be2:	06 88       	sub	r8,	r6	;

00009be4 <.LVL257>:
    9be4:	4c 43       	clr.b	r12		;
    9be6:	0c 96       	cmp	r6,	r12	;
    9be8:	ef 37       	jge	$-32     	;abs 0x9bc8

00009bea <.Loc.1771.1>:
    9bea:	79 40 10 00 	mov.b	#16,	r9	;#0x0010
    9bee:	35 40 fa 91 	mov	#-28166,r5	;#0x91fa

00009bf2 <.L148>:
    9bf2:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    9bf6:	1c 53       	inc	r12		;
    9bf8:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    9bfc:	bb 40 5e 51 	mov	#20830,	0(r11)	;#0x515e
    9c00:	00 00 
    9c02:	0e 96       	cmp	r6,	r14	;
    9c04:	1c 34       	jge	$+58     	;abs 0x9c3e

00009c06 <.Loc.1771.1>:
    9c06:	8b 49 02 00 	mov	r9,	2(r11)	;
    9c0a:	b1 50 10 00 	add	#16,	24(r1)	;#0x0010, 0x0018
    9c0e:	18 00 
    9c10:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9c14:	7d 40 07 00 	mov.b	#7,	r13	;
    9c18:	0d 9c       	cmp	r12,	r13	;
    9c1a:	02 38       	jl	$+6      	;abs 0x9c20

00009c1c <.LVL259>:
    9c1c:	2b 52       	add	#4,	r11	;r2 As==10

00009c1e <.LVL260>:
    9c1e:	0c 3c       	jmp	$+26     	;abs 0x9c38

00009c20 <.L149>:
    9c20:	0e 41       	mov	r1,	r14	;
    9c22:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9c26:	0d 4a       	mov	r10,	r13	;
    9c28:	1c 41 02 00 	mov	2(r1),	r12	;
    9c2c:	85 12       	call	r5		;

00009c2e <.LVL262>:
    9c2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9c30:	38 20       	jnz	$+114    	;abs 0x9ca2

00009c32 <.LVL263>:
    9c32:	0b 41       	mov	r1,	r11	;
    9c34:	3b 50 1a 00 	add	#26,	r11	;#0x001a

00009c38 <.L150>:
    9c38:	36 50 f0 ff 	add	#-16,	r6	;#0xfff0
    9c3c:	da 3f       	jmp	$-74     	;abs 0x9bf2

00009c3e <.L242>:
    9c3e:	8b 46 02 00 	mov	r6,	2(r11)	;
    9c42:	81 56 18 00 	add	r6,	24(r1)	; 0x0018
    9c46:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    9c4a:	7f 40 07 00 	mov.b	#7,	r15	;
    9c4e:	0f 9c       	cmp	r12,	r15	;
    9c50:	bb 37       	jge	$-136    	;abs 0x9bc8

00009c52 <.Loc.1771.1>:
    9c52:	0e 41       	mov	r1,	r14	;
    9c54:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9c58:	0d 4a       	mov	r10,	r13	;
    9c5a:	1c 41 02 00 	mov	2(r1),	r12	;
    9c5e:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009c62 <.LVL266>:
    9c62:	0c 93       	cmp	#0,	r12	;r3 As==00
    9c64:	b1 27       	jz	$-156    	;abs 0x9bc8
    9c66:	1d 3c       	jmp	$+60     	;abs 0x9ca2

00009c68 <.L241>:
    9c68:	0e 41       	mov	r1,	r14	;
    9c6a:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9c6e:	0d 4a       	mov	r10,	r13	;
    9c70:	1c 41 02 00 	mov	2(r1),	r12	;
    9c74:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009c78 <.LVL268>:
    9c78:	0c 93       	cmp	#0,	r12	;r3 As==00
    9c7a:	13 20       	jnz	$+40     	;abs 0x9ca2

00009c7c <.L146>:
    9c7c:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016

00009c80 <.LVL269>:
    9c80:	09 47       	mov	r7,	r9	;
    9c82:	0b 41       	mov	r1,	r11	;
    9c84:	3b 50 1a 00 	add	#26,	r11	;#0x001a
    9c88:	30 40 8a 93 	br	#0x938a		;

00009c8c <.L34>:
    9c8c:	81 93 18 00 	cmp	#0,	24(r1)	;r3 As==00, 0x0018
    9c90:	08 24       	jz	$+18     	;abs 0x9ca2

00009c92 <.Loc.1784.1>:
    9c92:	0e 41       	mov	r1,	r14	;
    9c94:	3e 50 14 00 	add	#20,	r14	;#0x0014
    9c98:	0d 4a       	mov	r10,	r13	;
    9c9a:	1c 41 02 00 	mov	2(r1),	r12	;
    9c9e:	b0 12 fa 91 	call	#-28166	;#0x91fa

00009ca2 <.L33>:
    9ca2:	fa b0 40 00 	bit.b	#64,	6(r10)	;#0x0040
    9ca6:	06 00 
    9ca8:	02 24       	jz	$+6      	;abs 0x9cae
    9caa:	b1 43 08 00 	mov	#-1,	8(r1)	;r3 As==11

00009cae <.L22>:
    9cae:	1c 41 08 00 	mov	8(r1),	r12	;
    9cb2:	31 50 62 00 	add	#98,	r1	;#0x0062

00009cb6 <L0>:
    9cb6:	64 17       	popm	#7,	r10	;16-bit words
    9cb8:	30 41       	ret			

00009cba <memchr>:
    9cba:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00009cbe <.LVL2>:
    9cbe:	0e 5c       	add	r12,	r14	;

00009cc0 <.L2>:
    9cc0:	0c 9e       	cmp	r14,	r12	;
    9cc2:	05 24       	jz	$+12     	;abs 0x9cce

00009cc4 <.Loc.128.1>:
    9cc4:	cc 9d 00 00 	cmp.b	r13,	0(r12)	;
    9cc8:	03 24       	jz	$+8      	;abs 0x9cd0

00009cca <.Loc.130.1>:
    9cca:	1c 53       	inc	r12		;

00009ccc <.LVL4>:
    9ccc:	f9 3f       	jmp	$-12     	;abs 0x9cc0

00009cce <.L7>:
    9cce:	4c 43       	clr.b	r12		;

00009cd0 <.L1>:
    9cd0:	30 41       	ret			

00009cd2 <memmove>:
    9cd2:	0b 4c       	mov	r12,	r11	;

00009cd4 <L0>:
    9cd4:	0b 5e       	add	r14,	r11	;

00009cd6 <.Loc.69.1>:
    9cd6:	0d 9c       	cmp	r12,	r13	;
    9cd8:	02 28       	jnc	$+6      	;abs 0x9cde

00009cda <.L4>:
    9cda:	0e 4c       	mov	r12,	r14	;

00009cdc <.LVL2>:
    9cdc:	0f 3c       	jmp	$+32     	;abs 0x9cfc

00009cde <.L2>:
    9cde:	0f 4d       	mov	r13,	r15	;
    9ce0:	0f 5e       	add	r14,	r15	;
    9ce2:	0c 9f       	cmp	r15,	r12	;
    9ce4:	fa 2f       	jc	$-10     	;abs 0x9cda

00009ce6 <.LVL4>:
    9ce6:	0d 4f       	mov	r15,	r13	;

00009ce8 <.LVL5>:
    9ce8:	0e 8f       	sub	r15,	r14	;

00009cea <.L5>:
    9cea:	0f 4d       	mov	r13,	r15	;
    9cec:	0f 5e       	add	r14,	r15	;
    9cee:	0f 93       	cmp	#0,	r15	;r3 As==00
    9cf0:	0c 24       	jz	$+26     	;abs 0x9d0a

00009cf2 <.Loc.76.1>:
    9cf2:	3b 53       	add	#-1,	r11	;r3 As==11
    9cf4:	3d 53       	add	#-1,	r13	;r3 As==11

00009cf6 <.LVL8>:
    9cf6:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    9cfa:	f7 3f       	jmp	$-16     	;abs 0x9cea

00009cfc <.L3>:
    9cfc:	0b 9e       	cmp	r14,	r11	;
    9cfe:	05 24       	jz	$+12     	;abs 0x9d0a

00009d00 <.LVL10>:
    9d00:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    9d04:	1e 53       	inc	r14		;

00009d06 <.LVL11>:
    9d06:	1d 53       	inc	r13		;
    9d08:	f9 3f       	jmp	$-12     	;abs 0x9cfc

00009d0a <.L9>:
    9d0a:	30 41       	ret			

00009d0c <_free_r>:
    9d0c:	6a 15       	pushm	#7,	r10	;16-bit words

00009d0e <.LCFI0>:
    9d0e:	09 4c       	mov	r12,	r9	;

00009d10 <.Loc.342.1>:
    9d10:	0d 93       	cmp	#0,	r13	;r3 As==00

00009d12 <L0>:
    9d12:	7c 24       	jz	$+250    	;abs 0x9e0c

00009d14 <.LBB7>:
    9d14:	0a 4d       	mov	r13,	r10	;
    9d16:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc

00009d1a <.LVL2>:
    9d1a:	1c 4d fc ff 	mov	-4(r13),r12	;

00009d1e <.LVL3>:
    9d1e:	8d 93 fe ff 	cmp	#0,	-2(r13)	;r3 As==00, 0xfffe
    9d22:	01 34       	jge	$+4      	;abs 0x9d26
    9d24:	0a 5c       	add	r12,	r10	;

00009d26 <.L3>:
    9d26:	0c 49       	mov	r9,	r12	;
    9d28:	b0 12 82 9f 	call	#-24702	;#0x9f82

00009d2c <.LVL5>:
    9d2c:	1c 42 0c 5d 	mov	&0x5d0c,r12	;0x5d0c
    9d30:	0c 93       	cmp	#0,	r12	;r3 As==00
    9d32:	16 24       	jz	$+46     	;abs 0x9d60

00009d34 <.Loc.356.1>:
    9d34:	0a 9c       	cmp	r12,	r10	;
    9d36:	1f 2c       	jc	$+64     	;abs 0x9d76

00009d38 <.LBB9>:
    9d38:	2e 4a       	mov	@r10,	r14	;
    9d3a:	1f 4a 02 00 	mov	2(r10),	r15	;
    9d3e:	0d 4a       	mov	r10,	r13	;
    9d40:	0d 5e       	add	r14,	r13	;
    9d42:	0c 9d       	cmp	r13,	r12	;
    9d44:	0d 20       	jnz	$+28     	;abs 0x9d60

00009d46 <.Loc.362.1>:
    9d46:	04 4e       	mov	r14,	r4	;
    9d48:	05 4f       	mov	r15,	r5	;
    9d4a:	24 5c       	add	@r12,	r4	;
    9d4c:	15 6c 02 00 	addc	2(r12),	r5	;
    9d50:	8a 44 00 00 	mov	r4,	0(r10)	;
    9d54:	8a 45 02 00 	mov	r5,	2(r10)	;

00009d58 <.Loc.363.1>:
    9d58:	9a 4c 04 00 	mov	4(r12),	4(r10)	;
    9d5c:	04 00 
    9d5e:	02 3c       	jmp	$+6      	;abs 0x9d64

00009d60 <.L7>:
    9d60:	8a 4c 04 00 	mov	r12,	4(r10)	;

00009d64 <.L8>:
    9d64:	82 4a 0c 5d 	mov	r10,	&0x5d0c	;

00009d68 <.Loc.371.1>:
    9d68:	0c 49       	mov	r9,	r12	;
    9d6a:	b0 12 84 9f 	call	#-24700	;#0x9f84

00009d6e <.LVL6>:
    9d6e:	4e 3c       	jmp	$+158    	;abs 0x9e0c

00009d70 <.L23>:
    9d70:	0a 9d       	cmp	r13,	r10	;
    9d72:	05 28       	jnc	$+12     	;abs 0x9d7e
    9d74:	0c 4d       	mov	r13,	r12	;

00009d76 <.L10>:
    9d76:	1d 4c 04 00 	mov	4(r12),	r13	;

00009d7a <.LVL9>:
    9d7a:	0d 93       	cmp	#0,	r13	;r3 As==00
    9d7c:	f9 23       	jnz	$-12     	;abs 0x9d70

00009d7e <.L9>:
    9d7e:	2e 4c       	mov	@r12,	r14	;
    9d80:	18 4c 02 00 	mov	2(r12),	r8	;
    9d84:	0b 4c       	mov	r12,	r11	;
    9d86:	0b 5e       	add	r14,	r11	;
    9d88:	3f 40 84 9f 	mov	#-24700,r15	;#0x9f84
    9d8c:	0b 9a       	cmp	r10,	r11	;
    9d8e:	1a 20       	jnz	$+54     	;abs 0x9dc4

00009d90 <.Loc.390.1>:
    9d90:	26 4a       	mov	@r10,	r6	;
    9d92:	06 5e       	add	r14,	r6	;
    9d94:	17 4a 02 00 	mov	2(r10),	r7	;
    9d98:	07 68       	addc	r8,	r7	;
    9d9a:	8c 46 00 00 	mov	r6,	0(r12)	;
    9d9e:	8c 47 02 00 	mov	r7,	2(r12)	;

00009da2 <.Loc.393.1>:
    9da2:	0e 4c       	mov	r12,	r14	;
    9da4:	0e 56       	add	r6,	r14	;
    9da6:	0d 9e       	cmp	r14,	r13	;
    9da8:	2f 20       	jnz	$+96     	;abs 0x9e08

00009daa <.Loc.395.1>:
    9daa:	0a 46       	mov	r6,	r10	;
    9dac:	0b 47       	mov	r7,	r11	;
    9dae:	2a 5d       	add	@r13,	r10	;
    9db0:	1b 6d 02 00 	addc	2(r13),	r11	;
    9db4:	8c 4a 00 00 	mov	r10,	0(r12)	;
    9db8:	8c 4b 02 00 	mov	r11,	2(r12)	;

00009dbc <.Loc.396.1>:
    9dbc:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9dc0:	04 00 
    9dc2:	22 3c       	jmp	$+70     	;abs 0x9e08

00009dc4 <.L11>:
    9dc4:	0a 9b       	cmp	r11,	r10	;
    9dc6:	06 2c       	jc	$+14     	;abs 0x9dd4

00009dc8 <.LBB10>:
    9dc8:	b9 40 0c 00 	mov	#12,	0(r9)	;#0x000c
    9dcc:	00 00 

00009dce <.Loc.404.1>:
    9dce:	0c 49       	mov	r9,	r12	;

00009dd0 <.LVL10>:
    9dd0:	8f 12       	call	r15		;

00009dd2 <.LVL11>:
    9dd2:	1c 3c       	jmp	$+58     	;abs 0x9e0c

00009dd4 <.L13>:
    9dd4:	26 4a       	mov	@r10,	r6	;
    9dd6:	17 4a 02 00 	mov	2(r10),	r7	;
    9dda:	0e 4a       	mov	r10,	r14	;
    9ddc:	0e 56       	add	r6,	r14	;
    9dde:	0d 9e       	cmp	r14,	r13	;
    9de0:	0f 20       	jnz	$+32     	;abs 0x9e00

00009de2 <.Loc.412.1>:
    9de2:	04 46       	mov	r6,	r4	;
    9de4:	05 47       	mov	r7,	r5	;
    9de6:	24 5d       	add	@r13,	r4	;
    9de8:	15 6d 02 00 	addc	2(r13),	r5	;
    9dec:	8a 44 00 00 	mov	r4,	0(r10)	;
    9df0:	8a 45 02 00 	mov	r5,	2(r10)	;

00009df4 <.Loc.413.1>:
    9df4:	9a 4d 04 00 	mov	4(r13),	4(r10)	;
    9df8:	04 00 

00009dfa <.Loc.414.1>:
    9dfa:	8c 4a 04 00 	mov	r10,	4(r12)	;
    9dfe:	04 3c       	jmp	$+10     	;abs 0x9e08

00009e00 <.L14>:
    9e00:	8a 4d 04 00 	mov	r13,	4(r10)	;

00009e04 <.Loc.421.1>:
    9e04:	8c 4a 04 00 	mov	r10,	4(r12)	;

00009e08 <.L12>:
    9e08:	0c 49       	mov	r9,	r12	;

00009e0a <.LVL13>:
    9e0a:	8f 12       	call	r15		;

00009e0c <.L1>:
    9e0c:	64 17       	popm	#7,	r10	;16-bit words
    9e0e:	30 41       	ret			

00009e10 <_malloc_r>:
    9e10:	3a 15       	pushm	#4,	r10	;16-bit words

00009e12 <.LCFI0>:
    9e12:	08 4c       	mov	r12,	r8	;

00009e14 <.Loc.246.1>:
    9e14:	09 4d       	mov	r13,	r9	;
    9e16:	19 53       	inc	r9		;
    9e18:	19 c3       	bic	#1,	r9	;r3 As==01

00009e1a <L0>:
    9e1a:	39 50 0a 00 	add	#10,	r9	;#0x000a

00009e1e <.LVL2>:
    9e1e:	39 90 0c 00 	cmp	#12,	r9	;#0x000c
    9e22:	02 2c       	jc	$+6      	;abs 0x9e28
    9e24:	79 40 0c 00 	mov.b	#12,	r9	;#0x000c

00009e28 <.L2>:
    9e28:	09 9d       	cmp	r13,	r9	;
    9e2a:	05 2c       	jc	$+12     	;abs 0x9e36

00009e2c <.Loc.253.1>:
    9e2c:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    9e30:	00 00 

00009e32 <.Loc.254.1>:
    9e32:	4c 43       	clr.b	r12		;

00009e34 <.LVL4>:
    9e34:	6a 3c       	jmp	$+214    	;abs 0x9f0a

00009e36 <.L3>:
    9e36:	0c 48       	mov	r8,	r12	;
    9e38:	b0 12 82 9f 	call	#-24702	;#0x9f82

00009e3c <.LVL5>:
    9e3c:	1a 42 0c 5d 	mov	&0x5d0c,r10	;0x5d0c

00009e40 <.LVL6>:
    9e40:	0d 4a       	mov	r10,	r13	;

00009e42 <.L5>:
    9e42:	0d 93       	cmp	#0,	r13	;r3 As==00
    9e44:	28 24       	jz	$+82     	;abs 0x9e96

00009e46 <.LBB6>:
    9e46:	2c 4d       	mov	@r13,	r12	;
    9e48:	0c 89       	sub	r9,	r12	;

00009e4a <.LVL8>:
    9e4a:	0c 93       	cmp	#0,	r12	;r3 As==00
    9e4c:	20 38       	jl	$+66     	;abs 0x9e8e

00009e4e <.Loc.267.1>:
    9e4e:	7e 40 0b 00 	mov.b	#11,	r14	;#0x000b
    9e52:	0e 9c       	cmp	r12,	r14	;
    9e54:	11 2c       	jc	$+36     	;abs 0x9e78

00009e56 <.Loc.271.1>:
    9e56:	0e 4c       	mov	r12,	r14	;
    9e58:	0f 4c       	mov	r12,	r15	;
    9e5a:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    9e5e:	8d 4e 00 00 	mov	r14,	0(r13)	;
    9e62:	8d 4f 02 00 	mov	r15,	2(r13)	;

00009e66 <.Loc.272.1>:
    9e66:	0a 4d       	mov	r13,	r10	;

00009e68 <.LVL9>:
    9e68:	0a 5c       	add	r12,	r10	;

00009e6a <.LVL10>:
    9e6a:	0c 49       	mov	r9,	r12	;
    9e6c:	0d 43       	clr	r13		;

00009e6e <.LVL11>:
    9e6e:	8a 4c 00 00 	mov	r12,	0(r10)	;
    9e72:	8a 4d 02 00 	mov	r13,	2(r10)	;
    9e76:	28 3c       	jmp	$+82     	;abs 0x9ec8

00009e78 <.L7>:
    9e78:	0a 9d       	cmp	r13,	r10	;
    9e7a:	04 20       	jnz	$+10     	;abs 0x9e84

00009e7c <.Loc.281.1>:
    9e7c:	92 4a 04 00 	mov	4(r10),	&0x5d0c	;
    9e80:	0c 5d 
    9e82:	22 3c       	jmp	$+70     	;abs 0x9ec8

00009e84 <.L9>:
    9e84:	9a 4d 04 00 	mov	4(r13),	4(r10)	;
    9e88:	04 00 
    9e8a:	0a 4d       	mov	r13,	r10	;

00009e8c <.LVL13>:
    9e8c:	1d 3c       	jmp	$+60     	;abs 0x9ec8

00009e8e <.L6>:
    9e8e:	0a 4d       	mov	r13,	r10	;
    9e90:	1d 4d 04 00 	mov	4(r13),	r13	;

00009e94 <.LVL15>:
    9e94:	d6 3f       	jmp	$-82     	;abs 0x9e42

00009e96 <.L23>:
    9e96:	37 40 60 9f 	mov	#-24736,r7	;#0x9f60

00009e9a <.LBB7>:
    9e9a:	82 93 0a 5d 	cmp	#0,	&0x5d0a	;r3 As==00
    9e9e:	04 20       	jnz	$+10     	;abs 0x9ea8
    9ea0:	0c 48       	mov	r8,	r12	;
    9ea2:	87 12       	call	r7		;

00009ea4 <.LVL17>:
    9ea4:	82 4c 0a 5d 	mov	r12,	&0x5d0a	;

00009ea8 <.L16>:
    9ea8:	0d 49       	mov	r9,	r13	;
    9eaa:	0c 48       	mov	r8,	r12	;
    9eac:	87 12       	call	r7		;

00009eae <.LVL18>:
    9eae:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9eb0:	25 24       	jz	$+76     	;abs 0x9efc

00009eb2 <.Loc.221.1>:
    9eb2:	0a 4c       	mov	r12,	r10	;

00009eb4 <.LVL19>:
    9eb4:	1a 53       	inc	r10		;
    9eb6:	1a c3       	bic	#1,	r10	;r3 As==01

00009eb8 <.LVL20>:
    9eb8:	0c 9a       	cmp	r10,	r12	;
    9eba:	1a 20       	jnz	$+54     	;abs 0x9ef0

00009ebc <.L13>:
    9ebc:	0d 49       	mov	r9,	r13	;
    9ebe:	0e 43       	clr	r14		;
    9ec0:	8a 4d 00 00 	mov	r13,	0(r10)	;
    9ec4:	8a 4e 02 00 	mov	r14,	2(r10)	;

00009ec8 <.L8>:
    9ec8:	0c 48       	mov	r8,	r12	;
    9eca:	b0 12 84 9f 	call	#-24700	;#0x9f84

00009ece <.LVL23>:
    9ece:	0e 4a       	mov	r10,	r14	;
    9ed0:	2e 52       	add	#4,	r14	;r2 As==10

00009ed2 <.LVL24>:
    9ed2:	0c 4e       	mov	r14,	r12	;
    9ed4:	3c 50 07 00 	add	#7,	r12	;
    9ed8:	3c f0 f8 ff 	and	#-8,	r12	;#0xfff8

00009edc <.LVL25>:
    9edc:	0d 4c       	mov	r12,	r13	;
    9ede:	0d 8e       	sub	r14,	r13	;

00009ee0 <.LVL26>:
    9ee0:	0d 93       	cmp	#0,	r13	;r3 As==00
    9ee2:	13 24       	jz	$+40     	;abs 0x9f0a

00009ee4 <.Loc.317.1>:
    9ee4:	0a 5d       	add	r13,	r10	;

00009ee6 <.LVL27>:
    9ee6:	4e 43       	clr.b	r14		;

00009ee8 <.LVL28>:
    9ee8:	0e 8d       	sub	r13,	r14	;
    9eea:	8a 4e 00 00 	mov	r14,	0(r10)	;
    9eee:	0d 3c       	jmp	$+28     	;abs 0x9f0a

00009ef0 <.L24>:
    9ef0:	0d 4a       	mov	r10,	r13	;
    9ef2:	0d 8c       	sub	r12,	r13	;
    9ef4:	0c 48       	mov	r8,	r12	;

00009ef6 <.LVL30>:
    9ef6:	87 12       	call	r7		;

00009ef8 <.LVL31>:
    9ef8:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9efa:	e0 23       	jnz	$-62     	;abs 0x9ebc

00009efc <.L14>:
    9efc:	b8 40 0c 00 	mov	#12,	0(r8)	;#0x000c
    9f00:	00 00 

00009f02 <.Loc.303.1>:
    9f02:	0c 48       	mov	r8,	r12	;
    9f04:	b0 12 84 9f 	call	#-24700	;#0x9f84

00009f08 <.LVL33>:
    9f08:	4c 43       	clr.b	r12		;

00009f0a <.L1>:
    9f0a:	37 17       	popm	#4,	r10	;16-bit words
    9f0c:	30 41       	ret			

00009f0e <_realloc_r>:
    9f0e:	3a 15       	pushm	#4,	r10	;16-bit words

00009f10 <.LCFI0>:
    9f10:	07 4c       	mov	r12,	r7	;
    9f12:	08 4d       	mov	r13,	r8	;
    9f14:	0a 4e       	mov	r14,	r10	;

00009f16 <.Loc.453.1>:
    9f16:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f18:	05 20       	jnz	$+12     	;abs 0x9f24

00009f1a <L0>:
    9f1a:	0d 4e       	mov	r14,	r13	;

00009f1c <.LVL1>:
    9f1c:	b0 12 10 9e 	call	#-25072	;#0x9e10

00009f20 <.LVL2>:
    9f20:	09 4c       	mov	r12,	r9	;
    9f22:	1b 3c       	jmp	$+56     	;abs 0x9f5a

00009f24 <.L2>:
    9f24:	0e 93       	cmp	#0,	r14	;r3 As==00
    9f26:	04 20       	jnz	$+10     	;abs 0x9f30

00009f28 <.Loc.457.1>:
    9f28:	b0 12 0c 9d 	call	#-25332	;#0x9d0c

00009f2c <.LVL3>:
    9f2c:	09 4a       	mov	r10,	r9	;
    9f2e:	15 3c       	jmp	$+44     	;abs 0x9f5a

00009f30 <.L4>:
    9f30:	b0 12 86 9f 	call	#-24698	;#0x9f86

00009f34 <.LVL4>:
    9f34:	0c 9a       	cmp	r10,	r12	;
    9f36:	10 2c       	jc	$+34     	;abs 0x9f58

00009f38 <.Loc.466.1>:
    9f38:	0d 4a       	mov	r10,	r13	;
    9f3a:	0c 47       	mov	r7,	r12	;
    9f3c:	b0 12 10 9e 	call	#-25072	;#0x9e10

00009f40 <.LVL5>:
    9f40:	09 4c       	mov	r12,	r9	;

00009f42 <.LVL6>:
    9f42:	0c 93       	cmp	#0,	r12	;r3 As==00
    9f44:	0a 24       	jz	$+22     	;abs 0x9f5a

00009f46 <.Loc.469.1>:
    9f46:	0e 4a       	mov	r10,	r14	;
    9f48:	0d 48       	mov	r8,	r13	;
    9f4a:	b0 12 6a 91 	call	#-28310	;#0x916a

00009f4e <.LVL7>:
    9f4e:	0d 48       	mov	r8,	r13	;
    9f50:	0c 47       	mov	r7,	r12	;
    9f52:	b0 12 0c 9d 	call	#-25332	;#0x9d0c

00009f56 <.LVL8>:
    9f56:	01 3c       	jmp	$+4      	;abs 0x9f5a

00009f58 <.L5>:
    9f58:	09 48       	mov	r8,	r9	;

00009f5a <.L1>:
    9f5a:	0c 49       	mov	r9,	r12	;
    9f5c:	37 17       	popm	#4,	r10	;16-bit words
    9f5e:	30 41       	ret			

00009f60 <_sbrk_r>:
    9f60:	0a 15       	pushm	#1,	r10	;16-bit words

00009f62 <.LCFI0>:
    9f62:	0a 4c       	mov	r12,	r10	;

00009f64 <.Loc.57.1>:
    9f64:	82 43       	mov	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00009f66 <L0>:
    9f66:	0e 5d       	add	r13,	r14	;

00009f68 <.Loc.58.1>:
    9f68:	0c 4d       	mov	r13,	r12	;

00009f6a <.LVL1>:
    9f6a:	b0 12 9a 9f 	call	#-24678	;#0x9f9a

00009f6e <.LVL2>:
    9f6e:	3c 93       	cmp	#-1,	r12	;r3 As==11
    9f70:	06 20       	jnz	$+14     	;abs 0x9f7e

00009f72 <.Loc.58.1>:
    9f72:	1d 42 0e 5d 	mov	&0x5d0e,r13	;0x5d0e
    9f76:	0d 93       	cmp	#0,	r13	;r3 As==00
    9f78:	02 24       	jz	$+6      	;abs 0x9f7e

00009f7a <.Loc.59.1>:
    9f7a:	8a 4d 00 00 	mov	r13,	0(r10)	;

00009f7e <.L2>:
    9f7e:	0a 17       	popm	#1,	r10	;16-bit words
    9f80:	30 41       	ret			

00009f82 <__malloc_lock>:
    9f82:	30 41       	ret			

00009f84 <__malloc_unlock>:
    9f84:	30 41       	ret			

00009f86 <_malloc_usable_size_r>:
    9f86:	1e 4d fc ff 	mov	-4(r13),r14	;
    9f8a:	0c 4e       	mov	r14,	r12	;

00009f8c <.LVL3>:
    9f8c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

00009f90 <.Loc.529.1>:
    9f90:	0e 93       	cmp	#0,	r14	;r3 As==00
    9f92:	02 34       	jge	$+6      	;abs 0x9f98

00009f94 <.LVL4>:
    9f94:	0d 5c       	add	r12,	r13	;

00009f96 <.LVL5>:
    9f96:	2c 5d       	add	@r13,	r12	;

00009f98 <.L1>:
    9f98:	30 41       	ret			

00009f9a <_sbrk>:
    9f9a:	21 83       	decd	r1		;

00009f9c <.LCFI0>:
    9f9c:	1d 42 8e 5c 	mov	&0x5c8e,r13	;0x5c8e

00009fa0 <.LVL1>:
    9fa0:	4e 43       	clr.b	r14		;
    9fa2:	0e 51       	add	r1,	r14	;
    9fa4:	81 4e 00 00 	mov	r14,	0(r1)	;

00009fa8 <.Loc.22.1>:
    9fa8:	0c 5d       	add	r13,	r12	;

00009faa <.LVL2>:
    9faa:	01 9c       	cmp	r12,	r1	;
    9fac:	05 28       	jnc	$+12     	;abs 0x9fb8

00009fae <.Loc.29.1>:
    9fae:	82 4c 8e 5c 	mov	r12,	&0x5c8e	;

00009fb2 <.Loc.31.1>:
    9fb2:	0c 4d       	mov	r13,	r12	;
    9fb4:	21 53       	incd	r1		;
    9fb6:	30 41       	ret			

00009fb8 <.L4>:
    9fb8:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    9fbc:	3d 40 6e 51 	mov	#20846,	r13	;#0x516e

00009fc0 <.LVL4>:
    9fc0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9fc2:	b0 12 ca 9f 	call	#-24630	;#0x9fca

00009fc6 <.LVL5>:
    9fc6:	b0 12 5c a0 	call	#-24484	;#0xa05c

00009fca <write>:
    9fca:	6a 15       	pushm	#7,	r10	;16-bit words

00009fcc <.LCFI0>:
    9fcc:	21 82       	sub	#4,	r1	;r2 As==10

00009fce <.LCFI1>:
    9fce:	07 4d       	mov	r13,	r7	;
    9fd0:	09 4e       	mov	r14,	r9	;

00009fd2 <.Loc.48.1>:
    9fd2:	4d 43       	clr.b	r13		;

00009fd4 <.LVL2>:
    9fd4:	0d 9e       	cmp	r14,	r13	;
    9fd6:	3e 34       	jge	$+126    	;abs 0xa054
    9fd8:	4d 4c       	mov.b	r12,	r13	;
    9fda:	81 4d 02 00 	mov	r13,	2(r1)	;
    9fde:	5c 0f       	rrum	#4,	r12	;
    9fe0:	5c 0f       	rrum	#4,	r12	;

00009fe2 <.LVL3>:
    9fe2:	81 4c 00 00 	mov	r12,	0(r1)	;
    9fe6:	34 40 90 5c 	mov	#23696,	r4	;#0x5c90
    9fea:	35 40 6a 91 	mov	#-28310,r5	;#0x916a
    9fee:	36 40 58 a0 	mov	#-24488,r6	;#0xa058

00009ff2 <.LBB5>:
    9ff2:	48 43       	clr.b	r8		;

00009ff4 <.Loc.28.1>:
    9ff4:	09 47       	mov	r7,	r9	;
    9ff6:	07 4e       	mov	r14,	r7	;

00009ff8 <.L4>:
    9ff8:	0a 47       	mov	r7,	r10	;
    9ffa:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    9ffe:	0c 97       	cmp	r7,	r12	;
    a000:	01 34       	jge	$+4      	;abs 0xa004
    a002:	0a 4c       	mov	r12,	r10	;

0000a004 <.L3>:
    a004:	4c 4a       	mov.b	r10,	r12	;
    a006:	c4 4c 00 00 	mov.b	r12,	0(r4)	;

0000a00a <.Loc.22.1>:
    a00a:	c2 48 91 5c 	mov.b	r8,	&0x5c91	;

0000a00e <.Loc.23.1>:
    a00e:	f2 40 f3 ff 	mov.b	#-13,	&0x5c92	;#0xfff3
    a012:	92 5c 

0000a014 <.Loc.24.1>:
    a014:	1d 41 02 00 	mov	2(r1),	r13	;
    a018:	c4 4d 03 00 	mov.b	r13,	3(r4)	;

0000a01c <.Loc.25.1>:
    a01c:	2d 41       	mov	@r1,	r13	;
    a01e:	c4 4d 04 00 	mov.b	r13,	4(r4)	;

0000a022 <.Loc.26.1>:
    a022:	c4 4c 05 00 	mov.b	r12,	5(r4)	;

0000a026 <.Loc.27.1>:
    a026:	c2 48 96 5c 	mov.b	r8,	&0x5c96	;

0000a02a <.Loc.28.1>:
    a02a:	0e 4a       	mov	r10,	r14	;
    a02c:	0d 49       	mov	r9,	r13	;
    a02e:	3c 40 9b 5c 	mov	#23707,	r12	;#0x5c9b
    a032:	85 12       	call	r5		;

0000a034 <.LVL6>:
    a034:	86 12       	call	r6		;

0000a036 <.LBE10>:
    a036:	07 8a       	sub	r10,	r7	;

0000a038 <.Loc.56.1>:
    a038:	09 5a       	add	r10,	r9	;

0000a03a <.LBE5>:
    a03a:	4c 43       	clr.b	r12		;
    a03c:	0c 97       	cmp	r7,	r12	;
    a03e:	dc 3b       	jl	$-70     	;abs 0x9ff8

0000a040 <.LBB11>:
    a040:	5c 44 03 00 	mov.b	3(r4),	r12	;
    a044:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a048:	54 44 02 00 	mov.b	2(r4),	r4	;
    a04c:	0c 54       	add	r4,	r12	;

0000a04e <.L1>:
    a04e:	21 52       	add	#4,	r1	;r2 As==10
    a050:	64 17       	popm	#7,	r10	;16-bit words
    a052:	30 41       	ret			

0000a054 <.L5>:
    a054:	4c 43       	clr.b	r12		;

0000a056 <.LVL12>:
    a056:	fb 3f       	jmp	$-8      	;abs 0xa04e

0000a058 <C$$IO$$>:
    a058:	03 43       	nop			

0000a05a <L0>:
    a05a:	30 41       	ret			

0000a05c <abort>:
    a05c:	7c 40 06 00 	mov.b	#6,	r12	;
    a060:	b0 12 dc a0 	call	#-24356	;#0xa0dc

0000a064 <.LVL0>:
    a064:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a066:	b0 12 12 a1 	call	#-24302	;#0xa112

0000a06a <memset>:
    a06a:	0f 4c       	mov	r12,	r15	;
    a06c:	0e 5c       	add	r12,	r14	;

0000a06e <.L2>:
    a06e:	0f 9e       	cmp	r14,	r15	;
    a070:	04 24       	jz	$+10     	;abs 0xa07a

0000a072 <.LVL3>:
    a072:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    a076:	1f 53       	inc	r15		;

0000a078 <.LVL4>:
    a078:	fa 3f       	jmp	$-10     	;abs 0xa06e

0000a07a <.L5>:
    a07a:	30 41       	ret			

0000a07c <_raise_r>:
    a07c:	1a 15       	pushm	#2,	r10	;16-bit words

0000a07e <L0>:
    a07e:	09 4c       	mov	r12,	r9	;
    a080:	0a 4d       	mov	r13,	r10	;

0000a082 <.Loc.151.1>:
    a082:	7c 40 1f 00 	mov.b	#31,	r12	;#0x001f

0000a086 <.LVL16>:
    a086:	0c 9d       	cmp	r13,	r12	;
    a088:	05 2c       	jc	$+12     	;abs 0xa094

0000a08a <.Loc.153.1>:
    a08a:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    a08e:	00 00 

0000a090 <.Loc.154.1>:
    a090:	3c 43       	mov	#-1,	r12	;r3 As==11
    a092:	22 3c       	jmp	$+70     	;abs 0xa0d8

0000a094 <.L18>:
    a094:	1c 49 22 00 	mov	34(r9),	r12	;0x00022
    a098:	0c 93       	cmp	#0,	r12	;r3 As==00
    a09a:	05 24       	jz	$+12     	;abs 0xa0a6

0000a09c <.Loc.160.1>:
    a09c:	0d 5d       	rla	r13		;

0000a09e <.LVL17>:
    a09e:	0c 5d       	add	r13,	r12	;
    a0a0:	2d 4c       	mov	@r12,	r13	;

0000a0a2 <.LVL18>:
    a0a2:	0d 93       	cmp	#0,	r13	;r3 As==00
    a0a4:	09 20       	jnz	$+20     	;abs 0xa0b8

0000a0a6 <.L20>:
    a0a6:	0c 49       	mov	r9,	r12	;
    a0a8:	b0 12 0c a1 	call	#-24308	;#0xa10c

0000a0ac <.LVL20>:
    a0ac:	0e 4a       	mov	r10,	r14	;
    a0ae:	0d 4c       	mov	r12,	r13	;
    a0b0:	0c 49       	mov	r9,	r12	;
    a0b2:	b0 12 e8 a0 	call	#-24344	;#0xa0e8

0000a0b6 <.LVL21>:
    a0b6:	10 3c       	jmp	$+34     	;abs 0xa0d8

0000a0b8 <.L21>:
    a0b8:	1d 93       	cmp	#1,	r13	;r3 As==01
    a0ba:	0d 24       	jz	$+28     	;abs 0xa0d6

0000a0bc <.Loc.166.1>:
    a0bc:	3d 93       	cmp	#-1,	r13	;r3 As==11
    a0be:	05 20       	jnz	$+12     	;abs 0xa0ca

0000a0c0 <.Loc.168.1>:
    a0c0:	b9 40 16 00 	mov	#22,	0(r9)	;#0x0016
    a0c4:	00 00 

0000a0c6 <.Loc.169.1>:
    a0c6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a0c8:	07 3c       	jmp	$+16     	;abs 0xa0d8

0000a0ca <.L22>:
    a0ca:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

0000a0ce <.Loc.174.1>:
    a0ce:	0c 4a       	mov	r10,	r12	;
    a0d0:	8d 12       	call	r13		;

0000a0d2 <.LVL23>:
    a0d2:	4c 43       	clr.b	r12		;
    a0d4:	01 3c       	jmp	$+4      	;abs 0xa0d8

0000a0d6 <.L23>:
    a0d6:	4c 43       	clr.b	r12		;

0000a0d8 <.L17>:
    a0d8:	19 17       	popm	#2,	r10	;16-bit words
    a0da:	30 41       	ret			

0000a0dc <raise>:
    a0dc:	0d 4c       	mov	r12,	r13	;
    a0de:	1c 42 14 5c 	mov	&0x5c14,r12	;0x5c14

0000a0e2 <.LVL37>:
    a0e2:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

0000a0e4 <L0>:
    a0e4:	7c a0       	dadd.b,		r12	;Warning: disassembly unreliable - not enough bytes available

0000a0e6 <.LVL38>:
    a0e6:	30 41       	ret			

0000a0e8 <_kill_r>:
    a0e8:	0a 15       	pushm	#1,	r10	;16-bit words

0000a0ea <.LCFI0>:
    a0ea:	0a 4c       	mov	r12,	r10	;
    a0ec:	0c 4d       	mov	r13,	r12	;

0000a0ee <.LVL1>:
    a0ee:	82 43 0e 5d 	mov	#0,	&0x5d0e	;r3 As==00

0000a0f2 <.Loc.61.1>:
    a0f2:	0d 4e       	mov	r14,	r13	;

0000a0f4 <.LVL2>:
    a0f4:	b0 12 1a a1 	call	#-24294	;#0xa11a

0000a0f8 <.LVL3>:
    a0f8:	3c 93       	cmp	#-1,	r12	;r3 As==11
    a0fa:	06 20       	jnz	$+14     	;abs 0xa108

0000a0fc <.Loc.61.1>:
    a0fc:	1d 42 0e 5d 	mov	&0x5d0e,r13	;0x5d0e
    a100:	0d 93       	cmp	#0,	r13	;r3 As==00
    a102:	02 24       	jz	$+6      	;abs 0xa108

0000a104 <.Loc.62.1>:
    a104:	8a 4d 00 00 	mov	r13,	0(r10)	;

0000a108 <.L1>:
    a108:	0a 17       	popm	#1,	r10	;16-bit words
    a10a:	30 41       	ret			

0000a10c <_getpid_r>:
    a10c:	b0 12 14 a1 	call	#-24300	;#0xa114

0000a110 <.LVL5>:
    a110:	30 41       	ret			

0000a112 <_exit>:
    a112:	ff 3f       	jmp	$+0      	;abs 0xa112

0000a114 <getpid>:
    a114:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

0000a116 <L0>:
    a116:	2a 00 30 41 	mova			;Warning: disassembly unreliable - not enough bytes available

0000a118 <.Loc.65.1>:
    a118:	30 41       	ret			

0000a11a <kill>:
    a11a:	b0 12 28 a1 	call	#-24280	;#0xa128
    a11e:	bc 40 58 00 	mov	#88,	0(r12)	;#0x0058
    a122:	00 00 
    a124:	3c 43       	mov	#-1,	r12	;r3 As==11
    a126:	30 41       	ret			

0000a128 <__errno>:
    a128:	1c 42 14 5c 	mov	&0x5c14,r12	;0x5c14
    a12c:	30 41       	ret			
