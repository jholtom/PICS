
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	e4 ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	e6 ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	e8 ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	ea ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	ec ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	ee ab       	dadd.b	@r11		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	f0 ab 00 00 	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	f2 ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	f4 ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	f6 ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	f8 ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	fa ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	fc ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	fe ab       	dadd.b	@r11+		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	00 ac       	dadd	r12,	r0	;

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	02 ac       	dadd	r12,	r2	;

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	04 ac       	dadd	r12,	r4	;

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	06 ac       	dadd	r12,	r6	;

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	08 ac       	dadd	r12,	r8	;

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	0a ac       	dadd	r12,	r10	;

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	0c ac       	dadd	r12,	r12	;

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	0e ac       	dadd	r12,	r14	;

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	10 ac       	dadd,		r0	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	12 ac       	dadd,		r2	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	14 ac       	dadd,		r4	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	16 ac       	dadd,		r6	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	18 ac       	dadd,		r8	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	1a ac       	dadd,		r10	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	1c ac       	dadd,		r12	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	1e ac       	dadd,		r14	;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	20 ac       	dadd	@r12,	r0	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	22 ac       	dadd	@r12,	r2	;

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	98 4e       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	50 4e       	br			;Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	24 ac       	dadd	@r12,	r4	;

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	26 ac       	dadd	@r12,	r6	;

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	0a 4e       	mov	r14,	r10	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	28 ac       	dadd	@r12,	r8	;

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	2a ac       	dadd	@r12,	r10	;

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	c6 4d       	mov.b	r13		; Warning: disassembly unreliable - not enough bytes available

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	4a 5c       	interrupt service routine at 0x5c4a

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	2c ac       	interrupt service routine at 0xac2c

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	0c 51       	interrupt service routine at 0x510c

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	2e ac       	interrupt service routine at 0xac2e

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	30 ac       	interrupt service routine at 0xac30

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	32 ac       	interrupt service routine at 0xac32

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	34 ac       	interrupt service routine at 0xac34

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	a8 57       	interrupt service routine at 0x57a8

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	36 ac       	interrupt service routine at 0xac36

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	38 ac       	interrupt service routine at 0xac38

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	78 4d       	interrupt service routine at 0x4d78

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	3a ac       	interrupt service routine at 0xac3a

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	3c ac       	interrupt service routine at 0xac3c

Disassembly of section __interrupt_vector_55:

0000fffc <_end-0x2>:
    fffc:	3e ac       	interrupt service routine at 0xac3e

Disassembly of section .text:

00004400 <__crt0_start>:
    4400:	31 40 54 bd 	mov	#-17068,r1	;#0xbd54

00004404 <disable_watchdog>:
#include "errors.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    4404:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    4408:	5c 01 

0000440a <__crt0_init_bss>:
    440a:	3c 40 1c cd 	mov	#-13028,r12	;#0xcd1c

0000440e <.Loc.74.1>:
    440e:	0d 43       	clr	r13		;

00004410 <.Loc.75.1>:
    4410:	3e 40 c4 22 	mov	#8900,	r14	;#0x22c4

00004414 <.Loc.79.1>:
    4414:	b0 12 42 b1 	call	#-20158	;#0xb142

00004418 <__crt0_movedata>:
    4418:	3c 40 00 1c 	mov	#7168,	r12	;#0x1c00

0000441c <.Loc.116.1>:
    441c:	3d 40 90 c8 	mov	#-14192,r13	;#0xc890

00004420 <.Loc.119.1>:
    4420:	0d 9c       	cmp	r12,	r13	;

00004422 <.Loc.120.1>:
    4422:	04 24       	jz	$+10     	;abs 0x442c

00004424 <.Loc.122.1>:
    4424:	3e 40 8c 04 	mov	#1164,	r14	;#0x048c

00004428 <.Loc.124.1>:
    4428:	b0 12 08 b1 	call	#-20216	;#0xb108

0000442c <__crt0_call_just_main>:
    442c:	0c 43       	clr	r12		;

0000442e <.Loc.181.1>:
    442e:	b0 12 d2 ae 	call	#-20782	;#0xaed2

00004432 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    4432:	03 43       	nop			

00004434 <.Loc.356.1>:
  _enable_interrupts();
    4434:	32 d2       	eint			
    4436:	03 43       	nop			

00004438 <.Loc.357.1>:
}
    4438:	30 41       	ret			

0000443a <port_disable>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    443a:	32 c2       	dint			

0000443c <.Loc.390.1>:
  asm volatile("nop");
    443c:	03 43       	nop			

0000443e <.Loc.391.1>:
}
    443e:	30 41       	ret			

00004440 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4440:	82 93 06 1c 	cmp	#0,	&0x1c06	;r3 As==00
    4444:	03 20       	jnz	$+8      	;abs 0x444c

00004446 <.Loc.79.2>:
    4446:	82 93 08 1c 	cmp	#0,	&0x1c08	;r3 As==00
    444a:	06 24       	jz	$+14     	;abs 0x4458

0000444c <.L8>:
 *
 * @special
 */
void chSysHalt(const char *reason) {

  port_disable();
    444c:	b0 12 3a 44 	call	#17466		;#0x443a

00004450 <.LVL4>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    4450:	b2 40 59 bd 	mov	#-17063,&0x1c0a	;#0xbd59
    4454:	0a 1c 

00004456 <.L10>:
    4456:	ff 3f       	jmp	$+0      	;abs 0x4456

00004458 <.L7>:
}
    4458:	30 41       	ret			

0000445a <_dbg_check_lock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    445a:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

0000445c <L0>:
    445c:	06 1c 03 20 	rpt #7 { jnzx.?	$+8      	;abs 0x4466, Warning: reserved use of A/L and B/W bits detected

00004460 <.Loc.103.2>:
    4460:	82 93 08 1c 	cmp	#0,	&0x1c08	;r3 As==00
    4464:	06 24       	jz	$+14     	;abs 0x4472

00004466 <.L16>:
  port_disable();
    4466:	b0 12 3a 44 	call	#17466		;#0x443a

0000446a <.LVL10>:
  nil.dbg_panic_msg = reason;
    446a:	b2 40 63 bd 	mov	#-17053,&0x1c0a	;#0xbd63
    446e:	0a 1c 

00004470 <.L18>:
    4470:	ff 3f       	jmp	$+0      	;abs 0x4470

00004472 <.L17>:
  _dbg_enter_lock();
    4472:	92 43 08 1c 	mov	#1,	&0x1c08	;r3 As==01

00004476 <.Loc.107.2>:
}
    4476:	30 41       	ret			

00004478 <_dbg_check_unlock>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4478:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

0000447a <L0>:
    447a:	06 1c 04 20 	rpt #7 { jnzx.?	$+10     	;abs 0x4486, Warning: reserved use of A/L and B/W bits detected

0000447e <.Loc.116.2>:
    447e:	4c 43       	clr.b	r12		;
    4480:	1c 92 08 1c 	cmp	&0x1c08,r12	;0x1c08
    4484:	06 38       	jl	$+14     	;abs 0x4492

00004486 <.L20>:
  port_disable();
    4486:	b0 12 3a 44 	call	#17466		;#0x443a

0000448a <.LVL13>:
  nil.dbg_panic_msg = reason;
    448a:	b2 40 68 bd 	mov	#-17048,&0x1c0a	;#0xbd68
    448e:	0a 1c 

00004490 <.L22>:
    4490:	ff 3f       	jmp	$+0      	;abs 0x4490

00004492 <.L21>:
  _dbg_leave_lock();
    4492:	82 43 08 1c 	mov	#0,	&0x1c08	;r3 As==00

00004496 <.Loc.120.2>:
}
    4496:	30 41       	ret			

00004498 <_dbg_check_lock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    4498:	4c 43       	clr.b	r12		;

0000449a <L0>:
    449a:	1c 92 06 1c 	cmp	&0x1c06,r12	;0x1c06
    449e:	03 34       	jge	$+8      	;abs 0x44a6

000044a0 <.Loc.129.2>:
    44a0:	82 9c 08 1c 	cmp	r12,	&0x1c08	;
    44a4:	06 24       	jz	$+14     	;abs 0x44b2

000044a6 <.L24>:
  port_disable();
    44a6:	b0 12 3a 44 	call	#17466		;#0x443a

000044aa <.LVL16>:
  nil.dbg_panic_msg = reason;
    44aa:	b2 40 6d bd 	mov	#-17043,&0x1c0a	;#0xbd6d
    44ae:	0a 1c 

000044b0 <.L26>:
    44b0:	ff 3f       	jmp	$+0      	;abs 0x44b0

000044b2 <.L25>:
  _dbg_enter_lock();
    44b2:	92 43 08 1c 	mov	#1,	&0x1c08	;r3 As==01

000044b6 <.Loc.133.2>:
}
    44b6:	30 41       	ret			

000044b8 <_dbg_check_unlock_from_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    44b8:	4c 43       	clr.b	r12		;

000044ba <L0>:
    44ba:	1c 92 06 1c 	cmp	&0x1c06,r12	;0x1c06
    44be:	03 34       	jge	$+8      	;abs 0x44c6

000044c0 <.Loc.142.2>:
    44c0:	1c 92 08 1c 	cmp	&0x1c08,r12	;0x1c08
    44c4:	06 38       	jl	$+14     	;abs 0x44d2

000044c6 <.L28>:
  port_disable();
    44c6:	b0 12 3a 44 	call	#17466		;#0x443a

000044ca <.LVL19>:
  nil.dbg_panic_msg = reason;
    44ca:	b2 40 72 bd 	mov	#-17038,&0x1c0a	;#0xbd72
    44ce:	0a 1c 

000044d0 <.L30>:
    44d0:	ff 3f       	jmp	$+0      	;abs 0x44d0

000044d2 <.L29>:
  _dbg_leave_lock();
    44d2:	82 43 08 1c 	mov	#0,	&0x1c08	;r3 As==00

000044d6 <.Loc.146.2>:
}
    44d6:	30 41       	ret			

000044d8 <_dbg_check_enter_isr>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    44d8:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

000044da <L0>:
    44da:	00 1c 1d 4c 	movx.?	-524282(r12),r13	;0xfff80006, Warning: reserved use of A/L and B/W bits detected
    44de:	06 00 
    44e0:	0d 93       	cmp	#0,	r13	;r3 As==00
    44e2:	03 38       	jl	$+8      	;abs 0x44ea

000044e4 <.Loc.156.2>:
    44e4:	82 93 08 1c 	cmp	#0,	&0x1c08	;r3 As==00
    44e8:	06 24       	jz	$+14     	;abs 0x44f6

000044ea <.L32>:
  port_disable();
    44ea:	b0 12 3a 44 	call	#17466		;#0x443a

000044ee <.LVL22>:
  nil.dbg_panic_msg = reason;
    44ee:	b2 40 77 bd 	mov	#-17033,&0x1c0a	;#0xbd77
    44f2:	0a 1c 

000044f4 <.L34>:
    44f4:	ff 3f       	jmp	$+0      	;abs 0x44f4

000044f6 <.L33>:
  nil.isr_cnt++;
    44f6:	1d 53       	inc	r13		;
    44f8:	8c 4d 06 00 	mov	r13,	6(r12)	;

000044fc <.Loc.161.2>:
}
    44fc:	30 41       	ret			

000044fe <_dbg_check_leave_isr>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    44fe:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00004500 <L0>:
    4500:	00 1c 1d 4c 	movx.?	-524282(r12),r13	;0xfff80006, Warning: reserved use of A/L and B/W bits detected
    4504:	06 00 
    4506:	4e 43       	clr.b	r14		;
    4508:	0e 9d       	cmp	r13,	r14	;
    450a:	03 34       	jge	$+8      	;abs 0x4512

0000450c <.Loc.171.2>:
    450c:	82 9e 08 1c 	cmp	r14,	&0x1c08	;
    4510:	06 24       	jz	$+14     	;abs 0x451e

00004512 <.L36>:
  port_disable();
    4512:	b0 12 3a 44 	call	#17466		;#0x443a

00004516 <.LVL25>:
  nil.dbg_panic_msg = reason;
    4516:	b2 40 7c bd 	mov	#-17028,&0x1c0a	;#0xbd7c
    451a:	0a 1c 

0000451c <.L38>:
    451c:	ff 3f       	jmp	$+0      	;abs 0x451c

0000451e <.L37>:
  nil.isr_cnt--;
    451e:	3d 53       	add	#-1,	r13	;r3 As==11
    4520:	8c 4d 06 00 	mov	r13,	6(r12)	;

00004524 <.Loc.176.2>:
}
    4524:	30 41       	ret			

00004526 <chDbgCheckClassI>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4526:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00004528 <L0>:
    4528:	06 1c 04 38 	rpt #7 { jlx.?	$+10     	;abs 0x4534, Warning: reserved use of A/L and B/W bits detected

0000452c <.Loc.188.2>:
    452c:	4c 43       	clr.b	r12		;
    452e:	1c 92 08 1c 	cmp	&0x1c08,r12	;0x1c08
    4532:	06 38       	jl	$+14     	;abs 0x4540

00004534 <.L40>:
  port_disable();
    4534:	b0 12 3a 44 	call	#17466		;#0x443a

00004538 <.LVL28>:
  nil.dbg_panic_msg = reason;
    4538:	b2 40 81 bd 	mov	#-17023,&0x1c0a	;#0xbd81
    453c:	0a 1c 

0000453e <.L42>:
    453e:	ff 3f       	jmp	$+0      	;abs 0x453e

00004540 <.L39>:
}
    4540:	30 41       	ret			

00004542 <chDbgCheckClassS>:
  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    4542:	82 93       	cmp	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

00004544 <L0>:
    4544:	06 1c 04 20 	rpt #7 { jnzx.?	$+10     	;abs 0x4550, Warning: reserved use of A/L and B/W bits detected

00004548 <.Loc.203.2>:
    4548:	4c 43       	clr.b	r12		;
    454a:	1c 92 08 1c 	cmp	&0x1c08,r12	;0x1c08
    454e:	06 38       	jl	$+14     	;abs 0x455c

00004550 <.L44>:
  port_disable();
    4550:	b0 12 3a 44 	call	#17466		;#0x443a

00004554 <.LVL31>:
  nil.dbg_panic_msg = reason;
    4554:	b2 40 87 bd 	mov	#-17017,&0x1c0a	;#0xbd87
    4558:	0a 1c 

0000455a <.L46>:
    455a:	ff 3f       	jmp	$+0      	;abs 0x455a

0000455c <.L43>:
}
    455c:	30 41       	ret			

0000455e <chSysInit>:
void chSysInit(void) {
    455e:	0a 15       	pushm	#1,	r10	;16-bit words

00004560 <L0>:
  nil.isr_cnt  = (cnt_t)0;
    4560:	82 43 06 1c 	mov	#0,	&0x1c06	;r3 As==00

00004564 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    4564:	82 43 08 1c 	mov	#0,	&0x1c08	;r3 As==00

00004568 <.Loc.234.2>:
  tcp = nil_thd_configs;
    4568:	3c 40 f6 bd 	mov	#-16906,r12	;#0xbdf6

0000456c <.Loc.233.2>:
  tp = &nil.threads[0];
    456c:	3a 40 0c 1c 	mov	#7180,	r10	;#0x1c0c

00004570 <.L48>:
    tp->wabase  = (stkalign_t *)tcp->wbase;
    4570:	aa 4c 0e 00 	mov	@r12,	14(r10)	; 0x000e

00004574 <.Loc.241.2>:
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    4574:	1d 4c 02 00 	mov	2(r12),	r13	;
    4578:	0e 4d       	mov	r13,	r14	;
    457a:	3e 50 f0 ff 	add	#-16,	r14	;#0xfff0
    457e:	8a 4e 00 00 	mov	r14,	0(r10)	;
    4582:	9d 4c 06 00 	mov	6(r12),	-16(r13); 0xfff0
    4586:	f0 ff 
    4588:	9d 4c 08 00 	mov	8(r12),	-14(r13); 0xfff2
    458c:	f2 ff 
    458e:	bd 40 14 4b 	mov	#19220,	-2(r13)	;#0x4b14, 0xfffe
    4592:	fe ff 

00004594 <.Loc.246.2>:
    tp++;
    4594:	3a 50 10 00 	add	#16,	r10	;#0x0010

00004598 <.Loc.247.2>:
    tcp++;
    4598:	3c 50 0a 00 	add	#10,	r12	;#0x000a

0000459c <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    459c:	3a 90 4c 1c 	cmp	#7244,	r10	;#0x1c4c
    45a0:	e7 2b       	jnc	$-48     	;abs 0x4570

000045a2 <.Loc.253.2>:
  tp->wabase  = THD_IDLE_BASE;
    45a2:	ba 40 54 bd 	mov	#-17068,14(r10)	;#0xbd54, 0x000e
    45a6:	0e 00 

000045a8 <.Loc.258.2>:
  chSysSuspend();
    45a8:	b0 12 3a 44 	call	#17466		;#0x443a

000045ac <.LVL37>:
    45ac:	b0 12 40 44 	call	#17472		;#0x4440

000045b0 <.LVL38>:
  nil.lock_cnt = (cnt_t)1;
    45b0:	3c 40 00 1c 	mov	#7168,	r12	;#0x1c00
    45b4:	92 43 08 1c 	mov	#1,	&0x1c08	;r3 As==01

000045b8 <.LBB86>:
  __msp430x_in_isr = false;
    45b8:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00

000045bc <.LBE86>:
  nil.current = nil.next = nil.threads;
    45bc:	0d 4c       	mov	r12,	r13	;
    45be:	3d 50 0c 00 	add	#12,	r13	;#0x000c
    45c2:	8c 4d 02 00 	mov	r13,	2(r12)	;
    45c6:	0e 4d       	mov	r13,	r14	;
    45c8:	8c 4d 00 00 	mov	r13,	0(r12)	;

000045cc <.Loc.275.2>:
  port_switch(nil.current, tp);
    45cc:	0d 4a       	mov	r10,	r13	;
    45ce:	0c 4e       	mov	r14,	r12	;
    45d0:	b0 12 08 4b 	call	#19208		;#0x4b08

000045d4 <.LVL39>:
  chSysUnlock();
    45d4:	b0 12 78 44 	call	#17528		;#0x4478

000045d8 <.LVL40>:
    45d8:	b0 12 32 44 	call	#17458		;#0x4432

000045dc <.LVL41>:
}
    45dc:	0a 17       	popm	#1,	r10	;16-bit words
    45de:	30 41       	ret			

000045e0 <chSysHalt>:
void chSysHalt(const char *reason) {
    45e0:	0a 15       	pushm	#1,	r10	;16-bit words

000045e2 <.LCFI1>:
    45e2:	0a 4c       	mov	r12,	r10	;

000045e4 <.Loc.293.2>:
  port_disable();
    45e4:	b0 12 3a 44 	call	#17466		;#0x443a

000045e8 <.LVL43>:
  nil.dbg_panic_msg = reason;
    45e8:	82 4a 0a 1c 	mov	r10,	&0x1c0a	;

000045ec <.L51>:
    45ec:	ff 3f       	jmp	$+0      	;abs 0x45ec

000045ee <chSysGetStatusAndLockX>:
    45ee:	0a 15       	pushm	#1,	r10	;16-bit words

000045f0 <L0>:
  return __get_SR_register();
    45f0:	0a 42       	mov	r2,	r10	;

000045f2 <.LBE92>:
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void)  {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    45f2:	3a b2       	bit	#8,	r10	;r2 As==11
    45f4:	05 24       	jz	$+12     	;abs 0x4600

000045f6 <.Loc.450.2>:
    if (port_is_isr_context()) {
    45f6:	c2 93 5c 1c 	cmp.b	#0,	&0x1c5c	;r3 As==00
    45fa:	05 24       	jz	$+12     	;abs 0x4606

000045fc <.Loc.451.2>:
      chSysLockFromISR();
    45fc:	b0 12 98 44 	call	#17560		;#0x4498

00004600 <.L60>:
    else {
      chSysLock();
    }
  }
  return sts;
}
    4600:	0c 4a       	mov	r10,	r12	;
    4602:	0a 17       	popm	#1,	r10	;16-bit words
    4604:	30 41       	ret			

00004606 <.L61>:
      chSysLock();
    4606:	b0 12 3a 44 	call	#17466		;#0x443a

0000460a <.LVL49>:
    460a:	b0 12 5a 44 	call	#17498		;#0x445a

0000460e <.LVL50>:
    460e:	f8 3f       	jmp	$-14     	;abs 0x4600

00004610 <chSchReadyI>:
    4610:	0a 15       	pushm	#1,	r10	;16-bit words

00004612 <L0>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    4612:	21 83       	decd	r1		;

00004614 <.LCFI4>:
    4614:	0a 4d       	mov	r13,	r10	;

00004616 <.Loc.536.2>:

  chDbgCheckClassI();
    4616:	81 4c 00 00 	mov	r12,	0(r1)	;
    461a:	b0 12 26 45 	call	#17702		;#0x4526

0000461e <.LVL52>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    461e:	2c 41       	mov	@r1,	r12	;
    4620:	8c 4a 04 00 	mov	r10,	4(r12)	;

00004624 <.Loc.542.2>:
  tp->state = NIL_STATE_READY;
    4624:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00004628 <.Loc.543.2>:
  tp->timeout = (systime_t)0;
    4628:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

0000462c <.Loc.544.2>:
  if (tp < nil.next) {
    462c:	1c 92 02 1c 	cmp	&0x1c02,r12	;0x1c02
    4630:	02 2c       	jc	$+6      	;abs 0x4636

00004632 <.Loc.545.2>:
    nil.next = tp;
    4632:	82 4c 02 1c 	mov	r12,	&0x1c02	;

00004636 <.L66>:
  }
  return tp;
}
    4636:	21 53       	incd	r1		;
    4638:	0a 17       	popm	#1,	r10	;16-bit words
    463a:	30 41       	ret			

0000463c <chSysTimerHandlerI>:
void chSysTimerHandlerI(void) {
    463c:	3a 15       	pushm	#4,	r10	;16-bit words

0000463e <.LCFI5>:
  chDbgCheckClassI();
    463e:	b0 12 26 45 	call	#17702		;#0x4526

00004642 <.LVL53>:
  nil.systime++;
    4642:	3a 40 00 1c 	mov	#7168,	r10	;#0x1c00
    4646:	9a 53 04 00 	inc	4(r10)		;
    464a:	3a 50 10 00 	add	#16,	r10	;#0x0010

0000464e <.Loc.341.2>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    464e:	37 40 10 46 	mov	#17936,	r7	;#0x4610

00004652 <.Loc.346.2>:
    chSysUnlockFromISR();
    4652:	38 40 b8 44 	mov	#17592,	r8	;#0x44b8

00004656 <.Loc.348.2>:
    chSysLockFromISR();
    4656:	39 40 98 44 	mov	#17560,	r9	;#0x4498

0000465a <.L73>:
    465a:	0c 4a       	mov	r10,	r12	;
    465c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

00004660 <.LVL55>:
    if (tp->timeout > (systime_t)0) {
    4660:	1d 4c 08 00 	mov	8(r12),	r13	;
    4664:	0d 93       	cmp	#0,	r13	;r3 As==00
    4666:	11 24       	jz	$+36     	;abs 0x468a

00004668 <.Loc.330.2>:
      if (--tp->timeout == (systime_t)0) {
    4668:	1d 4c 08 00 	mov	8(r12),	r13	;
    466c:	3d 53       	add	#-1,	r13	;r3 As==11
    466e:	8c 4d 08 00 	mov	r13,	8(r12)	;
    4672:	0d 93       	cmp	#0,	r13	;r3 As==00
    4674:	0a 20       	jnz	$+22     	;abs 0x468a

00004676 <.Loc.334.2>:
        if (NIL_THD_IS_WTSEM(tp)) {
    4676:	5e 4a fe ff 	mov.b	-2(r10),r14	;
    467a:	7e 90 03 00 	cmp.b	#3,	r14	;
    467e:	13 20       	jnz	$+40     	;abs 0x46a6

00004680 <.Loc.335.2>:
          tp->u1.semp->cnt++;
    4680:	2d 4a       	mov	@r10,	r13	;
    4682:	9d 53 00 00 	inc	0(r13)		;

00004686 <.L72>:
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    4686:	3d 43       	mov	#-1,	r13	;r3 As==11
    4688:	87 12       	call	r7		;

0000468a <.L69>:
    chSysUnlockFromISR();
    468a:	88 12       	call	r8		;

0000468c <.LVL57>:
    chSysLockFromISR();
    468c:	89 12       	call	r9		;

0000468e <.LVL58>:
    468e:	0c 4a       	mov	r10,	r12	;
    4690:	3c 50 10 00 	add	#16,	r12	;#0x0010

00004694 <.Loc.349.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    4694:	3a 50 0c 00 	add	#12,	r10	;#0x000c

00004698 <.LVL59>:
    4698:	3a 90 4c 1c 	cmp	#7244,	r10	;#0x1c4c
    469c:	02 28       	jnc	$+6      	;abs 0x46a2

0000469e <.Loc.403.2>:
}
    469e:	37 17       	popm	#4,	r10	;16-bit words
    46a0:	30 41       	ret			

000046a2 <.L74>:
    46a2:	0a 4c       	mov	r12,	r10	;

000046a4 <.LVL60>:
    46a4:	da 3f       	jmp	$-74     	;abs 0x465a

000046a6 <.L71>:
        else if (NIL_THD_IS_SUSP(tp)) {
    46a6:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    46a8:	ee 23       	jnz	$-34     	;abs 0x4686

000046aa <.Loc.338.2>:
          *tp->u1.trp = NULL;
    46aa:	2e 4a       	mov	@r10,	r14	;
    46ac:	8e 4d 00 00 	mov	r13,	0(r14)	;
    46b0:	ea 3f       	jmp	$-42     	;abs 0x4686

000046b2 <chSchIsPreemptionRequired>:
    46b2:	3c 40 00 1c 	mov	#7168,	r12	;#0x1c00

000046b6 <L0>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    46b6:	2d 4c       	mov	@r12,	r13	;
    46b8:	1d ec 02 00 	xor	2(r12),	r13	;
    46bc:	0c 43       	clr	r12		;
    46be:	0c 8d       	sub	r13,	r12	;
    46c0:	0c dd       	bis	r13,	r12	;

000046c2 <.Loc.566.2>:
}
    46c2:	5c 03       	rrum	#1,	r12	;
    46c4:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    46c8:	30 41       	ret			

000046ca <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = nil.current;
    46ca:	3e 40 00 1c 	mov	#7168,	r14	;#0x1c00
    46ce:	2d 4e       	mov	@r14,	r13	;

000046d0 <.LVL62>:

  nil.current = nil.next;
    46d0:	1c 4e 02 00 	mov	2(r14),	r12	;
    46d4:	8e 4c 00 00 	mov	r12,	0(r14)	;

000046d8 <.Loc.582.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    46d8:	b0 12 08 4b 	call	#19208		;#0x4b08

000046dc <.LVL63>:
}
    46dc:	30 41       	ret			

000046de <chSchRescheduleS>:
 *
 * @sclass
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();
    46de:	b0 12 42 45 	call	#17730		;#0x4542

000046e2 <.LVL64>:

  if (chSchIsRescRequiredI()) {
    46e2:	92 92 02 1c 	cmp	&0x1c02,&0x1c00	;0x1c02
    46e6:	00 1c 
    46e8:	02 24       	jz	$+6      	;abs 0x46ee

000046ea <.Loc.595.2>:
    chSchDoReschedule();
    46ea:	b0 12 ca 46 	call	#18122		;#0x46ca

000046ee <.L77>:
  }
}
    46ee:	30 41       	ret			

000046f0 <chSysRestoreStatusX>:
  if (port_irq_enabled(sts)) {
    46f0:	3c b2       	bit	#8,	r12	;r2 As==11
    46f2:	05 24       	jz	$+12     	;abs 0x46fe

000046f4 <.Loc.472.2>:
    if (port_is_isr_context()) {
    46f4:	c2 93 5c 1c 	cmp.b	#0,	&0x1c5c	;r3 As==00
    46f8:	03 24       	jz	$+8      	;abs 0x4700

000046fa <.Loc.473.2>:
      chSysUnlockFromISR();
    46fa:	b0 12 b8 44 	call	#17592		;#0x44b8

000046fe <.L79>:
}
    46fe:	30 41       	ret			

00004700 <.L81>:
      chSchRescheduleS();
    4700:	b0 12 de 46 	call	#18142		;#0x46de

00004704 <.LVL69>:
      chSysUnlock();
    4704:	b0 12 78 44 	call	#17528		;#0x4478

00004708 <.LVL70>:
    4708:	b0 12 32 44 	call	#17458		;#0x4432

0000470c <.LVL71>:
}
    470c:	f8 3f       	jmp	$-14     	;abs 0x46fe

0000470e <chSchGoSleepTimeoutS>:
    470e:	3a 15       	pushm	#4,	r10	;16-bit words

00004710 <L0>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    4710:	47 4c       	mov.b	r12,	r7	;
    4712:	08 4d       	mov	r13,	r8	;

00004714 <.Loc.617.2>:
  thread_t *ntp, *otp = nil.current;
    4714:	3a 40 00 1c 	mov	#7168,	r10	;#0x1c00
    4718:	29 4a       	mov	@r10,	r9	;

0000471a <.Loc.619.2>:

  chDbgCheckClassS();
    471a:	b0 12 42 45 	call	#17730		;#0x4542

0000471e <.LVL74>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    471e:	c9 47 02 00 	mov.b	r7,	2(r9)	;

00004722 <.Loc.660.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    4722:	89 48 08 00 	mov	r8,	8(r9)	;
    4726:	0e 4a       	mov	r10,	r14	;
    4728:	3e 50 0e 00 	add	#14,	r14	;#0x000e

0000472c <.L86>:
    472c:	0c 4e       	mov	r14,	r12	;
    472e:	3c 50 fe ff 	add	#-2,	r12	;#0xfffe

00004732 <.LVL77>:
    4732:	3e 50 10 00 	add	#16,	r14	;#0x0010

00004736 <.Loc.667.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    4736:	ce 93 f0 ff 	cmp.b	#0,	-16(r14);r3 As==00, 0xfff0
    473a:	f8 23       	jnz	$-14     	;abs 0x472c

0000473c <.Loc.668.2>:
      nil.current = nil.next = ntp;
    473c:	8a 4c 02 00 	mov	r12,	2(r10)	;
    4740:	8a 4c 00 00 	mov	r12,	0(r10)	;

00004744 <.Loc.672.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    4744:	0d 49       	mov	r9,	r13	;
    4746:	b0 12 08 4b 	call	#19208		;#0x4b08

0000474a <.LVL78>:
      return nil.current->u1.msg;
    474a:	2c 4a       	mov	@r10,	r12	;

0000474c <.Loc.681.2>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    474c:	1c 4c 04 00 	mov	4(r12),	r12	;
    4750:	37 17       	popm	#4,	r10	;16-bit words
    4752:	30 41       	ret			

00004754 <chThdSuspendTimeoutS>:
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    4754:	3e 40 00 1c 	mov	#7168,	r14	;#0x1c00
    4758:	ac 4e 00 00 	mov	@r14,	0(r12)	;

0000475c <.Loc.702.2>:
  nil.current->u1.trp = trp;
    475c:	2e 4e       	mov	@r14,	r14	;
    475e:	8e 4c 04 00 	mov	r12,	4(r14)	;

00004762 <.Loc.703.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    4762:	6c 43       	mov.b	#2,	r12	;r3 As==10

00004764 <.LVL80>:
    4764:	b0 12 0e 47 	call	#18190		;#0x470e

00004768 <.LVL81>:
}
    4768:	30 41       	ret			

0000476a <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    476a:	2e 4c       	mov	@r12,	r14	;
    476c:	0e 93       	cmp	#0,	r14	;r3 As==00
    476e:	05 24       	jz	$+12     	;abs 0x477a

00004770 <.LBB94>:
    thread_reference_t tr = *trp;

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    4770:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00004774 <.Loc.724.2>:
    (void) chSchReadyI(tr, msg);
    4774:	0c 4e       	mov	r14,	r12	;

00004776 <.LVL84>:
    4776:	b0 12 10 46 	call	#17936		;#0x4610

0000477a <.L89>:
  }
}
    477a:	30 41       	ret			

0000477c <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    477c:	0a 15       	pushm	#1,	r10	;16-bit words

0000477e <.LCFI7>:
    477e:	0a 4c       	mov	r12,	r10	;

00004780 <.Loc.737.2>:

  chSysLock();
    4780:	b0 12 3a 44 	call	#17466		;#0x443a

00004784 <.LVL87>:
    4784:	b0 12 5a 44 	call	#17498		;#0x445a

00004788 <.LVL88>:
  chThdSleepS(timeout);
    4788:	0d 4a       	mov	r10,	r13	;
    478a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    478c:	b0 12 0e 47 	call	#18190		;#0x470e

00004790 <.LVL89>:
  chSysUnlock();
    4790:	b0 12 78 44 	call	#17528		;#0x4478

00004794 <.LVL90>:
    4794:	b0 12 32 44 	call	#17458		;#0x4432

00004798 <.LVL91>:
}
    4798:	0a 17       	popm	#1,	r10	;16-bit words
    479a:	30 41       	ret			

0000479c <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    479c:	0a 15       	pushm	#1,	r10	;16-bit words

0000479e <.LCFI9>:
    479e:	21 83       	decd	r1		;

000047a0 <.LCFI10>:
    47a0:	0a 4c       	mov	r12,	r10	;

000047a2 <.Loc.808.2>:

  chDbgCheckClassS();
    47a2:	81 4d 00 00 	mov	r13,	0(r1)	;
    47a6:	b0 12 42 45 	call	#17730		;#0x4542

000047aa <.LVL100>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    47aa:	2c 4a       	mov	@r10,	r12	;

000047ac <.LVL101>:
  if (cnt <= (cnt_t)0) {
    47ac:	2d 41       	mov	@r1,	r13	;
    47ae:	4e 43       	clr.b	r14		;
    47b0:	0e 9c       	cmp	r12,	r14	;
    47b2:	10 38       	jl	$+34     	;abs 0x47d4

000047b4 <.Loc.815.2>:
    if (TIME_IMMEDIATE == timeout) {
    47b4:	3d 93       	cmp	#-1,	r13	;r3 As==11
    47b6:	13 24       	jz	$+40     	;abs 0x47de

000047b8 <.Loc.818.2>:
      return MSG_TIMEOUT;
    }
    sp->cnt = cnt - (cnt_t)1;
    47b8:	3c 53       	add	#-1,	r12	;r3 As==11

000047ba <.LVL102>:
    47ba:	8a 4c 00 00 	mov	r12,	0(r10)	;

000047be <.Loc.819.2>:
    nil.current->u1.semp = sp;
    47be:	1c 42 00 1c 	mov	&0x1c00,r12	;0x1c00

000047c2 <.LVL103>:
    47c2:	8c 4a 04 00 	mov	r10,	4(r12)	;

000047c6 <.LVL104>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    47c6:	7c 40 03 00 	mov.b	#3,	r12	;
    47ca:	b0 12 0e 47 	call	#18190		;#0x470e

000047ce <.L96>:
  }
  sp->cnt = cnt - (cnt_t)1;
  return MSG_OK;
}
    47ce:	21 53       	incd	r1		;
    47d0:	0a 17       	popm	#1,	r10	;16-bit words
    47d2:	30 41       	ret			

000047d4 <.L97>:
  sp->cnt = cnt - (cnt_t)1;
    47d4:	3c 53       	add	#-1,	r12	;r3 As==11

000047d6 <.LVL107>:
    47d6:	8a 4c 00 00 	mov	r12,	0(r10)	;

000047da <.Loc.823.2>:
  return MSG_OK;
    47da:	4c 43       	clr.b	r12		;

000047dc <.LVL108>:
    47dc:	f8 3f       	jmp	$-14     	;abs 0x47ce

000047de <.L99>:
      return MSG_TIMEOUT;
    47de:	0c 4d       	mov	r13,	r12	;

000047e0 <.LVL110>:
    47e0:	f6 3f       	jmp	$-18     	;abs 0x47ce

000047e2 <chSemWaitTimeout>:
    47e2:	21 82       	sub	#4,	r1	;r2 As==10

000047e4 <.LCFI11>:
  chSysLock();
    47e4:	81 4c       	mov	r12		; Warning: disassembly unreliable - not enough bytes available

000047e6 <L0>:
    47e6:	00 00       	beq			
    47e8:	81 4d 02 00 	mov	r13,	2(r1)	;
    47ec:	b0 12 3a 44 	call	#17466		;#0x443a

000047f0 <.LVL112>:
    47f0:	b0 12 5a 44 	call	#17498		;#0x445a

000047f4 <.LVL113>:
  msg = chSemWaitTimeoutS(sp, timeout);
    47f4:	1d 41 02 00 	mov	2(r1),	r13	;
    47f8:	2c 41       	mov	@r1,	r12	;
    47fa:	b0 12 9c 47 	call	#18332		;#0x479c

000047fe <.LVL114>:
  chSysUnlock();
    47fe:	81 4c 00 00 	mov	r12,	0(r1)	;
    4802:	b0 12 78 44 	call	#17528		;#0x4478

00004806 <.LVL115>:
    4806:	b0 12 32 44 	call	#17458		;#0x4432

0000480a <.LVL116>:
}
    480a:	2c 41       	mov	@r1,	r12	;
    480c:	21 52       	add	#4,	r1	;r2 As==10
    480e:	30 41       	ret			

00004810 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    4810:	0a 15       	pushm	#1,	r10	;16-bit words

00004812 <.LCFI12>:
    4812:	0a 4c       	mov	r12,	r10	;

00004814 <.Loc.854.2>:

  chDbgCheckClassI();
    4814:	b0 12 26 45 	call	#17702		;#0x4526

00004818 <.LVL118>:
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    4818:	2c 4a       	mov	@r10,	r12	;
    481a:	1c 53       	inc	r12		;
    481c:	8a 4c 00 00 	mov	r12,	0(r10)	;
    4820:	4d 43       	clr.b	r13		;
    4822:	0d 9c       	cmp	r12,	r13	;
    4824:	0d 38       	jl	$+28     	;abs 0x4840
    4826:	3d 40 10 1c 	mov	#7184,	r13	;#0x1c10

0000482a <.L103>:
    482a:	0c 4d       	mov	r13,	r12	;
    482c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

00004830 <.LVL119>:
    4830:	3d 50 10 00 	add	#16,	r13	;#0x0010

00004834 <.LBB100>:
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    4834:	1a 9d f0 ff 	cmp	-16(r13),r10	;0xfffffff0
    4838:	f8 23       	jnz	$-14     	;abs 0x482a

0000483a <.Loc.865.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        (void) chSchReadyI(tr, MSG_OK);
    483a:	4d 43       	clr.b	r13		;
    483c:	b0 12 10 46 	call	#17936		;#0x4610

00004840 <.L101>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4840:	0a 17       	popm	#1,	r10	;16-bit words
    4842:	30 41       	ret			

00004844 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t mask) {
    4844:	1a 15       	pushm	#2,	r10	;16-bit words

00004846 <.LCFI16>:
    4846:	21 83       	decd	r1		;

00004848 <.LCFI17>:
    4848:	0a 4d       	mov	r13,	r10	;
    484a:	09 4e       	mov	r14,	r9	;

0000484c <.Loc.971.2>:

  chDbgCheckClassI();
    484c:	81 4c 00 00 	mov	r12,	0(r1)	;
    4850:	b0 12 26 45 	call	#17702		;#0x4526

00004854 <.LVL146>:
  chDbgCheck(tp != NULL);

  tp->epmask |= mask;
    4854:	2c 41       	mov	@r1,	r12	;
    4856:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    485a:	0d da       	bis	r10,	r13	;
    485c:	1e 4c 0c 00 	mov	12(r12),r14	;0x0000c
    4860:	0e d9       	bis	r9,	r14	;
    4862:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a
    4866:	8c 4e 0c 00 	mov	r14,	12(r12)	; 0x000c

0000486a <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    486a:	ec 92 02 00 	cmp.b	#4,	2(r12)	;r2 As==10
    486e:	0a 20       	jnz	$+22     	;abs 0x4884

00004870 <.Loc.976.2>:
      ((tp->epmask & tp->u1.ewmask) != (eventmask_t)0)) {
    4870:	1d fc 04 00 	and	4(r12),	r13	;
    4874:	1e fc 06 00 	and	6(r12),	r14	;

00004878 <.Loc.975.2>:
  if (NIL_THD_IS_WTOREVT(tp) &&
    4878:	0d de       	bis	r14,	r13	;
    487a:	0d 93       	cmp	#0,	r13	;r3 As==00
    487c:	03 24       	jz	$+8      	;abs 0x4884

0000487e <.Loc.977.2>:
    (void) chSchReadyI(tp, MSG_OK);
    487e:	4d 43       	clr.b	r13		;
    4880:	b0 12 10 46 	call	#17936		;#0x4610

00004884 <.L111>:
  }
}
    4884:	21 53       	incd	r1		;
    4886:	19 17       	popm	#2,	r10	;16-bit words
    4888:	30 41       	ret			

0000488a <chEvtSignal>:
void chEvtSignal(thread_t *tp, eventmask_t mask) {
    488a:	19 15       	pushm	#2,	r9	;16-bit words

0000488c <.LCFI18>:
    488c:	21 83       	decd	r1		;

0000488e <.LCFI19>:
    488e:	08 4d       	mov	r13,	r8	;
    4890:	09 4e       	mov	r14,	r9	;

00004892 <.Loc.951.2>:
  chSysLock();
    4892:	81 4c 00 00 	mov	r12,	0(r1)	;
    4896:	b0 12 3a 44 	call	#17466		;#0x443a

0000489a <.LVL149>:
    489a:	b0 12 5a 44 	call	#17498		;#0x445a

0000489e <.LVL150>:
  chEvtSignalI(tp, mask);
    489e:	0d 48       	mov	r8,	r13	;
    48a0:	0e 49       	mov	r9,	r14	;
    48a2:	2c 41       	mov	@r1,	r12	;
    48a4:	b0 12 44 48 	call	#18500		;#0x4844

000048a8 <.LVL151>:
  chSchRescheduleS();
    48a8:	b0 12 de 46 	call	#18142		;#0x46de

000048ac <.LVL152>:
  chSysUnlock();
    48ac:	b0 12 78 44 	call	#17528		;#0x4478

000048b0 <.LVL153>:
    48b0:	b0 12 32 44 	call	#17458		;#0x4432

000048b4 <.LVL154>:
}
    48b4:	21 53       	incd	r1		;
    48b6:	18 17       	popm	#2,	r9	;16-bit words
    48b8:	30 41       	ret			

000048ba <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t timeout) {
    48ba:	6a 15       	pushm	#7,	r10	;16-bit words

000048bc <.LCFI20>:
    48bc:	21 83       	decd	r1		;

000048be <.LCFI21>:
    48be:	06 4c       	mov	r12,	r6	;
    48c0:	07 4d       	mov	r13,	r7	;

000048c2 <.Loc.1000.2>:
  thread_t *ctp = nil.current;
    48c2:	1a 42 00 1c 	mov	&0x1c00,r10	;0x1c00

000048c6 <.Loc.1003.2>:
  eventmask_t m;

  chSysLock();
    48c6:	81 4e 00 00 	mov	r14,	0(r1)	;
    48ca:	b0 12 3a 44 	call	#17466		;#0x443a

000048ce <.LVL157>:
    48ce:	b0 12 5a 44 	call	#17498		;#0x445a

000048d2 <.LVL158>:
  if ((m = (ctp->epmask & mask)) == (eventmask_t)0) {
    48d2:	18 4a 0a 00 	mov	10(r10),r8	;0x0000a
    48d6:	08 f6       	and	r6,	r8	;
    48d8:	19 4a 0c 00 	mov	12(r10),r9	;0x0000c
    48dc:	09 f7       	and	r7,	r9	;

000048de <.LVL159>:
    48de:	0c 48       	mov	r8,	r12	;
    48e0:	0c d9       	bis	r9,	r12	;
    48e2:	34 40 78 44 	mov	#17528,	r4	;#0x4478
    48e6:	35 40 32 44 	mov	#17458,	r5	;#0x4432
    48ea:	2d 41       	mov	@r1,	r13	;
    48ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    48ee:	18 20       	jnz	$+50     	;abs 0x4920

000048f0 <.Loc.1005.2>:
    if (TIME_IMMEDIATE == timeout) {
    48f0:	3d 93       	cmp	#-1,	r13	;r3 As==11
    48f2:	07 20       	jnz	$+16     	;abs 0x4902

000048f4 <.L123>:
      return (eventmask_t)0;
    }
    m = ctp->epmask & mask;
  }
  ctp->epmask &= ~m;
  chSysUnlock();
    48f4:	84 12       	call	r4		;

000048f6 <.LVL161>:
    48f6:	85 12       	call	r5		;

000048f8 <.LVL162>:

  return m;
}
    48f8:	0c 48       	mov	r8,	r12	;
    48fa:	0d 49       	mov	r9,	r13	;
    48fc:	21 53       	incd	r1		;
    48fe:	64 17       	popm	#7,	r10	;16-bit words
    4900:	30 41       	ret			

00004902 <.L120>:
    ctp->u1.ewmask = mask;
    4902:	8a 46 04 00 	mov	r6,	4(r10)	;
    4906:	8a 47 06 00 	mov	r7,	6(r10)	;

0000490a <.Loc.1011.2>:
    if (chSchGoSleepTimeoutS(NIL_STATE_WTOREVT, timeout) < MSG_OK) {
    490a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    490c:	b0 12 0e 47 	call	#18190		;#0x470e

00004910 <.LVL164>:
    4910:	0c 93       	cmp	#0,	r12	;r3 As==00
    4912:	f0 3b       	jl	$-30     	;abs 0x48f4

00004914 <.Loc.1016.2>:
    m = ctp->epmask & mask;
    4914:	18 4a 0a 00 	mov	10(r10),r8	;0x0000a

00004918 <.LVL165>:
    4918:	08 f6       	and	r6,	r8	;
    491a:	19 4a 0c 00 	mov	12(r10),r9	;0x0000c
    491e:	09 f7       	and	r7,	r9	;

00004920 <.L119>:
  ctp->epmask &= ~m;
    4920:	8a c8 0a 00 	bic	r8,	10(r10)	; 0x000a
    4924:	8a c9 0c 00 	bic	r9,	12(r10)	; 0x000c
    4928:	e5 3f       	jmp	$-52     	;abs 0x48f4

0000492a <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    492a:	2a 15       	pushm	#3,	r10	;16-bit words

0000492c <L0>:
    492c:	0a 4c       	mov	r12,	r10	;
    492e:	08 4d       	mov	r13,	r8	;
    4930:	09 4e       	mov	r14,	r9	;

00004932 <.Loc.187.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    4932:	b0 12 42 45 	call	#17730		;#0x4542

00004936 <.LVL12>:
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
    4936:	0d 49       	mov	r9,	r13	;
    4938:	0c 4a       	mov	r10,	r12	;
    493a:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    493e:	b0 12 9c 47 	call	#18332		;#0x479c

00004942 <.LVL13>:
    4942:	09 4c       	mov	r12,	r9	;

00004944 <.LVL14>:
  if (rdymsg == MSG_OK) {
    4944:	0c 93       	cmp	#0,	r12	;r3 As==00
    4946:	13 20       	jnz	$+40     	;abs 0x496e

00004948 <.LBB12>:
    *mbp->wrptr++ = msg;
    4948:	1d 4a 04 00 	mov	4(r10),	r13	;
    494c:	0c 4d       	mov	r13,	r12	;
    494e:	2c 53       	incd	r12		;
    4950:	8a 4c 04 00 	mov	r12,	4(r10)	;
    4954:	8d 48 00 00 	mov	r8,	0(r13)	;

00004958 <.Loc.193.1>:
    if (mbp->wrptr >= mbp->top) {
    4958:	1c 9a 02 00 	cmp	2(r10),	r12	;
    495c:	02 28       	jnc	$+6      	;abs 0x4962

0000495e <.Loc.194.1>:
      mbp->wrptr = mbp->buffer;
    495e:	aa 4a 04 00 	mov	@r10,	4(r10)	;

00004962 <.L6>:
    }
    chSemSignalI(&mbp->fullsem);
    4962:	0c 4a       	mov	r10,	r12	;
    4964:	3c 52       	add	#8,	r12	;r2 As==11
    4966:	b0 12 10 48 	call	#18448		;#0x4810

0000496a <.LVL16>:
    chSchRescheduleS();
    496a:	b0 12 de 46 	call	#18142		;#0x46de

0000496e <.L4>:
  }

  return rdymsg;
}
    496e:	0c 49       	mov	r9,	r12	;
    4970:	28 17       	popm	#3,	r10	;16-bit words
    4972:	30 41       	ret			

00004974 <chMBPost>:
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    4974:	31 80 06 00 	sub	#6,	r1	;

00004978 <.LBB18>:
  _disable_interrupts();
    4978:	32 c2       	dint			

0000497a <.Loc.348.2>:
  asm volatile("nop");
    497a:	03 43       	nop			

0000497c <.LBE18>:
  chSysLock();
    497c:	81 4c 00 00 	mov	r12,	0(r1)	;
    4980:	81 4d 04 00 	mov	r13,	4(r1)	;
    4984:	81 4e 02 00 	mov	r14,	2(r1)	;
    4988:	b0 12 5a 44 	call	#17498		;#0x445a

0000498c <.LVL19>:
  rdymsg = chMBPostS(mbp, msg, timeout);
    498c:	1e 41 02 00 	mov	2(r1),	r14	;
    4990:	1d 41 04 00 	mov	4(r1),	r13	;
    4994:	2c 41       	mov	@r1,	r12	;
    4996:	b0 12 2a 49 	call	#18730		;#0x492a

0000499a <.LVL20>:
  chSysUnlock();
    499a:	81 4c 00 00 	mov	r12,	0(r1)	;
    499e:	b0 12 78 44 	call	#17528		;#0x4478

000049a2 <.LBB20>:
  asm volatile("nop");
    49a2:	03 43       	nop			

000049a4 <.Loc.356.2>:
  _enable_interrupts();
    49a4:	32 d2       	eint			
    49a6:	03 43       	nop			

000049a8 <.LBE20>:
}
    49a8:	2c 41       	mov	@r1,	r12	;
    49aa:	31 50 06 00 	add	#6,	r1	;
    49ae:	30 41       	ret			

000049b0 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    49b0:	1a 15       	pushm	#2,	r10	;16-bit words

000049b2 <.LCFI4>:
    49b2:	0a 4c       	mov	r12,	r10	;
    49b4:	09 4d       	mov	r13,	r9	;

000049b6 <.Loc.219.1>:

  chDbgCheckClassI();
    49b6:	b0 12 26 45 	call	#17702		;#0x4526

000049ba <.LVL23>:
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    49ba:	1c 4a 0a 00 	mov	10(r10),r12	;0x0000a
    49be:	4d 43       	clr.b	r13		;
    49c0:	0d 9c       	cmp	r12,	r13	;
    49c2:	16 34       	jge	$+46     	;abs 0x49f0

000049c4 <.Loc.226.1>:
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
    49c4:	ba 53 0a 00 	add	#-1,	10(r10)	;r3 As==11, 0x000a

000049c8 <.Loc.227.1>:
  *mbp->wrptr++ = msg;
    49c8:	1e 4a 04 00 	mov	4(r10),	r14	;
    49cc:	0c 4e       	mov	r14,	r12	;
    49ce:	2c 53       	incd	r12		;
    49d0:	8a 4c 04 00 	mov	r12,	4(r10)	;
    49d4:	8e 49 00 00 	mov	r9,	0(r14)	;

000049d8 <.Loc.228.1>:
  if (mbp->wrptr >= mbp->top) {
    49d8:	1c 9a 02 00 	cmp	2(r10),	r12	;
    49dc:	02 28       	jnc	$+6      	;abs 0x49e2

000049de <.Loc.229.1>:
     mbp->wrptr = mbp->buffer;
    49de:	aa 4a 04 00 	mov	@r10,	4(r10)	;

000049e2 <.L10>:
  }
  chSemSignalI(&mbp->fullsem);
    49e2:	0c 4a       	mov	r10,	r12	;
    49e4:	3c 52       	add	#8,	r12	;r2 As==11
    49e6:	b0 12 10 48 	call	#18448		;#0x4810

000049ea <.LVL24>:

  return MSG_OK;
    49ea:	4c 43       	clr.b	r12		;

000049ec <.L8>:
}
    49ec:	19 17       	popm	#2,	r10	;16-bit words
    49ee:	30 41       	ret			

000049f0 <.L11>:
    return MSG_TIMEOUT;
    49f0:	3c 43       	mov	#-1,	r12	;r3 As==11
    49f2:	fc 3f       	jmp	$-6      	;abs 0x49ec

000049f4 <chMBFetchS>:
    49f4:	2a 15       	pushm	#3,	r10	;16-bit words

000049f6 <L0>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    49f6:	0a 4c       	mov	r12,	r10	;
    49f8:	08 4d       	mov	r13,	r8	;
    49fa:	09 4e       	mov	r14,	r9	;

000049fc <.Loc.386.1>:
  msg_t rdymsg;

  chDbgCheckClassS();
    49fc:	b0 12 42 45 	call	#17730		;#0x4542

00004a00 <.LVL40>:
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
    4a00:	0d 49       	mov	r9,	r13	;
    4a02:	0c 4a       	mov	r10,	r12	;
    4a04:	3c 52       	add	#8,	r12	;r2 As==11
    4a06:	b0 12 9c 47 	call	#18332		;#0x479c

00004a0a <.LVL41>:
    4a0a:	09 4c       	mov	r12,	r9	;

00004a0c <.LVL42>:
  if (rdymsg == MSG_OK) {
    4a0c:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a0e:	14 20       	jnz	$+42     	;abs 0x4a38

00004a10 <.LBB36>:
    *msgp = *mbp->rdptr++;
    4a10:	1d 4a 06 00 	mov	6(r10),	r13	;
    4a14:	0c 4d       	mov	r13,	r12	;
    4a16:	2c 53       	incd	r12		;
    4a18:	8a 4c 06 00 	mov	r12,	6(r10)	;
    4a1c:	a8 4d 00 00 	mov	@r13,	0(r8)	;

00004a20 <.Loc.392.1>:
    if (mbp->rdptr >= mbp->top) {
    4a20:	1c 9a 02 00 	cmp	2(r10),	r12	;
    4a24:	02 28       	jnc	$+6      	;abs 0x4a2a

00004a26 <.Loc.393.1>:
      mbp->rdptr = mbp->buffer;
    4a26:	aa 4a 06 00 	mov	@r10,	6(r10)	;

00004a2a <.L22>:
    }
    chSemSignalI(&mbp->emptysem);
    4a2a:	0c 4a       	mov	r10,	r12	;
    4a2c:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    4a30:	b0 12 10 48 	call	#18448		;#0x4810

00004a34 <.LVL44>:
    chSchRescheduleS();
    4a34:	b0 12 de 46 	call	#18142		;#0x46de

00004a38 <.L20>:
  }

  return rdymsg;
}
    4a38:	0c 49       	mov	r9,	r12	;
    4a3a:	28 17       	popm	#3,	r10	;16-bit words
    4a3c:	30 41       	ret			

00004a3e <chMBFetch>:
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    4a3e:	31 80 06 00 	sub	#6,	r1	;

00004a42 <.LBB42>:
  _disable_interrupts();
    4a42:	32 c2       	dint			

00004a44 <.Loc.348.2>:
  asm volatile("nop");
    4a44:	03 43       	nop			

00004a46 <.LBE42>:
  chSysLock();
    4a46:	81 4c 00 00 	mov	r12,	0(r1)	;
    4a4a:	81 4d 04 00 	mov	r13,	4(r1)	;
    4a4e:	81 4e 02 00 	mov	r14,	2(r1)	;
    4a52:	b0 12 5a 44 	call	#17498		;#0x445a

00004a56 <.LVL47>:
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    4a56:	1e 41 02 00 	mov	2(r1),	r14	;
    4a5a:	1d 41 04 00 	mov	4(r1),	r13	;
    4a5e:	2c 41       	mov	@r1,	r12	;
    4a60:	b0 12 f4 49 	call	#18932		;#0x49f4

00004a64 <.LVL48>:
  chSysUnlock();
    4a64:	81 4c 00 00 	mov	r12,	0(r1)	;
    4a68:	b0 12 78 44 	call	#17528		;#0x4478

00004a6c <.LBB44>:
  asm volatile("nop");
    4a6c:	03 43       	nop			

00004a6e <.Loc.356.2>:
  _enable_interrupts();
    4a6e:	32 d2       	eint			
    4a70:	03 43       	nop			

00004a72 <.LBE44>:
}
    4a72:	2c 41       	mov	@r1,	r12	;
    4a74:	31 50 06 00 	add	#6,	r1	;
    4a78:	30 41       	ret			

00004a7a <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    4a7a:	0a 15       	pushm	#1,	r10	;16-bit words

00004a7c <.LCFI0>:
    4a7c:	0a 4c       	mov	r12,	r10	;

00004a7e <.Loc.124.1>:
  void *objp;

  chDbgCheckClassI();
    4a7e:	b0 12 26 45 	call	#17702		;#0x4526

00004a82 <.LVL2>:
  chDbgCheck(mp != NULL);

  objp = mp->next;
    4a82:	2c 4a       	mov	@r10,	r12	;

00004a84 <.LVL3>:
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    4a84:	0c 93       	cmp	#0,	r12	;r3 As==00
    4a86:	04 24       	jz	$+10     	;abs 0x4a90

00004a88 <.Loc.130.1>:
    mp->next = mp->next->next;
    4a88:	aa 4c 00 00 	mov	@r12,	0(r10)	;

00004a8c <.L2>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
  }
  /*lint -restore*/

  return objp;
}
    4a8c:	0a 17       	popm	#1,	r10	;16-bit words
    4a8e:	30 41       	ret			

00004a90 <.L3>:
  else if (mp->provider != NULL) {
    4a90:	1e 4a 04 00 	mov	4(r10),	r14	;
    4a94:	0e 93       	cmp	#0,	r14	;r3 As==00
    4a96:	fa 27       	jz	$-10     	;abs 0x4a8c

00004a98 <.Loc.133.1>:
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
    4a98:	6d 43       	mov.b	#2,	r13	;r3 As==10
    4a9a:	1c 4a 02 00 	mov	2(r10),	r12	;

00004a9e <.LVL4>:
    4a9e:	8e 12       	call	r14		;

00004aa0 <.LVL5>:
  return objp;
    4aa0:	f5 3f       	jmp	$-20     	;abs 0x4a8c

00004aa2 <chPoolAlloc>:
    4aa2:	21 83       	decd	r1		;

00004aa4 <L0>:
  _disable_interrupts();
    4aa4:	32 c2       	dint			

00004aa6 <.Loc.348.2>:
  asm volatile("nop");
    4aa6:	03 43       	nop			

00004aa8 <.LBE16>:
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
  void *objp;

  chSysLock();
    4aa8:	81 4c 00 00 	mov	r12,	0(r1)	;
    4aac:	b0 12 5a 44 	call	#17498		;#0x445a

00004ab0 <.LVL7>:
  objp = chPoolAllocI(mp);
    4ab0:	2c 41       	mov	@r1,	r12	;
    4ab2:	b0 12 7a 4a 	call	#19066		;#0x4a7a

00004ab6 <.LVL8>:
  chSysUnlock();
    4ab6:	81 4c 00 00 	mov	r12,	0(r1)	;
    4aba:	b0 12 78 44 	call	#17528		;#0x4478

00004abe <.LBB18>:
  asm volatile("nop");
    4abe:	03 43       	nop			

00004ac0 <.Loc.356.2>:
  _enable_interrupts();
    4ac0:	32 d2       	eint			
    4ac2:	03 43       	nop			

00004ac4 <.LBE18>:

  return objp;
}
    4ac4:	2c 41       	mov	@r1,	r12	;
    4ac6:	21 53       	incd	r1		;
    4ac8:	30 41       	ret			

00004aca <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    4aca:	1a 15       	pushm	#2,	r10	;16-bit words

00004acc <.LCFI2>:
    4acc:	0a 4c       	mov	r12,	r10	;
    4ace:	09 4d       	mov	r13,	r9	;

00004ad0 <.LVL11>:
  struct pool_header *php = objp;

  chDbgCheckClassI();
    4ad0:	b0 12 26 45 	call	#17702		;#0x4526

00004ad4 <.LVL12>:
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
    4ad4:	a9 4a 00 00 	mov	@r10,	0(r9)	;

00004ad8 <.Loc.179.1>:
  mp->next = php;
    4ad8:	8a 49 00 00 	mov	r9,	0(r10)	;

00004adc <.Loc.180.1>:
}
    4adc:	19 17       	popm	#2,	r10	;16-bit words
    4ade:	30 41       	ret			

00004ae0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    4ae0:	1a 15       	pushm	#2,	r10	;16-bit words

00004ae2 <.LCFI3>:
    4ae2:	0a 4c       	mov	r12,	r10	;
    4ae4:	09 4d       	mov	r13,	r9	;

00004ae6 <.LBB26>:
  _disable_interrupts();
    4ae6:	32 c2       	dint			

00004ae8 <.Loc.348.2>:
  asm volatile("nop");
    4ae8:	03 43       	nop			

00004aea <.LBE26>:

  chSysLock();
    4aea:	b0 12 5a 44 	call	#17498		;#0x445a

00004aee <.LBB28>:
  chDbgCheckClassI();
    4aee:	b0 12 26 45 	call	#17702		;#0x4526

00004af2 <.LVL15>:
  php->next = mp->next;
    4af2:	a9 4a 00 00 	mov	@r10,	0(r9)	;

00004af6 <.Loc.179.1>:
  mp->next = php;
    4af6:	8a 49 00 00 	mov	r9,	0(r10)	;

00004afa <.LBE28>:
  chPoolFreeI(mp, objp);
  chSysUnlock();
    4afa:	b0 12 78 44 	call	#17528		;#0x4478

00004afe <.LBB30>:
  asm volatile("nop");
    4afe:	03 43       	nop			

00004b00 <.Loc.356.2>:
  _enable_interrupts();
    4b00:	32 d2       	eint			
    4b02:	03 43       	nop			

00004b04 <.LBE30>:
}
    4b04:	19 17       	popm	#2,	r10	;16-bit words
    4b06:	30 41       	ret			

00004b08 <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    4b08:	6a 15       	pushm	#7,	r10	;16-bit words

00004b0a <.Loc.80.1>:
  asm volatile ("mov r1, @R13");
    4b0a:	8d 41 00 00 	mov	r1,	0(r13)	;

00004b0e <.Loc.81.1>:
  asm volatile ("mov @R12, r1");
    4b0e:	21 4c       	mov	@r12,	r1	;

00004b10 <.Loc.82.1>:
  asm volatile ("popm.w #7, R10");
    4b10:	64 17       	popm	#7,	r10	;16-bit words

00004b12 <.Loc.83.1>:
  asm volatile ("ret");
    4b12:	30 41       	ret			

00004b14 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    4b14:	b0 12 78 44 	call	#17528		;#0x4478

00004b18 <.LBB4>:
  asm volatile("nop");
    4b18:	03 43       	nop			

00004b1a <.Loc.356.2>:
  _enable_interrupts();
    4b1a:	32 d2       	eint			
    4b1c:	03 43       	nop			

00004b1e <.LBE4>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    4b1e:	0c 45       	mov	r5,	r12	;

00004b20 <.Loc.101.1>:
  asm volatile ("call R4");
    4b20:	84 12       	call	r4		;

00004b22 <.Loc.107.1>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    4b22:	4c 43       	clr.b	r12		;
    4b24:	b0 12 e0 45 	call	#17888		;#0x45e0

00004b28 <.LVL2>:
#endif
}
    4b28:	30 41       	ret			

00004b2a <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    4b2a:	0e 4c       	mov	r12,	r14	;

00004b2c <.LVL1>:
  semaphore_t *sp = &tqp->sem;

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    4b2c:	2c 4c       	mov	@r12,	r12	;

00004b2e <.LVL2>:
    4b2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    4b30:	0e 34       	jge	$+30     	;abs 0x4b4e
    4b32:	3f 40 10 1c 	mov	#7184,	r15	;#0x1c10

00004b36 <.L3>:
    4b36:	0c 4f       	mov	r15,	r12	;
    4b38:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc

00004b3c <.LBB2>:
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    4b3c:	2b 4f       	mov	@r15,	r11	;
    4b3e:	3f 50 10 00 	add	#16,	r15	;#0x0010
    4b42:	0e 9b       	cmp	r11,	r14	;
    4b44:	f8 23       	jnz	$-14     	;abs 0x4b36

00004b46 <.Loc.67.1>:
        sp->cnt++;
    4b46:	9e 53 00 00 	inc	0(r14)		;

00004b4a <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    4b4a:	b0 12 10 46 	call	#17936		;#0x4610

00004b4e <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    4b4e:	30 41       	ret			

00004b50 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    4b50:	b0 12 3c 4d 	call	#19772		;#0x4d3c

00004b54 <.LVL0>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    4b54:	3c 40 8e bd 	mov	#-17010,r12	;#0xbd8e
    4b58:	b0 12 e0 4e 	call	#20192		;#0x4ee0

00004b5c <.LVL1>:
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
    4b5c:	b0 12 8e 4b 	call	#19342		;#0x4b8e

00004b60 <.LVL2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    4b60:	b0 12 0c 4c 	call	#19468		;#0x4c0c

00004b64 <.LVL3>:
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
    4b64:	b0 12 88 4c 	call	#19592		;#0x4c88

00004b68 <.LVL4>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    4b68:	b0 12 ae 5c 	call	#23726		;#0x5cae

00004b6c <.LVL5>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    4b6c:	b0 12 72 4b 	call	#19314		;#0x4b72

00004b70 <.LVL6>:
#endif
}
    4b70:	30 41       	ret			

00004b72 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    4b72:	b0 12 ae 4d 	call	#19886		;#0x4dae

00004b76 <.LVL0>:
}
    4b76:	30 41       	ret			

00004b78 <osalSysLock>:
  _disable_interrupts();
    4b78:	32 c2       	dint			

00004b7a <.Loc.348.2>:
  asm volatile("nop");
    4b7a:	03 43       	nop			

00004b7c <.LBE4>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    4b7c:	b0 12 5a 44 	call	#17498		;#0x445a

00004b80 <.LVL0>:
}
    4b80:	30 41       	ret			

00004b82 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    4b82:	b0 12 78 44 	call	#17528		;#0x4478

00004b86 <.LBB8>:
  asm volatile("nop");
    4b86:	03 43       	nop			

00004b88 <.Loc.356.2>:
  _enable_interrupts();
    4b88:	32 d2       	eint			
    4b8a:	03 43       	nop			

00004b8c <.LBE8>:
}
    4b8c:	30 41       	ret			

00004b8e <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
    4b8e:	b0 12 8c 5b 	call	#23436		;#0x5b8c

00004b92 <.LVL2>:
}
    4b92:	30 41       	ret			

00004b94 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
    4b94:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004b98 <.Loc.71.3>:
  gptp->config = NULL;
    4b98:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00004b9c <.Loc.72.3>:
}
    4b9c:	30 41       	ret			

00004b9e <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
    4b9e:	1a 15       	pushm	#2,	r10	;16-bit words

00004ba0 <.LCFI0>:
    4ba0:	0a 4c       	mov	r12,	r10	;
    4ba2:	09 4d       	mov	r13,	r9	;

00004ba4 <.Loc.86.3>:

  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
    4ba4:	b0 12 78 4b 	call	#19320		;#0x4b78

00004ba8 <.LVL5>:
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
    4ba8:	8a 49 02 00 	mov	r9,	2(r10)	;

00004bac <.Loc.90.3>:
  gpt_lld_start(gptp);
    4bac:	0c 4a       	mov	r10,	r12	;
    4bae:	b0 12 9c 5b 	call	#23452		;#0x5b9c

00004bb2 <.LVL6>:
  gptp->state = GPT_READY;
    4bb2:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004bb6 <.Loc.92.3>:
  osalSysUnlock();
    4bb6:	b0 12 82 4b 	call	#19330		;#0x4b82

00004bba <.LVL7>:
}
    4bba:	19 17       	popm	#2,	r10	;16-bit words
    4bbc:	30 41       	ret			

00004bbe <gptStartOneShotI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  time interval in ticks
 *
 * @api
 */
void gptStartOneShotI(GPTDriver *gptp, gptcnt_t interval) {
    4bbe:	21 82       	sub	#4,	r1	;r2 As==10

00004bc0 <.LCFI4>:

  osalDbgCheckClassI();
    4bc0:	81 4c 02 00 	mov	r12,	2(r1)	;
    4bc4:	81 4d 00 00 	mov	r13,	0(r1)	;
    4bc8:	b0 12 26 45 	call	#17702		;#0x4526

00004bcc <.LVL23>:
  osalDbgCheck(gptp != NULL);
  osalDbgCheck(gptp->config->callback != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_ONESHOT;
    4bcc:	1c 41 02 00 	mov	2(r1),	r12	;
    4bd0:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10

00004bd4 <.Loc.206.3>:
  gpt_lld_start_timer(gptp, interval);
    4bd4:	2d 41       	mov	@r1,	r13	;
    4bd6:	b0 12 1c 5c 	call	#23580		;#0x5c1c

00004bda <.LVL24>:
}
    4bda:	21 52       	add	#4,	r1	;r2 As==10
    4bdc:	30 41       	ret			

00004bde <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
    4bde:	21 83       	decd	r1		;

00004be0 <.LCFI6>:

  osalDbgCheckClassI();
    4be0:	81 4c 00 00 	mov	r12,	0(r1)	;
    4be4:	b0 12 26 45 	call	#17702		;#0x4526

00004be8 <.LVL30>:
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
    4be8:	2c 41       	mov	@r1,	r12	;
    4bea:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00004bee <.Loc.239.3>:
  gpt_lld_stop_timer(gptp);
    4bee:	b0 12 3e 5c 	call	#23614		;#0x5c3e

00004bf2 <.LVL31>:
}
    4bf2:	21 53       	incd	r1		;
    4bf4:	30 41       	ret			

00004bf6 <osalSysLock>:
  _disable_interrupts();
    4bf6:	32 c2       	dint			

00004bf8 <.Loc.348.2>:
  asm volatile("nop");
    4bf8:	03 43       	nop			

00004bfa <.LBE4>:
  chSysLock();
    4bfa:	b0 12 5a 44 	call	#17498		;#0x445a

00004bfe <.LVL0>:
}
    4bfe:	30 41       	ret			

00004c00 <osalSysUnlock>:
  chSysUnlock();
    4c00:	b0 12 78 44 	call	#17528		;#0x4478

00004c04 <.LBB8>:
  asm volatile("nop");
    4c04:	03 43       	nop			

00004c06 <.Loc.356.2>:
  _enable_interrupts();
    4c06:	32 d2       	eint			
    4c08:	03 43       	nop			

00004c0a <.LBE8>:
}
    4c0a:	30 41       	ret			

00004c0c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    4c0c:	b0 12 b4 53 	call	#21428		;#0x53b4

00004c10 <.LVL4>:
}
    4c10:	30 41       	ret			

00004c12 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
    4c12:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004c16 <.Loc.71.3>:
  spip->config = NULL;
    4c16:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00004c1a <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    4c1a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00004c1e <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    4c1e:	30 41       	ret			

00004c20 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    4c20:	1a 15       	pushm	#2,	r10	;16-bit words

00004c22 <.LCFI0>:
    4c22:	0a 4c       	mov	r12,	r10	;
    4c24:	09 4d       	mov	r13,	r9	;

00004c26 <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    4c26:	b0 12 f6 4b 	call	#19446		;#0x4bf6

00004c2a <.LVL7>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    4c2a:	8a 49 02 00 	mov	r9,	2(r10)	;

00004c2e <.Loc.99.3>:
  spi_lld_start(spip);
    4c2e:	0c 4a       	mov	r10,	r12	;
    4c30:	b0 12 68 54 	call	#21608		;#0x5468

00004c34 <.LVL8>:
  spip->state = SPI_READY;
    4c34:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004c38 <.Loc.101.3>:
  osalSysUnlock();
    4c38:	b0 12 00 4c 	call	#19456		;#0x4c00

00004c3c <.LVL9>:
}
    4c3c:	19 17       	popm	#2,	r10	;16-bit words
    4c3e:	30 41       	ret			

00004c40 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
    4c40:	31 80 06 00 	sub	#6,	r1	;

00004c44 <.LCFI6>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
    4c44:	81 4c 04 00 	mov	r12,	4(r1)	;
    4c48:	81 4d 02 00 	mov	r13,	2(r1)	;
    4c4c:	81 4e 00 00 	mov	r14,	0(r1)	;
    4c50:	b0 12 f6 4b 	call	#19446		;#0x4bf6

00004c54 <.LVL31>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
    4c54:	1c 41 04 00 	mov	4(r1),	r12	;
    4c58:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    4c5c:	00 00 
    4c5e:	2e 41       	mov	@r1,	r14	;
    4c60:	1d 41 02 00 	mov	2(r1),	r13	;
    4c64:	b0 12 ec 54 	call	#21740		;#0x54ec

00004c68 <.LVL32>:
  osalSysUnlock();
    4c68:	b0 12 00 4c 	call	#19456		;#0x4c00

00004c6c <.LVL33>:
}
    4c6c:	31 50 06 00 	add	#6,	r1	;
    4c70:	30 41       	ret			

00004c72 <osalSysLock>:
  _disable_interrupts();
    4c72:	32 c2       	dint			

00004c74 <.Loc.348.2>:
  asm volatile("nop");
    4c74:	03 43       	nop			

00004c76 <.LBE12>:
  chSysLock();
    4c76:	b0 12 5a 44 	call	#17498		;#0x445a

00004c7a <.LVL0>:
}
    4c7a:	30 41       	ret			

00004c7c <osalSysUnlock>:
  chSysUnlock();
    4c7c:	b0 12 78 44 	call	#17528		;#0x4478

00004c80 <.LBB16>:
  asm volatile("nop");
    4c80:	03 43       	nop			

00004c82 <.Loc.356.2>:
  _enable_interrupts();
    4c82:	32 d2       	eint			
    4c84:	03 43       	nop			

00004c86 <.LBE16>:
}
    4c86:	30 41       	ret			

00004c88 <uartInit>:
 *
 * @init
 */
void uartInit(void) {

  uart_lld_init();
    4c88:	b0 12 96 58 	call	#22678		;#0x5896

00004c8c <.LVL2>:
}
    4c8c:	30 41       	ret			

00004c8e <uartObjectInit>:
 *
 * @init
 */
void uartObjectInit(UARTDriver *uartp) {

  uartp->state      = UART_STOP;
    4c8e:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00004c92 <.Loc.71.3>:
  uartp->txstate    = UART_TX_IDLE;
    4c92:	cc 43 01 00 	mov.b	#0,	1(r12)	;r3 As==00

00004c96 <.Loc.72.3>:
  uartp->rxstate    = UART_RX_IDLE;
    4c96:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00004c9a <.Loc.73.3>:
  uartp->config     = NULL;
    4c9a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00004c9e <.Loc.75.3>:
#if UART_USE_WAIT == TRUE
  uartp->early      = false;
    4c9e:	cc 43 06 00 	mov.b	#0,	6(r12)	;r3 As==00

00004ca2 <.Loc.76.3>:
  uartp->threadrx   = NULL;
    4ca2:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00

00004ca6 <.Loc.77.3>:
  uartp->threadtx   = NULL;
    4ca6:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

00004caa <.Loc.87.3>:

  /* Optional, user-defined initializer.*/
#if defined(UART_DRIVER_EXT_INIT_HOOK)
  UART_DRIVER_EXT_INIT_HOOK(uartp);
#endif
}
    4caa:	30 41       	ret			

00004cac <uartStart>:
 * @param[in] uartp     pointer to the @p UARTDriver object
 * @param[in] config    pointer to the @p UARTConfig object
 *
 * @api
 */
void uartStart(UARTDriver *uartp, const UARTConfig *config) {
    4cac:	1a 15       	pushm	#2,	r10	;16-bit words

00004cae <.LCFI0>:
    4cae:	0a 4c       	mov	r12,	r10	;
    4cb0:	09 4d       	mov	r13,	r9	;

00004cb2 <.Loc.101.3>:

  osalDbgCheck((uartp != NULL) && (config != NULL));

  osalSysLock();
    4cb2:	b0 12 72 4c 	call	#19570		;#0x4c72

00004cb6 <.LVL5>:
  osalDbgAssert((uartp->state == UART_STOP) || (uartp->state == UART_READY),
                "invalid state");

  uartp->config = config;
    4cb6:	8a 49 04 00 	mov	r9,	4(r10)	;

00004cba <.Loc.106.3>:
  uart_lld_start(uartp);
    4cba:	0c 4a       	mov	r10,	r12	;
    4cbc:	b0 12 f2 58 	call	#22770		;#0x58f2

00004cc0 <.LVL6>:
  uartp->state = UART_READY;
    4cc0:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00004cc4 <.Loc.108.3>:
  osalSysUnlock();
    4cc4:	b0 12 7c 4c 	call	#19580		;#0x4c7c

00004cc8 <.LVL7>:
}
    4cc8:	19 17       	popm	#2,	r10	;16-bit words
    4cca:	30 41       	ret			

00004ccc <uartStartSendI>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @iclass
 */
void uartStartSendI(UARTDriver *uartp, size_t n, const void *txbuf) {
    4ccc:	0a 15       	pushm	#1,	r10	;16-bit words

00004cce <.LCFI4>:
    4cce:	21 82       	sub	#4,	r1	;r2 As==10

00004cd0 <.LCFI5>:
    4cd0:	0a 4c       	mov	r12,	r10	;

00004cd2 <.Loc.174.3>:

  osalDbgCheckClassI();
    4cd2:	81 4d 02 00 	mov	r13,	2(r1)	;
    4cd6:	81 4e 00 00 	mov	r14,	0(r1)	;
    4cda:	b0 12 26 45 	call	#17702		;#0x4526

00004cde <.LVL17>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (txbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->txstate != UART_TX_ACTIVE, "tx active");

  uart_lld_start_send(uartp, n, txbuf);
    4cde:	2e 41       	mov	@r1,	r14	;
    4ce0:	1d 41 02 00 	mov	2(r1),	r13	;
    4ce4:	0c 4a       	mov	r10,	r12	;
    4ce6:	b0 12 be 5a 	call	#23230		;#0x5abe

00004cea <.LVL18>:
  uartp->txstate = UART_TX_ACTIVE;
    4cea:	da 43 01 00 	mov.b	#1,	1(r10)	;r3 As==01

00004cee <.Loc.181.3>:
}
    4cee:	21 52       	add	#4,	r1	;r2 As==10
    4cf0:	0a 17       	popm	#1,	r10	;16-bit words
    4cf2:	30 41       	ret			

00004cf4 <uartStartReceiveI>:
 * @param[in] n         number of data frames to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @iclass
 */
void uartStartReceiveI(UARTDriver *uartp, size_t n, void *rxbuf) {
    4cf4:	0a 15       	pushm	#1,	r10	;16-bit words

00004cf6 <.LCFI11>:
    4cf6:	21 82       	sub	#4,	r1	;r2 As==10

00004cf8 <.LCFI12>:
    4cf8:	0a 4c       	mov	r12,	r10	;

00004cfa <.Loc.280.3>:

  osalDbgCheckClassI();
    4cfa:	81 4d 02 00 	mov	r13,	2(r1)	;
    4cfe:	81 4e 00 00 	mov	r14,	0(r1)	;
    4d02:	b0 12 26 45 	call	#17702		;#0x4526

00004d06 <.LVL34>:
  osalDbgCheck((uartp != NULL) && (n > 0U) && (rxbuf != NULL));
  osalDbgAssert(uartp->state == UART_READY, "is active");
  osalDbgAssert(uartp->rxstate != UART_RX_ACTIVE, "rx active");

  uart_lld_start_receive(uartp, n, rxbuf);
    4d06:	2e 41       	mov	@r1,	r14	;
    4d08:	1d 41 02 00 	mov	2(r1),	r13	;
    4d0c:	0c 4a       	mov	r10,	r12	;
    4d0e:	b0 12 08 5b 	call	#23304		;#0x5b08

00004d12 <.LVL35>:
  uartp->rxstate = UART_RX_ACTIVE;
    4d12:	da 43 02 00 	mov.b	#1,	2(r10)	;r3 As==01

00004d16 <.Loc.287.3>:
}
    4d16:	21 52       	add	#4,	r1	;r2 As==10
    4d18:	0a 17       	popm	#1,	r10	;16-bit words
    4d1a:	30 41       	ret			

00004d1c <uartStopReceiveI>:
 *                      stopped receive operation.
 * @retval 0            There was no receive operation in progress.
 *
 * @iclass
 */
size_t uartStopReceiveI(UARTDriver *uartp) {
    4d1c:	0a 15       	pushm	#1,	r10	;16-bit words

00004d1e <.LCFI15>:
    4d1e:	0a 4c       	mov	r12,	r10	;

00004d20 <.Loc.336.3>:

  osalDbgCheckClassI();
    4d20:	b0 12 26 45 	call	#17702		;#0x4526

00004d24 <.LVL42>:
  osalDbgCheck(uartp != NULL);
  osalDbgAssert(uartp->state == UART_READY, "not active");

  if (uartp->rxstate == UART_RX_ACTIVE) {
    4d24:	da 93 02 00 	cmp.b	#1,	2(r10)	;r3 As==01
    4d28:	07 20       	jnz	$+16     	;abs 0x4d38

00004d2a <.LBB27>:
    size_t n = uart_lld_stop_receive(uartp);
    4d2a:	0c 4a       	mov	r10,	r12	;
    4d2c:	b0 12 56 5b 	call	#23382		;#0x5b56

00004d30 <.LVL44>:
    uartp->rxstate = UART_RX_IDLE;
    4d30:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00

00004d34 <.L20>:
    return n;
  }
  return 0;
}
    4d34:	0a 17       	popm	#1,	r10	;16-bit words
    4d36:	30 41       	ret			

00004d38 <.L22>:
  return 0;
    4d38:	4c 43       	clr.b	r12		;
    4d3a:	fc 3f       	jmp	$-6      	;abs 0x4d34

00004d3c <hal_lld_init>:
    4d3c:	b2 40       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00004d3e <L0>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    4d3e:	80 5a 5c 01 	add	r10,	0x015c	; PC rel. 0x4e9c

00004d42 <.Loc.63.1>:
#if MSP430X_MCLK_FREQ > 8000000
  /* Init FRAM system */
  /* TODO this depends on the MCU */
  FRCTL0 = FRCTLPW | NWAITS_1;
    4d42:	b2 40 10 a5 	mov	#-23280,&0x0140	;#0xa510
    4d46:	40 01 

00004d48 <.Loc.65.1>:
  /* Lock the FRAM system */
  FRCTL0_H = 0xFF;
    4d48:	f2 43 41 01 	mov.b	#-1,	&0x0141	;r3 As==11

00004d4c <.Loc.68.1>:
#endif
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    4d4c:	b2 40 00 a5 	mov	#-23296,&0x0160	;#0xa500
    4d50:	60 01 

00004d52 <.Loc.69.1>:
  CSCTL1 = MSP430X_DCOSEL;
    4d52:	b2 40 48 00 	mov	#72,	&0x0162	;#0x0048
    4d56:	62 01 

00004d58 <.Loc.70.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    4d58:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    4d5c:	64 01 

00004d5e <.Loc.71.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    4d5e:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00004d62 <.Loc.72.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    4d62:	b2 40 c9 c1 	mov	#-15927,&0x0168	;#0xc1c9
    4d66:	68 01 

00004d68 <.Loc.74.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    4d68:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    4d6c:	6c 01 

00004d6e <.Loc.91.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    4d6e:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00004d72 <.Loc.94.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    4d72:	b0 12 7c 51 	call	#20860		;#0x517c

00004d76 <.LVL0>:
#endif
}
    4d76:	30 41       	ret			

00004d78 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    4d78:	bf 15       	pushm	#12,	r15	;16-bit words

00004d7a <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    4d7a:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    4d7e:	b0 12 d8 44 	call	#17624		;#0x44d8

00004d82 <.LBB12>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    4d82:	b0 12 98 44 	call	#17560		;#0x4498

00004d86 <.LBB14>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    4d86:	b0 12 3c 46 	call	#17980		;#0x463c

00004d8a <.LBB16>:
  chSysUnlockFromISR();
    4d8a:	b0 12 b8 44 	call	#17592		;#0x44b8

00004d8e <.LBE16>:
  
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();
  
  OSAL_IRQ_EPILOGUE();
    4d8e:	b0 12 fe 44 	call	#17662		;#0x44fe

00004d92 <.LVL4>:
    4d92:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    4d96:	b0 12 5a 44 	call	#17498		;#0x445a

00004d9a <.LVL5>:
    4d9a:	b0 12 b2 46 	call	#18098		;#0x46b2

00004d9e <.LVL6>:
    4d9e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4da0:	02 24       	jz	$+6      	;abs 0x4da6

00004da2 <.Loc.174.1>:
    4da2:	b0 12 ca 46 	call	#18122		;#0x46ca

00004da6 <.L2>:
    4da6:	b0 12 78 44 	call	#17528		;#0x4478

00004daa <.LVL8>:
}
    4daa:	b4 17       	popm	#12,	r15	;16-bit words
    4dac:	00 13       	reti			

00004dae <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    4dae:	b2 40 7f 3e 	mov	#15999,	&0x03d2	;#0x3e7f
    4db2:	d2 03 

00004db4 <.Loc.198.1>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    4db4:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    4db8:	c2 03 

00004dba <.Loc.199.1>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    4dba:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00004dbe <.Loc.200.1>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    4dbe:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    4dc2:	c0 03 

00004dc4 <.Loc.202.1>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    4dc4:	30 41       	ret			

00004dc6 <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    4dc6:	bf 15       	pushm	#12,	r15	;16-bit words

00004dc8 <.LCFI0>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4dc8:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    4dcc:	b0 12 d8 44 	call	#17624		;#0x44d8

00004dd0 <.LVL0>:
  pad = (P1IV >> 1) - 1;
    4dd0:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e

00004dd4 <.LVL1>:
    4dd4:	12 c3       	clrc			
    4dd6:	0c 10       	rrc	r12		;

00004dd8 <.LVL2>:
    4dd8:	7c 53       	add.b	#-1,	r12	;r3 As==11

00004dda <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    4dda:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    4dde:	0c 5c       	rla	r12		;
    4de0:	1c 4c 5e 1c 	mov	7262(r12),r12	;0x01c5e

00004de4 <.LVL3>:
  if (cb != NULL) {
    4de4:	0c 93       	cmp	#0,	r12	;r3 As==00
    4de6:	01 24       	jz	$+4      	;abs 0x4dea

00004de8 <.Loc.81.1>:
    (*cb)();
    4de8:	8c 12       	call	r12		;

00004dea <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4dea:	b0 12 fe 44 	call	#17662		;#0x44fe

00004dee <.LVL5>:
    4dee:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    4df2:	b0 12 5a 44 	call	#17498		;#0x445a

00004df6 <.LVL6>:
    4df6:	b0 12 b2 46 	call	#18098		;#0x46b2

00004dfa <.LVL7>:
    4dfa:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4dfc:	02 24       	jz	$+6      	;abs 0x4e02

00004dfe <.Loc.84.1>:
    4dfe:	b0 12 ca 46 	call	#18122		;#0x46ca

00004e02 <.L3>:
    4e02:	b0 12 78 44 	call	#17528		;#0x4478

00004e06 <.LVL9>:
}
    4e06:	b4 17       	popm	#12,	r15	;16-bit words
    4e08:	00 13       	reti			

00004e0a <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    4e0a:	bf 15       	pushm	#12,	r15	;16-bit words

00004e0c <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e0c:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    4e10:	b0 12 d8 44 	call	#17624		;#0x44d8

00004e14 <.LVL10>:
  pad = (P2IV >> 1) - 1;
    4e14:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e

00004e18 <.LVL11>:
    4e18:	12 c3       	clrc			
    4e1a:	0c 10       	rrc	r12		;

00004e1c <.LVL12>:
    4e1c:	7c 53       	add.b	#-1,	r12	;r3 As==11

00004e1e <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    4e1e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    4e22:	3c 52       	add	#8,	r12	;r2 As==11
    4e24:	0c 5c       	rla	r12		;
    4e26:	1c 4c 5e 1c 	mov	7262(r12),r12	;0x01c5e

00004e2a <.LVL13>:
  if (cb != NULL) {
    4e2a:	0c 93       	cmp	#0,	r12	;r3 As==00
    4e2c:	01 24       	jz	$+4      	;abs 0x4e30

00004e2e <.Loc.99.1>:
    (*cb)();
    4e2e:	8c 12       	call	r12		;

00004e30 <.L11>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4e30:	b0 12 fe 44 	call	#17662		;#0x44fe

00004e34 <.LVL15>:
    4e34:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    4e38:	b0 12 5a 44 	call	#17498		;#0x445a

00004e3c <.LVL16>:
    4e3c:	b0 12 b2 46 	call	#18098		;#0x46b2

00004e40 <.LVL17>:
    4e40:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4e42:	02 24       	jz	$+6      	;abs 0x4e48

00004e44 <.Loc.102.1>:
    4e44:	b0 12 ca 46 	call	#18122		;#0x46ca

00004e48 <.L12>:
    4e48:	b0 12 78 44 	call	#17528		;#0x4478

00004e4c <.LVL19>:
}
    4e4c:	b4 17       	popm	#12,	r15	;16-bit words
    4e4e:	00 13       	reti			

00004e50 <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    4e50:	bf 15       	pushm	#12,	r15	;16-bit words

00004e52 <.LCFI2>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e52:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    4e56:	b0 12 d8 44 	call	#17624		;#0x44d8

00004e5a <.LVL20>:
  pad = (P3IV >> 1) - 1;
    4e5a:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e

00004e5e <.LVL21>:
    4e5e:	12 c3       	clrc			
    4e60:	0c 10       	rrc	r12		;

00004e62 <.LVL22>:
    4e62:	7c 53       	add.b	#-1,	r12	;r3 As==11

00004e64 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    4e64:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    4e68:	3c 50 10 00 	add	#16,	r12	;#0x0010
    4e6c:	0c 5c       	rla	r12		;
    4e6e:	1c 4c 5e 1c 	mov	7262(r12),r12	;0x01c5e

00004e72 <.LVL23>:
  if (cb != NULL) {
    4e72:	0c 93       	cmp	#0,	r12	;r3 As==00
    4e74:	01 24       	jz	$+4      	;abs 0x4e78

00004e76 <.Loc.118.1>:
    (*cb)();
    4e76:	8c 12       	call	r12		;

00004e78 <.L20>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4e78:	b0 12 fe 44 	call	#17662		;#0x44fe

00004e7c <.LVL25>:
    4e7c:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    4e80:	b0 12 5a 44 	call	#17498		;#0x445a

00004e84 <.LVL26>:
    4e84:	b0 12 b2 46 	call	#18098		;#0x46b2

00004e88 <.LVL27>:
    4e88:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4e8a:	02 24       	jz	$+6      	;abs 0x4e90

00004e8c <.Loc.121.1>:
    4e8c:	b0 12 ca 46 	call	#18122		;#0x46ca

00004e90 <.L21>:
    4e90:	b0 12 78 44 	call	#17528		;#0x4478

00004e94 <.LVL29>:
}
    4e94:	b4 17       	popm	#12,	r15	;16-bit words
    4e96:	00 13       	reti			

00004e98 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    4e98:	bf 15       	pushm	#12,	r15	;16-bit words

00004e9a <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    4e9a:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    4e9e:	b0 12 d8 44 	call	#17624		;#0x44d8

00004ea2 <.LVL30>:
  pad = (P4IV >> 1) - 1;
    4ea2:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e

00004ea6 <.LVL31>:
    4ea6:	12 c3       	clrc			
    4ea8:	0c 10       	rrc	r12		;

00004eaa <.LVL32>:
    4eaa:	7c 53       	add.b	#-1,	r12	;r3 As==11

00004eac <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    4eac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    4eb0:	3c 50 18 00 	add	#24,	r12	;#0x0018
    4eb4:	0c 5c       	rla	r12		;
    4eb6:	1c 4c 5e 1c 	mov	7262(r12),r12	;0x01c5e

00004eba <.LVL33>:
  if (cb != NULL) {
    4eba:	0c 93       	cmp	#0,	r12	;r3 As==00
    4ebc:	01 24       	jz	$+4      	;abs 0x4ec0

00004ebe <.Loc.136.1>:
    (*cb)();
    4ebe:	8c 12       	call	r12		;

00004ec0 <.L29>:
  }
  
  OSAL_IRQ_EPILOGUE();
    4ec0:	b0 12 fe 44 	call	#17662		;#0x44fe

00004ec4 <.LVL35>:
    4ec4:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    4ec8:	b0 12 5a 44 	call	#17498		;#0x445a

00004ecc <.LVL36>:
    4ecc:	b0 12 b2 46 	call	#18098		;#0x46b2

00004ed0 <.LVL37>:
    4ed0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    4ed2:	02 24       	jz	$+6      	;abs 0x4ed8

00004ed4 <.Loc.139.1>:
    4ed4:	b0 12 ca 46 	call	#18122		;#0x46ca

00004ed8 <.L30>:
    4ed8:	b0 12 78 44 	call	#17528		;#0x4478

00004edc <.LVL39>:
}
    4edc:	b4 17       	popm	#12,	r15	;16-bit words
    4ede:	00 13       	reti			

00004ee0 <_pal_lld_init>:
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  PAOUT = config->porta.out;
    4ee0:	a2 4c 02 02 	mov	@r12,	&0x0202	;

00004ee4 <.Loc.310.1>:
  PADIR = config->porta.dir;
    4ee4:	92 4c 02 00 	mov	2(r12),	&0x0204	;
    4ee8:	04 02 

00004eea <.Loc.311.1>:
  PAREN = config->porta.ren;
    4eea:	92 4c 04 00 	mov	4(r12),	&0x0206	;
    4eee:	06 02 

00004ef0 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    4ef0:	92 4c 06 00 	mov	6(r12),	&0x020a	;
    4ef4:	0a 02 

00004ef6 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    4ef6:	92 4c 08 00 	mov	8(r12),	&0x020c	;
    4efa:	0c 02 

00004efc <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    4efc:	92 4c 0a 00 	mov	10(r12),&0x0222	;0x0000a
    4f00:	22 02 

00004f02 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    4f02:	92 4c 0c 00 	mov	12(r12),&0x0224	;0x0000c
    4f06:	24 02 

00004f08 <.Loc.317.1>:
  PBREN = config->portb.ren;
    4f08:	92 4c 0e 00 	mov	14(r12),&0x0226	;0x0000e
    4f0c:	26 02 

00004f0e <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    4f0e:	92 4c 10 00 	mov	16(r12),&0x022a	;0x00010
    4f12:	2a 02 

00004f14 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    4f14:	92 4c 12 00 	mov	18(r12),&0x022c	;0x00012
    4f18:	2c 02 

00004f1a <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    4f1a:	92 4c 14 00 	mov	20(r12),&0x0322	;0x00014
    4f1e:	22 03 

00004f20 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    4f20:	92 4c 16 00 	mov	22(r12),&0x0324	;0x00016
    4f24:	24 03 

00004f26 <.Loc.351.1>:
  PJREN = config->portj.ren;
    4f26:	92 4c 18 00 	mov	24(r12),&0x0326	;0x00018
    4f2a:	26 03 

00004f2c <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    4f2c:	92 4c 1a 00 	mov	26(r12),&0x032a	;0x0001a
    4f30:	2a 03 

00004f32 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    4f32:	92 4c 1c 00 	mov	28(r12),&0x032c	;0x0001c
    4f36:	2c 03 

00004f38 <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    4f38:	92 c3 30 01 	bic	#1,	&0x0130	;r3 As==01

00004f3c <.Loc.356.1>:
}
    4f3c:	30 41       	ret			

00004f3e <_pal_lld_setgroupmode>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    4f3e:	2e 92       	cmp	#4,	r14	;r2 As==10
    4f40:	4a 24       	jz	$+150    	;abs 0x4fd6
    4f42:	6f 42       	mov.b	#4,	r15	;r2 As==10
    4f44:	0f 9e       	cmp	r14,	r15	;
    4f46:	0a 28       	jnc	$+22     	;abs 0x4f5c
    4f48:	1e 93       	cmp	#1,	r14	;r3 As==01
    4f4a:	3c 24       	jz	$+122    	;abs 0x4fc4
    4f4c:	0e 93       	cmp	#0,	r14	;r3 As==00
    4f4e:	2b 24       	jz	$+88     	;abs 0x4fa6
    4f50:	2e 93       	cmp	#2,	r14	;r3 As==10
    4f52:	29 24       	jz	$+84     	;abs 0x4fa6
    4f54:	3e 90 03 00 	cmp	#3,	r14	;
    4f58:	35 24       	jz	$+108    	;abs 0x4fc4

00004f5a <.L38>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    4f5a:	30 41       	ret			

00004f5c <.L41>:
  switch (mode) {
    4f5c:	3e 92       	cmp	#8,	r14	;r2 As==11
    4f5e:	49 24       	jz	$+148    	;abs 0x4ff2
    4f60:	7f 42       	mov.b	#8,	r15	;r2 As==11
    4f62:	0f 9e       	cmp	r14,	r15	;
    4f64:	11 28       	jnc	$+36     	;abs 0x4f88
    4f66:	3e 90 06 00 	cmp	#6,	r14	;
    4f6a:	f7 23       	jnz	$-16     	;abs 0x4f5a

00004f6c <.Loc.410.1>:
      port->dir |= mask;
    4f6c:	8c dd 04 00 	bis	r13,	4(r12)	;

00004f70 <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    4f70:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    4f74:	03 24       	jz	$+8      	;abs 0x4f7c

00004f76 <.Loc.411.1>:
    4f76:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    4f7a:	21 20       	jnz	$+68     	;abs 0x4fbe

00004f7c <.L52>:
        port->sel0 &= ~mask;
    4f7c:	3d e3       	inv	r13		;

00004f7e <.LVL44>:
    4f7e:	8c fd 0a 00 	and	r13,	10(r12)	; 0x000a

00004f82 <.Loc.415.1>:
        port->sel1 &= ~mask;
    4f82:	8c fd 0c 00 	and	r13,	12(r12)	; 0x000c
    4f86:	e9 3f       	jmp	$-44     	;abs 0x4f5a

00004f88 <.L45>:
  switch (mode) {
    4f88:	3e 90 09 00 	cmp	#9,	r14	;
    4f8c:	3d 24       	jz	$+124    	;abs 0x5008
    4f8e:	3e 90 0a 00 	cmp	#10,	r14	;#0x000a
    4f92:	e3 23       	jnz	$-56     	;abs 0x4f5a

00004f94 <.Loc.435.1>:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    4f94:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    4f98:	03 20       	jnz	$+8      	;abs 0x4fa0

00004f9a <.Loc.435.1>:
    4f9a:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    4f9e:	0f 24       	jz	$+32     	;abs 0x4fbe

00004fa0 <.L55>:
        port->sel0 |= mask;
    4fa0:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a
    4fa4:	39 3c       	jmp	$+116    	;abs 0x5018

00004fa6 <.L43>:
      port->dir &= ~mask;
    4fa6:	0e 4d       	mov	r13,	r14	;

00004fa8 <.LVL46>:
    4fa8:	3e e3       	inv	r14		;
    4faa:	8c fe 04 00 	and	r14,	4(r12)	;

00004fae <.Loc.378.1>:
      port->ren &= ~mask;
    4fae:	8c fe 08 00 	and	r14,	8(r12)	;

00004fb2 <.L105>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    4fb2:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    4fb6:	18 24       	jz	$+50     	;abs 0x4fe8

00004fb8 <.Loc.402.1>:
    4fb8:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    4fbc:	15 24       	jz	$+44     	;abs 0x4fe8

00004fbe <.L99>:
        port->selc = mask;
    4fbe:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016
    4fc2:	cb 3f       	jmp	$-104    	;abs 0x4f5a

00004fc4 <.L42>:
      port->dir &= ~mask;
    4fc4:	0e 4d       	mov	r13,	r14	;

00004fc6 <.LVL48>:
    4fc6:	3e e3       	inv	r14		;
    4fc8:	8c fe 04 00 	and	r14,	4(r12)	;

00004fcc <.Loc.389.1>:
      port->ren |= mask;
    4fcc:	8c dd 08 00 	bis	r13,	8(r12)	;

00004fd0 <.Loc.390.1>:
      port->out |= mask;
    4fd0:	8c dd 02 00 	bis	r13,	2(r12)	;
    4fd4:	ee 3f       	jmp	$-34     	;abs 0x4fb2

00004fd6 <.L40>:
      port->dir &= ~mask;
    4fd6:	0e 4d       	mov	r13,	r14	;

00004fd8 <.LVL50>:
    4fd8:	3e e3       	inv	r14		;
    4fda:	8c fe 04 00 	and	r14,	4(r12)	;

00004fde <.Loc.400.1>:
      port->ren |= mask;
    4fde:	8c dd 08 00 	bis	r13,	8(r12)	;

00004fe2 <.Loc.401.1>:
      port->out &= ~mask;
    4fe2:	8c fe 02 00 	and	r14,	2(r12)	;
    4fe6:	e5 3f       	jmp	$-52     	;abs 0x4fb2

00004fe8 <.L51>:
        port->sel0 &= ~mask;
    4fe8:	8c fe 0a 00 	and	r14,	10(r12)	; 0x000a

00004fec <.Loc.406.1>:
        port->sel1 &= ~mask;
    4fec:	8c fe 0c 00 	and	r14,	12(r12)	; 0x000c
    4ff0:	b4 3f       	jmp	$-150    	;abs 0x4f5a

00004ff2 <.L44>:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    4ff2:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    4ff6:	03 20       	jnz	$+8      	;abs 0x4ffe

00004ff8 <.Loc.419.1>:
    4ff8:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    4ffc:	e0 23       	jnz	$-62     	;abs 0x4fbe

00004ffe <.L53>:
        port->sel0 |= mask;
    4ffe:	8c dd 0a 00 	bis	r13,	10(r12)	; 0x000a

00005002 <.Loc.423.1>:
        port->sel1 &= ~mask;
    5002:	8c cd 0c 00 	bic	r13,	12(r12)	; 0x000c
    5006:	a9 3f       	jmp	$-172    	;abs 0x4f5a

00005008 <.L47>:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    5008:	1d bc 0a 00 	bit	10(r12),r13	;0x0000a
    500c:	03 24       	jz	$+8      	;abs 0x5014

0000500e <.Loc.427.1>:
    500e:	1d bc 0c 00 	bit	12(r12),r13	;0x0000c
    5012:	d5 27       	jz	$-84     	;abs 0x4fbe

00005014 <.L54>:
        port->sel0 &= ~mask;
    5014:	8c cd 0a 00 	bic	r13,	10(r12)	; 0x000a

00005018 <.L98>:
        port->sel1 |= mask;
    5018:	8c dd 0c 00 	bis	r13,	12(r12)	; 0x000c

0000501c <.Loc.443.1>:
}
    501c:	9e 3f       	jmp	$-194    	;abs 0x4f5a

0000501e <_pal_lld_enablepadevent>:
    501e:	2a 15       	pushm	#3,	r10	;16-bit words

00005020 <.LCFI4>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    5020:	0a 4c       	mov	r12,	r10	;
    5022:	49 4d       	mov.b	r13,	r9	;
    5024:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

00005028 <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5028:	43 18 0c 11 	rpt #4 { rrax.w	r12		;

0000502c <.LVL53>:
    502c:	4d 4c       	mov.b	r12,	r13	;

0000502e <L0>:
    502e:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    5032:	7c 40 07 00 	mov.b	#7,	r12	;
    5036:	4c 99       	cmp.b	r9,	r12	;
    5038:	25 28       	jnc	$+76     	;abs 0x5084
    503a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000503c <.L108>:
    503c:	4c 5d       	add.b	r13,	r12	;

0000503e <.LVL56>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    503e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    5042:	3c 53       	add	#-1,	r12	;r3 As==11
    5044:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    5048:	0d 49       	mov	r9,	r13	;
    504a:	7d f0 07 00 	and.b	#7,	r13	;
    504e:	0c 5d       	add	r13,	r12	;
    5050:	0c 5c       	rla	r12		;
    5052:	8c 4f 5e 1c 	mov	r15,	7262(r12); 0x1c5e

00005056 <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    5056:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    5058:	17 20       	jnz	$+48     	;abs 0x5088

0000505a <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    505a:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    505e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5060:	0d 49       	mov	r9,	r13	;
    5062:	b0 12 94 af 	call	#-20588	;#0xaf94

00005066 <.LVL57>:
    5066:	08 cc       	bic	r12,	r8	;
    5068:	8a 48 18 00 	mov	r8,	24(r10)	; 0x0018

0000506c <.L110>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    506c:	18 4a 1c 00 	mov	28(r10),r8	;0x0001c
    5070:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5072:	0d 49       	mov	r9,	r13	;
    5074:	b0 12 94 af 	call	#-20588	;#0xaf94
    5078:	08 cc       	bic	r12,	r8	;
    507a:	8a 48 1c 00 	mov	r8,	28(r10)	; 0x001c

0000507e <.Loc.464.1>:
    port->ie |= (1 << pad);
    507e:	8a dc 1a 00 	bis	r12,	26(r10)	; 0x001a

00005082 <.Loc.466.1>:
  }
}
    5082:	19 3c       	jmp	$+52     	;abs 0x50b6

00005084 <.L113>:
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    5084:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5086:	da 3f       	jmp	$-74     	;abs 0x503c

00005088 <.L109>:
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    5088:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    508a:	0a 20       	jnz	$+22     	;abs 0x50a0

0000508c <.Loc.456.1>:
    port->ies |= (1 << pad);
    508c:	18 4a 18 00 	mov	24(r10),r8	;0x00018
    5090:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5092:	0d 49       	mov	r9,	r13	;
    5094:	b0 12 94 af 	call	#-20588	;#0xaf94

00005098 <.LVL60>:
    5098:	0c d8       	bis	r8,	r12	;
    509a:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018
    509e:	e6 3f       	jmp	$-50     	;abs 0x506c

000050a0 <.L111>:
  if (mode == PAL_EVENT_MODE_DISABLED) {
    50a0:	0e 93       	cmp	#0,	r14	;r3 As==00
    50a2:	e4 23       	jnz	$-54     	;abs 0x506c

000050a4 <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    50a4:	18 4a 1a 00 	mov	26(r10),r8	;0x0001a
    50a8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    50aa:	0d 49       	mov	r9,	r13	;
    50ac:	b0 12 94 af 	call	#-20588	;#0xaf94

000050b0 <.LVL62>:
    50b0:	08 cc       	bic	r12,	r8	;
    50b2:	8a 48 1a 00 	mov	r8,	26(r10)	; 0x001a

000050b6 <.L107>:
}
    50b6:	28 17       	popm	#3,	r10	;16-bit words
    50b8:	30 41       	ret			

000050ba <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    50ba:	1a 15       	pushm	#2,	r10	;16-bit words

000050bc <.LCFI5>:
    50bc:	0a 4c       	mov	r12,	r10	;

000050be <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    50be:	19 4c       	mov,		r9	;Warning: disassembly unreliable - not enough bytes available

000050c0 <L0>:
    50c0:	1a 00       	mova	@r0+,	r10	;
    50c2:	5c 43       	mov.b	#1,	r12	;r3 As==01

000050c4 <.LVL64>:
    50c4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    50c8:	b0 12 94 af 	call	#-20588	;#0xaf94

000050cc <.LVL65>:
    50cc:	09 cc       	bic	r12,	r9	;
    50ce:	8a 49 1a 00 	mov	r9,	26(r10)	; 0x001a

000050d2 <.Loc.471.1>:
}
    50d2:	19 17       	popm	#2,	r10	;16-bit words
    50d4:	30 41       	ret			

000050d6 <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    50d6:	3a 15       	pushm	#4,	r10	;16-bit words

000050d8 <.LCFI0>:
    50d8:	4a 4c       	mov.b	r12,	r10	;
    50da:	47 4d       	mov.b	r13,	r7	;

000050dc <.Loc.62.1>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    50dc:	09 4a       	mov	r10,	r9	;
    50de:	79 f0 fe 00 	and.b	#254,	r9	;#0x00fe
    50e2:	39 50 00 05 	add	#1280,	r9	;#0x0500

000050e6 <.Loc.63.1>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    50e6:	5a f3       	and.b	#1,	r10	;r3 As==01
    50e8:	42 18 0a 5a 	rpt #3 { rlax.w	r10		;
    50ec:	3c 40 00 ff 	mov	#-256,	r12	;#0xff00

000050f0 <.LVL2>:
    50f0:	0d 4a       	mov	r10,	r13	;

000050f2 <.LVL3>:
    50f2:	b0 12 28 b0 	call	#-20440	;#0xb028
    50f6:	08 4c       	mov	r12,	r8	;
    50f8:	28 f9       	and	@r9,	r8	;

000050fa <.Loc.64.1>:
  *ctl |= trigger << (8 * (index % 2));
    50fa:	0c 47       	mov	r7,	r12	;
    50fc:	0d 4a       	mov	r10,	r13	;
    50fe:	b0 12 94 af 	call	#-20588	;#0xaf94
    5102:	08 dc       	bis	r12,	r8	;
    5104:	89 48 00 00 	mov	r8,	0(r9)	;

00005108 <.Loc.65.1>:
}
    5108:	37 17       	popm	#4,	r10	;16-bit words
    510a:	30 41       	ret			

0000510c <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    510c:	bf 15       	pushm	#12,	r15	;16-bit words

0000510e <.LCFI1>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    510e:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    5112:	b0 12 d8 44 	call	#17624		;#0x44d8

00005116 <.LVL6>:

  index = (DMAIV >> 1) - 1;
    5116:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    511a:	12 c3       	clrc			
    511c:	0c 10       	rrc	r12		;
    511e:	7c 53       	add.b	#-1,	r12	;r3 As==11
    5120:	4a 4c       	mov.b	r12,	r10	;

00005122 <.LVL7>:

  if (index < MSP430X_DMA_CHANNELS) {
    5122:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5124:	4d 9c       	cmp.b	r12,	r13	;
    5126:	1a 28       	jnc	$+54     	;abs 0x515c

00005128 <.LBB10>:
    /* Set to idle mode (but still claimed) */
    dma_regs[index].ctl &= ~DMAEN;
    5128:	09 4a       	mov	r10,	r9	;
    512a:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    512e:	39 50 10 05 	add	#1296,	r9	;#0x0510
    5132:	b9 f0 ef ff 	and	#-17,	0(r9)	;#0xffef
    5136:	00 00 

00005138 <.Loc.80.1>:
    dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    5138:	4d 43       	clr.b	r13		;
    513a:	b0 12 d6 50 	call	#20694		;#0x50d6

0000513e <.LVL8>:
    dma_regs[index].sz  = 0;
    513e:	89 43 0a 00 	mov	#0,	10(r9)	;r3 As==00, 0x000a

00005142 <.Loc.82.1>:
    dma_regs[index].ctl = DMAEN | DMAABORT;
    5142:	b9 40 12 00 	mov	#18,	0(r9)	;#0x0012
    5146:	00 00 

00005148 <.LVL9>:

    msp430x_dma_cb_t * cb = &callbacks[index];

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    5148:	41 18 0a 5a 	rpt #2 { rlax.w	r10		;

0000514c <.LVL10>:
    514c:	3a 50 1e cd 	add	#-13026,r10	;#0xcd1e

00005150 <.LVL11>:
    5150:	2d 4a       	mov	@r10,	r13	;
    5152:	0d 93       	cmp	#0,	r13	;r3 As==00
    5154:	03 24       	jz	$+8      	;abs 0x515c

00005156 <.Loc.88.1>:
      cb->callback(cb->args);
    5156:	1c 4a 02 00 	mov	2(r10),	r12	;
    515a:	8d 12       	call	r13		;

0000515c <.L4>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    515c:	b0 12 fe 44 	call	#17662		;#0x44fe

00005160 <.LVL13>:
    5160:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    5164:	b0 12 5a 44 	call	#17498		;#0x445a

00005168 <.LVL14>:
    5168:	b0 12 b2 46 	call	#18098		;#0x46b2

0000516c <.LVL15>:
    516c:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    516e:	02 24       	jz	$+6      	;abs 0x5174

00005170 <.Loc.92.1>:
    5170:	b0 12 ca 46 	call	#18122		;#0x46ca

00005174 <.L6>:
    5174:	b0 12 78 44 	call	#17528		;#0x4478

00005178 <.LVL17>:
}
    5178:	b4 17       	popm	#12,	r15	;16-bit words
    517a:	00 13       	reti			

0000517c <dmaInit>:
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    517c:	82 43 1c cd 	mov	#0,	&0xcd1c	;r3 As==00

00005180 <.LBE11>:
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
}
    5180:	30 41       	ret			

00005182 <dmaAcquireI>:
 * @retval false          no error, channel acquired.
 * @retval true           error, channel already acquired.
 * 
 * @iclass
 */
msg_t dmaAcquireI(msp430x_dma_ch_t * channel) {
    5182:	2a 15       	pushm	#3,	r10	;16-bit words

00005184 <.LCFI2>:
    5184:	09 4c       	mov	r12,	r9	;

00005186 <.Loc.188.1>:
  
  osalDbgCheckClassI();
    5186:	b0 12 26 45 	call	#17702		;#0x4526

0000518a <.LVL21>:

  /* Grab the correct DMA channel to use */
  int i = 0;
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    if (!(dma_regs[i].ctl & DMAEN)) {
    518a:	1a 42 10 05 	mov	&0x0510,r10	;0x0510
    518e:	7a f0 10 00 	and.b	#16,	r10	;#0x0010
    5192:	0a 93       	cmp	#0,	r10	;r3 As==00
    5194:	0e 24       	jz	$+30     	;abs 0x51b2

00005196 <.LVL22>:
    5196:	3c 40 20 05 	mov	#1312,	r12	;#0x0520
    519a:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    519e:	00 00 
    51a0:	07 24       	jz	$+16     	;abs 0x51b0

000051a2 <.LVL23>:
    51a2:	bc b0 10 00 	bit	#16,	16(r12)	;#0x0010, 0x0010
    51a6:	10 00 
    51a8:	18 24       	jz	$+50     	;abs 0x51da

000051aa <.Loc.199.1>:
      break;
    }
  }
  
  if (i >= MSP430X_DMA_CHANNELS)  {
    return MSG_TIMEOUT;
    51aa:	3c 43       	mov	#-1,	r12	;r3 As==11

000051ac <.L14>:

  channel->registers = dma_regs + i;
  channel->index     = i;
  
  return MSG_OK;
}
    51ac:	28 17       	popm	#3,	r10	;16-bit words
    51ae:	30 41       	ret			

000051b0 <.L18>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    51b0:	5a 43       	mov.b	#1,	r10	;r3 As==01

000051b2 <.L15>:
  dma_trigger_set(i, DMA_TRIGGER_MNEM(DMAREQ));
    51b2:	48 4a       	mov.b	r10,	r8	;
    51b4:	4d 43       	clr.b	r13		;
    51b6:	4c 48       	mov.b	r8,	r12	;
    51b8:	b0 12 d6 50 	call	#20694		;#0x50d6

000051bc <.LVL27>:
  dma_regs[i].sz  = 0;
    51bc:	43 18 0a 5a 	rpt #4 { rlax.w	r10		;
    51c0:	3a 50 10 05 	add	#1296,	r10	;#0x0510
    51c4:	8a 43 0a 00 	mov	#0,	10(r10)	;r3 As==00, 0x000a

000051c8 <.Loc.205.1>:
  dma_regs[i].ctl = DMAEN | DMAABORT;
    51c8:	ba 40 12 00 	mov	#18,	0(r10)	;#0x0012
    51cc:	00 00 

000051ce <.Loc.207.1>:
  channel->registers = dma_regs + i;
    51ce:	89 4a 00 00 	mov	r10,	0(r9)	;

000051d2 <.Loc.208.1>:
  channel->index     = i;
    51d2:	c9 48 02 00 	mov.b	r8,	2(r9)	;

000051d6 <.Loc.210.1>:
  return MSG_OK;
    51d6:	4c 43       	clr.b	r12		;
    51d8:	e9 3f       	jmp	$-44     	;abs 0x51ac

000051da <.L19>:
  for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    51da:	6a 43       	mov.b	#2,	r10	;r3 As==10
    51dc:	ea 3f       	jmp	$-42     	;abs 0x51b2

000051de <dmaClaimI>:
    51de:	3a 15       	pushm	#4,	r10	;16-bit words

000051e0 <.LCFI4>:
 * @retval false          no error, channel claimed.
 * @retval true           error, channel in use.
 * 
 * @iclass
 */
msg_t dmaClaimI(msp430x_dma_ch_t * channel, uint8_t index) {
    51e0:	07 4c       	mov	r12,	r7	;

000051e2 <L0>:
    51e2:	48 4d       	mov.b	r13,	r8	;

000051e4 <.Loc.229.1>:
  
  osalDbgCheckClassI();
    51e4:	b0 12 26 45 	call	#17702		;#0x4526

000051e8 <.LVL38>:

  /* Is the channel already acquired? */
  osalDbgAssert(index < MSP430X_DMA_CHANNELS, "invalid channel index");
  if (dma_regs[index].ctl & DMAEN) {
    51e8:	09 48       	mov	r8,	r9	;
    51ea:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    51ee:	39 50 10 05 	add	#1296,	r9	;#0x0510
    51f2:	2a 49       	mov	@r9,	r10	;
    51f4:	7a f0 10 00 	and.b	#16,	r10	;#0x0010
    51f8:	0a 93       	cmp	#0,	r10	;r3 As==00
    51fa:	10 20       	jnz	$+34     	;abs 0x521c

000051fc <.Loc.238.1>:
    return MSG_TIMEOUT;
  }

  /* Acquire the channel in an idle mode */
  dma_trigger_set(index, DMA_TRIGGER_MNEM(DMAREQ));
    51fc:	4d 4a       	mov.b	r10,	r13	;
    51fe:	4c 48       	mov.b	r8,	r12	;
    5200:	b0 12 d6 50 	call	#20694		;#0x50d6

00005204 <.LVL39>:
  dma_regs[index].sz  = 0;
    5204:	89 4a 0a 00 	mov	r10,	10(r9)	; 0x000a

00005208 <.Loc.240.1>:
  dma_regs[index].ctl = DMAEN | DMAABORT;
    5208:	b9 40 12 00 	mov	#18,	0(r9)	;#0x0012
    520c:	00 00 

0000520e <.Loc.242.1>:

  channel->registers = dma_regs + index;
    520e:	87 49 00 00 	mov	r9,	0(r7)	;

00005212 <.Loc.243.1>:
  channel->index     = index;
    5212:	c7 48 02 00 	mov.b	r8,	2(r7)	;

00005216 <.Loc.245.1>:
  
  return MSG_OK;
    5216:	0c 4a       	mov	r10,	r12	;

00005218 <.L26>:
}
    5218:	37 17       	popm	#4,	r10	;16-bit words
    521a:	30 41       	ret			

0000521c <.L28>:
    return MSG_TIMEOUT;
    521c:	3c 43       	mov	#-1,	r12	;r3 As==11
    521e:	fc 3f       	jmp	$-6      	;abs 0x5218

00005220 <dmaTransferI>:
    5220:	1a 15       	pushm	#2,	r10	;16-bit words

00005222 <L0>:
 * @param[in] channel   pointer to a DMA channel from @p dmaAcquire().
 * @param[in] request   pointer to a DMA request object.
 * 
 * @iclass
 */
void dmaTransferI(msp430x_dma_ch_t * channel, msp430x_dma_req_t * request) {
    5222:	09 4c       	mov	r12,	r9	;
    5224:	0a 4d       	mov	r13,	r10	;

00005226 <.Loc.275.1>:

  osalDbgCheckClassI();
    5226:	b0 12 26 45 	call	#17702		;#0x4526

0000522a <.LVL41>:

  channel->registers->ctl &= (~DMAEN);
    522a:	2c 49       	mov	@r9,	r12	;
    522c:	bc f0 ef ff 	and	#-17,	0(r12)	;#0xffef
    5230:	00 00 

00005232 <.Loc.278.1>:
  dma_trigger_set(channel->index, request->trigger);
    5232:	5d 4a 0c 00 	mov.b	12(r10),r13	;0x0000c
    5236:	5c 49 02 00 	mov.b	2(r9),	r12	;
    523a:	b0 12 d6 50 	call	#20694		;#0x50d6

0000523e <.LVL42>:
  callbacks[channel->index] = request->callback;
    523e:	5c 49 02 00 	mov.b	2(r9),	r12	;
    5242:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    5246:	9c 4a 0e 00 	mov	14(r10),-13026(r12);0x0000e, 0xcd1e
    524a:	1e cd 
    524c:	9c 4a 10 00 	mov	16(r10),-13024(r12);0x00010, 0xcd20
    5250:	20 cd 

00005252 <.Loc.281.1>:

  channel->registers->sa  = (uintptr_t)request->source_addr;
    5252:	2c 49       	mov	@r9,	r12	;
    5254:	2d 4a       	mov	@r10,	r13	;
    5256:	0e 4d       	mov	r13,	r14	;
    5258:	0f 43       	clr	r15		;
    525a:	8c 4e 02 00 	mov	r14,	2(r12)	;
    525e:	8c 4f 04 00 	mov	r15,	4(r12)	;

00005262 <.Loc.282.1>:
  channel->registers->da  = (uintptr_t)request->dest_addr;
    5262:	1d 4a 02 00 	mov	2(r10),	r13	;
    5266:	0e 4d       	mov	r13,	r14	;
    5268:	0f 43       	clr	r15		;
    526a:	8c 4e 06 00 	mov	r14,	6(r12)	;
    526e:	8c 4f 08 00 	mov	r15,	8(r12)	;

00005272 <.Loc.283.1>:
  channel->registers->sz  = request->size;
    5272:	9c 4a 04 00 	mov	4(r10),	10(r12)	; 0x000a
    5276:	0a 00 

00005278 <.Loc.284.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5278:	1d 4a 08 00 	mov	8(r10),	r13	;
    527c:	1d da 06 00 	bis	6(r10),	r13	;

00005280 <.Loc.285.1>:
                            request->transfer_mode | DMAEN |
    5280:	3d d0 15 00 	bis	#21,	r13	;#0x0015

00005284 <.Loc.284.1>:
  channel->registers->ctl = DMAIE | request->data_mode | request->addr_mode |
    5284:	1d da 0a 00 	bis	10(r10),r13	;0x0000a
    5288:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000528c <.Loc.287.1>:
                            DMAREQ;
}
    528c:	19 17       	popm	#2,	r10	;16-bit words
    528e:	30 41       	ret			

00005290 <dmaReleaseX>:
 *          operation and is trapped if assertions are enabled.
 * @pre     The channel must have been acquired using @p dmaAcquireI() 
 *          or claimed using @p dmaClaimI().
 * @post    The channel is returned to the DMA engine pool.
 */
void dmaReleaseX(msp430x_dma_ch_t * channel) {
    5290:	1a 15       	pushm	#2,	r10	;16-bit words

00005292 <.LCFI7>:
    5292:	0a 4c       	mov	r12,	r10	;

00005294 <.LBB31>:
  return chSysGetStatusAndLockX();
    5294:	b0 12 ee 45 	call	#17902		;#0x45ee

00005298 <.LVL48>:
    5298:	09 4c       	mov	r12,	r9	;

0000529a <.LBE31>:
  syssts_t sts;

  sts = osalSysGetStatusAndLockX();
  osalDbgCheck(channel != NULL);
  
  if (dmaIsClaimed(channel)) {
    529a:	0a 93       	cmp	#0,	r10	;r3 As==00
    529c:	0e 24       	jz	$+30     	;abs 0x52ba

0000529e <.Loc.304.1>:
    529e:	2c 4a       	mov	@r10,	r12	;
    52a0:	0c 93       	cmp	#0,	r12	;r3 As==00
    52a2:	0b 24       	jz	$+24     	;abs 0x52ba

000052a4 <.Loc.304.1>:
    52a4:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    52a8:	00 00 
    52aa:	07 24       	jz	$+16     	;abs 0x52ba

000052ac <.Loc.307.1>:

    /* Release the channel in an idle mode */
    channel->registers->ctl = DMAABORT;
    52ac:	ac 43 00 00 	mov	#2,	0(r12)	;r3 As==10

000052b0 <.Loc.310.1>:

    /* release the DMA counter */
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    52b0:	4d 43       	clr.b	r13		;
    52b2:	3c 40 1c cd 	mov	#-13028,r12	;#0xcd1c
    52b6:	b0 12 2a 4b 	call	#19242		;#0x4b2a

000052ba <.L32>:
  chSysRestoreStatusX(sts);
    52ba:	0c 49       	mov	r9,	r12	;
    52bc:	b0 12 f0 46 	call	#18160		;#0x46f0

000052c0 <.LBE33>:
  }
  osalSysRestoreStatusX(sts);
}
    52c0:	19 17       	popm	#2,	r10	;16-bit words
    52c2:	30 41       	ret			

000052c4 <dmaCancelI>:
 * @note    Trying to cancel a transaction on a channel which is not currently
 *          in use is not an error but it is a waste of time.
 * @note    Cancelling a transaction on a channel from the DMA engine pool will
 *          return the channel to the pool.
 */
void dmaCancelI(msp430x_dma_ch_t * channel) {
    52c4:	0a 15       	pushm	#1,	r10	;16-bit words

000052c6 <.LCFI8>:
    52c6:	0a 4c       	mov	r12,	r10	;

000052c8 <.Loc.326.1>:
  
  osalDbgCheckClassI();
    52c8:	b0 12 26 45 	call	#17702		;#0x4526

000052cc <.LVL52>:
  osalDbgCheck(channel != NULL);
  
  if (!(channel->registers->ctl & DMAEN)) {
    52cc:	2c 4a       	mov	@r10,	r12	;
    52ce:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    52d2:	00 00 
    52d4:	0e 24       	jz	$+30     	;abs 0x52f2

000052d6 <.Loc.334.1>:
    return;
  }
  
  /* Cancel pending DMA transaction */
  channel->registers->ctl &= ~(DMAEN | DMAREQ);
    52d6:	bc f0 ee ff 	and	#-18,	0(r12)	;#0xffee
    52da:	00 00 

000052dc <.Loc.336.1>:
  /* Set to idle mode (but still claimed */
  dma_trigger_set(channel->index, DMA_TRIGGER_MNEM(DMAREQ));
    52dc:	4d 43       	clr.b	r13		;
    52de:	5c 4a 02 00 	mov.b	2(r10),	r12	;
    52e2:	b0 12 d6 50 	call	#20694		;#0x50d6

000052e6 <.LVL53>:
  channel->registers->sz  = 0;
    52e6:	2c 4a       	mov	@r10,	r12	;
    52e8:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a

000052ec <.Loc.338.1>:
  channel->registers->ctl = DMAEN | DMAABORT;
    52ec:	bc 40 12 00 	mov	#18,	0(r12)	;#0x0012
    52f0:	00 00 

000052f2 <.L42>:
}
    52f2:	0a 17       	popm	#1,	r10	;16-bit words
    52f4:	30 41       	ret			

000052f6 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    52f6:	3a 15       	pushm	#4,	r10	;16-bit words

000052f8 <.LCFI0>:
    52f8:	0a 4c       	mov	r12,	r10	;

000052fa <.Loc.106.1>:

  if (!dmaIsClaimed(&(spip->dmarx))) {
    52fa:	08 4c       	mov	r12,	r8	;
    52fc:	38 50 34 00 	add	#52,	r8	;#0x0034
    5300:	08 93       	cmp	#0,	r8	;r3 As==00
    5302:	08 24       	jz	$+18     	;abs 0x5314

00005304 <.Loc.106.1>:
    5304:	1c 4c 34 00 	mov	52(r12),r12	;0x00034

00005308 <.LVL1>:
    5308:	0c 93       	cmp	#0,	r12	;r3 As==00
    530a:	04 24       	jz	$+10     	;abs 0x5314

0000530c <.Loc.106.1>:
    530c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5310:	00 00 
    5312:	03 20       	jnz	$+8      	;abs 0x531a

00005314 <.L2>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmarx));
    5314:	0c 48       	mov	r8,	r12	;
    5316:	b0 12 82 51 	call	#20866		;#0x5182

0000531a <.L3>:
  }
  
  if (!dmaIsClaimed(&(spip->dmatx))) {
    531a:	09 4a       	mov	r10,	r9	;
    531c:	39 50 2e 00 	add	#46,	r9	;#0x002e
    5320:	09 93       	cmp	#0,	r9	;r3 As==00
    5322:	08 24       	jz	$+18     	;abs 0x5334

00005324 <.Loc.111.1>:
    5324:	1c 4a 2e 00 	mov	46(r10),r12	;0x0002e
    5328:	0c 93       	cmp	#0,	r12	;r3 As==00
    532a:	04 24       	jz	$+10     	;abs 0x5334

0000532c <.Loc.111.1>:
    532c:	bc b0 10 00 	bit	#16,	0(r12)	;#0x0010
    5330:	00 00 
    5332:	03 20       	jnz	$+8      	;abs 0x533a

00005334 <.L4>:
    /* TODO timeouts and fallbacks */
    dmaAcquireI(&(spip->dmatx));
    5334:	0c 49       	mov	r9,	r12	;
    5336:	b0 12 82 51 	call	#20866		;#0x5182

0000533a <.L5>:
  }
  
  dmaTransferI(&(spip->dmarx), &(spip->rx_req));
    533a:	37 40 20 52 	mov	#21024,	r7	;#0x5220
    533e:	0d 4a       	mov	r10,	r13	;
    5340:	3d 50 1c 00 	add	#28,	r13	;#0x001c
    5344:	0c 48       	mov	r8,	r12	;
    5346:	87 12       	call	r7		;

00005348 <.LVL4>:
  dmaTransferI(&(spip->dmatx), &(spip->tx_req));
    5348:	0d 4a       	mov	r10,	r13	;
    534a:	3d 50 0a 00 	add	#10,	r13	;#0x000a
    534e:	0c 49       	mov	r9,	r12	;
    5350:	87 12       	call	r7		;

00005352 <.LVL5>:

  *(spip->ifg) |= UCTXIFG;
    5352:	1c 4a 08 00 	mov	8(r10),	r12	;
    5356:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

0000535a <.Loc.120.1>:
}
    535a:	37 17       	popm	#4,	r10	;16-bit words
    535c:	30 41       	ret			

0000535e <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * arg) {
    535e:	1a 15       	pushm	#2,	r10	;16-bit words

00005360 <.LCFI1>:
    5360:	0a 4c       	mov	r12,	r10	;

00005362 <.LVL7>:
  SPIDriver * spip = (SPIDriver *)(arg);

  /* So that future transfers will actually work */
  *(spip->ifg) &= ~(UCTXIFG);
    5362:	1d 4c 08 00 	mov	8(r12),	r13	;
    5366:	ad c3 00 00 	bic	#2,	0(r13)	;r3 As==10

0000536a <.Loc.136.1>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code(spip);
    536a:	1d 4c 02 00 	mov	2(r12),	r13	;
    536e:	2d 4d       	mov	@r13,	r13	;
    5370:	0d 93       	cmp	#0,	r13	;r3 As==00
    5372:	06 24       	jz	$+14     	;abs 0x5380

00005374 <.Loc.136.1>:
    5374:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    5378:	8d 12       	call	r13		;

0000537a <.LVL8>:
    537a:	ea 92 00 00 	cmp.b	#4,	0(r10)	;r2 As==10
    537e:	02 20       	jnz	$+6      	;abs 0x5384

00005380 <.L19>:
    5380:	ea 43 00 00 	mov.b	#2,	0(r10)	;r3 As==10

00005384 <.L20>:
  chSysLockFromISR();
    5384:	b0 12 98 44 	call	#17560		;#0x4498

00005388 <.LBB34>:
  chThdResumeI(trp, msg);
    5388:	4d 43       	clr.b	r13		;
    538a:	0c 4a       	mov	r10,	r12	;
    538c:	2c 52       	add	#4,	r12	;r2 As==10

0000538e <.LVL10>:
    538e:	b0 12 6a 47 	call	#18282		;#0x476a

00005392 <.LBB36>:
  chSysUnlockFromISR();
    5392:	b0 12 b8 44 	call	#17592		;#0x44b8

00005396 <.LBE36>:
  
  if (spip->state == SPI_READY) {
    5396:	ea 93 00 00 	cmp.b	#2,	0(r10)	;r3 As==10
    539a:	0a 20       	jnz	$+22     	;abs 0x53b0

0000539c <.LBB38>:
    dmaReleaseX(&(spip->dmarx));
    539c:	39 40 90 52 	mov	#21136,	r9	;#0x5290
    53a0:	0c 4a       	mov	r10,	r12	;
    53a2:	3c 50 34 00 	add	#52,	r12	;#0x0034
    53a6:	89 12       	call	r9		;

000053a8 <.LVL14>:
    dmaReleaseX(&(spip->dmatx));
    53a8:	0c 4a       	mov	r10,	r12	;
    53aa:	3c 50 2e 00 	add	#46,	r12	;#0x002e
    53ae:	89 12       	call	r9		;

000053b0 <.L18>:
  }
}
    53b0:	19 17       	popm	#2,	r10	;16-bit words
    53b2:	30 41       	ret			

000053b4 <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    53b4:	3c 40 9e 1c 	mov	#7326,	r12	;#0x1c9e
    53b8:	b0 12 12 4c 	call	#19474		;#0x4c12

000053bc <.LVL16>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    53bc:	3c 40 9e 1c 	mov	#7326,	r12	;#0x1c9e
    53c0:	bc 40 e0 05 	mov	#1504,	6(r12)	;#0x05e0
    53c4:	06 00 

000053c6 <.Loc.184.1>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    53c6:	bc 40 fc 05 	mov	#1532,	8(r12)	;#0x05fc
    53ca:	08 00 

000053cc <.Loc.185.1>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    53cc:	bc 40 11 00 	mov	#17,	22(r12)	;#0x0011, 0x0016
    53d0:	16 00 

000053d2 <.Loc.186.1>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    53d2:	bc 40 10 00 	mov	#16,	40(r12)	;#0x0010, 0x0028
    53d6:	28 00 

000053d8 <.Loc.187.1>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    53d8:	bc 40 ee 05 	mov	#1518,	12(r12)	;#0x05ee, 0x000c
    53dc:	0c 00 

000053de <.Loc.188.1>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    53de:	bc 40 ec 05 	mov	#1516,	28(r12)	;#0x05ec, 0x001c
    53e2:	1c 00 

000053e4 <.Loc.189.1>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    53e4:	bc 40 c0 00 	mov	#192,	18(r12)	;#0x00c0, 0x0012
    53e8:	12 00 

000053ea <.Loc.190.1>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    53ea:	bc 40 c0 00 	mov	#192,	36(r12)	;#0x00c0, 0x0024
    53ee:	24 00 

000053f0 <.Loc.191.1>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    53f0:	8c 43 14 00 	mov	#0,	20(r12)	;r3 As==00, 0x0014

000053f4 <.Loc.192.1>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    53f4:	8c 43 26 00 	mov	#0,	38(r12)	;r3 As==00, 0x0026

000053f8 <.Loc.193.1>:
  SPIDA1.tx_req.callback.callback = NULL;
    53f8:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018

000053fc <.Loc.194.1>:
  SPIDA1.tx_req.callback.args     = NULL;
    53fc:	8c 43 1a 00 	mov	#0,	26(r12)	;r3 As==00, 0x001a

00005400 <.Loc.195.1>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    5400:	bc 40 5e 53 	mov	#21342,	42(r12)	;#0x535e, 0x002a
    5404:	2a 00 

00005406 <.Loc.196.1>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    5406:	8c 4c 2c 00 	mov	r12,	44(r12)	; 0x002c

0000540a <.Loc.312.1>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    540a:	30 41       	ret			

0000540c <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    540c:	1a 15       	pushm	#2,	r10	;16-bit words

0000540e <.LCFI2>:

  if (spip->config->ss_line) {
    540e:	1c 4c 02 00 	mov	2(r12),	r12	;

00005412 <.LVL20>:
    5412:	1d 4c 02 00 	mov	2(r12),	r13	;
    5416:	0d 93       	cmp	#0,	r13	;r3 As==00
    5418:	0e 24       	jz	$+30     	;abs 0x5436

0000541a <.Loc.432.1>:
    palClearLine(spip->config->ss_line);
    541a:	0a 4d       	mov	r13,	r10	;
    541c:	3a f0 ff 0f 	and	#4095,	r10	;#0x0fff
    5420:	19 4a 02 00 	mov	2(r10),	r9	;
    5424:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5426:	5d 03       	rrum	#1,	r13	;
    5428:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    542c:	b0 12 94 af 	call	#-20588	;#0xaf94
    5430:	09 cc       	bic	r12,	r9	;
    5432:	8a 49 02 00 	mov	r9,	2(r10)	;

00005436 <.L28>:
  }
}
    5436:	19 17       	popm	#2,	r10	;16-bit words
    5438:	30 41       	ret			

0000543a <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    543a:	1a 15       	pushm	#2,	r10	;16-bit words

0000543c <.LCFI3>:

  if (spip->config->ss_line) {
    543c:	1c 4c 02 00 	mov	2(r12),	r12	;

00005440 <.LVL23>:
    5440:	1d 4c 02 00 	mov	2(r12),	r13	;
    5444:	0d 93       	cmp	#0,	r13	;r3 As==00
    5446:	0e 24       	jz	$+30     	;abs 0x5464

00005448 <.Loc.447.1>:
    palSetLine(spip->config->ss_line);
    5448:	0a 4d       	mov	r13,	r10	;
    544a:	3a f0 ff 0f 	and	#4095,	r10	;#0x0fff
    544e:	19 4a 02 00 	mov	2(r10),	r9	;
    5452:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5454:	5d 03       	rrum	#1,	r13	;
    5456:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    545a:	b0 12 94 af 	call	#-20588	;#0xaf94
    545e:	0c d9       	bis	r9,	r12	;
    5460:	8a 4c 02 00 	mov	r12,	2(r10)	;

00005464 <.L33>:
  }
}
    5464:	19 17       	popm	#2,	r10	;16-bit words
    5466:	30 41       	ret			

00005468 <spi_lld_start>:
void spi_lld_start(SPIDriver * spip) {
    5468:	1a 15       	pushm	#2,	r10	;16-bit words

0000546a <.LCFI4>:
    546a:	0a 4c       	mov	r12,	r10	;

0000546c <.LVL26>:
  if (spip == &SPIDA1) {
    546c:	3c 90 9e 1c 	cmp	#7326,	r12	;#0x1c9e
    5470:	38 20       	jnz	$+114    	;abs 0x54e2

00005472 <.Loc.348.1>:
    brw  = MSP430X_SPIA1_CLK_FREQ / spip->config->bit_rate;
    5472:	1c 4c 02 00 	mov	2(r12),	r12	;

00005476 <.LVL27>:
    5476:	1e 4c 04 00 	mov	4(r12),	r14	;
    547a:	1f 4c 06 00 	mov	6(r12),	r15	;
    547e:	3c 40 00 24 	mov	#9216,	r12	;#0x2400
    5482:	7d 40 f4 00 	mov.b	#244,	r13	;#0x00f4
    5486:	b0 12 62 af 	call	#-20638	;#0xaf62

0000548a <.LVL28>:
    ssel = MSP430X_SPIA1_UCSSEL;
    548a:	7e 40 80 00 	mov.b	#128,	r14	;#0x0080

0000548e <.L39>:
  spip->regs->ctlw0 = UCSWRST;
    548e:	1b 4a 06 00 	mov	6(r10),	r11	;

00005492 <.Loc.390.1>:
  spip->regs->brw   = brw;
    5492:	8b 4c 06 00 	mov	r12,	6(r11)	;

00005496 <.Loc.392.1>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    5496:	1d 4a 02 00 	mov	2(r10),	r13	;
    549a:	5c 4d 0a 00 	mov.b	10(r13),r12	;0x0000a

0000549e <.LVL30>:
    549e:	6c e3       	xor.b	#2,	r12	;r3 As==10
    54a0:	0f 4c       	mov	r12,	r15	;
    54a2:	4d 18 0f 5f 	rpt #14 { rlax.w	r15		;
    54a6:	5c 4d 08 00 	mov.b	8(r13),	r12	;
    54aa:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;

000054ae <.Loc.393.1>:
      (spip->config->data_size << 12) | (UCMST) |
    54ae:	59 4d 09 00 	mov.b	9(r13),	r9	;
    54b2:	4b 18 09 59 	rpt #12 { rlax.w	r9		;
    54b6:	0c d9       	bis	r9,	r12	;

000054b8 <.Loc.394.1>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    54b8:	8d 93 02 00 	cmp	#0,	2(r13)	;r3 As==00
    54bc:	15 20       	jnz	$+44     	;abs 0x54e8
    54be:	3d 40 00 04 	mov	#1024,	r13	;#0x0400

000054c2 <.L40>:
    54c2:	3c d0 02 09 	bis	#2306,	r12	;#0x0902
    54c6:	0c df       	bis	r15,	r12	;
    54c8:	0c de       	bis	r14,	r12	;
    54ca:	0c dd       	bis	r13,	r12	;
    54cc:	8b 4c 00 00 	mov	r12,	0(r11)	;

000054d0 <.Loc.395.1>:
  *(spip->ifg) = 0;
    54d0:	1c 4a 08 00 	mov	8(r10),	r12	;
    54d4:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000054d8 <.LVL31>:
  spi_lld_unselect(spip);
    54d8:	0c 4a       	mov	r10,	r12	;
    54da:	b0 12 3a 54 	call	#21562		;#0x543a

000054de <.LVL32>:
}
    54de:	19 17       	popm	#2,	r10	;16-bit words
    54e0:	30 41       	ret			

000054e2 <.L41>:
  uint8_t ssel = 0;
    54e2:	4e 43       	clr.b	r14		;

000054e4 <.Loc.338.1>:
  uint16_t brw = 0;
    54e4:	0c 4e       	mov	r14,	r12	;
    54e6:	d3 3f       	jmp	$-88     	;abs 0x548e

000054e8 <.L42>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    54e8:	4d 43       	clr.b	r13		;
    54ea:	eb 3f       	jmp	$-40     	;abs 0x54c2

000054ec <spi_lld_send>:
    54ec:	8c 4e 0a 00 	mov	r14,	10(r12)	; 0x000a

000054f0 <L0>:
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {

  spip->tx_req.source_addr = txbuf;
  spip->tx_req.size        = n;
    54f0:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

000054f4 <.Loc.523.1>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    54f4:	bc 40 00 03 	mov	#768,	16(r12)	;#0x0300, 0x0010
    54f8:	10 00 

000054fa <.Loc.525.1>:

  spip->rx_req.dest_addr = &dummyrx;
    54fa:	bc 40 2a cd 	mov	#-13014,30(r12)	;#0xcd2a, 0x001e
    54fe:	1e 00 

00005500 <.Loc.526.1>:
  spip->rx_req.size      = n;
    5500:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020

00005504 <.Loc.527.1>:
  spip->rx_req.addr_mode = 0;
    5504:	8c 43 22 00 	mov	#0,	34(r12)	;r3 As==00, 0x0022

00005508 <.Loc.529.1>:

  init_transfer(spip);
    5508:	b0 12 f6 52 	call	#21238		;#0x52f6

0000550c <.LVL40>:
}
    550c:	30 41       	ret			

0000550e <spi_lld_polled_exchange>:
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {

  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spip->regs->txbuf = frame;
    550e:	1e 4c 06 00 	mov	6(r12),	r14	;
    5512:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    5516:	8e 4d 0e 00 	mov	r13,	14(r14)	; 0x000e

0000551a <.Loc.574.1>:
  while (!(*(spip->ifg) & UCRXIFG))
    551a:	1c 4c 08 00 	mov	8(r12),	r12	;

0000551e <.L48>:
    551e:	9c b3 00 00 	bit	#1,	0(r12)	;r3 As==01
    5522:	fd 27       	jz	$-4      	;abs 0x551e

00005524 <.Loc.576.1>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    5524:	bc f0 fc ff 	and	#-4,	0(r12)	;#0xfffc
    5528:	00 00 

0000552a <.Loc.578.1>:
  return spip->regs->rxbuf;
}
    552a:	5c 4e 0c 00 	mov.b	12(r14),r12	;0x0000c
    552e:	30 41       	ret			

00005530 <rx_cb>:
static void uart_enter_rx_idle_loop(UARTDriver* uartp) {
  /* Re-enable RX interrupt */
  uartp->regs->ie |= UCRXIE;
}

static void rx_cb(void * arg){
    5530:	0a 15       	pushm	#1,	r10	;16-bit words

00005532 <.LCFI0>:
    5532:	0a 4c       	mov	r12,	r10	;

00005534 <.LVL1>:
  UARTDriver * uartp = (UARTDriver *)(arg);
  
  /* Call the callback function */
  _uart_rx_complete_isr_code(uartp);
    5534:	ec 43 02 00 	mov.b	#2,	2(r12)	;r3 As==10
    5538:	1d 4c 04 00 	mov	4(r12),	r13	;
    553c:	1d 4d 04 00 	mov	4(r13),	r13	;
    5540:	0d 93       	cmp	#0,	r13	;r3 As==00
    5542:	01 24       	jz	$+4      	;abs 0x5546

00005544 <.Loc.204.1>:
    5544:	8d 12       	call	r13		;

00005546 <.L2>:
    5546:	ea 93 02 00 	cmp.b	#2,	2(r10)	;r3 As==10
    554a:	06 20       	jnz	$+14     	;abs 0x5558

0000554c <.Loc.204.1>:
    554c:	ca 43 02 00 	mov.b	#0,	2(r10)	;r3 As==00
    5550:	1c 4a 10 00 	mov	16(r10),r12	;0x00010

00005554 <.LBB39>:
  uartp->regs->ie |= UCRXIE;
    5554:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005558 <.L3>:
  chSysLockFromISR();
    5558:	b0 12 98 44 	call	#17560		;#0x4498

0000555c <.LBB43>:
  chThdResumeI(trp, msg);
    555c:	4d 43       	clr.b	r13		;
    555e:	0c 4a       	mov	r10,	r12	;
    5560:	3c 52       	add	#8,	r12	;r2 As==11

00005562 <.LVL6>:
    5562:	b0 12 6a 47 	call	#18282		;#0x476a

00005566 <.LBB45>:
  chSysUnlockFromISR();
    5566:	b0 12 b8 44 	call	#17592		;#0x44b8

0000556a <.LBE45>:
}
    556a:	0a 17       	popm	#1,	r10	;16-bit words
    556c:	30 41       	ret			

0000556e <UCBRS>:
  if (frac < 529)
    556e:	3d 40 10 02 	mov	#528,	r13	;#0x0210
    5572:	0d 9c       	cmp	r12,	r13	;
    5574:	8b 2c       	jc	$+280    	;abs 0x568c

00005576 <.Loc.84.1>:
  else if (frac < 715)
    5576:	3d 40 ca 02 	mov	#714,	r13	;#0x02ca
    557a:	0d 9c       	cmp	r12,	r13	;
    557c:	89 2c       	jc	$+276    	;abs 0x5690

0000557e <.Loc.86.1>:
  else if (frac < 835)
    557e:	3d 40 42 03 	mov	#834,	r13	;#0x0342
    5582:	0d 9c       	cmp	r12,	r13	;
    5584:	87 2c       	jc	$+272    	;abs 0x5694

00005586 <.Loc.88.1>:
  else if (frac < 1001)
    5586:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    558a:	0d 9c       	cmp	r12,	r13	;
    558c:	85 2c       	jc	$+268    	;abs 0x5698

0000558e <.Loc.90.1>:
  else if (frac < 1252)
    558e:	3d 40 e3 04 	mov	#1251,	r13	;#0x04e3
    5592:	0d 9c       	cmp	r12,	r13	;
    5594:	83 2c       	jc	$+264    	;abs 0x569c

00005596 <.Loc.92.1>:
  else if (frac < 1430)
    5596:	3d 40 95 05 	mov	#1429,	r13	;#0x0595
    559a:	0d 9c       	cmp	r12,	r13	;
    559c:	81 2c       	jc	$+260    	;abs 0x56a0

0000559e <.Loc.94.1>:
  else if (frac < 1670)
    559e:	3d 40 85 06 	mov	#1669,	r13	;#0x0685
    55a2:	0d 9c       	cmp	r12,	r13	;
    55a4:	80 2c       	jc	$+258    	;abs 0x56a6

000055a6 <.Loc.96.1>:
  else if (frac < 2147)
    55a6:	3d 40 62 08 	mov	#2146,	r13	;#0x0862
    55aa:	0d 9c       	cmp	r12,	r13	;
    55ac:	7f 2c       	jc	$+256    	;abs 0x56ac

000055ae <.Loc.98.1>:
  else if (frac < 2224)
    55ae:	3d 40 af 08 	mov	#2223,	r13	;#0x08af
    55b2:	0d 9c       	cmp	r12,	r13	;
    55b4:	7e 2c       	jc	$+254    	;abs 0x56b2

000055b6 <.Loc.100.1>:
  else if (frac < 2503)
    55b6:	3d 40 c6 09 	mov	#2502,	r13	;#0x09c6
    55ba:	0d 9c       	cmp	r12,	r13	;
    55bc:	7d 2c       	jc	$+252    	;abs 0x56b8

000055be <.Loc.102.1>:
  else if (frac < 3000)
    55be:	3d 40 b7 0b 	mov	#2999,	r13	;#0x0bb7
    55c2:	0d 9c       	cmp	r12,	r13	;
    55c4:	7c 2c       	jc	$+250    	;abs 0x56be

000055c6 <.LBB49>:
  else if (frac < 3335)
    55c6:	3d 40 06 0d 	mov	#3334,	r13	;#0x0d06
    55ca:	0d 9c       	cmp	r12,	r13	;
    55cc:	7b 2c       	jc	$+248    	;abs 0x56c4

000055ce <.Loc.106.1>:
  else if (frac < 3575)
    55ce:	3d 40 f6 0d 	mov	#3574,	r13	;#0x0df6
    55d2:	0d 9c       	cmp	r12,	r13	;
    55d4:	7a 2c       	jc	$+246    	;abs 0x56ca

000055d6 <.Loc.108.1>:
  else if (frac < 3753)
    55d6:	3d 40 a8 0e 	mov	#3752,	r13	;#0x0ea8
    55da:	0d 9c       	cmp	r12,	r13	;
    55dc:	79 2c       	jc	$+244    	;abs 0x56d0

000055de <.Loc.110.1>:
  else if (frac < 4003)
    55de:	3d 40 a2 0f 	mov	#4002,	r13	;#0x0fa2
    55e2:	0d 9c       	cmp	r12,	r13	;
    55e4:	78 2c       	jc	$+242    	;abs 0x56d6

000055e6 <.Loc.112.1>:
  else if (frac < 4286)
    55e6:	3d 40 bd 10 	mov	#4285,	r13	;#0x10bd
    55ea:	0d 9c       	cmp	r12,	r13	;
    55ec:	77 2c       	jc	$+240    	;abs 0x56dc

000055ee <.Loc.114.1>:
  else if (frac < 4378)
    55ee:	3d 40 19 11 	mov	#4377,	r13	;#0x1119
    55f2:	0d 9c       	cmp	r12,	r13	;
    55f4:	76 2c       	jc	$+238    	;abs 0x56e2

000055f6 <.Loc.116.1>:
  else if (frac < 5002)
    55f6:	3d 40 89 13 	mov	#5001,	r13	;#0x1389
    55fa:	0d 9c       	cmp	r12,	r13	;
    55fc:	75 2c       	jc	$+236    	;abs 0x56e8

000055fe <.Loc.118.1>:
  else if (frac < 5715)
    55fe:	3d 40 52 16 	mov	#5714,	r13	;#0x1652
    5602:	0d 9c       	cmp	r12,	r13	;
    5604:	74 2c       	jc	$+234    	;abs 0x56ee

00005606 <.Loc.120.1>:
  else if (frac < 6003)
    5606:	3d 40 72 17 	mov	#6002,	r13	;#0x1772
    560a:	0d 9c       	cmp	r12,	r13	;
    560c:	73 2c       	jc	$+232    	;abs 0x56f4

0000560e <.Loc.122.1>:
  else if (frac < 6254)
    560e:	3d 40 6d 18 	mov	#6253,	r13	;#0x186d
    5612:	0d 9c       	cmp	r12,	r13	;
    5614:	72 2c       	jc	$+230    	;abs 0x56fa

00005616 <.Loc.124.1>:
  else if (frac < 6432)
    5616:	3d 40 1f 19 	mov	#6431,	r13	;#0x191f
    561a:	0d 9c       	cmp	r12,	r13	;
    561c:	71 2c       	jc	$+228    	;abs 0x5700

0000561e <.Loc.126.1>:
  else if (frac < 6667)
    561e:	3d 40 0a 1a 	mov	#6666,	r13	;#0x1a0a
    5622:	0d 9c       	cmp	r12,	r13	;
    5624:	70 2c       	jc	$+226    	;abs 0x5706

00005626 <.Loc.128.1>:
  else if (frac < 7001)
    5626:	3d 40 58 1b 	mov	#7000,	r13	;#0x1b58
    562a:	0d 9c       	cmp	r12,	r13	;
    562c:	6f 2c       	jc	$+224    	;abs 0x570c

0000562e <.Loc.130.1>:
  else if (frac < 7147)
    562e:	3d 40 ea 1b 	mov	#7146,	r13	;#0x1bea
    5632:	0d 9c       	cmp	r12,	r13	;
    5634:	6e 2c       	jc	$+222    	;abs 0x5712

00005636 <.Loc.132.1>:
  else if (frac < 7503)
    5636:	3d 40 4e 1d 	mov	#7502,	r13	;#0x1d4e
    563a:	0d 9c       	cmp	r12,	r13	;
    563c:	6d 2c       	jc	$+220    	;abs 0x5718

0000563e <.Loc.134.1>:
  else if (frac < 7861)
    563e:	3d 40 b4 1e 	mov	#7860,	r13	;#0x1eb4
    5642:	0d 9c       	cmp	r12,	r13	;
    5644:	6c 2c       	jc	$+218    	;abs 0x571e

00005646 <.Loc.136.1>:
  else if (frac < 8004)
    5646:	3d 40 43 1f 	mov	#8003,	r13	;#0x1f43
    564a:	0d 9c       	cmp	r12,	r13	;
    564c:	6b 2c       	jc	$+216    	;abs 0x5724

0000564e <.Loc.138.1>:
  else if (frac < 8333)
    564e:	3d 40 8c 20 	mov	#8332,	r13	;#0x208c
    5652:	0d 9c       	cmp	r12,	r13	;
    5654:	6a 2c       	jc	$+214    	;abs 0x572a

00005656 <.Loc.140.1>:
  else if (frac < 8464)
    5656:	3d 40 0f 21 	mov	#8463,	r13	;#0x210f
    565a:	0d 9c       	cmp	r12,	r13	;
    565c:	69 2c       	jc	$+212    	;abs 0x5730

0000565e <.Loc.142.1>:
  else if (frac < 8572)
    565e:	3d 40 7b 21 	mov	#8571,	r13	;#0x217b
    5662:	0d 9c       	cmp	r12,	r13	;
    5664:	68 2c       	jc	$+210    	;abs 0x5736

00005666 <.Loc.144.1>:
  else if (frac < 8751)
    5666:	3d 40 2e 22 	mov	#8750,	r13	;#0x222e
    566a:	0d 9c       	cmp	r12,	r13	;
    566c:	67 2c       	jc	$+208    	;abs 0x573c

0000566e <.Loc.146.1>:
  else if (frac < 9004)
    566e:	3d 40 2b 23 	mov	#9003,	r13	;#0x232b
    5672:	0d 9c       	cmp	r12,	r13	;
    5674:	66 2c       	jc	$+206    	;abs 0x5742

00005676 <.Loc.148.1>:
  else if (frac < 9170)
    5676:	3d 40 d1 23 	mov	#9169,	r13	;#0x23d1
    567a:	0d 9c       	cmp	r12,	r13	;
    567c:	65 2c       	jc	$+204    	;abs 0x5748

0000567e <.Loc.150.1>:
  else if (frac < 9288)
    567e:	3d 40 47 24 	mov	#9287,	r13	;#0x2447
    5682:	0d 9c       	cmp	r12,	r13	;
    5684:	64 2c       	jc	$+202    	;abs 0x574e

00005686 <.Loc.153.1>:
    return 0xFE;
    5686:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

0000568a <.L8>:
}
    568a:	30 41       	ret			

0000568c <.L9>:
    return 0x00;
    568c:	4c 43       	clr.b	r12		;

0000568e <.LVL13>:
    568e:	fd 3f       	jmp	$-4      	;abs 0x568a

00005690 <.L10>:
    return 0x01;
    5690:	5c 43       	mov.b	#1,	r12	;r3 As==01

00005692 <.LVL15>:
    5692:	fb 3f       	jmp	$-8      	;abs 0x568a

00005694 <.L11>:
    return 0x02;
    5694:	6c 43       	mov.b	#2,	r12	;r3 As==10

00005696 <.LVL17>:
    5696:	f9 3f       	jmp	$-12     	;abs 0x568a

00005698 <.L12>:
    return 0x04;
    5698:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000569a <.LVL19>:
    569a:	f7 3f       	jmp	$-16     	;abs 0x568a

0000569c <.L13>:
    return 0x08;
    569c:	7c 42       	mov.b	#8,	r12	;r2 As==11

0000569e <.LVL21>:
    569e:	f5 3f       	jmp	$-20     	;abs 0x568a

000056a0 <.L14>:
    return 0x10;
    56a0:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010

000056a4 <.LVL23>:
    56a4:	f2 3f       	jmp	$-26     	;abs 0x568a

000056a6 <.L15>:
    return 0x20;
    56a6:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020

000056aa <.LVL25>:
    56aa:	ef 3f       	jmp	$-32     	;abs 0x568a

000056ac <.L16>:
    return 0x11;
    56ac:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011

000056b0 <.LVL27>:
    56b0:	ec 3f       	jmp	$-38     	;abs 0x568a

000056b2 <.L17>:
    return 0x21;
    56b2:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021

000056b6 <.LVL29>:
    56b6:	e9 3f       	jmp	$-44     	;abs 0x568a

000056b8 <.L18>:
    return 0x22;
    56b8:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022

000056bc <.LVL31>:
    56bc:	e6 3f       	jmp	$-50     	;abs 0x568a

000056be <.L19>:
    return 0x44;
    56be:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044

000056c2 <.LVL33>:
    56c2:	e3 3f       	jmp	$-56     	;abs 0x568a

000056c4 <.L20>:
    return 0x25;
    56c4:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025

000056c8 <.LVL35>:
    56c8:	e0 3f       	jmp	$-62     	;abs 0x568a

000056ca <.L21>:
    return 0x49;
    56ca:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049

000056ce <.LVL37>:
    56ce:	dd 3f       	jmp	$-68     	;abs 0x568a

000056d0 <.L22>:
    return 0x4A;
    56d0:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a

000056d4 <.LVL39>:
    56d4:	da 3f       	jmp	$-74     	;abs 0x568a

000056d6 <.L23>:
    return 0x52;
    56d6:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052

000056da <.LVL41>:
    56da:	d7 3f       	jmp	$-80     	;abs 0x568a

000056dc <.L24>:
    return 0x92;
    56dc:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092

000056e0 <.LVL43>:
    56e0:	d4 3f       	jmp	$-86     	;abs 0x568a

000056e2 <.L25>:
    return 0x53;
    56e2:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053

000056e6 <.LVL45>:
    56e6:	d1 3f       	jmp	$-92     	;abs 0x568a

000056e8 <.L26>:
    return 0x55;
    56e8:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055

000056ec <.LVL47>:
    56ec:	ce 3f       	jmp	$-98     	;abs 0x568a

000056ee <.L27>:
    return 0xAA;
    56ee:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa

000056f2 <.LVL49>:
    56f2:	cb 3f       	jmp	$-104    	;abs 0x568a

000056f4 <.L28>:
    return 0x6B;
    56f4:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b

000056f8 <.LVL51>:
    56f8:	c8 3f       	jmp	$-110    	;abs 0x568a

000056fa <.L29>:
    return 0xAD;
    56fa:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad

000056fe <.LVL53>:
    56fe:	c5 3f       	jmp	$-116    	;abs 0x568a

00005700 <.L30>:
    return 0xB5;
    5700:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5

00005704 <.LVL55>:
    5704:	c2 3f       	jmp	$-122    	;abs 0x568a

00005706 <.L31>:
    return 0xB6;
    5706:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6

0000570a <.LVL57>:
    570a:	bf 3f       	jmp	$-128    	;abs 0x568a

0000570c <.L32>:
    return 0xD6;
    570c:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6

00005710 <.LVL59>:
    5710:	bc 3f       	jmp	$-134    	;abs 0x568a

00005712 <.L33>:
    return 0xB7;
    5712:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7

00005716 <.LVL61>:
    5716:	b9 3f       	jmp	$-140    	;abs 0x568a

00005718 <.L34>:
    return 0xBB;
    5718:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb

0000571c <.LVL63>:
    571c:	b6 3f       	jmp	$-146    	;abs 0x568a

0000571e <.L35>:
    return 0xDD;
    571e:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd

00005722 <.LVL65>:
    5722:	b3 3f       	jmp	$-152    	;abs 0x568a

00005724 <.L36>:
    return 0xED;
    5724:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed

00005728 <.LVL67>:
    5728:	b0 3f       	jmp	$-158    	;abs 0x568a

0000572a <.L37>:
    return 0xEE;
    572a:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee

0000572e <.LVL69>:
    572e:	ad 3f       	jmp	$-164    	;abs 0x568a

00005730 <.L38>:
    return 0xBF;
    5730:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf

00005734 <.LVL71>:
    5734:	aa 3f       	jmp	$-170    	;abs 0x568a

00005736 <.L39>:
    return 0xDF;
    5736:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df

0000573a <.LVL73>:
    573a:	a7 3f       	jmp	$-176    	;abs 0x568a

0000573c <.L40>:
    return 0xEF;
    573c:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef

00005740 <.LVL75>:
    5740:	a4 3f       	jmp	$-182    	;abs 0x568a

00005742 <.L41>:
    return 0xF7;
    5742:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7

00005746 <.LVL77>:
    5746:	a1 3f       	jmp	$-188    	;abs 0x568a

00005748 <.L42>:
    return 0xFB;
    5748:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb

0000574c <.LVL79>:
    574c:	9e 3f       	jmp	$-194    	;abs 0x568a

0000574e <.L43>:
    return 0xFD;
    574e:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd

00005752 <.LVL81>:
    5752:	9b 3f       	jmp	$-200    	;abs 0x568a

00005754 <tx_cb>:
    5754:	0a 15       	pushm	#1,	r10	;16-bit words

00005756 <.LCFI1>:
static void tx_cb(void * arg) {
    5756:	0a 4c       	mov	r12,	r10	;

00005758 <.LVL83>:
  _uart_tx1_isr_code(uartp);
    5758:	ec 43 01 00 	mov.b	#2,	1(r12)	;r3 As==10
    575c:	1d 4c 04 00 	mov	4(r12),	r13	;
    5760:	2d 4d       	mov	@r13,	r13	;
    5762:	0d 93       	cmp	#0,	r13	;r3 As==00
    5764:	01 24       	jz	$+4      	;abs 0x5768

00005766 <.Loc.183.1>:
    5766:	8d 12       	call	r13		;

00005768 <.L45>:
    5768:	ea 93 01 00 	cmp.b	#2,	1(r10)	;r3 As==10
    576c:	02 20       	jnz	$+6      	;abs 0x5772

0000576e <.Loc.183.1>:
    576e:	ca 43 01 00 	mov.b	#0,	1(r10)	;r3 As==00

00005772 <.L46>:
    5772:	ca 93 06 00 	cmp.b	#0,	6(r10)	;r3 As==00
    5776:	0a 24       	jz	$+22     	;abs 0x578c

00005778 <.LBB67>:
  chSysLockFromISR();
    5778:	b0 12 98 44 	call	#17560		;#0x4498

0000577c <.LBB69>:
  chThdResumeI(trp, msg);
    577c:	4d 43       	clr.b	r13		;
    577e:	0c 4a       	mov	r10,	r12	;
    5780:	3c 50 0a 00 	add	#10,	r12	;#0x000a

00005784 <.LVL86>:
    5784:	b0 12 6a 47 	call	#18282		;#0x476a

00005788 <.LBB71>:
  chSysUnlockFromISR();
    5788:	b0 12 b8 44 	call	#17592		;#0x44b8

0000578c <.L47>:
  if (uartp->txstate == UART_TX_IDLE) {
    578c:	ca 93 01 00 	cmp.b	#0,	1(r10)	;r3 As==00
    5790:	09 20       	jnz	$+20     	;abs 0x57a4

00005792 <.LBB73>:
    while (!(uartp->regs->ifg & UCTXCPTIFG));
    5792:	1c 4a 10 00 	mov	16(r10),r12	;0x00010

00005796 <.L49>:
    5796:	bc b2 1c 00 	bit	#8,	28(r12)	;r2 As==11, 0x001c

0000579a <L0>:
    579a:	fd 27       	jz	$-4      	;abs 0x5796

0000579c <.Loc.188.1>:
    uartp->regs->ifg &= ~UCTXCPTIFG;
    579c:	bc c2 1c 00 	bic	#8,	28(r12)	;r2 As==11, 0x001c

000057a0 <.Loc.191.1>:
    uartp->regs->ie |= UCTXCPTIE;
    57a0:	bc d2 1a 00 	bis	#8,	26(r12)	;r2 As==11, 0x001a

000057a4 <.L44>:
}
    57a4:	0a 17       	popm	#1,	r10	;16-bit words
    57a6:	30 41       	ret			

000057a8 <ISR_USCI_A0_VECTOR>:
/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

#if MSP430X_UART_USE_UARTA0 == TRUE
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    57a8:	bf 15       	pushm	#12,	r15	;16-bit words

000057aa <.LCFI2>:
  OSAL_IRQ_PROLOGUE();
    57aa:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    57ae:	b0 12 d8 44 	call	#17624		;#0x44d8

000057b2 <.LVL89>:

  switch(__even_in_range(UCA0IV, UCTXCPTIFG)) {
    57b2:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    57b6:	2c 93       	cmp	#2,	r12	;r3 As==10
    57b8:	12 24       	jz	$+38     	;abs 0x57de
    57ba:	3c 92       	cmp	#8,	r12	;r2 As==11
    57bc:	50 24       	jz	$+162    	;abs 0x585e

000057be <.L56>:
        UARTDA0.txcpt_first = true;
      /*}*/
      break;
  }
  
  OSAL_IRQ_EPILOGUE();
    57be:	b0 12 fe 44 	call	#17662		;#0x44fe

000057c2 <.LVL90>:
    57c2:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    57c6:	b0 12 5a 44 	call	#17498		;#0x445a

000057ca <.LVL91>:
    57ca:	b0 12 b2 46 	call	#18098		;#0x46b2

000057ce <.LVL92>:
    57ce:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    57d0:	02 24       	jz	$+6      	;abs 0x57d6

000057d2 <.Loc.265.1>:
    57d2:	b0 12 ca 46 	call	#18122		;#0x46ca

000057d6 <.L68>:
    57d6:	b0 12 78 44 	call	#17528		;#0x4478

000057da <.LVL94>:
}
    57da:	b4 17       	popm	#12,	r15	;16-bit words
    57dc:	00 13       	reti			

000057de <.L57>:
    57de:	3a 40 d8 1c 	mov	#7384,	r10	;#0x1cd8

000057e2 <.Loc.220.1>:
      if (UCA0STATW & UCRXERR) {
    57e2:	e2 b2 ca 05 	bit.b	#4,	&0x05ca	;r2 As==10
    57e6:	29 24       	jz	$+84     	;abs 0x583a

000057e8 <.LBB75>:
        if (UCA0STATW & UCBRK)
    57e8:	f2 b2 ca 05 	bit.b	#8,	&0x05ca	;r2 As==11
    57ec:	32 24       	jz	$+102    	;abs 0x5852

000057ee <.Loc.225.1>:
          sts |= UART_BREAK_DETECTED;
    57ee:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    57f2:	4e 43       	clr.b	r14		;

000057f4 <.L60>:
        if (UCA0STATW & UCOE)
    57f4:	f2 b0 20 00 	bit.b	#32,	&0x05ca	;#0x0020
    57f8:	ca 05 
    57fa:	02 24       	jz	$+6      	;abs 0x5800

000057fc <.Loc.227.1>:
          sts |= UART_OVERRUN_ERROR;
    57fc:	3d d0 10 00 	bis	#16,	r13	;#0x0010

00005800 <.L61>:
        if (UCA0STATW & UCFE)
    5800:	f2 b0 40 00 	bit.b	#64,	&0x05ca	;#0x0040
    5804:	ca 05 
    5806:	01 24       	jz	$+4      	;abs 0x580a

00005808 <.Loc.229.1>:
          sts |= UART_FRAMING_ERROR;
    5808:	3d d2       	bis	#8,	r13	;r2 As==11

0000580a <.L62>:
        if (UCA0STATW & UCPE)
    580a:	f2 b0 10 00 	bit.b	#16,	&0x05ca	;#0x0010
    580e:	ca 05 
    5810:	01 24       	jz	$+4      	;abs 0x5814

00005812 <.Loc.231.1>:
          sts |= UART_PARITY_ERROR;
    5812:	2d d2       	bis	#4,	r13	;r2 As==10

00005814 <.L63>:
        _uart_rx_error_isr_code(&UARTDA0, sts);
    5814:	1c 4a 04 00 	mov	4(r10),	r12	;
    5818:	1f 4c 08 00 	mov	8(r12),	r15	;
    581c:	0f 93       	cmp	#0,	r15	;r3 As==00
    581e:	03 24       	jz	$+8      	;abs 0x5826

00005820 <.Loc.233.1>:
    5820:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    5824:	8f 12       	call	r15		;

00005826 <.L64>:
  chSysLockFromISR();
    5826:	b0 12 98 44 	call	#17560		;#0x4498

0000582a <.LBB78>:
  chThdResumeI(trp, msg);
    582a:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    582e:	3c 40 e0 1c 	mov	#7392,	r12	;#0x1ce0

00005832 <.LVL102>:
    5832:	b0 12 6a 47 	call	#18282		;#0x476a

00005836 <.LBB80>:
  chSysUnlockFromISR();
    5836:	b0 12 b8 44 	call	#17592		;#0x44b8

0000583a <.L59>:
      if (UARTDA0.config->rxchar_cb != NULL) {
    583a:	1c 4a 04 00 	mov	4(r10),	r12	;
    583e:	1e 4c 06 00 	mov	6(r12),	r14	;
    5842:	0e 93       	cmp	#0,	r14	;r3 As==00
    5844:	09 24       	jz	$+20     	;abs 0x5858

00005846 <.Loc.238.1>:
        UARTDA0.config->rxchar_cb(&UARTDA0, UCA0RXBUF);
    5846:	1d 42 cc 05 	mov	&0x05cc,r13	;0x05cc
    584a:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    584e:	8e 12       	call	r14		;

00005850 <.LVL105>:
    5850:	b6 3f       	jmp	$-146    	;abs 0x57be

00005852 <.L69>:
        uartflags_t sts = 0;
    5852:	4d 43       	clr.b	r13		;
    5854:	0e 4d       	mov	r13,	r14	;
    5856:	ce 3f       	jmp	$-98     	;abs 0x57f4

00005858 <.L65>:
        UCA0IFG &= ~UCRXIFG;
    5858:	92 c3 dc 05 	bic	#1,	&0x05dc	;r3 As==01
    585c:	b0 3f       	jmp	$-158    	;abs 0x57be

0000585e <.L58>:
        _uart_tx2_isr_code(&UARTDA0);
    585e:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    5862:	1d 4c 04 00 	mov	4(r12),	r13	;
    5866:	1d 4d 02 00 	mov	2(r13),	r13	;
    586a:	0d 93       	cmp	#0,	r13	;r3 As==00
    586c:	01 24       	jz	$+4      	;abs 0x5870

0000586e <.Loc.255.1>:
    586e:	8d 12       	call	r13		;

00005870 <.L66>:
    5870:	c2 93 de 1c 	cmp.b	#0,	&0x1cde	;r3 As==00
    5874:	09 20       	jnz	$+20     	;abs 0x5888

00005876 <.LBB83>:
  chSysLockFromISR();
    5876:	b0 12 98 44 	call	#17560		;#0x4498

0000587a <.LBB85>:
  chThdResumeI(trp, msg);
    587a:	4d 43       	clr.b	r13		;
    587c:	3c 40 e2 1c 	mov	#7394,	r12	;#0x1ce2

00005880 <.LVL110>:
    5880:	b0 12 6a 47 	call	#18282		;#0x476a

00005884 <.LBB87>:
  chSysUnlockFromISR();
    5884:	b0 12 b8 44 	call	#17592		;#0x44b8

00005888 <.L67>:
        UCA0IE &= ~UCTXCPTIE;
    5888:	b2 c2 da 05 	bic	#8,	&0x05da	;r2 As==11

0000588c <.Loc.259.1>:
        UCA0IFG &= ~UCTXCPTIFG;
    588c:	b2 c2 dc 05 	bic	#8,	&0x05dc	;r2 As==11

00005890 <.Loc.260.1>:
        UARTDA0.txcpt_first = true;
    5890:	d2 43 1a 1d 	mov.b	#1,	&0x1d1a	;r3 As==01

00005894 <.Loc.262.1>:
      break;
    5894:	94 3f       	jmp	$-214    	;abs 0x57be

00005896 <uart_lld_init>:
    5896:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
 */
void uart_lld_init(void) {

#if MSP430X_UART_USE_UARTA0 == TRUE
  /* Driver initialization.*/
  uartObjectInit(&UARTDA0);
    589a:	b0 12 8e 4c 	call	#19598		;#0x4c8e

0000589e <L0>:
  UARTDA0.regs = (msp430x_uart_reg_t  *)(&UCA0CTLW0);
    589e:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    58a2:	bc 40 c0 05 	mov	#1472,	16(r12)	;#0x05c0, 0x0010
    58a6:	10 00 

000058a8 <.Loc.458.1>:
  UARTDA0.freq = MSP430X_UARTA0_CLK_FREQ;
    58a8:	bc 40 00 24 	mov	#9216,	12(r12)	;#0x2400, 0x000c
    58ac:	0c 00 
    58ae:	bc 40 f4 00 	mov	#244,	14(r12)	;#0x00f4, 0x000e
    58b2:	0e 00 

000058b4 <.Loc.459.1>:
  UARTDA0.dmareq_tx.dest_addr = (void*)(&UCA0TXBUF);
    58b4:	bc 40 ce 05 	mov	#1486,	20(r12)	;#0x05ce, 0x0014
    58b8:	14 00 

000058ba <.Loc.460.1>:
  UARTDA0.dmareq_tx.addr_mode = MSP430X_DMA_SRCINCR;
    58ba:	bc 40 00 03 	mov	#768,	24(r12)	;#0x0300, 0x0018
    58be:	18 00 

000058c0 <.Loc.461.1>:
  UARTDA0.dmareq_tx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    58c0:	bc 40 c0 00 	mov	#192,	26(r12)	;#0x00c0, 0x001a
    58c4:	1a 00 

000058c6 <.Loc.462.1>:
  UARTDA0.dmareq_tx.transfer_mode = MSP430X_DMA_SINGLE;
    58c6:	8c 43 1c 00 	mov	#0,	28(r12)	;r3 As==00, 0x001c

000058ca <.Loc.463.1>:
  UARTDA0.dmareq_tx.trigger = DMA_TRIGGER_MNEM(UCA0TXIFG);
    58ca:	bc 40 0f 00 	mov	#15,	30(r12)	;#0x000f, 0x001e
    58ce:	1e 00 

000058d0 <.Loc.464.1>:
  UARTDA0.dmareq_rx.source_addr = (void*)(&UCA0RXBUF);
    58d0:	bc 40 cc 05 	mov	#1484,	36(r12)	;#0x05cc, 0x0024
    58d4:	24 00 

000058d6 <.Loc.465.1>:
  UARTDA0.dmareq_rx.addr_mode = MSP430X_DMA_DSTINCR;
    58d6:	bc 40 00 0c 	mov	#3072,	42(r12)	;#0x0c00, 0x002a
    58da:	2a 00 

000058dc <.Loc.466.1>:
  UARTDA0.dmareq_rx.data_mode = (MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE);
    58dc:	bc 40 c0 00 	mov	#192,	44(r12)	;#0x00c0, 0x002c
    58e0:	2c 00 

000058e2 <.Loc.467.1>:
  UARTDA0.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
    58e2:	8c 43 2e 00 	mov	#0,	46(r12)	;r3 As==00, 0x002e

000058e6 <.Loc.468.1>:
  UARTDA0.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA0RXIFG);
    58e6:	bc 40 0e 00 	mov	#14,	48(r12)	;#0x000e, 0x0030
    58ea:	30 00 

000058ec <.Loc.469.1>:
  UARTDA0.txcpt_first = true;
    58ec:	dc 43 42 00 	mov.b	#1,	66(r12)	;r3 As==01, 0x0042

000058f0 <.Loc.526.1>:
  UARTDA3.dmareq_rx.transfer_mode = MSP430X_DMA_SINGLE;
  UARTDA3.dmareq_rx.trigger = DMA_TRIGGER_MNEM(UCA3RXIFG);
  UARTDA3.txcpt_first = true;
#endif
  
}
    58f0:	30 41       	ret			

000058f2 <uart_lld_start>:
 *
 * @param[in] uartp      pointer to the @p UARTDriver object
 *
 * @notapi
 */
void uart_lld_start(UARTDriver *uartp) {
    58f2:	6a 15       	pushm	#7,	r10	;16-bit words

000058f4 <.LCFI3>:
    58f4:	31 80 0a 00 	sub	#10,	r1	;#0x000a

000058f8 <.LCFI4>:
    58f8:	0a 4c       	mov	r12,	r10	;

000058fa <.Loc.537.1>:

  if (uartp->state != UART_STOP) {
    58fa:	dc 93 00 00 	cmp.b	#1,	0(r12)	;r3 As==01
    58fe:	15 24       	jz	$+44     	;abs 0x592a

00005900 <.Loc.539.1>:
    /* Waits for previous transmission to complete */
    while (!(uartp->regs->ifg & UCTXIFG));
    5900:	1c 4c 10 00 	mov	16(r12),r12	;0x00010

00005904 <.L95>:
    5904:	ac b3 1c 00 	bit	#2,	28(r12)	;r3 As==10, 0x001c
    5908:	fd 27       	jz	$-4      	;abs 0x5904

0000590a <.Loc.542.1>:
    
    /* Releases previously held channels */
    if (uartp->dma_acquired_tx) {
    590a:	ca 93 43 00 	cmp.b	#0,	67(r10)	;r3 As==00, 0x0043
    590e:	05 24       	jz	$+12     	;abs 0x591a

00005910 <.Loc.543.1>:
      dmaReleaseX(&(uartp->dma_tx));
    5910:	0c 4a       	mov	r10,	r12	;
    5912:	3c 50 36 00 	add	#54,	r12	;#0x0036
    5916:	b0 12 90 52 	call	#21136		;#0x5290

0000591a <.L96>:
    }
    if (uartp->dma_acquired_rx) {
    591a:	ca 93 44 00 	cmp.b	#0,	68(r10)	;r3 As==00, 0x0044
    591e:	05 24       	jz	$+12     	;abs 0x592a

00005920 <.Loc.546.1>:
      dmaReleaseX(&(uartp->dma_rx));
    5920:	0c 4a       	mov	r10,	r12	;
    5922:	3c 50 3c 00 	add	#60,	r12	;#0x003c
    5926:	b0 12 90 52 	call	#21136		;#0x5290

0000592a <.L94>:
    }
  }
  /* Configures the peripheral.*/
  /* Put the peripheral in reset */
  uartp->regs->ctlw0 |= UCSWRST;
    592a:	18 4a 10 00 	mov	16(r10),r8	;0x00010
    592e:	98 d3 00 00 	bis	#1,	0(r8)	;r3 As==01

00005932 <.LBB91>:
  uint16_t n = uartp->freq / uartp->config->baud;
    5932:	91 4a 0c 00 	mov	12(r10),6(r1)	;0x0000c
    5936:	06 00 
    5938:	91 4a 0e 00 	mov	14(r10),8(r1)	;0x0000e
    593c:	08 00 
    593e:	17 4a 04 00 	mov	4(r10),	r7	;
    5942:	91 47 0a 00 	mov	10(r7),	2(r1)	;0x0000a
    5946:	02 00 
    5948:	91 47 0c 00 	mov	12(r7),	4(r1)	;0x0000c
    594c:	04 00 
    594e:	3b 40 62 af 	mov	#-20638,r11	;#0xaf62
    5952:	1e 41 02 00 	mov	2(r1),	r14	;
    5956:	1f 41 04 00 	mov	4(r1),	r15	;
    595a:	1c 41 06 00 	mov	6(r1),	r12	;
    595e:	1d 41 08 00 	mov	8(r1),	r13	;
    5962:	81 4b 00 00 	mov	r11,	0(r1)	;
    5966:	8b 12       	call	r11		;

00005968 <.LVL119>:
    5968:	06 4c       	mov	r12,	r6	;
    596a:	09 4c       	mov	r12,	r9	;

0000596c <.Loc.158.1>:
  uint16_t frac = (uartp->freq - (n * uartp->config->baud)) * 10000 / uartp->config->baud;
    596c:	1e 41 02 00 	mov	2(r1),	r14	;
    5970:	1f 41 04 00 	mov	4(r1),	r15	;
    5974:	4d 43       	clr.b	r13		;
    5976:	b0 12 d4 b0 	call	#-20268	;#0xb0d4
    597a:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    597e:	4f 43       	clr.b	r15		;
    5980:	14 41 06 00 	mov	6(r1),	r4	;
    5984:	15 41 08 00 	mov	8(r1),	r5	;
    5988:	04 8c       	sub	r12,	r4	;
    598a:	05 7d       	subc	r13,	r5	;
    598c:	0c 44       	mov	r4,	r12	;
    598e:	0d 45       	mov	r5,	r13	;
    5990:	b0 12 d4 b0 	call	#-20268	;#0xb0d4
    5994:	1e 41 02 00 	mov	2(r1),	r14	;
    5998:	1f 41 04 00 	mov	4(r1),	r15	;
    599c:	2b 41       	mov	@r1,	r11	;
    599e:	8b 12       	call	r11		;

000059a0 <.LVL123>:
    59a0:	3d 40 6e 55 	mov	#21870,	r13	;#0x556e

000059a4 <.Loc.159.1>:
  if (n > 16) {
    59a4:	75 40 10 00 	mov.b	#16,	r5	;#0x0010
    59a8:	05 96       	cmp	r6,	r5	;
    59aa:	7b 2c       	jc	$+248    	;abs 0x5aa2

000059ac <.Loc.160.1>:
    uartp->regs->brw = (n >> 4);
    59ac:	0e 46       	mov	r6,	r14	;
    59ae:	5e 0f       	rrum	#4,	r14	;
    59b0:	88 4e 06 00 	mov	r14,	6(r8)	;

000059b4 <.Loc.162.1>:
    uartp->regs->mctlw = ((UCBRS(frac) << 8) | (n << 4) | UCOS16);
    59b4:	8d 12       	call	r13		;

000059b6 <.LVL124>:
    59b6:	43 18 09 59 	rpt #4 { rlax.w	r9		;
    59ba:	79 f0 ff 00 	and.b	#255,	r9	;#0x00ff
    59be:	19 d3       	bis	#1,	r9	;r3 As==01
    59c0:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    59c4:	09 dc       	bis	r12,	r9	;
    59c6:	88 49 08 00 	mov	r9,	8(r8)	;

000059ca <.L99>:
  set_baud(uartp);
  uartp->regs->abctl = (UCDELIM1 | UCDELIM0 | uartp->config->autobaud);
    59ca:	5c 47 0e 00 	mov.b	14(r7),	r12	;0x0000e
    59ce:	5c 0f       	rrum	#4,	r12	;
    59d0:	5c 03       	rrum	#1,	r12	;
    59d2:	5c f3       	and.b	#1,	r12	;r3 As==01
    59d4:	3c d0 30 00 	bis	#48,	r12	;#0x0030
    59d8:	88 4c 10 00 	mov	r12,	16(r8)	; 0x0010

000059dc <.Loc.557.1>:
#if MSP430X_UART_EXCLUSIVE_DMA == TRUE
  /* Acquire channels */
  bool b;
  if (uartp->config->dmatx_index < MSP430X_DMA_CHANNELS) {
    59dc:	5d 47 0f 00 	mov.b	15(r7),	r13	;0x0000f
    59e0:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    59e4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    59e6:	0c 9d       	cmp	r13,	r12	;
    59e8:	64 38       	jl	$+202    	;abs 0x5ab2

000059ea <.Loc.558.1>:
    b = dmaClaimI(&(uartp->dma_tx), uartp->config->dmatx_index);
    59ea:	0c 4a       	mov	r10,	r12	;
    59ec:	3c 50 36 00 	add	#54,	r12	;#0x0036
    59f0:	b0 12 de 51 	call	#20958		;#0x51de

000059f4 <.LVL126>:
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_tx = !b;
    59f4:	5d 43       	mov.b	#1,	r13	;r3 As==01
    59f6:	0c 93       	cmp	#0,	r12	;r3 As==00
    59f8:	01 24       	jz	$+4      	;abs 0x59fc
    59fa:	4d 43       	clr.b	r13		;

000059fc <.L101>:
    59fc:	ca 4d 43 00 	mov.b	r13,	67(r10)	; 0x0043

00005a00 <.L102>:
  }
  else {
    uartp->dma_acquired_tx = false;
  }
  if (uartp->config->dmarx_index < MSP430X_DMA_CHANNELS) {
    5a00:	1c 4a 04 00 	mov	4(r10),	r12	;
    5a04:	5d 4c 0f 00 	mov.b	15(r12),r13	;0x0000f
    5a08:	5d 0f       	rrum	#4,	r13	;
    5a0a:	6e 43       	mov.b	#2,	r14	;r3 As==10
    5a0c:	0e 9d       	cmp	r13,	r14	;
    5a0e:	54 38       	jl	$+170    	;abs 0x5ab8

00005a10 <.Loc.566.1>:
    b = dmaClaimI(&(uartp->dma_rx), uartp->config->dmarx_index);
    5a10:	0c 4a       	mov	r10,	r12	;
    5a12:	3c 50 3c 00 	add	#60,	r12	;#0x003c
    5a16:	b0 12 de 51 	call	#20958		;#0x51de

00005a1a <.LVL128>:
    osalDbgAssert(!b, "stream already allocated");
    uartp->dma_acquired_rx = !b;
    5a1a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5a1c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5a1e:	01 24       	jz	$+4      	;abs 0x5a22
    5a20:	4d 43       	clr.b	r13		;

00005a22 <.L104>:
    5a22:	ca 4d 44 00 	mov.b	r13,	68(r10)	; 0x0044

00005a26 <.L105>:
  else {
    uartp->dma_acquired_rx = false;
  }
#endif
  /* Configure callbacks */
  uartp->dmareq_tx.callback.callback = tx_cb;
    5a26:	ba 40 54 57 	mov	#22356,	32(r10)	;#0x5754, 0x0020
    5a2a:	20 00 

00005a2c <.Loc.576.1>:
  uartp->dmareq_tx.callback.args = uartp;
    5a2c:	8a 4a 22 00 	mov	r10,	34(r10)	; 0x0022

00005a30 <.Loc.577.1>:
  uartp->dmareq_rx.callback.callback = rx_cb;
    5a30:	ba 40 30 55 	mov	#21808,	50(r10)	;#0x5530, 0x0032
    5a34:	32 00 

00005a36 <.Loc.578.1>:
  uartp->dmareq_rx.callback.args = uartp;
    5a36:	8a 4a 34 00 	mov	r10,	52(r10)	; 0x0034

00005a3a <.Loc.580.1>:
#if MSP430X_UART_USE_UARTA0 == TRUE
  if (&UARTDA0 == uartp) {
    5a3a:	3a 90 d8 1c 	cmp	#7384,	r10	;#0x1cd8
    5a3e:	29 20       	jnz	$+84     	;abs 0x5a92

00005a40 <.Loc.581.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5a40:	1f 4a 10 00 	mov	16(r10),r15	;0x00010
    5a44:	1c 4a 04 00 	mov	4(r10),	r12	;

00005a48 <.Loc.585.1>:
        (uartp->config->order << 13) | 
        (uartp->config->char_size << 12) | 
        (uartp->config->stop_bits << 11) |
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5a48:	5d 4c 0e 00 	mov.b	14(r12),r13	;0x0000e
    5a4c:	0e 4d       	mov	r13,	r14	;
    5a4e:	5e 0f       	rrum	#4,	r14	;
    5a50:	5e 03       	rrum	#1,	r14	;
    5a52:	5e f3       	and.b	#1,	r14	;r3 As==01

00005a54 <.Loc.581.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5a54:	0c 4d       	mov	r13,	r12	;
    5a56:	4d 18 0c 5c 	rpt #14 { rlax.w	r12		;

00005a5a <.Loc.582.1>:
        (uartp->config->order << 13) | 
    5a5a:	09 4d       	mov	r13,	r9	;
    5a5c:	4a 18 09 59 	rpt #11 { rlax.w	r9		;
    5a60:	39 f0 00 20 	and	#8192,	r9	;#0x2000

00005a64 <.Loc.581.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5a64:	0c d9       	bis	r9,	r12	;

00005a66 <.Loc.587.1>:
        (MSP430X_UARTA0_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));
    5a66:	3c d0 b0 00 	bis	#176,	r12	;#0x00b0

00005a6a <.Loc.583.1>:
        (uartp->config->char_size << 12) | 
    5a6a:	09 4d       	mov	r13,	r9	;
    5a6c:	48 18 09 59 	rpt #9 { rlax.w	r9		;
    5a70:	39 f0 00 10 	and	#4096,	r9	;#0x1000

00005a74 <.Loc.587.1>:
        (UCRXEIE) | (UCBRKIE));
    5a74:	0c d9       	bis	r9,	r12	;

00005a76 <.Loc.584.1>:
        (uartp->config->stop_bits << 11) |
    5a76:	46 18 0d 5d 	rpt #7 { rlax.w	r13		;
    5a7a:	3d f0 00 08 	and	#2048,	r13	;#0x0800

00005a7e <.Loc.587.1>:
        (UCRXEIE) | (UCBRKIE));
    5a7e:	0c dd       	bis	r13,	r12	;

00005a80 <.Loc.585.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5a80:	0d 4e       	mov	r14,	r13	;
    5a82:	49 18 0d 5d 	rpt #10 { rlax.w	r13		;

00005a86 <.Loc.587.1>:
        (UCRXEIE) | (UCBRKIE));
    5a86:	0c dd       	bis	r13,	r12	;

00005a88 <.Loc.585.1>:
        (uartp->config->autobaud << 10) | (uartp->config->autobaud << 9) |
    5a88:	48 18 0e 5e 	rpt #9 { rlax.w	r14		;

00005a8c <.Loc.581.1>:
    uartp->regs->ctlw0 = ((uartp->config->parity << 14) | 
    5a8c:	0c de       	bis	r14,	r12	;
    5a8e:	8f 4c 00 00 	mov	r12,	0(r15)	;

00005a92 <.L106>:
        (MSP430X_UARTA3_UCSSEL) | 
        (UCRXEIE) | (UCBRKIE));

  }
#endif
  uartp->regs->ie |= UCRXIE;
    5a92:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5a96:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005a9a <.Loc.628.1>:
}
    5a9a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    5a9e:	64 17       	popm	#7,	r10	;16-bit words
    5aa0:	30 41       	ret			

00005aa2 <.L98>:
    uartp->regs->brw = n;
    5aa2:	88 46 06 00 	mov	r6,	6(r8)	;

00005aa6 <.Loc.166.1>:
    uartp->regs->mctlw = (UCBRS(frac) << 8);
    5aa6:	8d 12       	call	r13		;

00005aa8 <.LVL131>:
    5aa8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    5aac:	88 4c 08 00 	mov	r12,	8(r8)	;
    5ab0:	8c 3f       	jmp	$-230    	;abs 0x59ca

00005ab2 <.L100>:
    uartp->dma_acquired_tx = false;
    5ab2:	ca 43 43 00 	mov.b	#0,	67(r10)	;r3 As==00, 0x0043
    5ab6:	a4 3f       	jmp	$-182    	;abs 0x5a00

00005ab8 <.L103>:
    uartp->dma_acquired_rx = false;
    5ab8:	ca 43 44 00 	mov.b	#0,	68(r10)	;r3 As==00, 0x0044
    5abc:	b4 3f       	jmp	$-150    	;abs 0x5a26

00005abe <uart_lld_start_send>:
    5abe:	2a 15       	pushm	#3,	r10	;16-bit words

00005ac0 <.LCFI6>:
 * @param[in] n         number of data frames to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void uart_lld_start_send(UARTDriver *uartp, size_t n, const void *txbuf) {
    5ac0:	0a 4c       	mov	r12,	r10	;

00005ac2 <.Loc.661.1>:

  uartp->dmareq_tx.source_addr = txbuf;
    5ac2:	8c 4e       	mov	r14		; Warning: disassembly unreliable - not enough bytes available

00005ac4 <L0>:
    5ac4:	12 00       	mova	@r0+,	r2	;

00005ac6 <.Loc.662.1>:
  uartp->dmareq_tx.size = n;
    5ac6:	8c 4d 16 00 	mov	r13,	22(r12)	; 0x0016

00005aca <.Loc.664.1>:
  
  while (!(uartp->regs->ifg & UCTXIFG)) ;
    5aca:	1c 4c 10 00 	mov	16(r12),r12	;0x00010

00005ace <.L118>:
    5ace:	ac b3 1c 00 	bit	#2,	28(r12)	;r3 As==10, 0x001c
    5ad2:	fd 27       	jz	$-4      	;abs 0x5ace

00005ad4 <.Loc.665.1>:
  uartp->regs->ifg &= ~UCTXIFG;
    5ad4:	ac c3 1c 00 	bic	#2,	28(r12)	;r3 As==10, 0x001c

00005ad8 <.Loc.667.1>:

  init_transfer(&(uartp->dma_tx), &(uartp->dmareq_tx), &(uartp->dma_acquired_tx));
    5ad8:	09 4a       	mov	r10,	r9	;
    5ada:	39 50 36 00 	add	#54,	r9	;#0x0036
    5ade:	08 4a       	mov	r10,	r8	;
    5ae0:	38 50 12 00 	add	#18,	r8	;#0x0012

00005ae4 <.LBB97>:
  if (!(*acquired)) {
    5ae4:	ca 93 43 00 	cmp.b	#0,	67(r10)	;r3 As==00, 0x0043
    5ae8:	05 20       	jnz	$+12     	;abs 0x5af4

00005aea <.Loc.173.1>:
    dmaAcquireI(dma);
    5aea:	0c 49       	mov	r9,	r12	;
    5aec:	b0 12 82 51 	call	#20866		;#0x5182

00005af0 <.LVL140>:
    (*acquired) = true;
    5af0:	da 43 43 00 	mov.b	#1,	67(r10)	;r3 As==01, 0x0043

00005af4 <.L119>:
  dmaTransferI(dma, req);
    5af4:	0d 48       	mov	r8,	r13	;
    5af6:	0c 49       	mov	r9,	r12	;
    5af8:	b0 12 20 52 	call	#21024		;#0x5220

00005afc <.LBE97>:
  
  uartp->regs->ifg |= UCTXIFG;
    5afc:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5b00:	ac d3 1c 00 	bis	#2,	28(r12)	;r3 As==10, 0x001c

00005b04 <.Loc.670.1>:
}
    5b04:	28 17       	popm	#3,	r10	;16-bit words
    5b06:	30 41       	ret			

00005b08 <uart_lld_start_receive>:
 * @param[in] n         number of data frames to send
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void uart_lld_start_receive(UARTDriver *uartp, size_t n, void *rxbuf) {
    5b08:	2a 15       	pushm	#3,	r10	;16-bit words

00005b0a <.LCFI8>:
    5b0a:	0a 4c       	mov	r12,	r10	;

00005b0c <.Loc.708.1>:

  uartp->dmareq_rx.dest_addr = rxbuf;
    5b0c:	8c 4e 26 00 	mov	r14,	38(r12)	; 0x0026

00005b10 <.Loc.709.1>:
  uartp->dmareq_rx.size = n;
    5b10:	8c 4d 28 00 	mov	r13,	40(r12)	; 0x0028

00005b14 <.Loc.712.1>:
  
  /* Disable the Idle state RX interrupt in order to allow DMA to happen */
  uartp->regs->ie &= ~UCRXIE;
    5b14:	1c 4c 10 00 	mov	16(r12),r12	;0x00010

00005b18 <.LVL148>:
    5b18:	9c c3 1a 00 	bic	#1,	26(r12)	;r3 As==01, 0x001a

00005b1c <.Loc.714.1>:

  init_transfer(&(uartp->dma_rx), &(uartp->dmareq_rx), &(uartp->dma_acquired_rx));
    5b1c:	09 4a       	mov	r10,	r9	;
    5b1e:	39 50 3c 00 	add	#60,	r9	;#0x003c
    5b22:	08 4a       	mov	r10,	r8	;
    5b24:	38 50 24 00 	add	#36,	r8	;#0x0024

00005b28 <.LBB101>:
  if (!(*acquired)) {
    5b28:	ca 93 44 00 	cmp.b	#0,	68(r10)	;r3 As==00, 0x0044
    5b2c:	05 20       	jnz	$+12     	;abs 0x5b38

00005b2e <.Loc.173.1>:
    dmaAcquireI(dma);
    5b2e:	0c 49       	mov	r9,	r12	;
    5b30:	b0 12 82 51 	call	#20866		;#0x5182

00005b34 <.LVL150>:
    (*acquired) = true;
    5b34:	da 43 44 00 	mov.b	#1,	68(r10)	;r3 As==01, 0x0044

00005b38 <.L125>:
  dmaTransferI(dma, req);
    5b38:	0d 48       	mov	r8,	r13	;
    5b3a:	0c 49       	mov	r9,	r12	;
    5b3c:	b0 12 20 52 	call	#21024		;#0x5220

00005b40 <.LBE101>:
  
  if (uartp->regs->ifg & UCRXIFG) {
    5b40:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5b44:	9c b3 1c 00 	bit	#1,	28(r12)	;r3 As==01, 0x001c
    5b48:	04 24       	jz	$+10     	;abs 0x5b52

00005b4a <.Loc.718.1>:
    /* Toggle UCRXIFG to DMA the byte out of RXBUF */
    uartp->regs->ifg &= ~UCRXIFG;
    5b4a:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005b4e <.Loc.719.1>:
    uartp->regs->ifg |= UCRXIFG;
    5b4e:	9c d3 1c 00 	bis	#1,	28(r12)	;r3 As==01, 0x001c

00005b52 <.L124>:
  }
}
    5b52:	28 17       	popm	#3,	r10	;16-bit words
    5b54:	30 41       	ret			

00005b56 <uart_lld_stop_receive>:
 * @return              The number of data frames not received by the
 *                      stopped receive operation.
 *
 * @notapi
 */
size_t uart_lld_stop_receive(UARTDriver *uartp) {
    5b56:	2a 15       	pushm	#3,	r10	;16-bit words

00005b58 <.LCFI9>:
    5b58:	0a 4c       	mov	r12,	r10	;

00005b5a <.Loc.736.1>:

  size_t result = uartp->dma_rx.registers->sz;
    5b5a:	1c 4c 3c 00 	mov	60(r12),r12	;0x0003c

00005b5e <.LVL153>:
    5b5e:	18 4c 0a 00 	mov	10(r12),r8	;0x0000a

00005b62 <.Loc.737.1>:
  dmaCancelI(&(uartp->dma_rx));
    5b62:	09 4a       	mov	r10,	r9	;
    5b64:	39 50 3c 00 	add	#60,	r9	;#0x003c
    5b68:	0c 49       	mov	r9,	r12	;
    5b6a:	b0 12 c4 52 	call	#21188		;#0x52c4

00005b6e <.LVL155>:
  if (uartp->dma_acquired_rx) {
    5b6e:	ca 93 44 00 	cmp.b	#0,	68(r10)	;r3 As==00, 0x0044
    5b72:	03 24       	jz	$+8      	;abs 0x5b7a

00005b74 <.Loc.739.1>:
    dmaReleaseX(&(uartp->dma_rx));
    5b74:	0c 49       	mov	r9,	r12	;
    5b76:	b0 12 90 52 	call	#21136		;#0x5290

00005b7a <.L131>:
  }
  
  uartp->regs->ifg &= ~UCRXIFG;
    5b7a:	1c 4a 10 00 	mov	16(r10),r12	;0x00010
    5b7e:	9c c3 1c 00 	bic	#1,	28(r12)	;r3 As==01, 0x001c

00005b82 <.Loc.743.1>:
  uartp->regs->ie |= UCRXIE; /* to re-enable CharCB */
    5b82:	9c d3 1a 00 	bis	#1,	26(r12)	;r3 As==01, 0x001a

00005b86 <.Loc.746.1>:

  return result;
}
    5b86:	0c 48       	mov	r8,	r12	;
    5b88:	28 17       	popm	#3,	r10	;16-bit words
    5b8a:	30 41       	ret			

00005b8c <gpt_lld_init>:
  GPTDA0.regs = (msp430x_timer_reg_t *)(&TA0CTL);
  gptObjectInit(&GPTDA0);
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  /* Driver initialization.*/
  GPTDA1.regs = (msp430x_timer_reg_t *)(&TA1CTL);
    5b8c:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    5b90:	bc 40 80 03 	mov	#896,	4(r12)	;#0x0380
    5b94:	04 00 

00005b96 <.Loc.254.1>:
  gptObjectInit(&GPTDA1);
    5b96:	b0 12 94 4b 	call	#19348		;#0x4b94

00005b9a <.LVL0>:
#if MSP430X_GPT_USE_TB1 == TRUE
  /* Driver initialization.*/
  GPTDB1.regs = (msp430x_timer_reg_t *)(&TB1CTL);
  gptObjectInit(&GPTDB1);
#endif
}
    5b9a:	30 41       	ret			

00005b9c <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
    5b9c:	0a 15       	pushm	#1,	r10	;16-bit words

00005b9e <.LCFI0>:
    5b9e:	1a 4c 04 00 	mov	4(r12),	r10	;

00005ba2 <.Loc.299.1>:
    /* Calculate the divider */
    divider = MSP430X_TA0_CLK_FREQ / gptp->config->frequency;
  }
#endif
#if MSP430X_GPT_USE_TA1 == TRUE
  if (&GPTDA1 == gptp) {
    5ba2:	3c 90 1e 1d 	cmp	#7454,	r12	;#0x1d1e
    5ba6:	1d 20       	jnz	$+60     	;abs 0x5be2

00005ba8 <.Loc.301.1>:
    /* Make sure the timer is stopped */
    gptp->regs->ctl = MSP430X_TA1_TASSEL | TACLR;
    5ba8:	ba 40 04 01 	mov	#260,	0(r10)	;#0x0104
    5bac:	00 00 

00005bae <.Loc.304.1>:
    
    /* Calculate the divider */
    divider = MSP430X_TA1_CLK_FREQ / gptp->config->frequency;
    5bae:	1c 4c 02 00 	mov	2(r12),	r12	;

00005bb2 <.LVL3>:
    5bb2:	2e 4c       	mov	@r12,	r14	;
    5bb4:	1f 4c 02 00 	mov	2(r12),	r15	;
    5bb8:	3c 40 10 27 	mov	#10000,	r12	;#0x2710
    5bbc:	4d 43       	clr.b	r13		;
    5bbe:	b0 12 62 af 	call	#-20638	;#0xaf62

00005bc2 <.LVL4>:
    /* Calculate the divider */
    divider = MSP430X_TB0_CLK_FREQ / gptp->config->frequency;
  }
#endif
  osalDbgAssert(divider <= 64, "Invalid timer frequency w/ current config");
  if (!(divider & 0x00000007)) { /* divisible by 8 */
    5bc2:	0e 4c       	mov	r12,	r14	;
    5bc4:	7e f0 07 00 	and.b	#7,	r14	;
    5bc8:	0e 93       	cmp	#0,	r14	;r3 As==00
    5bca:	0e 20       	jnz	$+30     	;abs 0x5be8

00005bcc <.L8>:
    gptp->regs->ctl |= ID__8; /* Input Divider == 8 */
    5bcc:	ba d0 c0 00 	bis	#192,	0(r10)	;#0x00c0
    5bd0:	00 00 

00005bd2 <.Loc.346.1>:
    divider /= 8;
    5bd2:	b0 12 76 b0 	call	#-20362	;#0xb076

00005bd6 <.L5>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    divider /= 2;
  }
  osalDbgAssert(divider <= 8, "Invalid timer frequency w/ current config");
  gptp->regs->ex0 = divider - 1; /* Extra Divider */
    5bd6:	0e 4c       	mov	r12,	r14	;
    5bd8:	3e 53       	add	#-1,	r14	;r3 As==11
    5bda:	8a 4e 20 00 	mov	r14,	32(r10)	; 0x0020

00005bde <.Loc.359.1>:

}
    5bde:	0a 17       	popm	#1,	r10	;16-bit words
    5be0:	30 41       	ret			

00005be2 <.L7>:
  uint32_t divider = 0;
    5be2:	4c 43       	clr.b	r12		;

00005be4 <.LVL8>:
    5be4:	4d 43       	clr.b	r13		;
    5be6:	f2 3f       	jmp	$-26     	;abs 0x5bcc

00005be8 <.L4>:
  else if (!(divider & 0x00000003)) { /* divisible by 4 */
    5be8:	0e 4c       	mov	r12,	r14	;
    5bea:	7e f0 03 00 	and.b	#3,	r14	;
    5bee:	0e 93       	cmp	#0,	r14	;r3 As==00
    5bf0:	0a 20       	jnz	$+22     	;abs 0x5c06

00005bf2 <.Loc.349.1>:
    gptp->regs->ctl |= ID__4; /* Input Divider == 4 */
    5bf2:	ba 40 84 01 	mov	#388,	0(r10)	;#0x0184
    5bf6:	00 00 

00005bf8 <.Loc.350.1>:
    divider /= 4;
    5bf8:	40 19 0d 10 	rrux.w	r13		;
    5bfc:	0c 10       	rrc	r12		;
    5bfe:	40 19 0d 10 	rrux.w	r13		;
    5c02:	0c 10       	rrc	r12		;

00005c04 <.LVL10>:
    5c04:	e8 3f       	jmp	$-46     	;abs 0x5bd6

00005c06 <.L6>:
  else if (!(divider & 0x00000001)) { /* divisible by 2 */
    5c06:	0e 4c       	mov	r12,	r14	;
    5c08:	5e f3       	and.b	#1,	r14	;r3 As==01
    5c0a:	0e 93       	cmp	#0,	r14	;r3 As==00
    5c0c:	e4 23       	jnz	$-54     	;abs 0x5bd6

00005c0e <.Loc.353.1>:
    gptp->regs->ctl |= ID__2; /* Input Divider == 2 */
    5c0e:	ba 40 44 01 	mov	#324,	0(r10)	;#0x0144
    5c12:	00 00 

00005c14 <.Loc.354.1>:
    divider /= 2;
    5c14:	12 c3       	clrc			
    5c16:	0d 10       	rrc	r13		;
    5c18:	0c 10       	rrc	r12		;

00005c1a <.LVL12>:
    5c1a:	dd 3f       	jmp	$-68     	;abs 0x5bd6

00005c1c <gpt_lld_start_timer>:
    5c1c:	1e 4c 02 00 	mov	2(r12),	r14	;
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  /* Enable interrupt if callback required */
  if (NULL != gptp->config->callback) {
    5c20:	1c 4c       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00005c22 <L0>:
    5c22:	04 00       	mova	@r0,	r4	;

00005c24 <.LVL16>:
    5c24:	8e 93 04 00 	cmp	#0,	4(r14)	;r3 As==00
    5c28:	02 24       	jz	$+6      	;abs 0x5c2e

00005c2a <.Loc.390.1>:
    gptp->regs->ctl |= TAIE;
    5c2a:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

00005c2e <.L12>:
  }
  /* Clear timer */
  gptp->regs->ctl |= TACLR;
  /* CCR0 is the interval */
  gptp->regs->ccr0 = interval;
    5c2e:	8c 4d 12 00 	mov	r13,	18(r12)	; 0x0012

00005c32 <.Loc.397.1>:
  /* Up mode */
  gptp->regs->ctl |= MC__UP;
    5c32:	2d 4c       	mov	@r12,	r13	;

00005c34 <.LVL17>:
    5c34:	3d d0 14 00 	bis	#20,	r13	;#0x0014
    5c38:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005c3c <.Loc.398.1>:
}
    5c3c:	30 41       	ret			

00005c3e <gpt_lld_stop_timer>:
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  /* Stop timer */
  gptp->regs->ctl &= ~MC_3;
    5c3e:	1c 4c 04 00 	mov	4(r12),	r12	;

00005c42 <.LVL19>:
    5c42:	bc f0 cf ff 	and	#-49,	0(r12)	;#0xffcf
    5c46:	00 00 

00005c48 <.Loc.412.1>:

}
    5c48:	30 41       	ret			

00005c4a <ISR_TIMER1_A1_VECTOR>:
PORT_IRQ_HANDLER(TIMER1_A1_VECTOR) {
    5c4a:	bf 15       	pushm	#12,	r15	;16-bit words

00005c4c <.LCFI1>:
  OSAL_IRQ_PROLOGUE();
    5c4c:	d2 43 5c 1c 	mov.b	#1,	&0x1c5c	;r3 As==01
    5c50:	b0 12 d8 44 	call	#17624		;#0x44d8

00005c54 <.LVL20>:
  switch(__even_in_range(TA1IV, TA1IV_TAIFG)) {
    5c54:	1c 42 ae 03 	mov	&0x03ae,r12	;0x03ae
    5c58:	3c 90 0e 00 	cmp	#14,	r12	;#0x000e
    5c5c:	18 20       	jnz	$+50     	;abs 0x5c8e

00005c5e <.Loc.122.1>:
      if ((GPTDA1.state == GPT_ONESHOT || 
    5c5e:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    5c62:	6d 4c       	mov.b	@r12,	r13	;
    5c64:	7d 50 fd ff 	add.b	#-3,	r13	;#0xfffd
    5c68:	5e 43       	mov.b	#1,	r14	;r3 As==01
    5c6a:	4e 9d       	cmp.b	r13,	r14	;
    5c6c:	07 28       	jnc	$+16     	;abs 0x5c7c

00005c6e <.Loc.124.1>:
          NULL != GPTDA1.config->callback) {
    5c6e:	1d 4c 02 00 	mov	2(r12),	r13	;
    5c72:	1d 4d 04 00 	mov	4(r13),	r13	;

00005c76 <.Loc.123.1>:
            GPTDA1.state == GPT_CONTINUOUS) &&
    5c76:	0d 93       	cmp	#0,	r13	;r3 As==00
    5c78:	01 24       	jz	$+4      	;abs 0x5c7c

00005c7a <.Loc.125.1>:
        GPTDA1.config->callback(&GPTDA1);
    5c7a:	8d 12       	call	r13		;

00005c7c <.L17>:
      if (GPTDA1.state == GPT_ONESHOT) {
    5c7c:	e2 92 1e 1d 	cmp.b	#4,	&0x1d1e	;r2 As==10
    5c80:	06 20       	jnz	$+14     	;abs 0x5c8e

00005c82 <.Loc.129.1>:
        GPTDA1.state = GPT_READY;
    5c82:	e2 43 1e 1d 	mov.b	#2,	&0x1d1e	;r3 As==10

00005c86 <.Loc.130.1>:
        gpt_lld_stop_timer(&GPTDA1);
    5c86:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    5c8a:	b0 12 3e 5c 	call	#23614		;#0x5c3e

00005c8e <.L15>:
  OSAL_IRQ_EPILOGUE();
    5c8e:	b0 12 fe 44 	call	#17662		;#0x44fe

00005c92 <.LVL23>:
    5c92:	c2 43 5c 1c 	mov.b	#0,	&0x1c5c	;r3 As==00
    5c96:	b0 12 5a 44 	call	#17498		;#0x445a

00005c9a <.LVL24>:
    5c9a:	b0 12 b2 46 	call	#18098		;#0x46b2

00005c9e <.LVL25>:
    5c9e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5ca0:	02 24       	jz	$+6      	;abs 0x5ca6

00005ca2 <.Loc.135.1>:
    5ca2:	b0 12 ca 46 	call	#18122		;#0x46ca

00005ca6 <.L18>:
    5ca6:	b0 12 78 44 	call	#17528		;#0x4478

00005caa <.LVL27>:
}
    5caa:	b4 17       	popm	#12,	r15	;16-bit words
    5cac:	00 13       	reti			

00005cae <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    5cae:	32 c2       	dint			

00005cb0 <.Loc.46.1>:

}
    5cb0:	30 41       	ret			

00005cb2 <sx1278SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
uint8_t sx1278SetRegister(SX1278Driver *devp, uint8_t reg, 
    uint8_t value) {
    5cb2:	5a 15       	pushm	#6,	r10	;16-bit words

00005cb4 <.LCFI0>:
    5cb4:	0a 4c       	mov	r12,	r10	;
    5cb6:	46 4d       	mov.b	r13,	r6	;
    5cb8:	47 4e       	mov.b	r14,	r7	;

00005cba <.Loc.110.1>:
  osalDbgAssert(reg & 0x7FU, "register address out of bounds");
  
  osalDbgAssert(reg != 0x11U && reg != 0x3CU && reg != 0x42U, 
      "setting read-only registers");
  
  palClearLine(devp->config->ss_line);
    5cba:	28 4c       	mov	@r12,	r8	;
    5cbc:	1d 48 28 00 	mov	40(r8),	r13	;0x00028

00005cc0 <.LVL4>:
    5cc0:	09 4d       	mov	r13,	r9	;
    5cc2:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    5cc6:	15 49 02 00 	mov	2(r9),	r5	;
    5cca:	5c 43       	mov.b	#1,	r12	;r3 As==01

00005ccc <.LVL5>:
    5ccc:	5d 03       	rrum	#1,	r13	;
    5cce:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    5cd2:	b0 12 94 af 	call	#-20588	;#0xaf94

00005cd6 <.LVL6>:
    5cd6:	05 cc       	bic	r12,	r5	;
    5cd8:	89 45 02 00 	mov	r5,	2(r9)	;

00005cdc <.Loc.111.1>:
  spiPolledExchange(devp->config->spip, (reg | 0x80));
    5cdc:	39 40 0e 55 	mov	#21774,	r9	;#0x550e
    5ce0:	4d 46       	mov.b	r6,	r13	;
    5ce2:	7d d0 80 ff 	bis.b	#-128,	r13	;#0xff80
    5ce6:	2c 48       	mov	@r8,	r12	;
    5ce8:	89 12       	call	r9		;

00005cea <.LVL7>:
  reg = spiPolledExchange(devp->config->spip, value);
    5cea:	2c 4a       	mov	@r10,	r12	;
    5cec:	4d 47       	mov.b	r7,	r13	;
    5cee:	2c 4c       	mov	@r12,	r12	;
    5cf0:	89 12       	call	r9		;

00005cf2 <.LVL8>:
    5cf2:	49 4c       	mov.b	r12,	r9	;

00005cf4 <.LVL9>:
  palSetLine(devp->config->ss_line);
    5cf4:	2c 4a       	mov	@r10,	r12	;
    5cf6:	1d 4c 28 00 	mov	40(r12),r13	;0x00028
    5cfa:	0a 4d       	mov	r13,	r10	;

00005cfc <.LVL10>:
    5cfc:	3a f0 ff 0f 	and	#4095,	r10	;#0x0fff
    5d00:	18 4a 02 00 	mov	2(r10),	r8	;
    5d04:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5d06:	5d 03       	rrum	#1,	r13	;
    5d08:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    5d0c:	b0 12 94 af 	call	#-20588	;#0xaf94
    5d10:	0c d8       	bis	r8,	r12	;
    5d12:	8a 4c 02 00 	mov	r12,	2(r10)	;

00005d16 <.Loc.116.1>:
  
  return reg;
}
    5d16:	4c 49       	mov.b	r9,	r12	;
    5d18:	55 17       	popm	#6,	r10	;16-bit words
    5d1a:	30 41       	ret			

00005d1c <sx1278SetBitrate>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp pointer to the SX1278 driver
 * @param[in] rate bit rate in bits per second to be used
*/
void sx1278SetBitrate(SX1278Driver *devp, uint32_t rate) {
    5d1c:	3a 15       	pushm	#4,	r10	;16-bit words

00005d1e <.LCFI1>:
    5d1e:	09 4c       	mov	r12,	r9	;

00005d20 <.Loc.166.1>:
  uint32_t tmp = (SX1278_CLK_FREQ << 4)/ rate;
    5d20:	0f 4e       	mov	r14,	r15	;
    5d22:	0e 4d       	mov	r13,	r14	;
    5d24:	3c 40 00 80 	mov	#-32768,r12	;#0x8000

00005d28 <.LVL13>:
    5d28:	3d 40 84 1e 	mov	#7812,	r13	;#0x1e84

00005d2c <.LVL14>:
    5d2c:	b0 12 62 af 	call	#-20638	;#0xaf62
    5d30:	07 4c       	mov	r12,	r7	;

00005d32 <.LVL16>:
  uint16_t regs = tmp >> 4;
    5d32:	b0 12 70 b0 	call	#-20368	;#0xb070

00005d36 <.LVL17>:
    5d36:	08 4c       	mov	r12,	r8	;

00005d38 <.Loc.172.1>:
  uint8_t frac = tmp & 0x000F;
  
  osalDbgAssert(rate < 300000, "bit rate too high");
  
  sx1278SetRegister(devp, RegBitrateMsb, (regs >> 8));
    5d38:	3a 40 b2 5c 	mov	#23730,	r10	;#0x5cb2
    5d3c:	0e 4c       	mov	r12,	r14	;
    5d3e:	5e 0f       	rrum	#4,	r14	;
    5d40:	5e 0f       	rrum	#4,	r14	;
    5d42:	6d 43       	mov.b	#2,	r13	;r3 As==10
    5d44:	0c 49       	mov	r9,	r12	;
    5d46:	8a 12       	call	r10		;

00005d48 <.LVL19>:
  sx1278SetRegister(devp, RegBitrateLsb, (regs & 0x00FF));
    5d48:	4e 48       	mov.b	r8,	r14	;
    5d4a:	7d 40 03 00 	mov.b	#3,	r13	;
    5d4e:	0c 49       	mov	r9,	r12	;
    5d50:	8a 12       	call	r10		;

00005d52 <.LVL20>:
  sx1278SetRegister(devp, RegBitrateFrac, frac);
    5d52:	4e 47       	mov.b	r7,	r14	;
    5d54:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    5d58:	7d 40 5d 00 	mov.b	#93,	r13	;#0x005d
    5d5c:	0c 49       	mov	r9,	r12	;
    5d5e:	8a 12       	call	r10		;

00005d60 <.LVL21>:
}
    5d60:	37 17       	popm	#4,	r10	;16-bit words
    5d62:	30 41       	ret			

00005d64 <sx1278SetDeviation>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
void sx1278SetDeviation(SX1278Driver *devp, uint32_t fdev) {
    5d64:	2a 15       	pushm	#3,	r10	;16-bit words

00005d66 <.LCFI2>:
    5d66:	09 4c       	mov	r12,	r9	;

00005d68 <.Loc.186.1>:
  /* Fancy math for freq / FSTEP to correct for roundings */
  uint16_t regs = ((fdev << 11) + (SX1278_CLK_FREQ >> 9)) / 
    5d68:	0c 4d       	mov	r13,	r12	;

00005d6a <.LVL23>:
    5d6a:	0d 4e       	mov	r14,	r13	;

00005d6c <.LVL24>:
    5d6c:	b0 12 aa af 	call	#-20566	;#0xafaa
    5d70:	3e 40 48 e8 	mov	#-6072,	r14	;#0xe848
    5d74:	5f 43       	mov.b	#1,	r15	;r3 As==01
    5d76:	3c 50 24 f4 	add	#-3036,	r12	;#0xf424
    5d7a:	0d 63       	adc	r13		;
    5d7c:	b0 12 62 af 	call	#-20638	;#0xaf62
    5d80:	08 4c       	mov	r12,	r8	;

00005d82 <.Loc.191.1>:
    (SX1278_CLK_FREQ >> 8);
  
  osalDbgAssert(fdev < 200000, "deviation too high");
  
  sx1278SetRegister(devp, RegFdevMsb, (regs >> 8));
    5d82:	3a 40 b2 5c 	mov	#23730,	r10	;#0x5cb2
    5d86:	0e 4c       	mov	r12,	r14	;
    5d88:	5e 0f       	rrum	#4,	r14	;
    5d8a:	5e 0f       	rrum	#4,	r14	;
    5d8c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    5d8e:	0c 49       	mov	r9,	r12	;
    5d90:	8a 12       	call	r10		;

00005d92 <.LVL28>:
  sx1278SetRegister(devp, RegFdevLsb, (regs & 0x00FF));
    5d92:	4e 48       	mov.b	r8,	r14	;
    5d94:	7d 40 05 00 	mov.b	#5,	r13	;
    5d98:	0c 49       	mov	r9,	r12	;
    5d9a:	8a 12       	call	r10		;

00005d9c <.LVL29>:
}
    5d9c:	28 17       	popm	#3,	r10	;16-bit words
    5d9e:	30 41       	ret			

00005da0 <sx1278SetFrequency>:
 * @pre     The SX1278 driver must be initialized
 * 
 * @param[in] devp      pointer to the SX1278 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
void sx1278SetFrequency(SX1278Driver *devp, uint32_t freq) {
    5da0:	5a 15       	pushm	#6,	r10	;16-bit words

00005da2 <.LCFI3>:
    5da2:	09 4c       	mov	r12,	r9	;
    5da4:	0a 4d       	mov	r13,	r10	;
    5da6:	08 4e       	mov	r14,	r8	;

00005da8 <.Loc.204.1>:
  /* Fancy math for freq / FSTEP to keep everything from rounding */
  uint32_t regs = (((freq + (SX1278_CLK_FREQ >> 12)) / 
    5da8:	3e 40 09 3d 	mov	#15625,	r14	;#0x3d09
    5dac:	4f 43       	clr.b	r15		;
    5dae:	0c 4d       	mov	r13,	r12	;

00005db0 <.LVL31>:
    5db0:	3c 50 84 1e 	add	#7812,	r12	;#0x1e84
    5db4:	0d 48       	mov	r8,	r13	;

00005db6 <.LVL32>:
    5db6:	0d 63       	adc	r13		;
    5db8:	b0 12 62 af 	call	#-20638	;#0xaf62
    5dbc:	05 4c       	mov	r12,	r5	;
    5dbe:	b0 12 b6 af 	call	#-20554	;#0xafb6
    5dc2:	06 4c       	mov	r12,	r6	;
    5dc4:	07 4d       	mov	r13,	r7	;

00005dc6 <.Loc.207.1>:
        (SX1278_CLK_FREQ >> 11)) << 8);
  
  if ((freq >= 137000000 && freq <= 175000000) || 
    5dc6:	0d 4a       	mov	r10,	r13	;
    5dc8:	3d 50 c0 8b 	add	#-29760,r13	;#0x8bc0
    5dcc:	0c 48       	mov	r8,	r12	;
    5dce:	3c 60 d5 f7 	addc	#-2091,	r12	;#0xf7d5
    5dd2:	3e 40 43 02 	mov	#579,	r14	;#0x0243
    5dd6:	0e 9c       	cmp	r12,	r14	;
    5dd8:	06 28       	jnc	$+14     	;abs 0x5de6
    5dda:	0c 9e       	cmp	r14,	r12	;
    5ddc:	14 20       	jnz	$+42     	;abs 0x5e06
    5dde:	3c 40 80 d5 	mov	#-10880,r12	;#0xd580
    5de2:	0c 9d       	cmp	r13,	r12	;
    5de4:	10 2c       	jc	$+34     	;abs 0x5e06

00005de6 <.L12>:
      (freq >= 410000000 && freq <= 525000000)) {
    5de6:	0d 4a       	mov	r10,	r13	;
    5de8:	3d 50 80 e5 	add	#-6784,	r13	;#0xe580
    5dec:	0c 48       	mov	r8,	r12	;
    5dee:	3c 60 8f e7 	addc	#-6257,	r12	;#0xe78f

00005df2 <.Loc.207.1>:
  if ((freq >= 137000000 && freq <= 175000000) || 
    5df2:	3e 40 da 06 	mov	#1754,	r14	;#0x06da
    5df6:	0e 9c       	cmp	r12,	r14	;
    5df8:	25 28       	jnc	$+76     	;abs 0x5e44
    5dfa:	0c 9e       	cmp	r14,	r12	;
    5dfc:	04 20       	jnz	$+10     	;abs 0x5e06
    5dfe:	3c 40 c0 c2 	mov	#-15680,r12	;#0xc2c0
    5e02:	0c 9d       	cmp	r13,	r12	;
    5e04:	1f 28       	jnc	$+64     	;abs 0x5e44

00005e06 <.L6>:
    /* Bands 2 + 3 */
    devp->regs.opmode |= (1 << 3);
    5e06:	f9 d2 03 00 	bis.b	#8,	3(r9)	;r2 As==11

00005e0a <.L10>:
    osalDbgAssert(false, "frequency out of range");
  }
  
  osalDbgAssert(!(regs & 0xFF000000), "incorrect register value calculated");
  
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    5e0a:	3a 40 b2 5c 	mov	#23730,	r10	;#0x5cb2
    5e0e:	5e 49 03 00 	mov.b	3(r9),	r14	;
    5e12:	5d 43       	mov.b	#1,	r13	;r3 As==01
    5e14:	0c 49       	mov	r9,	r12	;
    5e16:	8a 12       	call	r10		;

00005e18 <.LVL36>:
  sx1278SetRegister(devp, RegFrfMsb, ((regs >> 16) & 0x000000FF));
    5e18:	0c 46       	mov	r6,	r12	;
    5e1a:	0d 47       	mov	r7,	r13	;
    5e1c:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    5e20:	b0 12 92 b0 	call	#-20334	;#0xb092
    5e24:	4e 4c       	mov.b	r12,	r14	;
    5e26:	7d 40 06 00 	mov.b	#6,	r13	;
    5e2a:	0c 49       	mov	r9,	r12	;
    5e2c:	8a 12       	call	r10		;

00005e2e <.LVL38>:
  sx1278SetRegister(devp, RegFrfMid, ((regs >> 8) & 0x000000FF));
    5e2e:	4e 45       	mov.b	r5,	r14	;
    5e30:	7d 40 07 00 	mov.b	#7,	r13	;
    5e34:	0c 49       	mov	r9,	r12	;
    5e36:	8a 12       	call	r10		;

00005e38 <.LVL39>:
  sx1278SetRegister(devp, RegFrfLsb, (regs & 0x000000FF));
    5e38:	4e 43       	clr.b	r14		;
    5e3a:	7d 42       	mov.b	#8,	r13	;r2 As==11
    5e3c:	0c 49       	mov	r9,	r12	;
    5e3e:	8a 12       	call	r10		;

00005e40 <.LVL40>:
}
    5e40:	55 17       	popm	#6,	r10	;16-bit words
    5e42:	30 41       	ret			

00005e44 <.L8>:
  else if (freq >= 862000000 && freq <= 1020000000) {
    5e44:	3a 50 80 ec 	add	#-4992,	r10	;#0xec80
    5e48:	38 60 9e cc 	addc	#-13154,r8	;#0xcc9e
    5e4c:	3e 40 6a 09 	mov	#2410,	r14	;#0x096a
    5e50:	0e 98       	cmp	r8,	r14	;
    5e52:	db 2b       	jnc	$-72     	;abs 0x5e0a
    5e54:	08 9e       	cmp	r14,	r8	;
    5e56:	04 20       	jnz	$+10     	;abs 0x5e60
    5e58:	3c 40 80 e3 	mov	#-7296,	r12	;#0xe380
    5e5c:	0c 9a       	cmp	r10,	r12	;
    5e5e:	d5 2b       	jnc	$-84     	;abs 0x5e0a

00005e60 <.L13>:
    devp->regs.opmode &= ~(1 << 3);
    5e60:	f9 c2 03 00 	bic.b	#8,	3(r9)	;r2 As==11
    5e64:	d2 3f       	jmp	$-90     	;abs 0x5e0a

00005e66 <sx1278SetPower>:
    5e66:	4e 43       	clr.b	r14		;

00005e68 <L0>:
 * @param[in] pow  output power will be programmed as [10+(.2 * pow)], in dBm
*/
void sx1278SetPower(SX1278Driver * devp, uint8_t pow) {
  (void)(pow);
  /* TODO figure out how to set power properly. also add closed loop. */
  sx1278SetRegister(devp, RegPaConfig, 0x00);
    5e68:	7d 40 09 00 	mov.b	#9,	r13	;

00005e6c <.LVL42>:
    5e6c:	b0 12 b2 5c 	call	#23730		;#0x5cb2

00005e70 <.LVL43>:
  return;
}
    5e70:	30 41       	ret			

00005e72 <sx1278SetSync>:
 * 
 * @param[in] devp  pointer to the SX1278 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
void sx1278SetSync(SX1278Driver *devp, SX1278_SYNC_TYPE sync) {
    5e72:	5a 15       	pushm	#6,	r10	;16-bit words

00005e74 <.LCFI4>:
    5e74:	07 4c       	mov	r12,	r7	;
    5e76:	05 4d       	mov	r13,	r5	;
    5e78:	06 4e       	mov	r14,	r6	;

00005e7a <.LVL48>:
  
  osalDbgAssert(sizeof(sync) <= 8, "requested sync length too large");

  reg |= devp->config->packet_config->preamble_polarity << 5;
  
  if (sync == 0) {
    5e7a:	0d de       	bis	r14,	r13	;

00005e7c <.LVL49>:
    5e7c:	0d 93       	cmp	#0,	r13	;r3 As==00
    5e7e:	23 24       	jz	$+72     	;abs 0x5ec6

00005e80 <.Loc.281.1>:
  reg |= devp->config->packet_config->preamble_polarity << 5;
    5e80:	2d 4c       	mov	@r12,	r13	;
    5e82:	1d 4d 2a 00 	mov	42(r13),r13	;0x0002a
    5e86:	6e 4d       	mov.b	@r13,	r14	;
    5e88:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00005e8c <.LVL50>:
  }
  else {
    reg |= 0x90 | (sizeof(sync) - 1);
  }
  
  sx1278SetRegister(devp, RegSyncConfig, reg);
    5e8c:	3a 40 b2 5c 	mov	#23730,	r10	;#0x5cb2
    5e90:	7e d0 93 ff 	bis.b	#-109,	r14	;#0xff93

00005e94 <.LVL51>:
    5e94:	7d 40 27 00 	mov.b	#39,	r13	;#0x0027

00005e98 <.LVL52>:
    5e98:	8a 12       	call	r10		;

00005e9a <.LVL53>:
    5e9a:	79 40 28 00 	mov.b	#40,	r9	;#0x0028
    5e9e:	78 40 18 00 	mov.b	#24,	r8	;#0x0018

00005ea2 <.L18>:
  
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    osalDbgAssert(((sync >> (8 * (sizeof(sync) - 1 - i))) & 0xFF) != 0x00, 
        "sync can't contain 0 bytes");
    sx1278SetRegister(devp, RegSyncValue1 + i, 
        (sync >> (8 * (sizeof(sync) - 1 - i)) & 0xFF));
    5ea2:	0c 45       	mov	r5,	r12	;
    5ea4:	0d 46       	mov	r6,	r13	;
    5ea6:	0e 48       	mov	r8,	r14	;
    5ea8:	0f 43       	clr	r15		;
    5eaa:	b0 12 92 b0 	call	#-20334	;#0xb092

00005eae <.Loc.296.1>:
    sx1278SetRegister(devp, RegSyncValue1 + i, 
    5eae:	4e 4c       	mov.b	r12,	r14	;
    5eb0:	4d 49       	mov.b	r9,	r13	;
    5eb2:	0c 47       	mov	r7,	r12	;
    5eb4:	8a 12       	call	r10		;

00005eb6 <.LVL56>:
    5eb6:	38 50 f8 ff 	add	#-8,	r8	;#0xfff8
    5eba:	4c 49       	mov.b	r9,	r12	;
    5ebc:	5c 53       	inc.b	r12		;
    5ebe:	49 4c       	mov.b	r12,	r9	;

00005ec0 <.Loc.293.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    5ec0:	7c 90 2c 00 	cmp.b	#44,	r12	;#0x002c
    5ec4:	ee 23       	jnz	$-34     	;abs 0x5ea2

00005ec6 <.L16>:
  }
}
    5ec6:	55 17       	popm	#6,	r10	;16-bit words
    5ec8:	30 41       	ret			

00005eca <sx1278ObjectInit>:
 * @init
 */
void sx1278ObjectInit(SX1278Driver *devp) {
  
  /* Set all the stored registers to their reset states */
  devp->regs.opmode = 0x09;
    5eca:	fc 40 09 00 	mov.b	#9,	3(r12)	;
    5ece:	03 00 

00005ed0 <.Loc.511.1>:
  devp->regs.seq_config = 0x00;
    5ed0:	cc 43 04 00 	mov.b	#0,	4(r12)	;r3 As==00

00005ed4 <.Loc.513.1>:
  
  devp->state = SX1278_STOP;
    5ed4:	dc 43 02 00 	mov.b	#1,	2(r12)	;r3 As==01

00005ed8 <.Loc.514.1>:
}
    5ed8:	30 41       	ret			

00005eda <spi_callback>:

void spi_callback(SPIDriver *spip) {
    5eda:	3a 15       	pushm	#4,	r10	;16-bit words

00005edc <.LCFI7>:
    5edc:	08 4c       	mov	r12,	r8	;

00005ede <.Loc.517.1>:
  palSetLine(SX1278D1.config->ss_line);
    5ede:	3a 40 24 1d 	mov	#7460,	r10	;#0x1d24
    5ee2:	2c 4a       	mov	@r10,	r12	;

00005ee4 <.LVL91>:
    5ee4:	1d 4c 28 00 	mov	40(r12),r13	;0x00028
    5ee8:	09 4d       	mov	r13,	r9	;
    5eea:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    5eee:	17 49 02 00 	mov	2(r9),	r7	;
    5ef2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5ef4:	5d 03       	rrum	#1,	r13	;
    5ef6:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    5efa:	b0 12 94 af 	call	#-20588	;#0xaf94
    5efe:	0c d7       	bis	r7,	r12	;
    5f00:	89 4c 02 00 	mov	r12,	2(r9)	;

00005f04 <.Loc.518.1>:
  if (SX1278D1.callback != NULL) {
    5f04:	1d 4a 06 00 	mov	6(r10),	r13	;
    5f08:	0d 93       	cmp	#0,	r13	;r3 As==00
    5f0a:	02 24       	jz	$+6      	;abs 0x5f10

00005f0c <.Loc.519.1>:
    SX1278D1.callback(spip);
    5f0c:	0c 48       	mov	r8,	r12	;
    5f0e:	8d 12       	call	r13		;

00005f10 <.L37>:
  }
}
    5f10:	37 17       	popm	#4,	r10	;16-bit words
    5f12:	30 41       	ret			

00005f14 <sx1278Start>:
 * @param[in] devp      pointer to the @p SX1278Driver object
 * @param[in] config    pointer to the @p SX1278Config object
 *
 * @api
 */
void sx1278Start(SX1278Driver *devp, const SX1278Config *config) {
    5f14:	3a 15       	pushm	#4,	r10	;16-bit words

00005f16 <.LCFI8>:
    5f16:	0a 4c       	mov	r12,	r10	;
    5f18:	08 4d       	mov	r13,	r8	;

00005f1a <.Loc.533.1>:
  
  devp->config = config;
    5f1a:	8a 4d 00 00 	mov	r13,	0(r10)	;

00005f1e <.Loc.535.1>:
  /* Reset the device to get it into a known state */
  sx1278Reset(devp);
    5f1e:	b0 12 46 62 	call	#25158		;#0x6246

00005f22 <.LVL95>:
#if SX1278_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Add the SPI callback to the SPI config */
  config->spicfgp->end_cb = spi_callback;
    5f22:	1d 48 02 00 	mov	2(r8),	r13	;
    5f26:	bd 40 da 5e 	mov	#24282,	0(r13)	;#0x5eda
    5f2a:	00 00 

00005f2c <.Loc.542.1>:
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    5f2c:	2c 48       	mov	@r8,	r12	;
    5f2e:	b0 12 20 4c 	call	#19488		;#0x4c20

00005f32 <.LVL96>:
  /* Put the device into sleep mode */
  sx1278SetMode(devp, SX1278Sleep);
    5f32:	0c 4a       	mov	r10,	r12	;
    5f34:	b0 12 d0 62 	call	#25296		;#0x62d0

00005f38 <.LVL97>:
  /* Set device configuration */
  sx1278SetFrequency(devp, config->freq);
    5f38:	1d 48 08 00 	mov	8(r8),	r13	;
    5f3c:	1e 48 0a 00 	mov	10(r8),	r14	;0x0000a
    5f40:	0c 4a       	mov	r10,	r12	;
    5f42:	b0 12 a0 5d 	call	#23968		;#0x5da0

00005f46 <.LVL98>:
  sx1278SetDeviation(devp, config->fdev);
    5f46:	1d 48 0c 00 	mov	12(r8),	r13	;0x0000c
    5f4a:	1e 48 0e 00 	mov	14(r8),	r14	;0x0000e
    5f4e:	0c 4a       	mov	r10,	r12	;
    5f50:	b0 12 64 5d 	call	#23908		;#0x5d64

00005f54 <.LVL99>:
  sx1278SetBitrate(devp, config->bitrate);
    5f54:	1d 48 04 00 	mov	4(r8),	r13	;
    5f58:	1e 48 06 00 	mov	6(r8),	r14	;
    5f5c:	0c 4a       	mov	r10,	r12	;
    5f5e:	b0 12 1c 5d 	call	#23836		;#0x5d1c

00005f62 <.LVL100>:
  sx1278SetPower(devp, config->pow);
    5f62:	5d 48 11 00 	mov.b	17(r8),	r13	;0x00011
    5f66:	0c 4a       	mov	r10,	r12	;
    5f68:	b0 12 66 5e 	call	#24166		;#0x5e66

00005f6c <.LVL101>:
  sx1278SetPreambleLength(devp, config->preamble_len);
    5f6c:	17 48 12 00 	mov	18(r8),	r7	;0x00012

00005f70 <.LBB91>:
  sx1278SetRegister(devp, RegPreambleMsb, length >> 8);
    5f70:	39 40 b2 5c 	mov	#23730,	r9	;#0x5cb2
    5f74:	0e 47       	mov	r7,	r14	;
    5f76:	5e 0f       	rrum	#4,	r14	;
    5f78:	5e 0f       	rrum	#4,	r14	;
    5f7a:	7d 40 25 00 	mov.b	#37,	r13	;#0x0025
    5f7e:	0c 4a       	mov	r10,	r12	;
    5f80:	89 12       	call	r9		;

00005f82 <.LVL103>:
  sx1278SetRegister(devp, RegPreambleLsb, length & 0x00FF);
    5f82:	4e 47       	mov.b	r7,	r14	;
    5f84:	7d 40 26 00 	mov.b	#38,	r13	;#0x0026
    5f88:	0c 4a       	mov	r10,	r12	;
    5f8a:	89 12       	call	r9		;

00005f8c <.LBE91>:
  sx1278SetSync(devp, config->sync_word);
    5f8c:	1d 48 14 00 	mov	20(r8),	r13	;0x00014
    5f90:	1e 48 16 00 	mov	22(r8),	r14	;0x00016
    5f94:	0c 4a       	mov	r10,	r12	;
    5f96:	b0 12 72 5e 	call	#24178		;#0x5e72

00005f9a <.LVL105>:
  
  /* Configure the Top Level Sequencer to transmit when FiFo is filled */
  /* Set FromStart bits to 11 
  Don't set SequencerStart, SequencerStop, FromTransmit, and LowPowerSelection
  Don't care FromIdle, FromReceive, FromRxTimeout, FromPacketReceived */
  devp->regs.seq_config = 0x18;
    5f9a:	fa 40 18 00 	mov.b	#24,	4(r10)	;#0x0018
    5f9e:	04 00 

00005fa0 <.Loc.559.1>:
  
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    5fa0:	7e 40 18 00 	mov.b	#24,	r14	;#0x0018
    5fa4:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    5fa8:	0c 4a       	mov	r10,	r12	;
    5faa:	89 12       	call	r9		;

00005fac <.LVL106>:
  
  sx1278ConfigurePackets(devp, devp->config->packet_config);
    5fac:	2c 4a       	mov	@r10,	r12	;
    5fae:	18 4c 2a 00 	mov	42(r12),r8	;0x0002a

00005fb2 <.LBB93>:
  if (packet_config->format == SX1278Variable) {
    5fb2:	6c 48       	mov.b	@r8,	r12	;
    5fb4:	7c f0 03 00 	and.b	#3,	r12	;
    5fb8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    5fba:	3d 20       	jnz	$+124    	;abs 0x6036

00005fbc <.Loc.385.1>:
    reg |= 1 << 7;
    5fbc:	7f 40 80 00 	mov.b	#128,	r15	;#0x0080

00005fc0 <.L43>:
  reg |= packet_config->whitening << 6;
    5fc0:	6d 48       	mov.b	@r8,	r13	;
    5fc2:	0c 4d       	mov	r13,	r12	;
    5fc4:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    5fc8:	7c f0 40 00 	and.b	#64,	r12	;#0x0040

00005fcc <.Loc.394.1>:
  reg |= packet_config->manchester << 5;
    5fcc:	0e 4d       	mov	r13,	r14	;
    5fce:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;
    5fd2:	7e f0 20 00 	and.b	#32,	r14	;#0x0020

00005fd6 <.Loc.396.1>:
  reg |= packet_config->crc << 4;
    5fd6:	4c de       	bis.b	r14,	r12	;
    5fd8:	7d f0 10 00 	and.b	#16,	r13	;#0x0010
    5fdc:	4e 4c       	mov.b	r12,	r14	;
    5fde:	4e dd       	bis.b	r13,	r14	;

00005fe0 <.LVL109>:
  sx1278SetRegister(devp, RegPacketConfig1, reg);
    5fe0:	4e df       	bis.b	r15,	r14	;

00005fe2 <.LVL110>:
    5fe2:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

00005fe6 <.LVL111>:
    5fe6:	0c 4a       	mov	r10,	r12	;

00005fe8 <.LVL112>:
    5fe8:	89 12       	call	r9		;

00005fea <.LVL113>:
  if (packet_config->format == SX1278Fixed) {
    5fea:	6c 48       	mov.b	@r8,	r12	;
    5fec:	7c f0 03 00 	and.b	#3,	r12	;
    5ff0:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    5ff2:	23 20       	jnz	$+72     	;abs 0x603a

00005ff4 <.Loc.402.1>:
        0x40 | (devp->config->length >> 8));
    5ff4:	2c 4a       	mov	@r10,	r12	;
    5ff6:	1c 4c 2e 00 	mov	46(r12),r12	;0x0002e
    5ffa:	b0 12 00 b0 	call	#-20480	;#0xb000

00005ffe <.Loc.401.1>:
    sx1278SetRegister(devp, RegPacketConfig2, 
    5ffe:	4e 4c       	mov.b	r12,	r14	;
    6000:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    6004:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6008:	0c 4a       	mov	r10,	r12	;
    600a:	89 12       	call	r9		;

0000600c <.LVL115>:
    sx1278SetRegister(devp, RegPayloadLength, (devp->config->length & 0x00FF));
    600c:	2c 4a       	mov	@r10,	r12	;
    600e:	5e 4c 2e 00 	mov.b	46(r12),r14	;0x0002e
    6012:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    6016:	0c 4a       	mov	r10,	r12	;
    6018:	89 12       	call	r9		;

0000601a <.L45>:
  sx1278SetRegister(devp, RegDioMapping1, ((uint8_t *)(&dio_reg))[0]);
    601a:	4e 43       	clr.b	r14		;
    601c:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    6020:	0c 4a       	mov	r10,	r12	;
    6022:	89 12       	call	r9		;

00006024 <.LVL117>:
  sx1278SetRegister(devp, RegDioMapping2, ((uint8_t *)(&dio_reg))[1]);
    6024:	4e 43       	clr.b	r14		;
    6026:	7d 40 41 00 	mov.b	#65,	r13	;#0x0041
    602a:	0c 4a       	mov	r10,	r12	;
    602c:	89 12       	call	r9		;

0000602e <.LBE96>:

#if SX1278_SHARED_SPI
  spiReleaseBus(config->spip);
#endif
  
  devp->state = SX1278_IDLE;
    602e:	ea 43 02 00 	mov.b	#2,	2(r10)	;r3 As==10

00006032 <.Loc.570.1>:
}
    6032:	37 17       	popm	#4,	r10	;16-bit words
    6034:	30 41       	ret			

00006036 <.L46>:
  uint8_t reg = 0x00;
    6036:	4f 43       	clr.b	r15		;
    6038:	c3 3f       	jmp	$-120    	;abs 0x5fc0

0000603a <.L44>:
    sx1278SetRegister(devp, RegPacketConfig2, 0x40);
    603a:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    603e:	7d 40 31 00 	mov.b	#49,	r13	;#0x0031
    6042:	0c 4a       	mov	r10,	r12	;
    6044:	89 12       	call	r9		;

00006046 <.LVL121>:
    sx1278SetRegister(devp, RegPayloadLength, 0x00);
    6046:	4e 43       	clr.b	r14		;
    6048:	7d 40 32 00 	mov.b	#50,	r13	;#0x0032
    604c:	0c 4a       	mov	r10,	r12	;
    604e:	89 12       	call	r9		;

00006050 <.LVL122>:
    6050:	e4 3f       	jmp	$-54     	;abs 0x601a

00006052 <sx1278FifoWriteAsync>:
    6052:	1a 15       	pushm	#2,	r10	;16-bit words

00006054 <.LCFI11>:
  
  devp->state = SX1278_SLEEP;
}

__attribute__((optimize(0))) void sx1278FifoWriteAsync(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    6054:	31 82       	sub	#8,	r1	;r2 As==11

00006056 <L0>:
    6056:	81 4c 06 00 	mov	r12,	6(r1)	;
    605a:	81 4d 04 00 	mov	r13,	4(r1)	;
    605e:	81 4e 02 00 	mov	r14,	2(r1)	;
    6062:	81 4f 00 00 	mov	r15,	0(r1)	;

00006066 <.Loc.624.1>:
  devp->callback = cb;
    6066:	1c 41 06 00 	mov	6(r1),	r12	;
    606a:	ac 41 06 00 	mov	@r1,	6(r12)	;

0000606e <.Loc.625.1>:
  palClearLine(devp->config->ss_line);
    606e:	1c 41 06 00 	mov	6(r1),	r12	;
    6072:	2c 4c       	mov	@r12,	r12	;

00006074 <.LVL131>:
    6074:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    6078:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    607c:	0a 4c       	mov	r12,	r10	;
    607e:	1c 41 06 00 	mov	6(r1),	r12	;
    6082:	2c 4c       	mov	@r12,	r12	;
    6084:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    6088:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    608c:	19 4c 02 00 	mov	2(r12),	r9	;
    6090:	1c 41 06 00 	mov	6(r1),	r12	;
    6094:	2c 4c       	mov	@r12,	r12	;
    6096:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    609a:	0d 4c       	mov	r12,	r13	;

0000609c <.LVL132>:
    609c:	5d 03       	rrum	#1,	r13	;
    609e:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    60a2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    60a4:	b0 12 94 af 	call	#-20588	;#0xaf94

000060a8 <.LVL133>:
    60a8:	3c e3       	inv	r12		;
    60aa:	0c f9       	and	r9,	r12	;
    60ac:	8a 4c 02 00 	mov	r12,	2(r10)	;

000060b0 <.Loc.626.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    60b0:	1c 41 06 00 	mov	6(r1),	r12	;
    60b4:	2c 4c       	mov	@r12,	r12	;
    60b6:	2c 4c       	mov	@r12,	r12	;
    60b8:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    60bc:	b0 12 0e 55 	call	#21774		;#0x550e

000060c0 <.LVL134>:
  devp->config->spicfgp->end_cb = spi_callback;
    60c0:	1c 41 06 00 	mov	6(r1),	r12	;
    60c4:	2c 4c       	mov	@r12,	r12	;
    60c6:	1c 4c 02 00 	mov	2(r12),	r12	;
    60ca:	bc 40 da 5e 	mov	#24282,	0(r12)	;#0x5eda
    60ce:	00 00 

000060d0 <.Loc.628.1>:
  spiStartSend(devp->config->spip, n, buffer);
    60d0:	1c 41 06 00 	mov	6(r1),	r12	;
    60d4:	2c 4c       	mov	@r12,	r12	;
    60d6:	2c 4c       	mov	@r12,	r12	;
    60d8:	1e 41 02 00 	mov	2(r1),	r14	;
    60dc:	1d 41 04 00 	mov	4(r1),	r13	;
    60e0:	b0 12 40 4c 	call	#19520		;#0x4c40

000060e4 <.LVL135>:
}
    60e4:	03 43       	nop			
    60e6:	31 52       	add	#8,	r1	;r2 As==11

000060e8 <.LVL136>:
    60e8:	19 17       	popm	#2,	r10	;16-bit words
    60ea:	30 41       	ret			

000060ec <sx1278FifoWriteAsyncS>:

__attribute__((optimize(0))) void sx1278FifoWriteAsyncS(SX1278Driver * devp, size_t n, uint8_t * buffer,
    spicallback_t cb) {
    60ec:	1a 15       	pushm	#2,	r10	;16-bit words

000060ee <.LCFI13>:
    60ee:	31 82       	sub	#8,	r1	;r2 As==11

000060f0 <.LCFI14>:
    60f0:	81 4c 06 00 	mov	r12,	6(r1)	;
    60f4:	81 4d 04 00 	mov	r13,	4(r1)	;
    60f8:	81 4e 02 00 	mov	r14,	2(r1)	;
    60fc:	81 4f 00 00 	mov	r15,	0(r1)	;

00006100 <.Loc.633.1>:
  devp->callback = cb;
    6100:	1c 41 06 00 	mov	6(r1),	r12	;
    6104:	ac 41 06 00 	mov	@r1,	6(r12)	;

00006108 <.Loc.634.1>:
  palClearLine(devp->config->ss_line);
    6108:	1c 41 06 00 	mov	6(r1),	r12	;
    610c:	2c 4c       	mov	@r12,	r12	;

0000610e <.LVL138>:
    610e:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    6112:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    6116:	0a 4c       	mov	r12,	r10	;
    6118:	1c 41 06 00 	mov	6(r1),	r12	;
    611c:	2c 4c       	mov	@r12,	r12	;
    611e:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    6122:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    6126:	19 4c 02 00 	mov	2(r12),	r9	;
    612a:	1c 41 06 00 	mov	6(r1),	r12	;
    612e:	2c 4c       	mov	@r12,	r12	;
    6130:	1c 4c 28 00 	mov	40(r12),r12	;0x00028
    6134:	0d 4c       	mov	r12,	r13	;

00006136 <.LVL139>:
    6136:	5d 03       	rrum	#1,	r13	;
    6138:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    613c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    613e:	b0 12 94 af 	call	#-20588	;#0xaf94

00006142 <.LVL140>:
    6142:	3c e3       	inv	r12		;
    6144:	0c f9       	and	r9,	r12	;
    6146:	8a 4c 02 00 	mov	r12,	2(r10)	;

0000614a <.Loc.635.1>:
  spiPolledExchange(devp->config->spip, (RegFifo | 0x80));
    614a:	1c 41 06 00 	mov	6(r1),	r12	;
    614e:	2c 4c       	mov	@r12,	r12	;
    6150:	2c 4c       	mov	@r12,	r12	;
    6152:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    6156:	b0 12 0e 55 	call	#21774		;#0x550e

0000615a <.LVL141>:
  devp->config->spicfgp->end_cb = spi_callback;
    615a:	1c 41 06 00 	mov	6(r1),	r12	;
    615e:	2c 4c       	mov	@r12,	r12	;
    6160:	1c 4c 02 00 	mov	2(r12),	r12	;
    6164:	bc 40 da 5e 	mov	#24282,	0(r12)	;#0x5eda
    6168:	00 00 

0000616a <.Loc.637.1>:
  spiStartSendI(devp->config->spip, n, buffer);
    616a:	1c 41 06 00 	mov	6(r1),	r12	;
    616e:	2c 4c       	mov	@r12,	r12	;
    6170:	2c 4c       	mov	@r12,	r12	;
    6172:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6176:	00 00 
    6178:	1c 41 06 00 	mov	6(r1),	r12	;
    617c:	2c 4c       	mov	@r12,	r12	;
    617e:	2c 4c       	mov	@r12,	r12	;
    6180:	1e 41 02 00 	mov	2(r1),	r14	;
    6184:	1d 41 04 00 	mov	4(r1),	r13	;
    6188:	b0 12 ec 54 	call	#21740		;#0x54ec

0000618c <.LVL142>:
}
    618c:	03 43       	nop			
    618e:	31 52       	add	#8,	r1	;r2 As==11

00006190 <.LVL143>:
    6190:	19 17       	popm	#2,	r10	;16-bit words
    6192:	30 41       	ret			

00006194 <sx1278StartTransmit>:

size_t sx1278StartTransmit(SX1278Driver * devp, size_t n, uint8_t * buffer, 
    palcallback_t pal_cb, spicallback_t spi_cb) {
    6194:	3a 15       	pushm	#4,	r10	;16-bit words

00006196 <.LCFI15>:
    6196:	21 83       	decd	r1		;

00006198 <.LCFI16>:
    6198:	0a 4c       	mov	r12,	r10	;
    619a:	09 4d       	mov	r13,	r9	;
    619c:	08 4e       	mov	r14,	r8	;

0000619e <.Loc.645.1>:
  
  /* We're in Sleep or Standby, TLS isn't started yet */
  /* Set FifoThreshold to 25% or packet size, whichever's smaller */
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    619e:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018

000061a2 <.LVL145>:
    61a2:	0c 9d       	cmp	r13,	r12	;
    61a4:	4d 28       	jnc	$+156    	;abs 0x6240

000061a6 <.Loc.645.1>:
    61a6:	4e 4d       	mov.b	r13,	r14	;

000061a8 <.LVL146>:
    61a8:	7e 53       	add.b	#-1,	r14	;r3 As==11
    61aa:	3e f0 ff 00 	and	#255,	r14	;#0x00ff

000061ae <.L52>:
    61ae:	37 40 b2 5c 	mov	#23730,	r7	;#0x5cb2
    61b2:	7d 40 35 00 	mov.b	#53,	r13	;#0x0035

000061b6 <.LVL147>:
    61b6:	0c 4a       	mov	r10,	r12	;
    61b8:	81 4f 00 00 	mov	r15,	0(r1)	;
    61bc:	87 12       	call	r7		;

000061be <.LVL148>:
  /* Stop TLS */
  devp->regs.seq_config &= ~(0x80);
    61be:	5e 4a 04 00 	mov.b	4(r10),	r14	;
    61c2:	7e f0 7f 00 	and.b	#127,	r14	;#0x007f
    61c6:	ca 4e 04 00 	mov.b	r14,	4(r10)	;

000061ca <.Loc.648.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config | 0x40);
    61ca:	7e d0 40 00 	bis.b	#64,	r14	;#0x0040
    61ce:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    61d2:	0c 4a       	mov	r10,	r12	;
    61d4:	87 12       	call	r7		;

000061d6 <.LVL149>:
  /* Start TLS */
  devp->regs.seq_config |= 0x80;
    61d6:	5e 4a 04 00 	mov.b	4(r10),	r14	;
    61da:	7e d0 80 ff 	bis.b	#-128,	r14	;#0xff80
    61de:	ca 4e 04 00 	mov.b	r14,	4(r10)	;

000061e2 <.Loc.651.1>:
  sx1278SetRegister(devp, RegSeqConfig1, devp->regs.seq_config);
    61e2:	7d 40 36 00 	mov.b	#54,	r13	;#0x0036
    61e6:	0c 4a       	mov	r10,	r12	;
    61e8:	87 12       	call	r7		;

000061ea <.LBB103>:
  _disable_interrupts();
    61ea:	32 c2       	dint			

000061ec <.Loc.348.3>:
  asm volatile("nop");
    61ec:	03 43       	nop			

000061ee <.LBE103>:
  
  /* Configure FifoLevel interrupt */
  chSysLock();
    61ee:	b0 12 5a 44 	call	#17498		;#0x445a

000061f2 <.LVL151>:
  palLineEnableEventI(devp->config->dio_map[devp->config->irq_map[SX1278FifoLevel]],
    61f2:	2c 4a       	mov	@r10,	r12	;
    61f4:	5d 4c 19 00 	mov.b	25(r12),r13	;0x00019
    61f8:	3d 50 0d 00 	add	#13,	r13	;#0x000d
    61fc:	0d 5d       	rla	r13		;
    61fe:	0c 5d       	add	r13,	r12	;
    6200:	2c 4c       	mov	@r12,	r12	;
    6202:	2f 41       	mov	@r1,	r15	;
    6204:	6e 43       	mov.b	#2,	r14	;r3 As==10
    6206:	0d 4c       	mov	r12,	r13	;
    6208:	5d 03       	rrum	#1,	r13	;
    620a:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    620e:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    6212:	b0 12 1e 50 	call	#20510		;#0x501e

00006216 <.LVL152>:
      PAL_EVENT_MODE_FALLING_EDGE, pal_cb);
  chSysUnlock();
    6216:	b0 12 78 44 	call	#17528		;#0x4478

0000621a <.LBB105>:
  asm volatile("nop");
    621a:	03 43       	nop			

0000621c <.Loc.356.3>:
  _enable_interrupts();
    621c:	32 d2       	eint			
    621e:	03 43       	nop			

00006220 <.LBE105>:
  /* Fill the FIFO */
  uint8_t to_write = (n > 47 ? 47 : n);
    6220:	7c 40 2f 00 	mov.b	#47,	r12	;#0x002f
    6224:	0c 99       	cmp	r9,	r12	;
    6226:	01 2c       	jc	$+4      	;abs 0x622a
    6228:	09 4c       	mov	r12,	r9	;

0000622a <.L53>:
  sx1278FifoWriteAsync(devp, to_write, buffer, spi_cb);
    622a:	1f 41 0c 00 	mov	12(r1),	r15	;0x0000c
    622e:	0e 48       	mov	r8,	r14	;
    6230:	0d 49       	mov	r9,	r13	;
    6232:	0c 4a       	mov	r10,	r12	;
    6234:	b0 12 52 60 	call	#24658		;#0x6052

00006238 <.LVL155>:
  return to_write;
}
    6238:	0c 49       	mov	r9,	r12	;
    623a:	21 53       	incd	r1		;
    623c:	37 17       	popm	#4,	r10	;16-bit words
    623e:	30 41       	ret			

00006240 <.L54>:
  sx1278SetRegister(devp, RegFifoThresh, (n > 24 ? 23 : n-1));
    6240:	7e 40 17 00 	mov.b	#23,	r14	;#0x0017
    6244:	b4 3f       	jmp	$-150    	;abs 0x61ae

00006246 <sx1278Reset.isra.1>:
    6246:	3a 15       	pushm	#4,	r10	;16-bit words

00006248 <L0>:
static void sx1278Reset(SX1278Driver *devp) {
    6248:	0a 4c       	mov	r12,	r10	;

0000624a <.Loc.310.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    624a:	2c 4c       	mov	@r12,	r12	;
    624c:	19 4c 26 00 	mov	38(r12),r9	;0x00026
    6250:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6252:	0d 49       	mov	r9,	r13	;
    6254:	5d 03       	rrum	#1,	r13	;
    6256:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    625a:	b0 12 94 af 	call	#-20588	;#0xaf94
    625e:	38 40 3e 4f 	mov	#20286,	r8	;#0x4f3e
    6262:	7e 40 06 00 	mov.b	#6,	r14	;
    6266:	0d 4c       	mov	r12,	r13	;
    6268:	0c 49       	mov	r9,	r12	;
    626a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    626e:	88 12       	call	r8		;

00006270 <.LVL184>:
  palClearLine(devp->config->reset_line);
    6270:	2c 4a       	mov	@r10,	r12	;
    6272:	1d 4c 26 00 	mov	38(r12),r13	;0x00026
    6276:	09 4d       	mov	r13,	r9	;
    6278:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    627c:	17 49 02 00 	mov	2(r9),	r7	;
    6280:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6282:	5d 03       	rrum	#1,	r13	;
    6284:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    6288:	b0 12 94 af 	call	#-20588	;#0xaf94
    628c:	07 cc       	bic	r12,	r7	;
    628e:	89 47 02 00 	mov	r7,	2(r9)	;

00006292 <.LBB119>:
  chThdSleep(time);
    6292:	39 40 7c 47 	mov	#18300,	r9	;#0x477c
    6296:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6298:	89 12       	call	r9		;

0000629a <.LBE119>:
  palSetLine(devp->config->reset_line);
    629a:	2c 4a       	mov	@r10,	r12	;
    629c:	1d 4c 26 00 	mov	38(r12),r13	;0x00026
    62a0:	0a 4d       	mov	r13,	r10	;
    62a2:	3a f0 ff 0f 	and	#4095,	r10	;#0x0fff
    62a6:	17 4a 02 00 	mov	2(r10),	r7	;
    62aa:	5c 43       	mov.b	#1,	r12	;r3 As==01
    62ac:	5d 03       	rrum	#1,	r13	;
    62ae:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    62b2:	b0 12 94 af 	call	#-20588	;#0xaf94
    62b6:	07 dc       	bis	r12,	r7	;
    62b8:	8a 47 02 00 	mov	r7,	2(r10)	;

000062bc <.Loc.314.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLUP);
    62bc:	7e 40 03 00 	mov.b	#3,	r14	;
    62c0:	0d 4c       	mov	r12,	r13	;
    62c2:	0c 4a       	mov	r10,	r12	;
    62c4:	88 12       	call	r8		;

000062c6 <.LBB121>:
    62c6:	7c 40 05 00 	mov.b	#5,	r12	;
    62ca:	89 12       	call	r9		;

000062cc <.LBE121>:
}
    62cc:	37 17       	popm	#4,	r10	;16-bit words
    62ce:	30 41       	ret			

000062d0 <sx1278SetMode.constprop.5>:
  devp->regs.opmode = (devp->regs.opmode & 0xF8) | mode;
    62d0:	5e 4c 03 00 	mov.b	3(r12),	r14	;
    62d4:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    62d8:	cc 4e 03 00 	mov.b	r14,	3(r12)	;

000062dc <.Loc.330.1>:
  sx1278SetRegister(devp, RegOpMode, devp->regs.opmode);
    62dc:	5d 43       	mov.b	#1,	r13	;r3 As==01
    62de:	b0 12 b2 5c 	call	#23730		;#0x5cb2

000062e2 <.LVL193>:
}
    62e2:	30 41       	ret			

000062e4 <blockuntil_callback>:
  chSysLockFromISR();
    62e4:	b0 12 98 44 	call	#17560		;#0x4498

000062e8 <.LBB31>:
  chThdResumeI(trp, msg);
    62e8:	4d 43       	clr.b	r13		;
    62ea:	3c 40 2e 1d 	mov	#7470,	r12	;#0x1d2e
    62ee:	b0 12 6a 47 	call	#18282		;#0x476a

000062f2 <.LBB33>:
  chSysUnlockFromISR();
    62f2:	b0 12 b8 44 	call	#17592		;#0x44b8

000062f6 <.LBE33>:

static void blockuntil_callback(void) {
  osalSysLockFromISR();
  osalThreadResumeI(&tr, MSG_OK);
  osalSysUnlockFromISR();
}
    62f6:	30 41       	ret			

000062f8 <sx1212SetRegister.isra.0>:
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1212SetRegister(SX1212Driver *devp, uint8_t reg, 
    62f8:	3a 15       	pushm	#4,	r10	;16-bit words

000062fa <.LCFI0>:
    62fa:	0a 4c       	mov	r12,	r10	;
    62fc:	47 4d       	mov.b	r13,	r7	;
    62fe:	48 4e       	mov.b	r14,	r8	;

00006300 <.LVL8>:
  osalDbgAssert(reg != 20, "setting read-only registers");
  
  /* 00xxxxx0 */
  reg = (reg << 1);
  
  spiSelectI(devp->config->spip);
    6300:	2c 4c       	mov	@r12,	r12	;
    6302:	2c 4c       	mov	@r12,	r12	;
    6304:	b0 12 0c 54 	call	#21516		;#0x540c

00006308 <.LVL9>:
  spiPolledExchange(devp->config->spip, reg);
    6308:	2c 4a       	mov	@r10,	r12	;
    630a:	39 40 0e 55 	mov	#21774,	r9	;#0x550e
    630e:	0d 47       	mov	r7,	r13	;
    6310:	0d 5d       	rla	r13		;
    6312:	2c 4c       	mov	@r12,	r12	;
    6314:	89 12       	call	r9		;

00006316 <.LVL10>:
  reg = spiPolledExchange(devp->config->spip, value);
    6316:	2c 4a       	mov	@r10,	r12	;
    6318:	4d 48       	mov.b	r8,	r13	;
    631a:	2c 4c       	mov	@r12,	r12	;
    631c:	89 12       	call	r9		;

0000631e <.LVL11>:
    631e:	49 4c       	mov.b	r12,	r9	;

00006320 <.LVL12>:
  spiUnselectI(devp->config->spip);
    6320:	2c 4a       	mov	@r10,	r12	;
    6322:	2c 4c       	mov	@r12,	r12	;
    6324:	b0 12 3a 54 	call	#21562		;#0x543a

00006328 <.LVL13>:
  
  return reg;
}
    6328:	4c 49       	mov.b	r9,	r12	;
    632a:	37 17       	popm	#4,	r10	;16-bit words
    632c:	30 41       	ret			

0000632e <sx1212SetMode>:
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1212SetMode(SX1212Driver *devp, SX1212ModeConstants mode) {
  
  devp->regs.MCParam0 = (devp->regs.MCParam0 & 0x1F) | mode;
    632e:	5e 4c 02 00 	mov.b	2(r12),	r14	;
    6332:	7e f0 1f 00 	and.b	#31,	r14	;#0x001f
    6336:	4e dd       	bis.b	r13,	r14	;
    6338:	cc 4e 02 00 	mov.b	r14,	2(r12)	;

0000633c <.Loc.608.1>:
  sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    633c:	4d 43       	clr.b	r13		;

0000633e <.LVL15>:
    633e:	b0 12 f8 62 	call	#25336		;#0x62f8

00006342 <.LVL16>:
}
    6342:	30 41       	ret			

00006344 <sx1212Reset.isra.2>:
static void sx1212Reset(SX1212Driver *devp) {
    6344:	4a 15       	pushm	#5,	r10	;16-bit words

00006346 <.LCFI1>:
    6346:	0a 4c       	mov	r12,	r10	;

00006348 <.Loc.588.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    6348:	2c 4c       	mov	@r12,	r12	;
    634a:	19 4c 1c 00 	mov	28(r12),r9	;0x0001c
    634e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6350:	0d 49       	mov	r9,	r13	;
    6352:	5d 03       	rrum	#1,	r13	;
    6354:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    6358:	b0 12 94 af 	call	#-20588	;#0xaf94
    635c:	37 40 3e 4f 	mov	#20286,	r7	;#0x4f3e
    6360:	7e 40 06 00 	mov.b	#6,	r14	;
    6364:	0d 4c       	mov	r12,	r13	;
    6366:	0c 49       	mov	r9,	r12	;
    6368:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    636c:	87 12       	call	r7		;

0000636e <.LVL18>:
  palSetLine(devp->config->reset_line);
    636e:	2c 4a       	mov	@r10,	r12	;
    6370:	1d 4c 1c 00 	mov	28(r12),r13	;0x0001c
    6374:	09 4d       	mov	r13,	r9	;
    6376:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    637a:	18 49 02 00 	mov	2(r9),	r8	;
    637e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6380:	5d 03       	rrum	#1,	r13	;
    6382:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    6386:	b0 12 94 af 	call	#-20588	;#0xaf94
    638a:	0c d8       	bis	r8,	r12	;
    638c:	89 4c 02 00 	mov	r12,	2(r9)	;

00006390 <.LBB35>:
  chThdSleep(time);
    6390:	38 40 7c 47 	mov	#18300,	r8	;#0x477c
    6394:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6396:	88 12       	call	r8		;

00006398 <.LBE35>:
  palClearLine(devp->config->reset_line);
    6398:	2c 4a       	mov	@r10,	r12	;
    639a:	1a 4c 1c 00 	mov	28(r12),r10	;0x0001c
    639e:	09 4a       	mov	r10,	r9	;
    63a0:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    63a4:	16 49 02 00 	mov	2(r9),	r6	;
    63a8:	5a 03       	rrum	#1,	r10	;
    63aa:	4a 18 0a 11 	rpt #11 { rrax.w	r10		;
    63ae:	5c 43       	mov.b	#1,	r12	;r3 As==01
    63b0:	0d 4a       	mov	r10,	r13	;
    63b2:	b0 12 94 af 	call	#-20588	;#0xaf94
    63b6:	06 cc       	bic	r12,	r6	;
    63b8:	89 46 02 00 	mov	r6,	2(r9)	;

000063bc <.Loc.592.1>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLDOWN);
    63bc:	5c 43       	mov.b	#1,	r12	;r3 As==01
    63be:	0d 4a       	mov	r10,	r13	;
    63c0:	b0 12 94 af 	call	#-20588	;#0xaf94
    63c4:	6e 42       	mov.b	#4,	r14	;r2 As==10
    63c6:	0d 4c       	mov	r12,	r13	;
    63c8:	0c 49       	mov	r9,	r12	;
    63ca:	87 12       	call	r7		;

000063cc <.LBB37>:
    63cc:	7c 40 05 00 	mov.b	#5,	r12	;
    63d0:	88 12       	call	r8		;

000063d2 <.LBE37>:
}
    63d2:	46 17       	popm	#5,	r10	;16-bit words
    63d4:	30 41       	ret			

000063d6 <irq_block_with_timeout.isra.3>:
static msg_t irq_block_with_timeout(SX1212Driver *devp, ioline_t irq, 
    63d6:	3a 15       	pushm	#4,	r10	;16-bit words

000063d8 <.LCFI2>:
    63d8:	0a 4c       	mov	r12,	r10	;
    63da:	07 4d       	mov	r13,	r7	;

000063dc <.LBB49>:
  _disable_interrupts();
    63dc:	32 c2       	dint			

000063de <.Loc.348.3>:
  asm volatile("nop");
    63de:	03 43       	nop			

000063e0 <.LBE51>:
  chSysLock();
    63e0:	b0 12 5a 44 	call	#17498		;#0x445a

000063e4 <.LBE49>:
  palLineEnableEventI(irq, PAL_EVENT_MODE_RISING_EDGE, blockuntil_callback); 
    63e4:	09 4a       	mov	r10,	r9	;
    63e6:	39 f0 ff 0f 	and	#4095,	r9	;#0x0fff
    63ea:	5a 03       	rrum	#1,	r10	;
    63ec:	4a 18 0a 11 	rpt #11 { rrax.w	r10		;

000063f0 <.LVL29>:
    63f0:	48 4a       	mov.b	r10,	r8	;
    63f2:	3f 40 e4 62 	mov	#25316,	r15	;#0x62e4
    63f6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    63f8:	4d 48       	mov.b	r8,	r13	;
    63fa:	0c 49       	mov	r9,	r12	;
    63fc:	b0 12 1e 50 	call	#20510		;#0x501e

00006400 <.LVL30>:
  if (palReadLine(irq)) {
    6400:	2c 49       	mov	@r9,	r12	;
    6402:	0d 4a       	mov	r10,	r13	;
    6404:	b0 12 28 b0 	call	#-20440	;#0xb028
    6408:	1c b3       	bit	#1,	r12	;r3 As==01
    640a:	0f 24       	jz	$+32     	;abs 0x642a

0000640c <.Loc.243.1>:
    suspend_result = MSG_OK;
    640c:	82 43 2c cd 	mov	#0,	&0xcd2c	;r3 As==00

00006410 <.L8>:
  palLineDisableEventI(irq);
    6410:	4d 48       	mov.b	r8,	r13	;
    6412:	0c 49       	mov	r9,	r12	;
    6414:	b0 12 ba 50 	call	#20666		;#0x50ba

00006418 <.LBB53>:
  chSysUnlock();
    6418:	b0 12 78 44 	call	#17528		;#0x4478

0000641c <.LBB55>:
  asm volatile("nop");
    641c:	03 43       	nop			

0000641e <.Loc.356.3>:
  _enable_interrupts();
    641e:	32 d2       	eint			
    6420:	03 43       	nop			

00006422 <.LBE53>:
}
    6422:	1c 42 2c cd 	mov	&0xcd2c,r12	;0xcd2c
    6426:	37 17       	popm	#4,	r10	;16-bit words
    6428:	30 41       	ret			

0000642a <.L7>:
  return chThdSuspendTimeoutS(trp, timeout);
    642a:	0d 47       	mov	r7,	r13	;
    642c:	3c 40 2e 1d 	mov	#7470,	r12	;#0x1d2e
    6430:	b0 12 54 47 	call	#18260		;#0x4754

00006434 <.LBE57>:
    suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    6434:	82 4c 2c cd 	mov	r12,	&0xcd2c	;
    6438:	eb 3f       	jmp	$-40     	;abs 0x6410

0000643a <spi_mode_config>:
    643a:	2c 4c       	mov	@r12,	r12	;

0000643c <L0>:
  devp->config->spicfgp->end_cb = NULL;
    643c:	1d 4c 02 00 	mov	2(r12),	r13	;
    6440:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00

00006444 <.Loc.66.1>:
  devp->config->spip->regs->ctlw0 &= ~UCMODE1;
    6444:	2c 4c       	mov	@r12,	r12	;
    6446:	1c 4c 06 00 	mov	6(r12),	r12	;
    644a:	bc f0 ff fb 	and	#-1025,	0(r12)	;#0xfbff
    644e:	00 00 

00006450 <.Loc.67.1>:
}
    6450:	30 41       	ret			

00006452 <sx1212SetBitrate>:
void sx1212SetBitrate(SX1212Driver *devp, uint32_t rate) {
    6452:	6a 15       	pushm	#7,	r10	;16-bit words

00006454 <.LCFI4>:
    6454:	31 82       	sub	#8,	r1	;r2 As==11

00006456 <.LCFI5>:
    6456:	08 4c       	mov	r12,	r8	;

00006458 <.Loc.422.1>:
  rate = (SX1212_CLK_FREQ >> 1)/rate;
    6458:	39 40 62 af 	mov	#-20638,r9	;#0xaf62
    645c:	0f 4e       	mov	r14,	r15	;
    645e:	0e 4d       	mov	r13,	r14	;
    6460:	3c 40 00 a8 	mov	#-22528,r12	;#0xa800

00006464 <.LVL49>:
    6464:	7d 40 61 00 	mov.b	#97,	r13	;#0x0061

00006468 <.LVL50>:
    6468:	89 12       	call	r9		;

0000646a <.LVL51>:
    646a:	0a 4c       	mov	r12,	r10	;
    646c:	06 4d       	mov	r13,	r6	;

0000646e <.LVL52>:
  if (rate - 1 <= 255) {
    646e:	3c 53       	add	#-1,	r12	;r3 As==11
    6470:	07 4d       	mov	r13,	r7	;
    6472:	37 63       	addc	#-1,	r7	;r3 As==11
    6474:	07 93       	cmp	#0,	r7	;r3 As==00
    6476:	12 20       	jnz	$+38     	;abs 0x649c
    6478:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    647c:	0d 9c       	cmp	r12,	r13	;
    647e:	0e 28       	jnc	$+30     	;abs 0x649c

00006480 <.Loc.425.1>:
    sx1212SetRegister(devp, MCParam3, (rate & 0x00FF));
    6480:	39 40 f8 62 	mov	#25336,	r9	;#0x62f8
    6484:	4e 4a       	mov.b	r10,	r14	;
    6486:	7d 40 03 00 	mov.b	#3,	r13	;
    648a:	0c 48       	mov	r8,	r12	;
    648c:	89 12       	call	r9		;

0000648e <.LVL53>:
    sx1212SetRegister(devp, MCParam4, 0);
    648e:	4e 47       	mov.b	r7,	r14	;
    6490:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6492:	0c 48       	mov	r8,	r12	;
    6494:	89 12       	call	r9		;

00006496 <.L14>:
}
    6496:	31 52       	add	#8,	r1	;r2 As==11
    6498:	64 17       	popm	#7,	r10	;16-bit words
    649a:	30 41       	ret			

0000649c <.L15>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    649c:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    64a0:	4f 43       	clr.b	r15		;
    64a2:	0c 4a       	mov	r10,	r12	;
    64a4:	0d 46       	mov	r6,	r13	;
    64a6:	89 12       	call	r9		;
    64a8:	05 4c       	mov	r12,	r5	;
    64aa:	15 53       	inc	r5		;

000064ac <.LBE62>:
    uint8_t bestd = 0;
    64ac:	47 43       	clr.b	r7		;

000064ae <.Loc.429.1>:
    uint8_t bestc = 0;
    64ae:	81 47 04 00 	mov	r7,	4(r1)	;

000064b2 <.LBB63>:
      err = rate - (tmp * i);
    64b2:	34 40 c0 b0 	mov	#-20288,r4	;#0xb0c0

000064b6 <.Loc.442.1>:
      if (err == 0 || i*i > rate) break;
    64b6:	81 4a 06 00 	mov	r10,	6(r1)	;

000064ba <.L18>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    64ba:	7c 40 5c 00 	mov.b	#92,	r12	;#0x005c
    64be:	0c 95       	cmp	r5,	r12	;
    64c0:	0e 2c       	jc	$+30     	;abs 0x64de

000064c2 <.L20>:
    sx1212SetRegister(devp, MCParam3, bestc);
    64c2:	3a 40 f8 62 	mov	#25336,	r10	;#0x62f8

000064c6 <.LVL60>:
    64c6:	1d 41 04 00 	mov	4(r1),	r13	;
    64ca:	4e 4d       	mov.b	r13,	r14	;
    64cc:	7d 40 03 00 	mov.b	#3,	r13	;
    64d0:	0c 48       	mov	r8,	r12	;
    64d2:	8a 12       	call	r10		;

000064d4 <.LVL61>:
    sx1212SetRegister(devp, MCParam4, bestd);
    64d4:	4e 47       	mov.b	r7,	r14	;
    64d6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    64d8:	0c 48       	mov	r8,	r12	;
    64da:	8a 12       	call	r10		;

000064dc <.LBE61>:
}
    64dc:	dc 3f       	jmp	$-70     	;abs 0x6496

000064de <.L22>:
      tmp = rate / i;
    64de:	0e 45       	mov	r5,	r14	;
    64e0:	0f 43       	clr	r15		;
    64e2:	0c 4a       	mov	r10,	r12	;
    64e4:	0d 46       	mov	r6,	r13	;
    64e6:	89 12       	call	r9		;

000064e8 <.Loc.437.1>:
      err = rate - (tmp * i);
    64e8:	4e 4c       	mov.b	r12,	r14	;
    64ea:	4f 45       	mov.b	r5,	r15	;
    64ec:	0d 4f       	mov	r15,	r13	;
    64ee:	0c 4e       	mov	r14,	r12	;
    64f0:	81 4e 02 00 	mov	r14,	2(r1)	;
    64f4:	81 4f 00 00 	mov	r15,	0(r1)	;
    64f8:	84 12       	call	r4		;
    64fa:	4d 4a       	mov.b	r10,	r13	;
    64fc:	4d 8c       	sub.b	r12,	r13	;
    64fe:	4c 4d       	mov.b	r13,	r12	;
    6500:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006504 <.LVL66>:
      if (err < besterr) {
    6504:	1e 41 02 00 	mov	2(r1),	r14	;
    6508:	2f 41       	mov	@r1,	r15	;
    650a:	7c 93       	cmp.b	#-1,	r12	;r3 As==11
    650c:	09 24       	jz	$+20     	;abs 0x6520
    650e:	7f 53       	add.b	#-1,	r15	;r3 As==11
    6510:	3f f0 ff 00 	and	#255,	r15	;#0x00ff
    6514:	81 4f 04 00 	mov	r15,	4(r1)	;

00006518 <.LVL67>:
        bestd = tmp - 1;
    6518:	7e 53       	add.b	#-1,	r14	;r3 As==11
    651a:	47 4e       	mov.b	r14,	r7	;

0000651c <.LVL68>:
      if (err == 0 || i*i > rate) break;
    651c:	0d 93       	cmp	#0,	r13	;r3 As==00
    651e:	d1 27       	jz	$-92     	;abs 0x64c2

00006520 <.L19>:
    6520:	0d 45       	mov	r5,	r13	;
    6522:	0c 45       	mov	r5,	r12	;

00006524 <.LVL70>:
    6524:	84 12       	call	r4		;
    6526:	4d 43       	clr.b	r13		;
    6528:	0d 96       	cmp	r6,	r13	;
    652a:	03 20       	jnz	$+8      	;abs 0x6532
    652c:	81 9c 06 00 	cmp	r12,	6(r1)	;
    6530:	c8 2b       	jnc	$-110    	;abs 0x64c2

00006532 <.L24>:
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    6532:	15 53       	inc	r5		;
    6534:	c2 3f       	jmp	$-122    	;abs 0x64ba

00006536 <sx1212SetDeviation>:
    6536:	0a 15       	pushm	#1,	r10	;16-bit words

00006538 <.LCFI6>:
void sx1212SetDeviation(SX1212Driver *devp, uint32_t fdev) {
    6538:	0a 4c       	mov	r12,	r10	;

0000653a <L0>:
  uint16_t regs = (SX1212_CLK_FREQ >> 5) / fdev;
    653a:	0f 4e       	mov	r14,	r15	;
    653c:	0e 4d       	mov	r13,	r14	;
    653e:	3c 40 80 1a 	mov	#6784,	r12	;#0x1a80

00006542 <.LVL75>:
    6542:	7d 40 06 00 	mov.b	#6,	r13	;

00006546 <.LVL76>:
    6546:	b0 12 62 af 	call	#-20638	;#0xaf62

0000654a <.Loc.463.1>:
  sx1212SetRegister(devp, MCParam2, regs - 1);
    654a:	4e 4c       	mov.b	r12,	r14	;
    654c:	7e 53       	add.b	#-1,	r14	;r3 As==11
    654e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6550:	0c 4a       	mov	r10,	r12	;
    6552:	b0 12 f8 62 	call	#25336		;#0x62f8

00006556 <.LVL78>:
}
    6556:	0a 17       	popm	#1,	r10	;16-bit words
    6558:	30 41       	ret			

0000655a <sx1212SetFrequency>:
void sx1212SetFrequency(SX1212Driver *devp, uint32_t freq) {
    655a:	6a 15       	pushm	#7,	r10	;16-bit words

0000655c <.LCFI7>:
    655c:	31 80 10 00 	sub	#16,	r1	;#0x0010

00006560 <.LCFI8>:
    6560:	0a 4c       	mov	r12,	r10	;
    6562:	05 4d       	mov	r13,	r5	;
    6564:	04 4e       	mov	r14,	r4	;

00006566 <.LVL80>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    6566:	0c 4d       	mov	r13,	r12	;

00006568 <.LVL81>:
    6568:	0d 4e       	mov	r14,	r13	;

0000656a <.LVL82>:
    656a:	b0 12 ca af 	call	#-20534	;#0xafca
    656e:	81 4c 04 00 	mov	r12,	4(r1)	;
    6572:	81 4d 06 00 	mov	r13,	6(r1)	;

00006576 <.LVL84>:
    6576:	08 4c       	mov	r12,	r8	;
    6578:	09 4d       	mov	r13,	r9	;

0000657a <.LBB69>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    657a:	4e 43       	clr.b	r14		;

0000657c <.LBE69>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    657c:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    6580:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd

00006584 <.L33>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    6584:	0f 48       	mov	r8,	r15	;
    6586:	0f dc       	bis	r12,	r15	;
    6588:	1f b3       	bit	#1,	r15	;r3 As==01
    658a:	b6 24       	jz	$+366    	;abs 0x66f8

0000658c <.L36>:
  while((u & 1) == 0)
    658c:	0f 48       	mov	r8,	r15	;
    658e:	5f f3       	and.b	#1,	r15	;r3 As==01
    6590:	0f 93       	cmp	#0,	r15	;r3 As==00
    6592:	ba 24       	jz	$+374    	;abs 0x6708

00006594 <.L39>:
    while ((v & 1) == 0)
    6594:	0f 4c       	mov	r12,	r15	;
    6596:	5f f3       	and.b	#1,	r15	;r3 As==01
    6598:	0f 93       	cmp	#0,	r15	;r3 As==00
    659a:	ba 24       	jz	$+374    	;abs 0x6710

0000659c <.Loc.395.1>:
    if (u > v) {
    659c:	0d 99       	cmp	r9,	r13	;
    659e:	0a 28       	jnc	$+22     	;abs 0x65b4
    65a0:	09 9d       	cmp	r13,	r9	;
    65a2:	02 20       	jnz	$+6      	;abs 0x65a8
    65a4:	0c 98       	cmp	r8,	r12	;
    65a6:	06 28       	jnc	$+14     	;abs 0x65b4

000065a8 <.L64>:
    65a8:	06 4c       	mov	r12,	r6	;
    65aa:	07 4d       	mov	r13,	r7	;
    65ac:	0c 48       	mov	r8,	r12	;

000065ae <.LVL87>:
    65ae:	0d 49       	mov	r9,	r13	;
    65b0:	08 46       	mov	r6,	r8	;

000065b2 <.LVL88>:
    65b2:	09 47       	mov	r7,	r9	;

000065b4 <.L42>:
    v = v - u;
    65b4:	06 48       	mov	r8,	r6	;
    65b6:	07 49       	mov	r9,	r7	;
    65b8:	06 8c       	sub	r12,	r6	;
    65ba:	07 7d       	subc	r13,	r7	;

000065bc <.LVL90>:
  } while (v != 0);
    65bc:	0f 46       	mov	r6,	r15	;
    65be:	0f d7       	bis	r7,	r15	;
    65c0:	0f 93       	cmp	#0,	r15	;r3 As==00
    65c2:	ad 20       	jnz	$+348    	;abs 0x671e

000065c4 <.Loc.403.1>:
  return u << shift;
    65c4:	0f 43       	clr	r15		;
    65c6:	b0 12 de af 	call	#-20514	;#0xafde

000065ca <.LVL91>:
    65ca:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    65ce:	81 4d 0e 00 	mov	r13,	14(r1)	; 0x000e

000065d2 <.LBE73>:
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
    65d2:	0e 4c       	mov	r12,	r14	;
    65d4:	0f 4d       	mov	r13,	r15	;
    65d6:	3c 40 00 d0 	mov	#-12288,r12	;#0xd000
    65da:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    65de:	b0 12 62 af 	call	#-20638	;#0xaf62
    65e2:	81 4c 08 00 	mov	r12,	8(r1)	;
    65e6:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

000065ea <.L45>:
  while (r_mult - (75 * i) > 169) {
    65ea:	0d 93       	cmp	#0,	r13	;r3 As==00
    65ec:	9d 20       	jnz	$+316    	;abs 0x6728
    65ee:	7e 40 a9 00 	mov.b	#169,	r14	;#0x00a9
    65f2:	0e 9c       	cmp	r12,	r14	;
    65f4:	99 28       	jnc	$+308    	;abs 0x6728

000065f6 <.LVL95>:
  r = r_mult - 1;
    65f6:	4b 4c       	mov.b	r12,	r11	;
    65f8:	49 4b       	mov.b	r11,	r9	;
    65fa:	79 53       	add.b	#-1,	r9	;r3 As==11

000065fc <.L72>:
    r += r_mult;
    65fc:	39 f0 ff 00 	and	#255,	r9	;#0x00ff

00006600 <.LVL97>:
  while (r < 64 || r > 169) {
    6600:	4c 49       	mov.b	r9,	r12	;
    6602:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0
    6606:	7d 40 69 00 	mov.b	#105,	r13	;#0x0069
    660a:	4d 9c       	cmp.b	r12,	r13	;
    660c:	91 28       	jnc	$+292    	;abs 0x6730

0000660e <.Loc.511.1>:
  r -= r_mult;
    660e:	49 8b       	sub.b	r11,	r9	;

00006610 <.LVL98>:
    6610:	39 f0 ff 00 	and	#255,	r9	;#0x00ff

00006614 <.LVL99>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    6614:	36 40 62 af 	mov	#-20638,r6	;#0xaf62

00006618 <.L50>:
    r += r_mult;
    6618:	4c 49       	mov.b	r9,	r12	;
    661a:	4c 5b       	add.b	r11,	r12	;
    661c:	49 4c       	mov.b	r12,	r9	;

0000661e <.LVL101>:
  } while (r < 64 || r > 169 || s > p);
    661e:	7c 50 c0 ff 	add.b	#-64,	r12	;#0xffc0

00006622 <.LVL102>:
    6622:	7e 40 69 00 	mov.b	#105,	r14	;#0x0069
    6626:	4e 9c       	cmp.b	r12,	r14	;
    6628:	f7 2b       	jnc	$-16     	;abs 0x6618

0000662a <.Loc.514.1>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    662a:	1e 41 0c 00 	mov	12(r1),	r14	;0x0000c
    662e:	1f 41 0e 00 	mov	14(r1),	r15	;0x0000e
    6632:	1c 41 04 00 	mov	4(r1),	r12	;

00006636 <.LVL103>:
    6636:	1d 41 06 00 	mov	6(r1),	r13	;
    663a:	81 4b 00 00 	mov	r11,	0(r1)	;
    663e:	86 12       	call	r6		;
    6640:	0e 49       	mov	r9,	r14	;
    6642:	1e 53       	inc	r14		;
    6644:	3e b0 00 80 	bit	#-32768,r14	;#0x8000
    6648:	0f 7f       	subc	r15,	r15	;
    664a:	3f e3       	inv	r15		;
    664c:	b0 12 d4 b0 	call	#-20268	;#0xb0d4
    6650:	1e 41 08 00 	mov	8(r1),	r14	;
    6654:	1f 41 0a 00 	mov	10(r1),	r15	;0x0000a
    6658:	86 12       	call	r6		;
    665a:	81 4c 02 00 	mov	r12,	2(r1)	;

0000665e <.Loc.515.1>:
    p = (temp / 75) - 1;
    665e:	7e 40 4b 00 	mov.b	#75,	r14	;#0x004b
    6662:	4f 43       	clr.b	r15		;
    6664:	86 12       	call	r6		;
    6666:	48 4c       	mov.b	r12,	r8	;
    6668:	78 53       	add.b	#-1,	r8	;r3 As==11
    666a:	47 48       	mov.b	r8,	r7	;

0000666c <.Loc.516.1>:
    s = temp - ((p+1)*75);
    666c:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    6670:	0c 47       	mov	r7,	r12	;
    6672:	1c 53       	inc	r12		;
    6674:	b0 12 c0 b0 	call	#-20288	;#0xb0c0
    6678:	1d 41 02 00 	mov	2(r1),	r13	;
    667c:	4d 8c       	sub.b	r12,	r13	;
    667e:	4e 4d       	mov.b	r13,	r14	;
    6680:	81 4e 02 00 	mov	r14,	2(r1)	;

00006684 <.Loc.517.1>:
  } while (r < 64 || r > 169 || s > p);
    6684:	2b 41       	mov	@r1,	r11	;
    6686:	48 9d       	cmp.b	r13,	r8	;
    6688:	c7 2b       	jnc	$-112    	;abs 0x6618

0000668a <.Loc.519.1>:
  sx1212SetRegister(devp, MCParam6, r);
    668a:	38 40 f8 62 	mov	#25336,	r8	;#0x62f8
    668e:	4e 49       	mov.b	r9,	r14	;
    6690:	7d 40 06 00 	mov.b	#6,	r13	;
    6694:	0c 4a       	mov	r10,	r12	;
    6696:	88 12       	call	r8		;

00006698 <.LVL109>:
  sx1212SetRegister(devp, MCParam7, p);
    6698:	4e 47       	mov.b	r7,	r14	;
    669a:	7d 40 07 00 	mov.b	#7,	r13	;
    669e:	0c 4a       	mov	r10,	r12	;
    66a0:	88 12       	call	r8		;

000066a2 <.LVL110>:
  sx1212SetRegister(devp, MCParam8, s);
    66a2:	1c 41 02 00 	mov	2(r1),	r12	;
    66a6:	4e 4c       	mov.b	r12,	r14	;
    66a8:	7d 42       	mov.b	#8,	r13	;r2 As==11
    66aa:	0c 4a       	mov	r10,	r12	;
    66ac:	88 12       	call	r8		;

000066ae <.LVL111>:
  if (freq >= 300000000 && freq <= 330000000) {
    66ae:	0c 45       	mov	r5,	r12	;
    66b0:	3c 50 00 5d 	add	#23808,	r12	;#0x5d00
    66b4:	0d 44       	mov	r4,	r13	;
    66b6:	3d 60 1e ee 	addc	#-4578,	r13	;#0xee1e
    66ba:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    66be:	0e 9d       	cmp	r13,	r14	;
    66c0:	39 28       	jnc	$+116    	;abs 0x6734
    66c2:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    66c6:	04 20       	jnz	$+10     	;abs 0x66d0
    66c8:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    66cc:	0e 9c       	cmp	r12,	r14	;
    66ce:	32 28       	jnc	$+102    	;abs 0x6734

000066d0 <.L66>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    66d0:	59 4a 02 00 	mov.b	2(r10),	r9	;

000066d4 <.LVL112>:
    66d4:	79 f0 e0 ff 	and.b	#-32,	r9	;#0xffe0

000066d8 <.L75>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    66d8:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    66dc:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072

000066e0 <.L73>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    66e0:	86 12       	call	r6		;
    66e2:	4e 49       	mov.b	r9,	r14	;
    66e4:	4e dc       	bis.b	r12,	r14	;

000066e6 <.Loc.550.1>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    66e6:	ca 4e 02 00 	mov.b	r14,	2(r10)	;

000066ea <.Loc.552.1>:
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    66ea:	4d 43       	clr.b	r13		;
    66ec:	0c 4a       	mov	r10,	r12	;
    66ee:	88 12       	call	r8		;

000066f0 <.L32>:
}
    66f0:	31 50 10 00 	add	#16,	r1	;#0x0010
    66f4:	64 17       	popm	#7,	r10	;16-bit words
    66f6:	30 41       	ret			

000066f8 <.L34>:
    u >>= 1;
    66f8:	12 c3       	clrc			
    66fa:	09 10       	rrc	r9		;
    66fc:	08 10       	rrc	r8		;

000066fe <.Loc.385.1>:
    v >>= 1;
    66fe:	12 c3       	clrc			
    6700:	0d 10       	rrc	r13		;
    6702:	0c 10       	rrc	r12		;

00006704 <.Loc.383.1>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    6704:	1e 53       	inc	r14		;
    6706:	3e 3f       	jmp	$-386    	;abs 0x6584

00006708 <.L37>:
    u >>= 1;
    6708:	12 c3       	clrc			
    670a:	09 10       	rrc	r9		;
    670c:	08 10       	rrc	r8		;
    670e:	3e 3f       	jmp	$-386    	;abs 0x658c

00006710 <.L40>:
      v >>= 1;
    6710:	06 4c       	mov	r12,	r6	;
    6712:	07 4d       	mov	r13,	r7	;
    6714:	12 c3       	clrc			
    6716:	07 10       	rrc	r7		;
    6718:	06 10       	rrc	r6		;

0000671a <.LVL120>:
    671a:	0c 48       	mov	r8,	r12	;
    671c:	0d 49       	mov	r9,	r13	;

0000671e <.L44>:
    671e:	08 4c       	mov	r12,	r8	;
    6720:	09 4d       	mov	r13,	r9	;
    6722:	0c 46       	mov	r6,	r12	;
    6724:	0d 47       	mov	r7,	r13	;
    6726:	36 3f       	jmp	$-402    	;abs 0x6594

00006728 <.L46>:
    6728:	3c 50 b5 ff 	add	#-75,	r12	;#0xffb5
    672c:	3d 63       	addc	#-1,	r13	;r3 As==11
    672e:	5d 3f       	jmp	$-324    	;abs 0x65ea

00006730 <.L49>:
    r += r_mult;
    6730:	49 5b       	add.b	r11,	r9	;

00006732 <.LVL124>:
    6732:	64 3f       	jmp	$-310    	;abs 0x65fc

00006734 <.L52>:
  else if (freq >= 320000000 && freq <= 350000000) {
    6734:	0c 45       	mov	r5,	r12	;
    6736:	3c 50 00 30 	add	#12288,	r12	;#0x3000
    673a:	0d 44       	mov	r4,	r13	;
    673c:	3d 60 ed ec 	addc	#-4883,	r13	;#0xeced
    6740:	3e 40 c9 01 	mov	#457,	r14	;#0x01c9
    6744:	0e 9d       	cmp	r13,	r14	;
    6746:	0e 28       	jnc	$+30     	;abs 0x6764
    6748:	3d 90 c9 01 	cmp	#457,	r13	;#0x01c9
    674c:	04 20       	jnz	$+10     	;abs 0x6756
    674e:	3e 40 80 c3 	mov	#-15488,r14	;#0xc380
    6752:	0e 9c       	cmp	r12,	r14	;
    6754:	07 28       	jnc	$+16     	;abs 0x6764

00006756 <.L67>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    6756:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    675a:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    675e:	49 4e       	mov.b	r14,	r9	;

00006760 <.LVL126>:
    6760:	69 d2       	bis.b	#4,	r9	;r2 As==10
    6762:	ba 3f       	jmp	$-138    	;abs 0x66d8

00006764 <.L55>:
  else if (freq >= 350000000 && freq <= 390000000) {
    6764:	0c 45       	mov	r5,	r12	;
    6766:	3c 50 80 6c 	add	#27776,	r12	;#0x6c80
    676a:	0d 44       	mov	r4,	r13	;
    676c:	3d 60 23 eb 	addc	#-5341,	r13	;#0xeb23
    6770:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    6774:	0e 9d       	cmp	r13,	r14	;
    6776:	12 28       	jnc	$+38     	;abs 0x679c
    6778:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    677c:	04 20       	jnz	$+10     	;abs 0x6786
    677e:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    6782:	0e 9c       	cmp	r12,	r14	;
    6784:	0b 28       	jnc	$+24     	;abs 0x679c

00006786 <.L68>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    6786:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    678a:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    678e:	49 4e       	mov.b	r14,	r9	;

00006790 <.LVL128>:
    6790:	79 d2       	bis.b	#8,	r9	;r2 As==11

00006792 <.L74>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    6792:	3e 40 80 96 	mov	#-27008,r14	;#0x9680
    6796:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    679a:	a2 3f       	jmp	$-186    	;abs 0x66e0

0000679c <.L57>:
  else if (freq >= 390000000 && freq <= 430000000) {
    679c:	0c 45       	mov	r5,	r12	;
    679e:	3c 50 80 12 	add	#4736,	r12	;#0x1280
    67a2:	0d 44       	mov	r4,	r13	;
    67a4:	3d 60 c1 e8 	addc	#-5951,	r13	;#0xe8c1
    67a8:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    67ac:	0e 9d       	cmp	r13,	r14	;
    67ae:	0f 28       	jnc	$+32     	;abs 0x67ce
    67b0:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    67b4:	04 20       	jnz	$+10     	;abs 0x67be
    67b6:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    67ba:	0e 9c       	cmp	r12,	r14	;
    67bc:	08 28       	jnc	$+18     	;abs 0x67ce

000067be <.L69>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    67be:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    67c2:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    67c6:	49 4e       	mov.b	r14,	r9	;

000067c8 <.LVL130>:
    67c8:	79 d0 0c 00 	bis.b	#12,	r9	;#0x000c
    67cc:	e2 3f       	jmp	$-58     	;abs 0x6792

000067ce <.L59>:
  else if (freq >= 430000000 && freq <= 470000000) {
    67ce:	0c 45       	mov	r5,	r12	;
    67d0:	3c 50 80 b8 	add	#-18304,r12	;#0xb880
    67d4:	0d 44       	mov	r4,	r13	;
    67d6:	3d 60 5e e6 	addc	#-6562,	r13	;#0xe65e
    67da:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    67de:	0e 9d       	cmp	r13,	r14	;
    67e0:	0f 28       	jnc	$+32     	;abs 0x6800
    67e2:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    67e6:	04 20       	jnz	$+10     	;abs 0x67f0
    67e8:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    67ec:	0e 9c       	cmp	r12,	r14	;
    67ee:	08 28       	jnc	$+18     	;abs 0x6800

000067f0 <.L70>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    67f0:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    67f4:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    67f8:	49 4e       	mov.b	r14,	r9	;

000067fa <.LVL132>:
    67fa:	79 d0 10 00 	bis.b	#16,	r9	;#0x0010
    67fe:	c9 3f       	jmp	$-108    	;abs 0x6792

00006800 <.L61>:
  else if (freq >= 470000000 && freq <= 510000000) {
    6800:	0c 45       	mov	r5,	r12	;
    6802:	3c 50 80 5e 	add	#24192,	r12	;#0x5e80
    6806:	0d 44       	mov	r4,	r13	;
    6808:	3d 60 fc e3 	addc	#-7172,	r13	;#0xe3fc
    680c:	3e 40 62 02 	mov	#610,	r14	;#0x0262
    6810:	0e 9d       	cmp	r13,	r14	;
    6812:	6e 2b       	jnc	$-290    	;abs 0x66f0
    6814:	3d 90 62 02 	cmp	#610,	r13	;#0x0262
    6818:	04 20       	jnz	$+10     	;abs 0x6822
    681a:	3e 40 00 5a 	mov	#23040,	r14	;#0x5a00
    681e:	0e 9c       	cmp	r12,	r14	;
    6820:	67 2b       	jnc	$-304    	;abs 0x66f0

00006822 <.L71>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    6822:	5e 4a 02 00 	mov.b	2(r10),	r14	;
    6826:	7e f0 e0 ff 	and.b	#-32,	r14	;#0xffe0
    682a:	49 4e       	mov.b	r14,	r9	;

0000682c <.LVL134>:
    682c:	79 d0 14 00 	bis.b	#20,	r9	;#0x0014
    6830:	b0 3f       	jmp	$-158    	;abs 0x6792

00006832 <sx1212SetSync>:
    6832:	5a 15       	pushm	#6,	r10	;16-bit words

00006834 <.LCFI9>:
void sx1212SetSync(SX1212Driver *devp, SX1212_SYNC_TYPE sync) {
    6834:	05 4c       	mov	r12,	r5	;
    6836:	06 4d       	mov	r13,	r6	;
    6838:	07 4e       	mov	r14,	r7	;

0000683a <.LVL136>:
    683a:	7a 40 16 00 	mov.b	#22,	r10	;#0x0016
    683e:	79 40 18 00 	mov.b	#24,	r9	;#0x0018

00006842 <.LBB75>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    6842:	38 40 f8 62 	mov	#25336,	r8	;#0x62f8

00006846 <L0>:
        sync >> (8 * (sizeof(sync) - 1 - i)));
    6846:	0c 46       	mov	r6,	r12	;
    6848:	0d 47       	mov	r7,	r13	;
    684a:	0e 49       	mov	r9,	r14	;
    684c:	0f 43       	clr	r15		;
    684e:	b0 12 92 b0 	call	#-20334	;#0xb092

00006852 <.Loc.574.1>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    6852:	4e 4c       	mov.b	r12,	r14	;
    6854:	4d 4a       	mov.b	r10,	r13	;
    6856:	0c 45       	mov	r5,	r12	;
    6858:	88 12       	call	r8		;

0000685a <.LVL139>:
    685a:	39 50 f8 ff 	add	#-8,	r9	;#0xfff8
    685e:	4c 4a       	mov.b	r10,	r12	;
    6860:	5c 53       	inc.b	r12		;
    6862:	4a 4c       	mov.b	r12,	r10	;

00006864 <.Loc.573.1>:
  for (unsigned int i = 0; i < sizeof(sync); i++) {
    6864:	7c 90 1a 00 	cmp.b	#26,	r12	;#0x001a
    6868:	ee 23       	jnz	$-34     	;abs 0x6846

0000686a <.LBE75>:
}
    686a:	55 17       	popm	#6,	r10	;16-bit words
    686c:	30 41       	ret			

0000686e <sx1212SetRxBw>:
 * @param[in] bandwidth the receiver bandwidth to use minus one, in steps of 25 kHz
 * 
 * @note The bandwidth specifiedd here is for the active filter. Passive
 *       filter bandwidth is set automatically according to datasheet
 */
void sx1212SetRxBw(SX1212Driver *devp, uint8_t bandwidth) {
    686e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

00006872 <.Loc.734.1>:
  osalDbgAssert(bandwidth < 16, "requested bandwidth is too wide");
  
  /* Passive filter bandwidth to be between 3 and 4 times active filter 
   * bandwidth, per datasheet. This is precalculated because there's no obvious
   * mapping. */
  sx1212SetRegister(devp, RXParam0, (passive[bandwidth] << 4) | bandwidth);
    6872:	5e 4d ac bd 	mov.b	-16980(r13),r14	;0xffffbdac
    6876:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    687a:	4e dd       	bis.b	r13,	r14	;
    687c:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010

00006880 <.LVL141>:
    6880:	b0 12 f8 62 	call	#25336		;#0x62f8

00006884 <.LVL142>:
}
    6884:	30 41       	ret			

00006886 <sx1212Start>:
 * @param[in] devp      pointer to the @p SX1212Driver object
 * @param[in] config    pointer to the @p SX1212Config object
 *
 * @api
 */
void sx1212Start(SX1212Driver *devp, const SX1212Config *config) {
    6886:	3a 15       	pushm	#4,	r10	;16-bit words

00006888 <.LCFI10>:
    6888:	0a 4c       	mov	r12,	r10	;
    688a:	09 4d       	mov	r13,	r9	;

0000688c <.Loc.957.1>:
  
  devp->config = config;
    688c:	8a 4d 00 00 	mov	r13,	0(r10)	;

00006890 <.Loc.959.1>:
  /* Reset the device to get it into a known state */
  sx1212Reset(devp);
    6890:	b0 12 44 63 	call	#25412		;#0x6344

00006894 <.LVL144>:
  /* Set all the stored registers to their reset states */
  devp->regs.MCParam0 = 0x30;
    6894:	fa 40 30 00 	mov.b	#48,	2(r10)	;#0x0030
    6898:	02 00 

0000689a <.Loc.962.1>:
  devp->regs.IRQParam0 = 0x0F;
    689a:	fa 40 0f 00 	mov.b	#15,	3(r10)	;#0x000f
    689e:	03 00 

000068a0 <.Loc.965.1>:
  
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    68a0:	1d 49 02 00 	mov	2(r9),	r13	;
    68a4:	2c 49       	mov	@r9,	r12	;
    68a6:	b0 12 20 4c 	call	#19488		;#0x4c20

000068aa <.LVL145>:
  /* Put the SPI interface into Config mode */
  spi_mode_config(devp);
    68aa:	0c 4a       	mov	r10,	r12	;
    68ac:	b0 12 3a 64 	call	#25658		;#0x643a

000068b0 <.LVL146>:
  
  /* Put the device into sleep mode */
  sx1212SetMode(devp, SX1212Sleep);
    68b0:	4d 43       	clr.b	r13		;
    68b2:	0c 4a       	mov	r10,	r12	;
    68b4:	b0 12 2e 63 	call	#25390		;#0x632e

000068b8 <.LVL147>:
  /* Set device configuration */
  sx1212SetFrequency(devp, config->freq);
    68b8:	1d 49 0a 00 	mov	10(r9),	r13	;0x0000a
    68bc:	1e 49 0c 00 	mov	12(r9),	r14	;0x0000c
    68c0:	0c 4a       	mov	r10,	r12	;
    68c2:	b0 12 5a 65 	call	#25946		;#0x655a

000068c6 <.LVL148>:
  sx1212SetDeviation(devp, config->fdev);
    68c6:	1d 49 0e 00 	mov	14(r9),	r13	;0x0000e
    68ca:	1e 49 10 00 	mov	16(r9),	r14	;0x00010
    68ce:	0c 4a       	mov	r10,	r12	;
    68d0:	b0 12 36 65 	call	#25910		;#0x6536

000068d4 <.LVL149>:
  sx1212SetBitrate(devp, config->bitrate);
    68d4:	1d 49 06 00 	mov	6(r9),	r13	;
    68d8:	1e 49 08 00 	mov	8(r9),	r14	;
    68dc:	0c 4a       	mov	r10,	r12	;
    68de:	b0 12 52 64 	call	#25682		;#0x6452

000068e2 <.LVL150>:
  sx1212SetRxBw(devp, config->rx_bw);
    68e2:	5d 49 12 00 	mov.b	18(r9),	r13	;0x00012
    68e6:	0c 4a       	mov	r10,	r12	;
    68e8:	b0 12 6e 68 	call	#26734		;#0x686e

000068ec <.LVL151>:
  sx1212SetSync(devp, config->sync_word);
    68ec:	1d 49 16 00 	mov	22(r9),	r13	;0x00016
    68f0:	1e 49 18 00 	mov	24(r9),	r14	;0x00018
    68f4:	0c 4a       	mov	r10,	r12	;
    68f6:	b0 12 32 68 	call	#26674		;#0x6832

000068fa <.LVL152>:
    68fa:	38 40 f8 62 	mov	#25336,	r8	;#0x62f8

000068fe <.Loc.977.1>:
  if (config->packet_config != NULL) {
    68fe:	89 93 1e 00 	cmp	#0,	30(r9)	;r3 As==00, 0x001e
    6902:	6b 24       	jz	$+216    	;abs 0x69da

00006904 <.Loc.978.1>:
    sx1212ConfigurePackets(devp, devp->config->packet_config);
    6904:	2c 4a       	mov	@r10,	r12	;
    6906:	17 4c 1e 00 	mov	30(r12),r7	;0x0001e

0000690a <.LBB78>:
  sx1212SetRegister(devp, MCParam1, 0xA4);
    690a:	7e 40 a4 ff 	mov.b	#-92,	r14	;#0xffa4
    690e:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6910:	0c 4a       	mov	r10,	r12	;
    6912:	88 12       	call	r8		;

00006914 <.LVL154>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    6914:	6e 47       	mov.b	@r7,	r14	;
    6916:	44 18 0e 5e 	rpt #5 { rlax.w	r14		;
    691a:	7e f0 80 00 	and.b	#128,	r14	;#0x0080

0000691e <.Loc.763.1>:
     devp->config->length);
    691e:	2c 4a       	mov	@r10,	r12	;

00006920 <.Loc.762.1>:
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    6920:	5e dc 21 00 	bis.b	33(r12),r14	;0x00021
    6924:	7d 40 1c 00 	mov.b	#28,	r13	;#0x001c
    6928:	0c 4a       	mov	r10,	r12	;
    692a:	88 12       	call	r8		;

0000692c <.LVL155>:
  if (!packet_config->broadcast) {
    692c:	f7 b0 60 00 	bit.b	#96,	0(r7)	;#0x0060
    6930:	00 00 
    6932:	0b 20       	jnz	$+24     	;abs 0x694a

00006934 <.Loc.767.1>:
    packet_config->broadcast = packet_config->addressing;
    6934:	6d 47       	mov.b	@r7,	r13	;
    6936:	0c 4d       	mov	r13,	r12	;
    6938:	5c 0f       	rrum	#4,	r12	;
    693a:	5c f3       	and.b	#1,	r12	;r3 As==01
    693c:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    6940:	7d f0 9f ff 	and.b	#-97,	r13	;#0xff9f
    6944:	4d dc       	bis.b	r12,	r13	;
    6946:	c7 4d 00 00 	mov.b	r13,	0(r7)	;

0000694a <.L82>:
  if (packet_config->broadcast) {
    694a:	f7 b0 60 00 	bit.b	#96,	0(r7)	;#0x0060
    694e:	00 00 
    6950:	07 24       	jz	$+16     	;abs 0x6960

00006952 <.Loc.772.1>:
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
    6952:	2c 4a       	mov	@r10,	r12	;
    6954:	5e 4c 20 00 	mov.b	32(r12),r14	;0x00020
    6958:	7d 40 1d 00 	mov.b	#29,	r13	;#0x001d
    695c:	0c 4a       	mov	r10,	r12	;
    695e:	88 12       	call	r8		;

00006960 <.L83>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    6960:	d7 b3 00 00 	bit.b	#1,	0(r7)	;r3 As==01
    6964:	37 20       	jnz	$+112    	;abs 0x69d4
    6966:	4f 43       	clr.b	r15		;

00006968 <.L84>:
      (packet_config->whitening << 4) |
    6968:	6d 47       	mov.b	@r7,	r13	;
    696a:	0c 4d       	mov	r13,	r12	;
    696c:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    6970:	7c f0 10 00 	and.b	#16,	r12	;#0x0010

00006974 <.Loc.779.1>:
      (packet_config->crc << 3) |
    6974:	0e 4d       	mov	r13,	r14	;
    6976:	7e f2       	and.b	#8,	r14	;r2 As==11
    6978:	4c de       	bis.b	r14,	r12	;

0000697a <.Loc.780.1>:
      (packet_config->broadcast << 1));
    697a:	5d 0f       	rrum	#4,	r13	;
    697c:	7d f0 06 00 	and.b	#6,	r13	;

00006980 <.Loc.779.1>:
      (packet_config->crc << 3) |
    6980:	4e 4c       	mov.b	r12,	r14	;
    6982:	4e dd       	bis.b	r13,	r14	;

00006984 <.Loc.775.1>:
  sx1212SetRegister(devp, PKTParam2, 
    6984:	4e df       	bis.b	r15,	r14	;
    6986:	7d 40 1e 00 	mov.b	#30,	r13	;#0x001e
    698a:	0c 4a       	mov	r10,	r12	;
    698c:	88 12       	call	r8		;

0000698e <.LVL157>:
  sx1212SetRegister(devp, PKTParam3, ((!packet_config->crc_autoclear) << 7));
    698e:	6e 47       	mov.b	@r7,	r14	;
    6990:	3e e0 80 00 	xor	#128,	r14	;#0x0080
    6994:	7e f0 80 ff 	and.b	#-128,	r14	;#0xff80
    6998:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

0000699c <.L92>:
  }
  else {
    /* Buffered mode */
    sx1212SetRegister(devp, MCParam1, 0x64);
    699c:	0c 4a       	mov	r10,	r12	;
    699e:	88 12       	call	r8		;

000069a0 <.LVL159>:
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
  sx1212SetRegister(devp, RXParam2, 0x20 | 
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
    69a0:	5e 49 1a 00 	mov.b	26(r9),	r14	;0x0001a
    69a4:	4e 5e       	rla.b	r14		;

000069a6 <.Loc.987.1>:
  sx1212SetRegister(devp, RXParam2, 0x20 | 
    69a6:	7e d0 38 00 	bis.b	#56,	r14	;#0x0038
    69aa:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    69ae:	0c 4a       	mov	r10,	r12	;
    69b0:	88 12       	call	r8		;

000069b2 <.LVL160>:
  
  /* IRQParam2 - enable PLL lock */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    69b2:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    69b6:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    69ba:	0c 4a       	mov	r10,	r12	;
    69bc:	88 12       	call	r8		;

000069be <.LVL161>:
  
  /* Set Fifo size to 64 */
  sx1212SetRegister(devp, IRQParam0, 0xC0);
    69be:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    69c2:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    69c6:	0c 4a       	mov	r10,	r12	;
    69c8:	88 12       	call	r8		;

000069ca <.LVL162>:
  devp->regs.IRQParam0 = 0xC0;
    69ca:	fa 40 c0 ff 	mov.b	#-64,	3(r10)	;#0xffc0
    69ce:	03 00 

000069d0 <.Loc.1002.1>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(config->spip);
#endif

}
    69d0:	37 17       	popm	#4,	r10	;16-bit words
    69d2:	30 41       	ret			

000069d4 <.L87>:
      ((packet_config->format == SX1212Variable ? 1 : 0) << 7) | 
    69d4:	3f 40 80 ff 	mov	#-128,	r15	;#0xff80
    69d8:	c7 3f       	jmp	$-112    	;abs 0x6968

000069da <.L81>:
    sx1212SetRegister(devp, MCParam1, 0x64);
    69da:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    69de:	5d 43       	mov.b	#1,	r13	;r3 As==01
    69e0:	dd 3f       	jmp	$-68     	;abs 0x699c

000069e2 <sx1212ReceiveI>:
    69e2:	2a 15       	pushm	#3,	r10	;16-bit words

000069e4 <.LCFI12>:
      );
  
  return MSG_OK;
}

void sx1212ReceiveI(SX1212Driver * devp, size_t n, palcallback_t callback) {
    69e4:	09 4c       	mov	r12,	r9	;

000069e6 <L0>:
    69e6:	0a 4d       	mov	r13,	r10	;
    69e8:	08 4e       	mov	r14,	r8	;

000069ea <.Loc.1067.1>:
  static size_t fft;
  fft = n - 1;
  osalDbgCheckClassI();
    69ea:	b0 12 26 45 	call	#17702		;#0x4526

000069ee <.LVL171>:
  /* TODO state machine */
  
  /* IRQs are Fifoempty_B and Fifo_threshold */
  
  /* Configure the Fifo_threshold callback appropriately */
  palLineEnableEventI(SX1212_IRQ_1, PAL_EVENT_MODE_RISING_EDGE, callback);
    69ee:	0f 48       	mov	r8,	r15	;
    69f0:	5e 43       	mov.b	#1,	r14	;r3 As==01
    69f2:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    69f6:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    69fa:	b0 12 1e 50 	call	#20510		;#0x501e

000069fe <.LBB84>:
  sx1212SetRegister(devp, IRQParam0, (0xC0 | thresh));
    69fe:	7a d0 c0 ff 	bis.b	#-64,	r10	;#0xffc0

00006a02 <.LVL173>:
    6a02:	4e 4a       	mov.b	r10,	r14	;
    6a04:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    6a08:	0c 49       	mov	r9,	r12	;
    6a0a:	b0 12 f8 62 	call	#25336		;#0x62f8

00006a0e <.LVL174>:
  devp->regs.IRQParam0 = (0xC0 | thresh);
    6a0e:	c9 4a 03 00 	mov.b	r10,	3(r9)	;

00006a12 <.LBE84>:
  
  /* Set Fifo threshold */
  sx1212SetFifoThreshold(devp, n);
}
    6a12:	28 17       	popm	#3,	r10	;16-bit words
    6a14:	30 41       	ret			

00006a16 <sx1212StartReceive>:
msg_t sx1212StartReceive(SX1212Driver *devp, size_t n, palcallback_t callback) {
    6a16:	3a 15       	pushm	#4,	r10	;16-bit words

00006a18 <.LCFI13>:
    6a18:	0a 4c       	mov	r12,	r10	;
    6a1a:	09 4d       	mov	r13,	r9	;
    6a1c:	08 4e       	mov	r14,	r8	;

00006a1e <.LBB96>:
  devp->irq_mappings[0] = irq0;
    6a1e:	fc 40 80 ff 	mov.b	#-128,	4(r12)	;#0xff80
    6a22:	04 00 

00006a24 <.Loc.625.1>:
  devp->irq_mappings[1] = irq1;
    6a24:	fc 40 30 00 	mov.b	#48,	5(r12)	;#0x0030
    6a28:	05 00 

00006a2a <.Loc.627.1>:
  sx1212SetRegister(devp, IRQParam1, irq0 | irq1);
    6a2a:	37 40 f8 62 	mov	#25336,	r7	;#0x62f8
    6a2e:	7e 40 b0 ff 	mov.b	#-80,	r14	;#0xffb0

00006a32 <.LVL178>:
    6a32:	7d 40 0d 00 	mov.b	#13,	r13	;#0x000d

00006a36 <.LVL179>:
    6a36:	87 12       	call	r7		;

00006a38 <.LBB98>:
  _disable_interrupts();
    6a38:	32 c2       	dint			

00006a3a <.Loc.348.3>:
  asm volatile("nop");
    6a3a:	03 43       	nop			

00006a3c <.LBE98>:
  chSysLock();
    6a3c:	b0 12 5a 44 	call	#17498		;#0x445a

00006a40 <.LVL181>:
  sx1212ReceiveI(devp, n, callback);
    6a40:	0e 48       	mov	r8,	r14	;
    6a42:	0d 49       	mov	r9,	r13	;
    6a44:	0c 4a       	mov	r10,	r12	;
    6a46:	b0 12 e2 69 	call	#27106		;#0x69e2

00006a4a <.LVL182>:
  chSysUnlock();
    6a4a:	b0 12 78 44 	call	#17528		;#0x4478

00006a4e <.LBB100>:
  asm volatile("nop");
    6a4e:	03 43       	nop			

00006a50 <.Loc.356.3>:
  _enable_interrupts();
    6a50:	32 d2       	eint			
    6a52:	03 43       	nop			

00006a54 <.LBB102>:
  sx1212SetMode(devp, SX1212Stdby);
    6a54:	38 40 2e 63 	mov	#25390,	r8	;#0x632e

00006a58 <.LVL185>:
    6a58:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    6a5c:	0c 4a       	mov	r10,	r12	;
    6a5e:	88 12       	call	r8		;

00006a60 <.LBB104>:
  chThdSleep(time);
    6a60:	7c 40 05 00 	mov.b	#5,	r12	;
    6a64:	b0 12 7c 47 	call	#18300		;#0x477c

00006a68 <.LBE104>:
  sx1212SetMode(devp, SX1212FS);
    6a68:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    6a6c:	0c 4a       	mov	r10,	r12	;
    6a6e:	88 12       	call	r8		;

00006a70 <.LVL188>:
  suspend_result = irq_block_with_timeout(devp, SX1212_PLL_LOCK, timeout);
    6a70:	4d 43       	clr.b	r13		;
    6a72:	3c 40 20 b2 	mov	#-19936,r12	;#0xb220
    6a76:	b0 12 d6 63 	call	#25558		;#0x63d6

00006a7a <.LVL189>:
    6a7a:	09 4c       	mov	r12,	r9	;

00006a7c <.LVL190>:
    6a7c:	82 4c 2c cd 	mov	r12,	&0xcd2c	;

00006a80 <.Loc.677.1>:
  if (suspend_result != MSG_OK) {
    6a80:	0c 93       	cmp	#0,	r12	;r3 As==00
    6a82:	0a 20       	jnz	$+22     	;abs 0x6a98

00006a84 <.Loc.682.1>:
  sx1212SetMode(devp, SX1212Rx);
    6a84:	7d 40 60 00 	mov.b	#96,	r13	;#0x0060
    6a88:	0c 4a       	mov	r10,	r12	;
    6a8a:	88 12       	call	r8		;

00006a8c <.LVL191>:
  sx1212SetRegister(devp, IRQParam2, 0x51);
    6a8c:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    6a90:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    6a94:	0c 4a       	mov	r10,	r12	;
    6a96:	87 12       	call	r7		;

00006a98 <.L96>:
  BLOCK_RETURN_ERROR(
    6a98:	82 49 2c cd 	mov	r9,	&0xcd2c	;

00006a9c <.Loc.1062.1>:
}
    6a9c:	0c 49       	mov	r9,	r12	;
    6a9e:	37 17       	popm	#4,	r10	;16-bit words
    6aa0:	30 41       	ret			

00006aa2 <sx1212FifoRead>:
  
  devp->rx_callback = callback;
  spiStartReceive(devp->config->spip, n, buffer);
}

void sx1212FifoRead(SX1212Driver * devp, size_t n, uint8_t * buffer) {
    6aa2:	6a 15       	pushm	#7,	r10	;16-bit words

00006aa4 <.LCFI16>:
    6aa4:	21 83       	decd	r1		;

00006aa6 <.LCFI17>:
    6aa6:	09 4c       	mov	r12,	r9	;
    6aa8:	0a 4e       	mov	r14,	r10	;

00006aaa <.LVL197>:
    6aaa:	0d 5e       	add	r14,	r13	;

00006aac <.LVL198>:
    6aac:	81 4d 00 00 	mov	r13,	0(r1)	;

00006ab0 <.LBB106>:
  
  for (size_t i = 0; i < n; i++) {
    palClearLine(devp->config->data_ss_b);
    6ab0:	58 43       	mov.b	#1,	r8	;r3 As==01

00006ab2 <.Loc.1092.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    6ab2:	36 40 0e 55 	mov	#21774,	r6	;#0x550e

00006ab6 <.L99>:
  for (size_t i = 0; i < n; i++) {
    6ab6:	81 9a 00 00 	cmp	r10,	0(r1)	;
    6aba:	03 20       	jnz	$+8      	;abs 0x6ac2

00006abc <.LBE106>:
    palSetLine(devp->config->data_ss_b);
  }
  
}
    6abc:	21 53       	incd	r1		;
    6abe:	64 17       	popm	#7,	r10	;16-bit words
    6ac0:	30 41       	ret			

00006ac2 <.L100>:
    palClearLine(devp->config->data_ss_b);
    6ac2:	27 49       	mov	@r9,	r7	;
    6ac4:	1d 47 04 00 	mov	4(r7),	r13	;
    6ac8:	05 4d       	mov	r13,	r5	;
    6aca:	35 f0 ff 0f 	and	#4095,	r5	;#0x0fff
    6ace:	14 45 02 00 	mov	2(r5),	r4	;
    6ad2:	0c 48       	mov	r8,	r12	;
    6ad4:	5d 03       	rrum	#1,	r13	;
    6ad6:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    6ada:	b0 12 94 af 	call	#-20588	;#0xaf94
    6ade:	04 cc       	bic	r12,	r4	;
    6ae0:	85 44 02 00 	mov	r4,	2(r5)	;

00006ae4 <.Loc.1092.1>:
    buffer[i] = spiPolledExchange(devp->config->spip, 0xFF);
    6ae4:	7d 43       	mov.b	#-1,	r13	;r3 As==11
    6ae6:	2c 47       	mov	@r7,	r12	;
    6ae8:	86 12       	call	r6		;

00006aea <.LVL201>:
    6aea:	ca 4c 00 00 	mov.b	r12,	0(r10)	;

00006aee <.Loc.1093.1>:
    palSetLine(devp->config->data_ss_b);
    6aee:	2c 49       	mov	@r9,	r12	;
    6af0:	1d 4c 04 00 	mov	4(r12),	r13	;
    6af4:	07 4d       	mov	r13,	r7	;
    6af6:	37 f0 ff 0f 	and	#4095,	r7	;#0x0fff
    6afa:	14 47 02 00 	mov	2(r7),	r4	;
    6afe:	0c 48       	mov	r8,	r12	;
    6b00:	5d 03       	rrum	#1,	r13	;
    6b02:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    6b06:	b0 12 94 af 	call	#-20588	;#0xaf94
    6b0a:	0c d4       	bis	r4,	r12	;
    6b0c:	87 4c 02 00 	mov	r12,	2(r7)	;

00006b10 <.LVL203>:
    6b10:	1a 53       	inc	r10		;

00006b12 <.LVL204>:
    6b12:	d1 3f       	jmp	$-92     	;abs 0x6ab6

00006b14 <sx1212StopReceive>:
    6b14:	0a 15       	pushm	#1,	r10	;16-bit words

00006b16 <L0>:
 * @post    NSS_CONFIG and NSS_DATA busses are both released (if enabled).
 *          SX1212 is in Sleep mode.
 *          
 * @param[in] devp    pointer to the SX1212 driver
 */
void sx1212StopReceive(SX1212Driver *devp) {
    6b16:	0a 4c       	mov	r12,	r10	;

00006b18 <.Loc.1146.1>:
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* Reset for next packet reception */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    6b18:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    6b1c:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    6b20:	b0 12 f8 62 	call	#25336		;#0x62f8

00006b24 <.LVL206>:
  /* Go to Sleep */
  sx1212SetMode(devp, SX1212Sleep);
    6b24:	4d 43       	clr.b	r13		;
    6b26:	0c 4a       	mov	r10,	r12	;
    6b28:	b0 12 2e 63 	call	#25390		;#0x632e

00006b2c <.LVL207>:
  
  /* Release SPI bus */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
}
    6b2c:	0a 17       	popm	#1,	r10	;16-bit words
    6b2e:	30 41       	ret			

00006b30 <send_complete_cb>:
  chEvtSignalI(uart_thd, UARTRxBufferReady);
}

void send_complete_cb(UARTDriver * uartp) {
  (void)(uartp);
  chSysLockFromISR();
    6b30:	b0 12 98 44 	call	#17560		;#0x4498

00006b34 <.LVL1>:
  /* Null out the active buffer so we'll get a new one */
  tx_active_buffer = NULL;
    6b34:	82 43 36 cd 	mov	#0,	&0xcd36	;r3 As==00

00006b38 <.Loc.56.1>:
  /* Allow us to handle config and buffer events again */
  UARTEvtMask |= (UARTConfigUpdated | UARTBufferPosted);
    6b38:	f2 d0 03 00 	bis.b	#3,	&0xcd34	;
    6b3c:	34 cd 

00006b3e <.LBB10>:
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();
    6b3e:	b0 12 26 45 	call	#17702		;#0x4526

00006b42 <.LVL3>:

  return chSemGetCounterI(&mbp->fullsem);
    6b42:	1c 42 8a be 	mov	&0xbe8a,r12	;0xbe8a

00006b46 <.LBE10>:
  /* Reset this because we might have had more than one in the mailbox */
  if (chMBGetUsedCountI(&uart_mbox) > 0) {
    6b46:	4d 43       	clr.b	r13		;
    6b48:	0d 9c       	cmp	r12,	r13	;
    6b4a:	04 34       	jge	$+10     	;abs 0x6b54

00006b4c <.Loc.59.1>:
    events |= UARTBufferPosted;
    6b4c:	a2 d3 30 cd 	bis	#2,	&0xcd30	;r3 As==10
    6b50:	82 dd 32 cd 	bis	r13,	&0xcd32	;

00006b54 <.L2>:
  }
  /* Event mask modified, need to kick the thread */
  if (!NIL_THD_IS_READY(uart_thd)) {
    6b54:	1c 42 2e cd 	mov	&0xcd2e,r12	;0xcd2e
    6b58:	cc 93 02 00 	cmp.b	#0,	2(r12)	;r3 As==00
    6b5c:	04 24       	jz	$+10     	;abs 0x6b66

00006b5e <.Loc.63.1>:
    chSchReadyI(uart_thd, MSG_RESET);
    6b5e:	3d 40 fe ff 	mov	#-2,	r13	;#0xfffe
    6b62:	b0 12 10 46 	call	#17936		;#0x4610

00006b66 <.L3>:
  }
  chSysUnlockFromISR();
    6b66:	b0 12 b8 44 	call	#17592		;#0x44b8

00006b6a <.LVL6>:
}
    6b6a:	30 41       	ret			

00006b6c <elyUARTCfgMarkDirty>:
  chEvtSignal(uart_thd, UARTConfigUpdated);
    6b6c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    6b6e:	4e 43       	clr.b	r14		;
    6b70:	1c 42 2e cd 	mov	&0xcd2e,r12	;0xcd2e
    6b74:	b0 12 8a 48 	call	#18570		;#0x488a

00006b78 <.LVL8>:
}
    6b78:	30 41       	ret			

00006b7a <elyUARTPostI>:
msg_t elyUARTPostI(uint8_t * buffer) {
    6b7a:	0a 15       	pushm	#1,	r10	;16-bit words

00006b7c <.LCFI0>:
  msg = chMBPostI(&uart_mbox, (msg_t)(buffer));
    6b7c:	0d 4c       	mov	r12,	r13	;
    6b7e:	3c 40 82 be 	mov	#-16766,r12	;#0xbe82

00006b82 <.LVL10>:
    6b82:	b0 12 b0 49 	call	#18864		;#0x49b0

00006b86 <.LVL11>:
    6b86:	0a 4c       	mov	r12,	r10	;

00006b88 <.Loc.26.1>:
  if (MSG_OK == msg) {
    6b88:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b8a:	06 20       	jnz	$+14     	;abs 0x6b98

00006b8c <.Loc.27.1>:
    chEvtSignalI(uart_thd, UARTBufferPosted);
    6b8c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6b8e:	4e 43       	clr.b	r14		;
    6b90:	1c 42 2e cd 	mov	&0xcd2e,r12	;0xcd2e
    6b94:	b0 12 44 48 	call	#18500		;#0x4844

00006b98 <.L6>:
}
    6b98:	0c 4a       	mov	r10,	r12	;
    6b9a:	0a 17       	popm	#1,	r10	;16-bit words
    6b9c:	30 41       	ret			

00006b9e <elyUARTPost>:
msg_t elyUARTPost(uint8_t * buffer, systime_t timeout) {
    6b9e:	1a 15       	pushm	#2,	r10	;16-bit words

00006ba0 <.LCFI1>:
    6ba0:	0a 4c       	mov	r12,	r10	;
    6ba2:	09 4d       	mov	r13,	r9	;

00006ba4 <.LBB16>:
  _disable_interrupts();
    6ba4:	32 c2       	dint			

00006ba6 <.Loc.348.3>:
  asm volatile("nop");
    6ba6:	03 43       	nop			

00006ba8 <.LBE16>:
  chSysLock();
    6ba8:	b0 12 5a 44 	call	#17498		;#0x445a

00006bac <.LVL15>:
  msg = chMBPostS(&uart_mbox, (msg_t)(buffer), timeout);
    6bac:	0e 49       	mov	r9,	r14	;
    6bae:	0d 4a       	mov	r10,	r13	;
    6bb0:	3c 40 82 be 	mov	#-16766,r12	;#0xbe82
    6bb4:	b0 12 2a 49 	call	#18730		;#0x492a

00006bb8 <.LVL16>:
    6bb8:	0a 4c       	mov	r12,	r10	;

00006bba <.LVL17>:
  chEvtSignalI(uart_thd, UARTBufferPosted);
    6bba:	6d 43       	mov.b	#2,	r13	;r3 As==10
    6bbc:	4e 43       	clr.b	r14		;
    6bbe:	1c 42 2e cd 	mov	&0xcd2e,r12	;0xcd2e
    6bc2:	b0 12 44 48 	call	#18500		;#0x4844

00006bc6 <.LVL18>:
  chSysUnlock();
    6bc6:	b0 12 78 44 	call	#17528		;#0x4478

00006bca <.LBB18>:
  asm volatile("nop");
    6bca:	03 43       	nop			

00006bcc <.Loc.356.3>:
  _enable_interrupts();
    6bcc:	32 d2       	eint			
    6bce:	03 43       	nop			

00006bd0 <.LBE18>:
}
    6bd0:	0c 4a       	mov	r10,	r12	;
    6bd2:	19 17       	popm	#2,	r10	;16-bit words
    6bd4:	30 41       	ret			

00006bd6 <UARTThd>:
  1000, /* milliseconds */
  elyUARTDLLTimeoutCB
};

THD_WORKING_AREA(waUARTThd, 128);
THD_FUNCTION(UARTThd, arg) {
    6bd6:	4a 15       	pushm	#5,	r10	;16-bit words

00006bd8 <.LCFI2>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  uart_thd = chThdGetSelfX();
    6bd8:	92 42 00 1c 	mov	&0x1c00,&0xcd2e	;0x1c00
    6bdc:	2e cd 

00006bde <.Loc.98.1>:
  
  /* Set the kinds of events we can handle */
  UARTEvtMask = (UARTConfigUpdated | UARTBufferPosted | UARTRxBufferReady);
    6bde:	f2 40 07 00 	mov.b	#7,	&0xcd34	;
    6be2:	34 cd 

00006be4 <.LBB36>:
  _disable_interrupts();
    6be4:	32 c2       	dint			

00006be6 <.Loc.348.3>:
  asm volatile("nop");
    6be6:	03 43       	nop			

00006be8 <.LBE36>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    6be8:	39 40 5a 44 	mov	#17498,	r9	;#0x445a
    6bec:	89 12       	call	r9		;

00006bee <.LVL22>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    6bee:	82 93 36 cd 	cmp	#0,	&0xcd36	;r3 As==00
    6bf2:	77 24       	jz	$+240    	;abs 0x6ce2

00006bf4 <.L13>:
    events |= UARTBufferPosted;
    6bf4:	a2 d3 30 cd 	bis	#2,	&0xcd30	;r3 As==10
    6bf8:	82 d3 32 cd 	bis	#0,	&0xcd32	;r3 As==00

00006bfc <.L12>:
  }
  chSysUnlock();
    6bfc:	3a 40 78 44 	mov	#17528,	r10	;#0x4478
    6c00:	8a 12       	call	r10		;

00006c02 <.LBB38>:
  asm volatile("nop");
    6c02:	03 43       	nop			

00006c04 <.Loc.356.3>:
  _enable_interrupts();
    6c04:	32 d2       	eint			
    6c06:	03 43       	nop			

00006c08 <.LBE38>:
  
  /* Require configuration load */
  events |= UARTConfigUpdated;
    6c08:	92 d3 30 cd 	bis	#1,	&0xcd30	;r3 As==01
    6c0c:	82 d3 32 cd 	bis	#0,	&0xcd32	;r3 As==00

00006c10 <.Loc.111.1>:
  
  /* Initialize the timeout timer */
  gptStart(&uart_gpt, &uart_timer_cfg);
    6c10:	3d 40 6c be 	mov	#-16788,r13	;#0xbe6c
    6c14:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    6c18:	b0 12 9e 4b 	call	#19358		;#0x4b9e

00006c1c <.LVL24>:
  
  /* Initialize the RX state machine */
  elyUARTDLLRxInit(&ELY_UART);
    6c1c:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    6c20:	b0 12 f8 98 	call	#-26376	;#0x98f8

00006c24 <.LVL25>:
  while (true) {
    if (events & UARTConfigUpdated) {
      /* Update config based on register values */
      chSysLock();
      /* Parity */
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    6c24:	18 42 be bd 	mov	&0xbdbe,r8	;0xbdbe
    6c28:	37 40 80 be 	mov	#-16768,r7	;#0xbe80

00006c2c <.Loc.128.1>:
      /* Stop bits */
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
      /* Autobaud */
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
      /* Baud rate */
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    6c2c:	36 40 72 be 	mov	#-16782,r6	;#0xbe72

00006c30 <.L14>:
    if (events & UARTConfigUpdated) {
    6c30:	d2 b3 30 cd 	bit.b	#1,	&0xcd30	;r3 As==01
    6c34:	3b 24       	jz	$+120    	;abs 0x6cac

00006c36 <.LBB40>:
  _disable_interrupts();
    6c36:	32 c2       	dint			

00006c38 <.Loc.348.3>:
  asm volatile("nop");
    6c38:	03 43       	nop			

00006c3a <.LBE40>:
      chSysLock();
    6c3a:	89 12       	call	r9		;

00006c3c <.LVL26>:
      A1_cfg.parity = bank0p[RegUARTParams] & 0x03;
    6c3c:	5c 48 26 00 	mov.b	38(r8),	r12	;0x00026
    6c40:	4f 4c       	mov.b	r12,	r15	;
    6c42:	7f f0 03 00 	and.b	#3,	r15	;
    6c46:	6d 47       	mov.b	@r7,	r13	;
    6c48:	7d f0 ec ff 	and.b	#-20,	r13	;#0xffec

00006c4c <.Loc.124.1>:
      A1_cfg.stop_bits = ((bank0p[RegUARTParams] >> 2) & 0x01);
    6c4c:	0e 4c       	mov	r12,	r14	;
    6c4e:	5e 07       	rrum	#2,	r14	;
    6c50:	5e f3       	and.b	#1,	r14	;r3 As==01
    6c52:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    6c56:	4d df       	bis.b	r15,	r13	;
    6c58:	4d de       	bis.b	r14,	r13	;

00006c5a <.Loc.126.1>:
      A1_cfg.autobaud = ((bank0p[RegUARTParams] >> 3) & 0x01);
    6c5a:	5c 0b       	rrum	#3,	r12	;
    6c5c:	5c f3       	and.b	#1,	r12	;r3 As==01
    6c5e:	44 18 0c 5c 	rpt #5 { rlax.w	r12		;
    6c62:	7d f0 df ff 	and.b	#-33,	r13	;#0xffdf
    6c66:	4d dc       	bis.b	r12,	r13	;
    6c68:	c7 4d 00 00 	mov.b	r13,	0(r7)	;

00006c6c <.Loc.130.1>:
                      ((uint32_t)(bank0p[RegUARTBaudLmb]) << 8) |
                      ((uint32_t)(bank0p[RegUARTBaudHmb]) << 16) |
    6c6c:	5d 48 23 00 	mov.b	35(r8),	r13	;0x00023
    6c70:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    6c74:	5c 48 25 00 	mov.b	37(r8),	r12	;0x00025
    6c78:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6c7c:	5e 48 24 00 	mov.b	36(r8),	r14	;0x00024
    6c80:	0c de       	bis	r14,	r12	;

00006c82 <.Loc.128.1>:
      A1_cfg.baud = ( ((uint32_t)(bank0p[RegUARTBaudLsb])) |
    6c82:	5e 48 22 00 	mov.b	34(r8),	r14	;0x00022
    6c86:	0e dd       	bis	r13,	r14	;
    6c88:	86 4e 0a 00 	mov	r14,	10(r6)	; 0x000a
    6c8c:	86 4c 0c 00 	mov	r12,	12(r6)	; 0x000c

00006c90 <.Loc.133.1>:
                      ((uint32_t)(bank0p[RegUARTBaudMsb]) << 24) );
      
      chSysUnlock();
    6c90:	8a 12       	call	r10		;

00006c92 <.LBB42>:
  asm volatile("nop");
    6c92:	03 43       	nop			

00006c94 <.Loc.356.3>:
  _enable_interrupts();
    6c94:	32 d2       	eint			
    6c96:	03 43       	nop			

00006c98 <.LBE42>:
      /* Re-initialize the UART */
      uartStart(&ELY_UART, &A1_cfg);
    6c98:	3d 40 72 be 	mov	#-16782,r13	;#0xbe72
    6c9c:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    6ca0:	b0 12 ac 4c 	call	#19628		;#0x4cac

00006ca4 <.LVL28>:
      events &= ~UARTConfigUpdated;
    6ca4:	92 c3 30 cd 	bic	#1,	&0xcd30	;r3 As==01
    6ca8:	82 c3 32 cd 	bic	#0,	&0xcd32	;r3 As==00

00006cac <.L15>:
    }
    if (events & UARTBufferPosted) {
    6cac:	e2 b3 30 cd 	bit.b	#2,	&0xcd30	;r3 As==10
    6cb0:	31 24       	jz	$+100    	;abs 0x6d14

00006cb2 <.Loc.139.1>:
      if (NULL == tx_active_buffer) {
    6cb2:	82 93 36 cd 	cmp	#0,	&0xcd36	;r3 As==00
    6cb6:	21 20       	jnz	$+68     	;abs 0x6cfa

00006cb8 <.LBB44>:
  _disable_interrupts();
    6cb8:	32 c2       	dint			

00006cba <.Loc.348.3>:
  asm volatile("nop");
    6cba:	03 43       	nop			

00006cbc <.LBE44>:
        /* Get the buffer */
        chSysLock();
    6cbc:	89 12       	call	r9		;

00006cbe <.LVL29>:
        result = chMBFetchS(&uart_mbox, (msg_t *)(&tx_active_buffer), TIME_IMMEDIATE);
    6cbe:	3e 43       	mov	#-1,	r14	;r3 As==11
    6cc0:	3d 40 36 cd 	mov	#-13002,r13	;#0xcd36
    6cc4:	3c 40 82 be 	mov	#-16766,r12	;#0xbe82
    6cc8:	b0 12 f4 49 	call	#18932		;#0x49f4

00006ccc <.LVL30>:
        if (result != MSG_OK) {
    6ccc:	0c 93       	cmp	#0,	r12	;r3 As==00
    6cce:	11 24       	jz	$+36     	;abs 0x6cf2

00006cd0 <.Loc.144.1>:
          events &= ~UARTBufferPosted;
    6cd0:	a2 c3 30 cd 	bic	#2,	&0xcd30	;r3 As==10
    6cd4:	82 c3 32 cd 	bic	#0,	&0xcd32	;r3 As==00

00006cd8 <.Loc.145.1>:
          chSysUnlock();
    6cd8:	8a 12       	call	r10		;

00006cda <.LBB46>:
  asm volatile("nop");
    6cda:	03 43       	nop			

00006cdc <.Loc.356.3>:
  _enable_interrupts();
    6cdc:	32 d2       	eint			
    6cde:	03 43       	nop			

00006ce0 <.LBE46>:
          /* Skip to the next loop */
          continue;
    6ce0:	a7 3f       	jmp	$-176    	;abs 0x6c30

00006ce2 <.L11>:
  chDbgCheckClassI();
    6ce2:	b0 12 26 45 	call	#17702		;#0x4526

00006ce6 <.LVL33>:
  return chSemGetCounterI(&mbp->fullsem);
    6ce6:	1c 42 8a be 	mov	&0xbe8a,r12	;0xbe8a

00006cea <.LBE48>:
  if (tx_active_buffer != NULL || chMBGetUsedCountI(&uart_mbox) > 0) {
    6cea:	4d 43       	clr.b	r13		;
    6cec:	0d 9c       	cmp	r12,	r13	;
    6cee:	82 3b       	jl	$-250    	;abs 0x6bf4
    6cf0:	85 3f       	jmp	$-244    	;abs 0x6bfc

00006cf2 <.L20>:
        }
        chSysUnlock();
    6cf2:	8a 12       	call	r10		;

00006cf4 <.LBB50>:
  asm volatile("nop");
    6cf4:	03 43       	nop			

00006cf6 <.Loc.356.3>:
  _enable_interrupts();
    6cf6:	32 d2       	eint			
    6cf8:	03 43       	nop			

00006cfa <.L19>:
      }
        
      /* Otherwise we already have a valid buffer to post */
      elyUARTDLLStartTx(&ELY_UART, tx_active_buffer);
    6cfa:	1d 42 36 cd 	mov	&0xcd36,r13	;0xcd36
    6cfe:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    6d02:	b0 12 7a 98 	call	#-26502	;#0x987a

00006d06 <.LVL37>:
      
      /* Don't handle config events or buffer events until transmission ends */
      UARTEvtMask &= ~(UARTConfigUpdated | UARTBufferPosted);
    6d06:	f2 f0 fc ff 	and.b	#-4,	&0xcd34	;#0xfffc
    6d0a:	34 cd 

00006d0c <.Loc.158.1>:
      
      events &= ~UARTBufferPosted; /* This will be re-set from the callback */
    6d0c:	a2 c3 30 cd 	bic	#2,	&0xcd30	;r3 As==10
    6d10:	82 c3 32 cd 	bic	#0,	&0xcd32	;r3 As==00

00006d14 <.L17>:
    }
    if (events & UARTRxBufferReady) {
    6d14:	e2 b2 30 cd 	bit.b	#4,	&0xcd30	;r2 As==10
    6d18:	06 24       	jz	$+14     	;abs 0x6d26

00006d1a <.Loc.162.1>:
      
      elyUARTDLLRxHandleBuffer();
    6d1a:	b0 12 00 99 	call	#-26368	;#0x9900

00006d1e <.LVL38>:
      events &= ~UARTRxBufferReady; /* Again, re-set from a callback */
    6d1e:	a2 c2 30 cd 	bic	#4,	&0xcd30	;r2 As==10
    6d22:	82 c3 32 cd 	bic	#0,	&0xcd32	;r3 As==00

00006d26 <.L22>:
    }
    /* Get next events */
    events = chEvtWaitAnyTimeout(UARTEvtMask, TIME_INFINITE);
    6d26:	4e 43       	clr.b	r14		;
    6d28:	5c 42 34 cd 	mov.b	&0xcd34,r12	;0xcd34
    6d2c:	0d 43       	clr	r13		;
    6d2e:	b0 12 ba 48 	call	#18618		;#0x48ba

00006d32 <.LVL39>:
    6d32:	82 4c 30 cd 	mov	r12,	&0xcd30	;
    6d36:	82 4d 32 cd 	mov	r13,	&0xcd32	;
    6d3a:	7a 3f       	jmp	$-266    	;abs 0x6c30

00006d3c <elyMainMBPost>:
static PERSIST msg_t main_buffer[elyNLMaxSlots];
static PERSIST MAILBOX_DECL(main_mbox, main_buffer, elyNLMaxSlots);
static PERSIST uint8_t * active_buffer = NULL;

msg_t elyMainMBPost(uint8_t * buffer, systime_t timeout) {
  return chMBPost(&main_mbox, (msg_t)(buffer), timeout);
    6d3c:	0e 4d       	mov	r13,	r14	;
    6d3e:	0d 4c       	mov	r12,	r13	;

00006d40 <.LVL1>:
    6d40:	3c 40       	mov,		r12	;Warning: disassembly unreliable - not enough bytes available

00006d42 <L0>:
    6d42:	8e be       	bit	r14		; Warning: disassembly unreliable - not enough bytes available

00006d44 <.LVL2>:
    6d44:	b0 12 74 49 	call	#18804		;#0x4974

00006d48 <.LVL3>:
}
    6d48:	30 41       	ret			

00006d4a <MainThd>:
msg_t elyMainMBPostI(uint8_t * buffer) {
  return chMBPostI(&main_mbox, (msg_t)(buffer));
}

THD_WORKING_AREA(waMainThd, 128);
THD_FUNCTION(MainThd, arg) {
    6d4a:	3a 15       	pushm	#4,	r10	;16-bit words

00006d4c <.LCFI1>:
    6d4c:	21 83       	decd	r1		;

00006d4e <.LCFI2>:
  (void)arg;
  
  while (true) {
    if (NULL == active_buffer) {
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    6d4e:	37 40 3e 4a 	mov	#19006,	r7	;#0x4a3e

00006d52 <.Loc.32.1>:
    }
    
    /* Run Network Layer validation checks */
    /* TODO figure out a better way to deal with this problem, here and below */
    if (!elyNLValidate(active_buffer)) {
    6d52:	38 40 c2 aa 	mov	#-21822,r8	;#0xaac2

00006d56 <.L5>:
    if (NULL == active_buffer) {
    6d56:	82 93 48 cd 	cmp	#0,	&0xcd48	;r3 As==00
    6d5a:	06 20       	jnz	$+14     	;abs 0x6d68

00006d5c <.Loc.27.1>:
      chMBFetch(&main_mbox, (msg_t *)(&active_buffer), TIME_INFINITE);
    6d5c:	4e 43       	clr.b	r14		;
    6d5e:	3d 40 48 cd 	mov	#-12984,r13	;#0xcd48
    6d62:	3c 40 8e be 	mov	#-16754,r12	;#0xbe8e
    6d66:	87 12       	call	r7		;

00006d68 <.L7>:
    if (!elyNLValidate(active_buffer)) {
    6d68:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6d6c:	88 12       	call	r8		;

00006d6e <.LVL13>:
    6d6e:	4a 4c       	mov.b	r12,	r10	;
    6d70:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6d74:	0a 93       	cmp	#0,	r10	;r3 As==00
    6d76:	05 20       	jnz	$+12     	;abs 0x6d82

00006d78 <.Loc.33.1>:
      elyNLFreeBuffer(active_buffer);
    6d78:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006d7c <.LVL14>:
      active_buffer = NULL; 
    6d7c:	82 4a 48 cd 	mov	r10,	&0xcd48	;

00006d80 <.Loc.35.1>:
      continue;
    6d80:	ea 3f       	jmp	$-42     	;abs 0x6d56

00006d82 <.L8>:
    }
    
    /* Route packet according to Network Layer rules */
    switch(elyNLGetDest(active_buffer)) {
    6d82:	b0 12 10 aa 	call	#-22000	;#0xaa10

00006d86 <.LVL15>:
    6d86:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    6d88:	31 24       	jz	$+100    	;abs 0x6dec
    6d8a:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    6d8c:	1e 24       	jz	$+62     	;abs 0x6dca
    6d8e:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    6d90:	e2 23       	jnz	$-58     	;abs 0x6d56

00006d92 <.LBB2>:
          active_buffer = NULL; 
        }
        break;
      case ELY_DEST_FW:
        { /* need a new scope */
          uint8_t * cmd_buffer = elyNLExtract(active_buffer);
    6d92:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6d96:	b0 12 20 ab 	call	#-21728	;#0xab20

00006d9a <.LVL16>:
    6d9a:	0a 4c       	mov	r12,	r10	;

00006d9c <.LVL17>:
          elysium_cmd_hdr_t hdr;
          
          hdr = elyCmdParse(cmd_buffer);
    6d9c:	0d 4c       	mov	r12,	r13	;
    6d9e:	0c 41       	mov	r1,	r12	;
    6da0:	b0 12 12 70 	call	#28690		;#0x7012

00006da4 <.LVL18>:
          if (elyCmdValidate(hdr, cmd_buffer)) {
    6da4:	0d 4a       	mov	r10,	r13	;
    6da6:	0c 41       	mov	r1,	r12	;
    6da8:	b0 12 3e 70 	call	#28734		;#0x703e

00006dac <.LVL19>:
    6dac:	49 4c       	mov.b	r12,	r9	;
    6dae:	09 93       	cmp	#0,	r9	;r3 As==00
    6db0:	25 24       	jz	$+76     	;abs 0x6dfc

00006db2 <.Loc.68.1>:
            if (hdr.reply) {
    6db2:	e1 b3 00 00 	bit.b	#2,	0(r1)	;r3 As==10
    6db6:	04 24       	jz	$+10     	;abs 0x6dc0

00006db8 <.Loc.72.1>:
              /* We set the network-layer destination here because we're going to
               * modify the packet to contain the response in elyCmdDispatch and
               * that will destroy the ReplyAddress field */
              elyNLSetDest(active_buffer);
    6db8:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6dbc:	b0 12 66 aa 	call	#-21914	;#0xaa66

00006dc0 <.L14>:
            }
            elyCmdDispatch(hdr, cmd_buffer);
    6dc0:	0d 4a       	mov	r10,	r13	;
    6dc2:	0c 41       	mov	r1,	r12	;
    6dc4:	b0 12 80 72 	call	#29312		;#0x7280

00006dc8 <.LVL21>:
    6dc8:	0b 3c       	jmp	$+24     	;abs 0x6de0

00006dca <.L10>:
        if (MSG_OK != elyUARTPost(active_buffer, TIME_IMMEDIATE)) {
    6dca:	3d 43       	mov	#-1,	r13	;r3 As==11
    6dcc:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6dd0:	b0 12 9e 6b 	call	#27550		;#0x6b9e

00006dd4 <.LVL23>:
    6dd4:	0c 93       	cmp	#0,	r12	;r3 As==00
    6dd6:	07 24       	jz	$+16     	;abs 0x6de6

00006dd8 <.L23>:
          elyNLFreeBuffer(active_buffer);
    6dd8:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6ddc:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006de0 <.L22>:
            /* null the buffer so we get a new one */
            active_buffer = NULL;
    6de0:	82 43 48 cd 	mov	#0,	&0xcd48	;r3 As==00
    6de4:	b8 3f       	jmp	$-142    	;abs 0x6d56

00006de6 <.L12>:
        active_buffer = NULL;
    6de6:	82 4c 48 cd 	mov	r12,	&0xcd48	;

00006dea <.Loc.50.1>:
        break;
    6dea:	b5 3f       	jmp	$-148    	;abs 0x6d56

00006dec <.L9>:
        if (MSG_OK != elyRFPost(active_buffer, TIME_IMMEDIATE)) {
    6dec:	3d 43       	mov	#-1,	r13	;r3 As==11
    6dee:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6df2:	b0 12 54 a2 	call	#-23980	;#0xa254

00006df6 <.LVL25>:
    6df6:	0c 93       	cmp	#0,	r12	;r3 As==00
    6df8:	ae 27       	jz	$-162    	;abs 0x6d56
    6dfa:	ee 3f       	jmp	$-34     	;abs 0x6dd8

00006dfc <.L13>:
          }
          else {
            /* Invalid command - free the buffer */
            elyNLFreeBuffer(active_buffer);
    6dfc:	1c 42 48 cd 	mov	&0xcd48,r12	;0xcd48
    6e00:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006e04 <.LVL27>:
            /* null the buffer so we get a new one */
            active_buffer = NULL;
    6e04:	82 49 48 cd 	mov	r9,	&0xcd48	;

00006e08 <.LBE4>:
          }
        }
        break;
    6e08:	a6 3f       	jmp	$-178    	;abs 0x6d56

00006e0a <port_lock>:
  _disable_interrupts();
    6e0a:	32 c2       	dint			

00006e0c <.Loc.348.1>:
  asm volatile("nop");
    6e0c:	03 43       	nop			

00006e0e <.Loc.349.1>:
}
    6e0e:	30 41       	ret			

00006e10 <port_unlock>:
  asm volatile("nop");
    6e10:	03 43       	nop			

00006e12 <.Loc.356.1>:
  _enable_interrupts();
    6e12:	32 d2       	eint			
    6e14:	03 43       	nop			

00006e16 <L0>:
}
    6e16:	30 41       	ret			

00006e18 <reset>:
  }
}

static void reset(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
  (void)(hdr);
  elyNLFreeBuffer(elyNLPack(buffer));
    6e18:	b0 12 32 ab 	call	#-21710	;#0xab32

00006e1c <.LVL1>:
    6e1c:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006e20 <.LVL2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    6e20:	b2 40 48 a5 	mov	#-23224,&0x0120	;#0xa548
    6e24:	20 01 

00006e26 <.Loc.48.2>:
}
    6e26:	30 41       	ret			

00006e28 <gen_success>:
static inline void gen_success(uint8_t *buffer, uint8_t crc) {
    6e28:	1a 15       	pushm	#2,	r10	;16-bit words

00006e2a <.LCFI0>:
    6e2a:	0a 4c       	mov	r12,	r10	;
    6e2c:	49 4d       	mov.b	r13,	r9	;

00006e2e <.Loc.20.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6e2e:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    6e32:	00 00 

00006e34 <.Loc.21.2>:
  buffer[1] = (crc ? 3 : 1);
    6e34:	09 93       	cmp	#0,	r9	;r3 As==00
    6e36:	1e 20       	jnz	$+62     	;abs 0x6e74
    6e38:	5c 43       	mov.b	#1,	r12	;r3 As==01

00006e3a <.L5>:
    6e3a:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00006e3e <.Loc.22.2>:
  chSysLock();
    6e3e:	b0 12 0a 6e 	call	#28170		;#0x6e0a

00006e42 <.LVL5>:
    6e42:	b0 12 5a 44 	call	#17498		;#0x445a

00006e46 <.LVL6>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6e46:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    6e4a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    6e4e:	02 00 

00006e50 <.Loc.24.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6e50:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    6e54:	03 00 

00006e56 <.Loc.25.2>:
  chSysUnlock();
    6e56:	b0 12 78 44 	call	#17528		;#0x4478

00006e5a <.LVL7>:
    6e5a:	b0 12 10 6e 	call	#28176		;#0x6e10

00006e5e <.LVL8>:
  buffer[4] = 1;
    6e5e:	da 43 04 00 	mov.b	#1,	4(r10)	;r3 As==01

00006e62 <.Loc.27.2>:
  if (crc) {
    6e62:	09 93       	cmp	#0,	r9	;r3 As==00
    6e64:	05 24       	jz	$+12     	;abs 0x6e70

00006e66 <.Loc.28.2>:
    crcGenX25(buffer, 7);
    6e66:	7d 40 07 00 	mov.b	#7,	r13	;
    6e6a:	0c 4a       	mov	r10,	r12	;
    6e6c:	b0 12 26 9b 	call	#-25818	;#0x9b26

00006e70 <.L4>:
}
    6e70:	19 17       	popm	#2,	r10	;16-bit words
    6e72:	30 41       	ret			

00006e74 <.L7>:
  buffer[1] = (crc ? 3 : 1);
    6e74:	7c 40 03 00 	mov.b	#3,	r12	;
    6e78:	e0 3f       	jmp	$-62     	;abs 0x6e3a

00006e7a <gen_failure>:
    6e7a:	1a 15       	pushm	#2,	r10	;16-bit words

00006e7c <L0>:
static inline void gen_failure(uint8_t *buffer, uint8_t crc) {
    6e7c:	0a 4c       	mov	r12,	r10	;
    6e7e:	49 4d       	mov.b	r13,	r9	;

00006e80 <.Loc.33.2>:
  buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    6e80:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    6e84:	00 00 

00006e86 <.Loc.34.2>:
  buffer[1] = (crc ? 2 : 0);
    6e86:	09 93       	cmp	#0,	r9	;r3 As==00
    6e88:	1c 20       	jnz	$+58     	;abs 0x6ec2
    6e8a:	0c 49       	mov	r9,	r12	;

00006e8c <.L12>:
    6e8c:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

00006e90 <.Loc.35.2>:
  chSysLock();
    6e90:	b0 12 0a 6e 	call	#28170		;#0x6e0a

00006e94 <.LVL13>:
    6e94:	b0 12 5a 44 	call	#17498		;#0x445a

00006e98 <.LVL14>:
  buffer[2] = bank0p[RegSrcAddrMsb];
    6e98:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    6e9c:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    6ea0:	02 00 

00006ea2 <.Loc.37.2>:
  buffer[3] = bank0p[RegSrcAddrLsb];
    6ea2:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    6ea6:	03 00 

00006ea8 <.Loc.38.2>:
  chSysUnlock();
    6ea8:	b0 12 78 44 	call	#17528		;#0x4478

00006eac <.LVL15>:
    6eac:	b0 12 10 6e 	call	#28176		;#0x6e10

00006eb0 <.LVL16>:
  if (crc) {
    6eb0:	09 93       	cmp	#0,	r9	;r3 As==00
    6eb2:	05 24       	jz	$+12     	;abs 0x6ebe

00006eb4 <.Loc.40.2>:
    crcGenX25(buffer, 6);
    6eb4:	7d 40 06 00 	mov.b	#6,	r13	;
    6eb8:	0c 4a       	mov	r10,	r12	;
    6eba:	b0 12 26 9b 	call	#-25818	;#0x9b26

00006ebe <.L11>:
}
    6ebe:	19 17       	popm	#2,	r10	;16-bit words
    6ec0:	30 41       	ret			

00006ec2 <.L14>:
  buffer[1] = (crc ? 2 : 0);
    6ec2:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6ec4:	e3 3f       	jmp	$-56     	;abs 0x6e8c

00006ec6 <store_telem>:
    6ec6:	3a 15       	pushm	#4,	r10	;16-bit words

00006ec8 <L0>:
  elyNLFreeBufferI(buffer);
  chSysUnlockFromISR();
  
}

static void store_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    6ec8:	21 83       	decd	r1		;

00006eca <.LCFI3>:
    6eca:	09 4c       	mov	r12,	r9	;
    6ecc:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00006ed0 <.LVL20>:
    6ed0:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00006ed4 <.Loc.1632.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6ed4:	6c 41       	mov.b	@r1,	r12	;

00006ed6 <.LVL22>:
    6ed6:	4d 4c       	mov.b	r12,	r13	;

00006ed8 <.LVL23>:
    6ed8:	6d f3       	and.b	#2,	r13	;r3 As==10
    6eda:	48 4d       	mov.b	r13,	r8	;
    6edc:	08 93       	cmp	#0,	r8	;r3 As==00
    6ede:	1c 20       	jnz	$+58     	;abs 0x6f18
    6ee0:	67 43       	mov.b	#2,	r7	;r3 As==10

00006ee2 <.L19>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6ee2:	1c b3       	bit	#1,	r12	;r3 As==01
    6ee4:	1b 20       	jnz	$+56     	;abs 0x6f1c

00006ee6 <.Loc.1633.2>:
    6ee6:	4c 43       	clr.b	r12		;

00006ee8 <.L20>:
    6ee8:	4a 8d       	sub.b	r13,	r10	;

00006eea <.LVL25>:
    6eea:	4a 8c       	sub.b	r12,	r10	;
    6eec:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00006ef0 <.LVL26>:
  
  chSysLock();
    6ef0:	b0 12 0a 6e 	call	#28170		;#0x6e0a

00006ef4 <.LVL27>:
    6ef4:	b0 12 5a 44 	call	#17498		;#0x445a

00006ef8 <.LVL28>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    6ef8:	0c 49       	mov	r9,	r12	;
    6efa:	0c 57       	add	r7,	r12	;
    6efc:	08 93       	cmp	#0,	r8	;r3 As==00
    6efe:	10 20       	jnz	$+34     	;abs 0x6f20

00006f00 <.Loc.1636.2>:
    6f00:	3e 40 26 6f 	mov	#28454,	r14	;#0x6f26

00006f04 <.L21>:
    6f04:	0d 4a       	mov	r10,	r13	;
    6f06:	b0 12 6a ae 	call	#-20886	;#0xae6a

00006f0a <.LVL29>:
      (hdr.reply ? store_telem_reply_cb : store_telem_noreply_cb));
  chSysUnlock();
    6f0a:	b0 12 78 44 	call	#17528		;#0x4478

00006f0e <.LVL30>:
    6f0e:	b0 12 10 6e 	call	#28176		;#0x6e10

00006f12 <.LVL31>:
  
  /* Reply is posted from callback if needed */
}
    6f12:	21 53       	incd	r1		;
    6f14:	37 17       	popm	#4,	r10	;16-bit words
    6f16:	30 41       	ret			

00006f18 <.L22>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    6f18:	67 42       	mov.b	#4,	r7	;r2 As==10
    6f1a:	e3 3f       	jmp	$-56     	;abs 0x6ee2

00006f1c <.L23>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    6f1c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6f1e:	e4 3f       	jmp	$-54     	;abs 0x6ee8

00006f20 <.L24>:
  elyTelemPostBufferS(buffer + hdr_ext, payload_len, 
    6f20:	3e 40 dc 72 	mov	#29404,	r14	;#0x72dc
    6f24:	ef 3f       	jmp	$-32     	;abs 0x6f04

00006f26 <store_telem_noreply_cb>:
    6f26:	0a 15       	pushm	#1,	r10	;16-bit words

00006f28 <.LCFI4>:
static void store_telem_noreply_cb(uint8_t * buffer) {
    6f28:	0a 4c       	mov	r12,	r10	;

00006f2a <.LVL36>:
  chSysLockFromISR();
    6f2a:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00006f2c <L0>:
    6f2c:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00006f2e <.LVL37>:
  elyNLFreeBufferI(buffer);
    6f2e:	0c 4a       	mov	r10,	r12	;
    6f30:	3c 50 fe ff 	add	#-2,	r12	;#0xfffe

00006f34 <.LVL38>:
    6f34:	b0 12 fa a9 	call	#-22022	;#0xa9fa

00006f38 <.LVL39>:
  chSysUnlockFromISR();
    6f38:	b0 12 b8 44 	call	#17592		;#0x44b8

00006f3c <.LVL40>:
}
    6f3c:	0a 17       	popm	#1,	r10	;16-bit words
    6f3e:	30 41       	ret			

00006f40 <upload_fw_noreply_cb>:
static void upload_fw_noreply_cb(uint8_t * buffer) {
    6f40:	0a 15       	pushm	#1,	r10	;16-bit words

00006f42 <.LCFI5>:
    6f42:	0a 4c       	mov	r12,	r10	;

00006f44 <.LVL42>:
  chSysLockFromISR();
    6f44:	b0 12 98 44 	call	#17560		;#0x4498

00006f48 <.LVL43>:
  elyNLFreeBufferI(elyNLPack(buffer));
    6f48:	0c 4a       	mov	r10,	r12	;
    6f4a:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa

00006f4e <.LVL44>:
    6f4e:	b0 12 32 ab 	call	#-21710	;#0xab32

00006f52 <.LVL45>:
    6f52:	b0 12 fa a9 	call	#-22022	;#0xa9fa

00006f56 <.LVL46>:
  chSysUnlockFromISR();
    6f56:	b0 12 b8 44 	call	#17592		;#0x44b8

00006f5a <.LVL47>:
}
    6f5a:	0a 17       	popm	#1,	r10	;16-bit words
    6f5c:	30 41       	ret			

00006f5e <verify_fw>:
static void verify_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    6f5e:	0a 15       	pushm	#1,	r10	;16-bit words

00006f60 <.LCFI6>:
    6f60:	21 82       	sub	#4,	r1	;r2 As==10

00006f62 <.LCFI7>:
    6f62:	0e 4c       	mov	r12,	r14	;

00006f64 <.Loc.1463.2>:
    6f64:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    6f68:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    6f6c:	03 00 

00006f6e <.Loc.1464.2>:
  if (hdr.reply) {
    6f6e:	e1 b3 02 00 	bit.b	#2,	2(r1)	;r3 As==10
    6f72:	33 24       	jz	$+104    	;abs 0x6fda

00006f74 <.LBB37>:
    stored_buff = buffer; /* store for freeing */
    6f74:	82 4c 62 cd 	mov	r12,	&0xcd62	;

00006f78 <.Loc.1467.2>:
    verify_crc = ((buffer[4] << 8) | (buffer[5]));
    6f78:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00006f7c <.LVL50>:
    6f7c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6f80:	5e 4e 05 00 	mov.b	5(r14),	r14	;

00006f84 <.LVL51>:
    6f84:	0e dc       	bis	r12,	r14	;
    6f86:	82 4e 64 cd 	mov	r14,	&0xcd64	;

00006f8a <.Loc.1470.2>:
    volatile uint8_t * crc_addr = crcStart();
    6f8a:	b0 12 98 9b 	call	#-25704	;#0x9b98

00006f8e <.LVL52>:
    6f8e:	0a 4c       	mov	r12,	r10	;

00006f90 <.LVL53>:
    elyFramGetRequest(&req);
    6f90:	0c 41       	mov	r1,	r12	;
    6f92:	b0 12 74 ae 	call	#-20876	;#0xae74

00006f96 <.LVL54>:
    req->address = FRAM_FW_BASE; 
    6f96:	2c 41       	mov	@r1,	r12	;
    6f98:	bc 40 00 04 	mov	#1024,	0(r12)	;#0x0400
    6f9c:	00 00 
    6f9e:	9c 43 02 00 	mov	#1,	2(r12)	;r3 As==01

00006fa2 <.Loc.1481.2>:
    req->special = 1; /* read to a constant register address */
    6fa2:	fc d0 03 00 	bis.b	#3,	4(r12)	;
    6fa6:	04 00 

00006fa8 <.Loc.1482.2>:
    req->size = FRAM_FW_SIZE;
    6fa8:	1d 4c 04 00 	mov	4(r12),	r13	;
    6fac:	7d f0 03 00 	and.b	#3,	r13	;
    6fb0:	3d d0 00 f0 	bis	#-4096,	r13	;#0xf000
    6fb4:	8c 4d 04 00 	mov	r13,	4(r12)	;
    6fb8:	5d 4c 06 00 	mov.b	6(r12),	r13	;
    6fbc:	7d d0 03 00 	bis.b	#3,	r13	;
    6fc0:	6d c2       	bic.b	#4,	r13	;r2 As==10
    6fc2:	cc 4d 06 00 	mov.b	r13,	6(r12)	;

00006fc6 <.Loc.1484.2>:
    req->buffer = (uint8_t *)(crc_addr); /* crc input register */
    6fc6:	8c 4a 08 00 	mov	r10,	8(r12)	;

00006fca <.Loc.1485.2>:
    req->callback = verify_fw_cb;
    6fca:	bc 40 f4 73 	mov	#29684,	10(r12)	;#0x73f4, 0x000a
    6fce:	0a 00 

00006fd0 <.Loc.1491.2>:
    elyFramPostRequest(req);
    6fd0:	b0 12 c0 ae 	call	#-20800	;#0xaec0

00006fd4 <.L27>:
}
    6fd4:	21 52       	add	#4,	r1	;r2 As==10
    6fd6:	0a 17       	popm	#1,	r10	;16-bit words
    6fd8:	30 41       	ret			

00006fda <.L28>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6fda:	b0 12 32 ab 	call	#-21710	;#0xab32

00006fde <.LVL57>:
    6fde:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006fe2 <.LVL58>:
}
    6fe2:	f8 3f       	jmp	$-14     	;abs 0x6fd4

00006fe4 <get_active_bank.part.13>:
    6fe4:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00006fe6 <L0>:
    elyNLFreeBuffer(elyNLPack(buffer));
    6fe6:	32 ab       	dadd	@r11+,	r2	;

00006fe8 <.LVL60>:
    6fe8:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00006fec <.LVL61>:
}
    6fec:	30 41       	ret			

00006fee <cancel_fw_eeprom_cb>:
  chSysLockFromISR();
    6fee:	b0 12 98 44 	call	#17560		;#0x4498

00006ff2 <.LBB41>:
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
    6ff2:	b0 12 26 45 	call	#17702		;#0x4526

00006ff6 <.LVL64>:

  if (bsp->sem.cnt < (cnt_t)1) {
    6ff6:	1c 42 60 cd 	mov	&0xcd60,r12	;0xcd60
    6ffa:	4d 43       	clr.b	r13		;
    6ffc:	0d 9c       	cmp	r12,	r13	;
    6ffe:	04 38       	jl	$+10     	;abs 0x7008

00007000 <.Loc.271.3>:
    chSemSignalI(&bsp->sem);
    7000:	3c 40 60 cd 	mov	#-12960,r12	;#0xcd60
    7004:	b0 12 10 48 	call	#18448		;#0x4810

00007008 <.L32>:
  pages_acked++;
    7008:	92 53 5c cd 	inc	&0xcd5c		;

0000700c <.Loc.1503.2>:
  chSysUnlockFromISR();
    700c:	b0 12 b8 44 	call	#17592		;#0x44b8

00007010 <.LVL66>:
}
    7010:	30 41       	ret			

00007012 <elyCmdParse>:
  store_telem,
  get_telem
};

/* ENH more clever ways to do this relying on non-portable constructs */
elysium_cmd_hdr_t elyCmdParse(uint8_t * buffer) {
    7012:	0a 15       	pushm	#1,	r10	;16-bit words

00007014 <.LCFI8>:
  elysium_cmd_hdr_t hdr;
  hdr.crc = (buffer[0] >> 7);
    7014:	6e 4d       	mov.b	@r13,	r14	;

00007016 <.LVL68>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
  hdr.opcode = (buffer[0] & 0x3F);
  hdr.length = buffer[1];
    7016:	5b 4d 01 00 	mov.b	1(r13),	r11	;

0000701a <.LVL69>:
  return hdr;
    701a:	0a 4e       	mov	r14,	r10	;
    701c:	5a 0f       	rrum	#4,	r10	;
    701e:	5a 0b       	rrum	#3,	r10	;

00007020 <.Loc.1745.2>:
  hdr.reply = ((buffer[0] >> 6) & 0x01);
    7020:	0d 4e       	mov	r14,	r13	;

00007022 <.LVL70>:
    7022:	5d 0f       	rrum	#4,	r13	;
    7024:	5d 07       	rrum	#2,	r13	;

00007026 <.Loc.1748.2>:
  return hdr;
    7026:	0d 5d       	rla	r13		;
    7028:	6d f3       	and.b	#2,	r13	;r3 As==10
    702a:	41 18 0e 5e 	rpt #2 { rlax.w	r14		;

0000702e <.LVL71>:
    702e:	4d da       	bis.b	r10,	r13	;
    7030:	4d de       	bis.b	r14,	r13	;
    7032:	cc 4d 00 00 	mov.b	r13,	0(r12)	;
    7036:	cc 4b 01 00 	mov.b	r11,	1(r12)	;

0000703a <.LVL72>:
}
    703a:	0a 17       	popm	#1,	r10	;16-bit words
    703c:	30 41       	ret			

0000703e <elyCmdValidate>:

bool elyCmdValidate(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    703e:	2a 15       	pushm	#3,	r10	;16-bit words

00007040 <.LCFI9>:
    7040:	21 83       	decd	r1		;

00007042 <.LCFI10>:
    7042:	09 4d       	mov	r13,	r9	;
    7044:	6a 4c       	mov.b	@r12,	r10	;
    7046:	0b 4a       	mov	r10,	r11	;
    7048:	5b 07       	rrum	#2,	r11	;

0000704a <.LVL74>:
    704a:	5d 4c 01 00 	mov.b	1(r12),	r13	;

0000704e <.LVL75>:
    704e:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007052 <.Loc.1754.2>:
  
  /* Check opcode */
  if (!(hdr.opcode < CMD_MAX)) {
    7052:	78 40 2f 00 	mov.b	#47,	r8	;#0x002f
    7056:	08 9b       	cmp	r11,	r8	;
    7058:	06 34       	jge	$+14     	;abs 0x7066

0000705a <.Loc.1755.2>:
    elyErrorSignal(ErrInvalidOpcode);
    705a:	7c 40 89 ff 	mov.b	#-119,	r12	;#0xff89

0000705e <.L177>:
    case CmdGetErr:
    case CmdGetLog:
    case CmdCancelFW:
    case CmdInstallFW:
      if (payload_len != 0) {
        elyErrorSignal(ErrInvalidLength);
    705e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007062 <.L65>:
      return false;
    7062:	4a 43       	clr.b	r10		;
    7064:	4a 3c       	jmp	$+150    	;abs 0x70fa

00007066 <.L35>:
  if (hdr.reply) {
    7066:	7a f0 03 00 	and.b	#3,	r10	;
    706a:	0c 4b       	mov	r11,	r12	;

0000706c <.LVL80>:
    706c:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7070:	4a dc       	bis.b	r12,	r10	;
    7072:	c1 4a 00 00 	mov.b	r10,	0(r1)	;
    7076:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    707a:	4e 4a       	mov.b	r10,	r14	;
    707c:	6e f3       	and.b	#2,	r14	;r3 As==10
    707e:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    7080:	0a 24       	jz	$+22     	;abs 0x7096

00007082 <.Loc.1761.2>:
    if (buff[2] == bank0p[RegSrcAddrMsb] && buff[3] == bank0p[RegSrcAddrLsb]) {
    7082:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    7086:	d9 9c 51 00 	cmp.b	81(r12),2(r9)	;0x00051
    708a:	02 00 
    708c:	04 20       	jnz	$+10     	;abs 0x7096

0000708e <.Loc.1761.2>:
    708e:	d9 9c 50 00 	cmp.b	80(r12),3(r9)	;0x00050
    7092:	03 00 
    7094:	e6 27       	jz	$-50     	;abs 0x7062

00007096 <.L37>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7096:	5a f3       	and.b	#1,	r10	;r3 As==01
    7098:	0a 93       	cmp	#0,	r10	;r3 As==00
    709a:	1d 24       	jz	$+60     	;abs 0x70d6
    709c:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000709e <.L38>:
    709e:	4f 4d       	mov.b	r13,	r15	;
    70a0:	4f 8e       	sub.b	r14,	r15	;
    70a2:	4f 8c       	sub.b	r12,	r15	;
    70a4:	4c 4f       	mov.b	r15,	r12	;

000070a6 <.LVL81>:
  switch(hdr.opcode) {
    70a6:	7b 90 16 00 	cmp.b	#22,	r11	;#0x0016
    70aa:	47 24       	jz	$+144    	;abs 0x713a
    70ac:	78 40 16 00 	mov.b	#22,	r8	;#0x0016
    70b0:	48 9b       	cmp.b	r11,	r8	;
    70b2:	64 28       	jnc	$+202    	;abs 0x717c
    70b4:	7b 90 0a 00 	cmp.b	#10,	r11	;#0x000a
    70b8:	40 24       	jz	$+130    	;abs 0x713a
    70ba:	78 40 0a 00 	mov.b	#10,	r8	;#0x000a
    70be:	48 9b       	cmp.b	r11,	r8	;
    70c0:	28 28       	jnc	$+82     	;abs 0x7112
    70c2:	6b 92       	cmp.b	#4,	r11	;r2 As==10
    70c4:	bc 24       	jz	$+378    	;abs 0x723e
    70c6:	68 42       	mov.b	#4,	r8	;r2 As==10
    70c8:	48 9b       	cmp.b	r11,	r8	;
    70ca:	07 28       	jnc	$+16     	;abs 0x70da
    70cc:	6b 93       	cmp.b	#2,	r11	;r3 As==10
    70ce:	35 20       	jnz	$+108    	;abs 0x713a

000070d0 <.L45>:
    case CmdSetTXPow:
    case CmdReloadConfig:
    case CmdGetChan:
    case CmdSetErr:
    case CmdSetLog:
      if (payload_len != 1) {
    70d0:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    70d2:	10 24       	jz	$+34     	;abs 0x70f4
    70d4:	34 3c       	jmp	$+106    	;abs 0x713e

000070d6 <.L66>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    70d6:	0c 4a       	mov	r10,	r12	;
    70d8:	e2 3f       	jmp	$-58     	;abs 0x709e

000070da <.L44>:
  switch(hdr.opcode) {
    70da:	7b 90 07 00 	cmp.b	#7,	r11	;
    70de:	bd 24       	jz	$+380    	;abs 0x725a
    70e0:	78 40 07 00 	mov.b	#7,	r8	;
    70e4:	48 9b       	cmp.b	r11,	r8	;
    70e6:	0d 28       	jnc	$+28     	;abs 0x7102
    70e8:	7b 90 05 00 	cmp.b	#5,	r11	;
    70ec:	ad 24       	jz	$+348    	;abs 0x7248
    70ee:	7b 90 06 00 	cmp.b	#6,	r11	;
    70f2:	a1 24       	jz	$+324    	;abs 0x7236

000070f4 <.L39>:
      /* Shouldn't happen */
      chDbgAssert(false, "invalid opcode in length check");
  }
  
  /* Check CRC */
  if (hdr.crc) {
    70f4:	0a 93       	cmp	#0,	r10	;r3 As==00
    70f6:	b8 20       	jnz	$+370    	;abs 0x7268

000070f8 <.L64>:
      elyErrorSignal(ErrFCSError);
      return false;
    }
  }
  
  return true;
    70f8:	5a 43       	mov.b	#1,	r10	;r3 As==01

000070fa <.L36>:
  
}
    70fa:	4c 4a       	mov.b	r10,	r12	;
    70fc:	21 53       	incd	r1		;
    70fe:	28 17       	popm	#3,	r10	;16-bit words
    7100:	30 41       	ret			

00007102 <.L47>:
  switch(hdr.opcode) {
    7102:	7b 92       	cmp.b	#8,	r11	;r2 As==11
    7104:	1a 24       	jz	$+54     	;abs 0x713a
    7106:	7b 90 09 00 	cmp.b	#9,	r11	;
    710a:	f4 23       	jnz	$-22     	;abs 0x70f4

0000710c <.L174>:
      if (payload_len != 2 && payload_len != 4 && 
    710c:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    710e:	17 20       	jnz	$+48     	;abs 0x713e
    7110:	f1 3f       	jmp	$-28     	;abs 0x70f4

00007112 <.L42>:
  switch(hdr.opcode) {
    7112:	7b 90 10 00 	cmp.b	#16,	r11	;#0x0010
    7116:	11 24       	jz	$+36     	;abs 0x713a
    7118:	78 40 10 00 	mov.b	#16,	r8	;#0x0010
    711c:	48 9b       	cmp.b	r11,	r8	;
    711e:	19 28       	jnc	$+52     	;abs 0x7152
    7120:	7b 90 0d 00 	cmp.b	#13,	r11	;#0x000d
    7124:	f3 27       	jz	$-24     	;abs 0x710c
    7126:	78 40 0d 00 	mov.b	#13,	r8	;#0x000d
    712a:	48 9b       	cmp.b	r11,	r8	;
    712c:	0b 28       	jnc	$+24     	;abs 0x7144
    712e:	7b 90 0b 00 	cmp.b	#11,	r11	;#0x000b
    7132:	ec 27       	jz	$-38     	;abs 0x710c
    7134:	7b 90 0c 00 	cmp.b	#12,	r11	;#0x000c
    7138:	dd 23       	jnz	$-68     	;abs 0x70f4

0000713a <.L40>:
      if (payload_len != 0) {
    713a:	0c 93       	cmp	#0,	r12	;r3 As==00
    713c:	db 27       	jz	$-72     	;abs 0x70f4

0000713e <.L62>:
        elyErrorSignal(ErrInvalidLength);
    713e:	7c 40 8a ff 	mov.b	#-118,	r12	;#0xff8a
    7142:	8d 3f       	jmp	$-228    	;abs 0x705e

00007144 <.L52>:
  switch(hdr.opcode) {
    7144:	7b 90 0e 00 	cmp.b	#14,	r11	;#0x000e
    7148:	f8 27       	jz	$-14     	;abs 0x713a
    714a:	7b 90 0f 00 	cmp.b	#15,	r11	;#0x000f
    714e:	de 27       	jz	$-66     	;abs 0x710c
    7150:	d1 3f       	jmp	$-92     	;abs 0x70f4

00007152 <.L51>:
    7152:	7b 90 13 00 	cmp.b	#19,	r11	;#0x0013
    7156:	da 27       	jz	$-74     	;abs 0x710c
    7158:	78 40 13 00 	mov.b	#19,	r8	;#0x0013
    715c:	48 9b       	cmp.b	r11,	r8	;
    715e:	07 28       	jnc	$+16     	;abs 0x716e
    7160:	7b 90 11 00 	cmp.b	#17,	r11	;#0x0011
    7164:	d3 27       	jz	$-88     	;abs 0x710c
    7166:	7b 90 12 00 	cmp.b	#18,	r11	;#0x0012
    716a:	e7 27       	jz	$-48     	;abs 0x713a
    716c:	c3 3f       	jmp	$-120    	;abs 0x70f4

0000716e <.L53>:
    716e:	7b 90 14 00 	cmp.b	#20,	r11	;#0x0014
    7172:	e3 27       	jz	$-56     	;abs 0x713a
    7174:	7b 90 15 00 	cmp.b	#21,	r11	;#0x0015
    7178:	ab 27       	jz	$-168    	;abs 0x70d0
    717a:	bc 3f       	jmp	$-134    	;abs 0x70f4

0000717c <.L41>:
    717c:	7b 90 24 00 	cmp.b	#36,	r11	;#0x0024
    7180:	c5 27       	jz	$-116    	;abs 0x710c
    7182:	78 40 24 00 	mov.b	#36,	r8	;#0x0024
    7186:	48 9b       	cmp.b	r11,	r8	;
    7188:	2e 28       	jnc	$+94     	;abs 0x71e6
    718a:	7b 90 1c 00 	cmp.b	#28,	r11	;#0x001c
    718e:	57 24       	jz	$+176    	;abs 0x723e
    7190:	78 40 1c 00 	mov.b	#28,	r8	;#0x001c
    7194:	48 9b       	cmp.b	r11,	r8	;
    7196:	19 28       	jnc	$+52     	;abs 0x71ca
    7198:	7b 90 19 00 	cmp.b	#25,	r11	;#0x0019
    719c:	11 24       	jz	$+36     	;abs 0x71c0
    719e:	7c 40 19 00 	mov.b	#25,	r12	;#0x0019
    71a2:	4c 9b       	cmp.b	r11,	r12	;
    71a4:	07 28       	jnc	$+16     	;abs 0x71b4
    71a6:	7b 90 17 00 	cmp.b	#23,	r11	;#0x0017
    71aa:	b0 27       	jz	$-158    	;abs 0x710c
    71ac:	7b 90 18 00 	cmp.b	#24,	r11	;#0x0018
    71b0:	8f 27       	jz	$-224    	;abs 0x70d0
    71b2:	a0 3f       	jmp	$-190    	;abs 0x70f4

000071b4 <.L57>:
    71b4:	7b 90 1a 00 	cmp.b	#26,	r11	;#0x001a
    71b8:	42 24       	jz	$+134    	;abs 0x723e
    71ba:	7b 90 1b 00 	cmp.b	#27,	r11	;#0x001b
    71be:	9a 23       	jnz	$-202    	;abs 0x70f4

000071c0 <.L56>:
      if (payload_len < 4 || payload_len > 251) {
    71c0:	7f 50 fc ff 	add.b	#-4,	r15	;#0xfffc

000071c4 <.LVL91>:
    71c4:	7c 40 f7 ff 	mov.b	#-9,	r12	;#0xfff7
    71c8:	3c 3c       	jmp	$+122    	;abs 0x7242

000071ca <.L55>:
  switch(hdr.opcode) {
    71ca:	78 40 22 00 	mov.b	#34,	r8	;#0x0022
    71ce:	48 9b       	cmp.b	r11,	r8	;
    71d0:	b4 2b       	jnc	$-150    	;abs 0x713a
    71d2:	7b 90 1f 00 	cmp.b	#31,	r11	;#0x001f
    71d6:	33 2c       	jc	$+104    	;abs 0x723e
    71d8:	7b 90 1d 00 	cmp.b	#29,	r11	;#0x001d
    71dc:	79 27       	jz	$-268    	;abs 0x70d0
    71de:	7b 90 1e 00 	cmp.b	#30,	r11	;#0x001e
    71e2:	88 23       	jnz	$-238    	;abs 0x70f4
    71e4:	aa 3f       	jmp	$-170    	;abs 0x713a

000071e6 <.L54>:
    71e6:	7b 90 2a 00 	cmp.b	#42,	r11	;#0x002a
    71ea:	ea 27       	jz	$-42     	;abs 0x71c0
    71ec:	78 40 2a 00 	mov.b	#42,	r8	;#0x002a
    71f0:	48 9b       	cmp.b	r11,	r8	;
    71f2:	0d 28       	jnc	$+28     	;abs 0x720e
    71f4:	7b 90 27 00 	cmp.b	#39,	r11	;#0x0027
    71f8:	6b 27       	jz	$-296    	;abs 0x70d0
    71fa:	7b 90 27 00 	cmp.b	#39,	r11	;#0x0027
    71fe:	9d 2b       	jnc	$-196    	;abs 0x713a
    7200:	7b 90 28 00 	cmp.b	#40,	r11	;#0x0028
    7204:	9a 27       	jz	$-202    	;abs 0x713a
    7206:	7b 90 29 00 	cmp.b	#41,	r11	;#0x0029
    720a:	62 27       	jz	$-314    	;abs 0x70d0
    720c:	73 3f       	jmp	$-280    	;abs 0x70f4

0000720e <.L58>:
    720e:	78 40 2d 00 	mov.b	#45,	r8	;#0x002d
    7212:	48 9b       	cmp.b	r11,	r8	;
    7214:	06 28       	jnc	$+14     	;abs 0x7222
    7216:	7b 90 2c 00 	cmp.b	#44,	r11	;#0x002c
    721a:	8f 2f       	jc	$-224    	;abs 0x713a

0000721c <.Loc.1807.2>:
      if (payload_len != 2) {
    721c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    721e:	6a 27       	jz	$-298    	;abs 0x70f4
    7220:	8e 3f       	jmp	$-226    	;abs 0x713e

00007222 <.L59>:
  switch(hdr.opcode) {
    7222:	7b 90 2e 00 	cmp.b	#46,	r11	;#0x002e
    7226:	0b 24       	jz	$+24     	;abs 0x723e
    7228:	7b 90 2f 00 	cmp.b	#47,	r11	;#0x002f
    722c:	63 23       	jnz	$-312    	;abs 0x70f4

0000722e <.Loc.1835.2>:
      if (payload_len != 2 && payload_len != 4 && 
    722e:	7f c2       	bic.b	#8,	r15	;r2 As==11

00007230 <.LVL93>:
    7230:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    7232:	6c 23       	jnz	$-294    	;abs 0x710c
    7234:	5f 3f       	jmp	$-320    	;abs 0x70f4

00007236 <.L49>:
      if (payload_len != 3) {
    7236:	7f 90 03 00 	cmp.b	#3,	r15	;
    723a:	5c 27       	jz	$-326    	;abs 0x70f4
    723c:	80 3f       	jmp	$-254    	;abs 0x713e

0000723e <.L43>:
      if (payload_len > 251) {
    723e:	7c 40 fb ff 	mov.b	#-5,	r12	;#0xfffb

00007242 <.L176>:
      if (payload_len < 4 || payload_len > 251) {
    7242:	4c 9f       	cmp.b	r15,	r12	;
    7244:	57 2f       	jc	$-336    	;abs 0x70f4
    7246:	7b 3f       	jmp	$-264    	;abs 0x713e

00007248 <.L48>:
      if (payload_len < 1 || !(payload_len & 0x01) || payload_len > 251) {
    7248:	4c 4f       	mov.b	r15,	r12	;
    724a:	7c 53       	add.b	#-1,	r12	;r3 As==11
    724c:	7e 40 fa ff 	mov.b	#-6,	r14	;#0xfffa
    7250:	4e 9c       	cmp.b	r12,	r14	;
    7252:	75 2b       	jnc	$-276    	;abs 0x713e

00007254 <.Loc.1857.2>:
    7254:	1f b3       	bit	#1,	r15	;r3 As==01
    7256:	4e 23       	jnz	$-354    	;abs 0x70f4
    7258:	72 3f       	jmp	$-282    	;abs 0x713e

0000725a <.L46>:
      if (payload_len < 2 || payload_len > 251) {
    725a:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

0000725e <.LVL97>:
    725e:	78 40 f9 ff 	mov.b	#-7,	r8	;#0xfff9
    7262:	48 9f       	cmp.b	r15,	r8	;
    7264:	47 2f       	jc	$-368    	;abs 0x70f4
    7266:	6b 3f       	jmp	$-296    	;abs 0x713e

00007268 <.L63>:
    if (!crcCheckX25(buff, hdr.length + 2)) {
    7268:	2d 53       	incd	r13		;

0000726a <.LVL99>:
    726a:	0c 49       	mov	r9,	r12	;
    726c:	b0 12 5c 9b 	call	#-25764	;#0x9b5c

00007270 <.LVL100>:
    7270:	4a 4c       	mov.b	r12,	r10	;
    7272:	0a 93       	cmp	#0,	r10	;r3 As==00
    7274:	41 23       	jnz	$-380    	;abs 0x70f8

00007276 <.Loc.1887.2>:
      elyErrorSignal(ErrFCSError);
    7276:	7c 40 8b ff 	mov.b	#-117,	r12	;#0xff8b
    727a:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000727e <.LVL101>:
      return false;
    727e:	3d 3f       	jmp	$-388    	;abs 0x70fa

00007280 <elyCmdDispatch>:
    7280:	21 83       	decd	r1		;

00007282 <.LCFI11>:

void elyCmdDispatch(elysium_cmd_hdr_t hdr, uint8_t * buff) {
    7282:	0b 4d       	mov	r13,	r11	;
    7284:	6e 4c       	mov.b	@r12,	r14	;
    7286:	0d 4e       	mov	r14,	r13	;

00007288 <.LVL103>:
    7288:	5d 07       	rrum	#2,	r13	;

0000728a <.LVL104>:
    728a:	d1 4c 01 00 	mov.b	1(r12),	1(r1)	;
    728e:	01 00 

00007290 <.Loc.1898.2>:
  /* Dispatch */
  handlers[hdr.opcode](buff, hdr);
    7290:	0c 4d       	mov	r13,	r12	;
    7292:	0c 5d       	add	r13,	r12	;
    7294:	1f 4c 9a be 	mov	-16742(r12),r15	;0xffffbe9a
    7298:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;

0000729c <.LVL106>:
    729c:	7e f0 03 00 	and.b	#3,	r14	;

000072a0 <.LVL107>:
    72a0:	4e dd       	bis.b	r13,	r14	;
    72a2:	c1 4e 00 00 	mov.b	r14,	0(r1)	;

000072a6 <L0>:
    72a6:	0d 41       	mov	r1,	r13	;
    72a8:	0c 4b       	mov	r11,	r12	;
    72aa:	8f 12       	call	r15		;

000072ac <.LVL108>:
}
    72ac:	21 53       	incd	r1		;
    72ae:	30 41       	ret			

000072b0 <elyCmdSendReplyI>:
  msg = elyCmdSendReplyI(buff);
  chSysUnlock();
  return msg;
}

msg_t elyCmdSendReplyI(uint8_t * buff) {
    72b0:	0a 15       	pushm	#1,	r10	;16-bit words

000072b2 <.LCFI12>:
  uint8_t * buffer = elyNLPack(buff);
    72b2:	b0 12 32 ab 	call	#-21710	;#0xab32

000072b6 <.LVL110>:
    72b6:	0a 4c       	mov	r12,	r10	;

000072b8 <.Loc.1911.2>:
  switch (elyNLGetDest(buffer)) {
    72b8:	b0 12 10 aa 	call	#-22000	;#0xaa10

000072bc <.LVL112>:
    72bc:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    72be:	07 24       	jz	$+16     	;abs 0x72ce
    72c0:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    72c2:	09 20       	jnz	$+20     	;abs 0x72d6

000072c4 <.Loc.1913.2>:
    case ELY_DEST_RF:
      return elyRFPostI(buffer);
    72c4:	0c 4a       	mov	r10,	r12	;
    72c6:	b0 12 2e a2 	call	#-24018	;#0xa22e

000072ca <.L179>:
      chDbgAssert(false, "shouldn't happen");
      break;
  }
  /* also shouldn't happen */
  return MSG_RESET;
}
    72ca:	0a 17       	popm	#1,	r10	;16-bit words
    72cc:	30 41       	ret			

000072ce <.L181>:
      return elyUARTPostI(buffer);
    72ce:	0c 4a       	mov	r10,	r12	;
    72d0:	b0 12 7a 6b 	call	#27514		;#0x6b7a

000072d4 <.LVL114>:
    72d4:	fa 3f       	jmp	$-10     	;abs 0x72ca

000072d6 <.L184>:
  return MSG_RESET;
    72d6:	3c 40 fe ff 	mov	#-2,	r12	;#0xfffe
    72da:	f7 3f       	jmp	$-16     	;abs 0x72ca

000072dc <store_telem_reply_cb>:
    72dc:	0a 15       	pushm	#1,	r10	;16-bit words

000072de <.LCFI13>:
  buffer = buffer - 4;
    72de:	0a 4c       	mov	r12,	r10	;

000072e0 <L0>:
    72e0:	3a 50 fc ff 	add	#-4,	r10	;#0xfffc

000072e4 <.LVL116>:
  gen_success(buffer, buffer[0] & 0x80); /* crc */
    72e4:	5d 4c fc ff 	mov.b	-4(r12),r13	;
    72e8:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    72ec:	0c 4a       	mov	r10,	r12	;
    72ee:	b0 12 28 6e 	call	#28200		;#0x6e28

000072f2 <.LVL117>:
  chSysLockFromISR();
    72f2:	b0 12 98 44 	call	#17560		;#0x4498

000072f6 <.LVL118>:
  elyCmdSendReplyI(buffer);
    72f6:	0c 4a       	mov	r10,	r12	;
    72f8:	b0 12 b0 72 	call	#29360		;#0x72b0

000072fc <.LVL119>:
  chSysUnlockFromISR();
    72fc:	b0 12 b8 44 	call	#17592		;#0x44b8

00007300 <.LVL120>:
}
    7300:	0a 17       	popm	#1,	r10	;16-bit words
    7302:	30 41       	ret			

00007304 <install_fw>:
static void install_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    7304:	0a 15       	pushm	#1,	r10	;16-bit words

00007306 <.LCFI14>:
    7306:	21 83       	decd	r1		;

00007308 <.LCFI15>:
    7308:	0a 4c       	mov	r12,	r10	;
    730a:	0e 4d       	mov	r13,	r14	;

0000730c <.LVL122>:
  if (hdr.reply) {
    730c:	6d 4d       	mov.b	@r13,	r13	;

0000730e <.LVL123>:
    730e:	5d f3       	and.b	#1,	r13	;r3 As==01
    7310:	ee b3 00 00 	bit.b	#2,	0(r14)	;r3 As==10
    7314:	0d 24       	jz	$+28     	;abs 0x7330

00007316 <.Loc.1597.2>:
    gen_success(buffer, hdr.crc);
    7316:	b0 12 28 6e 	call	#28200		;#0x6e28

0000731a <.LVL124>:
    elyCmdSendReplyI(buffer);
    731a:	0c 4a       	mov	r10,	r12	;
    731c:	b0 12 b0 72 	call	#29360		;#0x72b0

00007320 <.L188>:
  bootloader = 1;
    7320:	d2 43 fc 19 	mov.b	#1,	&0x19fc	;r3 As==01

00007324 <.Loc.1606.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    7324:	b2 40 48 a5 	mov	#-23224,&0x0120	;#0xa548
    7328:	20 01 

0000732a <.Loc.1608.2>:
}
    732a:	21 53       	incd	r1		;
    732c:	0a 17       	popm	#1,	r10	;16-bit words
    732e:	30 41       	ret			

00007330 <.L187>:
    elyNLFreeBufferI(elyNLPack(buffer));
    7330:	b0 12 32 ab 	call	#-21710	;#0xab32

00007334 <.LVL127>:
    7334:	b0 12 fa a9 	call	#-22022	;#0xa9fa

00007338 <.LVL128>:
    7338:	f3 3f       	jmp	$-24     	;abs 0x7320

0000733a <cancel_fw>:
    733a:	5a 15       	pushm	#6,	r10	;16-bit words

0000733c <L0>:
static void cancel_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    733c:	21 82       	sub	#4,	r1	;r2 As==10

0000733e <.LCFI17>:
    733e:	0a 4c       	mov	r12,	r10	;
    7340:	67 4d       	mov.b	@r13,	r7	;
    7342:	57 f3       	and.b	#1,	r7	;r3 As==01

00007344 <.Loc.1524.2>:
    7344:	e1 4d 02 00 	mov.b	@r13,	2(r1)	;
    7348:	d1 4d 01 00 	mov.b	1(r13),	3(r1)	;
    734c:	03 00 

0000734e <.Loc.1525.2>:
  stored_buff = buffer; /* store for freeing */
    734e:	82 4c 62 cd 	mov	r12,	&0xcd62	;

00007352 <.LVL132>:
    7352:	38 40 00 04 	mov	#1024,	r8	;#0x0400
    7356:	59 43       	mov.b	#1,	r9	;r3 As==01

00007358 <.LBB46>:
    chSysLock();
    7358:	36 40 0a 6e 	mov	#28170,	r6	;#0x6e0a
    735c:	35 40 5a 44 	mov	#17498,	r5	;#0x445a

00007360 <.L193>:
    7360:	86 12       	call	r6		;

00007362 <.LVL134>:
    7362:	85 12       	call	r5		;

00007364 <.LVL135>:
    elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    7364:	4d 43       	clr.b	r13		;
    7366:	0c 41       	mov	r1,	r12	;
    7368:	b0 12 9a ae 	call	#-20838	;#0xae9a

0000736c <.LVL136>:
    chSysUnlock();
    736c:	b0 12 78 44 	call	#17528		;#0x4478

00007370 <.LVL137>:
    7370:	b0 12 10 6e 	call	#28176		;#0x6e10

00007374 <.LVL138>:
    pages_sent++;
    7374:	92 53 5e cd 	inc	&0xcd5e		;

00007378 <.Loc.1563.2>:
    req->address = FRAM_FW_BASE + (i * 128); 
    7378:	2c 41       	mov	@r1,	r12	;
    737a:	8c 48 00 00 	mov	r8,	0(r12)	;
    737e:	8c 49 02 00 	mov	r9,	2(r12)	;

00007382 <.Loc.1564.2>:
    req->read = 0;
    7382:	5d 4c 04 00 	mov.b	4(r12),	r13	;
    7386:	6d c3       	bic.b	#2,	r13	;r3 As==10

00007388 <.Loc.1565.2>:
    req->special = 1; /* write a constant value */
    7388:	5d d3       	bis.b	#1,	r13	;r3 As==01
    738a:	cc 4d 04 00 	mov.b	r13,	4(r12)	;

0000738e <.Loc.1566.2>:
    req->size = 128;
    738e:	1d 4c 04 00 	mov	4(r12),	r13	;
    7392:	7d f0 03 00 	and.b	#3,	r13	;
    7396:	3d d0 00 02 	bis	#512,	r13	;#0x0200
    739a:	8c 4d 04 00 	mov	r13,	4(r12)	;
    739e:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    73a2:	06 00 

000073a4 <.Loc.1567.2>:
    req->buffer = &fill_value; 
    73a4:	bc 40 5a cd 	mov	#-12966,8(r12)	;#0xcd5a
    73a8:	08 00 

000073aa <.Loc.1568.2>:
    req->callback = cancel_fw_eeprom_cb;
    73aa:	bc 40 ee 6f 	mov	#28654,	10(r12)	;#0x6fee, 0x000a
    73ae:	0a 00 

000073b0 <.Loc.1572.2>:
    elyFramPostRequest(req);
    73b0:	b0 12 c0 ae 	call	#-20800	;#0xaec0

000073b4 <.LBB47>:
  return chSemWaitTimeout(&bsp->sem, time);
    73b4:	4d 43       	clr.b	r13		;
    73b6:	3c 40 60 cd 	mov	#-12960,r12	;#0xcd60
    73ba:	b0 12 e2 47 	call	#18402		;#0x47e2

000073be <.LVL140>:
    73be:	38 50 80 00 	add	#128,	r8	;#0x0080
    73c2:	09 63       	adc	r9		;

000073c4 <.LBE47>:
  for (size_t i = 0; i < FRAM_FW_SIZE/128; i++) {
    73c4:	08 93       	cmp	#0,	r8	;r3 As==00
    73c6:	cc 23       	jnz	$-102    	;abs 0x7360
    73c8:	29 93       	cmp	#2,	r9	;r3 As==10
    73ca:	ca 23       	jnz	$-106    	;abs 0x7360

000073cc <.LBE46>:
  if (hdr.reply) {
    73cc:	e1 b3 02 00 	bit.b	#2,	2(r1)	;r3 As==10
    73d0:	0a 24       	jz	$+22     	;abs 0x73e6

000073d2 <.Loc.1580.2>:
    gen_success(buffer, hdr.crc);
    73d2:	4d 47       	mov.b	r7,	r13	;
    73d4:	0c 4a       	mov	r10,	r12	;
    73d6:	b0 12 28 6e 	call	#28200		;#0x6e28

000073da <.LVL141>:
    elyCmdSendReplyI(buffer);
    73da:	0c 4a       	mov	r10,	r12	;
    73dc:	b0 12 b0 72 	call	#29360		;#0x72b0

000073e0 <.L189>:
}
    73e0:	21 52       	add	#4,	r1	;r2 As==10
    73e2:	55 17       	popm	#6,	r10	;16-bit words
    73e4:	30 41       	ret			

000073e6 <.L191>:
    elyNLFreeBufferI(elyNLPack(stored_buff));
    73e6:	1c 42 62 cd 	mov	&0xcd62,r12	;0xcd62
    73ea:	b0 12 32 ab 	call	#-21710	;#0xab32

000073ee <.LVL143>:
    73ee:	b0 12 fa a9 	call	#-22022	;#0xa9fa

000073f2 <.LVL144>:
}
    73f2:	f6 3f       	jmp	$-18     	;abs 0x73e0

000073f4 <verify_fw_cb>:
    73f4:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

000073f6 <L0>:
  uint16_t result = crcStop();
    73f6:	a2 9b       	cmp	@r11		; Warning: disassembly unreliable - not enough bytes available

000073f8 <.LVL146>:
    73f8:	1e 42 62 cd 	mov	&0xcd62,r14	;0xcd62

000073fc <.Loc.1453.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    73fc:	6d 4e       	mov.b	@r14,	r13	;
    73fe:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80

00007402 <.Loc.1452.2>:
  if (result == verify_crc) {
    7402:	1c 92 64 cd 	cmp	&0xcd64,r12	;0xcd64
    7406:	0c 20       	jnz	$+26     	;abs 0x7420

00007408 <.Loc.1453.2>:
    gen_success(stored_buff, stored_buff[0] & 0x80); /* crc */
    7408:	0c 4e       	mov	r14,	r12	;

0000740a <.LVL147>:
    740a:	b0 12 28 6e 	call	#28200		;#0x6e28

0000740e <.L196>:
  chSysLockFromISR();
    740e:	b0 12 98 44 	call	#17560		;#0x4498

00007412 <.LVL149>:
  elyCmdSendReplyI(stored_buff);
    7412:	1c 42 62 cd 	mov	&0xcd62,r12	;0xcd62
    7416:	b0 12 b0 72 	call	#29360		;#0x72b0

0000741a <.LVL150>:
  chSysUnlockFromISR();
    741a:	b0 12 b8 44 	call	#17592		;#0x44b8

0000741e <.LVL151>:
}
    741e:	30 41       	ret			

00007420 <.L195>:
    gen_failure(stored_buff, stored_buff[0] & 0x80); /* crc */
    7420:	0c 4e       	mov	r14,	r12	;

00007422 <.LVL153>:
    7422:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007426 <.LVL154>:
    7426:	f3 3f       	jmp	$-24     	;abs 0x740e

00007428 <upload_fw_reply_cb>:
    7428:	1a 15       	pushm	#2,	r10	;16-bit words

0000742a <L0>:
static void upload_fw_reply_cb(uint8_t * buffer) {
    742a:	09 4c       	mov	r12,	r9	;

0000742c <.Loc.1391.2>:
  buffer = buffer - 8;
    742c:	0a 4c       	mov	r12,	r10	;
    742e:	3a 50 f8 ff 	add	#-8,	r10	;#0xfff8

00007432 <.LVL156>:
  chSysLockFromISR();
    7432:	b0 12 98 44 	call	#17560		;#0x4498

00007436 <.LVL157>:
    gen_success(buffer, buffer[0] & 0x80); /* crc */
    7436:	5d 49 f8 ff 	mov.b	-8(r9),	r13	;
    743a:	7d f0 80 ff 	and.b	#-128,	r13	;#0xff80
    743e:	0c 4a       	mov	r10,	r12	;
    7440:	b0 12 28 6e 	call	#28200		;#0x6e28

00007444 <.LVL158>:
    elyCmdSendReplyI(buffer);
    7444:	0c 4a       	mov	r10,	r12	;
    7446:	b0 12 b0 72 	call	#29360		;#0x72b0

0000744a <.LVL159>:
  chSysUnlockFromISR();
    744a:	b0 12 b8 44 	call	#17592		;#0x44b8

0000744e <.LVL160>:
}
    744e:	19 17       	popm	#2,	r10	;16-bit words
    7450:	30 41       	ret			

00007452 <elyCmdSendReply>:
msg_t elyCmdSendReply(uint8_t * buff) {
    7452:	21 83       	decd	r1		;

00007454 <.LCFI19>:
  chSysLock();
    7454:	81 4c 00 00 	mov	r12,	0(r1)	;
    7458:	b0 12 0a 6e 	call	#28170		;#0x6e0a

0000745c <.LVL162>:
    745c:	b0 12 5a 44 	call	#17498		;#0x445a

00007460 <.LVL163>:
  msg = elyCmdSendReplyI(buff);
    7460:	2c 41       	mov	@r1,	r12	;
    7462:	b0 12 b0 72 	call	#29360		;#0x72b0

00007466 <.LVL164>:
  chSysUnlock();
    7466:	81 4c 00 00 	mov	r12,	0(r1)	;
    746a:	b0 12 78 44 	call	#17528		;#0x4478

0000746e <.LVL165>:
    746e:	b0 12 10 6e 	call	#28176		;#0x6e10

00007472 <.LVL166>:
}
    7472:	2c 41       	mov	@r1,	r12	;
    7474:	21 53       	incd	r1		;
    7476:	30 41       	ret			

00007478 <get_telem>:
static void get_telem(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7478:	6a 15       	pushm	#7,	r10	;16-bit words

0000747a <.LCFI20>:
    747a:	31 80 16 00 	sub	#22,	r1	;#0x0016

0000747e <.LCFI21>:
    747e:	0a 4c       	mov	r12,	r10	;

00007480 <.LVL168>:
    7480:	5e 4d 01 00 	mov.b	1(r13),	r14	;

00007484 <.LVL169>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7484:	6b 4d       	mov.b	@r13,	r11	;
    7486:	5b f3       	and.b	#1,	r11	;r3 As==01
    7488:	c1 4b 05 00 	mov.b	r11,	5(r1)	;
    748c:	6d 4d       	mov.b	@r13,	r13	;

0000748e <.LVL170>:
    748e:	44 4d       	mov.b	r13,	r4	;
    7490:	64 f3       	and.b	#2,	r4	;r3 As==10
    7492:	45 44       	mov.b	r4,	r5	;
    7494:	05 93       	cmp	#0,	r5	;r3 As==00
    7496:	42 20       	jnz	$+134    	;abs 0x751c
    7498:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000749a <.L200>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    749a:	1d b3       	bit	#1,	r13	;r3 As==01
    749c:	41 20       	jnz	$+132    	;abs 0x7520

0000749e <.Loc.1645.2>:
    749e:	4f 43       	clr.b	r15		;

000074a0 <.L201>:
    74a0:	4d 4e       	mov.b	r14,	r13	;
    74a2:	4d 84       	sub.b	r4,	r13	;

000074a4 <.LVL172>:
    74a4:	4d 8f       	sub.b	r15,	r13	;

000074a6 <.LVL173>:
  config.duration = ((buffer[hdr_ext] << 8) | buffer[hdr_ext+1]);
    74a6:	0e 4a       	mov	r10,	r14	;

000074a8 <.LVL174>:
    74a8:	0e 5c       	add	r12,	r14	;
    74aa:	6f 4e       	mov.b	@r14,	r15	;
    74ac:	47 18 0f 5f 	rpt #8 { rlax.w	r15		;
    74b0:	5b 4e 01 00 	mov.b	1(r14),	r11	;
    74b4:	0b df       	bis	r15,	r11	;
    74b6:	81 4b 10 00 	mov	r11,	16(r1)	; 0x0010

000074ba <.Loc.1650.2>:
  if (payload_len == 4 || payload_len == 12) {
    74ba:	4f 4d       	mov.b	r13,	r15	;
    74bc:	7f c2       	bic.b	#8,	r15	;r2 As==11
    74be:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    74c0:	60 20       	jnz	$+194    	;abs 0x7582

000074c2 <.LVL175>:
    config.index_start = buffer[hdr_ext+2];
    74c2:	d1 4e 02 00 	mov.b	2(r14),	18(r1)	; 0x0012
    74c6:	12 00 

000074c8 <.Loc.1653.2>:
    config.index_end = buffer[hdr_ext+3];
    74c8:	d1 4e 03 00 	mov.b	3(r14),	19(r1)	; 0x0013
    74cc:	13 00 

000074ce <.Loc.1659.2>:
  if (payload_len > 4) {
    74ce:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    74d0:	2f 20       	jnz	$+96     	;abs 0x7530

000074d2 <.L214>:
    config.use_index = true;
    74d2:	54 43       	mov.b	#1,	r4	;r3 As==01

000074d4 <.L204>:
  chSysLock();
    74d4:	b0 12 0a 6e 	call	#28170		;#0x6e0a

000074d8 <.LVL178>:
    74d8:	b0 12 5a 44 	call	#17498		;#0x445a

000074dc <.LVL179>:
  elyTelemUpdateConfigS(config);
    74dc:	81 49 08 00 	mov	r9,	8(r1)	;
    74e0:	81 48 0a 00 	mov	r8,	10(r1)	; 0x000a
    74e4:	81 47 0c 00 	mov	r7,	12(r1)	; 0x000c
    74e8:	81 46 0e 00 	mov	r6,	14(r1)	; 0x000e
    74ec:	c1 44 14 00 	mov.b	r4,	20(r1)	; 0x0014
    74f0:	0c 41       	mov	r1,	r12	;
    74f2:	3c 52       	add	#8,	r12	;r2 As==11
    74f4:	b0 12 6e ae 	call	#-20882	;#0xae6e

000074f8 <.LVL180>:
  chSysUnlock();
    74f8:	b0 12 78 44 	call	#17528		;#0x4478

000074fc <.LVL181>:
    74fc:	b0 12 10 6e 	call	#28176		;#0x6e10

00007500 <.LVL182>:
  if (hdr.reply) {
    7500:	05 93       	cmp	#0,	r5	;r3 As==00
    7502:	10 24       	jz	$+34     	;abs 0x7524

00007504 <.Loc.1681.2>:
    gen_success(buffer, hdr.crc);
    7504:	5d 41 05 00 	mov.b	5(r1),	r13	;
    7508:	0c 4a       	mov	r10,	r12	;
    750a:	b0 12 28 6e 	call	#28200		;#0x6e28

0000750e <.LVL183>:
    elyCmdSendReply(buffer);
    750e:	0c 4a       	mov	r10,	r12	;
    7510:	b0 12 52 74 	call	#29778		;#0x7452

00007514 <.L199>:
}
    7514:	31 50 16 00 	add	#22,	r1	;#0x0016
    7518:	64 17       	popm	#7,	r10	;16-bit words
    751a:	30 41       	ret			

0000751c <.L210>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    751c:	6c 42       	mov.b	#4,	r12	;r2 As==10
    751e:	bd 3f       	jmp	$-132    	;abs 0x749a

00007520 <.L211>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7520:	6f 43       	mov.b	#2,	r15	;r3 As==10
    7522:	be 3f       	jmp	$-130    	;abs 0x74a0

00007524 <.L207>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7524:	0c 4a       	mov	r10,	r12	;
    7526:	b0 12 32 ab 	call	#-21710	;#0xab32

0000752a <.LVL188>:
    752a:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000752e <.LVL189>:
}
    752e:	f2 3f       	jmp	$-26     	;abs 0x7514

00007530 <.L203>:
    config.use_timestamp = true;
    7530:	d1 43 15 00 	mov.b	#1,	21(r1)	;r3 As==01, 0x0015

00007534 <.LBB49>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    7534:	5e 4e 0a 00 	mov.b	10(r14),r14	;0x0000a
    7538:	81 4e 02 00 	mov	r14,	2(r1)	;
    753c:	3c 50 07 00 	add	#7,	r12	;

00007540 <.LVL191>:
    7540:	0e 4a       	mov	r10,	r14	;
    7542:	0e 5c       	add	r12,	r14	;
    7544:	44 43       	clr.b	r4		;

00007546 <.L205>:
        config.timestamp_start |= (buffer[hdr_ext + 7 - i] << (8 * i));
    7546:	6c 4e       	mov.b	@r14,	r12	;
    7548:	0d 44       	mov	r4,	r13	;
    754a:	81 4e 00 00 	mov	r14,	0(r1)	;
    754e:	b0 12 94 af 	call	#-20588	;#0xaf94
    7552:	0d 4c       	mov	r12,	r13	;
    7554:	0b 4c       	mov	r12,	r11	;
    7556:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    755a:	09 dd       	bis	r13,	r9	;

0000755c <.LVL194>:
    755c:	08 dc       	bis	r12,	r8	;

0000755e <.Loc.1664.2>:
        config.timestamp_end |= (buffer[hdr_ext + 11 - 1] << (8 * i));
    755e:	1c 41 02 00 	mov	2(r1),	r12	;
    7562:	0d 44       	mov	r4,	r13	;
    7564:	b0 12 94 af 	call	#-20588	;#0xaf94
    7568:	0d 4c       	mov	r12,	r13	;
    756a:	0b 4c       	mov	r12,	r11	;
    756c:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    7570:	07 dd       	bis	r13,	r7	;

00007572 <.LVL196>:
    7572:	06 dc       	bis	r12,	r6	;
    7574:	2e 41       	mov	@r1,	r14	;
    7576:	3e 53       	add	#-1,	r14	;r3 As==11
    7578:	34 52       	add	#8,	r4	;r2 As==11

0000757a <.Loc.1662.2>:
      for (int i = 0; i < 4; i++) {
    757a:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    757e:	e3 23       	jnz	$-56     	;abs 0x7546
    7580:	a8 3f       	jmp	$-174    	;abs 0x74d2

00007582 <.L202>:
  if (payload_len > 4) {
    7582:	6f 42       	mov.b	#4,	r15	;r2 As==10
    7584:	4f 9d       	cmp.b	r13,	r15	;
    7586:	28 2c       	jc	$+82     	;abs 0x75d8

00007588 <.Loc.1660.2>:
    config.use_timestamp = true;
    7588:	d1 43 15 00 	mov.b	#1,	21(r1)	;r3 As==01, 0x0015

0000758c <.LBB50>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    758c:	5e 4e 08 00 	mov.b	8(r14),	r14	;
    7590:	81 4e 02 00 	mov	r14,	2(r1)	;
    7594:	3c 50 05 00 	add	#5,	r12	;

00007598 <.LVL199>:
    7598:	0e 4a       	mov	r10,	r14	;
    759a:	0e 5c       	add	r12,	r14	;
    759c:	44 43       	clr.b	r4		;

0000759e <.L206>:
        config.timestamp_start |= (buffer[hdr_ext + 5 - i] << (8 * i));
    759e:	6c 4e       	mov.b	@r14,	r12	;
    75a0:	0d 44       	mov	r4,	r13	;
    75a2:	81 4e 00 00 	mov	r14,	0(r1)	;
    75a6:	b0 12 94 af 	call	#-20588	;#0xaf94
    75aa:	0d 4c       	mov	r12,	r13	;
    75ac:	0b 4c       	mov	r12,	r11	;
    75ae:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    75b2:	09 dd       	bis	r13,	r9	;

000075b4 <.LVL202>:
    75b4:	08 dc       	bis	r12,	r8	;

000075b6 <.Loc.1670.2>:
        config.timestamp_end |= (buffer[hdr_ext + 9 - 1] << (8 * i));
    75b6:	1c 41 02 00 	mov	2(r1),	r12	;
    75ba:	0d 44       	mov	r4,	r13	;
    75bc:	b0 12 94 af 	call	#-20588	;#0xaf94
    75c0:	0d 4c       	mov	r12,	r13	;
    75c2:	0b 4c       	mov	r12,	r11	;
    75c4:	4e 18 0c 11 	rpt #15 { rrax.w	r12		;
    75c8:	07 dd       	bis	r13,	r7	;

000075ca <.LVL204>:
    75ca:	06 dc       	bis	r12,	r6	;
    75cc:	2e 41       	mov	@r1,	r14	;
    75ce:	3e 53       	add	#-1,	r14	;r3 As==11
    75d0:	34 52       	add	#8,	r4	;r2 As==11

000075d2 <.Loc.1668.2>:
      for (int i = 0; i < 4; i++) {
    75d2:	34 90 20 00 	cmp	#32,	r4	;#0x0020
    75d6:	e3 23       	jnz	$-56     	;abs 0x759e

000075d8 <.L215>:
    config.use_index = false;
    75d8:	44 43       	clr.b	r4		;
    75da:	7c 3f       	jmp	$-262    	;abs 0x74d4

000075dc <upload_fw>:
    75dc:	6a 15       	pushm	#7,	r10	;16-bit words

000075de <.LCFI22>:
static void upload_fw(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    75de:	31 80 0c 00 	sub	#12,	r1	;#0x000c

000075e2 <.LCFI23>:
    75e2:	07 4c       	mov	r12,	r7	;
    75e4:	6b 4d       	mov.b	@r13,	r11	;

000075e6 <L0>:
    75e6:	5b f3       	and.b	#1,	r11	;r3 As==01

000075e8 <.LVL207>:
    75e8:	5a 4d 01 00 	mov.b	1(r13),	r10	;
    75ec:	81 4a 06 00 	mov	r10,	6(r1)	;

000075f0 <.LVL208>:
    75f0:	c1 4a 0b 00 	mov.b	r10,	11(r1)	; 0x000b

000075f4 <.Loc.1407.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    75f4:	6c 4d       	mov.b	@r13,	r12	;

000075f6 <.LVL210>:
    75f6:	5c c3       	bic.b	#1,	r12	;r3 As==01
    75f8:	4c db       	bis.b	r11,	r12	;
    75fa:	c1 4c 0a 00 	mov.b	r12,	10(r1)	; 0x000a
    75fe:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7602:	81 4c 02 00 	mov	r12,	2(r1)	;
    7606:	09 4c       	mov	r12,	r9	;
    7608:	69 f3       	and.b	#2,	r9	;r3 As==10
    760a:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    760e:	09 93       	cmp	#0,	r9	;r3 As==00
    7610:	31 20       	jnz	$+100    	;abs 0x7674
    7612:	68 43       	mov.b	#2,	r8	;r3 As==10

00007614 <.L217>:
    7614:	04 47       	mov	r7,	r4	;
    7616:	04 58       	add	r8,	r4	;

00007618 <.Loc.1407.2>:
    7618:	75 40 18 00 	mov.b	#24,	r5	;#0x0018

0000761c <.Loc.1408.2>:
  uint32_t address = 0;
    761c:	4a 43       	clr.b	r10		;
    761e:	06 4a       	mov	r10,	r6	;

00007620 <.L218>:
    address |= (uint32_t)(buffer[i + hdr_ext]) << (8 * (3-i));
    7620:	6c 44       	mov.b	@r4,	r12	;
    7622:	0d 43       	clr	r13		;
    7624:	0e 45       	mov	r5,	r14	;
    7626:	0f 43       	clr	r15		;
    7628:	81 4b 00 00 	mov	r11,	0(r1)	;
    762c:	b0 12 de af 	call	#-20514	;#0xafde
    7630:	0c da       	bis	r10,	r12	;
    7632:	0d d6       	bis	r6,	r13	;
    7634:	0a 4c       	mov	r12,	r10	;

00007636 <.LVL214>:
    7636:	06 4d       	mov	r13,	r6	;

00007638 <.LVL215>:
    7638:	14 53       	inc	r4		;

0000763a <.LVL216>:
    763a:	35 50 f8 ff 	add	#-8,	r5	;#0xfff8

0000763e <.Loc.1411.2>:
  for (int i = 0; i < 4; i++) {
    763e:	2b 41       	mov	@r1,	r11	;
    7640:	35 90 f8 ff 	cmp	#-8,	r5	;#0xfff8
    7644:	ed 23       	jnz	$-36     	;abs 0x7620

00007646 <.LBE51>:
  if (address < 0x4400 || address > 0x13FFF) {
    7646:	3c 50 00 bc 	add	#-17408,r12	;#0xbc00
    764a:	05 4d       	mov	r13,	r5	;
    764c:	35 63       	addc	#-1,	r5	;r3 As==11
    764e:	05 93       	cmp	#0,	r5	;r3 As==00
    7650:	04 20       	jnz	$+10     	;abs 0x765a
    7652:	3d 40 ff fb 	mov	#-1025,	r13	;#0xfbff
    7656:	0d 9c       	cmp	r12,	r13	;
    7658:	19 2c       	jc	$+52     	;abs 0x768c

0000765a <.L229>:
    if (hdr.reply) {
    765a:	09 93       	cmp	#0,	r9	;r3 As==00
    765c:	0d 24       	jz	$+28     	;abs 0x7678

0000765e <.Loc.1418.2>:
      gen_failure(buffer, hdr.crc);
    765e:	4d 4b       	mov.b	r11,	r13	;
    7660:	0c 47       	mov	r7,	r12	;
    7662:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007666 <.LVL217>:
      elyCmdSendReply(buffer);
    7666:	0c 47       	mov	r7,	r12	;
    7668:	b0 12 52 74 	call	#29778		;#0x7452

0000766c <.L216>:
}
    766c:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7670:	64 17       	popm	#7,	r10	;16-bit words
    7672:	30 41       	ret			

00007674 <.L226>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7674:	68 42       	mov.b	#4,	r8	;r2 As==10
    7676:	ce 3f       	jmp	$-98     	;abs 0x7614

00007678 <.L221>:
      elyErrorSignal(ErrCmdFailure);
    7678:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    767c:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007680 <.LVL221>:
      elyNLFreeBuffer(elyNLPack(buffer));
    7680:	0c 47       	mov	r7,	r12	;
    7682:	b0 12 32 ab 	call	#-21710	;#0xab32

00007686 <.LVL222>:
    7686:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000768a <.LVL223>:
    768a:	f0 3f       	jmp	$-30     	;abs 0x766c

0000768c <.L231>:
  elyFramGetRequest(&req);
    768c:	0c 41       	mov	r1,	r12	;
    768e:	3c 52       	add	#8,	r12	;r2 As==11
    7690:	b0 12 74 ae 	call	#-20876	;#0xae74

00007694 <.LVL224>:
  req->address = (address - 0x4400) + FRAM_FW_BASE;
    7694:	1c 41 08 00 	mov	8(r1),	r12	;
    7698:	3a 50 00 c0 	add	#-16384,r10	;#0xc000

0000769c <.LVL225>:
    769c:	8c 4a 00 00 	mov	r10,	0(r12)	;
    76a0:	06 63       	adc	r6		;
    76a2:	8c 46 02 00 	mov	r6,	2(r12)	;

000076a6 <.Loc.1436.2>:
  req->read = 0;
    76a6:	ec c3 04 00 	bic.b	#2,	4(r12)	;r3 As==10

000076aa <.Loc.1437.2>:
  req->size = hdr.length - (hdr.reply ? 2: 0) - (hdr.crc ? 2: 0) - 4;
    76aa:	1e 41 06 00 	mov	6(r1),	r14	;
    76ae:	0e 89       	sub	r9,	r14	;
    76b0:	91 b3 02 00 	bit	#1,	2(r1)	;r3 As==01
    76b4:	01 24       	jz	$+4      	;abs 0x76b8
    76b6:	65 43       	mov.b	#2,	r5	;r3 As==10

000076b8 <.L223>:
    76b8:	0e 85       	sub	r5,	r14	;
    76ba:	3e 50 fc ff 	add	#-4,	r14	;#0xfffc
    76be:	4e 0e       	rlam.a	#4,	r14	;
    76c0:	4e 0d       	rram.a	#4,	r14	;
    76c2:	80 18 7e f0 	andx.a	#131071,r14	;0x1ffff
    76c6:	ff ff 
    76c8:	71 0e 02 00 	mova	r14,	2(r1)	;
    76cc:	1d 41 02 00 	mov	2(r1),	r13	;
    76d0:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    76d4:	1e 4c 04 00 	mov	4(r12),	r14	;
    76d8:	7e f0 03 00 	and.b	#3,	r14	;
    76dc:	0e dd       	bis	r13,	r14	;
    76de:	8c 4e 04 00 	mov	r14,	4(r12)	;

000076e2 <.LVL227>:
    76e2:	1e 41 02 00 	mov	2(r1),	r14	;
    76e6:	0f 4e       	mov	r14,	r15	;
    76e8:	5f 03       	rrum	#1,	r15	;
    76ea:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    76ee:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    76f2:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    76f6:	3a 01 02 00 	mova	2(r1),	r10	;
    76fa:	0a 14       	pushm.a	#1,	r10	;20-bit words
    76fc:	0d 17       	popm	#1,	r13	;16-bit words
    76fe:	0d 17       	popm	#1,	r13	;16-bit words
    7700:	5d f3       	and.b	#1,	r13	;r3 As==01
    7702:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    7706:	4e df       	bis.b	r15,	r14	;
    7708:	4e dd       	bis.b	r13,	r14	;
    770a:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

0000770e <.Loc.1439.2>:
  req->buffer = &buffer[lookbehind];
    770e:	28 52       	add	#4,	r8	;r2 As==10

00007710 <.LVL228>:
    7710:	07 58       	add	r8,	r7	;

00007712 <.LVL229>:
    7712:	8c 47 08 00 	mov	r7,	8(r12)	;

00007716 <.Loc.1440.2>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    7716:	09 93       	cmp	#0,	r9	;r3 As==00
    7718:	07 20       	jnz	$+16     	;abs 0x7728

0000771a <.Loc.1440.2>:
    771a:	3d 40 40 6f 	mov	#28480,	r13	;#0x6f40

0000771e <.L224>:
    771e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007722 <.Loc.1444.2>:
  elyFramPostRequest(req);
    7722:	b0 12 c0 ae 	call	#-20800	;#0xaec0

00007726 <.LVL230>:
    7726:	a2 3f       	jmp	$-186    	;abs 0x766c

00007728 <.L228>:
  req->callback = (hdr.reply ? upload_fw_reply_cb : upload_fw_noreply_cb);
    7728:	3d 40 28 74 	mov	#29736,	r13	;#0x7428
    772c:	f8 3f       	jmp	$-14     	;abs 0x771e

0000772e <set_log>:
    772e:	3a 15       	pushm	#4,	r10	;16-bit words

00007730 <.LCFI24>:
static void set_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7730:	21 83       	decd	r1		;

00007732 <.LCFI25>:
    7732:	0a 4c       	mov	r12,	r10	;

00007734 <.LVL232>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7734:	67 4d       	mov.b	@r13,	r7	;

00007736 <L0>:
    7736:	57 f3       	and.b	#1,	r7	;r3 As==01
    7738:	69 4d       	mov.b	@r13,	r9	;
    773a:	69 f3       	and.b	#2,	r9	;r3 As==10
    773c:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7740:	09 93       	cmp	#0,	r9	;r3 As==00
    7742:	13 20       	jnz	$+40     	;abs 0x776a
    7744:	68 43       	mov.b	#2,	r8	;r3 As==10

00007746 <.L233>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    7746:	08 5a       	add	r10,	r8	;

00007748 <.LVL234>:
    7748:	6c 48       	mov.b	@r8,	r12	;

0000774a <.LVL235>:
    774a:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

0000774e <.LVL236>:
    774e:	4d 9c       	cmp.b	r12,	r13	;
    7750:	18 2c       	jc	$+50     	;abs 0x7782

00007752 <.Loc.1359.2>:
    if (hdr.reply) {
    7752:	09 93       	cmp	#0,	r9	;r3 As==00
    7754:	0c 24       	jz	$+26     	;abs 0x776e

00007756 <.Loc.1361.2>:
      gen_failure(buffer, hdr.crc);
    7756:	4d 47       	mov.b	r7,	r13	;
    7758:	0c 4a       	mov	r10,	r12	;
    775a:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000775e <.L239>:
    elyCmdSendReply(buffer);
    775e:	0c 4a       	mov	r10,	r12	;
    7760:	b0 12 52 74 	call	#29778		;#0x7452

00007764 <.L232>:
}
    7764:	21 53       	incd	r1		;
    7766:	37 17       	popm	#4,	r10	;16-bit words
    7768:	30 41       	ret			

0000776a <.L238>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    776a:	68 42       	mov.b	#4,	r8	;r2 As==10
    776c:	ec 3f       	jmp	$-38     	;abs 0x7746

0000776e <.L235>:
      elyErrorSignal(ErrCmdFailure);
    776e:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7772:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007776 <.L237>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7776:	0c 4a       	mov	r10,	r12	;
    7778:	b0 12 32 ab 	call	#-21710	;#0xab32

0000777c <.LVL242>:
    777c:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007780 <.LVL243>:
    7780:	f1 3f       	jmp	$-28     	;abs 0x7764

00007782 <.L234>:
  bank0w[RegErrLogLvl] = buffer[hdr_ext];
    7782:	1d 42 bc bd 	mov	&0xbdbc,r13	;0xbdbc
    7786:	cd 4c 4d 00 	mov.b	r12,	77(r13)	; 0x004d

0000778a <.Loc.1374.2>:
  chSysLock();
    778a:	b0 12 0a 6e 	call	#28170		;#0x6e0a

0000778e <.LVL244>:
    778e:	b0 12 5a 44 	call	#17498		;#0x445a

00007792 <.LVL245>:
  elyErrorSetLogLvlS(buffer[hdr_ext]);
    7792:	6c 48       	mov.b	@r8,	r12	;
    7794:	b0 12 6c ac 	call	#-21396	;#0xac6c

00007798 <.LVL246>:
  chSysUnlock();
    7798:	b0 12 78 44 	call	#17528		;#0x4478

0000779c <.LVL247>:
    779c:	b0 12 10 6e 	call	#28176		;#0x6e10

000077a0 <.LVL248>:
  if (hdr.reply) {
    77a0:	09 93       	cmp	#0,	r9	;r3 As==00
    77a2:	e9 27       	jz	$-44     	;abs 0x7776

000077a4 <.Loc.1380.2>:
    gen_success(buffer, hdr.crc);
    77a4:	4d 47       	mov.b	r7,	r13	;
    77a6:	0c 4a       	mov	r10,	r12	;
    77a8:	b0 12 28 6e 	call	#28200		;#0x6e28

000077ac <.LVL249>:
    77ac:	d8 3f       	jmp	$-78     	;abs 0x775e

000077ae <get_log>:
    77ae:	0a 15       	pushm	#1,	r10	;16-bit words

000077b0 <.LCFI26>:
static void get_log(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    77b0:	21 83       	decd	r1		;

000077b2 <.LCFI27>:
    77b2:	0a 4c       	mov	r12,	r10	;

000077b4 <L0>:
    77b4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    77b8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    77bc:	01 00 

000077be <.Loc.1334.2>:
  if (hdr.reply) {
    77be:	6e 41       	mov.b	@r1,	r14	;
    77c0:	2e b3       	bit	#2,	r14	;r3 As==10
    77c2:	20 24       	jz	$+66     	;abs 0x7804

000077c4 <.Loc.1335.2>:
    buffer[0] = buffer[0] & 0x3F;
    77c4:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    77c8:	00 00 

000077ca <.Loc.1336.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    77ca:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    77ce:	dc 4d 51 00 	mov.b	81(r13),2(r12)	;0x00051
    77d2:	02 00 

000077d4 <.Loc.1337.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    77d4:	dc 4d 50 00 	mov.b	80(r13),3(r12)	;0x00050
    77d8:	03 00 

000077da <.Loc.1338.2>:
    buffer[4] = bank0p[RegErrLogLvl];
    77da:	dc 4d 4d 00 	mov.b	77(r13),4(r12)	;0x0004d
    77de:	04 00 

000077e0 <.Loc.1339.2>:
    if (hdr.crc) {
    77e0:	1e b3       	bit	#1,	r14	;r3 As==01
    77e2:	0d 24       	jz	$+28     	;abs 0x77fe

000077e4 <.Loc.1340.2>:
      buffer[1] = 3;
    77e4:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    77e8:	01 00 

000077ea <.Loc.1341.2>:
      crcGenX25(buffer, 7);
    77ea:	7d 40 07 00 	mov.b	#7,	r13	;
    77ee:	b0 12 26 9b 	call	#-25818	;#0x9b26

000077f2 <.L243>:
    elyCmdSendReply(buffer);
    77f2:	0c 4a       	mov	r10,	r12	;
    77f4:	b0 12 52 74 	call	#29778		;#0x7452

000077f8 <.L240>:
}
    77f8:	21 53       	incd	r1		;
    77fa:	0a 17       	popm	#1,	r10	;16-bit words
    77fc:	30 41       	ret			

000077fe <.L242>:
      buffer[1] = 1;
    77fe:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    7802:	f7 3f       	jmp	$-16     	;abs 0x77f2

00007804 <.L241>:
    7804:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00007808 <.LVL253>:
}
    7808:	f7 3f       	jmp	$-16     	;abs 0x77f8

0000780a <set_err>:
    780a:	3a 15       	pushm	#4,	r10	;16-bit words

0000780c <.LCFI28>:
static void set_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    780c:	21 83       	decd	r1		;

0000780e <L0>:
    780e:	0a 4c       	mov	r12,	r10	;

00007810 <.LVL255>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7810:	67 4d       	mov.b	@r13,	r7	;
    7812:	57 f3       	and.b	#1,	r7	;r3 As==01
    7814:	69 4d       	mov.b	@r13,	r9	;
    7816:	69 f3       	and.b	#2,	r9	;r3 As==10
    7818:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    781c:	09 93       	cmp	#0,	r9	;r3 As==00
    781e:	13 20       	jnz	$+40     	;abs 0x7846
    7820:	68 43       	mov.b	#2,	r8	;r3 As==10

00007822 <.L246>:
  if (buffer[hdr_ext] > ELY_ALL_ERRORS) {
    7822:	08 5a       	add	r10,	r8	;

00007824 <.LVL257>:
    7824:	6c 48       	mov.b	@r8,	r12	;

00007826 <.LVL258>:
    7826:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f

0000782a <.LVL259>:
    782a:	4d 9c       	cmp.b	r12,	r13	;
    782c:	18 2c       	jc	$+50     	;abs 0x785e

0000782e <.Loc.1301.2>:
    if (hdr.reply) {
    782e:	09 93       	cmp	#0,	r9	;r3 As==00
    7830:	0c 24       	jz	$+26     	;abs 0x784a

00007832 <.Loc.1303.2>:
      gen_failure(buffer, hdr.crc);
    7832:	4d 47       	mov.b	r7,	r13	;
    7834:	0c 4a       	mov	r10,	r12	;
    7836:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000783a <.L252>:
    elyCmdSendReply(buffer);
    783a:	0c 4a       	mov	r10,	r12	;
    783c:	b0 12 52 74 	call	#29778		;#0x7452

00007840 <.L245>:
}
    7840:	21 53       	incd	r1		;
    7842:	37 17       	popm	#4,	r10	;16-bit words
    7844:	30 41       	ret			

00007846 <.L251>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7846:	68 42       	mov.b	#4,	r8	;r2 As==10
    7848:	ec 3f       	jmp	$-38     	;abs 0x7822

0000784a <.L248>:
      elyErrorSignal(ErrCmdFailure);
    784a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    784e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007852 <.L250>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7852:	0c 4a       	mov	r10,	r12	;
    7854:	b0 12 32 ab 	call	#-21710	;#0xab32

00007858 <.LVL265>:
    7858:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000785c <.LVL266>:
    785c:	f1 3f       	jmp	$-28     	;abs 0x7840

0000785e <.L247>:
  bank0w[RegErrRptLvl] = buffer[hdr_ext];
    785e:	1d 42 bc bd 	mov	&0xbdbc,r13	;0xbdbc
    7862:	cd 4c 4c 00 	mov.b	r12,	76(r13)	; 0x004c

00007866 <.Loc.1316.2>:
  chSysLock();
    7866:	b0 12 0a 6e 	call	#28170		;#0x6e0a

0000786a <.LVL267>:
    786a:	b0 12 5a 44 	call	#17498		;#0x445a

0000786e <.LVL268>:
  elyErrorSetRptLvlS(buffer[hdr_ext]);
    786e:	6c 48       	mov.b	@r8,	r12	;
    7870:	b0 12 6e ac 	call	#-21394	;#0xac6e

00007874 <.LVL269>:
  chSysUnlock();
    7874:	b0 12 78 44 	call	#17528		;#0x4478

00007878 <.LVL270>:
    7878:	b0 12 10 6e 	call	#28176		;#0x6e10

0000787c <.LVL271>:
  if (hdr.reply) {
    787c:	09 93       	cmp	#0,	r9	;r3 As==00
    787e:	e9 27       	jz	$-44     	;abs 0x7852

00007880 <.Loc.1322.2>:
    gen_success(buffer, hdr.crc);
    7880:	4d 47       	mov.b	r7,	r13	;
    7882:	0c 4a       	mov	r10,	r12	;
    7884:	b0 12 28 6e 	call	#28200		;#0x6e28

00007888 <.LVL272>:
    7888:	d8 3f       	jmp	$-78     	;abs 0x783a

0000788a <get_err>:
    788a:	0a 15       	pushm	#1,	r10	;16-bit words

0000788c <.LCFI30>:
static void get_err(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    788c:	21 83       	decd	r1		;

0000788e <.LCFI31>:
    788e:	0a 4c       	mov	r12,	r10	;

00007890 <L0>:
    7890:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7894:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7898:	01 00 

0000789a <.Loc.1276.2>:
  if (hdr.reply) {
    789a:	6e 41       	mov.b	@r1,	r14	;
    789c:	2e b3       	bit	#2,	r14	;r3 As==10
    789e:	20 24       	jz	$+66     	;abs 0x78e0

000078a0 <.Loc.1277.2>:
    buffer[0] = buffer[0] & 0x3F;
    78a0:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    78a4:	00 00 

000078a6 <.Loc.1278.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    78a6:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    78aa:	dc 4d 51 00 	mov.b	81(r13),2(r12)	;0x00051
    78ae:	02 00 

000078b0 <.Loc.1279.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    78b0:	dc 4d 50 00 	mov.b	80(r13),3(r12)	;0x00050
    78b4:	03 00 

000078b6 <.Loc.1280.2>:
    buffer[4] = bank0p[RegErrRptLvl];
    78b6:	dc 4d 4c 00 	mov.b	76(r13),4(r12)	;0x0004c
    78ba:	04 00 

000078bc <.Loc.1281.2>:
    if (hdr.crc) {
    78bc:	1e b3       	bit	#1,	r14	;r3 As==01
    78be:	0d 24       	jz	$+28     	;abs 0x78da

000078c0 <.Loc.1282.2>:
      buffer[1] = 3;
    78c0:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    78c4:	01 00 

000078c6 <.Loc.1283.2>:
      crcGenX25(buffer, 7);
    78c6:	7d 40 07 00 	mov.b	#7,	r13	;
    78ca:	b0 12 26 9b 	call	#-25818	;#0x9b26

000078ce <.L256>:
    elyCmdSendReply(buffer);
    78ce:	0c 4a       	mov	r10,	r12	;
    78d0:	b0 12 52 74 	call	#29778		;#0x7452

000078d4 <.L253>:
}
    78d4:	21 53       	incd	r1		;
    78d6:	0a 17       	popm	#1,	r10	;16-bit words
    78d8:	30 41       	ret			

000078da <.L255>:
      buffer[1] = 1;
    78da:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    78de:	f7 3f       	jmp	$-16     	;abs 0x78ce

000078e0 <.L254>:
    78e0:	b0 12 e4 6f 	call	#28644		;#0x6fe4

000078e4 <.LVL276>:
}
    78e4:	f7 3f       	jmp	$-16     	;abs 0x78d4

000078e6 <get_time>:
    78e6:	0a 15       	pushm	#1,	r10	;16-bit words

000078e8 <.LCFI32>:
static void get_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    78e8:	21 83       	decd	r1		;

000078ea <L0>:
    78ea:	0a 4c       	mov	r12,	r10	;

000078ec <.Loc.1251.2>:
    78ec:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    78f0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    78f4:	01 00 

000078f6 <.Loc.1253.2>:
  if (hdr.reply) {
    78f6:	6f 41       	mov.b	@r1,	r15	;
    78f8:	2f b3       	bit	#2,	r15	;r3 As==10
    78fa:	28 24       	jz	$+82     	;abs 0x794c

000078fc <.Loc.1254.2>:
    buffer[0] = buffer[0] & 0x3F;
    78fc:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    7900:	00 00 

00007902 <.Loc.1255.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7902:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

00007906 <.LVL278>:
    7906:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    790a:	02 00 

0000790c <.Loc.1256.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    790c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7910:	03 00 

00007912 <.Loc.1257.2>:
    buffer[1] += 2;
    7912:	ea 53 01 00 	incd.b	1(r10)		;

00007916 <.LVL279>:
    7916:	0d 4c       	mov	r12,	r13	;
    7918:	3d 50 76 00 	add	#118,	r13	;#0x0076
    791c:	0e 4a       	mov	r10,	r14	;
    791e:	2e 52       	add	#4,	r14	;r2 As==10
    7920:	3c 50 72 00 	add	#114,	r12	;#0x0072

00007924 <.L260>:
      buffer[i + 4] = bank0p[RegMissionTimeMsb - i];
    7924:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

00007928 <.LVL281>:
    7928:	3d 53       	add	#-1,	r13	;r3 As==11
    792a:	1e 53       	inc	r14		;

0000792c <.LVL282>:
    for (int i = 0; i < 4; i++) {
    792c:	0d 9c       	cmp	r12,	r13	;
    792e:	fa 23       	jnz	$-10     	;abs 0x7924

00007930 <.LBE52>:
    if (hdr.crc) {
    7930:	1f b3       	bit	#1,	r15	;r3 As==01
    7932:	06 24       	jz	$+14     	;abs 0x7940

00007934 <.Loc.1263.2>:
      crcGenX25(buffer, buffer[1]+4);
    7934:	5d 4a 01 00 	mov.b	1(r10),	r13	;
    7938:	2d 52       	add	#4,	r13	;r2 As==10
    793a:	0c 4a       	mov	r10,	r12	;
    793c:	b0 12 26 9b 	call	#-25818	;#0x9b26

00007940 <.L261>:
    elyCmdSendReply(buffer);
    7940:	0c 4a       	mov	r10,	r12	;
    7942:	b0 12 52 74 	call	#29778		;#0x7452

00007946 <.L258>:
}
    7946:	21 53       	incd	r1		;
    7948:	0a 17       	popm	#1,	r10	;16-bit words
    794a:	30 41       	ret			

0000794c <.L259>:
    elyNLFreeBuffer(elyNLPack(buffer));
    794c:	b0 12 32 ab 	call	#-21710	;#0xab32

00007950 <.LVL285>:
    7950:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007954 <.LVL286>:
}
    7954:	f8 3f       	jmp	$-14     	;abs 0x7946

00007956 <set_time>:
    7956:	0a 15       	pushm	#1,	r10	;16-bit words

00007958 <L0>:
static void set_time(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7958:	21 83       	decd	r1		;

0000795a <.LCFI35>:
    795a:	0a 4c       	mov	r12,	r10	;

0000795c <.Loc.1225.2>:
    795c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    7960:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    7964:	01 00 

00007966 <.Loc.1226.2>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7966:	6f 41       	mov.b	@r1,	r15	;
    7968:	4d 4f       	mov.b	r15,	r13	;
    796a:	6d f3       	and.b	#2,	r13	;r3 As==10
    796c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    7970:	0d 93       	cmp	#0,	r13	;r3 As==00
    7972:	2f 20       	jnz	$+96     	;abs 0x79d2
    7974:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007976 <.L268>:
  bank0w[RegMissionTimeMsb] = buffer[hdr_ext];
    7976:	1e 42 bc bd 	mov	&0xbdbc,r14	;0xbdbc
    797a:	0c 5a       	add	r10,	r12	;

0000797c <.LVL289>:
    797c:	ee 4c 76 00 	mov.b	@r12,	118(r14); 0x0076

00007980 <.Loc.1230.2>:
  bank0w[RegMissionTimeHmb] = buffer[hdr_ext+1];
    7980:	de 4c 01 00 	mov.b	1(r12),	117(r14); 0x0075
    7984:	75 00 

00007986 <.Loc.1231.2>:
  bank0w[RegMissionTimeLmb] = buffer[hdr_ext+2];
    7986:	de 4c 02 00 	mov.b	2(r12),	116(r14); 0x0074
    798a:	74 00 

0000798c <.Loc.1232.2>:
  bank0w[RegMissionTimeLsb] = buffer[hdr_ext+3];
    798c:	de 4c 03 00 	mov.b	3(r12),	115(r14); 0x0073
    7990:	73 00 

00007992 <.Loc.1234.2>:
  if (hdr.reply) {
    7992:	0d 93       	cmp	#0,	r13	;r3 As==00
    7994:	20 24       	jz	$+66     	;abs 0x79d6

00007996 <.Loc.1235.2>:
    buffer[0] = buffer[0] & 0x3F;
    7996:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    799a:	00 00 

0000799c <.Loc.1236.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    799c:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    79a0:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    79a4:	02 00 

000079a6 <.Loc.1237.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    79a6:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    79aa:	03 00 

000079ac <.Loc.1238.2>:
    buffer[1] -= 2;
    79ac:	5c 4a 01 00 	mov.b	1(r10),	r12	;
    79b0:	7c 50 fe ff 	add.b	#-2,	r12	;#0xfffe
    79b4:	4d 4c       	mov.b	r12,	r13	;
    79b6:	ca 4c 01 00 	mov.b	r12,	1(r10)	;

000079ba <.Loc.1239.2>:
    if (hdr.crc) {
    79ba:	1f b3       	bit	#1,	r15	;r3 As==01
    79bc:	04 24       	jz	$+10     	;abs 0x79c6

000079be <.Loc.1240.2>:
      crcGenX25(buffer, buffer[1]+4);
    79be:	2d 52       	add	#4,	r13	;r2 As==10
    79c0:	0c 4a       	mov	r10,	r12	;
    79c2:	b0 12 26 9b 	call	#-25818	;#0x9b26

000079c6 <.L270>:
    elyCmdSendReply(buffer);
    79c6:	0c 4a       	mov	r10,	r12	;
    79c8:	b0 12 52 74 	call	#29778		;#0x7452

000079cc <.L267>:
}
    79cc:	21 53       	incd	r1		;
    79ce:	0a 17       	popm	#1,	r10	;16-bit words
    79d0:	30 41       	ret			

000079d2 <.L272>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    79d2:	6c 42       	mov.b	#4,	r12	;r2 As==10
    79d4:	d0 3f       	jmp	$-94     	;abs 0x7976

000079d6 <.L269>:
    elyNLFreeBuffer(elyNLPack(buffer));
    79d6:	0c 4a       	mov	r10,	r12	;
    79d8:	b0 12 32 ab 	call	#-21710	;#0xab32

000079dc <.LVL292>:
    79dc:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

000079e0 <.LVL293>:
}
    79e0:	f5 3f       	jmp	$-20     	;abs 0x79cc

000079e2 <reset_event>:
    79e2:	1a 15       	pushm	#2,	r10	;16-bit words

000079e4 <.LCFI36>:
static void reset_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    79e4:	21 83       	decd	r1		;

000079e6 <L0>:
    79e6:	0a 4c       	mov	r12,	r10	;
    79e8:	69 4d       	mov.b	@r13,	r9	;
    79ea:	59 f3       	and.b	#1,	r9	;r3 As==01

000079ec <.Loc.1210.2>:
    79ec:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

000079f0 <.Loc.1212.2>:
  elyEventReset();
    79f0:	b0 12 06 ad 	call	#-21242	;#0xad06

000079f4 <.LVL297>:
  if (hdr.reply) {
    79f4:	e1 b3 00 00 	bit.b	#2,	0(r1)	;r3 As==10
    79f8:	0a 24       	jz	$+22     	;abs 0x7a0e

000079fa <.Loc.1216.2>:
    gen_success(buffer, hdr.crc);
    79fa:	4d 49       	mov.b	r9,	r13	;
    79fc:	0c 4a       	mov	r10,	r12	;
    79fe:	b0 12 28 6e 	call	#28200		;#0x6e28

00007a02 <.LVL298>:
    elyCmdSendReply(buffer);
    7a02:	0c 4a       	mov	r10,	r12	;
    7a04:	b0 12 52 74 	call	#29778		;#0x7452

00007a08 <.L276>:
}
    7a08:	21 53       	incd	r1		;
    7a0a:	19 17       	popm	#2,	r10	;16-bit words
    7a0c:	30 41       	ret			

00007a0e <.L277>:
    7a0e:	0c 4a       	mov	r10,	r12	;
    7a10:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00007a14 <.LVL300>:
    7a14:	f9 3f       	jmp	$-12     	;abs 0x7a08

00007a16 <unlog_event>:
    7a16:	5a 15       	pushm	#6,	r10	;16-bit words

00007a18 <L0>:
static void unlog_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7a18:	21 83       	decd	r1		;

00007a1a <.LCFI39>:
    7a1a:	08 4c       	mov	r12,	r8	;

00007a1c <.LVL302>:
    7a1c:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00007a20 <.LVL303>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7a20:	67 4d       	mov.b	@r13,	r7	;
    7a22:	57 f3       	and.b	#1,	r7	;r3 As==01
    7a24:	6c 4d       	mov.b	@r13,	r12	;

00007a26 <.LVL304>:
    7a26:	1c b3       	bit	#1,	r12	;r3 As==01
    7a28:	19 20       	jnz	$+52     	;abs 0x7a5c
    7a2a:	4d 43       	clr.b	r13		;

00007a2c <.L280>:
    7a2c:	6c f3       	and.b	#2,	r12	;r3 As==10

00007a2e <.LVL306>:
    7a2e:	46 4c       	mov.b	r12,	r6	;
    7a30:	4a 8c       	sub.b	r12,	r10	;

00007a32 <.LVL307>:
    7a32:	4a 8d       	sub.b	r13,	r10	;
    7a34:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00007a38 <.LVL308>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7a38:	06 93       	cmp	#0,	r6	;r3 As==00
    7a3a:	12 20       	jnz	$+38     	;abs 0x7a60

00007a3c <.Loc.1175.2>:
    7a3c:	69 43       	mov.b	#2,	r9	;r3 As==10

00007a3e <.L281>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7a3e:	0c 49       	mov	r9,	r12	;
    7a40:	0a 59       	add	r9,	r10	;

00007a42 <.L282>:
    7a42:	0c 9a       	cmp	r10,	r12	;
    7a44:	0f 38       	jl	$+32     	;abs 0x7a64

00007a46 <.LBB54>:
    elyEventUnlog(buffer[i]);
    7a46:	35 40 e8 ac 	mov	#-21272,r5	;#0xace8

00007a4a <.L287>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7a4a:	09 9a       	cmp	r10,	r9	;
    7a4c:	29 38       	jl	$+84     	;abs 0x7aa0

00007a4e <.LBE54>:
  if (hdr.reply) {
    7a4e:	06 93       	cmp	#0,	r6	;r3 As==00
    7a50:	1f 24       	jz	$+64     	;abs 0x7a90

00007a52 <.Loc.1200.2>:
    gen_success(buffer, hdr.crc);
    7a52:	4d 47       	mov.b	r7,	r13	;
    7a54:	0c 48       	mov	r8,	r12	;
    7a56:	b0 12 28 6e 	call	#28200		;#0x6e28

00007a5a <.LVL312>:
    7a5a:	10 3c       	jmp	$+34     	;abs 0x7a7c

00007a5c <.L290>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7a5c:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007a5e <.LVL314>:
    7a5e:	e6 3f       	jmp	$-50     	;abs 0x7a2c

00007a60 <.L291>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7a60:	69 42       	mov.b	#4,	r9	;r2 As==10
    7a62:	ed 3f       	jmp	$-36     	;abs 0x7a3e

00007a64 <.L286>:
    if (buffer[i] < 0xC0) {
    7a64:	0d 48       	mov	r8,	r13	;
    7a66:	0d 5c       	add	r12,	r13	;
    7a68:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    7a6c:	6e 9d       	cmp.b	@r13,	r14	;
    7a6e:	16 28       	jnc	$+46     	;abs 0x7a9c

00007a70 <.Loc.1180.2>:
      if (hdr.reply) {
    7a70:	06 93       	cmp	#0,	r6	;r3 As==00
    7a72:	0a 24       	jz	$+22     	;abs 0x7a88

00007a74 <.Loc.1182.2>:
        gen_failure(buffer, hdr.crc);
    7a74:	4d 47       	mov.b	r7,	r13	;
    7a76:	0c 48       	mov	r8,	r12	;

00007a78 <.LVL317>:
    7a78:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007a7c <.L292>:
    elyCmdSendReply(buffer);
    7a7c:	0c 48       	mov	r8,	r12	;
    7a7e:	b0 12 52 74 	call	#29778		;#0x7452

00007a82 <.L279>:
}
    7a82:	21 53       	incd	r1		;
    7a84:	55 17       	popm	#6,	r10	;16-bit words
    7a86:	30 41       	ret			

00007a88 <.L284>:
        elyErrorSignal(ErrCmdFailure);
    7a88:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007a8c <.LVL321>:
    7a8c:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007a90 <.L289>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7a90:	0c 48       	mov	r8,	r12	;
    7a92:	b0 12 32 ab 	call	#-21710	;#0xab32

00007a96 <.LVL323>:
    7a96:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007a9a <.LVL324>:
    7a9a:	f3 3f       	jmp	$-24     	;abs 0x7a82

00007a9c <.L283>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7a9c:	1c 53       	inc	r12		;
    7a9e:	d1 3f       	jmp	$-92     	;abs 0x7a42

00007aa0 <.L288>:
    elyEventUnlog(buffer[i]);
    7aa0:	0c 48       	mov	r8,	r12	;
    7aa2:	0c 59       	add	r9,	r12	;
    7aa4:	6c 4c       	mov.b	@r12,	r12	;
    7aa6:	85 12       	call	r5		;

00007aa8 <.LVL328>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7aa8:	19 53       	inc	r9		;
    7aaa:	cf 3f       	jmp	$-96     	;abs 0x7a4a

00007aac <log_event>:
    7aac:	5a 15       	pushm	#6,	r10	;16-bit words

00007aae <.LCFI40>:
static void log_event(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7aae:	21 83       	decd	r1		;

00007ab0 <.LCFI41>:
    7ab0:	08 4c       	mov	r12,	r8	;

00007ab2 <.LVL331>:
    7ab2:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00007ab6 <.LVL332>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7ab6:	66 4d       	mov.b	@r13,	r6	;

00007ab8 <L0>:
    7ab8:	56 f3       	and.b	#1,	r6	;r3 As==01
    7aba:	6c 4d       	mov.b	@r13,	r12	;

00007abc <.LVL333>:
    7abc:	1c b3       	bit	#1,	r12	;r3 As==01
    7abe:	19 20       	jnz	$+52     	;abs 0x7af2
    7ac0:	4d 43       	clr.b	r13		;

00007ac2 <.L294>:
    7ac2:	6c f3       	and.b	#2,	r12	;r3 As==10

00007ac4 <.LVL335>:
    7ac4:	47 4c       	mov.b	r12,	r7	;
    7ac6:	4a 8c       	sub.b	r12,	r10	;

00007ac8 <.LVL336>:
    7ac8:	4a 8d       	sub.b	r13,	r10	;
    7aca:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00007ace <.LVL337>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7ace:	07 93       	cmp	#0,	r7	;r3 As==00
    7ad0:	12 20       	jnz	$+38     	;abs 0x7af6

00007ad2 <.Loc.1136.2>:
    7ad2:	69 43       	mov.b	#2,	r9	;r3 As==10

00007ad4 <.L295>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7ad4:	0d 49       	mov	r9,	r13	;
    7ad6:	0a 59       	add	r9,	r10	;

00007ad8 <.L296>:
    7ad8:	0d 9a       	cmp	r10,	r13	;
    7ada:	0f 38       	jl	$+32     	;abs 0x7afa

00007adc <.LBB60>:
    elyEventLog(buffer[i]);
    7adc:	35 40 ca ac 	mov	#-21302,r5	;#0xacca

00007ae0 <.L302>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7ae0:	09 9a       	cmp	r10,	r9	;
    7ae2:	37 38       	jl	$+112    	;abs 0x7b52

00007ae4 <.LBE60>:
  if (hdr.reply) {
    7ae4:	07 93       	cmp	#0,	r7	;r3 As==00
    7ae6:	2d 24       	jz	$+92     	;abs 0x7b42

00007ae8 <.Loc.1163.2>:
    gen_success(buffer, hdr.crc);
    7ae8:	4d 46       	mov.b	r6,	r13	;
    7aea:	0c 48       	mov	r8,	r12	;
    7aec:	b0 12 28 6e 	call	#28200		;#0x6e28

00007af0 <.LVL341>:
    7af0:	1e 3c       	jmp	$+62     	;abs 0x7b2e

00007af2 <.L305>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7af2:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007af4 <.LVL343>:
    7af4:	e6 3f       	jmp	$-50     	;abs 0x7ac2

00007af6 <.L306>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7af6:	69 42       	mov.b	#4,	r9	;r2 As==10
    7af8:	ed 3f       	jmp	$-36     	;abs 0x7ad4

00007afa <.L301>:
    if ((buffer[i] < 0xC0) || 
    7afa:	0c 48       	mov	r8,	r12	;
    7afc:	0c 5d       	add	r13,	r12	;
    7afe:	6c 4c       	mov.b	@r12,	r12	;
    7b00:	4e 4c       	mov.b	r12,	r14	;
    7b02:	7e 50 40 00 	add.b	#64,	r14	;#0x0040
    7b06:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    7b0a:	4f 9e       	cmp.b	r14,	r15	;
    7b0c:	0a 28       	jnc	$+22     	;abs 0x7b22

00007b0e <.Loc.1140.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7b0e:	7e 50 ed ff 	add.b	#-19,	r14	;#0xffed

00007b12 <.Loc.1139.2>:
    if ((buffer[i] < 0xC0) || 
    7b12:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    7b16:	4f 9e       	cmp.b	r14,	r15	;
    7b18:	04 2c       	jc	$+10     	;abs 0x7b22

00007b1a <.Loc.1141.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7b1a:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

00007b1e <.Loc.1140.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7b1e:	4f 9c       	cmp.b	r12,	r15	;
    7b20:	16 28       	jnc	$+46     	;abs 0x7b4e

00007b22 <.L297>:
      if (hdr.reply) {
    7b22:	07 93       	cmp	#0,	r7	;r3 As==00
    7b24:	0a 24       	jz	$+22     	;abs 0x7b3a

00007b26 <.Loc.1145.2>:
        gen_failure(buffer, hdr.crc);
    7b26:	4d 46       	mov.b	r6,	r13	;

00007b28 <.LVL346>:
    7b28:	0c 48       	mov	r8,	r12	;
    7b2a:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007b2e <.L307>:
    elyCmdSendReply(buffer);
    7b2e:	0c 48       	mov	r8,	r12	;
    7b30:	b0 12 52 74 	call	#29778		;#0x7452

00007b34 <.L293>:
}
    7b34:	21 53       	incd	r1		;
    7b36:	55 17       	popm	#6,	r10	;16-bit words
    7b38:	30 41       	ret			

00007b3a <.L299>:
        elyErrorSignal(ErrCmdFailure);
    7b3a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7b3e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007b42 <.L304>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7b42:	0c 48       	mov	r8,	r12	;
    7b44:	b0 12 32 ab 	call	#-21710	;#0xab32

00007b48 <.LVL351>:
    7b48:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007b4c <.LVL352>:
    7b4c:	f3 3f       	jmp	$-24     	;abs 0x7b34

00007b4e <.L298>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7b4e:	1d 53       	inc	r13		;
    7b50:	c3 3f       	jmp	$-120    	;abs 0x7ad8

00007b52 <.L303>:
    elyEventLog(buffer[i]);
    7b52:	0c 48       	mov	r8,	r12	;
    7b54:	0c 59       	add	r9,	r12	;
    7b56:	6c 4c       	mov.b	@r12,	r12	;
    7b58:	85 12       	call	r5		;

00007b5a <.LVL356>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7b5a:	19 53       	inc	r9		;
    7b5c:	c1 3f       	jmp	$-124    	;abs 0x7ae0

00007b5e <event_unsub>:
    7b5e:	5a 15       	pushm	#6,	r10	;16-bit words

00007b60 <.LCFI42>:
static void event_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7b60:	21 83       	decd	r1		;

00007b62 <.LCFI43>:
    7b62:	08 4c       	mov	r12,	r8	;

00007b64 <.LVL359>:
    7b64:	5a 4d 01 00 	mov.b	1(r13),	r10	;

00007b68 <.LVL360>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7b68:	67 4d       	mov.b	@r13,	r7	;

00007b6a <L0>:
    7b6a:	57 f3       	and.b	#1,	r7	;r3 As==01
    7b6c:	6c 4d       	mov.b	@r13,	r12	;

00007b6e <.LVL361>:
    7b6e:	1c b3       	bit	#1,	r12	;r3 As==01
    7b70:	19 20       	jnz	$+52     	;abs 0x7ba4
    7b72:	4d 43       	clr.b	r13		;

00007b74 <.L309>:
    7b74:	6c f3       	and.b	#2,	r12	;r3 As==10

00007b76 <.LVL363>:
    7b76:	46 4c       	mov.b	r12,	r6	;
    7b78:	4a 8c       	sub.b	r12,	r10	;

00007b7a <.LVL364>:
    7b7a:	4a 8d       	sub.b	r13,	r10	;
    7b7c:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00007b80 <.LVL365>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7b80:	06 93       	cmp	#0,	r6	;r3 As==00
    7b82:	12 20       	jnz	$+38     	;abs 0x7ba8

00007b84 <.Loc.1100.2>:
    7b84:	69 43       	mov.b	#2,	r9	;r3 As==10

00007b86 <.L310>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7b86:	0c 49       	mov	r9,	r12	;
    7b88:	0a 59       	add	r9,	r10	;

00007b8a <.L311>:
    7b8a:	0c 9a       	cmp	r10,	r12	;
    7b8c:	0f 38       	jl	$+32     	;abs 0x7bac

00007b8e <.LBB66>:
    elyEventUnsubscribe(buffer[i]);
    7b8e:	35 40 ac ac 	mov	#-21332,r5	;#0xacac

00007b92 <.L316>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7b92:	09 9a       	cmp	r10,	r9	;
    7b94:	29 38       	jl	$+84     	;abs 0x7be8

00007b96 <.LBE66>:
  if (hdr.reply) {
    7b96:	06 93       	cmp	#0,	r6	;r3 As==00
    7b98:	1f 24       	jz	$+64     	;abs 0x7bd8

00007b9a <.Loc.1124.2>:
    gen_success(buffer, hdr.crc);
    7b9a:	4d 47       	mov.b	r7,	r13	;
    7b9c:	0c 48       	mov	r8,	r12	;
    7b9e:	b0 12 28 6e 	call	#28200		;#0x6e28

00007ba2 <.LVL369>:
    7ba2:	10 3c       	jmp	$+34     	;abs 0x7bc4

00007ba4 <.L319>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7ba4:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007ba6 <.LVL371>:
    7ba6:	e6 3f       	jmp	$-50     	;abs 0x7b74

00007ba8 <.L320>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7ba8:	69 42       	mov.b	#4,	r9	;r2 As==10
    7baa:	ed 3f       	jmp	$-36     	;abs 0x7b86

00007bac <.L315>:
    if (buffer[i] < 0xC0) {
    7bac:	0d 48       	mov	r8,	r13	;
    7bae:	0d 5c       	add	r12,	r13	;
    7bb0:	7e 40 bf ff 	mov.b	#-65,	r14	;#0xffbf
    7bb4:	6e 9d       	cmp.b	@r13,	r14	;
    7bb6:	16 28       	jnc	$+46     	;abs 0x7be4

00007bb8 <.Loc.1104.2>:
      if (hdr.reply) {
    7bb8:	06 93       	cmp	#0,	r6	;r3 As==00
    7bba:	0a 24       	jz	$+22     	;abs 0x7bd0

00007bbc <.Loc.1106.2>:
        gen_failure(buffer, hdr.crc);
    7bbc:	4d 47       	mov.b	r7,	r13	;
    7bbe:	0c 48       	mov	r8,	r12	;

00007bc0 <.LVL374>:
    7bc0:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007bc4 <.L321>:
    elyCmdSendReply(buffer);
    7bc4:	0c 48       	mov	r8,	r12	;
    7bc6:	b0 12 52 74 	call	#29778		;#0x7452

00007bca <.L308>:
}
    7bca:	21 53       	incd	r1		;
    7bcc:	55 17       	popm	#6,	r10	;16-bit words
    7bce:	30 41       	ret			

00007bd0 <.L313>:
        elyErrorSignal(ErrCmdFailure);
    7bd0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007bd4 <.LVL378>:
    7bd4:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007bd8 <.L318>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7bd8:	0c 48       	mov	r8,	r12	;
    7bda:	b0 12 32 ab 	call	#-21710	;#0xab32

00007bde <.LVL380>:
    7bde:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007be2 <.LVL381>:
    7be2:	f3 3f       	jmp	$-24     	;abs 0x7bca

00007be4 <.L312>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7be4:	1c 53       	inc	r12		;
    7be6:	d1 3f       	jmp	$-92     	;abs 0x7b8a

00007be8 <.L317>:
    elyEventUnsubscribe(buffer[i]);
    7be8:	0c 48       	mov	r8,	r12	;
    7bea:	0c 59       	add	r9,	r12	;
    7bec:	6c 4c       	mov.b	@r12,	r12	;
    7bee:	85 12       	call	r5		;

00007bf0 <.LVL385>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7bf0:	19 53       	inc	r9		;
    7bf2:	cf 3f       	jmp	$-96     	;abs 0x7b92

00007bf4 <event_sub>:
    7bf4:	6a 15       	pushm	#7,	r10	;16-bit words

00007bf6 <.LCFI44>:
static void event_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7bf6:	21 83       	decd	r1		;

00007bf8 <.LCFI45>:
    7bf8:	09 4c       	mov	r12,	r9	;
    7bfa:	68 4d       	mov.b	@r13,	r8	;
    7bfc:	58 f3       	and.b	#1,	r8	;r3 As==01

00007bfe <.LVL388>:
    7bfe:	5a 4d       	mov.b,		r10	;Warning: disassembly unreliable - not enough bytes available

00007c00 <L0>:
    7c00:	01 00       	mova	@r0,	r1	;

00007c02 <.LVL389>:
    7c02:	c1 4a 01 00 	mov.b	r10,	1(r1)	;

00007c06 <.Loc.1051.2>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7c06:	6c 4d       	mov.b	@r13,	r12	;

00007c08 <.LVL391>:
    7c08:	5c c3       	bic.b	#1,	r12	;r3 As==01
    7c0a:	4c d8       	bis.b	r8,	r12	;
    7c0c:	c1 4c 00 00 	mov.b	r12,	0(r1)	;
    7c10:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7c14:	1c b3       	bit	#1,	r12	;r3 As==01
    7c16:	22 24       	jz	$+70     	;abs 0x7c5c
    7c18:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007c1a <.L323>:
    7c1a:	6c f3       	and.b	#2,	r12	;r3 As==10
    7c1c:	46 4c       	mov.b	r12,	r6	;
    7c1e:	4a 8c       	sub.b	r12,	r10	;

00007c20 <.LVL393>:
    7c20:	4a 8d       	sub.b	r13,	r10	;
    7c22:	3a f0 ff 00 	and	#255,	r10	;#0x00ff

00007c26 <.LVL394>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c26:	06 93       	cmp	#0,	r6	;r3 As==00
    7c28:	1b 24       	jz	$+56     	;abs 0x7c60

00007c2a <.Loc.1052.2>:
    7c2a:	67 42       	mov.b	#4,	r7	;r2 As==10

00007c2c <.L324>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7c2c:	0d 47       	mov	r7,	r13	;
    7c2e:	0a 57       	add	r7,	r10	;

00007c30 <.L325>:
    7c30:	0d 9a       	cmp	r10,	r13	;
    7c32:	18 38       	jl	$+50     	;abs 0x7c64

00007c34 <.LBE71>:
  if (hdr.reply) {
    7c34:	06 93       	cmp	#0,	r6	;r3 As==00
    7c36:	42 24       	jz	$+134    	;abs 0x7cbc

00007c38 <.Loc.1075.2>:
    addr = ((buffer[2] << 8) | (buffer[3]));
    7c38:	55 49 02 00 	mov.b	2(r9),	r5	;
    7c3c:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    7c40:	5c 49 03 00 	mov.b	3(r9),	r12	;

00007c44 <.L338>:
    7c44:	05 dc       	bis	r12,	r5	;

00007c46 <.LBB72>:
      elyEventSubscribe(buffer[i], addr);
    7c46:	34 40 8e ac 	mov	#-21362,r4	;#0xac8e

00007c4a <.L333>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7c4a:	07 9a       	cmp	r10,	r7	;
    7c4c:	40 38       	jl	$+130    	;abs 0x7cce

00007c4e <.LBE72>:
  if (hdr.reply) {
    7c4e:	06 93       	cmp	#0,	r6	;r3 As==00
    7c50:	2d 24       	jz	$+92     	;abs 0x7cac

00007c52 <.Loc.1088.2>:
    gen_success(buffer, hdr.crc);
    7c52:	4d 48       	mov.b	r8,	r13	;
    7c54:	0c 49       	mov	r9,	r12	;
    7c56:	b0 12 28 6e 	call	#28200		;#0x6e28

00007c5a <.LVL399>:
    7c5a:	1e 3c       	jmp	$+62     	;abs 0x7c98

00007c5c <.L336>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7c5c:	4d 43       	clr.b	r13		;

00007c5e <.LVL401>:
    7c5e:	dd 3f       	jmp	$-68     	;abs 0x7c1a

00007c60 <.L337>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7c60:	67 43       	mov.b	#2,	r7	;r3 As==10
    7c62:	e4 3f       	jmp	$-54     	;abs 0x7c2c

00007c64 <.L330>:
    if ((buffer[i] < 0xC0) || 
    7c64:	0c 49       	mov	r9,	r12	;
    7c66:	0c 5d       	add	r13,	r12	;
    7c68:	6c 4c       	mov.b	@r12,	r12	;
    7c6a:	4e 4c       	mov.b	r12,	r14	;
    7c6c:	7e 50 40 00 	add.b	#64,	r14	;#0x0040
    7c70:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
    7c74:	4f 9e       	cmp.b	r14,	r15	;
    7c76:	0a 28       	jnc	$+22     	;abs 0x7c8c

00007c78 <.Loc.1056.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7c78:	7e 50 ed ff 	add.b	#-19,	r14	;#0xffed

00007c7c <.Loc.1055.2>:
    if ((buffer[i] < 0xC0) || 
    7c7c:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    7c80:	4f 9e       	cmp.b	r14,	r15	;
    7c82:	04 2c       	jc	$+10     	;abs 0x7c8c

00007c84 <.Loc.1057.2>:
        (buffer[i] >= EvtNLMAX && buffer[i] < 0xF0) ||
    7c84:	7c 50 1d 00 	add.b	#29,	r12	;#0x001d

00007c88 <.Loc.1056.2>:
        (buffer[i] >= EvtCoreMAX && buffer[i] < 0xE0) ||
    7c88:	4f 9c       	cmp.b	r12,	r15	;
    7c8a:	16 28       	jnc	$+46     	;abs 0x7cb8

00007c8c <.L326>:
      if (hdr.reply) {
    7c8c:	06 93       	cmp	#0,	r6	;r3 As==00
    7c8e:	0a 24       	jz	$+22     	;abs 0x7ca4

00007c90 <.Loc.1061.2>:
        gen_failure(buffer, hdr.crc);
    7c90:	4d 48       	mov.b	r8,	r13	;

00007c92 <.LVL404>:
    7c92:	0c 49       	mov	r9,	r12	;
    7c94:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007c98 <.L339>:
    elyCmdSendReply(buffer);
    7c98:	0c 49       	mov	r9,	r12	;
    7c9a:	b0 12 52 74 	call	#29778		;#0x7452

00007c9e <.L322>:
}
    7c9e:	21 53       	incd	r1		;
    7ca0:	64 17       	popm	#7,	r10	;16-bit words
    7ca2:	30 41       	ret			

00007ca4 <.L328>:
        elyErrorSignal(ErrCmdFailure);
    7ca4:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7ca8:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007cac <.L335>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7cac:	0c 49       	mov	r9,	r12	;
    7cae:	b0 12 32 ab 	call	#-21710	;#0xab32

00007cb2 <.LVL409>:
    7cb2:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007cb6 <.LVL410>:
    7cb6:	f3 3f       	jmp	$-24     	;abs 0x7c9e

00007cb8 <.L327>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7cb8:	1d 53       	inc	r13		;
    7cba:	ba 3f       	jmp	$-138    	;abs 0x7c30

00007cbc <.L331>:
    7cbc:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    7cc0:	55 4c 55 00 	mov.b	85(r12),r5	;0x00055
    7cc4:	47 18 05 55 	rpt #8 { rlax.w	r5		;
    7cc8:	5c 4c 54 00 	mov.b	84(r12),r12	;0x00054
    7ccc:	bb 3f       	jmp	$-136    	;abs 0x7c44

00007cce <.L334>:
      elyEventSubscribe(buffer[i], addr);
    7cce:	0c 49       	mov	r9,	r12	;
    7cd0:	0c 57       	add	r7,	r12	;
    7cd2:	0d 45       	mov	r5,	r13	;
    7cd4:	6c 4c       	mov.b	@r12,	r12	;
    7cd6:	84 12       	call	r4		;

00007cd8 <.LVL414>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7cd8:	17 53       	inc	r7		;
    7cda:	b7 3f       	jmp	$-144    	;abs 0x7c4a

00007cdc <reset_chan>:
    7cdc:	1a 15       	pushm	#2,	r10	;16-bit words

00007cde <.LCFI46>:
static void reset_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7cde:	21 83       	decd	r1		;

00007ce0 <.LCFI47>:
    7ce0:	0a 4c       	mov	r12,	r10	;
    7ce2:	69 4d       	mov.b	@r13,	r9	;
    7ce4:	59 f3       	and.b	#1,	r9	;r3 As==01

00007ce6 <.Loc.1035.2>:
    7ce6:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;

00007cea <L0>:
  elyChanReset();
    7cea:	b0 12 54 ae 	call	#-20908	;#0xae54

00007cee <.LVL419>:
  if (hdr.reply) {
    7cee:	e1 b3 00 00 	bit.b	#2,	0(r1)	;r3 As==10
    7cf2:	0a 24       	jz	$+22     	;abs 0x7d08

00007cf4 <.Loc.1041.2>:
    gen_success(buffer, hdr.crc);
    7cf4:	4d 49       	mov.b	r9,	r13	;
    7cf6:	0c 4a       	mov	r10,	r12	;
    7cf8:	b0 12 28 6e 	call	#28200		;#0x6e28

00007cfc <.LVL420>:
    elyCmdSendReply(buffer);
    7cfc:	0c 4a       	mov	r10,	r12	;
    7cfe:	b0 12 52 74 	call	#29778		;#0x7452

00007d02 <.L340>:
}
    7d02:	21 53       	incd	r1		;
    7d04:	19 17       	popm	#2,	r10	;16-bit words
    7d06:	30 41       	ret			

00007d08 <.L341>:
    7d08:	0c 4a       	mov	r10,	r12	;
    7d0a:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00007d0e <.LVL422>:
    7d0e:	f9 3f       	jmp	$-12     	;abs 0x7d02

00007d10 <get_chan>:
    7d10:	2a 15       	pushm	#3,	r10	;16-bit words

00007d12 <L0>:
static void get_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7d12:	21 83       	decd	r1		;

00007d14 <.LCFI49>:
    7d14:	0a 4c       	mov	r12,	r10	;
    7d16:	0e 4d       	mov	r13,	r14	;
    7d18:	6d 4d       	mov.b	@r13,	r13	;
    7d1a:	5d f3       	and.b	#1,	r13	;r3 As==01

00007d1c <.LVL424>:
    7d1c:	d1 4e 01 00 	mov.b	1(r14),	1(r1)	;
    7d20:	01 00 

00007d22 <.Loc.1001.2>:
  if (hdr.reply) {
    7d22:	69 4e       	mov.b	@r14,	r9	;
    7d24:	59 c3       	bic.b	#1,	r9	;r3 As==01
    7d26:	49 dd       	bis.b	r13,	r9	;
    7d28:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    7d2c:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    7d30:	29 b3       	bit	#2,	r9	;r3 As==10
    7d32:	40 24       	jz	$+130    	;abs 0x7db4

00007d34 <.LBB77>:
    if ((buffer[4] < 0x40) || 
    7d34:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00007d38 <.LVL426>:
    7d38:	4e 4c       	mov.b	r12,	r14	;
    7d3a:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    7d3e:	38 40 52 74 	mov	#29778,	r8	;#0x7452
    7d42:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    7d46:	4f 9e       	cmp.b	r14,	r15	;
    7d48:	0c 28       	jnc	$+26     	;abs 0x7d62

00007d4a <.Loc.1003.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    7d4a:	7e 50 ef ff 	add.b	#-17,	r14	;#0xffef

00007d4e <.Loc.1002.2>:
    if ((buffer[4] < 0x40) || 
    7d4e:	7f 40 0e 00 	mov.b	#14,	r15	;#0x000e
    7d52:	4f 9e       	cmp.b	r14,	r15	;
    7d54:	06 2c       	jc	$+14     	;abs 0x7d62

00007d56 <.Loc.1004.2>:
        (buffer[4] >= ChanNLMAX && buffer[4] < 0x70) ||
    7d56:	7c 50 9d ff 	add.b	#-99,	r12	;#0xff9d

00007d5a <.Loc.1003.2>:
        (buffer[4] >= ChanCoreMAX && buffer[4] < 0x60) ||
    7d5a:	7e 40 0c 00 	mov.b	#12,	r14	;#0x000c
    7d5e:	4e 9c       	cmp.b	r12,	r14	;
    7d60:	08 28       	jnc	$+18     	;abs 0x7d72

00007d62 <.L345>:
        gen_failure(buffer, hdr.crc);
    7d62:	0c 4a       	mov	r10,	r12	;
    7d64:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007d68 <.L349>:
    elyCmdSendReply(buffer);
    7d68:	0c 4a       	mov	r10,	r12	;
    7d6a:	88 12       	call	r8		;

00007d6c <.L343>:
}
    7d6c:	21 53       	incd	r1		;
    7d6e:	28 17       	popm	#3,	r10	;16-bit words
    7d70:	30 41       	ret			

00007d72 <.L346>:
    buffer[0] = buffer[0] & 0x3F;
    7d72:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    7d76:	00 00 

00007d78 <.Loc.1013.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    7d78:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    7d7c:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    7d80:	02 00 

00007d82 <.Loc.1014.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    7d82:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    7d86:	03 00 

00007d88 <.Loc.1017.2>:
    size_t n = elyChanGetValue(&buffer[4]);
    7d88:	0c 4a       	mov	r10,	r12	;
    7d8a:	2c 52       	add	#4,	r12	;r2 As==10
    7d8c:	b0 12 4c ae 	call	#-20916	;#0xae4c

00007d90 <.LVL430>:
    if (hdr.crc) {
    7d90:	19 b3       	bit	#1,	r9	;r3 As==01
    7d92:	0c 24       	jz	$+26     	;abs 0x7dac

00007d94 <.Loc.1020.2>:
      buffer[1] = n + 3;
    7d94:	4f 4c       	mov.b	r12,	r15	;
    7d96:	7f 50 03 00 	add.b	#3,	r15	;
    7d9a:	ca 4f 01 00 	mov.b	r15,	1(r10)	;

00007d9e <.Loc.1021.2>:
      crcGenX25(buffer, 7+n);
    7d9e:	0d 4c       	mov	r12,	r13	;
    7da0:	3d 50 07 00 	add	#7,	r13	;
    7da4:	0c 4a       	mov	r10,	r12	;

00007da6 <.LVL431>:
    7da6:	b0 12 26 9b 	call	#-25818	;#0x9b26

00007daa <.LVL432>:
    7daa:	de 3f       	jmp	$-66     	;abs 0x7d68

00007dac <.L348>:
      buffer[1] = n + 1;
    7dac:	5c 53       	inc.b	r12		;

00007dae <.LVL434>:
    7dae:	ca 4c 01 00 	mov.b	r12,	1(r10)	;
    7db2:	da 3f       	jmp	$-74     	;abs 0x7d68

00007db4 <.L344>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7db4:	b0 12 32 ab 	call	#-21710	;#0xab32

00007db8 <.LVL436>:
    7db8:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007dbc <.LVL437>:
    7dbc:	d7 3f       	jmp	$-80     	;abs 0x7d6c

00007dbe <unlog_chan>:
    7dbe:	5a 15       	pushm	#6,	r10	;16-bit words

00007dc0 <.LCFI50>:
static void unlog_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7dc0:	21 83       	decd	r1		;

00007dc2 <.LCFI51>:
    7dc2:	0a 4c       	mov	r12,	r10	;

00007dc4 <L0>:
    7dc4:	5b 4d 01 00 	mov.b	1(r13),	r11	;

00007dc8 <.LVL440>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7dc8:	67 4d       	mov.b	@r13,	r7	;
    7dca:	57 f3       	and.b	#1,	r7	;r3 As==01
    7dcc:	6f 4d       	mov.b	@r13,	r15	;
    7dce:	0e 4f       	mov	r15,	r14	;
    7dd0:	5e f3       	and.b	#1,	r14	;r3 As==01
    7dd2:	0e 93       	cmp	#0,	r14	;r3 As==00
    7dd4:	1c 20       	jnz	$+58     	;abs 0x7e0e
    7dd6:	0d 4e       	mov	r14,	r13	;

00007dd8 <.L351>:
    7dd8:	6f f3       	and.b	#2,	r15	;r3 As==10

00007dda <.LVL442>:
    7dda:	48 4f       	mov.b	r15,	r8	;

00007ddc <.LVL443>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7ddc:	08 93       	cmp	#0,	r8	;r3 As==00
    7dde:	19 20       	jnz	$+52     	;abs 0x7e12

00007de0 <.Loc.967.2>:
    7de0:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007de2 <.L352>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7de2:	09 4c       	mov	r12,	r9	;

00007de4 <.LVL445>:
    7de4:	06 4b       	mov	r11,	r6	;
    7de6:	06 5c       	add	r12,	r6	;
    7de8:	0e 93       	cmp	#0,	r14	;r3 As==00
    7dea:	01 24       	jz	$+4      	;abs 0x7dee
    7dec:	6e 43       	mov.b	#2,	r14	;r3 As==10

00007dee <.L354>:
    7dee:	06 8e       	sub	r14,	r6	;

00007df0 <.L355>:
    7df0:	09 96       	cmp	r6,	r9	;
    7df2:	11 38       	jl	$+36     	;abs 0x7e16

00007df4 <.LBE79>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7df4:	4b 8f       	sub.b	r15,	r11	;

00007df6 <.LVL447>:
  elyChanUnlog(buffer + hdr_ext, payload_len);
    7df6:	4b 8d       	sub.b	r13,	r11	;
    7df8:	4d 4b       	mov.b	r11,	r13	;
    7dfa:	0c 5a       	add	r10,	r12	;

00007dfc <.LVL448>:
    7dfc:	b0 12 02 ae 	call	#-20990	;#0xae02

00007e00 <.LVL449>:
  if (hdr.reply) {
    7e00:	08 93       	cmp	#0,	r8	;r3 As==00
    7e02:	22 24       	jz	$+70     	;abs 0x7e48

00007e04 <.Loc.989.2>:
    gen_success(buffer, hdr.crc);
    7e04:	4d 47       	mov.b	r7,	r13	;
    7e06:	0c 4a       	mov	r10,	r12	;
    7e08:	b0 12 28 6e 	call	#28200		;#0x6e28

00007e0c <.LVL450>:
    7e0c:	13 3c       	jmp	$+40     	;abs 0x7e34

00007e0e <.L361>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7e0e:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007e10 <.LVL452>:
    7e10:	e3 3f       	jmp	$-56     	;abs 0x7dd8

00007e12 <.L362>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7e12:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7e14:	e6 3f       	jmp	$-50     	;abs 0x7de2

00007e16 <.L359>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7e16:	0e 4a       	mov	r10,	r14	;
    7e18:	0e 59       	add	r9,	r14	;
    7e1a:	6e 4e       	mov.b	@r14,	r14	;
    7e1c:	7e 50 c0 ff 	add.b	#-64,	r14	;#0xffc0
    7e20:	75 40 3f 00 	mov.b	#63,	r5	;#0x003f
    7e24:	45 9e       	cmp.b	r14,	r5	;
    7e26:	16 2c       	jc	$+46     	;abs 0x7e54

00007e28 <.Loc.971.2>:
      if (hdr.reply) {
    7e28:	08 93       	cmp	#0,	r8	;r3 As==00
    7e2a:	0a 24       	jz	$+22     	;abs 0x7e40

00007e2c <.Loc.973.2>:
        gen_failure(buffer, hdr.crc);
    7e2c:	4d 47       	mov.b	r7,	r13	;

00007e2e <.LVL455>:
    7e2e:	0c 4a       	mov	r10,	r12	;

00007e30 <.LVL456>:
    7e30:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007e34 <.L363>:
    elyCmdSendReply(buffer);
    7e34:	0c 4a       	mov	r10,	r12	;
    7e36:	b0 12 52 74 	call	#29778		;#0x7452

00007e3a <.L350>:
}
    7e3a:	21 53       	incd	r1		;
    7e3c:	55 17       	popm	#6,	r10	;16-bit words
    7e3e:	30 41       	ret			

00007e40 <.L357>:
        elyErrorSignal(ErrCmdFailure);
    7e40:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00007e44 <.LVL460>:
    7e44:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007e48 <.L360>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7e48:	0c 4a       	mov	r10,	r12	;
    7e4a:	b0 12 32 ab 	call	#-21710	;#0xab32

00007e4e <.LVL462>:
    7e4e:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007e52 <.LVL463>:
    7e52:	f3 3f       	jmp	$-24     	;abs 0x7e3a

00007e54 <.L356>:
  for (int i = hdr_ext; i < hdr.length + hdr_ext - (hdr.crc ? 2 : 0); i++) {
    7e54:	19 53       	inc	r9		;
    7e56:	cc 3f       	jmp	$-102    	;abs 0x7df0

00007e58 <log_chan>:
    7e58:	6a 15       	pushm	#7,	r10	;16-bit words

00007e5a <.LCFI52>:
static void log_chan(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7e5a:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00007e5e <.LCFI53>:
    7e5e:	0a 4c       	mov	r12,	r10	;

00007e60 <.LVL467>:
    7e60:	59 4d       	mov.b,		r9	;Warning: disassembly unreliable - not enough bytes available

00007e62 <L0>:
    7e62:	01 00       	mova	@r0,	r1	;

00007e64 <.LVL468>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7e64:	65 4d       	mov.b	@r13,	r5	;
    7e66:	55 f3       	and.b	#1,	r5	;r3 As==01
    7e68:	6c 4d       	mov.b	@r13,	r12	;

00007e6a <.LVL469>:
    7e6a:	1c b3       	bit	#1,	r12	;r3 As==01
    7e6c:	4c 20       	jnz	$+154    	;abs 0x7f06
    7e6e:	4d 43       	clr.b	r13		;

00007e70 <.L365>:
    7e70:	6c f3       	and.b	#2,	r12	;r3 As==10

00007e72 <.LVL471>:
    7e72:	46 4c       	mov.b	r12,	r6	;
    7e74:	49 8c       	sub.b	r12,	r9	;

00007e76 <.LVL472>:
    7e76:	49 8d       	sub.b	r13,	r9	;
    7e78:	4f 49       	mov.b	r9,	r15	;

00007e7a <.LVL473>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7e7a:	06 93       	cmp	#0,	r6	;r3 As==00
    7e7c:	46 20       	jnz	$+142    	;abs 0x7f0a

00007e7e <.Loc.921.2>:
    7e7e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007e80 <.L366>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7e80:	0d 4c       	mov	r12,	r13	;
    7e82:	2d 52       	add	#4,	r13	;r2 As==10

00007e84 <.LVL475>:
    7e84:	81 4d 06 00 	mov	r13,	6(r1)	;
    7e88:	0f 5c       	add	r12,	r15	;

00007e8a <.L367>:
    7e8a:	0d 9f       	cmp	r15,	r13	;
    7e8c:	40 38       	jl	$+130    	;abs 0x7f0e
    7e8e:	0d 4c       	mov	r12,	r13	;

00007e90 <.LVL476>:
    7e90:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    7e94:	0d 8c       	sub	r12,	r13	;
    7e96:	81 4d 04 00 	mov	r13,	4(r1)	;

00007e9a <.Loc.924.2>:
    7e9a:	67 42       	mov.b	#4,	r7	;r2 As==10
    7e9c:	48 43       	clr.b	r8		;
    7e9e:	04 48       	mov	r8,	r4	;

00007ea0 <.LBB84>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7ea0:	0c 5a       	add	r10,	r12	;
    7ea2:	81 4c 08 00 	mov	r12,	8(r1)	;

00007ea6 <.L373>:
    7ea6:	37 53       	add	#-1,	r7	;r3 As==11

00007ea8 <.Loc.943.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    7ea8:	37 93       	cmp	#-1,	r7	;r3 As==11
    7eaa:	60 20       	jnz	$+194    	;abs 0x7f6c

00007eac <.LBE84>:
  interval = (interval / 100) * 100;
    7eac:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    7eb0:	4f 43       	clr.b	r15		;
    7eb2:	0c 48       	mov	r8,	r12	;
    7eb4:	0d 44       	mov	r4,	r13	;
    7eb6:	b0 12 62 af 	call	#-20638	;#0xaf62
    7eba:	0e 4c       	mov	r12,	r14	;
    7ebc:	07 4d       	mov	r13,	r7	;

00007ebe <.LVL479>:
    7ebe:	08 4c       	mov	r12,	r8	;
    7ec0:	08 5c       	add	r12,	r8	;
    7ec2:	0f 4d       	mov	r13,	r15	;
    7ec4:	0f 6d       	addc	r13,	r15	;
    7ec6:	08 5c       	add	r12,	r8	;
    7ec8:	0f 6d       	addc	r13,	r15	;
    7eca:	0c 48       	mov	r8,	r12	;
    7ecc:	0d 4f       	mov	r15,	r13	;
    7ece:	81 4e 02 00 	mov	r14,	2(r1)	;
    7ed2:	81 4f 00 00 	mov	r15,	0(r1)	;
    7ed6:	b0 12 c2 af 	call	#-20542	;#0xafc2
    7eda:	0c 58       	add	r8,	r12	;
    7edc:	2f 41       	mov	@r1,	r15	;
    7ede:	0f 6d       	addc	r13,	r15	;

00007ee0 <.Loc.950.2>:
  elyChanLog(buffer + hdr_ext + 4, payload_len - 4, interval);
    7ee0:	1e 41 02 00 	mov	2(r1),	r14	;
    7ee4:	0e 5c       	add	r12,	r14	;
    7ee6:	0f 67       	addc	r7,	r15	;
    7ee8:	4d 49       	mov.b	r9,	r13	;
    7eea:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    7eee:	1c 41 06 00 	mov	6(r1),	r12	;
    7ef2:	0c 5a       	add	r10,	r12	;
    7ef4:	b0 12 b8 ad 	call	#-21064	;#0xadb8

00007ef8 <.LVL484>:
  if (hdr.reply) {
    7ef8:	06 93       	cmp	#0,	r6	;r3 As==00
    7efa:	30 24       	jz	$+98     	;abs 0x7f5c

00007efc <.Loc.954.2>:
    gen_success(buffer, hdr.crc);
    7efc:	4d 45       	mov.b	r5,	r13	;
    7efe:	0c 4a       	mov	r10,	r12	;
    7f00:	b0 12 28 6e 	call	#28200		;#0x6e28

00007f04 <.LVL485>:
    7f04:	20 3c       	jmp	$+66     	;abs 0x7f46

00007f06 <.L376>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7f06:	6d 43       	mov.b	#2,	r13	;r3 As==10

00007f08 <.LVL487>:
    7f08:	b3 3f       	jmp	$-152    	;abs 0x7e70

00007f0a <.L377>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7f0a:	6c 42       	mov.b	#4,	r12	;r2 As==10
    7f0c:	b9 3f       	jmp	$-140    	;abs 0x7e80

00007f0e <.L372>:
    if ((buffer[i] < 0x40) || 
    7f0e:	0e 4a       	mov	r10,	r14	;
    7f10:	0e 5d       	add	r13,	r14	;
    7f12:	6e 4e       	mov.b	@r14,	r14	;
    7f14:	48 4e       	mov.b	r14,	r8	;
    7f16:	78 50 c0 ff 	add.b	#-64,	r8	;#0xffc0
    7f1a:	77 40 36 00 	mov.b	#54,	r7	;#0x0036
    7f1e:	47 98       	cmp.b	r8,	r7	;
    7f20:	0c 28       	jnc	$+26     	;abs 0x7f3a

00007f22 <.Loc.926.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7f22:	78 50 ef ff 	add.b	#-17,	r8	;#0xffef

00007f26 <.Loc.925.2>:
    if ((buffer[i] < 0x40) || 
    7f26:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    7f2a:	47 98       	cmp.b	r8,	r7	;
    7f2c:	06 2c       	jc	$+14     	;abs 0x7f3a

00007f2e <.Loc.927.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    7f2e:	7e 50 9d ff 	add.b	#-99,	r14	;#0xff9d

00007f32 <.Loc.926.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    7f32:	78 40 0c 00 	mov.b	#12,	r8	;#0x000c
    7f36:	48 9e       	cmp.b	r14,	r8	;
    7f38:	17 28       	jnc	$+48     	;abs 0x7f68

00007f3a <.L368>:
      if (hdr.reply) {
    7f3a:	06 93       	cmp	#0,	r6	;r3 As==00
    7f3c:	0b 24       	jz	$+24     	;abs 0x7f54

00007f3e <.Loc.931.2>:
        gen_failure(buffer, hdr.crc);
    7f3e:	4d 45       	mov.b	r5,	r13	;

00007f40 <.LVL490>:
    7f40:	0c 4a       	mov	r10,	r12	;
    7f42:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007f46 <.L378>:
    elyCmdSendReply(buffer);
    7f46:	0c 4a       	mov	r10,	r12	;
    7f48:	b0 12 52 74 	call	#29778		;#0x7452

00007f4c <.L364>:
}
    7f4c:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7f50:	64 17       	popm	#7,	r10	;16-bit words
    7f52:	30 41       	ret			

00007f54 <.L370>:
        elyErrorSignal(ErrCmdFailure);
    7f54:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    7f58:	b0 12 5a ac 	call	#-21414	;#0xac5a

00007f5c <.L375>:
    elyNLFreeBuffer(elyNLPack(buffer));
    7f5c:	0c 4a       	mov	r10,	r12	;
    7f5e:	b0 12 32 ab 	call	#-21710	;#0xab32

00007f62 <.LVL495>:
    7f62:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00007f66 <.LVL496>:
    7f66:	f2 3f       	jmp	$-26     	;abs 0x7f4c

00007f68 <.L369>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    7f68:	1d 53       	inc	r13		;
    7f6a:	8f 3f       	jmp	$-224    	;abs 0x7e8a

00007f6c <.L374>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    7f6c:	1e 41 04 00 	mov	4(r1),	r14	;
    7f70:	0e 57       	add	r7,	r14	;
    7f72:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    7f76:	1f 41 08 00 	mov	8(r1),	r15	;
    7f7a:	6c 4f       	mov.b	@r15,	r12	;
    7f7c:	0d 43       	clr	r13		;
    7f7e:	0f 43       	clr	r15		;
    7f80:	b0 12 de af 	call	#-20514	;#0xafde
    7f84:	08 dc       	bis	r12,	r8	;

00007f86 <.LVL501>:
    7f86:	04 dd       	bis	r13,	r4	;

00007f88 <.LVL502>:
    7f88:	8e 3f       	jmp	$-226    	;abs 0x7ea6

00007f8a <channel_unsub>:
    7f8a:	3a 15       	pushm	#4,	r10	;16-bit words

00007f8c <.LCFI54>:
static void channel_unsub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    7f8c:	21 83       	decd	r1		;

00007f8e <.LCFI55>:
    7f8e:	0a 4c       	mov	r12,	r10	;

00007f90 <.LVL504>:
    7f90:	5c 4d 01 00 	mov.b	1(r13),	r12	;

00007f94 <.LVL505>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7f94:	68 4d       	mov.b	@r13,	r8	;

00007f96 <L0>:
    7f96:	58 f3       	and.b	#1,	r8	;r3 As==01
    7f98:	6e 4d       	mov.b	@r13,	r14	;
    7f9a:	1e b3       	bit	#1,	r14	;r3 As==01
    7f9c:	18 20       	jnz	$+50     	;abs 0x7fce
    7f9e:	4f 43       	clr.b	r15		;

00007fa0 <.L380>:
    7fa0:	6e f3       	and.b	#2,	r14	;r3 As==10
    7fa2:	49 4e       	mov.b	r14,	r9	;
    7fa4:	4d 4c       	mov.b	r12,	r13	;
    7fa6:	4d 8e       	sub.b	r14,	r13	;

00007fa8 <.LVL506>:
    7fa8:	4d 8f       	sub.b	r15,	r13	;
    7faa:	4f 4d       	mov.b	r13,	r15	;

00007fac <.LVL507>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7fac:	09 93       	cmp	#0,	r9	;r3 As==00
    7fae:	11 20       	jnz	$+36     	;abs 0x7fd2

00007fb0 <.Loc.887.2>:
    7fb0:	6c 43       	mov.b	#2,	r12	;r3 As==10

00007fb2 <.L381>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    7fb2:	0e 4c       	mov	r12,	r14	;
    7fb4:	0f 5c       	add	r12,	r15	;

00007fb6 <.L382>:
    7fb6:	0e 9f       	cmp	r15,	r14	;
    7fb8:	0e 38       	jl	$+30     	;abs 0x7fd6

00007fba <.LBE89>:
  elyChanUnsubscribe(buffer + hdr_ext, payload_len);
    7fba:	0c 5a       	add	r10,	r12	;

00007fbc <.LVL510>:
    7fbc:	b0 12 6e ad 	call	#-21138	;#0xad6e

00007fc0 <.LVL511>:
  if (hdr.reply) {
    7fc0:	09 93       	cmp	#0,	r9	;r3 As==00
    7fc2:	22 24       	jz	$+70     	;abs 0x8008

00007fc4 <.Loc.909.2>:
    gen_success(buffer, hdr.crc);
    7fc4:	4d 48       	mov.b	r8,	r13	;
    7fc6:	0c 4a       	mov	r10,	r12	;
    7fc8:	b0 12 28 6e 	call	#28200		;#0x6e28

00007fcc <.LVL512>:
    7fcc:	13 3c       	jmp	$+40     	;abs 0x7ff4

00007fce <.L388>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    7fce:	6f 43       	mov.b	#2,	r15	;r3 As==10
    7fd0:	e7 3f       	jmp	$-48     	;abs 0x7fa0

00007fd2 <.L389>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    7fd2:	6c 42       	mov.b	#4,	r12	;r2 As==10

00007fd4 <.LVL515>:
    7fd4:	ee 3f       	jmp	$-34     	;abs 0x7fb2

00007fd6 <.L386>:
    if (buffer[i] < 0x40 || buffer[i] > 0x7F) {
    7fd6:	0b 4a       	mov	r10,	r11	;
    7fd8:	0b 5e       	add	r14,	r11	;
    7fda:	6b 4b       	mov.b	@r11,	r11	;
    7fdc:	7b 50 c0 ff 	add.b	#-64,	r11	;#0xffc0
    7fe0:	77 40 3f 00 	mov.b	#63,	r7	;#0x003f
    7fe4:	47 9b       	cmp.b	r11,	r7	;
    7fe6:	16 2c       	jc	$+46     	;abs 0x8014

00007fe8 <.Loc.891.2>:
      if (hdr.reply) {
    7fe8:	09 93       	cmp	#0,	r9	;r3 As==00
    7fea:	0a 24       	jz	$+22     	;abs 0x8000

00007fec <.Loc.893.2>:
        gen_failure(buffer, hdr.crc);
    7fec:	4d 48       	mov.b	r8,	r13	;

00007fee <.LVL517>:
    7fee:	0c 4a       	mov	r10,	r12	;

00007ff0 <.LVL518>:
    7ff0:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00007ff4 <.L390>:
    elyCmdSendReply(buffer);
    7ff4:	0c 4a       	mov	r10,	r12	;
    7ff6:	b0 12 52 74 	call	#29778		;#0x7452

00007ffa <.L379>:
}
    7ffa:	21 53       	incd	r1		;
    7ffc:	37 17       	popm	#4,	r10	;16-bit words
    7ffe:	30 41       	ret			

00008000 <.L384>:
        elyErrorSignal(ErrCmdFailure);
    8000:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c

00008004 <.LVL522>:
    8004:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008008 <.L387>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8008:	0c 4a       	mov	r10,	r12	;
    800a:	b0 12 32 ab 	call	#-21710	;#0xab32

0000800e <.LVL524>:
    800e:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008012 <.LVL525>:
    8012:	f3 3f       	jmp	$-24     	;abs 0x7ffa

00008014 <.L383>:
  for (int i = hdr_ext; i < hdr_ext + payload_len; i++) {
    8014:	1e 53       	inc	r14		;
    8016:	cf 3f       	jmp	$-96     	;abs 0x7fb6

00008018 <channel_sub>:
    8018:	6a 15       	pushm	#7,	r10	;16-bit words

0000801a <.LCFI56>:
static void channel_sub(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    801a:	31 80 0c 00 	sub	#12,	r1	;#0x000c

0000801e <.LCFI57>:
    801e:	0a 4c       	mov	r12,	r10	;

00008020 <.LVL529>:
    8020:	59 4d       	mov.b,		r9	;Warning: disassembly unreliable - not enough bytes available

00008022 <L0>:
    8022:	01 00       	mova	@r0,	r1	;

00008024 <.LVL530>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    8024:	65 4d       	mov.b	@r13,	r5	;
    8026:	55 f3       	and.b	#1,	r5	;r3 As==01
    8028:	6c 4d       	mov.b	@r13,	r12	;

0000802a <.LVL531>:
    802a:	1c b3       	bit	#1,	r12	;r3 As==01
    802c:	4c 20       	jnz	$+154    	;abs 0x80c6
    802e:	4d 43       	clr.b	r13		;

00008030 <.L392>:
    8030:	6c f3       	and.b	#2,	r12	;r3 As==10

00008032 <.LVL533>:
    8032:	46 4c       	mov.b	r12,	r6	;
    8034:	49 8c       	sub.b	r12,	r9	;

00008036 <.LVL534>:
    8036:	49 8d       	sub.b	r13,	r9	;
    8038:	4f 49       	mov.b	r9,	r15	;

0000803a <.LVL535>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    803a:	06 93       	cmp	#0,	r6	;r3 As==00
    803c:	46 20       	jnz	$+142    	;abs 0x80ca

0000803e <.Loc.841.2>:
    803e:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008040 <.L393>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8040:	0d 4c       	mov	r12,	r13	;
    8042:	2d 52       	add	#4,	r13	;r2 As==10

00008044 <.LVL537>:
    8044:	81 4d 06 00 	mov	r13,	6(r1)	;
    8048:	0f 5c       	add	r12,	r15	;

0000804a <.L394>:
    804a:	0d 9f       	cmp	r15,	r13	;
    804c:	40 38       	jl	$+130    	;abs 0x80ce
    804e:	0d 4c       	mov	r12,	r13	;

00008050 <.LVL538>:
    8050:	4c 18 0d 5d 	rpt #13 { rlax.w	r13		;
    8054:	0d 8c       	sub	r12,	r13	;
    8056:	81 4d 04 00 	mov	r13,	4(r1)	;

0000805a <.Loc.844.2>:
    805a:	67 42       	mov.b	#4,	r7	;r2 As==10
    805c:	48 43       	clr.b	r8		;
    805e:	04 48       	mov	r8,	r4	;

00008060 <.LBB94>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    8060:	0c 5a       	add	r10,	r12	;
    8062:	81 4c 08 00 	mov	r12,	8(r1)	;

00008066 <.L400>:
    8066:	37 53       	add	#-1,	r7	;r3 As==11

00008068 <.Loc.863.2>:
  for (int i = hdr_ext; i < hdr_ext + 4; i++) {
    8068:	37 93       	cmp	#-1,	r7	;r3 As==11
    806a:	60 20       	jnz	$+194    	;abs 0x812c

0000806c <.LBE94>:
  interval = (interval / 100) * 100;
    806c:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8070:	4f 43       	clr.b	r15		;
    8072:	0c 48       	mov	r8,	r12	;
    8074:	0d 44       	mov	r4,	r13	;
    8076:	b0 12 62 af 	call	#-20638	;#0xaf62
    807a:	0e 4c       	mov	r12,	r14	;
    807c:	07 4d       	mov	r13,	r7	;

0000807e <.LVL541>:
    807e:	08 4c       	mov	r12,	r8	;
    8080:	08 5c       	add	r12,	r8	;
    8082:	0f 4d       	mov	r13,	r15	;
    8084:	0f 6d       	addc	r13,	r15	;
    8086:	08 5c       	add	r12,	r8	;
    8088:	0f 6d       	addc	r13,	r15	;
    808a:	0c 48       	mov	r8,	r12	;
    808c:	0d 4f       	mov	r15,	r13	;
    808e:	81 4e 02 00 	mov	r14,	2(r1)	;
    8092:	81 4f 00 00 	mov	r15,	0(r1)	;
    8096:	b0 12 c2 af 	call	#-20542	;#0xafc2
    809a:	0c 58       	add	r8,	r12	;
    809c:	2f 41       	mov	@r1,	r15	;
    809e:	0f 6d       	addc	r13,	r15	;

000080a0 <.Loc.871.2>:
  elyChanSubscribe(buffer + hdr_ext + 4, payload_len-4, interval);
    80a0:	1e 41 02 00 	mov	2(r1),	r14	;
    80a4:	0e 5c       	add	r12,	r14	;
    80a6:	0f 67       	addc	r7,	r15	;
    80a8:	4d 49       	mov.b	r9,	r13	;
    80aa:	7d 50 fc ff 	add.b	#-4,	r13	;#0xfffc
    80ae:	1c 41 06 00 	mov	6(r1),	r12	;
    80b2:	0c 5a       	add	r10,	r12	;
    80b4:	b0 12 24 ad 	call	#-21212	;#0xad24

000080b8 <.LVL546>:
  if (hdr.reply) {
    80b8:	06 93       	cmp	#0,	r6	;r3 As==00
    80ba:	47 24       	jz	$+144    	;abs 0x814a

000080bc <.Loc.875.2>:
    gen_success(buffer, hdr.crc);
    80bc:	4d 45       	mov.b	r5,	r13	;
    80be:	0c 4a       	mov	r10,	r12	;
    80c0:	b0 12 28 6e 	call	#28200		;#0x6e28

000080c4 <.LVL547>:
    80c4:	20 3c       	jmp	$+66     	;abs 0x8106

000080c6 <.L403>:
  uint8_t payload_len = hdr.length - ((hdr.crc ? 2 : 0) + (hdr.reply ? 2 : 0));
    80c6:	6d 43       	mov.b	#2,	r13	;r3 As==10

000080c8 <.LVL549>:
    80c8:	b3 3f       	jmp	$-152    	;abs 0x8030

000080ca <.L404>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    80ca:	6c 42       	mov.b	#4,	r12	;r2 As==10
    80cc:	b9 3f       	jmp	$-140    	;abs 0x8040

000080ce <.L399>:
    if ((buffer[i] < 0x40) || 
    80ce:	0e 4a       	mov	r10,	r14	;
    80d0:	0e 5d       	add	r13,	r14	;
    80d2:	6e 4e       	mov.b	@r14,	r14	;
    80d4:	48 4e       	mov.b	r14,	r8	;
    80d6:	78 50 c0 ff 	add.b	#-64,	r8	;#0xffc0
    80da:	77 40 36 00 	mov.b	#54,	r7	;#0x0036
    80de:	47 98       	cmp.b	r8,	r7	;
    80e0:	0c 28       	jnc	$+26     	;abs 0x80fa

000080e2 <.Loc.846.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    80e2:	78 50 ef ff 	add.b	#-17,	r8	;#0xffef

000080e6 <.Loc.845.2>:
    if ((buffer[i] < 0x40) || 
    80e6:	77 40 0e 00 	mov.b	#14,	r7	;#0x000e
    80ea:	47 98       	cmp.b	r8,	r7	;
    80ec:	06 2c       	jc	$+14     	;abs 0x80fa

000080ee <.Loc.847.2>:
        (buffer[i] >= ChanNLMAX && buffer[i] < 0x70) ||
    80ee:	7e 50 9d ff 	add.b	#-99,	r14	;#0xff9d

000080f2 <.Loc.846.2>:
        (buffer[i] >= ChanCoreMAX && buffer[i] < 0x60) ||
    80f2:	78 40 0c 00 	mov.b	#12,	r8	;#0x000c
    80f6:	48 9e       	cmp.b	r14,	r8	;
    80f8:	17 28       	jnc	$+48     	;abs 0x8128

000080fa <.L395>:
      if (hdr.reply) {
    80fa:	06 93       	cmp	#0,	r6	;r3 As==00
    80fc:	08 24       	jz	$+18     	;abs 0x810e

000080fe <.Loc.851.2>:
        gen_failure(buffer, hdr.crc);
    80fe:	4d 45       	mov.b	r5,	r13	;

00008100 <.LVL552>:
    8100:	0c 4a       	mov	r10,	r12	;
    8102:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008106 <.L405>:
    elyCmdSendReply(buffer);
    8106:	0c 4a       	mov	r10,	r12	;
    8108:	b0 12 52 74 	call	#29778		;#0x7452

0000810c <.LVL554>:
    810c:	09 3c       	jmp	$+20     	;abs 0x8120

0000810e <.L397>:
        elyNLFreeBuffer(elyNLPack(buffer));
    810e:	0c 4a       	mov	r10,	r12	;
    8110:	b0 12 32 ab 	call	#-21710	;#0xab32

00008114 <.LVL556>:
    8114:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008118 <.LVL557>:
        elyErrorSignal(ErrCmdFailure);
    8118:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    811c:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008120 <.L391>:
}
    8120:	31 50 0c 00 	add	#12,	r1	;#0x000c
    8124:	64 17       	popm	#7,	r10	;16-bit words
    8126:	30 41       	ret			

00008128 <.L396>:
  for (int i = hdr_ext + 4; i < hdr_ext + payload_len; i++) {
    8128:	1d 53       	inc	r13		;
    812a:	8f 3f       	jmp	$-224    	;abs 0x804a

0000812c <.L401>:
    interval |= ((uint32_t)(buffer[hdr_ext]) << (8 * (3-i)));
    812c:	1e 41 04 00 	mov	4(r1),	r14	;
    8130:	0e 57       	add	r7,	r14	;
    8132:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    8136:	1f 41 08 00 	mov	8(r1),	r15	;
    813a:	6c 4f       	mov.b	@r15,	r12	;
    813c:	0d 43       	clr	r13		;
    813e:	0f 43       	clr	r15		;
    8140:	b0 12 de af 	call	#-20514	;#0xafde
    8144:	08 dc       	bis	r12,	r8	;

00008146 <.LVL563>:
    8146:	04 dd       	bis	r13,	r4	;

00008148 <.LVL564>:
    8148:	8e 3f       	jmp	$-226    	;abs 0x8066

0000814a <.L402>:
    elyNLFreeBuffer(elyNLPack(buffer));
    814a:	0c 4a       	mov	r10,	r12	;
    814c:	b0 12 32 ab 	call	#-21710	;#0xab32

00008150 <.LVL566>:
    8150:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008154 <.LVL567>:
    8154:	e5 3f       	jmp	$-52     	;abs 0x8120

00008156 <reload_config>:
    8156:	3a 15       	pushm	#4,	r10	;16-bit words

00008158 <.LCFI58>:
static void reload_config(uint8_t * buffer, elysium_cmd_hdr_t hdr) {
    8158:	21 83       	decd	r1		;

0000815a <.LCFI59>:
    815a:	09 4c       	mov	r12,	r9	;
    815c:	0c 4d       	mov	r13,	r12	;

0000815e <.LVL569>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    815e:	6d 4d       	mov.b	@r13,	r13	;
    8160:	5d f3       	and.b	#1,	r13	;r3 As==01
    8162:	6c 4c       	mov.b	@r12,	r12	;

00008164 <L0>:
    8164:	6c f3       	and.b	#2,	r12	;r3 As==10

00008166 <.LVL571>:
    8166:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    816a:	0c 93       	cmp	#0,	r12	;r3 As==00
    816c:	14 20       	jnz	$+42     	;abs 0x8196
    816e:	6e 43       	mov.b	#2,	r14	;r3 As==10

00008170 <.L407>:
  uint8_t bank = buffer[hdr_ext];
    8170:	0e 59       	add	r9,	r14	;

00008172 <.LVL573>:
    8172:	6a 4e       	mov.b	@r14,	r10	;

00008174 <.LVL574>:
  if (bank == 0 || bank > 4) {
    8174:	4e 4a       	mov.b	r10,	r14	;

00008176 <.LVL575>:
    8176:	7e 53       	add.b	#-1,	r14	;r3 As==11
    8178:	7f 40 03 00 	mov.b	#3,	r15	;
    817c:	4f 9e       	cmp.b	r14,	r15	;
    817e:	17 2c       	jc	$+48     	;abs 0x81ae

00008180 <.Loc.811.2>:
    if (hdr.reply) {
    8180:	0c 93       	cmp	#0,	r12	;r3 As==00
    8182:	0b 24       	jz	$+24     	;abs 0x819a

00008184 <.Loc.813.2>:
      gen_failure(buffer, hdr.crc);
    8184:	0c 49       	mov	r9,	r12	;
    8186:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000818a <.LVL576>:
      elyCmdSendReply(buffer);
    818a:	0c 49       	mov	r9,	r12	;
    818c:	b0 12 52 74 	call	#29778		;#0x7452

00008190 <.L406>:
}
    8190:	21 53       	incd	r1		;
    8192:	37 17       	popm	#4,	r10	;16-bit words
    8194:	30 41       	ret			

00008196 <.L411>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8196:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8198:	eb 3f       	jmp	$-40     	;abs 0x8170

0000819a <.L409>:
      elyErrorSignal(ErrCmdFailure);
    819a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    819e:	b0 12 5a ac 	call	#-21414	;#0xac5a

000081a2 <.LVL580>:
      elyNLFreeBuffer(elyNLPack(buffer));
    81a2:	0c 49       	mov	r9,	r12	;
    81a4:	b0 12 32 ab 	call	#-21710	;#0xab32

000081a8 <.LVL581>:
    81a8:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

000081ac <.LVL582>:
    81ac:	f1 3f       	jmp	$-28     	;abs 0x8190

000081ae <.L408>:
  elyRegGetBlock(bank, bank0w, 0, RegCoreMAX);
    81ae:	18 42 bc bd 	mov	&0xbdbc,r8	;0xbdbc
    81b2:	37 40 60 96 	mov	#-27040,r7	;#0x9660
    81b6:	7f 40 56 00 	mov.b	#86,	r15	;#0x0056
    81ba:	4e 43       	clr.b	r14		;
    81bc:	0d 48       	mov	r8,	r13	;
    81be:	4c 4a       	mov.b	r10,	r12	;
    81c0:	87 12       	call	r7		;

000081c2 <.LVL583>:
  elyRegGetBlock(bank, bank0w + 0x80, 0x80, RegNLMAX - 0x80);
    81c2:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    81c6:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80
    81ca:	0d 48       	mov	r8,	r13	;
    81cc:	3d 50 80 00 	add	#128,	r13	;#0x0080
    81d0:	4c 4a       	mov.b	r10,	r12	;
    81d2:	87 12       	call	r7		;

000081d4 <.LVL584>:
  elyRegGetBlock(bank, bank0w + 0xC0, 0xC0, RegDLLMAX - 0xC0);
    81d4:	7f 40 15 00 	mov.b	#21,	r15	;#0x0015
    81d8:	7e 40 c0 ff 	mov.b	#-64,	r14	;#0xffc0
    81dc:	0d 48       	mov	r8,	r13	;
    81de:	3d 50 c0 00 	add	#192,	r13	;#0x00c0
    81e2:	4c 4a       	mov.b	r10,	r12	;
    81e4:	87 12       	call	r7		;

000081e6 <.LVL585>:
  elyNLFreeBuffer(elyNLPack(buffer));
    81e6:	0c 49       	mov	r9,	r12	;
    81e8:	b0 12 32 ab 	call	#-21710	;#0xab32

000081ec <.LVL586>:
    81ec:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

000081f0 <.LVL587>:
  bank0w[RegActiveBank] = bank;
    81f0:	c8 4a 69 00 	mov.b	r10,	105(r8)	; 0x0069

000081f4 <.Loc.836.2>:
  PMMCTL0 = PMMPW | SVSHE | PMMSWPOR; /* SW POR */
    81f4:	b2 40 48 a5 	mov	#-23224,&0x0120	;#0xa548
    81f8:	20 01 
    81fa:	ca 3f       	jmp	$-106    	;abs 0x8190

000081fc <set_baud>:
    81fc:	6a 15       	pushm	#7,	r10	;16-bit words

000081fe <.LCFI60>:
static void set_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    81fe:	21 82       	sub	#4,	r1	;r2 As==10

00008200 <.LCFI61>:
    8200:	08 4c       	mov	r12,	r8	;

00008202 <L0>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8202:	66 4d       	mov.b	@r13,	r6	;
    8204:	56 f3       	and.b	#1,	r6	;r3 As==01
    8206:	67 4d       	mov.b	@r13,	r7	;
    8208:	67 f3       	and.b	#2,	r7	;r3 As==10
    820a:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    820e:	07 93       	cmp	#0,	r7	;r3 As==00
    8210:	32 20       	jnz	$+102    	;abs 0x8276
    8212:	69 43       	mov.b	#2,	r9	;r3 As==10

00008214 <.L413>:
    8214:	09 58       	add	r8,	r9	;
    8216:	0b 49       	mov	r9,	r11	;

00008218 <.Loc.762.2>:
    8218:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

0000821c <.Loc.763.2>:
  uint32_t baud = 0;
    821c:	45 43       	clr.b	r5		;
    821e:	0a 45       	mov	r5,	r10	;

00008220 <.L414>:
    baud |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8220:	6c 4b       	mov.b	@r11,	r12	;
    8222:	0d 43       	clr	r13		;
    8224:	0e 44       	mov	r4,	r14	;
    8226:	0f 43       	clr	r15		;
    8228:	81 4b 00 00 	mov	r11,	0(r1)	;
    822c:	b0 12 de af 	call	#-20514	;#0xafde
    8230:	0c d5       	bis	r5,	r12	;
    8232:	0d da       	bis	r10,	r13	;
    8234:	05 4c       	mov	r12,	r5	;

00008236 <.LVL593>:
    8236:	0a 4d       	mov	r13,	r10	;

00008238 <.LVL594>:
    8238:	2b 41       	mov	@r1,	r11	;
    823a:	1b 53       	inc	r11		;
    823c:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

00008240 <.Loc.766.2>:
  for (int i = 0; i < 4; i++) {
    8240:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    8244:	ed 23       	jnz	$-36     	;abs 0x8220

00008246 <.LBE99>:
  if (baud > UART_BAUD_MAX || 
    8246:	35 53       	add	#-1,	r5	;r3 As==11

00008248 <.LVL595>:
    8248:	3a 63       	addc	#-1,	r10	;r3 As==11

0000824a <.LVL596>:
    824a:	7c 40 0f 00 	mov.b	#15,	r12	;#0x000f

0000824e <.LVL597>:
    824e:	0c 9a       	cmp	r10,	r12	;
    8250:	06 28       	jnc	$+14     	;abs 0x825e
    8252:	0a 9c       	cmp	r12,	r10	;
    8254:	1c 20       	jnz	$+58     	;abs 0x828e
    8256:	3c 40 3f 42 	mov	#16959,	r12	;#0x423f
    825a:	0c 95       	cmp	r5,	r12	;
    825c:	18 2c       	jc	$+50     	;abs 0x828e

0000825e <.L421>:
    if (hdr.reply) {
    825e:	07 93       	cmp	#0,	r7	;r3 As==00
    8260:	0c 24       	jz	$+26     	;abs 0x827a

00008262 <.Loc.774.2>:
      gen_failure(buffer, hdr.crc);
    8262:	4d 46       	mov.b	r6,	r13	;
    8264:	0c 48       	mov	r8,	r12	;
    8266:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000826a <.L423>:
    elyCmdSendReply(buffer);
    826a:	0c 48       	mov	r8,	r12	;
    826c:	b0 12 52 74 	call	#29778		;#0x7452

00008270 <.L412>:
}
    8270:	21 52       	add	#4,	r1	;r2 As==10
    8272:	64 17       	popm	#7,	r10	;16-bit words
    8274:	30 41       	ret			

00008276 <.L420>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8276:	69 42       	mov.b	#4,	r9	;r2 As==10
    8278:	cd 3f       	jmp	$-100    	;abs 0x8214

0000827a <.L417>:
      elyErrorSignal(ErrCmdFailure);
    827a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    827e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008282 <.L419>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8282:	0c 48       	mov	r8,	r12	;
    8284:	b0 12 32 ab 	call	#-21710	;#0xab32

00008288 <.LVL604>:
    8288:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000828c <.LVL605>:
    828c:	f1 3f       	jmp	$-28     	;abs 0x8270

0000828e <.L415>:
  bank0w[RegUARTBaudMsb] = buffer[hdr_ext];
    828e:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    8292:	ec 49 25 00 	mov.b	@r9,	37(r12)	; 0x0025

00008296 <.Loc.786.2>:
  bank0w[RegUARTBaudHmb] = buffer[hdr_ext+1];
    8296:	dc 49 01 00 	mov.b	1(r9),	36(r12)	; 0x0024
    829a:	24 00 

0000829c <.Loc.787.2>:
  bank0w[RegUARTBaudLmb] = buffer[hdr_ext+2];
    829c:	dc 49 02 00 	mov.b	2(r9),	35(r12)	; 0x0023
    82a0:	23 00 

000082a2 <.Loc.788.2>:
  bank0w[RegUARTBaudLsb] = buffer[hdr_ext+3];
    82a2:	dc 49 03 00 	mov.b	3(r9),	34(r12)	; 0x0022
    82a6:	22 00 

000082a8 <.Loc.791.2>:
  elyUARTCfgMarkDirty();
    82a8:	b0 12 6c 6b 	call	#27500		;#0x6b6c

000082ac <.LVL607>:
  if (hdr.reply) {
    82ac:	07 93       	cmp	#0,	r7	;r3 As==00
    82ae:	e9 27       	jz	$-44     	;abs 0x8282

000082b0 <.Loc.795.2>:
    gen_success(buffer, hdr.crc);
    82b0:	4d 46       	mov.b	r6,	r13	;
    82b2:	0c 48       	mov	r8,	r12	;
    82b4:	b0 12 28 6e 	call	#28200		;#0x6e28

000082b8 <.LVL608>:
    82b8:	d8 3f       	jmp	$-78     	;abs 0x826a

000082ba <get_baud>:
    82ba:	0a 15       	pushm	#1,	r10	;16-bit words

000082bc <.LCFI62>:
static void get_baud(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    82bc:	21 83       	decd	r1		;

000082be <.LCFI63>:
    82be:	0a 4c       	mov	r12,	r10	;

000082c0 <L0>:
    82c0:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    82c4:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    82c8:	01 00 

000082ca <.Loc.737.2>:
  if (hdr.reply) {
    82ca:	6f 41       	mov.b	@r1,	r15	;
    82cc:	2f b3       	bit	#2,	r15	;r3 As==10
    82ce:	2b 24       	jz	$+88     	;abs 0x8326

000082d0 <.Loc.738.2>:
    buffer[0] = buffer[0] & 0x3F;
    82d0:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    82d4:	00 00 

000082d6 <.Loc.739.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    82d6:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

000082da <.LVL610>:
    82da:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    82de:	02 00 

000082e0 <.Loc.740.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    82e0:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    82e4:	03 00 

000082e6 <.LVL611>:
    82e6:	0d 4c       	mov	r12,	r13	;
    82e8:	3d 50 25 00 	add	#37,	r13	;#0x0025
    82ec:	0e 4a       	mov	r10,	r14	;
    82ee:	2e 52       	add	#4,	r14	;r2 As==10
    82f0:	3c 50 21 00 	add	#33,	r12	;#0x0021

000082f4 <.L426>:
      buffer[i + 4] = bank0p[RegUARTBaudMsb - i];
    82f4:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

000082f8 <.LVL613>:
    82f8:	3d 53       	add	#-1,	r13	;r3 As==11
    82fa:	1e 53       	inc	r14		;

000082fc <.LVL614>:
    for (int i = 0; i < 4; i++) {
    82fc:	0d 9c       	cmp	r12,	r13	;
    82fe:	fa 23       	jnz	$-10     	;abs 0x82f4

00008300 <.LBE100>:
    if (hdr.crc) {
    8300:	1f b3       	bit	#1,	r15	;r3 As==01
    8302:	0e 24       	jz	$+30     	;abs 0x8320

00008304 <.Loc.746.2>:
      buffer[1] = 6;
    8304:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8308:	01 00 

0000830a <.Loc.747.2>:
      crcGenX25(buffer, 10);
    830a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    830e:	0c 4a       	mov	r10,	r12	;
    8310:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008314 <.L428>:
    elyCmdSendReply(buffer);
    8314:	0c 4a       	mov	r10,	r12	;
    8316:	b0 12 52 74 	call	#29778		;#0x7452

0000831a <.L424>:
}
    831a:	21 53       	incd	r1		;
    831c:	0a 17       	popm	#1,	r10	;16-bit words
    831e:	30 41       	ret			

00008320 <.L427>:
      buffer[1] = 4;
    8320:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8324:	f7 3f       	jmp	$-16     	;abs 0x8314

00008326 <.L425>:
    8326:	b0 12 e4 6f 	call	#28644		;#0x6fe4

0000832a <.LVL619>:
}
    832a:	f7 3f       	jmp	$-16     	;abs 0x831a

0000832c <set_tx_pow>:
    832c:	2a 15       	pushm	#3,	r10	;16-bit words

0000832e <.LCFI64>:
static void set_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    832e:	21 83       	decd	r1		;

00008330 <L0>:
    8330:	0a 4c       	mov	r12,	r10	;

00008332 <.LVL621>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8332:	68 4d       	mov.b	@r13,	r8	;
    8334:	58 f3       	and.b	#1,	r8	;r3 As==01
    8336:	69 4d       	mov.b	@r13,	r9	;
    8338:	69 f3       	and.b	#2,	r9	;r3 As==10
    833a:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    833e:	09 93       	cmp	#0,	r9	;r3 As==00
    8340:	12 20       	jnz	$+38     	;abs 0x8366
    8342:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008344 <.L432>:
  if ((int8_t)(buffer[hdr_ext]) > TX_POW_MAX) {
    8344:	0c 5a       	add	r10,	r12	;

00008346 <.LVL623>:
    8346:	6c 4c       	mov.b	@r12,	r12	;
    8348:	4d 43       	clr.b	r13		;

0000834a <.LVL624>:
    834a:	4d 9c       	cmp.b	r12,	r13	;
    834c:	18 34       	jge	$+50     	;abs 0x837e

0000834e <.Loc.705.2>:
    if (hdr.reply) {
    834e:	09 93       	cmp	#0,	r9	;r3 As==00
    8350:	0c 24       	jz	$+26     	;abs 0x836a

00008352 <.Loc.707.2>:
      gen_failure(buffer, hdr.crc);
    8352:	4d 48       	mov.b	r8,	r13	;
    8354:	0c 4a       	mov	r10,	r12	;
    8356:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000835a <.L438>:
    elyCmdSendReply(buffer);
    835a:	0c 4a       	mov	r10,	r12	;
    835c:	b0 12 52 74 	call	#29778		;#0x7452

00008360 <.L431>:
}
    8360:	21 53       	incd	r1		;
    8362:	28 17       	popm	#3,	r10	;16-bit words
    8364:	30 41       	ret			

00008366 <.L437>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8366:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8368:	ed 3f       	jmp	$-36     	;abs 0x8344

0000836a <.L434>:
      elyErrorSignal(ErrCmdFailure);
    836a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    836e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008372 <.L436>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8372:	0c 4a       	mov	r10,	r12	;
    8374:	b0 12 32 ab 	call	#-21710	;#0xab32

00008378 <.LVL630>:
    8378:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000837c <.LVL631>:
    837c:	f1 3f       	jmp	$-28     	;abs 0x8360

0000837e <.L433>:
  bank0w[RegOutputPower] = buffer[hdr_ext];
    837e:	1d 42 bc bd 	mov	&0xbdbc,r13	;0xbdbc
    8382:	cd 4c 21 00 	mov.b	r12,	33(r13)	; 0x0021

00008386 <.Loc.721.2>:
  elyRFCfgMarkDirty(RFTxPowerUpdated);
    8386:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    838a:	4d 43       	clr.b	r13		;
    838c:	b0 12 90 a2 	call	#-23920	;#0xa290

00008390 <.LVL632>:
  if (hdr.reply) {
    8390:	09 93       	cmp	#0,	r9	;r3 As==00
    8392:	ef 27       	jz	$-32     	;abs 0x8372

00008394 <.Loc.725.2>:
    gen_success(buffer, hdr.crc);
    8394:	4d 48       	mov.b	r8,	r13	;
    8396:	0c 4a       	mov	r10,	r12	;
    8398:	b0 12 28 6e 	call	#28200		;#0x6e28

0000839c <.LVL633>:
    839c:	de 3f       	jmp	$-66     	;abs 0x835a

0000839e <get_tx_pow>:
    839e:	0a 15       	pushm	#1,	r10	;16-bit words

000083a0 <.LCFI66>:
static void get_tx_pow(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83a0:	21 83       	decd	r1		;

000083a2 <.LCFI67>:
    83a2:	0a 4c       	mov	r12,	r10	;

000083a4 <L0>:
    83a4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    83a8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    83ac:	01 00 

000083ae <.Loc.680.2>:
  if (hdr.reply) {
    83ae:	6e 41       	mov.b	@r1,	r14	;
    83b0:	2e b3       	bit	#2,	r14	;r3 As==10
    83b2:	20 24       	jz	$+66     	;abs 0x83f4

000083b4 <.Loc.681.2>:
    buffer[0] = buffer[0] & 0x3F;
    83b4:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    83b8:	00 00 

000083ba <.Loc.682.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    83ba:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    83be:	dc 4d 51 00 	mov.b	81(r13),2(r12)	;0x00051
    83c2:	02 00 

000083c4 <.Loc.683.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    83c4:	dc 4d 50 00 	mov.b	80(r13),3(r12)	;0x00050
    83c8:	03 00 

000083ca <.Loc.684.2>:
    buffer[4] = bank0p[RegOutputPower];
    83ca:	dc 4d 21 00 	mov.b	33(r13),4(r12)	;0x00021
    83ce:	04 00 

000083d0 <.Loc.685.2>:
    if (hdr.crc) {
    83d0:	1e b3       	bit	#1,	r14	;r3 As==01
    83d2:	0d 24       	jz	$+28     	;abs 0x83ee

000083d4 <.Loc.686.2>:
      buffer[1] = 3;
    83d4:	fc 40 03 00 	mov.b	#3,	1(r12)	;
    83d8:	01 00 

000083da <.Loc.687.2>:
      crcGenX25(buffer, 7);
    83da:	7d 40 07 00 	mov.b	#7,	r13	;
    83de:	b0 12 26 9b 	call	#-25818	;#0x9b26

000083e2 <.L442>:
    elyCmdSendReply(buffer);
    83e2:	0c 4a       	mov	r10,	r12	;
    83e4:	b0 12 52 74 	call	#29778		;#0x7452

000083e8 <.L439>:
}
    83e8:	21 53       	incd	r1		;
    83ea:	0a 17       	popm	#1,	r10	;16-bit words
    83ec:	30 41       	ret			

000083ee <.L441>:
      buffer[1] = 1;
    83ee:	dc 43 01 00 	mov.b	#1,	1(r12)	;r3 As==01
    83f2:	f7 3f       	jmp	$-16     	;abs 0x83e2

000083f4 <.L440>:
    83f4:	b0 12 e4 6f 	call	#28644		;#0x6fe4

000083f8 <.LVL637>:
}
    83f8:	f7 3f       	jmp	$-16     	;abs 0x83e8

000083fa <set_rx_dev>:
    83fa:	6a 15       	pushm	#7,	r10	;16-bit words

000083fc <.LCFI68>:
static void set_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    83fc:	21 82       	sub	#4,	r1	;r2 As==10

000083fe <L0>:
    83fe:	08 4c       	mov	r12,	r8	;

00008400 <.LVL639>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8400:	66 4d       	mov.b	@r13,	r6	;
    8402:	56 f3       	and.b	#1,	r6	;r3 As==01
    8404:	67 4d       	mov.b	@r13,	r7	;
    8406:	67 f3       	and.b	#2,	r7	;r3 As==10
    8408:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    840c:	07 93       	cmp	#0,	r7	;r3 As==00
    840e:	32 20       	jnz	$+102    	;abs 0x8474
    8410:	69 43       	mov.b	#2,	r9	;r3 As==10

00008412 <.L445>:
    8412:	09 58       	add	r8,	r9	;
    8414:	0b 49       	mov	r9,	r11	;

00008416 <.Loc.635.2>:
    8416:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

0000841a <.Loc.636.2>:
  uint32_t dev = 0;
    841a:	45 43       	clr.b	r5		;
    841c:	0a 45       	mov	r5,	r10	;

0000841e <.L446>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    841e:	6c 4b       	mov.b	@r11,	r12	;
    8420:	0d 43       	clr	r13		;
    8422:	0e 44       	mov	r4,	r14	;
    8424:	0f 43       	clr	r15		;
    8426:	81 4b 00 00 	mov	r11,	0(r1)	;
    842a:	b0 12 de af 	call	#-20514	;#0xafde
    842e:	0c d5       	bis	r5,	r12	;
    8430:	0d da       	bis	r10,	r13	;
    8432:	05 4c       	mov	r12,	r5	;

00008434 <.LVL643>:
    8434:	0a 4d       	mov	r13,	r10	;

00008436 <.LVL644>:
    8436:	2b 41       	mov	@r1,	r11	;
    8438:	1b 53       	inc	r11		;
    843a:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

0000843e <.Loc.639.2>:
  for (int i = 0; i < 4; i++) {
    843e:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    8442:	ed 23       	jnz	$-36     	;abs 0x841e

00008444 <.LBE101>:
  if (dev > RX_DEV_MAX || 
    8444:	35 50 18 7f 	add	#32536,	r5	;#0x7f18

00008448 <.LVL645>:
    8448:	3a 63       	addc	#-1,	r10	;r3 As==11

0000844a <.LVL646>:
    844a:	6c 43       	mov.b	#2,	r12	;r3 As==10

0000844c <.LVL647>:
    844c:	0c 9a       	cmp	r10,	r12	;
    844e:	06 28       	jnc	$+14     	;abs 0x845c
    8450:	0a 9c       	cmp	r12,	r10	;
    8452:	1c 20       	jnz	$+58     	;abs 0x848c
    8454:	3c 40 58 8c 	mov	#-29608,r12	;#0x8c58
    8458:	0c 95       	cmp	r5,	r12	;
    845a:	18 2c       	jc	$+50     	;abs 0x848c

0000845c <.L453>:
    if (hdr.reply) {
    845c:	07 93       	cmp	#0,	r7	;r3 As==00
    845e:	0c 24       	jz	$+26     	;abs 0x8478

00008460 <.Loc.647.2>:
      gen_failure(buffer, hdr.crc);
    8460:	4d 46       	mov.b	r6,	r13	;
    8462:	0c 48       	mov	r8,	r12	;
    8464:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008468 <.L455>:
    elyCmdSendReply(buffer);
    8468:	0c 48       	mov	r8,	r12	;
    846a:	b0 12 52 74 	call	#29778		;#0x7452

0000846e <.L444>:
}
    846e:	21 52       	add	#4,	r1	;r2 As==10
    8470:	64 17       	popm	#7,	r10	;16-bit words
    8472:	30 41       	ret			

00008474 <.L452>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8474:	69 42       	mov.b	#4,	r9	;r2 As==10
    8476:	cd 3f       	jmp	$-100    	;abs 0x8412

00008478 <.L449>:
      elyErrorSignal(ErrCmdFailure);
    8478:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    847c:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008480 <.L451>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8480:	0c 48       	mov	r8,	r12	;
    8482:	b0 12 32 ab 	call	#-21710	;#0xab32

00008486 <.LVL654>:
    8486:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000848a <.LVL655>:
    848a:	f1 3f       	jmp	$-28     	;abs 0x846e

0000848c <.L447>:
  bank0w[RegRXDevMsb] = buffer[hdr_ext];
    848c:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    8490:	ec 49 0f 00 	mov.b	@r9,	15(r12)	; 0x000f

00008494 <.Loc.659.2>:
  bank0w[RegRXDevHmb] = buffer[hdr_ext+1];
    8494:	dc 49 01 00 	mov.b	1(r9),	14(r12)	; 0x000e
    8498:	0e 00 

0000849a <.Loc.660.2>:
  bank0w[RegRXDevLmb] = buffer[hdr_ext+2];
    849a:	dc 49 02 00 	mov.b	2(r9),	13(r12)	; 0x000d
    849e:	0d 00 

000084a0 <.Loc.661.2>:
  bank0w[RegRXDevLsb] = buffer[hdr_ext+3];
    84a0:	dc 49 03 00 	mov.b	3(r9),	12(r12)	; 0x000c
    84a4:	0c 00 

000084a6 <.Loc.664.2>:
  elyRFCfgMarkDirty(RFRxDevUpdated);
    84a6:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    84aa:	4d 43       	clr.b	r13		;
    84ac:	b0 12 90 a2 	call	#-23920	;#0xa290

000084b0 <.LVL658>:
  if (hdr.reply) {
    84b0:	07 93       	cmp	#0,	r7	;r3 As==00
    84b2:	e6 27       	jz	$-50     	;abs 0x8480

000084b4 <.Loc.668.2>:
    gen_success(buffer, hdr.crc);
    84b4:	4d 46       	mov.b	r6,	r13	;
    84b6:	0c 48       	mov	r8,	r12	;
    84b8:	b0 12 28 6e 	call	#28200		;#0x6e28

000084bc <.LVL659>:
    84bc:	d5 3f       	jmp	$-84     	;abs 0x8468

000084be <get_rx_dev>:
    84be:	0a 15       	pushm	#1,	r10	;16-bit words

000084c0 <.LCFI70>:
static void get_rx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    84c0:	21 83       	decd	r1		;

000084c2 <.LCFI71>:
    84c2:	0a 4c       	mov	r12,	r10	;

000084c4 <L0>:
    84c4:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    84c8:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    84cc:	01 00 

000084ce <.Loc.610.2>:
  if (hdr.reply) {
    84ce:	6f 41       	mov.b	@r1,	r15	;
    84d0:	2f b3       	bit	#2,	r15	;r3 As==10
    84d2:	2b 24       	jz	$+88     	;abs 0x852a

000084d4 <.Loc.611.2>:
    buffer[0] = buffer[0] & 0x3F;
    84d4:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    84d8:	00 00 

000084da <.Loc.612.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    84da:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

000084de <.LVL661>:
    84de:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    84e2:	02 00 

000084e4 <.Loc.613.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    84e4:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    84e8:	03 00 

000084ea <.LVL662>:
    84ea:	0d 4c       	mov	r12,	r13	;
    84ec:	3d 50 0f 00 	add	#15,	r13	;#0x000f
    84f0:	0e 4a       	mov	r10,	r14	;
    84f2:	2e 52       	add	#4,	r14	;r2 As==10
    84f4:	3c 50 0b 00 	add	#11,	r12	;#0x000b

000084f8 <.L458>:
      buffer[i + 4] = bank0p[RegRXDevMsb - i];
    84f8:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

000084fc <.LVL664>:
    84fc:	3d 53       	add	#-1,	r13	;r3 As==11
    84fe:	1e 53       	inc	r14		;

00008500 <.LVL665>:
    for (int i = 0; i < 4; i++) {
    8500:	0d 9c       	cmp	r12,	r13	;
    8502:	fa 23       	jnz	$-10     	;abs 0x84f8

00008504 <.LBE102>:
    if (hdr.crc) {
    8504:	1f b3       	bit	#1,	r15	;r3 As==01
    8506:	0e 24       	jz	$+30     	;abs 0x8524

00008508 <.Loc.619.2>:
      buffer[1] = 6;
    8508:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    850c:	01 00 

0000850e <.Loc.620.2>:
      crcGenX25(buffer, 10);
    850e:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    8512:	0c 4a       	mov	r10,	r12	;
    8514:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008518 <.L460>:
    elyCmdSendReply(buffer);
    8518:	0c 4a       	mov	r10,	r12	;
    851a:	b0 12 52 74 	call	#29778		;#0x7452

0000851e <.L456>:
}
    851e:	21 53       	incd	r1		;
    8520:	0a 17       	popm	#1,	r10	;16-bit words
    8522:	30 41       	ret			

00008524 <.L459>:
      buffer[1] = 4;
    8524:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8528:	f7 3f       	jmp	$-16     	;abs 0x8518

0000852a <.L457>:
    852a:	b0 12 e4 6f 	call	#28644		;#0x6fe4

0000852e <.LVL670>:
}
    852e:	f7 3f       	jmp	$-16     	;abs 0x851e

00008530 <set_tx_dev>:
    8530:	6a 15       	pushm	#7,	r10	;16-bit words

00008532 <.LCFI72>:
static void set_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8532:	21 82       	sub	#4,	r1	;r2 As==10

00008534 <L0>:
    8534:	08 4c       	mov	r12,	r8	;

00008536 <.LVL672>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8536:	66 4d       	mov.b	@r13,	r6	;
    8538:	56 f3       	and.b	#1,	r6	;r3 As==01
    853a:	67 4d       	mov.b	@r13,	r7	;
    853c:	67 f3       	and.b	#2,	r7	;r3 As==10
    853e:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    8542:	07 93       	cmp	#0,	r7	;r3 As==00
    8544:	33 20       	jnz	$+104    	;abs 0x85ac
    8546:	69 43       	mov.b	#2,	r9	;r3 As==10

00008548 <.L464>:
    8548:	09 58       	add	r8,	r9	;
    854a:	0b 49       	mov	r9,	r11	;

0000854c <.Loc.565.2>:
    854c:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

00008550 <.Loc.566.2>:
  uint32_t dev = 0;
    8550:	45 43       	clr.b	r5		;
    8552:	0a 45       	mov	r5,	r10	;

00008554 <.L465>:
    dev |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8554:	6c 4b       	mov.b	@r11,	r12	;
    8556:	0d 43       	clr	r13		;
    8558:	0e 44       	mov	r4,	r14	;
    855a:	0f 43       	clr	r15		;
    855c:	81 4b 00 00 	mov	r11,	0(r1)	;
    8560:	b0 12 de af 	call	#-20514	;#0xafde
    8564:	0c d5       	bis	r5,	r12	;
    8566:	0d da       	bis	r10,	r13	;
    8568:	05 4c       	mov	r12,	r5	;

0000856a <.LVL676>:
    856a:	0a 4d       	mov	r13,	r10	;

0000856c <.LVL677>:
    856c:	2b 41       	mov	@r1,	r11	;
    856e:	1b 53       	inc	r11		;
    8570:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

00008574 <.Loc.569.2>:
  for (int i = 0; i < 4; i++) {
    8574:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    8578:	ed 23       	jnz	$-36     	;abs 0x8554

0000857a <.LBE103>:
  if (dev > TX_DEV_MAX || 
    857a:	35 50 a8 fd 	add	#-600,	r5	;#0xfda8

0000857e <.LVL678>:
    857e:	3a 63       	addc	#-1,	r10	;r3 As==11

00008580 <.LVL679>:
    8580:	7c 40 03 00 	mov.b	#3,	r12	;

00008584 <.LVL680>:
    8584:	0c 9a       	cmp	r10,	r12	;
    8586:	06 28       	jnc	$+14     	;abs 0x8594
    8588:	0a 9c       	cmp	r12,	r10	;
    858a:	1c 20       	jnz	$+58     	;abs 0x85c4
    858c:	3c 40 e8 0a 	mov	#2792,	r12	;#0x0ae8
    8590:	0c 95       	cmp	r5,	r12	;
    8592:	18 2c       	jc	$+50     	;abs 0x85c4

00008594 <.L472>:
    if (hdr.reply) {
    8594:	07 93       	cmp	#0,	r7	;r3 As==00
    8596:	0c 24       	jz	$+26     	;abs 0x85b0

00008598 <.Loc.577.2>:
      gen_failure(buffer, hdr.crc);
    8598:	4d 46       	mov.b	r6,	r13	;
    859a:	0c 48       	mov	r8,	r12	;
    859c:	b0 12 7a 6e 	call	#28282		;#0x6e7a

000085a0 <.L474>:
    elyCmdSendReply(buffer);
    85a0:	0c 48       	mov	r8,	r12	;
    85a2:	b0 12 52 74 	call	#29778		;#0x7452

000085a6 <.L463>:
}
    85a6:	21 52       	add	#4,	r1	;r2 As==10
    85a8:	64 17       	popm	#7,	r10	;16-bit words
    85aa:	30 41       	ret			

000085ac <.L471>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    85ac:	69 42       	mov.b	#4,	r9	;r2 As==10
    85ae:	cc 3f       	jmp	$-102    	;abs 0x8548

000085b0 <.L468>:
      elyErrorSignal(ErrCmdFailure);
    85b0:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    85b4:	b0 12 5a ac 	call	#-21414	;#0xac5a

000085b8 <.L470>:
    elyNLFreeBuffer(elyNLPack(buffer));
    85b8:	0c 48       	mov	r8,	r12	;
    85ba:	b0 12 32 ab 	call	#-21710	;#0xab32

000085be <.LVL687>:
    85be:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

000085c2 <.LVL688>:
    85c2:	f1 3f       	jmp	$-28     	;abs 0x85a6

000085c4 <.L466>:
  bank0w[RegTXDevMsb] = buffer[hdr_ext];
    85c4:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    85c8:	ec 49 0b 00 	mov.b	@r9,	11(r12)	; 0x000b

000085cc <.Loc.589.2>:
  bank0w[RegTXDevHmb] = buffer[hdr_ext+1];
    85cc:	dc 49 01 00 	mov.b	1(r9),	10(r12)	; 0x000a
    85d0:	0a 00 

000085d2 <.Loc.590.2>:
  bank0w[RegTXDevLmb] = buffer[hdr_ext+2];
    85d2:	dc 49 02 00 	mov.b	2(r9),	9(r12)	;
    85d6:	09 00 

000085d8 <.Loc.591.2>:
  bank0w[RegTXDevLsb] = buffer[hdr_ext+3];
    85d8:	dc 49 03 00 	mov.b	3(r9),	8(r12)	;
    85dc:	08 00 

000085de <.Loc.594.2>:
  elyRFCfgMarkDirty(RFTxDevUpdated);
    85de:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    85e2:	4d 43       	clr.b	r13		;
    85e4:	b0 12 90 a2 	call	#-23920	;#0xa290

000085e8 <.LVL691>:
  if (hdr.reply) {
    85e8:	07 93       	cmp	#0,	r7	;r3 As==00
    85ea:	e6 27       	jz	$-50     	;abs 0x85b8

000085ec <.Loc.598.2>:
    gen_success(buffer, hdr.crc);
    85ec:	4d 46       	mov.b	r6,	r13	;
    85ee:	0c 48       	mov	r8,	r12	;
    85f0:	b0 12 28 6e 	call	#28200		;#0x6e28

000085f4 <.LVL692>:
    85f4:	d5 3f       	jmp	$-84     	;abs 0x85a0

000085f6 <get_tx_dev>:
    85f6:	0a 15       	pushm	#1,	r10	;16-bit words

000085f8 <.LCFI74>:
static void get_tx_dev(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    85f8:	21 83       	decd	r1		;

000085fa <.LCFI75>:
    85fa:	0a 4c       	mov	r12,	r10	;

000085fc <L0>:
    85fc:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8600:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8604:	01 00 

00008606 <.Loc.540.2>:
  if (hdr.reply) {
    8606:	6f 41       	mov.b	@r1,	r15	;
    8608:	2f b3       	bit	#2,	r15	;r3 As==10
    860a:	2b 24       	jz	$+88     	;abs 0x8662

0000860c <.Loc.541.2>:
    buffer[0] = buffer[0] & 0x3F;
    860c:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8610:	00 00 

00008612 <.Loc.542.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8612:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

00008616 <.LVL694>:
    8616:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    861a:	02 00 

0000861c <.Loc.543.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    861c:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8620:	03 00 

00008622 <.LVL695>:
    8622:	0d 4c       	mov	r12,	r13	;
    8624:	3d 50 0b 00 	add	#11,	r13	;#0x000b
    8628:	0e 4a       	mov	r10,	r14	;
    862a:	2e 52       	add	#4,	r14	;r2 As==10
    862c:	3c 50 07 00 	add	#7,	r12	;

00008630 <.L477>:
      buffer[i + 4] = bank0p[RegTXDevMsb - i];
    8630:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

00008634 <.LVL697>:
    8634:	3d 53       	add	#-1,	r13	;r3 As==11
    8636:	1e 53       	inc	r14		;

00008638 <.LVL698>:
    for (int i = 0; i < 4; i++) {
    8638:	0d 9c       	cmp	r12,	r13	;
    863a:	fa 23       	jnz	$-10     	;abs 0x8630

0000863c <.LBE104>:
    if (hdr.crc) {
    863c:	1f b3       	bit	#1,	r15	;r3 As==01
    863e:	0e 24       	jz	$+30     	;abs 0x865c

00008640 <.Loc.549.2>:
      buffer[1] = 6;
    8640:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8644:	01 00 

00008646 <.Loc.550.2>:
      crcGenX25(buffer, 10);
    8646:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    864a:	0c 4a       	mov	r10,	r12	;
    864c:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008650 <.L479>:
    elyCmdSendReply(buffer);
    8650:	0c 4a       	mov	r10,	r12	;
    8652:	b0 12 52 74 	call	#29778		;#0x7452

00008656 <.L475>:
}
    8656:	21 53       	incd	r1		;
    8658:	0a 17       	popm	#1,	r10	;16-bit words
    865a:	30 41       	ret			

0000865c <.L478>:
      buffer[1] = 4;
    865c:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8660:	f7 3f       	jmp	$-16     	;abs 0x8650

00008662 <.L476>:
    8662:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00008666 <.LVL703>:
}
    8666:	f7 3f       	jmp	$-16     	;abs 0x8656

00008668 <set_rx_br>:
    8668:	6a 15       	pushm	#7,	r10	;16-bit words

0000866a <.LCFI76>:
static void set_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    866a:	21 82       	sub	#4,	r1	;r2 As==10

0000866c <L0>:
    866c:	08 4c       	mov	r12,	r8	;

0000866e <.LVL705>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    866e:	66 4d       	mov.b	@r13,	r6	;
    8670:	56 f3       	and.b	#1,	r6	;r3 As==01
    8672:	67 4d       	mov.b	@r13,	r7	;
    8674:	67 f3       	and.b	#2,	r7	;r3 As==10
    8676:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    867a:	07 93       	cmp	#0,	r7	;r3 As==00
    867c:	32 20       	jnz	$+102    	;abs 0x86e2
    867e:	69 43       	mov.b	#2,	r9	;r3 As==10

00008680 <.L483>:
    8680:	09 58       	add	r8,	r9	;
    8682:	0b 49       	mov	r9,	r11	;

00008684 <.Loc.495.2>:
    8684:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

00008688 <.Loc.496.2>:
  uint32_t br = 0;
    8688:	45 43       	clr.b	r5		;
    868a:	0a 45       	mov	r5,	r10	;

0000868c <.L484>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    868c:	6c 4b       	mov.b	@r11,	r12	;
    868e:	0d 43       	clr	r13		;
    8690:	0e 44       	mov	r4,	r14	;
    8692:	0f 43       	clr	r15		;
    8694:	81 4b 00 00 	mov	r11,	0(r1)	;
    8698:	b0 12 de af 	call	#-20514	;#0xafde
    869c:	0c d5       	bis	r5,	r12	;
    869e:	0d da       	bis	r10,	r13	;
    86a0:	05 4c       	mov	r12,	r5	;

000086a2 <.LVL709>:
    86a2:	0a 4d       	mov	r13,	r10	;

000086a4 <.LVL710>:
    86a4:	2b 41       	mov	@r1,	r11	;
    86a6:	1b 53       	inc	r11		;
    86a8:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

000086ac <.Loc.499.2>:
  for (int i = 0; i < 4; i++) {
    86ac:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    86b0:	ed 23       	jnz	$-36     	;abs 0x868c

000086b2 <.LBE105>:
  if (br > RX_BR_MAX || 
    86b2:	35 50 f4 fc 	add	#-780,	r5	;#0xfcf4

000086b6 <.LVL711>:
    86b6:	3a 63       	addc	#-1,	r10	;r3 As==11

000086b8 <.LVL712>:
    86b8:	6c 43       	mov.b	#2,	r12	;r3 As==10

000086ba <.LVL713>:
    86ba:	0c 9a       	cmp	r10,	r12	;
    86bc:	06 28       	jnc	$+14     	;abs 0x86ca
    86be:	0a 9c       	cmp	r12,	r10	;
    86c0:	1c 20       	jnz	$+58     	;abs 0x86fa
    86c2:	3c 40 e4 46 	mov	#18148,	r12	;#0x46e4
    86c6:	0c 95       	cmp	r5,	r12	;
    86c8:	18 2c       	jc	$+50     	;abs 0x86fa

000086ca <.L491>:
    if (hdr.reply) {
    86ca:	07 93       	cmp	#0,	r7	;r3 As==00
    86cc:	0c 24       	jz	$+26     	;abs 0x86e6

000086ce <.Loc.507.2>:
      gen_failure(buffer, hdr.crc);
    86ce:	4d 46       	mov.b	r6,	r13	;
    86d0:	0c 48       	mov	r8,	r12	;
    86d2:	b0 12 7a 6e 	call	#28282		;#0x6e7a

000086d6 <.L493>:
    elyCmdSendReply(buffer);
    86d6:	0c 48       	mov	r8,	r12	;
    86d8:	b0 12 52 74 	call	#29778		;#0x7452

000086dc <.L482>:
}
    86dc:	21 52       	add	#4,	r1	;r2 As==10
    86de:	64 17       	popm	#7,	r10	;16-bit words
    86e0:	30 41       	ret			

000086e2 <.L490>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    86e2:	69 42       	mov.b	#4,	r9	;r2 As==10
    86e4:	cd 3f       	jmp	$-100    	;abs 0x8680

000086e6 <.L487>:
      elyErrorSignal(ErrCmdFailure);
    86e6:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    86ea:	b0 12 5a ac 	call	#-21414	;#0xac5a

000086ee <.L489>:
    elyNLFreeBuffer(elyNLPack(buffer));
    86ee:	0c 48       	mov	r8,	r12	;
    86f0:	b0 12 32 ab 	call	#-21710	;#0xab32

000086f4 <.LVL720>:
    86f4:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

000086f8 <.LVL721>:
    86f8:	f1 3f       	jmp	$-28     	;abs 0x86dc

000086fa <.L485>:
  bank0w[RegRXBRMsb] = buffer[hdr_ext];
    86fa:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    86fe:	ec 49 1f 00 	mov.b	@r9,	31(r12)	; 0x001f

00008702 <.Loc.519.2>:
  bank0w[RegRXBRHmb] = buffer[hdr_ext+1];
    8702:	dc 49 01 00 	mov.b	1(r9),	30(r12)	; 0x001e
    8706:	1e 00 

00008708 <.Loc.520.2>:
  bank0w[RegRXBRLmb] = buffer[hdr_ext+2];
    8708:	dc 49 02 00 	mov.b	2(r9),	29(r12)	; 0x001d
    870c:	1d 00 

0000870e <.Loc.521.2>:
  bank0w[RegRXBRLsb] = buffer[hdr_ext+3];
    870e:	dc 49 03 00 	mov.b	3(r9),	28(r12)	; 0x001c
    8712:	1c 00 

00008714 <.Loc.524.2>:
  elyRFCfgMarkDirty(RFRxBRUpdated);
    8714:	7c 42       	mov.b	#8,	r12	;r2 As==11
    8716:	4d 43       	clr.b	r13		;
    8718:	b0 12 90 a2 	call	#-23920	;#0xa290

0000871c <.LVL724>:
  if (hdr.reply) {
    871c:	07 93       	cmp	#0,	r7	;r3 As==00
    871e:	e7 27       	jz	$-48     	;abs 0x86ee

00008720 <.Loc.528.2>:
    gen_success(buffer, hdr.crc);
    8720:	4d 46       	mov.b	r6,	r13	;
    8722:	0c 48       	mov	r8,	r12	;
    8724:	b0 12 28 6e 	call	#28200		;#0x6e28

00008728 <.LVL725>:
    8728:	d6 3f       	jmp	$-82     	;abs 0x86d6

0000872a <get_rx_br>:
    872a:	0a 15       	pushm	#1,	r10	;16-bit words

0000872c <.LCFI78>:
static void get_rx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    872c:	21 83       	decd	r1		;

0000872e <.LCFI79>:
    872e:	0a 4c       	mov	r12,	r10	;

00008730 <L0>:
    8730:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8734:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8738:	01 00 

0000873a <.Loc.470.2>:
  if (hdr.reply) {
    873a:	6f 41       	mov.b	@r1,	r15	;
    873c:	2f b3       	bit	#2,	r15	;r3 As==10
    873e:	2b 24       	jz	$+88     	;abs 0x8796

00008740 <.Loc.471.2>:
    buffer[0] = buffer[0] & 0x3F;
    8740:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8744:	00 00 

00008746 <.Loc.472.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8746:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

0000874a <.LVL727>:
    874a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    874e:	02 00 

00008750 <.Loc.473.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8750:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8754:	03 00 

00008756 <.LVL728>:
    8756:	0d 4c       	mov	r12,	r13	;
    8758:	3d 50 1f 00 	add	#31,	r13	;#0x001f
    875c:	0e 4a       	mov	r10,	r14	;
    875e:	2e 52       	add	#4,	r14	;r2 As==10
    8760:	3c 50 1b 00 	add	#27,	r12	;#0x001b

00008764 <.L496>:
      buffer[i + 4] = bank0p[RegRXBRMsb - i];
    8764:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

00008768 <.LVL730>:
    8768:	3d 53       	add	#-1,	r13	;r3 As==11
    876a:	1e 53       	inc	r14		;

0000876c <.LVL731>:
    for (int i = 0; i < 4; i++) {
    876c:	0d 9c       	cmp	r12,	r13	;
    876e:	fa 23       	jnz	$-10     	;abs 0x8764

00008770 <.LBE106>:
    if (hdr.crc) {
    8770:	1f b3       	bit	#1,	r15	;r3 As==01
    8772:	0e 24       	jz	$+30     	;abs 0x8790

00008774 <.Loc.479.2>:
      buffer[1] = 6;
    8774:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8778:	01 00 

0000877a <.Loc.480.2>:
      crcGenX25(buffer, 10);
    877a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    877e:	0c 4a       	mov	r10,	r12	;
    8780:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008784 <.L498>:
    elyCmdSendReply(buffer);
    8784:	0c 4a       	mov	r10,	r12	;
    8786:	b0 12 52 74 	call	#29778		;#0x7452

0000878a <.L494>:
}
    878a:	21 53       	incd	r1		;
    878c:	0a 17       	popm	#1,	r10	;16-bit words
    878e:	30 41       	ret			

00008790 <.L497>:
      buffer[1] = 4;
    8790:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8794:	f7 3f       	jmp	$-16     	;abs 0x8784

00008796 <.L495>:
    8796:	b0 12 e4 6f 	call	#28644		;#0x6fe4

0000879a <.LVL736>:
}
    879a:	f7 3f       	jmp	$-16     	;abs 0x878a

0000879c <set_tx_br>:
    879c:	6a 15       	pushm	#7,	r10	;16-bit words

0000879e <.LCFI80>:
static void set_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    879e:	21 82       	sub	#4,	r1	;r2 As==10

000087a0 <L0>:
    87a0:	08 4c       	mov	r12,	r8	;

000087a2 <.LVL738>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    87a2:	66 4d       	mov.b	@r13,	r6	;
    87a4:	56 f3       	and.b	#1,	r6	;r3 As==01
    87a6:	67 4d       	mov.b	@r13,	r7	;
    87a8:	67 f3       	and.b	#2,	r7	;r3 As==10
    87aa:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    87ae:	07 93       	cmp	#0,	r7	;r3 As==00
    87b0:	32 20       	jnz	$+102    	;abs 0x8816
    87b2:	69 43       	mov.b	#2,	r9	;r3 As==10

000087b4 <.L502>:
    87b4:	09 58       	add	r8,	r9	;
    87b6:	0b 49       	mov	r9,	r11	;

000087b8 <.Loc.425.2>:
    87b8:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

000087bc <.Loc.426.2>:
  uint32_t br = 0;
    87bc:	45 43       	clr.b	r5		;
    87be:	0a 45       	mov	r5,	r10	;

000087c0 <.L503>:
    br |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    87c0:	6c 4b       	mov.b	@r11,	r12	;
    87c2:	0d 43       	clr	r13		;
    87c4:	0e 44       	mov	r4,	r14	;
    87c6:	0f 43       	clr	r15		;
    87c8:	81 4b 00 00 	mov	r11,	0(r1)	;
    87cc:	b0 12 de af 	call	#-20514	;#0xafde
    87d0:	0c d5       	bis	r5,	r12	;
    87d2:	0d da       	bis	r10,	r13	;
    87d4:	05 4c       	mov	r12,	r5	;

000087d6 <.LVL742>:
    87d6:	0a 4d       	mov	r13,	r10	;

000087d8 <.LVL743>:
    87d8:	2b 41       	mov	@r1,	r11	;
    87da:	1b 53       	inc	r11		;
    87dc:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

000087e0 <.Loc.429.2>:
  for (int i = 0; i < 4; i++) {
    87e0:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    87e4:	ed 23       	jnz	$-36     	;abs 0x87c0

000087e6 <.LBE107>:
  if (br > TX_BR_MAX || 
    87e6:	35 50 50 fb 	add	#-1200,	r5	;#0xfb50

000087ea <.LVL744>:
    87ea:	3a 63       	addc	#-1,	r10	;r3 As==11

000087ec <.LVL745>:
    87ec:	6c 42       	mov.b	#4,	r12	;r2 As==10

000087ee <.LVL746>:
    87ee:	0c 9a       	cmp	r10,	r12	;
    87f0:	06 28       	jnc	$+14     	;abs 0x87fe
    87f2:	0a 9c       	cmp	r12,	r10	;
    87f4:	1c 20       	jnz	$+58     	;abs 0x882e
    87f6:	3c 40 30 8f 	mov	#-28880,r12	;#0x8f30
    87fa:	0c 95       	cmp	r5,	r12	;
    87fc:	18 2c       	jc	$+50     	;abs 0x882e

000087fe <.L510>:
    if (hdr.reply) {
    87fe:	07 93       	cmp	#0,	r7	;r3 As==00
    8800:	0c 24       	jz	$+26     	;abs 0x881a

00008802 <.Loc.437.2>:
      gen_failure(buffer, hdr.crc);
    8802:	4d 46       	mov.b	r6,	r13	;
    8804:	0c 48       	mov	r8,	r12	;
    8806:	b0 12 7a 6e 	call	#28282		;#0x6e7a

0000880a <.L512>:
    elyCmdSendReply(buffer);
    880a:	0c 48       	mov	r8,	r12	;
    880c:	b0 12 52 74 	call	#29778		;#0x7452

00008810 <.L501>:
}
    8810:	21 52       	add	#4,	r1	;r2 As==10
    8812:	64 17       	popm	#7,	r10	;16-bit words
    8814:	30 41       	ret			

00008816 <.L509>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8816:	69 42       	mov.b	#4,	r9	;r2 As==10
    8818:	cd 3f       	jmp	$-100    	;abs 0x87b4

0000881a <.L506>:
      elyErrorSignal(ErrCmdFailure);
    881a:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    881e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008822 <.L508>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8822:	0c 48       	mov	r8,	r12	;
    8824:	b0 12 32 ab 	call	#-21710	;#0xab32

00008828 <.LVL753>:
    8828:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000882c <.LVL754>:
    882c:	f1 3f       	jmp	$-28     	;abs 0x8810

0000882e <.L504>:
  bank0w[RegTXBRMsb] = buffer[hdr_ext];
    882e:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    8832:	ec 49 1b 00 	mov.b	@r9,	27(r12)	; 0x001b

00008836 <.Loc.449.2>:
  bank0w[RegTXBRHmb] = buffer[hdr_ext+1];
    8836:	dc 49 01 00 	mov.b	1(r9),	26(r12)	; 0x001a
    883a:	1a 00 

0000883c <.Loc.450.2>:
  bank0w[RegTXBRLmb] = buffer[hdr_ext+2];
    883c:	dc 49 02 00 	mov.b	2(r9),	25(r12)	; 0x0019
    8840:	19 00 

00008842 <.Loc.451.2>:
  bank0w[RegTXBRLsb] = buffer[hdr_ext+3];
    8842:	dc 49 03 00 	mov.b	3(r9),	24(r12)	; 0x0018
    8846:	18 00 

00008848 <.Loc.454.2>:
  elyRFCfgMarkDirty(RFTxBRUpdated);
    8848:	6c 42       	mov.b	#4,	r12	;r2 As==10
    884a:	4d 43       	clr.b	r13		;
    884c:	b0 12 90 a2 	call	#-23920	;#0xa290

00008850 <.LVL757>:
  if (hdr.reply) {
    8850:	07 93       	cmp	#0,	r7	;r3 As==00
    8852:	e7 27       	jz	$-48     	;abs 0x8822

00008854 <.Loc.458.2>:
    gen_success(buffer, hdr.crc);
    8854:	4d 46       	mov.b	r6,	r13	;
    8856:	0c 48       	mov	r8,	r12	;
    8858:	b0 12 28 6e 	call	#28200		;#0x6e28

0000885c <.LVL758>:
    885c:	d6 3f       	jmp	$-82     	;abs 0x880a

0000885e <get_tx_br>:
    885e:	0a 15       	pushm	#1,	r10	;16-bit words

00008860 <.LCFI82>:
static void get_tx_br(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8860:	21 83       	decd	r1		;

00008862 <.LCFI83>:
    8862:	0a 4c       	mov	r12,	r10	;

00008864 <L0>:
    8864:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    8868:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    886c:	01 00 

0000886e <.Loc.400.2>:
  if (hdr.reply) {
    886e:	6f 41       	mov.b	@r1,	r15	;
    8870:	2f b3       	bit	#2,	r15	;r3 As==10
    8872:	2b 24       	jz	$+88     	;abs 0x88ca

00008874 <.Loc.401.2>:
    buffer[0] = buffer[0] & 0x3F;
    8874:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8878:	00 00 

0000887a <.Loc.402.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    887a:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

0000887e <.LVL760>:
    887e:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8882:	02 00 

00008884 <.Loc.403.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8884:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8888:	03 00 

0000888a <.LVL761>:
    888a:	0d 4c       	mov	r12,	r13	;
    888c:	3d 50 1b 00 	add	#27,	r13	;#0x001b
    8890:	0e 4a       	mov	r10,	r14	;
    8892:	2e 52       	add	#4,	r14	;r2 As==10
    8894:	3c 50 17 00 	add	#23,	r12	;#0x0017

00008898 <.L515>:
      buffer[i + 4] = bank0p[RegTXBRMsb - i];
    8898:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

0000889c <.LVL763>:
    889c:	3d 53       	add	#-1,	r13	;r3 As==11
    889e:	1e 53       	inc	r14		;

000088a0 <.LVL764>:
    for (int i = 0; i < 4; i++) {
    88a0:	0d 9c       	cmp	r12,	r13	;
    88a2:	fa 23       	jnz	$-10     	;abs 0x8898

000088a4 <.LBE108>:
    if (hdr.crc) {
    88a4:	1f b3       	bit	#1,	r15	;r3 As==01
    88a6:	0e 24       	jz	$+30     	;abs 0x88c4

000088a8 <.Loc.409.2>:
      buffer[1] = 6;
    88a8:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    88ac:	01 00 

000088ae <.Loc.410.2>:
      crcGenX25(buffer, 10);
    88ae:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    88b2:	0c 4a       	mov	r10,	r12	;
    88b4:	b0 12 26 9b 	call	#-25818	;#0x9b26

000088b8 <.L517>:
    elyCmdSendReply(buffer);
    88b8:	0c 4a       	mov	r10,	r12	;
    88ba:	b0 12 52 74 	call	#29778		;#0x7452

000088be <.L513>:
}
    88be:	21 53       	incd	r1		;
    88c0:	0a 17       	popm	#1,	r10	;16-bit words
    88c2:	30 41       	ret			

000088c4 <.L516>:
      buffer[1] = 4;
    88c4:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    88c8:	f7 3f       	jmp	$-16     	;abs 0x88b8

000088ca <.L514>:
    88ca:	b0 12 e4 6f 	call	#28644		;#0x6fe4

000088ce <.LVL769>:
}
    88ce:	f7 3f       	jmp	$-16     	;abs 0x88be

000088d0 <set_rx_freq>:
    88d0:	6a 15       	pushm	#7,	r10	;16-bit words

000088d2 <.LCFI84>:
static void set_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    88d2:	21 82       	sub	#4,	r1	;r2 As==10

000088d4 <L0>:
    88d4:	08 4c       	mov	r12,	r8	;

000088d6 <.LVL771>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    88d6:	66 4d       	mov.b	@r13,	r6	;
    88d8:	56 f3       	and.b	#1,	r6	;r3 As==01
    88da:	67 4d       	mov.b	@r13,	r7	;
    88dc:	67 f3       	and.b	#2,	r7	;r3 As==10
    88de:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    88e2:	07 93       	cmp	#0,	r7	;r3 As==00
    88e4:	34 20       	jnz	$+106    	;abs 0x894e
    88e6:	69 43       	mov.b	#2,	r9	;r3 As==10

000088e8 <.L521>:
    88e8:	09 58       	add	r8,	r9	;
    88ea:	0b 49       	mov	r9,	r11	;

000088ec <.Loc.355.2>:
    88ec:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

000088f0 <.Loc.356.2>:
  uint32_t freq = 0;
    88f0:	45 43       	clr.b	r5		;
    88f2:	0a 45       	mov	r5,	r10	;

000088f4 <.L522>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    88f4:	6c 4b       	mov.b	@r11,	r12	;
    88f6:	0d 43       	clr	r13		;
    88f8:	0e 44       	mov	r4,	r14	;
    88fa:	0f 43       	clr	r15		;
    88fc:	81 4b 00 00 	mov	r11,	0(r1)	;
    8900:	b0 12 de af 	call	#-20514	;#0xafde
    8904:	0c d5       	bis	r5,	r12	;
    8906:	0d da       	bis	r10,	r13	;
    8908:	05 4c       	mov	r12,	r5	;

0000890a <.LVL775>:
    890a:	0a 4d       	mov	r13,	r10	;

0000890c <.LVL776>:
    890c:	2b 41       	mov	@r1,	r11	;
    890e:	1b 53       	inc	r11		;
    8910:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

00008914 <.Loc.359.2>:
  for (int i = 0; i < 4; i++) {
    8914:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    8918:	ed 23       	jnz	$-36     	;abs 0x88f4

0000891a <.LBE109>:
  if (freq > RX_BAND_MAX || 
    891a:	35 50 20 d5 	add	#-10976,r5	;#0xd520

0000891e <.LVL777>:
    891e:	3a 60 47 e6 	addc	#-6585,	r10	;#0xe647

00008922 <.LVL778>:
    8922:	7c 40 4c 00 	mov.b	#76,	r12	;#0x004c

00008926 <.LVL779>:
    8926:	0c 9a       	cmp	r10,	r12	;
    8928:	06 28       	jnc	$+14     	;abs 0x8936
    892a:	0a 9c       	cmp	r12,	r10	;
    892c:	1c 20       	jnz	$+58     	;abs 0x8966
    892e:	3c 40 40 4b 	mov	#19264,	r12	;#0x4b40
    8932:	0c 95       	cmp	r5,	r12	;
    8934:	18 2c       	jc	$+50     	;abs 0x8966

00008936 <.L529>:
    if (hdr.reply) {
    8936:	07 93       	cmp	#0,	r7	;r3 As==00
    8938:	0c 24       	jz	$+26     	;abs 0x8952

0000893a <.Loc.367.2>:
      gen_failure(buffer, hdr.crc);
    893a:	4d 46       	mov.b	r6,	r13	;
    893c:	0c 48       	mov	r8,	r12	;
    893e:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008942 <.L531>:
    elyCmdSendReply(buffer);
    8942:	0c 48       	mov	r8,	r12	;
    8944:	b0 12 52 74 	call	#29778		;#0x7452

00008948 <.L520>:
}
    8948:	21 52       	add	#4,	r1	;r2 As==10
    894a:	64 17       	popm	#7,	r10	;16-bit words
    894c:	30 41       	ret			

0000894e <.L528>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    894e:	69 42       	mov.b	#4,	r9	;r2 As==10
    8950:	cb 3f       	jmp	$-104    	;abs 0x88e8

00008952 <.L525>:
      elyErrorSignal(ErrCmdFailure);
    8952:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8956:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000895a <.L527>:
    elyNLFreeBuffer(elyNLPack(buffer));
    895a:	0c 48       	mov	r8,	r12	;
    895c:	b0 12 32 ab 	call	#-21710	;#0xab32

00008960 <.LVL786>:
    8960:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008964 <.LVL787>:
    8964:	f1 3f       	jmp	$-28     	;abs 0x8948

00008966 <.L523>:
  bank0w[RegRXFreqMsb] = buffer[hdr_ext];
    8966:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    896a:	ec 49 07 00 	mov.b	@r9,	7(r12)	;

0000896e <.Loc.379.2>:
  bank0w[RegRXFreqHmb] = buffer[hdr_ext+1];
    896e:	dc 49 01 00 	mov.b	1(r9),	6(r12)	;
    8972:	06 00 

00008974 <.Loc.380.2>:
  bank0w[RegRXFreqLmb] = buffer[hdr_ext+2];
    8974:	dc 49 02 00 	mov.b	2(r9),	5(r12)	;
    8978:	05 00 

0000897a <.Loc.381.2>:
  bank0w[RegRXFreqLsb] = buffer[hdr_ext+3];
    897a:	dc 49 03 00 	mov.b	3(r9),	4(r12)	;
    897e:	04 00 

00008980 <.Loc.384.2>:
  elyRFCfgMarkDirty(RFRxFreqUpdated);
    8980:	6c 43       	mov.b	#2,	r12	;r3 As==10
    8982:	4d 43       	clr.b	r13		;
    8984:	b0 12 90 a2 	call	#-23920	;#0xa290

00008988 <.LVL790>:
  if (hdr.reply) {
    8988:	07 93       	cmp	#0,	r7	;r3 As==00
    898a:	e7 27       	jz	$-48     	;abs 0x895a

0000898c <.Loc.388.2>:
    gen_success(buffer, hdr.crc);
    898c:	4d 46       	mov.b	r6,	r13	;
    898e:	0c 48       	mov	r8,	r12	;
    8990:	b0 12 28 6e 	call	#28200		;#0x6e28

00008994 <.LVL791>:
    8994:	d6 3f       	jmp	$-82     	;abs 0x8942

00008996 <get_rx_freq>:
    8996:	0a 15       	pushm	#1,	r10	;16-bit words

00008998 <.LCFI86>:
static void get_rx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8998:	21 83       	decd	r1		;

0000899a <.LCFI87>:
    899a:	0a 4c       	mov	r12,	r10	;

0000899c <L0>:
    899c:	e1 4d 00 00 	mov.b	@r13,	0(r1)	;
    89a0:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    89a4:	01 00 

000089a6 <.Loc.330.2>:
  if (hdr.reply) {
    89a6:	6f 41       	mov.b	@r1,	r15	;
    89a8:	2f b3       	bit	#2,	r15	;r3 As==10
    89aa:	2b 24       	jz	$+88     	;abs 0x8a02

000089ac <.Loc.331.2>:
    buffer[0] = buffer[0] & 0x3F;
    89ac:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    89b0:	00 00 

000089b2 <.Loc.332.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    89b2:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

000089b6 <.LVL793>:
    89b6:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    89ba:	02 00 

000089bc <.Loc.333.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    89bc:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    89c0:	03 00 

000089c2 <.LVL794>:
    89c2:	0d 4c       	mov	r12,	r13	;
    89c4:	3d 50 07 00 	add	#7,	r13	;
    89c8:	0e 4a       	mov	r10,	r14	;
    89ca:	2e 52       	add	#4,	r14	;r2 As==10
    89cc:	3c 50 03 00 	add	#3,	r12	;

000089d0 <.L534>:
      buffer[i + 4] = bank0p[RegRXFreqMsb - i];
    89d0:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;

000089d4 <.LVL796>:
    89d4:	3d 53       	add	#-1,	r13	;r3 As==11
    89d6:	1e 53       	inc	r14		;

000089d8 <.LVL797>:
    for (int i = 0; i < 4; i++) {
    89d8:	0d 9c       	cmp	r12,	r13	;
    89da:	fa 23       	jnz	$-10     	;abs 0x89d0

000089dc <.LBE110>:
    if (hdr.crc) {
    89dc:	1f b3       	bit	#1,	r15	;r3 As==01
    89de:	0e 24       	jz	$+30     	;abs 0x89fc

000089e0 <.Loc.339.2>:
      buffer[1] = 6;
    89e0:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    89e4:	01 00 

000089e6 <.Loc.340.2>:
      crcGenX25(buffer, 10);
    89e6:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a
    89ea:	0c 4a       	mov	r10,	r12	;
    89ec:	b0 12 26 9b 	call	#-25818	;#0x9b26

000089f0 <.L536>:
    elyCmdSendReply(buffer);
    89f0:	0c 4a       	mov	r10,	r12	;
    89f2:	b0 12 52 74 	call	#29778		;#0x7452

000089f6 <.L532>:
}
    89f6:	21 53       	incd	r1		;
    89f8:	0a 17       	popm	#1,	r10	;16-bit words
    89fa:	30 41       	ret			

000089fc <.L535>:
      buffer[1] = 4;
    89fc:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8a00:	f7 3f       	jmp	$-16     	;abs 0x89f0

00008a02 <.L533>:
    8a02:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00008a06 <.LVL802>:
}
    8a06:	f7 3f       	jmp	$-16     	;abs 0x89f6

00008a08 <set_tx_freq>:
    8a08:	6a 15       	pushm	#7,	r10	;16-bit words

00008a0a <.LCFI88>:
static void set_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8a0a:	21 82       	sub	#4,	r1	;r2 As==10

00008a0c <L0>:
    8a0c:	08 4c       	mov	r12,	r8	;

00008a0e <.LVL804>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a0e:	66 4d       	mov.b	@r13,	r6	;
    8a10:	56 f3       	and.b	#1,	r6	;r3 As==01
    8a12:	67 4d       	mov.b	@r13,	r7	;
    8a14:	67 f3       	and.b	#2,	r7	;r3 As==10
    8a16:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    8a1a:	07 93       	cmp	#0,	r7	;r3 As==00
    8a1c:	32 20       	jnz	$+102    	;abs 0x8a82
    8a1e:	69 43       	mov.b	#2,	r9	;r3 As==10

00008a20 <.L540>:
    8a20:	09 58       	add	r8,	r9	;
    8a22:	0b 49       	mov	r9,	r11	;

00008a24 <.Loc.282.2>:
    8a24:	74 40 18 00 	mov.b	#24,	r4	;#0x0018

00008a28 <.Loc.283.2>:
  uint32_t freq = 0;
    8a28:	45 43       	clr.b	r5		;
    8a2a:	0a 45       	mov	r5,	r10	;

00008a2c <.L541>:
    freq |= ((uint32_t)(buffer[hdr_ext + i]) << (8 * (3-i)));
    8a2c:	6c 4b       	mov.b	@r11,	r12	;
    8a2e:	0d 43       	clr	r13		;
    8a30:	0e 44       	mov	r4,	r14	;
    8a32:	0f 43       	clr	r15		;
    8a34:	81 4b 00 00 	mov	r11,	0(r1)	;
    8a38:	b0 12 de af 	call	#-20514	;#0xafde
    8a3c:	0c d5       	bis	r5,	r12	;
    8a3e:	0d da       	bis	r10,	r13	;
    8a40:	05 4c       	mov	r12,	r5	;

00008a42 <.LVL808>:
    8a42:	0a 4d       	mov	r13,	r10	;

00008a44 <.LVL809>:
    8a44:	2b 41       	mov	@r1,	r11	;
    8a46:	1b 53       	inc	r11		;
    8a48:	34 50 f8 ff 	add	#-8,	r4	;#0xfff8

00008a4c <.Loc.286.2>:
  for (int i = 0; i < 4; i++) {
    8a4c:	34 90 f8 ff 	cmp	#-8,	r4	;#0xfff8
    8a50:	ed 23       	jnz	$-36     	;abs 0x8a2c

00008a52 <.LBE111>:
  if (freq > TX_BAND_MAX || 
    8a52:	35 50 c0 f1 	add	#-3648,	r5	;#0xf1c0

00008a56 <.LVL810>:
    8a56:	3a 60 30 e6 	addc	#-6608,	r10	;#0xe630

00008a5a <.LVL811>:
    8a5a:	3c 40 34 02 	mov	#564,	r12	;#0x0234

00008a5e <.LVL812>:
    8a5e:	0c 9a       	cmp	r10,	r12	;
    8a60:	06 28       	jnc	$+14     	;abs 0x8a6e
    8a62:	0a 9c       	cmp	r12,	r10	;
    8a64:	1c 20       	jnz	$+58     	;abs 0x8a9e
    8a66:	3c 40 40 93 	mov	#-27840,r12	;#0x9340
    8a6a:	0c 95       	cmp	r5,	r12	;
    8a6c:	18 2c       	jc	$+50     	;abs 0x8a9e

00008a6e <.L548>:
    if (hdr.reply) {
    8a6e:	07 93       	cmp	#0,	r7	;r3 As==00
    8a70:	0a 24       	jz	$+22     	;abs 0x8a86

00008a72 <.Loc.294.2>:
      gen_failure(buffer, hdr.crc);
    8a72:	4d 46       	mov.b	r6,	r13	;
    8a74:	0c 48       	mov	r8,	r12	;
    8a76:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008a7a <.L550>:
    elyCmdSendReply(buffer);
    8a7a:	0c 48       	mov	r8,	r12	;
    8a7c:	b0 12 52 74 	call	#29778		;#0x7452

00008a80 <.LVL815>:
    8a80:	0b 3c       	jmp	$+24     	;abs 0x8a98

00008a82 <.L547>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8a82:	69 42       	mov.b	#4,	r9	;r2 As==10
    8a84:	cd 3f       	jmp	$-100    	;abs 0x8a20

00008a86 <.L544>:
      elyNLFreeBuffer(elyNLPack(buffer));
    8a86:	0c 48       	mov	r8,	r12	;
    8a88:	b0 12 32 ab 	call	#-21710	;#0xab32

00008a8c <.LVL818>:
    8a8c:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008a90 <.LVL819>:
      elyErrorSignal(ErrCmdFailure);
    8a90:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8a94:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008a98 <.L539>:
}
    8a98:	21 52       	add	#4,	r1	;r2 As==10
    8a9a:	64 17       	popm	#7,	r10	;16-bit words
    8a9c:	30 41       	ret			

00008a9e <.L542>:
  bank0w[RegTXFreqMsb] = buffer[hdr_ext];
    8a9e:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    8aa2:	ec 49 03 00 	mov.b	@r9,	3(r12)	;

00008aa6 <.Loc.306.2>:
  bank0w[RegTXFreqHmb] = buffer[hdr_ext+1];
    8aa6:	dc 49 01 00 	mov.b	1(r9),	2(r12)	;
    8aaa:	02 00 

00008aac <.Loc.307.2>:
  bank0w[RegTXFreqLmb] = buffer[hdr_ext+2];
    8aac:	dc 49 02 00 	mov.b	2(r9),	1(r12)	;
    8ab0:	01 00 

00008ab2 <.Loc.308.2>:
  bank0w[RegTXFreqLsb] = buffer[hdr_ext+3];
    8ab2:	dc 49 03 00 	mov.b	3(r9),	0(r12)	;
    8ab6:	00 00 

00008ab8 <.Loc.311.2>:
  elyRFCfgMarkDirty(RFTxFreqUpdated);
    8ab8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8aba:	4d 43       	clr.b	r13		;
    8abc:	b0 12 90 a2 	call	#-23920	;#0xa290

00008ac0 <.LVL823>:
  elyEventSignal(EvtTXFreqChange);
    8ac0:	7c 40 c5 ff 	mov.b	#-59,	r12	;#0xffc5
    8ac4:	b0 12 70 ac 	call	#-21392	;#0xac70

00008ac8 <.LVL824>:
  if (hdr.reply) {
    8ac8:	07 93       	cmp	#0,	r7	;r3 As==00
    8aca:	05 24       	jz	$+12     	;abs 0x8ad6

00008acc <.Loc.318.2>:
    gen_success(buffer, hdr.crc);
    8acc:	4d 46       	mov.b	r6,	r13	;
    8ace:	0c 48       	mov	r8,	r12	;
    8ad0:	b0 12 28 6e 	call	#28200		;#0x6e28

00008ad4 <.LVL825>:
    8ad4:	d2 3f       	jmp	$-90     	;abs 0x8a7a

00008ad6 <.L546>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8ad6:	0c 48       	mov	r8,	r12	;
    8ad8:	b0 12 32 ab 	call	#-21710	;#0xab32

00008adc <.LVL826>:
    8adc:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008ae0 <.LVL827>:
    8ae0:	db 3f       	jmp	$-72     	;abs 0x8a98

00008ae2 <get_tx_freq>:
    8ae2:	0a 15       	pushm	#1,	r10	;16-bit words

00008ae4 <.LCFI90>:
static void get_tx_freq(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8ae4:	21 83       	decd	r1		;

00008ae6 <.LCFI91>:
    8ae6:	0a 4c       	mov	r12,	r10	;

00008ae8 <.Loc.255.2>:
    8ae8:	e1 4d       	mov.b	@r13		; Warning: disassembly unreliable - not enough bytes available

00008aea <L0>:
    8aea:	00 00       	beq			
    8aec:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8af0:	01 00 

00008af2 <.Loc.257.2>:
  if (hdr.reply) {
    8af2:	6e 41       	mov.b	@r1,	r14	;
    8af4:	2e b3       	bit	#2,	r14	;r3 As==10
    8af6:	2a 24       	jz	$+86     	;abs 0x8b4c

00008af8 <.Loc.258.2>:
    buffer[0] = buffer[0] & 0x3F;
    8af8:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8afc:	00 00 

00008afe <.Loc.259.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8afe:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

00008b02 <.LVL829>:
    8b02:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8b06:	02 00 

00008b08 <.Loc.260.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8b08:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8b0c:	03 00 

00008b0e <.LVL830>:
    8b0e:	3c 50 03 00 	add	#3,	r12	;
    8b12:	0d 4a       	mov	r10,	r13	;
    8b14:	2d 52       	add	#4,	r13	;r2 As==10
    8b16:	0f 4a       	mov	r10,	r15	;
    8b18:	3f 52       	add	#8,	r15	;r2 As==11

00008b1a <.L553>:
      buffer[i + 4] = bank0p[RegTXFreqMsb - i];
    8b1a:	ed 4c 00 00 	mov.b	@r12,	0(r13)	;

00008b1e <.LVL832>:
    8b1e:	3c 53       	add	#-1,	r12	;r3 As==11
    8b20:	1d 53       	inc	r13		;

00008b22 <.LVL833>:
    for (int i = 0; i < 4; i++) {
    8b22:	0d 9f       	cmp	r15,	r13	;
    8b24:	fa 23       	jnz	$-10     	;abs 0x8b1a

00008b26 <.LBE112>:
    if (hdr.crc) {
    8b26:	1e b3       	bit	#1,	r14	;r3 As==01
    8b28:	0e 24       	jz	$+30     	;abs 0x8b46

00008b2a <.Loc.266.2>:
      buffer[1] = 6;
    8b2a:	fa 40 06 00 	mov.b	#6,	1(r10)	;
    8b2e:	01 00 

00008b30 <.Loc.267.2>:
      crcGenX25(buffer, 10);
    8b30:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a

00008b34 <.LVL834>:
    8b34:	0c 4a       	mov	r10,	r12	;
    8b36:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008b3a <.L555>:
    elyCmdSendReply(buffer);
    8b3a:	0c 4a       	mov	r10,	r12	;
    8b3c:	b0 12 52 74 	call	#29778		;#0x7452

00008b40 <.L551>:
}
    8b40:	21 53       	incd	r1		;
    8b42:	0a 17       	popm	#1,	r10	;16-bit words
    8b44:	30 41       	ret			

00008b46 <.L554>:
      buffer[1] = 4;
    8b46:	ea 42 01 00 	mov.b	#4,	1(r10)	;r2 As==10
    8b4a:	f7 3f       	jmp	$-16     	;abs 0x8b3a

00008b4c <.L552>:
    8b4c:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00008b50 <.LVL839>:
}
    8b50:	f7 3f       	jmp	$-16     	;abs 0x8b40

00008b52 <set_block>:
    8b52:	3a 15       	pushm	#4,	r10	;16-bit words

00008b54 <.LCFI92>:
static void set_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8b54:	21 83       	decd	r1		;

00008b56 <L0>:
    8b56:	0a 4c       	mov	r12,	r10	;

00008b58 <.LVL841>:
    8b58:	5f 4d 01 00 	mov.b	1(r13),	r15	;

00008b5c <.LVL842>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8b5c:	68 4d       	mov.b	@r13,	r8	;
    8b5e:	58 f3       	and.b	#1,	r8	;r3 As==01
    8b60:	6b 4d       	mov.b	@r13,	r11	;
    8b62:	47 4b       	mov.b	r11,	r7	;
    8b64:	67 f3       	and.b	#2,	r7	;r3 As==10
    8b66:	49 47       	mov.b	r7,	r9	;
    8b68:	09 93       	cmp	#0,	r9	;r3 As==00
    8b6a:	1f 20       	jnz	$+64     	;abs 0x8baa
    8b6c:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008b6e <.L559>:
  uint8_t bank = buffer[hdr_ext];
    8b6e:	0e 4a       	mov	r10,	r14	;
    8b70:	0e 5d       	add	r13,	r14	;
    8b72:	6c 4e       	mov.b	@r14,	r12	;

00008b74 <.LVL844>:
  uint8_t addr = buffer[hdr_ext+1];
    8b74:	5e 4e 01 00 	mov.b	1(r14),	r14	;

00008b78 <.LVL845>:
    8b78:	7f 50 fe ff 	add.b	#-2,	r15	;#0xfffe

00008b7c <.LVL846>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8b7c:	1b b3       	bit	#1,	r11	;r3 As==01
    8b7e:	17 20       	jnz	$+48     	;abs 0x8bae

00008b80 <.Loc.227.2>:
    8b80:	4b 43       	clr.b	r11		;

00008b82 <.L560>:
    8b82:	4f 87       	sub.b	r7,	r15	;

00008b84 <.LVL848>:
  if (!elyRegSetBlock(bank, buffer + hdr_ext + 2, addr, count)) {
    8b84:	2d 53       	incd	r13		;

00008b86 <.LVL849>:
    8b86:	4f 8b       	sub.b	r11,	r15	;
    8b88:	0d 5a       	add	r10,	r13	;

00008b8a <.LVL850>:
    8b8a:	b0 12 e0 96 	call	#-26912	;#0x96e0

00008b8e <.LVL851>:
    8b8e:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8b90:	1a 20       	jnz	$+54     	;abs 0x8bc6

00008b92 <.Loc.230.2>:
    if (hdr.reply) {
    8b92:	09 93       	cmp	#0,	r9	;r3 As==00
    8b94:	0e 24       	jz	$+30     	;abs 0x8bb2

00008b96 <.Loc.232.2>:
      gen_failure(buffer, hdr.crc);
    8b96:	4d 48       	mov.b	r8,	r13	;
    8b98:	0c 4a       	mov	r10,	r12	;
    8b9a:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008b9e <.L567>:
    elyCmdSendReply(buffer);
    8b9e:	0c 4a       	mov	r10,	r12	;
    8ba0:	b0 12 52 74 	call	#29778		;#0x7452

00008ba4 <.L558>:
}
    8ba4:	21 53       	incd	r1		;
    8ba6:	37 17       	popm	#4,	r10	;16-bit words
    8ba8:	30 41       	ret			

00008baa <.L565>:
  uint8_t hdr_ext = (hdr.reply ? 4 : 2);
    8baa:	6d 42       	mov.b	#4,	r13	;r2 As==10

00008bac <.LVL855>:
    8bac:	e0 3f       	jmp	$-62     	;abs 0x8b6e

00008bae <.L566>:
  uint8_t count = hdr.length - (hdr.reply ? 2 : 0) - (hdr.crc ? 2 : 0) - 2;
    8bae:	6b 43       	mov.b	#2,	r11	;r3 As==10

00008bb0 <.LVL857>:
    8bb0:	e8 3f       	jmp	$-46     	;abs 0x8b82

00008bb2 <.L562>:
      elyErrorSignal(ErrCmdFailure);
    8bb2:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8bb6:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008bba <.L564>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8bba:	0c 4a       	mov	r10,	r12	;
    8bbc:	b0 12 32 ab 	call	#-21710	;#0xab32

00008bc0 <.LVL860>:
    8bc0:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008bc4 <.LVL861>:
    8bc4:	ef 3f       	jmp	$-32     	;abs 0x8ba4

00008bc6 <.L561>:
  if (hdr.reply) {
    8bc6:	09 93       	cmp	#0,	r9	;r3 As==00
    8bc8:	f8 27       	jz	$-14     	;abs 0x8bba

00008bca <.Loc.246.2>:
    gen_success(buffer, hdr.crc);
    8bca:	4d 48       	mov.b	r8,	r13	;
    8bcc:	0c 4a       	mov	r10,	r12	;
    8bce:	b0 12 28 6e 	call	#28200		;#0x6e28

00008bd2 <.LVL862>:
    8bd2:	e5 3f       	jmp	$-52     	;abs 0x8b9e

00008bd4 <get_block>:
    8bd4:	4a 15       	pushm	#5,	r10	;16-bit words

00008bd6 <.LCFI94>:
static void get_block(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8bd6:	21 83       	decd	r1		;

00008bd8 <.LCFI95>:
    8bd8:	0a 4c       	mov	r12,	r10	;
    8bda:	66 4d       	mov.b	@r13,	r6	;

00008bdc <L0>:
    8bdc:	56 f3       	and.b	#1,	r6	;r3 As==01

00008bde <.Loc.191.2>:
    8bde:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8be2:	01 00 

00008be4 <.Loc.193.2>:
  if (hdr.reply) { /* reply requested */
    8be4:	69 4d       	mov.b	@r13,	r9	;
    8be6:	59 c3       	bic.b	#1,	r9	;r3 As==01
    8be8:	49 d6       	bis.b	r6,	r9	;
    8bea:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    8bee:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8bf2:	29 b3       	bit	#2,	r9	;r3 As==10
    8bf4:	36 24       	jz	$+110    	;abs 0x8c62

00008bf6 <.LBB113>:
    uint8_t count = buffer[6];
    8bf6:	58 4c 06 00 	mov.b	6(r12),	r8	;

00008bfa <.LVL867>:
    if (!elyRegGetBlock(bank, buffer + 4, addr, count)) {
    8bfa:	4f 48       	mov.b	r8,	r15	;
    8bfc:	5e 4c 05 00 	mov.b	5(r12),	r14	;
    8c00:	0d 4c       	mov	r12,	r13	;
    8c02:	2d 52       	add	#4,	r13	;r2 As==10

00008c04 <.LVL868>:
    8c04:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008c08 <.LVL869>:
    8c08:	b0 12 60 96 	call	#-27040	;#0x9660

00008c0c <.LVL870>:
    8c0c:	37 40 52 74 	mov	#29778,	r7	;#0x7452
    8c10:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8c12:	09 20       	jnz	$+20     	;abs 0x8c26

00008c14 <.Loc.200.2>:
      gen_failure(buffer, hdr.crc);
    8c14:	4d 46       	mov.b	r6,	r13	;
    8c16:	0c 4a       	mov	r10,	r12	;
    8c18:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008c1c <.L573>:
    elyCmdSendReply(buffer);
    8c1c:	0c 4a       	mov	r10,	r12	;
    8c1e:	87 12       	call	r7		;

00008c20 <.L568>:
}
    8c20:	21 53       	incd	r1		;
    8c22:	46 17       	popm	#5,	r10	;16-bit words
    8c24:	30 41       	ret			

00008c26 <.L570>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8c26:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8c2a:	00 00 

00008c2c <.Loc.207.2>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    8c2c:	0c 49       	mov	r9,	r12	;
    8c2e:	5c f3       	and.b	#1,	r12	;r3 As==01
    8c30:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c32:	15 20       	jnz	$+44     	;abs 0x8c5e
    8c34:	0d 4c       	mov	r12,	r13	;

00008c36 <.L572>:
    8c36:	4d 58       	add.b	r8,	r13	;
    8c38:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00008c3c <.Loc.208.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8c3c:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    8c40:	da 4d 51 00 	mov.b	81(r13),2(r10)	;0x00051
    8c44:	02 00 

00008c46 <.Loc.209.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8c46:	da 4d 50 00 	mov.b	80(r13),3(r10)	;0x00050
    8c4a:	03 00 

00008c4c <.Loc.211.2>:
    if (hdr.crc) {
    8c4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8c4e:	e6 27       	jz	$-50     	;abs 0x8c1c

00008c50 <.Loc.212.2>:
      crcGenX25(buffer, count + 6);
    8c50:	0d 48       	mov	r8,	r13	;
    8c52:	3d 50 06 00 	add	#6,	r13	;
    8c56:	0c 4a       	mov	r10,	r12	;
    8c58:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008c5c <.LVL874>:
    8c5c:	df 3f       	jmp	$-64     	;abs 0x8c1c

00008c5e <.L574>:
    buffer[1] = count + (hdr.crc ? 2 : 0); 
    8c5e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    8c60:	ea 3f       	jmp	$-42     	;abs 0x8c36

00008c62 <.L569>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8c62:	b0 12 32 ab 	call	#-21710	;#0xab32

00008c66 <.LVL876>:
    8c66:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008c6a <.LVL877>:
    8c6a:	da 3f       	jmp	$-74     	;abs 0x8c20

00008c6c <set_regs>:
    8c6c:	2a 15       	pushm	#3,	r10	;16-bit words

00008c6e <.LCFI96>:
static void set_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8c6e:	21 83       	decd	r1		;

00008c70 <.LCFI97>:
    8c70:	0a 4c       	mov	r12,	r10	;

00008c72 <L0>:
    8c72:	5e 4d 01 00 	mov.b	1(r13),	r14	;

00008c76 <.LVL880>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8c76:	68 4d       	mov.b	@r13,	r8	;
    8c78:	58 f3       	and.b	#1,	r8	;r3 As==01
    8c7a:	6f 4d       	mov.b	@r13,	r15	;
    8c7c:	49 4f       	mov.b	r15,	r9	;
    8c7e:	69 f3       	and.b	#2,	r9	;r3 As==10
    8c80:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8c84:	09 93       	cmp	#0,	r9	;r3 As==00
    8c86:	21 24       	jz	$+68     	;abs 0x8cca

00008c88 <.Loc.160.2>:
    8c88:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008c8c <.LVL881>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8c8c:	7d 40 05 00 	mov.b	#5,	r13	;

00008c90 <.L580>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8c90:	1f b3       	bit	#1,	r15	;r3 As==01
    8c92:	20 20       	jnz	$+66     	;abs 0x8cd4

00008c94 <.Loc.162.2>:
    8c94:	4f 43       	clr.b	r15		;

00008c96 <.L581>:
    8c96:	0e 8f       	sub	r15,	r14	;

00008c98 <.LVL884>:
    8c98:	0e 89       	sub	r9,	r14	;
    8c9a:	0f 4e       	mov	r14,	r15	;
    8c9c:	5f 03       	rrum	#1,	r15	;
    8c9e:	4d 18 0f 11 	rpt #14 { rrax.w	r15		;
    8ca2:	0e 5f       	add	r15,	r14	;

00008ca4 <.Loc.164.2>:
  if (!elyRegSet(bank, buffer + regs_offset, num_regs)) {
    8ca4:	12 c3       	clrc			
    8ca6:	0e 10       	rrc	r14		;
    8ca8:	0d 5a       	add	r10,	r13	;

00008caa <.LVL885>:
    8caa:	b0 12 cc 95 	call	#-27188	;#0x95cc

00008cae <.LVL886>:
    8cae:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8cb0:	1d 20       	jnz	$+60     	;abs 0x8cec

00008cb2 <.Loc.165.2>:
    if (hdr.reply) {
    8cb2:	09 93       	cmp	#0,	r9	;r3 As==00
    8cb4:	11 24       	jz	$+36     	;abs 0x8cd8

00008cb6 <.Loc.167.2>:
      gen_failure(buffer, hdr.crc);
    8cb6:	4d 48       	mov.b	r8,	r13	;
    8cb8:	0c 4a       	mov	r10,	r12	;
    8cba:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008cbe <.L587>:
    elyCmdSendReply(buffer);
    8cbe:	0c 4a       	mov	r10,	r12	;
    8cc0:	b0 12 52 74 	call	#29778		;#0x7452

00008cc4 <.L578>:
}
    8cc4:	21 53       	incd	r1		;
    8cc6:	28 17       	popm	#3,	r10	;16-bit words
    8cc8:	30 41       	ret			

00008cca <.L579>:
  uint8_t bank = (hdr.reply ? buffer[4] : buffer[2]);
    8cca:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008cce <.LVL890>:
  const uint8_t regs_offset = (hdr.reply ? 5 : 3);
    8cce:	7d 40 03 00 	mov.b	#3,	r13	;

00008cd2 <.LVL891>:
    8cd2:	de 3f       	jmp	$-66     	;abs 0x8c90

00008cd4 <.L586>:
  const uint8_t num_regs = (hdr.length - (hdr.crc ? 2 : 0) - (hdr.reply ? 2 : 0)) / 2;
    8cd4:	6f 43       	mov.b	#2,	r15	;r3 As==10

00008cd6 <.LVL893>:
    8cd6:	df 3f       	jmp	$-64     	;abs 0x8c96

00008cd8 <.L583>:
      elyErrorSignal(ErrCmdFailure);
    8cd8:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8cdc:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008ce0 <.L585>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8ce0:	0c 4a       	mov	r10,	r12	;
    8ce2:	b0 12 32 ab 	call	#-21710	;#0xab32

00008ce6 <.LVL896>:
    8ce6:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008cea <.LVL897>:
    8cea:	ec 3f       	jmp	$-38     	;abs 0x8cc4

00008cec <.L582>:
  if (hdr.reply) {
    8cec:	09 93       	cmp	#0,	r9	;r3 As==00
    8cee:	f8 27       	jz	$-14     	;abs 0x8ce0

00008cf0 <.Loc.181.2>:
    gen_success(buffer, hdr.crc);
    8cf0:	4d 48       	mov.b	r8,	r13	;
    8cf2:	0c 4a       	mov	r10,	r12	;
    8cf4:	b0 12 28 6e 	call	#28200		;#0x6e28

00008cf8 <.LVL898>:
    8cf8:	e2 3f       	jmp	$-58     	;abs 0x8cbe

00008cfa <get_regs>:
    8cfa:	5a 15       	pushm	#6,	r10	;16-bit words

00008cfc <.LCFI98>:
static void get_regs(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8cfc:	21 83       	decd	r1		;

00008cfe <.LCFI99>:
    8cfe:	0a 4c       	mov	r12,	r10	;
    8d00:	67 4d       	mov.b	@r13,	r7	;

00008d02 <L0>:
    8d02:	57 f3       	and.b	#1,	r7	;r3 As==01

00008d04 <.LVL900>:
    8d04:	58 4d 01 00 	mov.b	1(r13),	r8	;

00008d08 <.LVL901>:
    8d08:	c1 48 01 00 	mov.b	r8,	1(r1)	;

00008d0c <.Loc.130.2>:
  if (hdr.reply) {
    8d0c:	69 4d       	mov.b	@r13,	r9	;
    8d0e:	59 c3       	bic.b	#1,	r9	;r3 As==01
    8d10:	49 d7       	bis.b	r7,	r9	;
    8d12:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    8d16:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    8d1a:	29 b3       	bit	#2,	r9	;r3 As==10
    8d1c:	35 24       	jz	$+108    	;abs 0x8d88

00008d1e <.LBB115>:
    uint8_t bank = buffer[4];
    8d1e:	5c 4c 04 00 	mov.b	4(r12),	r12	;

00008d22 <.LVL903>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8d22:	59 f3       	and.b	#1,	r9	;r3 As==01
    8d24:	09 93       	cmp	#0,	r9	;r3 As==00
    8d26:	18 24       	jz	$+50     	;abs 0x8d58
    8d28:	6d 43       	mov.b	#2,	r13	;r3 As==10

00008d2a <.L590>:
    8d2a:	78 50 fd ff 	add.b	#-3,	r8	;#0xfffd

00008d2e <.LVL905>:
    8d2e:	4e 48       	mov.b	r8,	r14	;
    8d30:	4e 8d       	sub.b	r13,	r14	;
    8d32:	45 4e       	mov.b	r14,	r5	;

00008d34 <.LVL906>:
    if (!elyRegGet(bank, buffer + regs_offset, num_regs)) {
    8d34:	0d 4a       	mov	r10,	r13	;
    8d36:	3d 50 05 00 	add	#5,	r13	;
    8d3a:	b0 12 3c 95 	call	#-27332	;#0x953c

00008d3e <.LVL907>:
    8d3e:	36 40 52 74 	mov	#29778,	r6	;#0x7452
    8d42:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8d44:	0b 20       	jnz	$+24     	;abs 0x8d5c

00008d46 <.Loc.137.2>:
      gen_failure(buffer, hdr.crc);
    8d46:	4d 47       	mov.b	r7,	r13	;
    8d48:	0c 4a       	mov	r10,	r12	;
    8d4a:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008d4e <.L593>:
    elyCmdSendReply(buffer);
    8d4e:	0c 4a       	mov	r10,	r12	;
    8d50:	86 12       	call	r6		;

00008d52 <.L588>:
}
    8d52:	21 53       	incd	r1		;
    8d54:	55 17       	popm	#6,	r10	;16-bit words
    8d56:	30 41       	ret			

00008d58 <.L594>:
    const uint8_t num_regs = hdr.length - (hdr.crc ? 2 : 0) - 3;
    8d58:	0d 49       	mov	r9,	r13	;

00008d5a <.LVL911>:
    8d5a:	e7 3f       	jmp	$-48     	;abs 0x8d2a

00008d5c <.L591>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8d5c:	fa f0 3f 00 	and.b	#63,	0(r10)	;#0x003f
    8d60:	00 00 

00008d62 <.Loc.144.2>:
    buffer[1] = hdr.length - 3; /* no Reply Address, no Bank Index */
    8d62:	ca 48 01 00 	mov.b	r8,	1(r10)	;

00008d66 <.Loc.145.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8d66:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    8d6a:	da 4c 51 00 	mov.b	81(r12),2(r10)	;0x00051
    8d6e:	02 00 

00008d70 <.Loc.146.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8d70:	da 4c 50 00 	mov.b	80(r12),3(r10)	;0x00050
    8d74:	03 00 

00008d76 <.Loc.148.2>:
    if (hdr.crc) {
    8d76:	09 93       	cmp	#0,	r9	;r3 As==00
    8d78:	ea 27       	jz	$-42     	;abs 0x8d4e

00008d7a <.Loc.149.2>:
      crcGenX25(buffer, num_regs + 6);
    8d7a:	0d 45       	mov	r5,	r13	;
    8d7c:	3d 50 06 00 	add	#6,	r13	;
    8d80:	0c 4a       	mov	r10,	r12	;
    8d82:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008d86 <.LVL913>:
    8d86:	e3 3f       	jmp	$-56     	;abs 0x8d4e

00008d88 <.L589>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8d88:	b0 12 32 ab 	call	#-21710	;#0xab32

00008d8c <.LVL915>:
    8d8c:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008d90 <.LVL916>:
    8d90:	e0 3f       	jmp	$-62     	;abs 0x8d52

00008d92 <get_active_bank>:
    8d92:	0a 15       	pushm	#1,	r10	;16-bit words

00008d94 <.LCFI100>:
static void get_active_bank(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8d94:	21 83       	decd	r1		;

00008d96 <.LCFI101>:
    8d96:	0a 4c       	mov	r12,	r10	;

00008d98 <L0>:
    8d98:	6e 4d       	mov.b	@r13,	r14	;
    8d9a:	5e f3       	and.b	#1,	r14	;r3 As==01

00008d9c <.LVL918>:
    8d9c:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8da0:	01 00 

00008da2 <.Loc.111.2>:
  if (hdr.reply) { /* reply requested */
    8da2:	6d 4d       	mov.b	@r13,	r13	;
    8da4:	5d c3       	bic.b	#1,	r13	;r3 As==01
    8da6:	4d de       	bis.b	r14,	r13	;
    8da8:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    8dac:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8db0:	2d b3       	bit	#2,	r13	;r3 As==10
    8db2:	1e 24       	jz	$+62     	;abs 0x8df0

00008db4 <.Loc.112.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8db4:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8db8:	00 00 

00008dba <.Loc.113.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    8dba:	4e 5e       	rla.b	r14		;

00008dbc <.LVL920>:
    8dbc:	5e 53       	inc.b	r14		;
    8dbe:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00008dc2 <.Loc.114.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8dc2:	1e 42 be bd 	mov	&0xbdbe,r14	;0xbdbe
    8dc6:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8dca:	02 00 

00008dcc <.Loc.115.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8dcc:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8dd0:	03 00 

00008dd2 <.Loc.116.2>:
    buffer[4] = bank0p[RegActiveBank];
    8dd2:	dc 4e 69 00 	mov.b	105(r14),4(r12)	;0x00069
    8dd6:	04 00 

00008dd8 <.Loc.117.2>:
    if (hdr.crc) {
    8dd8:	1d b3       	bit	#1,	r13	;r3 As==01
    8dda:	04 24       	jz	$+10     	;abs 0x8de4

00008ddc <.Loc.118.2>:
      crcGenX25(buffer, 7);
    8ddc:	7d 40 07 00 	mov.b	#7,	r13	;
    8de0:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008de4 <.L600>:
    elyCmdSendReply(buffer);
    8de4:	0c 4a       	mov	r10,	r12	;
    8de6:	b0 12 52 74 	call	#29778		;#0x7452

00008dea <.L598>:
}
    8dea:	21 53       	incd	r1		;
    8dec:	0a 17       	popm	#1,	r10	;16-bit words
    8dee:	30 41       	ret			

00008df0 <.L599>:
    8df0:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00008df4 <.LVL924>:
    8df4:	fa 3f       	jmp	$-10     	;abs 0x8dea

00008df6 <set_gpo>:
    8df6:	3a 15       	pushm	#4,	r10	;16-bit words

00008df8 <L0>:
static void set_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8df8:	21 83       	decd	r1		;

00008dfa <.LCFI103>:
    8dfa:	09 4c       	mov	r12,	r9	;
    8dfc:	68 4d       	mov.b	@r13,	r8	;
    8dfe:	58 f3       	and.b	#1,	r8	;r3 As==01

00008e00 <.Loc.70.2>:
    8e00:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8e04:	01 00 

00008e06 <.Loc.71.2>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    8e06:	6a 4d       	mov.b	@r13,	r10	;
    8e08:	5a c3       	bic.b	#1,	r10	;r3 As==01
    8e0a:	4a d8       	bis.b	r8,	r10	;
    8e0c:	c1 4a 00 00 	mov.b	r10,	0(r1)	;
    8e10:	6a f3       	and.b	#2,	r10	;r3 As==10
    8e12:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    8e16:	0a 93       	cmp	#0,	r10	;r3 As==00
    8e18:	12 20       	jnz	$+38     	;abs 0x8e3e
    8e1a:	6c 43       	mov.b	#2,	r12	;r3 As==10

00008e1c <.L606>:
    8e1c:	0c 59       	add	r9,	r12	;
    8e1e:	67 4c       	mov.b	@r12,	r7	;

00008e20 <.LVL929>:
  if (arg > 1) {
    8e20:	5c 43       	mov.b	#1,	r12	;r3 As==01

00008e22 <.LVL930>:
    8e22:	4c 97       	cmp.b	r7,	r12	;
    8e24:	18 2c       	jc	$+50     	;abs 0x8e56

00008e26 <.Loc.74.2>:
    if (hdr.reply) {
    8e26:	0a 93       	cmp	#0,	r10	;r3 As==00
    8e28:	0c 24       	jz	$+26     	;abs 0x8e42

00008e2a <.Loc.76.2>:
      gen_failure(buffer, hdr.crc);
    8e2a:	4d 48       	mov.b	r8,	r13	;
    8e2c:	0c 49       	mov	r9,	r12	;
    8e2e:	b0 12 7a 6e 	call	#28282		;#0x6e7a

00008e32 <.L613>:
    elyCmdSendReply(buffer);
    8e32:	0c 49       	mov	r9,	r12	;
    8e34:	b0 12 52 74 	call	#29778		;#0x7452

00008e38 <.L605>:
}
    8e38:	21 53       	incd	r1		;
    8e3a:	37 17       	popm	#4,	r10	;16-bit words
    8e3c:	30 41       	ret			

00008e3e <.L612>:
  uint8_t arg = buffer[(hdr.reply ? 4 : 2)];
    8e3e:	6c 42       	mov.b	#4,	r12	;r2 As==10
    8e40:	ed 3f       	jmp	$-36     	;abs 0x8e1c

00008e42 <.L608>:
      elyErrorSignal(ErrCmdFailure);
    8e42:	7c 40 8c ff 	mov.b	#-116,	r12	;#0xff8c
    8e46:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008e4a <.L611>:
    elyNLFreeBuffer(elyNLPack(buffer));
    8e4a:	0c 49       	mov	r9,	r12	;
    8e4c:	b0 12 32 ab 	call	#-21710	;#0xab32

00008e50 <.LVL936>:
    8e50:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00008e54 <.LVL937>:
    8e54:	f1 3f       	jmp	$-28     	;abs 0x8e38

00008e56 <.L607>:
  if (bank0p[RegGPOState] != arg) {
    8e56:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe
    8e5a:	cc 97 61 00 	cmp.b	r7,	97(r12)	; 0x0061
    8e5e:	08 24       	jz	$+18     	;abs 0x8e70

00008e60 <.Loc.93.2>:
    elyEventSignal(EvtGPOChange);
    8e60:	7c 40 c3 ff 	mov.b	#-61,	r12	;#0xffc3
    8e64:	b0 12 70 ac 	call	#-21392	;#0xac70

00008e68 <.LVL938>:
    bank0w[RegGPOState] = arg;
    8e68:	1c 42 bc bd 	mov	&0xbdbc,r12	;0xbdbc
    8e6c:	cc 47 61 00 	mov.b	r7,	97(r12)	; 0x0061

00008e70 <.L610>:
  if (hdr.reply) {
    8e70:	0a 93       	cmp	#0,	r10	;r3 As==00
    8e72:	eb 27       	jz	$-40     	;abs 0x8e4a

00008e74 <.Loc.99.2>:
    gen_success(buffer, hdr.crc);
    8e74:	4d 48       	mov.b	r8,	r13	;
    8e76:	0c 49       	mov	r9,	r12	;
    8e78:	b0 12 28 6e 	call	#28200		;#0x6e28

00008e7c <.LVL939>:
    8e7c:	da 3f       	jmp	$-74     	;abs 0x8e32

00008e7e <get_gpo>:
    8e7e:	0a 15       	pushm	#1,	r10	;16-bit words

00008e80 <.LCFI104>:
static void get_gpo(uint8_t* buffer, elysium_cmd_hdr_t hdr) {
    8e80:	21 83       	decd	r1		;

00008e82 <.LCFI105>:
    8e82:	0a 4c       	mov	r12,	r10	;

00008e84 <L0>:
    8e84:	6e 4d       	mov.b	@r13,	r14	;
    8e86:	5e f3       	and.b	#1,	r14	;r3 As==01

00008e88 <.LVL941>:
    8e88:	d1 4d 01 00 	mov.b	1(r13),	1(r1)	;
    8e8c:	01 00 

00008e8e <.Loc.52.2>:
  if (hdr.reply) { /* reply requested */
    8e8e:	6d 4d       	mov.b	@r13,	r13	;
    8e90:	5d c3       	bic.b	#1,	r13	;r3 As==01
    8e92:	4d de       	bis.b	r14,	r13	;
    8e94:	c1 4d 00 00 	mov.b	r13,	0(r1)	;
    8e98:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8e9c:	2d b3       	bit	#2,	r13	;r3 As==10
    8e9e:	1e 24       	jz	$+62     	;abs 0x8edc

00008ea0 <.Loc.53.2>:
    buffer[0] &= 0x3F; /* opcode w/o CRC or Reply */
    8ea0:	fc f0 3f 00 	and.b	#63,	0(r12)	;#0x003f
    8ea4:	00 00 

00008ea6 <.Loc.54.2>:
    buffer[1] = 1 + (hdr.crc << 1);
    8ea6:	4e 5e       	rla.b	r14		;

00008ea8 <.LVL943>:
    8ea8:	5e 53       	inc.b	r14		;
    8eaa:	cc 4e 01 00 	mov.b	r14,	1(r12)	;

00008eae <.Loc.55.2>:
    buffer[2] = bank0p[RegSrcAddrMsb];
    8eae:	1e 42 be bd 	mov	&0xbdbe,r14	;0xbdbe
    8eb2:	dc 4e 51 00 	mov.b	81(r14),2(r12)	;0x00051
    8eb6:	02 00 

00008eb8 <.Loc.56.2>:
    buffer[3] = bank0p[RegSrcAddrLsb];
    8eb8:	dc 4e 50 00 	mov.b	80(r14),3(r12)	;0x00050
    8ebc:	03 00 

00008ebe <.Loc.57.2>:
    buffer[4] = bank0p[RegGPOState];
    8ebe:	dc 4e 61 00 	mov.b	97(r14),4(r12)	;0x00061
    8ec2:	04 00 

00008ec4 <.Loc.58.2>:
    if (hdr.crc) {
    8ec4:	1d b3       	bit	#1,	r13	;r3 As==01
    8ec6:	04 24       	jz	$+10     	;abs 0x8ed0

00008ec8 <.Loc.59.2>:
      crcGenX25(buffer, 7);
    8ec8:	7d 40 07 00 	mov.b	#7,	r13	;
    8ecc:	b0 12 26 9b 	call	#-25818	;#0x9b26

00008ed0 <.L616>:
    elyCmdSendReply(buffer);
    8ed0:	0c 4a       	mov	r10,	r12	;
    8ed2:	b0 12 52 74 	call	#29778		;#0x7452

00008ed6 <.L614>:
}
    8ed6:	21 53       	incd	r1		;
    8ed8:	0a 17       	popm	#1,	r10	;16-bit words
    8eda:	30 41       	ret			

00008edc <.L615>:
    8edc:	b0 12 e4 6f 	call	#28644		;#0x6fe4

00008ee0 <.LVL947>:
    8ee0:	fa 3f       	jmp	$-10     	;abs 0x8ed6

00008ee2 <clamp>:

/* TODO persistent, really? */
static BSEMAPHORE_DECL(regs_sem, 1); /* 1 is taken which is cnt == 0 */
static uint8_t regs_in_progress = 0;

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    8ee2:	1a 15       	pushm	#2,	r10	;16-bit words

00008ee4 <L0>:
    8ee4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ee8:	49 4d       	mov.b	r13,	r9	;
    8eea:	4a 4e       	mov.b	r14,	r10	;

00008eec <.Loc.153.1>:
  if (value < min) {
    8eec:	4c 99       	cmp.b	r9,	r12	;
    8eee:	07 2c       	jc	$+16     	;abs 0x8efe

00008ef0 <.LVL1>:
    value = min;
    elyErrorSignal(ErrRegClip);
    8ef0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8ef4:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008ef8 <.LVL2>:
    8ef8:	0c 49       	mov	r9,	r12	;

00008efa <.L3>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    8efa:	19 17       	popm	#2,	r10	;16-bit words
    8efc:	30 41       	ret			

00008efe <.L2>:
  else if (value > max) {
    8efe:	4a 9c       	cmp.b	r12,	r10	;
    8f00:	fc 2f       	jc	$-6      	;abs 0x8efa

00008f02 <.LVL5>:
    elyErrorSignal(ErrRegClip);
    8f02:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    8f06:	b0 12 5a ac 	call	#-21414	;#0xac5a

00008f0a <.LVL6>:
    8f0a:	0c 4a       	mov	r10,	r12	;
    8f0c:	f6 3f       	jmp	$-18     	;abs 0x8efa

00008f0e <fram_reg_cb>:
    8f0e:	5c 42       	mov.b,		r12	;Warning: disassembly unreliable - not enough bytes available

00008f10 <L0>:
  return value;
}

void fram_reg_cb(uint8_t * buffer) {
  (void)(buffer);
  regs_in_progress--;
    8f10:	66 cd       	bic.b	@r13,	r6	;

00008f12 <.LVL8>:
    8f12:	7c 53       	add.b	#-1,	r12	;r3 As==11
    8f14:	c2 4c 66 cd 	mov.b	r12,	&0xcd66	;

00008f18 <.Loc.208.1>:
  if (regs_in_progress == 0) {
    8f18:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    8f1a:	0f 20       	jnz	$+32     	;abs 0x8f3a

00008f1c <.LBB14>:
    chSysLockFromISR();
    8f1c:	b0 12 98 44 	call	#17560		;#0x4498

00008f20 <.LBB16>:
  chDbgCheckClassI();
    8f20:	b0 12 26 45 	call	#17702		;#0x4526

00008f24 <.LVL11>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8f24:	1c 42 68 cd 	mov	&0xcd68,r12	;0xcd68
    8f28:	4d 43       	clr.b	r13		;
    8f2a:	0d 9c       	cmp	r12,	r13	;
    8f2c:	04 38       	jl	$+10     	;abs 0x8f36

00008f2e <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8f2e:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    8f32:	b0 12 10 48 	call	#18448		;#0x4810

00008f36 <.L6>:
    chBSemSignalI(&regs_sem);
    chSysUnlockFromISR();
    8f36:	b0 12 b8 44 	call	#17592		;#0x44b8

00008f3a <.L4>:
  }
}
    8f3a:	30 41       	ret			

00008f3c <fram_block_cb>:
  elyFramPostRequest(req);
}

void fram_block_cb(uint8_t * buffer) {
  (void)(buffer);
  chSysLockFromISR();
    8f3c:	b0 12 98 44 	call	#17560		;#0x4498

00008f40 <.LBB20>:
  chDbgCheckClassI();
    8f40:	b0 12 26 45 	call	#17702		;#0x4526

00008f44 <.LVL16>:
  if (bsp->sem.cnt < (cnt_t)1) {
    8f44:	1c 42 68 cd 	mov	&0xcd68,r12	;0xcd68
    8f48:	4d 43       	clr.b	r13		;
    8f4a:	0d 9c       	cmp	r12,	r13	;
    8f4c:	04 38       	jl	$+10     	;abs 0x8f56

00008f4e <.Loc.271.2>:
    chSemSignalI(&bsp->sem);
    8f4e:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    8f52:	b0 12 10 48 	call	#18448		;#0x4810

00008f56 <.L8>:
  chBSemSignalI(&regs_sem);
  chSysUnlockFromISR();
    8f56:	b0 12 b8 44 	call	#17592		;#0x44b8

00008f5a <.LVL18>:
}
    8f5a:	30 41       	ret			

00008f5c <fram_reg>:
void fram_reg(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * valuep) {
    8f5c:	1a 15       	pushm	#2,	r10	;16-bit words

00008f5e <.LCFI1>:
    8f5e:	17 15       	pushm	#2,	r7	;16-bit words

00008f60 <.LCFI2>:
    8f60:	21 83       	decd	r1		;

00008f62 <.LCFI3>:
    8f62:	4a 4c       	mov.b	r12,	r10	;
    8f64:	47 4d       	mov.b	r13,	r7	;
    8f66:	46 4e       	mov.b	r14,	r6	;
    8f68:	09 4f       	mov	r15,	r9	;

00008f6a <.LBB26>:
  _disable_interrupts();
    8f6a:	32 c2       	dint			

00008f6c <.Loc.348.3>:
  asm volatile("nop");
    8f6c:	03 43       	nop			

00008f6e <.LBE26>:
  chSysLock();
    8f6e:	b0 12 5a 44 	call	#17498		;#0x445a

00008f72 <.LVL20>:
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8f72:	4d 43       	clr.b	r13		;
    8f74:	0c 41       	mov	r1,	r12	;
    8f76:	b0 12 9a ae 	call	#-20838	;#0xae9a

00008f7a <.LVL21>:
  chSysUnlock();
    8f7a:	b0 12 78 44 	call	#17528		;#0x4478

00008f7e <.LBB28>:
  asm volatile("nop");
    8f7e:	03 43       	nop			

00008f80 <.Loc.356.3>:
  _enable_interrupts();
    8f80:	32 d2       	eint			
    8f82:	03 43       	nop			

00008f84 <.LBE28>:
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    8f84:	2c 41       	mov	@r1,	r12	;
    8f86:	37 53       	add	#-1,	r7	;r3 As==11

00008f88 <.LVL23>:
    8f88:	47 18 07 57 	rpt #8 { rlax.w	r7		;

00008f8c <.LVL24>:
    8f8c:	0e 47       	mov	r7,	r14	;
    8f8e:	0f 47       	mov	r7,	r15	;
    8f90:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    8f94:	46 46       	mov.b	r6,	r6	;
    8f96:	07 43       	clr	r7		;

00008f98 <.LVL25>:
    8f98:	0d 46       	mov	r6,	r13	;
    8f9a:	0d 53       	add	#0,	r13	;r3 As==00
    8f9c:	17 63       	addc	#1,	r7	;r3 As==01
    8f9e:	0d 5e       	add	r14,	r13	;
    8fa0:	8c 4d 00 00 	mov	r13,	0(r12)	;
    8fa4:	07 6f       	addc	r15,	r7	;
    8fa6:	8c 47 02 00 	mov	r7,	2(r12)	;

00008faa <.Loc.225.1>:
  req->read = read;
    8faa:	4d 4a       	mov.b	r10,	r13	;
    8fac:	5d f3       	and.b	#1,	r13	;r3 As==01
    8fae:	4d 5d       	rla.b	r13		;
    8fb0:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    8fb4:	6e c3       	bic.b	#2,	r14	;r3 As==10
    8fb6:	4e dd       	bis.b	r13,	r14	;
    8fb8:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

00008fbc <.Loc.226.1>:
  req->size = 1;
    8fbc:	1d 4c 04 00 	mov	4(r12),	r13	;
    8fc0:	7d f0 03 00 	and.b	#3,	r13	;
    8fc4:	2d d2       	bis	#4,	r13	;r2 As==10
    8fc6:	8c 4d 04 00 	mov	r13,	4(r12)	;
    8fca:	fc f0 f8 ff 	and.b	#-8,	6(r12)	;#0xfff8
    8fce:	06 00 

00008fd0 <.Loc.227.1>:
  req->buffer = valuep;
    8fd0:	8c 49 08 00 	mov	r9,	8(r12)	;

00008fd4 <.Loc.228.1>:
  req->callback = fram_reg_cb;
    8fd4:	bc 40 0e 8f 	mov	#-28914,10(r12)	;#0x8f0e, 0x000a
    8fd8:	0a 00 

00008fda <.Loc.231.1>:
  elyFramPostRequest(req);
    8fda:	b0 12 c0 ae 	call	#-20800	;#0xaec0

00008fde <.LVL26>:
}
    8fde:	21 53       	incd	r1		;
    8fe0:	16 17       	popm	#2,	r7	;16-bit words
    8fe2:	19 17       	popm	#2,	r10	;16-bit words
    8fe4:	30 41       	ret			

00008fe6 <fram_block>:

void fram_block(uint8_t read, uint8_t bank, uint8_t addr, uint8_t * buffer, uint8_t n) {
    8fe6:	1a 15       	pushm	#2,	r10	;16-bit words

00008fe8 <.LCFI4>:
    8fe8:	17 15       	pushm	#2,	r7	;16-bit words

00008fea <.LCFI5>:
    8fea:	31 80 06 00 	sub	#6,	r1	;

00008fee <.LCFI6>:
    8fee:	4a 4c       	mov.b	r12,	r10	;
    8ff0:	47 4d       	mov.b	r13,	r7	;
    8ff2:	46 4e       	mov.b	r14,	r6	;
    8ff4:	09 4f       	mov	r15,	r9	;

00008ff6 <.LBB34>:
  _disable_interrupts();
    8ff6:	32 c2       	dint			

00008ff8 <.Loc.348.3>:
  asm volatile("nop");
    8ff8:	03 43       	nop			

00008ffa <.LBE34>:
  fram_req_t * req;
  
  chSysLock();
    8ffa:	b0 12 5a 44 	call	#17498		;#0x445a

00008ffe <.LVL28>:
  /* TODO timeout for safety */
  elyFramGetRequestTimeoutS(&req, TIME_INFINITE);
    8ffe:	4d 43       	clr.b	r13		;
    9000:	0c 41       	mov	r1,	r12	;
    9002:	2c 52       	add	#4,	r12	;r2 As==10
    9004:	b0 12 9a ae 	call	#-20838	;#0xae9a

00009008 <.LVL29>:
  chSysUnlock();
    9008:	b0 12 78 44 	call	#17528		;#0x4478

0000900c <.LBB36>:
  asm volatile("nop");
    900c:	03 43       	nop			

0000900e <.Loc.356.3>:
  _enable_interrupts();
    900e:	32 d2       	eint			
    9010:	03 43       	nop			

00009012 <.LBE36>:
  
  /* Fill out the request */
  req->address = FRAM_REG_BASE + ((bank-1) * 256) + addr;
    9012:	1c 41 04 00 	mov	4(r1),	r12	;
    9016:	37 53       	add	#-1,	r7	;r3 As==11

00009018 <.LVL31>:
    9018:	47 18 07 57 	rpt #8 { rlax.w	r7		;

0000901c <.LVL32>:
    901c:	0e 47       	mov	r7,	r14	;
    901e:	0f 47       	mov	r7,	r15	;
    9020:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;
    9024:	46 46       	mov.b	r6,	r6	;
    9026:	07 43       	clr	r7		;

00009028 <.LVL33>:
    9028:	0d 46       	mov	r6,	r13	;
    902a:	0d 53       	add	#0,	r13	;r3 As==00
    902c:	17 63       	addc	#1,	r7	;r3 As==01
    902e:	0d 5e       	add	r14,	r13	;
    9030:	8c 4d 00 00 	mov	r13,	0(r12)	;
    9034:	07 6f       	addc	r15,	r7	;
    9036:	8c 47 02 00 	mov	r7,	2(r12)	;

0000903a <.Loc.251.1>:
  req->read = read;
    903a:	4d 4a       	mov.b	r10,	r13	;
    903c:	5d f3       	and.b	#1,	r13	;r3 As==01
    903e:	4d 5d       	rla.b	r13		;
    9040:	5e 4c 04 00 	mov.b	4(r12),	r14	;
    9044:	6e c3       	bic.b	#2,	r14	;r3 As==10
    9046:	4e dd       	bis.b	r13,	r14	;
    9048:	cc 4e 04 00 	mov.b	r14,	4(r12)	;

0000904c <.Loc.252.1>:
  req->size = n;
    904c:	5d 41 10 00 	mov.b	16(r1),	r13	;0x00010
    9050:	00 18 c1 4d 	movx.a	r13,	0(r1)	;
    9054:	00 00 
    9056:	2d 41       	mov	@r1,	r13	;
    9058:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    905c:	1e 4c 04 00 	mov	4(r12),	r14	;
    9060:	7e f0 03 00 	and.b	#3,	r14	;
    9064:	0e dd       	bis	r13,	r14	;
    9066:	8c 4e 04 00 	mov	r14,	4(r12)	;

0000906a <.LVL34>:
    906a:	2e 41       	mov	@r1,	r14	;
    906c:	0f 4e       	mov	r14,	r15	;
    906e:	5f 03       	rrum	#1,	r15	;
    9070:	4c 18 0f 11 	rpt #13 { rrax.w	r15		;
    9074:	5e 4c 06 00 	mov.b	6(r12),	r14	;
    9078:	7e f0 f8 ff 	and.b	#-8,	r14	;#0xfff8
    907c:	0a 01       	mova	@r1,	r10	;

0000907e <.LVL35>:
    907e:	0a 14       	pushm.a	#1,	r10	;20-bit words
    9080:	0d 17       	popm	#1,	r13	;16-bit words
    9082:	0d 17       	popm	#1,	r13	;16-bit words
    9084:	5d f3       	and.b	#1,	r13	;r3 As==01
    9086:	41 18 0d 5d 	rpt #2 { rlax.w	r13		;
    908a:	4e df       	bis.b	r15,	r14	;
    908c:	4e dd       	bis.b	r13,	r14	;
    908e:	cc 4e 06 00 	mov.b	r14,	6(r12)	;

00009092 <.Loc.253.1>:
  req->buffer = buffer;
    9092:	8c 49 08 00 	mov	r9,	8(r12)	;

00009096 <.Loc.254.1>:
  req->callback = fram_block_cb;
    9096:	bc 40 3c 8f 	mov	#-28868,10(r12)	;#0x8f3c, 0x000a
    909a:	0a 00 

0000909c <.Loc.257.1>:
  
  /* TODO handle failure */
  elyFramPostRequest(req);
    909c:	b0 12 c0 ae 	call	#-20800	;#0xaec0

000090a0 <.LVL36>:
}
    90a0:	31 50 06 00 	add	#6,	r1	;
    90a4:	16 17       	popm	#2,	r7	;16-bit words
    90a6:	19 17       	popm	#2,	r10	;16-bit words
    90a8:	30 41       	ret			

000090aa <elyClampReg>:

uint8_t elyClampReg(uint8_t addr, uint8_t value) {
    90aa:	4e 4c       	mov.b	r12,	r14	;
    90ac:	4c 4d       	mov.b	r13,	r12	;

000090ae <.LVL38>:
  switch(addr) {
    90ae:	7e 90 19 00 	cmp.b	#25,	r14	;#0x0019
    90b2:	b6 25       	jz	$+878    	;abs 0x9420
    90b4:	7f 40 19 00 	mov.b	#25,	r15	;#0x0019
    90b8:	4f 9e       	cmp.b	r14,	r15	;
    90ba:	5f 28       	jnc	$+192    	;abs 0x917a
    90bc:	7e 92       	cmp.b	#8,	r14	;r2 As==11
    90be:	52 25       	jz	$+678    	;abs 0x9364
    90c0:	7f 42       	mov.b	#8,	r15	;r2 As==11
    90c2:	4f 9e       	cmp.b	r14,	r15	;
    90c4:	30 28       	jnc	$+98     	;abs 0x9126
    90c6:	7e 90 03 00 	cmp.b	#3,	r14	;
    90ca:	00 25       	jz	$+514    	;abs 0x92cc
    90cc:	7f 40 03 00 	mov.b	#3,	r15	;
    90d0:	4f 9e       	cmp.b	r14,	r15	;
    90d2:	0f 28       	jnc	$+32     	;abs 0x90f2
    90d4:	3f 40 fa be 	mov	#-16646,r15	;#0xbefa
    90d8:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    90da:	da 24       	jz	$+438    	;abs 0x9290
    90dc:	5d 43       	mov.b	#1,	r13	;r3 As==01

000090de <.LVL39>:
    90de:	4d 9e       	cmp.b	r14,	r13	;
    90e0:	b3 2c       	jc	$+360    	;abs 0x9248

000090e2 <.Loc.285.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MIN_HMB) {
        value = clamp(value, TX_BAND_MIN_LMB, 0xFF);
      }
      break;
    case RegTXFreqHmb:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB) {
    90e2:	5d 4f 03 00 	mov.b	3(r15),	r13	;
    90e6:	7d 90 1c 00 	cmp.b	#28,	r13	;#0x001c
    90ea:	e9 20       	jnz	$+468    	;abs 0x92be

000090ec <.L61>:
        value = clamp(value, 0, TX_BAND_MAX_HMB);
    90ec:	7e 40 03 00 	mov.b	#3,	r14	;

000090f0 <.LVL40>:
    90f0:	ba 3c       	jmp	$+374    	;abs 0x9266

000090f2 <.L18>:
  switch(addr) {
    90f2:	7e 90 05 00 	cmp.b	#5,	r14	;
    90f6:	0e 25       	jz	$+542    	;abs 0x9314
    90f8:	7e 90 05 00 	cmp.b	#5,	r14	;
    90fc:	ec 28       	jnc	$+474    	;abs 0x92d6
    90fe:	7e 90 06 00 	cmp.b	#6,	r14	;
    9102:	1f 25       	jz	$+576    	;abs 0x9342
    9104:	7e 90 07 00 	cmp.b	#7,	r14	;
    9108:	2a 25       	jz	$+598    	;abs 0x935e

0000910a <.L12>:
    case RegPATempWARN:
    case RegPATempERR:
      value = clamps(value, TEMP_MIN, TEMP_MAX);
      break;
    default:
      if (addr > 0x80 && addr < 0xBF) {
    910a:	4d 4e       	mov.b	r14,	r13	;
    910c:	7d 50 7f 00 	add.b	#127,	r13	;#0x007f
    9110:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    9114:	4f 9d       	cmp.b	r13,	r15	;
    9116:	02 2c       	jc	$+6      	;abs 0x911c
    9118:	80 00 2a 95 	mova	#38186,	r0	;0x0952a

0000911c <.Loc.498.1>:
        value = elyNLClampReg(addr, value);
    911c:	4d 4c       	mov.b	r12,	r13	;
    911e:	4c 4e       	mov.b	r14,	r12	;

00009120 <.LVL43>:
    9120:	b0 12 00 a9 	call	#-22272	;#0xa900

00009124 <.LVL44>:
    9124:	b2 3c       	jmp	$+358    	;abs 0x928a

00009126 <.L16>:
  switch(addr) {
    9126:	7e 90 0c 00 	cmp.b	#12,	r14	;#0x000c
    912a:	48 25       	jz	$+658    	;abs 0x93bc
    912c:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    9130:	4f 9e       	cmp.b	r14,	r15	;
    9132:	09 28       	jnc	$+20     	;abs 0x9146
    9134:	7e 90 0a 00 	cmp.b	#10,	r14	;#0x000a
    9138:	3d 25       	jz	$+636    	;abs 0x93b4
    913a:	7d 40 0a 00 	mov.b	#10,	r13	;#0x000a

0000913e <.LVL46>:
    913e:	4d 9e       	cmp.b	r14,	r13	;
    9140:	29 2d       	jc	$+596    	;abs 0x9394

00009142 <.L42>:
      value = clamp(value, RX_BR_MIN_MSB, RX_BR_MAX_MSB);
    9142:	4e 43       	clr.b	r14		;
    9144:	90 3c       	jmp	$+290    	;abs 0x9266

00009146 <.L27>:
  switch(addr) {
    9146:	7e 90 0e 00 	cmp.b	#14,	r14	;#0x000e
    914a:	5d 25       	jz	$+700    	;abs 0x9406
    914c:	7e 90 0e 00 	cmp.b	#14,	r14	;#0x000e
    9150:	4c 29       	jnc	$+666    	;abs 0x93ea
    9152:	7e 90 0f 00 	cmp.b	#15,	r14	;#0x000f
    9156:	f5 27       	jz	$-20     	;abs 0x9142
    9158:	7e 90 18 00 	cmp.b	#24,	r14	;#0x0018
    915c:	d6 23       	jnz	$-82     	;abs 0x910a

0000915e <.Loc.395.1>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    915e:	c2 93 15 bf 	cmp.b	#0,	&0xbf15	;r3 As==00
    9162:	2b 21       	jnz	$+600    	;abs 0x93ba

00009164 <.Loc.396.1>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB &&
    9164:	5d 42 14 bf 	mov.b	&0xbf14,r13	;0xbf14

00009168 <.LVL48>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    9168:	2d 92       	cmp	#4,	r13	;r2 As==10
    916a:	51 21       	jnz	$+676    	;abs 0x940e

0000916c <.Loc.396.1>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB &&
    916c:	f2 90 93 ff 	cmp.b	#-109,	&0xbf13	;#0xff93
    9170:	13 bf 
    9172:	23 21       	jnz	$+584    	;abs 0x93ba

00009174 <.Loc.398.1>:
        value = clamp(value, 0, TX_BR_MAX_LSB);
    9174:	7e 40 e0 ff 	mov.b	#-32,	r14	;#0xffe0
    9178:	76 3c       	jmp	$+238    	;abs 0x9266

0000917a <.L14>:
  switch(addr) {
    917a:	7e 90 24 00 	cmp.b	#36,	r14	;#0x0024
    917e:	8a 25       	jz	$+790    	;abs 0x9494
    9180:	7f 40 24 00 	mov.b	#36,	r15	;#0x0024
    9184:	4f 9e       	cmp.b	r14,	r15	;
    9186:	2b 28       	jnc	$+88     	;abs 0x91de
    9188:	7e 90 1d 00 	cmp.b	#29,	r14	;#0x001d
    918c:	66 25       	jz	$+718    	;abs 0x945a
    918e:	7f 40 1d 00 	mov.b	#29,	r15	;#0x001d
    9192:	4f 9e       	cmp.b	r14,	r15	;
    9194:	15 28       	jnc	$+44     	;abs 0x91c0
    9196:	7e 90 1b 00 	cmp.b	#27,	r14	;#0x001b
    919a:	d3 27       	jz	$-88     	;abs 0x9142
    919c:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b

000091a0 <.LVL50>:
    91a0:	4d 9e       	cmp.b	r14,	r13	;
    91a2:	4d 2d       	jc	$+668    	;abs 0x943e

000091a4 <.Loc.428.1>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    91a4:	c2 93 19 bf 	cmp.b	#0,	&0xbf19	;r3 As==00
    91a8:	08 21       	jnz	$+530    	;abs 0x93ba

000091aa <.Loc.429.1>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB &&
    91aa:	5d 42 18 bf 	mov.b	&0xbf18,r13	;0xbf18

000091ae <.Loc.428.1>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    91ae:	2d 93       	cmp	#2,	r13	;r3 As==10
    91b0:	4a 21       	jnz	$+662    	;abs 0x9446

000091b2 <.Loc.429.1>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB &&
    91b2:	f2 90 49 00 	cmp.b	#73,	&0xbf17	;#0x0049
    91b6:	17 bf 
    91b8:	00 21       	jnz	$+514    	;abs 0x93ba

000091ba <.Loc.431.1>:
        value = clamp(value, 0, RX_BR_MAX_LSB);
    91ba:	7e 40 f0 ff 	mov.b	#-16,	r14	;#0xfff0
    91be:	53 3c       	jmp	$+168    	;abs 0x9266

000091c0 <.L38>:
  switch(addr) {
    91c0:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    91c4:	be 27       	jz	$-130    	;abs 0x9142
    91c6:	7e 90 1f 00 	cmp.b	#31,	r14	;#0x001f
    91ca:	57 29       	jnc	$+688    	;abs 0x947a
    91cc:	7e 90 21 00 	cmp.b	#33,	r14	;#0x0021
    91d0:	59 25       	jz	$+692    	;abs 0x9484
    91d2:	7e 90 22 00 	cmp.b	#34,	r14	;#0x0022
    91d6:	99 23       	jnz	$-204    	;abs 0x910a

000091d8 <.L45>:
      value = clamp(value, 1, 0xFF);
    91d8:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    91da:	5d 43       	mov.b	#1,	r13	;r3 As==01
    91dc:	54 3c       	jmp	$+170    	;abs 0x9286

000091de <.L36>:
  switch(addr) {
    91de:	7e 90 3a 00 	cmp.b	#58,	r14	;#0x003a
    91e2:	58 25       	jz	$+690    	;abs 0x9494
    91e4:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    91e8:	4f 9e       	cmp.b	r14,	r15	;
    91ea:	10 28       	jnc	$+34     	;abs 0x920c
    91ec:	7f 40 33 00 	mov.b	#51,	r15	;#0x0033
    91f0:	4f 9e       	cmp.b	r14,	r15	;
    91f2:	08 28       	jnc	$+18     	;abs 0x9204
    91f4:	7e 90 2a 00 	cmp.b	#42,	r14	;#0x002a
    91f8:	50 2d       	jc	$+674    	;abs 0x949a
    91fa:	7e 90 25 00 	cmp.b	#37,	r14	;#0x0025
    91fe:	85 23       	jnz	$-244    	;abs 0x910a

00009200 <.L77>:
      return 0; /* this is purely efficiency */
    9200:	4c 43       	clr.b	r12		;
    9202:	db 3c       	jmp	$+440    	;abs 0x93ba

00009204 <.L47>:
  switch(addr) {
    9204:	7e 90 38 00 	cmp.b	#56,	r14	;#0x0038
    9208:	e7 27       	jz	$-48     	;abs 0x91d8
    920a:	7f 3f       	jmp	$-256    	;abs 0x910a

0000920c <.L46>:
    920c:	7e 90 40 00 	cmp.b	#64,	r14	;#0x0040
    9210:	9d 24       	jz	$+316    	;abs 0x934c
    9212:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    9216:	4f 9e       	cmp.b	r14,	r15	;
    9218:	04 28       	jnc	$+10     	;abs 0x9222
    921a:	7e 90 3b 00 	cmp.b	#59,	r14	;#0x003b
    921e:	f0 27       	jz	$-30     	;abs 0x9200
    9220:	74 3f       	jmp	$-278    	;abs 0x910a

00009222 <.L51>:
    9222:	4d 4e       	mov.b	r14,	r13	;

00009224 <.LVL56>:
    9224:	7d 50 ba ff 	add.b	#-70,	r13	;#0xffba
    9228:	7f 40 05 00 	mov.b	#5,	r15	;
    922c:	4f 9d       	cmp.b	r13,	r15	;
    922e:	6d 2b       	jnc	$-292    	;abs 0x910a

00009230 <.LBB42>:
  if ((int8_t)(value) < min) {
    9230:	4d 4c       	mov.b	r12,	r13	;
    9232:	8d 11       	sxt	r13		;
    9234:	7d 90 b0 ff 	cmp.b	#-80,	r13	;#0xffb0
    9238:	6d 35       	jge	$+732    	;abs 0x9514

0000923a <.Loc.195.1>:
    elyErrorSignal(ErrRegClip);
    923a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000923e <.LVL58>:
    923e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009242 <.LVL59>:
    value = (uint8_t)(min);
    9242:	7c 40 b0 00 	mov.b	#176,	r12	;#0x00b0
    9246:	b9 3c       	jmp	$+372    	;abs 0x93ba

00009248 <.L132>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    9248:	5d 4f 03 00 	mov.b	3(r15),	r13	;
    924c:	7d 90 1c 00 	cmp.b	#28,	r13	;#0x001c
    9250:	0c 20       	jnz	$+26     	;abs 0x926a

00009252 <.Loc.263.1>:
    9252:	f2 90 03 00 	cmp.b	#3,	&0xbefc	;
    9256:	fc be 
    9258:	b0 20       	jnz	$+354    	;abs 0x93ba

0000925a <.Loc.264.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MAX_HMB &&
    925a:	f2 90 a1 ff 	cmp.b	#-95,	&0xbefb	;#0xffa1
    925e:	fb be 
    9260:	ac 20       	jnz	$+346    	;abs 0x93ba

00009262 <.Loc.266.1>:
        value = clamp(value, 0, TX_BAND_MAX_LSB);
    9262:	7e 40 80 ff 	mov.b	#-128,	r14	;#0xff80

00009266 <.L138>:
        value = clamp(value, 0, RX_BR_MAX_LSB);
    9266:	4d 43       	clr.b	r13		;
    9268:	0e 3c       	jmp	$+30     	;abs 0x9286

0000926a <.L53>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    926a:	7d 90 19 00 	cmp.b	#25,	r13	;#0x0019
    926e:	a5 20       	jnz	$+332    	;abs 0x93ba

00009270 <.Loc.268.1>:
    9270:	f2 90 cf ff 	cmp.b	#-49,	&0xbefc	;#0xffcf
    9274:	fc be 
    9276:	a1 20       	jnz	$+324    	;abs 0x93ba

00009278 <.Loc.269.1>:
          bank0p[RegTXFreqHmb] == TX_BAND_MIN_HMB &&
    9278:	f2 90 0e 00 	cmp.b	#14,	&0xbefb	;#0x000e
    927c:	fb be 
    927e:	9d 20       	jnz	$+316    	;abs 0x93ba

00009280 <.Loc.271.1>:
        value = clamp(value, TX_BAND_MIN_LSB, 0xFF);
    9280:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9282:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040

00009286 <.L137>:
        value = clamp(value, 0, RX_BR_MAX_LSB);
    9286:	b0 12 e2 8e 	call	#-28958	;#0x8ee2

0000928a <.L139>:
    928a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000928e <.LVL63>:
    928e:	95 3c       	jmp	$+300    	;abs 0x93ba

00009290 <.L19>:
      if (bank0p[RegTXFreqMsb] == TX_BAND_MAX_MSB && 
    9290:	5d 4f 03 00 	mov.b	3(r15),	r13	;

00009294 <.LVL65>:
    9294:	7d 90 1c 00 	cmp.b	#28,	r13	;#0x001c
    9298:	07 20       	jnz	$+16     	;abs 0x92a8

0000929a <.Loc.275.1>:
    929a:	f2 90 03 00 	cmp.b	#3,	&0xbefc	;
    929e:	fc be 
    92a0:	8c 20       	jnz	$+282    	;abs 0x93ba

000092a2 <.Loc.277.1>:
        value = clamp(value, 0, TX_BAND_MAX_LMB);
    92a2:	7e 40 a1 ff 	mov.b	#-95,	r14	;#0xffa1
    92a6:	df 3f       	jmp	$-64     	;abs 0x9266

000092a8 <.L54>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB && 
    92a8:	7d 90 19 00 	cmp.b	#25,	r13	;#0x0019
    92ac:	86 20       	jnz	$+270    	;abs 0x93ba

000092ae <.Loc.279.1>:
    92ae:	f2 90 cf ff 	cmp.b	#-49,	&0xbefc	;#0xffcf
    92b2:	fc be 
    92b4:	82 20       	jnz	$+262    	;abs 0x93ba

000092b6 <.Loc.281.1>:
        value = clamp(value, TX_BAND_MIN_LMB, 0xFF);
    92b6:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    92b8:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    92bc:	e4 3f       	jmp	$-54     	;abs 0x9286

000092be <.L55>:
      else if (bank0p[RegTXFreqMsb] == TX_BAND_MIN_MSB) {
    92be:	7d 90 19 00 	cmp.b	#25,	r13	;#0x0019
    92c2:	7b 20       	jnz	$+248    	;abs 0x93ba

000092c4 <.Loc.289.1>:
        value = clamp(value, TX_BAND_MIN_HMB, 0xFF);
    92c4:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    92c6:	7d 40 cf ff 	mov.b	#-49,	r13	;#0xffcf
    92ca:	dd 3f       	jmp	$-68     	;abs 0x9286

000092cc <.L17>:
      value = clamp(value, TX_BAND_MIN_MSB, TX_BAND_MAX_MSB);
    92cc:	7e 40 1c 00 	mov.b	#28,	r14	;#0x001c

000092d0 <.L140>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    92d0:	7d 40 19 00 	mov.b	#25,	r13	;#0x0019

000092d4 <.LVL67>:
    92d4:	d8 3f       	jmp	$-78     	;abs 0x9286

000092d6 <.L23>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    92d6:	5d 42 01 bf 	mov.b	&0xbf01,r13	;0xbf01

000092da <.LVL69>:
    92da:	f2 90 1a 00 	cmp.b	#26,	&0xbf01	;#0x001a
    92de:	01 bf 
    92e0:	0a 20       	jnz	$+22     	;abs 0x92f6

000092e2 <.Loc.296.1>:
    92e2:	e2 92 00 bf 	cmp.b	#4,	&0xbf00	;r2 As==10
    92e6:	69 20       	jnz	$+212    	;abs 0x93ba

000092e8 <.Loc.297.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MAX_HMB &&
    92e8:	f2 90 76 00 	cmp.b	#118,	&0xbeff	;#0x0076
    92ec:	ff be 
    92ee:	65 20       	jnz	$+204    	;abs 0x93ba

000092f0 <.Loc.299.1>:
        value = clamp(value, 0, RX_BAND_MAX_LSB);
    92f0:	7e 40 20 00 	mov.b	#32,	r14	;#0x0020
    92f4:	b8 3f       	jmp	$-142    	;abs 0x9266

000092f6 <.L56>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    92f6:	7d 90 19 00 	cmp.b	#25,	r13	;#0x0019
    92fa:	5f 20       	jnz	$+192    	;abs 0x93ba

000092fc <.Loc.301.1>:
    92fc:	f2 90 b8 ff 	cmp.b	#-72,	&0xbf00	;#0xffb8
    9300:	00 bf 
    9302:	5b 20       	jnz	$+184    	;abs 0x93ba

00009304 <.Loc.302.1>:
          bank0p[RegRXFreqHmb] == RX_BAND_MIN_HMB &&
    9304:	f2 90 2a 00 	cmp.b	#42,	&0xbeff	;#0x002a
    9308:	ff be 
    930a:	57 20       	jnz	$+176    	;abs 0x93ba

0000930c <.Loc.304.1>:
        value = clamp(value, RX_BAND_MIN_LSB, 0xFF);
    930c:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    930e:	7d 40 e0 ff 	mov.b	#-32,	r13	;#0xffe0
    9312:	b9 3f       	jmp	$-140    	;abs 0x9286

00009314 <.L22>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB && 
    9314:	5d 42 01 bf 	mov.b	&0xbf01,r13	;0xbf01

00009318 <.LVL71>:
    9318:	f2 90 1a 00 	cmp.b	#26,	&0xbf01	;#0x001a
    931c:	01 bf 
    931e:	06 20       	jnz	$+14     	;abs 0x932c

00009320 <.Loc.308.1>:
    9320:	e2 92 00 bf 	cmp.b	#4,	&0xbf00	;r2 As==10
    9324:	4a 20       	jnz	$+150    	;abs 0x93ba

00009326 <.Loc.310.1>:
        value = clamp(value, 0, RX_BAND_MAX_LMB);
    9326:	7e 40 76 00 	mov.b	#118,	r14	;#0x0076
    932a:	9d 3f       	jmp	$-196    	;abs 0x9266

0000932c <.L57>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB && 
    932c:	7d 90 19 00 	cmp.b	#25,	r13	;#0x0019
    9330:	44 20       	jnz	$+138    	;abs 0x93ba

00009332 <.Loc.312.1>:
    9332:	f2 90 b8 ff 	cmp.b	#-72,	&0xbf00	;#0xffb8
    9336:	00 bf 
    9338:	40 20       	jnz	$+130    	;abs 0x93ba

0000933a <.Loc.314.1>:
        value = clamp(value, RX_BAND_MIN_LMB, 0xFF);
    933a:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    933c:	7d 40 2a 00 	mov.b	#42,	r13	;#0x002a
    9340:	a2 3f       	jmp	$-186    	;abs 0x9286

00009342 <.L24>:
      if (bank0p[RegRXFreqMsb] == RX_BAND_MAX_MSB) {
    9342:	5d 42 01 bf 	mov.b	&0xbf01,r13	;0xbf01

00009346 <.LVL73>:
    9346:	3d 90 1a 00 	cmp	#26,	r13	;#0x001a
    934a:	02 20       	jnz	$+6      	;abs 0x9350

0000934c <.L50>:
      value = clamp(value, 0, 4);
    934c:	6e 42       	mov.b	#4,	r14	;r2 As==10
    934e:	8b 3f       	jmp	$-232    	;abs 0x9266

00009350 <.L58>:
      else if (bank0p[RegRXFreqMsb] == RX_BAND_MIN_MSB) {
    9350:	3d 90 19 00 	cmp	#25,	r13	;#0x0019
    9354:	32 20       	jnz	$+102    	;abs 0x93ba

00009356 <.Loc.322.1>:
        value = clamp(value, RX_BAND_MIN_HMB, 0xFF);
    9356:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9358:	7d 40 b8 ff 	mov.b	#-72,	r13	;#0xffb8
    935c:	94 3f       	jmp	$-214    	;abs 0x9286

0000935e <.L25>:
      value = clamp(value, RX_BAND_MIN_MSB, RX_BAND_MAX_MSB);
    935e:	7e 40 1a 00 	mov.b	#26,	r14	;#0x001a
    9362:	b6 3f       	jmp	$-146    	;abs 0x92d0

00009364 <.L15>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    9364:	c2 93 05 bf 	cmp.b	#0,	&0xbf05	;r3 As==00
    9368:	28 20       	jnz	$+82     	;abs 0x93ba

0000936a <.Loc.330.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB &&
    936a:	5d 42 04 bf 	mov.b	&0xbf04,r13	;0xbf04

0000936e <.LVL75>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    936e:	3d 90 03 00 	cmp	#3,	r13	;
    9372:	07 20       	jnz	$+16     	;abs 0x9382

00009374 <.Loc.330.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB &&
    9374:	f2 90 0d 00 	cmp.b	#13,	&0xbf03	;#0x000d
    9378:	03 bf 
    937a:	1f 20       	jnz	$+64     	;abs 0x93ba

0000937c <.L63>:
        value = clamp(value, 0, TX_DEV_MAX_LSB);
    937c:	7e 40 40 00 	mov.b	#64,	r14	;#0x0040
    9380:	72 3f       	jmp	$-282    	;abs 0x9266

00009382 <.L59>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    9382:	0d 93       	cmp	#0,	r13	;r3 As==00
    9384:	1a 20       	jnz	$+54     	;abs 0x93ba

00009386 <.Loc.335.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MIN_HMB &&
    9386:	e2 93 03 bf 	cmp.b	#2,	&0xbf03	;r3 As==10
    938a:	17 20       	jnz	$+48     	;abs 0x93ba

0000938c <.Loc.337.1>:
        value = clamp(value, TX_DEV_MIN_LSB, 0xFF);
    938c:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    938e:	7d 40 58 00 	mov.b	#88,	r13	;#0x0058
    9392:	79 3f       	jmp	$-268    	;abs 0x9286

00009394 <.L133>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    9394:	c2 93 05 bf 	cmp.b	#0,	&0xbf05	;r3 As==00
    9398:	10 20       	jnz	$+34     	;abs 0x93ba

0000939a <.Loc.342.1>:
          bank0p[RegTXDevHmb] == TX_DEV_MAX_HMB) {
    939a:	5d 42 04 bf 	mov.b	&0xbf04,r13	;0xbf04

0000939e <.Loc.341.1>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB && 
    939e:	3d 90 03 00 	cmp	#3,	r13	;
    93a2:	03 20       	jnz	$+8      	;abs 0x93aa

000093a4 <.L64>:
        value = clamp(value, 0, TX_DEV_MAX_LMB);
    93a4:	7e 40 0d 00 	mov.b	#13,	r14	;#0x000d
    93a8:	5e 3f       	jmp	$-322    	;abs 0x9266

000093aa <.L60>:
      else if (bank0p[RegTXDevMsb] == TX_DEV_MIN_MSB && 
    93aa:	0d 93       	cmp	#0,	r13	;r3 As==00
    93ac:	06 20       	jnz	$+14     	;abs 0x93ba

000093ae <.Loc.347.1>:
        value = clamp(value, TX_DEV_MIN_LMB, 0xFF);
    93ae:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    93b0:	6d 43       	mov.b	#2,	r13	;r3 As==10
    93b2:	69 3f       	jmp	$-300    	;abs 0x9286

000093b4 <.L28>:
      if (bank0p[RegTXDevMsb] == TX_DEV_MAX_MSB) {
    93b4:	c2 93 05 bf 	cmp.b	#0,	&0xbf05	;r3 As==00
    93b8:	99 26       	jz	$-716    	;abs 0x90ec

000093ba <.L49>:
        value = elyDLLClampReg(addr, value);
      }
      /* Other Core Registers have ranges equal to their data type's */
  }
  return value;
}
    93ba:	30 41       	ret			

000093bc <.L26>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    93bc:	c2 93 09 bf 	cmp.b	#0,	&0xbf09	;r3 As==00
    93c0:	fc 23       	jnz	$-6      	;abs 0x93ba

000093c2 <.Loc.363.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB &&
    93c2:	5d 42 08 bf 	mov.b	&0xbf08,r13	;0xbf08

000093c6 <.LVL79>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    93c6:	3d 90 03 00 	cmp	#3,	r13	;
    93ca:	05 20       	jnz	$+12     	;abs 0x93d6

000093cc <.Loc.363.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB &&
    93cc:	f2 90 0d 00 	cmp.b	#13,	&0xbf07	;#0x000d
    93d0:	07 bf 
    93d2:	f3 23       	jnz	$-24     	;abs 0x93ba
    93d4:	d3 3f       	jmp	$-88     	;abs 0x937c

000093d6 <.L62>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    93d6:	0d 93       	cmp	#0,	r13	;r3 As==00
    93d8:	f0 23       	jnz	$-30     	;abs 0x93ba

000093da <.Loc.368.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MIN_HMB &&
    93da:	f2 90 80 ff 	cmp.b	#-128,	&0xbf07	;#0xff80
    93de:	07 bf 
    93e0:	ec 23       	jnz	$-38     	;abs 0x93ba

000093e2 <.Loc.370.1>:
        value = clamp(value, RX_DEV_MIN_LSB, 0xFF);
    93e2:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    93e4:	7d 40 e8 ff 	mov.b	#-24,	r13	;#0xffe8
    93e8:	4e 3f       	jmp	$-354    	;abs 0x9286

000093ea <.L32>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    93ea:	c2 93 09 bf 	cmp.b	#0,	&0xbf09	;r3 As==00
    93ee:	e5 23       	jnz	$-52     	;abs 0x93ba

000093f0 <.Loc.375.1>:
          bank0p[RegRXDevHmb] == RX_DEV_MAX_HMB) {
    93f0:	5d 42 08 bf 	mov.b	&0xbf08,r13	;0xbf08

000093f4 <.LVL81>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB && 
    93f4:	3d 90 03 00 	cmp	#3,	r13	;
    93f8:	d5 27       	jz	$-84     	;abs 0x93a4

000093fa <.Loc.378.1>:
      else if (bank0p[RegRXDevMsb] == RX_DEV_MIN_MSB && 
    93fa:	0d 93       	cmp	#0,	r13	;r3 As==00
    93fc:	de 23       	jnz	$-66     	;abs 0x93ba

000093fe <.Loc.380.1>:
        value = clamp(value, RX_DEV_MIN_LMB, 0xFF);
    93fe:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9400:	7d 40 80 ff 	mov.b	#-128,	r13	;#0xff80
    9404:	40 3f       	jmp	$-382    	;abs 0x9286

00009406 <.L31>:
      if (bank0p[RegRXDevMsb] == RX_DEV_MAX_MSB) {
    9406:	c2 93 09 bf 	cmp.b	#0,	&0xbf09	;r3 As==00
    940a:	d7 23       	jnz	$-80     	;abs 0x93ba
    940c:	6f 3e       	jmp	$-800    	;abs 0x90ec

0000940e <.L65>:
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    940e:	0d 93       	cmp	#0,	r13	;r3 As==00
    9410:	d4 23       	jnz	$-86     	;abs 0x93ba

00009412 <.Loc.401.1>:
          bank0p[RegTXBRHmb] == TX_BR_MIN_HMB &&
    9412:	e2 92 13 bf 	cmp.b	#4,	&0xbf13	;r2 As==10
    9416:	d1 23       	jnz	$-92     	;abs 0x93ba

00009418 <.Loc.403.1>:
        value = clamp(value, TX_BR_MIN_LSB, 0xFF);
    9418:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    941a:	7d 40 b0 ff 	mov.b	#-80,	r13	;#0xffb0
    941e:	33 3f       	jmp	$-408    	;abs 0x9286

00009420 <.L13>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    9420:	c2 93 15 bf 	cmp.b	#0,	&0xbf15	;r3 As==00
    9424:	ca 23       	jnz	$-106    	;abs 0x93ba

00009426 <.Loc.408.1>:
          bank0p[RegTXBRHmb] == TX_BR_MAX_HMB) {
    9426:	5d 42 14 bf 	mov.b	&0xbf14,r13	;0xbf14

0000942a <.LVL85>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB && 
    942a:	2d 92       	cmp	#4,	r13	;r2 As==10
    942c:	03 20       	jnz	$+8      	;abs 0x9434

0000942e <.Loc.409.1>:
        value = clamp(value, 0, TX_BR_MAX_LMB);
    942e:	7e 40 93 ff 	mov.b	#-109,	r14	;#0xff93
    9432:	19 3f       	jmp	$-460    	;abs 0x9266

00009434 <.L66>:
      else if (bank0p[RegTXBRMsb] == TX_BR_MIN_MSB && 
    9434:	0d 93       	cmp	#0,	r13	;r3 As==00
    9436:	c1 23       	jnz	$-124    	;abs 0x93ba

00009438 <.Loc.413.1>:
        value = clamp(value, TX_BR_MIN_LMB, 0xFF);
    9438:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    943a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    943c:	24 3f       	jmp	$-438    	;abs 0x9286

0000943e <.L134>:
      if (bank0p[RegTXBRMsb] == TX_BR_MAX_MSB) {
    943e:	c2 93 15 bf 	cmp.b	#0,	&0xbf15	;r3 As==00
    9442:	bb 23       	jnz	$-136    	;abs 0x93ba
    9444:	83 3f       	jmp	$-248    	;abs 0x934c

00009446 <.L68>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    9446:	0d 93       	cmp	#0,	r13	;r3 As==00
    9448:	b8 23       	jnz	$-142    	;abs 0x93ba

0000944a <.Loc.434.1>:
          bank0p[RegRXBRHmb] == RX_BR_MIN_HMB &&
    944a:	f2 90 03 00 	cmp.b	#3,	&0xbf17	;
    944e:	17 bf 
    9450:	b4 23       	jnz	$-150    	;abs 0x93ba

00009452 <.Loc.436.1>:
        value = clamp(value, RX_BR_MIN_LSB, 0xFF);
    9452:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9454:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    9458:	16 3f       	jmp	$-466    	;abs 0x9286

0000945a <.L37>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    945a:	c2 93 19 bf 	cmp.b	#0,	&0xbf19	;r3 As==00
    945e:	ad 23       	jnz	$-164    	;abs 0x93ba

00009460 <.Loc.441.1>:
          bank0p[RegRXBRHmb] == RX_BR_MAX_HMB) {
    9460:	5d 42 18 bf 	mov.b	&0xbf18,r13	;0xbf18

00009464 <.LVL87>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB && 
    9464:	2d 93       	cmp	#2,	r13	;r3 As==10
    9466:	03 20       	jnz	$+8      	;abs 0x946e

00009468 <.Loc.442.1>:
        value = clamp(value, 0, RX_BR_MAX_LMB);
    9468:	7e 40 49 00 	mov.b	#73,	r14	;#0x0049
    946c:	fc 3e       	jmp	$-518    	;abs 0x9266

0000946e <.L69>:
      else if (bank0p[RegRXBRMsb] == RX_BR_MIN_MSB && 
    946e:	0d 93       	cmp	#0,	r13	;r3 As==00
    9470:	a4 23       	jnz	$-182    	;abs 0x93ba

00009472 <.Loc.446.1>:
        value = clamp(value, RX_BR_MIN_LMB, 0xFF);
    9472:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    9474:	7d 40 03 00 	mov.b	#3,	r13	;
    9478:	06 3f       	jmp	$-498    	;abs 0x9286

0000947a <.L43>:
      if (bank0p[RegRXBRMsb] == RX_BR_MAX_MSB) {
    947a:	c2 93 19 bf 	cmp.b	#0,	&0xbf19	;r3 As==00
    947e:	9d 23       	jnz	$-196    	;abs 0x93ba

00009480 <.Loc.451.1>:
        value = clamp(value, 0, RX_BR_MAX_HMB);
    9480:	6e 43       	mov.b	#2,	r14	;r3 As==10
    9482:	f1 3e       	jmp	$-540    	;abs 0x9266

00009484 <.L44>:
      value = clamp(value, (15.8 - FIXED_ATTEN)*5, TX_POW_MAX);
    9484:	4e 43       	clr.b	r14		;
    9486:	7d 40 4f 00 	mov.b	#79,	r13	;#0x004f

0000948a <.LVL89>:
    948a:	b0 12 e2 8e 	call	#-28958	;#0x8ee2

0000948e <.LVL90>:
    948e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00009492 <.LVL91>:
    9492:	a2 3e       	jmp	$-698    	;abs 0x91d8

00009494 <.L35>:
      value = clamp(value, 0, UART_BAUD_MAX_HMB);
    9494:	7e 40 0f 00 	mov.b	#15,	r14	;#0x000f
    9498:	e6 3e       	jmp	$-562    	;abs 0x9266

0000949a <.L48>:
  if ((value & 0x10) && value != 0x10) {
    949a:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    949e:	0a 24       	jz	$+22     	;abs 0x94b4
    94a0:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    94a4:	07 24       	jz	$+16     	;abs 0x94b4

000094a6 <.Loc.166.1>:
    elyErrorSignal(ErrRegClip);
    94a6:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000094aa <.LVL94>:
    94aa:	b0 12 5a ac 	call	#-21414	;#0xac5a

000094ae <.LVL95>:
    return 0x10;
    94ae:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    94b2:	83 3f       	jmp	$-248    	;abs 0x93ba

000094b4 <.L70>:
  if ((value & 0x08) && value != 0x08) {
    94b4:	3c b2       	bit	#8,	r12	;r2 As==11
    94b6:	08 24       	jz	$+18     	;abs 0x94c8
    94b8:	3c 92       	cmp	#8,	r12	;r2 As==11
    94ba:	06 24       	jz	$+14     	;abs 0x94c8

000094bc <.Loc.170.1>:
    elyErrorSignal(ErrRegClip);
    94bc:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000094c0 <.LVL97>:
    94c0:	b0 12 5a ac 	call	#-21414	;#0xac5a

000094c4 <.LVL98>:
    return 0x08;
    94c4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    94c6:	79 3f       	jmp	$-268    	;abs 0x93ba

000094c8 <.L71>:
  if ((value & 0x04) && value != 0x04) {
    94c8:	2c b2       	bit	#4,	r12	;r2 As==10
    94ca:	08 24       	jz	$+18     	;abs 0x94dc
    94cc:	2c 92       	cmp	#4,	r12	;r2 As==10
    94ce:	06 24       	jz	$+14     	;abs 0x94dc

000094d0 <.Loc.174.1>:
    elyErrorSignal(ErrRegClip);
    94d0:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000094d4 <.LVL100>:
    94d4:	b0 12 5a ac 	call	#-21414	;#0xac5a

000094d8 <.LVL101>:
    return 0x04;
    94d8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    94da:	6f 3f       	jmp	$-288    	;abs 0x93ba

000094dc <.L72>:
  if ((value & 0x02) && value != 0x02) {
    94dc:	2c b3       	bit	#2,	r12	;r3 As==10
    94de:	08 24       	jz	$+18     	;abs 0x94f0
    94e0:	2c 93       	cmp	#2,	r12	;r3 As==10
    94e2:	06 24       	jz	$+14     	;abs 0x94f0

000094e4 <.Loc.178.1>:
    elyErrorSignal(ErrRegClip);
    94e4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000094e8 <.LVL103>:
    94e8:	b0 12 5a ac 	call	#-21414	;#0xac5a

000094ec <.LVL104>:
    return 0x02;
    94ec:	6c 43       	mov.b	#2,	r12	;r3 As==10
    94ee:	65 3f       	jmp	$-308    	;abs 0x93ba

000094f0 <.L73>:
  if ((value & 0x01) && value != 0x01) {
    94f0:	1c b3       	bit	#1,	r12	;r3 As==01
    94f2:	08 24       	jz	$+18     	;abs 0x9504
    94f4:	1c 93       	cmp	#1,	r12	;r3 As==01
    94f6:	06 24       	jz	$+14     	;abs 0x9504

000094f8 <.Loc.182.1>:
    elyErrorSignal(ErrRegClip);
    94f8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

000094fc <.LVL106>:
    94fc:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009500 <.LVL107>:
    return 0x01;
    9500:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9502:	5b 3f       	jmp	$-328    	;abs 0x93ba

00009504 <.L74>:
  if (value & 0xD0) {
    9504:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    9508:	58 27       	jz	$-334    	;abs 0x93ba

0000950a <.Loc.186.1>:
    elyErrorSignal(ErrRegClip);
    950a:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000950e <.LVL109>:
    950e:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009512 <.LVL110>:
    9512:	76 3e       	jmp	$-786    	;abs 0x9200

00009514 <.L75>:
  else if ((int8_t)(value) > max) {
    9514:	7e 40 7d 00 	mov.b	#125,	r14	;#0x007d
    9518:	4e 9d       	cmp.b	r13,	r14	;
    951a:	4f 37       	jge	$-352    	;abs 0x93ba

0000951c <.Loc.199.1>:
    elyErrorSignal(ErrRegClip);
    951c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009520 <.LVL112>:
    9520:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009524 <.LVL113>:
    value = (uint8_t)(max);
    9524:	7c 40 7d 00 	mov.b	#125,	r12	;#0x007d
    9528:	48 3f       	jmp	$-366    	;abs 0x93ba

0000952a <.L76>:
      else if (addr > 0xC0) {
    952a:	7d 40 c0 ff 	mov.b	#-64,	r13	;#0xffc0
    952e:	4d 9e       	cmp.b	r14,	r13	;
    9530:	44 2f       	jc	$-374    	;abs 0x93ba

00009532 <.Loc.501.1>:
        value = elyDLLClampReg(addr, value);
    9532:	4d 4c       	mov.b	r12,	r13	;
    9534:	4c 4e       	mov.b	r14,	r12	;
    9536:	b0 12 b8 9c 	call	#-25416	;#0x9cb8

0000953a <L0>:
    953a:	a7 3e       	jmp	$-688    	;abs 0x928a

0000953c <elyRegGet>:
    953c:	4a 15       	pushm	#5,	r10	;16-bit words

0000953e <.LCFI7>:

bool elyRegGet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    953e:	48 4c       	mov.b	r12,	r8	;
    9540:	49 4e       	mov.b	r14,	r9	;

00009542 <.Loc.509.1>:
  regs_in_progress = n;
    9542:	c2 49 66 cd 	mov.b	r9,	&0xcd66	;

00009546 <.LVL117>:
    9546:	0a 4d       	mov	r13,	r10	;

00009548 <.LBB56>:
  
  for (int i = 0; i < n; i++) {
    9548:	0c 4d       	mov	r13,	r12	;

0000954a <.L142>:
    954a:	0e 4c       	mov	r12,	r14	;
    954c:	0e 8d       	sub	r13,	r14	;
    954e:	0e 99       	cmp	r9,	r14	;
    9550:	0e 38       	jl	$+30     	;abs 0x956e
    9552:	09 5d       	add	r13,	r9	;

00009554 <.LBE56>:
        (addr >= RegDLLMAX)) {
      return false; /* other bits handled outside */
    }
  }
  
  if (bank == 0) {
    9554:	08 93       	cmp	#0,	r8	;r3 As==00
    9556:	2d 24       	jz	$+92     	;abs 0x95b2

00009558 <.LBB58>:
  else {
    for (int i = 0; i < n; i++) {
      uint8_t addr = buffer[i];
  
      /* Get the register */
      fram_reg(1, bank, addr, (buffer+i-1));
    9558:	37 40 5c 8f 	mov	#-28836,r7	;#0x8f5c
    955c:	56 43       	mov.b	#1,	r6	;r3 As==01

0000955e <.L146>:
    for (int i = 0; i < n; i++) {
    955e:	0a 99       	cmp	r9,	r10	;
    9560:	2d 20       	jnz	$+92     	;abs 0x95bc

00009562 <.LBB61>:
  return chSemWaitTimeout(&bsp->sem, time);
    9562:	4d 43       	clr.b	r13		;
    9564:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    9568:	b0 12 e2 47 	call	#18402		;#0x47e2

0000956c <.LVL122>:
    956c:	24 3c       	jmp	$+74     	;abs 0x95b6

0000956e <.L144>:
    uint8_t addr = buffer[i];
    956e:	6f 4c       	mov.b	@r12,	r15	;

00009570 <.LVL124>:
    if ((bank > 4) ||
    9570:	67 42       	mov.b	#4,	r7	;r2 As==10
    9572:	47 98       	cmp.b	r8,	r7	;
    9574:	17 28       	jnc	$+48     	;abs 0x95a4

00009576 <.Loc.515.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    9576:	4e 4f       	mov.b	r15,	r14	;
    9578:	7e 50 aa ff 	add.b	#-86,	r14	;#0xffaa

0000957c <.Loc.514.1>:
    if ((bank > 4) ||
    957c:	77 40 09 00 	mov.b	#9,	r7	;
    9580:	47 9e       	cmp.b	r14,	r7	;
    9582:	10 2c       	jc	$+34     	;abs 0x95a4

00009584 <.Loc.516.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9584:	7e 50 df ff 	add.b	#-33,	r14	;#0xffdf

00009588 <.Loc.515.1>:
        (addr >= RegCoreMAX && addr < 0x60) ||
    9588:	77 42       	mov.b	#8,	r7	;r2 As==11
    958a:	47 9e       	cmp.b	r14,	r7	;
    958c:	0b 2c       	jc	$+24     	;abs 0x95a4

0000958e <.Loc.517.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    958e:	7e 50 ed ff 	add.b	#-19,	r14	;#0xffed

00009592 <.Loc.516.1>:
        (addr >= RegSpecialMAX && addr < 0x80) ||
    9592:	77 40 35 00 	mov.b	#53,	r7	;#0x0035
    9596:	47 9e       	cmp.b	r14,	r7	;
    9598:	05 2c       	jc	$+12     	;abs 0x95a4
    959a:	1c 53       	inc	r12		;

0000959c <.LVL125>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    959c:	7e 40 d4 ff 	mov.b	#-44,	r14	;#0xffd4
    95a0:	4e 9f       	cmp.b	r15,	r14	;
    95a2:	d3 2f       	jc	$-88     	;abs 0x954a

000095a4 <.L154>:
      return false; /* other bits handled outside */
    95a4:	4c 43       	clr.b	r12		;
    95a6:	08 3c       	jmp	$+18     	;abs 0x95b8

000095a8 <.L148>:
      *(buffer+i-1) = bank0p[addr];
    95a8:	6c 4a       	mov.b	@r10,	r12	;
    95aa:	da 4c fa be 	mov.b	-16646(r12),-1(r10)	;0xffffbefa, 0xffff
    95ae:	ff ff 

000095b0 <.LVL128>:
    95b0:	1a 53       	inc	r10		;

000095b2 <.L147>:
    for (int i = 0; i < n; i++) {
    95b2:	0a 99       	cmp	r9,	r10	;
    95b4:	f9 23       	jnz	$-12     	;abs 0x95a8

000095b6 <.L156>:
    /* Wait for all writes to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    95b6:	5c 43       	mov.b	#1,	r12	;r3 As==01

000095b8 <.L143>:
}
    95b8:	46 17       	popm	#5,	r10	;16-bit words
    95ba:	30 41       	ret			

000095bc <.L149>:
      fram_reg(1, bank, addr, (buffer+i-1));
    95bc:	0f 4a       	mov	r10,	r15	;
    95be:	3f 53       	add	#-1,	r15	;r3 As==11
    95c0:	6e 4a       	mov.b	@r10,	r14	;
    95c2:	4d 48       	mov.b	r8,	r13	;
    95c4:	4c 46       	mov.b	r6,	r12	;
    95c6:	87 12       	call	r7		;

000095c8 <.LVL132>:
    95c8:	1a 53       	inc	r10		;

000095ca <.LVL133>:
    95ca:	c9 3f       	jmp	$-108    	;abs 0x955e

000095cc <elyRegSet>:
    95cc:	6a 15       	pushm	#7,	r10	;16-bit words

000095ce <.LCFI8>:

bool elyRegSet(uint8_t bank, uint8_t * buffer, uint8_t n) {
    95ce:	21 83       	decd	r1		;

000095d0 <.LCFI9>:
    95d0:	47 4c       	mov.b	r12,	r7	;

000095d2 <L0>:
    95d2:	09 4d       	mov	r13,	r9	;
    95d4:	4a 4e       	mov.b	r14,	r10	;

000095d6 <.Loc.545.1>:
  regs_in_progress = n;
    95d6:	c2 4a 66 cd 	mov.b	r10,	&0xcd66	;

000095da <.LBB73>:
  
  for (int i = 0; i < n * 2; i += 2) {
    95da:	0a 5a       	rla	r10		;
    95dc:	0c 4d       	mov	r13,	r12	;

000095de <.LBB74>:
    uint8_t addr = buffer[i];
    
    if ((bank == 0) || (bank > 4) ||
    95de:	4e 47       	mov.b	r7,	r14	;

000095e0 <.LVL137>:
    95e0:	7e 53       	add.b	#-1,	r14	;r3 As==11

000095e2 <.L158>:
  for (int i = 0; i < n * 2; i += 2) {
    95e2:	0d 4c       	mov	r12,	r13	;
    95e4:	0d 89       	sub	r9,	r13	;
    95e6:	0d 9a       	cmp	r10,	r13	;
    95e8:	14 38       	jl	$+42     	;abs 0x9612
    95ea:	04 49       	mov	r9,	r4	;
    95ec:	14 53       	inc	r4		;

000095ee <.Loc.547.1>:
    95ee:	08 49       	mov	r9,	r8	;

000095f0 <.LBB76>:
  }

  for (int i = 0; i < n * 2; i += 2) {
    uint8_t addr = buffer[i];
    uint8_t value = buffer[i+1];
    value = elyClampReg(addr, value);
    95f0:	36 40 aa 90 	mov	#-28502,r6	;#0x90aa

000095f4 <.Loc.564.1>:
  
    /* Write the register */
    fram_reg(0, bank, addr, &buffer[i+1]);
    95f4:	35 40 5c 8f 	mov	#-28836,r5	;#0x8f5c

000095f8 <.L161>:
  for (int i = 0; i < n * 2; i += 2) {
    95f8:	0c 48       	mov	r8,	r12	;
    95fa:	0c 89       	sub	r9,	r12	;
    95fc:	0c 9a       	cmp	r10,	r12	;
    95fe:	22 38       	jl	$+70     	;abs 0x9644

00009600 <.LBB79>:
    9600:	4d 43       	clr.b	r13		;
    9602:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    9606:	b0 12 e2 47 	call	#18402		;#0x47e2

0000960a <.LBE79>:
  
  /* Wait for all writes to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    960a:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000960c <.L159>:
}
    960c:	21 53       	incd	r1		;
    960e:	64 17       	popm	#7,	r10	;16-bit words
    9610:	30 41       	ret			

00009612 <.L160>:
    uint8_t addr = buffer[i];
    9612:	6d 4c       	mov.b	@r12,	r13	;

00009614 <.LVL144>:
    if ((bank == 0) || (bank > 4) ||
    9614:	78 40 03 00 	mov.b	#3,	r8	;
    9618:	48 9e       	cmp.b	r14,	r8	;
    961a:	12 28       	jnc	$+38     	;abs 0x9640

0000961c <.Loc.551.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    961c:	4f 4d       	mov.b	r13,	r15	;
    961e:	7f 50 aa ff 	add.b	#-86,	r15	;#0xffaa

00009622 <.Loc.550.1>:
    if ((bank == 0) || (bank > 4) ||
    9622:	78 40 29 00 	mov.b	#41,	r8	;#0x0029
    9626:	48 9f       	cmp.b	r15,	r8	;
    9628:	0b 2c       	jc	$+24     	;abs 0x9640

0000962a <.Loc.552.1>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    962a:	7f 50 cc ff 	add.b	#-52,	r15	;#0xffcc

0000962e <.Loc.551.1>:
        (addr >= RegCoreMAX && addr < 0x80) ||
    962e:	78 40 35 00 	mov.b	#53,	r8	;#0x0035
    9632:	48 9f       	cmp.b	r15,	r8	;
    9634:	05 2c       	jc	$+12     	;abs 0x9640
    9636:	2c 53       	incd	r12		;

00009638 <.LVL145>:
        (addr >= RegNLMAX && addr < 0xC0) ||
    9638:	7f 40 d4 ff 	mov.b	#-44,	r15	;#0xffd4
    963c:	4f 9d       	cmp.b	r13,	r15	;
    963e:	d1 2f       	jc	$-92     	;abs 0x95e2

00009640 <.L166>:
      return false; /* other bits handled outside */
    9640:	4c 43       	clr.b	r12		;
    9642:	e4 3f       	jmp	$-54     	;abs 0x960c

00009644 <.L162>:
    uint8_t addr = buffer[i];
    9644:	6e 48       	mov.b	@r8,	r14	;

00009646 <.LVL148>:
    value = elyClampReg(addr, value);
    9646:	6d 44       	mov.b	@r4,	r13	;
    9648:	4c 4e       	mov.b	r14,	r12	;
    964a:	81 4e 00 00 	mov	r14,	0(r1)	;

0000964e <.LVL149>:
    964e:	86 12       	call	r6		;

00009650 <.LVL150>:
    fram_reg(0, bank, addr, &buffer[i+1]);
    9650:	0f 44       	mov	r4,	r15	;
    9652:	2e 41       	mov	@r1,	r14	;
    9654:	4d 47       	mov.b	r7,	r13	;
    9656:	4c 43       	clr.b	r12		;
    9658:	85 12       	call	r5		;

0000965a <.LVL151>:
    965a:	28 53       	incd	r8		;

0000965c <.LVL152>:
    965c:	24 53       	incd	r4		;
    965e:	cc 3f       	jmp	$-102    	;abs 0x95f8

00009660 <elyRegGetBlock>:
    9660:	0a 15       	pushm	#1,	r10	;16-bit words

00009662 <.LCFI10>:

bool elyRegGetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    9662:	21 83       	decd	r1		;

00009664 <L0>:
    9664:	4b 4c       	mov.b	r12,	r11	;
    9666:	0c 4d       	mov	r13,	r12	;

00009668 <.LVL154>:
    9668:	4d 4e       	mov.b	r14,	r13	;

0000966a <.LVL155>:
    966a:	4e 4f       	mov.b	r15,	r14	;

0000966c <.LVL156>:
  
  if (bank > 4 || 
    966c:	6a 42       	mov.b	#4,	r10	;r2 As==10
    966e:	4a 9b       	cmp.b	r11,	r10	;
    9670:	35 28       	jnc	$+108    	;abs 0x96dc

00009672 <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    9672:	3f 40 57 00 	mov	#87,	r15	;#0x0057
    9676:	0f 8e       	sub	r14,	r15	;

00009678 <.LVL157>:
  if (bank > 4 || 
    9678:	0d 9f       	cmp	r15,	r13	;
    967a:	04 38       	jl	$+10     	;abs 0x9684

0000967c <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    967c:	7f 40 5f 00 	mov.b	#95,	r15	;#0x005f
    9680:	4f 9d       	cmp.b	r13,	r15	;
    9682:	2c 2c       	jc	$+90     	;abs 0x96dc

00009684 <.L169>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    9684:	4f 4d       	mov.b	r13,	r15	;
    9686:	7f 50 89 ff 	add.b	#-119,	r15	;#0xff89

0000968a <.Loc.577.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x60) ||
    968a:	7a 42       	mov.b	#8,	r10	;r2 As==11
    968c:	4a 9f       	cmp.b	r15,	r10	;
    968e:	26 2c       	jc	$+78     	;abs 0x96dc

00009690 <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9690:	3f 40 8b 00 	mov	#139,	r15	;#0x008b
    9694:	0f 8e       	sub	r14,	r15	;

00009696 <.Loc.578.1>:
      (addr >= RegSpecialMAX && addr < 0x80) ||
    9696:	0d 9f       	cmp	r15,	r13	;
    9698:	04 38       	jl	$+10     	;abs 0x96a2

0000969a <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    969a:	7f 40 bf ff 	mov.b	#-65,	r15	;#0xffbf
    969e:	4f 9d       	cmp.b	r13,	r15	;
    96a0:	1d 2c       	jc	$+60     	;abs 0x96dc

000096a2 <.L170>:
      (addr >= RegDLLMAX - n + 1)) {
    96a2:	3f 40 d6 00 	mov	#214,	r15	;#0x00d6
    96a6:	0f 8e       	sub	r14,	r15	;

000096a8 <.Loc.579.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    96a8:	0d 9f       	cmp	r15,	r13	;
    96aa:	18 34       	jge	$+50     	;abs 0x96dc

000096ac <.Loc.584.1>:
    return false; /* Other bits handled outside */
  }
  
  if (bank == 0) {
    96ac:	0b 93       	cmp	#0,	r11	;r3 As==00
    96ae:	08 20       	jnz	$+18     	;abs 0x96c0

000096b0 <.Loc.585.1>:
    memcpy(buffer, bank0p + addr, n);
    96b0:	3d 50 fa be 	add	#-16646,r13	;#0xbefa

000096b4 <.LVL158>:
    96b4:	b0 12 f4 b0 	call	#-20236	;#0xb0f4

000096b8 <.L177>:
    /* Wait for the write to complete */
    /* TODO timeout for safety */
    chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  }
  
  return true;
    96b8:	5c 43       	mov.b	#1,	r12	;r3 As==01

000096ba <.L168>:
}
    96ba:	21 53       	incd	r1		;
    96bc:	0a 17       	popm	#1,	r10	;16-bit words
    96be:	30 41       	ret			

000096c0 <.L171>:
    fram_block(1, bank, addr, buffer, n);
    96c0:	c1 4e 00 00 	mov.b	r14,	0(r1)	;
    96c4:	0f 4c       	mov	r12,	r15	;
    96c6:	4e 4d       	mov.b	r13,	r14	;
    96c8:	4d 4b       	mov.b	r11,	r13	;
    96ca:	5c 43       	mov.b	#1,	r12	;r3 As==01

000096cc <.LVL161>:
    96cc:	b0 12 e6 8f 	call	#-28698	;#0x8fe6

000096d0 <.LBB85>:
    96d0:	4d 43       	clr.b	r13		;
    96d2:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    96d6:	b0 12 e2 47 	call	#18402		;#0x47e2

000096da <.LVL163>:
    96da:	ee 3f       	jmp	$-34     	;abs 0x96b8

000096dc <.L176>:
    return false; /* Other bits handled outside */
    96dc:	4c 43       	clr.b	r12		;

000096de <.LVL165>:
    96de:	ed 3f       	jmp	$-36     	;abs 0x96ba

000096e0 <elyRegSetBlock>:
    96e0:	6a 15       	pushm	#7,	r10	;16-bit words

000096e2 <.LCFI12>:

bool elyRegSetBlock(uint8_t bank, uint8_t * buffer, uint8_t addr, uint8_t n) {
    96e2:	21 83       	decd	r1		;

000096e4 <L0>:
    96e4:	44 4c       	mov.b	r12,	r4	;
    96e6:	06 4d       	mov	r13,	r6	;
    96e8:	4a 4e       	mov.b	r14,	r10	;
    96ea:	49 4f       	mov.b	r15,	r9	;

000096ec <.Loc.600.1>:
  
  if (bank == 0 || bank > 4 || 
    96ec:	4c 44       	mov.b	r4,	r12	;

000096ee <.LVL167>:
    96ee:	7c 53       	add.b	#-1,	r12	;r3 As==11
    96f0:	7d 40 03 00 	mov.b	#3,	r13	;

000096f4 <.LVL168>:
    96f4:	4d 9c       	cmp.b	r12,	r13	;
    96f6:	38 28       	jnc	$+114    	;abs 0x9768

000096f8 <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    96f8:	3c 40 57 00 	mov	#87,	r12	;#0x0057
    96fc:	0c 89       	sub	r9,	r12	;

000096fe <.Loc.600.1>:
  if (bank == 0 || bank > 4 || 
    96fe:	0a 9c       	cmp	r12,	r10	;
    9700:	02 38       	jl	$+6      	;abs 0x9706

00009702 <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    9702:	4a 93       	cmp.b	#0,	r10	;r3 As==00
    9704:	31 34       	jge	$+100    	;abs 0x9768

00009706 <.L180>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9706:	3c 40 8b 00 	mov	#139,	r12	;#0x008b
    970a:	0c 89       	sub	r9,	r12	;

0000970c <.Loc.601.1>:
      (addr >= RegCoreMAX - n + 1 && addr < 0x80) ||
    970c:	0a 9c       	cmp	r12,	r10	;
    970e:	04 38       	jl	$+10     	;abs 0x9718

00009710 <.Loc.602.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    9710:	7c 40 bf ff 	mov.b	#-65,	r12	;#0xffbf
    9714:	4c 9a       	cmp.b	r10,	r12	;
    9716:	28 2c       	jc	$+82     	;abs 0x9768

00009718 <.L181>:
      (addr >= RegDLLMAX - n + 1)) {
    9718:	3c 40 d6 00 	mov	#214,	r12	;#0x00d6
    971c:	0c 89       	sub	r9,	r12	;

0000971e <.Loc.602.1>:
      (addr >= RegNLMAX - n + 1 && addr < 0xC0) ||
    971e:	0a 9c       	cmp	r12,	r10	;
    9720:	23 34       	jge	$+72     	;abs 0x9768

00009722 <.Loc.602.1>:
    9722:	07 4a       	mov	r10,	r7	;
    9724:	08 46       	mov	r6,	r8	;

00009726 <.LBB90>:
    return false; /* Other bits handled outside */
  }
  
  for (int i = 0; i < n; i++) {
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    9726:	35 40 aa 90 	mov	#-28502,r5	;#0x90aa

0000972a <.L182>:
  for (int i = 0; i < n; i++) {
    972a:	0c 48       	mov	r8,	r12	;
    972c:	0c 86       	sub	r6,	r12	;

0000972e <.LVL170>:
    972e:	0c 99       	cmp	r9,	r12	;
    9730:	11 38       	jl	$+36     	;abs 0x9754

00009732 <.LBE90>:
  }
  
  /* Write the block */
  fram_block(0, bank, addr, buffer, n);
    9732:	c1 49 00 00 	mov.b	r9,	0(r1)	;
    9736:	0f 46       	mov	r6,	r15	;
    9738:	4e 4a       	mov.b	r10,	r14	;
    973a:	4d 44       	mov.b	r4,	r13	;
    973c:	4c 43       	clr.b	r12		;

0000973e <.LVL171>:
    973e:	b0 12 e6 8f 	call	#-28698	;#0x8fe6

00009742 <.LBB91>:
    9742:	4d 43       	clr.b	r13		;
    9744:	3c 40 68 cd 	mov	#-12952,r12	;#0xcd68
    9748:	b0 12 e2 47 	call	#18402		;#0x47e2

0000974c <.LBE91>:
  
  /* Wait for the write to complete */
  /* TODO timeout for safety */
  chBSemWaitTimeout(&regs_sem, TIME_INFINITE);
  
  return true;
    974c:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000974e <.L179>:
}
    974e:	21 53       	incd	r1		;
    9750:	64 17       	popm	#7,	r10	;16-bit words
    9752:	30 41       	ret			

00009754 <.L183>:
    buffer[i] = elyClampReg(addr + i, buffer[i]);
    9754:	6d 48       	mov.b	@r8,	r13	;
    9756:	4c 47       	mov.b	r7,	r12	;

00009758 <.LVL176>:
    9758:	85 12       	call	r5		;

0000975a <.LVL177>:
    975a:	c8 4c 00 00 	mov.b	r12,	0(r8)	;

0000975e <.LVL178>:
    975e:	18 53       	inc	r8		;

00009760 <.LVL179>:
    9760:	57 53       	inc.b	r7		;
    9762:	37 f0 ff 00 	and	#255,	r7	;#0x00ff
    9766:	e1 3f       	jmp	$-60     	;abs 0x972a

00009768 <.L187>:
    return false; /* Other bits handled outside */
    9768:	4c 43       	clr.b	r12		;
    976a:	f1 3f       	jmp	$-28     	;abs 0x974e

0000976c <calc_next_buff>:
    976c:	1a 15       	pushm	#2,	r10	;16-bit words

0000976e <.LCFI0>:

static thread_t * uart_thd;
    
void calc_next_buff(void) {
  
  switch (tx_state) {
    976e:	5c 42       	mov.b,		r12	;Warning: disassembly unreliable - not enough bytes available

00009770 <L0>:
    9770:	a4 1e 5c 93 	rpt r4 { cmpx.a	#1,	r12	;r3 As==01
    9774:	2f 24       	jz	$+96     	;abs 0x97d4
    9776:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9778:	1a 20       	jnz	$+54     	;abs 0x97ae

0000977a <.Loc.28.1>:
    case ELY_SLIP_NOT_ESCAPED:
      next_tx_ptr = tx_read_ptr;
    977a:	1f 42 72 cd 	mov	&0xcd72,r15	;0xcd72
    977e:	82 4f 6e cd 	mov	r15,	&0xcd6e	;

00009782 <.Loc.29.1>:
      next_cnt = 0;
    9782:	82 43 70 cd 	mov	#0,	&0xcd70	;r3 As==00

00009786 <.Loc.30.1>:
      while (next_cnt != tx_n && 
    9786:	1b 42 74 cd 	mov	&0xcd74,r11	;0xcd74
    978a:	0c 4f       	mov	r15,	r12	;
    978c:	4e 43       	clr.b	r14		;
    978e:	59 43       	mov.b	#1,	r9	;r3 As==01

00009790 <.L5>:
    9790:	0d 4c       	mov	r12,	r13	;
    9792:	0d 8f       	sub	r15,	r13	;
    9794:	0b 9d       	cmp	r13,	r11	;
    9796:	0d 20       	jnz	$+28     	;abs 0x97b2
    9798:	0e 93       	cmp	#0,	r14	;r3 As==00
    979a:	04 24       	jz	$+10     	;abs 0x97a4
    979c:	82 4b 70 cd 	mov	r11,	&0xcd70	;
    97a0:	82 4c 72 cd 	mov	r12,	&0xcd72	;

000097a4 <.L7>:
    97a4:	0d 4b       	mov	r11,	r13	;

000097a6 <.L10>:
          *tx_read_ptr != SLIP_END && 
          *tx_read_ptr != SLIP_ESC) {
        next_cnt++;
        tx_read_ptr++;
      }
      tx_state = ELY_SLIP_ESCAPED;
    97a6:	d2 43 a4 1e 	mov.b	#1,	&0x1ea4	;r3 As==01

000097aa <.Loc.37.1>:
      if (next_cnt > 0) {
    97aa:	0d 93       	cmp	#0,	r13	;r3 As==00
    97ac:	13 24       	jz	$+40     	;abs 0x97d4

000097ae <.L1>:
      chDbgAssert(false, "State machine error");
      /* ACTUALLY can't happen */
      break;
  }
            
}
    97ae:	19 17       	popm	#2,	r10	;16-bit words
    97b0:	30 41       	ret			

000097b2 <.L6>:
      while (next_cnt != tx_n && 
    97b2:	6a 4c       	mov.b	@r12,	r10	;
    97b4:	7a 90 c0 ff 	cmp.b	#-64,	r10	;#0xffc0
    97b8:	07 20       	jnz	$+16     	;abs 0x97c8

000097ba <.L31>:
    97ba:	0e 93       	cmp	#0,	r14	;r3 As==00
    97bc:	f4 27       	jz	$-22     	;abs 0x97a6
    97be:	82 4d 70 cd 	mov	r13,	&0xcd70	;
    97c2:	82 4c 72 cd 	mov	r12,	&0xcd72	;
    97c6:	ef 3f       	jmp	$-32     	;abs 0x97a6

000097c8 <.L8>:
          *tx_read_ptr != SLIP_END && 
    97c8:	7a 90 db ff 	cmp.b	#-37,	r10	;#0xffdb
    97cc:	f6 27       	jz	$-18     	;abs 0x97ba

000097ce <.Loc.34.1>:
        tx_read_ptr++;
    97ce:	1c 53       	inc	r12		;
    97d0:	0e 49       	mov	r9,	r14	;
    97d2:	de 3f       	jmp	$-66     	;abs 0x9790

000097d4 <.L3>:
        switch(*tx_read_ptr++) {
    97d4:	1c 42 72 cd 	mov	&0xcd72,r12	;0xcd72
    97d8:	0d 4c       	mov	r12,	r13	;
    97da:	1d 53       	inc	r13		;
    97dc:	82 4d 72 cd 	mov	r13,	&0xcd72	;
    97e0:	6c 4c       	mov.b	@r12,	r12	;
    97e2:	7c 90 c0 ff 	cmp.b	#-64,	r12	;#0xffc0
    97e6:	0d 24       	jz	$+28     	;abs 0x9802
    97e8:	7c 90 db ff 	cmp.b	#-37,	r12	;#0xffdb
    97ec:	0e 20       	jnz	$+30     	;abs 0x980a

000097ee <.Loc.44.1>:
            next_tx_ptr = SLIP_ESC_ESC_ESC;
    97ee:	b2 40 c4 bd 	mov	#-16956,&0xcd6e	;#0xbdc4
    97f2:	6e cd 

000097f4 <.L16>:
        next_cnt = 2;
    97f4:	a2 43 70 cd 	mov	#2,	&0xcd70	;r3 As==10

000097f8 <.Loc.58.1>:
        tx_n++; /* need another byte - sending 2 for 1 */
    97f8:	92 53 74 cd 	inc	&0xcd74		;

000097fc <.Loc.59.1>:
        tx_state = ELY_SLIP_NOT_ESCAPED;
    97fc:	e2 43 a4 1e 	mov.b	#2,	&0x1ea4	;r3 As==10

00009800 <.LBE32>:
}
    9800:	d6 3f       	jmp	$-82     	;abs 0x97ae

00009802 <.L14>:
            next_tx_ptr = SLIP_ESC_ESC_END;
    9802:	b2 40 c2 bd 	mov	#-16958,&0xcd6e	;#0xbdc2
    9806:	6e cd 
    9808:	f5 3f       	jmp	$-20     	;abs 0x97f4

0000980a <.L29>:
            tx_n--;
    980a:	b2 53 74 cd 	add	#-1,	&0xcd74	;r3 As==11
    980e:	f2 3f       	jmp	$-26     	;abs 0x97f4

00009810 <elyUARTDLLTxCB>:
    9810:	1a 15       	pushm	#2,	r10	;16-bit words

00009812 <.LCFI1>:

void elyUARTDLLTxCB(UARTDriver * uartp) {
    9812:	21 83       	decd	r1		;

00009814 <.LCFI2>:
  static bool done = false;
  static const uint8_t END = SLIP_END;
  
  if (done) {
    9814:	c2 93 6a cd 	cmp.b	#0,	&0xcd6a	;r3 As==00
    9818:	05 24       	jz	$+12     	;abs 0x9824

0000981a <L0>:
    done = false;
    981a:	c2 43 6a cd 	mov.b	#0,	&0xcd6a	;r3 As==00

0000981e <.L32>:
    next_cnt = 1;
    return;
  }
  
  calc_next_buff();
}
    981e:	21 53       	incd	r1		;
    9820:	19 17       	popm	#2,	r10	;16-bit words
    9822:	30 41       	ret			

00009824 <.L33>:
  chSysLockFromISR();
    9824:	39 40 98 44 	mov	#17560,	r9	;#0x4498
    9828:	81 4c 00 00 	mov	r12,	0(r1)	;
    982c:	89 12       	call	r9		;

0000982e <.LVL3>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    982e:	1e 42 6e cd 	mov	&0xcd6e,r14	;0xcd6e
    9832:	1d 42 70 cd 	mov	&0xcd70,r13	;0xcd70
    9836:	2c 41       	mov	@r1,	r12	;
    9838:	b0 12 cc 4c 	call	#19660		;#0x4ccc

0000983c <.LVL4>:
  chSysUnlockFromISR();
    983c:	3a 40 b8 44 	mov	#17592,	r10	;#0x44b8
    9840:	8a 12       	call	r10		;

00009842 <.LVL5>:
  if (tx_n == 0) {
    9842:	1c 42 74 cd 	mov	&0xcd74,r12	;0xcd74
    9846:	0c 93       	cmp	#0,	r12	;r3 As==00
    9848:	03 20       	jnz	$+8      	;abs 0x9850

0000984a <.Loc.84.1>:
    done = true;
    984a:	d2 43 6a cd 	mov.b	#1,	&0xcd6a	;r3 As==01

0000984e <.Loc.85.1>:
    return;
    984e:	e7 3f       	jmp	$-48     	;abs 0x981e

00009850 <.L35>:
  tx_n -= next_cnt;
    9850:	1c 82 70 cd 	sub	&0xcd70,r12	;0xcd70
    9854:	82 4c 74 cd 	mov	r12,	&0xcd74	;

00009858 <.Loc.90.1>:
  if (tx_n == 0) {
    9858:	0c 93       	cmp	#0,	r12	;r3 As==00
    985a:	0c 20       	jnz	$+26     	;abs 0x9874

0000985c <.Loc.91.1>:
    chSysLockFromISR();
    985c:	89 12       	call	r9		;

0000985e <.LVL6>:
    elyNLFreeBufferI(tx_active_buffer);
    985e:	1c 42 76 cd 	mov	&0xcd76,r12	;0xcd76
    9862:	b0 12 fa a9 	call	#-22022	;#0xa9fa

00009866 <.LVL7>:
    chSysUnlockFromISR();
    9866:	8a 12       	call	r10		;

00009868 <.LVL8>:
    next_tx_ptr = &END;
    9868:	b2 40 c1 bd 	mov	#-16959,&0xcd6e	;#0xbdc1
    986c:	6e cd 

0000986e <.Loc.95.1>:
    next_cnt = 1;
    986e:	92 43 70 cd 	mov	#1,	&0xcd70	;r3 As==01

00009872 <.Loc.96.1>:
    return;
    9872:	d5 3f       	jmp	$-84     	;abs 0x981e

00009874 <.L36>:
  calc_next_buff();
    9874:	b0 12 6c 97 	call	#-26772	;#0x976c

00009878 <.LVL9>:
    9878:	d2 3f       	jmp	$-90     	;abs 0x981e

0000987a <elyUARTDLLStartTx>:
    987a:	2a 15       	pushm	#3,	r10	;16-bit words

0000987c <.LCFI3>:

void elyUARTDLLStartTx(UARTDriver * uartp, uint8_t * buffer) {
    987c:	08 4c       	mov	r12,	r8	;
    987e:	0a 4d       	mov	r13,	r10	;

00009880 <L0>:
  static const uint8_t END = SLIP_END;
  /* Calculate the length of the packet - store it in n */
  tx_n = elyNLGetLength(buffer);
    9880:	0c 4d       	mov	r13,	r12	;

00009882 <.LVL11>:
    9882:	b0 12 ae aa 	call	#-21842	;#0xaaae

00009886 <.LVL12>:
    9886:	82 4c 74 cd 	mov	r12,	&0xcd74	;

0000988a <.Loc.107.1>:
  chDbgAssert(tx_n != 0 && tx_n < elyNLMaxLen, "invalid packet length");
  if (tx_n == 0 || tx_n > elyNLMaxLen) {
    988a:	0c 93       	cmp	#0,	r12	;r3 As==00
    988c:	03 24       	jz	$+8      	;abs 0x9894

0000988e <.Loc.107.1>:
    988e:	82 9c 82 c8 	cmp	r12,	&0xc882	;
    9892:	03 2c       	jc	$+8      	;abs 0x989a

00009894 <.L38>:
    /* TODO signal an error here */
    elyNLFreeBuffer(buffer);
    9894:	0c 4a       	mov	r10,	r12	;
    9896:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000989a <.L39>:
  }
  tx_read_ptr = buffer;
    989a:	82 4a 72 cd 	mov	r10,	&0xcd72	;

0000989e <.Loc.112.1>:
  tx_active_buffer = buffer;
    989e:	82 4a 76 cd 	mov	r10,	&0xcd76	;

000098a2 <.Loc.113.1>:
  tx_state = ELY_SLIP_NOT_ESCAPED;
    98a2:	e2 43 a4 1e 	mov.b	#2,	&0x1ea4	;r3 As==10

000098a6 <.Loc.115.1>:
  
  calc_next_buff();
    98a6:	39 40 6c 97 	mov	#-26772,r9	;#0x976c
    98aa:	89 12       	call	r9		;

000098ac <.LBB41>:
  _disable_interrupts();
    98ac:	32 c2       	dint			

000098ae <.Loc.348.2>:
  asm volatile("nop");
    98ae:	03 43       	nop			

000098b0 <.LBE41>:
  
  chSysLock();
    98b0:	b0 12 5a 44 	call	#17498		;#0x445a

000098b4 <.LVL15>:
  uartStartSendI(uartp, next_cnt, next_tx_ptr);
    98b4:	1e 42 6e cd 	mov	&0xcd6e,r14	;0xcd6e
    98b8:	1d 42 70 cd 	mov	&0xcd70,r13	;0xcd70
    98bc:	0c 48       	mov	r8,	r12	;
    98be:	b0 12 cc 4c 	call	#19660		;#0x4ccc

000098c2 <.LVL16>:
  
  tx_n -= next_cnt;
    98c2:	1c 42 74 cd 	mov	&0xcd74,r12	;0xcd74
    98c6:	1c 82 70 cd 	sub	&0xcd70,r12	;0xcd70
    98ca:	82 4c 74 cd 	mov	r12,	&0xcd74	;
    98ce:	3a 40 78 44 	mov	#17528,	r10	;#0x4478

000098d2 <.LVL17>:
  
  if (tx_n == 0) {
    98d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    98d4:	0f 20       	jnz	$+32     	;abs 0x98f4

000098d6 <.Loc.123.1>:
    elyNLFreeBufferI(tx_active_buffer);
    98d6:	1c 42 76 cd 	mov	&0xcd76,r12	;0xcd76
    98da:	b0 12 fa a9 	call	#-22022	;#0xa9fa

000098de <.LVL18>:
    next_tx_ptr = &END;
    98de:	b2 40 c0 bd 	mov	#-16960,&0xcd6e	;#0xbdc0
    98e2:	6e cd 

000098e4 <.Loc.125.1>:
    next_cnt = 1;
    98e4:	92 43 70 cd 	mov	#1,	&0xcd70	;r3 As==01

000098e8 <.L45>:
    chSysUnlock();
    return;
  }
  
  calc_next_buff();
  chSysUnlock();
    98e8:	8a 12       	call	r10		;

000098ea <.LBB43>:
  asm volatile("nop");
    98ea:	03 43       	nop			

000098ec <.Loc.356.2>:
  _enable_interrupts();
    98ec:	32 d2       	eint			
    98ee:	03 43       	nop			

000098f0 <.LBE43>:
  
}
    98f0:	28 17       	popm	#3,	r10	;16-bit words
    98f2:	30 41       	ret			

000098f4 <.L40>:
  calc_next_buff();
    98f4:	89 12       	call	r9		;

000098f6 <.LVL20>:
    98f6:	f8 3f       	jmp	$-14     	;abs 0x98e8

000098f8 <elyUARTDLLRxInit>:
    98f8:	92 42       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

000098fa <L0>:

void elyUARTDLLRxInit(UARTDriver * uartp) {
  (void)(uartp);
  
  /* allocate a working buffer from the main pool */
  uart_thd = chThdGetSelfX();
    98fa:	00 1c 6c cd 	bicx.a	@r13,	r12	;

000098fe <.Loc.140.1>:
}
    98fe:	30 41       	ret			

00009900 <elyUARTDLLRxHandleBuffer>:
    rx_state = ELY_SLIP_RESET;
  }

}

void elyUARTDLLRxHandleBuffer() {
    9900:	6a 15       	pushm	#7,	r10	;16-bit words

00009902 <.LCFI4>:
  handle_buffer(bytes_available, curr_rx_buf);
    9902:	18 42 78 cd 	mov	&0xcd78,r8	;0xcd78
    9906:	1a 42 a8 1e 	mov	&0x1ea8,r10	;0x1ea8

0000990a <.LBB48>:
  const uint8_t * end = buffer + bytes_available;
    990a:	05 4a       	mov	r10,	r5	;
    990c:	05 58       	add	r8,	r5	;

0000990e <.LBB50>:
        rx_active_buffer = elyNLGetBuffer();
    990e:	37 40 d6 a9 	mov	#-22058,r7	;#0xa9d6

00009912 <.Loc.240.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    9912:	34 40 ae aa 	mov	#-21842,r4	;#0xaaae

00009916 <.Loc.244.1>:
        elyNLFreeBuffer(rx_active_buffer);
    9916:	36 40 e0 a9 	mov	#-22048,r6	;#0xa9e0

0000991a <.L48>:
  while (cp < end) {
    991a:	0a 95       	cmp	r5,	r10	;
    991c:	0d 28       	jnc	$+28     	;abs 0x9938

0000991e <.Loc.251.1>:
  if (bytes_available < SLIP_RX_BUF_LEN) {
    991e:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    9922:	0c 98       	cmp	r8,	r12	;
    9924:	7a 28       	jnc	$+246    	;abs 0x9a1a

00009926 <.Loc.252.1>:
    elyNLFreeBuffer(rx_active_buffer);
    9926:	1c 42 7c cd 	mov	&0xcd7c,r12	;0xcd7c
    992a:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000992e <.LVL25>:
    rx_active_buffer = NULL;
    992e:	82 43 7c cd 	mov	#0,	&0xcd7c	;r3 As==00

00009932 <.Loc.254.1>:
    rx_state = ELY_SLIP_RESET;
    9932:	c2 43 7e cd 	mov.b	#0,	&0xcd7e	;r3 As==00
    9936:	71 3c       	jmp	$+228    	;abs 0x9a1a

00009938 <.L68>:
    uint8_t c = *cp;
    9938:	69 4a       	mov.b	@r10,	r9	;

0000993a <.LVL26>:
    if (rx_state == ELY_SLIP_RESET) {
    993a:	c2 93 7e cd 	cmp.b	#0,	&0xcd7e	;r3 As==00
    993e:	10 20       	jnz	$+34     	;abs 0x9960

00009940 <.Loc.159.1>:
      if (NULL == rx_active_buffer) {
    9940:	82 93 7c cd 	cmp	#0,	&0xcd7c	;r3 As==00
    9944:	03 20       	jnz	$+8      	;abs 0x994c

00009946 <.Loc.160.1>:
        rx_active_buffer = elyNLGetBuffer();
    9946:	87 12       	call	r7		;

00009948 <.LVL27>:
    9948:	82 4c 7c cd 	mov	r12,	&0xcd7c	;

0000994c <.L50>:
      rx_write_ptr = rx_active_buffer;
    994c:	92 42 7c cd 	mov	&0xcd7c,&0xcd7a	;0xcd7c
    9950:	7a cd 

00009952 <.Loc.163.1>:
      rx_n = elyNLHeaderLen;
    9952:	b2 40 06 00 	mov	#6,	&0x1ea2	;
    9956:	a2 1e 

00009958 <.Loc.164.1>:
      rx_state = ELY_SLIP_NOT_ESCAPED;
    9958:	e2 43 7e cd 	mov.b	#2,	&0xcd7e	;r3 As==10

0000995c <.Loc.165.1>:
      header = true;
    995c:	d2 43 a0 1e 	mov.b	#1,	&0x1ea0	;r3 As==01

00009960 <.L49>:
    switch (rx_state) {
    9960:	5c 42 7e cd 	mov.b	&0xcd7e,r12	;0xcd7e
    9964:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9966:	1c 24       	jz	$+58     	;abs 0x99a0
    9968:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    996a:	3c 24       	jz	$+122    	;abs 0x99e4

0000996c <.L51>:
    if (rx_n == 0 && header) { /* and we haven't reset */
    996c:	82 93 a2 1e 	cmp	#0,	&0x1ea2	;r3 As==00
    9970:	d4 23       	jnz	$-86     	;abs 0x991a
    9972:	c2 93 a0 1e 	cmp.b	#0,	&0x1ea0	;r3 As==00
    9976:	d1 27       	jz	$-92     	;abs 0x991a

00009978 <.Loc.240.1>:
      rx_n = elyNLGetLength(rx_active_buffer) - elyNLHeaderLen;
    9978:	1c 42 7c cd 	mov	&0xcd7c,r12	;0xcd7c
    997c:	84 12       	call	r4		;

0000997e <.LVL28>:
    997e:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa
    9982:	82 4c a2 1e 	mov	r12,	&0x1ea2	;

00009986 <.Loc.241.1>:
      header = false;
    9986:	c2 43 a0 1e 	mov.b	#0,	&0x1ea0	;r3 As==00

0000998a <.Loc.242.1>:
      if (rx_n == 0 || rx_n > elyNLMaxLen) {
    998a:	0c 93       	cmp	#0,	r12	;r3 As==00
    998c:	03 24       	jz	$+8      	;abs 0x9994
    998e:	82 9c 82 c8 	cmp	r12,	&0xc882	;
    9992:	c3 2f       	jc	$-120    	;abs 0x991a

00009994 <.L67>:
        elyNLFreeBuffer(rx_active_buffer);
    9994:	1c 42 7c cd 	mov	&0xcd7c,r12	;0xcd7c

00009998 <.L78>:
    9998:	86 12       	call	r6		;

0000999a <.LVL29>:
        rx_active_buffer = NULL;
    999a:	82 43 7c cd 	mov	#0,	&0xcd7c	;r3 As==00
    999e:	06 3c       	jmp	$+14     	;abs 0x99ac

000099a0 <.L52>:
          switch(c) {
    99a0:	79 90 dc ff 	cmp.b	#-36,	r9	;#0xffdc
    99a4:	06 24       	jz	$+14     	;abs 0x99b2
    99a6:	79 90 dd ff 	cmp.b	#-35,	r9	;#0xffdd
    99aa:	12 24       	jz	$+38     	;abs 0x99d0

000099ac <.L77>:
        rx_state = ELY_SLIP_RESET;
    99ac:	c2 43 7e cd 	mov.b	#0,	&0xcd7e	;r3 As==00
    99b0:	b4 3f       	jmp	$-150    	;abs 0x991a

000099b2 <.L55>:
              *rx_write_ptr++ = SLIP_END;
    99b2:	1c 42 7a cd 	mov	&0xcd7a,r12	;0xcd7a
    99b6:	0d 4c       	mov	r12,	r13	;
    99b8:	1d 53       	inc	r13		;
    99ba:	82 4d 7a cd 	mov	r13,	&0xcd7a	;
    99be:	fc 40 c0 ff 	mov.b	#-64,	0(r12)	;#0xffc0
    99c2:	00 00 

000099c4 <.L57>:
          rx_n--;
    99c4:	b2 53 a2 1e 	add	#-1,	&0x1ea2	;r3 As==11

000099c8 <.Loc.183.1>:
          rx_state = ELY_SLIP_NOT_ESCAPED;
    99c8:	e2 43 7e cd 	mov.b	#2,	&0xcd7e	;r3 As==10

000099cc <.L76>:
                cp++;
    99cc:	1a 53       	inc	r10		;
    99ce:	ce 3f       	jmp	$-98     	;abs 0x996c

000099d0 <.L56>:
              *rx_write_ptr++ = SLIP_ESC;
    99d0:	1c 42 7a cd 	mov	&0xcd7a,r12	;0xcd7a
    99d4:	0e 4c       	mov	r12,	r14	;
    99d6:	1e 53       	inc	r14		;
    99d8:	82 4e 7a cd 	mov	r14,	&0xcd7a	;
    99dc:	fc 40 db ff 	mov.b	#-37,	0(r12)	;#0xffdb
    99e0:	00 00 
    99e2:	f0 3f       	jmp	$-30     	;abs 0x99c4

000099e4 <.L53>:
          switch(c) {
    99e4:	79 90 c0 ff 	cmp.b	#-64,	r9	;#0xffc0
    99e8:	09 24       	jz	$+20     	;abs 0x99fc
    99ea:	79 90 db ff 	cmp.b	#-37,	r9	;#0xffdb
    99ee:	20 20       	jnz	$+66     	;abs 0x9a30

000099f0 <.Loc.191.1>:
              if (rx_n == 0) {
    99f0:	82 93 a2 1e 	cmp	#0,	&0x1ea2	;r3 As==00
    99f4:	db 27       	jz	$-72     	;abs 0x99ac

000099f6 <.Loc.196.1>:
                rx_state = ELY_SLIP_ESCAPED;
    99f6:	d2 43 7e cd 	mov.b	#1,	&0xcd7e	;r3 As==01
    99fa:	e8 3f       	jmp	$-46     	;abs 0x99cc

000099fc <.L60>:
    99fc:	1c 42 7c cd 	mov	&0xcd7c,r12	;0xcd7c

00009a00 <.Loc.201.1>:
              if (rx_n == 0) {
    9a00:	82 93 a2 1e 	cmp	#0,	&0x1ea2	;r3 As==00
    9a04:	c9 23       	jnz	$-108    	;abs 0x9998

00009a06 <.Loc.203.1>:
                elyMainMBPost(rx_active_buffer, TIME_INFINITE);
    9a06:	4d 43       	clr.b	r13		;
    9a08:	b0 12 3c 6d 	call	#27964		;#0x6d3c

00009a0c <.LVL31>:
                rx_active_buffer = elyNLGetBuffer();
    9a0c:	87 12       	call	r7		;

00009a0e <.LVL32>:
    9a0e:	82 4c 7c cd 	mov	r12,	&0xcd7c	;

00009a12 <.Loc.205.1>:
                if (rx_active_buffer == NULL) {
    9a12:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a14:	0b 20       	jnz	$+24     	;abs 0x9a2c

00009a16 <.Loc.207.1>:
                  rx_state = ELY_SLIP_RESET;
    9a16:	c2 4c 7e cd 	mov.b	r12,	&0xcd7e	;

00009a1a <.L65>:
  
  if (curr_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    9a1a:	b2 90 7f ce 	cmp	#-12673,&0x1ea8	;#0xce7f
    9a1e:	a8 1e 
    9a20:	1a 20       	jnz	$+54     	;abs 0x9a56

00009a22 <.Loc.263.1>:
    curr_rx_buf = rx_buf;
    9a22:	b2 40 7f cd 	mov	#-12929,&0x1ea8	;#0xcd7f
    9a26:	a8 1e 

00009a28 <.L47>:
  }
  else {
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
}
    9a28:	64 17       	popm	#7,	r10	;16-bit words
    9a2a:	30 41       	ret			

00009a2c <.L64>:
                cp++;
    9a2c:	1a 53       	inc	r10		;
    9a2e:	be 3f       	jmp	$-130    	;abs 0x99ac

00009a30 <.L75>:
              if (rx_n == 0) {
    9a30:	1c 42 a2 1e 	mov	&0x1ea2,r12	;0x1ea2
    9a34:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a36:	03 20       	jnz	$+8      	;abs 0x9a3e

00009a38 <.Loc.222.1>:
                rx_state = reset_state();
    9a38:	c2 4c 7e cd 	mov.b	r12,	&0xcd7e	;
    9a3c:	6e 3f       	jmp	$-290    	;abs 0x991a

00009a3e <.L66>:
                *rx_write_ptr++ = c;
    9a3e:	1d 42 7a cd 	mov	&0xcd7a,r13	;0xcd7a
    9a42:	0e 4d       	mov	r13,	r14	;
    9a44:	1e 53       	inc	r14		;
    9a46:	82 4e 7a cd 	mov	r14,	&0xcd7a	;
    9a4a:	cd 49 00 00 	mov.b	r9,	0(r13)	;

00009a4e <.Loc.227.1>:
                rx_n--;
    9a4e:	3c 53       	add	#-1,	r12	;r3 As==11
    9a50:	82 4c a2 1e 	mov	r12,	&0x1ea2	;
    9a54:	bb 3f       	jmp	$-136    	;abs 0x99cc

00009a56 <.L69>:
    curr_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9a56:	b2 40 7f ce 	mov	#-12673,&0x1ea8	;#0xce7f
    9a5a:	a8 1e 

00009a5c <.Loc.268.1>:
}
    9a5c:	e5 3f       	jmp	$-52     	;abs 0x9a28

00009a5e <elyUARTDLLTimeoutCB>:
    9a5e:	b0 12 98 44 	call	#17560		;#0x4498

00009a62 <.LVL38>:
/* TODO we might be able to refactor this out by signalling from 
 * the callbacks and using an S-class timeout API */
void elyUARTDLLTimeoutCB(GPTDriver * gptp) {
  (void)(gptp);
  chSysLockFromISR();
  size_t bytes_missed = uartStopReceiveI(&ELY_UART);
    9a62:	3c 40 d8 1c 	mov	#7384,	r12	;#0x1cd8
    9a66:	b0 12 1c 4d 	call	#19740		;#0x4d1c

00009a6a <.LVL39>:
  
  /* Count the number of bytes that are available */
  bytes_available = SLIP_RX_BUF_LEN - bytes_missed;
    9a6a:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9a6e:	0d 8c       	sub	r12,	r13	;
    9a70:	82 4d       	mov	r13		; Warning: disassembly unreliable - not enough bytes available

00009a72 <L0>:
    9a72:	78 cd       	bic.b	@r13+,	r8	;

00009a74 <.Loc.280.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    9a74:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9a76:	4e 43       	clr.b	r14		;
    9a78:	1c 42 6c cd 	mov	&0xcd6c,r12	;0xcd6c

00009a7c <.LVL40>:
    9a7c:	b0 12 44 48 	call	#18500		;#0x4844

00009a80 <.LVL41>:
  chSysUnlockFromISR();
    9a80:	b0 12 b8 44 	call	#17592		;#0x44b8

00009a84 <.LVL42>:

}
    9a84:	30 41       	ret			

00009a86 <elyUARTDLLRxCharCB>:

void elyUARTDLLRxCharCB(UARTDriver * uartp, uint16_t c) {
    9a86:	0a 15       	pushm	#1,	r10	;16-bit words

00009a88 <.LCFI5>:
    9a88:	21 83       	decd	r1		;

00009a8a <.LCFI6>:
  chDbgAssert(c < 0x100, "invalid char");
  rx_buf[0] = (uint8_t)(c);
    9a8a:	3a 40 7f cd 	mov	#-12929,r10	;#0xcd7f
    9a8e:	ca 4d 00 00 	mov.b	r13,	0(r10)	;

00009a92 <.Loc.288.1>:
  chSysLockFromISR();
    9a92:	81 4c 00 00 	mov	r12,	0(r1)	;
    9a96:	b0 12 98 44 	call	#17560		;#0x4498

00009a9a <.LVL44>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN-1, rx_buf+1);
    9a9a:	0e 4a       	mov	r10,	r14	;
    9a9c:	1e 53       	inc	r14		;
    9a9e:	7d 40 ff 00 	mov.b	#255,	r13	;#0x00ff
    9aa2:	2c 41       	mov	@r1,	r12	;
    9aa4:	b0 12 f4 4c 	call	#19700		;#0x4cf4

00009aa8 <.LVL45>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    9aa8:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9aac:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    9ab0:	b0 12 be 4b 	call	#19390		;#0x4bbe

00009ab4 <.LVL46>:
  
  curr_rx_buf = rx_buf;
    9ab4:	82 4a a8 1e 	mov	r10,	&0x1ea8	;

00009ab8 <.Loc.293.1>:
  next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9ab8:	3a 50 00 01 	add	#256,	r10	;#0x0100
    9abc:	82 4a a6 1e 	mov	r10,	&0x1ea6	;

00009ac0 <.Loc.295.1>:
  
  chSysUnlockFromISR();
    9ac0:	b0 12 b8 44 	call	#17592		;#0x44b8

00009ac4 <.LVL47>:
}
    9ac4:	21 53       	incd	r1		;
    9ac6:	0a 17       	popm	#1,	r10	;16-bit words
    9ac8:	30 41       	ret			

00009aca <elyUARTDLLRxCB>:

void elyUARTDLLRxCB(UARTDriver * uartp) {
    9aca:	21 83       	decd	r1		;

00009acc <.LCFI7>:
  /* Get the second batch of data into reception ASAP */
  chSysLockFromISR();
    9acc:	81 4c 00 00 	mov	r12,	0(r1)	;
    9ad0:	b0 12 98 44 	call	#17560		;#0x4498

00009ad4 <.LVL49>:
  uartStartReceiveI(uartp, SLIP_RX_BUF_LEN, next_rx_buf); 
    9ad4:	1e 42 a6 1e 	mov	&0x1ea6,r14	;0x1ea6
    9ad8:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    9adc:	2c 41       	mov	@r1,	r12	;
    9ade:	b0 12 f4 4c 	call	#19700		;#0x4cf4

00009ae2 <.LVL50>:
  gptStopTimerI(&uart_gpt);
    9ae2:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    9ae6:	b0 12 de 4b 	call	#19422		;#0x4bde

00009aea <.LVL51>:
  gptStartOneShotI(&uart_gpt, UART_TIMEOUT_MS);
    9aea:	3d 40 e8 03 	mov	#1000,	r13	;#0x03e8
    9aee:	3c 40 1e 1d 	mov	#7454,	r12	;#0x1d1e
    9af2:	b0 12 be 4b 	call	#19390		;#0x4bbe

00009af6 <.LVL52>:
  /* All the bytes are available */
  bytes_available = SLIP_RX_BUF_LEN;
    9af6:	b2 40 00 01 	mov	#256,	&0xcd78	;#0x0100
    9afa:	78 cd 

00009afc <.Loc.307.1>:
  /* Signal the thread that a buffer is ready */
  chEvtSignalI(uart_thd, UARTRxBufferReady);
    9afc:	6d 42       	mov.b	#4,	r13	;r2 As==10
    9afe:	4e 43       	clr.b	r14		;
    9b00:	1c 42 6c cd 	mov	&0xcd6c,r12	;0xcd6c
    9b04:	b0 12 44 48 	call	#18500		;#0x4844

00009b08 <.LVL53>:
  
  if (next_rx_buf == rx_buf + SLIP_RX_BUF_LEN) {
    9b08:	b2 90 7f ce 	cmp	#-12673,&0x1ea6	;#0xce7f
    9b0c:	a6 1e 
    9b0e:	07 20       	jnz	$+16     	;abs 0x9b1e

00009b10 <.Loc.310.1>:
    next_rx_buf = rx_buf;
    9b10:	b2 40 7f cd 	mov	#-12929,&0x1ea6	;#0xcd7f
    9b14:	a6 1e 

00009b16 <.L83>:
  }
  else {
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
  }
  
  chSysUnlockFromISR();
    9b16:	b0 12 b8 44 	call	#17592		;#0x44b8

00009b1a <.LVL54>:
}
    9b1a:	21 53       	incd	r1		;
    9b1c:	30 41       	ret			

00009b1e <.L82>:
    next_rx_buf = rx_buf + SLIP_RX_BUF_LEN;
    9b1e:	b2 40 7f ce 	mov	#-12673,&0x1ea6	;#0xce7f
    9b22:	a6 1e 
    9b24:	f8 3f       	jmp	$-14     	;abs 0x9b16

00009b26 <crcGenX25>:
   * of 0xFFFF and a final inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9b26:	b2 43       	mov	#-1		;r3 As==11, Warning: disassembly unreliable - not enough bytes available

00009b28 <L0>:
    9b28:	54 01       	rram	#1,	r4	;

00009b2a <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9b2a:	0f 4c       	mov	r12,	r15	;
    9b2c:	0e 4d       	mov	r13,	r14	;
    9b2e:	3e 50 fe ff 	add	#-2,	r14	;#0xfffe

00009b32 <.L2>:
    9b32:	0b 4f       	mov	r15,	r11	;
    9b34:	0b 8c       	sub	r12,	r11	;

00009b36 <.LVL3>:
    9b36:	0b 9e       	cmp	r14,	r11	;
    9b38:	0d 28       	jnc	$+28     	;abs 0x9b54

00009b3a <.LBE2>:
  chSysUnlock();
#endif
  
   
  /* Write result to final 2 bytes - MSB comes first because network byte order */
  *(message+n-2) = ~(CRCRESR_H);
    9b3a:	0e 5c       	add	r12,	r14	;
    9b3c:	5f 42 57 01 	mov.b	&0x0157,r15	;0x0157
    9b40:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    9b42:	ce 4f 00 00 	mov.b	r15,	0(r14)	;

00009b46 <.Loc.62.1>:
  *(message+n-1) = ~(CRCRESR_L);
    9b46:	0c 5d       	add	r13,	r12	;

00009b48 <.LVL4>:
    9b48:	5d 42 56 01 	mov.b	&0x0156,r13	;0x0156

00009b4c <.LVL5>:
    9b4c:	7d e3       	xor.b	#-1,	r13	;r3 As==11
    9b4e:	cc 4d ff ff 	mov.b	r13,	-1(r12)	; 0xffff

00009b52 <.Loc.63.1>:
}
    9b52:	30 41       	ret			

00009b54 <.L3>:
      CRCDI_L = message[i];
    9b54:	e2 4f 50 01 	mov.b	@r15,	&0x0150	;

00009b58 <.LVL7>:
    9b58:	1f 53       	inc	r15		;

00009b5a <.LVL8>:
    9b5a:	eb 3f       	jmp	$-40     	;abs 0x9b32

00009b5c <crcCheckX25>:
    9b5c:	b2 43       	mov	#-1		;r3 As==11, Warning: disassembly unreliable - not enough bytes available

00009b5e <L0>:
 */
bool crcCheckX25(uint8_t * message, size_t n) {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
  
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9b5e:	54 01       	rram	#1,	r4	;

00009b60 <.LBB4>:
  dmareq.size = n-2;
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9b60:	0f 4c       	mov	r12,	r15	;
    9b62:	0e 4d       	mov	r13,	r14	;
    9b64:	3e 50 fe ff 	add	#-2,	r14	;#0xfffe

00009b68 <.L5>:
    9b68:	0b 4f       	mov	r15,	r11	;
    9b6a:	0b 8c       	sub	r12,	r11	;

00009b6c <.LVL12>:
    9b6c:	0b 9e       	cmp	r14,	r11	;
    9b6e:	10 28       	jnc	$+34     	;abs 0x9b90

00009b70 <.LBE4>:
  chSysUnlock();
#endif
  
   
  /* Final result should be equal to calculated*/
  return (~CRCRESR == ((uint16_t)(message[n-2] << 8) | message[n-1]));
    9b70:	0e 5c       	add	r12,	r14	;
    9b72:	6e 4e       	mov.b	@r14,	r14	;
    9b74:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9b78:	0c 5d       	add	r13,	r12	;

00009b7a <.LVL13>:
    9b7a:	5d 4c ff ff 	mov.b	-1(r12),r13	;

00009b7e <.LVL14>:
    9b7e:	0d de       	bis	r14,	r13	;
    9b80:	1e 42 56 01 	mov	&0x0156,r14	;0x0156
    9b84:	3e e3       	inv	r14		;
    9b86:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9b88:	0d 9e       	cmp	r14,	r13	;
    9b8a:	01 24       	jz	$+4      	;abs 0x9b8e
    9b8c:	4c 43       	clr.b	r12		;

00009b8e <.L7>:
}
    9b8e:	30 41       	ret			

00009b90 <.L6>:
      CRCDI_L = message[i];
    9b90:	e2 4f 50 01 	mov.b	@r15,	&0x0150	;

00009b94 <.LVL16>:
    9b94:	1f 53       	inc	r15		;

00009b96 <.LVL17>:
    9b96:	e8 3f       	jmp	$-46     	;abs 0x9b68

00009b98 <crcStart>:
    9b98:	b2 43       	mov	#-1		;r3 As==11, Warning: disassembly unreliable - not enough bytes available

00009b9a <L0>:
 * @return    The address of the CRC module input
 */
volatile uint8_t * crcStart() {
  chDbgAssert(crc_state == CRC_STOPPED, "invalid call order");
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9b9a:	54 01       	rram	#1,	r4	;

00009b9c <.Loc.112.1>:
  /* Change state */
  crc_state = CRC_RUNNING;
  
  /* Return the address of the input register */
  return &CRCDI_L;
}
    9b9c:	3c 40 50 01 	mov	#336,	r12	;#0x0150
    9ba0:	30 41       	ret			

00009ba2 <crcStop>:
  /* Change state */
  crc_state = CRC_STOPPED;
  
  /* Return the result */
  return ~CRCRESR;
}
    9ba2:	1c 42 56 01 	mov	&0x0156,r12	;0x0156
    9ba6:	3c e3       	inv	r12		;
    9ba8:	30 41       	ret			

00009baa <crcGenSDLP>:
   * of 0xFFFF and no inversion */
   
  chDbgAssert(n >= 2, "message too small to CRC");
   
  /* Initialize the register to 0xFFFF */
  CRCINIRES = 0xFFFF;
    9baa:	b2 43 54 01 	mov	#-1,	&0x0154	;r3 As==11

00009bae <.LBB2>:
  dmareq.size = (n-2);
  chSysLock();
  if (dmaRequestS(NULL, &dmareq, TIME_IMMEDIATE) < 0) {
    /* Fall back to byte-wise software copying */
#endif
    for (size_t i = 0; i < n-2; i++) {
    9bae:	0f 4c       	mov	r12,	r15	;
    9bb0:	0e 4d       	mov	r13,	r14	;
    9bb2:	3e 50 fe ff 	add	#-2,	r14	;#0xfffe

00009bb6 <.L2>:
    9bb6:	0b 4f       	mov	r15,	r11	;
    9bb8:	0b 8c       	sub	r12,	r11	;

00009bba <.LVL3>:
    9bba:	0b 9e       	cmp	r14,	r11	;
    9bbc:	09 28       	jnc	$+20     	;abs 0x9bd0

00009bbe <.LBE2>:
#endif
  
   
  /* Write result to final 2 bytes */
  /* MSB comes first because of how things are transmitted */
  *(message+n-2) = (CRCINIRES_H);
    9bbe:	0e 5c       	add	r12,	r14	;
    9bc0:	de 42 55 01 	mov.b	&0x0155,0(r14)	;0x0155
    9bc4:	00 00 

00009bc6 <.Loc.55.1>:
  *(message+n-1) = (CRCINIRES_L);
    9bc6:	0c 5d       	add	r13,	r12	;

00009bc8 <.LVL4>:
    9bc8:	dc 42 54 01 	mov.b	&0x0154,-1(r12)	;0x0154, 0xffff
    9bcc:	ff ff 

00009bce <.Loc.56.1>:
}
    9bce:	30 41       	ret			

00009bd0 <.L3>:
      CRCDIRB_L = message[i];
    9bd0:	e2 4f 52 01 	mov.b	@r15,	&0x0152	;

00009bd4 <.LVL6>:
    9bd4:	1f 53       	inc	r15		;

00009bd6 <.LVL7>:
    9bd6:	ef 3f       	jmp	$-32     	;abs 0x9bb6

00009bd8 <rxfifothresh_callback>:
  /* Frame is ready */
  chEvtSignal(rf_thd, RFTxFrameReady);
}

void rxfifothresh_callback(void) {
  chSysLockFromISR();
    9bd8:	b0 12       	call			;Warning: disassembly unreliable - not enough bytes available

00009bda <L0>:
    9bda:	98 44       	mov			;Warning: disassembly unreliable - not enough bytes available, Warning: disassembly unreliable - not enough bytes available

00009bdc <.LVL0>:
  chEvtSignalI(rf_thd, RFRxFifoThresh);
    9bdc:	3d 40 00 10 	mov	#4096,	r13	;#0x1000
    9be0:	4e 43       	clr.b	r14		;
    9be2:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9be6:	b0 12 44 48 	call	#18500		;#0x4844

00009bea <.LVL1>:
  chSysUnlockFromISR();
    9bea:	b0 12 b8 44 	call	#17592		;#0x44b8

00009bee <.LVL2>:
}
    9bee:	30 41       	ret			

00009bf0 <txlvl_callback>:
  }
  
}

void txlvl_callback(void) {
  chSysLockFromISR();
    9bf0:	b0 12 98 44 	call	#17560		;#0x4498

00009bf4 <.LVL3>:
  chEvtSignalI(rf_thd, RFTxFifoLevel);
    9bf4:	3d 40 00 80 	mov	#-32768,r13	;#0x8000
    9bf8:	4e 43       	clr.b	r14		;
    9bfa:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9bfe:	b0 12 44 48 	call	#18500		;#0x4844

00009c02 <.LVL4>:
  chSysUnlockFromISR();
    9c02:	b0 12 b8 44 	call	#17592		;#0x44b8

00009c06 <.LVL5>:
}
    9c06:	30 41       	ret			

00009c08 <write_cb>:

void write_cb(SPIDriver * spip) {
    9c08:	1a 15       	pushm	#2,	r10	;16-bit words

00009c0a <.LCFI0>:
  (void)(spip);
  chSysLockFromISR();
    9c0a:	b0 12 98 44 	call	#17560		;#0x4498

00009c0e <.LVL7>:
  palSetLine(SX1278D1.config->ss_line);
    9c0e:	1c 42 24 1d 	mov	&0x1d24,r12	;0x1d24
    9c12:	1d 4c 28 00 	mov	40(r12),r13	;0x00028
    9c16:	0a 4d       	mov	r13,	r10	;
    9c18:	3a f0 ff 0f 	and	#4095,	r10	;#0x0fff
    9c1c:	19 4a 02 00 	mov	2(r10),	r9	;
    9c20:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9c22:	5d 03       	rrum	#1,	r13	;
    9c24:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    9c28:	b0 12 94 af 	call	#-20588	;#0xaf94
    9c2c:	0c d9       	bis	r9,	r12	;
    9c2e:	8a 4c 02 00 	mov	r12,	2(r10)	;
    9c32:	3a 40 44 48 	mov	#18500,	r10	;#0x4844

00009c36 <.Loc.457.1>:
  if (tf_idx == tf_len) {
    9c36:	92 92 0c c0 	cmp	&0xc00c,&0xcf9c	;0xc00c
    9c3a:	9c cf 
    9c3c:	15 20       	jnz	$+44     	;abs 0x9c68

00009c3e <.Loc.462.1>:
    /* TODO in this function, check for another available packet or frame and
     * if none exists, go to sleep mode */
    /* Done transmitting. Do the stuff */
#if ELY_DISCRETE_PA_CTL
    palClearLine(LINE_PA_PC_EN);
    9c3e:	b2 f0 ef ff 	and	#-17,	&0x0222	;#0xffef
    9c42:	22 02 

00009c44 <.Loc.464.1>:
#endif
    palLineDisableEventI(LINE_SX1278_DIO1);
    9c44:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    9c48:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    9c4c:	b0 12 ba 50 	call	#20666		;#0x50ba

00009c50 <.LVL9>:
    
    chEvtSignalI(rf_thd, RFSpiAvailable | RFTxIdle);
    9c50:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    9c54:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9c56:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9c5a:	8a 12       	call	r10		;

00009c5c <.LVL10>:
    tf_idx = 0;
    9c5c:	82 43 9c cf 	mov	#0,	&0xcf9c	;r3 As==00

00009c60 <.L5>:
  }
  else {
    chEvtSignalI(rf_thd, RFSpiAvailable);
  }
  chSysUnlockFromISR();
    9c60:	b0 12 b8 44 	call	#17592		;#0x44b8

00009c64 <.LVL11>:
}
    9c64:	19 17       	popm	#2,	r10	;16-bit words
    9c66:	30 41       	ret			

00009c68 <.L4>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    9c68:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    9c6c:	4e 43       	clr.b	r14		;
    9c6e:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9c72:	8a 12       	call	r10		;

00009c74 <.LVL12>:
    9c74:	f5 3f       	jmp	$-20     	;abs 0x9c60

00009c76 <elyRFChangeTxSyncS>:
    9c76:	0a 15       	pushm	#1,	r10	;16-bit words

00009c78 <L0>:
void elyRFChangeTxSyncS(SX1278Config * cfg) {
    9c78:	0a 4c       	mov	r12,	r10	;

00009c7a <.Loc.74.1>:
  chDbgCheckClassS();
    9c7a:	b0 12 42 45 	call	#17730		;#0x4542

00009c7e <.LVL14>:
  if (!(bank0p[RegDLLOptions] & BIT2)) { /* Compliant ASM */
    9c7e:	1f 42 be bd 	mov	&0xbdbe,r15	;0xbdbe
    9c82:	ef b2 c4 00 	bit.b	#4,	196(r15);r2 As==10, 0x00c4
    9c86:	16 20       	jnz	$+46     	;abs 0x9cb4

00009c88 <.Loc.79.1>:
                  ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    9c88:	5d 4f 11 00 	mov.b	17(r15),r13	;0x00011
    9c8c:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    9c90:	5c 4f 10 00 	mov.b	16(r15),r12	;0x00010
    9c94:	0d dc       	bis	r12,	r13	;
    9c96:	5e 4f 13 00 	mov.b	19(r15),r14	;0x00013
    9c9a:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    9c9e:	5f 4f 12 00 	mov.b	18(r15),r15	;0x00012
    9ca2:	0e df       	bis	r15,	r14	;

00009ca4 <.Loc.77.1>:
    cfg->sync_word = ( (bank0p[RegTXSyncLsb]) |
    9ca4:	8a 4d 14 00 	mov	r13,	20(r10)	; 0x0014
    9ca8:	8a 4e 16 00 	mov	r14,	22(r10)	; 0x0016

00009cac <.Loc.82.1>:
    sx1278SetSync(&SX1278D1, cfg->sync_word);
    9cac:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    9cb0:	b0 12 72 5e 	call	#24178		;#0x5e72

00009cb4 <.L6>:
}
    9cb4:	0a 17       	popm	#1,	r10	;16-bit words
    9cb6:	30 41       	ret			

00009cb8 <elyDLLClampReg>:
uint8_t elyDLLClampReg(uint8_t addr, uint8_t value) {
    9cb8:	4e 4c       	mov.b	r12,	r14	;
    9cba:	4c 4d       	mov.b	r13,	r12	;

00009cbc <.LVL17>:
  switch (addr) {
    9cbc:	7e 90 c3 ff 	cmp.b	#-61,	r14	;#0xffc3
    9cc0:	50 24       	jz	$+162    	;abs 0x9d62
    9cc2:	7f 40 c3 ff 	mov.b	#-61,	r15	;#0xffc3
    9cc6:	4f 9e       	cmp.b	r14,	r15	;
    9cc8:	0b 28       	jnc	$+24     	;abs 0x9ce0
    9cca:	7e 90 c1 ff 	cmp.b	#-63,	r14	;#0xffc1
    9cce:	2b 24       	jz	$+88     	;abs 0x9d26
    9cd0:	7f 40 c1 ff 	mov.b	#-63,	r15	;#0xffc1
    9cd4:	4f 9e       	cmp.b	r14,	r15	;
    9cd6:	32 28       	jnc	$+102    	;abs 0x9d3c
    9cd8:	7e 90 c0 ff 	cmp.b	#-64,	r14	;#0xffc0
    9cdc:	19 24       	jz	$+52     	;abs 0x9d10

00009cde <.L9>:
}
    9cde:	30 41       	ret			

00009ce0 <.L11>:
  switch (addr) {
    9ce0:	7e 90 c7 ff 	cmp.b	#-57,	r14	;#0xffc7
    9ce4:	44 24       	jz	$+138    	;abs 0x9d6e
    9ce6:	7e 90 c7 ff 	cmp.b	#-57,	r14	;#0xffc7
    9cea:	f9 2b       	jnc	$-12     	;abs 0x9cde
    9cec:	7e 50 35 00 	add.b	#53,	r14	;#0x0035
    9cf0:	7d 42       	mov.b	#8,	r13	;r2 As==11

00009cf2 <.LVL20>:
    9cf2:	4d 9e       	cmp.b	r14,	r13	;
    9cf4:	f4 2b       	jnc	$-22     	;abs 0x9cde

00009cf6 <.LBB28>:
  if ((value & 0x10) && value != 0x10) {
    9cf6:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    9cfa:	3c 24       	jz	$+122    	;abs 0x9d74
    9cfc:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    9d00:	39 24       	jz	$+116    	;abs 0x9d74

00009d02 <.Loc.91.1>:
    elyErrorSignal(ErrRegClip);
    9d02:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009d06 <.LVL22>:
    9d06:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009d0a <.LVL23>:
    return 0x10;
    9d0a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    9d0e:	e7 3f       	jmp	$-48     	;abs 0x9cde

00009d10 <.L14>:
  if (value < min) {
    9d10:	7e 40 06 00 	mov.b	#6,	r14	;
    9d14:	4e 9c       	cmp.b	r12,	r14	;
    9d16:	e3 2b       	jnc	$-56     	;abs 0x9cde

00009d18 <.LVL25>:
    elyErrorSignal(ErrRegClip);
    9d18:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9d1c:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009d20 <.LVL26>:
    value = min;
    9d20:	7c 40 07 00 	mov.b	#7,	r12	;
    9d24:	dc 3f       	jmp	$-70     	;abs 0x9cde

00009d26 <.L12>:
  else if (value > max) {
    9d26:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    9d2a:	4f 9c       	cmp.b	r12,	r15	;
    9d2c:	d8 2f       	jc	$-78     	;abs 0x9cde

00009d2e <.LVL28>:
    elyErrorSignal(ErrRegClip);
    9d2e:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    9d32:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009d36 <.LVL29>:
    value = max;
    9d36:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    9d3a:	d1 3f       	jmp	$-92     	;abs 0x9cde

00009d3c <.L13>:
      if ((value & 0x38) == 0x38) {
    9d3c:	4d 4c       	mov.b	r12,	r13	;

00009d3e <.LVL31>:
    9d3e:	7d f0 38 00 	and.b	#56,	r13	;#0x0038
    9d42:	7d 90 38 00 	cmp.b	#56,	r13	;#0x0038
    9d46:	02 20       	jnz	$+6      	;abs 0x9d4c

00009d48 <.Loc.128.1>:
        value &= ~BIT3;
    9d48:	7c f0 f7 00 	and.b	#247,	r12	;#0x00f7

00009d4c <.L17>:
      if ((value & 0x07) > 5) {
    9d4c:	4d 4c       	mov.b	r12,	r13	;
    9d4e:	7d f0 07 00 	and.b	#7,	r13	;
    9d52:	7e 40 05 00 	mov.b	#5,	r14	;
    9d56:	4e 9d       	cmp.b	r13,	r14	;
    9d58:	c2 2f       	jc	$-122    	;abs 0x9cde

00009d5a <.LVL33>:
        value |= BIT0;
    9d5a:	7c f0 fc 00 	and.b	#252,	r12	;#0x00fc

00009d5e <.LVL34>:
    9d5e:	1c d3       	bis	#1,	r12	;r3 As==01

00009d60 <.LVL35>:
    9d60:	be 3f       	jmp	$-130    	;abs 0x9cde

00009d62 <.L10>:
      if ((value & 0x03) == 0x03) {
    9d62:	4d 4c       	mov.b	r12,	r13	;

00009d64 <.LVL37>:
    9d64:	7d f0 03 00 	and.b	#3,	r13	;
    9d68:	7d 90 03 00 	cmp.b	#3,	r13	;
    9d6c:	b8 23       	jnz	$-142    	;abs 0x9cde

00009d6e <.L15>:
      value &= ~BIT0;
    9d6e:	7c f0 fe 00 	and.b	#254,	r12	;#0x00fe

00009d72 <.LVL38>:
      break;
    9d72:	b5 3f       	jmp	$-148    	;abs 0x9cde

00009d74 <.L18>:
  if ((value & 0x08) && value != 0x08) {
    9d74:	3c b2       	bit	#8,	r12	;r2 As==11
    9d76:	08 24       	jz	$+18     	;abs 0x9d88
    9d78:	3c 92       	cmp	#8,	r12	;r2 As==11
    9d7a:	06 24       	jz	$+14     	;abs 0x9d88

00009d7c <.Loc.95.1>:
    elyErrorSignal(ErrRegClip);
    9d7c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009d80 <.LVL40>:
    9d80:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009d84 <.LVL41>:
    return 0x08;
    9d84:	7c 42       	mov.b	#8,	r12	;r2 As==11
    9d86:	ab 3f       	jmp	$-168    	;abs 0x9cde

00009d88 <.L19>:
  if ((value & 0x04) && value != 0x04) {
    9d88:	2c b2       	bit	#4,	r12	;r2 As==10
    9d8a:	08 24       	jz	$+18     	;abs 0x9d9c
    9d8c:	2c 92       	cmp	#4,	r12	;r2 As==10
    9d8e:	06 24       	jz	$+14     	;abs 0x9d9c

00009d90 <.Loc.99.1>:
    elyErrorSignal(ErrRegClip);
    9d90:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009d94 <.LVL43>:
    9d94:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009d98 <.LVL44>:
    return 0x04;
    9d98:	6c 42       	mov.b	#4,	r12	;r2 As==10
    9d9a:	a1 3f       	jmp	$-188    	;abs 0x9cde

00009d9c <.L20>:
  if ((value & 0x02) && value != 0x02) {
    9d9c:	2c b3       	bit	#2,	r12	;r3 As==10
    9d9e:	08 24       	jz	$+18     	;abs 0x9db0
    9da0:	2c 93       	cmp	#2,	r12	;r3 As==10
    9da2:	06 24       	jz	$+14     	;abs 0x9db0

00009da4 <.Loc.103.1>:
    elyErrorSignal(ErrRegClip);
    9da4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009da8 <.LVL46>:
    9da8:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009dac <.LVL47>:
    return 0x02;
    9dac:	6c 43       	mov.b	#2,	r12	;r3 As==10
    9dae:	97 3f       	jmp	$-208    	;abs 0x9cde

00009db0 <.L21>:
  if ((value & 0x01) && value != 0x01) {
    9db0:	1c b3       	bit	#1,	r12	;r3 As==01
    9db2:	08 24       	jz	$+18     	;abs 0x9dc4
    9db4:	1c 93       	cmp	#1,	r12	;r3 As==01
    9db6:	06 24       	jz	$+14     	;abs 0x9dc4

00009db8 <.Loc.107.1>:
    elyErrorSignal(ErrRegClip);
    9db8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009dbc <.LVL49>:
    9dbc:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009dc0 <.LVL50>:
    return 0x01;
    9dc0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    9dc2:	8d 3f       	jmp	$-228    	;abs 0x9cde

00009dc4 <.L22>:
  if (value & 0xD0) {
    9dc4:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    9dc8:	8a 27       	jz	$-234    	;abs 0x9cde

00009dca <.Loc.111.1>:
    elyErrorSignal(ErrRegClip);
    9dca:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

00009dce <.LVL52>:
    9dce:	b0 12 5a ac 	call	#-21414	;#0xac5a

00009dd2 <.LVL53>:
    return 0x00;
    9dd2:	4c 43       	clr.b	r12		;
    9dd4:	84 3f       	jmp	$-246    	;abs 0x9cde

00009dd6 <elyRFDLLBuildFrame>:
    9dd6:	6a 15       	pushm	#7,	r10	;16-bit words

00009dd8 <.LCFI2>:
  chEvtSignal(rf_thd, RFPktAvailable);
    9dd8:	39 40 8a 48 	mov	#18570,	r9	;#0x488a
    9ddc:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    9de0:	4e 43       	clr.b	r14		;
    9de2:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9de6:	89 12       	call	r9		;

00009de8 <.LVL55>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    9de8:	17 42       	mov,		r7	;Warning: disassembly unreliable - not enough bytes available

00009dea <L0>:
    9dea:	be bd 5c 47 	bit	@r13+,	18268(r14); 0x475c
    9dee:	ca 00       	mova	r0,	r10	;

00009df0 <.Loc.179.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    9df0:	5d 47 c9 00 	mov.b	201(r7),r13	;0x000c9

00009df4 <.Loc.178.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    9df4:	3a 40 0e c0 	mov	#-16370,r10	;#0xc00e

00009df8 <.Loc.179.1>:
                    ((bank0p[RegDLLIDsLSB] & 0xF0) >> 4));
    9df8:	0f 4d       	mov	r13,	r15	;
    9dfa:	5f 0f       	rrum	#4,	r15	;

00009dfc <.Loc.178.1>:
  tf_buffer[0] |= ( ((bank0p[RegDLLIDsMSB] & 0x03) << 4) | 
    9dfc:	6f da       	bis.b	@r10,	r15	;
    9dfe:	0e 4c       	mov	r12,	r14	;
    9e00:	43 18 0e 5e 	rpt #4 { rlax.w	r14		;
    9e04:	7e f0 30 00 	and.b	#48,	r14	;#0x0030
    9e08:	4f de       	bis.b	r14,	r15	;
    9e0a:	ca 4f 00 00 	mov.b	r15,	0(r10)	;

00009e0e <.Loc.181.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    9e0e:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;
    9e12:	5d da 01 00 	bis.b	1(r10),	r13	;

00009e16 <.Loc.182.1>:
      ((bank0p[RegDLLIDsMSB] & 0x1C) >> 1));
    9e16:	0c 11       	rra	r12		;
    9e18:	7c f0 0e 00 	and.b	#14,	r12	;#0x000e

00009e1c <.Loc.181.1>:
  tf_buffer[1] |= ( ((bank0p[RegDLLIDsLSB] & 0x0F) << 4) |
    9e1c:	4d dc       	bis.b	r12,	r13	;
    9e1e:	ca 4d 01 00 	mov.b	r13,	1(r10)	;

00009e22 <.Loc.184.1>:
  tf_buffer[2] = mcfc;
    9e22:	5e 42 9a cf 	mov.b	&0xcf9a,r14	;0xcf9a
    9e26:	ca 4e 02 00 	mov.b	r14,	2(r10)	;

00009e2a <.Loc.186.1>:
  tf_buffer[3] = vcfc[0];
    9e2a:	3c 40 98 cf 	mov	#-12392,r12	;#0xcf98
    9e2e:	6d 4c       	mov.b	@r12,	r13	;
    9e30:	ca 4d 03 00 	mov.b	r13,	3(r10)	;

00009e34 <.Loc.188.1>:
  mcfc++;
    9e34:	5e 53       	inc.b	r14		;
    9e36:	c2 4e 9a cf 	mov.b	r14,	&0xcf9a	;

00009e3a <.Loc.189.1>:
  vcfc[0]++;
    9e3a:	5d 53       	inc.b	r13		;
    9e3c:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00009e40 <.Loc.191.1>:
  tf_buffer[4] &= ~BIT6;
    9e40:	5c 4a 04 00 	mov.b	4(r10),	r12	;
    9e44:	7c f0 bf ff 	and.b	#-65,	r12	;#0xffbf

00009e48 <.Loc.193.1>:
  tf_buffer[4] |= 0x07;
    9e48:	7c d0 07 00 	bis.b	#7,	r12	;
    9e4c:	ca 4c 04 00 	mov.b	r12,	4(r10)	;

00009e50 <.Loc.194.1>:
  tf_buffer[5] = 0xFF;
    9e50:	f2 43 13 c0 	mov.b	#-1,	&0xc013	;r3 As==11

00009e54 <.Loc.197.1>:
  if (state == FB_STATE_UNINIT) {
    9e54:	c2 93 8a cf 	cmp.b	#0,	&0xcf8a	;r3 As==00
    9e58:	38 20       	jnz	$+114    	;abs 0x9eca

00009e5a <.Loc.200.1>:
    if (MSG_OK != chMBFetch(&rf_mbox, (msg_t *)(&active_packet), 
    9e5a:	3e 43       	mov	#-1,	r14	;r3 As==11
    9e5c:	3d 40 88 cf 	mov	#-12408,r13	;#0xcf88
    9e60:	3c 40 6c c8 	mov	#-14228,r12	;#0xc86c
    9e64:	b0 12 3e 4a 	call	#19006		;#0x4a3e

00009e68 <.LVL56>:
    pkt_len = elyNLGetLength(active_packet);
    9e68:	1c 42 88 cf 	mov	&0xcf88,r12	;0xcf88
    9e6c:	b0 12 ae aa 	call	#-21842	;#0xaaae

00009e70 <.LVL57>:
    9e70:	82 4c 86 cf 	mov	r12,	&0xcf86	;

00009e74 <.Loc.207.1>:
    tf_buffer[4] &= ~0x07;
    9e74:	fa f0 f8 ff 	and.b	#-8,	4(r10)	;#0xfff8
    9e78:	04 00 

00009e7a <.Loc.208.1>:
    tf_buffer[5] = 0;
    9e7a:	c2 43 13 c0 	mov.b	#0,	&0xc013	;r3 As==00

00009e7e <.LVL58>:
    idle_len = 0;
    9e7e:	82 43 84 cf 	mov	#0,	&0xcf84	;r3 As==00

00009e82 <.Loc.211.1>:
    idle_idx = 0;
    9e82:	82 43 82 cf 	mov	#0,	&0xcf82	;r3 As==00

00009e86 <.Loc.212.1>:
    pkt_idx = 0;
    9e86:	82 43 80 cf 	mov	#0,	&0xcf80	;r3 As==00

00009e8a <.Loc.209.1>:
    fhp = true;
    9e8a:	58 43       	mov.b	#1,	r8	;r3 As==01

00009e8c <.L58>:
  state = FB_STATE_HEADER;
    9e8c:	d2 43 8a cf 	mov.b	#1,	&0xcf8a	;r3 As==01

00009e90 <.Loc.167.1>:
  size_t tf_idx = SDLP_TM_PH_LEN;
    9e90:	76 40 06 00 	mov.b	#6,	r6	;

00009e94 <.LBB36>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    9e94:	35 40 3e 4a 	mov	#19006,	r5	;#0x4a3e

00009e98 <.Loc.249.1>:
            pkt_len = elyNLGetLength(active_packet);
    9e98:	34 40 ae aa 	mov	#-21842,r4	;#0xaaae

00009e9c <.L59>:
  while (tf_idx != tf_data_len) {
    9e9c:	1d 42 0a c0 	mov	&0xc00a,r13	;0xc00a

00009ea0 <.Loc.218.1>:
    switch(state) {
    9ea0:	5c 42 8a cf 	mov.b	&0xcf8a,r12	;0xcf8a

00009ea4 <.L60>:
  while (tf_idx != tf_data_len) {
    9ea4:	06 9d       	cmp	r13,	r6	;
    9ea6:	13 20       	jnz	$+40     	;abs 0x9ece

00009ea8 <.Loc.280.1>:
  if (bank0p[RegDLLTMFEC] & BIT7) {
    9ea8:	c7 93 c2 00 	cmp.b	#0,	194(r7)	;r3 As==00, 0x00c2
    9eac:	06 34       	jge	$+14     	;abs 0x9eba

00009eae <.Loc.282.1>:
    crcGenSDLP(tf_buffer, tf_len);
    9eae:	1d 42 0c c0 	mov	&0xc00c,r13	;0xc00c
    9eb2:	3c 40 0e c0 	mov	#-16370,r12	;#0xc00e
    9eb6:	b0 12 aa 9b 	call	#-25686	;#0x9baa

00009eba <.L74>:
  chEvtSignal(rf_thd, RFTxFrameReady);
    9eba:	3d 40 00 08 	mov	#2048,	r13	;#0x0800
    9ebe:	4e 43       	clr.b	r14		;
    9ec0:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    9ec4:	89 12       	call	r9		;

00009ec6 <.LVL63>:
}
    9ec6:	64 17       	popm	#7,	r10	;16-bit words
    9ec8:	30 41       	ret			

00009eca <.L75>:
  bool fhp = false;
    9eca:	48 43       	clr.b	r8		;
    9ecc:	df 3f       	jmp	$-64     	;abs 0x9e8c

00009ece <.L73>:
    switch(state) {
    9ece:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9ed0:	0f 24       	jz	$+32     	;abs 0x9ef0
    9ed2:	7c 90 03 00 	cmp.b	#3,	r12	;
    9ed6:	63 24       	jz	$+200    	;abs 0x9f9e
    9ed8:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    9eda:	e4 23       	jnz	$-54     	;abs 0x9ea4

00009edc <.Loc.220.1>:
        if (idle_len > 0) {
    9edc:	82 93 84 cf 	cmp	#0,	&0xcf84	;r3 As==00
    9ee0:	04 24       	jz	$+10     	;abs 0x9eea

00009ee2 <.Loc.221.1>:
          state = FB_STATE_IDLE;
    9ee2:	f2 40 03 00 	mov.b	#3,	&0xcf8a	;
    9ee6:	8a cf 
    9ee8:	d9 3f       	jmp	$-76     	;abs 0x9e9c

00009eea <.L64>:
          state = FB_STATE_PAYLOAD;
    9eea:	e2 43 8a cf 	mov.b	#2,	&0xcf8a	;r3 As==10
    9eee:	d6 3f       	jmp	$-82     	;abs 0x9e9c

00009ef0 <.L61>:
        if (pkt_idx == pkt_len) {
    9ef0:	92 92 86 cf 	cmp	&0xcf86,&0xcf80	;0xcf86
    9ef4:	80 cf 
    9ef6:	47 20       	jnz	$+144    	;abs 0x9f86

00009ef8 <.LBB37>:
          pkt_idx = 0; /* either way - needs to be 0 when we come back around */
    9ef8:	82 43 80 cf 	mov	#0,	&0xcf80	;r3 As==00

00009efc <.Loc.230.1>:
          elyNLFreeBuffer(active_packet);
    9efc:	1c 42 88 cf 	mov	&0xcf88,r12	;0xcf88
    9f00:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

00009f04 <.LVL66>:
          if (!fhp) {
    9f04:	08 93       	cmp	#0,	r8	;r3 As==00
    9f06:	0c 20       	jnz	$+26     	;abs 0x9f20

00009f08 <.Loc.232.1>:
            tf_buffer[4] |= (tf_idx-SDLP_TM_PH_LEN) >> 8;
    9f08:	0c 46       	mov	r6,	r12	;
    9f0a:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa
    9f0e:	5c 0f       	rrum	#4,	r12	;
    9f10:	5c 0f       	rrum	#4,	r12	;
    9f12:	ca dc 04 00 	bis.b	r12,	4(r10)	;

00009f16 <.Loc.233.1>:
            tf_buffer[5] = (tf_idx-SDLP_TM_PH_LEN) & 0xFF;
    9f16:	4c 46       	mov.b	r6,	r12	;
    9f18:	7c 50 fa ff 	add.b	#-6,	r12	;#0xfffa
    9f1c:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

00009f20 <.L67>:
          msg_t r = chMBFetch(&rf_mbox, (msg_t *)(&active_packet), SDLP_IDLE_PACKET_TIMEOUT);
    9f20:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    9f24:	3d 40 88 cf 	mov	#-12408,r13	;#0xcf88
    9f28:	3c 40 6c c8 	mov	#-14228,r12	;#0xc86c
    9f2c:	85 12       	call	r5		;

00009f2e <.LVL68>:
          if (MSG_OK != r) {
    9f2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9f30:	24 24       	jz	$+74     	;abs 0x9f7a

00009f32 <.Loc.238.1>:
            idle_len = tf_data_len - tf_idx;
    9f32:	1d 42 0a c0 	mov	&0xc00a,r13	;0xc00a
    9f36:	0c 4d       	mov	r13,	r12	;
    9f38:	0c 86       	sub	r6,	r12	;

00009f3a <.LVL69>:
            if (idle_len < 7) {
    9f3a:	7e 40 06 00 	mov.b	#6,	r14	;
    9f3e:	0e 9c       	cmp	r12,	r14	;
    9f40:	18 2c       	jc	$+50     	;abs 0x9f72

00009f42 <.Loc.238.1>:
            idle_len = tf_data_len - tf_idx;
    9f42:	82 4c 84 cf 	mov	r12,	&0xcf84	;

00009f46 <.L70>:
            idle_header[4] = (idle_len - 6) >> 8;
    9f46:	1e 42 84 cf 	mov	&0xcf84,r14	;0xcf84
    9f4a:	3d 40 fc bf 	mov	#-16388,r13	;#0xbffc
    9f4e:	0c 4e       	mov	r14,	r12	;
    9f50:	3c 50 fa ff 	add	#-6,	r12	;#0xfffa
    9f54:	5c 0f       	rrum	#4,	r12	;
    9f56:	5c 0f       	rrum	#4,	r12	;
    9f58:	cd 4c 04 00 	mov.b	r12,	4(r13)	;

00009f5c <.Loc.243.1>:
            idle_header[5] = (idle_len - 6) & 0xFF;
    9f5c:	7e 50 fa ff 	add.b	#-6,	r14	;#0xfffa
    9f60:	cd 4e 05 00 	mov.b	r14,	5(r13)	;

00009f64 <.Loc.244.1>:
            idle_idx = 0;
    9f64:	82 43 82 cf 	mov	#0,	&0xcf82	;r3 As==00

00009f68 <.Loc.245.1>:
            state = FB_STATE_IDLE;
    9f68:	f2 40 03 00 	mov.b	#3,	&0xcf8a	;
    9f6c:	8a cf 

00009f6e <.Loc.246.1>:
            continue;
    9f6e:	58 43       	mov.b	#1,	r8	;r3 As==01
    9f70:	95 3f       	jmp	$-212    	;abs 0x9e9c

00009f72 <.L69>:
              idle_len += tf_data_len;
    9f72:	0d 5c       	add	r12,	r13	;
    9f74:	82 4d 84 cf 	mov	r13,	&0xcf84	;
    9f78:	e6 3f       	jmp	$-50     	;abs 0x9f46

00009f7a <.L68>:
            pkt_len = elyNLGetLength(active_packet);
    9f7a:	1c 42 88 cf 	mov	&0xcf88,r12	;0xcf88

00009f7e <.LVL71>:
    9f7e:	84 12       	call	r4		;

00009f80 <.LVL72>:
    9f80:	82 4c 86 cf 	mov	r12,	&0xcf86	;
    9f84:	58 43       	mov.b	#1,	r8	;r3 As==01

00009f86 <.L66>:
        tf_buffer[tf_idx++] = active_packet[pkt_idx++];
    9f86:	1c 42 80 cf 	mov	&0xcf80,r12	;0xcf80
    9f8a:	0d 4c       	mov	r12,	r13	;
    9f8c:	1d 53       	inc	r13		;
    9f8e:	82 4d 80 cf 	mov	r13,	&0xcf80	;
    9f92:	1c 52 88 cf 	add	&0xcf88,r12	;0xcf88
    9f96:	e6 4c 0e c0 	mov.b	@r12,	-16370(r6); 0xc00e
    9f9a:	16 53       	inc	r6		;

00009f9c <.LVL74>:
        break;
    9f9c:	7f 3f       	jmp	$-256    	;abs 0x9e9c

00009f9e <.L62>:
        if (idle_idx < 6) {
    9f9e:	1c 42 82 cf 	mov	&0xcf82,r12	;0xcf82
    9fa2:	0d 46       	mov	r6,	r13	;
    9fa4:	1d 53       	inc	r13		;
    9fa6:	0f 46       	mov	r6,	r15	;
    9fa8:	3f 50 0e c0 	add	#-16370,r15	;#0xc00e
    9fac:	7e 40 05 00 	mov.b	#5,	r14	;
    9fb0:	0e 9c       	cmp	r12,	r14	;
    9fb2:	17 28       	jnc	$+48     	;abs 0x9fe2

00009fb4 <.LVL75>:
          tf_buffer[tf_idx++] = idle_header[idle_idx++];
    9fb4:	0e 4c       	mov	r12,	r14	;
    9fb6:	1e 53       	inc	r14		;
    9fb8:	82 4e 82 cf 	mov	r14,	&0xcf82	;
    9fbc:	df 4c fc bf 	mov.b	-16388(r12),0(r15)	;0xffffbffc
    9fc0:	00 00 

00009fc2 <.L76>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    9fc2:	06 4d       	mov	r13,	r6	;

00009fc4 <.LVL76>:
        if (idle_idx == idle_len) {
    9fc4:	92 92 84 cf 	cmp	&0xcf84,&0xcf82	;0xcf84
    9fc8:	82 cf 
    9fca:	68 23       	jnz	$-302    	;abs 0x9e9c

00009fcc <.Loc.264.1>:
          idle_len = 0;
    9fcc:	82 43 84 cf 	mov	#0,	&0xcf84	;r3 As==00

00009fd0 <.Loc.265.1>:
          chEvtWaitAnyTimeout(RFPktAvailable, TIME_IMMEDIATE);
    9fd0:	3e 43       	mov	#-1,	r14	;r3 As==11
    9fd2:	3c 40 00 04 	mov	#1024,	r12	;#0x0400
    9fd6:	4d 43       	clr.b	r13		;
    9fd8:	b0 12 ba 48 	call	#18618		;#0x48ba

00009fdc <.LVL77>:
          state = FB_STATE_UNINIT;
    9fdc:	c2 43 8a cf 	mov.b	#0,	&0xcf8a	;r3 As==00

00009fe0 <.Loc.267.1>:
          continue;
    9fe0:	5d 3f       	jmp	$-324    	;abs 0x9e9c

00009fe2 <.L71>:
          tf_buffer[tf_idx++] = SPP_IDLE_DATA;
    9fe2:	ff 40 aa ff 	mov.b	#-86,	0(r15)	;#0xffaa
    9fe6:	00 00 

00009fe8 <.Loc.260.1>:
          idle_idx++;
    9fe8:	1c 53       	inc	r12		;
    9fea:	82 4c 82 cf 	mov	r12,	&0xcf82	;
    9fee:	e9 3f       	jmp	$-44     	;abs 0x9fc2

00009ff0 <elyRFDLLRxInit>:
    9ff0:	0a 15       	pushm	#1,	r10	;16-bit words

00009ff2 <.LCFI5>:
void elyRFDLLRxInit(SX1212Driver * devp) {
    9ff2:	0a 4c       	mov	r12,	r10	;

00009ff4 <.Loc.347.1>:
  sx1212StopReceive(devp);
    9ff4:	b0 12 14 6b 	call	#27412		;#0x6b14

00009ff8 <.LVL97>:
  sx1212StartReceive(devp, SDLP_TC_PH_LEN, rxfifothresh_callback);
    9ff8:	3e 40 d8 9b 	mov	#-25640,r14	;#0x9bd8
    9ffc:	7d 40 05 00 	mov.b	#5,	r13	;

0000a000 <L0>:
    a000:	0c 4a       	mov	r10,	r12	;
    a002:	b0 12 16 6a 	call	#27158		;#0x6a16

0000a006 <.LVL98>:
  dll_state = DLL_STATE_HDR;
    a006:	c2 43 97 cf 	mov.b	#0,	&0xcf97	;r3 As==00

0000a00a <.Loc.355.1>:
  chEvtSignal(rf_thd, RFRxIdle);
    a00a:	3d 40 00 40 	mov	#16384,	r13	;#0x4000
    a00e:	4e 43       	clr.b	r14		;
    a010:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a014:	b0 12 8a 48 	call	#18570		;#0x488a

0000a018 <.LVL99>:
}
    a018:	0a 17       	popm	#1,	r10	;16-bit words
    a01a:	30 41       	ret			

0000a01c <elyRFDLLHandleRxFifo>:
void elyRFDLLHandleRxFifo(SX1212Driver * devp) {
    a01c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a01e <.LCFI6>:
    a01e:	0a 4c       	mov	r12,	r10	;
    a020:	3f 40 a2 6a 	mov	#27298,	r15	;#0x6aa2

0000a024 <.Loc.360.1>:
  if (dll_state == DLL_STATE_HDR) {
    a024:	c2 93 97 cf 	cmp.b	#0,	&0xcf97	;r3 As==00
    a028:	57 20       	jnz	$+176    	;abs 0xa0d8

0000a02a <.Loc.364.1>:
    sx1212FifoRead(devp, SDLP_TC_PH_LEN, tc_hdr_buff);
    a02a:	3e 40 92 cf 	mov	#-12398,r14	;#0xcf92
    a02e:	7d 40 05 00 	mov.b	#5,	r13	;
    a032:	8f 12       	call	r15		;

0000a034 <.LVL101>:
    if (tc_hdr_buff[0] & 0xCC) {
    a034:	3e 40 92 cf 	mov	#-12398,r14	;#0xcf92
    a038:	6c 4e       	mov.b	@r14,	r12	;
    a03a:	7c b0 cc ff 	bit.b	#-52,	r12	;#0xffcc
    a03e:	05 24       	jz	$+12     	;abs 0xa04a

0000a040 <.L95>:
      elyRFDLLRxInit(devp);
    a040:	0c 4a       	mov	r10,	r12	;
    a042:	b0 12 f0 9f 	call	#-24592	;#0x9ff0

0000a046 <.L91>:
}
    a046:	0a 17       	popm	#1,	r10	;16-bit words
    a048:	30 41       	ret			

0000a04a <.L93>:
    if (((tc_hdr_buff[0] & 0x03) != (bank0p[RegDLLIDsMSB] & 0x03)) ||
    a04a:	1f 42 be bd 	mov	&0xbdbe,r15	;0xbdbe
    a04e:	5d 4f ca 00 	mov.b	202(r15),r13	;0x000ca
    a052:	4c ed       	xor.b	r13,	r12	;
    a054:	3c b0 03 00 	bit	#3,	r12	;
    a058:	f3 23       	jnz	$-24     	;abs 0xa040

0000a05a <.Loc.374.1>:
    a05a:	d2 9f c9 00 	cmp.b	201(r15),&0xcf93	;0x000c9
    a05e:	93 cf 
    a060:	ef 23       	jnz	$-32     	;abs 0xa040

0000a062 <.Loc.381.1>:
    if ((tc_hdr_buff[2] & 0xFC) != (bank0p[RegDLLIDsMSB] & 0xFC)) {
    a062:	5c 4e 02 00 	mov.b	2(r14),	r12	;
    a066:	4d ec       	xor.b	r12,	r13	;
    a068:	7d b0 fc ff 	bit.b	#-4,	r13	;#0xfffc
    a06c:	e9 23       	jnz	$-44     	;abs 0xa040

0000a06e <.Loc.388.1>:
    rx_pkt_len = (((tc_hdr_buff[2] & 0x03) << 8) | (tc_hdr_buff[3]))+1;
    a06e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a072:	3c f0 00 03 	and	#768,	r12	;#0x0300
    a076:	5e 4e 03 00 	mov.b	3(r14),	r14	;
    a07a:	0c de       	bis	r14,	r12	;

0000a07c <.Loc.394.1>:
    rx_pkt_len -= SDLP_TC_PH_LEN;
    a07c:	3c 50 fc ff 	add	#-4,	r12	;#0xfffc
    a080:	82 4c 8c cf 	mov	r12,	&0xcf8c	;

0000a084 <.LBB46>:
  _disable_interrupts();
    a084:	32 c2       	dint			

0000a086 <.Loc.348.2>:
  asm volatile("nop");
    a086:	03 43       	nop			

0000a088 <.LBE46>:
    chSysLock();
    a088:	b0 12 5a 44 	call	#17498		;#0x445a

0000a08c <.LVL103>:
    rx_active_buffer = elyNLGetBufferI();
    a08c:	b0 12 ec a9 	call	#-22036	;#0xa9ec

0000a090 <.LVL104>:
    a090:	82 4c 90 cf 	mov	r12,	&0xcf90	;

0000a094 <.Loc.398.1>:
    if (rx_active_buffer == NULL) {
    a094:	0c 93       	cmp	#0,	r12	;r3 As==00
    a096:	d4 27       	jz	$-86     	;abs 0xa040

0000a098 <.Loc.404.1>:
    curr_threshold = (rx_pkt_len <= 64 ? rx_pkt_len : 32);
    a098:	1d 42 8c cf 	mov	&0xcf8c,r13	;0xcf8c
    a09c:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    a0a0:	0c 9d       	cmp	r13,	r12	;
    a0a2:	02 2c       	jc	$+6      	;abs 0xa0a8
    a0a4:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020

0000a0a8 <.L96>:
    a0a8:	c2 4d 8b cf 	mov.b	r13,	&0xcf8b	;

0000a0ac <.Loc.405.1>:
    rx_idx = 0;
    a0ac:	82 43 8e cf 	mov	#0,	&0xcf8e	;r3 As==00

0000a0b0 <.Loc.407.1>:
    sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    a0b0:	3e 40 d8 9b 	mov	#-25640,r14	;#0x9bd8
    a0b4:	0c 4a       	mov	r10,	r12	;
    a0b6:	b0 12 e2 69 	call	#27106		;#0x69e2

0000a0ba <.LVL105>:
    chEvtSignalI(rf_thd, RFSpiAvailable);
    a0ba:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    a0be:	4e 43       	clr.b	r14		;
    a0c0:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a0c4:	b0 12 44 48 	call	#18500		;#0x4844

0000a0c8 <.LVL106>:
    dll_state = DLL_STATE_PKT;
    a0c8:	d2 43 97 cf 	mov.b	#1,	&0xcf97	;r3 As==01

0000a0cc <.L108>:
      chSysUnlock();
    a0cc:	b0 12 78 44 	call	#17528		;#0x4478

0000a0d0 <.LBB48>:
  asm volatile("nop");
    a0d0:	03 43       	nop			

0000a0d2 <.Loc.356.2>:
  _enable_interrupts();
    a0d2:	32 d2       	eint			
    a0d4:	03 43       	nop			
    a0d6:	b7 3f       	jmp	$-144    	;abs 0xa046

0000a0d8 <.L92>:
    sx1212FifoRead(devp, curr_threshold, rx_active_buffer + rx_idx);
    a0d8:	1e 42 90 cf 	mov	&0xcf90,r14	;0xcf90
    a0dc:	1e 52 8e cf 	add	&0xcf8e,r14	;0xcf8e
    a0e0:	5d 42 8b cf 	mov.b	&0xcf8b,r13	;0xcf8b
    a0e4:	8f 12       	call	r15		;

0000a0e6 <.LVL108>:
    rx_idx += curr_threshold;
    a0e6:	5c 42 8b cf 	mov.b	&0xcf8b,r12	;0xcf8b
    a0ea:	1c 52 8e cf 	add	&0xcf8e,r12	;0xcf8e
    a0ee:	82 4c 8e cf 	mov	r12,	&0xcf8e	;

0000a0f2 <.Loc.424.1>:
    if (rx_idx < rx_pkt_len) {
    a0f2:	1c 92 8c cf 	cmp	&0xcf8c,r12	;0xcf8c
    a0f6:	1b 2c       	jc	$+56     	;abs 0xa12e

0000a0f8 <.LBB50>:
  _disable_interrupts();
    a0f8:	32 c2       	dint			

0000a0fa <.Loc.348.2>:
  asm volatile("nop");
    a0fa:	03 43       	nop			

0000a0fc <.LBE50>:
      chSysLock();
    a0fc:	b0 12 5a 44 	call	#17498		;#0x445a

0000a100 <.LVL109>:
      curr_threshold = (rx_pkt_len <= 64 ? rx_pkt_len : 48);
    a100:	1d 42 8c cf 	mov	&0xcf8c,r13	;0xcf8c
    a104:	7c 40 40 00 	mov.b	#64,	r12	;#0x0040
    a108:	0c 9d       	cmp	r13,	r12	;
    a10a:	02 2c       	jc	$+6      	;abs 0xa110
    a10c:	7d 40 30 00 	mov.b	#48,	r13	;#0x0030

0000a110 <.L98>:
    a110:	c2 4d 8b cf 	mov.b	r13,	&0xcf8b	;

0000a114 <.Loc.428.1>:
      sx1212ReceiveI(devp, curr_threshold, rxfifothresh_callback);
    a114:	3e 40 d8 9b 	mov	#-25640,r14	;#0x9bd8
    a118:	0c 4a       	mov	r10,	r12	;
    a11a:	b0 12 e2 69 	call	#27106		;#0x69e2

0000a11e <.LVL110>:
      chEvtSignalI(rf_thd, RFSpiAvailable);
    a11e:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    a122:	4e 43       	clr.b	r14		;
    a124:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a128:	b0 12 44 48 	call	#18500		;#0x4844

0000a12c <.LVL111>:
    a12c:	cf 3f       	jmp	$-96     	;abs 0xa0cc

0000a12e <.L97>:
      if (MSG_OK != elyMainMBPost(rx_active_buffer, TIME_IMMEDIATE)) {
    a12e:	3d 43       	mov	#-1,	r13	;r3 As==11
    a130:	1c 42 90 cf 	mov	&0xcf90,r12	;0xcf90
    a134:	b0 12 3c 6d 	call	#27964		;#0x6d3c

0000a138 <.LVL112>:
    a138:	0c 93       	cmp	#0,	r12	;r3 As==00
    a13a:	04 24       	jz	$+10     	;abs 0xa144

0000a13c <.Loc.435.1>:
        elyNLFreeBuffer(rx_active_buffer);
    a13c:	1c 42 90 cf 	mov	&0xcf90,r12	;0xcf90
    a140:	b0 12 e0 a9 	call	#-22048	;#0xa9e0

0000a144 <.L99>:
      elyRFDLLRxInit(devp);
    a144:	0c 4a       	mov	r10,	r12	;
    a146:	b0 12 f0 9f 	call	#-24592	;#0x9ff0

0000a14a <.LVL114>:
      chEvtSignal(rf_thd, RFSpiAvailable);
    a14a:	3d 40 00 20 	mov	#8192,	r13	;#0x2000
    a14e:	4e 43       	clr.b	r14		;
    a150:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a154:	b0 12 8a 48 	call	#18570		;#0x488a

0000a158 <.LVL115>:
    a158:	76 3f       	jmp	$-274    	;abs 0xa046

0000a15a <elyRFDLLTxInit>:
    a15a:	21 83       	decd	r1		;

0000a15c <.LBB56>:
  _disable_interrupts();
    a15c:	32 c2       	dint			

0000a15e <.Loc.348.2>:
  asm volatile("nop");
    a15e:	03 43       	nop			

0000a160 <L0>:

void elyRFDLLTxInit(SX1278Driver * devp) {
  chSysLock();
    a160:	81 4c 00 00 	mov	r12,	0(r1)	;
    a164:	b0 12 5a 44 	call	#17498		;#0x445a

0000a168 <.LVL117>:
  tf_len = ((uint16_t)(bank0p[RegDLLTFLengthMSB] << 8)) | ((uint16_t)(bank0p[RegDLLTFLengthLSB]));
    a168:	1e 42 be bd 	mov	&0xbdbe,r14	;0xbdbe
    a16c:	5d 4e c1 00 	mov.b	193(r14),r13	;0x000c1
    a170:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    a174:	5f 4e c0 00 	mov.b	192(r14),r15	;0x000c0
    a178:	0d df       	bis	r15,	r13	;
    a17a:	82 4d 0c c0 	mov	r13,	&0xc00c	;

0000a17e <.Loc.478.1>:
  if (bank0p[RegDLLOptions] & BIT5) {
    a17e:	5e 4e c4 00 	mov.b	196(r14),r14	;0x000c4
    a182:	2c 41       	mov	@r1,	r12	;
    a184:	3e b0 20 00 	bit	#32,	r14	;#0x0020
    a188:	02 24       	jz	$+6      	;abs 0xa18e

0000a18a <.Loc.479.1>:
    tf_data_len = tf_len - 4;
    a18a:	3d 50 fc ff 	add	#-4,	r13	;#0xfffc

0000a18e <.L110>:
  }
  else {
    tf_data_len = tf_len;
    a18e:	82 4d 0a c0 	mov	r13,	&0xc00a	;

0000a192 <.Loc.484.1>:
  }
  if (bank0p[RegDLLOptions] & BIT2) {
    a192:	2e b2       	bit	#4,	r14	;r2 As==10
    a194:	06 24       	jz	$+14     	;abs 0xa1a2

0000a196 <.Loc.486.1>:
    /* TODO this depends on the FEC */
    sx1278SetSync(devp, 0x1ACFFC1D);
    a196:	3d 40 1d fc 	mov	#-995,	r13	;#0xfc1d
    a19a:	3e 40 cf 1a 	mov	#6863,	r14	;#0x1acf
    a19e:	b0 12 72 5e 	call	#24178		;#0x5e72

0000a1a2 <.L112>:
  }
  /* TODO data whitening, FARM */
  chSysUnlock();
    a1a2:	b0 12 78 44 	call	#17528		;#0x4478

0000a1a6 <.LBB58>:
  asm volatile("nop");
    a1a6:	03 43       	nop			

0000a1a8 <.Loc.356.2>:
  _enable_interrupts();
    a1a8:	32 d2       	eint			
    a1aa:	03 43       	nop			

0000a1ac <.LBE58>:
}
    a1ac:	21 53       	incd	r1		;
    a1ae:	30 41       	ret			

0000a1b0 <elyRFDLLInitiateTransmit>:

void elyRFDLLInitiateTransmit(SX1278Driver * devp) {
    a1b0:	21 83       	decd	r1		;

0000a1b2 <.LCFI8>:
  
#if ELY_DISCRETE_PA_CTL
  palSetLine(LINE_PA_PC_EN);
    a1b2:	b2 d0 10 00 	bis	#16,	&0x0222	;#0x0010
    a1b6:	22 02 

0000a1b8 <.Loc.498.1>:
#endif
  
  tf_idx = sx1278StartTransmit(devp, tf_len, tf_buffer, txlvl_callback, write_cb);
    a1b8:	b1 40 08 9c 	mov	#-25592,0(r1)	;#0x9c08
    a1bc:	00 00 
    a1be:	3f 40 f0 9b 	mov	#-25616,r15	;#0x9bf0
    a1c2:	3e 40 0e c0 	mov	#-16370,r14	;#0xc00e
    a1c6:	1d 42 0c c0 	mov	&0xc00c,r13	;0xc00c
    a1ca:	b0 12 94 61 	call	#24980		;#0x6194

0000a1ce <.LVL121>:
    a1ce:	82 4c 9c cf 	mov	r12,	&0xcf9c	;

0000a1d2 <.Loc.499.1>:
}
    a1d2:	21 53       	incd	r1		;
    a1d4:	30 41       	ret			

0000a1d6 <elyRFDLLHandleTxFifo>:

void elyRFDLLHandleTxFifo(SX1278Driver * devp) {
    a1d6:	0a 15       	pushm	#1,	r10	;16-bit words

0000a1d8 <.LCFI9>:
    a1d8:	21 83       	decd	r1		;

0000a1da <.LCFI10>:
  /* FIFO is sufficiently empty */
  uint8_t to_transmit = (tf_len - tf_idx <= 31 ? tf_len - tf_idx : 31);
    a1da:	1a 42 0c c0 	mov	&0xc00c,r10	;0xc00c
    a1de:	1a 82 9c cf 	sub	&0xcf9c,r10	;0xcf9c
    a1e2:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f
    a1e6:	0d 9a       	cmp	r10,	r13	;
    a1e8:	01 2c       	jc	$+4      	;abs 0xa1ec
    a1ea:	0a 4d       	mov	r13,	r10	;

0000a1ec <.L118>:
  _disable_interrupts();
    a1ec:	32 c2       	dint			

0000a1ee <.Loc.348.2>:
  asm volatile("nop");
    a1ee:	03 43       	nop			

0000a1f0 <.LBE64>:
  chSysLock();
    a1f0:	81 4c 00 00 	mov	r12,	0(r1)	;
    a1f4:	b0 12 5a 44 	call	#17498		;#0x445a

0000a1f8 <.LVL124>:
  sx1278FifoWriteAsyncS(devp, to_transmit, tf_buffer + tf_idx, write_cb);
    a1f8:	3f 40 08 9c 	mov	#-25592,r15	;#0x9c08
    a1fc:	1e 42 9c cf 	mov	&0xcf9c,r14	;0xcf9c
    a200:	3e 50 0e c0 	add	#-16370,r14	;#0xc00e
    a204:	0d 4a       	mov	r10,	r13	;
    a206:	2c 41       	mov	@r1,	r12	;
    a208:	b0 12 ec 60 	call	#24812		;#0x60ec

0000a20c <.LVL125>:
  tf_idx += to_transmit;
    a20c:	82 5a 9c cf 	add	r10,	&0xcf9c	;

0000a210 <.Loc.507.1>:
  chSysUnlock();
    a210:	b0 12 78 44 	call	#17528		;#0x4478

0000a214 <.LBB66>:
  asm volatile("nop");
    a214:	03 43       	nop			

0000a216 <.Loc.356.2>:
  _enable_interrupts();
    a216:	32 d2       	eint			
    a218:	03 43       	nop			

0000a21a <.LBE66>:
}
    a21a:	21 53       	incd	r1		;
    a21c:	0a 17       	popm	#1,	r10	;16-bit words
    a21e:	30 41       	ret			

0000a220 <port_lock>:
  _disable_interrupts();
    a220:	32 c2       	dint			

0000a222 <.Loc.348.1>:
  asm volatile("nop");
    a222:	03 43       	nop			

0000a224 <.Loc.349.1>:
}
    a224:	30 41       	ret			

0000a226 <port_unlock>:
  asm volatile("nop");
    a226:	03 43       	nop			

0000a228 <.Loc.356.1>:
  _enable_interrupts();
    a228:	32 d2       	eint			
    a22a:	03 43       	nop			

0000a22c <.Loc.357.1>:
}
    a22c:	30 41       	ret			

0000a22e <elyRFPostI>:
static const PERSIST rf_events_t AllRfEvents = 0x1FFFF;
static const PERSIST rf_events_t RFTxCfgMask = 0x155;
static const PERSIST rf_events_t RFRxCfgMask = 0xAA;
static eventmask_t events;

msg_t elyRFPostI(uint8_t * buffer) {
    a22e:	0a 15       	pushm	#1,	r10	;16-bit words

0000a230 <.LCFI0>:
  msg_t msg;
  msg = chMBPostI(&rf_mbox, (msg_t)(buffer));
    a230:	0d 4c       	mov	r12,	r13	;
    a232:	3c 40 6c c8 	mov	#-14228,r12	;#0xc86c

0000a236 <.LVL1>:
    a236:	b0 12 b0 49 	call	#18864		;#0x49b0

0000a23a <.LVL2>:
    a23a:	0a 4c       	mov	r12,	r10	;

0000a23c <.Loc.18.2>:
  if (MSG_OK == msg) {
    a23c:	0c 93       	cmp	#0,	r12	;r3 As==00
    a23e:	07 20       	jnz	$+16     	;abs 0xa24e

0000a240 <.Loc.19.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    a240:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    a244:	4e 43       	clr.b	r14		;
    a246:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a24a:	b0 12 44 48 	call	#18500		;#0x4844

0000a24e <.L3>:
  }
  return msg;
}
    a24e:	0c 4a       	mov	r10,	r12	;
    a250:	0a 17       	popm	#1,	r10	;16-bit words
    a252:	30 41       	ret			

0000a254 <elyRFPost>:

msg_t elyRFPost(uint8_t * buffer, systime_t timeout) {
    a254:	1a 15       	pushm	#2,	r10	;16-bit words

0000a256 <.LCFI1>:
    a256:	0a 4c       	mov	r12,	r10	;
    a258:	09 4d       	mov	r13,	r9	;

0000a25a <.Loc.26.2>:
  msg_t msg;
  chSysLock();
    a25a:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a25e <.LVL6>:
    a25e:	b0 12 5a 44 	call	#17498		;#0x445a

0000a262 <.LVL7>:
  msg = chMBPostS(&rf_mbox, (msg_t)(buffer), timeout);
    a262:	0e 49       	mov	r9,	r14	;
    a264:	0d 4a       	mov	r10,	r13	;
    a266:	3c 40 6c c8 	mov	#-14228,r12	;#0xc86c
    a26a:	b0 12 2a 49 	call	#18730		;#0x492a

0000a26e <.LVL8>:
    a26e:	0a 4c       	mov	r12,	r10	;

0000a270 <.LVL9>:
  if (MSG_OK == msg) {
    a270:	0c 93       	cmp	#0,	r12	;r3 As==00
    a272:	07 20       	jnz	$+16     	;abs 0xa282

0000a274 <.Loc.29.2>:
    chEvtSignalI(rf_thd, RFPktAvailable);
    a274:	3d 40 00 04 	mov	#1024,	r13	;#0x0400
    a278:	4e 43       	clr.b	r14		;
    a27a:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda
    a27e:	b0 12 44 48 	call	#18500		;#0x4844

0000a282 <.L6>:
  }
  chSysUnlock();
    a282:	b0 12 78 44 	call	#17528		;#0x4478

0000a286 <.LVL11>:
    a286:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a28a <.LVL12>:
  return msg;
}
    a28a:	0c 4a       	mov	r10,	r12	;
    a28c:	19 17       	popm	#2,	r10	;16-bit words
    a28e:	30 41       	ret			

0000a290 <elyRFCfgMarkDirty>:

void elyRFCfgMarkDirty(rf_events_t event) {
  chDbgAssert(chThdGetSelfX() != rf_thd, "can't set your own config dirty");
  chDbgAssert(event & RFCfgMask, "invalid event");
  
  chEvtSignal(rf_thd, event);
    a290:	0e 4d       	mov	r13,	r14	;
    a292:	0d 4c       	mov	r12,	r13	;
    a294:	1c 42 da 1f 	mov	&0x1fda,r12	;0x1fda

0000a298 <.LVL17>:
    a298:	b0 12 8a 48 	call	#18570		;#0x488a

0000a29c <.LVL18>:
}
    a29c:	30 41       	ret			

0000a29e <elyRFChangeTxFreqS>:
static eventmask_t get_next_event(eventmask_t mask) {
  mask ^= mask & (mask - (eventmask_t)1);
  return mask;
}

void __attribute__((weak)) elyRFChangeTxFreqS(SX1278Config * cfg) {
    a29e:	0a 15       	pushm	#1,	r10	;16-bit words

0000a2a0 <.LCFI2>:
    a2a0:	0a 4c       	mov	r12,	r10	;

0000a2a2 <.Loc.55.2>:
  chSysLock();
    a2a2:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a2a6 <.LVL20>:
    a2a6:	b0 12 5a 44 	call	#17498		;#0x445a

0000a2aa <.LVL21>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    a2aa:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a2ae:	5e 4d 01 00 	mov.b	1(r13),	r14	;
    a2b2:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a2b6:	5c 4d 03 00 	mov.b	3(r13),	r12	;
    a2ba:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a2be:	5f 4d 02 00 	mov.b	2(r13),	r15	;
    a2c2:	0c df       	bis	r15,	r12	;

0000a2c4 <.Loc.56.2>:
  cfg->freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    a2c4:	6d 4d       	mov.b	@r13,	r13	;
    a2c6:	0d de       	bis	r14,	r13	;
    a2c8:	8a 4d 08 00 	mov	r13,	8(r10)	;
    a2cc:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a

0000a2d0 <.Loc.60.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  chSysUnlock();
    a2d0:	b0 12 78 44 	call	#17528		;#0x4478

0000a2d4 <.LVL22>:
    a2d4:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a2d8 <.LVL23>:
  
  /* This is pretty fast */
  sx1278SetFrequency(&SX1278D1, cfg->freq);
    a2d8:	1d 4a 08 00 	mov	8(r10),	r13	;
    a2dc:	1e 4a 0a 00 	mov	10(r10),r14	;0x0000a
    a2e0:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a2e4:	b0 12 a0 5d 	call	#23968		;#0x5da0

0000a2e8 <.LVL24>:
}
    a2e8:	0a 17       	popm	#1,	r10	;16-bit words
    a2ea:	30 41       	ret			

0000a2ec <elyRFChangeRxFreqS>:

void __attribute__((weak)) elyRFChangeRxFreqS(SX1212Config * cfg) {
    a2ec:	0a 15       	pushm	#1,	r10	;16-bit words

0000a2ee <.LCFI3>:
    a2ee:	0a 4c       	mov	r12,	r10	;

0000a2f0 <.Loc.67.2>:
  chSysLock();
    a2f0:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a2f4 <.LVL26>:
    a2f4:	b0 12 5a 44 	call	#17498		;#0x445a

0000a2f8 <.LVL27>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    a2f8:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a2fc:	5e 4d 05 00 	mov.b	5(r13),	r14	;
    a300:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a304:	5c 4d 07 00 	mov.b	7(r13),	r12	;
    a308:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a30c:	5f 4d 06 00 	mov.b	6(r13),	r15	;
    a310:	0c df       	bis	r15,	r12	;

0000a312 <.Loc.68.2>:
  cfg->freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    a312:	5d 4d 04 00 	mov.b	4(r13),	r13	;
    a316:	0d de       	bis	r14,	r13	;
    a318:	8a 4d 0a 00 	mov	r13,	10(r10)	; 0x000a
    a31c:	8a 4c 0c 00 	mov	r12,	12(r10)	; 0x000c

0000a320 <.Loc.72.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  chSysUnlock();
    a320:	b0 12 78 44 	call	#17528		;#0x4478

0000a324 <.LVL28>:
    a324:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a328 <.LVL29>:
  
  /* This is INCREDIBLY slow */
  sx1212SetFrequency(&SX1212D1, cfg->freq);
    a328:	1d 4a 0a 00 	mov	10(r10),r13	;0x0000a
    a32c:	1e 4a 0c 00 	mov	12(r10),r14	;0x0000c
    a330:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a334:	b0 12 5a 65 	call	#25946		;#0x655a

0000a338 <.LVL30>:
}
    a338:	0a 17       	popm	#1,	r10	;16-bit words
    a33a:	30 41       	ret			

0000a33c <elyRFChangeTxBRS>:

void __attribute__((weak)) elyRFChangeTxBRS(SX1278Config * cfg) {
    a33c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a33e <.LCFI4>:
    a33e:	0a 4c       	mov	r12,	r10	;

0000a340 <.Loc.79.2>:
  chSysLock();
    a340:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a344 <.LVL32>:
    a344:	b0 12 5a 44 	call	#17498		;#0x445a

0000a348 <.LVL33>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    a348:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a34c:	5e 4d 19 00 	mov.b	25(r13),r14	;0x00019
    a350:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a354:	5c 4d 1b 00 	mov.b	27(r13),r12	;0x0001b
    a358:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a35c:	5f 4d 1a 00 	mov.b	26(r13),r15	;0x0001a
    a360:	0c df       	bis	r15,	r12	;

0000a362 <.Loc.80.2>:
  cfg->bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    a362:	5d 4d 18 00 	mov.b	24(r13),r13	;0x00018
    a366:	0d de       	bis	r14,	r13	;
    a368:	8a 4d 04 00 	mov	r13,	4(r10)	;
    a36c:	8a 4c 06 00 	mov	r12,	6(r10)	;

0000a370 <.Loc.84.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  chSysUnlock();
    a370:	b0 12 78 44 	call	#17528		;#0x4478

0000a374 <.LVL34>:
    a374:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a378 <.LVL35>:
  
  /* This is fast */
  sx1278SetBitrate(&SX1278D1, cfg->bitrate);
    a378:	1d 4a 04 00 	mov	4(r10),	r13	;
    a37c:	1e 4a 06 00 	mov	6(r10),	r14	;
    a380:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a384:	b0 12 1c 5d 	call	#23836		;#0x5d1c

0000a388 <.LVL36>:
}
    a388:	0a 17       	popm	#1,	r10	;16-bit words
    a38a:	30 41       	ret			

0000a38c <elyRFChangeRxBRS>:

void __attribute__((weak)) elyRFChangeRxBRS(SX1212Config * cfg) {
    a38c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a38e <.LCFI5>:
    a38e:	0a 4c       	mov	r12,	r10	;

0000a390 <.Loc.91.2>:
  chSysLock();
    a390:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a394 <.LVL38>:
    a394:	b0 12 5a 44 	call	#17498		;#0x445a

0000a398 <.LVL39>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    a398:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a39c:	5e 4d 1d 00 	mov.b	29(r13),r14	;0x0001d
    a3a0:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a3a4:	5c 4d 1f 00 	mov.b	31(r13),r12	;0x0001f
    a3a8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a3ac:	5f 4d 1e 00 	mov.b	30(r13),r15	;0x0001e
    a3b0:	0c df       	bis	r15,	r12	;

0000a3b2 <.Loc.92.2>:
  cfg->bitrate = ( (uint32_t)(bank0p[RegRXBRLsb]) |
    a3b2:	5d 4d 1c 00 	mov.b	28(r13),r13	;0x0001c
    a3b6:	0d de       	bis	r14,	r13	;
    a3b8:	8a 4d 06 00 	mov	r13,	6(r10)	;
    a3bc:	8a 4c 08 00 	mov	r12,	8(r10)	;

0000a3c0 <.Loc.96.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  chSysUnlock();
    a3c0:	b0 12 78 44 	call	#17528		;#0x4478

0000a3c4 <.LVL40>:
    a3c4:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a3c8 <.LVL41>:
  
  /* This is only moderately slow */
  sx1212SetBitrate(&SX1212D1, cfg->bitrate);
    a3c8:	1d 4a 06 00 	mov	6(r10),	r13	;
    a3cc:	1e 4a 08 00 	mov	8(r10),	r14	;
    a3d0:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a3d4:	b0 12 52 64 	call	#25682		;#0x6452

0000a3d8 <.LVL42>:
}
    a3d8:	0a 17       	popm	#1,	r10	;16-bit words
    a3da:	30 41       	ret			

0000a3dc <elyRFChangeTxDevS>:

void __attribute__((weak)) elyRFChangeTxDevS(SX1278Config * cfg) {
    a3dc:	0a 15       	pushm	#1,	r10	;16-bit words

0000a3de <.LCFI6>:
    a3de:	0a 4c       	mov	r12,	r10	;

0000a3e0 <.Loc.103.2>:
  chSysLock();
    a3e0:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a3e4 <.LVL44>:
    a3e4:	b0 12 5a 44 	call	#17498		;#0x445a

0000a3e8 <.LVL45>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    a3e8:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a3ec:	5e 4d 09 00 	mov.b	9(r13),	r14	;
    a3f0:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a3f4:	5c 4d 0b 00 	mov.b	11(r13),r12	;0x0000b
    a3f8:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a3fc:	5f 4d 0a 00 	mov.b	10(r13),r15	;0x0000a
    a400:	0c df       	bis	r15,	r12	;

0000a402 <.Loc.104.2>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    a402:	5d 4d 08 00 	mov.b	8(r13),	r13	;
    a406:	0d de       	bis	r14,	r13	;
    a408:	8a 4d 0c 00 	mov	r13,	12(r10)	; 0x000c
    a40c:	8a 4c 0e 00 	mov	r12,	14(r10)	; 0x000e

0000a410 <.Loc.108.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  chSysUnlock();
    a410:	b0 12 78 44 	call	#17528		;#0x4478

0000a414 <.LVL46>:
    a414:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a418 <.LVL47>:
  
  /* This is fast */
  sx1278SetDeviation(&SX1278D1, cfg->fdev);
    a418:	1d 4a 0c 00 	mov	12(r10),r13	;0x0000c
    a41c:	1e 4a 0e 00 	mov	14(r10),r14	;0x0000e
    a420:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a424:	b0 12 64 5d 	call	#23908		;#0x5d64

0000a428 <.LVL48>:
}
    a428:	0a 17       	popm	#1,	r10	;16-bit words
    a42a:	30 41       	ret			

0000a42c <elyRFChangeRxDevS>:

void __attribute__((weak)) elyRFChangeRxDevS(SX1212Config * cfg) {
    a42c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a42e <.LCFI7>:
    a42e:	0a 4c       	mov	r12,	r10	;

0000a430 <.Loc.115.2>:
  chSysLock();
    a430:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a434 <.LVL50>:
    a434:	b0 12 5a 44 	call	#17498		;#0x445a

0000a438 <.LVL51>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    a438:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a43c:	5e 4d 0d 00 	mov.b	13(r13),r14	;0x0000d
    a440:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a444:	5c 4d 0f 00 	mov.b	15(r13),r12	;0x0000f
    a448:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a44c:	5f 4d 0e 00 	mov.b	14(r13),r15	;0x0000e
    a450:	0c df       	bis	r15,	r12	;

0000a452 <.Loc.116.2>:
  cfg->fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    a452:	5d 4d 0c 00 	mov.b	12(r13),r13	;0x0000c
    a456:	0d de       	bis	r14,	r13	;
    a458:	8a 4d 0e 00 	mov	r13,	14(r10)	; 0x000e
    a45c:	8a 4c 10 00 	mov	r12,	16(r10)	; 0x0010

0000a460 <.Loc.120.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  chSysUnlock();
    a460:	b0 12 78 44 	call	#17528		;#0x4478

0000a464 <.LVL52>:
    a464:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a468 <.LVL53>:
  
  /* This is super fast */
  sx1212SetDeviation(&SX1212D1, cfg->fdev);
    a468:	1d 4a 0e 00 	mov	14(r10),r13	;0x0000e
    a46c:	1e 4a 10 00 	mov	16(r10),r14	;0x00010
    a470:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a474:	b0 12 36 65 	call	#25910		;#0x6536

0000a478 <.LVL54>:
}
    a478:	0a 17       	popm	#1,	r10	;16-bit words
    a47a:	30 41       	ret			

0000a47c <elyRFChangeRxSyncS>:
  
  /* This is reasonably fast */
  sx1278SetSync(&SX1278D1, cfg->sync_word);
}

void __attribute__((weak)) elyRFChangeRxSyncS(SX1212Config * cfg) {
    a47c:	0a 15       	pushm	#1,	r10	;16-bit words

0000a47e <.LCFI9>:
    a47e:	0a 4c       	mov	r12,	r10	;

0000a480 <.Loc.139.2>:
  chSysLock();
    a480:	b0 12 20 a2 	call	#-24032	;#0xa220

0000a484 <.LVL62>:
    a484:	b0 12 5a 44 	call	#17498		;#0x445a

0000a488 <.LVL63>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    a488:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a48c:	5e 4d 15 00 	mov.b	21(r13),r14	;0x00015
    a490:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a494:	5c 4d 17 00 	mov.b	23(r13),r12	;0x00017
    a498:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a49c:	5f 4d 16 00 	mov.b	22(r13),r15	;0x00016
    a4a0:	0c df       	bis	r15,	r12	;

0000a4a2 <.Loc.140.2>:
  cfg->sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    a4a2:	5d 4d 14 00 	mov.b	20(r13),r13	;0x00014
    a4a6:	0d de       	bis	r14,	r13	;
    a4a8:	8a 4d 16 00 	mov	r13,	22(r10)	; 0x0016
    a4ac:	8a 4c 18 00 	mov	r12,	24(r10)	; 0x0018

0000a4b0 <.Loc.144.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    a4b0:	b0 12 78 44 	call	#17528		;#0x4478

0000a4b4 <.LVL64>:
    a4b4:	b0 12 26 a2 	call	#-24026	;#0xa226

0000a4b8 <.LVL65>:
  
  /* This is reasonably fast */
  sx1212SetSync(&SX1212D1, cfg->sync_word);
    a4b8:	1d 4a 16 00 	mov	22(r10),r13	;0x00016
    a4bc:	1e 4a 18 00 	mov	24(r10),r14	;0x00018
    a4c0:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a4c4:	b0 12 32 68 	call	#26674		;#0x6832

0000a4c8 <.LVL66>:
}
    a4c8:	0a 17       	popm	#1,	r10	;16-bit words
    a4ca:	30 41       	ret			

0000a4cc <elyRFChangeTxPowerS>:

void __attribute__((weak)) elyRFChangeTxPowerS(SX1278Config * cfg) {
  cfg->pow = bank0p[RegOutputPower];
    a4cc:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a4d0:	5d 4d 21 00 	mov.b	33(r13),r13	;0x00021
    a4d4:	cc 4d 11 00 	mov.b	r13,	17(r12)	; 0x0011

0000a4d8 <.Loc.154.2>:
  
  /* This is reasonably fast because I made it kind of sloppy */
  sx1278SetPower(&SX1278D1, cfg->pow);
    a4d8:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24

0000a4dc <.LVL68>:
    a4dc:	b0 12 66 5e 	call	#24166		;#0x5e66

0000a4e0 <.LVL69>:
}
    a4e0:	30 41       	ret			

0000a4e2 <elyRFChangeRxFilterParamsS>:
  sx1278SetFilterParams(&SX1278D1, tx_cfg->filter);
}

void __attribute__((weak)) elyRFChangeRxFilterParamsS(SX1212Config * rx_cfg) {
  
  rx_cfg->rx_bw = (bank0p[RegFilterParams] & 0x0F);
    a4e2:	1d 42 be bd 	mov	&0xbdbe,r13	;0xbdbe
    a4e6:	5d 4d 20 00 	mov.b	32(r13),r13	;0x00020
    a4ea:	7d f0 0f 00 	and.b	#15,	r13	;#0x000f
    a4ee:	4e 4d       	mov.b	r13,	r14	;
    a4f0:	0f 43       	clr	r15		;
    a4f2:	8c 4e 12 00 	mov	r14,	18(r12)	; 0x0012
    a4f6:	8c 4f 14 00 	mov	r15,	20(r12)	; 0x0014

0000a4fa <.Loc.168.2>:
  /* This is fast and I made it kind of sloppy anyway */
  sx1212SetRxBw(&SX1212D1, rx_cfg->rx_bw);
    a4fa:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30

0000a4fe <.LVL74>:
    a4fe:	b0 12 6e 68 	call	#26734		;#0x686e

0000a502 <.LVL75>:
}
    a502:	30 41       	ret			

0000a504 <RFThd>:
static bool bits_set(eventmask_t events, eventmask_t bits) {
  return ((events & bits) == bits);
}

THD_WORKING_AREA(waRFThd, 256);
THD_FUNCTION(RFThd, arg) {
    a504:	6a 15       	pushm	#7,	r10	;16-bit words

0000a506 <.LCFI10>:
    a506:	31 80 06 00 	sub	#6,	r1	;

0000a50a <.LCFI11>:
  (void)arg;
  
  /* Store a thread pointer for later use */
  rf_thd = chThdGetSelfX();
    a50a:	92 42 00 1c 	mov	&0x1c00,&0x1fda	;0x1c00
    a50e:	da 1f 

0000a510 <.Loc.238.2>:
  
  /* Build the TX config out of the registers */
  chSysLock();
    a510:	35 40 20 a2 	mov	#-24032,r5	;#0xa220
    a514:	85 12       	call	r5		;

0000a516 <.LVL77>:
    a516:	38 40 5a 44 	mov	#17498,	r8	;#0x445a
    a51a:	88 12       	call	r8		;

0000a51c <.LVL78>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    a51c:	14 42 be bd 	mov	&0xbdbe,r4	;0xbdbe
    a520:	3d 40 30 c8 	mov	#-14288,r13	;#0xc830

0000a524 <.Loc.241.2>:
                   ((uint32_t)(bank0p[RegTXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegTXBRHmb]) << 16) |
    a524:	5e 44 19 00 	mov.b	25(r4),	r14	;0x00019
    a528:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a52c:	5c 44 1b 00 	mov.b	27(r4),	r12	;0x0001b
    a530:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a534:	5f 44 1a 00 	mov.b	26(r4),	r15	;0x0001a
    a538:	0c df       	bis	r15,	r12	;

0000a53a <.Loc.239.2>:
  tx_cfg.bitrate = ( ((uint32_t)(bank0p[RegTXBRLsb])) |
    a53a:	5f 44 18 00 	mov.b	24(r4),	r15	;0x00018
    a53e:	0f de       	bis	r14,	r15	;
    a540:	8d 4f 04 00 	mov	r15,	4(r13)	;
    a544:	8d 4c 06 00 	mov	r12,	6(r13)	;

0000a548 <.Loc.245.2>:
                   ((uint32_t)(bank0p[RegTXBRMsb]) << 24) );
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
               ((uint32_t)(bank0p[RegTXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegTXFreqHmb]) << 16) |
    a548:	5e 44 01 00 	mov.b	1(r4),	r14	;
    a54c:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a550:	5c 44 03 00 	mov.b	3(r4),	r12	;
    a554:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a558:	5f 44 02 00 	mov.b	2(r4),	r15	;
    a55c:	0c df       	bis	r15,	r12	;

0000a55e <.Loc.243.2>:
  tx_cfg.freq = ( ((uint32_t)(bank0p[RegTXFreqLsb])) |
    a55e:	6f 44       	mov.b	@r4,	r15	;
    a560:	0f de       	bis	r14,	r15	;
    a562:	8d 4f 08 00 	mov	r15,	8(r13)	;
    a566:	8d 4c 0a 00 	mov	r12,	10(r13)	; 0x000a

0000a56a <.Loc.249.2>:
               ((uint32_t)(bank0p[RegTXFreqMsb]) << 24) );
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
                     ((uint32_t)(bank0p[RegTXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegTXDevHmb]) << 16) |
    a56a:	5e 44 09 00 	mov.b	9(r4),	r14	;
    a56e:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a572:	5c 44 0b 00 	mov.b	11(r4),	r12	;0x0000b
    a576:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a57a:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x0000a
    a57e:	0c df       	bis	r15,	r12	;

0000a580 <.Loc.247.2>:
  tx_cfg.fdev = ( ((uint32_t)(bank0p[RegTXDevLsb])) |
    a580:	5f 44 08 00 	mov.b	8(r4),	r15	;
    a584:	0f de       	bis	r14,	r15	;
    a586:	8d 4f 0c 00 	mov	r15,	12(r13)	; 0x000c
    a58a:	8d 4c 0e 00 	mov	r12,	14(r13)	; 0x000e

0000a58e <.Loc.251.2>:
                     ((uint32_t)(bank0p[RegTXDevMsb]) << 24) );
  tx_cfg.filter = ((bank0p[RegFilterParams] >> 4) & 0x03);
    a58e:	5c 44 20 00 	mov.b	32(r4),	r12	;0x00020
    a592:	5c 0f       	rrum	#4,	r12	;
    a594:	7c f0 03 00 	and.b	#3,	r12	;
    a598:	cd 4c 10 00 	mov.b	r12,	16(r13)	; 0x0010

0000a59c <.Loc.252.2>:
  tx_cfg.pow = bank0p[RegOutputPower];
    a59c:	dd 44 21 00 	mov.b	33(r4),	17(r13)	;0x00021, 0x0011
    a5a0:	11 00 

0000a5a2 <.Loc.255.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
                ((uint32_t)(bank0p[RegTXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegTXSyncHmb]) << 16) |
    a5a2:	5e 44 11 00 	mov.b	17(r4),	r14	;0x00011
    a5a6:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a5aa:	5c 44 13 00 	mov.b	19(r4),	r12	;0x00013
    a5ae:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a5b2:	5f 44 12 00 	mov.b	18(r4),	r15	;0x00012
    a5b6:	0c df       	bis	r15,	r12	;

0000a5b8 <.Loc.253.2>:
  tx_cfg.sync_word = ( ((uint32_t)(bank0p[RegTXSyncLsb])) |
    a5b8:	5f 44 10 00 	mov.b	16(r4),	r15	;0x00010
    a5bc:	0f de       	bis	r14,	r15	;
    a5be:	8d 4f 14 00 	mov	r15,	20(r13)	; 0x0014
    a5c2:	8d 4c 16 00 	mov	r12,	22(r13)	; 0x0016

0000a5c6 <.Loc.257.2>:
                ((uint32_t)(bank0p[RegTXSyncMsb]) << 24) );
  chSysUnlock();
    a5c6:	39 40 78 44 	mov	#17528,	r9	;#0x4478
    a5ca:	81 4d 00 00 	mov	r13,	0(r1)	;
    a5ce:	89 12       	call	r9		;

0000a5d0 <.LVL79>:
    a5d0:	3a 40 26 a2 	mov	#-24026,r10	;#0xa226
    a5d4:	8a 12       	call	r10		;

0000a5d6 <.LVL80>:
  
  /* Start the transmitter driver and initiate the transmit loop */
  sx1278ObjectInit(&SX1278D1);
    a5d6:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a5da:	b0 12 ca 5e 	call	#24266		;#0x5eca

0000a5de <.LVL81>:
  sx1278Start(&SX1278D1, &tx_cfg);
    a5de:	2d 41       	mov	@r1,	r13	;
    a5e0:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a5e4:	b0 12 14 5f 	call	#24340		;#0x5f14

0000a5e8 <.LVL82>:
  
  elyRFDLLTxInit(&SX1278D1);
    a5e8:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a5ec:	b0 12 5a a1 	call	#-24230	;#0xa15a

0000a5f0 <.LVL83>:
  
  /* Build the RX config out of the registers */
  chSysLock();
    a5f0:	85 12       	call	r5		;

0000a5f2 <.LVL84>:
    a5f2:	88 12       	call	r8		;

0000a5f4 <.LVL85>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    a5f4:	3d 40 0e c8 	mov	#-14322,r13	;#0xc80e

0000a5f8 <.Loc.269.2>:
                   ((uint32_t)(bank0p[RegRXBRLmb]) << 8) |
                   ((uint32_t)(bank0p[RegRXBRHmb]) << 16) |
    a5f8:	5e 44 1d 00 	mov.b	29(r4),	r14	;0x0001d
    a5fc:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a600:	5c 44 1f 00 	mov.b	31(r4),	r12	;0x0001f
    a604:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a608:	5f 44 1e 00 	mov.b	30(r4),	r15	;0x0001e
    a60c:	0c df       	bis	r15,	r12	;

0000a60e <.Loc.267.2>:
  rx_cfg.bitrate = ( ((uint32_t)(bank0p[RegRXBRLsb])) |
    a60e:	5f 44 1c 00 	mov.b	28(r4),	r15	;0x0001c
    a612:	0f de       	bis	r14,	r15	;
    a614:	8d 4f 06 00 	mov	r15,	6(r13)	;
    a618:	8d 4c 08 00 	mov	r12,	8(r13)	;

0000a61c <.Loc.273.2>:
                   ((uint32_t)(bank0p[RegRXBRMsb]) << 24) );
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
               ((uint32_t)(bank0p[RegRXFreqLmb]) << 8) |
               ((uint32_t)(bank0p[RegRXFreqHmb]) << 16) |
    a61c:	5e 44 05 00 	mov.b	5(r4),	r14	;
    a620:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a624:	5c 44 07 00 	mov.b	7(r4),	r12	;
    a628:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a62c:	5f 44 06 00 	mov.b	6(r4),	r15	;
    a630:	0c df       	bis	r15,	r12	;

0000a632 <.Loc.271.2>:
  rx_cfg.freq = ( ((uint32_t)(bank0p[RegRXFreqLsb])) |
    a632:	5f 44 04 00 	mov.b	4(r4),	r15	;
    a636:	0f de       	bis	r14,	r15	;
    a638:	8d 4f 0a 00 	mov	r15,	10(r13)	; 0x000a
    a63c:	8d 4c 0c 00 	mov	r12,	12(r13)	; 0x000c

0000a640 <.Loc.277.2>:
               ((uint32_t)(bank0p[RegRXFreqMsb]) << 24) );
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
                     ((uint32_t)(bank0p[RegRXDevLmb]) << 8) |
                     ((uint32_t)(bank0p[RegRXDevHmb]) << 16) |
    a640:	5e 44 0d 00 	mov.b	13(r4),	r14	;0x0000d
    a644:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a648:	5c 44 0f 00 	mov.b	15(r4),	r12	;0x0000f
    a64c:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a650:	5f 44 0e 00 	mov.b	14(r4),	r15	;0x0000e
    a654:	0c df       	bis	r15,	r12	;

0000a656 <.Loc.275.2>:
  rx_cfg.fdev = ( ((uint32_t)(bank0p[RegRXDevLsb])) |
    a656:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x0000c
    a65a:	0f de       	bis	r14,	r15	;
    a65c:	8d 4f 0e 00 	mov	r15,	14(r13)	; 0x000e
    a660:	8d 4c 10 00 	mov	r12,	16(r13)	; 0x0010

0000a664 <.Loc.279.2>:
                     ((uint32_t)(bank0p[RegRXDevMsb]) << 24) );
  rx_cfg.rx_bw = (bank0p[RegFilterParams] & 0x0F);
    a664:	5c 44 20 00 	mov.b	32(r4),	r12	;0x00020
    a668:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    a66c:	4e 4c       	mov.b	r12,	r14	;
    a66e:	0f 43       	clr	r15		;
    a670:	8d 4e 12 00 	mov	r14,	18(r13)	; 0x0012
    a674:	8d 4f 14 00 	mov	r15,	20(r13)	; 0x0014

0000a678 <.Loc.282.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
                ((uint32_t)(bank0p[RegRXSyncLmb]) << 8) |
                ((uint32_t)(bank0p[RegRXSyncHmb]) << 16) |
    a678:	5e 44 15 00 	mov.b	21(r4),	r14	;0x00015
    a67c:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    a680:	5c 44 17 00 	mov.b	23(r4),	r12	;0x00017
    a684:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    a688:	5f 44 16 00 	mov.b	22(r4),	r15	;0x00016
    a68c:	0c df       	bis	r15,	r12	;

0000a68e <.Loc.280.2>:
  rx_cfg.sync_word = ( ((uint32_t)(bank0p[RegRXSyncLsb])) |
    a68e:	54 44 14 00 	mov.b	20(r4),	r4	;0x00014
    a692:	04 de       	bis	r14,	r4	;
    a694:	8d 44 16 00 	mov	r4,	22(r13)	; 0x0016
    a698:	8d 4c 18 00 	mov	r12,	24(r13)	; 0x0018

0000a69c <.Loc.284.2>:
                ((uint32_t)(bank0p[RegRXSyncMsb]) << 24) );
  chSysUnlock();
    a69c:	81 4d 00 00 	mov	r13,	0(r1)	;
    a6a0:	89 12       	call	r9		;

0000a6a2 <.LVL86>:
    a6a2:	8a 12       	call	r10		;

0000a6a4 <.LVL87>:


  /* Start the receiver driver and initiate the receive loop */
  sx1212Start(&SX1212D1, &rx_cfg);
    a6a4:	2d 41       	mov	@r1,	r13	;
    a6a6:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a6aa:	b0 12 86 68 	call	#26758		;#0x6886

0000a6ae <.LVL88>:
  
  elyRFDLLRxInit(&SX1212D1);
    a6ae:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a6b2:	b0 12 f0 9f 	call	#-24592	;#0x9ff0

0000a6b6 <.LVL89>:
  
  events = (RFSpiAvailable | RFTxIdle);
    a6b6:	b2 40 00 20 	mov	#8192,	&0xcf9e	;#0x2000
    a6ba:	9e cf 
    a6bc:	92 43 a0 cf 	mov	#1,	&0xcfa0	;r3 As==01

0000a6c0 <.Loc.295.2>:
  
  /* Get events into a consistent state with mailbox */
  chSysLock();
    a6c0:	85 12       	call	r5		;

0000a6c2 <.LVL90>:
    a6c2:	88 12       	call	r8		;

0000a6c4 <.LBB22>:
  chDbgCheckClassI();
    a6c4:	b0 12 26 45 	call	#17702		;#0x4526

0000a6c8 <.LVL92>:
  return chSemGetCounterI(&mbp->fullsem);
    a6c8:	1c 42 74 c8 	mov	&0xc874,r12	;0xc874

0000a6cc <.LBE22>:
  if (chMBGetUsedCountI(&rf_mbox) > 0) {
    a6cc:	4d 43       	clr.b	r13		;
    a6ce:	0d 9c       	cmp	r12,	r13	;
    a6d0:	05 34       	jge	$+12     	;abs 0xa6dc

0000a6d2 <.Loc.297.2>:
    events |= RFPktAvailable;
    a6d2:	b2 d0 00 04 	bis	#1024,	&0xcf9e	;#0x0400
    a6d6:	9e cf 
    a6d8:	82 dd a0 cf 	bis	r13,	&0xcfa0	;

0000a6dc <.L21>:
  }
  chSysUnlock();
    a6dc:	89 12       	call	r9		;

0000a6de <.LVL94>:
    a6de:	8a 12       	call	r10		;

0000a6e0 <.LBB24>:
  mask ^= mask & (mask - (eventmask_t)1);
    a6e0:	44 43       	clr.b	r4		;
    a6e2:	45 43       	clr.b	r5		;

0000a6e4 <.L45>:
  return ((events & bits) == bits);
    a6e4:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e
    a6e8:	3c f0 00 30 	and	#12288,	r12	;#0x3000

0000a6ec <.LBE29>:
  
  while (true) {
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    a6ec:	3c 90 00 30 	cmp	#12288,	r12	;#0x3000
    a6f0:	09 20       	jnz	$+20     	;abs 0xa704

0000a6f2 <.Loc.308.2>:
      /* 
       * Read FifoThresh bytes from the Fifo using spiStartReceive
       *  In the callback - signal SpiAvailable, and post buffer and signal RxIdle if applicable
       * Clear RxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleRxFifo(&SX1212D1);
    a6f2:	3c 40 30 1d 	mov	#7472,	r12	;#0x1d30
    a6f6:	b0 12 1c a0 	call	#-24548	;#0xa01c

0000a6fa <.LVL96>:
      events &= ~(RFSpiAvailable | RFRxFifoThresh);
    a6fa:	b2 f0 ff cf 	and	#-12289,&0xcf9e	;#0xcfff
    a6fe:	9e cf 
    a700:	82 c3 a0 cf 	bic	#0,	&0xcfa0	;r3 As==00

0000a704 <.L22>:
  return ((events & bits) == bits);
    a704:	1d 42 9e cf 	mov	&0xcf9e,r13	;0xcf9e
    a708:	3d f0 00 28 	and	#10240,	r13	;#0x2800
    a70c:	1c 42 a0 cf 	mov	&0xcfa0,r12	;0xcfa0
    a710:	5c f3       	and.b	#1,	r12	;r3 As==01

0000a712 <.LBE31>:
    }
    if (bits_set(events, (RFSpiAvailable | RFTxFrameReady | RFTxIdle))) {
    a712:	3d 90 00 28 	cmp	#10240,	r13	;#0x2800
    a716:	0b 20       	jnz	$+24     	;abs 0xa72e
    a718:	1c 93       	cmp	#1,	r12	;r3 As==01
    a71a:	09 20       	jnz	$+20     	;abs 0xa72e

0000a71c <.Loc.312.2>:
      elyRFDLLInitiateTransmit(&SX1278D1);
    a71c:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a720:	b0 12 b0 a1 	call	#-24144	;#0xa1b0

0000a724 <.LVL97>:
      events &= ~(RFSpiAvailable | RFTxFrameReady | RFTxIdle);
    a724:	b2 f0 ff d7 	and	#-10241,&0xcf9e	;#0xd7ff
    a728:	9e cf 
    a72a:	92 c3 a0 cf 	bic	#1,	&0xcfa0	;r3 As==01

0000a72e <.L23>:
  return ((events & bits) == bits);
    a72e:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e
    a732:	3c f0 00 a0 	and	#-24576,r12	;#0xa000

0000a736 <.LBE33>:
    }
    if (bits_set(events, (RFTxFifoLevel | RFSpiAvailable))) {
    a736:	3c 90 00 a0 	cmp	#-24576,r12	;#0xa000
    a73a:	09 20       	jnz	$+20     	;abs 0xa74e

0000a73c <.Loc.322.2>:
       * Write FifoSize or BytesRemaining bytes to the Fifo using spiStartSend
       *  In the callback - signal SpiAvailable, and TxIdle if applicable
       *  TxFifoThresh signaled by PAL callback
       * Clear TxFifoThresh and SpiAvailable from Events variable
       */
      elyRFDLLHandleTxFifo(&SX1278D1);
    a73c:	3c 40 24 1d 	mov	#7460,	r12	;#0x1d24
    a740:	b0 12 d6 a1 	call	#-24106	;#0xa1d6

0000a744 <.LVL98>:
      events &= ~(RFSpiAvailable | RFTxFifoLevel);
    a744:	b2 f0 ff 5f 	and	#24575,	&0xcf9e	;#0x5fff
    a748:	9e cf 
    a74a:	82 c3 a0 cf 	bic	#0,	&0xcfa0	;r3 As==00

0000a74e <.L24>:
    }
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    a74e:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e

0000a752 <.LBB35>:
  return ((events & bits) == bits);
    a752:	1d 42 a0 cf 	mov	&0xcfa0,r13	;0xcfa0
    a756:	5d f3       	and.b	#1,	r13	;r3 As==01

0000a758 <.LBE35>:
    if (bits_set(events, (RFPktAvailable | RFTxIdle)) && !(events & RFTxFrameReady)) {
    a758:	3c b0 00 04 	bit	#1024,	r12	;#0x0400
    a75c:	0f 24       	jz	$+32     	;abs 0xa77c
    a75e:	1d 93       	cmp	#1,	r13	;r3 As==01
    a760:	0d 20       	jnz	$+28     	;abs 0xa77c

0000a762 <.Loc.325.2>:
    a762:	3c b0 00 08 	bit	#2048,	r12	;#0x0800
    a766:	0a 20       	jnz	$+22     	;abs 0xa77c

0000a768 <.Loc.331.2>:
      /*
       * Turn the NL packet into a DLL frame. Do it outside a lock zone.
       * Once the frame is ready, signal TxFrameReady to start transmission
       * Clear RFPktAvailable from Events variable
       */
      elyRFDLLBuildFrame();
    a768:	b0 12 d6 9d 	call	#-25130	;#0x9dd6

0000a76c <.LVL99>:
      events &= ~RFPktAvailable;
    a76c:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e
    a770:	3c f0 ff fb 	and	#-1025,	r12	;#0xfbff

0000a774 <.Loc.333.2>:
      events |= (RFTxFrameReady);
    a774:	3c d0 00 08 	bis	#2048,	r12	;#0x0800
    a778:	82 4c 9e cf 	mov	r12,	&0xcf9e	;

0000a77c <.L25>:
  return ((events & bits) == bits);
    a77c:	1d 42 9e cf 	mov	&0xcf9e,r13	;0xcf9e
    a780:	3d f0 55 21 	and	#8533,	r13	;#0x2155
    a784:	1c 42 a0 cf 	mov	&0xcfa0,r12	;0xcfa0
    a788:	5c f3       	and.b	#1,	r12	;r3 As==01

0000a78a <.LBE37>:
    }
    if (bits_set(events, (RFTxCfgMask | RFTxIdle | RFSpiAvailable))) {
    a78a:	3d 90 55 21 	cmp	#8533,	r13	;#0x2155
    a78e:	0b 20       	jnz	$+24     	;abs 0xa7a6
    a790:	1c 93       	cmp	#1,	r12	;r3 As==01
    a792:	09 20       	jnz	$+20     	;abs 0xa7a6

0000a794 <.LBB39>:
      while (events & RFTxCfgMask) {
        eventmask_t evt = get_next_event(events & RFTxCfgMask);
        
        switch (evt) {
    a794:	39 40 b0 b0 	mov	#-20304,r9	;#0xb0b0

0000a798 <.L26>:
      while (events & RFTxCfgMask) {
    a798:	16 42 9e cf 	mov	&0xcf9e,r6	;0xcf9e
    a79c:	36 f0 55 01 	and	#341,	r6	;#0x0155
    a7a0:	47 43       	clr.b	r7		;
    a7a2:	06 97       	cmp	r7,	r6	;
    a7a4:	1d 20       	jnz	$+60     	;abs 0xa7e0

0000a7a6 <.L44>:
  return ((events & bits) == bits);
    a7a6:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e
    a7aa:	3c f0 aa 60 	and	#24746,	r12	;#0x60aa

0000a7ae <.LBE40>:
        
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    if (bits_set(events, (RFRxCfgMask | RFRxIdle | RFSpiAvailable))) {
    a7ae:	3c 90 aa 60 	cmp	#24746,	r12	;#0x60aa
    a7b2:	0c 20       	jnz	$+26     	;abs 0xa7cc

0000a7b4 <.LBB42>:
      while (events & RFRxCfgMask) {
        eventmask_t evt = get_next_event(events & RFRxCfgMask);
        
        switch (evt) {
    a7b4:	39 40 b0 b0 	mov	#-20304,r9	;#0xb0b0

0000a7b8 <.L28>:
      while (events & RFRxCfgMask) {
    a7b8:	1c 42 9e cf 	mov	&0xcf9e,r12	;0xcf9e
    a7bc:	7c f0 aa 00 	and.b	#170,	r12	;#0x00aa
    a7c0:	81 4c 02 00 	mov	r12,	2(r1)	;
    a7c4:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    a7c8:	0c 93       	cmp	#0,	r12	;r3 As==00
    a7ca:	40 20       	jnz	$+130    	;abs 0xa84c

0000a7cc <.L30>:
        /* Remove event from mask */
        events &= ~evt;
      }
    }
    
    events |= chEvtWaitAnyTimeout(AllRfEvents, TIME_INFINITE);
    a7cc:	4e 43       	clr.b	r14		;
    a7ce:	3c 43       	mov	#-1,	r12	;r3 As==11
    a7d0:	5d 43       	mov.b	#1,	r13	;r3 As==01
    a7d2:	b0 12 ba 48 	call	#18618		;#0x48ba

0000a7d6 <.LVL100>:
    a7d6:	82 dc 9e cf 	bis	r12,	&0xcf9e	;
    a7da:	82 dd a0 cf 	bis	r13,	&0xcfa0	;

0000a7de <.Loc.302.2>:
    if (bits_set(events, (RFRxFifoThresh | RFSpiAvailable))) {
    a7de:	82 3f       	jmp	$-250    	;abs 0xa6e4

0000a7e0 <.L43>:
  mask ^= mask & (mask - (eventmask_t)1);
    a7e0:	0a 44       	mov	r4,	r10	;
    a7e2:	0b 45       	mov	r5,	r11	;
    a7e4:	0a 86       	sub	r6,	r10	;
    a7e6:	0b 77       	subc	r7,	r11	;
    a7e8:	0a f6       	and	r6,	r10	;

0000a7ea <.LBE28>:
        switch (evt) {
    a7ea:	3a 90 10 00 	cmp	#16,	r10	;#0x0010
    a7ee:	07 20       	jnz	$+16     	;abs 0xa7fe

0000a7f0 <.Loc.347.2>:
            elyRFChangeTxDevS(&tx_cfg);
    a7f0:	3c 40 30 c8 	mov	#-14288,r12	;#0xc830
    a7f4:	b0 12 dc a3 	call	#-23588	;#0xa3dc

0000a7f8 <.L31>:
        events &= ~evt;
    a7f8:	82 ca 9e cf 	bic	r10,	&0xcf9e	;
    a7fc:	cd 3f       	jmp	$-100    	;abs 0xa798

0000a7fe <.L33>:
        switch (evt) {
    a7fe:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    a802:	4f 43       	clr.b	r15		;
    a804:	0c 4a       	mov	r10,	r12	;
    a806:	4d 43       	clr.b	r13		;
    a808:	89 12       	call	r9		;
    a80a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    a80c:	0e 9c       	cmp	r12,	r14	;
    a80e:	09 28       	jnc	$+20     	;abs 0xa822
    a810:	0a 9e       	cmp	r14,	r10	;
    a812:	12 24       	jz	$+38     	;abs 0xa838
    a814:	2a 92       	cmp	#4,	r10	;r2 As==10
    a816:	f0 23       	jnz	$-30     	;abs 0xa7f8

0000a818 <.Loc.344.2>:
            elyRFChangeTxBRS(&tx_cfg);
    a818:	3c 40 30 c8 	mov	#-14288,r12	;#0xc830
    a81c:	b0 12 3c a3 	call	#-23748	;#0xa33c

0000a820 <.LVL105>:
            break;
    a820:	eb 3f       	jmp	$-40     	;abs 0xa7f8

0000a822 <.L34>:
        switch (evt) {
    a822:	3a 90 40 00 	cmp	#64,	r10	;#0x0040
    a826:	0d 24       	jz	$+28     	;abs 0xa842
    a828:	3a 90 00 01 	cmp	#256,	r10	;#0x0100
    a82c:	e5 23       	jnz	$-52     	;abs 0xa7f8

0000a82e <.L41>:
            elyRFChangeTxPowerS(&tx_cfg);
    a82e:	3c 40 30 c8 	mov	#-14288,r12	;#0xc830
    a832:	b0 12 cc a4 	call	#-23348	;#0xa4cc

0000a836 <.LVL106>:
            break;
    a836:	e0 3f       	jmp	$-62     	;abs 0xa7f8

0000a838 <.L57>:
            elyRFChangeTxFreqS(&tx_cfg);
    a838:	3c 40 30 c8 	mov	#-14288,r12	;#0xc830
    a83c:	b0 12 9e a2 	call	#-23906	;#0xa29e

0000a840 <.LVL107>:
            break;
    a840:	db 3f       	jmp	$-72     	;abs 0xa7f8

0000a842 <.L59>:
            elyRFChangeTxSyncS(&tx_cfg);
    a842:	3c 40 30 c8 	mov	#-14288,r12	;#0xc830
    a846:	b0 12 76 9c 	call	#-25482	;#0x9c76

0000a84a <.LVL108>:
    a84a:	f1 3f       	jmp	$-28     	;abs 0xa82e

0000a84c <.L56>:
  mask ^= mask & (mask - (eventmask_t)1);
    a84c:	0a 44       	mov	r4,	r10	;
    a84e:	0b 45       	mov	r5,	r11	;
    a850:	1a 81 02 00 	sub	2(r1),	r10	;
    a854:	1b 71 04 00 	subc	4(r1),	r11	;
    a858:	1a f1 02 00 	and	2(r1),	r10	;

0000a85c <.LBE43>:
        switch (evt) {
    a85c:	3a 92       	cmp	#8,	r10	;r2 As==11
    a85e:	07 20       	jnz	$+16     	;abs 0xa86e

0000a860 <.Loc.374.2>:
            elyRFChangeRxBRS(&rx_cfg);
    a860:	3c 40 0e c8 	mov	#-14322,r12	;#0xc80e
    a864:	b0 12 8c a3 	call	#-23668	;#0xa38c

0000a868 <.L46>:
        events &= ~evt;
    a868:	82 ca 9e cf 	bic	r10,	&0xcf9e	;
    a86c:	a5 3f       	jmp	$-180    	;abs 0xa7b8

0000a86e <.L48>:
        switch (evt) {
    a86e:	7e 42       	mov.b	#8,	r14	;r2 As==11
    a870:	4f 43       	clr.b	r15		;
    a872:	0c 4a       	mov	r10,	r12	;
    a874:	4d 43       	clr.b	r13		;
    a876:	89 12       	call	r9		;
    a878:	5f 43       	mov.b	#1,	r15	;r3 As==01
    a87a:	0f 9c       	cmp	r12,	r15	;
    a87c:	07 28       	jnc	$+16     	;abs 0xa88c
    a87e:	2a 93       	cmp	#2,	r10	;r3 As==10
    a880:	f3 23       	jnz	$-24     	;abs 0xa868

0000a882 <.Loc.371.2>:
            elyRFChangeRxFreqS(&rx_cfg);
    a882:	3c 40 0e c8 	mov	#-14322,r12	;#0xc80e
    a886:	b0 12 ec a2 	call	#-23828	;#0xa2ec

0000a88a <.LVL113>:
            break;
    a88a:	ee 3f       	jmp	$-34     	;abs 0xa868

0000a88c <.L49>:
        switch (evt) {
    a88c:	3a 90 20 00 	cmp	#32,	r10	;#0x0020
    a890:	0c 24       	jz	$+26     	;abs 0xa8aa
    a892:	3a 90 80 00 	cmp	#128,	r10	;#0x0080
    a896:	e8 23       	jnz	$-46     	;abs 0xa868

0000a898 <.Loc.380.2>:
            elyRFChangeRxSyncS(&rx_cfg);
    a898:	3c 40 0e c8 	mov	#-14322,r12	;#0xc80e
    a89c:	b0 12 7c a4 	call	#-23428	;#0xa47c

0000a8a0 <.LVL114>:
            elyRFChangeRxFilterParamsS(&rx_cfg);
    a8a0:	3c 40 0e c8 	mov	#-14322,r12	;#0xc80e
    a8a4:	b0 12 e2 a4 	call	#-23326	;#0xa4e2

0000a8a8 <.LVL115>:
            break;
    a8a8:	df 3f       	jmp	$-64     	;abs 0xa868

0000a8aa <.L61>:
            elyRFChangeRxDevS(&rx_cfg);
    a8aa:	3c 40 0e c8 	mov	#-14322,r12	;#0xc80e
    a8ae:	b0 12 2c a4 	call	#-23508	;#0xa42c

0000a8b2 <.LVL116>:
            break;
    a8b2:	da 3f       	jmp	$-74     	;abs 0xa868

0000a8b4 <nl_allocator>:
  (void)(align);
  /* Provides memory blocks for the pool */
  /* TODO fix this to use PERSIST when GCC fixes bug #78818 */
  static size_t __attribute__((section(".persistent"))) curr_index = 0;
  
  if (curr_index + size > elyNLTotalBuffer) {
    a8b4:	1d 42 7e c8 	mov	&0xc87e,r13	;0xc87e

0000a8b8 <.LVL1>:
    a8b8:	0e 4d       	mov	r13,	r14	;
    a8ba:	0e 5c       	add	r12,	r14	;
    a8bc:	3c 40 00 20 	mov	#8192,	r12	;#0x2000

0000a8c0 <.LVL2>:
    a8c0:	0c 9e       	cmp	r14,	r12	;
    a8c2:	06 28       	jnc	$+14     	;abs 0xa8d0

0000a8c4 <.Loc.23.1>:
    return NULL;
  }

  void * result = mpool_storage + curr_index;
    a8c4:	0c 4d       	mov	r13,	r12	;
    a8c6:	3c 50       	add,		r12	;Warning: disassembly unreliable - not enough bytes available

0000a8c8 <L0>:
    a8c8:	b2 cf       	bic	@r15+		; Warning: disassembly unreliable - not enough bytes available

0000a8ca <.LVL3>:
  
  curr_index += size;
    a8ca:	82 4e 7e c8 	mov	r14,	&0xc87e	;

0000a8ce <.L1>:
  return result;
}
    a8ce:	30 41       	ret			

0000a8d0 <.L3>:
    return NULL;
    a8d0:	4c 43       	clr.b	r12		;
    a8d2:	fd 3f       	jmp	$-4      	;abs 0xa8ce

0000a8d4 <clamp>:
    a8d4:	1a 15       	pushm	#2,	r10	;16-bit words

0000a8d6 <L0>:

static PERSIST MEMORYPOOL_DECL(main_mpool, elyNLDefaultMaxLen, nl_allocator);

static uint8_t clamp(uint8_t value, uint8_t min, uint8_t max) {
    a8d6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a8da:	49 4d       	mov.b	r13,	r9	;
    a8dc:	4a 4e       	mov.b	r14,	r10	;

0000a8de <.Loc.32.1>:
  if (value < min) {
    a8de:	4c 99       	cmp.b	r9,	r12	;
    a8e0:	07 2c       	jc	$+16     	;abs 0xa8f0

0000a8e2 <.LVL6>:
    value = min;
    elyErrorSignal(ErrRegClip);
    a8e2:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a8e6:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a8ea <.LVL7>:
    a8ea:	0c 49       	mov	r9,	r12	;

0000a8ec <.L6>:
  else if (value > max) {
    value = max;
    elyErrorSignal(ErrRegClip);
  }
  return value;
}
    a8ec:	19 17       	popm	#2,	r10	;16-bit words
    a8ee:	30 41       	ret			

0000a8f0 <.L5>:
  else if (value > max) {
    a8f0:	4a 9c       	cmp.b	r12,	r10	;
    a8f2:	fc 2f       	jc	$-6      	;abs 0xa8ec

0000a8f4 <.LVL10>:
    elyErrorSignal(ErrRegClip);
    a8f4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88
    a8f8:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a8fc <.LVL11>:
    a8fc:	0c 4a       	mov	r10,	r12	;
    a8fe:	f6 3f       	jmp	$-18     	;abs 0xa8ec

0000a900 <elyNLClampReg>:
    a900:	4e 4c       	mov.b	r12,	r14	;

0000a902 <L0>:
    return 0x00;
  }
  return value; /* must be 0x00 at this point */
}

uint8_t elyNLClampReg(uint8_t addr, uint8_t value) {
    a902:	4c 4d       	mov.b	r13,	r12	;

0000a904 <.LVL13>:
  chDbgAssert(addr >= 0x80 && addr < RegNLMAX, "invalid addr");
  switch(addr) {
    a904:	7e 90 83 ff 	cmp.b	#-125,	r14	;#0xff83
    a908:	2f 24       	jz	$+96     	;abs 0xa968
    a90a:	7f 40 83 ff 	mov.b	#-125,	r15	;#0xff83
    a90e:	4f 9e       	cmp.b	r14,	r15	;
    a910:	07 28       	jnc	$+16     	;abs 0xa920
    a912:	7e 90 80 ff 	cmp.b	#-128,	r14	;#0xff80
    a916:	1c 24       	jz	$+58     	;abs 0xa950
    a918:	7e 90 81 ff 	cmp.b	#-127,	r14	;#0xff81
    a91c:	21 24       	jz	$+68     	;abs 0xa960

0000a91e <.L8>:
    default:
      /* All other registers have ranges equal to their data type's */
      break;
  }
  return value;
}
    a91e:	30 41       	ret			

0000a920 <.L10>:
  switch(addr) {
    a920:	7e 90 85 ff 	cmp.b	#-123,	r14	;#0xff85
    a924:	24 24       	jz	$+74     	;abs 0xa96e
    a926:	7e 90 85 ff 	cmp.b	#-123,	r14	;#0xff85
    a92a:	f9 2b       	jnc	$-12     	;abs 0xa91e
    a92c:	7e 50 79 00 	add.b	#121,	r14	;#0x0079
    a930:	5d 43       	mov.b	#1,	r13	;r3 As==01

0000a932 <.LVL16>:
    a932:	4d 9e       	cmp.b	r14,	r13	;
    a934:	f4 2b       	jnc	$-22     	;abs 0xa91e

0000a936 <.LBB4>:
  if ((value & 0x10) && value != 0x10) {
    a936:	3c b0 10 00 	bit	#16,	r12	;#0x0010
    a93a:	1c 24       	jz	$+58     	;abs 0xa974
    a93c:	3c 90 10 00 	cmp	#16,	r12	;#0x0010
    a940:	19 24       	jz	$+52     	;abs 0xa974

0000a942 <.Loc.45.1>:
    elyErrorSignal(ErrRegClip);
    a942:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a946 <.LVL18>:
    a946:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a94a <.LVL19>:
    return 0x10;
    a94a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    a94e:	e7 3f       	jmp	$-48     	;abs 0xa91e

0000a950 <.L11>:
      value = clamp(value, 7, 0xFF);
    a950:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    a952:	7d 40 07 00 	mov.b	#7,	r13	;

0000a956 <.L54>:
      value = clamp(value, 0, 0x10);
    a956:	b0 12 d4 a8 	call	#-22316	;#0xa8d4

0000a95a <.LVL22>:
    a95a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

0000a95e <.LVL23>:
      break;
    a95e:	df 3f       	jmp	$-64     	;abs 0xa91e

0000a960 <.L12>:
      value = clamp(value, 0, 0x10);
    a960:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010

0000a964 <.L55>:
    a964:	4d 43       	clr.b	r13		;

0000a966 <.LVL25>:
    a966:	f7 3f       	jmp	$-16     	;abs 0xa956

0000a968 <.L9>:
      value = clamp(value, 0, 0x07);
    a968:	7e 40 07 00 	mov.b	#7,	r14	;
    a96c:	fb 3f       	jmp	$-8      	;abs 0xa964

0000a96e <.L13>:
      value = clamp(value, 0, 0x3F);
    a96e:	7e 40 3f 00 	mov.b	#63,	r14	;#0x003f
    a972:	f8 3f       	jmp	$-14     	;abs 0xa964

0000a974 <.L15>:
  if ((value & 0x08) && value != 0x08) {
    a974:	3c b2       	bit	#8,	r12	;r2 As==11
    a976:	08 24       	jz	$+18     	;abs 0xa988
    a978:	3c 92       	cmp	#8,	r12	;r2 As==11
    a97a:	06 24       	jz	$+14     	;abs 0xa988

0000a97c <.Loc.49.1>:
    elyErrorSignal(ErrRegClip);
    a97c:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a980 <.LVL28>:
    a980:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a984 <.LVL29>:
    return 0x08;
    a984:	7c 42       	mov.b	#8,	r12	;r2 As==11
    a986:	cb 3f       	jmp	$-104    	;abs 0xa91e

0000a988 <.L16>:
  if ((value & 0x04) && value != 0x04) {
    a988:	2c b2       	bit	#4,	r12	;r2 As==10
    a98a:	08 24       	jz	$+18     	;abs 0xa99c
    a98c:	2c 92       	cmp	#4,	r12	;r2 As==10
    a98e:	06 24       	jz	$+14     	;abs 0xa99c

0000a990 <.Loc.53.1>:
    elyErrorSignal(ErrRegClip);
    a990:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a994 <.LVL31>:
    a994:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a998 <.LVL32>:
    return 0x04;
    a998:	6c 42       	mov.b	#4,	r12	;r2 As==10
    a99a:	c1 3f       	jmp	$-124    	;abs 0xa91e

0000a99c <.L17>:
  if ((value & 0x02) && value != 0x02) {
    a99c:	2c b3       	bit	#2,	r12	;r3 As==10
    a99e:	08 24       	jz	$+18     	;abs 0xa9b0
    a9a0:	2c 93       	cmp	#2,	r12	;r3 As==10
    a9a2:	06 24       	jz	$+14     	;abs 0xa9b0

0000a9a4 <.Loc.57.1>:
    elyErrorSignal(ErrRegClip);
    a9a4:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a9a8 <.LVL34>:
    a9a8:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a9ac <.LVL35>:
    return 0x02;
    a9ac:	6c 43       	mov.b	#2,	r12	;r3 As==10
    a9ae:	b7 3f       	jmp	$-144    	;abs 0xa91e

0000a9b0 <.L18>:
  if ((value & 0x01) && value != 0x01) {
    a9b0:	1c b3       	bit	#1,	r12	;r3 As==01
    a9b2:	08 24       	jz	$+18     	;abs 0xa9c4
    a9b4:	1c 93       	cmp	#1,	r12	;r3 As==01
    a9b6:	06 24       	jz	$+14     	;abs 0xa9c4

0000a9b8 <.Loc.61.1>:
    elyErrorSignal(ErrRegClip);
    a9b8:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a9bc <.LVL37>:
    a9bc:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a9c0 <.LVL38>:
    return 0x01;
    a9c0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a9c2:	ad 3f       	jmp	$-164    	;abs 0xa91e

0000a9c4 <.L19>:
  if (value & 0xD0) {
    a9c4:	7c b0 d0 ff 	bit.b	#-48,	r12	;#0xffd0
    a9c8:	aa 27       	jz	$-170    	;abs 0xa91e

0000a9ca <.Loc.65.1>:
    elyErrorSignal(ErrRegClip);
    a9ca:	7c 40 88 ff 	mov.b	#-120,	r12	;#0xff88

0000a9ce <.LVL40>:
    a9ce:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000a9d2 <.LVL41>:
    return 0x00;
    a9d2:	4c 43       	clr.b	r12		;
    a9d4:	a4 3f       	jmp	$-182    	;abs 0xa91e

0000a9d6 <elyNLGetBuffer>:
    a9d6:	3c 40 78 c8 	mov	#-14216,r12	;#0xc878
  elyNLMaxLen = len;
  main_mpool.object_size = elyNLMaxLen;
}

uint8_t * elyNLGetBuffer() {
  return chPoolAlloc(&main_mpool);
    a9da:	b0 12 a2 4a 	call	#19106		;#0x4aa2

0000a9de <.LVL48>:
}
    a9de:	30 41       	ret			

0000a9e0 <elyNLFreeBuffer>:

void elyNLFreeBuffer(uint8_t * buffer) {
  chPoolFree(&main_mpool, buffer);
    a9e0:	0d 4c       	mov	r12,	r13	;
    a9e2:	3c 40 78 c8 	mov	#-14216,r12	;#0xc878

0000a9e6 <.LVL50>:
    a9e6:	b0 12 e0 4a 	call	#19168		;#0x4ae0

0000a9ea <L0>:
}
    a9ea:	30 41       	ret			

0000a9ec <elyNLGetBufferI>:

uint8_t * elyNLGetBufferI() {
  chDbgCheckClassI();
    a9ec:	b0 12 26 45 	call	#17702		;#0x4526

0000a9f0 <.LVL52>:
  return chPoolAllocI(&main_mpool);
    a9f0:	3c 40 78 c8 	mov	#-14216,r12	;#0xc878
    a9f4:	b0 12 7a 4a 	call	#19066		;#0x4a7a

0000a9f8 <.LVL53>:
}
    a9f8:	30 41       	ret			

0000a9fa <elyNLFreeBufferI>:

void elyNLFreeBufferI(uint8_t * buffer) {
    a9fa:	0a 15       	pushm	#1,	r10	;16-bit words

0000a9fc <.LCFI2>:
    a9fc:	0a 4c       	mov	r12,	r10	;

0000a9fe <.Loc.125.1>:
  chDbgCheckClassI();
    a9fe:	b0 12 26 45 	call	#17702		;#0x4526

0000aa02 <.LVL55>:
  chPoolFreeI(&main_mpool, buffer);
    aa02:	0d 4a       	mov	r10,	r13	;
    aa04:	3c 40 78 c8 	mov	#-14216,r12	;#0xc878
    aa08:	b0 12 ca 4a 	call	#19146		;#0x4aca

0000aa0c <.LVL56>:
}
    aa0c:	0a 17       	popm	#1,	r10	;16-bit words
    aa0e:	30 41       	ret			

0000aa10 <elyNLGetDest>:
   * Else If (TC) UART
   * Else (TM) If (Source == Elysium AND APID != GroundAPID) UART
   * Else RF */
  
  /* TODO better constants */
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    aa10:	6d 4c       	mov.b	@r12,	r13	;
    aa12:	5f 4c 01 00 	mov.b	1(r12),	r15	;

0000aa16 <.LVL58>:
    aa16:	1e 42 be bd 	mov	&0xbdbe,r14	;0xbdbe
    aa1a:	5c 4e 51 00 	mov.b	81(r14),r12	;0x00051

0000aa1e <.LVL59>:
    aa1e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    aa22:	5e 4e 50 00 	mov.b	80(r14),r14	;0x00050
    aa26:	0c de       	bis	r14,	r12	;

0000aa28 <.LVL60>:
  uint16_t elysium_apid = ( ((bank0p[RegSrcAddrMsb] << 8) | 
        (bank0p[RegSrcAddrLsb])) );
  bool tc = buffer[0] & 0x10;
  
  if (tc) {
    aa28:	3d b0 10 00 	bit	#16,	r13	;#0x0010
    aa2c:	09 24       	jz	$+20     	;abs 0xaa40

0000aa2e <.Loc.160.1>:
  uint16_t apid = ( ((buffer[0] & 0x07) << 8) | (buffer[1]) );
    aa2e:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;

0000aa32 <.LVL61>:
    aa32:	3d f0 00 07 	and	#1792,	r13	;#0x0700
    aa36:	0d df       	bis	r15,	r13	;

0000aa38 <.Loc.166.1>:
    if (apid == elysium_apid)
    aa38:	0d 9c       	cmp	r12,	r13	;
    aa3a:	04 24       	jz	$+10     	;abs 0xaa44

0000aa3c <.Loc.169.1>:
      return ELY_DEST_FW;
    else
      return ELY_DEST_UART;
    aa3c:	4c 43       	clr.b	r12		;

0000aa3e <.L66>:
    return ELY_DEST_RF;
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    aa3e:	30 41       	ret			

0000aa40 <.L67>:
    return ELY_DEST_RF;
    aa40:	5c 43       	mov.b	#1,	r12	;r3 As==01
    aa42:	fd 3f       	jmp	$-4      	;abs 0xaa3e

0000aa44 <.L68>:
      return ELY_DEST_FW;
    aa44:	6c 43       	mov.b	#2,	r12	;r3 As==10
    aa46:	fb 3f       	jmp	$-8      	;abs 0xaa3e

0000aa48 <get_sh_len>:
    aa48:	1c 42 be bd 	mov	&0xbdbe,r12	;0xbdbe

0000aa4c <L0>:

size_t get_sh_len(void) {
  uint8_t options = bank0p[RegNLOptions];
    aa4c:	5c 4c 86 00 	mov.b	134(r12),r12	;0x00086

0000aa50 <.Loc.183.1>:
  if (options & 0x02) { /* Timestamp */
    aa50:	2c b3       	bit	#2,	r12	;r3 As==10
    aa52:	04 24       	jz	$+10     	;abs 0xaa5c

0000aa54 <.Loc.184.1>:
    if (options & 0x01) { /* P-field */
    aa54:	1c b3       	bit	#1,	r12	;r3 As==01
    aa56:	04 20       	jnz	$+10     	;abs 0xaa60

0000aa58 <.Loc.190.1>:
      /* 5-byte Secondary Header + 6-byte Primary Header */
      return 5;
    }
    else { /* No P-field */
      /* 4-byte Secondary Header + 6-byte Primary Header */
      return 4;
    aa58:	6c 42       	mov.b	#4,	r12	;r2 As==10

0000aa5a <.L69>:
    }
  }
  
  return 0;
}
    aa5a:	30 41       	ret			

0000aa5c <.L71>:
  return 0;
    aa5c:	4c 43       	clr.b	r12		;
    aa5e:	fd 3f       	jmp	$-4      	;abs 0xaa5a

0000aa60 <.L72>:
      return 5;
    aa60:	7c 40 05 00 	mov.b	#5,	r12	;
    aa64:	fa 3f       	jmp	$-10     	;abs 0xaa5a

0000aa66 <elyNLSetDest>:
    aa66:	1f 42 be bd 	mov	&0xbdbe,r15	;0xbdbe

0000aa6a <L0>:

elysium_destinations_t elyNLSetDest(uint8_t * buffer) {
  uint16_t apid;
  if (buffer[0] & 0x08) { /* Secondary Header flag - Timestamp */
    aa6a:	fc b2 00 00 	bit.b	#8,	0(r12)	;r2 As==11
    aa6e:	1a 24       	jz	$+54     	;abs 0xaaa4

0000aa70 <.Loc.200.1>:
    if (bank0p[RegNLOptions] & 0x01) { /* P-field - SH 5 bytes */
    aa70:	df b3 86 00 	bit.b	#1,	134(r15);r3 As==01, 0x0086
    aa74:	14 24       	jz	$+42     	;abs 0xaa9e

0000aa76 <.Loc.202.1>:
      /* PH 6 bytes, SH 5 bytes, EH 2 bytes */
      apid = ( ((buffer[13] << 8) & 0x07) | (buffer[14]) );
    aa76:	5d 4c 0e 00 	mov.b	14(r12),r13	;0x0000e

0000aa7a <.L76>:
    /* PH 6 bytes, EH 2 bytes */
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
  }
  
  /* Set APID */
  buffer[0] = (apid >> 8);
    aa7a:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

0000aa7e <.Loc.215.1>:
  buffer[1] = (apid & 0xFF);
    aa7e:	cc 4d 01 00 	mov.b	r13,	1(r12)	;

0000aa82 <.Loc.220.1>:
  
  uint16_t ground_apid = ( ((bank0p[RegNLGroundAPIDMsb] << 8) | 
        (bank0p[RegNLGroundAPIDLsb])) );
  
  if (apid == ground_apid) {
    aa82:	5e 4f 83 00 	mov.b	131(r15),r14	;0x00083
    aa86:	47 18 0e 5e 	rpt #8 { rlax.w	r14		;
    aa8a:	5f 4f 82 00 	mov.b	130(r15),r15	;0x00082
    aa8e:	0e df       	bis	r15,	r14	;
    aa90:	0d 9e       	cmp	r14,	r13	;
    aa92:	0b 24       	jz	$+24     	;abs 0xaaaa

0000aa94 <.Loc.225.1>:
    return ELY_DEST_RF;
  }
  else {
    /* Remember to set it to TC mode */
    buffer[0] |= 0x10;
    aa94:	fc 40 10 00 	mov.b	#16,	0(r12)	;#0x0010
    aa98:	00 00 

0000aa9a <.Loc.226.1>:
    return ELY_DEST_UART;
    aa9a:	4c 43       	clr.b	r12		;

0000aa9c <.L77>:
  }
  
  osalDbgAssert(false, "unreachable code path");
  return 0;
}
    aa9c:	30 41       	ret			

0000aa9e <.L75>:
      apid = ( ((buffer[12] << 8) & 0x07) | (buffer[13]) );
    aa9e:	5d 4c 0d 00 	mov.b	13(r12),r13	;0x0000d

0000aaa2 <.LVL71>:
    aaa2:	eb 3f       	jmp	$-40     	;abs 0xaa7a

0000aaa4 <.L74>:
    apid = ( ((buffer[8] << 8) & 0x07) | (buffer[9]) );
    aaa4:	5d 4c 09 00 	mov.b	9(r12),	r13	;

0000aaa8 <.LVL73>:
    aaa8:	e8 3f       	jmp	$-46     	;abs 0xaa7a

0000aaaa <.L78>:
    return ELY_DEST_RF;
    aaaa:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000aaac <.LVL75>:
    aaac:	f7 3f       	jmp	$-16     	;abs 0xaa9c

0000aaae <elyNLGetLength>:
    aaae:	5d 4c 04 00 	mov.b	4(r12),	r13	;

size_t elyNLGetLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) + elyNLHeaderLen + 1;
    aab2:	47 18 0d 5d 	.word	0x1847, 0xffff;	????

0000aab4 <L0>:
    aab4:	0d 5d       	rla	r13		;
    aab6:	5c 4c 05 00 	mov.b	5(r12),	r12	;

0000aaba <.LVL77>:
    aaba:	0c dd       	bis	r13,	r12	;

0000aabc <.Loc.235.1>:
}
    aabc:	3c 50 07 00 	add	#7,	r12	;
    aac0:	30 41       	ret			

0000aac2 <elyNLValidate>:
bool elyNLValidate(const uint8_t * buffer) {
    aac2:	21 83       	decd	r1		;

0000aac4 <.LCFI3>:
  if (buffer[0] & 0xE0) {
    aac4:	fc b0 e0 ff 	bit.b	#-32,	0(r12)	;#0xffe0
    aac8:	00 00 
    aaca:	07 24       	jz	$+16     	;abs 0xaada

0000aacc <.Loc.135.1>:
    elyErrorSignal(ErrNLPVNMismatch);
    aacc:	7c 40 a0 ff 	mov.b	#-96,	r12	;#0xffa0

0000aad0 <.L84>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    aad0:	b0 12 5a ac 	call	#-21414	;#0xac5a

0000aad4 <.LVL80>:
    return false;
    aad4:	4c 43       	clr.b	r12		;

0000aad6 <.L82>:
}
    aad6:	21 53       	incd	r1		;
    aad8:	30 41       	ret			

0000aada <.L81>:
  _disable_interrupts();
    aada:	32 c2       	dint			

0000aadc <.Loc.348.2>:
  asm volatile("nop");
    aadc:	03 43       	nop			

0000aade <.LBE15>:
  chSysLock();
    aade:	81 4c 00 00 	mov	r12,	0(r1)	;
    aae2:	b0 12 5a 44 	call	#17498		;#0x445a

0000aae6 <.LVL82>:
  if ( elyNLGetLength(buffer) > 
    aae6:	2c 41       	mov	@r1,	r12	;
    aae8:	b0 12 ae aa 	call	#-21842	;#0xaaae

0000aaec <.LVL83>:
      ((uint16_t)(bank0p[RegNLMaxPktLengthMsb] << 8) | (uint16_t)(bank0p[RegNLMaxPktLengthLsb])) ) {
    aaec:	1e 42 be bd 	mov	&0xbdbe,r14	;0xbdbe
    aaf0:	5d 4e 81 00 	mov.b	129(r14),r13	;0x00081
    aaf4:	47 18 0d 5d 	rpt #8 { rlax.w	r13		;
    aaf8:	5e 4e 80 00 	mov.b	128(r14),r14	;0x00080
    aafc:	0d de       	bis	r14,	r13	;
    aafe:	3e 40 78 44 	mov	#17528,	r14	;#0x4478

0000ab02 <.Loc.141.1>:
  if ( elyNLGetLength(buffer) > 
    ab02:	0d 9c       	cmp	r12,	r13	;
    ab04:	07 2c       	jc	$+16     	;abs 0xab14

0000ab06 <.Loc.143.1>:
    chSysUnlock();
    ab06:	8e 12       	call	r14		;

0000ab08 <.LBB17>:
  asm volatile("nop");
    ab08:	03 43       	nop			

0000ab0a <.Loc.356.2>:
  _enable_interrupts();
    ab0a:	32 d2       	eint			
    ab0c:	03 43       	nop			

0000ab0e <.LBE17>:
    elyErrorSignal(ErrNLPacketLengthMismatch);
    ab0e:	7c 40 a1 ff 	mov.b	#-95,	r12	;#0xffa1
    ab12:	de 3f       	jmp	$-66     	;abs 0xaad0

0000ab14 <.L83>:
  chSysUnlock();
    ab14:	8e 12       	call	r14		;

0000ab16 <.LBB19>:
  asm volatile("nop");
    ab16:	03 43       	nop			

0000ab18 <.Loc.356.2>:
  _enable_interrupts();
    ab18:	32 d2       	eint			
    ab1a:	03 43       	nop			

0000ab1c <.LBE19>:
  return true;
    ab1c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ab1e:	db 3f       	jmp	$-72     	;abs 0xaad6

0000ab20 <elyNLExtract>:
    ab20:	0a 15       	pushm	#1,	r10	;16-bit words

0000ab22 <.LCFI5>:

size_t elyNLGetPayloadLength(const uint8_t * buffer) {
  return ((buffer[4] << 8) | (buffer[5])) - get_sh_len() + 1;
}

uint8_t * elyNLExtract(uint8_t * buffer) {
    ab22:	0a 4c       	mov	r12,	r10	;

0000ab24 <L0>:
  /* 6-byte Primary Header */
  return buffer + get_sh_len() + 6;
    ab24:	b0 12 48 aa 	call	#-21944	;#0xaa48

0000ab28 <.LVL90>:
    ab28:	3c 50 06 00 	add	#6,	r12	;

0000ab2c <.Loc.244.1>:
}
    ab2c:	0c 5a       	add	r10,	r12	;
    ab2e:	0a 17       	popm	#1,	r10	;16-bit words
    ab30:	30 41       	ret			

0000ab32 <elyNLPack>:

uint8_t * elyNLPack(uint8_t * buffer) {
    ab32:	2a 15       	pushm	#3,	r10	;16-bit words

0000ab34 <.LCFI6>:
    ab34:	09 4c       	mov	r12,	r9	;

0000ab36 <.Loc.248.1>:
  /* 6-byte Primary Header */
  uint8_t * result = buffer - get_sh_len() - 6;
    ab36:	b0 12 48 aa 	call	#-21944	;#0xaa48

0000ab3a <.LVL92>:
    ab3a:	3a 40 fa ff 	mov	#-6,	r10	;#0xfffa
    ab3e:	0a 8c       	sub	r12,	r10	;
    ab40:	0a 59       	add	r9,	r10	;

0000ab42 <.Loc.249.1>:
  uint16_t length = (buffer[1] + 4 + get_sh_len() - 1);
    ab42:	5d 49 01 00 	mov.b	1(r9),	r13	;
    ab46:	3d 50 03 00 	add	#3,	r13	;
    ab4a:	0c 5d       	add	r13,	r12	;

0000ab4c <.LVL94>:
  result[4] = (length >> 8);
    ab4c:	0d 4c       	mov	r12,	r13	;
    ab4e:	5d 0f       	rrum	#4,	r13	;
    ab50:	5d 0f       	rrum	#4,	r13	;
    ab52:	ca 4d 04 00 	mov.b	r13,	4(r10)	;

0000ab56 <.Loc.251.1>:
  result[5] = (length & 0xFF);
    ab56:	ca 4c 05 00 	mov.b	r12,	5(r10)	;

0000ab5a <.Loc.253.1>:
  
  result[2] = (packets_sent >> 8) | 0xC0;
    ab5a:	1c 42 80 c8 	mov	&0xc880,r12	;0xc880

0000ab5e <.LVL95>:
    ab5e:	0d 4c       	mov	r12,	r13	;
    ab60:	5d 0f       	rrum	#4,	r13	;
    ab62:	5d 0f       	rrum	#4,	r13	;
    ab64:	7d d0 c0 ff 	bis.b	#-64,	r13	;#0xffc0
    ab68:	ca 4d 02 00 	mov.b	r13,	2(r10)	;

0000ab6c <.Loc.254.1>:
  result[3] = (packets_sent & 0xFF);
    ab6c:	ca 4c 03 00 	mov.b	r12,	3(r10)	;

0000ab70 <.Loc.255.1>:
  packets_sent = (packets_sent + 1) & 0x3FFF;
    ab70:	1c 53       	inc	r12		;
    ab72:	3c f0 ff 3f 	and	#16383,	r12	;#0x3fff
    ab76:	82 4c 80 c8 	mov	r12,	&0xc880	;

0000ab7a <.Loc.258.1>:
  
  /* insert timestamps here too if required */
  uint8_t options = bank0p[RegNLOptions];
    ab7a:	19 42 be bd 	mov	&0xbdbe,r9	;0xbdbe

0000ab7e <.LVL96>:
    ab7e:	5d 49 86 00 	mov.b	134(r9),r13	;0x00086

0000ab82 <.LVL97>:
  if (options & 0x02) { /* Timestamp */
    ab82:	2d b3       	bit	#2,	r13	;r3 As==10
    ab84:	1c 24       	jz	$+58     	;abs 0xabbe
    ab86:	3c 40 5a 44 	mov	#17498,	r12	;#0x445a
    ab8a:	38 40 78 44 	mov	#17528,	r8	;#0x4478

0000ab8e <.Loc.260.1>:
    if (options & 0x01) { /* P-field */
    ab8e:	1d b3       	bit	#1,	r13	;r3 As==01
    ab90:	19 24       	jz	$+52     	;abs 0xabc4

0000ab92 <.Loc.261.1>:
      result[6] = SPP_PFIELD;
    ab92:	fa 40 2c 00 	mov.b	#44,	6(r10)	;#0x002c
    ab96:	06 00 

0000ab98 <.LBB29>:
  _disable_interrupts();
    ab98:	32 c2       	dint			

0000ab9a <.Loc.348.2>:
  asm volatile("nop");
    ab9a:	03 43       	nop			

0000ab9c <.LBE29>:
      chSysLock();
    ab9c:	8c 12       	call	r12		;

0000ab9e <.LVL99>:
      result[7] = bank0p[RegMissionTimeMsb];
    ab9e:	da 49 76 00 	mov.b	118(r9),7(r10)	;0x00076
    aba2:	07 00 

0000aba4 <.Loc.264.1>:
      result[8] = bank0p[RegMissionTimeHmb];
    aba4:	da 49 75 00 	mov.b	117(r9),8(r10)	;0x00075
    aba8:	08 00 

0000abaa <.Loc.265.1>:
      result[9] = bank0p[RegMissionTimeLmb];
    abaa:	da 49 74 00 	mov.b	116(r9),9(r10)	;0x00074
    abae:	09 00 

0000abb0 <.Loc.266.1>:
      result[10] = bank0p[RegMissionTimeLsb];
    abb0:	da 49 73 00 	mov.b	115(r9),10(r10)	;0x00073, 0x000a
    abb4:	0a 00 

0000abb6 <.L93>:
      chSysLock();
      result[6] = bank0p[RegMissionTimeMsb];
      result[7] = bank0p[RegMissionTimeHmb];
      result[8] = bank0p[RegMissionTimeLmb];
      result[9] = bank0p[RegMissionTimeLsb];
      chSysUnlock();
    abb6:	88 12       	call	r8		;

0000abb8 <.LBB31>:
  asm volatile("nop");
    abb8:	03 43       	nop			

0000abba <.Loc.356.2>:
  _enable_interrupts();
    abba:	32 d2       	eint			
    abbc:	03 43       	nop			

0000abbe <.L87>:
    }
  }
  
  return result;
}
    abbe:	0c 4a       	mov	r10,	r12	;
    abc0:	28 17       	popm	#3,	r10	;16-bit words
    abc2:	30 41       	ret			

0000abc4 <.L89>:
  _disable_interrupts();
    abc4:	32 c2       	dint			

0000abc6 <.Loc.348.2>:
  asm volatile("nop");
    abc6:	03 43       	nop			

0000abc8 <.LBE33>:
      chSysLock();
    abc8:	8c 12       	call	r12		;

0000abca <.LVL102>:
      result[6] = bank0p[RegMissionTimeMsb];
    abca:	da 49 76 00 	mov.b	118(r9),6(r10)	;0x00076
    abce:	06 00 

0000abd0 <.Loc.274.1>:
      result[7] = bank0p[RegMissionTimeHmb];
    abd0:	da 49 75 00 	mov.b	117(r9),7(r10)	;0x00075
    abd4:	07 00 

0000abd6 <.Loc.275.1>:
      result[8] = bank0p[RegMissionTimeLmb];
    abd6:	da 49 74 00 	mov.b	116(r9),8(r10)	;0x00074
    abda:	08 00 

0000abdc <.Loc.276.1>:
      result[9] = bank0p[RegMissionTimeLsb];
    abdc:	da 49 73 00 	mov.b	115(r9),9(r10)	;0x00073
    abe0:	09 00 
    abe2:	e9 3f       	jmp	$-44     	;abs 0xabb6

0000abe4 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {
    abe4:	ff 3f       	jmp	$+0      	;abs 0xabe4

0000abe6 <Vector2>:
    abe6:	ff 3f       	jmp	$+0      	;abs 0xabe6

0000abe8 <Vector3>:

  while (1) {
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {
    abe8:	ff 3f       	jmp	$+0      	;abs 0xabe8

0000abea <Vector4>:

  while (1) {
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {
    abea:	ff 3f       	jmp	$+0      	;abs 0xabea

0000abec <Vector5>:

  while (1) {
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {
    abec:	ff 3f       	jmp	$+0      	;abs 0xabec

0000abee <Vector6>:

  while (1) {
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {
    abee:	ff 3f       	jmp	$+0      	;abs 0xabee

0000abf0 <Vector7>:

  while (1) {
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {
    abf0:	ff 3f       	jmp	$+0      	;abs 0xabf0

0000abf2 <Vector8>:

  while (1) {
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {
    abf2:	ff 3f       	jmp	$+0      	;abs 0xabf2

0000abf4 <Vector9>:

  while (1) {
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {
    abf4:	ff 3f       	jmp	$+0      	;abs 0xabf4

0000abf6 <Vector10>:

  while (1) {
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {
    abf6:	ff 3f       	jmp	$+0      	;abs 0xabf6

0000abf8 <Vector11>:

  while (1) {
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {
    abf8:	ff 3f       	jmp	$+0      	;abs 0xabf8

0000abfa <Vector12>:

  while (1) {
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {
    abfa:	ff 3f       	jmp	$+0      	;abs 0xabfa

0000abfc <Vector13>:

  while (1) {
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {
    abfc:	ff 3f       	jmp	$+0      	;abs 0xabfc

0000abfe <Vector14>:

  while (1) {
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {
    abfe:	ff 3f       	jmp	$+0      	;abs 0xabfe

0000ac00 <Vector15>:

  while (1) {
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {
    ac00:	ff 3f       	jmp	$+0      	;abs 0xac00

0000ac02 <Vector16>:

  while (1) {
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {
    ac02:	ff 3f       	jmp	$+0      	;abs 0xac02

0000ac04 <Vector17>:

  while (1) {
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {
    ac04:	ff 3f       	jmp	$+0      	;abs 0xac04

0000ac06 <Vector18>:

  while (1) {
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {
    ac06:	ff 3f       	jmp	$+0      	;abs 0xac06

0000ac08 <Vector19>:

  while (1) {
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {
    ac08:	ff 3f       	jmp	$+0      	;abs 0xac08

0000ac0a <Vector20>:

  while (1) {
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {
    ac0a:	ff 3f       	jmp	$+0      	;abs 0xac0a

0000ac0c <Vector21>:

  while (1) {
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {
    ac0c:	ff 3f       	jmp	$+0      	;abs 0xac0c

0000ac0e <Vector22>:

  while (1) {
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {
    ac0e:	ff 3f       	jmp	$+0      	;abs 0xac0e

0000ac10 <Vector23>:

  while (1) {
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {
    ac10:	ff 3f       	jmp	$+0      	;abs 0xac10

0000ac12 <Vector24>:

  while (1) {
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {
    ac12:	ff 3f       	jmp	$+0      	;abs 0xac12

0000ac14 <Vector25>:

  while (1) {
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {
    ac14:	ff 3f       	jmp	$+0      	;abs 0xac14

0000ac16 <Vector26>:

  while (1) {
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {
    ac16:	ff 3f       	jmp	$+0      	;abs 0xac16

0000ac18 <Vector27>:

  while (1) {
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {
    ac18:	ff 3f       	jmp	$+0      	;abs 0xac18

0000ac1a <Vector28>:

  while (1) {
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {
    ac1a:	ff 3f       	jmp	$+0      	;abs 0xac1a

0000ac1c <Vector29>:

  while (1) {
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {
    ac1c:	ff 3f       	jmp	$+0      	;abs 0xac1c

0000ac1e <Vector30>:

  while (1) {
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {
    ac1e:	ff 3f       	jmp	$+0      	;abs 0xac1e

0000ac20 <Vector31>:

  while (1) {
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {
    ac20:	ff 3f       	jmp	$+0      	;abs 0xac20

0000ac22 <Vector32>:

  while (1) {
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {
    ac22:	ff 3f       	jmp	$+0      	;abs 0xac22

0000ac24 <Vector35>:

  while (1) {
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {
    ac24:	ff 3f       	jmp	$+0      	;abs 0xac24

0000ac26 <Vector36>:

  while (1) {
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {
    ac26:	ff 3f       	jmp	$+0      	;abs 0xac26

0000ac28 <Vector38>:

  while (1) {
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {
    ac28:	ff 3f       	jmp	$+0      	;abs 0xac28

0000ac2a <Vector39>:

  while (1) {
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {
    ac2a:	ff 3f       	jmp	$+0      	;abs 0xac2a

0000ac2c <Vector42>:

  while (1) {
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {
    ac2c:	ff 3f       	jmp	$+0      	;abs 0xac2c

0000ac2e <Vector45>:

  while (1) {
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {
    ac2e:	ff 3f       	jmp	$+0      	;abs 0xac2e

0000ac30 <Vector46>:

  while (1) {
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {
    ac30:	ff 3f       	jmp	$+0      	;abs 0xac30

0000ac32 <Vector47>:

  while (1) {
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {
    ac32:	ff 3f       	jmp	$+0      	;abs 0xac32

0000ac34 <Vector48>:

  while (1) {
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {
    ac34:	ff 3f       	jmp	$+0      	;abs 0xac34

0000ac36 <Vector50>:

  while (1) {
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {
    ac36:	ff 3f       	jmp	$+0      	;abs 0xac36

0000ac38 <Vector51>:

  while (1) {
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {
    ac38:	ff 3f       	jmp	$+0      	;abs 0xac38

0000ac3a <Vector53>:

  while (1) {
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {
    ac3a:	ff 3f       	jmp	$+0      	;abs 0xac3a

0000ac3c <Vector54>:

  while (1) {
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {
    ac3c:	ff 3f       	jmp	$+0      	;abs 0xac3c

0000ac3e <Vector55>:

  while (1) {
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {
    ac3e:	ff 3f       	jmp	$+0      	;abs 0xac3e

0000ac40 <Thread2>:

  while (1) {
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {
    ac40:	1a 15       	pushm	#2,	r10	;16-bit words

0000ac42 <L0>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 128);
THD_FUNCTION(Thread2, arg) {
    ac42:	21 83       	decd	r1		;

0000ac44 <.LCFI1>:
  (void)(arg);
  volatile uint8_t i = 0;
    ac44:	c1 43 01 00 	mov.b	#0,	1(r1)	;r3 As==00

0000ac48 <.Loc.181.1>:
  while (true) {
    i++;
    chThdSleepMilliseconds(100);
    ac48:	3a 40 7c 47 	mov	#18300,	r10	;#0x477c
    ac4c:	79 40 64 00 	mov.b	#100,	r9	;#0x0064

0000ac50 <.L2>:
    i++;
    ac50:	d1 53 01 00 	inc.b	1(r1)		;

0000ac54 <.Loc.181.1>:
    chThdSleepMilliseconds(100);
    ac54:	0c 49       	mov	r9,	r12	;
    ac56:	8a 12       	call	r10		;

0000ac58 <.LVL2>:
    ac58:	fb 3f       	jmp	$-8      	;abs 0xac50

0000ac5a <elyErrorSignal>:
    ac5a:	0d 4c       	mov	r12,	r13	;

0000ac5c <L0>:
  return (1 << (error & 0x3F));
    ac5c:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    ac60:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ac62 <.LVL4>:
    ac62:	b0 12 94 af 	call	#-20588	;#0xaf94

0000ac66 <.LBE26>:
  signalled_errors |= mask_from_error(error);
    ac66:	82 dc de ef 	bis	r12,	&0xefde	;

0000ac6a <.Loc.40.1>:
}
    ac6a:	30 41       	ret			

0000ac6c <elyErrorSetLogLvlS>:
}
    ac6c:	30 41       	ret			

0000ac6e <elyErrorSetRptLvlS>:
}
    ac6e:	30 41       	ret			

0000ac70 <elyEventSignal>:
  return (1 << (event & 0x3F));
    ac70:	0d 4c       	mov	r12,	r13	;
    ac72:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    ac76:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ac78 <.LVL9>:
    ac78:	b0 12 94 af 	call	#-20588	;#0xaf94
    ac7c:	0e 4c       	mov	r12,	r14	;
    ac7e:	0f 4c       	mov	r12,	r15	;
    ac80:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000ac84 <.LBE28>:
  signalled_events |= mask_from_event(event);
    ac84:	82 dc da ef 	bis	r12,	&0xefda	;
    ac88:	82 df dc ef 	bis	r15,	&0xefdc	;

0000ac8c <.Loc.61.1>:
}
    ac8c:	30 41       	ret			

0000ac8e <elyEventSubscribe>:
  return (1 << (event & 0x3F));
    ac8e:	0d 4c       	mov	r12,	r13	;

0000ac90 <.LVL12>:
    ac90:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    ac94:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ac96 <.LVL13>:
    ac96:	b0 12 94 af 	call	#-20588	;#0xaf94
    ac9a:	0e 4c       	mov	r12,	r14	;
    ac9c:	0f 4c       	mov	r12,	r15	;
    ac9e:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000aca2 <.LBE30>:
  reported_events |= mask_from_event(event);
    aca2:	82 dc 86 c8 	bis	r12,	&0xc886	;
    aca6:	82 df 88 c8 	bis	r15,	&0xc888	;

0000acaa <.Loc.66.1>:
}
    acaa:	30 41       	ret			

0000acac <elyEventUnsubscribe>:
  return (1 << (event & 0x3F));
    acac:	0d 4c       	mov	r12,	r13	;
    acae:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    acb2:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000acb4 <.LVL16>:
    acb4:	b0 12 94 af 	call	#-20588	;#0xaf94
    acb8:	0e 4c       	mov	r12,	r14	;
    acba:	0f 4c       	mov	r12,	r15	;
    acbc:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000acc0 <.LBE32>:
  reported_events &= ~mask_from_event(event);
    acc0:	82 cc 86 c8 	bic	r12,	&0xc886	;
    acc4:	82 cf 88 c8 	bic	r15,	&0xc888	;

0000acc8 <.Loc.70.1>:
}
    acc8:	30 41       	ret			

0000acca <elyEventLog>:
  return (1 << (event & 0x3F));
    acca:	0d 4c       	mov	r12,	r13	;
    accc:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    acd0:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000acd2 <.LVL19>:
    acd2:	b0 12 94 af 	call	#-20588	;#0xaf94
    acd6:	0e 4c       	mov	r12,	r14	;
    acd8:	0f 4c       	mov	r12,	r15	;
    acda:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000acde <.LBE34>:
  logged_events |= mask_from_event(event);
    acde:	82 dc 8a c8 	bis	r12,	&0xc88a	;
    ace2:	82 df 8c c8 	bis	r15,	&0xc88c	;

0000ace6 <.Loc.74.1>:
}
    ace6:	30 41       	ret			

0000ace8 <elyEventUnlog>:
  return (1 << (event & 0x3F));
    ace8:	0d 4c       	mov	r12,	r13	;
    acea:	7d f0 3f 00 	and.b	#63,	r13	;#0x003f
    acee:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000acf0 <.LVL22>:
    acf0:	b0 12 94 af 	call	#-20588	;#0xaf94
    acf4:	0e 4c       	mov	r12,	r14	;
    acf6:	0f 4c       	mov	r12,	r15	;
    acf8:	4e 18 0f 11 	rpt #15 { rrax.w	r15		;

0000acfc <.LBE36>:
  logged_events &= ~mask_from_event(event);
    acfc:	82 cc 8a c8 	bic	r12,	&0xc88a	;
    ad00:	82 cf 8c c8 	bic	r15,	&0xc88c	;

0000ad04 <.Loc.78.1>:
}
    ad04:	30 41       	ret			

0000ad06 <elyEventReset>:
  logged_events = 0;
    ad06:	82 43 8a c8 	mov	#0,	&0xc88a	;r3 As==00
    ad0a:	82 43 8c c8 	mov	#0,	&0xc88c	;r3 As==00

0000ad0e <.Loc.82.1>:
  signalled_events = 0;
    ad0e:	82 43 da ef 	mov	#0,	&0xefda	;r3 As==00
    ad12:	82 43 dc ef 	mov	#0,	&0xefdc	;r3 As==00

0000ad16 <.Loc.83.1>:
  reported_events = 0;
    ad16:	82 43 86 c8 	mov	#0,	&0xc886	;r3 As==00
    ad1a:	82 43 88 c8 	mov	#0,	&0xc888	;r3 As==00

0000ad1e <.Loc.84.1>:
  event_resets++;
    ad1e:	92 53 84 c8 	inc	&0xc884		;

0000ad22 <.Loc.85.1>:
}
    ad22:	30 41       	ret			

0000ad24 <elyChanSubscribe>:
void elyChanSubscribe(uint8_t * buffer, uint8_t length, uint32_t interval) {
    ad24:	3a 15       	pushm	#4,	r10	;16-bit words

0000ad26 <.LCFI2>:
    ad26:	15 15       	pushm	#2,	r5	;16-bit words

0000ad28 <.LCFI3>:
    ad28:	07 4c       	mov	r12,	r7	;
    ad2a:	45 4d       	mov.b	r13,	r5	;

0000ad2c <.LVL25>:
    ad2c:	18 42 d6 ef 	mov	&0xefd6,r8	;0xefd6
    ad30:	19 42 d8 ef 	mov	&0xefd8,r9	;0xefd8

0000ad34 <.LBB38>:
  for (int i = 0; i < length; i++) {
    ad34:	0a 4c       	mov	r12,	r10	;
    ad36:	4c 43       	clr.b	r12		;

0000ad38 <.LVL26>:
    ad38:	54 43       	mov.b	#1,	r4	;r3 As==01

0000ad3a <.L14>:
    ad3a:	0d 4a       	mov	r10,	r13	;
    ad3c:	0d 87       	sub	r7,	r13	;
    ad3e:	0d 95       	cmp	r5,	r13	;
    ad40:	09 38       	jl	$+20     	;abs 0xad54
    ad42:	0c 93       	cmp	#0,	r12	;r3 As==00
    ad44:	04 24       	jz	$+10     	;abs 0xad4e
    ad46:	82 48 d6 ef 	mov	r8,	&0xefd6	;
    ad4a:	82 49 d8 ef 	mov	r9,	&0xefd8	;

0000ad4e <.L13>:
}
    ad4e:	14 17       	popm	#2,	r5	;16-bit words
    ad50:	37 17       	popm	#4,	r10	;16-bit words
    ad52:	30 41       	ret			

0000ad54 <.L15>:
  return (1UL << (chan & 0x3F));
    ad54:	6e 4a       	mov.b	@r10,	r14	;
    ad56:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    ad5a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ad5c:	4d 43       	clr.b	r13		;
    ad5e:	0f 43       	clr	r15		;
    ad60:	b0 12 de af 	call	#-20514	;#0xafde

0000ad64 <.LBE39>:
    subscribed_channels |= mask_from_chan(buffer[i]);
    ad64:	08 dc       	bis	r12,	r8	;
    ad66:	09 dd       	bis	r13,	r9	;

0000ad68 <.LVL29>:
    ad68:	1a 53       	inc	r10		;

0000ad6a <.LVL30>:
    ad6a:	0c 44       	mov	r4,	r12	;
    ad6c:	e6 3f       	jmp	$-50     	;abs 0xad3a

0000ad6e <elyChanUnsubscribe>:
    ad6e:	3a 15       	pushm	#4,	r10	;16-bit words

0000ad70 <L0>:
void elyChanUnsubscribe(uint8_t * buffer, uint8_t length) {
    ad70:	15 15       	pushm	#2,	r5	;16-bit words

0000ad72 <.LCFI5>:
    ad72:	07 4c       	mov	r12,	r7	;
    ad74:	45 4d       	mov.b	r13,	r5	;

0000ad76 <.LVL32>:
    ad76:	18 42 d6 ef 	mov	&0xefd6,r8	;0xefd6
    ad7a:	19 42 d8 ef 	mov	&0xefd8,r9	;0xefd8

0000ad7e <.LBB42>:
  for (int i = 0; i < length; i++) {
    ad7e:	0a 4c       	mov	r12,	r10	;
    ad80:	4c 43       	clr.b	r12		;

0000ad82 <.LVL33>:
    ad82:	54 43       	mov.b	#1,	r4	;r3 As==01

0000ad84 <.L21>:
    ad84:	0d 4a       	mov	r10,	r13	;
    ad86:	0d 87       	sub	r7,	r13	;
    ad88:	0d 95       	cmp	r5,	r13	;
    ad8a:	09 38       	jl	$+20     	;abs 0xad9e
    ad8c:	0c 93       	cmp	#0,	r12	;r3 As==00
    ad8e:	04 24       	jz	$+10     	;abs 0xad98
    ad90:	82 48 d6 ef 	mov	r8,	&0xefd6	;
    ad94:	82 49 d8 ef 	mov	r9,	&0xefd8	;

0000ad98 <.L20>:
}
    ad98:	14 17       	popm	#2,	r5	;16-bit words
    ad9a:	37 17       	popm	#4,	r10	;16-bit words
    ad9c:	30 41       	ret			

0000ad9e <.L22>:
  return (1UL << (chan & 0x3F));
    ad9e:	6e 4a       	mov.b	@r10,	r14	;
    ada0:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    ada4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ada6:	4d 43       	clr.b	r13		;
    ada8:	0f 43       	clr	r15		;
    adaa:	b0 12 de af 	call	#-20514	;#0xafde

0000adae <.LBE43>:
    subscribed_channels &= ~mask_from_chan(buffer[i]);
    adae:	08 cc       	bic	r12,	r8	;
    adb0:	09 cd       	bic	r13,	r9	;

0000adb2 <.LVL36>:
    adb2:	1a 53       	inc	r10		;

0000adb4 <.LVL37>:
    adb4:	0c 44       	mov	r4,	r12	;
    adb6:	e6 3f       	jmp	$-50     	;abs 0xad84

0000adb8 <elyChanLog>:
    adb8:	3a 15       	pushm	#4,	r10	;16-bit words

0000adba <L0>:
void elyChanLog(uint8_t * buffer, uint8_t length, uint32_t interval) {
    adba:	15 15       	pushm	#2,	r5	;16-bit words

0000adbc <.LCFI7>:
    adbc:	07 4c       	mov	r12,	r7	;
    adbe:	45 4d       	mov.b	r13,	r5	;

0000adc0 <.LVL39>:
    adc0:	18 42 d2 ef 	mov	&0xefd2,r8	;0xefd2
    adc4:	19 42 d4 ef 	mov	&0xefd4,r9	;0xefd4

0000adc8 <.LBB46>:
  for (int i = 0; i < length; i++) {
    adc8:	0a 4c       	mov	r12,	r10	;
    adca:	4c 43       	clr.b	r12		;

0000adcc <.LVL40>:
    adcc:	54 43       	mov.b	#1,	r4	;r3 As==01

0000adce <.L28>:
    adce:	0d 4a       	mov	r10,	r13	;
    add0:	0d 87       	sub	r7,	r13	;
    add2:	0d 95       	cmp	r5,	r13	;
    add4:	09 38       	jl	$+20     	;abs 0xade8
    add6:	0c 93       	cmp	#0,	r12	;r3 As==00
    add8:	04 24       	jz	$+10     	;abs 0xade2
    adda:	82 48 d2 ef 	mov	r8,	&0xefd2	;
    adde:	82 49 d4 ef 	mov	r9,	&0xefd4	;

0000ade2 <.L27>:
}
    ade2:	14 17       	popm	#2,	r5	;16-bit words
    ade4:	37 17       	popm	#4,	r10	;16-bit words
    ade6:	30 41       	ret			

0000ade8 <.L29>:
  return (1UL << (chan & 0x3F));
    ade8:	6e 4a       	mov.b	@r10,	r14	;
    adea:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    adee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    adf0:	4d 43       	clr.b	r13		;
    adf2:	0f 43       	clr	r15		;
    adf4:	b0 12 de af 	call	#-20514	;#0xafde

0000adf8 <.LBE47>:
    logged_channels |= mask_from_chan(buffer[i]);
    adf8:	08 dc       	bis	r12,	r8	;
    adfa:	09 dd       	bis	r13,	r9	;

0000adfc <.LVL43>:
    adfc:	1a 53       	inc	r10		;

0000adfe <.LVL44>:
    adfe:	0c 44       	mov	r4,	r12	;
    ae00:	e6 3f       	jmp	$-50     	;abs 0xadce

0000ae02 <elyChanUnlog>:
    ae02:	3a 15       	pushm	#4,	r10	;16-bit words

0000ae04 <L0>:
void elyChanUnlog(uint8_t * buffer, uint8_t length) {
    ae04:	15 15       	pushm	#2,	r5	;16-bit words

0000ae06 <.LCFI9>:
    ae06:	07 4c       	mov	r12,	r7	;
    ae08:	45 4d       	mov.b	r13,	r5	;

0000ae0a <.LVL46>:
    ae0a:	18 42 d2 ef 	mov	&0xefd2,r8	;0xefd2
    ae0e:	19 42 d4 ef 	mov	&0xefd4,r9	;0xefd4

0000ae12 <.LBB50>:
  for (int i = 0; i < length; i++) {
    ae12:	0a 4c       	mov	r12,	r10	;
    ae14:	4c 43       	clr.b	r12		;

0000ae16 <.LVL47>:
    ae16:	54 43       	mov.b	#1,	r4	;r3 As==01

0000ae18 <.L35>:
    ae18:	0d 4a       	mov	r10,	r13	;
    ae1a:	0d 87       	sub	r7,	r13	;
    ae1c:	0d 95       	cmp	r5,	r13	;
    ae1e:	09 38       	jl	$+20     	;abs 0xae32
    ae20:	0c 93       	cmp	#0,	r12	;r3 As==00
    ae22:	04 24       	jz	$+10     	;abs 0xae2c
    ae24:	82 48 d2 ef 	mov	r8,	&0xefd2	;
    ae28:	82 49 d4 ef 	mov	r9,	&0xefd4	;

0000ae2c <.L34>:
}
    ae2c:	14 17       	popm	#2,	r5	;16-bit words
    ae2e:	37 17       	popm	#4,	r10	;16-bit words
    ae30:	30 41       	ret			

0000ae32 <.L36>:
  return (1UL << (chan & 0x3F));
    ae32:	6e 4a       	mov.b	@r10,	r14	;
    ae34:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    ae38:	5c 43       	mov.b	#1,	r12	;r3 As==01
    ae3a:	4d 43       	clr.b	r13		;
    ae3c:	0f 43       	clr	r15		;
    ae3e:	b0 12 de af 	call	#-20514	;#0xafde

0000ae42 <.LBE51>:
    logged_channels &= ~mask_from_chan(buffer[i]);
    ae42:	08 cc       	bic	r12,	r8	;
    ae44:	09 cd       	bic	r13,	r9	;

0000ae46 <.LVL50>:
    ae46:	1a 53       	inc	r10		;

0000ae48 <.LVL51>:
    ae48:	0c 44       	mov	r4,	r12	;
    ae4a:	e6 3f       	jmp	$-50     	;abs 0xae18

0000ae4c <elyChanGetValue>:
    ae4c:	cc 43       	mov.b	#0		;r3 As==00, Warning: disassembly unreliable - not enough bytes available

0000ae4e <L0>:
  buffer[1] = 0;
    ae4e:	01 00       	mova	@r0,	r1	;

0000ae50 <.Loc.124.1>:
}
    ae50:	5c 43       	mov.b	#1,	r12	;r3 As==01

0000ae52 <.LVL53>:
    ae52:	30 41       	ret			

0000ae54 <elyChanReset>:
  logged_channels = 0;
    ae54:	82 43 d2 ef 	mov	#0,	&0xefd2	;r3 As==00
    ae58:	82 43 d4 ef 	mov	#0,	&0xefd4	;r3 As==00

0000ae5c <.Loc.128.1>:
  subscribed_channels = 0;
    ae5c:	82 43 d6 ef 	mov	#0,	&0xefd6	;r3 As==00
    ae60:	82 43 d8 ef 	mov	#0,	&0xefd8	;r3 As==00

0000ae64 <.Loc.129.1>:
  chan_resets++;
    ae64:	92 53 d0 ef 	inc	&0xefd0		;

0000ae68 <.Loc.130.1>:
}
    ae68:	30 41       	ret			

0000ae6a <elyTelemPostBufferS>:
  cb(buffer);
    ae6a:	8e 12       	call	r14		;

0000ae6c <.LVL55>:
}
    ae6c:	30 41       	ret			

0000ae6e <elyTelemUpdateConfigS>:
  chDbgCheckClassS();
    ae6e:	b0 12 42 45 	call	#17730		;#0x4542

0000ae72 <.LVL56>:
}
    ae72:	30 41       	ret			

0000ae74 <elyFramGetRequest>:
  (*reqp) = &reqs[fram_idx];
    ae74:	5d 42 b2 ef 	mov.b	&0xefb2,r13	;0xefb2
    ae78:	0e 4d       	mov	r13,	r14	;
    ae7a:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    ae7e:	0e 8d       	sub	r13,	r14	;
    ae80:	0e 5e       	rla	r14		;
    ae82:	3e 50 b4 ef 	add	#-4172,	r14	;#0xefb4
    ae86:	8c 4e 00 00 	mov	r14,	0(r12)	;

0000ae8a <.Loc.153.1>:
  fram_idx = (fram_idx ? 0 : 1);
    ae8a:	3d 53       	add	#-1,	r13	;r3 As==11
    ae8c:	5d 03       	rrum	#1,	r13	;
    ae8e:	4d 18 0d 11 	rpt #14 { rrax.w	r13		;
    ae92:	c2 4d b2 ef 	mov.b	r13,	&0xefb2	;

0000ae96 <.Loc.155.1>:
}
    ae96:	4c 43       	clr.b	r12		;

0000ae98 <.LVL58>:
    ae98:	30 41       	ret			

0000ae9a <elyFramGetRequestTimeoutS>:
  (*reqp) = &reqs[fram_idx];
    ae9a:	5d 42 b2 ef 	mov.b	&0xefb2,r13	;0xefb2

0000ae9e <.LVL60>:
    ae9e:	0e 4d       	mov	r13,	r14	;
    aea0:	42 18 0e 5e 	rpt #3 { rlax.w	r14		;
    aea4:	0e 8d       	sub	r13,	r14	;
    aea6:	0e 5e       	rla	r14		;
    aea8:	3e 50 b4 ef 	add	#-4172,	r14	;#0xefb4
    aeac:	8c 4e 00 00 	mov	r14,	0(r12)	;

0000aeb0 <.Loc.160.1>:
  fram_idx = (fram_idx ? 0 : 1);
    aeb0:	3d 53       	add	#-1,	r13	;r3 As==11
    aeb2:	5d 03       	rrum	#1,	r13	;
    aeb4:	4d 18 0d 11 	rpt #14 { rrax.w	r13		;
    aeb8:	c2 4d b2 ef 	mov.b	r13,	&0xefb2	;

0000aebc <.Loc.162.1>:
}
    aebc:	4c 43       	clr.b	r12		;

0000aebe <.LVL61>:
    aebe:	30 41       	ret			

0000aec0 <elyFramPostRequest>:
  if (req->callback) {
    aec0:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    aec4:	0d 93       	cmp	#0,	r13	;r3 As==00
    aec6:	03 24       	jz	$+8      	;abs 0xaece

0000aec8 <.Loc.167.1>:
    req->callback(req->buffer);
    aec8:	1c 4c 08 00 	mov	8(r12),	r12	;

0000aecc <.LVL63>:
    aecc:	8d 12       	call	r13		;

0000aece <.L48>:
}
    aece:	4c 43       	clr.b	r12		;
    aed0:	30 41       	ret			

0000aed2 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    aed2:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    aed6:	5c 01 

0000aed8 <.Loc.211.1>:

  halInit();
    aed8:	b0 12 50 4b 	call	#19280		;#0x4b50

0000aedc <.LVL65>:
  chSysInit();
    aedc:	b0 12 5e 45 	call	#17758		;#0x455e

0000aee0 <.L53>:
    aee0:	ff 3f       	jmp	$+0      	;abs 0xaee0

0000aee2 <udivmodsi4>:
    aee2:	5a 15       	pushm	#6,	r10	;16-bit words

0000aee4 <L0>:
UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);
UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);

UINT_TYPE
C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)
{
    aee4:	0a 4c       	mov	r12,	r10	;
    aee6:	0b 4d       	mov	r13,	r11	;

0000aee8 <.LVL1>:
  UINT_TYPE bit = 1;
  UINT_TYPE res = 0;

  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    aee8:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

0000aeec <.Loc.35.1>:
  UINT_TYPE bit = 1;
    aeec:	58 43       	mov.b	#1,	r8	;r3 As==01
    aeee:	49 43       	clr.b	r9		;

0000aef0 <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    aef0:	07 4b       	mov	r11,	r7	;

0000aef2 <.L2>:
    aef2:	0f 9b       	cmp	r11,	r15	;
    aef4:	11 28       	jnc	$+36     	;abs 0xaf18
    aef6:	07 9f       	cmp	r15,	r7	;
    aef8:	02 20       	jnz	$+6      	;abs 0xaefe
    aefa:	0e 9a       	cmp	r10,	r14	;
    aefc:	0d 28       	jnc	$+28     	;abs 0xaf18

0000aefe <.L20>:
    aefe:	4c 43       	clr.b	r12		;

0000af00 <.LVL3>:
    af00:	0d 4c       	mov	r12,	r13	;

0000af02 <.L5>:
    {
      den <<= 1;
      bit <<= 1;
    }
  while (bit)
    af02:	07 48       	mov	r8,	r7	;
    af04:	07 d9       	bis	r9,	r7	;
    af06:	07 93       	cmp	#0,	r7	;r3 As==00
    af08:	19 20       	jnz	$+52     	;abs 0xaf3c

0000af0a <.L6>:
	  res |= bit;
	}
      bit >>= 1;
      den >>= 1;
    }
  if (modwanted)
    af0a:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    af0e:	02 24       	jz	$+6      	;abs 0xaf14
    af10:	0c 4a       	mov	r10,	r12	;
    af12:	0d 4b       	mov	r11,	r13	;

0000af14 <.L1>:
    return num;
  return res;
}
    af14:	55 17       	popm	#6,	r10	;16-bit words
    af16:	30 41       	ret			

0000af18 <.L3>:
    af18:	3d 53       	add	#-1,	r13	;r3 As==11

0000af1a <.Loc.38.1>:
  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))
    af1a:	0d 93       	cmp	#0,	r13	;r3 As==00
    af1c:	20 24       	jz	$+66     	;abs 0xaf5e

0000af1e <.Loc.38.1>:
    af1e:	0f 93       	cmp	#0,	r15	;r3 As==00
    af20:	ee 3b       	jl	$-34     	;abs 0xaefe

0000af22 <.Loc.40.1>:
      den <<= 1;
    af22:	05 4e       	mov	r14,	r5	;
    af24:	06 4f       	mov	r15,	r6	;
    af26:	05 5e       	add	r14,	r5	;
    af28:	06 6f       	addc	r15,	r6	;
    af2a:	0e 45       	mov	r5,	r14	;

0000af2c <.LVL7>:
    af2c:	0f 46       	mov	r6,	r15	;

0000af2e <.LVL8>:
      bit <<= 1;
    af2e:	05 48       	mov	r8,	r5	;
    af30:	06 49       	mov	r9,	r6	;
    af32:	05 58       	add	r8,	r5	;
    af34:	06 69       	addc	r9,	r6	;
    af36:	08 45       	mov	r5,	r8	;

0000af38 <.LVL9>:
    af38:	09 46       	mov	r6,	r9	;

0000af3a <.LVL10>:
    af3a:	db 3f       	jmp	$-72     	;abs 0xaef2

0000af3c <.L12>:
      if (num >= den)
    af3c:	0b 9f       	cmp	r15,	r11	;
    af3e:	08 28       	jnc	$+18     	;abs 0xaf50
    af40:	0f 9b       	cmp	r11,	r15	;
    af42:	02 20       	jnz	$+6      	;abs 0xaf48
    af44:	0a 9e       	cmp	r14,	r10	;
    af46:	04 28       	jnc	$+10     	;abs 0xaf50

0000af48 <.L16>:
	  num -= den;
    af48:	0a 8e       	sub	r14,	r10	;
    af4a:	0b 7f       	subc	r15,	r11	;

0000af4c <.Loc.48.1>:
	  res |= bit;
    af4c:	0c d8       	bis	r8,	r12	;

0000af4e <.LVL13>:
    af4e:	0d d9       	bis	r9,	r13	;

0000af50 <.L10>:
      bit >>= 1;
    af50:	12 c3       	clrc			
    af52:	09 10       	rrc	r9		;
    af54:	08 10       	rrc	r8		;

0000af56 <.Loc.51.1>:
      den >>= 1;
    af56:	12 c3       	clrc			
    af58:	0f 10       	rrc	r15		;
    af5a:	0e 10       	rrc	r14		;
    af5c:	d2 3f       	jmp	$-90     	;abs 0xaf02

0000af5e <.L14>:
    af5e:	0c 4d       	mov	r13,	r12	;

0000af60 <.LVL18>:
    af60:	d4 3f       	jmp	$-86     	;abs 0xaf0a

0000af62 <__mspabi_divlu>:
    af62:	21 83       	decd	r1		;

0000af64 <.LCFI5>:
    af64:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

0000af68 <L0>:
}

UINT_TYPE
C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)
{
  return C3(udivmod,NAME_MODE,4) (a, b, 0);
    af68:	b0 12 e2 ae 	call	#-20766	;#0xaee2

0000af6c <.LVL46>:
}
    af6c:	21 53       	incd	r1		;
    af6e:	30 41       	ret			

0000af70 <__mspabi_slli_15>:
    af70:	0c 5c       	rla	r12		;

0000af72 <__mspabi_slli_14>:
    af72:	0c 5c       	rla	r12		;

0000af74 <__mspabi_slli_13>:
    af74:	0c 5c       	rla	r12		;

0000af76 <__mspabi_slli_12>:
    af76:	0c 5c       	rla	r12		;

0000af78 <__mspabi_slli_11>:
    af78:	0c 5c       	rla	r12		;

0000af7a <__mspabi_slli_10>:
    af7a:	0c 5c       	rla	r12		;

0000af7c <__mspabi_slli_9>:
    af7c:	0c 5c       	rla	r12		;

0000af7e <__mspabi_slli_8>:
    af7e:	0c 5c       	rla	r12		;

0000af80 <__mspabi_slli_7>:
    af80:	0c 5c       	rla	r12		;

0000af82 <__mspabi_slli_6>:
    af82:	0c 5c       	rla	r12		;

0000af84 <__mspabi_slli_5>:
    af84:	0c 5c       	rla	r12		;

0000af86 <__mspabi_slli_4>:
    af86:	0c 5c       	rla	r12		;

0000af88 <__mspabi_slli_3>:
    af88:	0c 5c       	rla	r12		;

0000af8a <__mspabi_slli_2>:
    af8a:	0c 5c       	rla	r12		;

0000af8c <__mspabi_slli_1>:
    af8c:	0c 5c       	rla	r12		;
    af8e:	30 41       	ret			

0000af90 <.L11>:
    af90:	3d 53       	add	#-1,	r13	;r3 As==11
    af92:	0c 5c       	rla	r12		;

0000af94 <__mspabi_slli>:
    af94:	0d 93       	cmp	#0,	r13	;r3 As==00
    af96:	fc 23       	jnz	$-6      	;abs 0xaf90
    af98:	30 41       	ret			

0000af9a <__mspabi_slll_15>:
    af9a:	0c 5c       	rla	r12		;
    af9c:	0d 6d       	rlc	r13		;

0000af9e <__mspabi_slll_14>:
    af9e:	0c 5c       	rla	r12		;
    afa0:	0d 6d       	rlc	r13		;

0000afa2 <__mspabi_slll_13>:
    afa2:	0c 5c       	rla	r12		;
    afa4:	0d 6d       	rlc	r13		;

0000afa6 <__mspabi_slll_12>:
    afa6:	0c 5c       	rla	r12		;
    afa8:	0d 6d       	rlc	r13		;

0000afaa <__mspabi_slll_11>:
    afaa:	0c 5c       	rla	r12		;
    afac:	0d 6d       	rlc	r13		;

0000afae <__mspabi_slll_10>:
    afae:	0c 5c       	rla	r12		;
    afb0:	0d 6d       	rlc	r13		;

0000afb2 <__mspabi_slll_9>:
    afb2:	0c 5c       	rla	r12		;
    afb4:	0d 6d       	rlc	r13		;

0000afb6 <__mspabi_slll_8>:
    afb6:	0c 5c       	rla	r12		;
    afb8:	0d 6d       	rlc	r13		;

0000afba <__mspabi_slll_7>:
    afba:	0c 5c       	rla	r12		;
    afbc:	0d 6d       	rlc	r13		;

0000afbe <__mspabi_slll_6>:
    afbe:	0c 5c       	rla	r12		;
    afc0:	0d 6d       	rlc	r13		;

0000afc2 <__mspabi_slll_5>:
    afc2:	0c 5c       	rla	r12		;
    afc4:	0d 6d       	rlc	r13		;

0000afc6 <__mspabi_slll_4>:
    afc6:	0c 5c       	rla	r12		;
    afc8:	0d 6d       	rlc	r13		;

0000afca <__mspabi_slll_3>:
    afca:	0c 5c       	rla	r12		;
    afcc:	0d 6d       	rlc	r13		;

0000afce <__mspabi_slll_2>:
    afce:	0c 5c       	rla	r12		;
    afd0:	0d 6d       	rlc	r13		;

0000afd2 <__mspabi_slll_1>:
    afd2:	0c 5c       	rla	r12		;
    afd4:	0d 6d       	rlc	r13		;
    afd6:	30 41       	ret			

0000afd8 <.L12>:
    afd8:	3e 53       	add	#-1,	r14	;r3 As==11
    afda:	0c 5c       	rla	r12		;
    afdc:	0d 6d       	rlc	r13		;

0000afde <__mspabi_slll>:
    afde:	0e 93       	cmp	#0,	r14	;r3 As==00
    afe0:	fb 23       	jnz	$-8      	;abs 0xafd8
    afe2:	30 41       	ret			

0000afe4 <__mspabi_srli_15>:
    afe4:	12 c3       	clrc			
    afe6:	0c 10       	rrc	r12		;

0000afe8 <__mspabi_srli_14>:
    afe8:	12 c3       	clrc			
    afea:	0c 10       	rrc	r12		;

0000afec <__mspabi_srli_13>:
    afec:	12 c3       	clrc			
    afee:	0c 10       	rrc	r12		;

0000aff0 <__mspabi_srli_12>:
    aff0:	12 c3       	clrc			
    aff2:	0c 10       	rrc	r12		;

0000aff4 <__mspabi_srli_11>:
    aff4:	12 c3       	clrc			
    aff6:	0c 10       	rrc	r12		;

0000aff8 <__mspabi_srli_10>:
    aff8:	12 c3       	clrc			
    affa:	0c 10       	rrc	r12		;

0000affc <__mspabi_srli_9>:
    affc:	12 c3       	clrc			
    affe:	0c 10       	rrc	r12		;

0000b000 <__mspabi_srli_8>:
    b000:	12 c3       	clrc			
    b002:	0c 10       	rrc	r12		;

0000b004 <__mspabi_srli_7>:
    b004:	12 c3       	clrc			
    b006:	0c 10       	rrc	r12		;

0000b008 <__mspabi_srli_6>:
    b008:	12 c3       	clrc			
    b00a:	0c 10       	rrc	r12		;

0000b00c <__mspabi_srli_5>:
    b00c:	12 c3       	clrc			
    b00e:	0c 10       	rrc	r12		;

0000b010 <__mspabi_srli_4>:
    b010:	12 c3       	clrc			
    b012:	0c 10       	rrc	r12		;

0000b014 <__mspabi_srli_3>:
    b014:	12 c3       	clrc			
    b016:	0c 10       	rrc	r12		;

0000b018 <__mspabi_srli_2>:
    b018:	12 c3       	clrc			
    b01a:	0c 10       	rrc	r12		;

0000b01c <__mspabi_srli_1>:
    b01c:	12 c3       	clrc			
    b01e:	0c 10       	rrc	r12		;
    b020:	30 41       	ret			

0000b022 <.L11>:
    b022:	3d 53       	add	#-1,	r13	;r3 As==11
    b024:	12 c3       	clrc			
    b026:	0c 10       	rrc	r12		;

0000b028 <__mspabi_srli>:
    b028:	0d 93       	cmp	#0,	r13	;r3 As==00
    b02a:	fb 23       	jnz	$-8      	;abs 0xb022
    b02c:	30 41       	ret			

0000b02e <__mspabi_srll_15>:
    b02e:	12 c3       	clrc			
    b030:	0d 10       	rrc	r13		;
    b032:	0c 10       	rrc	r12		;

0000b034 <__mspabi_srll_14>:
    b034:	12 c3       	clrc			
    b036:	0d 10       	rrc	r13		;
    b038:	0c 10       	rrc	r12		;

0000b03a <__mspabi_srll_13>:
    b03a:	12 c3       	clrc			
    b03c:	0d 10       	rrc	r13		;
    b03e:	0c 10       	rrc	r12		;

0000b040 <__mspabi_srll_12>:
    b040:	12 c3       	clrc			
    b042:	0d 10       	rrc	r13		;
    b044:	0c 10       	rrc	r12		;

0000b046 <__mspabi_srll_11>:
    b046:	12 c3       	clrc			
    b048:	0d 10       	rrc	r13		;
    b04a:	0c 10       	rrc	r12		;

0000b04c <__mspabi_srll_10>:
    b04c:	12 c3       	clrc			
    b04e:	0d 10       	rrc	r13		;
    b050:	0c 10       	rrc	r12		;

0000b052 <__mspabi_srll_9>:
    b052:	12 c3       	clrc			
    b054:	0d 10       	rrc	r13		;
    b056:	0c 10       	rrc	r12		;

0000b058 <__mspabi_srll_8>:
    b058:	12 c3       	clrc			
    b05a:	0d 10       	rrc	r13		;
    b05c:	0c 10       	rrc	r12		;

0000b05e <__mspabi_srll_7>:
    b05e:	12 c3       	clrc			
    b060:	0d 10       	rrc	r13		;
    b062:	0c 10       	rrc	r12		;

0000b064 <__mspabi_srll_6>:
    b064:	12 c3       	clrc			
    b066:	0d 10       	rrc	r13		;
    b068:	0c 10       	rrc	r12		;

0000b06a <__mspabi_srll_5>:
    b06a:	12 c3       	clrc			
    b06c:	0d 10       	rrc	r13		;
    b06e:	0c 10       	rrc	r12		;

0000b070 <__mspabi_srll_4>:
    b070:	12 c3       	clrc			
    b072:	0d 10       	rrc	r13		;
    b074:	0c 10       	rrc	r12		;

0000b076 <__mspabi_srll_3>:
    b076:	12 c3       	clrc			
    b078:	0d 10       	rrc	r13		;
    b07a:	0c 10       	rrc	r12		;

0000b07c <__mspabi_srll_2>:
    b07c:	12 c3       	clrc			
    b07e:	0d 10       	rrc	r13		;
    b080:	0c 10       	rrc	r12		;

0000b082 <__mspabi_srll_1>:
    b082:	12 c3       	clrc			
    b084:	0d 10       	rrc	r13		;
    b086:	0c 10       	rrc	r12		;
    b088:	30 41       	ret			

0000b08a <.L12>:
    b08a:	3e 53       	add	#-1,	r14	;r3 As==11
    b08c:	12 c3       	clrc			
    b08e:	0d 10       	rrc	r13		;
    b090:	0c 10       	rrc	r12		;

0000b092 <__mspabi_srll>:
    b092:	0e 93       	cmp	#0,	r14	;r3 As==00
    b094:	fa 23       	jnz	$-10     	;abs 0xb08a
    b096:	30 41       	ret			

0000b098 <__cmpsi2>:
    b098:	0f 9d       	cmp	r13,	r15	;
    b09a:	05 24       	jz	$+12     	;abs 0xb0a6
    b09c:	02 34       	jge	$+6      	;abs 0xb0a2

0000b09e <.L_greater_than>:
    b09e:	2c 43       	mov	#2,	r12	;r3 As==10
    b0a0:	30 41       	ret			

0000b0a2 <.L_less_than>:
    b0a2:	0c 43       	clr	r12		;
    b0a4:	30 41       	ret			

0000b0a6 <.L_compare_low>:
    b0a6:	0e 9c       	cmp	r12,	r14	;
    b0a8:	fa 3b       	jl	$-10     	;abs 0xb09e
    b0aa:	fb 23       	jnz	$-8      	;abs 0xb0a2
    b0ac:	1c 43       	mov	#1,	r12	;r3 As==01
    b0ae:	30 41       	ret			

0000b0b0 <__ucmpsi2>:
    b0b0:	0d 93       	cmp	#0,	r13	;r3 As==00
    b0b2:	03 30       	jn	$+8      	;abs 0xb0ba
    b0b4:	0f 93       	cmp	#0,	r15	;r3 As==00
    b0b6:	f5 33       	jn	$-20     	;abs 0xb0a2
    b0b8:	ef 2f       	jc	$-32     	;abs 0xb098

0000b0ba <.L_top_bit_set_in_A>:
    b0ba:	0f 93       	cmp	#0,	r15	;r3 As==00
    b0bc:	ed 33       	jn	$-36     	;abs 0xb098
    b0be:	ef 2f       	jc	$-32     	;abs 0xb09e

0000b0c0 <__mspabi_mpyi>:
    b0c0:	02 12       	push	r2		;
    b0c2:	32 c2       	dint			
    b0c4:	03 43       	nop			
    b0c6:	82 4c c0 04 	mov	r12,	&0x04c0	;
    b0ca:	82 4d c8 04 	mov	r13,	&0x04c8	;
    b0ce:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    b0d2:	00 13       	reti			

0000b0d4 <__mspabi_mpyl>:
    b0d4:	02 12       	push	r2		;
    b0d6:	32 c2       	dint			
    b0d8:	03 43       	nop			
    b0da:	82 4c d0 04 	mov	r12,	&0x04d0	;
    b0de:	82 4d d2 04 	mov	r13,	&0x04d2	;
    b0e2:	82 4e e0 04 	mov	r14,	&0x04e0	;
    b0e6:	82 4f e2 04 	mov	r15,	&0x04e2	;
    b0ea:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    b0ee:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    b0f2:	00 13       	reti			

0000b0f4 <memcpy>:
    b0f4:	0f 4c       	mov	r12,	r15	;
    b0f6:	0e 5c       	add	r12,	r14	;

0000b0f8 <.L2>:
    b0f8:	0f 9e       	cmp	r14,	r15	;
    b0fa:	05 24       	jz	$+12     	;abs 0xb106

0000b0fc <.LVL3>:
    b0fc:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;
    b100:	1f 53       	inc	r15		;

0000b102 <.LVL4>:
    b102:	1d 53       	inc	r13		;
    b104:	f9 3f       	jmp	$-12     	;abs 0xb0f8

0000b106 <.L5>:
    b106:	30 41       	ret			

0000b108 <memmove>:
    b108:	0b 4c       	mov	r12,	r11	;

0000b10a <L0>:
    b10a:	0b 5e       	add	r14,	r11	;

0000b10c <.Loc.69.1>:
    b10c:	0d 9c       	cmp	r12,	r13	;
    b10e:	02 28       	jnc	$+6      	;abs 0xb114

0000b110 <.L4>:
    b110:	0e 4c       	mov	r12,	r14	;

0000b112 <.LVL2>:
    b112:	0f 3c       	jmp	$+32     	;abs 0xb132

0000b114 <.L2>:
    b114:	0f 4d       	mov	r13,	r15	;
    b116:	0f 5e       	add	r14,	r15	;
    b118:	0c 9f       	cmp	r15,	r12	;
    b11a:	fa 2f       	jc	$-10     	;abs 0xb110

0000b11c <.LVL4>:
    b11c:	0d 4f       	mov	r15,	r13	;

0000b11e <.LVL5>:
    b11e:	0e 8f       	sub	r15,	r14	;

0000b120 <.L5>:
    b120:	0f 4d       	mov	r13,	r15	;
    b122:	0f 5e       	add	r14,	r15	;
    b124:	0f 93       	cmp	#0,	r15	;r3 As==00
    b126:	0c 24       	jz	$+26     	;abs 0xb140

0000b128 <.Loc.76.1>:
    b128:	3b 53       	add	#-1,	r11	;r3 As==11
    b12a:	3d 53       	add	#-1,	r13	;r3 As==11

0000b12c <.LVL8>:
    b12c:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    b130:	f7 3f       	jmp	$-16     	;abs 0xb120

0000b132 <.L3>:
    b132:	0b 9e       	cmp	r14,	r11	;
    b134:	05 24       	jz	$+12     	;abs 0xb140

0000b136 <.LVL10>:
    b136:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    b13a:	1e 53       	inc	r14		;

0000b13c <.LVL11>:
    b13c:	1d 53       	inc	r13		;
    b13e:	f9 3f       	jmp	$-12     	;abs 0xb132

0000b140 <.L9>:
    b140:	30 41       	ret			

0000b142 <memset>:
    b142:	0f 4c       	mov	r12,	r15	;
    b144:	0e 5c       	add	r12,	r14	;

0000b146 <.L2>:
    b146:	0f 9e       	cmp	r14,	r15	;

0000b148 <L0>:
    b148:	04 24       	jz	$+10     	;abs 0xb152

0000b14a <.LVL3>:
    b14a:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    b14e:	1f 53       	inc	r15		;

0000b150 <.LVL4>:
    b150:	fa 3f       	jmp	$-10     	;abs 0xb146

0000b152 <.L5>:
    b152:	30 41       	ret			
