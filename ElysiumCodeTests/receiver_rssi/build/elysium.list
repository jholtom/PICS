
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	90 90 5d 01 	Address 0x000000000000ff92 is out of bounds.
Address 0x000000000000ff94 is out of bounds.
cmp	0xffff,	0xffff	;PC rel. 0xff91, PC rel. 0xff93
    ff94:	1f 7f 

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	92 90 5d 01 	Address 0x000000000000ff94 is out of bounds.
Address 0x000000000000ff96 is out of bounds.
cmp	0xffff,	&0xffff	;PC rel. 0xff93
    ff96:	1f 7f 

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	94 90 00 00 	Address 0x000000000000ff96 is out of bounds.
Address 0x000000000000ff98 is out of bounds.
cmp	0xffff,	-1(r4)	;PC rel. 0xff95, 0xffff
    ff98:	00 00 

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	96 90 00 00 	Address 0x000000000000ff98 is out of bounds.
Address 0x000000000000ff9a is out of bounds.
cmp	0xffff,	-1(r6)	;PC rel. 0xff97, 0xffff
    ff9a:	00 00 

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	98 90 00 00 	Address 0x000000000000ff9a is out of bounds.
Address 0x000000000000ff9c is out of bounds.
cmp	0xffff,	-1(r8)	;PC rel. 0xff99, 0xffff
    ff9c:	00 00 

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	9a 90 00 00 	Address 0x000000000000ff9c is out of bounds.
Address 0x000000000000ff9e is out of bounds.
cmp	0xffff,	-1(r10)	;PC rel. 0xff9b, 0xffff
    ff9e:	00 00 

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	9c 90 00 00 	Address 0x000000000000ff9e is out of bounds.
Address 0x000000000000ffa0 is out of bounds.
cmp	0xffff,	-1(r12)	;PC rel. 0xff9d, 0xffff
    ffa0:	00 00 

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	9e 90 00 00 	Address 0x000000000000ffa0 is out of bounds.
Address 0x000000000000ffa2 is out of bounds.
cmp	0xffff,	-1(r14)	;PC rel. 0xff9f, 0xffff
    ffa2:	00 00 

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	a0 90 00 00 	Address 0x000000000000ffa2 is out of bounds.
cmp	@r0,	0xffff	; PC rel. 0xffa1

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	a2 90 00 00 	Address 0x000000000000ffa4 is out of bounds.
cmp	@r0,	&0xffff	;

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	a4 90 00 00 	Address 0x000000000000ffa6 is out of bounds.
cmp	@r0,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	a6 90 00 00 	Address 0x000000000000ffa8 is out of bounds.
cmp	@r0,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	a8 90 00 00 	Address 0x000000000000ffaa is out of bounds.
cmp	@r0,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	aa 90 00 00 	Address 0x000000000000ffac is out of bounds.
cmp	@r0,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	ac 90 00 00 	Address 0x000000000000ffae is out of bounds.
cmp	@r0,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	ae 90 00 00 	Address 0x000000000000ffb0 is out of bounds.
cmp	@r0,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	b0 90 00 00 	Address 0x000000000000ffb2 is out of bounds.
Address 0x000000000000ffb4 is out of bounds.
cmp	#65535,	0xffff	;#0xffff, PC rel. 0xffb3
    ffb4:	00 00 

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	b2 90 00 00 	Address 0x000000000000ffb4 is out of bounds.
Address 0x000000000000ffb6 is out of bounds.
cmp	#65535,	&0xffff	;#0xffff
    ffb6:	00 00 

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	b4 90 00 00 	Address 0x000000000000ffb6 is out of bounds.
Address 0x000000000000ffb8 is out of bounds.
cmp	#65535,	-1(r4)	;#0xffff, 0xffff
    ffb8:	00 00 

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	b6 90 00 00 	Address 0x000000000000ffb8 is out of bounds.
Address 0x000000000000ffba is out of bounds.
cmp	#65535,	-1(r6)	;#0xffff, 0xffff
    ffba:	00 00 

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	b8 90 00 00 	Address 0x000000000000ffba is out of bounds.
Address 0x000000000000ffbc is out of bounds.
cmp	#65535,	-1(r8)	;#0xffff, 0xffff
    ffbc:	00 00 

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	ba 90 00 00 	Address 0x000000000000ffbc is out of bounds.
Address 0x000000000000ffbe is out of bounds.
cmp	#65535,	-1(r10)	;#0xffff, 0xffff
    ffbe:	00 00 

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	bc 90 00 00 	Address 0x000000000000ffbe is out of bounds.
Address 0x000000000000ffc0 is out of bounds.
cmp	#65535,	-1(r12)	;#0xffff, 0xffff
    ffc0:	00 00 

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	be 90 00 00 	Address 0x000000000000ffc0 is out of bounds.
Address 0x000000000000ffc2 is out of bounds.
cmp	#65535,	-1(r14)	;#0xffff, 0xffff
    ffc2:	00 00 

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	c0 90 00 00 	Address 0x000000000000ffc2 is out of bounds.
cmp.b	r0,	0xffff	; PC rel. 0xffc1

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	c2 90 00 00 	Address 0x000000000000ffc4 is out of bounds.
cmp.b	r0,	&0xffff	;

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	c4 90 00 00 	Address 0x000000000000ffc6 is out of bounds.
cmp.b	r0,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	c6 90 00 00 	Address 0x000000000000ffc8 is out of bounds.
cmp.b	r0,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	c8 90 00 00 	Address 0x000000000000ffca is out of bounds.
cmp.b	r0,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	ca 90 00 00 	Address 0x000000000000ffcc is out of bounds.
cmp.b	r0,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	cc 90 00 00 	Address 0x000000000000ffce is out of bounds.
cmp.b	r0,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	ce 90 00 00 	Address 0x000000000000ffd0 is out of bounds.
cmp.b	r0,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	c0 77 00 00 	Address 0x000000000000ffd2 is out of bounds.
subc.b	r7,	0xffff	; PC rel. 0xffd1

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	6c 77       	subc.b	@r7,	r12	;

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	d0 90 00 00 	Address 0x000000000000ffd6 is out of bounds.
Address 0x000000000000ffd8 is out of bounds.
cmp.b	0xffff,	0xffff	;PC rel. 0xffd5, PC rel. 0xffd7
    ffd8:	00 00 

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	d2 90 00 00 	Address 0x000000000000ffd8 is out of bounds.
Address 0x000000000000ffda is out of bounds.
cmp.b	0xffff,	&0xffff	;PC rel. 0xffd7
    ffda:	00 00 

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	1a 77 00 00 	Address 0x000000000000ffda is out of bounds.
subc	-1(r7),	r10	;

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	d4 90 00 00 	Address 0x000000000000ffdc is out of bounds.
Address 0x000000000000ffde is out of bounds.
cmp.b	0xffff,	-1(r4)	;PC rel. 0xffdb, 0xffff
    ffde:	00 00 

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	d6 90 00 00 	Address 0x000000000000ffde is out of bounds.
Address 0x000000000000ffe0 is out of bounds.
cmp.b	0xffff,	-1(r6)	;PC rel. 0xffdd, 0xffff
    ffe0:	00 00 

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	ca 76 00 00 	Address 0x000000000000ffe0 is out of bounds.
subc.b	r6,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	d8 90       	interrupt service routine at 0x90d8

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	da 90       	interrupt service routine at 0x90da

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	e4 7d       	interrupt service routine at 0x7de4

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	dc 90       	interrupt service routine at 0x90dc

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	de 90       	interrupt service routine at 0x90de

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	e0 90       	interrupt service routine at 0x90e0

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	e2 90       	interrupt service routine at 0x90e2

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	e4 90       	interrupt service routine at 0x90e4

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	8c 75       	interrupt service routine at 0x758c

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	e6 90       	interrupt service routine at 0x90e6

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	e8 90       	interrupt service routine at 0x90e8

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	0c 71       	interrupt service routine at 0x710c

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	ea 90       	interrupt service routine at 0x90ea

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	ec 90       	interrupt service routine at 0x90ec

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	ee 90       	interrupt service routine at 0x90ee

Disassembly of section .text:

00006240 <__crt0_start>:
    6240:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00006244 <disable_watchdog>:
#include "sx1212.h"

/* Disable watchdog because of lousy startup code in newlib */
static void __attribute__((naked, section(".crt_0042disable_watchdog"), used))
disable_watchdog(void) {
  WDTCTL = WDTPW | WDTHOLD;
    6244:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6248:	5c 01 

0000624a <.Loc.27.1>:
}
    624a:	03 43       	nop			

0000624c <__crt0_init_bss>:
    624c:	3c 40 0c 51 	mov	#20748,	r12	;#0x510c

00006250 <.Loc.74.1>:
    6250:	0d 43       	clr	r13		;

00006252 <.Loc.75.1>:
    6252:	3e 40 34 11 	mov	#4404,	r14	;#0x1134

00006256 <.Loc.79.1>:
    6256:	b0 12 a2 93 	call	#37794		;#0x93a2

0000625a <__crt0_movedata>:
    625a:	3c 40 ce 50 	mov	#20686,	r12	;#0x50ce

0000625e <.Loc.116.1>:
    625e:	3d 40 ce 50 	mov	#20686,	r13	;#0x50ce

00006262 <.Loc.119.1>:
    6262:	0d 9c       	cmp	r12,	r13	;

00006264 <.Loc.120.1>:
    6264:	04 24       	jz	$+10     	;abs 0x626e

00006266 <.Loc.122.1>:
    6266:	3e 40 3e 00 	mov	#62,	r14	;#0x003e

0000626a <.Loc.124.1>:
    626a:	b0 12 68 93 	call	#37736		;#0x9368

0000626e <__crt0_call_just_main>:
    626e:	0c 43       	clr	r12		;

00006270 <.Loc.181.1>:
    6270:	b0 12 6e 91 	call	#37230		;#0x916e

00006274 <port_init>:

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
  __msp430x_in_isr = false;
    6274:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00

00006278 <.Loc.305.1>:
}
    6278:	03 43       	nop			
    627a:	30 41       	ret			

0000627c <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    627c:	32 c2       	dint			

0000627e <.Loc.348.1>:
  asm volatile("nop");
    627e:	03 43       	nop			

00006280 <.Loc.349.1>:
}
    6280:	03 43       	nop			
    6282:	30 41       	ret			

00006284 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6284:	03 43       	nop			

00006286 <.Loc.356.1>:
  _enable_interrupts();
    6286:	32 d2       	eint			
    6288:	03 43       	nop			

0000628a <.Loc.357.1>:
}
    628a:	03 43       	nop			
    628c:	30 41       	ret			

0000628e <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    628e:	03 43       	nop			
    6290:	30 41       	ret			

00006292 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6292:	03 43       	nop			
    6294:	30 41       	ret			

00006296 <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    6296:	32 c2       	dint			

00006298 <.Loc.381.1>:
  asm volatile("nop");
    6298:	03 43       	nop			

0000629a <.Loc.382.1>:
}
    629a:	03 43       	nop			
    629c:	30 41       	ret			

0000629e <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    629e:	32 c2       	dint			

000062a0 <.Loc.390.1>:
  asm volatile("nop");
    62a0:	03 43       	nop			

000062a2 <.Loc.391.1>:
}
    62a2:	03 43       	nop			
    62a4:	30 41       	ret			

000062a6 <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    62a6:	21 82       	sub	#4,	r1	;r2 As==10

000062a8 <.LCFI2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    62a8:	b1 40 14 51 	mov	#20756,	2(r1)	;#0x5114
    62ac:	02 00 

000062ae <.Loc.234.2>:
  tcp = nil_thd_configs;
    62ae:	b1 40 72 50 	mov	#20594,	0(r1)	;#0x5072
    62b2:	00 00 

000062b4 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    62b4:	2d 3c       	jmp	$+92     	;abs 0x6310

000062b6 <.L16>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    62b6:	2c 41       	mov	@r1,	r12	;
    62b8:	2d 4c       	mov	@r12,	r13	;
    62ba:	1c 41 02 00 	mov	2(r1),	r12	;
    62be:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000062c2 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    62c2:	2c 41       	mov	@r1,	r12	;
    62c4:	1c 4c 02 00 	mov	2(r12),	r12	;
    62c8:	0d 4c       	mov	r12,	r13	;
    62ca:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    62ce:	1c 41 02 00 	mov	2(r1),	r12	;
    62d2:	8c 4d 00 00 	mov	r13,	0(r12)	;
    62d6:	1c 41 02 00 	mov	2(r1),	r12	;
    62da:	2c 4c       	mov	@r12,	r12	;
    62dc:	2d 41       	mov	@r1,	r13	;
    62de:	1d 4d 06 00 	mov	6(r13),	r13	;
    62e2:	8c 4d 00 00 	mov	r13,	0(r12)	;
    62e6:	1c 41 02 00 	mov	2(r1),	r12	;
    62ea:	2c 4c       	mov	@r12,	r12	;
    62ec:	2d 41       	mov	@r1,	r13	;
    62ee:	1d 4d 08 00 	mov	8(r13),	r13	;
    62f2:	8c 4d 02 00 	mov	r13,	2(r12)	;
    62f6:	1c 41 02 00 	mov	2(r1),	r12	;
    62fa:	2c 4c       	mov	@r12,	r12	;
    62fc:	3d 40 6a 66 	mov	#26218,	r13	;#0x666a
    6300:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00006304 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    6304:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    6308:	02 00 

0000630a <.Loc.247.2>:
    tcp++;
    630a:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    630e:	00 00 

00006310 <.L15>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    6310:	b1 90 20 51 	cmp	#20768,	2(r1)	;#0x5120
    6314:	02 00 
    6316:	cf 2b       	jnc	$-96     	;abs 0x62b6

00006318 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    6318:	1c 41 02 00 	mov	2(r1),	r12	;
    631c:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    6320:	0a 00 

00006322 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    6322:	b0 12 9e 62 	call	#25246		;#0x629e

00006326 <.Loc.265.2>:
  nil.lock_cnt = (cnt_t)1;
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    6326:	b0 12 3c 66 	call	#26172		;#0x663c

0000632a <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    632a:	b0 12 74 62 	call	#25204		;#0x6274

0000632e <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    632e:	b2 40 14 51 	mov	#20756,	&0x510e	;#0x5114
    6332:	0e 51 
    6334:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    6338:	82 4c 0c 51 	mov	r12,	&0x510c	;

0000633c <.Loc.275.2>:
  port_switch(nil.current, tp);
    633c:	1c 42 0c 51 	mov	&0x510c,r12	;0x510c
    6340:	1d 41 02 00 	mov	2(r1),	r13	;
    6344:	b0 12 5c 66 	call	#26204		;#0x665c

00006348 <.Loc.276.2>:
  chSysUnlock();
    6348:	b0 12 84 62 	call	#25220		;#0x6284

0000634c <.Loc.277.2>:
}
    634c:	03 43       	nop			
    634e:	21 52       	add	#4,	r1	;r2 As==10
    6350:	30 41       	ret			

00006352 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    6352:	21 83       	decd	r1		;

00006354 <L0>:
    6354:	81 4c 00 00 	mov	r12,	0(r1)	;

00006358 <.Loc.293.2>:

  port_disable();
    6358:	b0 12 96 62 	call	#25238		;#0x6296

0000635c <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    635c:	a2 41 12 51 	mov	@r1,	&0x5112	;

00006360 <.L18>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    6360:	ff 3f       	jmp	$+0      	;abs 0x6360

00006362 <chSysTimerHandlerI>:
    6362:	21 83       	decd	r1		;

00006364 <L0>:
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    6364:	b1 40 14 51 	mov	#20756,	0(r1)	;#0x5114
    6368:	00 00 

0000636a <.Loc.321.2>:
  nil.systime++;
    636a:	1c 42 10 51 	mov	&0x5110,r12	;0x5110
    636e:	1c 53       	inc	r12		;
    6370:	82 4c 10 51 	mov	r12,	&0x5110	;

00006374 <.L23>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    6374:	2c 41       	mov	@r1,	r12	;
    6376:	1c 4c 06 00 	mov	6(r12),	r12	;
    637a:	0c 93       	cmp	#0,	r12	;r3 As==00
    637c:	25 24       	jz	$+76     	;abs 0x63c8

0000637e <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    637e:	2c 41       	mov	@r1,	r12	;
    6380:	1c 4c 06 00 	mov	6(r12),	r12	;
    6384:	3c 53       	add	#-1,	r12	;r3 As==11
    6386:	2d 41       	mov	@r1,	r13	;
    6388:	8d 4c 06 00 	mov	r12,	6(r13)	;
    638c:	0c 93       	cmp	#0,	r12	;r3 As==00
    638e:	1c 20       	jnz	$+58     	;abs 0x63c8

00006390 <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    6390:	2c 41       	mov	@r1,	r12	;
    6392:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    6396:	7c 90 03 00 	cmp.b	#3,	r12	;
    639a:	08 20       	jnz	$+18     	;abs 0x63ac

0000639c <.Loc.334.2>:
          tp->u1.semp->cnt++;
    639c:	2c 41       	mov	@r1,	r12	;
    639e:	1c 4c 04 00 	mov	4(r12),	r12	;
    63a2:	2d 4c       	mov	@r12,	r13	;
    63a4:	1d 53       	inc	r13		;
    63a6:	8c 4d 00 00 	mov	r13,	0(r12)	;
    63aa:	0a 3c       	jmp	$+22     	;abs 0x63c0

000063ac <.L21>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    63ac:	2c 41       	mov	@r1,	r12	;
    63ae:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    63b2:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    63b4:	05 20       	jnz	$+12     	;abs 0x63c0

000063b6 <.Loc.337.2>:
          *tp->u1.trp = NULL;
    63b6:	2c 41       	mov	@r1,	r12	;
    63b8:	1c 4c 04 00 	mov	4(r12),	r12	;
    63bc:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

000063c0 <.L22>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    63c0:	3d 43       	mov	#-1,	r13	;r3 As==11
    63c2:	2c 41       	mov	@r1,	r12	;
    63c4:	b0 12 e4 63 	call	#25572		;#0x63e4

000063c8 <.L20>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    63c8:	b0 12 92 62 	call	#25234		;#0x6292

000063cc <.Loc.346.2>:
    tp++;
    63cc:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    63d0:	00 00 

000063d2 <.Loc.347.2>:
    chSysLockFromISR();
    63d2:	b0 12 8e 62 	call	#25230		;#0x628e

000063d6 <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    63d6:	b1 90 20 51 	cmp	#20768,	0(r1)	;#0x5120
    63da:	00 00 
    63dc:	cb 2b       	jnc	$-104    	;abs 0x6374

000063de <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    63de:	03 43       	nop			
    63e0:	21 53       	incd	r1		;
    63e2:	30 41       	ret			

000063e4 <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    63e4:	21 82       	sub	#4,	r1	;r2 As==10

000063e6 <L0>:
    63e6:	81 4c 02 00 	mov	r12,	2(r1)	;
    63ea:	81 4d 00 00 	mov	r13,	0(r1)	;

000063ee <.Loc.540.2>:
  chDbgCheckClassI();
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    63ee:	1c 41 02 00 	mov	2(r1),	r12	;
    63f2:	ac 41 04 00 	mov	@r1,	4(r12)	;

000063f6 <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    63f6:	1c 41 02 00 	mov	2(r1),	r12	;
    63fa:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

000063fe <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    63fe:	1c 41 02 00 	mov	2(r1),	r12	;
    6402:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006406 <.Loc.543.2>:
  if (tp < nil.next) {
    6406:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    640a:	81 9c 02 00 	cmp	r12,	2(r1)	;
    640e:	03 2c       	jc	$+8      	;abs 0x6416

00006410 <.Loc.544.2>:
    nil.next = tp;
    6410:	92 41 02 00 	mov	2(r1),	&0x510e	;
    6414:	0e 51 

00006416 <.L39>:
  }
  return tp;
    6416:	1c 41 02 00 	mov	2(r1),	r12	;

0000641a <.Loc.547.2>:
}
    641a:	21 52       	add	#4,	r1	;r2 As==10
    641c:	30 41       	ret			

0000641e <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    641e:	1d 42 0c 51 	mov	&0x510c,r13	;0x510c
    6422:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    6426:	0c ed       	xor	r13,	r12	;
    6428:	0d 43       	clr	r13		;
    642a:	0d 8c       	sub	r12,	r13	;
    642c:	0c dd       	bis	r13,	r12	;
    642e:	5c 03       	rrum	#1,	r12	;
    6430:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    6434:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00006438 <.Loc.565.2>:
}
    6438:	30 41       	ret			

0000643a <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    643a:	21 83       	decd	r1		;

0000643c <.LCFI8>:
  thread_t *otp = nil.current;
    643c:	91 42 0c 51 	mov	&0x510c,0(r1)	;0x510c
    6440:	00 00 

00006442 <.Loc.577.2>:

  nil.current = nil.next;
    6442:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    6446:	82 4c 0c 51 	mov	r12,	&0x510c	;

0000644a <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    644a:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    644e:	2d 41       	mov	@r1,	r13	;
    6450:	b0 12 5c 66 	call	#26204		;#0x665c

00006454 <.Loc.582.2>:
}
    6454:	03 43       	nop			
    6456:	21 53       	incd	r1		;
    6458:	30 41       	ret			

0000645a <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    645a:	31 82       	sub	#8,	r1	;r2 As==11

0000645c <.LCFI9>:
    645c:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    6460:	81 4d 00 00 	mov	r13,	0(r1)	;

00006464 <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    6464:	91 42 0c 51 	mov	&0x510c,4(r1)	;0x510c
    6468:	04 00 

0000646a <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    646a:	1c 41 04 00 	mov	4(r1),	r12	;
    646e:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    6472:	02 00 

00006474 <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    6474:	1c 41 04 00 	mov	4(r1),	r12	;
    6478:	ac 41 06 00 	mov	@r1,	6(r12)	;

0000647c <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    647c:	b1 40 14 51 	mov	#20756,	6(r1)	;#0x5114
    6480:	06 00 

00006482 <.L50>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    6482:	1c 41 06 00 	mov	6(r1),	r12	;
    6486:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    648a:	0c 93       	cmp	#0,	r12	;r3 As==00
    648c:	12 20       	jnz	$+38     	;abs 0x64b2

0000648e <.Loc.667.2>:
      nil.current = nil.next = ntp;
    648e:	92 41 06 00 	mov	6(r1),	&0x510e	;
    6492:	0e 51 
    6494:	1c 42 0e 51 	mov	&0x510e,r12	;0x510e
    6498:	82 4c 0c 51 	mov	r12,	&0x510c	;

0000649c <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    649c:	1d 41 04 00 	mov	4(r1),	r13	;
    64a0:	1c 41 06 00 	mov	6(r1),	r12	;
    64a4:	b0 12 5c 66 	call	#26204		;#0x665c

000064a8 <.Loc.672.2>:
      return nil.current->u1.msg;
    64a8:	1c 42 0c 51 	mov	&0x510c,r12	;0x510c
    64ac:	1c 4c 04 00 	mov	4(r12),	r12	;
    64b0:	04 3c       	jmp	$+10     	;abs 0x64ba

000064b2 <.L48>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    64b2:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    64b6:	06 00 

000064b8 <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    64b8:	e4 3f       	jmp	$-54     	;abs 0x6482

000064ba <.L51>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    64ba:	31 52       	add	#8,	r1	;r2 As==11
    64bc:	30 41       	ret			

000064be <chThdSuspendTimeoutS>:
 *                      .
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    64be:	21 82       	sub	#4,	r1	;r2 As==10

000064c0 <.LCFI10>:
    64c0:	81 4c 02 00 	Address 0x00000000000064c2 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

000064c2 <L0>:
    64c2:	02 00       	mova	@r0,	r2	;
    64c4:	81 4d 00 00 	mov	r13,	0(r1)	;

000064c8 <.Loc.700.2>:

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    64c8:	1d 42 0c 51 	mov	&0x510c,r13	;0x510c
    64cc:	1c 41 02 00 	mov	2(r1),	r12	;
    64d0:	8c 4d 00 00 	mov	r13,	0(r12)	;

000064d4 <.Loc.701.2>:
  nil.current->u1.trp = trp;
    64d4:	1c 42 0c 51 	mov	&0x510c,r12	;0x510c
    64d8:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    64dc:	04 00 

000064de <.Loc.702.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    64de:	2d 41       	mov	@r1,	r13	;
    64e0:	6c 43       	mov.b	#2,	r12	;r3 As==10
    64e2:	b0 12 5a 64 	call	#25690		;#0x645a

000064e6 <.Loc.703.2>:
}
    64e6:	21 52       	add	#4,	r1	;r2 As==10
    64e8:	30 41       	ret			

000064ea <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    64ea:	31 80 06 00 	sub	#6,	r1	;

000064ee <.LCFI11>:
    64ee:	81 4c 02 00 	mov	r12,	2(r1)	;
    64f2:	81 4d 00 00 	mov	r13,	0(r1)	;

000064f6 <.Loc.717.2>:

  if (*trp != NULL) {
    64f6:	1c 41 02 00 	mov	2(r1),	r12	;
    64fa:	2c 4c       	mov	@r12,	r12	;
    64fc:	0c 93       	cmp	#0,	r12	;r3 As==00
    64fe:	0d 24       	jz	$+28     	;abs 0x651a

00006500 <.LBB3>:
    thread_reference_t tr = *trp;
    6500:	1c 41 02 00 	mov	2(r1),	r12	;
    6504:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006508 <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    6508:	1c 41 02 00 	mov	2(r1),	r12	;
    650c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006510 <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    6510:	2d 41       	mov	@r1,	r13	;
    6512:	1c 41 04 00 	mov	4(r1),	r12	;
    6516:	b0 12 e4 63 	call	#25572		;#0x63e4

0000651a <.L56>:
  }
}
    651a:	03 43       	nop			
    651c:	31 50 06 00 	add	#6,	r1	;
    6520:	30 41       	ret			

00006522 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    6522:	21 83       	decd	r1		;

00006524 <.LCFI12>:
    6524:	81 4c 00 00 	mov	r12,	0(r1)	;

00006528 <.Loc.736.2>:

  chSysLock();
    6528:	b0 12 7c 62 	call	#25212		;#0x627c

0000652c <.Loc.737.2>:
  chThdSleepS(timeout);
    652c:	2d 41       	mov	@r1,	r13	;
    652e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6530:	b0 12 5a 64 	call	#25690		;#0x645a

00006534 <.Loc.738.2>:
  chSysUnlock();
    6534:	b0 12 84 62 	call	#25220		;#0x6284

00006538 <.Loc.739.2>:
}
    6538:	03 43       	nop			
    653a:	21 53       	incd	r1		;
    653c:	30 41       	ret			

0000653e <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    653e:	31 80 06 00 	sub	#6,	r1	;

00006542 <.LCFI15>:
    6542:	81 4c 02 00 	mov	r12,	2(r1)	;
    6546:	81 4d 00 00 	mov	r13,	0(r1)	;

0000654a <.Loc.812.2>:
  chDbgCheckClassS();
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    654a:	1c 41 02 00 	mov	2(r1),	r12	;
    654e:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00006552 <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    6552:	4c 43       	clr.b	r12		;
    6554:	1c 91 04 00 	cmp	4(r1),	r12	;
    6558:	17 38       	jl	$+48     	;abs 0x6588

0000655a <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    655a:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    655e:	02 20       	jnz	$+6      	;abs 0x6564

00006560 <.Loc.815.2>:
      return MSG_TIMEOUT;
    6560:	3c 43       	mov	#-1,	r12	;r3 As==11
    6562:	1a 3c       	jmp	$+54     	;abs 0x6598

00006564 <.L63>:
    }
    sp->cnt = cnt - (cnt_t)1;
    6564:	1d 41 04 00 	mov	4(r1),	r13	;
    6568:	3d 53       	add	#-1,	r13	;r3 As==11
    656a:	1c 41 02 00 	mov	2(r1),	r12	;
    656e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006572 <.Loc.818.2>:
    nil.current->u1.semp = sp;
    6572:	1c 42 0c 51 	mov	&0x510c,r12	;0x510c
    6576:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    657a:	04 00 

0000657c <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    657c:	2d 41       	mov	@r1,	r13	;
    657e:	7c 40 03 00 	mov.b	#3,	r12	;
    6582:	b0 12 5a 64 	call	#25690		;#0x645a
    6586:	08 3c       	jmp	$+18     	;abs 0x6598

00006588 <.L62>:
  }
  sp->cnt = cnt - (cnt_t)1;
    6588:	1d 41 04 00 	mov	4(r1),	r13	;
    658c:	3d 53       	add	#-1,	r13	;r3 As==11
    658e:	1c 41 02 00 	mov	2(r1),	r12	;
    6592:	8c 4d 00 00 	mov	r13,	0(r12)	;

00006596 <.Loc.822.2>:
  return MSG_OK;
    6596:	4c 43       	clr.b	r12		;

00006598 <.L64>:
}
    6598:	31 50 06 00 	add	#6,	r1	;
    659c:	30 41       	ret			

0000659e <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    659e:	32 c2       	dint			

000065a0 <.Loc.348.1>:
  asm volatile("nop");
    65a0:	03 43       	nop			

000065a2 <L0>:
}
    65a2:	03 43       	nop			
    65a4:	30 41       	ret			

000065a6 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    65a6:	03 43       	nop			

000065a8 <.Loc.356.1>:
  _enable_interrupts();
    65a8:	32 d2       	eint			
    65aa:	03 43       	nop			

000065ac <.Loc.357.1>:
}
    65ac:	03 43       	nop			
    65ae:	30 41       	ret			

000065b0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    65b0:	31 80 06 00 	sub	#6,	r1	;

000065b4 <.LCFI0>:
    65b4:	81 4c 02 00 	mov	r12,	2(r1)	;
    65b8:	81 4d 00 00 	mov	r13,	0(r1)	;

000065bc <.Loc.114.2>:
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    65bc:	2c 41       	mov	@r1,	r12	;
    65be:	1c 51 02 00 	add	2(r1),	r12	;
    65c2:	0d 4c       	mov	r12,	r13	;
    65c4:	3d 53       	add	#-1,	r13	;r3 As==11
    65c6:	4c 43       	clr.b	r12		;
    65c8:	2c 81       	sub	@r1,	r12	;
    65ca:	0e 4d       	mov	r13,	r14	;
    65cc:	0e fc       	and	r12,	r14	;
    65ce:	81 4e 02 00 	mov	r14,	2(r1)	;

000065d2 <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    65d2:	1c 42 2c 51 	mov	&0x512c,r12	;0x512c
    65d6:	2c 51       	add	@r1,	r12	;
    65d8:	0d 4c       	mov	r12,	r13	;
    65da:	3d 53       	add	#-1,	r13	;r3 As==11
    65dc:	4c 43       	clr.b	r12		;
    65de:	2c 81       	sub	@r1,	r12	;
    65e0:	0c fd       	and	r13,	r12	;
    65e2:	81 4c 04 00 	mov	r12,	4(r1)	;

000065e6 <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    65e6:	1c 42 2e 51 	mov	&0x512e,r12	;0x512e
    65ea:	1d 41 04 00 	mov	4(r1),	r13	;
    65ee:	0c 8d       	sub	r13,	r12	;
    65f0:	1c 91 02 00 	cmp	2(r1),	r12	;
    65f4:	02 2c       	jc	$+6      	;abs 0x65fa

000065f6 <.Loc.118.2>:
    return NULL;
    65f6:	4c 43       	clr.b	r12		;
    65f8:	08 3c       	jmp	$+18     	;abs 0x660a

000065fa <.L5>:
  }
  nextmem = p + size;
    65fa:	1c 41 04 00 	mov	4(r1),	r12	;
    65fe:	1c 51 02 00 	add	2(r1),	r12	;
    6602:	82 4c 2c 51 	mov	r12,	&0x512c	;

00006606 <.Loc.122.2>:

  return p;
    6606:	1c 41 04 00 	mov	4(r1),	r12	;

0000660a <.L6>:
}
    660a:	31 50 06 00 	add	#6,	r1	;
    660e:	30 41       	ret			

00006610 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    6610:	31 80 06 00 	Address 0x0000000000006612 is out of bounds.
sub	#65535,	r1	;#0xffff

00006612 <L0>:
    6612:	06 00       	mova	@r0,	r6	;

00006614 <.LCFI1>:
    6614:	81 4c 02 00 	mov	r12,	2(r1)	;
    6618:	81 4d 00 00 	mov	r13,	0(r1)	;

0000661c <.Loc.140.2>:
  void *p;

  chSysLock();
    661c:	b0 12 9e 65 	call	#26014		;#0x659e

00006620 <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    6620:	2d 41       	mov	@r1,	r13	;
    6622:	1c 41 02 00 	mov	2(r1),	r12	;
    6626:	b0 12 b0 65 	call	#26032		;#0x65b0
    662a:	81 4c 04 00 	mov	r12,	4(r1)	;

0000662e <.Loc.142.2>:
  chSysUnlock();
    662e:	b0 12 a6 65 	call	#26022		;#0x65a6

00006632 <.Loc.144.2>:

  return p;
    6632:	1c 41 04 00 	mov	4(r1),	r12	;

00006636 <.Loc.145.2>:
}
    6636:	31 50 06 00 	add	#6,	r1	;
    663a:	30 41       	ret			

0000663c <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    663c:	b2 40 10 66 	mov	#26128,	&0x5130	;#0x6610
    6640:	30 51 

00006642 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6642:	82 43 32 51 	mov	#0,	&0x5132	;r3 As==00

00006646 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    6646:	82 43 34 51 	mov	#0,	&0x5134	;r3 As==00

0000664a <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    664a:	92 43 36 51 	mov	#1,	&0x5136	;r3 As==01

0000664e <.Loc.117.1>:
#endif
}
    664e:	03 43       	nop			
    6650:	30 41       	ret			

00006652 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6652:	03 43       	nop			

00006654 <.Loc.356.1>:
  _enable_interrupts();
    6654:	32 d2       	eint			
    6656:	03 43       	nop			

00006658 <.Loc.357.1>:
}
    6658:	03 43       	nop			
    665a:	30 41       	ret			

0000665c <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    665c:	6a 15       	pushm	#7,	r10	;16-bit words

0000665e <.Loc.80.2>:
  asm volatile ("mov r1, @R13");
    665e:	8d 41 00 00 	mov	r1,	0(r13)	;

00006662 <.Loc.81.2>:
  asm volatile ("mov @R12, r1");
    6662:	21 4c       	mov	@r12,	r1	;

00006664 <.Loc.82.2>:
  asm volatile ("popm.w #7, R10");
    6664:	64 17       	popm	#7,	r10	;16-bit words

00006666 <.Loc.83.2>:
  asm volatile ("ret");
    6666:	30 41       	ret			

00006668 <.Loc.85.2>:
#endif
}
    6668:	03 43       	nop			

0000666a <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    666a:	b0 12 52 66 	call	#26194		;#0x6652

0000666e <.Loc.100.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    666e:	0c 45       	mov	r5,	r12	;

00006670 <.Loc.101.2>:
  asm volatile ("call R4");
    6670:	84 12       	call	r4		;

00006672 <.Loc.107.2>:
#endif
#if defined(_CHIBIOS_RT_CONF_)
  chThdExit(MSG_OK);
#endif
#if defined(_CHIBIOS_NIL_CONF_)
  chSysHalt(0);
    6672:	4c 43       	clr.b	r12		;
    6674:	b0 12 52 63 	call	#25426		;#0x6352

00006678 <.Loc.109.2>:
#endif
}
    6678:	03 43       	nop			
    667a:	30 41       	ret			

0000667c <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    667c:	31 82       	sub	#8,	r1	;r2 As==11

0000667e <.LCFI0>:
    667e:	81 4c 02 00 	mov	r12,	2(r1)	;
    6682:	81 4d 00 00 	mov	r13,	0(r1)	;

00006686 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    6686:	91 41 02 00 	mov	2(r1),	4(r1)	;
    668a:	04 00 

0000668c <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    668c:	1c 41 02 00 	mov	2(r1),	r12	;
    6690:	2c 4c       	mov	@r12,	r12	;
    6692:	0c 93       	cmp	#0,	r12	;r3 As==00
    6694:	1d 34       	jge	$+60     	;abs 0x66d0

00006696 <.LBB2>:
    thread_t *tp = nil.threads;
    6696:	b1 40 14 51 	mov	#20756,	6(r1)	;#0x5114
    669a:	06 00 

0000669c <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    669c:	1c 41 06 00 	mov	6(r1),	r12	;
    66a0:	1c 4c 04 00 	mov	4(r12),	r12	;
    66a4:	1c 91 04 00 	cmp	4(r1),	r12	;
    66a8:	0f 20       	jnz	$+32     	;abs 0x66c8

000066aa <.Loc.67.1>:
        sp->cnt++;
    66aa:	1c 41 04 00 	mov	4(r1),	r12	;
    66ae:	2c 4c       	mov	@r12,	r12	;
    66b0:	1c 53       	inc	r12		;
    66b2:	0d 4c       	mov	r12,	r13	;
    66b4:	1c 41 04 00 	mov	4(r1),	r12	;
    66b8:	8c 4d 00 00 	mov	r13,	0(r12)	;

000066bc <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    66bc:	2d 41       	mov	@r1,	r13	;
    66be:	1c 41 06 00 	mov	6(r1),	r12	;
    66c2:	b0 12 e4 63 	call	#25572		;#0x63e4

000066c6 <.Loc.72.1>:
        return;
    66c6:	04 3c       	jmp	$+10     	;abs 0x66d0

000066c8 <.L3>:
      }
      tp++;
    66c8:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    66cc:	06 00 

000066ce <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    66ce:	e6 3f       	jmp	$-50     	;abs 0x669c

000066d0 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    66d0:	31 52       	add	#8,	r1	;r2 As==11
    66d2:	30 41       	ret			

000066d4 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    66d4:	03 43       	nop			
    66d6:	30 41       	ret			

000066d8 <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    66d8:	b0 12 d4 66 	call	#26324		;#0x66d4

000066dc <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    66dc:	b0 12 b6 70 	call	#28854		;#0x70b6

000066e0 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    66e0:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    66e4:	b0 12 14 78 	call	#30740		;#0x7814

000066e8 <.Loc.101.2>:
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    66e8:	b0 12 cc 6e 	call	#28364		;#0x6ecc

000066ec <.Loc.107.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    66ec:	b0 12 22 70 	call	#28706		;#0x7022

000066f0 <.Loc.136.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    66f0:	b0 12 56 81 	call	#33110		;#0x8156

000066f4 <.Loc.143.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    66f4:	b0 12 fc 66 	call	#26364		;#0x66fc

000066f8 <.Loc.145.2>:
#endif
}
    66f8:	03 43       	nop			
    66fa:	30 41       	ret			

000066fc <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    66fc:	b0 12 38 71 	call	#28984		;#0x7138

00006700 <.Loc.63.2>:
}
    6700:	03 43       	nop			
    6702:	30 41       	ret			

00006704 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6704:	32 c2       	dint			

00006706 <.Loc.348.1>:
  asm volatile("nop");
    6706:	03 43       	nop			

00006708 <.Loc.349.1>:
}
    6708:	03 43       	nop			
    670a:	30 41       	ret			

0000670c <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    670c:	03 43       	nop			

0000670e <.Loc.356.1>:
  _enable_interrupts();
    670e:	32 d2       	eint			
    6710:	03 43       	nop			

00006712 <.Loc.357.1>:
}
    6712:	03 43       	nop			
    6714:	30 41       	ret			

00006716 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6716:	b0 12 04 67 	call	#26372		;#0x6704

0000671a <.Loc.505.2>:
}
    671a:	03 43       	nop			
    671c:	30 41       	ret			

0000671e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    671e:	b0 12 0c 67 	call	#26380		;#0x670c

00006722 <.Loc.516.2>:
}
    6722:	03 43       	nop			
    6724:	30 41       	ret			

00006726 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6726:	1c 42 10 51 	mov	&0x5110,r12	;0x5110

0000672a <.Loc.630.2>:
}
    672a:	30 41       	ret			

0000672c <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    672c:	21 83       	decd	r1		;

0000672e <.LCFI0>:
    672e:	81 4c 00 00 	mov	r12,	0(r1)	;

00006732 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    6732:	2c 41       	mov	@r1,	r12	;
    6734:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006738 <.Loc.768.2>:
}
    6738:	03 43       	nop			
    673a:	21 53       	incd	r1		;
    673c:	30 41       	ret			

0000673e <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    673e:	21 82       	sub	#4,	r1	;r2 As==10

00006740 <.LCFI1>:
    6740:	81 4c 02 00 	mov	r12,	2(r1)	;
    6744:	81 4d 00 00 	mov	r13,	0(r1)	;

00006748 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6748:	1c 41 02 00 	mov	2(r1),	r12	;
    674c:	2d 41       	mov	@r1,	r13	;
    674e:	b0 12 3e 65 	call	#25918		;#0x653e

00006752 <.Loc.797.2>:
}
    6752:	21 52       	add	#4,	r1	;r2 As==10
    6754:	30 41       	ret			

00006756 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6756:	31 82       	sub	#8,	r1	;r2 As==11

00006758 <.LCFI2>:
    6758:	81 4c 06 00 	mov	r12,	6(r1)	;
    675c:	81 4d 04 00 	mov	r13,	4(r1)	;
    6760:	81 4e 02 00 	mov	r14,	2(r1)	;
    6764:	81 4f 00 00 	mov	r15,	0(r1)	;

00006768 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6768:	1c 41 06 00 	mov	6(r1),	r12	;
    676c:	b0 12 2c 67 	call	#26412		;#0x672c

00006770 <.Loc.59.3>:
  iqp->q_counter = 0;
    6770:	1c 41 06 00 	mov	6(r1),	r12	;
    6774:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006778 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6778:	1c 41 06 00 	mov	6(r1),	r12	;
    677c:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6780:	04 00 

00006782 <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    6782:	1c 41 06 00 	mov	6(r1),	r12	;
    6786:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    678a:	0a 00 

0000678c <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    678c:	1c 41 06 00 	mov	6(r1),	r12	;
    6790:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6794:	08 00 

00006796 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    6796:	1d 41 04 00 	mov	4(r1),	r13	;
    679a:	1d 51 02 00 	add	2(r1),	r13	;
    679e:	1c 41 06 00 	mov	6(r1),	r12	;
    67a2:	8c 4d 06 00 	mov	r13,	6(r12)	;

000067a6 <.Loc.64.3>:
  iqp->q_notify  = infy;
    67a6:	1c 41 06 00 	mov	6(r1),	r12	;
    67aa:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000067ae <.Loc.65.3>:
  iqp->q_link    = link;
    67ae:	1c 41 06 00 	mov	6(r1),	r12	;
    67b2:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    67b6:	0e 00 

000067b8 <.Loc.66.3>:
}
    67b8:	03 43       	nop			
    67ba:	31 52       	add	#8,	r1	;r2 As==11
    67bc:	30 41       	ret			

000067be <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    67be:	21 82       	sub	#4,	r1	;r2 As==10

000067c0 <.LCFI4>:
    67c0:	81 4c 02 00 	mov	r12,	2(r1)	;
    67c4:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000067c8 <.Loc.106.3>:

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
    67c8:	1c 41 02 00 	mov	2(r1),	r12	;
    67cc:	1d 4c 08 00 	mov	8(r12),	r13	;
    67d0:	1c 41 02 00 	mov	2(r1),	r12	;
    67d4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    67d8:	0d 9c       	cmp	r12,	r13	;
    67da:	08 20       	jnz	$+18     	;abs 0x67ec

000067dc <.Loc.106.3>:
    67dc:	1c 41 02 00 	mov	2(r1),	r12	;
    67e0:	1c 4c 02 00 	mov	2(r12),	r12	;
    67e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    67e6:	02 24       	jz	$+6      	;abs 0x67ec

000067e8 <.Loc.106.3>:
    67e8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    67ea:	01 3c       	jmp	$+4      	;abs 0x67ee

000067ec <.L13>:
    67ec:	4c 43       	clr.b	r12		;

000067ee <.L14>:
    67ee:	5c f3       	and.b	#1,	r12	;r3 As==01
    67f0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    67f4:	0c 93       	cmp	#0,	r12	;r3 As==00
    67f6:	02 24       	jz	$+6      	;abs 0x67fc

000067f8 <.Loc.107.3>:
    return MSG_TIMEOUT;
    67f8:	3c 43       	mov	#-1,	r12	;r3 As==11
    67fa:	2f 3c       	jmp	$+96     	;abs 0x685a

000067fc <.L15>:
  }

  iqp->q_counter++;
    67fc:	1c 41 02 00 	mov	2(r1),	r12	;
    6800:	1c 4c 02 00 	mov	2(r12),	r12	;
    6804:	0d 4c       	mov	r12,	r13	;
    6806:	1d 53       	inc	r13		;
    6808:	1c 41 02 00 	mov	2(r1),	r12	;
    680c:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006810 <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    6810:	1c 41 02 00 	mov	2(r1),	r12	;
    6814:	1c 4c 08 00 	mov	8(r12),	r12	;
    6818:	0e 4c       	mov	r12,	r14	;
    681a:	1e 53       	inc	r14		;
    681c:	1d 41 02 00 	mov	2(r1),	r13	;
    6820:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6824:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6828:	00 00 

0000682a <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    682a:	1c 41 02 00 	mov	2(r1),	r12	;
    682e:	1d 4c 08 00 	mov	8(r12),	r13	;
    6832:	1c 41 02 00 	mov	2(r1),	r12	;
    6836:	1c 4c 06 00 	mov	6(r12),	r12	;
    683a:	0d 9c       	cmp	r12,	r13	;
    683c:	08 28       	jnc	$+18     	;abs 0x684e

0000683e <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    683e:	1c 41 02 00 	mov	2(r1),	r12	;
    6842:	1d 4c 04 00 	mov	4(r12),	r13	;
    6846:	1c 41 02 00 	mov	2(r1),	r12	;
    684a:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000684e <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    684e:	1c 41 02 00 	mov	2(r1),	r12	;
    6852:	4d 43       	clr.b	r13		;
    6854:	b0 12 7c 66 	call	#26236		;#0x667c

00006858 <.Loc.118.3>:

  return MSG_OK;
    6858:	4c 43       	clr.b	r12		;

0000685a <.L16>:
}
    685a:	21 52       	add	#4,	r1	;r2 As==10
    685c:	30 41       	ret			

0000685e <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    685e:	31 82       	sub	#8,	r1	;r2 As==11

00006860 <.LCFI5>:
    6860:	81 4c 02 00 	Address 0x0000000000006862 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006862 <L0>:
    6862:	02 00       	mova	@r0,	r2	;
    6864:	81 4d 00 00 	mov	r13,	0(r1)	;

00006868 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6868:	b0 12 16 67 	call	#26390		;#0x6716

0000686c <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    686c:	0f 3c       	jmp	$+32     	;abs 0x688c

0000686e <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    686e:	1c 41 02 00 	mov	2(r1),	r12	;
    6872:	2d 41       	mov	@r1,	r13	;
    6874:	b0 12 3e 67 	call	#26430		;#0x673e
    6878:	81 4c 06 00 	mov	r12,	6(r1)	;

0000687c <.Loc.149.3>:
    if (msg < MSG_OK) {
    687c:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6880:	05 34       	jge	$+12     	;abs 0x688c

00006882 <.Loc.150.3>:
      osalSysUnlock();
    6882:	b0 12 1e 67 	call	#26398		;#0x671e

00006886 <.Loc.151.3>:
      return msg;
    6886:	1c 41 06 00 	mov	6(r1),	r12	;
    688a:	3f 3c       	jmp	$+128    	;abs 0x690a

0000688c <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    688c:	1c 41 02 00 	mov	2(r1),	r12	;
    6890:	1c 4c 02 00 	mov	2(r12),	r12	;
    6894:	0c 93       	cmp	#0,	r12	;r3 As==00
    6896:	eb 27       	jz	$-40     	;abs 0x686e

00006898 <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    6898:	1c 41 02 00 	mov	2(r1),	r12	;
    689c:	1c 4c 02 00 	mov	2(r12),	r12	;
    68a0:	0d 4c       	mov	r12,	r13	;
    68a2:	3d 53       	add	#-1,	r13	;r3 As==11
    68a4:	1c 41 02 00 	mov	2(r1),	r12	;
    68a8:	8c 4d 02 00 	mov	r13,	2(r12)	;

000068ac <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    68ac:	1c 41 02 00 	mov	2(r1),	r12	;
    68b0:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    68b4:	0e 4c       	mov	r12,	r14	;
    68b6:	1e 53       	inc	r14		;
    68b8:	1d 41 02 00 	mov	2(r1),	r13	;
    68bc:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    68c0:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

000068c4 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    68c4:	1c 41 02 00 	mov	2(r1),	r12	;
    68c8:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    68cc:	1c 41 02 00 	mov	2(r1),	r12	;
    68d0:	1c 4c 06 00 	mov	6(r12),	r12	;
    68d4:	0d 9c       	cmp	r12,	r13	;
    68d6:	08 28       	jnc	$+18     	;abs 0x68e8

000068d8 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    68d8:	1c 41 02 00 	mov	2(r1),	r12	;
    68dc:	1d 4c 04 00 	mov	4(r12),	r13	;
    68e0:	1c 41 02 00 	mov	2(r1),	r12	;
    68e4:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000068e8 <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    68e8:	1c 41 02 00 	mov	2(r1),	r12	;
    68ec:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    68f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    68f2:	07 24       	jz	$+16     	;abs 0x6902

000068f4 <.Loc.164.3>:
    iqp->q_notify(iqp);
    68f4:	1c 41 02 00 	mov	2(r1),	r12	;
    68f8:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    68fc:	1c 41 02 00 	mov	2(r1),	r12	;
    6900:	8d 12       	call	r13		;

00006902 <.L23>:
  }

  osalSysUnlock();
    6902:	b0 12 1e 67 	call	#26398		;#0x671e

00006906 <.Loc.169.3>:

  return (msg_t)b;
    6906:	5c 41 05 00 	mov.b	5(r1),	r12	;

0000690a <.L20>:
}
    690a:	31 52       	add	#8,	r1	;r2 As==11
    690c:	30 41       	ret			

0000690e <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    690e:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006912 <L0>:
    6912:	81 4c 06 00 	mov	r12,	6(r1)	;
    6916:	81 4d 04 00 	mov	r13,	4(r1)	;
    691a:	81 4e 02 00 	mov	r14,	2(r1)	;
    691e:	81 4f 00 00 	mov	r15,	0(r1)	;

00006922 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6922:	1c 41 06 00 	mov	6(r1),	r12	;
    6926:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    692a:	0c 00 

0000692c <.Loc.200.3>:
  size_t r = 0;
    692c:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006930 <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6930:	b0 12 16 67 	call	#26390		;#0x6716

00006934 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6934:	b0 12 26 67 	call	#26406		;#0x6726
    6938:	0d 4c       	mov	r12,	r13	;
    693a:	2d 51       	add	@r1,	r13	;
    693c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006940 <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6940:	2e 3c       	jmp	$+94     	;abs 0x699e

00006942 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6942:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6946:	03 24       	jz	$+8      	;abs 0x694e

00006948 <.Loc.218.3>:
    6948:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    694c:	08 20       	jnz	$+18     	;abs 0x695e

0000694e <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    694e:	1c 41 06 00 	mov	6(r1),	r12	;
    6952:	2d 41       	mov	@r1,	r13	;
    6954:	b0 12 3e 67 	call	#26430		;#0x673e
    6958:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    695c:	18 3c       	jmp	$+50     	;abs 0x698e

0000695e <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    695e:	b0 12 26 67 	call	#26406		;#0x6726
    6962:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6966:	0d 8c       	sub	r12,	r13	;
    6968:	81 4d 08 00 	mov	r13,	8(r1)	;

0000696c <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    696c:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6970:	00 00 
    6972:	05 2c       	jc	$+12     	;abs 0x697e

00006974 <.Loc.228.3>:
          osalSysUnlock();
    6974:	b0 12 1e 67 	call	#26398		;#0x671e

00006978 <.Loc.229.3>:
          return r;
    6978:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    697c:	5c 3c       	jmp	$+186    	;abs 0x6a36

0000697e <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    697e:	1c 41 06 00 	mov	6(r1),	r12	;
    6982:	1d 41 08 00 	mov	8(r1),	r13	;
    6986:	b0 12 3e 67 	call	#26430		;#0x673e
    698a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

0000698e <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    698e:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6992:	05 24       	jz	$+12     	;abs 0x699e

00006994 <.Loc.237.3>:
        osalSysUnlock();
    6994:	b0 12 1e 67 	call	#26398		;#0x671e

00006998 <.Loc.238.3>:
        return r;
    6998:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    699c:	4c 3c       	jmp	$+154    	;abs 0x6a36

0000699e <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    699e:	1c 41 06 00 	mov	6(r1),	r12	;
    69a2:	1c 4c 02 00 	mov	2(r12),	r12	;
    69a6:	0c 93       	cmp	#0,	r12	;r3 As==00
    69a8:	cc 27       	jz	$-102    	;abs 0x6942

000069aa <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    69aa:	1c 41 06 00 	mov	6(r1),	r12	;
    69ae:	1c 4c 02 00 	mov	2(r12),	r12	;
    69b2:	0d 4c       	mov	r12,	r13	;
    69b4:	3d 53       	add	#-1,	r13	;r3 As==11
    69b6:	1c 41 06 00 	mov	6(r1),	r12	;
    69ba:	8c 4d 02 00 	mov	r13,	2(r12)	;

000069be <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    69be:	1c 41 04 00 	mov	4(r1),	r12	;
    69c2:	0d 4c       	mov	r12,	r13	;
    69c4:	1d 53       	inc	r13		;
    69c6:	81 4d 04 00 	mov	r13,	4(r1)	;
    69ca:	1d 41 06 00 	mov	6(r1),	r13	;
    69ce:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    69d2:	0f 4d       	mov	r13,	r15	;
    69d4:	1f 53       	inc	r15		;
    69d6:	1e 41 06 00 	mov	6(r1),	r14	;
    69da:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    69de:	6d 4d       	mov.b	@r13,	r13	;
    69e0:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000069e4 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    69e4:	1c 41 06 00 	mov	6(r1),	r12	;
    69e8:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    69ec:	1c 41 06 00 	mov	6(r1),	r12	;
    69f0:	1c 4c 06 00 	mov	6(r12),	r12	;
    69f4:	0d 9c       	cmp	r12,	r13	;
    69f6:	08 28       	jnc	$+18     	;abs 0x6a08

000069f8 <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    69f8:	1c 41 06 00 	mov	6(r1),	r12	;
    69fc:	1d 4c 04 00 	mov	4(r12),	r13	;
    6a00:	1c 41 06 00 	mov	6(r1),	r12	;
    6a04:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006a08 <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6a08:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6a0c:	05 24       	jz	$+12     	;abs 0x6a18

00006a0e <.Loc.251.3>:
      nfy(iqp);
    6a0e:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6a12:	1c 41 06 00 	mov	6(r1),	r12	;
    6a16:	8d 12       	call	r13		;

00006a18 <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6a18:	b0 12 1e 67 	call	#26398		;#0x671e

00006a1c <.Loc.257.3>:

    r++;
    6a1c:	91 53 10 00 	inc	16(r1)		;

00006a20 <.Loc.258.3>:
    if (--n == 0U) {
    6a20:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6a24:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6a28:	03 20       	jnz	$+8      	;abs 0x6a30

00006a2a <.Loc.259.3>:
      return r;
    6a2a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6a2e:	03 3c       	jmp	$+8      	;abs 0x6a36

00006a30 <.L34>:
    }

    osalSysLock();
    6a30:	b0 12 16 67 	call	#26390		;#0x6716

00006a34 <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6a34:	b4 3f       	jmp	$-150    	;abs 0x699e

00006a36 <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    6a36:	31 50 12 00 	add	#18,	r1	;#0x0012
    6a3a:	30 41       	ret			

00006a3c <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    6a3c:	31 82       	sub	#8,	r1	;r2 As==11

00006a3e <.LCFI7>:
    6a3e:	81 4c 06 00 	mov	r12,	6(r1)	;
    6a42:	81 4d 04 00 	mov	r13,	4(r1)	;
    6a46:	81 4e 02 00 	Address 0x0000000000006a48 is out of bounds.
mov	r14,	-1(r1)	; 0xffff

00006a48 <L0>:
    6a48:	02 00       	mova	@r0,	r2	;
    6a4a:	81 4f 00 00 	mov	r15,	0(r1)	;

00006a4e <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    6a4e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a52:	b0 12 2c 67 	call	#26412		;#0x672c

00006a56 <.Loc.285.3>:
  oqp->q_counter = size;
    6a56:	1c 41 06 00 	mov	6(r1),	r12	;
    6a5a:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    6a5e:	02 00 

00006a60 <.Loc.286.3>:
  oqp->q_buffer  = bp;
    6a60:	1c 41 06 00 	mov	6(r1),	r12	;
    6a64:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6a68:	04 00 

00006a6a <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6a6a:	1c 41 06 00 	mov	6(r1),	r12	;
    6a6e:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6a72:	0a 00 

00006a74 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6a74:	1c 41 06 00 	mov	6(r1),	r12	;
    6a78:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    6a7c:	08 00 

00006a7e <.Loc.289.3>:
  oqp->q_top     = bp + size;
    6a7e:	1d 41 04 00 	mov	4(r1),	r13	;
    6a82:	1d 51 02 00 	add	2(r1),	r13	;
    6a86:	1c 41 06 00 	mov	6(r1),	r12	;
    6a8a:	8c 4d 06 00 	mov	r13,	6(r12)	;

00006a8e <.Loc.290.3>:
  oqp->q_notify  = onfy;
    6a8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6a92:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

00006a96 <.Loc.291.3>:
  oqp->q_link    = link;
    6a96:	1c 41 06 00 	mov	6(r1),	r12	;
    6a9a:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    6a9e:	0e 00 

00006aa0 <.Loc.292.3>:
}
    6aa0:	03 43       	nop			
    6aa2:	31 52       	add	#8,	r1	;r2 As==11
    6aa4:	30 41       	ret			

00006aa6 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    6aa6:	31 82       	sub	#8,	r1	;r2 As==11

00006aa8 <.LCFI9>:
    6aa8:	81 4c 04 00 	mov	r12,	4(r1)	;
    6aac:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6ab0:	81 4e 00 00 	mov	r14,	0(r1)	;

00006ab4 <.Loc.339.3>:

  osalSysLock();
    6ab4:	b0 12 16 67 	call	#26390		;#0x6716

00006ab8 <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6ab8:	0f 3c       	jmp	$+32     	;abs 0x6ad8

00006aba <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6aba:	1c 41 04 00 	mov	4(r1),	r12	;
    6abe:	2d 41       	mov	@r1,	r13	;
    6ac0:	b0 12 3e 67 	call	#26430		;#0x673e
    6ac4:	81 4c 06 00 	mov	r12,	6(r1)	;

00006ac8 <.Loc.344.3>:
    if (msg < MSG_OK) {
    6ac8:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    6acc:	05 34       	jge	$+12     	;abs 0x6ad8

00006ace <.Loc.345.3>:
      osalSysUnlock();
    6ace:	b0 12 1e 67 	call	#26398		;#0x671e

00006ad2 <.Loc.346.3>:
      return msg;
    6ad2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ad6:	3f 3c       	jmp	$+128    	;abs 0x6b56

00006ad8 <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    6ad8:	1c 41 04 00 	mov	4(r1),	r12	;
    6adc:	1c 4c 02 00 	mov	2(r12),	r12	;
    6ae0:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ae2:	eb 27       	jz	$-40     	;abs 0x6aba

00006ae4 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    6ae4:	1c 41 04 00 	mov	4(r1),	r12	;
    6ae8:	1c 4c 02 00 	mov	2(r12),	r12	;
    6aec:	0d 4c       	mov	r12,	r13	;
    6aee:	3d 53       	add	#-1,	r13	;r3 As==11
    6af0:	1c 41 04 00 	mov	4(r1),	r12	;
    6af4:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006af8 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6af8:	1c 41 04 00 	mov	4(r1),	r12	;
    6afc:	1c 4c 08 00 	mov	8(r12),	r12	;
    6b00:	0e 4c       	mov	r12,	r14	;
    6b02:	1e 53       	inc	r14		;
    6b04:	1d 41 04 00 	mov	4(r1),	r13	;
    6b08:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6b0c:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    6b10:	00 00 

00006b12 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6b12:	1c 41 04 00 	mov	4(r1),	r12	;
    6b16:	1d 4c 08 00 	mov	8(r12),	r13	;
    6b1a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b1e:	1c 4c 06 00 	mov	6(r12),	r12	;
    6b22:	0d 9c       	cmp	r12,	r13	;
    6b24:	08 28       	jnc	$+18     	;abs 0x6b36

00006b26 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    6b26:	1c 41 04 00 	mov	4(r1),	r12	;
    6b2a:	1d 4c 04 00 	mov	4(r12),	r13	;
    6b2e:	1c 41 04 00 	mov	4(r1),	r12	;
    6b32:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006b36 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6b36:	1c 41 04 00 	mov	4(r1),	r12	;
    6b3a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    6b3e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b40:	07 24       	jz	$+16     	;abs 0x6b50

00006b42 <.Loc.359.3>:
    oqp->q_notify(oqp);
    6b42:	1c 41 04 00 	mov	4(r1),	r12	;
    6b46:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6b4a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b4e:	8d 12       	call	r13		;

00006b50 <.L43>:
  }

  osalSysUnlock();
    6b50:	b0 12 1e 67 	call	#26398		;#0x671e

00006b54 <.Loc.364.3>:

  return MSG_OK;
    6b54:	4c 43       	clr.b	r12		;

00006b56 <.L40>:
}
    6b56:	31 52       	add	#8,	r1	;r2 As==11
    6b58:	30 41       	ret			

00006b5a <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6b5a:	21 82       	sub	#4,	r1	;r2 As==10

00006b5c <.LCFI10>:
    6b5c:	81 4c 00 00 	Address 0x0000000000006b5e is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006b5e <L0>:
	...

00006b60 <.Loc.382.3>:
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
    6b60:	2c 41       	mov	@r1,	r12	;
    6b62:	1d 4c 08 00 	mov	8(r12),	r13	;
    6b66:	2c 41       	mov	@r1,	r12	;
    6b68:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6b6c:	0d 9c       	cmp	r12,	r13	;
    6b6e:	07 20       	jnz	$+16     	;abs 0x6b7e

00006b70 <.Loc.382.3>:
    6b70:	2c 41       	mov	@r1,	r12	;
    6b72:	1c 4c 02 00 	mov	2(r12),	r12	;
    6b76:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b78:	02 24       	jz	$+6      	;abs 0x6b7e

00006b7a <.Loc.382.3>:
    6b7a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6b7c:	01 3c       	jmp	$+4      	;abs 0x6b80

00006b7e <.L45>:
    6b7e:	4c 43       	clr.b	r12		;

00006b80 <.L46>:
    6b80:	5c f3       	and.b	#1,	r12	;r3 As==01
    6b82:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6b86:	0c 93       	cmp	#0,	r12	;r3 As==00
    6b88:	02 24       	jz	$+6      	;abs 0x6b8e

00006b8a <.Loc.383.3>:
    return MSG_TIMEOUT;
    6b8a:	3c 43       	mov	#-1,	r12	;r3 As==11
    6b8c:	26 3c       	jmp	$+78     	;abs 0x6bda

00006b8e <.L47>:
  }

  oqp->q_counter++;
    6b8e:	2c 41       	mov	@r1,	r12	;
    6b90:	1c 4c 02 00 	mov	2(r12),	r12	;
    6b94:	0d 4c       	mov	r12,	r13	;
    6b96:	1d 53       	inc	r13		;
    6b98:	2c 41       	mov	@r1,	r12	;
    6b9a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006b9e <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    6b9e:	2c 41       	mov	@r1,	r12	;
    6ba0:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    6ba4:	0e 4c       	mov	r12,	r14	;
    6ba6:	1e 53       	inc	r14		;
    6ba8:	2d 41       	mov	@r1,	r13	;
    6baa:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    6bae:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

00006bb2 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    6bb2:	2c 41       	mov	@r1,	r12	;
    6bb4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    6bb8:	2c 41       	mov	@r1,	r12	;
    6bba:	1c 4c 06 00 	mov	6(r12),	r12	;
    6bbe:	0d 9c       	cmp	r12,	r13	;
    6bc0:	06 28       	jnc	$+14     	;abs 0x6bce

00006bc2 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    6bc2:	2c 41       	mov	@r1,	r12	;
    6bc4:	1d 4c 04 00 	mov	4(r12),	r13	;
    6bc8:	2c 41       	mov	@r1,	r12	;
    6bca:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006bce <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    6bce:	2c 41       	mov	@r1,	r12	;
    6bd0:	4d 43       	clr.b	r13		;
    6bd2:	b0 12 7c 66 	call	#26236		;#0x667c

00006bd6 <.Loc.394.3>:

  return (msg_t)b;
    6bd6:	5c 41 03 00 	mov.b	3(r1),	r12	;

00006bda <.L48>:
}
    6bda:	21 52       	add	#4,	r1	;r2 As==10
    6bdc:	30 41       	ret			

00006bde <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    6bde:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006be2 <L0>:
    6be2:	81 4c 06 00 	mov	r12,	6(r1)	;
    6be6:	81 4d 04 00 	mov	r13,	4(r1)	;
    6bea:	81 4e 02 00 	mov	r14,	2(r1)	;
    6bee:	81 4f 00 00 	mov	r15,	0(r1)	;

00006bf2 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    6bf2:	1c 41 06 00 	mov	6(r1),	r12	;
    6bf6:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6bfa:	0c 00 

00006bfc <.Loc.425.3>:
  size_t w = 0;
    6bfc:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006c00 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6c00:	b0 12 16 67 	call	#26390		;#0x6716

00006c04 <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6c04:	b0 12 26 67 	call	#26406		;#0x6726
    6c08:	0d 4c       	mov	r12,	r13	;
    6c0a:	2d 51       	add	@r1,	r13	;
    6c0c:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006c10 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6c10:	2e 3c       	jmp	$+94     	;abs 0x6c6e

00006c12 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6c12:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6c16:	03 24       	jz	$+8      	;abs 0x6c1e

00006c18 <.Loc.442.3>:
    6c18:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    6c1c:	08 20       	jnz	$+18     	;abs 0x6c2e

00006c1e <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6c1e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c22:	2d 41       	mov	@r1,	r13	;
    6c24:	b0 12 3e 67 	call	#26430		;#0x673e
    6c28:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    6c2c:	18 3c       	jmp	$+50     	;abs 0x6c5e

00006c2e <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6c2e:	b0 12 26 67 	call	#26406		;#0x6726
    6c32:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6c36:	0e 8c       	sub	r12,	r14	;
    6c38:	81 4e 08 00 	mov	r14,	8(r1)	;

00006c3c <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    6c3c:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6c40:	00 00 
    6c42:	05 2c       	jc	$+12     	;abs 0x6c4e

00006c44 <.Loc.452.3>:
          osalSysUnlock();
    6c44:	b0 12 1e 67 	call	#26398		;#0x671e

00006c48 <.Loc.453.3>:
          return w;
    6c48:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6c4c:	5c 3c       	jmp	$+186    	;abs 0x6d06

00006c4e <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    6c4e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c52:	1d 41 08 00 	mov	8(r1),	r13	;
    6c56:	b0 12 3e 67 	call	#26430		;#0x673e
    6c5a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006c5e <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6c5e:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6c62:	05 24       	jz	$+12     	;abs 0x6c6e

00006c64 <.Loc.461.3>:
        osalSysUnlock();
    6c64:	b0 12 1e 67 	call	#26398		;#0x671e

00006c68 <.Loc.462.3>:
        return w;
    6c68:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6c6c:	4c 3c       	jmp	$+154    	;abs 0x6d06

00006c6e <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6c6e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c72:	1c 4c 02 00 	mov	2(r12),	r12	;
    6c76:	0c 93       	cmp	#0,	r12	;r3 As==00
    6c78:	cc 27       	jz	$-102    	;abs 0x6c12

00006c7a <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    6c7a:	1c 41 06 00 	mov	6(r1),	r12	;
    6c7e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6c82:	0d 4c       	mov	r12,	r13	;
    6c84:	3d 53       	add	#-1,	r13	;r3 As==11
    6c86:	1c 41 06 00 	mov	6(r1),	r12	;
    6c8a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006c8e <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    6c8e:	1c 41 06 00 	mov	6(r1),	r12	;
    6c92:	1c 4c 08 00 	mov	8(r12),	r12	;
    6c96:	0e 4c       	mov	r12,	r14	;
    6c98:	1e 53       	inc	r14		;
    6c9a:	1d 41 06 00 	mov	6(r1),	r13	;
    6c9e:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6ca2:	1d 41 04 00 	mov	4(r1),	r13	;
    6ca6:	0e 4d       	mov	r13,	r14	;
    6ca8:	1e 53       	inc	r14		;
    6caa:	81 4e 04 00 	mov	r14,	4(r1)	;
    6cae:	6d 4d       	mov.b	@r13,	r13	;
    6cb0:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006cb4 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    6cb4:	1c 41 06 00 	mov	6(r1),	r12	;
    6cb8:	1d 4c 08 00 	mov	8(r12),	r13	;
    6cbc:	1c 41 06 00 	mov	6(r1),	r12	;
    6cc0:	1c 4c 06 00 	mov	6(r12),	r12	;
    6cc4:	0d 9c       	cmp	r12,	r13	;
    6cc6:	08 28       	jnc	$+18     	;abs 0x6cd8

00006cc8 <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    6cc8:	1c 41 06 00 	mov	6(r1),	r12	;
    6ccc:	1d 4c 04 00 	mov	4(r12),	r13	;
    6cd0:	1c 41 06 00 	mov	6(r1),	r12	;
    6cd4:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006cd8 <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    6cd8:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    6cdc:	05 24       	jz	$+12     	;abs 0x6ce8

00006cde <.Loc.475.3>:
      nfy(oqp);
    6cde:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6ce2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ce6:	8d 12       	call	r13		;

00006ce8 <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6ce8:	b0 12 1e 67 	call	#26398		;#0x671e

00006cec <.Loc.481.3>:

    w++;
    6cec:	91 53 10 00 	inc	16(r1)		;

00006cf0 <.Loc.482.3>:
    if (--n == 0U) {
    6cf0:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6cf4:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6cf8:	03 20       	jnz	$+8      	;abs 0x6d00

00006cfa <.Loc.483.3>:
      return w;
    6cfa:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6cfe:	03 3c       	jmp	$+8      	;abs 0x6d06

00006d00 <.L60>:
    }

    osalSysLock();
    6d00:	b0 12 16 67 	call	#26390		;#0x6716

00006d04 <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    6d04:	85 3f       	jmp	$-244    	;abs 0x6c10

00006d06 <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    6d06:	31 50 12 00 	add	#18,	r1	;#0x0012
    6d0a:	30 41       	ret			

00006d0c <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6d0c:	32 c2       	dint			

00006d0e <.Loc.348.1>:
  asm volatile("nop");
    6d0e:	03 43       	nop			

00006d10 <.Loc.349.1>:
}
    6d10:	03 43       	nop			
    6d12:	30 41       	ret			

00006d14 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6d14:	03 43       	nop			

00006d16 <.Loc.356.1>:
  _enable_interrupts();
    6d16:	32 d2       	eint			

00006d18 <L0>:
    6d18:	03 43       	nop			

00006d1a <.Loc.357.1>:
}
    6d1a:	03 43       	nop			
    6d1c:	30 41       	ret			

00006d1e <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6d1e:	b0 12 0c 6d 	call	#27916		;#0x6d0c

00006d22 <.Loc.505.2>:
}
    6d22:	03 43       	nop			
    6d24:	30 41       	ret			

00006d26 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6d26:	b0 12 14 6d 	call	#27924		;#0x6d14

00006d2a <.Loc.516.2>:
}
    6d2a:	03 43       	nop			
    6d2c:	30 41       	ret			

00006d2e <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    6d2e:	21 83       	decd	r1		;

00006d30 <.LCFI0>:
    6d30:	81 4c 00 00 	mov	r12,	0(r1)	;

00006d34 <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    6d34:	2c 41       	mov	@r1,	r12	;
    6d36:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    6d3a:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006d3e <.Loc.811.2>:
  esp->cb    = NULL;
    6d3e:	2c 41       	mov	@r1,	r12	;
    6d40:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006d44 <.Loc.812.2>:
  esp->param = NULL;
    6d44:	2c 41       	mov	@r1,	r12	;
    6d46:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006d4a <.Loc.813.2>:
}
    6d4a:	03 43       	nop			
    6d4c:	21 53       	incd	r1		;
    6d4e:	30 41       	ret			

00006d50 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6d50:	0a 15       	pushm	#1,	r10	;16-bit words

00006d52 <.LCFI1>:
    6d52:	31 80 06 00 	sub	#6,	r1	;

00006d56 <.LCFI2>:
    6d56:	81 4c 04 00 	mov	r12,	4(r1)	;
    6d5a:	81 4d 00 00 	mov	r13,	0(r1)	;
    6d5e:	81 4e 02 00 	mov	r14,	2(r1)	;

00006d62 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6d62:	1c 41 04 00 	mov	4(r1),	r12	;
    6d66:	1d 4c 02 00 	mov	2(r12),	r13	;
    6d6a:	2c 4c       	mov	@r12,	r12	;
    6d6c:	2a 41       	mov	@r1,	r10	;
    6d6e:	0a dc       	bis	r12,	r10	;
    6d70:	1b 41 02 00 	mov	2(r1),	r11	;
    6d74:	0b dd       	bis	r13,	r11	;
    6d76:	1c 41 04 00 	mov	4(r1),	r12	;
    6d7a:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6d7e:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006d82 <.Loc.829.2>:
  if (esp->cb != NULL) {
    6d82:	1c 41 04 00 	mov	4(r1),	r12	;
    6d86:	1c 4c 04 00 	mov	4(r12),	r12	;
    6d8a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6d8c:	07 24       	jz	$+16     	;abs 0x6d9c

00006d8e <.Loc.830.2>:
    esp->cb(esp);
    6d8e:	1c 41 04 00 	mov	4(r1),	r12	;
    6d92:	1d 4c 04 00 	mov	4(r12),	r13	;
    6d96:	1c 41 04 00 	mov	4(r1),	r12	;
    6d9a:	8d 12       	call	r13		;

00006d9c <.L9>:
  }
}
    6d9c:	03 43       	nop			
    6d9e:	31 50 06 00 	add	#6,	r1	;
    6da2:	0a 17       	popm	#1,	r10	;16-bit words
    6da4:	30 41       	ret			

00006da6 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    6da6:	31 80 06 00 	sub	#6,	r1	;

00006daa <.LCFI3>:
    6daa:	81 4c 04 00 	mov	r12,	4(r1)	;
    6dae:	81 4d 02 00 	mov	r13,	2(r1)	;
    6db2:	81 4e 00 00 	mov	r14,	0(r1)	;

00006db6 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    6db6:	1c 41 04 00 	mov	4(r1),	r12	;
    6dba:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6dbe:	4f 43       	clr.b	r15		;
    6dc0:	2e 41       	mov	@r1,	r14	;
    6dc2:	1d 41 02 00 	mov	2(r1),	r13	;
    6dc6:	b0 12 de 6b 	call	#27614		;#0x6bde

00006dca <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    6dca:	31 50 06 00 	add	#6,	r1	;
    6dce:	30 41       	ret			

00006dd0 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    6dd0:	31 80 06 00 	sub	#6,	r1	;

00006dd4 <.LCFI4>:
    6dd4:	81 4c 04 00 	mov	r12,	4(r1)	;
    6dd8:	81 4d 02 00 	mov	r13,	2(r1)	;
    6ddc:	81 4e 00 00 	mov	r14,	0(r1)	;

00006de0 <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    6de0:	1c 41 04 00 	mov	4(r1),	r12	;
    6de4:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6de8:	4f 43       	clr.b	r15		;
    6dea:	2e 41       	mov	@r1,	r14	;
    6dec:	1d 41 02 00 	mov	2(r1),	r13	;
    6df0:	b0 12 0e 69 	call	#26894		;#0x690e

00006df4 <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    6df4:	31 50 06 00 	add	#6,	r1	;
    6df8:	30 41       	ret			

00006dfa <put>:

static msg_t put(void *ip, uint8_t b) {
    6dfa:	21 82       	sub	#4,	r1	;r2 As==10

00006dfc <.LCFI5>:
    6dfc:	81 4c 02 00 	mov	r12,	2(r1)	;
    6e00:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006e04 <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    6e04:	1c 41 02 00 	mov	2(r1),	r12	;
    6e08:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6e0c:	4e 43       	clr.b	r14		;
    6e0e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6e12:	b0 12 a6 6a 	call	#27302		;#0x6aa6

00006e16 <.Loc.65.3>:
}
    6e16:	21 52       	add	#4,	r1	;r2 As==10
    6e18:	30 41       	ret			

00006e1a <get>:

static msg_t get(void *ip) {
    6e1a:	21 83       	decd	r1		;

00006e1c <.LCFI6>:
    6e1c:	81 4c 00 00 	mov	r12,	0(r1)	;

00006e20 <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    6e20:	2c 41       	mov	@r1,	r12	;
    6e22:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6e26:	4d 43       	clr.b	r13		;
    6e28:	b0 12 5e 68 	call	#26718		;#0x685e

00006e2c <.Loc.70.3>:
}
    6e2c:	21 53       	incd	r1		;
    6e2e:	30 41       	ret			

00006e30 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    6e30:	31 80 06 00 	sub	#6,	r1	;

00006e34 <.LCFI7>:
    6e34:	81 4c 04 00 	mov	r12,	4(r1)	;
    6e38:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6e3c:	81 4e 00 00 	mov	r14,	0(r1)	;

00006e40 <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    6e40:	1c 41 04 00 	mov	4(r1),	r12	;
    6e44:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6e48:	2e 41       	mov	@r1,	r14	;
    6e4a:	5d 41 03 00 	mov.b	3(r1),	r13	;
    6e4e:	b0 12 a6 6a 	call	#27302		;#0x6aa6

00006e52 <.Loc.75.3>:
}
    6e52:	31 50 06 00 	add	#6,	r1	;
    6e56:	30 41       	ret			

00006e58 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    6e58:	21 82       	sub	#4,	r1	;r2 As==10

00006e5a <.LCFI8>:
    6e5a:	81 4c 02 00 	mov	r12,	2(r1)	;
    6e5e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006e62 <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    6e62:	1c 41 02 00 	mov	2(r1),	r12	;
    6e66:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6e6a:	2d 41       	mov	@r1,	r13	;
    6e6c:	b0 12 5e 68 	call	#26718		;#0x685e

00006e70 <.Loc.80.3>:
}
    6e70:	21 52       	add	#4,	r1	;r2 As==10
    6e72:	30 41       	ret			

00006e74 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    6e74:	31 82       	sub	#8,	r1	;r2 As==11

00006e76 <.LCFI9>:
    6e76:	81 4c 06 00 	mov	r12,	6(r1)	;
    6e7a:	81 4d 04 00 	mov	r13,	4(r1)	;
    6e7e:	81 4e 02 00 	mov	r14,	2(r1)	;
    6e82:	81 4f 00 00 	mov	r15,	0(r1)	;

00006e86 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    6e86:	1c 41 06 00 	mov	6(r1),	r12	;
    6e8a:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6e8e:	2f 41       	mov	@r1,	r15	;
    6e90:	1e 41 02 00 	mov	2(r1),	r14	;
    6e94:	1d 41 04 00 	mov	4(r1),	r13	;
    6e98:	b0 12 de 6b 	call	#27614		;#0x6bde

00006e9c <.Loc.85.3>:
}
    6e9c:	31 52       	add	#8,	r1	;r2 As==11
    6e9e:	30 41       	ret			

00006ea0 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    6ea0:	31 82       	sub	#8,	r1	;r2 As==11

00006ea2 <.LCFI10>:
    6ea2:	81 4c 06 00 	mov	r12,	6(r1)	;
    6ea6:	81 4d 04 00 	mov	r13,	4(r1)	;
    6eaa:	81 4e 02 00 	mov	r14,	2(r1)	;
    6eae:	81 4f 00 00 	mov	r15,	0(r1)	;

00006eb2 <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    6eb2:	1c 41 06 00 	mov	6(r1),	r12	;
    6eb6:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6eba:	2f 41       	mov	@r1,	r15	;
    6ebc:	1e 41 02 00 	mov	2(r1),	r14	;
    6ec0:	1d 41 04 00 	mov	4(r1),	r13	;
    6ec4:	b0 12 0e 69 	call	#26894		;#0x690e

00006ec8 <.Loc.90.3>:
}
    6ec8:	31 52       	add	#8,	r1	;r2 As==11
    6eca:	30 41       	ret			

00006ecc <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    6ecc:	b0 12 82 76 	call	#30338		;#0x7682

00006ed0 <.Loc.111.3>:
}
    6ed0:	03 43       	nop			
    6ed2:	30 41       	ret			

00006ed4 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    6ed4:	31 82       	sub	#8,	r1	;r2 As==11

00006ed6 <.LCFI11>:
    6ed6:	81 4c 06 00 	mov	r12,	6(r1)	;
    6eda:	81 4d 04 00 	mov	r13,	4(r1)	;
    6ede:	81 4e 02 00 	mov	r14,	2(r1)	;

00006ee2 <.Loc.130.3>:

  sdp->vmt = &vmt;
    6ee2:	1c 41 06 00 	mov	6(r1),	r12	;
    6ee6:	bc 40 00 50 	mov	#20480,	0(r12)	;#0x5000
    6eea:	00 00 

00006eec <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    6eec:	1c 41 06 00 	mov	6(r1),	r12	;
    6ef0:	2c 53       	incd	r12		;
    6ef2:	b0 12 2e 6d 	call	#27950		;#0x6d2e

00006ef6 <.Loc.132.3>:
  sdp->state = SD_STOP;
    6ef6:	1c 41 06 00 	mov	6(r1),	r12	;
    6efa:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

00006efe <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    6efe:	1c 41 06 00 	mov	6(r1),	r12	;
    6f02:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6f06:	1d 41 06 00 	mov	6(r1),	r13	;
    6f0a:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    6f0e:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6f12:	00 00 
    6f14:	1f 41 04 00 	mov	4(r1),	r15	;
    6f18:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6f1c:	b0 12 56 67 	call	#26454		;#0x6756

00006f20 <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    6f20:	1c 41 06 00 	mov	6(r1),	r12	;
    6f24:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6f28:	1d 41 06 00 	mov	6(r1),	r13	;
    6f2c:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    6f30:	91 41 06 00 	mov	6(r1),	0(r1)	;
    6f34:	00 00 
    6f36:	1f 41 02 00 	mov	2(r1),	r15	;
    6f3a:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6f3e:	b0 12 3c 6a 	call	#27196		;#0x6a3c

00006f42 <.Loc.135.3>:
}
    6f42:	03 43       	nop			
    6f44:	31 52       	add	#8,	r1	;r2 As==11
    6f46:	30 41       	ret			

00006f48 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    6f48:	21 82       	sub	#4,	r1	;r2 As==10

00006f4a <.LCFI12>:
    6f4a:	81 4c 02 00 	mov	r12,	2(r1)	;
    6f4e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006f52 <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    6f52:	b0 12 1e 6d 	call	#27934		;#0x6d1e

00006f56 <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    6f56:	2d 41       	mov	@r1,	r13	;
    6f58:	1c 41 02 00 	mov	2(r1),	r12	;
    6f5c:	b0 12 94 76 	call	#30356		;#0x7694

00006f60 <.Loc.155.3>:
  sdp->state = SD_READY;
    6f60:	1c 41 02 00 	mov	2(r1),	r12	;
    6f64:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00006f68 <.Loc.156.3>:
  osalSysUnlock();
    6f68:	b0 12 26 6d 	call	#27942		;#0x6d26

00006f6c <.Loc.157.3>:
}
    6f6c:	03 43       	nop			
    6f6e:	21 52       	add	#4,	r1	;r2 As==10
    6f70:	30 41       	ret			

00006f72 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    6f72:	21 82       	sub	#4,	r1	;r2 As==10

00006f74 <.LCFI14>:
    6f74:	81 4c 02 00 	mov	r12,	2(r1)	;
    6f78:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00006f7c <.Loc.207.3>:

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    6f7c:	1c 41 02 00 	mov	2(r1),	r12	;
    6f80:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    6f84:	0c 93       	cmp	#0,	r12	;r3 As==00
    6f86:	07 20       	jnz	$+16     	;abs 0x6f96

00006f88 <.Loc.208.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    6f88:	1c 41 02 00 	mov	2(r1),	r12	;
    6f8c:	2c 53       	incd	r12		;
    6f8e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    6f90:	4e 43       	clr.b	r14		;
    6f92:	b0 12 50 6d 	call	#27984		;#0x6d50

00006f96 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    6f96:	1c 41 02 00 	mov	2(r1),	r12	;
    6f9a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6f9e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    6fa2:	b0 12 be 67 	call	#26558		;#0x67be
    6fa6:	0c 93       	cmp	#0,	r12	;r3 As==00
    6fa8:	08 34       	jge	$+18     	;abs 0x6fba

00006faa <.Loc.210.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    6faa:	1c 41 02 00 	mov	2(r1),	r12	;
    6fae:	2c 53       	incd	r12		;
    6fb0:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    6fb4:	4e 43       	clr.b	r14		;
    6fb6:	b0 12 50 6d 	call	#27984		;#0x6d50

00006fba <.L33>:
}
    6fba:	03 43       	nop			
    6fbc:	21 52       	add	#4,	r1	;r2 As==10
    6fbe:	30 41       	ret			

00006fc0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    6fc0:	21 82       	sub	#4,	r1	;r2 As==10

00006fc2 <.LCFI15>:
    6fc2:	81 4c 00 00 	mov	r12,	0(r1)	;

00006fc6 <.Loc.234.3>:
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    6fc6:	2c 41       	mov	@r1,	r12	;
    6fc8:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6fcc:	b0 12 5a 6b 	call	#27482		;#0x6b5a
    6fd0:	81 4c 02 00 	mov	r12,	2(r1)	;

00006fd4 <.Loc.235.3>:
  if (b < MSG_OK)
    6fd4:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6fd8:	06 34       	jge	$+14     	;abs 0x6fe6

00006fda <.Loc.236.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    6fda:	2c 41       	mov	@r1,	r12	;
    6fdc:	2c 53       	incd	r12		;
    6fde:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6fe0:	4e 43       	clr.b	r14		;
    6fe2:	b0 12 50 6d 	call	#27984		;#0x6d50

00006fe6 <.L35>:
  return b;
    6fe6:	1c 41 02 00 	mov	2(r1),	r12	;

00006fea <.Loc.238.3>:
}
    6fea:	21 52       	add	#4,	r1	;r2 As==10
    6fec:	30 41       	ret			

00006fee <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6fee:	32 c2       	dint			

00006ff0 <.Loc.348.1>:
  asm volatile("nop");
    6ff0:	03 43       	nop			

00006ff2 <.Loc.349.1>:
}
    6ff2:	03 43       	nop			
    6ff4:	30 41       	ret			

00006ff6 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6ff6:	03 43       	nop			

00006ff8 <.Loc.356.1>:
  _enable_interrupts();
    6ff8:	32 d2       	eint			
    6ffa:	03 43       	nop			

00006ffc <.Loc.357.1>:
}
    6ffc:	03 43       	nop			
    6ffe:	30 41       	ret			

00007000 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    7000:	b0 12 ee 6f 	call	#28654		;#0x6fee

00007004 <.Loc.505.2>:
}
    7004:	03 43       	nop			
    7006:	30 41       	ret			

00007008 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    7008:	b0 12 f6 6f 	call	#28662		;#0x6ff6

0000700c <.Loc.516.2>:
}
    700c:	03 43       	nop			
    700e:	30 41       	ret			

00007010 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    7010:	21 83       	decd	r1		;

00007012 <.LCFI1>:
    7012:	81 4c 00 00 	mov	r12,	0(r1)	;

00007016 <.Loc.885.2>:

  chSemObjectInit((semaphore_t *)mp, (cnt_t)1);
    7016:	2c 41       	mov	@r1,	r12	;
    7018:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

0000701c <.Loc.886.2>:
}
    701c:	03 43       	nop			
    701e:	21 53       	incd	r1		;
    7020:	30 41       	ret			

00007022 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    7022:	b0 12 00 7f 	call	#32512		;#0x7f00

00007026 <.Loc.59.3>:
}
    7026:	03 43       	nop			
    7028:	30 41       	ret			

0000702a <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    702a:	21 83       	decd	r1		;

0000702c <.LCFI4>:
    702c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007030 <.Loc.70.3>:

  spip->state = SPI_STOP;
    7030:	2c 41       	mov	@r1,	r12	;
    7032:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00007036 <.Loc.71.3>:
  spip->config = NULL;
    7036:	2c 41       	mov	@r1,	r12	;
    7038:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

0000703c <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    703c:	2c 41       	mov	@r1,	r12	;
    703e:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00007042 <.Loc.76.3>:
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
    7042:	2c 41       	mov	@r1,	r12	;
    7044:	3c 50 06 00 	add	#6,	r12	;
    7048:	b0 12 10 70 	call	#28688		;#0x7010

0000704c <.Loc.81.3>:
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    704c:	03 43       	nop			
    704e:	21 53       	incd	r1		;
    7050:	30 41       	ret			

00007052 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    7052:	21 82       	sub	#4,	r1	;r2 As==10

00007054 <.LCFI5>:
    7054:	81 4c 02 00 	mov	r12,	2(r1)	;
    7058:	81 4d 00 00 	mov	r13,	0(r1)	;

0000705c <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    705c:	b0 12 00 70 	call	#28672		;#0x7000

00007060 <.Loc.98.3>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    7060:	1c 41 02 00 	mov	2(r1),	r12	;
    7064:	ac 41 02 00 	mov	@r1,	2(r12)	;

00007068 <.Loc.99.3>:
  spi_lld_start(spip);
    7068:	1c 41 02 00 	mov	2(r1),	r12	;
    706c:	b0 12 64 7f 	call	#32612		;#0x7f64

00007070 <.Loc.100.3>:
  spip->state = SPI_READY;
    7070:	1c 41 02 00 	mov	2(r1),	r12	;
    7074:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007078 <.Loc.101.3>:
  osalSysUnlock();
    7078:	b0 12 08 70 	call	#28680		;#0x7008

0000707c <.Loc.102.3>:
}
    707c:	03 43       	nop			
    707e:	21 52       	add	#4,	r1	;r2 As==10
    7080:	30 41       	ret			

00007082 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
    7082:	21 83       	decd	r1		;

00007084 <.LCFI7>:
    7084:	81 4c 00 00 	mov	r12,	0(r1)	;

00007088 <.Loc.140.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    7088:	b0 12 00 70 	call	#28672		;#0x7000

0000708c <.Loc.142.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
    708c:	2c 41       	mov	@r1,	r12	;
    708e:	b0 12 3e 80 	call	#32830		;#0x803e

00007092 <.Loc.143.3>:
  osalSysUnlock();
    7092:	b0 12 08 70 	call	#28680		;#0x7008

00007096 <.Loc.144.3>:
}
    7096:	03 43       	nop			
    7098:	21 53       	incd	r1		;
    709a:	30 41       	ret			

0000709c <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
    709c:	21 83       	decd	r1		;

0000709e <.LCFI8>:
    709e:	81 4c 00 00 	mov	r12,	0(r1)	;

000070a2 <.Loc.158.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    70a2:	b0 12 00 70 	call	#28672		;#0x7000

000070a6 <.Loc.160.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
    70a6:	2c 41       	mov	@r1,	r12	;
    70a8:	b0 12 9e 80 	call	#32926		;#0x809e

000070ac <.Loc.161.3>:
  osalSysUnlock();
    70ac:	b0 12 08 70 	call	#28680		;#0x7008

000070b0 <.Loc.162.3>:
}
    70b0:	03 43       	nop			
    70b2:	21 53       	incd	r1		;
    70b4:	30 41       	ret			

000070b6 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    70b6:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    70ba:	5c 01 

000070bc <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    70bc:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    70c0:	60 01 

000070c2 <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    70c2:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    70c6:	62 01 

000070c8 <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    70c8:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    70cc:	64 01 

000070ce <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    70ce:	b2 40 50 00 	mov	#80,	&0x0166	;#0x0050
    70d2:	66 01 

000070d4 <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    70d4:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    70d8:	68 01 

000070da <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    70da:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    70de:	6c 01 

000070e0 <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    70e0:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

000070e4 <.Loc.87.1>:
  
#if (HAL_USE_DMA == TRUE)
  dmaInit();
    70e4:	b0 12 5c 7e 	call	#32348		;#0x7e5c

000070e8 <.Loc.89.1>:
#endif
}
    70e8:	03 43       	nop			
    70ea:	30 41       	ret			

000070ec <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    70ec:	03 43       	nop			
    70ee:	30 41       	ret			

000070f0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    70f0:	03 43       	nop			
    70f2:	30 41       	ret			

000070f4 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    70f4:	b0 12 ec 70 	call	#28908		;#0x70ec

000070f8 <.Loc.527.2>:
}
    70f8:	03 43       	nop			
    70fa:	30 41       	ret			

000070fc <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    70fc:	b0 12 f0 70 	call	#28912		;#0x70f0

00007100 <.Loc.538.2>:
}
    7100:	03 43       	nop			
    7102:	30 41       	ret			

00007104 <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    7104:	b0 12 62 63 	call	#25442		;#0x6362

00007108 <.Loc.597.2>:
}
    7108:	03 43       	nop			
    710a:	30 41       	ret			

0000710c <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    710c:	bf 15       	pushm	#12,	r15	;16-bit words

0000710e <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    710e:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

00007112 <.Loc.170.3>:
  
  osalSysLockFromISR();
    7112:	b0 12 f4 70 	call	#28916		;#0x70f4

00007116 <.Loc.171.3>:
  osalOsTimerHandlerI();
    7116:	b0 12 04 71 	call	#28932		;#0x7104

0000711a <.Loc.172.3>:
  osalSysUnlockFromISR();
    711a:	b0 12 fc 70 	call	#28924		;#0x70fc

0000711e <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    711e:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    7122:	b0 12 1e 64 	call	#25630		;#0x641e
    7126:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    712a:	0c 93       	cmp	#0,	r12	;r3 As==00
    712c:	02 24       	jz	$+6      	;abs 0x7132

0000712e <.Loc.174.3>:
    712e:	b0 12 3a 64 	call	#25658		;#0x643a

00007132 <.L8>:
}
    7132:	03 43       	nop			
    7134:	b4 17       	popm	#12,	r15	;16-bit words
    7136:	00 13       	reti			

00007138 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    7138:	b2 40 f9 00 	mov	#249,	&0x03d2	;#0x00f9
    713c:	d2 03 

0000713e <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    713e:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    7142:	c2 03 

00007144 <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    7144:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00007148 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    7148:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    714c:	c0 03 

0000714e <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    714e:	03 43       	nop			
    7150:	30 41       	ret			

00007152 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7152:	03 43       	nop			
    7154:	30 41       	ret			

00007156 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7156:	03 43       	nop			
    7158:	30 41       	ret			

0000715a <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    715a:	b0 12 52 71 	call	#29010		;#0x7152

0000715e <.Loc.527.2>:
}
    715e:	03 43       	nop			
    7160:	30 41       	ret			

00007162 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7162:	b0 12 56 71 	call	#29014		;#0x7156

00007166 <.Loc.538.2>:
}
    7166:	03 43       	nop			
    7168:	30 41       	ret			

0000716a <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    716a:	0a 15       	pushm	#1,	r10	;16-bit words

0000716c <.LCFI0>:
    716c:	31 80 06 00 	sub	#6,	r1	;

00007170 <.LCFI1>:
    7170:	81 4c 04 00 	mov	r12,	4(r1)	;
    7174:	81 4d 00 00 	mov	r13,	0(r1)	;
    7178:	81 4e 02 00 	mov	r14,	2(r1)	;

0000717c <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    717c:	1c 41 04 00 	mov	4(r1),	r12	;
    7180:	1d 4c 02 00 	mov	2(r12),	r13	;
    7184:	2c 4c       	mov	@r12,	r12	;
    7186:	2a 41       	mov	@r1,	r10	;
    7188:	0a dc       	bis	r12,	r10	;
    718a:	1b 41 02 00 	mov	2(r1),	r11	;
    718e:	0b dd       	bis	r13,	r11	;
    7190:	1c 41 04 00 	mov	4(r1),	r12	;
    7194:	8c 4a 00 00 	mov	r10,	0(r12)	;
    7198:	8c 4b 02 00 	mov	r11,	2(r12)	;

0000719c <.Loc.829.2>:
  if (esp->cb != NULL) {
    719c:	1c 41 04 00 	mov	4(r1),	r12	;
    71a0:	1c 4c 04 00 	mov	4(r12),	r12	;
    71a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    71a6:	07 24       	jz	$+16     	;abs 0x71b6

000071a8 <.Loc.830.2>:
    esp->cb(esp);
    71a8:	1c 41 04 00 	mov	4(r1),	r12	;
    71ac:	1d 4c 04 00 	mov	4(r12),	r13	;
    71b0:	1c 41 04 00 	mov	4(r1),	r12	;
    71b4:	8d 12       	call	r13		;

000071b6 <.L7>:
  }
}
    71b6:	03 43       	nop			
    71b8:	31 50 06 00 	add	#6,	r1	;
    71bc:	0a 17       	popm	#1,	r10	;16-bit words
    71be:	30 41       	ret			

000071c0 <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    71c0:	21 83       	decd	r1		;

000071c2 <.LCFI2>:
    71c2:	81 4c 00 00 	mov	r12,	0(r1)	;

000071c6 <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    71c6:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    71ca:	2c 91       	cmp	@r1,	r12	;
    71cc:	02 28       	jnc	$+6      	;abs 0x71d2

000071ce <.Loc.108.3>:
    return 0x00;
    71ce:	4c 43       	clr.b	r12		;
    71d0:	ec 3c       	jmp	$+474    	;abs 0x73aa

000071d2 <.L9>:
  else if (frac < 715)
    71d2:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    71d6:	2c 91       	cmp	@r1,	r12	;
    71d8:	02 28       	jnc	$+6      	;abs 0x71de

000071da <.Loc.110.3>:
    return 0x01;
    71da:	5c 43       	mov.b	#1,	r12	;r3 As==01
    71dc:	e6 3c       	jmp	$+462    	;abs 0x73aa

000071de <.L11>:
  else if (frac < 835)
    71de:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    71e2:	2c 91       	cmp	@r1,	r12	;
    71e4:	02 28       	jnc	$+6      	;abs 0x71ea

000071e6 <.Loc.112.3>:
    return 0x02;
    71e6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    71e8:	e0 3c       	jmp	$+450    	;abs 0x73aa

000071ea <.L12>:
  else if (frac < 1001)
    71ea:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    71ee:	2c 91       	cmp	@r1,	r12	;
    71f0:	02 28       	jnc	$+6      	;abs 0x71f6

000071f2 <.Loc.114.3>:
    return 0x04;
    71f2:	6c 42       	mov.b	#4,	r12	;r2 As==10
    71f4:	da 3c       	jmp	$+438    	;abs 0x73aa

000071f6 <.L13>:
  else if (frac < 1252)
    71f6:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    71fa:	2c 91       	cmp	@r1,	r12	;
    71fc:	02 28       	jnc	$+6      	;abs 0x7202

000071fe <.Loc.116.3>:
    return 0x08;
    71fe:	7c 42       	mov.b	#8,	r12	;r2 As==11
    7200:	d4 3c       	jmp	$+426    	;abs 0x73aa

00007202 <.L14>:
  else if (frac < 1430)
    7202:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    7206:	2c 91       	cmp	@r1,	r12	;
    7208:	03 28       	jnc	$+8      	;abs 0x7210

0000720a <.Loc.118.3>:
    return 0x10;
    720a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    720e:	cd 3c       	jmp	$+412    	;abs 0x73aa

00007210 <.L15>:
  else if (frac < 1670)
    7210:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    7214:	2c 91       	cmp	@r1,	r12	;
    7216:	03 28       	jnc	$+8      	;abs 0x721e

00007218 <.Loc.120.3>:
    return 0x20;
    7218:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    721c:	c6 3c       	jmp	$+398    	;abs 0x73aa

0000721e <.L16>:
  else if (frac < 2147)
    721e:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    7222:	2c 91       	cmp	@r1,	r12	;
    7224:	03 28       	jnc	$+8      	;abs 0x722c

00007226 <.Loc.122.3>:
    return 0x11;
    7226:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    722a:	bf 3c       	jmp	$+384    	;abs 0x73aa

0000722c <.L17>:
  else if (frac < 2224)
    722c:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    7230:	2c 91       	cmp	@r1,	r12	;
    7232:	03 28       	jnc	$+8      	;abs 0x723a

00007234 <.Loc.124.3>:
    return 0x21;
    7234:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    7238:	b8 3c       	jmp	$+370    	;abs 0x73aa

0000723a <.L18>:
  else if (frac < 2503)
    723a:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    723e:	2c 91       	cmp	@r1,	r12	;
    7240:	03 28       	jnc	$+8      	;abs 0x7248

00007242 <.Loc.126.3>:
    return 0x22;
    7242:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    7246:	b1 3c       	jmp	$+356    	;abs 0x73aa

00007248 <.L19>:
  else if (frac < 3000)
    7248:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    724c:	2c 91       	cmp	@r1,	r12	;
    724e:	03 28       	jnc	$+8      	;abs 0x7256

00007250 <.Loc.128.3>:
    return 0x44;
    7250:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    7254:	aa 3c       	jmp	$+342    	;abs 0x73aa

00007256 <.L20>:
  else if (frac < 3335)
    7256:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    725a:	2c 91       	cmp	@r1,	r12	;
    725c:	03 28       	jnc	$+8      	;abs 0x7264

0000725e <.Loc.130.3>:
    return 0x25;
    725e:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    7262:	a3 3c       	jmp	$+328    	;abs 0x73aa

00007264 <.L21>:
  else if (frac < 3575)
    7264:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    7268:	2c 91       	cmp	@r1,	r12	;
    726a:	03 28       	jnc	$+8      	;abs 0x7272

0000726c <.Loc.132.3>:
    return 0x49;
    726c:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    7270:	9c 3c       	jmp	$+314    	;abs 0x73aa

00007272 <.L22>:
  else if (frac < 3753)
    7272:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    7276:	2c 91       	cmp	@r1,	r12	;
    7278:	03 28       	jnc	$+8      	;abs 0x7280

0000727a <.Loc.134.3>:
    return 0x4A;
    727a:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    727e:	95 3c       	jmp	$+300    	;abs 0x73aa

00007280 <.L23>:
  else if (frac < 4003)
    7280:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    7284:	2c 91       	cmp	@r1,	r12	;
    7286:	03 28       	jnc	$+8      	;abs 0x728e

00007288 <.Loc.136.3>:
    return 0x52;
    7288:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    728c:	8e 3c       	jmp	$+286    	;abs 0x73aa

0000728e <.L24>:
  else if (frac < 4286)
    728e:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    7292:	2c 91       	cmp	@r1,	r12	;
    7294:	03 28       	jnc	$+8      	;abs 0x729c

00007296 <.Loc.138.3>:
    return 0x92;
    7296:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    729a:	87 3c       	jmp	$+272    	;abs 0x73aa

0000729c <.L25>:
  else if (frac < 4378)
    729c:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    72a0:	2c 91       	cmp	@r1,	r12	;
    72a2:	03 28       	jnc	$+8      	;abs 0x72aa

000072a4 <.Loc.140.3>:
    return 0x53;
    72a4:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    72a8:	80 3c       	jmp	$+258    	;abs 0x73aa

000072aa <.L26>:
  else if (frac < 5002)
    72aa:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    72ae:	2c 91       	cmp	@r1,	r12	;
    72b0:	03 28       	jnc	$+8      	;abs 0x72b8

000072b2 <.Loc.142.3>:
    return 0x55;
    72b2:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    72b6:	79 3c       	jmp	$+244    	;abs 0x73aa

000072b8 <.L27>:
  else if (frac < 5715)
    72b8:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    72bc:	2c 91       	cmp	@r1,	r12	;
    72be:	03 28       	jnc	$+8      	;abs 0x72c6

000072c0 <.Loc.144.3>:
    return 0xAA;
    72c0:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    72c4:	72 3c       	jmp	$+230    	;abs 0x73aa

000072c6 <.L28>:
  else if (frac < 6003)
    72c6:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    72ca:	2c 91       	cmp	@r1,	r12	;
    72cc:	03 28       	jnc	$+8      	;abs 0x72d4

000072ce <.Loc.146.3>:
    return 0x6B;
    72ce:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    72d2:	6b 3c       	jmp	$+216    	;abs 0x73aa

000072d4 <.L29>:
  else if (frac < 6254)
    72d4:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    72d8:	2c 91       	cmp	@r1,	r12	;
    72da:	03 28       	jnc	$+8      	;abs 0x72e2

000072dc <.Loc.148.3>:
    return 0xAD;
    72dc:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    72e0:	64 3c       	jmp	$+202    	;abs 0x73aa

000072e2 <.L30>:
  else if (frac < 6432)
    72e2:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    72e6:	2c 91       	cmp	@r1,	r12	;
    72e8:	03 28       	jnc	$+8      	;abs 0x72f0

000072ea <.Loc.150.3>:
    return 0xB5;
    72ea:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    72ee:	5d 3c       	jmp	$+188    	;abs 0x73aa

000072f0 <.L31>:
  else if (frac < 6667)
    72f0:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    72f4:	2c 91       	cmp	@r1,	r12	;
    72f6:	03 28       	jnc	$+8      	;abs 0x72fe

000072f8 <.Loc.152.3>:
    return 0xB6;
    72f8:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    72fc:	56 3c       	jmp	$+174    	;abs 0x73aa

000072fe <.L32>:
  else if (frac < 7001)
    72fe:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    7302:	2c 91       	cmp	@r1,	r12	;
    7304:	03 28       	jnc	$+8      	;abs 0x730c

00007306 <.Loc.154.3>:
    return 0xD6;
    7306:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    730a:	4f 3c       	jmp	$+160    	;abs 0x73aa

0000730c <.L33>:
  else if (frac < 7147)
    730c:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    7310:	2c 91       	cmp	@r1,	r12	;
    7312:	03 28       	jnc	$+8      	;abs 0x731a

00007314 <.Loc.156.3>:
    return 0xB7;
    7314:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    7318:	48 3c       	jmp	$+146    	;abs 0x73aa

0000731a <.L34>:
  else if (frac < 7503)
    731a:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    731e:	2c 91       	cmp	@r1,	r12	;
    7320:	03 28       	jnc	$+8      	;abs 0x7328

00007322 <.Loc.158.3>:
    return 0xBB;
    7322:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    7326:	41 3c       	jmp	$+132    	;abs 0x73aa

00007328 <.L35>:
  else if (frac < 7861)
    7328:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    732c:	2c 91       	cmp	@r1,	r12	;
    732e:	03 28       	jnc	$+8      	;abs 0x7336

00007330 <.Loc.160.3>:
    return 0xDD;
    7330:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    7334:	3a 3c       	jmp	$+118    	;abs 0x73aa

00007336 <.L36>:
  else if (frac < 8004)
    7336:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    733a:	2c 91       	cmp	@r1,	r12	;
    733c:	03 28       	jnc	$+8      	;abs 0x7344

0000733e <.Loc.162.3>:
    return 0xED;
    733e:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    7342:	33 3c       	jmp	$+104    	;abs 0x73aa

00007344 <.L37>:
  else if (frac < 8333)
    7344:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    7348:	2c 91       	cmp	@r1,	r12	;
    734a:	03 28       	jnc	$+8      	;abs 0x7352

0000734c <.Loc.164.3>:
    return 0xEE;
    734c:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    7350:	2c 3c       	jmp	$+90     	;abs 0x73aa

00007352 <.L38>:
  else if (frac < 8464)
    7352:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    7356:	2c 91       	cmp	@r1,	r12	;
    7358:	03 28       	jnc	$+8      	;abs 0x7360

0000735a <.Loc.166.3>:
    return 0xBF;
    735a:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    735e:	25 3c       	jmp	$+76     	;abs 0x73aa

00007360 <.L39>:
  else if (frac < 8572)
    7360:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    7364:	2c 91       	cmp	@r1,	r12	;
    7366:	03 28       	jnc	$+8      	;abs 0x736e

00007368 <.Loc.168.3>:
    return 0xDF;
    7368:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    736c:	1e 3c       	jmp	$+62     	;abs 0x73aa

0000736e <.L40>:
  else if (frac < 8751)
    736e:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    7372:	2c 91       	cmp	@r1,	r12	;
    7374:	03 28       	jnc	$+8      	;abs 0x737c

00007376 <.Loc.170.3>:
    return 0xEF;
    7376:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    737a:	17 3c       	jmp	$+48     	;abs 0x73aa

0000737c <.L41>:
  else if (frac < 9004)
    737c:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    7380:	2c 91       	cmp	@r1,	r12	;
    7382:	03 28       	jnc	$+8      	;abs 0x738a

00007384 <.Loc.172.3>:
    return 0xF7;
    7384:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    7388:	10 3c       	jmp	$+34     	;abs 0x73aa

0000738a <.L42>:
  else if (frac < 9170)
    738a:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    738e:	2c 91       	cmp	@r1,	r12	;
    7390:	03 28       	jnc	$+8      	;abs 0x7398

00007392 <.Loc.174.3>:
    return 0xFB;
    7392:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    7396:	09 3c       	jmp	$+20     	;abs 0x73aa

00007398 <.L43>:
  else if (frac < 9288)
    7398:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    739c:	2c 91       	cmp	@r1,	r12	;
    739e:	03 28       	jnc	$+8      	;abs 0x73a6

000073a0 <.Loc.176.3>:
    return 0xFD;
    73a0:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    73a4:	02 3c       	jmp	$+6      	;abs 0x73aa

000073a6 <.L44>:
  else
    return 0xFE;
    73a6:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

000073aa <.L10>:
}
    73aa:	21 53       	incd	r1		;
    73ac:	30 41       	ret			

000073ae <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    73ae:	0a 15       	pushm	#1,	r10	;16-bit words

000073b0 <.LCFI3>:
    73b0:	31 80 0c 00 	sub	#12,	r1	;#0x000c

000073b4 <.LCFI4>:
    73b4:	81 4c 04 00 	mov	r12,	4(r1)	;
    73b8:	81 4d 06 00 	mov	r13,	6(r1)	;
    73bc:	81 4e 00 00 	mov	r14,	0(r1)	;
    73c0:	81 4f 02 00 	mov	r15,	2(r1)	;

000073c4 <.Loc.191.3>:

  uint16_t n = freq / baud;
    73c4:	1e 41 04 00 	mov	4(r1),	r14	;
    73c8:	1f 41 06 00 	mov	6(r1),	r15	;
    73cc:	2c 41       	mov	@r1,	r12	;
    73ce:	1d 41 02 00 	mov	2(r1),	r13	;
    73d2:	b0 12 fe 91 	call	#37374		;#0x91fe
    73d6:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

000073da <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    73da:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    73de:	0c 4e       	mov	r14,	r12	;
    73e0:	0d 43       	clr	r13		;
    73e2:	1e 41 04 00 	mov	4(r1),	r14	;
    73e6:	1f 41 06 00 	mov	6(r1),	r15	;
    73ea:	b0 12 48 93 	call	#37704		;#0x9348
    73ee:	0e 4c       	mov	r12,	r14	;
    73f0:	0f 4d       	mov	r13,	r15	;
    73f2:	2c 41       	mov	@r1,	r12	;

000073f4 <L0>:
    73f4:	1d 41 02 00 	mov	2(r1),	r13	;
    73f8:	0c 8e       	sub	r14,	r12	;
    73fa:	0d 7f       	subc	r15,	r13	;
    73fc:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    7400:	4f 43       	clr.b	r15		;
    7402:	b0 12 48 93 	call	#37704		;#0x9348
    7406:	1e 41 04 00 	mov	4(r1),	r14	;
    740a:	1f 41 06 00 	mov	6(r1),	r15	;
    740e:	b0 12 fe 91 	call	#37374		;#0x91fe
    7412:	81 4c 08 00 	mov	r12,	8(r1)	;

00007416 <.Loc.194.3>:
  if (n > 16) {
    7416:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    741a:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    741e:	19 2c       	jc	$+52     	;abs 0x7452

00007420 <.Loc.195.3>:
    while (n > 16) {
    7420:	03 3c       	jmp	$+8      	;abs 0x7428

00007422 <.L48>:
      n -= 16;
    7422:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    7426:	0a 00 

00007428 <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    7428:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    742c:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    7430:	f8 2b       	jnc	$-14     	;abs 0x7422

00007432 <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    7432:	1c 41 08 00 	mov	8(r1),	r12	;
    7436:	b0 12 c0 71 	call	#29120		;#0x71c0
    743a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    743e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    7442:	0a 4c       	mov	r12,	r10	;
    7444:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    7448:	b0 12 22 92 	call	#37410		;#0x9222
    744c:	0c da       	bis	r10,	r12	;
    744e:	1c d3       	bis	#1,	r12	;r3 As==01
    7450:	08 3c       	jmp	$+18     	;abs 0x7462

00007452 <.L46>:
  }
  return UCBRS(frac) << 8;
    7452:	1c 41 08 00 	mov	8(r1),	r12	;
    7456:	b0 12 c0 71 	call	#29120		;#0x71c0
    745a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    745e:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

00007462 <.L49>:
}
    7462:	31 50 0c 00 	add	#12,	r1	;#0x000c
    7466:	0a 17       	popm	#1,	r10	;16-bit words
    7468:	30 41       	ret			

0000746a <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    746a:	31 80 0a 00 	sub	#10,	r1	;#0x000a

0000746e <L0>:
    746e:	81 4c 04 00 	mov	r12,	4(r1)	;
    7472:	81 4d 06 00 	mov	r13,	6(r1)	;
    7476:	81 4e 00 00 	mov	r14,	0(r1)	;
    747a:	81 4f 02 00 	mov	r15,	2(r1)	;

0000747e <.Loc.212.3>:
  uint16_t n = freq / baud;
    747e:	1e 41 04 00 	mov	4(r1),	r14	;
    7482:	1f 41 06 00 	mov	6(r1),	r15	;
    7486:	2c 41       	mov	@r1,	r12	;
    7488:	1d 41 02 00 	mov	2(r1),	r13	;
    748c:	b0 12 fe 91 	call	#37374		;#0x91fe
    7490:	81 4c 08 00 	mov	r12,	8(r1)	;

00007494 <.Loc.213.3>:
  if (n > 16) {
    7494:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    7498:	1c 91 08 00 	cmp	8(r1),	r12	;
    749c:	05 2c       	jc	$+12     	;abs 0x74a8

0000749e <.Loc.214.3>:
    return n >> 4;
    749e:	1c 41 08 00 	mov	8(r1),	r12	;
    74a2:	b0 12 ac 92 	call	#37548		;#0x92ac
    74a6:	02 3c       	jmp	$+6      	;abs 0x74ac

000074a8 <.L51>:
  }
  return n;
    74a8:	1c 41 08 00 	mov	8(r1),	r12	;

000074ac <.L52>:
}
    74ac:	31 50 0a 00 	add	#10,	r1	;#0x000a
    74b0:	30 41       	ret			

000074b2 <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    74b2:	21 83       	decd	r1		;

000074b4 <L0>:
    74b4:	81 4c 00 00 	mov	r12,	0(r1)	;

000074b8 <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    74b8:	2c 41       	mov	@r1,	r12	;
    74ba:	1d 4c 02 00 	mov	2(r12),	r13	;
    74be:	2c 4c       	mov	@r12,	r12	;
    74c0:	3e 40 90 d0 	mov	#53392,	r14	;#0xd090
    74c4:	7f 40 03 00 	mov.b	#3,	r15	;
    74c8:	b0 12 6a 74 	call	#29802		;#0x746a
    74cc:	82 4c c6 05 	mov	r12,	&0x05c6	;

000074d0 <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    74d0:	2c 41       	mov	@r1,	r12	;
    74d2:	1d 4c 02 00 	mov	2(r12),	r13	;
    74d6:	2c 4c       	mov	@r12,	r12	;
    74d8:	3e 40 90 d0 	mov	#53392,	r14	;#0xd090
    74dc:	7f 40 03 00 	mov.b	#3,	r15	;
    74e0:	b0 12 ae 73 	call	#29614		;#0x73ae
    74e4:	82 4c c8 05 	mov	r12,	&0x05c8	;

000074e8 <.Loc.223.3>:
  UCA0STATW = 0;
    74e8:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

000074ec <.Loc.224.3>:
  UCA0ABCTL = 0;
    74ec:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

000074f0 <.Loc.225.3>:
  UCA0IRCTL = 0;
    74f0:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

000074f4 <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    74f4:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    74f8:	c0 05 

000074fa <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    74fa:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

000074fe <.Loc.230.3>:
}
    74fe:	03 43       	nop			
    7500:	21 53       	incd	r1		;
    7502:	30 41       	ret			

00007504 <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    7504:	21 83       	decd	r1		;

00007506 <.LCFI7>:
    7506:	81 4c 00 00 	mov	r12,	0(r1)	;

0000750a <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    750a:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    750e:	2c d3       	bis	#2,	r12	;r3 As==10
    7510:	82 4c da 05 	mov	r12,	&0x05da	;

00007514 <.Loc.280.3>:
}
    7514:	03 43       	nop			
    7516:	21 53       	incd	r1		;
    7518:	30 41       	ret			

0000751a <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    751a:	31 82       	sub	#8,	r1	;r2 As==11

0000751c <.LCFI8>:
    751c:	81 4c 02 00 	mov	r12,	2(r1)	;
    7520:	81 4d 00 00 	mov	r13,	0(r1)	;

00007524 <.Loc.314.3>:
  eventflags_t sts = 0;
    7524:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    7528:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

0000752c <.Loc.316.3>:

  if (sra & UCOE)
    752c:	1c 41 02 00 	mov	2(r1),	r12	;
    7530:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    7534:	0c 93       	cmp	#0,	r12	;r3 As==00
    7536:	05 24       	jz	$+12     	;abs 0x7542

00007538 <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    7538:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    753c:	04 00 
    753e:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007542 <.L56>:
  if (sra & UCPE)
    7542:	1c 41 02 00 	mov	2(r1),	r12	;
    7546:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    754a:	0c 93       	cmp	#0,	r12	;r3 As==00
    754c:	05 24       	jz	$+12     	;abs 0x7558

0000754e <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    754e:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    7552:	04 00 
    7554:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007558 <.L57>:
  if (sra & UCFE)
    7558:	1c 41 02 00 	mov	2(r1),	r12	;
    755c:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    7560:	0c 93       	cmp	#0,	r12	;r3 As==00
    7562:	05 24       	jz	$+12     	;abs 0x756e

00007564 <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    7564:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    7568:	04 00 
    756a:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

0000756e <.L58>:
  osalSysLockFromISR();
    756e:	b0 12 5a 71 	call	#29018		;#0x715a

00007572 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    7572:	2c 41       	mov	@r1,	r12	;
    7574:	2c 53       	incd	r12		;
    7576:	1d 41 04 00 	mov	4(r1),	r13	;
    757a:	1e 41 06 00 	mov	6(r1),	r14	;
    757e:	b0 12 6a 71 	call	#29034		;#0x716a

00007582 <.Loc.324.3>:
  osalSysUnlockFromISR();
    7582:	b0 12 62 71 	call	#29026		;#0x7162

00007586 <.Loc.325.3>:
}
    7586:	03 43       	nop			
    7588:	31 52       	add	#8,	r1	;r2 As==11
    758a:	30 41       	ret			

0000758c <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    758c:	bf 15       	pushm	#12,	r15	;16-bit words

0000758e <.LCFI9>:
    758e:	21 83       	decd	r1		;

00007590 <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    7590:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

00007594 <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    7594:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    7598:	2c 92       	cmp	#4,	r12	;r2 As==10
    759a:	1e 24       	jz	$+62     	;abs 0x75d8
    759c:	3c 92       	cmp	#8,	r12	;r2 As==11
    759e:	40 24       	jz	$+130    	;abs 0x7620
    75a0:	2c 93       	cmp	#2,	r12	;r3 As==10
    75a2:	01 24       	jz	$+4      	;abs 0x75a6

000075a4 <.Loc.382.3>:
    osalSysUnlockFromISR();
    break;

  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
    75a4:	60 3c       	jmp	$+194    	;abs 0x7666

000075a6 <.L63>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    75a6:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    75aa:	6c f2       	and.b	#4,	r12	;r2 As==10
    75ac:	0c 93       	cmp	#0,	r12	;r3 As==00
    75ae:	06 24       	jz	$+14     	;abs 0x75bc

000075b0 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    75b0:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    75b4:	3d 40 3a 51 	mov	#20794,	r13	;#0x513a
    75b8:	b0 12 1a 75 	call	#29978		;#0x751a

000075bc <.L64>:

    /* Data available */
    osalSysLockFromISR();
    75bc:	b0 12 5a 71 	call	#29018		;#0x715a

000075c0 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    75c0:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    75c4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    75c8:	4d 4c       	mov.b	r12,	r13	;
    75ca:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a
    75ce:	b0 12 72 6f 	call	#28530		;#0x6f72

000075d2 <.Loc.352.3>:
    osalSysUnlockFromISR();
    75d2:	b0 12 62 71 	call	#29026		;#0x7162

000075d6 <.Loc.353.3>:
    break;
    75d6:	47 3c       	jmp	$+144    	;abs 0x7666

000075d8 <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    75d8:	b0 12 5a 71 	call	#29018		;#0x715a

000075dc <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    75dc:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a
    75e0:	b0 12 c0 6f 	call	#28608		;#0x6fc0
    75e4:	81 4c 00 00 	mov	r12,	0(r1)	;

000075e8 <.Loc.360.3>:
    if (b < Q_OK) {
    75e8:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    75ec:	13 34       	jge	$+40     	;abs 0x7614

000075ee <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    75ee:	7d 42       	mov.b	#8,	r13	;r2 As==11
    75f0:	4e 43       	clr.b	r14		;
    75f2:	3c 40 3c 51 	mov	#20796,	r12	;#0x513c
    75f6:	b0 12 6a 71 	call	#29034		;#0x716a

000075fa <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    75fa:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    75fe:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    7602:	3c d2       	bis	#8,	r12	;r2 As==11
    7604:	82 4c da 05 	mov	r12,	&0x05da	;

00007608 <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    7608:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    760c:	2c d3       	bis	#2,	r12	;r3 As==10
    760e:	82 4c dc 05 	mov	r12,	&0x05dc	;
    7612:	03 3c       	jmp	$+8      	;abs 0x761a

00007614 <.L66>:
    }
    else
      UCA0TXBUF = b;
    7614:	2c 41       	mov	@r1,	r12	;
    7616:	82 4c ce 05 	mov	r12,	&0x05ce	;

0000761a <.L67>:
    osalSysUnlockFromISR();
    761a:	b0 12 62 71 	call	#29026		;#0x7162

0000761e <.Loc.368.3>:
    break;
    761e:	23 3c       	jmp	$+72     	;abs 0x7666

00007620 <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    7620:	b0 12 5a 71 	call	#29018		;#0x715a

00007624 <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    7624:	1d 42 5e 51 	mov	&0x515e,r13	;0x515e
    7628:	1c 42 60 51 	mov	&0x5160,r12	;0x5160
    762c:	0d 9c       	cmp	r12,	r13	;
    762e:	06 20       	jnz	$+14     	;abs 0x763c

00007630 <.Loc.374.3>:
    7630:	1c 42 58 51 	mov	&0x5158,r12	;0x5158
    7634:	0c 93       	cmp	#0,	r12	;r3 As==00
    7636:	02 24       	jz	$+6      	;abs 0x763c

00007638 <.Loc.374.3>:
    7638:	5c 43       	mov.b	#1,	r12	;r3 As==01
    763a:	01 3c       	jmp	$+4      	;abs 0x763e

0000763c <.L68>:
    763c:	4c 43       	clr.b	r12		;

0000763e <.L69>:
    763e:	5c f3       	and.b	#1,	r12	;r3 As==01
    7640:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7644:	0c 93       	cmp	#0,	r12	;r3 As==00
    7646:	07 24       	jz	$+16     	;abs 0x7656

00007648 <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    7648:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    764c:	4e 43       	clr.b	r14		;
    764e:	3c 40 3c 51 	mov	#20796,	r12	;#0x513c
    7652:	b0 12 6a 71 	call	#29034		;#0x716a

00007656 <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    7656:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    765a:	3c c2       	bic	#8,	r12	;r2 As==11
    765c:	82 4c da 05 	mov	r12,	&0x05da	;

00007660 <.Loc.377.3>:
    osalSysUnlockFromISR();
    7660:	b0 12 62 71 	call	#29026		;#0x7162

00007664 <.Loc.378.3>:
    break;
    7664:	03 43       	nop			

00007666 <.L65>:
  default: /* other interrupts */
    osalDbgAssert(false, "unhandled serial interrupt");
    break;
  }

  OSAL_IRQ_EPILOGUE();
    7666:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    766a:	b0 12 1e 64 	call	#25630		;#0x641e
    766e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7672:	0c 93       	cmp	#0,	r12	;r3 As==00
    7674:	02 24       	jz	$+6      	;abs 0x767a

00007676 <.Loc.385.3>:
    7676:	b0 12 3a 64 	call	#25658		;#0x643a

0000767a <.L72>:
}
    767a:	03 43       	nop			
    767c:	21 53       	incd	r1		;
    767e:	b4 17       	popm	#12,	r15	;16-bit words
    7680:	00 13       	reti			

00007682 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    7682:	3e 40 04 75 	mov	#29956,	r14	;#0x7504
    7686:	4d 43       	clr.b	r13		;
    7688:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a

0000768c <L0>:
    768c:	b0 12 d4 6e 	call	#28372		;#0x6ed4

00007690 <.Loc.589.3>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    7690:	03 43       	nop			
    7692:	30 41       	ret			

00007694 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7694:	21 82       	sub	#4,	r1	;r2 As==10

00007696 <.LCFI11>:
    7696:	81 4c 02 00 	mov	r12,	2(r1)	;
    769a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000769e <.Loc.603.3>:

  if (config == NULL) {
    769e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    76a2:	03 20       	jnz	$+8      	;abs 0x76aa

000076a4 <.Loc.604.3>:
    config = &default_config;
    76a4:	b1 40 10 50 	mov	#20496,	0(r1)	;#0x5010
    76a8:	00 00 

000076aa <.L75>:
  }

  if (sdp->state == SD_STOP) {
    76aa:	1c 41 02 00 	mov	2(r1),	r12	;
    76ae:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    76b2:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    76b4:	07 20       	jnz	$+16     	;abs 0x76c4

000076b6 <.Loc.609.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    76b6:	b1 90 3a 51 	cmp	#20794,	2(r1)	;#0x513a
    76ba:	02 00 
    76bc:	03 20       	jnz	$+8      	;abs 0x76c4

000076be <.Loc.610.3>:
      usart0_init(config);
    76be:	2c 41       	mov	@r1,	r12	;
    76c0:	b0 12 b2 74 	call	#29874		;#0x74b2

000076c4 <.L77>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    76c4:	03 43       	nop			
    76c6:	21 52       	add	#4,	r1	;r2 As==10
    76c8:	30 41       	ret			

000076ca <ISR_PORT1_VECTOR>:
/**
 * @brief   PORT1 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT1_VECTOR) {
    76ca:	bf 15       	pushm	#12,	r15	;16-bit words

000076cc <.LCFI0>:
    76cc:	21 82       	sub	#4,	r1	;r2 As==10

000076ce <.LCFI1>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    76ce:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

000076d2 <.Loc.78.1>:
  pad = (P1IV >> 1) - 1;
    76d2:	1c 42 0e 02 	mov	&0x020e,r12	;0x020e
    76d6:	12 c3       	clrc			
    76d8:	0c 10       	rrc	r12		;
    76da:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76de:	4d 4c       	mov.b	r12,	r13	;
    76e0:	7d 53       	add.b	#-1,	r13	;r3 As==11
    76e2:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000076e6 <.Loc.79.1>:
  cb = port_callback_map[0][pad];
    76e6:	5c 41 03 00 	mov.b	3(r1),	r12	;
    76ea:	0c 5c       	rla	r12		;
    76ec:	3c 50 86 51 	add	#20870,	r12	;#0x5186
    76f0:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000076f4 <.Loc.80.1>:
  if (cb != NULL) {
    76f4:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    76f8:	02 24       	jz	$+6      	;abs 0x76fe

000076fa <.Loc.81.1>:
    (*cb)();
    76fa:	2c 41       	mov	@r1,	r12	;
    76fc:	8c 12       	call	r12		;

000076fe <.L2>:
  }
  
  OSAL_IRQ_EPILOGUE();
    76fe:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    7702:	b0 12 1e 64 	call	#25630		;#0x641e
    7706:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    770a:	0c 93       	cmp	#0,	r12	;r3 As==00
    770c:	02 24       	jz	$+6      	;abs 0x7712

0000770e <.Loc.84.1>:
    770e:	b0 12 3a 64 	call	#25658		;#0x643a

00007712 <.L4>:
}
    7712:	03 43       	nop			
    7714:	21 52       	add	#4,	r1	;r2 As==10
    7716:	b4 17       	popm	#12,	r15	;16-bit words
    7718:	00 13       	reti			

0000771a <ISR_PORT2_VECTOR>:
/**
 * @brief   PORT2 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT2_VECTOR) {
    771a:	bf 15       	pushm	#12,	r15	;16-bit words

0000771c <.LCFI2>:
    771c:	21 82       	sub	#4,	r1	;r2 As==10

0000771e <.LCFI3>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    771e:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

00007722 <.Loc.96.1>:
  pad = (P2IV >> 1) - 1;
    7722:	1c 42 1e 02 	mov	&0x021e,r12	;0x021e
    7726:	12 c3       	clrc			
    7728:	0c 10       	rrc	r12		;
    772a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    772e:	4d 4c       	mov.b	r12,	r13	;
    7730:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7732:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007736 <.Loc.97.1>:
  cb = port_callback_map[1][pad];
    7736:	5c 41 03 00 	mov.b	3(r1),	r12	;
    773a:	3c 52       	add	#8,	r12	;r2 As==11
    773c:	0c 5c       	rla	r12		;
    773e:	3c 50 86 51 	add	#20870,	r12	;#0x5186
    7742:	a1 4c 00 00 	mov	@r12,	0(r1)	;

00007746 <.Loc.98.1>:
  if (cb != NULL) {
    7746:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    774a:	02 24       	jz	$+6      	;abs 0x7750

0000774c <.Loc.99.1>:
    (*cb)();
    774c:	2c 41       	mov	@r1,	r12	;
    774e:	8c 12       	call	r12		;

00007750 <.L6>:
  }
  
  OSAL_IRQ_EPILOGUE();
    7750:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    7754:	b0 12 1e 64 	call	#25630		;#0x641e
    7758:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    775c:	0c 93       	cmp	#0,	r12	;r3 As==00
    775e:	02 24       	jz	$+6      	;abs 0x7764

00007760 <.Loc.102.1>:
    7760:	b0 12 3a 64 	call	#25658		;#0x643a

00007764 <.L8>:
}
    7764:	03 43       	nop			
    7766:	21 52       	add	#4,	r1	;r2 As==10
    7768:	b4 17       	popm	#12,	r15	;16-bit words
    776a:	00 13       	reti			

0000776c <ISR_PORT3_VECTOR>:
/**
 * @brief   PORT3 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT3_VECTOR) {
    776c:	bf 15       	pushm	#12,	r15	;16-bit words

0000776e <.LCFI4>:
    776e:	21 82       	sub	#4,	r1	;r2 As==10

00007770 <.LCFI5>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    7770:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

00007774 <.Loc.115.1>:
  pad = (P3IV >> 1) - 1;
    7774:	1c 42 2e 02 	mov	&0x022e,r12	;0x022e
    7778:	12 c3       	clrc			
    777a:	0c 10       	rrc	r12		;
    777c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7780:	4d 4c       	mov.b	r12,	r13	;
    7782:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7784:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007788 <.Loc.116.1>:
  cb = port_callback_map[2][pad];
    7788:	5c 41 03 00 	mov.b	3(r1),	r12	;
    778c:	3c 50 10 00 	add	#16,	r12	;#0x0010
    7790:	0c 5c       	rla	r12		;
    7792:	3c 50 86 51 	add	#20870,	r12	;#0x5186
    7796:	a1 4c 00 00 	mov	@r12,	0(r1)	;

0000779a <.Loc.117.1>:
  if (cb != NULL) {
    779a:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    779e:	02 24       	jz	$+6      	;abs 0x77a4

000077a0 <.Loc.118.1>:
    (*cb)();
    77a0:	2c 41       	mov	@r1,	r12	;
    77a2:	8c 12       	call	r12		;

000077a4 <.L10>:
  }
  
  OSAL_IRQ_EPILOGUE();
    77a4:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    77a8:	b0 12 1e 64 	call	#25630		;#0x641e
    77ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    77b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    77b2:	02 24       	jz	$+6      	;abs 0x77b8

000077b4 <.Loc.121.1>:
    77b4:	b0 12 3a 64 	call	#25658		;#0x643a

000077b8 <.L12>:
}
    77b8:	03 43       	nop			
    77ba:	21 52       	add	#4,	r1	;r2 As==10
    77bc:	b4 17       	popm	#12,	r15	;16-bit words
    77be:	00 13       	reti			

000077c0 <ISR_PORT4_VECTOR>:
/**
 * @brief   PORT4 interrupt handler
 * 
 * @isr
 */
PORT_IRQ_HANDLER(PORT4_VECTOR) {
    77c0:	bf 15       	pushm	#12,	r15	;16-bit words

000077c2 <.LCFI6>:
    77c2:	21 82       	sub	#4,	r1	;r2 As==10

000077c4 <.LCFI7>:
  palcallback_t cb;
  uint8_t pad;
  OSAL_IRQ_PROLOGUE();
    77c4:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

000077c8 <.Loc.133.1>:
  pad = (P4IV >> 1) - 1;
    77c8:	1c 42 3e 02 	mov	&0x023e,r12	;0x023e
    77cc:	12 c3       	clrc			
    77ce:	0c 10       	rrc	r12		;
    77d0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    77d4:	4d 4c       	mov.b	r12,	r13	;
    77d6:	7d 53       	add.b	#-1,	r13	;r3 As==11
    77d8:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

000077dc <.Loc.134.1>:
  cb = port_callback_map[3][pad];
    77dc:	5c 41 03 00 	mov.b	3(r1),	r12	;
    77e0:	3c 50 18 00 	add	#24,	r12	;#0x0018
    77e4:	0c 5c       	rla	r12		;
    77e6:	3c 50 86 51 	add	#20870,	r12	;#0x5186
    77ea:	a1 4c 00 00 	mov	@r12,	0(r1)	;

000077ee <.Loc.135.1>:
  if (cb != NULL) {
    77ee:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    77f2:	02 24       	jz	$+6      	;abs 0x77f8

000077f4 <.Loc.136.1>:
    (*cb)();
    77f4:	2c 41       	mov	@r1,	r12	;
    77f6:	8c 12       	call	r12		;

000077f8 <.L14>:
  }
  
  OSAL_IRQ_EPILOGUE();
    77f8:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    77fc:	b0 12 1e 64 	call	#25630		;#0x641e
    7800:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7804:	0c 93       	cmp	#0,	r12	;r3 As==00
    7806:	02 24       	jz	$+6      	;abs 0x780c

00007808 <.Loc.139.1>:
    7808:	b0 12 3a 64 	call	#25658		;#0x643a

0000780c <.L16>:
}
    780c:	03 43       	nop			
    780e:	21 52       	add	#4,	r1	;r2 As==10
    7810:	b4 17       	popm	#12,	r15	;16-bit words
    7812:	00 13       	reti			

00007814 <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    7814:	21 83       	decd	r1		;

00007816 <.LCFI8>:
    7816:	81 4c 00 00 	mov	r12,	0(r1)	;

0000781a <.Loc.309.1>:

  PAOUT = config->porta.out;
    781a:	2c 41       	mov	@r1,	r12	;
    781c:	2c 4c       	mov	@r12,	r12	;
    781e:	82 4c 02 02 	mov	r12,	&0x0202	;

00007822 <.Loc.310.1>:
  PADIR = config->porta.dir;
    7822:	2c 41       	mov	@r1,	r12	;
    7824:	1c 4c 02 00 	mov	2(r12),	r12	;
    7828:	82 4c 04 02 	mov	r12,	&0x0204	;

0000782c <.Loc.311.1>:
  PAREN = config->porta.ren;
    782c:	2c 41       	mov	@r1,	r12	;
    782e:	1c 4c 04 00 	mov	4(r12),	r12	;
    7832:	82 4c 06 02 	mov	r12,	&0x0206	;

00007836 <.Loc.312.1>:
  PASEL0 = config->porta.sel0;
    7836:	2c 41       	mov	@r1,	r12	;
    7838:	1c 4c 06 00 	mov	6(r12),	r12	;
    783c:	82 4c 0a 02 	mov	r12,	&0x020a	;

00007840 <.Loc.313.1>:
  PASEL1 = config->porta.sel1;
    7840:	2c 41       	mov	@r1,	r12	;
    7842:	1c 4c 08 00 	mov	8(r12),	r12	;
    7846:	82 4c 0c 02 	mov	r12,	&0x020c	;

0000784a <.Loc.315.1>:
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    784a:	2c 41       	mov	@r1,	r12	;
    784c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7850:	82 4c 22 02 	mov	r12,	&0x0222	;

00007854 <.Loc.316.1>:
  PBDIR = config->portb.dir;
    7854:	2c 41       	mov	@r1,	r12	;
    7856:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    785a:	82 4c 24 02 	mov	r12,	&0x0224	;

0000785e <.Loc.317.1>:
  PBREN = config->portb.ren;
    785e:	2c 41       	mov	@r1,	r12	;
    7860:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    7864:	82 4c 26 02 	mov	r12,	&0x0226	;

00007868 <.Loc.318.1>:
  PBSEL0 = config->portb.sel0;
    7868:	2c 41       	mov	@r1,	r12	;
    786a:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    786e:	82 4c 2a 02 	mov	r12,	&0x022a	;

00007872 <.Loc.319.1>:
  PBSEL1 = config->portb.sel1;
    7872:	2c 41       	mov	@r1,	r12	;
    7874:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7878:	82 4c 2c 02 	mov	r12,	&0x022c	;

0000787c <.Loc.349.1>:
  PFDIR = config->portf.dir;
  PFREN = config->portf.ren;
  PFSEL0 = config->portf.sel0;
  PFSEL1 = config->portf.sel1;
#endif
  PJOUT = config->portj.out;
    787c:	2c 41       	mov	@r1,	r12	;
    787e:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    7882:	82 4c 22 03 	mov	r12,	&0x0322	;

00007886 <.Loc.350.1>:
  PJDIR = config->portj.dir;
    7886:	2c 41       	mov	@r1,	r12	;
    7888:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    788c:	82 4c 24 03 	mov	r12,	&0x0324	;

00007890 <.Loc.351.1>:
  PJREN = config->portj.ren;
    7890:	2c 41       	mov	@r1,	r12	;
    7892:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    7896:	82 4c 26 03 	mov	r12,	&0x0326	;

0000789a <.Loc.352.1>:
  PJSEL0 = config->portj.sel0;
    789a:	2c 41       	mov	@r1,	r12	;
    789c:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    78a0:	82 4c 2a 03 	mov	r12,	&0x032a	;

000078a4 <.Loc.353.1>:
  PJSEL1 = config->portj.sel1;
    78a4:	2c 41       	mov	@r1,	r12	;
    78a6:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    78aa:	82 4c 2c 03 	mov	r12,	&0x032c	;

000078ae <.Loc.355.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    78ae:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    78b2:	1c c3       	bic	#1,	r12	;r3 As==01
    78b4:	82 4c 30 01 	mov	r12,	&0x0130	;

000078b8 <.Loc.356.1>:
}
    78b8:	03 43       	nop			
    78ba:	21 53       	incd	r1		;
    78bc:	30 41       	ret			

000078be <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    78be:	31 80 06 00 	sub	#6,	r1	;

000078c2 <.LCFI9>:
    78c2:	81 4c 04 00 	mov	r12,	4(r1)	;
    78c6:	81 4d 02 00 	mov	r13,	2(r1)	;
    78ca:	81 4e 00 00 	mov	r14,	0(r1)	;

000078ce <.Loc.374.1>:
  
  switch (mode) {
    78ce:	2c 41       	mov	@r1,	r12	;
    78d0:	2c 92       	cmp	#4,	r12	;r2 As==10
    78d2:	b5 24       	jz	$+364    	;abs 0x7a3e
    78d4:	6d 42       	mov.b	#4,	r13	;r2 As==10
    78d6:	0d 9c       	cmp	r12,	r13	;
    78d8:	0a 28       	jnc	$+22     	;abs 0x78ee
    78da:	1c 93       	cmp	#1,	r12	;r3 As==01
    78dc:	5f 24       	jz	$+192    	;abs 0x799c
    78de:	1c 93       	cmp	#1,	r12	;r3 As==01
    78e0:	16 28       	jnc	$+46     	;abs 0x790e
    78e2:	2c 93       	cmp	#2,	r12	;r3 As==10
    78e4:	14 24       	jz	$+42     	;abs 0x790e
    78e6:	3c 90 03 00 	cmp	#3,	r12	;
    78ea:	58 24       	jz	$+178    	;abs 0x799c

000078ec <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    78ec:	bd 3d       	jmp	$+892    	;abs 0x7c68

000078ee <.L21>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    78ee:	3c 92       	cmp	#8,	r12	;r2 As==11
    78f0:	32 25       	jz	$+614    	;abs 0x7b56
    78f2:	7d 42       	mov.b	#8,	r13	;r2 As==11
    78f4:	0d 9c       	cmp	r12,	r13	;
    78f6:	04 28       	jnc	$+10     	;abs 0x7900
    78f8:	3c 90 06 00 	cmp	#6,	r12	;
    78fc:	f2 24       	jz	$+486    	;abs 0x7ae2

000078fe <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    78fe:	b4 3d       	jmp	$+874    	;abs 0x7c68

00007900 <.L25>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    7900:	3c 90 09 00 	cmp	#9,	r12	;
    7904:	56 25       	jz	$+686    	;abs 0x7bb2
    7906:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    790a:	81 25       	jz	$+772    	;abs 0x7c0e

0000790c <.Loc.443.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    790c:	ad 3d       	jmp	$+860    	;abs 0x7c68

0000790e <.L23>:
                           iomode_t mode) {
  
  switch (mode) {
    case PAL_MODE_RESET:
    case PAL_MODE_INPUT:
      port->dir &= ~mask;
    790e:	1c 41 04 00 	mov	4(r1),	r12	;
    7912:	1d 4c 04 00 	mov	4(r12),	r13	;
    7916:	1c 41 02 00 	mov	2(r1),	r12	;
    791a:	3c e3       	inv	r12		;
    791c:	0d fc       	and	r12,	r13	;
    791e:	1c 41 04 00 	mov	4(r1),	r12	;
    7922:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007926 <.Loc.378.1>:
      port->ren &= ~mask;
    7926:	1c 41 04 00 	mov	4(r1),	r12	;
    792a:	1d 4c 08 00 	mov	8(r12),	r13	;
    792e:	1c 41 02 00 	mov	2(r1),	r12	;
    7932:	3c e3       	inv	r12		;
    7934:	0d fc       	and	r12,	r13	;
    7936:	1c 41 04 00 	mov	4(r1),	r12	;
    793a:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000793e <.Loc.379.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    793e:	1c 41 04 00 	mov	4(r1),	r12	;
    7942:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7946:	1c f1 02 00 	and	2(r1),	r12	;
    794a:	0c 93       	cmp	#0,	r12	;r3 As==00
    794c:	0e 24       	jz	$+30     	;abs 0x796a

0000794e <.Loc.379.1>:
    794e:	1c 41 04 00 	mov	4(r1),	r12	;
    7952:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7956:	1c f1 02 00 	and	2(r1),	r12	;
    795a:	0c 93       	cmp	#0,	r12	;r3 As==00
    795c:	06 24       	jz	$+14     	;abs 0x796a

0000795e <.Loc.380.1>:
        port->selc = mask;
    795e:	1c 41 04 00 	mov	4(r1),	r12	;
    7962:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7966:	16 00 

00007968 <.Loc.385.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7968:	7f 3d       	jmp	$+768    	;abs 0x7c68

0000796a <.L29>:
      port->dir &= ~mask;
      port->ren &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    796a:	1c 41 04 00 	mov	4(r1),	r12	;
    796e:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7972:	1c 41 02 00 	mov	2(r1),	r12	;
    7976:	3c e3       	inv	r12		;
    7978:	0d fc       	and	r12,	r13	;
    797a:	1c 41 04 00 	mov	4(r1),	r12	;
    797e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007982 <.Loc.383.1>:
        port->sel1 &= ~mask;
    7982:	1c 41 04 00 	mov	4(r1),	r12	;
    7986:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    798a:	1c 41 02 00 	mov	2(r1),	r12	;
    798e:	3c e3       	inv	r12		;
    7990:	0d fc       	and	r12,	r13	;
    7992:	1c 41 04 00 	mov	4(r1),	r12	;
    7996:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000799a <.Loc.385.1>:
      }
      break;
    799a:	66 3d       	jmp	$+718    	;abs 0x7c68

0000799c <.L22>:
    case PAL_MODE_UNCONNECTED:
    case PAL_MODE_INPUT_PULLUP:
      port->dir &= ~mask;
    799c:	1c 41 04 00 	mov	4(r1),	r12	;
    79a0:	1d 4c 04 00 	mov	4(r12),	r13	;
    79a4:	1c 41 02 00 	mov	2(r1),	r12	;
    79a8:	3c e3       	inv	r12		;
    79aa:	0d fc       	and	r12,	r13	;
    79ac:	1c 41 04 00 	mov	4(r1),	r12	;
    79b0:	8c 4d 04 00 	mov	r13,	4(r12)	;

000079b4 <.Loc.389.1>:
      port->ren |= mask;
    79b4:	1c 41 04 00 	mov	4(r1),	r12	;
    79b8:	1c 4c 08 00 	mov	8(r12),	r12	;
    79bc:	0d 4c       	mov	r12,	r13	;
    79be:	1d d1 02 00 	bis	2(r1),	r13	;
    79c2:	1c 41 04 00 	mov	4(r1),	r12	;
    79c6:	8c 4d 08 00 	mov	r13,	8(r12)	;

000079ca <.Loc.390.1>:
      port->out |= mask;
    79ca:	1c 41 04 00 	mov	4(r1),	r12	;
    79ce:	1c 4c 02 00 	mov	2(r12),	r12	;
    79d2:	0d 4c       	mov	r12,	r13	;
    79d4:	1d d1 02 00 	bis	2(r1),	r13	;
    79d8:	1c 41 04 00 	mov	4(r1),	r12	;
    79dc:	8c 4d 02 00 	mov	r13,	2(r12)	;

000079e0 <.Loc.391.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    79e0:	1c 41 04 00 	mov	4(r1),	r12	;
    79e4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    79e8:	1c f1 02 00 	and	2(r1),	r12	;
    79ec:	0c 93       	cmp	#0,	r12	;r3 As==00
    79ee:	0e 24       	jz	$+30     	;abs 0x7a0c

000079f0 <.Loc.391.1>:
    79f0:	1c 41 04 00 	mov	4(r1),	r12	;
    79f4:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    79f8:	1c f1 02 00 	and	2(r1),	r12	;
    79fc:	0c 93       	cmp	#0,	r12	;r3 As==00
    79fe:	06 24       	jz	$+14     	;abs 0x7a0c

00007a00 <.Loc.392.1>:
        port->selc = mask;
    7a00:	1c 41 04 00 	mov	4(r1),	r12	;
    7a04:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7a08:	16 00 

00007a0a <.Loc.397.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7a0a:	2e 3d       	jmp	$+606    	;abs 0x7c68

00007a0c <.L31>:
      port->ren |= mask;
      port->out |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7a0c:	1c 41 04 00 	mov	4(r1),	r12	;
    7a10:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7a14:	1c 41 02 00 	mov	2(r1),	r12	;
    7a18:	3c e3       	inv	r12		;
    7a1a:	0d fc       	and	r12,	r13	;
    7a1c:	1c 41 04 00 	mov	4(r1),	r12	;
    7a20:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007a24 <.Loc.395.1>:
        port->sel1 &= ~mask;
    7a24:	1c 41 04 00 	mov	4(r1),	r12	;
    7a28:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7a2c:	1c 41 02 00 	mov	2(r1),	r12	;
    7a30:	3c e3       	inv	r12		;
    7a32:	0d fc       	and	r12,	r13	;
    7a34:	1c 41 04 00 	mov	4(r1),	r12	;
    7a38:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007a3c <.Loc.397.1>:
      }
      break;
    7a3c:	15 3d       	jmp	$+556    	;abs 0x7c68

00007a3e <.L20>:
    case PAL_MODE_INPUT_PULLDOWN:
      port->dir &= ~mask;
    7a3e:	1c 41 04 00 	mov	4(r1),	r12	;
    7a42:	1d 4c 04 00 	mov	4(r12),	r13	;
    7a46:	1c 41 02 00 	mov	2(r1),	r12	;
    7a4a:	3c e3       	inv	r12		;
    7a4c:	0d fc       	and	r12,	r13	;
    7a4e:	1c 41 04 00 	mov	4(r1),	r12	;
    7a52:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007a56 <.Loc.400.1>:
      port->ren |= mask;
    7a56:	1c 41 04 00 	mov	4(r1),	r12	;
    7a5a:	1c 4c 08 00 	mov	8(r12),	r12	;
    7a5e:	0d 4c       	mov	r12,	r13	;
    7a60:	1d d1 02 00 	bis	2(r1),	r13	;
    7a64:	1c 41 04 00 	mov	4(r1),	r12	;
    7a68:	8c 4d 08 00 	mov	r13,	8(r12)	;

00007a6c <.Loc.401.1>:
      port->out &= ~mask;
    7a6c:	1c 41 04 00 	mov	4(r1),	r12	;
    7a70:	1d 4c 02 00 	mov	2(r12),	r13	;
    7a74:	1c 41 02 00 	mov	2(r1),	r12	;
    7a78:	3c e3       	inv	r12		;
    7a7a:	0d fc       	and	r12,	r13	;
    7a7c:	1c 41 04 00 	mov	4(r1),	r12	;
    7a80:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007a84 <.Loc.402.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    7a84:	1c 41 04 00 	mov	4(r1),	r12	;
    7a88:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7a8c:	1c f1 02 00 	and	2(r1),	r12	;
    7a90:	0c 93       	cmp	#0,	r12	;r3 As==00
    7a92:	0e 24       	jz	$+30     	;abs 0x7ab0

00007a94 <.Loc.402.1>:
    7a94:	1c 41 04 00 	mov	4(r1),	r12	;
    7a98:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7a9c:	1c f1 02 00 	and	2(r1),	r12	;
    7aa0:	0c 93       	cmp	#0,	r12	;r3 As==00
    7aa2:	06 24       	jz	$+14     	;abs 0x7ab0

00007aa4 <.Loc.403.1>:
        port->selc = mask;
    7aa4:	1c 41 04 00 	mov	4(r1),	r12	;
    7aa8:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7aac:	16 00 

00007aae <.Loc.408.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7aae:	dc 3c       	jmp	$+442    	;abs 0x7c68

00007ab0 <.L33>:
      port->ren |= mask;
      port->out &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7ab0:	1c 41 04 00 	mov	4(r1),	r12	;
    7ab4:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7ab8:	1c 41 02 00 	mov	2(r1),	r12	;
    7abc:	3c e3       	inv	r12		;
    7abe:	0d fc       	and	r12,	r13	;
    7ac0:	1c 41 04 00 	mov	4(r1),	r12	;
    7ac4:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007ac8 <.Loc.406.1>:
        port->sel1 &= ~mask;
    7ac8:	1c 41 04 00 	mov	4(r1),	r12	;
    7acc:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7ad0:	1c 41 02 00 	mov	2(r1),	r12	;
    7ad4:	3c e3       	inv	r12		;
    7ad6:	0d fc       	and	r12,	r13	;
    7ad8:	1c 41 04 00 	mov	4(r1),	r12	;
    7adc:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007ae0 <.Loc.408.1>:
      }
      break;
    7ae0:	c3 3c       	jmp	$+392    	;abs 0x7c68

00007ae2 <.L26>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
    7ae2:	1c 41 04 00 	mov	4(r1),	r12	;
    7ae6:	1c 4c 04 00 	mov	4(r12),	r12	;
    7aea:	0d 4c       	mov	r12,	r13	;
    7aec:	1d d1 02 00 	bis	2(r1),	r13	;
    7af0:	1c 41 04 00 	mov	4(r1),	r12	;
    7af4:	8c 4d 04 00 	mov	r13,	4(r12)	;

00007af8 <.Loc.411.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    7af8:	1c 41 04 00 	mov	4(r1),	r12	;
    7afc:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7b00:	1c f1 02 00 	and	2(r1),	r12	;
    7b04:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b06:	0e 24       	jz	$+30     	;abs 0x7b24

00007b08 <.Loc.411.1>:
    7b08:	1c 41 04 00 	mov	4(r1),	r12	;
    7b0c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7b10:	1c f1 02 00 	and	2(r1),	r12	;
    7b14:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b16:	06 24       	jz	$+14     	;abs 0x7b24

00007b18 <.Loc.412.1>:
        port->selc = mask;
    7b18:	1c 41 04 00 	mov	4(r1),	r12	;
    7b1c:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7b20:	16 00 

00007b22 <.Loc.417.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7b22:	a2 3c       	jmp	$+326    	;abs 0x7c68

00007b24 <.L35>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7b24:	1c 41 04 00 	mov	4(r1),	r12	;
    7b28:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7b2c:	1c 41 02 00 	mov	2(r1),	r12	;
    7b30:	3c e3       	inv	r12		;
    7b32:	0d fc       	and	r12,	r13	;
    7b34:	1c 41 04 00 	mov	4(r1),	r12	;
    7b38:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007b3c <.Loc.415.1>:
        port->sel1 &= ~mask;
    7b3c:	1c 41 04 00 	mov	4(r1),	r12	;
    7b40:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7b44:	1c 41 02 00 	mov	2(r1),	r12	;
    7b48:	3c e3       	inv	r12		;
    7b4a:	0d fc       	and	r12,	r13	;
    7b4c:	1c 41 04 00 	mov	4(r1),	r12	;
    7b50:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007b54 <.Loc.417.1>:
      }
      break;
    7b54:	89 3c       	jmp	$+276    	;abs 0x7c68

00007b56 <.L24>:
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    7b56:	1c 41 04 00 	mov	4(r1),	r12	;
    7b5a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7b5e:	1c f1 02 00 	and	2(r1),	r12	;
    7b62:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b64:	0e 20       	jnz	$+30     	;abs 0x7b82

00007b66 <.Loc.419.1>:
    7b66:	1c 41 04 00 	mov	4(r1),	r12	;
    7b6a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7b6e:	1c f1 02 00 	and	2(r1),	r12	;
    7b72:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b74:	06 24       	jz	$+14     	;abs 0x7b82

00007b76 <.Loc.420.1>:
        port->selc = mask;
    7b76:	1c 41 04 00 	mov	4(r1),	r12	;
    7b7a:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7b7e:	16 00 

00007b80 <.Loc.425.1>:
      else {
        port->sel0 |= mask;
        port->sel1 &= ~mask;
      }
      break;
    7b80:	73 3c       	jmp	$+232    	;abs 0x7c68

00007b82 <.L37>:
      break;
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
        port->selc = mask;
      else {
        port->sel0 |= mask;
    7b82:	1c 41 04 00 	mov	4(r1),	r12	;
    7b86:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7b8a:	0d 4c       	mov	r12,	r13	;
    7b8c:	1d d1 02 00 	bis	2(r1),	r13	;
    7b90:	1c 41 04 00 	mov	4(r1),	r12	;
    7b94:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007b98 <.Loc.423.1>:
        port->sel1 &= ~mask;
    7b98:	1c 41 04 00 	mov	4(r1),	r12	;
    7b9c:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7ba0:	1c 41 02 00 	mov	2(r1),	r12	;
    7ba4:	3c e3       	inv	r12		;
    7ba6:	0d fc       	and	r12,	r13	;
    7ba8:	1c 41 04 00 	mov	4(r1),	r12	;
    7bac:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007bb0 <.Loc.425.1>:
      }
      break;
    7bb0:	5b 3c       	jmp	$+184    	;abs 0x7c68

00007bb2 <.L27>:
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    7bb2:	1c 41 04 00 	mov	4(r1),	r12	;
    7bb6:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7bba:	1c f1 02 00 	and	2(r1),	r12	;
    7bbe:	0c 93       	cmp	#0,	r12	;r3 As==00
    7bc0:	0e 24       	jz	$+30     	;abs 0x7bde

00007bc2 <.Loc.427.1>:
    7bc2:	1c 41 04 00 	mov	4(r1),	r12	;
    7bc6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7bca:	1c f1 02 00 	and	2(r1),	r12	;
    7bce:	0c 93       	cmp	#0,	r12	;r3 As==00
    7bd0:	06 20       	jnz	$+14     	;abs 0x7bde

00007bd2 <.Loc.428.1>:
        port->selc = mask;
    7bd2:	1c 41 04 00 	mov	4(r1),	r12	;
    7bd6:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7bda:	16 00 

00007bdc <.Loc.433.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 |= mask;
      }
      break;
    7bdc:	45 3c       	jmp	$+140    	;abs 0x7c68

00007bde <.L39>:
      break;
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7bde:	1c 41 04 00 	mov	4(r1),	r12	;
    7be2:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7be6:	1c 41 02 00 	mov	2(r1),	r12	;
    7bea:	3c e3       	inv	r12		;
    7bec:	0d fc       	and	r12,	r13	;
    7bee:	1c 41 04 00 	mov	4(r1),	r12	;
    7bf2:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007bf6 <.Loc.431.1>:
        port->sel1 |= mask;
    7bf6:	1c 41 04 00 	mov	4(r1),	r12	;
    7bfa:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7bfe:	0d 4c       	mov	r12,	r13	;
    7c00:	1d d1 02 00 	bis	2(r1),	r13	;
    7c04:	1c 41 04 00 	mov	4(r1),	r12	;
    7c08:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007c0c <.Loc.433.1>:
      }
      break;
    7c0c:	2d 3c       	jmp	$+92     	;abs 0x7c68

00007c0e <.L28>:
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    7c0e:	1c 41 04 00 	mov	4(r1),	r12	;
    7c12:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7c16:	1c f1 02 00 	and	2(r1),	r12	;
    7c1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c1c:	0e 20       	jnz	$+30     	;abs 0x7c3a

00007c1e <.Loc.435.1>:
    7c1e:	1c 41 04 00 	mov	4(r1),	r12	;
    7c22:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7c26:	1c f1 02 00 	and	2(r1),	r12	;
    7c2a:	0c 93       	cmp	#0,	r12	;r3 As==00
    7c2c:	06 20       	jnz	$+14     	;abs 0x7c3a

00007c2e <.Loc.436.1>:
        port->selc = mask;
    7c2e:	1c 41 04 00 	mov	4(r1),	r12	;
    7c32:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7c36:	16 00 

00007c38 <.Loc.441.1>:
      else {
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
    7c38:	16 3c       	jmp	$+46     	;abs 0x7c66

00007c3a <.L41>:
      break;
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 |= mask;
    7c3a:	1c 41 04 00 	mov	4(r1),	r12	;
    7c3e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7c42:	0d 4c       	mov	r12,	r13	;
    7c44:	1d d1 02 00 	bis	2(r1),	r13	;
    7c48:	1c 41 04 00 	mov	4(r1),	r12	;
    7c4c:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007c50 <.Loc.439.1>:
        port->sel1 |= mask;
    7c50:	1c 41 04 00 	mov	4(r1),	r12	;
    7c54:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7c58:	0d 4c       	mov	r12,	r13	;
    7c5a:	1d d1 02 00 	bis	2(r1),	r13	;
    7c5e:	1c 41 04 00 	mov	4(r1),	r12	;
    7c62:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007c66 <.L43>:
      }
      break;
    7c66:	03 43       	nop			

00007c68 <.L19>:
  }
}
    7c68:	03 43       	nop			
    7c6a:	31 50 06 00 	add	#6,	r1	;
    7c6e:	30 41       	ret			

00007c70 <_pal_lld_enablepadevent>:

void _pal_lld_enablepadevent(ioportid_t port, uint8_t pad, ioeventmode_t mode,
    palcallback_t callback) {
    7c70:	0a 15       	pushm	#1,	r10	;16-bit words

00007c72 <.LCFI10>:
    7c72:	31 82       	sub	#8,	r1	;r2 As==11

00007c74 <.LCFI11>:
    7c74:	81 4c 04 00 	mov	r12,	4(r1)	;
    7c78:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    7c7c:	c1 4e 02 00 	mov.b	r14,	2(r1)	;
    7c80:	81 4f 00 00 	mov	r15,	0(r1)	;

00007c84 <.Loc.448.1>:
  /* This is ugly but very efficient. Check the MSP header files. */
  uint8_t portindex = ((((intptr_t)(port)) >> 4) & 0x0F) + (pad > 7 ? 2 : 1);
    7c84:	1c 41 04 00 	mov	4(r1),	r12	;
    7c88:	43 18 0c 11 	rpt #4 { rrax.w	r12		;
    7c8c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00007c90 <L0>:
    7c90:	7c f0 0f 00 	and.b	#15,	r12	;#0x000f
    7c94:	4d 4c       	mov.b	r12,	r13	;
    7c96:	7c 40 07 00 	mov.b	#7,	r12	;
    7c9a:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7c9e:	02 2c       	jc	$+6      	;abs 0x7ca4

00007ca0 <.Loc.448.1>:
    7ca0:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7ca2:	01 3c       	jmp	$+4      	;abs 0x7ca6

00007ca4 <.L46>:
    7ca4:	5c 43       	mov.b	#1,	r12	;r3 As==01

00007ca6 <.L47>:
    7ca6:	4e 4d       	mov.b	r13,	r14	;
    7ca8:	4e 5c       	add.b	r12,	r14	;
    7caa:	c1 4e 07 00 	mov.b	r14,	7(r1)	;

00007cae <.Loc.450.1>:
  
  port_callback_map[portindex - 1][pad & 0x07] = callback;
    7cae:	5c 41 07 00 	mov.b	7(r1),	r12	;
    7cb2:	3c 53       	add	#-1,	r12	;r3 As==11
    7cb4:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7cb8:	7d f0 07 00 	and.b	#7,	r13	;
    7cbc:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    7cc0:	0c 5d       	add	r13,	r12	;
    7cc2:	0c 5c       	rla	r12		;
    7cc4:	3c 50 86 51 	add	#20870,	r12	;#0x5186
    7cc8:	ac 41 00 00 	mov	@r1,	0(r12)	;

00007ccc <.Loc.452.1>:

  if (mode == PAL_EVENT_MODE_RISING_EDGE) {
    7ccc:	d1 93 02 00 	cmp.b	#1,	2(r1)	;r3 As==01
    7cd0:	11 20       	jnz	$+36     	;abs 0x7cf4

00007cd2 <.Loc.453.1>:
    port->ies &= ~(1 << pad);
    7cd2:	1c 41 04 00 	mov	4(r1),	r12	;
    7cd6:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    7cda:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7cde:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7ce0:	b0 12 30 92 	call	#37424		;#0x9230
    7ce4:	3c e3       	inv	r12		;
    7ce6:	0d 4a       	mov	r10,	r13	;
    7ce8:	0d fc       	and	r12,	r13	;
    7cea:	1c 41 04 00 	mov	4(r1),	r12	;
    7cee:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018
    7cf2:	12 3c       	jmp	$+38     	;abs 0x7d18

00007cf4 <.L48>:
  }
  else if (mode == PAL_EVENT_MODE_FALLING_EDGE) {
    7cf4:	e1 93 02 00 	cmp.b	#2,	2(r1)	;r3 As==10
    7cf8:	0f 20       	jnz	$+32     	;abs 0x7d18

00007cfa <.Loc.456.1>:
    port->ies |= (1 << pad);
    7cfa:	1c 41 04 00 	mov	4(r1),	r12	;
    7cfe:	1a 4c 18 00 	mov	24(r12),r10	;0x00018
    7d02:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7d06:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d08:	b0 12 30 92 	call	#37424		;#0x9230
    7d0c:	0d 4a       	mov	r10,	r13	;
    7d0e:	0d dc       	bis	r12,	r13	;
    7d10:	1c 41 04 00 	mov	4(r1),	r12	;
    7d14:	8c 4d 18 00 	mov	r13,	24(r12)	; 0x0018

00007d18 <.L49>:
  }
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    7d18:	c1 93 02 00 	cmp.b	#0,	2(r1)	;r3 As==00
    7d1c:	11 20       	jnz	$+36     	;abs 0x7d40

00007d1e <.Loc.460.1>:
    port->ie &= ~(1 << pad);
    7d1e:	1c 41 04 00 	mov	4(r1),	r12	;
    7d22:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    7d26:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7d2a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d2c:	b0 12 30 92 	call	#37424		;#0x9230
    7d30:	3c e3       	inv	r12		;
    7d32:	0d 4a       	mov	r10,	r13	;
    7d34:	0d fc       	and	r12,	r13	;
    7d36:	1c 41 04 00 	mov	4(r1),	r12	;
    7d3a:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00007d3e <.Loc.466.1>:
  }
  else {
    port->ifg &= ~(1 << pad);
    port->ie |= (1 << pad);
  }
}
    7d3e:	1f 3c       	jmp	$+64     	;abs 0x7d7e

00007d40 <.L50>:
  
  if (mode == PAL_EVENT_MODE_DISABLED) {
    port->ie &= ~(1 << pad);
  }
  else {
    port->ifg &= ~(1 << pad);
    7d40:	1c 41 04 00 	mov	4(r1),	r12	;
    7d44:	1a 4c 1c 00 	mov	28(r12),r10	;0x0001c
    7d48:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7d4c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d4e:	b0 12 30 92 	call	#37424		;#0x9230
    7d52:	3c e3       	inv	r12		;
    7d54:	0d 4a       	mov	r10,	r13	;
    7d56:	0d fc       	and	r12,	r13	;
    7d58:	1c 41 04 00 	mov	4(r1),	r12	;
    7d5c:	8c 4d 1c 00 	mov	r13,	28(r12)	; 0x001c

00007d60 <.Loc.464.1>:
    port->ie |= (1 << pad);
    7d60:	1c 41 04 00 	mov	4(r1),	r12	;
    7d64:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    7d68:	5d 41 03 00 	mov.b	3(r1),	r13	;
    7d6c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d6e:	b0 12 30 92 	call	#37424		;#0x9230
    7d72:	0d 4a       	mov	r10,	r13	;
    7d74:	0d dc       	bis	r12,	r13	;
    7d76:	1c 41 04 00 	mov	4(r1),	r12	;
    7d7a:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00007d7e <.L52>:
  }
}
    7d7e:	03 43       	nop			
    7d80:	31 52       	add	#8,	r1	;r2 As==11
    7d82:	0a 17       	popm	#1,	r10	;16-bit words
    7d84:	30 41       	ret			

00007d86 <_pal_lld_disablepadevent>:

void _pal_lld_disablepadevent(ioportid_t port, uint8_t pad) {
    7d86:	0a 15       	pushm	#1,	r10	;16-bit words

00007d88 <.LCFI12>:
    7d88:	21 82       	sub	#4,	r1	;r2 As==10

00007d8a <.LCFI13>:
    7d8a:	81 4c 02 00 	Address 0x0000000000007d8c is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00007d8c <L0>:
    7d8c:	02 00       	mova	@r0,	r2	;
    7d8e:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00007d92 <.Loc.470.1>:
  
  port->ie &= ~(1 << pad);
    7d92:	1c 41 02 00 	mov	2(r1),	r12	;
    7d96:	1a 4c 1a 00 	mov	26(r12),r10	;0x0001a
    7d9a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7d9e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7da0:	b0 12 30 92 	call	#37424		;#0x9230
    7da4:	3c e3       	inv	r12		;
    7da6:	0d 4a       	mov	r10,	r13	;
    7da8:	0d fc       	and	r12,	r13	;
    7daa:	1c 41 02 00 	mov	2(r1),	r12	;
    7dae:	8c 4d 1a 00 	mov	r13,	26(r12)	; 0x001a

00007db2 <.Loc.471.1>:
}
    7db2:	03 43       	nop			
    7db4:	21 52       	add	#4,	r1	;r2 As==10
    7db6:	0a 17       	popm	#1,	r10	;16-bit words
    7db8:	30 41       	ret			

00007dba <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7dba:	03 43       	nop			
    7dbc:	30 41       	ret			

00007dbe <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7dbe:	03 43       	nop			
    7dc0:	30 41       	ret			

00007dc2 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7dc2:	b0 12 ba 7d 	call	#32186		;#0x7dba

00007dc6 <.Loc.527.2>:
}
    7dc6:	03 43       	nop			
    7dc8:	30 41       	ret			

00007dca <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7dca:	b0 12 be 7d 	call	#32190		;#0x7dbe

00007dce <.Loc.538.2>:
}
    7dce:	03 43       	nop			
    7dd0:	30 41       	ret			

00007dd2 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    7dd2:	21 83       	decd	r1		;

00007dd4 <.LCFI1>:
    7dd4:	81 4c 00 00 	mov	r12,	0(r1)	;

00007dd8 <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    7dd8:	2c 41       	mov	@r1,	r12	;
    7dda:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00007dde <.Loc.768.2>:
}
    7dde:	03 43       	nop			
    7de0:	21 53       	incd	r1		;
    7de2:	30 41       	ret			

00007de4 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    7de4:	bf 15       	pushm	#12,	r15	;16-bit words

00007de6 <.LCFI6>:
    7de6:	21 82       	sub	#4,	r1	;r2 As==10

00007de8 <.LCFI7>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    7de8:	d2 43 38 51 	mov.b	#1,	&0x5138	;r3 As==01

00007dec <.Loc.87.3>:

  index = (DMAIV >> 1) - 1;
    7dec:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    7df0:	12 c3       	clrc			
    7df2:	0c 10       	rrc	r12		;
    7df4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7df8:	4d 4c       	mov.b	r12,	r13	;
    7dfa:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7dfc:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

00007e00 <.Loc.89.3>:

  if (index < MSP430X_DMA_CHANNELS) {
    7e00:	6c 43       	mov.b	#2,	r12	;r3 As==10
    7e02:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7e06:	1c 28       	jnc	$+58     	;abs 0x7e40

00007e08 <.LBB2>:
    osalSysLockFromISR();
    7e08:	b0 12 c2 7d 	call	#32194		;#0x7dc2

00007e0c <.Loc.91.3>:
    osalThreadDequeueNextI(&dma_queue, MSG_OK);
    7e0c:	4d 43       	clr.b	r13		;
    7e0e:	3c 40 d2 51 	mov	#20946,	r12	;#0x51d2
    7e12:	b0 12 7c 66 	call	#26236		;#0x667c

00007e16 <.Loc.92.3>:
    osalSysUnlockFromISR();
    7e16:	b0 12 ca 7d 	call	#32202		;#0x7dca

00007e1a <.Loc.94.3>:

    msp430x_dma_cb_t * cb = &callbacks[index];
    7e1a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7e1e:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    7e22:	0d 4c       	mov	r12,	r13	;
    7e24:	3d 50 c6 51 	add	#20934,	r13	;#0x51c6
    7e28:	81 4d 00 00 	mov	r13,	0(r1)	;

00007e2c <.Loc.97.3>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    7e2c:	2c 41       	mov	@r1,	r12	;
    7e2e:	2c 4c       	mov	@r12,	r12	;
    7e30:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e32:	06 24       	jz	$+14     	;abs 0x7e40

00007e34 <.Loc.98.3>:
      cb->callback(cb->args);
    7e34:	2c 41       	mov	@r1,	r12	;
    7e36:	2d 4c       	mov	@r12,	r13	;
    7e38:	2c 41       	mov	@r1,	r12	;
    7e3a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7e3e:	8d 12       	call	r13		;

00007e40 <.L14>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    7e40:	c2 43 38 51 	mov.b	#0,	&0x5138	;r3 As==00
    7e44:	b0 12 1e 64 	call	#25630		;#0x641e
    7e48:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7e4c:	0c 93       	cmp	#0,	r12	;r3 As==00
    7e4e:	02 24       	jz	$+6      	;abs 0x7e54

00007e50 <.Loc.102.3>:
    7e50:	b0 12 3a 64 	call	#25658		;#0x643a

00007e54 <.L16>:
}
    7e54:	03 43       	nop			
    7e56:	21 52       	add	#4,	r1	;r2 As==10
    7e58:	b4 17       	popm	#12,	r15	;16-bit words
    7e5a:	00 13       	reti			

00007e5c <dmaInit>:
 * @brief Initialize the DMA engine.
 *
 * @init
 */
void dmaInit(void) {
  osalThreadQueueObjectInit(&dma_queue);
    7e5c:	3c 40 d2 51 	mov	#20946,	r12	;#0x51d2
    7e60:	b0 12 d2 7d 	call	#32210		;#0x7dd2

00007e64 <.Loc.116.3>:
}
    7e64:	03 43       	nop			
    7e66:	30 41       	ret			

00007e68 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7e68:	03 43       	nop			
    7e6a:	30 41       	ret			

00007e6c <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7e6c:	03 43       	nop			
    7e6e:	30 41       	ret			

00007e70 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7e70:	b0 12 68 7e 	call	#32360		;#0x7e68

00007e74 <.Loc.527.2>:
}
    7e74:	03 43       	nop			
    7e76:	30 41       	ret			

00007e78 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7e78:	b0 12 6c 7e 	call	#32364		;#0x7e6c

00007e7c <.Loc.538.2>:
}
    7e7c:	03 43       	nop			
    7e7e:	30 41       	ret			

00007e80 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    7e80:	21 82       	sub	#4,	r1	;r2 As==10

00007e82 <.LCFI0>:
    7e82:	81 4c 02 00 	mov	r12,	2(r1)	;
    7e86:	81 4d 00 00 	mov	r13,	0(r1)	;

00007e8a <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7e8a:	2d 41       	mov	@r1,	r13	;
    7e8c:	1c 41 02 00 	mov	2(r1),	r12	;
    7e90:	b0 12 ea 64 	call	#25834		;#0x64ea

00007e94 <.Loc.740.2>:
}
    7e94:	03 43       	nop			
    7e96:	21 52       	add	#4,	r1	;r2 As==10
    7e98:	30 41       	ret			

00007e9a <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * spip) {
    7e9a:	21 83       	decd	r1		;

00007e9c <.LCFI2>:
    7e9c:	81 4c 00 00 	mov	r12,	0(r1)	;

00007ea0 <.Loc.136.3>:

  /* So that future transfers will actually work */
  *(((SPIDriver *)spip)->ifg) &= ~(UCTXIFG);
    7ea0:	2c 41       	mov	@r1,	r12	;
    7ea2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7ea6:	2d 41       	mov	@r1,	r13	;
    7ea8:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    7eac:	2d 4d       	mov	@r13,	r13	;
    7eae:	2d c3       	bic	#2,	r13	;r3 As==10
    7eb0:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007eb4 <.Loc.140.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code((SPIDriver *)spip);
    7eb4:	2c 41       	mov	@r1,	r12	;
    7eb6:	1c 4c 02 00 	mov	2(r12),	r12	;
    7eba:	2c 4c       	mov	@r12,	r12	;
    7ebc:	0c 93       	cmp	#0,	r12	;r3 As==00
    7ebe:	11 24       	jz	$+36     	;abs 0x7ee2

00007ec0 <.Loc.140.3>:
    7ec0:	2c 41       	mov	@r1,	r12	;
    7ec2:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    7ec6:	2c 41       	mov	@r1,	r12	;
    7ec8:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ecc:	2d 4c       	mov	@r12,	r13	;
    7ece:	2c 41       	mov	@r1,	r12	;
    7ed0:	8d 12       	call	r13		;
    7ed2:	2c 41       	mov	@r1,	r12	;
    7ed4:	6c 4c       	mov.b	@r12,	r12	;
    7ed6:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    7ed8:	07 20       	jnz	$+16     	;abs 0x7ee8

00007eda <.Loc.140.3>:
    7eda:	2c 41       	mov	@r1,	r12	;
    7edc:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7ee0:	03 3c       	jmp	$+8      	;abs 0x7ee8

00007ee2 <.L8>:
    7ee2:	2c 41       	mov	@r1,	r12	;
    7ee4:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00007ee8 <.L10>:
    7ee8:	b0 12 70 7e 	call	#32368		;#0x7e70
    7eec:	2c 41       	mov	@r1,	r12	;
    7eee:	2c 52       	add	#4,	r12	;r2 As==10
    7ef0:	4d 43       	clr.b	r13		;
    7ef2:	b0 12 80 7e 	call	#32384		;#0x7e80
    7ef6:	b0 12 78 7e 	call	#32376		;#0x7e78

00007efa <.Loc.141.3>:
}
    7efa:	03 43       	nop			
    7efc:	21 53       	incd	r1		;
    7efe:	30 41       	ret			

00007f00 <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    7f00:	3c 40 d4 51 	Address 0x0000000000007f02 is out of bounds.
mov	#65535,	r12	;#0xffff

00007f02 <L0>:
    7f02:	d4 51 b0 12 	add.b	4784(r1),28714(r4);0x012b0, 0x702a
    7f06:	2a 70 

00007f08 <.Loc.182.3>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    7f08:	b2 40 e0 05 	mov	#1504,	&0x51dc	;#0x05e0
    7f0c:	dc 51 

00007f0e <.Loc.183.3>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    7f0e:	b2 40 fc 05 	mov	#1532,	&0x51de	;#0x05fc
    7f12:	de 51 

00007f14 <.Loc.184.3>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    7f14:	b2 40 11 00 	mov	#17,	&0x51ec	;#0x0011
    7f18:	ec 51 

00007f1a <.Loc.185.3>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    7f1a:	b2 40 10 00 	mov	#16,	&0x51fe	;#0x0010
    7f1e:	fe 51 

00007f20 <.Loc.186.3>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    7f20:	1c 42 dc 51 	mov	&0x51dc,r12	;0x51dc
    7f24:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    7f28:	82 4c e2 51 	mov	r12,	&0x51e2	;

00007f2c <.Loc.187.3>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    7f2c:	1c 42 dc 51 	mov	&0x51dc,r12	;0x51dc
    7f30:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7f34:	82 4c f2 51 	mov	r12,	&0x51f2	;

00007f38 <.Loc.188.3>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7f38:	b2 40 c0 00 	mov	#192,	&0x51e8	;#0x00c0
    7f3c:	e8 51 

00007f3e <.Loc.189.3>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7f3e:	b2 40 c0 00 	mov	#192,	&0x51fa	;#0x00c0
    7f42:	fa 51 

00007f44 <.Loc.190.3>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7f44:	82 43 ea 51 	mov	#0,	&0x51ea	;r3 As==00

00007f48 <.Loc.191.3>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7f48:	82 43 fc 51 	mov	#0,	&0x51fc	;r3 As==00

00007f4c <.Loc.192.3>:
  SPIDA1.tx_req.callback.callback = NULL;
    7f4c:	82 43 ee 51 	mov	#0,	&0x51ee	;r3 As==00

00007f50 <.Loc.193.3>:
  SPIDA1.tx_req.callback.args     = NULL;
    7f50:	82 43 f0 51 	mov	#0,	&0x51f0	;r3 As==00

00007f54 <.Loc.194.3>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    7f54:	b2 40 9a 7e 	mov	#32410,	&0x5200	;#0x7e9a
    7f58:	00 52 

00007f5a <.Loc.195.3>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    7f5a:	b2 40 d4 51 	mov	#20948,	&0x5202	;#0x51d4
    7f5e:	02 52 

00007f60 <.Loc.311.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    7f60:	03 43       	nop			
    7f62:	30 41       	ret			

00007f64 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver * spip) {
    7f64:	31 80 06 00 	sub	#6,	r1	;

00007f68 <.LCFI3>:
    7f68:	81 4c 00 00 	mov	r12,	0(r1)	;

00007f6c <.Loc.337.3>:
      b = dmaAcquireI(&(spip->dmarx), spip->config->dmarx_index);
      osalDbgAssert(!b, "stream already allocated");
    }
#endif /* MSP430X_SPI_EXCLUSIVE_DMA */
  }
  uint16_t brw = 0;
    7f6c:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00007f70 <.Loc.338.3>:
  uint8_t ssel = 0;
    7f70:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00007f74 <.Loc.346.3>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA0_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIA1
  if (spip == &SPIDA1) {
    7f74:	b1 90 d4 51 	cmp	#20948,	0(r1)	;#0x51d4
    7f78:	00 00 
    7f7a:	14 20       	jnz	$+42     	;abs 0x7fa4

00007f7c <.Loc.347.3>:
    brw  = MSP430X_SPIA1_CLK_FREQ / spip->config->bit_rate;
    7f7c:	2c 41       	mov	@r1,	r12	;
    7f7e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7f82:	1d 4c 06 00 	mov	6(r12),	r13	;
    7f86:	1c 4c 04 00 	mov	4(r12),	r12	;
    7f8a:	0e 4c       	mov	r12,	r14	;
    7f8c:	0f 4d       	mov	r13,	r15	;
    7f8e:	3c 40 90 d0 	mov	#53392,	r12	;#0xd090
    7f92:	7d 40 03 00 	mov.b	#3,	r13	;
    7f96:	b0 12 fe 91 	call	#37374		;#0x91fe
    7f9a:	81 4c 04 00 	mov	r12,	4(r1)	;

00007f9e <.Loc.348.3>:
    ssel = MSP430X_SPIA1_UCSSEL;
    7f9e:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    7fa2:	03 00 

00007fa4 <.L13>:
    brw  = MSP430X_SPIB3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIB3_UCSSEL;
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
    7fa4:	2c 41       	mov	@r1,	r12	;
    7fa6:	1c 4c 08 00 	mov	8(r12),	r12	;
    7faa:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00007fae <.Loc.389.3>:
  spip->regs->brw   = brw;
    7fae:	2c 41       	mov	@r1,	r12	;
    7fb0:	1c 4c 08 00 	mov	8(r12),	r12	;
    7fb4:	9c 41 04 00 	mov	4(r1),	6(r12)	;
    7fb8:	06 00 

00007fba <.Loc.390.3>:
  spip->regs->ctlw0 =
    7fba:	2c 41       	mov	@r1,	r12	;
    7fbc:	1d 4c 08 00 	mov	8(r12),	r13	;

00007fc0 <.Loc.391.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7fc0:	2c 41       	mov	@r1,	r12	;
    7fc2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fc6:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7fca:	6c e3       	xor.b	#2,	r12	;r3 As==10
    7fcc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7fd0:	0e 4c       	mov	r12,	r14	;
    7fd2:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    7fd6:	2c 41       	mov	@r1,	r12	;
    7fd8:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fdc:	5c 4c 08 00 	mov.b	8(r12),	r12	;
    7fe0:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    7fe4:	0e dc       	bis	r12,	r14	;

00007fe6 <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7fe6:	2c 41       	mov	@r1,	r12	;
    7fe8:	1c 4c 02 00 	mov	2(r12),	r12	;
    7fec:	5c 4c 09 00 	mov.b	9(r12),	r12	;
    7ff0:	4b 18 0c 5c 	rpt #12 { rlax.w	r12		;

00007ff4 <.Loc.391.3>:
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7ff4:	0c de       	bis	r14,	r12	;

00007ff6 <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7ff6:	0e 4c       	mov	r12,	r14	;
    7ff8:	3e d0 00 08 	bis	#2048,	r14	;#0x0800

00007ffc <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    7ffc:	2c 41       	mov	@r1,	r12	;
    7ffe:	1c 4c 02 00 	mov	2(r12),	r12	;
    8002:	1c 4c 02 00 	mov	2(r12),	r12	;
    8006:	0c 93       	cmp	#0,	r12	;r3 As==00
    8008:	02 24       	jz	$+6      	;abs 0x800e

0000800a <.Loc.393.3>:
    800a:	4c 43       	clr.b	r12		;
    800c:	02 3c       	jmp	$+6      	;abs 0x8012

0000800e <.L14>:
    800e:	3c 40 00 04 	mov	#1024,	r12	;#0x0400

00008012 <.L15>:
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
    8012:	0c de       	bis	r14,	r12	;

00008014 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    8014:	0e 4c       	mov	r12,	r14	;
    8016:	3e d0 00 01 	bis	#256,	r14	;#0x0100
    801a:	5c 41 03 00 	mov.b	3(r1),	r12	;
    801e:	0c de       	bis	r14,	r12	;
    8020:	2c d3       	bis	#2,	r12	;r3 As==10

00008022 <.Loc.390.3>:
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
    8022:	8d 4c 00 00 	mov	r12,	0(r13)	;

00008026 <.Loc.394.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
  *(spip->ifg) = 0;
    8026:	2c 41       	mov	@r1,	r12	;
    8028:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    802c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00008030 <.Loc.395.3>:
  spi_lld_unselect(spip);
    8030:	2c 41       	mov	@r1,	r12	;
    8032:	b0 12 9e 80 	call	#32926		;#0x809e

00008036 <.Loc.396.3>:
}
    8036:	03 43       	nop			
    8038:	31 50 06 00 	add	#6,	r1	;
    803c:	30 41       	ret			

0000803e <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    803e:	1a 15       	pushm	#2,	r10	;16-bit words

00008040 <L0>:
    8040:	21 83       	decd	r1		;

00008042 <.LCFI6>:
    8042:	81 4c 00 00 	mov	r12,	0(r1)	;

00008046 <.Loc.430.3>:

  if (spip->config->ss_line) {
    8046:	2c 41       	mov	@r1,	r12	;
    8048:	1c 4c 02 00 	mov	2(r12),	r12	;
    804c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8050:	0c 93       	cmp	#0,	r12	;r3 As==00
    8052:	21 24       	jz	$+68     	;abs 0x8096

00008054 <.Loc.431.3>:
    palClearLine(spip->config->ss_line);
    8054:	2c 41       	mov	@r1,	r12	;
    8056:	1c 4c 02 00 	mov	2(r12),	r12	;
    805a:	1c 4c 02 00 	mov	2(r12),	r12	;
    805e:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8062:	0a 4c       	mov	r12,	r10	;
    8064:	2c 41       	mov	@r1,	r12	;
    8066:	1c 4c 02 00 	mov	2(r12),	r12	;
    806a:	1c 4c 02 00 	mov	2(r12),	r12	;
    806e:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8072:	19 4c 02 00 	mov	2(r12),	r9	;
    8076:	2c 41       	mov	@r1,	r12	;
    8078:	1c 4c 02 00 	mov	2(r12),	r12	;
    807c:	1c 4c 02 00 	mov	2(r12),	r12	;
    8080:	0d 4c       	mov	r12,	r13	;
    8082:	5d 03       	rrum	#1,	r13	;
    8084:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8088:	5c 43       	mov.b	#1,	r12	;r3 As==01
    808a:	b0 12 30 92 	call	#37424		;#0x9230
    808e:	3c e3       	inv	r12		;
    8090:	0c f9       	and	r9,	r12	;
    8092:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008096 <.L21>:
  }
}
    8096:	03 43       	nop			
    8098:	21 53       	incd	r1		;
    809a:	19 17       	popm	#2,	r10	;16-bit words
    809c:	30 41       	ret			

0000809e <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    809e:	1a 15       	pushm	#2,	r10	;16-bit words

000080a0 <.LCFI7>:
    80a0:	21 83       	decd	r1		;

000080a2 <.LCFI8>:
    80a2:	81 4c 00 00 	mov	r12,	0(r1)	;

000080a6 <.Loc.445.3>:

  if (spip->config->ss_line) {
    80a6:	2c 41       	mov	@r1,	r12	;
    80a8:	1c 4c 02 00 	mov	2(r12),	r12	;
    80ac:	1c 4c 02 00 	mov	2(r12),	r12	;
    80b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    80b2:	20 24       	jz	$+66     	;abs 0x80f4

000080b4 <.Loc.446.3>:
    palSetLine(spip->config->ss_line);
    80b4:	2c 41       	mov	@r1,	r12	;
    80b6:	1c 4c 02 00 	mov	2(r12),	r12	;
    80ba:	1c 4c 02 00 	mov	2(r12),	r12	;
    80be:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    80c2:	0a 4c       	mov	r12,	r10	;
    80c4:	2c 41       	mov	@r1,	r12	;
    80c6:	1c 4c 02 00 	mov	2(r12),	r12	;
    80ca:	1c 4c 02 00 	mov	2(r12),	r12	;
    80ce:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    80d2:	19 4c 02 00 	mov	2(r12),	r9	;
    80d6:	2c 41       	mov	@r1,	r12	;
    80d8:	1c 4c 02 00 	mov	2(r12),	r12	;
    80dc:	1c 4c 02 00 	mov	2(r12),	r12	;
    80e0:	0d 4c       	mov	r12,	r13	;
    80e2:	5d 03       	rrum	#1,	r13	;
    80e4:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    80e8:	5c 43       	mov.b	#1,	r12	;r3 As==01
    80ea:	b0 12 30 92 	call	#37424		;#0x9230
    80ee:	0c d9       	bis	r9,	r12	;
    80f0:	8a 4c 02 00 	mov	r12,	2(r10)	;

000080f4 <.L24>:
  }
}
    80f4:	03 43       	nop			
    80f6:	21 53       	incd	r1		;
    80f8:	19 17       	popm	#2,	r10	;16-bit words
    80fa:	30 41       	ret			

000080fc <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint8_t spi_lld_polled_exchange(SPIDriver * spip, uint8_t frame) {
    80fc:	21 82       	sub	#4,	r1	;r2 As==10

000080fe <.LCFI13>:
    80fe:	81 4c 02 00 	mov	r12,	2(r1)	;
    8102:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008106 <.Loc.571.3>:

  spip->regs->txbuf = frame;
    8106:	1c 41 02 00 	mov	2(r1),	r12	;
    810a:	1c 4c 08 00 	mov	8(r12),	r12	;
    810e:	5d 41 01 00 	mov.b	1(r1),	r13	;
    8112:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00008116 <.Loc.572.3>:
  while (!(*(spip->ifg) & UCRXIFG))
    8116:	03 43       	nop			

00008118 <.L30>:
    8118:	1c 41 02 00 	mov	2(r1),	r12	;
    811c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8120:	2c 4c       	mov	@r12,	r12	;
    8122:	5c f3       	and.b	#1,	r12	;r3 As==01
    8124:	0c 93       	cmp	#0,	r12	;r3 As==00
    8126:	f8 27       	jz	$-14     	;abs 0x8118

00008128 <.Loc.574.3>:
    ;
  *(spip->ifg) &= ~(UCRXIFG | UCTXIFG);
    8128:	1c 41 02 00 	mov	2(r1),	r12	;
    812c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    8130:	1d 41 02 00 	mov	2(r1),	r13	;
    8134:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    8138:	2d 4d       	mov	@r13,	r13	;
    813a:	3d f0 fc ff 	and	#65532,	r13	;#0xfffc
    813e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00008142 <.Loc.575.3>:
  return spip->regs->rxbuf;
    8142:	1c 41 02 00 	mov	2(r1),	r12	;
    8146:	1c 4c 08 00 	mov	8(r12),	r12	;
    814a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    814e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008152 <.Loc.576.3>:
}
    8152:	21 52       	add	#4,	r1	;r2 As==10
    8154:	30 41       	ret			

00008156 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    8156:	32 c2       	dint			

00008158 <.Loc.46.1>:

}
    8158:	03 43       	nop			
    815a:	30 41       	ret			

0000815c <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    815c:	32 c2       	dint			

0000815e <.Loc.348.1>:
  asm volatile("nop");
    815e:	03 43       	nop			

00008160 <.Loc.349.1>:
}
    8160:	03 43       	nop			
    8162:	30 41       	ret			

00008164 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    8164:	03 43       	nop			

00008166 <.Loc.356.1>:
  _enable_interrupts();
    8166:	32 d2       	eint			
    8168:	03 43       	nop			

0000816a <.Loc.357.1>:
}
    816a:	03 43       	nop			
    816c:	30 41       	ret			

0000816e <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    816e:	03 43       	nop			
    8170:	30 41       	ret			

00008172 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    8172:	03 43       	nop			
    8174:	30 41       	ret			

00008176 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    8176:	b0 12 5c 81 	call	#33116		;#0x815c

0000817a <.Loc.505.2>:
}
    817a:	03 43       	nop			
    817c:	30 41       	ret			

0000817e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    817e:	b0 12 64 81 	call	#33124		;#0x8164

00008182 <.Loc.516.2>:
}
    8182:	03 43       	nop			
    8184:	30 41       	ret			

00008186 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    8186:	b0 12 6e 81 	call	#33134		;#0x816e

0000818a <.Loc.527.2>:
}
    818a:	03 43       	nop			
    818c:	30 41       	ret			

0000818e <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    818e:	b0 12 72 81 	call	#33138		;#0x8172

00008192 <.Loc.538.2>:
}
    8192:	03 43       	nop			
    8194:	30 41       	ret			

00008196 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
    8196:	21 83       	decd	r1		;

00008198 <.LCFI1>:
    8198:	81 4c 00 00 	mov	r12,	0(r1)	;

0000819c <.Loc.684.2>:

  chThdSleep(time);
    819c:	2c 41       	mov	@r1,	r12	;
    819e:	b0 12 22 65 	call	#25890		;#0x6522

000081a2 <.Loc.685.2>:
}
    81a2:	03 43       	nop			
    81a4:	21 53       	incd	r1		;
    81a6:	30 41       	ret			

000081a8 <osalThreadSuspendTimeoutS>:
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {
    81a8:	21 82       	sub	#4,	r1	;r2 As==10

000081aa <.LCFI2>:
    81aa:	81 4c 02 00 	mov	r12,	2(r1)	;
    81ae:	81 4d 00 00 	mov	r13,	0(r1)	;

000081b2 <.Loc.724.2>:

  return chThdSuspendTimeoutS(trp, timeout);
    81b2:	2d 41       	mov	@r1,	r13	;
    81b4:	1c 41 02 00 	mov	2(r1),	r12	;
    81b8:	b0 12 be 64 	call	#25790		;#0x64be

000081bc <.Loc.725.2>:
}
    81bc:	21 52       	add	#4,	r1	;r2 As==10
    81be:	30 41       	ret			

000081c0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    81c0:	21 82       	sub	#4,	r1	;r2 As==10

000081c2 <.LCFI3>:
    81c2:	81 4c 02 00 	mov	r12,	2(r1)	;
    81c6:	81 4d 00 00 	mov	r13,	0(r1)	;

000081ca <.Loc.739.2>:

  chThdResumeI(trp, msg);
    81ca:	2d 41       	mov	@r1,	r13	;
    81cc:	1c 41 02 00 	mov	2(r1),	r12	;
    81d0:	b0 12 ea 64 	call	#25834		;#0x64ea

000081d4 <.Loc.740.2>:
}
    81d4:	03 43       	nop			
    81d6:	21 52       	add	#4,	r1	;r2 As==10
    81d8:	30 41       	ret			

000081da <blockuntil_callback>:
  /* Set up for DMA retrieval of remaining packet */
}
#endif /* ADAMANT ONLY - REMOVE BEFORE COMMIT */

static void blockuntil_callback(void) {
  osalSysLockFromISR();
    81da:	b0 12 86 81 	call	#33158		;#0x8186

000081de <.Loc.120.3>:
  osalThreadResumeI(&tr, MSG_OK);
    81de:	4d 43       	clr.b	r13		;
    81e0:	3c 40 04 52 	mov	#20996,	r12	;#0x5204
    81e4:	b0 12 c0 81 	call	#33216		;#0x81c0

000081e8 <.Loc.121.3>:
  osalSysUnlockFromISR();
    81e8:	b0 12 8e 81 	call	#33166		;#0x818e

000081ec <.Loc.122.3>:
}
    81ec:	03 43       	nop			
    81ee:	30 41       	ret			

000081f0 <sx1212ReadRegister>:
 * 
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] reg     register address
 * @return            the read value
 */
static uint8_t sx1212ReadRegister(SX1212Driver *devp, uint8_t reg) {
    81f0:	21 82       	sub	#4,	r1	;r2 As==10

000081f2 <.LCFI4>:
    81f2:	81 4c 02 00 	mov	r12,	2(r1)	;
    81f6:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000081fa <.Loc.143.3>:
  
  osalDbgAssert(reg <= 30, "register address out of bounds");
  
  /* 01xxxxx0 - set read bit */
  reg = (0x40 | (reg << 1));
    81fa:	5c 41 01 00 	mov.b	1(r1),	r12	;
    81fe:	0c 5c       	rla	r12		;
    8200:	8c 11       	sxt	r12		;
    8202:	7c d0 40 00 	bis.b	#64,	r12	;#0x0040
    8206:	8c 11       	sxt	r12		;
    8208:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

0000820c <.Loc.146.3>:
  
  /* assume we're already in config mode - see precondition */
  spiSelect(devp->config->spip);
    820c:	1c 41 02 00 	mov	2(r1),	r12	;
    8210:	2c 4c       	mov	@r12,	r12	;
    8212:	2c 4c       	mov	@r12,	r12	;
    8214:	b0 12 82 70 	call	#28802		;#0x7082

00008218 <.Loc.147.3>:
  spiPolledExchange(devp->config->spip, reg);
    8218:	1c 41 02 00 	mov	2(r1),	r12	;
    821c:	2c 4c       	mov	@r12,	r12	;
    821e:	2c 4c       	mov	@r12,	r12	;
    8220:	5d 41 01 00 	mov.b	1(r1),	r13	;
    8224:	b0 12 fc 80 	call	#33020		;#0x80fc

00008228 <.Loc.148.3>:
  reg = spiPolledExchange(devp->config->spip, 0xFFU);
    8228:	1c 41 02 00 	mov	2(r1),	r12	;
    822c:	2c 4c       	mov	@r12,	r12	;
    822e:	2c 4c       	mov	@r12,	r12	;
    8230:	7d 43       	mov.b	#-1,	r13	;r3 As==11
    8232:	b0 12 fc 80 	call	#33020		;#0x80fc
    8236:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

0000823a <.Loc.149.3>:
  spiUnselect(devp->config->spip);
    823a:	1c 41 02 00 	mov	2(r1),	r12	;
    823e:	2c 4c       	mov	@r12,	r12	;
    8240:	2c 4c       	mov	@r12,	r12	;
    8242:	b0 12 9c 70 	call	#28828		;#0x709c

00008246 <.Loc.151.3>:
  
  return reg;
    8246:	5c 41 01 00 	mov.b	1(r1),	r12	;

0000824a <.Loc.152.3>:
}
    824a:	21 52       	add	#4,	r1	;r2 As==10
    824c:	30 41       	ret			

0000824e <sx1212SetRegister>:
 * @param[in] reg     register address
 * @param[in] value   the value to be written
 * @return            the previous value of the register
 */
static uint8_t sx1212SetRegister(SX1212Driver *devp, uint8_t reg, 
    uint8_t value) {
    824e:	21 82       	sub	#4,	r1	;r2 As==10

00008250 <.LCFI5>:
    8250:	81 4c 02 00 	mov	r12,	2(r1)	;
    8254:	c1 4d 01 00 	mov.b	r13,	1(r1)	;
    8258:	c1 4e 00 00 	mov.b	r14,	0(r1)	;

0000825c <.Loc.173.3>:
  osalDbgAssert(reg <= 30, "register address out of bounds");
  
  osalDbgAssert(reg != 20, "setting read-only registers");
  
  /* 00xxxxx0 */
  reg = (reg << 1);
    825c:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8260:	4c 5c       	rla.b	r12		;
    8262:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00008266 <.Loc.176.3>:
  
  /* assume we're already in config mode - see precondition */
  spiSelect(devp->config->spip);
    8266:	1c 41 02 00 	mov	2(r1),	r12	;
    826a:	2c 4c       	mov	@r12,	r12	;
    826c:	2c 4c       	mov	@r12,	r12	;
    826e:	b0 12 82 70 	call	#28802		;#0x7082

00008272 <.Loc.177.3>:
  spiPolledExchange(devp->config->spip, reg);
    8272:	1c 41 02 00 	mov	2(r1),	r12	;
    8276:	2c 4c       	mov	@r12,	r12	;
    8278:	2c 4c       	mov	@r12,	r12	;
    827a:	5d 41 01 00 	mov.b	1(r1),	r13	;
    827e:	b0 12 fc 80 	call	#33020		;#0x80fc

00008282 <.Loc.178.3>:
  reg = spiPolledExchange(devp->config->spip, value);
    8282:	1c 41 02 00 	mov	2(r1),	r12	;
    8286:	2c 4c       	mov	@r12,	r12	;
    8288:	2c 4c       	mov	@r12,	r12	;
    828a:	6d 41       	mov.b	@r1,	r13	;
    828c:	b0 12 fc 80 	call	#33020		;#0x80fc
    8290:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00008294 <.Loc.179.3>:
  spiUnselect(devp->config->spip);
    8294:	1c 41 02 00 	mov	2(r1),	r12	;
    8298:	2c 4c       	mov	@r12,	r12	;
    829a:	2c 4c       	mov	@r12,	r12	;
    829c:	b0 12 9c 70 	call	#28828		;#0x709c

000082a0 <.Loc.181.3>:
  
  return reg;
    82a0:	5c 41 01 00 	mov.b	1(r1),	r12	;

000082a4 <.Loc.182.3>:
}
    82a4:	21 52       	add	#4,	r1	;r2 As==10
    82a6:	30 41       	ret			

000082a8 <irq_block_with_timeout>:
 * @return  @p MSG_OK, or @p MSG_TIMEOUT if timeout occurs
 * 
 * @notapi
 */
static msg_t irq_block_with_timeout(SX1212Driver *devp, ioline_t irq, 
    systime_t timeout) {
    82a8:	0a 15       	pushm	#1,	r10	;16-bit words

000082aa <.LCFI7>:
    82aa:	31 80 06 00 	sub	#6,	r1	;

000082ae <.LCFI8>:
    82ae:	81 4c 04 00 	mov	r12,	4(r1)	;
    82b2:	81 4d 02 00 	mov	r13,	2(r1)	;
    82b6:	81 4e 00 00 	mov	r14,	0(r1)	;

000082ba <.Loc.236.3>:
  spiReleaseBus(devp->config->spip);
#else
  /* suppress warning */
  (void)devp;
#endif
  osalSysLock();
    82ba:	b0 12 76 81 	call	#33142		;#0x8176

000082be <.Loc.237.3>:
  palLineEnableEventI(irq, PAL_EVENT_MODE_RISING_EDGE, blockuntil_callback); 
    82be:	1c 41 02 00 	mov	2(r1),	r12	;
    82c2:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    82c6:	0a 4c       	mov	r12,	r10	;
    82c8:	1c 41 02 00 	mov	2(r1),	r12	;
    82cc:	b0 12 8c 92 	call	#37516		;#0x928c
    82d0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    82d4:	3f 40 da 81 	mov	#33242,	r15	;#0x81da
    82d8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    82da:	4d 4c       	mov.b	r12,	r13	;
    82dc:	0c 4a       	mov	r10,	r12	;
    82de:	b0 12 70 7c 	call	#31856		;#0x7c70

000082e2 <.Loc.238.3>:
  if (palReadLine(irq)) {
    82e2:	1c 41 02 00 	mov	2(r1),	r12	;
    82e6:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    82ea:	2a 4c       	mov	@r12,	r10	;
    82ec:	1c 41 02 00 	mov	2(r1),	r12	;
    82f0:	b0 12 8c 92 	call	#37516		;#0x928c
    82f4:	0d 4c       	mov	r12,	r13	;
    82f6:	0c 4a       	mov	r10,	r12	;
    82f8:	b0 12 c4 92 	call	#37572		;#0x92c4
    82fc:	5c f3       	and.b	#1,	r12	;r3 As==01
    82fe:	0c 93       	cmp	#0,	r12	;r3 As==00
    8300:	03 24       	jz	$+8      	;abs 0x8308

00008302 <.Loc.239.3>:
    suspend_result = MSG_OK;
    8302:	82 43 06 52 	mov	#0,	&0x5206	;r3 As==00
    8306:	07 3c       	jmp	$+16     	;abs 0x8316

00008308 <.L29>:
  }
  else {
    suspend_result = osalThreadSuspendTimeoutS(&tr, timeout);
    8308:	2d 41       	mov	@r1,	r13	;
    830a:	3c 40 04 52 	mov	#20996,	r12	;#0x5204
    830e:	b0 12 a8 81 	call	#33192		;#0x81a8
    8312:	82 4c 06 52 	mov	r12,	&0x5206	;

00008316 <.L30>:
  }
  
  /* Disable interrupt */
  palLineDisableEventI(irq);
    8316:	1c 41 02 00 	mov	2(r1),	r12	;
    831a:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    831e:	0a 4c       	mov	r12,	r10	;
    8320:	1c 41 02 00 	mov	2(r1),	r12	;
    8324:	b0 12 8c 92 	call	#37516		;#0x928c
    8328:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    832c:	4d 4c       	mov.b	r12,	r13	;
    832e:	0c 4a       	mov	r10,	r12	;
    8330:	b0 12 86 7d 	call	#32134		;#0x7d86

00008334 <.Loc.247.3>:
  osalSysUnlock();
    8334:	b0 12 7e 81 	call	#33150		;#0x817e

00008338 <.Loc.255.3>:
#if SX1212_SHARED_SPI
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  return suspend_result;
    8338:	1c 42 06 52 	mov	&0x5206,r12	;0x5206

0000833c <.Loc.256.3>:
}
    833c:	31 50 06 00 	add	#6,	r1	;
    8340:	0a 17       	popm	#1,	r10	;16-bit words
    8342:	30 41       	ret			

00008344 <gcd>:
 *          
 * @note    Many sources for this algorithm exist
 * 
 * @notapi
 */
static uint32_t gcd(uint32_t u, uint32_t v) {
    8344:	6a 15       	pushm	#7,	r10	;16-bit words

00008346 <L0>:
    8346:	31 80 0e 00 	sub	#14,	r1	;#0x000e

0000834a <.LCFI15>:
    834a:	81 4c 04 00 	mov	r12,	4(r1)	;
    834e:	81 4d 06 00 	mov	r13,	6(r1)	;
    8352:	81 4e 00 00 	mov	r14,	0(r1)	;
    8356:	81 4f 02 00 	mov	r15,	2(r1)	;

0000835a <.Loc.394.3>:
  int shift;
  
  osalDbgAssert(u != 0 && v != 0, "doesn't support 0s");
  
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    835a:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c
    835e:	0b 3c       	jmp	$+24     	;abs 0x8376

00008360 <.L47>:
    u >>= 1;
    8360:	12 c3       	clrc			
    8362:	11 10 06 00 	rrc	6(r1)		;
    8366:	11 10 04 00 	rrc	4(r1)		;

0000836a <.Loc.396.3>:
    v >>= 1;
    836a:	12 c3       	clrc			
    836c:	11 10 02 00 	rrc	2(r1)		;
    8370:	21 10       	rrc	@r1		;

00008372 <.Loc.394.3>:
static uint32_t gcd(uint32_t u, uint32_t v) {
  int shift;
  
  osalDbgAssert(u != 0 && v != 0, "doesn't support 0s");
  
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    8372:	91 53 0c 00 	inc	12(r1)		;

00008376 <.L46>:
    8376:	14 41 04 00 	mov	4(r1),	r4	;
    837a:	24 d1       	bis	@r1,	r4	;
    837c:	15 41 06 00 	mov	6(r1),	r5	;
    8380:	15 d1 02 00 	bis	2(r1),	r5	;
    8384:	06 44       	mov	r4,	r6	;
    8386:	56 f3       	and.b	#1,	r6	;r3 As==01
    8388:	07 45       	mov	r5,	r7	;
    838a:	37 c3       	bic	#-1,	r7	;r3 As==11
    838c:	0c 46       	mov	r6,	r12	;
    838e:	0c d7       	bis	r7,	r12	;
    8390:	0c 93       	cmp	#0,	r12	;r3 As==00
    8392:	e6 27       	jz	$-50     	;abs 0x8360

00008394 <.Loc.399.3>:
    u >>= 1;
    v >>= 1;
  }
  
  while((u & 1) == 0)
    8394:	05 3c       	jmp	$+12     	;abs 0x83a0

00008396 <.L50>:
    u >>= 1;
    8396:	12 c3       	clrc			
    8398:	11 10 06 00 	rrc	6(r1)		;
    839c:	11 10 04 00 	rrc	4(r1)		;

000083a0 <.L49>:
  for (shift = 0; ((u | v) & 1) == 0; ++shift) {
    u >>= 1;
    v >>= 1;
  }
  
  while((u & 1) == 0)
    83a0:	18 41 04 00 	mov	4(r1),	r8	;
    83a4:	58 f3       	and.b	#1,	r8	;r3 As==01
    83a6:	19 41 06 00 	mov	6(r1),	r9	;
    83aa:	39 c3       	bic	#-1,	r9	;r3 As==11
    83ac:	0c 48       	mov	r8,	r12	;
    83ae:	0c d9       	bis	r9,	r12	;
    83b0:	0c 93       	cmp	#0,	r12	;r3 As==00
    83b2:	f1 27       	jz	$-28     	;abs 0x8396

000083b4 <.Loc.403.3>:
    u >>= 1;
  
  do {
    while ((v & 1) == 0)
    83b4:	04 3c       	jmp	$+10     	;abs 0x83be

000083b6 <.L53>:
      v >>= 1;
    83b6:	12 c3       	clrc			
    83b8:	11 10 02 00 	rrc	2(r1)		;
    83bc:	21 10       	rrc	@r1		;

000083be <.L52>:
  
  while((u & 1) == 0)
    u >>= 1;
  
  do {
    while ((v & 1) == 0)
    83be:	2a 41       	mov	@r1,	r10	;
    83c0:	5a f3       	and.b	#1,	r10	;r3 As==01
    83c2:	1b 41 02 00 	mov	2(r1),	r11	;
    83c6:	3b c3       	bic	#-1,	r11	;r3 As==11
    83c8:	0c 4a       	mov	r10,	r12	;
    83ca:	0c db       	bis	r11,	r12	;
    83cc:	0c 93       	cmp	#0,	r12	;r3 As==00
    83ce:	f3 27       	jz	$-24     	;abs 0x83b6

000083d0 <.Loc.406.3>:
      v >>= 1;
    
    if (u > v) {
    83d0:	91 91 06 00 	cmp	6(r1),	2(r1)	;
    83d4:	02 00 
    83d6:	08 28       	jnc	$+18     	;abs 0x83e8
    83d8:	91 91 02 00 	cmp	2(r1),	6(r1)	;
    83dc:	06 00 
    83de:	15 20       	jnz	$+44     	;abs 0x840a
    83e0:	91 91 04 00 	cmp	4(r1),	0(r1)	;
    83e4:	00 00 
    83e6:	11 2c       	jc	$+36     	;abs 0x840a

000083e8 <.L59>:
      uint32_t t = v;
    83e8:	a1 41 08 00 	mov	@r1,	8(r1)	;
    83ec:	91 41 02 00 	mov	2(r1),	10(r1)	; 0x000a
    83f0:	0a 00 

000083f2 <.Loc.408.3>:
      v = u;
    83f2:	91 41 04 00 	mov	4(r1),	0(r1)	;
    83f6:	00 00 
    83f8:	91 41 06 00 	mov	6(r1),	2(r1)	;
    83fc:	02 00 

000083fe <.Loc.409.3>:
      u = t;
    83fe:	91 41 08 00 	mov	8(r1),	4(r1)	;
    8402:	04 00 
    8404:	91 41 0a 00 	mov	10(r1),	6(r1)	;0x0000a
    8408:	06 00 

0000840a <.L55>:
    }
    v = v - u;
    840a:	91 81 04 00 	sub	4(r1),	0(r1)	;
    840e:	00 00 
    8410:	91 71 06 00 	subc	6(r1),	2(r1)	;
    8414:	02 00 

00008416 <.Loc.412.3>:
  } while (v != 0);
    8416:	2c 41       	mov	@r1,	r12	;
    8418:	1c d1 02 00 	bis	2(r1),	r12	;
    841c:	0c 93       	cmp	#0,	r12	;r3 As==00
    841e:	cf 23       	jnz	$-96     	;abs 0x83be

00008420 <.Loc.414.3>:
    
  return u << shift;
    8420:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    8424:	0e 4c       	mov	r12,	r14	;
    8426:	0f 43       	clr	r15		;
    8428:	1c 41 04 00 	mov	4(r1),	r12	;
    842c:	1d 41 06 00 	mov	6(r1),	r13	;
    8430:	b0 12 7a 92 	call	#37498		;#0x927a

00008434 <.Loc.415.3>:
}
    8434:	31 50 0e 00 	add	#14,	r1	;#0x000e
    8438:	64 17       	popm	#7,	r10	;16-bit words
    843a:	30 41       	ret			

0000843c <sx1212SetBitrate>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] rate bit rate in bits per second to be used
*/
static void sx1212SetBitrate(SX1212Driver *devp, uint32_t rate) {
    843c:	1a 15       	pushm	#2,	r10	;16-bit words

0000843e <.LCFI16>:
    843e:	31 80 10 00 	sub	#16,	r1	;#0x0010

00008442 <L0>:
    8442:	81 4c 04 00 	mov	r12,	4(r1)	;
    8446:	81 4d 00 00 	mov	r13,	0(r1)	;
    844a:	81 4e 02 00 	mov	r14,	2(r1)	;

0000844e <.Loc.433.3>:
  uint16_t tmp;
  
  osalDbgAssert(rate < 150000, "bit rate too high");
  
  /* Calculate the multiplier */
  rate = (SX1212_CLK_FREQ >> 1)/rate;
    844e:	2e 41       	mov	@r1,	r14	;
    8450:	1f 41 02 00 	mov	2(r1),	r15	;
    8454:	3c 40 00 a8 	mov	#43008,	r12	;#0xa800
    8458:	7d 40 61 00 	mov.b	#97,	r13	;#0x0061
    845c:	b0 12 fe 91 	call	#37374		;#0x91fe
    8460:	81 4c 00 00 	mov	r12,	0(r1)	;
    8464:	81 4d 02 00 	mov	r13,	2(r1)	;

00008468 <.Loc.435.3>:
  
  if (rate - 1 <= 255) {
    8468:	29 41       	mov	@r1,	r9	;
    846a:	39 53       	add	#-1,	r9	;r3 As==11
    846c:	1a 41 02 00 	mov	2(r1),	r10	;
    8470:	3a 63       	addc	#-1,	r10	;r3 As==11
    8472:	0c 4a       	mov	r10,	r12	;
    8474:	0c 93       	cmp	#0,	r12	;r3 As==00
    8476:	16 20       	jnz	$+46     	;abs 0x84a4
    8478:	0c 4a       	mov	r10,	r12	;
    847a:	0c 93       	cmp	#0,	r12	;r3 As==00
    847c:	04 20       	jnz	$+10     	;abs 0x8486
    847e:	7c 40 ff 00 	mov.b	#255,	r12	;#0x00ff
    8482:	0c 99       	cmp	r9,	r12	;
    8484:	0f 28       	jnc	$+32     	;abs 0x84a4

00008486 <.L69>:
    sx1212SetRegister(devp, MCParam3, (rate & 0x00FF));
    8486:	6c 41       	mov.b	@r1,	r12	;
    8488:	4e 4c       	mov.b	r12,	r14	;
    848a:	7d 40 03 00 	mov.b	#3,	r13	;
    848e:	1c 41 04 00 	mov	4(r1),	r12	;
    8492:	b0 12 4e 82 	call	#33358		;#0x824e

00008496 <.Loc.437.3>:
    sx1212SetRegister(devp, MCParam4, 0);
    8496:	4e 43       	clr.b	r14		;
    8498:	6d 42       	mov.b	#4,	r13	;r2 As==10
    849a:	1c 41 04 00 	mov	4(r1),	r12	;
    849e:	b0 12 4e 82 	call	#33358		;#0x824e

000084a2 <.Loc.458.3>:
      if (err == 0 || i*i > rate) break;
    }
    sx1212SetRegister(devp, MCParam3, bestc);
    sx1212SetRegister(devp, MCParam4, bestd);
  }
}
    84a2:	6a 3c       	jmp	$+214    	;abs 0x8578

000084a4 <.L61>:
    sx1212SetRegister(devp, MCParam4, 0);
  }
  else {
    uint8_t bestc;
    uint8_t bestd;
    uint8_t besterr = 0xffu;
    84a4:	f1 43 0b 00 	mov.b	#-1,	11(r1)	;r3 As==11, 0x000b

000084a8 <.LBB6>:
    uint8_t err;
    /* i is (C+1), up to the largest multiplier's square root */
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    84a8:	2c 41       	mov	@r1,	r12	;
    84aa:	1d 41 02 00 	mov	2(r1),	r13	;
    84ae:	7e 40 ff 00 	mov.b	#255,	r14	;#0x00ff
    84b2:	4f 43       	clr.b	r15		;
    84b4:	b0 12 fe 91 	call	#37374		;#0x91fe
    84b8:	0d 4c       	mov	r12,	r13	;
    84ba:	1d 53       	inc	r13		;
    84bc:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    84c0:	47 3c       	jmp	$+144    	;abs 0x8550

000084c2 <.L68>:
      /* Divide by i - this is (D+1) */
      tmp = rate / i;
    84c2:	1e 41 0c 00 	mov	12(r1),	r14	;0x0000c
    84c6:	0c 4e       	mov	r14,	r12	;
    84c8:	0d 43       	clr	r13		;
    84ca:	0e 4c       	mov	r12,	r14	;
    84cc:	0f 4d       	mov	r13,	r15	;
    84ce:	2c 41       	mov	@r1,	r12	;
    84d0:	1d 41 02 00 	mov	2(r1),	r13	;
    84d4:	b0 12 fe 91 	call	#37374		;#0x91fe
    84d8:	81 4c 08 00 	mov	r12,	8(r1)	;

000084dc <.Loc.448.3>:
      err = rate - (tmp * i);
    84dc:	6a 41       	mov.b	@r1,	r10	;
    84de:	1c 41 08 00 	mov	8(r1),	r12	;
    84e2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84e6:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    84ea:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    84ee:	b0 12 34 93 	call	#37684		;#0x9334
    84f2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    84f6:	4d 4a       	mov.b	r10,	r13	;
    84f8:	4d 8c       	sub.b	r12,	r13	;
    84fa:	c1 4d 07 00 	mov.b	r13,	7(r1)	;

000084fe <.Loc.449.3>:
      if (err < besterr) {
    84fe:	d1 91 0b 00 	cmp.b	11(r1),	7(r1)	;0x0000b
    8502:	07 00 
    8504:	10 2c       	jc	$+34     	;abs 0x8526

00008506 <.Loc.450.3>:
        bestc = i - 1;
    8506:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    850a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    850e:	4e 4c       	mov.b	r12,	r14	;
    8510:	7e 53       	add.b	#-1,	r14	;r3 As==11
    8512:	c1 4e 0f 00 	mov.b	r14,	15(r1)	; 0x000f

00008516 <.Loc.451.3>:
        bestd = tmp - 1;
    8516:	1c 41 08 00 	mov	8(r1),	r12	;
    851a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    851e:	4d 4c       	mov.b	r12,	r13	;
    8520:	7d 53       	add.b	#-1,	r13	;r3 As==11
    8522:	c1 4d 0e 00 	mov.b	r13,	14(r1)	; 0x000e

00008526 <.L65>:
      }
      if (err == 0 || i*i > rate) break;
    8526:	c1 93 07 00 	cmp.b	#0,	7(r1)	;r3 As==00
    852a:	17 24       	jz	$+48     	;abs 0x855a

0000852c <.Loc.453.3>:
    852c:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8530:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    8534:	b0 12 34 93 	call	#37684		;#0x9334
    8538:	0d 43       	clr	r13		;
    853a:	81 9d 02 00 	cmp	r13,	2(r1)	;
    853e:	0d 28       	jnc	$+28     	;abs 0x855a
    8540:	81 9d 02 00 	cmp	r13,	2(r1)	;
    8544:	03 20       	jnz	$+8      	;abs 0x854c
    8546:	81 9c 00 00 	cmp	r12,	0(r1)	;
    854a:	07 28       	jnc	$+16     	;abs 0x855a

0000854c <.L70>:
    uint8_t bestc;
    uint8_t bestd;
    uint8_t besterr = 0xffu;
    uint8_t err;
    /* i is (C+1), up to the largest multiplier's square root */
    for (unsigned int i = (rate / 255) + 1; i <= 92; i++) {
    854c:	91 53 0c 00 	inc	12(r1)		;

00008550 <.L64>:
    8550:	7c 40 5c 00 	mov.b	#92,	r12	;#0x005c
    8554:	1c 91 0c 00 	cmp	12(r1),	r12	;0x0000c
    8558:	b4 2f       	jc	$-150    	;abs 0x84c2

0000855a <.L66>:
        bestc = i - 1;
        bestd = tmp - 1;
      }
      if (err == 0 || i*i > rate) break;
    }
    sx1212SetRegister(devp, MCParam3, bestc);
    855a:	5e 41 0f 00 	mov.b	15(r1),	r14	;0x0000f
    855e:	7d 40 03 00 	mov.b	#3,	r13	;
    8562:	1c 41 04 00 	mov	4(r1),	r12	;
    8566:	b0 12 4e 82 	call	#33358		;#0x824e

0000856a <.Loc.456.3>:
    sx1212SetRegister(devp, MCParam4, bestd);
    856a:	5e 41 0e 00 	mov.b	14(r1),	r14	;0x0000e
    856e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    8570:	1c 41 04 00 	mov	4(r1),	r12	;
    8574:	b0 12 4e 82 	call	#33358		;#0x824e

00008578 <.L71>:
  }
}
    8578:	03 43       	nop			
    857a:	31 50 10 00 	add	#16,	r1	;#0x0010
    857e:	19 17       	popm	#2,	r10	;16-bit words
    8580:	30 41       	ret			

00008582 <sx1212SetDeviation>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp      pointer to the SX1212 driver
 * @param[in] deviation frequency deviation to be programmed, in Hz
*/
static void sx1212SetDeviation(SX1212Driver *devp, uint32_t fdev) {
    8582:	31 82       	sub	#8,	r1	;r2 As==11

00008584 <.LCFI18>:
    8584:	81 4c 04 00 	Address 0x0000000000008586 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00008586 <L0>:
    8586:	04 00       	mova	@r0,	r4	;
    8588:	81 4d 00 00 	mov	r13,	0(r1)	;
    858c:	81 4e 02 00 	mov	r14,	2(r1)	;

00008590 <.Loc.470.3>:
  uint16_t regs = (SX1212_CLK_FREQ >> 5) / fdev;
    8590:	2e 41       	mov	@r1,	r14	;
    8592:	1f 41 02 00 	mov	2(r1),	r15	;
    8596:	3c 40 80 1a 	mov	#6784,	r12	;#0x1a80
    859a:	7d 40 06 00 	mov.b	#6,	r13	;
    859e:	b0 12 fe 91 	call	#37374		;#0x91fe
    85a2:	81 4c 06 00 	mov	r12,	6(r1)	;

000085a6 <.Loc.474.3>:
  
  osalDbgAssert(fdev < 200000, "deviation too high");
  
  sx1212SetRegister(devp, MCParam2, regs - 1);
    85a6:	1c 41 06 00 	mov	6(r1),	r12	;
    85aa:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85ae:	7c 53       	add.b	#-1,	r12	;r3 As==11
    85b0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    85b4:	4e 4c       	mov.b	r12,	r14	;
    85b6:	6d 43       	mov.b	#2,	r13	;r3 As==10
    85b8:	1c 41 04 00 	mov	4(r1),	r12	;
    85bc:	b0 12 4e 82 	call	#33358		;#0x824e

000085c0 <.Loc.475.3>:
}
    85c0:	03 43       	nop			
    85c2:	31 52       	add	#8,	r1	;r2 As==11
    85c4:	30 41       	ret			

000085c6 <sx1212SetFrequency>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp      pointer to the SX1212 driver
 * @param[in] deviation center frequency to be programmed, in Hz
*/
static void sx1212SetFrequency(SX1212Driver *devp, uint32_t freq) {
    85c6:	5a 15       	pushm	#6,	r10	;16-bit words

000085c8 <.LCFI19>:
    85c8:	31 80 28 00 	sub	#40,	r1	;#0x0028

000085cc <.LCFI20>:
    85cc:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    85d0:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010
    85d4:	81 4e 12 00 	mov	r14,	18(r1)	; 0x0012

000085d8 <.Loc.495.3>:
  osalDbgAssert(freq >= 300000000 && freq <= 510000000, 
      "frequency out of range");
  
  /* The equation is (9/8) * (FREQ / (R+1)) * (75*(P+1) + S) */
  /* The constraints are 64 <= R <= 169, S < P+1, R,P,S < 256 */
  uint8_t r = 0;
    85d8:	c1 43 27 00 	mov.b	#0,	39(r1)	;r3 As==00, 0x0027

000085dc <.Loc.496.3>:
  uint8_t s = 0;
    85dc:	c1 43 23 00 	mov.b	#0,	35(r1)	;r3 As==00, 0x0023

000085e0 <.Loc.497.3>:
  uint8_t p = 0;
    85e0:	c1 43 22 00 	mov.b	#0,	34(r1)	;r3 As==00, 0x0022

000085e4 <.Loc.498.3>:
  uint32_t r_mult = 0;
    85e4:	81 43 1e 00 	mov	#0,	30(r1)	;r3 As==00, 0x001e
    85e8:	81 43 20 00 	mov	#0,	32(r1)	;r3 As==00, 0x0020

000085ec <.Loc.499.3>:
  uint32_t tmpgcd = 0;
    85ec:	81 43 1a 00 	mov	#0,	26(r1)	;r3 As==00, 0x001a
    85f0:	81 43 1c 00 	mov	#0,	28(r1)	;r3 As==00, 0x001c

000085f4 <.Loc.500.3>:
  uint32_t temp = 0;
    85f4:	81 43 16 00 	mov	#0,	22(r1)	;r3 As==00, 0x0016
    85f8:	81 43 18 00 	mov	#0,	24(r1)	;r3 As==00, 0x0018

000085fc <.Loc.503.3>:
  /* Find R such that (f/FREQ)*(8/9)*(R+1) is an integer */
  /* GCD(f*8, freq*9) */
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
    85fc:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8600:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8604:	b0 12 66 92 	call	#37478		;#0x9266
    8608:	3e 40 00 d0 	mov	#53248,	r14	;#0xd000
    860c:	3f 40 dd 06 	mov	#1757,	r15	;#0x06dd
    8610:	b0 12 44 83 	call	#33604		;#0x8344
    8614:	81 4c 1a 00 	mov	r12,	26(r1)	; 0x001a
    8618:	81 4d 1c 00 	mov	r13,	28(r1)	; 0x001c

0000861c <.Loc.504.3>:
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
    861c:	1e 41 1a 00 	mov	26(r1),	r14	;0x0001a
    8620:	1f 41 1c 00 	mov	28(r1),	r15	;0x0001c
    8624:	3c 40 00 d0 	mov	#53248,	r12	;#0xd000
    8628:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    862c:	b0 12 fe 91 	call	#37374		;#0x91fe
    8630:	81 4c 1e 00 	mov	r12,	30(r1)	; 0x001e
    8634:	81 4d 20 00 	mov	r13,	32(r1)	; 0x0020

00008638 <.Loc.507.3>:
  
  /* for inexact frequencies */
  int i = 0;
    8638:	81 43 24 00 	mov	#0,	36(r1)	;r3 As==00, 0x0024

0000863c <.Loc.508.3>:
  while (r_mult - (75 * i) > 169) {
    863c:	02 3c       	jmp	$+6      	;abs 0x8642

0000863e <.L75>:
    i++;
    863e:	91 53 24 00 	inc	36(r1)		;

00008642 <.L74>:
  tmpgcd = gcd(freq*8, SX1212_CLK_FREQ*9);
  r_mult = SX1212_CLK_FREQ*9 / tmpgcd;
  
  /* for inexact frequencies */
  int i = 0;
  while (r_mult - (75 * i) > 169) {
    8642:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    8646:	1c 41 24 00 	mov	36(r1),	r12	;0x00024
    864a:	b0 12 34 93 	call	#37684		;#0x9334
    864e:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    8652:	0d 7d       	subc	r13,	r13	;
    8654:	3d e3       	inv	r13		;
    8656:	1e 41 1e 00 	mov	30(r1),	r14	;0x0001e
    865a:	1f 41 20 00 	mov	32(r1),	r15	;0x00020
    865e:	0e 8c       	sub	r12,	r14	;
    8660:	0f 7d       	subc	r13,	r15	;
    8662:	0c 4f       	mov	r15,	r12	;
    8664:	0c 93       	cmp	#0,	r12	;r3 As==00
    8666:	eb 23       	jnz	$-40     	;abs 0x863e
    8668:	0c 4f       	mov	r15,	r12	;
    866a:	0c 93       	cmp	#0,	r12	;r3 As==00
    866c:	04 20       	jnz	$+10     	;abs 0x8676
    866e:	7c 40 a9 00 	mov.b	#169,	r12	;#0x00a9
    8672:	0c 9e       	cmp	r14,	r12	;
    8674:	e4 2b       	jnc	$-54     	;abs 0x863e

00008676 <.L98>:
    i++;
  }
  r_mult = r_mult - (75 * i);
    8676:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    867a:	1c 41 24 00 	mov	36(r1),	r12	;0x00024
    867e:	b0 12 34 93 	call	#37684		;#0x9334
    8682:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    8686:	0d 7d       	subc	r13,	r13	;
    8688:	3d e3       	inv	r13		;
    868a:	81 8c 1e 00 	sub	r12,	30(r1)	; 0x001e
    868e:	81 7d 20 00 	subc	r13,	32(r1)	; 0x0020

00008692 <.Loc.514.3>:
  
  /* R+1 is a multiple of r_mult */
  r = r_mult - 1;
    8692:	5c 41 1e 00 	mov.b	30(r1),	r12	;0x0001e
    8696:	4d 4c       	mov.b	r12,	r13	;
    8698:	7d 53       	add.b	#-1,	r13	;r3 As==11
    869a:	c1 4d 27 00 	mov.b	r13,	39(r1)	; 0x0027

0000869e <.Loc.517.3>:
  
  /* Satisfy R constraint */
  while (r < 64 || r > 169) {
    869e:	04 3c       	jmp	$+10     	;abs 0x86a8

000086a0 <.L78>:
    r += r_mult;
    86a0:	5c 41 1e 00 	mov.b	30(r1),	r12	;0x0001e
    86a4:	c1 5c 27 00 	add.b	r12,	39(r1)	; 0x0027

000086a8 <.L77>:
  
  /* R+1 is a multiple of r_mult */
  r = r_mult - 1;
  
  /* Satisfy R constraint */
  while (r < 64 || r > 169) {
    86a8:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    86ac:	5c 91 27 00 	cmp.b	39(r1),	r12	;0x00027
    86b0:	f7 2f       	jc	$-16     	;abs 0x86a0

000086b2 <.Loc.517.3>:
    86b2:	7c 40 a9 ff 	mov.b	#65449,	r12	;#0xffa9
    86b6:	5c 91 27 00 	cmp.b	39(r1),	r12	;0x00027
    86ba:	f2 2b       	jnc	$-26     	;abs 0x86a0

000086bc <.Loc.522.3>:
    r += r_mult;
  }
  
  /* Calculate P and S */
  r -= r_mult;
    86bc:	5c 41 1e 00 	mov.b	30(r1),	r12	;0x0001e
    86c0:	c1 8c 27 00 	sub.b	r12,	39(r1)	; 0x0027

000086c4 <.L79>:
  do {
    r += r_mult;
    86c4:	5c 41 1e 00 	mov.b	30(r1),	r12	;0x0001e
    86c8:	c1 5c 27 00 	add.b	r12,	39(r1)	; 0x0027

000086cc <.Loc.525.3>:
    temp = ((freq * 8 / tmpgcd) * (r+1)) / (SX1212_CLK_FREQ * 9 / tmpgcd);
    86cc:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    86d0:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    86d4:	b0 12 66 92 	call	#37478		;#0x9266
    86d8:	1e 41 1a 00 	mov	26(r1),	r14	;0x0001a
    86dc:	1f 41 1c 00 	mov	28(r1),	r15	;0x0001c
    86e0:	b0 12 fe 91 	call	#37374		;#0x91fe
    86e4:	0a 4c       	mov	r12,	r10	;
    86e6:	0b 4d       	mov	r13,	r11	;
    86e8:	5c 41 27 00 	mov.b	39(r1),	r12	;0x00027
    86ec:	1c 53       	inc	r12		;
    86ee:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    86f2:	0d 7d       	subc	r13,	r13	;
    86f4:	3d e3       	inv	r13		;
    86f6:	0e 4c       	mov	r12,	r14	;
    86f8:	0f 4d       	mov	r13,	r15	;
    86fa:	0c 4a       	mov	r10,	r12	;
    86fc:	0d 4b       	mov	r11,	r13	;
    86fe:	b0 12 48 93 	call	#37704		;#0x9348
    8702:	09 4c       	mov	r12,	r9	;
    8704:	0a 4d       	mov	r13,	r10	;
    8706:	1e 41 1a 00 	mov	26(r1),	r14	;0x0001a
    870a:	1f 41 1c 00 	mov	28(r1),	r15	;0x0001c
    870e:	3c 40 00 d0 	mov	#53248,	r12	;#0xd000
    8712:	3d 40 dd 06 	mov	#1757,	r13	;#0x06dd
    8716:	b0 12 fe 91 	call	#37374		;#0x91fe
    871a:	0e 4c       	mov	r12,	r14	;
    871c:	0f 4d       	mov	r13,	r15	;
    871e:	0c 49       	mov	r9,	r12	;
    8720:	0d 4a       	mov	r10,	r13	;
    8722:	b0 12 fe 91 	call	#37374		;#0x91fe
    8726:	81 4c 16 00 	mov	r12,	22(r1)	; 0x0016
    872a:	81 4d 18 00 	mov	r13,	24(r1)	; 0x0018

0000872e <.Loc.526.3>:
    p = (temp / 75) - 1;
    872e:	1c 41 16 00 	mov	22(r1),	r12	;0x00016
    8732:	1d 41 18 00 	mov	24(r1),	r13	;0x00018
    8736:	7e 40 4b 00 	mov.b	#75,	r14	;#0x004b
    873a:	4f 43       	clr.b	r15		;
    873c:	b0 12 fe 91 	call	#37374		;#0x91fe
    8740:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8744:	4d 4c       	mov.b	r12,	r13	;
    8746:	7d 53       	add.b	#-1,	r13	;r3 As==11
    8748:	c1 4d 22 00 	mov.b	r13,	34(r1)	; 0x0022

0000874c <.Loc.527.3>:
    s = temp - ((p+1)*75);
    874c:	5a 41 16 00 	mov.b	22(r1),	r10	;0x00016
    8750:	5c 41 22 00 	mov.b	34(r1),	r12	;0x00022
    8754:	1c 53       	inc	r12		;
    8756:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    875a:	7d 40 4b 00 	mov.b	#75,	r13	;#0x004b
    875e:	b0 12 34 93 	call	#37684		;#0x9334
    8762:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8766:	4d 4a       	mov.b	r10,	r13	;
    8768:	4d 8c       	sub.b	r12,	r13	;
    876a:	c1 4d 23 00 	mov.b	r13,	35(r1)	; 0x0023

0000876e <.Loc.528.3>:
  } while (r < 64 || r > 169 || s > p);
    876e:	7c 40 3f 00 	mov.b	#63,	r12	;#0x003f
    8772:	5c 91 27 00 	cmp.b	39(r1),	r12	;0x00027
    8776:	a6 2f       	jc	$-178    	;abs 0x86c4

00008778 <.Loc.528.3>:
    8778:	7c 40 a9 ff 	mov.b	#65449,	r12	;#0xffa9
    877c:	5c 91 27 00 	cmp.b	39(r1),	r12	;0x00027
    8780:	a1 2b       	jnc	$-188    	;abs 0x86c4

00008782 <.Loc.528.3>:
    8782:	d1 91 23 00 	cmp.b	35(r1),	34(r1)	;0x00023, 0x0022
    8786:	22 00 
    8788:	9d 2b       	jnc	$-196    	;abs 0x86c4

0000878a <.Loc.530.3>:
  
  sx1212SetRegister(devp, MCParam6, r);
    878a:	5e 41 27 00 	mov.b	39(r1),	r14	;0x00027
    878e:	7d 40 06 00 	mov.b	#6,	r13	;
    8792:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8796:	b0 12 4e 82 	call	#33358		;#0x824e

0000879a <.Loc.531.3>:
  sx1212SetRegister(devp, MCParam7, p);
    879a:	5e 41 22 00 	mov.b	34(r1),	r14	;0x00022
    879e:	7d 40 07 00 	mov.b	#7,	r13	;
    87a2:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    87a6:	b0 12 4e 82 	call	#33358		;#0x824e

000087aa <.Loc.532.3>:
  sx1212SetRegister(devp, MCParam8, s);
    87aa:	5e 41 23 00 	mov.b	35(r1),	r14	;0x00023
    87ae:	7d 42       	mov.b	#8,	r13	;r2 As==11
    87b0:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    87b4:	b0 12 4e 82 	call	#33358		;#0x824e

000087b8 <.Loc.535.3>:
  
  /* Set frequency band registers */
  if (freq >= 300000000 && freq <= 330000000) {
    87b8:	3c 40 e1 11 	mov	#4577,	r12	;#0x11e1
    87bc:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    87c0:	09 28       	jnc	$+20     	;abs 0x87d4
    87c2:	b1 90 e1 11 	cmp	#4577,	18(r1)	;#0x11e1, 0x0012
    87c6:	12 00 
    87c8:	43 20       	jnz	$+136    	;abs 0x8850
    87ca:	3c 40 ff a2 	mov	#41727,	r12	;#0xa2ff
    87ce:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    87d2:	3e 2c       	jc	$+126    	;abs 0x8850

000087d4 <.L99>:
    87d4:	3c 40 ab 13 	mov	#5035,	r12	;#0x13ab
    87d8:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    87dc:	39 28       	jnc	$+116    	;abs 0x8850
    87de:	b1 90 ab 13 	cmp	#5035,	18(r1)	;#0x13ab, 0x0012
    87e2:	12 00 
    87e4:	05 20       	jnz	$+12     	;abs 0x87f0
    87e6:	3c 40 80 66 	mov	#26240,	r12	;#0x6680
    87ea:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    87ee:	30 28       	jnc	$+98     	;abs 0x8850

000087f0 <.L100>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    87f0:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    87f4:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    87f8:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    87fc:	4a 4c       	mov.b	r12,	r10	;

000087fe <.Loc.537.3>:
      0x00 << 2 | ((freq - 300000000) / 7500000);
    87fe:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8802:	3c 50 00 5d 	add	#23808,	r12	;#0x5d00
    8806:	81 4c 0c 00 	mov	r12,	12(r1)	; 0x000c
    880a:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    880e:	3d 60 1e ee 	addc	#60958,	r13	;#0xee1e
    8812:	81 4d 0e 00 	mov	r13,	14(r1)	; 0x000e
    8816:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    881a:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    881e:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    8822:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    8826:	b0 12 fe 91 	call	#37374		;#0x91fe
    882a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    882e:	4c da       	bis.b	r10,	r12	;
    8830:	4d 4c       	mov.b	r12,	r13	;

00008832 <.Loc.536.3>:
  sx1212SetRegister(devp, MCParam7, p);
  sx1212SetRegister(devp, MCParam8, s);
  
  /* Set frequency band registers */
  if (freq >= 300000000 && freq <= 330000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8832:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8836:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

0000883a <.Loc.538.3>:
      0x00 << 2 | ((freq - 300000000) / 7500000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    883a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    883e:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8842:	4e 4c       	mov.b	r12,	r14	;
    8844:	4d 43       	clr.b	r13		;
    8846:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    884a:	b0 12 4e 82 	call	#33358		;#0x824e
    884e:	82 3d       	jmp	$+774    	;abs 0x8b54

00008850 <.L80>:
  }
  else if (freq >= 320000000 && freq <= 350000000) {
    8850:	3c 40 12 13 	mov	#4882,	r12	;#0x1312
    8854:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8858:	09 28       	jnc	$+20     	;abs 0x886c
    885a:	b1 90 12 13 	cmp	#4882,	18(r1)	;#0x1312, 0x0012
    885e:	12 00 
    8860:	46 20       	jnz	$+142    	;abs 0x88ee
    8862:	3c 40 ff cf 	mov	#53247,	r12	;#0xcfff
    8866:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    886a:	41 2c       	jc	$+132    	;abs 0x88ee

0000886c <.L101>:
    886c:	3c 40 dc 14 	mov	#5340,	r12	;#0x14dc
    8870:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8874:	3c 28       	jnc	$+122    	;abs 0x88ee
    8876:	b1 90 dc 14 	cmp	#5340,	18(r1)	;#0x14dc, 0x0012
    887a:	12 00 
    887c:	05 20       	jnz	$+12     	;abs 0x8888
    887e:	3c 40 80 93 	mov	#37760,	r12	;#0x9380
    8882:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8886:	33 28       	jnc	$+104    	;abs 0x88ee

00008888 <.L102>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8888:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    888c:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008890 <.Loc.542.3>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    8890:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    8894:	4a 4c       	mov.b	r12,	r10	;
    8896:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    889a:	3c 50 00 30 	add	#12288,	r12	;#0x3000
    889e:	81 4c 08 00 	mov	r12,	8(r1)	;
    88a2:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    88a6:	3d 60 ed ec 	addc	#60653,	r13	;#0xeced
    88aa:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    88ae:	3e 40 e0 70 	mov	#28896,	r14	;#0x70e0
    88b2:	7f 40 72 00 	mov.b	#114,	r15	;#0x0072
    88b6:	1c 41 08 00 	mov	8(r1),	r12	;
    88ba:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    88be:	b0 12 fe 91 	call	#37374		;#0x91fe
    88c2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    88c6:	4c da       	bis.b	r10,	r12	;
    88c8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    88cc:	6c d2       	bis.b	#4,	r12	;r2 As==10
    88ce:	4d 4c       	mov.b	r12,	r13	;

000088d0 <.Loc.541.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x00 << 2 | ((freq - 300000000) / 7500000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 320000000 && freq <= 350000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    88d0:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88d4:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

000088d8 <.Loc.543.3>:
      0x01 << 2 | ((freq - 320000000) / 7500000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    88d8:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88dc:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    88e0:	4e 4c       	mov.b	r12,	r14	;
    88e2:	4d 43       	clr.b	r13		;
    88e4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    88e8:	b0 12 4e 82 	call	#33358		;#0x824e
    88ec:	33 3d       	jmp	$+616    	;abs 0x8b54

000088ee <.L84>:
  }
  else if (freq >= 350000000 && freq <= 390000000) {
    88ee:	3c 40 dc 14 	mov	#5340,	r12	;#0x14dc
    88f2:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    88f6:	09 28       	jnc	$+20     	;abs 0x890a
    88f8:	b1 90 dc 14 	cmp	#5340,	18(r1)	;#0x14dc, 0x0012
    88fc:	12 00 
    88fe:	46 20       	jnz	$+142    	;abs 0x898c
    8900:	3c 40 7f 93 	mov	#37759,	r12	;#0x937f
    8904:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8908:	41 2c       	jc	$+132    	;abs 0x898c

0000890a <.L103>:
    890a:	3c 40 3e 17 	mov	#5950,	r12	;#0x173e
    890e:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8912:	3c 28       	jnc	$+122    	;abs 0x898c
    8914:	b1 90 3e 17 	cmp	#5950,	18(r1)	;#0x173e, 0x0012
    8918:	12 00 
    891a:	05 20       	jnz	$+12     	;abs 0x8926
    891c:	3c 40 80 ed 	mov	#60800,	r12	;#0xed80
    8920:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8924:	33 28       	jnc	$+104    	;abs 0x898c

00008926 <.L104>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8926:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    892a:	5c 4c 02 00 	mov.b	2(r12),	r12	;

0000892e <.Loc.547.3>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    892e:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    8932:	4a 4c       	mov.b	r12,	r10	;
    8934:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    8938:	3c 50 80 6c 	add	#27776,	r12	;#0x6c80
    893c:	81 4c 04 00 	mov	r12,	4(r1)	;
    8940:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    8944:	3d 60 23 eb 	addc	#60195,	r13	;#0xeb23
    8948:	81 4d 06 00 	mov	r13,	6(r1)	;
    894c:	3e 40 80 96 	mov	#38528,	r14	;#0x9680
    8950:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    8954:	1c 41 04 00 	mov	4(r1),	r12	;
    8958:	1d 41 06 00 	mov	6(r1),	r13	;
    895c:	b0 12 fe 91 	call	#37374		;#0x91fe
    8960:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8964:	4c da       	bis.b	r10,	r12	;
    8966:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    896a:	7c d2       	bis.b	#8,	r12	;r2 As==11
    896c:	4d 4c       	mov.b	r12,	r13	;

0000896e <.Loc.546.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x01 << 2 | ((freq - 320000000) / 7500000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 350000000 && freq <= 390000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    896e:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8972:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00008976 <.Loc.548.3>:
      0x02 << 2 | ((freq - 350000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    8976:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    897a:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    897e:	4e 4c       	mov.b	r12,	r14	;
    8980:	4d 43       	clr.b	r13		;
    8982:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8986:	b0 12 4e 82 	call	#33358		;#0x824e
    898a:	e4 3c       	jmp	$+458    	;abs 0x8b54

0000898c <.L87>:
  }
  else if (freq >= 390000000 && freq <= 430000000) {
    898c:	3c 40 3e 17 	mov	#5950,	r12	;#0x173e
    8990:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8994:	09 28       	jnc	$+20     	;abs 0x89a8
    8996:	b1 90 3e 17 	cmp	#5950,	18(r1)	;#0x173e, 0x0012
    899a:	12 00 
    899c:	46 20       	jnz	$+142    	;abs 0x8a2a
    899e:	3c 40 7f ed 	mov	#60799,	r12	;#0xed7f
    89a2:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    89a6:	41 2c       	jc	$+132    	;abs 0x8a2a

000089a8 <.L105>:
    89a8:	3c 40 a1 19 	mov	#6561,	r12	;#0x19a1
    89ac:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    89b0:	3c 28       	jnc	$+122    	;abs 0x8a2a
    89b2:	b1 90 a1 19 	cmp	#6561,	18(r1)	;#0x19a1, 0x0012
    89b6:	12 00 
    89b8:	05 20       	jnz	$+12     	;abs 0x89c4
    89ba:	3c 40 80 47 	mov	#18304,	r12	;#0x4780
    89be:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    89c2:	33 28       	jnc	$+104    	;abs 0x8a2a

000089c4 <.L106>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    89c4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    89c8:	5c 4c 02 00 	mov.b	2(r12),	r12	;

000089cc <.Loc.552.3>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    89cc:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    89d0:	4a 4c       	mov.b	r12,	r10	;
    89d2:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    89d6:	3c 50 80 12 	add	#4736,	r12	;#0x1280
    89da:	81 4c 00 00 	mov	r12,	0(r1)	;
    89de:	1d 41 12 00 	mov	18(r1),	r13	;0x00012
    89e2:	3d 60 c1 e8 	addc	#59585,	r13	;#0xe8c1
    89e6:	81 4d 02 00 	mov	r13,	2(r1)	;
    89ea:	3e 40 80 96 	mov	#38528,	r14	;#0x9680
    89ee:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    89f2:	2c 41       	mov	@r1,	r12	;
    89f4:	1d 41 02 00 	mov	2(r1),	r13	;
    89f8:	b0 12 fe 91 	call	#37374		;#0x91fe
    89fc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a00:	4c da       	bis.b	r10,	r12	;
    8a02:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a06:	7c d0 0c 00 	bis.b	#12,	r12	;#0x000c
    8a0a:	4d 4c       	mov.b	r12,	r13	;

00008a0c <.Loc.551.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x02 << 2 | ((freq - 350000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 390000000 && freq <= 430000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8a0c:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8a10:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00008a14 <.Loc.553.3>:
      0x03 << 2 | ((freq - 390000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    8a14:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8a18:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8a1c:	4e 4c       	mov.b	r12,	r14	;
    8a1e:	4d 43       	clr.b	r13		;
    8a20:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8a24:	b0 12 4e 82 	call	#33358		;#0x824e
    8a28:	95 3c       	jmp	$+300    	;abs 0x8b54

00008a2a <.L90>:
  }
  else if (freq >= 430000000 && freq <= 470000000) {
    8a2a:	3c 40 a1 19 	mov	#6561,	r12	;#0x19a1
    8a2e:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8a32:	09 28       	jnc	$+20     	;abs 0x8a46
    8a34:	b1 90 a1 19 	cmp	#6561,	18(r1)	;#0x19a1, 0x0012
    8a38:	12 00 
    8a3a:	41 20       	jnz	$+132    	;abs 0x8abe
    8a3c:	3c 40 7f 47 	mov	#18303,	r12	;#0x477f
    8a40:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8a44:	3c 2c       	jc	$+122    	;abs 0x8abe

00008a46 <.L107>:
    8a46:	3c 40 03 1c 	mov	#7171,	r12	;#0x1c03
    8a4a:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8a4e:	37 28       	jnc	$+112    	;abs 0x8abe
    8a50:	b1 90 03 1c 	cmp	#7171,	18(r1)	;#0x1c03, 0x0012
    8a54:	12 00 
    8a56:	05 20       	jnz	$+12     	;abs 0x8a62
    8a58:	3c 40 80 a1 	mov	#41344,	r12	;#0xa180
    8a5c:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8a60:	2e 28       	jnc	$+94     	;abs 0x8abe

00008a62 <.L108>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8a62:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8a66:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008a6a <.Loc.557.3>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    8a6a:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    8a6e:	4a 4c       	mov.b	r12,	r10	;
    8a70:	15 41 10 00 	mov	16(r1),	r5	;0x00010
    8a74:	35 50 80 b8 	add	#47232,	r5	;#0xb880
    8a78:	16 41 12 00 	mov	18(r1),	r6	;0x00012
    8a7c:	36 60 5e e6 	addc	#58974,	r6	;#0xe65e
    8a80:	3e 40 80 96 	mov	#38528,	r14	;#0x9680
    8a84:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    8a88:	0c 45       	mov	r5,	r12	;
    8a8a:	0d 46       	mov	r6,	r13	;
    8a8c:	b0 12 fe 91 	call	#37374		;#0x91fe
    8a90:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a94:	4c da       	bis.b	r10,	r12	;
    8a96:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8a9a:	7c d0 10 00 	bis.b	#16,	r12	;#0x0010
    8a9e:	4d 4c       	mov.b	r12,	r13	;

00008aa0 <.Loc.556.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x03 << 2 | ((freq - 390000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 430000000 && freq <= 470000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8aa0:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8aa4:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00008aa8 <.Loc.558.3>:
      0x04 << 2 | ((freq - 430000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    8aa8:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8aac:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8ab0:	4e 4c       	mov.b	r12,	r14	;
    8ab2:	4d 43       	clr.b	r13		;
    8ab4:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8ab8:	b0 12 4e 82 	call	#33358		;#0x824e
    8abc:	4b 3c       	jmp	$+152    	;abs 0x8b54

00008abe <.L93>:
  }
  else if (freq >= 470000000 && freq <= 510000000) {
    8abe:	3c 40 03 1c 	mov	#7171,	r12	;#0x1c03
    8ac2:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8ac6:	0a 28       	jnc	$+22     	;abs 0x8adc
    8ac8:	b1 90 03 1c 	cmp	#7171,	18(r1)	;#0x1c03, 0x0012
    8acc:	12 00 
    8ace:	42 20       	jnz	$+134    	;abs 0x8b54
    8ad0:	3c 40 7f a1 	mov	#41343,	r12	;#0xa17f
    8ad4:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8ad8:	01 28       	jnc	$+4      	;abs 0x8adc

00008ada <.Loc.566.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x05 << 2 | ((freq - 470000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }

}
    8ada:	3c 3c       	jmp	$+122    	;abs 0x8b54

00008adc <.L109>:
  else if (freq >= 430000000 && freq <= 470000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x04 << 2 | ((freq - 430000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 470000000 && freq <= 510000000) {
    8adc:	3c 40 65 1e 	mov	#7781,	r12	;#0x1e65
    8ae0:	1c 91 12 00 	cmp	18(r1),	r12	;0x00012
    8ae4:	37 28       	jnc	$+112    	;abs 0x8b54
    8ae6:	b1 90 65 1e 	cmp	#7781,	18(r1)	;#0x1e65, 0x0012
    8aea:	12 00 
    8aec:	05 20       	jnz	$+12     	;abs 0x8af8
    8aee:	3c 40 80 fb 	mov	#64384,	r12	;#0xfb80
    8af2:	1c 91 10 00 	cmp	16(r1),	r12	;0x00010
    8af6:	2e 28       	jnc	$+94     	;abs 0x8b54

00008af8 <.L110>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8af8:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8afc:	5c 4c 02 00 	mov.b	2(r12),	r12	;

00008b00 <.Loc.562.3>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    8b00:	7c f0 e0 ff 	and.b	#65504,	r12	;#0xffe0
    8b04:	4a 4c       	mov.b	r12,	r10	;
    8b06:	17 41 10 00 	mov	16(r1),	r7	;0x00010
    8b0a:	37 50 80 5e 	add	#24192,	r7	;#0x5e80
    8b0e:	18 41 12 00 	mov	18(r1),	r8	;0x00012
    8b12:	38 60 fc e3 	addc	#58364,	r8	;#0xe3fc
    8b16:	3e 40 80 96 	mov	#38528,	r14	;#0x9680
    8b1a:	7f 40 98 00 	mov.b	#152,	r15	;#0x0098
    8b1e:	0c 47       	mov	r7,	r12	;
    8b20:	0d 48       	mov	r8,	r13	;
    8b22:	b0 12 fe 91 	call	#37374		;#0x91fe
    8b26:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8b2a:	4c da       	bis.b	r10,	r12	;
    8b2c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8b30:	7c d0 14 00 	bis.b	#20,	r12	;#0x0014
    8b34:	4d 4c       	mov.b	r12,	r13	;

00008b36 <.Loc.561.3>:
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
      0x04 << 2 | ((freq - 430000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
  }
  else if (freq >= 470000000 && freq <= 510000000) {
    devp->regs.MCParam0 = (devp->regs.MCParam0 & 0xE0) | 
    8b36:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8b3a:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00008b3e <.Loc.563.3>:
      0x05 << 2 | ((freq - 470000000) / 10000000);
    sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    8b3e:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8b42:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8b46:	4e 4c       	mov.b	r12,	r14	;
    8b48:	4d 43       	clr.b	r13		;
    8b4a:	1c 41 14 00 	mov	20(r1),	r12	;0x00014
    8b4e:	b0 12 4e 82 	call	#33358		;#0x824e

00008b52 <.Loc.566.3>:
  }

}
    8b52:	00 3c       	jmp	$+2      	;abs 0x8b54

00008b54 <.L111>:
    8b54:	03 43       	nop			
    8b56:	31 50 28 00 	add	#40,	r1	;#0x0028
    8b5a:	55 17       	popm	#6,	r10	;16-bit words
    8b5c:	30 41       	ret			

00008b5e <sx1212SetSync>:
    8b5e:	0a 15       	pushm	#1,	r10	;16-bit words

00008b60 <.LCFI21>:
 * 
 * @param[in] devp  pointer to the SX1212 driver
 * @param[in] bytes length of the sync value in bytes
 * @param[in] value pointer to the sync value
*/
static void sx1212SetSync(SX1212Driver *devp, SX1212_SYNC_TYPE sync) {
    8b60:	31 82       	sub	#8,	r1	;r2 As==11

00008b62 <.LCFI22>:
    8b62:	81 4c 04 00 	mov	r12,	4(r1)	;
    8b66:	81 4d 00 00 	mov	r13,	0(r1)	;
    8b6a:	81 4e 02 00 	mov	r14,	2(r1)	;

00008b6e <.LBB7>:
  
  osalDbgAssert(sizeof(sync) <= 4 && sizeof(sync) >= 1, 
      "requested sync length invalid");
  /* Sync is required - we don't support turning it off (why would you?) */

  for (unsigned int i = 0; i < sizeof(sync); i++) {
    8b6e:	81 43 06 00 	Address 0x0000000000008b70 is out of bounds.
mov	#0,	-1(r1)	;r3 As==00, 0xffff

00008b70 <L0>:
    8b70:	06 00       	mova	@r0,	r6	;
    8b72:	21 3c       	jmp	$+68     	;abs 0x8bb6

00008b74 <.L114>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
    8b74:	1c 41 06 00 	mov	6(r1),	r12	;
    8b78:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8b7c:	7c 50 16 00 	add.b	#22,	r12	;#0x0016
    8b80:	4a 4c       	mov.b	r12,	r10	;

00008b82 <.Loc.586.3>:
        sync >> (8 * (sizeof(sync) - 1 - i)));
    8b82:	1c 41 06 00 	mov	6(r1),	r12	;
    8b86:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;
    8b8a:	0d 43       	clr	r13		;
    8b8c:	0d 8c       	sub	r12,	r13	;
    8b8e:	0c 4d       	mov	r13,	r12	;
    8b90:	3c 50 18 00 	add	#24,	r12	;#0x0018
    8b94:	0e 4c       	mov	r12,	r14	;
    8b96:	0f 43       	clr	r15		;
    8b98:	2c 41       	mov	@r1,	r12	;
    8b9a:	1d 41 02 00 	mov	2(r1),	r13	;
    8b9e:	b0 12 2e 93 	call	#37678		;#0x932e

00008ba2 <.Loc.585.3>:
  osalDbgAssert(sizeof(sync) <= 4 && sizeof(sync) >= 1, 
      "requested sync length invalid");
  /* Sync is required - we don't support turning it off (why would you?) */

  for (unsigned int i = 0; i < sizeof(sync); i++) {
    sx1212SetRegister(devp, SYNCParam0 + i, 
    8ba2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8ba6:	4e 4c       	mov.b	r12,	r14	;
    8ba8:	4d 4a       	mov.b	r10,	r13	;
    8baa:	1c 41 04 00 	mov	4(r1),	r12	;
    8bae:	b0 12 4e 82 	call	#33358		;#0x824e

00008bb2 <.Loc.584.3>:
  
  osalDbgAssert(sizeof(sync) <= 4 && sizeof(sync) >= 1, 
      "requested sync length invalid");
  /* Sync is required - we don't support turning it off (why would you?) */

  for (unsigned int i = 0; i < sizeof(sync); i++) {
    8bb2:	91 53 06 00 	inc	6(r1)		;

00008bb6 <.L113>:
    8bb6:	7c 40 03 00 	mov.b	#3,	r12	;
    8bba:	1c 91 06 00 	cmp	6(r1),	r12	;
    8bbe:	da 2f       	jc	$-74     	;abs 0x8b74

00008bc0 <.LBE7>:
    sx1212SetRegister(devp, SYNCParam0 + i, 
        sync >> (8 * (sizeof(sync) - 1 - i)));
  }
}
    8bc0:	03 43       	nop			
    8bc2:	31 52       	add	#8,	r1	;r2 As==11
    8bc4:	0a 17       	popm	#1,	r10	;16-bit words
    8bc6:	30 41       	ret			

00008bc8 <sx1212Reset>:
/**
 * @brief   Resets the transceiver
 * 
 * @param[in] devp pointer to the SX1212 driver
 */
static void sx1212Reset(SX1212Driver *devp) {
    8bc8:	1a 15       	pushm	#2,	r10	;16-bit words

00008bca <L0>:
    8bca:	21 83       	decd	r1		;

00008bcc <.LCFI24>:
    8bcc:	81 4c 00 00 	mov	r12,	0(r1)	;

00008bd0 <.Loc.599.3>:
  
  osalDbgAssert(devp->config->reset_line != PAL_NOLINE, "reset line required");
  
  palSetLineMode(devp->config->reset_line, PAL_MODE_OUTPUT_PUSHPULL);
    8bd0:	2c 41       	mov	@r1,	r12	;
    8bd2:	2c 4c       	mov	@r12,	r12	;
    8bd4:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8bd8:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8bdc:	0a 4c       	mov	r12,	r10	;
    8bde:	2c 41       	mov	@r1,	r12	;
    8be0:	2c 4c       	mov	@r12,	r12	;
    8be2:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8be6:	0d 4c       	mov	r12,	r13	;
    8be8:	5d 03       	rrum	#1,	r13	;
    8bea:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8bee:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8bf0:	b0 12 30 92 	call	#37424		;#0x9230
    8bf4:	7e 40 06 00 	mov.b	#6,	r14	;
    8bf8:	0d 4c       	mov	r12,	r13	;
    8bfa:	0c 4a       	mov	r10,	r12	;
    8bfc:	b0 12 be 78 	call	#30910		;#0x78be

00008c00 <.Loc.600.3>:
  palSetLine(devp->config->reset_line);
    8c00:	2c 41       	mov	@r1,	r12	;
    8c02:	2c 4c       	mov	@r12,	r12	;
    8c04:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c08:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c0c:	0a 4c       	mov	r12,	r10	;
    8c0e:	2c 41       	mov	@r1,	r12	;
    8c10:	2c 4c       	mov	@r12,	r12	;
    8c12:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c16:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c1a:	19 4c 02 00 	mov	2(r12),	r9	;
    8c1e:	2c 41       	mov	@r1,	r12	;
    8c20:	2c 4c       	mov	@r12,	r12	;
    8c22:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c26:	0d 4c       	mov	r12,	r13	;
    8c28:	5d 03       	rrum	#1,	r13	;
    8c2a:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8c2e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c30:	b0 12 30 92 	call	#37424		;#0x9230
    8c34:	0c d9       	bis	r9,	r12	;
    8c36:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008c3a <.Loc.601.3>:
  osalThreadSleepMicroseconds(100);
    8c3a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c3c:	b0 12 96 81 	call	#33174		;#0x8196

00008c40 <.Loc.602.3>:
  palClearLine(devp->config->reset_line);
    8c40:	2c 41       	mov	@r1,	r12	;
    8c42:	2c 4c       	mov	@r12,	r12	;
    8c44:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c48:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c4c:	0a 4c       	mov	r12,	r10	;
    8c4e:	2c 41       	mov	@r1,	r12	;
    8c50:	2c 4c       	mov	@r12,	r12	;
    8c52:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c56:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c5a:	19 4c 02 00 	mov	2(r12),	r9	;
    8c5e:	2c 41       	mov	@r1,	r12	;
    8c60:	2c 4c       	mov	@r12,	r12	;
    8c62:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c66:	0d 4c       	mov	r12,	r13	;
    8c68:	5d 03       	rrum	#1,	r13	;
    8c6a:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8c6e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c70:	b0 12 30 92 	call	#37424		;#0x9230
    8c74:	3c e3       	inv	r12		;
    8c76:	0c f9       	and	r9,	r12	;
    8c78:	8a 4c 02 00 	mov	r12,	2(r10)	;

00008c7c <.Loc.603.3>:
  palSetLineMode(devp->config->reset_line, PAL_MODE_INPUT_PULLDOWN);
    8c7c:	2c 41       	mov	@r1,	r12	;
    8c7e:	2c 4c       	mov	@r12,	r12	;
    8c80:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c84:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    8c88:	0a 4c       	mov	r12,	r10	;
    8c8a:	2c 41       	mov	@r1,	r12	;
    8c8c:	2c 4c       	mov	@r12,	r12	;
    8c8e:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    8c92:	0d 4c       	mov	r12,	r13	;
    8c94:	5d 03       	rrum	#1,	r13	;
    8c96:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    8c9a:	5c 43       	mov.b	#1,	r12	;r3 As==01
    8c9c:	b0 12 30 92 	call	#37424		;#0x9230
    8ca0:	6e 42       	mov.b	#4,	r14	;r2 As==10
    8ca2:	0d 4c       	mov	r12,	r13	;
    8ca4:	0c 4a       	mov	r10,	r12	;
    8ca6:	b0 12 be 78 	call	#30910		;#0x78be

00008caa <.Loc.604.3>:
  osalThreadSleepMilliseconds(5);
    8caa:	7c 40 05 00 	mov.b	#5,	r12	;
    8cae:	b0 12 96 81 	call	#33174		;#0x8196

00008cb2 <.Loc.605.3>:
}
    8cb2:	03 43       	nop			
    8cb4:	21 53       	incd	r1		;
    8cb6:	19 17       	popm	#2,	r10	;16-bit words
    8cb8:	30 41       	ret			

00008cba <sx1212SetMode>:
 * @post    The NSS_CONFIG interface is started and acquired (if enabled)
 * 
 * @param[in] devp pointer to the SX1212 driver
 * @param[in] mode the mode to transition the driver to
 */
static void sx1212SetMode(SX1212Driver *devp, SX1212ModeConstants mode) {
    8cba:	21 82       	sub	#4,	r1	;r2 As==10

00008cbc <.LCFI25>:
    8cbc:	81 4c 02 00 	mov	r12,	2(r1)	;
    8cc0:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00008cc4 <.Loc.620.3>:
  
  osalDbgAssert(mode < 0x05U, "requested invalid transceiver mode");
  
  devp->regs.MCParam0 = (devp->regs.MCParam0 & 0x1F) | mode;
    8cc4:	1c 41 02 00 	mov	2(r1),	r12	;
    8cc8:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8ccc:	8c 11       	sxt	r12		;
    8cce:	7c f0 1f 00 	and.b	#31,	r12	;#0x001f
    8cd2:	4d 4c       	mov.b	r12,	r13	;
    8cd4:	8d 11       	sxt	r13		;
    8cd6:	5c 41 01 00 	mov.b	1(r1),	r12	;
    8cda:	8c 11       	sxt	r12		;
    8cdc:	4c dd       	bis.b	r13,	r12	;
    8cde:	8c 11       	sxt	r12		;
    8ce0:	4d 4c       	mov.b	r12,	r13	;
    8ce2:	1c 41 02 00 	mov	2(r1),	r12	;
    8ce6:	cc 4d 02 00 	mov.b	r13,	2(r12)	;

00008cea <.Loc.621.3>:
  sx1212SetRegister(devp, MCParam0, devp->regs.MCParam0);
    8cea:	1c 41 02 00 	mov	2(r1),	r12	;
    8cee:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    8cf2:	4e 4c       	mov.b	r12,	r14	;
    8cf4:	4d 43       	clr.b	r13		;
    8cf6:	1c 41 02 00 	mov	2(r1),	r12	;
    8cfa:	b0 12 4e 82 	call	#33358		;#0x824e

00008cfe <.Loc.622.3>:
}
    8cfe:	03 43       	nop			
    8d00:	21 52       	add	#4,	r1	;r2 As==10
    8d02:	30 41       	ret			

00008d04 <sx1212SetRxBw>:
 * @param[in] bandwidth the receiver bandwidth to use, in Hz
 * 
 * @note The bandwidth specifiedd here is for the active filter. Passive
 *       filter bandwidth is set automatically according to datasheet
 */
static void sx1212SetRxBw(SX1212Driver *devp, uint32_t bandwidth) {
    8d04:	31 80 06 00 	sub	#6,	r1	;

00008d08 <.LCFI28>:
    8d08:	81 4c 04 00 	mov	r12,	4(r1)	;
    8d0c:	81 4d 00 00 	mov	r13,	0(r1)	;
    8d10:	81 4e 02 00 	mov	r14,	2(r1)	;

00008d14 <.Loc.679.3>:
  };
  
  osalDbgAssert(bandwidth <= 400000, "requested bandwidth is too wide");
  
  /* Calculate register value for active filter bandwidth */
  bandwidth = ((bandwidth/200000) * (12800000/SX1212_CLK_FREQ) * 8) - 1;
    8d14:	2c 41       	mov	@r1,	r12	;
    8d16:	1d 41 02 00 	mov	2(r1),	r13	;
    8d1a:	3e 40 40 0d 	mov	#3392,	r14	;#0x0d40
    8d1e:	7f 40 03 00 	mov.b	#3,	r15	;
    8d22:	b0 12 fe 91 	call	#37374		;#0x91fe
    8d26:	b0 12 66 92 	call	#37478		;#0x9266
    8d2a:	0e 4c       	mov	r12,	r14	;
    8d2c:	3e 53       	add	#-1,	r14	;r3 As==11
    8d2e:	81 4e 00 00 	mov	r14,	0(r1)	;
    8d32:	0e 4d       	mov	r13,	r14	;
    8d34:	3e 63       	addc	#-1,	r14	;r3 As==11
    8d36:	81 4e 02 00 	mov	r14,	2(r1)	;

00008d3a <.Loc.684.3>:
  
  /* Passive filter bandwidth to be between 3 and 4 times active filter 
   * bandwidth, per datasheet. This is precalculated because there's no obvious
   * mapping. */
  sx1212SetRegister(devp, RXParam0, (passive[bandwidth] << 4) | bandwidth);
    8d3a:	2c 41       	mov	@r1,	r12	;
    8d3c:	3c 50 32 50 	add	#20530,	r12	;#0x5032
    8d40:	6c 4c       	mov.b	@r12,	r12	;
    8d42:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    8d46:	4d 4c       	mov.b	r12,	r13	;
    8d48:	6c 41       	mov.b	@r1,	r12	;
    8d4a:	4c dd       	bis.b	r13,	r12	;
    8d4c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d50:	4e 4c       	mov.b	r12,	r14	;
    8d52:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    8d56:	1c 41 04 00 	mov	4(r1),	r12	;
    8d5a:	b0 12 4e 82 	call	#33358		;#0x824e

00008d5e <.Loc.685.3>:
}
    8d5e:	03 43       	nop			
    8d60:	31 50 06 00 	add	#6,	r1	;
    8d64:	30 41       	ret			

00008d66 <sx1212ConfigurePackets>:
 * 
 * @param[in] devp          pointer to the SX1212 driver
 * @param[in] packet_config the packet configuration to apply
 */
static void sx1212ConfigurePackets(SX1212Driver* devp, 
    sx1212_packet_config_t *packet_config) {
    8d66:	21 82       	sub	#4,	r1	;r2 As==10

00008d68 <.LCFI29>:
    8d68:	81 4c 02 00 	mov	r12,	2(r1)	;
    8d6c:	81 4d 00 00 	mov	r13,	0(r1)	;

00008d70 <.Loc.705.3>:
  /* Buffered - Data_mode == 01b */
  /* Fixed - Data_mode == 10b, Pkt_format == 0 */
  /* Variable - Data_mode == 10b, Pkt_format == 1 */
  
  /* MCParam1 - Data_mode */
  sx1212SetRegister(devp, MCParam1, 0xA4);
    8d70:	7e 40 a4 ff 	mov.b	#65444,	r14	;#0xffa4
    8d74:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8d76:	1c 41 02 00 	mov	2(r1),	r12	;
    8d7a:	b0 12 4e 82 	call	#33358		;#0x824e

00008d7e <.Loc.712.3>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
      "Whitening and Manchester encoding are mutually exclusive");
  
  /* PKTParam0 - Manchester_on, Payload_length */
  osalDbgAssert(devp->config->length < 128, "requested packet size too long");
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    8d7e:	2c 41       	mov	@r1,	r12	;
    8d80:	6c 4c       	mov.b	@r12,	r12	;
    8d82:	5c 07       	rrum	#2,	r12	;
    8d84:	5c f3       	and.b	#1,	r12	;r3 As==01
    8d86:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d8a:	46 18 0c 5c 	rpt #7 { rlax.w	r12		;
    8d8e:	4d 4c       	mov.b	r12,	r13	;
    8d90:	8d 11       	sxt	r13		;

00008d92 <.Loc.713.3>:
     devp->config->length);
    8d92:	1c 41 02 00 	mov	2(r1),	r12	;
    8d96:	2c 4c       	mov	@r12,	r12	;
    8d98:	5c 4c 23 00 	mov.b	35(r12),r12	;0x00023
    8d9c:	8c 11       	sxt	r12		;

00008d9e <.Loc.712.3>:
  osalDbgAssert(!(packet_config->whitening && packet_config->manchester), 
      "Whitening and Manchester encoding are mutually exclusive");
  
  /* PKTParam0 - Manchester_on, Payload_length */
  osalDbgAssert(devp->config->length < 128, "requested packet size too long");
  sx1212SetRegister(devp, PKTParam0, (packet_config->manchester << 7) | 
    8d9e:	4c dd       	bis.b	r13,	r12	;
    8da0:	8c 11       	sxt	r12		;
    8da2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8da6:	4e 4c       	mov.b	r12,	r14	;
    8da8:	7d 40 1c 00 	mov.b	#28,	r13	;#0x001c
    8dac:	1c 41 02 00 	mov	2(r1),	r12	;
    8db0:	b0 12 4e 82 	call	#33358		;#0x824e

00008db4 <.Loc.716.3>:
     devp->config->length);
  
  /* PKTParam2 - Pkt_format, preamble_size, Whitening_on, CRC_on, Adrs_filt */
  if (!packet_config->broadcast) {
    8db4:	2c 41       	mov	@r1,	r12	;
    8db6:	6c 4c       	mov.b	@r12,	r12	;
    8db8:	7c f0 60 00 	and.b	#96,	r12	;#0x0060
    8dbc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8dc0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8dc2:	14 20       	jnz	$+42     	;abs 0x8dec

00008dc4 <.Loc.717.3>:
    packet_config->broadcast = packet_config->addressing;
    8dc4:	2c 41       	mov	@r1,	r12	;
    8dc6:	6c 4c       	mov.b	@r12,	r12	;
    8dc8:	5c 0f       	rrum	#4,	r12	;
    8dca:	5c f3       	and.b	#1,	r12	;r3 As==01
    8dcc:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8dd0:	7c f0 03 00 	and.b	#3,	r12	;
    8dd4:	4d 4c       	mov.b	r12,	r13	;
    8dd6:	2c 41       	mov	@r1,	r12	;
    8dd8:	7d f0 03 00 	and.b	#3,	r13	;
    8ddc:	44 18 0d 5d 	rpt #5 { rlax.w	r13		;
    8de0:	6e 4c       	mov.b	@r12,	r14	;
    8de2:	7e f0 9f ff 	and.b	#65439,	r14	;#0xff9f
    8de6:	4d de       	bis.b	r14,	r13	;
    8de8:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00008dec <.L121>:
  }
  
  /* PKTParam1 - Address */
  if (packet_config->broadcast) {
    8dec:	2c 41       	mov	@r1,	r12	;
    8dee:	6c 4c       	mov.b	@r12,	r12	;
    8df0:	7c f0 60 00 	and.b	#96,	r12	;#0x0060
    8df4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8df8:	0c 93       	cmp	#0,	r12	;r3 As==00
    8dfa:	0c 24       	jz	$+26     	;abs 0x8e14

00008dfc <.Loc.722.3>:
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
    8dfc:	1c 41 02 00 	mov	2(r1),	r12	;
    8e00:	2c 4c       	mov	@r12,	r12	;
    8e02:	5c 4c 22 00 	mov.b	34(r12),r12	;0x00022
    8e06:	4e 4c       	mov.b	r12,	r14	;
    8e08:	7d 40 1d 00 	mov.b	#29,	r13	;#0x001d
    8e0c:	1c 41 02 00 	mov	2(r1),	r12	;
    8e10:	b0 12 4e 82 	call	#33358		;#0x824e

00008e14 <.L122>:
  }
  
  sx1212SetRegister(devp, PKTParam2, 
      ((packet_config->format == Variable ? 1 : 0) << 7) | 
    8e14:	2c 41       	mov	@r1,	r12	;
    8e16:	6c 4c       	mov.b	@r12,	r12	;
    8e18:	5c f3       	and.b	#1,	r12	;r3 As==01
    8e1a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e1e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e20:	03 24       	jz	$+8      	;abs 0x8e28

00008e22 <.Loc.726.3>:
    8e22:	3c 40 80 ff 	mov	#65408,	r12	;#0xff80
    8e26:	01 3c       	jmp	$+4      	;abs 0x8e2a

00008e28 <.L123>:
    8e28:	4c 43       	clr.b	r12		;

00008e2a <.L124>:
      /* (packet_config->preamble_len << 5) | */
      (packet_config->whitening << 4) |
    8e2a:	2d 41       	mov	@r1,	r13	;
    8e2c:	6d 4d       	mov.b	@r13,	r13	;
    8e2e:	12 c3       	clrc			
    8e30:	0d 10       	rrc	r13		;
    8e32:	5d f3       	and.b	#1,	r13	;r3 As==01
    8e34:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    8e38:	43 18 0d 5d 	rpt #4 { rlax.w	r13		;

00008e3c <.Loc.726.3>:
  if (packet_config->broadcast) {
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
  }
  
  sx1212SetRegister(devp, PKTParam2, 
      ((packet_config->format == Variable ? 1 : 0) << 7) | 
    8e3c:	8d 11       	sxt	r13		;
    8e3e:	4c dd       	bis.b	r13,	r12	;
    8e40:	4d 4c       	mov.b	r12,	r13	;
    8e42:	8d 11       	sxt	r13		;

00008e44 <.Loc.729.3>:
      /* (packet_config->preamble_len << 5) | */
      (packet_config->whitening << 4) |
      (packet_config->crc << 3) |
    8e44:	2c 41       	mov	@r1,	r12	;
    8e46:	6c 4c       	mov.b	@r12,	r12	;
    8e48:	5c 0b       	rrum	#3,	r12	;
    8e4a:	5c f3       	and.b	#1,	r12	;r3 As==01
    8e4c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e50:	42 18 0c 5c 	rpt #3 { rlax.w	r12		;

00008e54 <.Loc.728.3>:
  }
  
  sx1212SetRegister(devp, PKTParam2, 
      ((packet_config->format == Variable ? 1 : 0) << 7) | 
      /* (packet_config->preamble_len << 5) | */
      (packet_config->whitening << 4) |
    8e54:	8c 11       	sxt	r12		;
    8e56:	4c dd       	bis.b	r13,	r12	;
    8e58:	4d 4c       	mov.b	r12,	r13	;
    8e5a:	8d 11       	sxt	r13		;

00008e5c <.Loc.730.3>:
      (packet_config->crc << 3) |
      (packet_config->broadcast << 1));
    8e5c:	2c 41       	mov	@r1,	r12	;
    8e5e:	6c 4c       	mov.b	@r12,	r12	;
    8e60:	5c 0f       	rrum	#4,	r12	;
    8e62:	5c 03       	rrum	#1,	r12	;
    8e64:	7c f0 03 00 	and.b	#3,	r12	;
    8e68:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e6c:	0c 5c       	rla	r12		;

00008e6e <.Loc.729.3>:
  
  sx1212SetRegister(devp, PKTParam2, 
      ((packet_config->format == Variable ? 1 : 0) << 7) | 
      /* (packet_config->preamble_len << 5) | */
      (packet_config->whitening << 4) |
      (packet_config->crc << 3) |
    8e6e:	8c 11       	sxt	r12		;
    8e70:	4c dd       	bis.b	r13,	r12	;
    8e72:	8c 11       	sxt	r12		;

00008e74 <.Loc.725.3>:
  /* PKTParam1 - Address */
  if (packet_config->broadcast) {
    sx1212SetRegister(devp, PKTParam1, devp->config->addr);
  }
  
  sx1212SetRegister(devp, PKTParam2, 
    8e74:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e78:	4e 4c       	mov.b	r12,	r14	;
    8e7a:	7d 40 1e 00 	mov.b	#30,	r13	;#0x001e
    8e7e:	1c 41 02 00 	mov	2(r1),	r12	;
    8e82:	b0 12 4e 82 	call	#33358		;#0x824e

00008e86 <.Loc.733.3>:
      (packet_config->whitening << 4) |
      (packet_config->crc << 3) |
      (packet_config->broadcast << 1));
  
  /* PktParam3 - CRC_autoclr */
  sx1212SetRegister(devp, PKTParam3, ((!packet_config->crc_autoclear) << 7));
    8e86:	2c 41       	mov	@r1,	r12	;
    8e88:	6c 4c       	mov.b	@r12,	r12	;
    8e8a:	7c f0 80 ff 	and.b	#65408,	r12	;#0xff80
    8e8e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e92:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e94:	03 20       	jnz	$+8      	;abs 0x8e9c

00008e96 <.Loc.733.3>:
    8e96:	7c 40 80 00 	mov.b	#128,	r12	;#0x0080
    8e9a:	01 3c       	jmp	$+4      	;abs 0x8e9e

00008e9c <.L125>:
    8e9c:	4c 43       	clr.b	r12		;

00008e9e <.L126>:
    8e9e:	4e 4c       	mov.b	r12,	r14	;
    8ea0:	7d 40 1f 00 	mov.b	#31,	r13	;#0x001f
    8ea4:	1c 41 02 00 	mov	2(r1),	r12	;
    8ea8:	b0 12 4e 82 	call	#33358		;#0x824e

00008eac <.Loc.734.3>:
}
    8eac:	03 43       	nop			
    8eae:	21 52       	add	#4,	r1	;r2 As==10
    8eb0:	30 41       	ret			

00008eb2 <sx1212ObjectInit>:
 *
 * @param[out] devp     pointer to the @p SX1212Driver object
 *
 * @init
 */
void sx1212ObjectInit(SX1212Driver *devp) {
    8eb2:	21 83       	decd	r1		;

00008eb4 <.LCFI32>:
    8eb4:	81 4c 00 00 	Address 0x0000000000008eb6 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00008eb6 <L0>:
	...

00008eb8 <.Loc.904.3>:
  
  /* Set all the stored registers to their reset states */
  devp->regs.MCParam0 = 0x30;
    8eb8:	2c 41       	mov	@r1,	r12	;
    8eba:	fc 40 30 00 	mov.b	#48,	2(r12)	;#0x0030
    8ebe:	02 00 

00008ec0 <.Loc.905.3>:
}
    8ec0:	03 43       	nop			
    8ec2:	21 53       	incd	r1		;
    8ec4:	30 41       	ret			

00008ec6 <sx1212Start>:
 * @param[in] devp      pointer to the @p SX1212Driver object
 * @param[in] config    pointer to the @p SX1212Config object
 *
 * @api
 */
void sx1212Start(SX1212Driver *devp, const SX1212Config *config) {
    8ec6:	21 82       	sub	#4,	r1	;r2 As==10

00008ec8 <.LCFI33>:
    8ec8:	81 4c 02 00 	mov	r12,	2(r1)	;
    8ecc:	81 4d 00 00 	mov	r13,	0(r1)	;

00008ed0 <.Loc.920.3>:
  
  devp->config = config;
    8ed0:	1c 41 02 00 	mov	2(r1),	r12	;
    8ed4:	ac 41 00 00 	mov	@r1,	0(r12)	;

00008ed8 <.Loc.922.3>:
  /* Reset the device to get it into a known state */
  sx1212Reset(devp);
    8ed8:	1c 41 02 00 	mov	2(r1),	r12	;
    8edc:	b0 12 c8 8b 	call	#35784		;#0x8bc8

00008ee0 <.Loc.927.3>:
#if SX1212_SHARED_SPI
  spiAcquireBus(config->spip);
#endif
  /* Start device SPI interface */
  spiStart(config->spip, config->spicfgp);
    8ee0:	2c 41       	mov	@r1,	r12	;
    8ee2:	2c 4c       	mov	@r12,	r12	;
    8ee4:	2d 41       	mov	@r1,	r13	;
    8ee6:	1d 4d 04 00 	mov	4(r13),	r13	;
    8eea:	b0 12 52 70 	call	#28754		;#0x7052

00008eee <.Loc.929.3>:
  /* Put the device into sleep mode */
  sx1212SetMode(devp, Sleep);
    8eee:	4d 43       	clr.b	r13		;
    8ef0:	1c 41 02 00 	mov	2(r1),	r12	;
    8ef4:	b0 12 ba 8c 	call	#36026		;#0x8cba

00008ef8 <.Loc.931.3>:
  /* Set device configuration */
  sx1212SetFrequency(devp, config->freq);
    8ef8:	2c 41       	mov	@r1,	r12	;
    8efa:	1d 4c 0e 00 	mov	14(r12),r13	;0x0000e
    8efe:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    8f02:	0e 4d       	mov	r13,	r14	;
    8f04:	0d 4c       	mov	r12,	r13	;
    8f06:	1c 41 02 00 	mov	2(r1),	r12	;
    8f0a:	b0 12 c6 85 	call	#34246		;#0x85c6

00008f0e <.Loc.932.3>:
  sx1212SetDeviation(devp, config->fdev);
    8f0e:	2c 41       	mov	@r1,	r12	;
    8f10:	1d 4c 12 00 	mov	18(r12),r13	;0x00012
    8f14:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    8f18:	0e 4d       	mov	r13,	r14	;
    8f1a:	0d 4c       	mov	r12,	r13	;
    8f1c:	1c 41 02 00 	mov	2(r1),	r12	;
    8f20:	b0 12 82 85 	call	#34178		;#0x8582

00008f24 <.Loc.933.3>:
  sx1212SetBitrate(devp, config->bitrate);
    8f24:	2c 41       	mov	@r1,	r12	;
    8f26:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    8f2a:	1c 4c 08 00 	mov	8(r12),	r12	;
    8f2e:	0e 4d       	mov	r13,	r14	;
    8f30:	0d 4c       	mov	r12,	r13	;
    8f32:	1c 41 02 00 	mov	2(r1),	r12	;
    8f36:	b0 12 3c 84 	call	#33852		;#0x843c

00008f3a <.Loc.934.3>:
  sx1212SetRxBw(devp, config->rx_bw);
    8f3a:	2c 41       	mov	@r1,	r12	;
    8f3c:	1d 4c 16 00 	mov	22(r12),r13	;0x00016
    8f40:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    8f44:	0e 4d       	mov	r13,	r14	;
    8f46:	0d 4c       	mov	r12,	r13	;
    8f48:	1c 41 02 00 	mov	2(r1),	r12	;
    8f4c:	b0 12 04 8d 	call	#36100		;#0x8d04

00008f50 <.Loc.935.3>:
  sx1212SetSync(devp, config->sync_word);
    8f50:	2c 41       	mov	@r1,	r12	;
    8f52:	1d 4c 1a 00 	mov	26(r12),r13	;0x0001a
    8f56:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    8f5a:	0e 4d       	mov	r13,	r14	;
    8f5c:	0d 4c       	mov	r12,	r13	;
    8f5e:	1c 41 02 00 	mov	2(r1),	r12	;
    8f62:	b0 12 5e 8b 	call	#35678		;#0x8b5e

00008f66 <.Loc.936.3>:
  if (config->packet_config) {
    8f66:	2c 41       	mov	@r1,	r12	;
    8f68:	1c 4c 20 00 	mov	32(r12),r12	;0x00020
    8f6c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8f6e:	0b 24       	jz	$+24     	;abs 0x8f86

00008f70 <.Loc.937.3>:
    sx1212ConfigurePackets(devp, devp->config->packet_config);
    8f70:	1c 41 02 00 	mov	2(r1),	r12	;
    8f74:	2c 4c       	mov	@r12,	r12	;
    8f76:	1c 4c 20 00 	mov	32(r12),r12	;0x00020
    8f7a:	0d 4c       	mov	r12,	r13	;
    8f7c:	1c 41 02 00 	mov	2(r1),	r12	;
    8f80:	b0 12 66 8d 	call	#36198		;#0x8d66
    8f84:	07 3c       	jmp	$+16     	;abs 0x8f94

00008f86 <.L148>:
  }
  else {
    /* Buffered mode */
    sx1212SetRegister(devp, MCParam1, 0x64);
    8f86:	7e 40 64 00 	mov.b	#100,	r14	;#0x0064
    8f8a:	5d 43       	mov.b	#1,	r13	;r3 As==01
    8f8c:	1c 41 02 00 	mov	2(r1),	r12	;
    8f90:	b0 12 4e 82 	call	#33358		;#0x824e

00008f94 <.L150>:
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
  sx1212SetRegister(devp, RXParam2, 0x20 | 
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
    8f94:	2c 41       	mov	@r1,	r12	;
    8f96:	5c 4c 1c 00 	mov.b	28(r12),r12	;0x0001c
    8f9a:	4c 5c       	rla.b	r12		;
    8f9c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00008fa0 <.Loc.946.3>:
    sx1212SetRegister(devp, MCParam1, 0x64);
  }
  
  /* RXParam2 - Sync_tol + Sync_size */
  osalDbgAssert(config->sync_tol <= 3, "sync tolerance too loose");
  sx1212SetRegister(devp, RXParam2, 0x20 | 
    8fa0:	7c d0 38 00 	bis.b	#56,	r12	;#0x0038
    8fa4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8fa8:	4e 4c       	mov.b	r12,	r14	;
    8faa:	7d 40 12 00 	mov.b	#18,	r13	;#0x0012
    8fae:	1c 41 02 00 	mov	2(r1),	r12	;
    8fb2:	b0 12 4e 82 	call	#33358		;#0x824e

00008fb6 <.Loc.951.3>:
      ((sizeof(SX1212_SYNC_TYPE) - 1) << 3) |
      (config->sync_tol << 1));
  
  /* IRQParam2 - enable PLL lock */
  sx1212SetRegister(devp, IRQParam2, 0x51);
    8fb6:	7e 40 51 00 	mov.b	#81,	r14	;#0x0051
    8fba:	7d 40 0e 00 	mov.b	#14,	r13	;#0x000e
    8fbe:	1c 41 02 00 	mov	2(r1),	r12	;
    8fc2:	b0 12 4e 82 	call	#33358		;#0x824e

00008fc6 <.Loc.954.3>:
  
  /* Set Fifo size to 64 */
  sx1212SetRegister(devp, IRQParam0, 0xC0);
    8fc6:	7e 40 c0 ff 	mov.b	#65472,	r14	;#0xffc0
    8fca:	7d 40 0c 00 	mov.b	#12,	r13	;#0x000c
    8fce:	1c 41 02 00 	mov	2(r1),	r12	;
    8fd2:	b0 12 4e 82 	call	#33358		;#0x824e

00008fd6 <.Loc.960.3>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(config->spip);
#endif

}
    8fd6:	03 43       	nop			
    8fd8:	21 52       	add	#4,	r1	;r2 As==10
    8fda:	30 41       	ret			

00008fdc <sx1212StartReceive>:
 *          
 * @param[in] devp    pointer to the SX1212 driver
 * @param[in] timeout how long to wait for additional bytes to arrive
 * @return  @p MSG_OK, or @p MSG_TIMEOUT if timeout occurs
 */
msg_t sx1212StartReceive(SX1212Driver *devp, systime_t timeout) {
    8fdc:	21 82       	sub	#4,	r1	;r2 As==10

00008fde <L0>:
    8fde:	81 4c 02 00 	mov	r12,	2(r1)	;
    8fe2:	81 4d 00 00 	mov	r13,	0(r1)	;

00008fe6 <.Loc.1014.3>:
#endif
  
  /* Assume in Sleep mode */
  /* Go to Rx, by degrees */
  /* Standby */
  sx1212SetMode(devp, Stdby);
    8fe6:	7d 40 20 00 	mov.b	#32,	r13	;#0x0020
    8fea:	1c 41 02 00 	mov	2(r1),	r12	;
    8fee:	b0 12 ba 8c 	call	#36026		;#0x8cba

00008ff2 <.Loc.1020.3>:
  /* Release SPI bus I guess... */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
  /* Wait TS_OSC */
  osalThreadSleepMilliseconds(5);
    8ff2:	7c 40 05 00 	mov.b	#5,	r12	;
    8ff6:	b0 12 96 81 	call	#33174		;#0x8196

00008ffa <.Loc.1026.3>:
#if SX1212_SHARED_SPI
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  /* FS */
  sx1212SetMode(devp, FS);
    8ffa:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    8ffe:	1c 41 02 00 	mov	2(r1),	r12	;
    9002:	b0 12 ba 8c 	call	#36026		;#0x8cba

00009006 <.Loc.1030.3>:
  /* Wait for PLL lock */
  /* can't use the macro - SPI state change must be reversed before return */
#if defined(SX1212_PLL_LOCK)
  suspend_result = irq_block_with_timeout(devp, SX1212_PLL_LOCK, timeout);
    9006:	2e 41       	mov	@r1,	r14	;
    9008:	3d 40 20 b2 	mov	#45600,	r13	;#0xb220
    900c:	1c 41 02 00 	mov	2(r1),	r12	;
    9010:	b0 12 a8 82 	call	#33448		;#0x82a8
    9014:	82 4c 06 52 	mov	r12,	&0x5206	;

00009018 <.Loc.1035.3>:
#else
  suspend_result = block_on_bit(devp, IRQParam2, BIT1, timeout);
#endif
  /* Receive */
  sx1212SetMode(devp, Rx);
    9018:	7d 40 60 00 	mov.b	#96,	r13	;#0x0060
    901c:	1c 41 02 00 	mov	2(r1),	r12	;
    9020:	b0 12 ba 8c 	call	#36026		;#0x8cba

00009024 <.Loc.1042.3>:
  /* Release SPI bus */
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
  
  return suspend_result;
    9024:	1c 42 06 52 	mov	&0x5206,r12	;0x5206

00009028 <.Loc.1043.3>:
}
    9028:	21 52       	add	#4,	r1	;r2 As==10
    902a:	30 41       	ret			

0000902c <sx1212RSSI>:
 * @param[in] devp  pointer to the @p SX1212Driver object
 * @return    RSSI value in dBm (-115 to 12)
 * 
 * @note    Accuracy is very poor outside of -100 to -40 range
 */
int8_t sx1212RSSI(SX1212Driver *devp) {
    902c:	21 82       	sub	#4,	r1	;r2 As==10

0000902e <.LCFI38>:
    902e:	81 4c 00 00 	mov	r12,	0(r1)	;

00009032 <.Loc.1123.3>:
  uint8_t rssi = 0;
    9032:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00009036 <.Loc.1133.3>:
  spiAcquireBus(devp->config->spip);
  spiStart(devp->config->spip, devp->config->spicfgp);
#endif
  
  /* Assume we're already in RX mode */
  rssi = sx1212ReadRegister(devp, RXParam4);
    9036:	7d 40 14 00 	mov.b	#20,	r13	;#0x0014
    903a:	2c 41       	mov	@r1,	r12	;
    903c:	b0 12 f0 81 	call	#33264		;#0x81f0
    9040:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

00009044 <.Loc.1139.3>:
  
#if SX1212_SHARED_SPI
  spiReleaseBus(devp->config->spip);
#endif
    
  return ((int8_t)(rssi >> 1)) - 115;
    9044:	5c 41 03 00 	mov.b	3(r1),	r12	;
    9048:	12 c3       	clrc			
    904a:	0c 10       	rrc	r12		;
    904c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9050:	7c 50 8d ff 	add.b	#65421,	r12	;#0xff8d
    9054:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9058:	8c 11       	sxt	r12		;

0000905a <.Loc.1140.3>:
}
    905a:	21 52       	add	#4,	r1	;r2 As==10
    905c:	30 41       	ret			

0000905e <sx1212CLKOUT>:

void sx1212CLKOUT(SX1212Driver *devp, uint8_t div) {
    905e:	21 82       	sub	#4,	r1	;r2 As==10

00009060 <.LCFI39>:
    9060:	81 4c 02 00 	mov	r12,	2(r1)	;
    9064:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

00009068 <.Loc.1144.3>:
  
  sx1212SetRegister(devp, OSCParam, 0x80 | (div << 2));
    9068:	5c 41 01 00 	mov.b	1(r1),	r12	;
    906c:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    9070:	8c 11       	sxt	r12		;
    9072:	7c d0 80 ff 	bis.b	#65408,	r12	;#0xff80
    9076:	8c 11       	sxt	r12		;
    9078:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    907c:	4e 4c       	mov.b	r12,	r14	;
    907e:	7d 40 1b 00 	mov.b	#27,	r13	;#0x001b
    9082:	1c 41 02 00 	mov	2(r1),	r12	;
    9086:	b0 12 4e 82 	call	#33358		;#0x824e

0000908a <.Loc.1145.3>:
}
    908a:	03 43       	nop			
    908c:	21 52       	add	#4,	r1	;r2 As==10
    908e:	30 41       	ret			

00009090 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    9090:	ff 3f       	jmp	$+0      	;abs 0x9090

00009092 <Vector2>:
    9092:	ff 3f       	jmp	$+0      	;abs 0x9092

00009094 <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    9094:	ff 3f       	jmp	$+0      	;abs 0x9094

00009096 <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    9096:	ff 3f       	jmp	$+0      	;abs 0x9096

00009098 <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    9098:	ff 3f       	jmp	$+0      	;abs 0x9098

0000909a <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    909a:	ff 3f       	jmp	$+0      	;abs 0x909a

0000909c <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    909c:	ff 3f       	jmp	$+0      	;abs 0x909c

0000909e <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    909e:	ff 3f       	jmp	$+0      	;abs 0x909e

000090a0 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    90a0:	ff 3f       	jmp	$+0      	;abs 0x90a0

000090a2 <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    90a2:	ff 3f       	jmp	$+0      	;abs 0x90a2

000090a4 <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    90a4:	ff 3f       	jmp	$+0      	;abs 0x90a4

000090a6 <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    90a6:	ff 3f       	jmp	$+0      	;abs 0x90a6

000090a8 <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    90a8:	ff 3f       	jmp	$+0      	;abs 0x90a8

000090aa <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    90aa:	ff 3f       	jmp	$+0      	;abs 0x90aa

000090ac <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    90ac:	ff 3f       	jmp	$+0      	;abs 0x90ac

000090ae <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    90ae:	ff 3f       	jmp	$+0      	;abs 0x90ae

000090b0 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    90b0:	ff 3f       	jmp	$+0      	;abs 0x90b0

000090b2 <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    90b2:	ff 3f       	jmp	$+0      	;abs 0x90b2

000090b4 <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    90b4:	ff 3f       	jmp	$+0      	;abs 0x90b4

000090b6 <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    90b6:	ff 3f       	jmp	$+0      	;abs 0x90b6

000090b8 <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    90b8:	ff 3f       	jmp	$+0      	;abs 0x90b8

000090ba <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    90ba:	ff 3f       	jmp	$+0      	;abs 0x90ba

000090bc <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    90bc:	ff 3f       	jmp	$+0      	;abs 0x90bc

000090be <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    90be:	ff 3f       	jmp	$+0      	;abs 0x90be

000090c0 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    90c0:	ff 3f       	jmp	$+0      	;abs 0x90c0

000090c2 <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    90c2:	ff 3f       	jmp	$+0      	;abs 0x90c2

000090c4 <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    90c4:	ff 3f       	jmp	$+0      	;abs 0x90c4

000090c6 <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    90c6:	ff 3f       	jmp	$+0      	;abs 0x90c6

000090c8 <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    90c8:	ff 3f       	jmp	$+0      	;abs 0x90c8

000090ca <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    90ca:	ff 3f       	jmp	$+0      	;abs 0x90ca

000090cc <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    90cc:	ff 3f       	jmp	$+0      	;abs 0x90cc

000090ce <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    90ce:	ff 3f       	jmp	$+0      	;abs 0x90ce

000090d0 <Vector35>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    90d0:	ff 3f       	jmp	$+0      	;abs 0x90d0

000090d2 <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    90d2:	ff 3f       	jmp	$+0      	;abs 0x90d2

000090d4 <Vector38>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    90d4:	ff 3f       	jmp	$+0      	;abs 0x90d4

000090d6 <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    90d6:	ff 3f       	jmp	$+0      	;abs 0x90d6

000090d8 <Vector41>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    90d8:	ff 3f       	jmp	$+0      	;abs 0x90d8

000090da <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    90da:	ff 3f       	jmp	$+0      	;abs 0x90da

000090dc <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    90dc:	ff 3f       	jmp	$+0      	;abs 0x90dc

000090de <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    90de:	ff 3f       	jmp	$+0      	;abs 0x90de

000090e0 <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    90e0:	ff 3f       	jmp	$+0      	;abs 0x90e0

000090e2 <Vector47>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    90e2:	ff 3f       	jmp	$+0      	;abs 0x90e2

000090e4 <Vector48>:
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {

  while (1) {
    90e4:	ff 3f       	jmp	$+0      	;abs 0x90e4

000090e6 <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    90e6:	ff 3f       	jmp	$+0      	;abs 0x90e6

000090e8 <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    90e8:	ff 3f       	jmp	$+0      	;abs 0x90e8

000090ea <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    90ea:	ff 3f       	jmp	$+0      	;abs 0x90ea

000090ec <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    90ec:	ff 3f       	jmp	$+0      	;abs 0x90ec

000090ee <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    90ee:	ff 3f       	jmp	$+0      	;abs 0x90ee

000090f0 <Thread1>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    90f0:	21 83       	decd	r1		;

000090f2 <L0>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread1, 4096);
THD_FUNCTION(Thread1, arg) {
    90f2:	81 4c 00 00 	mov	r12,	0(r1)	;

000090f6 <.Loc.94.1>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    90f6:	4d 43       	clr.b	r13		;
    90f8:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a
    90fc:	b0 12 48 6f 	call	#28488		;#0x6f48

00009100 <.Loc.97.1>:
  
  /* Initialize the SX1212 driver */
  sx1212ObjectInit(&SX1212D1);
    9100:	3c 40 08 52 	mov	#21000,	r12	;#0x5208
    9104:	b0 12 b2 8e 	call	#36530		;#0x8eb2

00009108 <.Loc.100.1>:
  
  /* Start the SX1212 driver */
  sx1212Start(&SX1212D1, &config);
    9108:	3d 40 e8 50 	mov	#20712,	r13	;#0x50e8
    910c:	3c 40 08 52 	mov	#21000,	r12	;#0x5208
    9110:	b0 12 c6 8e 	call	#36550		;#0x8ec6

00009114 <.Loc.104.1>:

  /*chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));*/
  /* Set it to RX mode so RSSI is valid */
  sx1212StartReceive(&SX1212D1, TIME_INFINITE);
    9114:	4d 43       	clr.b	r13		;
    9116:	3c 40 08 52 	mov	#21000,	r12	;#0x5208
    911a:	b0 12 dc 8f 	call	#36828		;#0x8fdc

0000911e <.Loc.107.1>:
  
  /* FOR DEBUGGING */
  sx1212CLKOUT(&SX1212D1, 0x0F);
    911e:	7d 40 0f 00 	mov.b	#15,	r13	;#0x000f
    9122:	3c 40 08 52 	mov	#21000,	r12	;#0x5208
    9126:	b0 12 5e 90 	call	#36958		;#0x905e

0000912a <.Loc.109.1>:
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    912a:	14 3c       	jmp	$+42     	;abs 0x9154

0000912c <.L4>:
    rssi = sx1212RSSI(&SX1212D1);
    912c:	3c 40 08 52 	mov	#21000,	r12	;#0x5208
    9130:	b0 12 2c 90 	call	#36908		;#0x902c
    9134:	8c 11       	sxt	r12		;
    9136:	c2 4c 0e 52 	mov.b	r12,	&0x520e	;

0000913a <.Loc.111.1>:
    chnWrite(&SD0, (uint8_t *)(&rssi), 1);
    913a:	1c 42 3a 51 	mov	&0x513a,r12	;0x513a
    913e:	2f 4c       	mov	@r12,	r15	;
    9140:	5e 43       	mov.b	#1,	r14	;r3 As==01
    9142:	3d 40 0e 52 	mov	#21006,	r13	;#0x520e
    9146:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a
    914a:	8f 12       	call	r15		;

0000914c <.Loc.113.1>:
    
    chThdSleepMilliseconds(1000);
    914c:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    9150:	b0 12 22 65 	call	#25890		;#0x6522

00009154 <.L3>:
  sx1212StartReceive(&SX1212D1, TIME_INFINITE);
  
  /* FOR DEBUGGING */
  sx1212CLKOUT(&SX1212D1, 0x0F);
  
  while (chnGetTimeout(&SD0, TIME_INFINITE)) {
    9154:	1c 42 3a 51 	mov	&0x513a,r12	;0x513a
    9158:	1e 4c 0a 00 	mov	10(r12),r14	;0x0000a
    915c:	4d 43       	clr.b	r13		;
    915e:	3c 40 3a 51 	mov	#20794,	r12	;#0x513a
    9162:	8e 12       	call	r14		;
    9164:	0c 93       	cmp	#0,	r12	;r3 As==00
    9166:	e2 23       	jnz	$-58     	;abs 0x912c

00009168 <.Loc.115.1>:
    rssi = sx1212RSSI(&SX1212D1);
    chnWrite(&SD0, (uint8_t *)(&rssi), 1);
    
    chThdSleepMilliseconds(1000);
  }
}
    9168:	03 43       	nop			
    916a:	21 53       	incd	r1		;
    916c:	30 41       	ret			

0000916e <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    916e:	b2 40 80 5a 	Address 0x0000000000009170 is out of bounds.
Address 0x0000000000009172 is out of bounds.
mov	#65535,	&0xffff	;#0xffff
    9172:	5c 01 

00009170 <L0>:
    9170:	80 5a 5c 01 	add	r10,	0x015c	; PC rel. 0x92ce

00009174 <.Loc.139.1>:

  halInit();
    9174:	b0 12 d8 66 	call	#26328		;#0x66d8

00009178 <.Loc.140.1>:
  chSysInit();
    9178:	b0 12 a6 62 	call	#25254		;#0x62a6

0000917c <.L6>:

  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    917c:	ff 3f       	jmp	$+0      	;abs 0x917c

0000917e <udivmodsi4>:
    917e:	5a 15       	pushm	#6,	r10	;16-bit words

00009180 <L0>:
    9180:	0a 4c       	mov	r12,	r10	;
    9182:	0b 4d       	mov	r13,	r11	;

00009184 <.LVL1>:
    9184:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00009188 <.Loc.35.1>:
    9188:	58 43       	mov.b	#1,	r8	;r3 As==01
    918a:	49 43       	clr.b	r9		;

0000918c <.Loc.38.1>:
    918c:	07 4b       	mov	r11,	r7	;

0000918e <.L2>:
    918e:	0f 9b       	cmp	r11,	r15	;
    9190:	11 28       	jnc	$+36     	;abs 0x91b4
    9192:	07 9f       	cmp	r15,	r7	;
    9194:	02 20       	jnz	$+6      	;abs 0x919a
    9196:	0e 9a       	cmp	r10,	r14	;
    9198:	0d 28       	jnc	$+28     	;abs 0x91b4

0000919a <.L20>:
    919a:	4c 43       	clr.b	r12		;

0000919c <.LVL3>:
    919c:	0d 4c       	mov	r12,	r13	;

0000919e <.L5>:
    919e:	07 48       	mov	r8,	r7	;
    91a0:	07 d9       	bis	r9,	r7	;
    91a2:	07 93       	cmp	#0,	r7	;r3 As==00
    91a4:	19 20       	jnz	$+52     	;abs 0x91d8

000091a6 <.L6>:
    91a6:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    91aa:	02 24       	jz	$+6      	;abs 0x91b0
    91ac:	0c 4a       	mov	r10,	r12	;
    91ae:	0d 4b       	mov	r11,	r13	;

000091b0 <.L1>:
    91b0:	55 17       	popm	#6,	r10	;16-bit words
    91b2:	30 41       	ret			

000091b4 <.L3>:
    91b4:	3d 53       	add	#-1,	r13	;r3 As==11

000091b6 <.Loc.38.1>:
    91b6:	0d 93       	cmp	#0,	r13	;r3 As==00
    91b8:	20 24       	jz	$+66     	;abs 0x91fa

000091ba <.Loc.38.1>:
    91ba:	0f 93       	cmp	#0,	r15	;r3 As==00
    91bc:	ee 3b       	jl	$-34     	;abs 0x919a

000091be <.Loc.40.1>:
    91be:	05 4e       	mov	r14,	r5	;
    91c0:	06 4f       	mov	r15,	r6	;
    91c2:	05 5e       	add	r14,	r5	;
    91c4:	06 6f       	addc	r15,	r6	;
    91c6:	0e 45       	mov	r5,	r14	;

000091c8 <.LVL7>:
    91c8:	0f 46       	mov	r6,	r15	;

000091ca <.LVL8>:
    91ca:	05 48       	mov	r8,	r5	;
    91cc:	06 49       	mov	r9,	r6	;
    91ce:	05 58       	add	r8,	r5	;
    91d0:	06 69       	addc	r9,	r6	;
    91d2:	08 45       	mov	r5,	r8	;

000091d4 <.LVL9>:
    91d4:	09 46       	mov	r6,	r9	;

000091d6 <.LVL10>:
    91d6:	db 3f       	jmp	$-72     	;abs 0x918e

000091d8 <.L12>:
    91d8:	0b 9f       	cmp	r15,	r11	;
    91da:	08 28       	jnc	$+18     	;abs 0x91ec
    91dc:	0f 9b       	cmp	r11,	r15	;
    91de:	02 20       	jnz	$+6      	;abs 0x91e4
    91e0:	0a 9e       	cmp	r14,	r10	;
    91e2:	04 28       	jnc	$+10     	;abs 0x91ec

000091e4 <.L16>:
    91e4:	0a 8e       	sub	r14,	r10	;
    91e6:	0b 7f       	subc	r15,	r11	;

000091e8 <.Loc.48.1>:
    91e8:	0c d8       	bis	r8,	r12	;

000091ea <.LVL13>:
    91ea:	0d d9       	bis	r9,	r13	;

000091ec <.L10>:
    91ec:	12 c3       	clrc			
    91ee:	09 10       	rrc	r9		;
    91f0:	08 10       	rrc	r8		;

000091f2 <.Loc.51.1>:
    91f2:	12 c3       	clrc			
    91f4:	0f 10       	rrc	r15		;
    91f6:	0e 10       	rrc	r14		;
    91f8:	d2 3f       	jmp	$-90     	;abs 0x919e

000091fa <.L14>:
    91fa:	0c 4d       	mov	r13,	r12	;

000091fc <.LVL18>:
    91fc:	d4 3f       	jmp	$-86     	;abs 0x91a6

000091fe <__mspabi_divlu>:
    91fe:	21 83       	decd	r1		;

00009200 <.LCFI5>:
    9200:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00009204 <L0>:
    9204:	b0 12 7e 91 	call	#37246		;#0x917e

00009208 <.LVL46>:
    9208:	21 53       	incd	r1		;
    920a:	30 41       	ret			

0000920c <__mspabi_slli_15>:
    920c:	0c 5c       	rla	r12		;

0000920e <__mspabi_slli_14>:
    920e:	0c 5c       	rla	r12		;

00009210 <__mspabi_slli_13>:
    9210:	0c 5c       	rla	r12		;

00009212 <__mspabi_slli_12>:
    9212:	0c 5c       	rla	r12		;

00009214 <__mspabi_slli_11>:
    9214:	0c 5c       	rla	r12		;

00009216 <__mspabi_slli_10>:
    9216:	0c 5c       	rla	r12		;

00009218 <__mspabi_slli_9>:
    9218:	0c 5c       	rla	r12		;

0000921a <__mspabi_slli_8>:
    921a:	0c 5c       	rla	r12		;

0000921c <__mspabi_slli_7>:
    921c:	0c 5c       	rla	r12		;

0000921e <__mspabi_slli_6>:
    921e:	0c 5c       	rla	r12		;

00009220 <__mspabi_slli_5>:
    9220:	0c 5c       	rla	r12		;

00009222 <__mspabi_slli_4>:
    9222:	0c 5c       	rla	r12		;

00009224 <__mspabi_slli_3>:
    9224:	0c 5c       	rla	r12		;

00009226 <__mspabi_slli_2>:
    9226:	0c 5c       	rla	r12		;

00009228 <__mspabi_slli_1>:
    9228:	0c 5c       	rla	r12		;
    922a:	30 41       	ret			

0000922c <.L11>:
    922c:	3d 53       	add	#-1,	r13	;r3 As==11
    922e:	0c 5c       	rla	r12		;

00009230 <__mspabi_slli>:
    9230:	0d 93       	cmp	#0,	r13	;r3 As==00
    9232:	fc 23       	jnz	$-6      	;abs 0x922c
    9234:	30 41       	ret			

00009236 <__mspabi_slll_15>:
    9236:	0c 5c       	rla	r12		;
    9238:	0d 6d       	rlc	r13		;

0000923a <__mspabi_slll_14>:
    923a:	0c 5c       	rla	r12		;
    923c:	0d 6d       	rlc	r13		;

0000923e <__mspabi_slll_13>:
    923e:	0c 5c       	rla	r12		;
    9240:	0d 6d       	rlc	r13		;

00009242 <__mspabi_slll_12>:
    9242:	0c 5c       	rla	r12		;
    9244:	0d 6d       	rlc	r13		;

00009246 <__mspabi_slll_11>:
    9246:	0c 5c       	rla	r12		;
    9248:	0d 6d       	rlc	r13		;

0000924a <__mspabi_slll_10>:
    924a:	0c 5c       	rla	r12		;
    924c:	0d 6d       	rlc	r13		;

0000924e <__mspabi_slll_9>:
    924e:	0c 5c       	rla	r12		;
    9250:	0d 6d       	rlc	r13		;

00009252 <__mspabi_slll_8>:
    9252:	0c 5c       	rla	r12		;
    9254:	0d 6d       	rlc	r13		;

00009256 <__mspabi_slll_7>:
    9256:	0c 5c       	rla	r12		;
    9258:	0d 6d       	rlc	r13		;

0000925a <__mspabi_slll_6>:
    925a:	0c 5c       	rla	r12		;
    925c:	0d 6d       	rlc	r13		;

0000925e <__mspabi_slll_5>:
    925e:	0c 5c       	rla	r12		;
    9260:	0d 6d       	rlc	r13		;

00009262 <__mspabi_slll_4>:
    9262:	0c 5c       	rla	r12		;
    9264:	0d 6d       	rlc	r13		;

00009266 <__mspabi_slll_3>:
    9266:	0c 5c       	rla	r12		;
    9268:	0d 6d       	rlc	r13		;

0000926a <__mspabi_slll_2>:
    926a:	0c 5c       	rla	r12		;
    926c:	0d 6d       	rlc	r13		;

0000926e <__mspabi_slll_1>:
    926e:	0c 5c       	rla	r12		;
    9270:	0d 6d       	rlc	r13		;
    9272:	30 41       	ret			

00009274 <.L12>:
    9274:	3e 53       	add	#-1,	r14	;r3 As==11
    9276:	0c 5c       	rla	r12		;
    9278:	0d 6d       	rlc	r13		;

0000927a <__mspabi_slll>:
    927a:	0e 93       	cmp	#0,	r14	;r3 As==00
    927c:	fb 23       	jnz	$-8      	;abs 0x9274
    927e:	30 41       	ret			

00009280 <__mspabi_srli_15>:
    9280:	12 c3       	clrc			
    9282:	0c 10       	rrc	r12		;

00009284 <__mspabi_srli_14>:
    9284:	12 c3       	clrc			
    9286:	0c 10       	rrc	r12		;

00009288 <__mspabi_srli_13>:
    9288:	12 c3       	clrc			
    928a:	0c 10       	rrc	r12		;

0000928c <__mspabi_srli_12>:
    928c:	12 c3       	clrc			
    928e:	0c 10       	rrc	r12		;

00009290 <__mspabi_srli_11>:
    9290:	12 c3       	clrc			
    9292:	0c 10       	rrc	r12		;

00009294 <__mspabi_srli_10>:
    9294:	12 c3       	clrc			
    9296:	0c 10       	rrc	r12		;

00009298 <__mspabi_srli_9>:
    9298:	12 c3       	clrc			
    929a:	0c 10       	rrc	r12		;

0000929c <__mspabi_srli_8>:
    929c:	12 c3       	clrc			
    929e:	0c 10       	rrc	r12		;

000092a0 <__mspabi_srli_7>:
    92a0:	12 c3       	clrc			
    92a2:	0c 10       	rrc	r12		;

000092a4 <__mspabi_srli_6>:
    92a4:	12 c3       	clrc			
    92a6:	0c 10       	rrc	r12		;

000092a8 <__mspabi_srli_5>:
    92a8:	12 c3       	clrc			
    92aa:	0c 10       	rrc	r12		;

000092ac <__mspabi_srli_4>:
    92ac:	12 c3       	clrc			
    92ae:	0c 10       	rrc	r12		;

000092b0 <__mspabi_srli_3>:
    92b0:	12 c3       	clrc			
    92b2:	0c 10       	rrc	r12		;

000092b4 <__mspabi_srli_2>:
    92b4:	12 c3       	clrc			
    92b6:	0c 10       	rrc	r12		;

000092b8 <__mspabi_srli_1>:
    92b8:	12 c3       	clrc			
    92ba:	0c 10       	rrc	r12		;
    92bc:	30 41       	ret			

000092be <.L11>:
    92be:	3d 53       	add	#-1,	r13	;r3 As==11
    92c0:	12 c3       	clrc			
    92c2:	0c 10       	rrc	r12		;

000092c4 <__mspabi_srli>:
    92c4:	0d 93       	cmp	#0,	r13	;r3 As==00
    92c6:	fb 23       	jnz	$-8      	;abs 0x92be
    92c8:	30 41       	ret			

000092ca <__mspabi_srll_15>:
    92ca:	12 c3       	clrc			
    92cc:	0d 10       	rrc	r13		;
    92ce:	0c 10       	rrc	r12		;

000092d0 <__mspabi_srll_14>:
    92d0:	12 c3       	clrc			
    92d2:	0d 10       	rrc	r13		;
    92d4:	0c 10       	rrc	r12		;

000092d6 <__mspabi_srll_13>:
    92d6:	12 c3       	clrc			
    92d8:	0d 10       	rrc	r13		;
    92da:	0c 10       	rrc	r12		;

000092dc <__mspabi_srll_12>:
    92dc:	12 c3       	clrc			
    92de:	0d 10       	rrc	r13		;
    92e0:	0c 10       	rrc	r12		;

000092e2 <__mspabi_srll_11>:
    92e2:	12 c3       	clrc			
    92e4:	0d 10       	rrc	r13		;
    92e6:	0c 10       	rrc	r12		;

000092e8 <__mspabi_srll_10>:
    92e8:	12 c3       	clrc			
    92ea:	0d 10       	rrc	r13		;
    92ec:	0c 10       	rrc	r12		;

000092ee <__mspabi_srll_9>:
    92ee:	12 c3       	clrc			
    92f0:	0d 10       	rrc	r13		;
    92f2:	0c 10       	rrc	r12		;

000092f4 <__mspabi_srll_8>:
    92f4:	12 c3       	clrc			
    92f6:	0d 10       	rrc	r13		;
    92f8:	0c 10       	rrc	r12		;

000092fa <__mspabi_srll_7>:
    92fa:	12 c3       	clrc			
    92fc:	0d 10       	rrc	r13		;
    92fe:	0c 10       	rrc	r12		;

00009300 <__mspabi_srll_6>:
    9300:	12 c3       	clrc			
    9302:	0d 10       	rrc	r13		;
    9304:	0c 10       	rrc	r12		;

00009306 <__mspabi_srll_5>:
    9306:	12 c3       	clrc			
    9308:	0d 10       	rrc	r13		;
    930a:	0c 10       	rrc	r12		;

0000930c <__mspabi_srll_4>:
    930c:	12 c3       	clrc			
    930e:	0d 10       	rrc	r13		;
    9310:	0c 10       	rrc	r12		;

00009312 <__mspabi_srll_3>:
    9312:	12 c3       	clrc			
    9314:	0d 10       	rrc	r13		;
    9316:	0c 10       	rrc	r12		;

00009318 <__mspabi_srll_2>:
    9318:	12 c3       	clrc			
    931a:	0d 10       	rrc	r13		;
    931c:	0c 10       	rrc	r12		;

0000931e <__mspabi_srll_1>:
    931e:	12 c3       	clrc			
    9320:	0d 10       	rrc	r13		;
    9322:	0c 10       	rrc	r12		;
    9324:	30 41       	ret			

00009326 <.L12>:
    9326:	3e 53       	add	#-1,	r14	;r3 As==11
    9328:	12 c3       	clrc			
    932a:	0d 10       	rrc	r13		;
    932c:	0c 10       	rrc	r12		;

0000932e <__mspabi_srll>:
    932e:	0e 93       	cmp	#0,	r14	;r3 As==00
    9330:	fa 23       	jnz	$-10     	;abs 0x9326
    9332:	30 41       	ret			

00009334 <__mspabi_mpyi>:
    9334:	02 12       	push	r2		;
    9336:	32 c2       	dint			
    9338:	03 43       	nop			
    933a:	82 4c c0 04 	mov	r12,	&0x04c0	;
    933e:	82 4d c8 04 	mov	r13,	&0x04c8	;
    9342:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    9346:	00 13       	reti			

00009348 <__mspabi_mpyl>:
    9348:	02 12       	push	r2		;
    934a:	32 c2       	dint			
    934c:	03 43       	nop			
    934e:	82 4c d0 04 	mov	r12,	&0x04d0	;
    9352:	82 4d d2 04 	mov	r13,	&0x04d2	;
    9356:	82 4e e0 04 	mov	r14,	&0x04e0	;
    935a:	82 4f e2 04 	mov	r15,	&0x04e2	;
    935e:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    9362:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    9366:	00 13       	reti			

00009368 <memmove>:
    9368:	0b 4c       	mov	r12,	r11	;
    936a:	0b 5e       	add	r14,	r11	;

0000936c <.Loc.69.1>:
    936c:	0d 9c       	cmp	r12,	r13	;
    936e:	02 28       	jnc	$+6      	;abs 0x9374

00009370 <.L4>:
    9370:	0e 4c       	mov	r12,	r14	;

00009372 <.LVL2>:
    9372:	0f 3c       	jmp	$+32     	;abs 0x9392

00009374 <.L2>:
    9374:	0f 4d       	mov	r13,	r15	;
    9376:	0f 5e       	add	r14,	r15	;
    9378:	0c 9f       	cmp	r15,	r12	;
    937a:	fa 2f       	jc	$-10     	;abs 0x9370

0000937c <.LVL4>:
    937c:	0d 4f       	mov	r15,	r13	;

0000937e <.LVL5>:
    937e:	0e 8f       	sub	r15,	r14	;

00009380 <.L5>:
    9380:	0f 4d       	mov	r13,	r15	;
    9382:	0f 5e       	add	r14,	r15	;
    9384:	0f 93       	cmp	#0,	r15	;r3 As==00
    9386:	0c 24       	jz	$+26     	;abs 0x93a0

00009388 <.Loc.76.1>:
    9388:	3b 53       	add	#-1,	r11	;r3 As==11
    938a:	3d 53       	add	#-1,	r13	;r3 As==11

0000938c <.LVL8>:
    938c:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    9390:	f7 3f       	jmp	$-16     	;abs 0x9380

00009392 <.L3>:
    9392:	0b 9e       	cmp	r14,	r11	;
    9394:	05 24       	jz	$+12     	;abs 0x93a0

00009396 <.LVL10>:
    9396:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    939a:	1e 53       	inc	r14		;

0000939c <.LVL11>:
    939c:	1d 53       	inc	r13		;
    939e:	f9 3f       	jmp	$-12     	;abs 0x9392

000093a0 <.L9>:
    93a0:	30 41       	ret			

000093a2 <memset>:
    93a2:	0f 4c       	mov	r12,	r15	;
    93a4:	0e 5c       	add	r12,	r14	;

000093a6 <.L2>:
    93a6:	0f 9e       	cmp	r14,	r15	;

000093a8 <L0>:
    93a8:	04 24       	jz	$+10     	;abs 0x93b2

000093aa <.LVL3>:
    93aa:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    93ae:	1f 53       	inc	r15		;

000093b0 <.LVL4>:
    93b0:	fa 3f       	jmp	$-10     	;abs 0x93a6

000093b2 <.L5>:
    93b2:	30 41       	ret			
